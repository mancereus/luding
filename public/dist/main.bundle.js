/******/ (function(modules) { // webpackBootstrap
/******/ 	// install a JSONP callback for chunk loading
/******/ 	var parentJsonpFunction = window["webpackJsonp"];
/******/ 	window["webpackJsonp"] = function webpackJsonpCallback(chunkIds, moreModules, executeModules) {
/******/ 		// add "moreModules" to the modules object,
/******/ 		// then flag all "chunkIds" as loaded and fire callback
/******/ 		var moduleId, chunkId, i = 0, resolves = [], result;
/******/ 		for(;i < chunkIds.length; i++) {
/******/ 			chunkId = chunkIds[i];
/******/ 			if(installedChunks[chunkId]) {
/******/ 				resolves.push(installedChunks[chunkId][0]);
/******/ 			}
/******/ 			installedChunks[chunkId] = 0;
/******/ 		}
/******/ 		for(moduleId in moreModules) {
/******/ 			if(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
/******/ 				modules[moduleId] = moreModules[moduleId];
/******/ 			}
/******/ 		}
/******/ 		if(parentJsonpFunction) parentJsonpFunction(chunkIds, moreModules, executeModules);
/******/ 		while(resolves.length) {
/******/ 			resolves.shift()();
/******/ 		}
/******/
/******/ 	};
/******/
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// objects to store loaded and loading chunks
/******/ 	var installedChunks = {
/******/ 		6: 0
/******/ 	};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/ 	// This file contains only the entry chunk.
/******/ 	// The chunk loading function for additional chunks
/******/ 	__webpack_require__.e = function requireEnsure(chunkId) {
/******/ 		var installedChunkData = installedChunks[chunkId];
/******/ 		if(installedChunkData === 0) {
/******/ 			return new Promise(function(resolve) { resolve(); });
/******/ 		}
/******/
/******/ 		// a Promise means "currently loading".
/******/ 		if(installedChunkData) {
/******/ 			return installedChunkData[2];
/******/ 		}
/******/
/******/ 		// setup Promise in chunk cache
/******/ 		var promise = new Promise(function(resolve, reject) {
/******/ 			installedChunkData = installedChunks[chunkId] = [resolve, reject];
/******/ 		});
/******/ 		installedChunkData[2] = promise;
/******/
/******/ 		// start chunk loading
/******/ 		var head = document.getElementsByTagName('head')[0];
/******/ 		var script = document.createElement('script');
/******/ 		script.type = 'text/javascript';
/******/ 		script.charset = 'utf-8';
/******/ 		script.async = true;
/******/ 		script.timeout = 120000;
/******/
/******/ 		if (__webpack_require__.nc) {
/******/ 			script.setAttribute("nonce", __webpack_require__.nc);
/******/ 		}
/******/ 		script.src = __webpack_require__.p + "" + chunkId + ".bundle.js";
/******/ 		var timeout = setTimeout(onScriptComplete, 120000);
/******/ 		script.onerror = script.onload = onScriptComplete;
/******/ 		function onScriptComplete() {
/******/ 			// avoid mem leaks in IE.
/******/ 			script.onerror = script.onload = null;
/******/ 			clearTimeout(timeout);
/******/ 			var chunk = installedChunks[chunkId];
/******/ 			if(chunk !== 0) {
/******/ 				if(chunk) {
/******/ 					chunk[1](new Error('Loading chunk ' + chunkId + ' failed.'));
/******/ 				}
/******/ 				installedChunks[chunkId] = undefined;
/******/ 			}
/******/ 		};
/******/ 		head.appendChild(script);
/******/
/******/ 		return promise;
/******/ 	};
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "dist/";
/******/
/******/ 	// on error function for async loading
/******/ 	__webpack_require__.oe = function(err) { console.error(err); throw err; };
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 39);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(22);

__webpack_require__(54);

__webpack_require__(56);

__webpack_require__(57);

__webpack_require__(58);

__webpack_require__(59);

__webpack_require__(60);

__webpack_require__(61);

__webpack_require__(64);

// bc
Polymer.Base = Polymer.LegacyElementMixin(HTMLElement).prototype;

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


(function () {
  'use strict';

  var userPolymer = window.Polymer;

  /**
   * @namespace Polymer
   * @summary Polymer is a lightweight library built on top of the web
   *   standards-based Web Components API's, and makes it easy to build your
   *   own custom HTML elements.
   * @param {!PolymerInit} info Prototype for the custom element. It must contain
   *   an `is` property to specify the element name. Other properties populate
   *   the element prototype. The `properties`, `observers`, `hostAttributes`,
   *   and `listeners` properties are processed to create element features.
   * @return {!Object} Returns a custom element class for the given provided
   *   prototype `info` object. The name of the element if given by `info.is`.
   */
  window.Polymer = function (info) {
    return window.Polymer._polymerFn(info);
  };

  // support user settings on the Polymer object
  if (userPolymer) {
    Object.assign(Polymer, userPolymer);
  }

  // To be plugged by legacy implementation if loaded
  /* eslint-disable valid-jsdoc */
  /**
   * @param {!PolymerInit} info Prototype for the custom element. It must contain
   *   an `is` property to specify the element name. Other properties populate
   *   the element prototype. The `properties`, `observers`, `hostAttributes`,
   *   and `listeners` properties are processed to create element features.
   * @return {!Object} Returns a custom element class for the given provided
   *   prototype `info` object. The name of the element if given by `info.is`.
   */
  window.Polymer._polymerFn = function (info) {
    // eslint-disable-line no-unused-vars
    throw new Error('Load polymer.html to use the Polymer() function.');
  };
  /* eslint-enable */

  window.Polymer.version = '2.0.1';

  /* eslint-disable no-unused-vars */
  /*
  When using Closure Compiler, JSCompiler_renameProperty(property, object) is replaced by the munged name for object[property]
  We cannot alias this function, so we have to use a small shim that has the same behavior when not compiling.
  */
  window.JSCompiler_renameProperty = function (prop, obj) {
    return prop;
  };
  /* eslint-enable */
})();

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/* eslint-env browser */

var RegisterHtmlTemplate = function () {
  function RegisterHtmlTemplate() {
    _classCallCheck(this, RegisterHtmlTemplate);
  }

  _createClass(RegisterHtmlTemplate, null, [{
    key: 'register',

    /**
     * Create a `<template>` element to hold `<dom-module>` content.
     * This bit of code will execute in the context of the main document,
     * calling `importNode` on the `<template>`, which in turn triggers
     * the lifecycle of the `<dom-module>` and allows it to insert its
     * content into Polymer's global module map. When a Polymer element
     * boots up it will fetch its template from this module map.
     * https://github.com/Polymer/polymer/blob/master/lib/mixins/element-mixin.html#L501-L538
     * @param {string} val A `<dom-module>` as an HTML string
     */
    value: function register(val) {
      var content = void 0;
      var template = document.createElement('template');
      template.innerHTML = val;
      if (template.content) {
        content = template.content; // eslint-disable-line prefer-destructuring
      } else {
        content = document.createDocumentFragment();
        while (template.firstChild) {
          content.appendChild(template.firstChild);
        }
      }
      document.importNode(content, true);
    }
    /**
     * Content that will be injected into the main document. This is primarily
     * for things like `<iron-iconset>` and `<custom-style>` which do not have
     * templates but rely on HTML Imports ability to apply content to the main
     * document.
     * @param {string} val An HTML string
     */

  }, {
    key: 'toBody',
    value: function toBody(val) {
      var trimmedVal = val.trim();
      if (trimmedVal) {
        var div = document.createElement('div');
        div.innerHTML = trimmedVal;
        if (div.firstChild) {
          if (document.body) {
            document.body.insertBefore(div.firstChild, document.body.firstChild);
          } else {
            document.addEventListener('DOMContentLoaded', function () {
              document.body.insertBefore(div.firstChild, document.body.firstChild);
            });
          }
        }
      }
    }
  }]);

  return RegisterHtmlTemplate;
}();

module.exports = RegisterHtmlTemplate;

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(1);

(function () {

  'use strict';

  // unique global id for deduping mixins.

  var dedupeId = 0;

  /**
   * @constructor
   * @extends {Function}
   */
  function MixinFunction() {}
  /** @type {(WeakMap | undefined)} */
  MixinFunction.prototype.__mixinApplications;
  /** @type {(Object | undefined)} */
  MixinFunction.prototype.__mixinSet;

  /* eslint-disable valid-jsdoc */
  /**
   * Wraps an ES6 class expression mixin such that the mixin is only applied
   * if it has not already been applied its base argument.  Also memoizes mixin
   * applications.
   *
   * @memberof Polymer
   * @template T
   * @param {T} mixin ES6 class expression mixin to wrap
   * @suppress {invalidCasts}
   */
  Polymer.dedupingMixin = function (mixin) {
    var mixinApplications = /** @type {!MixinFunction} */mixin.__mixinApplications;
    if (!mixinApplications) {
      mixinApplications = new WeakMap();
      /** @type {!MixinFunction} */mixin.__mixinApplications = mixinApplications;
    }
    // maintain a unique id for each mixin
    var mixinDedupeId = dedupeId++;
    function dedupingMixin(base) {
      var baseSet = /** @type {!MixinFunction} */base.__mixinSet;
      if (baseSet && baseSet[mixinDedupeId]) {
        return base;
      }
      var map = mixinApplications;
      var extended = map.get(base);
      if (!extended) {
        extended = /** @type {!Function} */mixin(base);
        map.set(base, extended);
      }
      // copy inherited mixin set from the extended class, or the base class
      // NOTE: we avoid use of Set here because some browser (IE11)
      // cannot extend a base Set via the constructor.
      var mixinSet = Object.create( /** @type {!MixinFunction} */extended.__mixinSet || baseSet || null);
      mixinSet[mixinDedupeId] = true;
      /** @type {!MixinFunction} */extended.__mixinSet = mixinSet;
      return extended;
    }

    return dedupingMixin;
  };
  /* eslint-enable valid-jsdoc */
})();

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

__webpack_require__(36);

__webpack_require__(68);

/**
 * `Polymer.AppScrollEffectsBehavior` provides an interface that allows an element to use scrolls effects.
 *
 * ### Importing the app-layout effects
 *
 * app-layout provides a set of scroll effects that can be used by explicitly importing
 * `app-scroll-effects.html`:
 *
 * ```html
 * <link rel="import" href="/bower_components/app-layout/app-scroll-effects/app-scroll-effects.html">
 * ```
 *
 * The scroll effects can also be used by individually importing
 * `app-layout/app-scroll-effects/effects/[effectName].html`. For example:
 *
 * ```html
 *  <link rel="import" href="/bower_components/app-layout/app-scroll-effects/effects/waterfall.html">
 * ```
 *
 * ### Consuming effects
 *
 * Effects can be consumed via the `effects` property. For example:
 *
 * ```html
 * <app-header effects="waterfall"></app-header>
 * ```
 *
 * ### Creating scroll effects
 *
 * You may want to create a custom scroll effect if you need to modify the CSS of an element
 * based on the scroll position.
 *
 * A scroll effect definition is an object with `setUp()`, `tearDown()` and `run()` functions.
 *
 * To register the effect, you can use `Polymer.AppLayout.registerEffect(effectName, effectDef)`
 * For example, let's define an effect that resizes the header's logo:
 *
 * ```js
 * Polymer.AppLayout.registerEffect('resizable-logo', {
 *   setUp: function(config) {
 *     // the effect's config is passed to the setUp.
 *     this._fxResizeLogo = { logo: Polymer.dom(this).querySelector('[logo]') };
 *   },
 *
 *   run: function(progress) {
 *      // the progress of the effect
 *      this.transform('scale3d(' + progress + ', '+ progress +', 1)',  this._fxResizeLogo.logo);
 *   },
 *
 *   tearDown: function() {
 *      // clean up and reset of states
 *      delete this._fxResizeLogo;
 *   }
 * });
 * ```
 * Now, you can consume the effect:
 *
 * ```html
 * <app-header id="appHeader" effects="resizable-logo">
 *   <img logo src="logo.svg">
 * </app-header>
 * ```
 *
 * ### Imperative API
 *
 * ```js
 * var logoEffect = appHeader.createEffect('resizable-logo', effectConfig);
 * // run the effect: logoEffect.run(progress);
 * // tear down the effect: logoEffect.tearDown();
 * ```
 *
 * ### Configuring effects
 *
 * For effects installed via the `effects` property, their configuration can be set
 * via the `effectsConfig` property. For example:
 *
 * ```html
 * <app-header effects="waterfall"
 *   effects-config='{"waterfall": {"startsAt": 0, "endsAt": 0.5}}'>
 * </app-header>
 * ```
 *
 * All effects have a `startsAt` and `endsAt` config property. They specify at what
 * point the effect should start and end. This value goes from 0 to 1 inclusive.
 *
 * @polymerBehavior
 */
Polymer.AppScrollEffectsBehavior = [Polymer.IronScrollTargetBehavior, {

  properties: {

    /**
     * A space-separated list of the effects names that will be triggered when the user scrolls.
     * e.g. `waterfall parallax-background` installs the `waterfall` and `parallax-background`.
     */
    effects: {
      type: String
    },

    /**
     * An object that configurates the effects installed via the `effects` property. e.g.
     * ```js
     *  element.effectsConfig = {
     *   "blend-background": {
     *     "startsAt": 0.5
     *   }
     * };
     * ```
     * Every effect has at least two config properties: `startsAt` and `endsAt`.
     * These properties indicate when the event should start and end respectively
     * and relative to the overall element progress. So for example, if `blend-background`
     * starts at `0.5`, the effect will only start once the current element reaches 0.5
     * of its progress. In this context, the progress is a value in the range of `[0, 1]`
     * that indicates where this element is on the screen relative to the viewport.
     */
    effectsConfig: {
      type: Object,
      value: function value() {
        return {};
      }
    },

    /**
     * Disables CSS transitions and scroll effects on the element.
     */
    disabled: {
      type: Boolean,
      reflectToAttribute: true,
      value: false
    },

    /**
     * Allows to set a `scrollTop` threshold. When greater than 0, `thresholdTriggered`
     * is true only when the scroll target's `scrollTop` has reached this value.
     *
     * For example, if `threshold = 100`, `thresholdTriggered` is true when the `scrollTop`
     * is at least `100`.
     */
    threshold: {
      type: Number,
      value: 0
    },

    /**
     * True if the `scrollTop` threshold (set in `scrollTopThreshold`) has
     * been reached.
     */
    thresholdTriggered: {
      type: Boolean,
      notify: true,
      readOnly: true,
      reflectToAttribute: true
    }
  },

  observers: ['_effectsChanged(effects, effectsConfig, isAttached)'],

  /**
   * Updates the scroll state. This method should be overridden
   * by the consumer of this behavior.
   *
   * @method _updateScrollState
   */
  _updateScrollState: function _updateScrollState() {},

  /**
   * Returns true if the current element is on the screen.
   * That is, visible in the current viewport. This method should be
   * overridden by the consumer of this behavior.
   *
   * @method isOnScreen
   * @return {boolean}
   */
  isOnScreen: function isOnScreen() {
    return false;
  },

  /**
   * Returns true if there's content below the current element. This method
   * should be overridden by the consumer of this behavior.
   *
   * @method isContentBelow
   * @return {boolean}
   */
  isContentBelow: function isContentBelow() {
    return false;
  },

  /**
   * List of effects handlers that will take place during scroll.
   *
   * @type {Array<Function>}
   */
  _effectsRunFn: null,

  /**
   * List of the effects definitions installed via the `effects` property.
   *
   * @type {Array<Object>}
   */
  _effects: null,

  /**
   * The clamped value of `_scrollTop`.
   * @type number
   */
  get _clampedScrollTop() {
    return Math.max(0, this._scrollTop);
  },

  detached: function detached() {
    this._tearDownEffects();
  },

  /**
   * Creates an effect object from an effect's name that can be used to run
   * effects programmatically.
   *
   * @method createEffect
   * @param {string} effectName The effect's name registered via `Polymer.AppLayout.registerEffect`.
   * @param {Object=} effectConfig The effect config object. (Optional)
   * @return {Object} An effect object with the following functions:
   *
   *  * `effect.setUp()`, Sets up the requirements for the effect.
   *       This function is called automatically before the `effect` function returns.
   *  * `effect.run(progress, y)`, Runs the effect given a `progress`.
   *  * `effect.tearDown()`, Cleans up any DOM nodes or element references used by the effect.
   *
   * Example:
   * ```js
   * var parallax = element.createEffect('parallax-background');
   * // runs the effect
   * parallax.run(0.5, 0);
   * ```
   */
  createEffect: function createEffect(effectName, effectConfig) {
    var effectDef = Polymer.AppLayout._scrollEffects[effectName];
    if (!effectDef) {
      throw new ReferenceError(this._getUndefinedMsg(effectName));
    }
    var prop = this._boundEffect(effectDef, effectConfig || {});
    prop.setUp();
    return prop;
  },

  /**
   * Called when `effects` or `effectsConfig` changes.
   */
  _effectsChanged: function _effectsChanged(effects, effectsConfig, isAttached) {
    this._tearDownEffects();

    if (!effects || !isAttached) {
      return;
    }
    effects.split(' ').forEach(function (effectName) {
      var effectDef;
      if (effectName !== '') {
        if (effectDef = Polymer.AppLayout._scrollEffects[effectName]) {
          this._effects.push(this._boundEffect(effectDef, effectsConfig[effectName]));
        } else {
          console.warn(this._getUndefinedMsg(effectName));
        }
      }
    }, this);

    this._setUpEffect();
  },

  /**
   * Forces layout
   */
  _layoutIfDirty: function _layoutIfDirty() {
    return this.offsetWidth;
  },

  /**
   * Returns an effect object bound to the current context.
   *
   * @param {Object} effectDef
   * @param {Object=} effectsConfig The effect config object if the effect accepts config values. (Optional)
   */
  _boundEffect: function _boundEffect(effectDef, effectsConfig) {
    effectsConfig = effectsConfig || {};
    var startsAt = parseFloat(effectsConfig.startsAt || 0);
    var endsAt = parseFloat(effectsConfig.endsAt || 1);
    var deltaS = endsAt - startsAt;
    var noop = function noop() {};
    // fast path if possible
    var runFn = startsAt === 0 && endsAt === 1 ? effectDef.run : function (progress, y) {
      effectDef.run.call(this, Math.max(0, (progress - startsAt) / deltaS), y);
    };
    return {
      setUp: effectDef.setUp ? effectDef.setUp.bind(this, effectsConfig) : noop,
      run: effectDef.run ? runFn.bind(this) : noop,
      tearDown: effectDef.tearDown ? effectDef.tearDown.bind(this) : noop
    };
  },

  /**
   * Sets up the effects.
   */
  _setUpEffect: function _setUpEffect() {
    if (this.isAttached && this._effects) {
      this._effectsRunFn = [];
      this._effects.forEach(function (effectDef) {
        // install the effect only if no error was reported
        if (effectDef.setUp() !== false) {
          this._effectsRunFn.push(effectDef.run);
        }
      }, this);
    }
  },

  /**
   * Tears down the effects.
   */
  _tearDownEffects: function _tearDownEffects() {
    if (this._effects) {
      this._effects.forEach(function (effectDef) {
        effectDef.tearDown();
      });
    }
    this._effectsRunFn = [];
    this._effects = [];
  },

  /**
   * Runs the effects.
   *
   * @param {number} p The progress
   * @param {number} y The top position of the current element relative to the viewport.
   */
  _runEffects: function _runEffects(p, y) {
    if (this._effectsRunFn) {
      this._effectsRunFn.forEach(function (run) {
        run(p, y);
      });
    }
  },

  /**
   * Overrides the `_scrollHandler`.
   */
  _scrollHandler: function _scrollHandler() {
    if (!this.disabled) {
      var scrollTop = this._clampedScrollTop;
      this._updateScrollState(scrollTop);
      if (this.threshold > 0) {
        this._setThresholdTriggered(scrollTop >= this.threshold);
      }
    }
  },

  /**
   * Override this method to return a reference to a node in the local DOM.
   * The node is consumed by a scroll effect.
   *
   * @param {string} id The id for the node.
   */
  _getDOMRef: function _getDOMRef(id) {
    console.warn('_getDOMRef', '`' + id + '` is undefined');
  },

  _getUndefinedMsg: function _getUndefinedMsg(effectName) {
    return 'Scroll effect `' + effectName + '` is undefined. ' + 'Did you forget to import app-layout/app-scroll-effects/effects/' + effectName + '.html ?';
  }

}];

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

var RegisterHtmlTemplate = __webpack_require__(2);

RegisterHtmlTemplate.toBody("<custom-style> <style is=custom-style>html{--layout:{display:-ms-flexbox;display:-webkit-flex;display:flex};--layout-inline:{display:-ms-inline-flexbox;display:-webkit-inline-flex;display:inline-flex};--layout-horizontal:{@apply --layout;-ms-flex-direction:row;-webkit-flex-direction:row;flex-direction:row};--layout-horizontal-reverse:{@apply --layout;-ms-flex-direction:row-reverse;-webkit-flex-direction:row-reverse;flex-direction:row-reverse};--layout-vertical:{@apply --layout;-ms-flex-direction:column;-webkit-flex-direction:column;flex-direction:column};--layout-vertical-reverse:{@apply --layout;-ms-flex-direction:column-reverse;-webkit-flex-direction:column-reverse;flex-direction:column-reverse};--layout-wrap:{-ms-flex-wrap:wrap;-webkit-flex-wrap:wrap;flex-wrap:wrap};--layout-wrap-reverse:{-ms-flex-wrap:wrap-reverse;-webkit-flex-wrap:wrap-reverse;flex-wrap:wrap-reverse};--layout-flex-auto:{-ms-flex:1 1 auto;-webkit-flex:1 1 auto;flex:1 1 auto};--layout-flex-none:{-ms-flex:none;-webkit-flex:none;flex:none};--layout-flex:{-ms-flex:1 1 .000000001px;-webkit-flex:1;flex:1;-webkit-flex-basis:.000000001px;flex-basis:.000000001px};--layout-flex-2:{-ms-flex:2;-webkit-flex:2;flex:2};--layout-flex-3:{-ms-flex:3;-webkit-flex:3;flex:3};--layout-flex-4:{-ms-flex:4;-webkit-flex:4;flex:4};--layout-flex-5:{-ms-flex:5;-webkit-flex:5;flex:5};--layout-flex-6:{-ms-flex:6;-webkit-flex:6;flex:6};--layout-flex-7:{-ms-flex:7;-webkit-flex:7;flex:7};--layout-flex-8:{-ms-flex:8;-webkit-flex:8;flex:8};--layout-flex-9:{-ms-flex:9;-webkit-flex:9;flex:9};--layout-flex-10:{-ms-flex:10;-webkit-flex:10;flex:10};--layout-flex-11:{-ms-flex:11;-webkit-flex:11;flex:11};--layout-flex-12:{-ms-flex:12;-webkit-flex:12;flex:12};--layout-start:{-ms-flex-align:start;-webkit-align-items:flex-start;align-items:flex-start};--layout-center:{-ms-flex-align:center;-webkit-align-items:center;align-items:center};--layout-end:{-ms-flex-align:end;-webkit-align-items:flex-end;align-items:flex-end};--layout-baseline:{-ms-flex-align:baseline;-webkit-align-items:baseline;align-items:baseline};--layout-start-justified:{-ms-flex-pack:start;-webkit-justify-content:flex-start;justify-content:flex-start};--layout-center-justified:{-ms-flex-pack:center;-webkit-justify-content:center;justify-content:center};--layout-end-justified:{-ms-flex-pack:end;-webkit-justify-content:flex-end;justify-content:flex-end};--layout-around-justified:{-ms-flex-pack:distribute;-webkit-justify-content:space-around;justify-content:space-around};--layout-justified:{-ms-flex-pack:justify;-webkit-justify-content:space-between;justify-content:space-between};--layout-center-center:{@apply --layout-center;@apply --layout-center-justified;};--layout-self-start:{-ms-align-self:flex-start;-webkit-align-self:flex-start;align-self:flex-start};--layout-self-center:{-ms-align-self:center;-webkit-align-self:center;align-self:center};--layout-self-end:{-ms-align-self:flex-end;-webkit-align-self:flex-end;align-self:flex-end};--layout-self-stretch:{-ms-align-self:stretch;-webkit-align-self:stretch;align-self:stretch};--layout-self-baseline:{-ms-align-self:baseline;-webkit-align-self:baseline;align-self:baseline};--layout-start-aligned:{-ms-flex-line-pack:start;-ms-align-content:flex-start;-webkit-align-content:flex-start;align-content:flex-start};--layout-end-aligned:{-ms-flex-line-pack:end;-ms-align-content:flex-end;-webkit-align-content:flex-end;align-content:flex-end};--layout-center-aligned:{-ms-flex-line-pack:center;-ms-align-content:center;-webkit-align-content:center;align-content:center};--layout-between-aligned:{-ms-flex-line-pack:justify;-ms-align-content:space-between;-webkit-align-content:space-between;align-content:space-between};--layout-around-aligned:{-ms-flex-line-pack:distribute;-ms-align-content:space-around;-webkit-align-content:space-around;align-content:space-around};--layout-block:{display:block};--layout-invisible:{visibility:hidden!important};--layout-relative:{position:relative};--layout-fit:{position:absolute;top:0;right:0;bottom:0;left:0};--layout-scroll:{-webkit-overflow-scrolling:touch;overflow:auto};--layout-fullbleed:{margin:0;height:100vh};--layout-fixed-top:{position:fixed;top:0;left:0;right:0};--layout-fixed-right:{position:fixed;top:0;right:0;bottom:0};--layout-fixed-bottom:{position:fixed;right:0;bottom:0;left:0};--layout-fixed-left:{position:fixed;top:0;bottom:0;left:0};}</style> </custom-style>");

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(19);

(function () {
  'use strict';

  /**
   * Base class that provides the core API for Polymer's meta-programming
   * features including template stamping, data-binding, attribute deserialization,
   * and property change observation.
   *
   * @customElement
   * @polymer
   * @memberof Polymer
   * @constructor
   * @implements {Polymer_ElementMixin}
   * @extends HTMLElement
   * @appliesMixin Polymer.ElementMixin
   * @summary Custom element base class that provides the core API for Polymer's
   *   key meta-programming features including template stamping, data-binding,
   *   attribute deserialization, and property change observation
   */

  var Element = Polymer.ElementMixin(HTMLElement);
  /**
   * @constructor
   * @implements {Polymer_ElementMixin}
   * @extends {HTMLElement}
   */
  Polymer.Element = Element;
})();

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(1);

(function () {
  'use strict';

  var CSS_URL_RX = /(url\()([^)]*)(\))/g;
  var ABS_URL = /(^\/)|(^#)|(^[\w-\d]*:)/;
  var workingURL = void 0;
  var resolveDoc = void 0;
  /**
   * Resolves the given URL against the provided `baseUri'.
   *
   * @memberof Polymer.ResolveUrl
   * @param {string} url Input URL to resolve
   * @param {?string=} baseURI Base URI to resolve the URL against
   * @return {string} resolved URL
   */
  function resolveUrl(url, baseURI) {
    if (url && ABS_URL.test(url)) {
      return url;
    }
    // Lazy feature detection.
    if (workingURL === undefined) {
      workingURL = false;
      try {
        var u = new URL('b', 'http://a');
        u.pathname = 'c%20d';
        workingURL = u.href === 'http://a/c%20d';
      } catch (e) {
        // silently fail
      }
    }
    if (!baseURI) {
      baseURI = document.baseURI || window.location.href;
    }
    if (workingURL) {
      return new URL(url, baseURI).href;
    }
    // Fallback to creating an anchor into a disconnected document.
    if (!resolveDoc) {
      resolveDoc = document.implementation.createHTMLDocument('temp');
      resolveDoc.base = resolveDoc.createElement('base');
      resolveDoc.head.appendChild(resolveDoc.base);
      resolveDoc.anchor = resolveDoc.createElement('a');
      resolveDoc.body.appendChild(resolveDoc.anchor);
    }
    resolveDoc.base.href = baseURI;
    resolveDoc.anchor.href = url;
    return resolveDoc.anchor.href || url;
  }

  /**
   * Resolves any relative URL's in the given CSS text against the provided
   * `ownerDocument`'s `baseURI`.
   *
   * @memberof Polymer.ResolveUrl
   * @param {string} cssText CSS text to process
   * @param {string} baseURI Base URI to resolve the URL against
   * @return {string} Processed CSS text with resolved URL's
   */
  function resolveCss(cssText, baseURI) {
    return cssText.replace(CSS_URL_RX, function (m, pre, url, post) {
      return pre + '\'' + resolveUrl(url.replace(/["']/g, ''), baseURI) + '\'' + post;
    });
  }

  /**
   * Returns a path from a given `url`. The path includes the trailing
   * `/` from the url.
   *
   * @memberof Polymer.ResolveUrl
   * @param {string} url Input URL to transform
   * @return {string} resolved path
   */
  function pathFromUrl(url) {
    return url.substring(0, url.lastIndexOf('/') + 1);
  }

  /**
   * Module with utilities for resolving relative URL's.
   *
   * @namespace
   * @memberof Polymer
   * @summary Module with utilities for resolving relative URL's.
   */
  Polymer.ResolveUrl = {
    resolveCss: resolveCss,
    resolveUrl: resolveUrl,
    pathFromUrl: pathFromUrl
  };
})();

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(1);

(function () {

  'use strict';

  /** @typedef {{run: function(function(), number=):number, cancel: function(number)}} */

  var AsyncInterface = void 0; // eslint-disable-line no-unused-vars

  // Microtask implemented using Mutation Observer
  var microtaskCurrHandle = 0;
  var microtaskLastHandle = 0;
  var microtaskCallbacks = [];
  var microtaskNodeContent = 0;
  var microtaskNode = document.createTextNode('');
  new window.MutationObserver(microtaskFlush).observe(microtaskNode, { characterData: true });

  function microtaskFlush() {
    var len = microtaskCallbacks.length;
    for (var i = 0; i < len; i++) {
      var cb = microtaskCallbacks[i];
      if (cb) {
        try {
          cb();
        } catch (e) {
          setTimeout(function () {
            throw e;
          });
        }
      }
    }
    microtaskCallbacks.splice(0, len);
    microtaskLastHandle += len;
  }

  /**
   * Module that provides a number of strategies for enqueuing asynchronous
   * tasks.  Each sub-module provides a standard `run(fn)` interface that returns a
   * handle, and a `cancel(handle)` interface for canceling async tasks before
   * they run.
   *
   * @namespace
   * @memberof Polymer
   * @summary Module that provides a number of strategies for enqueuing asynchronous
   * tasks.
   */
  Polymer.Async = {

    /**
     * Async interface wrapper around `setTimeout`.
     *
     * @namespace
     * @memberof Polymer.Async
     * @summary Async interface wrapper around `setTimeout`.
     */
    timeOut: {
      /**
       * Returns a sub-module with the async interface providing the provided
       * delay.
       *
       * @memberof Polymer.Async.timeOut
       * @param {number} delay Time to wait before calling callbacks in ms
       * @return {AsyncInterface} An async timeout interface
       */
      after: function after(delay) {
        return {
          run: function run(fn) {
            return setTimeout(fn, delay);
          },

          cancel: window.clearTimeout.bind(window)
        };
      },

      /**
       * Enqueues a function called in the next task.
       *
       * @memberof Polymer.Async.timeOut
       * @param {Function} fn Callback to run
       * @return {number} Handle used for canceling task
       */
      run: window.setTimeout.bind(window),
      /**
       * Cancels a previously enqueued `timeOut` callback.
       *
       * @memberof Polymer.Async.timeOut
       * @param {number} handle Handle returned from `run` of callback to cancel
       */
      cancel: window.clearTimeout.bind(window)
    },

    /**
     * Async interface wrapper around `requestAnimationFrame`.
     *
     * @namespace
     * @memberof Polymer.Async
     * @summary Async interface wrapper around `requestAnimationFrame`.
     */
    animationFrame: {
      /**
       * Enqueues a function called at `requestAnimationFrame` timing.
       *
       * @memberof Polymer.Async.animationFrame
       * @param {Function} fn Callback to run
       * @return {number} Handle used for canceling task
       */
      run: window.requestAnimationFrame.bind(window),
      /**
       * Cancels a previously enqueued `animationFrame` callback.
       *
       * @memberof Polymer.Async.timeOut
       * @param {number} handle Handle returned from `run` of callback to cancel
       */
      cancel: window.cancelAnimationFrame.bind(window)
    },

    /**
     * Async interface wrapper around `requestIdleCallback`.  Falls back to
     * `setTimeout` on browsers that do not support `requestIdleCallback`.
     *
     * @namespace
     * @memberof Polymer.Async
     * @summary Async interface wrapper around `requestIdleCallback`.
     */
    idlePeriod: {
      /**
       * Enqueues a function called at `requestIdleCallback` timing.
       *
       * @memberof Polymer.Async.idlePeriod
       * @param {function(IdleDeadline)} fn Callback to run
       * @return {number} Handle used for canceling task
       */
      run: function run(fn) {
        return window.requestIdleCallback ? window.requestIdleCallback(fn) : window.setTimeout(fn, 16);
      },

      /**
       * Cancels a previously enqueued `idlePeriod` callback.
       *
       * @memberof Polymer.Async.idlePeriod
       * @param {number} handle Handle returned from `run` of callback to cancel
       */
      cancel: function cancel(handle) {
        window.cancelIdleCallback ? window.cancelIdleCallback(handle) : window.clearTimeout(handle);
      }
    },

    /**
     * Async interface for enqueueing callbacks that run at microtask timing.
     *
     * Note that microtask timing is achieved via a single `MutationObserver`,
     * and thus callbacks enqueued with this API will all run in a single
     * batch, and not interleaved with other microtasks such as promises.
     * Promises are avoided as an implementation choice for the time being
     * due to Safari bugs that cause Promises to lack microtask guarantees.
     *
     * @namespace
     * @memberof Polymer.Async
     * @summary Async interface for enqueueing callbacks that run at microtask
     *   timing.
     */
    microTask: {

      /**
       * Enqueues a function called at microtask timing.
       *
       * @memberof Polymer.Async.microTask
       * @param {Function} callback Callback to run
       * @return {number} Handle used for canceling task
       */
      run: function run(callback) {
        microtaskNode.textContent = microtaskNodeContent++;
        microtaskCallbacks.push(callback);
        return microtaskCurrHandle++;
      },


      /**
       * Cancels a previously enqueued `microTask` callback.
       *
       * @memberof Polymer.Async.microTask
       * @param {number} handle Handle returned from `run` of callback to cancel
       */
      cancel: function cancel(handle) {
        var idx = handle - microtaskLastHandle;
        if (idx >= 0) {
          if (!microtaskCallbacks[idx]) {
            throw new Error('invalid async handle: ' + handle);
          }
          microtaskCallbacks[idx] = null;
        }
      }
    }
  };
})();

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

__webpack_require__(3);

(function () {
  'use strict';

  // Common implementation for mixin & behavior

  function mutablePropertyChange(inst, property, value, old, mutableData) {
    var isObject = void 0;
    if (mutableData) {
      isObject = (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && value !== null;
      // Pull `old` for Objects from temp cache, but treat `null` as a primitive
      if (isObject) {
        old = inst.__dataTemp[property];
      }
    }
    // Strict equality check, but return false for NaN===NaN
    var shouldChange = old !== value && (old === old || value === value);
    // Objects are stored in temporary cache (cleared at end of
    // turn), which is used for dirty-checking
    if (isObject && shouldChange) {
      inst.__dataTemp[property] = value;
    }
    return shouldChange;
  }

  /**
   * Element class mixin to skip strict dirty-checking for objects and arrays
   * (always consider them to be "dirty"), for use on elements utilizing
   * `Polymer.PropertyEffects`
   *
   * By default, `Polymer.PropertyEffects` performs strict dirty checking on
   * objects, which means that any deep modifications to an object or array will
   * not be propagated unless "immutable" data patterns are used (i.e. all object
   * references from the root to the mutation were changed).
   *
   * Polymer also provides a proprietary data mutation and path notification API
   * (e.g. `notifyPath`, `set`, and array mutation API's) that allow efficient
   * mutation and notification of deep changes in an object graph to all elements
   * bound to the same object graph.
   *
   * In cases where neither immutable patterns nor the data mutation API can be
   * used, applying this mixin will cause Polymer to skip dirty checking for
   * objects and arrays (always consider them to be "dirty").  This allows a
   * user to make a deep modification to a bound object graph, and then either
   * simply re-set the object (e.g. `this.items = this.items`) or call `notifyPath`
   * (e.g. `this.notifyPath('items')`) to update the tree.  Note that all
   * elements that wish to be updated based on deep mutations must apply this
   * mixin or otherwise skip strict dirty checking for objects/arrays.
   *
   * In order to make the dirty check strategy configurable, see
   * `Polymer.OptionalMutableData`.
   *
   * Note, the performance characteristics of propagating large object graphs
   * will be worse as opposed to using strict dirty checking with immutable
   * patterns or Polymer's path notification API.
   *
   * @mixinFunction
   * @polymer
   * @memberof Polymer
   * @summary Element class mixin to skip strict dirty-checking for objects
   *   and arrays
   */
  Polymer.MutableData = Polymer.dedupingMixin(function (superClass) {

    /**
     * @polymer
     * @mixinClass
     * @implements {Polymer_MutableData}
     */
    var MutableData = function (_superClass) {
      _inherits(MutableData, _superClass);

      function MutableData() {
        _classCallCheck(this, MutableData);

        return _possibleConstructorReturn(this, (MutableData.__proto__ || Object.getPrototypeOf(MutableData)).apply(this, arguments));
      }

      _createClass(MutableData, [{
        key: '_shouldPropertyChange',

        /**
         * Overrides `Polymer.PropertyEffects` to provide option for skipping
         * strict equality checking for Objects and Arrays.
         *
         * This method pulls the value to dirty check against from the `__dataTemp`
         * cache (rather than the normal `__data` cache) for Objects.  Since the temp
         * cache is cleared at the end of a turn, this implementation allows
         * side-effects of deep object changes to be processed by re-setting the
         * same object (using the temp cache as an in-turn backstop to prevent
         * cycles due to 2-way notification).
         *
         * @param {string} property Property name
         * @param {*} value New property value
         * @param {*} old Previous property value
         * @return {boolean} Whether the property should be considered a change
         * @protected
         */
        value: function _shouldPropertyChange(property, value, old) {
          return mutablePropertyChange(this, property, value, old, true);
        }
      }]);

      return MutableData;
    }(superClass);
    /** @type {boolean} */


    MutableData.prototype.mutableData = false;

    return MutableData;
  });

  /**
   * Element class mixin to add the optional ability to skip strict
   * dirty-checking for objects and arrays (always consider them to be
   * "dirty") by setting a `mutable-data` attribute on an element instance.
   *
   * By default, `Polymer.PropertyEffects` performs strict dirty checking on
   * objects, which means that any deep modifications to an object or array will
   * not be propagated unless "immutable" data patterns are used (i.e. all object
   * references from the root to the mutation were changed).
   *
   * Polymer also provides a proprietary data mutation and path notification API
   * (e.g. `notifyPath`, `set`, and array mutation API's) that allow efficient
   * mutation and notification of deep changes in an object graph to all elements
   * bound to the same object graph.
   *
   * In cases where neither immutable patterns nor the data mutation API can be
   * used, applying this mixin will allow Polymer to skip dirty checking for
   * objects and arrays (always consider them to be "dirty").  This allows a
   * user to make a deep modification to a bound object graph, and then either
   * simply re-set the object (e.g. `this.items = this.items`) or call `notifyPath`
   * (e.g. `this.notifyPath('items')`) to update the tree.  Note that all
   * elements that wish to be updated based on deep mutations must apply this
   * mixin or otherwise skip strict dirty checking for objects/arrays.
   *
   * While this mixin adds the ability to forgo Object/Array dirty checking,
   * the `mutableData` flag defaults to false and must be set on the instance.
   *
   * Note, the performance characteristics of propagating large object graphs
   * will be worse by relying on `mutableData: true` as opposed to using
   * strict dirty checking with immutable patterns or Polymer's path notification
   * API.
   *
   * @mixinFunction
   * @polymer
   * @memberof Polymer
   * @summary Element class mixin to optionally skip strict dirty-checking
   *   for objects and arrays
   */
  Polymer.OptionalMutableData = Polymer.dedupingMixin(function (superClass) {

    /**
     * @mixinClass
     * @polymer
     * @implements {Polymer_OptionalMutableData}
     */
    var OptionalMutableData = function (_superClass2) {
      _inherits(OptionalMutableData, _superClass2);

      function OptionalMutableData() {
        _classCallCheck(this, OptionalMutableData);

        return _possibleConstructorReturn(this, (OptionalMutableData.__proto__ || Object.getPrototypeOf(OptionalMutableData)).apply(this, arguments));
      }

      _createClass(OptionalMutableData, [{
        key: '_shouldPropertyChange',


        /**
         * Overrides `Polymer.PropertyEffects` to provide option for skipping
         * strict equality checking for Objects and Arrays.
         *
         * When `this.mutableData` is true on this instance, this method
         * pulls the value to dirty check against from the `__dataTemp` cache
         * (rather than the normal `__data` cache) for Objects.  Since the temp
         * cache is cleared at the end of a turn, this implementation allows
         * side-effects of deep object changes to be processed by re-setting the
         * same object (using the temp cache as an in-turn backstop to prevent
         * cycles due to 2-way notification).
         *
         * @param {string} property Property name
         * @param {*} value New property value
         * @param {*} old Previous property value
         * @return {boolean} Whether the property should be considered a change
         * @protected
         */
        value: function _shouldPropertyChange(property, value, old) {
          return mutablePropertyChange(this, property, value, old, this.mutableData);
        }
      }], [{
        key: 'properties',
        get: function get() {
          return {
            /**
             * Instance-level flag for configuring the dirty-checking strategy
             * for this element.  When true, Objects and Arrays will skip dirty
             * checking, otherwise strict equality checking will be used.
             */
            mutableData: Boolean
          };
        }
      }]);

      return OptionalMutableData;
    }(superClass);

    return OptionalMutableData;
  });

  // Export for use by legacy behavior
  Polymer.MutableData._mutablePropertyChange = mutablePropertyChange;
})();

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(1);

(function () {
  'use strict';

  var caseMap = {};
  var DASH_TO_CAMEL = /-[a-z]/g;
  var CAMEL_TO_DASH = /([A-Z])/g;

  /**
   * Module with utilities for converting between "dash-case" and "camelCase"
   * identifiers.
   *
   * @namespace
   * @memberof Polymer
   * @summary Module that provides utilities for converting between "dash-case"
   *   and "camelCase".
   */
  var CaseMap = {

    /**
     * Converts "dash-case" identifier (e.g. `foo-bar-baz`) to "camelCase"
     * (e.g. `fooBarBaz`).
     *
     * @memberof Polymer.CaseMap
     * @param {string} dash Dash-case identifier
     * @return {string} Camel-case representation of the identifier
     */
    dashToCamelCase: function dashToCamelCase(dash) {
      return caseMap[dash] || (caseMap[dash] = dash.indexOf('-') < 0 ? dash : dash.replace(DASH_TO_CAMEL, function (m) {
        return m[1].toUpperCase();
      }));
    },


    /**
     * Converts "camelCase" identifier (e.g. `fooBarBaz`) to "dash-case"
     * (e.g. `foo-bar-baz`).
     *
     * @memberof Polymer.CaseMap
     * @param {string} camel Camel-case identifier
     * @return {string} Dash-case representation of the identifier
     */
    camelToDashCase: function camelToDashCase(camel) {
      return caseMap[camel] || (caseMap[camel] = camel.replace(CAMEL_TO_DASH, '-$1').toLowerCase());
    }
  };

  Polymer.CaseMap = CaseMap;
})();

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

__webpack_require__(1);

__webpack_require__(3);

__webpack_require__(42);

__webpack_require__(10);

__webpack_require__(43);

__webpack_require__(44);

(function () {

  'use strict';

  /** @const {Object} */

  var CaseMap = Polymer.CaseMap;

  // Monotonically increasing unique ID used for de-duping effects triggered
  // from multiple properties in the same turn
  var dedupeId = 0;

  /**
   * Property effect types; effects are stored on the prototype using these keys
   * @enum {string}
   */
  var TYPES = {
    COMPUTE: '__computeEffects',
    REFLECT: '__reflectEffects',
    NOTIFY: '__notifyEffects',
    PROPAGATE: '__propagateEffects',
    OBSERVE: '__observeEffects',
    READ_ONLY: '__readOnly'

    /**
     * @typedef {{
     * name: (string | undefined),
     * structured: (boolean | undefined),
     * wildcard: (boolean | undefined)
     * }}
     */
  };var DataTrigger = void 0; //eslint-disable-line no-unused-vars

  /**
   * @typedef {{
   * info: ?,
   * trigger: (!DataTrigger | undefined),
   * fn: (!Function | undefined)
   * }}
   */
  var DataEffect = void 0; //eslint-disable-line no-unused-vars

  var PropertyEffectsType = void 0; //eslint-disable-line no-unused-vars

  /**
   * Ensures that the model has an own-property map of effects for the given type.
   * The model may be a prototype or an instance.
   *
   * Property effects are stored as arrays of effects by property in a map,
   * by named type on the model. e.g.
   *
   *   __computeEffects: {
   *     foo: [ ... ],
   *     bar: [ ... ]
   *   }
   *
   * If the model does not yet have an effect map for the type, one is created
   * and returned.  If it does, but it is not an own property (i.e. the
   * prototype had effects), the the map is deeply cloned and the copy is
   * set on the model and returned, ready for new effects to be added.
   *
   * @param {Object} model Prototype or instance
   * @param {string} type Property effect type
   * @return {Object} The own-property map of effects for the given type
   * @private
   */
  function ensureOwnEffectMap(model, type) {
    var effects = model[type];
    if (!effects) {
      effects = model[type] = {};
    } else if (!model.hasOwnProperty(type)) {
      effects = model[type] = Object.create(model[type]);
      for (var p in effects) {
        var protoFx = effects[p];
        var instFx = effects[p] = Array(protoFx.length);
        for (var i = 0; i < protoFx.length; i++) {
          instFx[i] = protoFx[i];
        }
      }
    }
    return effects;
  }

  // -- effects ----------------------------------------------

  /**
   * Runs all effects of a given type for the given set of property changes
   * on an instance.
   *
   * @param {!PropertyEffectsType} inst The instance with effects to run
   * @param {Object} effects Object map of property-to-Array of effects
   * @param {Object} props Bag of current property changes
   * @param {Object=} oldProps Bag of previous values for changed properties
   * @param {boolean=} hasPaths True with `props` contains one or more paths
   * @param {*=} extraArgs Additional metadata to pass to effect function
   * @return {boolean} True if an effect ran for this property
   * @private
   */
  function runEffects(inst, effects, props, oldProps, hasPaths, extraArgs) {
    if (effects) {
      var ran = false;
      var id = dedupeId++;
      for (var prop in props) {
        if (runEffectsForProperty(inst, effects, id, prop, props, oldProps, hasPaths, extraArgs)) {
          ran = true;
        }
      }
      return ran;
    }
    return false;
  }

  /**
   * Runs a list of effects for a given property.
   *
   * @param {!PropertyEffectsType} inst The instance with effects to run
   * @param {Object} effects Object map of property-to-Array of effects
   * @param {number} dedupeId Counter used for de-duping effects
   * @param {string} prop Name of changed property
   * @param {*} props Changed properties
   * @param {*} oldProps Old properties
   * @param {boolean=} hasPaths True with `props` contains one or more paths
   * @param {*=} extraArgs Additional metadata to pass to effect function
   * @return {boolean} True if an effect ran for this property
   * @private
   */
  function runEffectsForProperty(inst, effects, dedupeId, prop, props, oldProps, hasPaths, extraArgs) {
    var ran = false;
    var rootProperty = hasPaths ? Polymer.Path.root(prop) : prop;
    var fxs = effects[rootProperty];
    if (fxs) {
      for (var i = 0, l = fxs.length, fx; i < l && (fx = fxs[i]); i++) {
        if ((!fx.info || fx.info.lastRun !== dedupeId) && (!hasPaths || pathMatchesTrigger(prop, fx.trigger))) {
          if (fx.info) {
            fx.info.lastRun = dedupeId;
          }
          fx.fn(inst, prop, props, oldProps, fx.info, hasPaths, extraArgs);
          ran = true;
        }
      }
    }
    return ran;
  }

  /**
   * Determines whether a property/path that has changed matches the trigger
   * criteria for an effect.  A trigger is a descriptor with the following
   * structure, which matches the descriptors returned from `parseArg`.
   * e.g. for `foo.bar.*`:
   * ```
   * trigger: {
   *   name: 'a.b',
   *   structured: true,
   *   wildcard: true
   * }
   * ```
   * If no trigger is given, the path is deemed to match.
   *
   * @param {string} path Path or property that changed
   * @param {DataTrigger} trigger Descriptor
   * @return {boolean} Whether the path matched the trigger
   */
  function pathMatchesTrigger(path, trigger) {
    if (trigger) {
      var triggerPath = trigger.name;
      return triggerPath == path || trigger.structured && Polymer.Path.isAncestor(triggerPath, path) || trigger.wildcard && Polymer.Path.isDescendant(triggerPath, path);
    } else {
      return true;
    }
  }

  /**
   * Implements the "observer" effect.
   *
   * Calls the method with `info.methodName` on the instance, passing the
   * new and old values.
   *
   * @param {!PropertyEffectsType} inst The instance the effect will be run on
   * @param {string} property Name of property
   * @param {Object} props Bag of current property changes
   * @param {Object} oldProps Bag of previous values for changed properties
   * @param {?} info Effect metadata
   * @private
   */
  function runObserverEffect(inst, property, props, oldProps, info) {
    var fn = inst[info.methodName];
    var changedProp = info.property;
    if (fn) {
      fn.call(inst, inst.__data[changedProp], oldProps[changedProp]);
    } else if (!info.dynamicFn) {
      console.warn('observer method `' + info.methodName + '` not defined');
    }
  }

  /**
   * Runs "notify" effects for a set of changed properties.
   *
   * This method differs from the generic `runEffects` method in that it
   * will dispatch path notification events in the case that the property
   * changed was a path and the root property for that path didn't have a
   * "notify" effect.  This is to maintain 1.0 behavior that did not require
   * `notify: true` to ensure object sub-property notifications were
   * sent.
   *
   * @param {!PropertyEffectsType} inst The instance with effects to run
   * @param {Object} notifyProps Bag of properties to notify
   * @param {Object} props Bag of current property changes
   * @param {Object} oldProps Bag of previous values for changed properties
   * @param {boolean} hasPaths True with `props` contains one or more paths
   * @private
   */
  function runNotifyEffects(inst, notifyProps, props, oldProps, hasPaths) {
    // Notify
    var fxs = inst[TYPES.NOTIFY];
    var notified = void 0;
    var id = dedupeId++;
    // Try normal notify effects; if none, fall back to try path notification
    for (var prop in notifyProps) {
      if (notifyProps[prop]) {
        if (fxs && runEffectsForProperty(inst, fxs, id, prop, props, oldProps, hasPaths)) {
          notified = true;
        } else if (hasPaths && notifyPath(inst, prop, props)) {
          notified = true;
        }
      }
    }
    // Flush host if we actually notified and host was batching
    // And the host has already initialized clients; this prevents
    // an issue with a host observing data changes before clients are ready.
    var host = void 0;
    if (notified && (host = inst.__dataHost) && host._invalidateProperties) {
      host._invalidateProperties();
    }
  }

  /**
   * Dispatches {property}-changed events with path information in the detail
   * object to indicate a sub-path of the property was changed.
   *
   * @param {!PropertyEffectsType} inst The element from which to fire the event
   * @param {string} path The path that was changed
   * @param {Object} props Bag of current property changes
   * @return {boolean} Returns true if the path was notified
   * @private
   */
  function notifyPath(inst, path, props) {
    var rootProperty = Polymer.Path.root(path);
    if (rootProperty !== path) {
      var eventName = Polymer.CaseMap.camelToDashCase(rootProperty) + '-changed';
      dispatchNotifyEvent(inst, eventName, props[path], path);
      return true;
    }
    return false;
  }

  /**
   * Dispatches {property}-changed events to indicate a property (or path)
   * changed.
   *
   * @param {!PropertyEffectsType} inst The element from which to fire the event
   * @param {string} eventName The name of the event to send ('{property}-changed')
   * @param {*} value The value of the changed property
   * @param {string | null | undefined} path If a sub-path of this property changed, the path
   *   that changed (optional).
   * @private
   * @suppress {invalidCasts}
   */
  function dispatchNotifyEvent(inst, eventName, value, path) {
    var detail = {
      value: value,
      queueProperty: true
    };
    if (path) {
      detail.path = path;
    }
    /** @type {!HTMLElement} */inst.dispatchEvent(new CustomEvent(eventName, { detail: detail }));
  }

  /**
   * Implements the "notify" effect.
   *
   * Dispatches a non-bubbling event named `info.eventName` on the instance
   * with a detail object containing the new `value`.
   *
   * @param {!PropertyEffectsType} inst The instance the effect will be run on
   * @param {string} property Name of property
   * @param {Object} props Bag of current property changes
   * @param {Object} oldProps Bag of previous values for changed properties
   * @param {?} info Effect metadata
   * @param {boolean} hasPaths True with `props` contains one or more paths
   * @private
   */
  function runNotifyEffect(inst, property, props, oldProps, info, hasPaths) {
    var rootProperty = hasPaths ? Polymer.Path.root(property) : property;
    var path = rootProperty != property ? property : null;
    var value = path ? Polymer.Path.get(inst, path) : inst.__data[property];
    if (path && value === undefined) {
      value = props[property]; // specifically for .splices
    }
    dispatchNotifyEvent(inst, info.eventName, value, path);
  }

  /**
   * Handler function for 2-way notification events. Receives context
   * information captured in the `addNotifyListener` closure from the
   * `__notifyListeners` metadata.
   *
   * Sets the value of the notified property to the host property or path.  If
   * the event contained path information, translate that path to the host
   * scope's name for that path first.
   *
   * @param {CustomEvent} event Notification event (e.g. '<property>-changed')
   * @param {!PropertyEffectsType} inst Host element instance handling the notification event
   * @param {string} fromProp Child element property that was bound
   * @param {string} toPath Host property/path that was bound
   * @param {boolean} negate Whether the binding was negated
   * @private
   */
  function handleNotification(event, inst, fromProp, toPath, negate) {
    var value = void 0;
    var detail = /** @type {Object} */event.detail;
    var fromPath = detail && detail.path;
    if (fromPath) {
      toPath = Polymer.Path.translate(fromProp, toPath, fromPath);
      value = detail && detail.value;
    } else {
      value = event.target[fromProp];
    }
    value = negate ? !value : value;
    if (!inst[TYPES.READ_ONLY] || !inst[TYPES.READ_ONLY][toPath]) {
      if (inst._setPendingPropertyOrPath(toPath, value, true, Boolean(fromPath)) && (!detail || !detail.queueProperty)) {
        inst._invalidateProperties();
      }
    }
  }

  /**
   * Implements the "reflect" effect.
   *
   * Sets the attribute named `info.attrName` to the given property value.
   *
   * @param {!PropertyEffectsType} inst The instance the effect will be run on
   * @param {string} property Name of property
   * @param {Object} props Bag of current property changes
   * @param {Object} oldProps Bag of previous values for changed properties
   * @param {?} info Effect metadata
   * @private
   */
  function runReflectEffect(inst, property, props, oldProps, info) {
    var value = inst.__data[property];
    if (Polymer.sanitizeDOMValue) {
      value = Polymer.sanitizeDOMValue(value, info.attrName, 'attribute', /** @type {Node} */inst);
    }
    inst._propertyToAttribute(property, info.attrName, value);
  }

  /**
   * Runs "computed" effects for a set of changed properties.
   *
   * This method differs from the generic `runEffects` method in that it
   * continues to run computed effects based on the output of each pass until
   * there are no more newly computed properties.  This ensures that all
   * properties that will be computed by the initial set of changes are
   * computed before other effects (binding propagation, observers, and notify)
   * run.
   *
   * @param {!PropertyEffectsType} inst The instance the effect will be run on
   * @param {!Object} changedProps Bag of changed properties
   * @param {!Object} oldProps Bag of previous values for changed properties
   * @param {boolean} hasPaths True with `props` contains one or more paths
   * @private
   */
  function runComputedEffects(inst, changedProps, oldProps, hasPaths) {
    var computeEffects = inst[TYPES.COMPUTE];
    if (computeEffects) {
      var inputProps = changedProps;
      while (runEffects(inst, computeEffects, inputProps, oldProps, hasPaths)) {
        Object.assign(oldProps, inst.__dataOld);
        Object.assign(changedProps, inst.__dataPending);
        inputProps = inst.__dataPending;
        inst.__dataPending = null;
      }
    }
  }

  /**
   * Implements the "computed property" effect by running the method with the
   * values of the arguments specified in the `info` object and setting the
   * return value to the computed property specified.
   *
   * @param {!PropertyEffectsType} inst The instance the effect will be run on
   * @param {string} property Name of property
   * @param {Object} props Bag of current property changes
   * @param {Object} oldProps Bag of previous values for changed properties
   * @param {?} info Effect metadata
   * @private
   */
  function runComputedEffect(inst, property, props, oldProps, info) {
    var result = runMethodEffect(inst, property, props, oldProps, info);
    var computedProp = info.methodInfo;
    if (inst.__dataHasAccessor && inst.__dataHasAccessor[computedProp]) {
      inst._setPendingProperty(computedProp, result, true);
    } else {
      inst[computedProp] = result;
    }
  }

  /**
   * Computes path changes based on path links set up using the `linkPaths`
   * API.
   *
   * @param {!PropertyEffectsType} inst The instance whose props are changing
   * @param {string | !Array<(string|number)>} path Path that has changed
   * @param {*} value Value of changed path
   * @private
   */
  function computeLinkedPaths(inst, path, value) {
    var links = inst.__dataLinkedPaths;
    if (links) {
      var link = void 0;
      for (var a in links) {
        var b = links[a];
        if (Polymer.Path.isDescendant(a, path)) {
          link = Polymer.Path.translate(a, b, path);
          inst._setPendingPropertyOrPath(link, value, true, true);
        } else if (Polymer.Path.isDescendant(b, path)) {
          link = Polymer.Path.translate(b, a, path);
          inst._setPendingPropertyOrPath(link, value, true, true);
        }
      }
    }
  }

  // -- bindings ----------------------------------------------

  /**
   * Adds binding metadata to the current `nodeInfo`, and binding effects
   * for all part dependencies to `templateInfo`.
   *
   * @param {Function} constructor Class that `_parseTemplate` is currently
   *   running on
   * @param {TemplateInfo} templateInfo Template metadata for current template
   * @param {NodeInfo} nodeInfo Node metadata for current template node
   * @param {string} kind Binding kind, either 'property', 'attribute', or 'text'
   * @param {string} target Target property name
   * @param {!Array<!BindingPart>} parts Array of binding part metadata
   * @param {string=} literal Literal text surrounding binding parts (specified
   *   only for 'property' bindings, since these must be initialized as part
   *   of boot-up)
   * @private
   */
  function addBinding(constructor, templateInfo, nodeInfo, kind, target, parts, literal) {
    // Create binding metadata and add to nodeInfo
    nodeInfo.bindings = nodeInfo.bindings || [];
    var /** Binding */binding = { kind: kind, target: target, parts: parts, literal: literal, isCompound: parts.length !== 1 };
    nodeInfo.bindings.push(binding);
    // Add listener info to binding metadata
    if (shouldAddListener(binding)) {
      var _binding$parts$ = binding.parts[0],
          event = _binding$parts$.event,
          negate = _binding$parts$.negate;

      binding.listenerEvent = event || CaseMap.camelToDashCase(target) + '-changed';
      binding.listenerNegate = negate;
    }
    // Add "propagate" property effects to templateInfo
    var index = templateInfo.nodeInfoList.length;
    for (var i = 0; i < binding.parts.length; i++) {
      var part = binding.parts[i];
      part.compoundIndex = i;
      addEffectForBindingPart(constructor, templateInfo, binding, part, index);
    }
  }

  /**
   * Adds property effects to the given `templateInfo` for the given binding
   * part.
   *
   * @param {Function} constructor Class that `_parseTemplate` is currently
   *   running on
   * @param {TemplateInfo} templateInfo Template metadata for current template
   * @param {!Binding} binding Binding metadata
   * @param {!BindingPart} part Binding part metadata
   * @param {number} index Index into `nodeInfoList` for this node
   */
  function addEffectForBindingPart(constructor, templateInfo, binding, part, index) {
    if (!part.literal) {
      if (binding.kind === 'attribute' && binding.target[0] === '-') {
        console.warn('Cannot set attribute ' + binding.target + ' because "-" is not a valid attribute starting character');
      } else {
        var dependencies = part.dependencies;
        var info = { index: index, binding: binding, part: part, evaluator: constructor };
        for (var j = 0; j < dependencies.length; j++) {
          var trigger = dependencies[j];
          if (typeof trigger == 'string') {
            trigger = parseArg(trigger);
            trigger.wildcard = true;
          }
          constructor._addTemplatePropertyEffect(templateInfo, trigger.rootProperty, {
            fn: runBindingEffect,
            info: info, trigger: trigger
          });
        }
      }
    }
  }

  /**
   * Implements the "binding" (property/path binding) effect.
   *
   * Note that binding syntax is overridable via `_parseBindings` and
   * `_evaluateBinding`.  This method will call `_evaluateBinding` for any
   * non-literal parts returned from `_parseBindings`.  However,
   * there is no support for _path_ bindings via custom binding parts,
   * as this is specific to Polymer's path binding syntax.
   *
   * @param {!PropertyEffectsType} inst The instance the effect will be run on
   * @param {string} path Name of property
   * @param {Object} props Bag of current property changes
   * @param {Object} oldProps Bag of previous values for changed properties
   * @param {?} info Effect metadata
   * @param {boolean} hasPaths True with `props` contains one or more paths
   * @param {Array} nodeList List of nodes associated with `nodeInfoList` template
   *   metadata
   * @private
   */
  function runBindingEffect(inst, path, props, oldProps, info, hasPaths, nodeList) {
    var node = nodeList[info.index];
    var binding = info.binding;
    var part = info.part;
    // Subpath notification: transform path and set to client
    // e.g.: foo="{{obj.sub}}", path: 'obj.sub.prop', set 'foo.prop'=obj.sub.prop
    if (hasPaths && part.source && path.length > part.source.length && binding.kind == 'property' && !binding.isCompound && node.__dataHasAccessor && node.__dataHasAccessor[binding.target]) {
      var value = props[path];
      path = Polymer.Path.translate(part.source, binding.target, path);
      if (node._setPendingPropertyOrPath(path, value, false, true)) {
        inst._enqueueClient(node);
      }
    } else {
      var _value = info.evaluator._evaluateBinding(inst, part, path, props, oldProps, hasPaths);
      // Propagate value to child
      applyBindingValue(inst, node, binding, part, _value);
    }
  }

  /**
   * Sets the value for an "binding" (binding) effect to a node,
   * either as a property or attribute.
   *
   * @param {!PropertyEffectsType} inst The instance owning the binding effect
   * @param {Node} node Target node for binding
   * @param {!Binding} binding Binding metadata
   * @param {!BindingPart} part Binding part metadata
   * @param {*} value Value to set
   * @private
   */
  function applyBindingValue(inst, node, binding, part, value) {
    value = computeBindingValue(node, value, binding, part);
    if (Polymer.sanitizeDOMValue) {
      value = Polymer.sanitizeDOMValue(value, binding.target, binding.kind, node);
    }
    if (binding.kind == 'attribute') {
      // Attribute binding
      inst._valueToNodeAttribute( /** @type {Element} */node, value, binding.target);
    } else {
      // Property binding
      var prop = binding.target;
      if (node.__dataHasAccessor && node.__dataHasAccessor[prop]) {
        if (!node[TYPES.READ_ONLY] || !node[TYPES.READ_ONLY][prop]) {
          if (node._setPendingProperty(prop, value)) {
            inst._enqueueClient(node);
          }
        }
      } else {
        inst._setUnmanagedPropertyToNode(node, prop, value);
      }
    }
  }

  /**
   * Transforms an "binding" effect value based on compound & negation
   * effect metadata, as well as handling for special-case properties
   *
   * @param {Node} node Node the value will be set to
   * @param {*} value Value to set
   * @param {!Binding} binding Binding metadata
   * @param {!BindingPart} part Binding part metadata
   * @return {*} Transformed value to set
   * @private
   */
  function computeBindingValue(node, value, binding, part) {
    if (binding.isCompound) {
      var storage = node.__dataCompoundStorage[binding.target];
      storage[part.compoundIndex] = value;
      value = storage.join('');
    }
    if (binding.kind !== 'attribute') {
      // Some browsers serialize `undefined` to `"undefined"`
      if (binding.target === 'textContent' || node.localName == 'input' && binding.target == 'value') {
        value = value == undefined ? '' : value;
      }
    }
    return value;
  }

  /**
   * Returns true if a binding's metadata meets all the requirements to allow
   * 2-way binding, and therefore a `<property>-changed` event listener should be
   * added:
   * - used curly braces
   * - is a property (not attribute) binding
   * - is not a textContent binding
   * - is not compound
   *
   * @param {!Binding} binding Binding metadata
   * @return {boolean} True if 2-way listener should be added
   * @private
   */
  function shouldAddListener(binding) {
    return Boolean(binding.target) && binding.kind != 'attribute' && binding.kind != 'text' && !binding.isCompound && binding.parts[0].mode === '{';
  }

  /**
   * Setup compound binding storage structures, notify listeners, and dataHost
   * references onto the bound nodeList.
   *
   * @param {!PropertyEffectsType} inst Instance that bas been previously bound
   * @param {TemplateInfo} templateInfo Template metadata
   * @private
   */
  function setupBindings(inst, templateInfo) {
    // Setup compound storage, dataHost, and notify listeners
    var nodeList = templateInfo.nodeList,
        nodeInfoList = templateInfo.nodeInfoList;

    if (nodeInfoList.length) {
      for (var i = 0; i < nodeInfoList.length; i++) {
        var info = nodeInfoList[i];
        var node = nodeList[i];
        var bindings = info.bindings;
        if (bindings) {
          for (var _i = 0; _i < bindings.length; _i++) {
            var binding = bindings[_i];
            setupCompoundStorage(node, binding);
            addNotifyListener(node, inst, binding);
          }
        }
        node.__dataHost = inst;
      }
    }
  }

  /**
   * Initializes `__dataCompoundStorage` local storage on a bound node with
   * initial literal data for compound bindings, and sets the joined
   * literal parts to the bound property.
   *
   * When changes to compound parts occur, they are first set into the compound
   * storage array for that property, and then the array is joined to result in
   * the final value set to the property/attribute.
   *
   * @param {Node} node Bound node to initialize
   * @param {Binding} binding Binding metadata
   * @private
   */
  function setupCompoundStorage(node, binding) {
    if (binding.isCompound) {
      // Create compound storage map
      var storage = node.__dataCompoundStorage || (node.__dataCompoundStorage = {});
      var parts = binding.parts;
      // Copy literals from parts into storage for this binding
      var literals = new Array(parts.length);
      for (var j = 0; j < parts.length; j++) {
        literals[j] = parts[j].literal;
      }
      var target = binding.target;
      storage[target] = literals;
      // Configure properties with their literal parts
      if (binding.literal && binding.kind == 'property') {
        node[target] = binding.literal;
      }
    }
  }

  /**
   * Adds a 2-way binding notification event listener to the node specified
   *
   * @param {Object} node Child element to add listener to
   * @param {!PropertyEffectsType} inst Host element instance to handle notification event
   * @param {Binding} binding Binding metadata
   * @private
   */
  function addNotifyListener(node, inst, binding) {
    if (binding.listenerEvent) {
      var part = binding.parts[0];
      node.addEventListener(binding.listenerEvent, function (e) {
        handleNotification(e, inst, binding.target, part.source, part.negate);
      });
    }
  }

  // -- for method-based effects (complexObserver & computed) --------------

  /**
   * Adds property effects for each argument in the method signature (and
   * optionally, for the method name if `dynamic` is true) that calls the
   * provided effect function.
   *
   * @param {Element | Object} model Prototype or instance
   * @param {!MethodSignature} sig Method signature metadata
   * @param {string} type Type of property effect to add
   * @param {Function} effectFn Function to run when arguments change
   * @param {*=} methodInfo Effect-specific information to be included in
   *   method effect metadata
   * @param {boolean|Object=} dynamicFn Boolean or object map indicating whether
   *   method names should be included as a dependency to the effect. Note,
   *   defaults to true if the signature is static (sig.static is true).
   * @private
   */
  function createMethodEffect(model, sig, type, effectFn, methodInfo, dynamicFn) {
    dynamicFn = sig.static || dynamicFn && ((typeof dynamicFn === 'undefined' ? 'undefined' : _typeof(dynamicFn)) !== 'object' || dynamicFn[sig.methodName]);
    var info = {
      methodName: sig.methodName,
      args: sig.args,
      methodInfo: methodInfo,
      dynamicFn: dynamicFn
    };
    for (var i = 0, arg; i < sig.args.length && (arg = sig.args[i]); i++) {
      if (!arg.literal) {
        model._addPropertyEffect(arg.rootProperty, type, {
          fn: effectFn, info: info, trigger: arg
        });
      }
    }
    if (dynamicFn) {
      model._addPropertyEffect(sig.methodName, type, {
        fn: effectFn, info: info
      });
    }
  }

  /**
   * Calls a method with arguments marshaled from properties on the instance
   * based on the method signature contained in the effect metadata.
   *
   * Multi-property observers, computed properties, and inline computing
   * functions call this function to invoke the method, then use the return
   * value accordingly.
   *
   * @param {!PropertyEffectsType} inst The instance the effect will be run on
   * @param {string} property Name of property
   * @param {Object} props Bag of current property changes
   * @param {Object} oldProps Bag of previous values for changed properties
   * @param {?} info Effect metadata
   * @return {*} Returns the return value from the method invocation
   * @private
   */
  function runMethodEffect(inst, property, props, oldProps, info) {
    // Instances can optionally have a _methodHost which allows redirecting where
    // to find methods. Currently used by `templatize`.
    var context = inst._methodHost || inst;
    var fn = context[info.methodName];
    if (fn) {
      var args = marshalArgs(inst.__data, info.args, property, props);
      return fn.apply(context, args);
    } else if (!info.dynamicFn) {
      console.warn('method `' + info.methodName + '` not defined');
    }
  }

  var emptyArray = [];

  // Regular expressions used for binding
  var IDENT = '(?:' + '[a-zA-Z_$][\\w.:$\\-*]*' + ')';
  var NUMBER = '(?:' + '[-+]?[0-9]*\\.?[0-9]+(?:[eE][-+]?[0-9]+)?' + ')';
  var SQUOTE_STRING = '(?:' + '\'(?:[^\'\\\\]|\\\\.)*\'' + ')';
  var DQUOTE_STRING = '(?:' + '"(?:[^"\\\\]|\\\\.)*"' + ')';
  var STRING = '(?:' + SQUOTE_STRING + '|' + DQUOTE_STRING + ')';
  var ARGUMENT = '(?:(' + IDENT + '|' + NUMBER + '|' + STRING + ')\\s*' + ')';
  var ARGUMENTS = '(?:' + ARGUMENT + '(?:,\\s*' + ARGUMENT + ')*' + ')';
  var ARGUMENT_LIST = '(?:' + '\\(\\s*' + '(?:' + ARGUMENTS + '?' + ')' + '\\)\\s*' + ')';
  var BINDING = '(' + IDENT + '\\s*' + ARGUMENT_LIST + '?' + ')'; // Group 3
  var OPEN_BRACKET = '(\\[\\[|{{)' + '\\s*';
  var CLOSE_BRACKET = '(?:]]|}})';
  var NEGATE = '(?:(!)\\s*)?'; // Group 2
  var EXPRESSION = OPEN_BRACKET + NEGATE + BINDING + CLOSE_BRACKET;
  var bindingRegex = new RegExp(EXPRESSION, "g");

  /**
   * Create a string from binding parts of all the literal parts
   *
   * @param {!Array<BindingPart>} parts All parts to stringify
   * @return {string} String made from the literal parts
   */
  function literalFromParts(parts) {
    var s = '';
    for (var i = 0; i < parts.length; i++) {
      var literal = parts[i].literal;
      s += literal || '';
    }
    return s;
  }

  /**
   * Parses an expression string for a method signature, and returns a metadata
   * describing the method in terms of `methodName`, `static` (whether all the
   * arguments are literals), and an array of `args`
   *
   * @param {string} expression The expression to parse
   * @return {?MethodSignature} The method metadata object if a method expression was
   *   found, otherwise `undefined`
   * @private
   */
  function parseMethod(expression) {
    // tries to match valid javascript property names
    var m = expression.match(/([^\s]+?)\(([\s\S]*)\)/);
    if (m) {
      var methodName = m[1];
      var sig = { methodName: methodName, static: true, args: emptyArray };
      if (m[2].trim()) {
        // replace escaped commas with comma entity, split on un-escaped commas
        var args = m[2].replace(/\\,/g, '&comma;').split(',');
        return parseArgs(args, sig);
      } else {
        return sig;
      }
    }
    return null;
  }

  /**
   * Parses an array of arguments and sets the `args` property of the supplied
   * signature metadata object. Sets the `static` property to false if any
   * argument is a non-literal.
   *
   * @param {!Array<string>} argList Array of argument names
   * @param {!MethodSignature} sig Method signature metadata object
   * @return {!MethodSignature} The updated signature metadata object
   * @private
   */
  function parseArgs(argList, sig) {
    sig.args = argList.map(function (rawArg) {
      var arg = parseArg(rawArg);
      if (!arg.literal) {
        sig.static = false;
      }
      return arg;
    }, this);
    return sig;
  }

  /**
   * Parses an individual argument, and returns an argument metadata object
   * with the following fields:
   *
   *   {
   *     value: 'prop',        // property/path or literal value
   *     literal: false,       // whether argument is a literal
   *     structured: false,    // whether the property is a path
   *     rootProperty: 'prop', // the root property of the path
   *     wildcard: false       // whether the argument was a wildcard '.*' path
   *   }
   *
   * @param {string} rawArg The string value of the argument
   * @return {!MethodArg} Argument metadata object
   * @private
   */
  function parseArg(rawArg) {
    // clean up whitespace
    var arg = rawArg.trim()
    // replace comma entity with comma
    .replace(/&comma;/g, ',')
    // repair extra escape sequences; note only commas strictly need
    // escaping, but we allow any other char to be escaped since its
    // likely users will do this
    .replace(/\\(.)/g, '\$1');
    // basic argument descriptor
    var a = {
      name: arg,
      value: '',
      literal: false
    };
    // detect literal value (must be String or Number)
    var fc = arg[0];
    if (fc === '-') {
      fc = arg[1];
    }
    if (fc >= '0' && fc <= '9') {
      fc = '#';
    }
    switch (fc) {
      case "'":
      case '"':
        a.value = arg.slice(1, -1);
        a.literal = true;
        break;
      case '#':
        a.value = Number(arg);
        a.literal = true;
        break;
    }
    // if not literal, look for structured path
    if (!a.literal) {
      a.rootProperty = Polymer.Path.root(arg);
      // detect structured path (has dots)
      a.structured = Polymer.Path.isPath(arg);
      if (a.structured) {
        a.wildcard = arg.slice(-2) == '.*';
        if (a.wildcard) {
          a.name = arg.slice(0, -2);
        }
      }
    }
    return a;
  }

  /**
   * Gather the argument values for a method specified in the provided array
   * of argument metadata.
   *
   * The `path` and `value` arguments are used to fill in wildcard descriptor
   * when the method is being called as a result of a path notification.
   *
   * @param {Object} data Instance data storage object to read properties from
   * @param {!Array<!MethodArg>} args Array of argument metadata
   * @param {string} path Property/path name that triggered the method effect
   * @param {Object} props Bag of current property changes
   * @return {Array<*>} Array of argument values
   * @private
   */
  function marshalArgs(data, args, path, props) {
    var values = [];
    for (var i = 0, l = args.length; i < l; i++) {
      var arg = args[i];
      var name = arg.name;
      var v = void 0;
      if (arg.literal) {
        v = arg.value;
      } else {
        if (arg.structured) {
          v = Polymer.Path.get(data, name);
          // when data is not stored e.g. `splices`
          if (v === undefined) {
            v = props[name];
          }
        } else {
          v = data[name];
        }
      }
      if (arg.wildcard) {
        // Only send the actual path changed info if the change that
        // caused the observer to run matched the wildcard
        var baseChanged = name.indexOf(path + '.') === 0;
        var matches = path.indexOf(name) === 0 && !baseChanged;
        values[i] = {
          path: matches ? path : name,
          value: matches ? props[path] : v,
          base: v
        };
      } else {
        values[i] = v;
      }
    }
    return values;
  }

  // data api

  /**
   * Sends array splice notifications (`.splices` and `.length`)
   *
   * Note: this implementation only accepts normalized paths
   *
   * @param {!PropertyEffectsType} inst Instance to send notifications to
   * @param {Array} array The array the mutations occurred on
   * @param {string} path The path to the array that was mutated
   * @param {Array} splices Array of splice records
   * @private
   */
  function _notifySplices(inst, array, path, splices) {
    var splicesPath = path + '.splices';
    inst.notifyPath(splicesPath, { indexSplices: splices });
    inst.notifyPath(path + '.length', array.length);
    // Null here to allow potentially large splice records to be GC'ed.
    inst.__data[splicesPath] = { indexSplices: null };
  }

  /**
   * Creates a splice record and sends an array splice notification for
   * the described mutation
   *
   * Note: this implementation only accepts normalized paths
   *
   * @param {!PropertyEffectsType} inst Instance to send notifications to
   * @param {Array} array The array the mutations occurred on
   * @param {string} path The path to the array that was mutated
   * @param {number} index Index at which the array mutation occurred
   * @param {number} addedCount Number of added items
   * @param {Array} removed Array of removed items
   * @private
   */
  function notifySplice(inst, array, path, index, addedCount, removed) {
    _notifySplices(inst, array, path, [{
      index: index,
      addedCount: addedCount,
      removed: removed,
      object: array,
      type: 'splice'
    }]);
  }

  /**
   * Returns an upper-cased version of the string.
   *
   * @param {string} name String to uppercase
   * @return {string} Uppercased string
   * @private
   */
  function upper(name) {
    return name[0].toUpperCase() + name.substring(1);
  }

  /**
   * Element class mixin that provides meta-programming for Polymer's template
   * binding and data observation (collectively, "property effects") system.
   *
   * This mixin uses provides the following key static methods for adding
   * property effects to an element class:
   * - `addPropertyEffect`
   * - `createPropertyObserver`
   * - `createMethodObserver`
   * - `createNotifyingProperty`
   * - `createReadOnlyProperty`
   * - `createReflectedProperty`
   * - `createComputedProperty`
   * - `bindTemplate`
   *
   * Each method creates one or more property accessors, along with metadata
   * used by this mixin's implementation of `_propertiesChanged` to perform
   * the property effects.
   *
   * Underscored versions of the above methods also exist on the element
   * prototype for adding property effects on instances at runtime.
   *
   * Note that this mixin overrides several `PropertyAccessors` methods, in
   * many cases to maintain guarantees provided by the Polymer 1.x features;
   * notably it changes property accessors to be synchronous by default
   * whereas the default when using `PropertyAccessors` standalone is to be
   * async by default.
   *
   * @mixinFunction
   * @polymer
   * @appliesMixin Polymer.TemplateStamp
   * @appliesMixin Polymer.PropertyAccessors
   * @memberof Polymer
   * @summary Element class mixin that provides meta-programming for Polymer's
   * template binding and data observation system.
   */
  Polymer.PropertyEffects = Polymer.dedupingMixin(function (superClass) {

    /**
     * @constructor
     * @extends {superClass}
     * @implements {Polymer_PropertyAccessors}
     * @implements {Polymer_TemplateStamp}
     * @unrestricted
     */
    var propertyEffectsBase = Polymer.TemplateStamp(Polymer.PropertyAccessors(superClass));

    /**
     * @polymer
     * @mixinClass
     * @implements {Polymer_PropertyEffects}
     * @extends {propertyEffectsBase}
     * @unrestricted
     */

    var PropertyEffects = function (_propertyEffectsBase) {
      _inherits(PropertyEffects, _propertyEffectsBase);

      function PropertyEffects() {
        _classCallCheck(this, PropertyEffects);

        /** @type {boolean} */
        var _this = _possibleConstructorReturn(this, (PropertyEffects.__proto__ || Object.getPrototypeOf(PropertyEffects)).call(this));

        _this.__dataClientsReady;
        /** @type {Array} */
        _this.__dataPendingClients;
        /** @type {Object} */
        _this.__dataToNotify;
        /** @type {Object} */
        _this.__dataLinkedPaths;
        /** @type {boolean} */
        _this.__dataHasPaths;
        /** @type {Object} */
        _this.__dataCompoundStorage;
        /** @type {Polymer_PropertyEffects} */
        _this.__dataHost;
        /** @type {!Object} */
        _this.__dataTemp;
        /** @type {boolean} */
        _this.__dataClientsInitialized;
        /** @type {!Object} */
        _this.__data;
        /** @type {!Object} */
        _this.__dataPending;
        /** @type {!Object} */
        _this.__dataOld;
        /** @type {Object} */
        _this.__computeEffects;
        /** @type {Object} */
        _this.__reflectEffects;
        /** @type {Object} */
        _this.__notifyEffects;
        /** @type {Object} */
        _this.__propagateEffects;
        /** @type {Object} */
        _this.__observeEffects;
        /** @type {Object} */
        _this.__readOnly;
        /** @type {number} */
        _this.__dataCounter;
        /** @type {!TemplateInfo} */
        _this.__templateInfo;
        return _this;
      }

      _createClass(PropertyEffects, [{
        key: '_initializeProperties',
        value: function _initializeProperties() {
          _get(PropertyEffects.prototype.__proto__ || Object.getPrototypeOf(PropertyEffects.prototype), '_initializeProperties', this).call(this);
          hostStack.registerHost(this);
          this.__dataClientsReady = false;
          this.__dataPendingClients = null;
          this.__dataToNotify = null;
          this.__dataLinkedPaths = null;
          this.__dataHasPaths = false;
          // May be set on instance prior to upgrade
          this.__dataCompoundStorage = this.__dataCompoundStorage || null;
          this.__dataHost = this.__dataHost || null;
          this.__dataTemp = {};
          this.__dataClientsInitialized = false;
        }

        /**
         * Overrides `Polymer.PropertyAccessors` implementation to provide a
         * more efficient implementation of initializing properties from
         * the prototype on the instance.
         *
         * @override
         * @param {Object} props Properties to initialize on the prototype
         */

      }, {
        key: '_initializeProtoProperties',
        value: function _initializeProtoProperties(props) {
          this.__data = Object.create(props);
          this.__dataPending = Object.create(props);
          this.__dataOld = {};
        }

        /**
         * Overrides `Polymer.PropertyAccessors` implementation to avoid setting
         * `_setProperty`'s `shouldNotify: true`.
         *
         * @override
         * @param {Object} props Properties to initialize on the instance
         */

      }, {
        key: '_initializeInstanceProperties',
        value: function _initializeInstanceProperties(props) {
          var readOnly = this[TYPES.READ_ONLY];
          for (var prop in props) {
            if (!readOnly || !readOnly[prop]) {
              this.__dataPending = this.__dataPending || {};
              this.__dataOld = this.__dataOld || {};
              this.__data[prop] = this.__dataPending[prop] = props[prop];
            }
          }
        }

        // Prototype setup ----------------------------------------

        /**
         * Equivalent to static `addPropertyEffect` API but can be called on
         * an instance to add effects at runtime.  See that method for
         * full API docs.
         *
         * @param {string} property Property that should trigger the effect
         * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES
         * @param {Object=} effect Effect metadata object
         * @protected
         */

      }, {
        key: '_addPropertyEffect',
        value: function _addPropertyEffect(property, type, effect) {
          this._createPropertyAccessor(property, type == TYPES.READ_ONLY);
          // effects are accumulated into arrays per property based on type
          var effects = ensureOwnEffectMap(this, type)[property];
          if (!effects) {
            effects = this[type][property] = [];
          }
          effects.push(effect);
        }

        /**
         * Removes the given property effect.
         *
         * @param {string} property Property the effect was associated with
         * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES
         * @param {Object=} effect Effect metadata object to remove
         */

      }, {
        key: '_removePropertyEffect',
        value: function _removePropertyEffect(property, type, effect) {
          var effects = ensureOwnEffectMap(this, type)[property];
          var idx = effects.indexOf(effect);
          if (idx >= 0) {
            effects.splice(idx, 1);
          }
        }

        /**
         * Returns whether the current prototype/instance has a property effect
         * of a certain type.
         *
         * @param {string} property Property name
         * @param {string=} type Effect type, from this.PROPERTY_EFFECT_TYPES
         * @return {boolean} True if the prototype/instance has an effect of this type
         * @protected
         */

      }, {
        key: '_hasPropertyEffect',
        value: function _hasPropertyEffect(property, type) {
          var effects = this[type];
          return Boolean(effects && effects[property]);
        }

        /**
         * Returns whether the current prototype/instance has a "read only"
         * accessor for the given property.
         *
         * @param {string} property Property name
         * @return {boolean} True if the prototype/instance has an effect of this type
         * @protected
         */

      }, {
        key: '_hasReadOnlyEffect',
        value: function _hasReadOnlyEffect(property) {
          return this._hasPropertyEffect(property, TYPES.READ_ONLY);
        }

        /**
         * Returns whether the current prototype/instance has a "notify"
         * property effect for the given property.
         *
         * @param {string} property Property name
         * @return {boolean} True if the prototype/instance has an effect of this type
         * @protected
         */

      }, {
        key: '_hasNotifyEffect',
        value: function _hasNotifyEffect(property) {
          return this._hasPropertyEffect(property, TYPES.NOTIFY);
        }

        /**
         * Returns whether the current prototype/instance has a "reflect to attribute"
         * property effect for the given property.
         *
         * @param {string} property Property name
         * @return {boolean} True if the prototype/instance has an effect of this type
         * @protected
         */

      }, {
        key: '_hasReflectEffect',
        value: function _hasReflectEffect(property) {
          return this._hasPropertyEffect(property, TYPES.REFLECT);
        }

        /**
         * Returns whether the current prototype/instance has a "computed"
         * property effect for the given property.
         *
         * @param {string} property Property name
         * @return {boolean} True if the prototype/instance has an effect of this type
         * @protected
         */

      }, {
        key: '_hasComputedEffect',
        value: function _hasComputedEffect(property) {
          return this._hasPropertyEffect(property, TYPES.COMPUTE);
        }

        // Runtime ----------------------------------------

        /**
         * Sets a pending property or path.  If the root property of the path in
         * question had no accessor, the path is set, otherwise it is enqueued
         * via `_setPendingProperty`.
         *
         * This function isolates relatively expensive functionality necessary
         * for the public API (`set`, `setProperties`, `notifyPath`, and property
         * change listeners via {{...}} bindings), such that it is only done
         * when paths enter the system, and not at every propagation step.  It
         * also sets a `__dataHasPaths` flag on the instance which is used to
         * fast-path slower path-matching code in the property effects host paths.
         *
         * `path` can be a path string or array of path parts as accepted by the
         * public API.
         *
         * @param {string | !Array<number|string>} path Path to set
         * @param {*} value Value to set
         * @param {boolean=} shouldNotify Set to true if this change should
         *  cause a property notification event dispatch
         * @param {boolean=} isPathNotification If the path being set is a path
         *   notification of an already changed value, as opposed to a request
         *   to set and notify the change.  In the latter `false` case, a dirty
         *   check is performed and then the value is set to the path before
         *   enqueuing the pending property change.
         * @return {boolean} Returns true if the property/path was enqueued in
         *   the pending changes bag.
         * @protected
         */

      }, {
        key: '_setPendingPropertyOrPath',
        value: function _setPendingPropertyOrPath(path, value, shouldNotify, isPathNotification) {
          if (isPathNotification || Polymer.Path.root(Array.isArray(path) ? path[0] : path) !== path) {
            // Dirty check changes being set to a path against the actual object,
            // since this is the entry point for paths into the system; from here
            // the only dirty checks are against the `__dataTemp` cache to prevent
            // duplicate work in the same turn only. Note, if this was a notification
            // of a change already set to a path (isPathNotification: true),
            // we always let the change through and skip the `set` since it was
            // already dirty checked at the point of entry and the underlying
            // object has already been updated
            if (!isPathNotification) {
              var old = Polymer.Path.get(this, path);
              path = /** @type {string} */Polymer.Path.set(this, path, value);
              // Use property-accessor's simpler dirty check
              if (!path || !_get(PropertyEffects.prototype.__proto__ || Object.getPrototypeOf(PropertyEffects.prototype), '_shouldPropertyChange', this).call(this, path, value, old)) {
                return false;
              }
            }
            this.__dataHasPaths = true;
            if (this._setPendingProperty( /**@type{string}*/path, value, shouldNotify)) {
              computeLinkedPaths(this, path, value);
              return true;
            }
          } else {
            if (this.__dataHasAccessor && this.__dataHasAccessor[path]) {
              return this._setPendingProperty( /**@type{string}*/path, value, shouldNotify);
            } else {
              this[path] = value;
            }
          }
          return false;
        }

        /**
         * Applies a value to a non-Polymer element/node's property.
         *
         * The implementation makes a best-effort at binding interop:
         * Some native element properties have side-effects when
         * re-setting the same value (e.g. setting `<input>.value` resets the
         * cursor position), so we do a dirty-check before setting the value.
         * However, for better interop with non-Polymer custom elements that
         * accept objects, we explicitly re-set object changes coming from the
         * Polymer world (which may include deep object changes without the
         * top reference changing), erring on the side of providing more
         * information.
         *
         * Users may override this method to provide alternate approaches.
         *
         * @param {Node} node The node to set a property on
         * @param {string} prop The property to set
         * @param {*} value The value to set
         * @protected
         */

      }, {
        key: '_setUnmanagedPropertyToNode',
        value: function _setUnmanagedPropertyToNode(node, prop, value) {
          // It is a judgment call that resetting primitives is
          // "bad" and resettings objects is also "good"; alternatively we could
          // implement a whitelist of tag & property values that should never
          // be reset (e.g. <input>.value && <select>.value)
          if (value !== node[prop] || (typeof value === 'undefined' ? 'undefined' : _typeof(value)) == 'object') {
            node[prop] = value;
          }
        }

        /**
         * Overrides the `PropertyAccessors` implementation to introduce special
         * dirty check logic depending on the property & value being set:
         *
         * 1. Any value set to a path (e.g. 'obj.prop': 42 or 'obj.prop': {...})
         *    Stored in `__dataTemp`, dirty checked against `__dataTemp`
         * 2. Object set to simple property (e.g. 'prop': {...})
         *    Stored in `__dataTemp` and `__data`, dirty checked against
         *    `__dataTemp` by default implementation of `_shouldPropertyChange`
         * 3. Primitive value set to simple property (e.g. 'prop': 42)
         *    Stored in `__data`, dirty checked against `__data`
         *
         * The dirty-check is important to prevent cycles due to two-way
         * notification, but paths and objects are only dirty checked against any
         * previous value set during this turn via a "temporary cache" that is
         * cleared when the last `_propertiesChaged` exits. This is so:
         * a. any cached array paths (e.g. 'array.3.prop') may be invalidated
         *    due to array mutations like shift/unshift/splice; this is fine
         *    since path changes are dirty-checked at user entry points like `set`
         * b. dirty-checking for objects only lasts one turn to allow the user
         *    to mutate the object in-place and re-set it with the same identity
         *    and have all sub-properties re-propagated in a subsequent turn.
         *
         * The temp cache is not necessarily sufficient to prevent invalid array
         * paths, since a splice can happen during the same turn (with pathological
         * user code); we could introduce a "fixup" for temporarily cached array
         * paths if needed: https://github.com/Polymer/polymer/issues/4227
         *
         * @param {string} property Name of the property
         * @param {*} value Value to set
         * @param {boolean=} shouldNotify True if property should fire notification
         *   event (applies only for `notify: true` properties)
         * @return {boolean} Returns true if the property changed
         * @override
         */

      }, {
        key: '_setPendingProperty',
        value: function _setPendingProperty(property, value, shouldNotify) {
          var isPath = this.__dataHasPaths && Polymer.Path.isPath(property);
          var prevProps = isPath ? this.__dataTemp : this.__data;
          if (this._shouldPropertyChange(property, value, prevProps[property])) {
            if (!this.__dataPending) {
              this.__dataPending = {};
              this.__dataOld = {};
            }
            // Ensure old is captured from the last turn
            if (!(property in this.__dataOld)) {
              this.__dataOld[property] = this.__data[property];
            }
            // Paths are stored in temporary cache (cleared at end of turn),
            // which is used for dirty-checking, all others stored in __data
            if (isPath) {
              this.__dataTemp[property] = value;
            } else {
              this.__data[property] = value;
            }
            // All changes go into pending property bag, passed to _propertiesChanged
            this.__dataPending[property] = value;
            // Track properties that should notify separately
            if (isPath || this[TYPES.NOTIFY] && this[TYPES.NOTIFY][property]) {
              this.__dataToNotify = this.__dataToNotify || {};
              this.__dataToNotify[property] = shouldNotify;
            }
            return true;
          }
          return false;
        }

        /**
         * Overrides base implementation to ensure all accessors set `shouldNotify`
         * to true, for per-property notification tracking.
         *
         * @override
         */

      }, {
        key: '_setProperty',
        value: function _setProperty(property, value) {
          if (this._setPendingProperty(property, value, true)) {
            this._invalidateProperties();
          }
        }

        /**
         * Overrides `PropertyAccessor`'s default async queuing of
         * `_propertiesChanged`: if `__dataReady` is false (has not yet been
         * manually flushed), the function no-ops; otherwise flushes
         * `_propertiesChanged` synchronously.
         *
         * @override
         */

      }, {
        key: '_invalidateProperties',
        value: function _invalidateProperties() {
          if (this.__dataReady) {
            this._flushProperties();
          }
        }

        /**
         * Enqueues the given client on a list of pending clients, whose
         * pending property changes can later be flushed via a call to
         * `_flushClients`.
         *
         * @param {Object} client PropertyEffects client to enqueue
         * @protected
         */

      }, {
        key: '_enqueueClient',
        value: function _enqueueClient(client) {
          this.__dataPendingClients = this.__dataPendingClients || [];
          if (client !== this) {
            this.__dataPendingClients.push(client);
          }
        }

        /**
         * Flushes any clients previously enqueued via `_enqueueClient`, causing
         * their `_flushProperties` method to run.
         *
         * @protected
         */

      }, {
        key: '_flushClients',
        value: function _flushClients() {
          if (!this.__dataClientsReady) {
            this.__dataClientsReady = true;
            this._readyClients();
            // Override point where accessors are turned on; importantly,
            // this is after clients have fully readied, providing a guarantee
            // that any property effects occur only after all clients are ready.
            this.__dataReady = true;
          } else {
            this.__enableOrFlushClients();
          }
        }

        // NOTE: We ensure clients either enable or flush as appropriate. This
        // handles two corner cases:
        // (1) clients flush properly when connected/enabled before the host
        // enables; e.g.
        //   (a) Templatize stamps with no properties and does not flush and
        //   (b) the instance is inserted into dom and
        //   (c) then the instance flushes.
        // (2) clients enable properly when not connected/enabled when the host
        // flushes; e.g.
        //   (a) a template is runtime stamped and not yet connected/enabled
        //   (b) a host sets a property, causing stamped dom to flush
        //   (c) the stamped dom enables.

      }, {
        key: '__enableOrFlushClients',
        value: function __enableOrFlushClients() {
          var clients = this.__dataPendingClients;
          if (clients) {
            this.__dataPendingClients = null;
            for (var i = 0; i < clients.length; i++) {
              var client = clients[i];
              if (!client.__dataEnabled) {
                client._enableProperties();
              } else if (client.__dataPending) {
                client._flushProperties();
              }
            }
          }
        }

        /**
         * Perform any initial setup on client dom. Called before the first
         * `_flushProperties` call on client dom and before any element
         * observers are called.
         *
         * @protected
         */

      }, {
        key: '_readyClients',
        value: function _readyClients() {
          this.__enableOrFlushClients();
        }

        /**
         * Sets a bag of property changes to this instance, and
         * synchronously processes all effects of the properties as a batch.
         *
         * Property names must be simple properties, not paths.  Batched
         * path propagation is not supported.
         *
         * @param {Object} props Bag of one or more key-value pairs whose key is
         *   a property and value is the new value to set for that property.
         * @param {boolean=} setReadOnly When true, any private values set in
         *   `props` will be set. By default, `setProperties` will not set
         *   `readOnly: true` root properties.
         * @public
         */

      }, {
        key: 'setProperties',
        value: function setProperties(props, setReadOnly) {
          for (var path in props) {
            if (setReadOnly || !this[TYPES.READ_ONLY] || !this[TYPES.READ_ONLY][path]) {
              //TODO(kschaaf): explicitly disallow paths in setProperty?
              // wildcard observers currently only pass the first changed path
              // in the `info` object, and you could do some odd things batching
              // paths, e.g. {'foo.bar': {...}, 'foo': null}
              this._setPendingPropertyOrPath(path, props[path], true);
            }
          }
          this._invalidateProperties();
        }

        /**
         * Overrides `PropertyAccessors` so that property accessor
         * side effects are not enabled until after client dom is fully ready.
         * Also calls `_flushClients` callback to ensure client dom is enabled
         * that was not enabled as a result of flushing properties.
         *
         * @override
         */

      }, {
        key: 'ready',
        value: function ready() {
          // It is important that `super.ready()` is not called here as it
          // immediately turns on accessors. Instead, we wait until `readyClients`
          // to enable accessors to provide a guarantee that clients are ready
          // before processing any accessors side effects.
          this._flushProperties();
          // If no data was pending, `_flushProperties` will not `flushClients`
          // so ensure this is done.
          if (!this.__dataClientsReady) {
            this._flushClients();
          }
          // Before ready, client notifications do not trigger _flushProperties.
          // Therefore a flush is necessary here if data has been set.
          if (this.__dataPending) {
            this._flushProperties();
          }
        }

        /**
         * Implements `PropertyAccessors`'s properties changed callback.
         *
         * Runs each class of effects for the batch of changed properties in
         * a specific order (compute, propagate, reflect, observe, notify).
         *
         * @override
         */

      }, {
        key: '_propertiesChanged',
        value: function _propertiesChanged(currentProps, changedProps, oldProps) {
          // ----------------------------
          // let c = Object.getOwnPropertyNames(changedProps || {});
          // window.debug && console.group(this.localName + '#' + this.id + ': ' + c);
          // if (window.debug) { debugger; }
          // ----------------------------
          var hasPaths = this.__dataHasPaths;
          this.__dataHasPaths = false;
          // Compute properties
          runComputedEffects(this, changedProps, oldProps, hasPaths);
          // Clear notify properties prior to possible reentry (propagate, observe),
          // but after computing effects have a chance to add to them
          var notifyProps = this.__dataToNotify;
          this.__dataToNotify = null;
          // Propagate properties to clients
          this._propagatePropertyChanges(changedProps, oldProps, hasPaths);
          // Flush clients
          this._flushClients();
          // Reflect properties
          runEffects(this, this[TYPES.REFLECT], changedProps, oldProps, hasPaths);
          // Observe properties
          runEffects(this, this[TYPES.OBSERVE], changedProps, oldProps, hasPaths);
          // Notify properties to host
          if (notifyProps) {
            runNotifyEffects(this, notifyProps, changedProps, oldProps, hasPaths);
          }
          // Clear temporary cache at end of turn
          if (this.__dataCounter == 1) {
            this.__dataTemp = {};
          }
          // ----------------------------
          // window.debug && console.groupEnd(this.localName + '#' + this.id + ': ' + c);
          // ----------------------------
        }

        /**
         * Called to propagate any property changes to stamped template nodes
         * managed by this element.
         *
         * @param {Object} changedProps Bag of changed properties
         * @param {Object} oldProps Bag of previous values for changed properties
         * @param {boolean} hasPaths True with `props` contains one or more paths
         * @protected
         */

      }, {
        key: '_propagatePropertyChanges',
        value: function _propagatePropertyChanges(changedProps, oldProps, hasPaths) {
          if (this[TYPES.PROPAGATE]) {
            runEffects(this, this[TYPES.PROPAGATE], changedProps, oldProps, hasPaths);
          }
          var templateInfo = this.__templateInfo;
          while (templateInfo) {
            runEffects(this, templateInfo.propertyEffects, changedProps, oldProps, hasPaths, templateInfo.nodeList);
            templateInfo = templateInfo.nextTemplateInfo;
          }
        }

        /**
         * Aliases one data path as another, such that path notifications from one
         * are routed to the other.
         *
         * @param {string | !Array<string|number>} to Target path to link.
         * @param {string | !Array<string|number>} from Source path to link.
         * @public
         */

      }, {
        key: 'linkPaths',
        value: function linkPaths(to, from) {
          to = Polymer.Path.normalize(to);
          from = Polymer.Path.normalize(from);
          this.__dataLinkedPaths = this.__dataLinkedPaths || {};
          this.__dataLinkedPaths[to] = from;
        }

        /**
         * Removes a data path alias previously established with `_linkPaths`.
         *
         * Note, the path to unlink should be the target (`to`) used when
         * linking the paths.
         *
         * @param {string | !Array<string|number>} path Target path to unlink.
         * @public
         */

      }, {
        key: 'unlinkPaths',
        value: function unlinkPaths(path) {
          path = Polymer.Path.normalize(path);
          if (this.__dataLinkedPaths) {
            delete this.__dataLinkedPaths[path];
          }
        }

        /**
         * Notify that an array has changed.
         *
         * Example:
         *
         *     this.items = [ {name: 'Jim'}, {name: 'Todd'}, {name: 'Bill'} ];
         *     ...
         *     this.items.splice(1, 1, {name: 'Sam'});
         *     this.items.push({name: 'Bob'});
         *     this.notifySplices('items', [
         *       { index: 1, removed: [{name: 'Todd'}], addedCount: 1, obect: this.items, type: 'splice' },
         *       { index: 3, removed: [], addedCount: 1, object: this.items, type: 'splice'}
         *     ]);
         *
         * @param {string} path Path that should be notified.
         * @param {Array} splices Array of splice records indicating ordered
         *   changes that occurred to the array. Each record should have the
         *   following fields:
         *    * index: index at which the change occurred
         *    * removed: array of items that were removed from this index
         *    * addedCount: number of new items added at this index
         *    * object: a reference to the array in question
         *    * type: the string literal 'splice'
         *
         *   Note that splice records _must_ be normalized such that they are
         *   reported in index order (raw results from `Object.observe` are not
         *   ordered and must be normalized/merged before notifying).
         * @public
        */

      }, {
        key: 'notifySplices',
        value: function notifySplices(path, splices) {
          var info = { path: '' };
          var array = /** @type {Array} */Polymer.Path.get(this, path, info);
          _notifySplices(this, array, info.path, splices);
        }

        /**
         * Convenience method for reading a value from a path.
         *
         * Note, if any part in the path is undefined, this method returns
         * `undefined` (this method does not throw when dereferencing undefined
         * paths).
         *
         * @param {(string|!Array<(string|number)>)} path Path to the value
         *   to read.  The path may be specified as a string (e.g. `foo.bar.baz`)
         *   or an array of path parts (e.g. `['foo.bar', 'baz']`).  Note that
         *   bracketed expressions are not supported; string-based path parts
         *   *must* be separated by dots.  Note that when dereferencing array
         *   indices, the index may be used as a dotted part directly
         *   (e.g. `users.12.name` or `['users', 12, 'name']`).
         * @param {Object=} root Root object from which the path is evaluated.
         * @return {*} Value at the path, or `undefined` if any part of the path
         *   is undefined.
         * @public
         */

      }, {
        key: 'get',
        value: function get(path, root) {
          return Polymer.Path.get(root || this, path);
        }

        /**
         * Convenience method for setting a value to a path and notifying any
         * elements bound to the same path.
         *
         * Note, if any part in the path except for the last is undefined,
         * this method does nothing (this method does not throw when
         * dereferencing undefined paths).
         *
         * @param {(string|!Array<(string|number)>)} path Path to the value
         *   to write.  The path may be specified as a string (e.g. `'foo.bar.baz'`)
         *   or an array of path parts (e.g. `['foo.bar', 'baz']`).  Note that
         *   bracketed expressions are not supported; string-based path parts
         *   *must* be separated by dots.  Note that when dereferencing array
         *   indices, the index may be used as a dotted part directly
         *   (e.g. `'users.12.name'` or `['users', 12, 'name']`).
         * @param {*} value Value to set at the specified path.
         * @param {Object=} root Root object from which the path is evaluated.
         *   When specified, no notification will occur.
         * @public
        */

      }, {
        key: 'set',
        value: function set(path, value, root) {
          if (root) {
            Polymer.Path.set(root, path, value);
          } else {
            if (!this[TYPES.READ_ONLY] || !this[TYPES.READ_ONLY][/** @type {string} */path]) {
              if (this._setPendingPropertyOrPath(path, value, true)) {
                this._invalidateProperties();
              }
            }
          }
        }

        /**
         * Adds items onto the end of the array at the path specified.
         *
         * The arguments after `path` and return value match that of
         * `Array.prototype.push`.
         *
         * This method notifies other paths to the same array that a
         * splice occurred to the array.
         *
         * @param {string} path Path to array.
         * @param {...*} items Items to push onto array
         * @return {number} New length of the array.
         * @public
         */

      }, {
        key: 'push',
        value: function push(path) {
          var info = { path: '' };
          var array = /** @type {Array}*/Polymer.Path.get(this, path, info);
          var len = array.length;

          for (var _len = arguments.length, items = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            items[_key - 1] = arguments[_key];
          }

          var ret = array.push.apply(array, items);
          if (items.length) {
            notifySplice(this, array, info.path, len, items.length, []);
          }
          return ret;
        }

        /**
         * Removes an item from the end of array at the path specified.
         *
         * The arguments after `path` and return value match that of
         * `Array.prototype.pop`.
         *
         * This method notifies other paths to the same array that a
         * splice occurred to the array.
         *
         * @param {string} path Path to array.
         * @return {*} Item that was removed.
         * @public
         */

      }, {
        key: 'pop',
        value: function pop(path) {
          var info = { path: '' };
          var array = /** @type {Array} */Polymer.Path.get(this, path, info);
          var hadLength = Boolean(array.length);
          var ret = array.pop();
          if (hadLength) {
            notifySplice(this, array, info.path, array.length, 0, [ret]);
          }
          return ret;
        }

        /**
         * Starting from the start index specified, removes 0 or more items
         * from the array and inserts 0 or more new items in their place.
         *
         * The arguments after `path` and return value match that of
         * `Array.prototype.splice`.
         *
         * This method notifies other paths to the same array that a
         * splice occurred to the array.
         *
         * @param {string} path Path to array.
         * @param {number} start Index from which to start removing/inserting.
         * @param {number} deleteCount Number of items to remove.
         * @param {...*} items Items to insert into array.
         * @return {Array} Array of removed items.
         * @public
         */

      }, {
        key: 'splice',
        value: function splice(path, start, deleteCount) {
          var info = { path: '' };
          var array = /** @type {Array} */Polymer.Path.get(this, path, info);
          // Normalize fancy native splice handling of crazy start values
          if (start < 0) {
            start = array.length - Math.floor(-start);
          } else {
            start = Math.floor(start);
          }
          if (!start) {
            start = 0;
          }

          for (var _len2 = arguments.length, items = Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {
            items[_key2 - 3] = arguments[_key2];
          }

          var ret = array.splice.apply(array, [start, deleteCount].concat(items));
          if (items.length || ret.length) {
            notifySplice(this, array, info.path, start, items.length, ret);
          }
          return ret;
        }

        /**
         * Removes an item from the beginning of array at the path specified.
         *
         * The arguments after `path` and return value match that of
         * `Array.prototype.pop`.
         *
         * This method notifies other paths to the same array that a
         * splice occurred to the array.
         *
         * @param {string} path Path to array.
         * @return {*} Item that was removed.
         * @public
         */

      }, {
        key: 'shift',
        value: function shift(path) {
          var info = { path: '' };
          var array = /** @type {Array} */Polymer.Path.get(this, path, info);
          var hadLength = Boolean(array.length);
          var ret = array.shift();
          if (hadLength) {
            notifySplice(this, array, info.path, 0, 0, [ret]);
          }
          return ret;
        }

        /**
         * Adds items onto the beginning of the array at the path specified.
         *
         * The arguments after `path` and return value match that of
         * `Array.prototype.push`.
         *
         * This method notifies other paths to the same array that a
         * splice occurred to the array.
         *
         * @param {string} path Path to array.
         * @param {...*} items Items to insert info array
         * @return {number} New length of the array.
         * @public
         */

      }, {
        key: 'unshift',
        value: function unshift(path) {
          var info = { path: '' };
          var array = /** @type {Array} */Polymer.Path.get(this, path, info);

          for (var _len3 = arguments.length, items = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
            items[_key3 - 1] = arguments[_key3];
          }

          var ret = array.unshift.apply(array, items);
          if (items.length) {
            notifySplice(this, array, info.path, 0, items.length, []);
          }
          return ret;
        }

        /**
         * Notify that a path has changed.
         *
         * Example:
         *
         *     this.item.user.name = 'Bob';
         *     this.notifyPath('item.user.name');
         *
         * @param {string} path Path that should be notified.
         * @param {*=} value Value at the path (optional).
         * @public
        */

      }, {
        key: 'notifyPath',
        value: function notifyPath(path, value) {
          /** @type {string} */
          var propPath = void 0;
          if (arguments.length == 1) {
            // Get value if not supplied
            var info = { path: '' };
            value = Polymer.Path.get(this, path, info);
            propPath = info.path;
          } else if (Array.isArray(path)) {
            // Normalize path if needed
            propPath = Polymer.Path.normalize(path);
          } else {
            propPath = /** @type{string} */path;
          }
          if (this._setPendingPropertyOrPath(propPath, value, true, true)) {
            this._invalidateProperties();
          }
        }

        /**
         * Equivalent to static `createReadOnlyProperty` API but can be called on
         * an instance to add effects at runtime.  See that method for
         * full API docs.
         *
         * @param {string} property Property name
         * @param {boolean=} protectedSetter Creates a custom protected setter
         *   when `true`.
         * @protected
         */

      }, {
        key: '_createReadOnlyProperty',
        value: function _createReadOnlyProperty(property, protectedSetter) {
          this._addPropertyEffect(property, TYPES.READ_ONLY);
          if (protectedSetter) {
            this['_set' + upper(property)] = /** @this {PropertyEffects} */function (value) {
              this._setProperty(property, value);
            };
          }
        }

        /**
         * Equivalent to static `createPropertyObserver` API but can be called on
         * an instance to add effects at runtime.  See that method for
         * full API docs.
         *
         * @param {string} property Property name
         * @param {string} methodName Name of observer method to call
         * @param {boolean=} dynamicFn Whether the method name should be included as
         *   a dependency to the effect.
         * @protected
         */

      }, {
        key: '_createPropertyObserver',
        value: function _createPropertyObserver(property, methodName, dynamicFn) {
          var info = { property: property, methodName: methodName, dynamicFn: Boolean(dynamicFn) };
          this._addPropertyEffect(property, TYPES.OBSERVE, {
            fn: runObserverEffect, info: info, trigger: { name: property }
          });
          if (dynamicFn) {
            this._addPropertyEffect(methodName, TYPES.OBSERVE, {
              fn: runObserverEffect, info: info, trigger: { name: methodName }
            });
          }
        }

        /**
         * Equivalent to static `createMethodObserver` API but can be called on
         * an instance to add effects at runtime.  See that method for
         * full API docs.
         *
         * @param {string} expression Method expression
         * @param {boolean|Object=} dynamicFn Boolean or object map indicating
         *   whether method names should be included as a dependency to the effect.
         * @protected
         */

      }, {
        key: '_createMethodObserver',
        value: function _createMethodObserver(expression, dynamicFn) {
          var sig = parseMethod(expression);
          if (!sig) {
            throw new Error("Malformed observer expression '" + expression + "'");
          }
          createMethodEffect(this, sig, TYPES.OBSERVE, runMethodEffect, null, dynamicFn);
        }

        /**
         * Equivalent to static `createNotifyingProperty` API but can be called on
         * an instance to add effects at runtime.  See that method for
         * full API docs.
         *
         * @param {string} property Property name
         * @protected
         */

      }, {
        key: '_createNotifyingProperty',
        value: function _createNotifyingProperty(property) {
          this._addPropertyEffect(property, TYPES.NOTIFY, {
            fn: runNotifyEffect,
            info: {
              eventName: CaseMap.camelToDashCase(property) + '-changed',
              property: property
            }
          });
        }

        /**
         * Equivalent to static `createReflectedProperty` API but can be called on
         * an instance to add effects at runtime.  See that method for
         * full API docs.
         *
         * @param {string} property Property name
         * @protected
         */

      }, {
        key: '_createReflectedProperty',
        value: function _createReflectedProperty(property) {
          var attr = CaseMap.camelToDashCase(property);
          if (attr[0] === '-') {
            console.warn('Property ' + property + ' cannot be reflected to attribute ' + attr + ' because "-" is not a valid starting attribute name. Use a lowercase first letter for the property thisead.');
          } else {
            this._addPropertyEffect(property, TYPES.REFLECT, {
              fn: runReflectEffect,
              info: {
                attrName: attr
              }
            });
          }
        }

        /**
         * Equivalent to static `createComputedProperty` API but can be called on
         * an instance to add effects at runtime.  See that method for
         * full API docs.
         *
         * @param {string} property Name of computed property to set
         * @param {string} expression Method expression
         * @param {boolean|Object=} dynamicFn Boolean or object map indicating
         *   whether method names should be included as a dependency to the effect.
         * @protected
         */

      }, {
        key: '_createComputedProperty',
        value: function _createComputedProperty(property, expression, dynamicFn) {
          var sig = parseMethod(expression);
          if (!sig) {
            throw new Error("Malformed computed expression '" + expression + "'");
          }
          createMethodEffect(this, sig, TYPES.COMPUTE, runComputedEffect, property, dynamicFn);
        }

        // -- static class methods ------------

        /**
         * Ensures an accessor exists for the specified property, and adds
         * to a list of "property effects" that will run when the accessor for
         * the specified property is set.  Effects are grouped by "type", which
         * roughly corresponds to a phase in effect processing.  The effect
         * metadata should be in the following form:
         *
         *   {
         *     fn: effectFunction, // Reference to function to call to perform effect
         *     info: { ... }       // Effect metadata passed to function
         *     trigger: {          // Optional triggering metadata; if not provided
         *       name: string      // the property is treated as a wildcard
         *       structured: boolean
         *       wildcard: boolean
         *     }
         *   }
         *
         * Effects are called from `_propertiesChanged` in the following order by
         * type:
         *
         * 1. COMPUTE
         * 2. PROPAGATE
         * 3. REFLECT
         * 4. OBSERVE
         * 5. NOTIFY
         *
         * Effect functions are called with the following signature:
         *
         *   effectFunction(inst, path, props, oldProps, info, hasPaths)
         *
         * @param {string} property Property that should trigger the effect
         * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES
         * @param {Object=} effect Effect metadata object
         * @protected
         */

      }, {
        key: '_bindTemplate',


        // -- binding ----------------------------------------------

        /**
         * Equivalent to static `bindTemplate` API but can be called on
         * an instance to add effects at runtime.  See that method for
         * full API docs.
         *
         * This method may be called on the prototype (for prototypical template
         * binding, to avoid creating accessors every instance) once per prototype,
         * and will be called with `runtimeBinding: true` by `_stampTemplate` to
         * create and link an instance of the template metadata associated with a
         * particular stamping.
         *
         * @param {HTMLTemplateElement} template Template containing binding
         *   bindings
         * @param {boolean=} instanceBinding When false (default), performs
         *   "prototypical" binding of the template and overwrites any previously
         *   bound template for the class. When true (as passed from
         *   `_stampTemplate`), the template info is instanced and linked into
         *   the list of bound templates.
         * @return {!TemplateInfo} Template metadata object; for `runtimeBinding`,
         *   this is an instance of the prototypical template info
         * @protected
         */
        value: function _bindTemplate(template, instanceBinding) {
          var templateInfo = this.constructor._parseTemplate(template);
          var wasPreBound = this.__templateInfo == templateInfo;
          // Optimization: since this is called twice for proto-bound templates,
          // don't attempt to recreate accessors if this template was pre-bound
          if (!wasPreBound) {
            for (var prop in templateInfo.propertyEffects) {
              this._createPropertyAccessor(prop);
            }
          }
          if (instanceBinding) {
            // For instance-time binding, create instance of template metadata
            // and link into list of templates if necessary
            templateInfo = /** @type {!TemplateInfo} */Object.create(templateInfo);
            templateInfo.wasPreBound = wasPreBound;
            if (!wasPreBound && this.__templateInfo) {
              var last = this.__templateInfoLast || this.__templateInfo;
              this.__templateInfoLast = last.nextTemplateInfo = templateInfo;
              templateInfo.previousTemplateInfo = last;
              return templateInfo;
            }
          }
          return this.__templateInfo = templateInfo;
        }

        /**
         * Adds a property effect to the given template metadata, which is run
         * at the "propagate" stage of `_propertiesChanged` when the template
         * has been bound to the element via `_bindTemplate`.
         *
         * The `effect` object should match the format in `_addPropertyEffect`.
         *
         * @param {Object} templateInfo Template metadata to add effect to
         * @param {string} prop Property that should trigger the effect
         * @param {Object=} effect Effect metadata object
         * @protected
         */

      }, {
        key: '_stampTemplate',


        /**
         * Stamps the provided template and performs instance-time setup for
         * Polymer template features, including data bindings, declarative event
         * listeners, and the `this.$` map of `id`'s to nodes.  A document fragment
         * is returned containing the stamped DOM, ready for insertion into the
         * DOM.
         *
         * This method may be called more than once; however note that due to
         * `shadycss` polyfill limitations, only styles from templates prepared
         * using `ShadyCSS.prepareTemplate` will be correctly polyfilled (scoped
         * to the shadow root and support CSS custom properties), and note that
         * `ShadyCSS.prepareTemplate` may only be called once per element. As such,
         * any styles required by in runtime-stamped templates must be included
         * in the main element template.
         *
         * @param {!HTMLTemplateElement} template Template to stamp
         * @return {!StampedTemplate} Cloned template content
         * @override
         * @protected
         */
        value: function _stampTemplate(template) {
          // Ensures that created dom is `_enqueueClient`'d to this element so
          // that it can be flushed on next call to `_flushProperties`
          hostStack.beginHosting(this);
          var dom = _get(PropertyEffects.prototype.__proto__ || Object.getPrototypeOf(PropertyEffects.prototype), '_stampTemplate', this).call(this, template);
          hostStack.endHosting(this);
          var templateInfo = /** @type {!TemplateInfo} */this._bindTemplate(template, true);
          // Add template-instance-specific data to instanced templateInfo
          templateInfo.nodeList = dom.nodeList;
          // Capture child nodes to allow unstamping of non-prototypical templates
          if (!templateInfo.wasPreBound) {
            var nodes = templateInfo.childNodes = [];
            for (var n = dom.firstChild; n; n = n.nextSibling) {
              nodes.push(n);
            }
          }
          dom.templateInfo = templateInfo;
          // Setup compound storage, 2-way listeners, and dataHost for bindings
          setupBindings(this, templateInfo);
          // Flush properties into template nodes if already booted
          if (this.__dataReady) {
            runEffects(this, templateInfo.propertyEffects, this.__data, null, false, templateInfo.nodeList);
          }
          return dom;
        }

        /**
         * Removes and unbinds the nodes previously contained in the provided
         * DocumentFragment returned from `_stampTemplate`.
         *
         * @param {!StampedTemplate} dom DocumentFragment previously returned
         *   from `_stampTemplate` associated with the nodes to be removed
         * @protected
         */

      }, {
        key: '_removeBoundDom',
        value: function _removeBoundDom(dom) {
          // Unlink template info
          var templateInfo = dom.templateInfo;
          if (templateInfo.previousTemplateInfo) {
            templateInfo.previousTemplateInfo.nextTemplateInfo = templateInfo.nextTemplateInfo;
          }
          if (templateInfo.nextTemplateInfo) {
            templateInfo.nextTemplateInfo.previousTemplateInfo = templateInfo.previousTemplateInfo;
          }
          if (this.__templateInfoLast == templateInfo) {
            this.__templateInfoLast = templateInfo.previousTemplateInfo;
          }
          templateInfo.previousTemplateInfo = templateInfo.nextTemplateInfo = null;
          // Remove stamped nodes
          var nodes = templateInfo.childNodes;
          for (var i = 0; i < nodes.length; i++) {
            var node = nodes[i];
            node.parentNode.removeChild(node);
          }
        }

        /**
         * Overrides default `TemplateStamp` implementation to add support for
         * parsing bindings from `TextNode`'s' `textContent`.  A `bindings`
         * array is added to `nodeInfo` and populated with binding metadata
         * with information capturing the binding target, and a `parts` array
         * with one or more metadata objects capturing the source(s) of the
         * binding.
         *
         * @override
         * @param {Node} node Node to parse
         * @param {TemplateInfo} templateInfo Template metadata for current template
         * @param {NodeInfo} nodeInfo Node metadata for current template node
         * @return {boolean} `true` if the visited node added node-specific
         *   metadata to `nodeInfo`
         * @protected
         * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
         */

      }, {
        key: 'PROPERTY_EFFECT_TYPES',
        get: function get() {
          return TYPES;
        }
      }], [{
        key: 'addPropertyEffect',
        value: function addPropertyEffect(property, type, effect) {
          this.prototype._addPropertyEffect(property, type, effect);
        }

        /**
         * Creates a single-property observer for the given property.
         *
         * @param {string} property Property name
         * @param {string} methodName Name of observer method to call
         * @param {boolean=} dynamicFn Whether the method name should be included as
         *   a dependency to the effect.
         * @protected
         */

      }, {
        key: 'createPropertyObserver',
        value: function createPropertyObserver(property, methodName, dynamicFn) {
          this.prototype._createPropertyObserver(property, methodName, dynamicFn);
        }

        /**
         * Creates a multi-property "method observer" based on the provided
         * expression, which should be a string in the form of a normal Javascript
         * function signature: `'methodName(arg1, [..., argn])'`.  Each argument
         * should correspond to a property or path in the context of this
         * prototype (or instance), or may be a literal string or number.
         *
         * @param {string} expression Method expression
         * @param {boolean|Object=} dynamicFn Boolean or object map indicating
         *   whether method names should be included as a dependency to the effect.
         * @protected
         */

      }, {
        key: 'createMethodObserver',
        value: function createMethodObserver(expression, dynamicFn) {
          this.prototype._createMethodObserver(expression, dynamicFn);
        }

        /**
         * Causes the setter for the given property to dispatch `<property>-changed`
         * events to notify of changes to the property.
         *
         * @param {string} property Property name
         * @protected
         */

      }, {
        key: 'createNotifyingProperty',
        value: function createNotifyingProperty(property) {
          this.prototype._createNotifyingProperty(property);
        }

        /**
         * Creates a read-only accessor for the given property.
         *
         * To set the property, use the protected `_setProperty` API.
         * To create a custom protected setter (e.g. `_setMyProp()` for
         * property `myProp`), pass `true` for `protectedSetter`.
         *
         * Note, if the property will have other property effects, this method
         * should be called first, before adding other effects.
         *
         * @param {string} property Property name
         * @param {boolean=} protectedSetter Creates a custom protected setter
         *   when `true`.
         * @protected
         */

      }, {
        key: 'createReadOnlyProperty',
        value: function createReadOnlyProperty(property, protectedSetter) {
          this.prototype._createReadOnlyProperty(property, protectedSetter);
        }

        /**
         * Causes the setter for the given property to reflect the property value
         * to a (dash-cased) attribute of the same name.
         *
         * @param {string} property Property name
         * @protected
         */

      }, {
        key: 'createReflectedProperty',
        value: function createReflectedProperty(property) {
          this.prototype._createReflectedProperty(property);
        }

        /**
         * Creates a computed property whose value is set to the result of the
         * method described by the given `expression` each time one or more
         * arguments to the method changes.  The expression should be a string
         * in the form of a normal Javascript function signature:
         * `'methodName(arg1, [..., argn])'`
         *
         * @param {string} property Name of computed property to set
         * @param {string} expression Method expression
         * @param {boolean|Object=} dynamicFn Boolean or object map indicating whether
         *   method names should be included as a dependency to the effect.
         * @protected
         */

      }, {
        key: 'createComputedProperty',
        value: function createComputedProperty(property, expression, dynamicFn) {
          this.prototype._createComputedProperty(property, expression, dynamicFn);
        }

        /**
         * Parses the provided template to ensure binding effects are created
         * for them, and then ensures property accessors are created for any
         * dependent properties in the template.  Binding effects for bound
         * templates are stored in a linked list on the instance so that
         * templates can be efficiently stamped and unstamped.
         *
         * @param {HTMLTemplateElement} template Template containing binding
         *   bindings
         * @return {Object} Template metadata object
         * @protected
         */

      }, {
        key: 'bindTemplate',
        value: function bindTemplate(template) {
          return this.prototype._bindTemplate(template);
        }
      }, {
        key: '_addTemplatePropertyEffect',
        value: function _addTemplatePropertyEffect(templateInfo, prop, effect) {
          var hostProps = templateInfo.hostProps = templateInfo.hostProps || {};
          hostProps[prop] = true;
          var effects = templateInfo.propertyEffects = templateInfo.propertyEffects || {};
          var propEffects = effects[prop] = effects[prop] || [];
          propEffects.push(effect);
        }
      }, {
        key: '_parseTemplateNode',
        value: function _parseTemplateNode(node, templateInfo, nodeInfo) {
          var noted = _get(PropertyEffects.__proto__ || Object.getPrototypeOf(PropertyEffects), '_parseTemplateNode', this).call(this, node, templateInfo, nodeInfo);
          if (node.nodeType === Node.TEXT_NODE) {
            var parts = this._parseBindings(node.textContent, templateInfo);
            if (parts) {
              // Initialize the textContent with any literal parts
              // NOTE: default to a space here so the textNode remains; some browsers
              // (IE) evacipate an empty textNode following cloneNode/importNode.
              node.textContent = literalFromParts(parts) || ' ';
              addBinding(this, templateInfo, nodeInfo, 'text', 'textContent', parts);
              noted = true;
            }
          }
          return noted;
        }

        /**
         * Overrides default `TemplateStamp` implementation to add support for
         * parsing bindings from attributes.  A `bindings`
         * array is added to `nodeInfo` and populated with binding metadata
         * with information capturing the binding target, and a `parts` array
         * with one or more metadata objects capturing the source(s) of the
         * binding.
         *
         * @override
         * @param {Element} node Node to parse
         * @param {TemplateInfo} templateInfo Template metadata for current template
         * @param {NodeInfo} nodeInfo Node metadata for current template node
         * @return {boolean} `true` if the visited node added node-specific
         *   metadata to `nodeInfo`
         * @protected
         * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
         */

      }, {
        key: '_parseTemplateNodeAttribute',
        value: function _parseTemplateNodeAttribute(node, templateInfo, nodeInfo, name, value) {
          var parts = this._parseBindings(value, templateInfo);
          if (parts) {
            // Attribute or property
            var origName = name;
            var kind = 'property';
            if (name[name.length - 1] == '$') {
              name = name.slice(0, -1);
              kind = 'attribute';
            }
            // Initialize attribute bindings with any literal parts
            var literal = literalFromParts(parts);
            if (literal && kind == 'attribute') {
              node.setAttribute(name, literal);
            }
            // Clear attribute before removing, since IE won't allow removing
            // `value` attribute if it previously had a value (can't
            // unconditionally set '' before removing since attributes with `$`
            // can't be set using setAttribute)
            if (node.localName === 'input' && origName === 'value') {
              node.setAttribute(origName, '');
            }
            // Remove annotation
            node.removeAttribute(origName);
            // Case hackery: attributes are lower-case, but bind targets
            // (properties) are case sensitive. Gambit is to map dash-case to
            // camel-case: `foo-bar` becomes `fooBar`.
            // Attribute bindings are excepted.
            if (kind === 'property') {
              name = Polymer.CaseMap.dashToCamelCase(name);
            }
            addBinding(this, templateInfo, nodeInfo, kind, name, parts, literal);
            return true;
          } else {
            return _get(PropertyEffects.__proto__ || Object.getPrototypeOf(PropertyEffects), '_parseTemplateNodeAttribute', this).call(this, node, templateInfo, nodeInfo, name, value);
          }
        }

        /**
         * Overrides default `TemplateStamp` implementation to add support for
         * binding the properties that a nested template depends on to the template
         * as `_host_<property>`.
         *
         * @override
         * @param {Node} node Node to parse
         * @param {TemplateInfo} templateInfo Template metadata for current template
         * @param {NodeInfo} nodeInfo Node metadata for current template node
         * @return {boolean} `true` if the visited node added node-specific
         *   metadata to `nodeInfo`
         * @protected
         * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
         */

      }, {
        key: '_parseTemplateNestedTemplate',
        value: function _parseTemplateNestedTemplate(node, templateInfo, nodeInfo) {
          var noted = _get(PropertyEffects.__proto__ || Object.getPrototypeOf(PropertyEffects), '_parseTemplateNestedTemplate', this).call(this, node, templateInfo, nodeInfo);
          // Merge host props into outer template and add bindings
          var hostProps = nodeInfo.templateInfo.hostProps;
          var mode = '{';
          for (var source in hostProps) {
            var parts = [{ mode: mode, source: source, dependencies: [source] }];
            addBinding(this, templateInfo, nodeInfo, 'property', '_host_' + source, parts);
          }
          return noted;
        }

        /**
         * Called to parse text in a template (either attribute values or
         * textContent) into binding metadata.
         *
         * Any overrides of this method should return an array of binding part
         * metadata  representing one or more bindings found in the provided text
         * and any "literal" text in between.  Any non-literal parts will be passed
         * to `_evaluateBinding` when any dependencies change.  The only required
         * fields of each "part" in the returned array are as follows:
         *
         * - `dependencies` - Array containing trigger metadata for each property
         *   that should trigger the binding to update
         * - `literal` - String containing text if the part represents a literal;
         *   in this case no `dependencies` are needed
         *
         * Additional metadata for use by `_evaluateBinding` may be provided in
         * each part object as needed.
         *
         * The default implementation handles the following types of bindings
         * (one or more may be intermixed with literal strings):
         * - Property binding: `[[prop]]`
         * - Path binding: `[[object.prop]]`
         * - Negated property or path bindings: `[[!prop]]` or `[[!object.prop]]`
         * - Two-way property or path bindings (supports negation):
         *   `{{prop}}`, `{{object.prop}}`, `{{!prop}}` or `{{!object.prop}}`
         * - Inline computed method (supports negation):
         *   `[[compute(a, 'literal', b)]]`, `[[!compute(a, 'literal', b)]]`
         *
         * @param {string} text Text to parse from attribute or textContent
         * @param {Object} templateInfo Current template metadata
         * @return {Array<!BindingPart>} Array of binding part metadata
         * @protected
         */

      }, {
        key: '_parseBindings',
        value: function _parseBindings(text, templateInfo) {
          var parts = [];
          var lastIndex = 0;
          var m = void 0;
          // Example: "literal1{{prop}}literal2[[!compute(foo,bar)]]final"
          // Regex matches:
          //        Iteration 1:  Iteration 2:
          // m[1]: '{{'          '[['
          // m[2]: ''            '!'
          // m[3]: 'prop'        'compute(foo,bar)'
          while ((m = bindingRegex.exec(text)) !== null) {
            // Add literal part
            if (m.index > lastIndex) {
              parts.push({ literal: text.slice(lastIndex, m.index) });
            }
            // Add binding part
            var mode = m[1][0];
            var negate = Boolean(m[2]);
            var source = m[3].trim();
            var customEvent = false,
                notifyEvent = '',
                colon = -1;
            if (mode == '{' && (colon = source.indexOf('::')) > 0) {
              notifyEvent = source.substring(colon + 2);
              source = source.substring(0, colon);
              customEvent = true;
            }
            var signature = parseMethod(source);
            var dependencies = [];
            if (signature) {
              // Inline computed function
              var args = signature.args,
                  methodName = signature.methodName;

              for (var i = 0; i < args.length; i++) {
                var arg = args[i];
                if (!arg.literal) {
                  dependencies.push(arg);
                }
              }
              var dynamicFns = templateInfo.dynamicFns;
              if (dynamicFns && dynamicFns[methodName] || signature.static) {
                dependencies.push(methodName);
                signature.dynamicFn = true;
              }
            } else {
              // Property or path
              dependencies.push(source);
            }
            parts.push({
              source: source, mode: mode, negate: negate, customEvent: customEvent, signature: signature, dependencies: dependencies,
              event: notifyEvent
            });
            lastIndex = bindingRegex.lastIndex;
          }
          // Add a final literal part
          if (lastIndex && lastIndex < text.length) {
            var literal = text.substring(lastIndex);
            if (literal) {
              parts.push({
                literal: literal
              });
            }
          }
          if (parts.length) {
            return parts;
          } else {
            return null;
          }
        }

        /**
         * Called to evaluate a previously parsed binding part based on a set of
         * one or more changed dependencies.
         *
         * @param {this} inst Element that should be used as scope for
         *   binding dependencies
         * @param {BindingPart} part Binding part metadata
         * @param {string} path Property/path that triggered this effect
         * @param {Object} props Bag of current property changes
         * @param {Object} oldProps Bag of previous values for changed properties
         * @param {boolean} hasPaths True with `props` contains one or more paths
         * @return {*} Value the binding part evaluated to
         * @protected
         */

      }, {
        key: '_evaluateBinding',
        value: function _evaluateBinding(inst, part, path, props, oldProps, hasPaths) {
          var value = void 0;
          if (part.signature) {
            value = runMethodEffect(inst, path, props, oldProps, part.signature);
          } else if (path != part.source) {
            value = Polymer.Path.get(inst, part.source);
          } else {
            if (hasPaths && Polymer.Path.isPath(path)) {
              value = Polymer.Path.get(inst, path);
            } else {
              value = inst.__data[path];
            }
          }
          if (part.negate) {
            value = !value;
          }
          return value;
        }
      }]);

      return PropertyEffects;
    }(propertyEffectsBase);

    // make a typing for closure :P


    PropertyEffectsType = PropertyEffects;

    return PropertyEffects;
  });

  /**
   * Helper api for enqueing client dom created by a host element.
   *
   * By default elements are flushed via `_flushProperties` when
   * `connectedCallback` is called. Elements attach their client dom to
   * themselves at `ready` time which results from this first flush.
   * This provides an ordering guarantee that the client dom an element
   * creates is flushed before the element itself (i.e. client `ready`
   * fires before host `ready`).
   *
   * However, if `_flushProperties` is called *before* an element is connected,
   * as for example `Templatize` does, this ordering guarantee cannot be
   * satisfied because no elements are connected. (Note: Bound elements that
   * receive data do become enqueued clients and are properly ordered but
   * unbound elements are not.)
   *
   * To maintain the desired "client before host" ordering guarantee for this
   * case we rely on the "host stack. Client nodes registers themselves with
   * the creating host element when created. This ensures that all client dom
   * is readied in the proper order, maintaining the desired guarantee.
   *
   * @private
   */
  var hostStack = {

    stack: [],

    /**
     * @param {*} inst Instance to add to hostStack
     * @this {hostStack}
     */
    registerHost: function registerHost(inst) {
      if (this.stack.length) {
        var host = this.stack[this.stack.length - 1];
        host._enqueueClient(inst);
      }
    },


    /**
     * @param {*} inst Instance to begin hosting
     * @this {hostStack}
     */
    beginHosting: function beginHosting(inst) {
      this.stack.push(inst);
    },


    /**
     * @param {*} inst Instance to end hosting
     * @this {hostStack}
     */
    endHosting: function endHosting(inst) {
      var stackLen = this.stack.length;
      if (stackLen && this.stack[stackLen - 1] == inst) {
        this.stack.pop();
      }
    }
  };
})();

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

__webpack_require__(1);

__webpack_require__(3);

__webpack_require__(8);

(function () {
  'use strict';

  /** @typedef {{run: function(function(), number=):number, cancel: function(number)}} */

  var AsyncModule = void 0; // eslint-disable-line no-unused-vars

  /**
   * @summary Collapse multiple callbacks into one invocation after a timer.
   * @memberof Polymer
   */

  var Debouncer = function () {
    function Debouncer() {
      _classCallCheck(this, Debouncer);

      this._asyncModule = null;
      this._callback = null;
      this._timer = null;
    }
    /**
     * Sets the scheduler; that is, a module with the Async interface,
     * a callback and optional arguments to be passed to the run function
     * from the async module.
     *
     * @param {!AsyncModule} asyncModule Object with Async interface.
     * @param {function()} callback Callback to run.
     */


    _createClass(Debouncer, [{
      key: 'setConfig',
      value: function setConfig(asyncModule, callback) {
        var _this = this;

        this._asyncModule = asyncModule;
        this._callback = callback;
        this._timer = this._asyncModule.run(function () {
          _this._timer = null;
          _this._callback();
        });
      }
      /**
       * Cancels an active debouncer and returns a reference to itself.
       */

    }, {
      key: 'cancel',
      value: function cancel() {
        if (this.isActive()) {
          this._asyncModule.cancel(this._timer);
          this._timer = null;
        }
      }
      /**
       * Flushes an active debouncer and returns a reference to itself.
       */

    }, {
      key: 'flush',
      value: function flush() {
        if (this.isActive()) {
          this.cancel();
          this._callback();
        }
      }
      /**
       * Returns true if the debouncer is active.
       *
       * @return {boolean} True if active.
       */

    }, {
      key: 'isActive',
      value: function isActive() {
        return this._timer != null;
      }
      /**
       * Creates a debouncer if no debouncer is passed as a parameter
       * or it cancels an active debouncer otherwise. The following
       * example shows how a debouncer can be called multiple times within a
       * microtask and "debounced" such that the provided callback function is
       * called once. Add this method to a custom element:
       *
       * _debounceWork() {
       *   this._debounceJob = Polymer.Debouncer.debounce(this._debounceJob,
       *       Polymer.Async.microTask, () => {
       *     this._doWork();
       *   });
       * }
       *
       * If the `_debounceWork` method is called multiple times within the same
       * microtask, the `_doWork` function will be called only once at the next
       * microtask checkpoint.
       *
       * Note: In testing it is often convenient to avoid asynchrony. To accomplish
       * this with a debouncer, you can use `Polymer.enqueueDebouncer` and
       * `Polymer.flush`. For example, extend the above example by adding
       * `Polymer.enqueueDebouncer(this._debounceJob)` at the end of the
       * `_debounceWork` method. Then in a test, call `Polymer.flush` to ensure
       * the debouncer has completed.
       *
       * @param {Debouncer?} debouncer Debouncer object.
       * @param {!AsyncModule} asyncModule Object with Async interface
       * @param {function()} callback Callback to run.
       * @return {!Debouncer} Returns a debouncer object.
       */

    }], [{
      key: 'debounce',
      value: function debounce(debouncer, asyncModule, callback) {
        if (debouncer instanceof Debouncer) {
          debouncer.cancel();
        } else {
          debouncer = new Debouncer();
        }
        debouncer.setConfig(asyncModule, callback);
        return debouncer;
      }
    }]);

    return Debouncer;
  }();

  Polymer.Debouncer = Debouncer;
})();

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(1);

(function () {
  'use strict';

  var debouncerQueue = [];

  /**
   * Adds a `Polymer.Debouncer` to a list of globally flushable tasks.
   *
   * @memberof Polymer
   * @param {Polymer.Debouncer} debouncer Debouncer to enqueue
   */
  Polymer.enqueueDebouncer = function (debouncer) {
    debouncerQueue.push(debouncer);
  };

  function flushDebouncers() {
    var didFlush = Boolean(debouncerQueue.length);
    while (debouncerQueue.length) {
      try {
        debouncerQueue.shift().flush();
      } catch (e) {
        setTimeout(function () {
          throw e;
        });
      }
    }
    return didFlush;
  }

  /**
   * Forces several classes of asynchronously queued tasks to flush:
   * - Debouncers added via `enqueueDebouncer`
   * - ShadyDOM distribution
   *
   * @memberof Polymer
   */
  Polymer.flush = function () {
    var shadyDOM = void 0,
        debouncers = void 0;
    do {
      shadyDOM = window.ShadyDOM && ShadyDOM.flush();
      if (window.ShadyCSS && window.ShadyCSS.ScopingShim) {
        window.ShadyCSS.ScopingShim.flush();
      }
      debouncers = flushDebouncers();
    } while (shadyDOM || debouncers);
  };
})();

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

__webpack_require__(1);

__webpack_require__(11);

__webpack_require__(9);

(function () {
  'use strict';

  // Base class for HTMLTemplateElement extension that has property effects
  // machinery for propagating host properties to children. This is an ES5
  // class only because Babel (incorrectly) requires super() in the class
  // constructor even though no `this` is used and it returns an instance.

  var newInstance = null;
  /**
   * @constructor
   * @extends {HTMLTemplateElement}
   */
  function HTMLTemplateElementExtension() {
    return newInstance;
  }
  HTMLTemplateElementExtension.prototype = Object.create(HTMLTemplateElement.prototype, {
    constructor: {
      value: HTMLTemplateElementExtension,
      writable: true
    }
  });
  /**
   * @constructor
   * @implements {Polymer_PropertyEffects}
   * @extends {HTMLTemplateElementExtension}
   */
  var DataTemplate = Polymer.PropertyEffects(HTMLTemplateElementExtension);
  /**
   * @constructor
   * @implements {Polymer_MutableData}
   * @extends {DataTemplate}
   */
  var MutableDataTemplate = Polymer.MutableData(DataTemplate);

  // Applies a DataTemplate subclass to a <template> instance
  function upgradeTemplate(template, constructor) {
    newInstance = template;
    Object.setPrototypeOf(template, constructor.prototype);
    new constructor();
    newInstance = null;
  }

  // Base class for TemplateInstance's
  /**
   * @constructor
   * @implements {Polymer_PropertyEffects}
   */
  var base = Polymer.PropertyEffects(function () {
    function _class() {
      _classCallCheck(this, _class);
    }

    return _class;
  }());

  /**
   * @polymer
   * @customElement
   * @appliesMixin Polymer.PropertyEffects
   * @unrestricted
   */

  var TemplateInstanceBase = function (_base) {
    _inherits(TemplateInstanceBase, _base);

    function TemplateInstanceBase(props) {
      _classCallCheck(this, TemplateInstanceBase);

      var _this = _possibleConstructorReturn(this, (TemplateInstanceBase.__proto__ || Object.getPrototypeOf(TemplateInstanceBase)).call(this));

      _this._configureProperties(props);
      _this.root = _this._stampTemplate(_this.__dataHost);
      // Save list of stamped children
      var children = _this.children = [];
      for (var n = _this.root.firstChild; n; n = n.nextSibling) {
        children.push(n);
        n.__templatizeInstance = _this;
      }
      if (_this.__templatizeOwner.__hideTemplateChildren__) {
        _this._showHideChildren(true);
      }
      // Flush props only when props are passed if instance props exist
      // or when there isn't instance props.
      var options = _this.__templatizeOptions;
      if (props && options.instanceProps || !options.instanceProps) {
        _this._enableProperties();
      }
      return _this;
    }
    /**
     * Configure the given `props` by calling `_setPendingProperty`. Also
     * sets any properties stored in `__hostProps`.
     * @private
     * @param {Object} props Object of property name-value pairs to set.
     */


    _createClass(TemplateInstanceBase, [{
      key: '_configureProperties',
      value: function _configureProperties(props) {
        var options = this.__templatizeOptions;
        if (props) {
          for (var iprop in options.instanceProps) {
            if (iprop in props) {
              this._setPendingProperty(iprop, props[iprop]);
            }
          }
        }
        for (var hprop in this.__hostProps) {
          this._setPendingProperty(hprop, this.__dataHost['_host_' + hprop]);
        }
      }
      /**
       * Forwards a host property to this instance.  This method should be
       * called on instances from the `options.forwardHostProp` callback
       * to propagate changes of host properties to each instance.
       *
       * Note this method enqueues the change, which are flushed as a batch.
       *
       * @param {string} prop Property or path name
       * @param {*} value Value of the property to forward
       */

    }, {
      key: 'forwardHostProp',
      value: function forwardHostProp(prop, value) {
        if (this._setPendingPropertyOrPath(prop, value, false, true)) {
          this.__dataHost._enqueueClient(this);
        }
      }
      /**
       * @override
       */

    }, {
      key: '_addEventListenerToNode',
      value: function _addEventListenerToNode(node, eventName, handler) {
        var _this2 = this;

        if (this._methodHost && this.__templatizeOptions.parentModel) {
          // If this instance should be considered a parent model, decorate
          // events this template instance as `model`
          this._methodHost._addEventListenerToNode(node, eventName, function (e) {
            e.model = _this2;
            handler(e);
          });
        } else {
          // Otherwise delegate to the template's host (which could be)
          // another template instance
          var templateHost = this.__dataHost.__dataHost;
          if (templateHost) {
            templateHost._addEventListenerToNode(node, eventName, handler);
          }
        }
      }
      /**
       * Shows or hides the template instance top level child elements. For
       * text nodes, `textContent` is removed while "hidden" and replaced when
       * "shown."
       * @param {boolean} hide Set to true to hide the children;
       * set to false to show them.
       * @protected
       */

    }, {
      key: '_showHideChildren',
      value: function _showHideChildren(hide) {
        var c = this.children;
        for (var i = 0; i < c.length; i++) {
          var n = c[i];
          // Ignore non-changes
          if (Boolean(hide) != Boolean(n.__hideTemplateChildren__)) {
            if (n.nodeType === Node.TEXT_NODE) {
              if (hide) {
                n.__polymerTextContent__ = n.textContent;
                n.textContent = '';
              } else {
                n.textContent = n.__polymerTextContent__;
              }
            } else if (n.style) {
              if (hide) {
                n.__polymerDisplay__ = n.style.display;
                n.style.display = 'none';
              } else {
                n.style.display = n.__polymerDisplay__;
              }
            }
          }
          n.__hideTemplateChildren__ = hide;
          if (n._showHideChildren) {
            n._showHideChildren(hide);
          }
        }
      }
      /**
       * Overrides default property-effects implementation to intercept
       * textContent bindings while children are "hidden" and cache in
       * private storage for later retrieval.
       *
       * @override
       */

    }, {
      key: '_setUnmanagedPropertyToNode',
      value: function _setUnmanagedPropertyToNode(node, prop, value) {
        if (node.__hideTemplateChildren__ && node.nodeType == Node.TEXT_NODE && prop == 'textContent') {
          node.__polymerTextContent__ = value;
        } else {
          _get(TemplateInstanceBase.prototype.__proto__ || Object.getPrototypeOf(TemplateInstanceBase.prototype), '_setUnmanagedPropertyToNode', this).call(this, node, prop, value);
        }
      }
      /**
       * Find the parent model of this template instance.  The parent model
       * is either another templatize instance that had option `parentModel: true`,
       * or else the host element.
       *
       * @return {Polymer_PropertyEffects} The parent model of this instance
       */

    }, {
      key: 'parentModel',
      get: function get() {
        var model = this.__parentModel;
        if (!model) {
          var options = void 0;
          model = this;
          do {
            // A template instance's `__dataHost` is a <template>
            // `model.__dataHost.__dataHost` is the template's host
            model = model.__dataHost.__dataHost;
          } while ((options = model.__templatizeOptions) && !options.parentModel);
          this.__parentModel = model;
        }
        return model;
      }
    }]);

    return TemplateInstanceBase;
  }(base);

  /** @type {!DataTemplate} */


  TemplateInstanceBase.prototype.__dataHost;
  /** @type {!TemplatizeOptions} */
  TemplateInstanceBase.prototype.__templatizeOptions;
  /** @type {!Polymer_PropertyEffects} */
  TemplateInstanceBase.prototype._methodHost;
  /** @type {!Object} */
  TemplateInstanceBase.prototype.__templatizeOwner;
  /** @type {!Object} */
  TemplateInstanceBase.prototype.__hostProps;

  /**
   * @constructor
   * @extends {TemplateInstanceBase}
   * @implements {Polymer_MutableData}
   */
  var MutableTemplateInstanceBase = Polymer.MutableData(TemplateInstanceBase);

  function findMethodHost(template) {
    // Technically this should be the owner of the outermost template.
    // In shadow dom, this is always getRootNode().host, but we can
    // approximate this via cooperation with our dataHost always setting
    // `_methodHost` as long as there were bindings (or id's) on this
    // instance causing it to get a dataHost.
    var templateHost = template.__dataHost;
    return templateHost && templateHost._methodHost || templateHost;
  }

  /* eslint-disable valid-jsdoc */
  /**
   * @suppress {missingProperties} class.prototype is not defined for some reason
   */
  function createTemplatizerClass(template, templateInfo, options) {
    // Anonymous class created by the templatize
    var base = options.mutableData ? MutableTemplateInstanceBase : TemplateInstanceBase;
    /**
     * @constructor
     * @extends {base}
     */
    var klass = function (_base2) {
      _inherits(klass, _base2);

      function klass() {
        _classCallCheck(this, klass);

        return _possibleConstructorReturn(this, (klass.__proto__ || Object.getPrototypeOf(klass)).apply(this, arguments));
      }

      return klass;
    }(base);
    klass.prototype.__templatizeOptions = options;
    klass.prototype._bindTemplate(template);
    addNotifyEffects(klass, template, templateInfo, options);
    return klass;
  }

  /**
   * @suppress {missingProperties} class.prototype is not defined for some reason
   */
  function addPropagateEffects(template, templateInfo, options) {
    var userForwardHostProp = options.forwardHostProp;
    if (userForwardHostProp) {
      // Provide data API and property effects on memoized template class
      var klass = templateInfo.templatizeTemplateClass;
      if (!klass) {
        var _base3 = options.mutableData ? MutableDataTemplate : DataTemplate;
        klass = templateInfo.templatizeTemplateClass = function (_base4) {
          _inherits(TemplatizedTemplate, _base4);

          function TemplatizedTemplate() {
            _classCallCheck(this, TemplatizedTemplate);

            return _possibleConstructorReturn(this, (TemplatizedTemplate.__proto__ || Object.getPrototypeOf(TemplatizedTemplate)).apply(this, arguments));
          }

          return TemplatizedTemplate;
        }(_base3);
        // Add template - >instances effects
        // and host <- template effects
        var hostProps = templateInfo.hostProps;
        for (var prop in hostProps) {
          klass.prototype._addPropertyEffect('_host_' + prop, klass.prototype.PROPERTY_EFFECT_TYPES.PROPAGATE, { fn: createForwardHostPropEffect(prop, userForwardHostProp) });
          klass.prototype._createNotifyingProperty('_host_' + prop);
        }
      }
      upgradeTemplate(template, klass);
      // Mix any pre-bound data into __data; no need to flush this to
      // instances since they pull from the template at instance-time
      if (template.__dataProto) {
        // Note, generally `__dataProto` could be chained, but it's guaranteed
        // to not be since this is a vanilla template we just added effects to
        Object.assign(template.__data, template.__dataProto);
      }
      // Clear any pending data for performance
      template.__dataTemp = {};
      template.__dataPending = null;
      template.__dataOld = null;
      template._enableProperties();
    }
  }
  /* eslint-enable valid-jsdoc */

  function createForwardHostPropEffect(hostProp, userForwardHostProp) {
    return function forwardHostProp(template, prop, props) {
      userForwardHostProp.call(template.__templatizeOwner, prop.substring('_host_'.length), props[prop]);
    };
  }

  function addNotifyEffects(klass, template, templateInfo, options) {
    var hostProps = templateInfo.hostProps || {};
    for (var iprop in options.instanceProps) {
      delete hostProps[iprop];
      var userNotifyInstanceProp = options.notifyInstanceProp;
      if (userNotifyInstanceProp) {
        klass.prototype._addPropertyEffect(iprop, klass.prototype.PROPERTY_EFFECT_TYPES.NOTIFY, { fn: createNotifyInstancePropEffect(iprop, userNotifyInstanceProp) });
      }
    }
    if (options.forwardHostProp && template.__dataHost) {
      for (var hprop in hostProps) {
        klass.prototype._addPropertyEffect(hprop, klass.prototype.PROPERTY_EFFECT_TYPES.NOTIFY, { fn: createNotifyHostPropEffect() });
      }
    }
  }

  function createNotifyInstancePropEffect(instProp, userNotifyInstanceProp) {
    return function notifyInstanceProp(inst, prop, props) {
      userNotifyInstanceProp.call(inst.__templatizeOwner, inst, prop, props[prop]);
    };
  }

  function createNotifyHostPropEffect() {
    return function notifyHostProp(inst, prop, props) {
      inst.__dataHost._setPendingPropertyOrPath('_host_' + prop, props[prop], true, true);
    };
  }

  /**
   * Module for preparing and stamping instances of templates that utilize
   * Polymer's data-binding and declarative event listener features.
   *
   * Example:
   *
   *     // Get a template from somewhere, e.g. light DOM
   *     let template = this.querySelector('template');
   *     // Prepare the template
   *     let TemplateClass = Polymer.Templatize.templatize(template);
   *     // Instance the template with an initial data model
   *     let instance = new TemplateClass({myProp: 'initial'});
   *     // Insert the instance's DOM somewhere, e.g. element's shadow DOM
   *     this.shadowRoot.appendChild(instance.root);
   *     // Changing a property on the instance will propagate to bindings
   *     // in the template
   *     instance.myProp = 'new value';
   *
   * The `options` dictionary passed to `templatize` allows for customizing
   * features of the generated template class, including how outer-scope host
   * properties should be forwarded into template instances, how any instance
   * properties added into the template's scope should be notified out to
   * the host, and whether the instance should be decorated as a "parent model"
   * of any event handlers.
   *
   *     // Customze property forwarding and event model decoration
   *     let TemplateClass = Polymer.Templatize.templatize(template, this, {
   *       parentModel: true,
   *       instanceProps: {...},
   *       forwardHostProp(property, value) {...},
   *       notifyInstanceProp(instance, property, value) {...},
   *     });
   *
   *
   * @namespace
   * @memberof Polymer
   * @summary Module for preparing and stamping instances of templates
   *   utilizing Polymer templating features.
   */

  var Templatize = {

    /**
     * Returns an anonymous `Polymer.PropertyEffects` class bound to the
     * `<template>` provided.  Instancing the class will result in the
     * template being stamped into document fragment stored as the instance's
     * `root` property, after which it can be appended to the DOM.
     *
     * Templates may utilize all Polymer data-binding features as well as
     * declarative event listeners.  Event listeners and inline computing
     * functions in the template will be called on the host of the template.
     *
     * The constructor returned takes a single argument dictionary of initial
     * property values to propagate into template bindings.  Additionally
     * host properties can be forwarded in, and instance properties can be
     * notified out by providing optional callbacks in the `options` dictionary.
     *
     * Valid configuration in `options` are as follows:
     *
     * - `forwardHostProp(property, value)`: Called when a property referenced
     *   in the template changed on the template's host. As this library does
     *   not retain references to templates instanced by the user, it is the
     *   templatize owner's responsibility to forward host property changes into
     *   user-stamped instances.  The `instance.forwardHostProp(property, value)`
     *    method on the generated class should be called to forward host
     *   properties into the template to prevent unnecessary property-changed
     *   notifications. Any properties referenced in the template that are not
     *   defined in `instanceProps` will be notified up to the template's host
     *   automatically.
     * - `instanceProps`: Dictionary of property names that will be added
     *   to the instance by the templatize owner.  These properties shadow any
     *   host properties, and changes within the template to these properties
     *   will result in `notifyInstanceProp` being called.
     * - `mutableData`: When `true`, the generated class will skip strict
     *   dirty-checking for objects and arrays (always consider them to be
     *   "dirty").
     * - `notifyInstanceProp(instance, property, value)`: Called when
     *   an instance property changes.  Users may choose to call `notifyPath`
     *   on e.g. the owner to notify the change.
     * - `parentModel`: When `true`, events handled by declarative event listeners
     *   (`on-event="handler"`) will be decorated with a `model` property pointing
     *   to the template instance that stamped it.  It will also be returned
     *   from `instance.parentModel` in cases where template instance nesting
     *   causes an inner model to shadow an outer model.
     *
     * Note that the class returned from `templatize` is generated only once
     * for a given `<template>` using `options` from the first call for that
     * template, and the cached class is returned for all subsequent calls to
     * `templatize` for that template.  As such, `options` callbacks should not
     * close over owner-specific properties since only the first `options` is
     * used; rather, callbacks are called bound to the `owner`, and so context
     * needed from the callbacks (such as references to `instances` stamped)
     * should be stored on the `owner` such that they can be retrieved via `this`.
     *
     * @memberof Polymer.Templatize
     * @param {!HTMLTemplateElement} template Template to templatize
     * @param {!Polymer_PropertyEffects} owner Owner of the template instances;
     *   any optional callbacks will be bound to this owner.
     * @param {Object=} options Options dictionary (see summary for details)
     * @return {function(new:TemplateInstanceBase)} Generated class bound to the template
     *   provided
     * @suppress {invalidCasts}
     */
    templatize: function templatize(template, owner, options) {
      options = /** @type {!TemplatizeOptions} */options || {};
      if (template.__templatizeOwner) {
        throw new Error('A <template> can only be templatized once');
      }
      template.__templatizeOwner = owner;
      var templateInfo = owner.constructor._parseTemplate(template);
      // Get memoized base class for the prototypical template, which
      // includes property effects for binding template & forwarding
      var baseClass = templateInfo.templatizeInstanceClass;
      if (!baseClass) {
        baseClass = createTemplatizerClass(template, templateInfo, options);
        templateInfo.templatizeInstanceClass = baseClass;
      }
      // Host property forwarding must be installed onto template instance
      addPropagateEffects(template, templateInfo, options);
      // Subclass base class and add reference for this specific template
      var klass = function (_baseClass) {
        _inherits(TemplateInstance, _baseClass);

        function TemplateInstance() {
          _classCallCheck(this, TemplateInstance);

          return _possibleConstructorReturn(this, (TemplateInstance.__proto__ || Object.getPrototypeOf(TemplateInstance)).apply(this, arguments));
        }

        return TemplateInstance;
      }(baseClass);
      klass.prototype._methodHost = findMethodHost(template);
      klass.prototype.__dataHost = template;
      klass.prototype.__templatizeOwner = owner;
      klass.prototype.__hostProps = templateInfo.hostProps;
      return (/** @type {function(new:TemplateInstanceBase)} */klass
      );
    },


    /**
     * Returns the template "model" associated with a given element, which
     * serves as the binding scope for the template instance the element is
     * contained in. A template model is an instance of
     * `TemplateInstanceBase`, and should be used to manipulate data
     * associated with this template instance.
     *
     * Example:
     *
     *   let model = modelForElement(el);
     *   if (model.index < 10) {
     *     model.set('item.checked', true);
     *   }
     *
     * @memberof Polymer.Templatize
     * @param {HTMLTemplateElement} template The model will be returned for
     *   elements stamped from this template
     * @param {Node} node Node for which to return a template model.
     * @return {TemplateInstanceBase} Template instance representing the
     *   binding scope for the element
     */
    modelForElement: function modelForElement(template, node) {
      var model = void 0;
      while (node) {
        // An element with a __templatizeInstance marks the top boundary
        // of a scope; walk up until we find one, and then ensure that
        // its __dataHost matches `this`, meaning this dom-repeat stamped it
        if (model = node.__templatizeInstance) {
          // Found an element stamped by another template; keep walking up
          // from its __dataHost
          if (model.__dataHost != template) {
            node = model.__dataHost;
          } else {
            return model;
          }
        } else {
          // Still in a template scope, keep going up until
          // a __templatizeInstance is found
          node = node.parentNode;
        }
      }
      return null;
    }
  };

  Polymer.Templatize = Templatize;
  Polymer.TemplateInstanceBase = TemplateInstanceBase;
})();

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

__webpack_require__(17);

/**
 * @polymerBehavior Polymer.AppLayoutBehavior
 **/
Polymer.AppLayoutBehavior = [Polymer.IronResizableBehavior, {

  listeners: {
    'app-reset-layout': '_appResetLayoutHandler',
    'iron-resize': 'resetLayout'
  },

  attached: function attached() {
    this.fire('app-reset-layout');
  },

  _appResetLayoutHandler: function _appResetLayoutHandler(e) {
    if (Polymer.dom(e).path[0] === this) {
      return;
    }
    this.resetLayout();
    e.stopPropagation();
  },

  _updateLayoutStates: function _updateLayoutStates() {
    console.error('unimplemented');
  },

  /**
   * Resets the layout. If you changed the size of this element via CSS
   * you can notify the changes by either firing the `iron-resize` event
   * or calling `resetLayout` directly.
   *
   * @method resetLayout
   */
  resetLayout: function resetLayout() {
    // Polymer v2.x
    var self = this;
    var cb = this._updateLayoutStates.bind(this);
    if (Polymer.Async && Polymer.Async.animationFrame) {
      this._layoutDebouncer = Polymer.Debouncer.debounce(this._layoutDebouncer, Polymer.Async.animationFrame, cb);
      Polymer.enqueueDebouncer(this._layoutDebouncer);
    }
    // Polymer v1.x
    else {
        this.debounce('resetLayout', cb);
      }
    this._notifyDescendantResize();
  },

  _notifyLayoutChanged: function _notifyLayoutChanged() {
    var self = this;
    // TODO: the event `app-reset-layout` can be fired synchronously
    // as long as `_updateLayoutStates` waits for all the microtasks after rAF.
    // E.g. requestAnimationFrame(setTimeOut())
    requestAnimationFrame(function () {
      self.fire('app-reset-layout');
    });
  },

  _notifyDescendantResize: function _notifyDescendantResize() {
    if (!this.isAttached) {
      return;
    }
    this._interestedResizables.forEach(function (resizable) {
      if (this.resizerShouldNotify(resizable)) {
        this._notifyDescendant(resizable);
      }
    }, this);
  }
}];

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

(function () {
  'use strict';

  /**
   * Chrome uses an older version of DOM Level 3 Keyboard Events
   *
   * Most keys are labeled as text, but some are Unicode codepoints.
   * Values taken from: http://www.w3.org/TR/2007/WD-DOM-Level-3-Events-20071221/keyset.html#KeySet-Set
   */

  var KEY_IDENTIFIER = {
    'U+0008': 'backspace',
    'U+0009': 'tab',
    'U+001B': 'esc',
    'U+0020': 'space',
    'U+007F': 'del'
  };

  /**
   * Special table for KeyboardEvent.keyCode.
   * KeyboardEvent.keyIdentifier is better, and KeyBoardEvent.key is even better
   * than that.
   *
   * Values from: https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent.keyCode#Value_of_keyCode
   */
  var KEY_CODE = {
    8: 'backspace',
    9: 'tab',
    13: 'enter',
    27: 'esc',
    33: 'pageup',
    34: 'pagedown',
    35: 'end',
    36: 'home',
    32: 'space',
    37: 'left',
    38: 'up',
    39: 'right',
    40: 'down',
    46: 'del',
    106: '*'
  };

  /**
   * MODIFIER_KEYS maps the short name for modifier keys used in a key
   * combo string to the property name that references those same keys
   * in a KeyboardEvent instance.
   */
  var MODIFIER_KEYS = {
    'shift': 'shiftKey',
    'ctrl': 'ctrlKey',
    'alt': 'altKey',
    'meta': 'metaKey'
  };

  /**
   * KeyboardEvent.key is mostly represented by printable character made by
   * the keyboard, with unprintable keys labeled nicely.
   *
   * However, on OS X, Alt+char can make a Unicode character that follows an
   * Apple-specific mapping. In this case, we fall back to .keyCode.
   */
  var KEY_CHAR = /[a-z0-9*]/;

  /**
   * Matches a keyIdentifier string.
   */
  var IDENT_CHAR = /U\+/;

  /**
   * Matches arrow keys in Gecko 27.0+
   */
  var ARROW_KEY = /^arrow/;

  /**
   * Matches space keys everywhere (notably including IE10's exceptional name
   * `spacebar`).
   */
  var SPACE_KEY = /^space(bar)?/;

  /**
   * Matches ESC key.
   *
   * Value from: http://w3c.github.io/uievents-key/#key-Escape
   */
  var ESC_KEY = /^escape$/;

  /**
   * Transforms the key.
   * @param {string} key The KeyBoardEvent.key
   * @param {Boolean} [noSpecialChars] Limits the transformation to
   * alpha-numeric characters.
   */
  function transformKey(key, noSpecialChars) {
    var validKey = '';
    if (key) {
      var lKey = key.toLowerCase();
      if (lKey === ' ' || SPACE_KEY.test(lKey)) {
        validKey = 'space';
      } else if (ESC_KEY.test(lKey)) {
        validKey = 'esc';
      } else if (lKey.length == 1) {
        if (!noSpecialChars || KEY_CHAR.test(lKey)) {
          validKey = lKey;
        }
      } else if (ARROW_KEY.test(lKey)) {
        validKey = lKey.replace('arrow', '');
      } else if (lKey == 'multiply') {
        // numpad '*' can map to Multiply on IE/Windows
        validKey = '*';
      } else {
        validKey = lKey;
      }
    }
    return validKey;
  }

  function transformKeyIdentifier(keyIdent) {
    var validKey = '';
    if (keyIdent) {
      if (keyIdent in KEY_IDENTIFIER) {
        validKey = KEY_IDENTIFIER[keyIdent];
      } else if (IDENT_CHAR.test(keyIdent)) {
        keyIdent = parseInt(keyIdent.replace('U+', '0x'), 16);
        validKey = String.fromCharCode(keyIdent).toLowerCase();
      } else {
        validKey = keyIdent.toLowerCase();
      }
    }
    return validKey;
  }

  function transformKeyCode(keyCode) {
    var validKey = '';
    if (Number(keyCode)) {
      if (keyCode >= 65 && keyCode <= 90) {
        // ascii a-z
        // lowercase is 32 offset from uppercase
        validKey = String.fromCharCode(32 + keyCode);
      } else if (keyCode >= 112 && keyCode <= 123) {
        // function keys f1-f12
        validKey = 'f' + (keyCode - 112 + 1);
      } else if (keyCode >= 48 && keyCode <= 57) {
        // top 0-9 keys
        validKey = String(keyCode - 48);
      } else if (keyCode >= 96 && keyCode <= 105) {
        // num pad 0-9
        validKey = String(keyCode - 96);
      } else {
        validKey = KEY_CODE[keyCode];
      }
    }
    return validKey;
  }

  /**
    * Calculates the normalized key for a KeyboardEvent.
    * @param {KeyboardEvent} keyEvent
    * @param {Boolean} [noSpecialChars] Set to true to limit keyEvent.key
    * transformation to alpha-numeric chars. This is useful with key
    * combinations like shift + 2, which on FF for MacOS produces
    * keyEvent.key = @
    * To get 2 returned, set noSpecialChars = true
    * To get @ returned, set noSpecialChars = false
   */
  function normalizedKeyForEvent(keyEvent, noSpecialChars) {
    // Fall back from .key, to .detail.key for artifical keyboard events,
    // and then to deprecated .keyIdentifier and .keyCode.
    if (keyEvent.key) {
      return transformKey(keyEvent.key, noSpecialChars);
    }
    if (keyEvent.detail && keyEvent.detail.key) {
      return transformKey(keyEvent.detail.key, noSpecialChars);
    }
    return transformKeyIdentifier(keyEvent.keyIdentifier) || transformKeyCode(keyEvent.keyCode) || '';
  }

  function keyComboMatchesEvent(keyCombo, event) {
    // For combos with modifiers we support only alpha-numeric keys
    var keyEvent = normalizedKeyForEvent(event, keyCombo.hasModifiers);
    return keyEvent === keyCombo.key && (!keyCombo.hasModifiers || !!event.shiftKey === !!keyCombo.shiftKey && !!event.ctrlKey === !!keyCombo.ctrlKey && !!event.altKey === !!keyCombo.altKey && !!event.metaKey === !!keyCombo.metaKey);
  }

  function parseKeyComboString(keyComboString) {
    if (keyComboString.length === 1) {
      return {
        combo: keyComboString,
        key: keyComboString,
        event: 'keydown'
      };
    }
    return keyComboString.split('+').reduce(function (parsedKeyCombo, keyComboPart) {
      var eventParts = keyComboPart.split(':');
      var keyName = eventParts[0];
      var event = eventParts[1];

      if (keyName in MODIFIER_KEYS) {
        parsedKeyCombo[MODIFIER_KEYS[keyName]] = true;
        parsedKeyCombo.hasModifiers = true;
      } else {
        parsedKeyCombo.key = keyName;
        parsedKeyCombo.event = event || 'keydown';
      }

      return parsedKeyCombo;
    }, {
      combo: keyComboString.split(':').shift()
    });
  }

  function parseEventString(eventString) {
    return eventString.trim().split(' ').map(function (keyComboString) {
      return parseKeyComboString(keyComboString);
    });
  }

  /**
   * `Polymer.IronA11yKeysBehavior` provides a normalized interface for processing
   * keyboard commands that pertain to [WAI-ARIA best practices](http://www.w3.org/TR/wai-aria-practices/#kbd_general_binding).
   * The element takes care of browser differences with respect to Keyboard events
   * and uses an expressive syntax to filter key presses.
   *
   * Use the `keyBindings` prototype property to express what combination of keys
   * will trigger the callback. A key binding has the format
   * `"KEY+MODIFIER:EVENT": "callback"` (`"KEY": "callback"` or
   * `"KEY:EVENT": "callback"` are valid as well). Some examples:
   *
   *      keyBindings: {
   *        'space': '_onKeydown', // same as 'space:keydown'
   *        'shift+tab': '_onKeydown',
   *        'enter:keypress': '_onKeypress',
   *        'esc:keyup': '_onKeyup'
   *      }
   *
   * The callback will receive with an event containing the following information in `event.detail`:
   *
   *      _onKeydown: function(event) {
   *        console.log(event.detail.combo); // KEY+MODIFIER, e.g. "shift+tab"
   *        console.log(event.detail.key); // KEY only, e.g. "tab"
   *        console.log(event.detail.event); // EVENT, e.g. "keydown"
   *        console.log(event.detail.keyboardEvent); // the original KeyboardEvent
   *      }
   *
   * Use the `keyEventTarget` attribute to set up event handlers on a specific
   * node.
   *
   * See the [demo source code](https://github.com/PolymerElements/iron-a11y-keys-behavior/blob/master/demo/x-key-aware.html)
   * for an example.
   *
   * @demo demo/index.html
   * @polymerBehavior
   */
  Polymer.IronA11yKeysBehavior = {
    properties: {
      /**
       * The EventTarget that will be firing relevant KeyboardEvents. Set it to
       * `null` to disable the listeners.
       * @type {?EventTarget}
       */
      keyEventTarget: {
        type: Object,
        value: function value() {
          return this;
        }
      },

      /**
       * If true, this property will cause the implementing element to
       * automatically stop propagation on any handled KeyboardEvents.
       */
      stopKeyboardEventPropagation: {
        type: Boolean,
        value: false
      },

      _boundKeyHandlers: {
        type: Array,
        value: function value() {
          return [];
        }
      },

      // We use this due to a limitation in IE10 where instances will have
      // own properties of everything on the "prototype".
      _imperativeKeyBindings: {
        type: Object,
        value: function value() {
          return {};
        }
      }
    },

    observers: ['_resetKeyEventListeners(keyEventTarget, _boundKeyHandlers)'],

    /**
     * To be used to express what combination of keys  will trigger the relative
     * callback. e.g. `keyBindings: { 'esc': '_onEscPressed'}`
     * @type {!Object}
     */
    keyBindings: {},

    registered: function registered() {
      this._prepKeyBindings();
    },

    attached: function attached() {
      this._listenKeyEventListeners();
    },

    detached: function detached() {
      this._unlistenKeyEventListeners();
    },

    /**
     * Can be used to imperatively add a key binding to the implementing
     * element. This is the imperative equivalent of declaring a keybinding
     * in the `keyBindings` prototype property.
     *
     * @param {string} eventString
     * @param {string} handlerName
     */
    addOwnKeyBinding: function addOwnKeyBinding(eventString, handlerName) {
      this._imperativeKeyBindings[eventString] = handlerName;
      this._prepKeyBindings();
      this._resetKeyEventListeners();
    },

    /**
     * When called, will remove all imperatively-added key bindings.
     */
    removeOwnKeyBindings: function removeOwnKeyBindings() {
      this._imperativeKeyBindings = {};
      this._prepKeyBindings();
      this._resetKeyEventListeners();
    },

    /**
     * Returns true if a keyboard event matches `eventString`.
     *
     * @param {KeyboardEvent} event
     * @param {string} eventString
     * @return {boolean}
     */
    keyboardEventMatchesKeys: function keyboardEventMatchesKeys(event, eventString) {
      var keyCombos = parseEventString(eventString);
      for (var i = 0; i < keyCombos.length; ++i) {
        if (keyComboMatchesEvent(keyCombos[i], event)) {
          return true;
        }
      }
      return false;
    },

    _collectKeyBindings: function _collectKeyBindings() {
      var keyBindings = this.behaviors.map(function (behavior) {
        return behavior.keyBindings;
      });

      if (keyBindings.indexOf(this.keyBindings) === -1) {
        keyBindings.push(this.keyBindings);
      }

      return keyBindings;
    },

    _prepKeyBindings: function _prepKeyBindings() {
      this._keyBindings = {};

      this._collectKeyBindings().forEach(function (keyBindings) {
        for (var eventString in keyBindings) {
          this._addKeyBinding(eventString, keyBindings[eventString]);
        }
      }, this);

      for (var eventString in this._imperativeKeyBindings) {
        this._addKeyBinding(eventString, this._imperativeKeyBindings[eventString]);
      }

      // Give precedence to combos with modifiers to be checked first.
      for (var eventName in this._keyBindings) {
        this._keyBindings[eventName].sort(function (kb1, kb2) {
          var b1 = kb1[0].hasModifiers;
          var b2 = kb2[0].hasModifiers;
          return b1 === b2 ? 0 : b1 ? -1 : 1;
        });
      }
    },

    _addKeyBinding: function _addKeyBinding(eventString, handlerName) {
      parseEventString(eventString).forEach(function (keyCombo) {
        this._keyBindings[keyCombo.event] = this._keyBindings[keyCombo.event] || [];

        this._keyBindings[keyCombo.event].push([keyCombo, handlerName]);
      }, this);
    },

    _resetKeyEventListeners: function _resetKeyEventListeners() {
      this._unlistenKeyEventListeners();

      if (this.isAttached) {
        this._listenKeyEventListeners();
      }
    },

    _listenKeyEventListeners: function _listenKeyEventListeners() {
      if (!this.keyEventTarget) {
        return;
      }
      Object.keys(this._keyBindings).forEach(function (eventName) {
        var keyBindings = this._keyBindings[eventName];
        var boundKeyHandler = this._onKeyBindingEvent.bind(this, keyBindings);

        this._boundKeyHandlers.push([this.keyEventTarget, eventName, boundKeyHandler]);

        this.keyEventTarget.addEventListener(eventName, boundKeyHandler);
      }, this);
    },

    _unlistenKeyEventListeners: function _unlistenKeyEventListeners() {
      var keyHandlerTuple;
      var keyEventTarget;
      var eventName;
      var boundKeyHandler;

      while (this._boundKeyHandlers.length) {
        // My kingdom for block-scope binding and destructuring assignment..
        keyHandlerTuple = this._boundKeyHandlers.pop();
        keyEventTarget = keyHandlerTuple[0];
        eventName = keyHandlerTuple[1];
        boundKeyHandler = keyHandlerTuple[2];

        keyEventTarget.removeEventListener(eventName, boundKeyHandler);
      }
    },

    _onKeyBindingEvent: function _onKeyBindingEvent(keyBindings, event) {
      if (this.stopKeyboardEventPropagation) {
        event.stopPropagation();
      }

      // if event has been already prevented, don't do anything
      if (event.defaultPrevented) {
        return;
      }

      for (var i = 0; i < keyBindings.length; i++) {
        var keyCombo = keyBindings[i][0];
        var handlerName = keyBindings[i][1];
        if (keyComboMatchesEvent(keyCombo, event)) {
          this._triggerKeyHandler(keyCombo, handlerName, event);
          // exit the loop if eventDefault was prevented
          if (event.defaultPrevented) {
            return;
          }
        }
      }
    },

    _triggerKeyHandler: function _triggerKeyHandler(keyCombo, handlerName, keyboardEvent) {
      var detail = Object.create(keyCombo);
      detail.keyboardEvent = keyboardEvent;
      var event = new CustomEvent(keyCombo.event, {
        detail: detail,
        cancelable: true
      });
      this[handlerName].call(this, event);
      if (event.defaultPrevented) {
        keyboardEvent.preventDefault();
      }
    }
  };
})();

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

/**
 * `IronResizableBehavior` is a behavior that can be used in Polymer elements to
 * coordinate the flow of resize events between "resizers" (elements that control the
 * size or hidden state of their children) and "resizables" (elements that need to be
 * notified when they are resized or un-hidden by their parents in order to take
 * action on their new measurements).
 *
 * Elements that perform measurement should add the `IronResizableBehavior` behavior to
 * their element definition and listen for the `iron-resize` event on themselves.
 * This event will be fired when they become showing after having been hidden,
 * when they are resized explicitly by another resizable, or when the window has been
 * resized.
 *
 * Note, the `iron-resize` event is non-bubbling.
 *
 * @polymerBehavior Polymer.IronResizableBehavior
 * @demo demo/index.html
 **/
Polymer.IronResizableBehavior = {
  properties: {
    /**
     * The closest ancestor element that implements `IronResizableBehavior`.
     */
    _parentResizable: {
      type: Object,
      observer: '_parentResizableChanged'
    },

    /**
     * True if this element is currently notifying its descendant elements of
     * resize.
     */
    _notifyingDescendant: {
      type: Boolean,
      value: false
    }
  },

  listeners: {
    'iron-request-resize-notifications': '_onIronRequestResizeNotifications'
  },

  created: function created() {
    // We don't really need property effects on these, and also we want them
    // to be created before the `_parentResizable` observer fires:
    this._interestedResizables = [];
    this._boundNotifyResize = this.notifyResize.bind(this);
  },

  attached: function attached() {
    this._requestResizeNotifications();
  },

  detached: function detached() {
    if (this._parentResizable) {
      this._parentResizable.stopResizeNotificationsFor(this);
    } else {
      window.removeEventListener('resize', this._boundNotifyResize);
    }

    this._parentResizable = null;
  },

  /**
   * Can be called to manually notify a resizable and its descendant
   * resizables of a resize change.
   */
  notifyResize: function notifyResize() {
    if (!this.isAttached) {
      return;
    }

    this._interestedResizables.forEach(function (resizable) {
      if (this.resizerShouldNotify(resizable)) {
        this._notifyDescendant(resizable);
      }
    }, this);

    this._fireResize();
  },

  /**
   * Used to assign the closest resizable ancestor to this resizable
   * if the ancestor detects a request for notifications.
   */
  assignParentResizable: function assignParentResizable(parentResizable) {
    this._parentResizable = parentResizable;
  },

  /**
   * Used to remove a resizable descendant from the list of descendants
   * that should be notified of a resize change.
   */
  stopResizeNotificationsFor: function stopResizeNotificationsFor(target) {
    var index = this._interestedResizables.indexOf(target);

    if (index > -1) {
      this._interestedResizables.splice(index, 1);
      this.unlisten(target, 'iron-resize', '_onDescendantIronResize');
    }
  },

  /**
   * This method can be overridden to filter nested elements that should or
   * should not be notified by the current element. Return true if an element
   * should be notified, or false if it should not be notified.
   *
   * @param {HTMLElement} element A candidate descendant element that
   * implements `IronResizableBehavior`.
   * @return {boolean} True if the `element` should be notified of resize.
   */
  resizerShouldNotify: function resizerShouldNotify(element) {
    return true;
  },

  _onDescendantIronResize: function _onDescendantIronResize(event) {
    if (this._notifyingDescendant) {
      event.stopPropagation();
      return;
    }

    // NOTE(cdata): In ShadowDOM, event retargeting makes echoing of the
    // otherwise non-bubbling event "just work." We do it manually here for
    // the case where Polymer is not using shadow roots for whatever reason:
    if (!Polymer.Settings.useShadow) {
      this._fireResize();
    }
  },

  _fireResize: function _fireResize() {
    this.fire('iron-resize', null, {
      node: this,
      bubbles: false
    });
  },

  _onIronRequestResizeNotifications: function _onIronRequestResizeNotifications(event) {
    var target = /** @type {!EventTarget} */Polymer.dom(event).rootTarget;
    if (target === this) {
      return;
    }

    if (this._interestedResizables.indexOf(target) === -1) {
      this._interestedResizables.push(target);
      this.listen(target, 'iron-resize', '_onDescendantIronResize');
    }

    target.assignParentResizable(this);
    this._notifyDescendant(target);

    event.stopPropagation();
  },

  _parentResizableChanged: function _parentResizableChanged(parentResizable) {
    if (parentResizable) {
      window.removeEventListener('resize', this._boundNotifyResize);
    }
  },

  _notifyDescendant: function _notifyDescendant(descendant) {
    // NOTE(cdata): In IE10, attached is fired on children first, so it's
    // important not to notify them if the parent is not attached yet (or
    // else they will get redundantly notified when the parent attaches).
    if (!this.isAttached) {
      return;
    }

    this._notifyingDescendant = true;
    descendant.notifyResize();
    this._notifyingDescendant = false;
  },

  _requestResizeNotifications: function _requestResizeNotifications() {
    if (!this.isAttached) return;

    // NOTE(valdrin) In CustomElements v1 with native HTMLImports, the order
    // of imports affects the order of `attached` callbacks (see webcomponents/custom-elements#15).
    // This might cause a child to notify parents too early (as the parent
    // still has to be upgraded), resulting in a parent not able to keep track
    // of the `_interestedResizables`. To solve this, we wait for the document
    // to be done loading before firing the event.
    if (document.readyState === 'loading') {
      var _requestResizeNotifications = this._requestResizeNotifications.bind(this);
      document.addEventListener('readystatechange', function readystatechanged() {
        document.removeEventListener('readystatechange', readystatechanged);
        _requestResizeNotifications();
      });
    } else {
      this.fire('iron-request-resize-notifications', null, {
        node: this,
        bubbles: true,
        cancelable: true
      });

      if (!this._parentResizable) {
        window.addEventListener('resize', this._boundNotifyResize);
        this.notifyResize();
      }
    }
  }
};

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

(function () {

  /**
   * @constructor
   * @param {{type: (string|null), key: (string|null), value: *}} options
   */
  function IronMeta(options) {
    this.type = options && options.type || 'default';
    this.key = options && options.key;
    if ('value' in options) {
      this.value = options.value;
    }
  }

  IronMeta.types = {};

  IronMeta.prototype = {
    get value() {
      var type = this.type;
      var key = this.key;

      if (type && key) {
        return IronMeta.types[type] && IronMeta.types[type][key];
      }
    },

    set value(value) {
      var type = this.type;
      var key = this.key;

      if (type && key) {
        type = IronMeta.types[type] = IronMeta.types[type] || {};
        if (value == null) {
          delete type[key];
        } else {
          type[key] = value;
        }
      }
    },

    get list() {
      var type = this.type;

      if (type) {
        return Object.keys(IronMeta.types[this.type]).map(function (key) {
          return metaDatas[this.type][key];
        }, this);
      }
    },

    byKey: function byKey(key) {
      this.key = key;
      return this.value;
    }
  };

  Polymer.IronMeta = IronMeta;

  var metaDatas = Polymer.IronMeta.types;

  Polymer({

    is: 'iron-meta',

    properties: {

      /**
       * The type of meta-data.  All meta-data of the same type is stored
       * together.
       * @type {string}
       */
      type: {
        type: String,
        value: 'default'
      },

      /**
       * The key used to store `value` under the `type` namespace.
       * @type {?string}
       */
      key: {
        type: String
      },

      /**
       * The meta-data to store or retrieve.
       * @type {*}
       */
      value: {
        type: String,
        notify: true
      },

      /**
       * If true, `value` is set to the iron-meta instance itself.
       */
      self: {
        type: Boolean,
        observer: '_selfChanged'
      },

      __meta: {
        type: Boolean,
        computed: '__computeMeta(type, key, value)'
      }
    },

    hostAttributes: {
      hidden: true
    },

    __computeMeta: function __computeMeta(type, key, value) {
      var meta = new Polymer.IronMeta({
        type: type,
        key: key
      });

      if (value !== undefined && value !== meta.value) {
        meta.value = value;
      } else if (this.value !== meta.value) {
        this.value = meta.value;
      }

      return meta;
    },

    get list() {
      return this.__meta && this.__meta.list;
    },

    _selfChanged: function _selfChanged(self) {
      if (self) {
        this.value = this;
      }
    },

    /**
     * Retrieves meta data value by key.
     *
     * @method byKey
     * @param {string} key The key of the meta-data to be returned.
     * @return {*}
     */
    byKey: function byKey(key) {
      return new Polymer.IronMeta({
        type: this.type,
        key: key
      }).value;
    }
  });
})();

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

__webpack_require__(1);

__webpack_require__(20);

__webpack_require__(3);

__webpack_require__(10);

__webpack_require__(21);

__webpack_require__(7);

__webpack_require__(41);

__webpack_require__(11);

(function () {
  'use strict';

  /**
   * Element class mixin that provides the core API for Polymer's meta-programming
   * features including template stamping, data-binding, attribute deserialization,
   * and property change observation.
   *
   * Subclassers may provide the following static getters to return metadata
   * used to configure Polymer's features for the class:
   *
   * - `static get is()`: When the template is provided via a `dom-module`,
   *   users should return the `dom-module` id from a static `is` getter.  If
   *   no template is needed or the template is provided directly via the
   *   `template` getter, there is no need to define `is` for the element.
   *
   * - `static get template()`: Users may provide the template directly (as
   *   opposed to via `dom-module`) by implementing a static `template` getter.
   *   The getter may return an `HTMLTemplateElement` or a string, which will
   *   automatically be parsed into a template.
   *
   * - `static get properties()`: Should return an object describing
   *   property-related metadata used by Polymer features (key: property name
   *   value: object containing property metadata). Valid keys in per-property
   *   metadata include:
   *   - `type` (String|Number|Object|Array|...): Used by
   *     `attributeChangedCallback` to determine how string-based attributes
   *     are deserialized to JavaScript property values.
   *   - `notify` (boolean): Causes a change in the property to fire a
   *     non-bubbling event called `<property>-changed`. Elements that have
   *     enabled two-way binding to the property use this event to observe changes.
   *   - `readOnly` (boolean): Creates a getter for the property, but no setter.
   *     To set a read-only property, use the private setter method
   *     `_setProperty(property, value)`.
   *   - `observer` (string): Observer method name that will be called when
   *     the property changes. The arguments of the method are
   *     `(value, previousValue)`.
   *   - `computed` (string): String describing method and dependent properties
   *     for computing the value of this property (e.g. `'computeFoo(bar, zot)'`).
   *     Computed properties are read-only by default and can only be changed
   *     via the return value of the computing method.
   *
   * - `static get observers()`: Array of strings describing multi-property
   *   observer methods and their dependent properties (e.g.
   *   `'observeABC(a, b, c)'`).
   *
   * The base class provides default implementations for the following standard
   * custom element lifecycle callbacks; users may override these, but should
   * call the super method to ensure
   * - `constructor`: Run when the element is created or upgraded
   * - `connectedCallback`: Run each time the element is connected to the
   *   document
   * - `disconnectedCallback`: Run each time the element is disconnected from
   *   the document
   * - `attributeChangedCallback`: Run each time an attribute in
   *   `observedAttributes` is set or removed (note: this element's default
   *   `observedAttributes` implementation will automatically return an array
   *   of dash-cased attributes based on `properties`)
   *
   * @mixinFunction
   * @polymer
   * @appliesMixin Polymer.PropertyEffects
   * @memberof Polymer
   * @property rootPath {string} Set to the value of `Polymer.rootPath`,
   *   which defaults to the main document path
   * @property importPath {string} Set to the value of the class's static
   *   `importPath` property, which defaults to the path of this element's
   *   `dom-module` (when `is` is used), but can be overridden for other
   *   import strategies.
   * @summary Element class mixin that provides the core API for Polymer's
   * meta-programming features.
   */

  Polymer.ElementMixin = Polymer.dedupingMixin(function (base) {

    /**
     * @constructor
     * @extends {base}
     * @implements {Polymer_PropertyEffects}
     */
    var polymerElementBase = Polymer.PropertyEffects(base);

    var caseMap = Polymer.CaseMap;

    /**
     * Returns the `properties` object specifically on `klass`. Use for:
     * (1) super chain mixes togther to make `propertiesForClass` which is
     * then used to make `observedAttributes`.
     * (2) properties effects and observers are created from it at `finalize` time.
     *
     * @param {HTMLElement} klass Element class
     * @return {Object} Object containing own properties for this class
     * @private
     */
    function ownPropertiesForClass(klass) {
      if (!klass.hasOwnProperty(JSCompiler_renameProperty('__ownProperties', klass))) {
        klass.__ownProperties = klass.hasOwnProperty(JSCompiler_renameProperty('properties', klass)) ?
        /** @type PolymerElementConstructor */klass.properties : {};
      }
      return klass.__ownProperties;
    }

    /**
     * Returns the `observers` array specifically on `klass`. Use for
     * setting up observers.
     *
     * @param {HTMLElement} klass Element class
     * @return {Array} Array containing own observers for this class
     * @private
     */
    function ownObserversForClass(klass) {
      if (!klass.hasOwnProperty(JSCompiler_renameProperty('__ownObservers', klass))) {
        klass.__ownObservers = klass.hasOwnProperty(JSCompiler_renameProperty('observers', klass)) ?
        /** @type PolymerElementConstructor */klass.observers : [];
      }
      return klass.__ownObservers;
    }

    /**
     * Mixes `props` into `flattenedProps` but upgrades shorthand type
     * syntax to { type: Type}.
     *
     * @param {Object} flattenedProps Bag to collect flattened properties into
     * @param {Object} props Bag of properties to add to `flattenedProps`
     * @return {Object} The input `flattenedProps` bag
     * @private
     */
    function flattenProperties(flattenedProps, props) {
      for (var p in props) {
        var o = props[p];
        if (typeof o == 'function') {
          o = { type: o };
        }
        flattenedProps[p] = o;
      }
      return flattenedProps;
    }

    /**
     * Returns a flattened list of properties mixed together from the chain of all
     * constructor's `config.properties`. This list is used to create
     * (1) observedAttributes,
     * (2) class property default values
     *
     * @param {PolymerElementConstructor} klass Element class
     * @return {PolymerElementProperties} Flattened properties for this class
     * @suppress {missingProperties} class.prototype is not a property for some reason?
     * @private
     */
    function propertiesForClass(klass) {
      if (!klass.hasOwnProperty(JSCompiler_renameProperty('__classProperties', klass))) {
        klass.__classProperties = flattenProperties({}, ownPropertiesForClass(klass));
        var superCtor = Object.getPrototypeOf(klass.prototype).constructor;
        if (superCtor.prototype instanceof PolymerElement) {
          klass.__classProperties = Object.assign(Object.create(propertiesForClass( /** @type PolymerElementConstructor */superCtor)), klass.__classProperties);
        }
      }
      return klass.__classProperties;
    }

    /**
     * Returns a list of properties with default values.
     * This list is created as an optimization since it is a subset of
     * the list returned from `propertiesForClass`.
     * This list is used in `_initializeProperties` to set property defaults.
     *
     * @param {PolymerElementConstructor} klass Element class
     * @return {PolymerElementProperties} Flattened properties for this class
     *   that have default values
     * @private
     */
    function propertyDefaultsForClass(klass) {
      if (!klass.hasOwnProperty(JSCompiler_renameProperty('__classPropertyDefaults', klass))) {
        klass.__classPropertyDefaults = null;
        var props = propertiesForClass(klass);
        for (var p in props) {
          var info = props[p];
          if ('value' in info) {
            klass.__classPropertyDefaults = klass.__classPropertyDefaults || {};
            klass.__classPropertyDefaults[p] = info;
          }
        }
      }
      return klass.__classPropertyDefaults;
    }

    /**
     * Returns true if a `klass` has finalized. Called in `ElementClass.finalize()`
     * @param {PolymerElementConstructor} klass Element class
     * @return {boolean} True if all metaprogramming for this class has been
     *   completed
     * @private
     */
    function hasClassFinalized(klass) {
      return klass.hasOwnProperty(JSCompiler_renameProperty('__finalized', klass));
    }

    /**
     * Called by `ElementClass.finalize()`. Ensures this `klass` and
     * *all superclasses* are finalized by traversing the prototype chain
     * and calling `klass.finalize()`.
     *
     * @param {PolymerElementConstructor} klass Element class
     * @private
     */
    function finalizeClassAndSuper(klass) {
      var proto = /** @type PolymerElementConstructor */klass.prototype;
      var superCtor = Object.getPrototypeOf(proto).constructor;
      if (superCtor.prototype instanceof PolymerElement) {
        superCtor.finalize();
      }
      finalizeClass(klass);
    }

    /**
     * Configures a `klass` based on a staic `klass.config` object and
     * a `template`. This includes creating accessors and effects
     * for properties in `config` and the `template` as well as preparing the
     * `template` for stamping.
     *
     * @param {PolymerElementConstructor} klass Element class
     * @private
     */
    function finalizeClass(klass) {
      klass.__finalized = true;
      var proto = /** @type PolymerElementConstructor */klass.prototype;
      if (klass.hasOwnProperty(JSCompiler_renameProperty('is', klass)) && klass.is) {
        Polymer.telemetry.register(proto);
      }
      var props = ownPropertiesForClass(klass);
      if (props) {
        finalizeProperties(proto, props);
      }
      var observers = ownObserversForClass(klass);
      if (observers) {
        finalizeObservers(proto, observers, props);
      }
      // note: create "working" template that is finalized at instance time
      var template = /** @type PolymerElementConstructor */klass.template;
      if (template) {
        if (typeof template === 'string') {
          var t = document.createElement('template');
          t.innerHTML = template;
          template = t;
        } else {
          template = template.cloneNode(true);
        }
        proto._template = template;
      }
    }

    /**
     * Configures a `proto` based on a `properties` object.
     * Leverages `PropertyEffects` to create property accessors and effects
     * supporting, observers, reflecting to attributes, change notification,
     * computed properties, and read only properties.
     * @param {PolymerElement} proto Element class prototype to add accessors
     *    and effects to
     * @param {Object} properties Flattened bag of property descriptors for
     *    this class
     * @private
     */
    function finalizeProperties(proto, properties) {
      for (var p in properties) {
        createPropertyFromConfig(proto, p, properties[p], properties);
      }
    }

    /**
     * Configures a `proto` based on a `observers` array.
     * Leverages `PropertyEffects` to create observers.
     * @param {PolymerElement} proto Element class prototype to add accessors
     *   and effects to
     * @param {Object} observers Flattened array of observer descriptors for
     *   this class
     * @param {Object} dynamicFns Object containing keys for any properties
     *   that are functions and should trigger the effect when the function
     *   reference is changed
     * @private
     */
    function finalizeObservers(proto, observers, dynamicFns) {
      for (var i = 0; i < observers.length; i++) {
        proto._createMethodObserver(observers[i], dynamicFns);
      }
    }

    /**
     * Creates effects for a property.
     *
     * Note, once a property has been set to
     * `readOnly`, `computed`, `reflectToAttribute`, or `notify`
     * these values may not be changed. For example, a subclass cannot
     * alter these settings. However, additional `observers` may be added
     * by subclasses.
     *
     * The info object should may contain property metadata as follows:
     *
     * * `type`: {function} type to which an attribute matching the property
     * is deserialized. Note the property is camel-cased from a dash-cased
     * attribute. For example, 'foo-bar' attribute is dersialized to a
     * property named 'fooBar'.
     *
     * * `readOnly`: {boolean} creates a readOnly property and
     * makes a private setter for the private of the form '_setFoo' for a
     * property 'foo',
     *
     * * `computed`: {string} creates a computed property. A computed property
     * also automatically is set to `readOnly: true`. The value is calculated
     * by running a method and arguments parsed from the given string. For
     * example 'compute(foo)' will compute a given property when the
     * 'foo' property changes by executing the 'compute' method. This method
     * must return the computed value.
     *
     * * `reflectToAttriute`: {boolean} If true, the property value is reflected
     * to an attribute of the same name. Note, the attribute is dash-cased
     * so a property named 'fooBar' is reflected as 'foo-bar'.
     *
     * * `notify`: {boolean} sends a non-bubbling notification event when
     * the property changes. For example, a property named 'foo' sends an
     * event named 'foo-changed' with `event.detail` set to the value of
     * the property.
     *
     * * observer: {string} name of a method that runs when the property
     * changes. The arguments of the method are (value, previousValue).
     *
     * Note: Users may want control over modifying property
     * effects via subclassing. For example, a user might want to make a
     * reflectToAttribute property not do so in a subclass. We've chosen to
     * disable this because it leads to additional complication.
     * For example, a readOnly effect generates a special setter. If a subclass
     * disables the effect, the setter would fail unexpectedly.
     * Based on feedback, we may want to try to make effects more malleable
     * and/or provide an advanced api for manipulating them.
     * Also consider adding warnings when an effect cannot be changed.
     *
     * @param {PolymerElement} proto Element class prototype to add accessors
     *   and effects to
     * @param {string} name Name of the property.
     * @param {Object} info Info object from which to create property effects.
     * Supported keys:
     * @param {Object} allProps Flattened map of all properties defined in this
     *   element (including inherited properties)
     * @private
     */
    function createPropertyFromConfig(proto, name, info, allProps) {
      // computed forces readOnly...
      if (info.computed) {
        info.readOnly = true;
      }
      // Note, since all computed properties are readOnly, this prevents
      // adding additional computed property effects (which leads to a confusing
      // setup where multiple triggers for setting a property)
      // While we do have `hasComputedEffect` this is set on the property's
      // dependencies rather than itself.
      if (info.computed && !proto._hasReadOnlyEffect(name)) {
        proto._createComputedProperty(name, info.computed, allProps);
      }
      if (info.readOnly && !proto._hasReadOnlyEffect(name)) {
        proto._createReadOnlyProperty(name, !info.computed);
      }
      if (info.reflectToAttribute && !proto._hasReflectEffect(name)) {
        proto._createReflectedProperty(name);
      }
      if (info.notify && !proto._hasNotifyEffect(name)) {
        proto._createNotifyingProperty(name);
      }
      // always add observer
      if (info.observer) {
        proto._createPropertyObserver(name, info.observer, allProps[info.observer]);
      }
    }

    /**
     * Configures an element `proto` to function with a given `template`.
     * The element name `is` and extends `ext` must be specified for ShadyCSS
     * style scoping.
     *
     * @param {PolymerElement} proto Element class prototype to add accessors
     *   and effects to
     * @param {!HTMLTemplateElement} template Template to process and bind
     * @param {string} baseURI URL against which to resolve urls in
     *   style element cssText
     * @param {string} is Tag name (or type extension name) for this element
     * @param {string=} ext For type extensions, the tag name that was extended
     * @private
     */
    function finalizeTemplate(proto, template, baseURI, is, ext) {
      // support `include="module-name"`
      var cssText = Polymer.StyleGather.cssFromTemplate(template, baseURI) + Polymer.StyleGather.cssFromModuleImports(is);
      if (cssText) {
        var style = document.createElement('style');
        style.textContent = cssText;
        template.content.insertBefore(style, template.content.firstChild);
      }
      if (window.ShadyCSS) {
        window.ShadyCSS.prepareTemplate(template, is, ext);
      }
      proto._bindTemplate(template);
    }

    /**
     * @polymer
     * @mixinClass
     * @unrestricted
     * @implements {Polymer_ElementMixin}
     */

    var PolymerElement = function (_polymerElementBase) {
      _inherits(PolymerElement, _polymerElementBase);

      function PolymerElement() {
        _classCallCheck(this, PolymerElement);

        return _possibleConstructorReturn(this, (PolymerElement.__proto__ || Object.getPrototypeOf(PolymerElement)).apply(this, arguments));
      }

      _createClass(PolymerElement, [{
        key: '_initializeProperties',


        /**
         * Overrides the default `Polymer.PropertyAccessors` to ensure class
         * metaprogramming related to property accessors and effects has
         * completed (calls `finalize`).
         *
         * It also initializes any property defaults provided via `value` in
         * `properties` metadata.
         *
         * @override
         * @suppress {invalidCasts}
         */
        value: function _initializeProperties() {
          Polymer.telemetry.instanceCount++;
          this.constructor.finalize();
          var importPath = this.constructor.importPath;
          // note: finalize template when we have access to `localName` to
          // avoid dependence on `is` for polyfilling styling.
          if (this._template && !this._template.__polymerFinalized) {
            this._template.__polymerFinalized = true;
            var baseURI = importPath ? Polymer.ResolveUrl.resolveUrl(importPath) : '';
            finalizeTemplate( /** @type {!PolymerElement} */this.__proto__, this._template, baseURI,
            /**@type {!HTMLElement}*/this.localName);
          }
          _get(PolymerElement.prototype.__proto__ || Object.getPrototypeOf(PolymerElement.prototype), '_initializeProperties', this).call(this);
          // set path defaults
          this.rootPath = Polymer.rootPath;
          this.importPath = importPath;
          // apply property defaults...
          var p$ = propertyDefaultsForClass(this.constructor);
          if (!p$) {
            return;
          }
          for (var p in p$) {
            var info = p$[p];
            // Don't set default value if there is already an own property, which
            // happens when a `properties` property with default but no effects had
            // a property set (e.g. bound) by its host before upgrade
            if (!this.hasOwnProperty(p)) {
              var value = typeof info.value == 'function' ? info.value.call(this) : info.value;
              // Set via `_setProperty` if there is an accessor, to enable
              // initializing readOnly property defaults
              if (this._hasAccessor(p)) {
                this._setPendingProperty(p, value, true);
              } else {
                this[p] = value;
              }
            }
          }
        }

        /**
         * Provides a default implementation of the standard Custom Elements
         * `connectedCallback`.
         *
         * The default implementation enables the property effects system and
         * flushes any pending properties, and updates shimmed CSS properties
         * when using the ShadyCSS scoping/custom properties polyfill.
         *
         * @suppress {invalidCasts}
         */

      }, {
        key: 'connectedCallback',
        value: function connectedCallback() {
          if (window.ShadyCSS && this._template) {
            window.ShadyCSS.styleElement( /** @type {!HTMLElement} */this);
          }
          this._enableProperties();
        }

        /**
         * Provides a default implementation of the standard Custom Elements
         * `disconnectedCallback`.
         */

      }, {
        key: 'disconnectedCallback',
        value: function disconnectedCallback() {}

        /**
         * Stamps the element template.
         *
         * @override
         */

      }, {
        key: 'ready',
        value: function ready() {
          if (this._template) {
            this.root = this._stampTemplate(this._template);
            this.$ = this.root.$;
          }
          _get(PolymerElement.prototype.__proto__ || Object.getPrototypeOf(PolymerElement.prototype), 'ready', this).call(this);
        }

        /**
         * Implements `PropertyEffects`'s `_readyClients` call. Attaches
         * element dom by calling `_attachDom` with the dom stamped from the
         * element's template via `_stampTemplate`. Note that this allows
         * client dom to be attached to the element prior to any observers
         * running.
         *
         * @override
         */

      }, {
        key: '_readyClients',
        value: function _readyClients() {
          if (this._template) {
            this.root = this._attachDom(this.root);
          }
          // The super._readyClients here sets the clients initialized flag.
          // We must wait to do this until after client dom is created/attached
          // so that this flag can be checked to prevent notifications fired
          // during this process from being handled before clients are ready.
          _get(PolymerElement.prototype.__proto__ || Object.getPrototypeOf(PolymerElement.prototype), '_readyClients', this).call(this);
        }

        /**
         * Attaches an element's stamped dom to itself. By default,
         * this method creates a `shadowRoot` and adds the dom to it.
         * However, this method may be overridden to allow an element
         * to put its dom in another location.
         *
         * @throws {Error}
         * @suppress {missingReturn}
         * @param {NodeList} dom to attach to the element.
         * @return {Node} node to which the dom has been attached.
         */

      }, {
        key: '_attachDom',
        value: function _attachDom(dom) {
          if (this.attachShadow) {
            if (dom) {
              if (!this.shadowRoot) {
                this.attachShadow({ mode: 'open' });
              }
              this.shadowRoot.appendChild(dom);
              return this.shadowRoot;
            }
            return null;
          } else {
            throw new Error('ShadowDOM not available. ' +
            // TODO(sorvell): move to compile-time conditional when supported
            'Polymer.Element can create dom as children instead of in ' + 'ShadowDOM by setting `this.root = this;\` before \`ready\`.');
          }
        }

        /**
         * Provides a default implementation of the standard Custom Elements
         * `attributeChangedCallback`.
         *
         * By default, attributes declared in `properties` metadata are
         * deserialized using their `type` information to properties of the
         * same name.  "Dash-cased" attributes are deserialzed to "camelCase"
         * properties.
         *
         * @param {string} name Name of attribute.
         * @param {?string} old Old value of attribute.
         * @param {?string} value Current value of attribute.
         * @override
         */

      }, {
        key: 'attributeChangedCallback',
        value: function attributeChangedCallback(name, old, value) {
          if (old !== value) {
            var property = caseMap.dashToCamelCase(name);
            var type = propertiesForClass(this.constructor)[property].type;
            if (!this._hasReadOnlyEffect(property)) {
              this._attributeToProperty(name, value, type);
            }
          }
        }

        /**
         * When using the ShadyCSS scoping and custom property shim, causes all
         * shimmed styles in this element (and its subtree) to be updated
         * based on current custom property values.
         *
         * The optional parameter overrides inline custom property styles with an
         * object of properties where the keys are CSS properties, and the values
         * are strings.
         *
         * Example: `this.updateStyles({'--color': 'blue'})`
         *
         * These properties are retained unless a value of `null` is set.
         *
         * @param {Object=} properties Bag of custom property key/values to
         *   apply to this element.
         * @suppress {invalidCasts}
         */

      }, {
        key: 'updateStyles',
        value: function updateStyles(properties) {
          if (window.ShadyCSS) {
            window.ShadyCSS.styleSubtree( /** @type {!HTMLElement} */this, properties);
          }
        }

        /**
         * Rewrites a given URL relative to a base URL. The base URL defaults to
         * the original location of the document containing the `dom-module` for
         * this element. This method will return the same URL before and after
         * bundling.
         *
         * @param {string} url URL to resolve.
         * @param {string=} base Optional base URL to resolve against, defaults
         * to the element's `importPath`
         * @return {string} Rewritten URL relative to base
         */

      }, {
        key: 'resolveUrl',
        value: function resolveUrl(url, base) {
          if (!base && this.importPath) {
            base = Polymer.ResolveUrl.resolveUrl(this.importPath);
          }
          return Polymer.ResolveUrl.resolveUrl(url, base);
        }

        /**
         * Overrides `PropertyAccessors` to add map of dynamic functions on
         * template info, for consumption by `PropertyEffects` template binding
         * code. This map determines which method templates should have accessors
         * created for them.
         *
         * @override
         * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
         */

      }], [{
        key: 'finalize',


        /**
         * Called automatically when the first element instance is created to
         * ensure that class finalization work has been completed.
         * May be called by users to eagerly perform class finalization work
         * prior to the creation of the first element instance.
         *
         * Class finalization work generally includes meta-programming such as
         * creating property accessors and any property effect metadata needed for
         * the features used.
         *
         * @public
         */
        value: function finalize() {
          if (!hasClassFinalized(this)) {
            finalizeClassAndSuper(this);
          }
        }

        /**
         * Returns the template that will be stamped into this element's shadow root.
         *
         * If a `static get is()` getter is defined, the default implementation
         * will return the first `<template>` in a `dom-module` whose `id`
         * matches this element's `is`.
         *
         * Users may override this getter to return an arbitrary template
         * (in which case the `is` getter is unnecessary). The template returned
         * may be either an `HTMLTemplateElement` or a string that will be
         * automatically parsed into a template.
         *
         * Note that when subclassing, if the super class overrode the default
         * implementation and the subclass would like to provide an alternate
         * template via a `dom-module`, it should override this getter and
         * return `Polymer.DomModule.import(this.is, 'template')`.
         *
         * If a subclass would like to modify the super class template, it should
         * clone it rather than modify it in place.  If the getter does expensive
         * work such as cloning/modifying a template, it should memoize the
         * template for maximum performance:
         *
         *   let memoizedTemplate;
         *   class MySubClass extends MySuperClass {
         *     static get template() {
         *       if (!memoizedTemplate) {
         *         memoizedTemplate = super.template.cloneNode(true);
         *         let subContent = document.createElement('div');
         *         subContent.textContent = 'This came from MySubClass';
         *         memoizedTemplate.content.appendChild(subContent);
         *       }
         *       return memoizedTemplate;
         *     }
         *   }
         *
         * @return {HTMLTemplateElement|string} Template to be stamped
         */

      }, {
        key: '_parseTemplateContent',
        value: function _parseTemplateContent(template, templateInfo, nodeInfo) {
          templateInfo.dynamicFns = templateInfo.dynamicFns || propertiesForClass(this);
          return _get(PolymerElement.__proto__ || Object.getPrototypeOf(PolymerElement), '_parseTemplateContent', this).call(this, template, templateInfo, nodeInfo);
        }
      }, {
        key: 'observedAttributes',


        /**
         * Standard Custom Elements V1 API.  The default implementation returns
         * a list of dash-cased attributes based on a flattening of all properties
         * declared in `static get properties()` for this element and any
         * superclasses.
         *
         * @return {Array} Observed attribute list
         */
        get: function get() {
          if (!this.hasOwnProperty(JSCompiler_renameProperty('__observedAttributes', this))) {
            var list = [];
            var properties = propertiesForClass(this);
            for (var prop in properties) {
              list.push(Polymer.CaseMap.camelToDashCase(prop));
            }
            this.__observedAttributes = list;
          }
          return this.__observedAttributes;
        }
      }, {
        key: 'template',
        get: function get() {
          if (!this.hasOwnProperty(JSCompiler_renameProperty('_template', this))) {
            this._template = Polymer.DomModule && Polymer.DomModule.import(
            /** @type PolymerElementConstructor*/this.is, 'template') ||
            // note: implemented so a subclass can retrieve the super
            // template; call the super impl this way so that `this` points
            // to the superclass.
            Object.getPrototypeOf( /** @type PolymerElementConstructor*/this.prototype).constructor.template;
          }
          return this._template;
        }

        /**
         * Path matching the url from which the element was imported.
         * This path is used to resolve url's in template style cssText.
         * The `importPath` property is also set on element instances and can be
         * used to create bindings relative to the import path.
         * Defaults to the path matching the url containing a `dom-module` element
         * matching this element's static `is` property.
         * Note, this path should contain a trailing `/`.
         *
         * @return {string} The import path for this element class
         */

      }, {
        key: 'importPath',
        get: function get() {
          if (!this.hasOwnProperty(JSCompiler_renameProperty('_importPath', this))) {
            var module = Polymer.DomModule && Polymer.DomModule.import( /** @type PolymerElementConstructor */this.is);
            this._importPath = module ? module.assetpath : '' || Object.getPrototypeOf( /** @type PolymerElementConstructor*/this.prototype).constructor.importPath;
          }
          return this._importPath;
        }
      }]);

      return PolymerElement;
    }(polymerElementBase);

    return PolymerElement;
  });

  /**
   * Provides basic tracking of element definitions (registrations) and
   * instance counts.
   *
   * @namespace
   * @summary Provides basic tracking of element definitions (registrations) and
   * instance counts.
   */
  Polymer.telemetry = {
    /**
     * Total number of Polymer element instances created.
     * @type {number}
     */
    instanceCount: 0,
    /**
     * Array of Polymer element classes that have been finalized.
     * @type {Array<Polymer.Element>}
     */
    registrations: [],
    /**
     * @param {!PolymerElementConstructor} prototype Element prototype to log
     * @this {this}
     * @private
     */
    _regLog: function _regLog(prototype) {
      console.log('[' + prototype.is + ']: registered');
    },
    /**
     * Registers a class prototype for telemetry purposes.
     * @param {HTMLElement} prototype Element prototype to register
     * @this {this}
     * @protected
     */
    register: function register(prototype) {
      this.registrations.push(prototype);
      Polymer.log && this._regLog(prototype);
    },
    /**
     * Logs all elements registered with an `is` to the console.
     * @public
     * @this {this}
     */
    dumpRegistrations: function dumpRegistrations() {
      this.registrations.forEach(this._regLog);
    }
  };

  /**
   * When using the ShadyCSS scoping and custom property shim, causes all
   * shimmed `styles` (via `custom-style`) in the document (and its subtree)
   * to be updated based on current custom property values.
   *
   * The optional parameter overrides inline custom property styles with an
   * object of properties where the keys are CSS properties, and the values
   * are strings.
   *
   * Example: `Polymer.updateStyles({'--color': 'blue'})`
   *
   * These properties are retained unless a value of `null` is set.
   *
   * @param {Object=} props Bag of custom property key/values to
   *   apply to the document.
   */
  Polymer.updateStyles = function (props) {
    if (window.ShadyCSS) {
      window.ShadyCSS.styleDocument(props);
    }
  };
})();

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(1);

__webpack_require__(7);

/** @suppress {deprecated} */
(function () {
  'use strict';

  /**
   * Legacy settings.
   * @namespace
   * @memberof Polymer
   */

  var settings = Polymer.Settings || {};
  settings.useShadow = !window.ShadyDOM;
  settings.useNativeCSSProperties = Boolean(!window.ShadyCSS || window.ShadyCSS.nativeCss);
  settings.useNativeCustomElements = !window.customElements.polyfillWrapFlushCallback;

  /**
   * Sets the global, legacy settings.
   *
   * @deprecated
   * @memberof Polymer
   */
  Polymer.Settings = settings;

  /**
   * Globally settable property that is automatically assigned to
   * `Polymer.ElementMixin` instances, useful for binding in templates to
   * make URL's relative to an application's root.  Defaults to the main
   * document URL, but can be overridden by users.  It may be useful to set
   * `Polymer.rootPath` to provide a stable application mount path when
   * using client side routing.
   *
   * @memberof Polymer
   */
  var rootPath = Polymer.rootPath || Polymer.ResolveUrl.pathFromUrl(document.baseURI || window.location.href);

  Polymer.rootPath = rootPath;

  /**
   * Sets the global rootPath property used by `Polymer.ElementMixin` and
   * available via `Polymer.rootPath`.
   *
   * @memberof Polymer
   * @param {string} path The new root path
   */
  Polymer.setRootPath = function (path) {
    Polymer.rootPath = path;
  };
})();

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(7);

(function () {
  'use strict';

  var MODULE_STYLE_LINK_SELECTOR = 'link[rel=import][type~=css]';
  var INCLUDE_ATTR = 'include';

  function importModule(moduleId) {
    if (!Polymer.DomModule) {
      return null;
    }
    return Polymer.DomModule.import(moduleId);
  }

  /** @typedef {{assetpath: string}} */
  var templateWithAssetPath = void 0; // eslint-disable-line no-unused-vars

  /**
   * Module with utilities for collection CSS text from `<templates>`, external
   * stylesheets, and `dom-module`s.
   *
   * @namespace
   * @memberof Polymer
   * @summary Module with utilities for collection CSS text from various sources.
   */
  var StyleGather = {

    /**
     * Returns CSS text of styles in a space-separated list of `dom-module`s.
     *
     * @memberof Polymer.StyleGather
     * @param {string} moduleIds List of dom-module id's within which to
     * search for css.
     * @return {string} Concatenated CSS content from specified `dom-module`s
     * @this {StyleGather}
     */
    cssFromModules: function cssFromModules(moduleIds) {
      var modules = moduleIds.trim().split(' ');
      var cssText = '';
      for (var i = 0; i < modules.length; i++) {
        cssText += this.cssFromModule(modules[i]);
      }
      return cssText;
    },


    /**
     * Returns CSS text of styles in a given `dom-module`.  CSS in a `dom-module`
     * can come either from `<style>`s within the first `<template>`, or else
     * from one or more `<link rel="import" type="css">` links outside the
     * template.
     *
     * Any `<styles>` processed are removed from their original location.
     *
     * @memberof Polymer.StyleGather
     * @param {string} moduleId dom-module id to gather styles from
     * @return {string} Concatenated CSS content from specified `dom-module`
     * @this {StyleGather}
     */
    cssFromModule: function cssFromModule(moduleId) {
      var m = importModule(moduleId);
      if (m && m._cssText === undefined) {
        var cssText = '';
        // include css from the first template in the module
        var t = m.querySelector('template');
        if (t) {
          cssText += this.cssFromTemplate(t, /** @type {templateWithAssetPath }*/m.assetpath);
        }
        // module imports: <link rel="import" type="css">
        cssText += this.cssFromModuleImports(moduleId);
        m._cssText = cssText || null;
      }
      if (!m) {
        console.warn('Could not find style data in module named', moduleId);
      }
      return m && m._cssText || '';
    },


    /**
     * Returns CSS text of `<styles>` within a given template.
     *
     * Any `<styles>` processed are removed from their original location.
     *
     * @memberof Polymer.StyleGather
     * @param {HTMLTemplateElement} template Template to gather styles from
     * @param {string} baseURI Base URI to resolve the URL against
     * @return {string} Concatenated CSS content from specified template
     * @this {StyleGather}
     */
    cssFromTemplate: function cssFromTemplate(template, baseURI) {
      var cssText = '';
      // if element is a template, get content from its .content
      var e$ = template.content.querySelectorAll('style');
      for (var i = 0; i < e$.length; i++) {
        var e = e$[i];
        // support style sharing by allowing styles to "include"
        // other dom-modules that contain styling
        var include = e.getAttribute(INCLUDE_ATTR);
        if (include) {
          cssText += this.cssFromModules(include);
        }
        e.parentNode.removeChild(e);
        cssText += baseURI ? Polymer.ResolveUrl.resolveCss(e.textContent, baseURI) : e.textContent;
      }
      return cssText;
    },


    /**
     * Returns CSS text from stylsheets loaded via `<link rel="import" type="css">`
     * links within the specified `dom-module`.
     *
     * @memberof Polymer.StyleGather
     * @param {string} moduleId Id of `dom-module` to gather CSS from
     * @return {string} Concatenated CSS content from links in specified `dom-module`
     * @this {StyleGather}
     */
    cssFromModuleImports: function cssFromModuleImports(moduleId) {
      var cssText = '';
      var m = importModule(moduleId);
      if (!m) {
        return cssText;
      }
      var p$ = m.querySelectorAll(MODULE_STYLE_LINK_SELECTOR);
      for (var i = 0; i < p$.length; i++) {
        var p = p$[i];
        if (p.import) {
          var importDoc = p.import;
          // NOTE: polyfill affordance.
          // under the HTMLImports polyfill, there will be no 'body',
          // but the import pseudo-doc can be used directly.
          var container = importDoc.body ? importDoc.body : importDoc;
          cssText += Polymer.ResolveUrl.resolveCss(container.textContent, importDoc.baseURI);
        }
      }
      return cssText;
    }
  };

  Polymer.StyleGather = StyleGather;
})();

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

__webpack_require__(46);

__webpack_require__(19);

__webpack_require__(23);

__webpack_require__(3);

__webpack_require__(49);

__webpack_require__(50);

__webpack_require__(51);

__webpack_require__(52);

(function () {

  'use strict';

  var styleInterface = window.ShadyCSS;

  /**
   * Element class mixin that provides Polymer's "legacy" API intended to be
   * backward-compatible to the greatest extent possible with the API
   * found on the Polymer 1.x `Polymer.Base` prototype applied to all elements
   * defined using the `Polymer({...})` function.
   *
   * @mixinFunction
   * @polymer
   * @appliesMixin Polymer.ElementMixin
   * @appliesMixin Polymer.GestureEventListeners
   * @property isAttached {boolean} Set to `true` in this element's
   *   `connectedCallback` and `false` in `disconnectedCallback`
   * @memberof Polymer
   * @summary Element class mixin that provides Polymer's "legacy" API
   */
  Polymer.LegacyElementMixin = Polymer.dedupingMixin(function (base) {

    /**
     * @constructor
     * @extends {base}
     * @implements {Polymer_ElementMixin}
     * @implements {Polymer_GestureEventListeners}
     */
    var legacyElementBase = Polymer.GestureEventListeners(Polymer.ElementMixin(base));

    /**
     * Map of simple names to touch action names
     * @dict
     */
    var DIRECTION_MAP = {
      'x': 'pan-x',
      'y': 'pan-y',
      'none': 'none',
      'all': 'auto'
    };

    /**
     * @polymer
     * @mixinClass
     * @extends {legacyElementBase}
     * @implements {Polymer_LegacyElementMixin}
     * @unrestricted
     */

    var LegacyElement = function (_legacyElementBase) {
      _inherits(LegacyElement, _legacyElementBase);

      function LegacyElement() {
        _classCallCheck(this, LegacyElement);

        var _this = _possibleConstructorReturn(this, (LegacyElement.__proto__ || Object.getPrototypeOf(LegacyElement)).call(this));

        _this.root = _this;
        _this.created();
        return _this;
      }

      /**
       * Legacy callback called during the `constructor`, for overriding
       * by the user.
       */


      _createClass(LegacyElement, [{
        key: 'created',
        value: function created() {}

        /**
         * Provides an implementation of `connectedCallback`
         * which adds Polymer legacy API's `attached` method.
         * @override
         */

      }, {
        key: 'connectedCallback',
        value: function connectedCallback() {
          _get(LegacyElement.prototype.__proto__ || Object.getPrototypeOf(LegacyElement.prototype), 'connectedCallback', this).call(this);
          this.isAttached = true;
          this.attached();
        }

        /**
         * Legacy callback called during `connectedCallback`, for overriding
         * by the user.
         */

      }, {
        key: 'attached',
        value: function attached() {}

        /**
         * Provides an implementation of `disconnectedCallback`
         * which adds Polymer legacy API's `detached` method.
         * @override
         */

      }, {
        key: 'disconnectedCallback',
        value: function disconnectedCallback() {
          _get(LegacyElement.prototype.__proto__ || Object.getPrototypeOf(LegacyElement.prototype), 'disconnectedCallback', this).call(this);
          this.isAttached = false;
          this.detached();
        }

        /**
         * Legacy callback called during `disconnectedCallback`, for overriding
         * by the user.
         */

      }, {
        key: 'detached',
        value: function detached() {}

        /**
         * Provides an override implementation of `attributeChangedCallback`
         * which adds the Polymer legacy API's `attributeChanged` method.
         * @param {string} name Name of attribute.
         * @param {?string} old Old value of attribute.
         * @param {?string} value Current value of attribute.
         * @override
         */

      }, {
        key: 'attributeChangedCallback',
        value: function attributeChangedCallback(name, old, value) {
          if (old !== value) {
            _get(LegacyElement.prototype.__proto__ || Object.getPrototypeOf(LegacyElement.prototype), 'attributeChangedCallback', this).call(this, name, old, value);
            this.attributeChanged(name, old, value);
          }
        }

        /**
         * Legacy callback called during `attributeChangedChallback`, for overriding
         * by the user.
         * @param {string} name Name of attribute.
         * @param {?string} old Old value of attribute.
         * @param {?string} value Current value of attribute.
         */

      }, {
        key: 'attributeChanged',
        value: function attributeChanged(name, old, value) {} // eslint-disable-line no-unused-vars

        /**
         * Overrides the default `Polymer.PropertyEffects` implementation to
         * add support for class initialization via the `_registered` callback.
         * This is called only when the first instance of the element is created.
         *
         * @override
         */

      }, {
        key: '_initializeProperties',
        value: function _initializeProperties() {
          var proto = Object.getPrototypeOf(this);
          if (!proto.hasOwnProperty('__hasRegisterFinished')) {
            proto.__hasRegisterFinished = true;
            this._registered();
          }
          _get(LegacyElement.prototype.__proto__ || Object.getPrototypeOf(LegacyElement.prototype), '_initializeProperties', this).call(this);
        }

        /**
         * Called automatically when an element is initializing.
         * Users may override this method to perform class registration time
         * work. The implementation should ensure the work is performed
         * only once for the class.
         * @protected
         */

      }, {
        key: '_registered',
        value: function _registered() {}

        /**
         * Overrides the default `Polymer.PropertyEffects` implementation to
         * add support for installing `hostAttributes` and `listeners`.
         *
         * @override
         */

      }, {
        key: 'ready',
        value: function ready() {
          this._ensureAttributes();
          this._applyListeners();
          _get(LegacyElement.prototype.__proto__ || Object.getPrototypeOf(LegacyElement.prototype), 'ready', this).call(this);
        }

        /**
         * Ensures an element has required attributes. Called when the element
         * is being readied via `ready`. Users should override to set the
         * element's required attributes. The implementation should be sure
         * to check and not override existing attributes added by
         * the user of the element. Typically, setting attributes should be left
         * to the element user and not done here; reasonable exceptions include
         * setting aria roles and focusability.
         * @protected
         */

      }, {
        key: '_ensureAttributes',
        value: function _ensureAttributes() {}

        /**
         * Adds element event listeners. Called when the element
         * is being readied via `ready`. Users should override to
         * add any required element event listeners.
         * In performance critical elements, the work done here should be kept
         * to a minimum since it is done before the element is rendered. In
         * these elements, consider adding listeners asychronously so as not to
         * block render.
         * @protected
         */

      }, {
        key: '_applyListeners',
        value: function _applyListeners() {}

        /**
         * Converts a typed JavaScript value to a string.
         *
         * Note this method is provided as backward-compatible legacy API
         * only.  It is not directly called by any Polymer features. To customize
         * how properties are serialized to attributes for attribute bindings and
         * `reflectToAttribute: true` properties as well as this method, override
         * the `_serializeValue` method provided by `Polymer.PropertyAccessors`.
         *
         * @param {*} value Value to deserialize
         * @return {string | undefined} Serialized value
         */

      }, {
        key: 'serialize',
        value: function serialize(value) {
          return this._serializeValue(value);
        }

        /**
         * Converts a string to a typed JavaScript value.
         *
         * Note this method is provided as backward-compatible legacy API
         * only.  It is not directly called by any Polymer features.  To customize
         * how attributes are deserialized to properties for in
         * `attributeChangedCallback`, override `_deserializeValue` method
         * provided by `Polymer.PropertyAccessors`.
         *
         * @param {string} value String to deserialize
         * @param {*} type Type to deserialize the string to
         * @return {*} Returns the deserialized value in the `type` given.
         */

      }, {
        key: 'deserialize',
        value: function deserialize(value, type) {
          return this._deserializeValue(value, type);
        }

        /**
         * Serializes a property to its associated attribute.
         *
         * Note this method is provided as backward-compatible legacy API
         * only.  It is not directly called by any Polymer features.
         *
         * @param {string} property Property name to reflect.
         * @param {string=} attribute Attribute name to reflect.
         * @param {*=} value Property value to refect.
         */

      }, {
        key: 'reflectPropertyToAttribute',
        value: function reflectPropertyToAttribute(property, attribute, value) {
          this._propertyToAttribute(property, attribute, value);
        }

        /**
         * Sets a typed value to an HTML attribute on a node.
         *
         * Note this method is provided as backward-compatible legacy API
         * only.  It is not directly called by any Polymer features.
         *
         * @param {*} value Value to serialize.
         * @param {string} attribute Attribute name to serialize to.
         * @param {Element} node Element to set attribute to.
         */

      }, {
        key: 'serializeValueToAttribute',
        value: function serializeValueToAttribute(value, attribute, node) {
          this._valueToNodeAttribute( /** @type {Element} */node || this, value, attribute);
        }

        /**
         * Copies own properties (including accessor descriptors) from a source
         * object to a target object.
         *
         * @param {Object} prototype Target object to copy properties to.
         * @param {Object} api Source object to copy properties from.
         * @return {Object} prototype object that was passed as first argument.
         */

      }, {
        key: 'extend',
        value: function extend(prototype, api) {
          if (!(prototype && api)) {
            return prototype || api;
          }
          var n$ = Object.getOwnPropertyNames(api);
          for (var i = 0, n; i < n$.length && (n = n$[i]); i++) {
            var pd = Object.getOwnPropertyDescriptor(api, n);
            if (pd) {
              Object.defineProperty(prototype, n, pd);
            }
          }
          return prototype;
        }

        /**
         * Copies props from a source object to a target object.
         *
         * Note, this method uses a simple `for...in` strategy for enumerating
         * properties.  To ensure only `ownProperties` are copied from source
         * to target and that accessor implementations are copied, use `extend`.
         *
         * @param {Object} target Target object to copy properties to.
         * @param {Object} source Source object to copy properties from.
         * @return {Object} Target object that was passed as first argument.
         */

      }, {
        key: 'mixin',
        value: function mixin(target, source) {
          for (var i in source) {
            target[i] = source[i];
          }
          return target;
        }

        /**
         * Sets the prototype of an object.
         *
         * Note this method is provided as backward-compatible legacy API
         * only.  It is not directly called by any Polymer features.
         * @param {Object} object The object on which to set the prototype.
         * @param {Object} prototype The prototype that will be set on the given
         * `object`.
         * @return {Object} Returns the given `object` with its prototype set
         * to the given `prototype` object.
         */

      }, {
        key: 'chainObject',
        value: function chainObject(object, prototype) {
          if (object && prototype && object !== prototype) {
            object.__proto__ = prototype;
          }
          return object;
        }

        /* **** Begin Template **** */

        /**
         * Calls `importNode` on the `content` of the `template` specified and
         * returns a document fragment containing the imported content.
         *
         * @param {HTMLTemplateElement} template HTML template element to instance.
         * @return {DocumentFragment} Document fragment containing the imported
         *   template content.
        */

      }, {
        key: 'instanceTemplate',
        value: function instanceTemplate(template) {
          var content = this.constructor._contentForTemplate(template);
          var dom = /** @type {DocumentFragment} */
          document.importNode(content, true);
          return dom;
        }

        /* **** Begin Events **** */

        /**
         * Dispatches a custom event with an optional detail value.
         *
         * @param {string} type Name of event type.
         * @param {*=} detail Detail value containing event-specific
         *   payload.
         * @param {{ bubbles: (boolean|undefined), cancelable: (boolean|undefined), composed: (boolean|undefined) }=}
         *  options Object specifying options.  These may include:
         *  `bubbles` (boolean, defaults to `true`),
         *  `cancelable` (boolean, defaults to false), and
         *  `node` on which to fire the event (HTMLElement, defaults to `this`).
         * @return {Event} The new event that was fired.
         */

      }, {
        key: 'fire',
        value: function fire(type, detail, options) {
          options = options || {};
          detail = detail === null || detail === undefined ? {} : detail;
          var event = new Event(type, {
            bubbles: options.bubbles === undefined ? true : options.bubbles,
            cancelable: Boolean(options.cancelable),
            composed: options.composed === undefined ? true : options.composed
          });
          event.detail = detail;
          var node = options.node || this;
          node.dispatchEvent(event);
          return event;
        }

        /**
         * Convenience method to add an event listener on a given element,
         * late bound to a named method on this element.
         *
         * @param {Element} node Element to add event listener to.
         * @param {string} eventName Name of event to listen for.
         * @param {string} methodName Name of handler method on `this` to call.
         */

      }, {
        key: 'listen',
        value: function listen(node, eventName, methodName) {
          node = /** @type {Element} */node || this;
          var hbl = this.__boundListeners || (this.__boundListeners = new WeakMap());
          var bl = hbl.get(node);
          if (!bl) {
            bl = {};
            hbl.set(node, bl);
          }
          var key = eventName + methodName;
          if (!bl[key]) {
            bl[key] = this._addMethodEventListenerToNode(node, eventName, methodName, this);
          }
        }

        /**
         * Convenience method to remove an event listener from a given element,
         * late bound to a named method on this element.
         *
         * @param {Element} node Element to remove event listener from.
         * @param {string} eventName Name of event to stop listening to.
         * @param {string} methodName Name of handler method on `this` to not call
         anymore.
         */

      }, {
        key: 'unlisten',
        value: function unlisten(node, eventName, methodName) {
          node = /** @type {Element} */node || this;
          var bl = this.__boundListeners && this.__boundListeners.get(node);
          var key = eventName + methodName;
          var handler = bl && bl[key];
          if (handler) {
            this._removeEventListenerFromNode(node, eventName, handler);
            bl[key] = null;
          }
        }

        /**
         * Override scrolling behavior to all direction, one direction, or none.
         *
         * Valid scroll directions:
         *   - 'all': scroll in any direction
         *   - 'x': scroll only in the 'x' direction
         *   - 'y': scroll only in the 'y' direction
         *   - 'none': disable scrolling for this node
         *
         * @param {string=} direction Direction to allow scrolling
         * Defaults to `all`.
         * @param {Element=} node Element to apply scroll direction setting.
         * Defaults to `this`.
         */

      }, {
        key: 'setScrollDirection',
        value: function setScrollDirection(direction, node) {
          Polymer.Gestures.setTouchAction( /** @type {Element} */node || this, DIRECTION_MAP[direction] || 'auto');
        }
        /* **** End Events **** */

        /**
         * Convenience method to run `querySelector` on this local DOM scope.
         *
         * This function calls `Polymer.dom(this.root).querySelector(slctr)`.
         *
         * @param {string} slctr Selector to run on this local DOM scope
         * @return {Element} Element found by the selector, or null if not found.
         */

      }, {
        key: '$$',
        value: function $$(slctr) {
          return this.root.querySelector(slctr);
        }

        /**
         * Return the element whose local dom within which this element
         * is contained. This is a shorthand for
         * `this.getRootNode().host`.
         * @this {Element}
         */

      }, {
        key: 'distributeContent',


        /**
         * Force this element to distribute its children to its local dom.
         * This should not be necessary as of Polymer 2.0.2 and is provided only
         * for backwards compatibility.
         */
        value: function distributeContent() {
          if (window.ShadyDOM && this.shadowRoot) {
            ShadyDOM.flush();
          }
        }

        /**
         * Returns a list of nodes that are the effective childNodes. The effective
         * childNodes list is the same as the element's childNodes except that
         * any `<content>` elements are replaced with the list of nodes distributed
         * to the `<content>`, the result of its `getDistributedNodes` method.
         * @this {Element}
         * @return {Array<Node>} List of effctive child nodes.
         */

      }, {
        key: 'getEffectiveChildNodes',
        value: function getEffectiveChildNodes() {
          return (/** @type {Polymer.DomApi} */Polymer.dom(this).getEffectiveChildNodes()
          );
        }

        /**
         * Returns a list of nodes distributed within this element that match
         * `selector`. These can be dom children or elements distributed to
         * children that are insertion points.
         * @param {string} selector Selector to run.
         * @this {Element}
         * @return {Array<Node>} List of distributed elements that match selector.
         */

      }, {
        key: 'queryDistributedElements',
        value: function queryDistributedElements(selector) {
          return (/** @type {Polymer.DomApi} */Polymer.dom(this).queryDistributedElements(selector)
          );
        }

        /**
         * Returns a list of elements that are the effective children. The effective
         * children list is the same as the element's children except that
         * any `<content>` elements are replaced with the list of elements
         * distributed to the `<content>`.
         *
         * @return {Array<Node>} List of effctive children.
         */

      }, {
        key: 'getEffectiveChildren',
        value: function getEffectiveChildren() {
          var list = this.getEffectiveChildNodes();
          return list.filter(function ( /** @type {Node} */n) {
            return n.nodeType === Node.ELEMENT_NODE;
          });
        }

        /**
         * Returns a string of text content that is the concatenation of the
         * text content's of the element's effective childNodes (the elements
         * returned by <a href="#getEffectiveChildNodes>getEffectiveChildNodes</a>.
         *
         * @return {string} List of effctive children.
         */

      }, {
        key: 'getEffectiveTextContent',
        value: function getEffectiveTextContent() {
          var cn = this.getEffectiveChildNodes();
          var tc = [];
          for (var i = 0, c; c = cn[i]; i++) {
            if (c.nodeType !== Node.COMMENT_NODE) {
              tc.push(c.textContent);
            }
          }
          return tc.join('');
        }

        /**
         * Returns the first effective childNode within this element that
         * match `selector`. These can be dom child nodes or elements distributed
         * to children that are insertion points.
         * @param {string} selector Selector to run.
         * @return {Object<Node>} First effective child node that matches selector.
         */

      }, {
        key: 'queryEffectiveChildren',
        value: function queryEffectiveChildren(selector) {
          var e$ = this.queryDistributedElements(selector);
          return e$ && e$[0];
        }

        /**
         * Returns a list of effective childNodes within this element that
         * match `selector`. These can be dom child nodes or elements distributed
         * to children that are insertion points.
         * @param {string} selector Selector to run.
         * @return {Array<Node>} List of effective child nodes that match selector.
         */

      }, {
        key: 'queryAllEffectiveChildren',
        value: function queryAllEffectiveChildren(selector) {
          return this.queryDistributedElements(selector);
        }

        /**
         * Returns a list of nodes distributed to this element's `<slot>`.
         *
         * If this element contains more than one `<slot>` in its local DOM,
         * an optional selector may be passed to choose the desired content.
         *
         * @param {string=} slctr CSS selector to choose the desired
         *   `<slot>`.  Defaults to `content`.
         * @return {Array<Node>} List of distributed nodes for the `<slot>`.
         */

      }, {
        key: 'getContentChildNodes',
        value: function getContentChildNodes(slctr) {
          var content = this.root.querySelector(slctr || 'slot');
          return content ? /** @type {Polymer.DomApi} */Polymer.dom(content).getDistributedNodes() : [];
        }

        /**
         * Returns a list of element children distributed to this element's
         * `<slot>`.
         *
         * If this element contains more than one `<slot>` in its
         * local DOM, an optional selector may be passed to choose the desired
         * content.  This method differs from `getContentChildNodes` in that only
         * elements are returned.
         *
         * @param {string=} slctr CSS selector to choose the desired
         *   `<content>`.  Defaults to `content`.
         * @return {Array<HTMLElement>} List of distributed nodes for the
         *   `<slot>`.
         * @suppress {invalidCasts}
         */

      }, {
        key: 'getContentChildren',
        value: function getContentChildren(slctr) {
          return (/** @type {Array<HTMLElement>} */this.getContentChildNodes(slctr).filter(function (n) {
              return n.nodeType === Node.ELEMENT_NODE;
            })
          );
        }

        /**
         * Checks whether an element is in this element's light DOM tree.
         *
         * @param {?Node} node The element to be checked.
         * @this {Element}
         * @return {boolean} true if node is in this element's light DOM tree.
         */

      }, {
        key: 'isLightDescendant',
        value: function isLightDescendant(node) {
          return this !== node && this.contains(node) && this.getRootNode() === node.getRootNode();
        }

        /**
         * Checks whether an element is in this element's local DOM tree.
         *
         * @param {Element=} node The element to be checked.
         * @return {boolean} true if node is in this element's local DOM tree.
         */

      }, {
        key: 'isLocalDescendant',
        value: function isLocalDescendant(node) {
          return this.root === node.getRootNode();
        }

        // NOTE: should now be handled by ShadyCss library.

      }, {
        key: 'scopeSubtree',
        value: function scopeSubtree(container, shouldObserve) {} // eslint-disable-line no-unused-vars


        /**
         * Returns the computed style value for the given property.
         * @param {string} property The css property name.
         * @return {string} Returns the computed css property value for the given
         * `property`.
         */

      }, {
        key: 'getComputedStyleValue',
        value: function getComputedStyleValue(property) {
          return styleInterface.getComputedStyleValue(this, property);
        }

        // debounce

        /**
         * Call `debounce` to collapse multiple requests for a named task into
         * one invocation which is made after the wait time has elapsed with
         * no new request.  If no wait time is given, the callback will be called
         * at microtask timing (guaranteed before paint).
         *
         *     debouncedClickAction(e) {
         *       // will not call `processClick` more than once per 100ms
         *       this.debounce('click', function() {
         *        this.processClick();
         *       } 100);
         *     }
         *
         * @param {string} jobName String to indentify the debounce job.
         * @param {function()} callback Function that is called (with `this`
         *   context) when the wait time elapses.
         * @param {number} wait Optional wait time in milliseconds (ms) after the
         *   last signal that must elapse before invoking `callback`
         * @return {Object} Returns a debouncer object on which exists the
         * following methods: `isActive()` returns true if the debouncer is
         * active; `cancel()` cancels the debouncer if it is active;
         * `flush()` immediately invokes the debounced callback if the debouncer
         * is active.
         */

      }, {
        key: 'debounce',
        value: function debounce(jobName, callback, wait) {
          this._debouncers = this._debouncers || {};
          return this._debouncers[jobName] = Polymer.Debouncer.debounce(this._debouncers[jobName], wait > 0 ? Polymer.Async.timeOut.after(wait) : Polymer.Async.microTask, callback.bind(this));
        }

        /**
         * Returns whether a named debouncer is active.
         *
         * @param {string} jobName The name of the debouncer started with `debounce`
         * @return {boolean} Whether the debouncer is active (has not yet fired).
         */

      }, {
        key: 'isDebouncerActive',
        value: function isDebouncerActive(jobName) {
          this._debouncers = this._debouncers || {};
          var debouncer = this._debouncers[jobName];
          return !!(debouncer && debouncer.isActive());
        }

        /**
         * Immediately calls the debouncer `callback` and inactivates it.
         *
         * @param {string} jobName The name of the debouncer started with `debounce`
         */

      }, {
        key: 'flushDebouncer',
        value: function flushDebouncer(jobName) {
          this._debouncers = this._debouncers || {};
          var debouncer = this._debouncers[jobName];
          if (debouncer) {
            debouncer.flush();
          }
        }

        /**
         * Cancels an active debouncer.  The `callback` will not be called.
         *
         * @param {string} jobName The name of the debouncer started with `debounce`
         */

      }, {
        key: 'cancelDebouncer',
        value: function cancelDebouncer(jobName) {
          this._debouncers = this._debouncers || {};
          var debouncer = this._debouncers[jobName];
          if (debouncer) {
            debouncer.cancel();
          }
        }

        /**
         * Runs a callback function asyncronously.
         *
         * By default (if no waitTime is specified), async callbacks are run at
         * microtask timing, which will occur before paint.
         *
         * @param {Function} callback The callback function to run, bound to `this`.
         * @param {number=} waitTime Time to wait before calling the
         *   `callback`.  If unspecified or 0, the callback will be run at microtask
         *   timing (before paint).
         * @return {number} Handle that may be used to cancel the async job.
         */

      }, {
        key: 'async',
        value: function async(callback, waitTime) {
          return waitTime > 0 ? Polymer.Async.timeOut.run(callback.bind(this), waitTime) : ~Polymer.Async.microTask.run(callback.bind(this));
        }

        /**
         * Cancels an async operation started with `async`.
         *
         * @param {number} handle Handle returned from original `async` call to
         *   cancel.
         */

      }, {
        key: 'cancelAsync',
        value: function cancelAsync(handle) {
          handle < 0 ? Polymer.Async.microTask.cancel(~handle) : Polymer.Async.timeOut.cancel(handle);
        }

        // other

        /**
         * Convenience method for creating an element and configuring it.
         *
         * @param {string} tag HTML element tag to create.
         * @param {Object} props Object of properties to configure on the
         *    instance.
         * @return {Element} Newly created and configured element.
         */

      }, {
        key: 'create',
        value: function create(tag, props) {
          var elt = document.createElement(tag);
          if (props) {
            if (elt.setProperties) {
              elt.setProperties(props);
            } else {
              for (var n in props) {
                elt[n] = props[n];
              }
            }
          }
          return elt;
        }

        /**
         * Convenience method for importing an HTML document imperatively.
         *
         * This method creates a new `<link rel="import">` element with
         * the provided URL and appends it to the document to start loading.
         * In the `onload` callback, the `import` property of the `link`
         * element will contain the imported document contents.
         *
         * @param {string} href URL to document to load.
         * @param {Function} onload Callback to notify when an import successfully
         *   loaded.
         * @param {Function} onerror Callback to notify when an import
         *   unsuccessfully loaded.
         * @param {boolean} optAsync True if the import should be loaded `async`.
         *   Defaults to `false`.
         * @return {HTMLLinkElement} The link element for the URL to be loaded.
         */

      }, {
        key: 'importHref',
        value: function importHref(href, onload, onerror, optAsync) {
          // eslint-disable-line no-unused-vars
          var loadFn = onload ? onload.bind(this) : null;
          var errorFn = onerror ? onerror.bind(this) : null;
          return Polymer.importHref(href, loadFn, errorFn, optAsync);
        }

        /**
         * Polyfill for Element.prototype.matches, which is sometimes still
         * prefixed.
         *
         * @param {string} selector Selector to test.
         * @param {Element=} node Element to test the selector against.
         * @return {boolean} Whether the element matches the selector.
         */

      }, {
        key: 'elementMatches',
        value: function elementMatches(selector, node) {
          return Polymer.dom.matchesSelector( /** @type {!Element} */node || this, selector);
        }

        /**
         * Toggles an HTML attribute on or off.
         *
         * @param {string} name HTML attribute name
         * @param {boolean=} bool Boolean to force the attribute on or off.
         *    When unspecified, the state of the attribute will be reversed.
         * @param {Element=} node Node to target.  Defaults to `this`.
         */

      }, {
        key: 'toggleAttribute',
        value: function toggleAttribute(name, bool, node) {
          node = /** @type {Element} */node || this;
          if (arguments.length == 1) {
            bool = !node.hasAttribute(name);
          }
          if (bool) {
            node.setAttribute(name, '');
          } else {
            node.removeAttribute(name);
          }
        }

        /**
         * Toggles a CSS class on or off.
         *
         * @param {string} name CSS class name
         * @param {boolean=} bool Boolean to force the class on or off.
         *    When unspecified, the state of the class will be reversed.
         * @param {Element=} node Node to target.  Defaults to `this`.
         */

      }, {
        key: 'toggleClass',
        value: function toggleClass(name, bool, node) {
          node = /** @type {Element} */node || this;
          if (arguments.length == 1) {
            bool = !node.classList.contains(name);
          }
          if (bool) {
            node.classList.add(name);
          } else {
            node.classList.remove(name);
          }
        }

        /**
         * Cross-platform helper for setting an element's CSS `transform` property.
         *
         * @param {string} transformText Transform setting.
         * @param {Element=} node Element to apply the transform to.
         * Defaults to `this`
         */

      }, {
        key: 'transform',
        value: function transform(transformText, node) {
          node = /** @type {Element} */node || this;
          node.style.webkitTransform = transformText;
          node.style.transform = transformText;
        }

        /**
         * Cross-platform helper for setting an element's CSS `translate3d`
         * property.
         *
         * @param {number} x X offset.
         * @param {number} y Y offset.
         * @param {number} z Z offset.
         * @param {Element=} node Element to apply the transform to.
         * Defaults to `this`.
         */

      }, {
        key: 'translate3d',
        value: function translate3d(x, y, z, node) {
          node = /** @type {Element} */node || this;
          this.transform('translate3d(' + x + ',' + y + ',' + z + ')', node);
        }

        /**
         * Removes an item from an array, if it exists.
         *
         * If the array is specified by path, a change notification is
         * generated, so that observers, data bindings and computed
         * properties watching that path can update.
         *
         * If the array is passed directly, **no change
         * notification is generated**.
         *
         * @param {string | !Array<number|string>} arrayOrPath Path to array from which to remove the item
         *   (or the array itself).
         * @param {*} item Item to remove.
         * @return {Array} Array containing item removed.
         */

      }, {
        key: 'arrayDelete',
        value: function arrayDelete(arrayOrPath, item) {
          var index = void 0;
          if (Array.isArray(arrayOrPath)) {
            index = arrayOrPath.indexOf(item);
            if (index >= 0) {
              return arrayOrPath.splice(index, 1);
            }
          } else {
            var arr = Polymer.Path.get(this, arrayOrPath);
            index = arr.indexOf(item);
            if (index >= 0) {
              return this.splice(arrayOrPath, index, 1);
            }
          }
          return null;
        }

        // logging

        /**
         * Facades `console.log`/`warn`/`error` as override point.
         *
         * @param {string} level One of 'log', 'warn', 'error'
         * @param {Array} args Array of strings or objects to log
         */

      }, {
        key: '_logger',
        value: function _logger(level, args) {
          var _console;

          // accept ['foo', 'bar'] and [['foo', 'bar']]
          if (Array.isArray(args) && args.length === 1) {
            args = args[0];
          }
          switch (level) {
            case 'log':
            case 'warn':
            case 'error':
              (_console = console)[level].apply(_console, _toConsumableArray(args));
          }
        }

        /**
         * Facades `console.log` as an override point.
         *
         * @param {...*} args Array of strings or objects to log
         */

      }, {
        key: '_log',
        value: function _log() {
          for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          this._logger('log', args);
        }

        /**
         * Facades `console.warn` as an override point.
         *
         * @param {...*} args Array of strings or objects to log
         */

      }, {
        key: '_warn',
        value: function _warn() {
          for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }

          this._logger('warn', args);
        }

        /**
         * Facades `console.error` as an override point.
         *
         * @param {...*} args Array of strings or objects to log
         */

      }, {
        key: '_error',
        value: function _error() {
          for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
            args[_key3] = arguments[_key3];
          }

          this._logger('error', args);
        }

        /**
         * Formats a message using the element type an a method name.
         *
         * @param {string} methodName Method name to associate with message
         * @param {...*} args Array of strings or objects to log
         * @return {Array} Array with formatting information for `console`
         *   logging.
         */

      }, {
        key: '_logf',
        value: function _logf(methodName) {
          for (var _len4 = arguments.length, args = Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
            args[_key4 - 1] = arguments[_key4];
          }

          return ['[%s::%s]', this.is, methodName].concat(args);
        }
      }, {
        key: 'domHost',
        get: function get() {
          var root = this.getRootNode();
          return root instanceof DocumentFragment ? /** @type {ShadowRoot} */root.host : root;
        }
      }]);

      return LegacyElement;
    }(legacyElementBase);

    LegacyElement.prototype.is = '';

    return LegacyElement;
  });
})();

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

__webpack_require__(1);

__webpack_require__(3);

__webpack_require__(48);

(function () {

  'use strict';

  /**
   * @const {Polymer.Gestures}
   */

  var gestures = Polymer.Gestures;

  /**
   * Element class mixin that provides API for adding Polymer's cross-platform
   * gesture events to nodes.
   *
   * The API is designed to be compatible with override points implemented
   * in `Polymer.TemplateStamp` such that declarative event listeners in
   * templates will support gesture events when this mixin is applied along with
   * `Polymer.TemplateStamp`.
   *
   * @mixinFunction
   * @polymer
   * @memberof Polymer
   * @summary Element class mixin that provides API for adding Polymer's cross-platform
   * gesture events to nodes
   */
  Polymer.GestureEventListeners = Polymer.dedupingMixin(function (superClass) {

    /**
     * @polymer
     * @mixinClass
     * @implements {Polymer_GestureEventListeners}
     */
    var GestureEventListeners = function (_superClass) {
      _inherits(GestureEventListeners, _superClass);

      function GestureEventListeners() {
        _classCallCheck(this, GestureEventListeners);

        return _possibleConstructorReturn(this, (GestureEventListeners.__proto__ || Object.getPrototypeOf(GestureEventListeners)).apply(this, arguments));
      }

      _createClass(GestureEventListeners, [{
        key: '_addEventListenerToNode',
        value: function _addEventListenerToNode(node, eventName, handler) {
          if (!gestures.addListener(node, eventName, handler)) {
            _get(GestureEventListeners.prototype.__proto__ || Object.getPrototypeOf(GestureEventListeners.prototype), '_addEventListenerToNode', this).call(this, node, eventName, handler);
          }
        }
      }, {
        key: '_removeEventListenerFromNode',
        value: function _removeEventListenerFromNode(node, eventName, handler) {
          if (!gestures.removeListener(node, eventName, handler)) {
            _get(GestureEventListeners.prototype.__proto__ || Object.getPrototypeOf(GestureEventListeners.prototype), '_removeEventListenerFromNode', this).call(this, node, eventName, handler);
          }
        }
      }]);

      return GestureEventListeners;
    }(superClass);

    return GestureEventListeners;
  });
})();

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(1);

(function () {

  'use strict';

  function newSplice(index, removed, addedCount) {
    return {
      index: index,
      removed: removed,
      addedCount: addedCount
    };
  }

  var EDIT_LEAVE = 0;
  var EDIT_UPDATE = 1;
  var EDIT_ADD = 2;
  var EDIT_DELETE = 3;

  // Note: This function is *based* on the computation of the Levenshtein
  // "edit" distance. The one change is that "updates" are treated as two
  // edits - not one. With Array splices, an update is really a delete
  // followed by an add. By retaining this, we optimize for "keeping" the
  // maximum array items in the original array. For example:
  //
  //   'xxxx123' -> '123yyyy'
  //
  // With 1-edit updates, the shortest path would be just to update all seven
  // characters. With 2-edit updates, we delete 4, leave 3, and add 4. This
  // leaves the substring '123' intact.
  function calcEditDistances(current, currentStart, currentEnd, old, oldStart, oldEnd) {
    // "Deletion" columns
    var rowCount = oldEnd - oldStart + 1;
    var columnCount = currentEnd - currentStart + 1;
    var distances = new Array(rowCount);

    // "Addition" rows. Initialize null column.
    for (var i = 0; i < rowCount; i++) {
      distances[i] = new Array(columnCount);
      distances[i][0] = i;
    }

    // Initialize null row
    for (var j = 0; j < columnCount; j++) {
      distances[0][j] = j;
    }for (var _i = 1; _i < rowCount; _i++) {
      for (var _j = 1; _j < columnCount; _j++) {
        if (equals(current[currentStart + _j - 1], old[oldStart + _i - 1])) distances[_i][_j] = distances[_i - 1][_j - 1];else {
          var north = distances[_i - 1][_j] + 1;
          var west = distances[_i][_j - 1] + 1;
          distances[_i][_j] = north < west ? north : west;
        }
      }
    }

    return distances;
  }

  // This starts at the final weight, and walks "backward" by finding
  // the minimum previous weight recursively until the origin of the weight
  // matrix.
  function spliceOperationsFromEditDistances(distances) {
    var i = distances.length - 1;
    var j = distances[0].length - 1;
    var current = distances[i][j];
    var edits = [];
    while (i > 0 || j > 0) {
      if (i == 0) {
        edits.push(EDIT_ADD);
        j--;
        continue;
      }
      if (j == 0) {
        edits.push(EDIT_DELETE);
        i--;
        continue;
      }
      var northWest = distances[i - 1][j - 1];
      var west = distances[i - 1][j];
      var north = distances[i][j - 1];

      var min = void 0;
      if (west < north) min = west < northWest ? west : northWest;else min = north < northWest ? north : northWest;

      if (min == northWest) {
        if (northWest == current) {
          edits.push(EDIT_LEAVE);
        } else {
          edits.push(EDIT_UPDATE);
          current = northWest;
        }
        i--;
        j--;
      } else if (min == west) {
        edits.push(EDIT_DELETE);
        i--;
        current = west;
      } else {
        edits.push(EDIT_ADD);
        j--;
        current = north;
      }
    }

    edits.reverse();
    return edits;
  }

  /**
   * Splice Projection functions:
   *
   * A splice map is a representation of how a previous array of items
   * was transformed into a new array of items. Conceptually it is a list of
   * tuples of
   *
   *   <index, removed, addedCount>
   *
   * which are kept in ascending index order of. The tuple represents that at
   * the |index|, |removed| sequence of items were removed, and counting forward
   * from |index|, |addedCount| items were added.
   */

  /**
   * Lacking individual splice mutation information, the minimal set of
   * splices can be synthesized given the previous state and final state of an
   * array. The basic approach is to calculate the edit distance matrix and
   * choose the shortest path through it.
   *
   * Complexity: O(l * p)
   *   l: The length of the current array
   *   p: The length of the old array
   *
   * @param {Array} current The current "changed" array for which to
   * calculate splices.
   * @param {number} currentStart Starting index in the `current` array for
   * which splices are calculated.
   * @param {number} currentEnd Ending index in the `current` array for
   * which splices are calculated.
   * @param {Array} old The original "unchanged" array to compare `current`
   * against to determine splices.
   * @param {number} oldStart Starting index in the `old` array for
   * which splices are calculated.
   * @param {number} oldEnd Ending index in the `old` array for
   * which splices are calculated.
   * @return {Array} Returns an array of splice record objects. Each of these
   * contains: `index` the location where the splice occurred; `removed`
   * the array of removed items from this location; `addedCount` the number
   * of items added at this location.
   */
  function calcSplices(current, currentStart, currentEnd, old, oldStart, oldEnd) {
    var prefixCount = 0;
    var suffixCount = 0;
    var splice = void 0;

    var minLength = Math.min(currentEnd - currentStart, oldEnd - oldStart);
    if (currentStart == 0 && oldStart == 0) prefixCount = sharedPrefix(current, old, minLength);

    if (currentEnd == current.length && oldEnd == old.length) suffixCount = sharedSuffix(current, old, minLength - prefixCount);

    currentStart += prefixCount;
    oldStart += prefixCount;
    currentEnd -= suffixCount;
    oldEnd -= suffixCount;

    if (currentEnd - currentStart == 0 && oldEnd - oldStart == 0) return [];

    if (currentStart == currentEnd) {
      splice = newSplice(currentStart, [], 0);
      while (oldStart < oldEnd) {
        splice.removed.push(old[oldStart++]);
      }return [splice];
    } else if (oldStart == oldEnd) return [newSplice(currentStart, [], currentEnd - currentStart)];

    var ops = spliceOperationsFromEditDistances(calcEditDistances(current, currentStart, currentEnd, old, oldStart, oldEnd));

    splice = undefined;
    var splices = [];
    var index = currentStart;
    var oldIndex = oldStart;
    for (var i = 0; i < ops.length; i++) {
      switch (ops[i]) {
        case EDIT_LEAVE:
          if (splice) {
            splices.push(splice);
            splice = undefined;
          }

          index++;
          oldIndex++;
          break;
        case EDIT_UPDATE:
          if (!splice) splice = newSplice(index, [], 0);

          splice.addedCount++;
          index++;

          splice.removed.push(old[oldIndex]);
          oldIndex++;
          break;
        case EDIT_ADD:
          if (!splice) splice = newSplice(index, [], 0);

          splice.addedCount++;
          index++;
          break;
        case EDIT_DELETE:
          if (!splice) splice = newSplice(index, [], 0);

          splice.removed.push(old[oldIndex]);
          oldIndex++;
          break;
      }
    }

    if (splice) {
      splices.push(splice);
    }
    return splices;
  }

  function sharedPrefix(current, old, searchLength) {
    for (var i = 0; i < searchLength; i++) {
      if (!equals(current[i], old[i])) return i;
    }return searchLength;
  }

  function sharedSuffix(current, old, searchLength) {
    var index1 = current.length;
    var index2 = old.length;
    var count = 0;
    while (count < searchLength && equals(current[--index1], old[--index2])) {
      count++;
    }return count;
  }

  function calculateSplices(current, previous) {
    return calcSplices(current, 0, current.length, previous, 0, previous.length);
  }

  function equals(currentValue, previousValue) {
    return currentValue === previousValue;
  }

  /**
   * @namespace
   * @memberof Polymer
   * @summary Module that provides utilities for diffing arrays.
   */
  Polymer.ArraySplice = {
    /**
     * Returns an array of splice records indicating the minimum edits required
     * to transform the `previous` array into the `current` array.
     *
     * Splice records are ordered by index and contain the following fields:
     * - `index`: index where edit started
     * - `removed`: array of removed items from this index
     * - `addedCount`: number of items added at this index
     *
     * This function is based on the Levenshtein "minimum edit distance"
     * algorithm. Note that updates are treated as removal followed by addition.
     *
     * The worst-case time complexity of this algorithm is `O(l * p)`
     *   l: The length of the current array
     *   p: The length of the previous array
     *
     * However, the worst-case complexity is reduced by an `O(n)` optimization
     * to detect any shared prefix & suffix between the two arrays and only
     * perform the more expensive minimum edit distance calculation over the
     * non-shared portions of the arrays.
     *
     * @memberof Polymer.ArraySplice
     * @param {Array} current The "changed" array for which splices will be
     * calculated.
     * @param {Array} previous The "unchanged" original array to compare
     * `current` against to determine the splices.
     * @return {Array} Returns an array of splice record objects. Each of these
     * contains: `index` the location where the splice occurred; `removed`
     * the array of removed items from this location; `addedCount` the number
     * of items added at this location.
     */
    calculateSplices: calculateSplices
  };
})();

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(4);

/**
 * While scrolling down, fade in the rear background layer and fade out the front background
 * layer (opacity interpolated based on scroll position).
 */
Polymer.AppLayout.registerEffect('blend-background', {
  /** @this Polymer.AppLayout.ElementWithBackground */
  setUp: function setUp() {
    var fx = {};
    fx.backgroundFrontLayer = this._getDOMRef('backgroundFrontLayer');
    fx.backgroundRearLayer = this._getDOMRef('backgroundRearLayer');
    fx.backgroundFrontLayer.style.willChange = 'opacity';
    fx.backgroundFrontLayer.style.transform = 'translateZ(0)';
    fx.backgroundRearLayer.style.willChange = 'opacity';
    fx.backgroundRearLayer.style.transform = 'translateZ(0)';
    fx.backgroundRearLayer.style.opacity = 0;
    this._fxBlendBackground = fx;
  },
  /** @this Polymer.AppLayout.ElementWithBackground */
  run: function run(p, y) {
    var fx = this._fxBlendBackground;
    fx.backgroundFrontLayer.style.opacity = 1 - p;
    fx.backgroundRearLayer.style.opacity = p;
  },
  /** @this Polymer.AppLayout.ElementWithBackground */
  tearDown: function tearDown() {
    delete this._fxBlendBackground;
  }
});

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(4);

/**
 * Toggles the shadow property in app-header when content is scrolled to create a sense of depth
 * between the element and the content underneath.
 */
Polymer.AppLayout.registerEffect('waterfall', {
  /**
   *  @this Polymer.AppLayout.ElementWithBackground
   */
  run: function run() {
    this.shadow = this.isOnScreen() && this.isContentBelow();
  }
});

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(4);

(function () {
  function interpolate(progress, points, fn, ctx) {
    fn.apply(ctx, points.map(function (point) {
      return point[0] + (point[1] - point[0]) * progress;
    }));
  }

  /**
   * Transform the font size of a designated title element between two values based on the scroll
   * position.
   */
  Polymer.AppLayout.registerEffect('resize-title', {
    /** @this Polymer.AppLayout.ElementWithBackground */
    setUp: function setUp() {
      var title = this._getDOMRef('mainTitle');
      var condensedTitle = this._getDOMRef('condensedTitle');

      if (!condensedTitle) {
        console.warn('Scroll effect `resize-title`: undefined `condensed-title`');
        return false;
      }
      if (!title) {
        console.warn('Scroll effect `resize-title`: undefined `main-title`');
        return false;
      }

      condensedTitle.style.willChange = 'opacity';
      condensedTitle.style.webkitTransform = 'translateZ(0)';
      condensedTitle.style.transform = 'translateZ(0)';
      condensedTitle.style.webkitTransformOrigin = 'left top';
      condensedTitle.style.transformOrigin = 'left top';

      title.style.willChange = 'opacity';
      title.style.webkitTransformOrigin = 'left top';
      title.style.transformOrigin = 'left top';
      title.style.webkitTransform = 'translateZ(0)';
      title.style.transform = 'translateZ(0)';

      var titleClientRect = title.getBoundingClientRect();
      var condensedTitleClientRect = condensedTitle.getBoundingClientRect();
      var fx = {};

      fx.scale = parseInt(window.getComputedStyle(condensedTitle)['font-size'], 10) / parseInt(window.getComputedStyle(title)['font-size'], 10);
      fx.titleDX = titleClientRect.left - condensedTitleClientRect.left;
      fx.titleDY = titleClientRect.top - condensedTitleClientRect.top;
      fx.condensedTitle = condensedTitle;
      fx.title = title;

      this._fxResizeTitle = fx;
    },
    /** @this PolymerElement */
    run: function run(p, y) {
      var fx = this._fxResizeTitle;
      if (!this.condenses) {
        y = 0;
      }
      if (p >= 1) {
        fx.title.style.opacity = 0;
        fx.condensedTitle.style.opacity = 1;
      } else {
        fx.title.style.opacity = 1;
        fx.condensedTitle.style.opacity = 0;
      }
      interpolate(Math.min(1, p), [[1, fx.scale], [0, -fx.titleDX], [y, y - fx.titleDY]], function (scale, translateX, translateY) {
        this.transform('translate(' + translateX + 'px, ' + translateY + 'px) ' + 'scale3d(' + scale + ', ' + scale + ', 1)', fx.title);
      }, this);
    },
    /** @this Polymer.AppLayout.ElementWithBackground */
    tearDown: function tearDown() {
      delete this._fxResizeTitle;
    }
  });
})();

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(4);

/**
 * Vertically translate the background based on a factor of the scroll position.
 */
Polymer.AppLayout.registerEffect('parallax-background', {
  /**
   * @param {{scalar: string}} config
   * @this Polymer.AppLayout.ElementWithBackground
   */
  setUp: function setUp(config) {
    var fx = {};
    var scalar = parseFloat(config.scalar);
    fx.background = this._getDOMRef('background');
    fx.backgroundFrontLayer = this._getDOMRef('backgroundFrontLayer');
    fx.backgroundRearLayer = this._getDOMRef('backgroundRearLayer');
    fx.deltaBg = fx.backgroundFrontLayer.offsetHeight - fx.background.offsetHeight;
    if (fx.deltaBg === 0) {
      if (isNaN(scalar)) {
        scalar = 0.8;
      }
      fx.deltaBg = this._dHeight * scalar;
    } else {
      if (isNaN(scalar)) {
        scalar = 1;
      }
      fx.deltaBg = fx.deltaBg * scalar;
    }
    this._fxParallaxBackground = fx;
  },
  /** @this Polymer.AppLayout.ElementWithBackground */
  run: function run(p, y) {
    var fx = this._fxParallaxBackground;
    this.transform('translate3d(0px, ' + fx.deltaBg * Math.min(1, p) + 'px, 0px)', fx.backgroundFrontLayer);
    if (fx.backgroundRearLayer) {
      this.transform('translate3d(0px, ' + fx.deltaBg * Math.min(1, p) + 'px, 0px)', fx.backgroundRearLayer);
    }
  },
  /** @this Polymer.AppLayout.ElementWithBackground */
  tearDown: function tearDown() {
    delete this._fxParallaxBackground;
  }
});

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

__webpack_require__(81);

/**
 * @polymerBehavior Polymer.IronSelectableBehavior
 */
Polymer.IronSelectableBehavior = {

  /**
   * Fired when iron-selector is activated (selected or deselected).
   * It is fired before the selected items are changed.
   * Cancel the event to abort selection.
   *
   * @event iron-activate
   */

  /**
   * Fired when an item is selected
   *
   * @event iron-select
   */

  /**
   * Fired when an item is deselected
   *
   * @event iron-deselect
   */

  /**
   * Fired when the list of selectable items changes (e.g., items are
   * added or removed). The detail of the event is a mutation record that
   * describes what changed.
   *
   * @event iron-items-changed
   */

  properties: {

    /**
     * If you want to use an attribute value or property of an element for
     * `selected` instead of the index, set this to the name of the attribute
     * or property. Hyphenated values are converted to camel case when used to
     * look up the property of a selectable element. Camel cased values are
     * *not* converted to hyphenated values for attribute lookup. It's
     * recommended that you provide the hyphenated form of the name so that
     * selection works in both cases. (Use `attr-or-property-name` instead of
     * `attrOrPropertyName`.)
     */
    attrForSelected: {
      type: String,
      value: null
    },

    /**
     * Gets or sets the selected element. The default is to use the index of the item.
     * @type {string|number}
     */
    selected: {
      type: String,
      notify: true
    },

    /**
     * Returns the currently selected item.
     *
     * @type {?Object}
     */
    selectedItem: {
      type: Object,
      readOnly: true,
      notify: true
    },

    /**
     * The event that fires from items when they are selected. Selectable
     * will listen for this event from items and update the selection state.
     * Set to empty string to listen to no events.
     */
    activateEvent: {
      type: String,
      value: 'tap',
      observer: '_activateEventChanged'
    },

    /**
     * This is a CSS selector string.  If this is set, only items that match the CSS selector
     * are selectable.
     */
    selectable: String,

    /**
     * The class to set on elements when selected.
     */
    selectedClass: {
      type: String,
      value: 'iron-selected'
    },

    /**
     * The attribute to set on elements when selected.
     */
    selectedAttribute: {
      type: String,
      value: null
    },

    /**
     * Default fallback if the selection based on selected with `attrForSelected`
     * is not found.
     */
    fallbackSelection: {
      type: String,
      value: null
    },

    /**
     * The list of items from which a selection can be made.
     */
    items: {
      type: Array,
      readOnly: true,
      notify: true,
      value: function value() {
        return [];
      }
    },

    /**
     * The set of excluded elements where the key is the `localName`
     * of the element that will be ignored from the item list.
     *
     * @default {template: 1}
     */
    _excludedLocalNames: {
      type: Object,
      value: function value() {
        return {
          'template': 1,
          'dom-bind': 1,
          'dom-if': 1,
          'dom-repeat': 1
        };
      }
    }
  },

  observers: ['_updateAttrForSelected(attrForSelected)', '_updateSelected(selected)', '_checkFallback(fallbackSelection)'],

  created: function created() {
    this._bindFilterItem = this._filterItem.bind(this);
    this._selection = new Polymer.IronSelection(this._applySelection.bind(this));
  },

  attached: function attached() {
    this._observer = this._observeItems(this);
    this._addListener(this.activateEvent);
  },

  detached: function detached() {
    if (this._observer) {
      Polymer.dom(this).unobserveNodes(this._observer);
    }
    this._removeListener(this.activateEvent);
  },

  /**
   * Returns the index of the given item.
   *
   * @method indexOf
   * @param {Object} item
   * @returns Returns the index of the item
   */
  indexOf: function indexOf(item) {
    return this.items.indexOf(item);
  },

  /**
   * Selects the given value.
   *
   * @method select
   * @param {string|number} value the value to select.
   */
  select: function select(value) {
    this.selected = value;
  },

  /**
   * Selects the previous item.
   *
   * @method selectPrevious
   */
  selectPrevious: function selectPrevious() {
    var length = this.items.length;
    var index = (Number(this._valueToIndex(this.selected)) - 1 + length) % length;
    this.selected = this._indexToValue(index);
  },

  /**
   * Selects the next item.
   *
   * @method selectNext
   */
  selectNext: function selectNext() {
    var index = (Number(this._valueToIndex(this.selected)) + 1) % this.items.length;
    this.selected = this._indexToValue(index);
  },

  /**
   * Selects the item at the given index.
   *
   * @method selectIndex
   */
  selectIndex: function selectIndex(index) {
    this.select(this._indexToValue(index));
  },

  /**
   * Force a synchronous update of the `items` property.
   *
   * NOTE: Consider listening for the `iron-items-changed` event to respond to
   * updates to the set of selectable items after updates to the DOM list and
   * selection state have been made.
   *
   * WARNING: If you are using this method, you should probably consider an
   * alternate approach. Synchronously querying for items is potentially
   * slow for many use cases. The `items` property will update asynchronously
   * on its own to reflect selectable items in the DOM.
   */
  forceSynchronousItemUpdate: function forceSynchronousItemUpdate() {
    if (this._observer && typeof this._observer.flush === "function") {
      // NOTE(bicknellr): `Polymer.dom.flush` above is no longer sufficient to
      // trigger `observeNodes` callbacks. Polymer 2.x returns an object from
      // `observeNodes` with a `flush` that synchronously gives the callback
      // any pending MutationRecords (retrieved with `takeRecords`). Any case
      // where ShadyDOM flushes were expected to synchronously trigger item
      // updates will now require calling `forceSynchronousItemUpdate`.
      this._observer.flush();
    } else {
      this._updateItems();
    }
  },

  // UNUSED, FOR API COMPATIBILITY
  get _shouldUpdateSelection() {
    return this.selected != null;
  },

  _checkFallback: function _checkFallback() {
    this._updateSelected();
  },

  _addListener: function _addListener(eventName) {
    this.listen(this, eventName, '_activateHandler');
  },

  _removeListener: function _removeListener(eventName) {
    this.unlisten(this, eventName, '_activateHandler');
  },

  _activateEventChanged: function _activateEventChanged(eventName, old) {
    this._removeListener(old);
    this._addListener(eventName);
  },

  _updateItems: function _updateItems() {
    var nodes = Polymer.dom(this).queryDistributedElements(this.selectable || '*');
    nodes = Array.prototype.filter.call(nodes, this._bindFilterItem);
    this._setItems(nodes);
  },

  _updateAttrForSelected: function _updateAttrForSelected() {
    if (this.selectedItem) {
      this.selected = this._valueForItem(this.selectedItem);
    }
  },

  _updateSelected: function _updateSelected() {
    this._selectSelected(this.selected);
  },

  _selectSelected: function _selectSelected(selected) {
    if (!this.items) {
      return;
    }

    var item = this._valueToItem(this.selected);
    if (item) {
      this._selection.select(item);
    } else {
      this._selection.clear();
    }
    // Check for items, since this array is populated only when attached
    // Since Number(0) is falsy, explicitly check for undefined
    if (this.fallbackSelection && this.items.length && this._selection.get() === undefined) {
      this.selected = this.fallbackSelection;
    }
  },

  _filterItem: function _filterItem(node) {
    return !this._excludedLocalNames[node.localName];
  },

  _valueToItem: function _valueToItem(value) {
    return value == null ? null : this.items[this._valueToIndex(value)];
  },

  _valueToIndex: function _valueToIndex(value) {
    if (this.attrForSelected) {
      for (var i = 0, item; item = this.items[i]; i++) {
        if (this._valueForItem(item) == value) {
          return i;
        }
      }
    } else {
      return Number(value);
    }
  },

  _indexToValue: function _indexToValue(index) {
    if (this.attrForSelected) {
      var item = this.items[index];
      if (item) {
        return this._valueForItem(item);
      }
    } else {
      return index;
    }
  },

  _valueForItem: function _valueForItem(item) {
    if (!item) {
      return null;
    }

    var propValue = item[Polymer.CaseMap.dashToCamelCase(this.attrForSelected)];
    return propValue != undefined ? propValue : item.getAttribute(this.attrForSelected);
  },

  _applySelection: function _applySelection(item, isSelected) {
    if (this.selectedClass) {
      this.toggleClass(this.selectedClass, isSelected, item);
    }
    if (this.selectedAttribute) {
      this.toggleAttribute(this.selectedAttribute, isSelected, item);
    }
    this._selectionChange();
    this.fire('iron-' + (isSelected ? 'select' : 'deselect'), { item: item });
  },

  _selectionChange: function _selectionChange() {
    this._setSelectedItem(this._selection.get());
  },

  // observe items change under the given node.
  _observeItems: function _observeItems(node) {
    return Polymer.dom(node).observeNodes(function (mutation) {
      this._updateItems();
      this._updateSelected();

      // Let other interested parties know about the change so that
      // we don't have to recreate mutation observers everywhere.
      this.fire('iron-items-changed', mutation, {
        bubbles: false,
        cancelable: false
      });
    });
  },

  _activateHandler: function _activateHandler(e) {
    var t = e.target;
    var items = this.items;
    while (t && t != this) {
      var i = items.indexOf(t);
      if (i >= 0) {
        var value = this._indexToValue(i);
        this._itemActivate(value, t);
        return;
      }
      t = t.parentNode;
    }
  },

  _itemActivate: function _itemActivate(value, item) {
    if (!this.fire('iron-activate', { selected: value, item: item }, { cancelable: true }).defaultPrevented) {
      this.select(value);
    }
  }

};

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

__webpack_require__(38);

var RegisterHtmlTemplate = __webpack_require__(2);

RegisterHtmlTemplate.toBody("<custom-style> <style is=custom-style>html{--primary-text-color:var(--light-theme-text-color);--primary-background-color:var(--light-theme-background-color);--secondary-text-color:var(--light-theme-secondary-color);--disabled-text-color:var(--light-theme-disabled-color);--divider-color:var(--light-theme-divider-color);--error-color:var(--paper-deep-orange-a700);--primary-color:var(--paper-indigo-500);--light-primary-color:var(--paper-indigo-100);--dark-primary-color:var(--paper-indigo-700);--accent-color:var(--paper-pink-a200);--light-accent-color:var(--paper-pink-a100);--dark-accent-color:var(--paper-pink-a400);--light-theme-background-color:#ffffff;--light-theme-base-color:#000000;--light-theme-text-color:var(--paper-grey-900);--light-theme-secondary-color:#737373;--light-theme-disabled-color:#9b9b9b;--light-theme-divider-color:#dbdbdb;--dark-theme-background-color:var(--paper-grey-900);--dark-theme-base-color:#ffffff;--dark-theme-text-color:#ffffff;--dark-theme-secondary-color:#bcbcbc;--dark-theme-disabled-color:#646464;--dark-theme-divider-color:#3c3c3c;--text-primary-color:var(--dark-theme-text-color);--default-primary-color:var(--primary-color)}</style> </custom-style>");

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

__webpack_require__(32);

__webpack_require__(84);

__webpack_require__(30);

var RegisterHtmlTemplate = __webpack_require__(2);

RegisterHtmlTemplate.register("<dom-module id=paper-icon-button> <template strip-whitespace=\"\"> <style>:host{display:inline-block;position:relative;padding:8px;outline:0;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;z-index:0;line-height:1;width:40px;height:40px;-webkit-tap-highlight-color:transparent;-webkit-tap-highlight-color:transparent;box-sizing:border-box!important;@apply --paper-icon-button;}:host #ink{color:var(--paper-icon-button-ink-color,var(--primary-text-color));opacity:.6}:host([disabled]){color:var(--paper-icon-button-disabled-text,var(--disabled-text-color));pointer-events:none;cursor:auto;@apply --paper-icon-button-disabled;}:host([hidden]){display:none!important}:host(:hover){@apply --paper-icon-button-hover;}iron-icon{--iron-icon-width:100%;--iron-icon-height:100%}</style> <iron-icon id=icon src=[[src]] icon=[[icon]] alt$=[[alt]]></iron-icon> </template> </dom-module>");

Polymer({
  is: 'paper-icon-button',

  hostAttributes: {
    role: 'button',
    tabindex: '0'
  },

  behaviors: [Polymer.PaperInkyFocusBehavior],

  properties: {
    /**
     * The URL of an image for the icon. If the src property is specified,
     * the icon property should not be.
     */
    src: {
      type: String
    },

    /**
     * Specifies the icon name or index in the set of icons available in
     * the icon's icon set. If the icon property is specified,
     * the src property should not be.
     */
    icon: {
      type: String
    },

    /**
     * Specifies the alternate text for the button, for accessibility.
     */
    alt: {
      type: String,
      observer: "_altChanged"
    }
  },

  _altChanged: function _altChanged(newValue, oldValue) {
    var label = this.getAttribute('aria-label');

    // Don't stomp over a user-set aria-label.
    if (!label || oldValue == label) {
      this.setAttribute('aria-label', newValue);
    }
  }
});

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

__webpack_require__(18);

__webpack_require__(5);

var RegisterHtmlTemplate = __webpack_require__(2);

RegisterHtmlTemplate.register("<dom-module id=iron-icon> <template> <style>:host{@apply --layout-inline;@apply --layout-center-center;position:relative;vertical-align:middle;fill:var(--iron-icon-fill-color,currentcolor);stroke:var(--iron-icon-stroke-color,none);width:var(--iron-icon-width,24px);height:var(--iron-icon-height,24px);@apply --iron-icon;}:host([hidden]){display:none}</style> </template> </dom-module>");

Polymer({

  is: 'iron-icon',

  properties: {

    /**
     * The name of the icon to use. The name should be of the form:
     * `iconset_name:icon_name`.
     */
    icon: {
      type: String
    },

    /**
     * The name of the theme to used, if one is specified by the
     * iconset.
     */
    theme: {
      type: String
    },

    /**
     * If using iron-icon without an iconset, you can set the src to be
     * the URL of an individual icon image file. Note that this will take
     * precedence over a given icon attribute.
     */
    src: {
      type: String
    },

    /**
     * @type {!Polymer.IronMeta}
     */
    _meta: {
      value: Polymer.Base.create('iron-meta', { type: 'iconset' })
    }

  },

  observers: ['_updateIcon(_meta, isAttached)', '_updateIcon(theme, isAttached)', '_srcChanged(src, isAttached)', '_iconChanged(icon, isAttached)'],

  _DEFAULT_ICONSET: 'icons',

  _iconChanged: function _iconChanged(icon) {
    var parts = (icon || '').split(':');
    this._iconName = parts.pop();
    this._iconsetName = parts.pop() || this._DEFAULT_ICONSET;
    this._updateIcon();
  },

  _srcChanged: function _srcChanged(src) {
    this._updateIcon();
  },

  _usesIconset: function _usesIconset() {
    return this.icon || !this.src;
  },

  /** @suppress {visibility} */
  _updateIcon: function _updateIcon() {
    if (this._usesIconset()) {
      if (this._img && this._img.parentNode) {
        Polymer.dom(this.root).removeChild(this._img);
      }
      if (this._iconName === "") {
        if (this._iconset) {
          this._iconset.removeIcon(this);
        }
      } else if (this._iconsetName && this._meta) {
        this._iconset = /** @type {?Polymer.Iconset} */this._meta.byKey(this._iconsetName);
        if (this._iconset) {
          this._iconset.applyIcon(this, this._iconName, this.theme);
          this.unlisten(window, 'iron-iconset-added', '_updateIcon');
        } else {
          this.listen(window, 'iron-iconset-added', '_updateIcon');
        }
      }
    } else {
      if (this._iconset) {
        this._iconset.removeIcon(this);
      }
      if (!this._img) {
        this._img = document.createElement('img');
        this._img.style.width = '100%';
        this._img.style.height = '100%';
        this._img.draggable = false;
      }
      this._img.src = this.src;
      Polymer.dom(this.root).appendChild(this._img);
    }
  }

});

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

/**
 * @demo demo/index.html
 * @polymerBehavior
 */
Polymer.IronControlState = {

  properties: {

    /**
     * If true, the element currently has focus.
     */
    focused: {
      type: Boolean,
      value: false,
      notify: true,
      readOnly: true,
      reflectToAttribute: true
    },

    /**
     * If true, the user cannot interact with this element.
     */
    disabled: {
      type: Boolean,
      value: false,
      notify: true,
      observer: '_disabledChanged',
      reflectToAttribute: true
    },

    _oldTabIndex: {
      type: Number
    },

    _boundFocusBlurHandler: {
      type: Function,
      value: function value() {
        return this._focusBlurHandler.bind(this);
      }
    },

    __handleEventRetargeting: {
      type: Boolean,
      value: function value() {
        return !this.shadowRoot && !Polymer.Element;
      }
    }
  },

  observers: ['_changedControlState(focused, disabled)'],

  ready: function ready() {
    this.addEventListener('focus', this._boundFocusBlurHandler, true);
    this.addEventListener('blur', this._boundFocusBlurHandler, true);
  },

  _focusBlurHandler: function _focusBlurHandler(event) {
    // In Polymer 2.0, the library takes care of retargeting events.
    if (Polymer.Element) {
      this._setFocused(event.type === 'focus');
      return;
    }

    // NOTE(cdata):  if we are in ShadowDOM land, `event.target` will
    // eventually become `this` due to retargeting; if we are not in
    // ShadowDOM land, `event.target` will eventually become `this` due
    // to the second conditional which fires a synthetic event (that is also
    // handled). In either case, we can disregard `event.path`.
    if (event.target === this) {
      this._setFocused(event.type === 'focus');
    } else if (this.__handleEventRetargeting) {
      var target = /** @type {Node} */Polymer.dom(event).localTarget;
      if (!this.isLightDescendant(target)) {
        this.fire(event.type, { sourceEvent: event }, {
          node: this,
          bubbles: event.bubbles,
          cancelable: event.cancelable
        });
      }
    }
  },

  _disabledChanged: function _disabledChanged(disabled, old) {
    this.setAttribute('aria-disabled', disabled ? 'true' : 'false');
    this.style.pointerEvents = disabled ? 'none' : '';
    if (disabled) {
      this._oldTabIndex = this.tabIndex;
      this._setFocused(false);
      this.tabIndex = -1;
      this.blur();
    } else if (this._oldTabIndex !== undefined) {
      this.tabIndex = this._oldTabIndex;
    }
  },

  _changedControlState: function _changedControlState() {
    // _controlStateChanged is abstract, follow-on behaviors may implement it
    if (this._controlStateChanged) {
      this._controlStateChanged();
    }
  }

};

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

__webpack_require__(16);

var RegisterHtmlTemplate = __webpack_require__(2);

RegisterHtmlTemplate.register("<dom-module id=paper-ripple> <template> <style>:host{display:block;position:absolute;border-radius:inherit;overflow:hidden;top:0;left:0;right:0;bottom:0;pointer-events:none}:host([animating]){-webkit-transform:translate(0,0);transform:translate3d(0,0,0)}#background,#waves,.wave,.wave-container{pointer-events:none;position:absolute;top:0;left:0;width:100%;height:100%}#background,.wave{opacity:0}#waves,.wave{overflow:hidden}.wave,.wave-container{border-radius:50%}:host(.circle) #background,:host(.circle) #waves{border-radius:50%}:host(.circle) .wave-container{overflow:hidden}</style> <div id=background></div> <div id=waves></div> </template> </dom-module>");

(function () {
  'use strict';

  var Utility = {
    distance: function distance(x1, y1, x2, y2) {
      var xDelta = x1 - x2;
      var yDelta = y1 - y2;

      return Math.sqrt(xDelta * xDelta + yDelta * yDelta);
    },

    now: window.performance && window.performance.now ? window.performance.now.bind(window.performance) : Date.now
  };

  /**
   * @param {HTMLElement} element
   * @constructor
   */
  function ElementMetrics(element) {
    this.element = element;
    this.width = this.boundingRect.width;
    this.height = this.boundingRect.height;

    this.size = Math.max(this.width, this.height);
  }

  ElementMetrics.prototype = {
    get boundingRect() {
      return this.element.getBoundingClientRect();
    },

    furthestCornerDistanceFrom: function furthestCornerDistanceFrom(x, y) {
      var topLeft = Utility.distance(x, y, 0, 0);
      var topRight = Utility.distance(x, y, this.width, 0);
      var bottomLeft = Utility.distance(x, y, 0, this.height);
      var bottomRight = Utility.distance(x, y, this.width, this.height);

      return Math.max(topLeft, topRight, bottomLeft, bottomRight);
    }
  };

  /**
   * @param {HTMLElement} element
   * @constructor
   */
  function Ripple(element) {
    this.element = element;
    this.color = window.getComputedStyle(element).color;

    this.wave = document.createElement('div');
    this.waveContainer = document.createElement('div');
    this.wave.style.backgroundColor = this.color;
    this.wave.classList.add('wave');
    this.waveContainer.classList.add('wave-container');
    Polymer.dom(this.waveContainer).appendChild(this.wave);

    this.resetInteractionState();
  }

  Ripple.MAX_RADIUS = 300;

  Ripple.prototype = {
    get recenters() {
      return this.element.recenters;
    },

    get center() {
      return this.element.center;
    },

    get mouseDownElapsed() {
      var elapsed;

      if (!this.mouseDownStart) {
        return 0;
      }

      elapsed = Utility.now() - this.mouseDownStart;

      if (this.mouseUpStart) {
        elapsed -= this.mouseUpElapsed;
      }

      return elapsed;
    },

    get mouseUpElapsed() {
      return this.mouseUpStart ? Utility.now() - this.mouseUpStart : 0;
    },

    get mouseDownElapsedSeconds() {
      return this.mouseDownElapsed / 1000;
    },

    get mouseUpElapsedSeconds() {
      return this.mouseUpElapsed / 1000;
    },

    get mouseInteractionSeconds() {
      return this.mouseDownElapsedSeconds + this.mouseUpElapsedSeconds;
    },

    get initialOpacity() {
      return this.element.initialOpacity;
    },

    get opacityDecayVelocity() {
      return this.element.opacityDecayVelocity;
    },

    get radius() {
      var width2 = this.containerMetrics.width * this.containerMetrics.width;
      var height2 = this.containerMetrics.height * this.containerMetrics.height;
      var waveRadius = Math.min(Math.sqrt(width2 + height2), Ripple.MAX_RADIUS) * 1.1 + 5;

      var duration = 1.1 - 0.2 * (waveRadius / Ripple.MAX_RADIUS);
      var timeNow = this.mouseInteractionSeconds / duration;
      var size = waveRadius * (1 - Math.pow(80, -timeNow));

      return Math.abs(size);
    },

    get opacity() {
      if (!this.mouseUpStart) {
        return this.initialOpacity;
      }

      return Math.max(0, this.initialOpacity - this.mouseUpElapsedSeconds * this.opacityDecayVelocity);
    },

    get outerOpacity() {
      // Linear increase in background opacity, capped at the opacity
      // of the wavefront (waveOpacity).
      var outerOpacity = this.mouseUpElapsedSeconds * 0.3;
      var waveOpacity = this.opacity;

      return Math.max(0, Math.min(outerOpacity, waveOpacity));
    },

    get isOpacityFullyDecayed() {
      return this.opacity < 0.01 && this.radius >= Math.min(this.maxRadius, Ripple.MAX_RADIUS);
    },

    get isRestingAtMaxRadius() {
      return this.opacity >= this.initialOpacity && this.radius >= Math.min(this.maxRadius, Ripple.MAX_RADIUS);
    },

    get isAnimationComplete() {
      return this.mouseUpStart ? this.isOpacityFullyDecayed : this.isRestingAtMaxRadius;
    },

    get translationFraction() {
      return Math.min(1, this.radius / this.containerMetrics.size * 2 / Math.sqrt(2));
    },

    get xNow() {
      if (this.xEnd) {
        return this.xStart + this.translationFraction * (this.xEnd - this.xStart);
      }

      return this.xStart;
    },

    get yNow() {
      if (this.yEnd) {
        return this.yStart + this.translationFraction * (this.yEnd - this.yStart);
      }

      return this.yStart;
    },

    get isMouseDown() {
      return this.mouseDownStart && !this.mouseUpStart;
    },

    resetInteractionState: function resetInteractionState() {
      this.maxRadius = 0;
      this.mouseDownStart = 0;
      this.mouseUpStart = 0;

      this.xStart = 0;
      this.yStart = 0;
      this.xEnd = 0;
      this.yEnd = 0;
      this.slideDistance = 0;

      this.containerMetrics = new ElementMetrics(this.element);
    },

    draw: function draw() {
      var scale;
      var translateString;
      var dx;
      var dy;

      this.wave.style.opacity = this.opacity;

      scale = this.radius / (this.containerMetrics.size / 2);
      dx = this.xNow - this.containerMetrics.width / 2;
      dy = this.yNow - this.containerMetrics.height / 2;

      // 2d transform for safari because of border-radius and overflow:hidden clipping bug.
      // https://bugs.webkit.org/show_bug.cgi?id=98538
      this.waveContainer.style.webkitTransform = 'translate(' + dx + 'px, ' + dy + 'px)';
      this.waveContainer.style.transform = 'translate3d(' + dx + 'px, ' + dy + 'px, 0)';
      this.wave.style.webkitTransform = 'scale(' + scale + ',' + scale + ')';
      this.wave.style.transform = 'scale3d(' + scale + ',' + scale + ',1)';
    },

    /** @param {Event=} event */
    downAction: function downAction(event) {
      var xCenter = this.containerMetrics.width / 2;
      var yCenter = this.containerMetrics.height / 2;

      this.resetInteractionState();
      this.mouseDownStart = Utility.now();

      if (this.center) {
        this.xStart = xCenter;
        this.yStart = yCenter;
        this.slideDistance = Utility.distance(this.xStart, this.yStart, this.xEnd, this.yEnd);
      } else {
        this.xStart = event ? event.detail.x - this.containerMetrics.boundingRect.left : this.containerMetrics.width / 2;
        this.yStart = event ? event.detail.y - this.containerMetrics.boundingRect.top : this.containerMetrics.height / 2;
      }

      if (this.recenters) {
        this.xEnd = xCenter;
        this.yEnd = yCenter;
        this.slideDistance = Utility.distance(this.xStart, this.yStart, this.xEnd, this.yEnd);
      }

      this.maxRadius = this.containerMetrics.furthestCornerDistanceFrom(this.xStart, this.yStart);

      this.waveContainer.style.top = (this.containerMetrics.height - this.containerMetrics.size) / 2 + 'px';
      this.waveContainer.style.left = (this.containerMetrics.width - this.containerMetrics.size) / 2 + 'px';

      this.waveContainer.style.width = this.containerMetrics.size + 'px';
      this.waveContainer.style.height = this.containerMetrics.size + 'px';
    },

    /** @param {Event=} event */
    upAction: function upAction(event) {
      if (!this.isMouseDown) {
        return;
      }

      this.mouseUpStart = Utility.now();
    },

    remove: function remove() {
      Polymer.dom(this.waveContainer.parentNode).removeChild(this.waveContainer);
    }
  };

  Polymer({
    is: 'paper-ripple',

    behaviors: [Polymer.IronA11yKeysBehavior],

    properties: {
      /**
       * The initial opacity set on the wave.
       *
       * @attribute initialOpacity
       * @type number
       * @default 0.25
       */
      initialOpacity: {
        type: Number,
        value: 0.25
      },

      /**
       * How fast (opacity per second) the wave fades out.
       *
       * @attribute opacityDecayVelocity
       * @type number
       * @default 0.8
       */
      opacityDecayVelocity: {
        type: Number,
        value: 0.8
      },

      /**
       * If true, ripples will exhibit a gravitational pull towards
       * the center of their container as they fade away.
       *
       * @attribute recenters
       * @type boolean
       * @default false
       */
      recenters: {
        type: Boolean,
        value: false
      },

      /**
       * If true, ripples will center inside its container
       *
       * @attribute recenters
       * @type boolean
       * @default false
       */
      center: {
        type: Boolean,
        value: false
      },

      /**
       * A list of the visual ripples.
       *
       * @attribute ripples
       * @type Array
       * @default []
       */
      ripples: {
        type: Array,
        value: function value() {
          return [];
        }
      },

      /**
       * True when there are visible ripples animating within the
       * element.
       */
      animating: {
        type: Boolean,
        readOnly: true,
        reflectToAttribute: true,
        value: false
      },

      /**
       * If true, the ripple will remain in the "down" state until `holdDown`
       * is set to false again.
       */
      holdDown: {
        type: Boolean,
        value: false,
        observer: '_holdDownChanged'
      },

      /**
       * If true, the ripple will not generate a ripple effect
       * via pointer interaction.
       * Calling ripple's imperative api like `simulatedRipple` will
       * still generate the ripple effect.
       */
      noink: {
        type: Boolean,
        value: false
      },

      _animating: {
        type: Boolean
      },

      _boundAnimate: {
        type: Function,
        value: function value() {
          return this.animate.bind(this);
        }
      }
    },

    get target() {
      return this.keyEventTarget;
    },

    keyBindings: {
      'enter:keydown': '_onEnterKeydown',
      'space:keydown': '_onSpaceKeydown',
      'space:keyup': '_onSpaceKeyup'
    },

    attached: function attached() {
      // Set up a11yKeysBehavior to listen to key events on the target,
      // so that space and enter activate the ripple even if the target doesn't
      // handle key events. The key handlers deal with `noink` themselves.
      if (this.parentNode.nodeType == 11) {
        // DOCUMENT_FRAGMENT_NODE
        this.keyEventTarget = Polymer.dom(this).getOwnerRoot().host;
      } else {
        this.keyEventTarget = this.parentNode;
      }
      var keyEventTarget = /** @type {!EventTarget} */this.keyEventTarget;
      this.listen(keyEventTarget, 'up', 'uiUpAction');
      this.listen(keyEventTarget, 'down', 'uiDownAction');
    },

    detached: function detached() {
      this.unlisten(this.keyEventTarget, 'up', 'uiUpAction');
      this.unlisten(this.keyEventTarget, 'down', 'uiDownAction');
      this.keyEventTarget = null;
    },

    get shouldKeepAnimating() {
      for (var index = 0; index < this.ripples.length; ++index) {
        if (!this.ripples[index].isAnimationComplete) {
          return true;
        }
      }

      return false;
    },

    simulatedRipple: function simulatedRipple() {
      this.downAction(null);

      // Please see polymer/polymer#1305
      this.async(function () {
        this.upAction();
      }, 1);
    },

    /**
     * Provokes a ripple down effect via a UI event,
     * respecting the `noink` property.
     * @param {Event=} event
     */
    uiDownAction: function uiDownAction(event) {
      if (!this.noink) {
        this.downAction(event);
      }
    },

    /**
     * Provokes a ripple down effect via a UI event,
     * *not* respecting the `noink` property.
     * @param {Event=} event
     */
    downAction: function downAction(event) {
      if (this.holdDown && this.ripples.length > 0) {
        return;
      }

      var ripple = this.addRipple();

      ripple.downAction(event);

      if (!this._animating) {
        this._animating = true;
        this.animate();
      }
    },

    /**
     * Provokes a ripple up effect via a UI event,
     * respecting the `noink` property.
     * @param {Event=} event
     */
    uiUpAction: function uiUpAction(event) {
      if (!this.noink) {
        this.upAction(event);
      }
    },

    /**
     * Provokes a ripple up effect via a UI event,
     * *not* respecting the `noink` property.
     * @param {Event=} event
     */
    upAction: function upAction(event) {
      if (this.holdDown) {
        return;
      }

      this.ripples.forEach(function (ripple) {
        ripple.upAction(event);
      });

      this._animating = true;
      this.animate();
    },

    onAnimationComplete: function onAnimationComplete() {
      this._animating = false;
      this.$.background.style.backgroundColor = null;
      this.fire('transitionend');
    },

    addRipple: function addRipple() {
      var ripple = new Ripple(this);

      Polymer.dom(this.$.waves).appendChild(ripple.waveContainer);
      this.$.background.style.backgroundColor = ripple.color;
      this.ripples.push(ripple);

      this._setAnimating(true);

      return ripple;
    },

    removeRipple: function removeRipple(ripple) {
      var rippleIndex = this.ripples.indexOf(ripple);

      if (rippleIndex < 0) {
        return;
      }

      this.ripples.splice(rippleIndex, 1);

      ripple.remove();

      if (!this.ripples.length) {
        this._setAnimating(false);
      }
    },

    /**
     * This conflicts with Element#antimate().
     * https://developer.mozilla.org/en-US/docs/Web/API/Element/animate
     * @suppress {checkTypes}
     */
    animate: function animate() {
      if (!this._animating) {
        return;
      }
      var index;
      var ripple;

      for (index = 0; index < this.ripples.length; ++index) {
        ripple = this.ripples[index];

        ripple.draw();

        this.$.background.style.opacity = ripple.outerOpacity;

        if (ripple.isOpacityFullyDecayed && !ripple.isRestingAtMaxRadius) {
          this.removeRipple(ripple);
        }
      }

      if (!this.shouldKeepAnimating && this.ripples.length === 0) {
        this.onAnimationComplete();
      } else {
        window.requestAnimationFrame(this._boundAnimate);
      }
    },

    _onEnterKeydown: function _onEnterKeydown() {
      this.uiDownAction();
      this.async(this.uiUpAction, 1);
    },

    _onSpaceKeydown: function _onSpaceKeydown() {
      this.uiDownAction();
    },

    _onSpaceKeyup: function _onSpaceKeyup() {
      this.uiUpAction();
    },

    // note: holdDown does not respect noink since it can be a focus based
    // effect.
    _holdDownChanged: function _holdDownChanged(newVal, oldVal) {
      if (oldVal === undefined) {
        return;
      }
      if (newVal) {
        this.downAction();
      } else {
        this.upAction();
      }
    }

    /**
    Fired when the animation finishes.
    This is useful if you want to wait until
    the ripple animation finishes to perform some action.
     @event transitionend
    @param {{node: Object}} detail Contains the animated node.
    */
  });
})();

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

__webpack_require__(18);

/**
 * The `iron-iconset-svg` element allows users to define their own icon sets
 * that contain svg icons. The svg icon elements should be children of the
 * `iron-iconset-svg` element. Multiple icons should be given distinct id's.
 *
 * Using svg elements to create icons has a few advantages over traditional
 * bitmap graphics like jpg or png. Icons that use svg are vector based so
 * they are resolution independent and should look good on any device. They
 * are stylable via css. Icons can be themed, colorized, and even animated.
 *
 * Example:
 *
 *     <iron-iconset-svg name="my-svg-icons" size="24">
 *       <svg>
 *         <defs>
 *           <g id="shape">
 *             <rect x="12" y="0" width="12" height="24" />
 *             <circle cx="12" cy="12" r="12" />
 *           </g>
 *         </defs>
 *       </svg>
 *     </iron-iconset-svg>
 *
 * This will automatically register the icon set "my-svg-icons" to the iconset
 * database.  To use these icons from within another element, make a
 * `iron-iconset` element and call the `byId` method
 * to retrieve a given iconset. To apply a particular icon inside an
 * element use the `applyIcon` method. For example:
 *
 *     iconset.applyIcon(iconNode, 'car');
 *
 * @element iron-iconset-svg
 * @demo demo/index.html
 * @implements {Polymer.Iconset}
 */
Polymer({
  is: 'iron-iconset-svg',

  properties: {

    /**
     * The name of the iconset.
     */
    name: {
      type: String,
      observer: '_nameChanged'
    },

    /**
     * The size of an individual icon. Note that icons must be square.
     */
    size: {
      type: Number,
      value: 24
    },

    /**
     * Set to true to enable mirroring of icons where specified when they are
     * stamped. Icons that should be mirrored should be decorated with a
     * `mirror-in-rtl` attribute.
     *
     * NOTE: For performance reasons, direction will be resolved once per
     * document per iconset, so moving icons in and out of RTL subtrees will
     * not cause their mirrored state to change.
     */
    rtlMirroring: {
      type: Boolean,
      value: false
    },

    /**
     * Set to true to measure RTL based on the dir attribute on the body or
     * html elements (measured on document.body or document.documentElement as
     * available).
     */
    useGlobalRtlAttribute: {
      type: Boolean,
      value: false
    }
  },

  created: function created() {
    this._meta = new Polymer.IronMeta({ type: 'iconset', key: null, value: null });
  },

  attached: function attached() {
    this.style.display = 'none';
  },

  /**
   * Construct an array of all icon names in this iconset.
   *
   * @return {!Array} Array of icon names.
   */
  getIconNames: function getIconNames() {
    this._icons = this._createIconMap();
    return Object.keys(this._icons).map(function (n) {
      return this.name + ':' + n;
    }, this);
  },

  /**
   * Applies an icon to the given element.
   *
   * An svg icon is prepended to the element's shadowRoot if it exists,
   * otherwise to the element itself.
   *
   * If RTL mirroring is enabled, and the icon is marked to be mirrored in
   * RTL, the element will be tested (once and only once ever for each
   * iconset) to determine the direction of the subtree the element is in.
   * This direction will apply to all future icon applications, although only
   * icons marked to be mirrored will be affected.
   *
   * @method applyIcon
   * @param {Element} element Element to which the icon is applied.
   * @param {string} iconName Name of the icon to apply.
   * @return {?Element} The svg element which renders the icon.
   */
  applyIcon: function applyIcon(element, iconName) {
    // Remove old svg element
    this.removeIcon(element);
    // install new svg element
    var svg = this._cloneIcon(iconName, this.rtlMirroring && this._targetIsRTL(element));
    if (svg) {
      // insert svg element into shadow root, if it exists
      var pde = Polymer.dom(element.root || element);
      pde.insertBefore(svg, pde.childNodes[0]);
      return element._svgIcon = svg;
    }
    return null;
  },

  /**
   * Remove an icon from the given element by undoing the changes effected
   * by `applyIcon`.
   *
   * @param {Element} element The element from which the icon is removed.
   */
  removeIcon: function removeIcon(element) {
    // Remove old svg element
    if (element._svgIcon) {
      Polymer.dom(element.root || element).removeChild(element._svgIcon);
      element._svgIcon = null;
    }
  },

  /**
   * Measures and memoizes the direction of the element. Note that this
   * measurement is only done once and the result is memoized for future
   * invocations.
   */
  _targetIsRTL: function _targetIsRTL(target) {
    if (this.__targetIsRTL == null) {
      if (this.useGlobalRtlAttribute) {
        var globalElement = document.body && document.body.hasAttribute('dir') ? document.body : document.documentElement;

        this.__targetIsRTL = globalElement.getAttribute('dir') === 'rtl';
      } else {
        if (target && target.nodeType !== Node.ELEMENT_NODE) {
          target = target.host;
        }

        this.__targetIsRTL = target && window.getComputedStyle(target)['direction'] === 'rtl';
      }
    }

    return this.__targetIsRTL;
  },

  /**
   *
   * When name is changed, register iconset metadata
   *
   */
  _nameChanged: function _nameChanged() {
    this._meta.value = null;
    this._meta.key = this.name;
    this._meta.value = this;

    this.async(function () {
      this.fire('iron-iconset-added', this, { node: window });
    });
  },

  /**
   * Create a map of child SVG elements by id.
   *
   * @return {!Object} Map of id's to SVG elements.
   */
  _createIconMap: function _createIconMap() {
    // Objects chained to Object.prototype (`{}`) have members. Specifically,
    // on FF there is a `watch` method that confuses the icon map, so we
    // need to use a null-based object here.
    var icons = Object.create(null);
    Polymer.dom(this).querySelectorAll('[id]').forEach(function (icon) {
      icons[icon.id] = icon;
    });
    return icons;
  },

  /**
   * Produce installable clone of the SVG element matching `id` in this
   * iconset, or `undefined` if there is no matching element.
   *
   * @return {Element} Returns an installable clone of the SVG element
   * matching `id`.
   */
  _cloneIcon: function _cloneIcon(id, mirrorAllowed) {
    // create the icon map on-demand, since the iconset itself has no discrete
    // signal to know when it's children are fully parsed
    this._icons = this._icons || this._createIconMap();
    return this._prepareSvgClone(this._icons[id], this.size, mirrorAllowed);
  },

  /**
   * @param {Element} sourceSvg
   * @param {number} size
   * @param {Boolean} mirrorAllowed
   * @return {Element}
   */
  _prepareSvgClone: function _prepareSvgClone(sourceSvg, size, mirrorAllowed) {
    if (sourceSvg) {
      var content = sourceSvg.cloneNode(true),
          svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg'),
          viewBox = content.getAttribute('viewBox') || '0 0 ' + size + ' ' + size,
          cssText = 'pointer-events: none; display: block; width: 100%; height: 100%;';

      if (mirrorAllowed && content.hasAttribute('mirror-in-rtl')) {
        cssText += '-webkit-transform:scale(-1,1);transform:scale(-1,1);';
      }

      svg.setAttribute('viewBox', viewBox);
      svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');
      svg.setAttribute('focusable', 'false');
      // TODO(dfreedm): `pointer-events: none` works around https://crbug.com/370136
      // TODO(sjmiles): inline style may not be ideal, but avoids requiring a shadow-root
      svg.style.cssText = cssText;
      svg.appendChild(content).removeAttribute('id');
      return svg;
    }
    return null;
  }

});

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

/**
 * `Polymer.IronScrollTargetBehavior` allows an element to respond to scroll events from a
 * designated scroll target.
 *
 * Elements that consume this behavior can override the `_scrollHandler`
 * method to add logic on the scroll event.
 *
 * @demo demo/scrolling-region.html Scrolling Region
 * @demo demo/document.html Document Element
 * @polymerBehavior
 */
Polymer.IronScrollTargetBehavior = {

  properties: {

    /**
     * Specifies the element that will handle the scroll event
     * on the behalf of the current element. This is typically a reference to an element,
     * but there are a few more posibilities:
     *
     * ### Elements id
     *
     *```html
     * <div id="scrollable-element" style="overflow: auto;">
     *  <x-element scroll-target="scrollable-element">
     *    <!-- Content-->
     *  </x-element>
     * </div>
     *```
     * In this case, the `scrollTarget` will point to the outer div element.
     *
     * ### Document scrolling
     *
     * For document scrolling, you can use the reserved word `document`:
     *
     *```html
     * <x-element scroll-target="document">
     *   <!-- Content -->
     * </x-element>
     *```
     *
     * ### Elements reference
     *
     *```js
     * appHeader.scrollTarget = document.querySelector('#scrollable-element');
     *```
     *
     * @type {HTMLElement}
     * @default document
     */
    scrollTarget: {
      type: HTMLElement,
      value: function value() {
        return this._defaultScrollTarget;
      }
    }
  },

  observers: ['_scrollTargetChanged(scrollTarget, isAttached)'],

  /**
   * True if the event listener should be installed.
   */
  _shouldHaveListener: true,

  _scrollTargetChanged: function _scrollTargetChanged(scrollTarget, isAttached) {
    var eventTarget;

    if (this._oldScrollTarget) {
      this._toggleScrollListener(false, this._oldScrollTarget);
      this._oldScrollTarget = null;
    }
    if (!isAttached) {
      return;
    }
    // Support element id references
    if (scrollTarget === 'document') {

      this.scrollTarget = this._doc;
    } else if (typeof scrollTarget === 'string') {

      var domHost = this.domHost;

      this.scrollTarget = domHost && domHost.$ ? domHost.$[scrollTarget] : Polymer.dom(this.ownerDocument).querySelector('#' + scrollTarget);
    } else if (this._isValidScrollTarget()) {

      this._oldScrollTarget = scrollTarget;
      this._toggleScrollListener(this._shouldHaveListener, scrollTarget);
    }
  },

  /**
   * Runs on every scroll event. Consumer of this behavior may override this method.
   *
   * @protected
   */
  _scrollHandler: function scrollHandler() {},

  /**
   * The default scroll target. Consumers of this behavior may want to customize
   * the default scroll target.
   *
   * @type {Element}
   */
  get _defaultScrollTarget() {
    return this._doc;
  },

  /**
   * Shortcut for the document element
   *
   * @type {Element}
   */
  get _doc() {
    return this.ownerDocument.documentElement;
  },

  /**
   * Gets the number of pixels that the content of an element is scrolled upward.
   *
   * @type {number}
   */
  get _scrollTop() {
    if (this._isValidScrollTarget()) {
      return this.scrollTarget === this._doc ? window.pageYOffset : this.scrollTarget.scrollTop;
    }
    return 0;
  },

  /**
   * Gets the number of pixels that the content of an element is scrolled to the left.
   *
   * @type {number}
   */
  get _scrollLeft() {
    if (this._isValidScrollTarget()) {
      return this.scrollTarget === this._doc ? window.pageXOffset : this.scrollTarget.scrollLeft;
    }
    return 0;
  },

  /**
   * Sets the number of pixels that the content of an element is scrolled upward.
   *
   * @type {number}
   */
  set _scrollTop(top) {
    if (this.scrollTarget === this._doc) {
      window.scrollTo(window.pageXOffset, top);
    } else if (this._isValidScrollTarget()) {
      this.scrollTarget.scrollTop = top;
    }
  },

  /**
   * Sets the number of pixels that the content of an element is scrolled to the left.
   *
   * @type {number}
   */
  set _scrollLeft(left) {
    if (this.scrollTarget === this._doc) {
      window.scrollTo(left, window.pageYOffset);
    } else if (this._isValidScrollTarget()) {
      this.scrollTarget.scrollLeft = left;
    }
  },

  /**
   * Scrolls the content to a particular place.
   *
   * @method scroll
   * @param {number} left The left position
   * @param {number} top The top position
   */
  scroll: function scroll(left, top) {
    if (this.scrollTarget === this._doc) {
      window.scrollTo(left, top);
    } else if (this._isValidScrollTarget()) {
      this.scrollTarget.scrollLeft = left;
      this.scrollTarget.scrollTop = top;
    }
  },

  /**
   * Gets the width of the scroll target.
   *
   * @type {number}
   */
  get _scrollTargetWidth() {
    if (this._isValidScrollTarget()) {
      return this.scrollTarget === this._doc ? window.innerWidth : this.scrollTarget.offsetWidth;
    }
    return 0;
  },

  /**
   * Gets the height of the scroll target.
   *
   * @type {number}
   */
  get _scrollTargetHeight() {
    if (this._isValidScrollTarget()) {
      return this.scrollTarget === this._doc ? window.innerHeight : this.scrollTarget.offsetHeight;
    }
    return 0;
  },

  /**
   * Returns true if the scroll target is a valid HTMLElement.
   *
   * @return {boolean}
   */
  _isValidScrollTarget: function _isValidScrollTarget() {
    return this.scrollTarget instanceof HTMLElement;
  },

  _toggleScrollListener: function _toggleScrollListener(yes, scrollTarget) {
    var eventTarget = scrollTarget === this._doc ? window : scrollTarget;
    if (yes) {
      if (!this._boundScrollHandler) {
        this._boundScrollHandler = this._scrollHandler.bind(this);
        eventTarget.addEventListener('scroll', this._boundScrollHandler);
      }
    } else {
      if (this._boundScrollHandler) {
        eventTarget.removeEventListener('scroll', this._boundScrollHandler);
        this._boundScrollHandler = null;
      }
    }
  },

  /**
   * Enables or disables the scroll event listener.
   *
   * @param {boolean} yes True to add the event, False to remove it.
   */
  toggleScrollListener: function toggleScrollListener(yes) {
    this._shouldHaveListener = yes;
    this._toggleScrollListener(yes, this.scrollTarget);
  }

};

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

__webpack_require__(16);

__webpack_require__(33);

/**
 * @demo demo/index.html
 * @polymerBehavior Polymer.IronButtonState
 */
Polymer.IronButtonStateImpl = {

  properties: {

    /**
     * If true, the user is currently holding down the button.
     */
    pressed: {
      type: Boolean,
      readOnly: true,
      value: false,
      reflectToAttribute: true,
      observer: '_pressedChanged'
    },

    /**
     * If true, the button toggles the active state with each tap or press
     * of the spacebar.
     */
    toggles: {
      type: Boolean,
      value: false,
      reflectToAttribute: true
    },

    /**
     * If true, the button is a toggle and is currently in the active state.
     */
    active: {
      type: Boolean,
      value: false,
      notify: true,
      reflectToAttribute: true
    },

    /**
     * True if the element is currently being pressed by a "pointer," which
     * is loosely defined as mouse or touch input (but specifically excluding
     * keyboard input).
     */
    pointerDown: {
      type: Boolean,
      readOnly: true,
      value: false
    },

    /**
     * True if the input device that caused the element to receive focus
     * was a keyboard.
     */
    receivedFocusFromKeyboard: {
      type: Boolean,
      readOnly: true
    },

    /**
     * The aria attribute to be set if the button is a toggle and in the
     * active state.
     */
    ariaActiveAttribute: {
      type: String,
      value: 'aria-pressed',
      observer: '_ariaActiveAttributeChanged'
    }
  },

  listeners: {
    down: '_downHandler',
    up: '_upHandler',
    tap: '_tapHandler'
  },

  observers: ['_focusChanged(focused)', '_activeChanged(active, ariaActiveAttribute)'],

  keyBindings: {
    'enter:keydown': '_asyncClick',
    'space:keydown': '_spaceKeyDownHandler',
    'space:keyup': '_spaceKeyUpHandler'
  },

  _mouseEventRe: /^mouse/,

  _tapHandler: function _tapHandler() {
    if (this.toggles) {
      // a tap is needed to toggle the active state
      this._userActivate(!this.active);
    } else {
      this.active = false;
    }
  },

  _focusChanged: function _focusChanged(focused) {
    this._detectKeyboardFocus(focused);

    if (!focused) {
      this._setPressed(false);
    }
  },

  _detectKeyboardFocus: function _detectKeyboardFocus(focused) {
    this._setReceivedFocusFromKeyboard(!this.pointerDown && focused);
  },

  // to emulate native checkbox, (de-)activations from a user interaction fire
  // 'change' events
  _userActivate: function _userActivate(active) {
    if (this.active !== active) {
      this.active = active;
      this.fire('change');
    }
  },

  _downHandler: function _downHandler(event) {
    this._setPointerDown(true);
    this._setPressed(true);
    this._setReceivedFocusFromKeyboard(false);
  },

  _upHandler: function _upHandler() {
    this._setPointerDown(false);
    this._setPressed(false);
  },

  /**
   * @param {!KeyboardEvent} event .
   */
  _spaceKeyDownHandler: function _spaceKeyDownHandler(event) {
    var keyboardEvent = event.detail.keyboardEvent;
    var target = Polymer.dom(keyboardEvent).localTarget;

    // Ignore the event if this is coming from a focused light child, since that
    // element will deal with it.
    if (this.isLightDescendant( /** @type {Node} */target)) return;

    keyboardEvent.preventDefault();
    keyboardEvent.stopImmediatePropagation();
    this._setPressed(true);
  },

  /**
   * @param {!KeyboardEvent} event .
   */
  _spaceKeyUpHandler: function _spaceKeyUpHandler(event) {
    var keyboardEvent = event.detail.keyboardEvent;
    var target = Polymer.dom(keyboardEvent).localTarget;

    // Ignore the event if this is coming from a focused light child, since that
    // element will deal with it.
    if (this.isLightDescendant( /** @type {Node} */target)) return;

    if (this.pressed) {
      this._asyncClick();
    }
    this._setPressed(false);
  },

  // trigger click asynchronously, the asynchrony is useful to allow one
  // event handler to unwind before triggering another event
  _asyncClick: function _asyncClick() {
    this.async(function () {
      this.click();
    }, 1);
  },

  // any of these changes are considered a change to button state

  _pressedChanged: function _pressedChanged(pressed) {
    this._changedButtonState();
  },

  _ariaActiveAttributeChanged: function _ariaActiveAttributeChanged(value, oldValue) {
    if (oldValue && oldValue != value && this.hasAttribute(oldValue)) {
      this.removeAttribute(oldValue);
    }
  },

  _activeChanged: function _activeChanged(active, ariaActiveAttribute) {
    if (this.toggles) {
      this.setAttribute(this.ariaActiveAttribute, active ? 'true' : 'false');
    } else {
      this.removeAttribute(this.ariaActiveAttribute);
    }
    this._changedButtonState();
  },

  _controlStateChanged: function _controlStateChanged() {
    if (this.disabled) {
      this._setPressed(false);
    } else {
      this._changedButtonState();
    }
  },

  // provide hook for follow-on behaviors to react to button-state

  _changedButtonState: function _changedButtonState() {
    if (this._buttonStateChanged) {
      this._buttonStateChanged(); // abstract
    }
  }

};

/** @polymerBehavior */
Polymer.IronButtonState = [Polymer.IronA11yKeysBehavior, Polymer.IronButtonStateImpl];

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

var RegisterHtmlTemplate = __webpack_require__(2);

RegisterHtmlTemplate.toBody("<custom-style> <style is=custom-style>html{--google-red-100:#f4c7c3;--google-red-300:#e67c73;--google-red-500:#db4437;--google-red-700:#c53929;--google-blue-100:#c6dafc;--google-blue-300:#7baaf7;--google-blue-500:#4285f4;--google-blue-700:#3367d6;--google-green-100:#b7e1cd;--google-green-300:#57bb8a;--google-green-500:#0f9d58;--google-green-700:#0b8043;--google-yellow-100:#fce8b2;--google-yellow-300:#f7cb4d;--google-yellow-500:#f4b400;--google-yellow-700:#f09300;--google-grey-100:#f5f5f5;--google-grey-300:#e0e0e0;--google-grey-500:#9e9e9e;--google-grey-700:#616161;--paper-red-50:#ffebee;--paper-red-100:#ffcdd2;--paper-red-200:#ef9a9a;--paper-red-300:#e57373;--paper-red-400:#ef5350;--paper-red-500:#f44336;--paper-red-600:#e53935;--paper-red-700:#d32f2f;--paper-red-800:#c62828;--paper-red-900:#b71c1c;--paper-red-a100:#ff8a80;--paper-red-a200:#ff5252;--paper-red-a400:#ff1744;--paper-red-a700:#d50000;--paper-pink-50:#fce4ec;--paper-pink-100:#f8bbd0;--paper-pink-200:#f48fb1;--paper-pink-300:#f06292;--paper-pink-400:#ec407a;--paper-pink-500:#e91e63;--paper-pink-600:#d81b60;--paper-pink-700:#c2185b;--paper-pink-800:#ad1457;--paper-pink-900:#880e4f;--paper-pink-a100:#ff80ab;--paper-pink-a200:#ff4081;--paper-pink-a400:#f50057;--paper-pink-a700:#c51162;--paper-purple-50:#f3e5f5;--paper-purple-100:#e1bee7;--paper-purple-200:#ce93d8;--paper-purple-300:#ba68c8;--paper-purple-400:#ab47bc;--paper-purple-500:#9c27b0;--paper-purple-600:#8e24aa;--paper-purple-700:#7b1fa2;--paper-purple-800:#6a1b9a;--paper-purple-900:#4a148c;--paper-purple-a100:#ea80fc;--paper-purple-a200:#e040fb;--paper-purple-a400:#d500f9;--paper-purple-a700:#aa00ff;--paper-deep-purple-50:#ede7f6;--paper-deep-purple-100:#d1c4e9;--paper-deep-purple-200:#b39ddb;--paper-deep-purple-300:#9575cd;--paper-deep-purple-400:#7e57c2;--paper-deep-purple-500:#673ab7;--paper-deep-purple-600:#5e35b1;--paper-deep-purple-700:#512da8;--paper-deep-purple-800:#4527a0;--paper-deep-purple-900:#311b92;--paper-deep-purple-a100:#b388ff;--paper-deep-purple-a200:#7c4dff;--paper-deep-purple-a400:#651fff;--paper-deep-purple-a700:#6200ea;--paper-indigo-50:#e8eaf6;--paper-indigo-100:#c5cae9;--paper-indigo-200:#9fa8da;--paper-indigo-300:#7986cb;--paper-indigo-400:#5c6bc0;--paper-indigo-500:#3f51b5;--paper-indigo-600:#3949ab;--paper-indigo-700:#303f9f;--paper-indigo-800:#283593;--paper-indigo-900:#1a237e;--paper-indigo-a100:#8c9eff;--paper-indigo-a200:#536dfe;--paper-indigo-a400:#3d5afe;--paper-indigo-a700:#304ffe;--paper-blue-50:#e3f2fd;--paper-blue-100:#bbdefb;--paper-blue-200:#90caf9;--paper-blue-300:#64b5f6;--paper-blue-400:#42a5f5;--paper-blue-500:#2196f3;--paper-blue-600:#1e88e5;--paper-blue-700:#1976d2;--paper-blue-800:#1565c0;--paper-blue-900:#0d47a1;--paper-blue-a100:#82b1ff;--paper-blue-a200:#448aff;--paper-blue-a400:#2979ff;--paper-blue-a700:#2962ff;--paper-light-blue-50:#e1f5fe;--paper-light-blue-100:#b3e5fc;--paper-light-blue-200:#81d4fa;--paper-light-blue-300:#4fc3f7;--paper-light-blue-400:#29b6f6;--paper-light-blue-500:#03a9f4;--paper-light-blue-600:#039be5;--paper-light-blue-700:#0288d1;--paper-light-blue-800:#0277bd;--paper-light-blue-900:#01579b;--paper-light-blue-a100:#80d8ff;--paper-light-blue-a200:#40c4ff;--paper-light-blue-a400:#00b0ff;--paper-light-blue-a700:#0091ea;--paper-cyan-50:#e0f7fa;--paper-cyan-100:#b2ebf2;--paper-cyan-200:#80deea;--paper-cyan-300:#4dd0e1;--paper-cyan-400:#26c6da;--paper-cyan-500:#00bcd4;--paper-cyan-600:#00acc1;--paper-cyan-700:#0097a7;--paper-cyan-800:#00838f;--paper-cyan-900:#006064;--paper-cyan-a100:#84ffff;--paper-cyan-a200:#18ffff;--paper-cyan-a400:#00e5ff;--paper-cyan-a700:#00b8d4;--paper-teal-50:#e0f2f1;--paper-teal-100:#b2dfdb;--paper-teal-200:#80cbc4;--paper-teal-300:#4db6ac;--paper-teal-400:#26a69a;--paper-teal-500:#009688;--paper-teal-600:#00897b;--paper-teal-700:#00796b;--paper-teal-800:#00695c;--paper-teal-900:#004d40;--paper-teal-a100:#a7ffeb;--paper-teal-a200:#64ffda;--paper-teal-a400:#1de9b6;--paper-teal-a700:#00bfa5;--paper-green-50:#e8f5e9;--paper-green-100:#c8e6c9;--paper-green-200:#a5d6a7;--paper-green-300:#81c784;--paper-green-400:#66bb6a;--paper-green-500:#4caf50;--paper-green-600:#43a047;--paper-green-700:#388e3c;--paper-green-800:#2e7d32;--paper-green-900:#1b5e20;--paper-green-a100:#b9f6ca;--paper-green-a200:#69f0ae;--paper-green-a400:#00e676;--paper-green-a700:#00c853;--paper-light-green-50:#f1f8e9;--paper-light-green-100:#dcedc8;--paper-light-green-200:#c5e1a5;--paper-light-green-300:#aed581;--paper-light-green-400:#9ccc65;--paper-light-green-500:#8bc34a;--paper-light-green-600:#7cb342;--paper-light-green-700:#689f38;--paper-light-green-800:#558b2f;--paper-light-green-900:#33691e;--paper-light-green-a100:#ccff90;--paper-light-green-a200:#b2ff59;--paper-light-green-a400:#76ff03;--paper-light-green-a700:#64dd17;--paper-lime-50:#f9fbe7;--paper-lime-100:#f0f4c3;--paper-lime-200:#e6ee9c;--paper-lime-300:#dce775;--paper-lime-400:#d4e157;--paper-lime-500:#cddc39;--paper-lime-600:#c0ca33;--paper-lime-700:#afb42b;--paper-lime-800:#9e9d24;--paper-lime-900:#827717;--paper-lime-a100:#f4ff81;--paper-lime-a200:#eeff41;--paper-lime-a400:#c6ff00;--paper-lime-a700:#aeea00;--paper-yellow-50:#fffde7;--paper-yellow-100:#fff9c4;--paper-yellow-200:#fff59d;--paper-yellow-300:#fff176;--paper-yellow-400:#ffee58;--paper-yellow-500:#ffeb3b;--paper-yellow-600:#fdd835;--paper-yellow-700:#fbc02d;--paper-yellow-800:#f9a825;--paper-yellow-900:#f57f17;--paper-yellow-a100:#ffff8d;--paper-yellow-a200:#ffff00;--paper-yellow-a400:#ffea00;--paper-yellow-a700:#ffd600;--paper-amber-50:#fff8e1;--paper-amber-100:#ffecb3;--paper-amber-200:#ffe082;--paper-amber-300:#ffd54f;--paper-amber-400:#ffca28;--paper-amber-500:#ffc107;--paper-amber-600:#ffb300;--paper-amber-700:#ffa000;--paper-amber-800:#ff8f00;--paper-amber-900:#ff6f00;--paper-amber-a100:#ffe57f;--paper-amber-a200:#ffd740;--paper-amber-a400:#ffc400;--paper-amber-a700:#ffab00;--paper-orange-50:#fff3e0;--paper-orange-100:#ffe0b2;--paper-orange-200:#ffcc80;--paper-orange-300:#ffb74d;--paper-orange-400:#ffa726;--paper-orange-500:#ff9800;--paper-orange-600:#fb8c00;--paper-orange-700:#f57c00;--paper-orange-800:#ef6c00;--paper-orange-900:#e65100;--paper-orange-a100:#ffd180;--paper-orange-a200:#ffab40;--paper-orange-a400:#ff9100;--paper-orange-a700:#ff6500;--paper-deep-orange-50:#fbe9e7;--paper-deep-orange-100:#ffccbc;--paper-deep-orange-200:#ffab91;--paper-deep-orange-300:#ff8a65;--paper-deep-orange-400:#ff7043;--paper-deep-orange-500:#ff5722;--paper-deep-orange-600:#f4511e;--paper-deep-orange-700:#e64a19;--paper-deep-orange-800:#d84315;--paper-deep-orange-900:#bf360c;--paper-deep-orange-a100:#ff9e80;--paper-deep-orange-a200:#ff6e40;--paper-deep-orange-a400:#ff3d00;--paper-deep-orange-a700:#dd2c00;--paper-brown-50:#efebe9;--paper-brown-100:#d7ccc8;--paper-brown-200:#bcaaa4;--paper-brown-300:#a1887f;--paper-brown-400:#8d6e63;--paper-brown-500:#795548;--paper-brown-600:#6d4c41;--paper-brown-700:#5d4037;--paper-brown-800:#4e342e;--paper-brown-900:#3e2723;--paper-grey-50:#fafafa;--paper-grey-100:#f5f5f5;--paper-grey-200:#eeeeee;--paper-grey-300:#e0e0e0;--paper-grey-400:#bdbdbd;--paper-grey-500:#9e9e9e;--paper-grey-600:#757575;--paper-grey-700:#616161;--paper-grey-800:#424242;--paper-grey-900:#212121;--paper-blue-grey-50:#eceff1;--paper-blue-grey-100:#cfd8dc;--paper-blue-grey-200:#b0bec5;--paper-blue-grey-300:#90a4ae;--paper-blue-grey-400:#78909c;--paper-blue-grey-500:#607d8b;--paper-blue-grey-600:#546e7a;--paper-blue-grey-700:#455a64;--paper-blue-grey-800:#37474f;--paper-blue-grey-900:#263238;--dark-divider-opacity:0.12;--dark-disabled-opacity:0.38;--dark-secondary-opacity:0.54;--dark-primary-opacity:0.87;--light-divider-opacity:0.12;--light-disabled-opacity:0.3;--light-secondary-opacity:0.7;--light-primary-opacity:1.0}</style> </custom-style>");

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(40);


/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

__webpack_require__(6);

__webpack_require__(45);

__webpack_require__(65);

__webpack_require__(67);

__webpack_require__(69);

__webpack_require__(70);

__webpack_require__(74);

__webpack_require__(75);

__webpack_require__(79);

__webpack_require__(80);

__webpack_require__(82);

__webpack_require__(31);

__webpack_require__(86);

var RegisterHtmlTemplate = __webpack_require__(2);

RegisterHtmlTemplate.register("<dom-module id=luding-app> <template> <style>:host{--app-primary-color:#3D2814;--app-secondary-color:#FF3C3C;display:block}app-drawer-layout:not([narrow]) [drawer-toggle]{display:none}app-header{color:#fff;background-color:var(--app-primary-color)}app-header paper-icon-button{--paper-icon-button-ink-color:white}.drawer-list{margin:0 20px}.drawer-list a{display:block;padding:0 16px;text-decoration:none;color:var(--app-secondary-color);line-height:40px}.drawer-list a.iron-selected{color:#000;font-weight:700}</style> <app-location route={{route}} url-space-regex=^[[rootPath]]></app-location> <app-route route={{route}} pattern=[[rootPath]]:page data={{routeData}} tail={{subroute}}></app-route> <app-drawer-layout fullbleed=\"\"> <app-drawer id=drawer slot=drawer> <app-toolbar>Luding.org</app-toolbar> <iron-selector selected=[[page]] attr-for-selected=name class=drawer-list role=navigation> <a name=view2 href$=[[rootPath]]view2>News</a> <a name=games href$=[[rootPath]]games>Spiele</a> <a name=authors href$=[[rootPath]]authors>Autoren</a> <a name=publishers href$=[[rootPath]]publishers>Verlage</a> <a name=designers href$=[[rootPath]]designers>Designer</a> <a name=reviews href$=[[rootPath]]reviews>Rezensenionen</a> <a name=view3 href$=[[rootPath]]view3>Preise</a> <hr> <a name=view3 href$=[[rootPath]]view3>Sammlung</a> <a name=view3 href$=[[rootPath]]view3>Settings</a> </iron-selector> </app-drawer> <app-header-layout has-scrolling-region=\"\"> <app-header slot=header condenses=\"\" reveals=\"\" effects=waterfall> <app-toolbar> <paper-icon-button icon=my-icons:menu drawer-toggle=\"\"></paper-icon-button> <div main-title=\"\">{{pagetitle}}</div> </app-toolbar> </app-header> <iron-pages selected=[[page]] attr-for-selected=name fallback-selection=view404 role=main> <games-list name=games></games-list> <my-view2 name=view2></my-view2> <authors-list name=authors></authors-list> <publishers-list name=publishers></publishers-list> <my-view3 name=view3></my-view3> <my-view404 name=view404></my-view404> </iron-pages> </app-header-layout> </app-drawer-layout> </template> </dom-module>");

var MyApp = function (_Polymer$Element) {
  _inherits(MyApp, _Polymer$Element);

  _createClass(MyApp, null, [{
    key: 'is',
    get: function get() {
      return 'luding-app';
    }
  }, {
    key: 'properties',
    get: function get() {
      return {
        page: {
          type: String,
          reflectToAttribute: true,
          observer: '_pageChanged'
        },
        pagetitle: {
          type: String,
          value: 'die Brettspieldatenbank'
        },
        routeData: Object,
        subroute: String,
        rootPath: {
          type: String,
          value: '/'
        },
        lazyPages: {
          type: Object,
          value: {
            view2: function view2() {
              __webpack_require__.e/* import() */(4).then(__webpack_require__.bind(null, 87));
            },
            games: function games() {
              __webpack_require__.e/* import() */(0).then(__webpack_require__.bind(null, 88));
            },
            authors: function authors() {
              __webpack_require__.e/* import() */(2).then(__webpack_require__.bind(null, 89));
            },
            publishers: function publishers() {
              __webpack_require__.e/* import() */(1).then(__webpack_require__.bind(null, 90));
            },
            view3: function view3() {
              __webpack_require__.e/* import() */(3).then(__webpack_require__.bind(null, 91));
            },
            view404: function view404() {
              __webpack_require__.e/* import() */(5).then(__webpack_require__.bind(null, 92));
            }
          }
        }
      };
    }
  }, {
    key: 'observers',
    get: function get() {
      return ['_routePageChanged(routeData.page)'];
    }
  }]);

  function MyApp() {
    _classCallCheck(this, MyApp);

    return _possibleConstructorReturn(this, (MyApp.__proto__ || Object.getPrototypeOf(MyApp)).call(this));
  }

  _createClass(MyApp, [{
    key: '_routePageChanged',
    value: function _routePageChanged(page) {
      // Polymer 2.0 will call with `undefined` on initialization.
      // Ignore until we are properly called with a string.
      if (page === undefined) {
        return;
      }

      // If no page was found in the route data, page will be an empty string.
      // Deault to 'view1' in that case.
      this.page = page || 'view1';

      // Close a non-persistent drawer when the page & route are changed.
      if (!this.$.drawer.persistent) {
        this.$.drawer.close();
      }
    }
  }, {
    key: '_pageChanged',
    value: function _pageChanged(page) {
      if (this.lazyPages[page]) {
        this.lazyPages[page]();
      } else {
        this._showPage404();
      }
    }
  }, {
    key: '_showPage404',
    value: function _showPage404() {
      this.page = 'view404';
    }
  }]);

  return MyApp;
}(Polymer.Element);

window.customElements.define(MyApp.is, MyApp);

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

__webpack_require__(1);

__webpack_require__(7);

(function () {
  'use strict';

  var modules = {};
  var lcModules = {};
  function findModule(id) {
    return modules[id] || lcModules[id.toLowerCase()];
  }

  function styleOutsideTemplateCheck(inst) {
    if (inst.querySelector('style')) {
      console.warn('dom-module %s has style outside template', inst.id);
    }
  }

  /**
   * The `dom-module` element registers the dom it contains to the name given
   * by the module's id attribute. It provides a unified database of dom
   * accessible via its static `import` API.
   *
   * A key use case of `dom-module` is for providing custom element `<template>`s
   * via HTML imports that are parsed by the native HTML parser, that can be
   * relocated during a bundling pass and still looked up by `id`.
   *
   * Example:
   *
   *     <dom-module id="foo">
   *       <img src="stuff.png">
   *     </dom-module>
   *
   * Then in code in some other location that cannot access the dom-module above
   *
   *     let img = document.createElement('dom-module').import('foo', 'img');
   *
   * @customElement
   * @extends HTMLElement
   * @memberof Polymer
   * @summary Custom element that provides a registry of relocatable DOM content
   *   by `id` that is agnostic to bundling.
   * @unrestricted
   */

  var DomModule = function (_HTMLElement) {
    _inherits(DomModule, _HTMLElement);

    function DomModule() {
      _classCallCheck(this, DomModule);

      return _possibleConstructorReturn(this, (DomModule.__proto__ || Object.getPrototypeOf(DomModule)).apply(this, arguments));
    }

    _createClass(DomModule, [{
      key: 'attributeChangedCallback',
      value: function attributeChangedCallback(name, old, value) {
        if (old !== value) {
          this.register();
        }
      }

      /**
       * The absolute URL of the original location of this `dom-module`.
       *
       * This value will differ from this element's `ownerDocument` in the
       * following ways:
       * - Takes into account any `assetpath` attribute added during bundling
       *   to indicate the original location relative to the bundled location
       * - Uses the HTMLImports polyfill's `importForElement` API to ensure
       *   the path is relative to the import document's location since
       *   `ownerDocument` is not currently polyfilled
       */

    }, {
      key: 'register',


      /**
       * Registers the dom-module at a given id. This method should only be called
       * when a dom-module is imperatively created. For
       * example, `document.createElement('dom-module').register('foo')`.
       * @param {string=} id The id at which to register the dom-module.
       */
      value: function register(id) {
        id = id || this.id;
        if (id) {
          this.id = id;
          // store id separate from lowercased id so that
          // in all cases mixedCase id will stored distinctly
          // and lowercase version is a fallback
          modules[id] = this;
          lcModules[id.toLowerCase()] = this;
          styleOutsideTemplateCheck(this);
        }
      }
    }, {
      key: 'assetpath',
      get: function get() {
        // Don't override existing assetpath.
        if (!this.__assetpath) {
          // note: assetpath set via an attribute must be relative to this
          // element's location; accomodate polyfilled HTMLImports
          var owner = window.HTMLImports && HTMLImports.importForElement ? HTMLImports.importForElement(this) || document : this.ownerDocument;
          var url = Polymer.ResolveUrl.resolveUrl(this.getAttribute('assetpath') || '', owner.baseURI);
          this.__assetpath = Polymer.ResolveUrl.pathFromUrl(url);
        }
        return this.__assetpath;
      }
    }], [{
      key: 'import',


      /**
       * Retrieves the element specified by the css `selector` in the module
       * registered by `id`. For example, this.import('foo', 'img');
       * @param {string} id The id of the dom-module in which to search.
       * @param {string=} selector The css selector by which to find the element.
       * @return {Element} Returns the element which matches `selector` in the
       * module registered at the specified `id`.
       */
      value: function _import(id, selector) {
        if (id) {
          var m = findModule(id);
          if (m && selector) {
            return m.querySelector(selector);
          }
          return m;
        }
        return null;
      }
    }, {
      key: 'observedAttributes',
      get: function get() {
        return ['id'];
      }
    }]);

    return DomModule;
  }(HTMLElement);

  DomModule.prototype['modules'] = modules;

  customElements.define('dom-module', DomModule);

  // export
  Polymer.DomModule = DomModule;
})();

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(1);

(function () {
  'use strict';

  /**
   * Module with utilities for manipulating structured data path strings.
   *
   * @namespace
   * @memberof Polymer
   * @summary Module with utilities for manipulating structured data path strings.
   */

  var Path = {

    /**
     * Returns true if the given string is a structured data path (has dots).
     *
     * Example:
     *
     * ```
     * Polymer.Path.isPath('foo.bar.baz') // true
     * Polymer.Path.isPath('foo')         // false
     * ```
     *
     * @memberof Polymer.Path
     * @param {string} path Path string
     * @return {boolean} True if the string contained one or more dots
     */
    isPath: function isPath(path) {
      return path.indexOf('.') >= 0;
    },

    /**
     * Returns the root property name for the given path.
     *
     * Example:
     *
     * ```
     * Polymer.Path.root('foo.bar.baz') // 'foo'
     * Polymer.Path.root('foo')         // 'foo'
     * ```
     *
     * @memberof Polymer.Path
     * @param {string} path Path string
     * @return {string} Root property name
     */
    root: function root(path) {
      var dotIndex = path.indexOf('.');
      if (dotIndex === -1) {
        return path;
      }
      return path.slice(0, dotIndex);
    },

    /**
     * Given `base` is `foo.bar`, `foo` is an ancestor, `foo.bar` is not
     * Returns true if the given path is an ancestor of the base path.
     *
     * Example:
     *
     * ```
     * Polymer.Path.isAncestor('foo.bar', 'foo')         // true
     * Polymer.Path.isAncestor('foo.bar', 'foo.bar')     // false
     * Polymer.Path.isAncestor('foo.bar', 'foo.bar.baz') // false
     * ```
     *
     * @memberof Polymer.Path
     * @param {string} base Path string to test against.
     * @param {string} path Path string to test.
     * @return {boolean} True if `path` is an ancestor of `base`.
     */
    isAncestor: function isAncestor(base, path) {
      //     base.startsWith(path + '.');
      return base.indexOf(path + '.') === 0;
    },

    /**
     * Given `base` is `foo.bar`, `foo.bar.baz` is an descendant
     *
     * Example:
     *
     * ```
     * Polymer.Path.isDescendant('foo.bar', 'foo.bar.baz') // true
     * Polymer.Path.isDescendant('foo.bar', 'foo.bar')     // false
     * Polymer.Path.isDescendant('foo.bar', 'foo')         // false
     * ```
     *
     * @memberof Polymer.Path
     * @param {string} base Path string to test against.
     * @param {string} path Path string to test.
     * @return {boolean} True if `path` is a descendant of `base`.
     */
    isDescendant: function isDescendant(base, path) {
      //     path.startsWith(base + '.');
      return path.indexOf(base + '.') === 0;
    },

    /**
     * Replaces a previous base path with a new base path, preserving the
     * remainder of the path.
     *
     * User must ensure `path` has a prefix of `base`.
     *
     * Example:
     *
     * ```
     * Polymer.Path.translate('foo.bar', 'zot' 'foo.bar.baz') // 'zot.baz'
     * ```
     *
     * @memberof Polymer.Path
     * @param {string} base Current base string to remove
     * @param {string} newBase New base string to replace with
     * @param {string} path Path to translate
     * @return {string} Translated string
     */
    translate: function translate(base, newBase, path) {
      return newBase + path.slice(base.length);
    },

    /**
     * @param {string} base Path string to test against
     * @param {string} path Path string to test
     * @return {boolean} True if `path` is equal to `base`
     * @this {Path}
     */
    matches: function matches(base, path) {
      return base === path || this.isAncestor(base, path) || this.isDescendant(base, path);
    },

    /**
     * Converts array-based paths to flattened path.  String-based paths
     * are returned as-is.
     *
     * Example:
     *
     * ```
     * Polymer.Path.normalize(['foo.bar', 0, 'baz'])  // 'foo.bar.0.baz'
     * Polymer.Path.normalize('foo.bar.0.baz')        // 'foo.bar.0.baz'
     * ```
     *
     * @memberof Polymer.Path
     * @param {string | !Array<string|number>} path Input path
     * @return {string} Flattened path
     */
    normalize: function normalize(path) {
      if (Array.isArray(path)) {
        var parts = [];
        for (var i = 0; i < path.length; i++) {
          var args = path[i].toString().split('.');
          for (var j = 0; j < args.length; j++) {
            parts.push(args[j]);
          }
        }
        return parts.join('.');
      } else {
        return path;
      }
    },

    /**
     * Splits a path into an array of property names. Accepts either arrays
     * of path parts or strings.
     *
     * Example:
     *
     * ```
     * Polymer.Path.split(['foo.bar', 0, 'baz'])  // ['foo', 'bar', '0', 'baz']
     * Polymer.Path.split('foo.bar.0.baz')        // ['foo', 'bar', '0', 'baz']
     * ```
     *
     * @memberof Polymer.Path
     * @param {string | !Array<string|number>} path Input path
     * @return {!Array<string>} Array of path parts
     * @this {Path}
     * @suppress {checkTypes}
     */
    split: function split(path) {
      if (Array.isArray(path)) {
        return this.normalize(path).split('.');
      }
      return path.toString().split('.');
    },

    /**
     * Reads a value from a path.  If any sub-property in the path is `undefined`,
     * this method returns `undefined` (will never throw.
     *
     * @memberof Polymer.Path
     * @param {Object} root Object from which to dereference path from
     * @param {string | !Array<string|number>} path Path to read
     * @param {Object=} info If an object is provided to `info`, the normalized
     *  (flattened) path will be set to `info.path`.
     * @return {*} Value at path, or `undefined` if the path could not be
     *  fully dereferenced.
     * @this {Path}
     */
    get: function get(root, path, info) {
      var prop = root;
      var parts = this.split(path);
      // Loop over path parts[0..n-1] and dereference
      for (var i = 0; i < parts.length; i++) {
        if (!prop) {
          return;
        }
        var part = parts[i];
        prop = prop[part];
      }
      if (info) {
        info.path = parts.join('.');
      }
      return prop;
    },

    /**
     * Sets a value to a path.  If any sub-property in the path is `undefined`,
     * this method will no-op.
     *
     * @memberof Polymer.Path
     * @param {Object} root Object from which to dereference path from
     * @param {string | !Array<string|number>} path Path to set
     * @param {*} value Value to set to path
     * @return {string | undefined} The normalized version of the input path
     * @this {Path}
     */
    set: function set(root, path, value) {
      var prop = root;
      var parts = this.split(path);
      var last = parts[parts.length - 1];
      if (parts.length > 1) {
        // Loop over path parts[0..n-2] and dereference
        for (var i = 0; i < parts.length - 1; i++) {
          var part = parts[i];
          prop = prop[part];
          if (!prop) {
            return;
          }
        }
        // Set value to object at end of path
        prop[last] = value;
      } else {
        // Simple property set
        prop[path] = value;
      }
      return parts.join('.');
    }

  };

  /**
   * Returns true if the given string is a structured data path (has dots).
   *
   * This function is deprecated.  Use `Polymer.Path.isPath` instead.
   *
   * Example:
   *
   * ```
   * Polymer.Path.isDeep('foo.bar.baz') // true
   * Polymer.Path.isDeep('foo')         // false
   * ```
   *
   * @deprecated
   * @memberof Polymer.Path
   * @param {string} path Path string
   * @return {boolean} True if the string contained one or more dots
   */
  Path.isDeep = Path.isPath;

  Polymer.Path = Path;
})();

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

__webpack_require__(1);

__webpack_require__(3);

__webpack_require__(10);

__webpack_require__(8);

(function () {

  'use strict';

  var caseMap = Polymer.CaseMap;

  var microtask = Polymer.Async.microTask;

  // Save map of native properties; this forms a blacklist or properties
  // that won't have their values "saved" by `saveAccessorValue`, since
  // reading from an HTMLElement accessor from the context of a prototype throws
  var nativeProperties = {};
  var proto = HTMLElement.prototype;
  while (proto) {
    var props = Object.getOwnPropertyNames(proto);
    for (var i = 0; i < props.length; i++) {
      nativeProperties[props[i]] = true;
    }
    proto = Object.getPrototypeOf(proto);
  }

  /**
   * Used to save the value of a property that will be overridden with
   * an accessor. If the `model` is a prototype, the values will be saved
   * in `__dataProto`, and it's up to the user (or downstream mixin) to
   * decide how/when to set these values back into the accessors.
   * If `model` is already an instance (it has a `__data` property), then
   * the value will be set as a pending property, meaning the user should
   * call `_invalidateProperties` or `_flushProperties` to take effect
   *
   * @param {Object} model Prototype or instance
   * @param {string} property Name of property
   * @private
   */
  function saveAccessorValue(model, property) {
    // Don't read/store value for any native properties since they could throw
    if (!nativeProperties[property]) {
      var value = model[property];
      if (value !== undefined) {
        if (model.__data) {
          // Adding accessor to instance; update the property
          // It is the user's responsibility to call _flushProperties
          model._setPendingProperty(property, value);
        } else {
          // Adding accessor to proto; save proto's value for instance-time use
          if (!model.__dataProto) {
            model.__dataProto = {};
          } else if (!model.hasOwnProperty(JSCompiler_renameProperty('__dataProto', model))) {
            model.__dataProto = Object.create(model.__dataProto);
          }
          model.__dataProto[property] = value;
        }
      }
    }
  }

  /**
   * Element class mixin that provides basic meta-programming for creating one
   * or more property accessors (getter/setter pair) that enqueue an async
   * (batched) `_propertiesChanged` callback.
   *
   * For basic usage of this mixin, simply declare attributes to observe via
   * the standard `static get observedAttributes()`, implement `_propertiesChanged`
   * on the class, and then call `MyClass.createPropertiesForAttributes()` once
   * on the class to generate property accessors for each observed attribute
   * prior to instancing.  Last, call `this._flushProperties()` once to enable
   * the accessors.
   *
   * Any `observedAttributes` will automatically be
   * deserialized via `attributeChangedCallback` and set to the associated
   * property using `dash-case`-to-`camelCase` convention.
   *
   * @mixinFunction
   * @polymer
   * @memberof Polymer
   * @summary Element class mixin for reacting to property changes from
   *   generated property accessors.
   */
  Polymer.PropertyAccessors = Polymer.dedupingMixin(function (superClass) {

    /**
     * @polymer
     * @mixinClass
     * @implements {Polymer_PropertyAccessors}
     * @extends HTMLElement
     * @unrestricted
     */
    var PropertyAccessors = function (_superClass) {
      _inherits(PropertyAccessors, _superClass);

      _createClass(PropertyAccessors, null, [{
        key: 'createPropertiesForAttributes',


        /**
         * Generates property accessors for all attributes in the standard
         * static `observedAttributes` array.
         *
         * Attribute names are mapped to property names using the `dash-case` to
         * `camelCase` convention
         *
         */
        value: function createPropertiesForAttributes() {
          var a$ = this.observedAttributes;
          for (var _i = 0; _i < a$.length; _i++) {
            this.prototype._createPropertyAccessor(caseMap.dashToCamelCase(a$[_i]));
          }
        }
      }]);

      function PropertyAccessors() {
        _classCallCheck(this, PropertyAccessors);

        /** @type {boolean} */
        var _this = _possibleConstructorReturn(this, (PropertyAccessors.__proto__ || Object.getPrototypeOf(PropertyAccessors)).call(this));

        _this.__serializing;
        /** @type {number} */
        _this.__dataCounter;
        /** @type {boolean} */
        _this.__dataEnabled;
        /** @type {boolean} */
        _this.__dataReady;
        /** @type {boolean} */
        _this.__dataInvalid;
        /** @type {!Object} */
        _this.__data;
        /** @type {Object} */
        _this.__dataPending;
        /** @type {Object} */
        _this.__dataOld;
        /** @type {Object} */
        _this.__dataProto;
        /** @type {Object} */
        _this.__dataHasAccessor;
        /** @type {Object} */
        _this.__dataInstanceProps;
        _this._initializeProperties();
        return _this;
      }

      /**
       * Implements native Custom Elements `attributeChangedCallback` to
       * set an attribute value to a property via `_attributeToProperty`.
       *
       * @param {string} name Name of attribute that changed
       * @param {?string} old Old attribute value
       * @param {?string} value New attribute value
       */


      _createClass(PropertyAccessors, [{
        key: 'attributeChangedCallback',
        value: function attributeChangedCallback(name, old, value) {
          if (old !== value) {
            this._attributeToProperty(name, value);
          }
        }

        /**
         * Initializes the local storage for property accessors.
         *
         * Provided as an override point for performing any setup work prior
         * to initializing the property accessor system.
         *
         * @protected
         */

      }, {
        key: '_initializeProperties',
        value: function _initializeProperties() {
          this.__serializing = false;
          this.__dataCounter = 0;
          this.__dataEnabled = false;
          this.__dataReady = false;
          this.__dataInvalid = false;
          this.__data = {};
          this.__dataPending = null;
          this.__dataOld = null;
          if (this.__dataProto) {
            this._initializeProtoProperties(this.__dataProto);
            this.__dataProto = null;
          }
          // Capture instance properties; these will be set into accessors
          // during first flush. Don't set them here, since we want
          // these to overwrite defaults/constructor assignments
          for (var p in this.__dataHasAccessor) {
            if (this.hasOwnProperty(p)) {
              this.__dataInstanceProps = this.__dataInstanceProps || {};
              this.__dataInstanceProps[p] = this[p];
              delete this[p];
            }
          }
        }

        /**
         * Called at instance time with bag of properties that were overwritten
         * by accessors on the prototype when accessors were created.
         *
         * The default implementation sets these properties back into the
         * setter at instance time.  This method is provided as an override
         * point for customizing or providing more efficient initialization.
         *
         * @param {Object} props Bag of property values that were overwritten
         *   when creating property accessors.
         * @protected
         */

      }, {
        key: '_initializeProtoProperties',
        value: function _initializeProtoProperties(props) {
          for (var p in props) {
            this._setProperty(p, props[p]);
          }
        }

        /**
         * Called at ready time with bag of instance properties that overwrote
         * accessors when the element upgraded.
         *
         * The default implementation sets these properties back into the
         * setter at ready time.  This method is provided as an override
         * point for customizing or providing more efficient initialization.
         *
         * @param {Object} props Bag of property values that were overwritten
         *   when creating property accessors.
         * @protected
         */

      }, {
        key: '_initializeInstanceProperties',
        value: function _initializeInstanceProperties(props) {
          Object.assign(this, props);
        }

        /**
         * Ensures the element has the given attribute. If it does not,
         * assigns the given value to the attribute.
         *
         *
         * @param {string} attribute Name of attribute to ensure is set.
         * @param {string} value of the attribute.
         */

      }, {
        key: '_ensureAttribute',
        value: function _ensureAttribute(attribute, value) {
          if (!this.hasAttribute(attribute)) {
            this._valueToNodeAttribute(this, value, attribute);
          }
        }

        /**
         * Deserializes an attribute to its associated property.
         *
         * This method calls the `_deserializeValue` method to convert the string to
         * a typed value.
         *
         * @param {string} attribute Name of attribute to deserialize.
         * @param {?string} value of the attribute.
         * @param {*=} type type to deserialize to.
         */

      }, {
        key: '_attributeToProperty',
        value: function _attributeToProperty(attribute, value, type) {
          // Don't deserialize back to property if currently reflecting
          if (!this.__serializing) {
            var property = caseMap.dashToCamelCase(attribute);
            this[property] = this._deserializeValue(value, type);
          }
        }

        /**
         * Serializes a property to its associated attribute.
         *
         * @param {string} property Property name to reflect.
         * @param {string=} attribute Attribute name to reflect.
         * @param {*=} value Property value to refect.
         */

      }, {
        key: '_propertyToAttribute',
        value: function _propertyToAttribute(property, attribute, value) {
          this.__serializing = true;
          value = arguments.length < 3 ? this[property] : value;
          this._valueToNodeAttribute(this, value, attribute || caseMap.camelToDashCase(property));
          this.__serializing = false;
        }

        /**
         * Sets a typed value to an HTML attribute on a node.
         *
         * This method calls the `_serializeValue` method to convert the typed
         * value to a string.  If the `_serializeValue` method returns `undefined`,
         * the attribute will be removed (this is the default for boolean
         * type `false`).
         *
         * @param {Element} node Element to set attribute to.
         * @param {*} value Value to serialize.
         * @param {string} attribute Attribute name to serialize to.
         */

      }, {
        key: '_valueToNodeAttribute',
        value: function _valueToNodeAttribute(node, value, attribute) {
          var str = this._serializeValue(value);
          if (str === undefined) {
            node.removeAttribute(attribute);
          } else {
            node.setAttribute(attribute, str);
          }
        }

        /**
         * Converts a typed JavaScript value to a string.
         *
         * This method is called by Polymer when setting JS property values to
         * HTML attributes.  Users may override this method on Polymer element
         * prototypes to provide serialization for custom types.
         *
         * @param {*} value Property value to serialize.
         * @return {string | undefined} String serialized from the provided property value.
         */

      }, {
        key: '_serializeValue',
        value: function _serializeValue(value) {
          /* eslint-disable no-fallthrough */
          switch (typeof value === 'undefined' ? 'undefined' : _typeof(value)) {
            case 'boolean':
              return value ? '' : undefined;

            case 'object':
              if (value instanceof Date) {
                return value.toString();
              } else if (value) {
                try {
                  return JSON.stringify(value);
                } catch (x) {
                  return '';
                }
              }

            default:
              return value != null ? value.toString() : undefined;
          }
        }

        /**
         * Converts a string to a typed JavaScript value.
         *
         * This method is called by Polymer when reading HTML attribute values to
         * JS properties.  Users may override this method on Polymer element
         * prototypes to provide deserialization for custom `type`s.  Note,
         * the `type` argument is the value of the `type` field provided in the
         * `properties` configuration object for a given property, and is
         * by convention the constructor for the type to deserialize.
         *
         * Note: The return value of `undefined` is used as a sentinel value to
         * indicate the attribute should be removed.
         *
         * @param {?string} value Attribute value to deserialize.
         * @param {*=} type Type to deserialize the string to.
         * @return {*} Typed value deserialized from the provided string.
         */

      }, {
        key: '_deserializeValue',
        value: function _deserializeValue(value, type) {
          /**
           * @type {*}
           */
          var outValue = void 0;
          switch (type) {
            case Number:
              outValue = Number(value);
              break;

            case Boolean:
              outValue = value !== null;
              break;

            case Object:
              try {
                outValue = JSON.parse( /** @type string */value);
              } catch (x) {
                // allow non-JSON literals like Strings and Numbers
              }
              break;

            case Array:
              try {
                outValue = JSON.parse( /** @type string */value);
              } catch (x) {
                outValue = null;
                console.warn('Polymer::Attributes: couldn\'t decode Array as JSON: ' + value);
              }
              break;

            case Date:
              outValue = new Date(value);
              break;

            case String:
            default:
              outValue = value;
              break;
          }

          return outValue;
        }
        /* eslint-enable no-fallthrough */

        /**
         * Creates a setter/getter pair for the named property with its own
         * local storage.  The getter returns the value in the local storage,
         * and the setter calls `_setProperty`, which updates the local storage
         * for the property and enqueues a `_propertiesChanged` callback.
         *
         * This method may be called on a prototype or an instance.  Calling
         * this method may overwrite a property value that already exists on
         * the prototype/instance by creating the accessor.  When calling on
         * a prototype, any overwritten values are saved in `__dataProto`,
         * and it is up to the subclasser to decide how/when to set those
         * properties back into the accessor.  When calling on an instance,
         * the overwritten value is set via `_setPendingProperty`, and the
         * user should call `_invalidateProperties` or `_flushProperties`
         * for the values to take effect.
         *
         * @param {string} property Name of the property
         * @param {boolean=} readOnly When true, no setter is created; the
         *   protected `_setProperty` function must be used to set the property
         * @protected
         */

      }, {
        key: '_createPropertyAccessor',
        value: function _createPropertyAccessor(property, readOnly) {
          if (!this.hasOwnProperty('__dataHasAccessor')) {
            this.__dataHasAccessor = Object.assign({}, this.__dataHasAccessor);
          }
          if (!this.__dataHasAccessor[property]) {
            this.__dataHasAccessor[property] = true;
            saveAccessorValue(this, property);
            Object.defineProperty(this, property, {
              /* eslint-disable valid-jsdoc */
              /** @this {PropertyAccessors} */
              get: function get() {
                return this.__data[property];
              },
              /** @this {PropertyAccessors} */
              set: readOnly ? function () {} : function (value) {
                this._setProperty(property, value);
              }
              /* eslint-enable */
            });
          }
        }

        /**
         * Returns true if this library created an accessor for the given property.
         *
         * @param {string} property Property name
         * @return {boolean} True if an accessor was created
         */

      }, {
        key: '_hasAccessor',
        value: function _hasAccessor(property) {
          return this.__dataHasAccessor && this.__dataHasAccessor[property];
        }

        /**
         * Updates the local storage for a property (via `_setPendingProperty`)
         * and enqueues a `_proeprtiesChanged` callback.
         *
         * @param {string} property Name of the property
         * @param {*} value Value to set
         * @protected
         */

      }, {
        key: '_setProperty',
        value: function _setProperty(property, value) {
          if (this._setPendingProperty(property, value)) {
            this._invalidateProperties();
          }
        }

        /**
         * Updates the local storage for a property, records the previous value,
         * and adds it to the set of "pending changes" that will be passed to the
         * `_propertiesChanged` callback.  This method does not enqueue the
         * `_propertiesChanged` callback.
         *
         * @param {string} property Name of the property
         * @param {*} value Value to set
         * @return {boolean} Returns true if the property changed
         * @protected
         */

      }, {
        key: '_setPendingProperty',
        value: function _setPendingProperty(property, value) {
          var old = this.__data[property];
          var changed = this._shouldPropertyChange(property, value, old);
          if (changed) {
            if (!this.__dataPending) {
              this.__dataPending = {};
              this.__dataOld = {};
            }
            // Ensure old is captured from the last turn
            if (this.__dataOld && !(property in this.__dataOld)) {
              this.__dataOld[property] = old;
            }
            this.__data[property] = value;
            this.__dataPending[property] = value;
          }
          return changed;
        }

        /**
         * Returns true if the specified property has a pending change.
         *
         * @param {string} prop Property name
         * @return {boolean} True if property has a pending change
         * @protected
         */

      }, {
        key: '_isPropertyPending',
        value: function _isPropertyPending(prop) {
          return Boolean(this.__dataPending && prop in this.__dataPending);
        }

        /**
         * Marks the properties as invalid, and enqueues an async
         * `_propertiesChanged` callback.
         *
         * @protected
         */

      }, {
        key: '_invalidateProperties',
        value: function _invalidateProperties() {
          var _this2 = this;

          if (!this.__dataInvalid && this.__dataReady) {
            this.__dataInvalid = true;
            microtask.run(function () {
              if (_this2.__dataInvalid) {
                _this2.__dataInvalid = false;
                _this2._flushProperties();
              }
            });
          }
        }

        /**
         * Call to enable property accessor processing. Before this method is
         * called accessor values will be set but side effects are
         * queued. When called, any pending side effects occur immediately.
         * For elements, generally `connectedCallback` is a normal spot to do so.
         * It is safe to call this method multiple times as it only turns on
         * property accessors once.
         */

      }, {
        key: '_enableProperties',
        value: function _enableProperties() {
          if (!this.__dataEnabled) {
            this.__dataEnabled = true;
            if (this.__dataInstanceProps) {
              this._initializeInstanceProperties(this.__dataInstanceProps);
              this.__dataInstanceProps = null;
            }
            this.ready();
          }
        }

        /**
         * Calls the `_propertiesChanged` callback with the current set of
         * pending changes (and old values recorded when pending changes were
         * set), and resets the pending set of changes. Generally, this method
         * should not be called in user code.
         *
         *
         * @protected
         */

      }, {
        key: '_flushProperties',
        value: function _flushProperties() {
          if (this.__dataPending && this.__dataOld) {
            var changedProps = this.__dataPending;
            this.__dataPending = null;
            this.__dataCounter++;
            this._propertiesChanged(this.__data, changedProps, this.__dataOld);
            this.__dataCounter--;
          }
        }

        /**
         * Lifecycle callback called the first time properties are being flushed.
         * Prior to `ready`, all property sets through accessors are queued and
         * their effects are flushed after this method returns.
         *
         * Users may override this function to implement behavior that is
         * dependent on the element having its properties initialized, e.g.
         * from defaults (initialized from `constructor`, `_initializeProperties`),
         * `attributeChangedCallback`, or values propagated from host e.g. via
         * bindings.  `super.ready()` must be called to ensure the data system
         * becomes enabled.
         *
         * @public
         */

      }, {
        key: 'ready',
        value: function ready() {
          this.__dataReady = true;
          // Run normal flush
          this._flushProperties();
        }

        /**
         * Callback called when any properties with accessors created via
         * `_createPropertyAccessor` have been set.
         *
         * @param {!Object} currentProps Bag of all current accessor values
         * @param {!Object} changedProps Bag of properties changed since the last
         *   call to `_propertiesChanged`
         * @param {!Object} oldProps Bag of previous values for each property
         *   in `changedProps`
         * @protected
         */

      }, {
        key: '_propertiesChanged',
        value: function _propertiesChanged(currentProps, changedProps, oldProps) {} // eslint-disable-line no-unused-vars


        /**
         * Method called to determine whether a property value should be
         * considered as a change and cause the `_propertiesChanged` callback
         * to be enqueued.
         *
         * The default implementation returns `true` for primitive types if a
         * strict equality check fails, and returns `true` for all Object/Arrays.
         * The method always returns false for `NaN`.
         *
         * Override this method to e.g. provide stricter checking for
         * Objects/Arrays when using immutable patterns.
         *
         * @param {string} property Property name
         * @param {*} value New property value
         * @param {*} old Previous property value
         * @return {boolean} Whether the property should be considered a change
         *   and enqueue a `_proeprtiesChanged` callback
         * @protected
         */

      }, {
        key: '_shouldPropertyChange',
        value: function _shouldPropertyChange(property, value, old) {
          return (
            // Strict equality check
            old !== value && (
            // This ensures (old==NaN, value==NaN) always returns false
            old === old || value === value)
          );
        }
      }]);

      return PropertyAccessors;
    }(superClass);

    return PropertyAccessors;
  });
})();

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

__webpack_require__(1);

__webpack_require__(3);

(function () {

  'use strict';

  // 1.x backwards-compatible auto-wrapper for template type extensions
  // This is a clear layering violation and gives favored-nation status to
  // dom-if and dom-repeat templates.  This is a conceit we're choosing to keep
  // a.) to ease 1.x backwards-compatibility due to loss of `is`, and
  // b.) to maintain if/repeat capability in parser-constrained elements
  //     (e.g. table, select) in lieu of native CE type extensions without
  //     massive new invention in this space (e.g. directive system)

  var templateExtensions = {
    'dom-if': true,
    'dom-repeat': true
  };
  function wrapTemplateExtension(node) {
    var is = node.getAttribute('is');
    if (is && templateExtensions[is]) {
      var t = node;
      t.removeAttribute('is');
      node = t.ownerDocument.createElement(is);
      t.parentNode.replaceChild(node, t);
      node.appendChild(t);
      while (t.attributes.length) {
        node.setAttribute(t.attributes[0].name, t.attributes[0].value);
        t.removeAttribute(t.attributes[0].name);
      }
    }
    return node;
  }

  function findTemplateNode(root, nodeInfo) {
    // recursively ascend tree until we hit root
    var parent = nodeInfo.parentInfo && findTemplateNode(root, nodeInfo.parentInfo);
    // unwind the stack, returning the indexed node at each level
    if (parent) {
      // note: marginally faster than indexing via childNodes
      // (http://jsperf.com/childnodes-lookup)
      for (var n = parent.firstChild, i = 0; n; n = n.nextSibling) {
        if (nodeInfo.parentIndex === i++) {
          return n;
        }
      }
    } else {
      return root;
    }
  }

  // construct `$` map (from id annotations)
  function applyIdToMap(inst, map, node, nodeInfo) {
    if (nodeInfo.id) {
      map[nodeInfo.id] = node;
    }
  }

  // install event listeners (from event annotations)
  function applyEventListener(inst, node, nodeInfo) {
    if (nodeInfo.events && nodeInfo.events.length) {
      for (var j = 0, e$ = nodeInfo.events, e; j < e$.length && (e = e$[j]); j++) {
        inst._addMethodEventListenerToNode(node, e.name, e.value, inst);
      }
    }
  }

  // push configuration references at configure time
  function applyTemplateContent(inst, node, nodeInfo) {
    if (nodeInfo.templateInfo) {
      node._templateInfo = nodeInfo.templateInfo;
    }
  }

  function createNodeEventHandler(context, eventName, methodName) {
    // Instances can optionally have a _methodHost which allows redirecting where
    // to find methods. Currently used by `templatize`.
    context = context._methodHost || context;
    var handler = function handler(e) {
      if (context[methodName]) {
        context[methodName](e, e.detail);
      } else {
        console.warn('listener method `' + methodName + '` not defined');
      }
    };
    return handler;
  }

  /**
   * Element mixin that provides basic template parsing and stamping, including
   * the following template-related features for stamped templates:
   *
   * - Declarative event listeners (`on-eventname="listener"`)
   * - Map of node id's to stamped node instances (`this.$.id`)
   * - Nested template content caching/removal and re-installation (performance
   *   optimization)
   *
   * @mixinFunction
   * @polymer
   * @memberof Polymer
   * @summary Element class mixin that provides basic template parsing and stamping
   */
  Polymer.TemplateStamp = Polymer.dedupingMixin(function (superClass) {

    /**
     * @polymer
     * @mixinClass
     * @implements {Polymer_TemplateStamp}
     */
    var TemplateStamp = function (_superClass) {
      _inherits(TemplateStamp, _superClass);

      function TemplateStamp() {
        _classCallCheck(this, TemplateStamp);

        return _possibleConstructorReturn(this, (TemplateStamp.__proto__ || Object.getPrototypeOf(TemplateStamp)).apply(this, arguments));
      }

      _createClass(TemplateStamp, [{
        key: '_stampTemplate',


        /**
         * Clones the provided template content and returns a document fragment
         * containing the cloned dom.
         *
         * The template is parsed (once and memoized) using this library's
         * template parsing features, and provides the following value-added
         * features:
         * * Adds declarative event listeners for `on-event="handler"` attributes
         * * Generates an "id map" for all nodes with id's under `$` on returned
         *   document fragment
         * * Passes template info including `content` back to templates as
         *   `_templateInfo` (a performance optimization to avoid deep template
         *   cloning)
         *
         * Note that the memoized template parsing process is destructive to the
         * template: attributes for bindings and declarative event listeners are
         * removed after being noted in notes, and any nested `<template>.content`
         * is removed and stored in notes as well.
         *
         * @param {!HTMLTemplateElement} template Template to stamp
         * @return {!StampedTemplate} Cloned template content
         */
        value: function _stampTemplate(template) {
          // Polyfill support: bootstrap the template if it has not already been
          if (template && !template.content && window.HTMLTemplateElement && HTMLTemplateElement.decorate) {
            HTMLTemplateElement.decorate(template);
          }
          var templateInfo = this.constructor._parseTemplate(template);
          var nodeInfo = templateInfo.nodeInfoList;
          var content = templateInfo.content || template.content;
          var dom = /** @type DocumentFragment */document.importNode(content, true);
          // NOTE: ShadyDom optimization indicating there is an insertion point
          dom.__noInsertionPoint = !templateInfo.hasInsertionPoint;
          var nodes = dom.nodeList = new Array(nodeInfo.length);
          dom.$ = {};
          for (var i = 0, l = nodeInfo.length, info; i < l && (info = nodeInfo[i]); i++) {
            var node = nodes[i] = findTemplateNode(dom, info);
            applyIdToMap(this, dom.$, node, info);
            applyTemplateContent(this, node, info);
            applyEventListener(this, node, info);
          }
          return (/** @type {!StampedTemplate} */dom
          );
        }

        /**
         * Adds an event listener by method name for the event provided.
         *
         * This method generates a handler function that looks up the method
         * name at handling time.
         *
         * @param {Node} node Node to add listener on
         * @param {string} eventName Name of event
         * @param {string} methodName Name of method
         * @param {*=} context Context the method will be called on (defaults
         *   to `node`)
         * @return {Function} Generated handler function
         */

      }, {
        key: '_addMethodEventListenerToNode',
        value: function _addMethodEventListenerToNode(node, eventName, methodName, context) {
          context = context || node;
          var handler = createNodeEventHandler(context, eventName, methodName);
          this._addEventListenerToNode(node, eventName, handler);
          return handler;
        }

        /**
         * Override point for adding custom or simulated event handling.
         *
         * @param {Node} node Node to add event listener to
         * @param {string} eventName Name of event
         * @param {Function} handler Listener function to add
         */

      }, {
        key: '_addEventListenerToNode',
        value: function _addEventListenerToNode(node, eventName, handler) {
          node.addEventListener(eventName, handler);
        }

        /**
         * Override point for adding custom or simulated event handling.
         *
         * @param {Node} node Node to remove event listener from
         * @param {string} eventName Name of event
         * @param {Function} handler Listener function to remove
         */

      }, {
        key: '_removeEventListenerFromNode',
        value: function _removeEventListenerFromNode(node, eventName, handler) {
          node.removeEventListener(eventName, handler);
        }
      }], [{
        key: '_parseTemplate',


        /**
         * Scans a template to produce template metadata.
         *
         * Template-specific metadata are stored in the object returned, and node-
         * specific metadata are stored in objects in its flattened `nodeInfoList`
         * array.  Only nodes in the template that were parsed as nodes of
         * interest contain an object in `nodeInfoList`.  Each `nodeInfo` object
         * contains an `index` (`childNodes` index in parent) and optionally
         * `parent`, which points to node info of its parent (including its index).
         *
         * The template metadata object returned from this method has the following
         * structure (many fields optional):
         *
         * ```js
         *   {
         *     // Flattened list of node metadata (for nodes that generated metadata)
         *     nodeInfoList: [
         *       {
         *         // `id` attribute for any nodes with id's for generating `$` map
         *         id: {string},
         *         // `on-event="handler"` metadata
         *         events: [
         *           {
         *             name: {string},   // event name
         *             value: {string},  // handler method name
         *           }, ...
         *         ],
         *         // Notes when the template contained a `<slot>` for shady DOM
         *         // optimization purposes
         *         hasInsertionPoint: {boolean},
         *         // For nested `<template>`` nodes, nested template metadata
         *         templateInfo: {object}, // nested template metadata
         *         // Metadata to allow efficient retrieval of instanced node
         *         // corresponding to this metadata
         *         parentInfo: {number},   // reference to parent nodeInfo>
         *         parentIndex: {number},  // index in parent's `childNodes` collection
         *         infoIndex: {number},    // index of this `nodeInfo` in `templateInfo.nodeInfoList`
         *       },
         *       ...
         *     ],
         *     // When true, the template had the `strip-whitespace` attribute
         *     // or was nested in a template with that setting
         *     stripWhitespace: {boolean},
         *     // For nested templates, nested template content is moved into
         *     // a document fragment stored here; this is an optimization to
         *     // avoid the cost of nested template cloning
         *     content: {DocumentFragment}
         *   }
         * ```
         *
         * This method kicks off a recursive treewalk as follows:
         *
         * ```
         *    _parseTemplate <---------------------+
         *      _parseTemplateContent              |
         *        _parseTemplateNode  <------------|--+
         *          _parseTemplateNestedTemplate --+  |
         *          _parseTemplateChildNodes ---------+
         *          _parseTemplateNodeAttributes
         *            _parseTemplateNodeAttribute
         *
         * ```
         *
         * These methods may be overridden to add custom metadata about templates
         * to either `templateInfo` or `nodeInfo`.
         *
         * Note that this method may be destructive to the template, in that
         * e.g. event annotations may be removed after being noted in the
         * template metadata.
         *
         * @param {!HTMLTemplateElement} template Template to parse
         * @param {TemplateInfo=} outerTemplateInfo Template metadata from the outer
         *   template, for parsing nested templates
         * @return {!TemplateInfo} Parsed template metadata
         */
        value: function _parseTemplate(template, outerTemplateInfo) {
          // since a template may be re-used, memo-ize metadata
          if (!template._templateInfo) {
            var templateInfo = template._templateInfo = {};
            templateInfo.nodeInfoList = [];
            templateInfo.stripWhiteSpace = outerTemplateInfo && outerTemplateInfo.stripWhiteSpace || template.hasAttribute('strip-whitespace');
            this._parseTemplateContent(template, templateInfo, { parent: null });
          }
          return template._templateInfo;
        }
      }, {
        key: '_parseTemplateContent',
        value: function _parseTemplateContent(template, templateInfo, nodeInfo) {
          return this._parseTemplateNode(template.content, templateInfo, nodeInfo);
        }

        /**
         * Parses template node and adds template and node metadata based on
         * the current node, and its `childNodes` and `attributes`.
         *
         * This method may be overridden to add custom node or template specific
         * metadata based on this node.
         *
         * @param {Node} node Node to parse
         * @param {!TemplateInfo} templateInfo Template metadata for current template
         * @param {!NodeInfo} nodeInfo Node metadata for current template.
         * @return {boolean} `true` if the visited node added node-specific
         *   metadata to `nodeInfo`
         */

      }, {
        key: '_parseTemplateNode',
        value: function _parseTemplateNode(node, templateInfo, nodeInfo) {
          var noted = void 0;
          var element = /** @type Element */node;
          if (element.localName == 'template' && !element.hasAttribute('preserve-content')) {
            noted = this._parseTemplateNestedTemplate(element, templateInfo, nodeInfo) || noted;
          } else if (element.localName === 'slot') {
            // For ShadyDom optimization, indicating there is an insertion point
            templateInfo.hasInsertionPoint = true;
          }
          if (element.firstChild) {
            noted = this._parseTemplateChildNodes(element, templateInfo, nodeInfo) || noted;
          }
          if (element.hasAttributes && element.hasAttributes()) {
            noted = this._parseTemplateNodeAttributes(element, templateInfo, nodeInfo) || noted;
          }
          return noted;
        }

        /**
         * Parses template child nodes for the given root node.
         *
         * This method also wraps whitelisted legacy template extensions
         * (`is="dom-if"` and `is="dom-repeat"`) with their equivalent element
         * wrappers, collapses text nodes, and strips whitespace from the template
         * if the `templateInfo.stripWhitespace` setting was provided.
         *
         * @param {Node} root Root node whose `childNodes` will be parsed
         * @param {!TemplateInfo} templateInfo Template metadata for current template
         * @param {!NodeInfo} nodeInfo Node metadata for current template.
         */

      }, {
        key: '_parseTemplateChildNodes',
        value: function _parseTemplateChildNodes(root, templateInfo, nodeInfo) {
          for (var node = root.firstChild, parentIndex = 0, next; node; node = next) {
            // Wrap templates
            if (node.localName == 'template') {
              node = wrapTemplateExtension(node);
            }
            // collapse adjacent textNodes: fixes an IE issue that can cause
            // text nodes to be inexplicably split =(
            // note that root.normalize() should work but does not so we do this
            // manually.
            next = node.nextSibling;
            if (node.nodeType === Node.TEXT_NODE) {
              var /** Node */n = next;
              while (n && n.nodeType === Node.TEXT_NODE) {
                node.textContent += n.textContent;
                next = n.nextSibling;
                root.removeChild(n);
                n = next;
              }
              // optionally strip whitespace
              if (templateInfo.stripWhiteSpace && !node.textContent.trim()) {
                root.removeChild(node);
                continue;
              }
            }
            var childInfo = { parentIndex: parentIndex, parentInfo: nodeInfo };
            if (this._parseTemplateNode(node, templateInfo, childInfo)) {
              childInfo.infoIndex = templateInfo.nodeInfoList.push( /** @type {!NodeInfo} */childInfo) - 1;
            }
            // Increment if not removed
            if (node.parentNode) {
              parentIndex++;
            }
          }
        }

        /**
         * Parses template content for the given nested `<template>`.
         *
         * Nested template info is stored as `templateInfo` in the current node's
         * `nodeInfo`. `template.content` is removed and stored in `templateInfo`.
         * It will then be the responsibility of the host to set it back to the
         * template and for users stamping nested templates to use the
         * `_contentForTemplate` method to retrieve the content for this template
         * (an optimization to avoid the cost of cloning nested template content).
         *
         * @param {HTMLTemplateElement} node Node to parse (a <template>)
         * @param {TemplateInfo} outerTemplateInfo Template metadata for current template
         *   that includes the template `node`
         * @param {!NodeInfo} nodeInfo Node metadata for current template.
         * @return {boolean} `true` if the visited node added node-specific
         *   metadata to `nodeInfo`
         */

      }, {
        key: '_parseTemplateNestedTemplate',
        value: function _parseTemplateNestedTemplate(node, outerTemplateInfo, nodeInfo) {
          var templateInfo = this._parseTemplate(node, outerTemplateInfo);
          var content = templateInfo.content = node.content.ownerDocument.createDocumentFragment();
          content.appendChild(node.content);
          nodeInfo.templateInfo = templateInfo;
          return true;
        }

        /**
         * Parses template node attributes and adds node metadata to `nodeInfo`
         * for nodes of interest.
         *
         * @param {Element} node Node to parse
         * @param {TemplateInfo} templateInfo Template metadata for current template
         * @param {NodeInfo} nodeInfo Node metadata for current template.
         * @return {boolean} `true` if the visited node added node-specific
         *   metadata to `nodeInfo`
         */

      }, {
        key: '_parseTemplateNodeAttributes',
        value: function _parseTemplateNodeAttributes(node, templateInfo, nodeInfo) {
          // Make copy of original attribute list, since the order may change
          // as attributes are added and removed
          var noted = false;
          var attrs = Array.from(node.attributes);
          for (var i = attrs.length - 1, a; a = attrs[i]; i--) {
            noted = this._parseTemplateNodeAttribute(node, templateInfo, nodeInfo, a.name, a.value) || noted;
          }
          return noted;
        }

        /**
         * Parses a single template node attribute and adds node metadata to
         * `nodeInfo` for attributes of interest.
         *
         * This implementation adds metadata for `on-event="handler"` attributes
         * and `id` attributes.
         *
         * @param {Element} node Node to parse
         * @param {!TemplateInfo} templateInfo Template metadata for current template
         * @param {!NodeInfo} nodeInfo Node metadata for current template.
         * @param {string} name Attribute name
         * @param {string} value Attribute value
         * @return {boolean} `true` if the visited node added node-specific
         *   metadata to `nodeInfo`
         */

      }, {
        key: '_parseTemplateNodeAttribute',
        value: function _parseTemplateNodeAttribute(node, templateInfo, nodeInfo, name, value) {
          // events (on-*)
          if (name.slice(0, 3) === 'on-') {
            node.removeAttribute(name);
            nodeInfo.events = nodeInfo.events || [];
            nodeInfo.events.push({
              name: name.slice(3),
              value: value
            });
            return true;
          }
          // static id
          else if (name === 'id') {
              nodeInfo.id = value;
              return true;
            }
          return false;
        }

        /**
         * Returns the `content` document fragment for a given template.
         *
         * For nested templates, Polymer performs an optimization to cache nested
         * template content to avoid the cost of cloning deeply nested templates.
         * This method retrieves the cached content for a given template.
         *
         * @param {HTMLTemplateElement} template Template to retrieve `content` for
         * @return {DocumentFragment} Content fragment
         */

      }, {
        key: '_contentForTemplate',
        value: function _contentForTemplate(template) {
          var templateInfo = /** @type {HTMLTemplateElementWithInfo} */template._templateInfo;
          return templateInfo && templateInfo.content || template.content;
        }
      }]);

      return TemplateStamp;
    }(superClass);

    return TemplateStamp;
  });
})();

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

__webpack_require__(5);

var RegisterHtmlTemplate = __webpack_require__(2);

RegisterHtmlTemplate.register("<dom-module id=app-drawer> <template> <style>:host{position:fixed;top:-120px;right:0;bottom:-120px;left:0;visibility:hidden;transition-property:visibility}:host([opened]){visibility:visible}:host([persistent]){width:var(--app-drawer-width,256px)}:host([persistent][position=left]){right:auto}:host([persistent][position=right]){left:auto}#contentContainer{position:absolute;top:0;bottom:0;left:0;width:var(--app-drawer-width,256px);padding:120px 0;transition-property:-webkit-transform;transition-property:transform;-webkit-transform:translate3d(-100%,0,0);transform:translate3d(-100%,0,0);background-color:#fff;@apply --app-drawer-content-container;}#contentContainer[persistent]{width:100%}#contentContainer[position=right]{right:0;left:auto;-webkit-transform:translate3d(100%,0,0);transform:translate3d(100%,0,0)}#contentContainer[swipe-open]::after{position:fixed;top:0;bottom:0;left:100%;visibility:visible;width:20px;content:''}#contentContainer[swipe-open][position=right]::after{right:100%;left:auto}#contentContainer[opened]{-webkit-transform:translate3d(0,0,0);transform:translate3d(0,0,0)}#scrim{position:absolute;top:0;right:0;bottom:0;left:0;transition-property:opacity;-webkit-transform:translateZ(0);transform:translateZ(0);opacity:0;background:var(--app-drawer-scrim-background,rgba(0,0,0,.5))}#scrim.visible{opacity:1}:host([no-transition]) #contentContainer{transition-property:none}</style> <div id=scrim on-click=close></div> <div id=contentContainer opened$=[[opened]] persistent$=[[persistent]] position$=[[position]] swipe-open$=[[swipeOpen]]> <slot></slot> </div> </template> </dom-module>");

Polymer({
  is: 'app-drawer',

  properties: {
    /**
     * The opened state of the drawer.
     */
    opened: {
      type: Boolean,
      value: false,
      notify: true,
      reflectToAttribute: true
    },

    /**
     * The drawer does not have a scrim and cannot be swiped close.
     */
    persistent: {
      type: Boolean,
      value: false,
      reflectToAttribute: true
    },

    /**
     * The transition duration of the drawer in milliseconds.
     */
    transitionDuration: {
      type: Number,
      value: 200
    },

    /**
     * The alignment of the drawer on the screen ('left', 'right', 'start' or 'end').
     * 'start' computes to left and 'end' to right in LTR layout and vice versa in RTL
     * layout.
     */
    align: {
      type: String,
      value: 'left'
    },

    /**
     * The computed, read-only position of the drawer on the screen ('left' or 'right').
     */
    position: {
      type: String,
      readOnly: true,
      reflectToAttribute: true
    },

    /**
     * Create an area at the edge of the screen to swipe open the drawer.
     */
    swipeOpen: {
      type: Boolean,
      value: false,
      reflectToAttribute: true
    },

    /**
     * Trap keyboard focus when the drawer is opened and not persistent.
     */
    noFocusTrap: {
      type: Boolean,
      value: false
    },

    /**
     * Disables swiping on the drawer.
     */
    disableSwipe: {
      type: Boolean,
      value: false
    }
  },

  observers: ['resetLayout(position, isAttached)', '_resetPosition(align, isAttached)', '_styleTransitionDuration(transitionDuration)', '_openedPersistentChanged(opened, persistent)'],

  _translateOffset: 0,

  _trackDetails: null,

  _drawerState: 0,

  _boundEscKeydownHandler: null,

  _firstTabStop: null,

  _lastTabStop: null,

  attached: function attached() {
    Polymer.RenderStatus.afterNextRender(this, function () {
      this._boundEscKeydownHandler = this._escKeydownHandler.bind(this);
      this.addEventListener('keydown', this._tabKeydownHandler.bind(this));

      // Only listen for horizontal track so you can vertically scroll inside the drawer.
      this.listen(this, 'track', '_track');
      this.setScrollDirection('y');
    });

    this.fire('app-reset-layout');
  },

  detached: function detached() {
    document.removeEventListener('keydown', this._boundEscKeydownHandler);
  },

  /**
   * Opens the drawer.
   */
  open: function open() {
    this.opened = true;
  },

  /**
   * Closes the drawer.
   */
  close: function close() {
    this.opened = false;
  },

  /**
   * Toggles the drawer open and close.
   */
  toggle: function toggle() {
    this.opened = !this.opened;
  },

  /**
   * Gets the width of the drawer.
   *
   * @return {number} The width of the drawer in pixels.
   */
  getWidth: function getWidth() {
    return this._savedWidth || this.$.contentContainer.offsetWidth;
  },

  _isRTL: function _isRTL() {
    return window.getComputedStyle(this).direction === 'rtl';
  },

  _resetPosition: function _resetPosition() {
    switch (this.align) {
      case 'start':
        this._setPosition(this._isRTL() ? 'right' : 'left');
        return;
      case 'end':
        this._setPosition(this._isRTL() ? 'left' : 'right');
        return;
    }
    this._setPosition(this.align);
  },

  _escKeydownHandler: function _escKeydownHandler(event) {
    var ESC_KEYCODE = 27;
    if (event.keyCode === ESC_KEYCODE) {
      // Prevent any side effects if app-drawer closes.
      event.preventDefault();
      this.close();
    }
  },

  _track: function _track(event) {
    if (this.persistent || this.disableSwipe) {
      return;
    }

    // Disable user selection on desktop.
    event.preventDefault();

    switch (event.detail.state) {
      case 'start':
        this._trackStart(event);
        break;
      case 'track':
        this._trackMove(event);
        break;
      case 'end':
        this._trackEnd(event);
        break;
    }
  },

  _trackStart: function _trackStart(event) {
    this._drawerState = this._DRAWER_STATE.TRACKING;

    var rect = this.$.contentContainer.getBoundingClientRect();
    this._savedWidth = rect.width;
    if (this.position === 'left') {
      this._translateOffset = rect.left;
    } else {
      this._translateOffset = rect.right - window.innerWidth;
    }

    this._trackDetails = [];

    // Disable transitions since style attributes will reflect user track events.
    this._styleTransitionDuration(0);
    this.style.visibility = 'visible';
  },

  _trackMove: function _trackMove(event) {
    this._translateDrawer(event.detail.dx + this._translateOffset);

    // Use Date.now() since event.timeStamp is inconsistent across browsers (e.g. most
    // browsers use milliseconds but FF 44 uses microseconds).
    this._trackDetails.push({
      dx: event.detail.dx,
      timeStamp: Date.now()
    });
  },

  _trackEnd: function _trackEnd(event) {
    var x = event.detail.dx + this._translateOffset;
    var drawerWidth = this.getWidth();
    var isPositionLeft = this.position === 'left';
    var isInEndState = isPositionLeft ? x >= 0 || x <= -drawerWidth : x <= 0 || x >= drawerWidth;

    if (!isInEndState) {
      // No longer need the track events after this method returns - allow them to be GC'd.
      var trackDetails = this._trackDetails;
      this._trackDetails = null;

      this._flingDrawer(event, trackDetails);
      if (this._drawerState === this._DRAWER_STATE.FLINGING) {
        return;
      }
    }

    // If the drawer is not flinging, toggle the opened state based on the position of
    // the drawer.
    var halfWidth = drawerWidth / 2;
    if (event.detail.dx < -halfWidth) {
      this.opened = this.position === 'right';
    } else if (event.detail.dx > halfWidth) {
      this.opened = this.position === 'left';
    }

    if (isInEndState) {
      this.debounce('_resetDrawerState', this._resetDrawerState);
    } else {
      this.debounce('_resetDrawerState', this._resetDrawerState, this.transitionDuration);
    }

    this._styleTransitionDuration(this.transitionDuration);
    this._resetDrawerTranslate();
    this.style.visibility = '';
  },

  _calculateVelocity: function _calculateVelocity(event, trackDetails) {
    // Find the oldest track event that is within 100ms using binary search.
    var now = Date.now();
    var timeLowerBound = now - 100;
    var trackDetail;
    var min = 0;
    var max = trackDetails.length - 1;

    while (min <= max) {
      // Floor of average of min and max.
      var mid = min + max >> 1;
      var d = trackDetails[mid];
      if (d.timeStamp >= timeLowerBound) {
        trackDetail = d;
        max = mid - 1;
      } else {
        min = mid + 1;
      }
    }

    if (trackDetail) {
      var dx = event.detail.dx - trackDetail.dx;
      var dt = now - trackDetail.timeStamp || 1;
      return dx / dt;
    }
    return 0;
  },

  _flingDrawer: function _flingDrawer(event, trackDetails) {
    var velocity = this._calculateVelocity(event, trackDetails);

    // Do not fling if velocity is not above a threshold.
    if (Math.abs(velocity) < this._MIN_FLING_THRESHOLD) {
      return;
    }

    this._drawerState = this._DRAWER_STATE.FLINGING;

    var x = event.detail.dx + this._translateOffset;
    var drawerWidth = this.getWidth();
    var isPositionLeft = this.position === 'left';
    var isVelocityPositive = velocity > 0;
    var isClosingLeft = !isVelocityPositive && isPositionLeft;
    var isClosingRight = isVelocityPositive && !isPositionLeft;
    var dx;
    if (isClosingLeft) {
      dx = -(x + drawerWidth);
    } else if (isClosingRight) {
      dx = drawerWidth - x;
    } else {
      dx = -x;
    }

    // Enforce a minimum transition velocity to make the drawer feel snappy.
    if (isVelocityPositive) {
      velocity = Math.max(velocity, this._MIN_TRANSITION_VELOCITY);
      this.opened = this.position === 'left';
    } else {
      velocity = Math.min(velocity, -this._MIN_TRANSITION_VELOCITY);
      this.opened = this.position === 'right';
    }

    // Calculate the amount of time needed to finish the transition based on the
    // initial slope of the timing function.
    var t = this._FLING_INITIAL_SLOPE * dx / velocity;
    this._styleTransitionDuration(t);
    this._styleTransitionTimingFunction(this._FLING_TIMING_FUNCTION);

    this._resetDrawerTranslate();
    this.debounce('_resetDrawerState', this._resetDrawerState, t);
  },

  _styleTransitionDuration: function _styleTransitionDuration(duration) {
    this.style.transitionDuration = duration + 'ms';
    this.$.contentContainer.style.transitionDuration = duration + 'ms';
    this.$.scrim.style.transitionDuration = duration + 'ms';
  },

  _styleTransitionTimingFunction: function _styleTransitionTimingFunction(timingFunction) {
    this.$.contentContainer.style.transitionTimingFunction = timingFunction;
    this.$.scrim.style.transitionTimingFunction = timingFunction;
  },

  _translateDrawer: function _translateDrawer(x) {
    var drawerWidth = this.getWidth();

    if (this.position === 'left') {
      x = Math.max(-drawerWidth, Math.min(x, 0));
      this.$.scrim.style.opacity = 1 + x / drawerWidth;
    } else {
      x = Math.max(0, Math.min(x, drawerWidth));
      this.$.scrim.style.opacity = 1 - x / drawerWidth;
    }

    this.translate3d(x + 'px', '0', '0', this.$.contentContainer);
  },

  _resetDrawerTranslate: function _resetDrawerTranslate() {
    this.$.scrim.style.opacity = '';
    this.transform('', this.$.contentContainer);
  },

  _resetDrawerState: function _resetDrawerState() {
    var oldState = this._drawerState;

    // If the drawer was flinging, we need to reset the style attributes.
    if (oldState === this._DRAWER_STATE.FLINGING) {
      this._styleTransitionDuration(this.transitionDuration);
      this._styleTransitionTimingFunction('');
      this.style.visibility = '';
    }

    this._savedWidth = null;

    if (this.opened) {
      this._drawerState = this.persistent ? this._DRAWER_STATE.OPENED_PERSISTENT : this._DRAWER_STATE.OPENED;
    } else {
      this._drawerState = this._DRAWER_STATE.CLOSED;
    }

    if (oldState !== this._drawerState) {
      if (this._drawerState === this._DRAWER_STATE.OPENED) {
        this._setKeyboardFocusTrap();
        document.addEventListener('keydown', this._boundEscKeydownHandler);
        document.body.style.overflow = 'hidden';
      } else {
        document.removeEventListener('keydown', this._boundEscKeydownHandler);
        document.body.style.overflow = '';
      }

      // Don't fire the event on initial load.
      if (oldState !== this._DRAWER_STATE.INIT) {
        this.fire('app-drawer-transitioned');
      }
    }
  },

  /**
   * Resets the layout.
   *
   * @method resetLayout
   */
  resetLayout: function resetLayout() {
    this.fire('app-reset-layout');
  },

  _setKeyboardFocusTrap: function _setKeyboardFocusTrap() {
    if (this.noFocusTrap) {
      return;
    }

    // NOTE: Unless we use /deep/ (which we shouldn't since it's deprecated), this will
    // not select focusable elements inside shadow roots.
    var focusableElementsSelector = ['a[href]:not([tabindex="-1"])', 'area[href]:not([tabindex="-1"])', 'input:not([disabled]):not([tabindex="-1"])', 'select:not([disabled]):not([tabindex="-1"])', 'textarea:not([disabled]):not([tabindex="-1"])', 'button:not([disabled]):not([tabindex="-1"])', 'iframe:not([tabindex="-1"])', '[tabindex]:not([tabindex="-1"])', '[contentEditable=true]:not([tabindex="-1"])'].join(',');
    var focusableElements = Polymer.dom(this).querySelectorAll(focusableElementsSelector);

    if (focusableElements.length > 0) {
      this._firstTabStop = focusableElements[0];
      this._lastTabStop = focusableElements[focusableElements.length - 1];
    } else {
      // Reset saved tab stops when there are no focusable elements in the drawer.
      this._firstTabStop = null;
      this._lastTabStop = null;
    }

    // Focus on app-drawer if it has non-zero tabindex. Otherwise, focus the first focusable
    // element in the drawer, if it exists. Use the tabindex attribute since the this.tabIndex
    // property in IE/Edge returns 0 (instead of -1) when the attribute is not set.
    var tabindex = this.getAttribute('tabindex');
    if (tabindex && parseInt(tabindex, 10) > -1) {
      this.focus();
    } else if (this._firstTabStop) {
      this._firstTabStop.focus();
    }
  },

  _tabKeydownHandler: function _tabKeydownHandler(event) {
    if (this.noFocusTrap) {
      return;
    }

    var TAB_KEYCODE = 9;
    if (this._drawerState === this._DRAWER_STATE.OPENED && event.keyCode === TAB_KEYCODE) {
      if (event.shiftKey) {
        if (this._firstTabStop && Polymer.dom(event).localTarget === this._firstTabStop) {
          event.preventDefault();
          this._lastTabStop.focus();
        }
      } else {
        if (this._lastTabStop && Polymer.dom(event).localTarget === this._lastTabStop) {
          event.preventDefault();
          this._firstTabStop.focus();
        }
      }
    }
  },

  _openedPersistentChanged: function _openedPersistentChanged(opened, persistent) {
    this.toggleClass('visible', opened && !persistent, this.$.scrim);

    // Use a debounce timer instead of transitionend since transitionend won't fire when
    // app-drawer is display: none.
    this.debounce('_resetDrawerState', this._resetDrawerState, this.transitionDuration);
  },

  _MIN_FLING_THRESHOLD: 0.2,

  _MIN_TRANSITION_VELOCITY: 1.2,

  _FLING_TIMING_FUNCTION: 'cubic-bezier(0.667, 1, 0.667, 1)',

  _FLING_INITIAL_SLOPE: 1.5,

  _DRAWER_STATE: {
    INIT: 0,
    OPENED: 1,
    OPENED_PERSISTENT: 2,
    CLOSED: 3,
    TRACKING: 4,
    FLINGING: 5

    /**
     * Fired when the layout of app-drawer has changed.
     *
     * @event app-reset-layout
     */

    /**
     * Fired when app-drawer has finished transitioning.
     *
     * @event app-drawer-transitioned
     */
  } });

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(47);

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


(function () {
  /*
  Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
  This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
  The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
  The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
  Code distributed by Google as part of the polymer project is also
  subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
  */
  'use strict';
  var k = {};function n() {
    this.end = this.start = 0;this.rules = this.parent = this.previous = null;this.cssText = this.parsedCssText = "";this.atRule = !1;this.type = 0;this.parsedSelector = this.selector = this.keyframesName = "";
  }
  function p(a) {
    a = a.replace(aa, "").replace(ba, "");var b = q,
        c = a,
        d = new n();d.start = 0;d.end = c.length;for (var e = d, f = 0, h = c.length; f < h; f++) {
      if ("{" === c[f]) {
        e.rules || (e.rules = []);var g = e,
            m = g.rules[g.rules.length - 1] || null;e = new n();e.start = f + 1;e.parent = g;e.previous = m;g.rules.push(e);
      } else "}" === c[f] && (e.end = f + 1, e = e.parent || d);
    }return b(d, a);
  }
  function q(a, b) {
    var c = b.substring(a.start, a.end - 1);a.parsedCssText = a.cssText = c.trim();a.parent && (c = b.substring(a.previous ? a.previous.end : a.parent.start, a.start - 1), c = ca(c), c = c.replace(r, " "), c = c.substring(c.lastIndexOf(";") + 1), c = a.parsedSelector = a.selector = c.trim(), a.atRule = 0 === c.indexOf("@"), a.atRule ? 0 === c.indexOf("@media") ? a.type = t : c.match(da) && (a.type = u, a.keyframesName = a.selector.split(r).pop()) : a.type = 0 === c.indexOf("--") ? v : x);if (c = a.rules) for (var d = 0, e = c.length, f; d < e && (f = c[d]); d++) {
      q(f, b);
    }return a;
  }
  function ca(a) {
    return a.replace(/\\([0-9a-f]{1,6})\s/gi, function (a, c) {
      a = c;for (c = 6 - a.length; c--;) {
        a = "0" + a;
      }return "\\" + a;
    });
  }
  function y(a, b, c) {
    c = void 0 === c ? "" : c;var d = "";if (a.cssText || a.rules) {
      var e = a.rules,
          f;if (f = e) f = e[0], f = !(f && f.selector && 0 === f.selector.indexOf("--"));if (f) {
        f = 0;for (var h = e.length, g; f < h && (g = e[f]); f++) {
          d = y(g, b, d);
        }
      } else b ? b = a.cssText : (b = a.cssText, b = b.replace(ea, "").replace(fa, ""), b = b.replace(ha, "").replace(ia, "")), (d = b.trim()) && (d = "  " + d + "\n");
    }d && (a.selector && (c += a.selector + " {\n"), c += d, a.selector && (c += "}\n\n"));return c;
  }
  var x = 1,
      u = 7,
      t = 4,
      v = 1E3,
      aa = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//gim,
      ba = /@import[^;]*;/gim,
      ea = /(?:^[^;\-\s}]+)?--[^;{}]*?:[^{};]*?(?:[;\n]|$)/gim,
      fa = /(?:^[^;\-\s}]+)?--[^;{}]*?:[^{};]*?{[^}]*?}(?:[;\n]|$)?/gim,
      ha = /@apply\s*\(?[^);]*\)?\s*(?:[;\n]|$)?/gim,
      ia = /[^;:]*?:[^;]*?var\([^;]*\)(?:[;\n]|$)?/gim,
      da = /^@[^\s]*keyframes/,
      r = /\s+/g;var ja = Promise.resolve();function ka(a) {
    if (a = k[a]) a._applyShimCurrentVersion = a._applyShimCurrentVersion || 0, a._applyShimValidatingVersion = a._applyShimValidatingVersion || 0, a._applyShimNextVersion = (a._applyShimNextVersion || 0) + 1;
  }function z(a) {
    return a._applyShimCurrentVersion === a._applyShimNextVersion;
  }function la(a) {
    a._applyShimValidatingVersion = a._applyShimNextVersion;a.a || (a.a = !0, ja.then(function () {
      a._applyShimCurrentVersion = a._applyShimNextVersion;a.a = !1;
    }));
  };var A = !(window.ShadyDOM && window.ShadyDOM.inUse),
      B;function C(a) {
    B = a && a.shimcssproperties ? !1 : A || !(navigator.userAgent.match(/AppleWebKit\/601|Edge\/15/) || !window.CSS || !CSS.supports || !CSS.supports("box-shadow", "0 0 0 var(--foo)"));
  }window.ShadyCSS && void 0 !== window.ShadyCSS.nativeCss ? B = window.ShadyCSS.nativeCss : window.ShadyCSS ? (C(window.ShadyCSS), window.ShadyCSS = void 0) : C(window.WebComponents && window.WebComponents.flags);var E = B;var F = /(?:^|[;\s{]\s*)(--[\w-]*?)\s*:\s*(?:((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};{])+)|\{([^}]*)\}(?:(?=[;\s}])|$))/gi,
      G = /(?:^|\W+)@apply\s*\(?([^);\n]*)\)?/gi,
      ma = /@media\s(.*)/;function H(a) {
    if (!a) return "";"string" === typeof a && (a = p(a));return y(a, E);
  }function I(a) {
    !a.__cssRules && a.textContent && (a.__cssRules = p(a.textContent));return a.__cssRules || null;
  }function J(a, b, c, d) {
    if (a) {
      var e = !1,
          f = a.type;if (d && f === t) {
        var h = a.selector.match(ma);h && (window.matchMedia(h[1]).matches || (e = !0));
      }f === x ? b(a) : c && f === u ? c(a) : f === v && (e = !0);if ((a = a.rules) && !e) {
        e = 0;f = a.length;for (var g; e < f && (g = a[e]); e++) {
          J(g, b, c, d);
        }
      }
    }
  }
  function K(a, b) {
    var c = a.indexOf("var(");if (-1 === c) return b(a, "", "", "");a: {
      var d = 0;var e = c + 3;for (var f = a.length; e < f; e++) {
        if ("(" === a[e]) d++;else if (")" === a[e] && 0 === --d) break a;
      }e = -1;
    }d = a.substring(c + 4, e);c = a.substring(0, c);a = K(a.substring(e + 1), b);e = d.indexOf(",");return -1 === e ? b(c, d.trim(), "", a) : b(c, d.substring(0, e).trim(), d.substring(e + 1).trim(), a);
  };var na = /;\s*/m,
      oa = /^\s*(initial)|(inherit)\s*$/;function L() {
    this.a = {};
  }L.prototype.set = function (a, b) {
    a = a.trim();this.a[a] = { h: b, i: {} };
  };L.prototype.get = function (a) {
    a = a.trim();return this.a[a] || null;
  };var M = null;function N() {
    this.b = this.c = null;this.a = new L();
  }N.prototype.o = function (a) {
    a = G.test(a) || F.test(a);G.lastIndex = 0;F.lastIndex = 0;return a;
  };N.prototype.m = function (a, b) {
    a = a.content.querySelector("style");var c = null;a && (c = this.j(a, b));return c;
  };
  N.prototype.j = function (a, b) {
    b = void 0 === b ? "" : b;var c = I(a);this.l(c, b);a.textContent = H(c);return c;
  };N.prototype.f = function (a) {
    var b = this,
        c = I(a);J(c, function (a) {
      ":root" === a.selector && (a.selector = "html");b.g(a);
    });a.textContent = H(c);return c;
  };N.prototype.l = function (a, b) {
    var c = this;this.c = b;J(a, function (a) {
      c.g(a);
    });this.c = null;
  };N.prototype.g = function (a) {
    a.cssText = pa(this, a.parsedCssText);":root" === a.selector && (a.selector = ":host > *");
  };
  function pa(a, b) {
    b = b.replace(F, function (b, d, e, f) {
      return qa(a, b, d, e, f);
    });return O(a, b);
  }function O(a, b) {
    for (var c; c = G.exec(b);) {
      var d = c[0],
          e = c[1];c = c.index;var f = b.slice(0, c + d.indexOf("@apply"));b = b.slice(c + d.length);var h = P(a, f);d = void 0;var g = a;e = e.replace(na, "");var m = [];var l = g.a.get(e);l || (g.a.set(e, {}), l = g.a.get(e));if (l) for (d in g.c && (l.i[g.c] = !0), l.h) {
        g = h && h[d], l = [d, ": var(", e, "_-_", d], g && l.push(",", g), l.push(")"), m.push(l.join(""));
      }d = m.join("; ");b = "" + f + d + b;G.lastIndex = c + d.length;
    }return b;
  }
  function P(a, b) {
    b = b.split(";");for (var c, d, e = {}, f = 0, h; f < b.length; f++) {
      if (c = b[f]) if (h = c.split(":"), 1 < h.length) {
        c = h[0].trim();var g = a;d = c;h = h.slice(1).join(":");var m = oa.exec(h);m && (m[1] ? (g.b || (g.b = document.createElement("meta"), g.b.setAttribute("apply-shim-measure", ""), g.b.style.all = "initial", document.head.appendChild(g.b)), d = window.getComputedStyle(g.b).getPropertyValue(d)) : d = "apply-shim-inherit", h = d);d = h;e[c] = d;
      }
    }return e;
  }function ra(a, b) {
    if (M) for (var c in b.i) {
      c !== a.c && M(c);
    }
  }
  function qa(a, b, c, d, e) {
    d && K(d, function (b, c) {
      c && a.a.get(c) && (e = "@apply " + c + ";");
    });if (!e) return b;var f = O(a, e),
        h = b.slice(0, b.indexOf("--")),
        g = f = P(a, f),
        m = a.a.get(c),
        l = m && m.h;l ? g = Object.assign(Object.create(l), f) : a.a.set(c, g);var X = [],
        w,
        Y = !1;for (w in g) {
      var D = f[w];void 0 === D && (D = "initial");!l || w in l || (Y = !0);X.push("" + c + "_-_" + w + ": " + D);
    }Y && ra(a, m);m && (m.h = g);d && (h = b + ";" + h);return "" + h + X.join("; ") + ";";
  }N.prototype.detectMixin = N.prototype.o;N.prototype.transformStyle = N.prototype.j;
  N.prototype.transformCustomStyle = N.prototype.f;N.prototype.transformRules = N.prototype.l;N.prototype.transformRule = N.prototype.g;N.prototype.transformTemplate = N.prototype.m;N.prototype._separator = "_-_";Object.defineProperty(N.prototype, "invalidCallback", { get: function get() {
      return M;
    }, set: function set(a) {
      M = a;
    } });var Q = null,
      R = window.HTMLImports && window.HTMLImports.whenReady || null,
      S;function sa(a) {
    requestAnimationFrame(function () {
      R ? R(a) : (Q || (Q = new Promise(function (a) {
        S = a;
      }), "complete" === document.readyState ? S() : document.addEventListener("readystatechange", function () {
        "complete" === document.readyState && S();
      })), Q.then(function () {
        a && a();
      }));
    });
  };var T = new N();function U() {
    var a = this;this.a = null;sa(function () {
      V(a);
    });T.invalidCallback = ka;
  }function V(a) {
    a.a || (a.a = window.ShadyCSS.CustomStyleInterface, a.a && (a.a.transformCallback = function (a) {
      T.f(a);
    }, a.a.validateCallback = function () {
      requestAnimationFrame(function () {
        a.a.enqueued && W(a);
      });
    }));
  }U.prototype.prepareTemplate = function (a, b) {
    V(this);k[b] = a;b = T.m(a, b);a._styleAst = b;
  };
  function W(a) {
    V(a);if (a.a) {
      var b = a.a.processStyles();if (a.a.enqueued) {
        for (var c = 0; c < b.length; c++) {
          var d = a.a.getStyleForCustomStyle(b[c]);d && T.f(d);
        }a.a.enqueued = !1;
      }
    }
  }U.prototype.styleSubtree = function (a, b) {
    V(this);if (b) for (var c in b) {
      null === c ? a.style.removeProperty(c) : a.style.setProperty(c, b[c]);
    }if (a.shadowRoot) for (this.styleElement(a), a = a.shadowRoot.children || a.shadowRoot.childNodes, b = 0; b < a.length; b++) {
      this.styleSubtree(a[b]);
    } else for (a = a.children || a.childNodes, b = 0; b < a.length; b++) {
      this.styleSubtree(a[b]);
    }
  };
  U.prototype.styleElement = function (a) {
    V(this);var b = a.localName,
        c;b ? -1 < b.indexOf("-") ? c = b : c = a.getAttribute && a.getAttribute("is") || "" : c = a.is;if ((b = k[c]) && !z(b)) {
      if (z(b) || b._applyShimValidatingVersion !== b._applyShimNextVersion) this.prepareTemplate(b, c), la(b);if (a = a.shadowRoot) if (a = a.querySelector("style")) a.__cssRules = b._styleAst, a.textContent = H(b._styleAst);
    }
  };U.prototype.styleDocument = function (a) {
    V(this);this.styleSubtree(document.body, a);
  };
  if (!window.ShadyCSS || !window.ShadyCSS.ScopingShim) {
    var Z = new U(),
        ta = window.ShadyCSS && window.ShadyCSS.CustomStyleInterface;window.ShadyCSS = { prepareTemplate: function prepareTemplate(a, b) {
        W(Z);Z.prepareTemplate(a, b);
      }, styleSubtree: function styleSubtree(a, b) {
        W(Z);Z.styleSubtree(a, b);
      }, styleElement: function styleElement(a) {
        W(Z);Z.styleElement(a);
      }, styleDocument: function styleDocument(a) {
        W(Z);Z.styleDocument(a);
      }, getComputedStyleValue: function getComputedStyleValue(a, b) {
        return (a = window.getComputedStyle(a).getPropertyValue(b)) ? a.trim() : "";
      }, nativeCss: E, nativeShadow: A };ta && (window.ShadyCSS.CustomStyleInterface = ta);
  }window.ShadyCSS.ApplyShim = T;
}).call(undefined);

//# sourceMappingURL=apply-shim.min.js.map

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(1);

__webpack_require__(8);

__webpack_require__(12);

(function () {

  'use strict';

  // detect native touch action support

  var HAS_NATIVE_TA = typeof document.head.style.touchAction === 'string';
  var GESTURE_KEY = '__polymerGestures';
  var HANDLED_OBJ = '__polymerGesturesHandled';
  var TOUCH_ACTION = '__polymerGesturesTouchAction';
  // radius for tap and track
  var TAP_DISTANCE = 25;
  var TRACK_DISTANCE = 5;
  // number of last N track positions to keep
  var TRACK_LENGTH = 2;

  // Disabling "mouse" handlers for 2500ms is enough
  var MOUSE_TIMEOUT = 2500;
  var MOUSE_EVENTS = ['mousedown', 'mousemove', 'mouseup', 'click'];
  // an array of bitmask values for mapping MouseEvent.which to MouseEvent.buttons
  var MOUSE_WHICH_TO_BUTTONS = [0, 1, 4, 2];
  var MOUSE_HAS_BUTTONS = function () {
    try {
      return new MouseEvent('test', { buttons: 1 }).buttons === 1;
    } catch (e) {
      return false;
    }
  }();

  /* eslint no-empty: ["error", { "allowEmptyCatch": true }] */
  // check for passive event listeners
  var SUPPORTS_PASSIVE = false;
  (function () {
    try {
      var opts = Object.defineProperty({}, 'passive', { get: function get() {
          SUPPORTS_PASSIVE = true;
        } });
      window.addEventListener('test', null, opts);
      window.removeEventListener('test', null, opts);
    } catch (e) {}
  })();

  // Check for touch-only devices
  var IS_TOUCH_ONLY = navigator.userAgent.match(/iP(?:[oa]d|hone)|Android/);

  var GestureRecognizer = function GestureRecognizer() {}; // eslint-disable-line no-unused-vars
  GestureRecognizer.prototype.reset = function () {};
  /** @type {function(MouseEvent) | undefined} */
  GestureRecognizer.prototype.mousedown;
  /** @type {(function(MouseEvent) | undefined)} */
  GestureRecognizer.prototype.mousemove;
  /** @type {(function(MouseEvent) | undefined)} */
  GestureRecognizer.prototype.mouseup;
  /** @type {(function(TouchEvent) | undefined)} */
  GestureRecognizer.prototype.touchstart;
  /** @type {(function(TouchEvent) | undefined)} */
  GestureRecognizer.prototype.touchmove;
  /** @type {(function(TouchEvent) | undefined)} */
  GestureRecognizer.prototype.touchend;
  /** @type {(function(MouseEvent) | undefined)} */
  GestureRecognizer.prototype.click;

  // touch will make synthetic mouse events
  // `preventDefault` on touchend will cancel them,
  // but this breaks `<input>` focus and link clicks
  // disable mouse handlers for MOUSE_TIMEOUT ms after
  // a touchend to ignore synthetic mouse events
  var mouseCanceller = function mouseCanceller(mouseEvent) {
    // Check for sourceCapabilities, used to distinguish synthetic events
    // if mouseEvent did not come from a device that fires touch events,
    // it was made by a real mouse and should be counted
    // http://wicg.github.io/InputDeviceCapabilities/#dom-inputdevicecapabilities-firestouchevents
    var sc = mouseEvent.sourceCapabilities;
    if (sc && !sc.firesTouchEvents) {
      return;
    }
    // skip synthetic mouse events
    mouseEvent[HANDLED_OBJ] = { skip: true };
    // disable "ghost clicks"
    if (mouseEvent.type === 'click') {
      var path = mouseEvent.composedPath && mouseEvent.composedPath();
      if (path) {
        for (var i = 0; i < path.length; i++) {
          if (path[i] === POINTERSTATE.mouse.target) {
            return;
          }
        }
      }
      mouseEvent.preventDefault();
      mouseEvent.stopPropagation();
    }
  };

  /**
   * @param {boolean=} setup True to add, false to remove.
   */
  function setupTeardownMouseCanceller(setup) {
    var events = IS_TOUCH_ONLY ? ['click'] : MOUSE_EVENTS;
    for (var i = 0, en; i < events.length; i++) {
      en = events[i];
      if (setup) {
        document.addEventListener(en, mouseCanceller, true);
      } else {
        document.removeEventListener(en, mouseCanceller, true);
      }
    }
  }

  function ignoreMouse(e) {
    if (!POINTERSTATE.mouse.mouseIgnoreJob) {
      setupTeardownMouseCanceller(true);
    }
    var unset = function unset() {
      setupTeardownMouseCanceller();
      POINTERSTATE.mouse.target = null;
      POINTERSTATE.mouse.mouseIgnoreJob = null;
    };
    POINTERSTATE.mouse.target = e.composedPath()[0];
    POINTERSTATE.mouse.mouseIgnoreJob = Polymer.Debouncer.debounce(POINTERSTATE.mouse.mouseIgnoreJob, Polymer.Async.timeOut.after(MOUSE_TIMEOUT), unset);
  }

  /**
   * @param {MouseEvent} ev event to test for left mouse button down
   * @return {boolean} has left mouse button down
   */
  function hasLeftMouseButton(ev) {
    var type = ev.type;
    // exit early if the event is not a mouse event
    if (MOUSE_EVENTS.indexOf(type) === -1) {
      return false;
    }
    // ev.button is not reliable for mousemove (0 is overloaded as both left button and no buttons)
    // instead we use ev.buttons (bitmask of buttons) or fall back to ev.which (deprecated, 0 for no buttons, 1 for left button)
    if (type === 'mousemove') {
      // allow undefined for testing events
      var buttons = ev.buttons === undefined ? 1 : ev.buttons;
      if (ev instanceof window.MouseEvent && !MOUSE_HAS_BUTTONS) {
        buttons = MOUSE_WHICH_TO_BUTTONS[ev.which] || 0;
      }
      // buttons is a bitmask, check that the left button bit is set (1)
      return Boolean(buttons & 1);
    } else {
      // allow undefined for testing events
      var button = ev.button === undefined ? 0 : ev.button;
      // ev.button is 0 in mousedown/mouseup/click for left button activation
      return button === 0;
    }
  }

  function isSyntheticClick(ev) {
    if (ev.type === 'click') {
      // ev.detail is 0 for HTMLElement.click in most browsers
      if (ev.detail === 0) {
        return true;
      }
      // in the worst case, check that the x/y position of the click is within
      // the bounding box of the target of the event
      // Thanks IE 10 >:(
      var t = Gestures._findOriginalTarget(ev);
      // make sure the target of the event is an element so we can use getBoundingClientRect,
      // if not, just assume it is a synthetic click
      if (!t.nodeType || /** @type {Element} */t.nodeType !== Node.ELEMENT_NODE) {
        return true;
      }
      var bcr = /** @type {Element} */t.getBoundingClientRect();
      // use page x/y to account for scrolling
      var x = ev.pageX,
          y = ev.pageY;
      // ev is a synthetic click if the position is outside the bounding box of the target
      return !(x >= bcr.left && x <= bcr.right && y >= bcr.top && y <= bcr.bottom);
    }
    return false;
  }

  var POINTERSTATE = {
    mouse: {
      target: null,
      mouseIgnoreJob: null
    },
    touch: {
      x: 0,
      y: 0,
      id: -1,
      scrollDecided: false
    }
  };

  function firstTouchAction(ev) {
    var ta = 'auto';
    var path = ev.composedPath && ev.composedPath();
    if (path) {
      for (var i = 0, n; i < path.length; i++) {
        n = path[i];
        if (n[TOUCH_ACTION]) {
          ta = n[TOUCH_ACTION];
          break;
        }
      }
    }
    return ta;
  }

  function trackDocument(stateObj, movefn, upfn) {
    stateObj.movefn = movefn;
    stateObj.upfn = upfn;
    document.addEventListener('mousemove', movefn);
    document.addEventListener('mouseup', upfn);
  }

  function untrackDocument(stateObj) {
    document.removeEventListener('mousemove', stateObj.movefn);
    document.removeEventListener('mouseup', stateObj.upfn);
    stateObj.movefn = null;
    stateObj.upfn = null;
  }

  // use a document-wide touchend listener to start the ghost-click prevention mechanism
  // Use passive event listeners, if supported, to not affect scrolling performance
  document.addEventListener('touchend', ignoreMouse, SUPPORTS_PASSIVE ? { passive: true } : false);

  /**
   * Module for adding listeners to a node for the following normalized
   * cross-platform "gesture" events:
   * - `down` - mouse or touch went down
   * - `up` - mouse or touch went up
   * - `tap` - mouse click or finger tap
   * - `track` - mouse drag or touch move
   *
   * @namespace
   * @memberof Polymer
   * @summary Module for adding cross-platform gesture event listeners.
   */
  var Gestures = {
    gestures: {},
    recognizers: [],

    /**
     * Finds the element rendered on the screen at the provided coordinates.
     *
     * Similar to `document.elementFromPoint`, but pierces through
     * shadow roots.
     *
     * @memberof Polymer.Gestures
     * @param {number} x Horizontal pixel coordinate
     * @param {number} y Vertical pixel coordinate
     * @return {Element} Returns the deepest shadowRoot inclusive element
     * found at the screen position given.
     */
    deepTargetFind: function deepTargetFind(x, y) {
      var node = document.elementFromPoint(x, y);
      var next = node;
      // this code path is only taken when native ShadowDOM is used
      // if there is a shadowroot, it may have a node at x/y
      // if there is not a shadowroot, exit the loop
      while (next && next.shadowRoot && !window.ShadyDOM) {
        // if there is a node at x/y in the shadowroot, look deeper
        var oldNext = next;
        next = next.shadowRoot.elementFromPoint(x, y);
        // on Safari, elementFromPoint may return the shadowRoot host
        if (oldNext === next) {
          break;
        }
        if (next) {
          node = next;
        }
      }
      return node;
    },
    /**
     * a cheaper check than ev.composedPath()[0];
     *
     * @private
     * @param {Event} ev Event.
     * @return {EventTarget} Returns the event target.
     */
    _findOriginalTarget: function _findOriginalTarget(ev) {
      // shadowdom
      if (ev.composedPath) {
        return (/** @type {EventTarget} */ev.composedPath()[0]
        );
      }
      // shadydom
      return ev.target;
    },

    /**
     * @private
     * @param {Event} ev Event.
     */
    _handleNative: function _handleNative(ev) {
      var handled = void 0;
      var type = ev.type;
      var node = ev.currentTarget;
      var gobj = node[GESTURE_KEY];
      if (!gobj) {
        return;
      }
      var gs = gobj[type];
      if (!gs) {
        return;
      }
      if (!ev[HANDLED_OBJ]) {
        ev[HANDLED_OBJ] = {};
        if (type.slice(0, 5) === 'touch') {
          ev = /** @type {TouchEvent} */ev; // eslint-disable-line no-self-assign
          var t = ev.changedTouches[0];
          if (type === 'touchstart') {
            // only handle the first finger
            if (ev.touches.length === 1) {
              POINTERSTATE.touch.id = t.identifier;
            }
          }
          if (POINTERSTATE.touch.id !== t.identifier) {
            return;
          }
          if (!HAS_NATIVE_TA) {
            if (type === 'touchstart' || type === 'touchmove') {
              Gestures._handleTouchAction(ev);
            }
          }
        }
      }
      handled = ev[HANDLED_OBJ];
      // used to ignore synthetic mouse events
      if (handled.skip) {
        return;
      }
      var recognizers = Gestures.recognizers;
      // reset recognizer state
      for (var i = 0, r; i < recognizers.length; i++) {
        r = recognizers[i];
        if (gs[r.name] && !handled[r.name]) {
          if (r.flow && r.flow.start.indexOf(ev.type) > -1 && r.reset) {
            r.reset();
          }
        }
      }
      // enforce gesture recognizer order
      for (var _i = 0, _r; _i < recognizers.length; _i++) {
        _r = recognizers[_i];
        if (gs[_r.name] && !handled[_r.name]) {
          handled[_r.name] = true;
          _r[type](ev);
        }
      }
    },

    /**
     * @private
     * @param {TouchEvent} ev Event.
     */
    _handleTouchAction: function _handleTouchAction(ev) {
      var t = ev.changedTouches[0];
      var type = ev.type;
      if (type === 'touchstart') {
        POINTERSTATE.touch.x = t.clientX;
        POINTERSTATE.touch.y = t.clientY;
        POINTERSTATE.touch.scrollDecided = false;
      } else if (type === 'touchmove') {
        if (POINTERSTATE.touch.scrollDecided) {
          return;
        }
        POINTERSTATE.touch.scrollDecided = true;
        var ta = firstTouchAction(ev);
        var prevent = false;
        var dx = Math.abs(POINTERSTATE.touch.x - t.clientX);
        var dy = Math.abs(POINTERSTATE.touch.y - t.clientY);
        if (!ev.cancelable) {
          // scrolling is happening
        } else if (ta === 'none') {
          prevent = true;
        } else if (ta === 'pan-x') {
          prevent = dy > dx;
        } else if (ta === 'pan-y') {
          prevent = dx > dy;
        }
        if (prevent) {
          ev.preventDefault();
        } else {
          Gestures.prevent('track');
        }
      }
    },

    /**
     * Adds an event listener to a node for the given gesture type.
     *
     * @memberof Polymer.Gestures
     * @param {Node} node Node to add listener on
     * @param {string} evType Gesture type: `down`, `up`, `track`, or `tap`
     * @param {Function} handler Event listener function to call
     * @return {boolean} Returns true if a gesture event listener was added.
     * @this {Gestures}
     */
    addListener: function addListener(node, evType, handler) {
      if (this.gestures[evType]) {
        this._add(node, evType, handler);
        return true;
      }
      return false;
    },

    /**
     * Removes an event listener from a node for the given gesture type.
     *
     * @memberof Polymer.Gestures
     * @param {Node} node Node to remove listener from
     * @param {string} evType Gesture type: `down`, `up`, `track`, or `tap`
     * @param {Function} handler Event listener function previously passed to
     *  `addListener`.
     * @return {boolean} Returns true if a gesture event listener was removed.
     * @this {Gestures}
     */
    removeListener: function removeListener(node, evType, handler) {
      if (this.gestures[evType]) {
        this._remove(node, evType, handler);
        return true;
      }
      return false;
    },

    /**
     * automate the event listeners for the native events
     *
     * @private
     * @param {HTMLElement} node Node on which to add the event.
     * @param {string} evType Event type to add.
     * @param {function(Event?)} handler Event handler function.
     * @this {Gestures}
     */
    _add: function _add(node, evType, handler) {
      var recognizer = this.gestures[evType];
      var deps = recognizer.deps;
      var name = recognizer.name;
      var gobj = node[GESTURE_KEY];
      if (!gobj) {
        node[GESTURE_KEY] = gobj = {};
      }
      for (var i = 0, dep, gd; i < deps.length; i++) {
        dep = deps[i];
        // don't add mouse handlers on iOS because they cause gray selection overlays
        if (IS_TOUCH_ONLY && MOUSE_EVENTS.indexOf(dep) > -1 && dep !== 'click') {
          continue;
        }
        gd = gobj[dep];
        if (!gd) {
          gobj[dep] = gd = { _count: 0 };
        }
        if (gd._count === 0) {
          node.addEventListener(dep, this._handleNative);
        }
        gd[name] = (gd[name] || 0) + 1;
        gd._count = (gd._count || 0) + 1;
      }
      node.addEventListener(evType, handler);
      if (recognizer.touchAction) {
        this.setTouchAction(node, recognizer.touchAction);
      }
    },

    /**
     * automate event listener removal for native events
     *
     * @private
     * @param {HTMLElement} node Node on which to remove the event.
     * @param {string} evType Event type to remove.
     * @param {function(Event?)} handler Event handler function.
     * @this {Gestures}
     */
    _remove: function _remove(node, evType, handler) {
      var recognizer = this.gestures[evType];
      var deps = recognizer.deps;
      var name = recognizer.name;
      var gobj = node[GESTURE_KEY];
      if (gobj) {
        for (var i = 0, dep, gd; i < deps.length; i++) {
          dep = deps[i];
          gd = gobj[dep];
          if (gd && gd[name]) {
            gd[name] = (gd[name] || 1) - 1;
            gd._count = (gd._count || 1) - 1;
            if (gd._count === 0) {
              node.removeEventListener(dep, this._handleNative);
            }
          }
        }
      }
      node.removeEventListener(evType, handler);
    },

    /**
     * Registers a new gesture event recognizer for adding new custom
     * gesture event types.
     *
     * @memberof Polymer.Gestures
     * @param {GestureRecognizer} recog Gesture recognizer descriptor
     * @this {Gestures}
     */
    register: function register(recog) {
      this.recognizers.push(recog);
      for (var i = 0; i < recog.emits.length; i++) {
        this.gestures[recog.emits[i]] = recog;
      }
    },

    /**
     * @private
     * @param {string} evName Event name.
     * @return {Object} Returns the gesture for the given event name.
     * @this {Gestures}
     */
    _findRecognizerByEvent: function _findRecognizerByEvent(evName) {
      for (var i = 0, r; i < this.recognizers.length; i++) {
        r = this.recognizers[i];
        for (var j = 0, n; j < r.emits.length; j++) {
          n = r.emits[j];
          if (n === evName) {
            return r;
          }
        }
      }
      return null;
    },

    /**
     * Sets scrolling direction on node.
     *
     * This value is checked on first move, thus it should be called prior to
     * adding event listeners.
     *
     * @memberof Polymer.Gestures
     * @param {Element} node Node to set touch action setting on
     * @param {string} value Touch action value
     */
    setTouchAction: function setTouchAction(node, value) {
      if (HAS_NATIVE_TA) {
        node.style.touchAction = value;
      }
      node[TOUCH_ACTION] = value;
    },

    /**
     * Dispatches an event on the `target` element of `type` with the given
     * `detail`.
     * @private
     * @param {EventTarget} target The element on which to fire an event.
     * @param {string} type The type of event to fire.
     * @param {Object=} detail The detail object to populate on the event.
     */
    _fire: function _fire(target, type, detail) {
      var ev = new Event(type, { bubbles: true, cancelable: true, composed: true });
      ev.detail = detail;
      target.dispatchEvent(ev);
      // forward `preventDefault` in a clean way
      if (ev.defaultPrevented) {
        var preventer = detail.preventer || detail.sourceEvent;
        if (preventer && preventer.preventDefault) {
          preventer.preventDefault();
        }
      }
    },

    /**
     * Prevents the dispatch and default action of the given event name.
     *
     * @memberof Polymer.Gestures
     * @param {string} evName Event name.
     * @this {Gestures}
     */
    prevent: function prevent(evName) {
      var recognizer = this._findRecognizerByEvent(evName);
      if (recognizer.info) {
        recognizer.info.prevent = true;
      }
    },

    /**
     * Reset the 2500ms timeout on processing mouse input after detecting touch input.
     *
     * Touch inputs create synthesized mouse inputs anywhere from 0 to 2000ms after the touch.
     * This method should only be called during testing with simulated touch inputs.
     * Calling this method in production may cause duplicate taps or other Gestures.
     *
     * @memberof Polymer.Gestures
     */
    resetMouseCanceller: function resetMouseCanceller() {
      if (POINTERSTATE.mouse.mouseIgnoreJob) {
        POINTERSTATE.mouse.mouseIgnoreJob.flush();
      }
    }
  };

  /* eslint-disable valid-jsdoc */

  Gestures.register({
    name: 'downup',
    deps: ['mousedown', 'touchstart', 'touchend'],
    flow: {
      start: ['mousedown', 'touchstart'],
      end: ['mouseup', 'touchend']
    },
    emits: ['down', 'up'],

    info: {
      movefn: null,
      upfn: null
    },

    /** @this {GestureRecognizer} */
    reset: function reset() {
      untrackDocument(this.info);
    },

    /**
     * @this {GestureRecognizer}
     * @param {MouseEvent} e
     */
    mousedown: function mousedown(e) {
      if (!hasLeftMouseButton(e)) {
        return;
      }
      var t = Gestures._findOriginalTarget(e);
      var self = this;
      var movefn = function movefn(e) {
        if (!hasLeftMouseButton(e)) {
          self._fire('up', t, e);
          untrackDocument(self.info);
        }
      };
      var upfn = function upfn(e) {
        if (hasLeftMouseButton(e)) {
          self._fire('up', t, e);
        }
        untrackDocument(self.info);
      };
      trackDocument(this.info, movefn, upfn);
      this._fire('down', t, e);
    },
    /**
     * @this {GestureRecognizer}
     * @param {TouchEvent} e
     */
    touchstart: function touchstart(e) {
      this._fire('down', Gestures._findOriginalTarget(e), e.changedTouches[0], e);
    },
    /**
     * @this {GestureRecognizer}
     * @param {TouchEvent} e
     */
    touchend: function touchend(e) {
      this._fire('up', Gestures._findOriginalTarget(e), e.changedTouches[0], e);
    },
    /**
     * @param {string} type
     * @param {EventTarget} target
     * @param {Event} event
     * @param {Function} preventer
     */
    _fire: function _fire(type, target, event, preventer) {
      Gestures._fire(target, type, {
        x: event.clientX,
        y: event.clientY,
        sourceEvent: event,
        preventer: preventer,
        prevent: function prevent(e) {
          return Gestures.prevent(e);
        }
      });
    }
  });

  Gestures.register({
    name: 'track',
    touchAction: 'none',
    deps: ['mousedown', 'touchstart', 'touchmove', 'touchend'],
    flow: {
      start: ['mousedown', 'touchstart'],
      end: ['mouseup', 'touchend']
    },
    emits: ['track'],

    info: {
      x: 0,
      y: 0,
      state: 'start',
      started: false,
      moves: [],
      /** @this {GestureRecognizer} */
      addMove: function addMove(move) {
        if (this.moves.length > TRACK_LENGTH) {
          this.moves.shift();
        }
        this.moves.push(move);
      },
      movefn: null,
      upfn: null,
      prevent: false
    },

    /** @this {GestureRecognizer} */
    reset: function reset() {
      this.info.state = 'start';
      this.info.started = false;
      this.info.moves = [];
      this.info.x = 0;
      this.info.y = 0;
      this.info.prevent = false;
      untrackDocument(this.info);
    },

    /**
     * @this {GestureRecognizer}
     * @param {number} x
     * @param {number} y
     * @return {boolean}
     */
    hasMovedEnough: function hasMovedEnough(x, y) {
      if (this.info.prevent) {
        return false;
      }
      if (this.info.started) {
        return true;
      }
      var dx = Math.abs(this.info.x - x);
      var dy = Math.abs(this.info.y - y);
      return dx >= TRACK_DISTANCE || dy >= TRACK_DISTANCE;
    },
    /**
     * @this {GestureRecognizer}
     * @param {MouseEvent} e
     */
    mousedown: function mousedown(e) {
      if (!hasLeftMouseButton(e)) {
        return;
      }
      var t = Gestures._findOriginalTarget(e);
      var self = this;
      var movefn = function movefn(e) {
        var x = e.clientX,
            y = e.clientY;
        if (self.hasMovedEnough(x, y)) {
          // first move is 'start', subsequent moves are 'move', mouseup is 'end'
          self.info.state = self.info.started ? e.type === 'mouseup' ? 'end' : 'track' : 'start';
          if (self.info.state === 'start') {
            // if and only if tracking, always prevent tap
            Gestures.prevent('tap');
          }
          self.info.addMove({ x: x, y: y });
          if (!hasLeftMouseButton(e)) {
            // always _fire "end"
            self.info.state = 'end';
            untrackDocument(self.info);
          }
          self._fire(t, e);
          self.info.started = true;
        }
      };
      var upfn = function upfn(e) {
        if (self.info.started) {
          movefn(e);
        }

        // remove the temporary listeners
        untrackDocument(self.info);
      };
      // add temporary document listeners as mouse retargets
      trackDocument(this.info, movefn, upfn);
      this.info.x = e.clientX;
      this.info.y = e.clientY;
    },
    /**
     * @this {GestureRecognizer}
     * @param {TouchEvent} e
     */
    touchstart: function touchstart(e) {
      var ct = e.changedTouches[0];
      this.info.x = ct.clientX;
      this.info.y = ct.clientY;
    },
    /**
     * @this {GestureRecognizer}
     * @param {TouchEvent} e
     */
    touchmove: function touchmove(e) {
      var t = Gestures._findOriginalTarget(e);
      var ct = e.changedTouches[0];
      var x = ct.clientX,
          y = ct.clientY;
      if (this.hasMovedEnough(x, y)) {
        if (this.info.state === 'start') {
          // if and only if tracking, always prevent tap
          Gestures.prevent('tap');
        }
        this.info.addMove({ x: x, y: y });
        this._fire(t, ct);
        this.info.state = 'track';
        this.info.started = true;
      }
    },
    /**
     * @this {GestureRecognizer}
     * @param {TouchEvent} e
     */
    touchend: function touchend(e) {
      var t = Gestures._findOriginalTarget(e);
      var ct = e.changedTouches[0];
      // only trackend if track was started and not aborted
      if (this.info.started) {
        // reset started state on up
        this.info.state = 'end';
        this.info.addMove({ x: ct.clientX, y: ct.clientY });
        this._fire(t, ct, e);
      }
    },

    /**
     * @this {GestureRecognizer}
     * @param {EventTarget} target
     * @param {Touch} touch
     */
    _fire: function _fire(target, touch) {
      var secondlast = this.info.moves[this.info.moves.length - 2];
      var lastmove = this.info.moves[this.info.moves.length - 1];
      var dx = lastmove.x - this.info.x;
      var dy = lastmove.y - this.info.y;
      var ddx = void 0,
          ddy = 0;
      if (secondlast) {
        ddx = lastmove.x - secondlast.x;
        ddy = lastmove.y - secondlast.y;
      }
      Gestures._fire(target, 'track', {
        state: this.info.state,
        x: touch.clientX,
        y: touch.clientY,
        dx: dx,
        dy: dy,
        ddx: ddx,
        ddy: ddy,
        sourceEvent: touch,
        hover: function hover() {
          return Gestures.deepTargetFind(touch.clientX, touch.clientY);
        }
      });
    }

  });

  Gestures.register({
    name: 'tap',
    deps: ['mousedown', 'click', 'touchstart', 'touchend'],
    flow: {
      start: ['mousedown', 'touchstart'],
      end: ['click', 'touchend']
    },
    emits: ['tap'],
    info: {
      x: NaN,
      y: NaN,
      prevent: false
    },
    /** @this {GestureRecognizer} */
    reset: function reset() {
      this.info.x = NaN;
      this.info.y = NaN;
      this.info.prevent = false;
    },
    /** @this {GestureRecognizer} */
    save: function save(e) {
      this.info.x = e.clientX;
      this.info.y = e.clientY;
    },
    /**
     * @this {GestureRecognizer}
     * @param {MouseEvent} e
     */
    mousedown: function mousedown(e) {
      if (hasLeftMouseButton(e)) {
        this.save(e);
      }
    },
    /**
     * @this {GestureRecognizer}
     * @param {MouseEvent} e
     */
    click: function click(e) {
      if (hasLeftMouseButton(e)) {
        this.forward(e);
      }
    },
    /**
     * @this {GestureRecognizer}
     * @param {TouchEvent} e
     */
    touchstart: function touchstart(e) {
      this.save(e.changedTouches[0], e);
    },
    /**
     * @this {GestureRecognizer}
     * @param {TouchEvent} e
     */
    touchend: function touchend(e) {
      this.forward(e.changedTouches[0], e);
    },
    /**
     * @this {GestureRecognizer}
     * @param {Event} e
     * @param {Function} preventer
     */
    forward: function forward(e, preventer) {
      var dx = Math.abs(e.clientX - this.info.x);
      var dy = Math.abs(e.clientY - this.info.y);
      var t = Gestures._findOriginalTarget(e);
      // dx,dy can be NaN if `click` has been simulated and there was no `down` for `start`
      if (isNaN(dx) || isNaN(dy) || dx <= TAP_DISTANCE && dy <= TAP_DISTANCE || isSyntheticClick(e)) {
        // prevent taps from being generated if an event has canceled them
        if (!this.info.prevent) {
          Gestures._fire(t, 'tap', {
            x: e.clientX,
            y: e.clientY,
            sourceEvent: e,
            preventer: preventer
          });
        }
      }
    }
  });

  /* eslint-enable valid-jsdoc */

  /** @deprecated */
  Gestures.findOriginalTarget = Gestures._findOriginalTarget;

  /** @deprecated */
  Gestures.add = Gestures.addListener;

  /** @deprecated */
  Gestures.remove = Gestures.removeListener;

  Polymer.Gestures = Gestures;
})();

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(1);

(function () {

  'use strict';

  // run a callback when HTMLImports are ready or immediately if
  // this api is not available.

  function whenImportsReady(cb) {
    if (window.HTMLImports) {
      HTMLImports.whenReady(cb);
    } else {
      cb();
    }
  }

  /**
   * Convenience method for importing an HTML document imperatively.
   *
   * This method creates a new `<link rel="import">` element with
   * the provided URL and appends it to the document to start loading.
   * In the `onload` callback, the `import` property of the `link`
   * element will contain the imported document contents.
   *
   * @memberof Polymer
   * @param {string} href URL to document to load.
   * @param {Function=} onload Callback to notify when an import successfully
   *   loaded.
   * @param {Function=} onerror Callback to notify when an import
   *   unsuccessfully loaded.
   * @param {boolean=} optAsync True if the import should be loaded `async`.
   *   Defaults to `false`.
   * @return {HTMLLinkElement} The link element for the URL to be loaded.
   */
  Polymer.importHref = function (href, onload, onerror, optAsync) {
    var link = /** @type {HTMLLinkElement} */
    document.head.querySelector('link[href="' + href + '"][import-href]');
    if (!link) {
      link = /** @type {HTMLLinkElement} */document.createElement('link');
      link.rel = 'import';
      link.href = href;
      link.setAttribute('import-href', '');
    }
    // always ensure link has `async` attribute if user specified one,
    // even if it was previously not async. This is considered less confusing.
    if (optAsync) {
      link.setAttribute('async', '');
    }
    // NOTE: the link may now be in 3 states: (1) pending insertion,
    // (2) inflight, (3) already laoded. In each case, we need to add
    // event listeners to process callbacks.
    var cleanup = function cleanup() {
      link.removeEventListener('load', loadListener);
      link.removeEventListener('error', errorListener);
    };
    var loadListener = function loadListener(event) {
      cleanup();
      // In case of a successful load, cache the load event on the link so
      // that it can be used to short-circuit this method in the future when
      // it is called with the same href param.
      link.__dynamicImportLoaded = true;
      if (onload) {
        whenImportsReady(function () {
          onload(event);
        });
      }
    };
    var errorListener = function errorListener(event) {
      cleanup();
      // In case of an error, remove the link from the document so that it
      // will be automatically created again the next time `importHref` is
      // called.
      if (link.parentNode) {
        link.parentNode.removeChild(link);
      }
      if (onerror) {
        whenImportsReady(function () {
          onerror(event);
        });
      }
    };
    link.addEventListener('load', loadListener);
    link.addEventListener('error', errorListener);
    if (link.parentNode == null) {
      document.head.appendChild(link);
      // if the link already loaded, dispatch a fake load event
      // so that listeners are called and get a proper event argument.
    } else if (link.__dynamicImportLoaded) {
      link.dispatchEvent(new Event('load'));
    }
    return link;
  };
})();

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(1);

(function () {

  'use strict';

  var scheduled = false;
  var beforeRenderQueue = [];
  var afterRenderQueue = [];

  function schedule() {
    scheduled = true;
    // before next render
    requestAnimationFrame(function () {
      scheduled = false;
      flushQueue(beforeRenderQueue);
      // after the render
      setTimeout(function () {
        runQueue(afterRenderQueue);
      });
    });
  }

  function flushQueue(queue) {
    while (queue.length) {
      callMethod(queue.shift());
    }
  }

  function runQueue(queue) {
    for (var i = 0, l = queue.length; i < l; i++) {
      callMethod(queue.shift());
    }
  }

  function callMethod(info) {
    var context = info[0];
    var callback = info[1];
    var args = info[2];
    try {
      callback.apply(context, args);
    } catch (e) {
      setTimeout(function () {
        throw e;
      });
    }
  }

  function flush() {
    while (beforeRenderQueue.length || afterRenderQueue.length) {
      flushQueue(beforeRenderQueue);
      flushQueue(afterRenderQueue);
    }
    scheduled = false;
  }

  /**
   * Module for scheduling flushable pre-render and post-render tasks.
   *
   * @namespace
   * @memberof Polymer
   * @summary Module for scheduling flushable pre-render and post-render tasks.
   */
  Polymer.RenderStatus = {

    /**
     * Enqueues a callback which will be run before the next render, at
     * `requestAnimationFrame` timing.
     *
     * This method is useful for enqueuing work that requires DOM measurement,
     * since measurement may not be reliable in custom element callbacks before
     * the first render, as well as for batching measurement tasks in general.
     *
     * Tasks in this queue may be flushed by calling `Polymer.RenderStatus.flush()`.
     *
     * @memberof Polymer.RenderStatus
     * @param {*} context Context object the callback function will be bound to
     * @param {function()} callback Callback function
     * @param {Array} args An array of arguments to call the callback function with
     */
    beforeNextRender: function beforeNextRender(context, callback, args) {
      if (!scheduled) {
        schedule();
      }
      beforeRenderQueue.push([context, callback, args]);
    },

    /**
     * Enqueues a callback which will be run after the next render, equivalent
     * to one task (`setTimeout`) after the next `requestAnimationFrame`.
     *
     * This method is useful for tuning the first-render performance of an
     * element or application by deferring non-critical work until after the
     * first paint.  Typical non-render-critical work may include adding UI
     * event listeners and aria attributes.
     *
     * @memberof Polymer.RenderStatus
     * @param {*} context Context object the callback function will be bound to
     * @param {function()} callback Callback function
     * @param {Array} args An array of arguments to call the callback function with
     */
    afterNextRender: function afterNextRender(context, callback, args) {
      if (!scheduled) {
        schedule();
      }
      afterRenderQueue.push([context, callback, args]);
    },

    /**
     * Flushes all `beforeNextRender` tasks, followed by all `afterNextRender`
     * tasks.
     *
     * @memberof Polymer.RenderStatus
     */
    flush: flush

  };
})();

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


(function () {
  'use strict';

  // unresolved

  function resolve() {
    document.body.removeAttribute('unresolved');
  }

  if (window.WebComponents) {
    window.addEventListener('WebComponentsReady', resolve);
  } else {
    if (document.readyState === 'interactive' || document.readyState === 'complete') {
      resolve();
    } else {
      window.addEventListener('DOMContentLoaded', resolve);
    }
  }
})();

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

__webpack_require__(1);

__webpack_require__(20);

__webpack_require__(53);

__webpack_require__(13);

(function () {
  'use strict';

  var p = Element.prototype;
  /**
   * @const {function(this:Element, string): boolean}
   */
  var normalizedMatchesSelector = p.matches || p.matchesSelector || p.mozMatchesSelector || p.msMatchesSelector || p.oMatchesSelector || p.webkitMatchesSelector;

  /**
   * Cross-platform `element.matches` shim.
   *
   * @function matchesSelector
   * @memberof Polymer.dom
   * @param {!Element} node Node to check selector against
   * @param {string} selector Selector to match
   * @return {boolean} True if node matched selector
   */
  var matchesSelector = function matchesSelector(node, selector) {
    return normalizedMatchesSelector.call(node, selector);
  };

  /**
   * Node API wrapper class returned from `Polymer.dom.(target)` when
   * `target` is a `Node`.
   */

  var DomApi = function () {

    /**
     * @param {Node} node Node for which to create a Polymer.dom helper object.
     */
    function DomApi(node) {
      _classCallCheck(this, DomApi);

      this.node = node;
    }

    /**
     * Returns an instance of `Polymer.FlattenedNodesObserver` that
     * listens for node changes on this element.
     *
     * @param {Function} callback Called when direct or distributed children
     *   of this element changes
     * @return {Polymer.FlattenedNodesObserver} Observer instance
     */


    _createClass(DomApi, [{
      key: 'observeNodes',
      value: function observeNodes(callback) {
        return new Polymer.FlattenedNodesObserver(this.node, callback);
      }

      /**
       * Disconnects an observer previously created via `observeNodes`
       *
       * @param {Polymer.FlattenedNodesObserver} observerHandle Observer instance
       *   to disconnect.
       */

    }, {
      key: 'unobserveNodes',
      value: function unobserveNodes(observerHandle) {
        observerHandle.disconnect();
      }

      /**
       * Provided as a backwards-compatible API only.  This method does nothing.
       */

    }, {
      key: 'notifyObserver',
      value: function notifyObserver() {}

      /**
       * Returns true if the provided node is contained with this element's
       * light-DOM children or shadow root, including any nested shadow roots
       * of children therein.
       *
       * @param {Node} node Node to test
       * @return {boolean} Returns true if the given `node` is contained within
       *   this element's light or shadow DOM.
       */

    }, {
      key: 'deepContains',
      value: function deepContains(node) {
        if (this.node.contains(node)) {
          return true;
        }
        var n = node;
        var doc = node.ownerDocument;
        // walk from node to `this` or `document`
        while (n && n !== doc && n !== this.node) {
          // use logical parentnode, or native ShadowRoot host
          n = n.parentNode || n.host;
        }
        return n === this.node;
      }

      /**
       * Returns the root node of this node.  Equivalent to `getRoodNode()`.
       *
       * @return {Node} Top most element in the dom tree in which the node
       * exists. If the node is connected to a document this is either a
       * shadowRoot or the document; otherwise, it may be the node
       * itself or a node or document fragment containing it.
       */

    }, {
      key: 'getOwnerRoot',
      value: function getOwnerRoot() {
        return this.node.getRootNode();
      }

      /**
       * For slot elements, returns the nodes assigned to the slot; otherwise
       * an empty array. It is equivalent to `<slot>.addignedNodes({flatten:true})`.
       *
       * @return {Array<Node>} Array of assigned nodes
       */

    }, {
      key: 'getDistributedNodes',
      value: function getDistributedNodes() {
        return this.node.localName === 'slot' ? this.node.assignedNodes({ flatten: true }) : [];
      }

      /**
       * Returns an array of all slots this element was distributed to.
       *
       * @return {Array<HTMLSlotElement>} Description
       */

    }, {
      key: 'getDestinationInsertionPoints',
      value: function getDestinationInsertionPoints() {
        var ip$ = [];
        var n = this.node.assignedSlot;
        while (n) {
          ip$.push(n);
          n = n.assignedSlot;
        }
        return ip$;
      }

      /**
       * Calls `importNode` on the `ownerDocument` for this node.
       *
       * @param {Node} node Node to import
       * @param {boolean} deep True if the node should be cloned deeply during
       *   import
       * @return {Node} Clone of given node imported to this owner document
       */

    }, {
      key: 'importNode',
      value: function importNode(node, deep) {
        var doc = this.node instanceof Document ? this.node : this.node.ownerDocument;
        return doc.importNode(node, deep);
      }

      /**
       * @return {Array} Returns a flattened list of all child nodes and nodes assigned
       * to child slots.
       */

    }, {
      key: 'getEffectiveChildNodes',
      value: function getEffectiveChildNodes() {
        return Polymer.FlattenedNodesObserver.getFlattenedNodes(this.node);
      }

      /**
       * Returns a filtered list of flattened child elements for this element based
       * on the given selector.
       *
       * @param {string} selector Selector to filter nodes against
       * @return {Array<HTMLElement>} List of flattened child elements
       */

    }, {
      key: 'queryDistributedElements',
      value: function queryDistributedElements(selector) {
        var c$ = this.getEffectiveChildNodes();
        var list = [];
        for (var i = 0, l = c$.length, c; i < l && (c = c$[i]); i++) {
          if (c.nodeType === Node.ELEMENT_NODE && matchesSelector(c, selector)) {
            list.push(c);
          }
        }
        return list;
      }

      /**
       * For shadow roots, returns the currently focused element within this
       * shadow root.
       *
       * @return {Node|undefined} Currently focused element
       */

    }, {
      key: 'activeElement',
      get: function get() {
        var node = this.node;
        return node._activeElement !== undefined ? node._activeElement : node.activeElement;
      }
    }]);

    return DomApi;
  }();

  function forwardMethods(proto, methods) {
    var _loop = function _loop(i) {
      var method = methods[i];
      proto[method] = /** @this {DomApi} */function () {
        return this.node[method].apply(this.node, arguments);
      };
    };

    for (var i = 0; i < methods.length; i++) {
      _loop(i);
    }
  }

  function forwardReadOnlyProperties(proto, properties) {
    var _loop2 = function _loop2(i) {
      var name = properties[i];
      Object.defineProperty(proto, name, {
        get: function get() {
          return (/** @type {DomApi} */this.node[name]
          );
        },
        configurable: true
      });
    };

    for (var i = 0; i < properties.length; i++) {
      _loop2(i);
    }
  }

  function forwardProperties(proto, properties) {
    var _loop3 = function _loop3(i) {
      var name = properties[i];
      Object.defineProperty(proto, name, {
        get: function get() {
          return (/** @type {DomApi} */this.node[name]
          );
        },
        set: function set(value) {
          /** @type {DomApi} */this.node[name] = value;
        },
        configurable: true
      });
    };

    for (var i = 0; i < properties.length; i++) {
      _loop3(i);
    }
  }

  forwardMethods(DomApi.prototype, ['cloneNode', 'appendChild', 'insertBefore', 'removeChild', 'replaceChild', 'setAttribute', 'removeAttribute', 'querySelector', 'querySelectorAll']);

  forwardReadOnlyProperties(DomApi.prototype, ['parentNode', 'firstChild', 'lastChild', 'nextSibling', 'previousSibling', 'firstElementChild', 'lastElementChild', 'nextElementSibling', 'previousElementSibling', 'childNodes', 'children', 'classList']);

  forwardProperties(DomApi.prototype, ['textContent', 'innerHTML']);

  /**
   * Event API wrapper class returned from `Polymer.dom.(target)` when
   * `target` is an `Event`.
   */

  var EventApi = function () {
    function EventApi(event) {
      _classCallCheck(this, EventApi);

      this.event = event;
    }

    /**
     * Returns the first node on the `composedPath` of this event.
     *
     * @return {Node} The node this event was dispatched to
     */


    _createClass(EventApi, [{
      key: 'rootTarget',
      get: function get() {
        return this.event.composedPath()[0];
      }

      /**
       * Returns the local (re-targeted) target for this event.
       *
       * @return {Node} The local (re-targeted) target for this event.
       */

    }, {
      key: 'localTarget',
      get: function get() {
        return this.event.target;
      }

      /**
       * Returns the `composedPath` for this event.
       */

    }, {
      key: 'path',
      get: function get() {
        return this.event.composedPath();
      }
    }]);

    return EventApi;
  }();

  Polymer.DomApi = DomApi;

  /**
   * Legacy DOM and Event manipulation API wrapper factory used to abstract
   * differences between native Shadow DOM and "Shady DOM" when polyfilling on
   * older browsers.
   *
   * Note that in Polymer 2.x use of `Polymer.dom` is no longer required and
   * in the majority of cases simply facades directly to the standard native
   * API.
   *
   * @namespace
   * @summary Legacy DOM and Event manipulation API wrapper factory used to
   * abstract differences between native Shadow DOM and "Shady DOM."
   * @memberof Polymer
   * @param {!Node|Event} obj Node or event to operate on
   * @return {DomApi|EventApi} Wrapper providing either node API or event API
   */
  Polymer.dom = function (obj) {
    obj = obj || document;
    if (!obj.__domApi) {
      var helper = void 0;
      if (obj instanceof Event) {
        helper = new EventApi(obj);
      } else {
        helper = new DomApi(obj);
      }
      obj.__domApi = helper;
    }
    return obj.__domApi;
  };

  Polymer.dom.matchesSelector = matchesSelector;

  /**
   * Forces several classes of asynchronously queued tasks to flush:
   * - Debouncers added via `Polymer.enqueueDebouncer`
   * - ShadyDOM distribution
   *
   * This method facades to `Polymer.flush`.
   *
   * @memberof Polymer.dom
   */
  Polymer.dom.flush = Polymer.flush;

  /**
   * Adds a `Polymer.Debouncer` to a list of globally flushable tasks.
   *
   * This method facades to `Polymer.enqueueDebouncer`.
   *
   * @memberof Polymer.dom
   * @param {Polymer.Debouncer} debouncer Debouncer to enqueue
   */
  Polymer.dom.addDebouncer = Polymer.enqueueDebouncer;
})();

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

__webpack_require__(1);

__webpack_require__(24);

__webpack_require__(8);

(function () {
  'use strict';

  /**
   * Returns true if `node` is a slot element
   * @param {HTMLElement} node Node to test.
   * @return {boolean} Returns true if the given `node` is a slot
   * @private
   */

  function isSlot(node) {
    return node.localName === 'slot';
  }

  /**
   * Class that listens for changes (additions or removals) to
   * "flattened nodes" on a given `node`. The list of flattened nodes consists
   * of a node's children and, for any children that are `<slot>` elements,
   * the expanded flattened list of `assignedNodes`.
   * For example, if the observed node has children `<a></a><slot></slot><b></b>`
   * and the `<slot>` has one `<div>` assigned to it, then the flattened
   * nodes list is `<a></a><div></div><b></b>`. If the `<slot>` has other
   * `<slot>` elements assigned to it, these are flattened as well.
   *
   * The provided `callback` is called whenever any change to this list
   * of flattened nodes occurs, where an addition or removal of a node is
   * considered a change. The `callback` is called with one argument, an object
   * containing an array of any `addedNodes` and `removedNodes`.
   *
   * Note: the callback is called asynchronous to any changes
   * at a microtask checkpoint. This is because observation is performed using
   * `MutationObserver` and the `<slot>` element's `slotchange` event which
   * are asynchronous.
   *
   * @memberof Polymer
   * @summary Class that listens for changes (additions or removals) to
   * "flattened nodes" on a given `node`.
   */

  var FlattenedNodesObserver = function () {
    _createClass(FlattenedNodesObserver, null, [{
      key: 'getFlattenedNodes',


      /**
       * Returns the list of flattened nodes for the given `node`.
       * This list consists of a node's children and, for any children
       * that are `<slot>` elements, the expanded flattened list of `assignedNodes`.
       * For example, if the observed node has children `<a></a><slot></slot><b></b>`
       * and the `<slot>` has one `<div>` assigned to it, then the flattened
       * nodes list is `<a></a><div></div><b></b>`. If the `<slot>` has other
       * `<slot>` elements assigned to it, these are flattened as well.
       *
       * @param {HTMLElement|HTMLSlotElement} node The node for which to return the list of flattened nodes.
       * @return {Array} The list of flattened nodes for the given `node`.
      */
      value: function getFlattenedNodes(node) {
        if (isSlot(node)) {
          return (/** @type {HTMLSlotElement} */node.assignedNodes({ flatten: true })
          );
        } else {
          return Array.from(node.childNodes).map(function (node) {
            if (isSlot(node)) {
              return (/** @type {HTMLSlotElement} */node.assignedNodes({ flatten: true })
              );
            } else {
              return [node];
            }
          }).reduce(function (a, b) {
            return a.concat(b);
          }, []);
        }
      }

      /**
       * @param {Node} target Node on which to listen for changes.
       * @param {Function} callback Function called when there are additions
       * or removals from the target's list of flattened nodes.
      */

    }]);

    function FlattenedNodesObserver(target, callback) {
      var _this = this;

      _classCallCheck(this, FlattenedNodesObserver);

      /** @type {MutationObserver} */
      this._shadyChildrenObserver = null;
      /** @type {MutationObserver} */
      this._nativeChildrenObserver = null;
      this._connected = false;
      this._target = target;
      this.callback = callback;
      this._effectiveNodes = [];
      this._observer = null;
      this._scheduled = false;
      /** @type {function()} */
      this._boundSchedule = function () {
        _this._schedule();
      };
      this.connect();
      this._schedule();
    }

    /**
     * Activates an observer. This method is automatically called when
     * a `FlattenedNodesObserver` is created. It should only be called to
     * re-activate an observer that has been deactivated via the `disconnect` method.
     */


    _createClass(FlattenedNodesObserver, [{
      key: 'connect',
      value: function connect() {
        var _this2 = this;

        if (isSlot(this._target)) {
          this._listenSlots([this._target]);
        } else {
          this._listenSlots(this._target.children);
          if (window.ShadyDOM) {
            this._shadyChildrenObserver = ShadyDOM.observeChildren(this._target, function (mutations) {
              _this2._processMutations(mutations);
            });
          } else {
            this._nativeChildrenObserver = new MutationObserver(function (mutations) {
              _this2._processMutations(mutations);
            });
            this._nativeChildrenObserver.observe(this._target, { childList: true });
          }
        }
        this._connected = true;
      }

      /**
       * Deactivates the flattened nodes observer. After calling this method
       * the observer callback will not be called when changes to flattened nodes
       * occur. The `connect` method may be subsequently called to reactivate
       * the observer.
       */

    }, {
      key: 'disconnect',
      value: function disconnect() {
        if (isSlot(this._target)) {
          this._unlistenSlots([this._target]);
        } else {
          this._unlistenSlots(this._target.children);
          if (window.ShadyDOM && this._shadyChildrenObserver) {
            ShadyDOM.unobserveChildren(this._shadyChildrenObserver);
            this._shadyChildrenObserver = null;
          } else if (this._nativeChildrenObserver) {
            this._nativeChildrenObserver.disconnect();
            this._nativeChildrenObserver = null;
          }
        }
        this._connected = false;
      }
    }, {
      key: '_schedule',
      value: function _schedule() {
        var _this3 = this;

        if (!this._scheduled) {
          this._scheduled = true;
          Polymer.Async.microTask.run(function () {
            return _this3.flush();
          });
        }
      }
    }, {
      key: '_processMutations',
      value: function _processMutations(mutations) {
        this._processSlotMutations(mutations);
        this.flush();
      }
    }, {
      key: '_processSlotMutations',
      value: function _processSlotMutations(mutations) {
        if (mutations) {
          for (var i = 0; i < mutations.length; i++) {
            var mutation = mutations[i];
            if (mutation.addedNodes) {
              this._listenSlots(mutation.addedNodes);
            }
            if (mutation.removedNodes) {
              this._unlistenSlots(mutation.removedNodes);
            }
          }
        }
      }

      /**
       * Flushes the observer causing any pending changes to be immediately
       * delivered the observer callback. By default these changes are delivered
       * asynchronously at the next microtask checkpoint.
       *
       * @return {boolean} Returns true if any pending changes caused the observer
       * callback to run.
       */

    }, {
      key: 'flush',
      value: function flush() {
        if (!this._connected) {
          return false;
        }
        if (window.ShadyDOM) {
          ShadyDOM.flush();
        }
        if (this._nativeChildrenObserver) {
          this._processSlotMutations(this._nativeChildrenObserver.takeRecords());
        } else if (this._shadyChildrenObserver) {
          this._processSlotMutations(this._shadyChildrenObserver.takeRecords());
        }
        this._scheduled = false;
        var info = {
          target: this._target,
          addedNodes: [],
          removedNodes: []
        };
        var newNodes = this.constructor.getFlattenedNodes(this._target);
        var splices = Polymer.ArraySplice.calculateSplices(newNodes, this._effectiveNodes);
        // process removals
        for (var i = 0, s; i < splices.length && (s = splices[i]); i++) {
          for (var j = 0, n; j < s.removed.length && (n = s.removed[j]); j++) {
            info.removedNodes.push(n);
          }
        }
        // process adds
        for (var _i = 0, _s; _i < splices.length && (_s = splices[_i]); _i++) {
          for (var _j = _s.index; _j < _s.index + _s.addedCount; _j++) {
            info.addedNodes.push(newNodes[_j]);
          }
        }
        // update cache
        this._effectiveNodes = newNodes;
        var didFlush = false;
        if (info.addedNodes.length || info.removedNodes.length) {
          didFlush = true;
          this.callback.call(this._target, info);
        }
        return didFlush;
      }
    }, {
      key: '_listenSlots',
      value: function _listenSlots(nodeList) {
        for (var i = 0; i < nodeList.length; i++) {
          var n = nodeList[i];
          if (isSlot(n)) {
            n.addEventListener('slotchange', this._boundSchedule);
          }
        }
      }
    }, {
      key: '_unlistenSlots',
      value: function _unlistenSlots(nodeList) {
        for (var i = 0; i < nodeList.length; i++) {
          var n = nodeList[i];
          if (isSlot(n)) {
            n.removeEventListener('slotchange', this._boundSchedule);
          }
        }
      }
    }]);

    return FlattenedNodesObserver;
  }();

  Polymer.FlattenedNodesObserver = FlattenedNodesObserver;
})();

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(55);

(function () {
  'use strict';

  /**
   * Legacy class factory and registration helper for defining Polymer
   * elements.
   *
   * This method is equivalent to
   * `customElements.define(info.is, Polymer.Class(info));`
   *
   * See `Polymer.Class` for details on valid legacy metadata format for `info`.
   *
   * @override
   * @function Polymer
   * @param {!PolymerInit} info Object containing Polymer metadata and functions
   *   to become class methods.
   * @return {!HTMLElement} Generated class
   * @suppress {duplicate, invalidCasts, checkTypes}
   */

  window.Polymer._polymerFn = function (info) {
    // if input is a `class` (aka a function with a prototype), use the prototype
    // remember that the `constructor` will never be called
    var klass = void 0;
    if (typeof info === 'function') {
      klass = info;
    } else {
      klass = Polymer.Class(info);
    }
    customElements.define(klass.is, /** @type {!HTMLElement} */klass);
    return klass;
  };
})();

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

__webpack_require__(22);

(function () {

  'use strict';

  var metaProps = {
    attached: true,
    detached: true,
    ready: true,
    created: true,
    beforeRegister: true,
    registered: true,
    attributeChanged: true,
    // meta objects
    behaviors: true

    /**
     * Applies a "legacy" behavior or array of behaviors to the provided class.
     *
     * Note: this method will automatically also apply the `Polymer.LegacyElementMixin`
     * to ensure that any legacy behaviors can rely on legacy Polymer API on
     * the underlying element.
     *
     * @param {!(Object|Array)} behaviors Behavior object or array of behaviors.
     * @param {!HTMLElement|function(new:HTMLElement)} klass Element class.
     * @return {function(new:HTMLElement)} Returns a new Element class extended by the
     * passed in `behaviors` and also by `Polymer.LegacyElementMixin`.
     * @memberof Polymer
     * @suppress {invalidCasts, checkTypes}
     */
  };function mixinBehaviors(behaviors, klass) {
    if (!behaviors) {
      return (/** @type {HTMLElement} */klass
      );
    }
    // NOTE: ensure the bahevior is extending a class with
    // legacy element api. This is necessary since behaviors expect to be able
    // to access 1.x legacy api.
    klass = Polymer.LegacyElementMixin(klass);
    if (!Array.isArray(behaviors)) {
      behaviors = [behaviors];
    }
    var superBehaviors = klass.prototype.behaviors;
    // get flattened, deduped list of behaviors *not* already on super class
    behaviors = flattenBehaviors(behaviors, null, superBehaviors);
    // mixin new behaviors
    klass = _mixinBehaviors(behaviors, klass);
    if (superBehaviors) {
      behaviors = superBehaviors.concat(behaviors);
    }
    // Set behaviors on prototype for BC...
    klass.prototype.behaviors = behaviors;
    return klass;
  }

  // NOTE:
  // 1.x
  // Behaviors were mixed in *in reverse order* and de-duped on the fly.
  // The rule was that behavior properties were copied onto the element
  // prototype if and only if the property did not already exist.
  // Given: Polymer{ behaviors: [A, B, C, A, B]}, property copy order was:
  // (1), B, (2), A, (3) C. This means prototype properties win over
  // B properties win over A win over C. This mirrors what would happen
  // with inheritance if element extended B extended A extended C.
  //
  // Again given, Polymer{ behaviors: [A, B, C, A, B]}, the resulting
  // `behaviors` array was [C, A, B].
  // Behavior lifecycle methods were called in behavior array order
  // followed by the element, e.g. (1) C.created, (2) A.created,
  // (3) B.created, (4) element.created. There was no support for
  // super, and "super-behavior" methods were callable only by name).
  //
  // 2.x
  // Behaviors are made into proper mixins which live in the
  // element's prototype chain. Behaviors are placed in the element prototype
  // eldest to youngest and de-duped youngest to oldest:
  // So, first [A, B, C, A, B] becomes [C, A, B] then,
  // the element prototype becomes (oldest) (1) Polymer.Element, (2) class(C),
  // (3) class(A), (4) class(B), (5) class(Polymer({...})).
  // Result:
  // This means element properties win over B properties win over A win
  // over C. (same as 1.x)
  // If lifecycle is called (super then me), order is
  // (1) C.created, (2) A.created, (3) B.created, (4) element.created
  // (again same as 1.x)
  function _mixinBehaviors(behaviors, klass) {
    for (var i = 0; i < behaviors.length; i++) {
      var b = behaviors[i];
      if (b) {
        klass = Array.isArray(b) ? _mixinBehaviors(b, klass) : GenerateClassFromInfo(b, klass);
      }
    }
    return klass;
  }

  /**
   * @param {Array} behaviors List of behaviors to flatten.
   * @param {Array=} list Target list to flatten behaviors into.
   * @param {Array=} exclude List of behaviors to exclude from the list.
   * @return {!Array} Returns the list of flattened behaviors.
   */
  function flattenBehaviors(behaviors, list, exclude) {
    list = list || [];
    for (var i = behaviors.length - 1; i >= 0; i--) {
      var b = behaviors[i];
      if (b) {
        if (Array.isArray(b)) {
          flattenBehaviors(b, list);
        } else {
          // dedup
          if (list.indexOf(b) < 0 && (!exclude || exclude.indexOf(b) < 0)) {
            list.unshift(b);
          }
        }
      } else {
        console.warn('behavior is null, check for missing or 404 import');
      }
    }
    return list;
  }

  /**
   * @param {!PolymerInit} info Polymer info object
   * @param {function(new:HTMLElement)} Base base class to extend with info object
   * @return {function(new:HTMLElement)} Generated class
   * @suppress {checkTypes}
   * @private
   */
  function GenerateClassFromInfo(info, Base) {
    var PolymerGenerated = function (_Base) {
      _inherits(PolymerGenerated, _Base);

      function PolymerGenerated() {
        _classCallCheck(this, PolymerGenerated);

        return _possibleConstructorReturn(this, (PolymerGenerated.__proto__ || Object.getPrototypeOf(PolymerGenerated)).apply(this, arguments));
      }

      _createClass(PolymerGenerated, [{
        key: 'created',
        value: function created() {
          _get(PolymerGenerated.prototype.__proto__ || Object.getPrototypeOf(PolymerGenerated.prototype), 'created', this).call(this);
          if (info.created) {
            info.created.call(this);
          }
        }
      }, {
        key: '_registered',
        value: function _registered() {
          _get(PolymerGenerated.prototype.__proto__ || Object.getPrototypeOf(PolymerGenerated.prototype), '_registered', this).call(this);
          /* NOTE: `beforeRegister` is called here for bc, but the behavior
           is different than in 1.x. In 1.0, the method was called *after*
           mixing prototypes together but *before* processing of meta-objects.
           However, dynamic effects can still be set here and can be done either
           in `beforeRegister` or `registered`. It is no longer possible to set
           `is` in `beforeRegister` as you could in 1.x.
          */
          if (info.beforeRegister) {
            info.beforeRegister.call(Object.getPrototypeOf(this));
          }
          if (info.registered) {
            info.registered.call(Object.getPrototypeOf(this));
          }
        }
      }, {
        key: '_applyListeners',
        value: function _applyListeners() {
          _get(PolymerGenerated.prototype.__proto__ || Object.getPrototypeOf(PolymerGenerated.prototype), '_applyListeners', this).call(this);
          if (info.listeners) {
            for (var l in info.listeners) {
              this._addMethodEventListenerToNode(this, l, info.listeners[l]);
            }
          }
        }

        // note: exception to "super then me" rule;
        // do work before calling super so that super attributes
        // only apply if not already set.

      }, {
        key: '_ensureAttributes',
        value: function _ensureAttributes() {
          if (info.hostAttributes) {
            for (var a in info.hostAttributes) {
              this._ensureAttribute(a, info.hostAttributes[a]);
            }
          }
          _get(PolymerGenerated.prototype.__proto__ || Object.getPrototypeOf(PolymerGenerated.prototype), '_ensureAttributes', this).call(this);
        }
      }, {
        key: 'ready',
        value: function ready() {
          _get(PolymerGenerated.prototype.__proto__ || Object.getPrototypeOf(PolymerGenerated.prototype), 'ready', this).call(this);
          if (info.ready) {
            info.ready.call(this);
          }
        }
      }, {
        key: 'attached',
        value: function attached() {
          _get(PolymerGenerated.prototype.__proto__ || Object.getPrototypeOf(PolymerGenerated.prototype), 'attached', this).call(this);
          if (info.attached) {
            info.attached.call(this);
          }
        }
      }, {
        key: 'detached',
        value: function detached() {
          _get(PolymerGenerated.prototype.__proto__ || Object.getPrototypeOf(PolymerGenerated.prototype), 'detached', this).call(this);
          if (info.detached) {
            info.detached.call(this);
          }
        }
      }, {
        key: 'attributeChanged',
        value: function attributeChanged(name, old, value) {
          _get(PolymerGenerated.prototype.__proto__ || Object.getPrototypeOf(PolymerGenerated.prototype), 'attributeChanged', this).call(this, name, old, value);
          if (info.attributeChanged) {
            info.attributeChanged.call(this, name, old, value);
          }
        }
      }], [{
        key: 'properties',
        get: function get() {
          return info.properties;
        }
      }, {
        key: 'observers',
        get: function get() {
          return info.observers;
        }

        /**
         * @return {HTMLTemplateElement} template for this class
         */

      }, {
        key: 'template',
        get: function get() {
          // get template first from any imperative set in `info._template`
          return info._template ||
          // next look in dom-module associated with this element's is.
          Polymer.DomModule && Polymer.DomModule.import(this.is, 'template') ||
          // next look for superclass template (note: use superclass symbol
          // to ensure correct `this.is`)
          Base.template ||
          // finally fall back to `_template` in element's protoype.
          this.prototype._template || null;
        }
      }]);

      return PolymerGenerated;
    }(Base);

    PolymerGenerated.generatedFrom = info;

    for (var p in info) {
      // NOTE: cannot copy `metaProps` methods onto prototype at least because
      // `super.ready` must be called and is not included in the user fn.
      if (!(p in metaProps)) {
        var pd = Object.getOwnPropertyDescriptor(info, p);
        if (pd) {
          Object.defineProperty(PolymerGenerated.prototype, p, pd);
        }
      }
    }

    return PolymerGenerated;
  }

  /**
   * Generates a class that extends `Polymer.LegacyElement` based on the
   * provided info object.  Metadata objects on the `info` object
   * (`properties`, `observers`, `listeners`, `behaviors`, `is`) are used
   * for Polymer's meta-programming systems, and any functions are copied
   * to the generated class.
   *
   * Valid "metadata" values are as follows:
   *
   * `is`: String providing the tag name to register the element under. In
   * addition, if a `dom-module` with the same id exists, the first template
   * in that `dom-module` will be stamped into the shadow root of this element,
   * with support for declarative event listeners (`on-...`), Polymer data
   * bindings (`[[...]]` and `{{...}}`), and id-based node finding into
   * `this.$`.
   *
   * `properties`: Object describing property-related metadata used by Polymer
   * features (key: property names, value: object containing property metadata).
   * Valid keys in per-property metadata include:
   * - `type` (String|Number|Object|Array|...): Used by
   *   `attributeChangedCallback` to determine how string-based attributes
   *   are deserialized to JavaScript property values.
   * - `notify` (boolean): Causes a change in the property to fire a
   *   non-bubbling event called `<property>-changed`. Elements that have
   *   enabled two-way binding to the property use this event to observe changes.
   * - `readOnly` (boolean): Creates a getter for the property, but no setter.
   *   To set a read-only property, use the private setter method
   *   `_setProperty(property, value)`.
   * - `observer` (string): Observer method name that will be called when
   *   the property changes. The arguments of the method are
   *   `(value, previousValue)`.
   * - `computed` (string): String describing method and dependent properties
   *   for computing the value of this property (e.g. `'computeFoo(bar, zot)'`).
   *   Computed properties are read-only by default and can only be changed
   *   via the return value of the computing method.
   *
   * `observers`: Array of strings describing multi-property observer methods
   *  and their dependent properties (e.g. `'observeABC(a, b, c)'`).
   *
   * `listeners`: Object describing event listeners to be added to each
   *  instance of this element (key: event name, value: method name).
   *
   * `behaviors`: Array of additional `info` objects containing metadata
   * and callbacks in the same format as the `info` object here which are
   * merged into this element.
   *
   * `hostAttributes`: Object listing attributes to be applied to the host
   *  once created (key: attribute name, value: attribute value).  Values
   *  are serialized based on the type of the value.  Host attributes should
   *  generally be limited to attributes such as `tabIndex` and `aria-...`.
   *  Attributes in `hostAttributes` are only applied if a user-supplied
   *  attribute is not already present (attributes in markup override
   *  `hostAttributes`).
   *
   * In addition, the following Polymer-specific callbacks may be provided:
   * - `registered`: called after first instance of this element,
   * - `created`: called during `constructor`
   * - `attached`: called during `connectedCallback`
   * - `detached`: called during `disconnectedCallback`
   * - `ready`: called before first `attached`, after all properties of
   *   this element have been propagated to its template and all observers
   *   have run
   *
   * @param {!PolymerInit} info Object containing Polymer metadata and functions
   *   to become class methods.
   * @return {function(new:HTMLElement)} Generated class
   * @memberof Polymer
   */
  Polymer.Class = function (info) {
    if (!info) {
      console.warn('Polymer.Class requires `info` argument');
    }
    var klass = GenerateClassFromInfo(info, info.behaviors ?
    // note: mixinBehaviors ensures `LegacyElementMixin`.
    mixinBehaviors(info.behaviors, HTMLElement) : Polymer.LegacyElementMixin(HTMLElement));
    // decorate klass with registration info
    klass.is = info.is;
    return klass;
  };

  Polymer.mixinBehaviors = mixinBehaviors;
})();

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(14);

(function () {
  'use strict';

  var TemplateInstanceBase = Polymer.TemplateInstanceBase; // eslint-disable-line

  /**
   * @typedef {{
   *   _templatizerTemplate: HTMLTemplateElement,
   *   _parentModel: boolean,
   *   _instanceProps: Object,
   *   _forwardHostPropV2: Function,
   *   _notifyInstancePropV2: Function,
   *   ctor: TemplateInstanceBase
   * }}
   */
  var TemplatizerUser = void 0; // eslint-disable-line

  /**
   * The `Polymer.Templatizer` behavior adds methods to generate instances of
   * templates that are each managed by an anonymous `Polymer.PropertyEffects`
   * instance where data-bindings in the stamped template content are bound to
   * accessors on itself.
   *
   * This behavior is provided in Polymer 2.x as a hybrid-element convenience
   * only.  For non-hybrid usage, the `Polymer.Templatize` library
   * should be used instead.
   *
   * Example:
   *
   *     // Get a template from somewhere, e.g. light DOM
   *     let template = this.querySelector('template');
   *     // Prepare the template
   *     this.templatize(template);
   *     // Instance the template with an initial data model
   *     let instance = this.stamp({myProp: 'initial'});
   *     // Insert the instance's DOM somewhere, e.g. light DOM
   *     Polymer.dom(this).appendChild(instance.root);
   *     // Changing a property on the instance will propagate to bindings
   *     // in the template
   *     instance.myProp = 'new value';
   *
   * Users of `Templatizer` may need to implement the following abstract
   * API's to determine how properties and paths from the host should be
   * forwarded into to instances:
   *
   *     _forwardHostPropV2: function(prop, value)
   *
   * Likewise, users may implement these additional abstract API's to determine
   * how instance-specific properties that change on the instance should be
   * forwarded out to the host, if necessary.
   *
   *     _notifyInstancePropV2: function(inst, prop, value)
   *
   * In order to determine which properties are instance-specific and require
   * custom notification via `_notifyInstanceProp`, define an `_instanceProps`
   * object containing keys for each instance prop, for example:
   *
   *     _instanceProps: {
   *       item: true,
   *       index: true
   *     }
   *
   * Any properties used in the template that are not defined in _instanceProp
   * will be forwarded out to the Templatize `owner` automatically.
   *
   * Users may also implement the following abstract function to show or
   * hide any DOM generated using `stamp`:
   *
   *     _showHideChildren: function(shouldHide)
   *
   * Note that some callbacks are suffixed with `V2` in the Polymer 2.x behavior
   * as the implementations will need to differ from the callbacks required
   * by the 1.x Templatizer API due to changes in the `TemplateInstance` API
   * between versions 1.x and 2.x.
   *
   * @polymerBehavior
   * @memberof Polymer
   */
  var Templatizer = {

    /**
     * Generates an anonymous `TemplateInstance` class (stored as `this.ctor`)
     * for the provided template.  This method should be called once per
     * template to prepare an element for stamping the template, followed
     * by `stamp` to create new instances of the template.
     *
     * @param {HTMLTemplateElement} template Template to prepare
     * @param {boolean=} mutableData When `true`, the generated class will skip
     *   strict dirty-checking for objects and arrays (always consider them to
     *   be "dirty"). Defaults to false.
     * @this {TemplatizerUser}
     */
    templatize: function templatize(template, mutableData) {
      this._templatizerTemplate = template;
      this.ctor = Polymer.Templatize.templatize(template, this, {
        mutableData: Boolean(mutableData),
        parentModel: this._parentModel,
        instanceProps: this._instanceProps,
        forwardHostProp: this._forwardHostPropV2,
        notifyInstanceProp: this._notifyInstancePropV2
      });
    },


    /**
     * Creates an instance of the template prepared by `templatize`.  The object
     * returned is an instance of the anonymous class generated by `templatize`
     * whose `root` property is a document fragment containing newly cloned
     * template content, and which has property accessors corresponding to
     * properties referenced in template bindings.
     *
     * @param {Object=} model Object containing initial property values to
     *   populate into the template bindings.
     * @return {TemplateInstanceBase} Returns the created instance of
     * the template prepared by `templatize`.
     * @this {TemplatizerUser}
     */
    stamp: function stamp(model) {
      return new this.ctor(model);
    },


    /**
     * Returns the template "model" (`TemplateInstance`) associated with
     * a given element, which serves as the binding scope for the template
     * instance the element is contained in.  A template model should be used
     * to manipulate data associated with this template instance.
     *
     * @param {HTMLElement} el Element for which to return a template model.
     * @return {TemplateInstanceBase} Model representing the binding scope for
     *   the element.
     * @this {TemplatizerUser}
     */
    modelForElement: function modelForElement(el) {
      return Polymer.Templatize.modelForElement(this._templatizerTemplate, el);
    }
  };

  Polymer.Templatizer = Templatizer;
})();

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

__webpack_require__(1);

__webpack_require__(11);

__webpack_require__(9);

__webpack_require__(23);

(function () {
  'use strict';

  /**
   * @constructor
   * @extends {HTMLElement}
   * @implements {Polymer_PropertyEffects}
   * @implements {Polymer_OptionalMutableData}
   * @implements {Polymer_GestureEventListeners}
   */

  var domBindBase = Polymer.GestureEventListeners(Polymer.OptionalMutableData(Polymer.PropertyEffects(HTMLElement)));

  /**
   * Custom element to allow using Polymer's template features (data binding,
   * declarative event listeners, etc.) in the main document without defining
   * a new custom element.
   *
   * `<template>` tags utilizing bindings may be wrapped with the `<dom-bind>`
   * element, which will immediately stamp the wrapped template into the main
   * document and bind elements to the `dom-bind` element itself as the
   * binding scope.
   *
   * @polymer
   * @customElement
   * @appliesMixin Polymer.PropertyEffects
   * @appliesMixin Polymer.OptionalMutableData
   * @appliesMixin Polymer.GestureEventListeners
   * @extends {domBindBase}
   * @memberof Polymer
   * @summary Custom element to allow using Polymer's template features (data
   *   binding, declarative event listeners, etc.) in the main document.
   */

  var DomBind = function (_domBindBase) {
    _inherits(DomBind, _domBindBase);

    _createClass(DomBind, null, [{
      key: 'observedAttributes',
      get: function get() {
        return ['mutable-data'];
      }
    }]);

    function DomBind() {
      _classCallCheck(this, DomBind);

      var _this = _possibleConstructorReturn(this, (DomBind.__proto__ || Object.getPrototypeOf(DomBind)).call(this));

      _this.root = null;
      _this.$ = null;
      _this.__children = null;
      return _this;
    }

    // assumes only one observed attribute


    _createClass(DomBind, [{
      key: 'attributeChangedCallback',
      value: function attributeChangedCallback() {
        this.mutableData = true;
      }
    }, {
      key: 'connectedCallback',
      value: function connectedCallback() {
        this.render();
      }
    }, {
      key: 'disconnectedCallback',
      value: function disconnectedCallback() {
        this.__removeChildren();
      }
    }, {
      key: '__insertChildren',
      value: function __insertChildren() {
        this.parentNode.insertBefore(this.root, this);
      }
    }, {
      key: '__removeChildren',
      value: function __removeChildren() {
        if (this.__children) {
          for (var i = 0; i < this.__children.length; i++) {
            this.root.appendChild(this.__children[i]);
          }
        }
      }

      /**
       * Forces the element to render its content. This is typically only
       * necessary to call if HTMLImports with the async attribute are used.
       */

    }, {
      key: 'render',
      value: function render() {
        var _this2 = this;

        var template = void 0;
        if (!this.__children) {
          template = /** @type {HTMLTemplateElement} */template || this.querySelector('template');
          if (!template) {
            // Wait until childList changes and template should be there by then
            var observer = new MutationObserver(function () {
              template = /** @type {HTMLTemplateElement} */_this2.querySelector('template');
              if (template) {
                observer.disconnect();
                _this2.render();
              } else {
                throw new Error('dom-bind requires a <template> child');
              }
            });
            observer.observe(this, { childList: true });
            return;
          }
          this.root = this._stampTemplate(template);
          this.$ = this.root.$;
          this.__children = [];
          for (var n = this.root.firstChild; n; n = n.nextSibling) {
            this.__children[this.__children.length] = n;
          }
          this._enableProperties();
        }
        this.__insertChildren();
        this.dispatchEvent(new CustomEvent('dom-change', {
          bubbles: true,
          composed: true
        }));
      }
    }]);

    return DomBind;
  }(domBindBase);

  customElements.define('dom-bind', DomBind);
})();

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

__webpack_require__(6);

__webpack_require__(14);

__webpack_require__(12);

__webpack_require__(13);

__webpack_require__(9);

(function () {
  'use strict';

  var TemplateInstanceBase = Polymer.TemplateInstanceBase; // eslint-disable-line

  /**
   * @constructor
   * @implements {Polymer_OptionalMutableData}
   * @extends {Polymer.Element}
   */
  var domRepeatBase = Polymer.OptionalMutableData(Polymer.Element);

  /**
   * The `<dom-repeat>` element will automatically stamp and binds one instance
   * of template content to each object in a user-provided array.
   * `dom-repeat` accepts an `items` property, and one instance of the template
   * is stamped for each item into the DOM at the location of the `dom-repeat`
   * element.  The `item` property will be set on each instance's binding
   * scope, thus templates should bind to sub-properties of `item`.
   *
   * Example:
   *
   * ```html
   * <dom-module id="employee-list">
   *
   *   <template>
   *
   *     <div> Employee list: </div>
   *     <template is="dom-repeat" items="{{employees}}">
   *         <div>First name: <span>{{item.first}}</span></div>
   *         <div>Last name: <span>{{item.last}}</span></div>
   *     </template>
   *
   *   </template>
   *
   *   <script>
   *     Polymer({
   *       is: 'employee-list',
   *       ready: function() {
   *         this.employees = [
   *             {first: 'Bob', last: 'Smith'},
   *             {first: 'Sally', last: 'Johnson'},
   *             ...
   *         ];
   *       }
   *     });
   *   < /script>
   *
   * </dom-module>
   * ```
   *
   * Notifications for changes to items sub-properties will be forwarded to template
   * instances, which will update via the normal structured data notification system.
   *
   * Mutations to the `items` array itself should be made using the Array
   * mutation API's on `Polymer.Base` (`push`, `pop`, `splice`, `shift`,
   * `unshift`), and template instances will be kept in sync with the data in the
   * array.
   *
   * Events caught by event handlers within the `dom-repeat` template will be
   * decorated with a `model` property, which represents the binding scope for
   * each template instance.  The model is an instance of Polymer.Base, and should
   * be used to manipulate data on the instance, for example
   * `event.model.set('item.checked', true);`.
   *
   * Alternatively, the model for a template instance for an element stamped by
   * a `dom-repeat` can be obtained using the `modelForElement` API on the
   * `dom-repeat` that stamped it, for example
   * `this.$.domRepeat.modelForElement(event.target).set('item.checked', true);`.
   * This may be useful for manipulating instance data of event targets obtained
   * by event handlers on parents of the `dom-repeat` (event delegation).
   *
   * A view-specific filter/sort may be applied to each `dom-repeat` by supplying a
   * `filter` and/or `sort` property.  This may be a string that names a function on
   * the host, or a function may be assigned to the property directly.  The functions
   * should implemented following the standard `Array` filter/sort API.
   *
   * In order to re-run the filter or sort functions based on changes to sub-fields
   * of `items`, the `observe` property may be set as a space-separated list of
   * `item` sub-fields that should cause a re-filter/sort when modified.  If
   * the filter or sort function depends on properties not contained in `items`,
   * the user should observe changes to those properties and call `render` to update
   * the view based on the dependency change.
   *
   * For example, for an `dom-repeat` with a filter of the following:
   *
   * ```js
   * isEngineer: function(item) {
   *     return item.type == 'engineer' || item.manager.type == 'engineer';
   * }
   * ```
   *
   * Then the `observe` property should be configured as follows:
   *
   * ```html
   * <template is="dom-repeat" items="{{employees}}"
   *           filter="isEngineer" observe="type manager.type">
   * ```
   *
   * @customElement
   * @polymer
   * @memberof Polymer
   * @extends {domRepeatBase}
   * @appliesMixin Polymer.OptionalMutableData
   * @summary Custom element for stamping instance of a template bound to
   *   items in an array.
   */

  var DomRepeat = function (_domRepeatBase) {
    _inherits(DomRepeat, _domRepeatBase);

    _createClass(DomRepeat, null, [{
      key: 'is',


      // Not needed to find template; can be removed once the analyzer
      // can find the tag name from customElements.define call
      get: function get() {
        return 'dom-repeat';
      }
    }, {
      key: 'template',
      get: function get() {
        return null;
      }
    }, {
      key: 'properties',
      get: function get() {

        /**
         * Fired whenever DOM is added or removed by this template (by
         * default, rendering occurs lazily).  To force immediate rendering, call
         * `render`.
         *
         * @event dom-change
         */
        return {

          /**
           * An array containing items determining how many instances of the template
           * to stamp and that that each template instance should bind to.
           */
          items: {
            type: Array
          },

          /**
           * The name of the variable to add to the binding scope for the array
           * element associated with a given template instance.
           */
          as: {
            type: String,
            value: 'item'
          },

          /**
           * The name of the variable to add to the binding scope with the index
           * of the instance in the sorted and filtered list of rendered items.
           * Note, for the index in the `this.items` array, use the value of the
           * `itemsIndexAs` property.
           */
          indexAs: {
            type: String,
            value: 'index'
          },

          /**
           * The name of the variable to add to the binding scope with the index
           * of the instance in the `this.items` array. Note, for the index of
           * this instance in the sorted and filtered list of rendered items,
           * use the value of the `indexAs` property.
           */
          itemsIndexAs: {
            type: String,
            value: 'itemsIndex'
          },

          /**
           * A function that should determine the sort order of the items.  This
           * property should either be provided as a string, indicating a method
           * name on the element's host, or else be an actual function.  The
           * function should match the sort function passed to `Array.sort`.
           * Using a sort function has no effect on the underlying `items` array.
           */
          sort: {
            type: Function,
            observer: '__sortChanged'
          },

          /**
           * A function that can be used to filter items out of the view.  This
           * property should either be provided as a string, indicating a method
           * name on the element's host, or else be an actual function.  The
           * function should match the sort function passed to `Array.filter`.
           * Using a filter function has no effect on the underlying `items` array.
           */
          filter: {
            type: Function,
            observer: '__filterChanged'
          },

          /**
           * When using a `filter` or `sort` function, the `observe` property
           * should be set to a space-separated list of the names of item
           * sub-fields that should trigger a re-sort or re-filter when changed.
           * These should generally be fields of `item` that the sort or filter
           * function depends on.
           */
          observe: {
            type: String,
            observer: '__observeChanged'
          },

          /**
           * When using a `filter` or `sort` function, the `delay` property
           * determines a debounce time after a change to observed item
           * properties that must pass before the filter or sort is re-run.
           * This is useful in rate-limiting shuffing of the view when
           * item changes may be frequent.
           */
          delay: Number,

          /**
           * Count of currently rendered items after `filter` (if any) has been applied.
           * If "chunking mode" is enabled, `renderedItemCount` is updated each time a
           * set of template instances is rendered.
           *
           */
          renderedItemCount: {
            type: Number,
            notify: true,
            readOnly: true
          },

          /**
           * Defines an initial count of template instances to render after setting
           * the `items` array, before the next paint, and puts the `dom-repeat`
           * into "chunking mode".  The remaining items will be created and rendered
           * incrementally at each animation frame therof until all instances have
           * been rendered.
           */
          initialCount: {
            type: Number,
            observer: '__initializeChunking'
          },

          /**
           * When `initialCount` is used, this property defines a frame rate to
           * target by throttling the number of instances rendered each frame to
           * not exceed the budget for the target frame rate.  Setting this to a
           * higher number will allow lower latency and higher throughput for
           * things like event handlers, but will result in a longer time for the
           * remaining items to complete rendering.
           */
          targetFramerate: {
            type: Number,
            value: 20
          },

          _targetFrameTime: {
            type: Number,
            computed: '__computeFrameTime(targetFramerate)'
          }

        };
      }
    }, {
      key: 'observers',
      get: function get() {
        return ['__itemsChanged(items.*)'];
      }
    }]);

    function DomRepeat() {
      _classCallCheck(this, DomRepeat);

      var _this = _possibleConstructorReturn(this, (DomRepeat.__proto__ || Object.getPrototypeOf(DomRepeat)).call(this));

      _this.__instances = [];
      _this.__limit = Infinity;
      _this.__pool = [];
      _this.__renderDebouncer = null;
      _this.__itemsIdxToInstIdx = {};
      _this.__chunkCount = null;
      _this.__lastChunkTime = null;
      _this.__sortFn = null;
      _this.__filterFn = null;
      _this.__observePaths = null;
      _this.__ctor = null;
      _this.__isDetached = true;
      _this.template = null;
      return _this;
    }

    _createClass(DomRepeat, [{
      key: 'disconnectedCallback',
      value: function disconnectedCallback() {
        _get(DomRepeat.prototype.__proto__ || Object.getPrototypeOf(DomRepeat.prototype), 'disconnectedCallback', this).call(this);
        this.__isDetached = true;
        for (var i = 0; i < this.__instances.length; i++) {
          this.__detachInstance(i);
        }
      }
    }, {
      key: 'connectedCallback',
      value: function connectedCallback() {
        _get(DomRepeat.prototype.__proto__ || Object.getPrototypeOf(DomRepeat.prototype), 'connectedCallback', this).call(this);
        // only perform attachment if the element was previously detached.
        if (this.__isDetached) {
          this.__isDetached = false;
          var parent = this.parentNode;
          for (var i = 0; i < this.__instances.length; i++) {
            this.__attachInstance(i, parent);
          }
        }
      }
    }, {
      key: '__ensureTemplatized',
      value: function __ensureTemplatized() {
        var _this2 = this;

        // Templatizing (generating the instance constructor) needs to wait
        // until ready, since won't have its template content handed back to
        // it until then
        if (!this.__ctor) {
          var template = this.template = this.querySelector('template');
          if (!template) {
            // // Wait until childList changes and template should be there by then
            var observer = new MutationObserver(function () {
              if (_this2.querySelector('template')) {
                observer.disconnect();
                _this2.__render();
              } else {
                throw new Error('dom-repeat requires a <template> child');
              }
            });
            observer.observe(this, { childList: true });
            return false;
          }
          // Template instance props that should be excluded from forwarding
          var instanceProps = {};
          instanceProps[this.as] = true;
          instanceProps[this.indexAs] = true;
          instanceProps[this.itemsIndexAs] = true;
          this.__ctor = Polymer.Templatize.templatize(template, this, {
            mutableData: this.mutableData,
            parentModel: true,
            instanceProps: instanceProps,
            /**
             * @this {this}
             * @param {string} prop Property to set
             * @param {*} value Value to set property to
             */
            forwardHostProp: function forwardHostProp(prop, value) {
              var i$ = this.__instances;
              for (var i = 0, inst; i < i$.length && (inst = i$[i]); i++) {
                inst.forwardHostProp(prop, value);
              }
            },
            /**
             * @this {this}
             * @param {Object} inst Instance to notify
             * @param {string} prop Property to notify
             * @param {*} value Value to notify
             */
            notifyInstanceProp: function notifyInstanceProp(inst, prop, value) {
              if (Polymer.Path.matches(this.as, prop)) {
                var idx = inst[this.itemsIndexAs];
                if (prop == this.as) {
                  this.items[idx] = value;
                }
                var path = Polymer.Path.translate(this.as, 'items.' + idx, prop);
                this.notifyPath(path, value);
              }
            }
          });
        }
        return true;
      }
    }, {
      key: '__getMethodHost',
      value: function __getMethodHost() {
        // Technically this should be the owner of the outermost template.
        // In shadow dom, this is always getRootNode().host, but we can
        // approximate this via cooperation with our dataHost always setting
        // `_methodHost` as long as there were bindings (or id's) on this
        // instance causing it to get a dataHost.
        return this.__dataHost._methodHost || this.__dataHost;
      }
    }, {
      key: '__sortChanged',
      value: function __sortChanged(sort) {
        var methodHost = this.__getMethodHost();
        this.__sortFn = sort && (typeof sort == 'function' ? sort : function () {
          return methodHost[sort].apply(methodHost, arguments);
        });
        if (this.items) {
          this.__debounceRender(this.__render);
        }
      }
    }, {
      key: '__filterChanged',
      value: function __filterChanged(filter) {
        var methodHost = this.__getMethodHost();
        this.__filterFn = filter && (typeof filter == 'function' ? filter : function () {
          return methodHost[filter].apply(methodHost, arguments);
        });
        if (this.items) {
          this.__debounceRender(this.__render);
        }
      }
    }, {
      key: '__computeFrameTime',
      value: function __computeFrameTime(rate) {
        return Math.ceil(1000 / rate);
      }
    }, {
      key: '__initializeChunking',
      value: function __initializeChunking() {
        if (this.initialCount) {
          this.__limit = this.initialCount;
          this.__chunkCount = this.initialCount;
          this.__lastChunkTime = performance.now();
        }
      }
    }, {
      key: '__tryRenderChunk',
      value: function __tryRenderChunk() {
        // Debounced so that multiple calls through `_render` between animation
        // frames only queue one new rAF (e.g. array mutation & chunked render)
        if (this.items && this.__limit < this.items.length) {
          this.__debounceRender(this.__requestRenderChunk);
        }
      }
    }, {
      key: '__requestRenderChunk',
      value: function __requestRenderChunk() {
        var _this3 = this;

        requestAnimationFrame(function () {
          return _this3.__renderChunk();
        });
      }
    }, {
      key: '__renderChunk',
      value: function __renderChunk() {
        // Simple auto chunkSize throttling algorithm based on feedback loop:
        // measure actual time between frames and scale chunk count by ratio
        // of target/actual frame time
        var currChunkTime = performance.now();
        var ratio = this._targetFrameTime / (currChunkTime - this.__lastChunkTime);
        this.__chunkCount = Math.round(this.__chunkCount * ratio) || 1;
        this.__limit += this.__chunkCount;
        this.__lastChunkTime = currChunkTime;
        this.__debounceRender(this.__render);
      }
    }, {
      key: '__observeChanged',
      value: function __observeChanged() {
        this.__observePaths = this.observe && this.observe.replace('.*', '.').split(' ');
      }
    }, {
      key: '__itemsChanged',
      value: function __itemsChanged(change) {
        if (this.items && !Array.isArray(this.items)) {
          console.warn('dom-repeat expected array for `items`, found', this.items);
        }
        // If path was to an item (e.g. 'items.3' or 'items.3.foo'), forward the
        // path to that instance synchronously (retuns false for non-item paths)
        if (!this.__handleItemPath(change.path, change.value)) {
          // Otherwise, the array was reset ('items') or spliced ('items.splices'),
          // so queue a full refresh
          this.__initializeChunking();
          this.__debounceRender(this.__render);
        }
      }
    }, {
      key: '__handleObservedPaths',
      value: function __handleObservedPaths(path) {
        if (this.__observePaths) {
          path = path.substring(path.indexOf('.') + 1);
          var paths = this.__observePaths;
          for (var i = 0; i < paths.length; i++) {
            if (path.indexOf(paths[i]) === 0) {
              this.__debounceRender(this.__render, this.delay);
              return true;
            }
          }
        }
      }

      /**
       * @param {function(this:DomRepeat)} fn Function to debounce.
       * @param {number=} delay Delay in ms to debounce by.
       */

    }, {
      key: '__debounceRender',
      value: function __debounceRender(fn) {
        var delay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

        this.__renderDebouncer = Polymer.Debouncer.debounce(this.__renderDebouncer, delay > 0 ? Polymer.Async.timeOut.after(delay) : Polymer.Async.microTask, fn.bind(this));
        Polymer.enqueueDebouncer(this.__renderDebouncer);
      }

      /**
       * Forces the element to render its content. Normally rendering is
       * asynchronous to a provoking change. This is done for efficiency so
       * that multiple changes trigger only a single render. The render method
       * should be called if, for example, template rendering is required to
       * validate application state.
       */

    }, {
      key: 'render',
      value: function render() {
        // Queue this repeater, then flush all in order
        this.__debounceRender(this.__render);
        Polymer.flush();
      }
    }, {
      key: '__render',
      value: function __render() {
        if (!this.__ensureTemplatized()) {
          // No template found yet
          return;
        }
        this.__applyFullRefresh();
        // Reset the pool
        // TODO(kschaaf): Reuse pool across turns and nested templates
        // Now that objects/arrays are re-evaluated when set, we can safely
        // reuse pooled instances across turns, however we still need to decide
        // semantics regarding how long to hold, how many to hold, etc.
        this.__pool.length = 0;
        // Set rendered item count
        this._setRenderedItemCount(this.__instances.length);
        // Notify users
        this.dispatchEvent(new CustomEvent('dom-change', {
          bubbles: true,
          composed: true
        }));
        // Check to see if we need to render more items
        this.__tryRenderChunk();
      }
    }, {
      key: '__applyFullRefresh',
      value: function __applyFullRefresh() {
        var _this4 = this;

        var items = this.items || [];
        var isntIdxToItemsIdx = new Array(items.length);
        for (var i = 0; i < items.length; i++) {
          isntIdxToItemsIdx[i] = i;
        }
        // Apply user filter
        if (this.__filterFn) {
          isntIdxToItemsIdx = isntIdxToItemsIdx.filter(function (i, idx, array) {
            return _this4.__filterFn(items[i], idx, array);
          });
        }
        // Apply user sort
        if (this.__sortFn) {
          isntIdxToItemsIdx.sort(function (a, b) {
            return _this4.__sortFn(items[a], items[b]);
          });
        }
        // items->inst map kept for item path forwarding
        var itemsIdxToInstIdx = this.__itemsIdxToInstIdx = {};
        var instIdx = 0;
        // Generate instances and assign items
        var limit = Math.min(isntIdxToItemsIdx.length, this.__limit);
        for (; instIdx < limit; instIdx++) {
          var inst = this.__instances[instIdx];
          var itemIdx = isntIdxToItemsIdx[instIdx];
          var item = items[itemIdx];
          itemsIdxToInstIdx[itemIdx] = instIdx;
          if (inst && instIdx < this.__limit) {
            inst._setPendingProperty(this.as, item);
            inst._setPendingProperty(this.indexAs, instIdx);
            inst._setPendingProperty(this.itemsIndexAs, itemIdx);
            inst._flushProperties();
          } else {
            this.__insertInstance(item, instIdx, itemIdx);
          }
        }
        // Remove any extra instances from previous state
        for (var _i = this.__instances.length - 1; _i >= instIdx; _i--) {
          this.__detachAndRemoveInstance(_i);
        }
      }
    }, {
      key: '__detachInstance',
      value: function __detachInstance(idx) {
        var inst = this.__instances[idx];
        for (var i = 0; i < inst.children.length; i++) {
          var el = inst.children[i];
          inst.root.appendChild(el);
        }
        return inst;
      }
    }, {
      key: '__attachInstance',
      value: function __attachInstance(idx, parent) {
        var inst = this.__instances[idx];
        parent.insertBefore(inst.root, this);
      }
    }, {
      key: '__detachAndRemoveInstance',
      value: function __detachAndRemoveInstance(idx) {
        var inst = this.__detachInstance(idx);
        if (inst) {
          this.__pool.push(inst);
        }
        this.__instances.splice(idx, 1);
      }
    }, {
      key: '__stampInstance',
      value: function __stampInstance(item, instIdx, itemIdx) {
        var model = {};
        model[this.as] = item;
        model[this.indexAs] = instIdx;
        model[this.itemsIndexAs] = itemIdx;
        return new this.__ctor(model);
      }
    }, {
      key: '__insertInstance',
      value: function __insertInstance(item, instIdx, itemIdx) {
        var inst = this.__pool.pop();
        if (inst) {
          // TODO(kschaaf): If the pool is shared across turns, hostProps
          // need to be re-set to reused instances in addition to item
          inst._setPendingProperty(this.as, item);
          inst._setPendingProperty(this.indexAs, instIdx);
          inst._setPendingProperty(this.itemsIndexAs, itemIdx);
          inst._flushProperties();
        } else {
          inst = this.__stampInstance(item, instIdx, itemIdx);
        }
        var beforeRow = this.__instances[instIdx + 1];
        var beforeNode = beforeRow ? beforeRow.children[0] : this;
        this.parentNode.insertBefore(inst.root, beforeNode);
        this.__instances[instIdx] = inst;
        return inst;
      }

      // Implements extension point from Templatize mixin

    }, {
      key: '_showHideChildren',
      value: function _showHideChildren(hidden) {
        for (var i = 0; i < this.__instances.length; i++) {
          this.__instances[i]._showHideChildren(hidden);
        }
      }

      // Called as a side effect of a host items.<key>.<path> path change,
      // responsible for notifying item.<path> changes to inst for key

    }, {
      key: '__handleItemPath',
      value: function __handleItemPath(path, value) {
        var itemsPath = path.slice(6); // 'items.'.length == 6
        var dot = itemsPath.indexOf('.');
        var itemsIdx = dot < 0 ? itemsPath : itemsPath.substring(0, dot);
        // If path was index into array...
        if (itemsIdx == parseInt(itemsIdx, 10)) {
          var itemSubPath = dot < 0 ? '' : itemsPath.substring(dot + 1);
          // If the path is observed, it will trigger a full refresh
          this.__handleObservedPaths(itemSubPath);
          // Note, even if a rull refresh is triggered, always do the path
          // notification because unless mutableData is used for dom-repeat
          // and all elements in the instance subtree, a full refresh may
          // not trigger the proper update.
          var instIdx = this.__itemsIdxToInstIdx[itemsIdx];
          var inst = this.__instances[instIdx];
          if (inst) {
            var itemPath = this.as + (itemSubPath ? '.' + itemSubPath : '');
            // This is effectively `notifyPath`, but avoids some of the overhead
            // of the public API
            inst._setPendingPropertyOrPath(itemPath, value, false, true);
            inst._flushProperties();
          }
          return true;
        }
      }

      /**
       * Returns the item associated with a given element stamped by
       * this `dom-repeat`.
       *
       * Note, to modify sub-properties of the item,
       * `modelForElement(el).set('item.<sub-prop>', value)`
       * should be used.
       *
       * @param {HTMLElement} el Element for which to return the item.
       * @return {*} Item associated with the element.
       */

    }, {
      key: 'itemForElement',
      value: function itemForElement(el) {
        var instance = this.modelForElement(el);
        return instance && instance[this.as];
      }

      /**
       * Returns the inst index for a given element stamped by this `dom-repeat`.
       * If `sort` is provided, the index will reflect the sorted order (rather
       * than the original array order).
       *
       * @param {HTMLElement} el Element for which to return the index.
       * @return {*} Row index associated with the element (note this may
       *   not correspond to the array index if a user `sort` is applied).
       */

    }, {
      key: 'indexForElement',
      value: function indexForElement(el) {
        var instance = this.modelForElement(el);
        return instance && instance[this.indexAs];
      }

      /**
       * Returns the template "model" associated with a given element, which
       * serves as the binding scope for the template instance the element is
       * contained in. A template model is an instance of `Polymer.Base`, and
       * should be used to manipulate data associated with this template instance.
       *
       * Example:
       *
       *   let model = modelForElement(el);
       *   if (model.index < 10) {
       *     model.set('item.checked', true);
       *   }
       *
       * @param {HTMLElement} el Element for which to return a template model.
       * @return {TemplateInstanceBase} Model representing the binding scope for
       *   the element.
       */

    }, {
      key: 'modelForElement',
      value: function modelForElement(el) {
        return Polymer.Templatize.modelForElement(this.template, el);
      }
    }]);

    return DomRepeat;
  }(domRepeatBase);

  customElements.define(DomRepeat.is, DomRepeat);

  Polymer.DomRepeat = DomRepeat;
})();

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

__webpack_require__(6);

__webpack_require__(14);

__webpack_require__(12);

__webpack_require__(13);

(function () {
  'use strict';

  /**
   * The `<dom-if>` element will stamp a light-dom `<template>` child when
   * the `if` property becomes truthy, and the template can use Polymer
   * data-binding and declarative event features when used in the context of
   * a Polymer element's template.
   *
   * When `if` becomes falsey, the stamped content is hidden but not
   * removed from dom. When `if` subsequently becomes truthy again, the content
   * is simply re-shown. This approach is used due to its favorable performance
   * characteristics: the expense of creating template content is paid only
   * once and lazily.
   *
   * Set the `restamp` property to true to force the stamped content to be
   * created / destroyed when the `if` condition changes.
   *
   * @customElement
   * @polymer
   * @extends Polymer.Element
   * @memberof Polymer
   * @summary Custom element that conditionally stamps and hides or removes
   *   template content based on a boolean flag.
   */

  var DomIf = function (_Polymer$Element) {
    _inherits(DomIf, _Polymer$Element);

    _createClass(DomIf, null, [{
      key: 'is',


      // Not needed to find template; can be removed once the analyzer
      // can find the tag name from customElements.define call
      get: function get() {
        return 'dom-if';
      }
    }, {
      key: 'template',
      get: function get() {
        return null;
      }
    }, {
      key: 'properties',
      get: function get() {

        return {

          /**
           * Fired whenever DOM is added or removed/hidden by this template (by
           * default, rendering occurs lazily).  To force immediate rendering, call
           * `render`.
           *
           * @event dom-change
           */

          /**
           * A boolean indicating whether this template should stamp.
           */
          if: {
            type: Boolean,
            observer: '__debounceRender'
          },

          /**
           * When true, elements will be removed from DOM and discarded when `if`
           * becomes false and re-created and added back to the DOM when `if`
           * becomes true.  By default, stamped elements will be hidden but left
           * in the DOM when `if` becomes false, which is generally results
           * in better performance.
           */
          restamp: {
            type: Boolean,
            observer: '__debounceRender'
          }

        };
      }
    }]);

    function DomIf() {
      _classCallCheck(this, DomIf);

      var _this = _possibleConstructorReturn(this, (DomIf.__proto__ || Object.getPrototypeOf(DomIf)).call(this));

      _this.__renderDebouncer = null;
      _this.__invalidProps = null;
      _this.__instance = null;
      _this._lastIf = false;
      _this.__ctor = null;
      return _this;
    }

    _createClass(DomIf, [{
      key: '__debounceRender',
      value: function __debounceRender() {
        var _this2 = this;

        // Render is async for 2 reasons:
        // 1. To eliminate dom creation trashing if user code thrashes `if` in the
        //    same turn. This was more common in 1.x where a compound computed
        //    property could result in the result changing multiple times, but is
        //    mitigated to a large extent by batched property processing in 2.x.
        // 2. To avoid double object propagation when a bag including values bound
        //    to the `if` property as well as one or more hostProps could enqueue
        //    the <dom-if> to flush before the <template>'s host property
        //    forwarding. In that scenario creating an instance would result in
        //    the host props being set once, and then the enqueued changes on the
        //    template would set properties a second time, potentially causing an
        //    object to be set to an instance more than once.  Creating the
        //    instance async from flushing data ensures this doesn't happen. If
        //    we wanted a sync option in the future, simply having <dom-if> flush
        //    (or clear) its template's pending host properties before creating
        //    the instance would also avoid the problem.
        this.__renderDebouncer = Polymer.Debouncer.debounce(this.__renderDebouncer, Polymer.Async.microTask, function () {
          return _this2.__render();
        });
        Polymer.enqueueDebouncer(this.__renderDebouncer);
      }
    }, {
      key: 'disconnectedCallback',
      value: function disconnectedCallback() {
        _get(DomIf.prototype.__proto__ || Object.getPrototypeOf(DomIf.prototype), 'disconnectedCallback', this).call(this);
        if (!this.parentNode || this.parentNode.nodeType == Node.DOCUMENT_FRAGMENT_NODE && !this.parentNode.host) {
          this.__teardownInstance();
        }
      }
    }, {
      key: 'connectedCallback',
      value: function connectedCallback() {
        _get(DomIf.prototype.__proto__ || Object.getPrototypeOf(DomIf.prototype), 'connectedCallback', this).call(this);
        if (this.if) {
          this.__debounceRender();
        }
      }

      /**
       * Forces the element to render its content. Normally rendering is
       * asynchronous to a provoking change. This is done for efficiency so
       * that multiple changes trigger only a single render. The render method
       * should be called if, for example, template rendering is required to
       * validate application state.
       */

    }, {
      key: 'render',
      value: function render() {
        Polymer.flush();
      }
    }, {
      key: '__render',
      value: function __render() {
        if (this.if) {
          if (!this.__ensureInstance()) {
            // No template found yet
            return;
          }
          this._showHideChildren();
        } else if (this.restamp) {
          this.__teardownInstance();
        }
        if (!this.restamp && this.__instance) {
          this._showHideChildren();
        }
        if (this.if != this._lastIf) {
          this.dispatchEvent(new CustomEvent('dom-change', {
            bubbles: true,
            composed: true
          }));
          this._lastIf = this.if;
        }
      }
    }, {
      key: '__ensureInstance',
      value: function __ensureInstance() {
        var _this3 = this;

        var parentNode = this.parentNode;
        // Guard against element being detached while render was queued
        if (parentNode) {
          if (!this.__ctor) {
            var template = this.querySelector('template');
            if (!template) {
              // Wait until childList changes and template should be there by then
              var observer = new MutationObserver(function () {
                if (_this3.querySelector('template')) {
                  observer.disconnect();
                  _this3.__render();
                } else {
                  throw new Error('dom-if requires a <template> child');
                }
              });
              observer.observe(this, { childList: true });
              return false;
            }
            this.__ctor = Polymer.Templatize.templatize(template, this, {
              // dom-if templatizer instances require `mutable: true`, as
              // `__syncHostProperties` relies on that behavior to sync objects
              mutableData: true,
              /**
               * @param {string} prop Property to forward
               * @param {*} value Value of property
               * @this {this}
               */
              forwardHostProp: function forwardHostProp(prop, value) {
                if (this.__instance) {
                  if (this.if) {
                    this.__instance.forwardHostProp(prop, value);
                  } else {
                    // If we have an instance but are squelching host property
                    // forwarding due to if being false, note the invalidated
                    // properties so `__syncHostProperties` can sync them the next
                    // time `if` becomes true
                    this.__invalidProps = this.__invalidProps || Object.create(null);
                    this.__invalidProps[Polymer.Path.root(prop)] = true;
                  }
                }
              }
            });
          }
          if (!this.__instance) {
            this.__instance = new this.__ctor();
            parentNode.insertBefore(this.__instance.root, this);
          } else {
            this.__syncHostProperties();
            var c$ = this.__instance.children;
            if (c$ && c$.length) {
              // Detect case where dom-if was re-attached in new position
              var lastChild = this.previousSibling;
              if (lastChild !== c$[c$.length - 1]) {
                for (var i = 0, n; i < c$.length && (n = c$[i]); i++) {
                  parentNode.insertBefore(n, this);
                }
              }
            }
          }
        }
        return true;
      }
    }, {
      key: '__syncHostProperties',
      value: function __syncHostProperties() {
        var props = this.__invalidProps;
        if (props) {
          for (var prop in props) {
            this.__instance._setPendingProperty(prop, this.__dataHost[prop]);
          }
          this.__invalidProps = null;
          this.__instance._flushProperties();
        }
      }
    }, {
      key: '__teardownInstance',
      value: function __teardownInstance() {
        if (this.__instance) {
          var c$ = this.__instance.children;
          if (c$ && c$.length) {
            // use first child parent, for case when dom-if may have been detached
            var parent = c$[0].parentNode;
            for (var i = 0, n; i < c$.length && (n = c$[i]); i++) {
              parent.removeChild(n);
            }
          }
          this.__instance = null;
          this.__invalidProps = null;
        }
      }
    }, {
      key: '_showHideChildren',
      value: function _showHideChildren() {
        var hidden = this.__hideTemplateChildren__ || !this.if;
        if (this.__instance) {
          this.__instance._showHideChildren(hidden);
        }
      }
    }]);

    return DomIf;
  }(Polymer.Element);

  customElements.define(DomIf.is, DomIf);

  Polymer.DomIf = DomIf;
})();

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

__webpack_require__(6);

__webpack_require__(3);

__webpack_require__(24);

(function () {
  'use strict';

  /**
   * Element mixin for recording dynamic associations between item paths in a
   * master `items` array and a `selected` array such that path changes to the
   * master array (at the host) element or elsewhere via data-binding) are
   * correctly propagated to items in the selected array and vice-versa.
   *
   * The `items` property accepts an array of user data, and via the
   * `select(item)` and `deselect(item)` API, updates the `selected` property
   * which may be bound to other parts of the application, and any changes to
   * sub-fields of `selected` item(s) will be kept in sync with items in the
   * `items` array.  When `multi` is false, `selected` is a property
   * representing the last selected item.  When `multi` is true, `selected`
   * is an array of multiply selected items.
   *
   * @polymer
   * @mixinFunction
   * @appliesMixin Polymer.ElementMixin
   * @memberof Polymer
   * @summary Element mixin for recording dynamic associations between item paths in a
   * master `items` array and a `selected` array
   */

  var ArraySelectorMixin = Polymer.dedupingMixin(function (superClass) {

    /**
     * @constructor
     * @extends {superClass}
     * @implements {Polymer_ElementMixin}
     */
    var elementBase = Polymer.ElementMixin(superClass);

    /**
     * @polymer
     * @mixinClass
     * @implements {Polymer_ArraySelectorMixin}
     * @unrestricted
     */

    var ArraySelectorMixin = function (_elementBase) {
      _inherits(ArraySelectorMixin, _elementBase);

      _createClass(ArraySelectorMixin, null, [{
        key: 'properties',
        get: function get() {

          return {

            /**
             * An array containing items from which selection will be made.
             */
            items: {
              type: Array
            },

            /**
             * When `true`, multiple items may be selected at once (in this case,
             * `selected` is an array of currently selected items).  When `false`,
             * only one item may be selected at a time.
             */
            multi: {
              type: Boolean,
              value: false
            },

            /**
             * When `multi` is true, this is an array that contains any selected.
             * When `multi` is false, this is the currently selected item, or `null`
             * if no item is selected.
             * @type {?(Object|Array<!Object>)}
             */
            selected: {
              type: Object,
              notify: true
            },

            /**
             * When `multi` is false, this is the currently selected item, or `null`
             * if no item is selected.
             * @type {?Object}
             */
            selectedItem: {
              type: Object,
              notify: true
            },

            /**
             * When `true`, calling `select` on an item that is already selected
             * will deselect the item.
             */
            toggle: {
              type: Boolean,
              value: false
            }

          };
        }
      }, {
        key: 'observers',
        get: function get() {
          return ['__updateSelection(multi, items.*)'];
        }
      }]);

      function ArraySelectorMixin() {
        _classCallCheck(this, ArraySelectorMixin);

        var _this = _possibleConstructorReturn(this, (ArraySelectorMixin.__proto__ || Object.getPrototypeOf(ArraySelectorMixin)).call(this));

        _this.__lastItems = null;
        _this.__lastMulti = null;
        _this.__selectedMap = null;
        return _this;
      }

      _createClass(ArraySelectorMixin, [{
        key: '__updateSelection',
        value: function __updateSelection(multi, itemsInfo) {
          var path = itemsInfo.path;
          if (path == 'items') {
            // Case 1 - items array changed, so diff against previous array and
            // deselect any removed items and adjust selected indices
            var newItems = itemsInfo.base || [];
            var lastItems = this.__lastItems;
            var lastMulti = this.__lastMulti;
            if (multi !== lastMulti) {
              this.clearSelection();
            }
            if (lastItems) {
              var splices = Polymer.ArraySplice.calculateSplices(newItems, lastItems);
              this.__applySplices(splices);
            }
            this.__lastItems = newItems;
            this.__lastMulti = multi;
          } else if (itemsInfo.path == 'items.splices') {
            // Case 2 - got specific splice information describing the array mutation:
            // deselect any removed items and adjust selected indices
            this.__applySplices(itemsInfo.value.indexSplices);
          } else {
            // Case 3 - an array element was changed, so deselect the previous
            // item for that index if it was previously selected
            var part = path.slice('items.'.length);
            var idx = parseInt(part, 10);
            if (part.indexOf('.') < 0 && part == idx) {
              this.__deselectChangedIdx(idx);
            }
          }
        }
      }, {
        key: '__applySplices',
        value: function __applySplices(splices) {
          var _this2 = this;

          var selected = this.__selectedMap;
          // Adjust selected indices and mark removals

          var _loop = function _loop(i) {
            var s = splices[i];
            selected.forEach(function (idx, item) {
              if (idx < s.index) {
                // no change
              } else if (idx >= s.index + s.removed.length) {
                // adjust index
                selected.set(item, idx + s.addedCount - s.removed.length);
              } else {
                // remove index
                selected.set(item, -1);
              }
            });
            for (var j = 0; j < s.addedCount; j++) {
              var idx = s.index + j;
              if (selected.has(_this2.items[idx])) {
                selected.set(_this2.items[idx], idx);
              }
            }
          };

          for (var i = 0; i < splices.length; i++) {
            _loop(i);
          }
          // Update linked paths
          this.__updateLinks();
          // Remove selected items that were removed from the items array
          var sidx = 0;
          selected.forEach(function (idx, item) {
            if (idx < 0) {
              if (_this2.multi) {
                _this2.splice('selected', sidx, 1);
              } else {
                _this2.selected = _this2.selectedItem = null;
              }
              selected.delete(item);
            } else {
              sidx++;
            }
          });
        }
      }, {
        key: '__updateLinks',
        value: function __updateLinks() {
          var _this3 = this;

          this.__dataLinkedPaths = {};
          if (this.multi) {
            var sidx = 0;
            this.__selectedMap.forEach(function (idx) {
              if (idx >= 0) {
                _this3.linkPaths('items.' + idx, 'selected.' + sidx++);
              }
            });
          } else {
            this.__selectedMap.forEach(function (idx) {
              _this3.linkPaths('selected', 'items.' + idx);
              _this3.linkPaths('selectedItem', 'items.' + idx);
            });
          }
        }

        /**
         * Clears the selection state.
         *
         */

      }, {
        key: 'clearSelection',
        value: function clearSelection() {
          // Unbind previous selection
          this.__dataLinkedPaths = {};
          // The selected map stores 3 pieces of information:
          // key: items array object
          // value: items array index
          // order: selected array index
          this.__selectedMap = new Map();
          // Initialize selection
          this.selected = this.multi ? [] : null;
          this.selectedItem = null;
        }

        /**
         * Returns whether the item is currently selected.
         *
         * @param {*} item Item from `items` array to test
         * @return {boolean} Whether the item is selected
         */

      }, {
        key: 'isSelected',
        value: function isSelected(item) {
          return this.__selectedMap.has(item);
        }

        /**
         * Returns whether the item is currently selected.
         *
         * @param {number} idx Index from `items` array to test
         * @return {boolean} Whether the item is selected
         */

      }, {
        key: 'isIndexSelected',
        value: function isIndexSelected(idx) {
          return this.isSelected(this.items[idx]);
        }
      }, {
        key: '__deselectChangedIdx',
        value: function __deselectChangedIdx(idx) {
          var _this4 = this;

          var sidx = this.__selectedIndexForItemIndex(idx);
          if (sidx >= 0) {
            var i = 0;
            this.__selectedMap.forEach(function (idx, item) {
              if (sidx == i++) {
                _this4.deselect(item);
              }
            });
          }
        }
      }, {
        key: '__selectedIndexForItemIndex',
        value: function __selectedIndexForItemIndex(idx) {
          var selected = this.__dataLinkedPaths['items.' + idx];
          if (selected) {
            return parseInt(selected.slice('selected.'.length), 10);
          }
        }

        /**
         * Deselects the given item if it is already selected.
         *
         * @param {*} item Item from `items` array to deselect
         */

      }, {
        key: 'deselect',
        value: function deselect(item) {
          var idx = this.__selectedMap.get(item);
          if (idx >= 0) {
            this.__selectedMap.delete(item);
            var sidx = void 0;
            if (this.multi) {
              sidx = this.__selectedIndexForItemIndex(idx);
            }
            this.__updateLinks();
            if (this.multi) {
              this.splice('selected', sidx, 1);
            } else {
              this.selected = this.selectedItem = null;
            }
          }
        }

        /**
         * Deselects the given index if it is already selected.
         *
         * @param {number} idx Index from `items` array to deselect
         */

      }, {
        key: 'deselectIndex',
        value: function deselectIndex(idx) {
          this.deselect(this.items[idx]);
        }

        /**
         * Selects the given item.  When `toggle` is true, this will automatically
         * deselect the item if already selected.
         *
         * @param {*} item Item from `items` array to select
         */

      }, {
        key: 'select',
        value: function select(item) {
          this.selectIndex(this.items.indexOf(item));
        }

        /**
         * Selects the given index.  When `toggle` is true, this will automatically
         * deselect the item if already selected.
         *
         * @param {number} idx Index from `items` array to select
         */

      }, {
        key: 'selectIndex',
        value: function selectIndex(idx) {
          var item = this.items[idx];
          if (!this.isSelected(item)) {
            if (!this.multi) {
              this.__selectedMap.clear();
            }
            this.__selectedMap.set(item, idx);
            this.__updateLinks();
            if (this.multi) {
              this.push('selected', item);
            } else {
              this.selected = this.selectedItem = item;
            }
          } else if (this.toggle) {
            this.deselectIndex(idx);
          }
        }
      }]);

      return ArraySelectorMixin;
    }(elementBase);

    return ArraySelectorMixin;
  });

  // export mixin
  Polymer.ArraySelectorMixin = ArraySelectorMixin;

  /**
   * @constructor
   * @extends {Polymer.Element}
   * @implements {Polymer_ArraySelectorMixin}
   */
  var baseArraySelector = ArraySelectorMixin(Polymer.Element);

  /**
   * Element implementing the `Polymer.ArraySelector` mixin, which records
   * dynamic associations between item paths in a master `items` array and a
   * `selected` array such that path changes to the master array (at the host)
   * element or elsewhere via data-binding) are correctly propagated to items
   * in the selected array and vice-versa.
   *
   * The `items` property accepts an array of user data, and via the
   * `select(item)` and `deselect(item)` API, updates the `selected` property
   * which may be bound to other parts of the application, and any changes to
   * sub-fields of `selected` item(s) will be kept in sync with items in the
   * `items` array.  When `multi` is false, `selected` is a property
   * representing the last selected item.  When `multi` is true, `selected`
   * is an array of multiply selected items.
   *
   * Example:
   *
   * ```html
   * <dom-module id="employee-list">
   *
   *   <template>
   *
   *     <div> Employee list: </div>
   *     <template is="dom-repeat" id="employeeList" items="{{employees}}">
   *         <div>First name: <span>{{item.first}}</span></div>
   *         <div>Last name: <span>{{item.last}}</span></div>
   *         <button on-click="toggleSelection">Select</button>
   *     </template>
   *
   *     <array-selector id="selector" items="{{employees}}" selected="{{selected}}" multi toggle></array-selector>
   *
   *     <div> Selected employees: </div>
   *     <template is="dom-repeat" items="{{selected}}">
   *         <div>First name: <span>{{item.first}}</span></div>
   *         <div>Last name: <span>{{item.last}}</span></div>
   *     </template>
   *
   *   </template>
   *
   * </dom-module>
   * ```
   *
   * ```js
   * Polymer({
   *   is: 'employee-list',
   *   ready() {
   *     this.employees = [
   *         {first: 'Bob', last: 'Smith'},
   *         {first: 'Sally', last: 'Johnson'},
   *         ...
   *     ];
   *   },
   *   toggleSelection(e) {
   *     let item = this.$.employeeList.itemForElement(e.target);
   *     this.$.selector.select(item);
   *   }
   * });
   * ```
   *
   * @polymer
   * @customElement
   * @extends {baseArraySelector}
   * @appliesMixin Polymer.ArraySelectorMixin
   * @memberof Polymer
   * @summary Custom element that links paths between an input `items` array and
   *   an output `selected` item or array based on calls to its selection API.
   */

  var ArraySelector = function (_baseArraySelector) {
    _inherits(ArraySelector, _baseArraySelector);

    function ArraySelector() {
      _classCallCheck(this, ArraySelector);

      return _possibleConstructorReturn(this, (ArraySelector.__proto__ || Object.getPrototypeOf(ArraySelector)).apply(this, arguments));
    }

    _createClass(ArraySelector, null, [{
      key: 'is',

      // Not needed to find template; can be removed once the analyzer
      // can find the tag name from customElements.define call
      get: function get() {
        return 'array-selector';
      }
    }]);

    return ArraySelector;
  }(baseArraySelector);

  customElements.define(ArraySelector.is, ArraySelector);
  Polymer.ArraySelector = ArraySelector;
})();

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

__webpack_require__(62);

__webpack_require__(21);

(function () {
  'use strict';

  var attr = 'include';

  var CustomStyleInterface = window.ShadyCSS.CustomStyleInterface;

  /**
   * Custom element for defining styles in the main document that can take
   * advantage of several special features of Polymer's styling system:
   *
   * - Document styles defined in a custom-style are shimmed to ensure they
   *   do not leak into local DOM when running on browsers without native
   *   Shadow DOM.
   * - Custom properties used by Polymer's shim for cross-scope styling may
   *   be defined in an custom-style. Use the :root selector to define custom
   *   properties that apply to all custom elements.
   *
   * To use, simply wrap an inline `<style>` tag in the main document whose
   * CSS uses these features with a `<custom-style>` element.
   *
   * @customElement
   * @extends HTMLElement
   * @memberof Polymer
   * @summary Custom element for defining styles in the main document that can
   *   take advantage of Polymer's style scoping and custom properties shims.
   */

  var CustomStyle = function (_HTMLElement) {
    _inherits(CustomStyle, _HTMLElement);

    function CustomStyle() {
      _classCallCheck(this, CustomStyle);

      var _this = _possibleConstructorReturn(this, (CustomStyle.__proto__ || Object.getPrototypeOf(CustomStyle)).call(this));

      _this._style = null;
      CustomStyleInterface.addCustomStyle(_this);
      return _this;
    }
    /**
     * Returns the light-DOM `<style>` child this element wraps.  Upon first
     * call any style modules referenced via the `include` attribute will be
     * concatenated to this element's `<style>`.
     *
     * @return {HTMLStyleElement} This element's light-DOM `<style>`
     */


    _createClass(CustomStyle, [{
      key: 'getStyle',
      value: function getStyle() {
        if (this._style) {
          return this._style;
        }
        var style = /** @type {HTMLStyleElement} */this.querySelector('style');
        if (!style) {
          return null;
        }
        this._style = style;
        var include = style.getAttribute(attr);
        if (include) {
          style.removeAttribute(attr);
          style.textContent = Polymer.StyleGather.cssFromModules(include) + style.textContent;
        }
        return this._style;
      }
    }]);

    return CustomStyle;
  }(HTMLElement);

  window.customElements.define('custom-style', CustomStyle);
  Polymer.CustomStyle = CustomStyle;
})();

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(63);

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


(function () {
  /*
  Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
  This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
  The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
  The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
  Code distributed by Google as part of the polymer project is also
  subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
  */
  'use strict';
  var c = !(window.ShadyDOM && window.ShadyDOM.inUse),
      f;function g(a) {
    f = a && a.shimcssproperties ? !1 : c || !(navigator.userAgent.match(/AppleWebKit\/601|Edge\/15/) || !window.CSS || !CSS.supports || !CSS.supports("box-shadow", "0 0 0 var(--foo)"));
  }window.ShadyCSS && void 0 !== window.ShadyCSS.nativeCss ? f = window.ShadyCSS.nativeCss : window.ShadyCSS ? (g(window.ShadyCSS), window.ShadyCSS = void 0) : g(window.WebComponents && window.WebComponents.flags);var h = f;function k(a, b) {
    for (var d in b) {
      null === d ? a.style.removeProperty(d) : a.style.setProperty(d, b[d]);
    }
  };var l = null,
      m = window.HTMLImports && window.HTMLImports.whenReady || null,
      n;function p() {
    var a = q;requestAnimationFrame(function () {
      m ? m(a) : (l || (l = new Promise(function (a) {
        n = a;
      }), "complete" === document.readyState ? n() : document.addEventListener("readystatechange", function () {
        "complete" === document.readyState && n();
      })), l.then(function () {
        a && a();
      }));
    });
  };var r = null,
      q = null;function t() {
    this.customStyles = [];this.enqueued = !1;
  }function u(a) {
    !a.enqueued && q && (a.enqueued = !0, p());
  }t.prototype.c = function (a) {
    a.__seenByShadyCSS || (a.__seenByShadyCSS = !0, this.customStyles.push(a), u(this));
  };t.prototype.b = function (a) {
    if (a.__shadyCSSCachedStyle) return a.__shadyCSSCachedStyle;var b;a.getStyle ? b = a.getStyle() : b = a;return b;
  };
  t.prototype.a = function () {
    for (var a = this.customStyles, b = 0; b < a.length; b++) {
      var d = a[b];if (!d.__shadyCSSCachedStyle) {
        var e = this.b(d);e && (e = e.__appliedElement || e, r && r(e), d.__shadyCSSCachedStyle = e);
      }
    }return a;
  };t.prototype.addCustomStyle = t.prototype.c;t.prototype.getStyleForCustomStyle = t.prototype.b;t.prototype.processStyles = t.prototype.a;
  Object.defineProperties(t.prototype, { transformCallback: { get: function get() {
        return r;
      }, set: function set(a) {
        r = a;
      } }, validateCallback: { get: function get() {
        return q;
      }, set: function set(a) {
        var b = !1;q || (b = !0);q = a;b && u(this);
      } } });var v = new t();window.ShadyCSS || (window.ShadyCSS = { prepareTemplate: function prepareTemplate() {}, styleSubtree: function styleSubtree(a, b) {
      v.a();k(a, b);
    }, styleElement: function styleElement() {
      v.a();
    }, styleDocument: function styleDocument(a) {
      v.a();k(document.body, a);
    }, getComputedStyleValue: function getComputedStyleValue(a, b) {
      return (a = window.getComputedStyle(a).getPropertyValue(b)) ? a.trim() : "";
    }, nativeCss: h, nativeShadow: c });window.ShadyCSS.CustomStyleInterface = v;
}).call(undefined);

//# sourceMappingURL=custom-style-interface.min.js.map

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(9);

(function () {
  'use strict';

  var mutablePropertyChange = void 0;
  (
  /** @suppress {missingProperties} */
  function () {
    mutablePropertyChange = Polymer.MutableData._mutablePropertyChange;
  })();

  /**
   * Legacy element behavior to skip strict dirty-checking for objects and arrays,
   * (always consider them to be "dirty") for use on legacy API Polymer elements.
   *
   * By default, `Polymer.PropertyEffects` performs strict dirty checking on
   * objects, which means that any deep modifications to an object or array will
   * not be propagated unless "immutable" data patterns are used (i.e. all object
   * references from the root to the mutation were changed).
   *
   * Polymer also provides a proprietary data mutation and path notification API
   * (e.g. `notifyPath`, `set`, and array mutation API's) that allow efficient
   * mutation and notification of deep changes in an object graph to all elements
   * bound to the same object graph.
   *
   * In cases where neither immutable patterns nor the data mutation API can be
   * used, applying this mixin will cause Polymer to skip dirty checking for
   * objects and arrays (always consider them to be "dirty").  This allows a
   * user to make a deep modification to a bound object graph, and then either
   * simply re-set the object (e.g. `this.items = this.items`) or call `notifyPath`
   * (e.g. `this.notifyPath('items')`) to update the tree.  Note that all
   * elements that wish to be updated based on deep mutations must apply this
   * mixin or otherwise skip strict dirty checking for objects/arrays.
   *
   * In order to make the dirty check strategy configurable, see
   * `Polymer.OptionalMutableDataBehavior`.
   *
   * Note, the performance characteristics of propagating large object graphs
   * will be worse as opposed to using strict dirty checking with immutable
   * patterns or Polymer's path notification API.
   *
   * @polymerBehavior
   * @memberof Polymer
   * @summary Behavior to skip strict dirty-checking for objects and
   *   arrays
   */
  Polymer.MutableDataBehavior = {

    /**
     * Overrides `Polymer.PropertyEffects` to provide option for skipping
     * strict equality checking for Objects and Arrays.
     *
     * This method pulls the value to dirty check against from the `__dataTemp`
     * cache (rather than the normal `__data` cache) for Objects.  Since the temp
     * cache is cleared at the end of a turn, this implementation allows
     * side-effects of deep object changes to be processed by re-setting the
     * same object (using the temp cache as an in-turn backstop to prevent
     * cycles due to 2-way notification).
     *
     * @param {string} property Property name
     * @param {*} value New property value
     * @param {*} old Previous property value
     * @return {boolean} Whether the property should be considered a change
     * @protected
     */
    _shouldPropertyChange: function _shouldPropertyChange(property, value, old) {
      return mutablePropertyChange(this, property, value, old, true);
    }
  };

  /**
   * Legacy element behavior to add the optional ability to skip strict
   * dirty-checking for objects and arrays (always consider them to be
   * "dirty") by setting a `mutable-data` attribute on an element instance.
   *
   * By default, `Polymer.PropertyEffects` performs strict dirty checking on
   * objects, which means that any deep modifications to an object or array will
   * not be propagated unless "immutable" data patterns are used (i.e. all object
   * references from the root to the mutation were changed).
   *
   * Polymer also provides a proprietary data mutation and path notification API
   * (e.g. `notifyPath`, `set`, and array mutation API's) that allow efficient
   * mutation and notification of deep changes in an object graph to all elements
   * bound to the same object graph.
   *
   * In cases where neither immutable patterns nor the data mutation API can be
   * used, applying this mixin will allow Polymer to skip dirty checking for
   * objects and arrays (always consider them to be "dirty").  This allows a
   * user to make a deep modification to a bound object graph, and then either
   * simply re-set the object (e.g. `this.items = this.items`) or call `notifyPath`
   * (e.g. `this.notifyPath('items')`) to update the tree.  Note that all
   * elements that wish to be updated based on deep mutations must apply this
   * mixin or otherwise skip strict dirty checking for objects/arrays.
   *
   * While this behavior adds the ability to forgo Object/Array dirty checking,
   * the `mutableData` flag defaults to false and must be set on the instance.
   *
   * Note, the performance characteristics of propagating large object graphs
   * will be worse by relying on `mutableData: true` as opposed to using
   * strict dirty checking with immutable patterns or Polymer's path notification
   * API.
   *
   * @polymerBehavior
   * @memberof Polymer
   * @summary Behavior to optionally skip strict dirty-checking for objects and
   *   arrays
   */
  Polymer.OptionalMutableDataBehavior = {

    properties: {
      /**
       * Instance-level flag for configuring the dirty-checking strategy
       * for this element.  When true, Objects and Arrays will skip dirty
       * checking, otherwise strict equality checking will be used.
       */
      mutableData: Boolean
    },

    /**
     * Overrides `Polymer.PropertyEffects` to skip strict equality checking
     * for Objects and Arrays.
     *
     * Pulls the value to dirty check against from the `__dataTemp` cache
     * (rather than the normal `__data` cache) for Objects.  Since the temp
     * cache is cleared at the end of a turn, this implementation allows
     * side-effects of deep object changes to be processed by re-setting the
     * same object (using the temp cache as an in-turn backstop to prevent
     * cycles due to 2-way notification).
     *
     * @param {string} property Property name
     * @param {*} value New property value
     * @param {*} old Previous property value
     * @return {boolean} Whether the property should be considered a change
     * @this {this}
     * @protected
     */
    _shouldPropertyChange: function _shouldPropertyChange(property, value, old) {
      return mutablePropertyChange(this, property, value, old, this.mutableData);
    }
  };
})();

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

__webpack_require__(66);

__webpack_require__(15);

var RegisterHtmlTemplate = __webpack_require__(2);

RegisterHtmlTemplate.register("<dom-module id=app-drawer-layout> <template> <style>:host{display:block;position:relative;z-index:0}:host ::slotted([slot=drawer]){z-index:1}:host([fullbleed]){@apply --layout-fit;}#contentContainer{position:relative;z-index:0;height:100%;transition:var(--app-drawer-layout-content-transition,none)}#contentContainer[drawer-position=left]{margin-left:var(--app-drawer-width,256px)}#contentContainer[drawer-position=right]{margin-right:var(--app-drawer-width,256px)}</style> <slot id=drawerSlot name=drawer></slot> <div id=contentContainer drawer-position$=[[_drawerPosition]]> <slot></slot> </div> <iron-media-query query=\"[[_computeMediaQuery(forceNarrow, responsiveWidth)]]\" on-query-matches-changed=_onQueryMatchesChanged></iron-media-query> </template> </dom-module>");

Polymer({
  is: 'app-drawer-layout',

  behaviors: [Polymer.AppLayoutBehavior],

  properties: {
    /**
     * If true, ignore `responsiveWidth` setting and force the narrow layout.
     */
    forceNarrow: {
      type: Boolean,
      value: false
    },

    /**
     * If the viewport's width is smaller than this value, the panel will change to narrow
     * layout. In the mode the drawer will be closed.
     */
    responsiveWidth: {
      type: String,
      value: '640px'
    },

    /**
     * Returns true if it is in narrow layout. This is useful if you need to show/hide
     * elements based on the layout.
     */
    narrow: {
      type: Boolean,
      reflectToAttribute: true,
      readOnly: true,
      notify: true
    },

    /**
     * If true, the drawer will initially be opened when in narrow layout mode.
     */
    openedWhenNarrow: {
      type: Boolean,
      value: false
    },

    _drawerPosition: {
      type: String
    }
  },

  listeners: {
    'click': '_clickHandler'
  },

  observers: ['_narrowChanged(narrow)'],

  /**
   * A reference to the app-drawer element.
   *
   * @property drawer
   */
  get drawer() {
    return Polymer.dom(this.$.drawerSlot).getDistributedNodes()[0];
  },

  attached: function attached() {
    // Disable drawer transitions until after app-drawer-layout sets the initial opened state.
    var drawer = this.drawer;
    if (drawer) {
      drawer.setAttribute('no-transition', '');
    }
  },

  _clickHandler: function _clickHandler(e) {
    var target = Polymer.dom(e).localTarget;
    if (target && target.hasAttribute('drawer-toggle')) {
      var drawer = this.drawer;
      if (drawer && !drawer.persistent) {
        drawer.toggle();
      }
    }
  },

  _updateLayoutStates: function _updateLayoutStates() {
    var drawer = this.drawer;
    if (!this.isAttached || !drawer) {
      return;
    }

    this._drawerPosition = this.narrow ? null : drawer.position;
    if (this._drawerNeedsReset) {
      if (this.narrow) {
        drawer.opened = this.openedWhenNarrow;
        drawer.persistent = false;
      } else {
        drawer.opened = drawer.persistent = true;
      }
      if (drawer.hasAttribute('no-transition')) {
        // Enable drawer transitions after app-drawer-layout sets the initial opened state.
        Polymer.RenderStatus.afterNextRender(this, function () {
          drawer.removeAttribute('no-transition');
        });
      }
      this._drawerNeedsReset = false;
    }
  },

  _narrowChanged: function _narrowChanged() {
    this._drawerNeedsReset = true;
    this.resetLayout();
  },

  _onQueryMatchesChanged: function _onQueryMatchesChanged(event) {
    this._setNarrow(event.detail.value);
  },

  _computeMediaQuery: function _computeMediaQuery(forceNarrow, responsiveWidth) {
    return forceNarrow ? '(min-width: 0px)' : '(max-width: ' + responsiveWidth + ')';
  }
});

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

Polymer({

  is: 'iron-media-query',

  properties: {

    /**
     * The Boolean return value of the media query.
     */
    queryMatches: {
      type: Boolean,
      value: false,
      readOnly: true,
      notify: true
    },

    /**
     * The CSS media query to evaluate.
     */
    query: {
      type: String,
      observer: 'queryChanged'
    },

    /**
     * If true, the query attribute is assumed to be a complete media query
     * string rather than a single media feature.
     */
    full: {
      type: Boolean,
      value: false
    },

    /**
     * @type {function(MediaQueryList)}
     */
    _boundMQHandler: {
      value: function value() {
        return this.queryHandler.bind(this);
      }
    },

    /**
     * @type {MediaQueryList}
     */
    _mq: {
      value: null
    }
  },

  attached: function attached() {
    this.style.display = 'none';
    this.queryChanged();
  },

  detached: function detached() {
    this._remove();
  },

  _add: function _add() {
    if (this._mq) {
      this._mq.addListener(this._boundMQHandler);
    }
  },

  _remove: function _remove() {
    if (this._mq) {
      this._mq.removeListener(this._boundMQHandler);
    }
    this._mq = null;
  },

  queryChanged: function queryChanged() {
    this._remove();
    var query = this.query;
    if (!query) {
      return;
    }
    if (!this.full && query[0] !== '(') {
      query = '(' + query + ')';
    }
    this._mq = window.matchMedia(query);
    this._add();
    this.queryHandler(this._mq);
  },

  queryHandler: function queryHandler(mq) {
    this._setQueryMatches(mq.matches);
  }

});

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

__webpack_require__(5);

__webpack_require__(4);

__webpack_require__(15);

var RegisterHtmlTemplate = __webpack_require__(2);

RegisterHtmlTemplate.register("<dom-module id=app-header> <template> <style>:host{position:relative;display:block;transition-timing-function:linear;transition-property:-webkit-transform;transition-property:transform}:host::before{position:absolute;right:0;bottom:-5px;left:0;width:100%;height:5px;content:\"\";transition:opacity .4s;pointer-events:none;opacity:0;box-shadow:inset 0 5px 6px -3px rgba(0,0,0,.4);will-change:opacity;@apply --app-header-shadow;}:host([shadow])::before{opacity:1}#background{@apply --layout-fit;overflow:hidden}#backgroundFrontLayer,#backgroundRearLayer{@apply --layout-fit;height:100%;pointer-events:none;background-size:cover}#backgroundFrontLayer{@apply --app-header-background-front-layer;}#backgroundRearLayer{opacity:0;@apply --app-header-background-rear-layer;}#contentContainer{position:relative;width:100%;height:100%}:host([disabled]),:host([disabled]) #backgroundFrontLayer,:host([disabled]) #backgroundRearLayer,:host([disabled])::after,:host([silent-scroll]),:host([silent-scroll]) #backgroundFrontLayer,:host([silent-scroll]) #backgroundRearLayer,:host([silent-scroll])::after{transition:none!important}:host([disabled]) ::slotted([sticky]),:host([disabled]) ::slotted(app-toolbar:first-of-type),:host([silent-scroll]) ::slotted([sticky]),:host([silent-scroll]) ::slotted(app-toolbar:first-of-type){transition:none!important}</style> <div id=contentContainer> <slot id=slot></slot> </div> </template> </dom-module>");

Polymer({
  is: 'app-header',

  behaviors: [Polymer.AppScrollEffectsBehavior, Polymer.AppLayoutBehavior],

  properties: {
    /**
     * If true, the header will automatically collapse when scrolling down.
     * That is, the `sticky` element remains visible when the header is fully condensed
     * whereas the rest of the elements will collapse below `sticky` element.
     *
     * By default, the `sticky` element is the first toolbar in the light DOM:
     *
     *```html
     * <app-header condenses>
     *   <app-toolbar>This toolbar remains on top</app-toolbar>
     *   <app-toolbar></app-toolbar>
     *   <app-toolbar></app-toolbar>
     * </app-header>
     * ```
     *
     * Additionally, you can specify which toolbar or element remains visible in condensed mode
     * by adding the `sticky` attribute to that element. For example: if we want the last
     * toolbar to remain visible, we can add the `sticky` attribute to it.
     *
     *```html
     * <app-header condenses>
     *   <app-toolbar></app-toolbar>
     *   <app-toolbar></app-toolbar>
     *   <app-toolbar sticky>This toolbar remains on top</app-toolbar>
     * </app-header>
     * ```
     *
     * Note the `sticky` element must be a direct child of `app-header`.
     */
    condenses: {
      type: Boolean,
      value: false
    },

    /**
     * Mantains the header fixed at the top so it never moves away.
     */
    fixed: {
      type: Boolean,
      value: false
    },

    /**
     * Slides back the header when scrolling back up.
     */
    reveals: {
      type: Boolean,
      value: false
    },

    /**
     * Displays a shadow below the header.
     */
    shadow: {
      type: Boolean,
      reflectToAttribute: true,
      value: false
    }
  },

  observers: ['_configChanged(isAttached, condenses, fixed)'],

  /**
   * A cached offsetHeight of the current element.
   *
   * @type {number}
   */
  _height: 0,

  /**
   * The distance in pixels the header will be translated to when scrolling.
   *
   * @type {number}
   */
  _dHeight: 0,

  /**
   * The offsetTop of `_stickyEl`
   *
   * @type {number}
   */
  _stickyElTop: 0,

  /**
   * A reference to the element that remains visible when the header condenses.
   *
   * @type {HTMLElement}
   */
  _stickyElRef: null,

  /**
   * The header's top value used for the `transformY`
   *
   * @type {number}
   */
  _top: 0,

  /**
   * The current scroll progress.
   *
   * @type {number}
   */
  _progress: 0,

  _wasScrollingDown: false,
  _initScrollTop: 0,
  _initTimestamp: 0,
  _lastTimestamp: 0,
  _lastScrollTop: 0,

  /**
   * The distance the header is allowed to move away.
   *
   * @type {number}
   */
  get _maxHeaderTop() {
    return this.fixed ? this._dHeight : this._height + 5;
  },

  /**
   * Returns a reference to the sticky element.
   *
   * @return {HTMLElement}?
   */
  get _stickyEl() {
    if (this._stickyElRef) {
      return this._stickyElRef;
    }
    var nodes = Polymer.dom(this.$.slot).getDistributedNodes();
    // Get the element with the sticky attribute on it or the first element in the light DOM.
    for (var i = 0, node; node = nodes[i]; i++) {
      if (node.nodeType === Node.ELEMENT_NODE) {
        if (node.hasAttribute('sticky')) {
          this._stickyElRef = node;
          break;
        } else if (!this._stickyElRef) {
          this._stickyElRef = node;
        }
      }
    }
    return this._stickyElRef;
  },

  _configChanged: function _configChanged() {
    this.resetLayout();
    this._notifyLayoutChanged();
  },

  _updateLayoutStates: function _updateLayoutStates() {
    if (this.offsetWidth === 0 && this.offsetHeight === 0) {
      return;
    }
    var scrollTop = this._clampedScrollTop;
    var firstSetup = this._height === 0 || scrollTop === 0;
    var currentDisabled = this.disabled;
    this._height = this.offsetHeight;
    this._stickyElRef = null;
    this.disabled = true;
    // prepare for measurement
    if (!firstSetup) {
      this._updateScrollState(0, true);
    }
    if (this._mayMove()) {
      this._dHeight = this._stickyEl ? this._height - this._stickyEl.offsetHeight : 0;
    } else {
      this._dHeight = 0;
    }
    this._stickyElTop = this._stickyEl ? this._stickyEl.offsetTop : 0;
    this._setUpEffect();
    if (firstSetup) {
      this._updateScrollState(scrollTop, true);
    } else {
      this._updateScrollState(this._lastScrollTop, true);
      this._layoutIfDirty();
    }
    // restore no transition
    this.disabled = currentDisabled;
  },

  /**
   * Updates the scroll state.
   *
   * @param {number} scrollTop
   * @param {boolean=} forceUpdate (default: false)
   */
  _updateScrollState: function _updateScrollState(scrollTop, forceUpdate) {
    if (this._height === 0) {
      return;
    }
    var progress = 0;
    var top = 0;
    var lastTop = this._top;
    var lastScrollTop = this._lastScrollTop;
    var maxHeaderTop = this._maxHeaderTop;
    var dScrollTop = scrollTop - this._lastScrollTop;
    var absDScrollTop = Math.abs(dScrollTop);
    var isScrollingDown = scrollTop > this._lastScrollTop;
    var now = performance.now();

    if (this._mayMove()) {
      top = this._clamp(this.reveals ? lastTop + dScrollTop : scrollTop, 0, maxHeaderTop);
    }
    if (scrollTop >= this._dHeight) {
      top = this.condenses && !this.fixed ? Math.max(this._dHeight, top) : top;
      this.style.transitionDuration = '0ms';
    }
    if (this.reveals && !this.disabled && absDScrollTop < 100) {
      // set the initial scroll position
      if (now - this._initTimestamp > 300 || this._wasScrollingDown !== isScrollingDown) {
        this._initScrollTop = scrollTop;
        this._initTimestamp = now;
      }
      if (scrollTop >= maxHeaderTop) {
        // check if the header is allowed to snap
        if (Math.abs(this._initScrollTop - scrollTop) > 30 || absDScrollTop > 10) {
          if (isScrollingDown && scrollTop >= maxHeaderTop) {
            top = maxHeaderTop;
          } else if (!isScrollingDown && scrollTop >= this._dHeight) {
            top = this.condenses && !this.fixed ? this._dHeight : 0;
          }
          var scrollVelocity = dScrollTop / (now - this._lastTimestamp);
          this.style.transitionDuration = this._clamp((top - lastTop) / scrollVelocity, 0, 300) + 'ms';
        } else {
          top = this._top;
        }
      }
    }
    if (this._dHeight === 0) {
      progress = scrollTop > 0 ? 1 : 0;
    } else {
      progress = top / this._dHeight;
    }
    if (!forceUpdate) {
      this._lastScrollTop = scrollTop;
      this._top = top;
      this._wasScrollingDown = isScrollingDown;
      this._lastTimestamp = now;
    }
    if (forceUpdate || progress !== this._progress || lastTop !== top || scrollTop === 0) {
      this._progress = progress;
      this._runEffects(progress, top);
      this._transformHeader(top);
    }
  },

  /**
   * Returns true if the current header is allowed to move as the user scrolls.
   *
   * @return {boolean}
   */
  _mayMove: function _mayMove() {
    return this.condenses || !this.fixed;
  },

  /**
   * Returns true if the current header will condense based on the size of the header
   * and the `consenses` property.
   *
   * @return {boolean}
   */
  willCondense: function willCondense() {
    return this._dHeight > 0 && this.condenses;
  },

  /**
   * Returns true if the current element is on the screen.
   * That is, visible in the current viewport.
   *
   * @method isOnScreen
   * @return {boolean}
   */
  isOnScreen: function isOnScreen() {
    return this._height !== 0 && this._top < this._height;
  },

  /**
   * Returns true if there's content below the current element.
   *
   * @method isContentBelow
   * @return {boolean}
   */
  isContentBelow: function isContentBelow() {
    return this._top === 0 ? this._clampedScrollTop > 0 : this._clampedScrollTop - this._maxHeaderTop >= 0;
  },

  /**
   * Transforms the header.
   *
   * @param {number} y
   */
  _transformHeader: function _transformHeader(y) {
    this.translate3d(0, -y + 'px', 0);
    if (this._stickyEl) {
      this.translate3d(0, this.condenses && y >= this._stickyElTop ? Math.min(y, this._dHeight) - this._stickyElTop + 'px' : 0, 0, this._stickyEl);
    }
  },

  _clamp: function _clamp(v, min, max) {
    return Math.min(max, Math.max(min, v));
  },

  _ensureBgContainers: function _ensureBgContainers() {
    if (!this._bgContainer) {
      this._bgContainer = document.createElement('div');
      this._bgContainer.id = 'background';
      this._bgRear = document.createElement('div');
      this._bgRear.id = 'backgroundRearLayer';
      this._bgContainer.appendChild(this._bgRear);
      this._bgFront = document.createElement('div');
      this._bgFront.id = 'backgroundFrontLayer';
      this._bgContainer.appendChild(this._bgFront);
      Polymer.dom(this.root).insertBefore(this._bgContainer, this.$.contentContainer);
    }
  },

  _getDOMRef: function _getDOMRef(id) {
    switch (id) {
      case 'backgroundFrontLayer':
        this._ensureBgContainers();
        return this._bgFront;
      case 'backgroundRearLayer':
        this._ensureBgContainers();
        return this._bgRear;
      case 'background':
        this._ensureBgContainers();
        return this._bgContainer;
      case 'mainTitle':
        return Polymer.dom(this).querySelector('[main-title]');
      case 'condensedTitle':
        return Polymer.dom(this).querySelector('[condensed-title]');
    }
    return null;
  },

  /**
   * Returns an object containing the progress value of the scroll effects
   * and the top position of the header.
   *
   * @method getScrollState
   * @return {Object}
   */
  getScrollState: function getScrollState() {
    return { progress: this._progress, top: this._top };
  }
});

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

Polymer.AppLayout = Polymer.AppLayout || {};

Polymer.AppLayout._scrollEffects = Polymer.AppLayout._scrollEffects || {};

Polymer.AppLayout.scrollTimingFunction = function easeOutQuad(t, b, c, d) {
  t /= d;
  return -c * t * (t - 2) + b;
};

/**
 * Registers a scroll effect to be used in elements that implement the
 * `Polymer.AppScrollEffectsBehavior` behavior.
 *
 * @param {string} effectName The effect name.
 * @param {Object} effectDef The effect definition.
 */
Polymer.AppLayout.registerEffect = function registerEffect(effectName, effectDef) {
  if (Polymer.AppLayout._scrollEffects[effectName] != null) {
    throw new Error('effect `' + effectName + '` is already registered.');
  }
  Polymer.AppLayout._scrollEffects[effectName] = effectDef;
};

Polymer.AppLayout.queryAllRoot = function (selector, root) {
  var queue = [root];
  var matches = [];

  while (queue.length > 0) {
    var node = queue.shift();
    matches.push.apply(matches, node.querySelectorAll(selector));
    for (i = 0; node.children[i]; i++) {
      if (node.children[i].shadowRoot) {
        queue.push(node.children[i].shadowRoot);
      }
    }
  }
  return matches;
};

/**
 * Scrolls to a particular set of coordinates in a scroll target.
 * If the scroll target is not defined, then it would use the main document as the target.
 *
 * To scroll in a smooth fashion, you can set the option `behavior: 'smooth'`. e.g.
 *
 * ```js
 * Polymer.AppLayout.scroll({top: 0, behavior: 'smooth'});
 * ```
 *
 * To scroll in a silent mode, without notifying scroll changes to any app-layout elements,
 * you can set the option `behavior: 'silent'`. This is particularly useful we you are using
 * `app-header` and you desire to scroll to the top of a scrolling region without running
 * scroll effects. e.g.
 *
 * ```js
 * Polymer.AppLayout.scroll({top: 0, behavior: 'silent'});
 * ```
 *
 * @param {Object} options {top: Number, left: Number, behavior: String(smooth | silent)}
 */
Polymer.AppLayout.scroll = function scroll(options) {
  options = options || {};

  var docEl = document.documentElement;
  var target = options.target || docEl;
  var hasNativeScrollBehavior = 'scrollBehavior' in target.style && target.scroll;
  var scrollClassName = 'app-layout-silent-scroll';
  var scrollTop = options.top || 0;
  var scrollLeft = options.left || 0;
  var scrollTo = target === docEl ? window.scrollTo : function scrollTo(scrollLeft, scrollTop) {
    target.scrollLeft = scrollLeft;
    target.scrollTop = scrollTop;
  };

  if (options.behavior === 'smooth') {

    if (hasNativeScrollBehavior) {

      target.scroll(options);
    } else {

      var timingFn = Polymer.AppLayout.scrollTimingFunction;
      var startTime = Date.now();
      var currentScrollTop = target === docEl ? window.pageYOffset : target.scrollTop;
      var currentScrollLeft = target === docEl ? window.pageXOffset : target.scrollLeft;
      var deltaScrollTop = scrollTop - currentScrollTop;
      var deltaScrollLeft = scrollLeft - currentScrollLeft;
      var duration = 300;
      var updateFrame = function updateFrame() {
        var now = Date.now();
        var elapsedTime = now - startTime;

        if (elapsedTime < duration) {
          scrollTo(timingFn(elapsedTime, currentScrollLeft, deltaScrollLeft, duration), timingFn(elapsedTime, currentScrollTop, deltaScrollTop, duration));
          requestAnimationFrame(updateFrame);
        } else {
          scrollTo(scrollLeft, scrollTop);
        }
      }.bind(this);

      updateFrame();
    }
  } else if (options.behavior === 'silent') {
    var headers = Polymer.AppLayout.queryAllRoot('app-header', document.body);

    headers.forEach(function (header) {
      header.setAttribute('silent-scroll', '');
    });

    // Browsers keep the scroll momentum even if the bottom of the scrolling content
    // was reached. This means that calling scroll({top: 0, behavior: 'silent'}) when
    // the momentum is still going will result in more scroll events and thus scroll effects.
    // This seems to only apply when using document scrolling.
    // Therefore, when should we remove the class from the document element?

    window.cancelAnimationFrame(Polymer.AppLayout._scrollTimer);

    Polymer.AppLayout._scrollTimer = window.requestAnimationFrame(function () {
      headers.forEach(function (header) {
        header.removeAttribute('silent-scroll');
      });
      Polymer.AppLayout._scrollTimer = null;
    });

    scrollTo(scrollLeft, scrollTop);
  } else {

    scrollTo(scrollLeft, scrollTop);
  }
};

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

__webpack_require__(5);

__webpack_require__(15);

var RegisterHtmlTemplate = __webpack_require__(2);

RegisterHtmlTemplate.register("<dom-module id=app-header-layout> <template> <style>:host{display:block;position:relative;z-index:0}#wrapper ::slotted([slot=header]){@apply --layout-fixed-top;z-index:1}#wrapper.initializing ::slotted([slot=header]){position:relative}:host([has-scrolling-region]){height:100%}:host([has-scrolling-region]) #wrapper ::slotted([slot=header]){position:absolute}:host([has-scrolling-region]) #wrapper.initializing ::slotted([slot=header]){position:relative}:host([has-scrolling-region]) #wrapper #contentContainer{@apply --layout-fit;overflow-y:auto;-webkit-overflow-scrolling:touch}:host([has-scrolling-region]) #wrapper.initializing #contentContainer{position:relative}:host([fullbleed]){@apply --layout-vertical;@apply --layout-fit;}:host([fullbleed]) #wrapper,:host([fullbleed]) #wrapper #contentContainer{@apply --layout-vertical;@apply --layout-flex;}#contentContainer{position:relative;z-index:0}</style> <div id=wrapper class=initializing> <slot id=headerSlot name=header></slot> <div id=contentContainer> <slot></slot> </div> </div> </template> </dom-module>");

Polymer({
  is: 'app-header-layout',

  behaviors: [Polymer.AppLayoutBehavior],

  properties: {
    /**
     * If true, the current element will have its own scrolling region.
     * Otherwise, it will use the document scroll to control the header.
     */
    hasScrollingRegion: {
      type: Boolean,
      value: false,
      reflectToAttribute: true
    }
  },

  observers: ['resetLayout(isAttached, hasScrollingRegion)'],

  /**
   * A reference to the app-header element.
   *
   * @property header
   */
  get header() {
    return Polymer.dom(this.$.headerSlot).getDistributedNodes()[0];
  },

  _updateLayoutStates: function _updateLayoutStates() {
    var header = this.header;
    if (!this.isAttached || !header) {
      return;
    }
    // Remove the initializing class, which staticly positions the header and the content
    // until the height of the header can be read.
    this.$.wrapper.classList.remove('initializing');
    // Update scroll target.
    header.scrollTarget = this.hasScrollingRegion ? this.$.contentContainer : this.ownerDocument.documentElement;
    // Get header height here so that style reads are batched together before style writes
    // (i.e. getBoundingClientRect() below).
    var headerHeight = header.offsetHeight;
    // Update the header position.
    if (!this.hasScrollingRegion) {
      requestAnimationFrame(function () {
        var rect = this.getBoundingClientRect();
        var rightOffset = document.documentElement.clientWidth - rect.right;
        header.style.left = rect.left + 'px';
        header.style.right = rightOffset + 'px';
      }.bind(this));
    } else {
      header.style.left = '';
      header.style.right = '';
    }
    // Update the content container position.
    var containerStyle = this.$.contentContainer.style;
    if (header.fixed && !header.condenses && this.hasScrollingRegion) {
      // If the header size does not change and we're using a scrolling region, exclude
      // the header area from the scrolling region so that the header doesn't overlap
      // the scrollbar.
      containerStyle.marginTop = headerHeight + 'px';
      containerStyle.paddingTop = '';
    } else {
      containerStyle.paddingTop = headerHeight + 'px';
      containerStyle.marginTop = '';
    }
  }

});

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(25);

__webpack_require__(71);

__webpack_require__(72);

__webpack_require__(28);

__webpack_require__(73);

__webpack_require__(27);

__webpack_require__(26);

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(4);

/**
 * Upon scrolling past a threshold, fade in the rear background layer and fade out the front
 * background layer (opacity CSS transitioned over time).
 *
 *
 */
Polymer.AppLayout.registerEffect('fade-background', {
  /** @this Polymer.AppLayout.ElementWithBackground */
  setUp: function setUp(config) {
    var fx = {};
    var duration = config.duration || '0.5s';
    fx.backgroundFrontLayer = this._getDOMRef('backgroundFrontLayer');
    fx.backgroundRearLayer = this._getDOMRef('backgroundRearLayer');
    fx.backgroundFrontLayer.style.willChange = 'opacity';
    fx.backgroundFrontLayer.style.webkitTransform = 'translateZ(0)';
    fx.backgroundFrontLayer.style.transitionProperty = 'opacity';
    fx.backgroundFrontLayer.style.transitionDuration = duration;
    fx.backgroundRearLayer.style.willChange = 'opacity';
    fx.backgroundRearLayer.style.webkitTransform = 'translateZ(0)';
    fx.backgroundRearLayer.style.transitionProperty = 'opacity';
    fx.backgroundRearLayer.style.transitionDuration = duration;
    this._fxFadeBackground = fx;
  },
  /** @this Polymer.AppLayout.ElementWithBackground */
  run: function run(p, y) {
    var fx = this._fxFadeBackground;
    if (p >= 1) {
      fx.backgroundFrontLayer.style.opacity = 0;
      fx.backgroundRearLayer.style.opacity = 1;
    } else {
      fx.backgroundFrontLayer.style.opacity = 1;
      fx.backgroundRearLayer.style.opacity = 0;
    }
  },
  /** @this Polymer.AppLayout.ElementWithBackground */
  tearDown: function tearDown() {
    delete this._fxFadeBackground;
  }
});

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(4);

__webpack_require__(26);

__webpack_require__(27);

__webpack_require__(25);

__webpack_require__(28);

/**
 * Shorthand for the waterfall, resize-title, blend-background, and parallax-background effects.
 */
Polymer.AppLayout.registerEffect('material', {
  /**
   * @this Polymer.AppLayout.ElementWithBackground
   */
  setUp: function setUp() {
    this.effects = 'waterfall resize-title blend-background parallax-background';
    return false;
  }
});

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(4);

/**
 * Upon scrolling past a threshold, CSS transition the font size of a designated title element
 * between two values.
 */
Polymer.AppLayout.registerEffect('resize-snapped-title', {
  /**
   * @this Polymer.AppLayout.ElementWithBackground
   */
  setUp: function setUp(config) {
    var title = this._getDOMRef('mainTitle');
    var condensedTitle = this._getDOMRef('condensedTitle');
    var duration = config.duration || '0.2s';
    var fx = {};

    if (!condensedTitle) {
      console.warn('Scroll effect `resize-snapped-title`: undefined `condensed-title`');
      return false;
    }
    if (!title) {
      console.warn('Scroll effect `resize-snapped-title`: undefined `main-title`');
      return false;
    }

    title.style.transitionProperty = 'opacity';
    title.style.transitionDuration = duration;
    condensedTitle.style.transitionProperty = 'opacity';
    condensedTitle.style.transitionDuration = duration;
    fx.condensedTitle = condensedTitle;
    fx.title = title;
    this._fxResizeSnappedTitle = fx;
  },
  /** @this Polymer.AppLayout.ElementWithBackground */
  run: function run(p, y) {
    var fx = this._fxResizeSnappedTitle;
    if (p > 0) {
      fx.title.style.opacity = 0;
      fx.condensedTitle.style.opacity = 1;
    } else {
      fx.title.style.opacity = 1;
      fx.condensedTitle.style.opacity = 0;
    }
  },
  /** @this Polymer.AppLayout.ElementWithBackground */
  tearDown: function tearDown() {
    var fx = this._fxResizeSnappedTitle;
    fx.title.style.transition = '';
    fx.condensedTitle.style.transition = '';
    delete this._fxResizeSnappedTitle;
  }
});

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

__webpack_require__(5);

var RegisterHtmlTemplate = __webpack_require__(2);

RegisterHtmlTemplate.register("<dom-module id=app-toolbar> <template> <style>:host{@apply --layout-horizontal;@apply --layout-center;position:relative;height:64px;padding:0 16px;pointer-events:none;font-size:var(--app-toolbar-font-size,20px)}:host ::slotted(*){pointer-events:auto}:host ::slotted(paper-icon-button){font-size:0}:host ::slotted([condensed-title]),:host ::slotted([main-title]){pointer-events:none;@apply --layout-flex;}:host ::slotted([bottom-item]){position:absolute;right:0;bottom:0;left:0}:host ::slotted([top-item]){position:absolute;top:0;right:0;left:0}:host ::slotted([spacer]){margin-left:64px}</style> <slot></slot> </template> </dom-module>");

Polymer({
  is: 'app-toolbar'
});

/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

__webpack_require__(76);

__webpack_require__(77);

__webpack_require__(78);

var RegisterHtmlTemplate = __webpack_require__(2);

RegisterHtmlTemplate.register("<dom-module id=app-location> <template> <iron-query-params params-string={{__query}} params-object={{queryParams}}> </iron-query-params> <iron-location path={{__path}} query={{__query}} hash={{__hash}} url-space-regex={{urlSpaceRegex}}> </iron-location> </template> </dom-module>");

(function () {
  'use strict';

  Polymer({
    is: 'app-location',

    properties: {
      /**
       * A model representing the deserialized path through the route tree, as
       * well as the current queryParams.
       */
      route: {
        type: Object,
        notify: true
      },

      /**
       * In many scenarios, it is convenient to treat the `hash` as a stand-in
       * alternative to the `path`. For example, if deploying an app to a static
       * web server (e.g., Github Pages) - where one does not have control over
       * server-side routing - it is usually a better experience to use the hash
       * to represent paths through one's app.
       *
       * When this property is set to true, the `hash` will be used in place of
        * the `path` for generating a `route`.
       */
      useHashAsPath: {
        type: Boolean,
        value: false
      },

      /**
       * A regexp that defines the set of URLs that should be considered part
       * of this web app.
       *
       * Clicking on a link that matches this regex won't result in a full page
       * navigation, but will instead just update the URL state in place.
       *
       * This regexp is given everything after the origin in an absolute
       * URL. So to match just URLs that start with /search/ do:
       *     url-space-regex="^/search/"
       *
       * @type {string|RegExp}
       */
      urlSpaceRegex: {
        type: String,
        notify: true
      },

      /**
       * A set of key/value pairs that are universally accessible to branches
       * of the route tree.
       */
      __queryParams: {
        type: Object
      },

      /**
       * The pathname component of the current URL.
       */
      __path: {
        type: String
      },

      /**
       * The query string portion of the current URL.
       */
      __query: {
        type: String
      },

      /**
       * The hash portion of the current URL.
       */
      __hash: {
        type: String
      },

      /**
       * The route path, which will be either the hash or the path, depending
       * on useHashAsPath.
       */
      path: {
        type: String,
        observer: '__onPathChanged'
      },

      /**
       * Whether or not the ready function has been called.
       */
      _isReady: {
        type: Boolean
      }
    },

    behaviors: [Polymer.AppRouteConverterBehavior],

    observers: ['__computeRoutePath(useHashAsPath, __hash, __path)'],

    ready: function ready() {
      this._isReady = true;
    },

    __computeRoutePath: function __computeRoutePath() {
      this.path = this.useHashAsPath ? this.__hash : this.__path;
    },

    __onPathChanged: function __onPathChanged() {
      if (!this._isReady) {
        return;
      }

      if (this.useHashAsPath) {
        this.__hash = this.path;
      } else {
        this.__path = this.path;
      }
    }
  });
})();

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

(function () {
  'use strict';

  var workingURL;

  var urlDoc, urlBase, anchor;

  /**
   * @param {string} path
   * @param {string=} base
   * @return {!URL|!HTMLAnchorElement}
   */
  function resolveURL(path, base) {
    if (workingURL === undefined) {
      workingURL = false;
      try {
        var u = new URL('b', 'http://a');
        u.pathname = 'c%20d';
        workingURL = u.href === 'http://a/c%20d';
        workingURL = workingURL && new URL('http://www.google.com/?foo bar').href === 'http://www.google.com/?foo%20bar';
      } catch (e) {}
    }
    if (workingURL) {
      return new URL(path, base);
    }
    if (!urlDoc) {
      urlDoc = document.implementation.createHTMLDocument('url');
      urlBase = urlDoc.createElement('base');
      urlDoc.head.appendChild(urlBase);
      anchor = /** @type {HTMLAnchorElement}*/urlDoc.createElement('a');
    }
    urlBase.href = base;
    anchor.href = path.replace(/ /g, '%20');
    return anchor;
  }

  Polymer({
    is: 'iron-location',

    properties: {
      /**
       * The pathname component of the URL.
       */
      path: {
        type: String,
        notify: true,
        value: function value() {
          return window.decodeURIComponent(window.location.pathname);
        }
      },

      /**
       * The query string portion of the URL.
       */
      query: {
        type: String,
        notify: true,
        value: function value() {
          return window.location.search.slice(1);
        }
      },

      /**
       * The hash component of the URL.
       */
      hash: {
        type: String,
        notify: true,
        value: function value() {
          return window.decodeURIComponent(window.location.hash.slice(1));
        }
      },

      /**
       * If the user was on a URL for less than `dwellTime` milliseconds, it
       * won't be added to the browser's history, but instead will be replaced
       * by the next entry.
       *
       * This is to prevent large numbers of entries from clogging up the user's
       * browser history. Disable by setting to a negative number.
       */
      dwellTime: {
        type: Number,
        value: 2000
      },

      /**
       * A regexp that defines the set of URLs that should be considered part
       * of this web app.
       *
       * Clicking on a link that matches this regex won't result in a full page
       * navigation, but will instead just update the URL state in place.
       *
       * This regexp is given everything after the origin in an absolute
       * URL. So to match just URLs that start with /search/ do:
       *     url-space-regex="^/search/"
       *
       * @type {string|RegExp}
       */
      urlSpaceRegex: {
        type: String,
        value: ''
      },

      /**
       * urlSpaceRegex, but coerced into a regexp.
       *
       * @type {RegExp}
       */
      _urlSpaceRegExp: {
        computed: '_makeRegExp(urlSpaceRegex)'
      },

      _lastChangedAt: {
        type: Number
      },

      _initialized: {
        type: Boolean,
        value: false
      }
    },

    hostAttributes: {
      hidden: true
    },

    observers: ['_updateUrl(path, query, hash)'],

    attached: function attached() {
      this.listen(window, 'hashchange', '_hashChanged');
      this.listen(window, 'location-changed', '_urlChanged');
      this.listen(window, 'popstate', '_urlChanged');
      this.listen( /** @type {!HTMLBodyElement} */document.body, 'click', '_globalOnClick');
      // Give a 200ms grace period to make initial redirects without any
      // additions to the user's history.
      this._lastChangedAt = window.performance.now() - (this.dwellTime - 200);
      this._initialized = true;

      this._urlChanged();
    },

    detached: function detached() {
      this.unlisten(window, 'hashchange', '_hashChanged');
      this.unlisten(window, 'location-changed', '_urlChanged');
      this.unlisten(window, 'popstate', '_urlChanged');
      this.unlisten( /** @type {!HTMLBodyElement} */document.body, 'click', '_globalOnClick');
      this._initialized = false;
    },

    _hashChanged: function _hashChanged() {
      this.hash = window.decodeURIComponent(window.location.hash.substring(1));
    },

    _urlChanged: function _urlChanged() {
      // We want to extract all info out of the updated URL before we
      // try to write anything back into it.
      //
      // i.e. without _dontUpdateUrl we'd overwrite the new path with the old
      // one when we set this.hash. Likewise for query.
      this._dontUpdateUrl = true;
      this._hashChanged();
      this.path = window.decodeURIComponent(window.location.pathname);
      this.query = window.location.search.substring(1);
      this._dontUpdateUrl = false;
      this._updateUrl();
    },

    _getUrl: function _getUrl() {
      var partiallyEncodedPath = window.encodeURI(this.path).replace(/\#/g, '%23').replace(/\?/g, '%3F');
      var partiallyEncodedQuery = '';
      if (this.query) {
        partiallyEncodedQuery = '?' + this.query.replace(/\#/g, '%23');
      }
      var partiallyEncodedHash = '';
      if (this.hash) {
        partiallyEncodedHash = '#' + window.encodeURI(this.hash);
      }
      return partiallyEncodedPath + partiallyEncodedQuery + partiallyEncodedHash;
    },

    _updateUrl: function _updateUrl() {
      if (this._dontUpdateUrl || !this._initialized) {
        return;
      }

      if (this.path === window.decodeURIComponent(window.location.pathname) && this.query === window.location.search.substring(1) && this.hash === window.decodeURIComponent(window.location.hash.substring(1))) {
        // Nothing to do, the current URL is a representation of our properties.
        return;
      }

      var newUrl = this._getUrl();
      // Need to use a full URL in case the containing page has a base URI.
      var fullNewUrl = resolveURL(newUrl, window.location.protocol + '//' + window.location.host).href;
      var now = window.performance.now();
      var shouldReplace = this._lastChangedAt + this.dwellTime > now;
      this._lastChangedAt = now;

      if (shouldReplace) {
        window.history.replaceState({}, '', fullNewUrl);
      } else {
        window.history.pushState({}, '', fullNewUrl);
      }

      this.fire('location-changed', {}, { node: window });
    },

    /**
     * A necessary evil so that links work as expected. Does its best to
     * bail out early if possible.
     *
     * @param {MouseEvent} event .
     */
    _globalOnClick: function _globalOnClick(event) {
      // If another event handler has stopped this event then there's nothing
      // for us to do. This can happen e.g. when there are multiple
      // iron-location elements in a page.
      if (event.defaultPrevented) {
        return;
      }

      var href = this._getSameOriginLinkHref(event);

      if (!href) {
        return;
      }

      event.preventDefault();

      // If the navigation is to the current page we shouldn't add a history
      // entry or fire a change event.
      if (href === window.location.href) {
        return;
      }

      window.history.pushState({}, '', href);
      this.fire('location-changed', {}, { node: window });
    },

    /**
     * Returns the absolute URL of the link (if any) that this click event
     * is clicking on, if we can and should override the resulting full
     * page navigation. Returns null otherwise.
     *
     * @param {MouseEvent} event .
     * @return {string?} .
     */
    _getSameOriginLinkHref: function _getSameOriginLinkHref(event) {
      // We only care about left-clicks.
      if (event.button !== 0) {
        return null;
      }

      // We don't want modified clicks, where the intent is to open the page
      // in a new tab.
      if (event.metaKey || event.ctrlKey) {
        return null;
      }

      var eventPath = Polymer.dom(event).path;
      var anchor = null;

      for (var i = 0; i < eventPath.length; i++) {
        var element = eventPath[i];

        if (element.tagName === 'A' && element.href) {
          anchor = element;
          break;
        }
      }

      // If there's no link there's nothing to do.
      if (!anchor) {
        return null;
      }

      // Target blank is a new tab, don't intercept.
      if (anchor.target === '_blank') {
        return null;
      }

      // If the link is for an existing parent frame, don't intercept.
      if ((anchor.target === '_top' || anchor.target === '_parent') && window.top !== window) {
        return null;
      }

      var href = anchor.href;

      // It only makes sense for us to intercept same-origin navigations.
      // pushState/replaceState don't work with cross-origin links.
      var url;

      if (document.baseURI != null) {
        url = resolveURL(href, /** @type {string} */document.baseURI);
      } else {
        url = resolveURL(href);
      }

      var origin;

      // IE Polyfill
      if (window.location.origin) {
        origin = window.location.origin;
      } else {
        origin = window.location.protocol + '//' + window.location.host;
      }

      var urlOrigin;

      if (url.origin) {
        urlOrigin = url.origin;
      } else {
        urlOrigin = url.protocol + '//' + url.host;
      }

      if (urlOrigin !== origin) {
        return null;
      }

      var normalizedHref = url.pathname + url.search + url.hash;

      // pathname should start with '/', but may not if `new URL` is not supported
      if (normalizedHref[0] !== '/') {
        normalizedHref = '/' + normalizedHref;
      }

      // If we've been configured not to handle this url... don't handle it!
      if (this._urlSpaceRegExp && !this._urlSpaceRegExp.test(normalizedHref)) {
        return null;
      }

      // Need to use a full URL in case the containing page has a base URI.
      var fullNormalizedHref = resolveURL(normalizedHref, window.location.href).href;
      return fullNormalizedHref;
    },

    _makeRegExp: function _makeRegExp(urlSpaceRegex) {
      return RegExp(urlSpaceRegex);
    }
  });
})();

/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

'use strict';

Polymer({
  is: 'iron-query-params',

  properties: {
    paramsString: {
      type: String,
      notify: true,
      observer: 'paramsStringChanged'
    },

    paramsObject: {
      type: Object,
      notify: true,
      value: function value() {
        return {};
      }
    },

    _dontReact: {
      type: Boolean,
      value: false
    }
  },

  hostAttributes: {
    hidden: true
  },

  observers: ['paramsObjectChanged(paramsObject.*)'],

  paramsStringChanged: function paramsStringChanged() {
    this._dontReact = true;
    this.paramsObject = this._decodeParams(this.paramsString);
    this._dontReact = false;
  },

  paramsObjectChanged: function paramsObjectChanged() {
    if (this._dontReact) {
      return;
    }
    this.paramsString = this._encodeParams(this.paramsObject).replace(/%3F/g, '?').replace(/%2F/g, '/').replace(/'/g, '%27');
  },

  _encodeParams: function _encodeParams(params) {
    var encodedParams = [];

    for (var key in params) {
      var value = params[key];

      if (value === '') {
        encodedParams.push(encodeURIComponent(key));
      } else if (value) {
        encodedParams.push(encodeURIComponent(key) + '=' + encodeURIComponent(value.toString()));
      }
    }
    return encodedParams.join('&');
  },

  _decodeParams: function _decodeParams(paramString) {
    var params = {};
    // Work around a bug in decodeURIComponent where + is not
    // converted to spaces:
    paramString = (paramString || '').replace(/\+/g, '%20');
    var paramList = paramString.split('&');
    for (var i = 0; i < paramList.length; i++) {
      var param = paramList[i].split('=');
      if (param[0]) {
        params[decodeURIComponent(param[0])] = decodeURIComponent(param[1] || '');
      }
    }
    return params;
  }
});

/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


(function () {
  'use strict';

  /**
   * Provides bidirectional mapping between `path` and `queryParams` and a
   * app-route compatible `route` object.
   *
   * For more information, see the docs for `app-route-converter`.
   *
   * @polymerBehavior
   */

  Polymer.AppRouteConverterBehavior = {
    properties: {
      /**
       * A model representing the deserialized path through the route tree, as
       * well as the current queryParams.
       *
       * A route object is the kernel of the routing system. It is intended to
       * be fed into consuming elements such as `app-route`.
       *
       * @type {?Object}
       */
      route: {
        type: Object,
        notify: true
      },

      /**
       * A set of key/value pairs that are universally accessible to branches of
       * the route tree.
       *
       * @type {?Object}
       */
      queryParams: {
        type: Object,
        notify: true
      },

      /**
       * The serialized path through the route tree. This corresponds to the
       * `window.location.pathname` value, and will update to reflect changes
       * to that value.
       */
      path: {
        type: String,
        notify: true
      }
    },

    observers: ['_locationChanged(path, queryParams)', '_routeChanged(route.prefix, route.path)', '_routeQueryParamsChanged(route.__queryParams)'],

    created: function created() {
      this.linkPaths('route.__queryParams', 'queryParams');
      this.linkPaths('queryParams', 'route.__queryParams');
    },

    /**
     * Handler called when the path or queryParams change.
     */
    _locationChanged: function _locationChanged() {
      if (this.route && this.route.path === this.path && this.queryParams === this.route.__queryParams) {
        return;
      }
      this.route = {
        prefix: '',
        path: this.path,
        __queryParams: this.queryParams
      };
    },

    /**
     * Handler called when the route prefix and route path change.
     */
    _routeChanged: function _routeChanged() {
      if (!this.route) {
        return;
      }

      this.path = this.route.prefix + this.route.path;
    },

    /**
     * Handler called when the route queryParams change.
     *
     * @param  {Object} queryParams A set of key/value pairs that are
     * universally accessible to branches of the route tree.
     */
    _routeQueryParamsChanged: function _routeQueryParamsChanged(queryParams) {
      if (!this.route) {
        return;
      }
      this.queryParams = queryParams;
    }
  };
})();

/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

(function () {
  'use strict';

  Polymer({
    is: 'app-route',

    properties: {
      /**
       * The URL component managed by this element.
       */
      route: {
        type: Object,
        notify: true
      },

      /**
       * The pattern of slash-separated segments to match `route.path` against.
       *
       * For example the pattern "/foo" will match "/foo" or "/foo/bar"
       * but not "/foobar".
       *
       * Path segments like `/:named` are mapped to properties on the `data` object.
       */
      pattern: {
        type: String
      },

      /**
       * The parameterized values that are extracted from the route as
       * described by `pattern`.
       */
      data: {
        type: Object,
        value: function value() {
          return {};
        },
        notify: true
      },

      /**
       * @type {?Object}
       */
      queryParams: {
        type: Object,
        value: function value() {
          return {};
        },
        notify: true
      },

      /**
       * The part of `route.path` NOT consumed by `pattern`.
       */
      tail: {
        type: Object,
        value: function value() {
          return { path: null, prefix: null, __queryParams: null };
        },
        notify: true
      },

      /**
       * Whether the current route is active. True if `route.path` matches the
       * `pattern`, false otherwise.
       */
      active: {
        type: Boolean,
        notify: true,
        readOnly: true
      },

      _queryParamsUpdating: {
        type: Boolean,
        value: false
      },
      /**
       * @type {?string}
       */
      _matched: {
        type: String,
        value: ''
      }
    },

    observers: ['__tryToMatch(route.path, pattern)', '__updatePathOnDataChange(data.*)', '__tailPathChanged(tail.path)', '__routeQueryParamsChanged(route.__queryParams)', '__tailQueryParamsChanged(tail.__queryParams)', '__queryParamsChanged(queryParams.*)'],

    created: function created() {
      this.linkPaths('route.__queryParams', 'tail.__queryParams');
      this.linkPaths('tail.__queryParams', 'route.__queryParams');
    },

    /**
     * Deal with the query params object being assigned to wholesale.
     */
    __routeQueryParamsChanged: function __routeQueryParamsChanged(queryParams) {
      if (queryParams && this.tail) {
        if (this.tail.__queryParams !== queryParams) {
          this.set('tail.__queryParams', queryParams);
        }

        if (!this.active || this._queryParamsUpdating) {
          return;
        }

        // Copy queryParams and track whether there are any differences compared
        // to the existing query params.
        var copyOfQueryParams = {};
        var anythingChanged = false;
        for (var key in queryParams) {
          copyOfQueryParams[key] = queryParams[key];
          if (anythingChanged || !this.queryParams || queryParams[key] !== this.queryParams[key]) {
            anythingChanged = true;
          }
        }
        // Need to check whether any keys were deleted
        for (var key in this.queryParams) {
          if (anythingChanged || !(key in queryParams)) {
            anythingChanged = true;
            break;
          }
        }

        if (!anythingChanged) {
          return;
        }
        this._queryParamsUpdating = true;
        this.set('queryParams', copyOfQueryParams);
        this._queryParamsUpdating = false;
      }
    },

    __tailQueryParamsChanged: function __tailQueryParamsChanged(queryParams) {
      if (queryParams && this.route && this.route.__queryParams != queryParams) {
        this.set('route.__queryParams', queryParams);
      }
    },

    __queryParamsChanged: function __queryParamsChanged(changes) {
      if (!this.active || this._queryParamsUpdating) {
        return;
      }

      this.set('route.__' + changes.path, changes.value);
    },

    __resetProperties: function __resetProperties() {
      this._setActive(false);
      this._matched = null;
    },

    __tryToMatch: function __tryToMatch() {
      if (!this.route) {
        return;
      }

      var path = this.route.path;
      var pattern = this.pattern;

      if (!pattern) {
        return;
      }

      if (!path) {
        this.__resetProperties();
        return;
      }

      var remainingPieces = path.split('/');
      var patternPieces = pattern.split('/');

      var matched = [];
      var namedMatches = {};

      for (var i = 0; i < patternPieces.length; i++) {
        var patternPiece = patternPieces[i];
        if (!patternPiece && patternPiece !== '') {
          break;
        }
        var pathPiece = remainingPieces.shift();

        // We don't match this path.
        if (!pathPiece && pathPiece !== '') {
          this.__resetProperties();
          return;
        }
        matched.push(pathPiece);

        if (patternPiece.charAt(0) == ':') {
          namedMatches[patternPiece.slice(1)] = pathPiece;
        } else if (patternPiece !== pathPiece) {
          this.__resetProperties();
          return;
        }
      }

      this._matched = matched.join('/');

      // Properties that must be updated atomically.
      var propertyUpdates = {};

      //this.active
      if (!this.active) {
        propertyUpdates.active = true;
      }

      // this.tail
      var tailPrefix = this.route.prefix + this._matched;
      var tailPath = remainingPieces.join('/');
      if (remainingPieces.length > 0) {
        tailPath = '/' + tailPath;
      }
      if (!this.tail || this.tail.prefix !== tailPrefix || this.tail.path !== tailPath) {
        propertyUpdates.tail = {
          prefix: tailPrefix,
          path: tailPath,
          __queryParams: this.route.__queryParams
        };
      }

      // this.data
      propertyUpdates.data = namedMatches;
      this._dataInUrl = {};
      for (var key in namedMatches) {
        this._dataInUrl[key] = namedMatches[key];
      }

      if (this.setProperties) {
        if (!this.active) {
          this._setActive(true);
        }
        // atomic update
        this.setProperties(propertyUpdates);
      } else {
        this.__setMulti(propertyUpdates);
      }
    },

    __tailPathChanged: function __tailPathChanged(path) {
      if (!this.active) {
        return;
      }
      var tailPath = path;
      var newPath = this._matched;
      if (tailPath) {
        if (tailPath.charAt(0) !== '/') {
          tailPath = '/' + tailPath;
        }
        newPath += tailPath;
      }
      this.set('route.path', newPath);
    },

    __updatePathOnDataChange: function __updatePathOnDataChange() {
      if (!this.route || !this.active) {
        return;
      }
      var newPath = this.__getLink({});
      var oldPath = this.__getLink(this._dataInUrl);
      if (newPath === oldPath) {
        return;
      }
      this.set('route.path', newPath);
    },

    __getLink: function __getLink(overrideValues) {
      var values = { tail: null };
      for (var key in this.data) {
        values[key] = this.data[key];
      }
      for (var key in overrideValues) {
        values[key] = overrideValues[key];
      }
      var patternPieces = this.pattern.split('/');
      var interp = patternPieces.map(function (value) {
        if (value[0] == ':') {
          value = values[value.slice(1)];
        }
        return value;
      }, this);
      if (values.tail && values.tail.path) {
        if (interp.length > 0 && values.tail.path.charAt(0) === '/') {
          interp.push(values.tail.path.slice(1));
        } else {
          interp.push(values.tail.path);
        }
      }
      return interp.join('/');
    },

    __setMulti: function __setMulti(setObj) {
      // HACK(rictic): skirting around 1.0's lack of a setMulti by poking at
      //     internal data structures. I would not advise that you copy this
      //     example.
      //
      //     In the future this will be a feature of Polymer itself.
      //     See: https://github.com/Polymer/polymer/issues/3640
      //
      //     Hacking around with private methods like this is juggling footguns,
      //     and is likely to have unexpected and unsupported rough edges.
      //
      //     Be ye so warned.
      for (var property in setObj) {
        this._propertySetter(property, setObj[property]);
      }
      //notify in a specific order
      if (setObj.data !== undefined) {
        this._pathEffector('data', this.data);
        this._notifyChange('data');
      }
      if (setObj.active !== undefined) {
        this._pathEffector('active', this.active);
        this._notifyChange('active');
      }
      if (setObj.tail !== undefined) {
        this._pathEffector('tail', this.tail);
        this._notifyChange('tail');
      }
    }
  });
})();

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

__webpack_require__(17);

__webpack_require__(29);

var RegisterHtmlTemplate = __webpack_require__(2);

RegisterHtmlTemplate.register("<dom-module id=iron-pages> <template> <style>:host{display:block}:host>::slotted(:not(.iron-selected)){display:none!important}</style> <slot></slot> </template> </dom-module>");

Polymer({

  is: 'iron-pages',

  behaviors: [Polymer.IronResizableBehavior, Polymer.IronSelectableBehavior],

  properties: {

    // as the selected page is the only one visible, activateEvent
    // is both non-sensical and problematic; e.g. in cases where a user
    // handler attempts to change the page and the activateEvent
    // handler immediately changes it back
    activateEvent: {
      type: String,
      value: null
    }

  },

  observers: ['_selectedPageChanged(selected)'],

  _selectedPageChanged: function _selectedPageChanged(selected, old) {
    this.async(this.notifyResize);
  }
});

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

/**
 * @param {!Function} selectCallback
 * @constructor
 */
Polymer.IronSelection = function (selectCallback) {
  this.selection = [];
  this.selectCallback = selectCallback;
};

Polymer.IronSelection.prototype = {

  /**
   * Retrieves the selected item(s).
   *
   * @method get
   * @returns Returns the selected item(s). If the multi property is true,
   * `get` will return an array, otherwise it will return
   * the selected item or undefined if there is no selection.
   */
  get: function get() {
    return this.multi ? this.selection.slice() : this.selection[0];
  },

  /**
   * Clears all the selection except the ones indicated.
   *
   * @method clear
   * @param {Array} excludes items to be excluded.
   */
  clear: function clear(excludes) {
    this.selection.slice().forEach(function (item) {
      if (!excludes || excludes.indexOf(item) < 0) {
        this.setItemSelected(item, false);
      }
    }, this);
  },

  /**
   * Indicates if a given item is selected.
   *
   * @method isSelected
   * @param {*} item The item whose selection state should be checked.
   * @returns Returns true if `item` is selected.
   */
  isSelected: function isSelected(item) {
    return this.selection.indexOf(item) >= 0;
  },

  /**
   * Sets the selection state for a given item to either selected or deselected.
   *
   * @method setItemSelected
   * @param {*} item The item to select.
   * @param {boolean} isSelected True for selected, false for deselected.
   */
  setItemSelected: function setItemSelected(item, isSelected) {
    if (item != null) {
      if (isSelected !== this.isSelected(item)) {
        // proceed to update selection only if requested state differs from current
        if (isSelected) {
          this.selection.push(item);
        } else {
          var i = this.selection.indexOf(item);
          if (i >= 0) {
            this.selection.splice(i, 1);
          }
        }
        if (this.selectCallback) {
          this.selectCallback(item, isSelected);
        }
      }
    }
  },

  /**
   * Sets the selection state for a given item. If the `multi` property
   * is true, then the selected state of `item` will be toggled; otherwise
   * the `item` will be selected.
   *
   * @method select
   * @param {*} item The item to select.
   */
  select: function select(item) {
    if (this.multi) {
      this.toggle(item);
    } else if (this.get() !== item) {
      this.setItemSelected(this.get(), false);
      this.setItemSelected(item, true);
    }
  },

  /**
   * Toggles the selection state for `item`.
   *
   * @method toggle
   * @param {*} item The item to toggle.
   */
  toggle: function toggle(item) {
    this.setItemSelected(item, !this.isSelected(item));
  }

};

/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

__webpack_require__(83);

/**
`iron-selector` is an element which can be used to manage a list of elements
that can be selected.  Tapping on the item will make the item selected.  The `selected` indicates
which item is being selected.  The default is to use the index of the item.
 Example:
     <iron-selector selected="0">
      <div>Item 1</div>
      <div>Item 2</div>
      <div>Item 3</div>
    </iron-selector>
 If you want to use the attribute value of an element for `selected` instead of the index,
set `attrForSelected` to the name of the attribute.  For example, if you want to select item by
`name`, set `attrForSelected` to `name`.
 Example:
     <iron-selector attr-for-selected="name" selected="foo">
      <div name="foo">Foo</div>
      <div name="bar">Bar</div>
      <div name="zot">Zot</div>
    </iron-selector>
 You can specify a default fallback with `fallbackSelection` in case the `selected` attribute does
not match the `attrForSelected` attribute of any elements.
 Example:
       <iron-selector attr-for-selected="name" selected="non-existing"
                     fallback-selection="default">
        <div name="foo">Foo</div>
        <div name="bar">Bar</div>
        <div name="default">Default</div>
      </iron-selector>
 Note: When the selector is multi, the selection will set to `fallbackSelection` iff
the number of matching elements is zero.
 `iron-selector` is not styled. Use the `iron-selected` CSS class to style the selected element.
 Example:
     <style>
      .iron-selected {
        background: #eee;
      }
    </style>
     ...
     <iron-selector selected="0">
      <div>Item 1</div>
      <div>Item 2</div>
      <div>Item 3</div>
    </iron-selector>
 @demo demo/index.html
*/

Polymer({

  is: 'iron-selector',

  behaviors: [Polymer.IronMultiSelectableBehavior]

});

/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

__webpack_require__(29);

/**
 * @polymerBehavior Polymer.IronMultiSelectableBehavior
 */
Polymer.IronMultiSelectableBehaviorImpl = {
  properties: {

    /**
     * If true, multiple selections are allowed.
     */
    multi: {
      type: Boolean,
      value: false,
      observer: 'multiChanged'
    },

    /**
     * Gets or sets the selected elements. This is used instead of `selected` when `multi`
     * is true.
     */
    selectedValues: {
      type: Array,
      notify: true,
      value: function value() {
        return [];
      }
    },

    /**
     * Returns an array of currently selected items.
     */
    selectedItems: {
      type: Array,
      readOnly: true,
      notify: true,
      value: function value() {
        return [];
      }
    }

  },

  observers: ['_updateSelected(selectedValues.splices)'],

  /**
   * Selects the given value. If the `multi` property is true, then the selected state of the
   * `value` will be toggled; otherwise the `value` will be selected.
   *
   * @method select
   * @param {string|number} value the value to select.
   */
  select: function select(value) {
    if (this.multi) {
      this._toggleSelected(value);
    } else {
      this.selected = value;
    }
  },

  multiChanged: function multiChanged(multi) {
    this._selection.multi = multi;
    this._updateSelected();
  },

  // UNUSED, FOR API COMPATIBILITY
  get _shouldUpdateSelection() {
    return this.selected != null || this.selectedValues != null && this.selectedValues.length;
  },

  _updateAttrForSelected: function _updateAttrForSelected() {
    if (!this.multi) {
      Polymer.IronSelectableBehavior._updateAttrForSelected.apply(this);
    } else if (this.selectedItems && this.selectedItems.length > 0) {
      this.selectedValues = this.selectedItems.map(function (selectedItem) {
        return this._indexToValue(this.indexOf(selectedItem));
      }, this).filter(function (unfilteredValue) {
        return unfilteredValue != null;
      }, this);
    }
  },

  _updateSelected: function _updateSelected() {
    if (this.multi) {
      this._selectMulti(this.selectedValues);
    } else {
      this._selectSelected(this.selected);
    }
  },

  _selectMulti: function _selectMulti(values) {
    values = values || [];

    var selectedItems = (this._valuesToItems(values) || []).filter(function (item) {
      return item !== null && item !== undefined;
    });

    // clear all but the current selected items
    this._selection.clear(selectedItems);

    // select only those not selected yet
    for (var i = 0; i < selectedItems.length; i++) {
      this._selection.setItemSelected(selectedItems[i], true);
    }

    // Check for items, since this array is populated only when attached
    if (this.fallbackSelection && !this._selection.get().length) {
      var fallback = this._valueToItem(this.fallbackSelection);
      if (fallback) {
        this.select(this.fallbackSelection);
      }
    }
  },

  _selectionChange: function _selectionChange() {
    var s = this._selection.get();
    if (this.multi) {
      this._setSelectedItems(s);
      this._setSelectedItem(s.length ? s[0] : null);
    } else {
      if (s !== null && s !== undefined) {
        this._setSelectedItems([s]);
        this._setSelectedItem(s);
      } else {
        this._setSelectedItems([]);
        this._setSelectedItem(null);
      }
    }
  },

  _toggleSelected: function _toggleSelected(value) {
    var i = this.selectedValues.indexOf(value);
    var unselected = i < 0;
    if (unselected) {
      this.push('selectedValues', value);
    } else {
      this.splice('selectedValues', i, 1);
    }
  },

  _valuesToItems: function _valuesToItems(values) {
    return values == null ? null : values.map(function (value) {
      return this._valueToItem(value);
    }, this);
  }
};

/** @polymerBehavior */
Polymer.IronMultiSelectableBehavior = [Polymer.IronSelectableBehavior, Polymer.IronMultiSelectableBehaviorImpl];

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

__webpack_require__(37);

__webpack_require__(85);

/**
 * `Polymer.PaperInkyFocusBehavior` implements a ripple when the element has keyboard focus.
 *
 * @polymerBehavior Polymer.PaperInkyFocusBehavior
 */
Polymer.PaperInkyFocusBehaviorImpl = {
  observers: ['_focusedChanged(receivedFocusFromKeyboard)'],

  _focusedChanged: function _focusedChanged(receivedFocusFromKeyboard) {
    if (receivedFocusFromKeyboard) {
      this.ensureRipple();
    }
    if (this.hasRipple()) {
      this._ripple.holdDown = receivedFocusFromKeyboard;
    }
  },

  _createRipple: function _createRipple() {
    var ripple = Polymer.PaperRippleBehavior._createRipple();
    ripple.id = 'ink';
    ripple.setAttribute('center', '');
    ripple.classList.add('circle');
    return ripple;
  }
};

/** @polymerBehavior Polymer.PaperInkyFocusBehavior */
Polymer.PaperInkyFocusBehavior = [Polymer.IronButtonState, Polymer.IronControlState, Polymer.PaperRippleBehavior, Polymer.PaperInkyFocusBehaviorImpl];

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

__webpack_require__(34);

/**
 * `Polymer.PaperRippleBehavior` dynamically implements a ripple
 * when the element has focus via pointer or keyboard.
 *
 * NOTE: This behavior is intended to be used in conjunction with and after
 * `Polymer.IronButtonState` and `Polymer.IronControlState`.
 *
 * @polymerBehavior Polymer.PaperRippleBehavior
 */
Polymer.PaperRippleBehavior = {
  properties: {
    /**
     * If true, the element will not produce a ripple effect when interacted
     * with via the pointer.
     */
    noink: {
      type: Boolean,
      observer: '_noinkChanged'
    },

    /**
     * @type {Element|undefined}
     */
    _rippleContainer: {
      type: Object
    }
  },

  /**
   * Ensures a `<paper-ripple>` element is available when the element is
   * focused.
   */
  _buttonStateChanged: function _buttonStateChanged() {
    if (this.focused) {
      this.ensureRipple();
    }
  },

  /**
   * In addition to the functionality provided in `IronButtonState`, ensures
   * a ripple effect is created when the element is in a `pressed` state.
   */
  _downHandler: function _downHandler(event) {
    Polymer.IronButtonStateImpl._downHandler.call(this, event);
    if (this.pressed) {
      this.ensureRipple(event);
    }
  },

  /**
   * Ensures this element contains a ripple effect. For startup efficiency
   * the ripple effect is dynamically on demand when needed.
   * @param {!Event=} optTriggeringEvent (optional) event that triggered the
   * ripple.
   */
  ensureRipple: function ensureRipple(optTriggeringEvent) {
    if (!this.hasRipple()) {
      this._ripple = this._createRipple();
      this._ripple.noink = this.noink;
      var rippleContainer = this._rippleContainer || this.root;
      if (rippleContainer) {
        Polymer.dom(rippleContainer).appendChild(this._ripple);
      }
      if (optTriggeringEvent) {
        // Check if the event happened inside of the ripple container
        // Fall back to host instead of the root because distributed text
        // nodes are not valid event targets
        var domContainer = Polymer.dom(this._rippleContainer || this);
        var target = Polymer.dom(optTriggeringEvent).rootTarget;
        if (domContainer.deepContains( /** @type {Node} */target)) {
          this._ripple.uiDownAction(optTriggeringEvent);
        }
      }
    }
  },

  /**
   * Returns the `<paper-ripple>` element used by this element to create
   * ripple effects. The element's ripple is created on demand, when
   * necessary, and calling this method will force the
   * ripple to be created.
   */
  getRipple: function getRipple() {
    this.ensureRipple();
    return this._ripple;
  },

  /**
   * Returns true if this element currently contains a ripple effect.
   * @return {boolean}
   */
  hasRipple: function hasRipple() {
    return Boolean(this._ripple);
  },

  /**
   * Create the element's ripple effect via creating a `<paper-ripple>`.
   * Override this method to customize the ripple element.
   * @return {!PaperRippleElement} Returns a `<paper-ripple>` element.
   */
  _createRipple: function _createRipple() {
    return (/** @type {!PaperRippleElement} */document.createElement('paper-ripple')
    );
  },

  _noinkChanged: function _noinkChanged(noink) {
    if (this.hasRipple()) {
      this._ripple.noink = noink;
    }
  }
};

/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(35);

var RegisterHtmlTemplate = __webpack_require__(2);

RegisterHtmlTemplate.toBody("<iron-iconset-svg name=my-icons size=24> <svg> <defs> <g id=arrow-back> <path d=\"M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z\"></path> </g> <g id=menu> <path d=\"M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z\"></path> </g> <g id=chevron-right> <path d=\"M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z\"></path> </g> <g id=close> <path d=\"M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z\"></path> </g> <g id=search><path d=\"M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z\"></path> </g> </defs> </svg> </iron-iconset-svg>");

/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgZGU1NDU2MmNkMDhkMjJmNDBhNjIiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL3BvbHltZXIuaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL3BvbHltZXIvbGliL3V0aWxzL2Jvb3QuaHRtbCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcG9seW1lci13ZWJwYWNrLWxvYWRlci9yZWdpc3Rlci1odG1sLXRlbXBsYXRlLmpzIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvdXRpbHMvbWl4aW4uaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL2FwcC1sYXlvdXQvYXBwLXNjcm9sbC1lZmZlY3RzL2FwcC1zY3JvbGwtZWZmZWN0cy1iZWhhdmlvci5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvaXJvbi1mbGV4LWxheW91dC9pcm9uLWZsZXgtbGF5b3V0Lmh0bWwiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL3BvbHltZXItZWxlbWVudC5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvdXRpbHMvcmVzb2x2ZS11cmwuaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL3BvbHltZXIvbGliL3V0aWxzL2FzeW5jLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi9taXhpbnMvbXV0YWJsZS1kYXRhLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi91dGlscy9jYXNlLW1hcC5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvbWl4aW5zL3Byb3BlcnR5LWVmZmVjdHMuaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL3BvbHltZXIvbGliL3V0aWxzL2RlYm91bmNlLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi91dGlscy9mbHVzaC5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvdXRpbHMvdGVtcGxhdGl6ZS5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvYXBwLWxheW91dC9hcHAtbGF5b3V0LWJlaGF2aW9yL2FwcC1sYXlvdXQtYmVoYXZpb3IuaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL2lyb24tYTExeS1rZXlzLWJlaGF2aW9yL2lyb24tYTExeS1rZXlzLWJlaGF2aW9yLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9pcm9uLXJlc2l6YWJsZS1iZWhhdmlvci9pcm9uLXJlc2l6YWJsZS1iZWhhdmlvci5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvaXJvbi1tZXRhL2lyb24tbWV0YS5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvbWl4aW5zL2VsZW1lbnQtbWl4aW4uaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL3BvbHltZXIvbGliL3V0aWxzL3NldHRpbmdzLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi91dGlscy9zdHlsZS1nYXRoZXIuaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL3BvbHltZXIvbGliL2xlZ2FjeS9sZWdhY3ktZWxlbWVudC1taXhpbi5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvbWl4aW5zL2dlc3R1cmUtZXZlbnQtbGlzdGVuZXJzLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi91dGlscy9hcnJheS1zcGxpY2UuaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL2FwcC1sYXlvdXQvYXBwLXNjcm9sbC1lZmZlY3RzL2VmZmVjdHMvYmxlbmQtYmFja2dyb3VuZC5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvYXBwLWxheW91dC9hcHAtc2Nyb2xsLWVmZmVjdHMvZWZmZWN0cy93YXRlcmZhbGwuaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL2FwcC1sYXlvdXQvYXBwLXNjcm9sbC1lZmZlY3RzL2VmZmVjdHMvcmVzaXplLXRpdGxlLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9hcHAtbGF5b3V0L2FwcC1zY3JvbGwtZWZmZWN0cy9lZmZlY3RzL3BhcmFsbGF4LWJhY2tncm91bmQuaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL2lyb24tc2VsZWN0b3IvaXJvbi1zZWxlY3RhYmxlLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9wYXBlci1zdHlsZXMvZGVmYXVsdC10aGVtZS5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvcGFwZXItaWNvbi1idXR0b24vcGFwZXItaWNvbi1idXR0b24uaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL2lyb24taWNvbi9pcm9uLWljb24uaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL2lyb24tYmVoYXZpb3JzL2lyb24tY29udHJvbC1zdGF0ZS5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvcGFwZXItcmlwcGxlL3BhcGVyLXJpcHBsZS5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvaXJvbi1pY29uc2V0LXN2Zy9pcm9uLWljb25zZXQtc3ZnLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9pcm9uLXNjcm9sbC10YXJnZXQtYmVoYXZpb3IvaXJvbi1zY3JvbGwtdGFyZ2V0LWJlaGF2aW9yLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9pcm9uLWJlaGF2aW9ycy9pcm9uLWJ1dHRvbi1zdGF0ZS5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvcGFwZXItc3R5bGVzL2NvbG9yLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vc3JjL2x1ZGluZy1hcHAuaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL3BvbHltZXIvbGliL2VsZW1lbnRzL2RvbS1tb2R1bGUuaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL3BvbHltZXIvbGliL3V0aWxzL3BhdGguaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL3BvbHltZXIvbGliL21peGlucy9wcm9wZXJ0eS1hY2Nlc3NvcnMuaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL3BvbHltZXIvbGliL21peGlucy90ZW1wbGF0ZS1zdGFtcC5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvYXBwLWxheW91dC9hcHAtZHJhd2VyL2FwcC1kcmF3ZXIuaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL3NoYWR5Y3NzL2FwcGx5LXNoaW0uaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL3NoYWR5Y3NzL2FwcGx5LXNoaW0ubWluLmpzIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvdXRpbHMvZ2VzdHVyZXMuaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL3BvbHltZXIvbGliL3V0aWxzL2ltcG9ydC1ocmVmLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi91dGlscy9yZW5kZXItc3RhdHVzLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi91dGlscy91bnJlc29sdmVkLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi9sZWdhY3kvcG9seW1lci5kb20uaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL3BvbHltZXIvbGliL3V0aWxzL2ZsYXR0ZW5lZC1ub2Rlcy1vYnNlcnZlci5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvbGVnYWN5L3BvbHltZXItZm4uaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL3BvbHltZXIvbGliL2xlZ2FjeS9jbGFzcy5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvbGVnYWN5L3RlbXBsYXRpemVyLWJlaGF2aW9yLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi9lbGVtZW50cy9kb20tYmluZC5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvZWxlbWVudHMvZG9tLXJlcGVhdC5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvZWxlbWVudHMvZG9tLWlmLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi9lbGVtZW50cy9hcnJheS1zZWxlY3Rvci5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvZWxlbWVudHMvY3VzdG9tLXN0eWxlLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9zaGFkeWNzcy9jdXN0b20tc3R5bGUtaW50ZXJmYWNlLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9zaGFkeWNzcy9jdXN0b20tc3R5bGUtaW50ZXJmYWNlLm1pbi5qcyIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL3BvbHltZXIvbGliL2xlZ2FjeS9tdXRhYmxlLWRhdGEtYmVoYXZpb3IuaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL2FwcC1sYXlvdXQvYXBwLWRyYXdlci1sYXlvdXQvYXBwLWRyYXdlci1sYXlvdXQuaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL2lyb24tbWVkaWEtcXVlcnkvaXJvbi1tZWRpYS1xdWVyeS5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvYXBwLWxheW91dC9hcHAtaGVhZGVyL2FwcC1oZWFkZXIuaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL2FwcC1sYXlvdXQvaGVscGVycy9oZWxwZXJzLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9hcHAtbGF5b3V0L2FwcC1oZWFkZXItbGF5b3V0L2FwcC1oZWFkZXItbGF5b3V0Lmh0bWwiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9hcHAtbGF5b3V0L2FwcC1zY3JvbGwtZWZmZWN0cy9hcHAtc2Nyb2xsLWVmZmVjdHMuaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL2FwcC1sYXlvdXQvYXBwLXNjcm9sbC1lZmZlY3RzL2VmZmVjdHMvZmFkZS1iYWNrZ3JvdW5kLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9hcHAtbGF5b3V0L2FwcC1zY3JvbGwtZWZmZWN0cy9lZmZlY3RzL21hdGVyaWFsLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9hcHAtbGF5b3V0L2FwcC1zY3JvbGwtZWZmZWN0cy9lZmZlY3RzL3Jlc2l6ZS1zbmFwcGVkLXRpdGxlLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9hcHAtbGF5b3V0L2FwcC10b29sYmFyL2FwcC10b29sYmFyLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9hcHAtcm91dGUvYXBwLWxvY2F0aW9uLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9pcm9uLWxvY2F0aW9uL2lyb24tbG9jYXRpb24uaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL2lyb24tbG9jYXRpb24vaXJvbi1xdWVyeS1wYXJhbXMuaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL2FwcC1yb3V0ZS9hcHAtcm91dGUtY29udmVydGVyLWJlaGF2aW9yLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9hcHAtcm91dGUvYXBwLXJvdXRlLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9pcm9uLXBhZ2VzL2lyb24tcGFnZXMuaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL2lyb24tc2VsZWN0b3IvaXJvbi1zZWxlY3Rpb24uaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL2lyb24tc2VsZWN0b3IvaXJvbi1zZWxlY3Rvci5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvaXJvbi1zZWxlY3Rvci9pcm9uLW11bHRpLXNlbGVjdGFibGUuaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL3BhcGVyLWJlaGF2aW9ycy9wYXBlci1pbmt5LWZvY3VzLWJlaGF2aW9yLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9wYXBlci1iZWhhdmlvcnMvcGFwZXItcmlwcGxlLWJlaGF2aW9yLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vc3JjL215LWljb25zLmh0bWwiXSwibmFtZXMiOlsiUmVnaXN0ZXJIdG1sVGVtcGxhdGUiLCJ2YWwiLCJjb250ZW50IiwidGVtcGxhdGUiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJpbm5lckhUTUwiLCJjcmVhdGVEb2N1bWVudEZyYWdtZW50IiwiZmlyc3RDaGlsZCIsImFwcGVuZENoaWxkIiwiaW1wb3J0Tm9kZSIsInRyaW1tZWRWYWwiLCJ0cmltIiwiZGl2IiwiYm9keSIsImluc2VydEJlZm9yZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJtb2R1bGUiLCJleHBvcnRzIiwicmVxdWlyZSIsInRvQm9keSIsImsiLCJuIiwiZW5kIiwic3RhcnQiLCJydWxlcyIsInBhcmVudCIsInByZXZpb3VzIiwiY3NzVGV4dCIsInBhcnNlZENzc1RleHQiLCJhdFJ1bGUiLCJ0eXBlIiwicGFyc2VkU2VsZWN0b3IiLCJzZWxlY3RvciIsImtleWZyYW1lc05hbWUiLCJwIiwiYSIsInJlcGxhY2UiLCJhYSIsImJhIiwiYiIsInEiLCJjIiwiZCIsImxlbmd0aCIsImUiLCJmIiwiaCIsImciLCJtIiwicHVzaCIsInN1YnN0cmluZyIsImNhIiwiciIsImxhc3RJbmRleE9mIiwiaW5kZXhPZiIsInQiLCJtYXRjaCIsImRhIiwidSIsInNwbGl0IiwicG9wIiwidiIsIngiLCJ5IiwiZWEiLCJmYSIsImhhIiwiaWEiLCJqYSIsIlByb21pc2UiLCJyZXNvbHZlIiwia2EiLCJfYXBwbHlTaGltQ3VycmVudFZlcnNpb24iLCJfYXBwbHlTaGltVmFsaWRhdGluZ1ZlcnNpb24iLCJfYXBwbHlTaGltTmV4dFZlcnNpb24iLCJ6IiwibGEiLCJ0aGVuIiwiQSIsIndpbmRvdyIsIlNoYWR5RE9NIiwiaW5Vc2UiLCJCIiwiQyIsInNoaW1jc3Nwcm9wZXJ0aWVzIiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwiQ1NTIiwic3VwcG9ydHMiLCJTaGFkeUNTUyIsIm5hdGl2ZUNzcyIsIldlYkNvbXBvbmVudHMiLCJmbGFncyIsIkUiLCJGIiwiRyIsIm1hIiwiSCIsIkkiLCJfX2Nzc1J1bGVzIiwidGV4dENvbnRlbnQiLCJKIiwibWF0Y2hNZWRpYSIsIm1hdGNoZXMiLCJLIiwibmEiLCJvYSIsIkwiLCJwcm90b3R5cGUiLCJzZXQiLCJpIiwiZ2V0IiwiTSIsIk4iLCJvIiwidGVzdCIsImxhc3RJbmRleCIsInF1ZXJ5U2VsZWN0b3IiLCJqIiwibCIsInBhIiwicWEiLCJPIiwiZXhlYyIsImluZGV4Iiwic2xpY2UiLCJQIiwiam9pbiIsInNldEF0dHJpYnV0ZSIsInN0eWxlIiwiYWxsIiwiaGVhZCIsImdldENvbXB1dGVkU3R5bGUiLCJnZXRQcm9wZXJ0eVZhbHVlIiwicmEiLCJPYmplY3QiLCJhc3NpZ24iLCJjcmVhdGUiLCJYIiwidyIsIlkiLCJEIiwiZGV0ZWN0TWl4aW4iLCJ0cmFuc2Zvcm1TdHlsZSIsInRyYW5zZm9ybUN1c3RvbVN0eWxlIiwidHJhbnNmb3JtUnVsZXMiLCJ0cmFuc2Zvcm1SdWxlIiwidHJhbnNmb3JtVGVtcGxhdGUiLCJfc2VwYXJhdG9yIiwiZGVmaW5lUHJvcGVydHkiLCJRIiwiUiIsIkhUTUxJbXBvcnRzIiwid2hlblJlYWR5IiwiUyIsInNhIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwicmVhZHlTdGF0ZSIsIlQiLCJVIiwiViIsImludmFsaWRDYWxsYmFjayIsIkN1c3RvbVN0eWxlSW50ZXJmYWNlIiwidHJhbnNmb3JtQ2FsbGJhY2siLCJ2YWxpZGF0ZUNhbGxiYWNrIiwiZW5xdWV1ZWQiLCJXIiwicHJlcGFyZVRlbXBsYXRlIiwiX3N0eWxlQXN0IiwicHJvY2Vzc1N0eWxlcyIsImdldFN0eWxlRm9yQ3VzdG9tU3R5bGUiLCJzdHlsZVN1YnRyZWUiLCJyZW1vdmVQcm9wZXJ0eSIsInNldFByb3BlcnR5Iiwic2hhZG93Um9vdCIsInN0eWxlRWxlbWVudCIsImNoaWxkcmVuIiwiY2hpbGROb2RlcyIsImxvY2FsTmFtZSIsImdldEF0dHJpYnV0ZSIsImlzIiwic3R5bGVEb2N1bWVudCIsIlNjb3BpbmdTaGltIiwiWiIsInRhIiwiZ2V0Q29tcHV0ZWRTdHlsZVZhbHVlIiwibmF0aXZlU2hhZG93IiwiQXBwbHlTaGltIiwiY2FsbCIsImN1c3RvbVN0eWxlcyIsIl9fc2VlbkJ5U2hhZHlDU1MiLCJfX3NoYWR5Q1NTQ2FjaGVkU3R5bGUiLCJnZXRTdHlsZSIsIl9fYXBwbGllZEVsZW1lbnQiLCJhZGRDdXN0b21TdHlsZSIsImRlZmluZVByb3BlcnRpZXMiXSwibWFwcGlu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UUFBTyxRQUNyQjtBQUNGO0FBQ0Q7QUFyRzZCLEU7Ozs7Ozs7OztBQ3RCaEMsbUJBQUFBLENBQVEsRUFBUjs7QUFFQSxJQUFNbkIsdUJBQXVCLG1CQUFBbUIsQ0FBUSxDQUFSLENBQTdCOztBQUVBbkIscUJBQXFCb0IsTUFBckIsQ0FBNEIsK3dCQUE1QixFIiwiZmlsZSI6Im1haW4uYnVuZGxlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gaW5zdGFsbCBhIEpTT05QIGNhbGxiYWNrIGZvciBjaHVuayBsb2FkaW5nXG4gXHR2YXIgcGFyZW50SnNvbnBGdW5jdGlvbiA9IHdpbmRvd1tcIndlYnBhY2tKc29ucFwiXTtcbiBcdHdpbmRvd1tcIndlYnBhY2tKc29ucFwiXSA9IGZ1bmN0aW9uIHdlYnBhY2tKc29ucENhbGxiYWNrKGNodW5rSWRzLCBtb3JlTW9kdWxlcywgZXhlY3V0ZU1vZHVsZXMpIHtcbiBcdFx0Ly8gYWRkIFwibW9yZU1vZHVsZXNcIiB0byB0aGUgbW9kdWxlcyBvYmplY3QsXG4gXHRcdC8vIHRoZW4gZmxhZyBhbGwgXCJjaHVua0lkc1wiIGFzIGxvYWRlZCBhbmQgZmlyZSBjYWxsYmFja1xuIFx0XHR2YXIgbW9kdWxlSWQsIGNodW5rSWQsIGkgPSAwLCByZXNvbHZlcyA9IFtdLCByZXN1bHQ7XG4gXHRcdGZvcig7aSA8IGNodW5rSWRzLmxlbmd0aDsgaSsrKSB7XG4gXHRcdFx0Y2h1bmtJZCA9IGNodW5rSWRzW2ldO1xuIFx0XHRcdGlmKGluc3RhbGxlZENodW5rc1tjaHVua0lkXSkge1xuIFx0XHRcdFx0cmVzb2x2ZXMucHVzaChpbnN0YWxsZWRDaHVua3NbY2h1bmtJZF1bMF0pO1xuIFx0XHRcdH1cbiBcdFx0XHRpbnN0YWxsZWRDaHVua3NbY2h1bmtJZF0gPSAwO1xuIFx0XHR9XG4gXHRcdGZvcihtb2R1bGVJZCBpbiBtb3JlTW9kdWxlcykge1xuIFx0XHRcdGlmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb3JlTW9kdWxlcywgbW9kdWxlSWQpKSB7XG4gXHRcdFx0XHRtb2R1bGVzW21vZHVsZUlkXSA9IG1vcmVNb2R1bGVzW21vZHVsZUlkXTtcbiBcdFx0XHR9XG4gXHRcdH1cbiBcdFx0aWYocGFyZW50SnNvbnBGdW5jdGlvbikgcGFyZW50SnNvbnBGdW5jdGlvbihjaHVua0lkcywgbW9yZU1vZHVsZXMsIGV4ZWN1dGVNb2R1bGVzKTtcbiBcdFx0d2hpbGUocmVzb2x2ZXMubGVuZ3RoKSB7XG4gXHRcdFx0cmVzb2x2ZXMuc2hpZnQoKSgpO1xuIFx0XHR9XG5cbiBcdH07XG5cbiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIG9iamVjdHMgdG8gc3RvcmUgbG9hZGVkIGFuZCBsb2FkaW5nIGNodW5rc1xuIFx0dmFyIGluc3RhbGxlZENodW5rcyA9IHtcbiBcdFx0NjogMFxuIFx0fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG4gXHQvLyBUaGlzIGZpbGUgY29udGFpbnMgb25seSB0aGUgZW50cnkgY2h1bmsuXG4gXHQvLyBUaGUgY2h1bmsgbG9hZGluZyBmdW5jdGlvbiBmb3IgYWRkaXRpb25hbCBjaHVua3NcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZSA9IGZ1bmN0aW9uIHJlcXVpcmVFbnN1cmUoY2h1bmtJZCkge1xuIFx0XHR2YXIgaW5zdGFsbGVkQ2h1bmtEYXRhID0gaW5zdGFsbGVkQ2h1bmtzW2NodW5rSWRdO1xuIFx0XHRpZihpbnN0YWxsZWRDaHVua0RhdGEgPT09IDApIHtcbiBcdFx0XHRyZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSkgeyByZXNvbHZlKCk7IH0pO1xuIFx0XHR9XG5cbiBcdFx0Ly8gYSBQcm9taXNlIG1lYW5zIFwiY3VycmVudGx5IGxvYWRpbmdcIi5cbiBcdFx0aWYoaW5zdGFsbGVkQ2h1bmtEYXRhKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZENodW5rRGF0YVsyXTtcbiBcdFx0fVxuXG4gXHRcdC8vIHNldHVwIFByb21pc2UgaW4gY2h1bmsgY2FjaGVcbiBcdFx0dmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiBcdFx0XHRpbnN0YWxsZWRDaHVua0RhdGEgPSBpbnN0YWxsZWRDaHVua3NbY2h1bmtJZF0gPSBbcmVzb2x2ZSwgcmVqZWN0XTtcbiBcdFx0fSk7XG4gXHRcdGluc3RhbGxlZENodW5rRGF0YVsyXSA9IHByb21pc2U7XG5cbiBcdFx0Ly8gc3RhcnQgY2h1bmsgbG9hZGluZ1xuIFx0XHR2YXIgaGVhZCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF07XG4gXHRcdHZhciBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiBcdFx0c2NyaXB0LnR5cGUgPSAndGV4dC9qYXZhc2NyaXB0JztcbiBcdFx0c2NyaXB0LmNoYXJzZXQgPSAndXRmLTgnO1xuIFx0XHRzY3JpcHQuYXN5bmMgPSB0cnVlO1xuIFx0XHRzY3JpcHQudGltZW91dCA9IDEyMDAwMDtcblxuIFx0XHRpZiAoX193ZWJwYWNrX3JlcXVpcmVfXy5uYykge1xuIFx0XHRcdHNjcmlwdC5zZXRBdHRyaWJ1dGUoXCJub25jZVwiLCBfX3dlYnBhY2tfcmVxdWlyZV9fLm5jKTtcbiBcdFx0fVxuIFx0XHRzY3JpcHQuc3JjID0gX193ZWJwYWNrX3JlcXVpcmVfXy5wICsgXCJcIiArIGNodW5rSWQgKyBcIi5idW5kbGUuanNcIjtcbiBcdFx0dmFyIHRpbWVvdXQgPSBzZXRUaW1lb3V0KG9uU2NyaXB0Q29tcGxldGUsIDEyMDAwMCk7XG4gXHRcdHNjcmlwdC5vbmVycm9yID0gc2NyaXB0Lm9ubG9hZCA9IG9uU2NyaXB0Q29tcGxldGU7XG4gXHRcdGZ1bmN0aW9uIG9uU2NyaXB0Q29tcGxldGUoKSB7XG4gXHRcdFx0Ly8gYXZvaWQgbWVtIGxlYWtzIGluIElFLlxuIFx0XHRcdHNjcmlwdC5vbmVycm9yID0gc2NyaXB0Lm9ubG9hZCA9IG51bGw7XG4gXHRcdFx0Y2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuIFx0XHRcdHZhciBjaHVuayA9IGluc3RhbGxlZENodW5rc1tjaHVua0lkXTtcbiBcdFx0XHRpZihjaHVuayAhPT0gMCkge1xuIFx0XHRcdFx0aWYoY2h1bmspIHtcbiBcdFx0XHRcdFx0Y2h1bmtbMV0obmV3IEVycm9yKCdMb2FkaW5nIGNodW5rICcgKyBjaHVua0lkICsgJyBmYWlsZWQuJykpO1xuIFx0XHRcdFx0fVxuIFx0XHRcdFx0aW5zdGFsbGVkQ2h1bmtzW2NodW5rSWRdID0gdW5kZWZpbmVkO1xuIFx0XHRcdH1cbiBcdFx0fTtcbiBcdFx0aGVhZC5hcHBlbmRDaGlsZChzY3JpcHQpO1xuXG4gXHRcdHJldHVybiBwcm9taXNlO1xuIFx0fTtcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbiBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbiBcdFx0XHR9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJkaXN0L1wiO1xuXG4gXHQvLyBvbiBlcnJvciBmdW5jdGlvbiBmb3IgYXN5bmMgbG9hZGluZ1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vZSA9IGZ1bmN0aW9uKGVycikgeyBjb25zb2xlLmVycm9yKGVycik7IHRocm93IGVycjsgfTtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAzOSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay9ib290c3RyYXAgZGU1NDU2MmNkMDhkMjJmNDBhNjIiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwibGliL2xlZ2FjeS9sZWdhY3ktZWxlbWVudC1taXhpbi5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwibGliL2xlZ2FjeS9wb2x5bWVyLWZuLmh0bWxcIj5cbjwhLS0gdGVtcGxhdGUgZWxlbWVudHMgLS0+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwibGliL2xlZ2FjeS90ZW1wbGF0aXplci1iZWhhdmlvci5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwibGliL2VsZW1lbnRzL2RvbS1iaW5kLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCJsaWIvZWxlbWVudHMvZG9tLXJlcGVhdC5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwibGliL2VsZW1lbnRzL2RvbS1pZi5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwibGliL2VsZW1lbnRzL2FycmF5LXNlbGVjdG9yLmh0bWxcIj5cbjwhLS0gY3VzdG9tLXN0eWxlIC0tPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cImxpYi9lbGVtZW50cy9jdXN0b20tc3R5bGUuaHRtbFwiPlxuPCEtLSBiYyBiZWhhdmlvcnMgLS0+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwibGliL2xlZ2FjeS9tdXRhYmxlLWRhdGEtYmVoYXZpb3IuaHRtbFwiPlxuPHNjcmlwdD5cbiAgLy8gYmNcbiAgUG9seW1lci5CYXNlID0gUG9seW1lci5MZWdhY3lFbGVtZW50TWl4aW4oSFRNTEVsZW1lbnQpLnByb3RvdHlwZTtcbjwvc2NyaXB0PlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL3BvbHltZXIuaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cbjxzY3JpcHQ+XG4oZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBjb25zdCB1c2VyUG9seW1lciA9IHdpbmRvdy5Qb2x5bWVyO1xuXG4gIC8qKlxuICAgKiBAbmFtZXNwYWNlIFBvbHltZXJcbiAgICogQHN1bW1hcnkgUG9seW1lciBpcyBhIGxpZ2h0d2VpZ2h0IGxpYnJhcnkgYnVpbHQgb24gdG9wIG9mIHRoZSB3ZWJcbiAgICogICBzdGFuZGFyZHMtYmFzZWQgV2ViIENvbXBvbmVudHMgQVBJJ3MsIGFuZCBtYWtlcyBpdCBlYXN5IHRvIGJ1aWxkIHlvdXJcbiAgICogICBvd24gY3VzdG9tIEhUTUwgZWxlbWVudHMuXG4gICAqIEBwYXJhbSB7IVBvbHltZXJJbml0fSBpbmZvIFByb3RvdHlwZSBmb3IgdGhlIGN1c3RvbSBlbGVtZW50LiBJdCBtdXN0IGNvbnRhaW5cbiAgICogICBhbiBgaXNgIHByb3BlcnR5IHRvIHNwZWNpZnkgdGhlIGVsZW1lbnQgbmFtZS4gT3RoZXIgcHJvcGVydGllcyBwb3B1bGF0ZVxuICAgKiAgIHRoZSBlbGVtZW50IHByb3RvdHlwZS4gVGhlIGBwcm9wZXJ0aWVzYCwgYG9ic2VydmVyc2AsIGBob3N0QXR0cmlidXRlc2AsXG4gICAqICAgYW5kIGBsaXN0ZW5lcnNgIHByb3BlcnRpZXMgYXJlIHByb2Nlc3NlZCB0byBjcmVhdGUgZWxlbWVudCBmZWF0dXJlcy5cbiAgICogQHJldHVybiB7IU9iamVjdH0gUmV0dXJucyBhIGN1c3RvbSBlbGVtZW50IGNsYXNzIGZvciB0aGUgZ2l2ZW4gcHJvdmlkZWRcbiAgICogICBwcm90b3R5cGUgYGluZm9gIG9iamVjdC4gVGhlIG5hbWUgb2YgdGhlIGVsZW1lbnQgaWYgZ2l2ZW4gYnkgYGluZm8uaXNgLlxuICAgKi9cbiAgd2luZG93LlBvbHltZXIgPSBmdW5jdGlvbihpbmZvKSB7XG4gICAgcmV0dXJuIHdpbmRvdy5Qb2x5bWVyLl9wb2x5bWVyRm4oaW5mbyk7XG4gIH1cblxuICAvLyBzdXBwb3J0IHVzZXIgc2V0dGluZ3Mgb24gdGhlIFBvbHltZXIgb2JqZWN0XG4gIGlmICh1c2VyUG9seW1lcikge1xuICAgIE9iamVjdC5hc3NpZ24oUG9seW1lciwgdXNlclBvbHltZXIpO1xuICB9XG5cbiAgLy8gVG8gYmUgcGx1Z2dlZCBieSBsZWdhY3kgaW1wbGVtZW50YXRpb24gaWYgbG9hZGVkXG4gIC8qIGVzbGludC1kaXNhYmxlIHZhbGlkLWpzZG9jICovXG4gIC8qKlxuICAgKiBAcGFyYW0geyFQb2x5bWVySW5pdH0gaW5mbyBQcm90b3R5cGUgZm9yIHRoZSBjdXN0b20gZWxlbWVudC4gSXQgbXVzdCBjb250YWluXG4gICAqICAgYW4gYGlzYCBwcm9wZXJ0eSB0byBzcGVjaWZ5IHRoZSBlbGVtZW50IG5hbWUuIE90aGVyIHByb3BlcnRpZXMgcG9wdWxhdGVcbiAgICogICB0aGUgZWxlbWVudCBwcm90b3R5cGUuIFRoZSBgcHJvcGVydGllc2AsIGBvYnNlcnZlcnNgLCBgaG9zdEF0dHJpYnV0ZXNgLFxuICAgKiAgIGFuZCBgbGlzdGVuZXJzYCBwcm9wZXJ0aWVzIGFyZSBwcm9jZXNzZWQgdG8gY3JlYXRlIGVsZW1lbnQgZmVhdHVyZXMuXG4gICAqIEByZXR1cm4geyFPYmplY3R9IFJldHVybnMgYSBjdXN0b20gZWxlbWVudCBjbGFzcyBmb3IgdGhlIGdpdmVuIHByb3ZpZGVkXG4gICAqICAgcHJvdG90eXBlIGBpbmZvYCBvYmplY3QuIFRoZSBuYW1lIG9mIHRoZSBlbGVtZW50IGlmIGdpdmVuIGJ5IGBpbmZvLmlzYC5cbiAgICovXG4gIHdpbmRvdy5Qb2x5bWVyLl9wb2x5bWVyRm4gPSBmdW5jdGlvbihpbmZvKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0xvYWQgcG9seW1lci5odG1sIHRvIHVzZSB0aGUgUG9seW1lcigpIGZ1bmN0aW9uLicpO1xuICB9XG4gIC8qIGVzbGludC1lbmFibGUgKi9cblxuICB3aW5kb3cuUG9seW1lci52ZXJzaW9uID0gJzIuMC4xJztcblxuICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuICAvKlxuICBXaGVuIHVzaW5nIENsb3N1cmUgQ29tcGlsZXIsIEpTQ29tcGlsZXJfcmVuYW1lUHJvcGVydHkocHJvcGVydHksIG9iamVjdCkgaXMgcmVwbGFjZWQgYnkgdGhlIG11bmdlZCBuYW1lIGZvciBvYmplY3RbcHJvcGVydHldXG4gIFdlIGNhbm5vdCBhbGlhcyB0aGlzIGZ1bmN0aW9uLCBzbyB3ZSBoYXZlIHRvIHVzZSBhIHNtYWxsIHNoaW0gdGhhdCBoYXMgdGhlIHNhbWUgYmVoYXZpb3Igd2hlbiBub3QgY29tcGlsaW5nLlxuICAqL1xuICB3aW5kb3cuSlNDb21waWxlcl9yZW5hbWVQcm9wZXJ0eSA9IGZ1bmN0aW9uKHByb3AsIG9iaikge1xuICAgIHJldHVybiBwcm9wO1xuICB9XG4gIC8qIGVzbGludC1lbmFibGUgKi9cblxufSkoKTtcbjwvc2NyaXB0PlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi91dGlscy9ib290Lmh0bWwiLCIvKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cblxuY2xhc3MgUmVnaXN0ZXJIdG1sVGVtcGxhdGUge1xuICAvKipcbiAgICogQ3JlYXRlIGEgYDx0ZW1wbGF0ZT5gIGVsZW1lbnQgdG8gaG9sZCBgPGRvbS1tb2R1bGU+YCBjb250ZW50LlxuICAgKiBUaGlzIGJpdCBvZiBjb2RlIHdpbGwgZXhlY3V0ZSBpbiB0aGUgY29udGV4dCBvZiB0aGUgbWFpbiBkb2N1bWVudCxcbiAgICogY2FsbGluZyBgaW1wb3J0Tm9kZWAgb24gdGhlIGA8dGVtcGxhdGU+YCwgd2hpY2ggaW4gdHVybiB0cmlnZ2Vyc1xuICAgKiB0aGUgbGlmZWN5Y2xlIG9mIHRoZSBgPGRvbS1tb2R1bGU+YCBhbmQgYWxsb3dzIGl0IHRvIGluc2VydCBpdHNcbiAgICogY29udGVudCBpbnRvIFBvbHltZXIncyBnbG9iYWwgbW9kdWxlIG1hcC4gV2hlbiBhIFBvbHltZXIgZWxlbWVudFxuICAgKiBib290cyB1cCBpdCB3aWxsIGZldGNoIGl0cyB0ZW1wbGF0ZSBmcm9tIHRoaXMgbW9kdWxlIG1hcC5cbiAgICogaHR0cHM6Ly9naXRodWIuY29tL1BvbHltZXIvcG9seW1lci9ibG9iL21hc3Rlci9saWIvbWl4aW5zL2VsZW1lbnQtbWl4aW4uaHRtbCNMNTAxLUw1MzhcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbCBBIGA8ZG9tLW1vZHVsZT5gIGFzIGFuIEhUTUwgc3RyaW5nXG4gICAqL1xuICBzdGF0aWMgcmVnaXN0ZXIodmFsKSB7XG4gICAgbGV0IGNvbnRlbnQ7XG4gICAgY29uc3QgdGVtcGxhdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScpO1xuICAgIHRlbXBsYXRlLmlubmVySFRNTCA9IHZhbDtcbiAgICBpZiAodGVtcGxhdGUuY29udGVudCkge1xuICAgICAgY29udGVudCA9IHRlbXBsYXRlLmNvbnRlbnQ7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcHJlZmVyLWRlc3RydWN0dXJpbmdcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICAgIHdoaWxlICh0ZW1wbGF0ZS5maXJzdENoaWxkKSB7XG4gICAgICAgIGNvbnRlbnQuYXBwZW5kQ2hpbGQodGVtcGxhdGUuZmlyc3RDaGlsZCk7XG4gICAgICB9XG4gICAgfVxuICAgIGRvY3VtZW50LmltcG9ydE5vZGUoY29udGVudCwgdHJ1ZSk7XG4gIH1cbiAgLyoqXG4gICAqIENvbnRlbnQgdGhhdCB3aWxsIGJlIGluamVjdGVkIGludG8gdGhlIG1haW4gZG9jdW1lbnQuIFRoaXMgaXMgcHJpbWFyaWx5XG4gICAqIGZvciB0aGluZ3MgbGlrZSBgPGlyb24taWNvbnNldD5gIGFuZCBgPGN1c3RvbS1zdHlsZT5gIHdoaWNoIGRvIG5vdCBoYXZlXG4gICAqIHRlbXBsYXRlcyBidXQgcmVseSBvbiBIVE1MIEltcG9ydHMgYWJpbGl0eSB0byBhcHBseSBjb250ZW50IHRvIHRoZSBtYWluXG4gICAqIGRvY3VtZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsIEFuIEhUTUwgc3RyaW5nXG4gICAqL1xuICBzdGF0aWMgdG9Cb2R5KHZhbCkge1xuICAgIGNvbnN0IHRyaW1tZWRWYWwgPSB2YWwudHJpbSgpO1xuICAgIGlmICh0cmltbWVkVmFsKSB7XG4gICAgICBjb25zdCBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGRpdi5pbm5lckhUTUwgPSB0cmltbWVkVmFsO1xuICAgICAgaWYgKGRpdi5maXJzdENoaWxkKSB7XG4gICAgICAgIGlmIChkb2N1bWVudC5ib2R5KSB7XG4gICAgICAgICAgZG9jdW1lbnQuYm9keS5pbnNlcnRCZWZvcmUoZGl2LmZpcnN0Q2hpbGQsIGRvY3VtZW50LmJvZHkuZmlyc3RDaGlsZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsICgpID0+IHtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuaW5zZXJ0QmVmb3JlKGRpdi5maXJzdENoaWxkLCBkb2N1bWVudC5ib2R5LmZpcnN0Q2hpbGQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVnaXN0ZXJIdG1sVGVtcGxhdGU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcG9seW1lci13ZWJwYWNrLWxvYWRlci9yZWdpc3Rlci1odG1sLXRlbXBsYXRlLmpzIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuXG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiYm9vdC5odG1sXCI+XG5cbjxzY3JpcHQ+XG5cbihmdW5jdGlvbigpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgLy8gdW5pcXVlIGdsb2JhbCBpZCBmb3IgZGVkdXBpbmcgbWl4aW5zLlxuICBsZXQgZGVkdXBlSWQgPSAwO1xuXG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQGV4dGVuZHMge0Z1bmN0aW9ufVxuICAgKi9cbiAgZnVuY3Rpb24gTWl4aW5GdW5jdGlvbigpe31cbiAgLyoqIEB0eXBlIHsoV2Vha01hcCB8IHVuZGVmaW5lZCl9ICovXG4gIE1peGluRnVuY3Rpb24ucHJvdG90eXBlLl9fbWl4aW5BcHBsaWNhdGlvbnM7XG4gIC8qKiBAdHlwZSB7KE9iamVjdCB8IHVuZGVmaW5lZCl9ICovXG4gIE1peGluRnVuY3Rpb24ucHJvdG90eXBlLl9fbWl4aW5TZXQ7XG5cbiAgLyogZXNsaW50LWRpc2FibGUgdmFsaWQtanNkb2MgKi9cbiAgLyoqXG4gICAqIFdyYXBzIGFuIEVTNiBjbGFzcyBleHByZXNzaW9uIG1peGluIHN1Y2ggdGhhdCB0aGUgbWl4aW4gaXMgb25seSBhcHBsaWVkXG4gICAqIGlmIGl0IGhhcyBub3QgYWxyZWFkeSBiZWVuIGFwcGxpZWQgaXRzIGJhc2UgYXJndW1lbnQuICBBbHNvIG1lbW9pemVzIG1peGluXG4gICAqIGFwcGxpY2F0aW9ucy5cbiAgICpcbiAgICogQG1lbWJlcm9mIFBvbHltZXJcbiAgICogQHRlbXBsYXRlIFRcbiAgICogQHBhcmFtIHtUfSBtaXhpbiBFUzYgY2xhc3MgZXhwcmVzc2lvbiBtaXhpbiB0byB3cmFwXG4gICAqIEBzdXBwcmVzcyB7aW52YWxpZENhc3RzfVxuICAgKi9cbiAgUG9seW1lci5kZWR1cGluZ01peGluID0gZnVuY3Rpb24obWl4aW4pIHtcbiAgICBsZXQgbWl4aW5BcHBsaWNhdGlvbnMgPSAvKiogQHR5cGUgeyFNaXhpbkZ1bmN0aW9ufSAqLyhtaXhpbikuX19taXhpbkFwcGxpY2F0aW9ucztcbiAgICBpZiAoIW1peGluQXBwbGljYXRpb25zKSB7XG4gICAgICBtaXhpbkFwcGxpY2F0aW9ucyA9IG5ldyBXZWFrTWFwKCk7XG4gICAgICAvKiogQHR5cGUgeyFNaXhpbkZ1bmN0aW9ufSAqLyhtaXhpbikuX19taXhpbkFwcGxpY2F0aW9ucyA9IG1peGluQXBwbGljYXRpb25zO1xuICAgIH1cbiAgICAvLyBtYWludGFpbiBhIHVuaXF1ZSBpZCBmb3IgZWFjaCBtaXhpblxuICAgIGxldCBtaXhpbkRlZHVwZUlkID0gZGVkdXBlSWQrKztcbiAgICBmdW5jdGlvbiBkZWR1cGluZ01peGluKGJhc2UpIHtcbiAgICAgIGxldCBiYXNlU2V0ID0gLyoqIEB0eXBlIHshTWl4aW5GdW5jdGlvbn0gKi8oYmFzZSkuX19taXhpblNldDtcbiAgICAgIGlmIChiYXNlU2V0ICYmIGJhc2VTZXRbbWl4aW5EZWR1cGVJZF0pIHtcbiAgICAgICAgcmV0dXJuIGJhc2U7XG4gICAgICB9XG4gICAgICBsZXQgbWFwID0gbWl4aW5BcHBsaWNhdGlvbnM7XG4gICAgICBsZXQgZXh0ZW5kZWQgPSBtYXAuZ2V0KGJhc2UpO1xuICAgICAgaWYgKCFleHRlbmRlZCkge1xuICAgICAgICBleHRlbmRlZCA9IC8qKiBAdHlwZSB7IUZ1bmN0aW9ufSAqLyhtaXhpbikoYmFzZSk7XG4gICAgICAgIG1hcC5zZXQoYmFzZSwgZXh0ZW5kZWQpO1xuICAgICAgfVxuICAgICAgLy8gY29weSBpbmhlcml0ZWQgbWl4aW4gc2V0IGZyb20gdGhlIGV4dGVuZGVkIGNsYXNzLCBvciB0aGUgYmFzZSBjbGFzc1xuICAgICAgLy8gTk9URTogd2UgYXZvaWQgdXNlIG9mIFNldCBoZXJlIGJlY2F1c2Ugc29tZSBicm93c2VyIChJRTExKVxuICAgICAgLy8gY2Fubm90IGV4dGVuZCBhIGJhc2UgU2V0IHZpYSB0aGUgY29uc3RydWN0b3IuXG4gICAgICBsZXQgbWl4aW5TZXQgPSBPYmplY3QuY3JlYXRlKC8qKiBAdHlwZSB7IU1peGluRnVuY3Rpb259ICovKGV4dGVuZGVkKS5fX21peGluU2V0IHx8IGJhc2VTZXQgfHwgbnVsbCk7XG4gICAgICBtaXhpblNldFttaXhpbkRlZHVwZUlkXSA9IHRydWU7XG4gICAgICAvKiogQHR5cGUgeyFNaXhpbkZ1bmN0aW9ufSAqLyhleHRlbmRlZCkuX19taXhpblNldCA9IG1peGluU2V0O1xuICAgICAgcmV0dXJuIGV4dGVuZGVkO1xuICAgIH1cblxuICAgIHJldHVybiBkZWR1cGluZ01peGluO1xuICB9O1xuICAvKiBlc2xpbnQtZW5hYmxlIHZhbGlkLWpzZG9jICovXG5cbn0pKCk7XG5cbjwvc2NyaXB0PlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi91dGlscy9taXhpbi5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNiBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuXG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vLi4vcG9seW1lci9wb2x5bWVyLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi8uLi9pcm9uLXNjcm9sbC10YXJnZXQtYmVoYXZpb3IvaXJvbi1zY3JvbGwtdGFyZ2V0LWJlaGF2aW9yLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi9oZWxwZXJzL2hlbHBlcnMuaHRtbFwiPlxuXG48c2NyaXB0PlxuICAvKipcbiAgICogYFBvbHltZXIuQXBwU2Nyb2xsRWZmZWN0c0JlaGF2aW9yYCBwcm92aWRlcyBhbiBpbnRlcmZhY2UgdGhhdCBhbGxvd3MgYW4gZWxlbWVudCB0byB1c2Ugc2Nyb2xscyBlZmZlY3RzLlxuICAgKlxuICAgKiAjIyMgSW1wb3J0aW5nIHRoZSBhcHAtbGF5b3V0IGVmZmVjdHNcbiAgICpcbiAgICogYXBwLWxheW91dCBwcm92aWRlcyBhIHNldCBvZiBzY3JvbGwgZWZmZWN0cyB0aGF0IGNhbiBiZSB1c2VkIGJ5IGV4cGxpY2l0bHkgaW1wb3J0aW5nXG4gICAqIGBhcHAtc2Nyb2xsLWVmZmVjdHMuaHRtbGA6XG4gICAqXG4gICAqIGBgYGh0bWxcbiAgICogPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi9ib3dlcl9jb21wb25lbnRzL2FwcC1sYXlvdXQvYXBwLXNjcm9sbC1lZmZlY3RzL2FwcC1zY3JvbGwtZWZmZWN0cy5odG1sXCI+XG4gICAqIGBgYFxuICAgKlxuICAgKiBUaGUgc2Nyb2xsIGVmZmVjdHMgY2FuIGFsc28gYmUgdXNlZCBieSBpbmRpdmlkdWFsbHkgaW1wb3J0aW5nXG4gICAqIGBhcHAtbGF5b3V0L2FwcC1zY3JvbGwtZWZmZWN0cy9lZmZlY3RzL1tlZmZlY3ROYW1lXS5odG1sYC4gRm9yIGV4YW1wbGU6XG4gICAqXG4gICAqIGBgYGh0bWxcbiAgICogIDxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIvYm93ZXJfY29tcG9uZW50cy9hcHAtbGF5b3V0L2FwcC1zY3JvbGwtZWZmZWN0cy9lZmZlY3RzL3dhdGVyZmFsbC5odG1sXCI+XG4gICAqIGBgYFxuICAgKlxuICAgKiAjIyMgQ29uc3VtaW5nIGVmZmVjdHNcbiAgICpcbiAgICogRWZmZWN0cyBjYW4gYmUgY29uc3VtZWQgdmlhIHRoZSBgZWZmZWN0c2AgcHJvcGVydHkuIEZvciBleGFtcGxlOlxuICAgKlxuICAgKiBgYGBodG1sXG4gICAqIDxhcHAtaGVhZGVyIGVmZmVjdHM9XCJ3YXRlcmZhbGxcIj48L2FwcC1oZWFkZXI+XG4gICAqIGBgYFxuICAgKlxuICAgKiAjIyMgQ3JlYXRpbmcgc2Nyb2xsIGVmZmVjdHNcbiAgICpcbiAgICogWW91IG1heSB3YW50IHRvIGNyZWF0ZSBhIGN1c3RvbSBzY3JvbGwgZWZmZWN0IGlmIHlvdSBuZWVkIHRvIG1vZGlmeSB0aGUgQ1NTIG9mIGFuIGVsZW1lbnRcbiAgICogYmFzZWQgb24gdGhlIHNjcm9sbCBwb3NpdGlvbi5cbiAgICpcbiAgICogQSBzY3JvbGwgZWZmZWN0IGRlZmluaXRpb24gaXMgYW4gb2JqZWN0IHdpdGggYHNldFVwKClgLCBgdGVhckRvd24oKWAgYW5kIGBydW4oKWAgZnVuY3Rpb25zLlxuICAgKlxuICAgKiBUbyByZWdpc3RlciB0aGUgZWZmZWN0LCB5b3UgY2FuIHVzZSBgUG9seW1lci5BcHBMYXlvdXQucmVnaXN0ZXJFZmZlY3QoZWZmZWN0TmFtZSwgZWZmZWN0RGVmKWBcbiAgICogRm9yIGV4YW1wbGUsIGxldCdzIGRlZmluZSBhbiBlZmZlY3QgdGhhdCByZXNpemVzIHRoZSBoZWFkZXIncyBsb2dvOlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiBQb2x5bWVyLkFwcExheW91dC5yZWdpc3RlckVmZmVjdCgncmVzaXphYmxlLWxvZ28nLCB7XG4gICAqICAgc2V0VXA6IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgKiAgICAgLy8gdGhlIGVmZmVjdCdzIGNvbmZpZyBpcyBwYXNzZWQgdG8gdGhlIHNldFVwLlxuICAgKiAgICAgdGhpcy5fZnhSZXNpemVMb2dvID0geyBsb2dvOiBQb2x5bWVyLmRvbSh0aGlzKS5xdWVyeVNlbGVjdG9yKCdbbG9nb10nKSB9O1xuICAgKiAgIH0sXG4gICAqXG4gICAqICAgcnVuOiBmdW5jdGlvbihwcm9ncmVzcykge1xuICAgKiAgICAgIC8vIHRoZSBwcm9ncmVzcyBvZiB0aGUgZWZmZWN0XG4gICAqICAgICAgdGhpcy50cmFuc2Zvcm0oJ3NjYWxlM2QoJyArIHByb2dyZXNzICsgJywgJysgcHJvZ3Jlc3MgKycsIDEpJywgIHRoaXMuX2Z4UmVzaXplTG9nby5sb2dvKTtcbiAgICogICB9LFxuICAgKlxuICAgKiAgIHRlYXJEb3duOiBmdW5jdGlvbigpIHtcbiAgICogICAgICAvLyBjbGVhbiB1cCBhbmQgcmVzZXQgb2Ygc3RhdGVzXG4gICAqICAgICAgZGVsZXRlIHRoaXMuX2Z4UmVzaXplTG9nbztcbiAgICogICB9XG4gICAqIH0pO1xuICAgKiBgYGBcbiAgICogTm93LCB5b3UgY2FuIGNvbnN1bWUgdGhlIGVmZmVjdDpcbiAgICpcbiAgICogYGBgaHRtbFxuICAgKiA8YXBwLWhlYWRlciBpZD1cImFwcEhlYWRlclwiIGVmZmVjdHM9XCJyZXNpemFibGUtbG9nb1wiPlxuICAgKiAgIDxpbWcgbG9nbyBzcmM9XCJsb2dvLnN2Z1wiPlxuICAgKiA8L2FwcC1oZWFkZXI+XG4gICAqIGBgYFxuICAgKlxuICAgKiAjIyMgSW1wZXJhdGl2ZSBBUElcbiAgICpcbiAgICogYGBganNcbiAgICogdmFyIGxvZ29FZmZlY3QgPSBhcHBIZWFkZXIuY3JlYXRlRWZmZWN0KCdyZXNpemFibGUtbG9nbycsIGVmZmVjdENvbmZpZyk7XG4gICAqIC8vIHJ1biB0aGUgZWZmZWN0OiBsb2dvRWZmZWN0LnJ1bihwcm9ncmVzcyk7XG4gICAqIC8vIHRlYXIgZG93biB0aGUgZWZmZWN0OiBsb2dvRWZmZWN0LnRlYXJEb3duKCk7XG4gICAqIGBgYFxuICAgKlxuICAgKiAjIyMgQ29uZmlndXJpbmcgZWZmZWN0c1xuICAgKlxuICAgKiBGb3IgZWZmZWN0cyBpbnN0YWxsZWQgdmlhIHRoZSBgZWZmZWN0c2AgcHJvcGVydHksIHRoZWlyIGNvbmZpZ3VyYXRpb24gY2FuIGJlIHNldFxuICAgKiB2aWEgdGhlIGBlZmZlY3RzQ29uZmlnYCBwcm9wZXJ0eS4gRm9yIGV4YW1wbGU6XG4gICAqXG4gICAqIGBgYGh0bWxcbiAgICogPGFwcC1oZWFkZXIgZWZmZWN0cz1cIndhdGVyZmFsbFwiXG4gICAqICAgZWZmZWN0cy1jb25maWc9J3tcIndhdGVyZmFsbFwiOiB7XCJzdGFydHNBdFwiOiAwLCBcImVuZHNBdFwiOiAwLjV9fSc+XG4gICAqIDwvYXBwLWhlYWRlcj5cbiAgICogYGBgXG4gICAqXG4gICAqIEFsbCBlZmZlY3RzIGhhdmUgYSBgc3RhcnRzQXRgIGFuZCBgZW5kc0F0YCBjb25maWcgcHJvcGVydHkuIFRoZXkgc3BlY2lmeSBhdCB3aGF0XG4gICAqIHBvaW50IHRoZSBlZmZlY3Qgc2hvdWxkIHN0YXJ0IGFuZCBlbmQuIFRoaXMgdmFsdWUgZ29lcyBmcm9tIDAgdG8gMSBpbmNsdXNpdmUuXG4gICAqXG4gICAqIEBwb2x5bWVyQmVoYXZpb3JcbiAgICovXG4gIFBvbHltZXIuQXBwU2Nyb2xsRWZmZWN0c0JlaGF2aW9yID0gW1xuICAgIFBvbHltZXIuSXJvblNjcm9sbFRhcmdldEJlaGF2aW9yLFxuICAge1xuXG4gICAgcHJvcGVydGllczoge1xuXG4gICAgICAvKipcbiAgICAgICAqIEEgc3BhY2Utc2VwYXJhdGVkIGxpc3Qgb2YgdGhlIGVmZmVjdHMgbmFtZXMgdGhhdCB3aWxsIGJlIHRyaWdnZXJlZCB3aGVuIHRoZSB1c2VyIHNjcm9sbHMuXG4gICAgICAgKiBlLmcuIGB3YXRlcmZhbGwgcGFyYWxsYXgtYmFja2dyb3VuZGAgaW5zdGFsbHMgdGhlIGB3YXRlcmZhbGxgIGFuZCBgcGFyYWxsYXgtYmFja2dyb3VuZGAuXG4gICAgICAgKi9cbiAgICAgIGVmZmVjdHM6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nXG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIEFuIG9iamVjdCB0aGF0IGNvbmZpZ3VyYXRlcyB0aGUgZWZmZWN0cyBpbnN0YWxsZWQgdmlhIHRoZSBgZWZmZWN0c2AgcHJvcGVydHkuIGUuZy5cbiAgICAgICAqIGBgYGpzXG4gICAgICAgKiAgZWxlbWVudC5lZmZlY3RzQ29uZmlnID0ge1xuICAgICAgICogICBcImJsZW5kLWJhY2tncm91bmRcIjoge1xuICAgICAgICogICAgIFwic3RhcnRzQXRcIjogMC41XG4gICAgICAgKiAgIH1cbiAgICAgICAqIH07XG4gICAgICAgKiBgYGBcbiAgICAgICAqIEV2ZXJ5IGVmZmVjdCBoYXMgYXQgbGVhc3QgdHdvIGNvbmZpZyBwcm9wZXJ0aWVzOiBgc3RhcnRzQXRgIGFuZCBgZW5kc0F0YC5cbiAgICAgICAqIFRoZXNlIHByb3BlcnRpZXMgaW5kaWNhdGUgd2hlbiB0aGUgZXZlbnQgc2hvdWxkIHN0YXJ0IGFuZCBlbmQgcmVzcGVjdGl2ZWx5XG4gICAgICAgKiBhbmQgcmVsYXRpdmUgdG8gdGhlIG92ZXJhbGwgZWxlbWVudCBwcm9ncmVzcy4gU28gZm9yIGV4YW1wbGUsIGlmIGBibGVuZC1iYWNrZ3JvdW5kYFxuICAgICAgICogc3RhcnRzIGF0IGAwLjVgLCB0aGUgZWZmZWN0IHdpbGwgb25seSBzdGFydCBvbmNlIHRoZSBjdXJyZW50IGVsZW1lbnQgcmVhY2hlcyAwLjVcbiAgICAgICAqIG9mIGl0cyBwcm9ncmVzcy4gSW4gdGhpcyBjb250ZXh0LCB0aGUgcHJvZ3Jlc3MgaXMgYSB2YWx1ZSBpbiB0aGUgcmFuZ2Ugb2YgYFswLCAxXWBcbiAgICAgICAqIHRoYXQgaW5kaWNhdGVzIHdoZXJlIHRoaXMgZWxlbWVudCBpcyBvbiB0aGUgc2NyZWVuIHJlbGF0aXZlIHRvIHRoZSB2aWV3cG9ydC5cbiAgICAgICAqL1xuICAgICAgZWZmZWN0c0NvbmZpZzoge1xuICAgICAgICB0eXBlOiBPYmplY3QsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogRGlzYWJsZXMgQ1NTIHRyYW5zaXRpb25zIGFuZCBzY3JvbGwgZWZmZWN0cyBvbiB0aGUgZWxlbWVudC5cbiAgICAgICAqL1xuICAgICAgZGlzYWJsZWQ6IHtcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgcmVmbGVjdFRvQXR0cmlidXRlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogQWxsb3dzIHRvIHNldCBhIGBzY3JvbGxUb3BgIHRocmVzaG9sZC4gV2hlbiBncmVhdGVyIHRoYW4gMCwgYHRocmVzaG9sZFRyaWdnZXJlZGBcbiAgICAgICAqIGlzIHRydWUgb25seSB3aGVuIHRoZSBzY3JvbGwgdGFyZ2V0J3MgYHNjcm9sbFRvcGAgaGFzIHJlYWNoZWQgdGhpcyB2YWx1ZS5cbiAgICAgICAqXG4gICAgICAgKiBGb3IgZXhhbXBsZSwgaWYgYHRocmVzaG9sZCA9IDEwMGAsIGB0aHJlc2hvbGRUcmlnZ2VyZWRgIGlzIHRydWUgd2hlbiB0aGUgYHNjcm9sbFRvcGBcbiAgICAgICAqIGlzIGF0IGxlYXN0IGAxMDBgLlxuICAgICAgICovXG4gICAgICB0aHJlc2hvbGQ6IHtcbiAgICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgICB2YWx1ZTogMFxuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBUcnVlIGlmIHRoZSBgc2Nyb2xsVG9wYCB0aHJlc2hvbGQgKHNldCBpbiBgc2Nyb2xsVG9wVGhyZXNob2xkYCkgaGFzXG4gICAgICAgKiBiZWVuIHJlYWNoZWQuXG4gICAgICAgKi9cbiAgICAgIHRocmVzaG9sZFRyaWdnZXJlZDoge1xuICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICBub3RpZnk6IHRydWUsXG4gICAgICAgIHJlYWRPbmx5OiB0cnVlLFxuICAgICAgICByZWZsZWN0VG9BdHRyaWJ1dGU6IHRydWVcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgb2JzZXJ2ZXJzOiBbXG4gICAgICAnX2VmZmVjdHNDaGFuZ2VkKGVmZmVjdHMsIGVmZmVjdHNDb25maWcsIGlzQXR0YWNoZWQpJ1xuICAgIF0sXG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBzY3JvbGwgc3RhdGUuIFRoaXMgbWV0aG9kIHNob3VsZCBiZSBvdmVycmlkZGVuXG4gICAgICogYnkgdGhlIGNvbnN1bWVyIG9mIHRoaXMgYmVoYXZpb3IuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIF91cGRhdGVTY3JvbGxTdGF0ZVxuICAgICAqL1xuICAgIF91cGRhdGVTY3JvbGxTdGF0ZTogZnVuY3Rpb24oKSB7fSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgY3VycmVudCBlbGVtZW50IGlzIG9uIHRoZSBzY3JlZW4uXG4gICAgICogVGhhdCBpcywgdmlzaWJsZSBpbiB0aGUgY3VycmVudCB2aWV3cG9ydC4gVGhpcyBtZXRob2Qgc2hvdWxkIGJlXG4gICAgICogb3ZlcnJpZGRlbiBieSB0aGUgY29uc3VtZXIgb2YgdGhpcyBiZWhhdmlvci5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgaXNPblNjcmVlblxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgaXNPblNjcmVlbjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGVyZSdzIGNvbnRlbnQgYmVsb3cgdGhlIGN1cnJlbnQgZWxlbWVudC4gVGhpcyBtZXRob2RcbiAgICAgKiBzaG91bGQgYmUgb3ZlcnJpZGRlbiBieSB0aGUgY29uc3VtZXIgb2YgdGhpcyBiZWhhdmlvci5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgaXNDb250ZW50QmVsb3dcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuICAgIGlzQ29udGVudEJlbG93OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTGlzdCBvZiBlZmZlY3RzIGhhbmRsZXJzIHRoYXQgd2lsbCB0YWtlIHBsYWNlIGR1cmluZyBzY3JvbGwuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7QXJyYXk8RnVuY3Rpb24+fVxuICAgICAqL1xuICAgIF9lZmZlY3RzUnVuRm46IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBMaXN0IG9mIHRoZSBlZmZlY3RzIGRlZmluaXRpb25zIGluc3RhbGxlZCB2aWEgdGhlIGBlZmZlY3RzYCBwcm9wZXJ0eS5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtBcnJheTxPYmplY3Q+fVxuICAgICAqL1xuICAgIF9lZmZlY3RzOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogVGhlIGNsYW1wZWQgdmFsdWUgb2YgYF9zY3JvbGxUb3BgLlxuICAgICAqIEB0eXBlIG51bWJlclxuICAgICAqL1xuICAgIGdldCBfY2xhbXBlZFNjcm9sbFRvcCgpIHtcbiAgICAgIHJldHVybiBNYXRoLm1heCgwLCB0aGlzLl9zY3JvbGxUb3ApO1xuICAgIH0sXG5cbiAgICBkZXRhY2hlZDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl90ZWFyRG93bkVmZmVjdHMoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBlZmZlY3Qgb2JqZWN0IGZyb20gYW4gZWZmZWN0J3MgbmFtZSB0aGF0IGNhbiBiZSB1c2VkIHRvIHJ1blxuICAgICAqIGVmZmVjdHMgcHJvZ3JhbW1hdGljYWxseS5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgY3JlYXRlRWZmZWN0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGVmZmVjdE5hbWUgVGhlIGVmZmVjdCdzIG5hbWUgcmVnaXN0ZXJlZCB2aWEgYFBvbHltZXIuQXBwTGF5b3V0LnJlZ2lzdGVyRWZmZWN0YC5cbiAgICAgKiBAcGFyYW0ge09iamVjdD19IGVmZmVjdENvbmZpZyBUaGUgZWZmZWN0IGNvbmZpZyBvYmplY3QuIChPcHRpb25hbClcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEFuIGVmZmVjdCBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIGZ1bmN0aW9uczpcbiAgICAgKlxuICAgICAqICAqIGBlZmZlY3Quc2V0VXAoKWAsIFNldHMgdXAgdGhlIHJlcXVpcmVtZW50cyBmb3IgdGhlIGVmZmVjdC5cbiAgICAgKiAgICAgICBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBhdXRvbWF0aWNhbGx5IGJlZm9yZSB0aGUgYGVmZmVjdGAgZnVuY3Rpb24gcmV0dXJucy5cbiAgICAgKiAgKiBgZWZmZWN0LnJ1bihwcm9ncmVzcywgeSlgLCBSdW5zIHRoZSBlZmZlY3QgZ2l2ZW4gYSBgcHJvZ3Jlc3NgLlxuICAgICAqICAqIGBlZmZlY3QudGVhckRvd24oKWAsIENsZWFucyB1cCBhbnkgRE9NIG5vZGVzIG9yIGVsZW1lbnQgcmVmZXJlbmNlcyB1c2VkIGJ5IHRoZSBlZmZlY3QuXG4gICAgICpcbiAgICAgKiBFeGFtcGxlOlxuICAgICAqIGBgYGpzXG4gICAgICogdmFyIHBhcmFsbGF4ID0gZWxlbWVudC5jcmVhdGVFZmZlY3QoJ3BhcmFsbGF4LWJhY2tncm91bmQnKTtcbiAgICAgKiAvLyBydW5zIHRoZSBlZmZlY3RcbiAgICAgKiBwYXJhbGxheC5ydW4oMC41LCAwKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBjcmVhdGVFZmZlY3Q6IGZ1bmN0aW9uKGVmZmVjdE5hbWUsIGVmZmVjdENvbmZpZykge1xuICAgICAgdmFyIGVmZmVjdERlZiA9IFBvbHltZXIuQXBwTGF5b3V0Ll9zY3JvbGxFZmZlY3RzW2VmZmVjdE5hbWVdO1xuICAgICAgaWYgKCFlZmZlY3REZWYpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKHRoaXMuX2dldFVuZGVmaW5lZE1zZyhlZmZlY3ROYW1lKSk7XG4gICAgICB9XG4gICAgICB2YXIgcHJvcCA9IHRoaXMuX2JvdW5kRWZmZWN0KGVmZmVjdERlZiwgZWZmZWN0Q29uZmlnIHx8IHt9KTtcbiAgICAgIHByb3Auc2V0VXAoKTtcbiAgICAgIHJldHVybiBwcm9wO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiBgZWZmZWN0c2Agb3IgYGVmZmVjdHNDb25maWdgIGNoYW5nZXMuXG4gICAgICovXG4gICAgX2VmZmVjdHNDaGFuZ2VkOiBmdW5jdGlvbihlZmZlY3RzLCBlZmZlY3RzQ29uZmlnLCBpc0F0dGFjaGVkKSB7XG4gICAgICB0aGlzLl90ZWFyRG93bkVmZmVjdHMoKTtcblxuICAgICAgaWYgKCFlZmZlY3RzIHx8ICFpc0F0dGFjaGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGVmZmVjdHMuc3BsaXQoJyAnKS5mb3JFYWNoKGZ1bmN0aW9uKGVmZmVjdE5hbWUpIHtcbiAgICAgICAgdmFyIGVmZmVjdERlZjtcbiAgICAgICAgaWYgKGVmZmVjdE5hbWUgIT09ICcnKSB7XG4gICAgICAgICAgaWYgKChlZmZlY3REZWYgPSBQb2x5bWVyLkFwcExheW91dC5fc2Nyb2xsRWZmZWN0c1tlZmZlY3ROYW1lXSkpIHtcbiAgICAgICAgICAgIHRoaXMuX2VmZmVjdHMucHVzaCh0aGlzLl9ib3VuZEVmZmVjdChlZmZlY3REZWYsIGVmZmVjdHNDb25maWdbZWZmZWN0TmFtZV0pKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKHRoaXMuX2dldFVuZGVmaW5lZE1zZyhlZmZlY3ROYW1lKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCB0aGlzKTtcblxuICAgICAgdGhpcy5fc2V0VXBFZmZlY3QoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRm9yY2VzIGxheW91dFxuICAgICAqL1xuICAgIF9sYXlvdXRJZkRpcnR5OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLm9mZnNldFdpZHRoO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGVmZmVjdCBvYmplY3QgYm91bmQgdG8gdGhlIGN1cnJlbnQgY29udGV4dC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlZmZlY3REZWZcbiAgICAgKiBAcGFyYW0ge09iamVjdD19IGVmZmVjdHNDb25maWcgVGhlIGVmZmVjdCBjb25maWcgb2JqZWN0IGlmIHRoZSBlZmZlY3QgYWNjZXB0cyBjb25maWcgdmFsdWVzLiAoT3B0aW9uYWwpXG4gICAgICovXG4gICAgX2JvdW5kRWZmZWN0OiBmdW5jdGlvbihlZmZlY3REZWYsIGVmZmVjdHNDb25maWcpIHtcbiAgICAgIGVmZmVjdHNDb25maWcgPSBlZmZlY3RzQ29uZmlnIHx8IHt9O1xuICAgICAgdmFyIHN0YXJ0c0F0ID0gcGFyc2VGbG9hdChlZmZlY3RzQ29uZmlnLnN0YXJ0c0F0IHx8IDApO1xuICAgICAgdmFyIGVuZHNBdCA9IHBhcnNlRmxvYXQoZWZmZWN0c0NvbmZpZy5lbmRzQXQgfHwgMSk7XG4gICAgICB2YXIgZGVsdGFTID0gZW5kc0F0IC0gc3RhcnRzQXQ7XG4gICAgICB2YXIgbm9vcCA9IGZ1bmN0aW9uKCkge307XG4gICAgICAvLyBmYXN0IHBhdGggaWYgcG9zc2libGVcbiAgICAgIHZhciBydW5GbiA9IChzdGFydHNBdCA9PT0gMCAmJiBlbmRzQXQgPT09IDEpID8gZWZmZWN0RGVmLnJ1biA6XG4gICAgICAgIGZ1bmN0aW9uKHByb2dyZXNzLCB5KSB7XG4gICAgICAgICAgZWZmZWN0RGVmLnJ1bi5jYWxsKHRoaXMsXG4gICAgICAgICAgICAgIE1hdGgubWF4KDAsIChwcm9ncmVzcyAtIHN0YXJ0c0F0KSAvIGRlbHRhUyksIHkpO1xuICAgICAgICB9O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2V0VXA6IGVmZmVjdERlZi5zZXRVcCA/IGVmZmVjdERlZi5zZXRVcC5iaW5kKHRoaXMsIGVmZmVjdHNDb25maWcpIDogbm9vcCxcbiAgICAgICAgcnVuOiBlZmZlY3REZWYucnVuID8gcnVuRm4uYmluZCh0aGlzKSA6IG5vb3AsXG4gICAgICAgIHRlYXJEb3duOiBlZmZlY3REZWYudGVhckRvd24gPyBlZmZlY3REZWYudGVhckRvd24uYmluZCh0aGlzKSA6IG5vb3BcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgdXAgdGhlIGVmZmVjdHMuXG4gICAgICovXG4gICAgX3NldFVwRWZmZWN0OiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmlzQXR0YWNoZWQgJiYgdGhpcy5fZWZmZWN0cykge1xuICAgICAgICB0aGlzLl9lZmZlY3RzUnVuRm4gPSBbXTtcbiAgICAgICAgdGhpcy5fZWZmZWN0cy5mb3JFYWNoKGZ1bmN0aW9uKGVmZmVjdERlZikge1xuICAgICAgICAgIC8vIGluc3RhbGwgdGhlIGVmZmVjdCBvbmx5IGlmIG5vIGVycm9yIHdhcyByZXBvcnRlZFxuICAgICAgICAgIGlmIChlZmZlY3REZWYuc2V0VXAoKSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRoaXMuX2VmZmVjdHNSdW5Gbi5wdXNoKGVmZmVjdERlZi5ydW4pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRlYXJzIGRvd24gdGhlIGVmZmVjdHMuXG4gICAgICovXG4gICAgX3RlYXJEb3duRWZmZWN0czogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5fZWZmZWN0cykge1xuICAgICAgICB0aGlzLl9lZmZlY3RzLmZvckVhY2goZnVuY3Rpb24oZWZmZWN0RGVmKSB7XG4gICAgICAgICAgZWZmZWN0RGVmLnRlYXJEb3duKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdGhpcy5fZWZmZWN0c1J1bkZuID0gW107XG4gICAgICB0aGlzLl9lZmZlY3RzID0gW107XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJ1bnMgdGhlIGVmZmVjdHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcCBUaGUgcHJvZ3Jlc3NcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSBUaGUgdG9wIHBvc2l0aW9uIG9mIHRoZSBjdXJyZW50IGVsZW1lbnQgcmVsYXRpdmUgdG8gdGhlIHZpZXdwb3J0LlxuICAgICAqL1xuICAgIF9ydW5FZmZlY3RzOiBmdW5jdGlvbihwLCB5KSB7XG4gICAgICBpZiAodGhpcy5fZWZmZWN0c1J1bkZuKSB7XG4gICAgICAgIHRoaXMuX2VmZmVjdHNSdW5Gbi5mb3JFYWNoKGZ1bmN0aW9uKHJ1bikge1xuICAgICAgICAgIHJ1bihwLCB5KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlcyB0aGUgYF9zY3JvbGxIYW5kbGVyYC5cbiAgICAgKi9cbiAgICBfc2Nyb2xsSGFuZGxlcjogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgdmFyIHNjcm9sbFRvcCA9IHRoaXMuX2NsYW1wZWRTY3JvbGxUb3A7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVNjcm9sbFN0YXRlKHNjcm9sbFRvcCk7XG4gICAgICAgIGlmICh0aGlzLnRocmVzaG9sZCA+IDApIHtcbiAgICAgICAgICB0aGlzLl9zZXRUaHJlc2hvbGRUcmlnZ2VyZWQoc2Nyb2xsVG9wID49IHRoaXMudGhyZXNob2xkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSB0aGlzIG1ldGhvZCB0byByZXR1cm4gYSByZWZlcmVuY2UgdG8gYSBub2RlIGluIHRoZSBsb2NhbCBET00uXG4gICAgICogVGhlIG5vZGUgaXMgY29uc3VtZWQgYnkgYSBzY3JvbGwgZWZmZWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkIFRoZSBpZCBmb3IgdGhlIG5vZGUuXG4gICAgICovXG4gICAgX2dldERPTVJlZjogZnVuY3Rpb24oaWQpIHtcbiAgICAgIGNvbnNvbGUud2FybignX2dldERPTVJlZicsICdgJysgaWQgKydgIGlzIHVuZGVmaW5lZCcpO1xuICAgIH0sXG5cbiAgICBfZ2V0VW5kZWZpbmVkTXNnOiBmdW5jdGlvbihlZmZlY3ROYW1lKSB7XG4gICAgICByZXR1cm4gJ1Njcm9sbCBlZmZlY3QgYCcgKyBlZmZlY3ROYW1lICsgJ2AgaXMgdW5kZWZpbmVkLiAnICtcbiAgICAgICAgICAnRGlkIHlvdSBmb3JnZXQgdG8gaW1wb3J0IGFwcC1sYXlvdXQvYXBwLXNjcm9sbC1lZmZlY3RzL2VmZmVjdHMvJyArIGVmZmVjdE5hbWUgKyAnLmh0bWwgPyc7XG4gICAgfVxuXG4gIH1dO1xuXG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvYXBwLWxheW91dC9hcHAtc2Nyb2xsLWVmZmVjdHMvYXBwLXNjcm9sbC1lZmZlY3RzLWJlaGF2aW9yLmh0bWwiLCJcbnJlcXVpcmUoJy4uL3BvbHltZXIvcG9seW1lci5odG1sJyk7XG5cbmNvbnN0IFJlZ2lzdGVySHRtbFRlbXBsYXRlID0gcmVxdWlyZSgncG9seW1lci13ZWJwYWNrLWxvYWRlci9yZWdpc3Rlci1odG1sLXRlbXBsYXRlJyk7XG5cblJlZ2lzdGVySHRtbFRlbXBsYXRlLnRvQm9keShcIjxjdXN0b20tc3R5bGU+IDxzdHlsZSBpcz1jdXN0b20tc3R5bGU+aHRtbHstLWxheW91dDp7ZGlzcGxheTotbXMtZmxleGJveDtkaXNwbGF5Oi13ZWJraXQtZmxleDtkaXNwbGF5OmZsZXh9Oy0tbGF5b3V0LWlubGluZTp7ZGlzcGxheTotbXMtaW5saW5lLWZsZXhib3g7ZGlzcGxheTotd2Via2l0LWlubGluZS1mbGV4O2Rpc3BsYXk6aW5saW5lLWZsZXh9Oy0tbGF5b3V0LWhvcml6b250YWw6e0BhcHBseSAtLWxheW91dDstbXMtZmxleC1kaXJlY3Rpb246cm93Oy13ZWJraXQtZmxleC1kaXJlY3Rpb246cm93O2ZsZXgtZGlyZWN0aW9uOnJvd307LS1sYXlvdXQtaG9yaXpvbnRhbC1yZXZlcnNlOntAYXBwbHkgLS1sYXlvdXQ7LW1zLWZsZXgtZGlyZWN0aW9uOnJvdy1yZXZlcnNlOy13ZWJraXQtZmxleC1kaXJlY3Rpb246cm93LXJldmVyc2U7ZmxleC1kaXJlY3Rpb246cm93LXJldmVyc2V9Oy0tbGF5b3V0LXZlcnRpY2FsOntAYXBwbHkgLS1sYXlvdXQ7LW1zLWZsZXgtZGlyZWN0aW9uOmNvbHVtbjstd2Via2l0LWZsZXgtZGlyZWN0aW9uOmNvbHVtbjtmbGV4LWRpcmVjdGlvbjpjb2x1bW59Oy0tbGF5b3V0LXZlcnRpY2FsLXJldmVyc2U6e0BhcHBseSAtLWxheW91dDstbXMtZmxleC1kaXJlY3Rpb246Y29sdW1uLXJldmVyc2U7LXdlYmtpdC1mbGV4LWRpcmVjdGlvbjpjb2x1bW4tcmV2ZXJzZTtmbGV4LWRpcmVjdGlvbjpjb2x1bW4tcmV2ZXJzZX07LS1sYXlvdXQtd3JhcDp7LW1zLWZsZXgtd3JhcDp3cmFwOy13ZWJraXQtZmxleC13cmFwOndyYXA7ZmxleC13cmFwOndyYXB9Oy0tbGF5b3V0LXdyYXAtcmV2ZXJzZTp7LW1zLWZsZXgtd3JhcDp3cmFwLXJldmVyc2U7LXdlYmtpdC1mbGV4LXdyYXA6d3JhcC1yZXZlcnNlO2ZsZXgtd3JhcDp3cmFwLXJldmVyc2V9Oy0tbGF5b3V0LWZsZXgtYXV0bzp7LW1zLWZsZXg6MSAxIGF1dG87LXdlYmtpdC1mbGV4OjEgMSBhdXRvO2ZsZXg6MSAxIGF1dG99Oy0tbGF5b3V0LWZsZXgtbm9uZTp7LW1zLWZsZXg6bm9uZTstd2Via2l0LWZsZXg6bm9uZTtmbGV4Om5vbmV9Oy0tbGF5b3V0LWZsZXg6ey1tcy1mbGV4OjEgMSAuMDAwMDAwMDAxcHg7LXdlYmtpdC1mbGV4OjE7ZmxleDoxOy13ZWJraXQtZmxleC1iYXNpczouMDAwMDAwMDAxcHg7ZmxleC1iYXNpczouMDAwMDAwMDAxcHh9Oy0tbGF5b3V0LWZsZXgtMjp7LW1zLWZsZXg6Mjstd2Via2l0LWZsZXg6MjtmbGV4OjJ9Oy0tbGF5b3V0LWZsZXgtMzp7LW1zLWZsZXg6Mzstd2Via2l0LWZsZXg6MztmbGV4OjN9Oy0tbGF5b3V0LWZsZXgtNDp7LW1zLWZsZXg6NDstd2Via2l0LWZsZXg6NDtmbGV4OjR9Oy0tbGF5b3V0LWZsZXgtNTp7LW1zLWZsZXg6NTstd2Via2l0LWZsZXg6NTtmbGV4OjV9Oy0tbGF5b3V0LWZsZXgtNjp7LW1zLWZsZXg6Njstd2Via2l0LWZsZXg6NjtmbGV4OjZ9Oy0tbGF5b3V0LWZsZXgtNzp7LW1zLWZsZXg6Nzstd2Via2l0LWZsZXg6NztmbGV4Ojd9Oy0tbGF5b3V0LWZsZXgtODp7LW1zLWZsZXg6ODstd2Via2l0LWZsZXg6ODtmbGV4Ojh9Oy0tbGF5b3V0LWZsZXgtOTp7LW1zLWZsZXg6OTstd2Via2l0LWZsZXg6OTtmbGV4Ojl9Oy0tbGF5b3V0LWZsZXgtMTA6ey1tcy1mbGV4OjEwOy13ZWJraXQtZmxleDoxMDtmbGV4OjEwfTstLWxheW91dC1mbGV4LTExOnstbXMtZmxleDoxMTstd2Via2l0LWZsZXg6MTE7ZmxleDoxMX07LS1sYXlvdXQtZmxleC0xMjp7LW1zLWZsZXg6MTI7LXdlYmtpdC1mbGV4OjEyO2ZsZXg6MTJ9Oy0tbGF5b3V0LXN0YXJ0OnstbXMtZmxleC1hbGlnbjpzdGFydDstd2Via2l0LWFsaWduLWl0ZW1zOmZsZXgtc3RhcnQ7YWxpZ24taXRlbXM6ZmxleC1zdGFydH07LS1sYXlvdXQtY2VudGVyOnstbXMtZmxleC1hbGlnbjpjZW50ZXI7LXdlYmtpdC1hbGlnbi1pdGVtczpjZW50ZXI7YWxpZ24taXRlbXM6Y2VudGVyfTstLWxheW91dC1lbmQ6ey1tcy1mbGV4LWFsaWduOmVuZDstd2Via2l0LWFsaWduLWl0ZW1zOmZsZXgtZW5kO2FsaWduLWl0ZW1zOmZsZXgtZW5kfTstLWxheW91dC1iYXNlbGluZTp7LW1zLWZsZXgtYWxpZ246YmFzZWxpbmU7LXdlYmtpdC1hbGlnbi1pdGVtczpiYXNlbGluZTthbGlnbi1pdGVtczpiYXNlbGluZX07LS1sYXlvdXQtc3RhcnQtanVzdGlmaWVkOnstbXMtZmxleC1wYWNrOnN0YXJ0Oy13ZWJraXQtanVzdGlmeS1jb250ZW50OmZsZXgtc3RhcnQ7anVzdGlmeS1jb250ZW50OmZsZXgtc3RhcnR9Oy0tbGF5b3V0LWNlbnRlci1qdXN0aWZpZWQ6ey1tcy1mbGV4LXBhY2s6Y2VudGVyOy13ZWJraXQtanVzdGlmeS1jb250ZW50OmNlbnRlcjtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyfTstLWxheW91dC1lbmQtanVzdGlmaWVkOnstbXMtZmxleC1wYWNrOmVuZDstd2Via2l0LWp1c3RpZnktY29udGVudDpmbGV4LWVuZDtqdXN0aWZ5LWNvbnRlbnQ6ZmxleC1lbmR9Oy0tbGF5b3V0LWFyb3VuZC1qdXN0aWZpZWQ6ey1tcy1mbGV4LXBhY2s6ZGlzdHJpYnV0ZTstd2Via2l0LWp1c3RpZnktY29udGVudDpzcGFjZS1hcm91bmQ7anVzdGlmeS1jb250ZW50OnNwYWNlLWFyb3VuZH07LS1sYXlvdXQtanVzdGlmaWVkOnstbXMtZmxleC1wYWNrOmp1c3RpZnk7LXdlYmtpdC1qdXN0aWZ5LWNvbnRlbnQ6c3BhY2UtYmV0d2VlbjtqdXN0aWZ5LWNvbnRlbnQ6c3BhY2UtYmV0d2Vlbn07LS1sYXlvdXQtY2VudGVyLWNlbnRlcjp7QGFwcGx5IC0tbGF5b3V0LWNlbnRlcjtAYXBwbHkgLS1sYXlvdXQtY2VudGVyLWp1c3RpZmllZDt9Oy0tbGF5b3V0LXNlbGYtc3RhcnQ6ey1tcy1hbGlnbi1zZWxmOmZsZXgtc3RhcnQ7LXdlYmtpdC1hbGlnbi1zZWxmOmZsZXgtc3RhcnQ7YWxpZ24tc2VsZjpmbGV4LXN0YXJ0fTstLWxheW91dC1zZWxmLWNlbnRlcjp7LW1zLWFsaWduLXNlbGY6Y2VudGVyOy13ZWJraXQtYWxpZ24tc2VsZjpjZW50ZXI7YWxpZ24tc2VsZjpjZW50ZXJ9Oy0tbGF5b3V0LXNlbGYtZW5kOnstbXMtYWxpZ24tc2VsZjpmbGV4LWVuZDstd2Via2l0LWFsaWduLXNlbGY6ZmxleC1lbmQ7YWxpZ24tc2VsZjpmbGV4LWVuZH07LS1sYXlvdXQtc2VsZi1zdHJldGNoOnstbXMtYWxpZ24tc2VsZjpzdHJldGNoOy13ZWJraXQtYWxpZ24tc2VsZjpzdHJldGNoO2FsaWduLXNlbGY6c3RyZXRjaH07LS1sYXlvdXQtc2VsZi1iYXNlbGluZTp7LW1zLWFsaWduLXNlbGY6YmFzZWxpbmU7LXdlYmtpdC1hbGlnbi1zZWxmOmJhc2VsaW5lO2FsaWduLXNlbGY6YmFzZWxpbmV9Oy0tbGF5b3V0LXN0YXJ0LWFsaWduZWQ6ey1tcy1mbGV4LWxpbmUtcGFjazpzdGFydDstbXMtYWxpZ24tY29udGVudDpmbGV4LXN0YXJ0Oy13ZWJraXQtYWxpZ24tY29udGVudDpmbGV4LXN0YXJ0O2FsaWduLWNvbnRlbnQ6ZmxleC1zdGFydH07LS1sYXlvdXQtZW5kLWFsaWduZWQ6ey1tcy1mbGV4LWxpbmUtcGFjazplbmQ7LW1zLWFsaWduLWNvbnRlbnQ6ZmxleC1lbmQ7LXdlYmtpdC1hbGlnbi1jb250ZW50OmZsZXgtZW5kO2FsaWduLWNvbnRlbnQ6ZmxleC1lbmR9Oy0tbGF5b3V0LWNlbnRlci1hbGlnbmVkOnstbXMtZmxleC1saW5lLXBhY2s6Y2VudGVyOy1tcy1hbGlnbi1jb250ZW50OmNlbnRlcjstd2Via2l0LWFsaWduLWNvbnRlbnQ6Y2VudGVyO2FsaWduLWNvbnRlbnQ6Y2VudGVyfTstLWxheW91dC1iZXR3ZWVuLWFsaWduZWQ6ey1tcy1mbGV4LWxpbmUtcGFjazpqdXN0aWZ5Oy1tcy1hbGlnbi1jb250ZW50OnNwYWNlLWJldHdlZW47LXdlYmtpdC1hbGlnbi1jb250ZW50OnNwYWNlLWJldHdlZW47YWxpZ24tY29udGVudDpzcGFjZS1iZXR3ZWVufTstLWxheW91dC1hcm91bmQtYWxpZ25lZDp7LW1zLWZsZXgtbGluZS1wYWNrOmRpc3RyaWJ1dGU7LW1zLWFsaWduLWNvbnRlbnQ6c3BhY2UtYXJvdW5kOy13ZWJraXQtYWxpZ24tY29udGVudDpzcGFjZS1hcm91bmQ7YWxpZ24tY29udGVudDpzcGFjZS1hcm91bmR9Oy0tbGF5b3V0LWJsb2NrOntkaXNwbGF5OmJsb2NrfTstLWxheW91dC1pbnZpc2libGU6e3Zpc2liaWxpdHk6aGlkZGVuIWltcG9ydGFudH07LS1sYXlvdXQtcmVsYXRpdmU6e3Bvc2l0aW9uOnJlbGF0aXZlfTstLWxheW91dC1maXQ6e3Bvc2l0aW9uOmFic29sdXRlO3RvcDowO3JpZ2h0OjA7Ym90dG9tOjA7bGVmdDowfTstLWxheW91dC1zY3JvbGw6ey13ZWJraXQtb3ZlcmZsb3ctc2Nyb2xsaW5nOnRvdWNoO292ZXJmbG93OmF1dG99Oy0tbGF5b3V0LWZ1bGxibGVlZDp7bWFyZ2luOjA7aGVpZ2h0OjEwMHZofTstLWxheW91dC1maXhlZC10b3A6e3Bvc2l0aW9uOmZpeGVkO3RvcDowO2xlZnQ6MDtyaWdodDowfTstLWxheW91dC1maXhlZC1yaWdodDp7cG9zaXRpb246Zml4ZWQ7dG9wOjA7cmlnaHQ6MDtib3R0b206MH07LS1sYXlvdXQtZml4ZWQtYm90dG9tOntwb3NpdGlvbjpmaXhlZDtyaWdodDowO2JvdHRvbTowO2xlZnQ6MH07LS1sYXlvdXQtZml4ZWQtbGVmdDp7cG9zaXRpb246Zml4ZWQ7dG9wOjA7Ym90dG9tOjA7bGVmdDowfTt9PC9zdHlsZT4gPC9jdXN0b20tc3R5bGU+XCIpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9pcm9uLWZsZXgtbGF5b3V0L2lyb24tZmxleC1sYXlvdXQuaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCJsaWIvbWl4aW5zL2VsZW1lbnQtbWl4aW4uaHRtbFwiPlxuPHNjcmlwdD5cbihmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8qKlxuICAgKiBCYXNlIGNsYXNzIHRoYXQgcHJvdmlkZXMgdGhlIGNvcmUgQVBJIGZvciBQb2x5bWVyJ3MgbWV0YS1wcm9ncmFtbWluZ1xuICAgKiBmZWF0dXJlcyBpbmNsdWRpbmcgdGVtcGxhdGUgc3RhbXBpbmcsIGRhdGEtYmluZGluZywgYXR0cmlidXRlIGRlc2VyaWFsaXphdGlvbixcbiAgICogYW5kIHByb3BlcnR5IGNoYW5nZSBvYnNlcnZhdGlvbi5cbiAgICpcbiAgICogQGN1c3RvbUVsZW1lbnRcbiAgICogQHBvbHltZXJcbiAgICogQG1lbWJlcm9mIFBvbHltZXJcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBpbXBsZW1lbnRzIHtQb2x5bWVyX0VsZW1lbnRNaXhpbn1cbiAgICogQGV4dGVuZHMgSFRNTEVsZW1lbnRcbiAgICogQGFwcGxpZXNNaXhpbiBQb2x5bWVyLkVsZW1lbnRNaXhpblxuICAgKiBAc3VtbWFyeSBDdXN0b20gZWxlbWVudCBiYXNlIGNsYXNzIHRoYXQgcHJvdmlkZXMgdGhlIGNvcmUgQVBJIGZvciBQb2x5bWVyJ3NcbiAgICogICBrZXkgbWV0YS1wcm9ncmFtbWluZyBmZWF0dXJlcyBpbmNsdWRpbmcgdGVtcGxhdGUgc3RhbXBpbmcsIGRhdGEtYmluZGluZyxcbiAgICogICBhdHRyaWJ1dGUgZGVzZXJpYWxpemF0aW9uLCBhbmQgcHJvcGVydHkgY2hhbmdlIG9ic2VydmF0aW9uXG4gICAqL1xuICBjb25zdCBFbGVtZW50ID0gUG9seW1lci5FbGVtZW50TWl4aW4oSFRNTEVsZW1lbnQpO1xuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBpbXBsZW1lbnRzIHtQb2x5bWVyX0VsZW1lbnRNaXhpbn1cbiAgICogQGV4dGVuZHMge0hUTUxFbGVtZW50fVxuICAgKi9cbiAgUG9seW1lci5FbGVtZW50ID0gRWxlbWVudDtcbn0pKCk7XG48L3NjcmlwdD5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL3BvbHltZXIvcG9seW1lci1lbGVtZW50Lmh0bWwiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiYm9vdC5odG1sXCI+XG5cbjxzY3JpcHQ+XG5cbiAgKGZ1bmN0aW9uKCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGxldCBDU1NfVVJMX1JYID0gLyh1cmxcXCgpKFteKV0qKShcXCkpL2c7XG4gICAgbGV0IEFCU19VUkwgPSAvKF5cXC8pfCheIyl8KF5bXFx3LVxcZF0qOikvO1xuICAgIGxldCB3b3JraW5nVVJMO1xuICAgIGxldCByZXNvbHZlRG9jO1xuICAgIC8qKlxuICAgICAqIFJlc29sdmVzIHRoZSBnaXZlbiBVUkwgYWdhaW5zdCB0aGUgcHJvdmlkZWQgYGJhc2VVcmknLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIFBvbHltZXIuUmVzb2x2ZVVybFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgSW5wdXQgVVJMIHRvIHJlc29sdmVcbiAgICAgKiBAcGFyYW0gez9zdHJpbmc9fSBiYXNlVVJJIEJhc2UgVVJJIHRvIHJlc29sdmUgdGhlIFVSTCBhZ2FpbnN0XG4gICAgICogQHJldHVybiB7c3RyaW5nfSByZXNvbHZlZCBVUkxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXNvbHZlVXJsKHVybCwgYmFzZVVSSSkge1xuICAgICAgaWYgKHVybCAmJiBBQlNfVVJMLnRlc3QodXJsKSkge1xuICAgICAgICByZXR1cm4gdXJsO1xuICAgICAgfVxuICAgICAgLy8gTGF6eSBmZWF0dXJlIGRldGVjdGlvbi5cbiAgICAgIGlmICh3b3JraW5nVVJMID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgd29ya2luZ1VSTCA9IGZhbHNlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHUgPSBuZXcgVVJMKCdiJywgJ2h0dHA6Ly9hJyk7XG4gICAgICAgICAgdS5wYXRobmFtZSA9ICdjJTIwZCc7XG4gICAgICAgICAgd29ya2luZ1VSTCA9ICh1LmhyZWYgPT09ICdodHRwOi8vYS9jJTIwZCcpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgLy8gc2lsZW50bHkgZmFpbFxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWJhc2VVUkkpIHtcbiAgICAgICAgYmFzZVVSSSA9IGRvY3VtZW50LmJhc2VVUkkgfHwgd2luZG93LmxvY2F0aW9uLmhyZWY7XG4gICAgICB9XG4gICAgICBpZiAod29ya2luZ1VSTCkge1xuICAgICAgICByZXR1cm4gKG5ldyBVUkwodXJsLCBiYXNlVVJJKSkuaHJlZjtcbiAgICAgIH1cbiAgICAgIC8vIEZhbGxiYWNrIHRvIGNyZWF0aW5nIGFuIGFuY2hvciBpbnRvIGEgZGlzY29ubmVjdGVkIGRvY3VtZW50LlxuICAgICAgaWYgKCFyZXNvbHZlRG9jKSB7XG4gICAgICAgIHJlc29sdmVEb2MgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoJ3RlbXAnKTtcbiAgICAgICAgcmVzb2x2ZURvYy5iYXNlID0gcmVzb2x2ZURvYy5jcmVhdGVFbGVtZW50KCdiYXNlJyk7XG4gICAgICAgIHJlc29sdmVEb2MuaGVhZC5hcHBlbmRDaGlsZChyZXNvbHZlRG9jLmJhc2UpO1xuICAgICAgICByZXNvbHZlRG9jLmFuY2hvciA9IHJlc29sdmVEb2MuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgICAgICByZXNvbHZlRG9jLmJvZHkuYXBwZW5kQ2hpbGQocmVzb2x2ZURvYy5hbmNob3IpO1xuICAgICAgfVxuICAgICAgcmVzb2x2ZURvYy5iYXNlLmhyZWYgPSBiYXNlVVJJO1xuICAgICAgcmVzb2x2ZURvYy5hbmNob3IuaHJlZiA9IHVybDtcbiAgICAgIHJldHVybiByZXNvbHZlRG9jLmFuY2hvci5ocmVmIHx8IHVybDtcblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlc29sdmVzIGFueSByZWxhdGl2ZSBVUkwncyBpbiB0aGUgZ2l2ZW4gQ1NTIHRleHQgYWdhaW5zdCB0aGUgcHJvdmlkZWRcbiAgICAgKiBgb3duZXJEb2N1bWVudGAncyBgYmFzZVVSSWAuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgUG9seW1lci5SZXNvbHZlVXJsXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNzc1RleHQgQ1NTIHRleHQgdG8gcHJvY2Vzc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlVVJJIEJhc2UgVVJJIHRvIHJlc29sdmUgdGhlIFVSTCBhZ2FpbnN0XG4gICAgICogQHJldHVybiB7c3RyaW5nfSBQcm9jZXNzZWQgQ1NTIHRleHQgd2l0aCByZXNvbHZlZCBVUkwnc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlc29sdmVDc3MoY3NzVGV4dCwgYmFzZVVSSSkge1xuICAgICAgcmV0dXJuIGNzc1RleHQucmVwbGFjZShDU1NfVVJMX1JYLCBmdW5jdGlvbihtLCBwcmUsIHVybCwgcG9zdCkge1xuICAgICAgICByZXR1cm4gcHJlICsgJ1xcJycgK1xuICAgICAgICAgIHJlc29sdmVVcmwodXJsLnJlcGxhY2UoL1tcIiddL2csICcnKSwgYmFzZVVSSSkgK1xuICAgICAgICAgICdcXCcnICsgcG9zdDtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBwYXRoIGZyb20gYSBnaXZlbiBgdXJsYC4gVGhlIHBhdGggaW5jbHVkZXMgdGhlIHRyYWlsaW5nXG4gICAgICogYC9gIGZyb20gdGhlIHVybC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBQb2x5bWVyLlJlc29sdmVVcmxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsIElucHV0IFVSTCB0byB0cmFuc2Zvcm1cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IHJlc29sdmVkIHBhdGhcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYXRoRnJvbVVybCh1cmwpIHtcbiAgICAgIHJldHVybiB1cmwuc3Vic3RyaW5nKDAsIHVybC5sYXN0SW5kZXhPZignLycpICsgMSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTW9kdWxlIHdpdGggdXRpbGl0aWVzIGZvciByZXNvbHZpbmcgcmVsYXRpdmUgVVJMJ3MuXG4gICAgICpcbiAgICAgKiBAbmFtZXNwYWNlXG4gICAgICogQG1lbWJlcm9mIFBvbHltZXJcbiAgICAgKiBAc3VtbWFyeSBNb2R1bGUgd2l0aCB1dGlsaXRpZXMgZm9yIHJlc29sdmluZyByZWxhdGl2ZSBVUkwncy5cbiAgICAgKi9cbiAgICBQb2x5bWVyLlJlc29sdmVVcmwgPSB7XG4gICAgICByZXNvbHZlQ3NzOiByZXNvbHZlQ3NzLFxuICAgICAgcmVzb2x2ZVVybDogcmVzb2x2ZVVybCxcbiAgICAgIHBhdGhGcm9tVXJsOiBwYXRoRnJvbVVybFxuICAgIH07XG5cbiAgfSkoKTtcblxuPC9zY3JpcHQ+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL3BvbHltZXIvbGliL3V0aWxzL3Jlc29sdmUtdXJsLmh0bWwiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiYm9vdC5odG1sXCI+XG5cbjxzY3JpcHQ+XG4oZnVuY3Rpb24oKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8qKiBAdHlwZWRlZiB7e3J1bjogZnVuY3Rpb24oZnVuY3Rpb24oKSwgbnVtYmVyPSk6bnVtYmVyLCBjYW5jZWw6IGZ1bmN0aW9uKG51bWJlcil9fSAqL1xuICBsZXQgQXN5bmNJbnRlcmZhY2U7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblxuICAvLyBNaWNyb3Rhc2sgaW1wbGVtZW50ZWQgdXNpbmcgTXV0YXRpb24gT2JzZXJ2ZXJcbiAgbGV0IG1pY3JvdGFza0N1cnJIYW5kbGUgPSAwO1xuICBsZXQgbWljcm90YXNrTGFzdEhhbmRsZSA9IDA7XG4gIGxldCBtaWNyb3Rhc2tDYWxsYmFja3MgPSBbXTtcbiAgbGV0IG1pY3JvdGFza05vZGVDb250ZW50ID0gMDtcbiAgbGV0IG1pY3JvdGFza05vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyk7XG4gIG5ldyB3aW5kb3cuTXV0YXRpb25PYnNlcnZlcihtaWNyb3Rhc2tGbHVzaCkub2JzZXJ2ZShtaWNyb3Rhc2tOb2RlLCB7Y2hhcmFjdGVyRGF0YTogdHJ1ZX0pO1xuXG4gIGZ1bmN0aW9uIG1pY3JvdGFza0ZsdXNoKCkge1xuICAgIGNvbnN0IGxlbiA9IG1pY3JvdGFza0NhbGxiYWNrcy5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgbGV0IGNiID0gbWljcm90YXNrQ2FsbGJhY2tzW2ldO1xuICAgICAgaWYgKGNiKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY2IoKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4geyB0aHJvdyBlIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIG1pY3JvdGFza0NhbGxiYWNrcy5zcGxpY2UoMCwgbGVuKTtcbiAgICBtaWNyb3Rhc2tMYXN0SGFuZGxlICs9IGxlbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBNb2R1bGUgdGhhdCBwcm92aWRlcyBhIG51bWJlciBvZiBzdHJhdGVnaWVzIGZvciBlbnF1ZXVpbmcgYXN5bmNocm9ub3VzXG4gICAqIHRhc2tzLiAgRWFjaCBzdWItbW9kdWxlIHByb3ZpZGVzIGEgc3RhbmRhcmQgYHJ1bihmbilgIGludGVyZmFjZSB0aGF0IHJldHVybnMgYVxuICAgKiBoYW5kbGUsIGFuZCBhIGBjYW5jZWwoaGFuZGxlKWAgaW50ZXJmYWNlIGZvciBjYW5jZWxpbmcgYXN5bmMgdGFza3MgYmVmb3JlXG4gICAqIHRoZXkgcnVuLlxuICAgKlxuICAgKiBAbmFtZXNwYWNlXG4gICAqIEBtZW1iZXJvZiBQb2x5bWVyXG4gICAqIEBzdW1tYXJ5IE1vZHVsZSB0aGF0IHByb3ZpZGVzIGEgbnVtYmVyIG9mIHN0cmF0ZWdpZXMgZm9yIGVucXVldWluZyBhc3luY2hyb25vdXNcbiAgICogdGFza3MuXG4gICAqL1xuICBQb2x5bWVyLkFzeW5jID0ge1xuXG4gICAgLyoqXG4gICAgICogQXN5bmMgaW50ZXJmYWNlIHdyYXBwZXIgYXJvdW5kIGBzZXRUaW1lb3V0YC5cbiAgICAgKlxuICAgICAqIEBuYW1lc3BhY2VcbiAgICAgKiBAbWVtYmVyb2YgUG9seW1lci5Bc3luY1xuICAgICAqIEBzdW1tYXJ5IEFzeW5jIGludGVyZmFjZSB3cmFwcGVyIGFyb3VuZCBgc2V0VGltZW91dGAuXG4gICAgICovXG4gICAgdGltZU91dDoge1xuICAgICAgLyoqXG4gICAgICAgKiBSZXR1cm5zIGEgc3ViLW1vZHVsZSB3aXRoIHRoZSBhc3luYyBpbnRlcmZhY2UgcHJvdmlkaW5nIHRoZSBwcm92aWRlZFxuICAgICAgICogZGVsYXkuXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlcm9mIFBvbHltZXIuQXN5bmMudGltZU91dFxuICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGRlbGF5IFRpbWUgdG8gd2FpdCBiZWZvcmUgY2FsbGluZyBjYWxsYmFja3MgaW4gbXNcbiAgICAgICAqIEByZXR1cm4ge0FzeW5jSW50ZXJmYWNlfSBBbiBhc3luYyB0aW1lb3V0IGludGVyZmFjZVxuICAgICAgICovXG4gICAgICBhZnRlcihkZWxheSkge1xuICAgICAgICByZXR1cm4gIHtcbiAgICAgICAgICBydW4oZm4pIHsgcmV0dXJuIHNldFRpbWVvdXQoZm4sIGRlbGF5KSB9LFxuICAgICAgICAgIGNhbmNlbDogd2luZG93LmNsZWFyVGltZW91dC5iaW5kKHdpbmRvdylcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8qKlxuICAgICAgICogRW5xdWV1ZXMgYSBmdW5jdGlvbiBjYWxsZWQgaW4gdGhlIG5leHQgdGFzay5cbiAgICAgICAqXG4gICAgICAgKiBAbWVtYmVyb2YgUG9seW1lci5Bc3luYy50aW1lT3V0XG4gICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBDYWxsYmFjayB0byBydW5cbiAgICAgICAqIEByZXR1cm4ge251bWJlcn0gSGFuZGxlIHVzZWQgZm9yIGNhbmNlbGluZyB0YXNrXG4gICAgICAgKi9cbiAgICAgIHJ1bjogd2luZG93LnNldFRpbWVvdXQuYmluZCh3aW5kb3cpLFxuICAgICAgLyoqXG4gICAgICAgKiBDYW5jZWxzIGEgcHJldmlvdXNseSBlbnF1ZXVlZCBgdGltZU91dGAgY2FsbGJhY2suXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlcm9mIFBvbHltZXIuQXN5bmMudGltZU91dFxuICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGhhbmRsZSBIYW5kbGUgcmV0dXJuZWQgZnJvbSBgcnVuYCBvZiBjYWxsYmFjayB0byBjYW5jZWxcbiAgICAgICAqL1xuICAgICAgY2FuY2VsOiB3aW5kb3cuY2xlYXJUaW1lb3V0LmJpbmQod2luZG93KVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBc3luYyBpbnRlcmZhY2Ugd3JhcHBlciBhcm91bmQgYHJlcXVlc3RBbmltYXRpb25GcmFtZWAuXG4gICAgICpcbiAgICAgKiBAbmFtZXNwYWNlXG4gICAgICogQG1lbWJlcm9mIFBvbHltZXIuQXN5bmNcbiAgICAgKiBAc3VtbWFyeSBBc3luYyBpbnRlcmZhY2Ugd3JhcHBlciBhcm91bmQgYHJlcXVlc3RBbmltYXRpb25GcmFtZWAuXG4gICAgICovXG4gICAgYW5pbWF0aW9uRnJhbWU6IHtcbiAgICAgIC8qKlxuICAgICAgICogRW5xdWV1ZXMgYSBmdW5jdGlvbiBjYWxsZWQgYXQgYHJlcXVlc3RBbmltYXRpb25GcmFtZWAgdGltaW5nLlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJvZiBQb2x5bWVyLkFzeW5jLmFuaW1hdGlvbkZyYW1lXG4gICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBDYWxsYmFjayB0byBydW5cbiAgICAgICAqIEByZXR1cm4ge251bWJlcn0gSGFuZGxlIHVzZWQgZm9yIGNhbmNlbGluZyB0YXNrXG4gICAgICAgKi9cbiAgICAgIHJ1bjogd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZS5iaW5kKHdpbmRvdyksXG4gICAgICAvKipcbiAgICAgICAqIENhbmNlbHMgYSBwcmV2aW91c2x5IGVucXVldWVkIGBhbmltYXRpb25GcmFtZWAgY2FsbGJhY2suXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlcm9mIFBvbHltZXIuQXN5bmMudGltZU91dFxuICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGhhbmRsZSBIYW5kbGUgcmV0dXJuZWQgZnJvbSBgcnVuYCBvZiBjYWxsYmFjayB0byBjYW5jZWxcbiAgICAgICAqL1xuICAgICAgY2FuY2VsOiB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUuYmluZCh3aW5kb3cpXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFzeW5jIGludGVyZmFjZSB3cmFwcGVyIGFyb3VuZCBgcmVxdWVzdElkbGVDYWxsYmFja2AuICBGYWxscyBiYWNrIHRvXG4gICAgICogYHNldFRpbWVvdXRgIG9uIGJyb3dzZXJzIHRoYXQgZG8gbm90IHN1cHBvcnQgYHJlcXVlc3RJZGxlQ2FsbGJhY2tgLlxuICAgICAqXG4gICAgICogQG5hbWVzcGFjZVxuICAgICAqIEBtZW1iZXJvZiBQb2x5bWVyLkFzeW5jXG4gICAgICogQHN1bW1hcnkgQXN5bmMgaW50ZXJmYWNlIHdyYXBwZXIgYXJvdW5kIGByZXF1ZXN0SWRsZUNhbGxiYWNrYC5cbiAgICAgKi9cbiAgICBpZGxlUGVyaW9kOiB7XG4gICAgICAvKipcbiAgICAgICAqIEVucXVldWVzIGEgZnVuY3Rpb24gY2FsbGVkIGF0IGByZXF1ZXN0SWRsZUNhbGxiYWNrYCB0aW1pbmcuXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlcm9mIFBvbHltZXIuQXN5bmMuaWRsZVBlcmlvZFxuICAgICAgICogQHBhcmFtIHtmdW5jdGlvbihJZGxlRGVhZGxpbmUpfSBmbiBDYWxsYmFjayB0byBydW5cbiAgICAgICAqIEByZXR1cm4ge251bWJlcn0gSGFuZGxlIHVzZWQgZm9yIGNhbmNlbGluZyB0YXNrXG4gICAgICAgKi9cbiAgICAgIHJ1bihmbikge1xuICAgICAgICByZXR1cm4gd2luZG93LnJlcXVlc3RJZGxlQ2FsbGJhY2sgP1xuICAgICAgICAgIHdpbmRvdy5yZXF1ZXN0SWRsZUNhbGxiYWNrKGZuKSA6XG4gICAgICAgICAgd2luZG93LnNldFRpbWVvdXQoZm4sIDE2KTtcbiAgICAgIH0sXG4gICAgICAvKipcbiAgICAgICAqIENhbmNlbHMgYSBwcmV2aW91c2x5IGVucXVldWVkIGBpZGxlUGVyaW9kYCBjYWxsYmFjay5cbiAgICAgICAqXG4gICAgICAgKiBAbWVtYmVyb2YgUG9seW1lci5Bc3luYy5pZGxlUGVyaW9kXG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0gaGFuZGxlIEhhbmRsZSByZXR1cm5lZCBmcm9tIGBydW5gIG9mIGNhbGxiYWNrIHRvIGNhbmNlbFxuICAgICAgICovXG4gICAgICBjYW5jZWwoaGFuZGxlKSB7XG4gICAgICAgIHdpbmRvdy5jYW5jZWxJZGxlQ2FsbGJhY2sgP1xuICAgICAgICAgIHdpbmRvdy5jYW5jZWxJZGxlQ2FsbGJhY2soaGFuZGxlKSA6XG4gICAgICAgICAgd2luZG93LmNsZWFyVGltZW91dChoYW5kbGUpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBc3luYyBpbnRlcmZhY2UgZm9yIGVucXVldWVpbmcgY2FsbGJhY2tzIHRoYXQgcnVuIGF0IG1pY3JvdGFzayB0aW1pbmcuXG4gICAgICpcbiAgICAgKiBOb3RlIHRoYXQgbWljcm90YXNrIHRpbWluZyBpcyBhY2hpZXZlZCB2aWEgYSBzaW5nbGUgYE11dGF0aW9uT2JzZXJ2ZXJgLFxuICAgICAqIGFuZCB0aHVzIGNhbGxiYWNrcyBlbnF1ZXVlZCB3aXRoIHRoaXMgQVBJIHdpbGwgYWxsIHJ1biBpbiBhIHNpbmdsZVxuICAgICAqIGJhdGNoLCBhbmQgbm90IGludGVybGVhdmVkIHdpdGggb3RoZXIgbWljcm90YXNrcyBzdWNoIGFzIHByb21pc2VzLlxuICAgICAqIFByb21pc2VzIGFyZSBhdm9pZGVkIGFzIGFuIGltcGxlbWVudGF0aW9uIGNob2ljZSBmb3IgdGhlIHRpbWUgYmVpbmdcbiAgICAgKiBkdWUgdG8gU2FmYXJpIGJ1Z3MgdGhhdCBjYXVzZSBQcm9taXNlcyB0byBsYWNrIG1pY3JvdGFzayBndWFyYW50ZWVzLlxuICAgICAqXG4gICAgICogQG5hbWVzcGFjZVxuICAgICAqIEBtZW1iZXJvZiBQb2x5bWVyLkFzeW5jXG4gICAgICogQHN1bW1hcnkgQXN5bmMgaW50ZXJmYWNlIGZvciBlbnF1ZXVlaW5nIGNhbGxiYWNrcyB0aGF0IHJ1biBhdCBtaWNyb3Rhc2tcbiAgICAgKiAgIHRpbWluZy5cbiAgICAgKi9cbiAgICBtaWNyb1Rhc2s6IHtcblxuICAgICAgLyoqXG4gICAgICAgKiBFbnF1ZXVlcyBhIGZ1bmN0aW9uIGNhbGxlZCBhdCBtaWNyb3Rhc2sgdGltaW5nLlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJvZiBQb2x5bWVyLkFzeW5jLm1pY3JvVGFza1xuICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgdG8gcnVuXG4gICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IEhhbmRsZSB1c2VkIGZvciBjYW5jZWxpbmcgdGFza1xuICAgICAgICovXG4gICAgICBydW4oY2FsbGJhY2spIHtcbiAgICAgICAgbWljcm90YXNrTm9kZS50ZXh0Q29udGVudCA9IG1pY3JvdGFza05vZGVDb250ZW50Kys7XG4gICAgICAgIG1pY3JvdGFza0NhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgcmV0dXJuIG1pY3JvdGFza0N1cnJIYW5kbGUrKztcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogQ2FuY2VscyBhIHByZXZpb3VzbHkgZW5xdWV1ZWQgYG1pY3JvVGFza2AgY2FsbGJhY2suXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlcm9mIFBvbHltZXIuQXN5bmMubWljcm9UYXNrXG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0gaGFuZGxlIEhhbmRsZSByZXR1cm5lZCBmcm9tIGBydW5gIG9mIGNhbGxiYWNrIHRvIGNhbmNlbFxuICAgICAgICovXG4gICAgICBjYW5jZWwoaGFuZGxlKSB7XG4gICAgICAgIGNvbnN0IGlkeCA9IGhhbmRsZSAtIG1pY3JvdGFza0xhc3RIYW5kbGU7XG4gICAgICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgICAgIGlmICghbWljcm90YXNrQ2FsbGJhY2tzW2lkeF0pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBhc3luYyBoYW5kbGU6ICcgKyBoYW5kbGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtaWNyb3Rhc2tDYWxsYmFja3NbaWR4XSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgIH1cbiAgfTtcblxufSkoKTtcbjwvc2NyaXB0PlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi91dGlscy9hc3luYy5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuXG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vdXRpbHMvbWl4aW4uaHRtbFwiPlxuXG48c2NyaXB0PlxuKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLy8gQ29tbW9uIGltcGxlbWVudGF0aW9uIGZvciBtaXhpbiAmIGJlaGF2aW9yXG4gIGZ1bmN0aW9uIG11dGFibGVQcm9wZXJ0eUNoYW5nZShpbnN0LCBwcm9wZXJ0eSwgdmFsdWUsIG9sZCwgbXV0YWJsZURhdGEpIHtcbiAgICBsZXQgaXNPYmplY3Q7XG4gICAgaWYgKG11dGFibGVEYXRhKSB7XG4gICAgICBpc09iamVjdCA9ICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsKTtcbiAgICAgIC8vIFB1bGwgYG9sZGAgZm9yIE9iamVjdHMgZnJvbSB0ZW1wIGNhY2hlLCBidXQgdHJlYXQgYG51bGxgIGFzIGEgcHJpbWl0aXZlXG4gICAgICBpZiAoaXNPYmplY3QpIHtcbiAgICAgICAgb2xkID0gaW5zdC5fX2RhdGFUZW1wW3Byb3BlcnR5XTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gU3RyaWN0IGVxdWFsaXR5IGNoZWNrLCBidXQgcmV0dXJuIGZhbHNlIGZvciBOYU49PT1OYU5cbiAgICBsZXQgc2hvdWxkQ2hhbmdlID0gKG9sZCAhPT0gdmFsdWUgJiYgKG9sZCA9PT0gb2xkIHx8IHZhbHVlID09PSB2YWx1ZSkpO1xuICAgIC8vIE9iamVjdHMgYXJlIHN0b3JlZCBpbiB0ZW1wb3JhcnkgY2FjaGUgKGNsZWFyZWQgYXQgZW5kIG9mXG4gICAgLy8gdHVybiksIHdoaWNoIGlzIHVzZWQgZm9yIGRpcnR5LWNoZWNraW5nXG4gICAgaWYgKGlzT2JqZWN0ICYmIHNob3VsZENoYW5nZSkge1xuICAgICAgaW5zdC5fX2RhdGFUZW1wW3Byb3BlcnR5XSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gc2hvdWxkQ2hhbmdlO1xuICB9XG5cbiAgLyoqXG4gICAqIEVsZW1lbnQgY2xhc3MgbWl4aW4gdG8gc2tpcCBzdHJpY3QgZGlydHktY2hlY2tpbmcgZm9yIG9iamVjdHMgYW5kIGFycmF5c1xuICAgKiAoYWx3YXlzIGNvbnNpZGVyIHRoZW0gdG8gYmUgXCJkaXJ0eVwiKSwgZm9yIHVzZSBvbiBlbGVtZW50cyB1dGlsaXppbmdcbiAgICogYFBvbHltZXIuUHJvcGVydHlFZmZlY3RzYFxuICAgKlxuICAgKiBCeSBkZWZhdWx0LCBgUG9seW1lci5Qcm9wZXJ0eUVmZmVjdHNgIHBlcmZvcm1zIHN0cmljdCBkaXJ0eSBjaGVja2luZyBvblxuICAgKiBvYmplY3RzLCB3aGljaCBtZWFucyB0aGF0IGFueSBkZWVwIG1vZGlmaWNhdGlvbnMgdG8gYW4gb2JqZWN0IG9yIGFycmF5IHdpbGxcbiAgICogbm90IGJlIHByb3BhZ2F0ZWQgdW5sZXNzIFwiaW1tdXRhYmxlXCIgZGF0YSBwYXR0ZXJucyBhcmUgdXNlZCAoaS5lLiBhbGwgb2JqZWN0XG4gICAqIHJlZmVyZW5jZXMgZnJvbSB0aGUgcm9vdCB0byB0aGUgbXV0YXRpb24gd2VyZSBjaGFuZ2VkKS5cbiAgICpcbiAgICogUG9seW1lciBhbHNvIHByb3ZpZGVzIGEgcHJvcHJpZXRhcnkgZGF0YSBtdXRhdGlvbiBhbmQgcGF0aCBub3RpZmljYXRpb24gQVBJXG4gICAqIChlLmcuIGBub3RpZnlQYXRoYCwgYHNldGAsIGFuZCBhcnJheSBtdXRhdGlvbiBBUEkncykgdGhhdCBhbGxvdyBlZmZpY2llbnRcbiAgICogbXV0YXRpb24gYW5kIG5vdGlmaWNhdGlvbiBvZiBkZWVwIGNoYW5nZXMgaW4gYW4gb2JqZWN0IGdyYXBoIHRvIGFsbCBlbGVtZW50c1xuICAgKiBib3VuZCB0byB0aGUgc2FtZSBvYmplY3QgZ3JhcGguXG4gICAqXG4gICAqIEluIGNhc2VzIHdoZXJlIG5laXRoZXIgaW1tdXRhYmxlIHBhdHRlcm5zIG5vciB0aGUgZGF0YSBtdXRhdGlvbiBBUEkgY2FuIGJlXG4gICAqIHVzZWQsIGFwcGx5aW5nIHRoaXMgbWl4aW4gd2lsbCBjYXVzZSBQb2x5bWVyIHRvIHNraXAgZGlydHkgY2hlY2tpbmcgZm9yXG4gICAqIG9iamVjdHMgYW5kIGFycmF5cyAoYWx3YXlzIGNvbnNpZGVyIHRoZW0gdG8gYmUgXCJkaXJ0eVwiKS4gIFRoaXMgYWxsb3dzIGFcbiAgICogdXNlciB0byBtYWtlIGEgZGVlcCBtb2RpZmljYXRpb24gdG8gYSBib3VuZCBvYmplY3QgZ3JhcGgsIGFuZCB0aGVuIGVpdGhlclxuICAgKiBzaW1wbHkgcmUtc2V0IHRoZSBvYmplY3QgKGUuZy4gYHRoaXMuaXRlbXMgPSB0aGlzLml0ZW1zYCkgb3IgY2FsbCBgbm90aWZ5UGF0aGBcbiAgICogKGUuZy4gYHRoaXMubm90aWZ5UGF0aCgnaXRlbXMnKWApIHRvIHVwZGF0ZSB0aGUgdHJlZS4gIE5vdGUgdGhhdCBhbGxcbiAgICogZWxlbWVudHMgdGhhdCB3aXNoIHRvIGJlIHVwZGF0ZWQgYmFzZWQgb24gZGVlcCBtdXRhdGlvbnMgbXVzdCBhcHBseSB0aGlzXG4gICAqIG1peGluIG9yIG90aGVyd2lzZSBza2lwIHN0cmljdCBkaXJ0eSBjaGVja2luZyBmb3Igb2JqZWN0cy9hcnJheXMuXG4gICAqXG4gICAqIEluIG9yZGVyIHRvIG1ha2UgdGhlIGRpcnR5IGNoZWNrIHN0cmF0ZWd5IGNvbmZpZ3VyYWJsZSwgc2VlXG4gICAqIGBQb2x5bWVyLk9wdGlvbmFsTXV0YWJsZURhdGFgLlxuICAgKlxuICAgKiBOb3RlLCB0aGUgcGVyZm9ybWFuY2UgY2hhcmFjdGVyaXN0aWNzIG9mIHByb3BhZ2F0aW5nIGxhcmdlIG9iamVjdCBncmFwaHNcbiAgICogd2lsbCBiZSB3b3JzZSBhcyBvcHBvc2VkIHRvIHVzaW5nIHN0cmljdCBkaXJ0eSBjaGVja2luZyB3aXRoIGltbXV0YWJsZVxuICAgKiBwYXR0ZXJucyBvciBQb2x5bWVyJ3MgcGF0aCBub3RpZmljYXRpb24gQVBJLlxuICAgKlxuICAgKiBAbWl4aW5GdW5jdGlvblxuICAgKiBAcG9seW1lclxuICAgKiBAbWVtYmVyb2YgUG9seW1lclxuICAgKiBAc3VtbWFyeSBFbGVtZW50IGNsYXNzIG1peGluIHRvIHNraXAgc3RyaWN0IGRpcnR5LWNoZWNraW5nIGZvciBvYmplY3RzXG4gICAqICAgYW5kIGFycmF5c1xuICAgKi9cbiAgUG9seW1lci5NdXRhYmxlRGF0YSA9IFBvbHltZXIuZGVkdXBpbmdNaXhpbihzdXBlckNsYXNzID0+IHtcblxuICAgIC8qKlxuICAgICAqIEBwb2x5bWVyXG4gICAgICogQG1peGluQ2xhc3NcbiAgICAgKiBAaW1wbGVtZW50cyB7UG9seW1lcl9NdXRhYmxlRGF0YX1cbiAgICAgKi9cbiAgICBjbGFzcyBNdXRhYmxlRGF0YSBleHRlbmRzIHN1cGVyQ2xhc3Mge1xuICAgICAgLyoqXG4gICAgICAgKiBPdmVycmlkZXMgYFBvbHltZXIuUHJvcGVydHlFZmZlY3RzYCB0byBwcm92aWRlIG9wdGlvbiBmb3Igc2tpcHBpbmdcbiAgICAgICAqIHN0cmljdCBlcXVhbGl0eSBjaGVja2luZyBmb3IgT2JqZWN0cyBhbmQgQXJyYXlzLlxuICAgICAgICpcbiAgICAgICAqIFRoaXMgbWV0aG9kIHB1bGxzIHRoZSB2YWx1ZSB0byBkaXJ0eSBjaGVjayBhZ2FpbnN0IGZyb20gdGhlIGBfX2RhdGFUZW1wYFxuICAgICAgICogY2FjaGUgKHJhdGhlciB0aGFuIHRoZSBub3JtYWwgYF9fZGF0YWAgY2FjaGUpIGZvciBPYmplY3RzLiAgU2luY2UgdGhlIHRlbXBcbiAgICAgICAqIGNhY2hlIGlzIGNsZWFyZWQgYXQgdGhlIGVuZCBvZiBhIHR1cm4sIHRoaXMgaW1wbGVtZW50YXRpb24gYWxsb3dzXG4gICAgICAgKiBzaWRlLWVmZmVjdHMgb2YgZGVlcCBvYmplY3QgY2hhbmdlcyB0byBiZSBwcm9jZXNzZWQgYnkgcmUtc2V0dGluZyB0aGVcbiAgICAgICAqIHNhbWUgb2JqZWN0ICh1c2luZyB0aGUgdGVtcCBjYWNoZSBhcyBhbiBpbi10dXJuIGJhY2tzdG9wIHRvIHByZXZlbnRcbiAgICAgICAqIGN5Y2xlcyBkdWUgdG8gMi13YXkgbm90aWZpY2F0aW9uKS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgbmFtZVxuICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBOZXcgcHJvcGVydHkgdmFsdWVcbiAgICAgICAqIEBwYXJhbSB7Kn0gb2xkIFByZXZpb3VzIHByb3BlcnR5IHZhbHVlXG4gICAgICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBwcm9wZXJ0eSBzaG91bGQgYmUgY29uc2lkZXJlZCBhIGNoYW5nZVxuICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICovXG4gICAgICBfc2hvdWxkUHJvcGVydHlDaGFuZ2UocHJvcGVydHksIHZhbHVlLCBvbGQpIHtcbiAgICAgICAgcmV0dXJuIG11dGFibGVQcm9wZXJ0eUNoYW5nZSh0aGlzLCBwcm9wZXJ0eSwgdmFsdWUsIG9sZCwgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICB9XG4gICAgLyoqIEB0eXBlIHtib29sZWFufSAqL1xuICAgIE11dGFibGVEYXRhLnByb3RvdHlwZS5tdXRhYmxlRGF0YSA9IGZhbHNlO1xuXG4gICAgcmV0dXJuIE11dGFibGVEYXRhO1xuXG4gIH0pO1xuXG5cbiAgLyoqXG4gICAqIEVsZW1lbnQgY2xhc3MgbWl4aW4gdG8gYWRkIHRoZSBvcHRpb25hbCBhYmlsaXR5IHRvIHNraXAgc3RyaWN0XG4gICAqIGRpcnR5LWNoZWNraW5nIGZvciBvYmplY3RzIGFuZCBhcnJheXMgKGFsd2F5cyBjb25zaWRlciB0aGVtIHRvIGJlXG4gICAqIFwiZGlydHlcIikgYnkgc2V0dGluZyBhIGBtdXRhYmxlLWRhdGFgIGF0dHJpYnV0ZSBvbiBhbiBlbGVtZW50IGluc3RhbmNlLlxuICAgKlxuICAgKiBCeSBkZWZhdWx0LCBgUG9seW1lci5Qcm9wZXJ0eUVmZmVjdHNgIHBlcmZvcm1zIHN0cmljdCBkaXJ0eSBjaGVja2luZyBvblxuICAgKiBvYmplY3RzLCB3aGljaCBtZWFucyB0aGF0IGFueSBkZWVwIG1vZGlmaWNhdGlvbnMgdG8gYW4gb2JqZWN0IG9yIGFycmF5IHdpbGxcbiAgICogbm90IGJlIHByb3BhZ2F0ZWQgdW5sZXNzIFwiaW1tdXRhYmxlXCIgZGF0YSBwYXR0ZXJucyBhcmUgdXNlZCAoaS5lLiBhbGwgb2JqZWN0XG4gICAqIHJlZmVyZW5jZXMgZnJvbSB0aGUgcm9vdCB0byB0aGUgbXV0YXRpb24gd2VyZSBjaGFuZ2VkKS5cbiAgICpcbiAgICogUG9seW1lciBhbHNvIHByb3ZpZGVzIGEgcHJvcHJpZXRhcnkgZGF0YSBtdXRhdGlvbiBhbmQgcGF0aCBub3RpZmljYXRpb24gQVBJXG4gICAqIChlLmcuIGBub3RpZnlQYXRoYCwgYHNldGAsIGFuZCBhcnJheSBtdXRhdGlvbiBBUEkncykgdGhhdCBhbGxvdyBlZmZpY2llbnRcbiAgICogbXV0YXRpb24gYW5kIG5vdGlmaWNhdGlvbiBvZiBkZWVwIGNoYW5nZXMgaW4gYW4gb2JqZWN0IGdyYXBoIHRvIGFsbCBlbGVtZW50c1xuICAgKiBib3VuZCB0byB0aGUgc2FtZSBvYmplY3QgZ3JhcGguXG4gICAqXG4gICAqIEluIGNhc2VzIHdoZXJlIG5laXRoZXIgaW1tdXRhYmxlIHBhdHRlcm5zIG5vciB0aGUgZGF0YSBtdXRhdGlvbiBBUEkgY2FuIGJlXG4gICAqIHVzZWQsIGFwcGx5aW5nIHRoaXMgbWl4aW4gd2lsbCBhbGxvdyBQb2x5bWVyIHRvIHNraXAgZGlydHkgY2hlY2tpbmcgZm9yXG4gICAqIG9iamVjdHMgYW5kIGFycmF5cyAoYWx3YXlzIGNvbnNpZGVyIHRoZW0gdG8gYmUgXCJkaXJ0eVwiKS4gIFRoaXMgYWxsb3dzIGFcbiAgICogdXNlciB0byBtYWtlIGEgZGVlcCBtb2RpZmljYXRpb24gdG8gYSBib3VuZCBvYmplY3QgZ3JhcGgsIGFuZCB0aGVuIGVpdGhlclxuICAgKiBzaW1wbHkgcmUtc2V0IHRoZSBvYmplY3QgKGUuZy4gYHRoaXMuaXRlbXMgPSB0aGlzLml0ZW1zYCkgb3IgY2FsbCBgbm90aWZ5UGF0aGBcbiAgICogKGUuZy4gYHRoaXMubm90aWZ5UGF0aCgnaXRlbXMnKWApIHRvIHVwZGF0ZSB0aGUgdHJlZS4gIE5vdGUgdGhhdCBhbGxcbiAgICogZWxlbWVudHMgdGhhdCB3aXNoIHRvIGJlIHVwZGF0ZWQgYmFzZWQgb24gZGVlcCBtdXRhdGlvbnMgbXVzdCBhcHBseSB0aGlzXG4gICAqIG1peGluIG9yIG90aGVyd2lzZSBza2lwIHN0cmljdCBkaXJ0eSBjaGVja2luZyBmb3Igb2JqZWN0cy9hcnJheXMuXG4gICAqXG4gICAqIFdoaWxlIHRoaXMgbWl4aW4gYWRkcyB0aGUgYWJpbGl0eSB0byBmb3JnbyBPYmplY3QvQXJyYXkgZGlydHkgY2hlY2tpbmcsXG4gICAqIHRoZSBgbXV0YWJsZURhdGFgIGZsYWcgZGVmYXVsdHMgdG8gZmFsc2UgYW5kIG11c3QgYmUgc2V0IG9uIHRoZSBpbnN0YW5jZS5cbiAgICpcbiAgICogTm90ZSwgdGhlIHBlcmZvcm1hbmNlIGNoYXJhY3RlcmlzdGljcyBvZiBwcm9wYWdhdGluZyBsYXJnZSBvYmplY3QgZ3JhcGhzXG4gICAqIHdpbGwgYmUgd29yc2UgYnkgcmVseWluZyBvbiBgbXV0YWJsZURhdGE6IHRydWVgIGFzIG9wcG9zZWQgdG8gdXNpbmdcbiAgICogc3RyaWN0IGRpcnR5IGNoZWNraW5nIHdpdGggaW1tdXRhYmxlIHBhdHRlcm5zIG9yIFBvbHltZXIncyBwYXRoIG5vdGlmaWNhdGlvblxuICAgKiBBUEkuXG4gICAqXG4gICAqIEBtaXhpbkZ1bmN0aW9uXG4gICAqIEBwb2x5bWVyXG4gICAqIEBtZW1iZXJvZiBQb2x5bWVyXG4gICAqIEBzdW1tYXJ5IEVsZW1lbnQgY2xhc3MgbWl4aW4gdG8gb3B0aW9uYWxseSBza2lwIHN0cmljdCBkaXJ0eS1jaGVja2luZ1xuICAgKiAgIGZvciBvYmplY3RzIGFuZCBhcnJheXNcbiAgICovXG4gIFBvbHltZXIuT3B0aW9uYWxNdXRhYmxlRGF0YSA9IFBvbHltZXIuZGVkdXBpbmdNaXhpbihzdXBlckNsYXNzID0+IHtcblxuICAgIC8qKlxuICAgICAqIEBtaXhpbkNsYXNzXG4gICAgICogQHBvbHltZXJcbiAgICAgKiBAaW1wbGVtZW50cyB7UG9seW1lcl9PcHRpb25hbE11dGFibGVEYXRhfVxuICAgICAqL1xuICAgIGNsYXNzIE9wdGlvbmFsTXV0YWJsZURhdGEgZXh0ZW5kcyBzdXBlckNsYXNzIHtcblxuICAgICAgc3RhdGljIGdldCBwcm9wZXJ0aWVzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIEluc3RhbmNlLWxldmVsIGZsYWcgZm9yIGNvbmZpZ3VyaW5nIHRoZSBkaXJ0eS1jaGVja2luZyBzdHJhdGVneVxuICAgICAgICAgICAqIGZvciB0aGlzIGVsZW1lbnQuICBXaGVuIHRydWUsIE9iamVjdHMgYW5kIEFycmF5cyB3aWxsIHNraXAgZGlydHlcbiAgICAgICAgICAgKiBjaGVja2luZywgb3RoZXJ3aXNlIHN0cmljdCBlcXVhbGl0eSBjaGVja2luZyB3aWxsIGJlIHVzZWQuXG4gICAgICAgICAgICovXG4gICAgICAgICAgbXV0YWJsZURhdGE6IEJvb2xlYW5cbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBPdmVycmlkZXMgYFBvbHltZXIuUHJvcGVydHlFZmZlY3RzYCB0byBwcm92aWRlIG9wdGlvbiBmb3Igc2tpcHBpbmdcbiAgICAgICAqIHN0cmljdCBlcXVhbGl0eSBjaGVja2luZyBmb3IgT2JqZWN0cyBhbmQgQXJyYXlzLlxuICAgICAgICpcbiAgICAgICAqIFdoZW4gYHRoaXMubXV0YWJsZURhdGFgIGlzIHRydWUgb24gdGhpcyBpbnN0YW5jZSwgdGhpcyBtZXRob2RcbiAgICAgICAqIHB1bGxzIHRoZSB2YWx1ZSB0byBkaXJ0eSBjaGVjayBhZ2FpbnN0IGZyb20gdGhlIGBfX2RhdGFUZW1wYCBjYWNoZVxuICAgICAgICogKHJhdGhlciB0aGFuIHRoZSBub3JtYWwgYF9fZGF0YWAgY2FjaGUpIGZvciBPYmplY3RzLiAgU2luY2UgdGhlIHRlbXBcbiAgICAgICAqIGNhY2hlIGlzIGNsZWFyZWQgYXQgdGhlIGVuZCBvZiBhIHR1cm4sIHRoaXMgaW1wbGVtZW50YXRpb24gYWxsb3dzXG4gICAgICAgKiBzaWRlLWVmZmVjdHMgb2YgZGVlcCBvYmplY3QgY2hhbmdlcyB0byBiZSBwcm9jZXNzZWQgYnkgcmUtc2V0dGluZyB0aGVcbiAgICAgICAqIHNhbWUgb2JqZWN0ICh1c2luZyB0aGUgdGVtcCBjYWNoZSBhcyBhbiBpbi10dXJuIGJhY2tzdG9wIHRvIHByZXZlbnRcbiAgICAgICAqIGN5Y2xlcyBkdWUgdG8gMi13YXkgbm90aWZpY2F0aW9uKS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgbmFtZVxuICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBOZXcgcHJvcGVydHkgdmFsdWVcbiAgICAgICAqIEBwYXJhbSB7Kn0gb2xkIFByZXZpb3VzIHByb3BlcnR5IHZhbHVlXG4gICAgICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBwcm9wZXJ0eSBzaG91bGQgYmUgY29uc2lkZXJlZCBhIGNoYW5nZVxuICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICovXG4gICAgICBfc2hvdWxkUHJvcGVydHlDaGFuZ2UocHJvcGVydHksIHZhbHVlLCBvbGQpIHtcbiAgICAgICAgcmV0dXJuIG11dGFibGVQcm9wZXJ0eUNoYW5nZSh0aGlzLCBwcm9wZXJ0eSwgdmFsdWUsIG9sZCwgdGhpcy5tdXRhYmxlRGF0YSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIE9wdGlvbmFsTXV0YWJsZURhdGE7XG5cbiAgfSk7XG5cbiAgLy8gRXhwb3J0IGZvciB1c2UgYnkgbGVnYWN5IGJlaGF2aW9yXG4gIFBvbHltZXIuTXV0YWJsZURhdGEuX211dGFibGVQcm9wZXJ0eUNoYW5nZSA9IG11dGFibGVQcm9wZXJ0eUNoYW5nZTtcblxufSkoKTtcbjwvc2NyaXB0PlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi9taXhpbnMvbXV0YWJsZS1kYXRhLmh0bWwiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiYm9vdC5odG1sXCI+XG48c2NyaXB0PlxuKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgY29uc3QgY2FzZU1hcCA9IHt9O1xuICBjb25zdCBEQVNIX1RPX0NBTUVMID0gLy1bYS16XS9nO1xuICBjb25zdCBDQU1FTF9UT19EQVNIID0gLyhbQS1aXSkvZztcblxuICAvKipcbiAgICogTW9kdWxlIHdpdGggdXRpbGl0aWVzIGZvciBjb252ZXJ0aW5nIGJldHdlZW4gXCJkYXNoLWNhc2VcIiBhbmQgXCJjYW1lbENhc2VcIlxuICAgKiBpZGVudGlmaWVycy5cbiAgICpcbiAgICogQG5hbWVzcGFjZVxuICAgKiBAbWVtYmVyb2YgUG9seW1lclxuICAgKiBAc3VtbWFyeSBNb2R1bGUgdGhhdCBwcm92aWRlcyB1dGlsaXRpZXMgZm9yIGNvbnZlcnRpbmcgYmV0d2VlbiBcImRhc2gtY2FzZVwiXG4gICAqICAgYW5kIFwiY2FtZWxDYXNlXCIuXG4gICAqL1xuICBjb25zdCBDYXNlTWFwID0ge1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgXCJkYXNoLWNhc2VcIiBpZGVudGlmaWVyIChlLmcuIGBmb28tYmFyLWJhemApIHRvIFwiY2FtZWxDYXNlXCJcbiAgICAgKiAoZS5nLiBgZm9vQmFyQmF6YCkuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgUG9seW1lci5DYXNlTWFwXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRhc2ggRGFzaC1jYXNlIGlkZW50aWZpZXJcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IENhbWVsLWNhc2UgcmVwcmVzZW50YXRpb24gb2YgdGhlIGlkZW50aWZpZXJcbiAgICAgKi9cbiAgICBkYXNoVG9DYW1lbENhc2UoZGFzaCkge1xuICAgICAgcmV0dXJuIGNhc2VNYXBbZGFzaF0gfHwgKFxuICAgICAgICBjYXNlTWFwW2Rhc2hdID0gZGFzaC5pbmRleE9mKCctJykgPCAwID8gZGFzaCA6IGRhc2gucmVwbGFjZShEQVNIX1RPX0NBTUVMLFxuICAgICAgICAgIChtKSA9PiBtWzFdLnRvVXBwZXJDYXNlKClcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgXCJjYW1lbENhc2VcIiBpZGVudGlmaWVyIChlLmcuIGBmb29CYXJCYXpgKSB0byBcImRhc2gtY2FzZVwiXG4gICAgICogKGUuZy4gYGZvby1iYXItYmF6YCkuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgUG9seW1lci5DYXNlTWFwXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNhbWVsIENhbWVsLWNhc2UgaWRlbnRpZmllclxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gRGFzaC1jYXNlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBpZGVudGlmaWVyXG4gICAgICovXG4gICAgY2FtZWxUb0Rhc2hDYXNlKGNhbWVsKSB7XG4gICAgICByZXR1cm4gY2FzZU1hcFtjYW1lbF0gfHwgKFxuICAgICAgICBjYXNlTWFwW2NhbWVsXSA9IGNhbWVsLnJlcGxhY2UoQ0FNRUxfVE9fREFTSCwgJy0kMScpLnRvTG93ZXJDYXNlKClcbiAgICAgICk7XG4gICAgfVxuXG4gIH07XG5cbiAgUG9seW1lci5DYXNlTWFwID0gQ2FzZU1hcDtcbn0pKCk7XG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvdXRpbHMvY2FzZS1tYXAuaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cblxuXG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vdXRpbHMvYm9vdC5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vdXRpbHMvbWl4aW4uaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3V0aWxzL3BhdGguaHRtbFwiPlxuPCEtLSBmb3Igbm90aWZ5LCByZWZsZWN0IC0tPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3V0aWxzL2Nhc2UtbWFwLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCJwcm9wZXJ0eS1hY2Nlc3NvcnMuaHRtbFwiPlxuPCEtLSBmb3IgYW5ub3RhdGVkIGVmZmVjdHMgLS0+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwidGVtcGxhdGUtc3RhbXAuaHRtbFwiPlxuXG5cbjxzY3JpcHQ+XG4oZnVuY3Rpb24oKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8qKiBAY29uc3Qge09iamVjdH0gKi9cbiAgY29uc3QgQ2FzZU1hcCA9IFBvbHltZXIuQ2FzZU1hcDtcblxuICAvLyBNb25vdG9uaWNhbGx5IGluY3JlYXNpbmcgdW5pcXVlIElEIHVzZWQgZm9yIGRlLWR1cGluZyBlZmZlY3RzIHRyaWdnZXJlZFxuICAvLyBmcm9tIG11bHRpcGxlIHByb3BlcnRpZXMgaW4gdGhlIHNhbWUgdHVyblxuICBsZXQgZGVkdXBlSWQgPSAwO1xuXG4gIC8qKlxuICAgKiBQcm9wZXJ0eSBlZmZlY3QgdHlwZXM7IGVmZmVjdHMgYXJlIHN0b3JlZCBvbiB0aGUgcHJvdG90eXBlIHVzaW5nIHRoZXNlIGtleXNcbiAgICogQGVudW0ge3N0cmluZ31cbiAgICovXG4gIGNvbnN0IFRZUEVTID0ge1xuICAgIENPTVBVVEU6ICdfX2NvbXB1dGVFZmZlY3RzJyxcbiAgICBSRUZMRUNUOiAnX19yZWZsZWN0RWZmZWN0cycsXG4gICAgTk9USUZZOiAnX19ub3RpZnlFZmZlY3RzJyxcbiAgICBQUk9QQUdBVEU6ICdfX3Byb3BhZ2F0ZUVmZmVjdHMnLFxuICAgIE9CU0VSVkU6ICdfX29ic2VydmVFZmZlY3RzJyxcbiAgICBSRUFEX09OTFk6ICdfX3JlYWRPbmx5J1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlZGVmIHt7XG4gICAqIG5hbWU6IChzdHJpbmcgfCB1bmRlZmluZWQpLFxuICAgKiBzdHJ1Y3R1cmVkOiAoYm9vbGVhbiB8IHVuZGVmaW5lZCksXG4gICAqIHdpbGRjYXJkOiAoYm9vbGVhbiB8IHVuZGVmaW5lZClcbiAgICogfX1cbiAgICovXG4gIGxldCBEYXRhVHJpZ2dlcjsgLy9lc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cbiAgLyoqXG4gICAqIEB0eXBlZGVmIHt7XG4gICAqIGluZm86ID8sXG4gICAqIHRyaWdnZXI6ICghRGF0YVRyaWdnZXIgfCB1bmRlZmluZWQpLFxuICAgKiBmbjogKCFGdW5jdGlvbiB8IHVuZGVmaW5lZClcbiAgICogfX1cbiAgICovXG4gIGxldCBEYXRhRWZmZWN0OyAvL2VzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblxuICBsZXQgUHJvcGVydHlFZmZlY3RzVHlwZTsgLy9lc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cbiAgLyoqXG4gICAqIEVuc3VyZXMgdGhhdCB0aGUgbW9kZWwgaGFzIGFuIG93bi1wcm9wZXJ0eSBtYXAgb2YgZWZmZWN0cyBmb3IgdGhlIGdpdmVuIHR5cGUuXG4gICAqIFRoZSBtb2RlbCBtYXkgYmUgYSBwcm90b3R5cGUgb3IgYW4gaW5zdGFuY2UuXG4gICAqXG4gICAqIFByb3BlcnR5IGVmZmVjdHMgYXJlIHN0b3JlZCBhcyBhcnJheXMgb2YgZWZmZWN0cyBieSBwcm9wZXJ0eSBpbiBhIG1hcCxcbiAgICogYnkgbmFtZWQgdHlwZSBvbiB0aGUgbW9kZWwuIGUuZy5cbiAgICpcbiAgICogICBfX2NvbXB1dGVFZmZlY3RzOiB7XG4gICAqICAgICBmb286IFsgLi4uIF0sXG4gICAqICAgICBiYXI6IFsgLi4uIF1cbiAgICogICB9XG4gICAqXG4gICAqIElmIHRoZSBtb2RlbCBkb2VzIG5vdCB5ZXQgaGF2ZSBhbiBlZmZlY3QgbWFwIGZvciB0aGUgdHlwZSwgb25lIGlzIGNyZWF0ZWRcbiAgICogYW5kIHJldHVybmVkLiAgSWYgaXQgZG9lcywgYnV0IGl0IGlzIG5vdCBhbiBvd24gcHJvcGVydHkgKGkuZS4gdGhlXG4gICAqIHByb3RvdHlwZSBoYWQgZWZmZWN0cyksIHRoZSB0aGUgbWFwIGlzIGRlZXBseSBjbG9uZWQgYW5kIHRoZSBjb3B5IGlzXG4gICAqIHNldCBvbiB0aGUgbW9kZWwgYW5kIHJldHVybmVkLCByZWFkeSBmb3IgbmV3IGVmZmVjdHMgdG8gYmUgYWRkZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBtb2RlbCBQcm90b3R5cGUgb3IgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgUHJvcGVydHkgZWZmZWN0IHR5cGVcbiAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgb3duLXByb3BlcnR5IG1hcCBvZiBlZmZlY3RzIGZvciB0aGUgZ2l2ZW4gdHlwZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gZW5zdXJlT3duRWZmZWN0TWFwKG1vZGVsLCB0eXBlKSB7XG4gICAgbGV0IGVmZmVjdHMgPSBtb2RlbFt0eXBlXTtcbiAgICBpZiAoIWVmZmVjdHMpIHtcbiAgICAgIGVmZmVjdHMgPSBtb2RlbFt0eXBlXSA9IHt9O1xuICAgIH0gZWxzZSBpZiAoIW1vZGVsLmhhc093blByb3BlcnR5KHR5cGUpKSB7XG4gICAgICBlZmZlY3RzID0gbW9kZWxbdHlwZV0gPSBPYmplY3QuY3JlYXRlKG1vZGVsW3R5cGVdKTtcbiAgICAgIGZvciAobGV0IHAgaW4gZWZmZWN0cykge1xuICAgICAgICBsZXQgcHJvdG9GeCA9IGVmZmVjdHNbcF07XG4gICAgICAgIGxldCBpbnN0RnggPSBlZmZlY3RzW3BdID0gQXJyYXkocHJvdG9GeC5sZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8cHJvdG9GeC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGluc3RGeFtpXSA9IHByb3RvRnhbaV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVmZmVjdHM7XG4gIH1cblxuICAvLyAtLSBlZmZlY3RzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvKipcbiAgICogUnVucyBhbGwgZWZmZWN0cyBvZiBhIGdpdmVuIHR5cGUgZm9yIHRoZSBnaXZlbiBzZXQgb2YgcHJvcGVydHkgY2hhbmdlc1xuICAgKiBvbiBhbiBpbnN0YW5jZS5cbiAgICpcbiAgICogQHBhcmFtIHshUHJvcGVydHlFZmZlY3RzVHlwZX0gaW5zdCBUaGUgaW5zdGFuY2Ugd2l0aCBlZmZlY3RzIHRvIHJ1blxuICAgKiBAcGFyYW0ge09iamVjdH0gZWZmZWN0cyBPYmplY3QgbWFwIG9mIHByb3BlcnR5LXRvLUFycmF5IG9mIGVmZmVjdHNcbiAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzIEJhZyBvZiBjdXJyZW50IHByb3BlcnR5IGNoYW5nZXNcbiAgICogQHBhcmFtIHtPYmplY3Q9fSBvbGRQcm9wcyBCYWcgb2YgcHJldmlvdXMgdmFsdWVzIGZvciBjaGFuZ2VkIHByb3BlcnRpZXNcbiAgICogQHBhcmFtIHtib29sZWFuPX0gaGFzUGF0aHMgVHJ1ZSB3aXRoIGBwcm9wc2AgY29udGFpbnMgb25lIG9yIG1vcmUgcGF0aHNcbiAgICogQHBhcmFtIHsqPX0gZXh0cmFBcmdzIEFkZGl0aW9uYWwgbWV0YWRhdGEgdG8gcGFzcyB0byBlZmZlY3QgZnVuY3Rpb25cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBhbiBlZmZlY3QgcmFuIGZvciB0aGlzIHByb3BlcnR5XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBydW5FZmZlY3RzKGluc3QsIGVmZmVjdHMsIHByb3BzLCBvbGRQcm9wcywgaGFzUGF0aHMsIGV4dHJhQXJncykge1xuICAgIGlmIChlZmZlY3RzKSB7XG4gICAgICBsZXQgcmFuID0gZmFsc2U7XG4gICAgICBsZXQgaWQgPSBkZWR1cGVJZCsrO1xuICAgICAgZm9yIChsZXQgcHJvcCBpbiBwcm9wcykge1xuICAgICAgICBpZiAocnVuRWZmZWN0c0ZvclByb3BlcnR5KGluc3QsIGVmZmVjdHMsIGlkLCBwcm9wLCBwcm9wcywgb2xkUHJvcHMsIGhhc1BhdGhzLCBleHRyYUFyZ3MpKSB7XG4gICAgICAgICAgcmFuID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJhbjtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJ1bnMgYSBsaXN0IG9mIGVmZmVjdHMgZm9yIGEgZ2l2ZW4gcHJvcGVydHkuXG4gICAqXG4gICAqIEBwYXJhbSB7IVByb3BlcnR5RWZmZWN0c1R5cGV9IGluc3QgVGhlIGluc3RhbmNlIHdpdGggZWZmZWN0cyB0byBydW5cbiAgICogQHBhcmFtIHtPYmplY3R9IGVmZmVjdHMgT2JqZWN0IG1hcCBvZiBwcm9wZXJ0eS10by1BcnJheSBvZiBlZmZlY3RzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkZWR1cGVJZCBDb3VudGVyIHVzZWQgZm9yIGRlLWR1cGluZyBlZmZlY3RzXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wIE5hbWUgb2YgY2hhbmdlZCBwcm9wZXJ0eVxuICAgKiBAcGFyYW0geyp9IHByb3BzIENoYW5nZWQgcHJvcGVydGllc1xuICAgKiBAcGFyYW0geyp9IG9sZFByb3BzIE9sZCBwcm9wZXJ0aWVzXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IGhhc1BhdGhzIFRydWUgd2l0aCBgcHJvcHNgIGNvbnRhaW5zIG9uZSBvciBtb3JlIHBhdGhzXG4gICAqIEBwYXJhbSB7Kj19IGV4dHJhQXJncyBBZGRpdGlvbmFsIG1ldGFkYXRhIHRvIHBhc3MgdG8gZWZmZWN0IGZ1bmN0aW9uXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYW4gZWZmZWN0IHJhbiBmb3IgdGhpcyBwcm9wZXJ0eVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gcnVuRWZmZWN0c0ZvclByb3BlcnR5KGluc3QsIGVmZmVjdHMsIGRlZHVwZUlkLCBwcm9wLCBwcm9wcywgb2xkUHJvcHMsIGhhc1BhdGhzLCBleHRyYUFyZ3MpIHtcbiAgICBsZXQgcmFuID0gZmFsc2U7XG4gICAgbGV0IHJvb3RQcm9wZXJ0eSA9IGhhc1BhdGhzID8gUG9seW1lci5QYXRoLnJvb3QocHJvcCkgOiBwcm9wO1xuICAgIGxldCBmeHMgPSBlZmZlY3RzW3Jvb3RQcm9wZXJ0eV07XG4gICAgaWYgKGZ4cykge1xuICAgICAgZm9yIChsZXQgaT0wLCBsPWZ4cy5sZW5ndGgsIGZ4OyAoaTxsKSAmJiAoZng9ZnhzW2ldKTsgaSsrKSB7XG4gICAgICAgIGlmICgoIWZ4LmluZm8gfHwgZnguaW5mby5sYXN0UnVuICE9PSBkZWR1cGVJZCkgJiZcbiAgICAgICAgICAgICghaGFzUGF0aHMgfHwgcGF0aE1hdGNoZXNUcmlnZ2VyKHByb3AsIGZ4LnRyaWdnZXIpKSkge1xuICAgICAgICAgIGlmIChmeC5pbmZvKSB7XG4gICAgICAgICAgICBmeC5pbmZvLmxhc3RSdW4gPSBkZWR1cGVJZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnguZm4oaW5zdCwgcHJvcCwgcHJvcHMsIG9sZFByb3BzLCBmeC5pbmZvLCBoYXNQYXRocywgZXh0cmFBcmdzKTtcbiAgICAgICAgICByYW4gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByYW47XG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIGEgcHJvcGVydHkvcGF0aCB0aGF0IGhhcyBjaGFuZ2VkIG1hdGNoZXMgdGhlIHRyaWdnZXJcbiAgICogY3JpdGVyaWEgZm9yIGFuIGVmZmVjdC4gIEEgdHJpZ2dlciBpcyBhIGRlc2NyaXB0b3Igd2l0aCB0aGUgZm9sbG93aW5nXG4gICAqIHN0cnVjdHVyZSwgd2hpY2ggbWF0Y2hlcyB0aGUgZGVzY3JpcHRvcnMgcmV0dXJuZWQgZnJvbSBgcGFyc2VBcmdgLlxuICAgKiBlLmcuIGZvciBgZm9vLmJhci4qYDpcbiAgICogYGBgXG4gICAqIHRyaWdnZXI6IHtcbiAgICogICBuYW1lOiAnYS5iJyxcbiAgICogICBzdHJ1Y3R1cmVkOiB0cnVlLFxuICAgKiAgIHdpbGRjYXJkOiB0cnVlXG4gICAqIH1cbiAgICogYGBgXG4gICAqIElmIG5vIHRyaWdnZXIgaXMgZ2l2ZW4sIHRoZSBwYXRoIGlzIGRlZW1lZCB0byBtYXRjaC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggUGF0aCBvciBwcm9wZXJ0eSB0aGF0IGNoYW5nZWRcbiAgICogQHBhcmFtIHtEYXRhVHJpZ2dlcn0gdHJpZ2dlciBEZXNjcmlwdG9yXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIHBhdGggbWF0Y2hlZCB0aGUgdHJpZ2dlclxuICAgKi9cbiAgZnVuY3Rpb24gcGF0aE1hdGNoZXNUcmlnZ2VyKHBhdGgsIHRyaWdnZXIpIHtcbiAgICBpZiAodHJpZ2dlcikge1xuICAgICAgbGV0IHRyaWdnZXJQYXRoID0gdHJpZ2dlci5uYW1lO1xuICAgICAgcmV0dXJuICh0cmlnZ2VyUGF0aCA9PSBwYXRoKSB8fFxuICAgICAgICAodHJpZ2dlci5zdHJ1Y3R1cmVkICYmIFBvbHltZXIuUGF0aC5pc0FuY2VzdG9yKHRyaWdnZXJQYXRoLCBwYXRoKSkgfHxcbiAgICAgICAgKHRyaWdnZXIud2lsZGNhcmQgJiYgUG9seW1lci5QYXRoLmlzRGVzY2VuZGFudCh0cmlnZ2VyUGF0aCwgcGF0aCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSW1wbGVtZW50cyB0aGUgXCJvYnNlcnZlclwiIGVmZmVjdC5cbiAgICpcbiAgICogQ2FsbHMgdGhlIG1ldGhvZCB3aXRoIGBpbmZvLm1ldGhvZE5hbWVgIG9uIHRoZSBpbnN0YW5jZSwgcGFzc2luZyB0aGVcbiAgICogbmV3IGFuZCBvbGQgdmFsdWVzLlxuICAgKlxuICAgKiBAcGFyYW0geyFQcm9wZXJ0eUVmZmVjdHNUeXBlfSBpbnN0IFRoZSBpbnN0YW5jZSB0aGUgZWZmZWN0IHdpbGwgYmUgcnVuIG9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBOYW1lIG9mIHByb3BlcnR5XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBCYWcgb2YgY3VycmVudCBwcm9wZXJ0eSBjaGFuZ2VzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvbGRQcm9wcyBCYWcgb2YgcHJldmlvdXMgdmFsdWVzIGZvciBjaGFuZ2VkIHByb3BlcnRpZXNcbiAgICogQHBhcmFtIHs/fSBpbmZvIEVmZmVjdCBtZXRhZGF0YVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gcnVuT2JzZXJ2ZXJFZmZlY3QoaW5zdCwgcHJvcGVydHksIHByb3BzLCBvbGRQcm9wcywgaW5mbykge1xuICAgIGxldCBmbiA9IGluc3RbaW5mby5tZXRob2ROYW1lXTtcbiAgICBsZXQgY2hhbmdlZFByb3AgPSBpbmZvLnByb3BlcnR5O1xuICAgIGlmIChmbikge1xuICAgICAgZm4uY2FsbChpbnN0LCBpbnN0Ll9fZGF0YVtjaGFuZ2VkUHJvcF0sIG9sZFByb3BzW2NoYW5nZWRQcm9wXSk7XG4gICAgfSBlbHNlIGlmICghaW5mby5keW5hbWljRm4pIHtcbiAgICAgIGNvbnNvbGUud2Fybignb2JzZXJ2ZXIgbWV0aG9kIGAnICsgaW5mby5tZXRob2ROYW1lICsgJ2Agbm90IGRlZmluZWQnKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUnVucyBcIm5vdGlmeVwiIGVmZmVjdHMgZm9yIGEgc2V0IG9mIGNoYW5nZWQgcHJvcGVydGllcy5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgZGlmZmVycyBmcm9tIHRoZSBnZW5lcmljIGBydW5FZmZlY3RzYCBtZXRob2QgaW4gdGhhdCBpdFxuICAgKiB3aWxsIGRpc3BhdGNoIHBhdGggbm90aWZpY2F0aW9uIGV2ZW50cyBpbiB0aGUgY2FzZSB0aGF0IHRoZSBwcm9wZXJ0eVxuICAgKiBjaGFuZ2VkIHdhcyBhIHBhdGggYW5kIHRoZSByb290IHByb3BlcnR5IGZvciB0aGF0IHBhdGggZGlkbid0IGhhdmUgYVxuICAgKiBcIm5vdGlmeVwiIGVmZmVjdC4gIFRoaXMgaXMgdG8gbWFpbnRhaW4gMS4wIGJlaGF2aW9yIHRoYXQgZGlkIG5vdCByZXF1aXJlXG4gICAqIGBub3RpZnk6IHRydWVgIHRvIGVuc3VyZSBvYmplY3Qgc3ViLXByb3BlcnR5IG5vdGlmaWNhdGlvbnMgd2VyZVxuICAgKiBzZW50LlxuICAgKlxuICAgKiBAcGFyYW0geyFQcm9wZXJ0eUVmZmVjdHNUeXBlfSBpbnN0IFRoZSBpbnN0YW5jZSB3aXRoIGVmZmVjdHMgdG8gcnVuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBub3RpZnlQcm9wcyBCYWcgb2YgcHJvcGVydGllcyB0byBub3RpZnlcbiAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzIEJhZyBvZiBjdXJyZW50IHByb3BlcnR5IGNoYW5nZXNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9sZFByb3BzIEJhZyBvZiBwcmV2aW91cyB2YWx1ZXMgZm9yIGNoYW5nZWQgcHJvcGVydGllc1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhhc1BhdGhzIFRydWUgd2l0aCBgcHJvcHNgIGNvbnRhaW5zIG9uZSBvciBtb3JlIHBhdGhzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBydW5Ob3RpZnlFZmZlY3RzKGluc3QsIG5vdGlmeVByb3BzLCBwcm9wcywgb2xkUHJvcHMsIGhhc1BhdGhzKSB7XG4gICAgLy8gTm90aWZ5XG4gICAgbGV0IGZ4cyA9IGluc3RbVFlQRVMuTk9USUZZXTtcbiAgICBsZXQgbm90aWZpZWQ7XG4gICAgbGV0IGlkID0gZGVkdXBlSWQrKztcbiAgICAvLyBUcnkgbm9ybWFsIG5vdGlmeSBlZmZlY3RzOyBpZiBub25lLCBmYWxsIGJhY2sgdG8gdHJ5IHBhdGggbm90aWZpY2F0aW9uXG4gICAgZm9yIChsZXQgcHJvcCBpbiBub3RpZnlQcm9wcykge1xuICAgICAgaWYgKG5vdGlmeVByb3BzW3Byb3BdKSB7XG4gICAgICAgIGlmIChmeHMgJiYgcnVuRWZmZWN0c0ZvclByb3BlcnR5KGluc3QsIGZ4cywgaWQsIHByb3AsIHByb3BzLCBvbGRQcm9wcywgaGFzUGF0aHMpKSB7XG4gICAgICAgICAgbm90aWZpZWQgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGhhc1BhdGhzICYmIG5vdGlmeVBhdGgoaW5zdCwgcHJvcCwgcHJvcHMpKSB7XG4gICAgICAgICAgbm90aWZpZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIEZsdXNoIGhvc3QgaWYgd2UgYWN0dWFsbHkgbm90aWZpZWQgYW5kIGhvc3Qgd2FzIGJhdGNoaW5nXG4gICAgLy8gQW5kIHRoZSBob3N0IGhhcyBhbHJlYWR5IGluaXRpYWxpemVkIGNsaWVudHM7IHRoaXMgcHJldmVudHNcbiAgICAvLyBhbiBpc3N1ZSB3aXRoIGEgaG9zdCBvYnNlcnZpbmcgZGF0YSBjaGFuZ2VzIGJlZm9yZSBjbGllbnRzIGFyZSByZWFkeS5cbiAgICBsZXQgaG9zdDtcbiAgICBpZiAobm90aWZpZWQgJiYgKGhvc3QgPSBpbnN0Ll9fZGF0YUhvc3QpICYmIGhvc3QuX2ludmFsaWRhdGVQcm9wZXJ0aWVzKSB7XG4gICAgICBob3N0Ll9pbnZhbGlkYXRlUHJvcGVydGllcygpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNwYXRjaGVzIHtwcm9wZXJ0eX0tY2hhbmdlZCBldmVudHMgd2l0aCBwYXRoIGluZm9ybWF0aW9uIGluIHRoZSBkZXRhaWxcbiAgICogb2JqZWN0IHRvIGluZGljYXRlIGEgc3ViLXBhdGggb2YgdGhlIHByb3BlcnR5IHdhcyBjaGFuZ2VkLlxuICAgKlxuICAgKiBAcGFyYW0geyFQcm9wZXJ0eUVmZmVjdHNUeXBlfSBpbnN0IFRoZSBlbGVtZW50IGZyb20gd2hpY2ggdG8gZmlyZSB0aGUgZXZlbnRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggVGhlIHBhdGggdGhhdCB3YXMgY2hhbmdlZFxuICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgQmFnIG9mIGN1cnJlbnQgcHJvcGVydHkgY2hhbmdlc1xuICAgKiBAcmV0dXJuIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgdGhlIHBhdGggd2FzIG5vdGlmaWVkXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBub3RpZnlQYXRoKGluc3QsIHBhdGgsIHByb3BzKSB7XG4gICAgbGV0IHJvb3RQcm9wZXJ0eSA9IFBvbHltZXIuUGF0aC5yb290KHBhdGgpO1xuICAgIGlmIChyb290UHJvcGVydHkgIT09IHBhdGgpIHtcbiAgICAgIGxldCBldmVudE5hbWUgPSBQb2x5bWVyLkNhc2VNYXAuY2FtZWxUb0Rhc2hDYXNlKHJvb3RQcm9wZXJ0eSkgKyAnLWNoYW5nZWQnO1xuICAgICAgZGlzcGF0Y2hOb3RpZnlFdmVudChpbnN0LCBldmVudE5hbWUsIHByb3BzW3BhdGhdLCBwYXRoKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogRGlzcGF0Y2hlcyB7cHJvcGVydHl9LWNoYW5nZWQgZXZlbnRzIHRvIGluZGljYXRlIGEgcHJvcGVydHkgKG9yIHBhdGgpXG4gICAqIGNoYW5nZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7IVByb3BlcnR5RWZmZWN0c1R5cGV9IGluc3QgVGhlIGVsZW1lbnQgZnJvbSB3aGljaCB0byBmaXJlIHRoZSBldmVudFxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byBzZW5kICgne3Byb3BlcnR5fS1jaGFuZ2VkJylcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgb2YgdGhlIGNoYW5nZWQgcHJvcGVydHlcbiAgICogQHBhcmFtIHtzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkfSBwYXRoIElmIGEgc3ViLXBhdGggb2YgdGhpcyBwcm9wZXJ0eSBjaGFuZ2VkLCB0aGUgcGF0aFxuICAgKiAgIHRoYXQgY2hhbmdlZCAob3B0aW9uYWwpLlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAc3VwcHJlc3Mge2ludmFsaWRDYXN0c31cbiAgICovXG4gIGZ1bmN0aW9uIGRpc3BhdGNoTm90aWZ5RXZlbnQoaW5zdCwgZXZlbnROYW1lLCB2YWx1ZSwgcGF0aCkge1xuICAgIGxldCBkZXRhaWwgPSB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBxdWV1ZVByb3BlcnR5OiB0cnVlXG4gICAgfTtcbiAgICBpZiAocGF0aCkge1xuICAgICAgZGV0YWlsLnBhdGggPSBwYXRoO1xuICAgIH1cbiAgICAvKiogQHR5cGUgeyFIVE1MRWxlbWVudH0gKi8oaW5zdCkuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoZXZlbnROYW1lLCB7IGRldGFpbCB9KSk7XG4gIH1cblxuICAvKipcbiAgICogSW1wbGVtZW50cyB0aGUgXCJub3RpZnlcIiBlZmZlY3QuXG4gICAqXG4gICAqIERpc3BhdGNoZXMgYSBub24tYnViYmxpbmcgZXZlbnQgbmFtZWQgYGluZm8uZXZlbnROYW1lYCBvbiB0aGUgaW5zdGFuY2VcbiAgICogd2l0aCBhIGRldGFpbCBvYmplY3QgY29udGFpbmluZyB0aGUgbmV3IGB2YWx1ZWAuXG4gICAqXG4gICAqIEBwYXJhbSB7IVByb3BlcnR5RWZmZWN0c1R5cGV9IGluc3QgVGhlIGluc3RhbmNlIHRoZSBlZmZlY3Qgd2lsbCBiZSBydW4gb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IE5hbWUgb2YgcHJvcGVydHlcbiAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzIEJhZyBvZiBjdXJyZW50IHByb3BlcnR5IGNoYW5nZXNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9sZFByb3BzIEJhZyBvZiBwcmV2aW91cyB2YWx1ZXMgZm9yIGNoYW5nZWQgcHJvcGVydGllc1xuICAgKiBAcGFyYW0gez99IGluZm8gRWZmZWN0IG1ldGFkYXRhXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaGFzUGF0aHMgVHJ1ZSB3aXRoIGBwcm9wc2AgY29udGFpbnMgb25lIG9yIG1vcmUgcGF0aHNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIHJ1bk5vdGlmeUVmZmVjdChpbnN0LCBwcm9wZXJ0eSwgcHJvcHMsIG9sZFByb3BzLCBpbmZvLCBoYXNQYXRocykge1xuICAgIGxldCByb290UHJvcGVydHkgPSBoYXNQYXRocyA/IFBvbHltZXIuUGF0aC5yb290KHByb3BlcnR5KSA6IHByb3BlcnR5O1xuICAgIGxldCBwYXRoID0gcm9vdFByb3BlcnR5ICE9IHByb3BlcnR5ID8gcHJvcGVydHkgOiBudWxsO1xuICAgIGxldCB2YWx1ZSA9IHBhdGggPyBQb2x5bWVyLlBhdGguZ2V0KGluc3QsIHBhdGgpIDogaW5zdC5fX2RhdGFbcHJvcGVydHldO1xuICAgIGlmIChwYXRoICYmIHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhbHVlID0gcHJvcHNbcHJvcGVydHldOyAgLy8gc3BlY2lmaWNhbGx5IGZvciAuc3BsaWNlc1xuICAgIH1cbiAgICBkaXNwYXRjaE5vdGlmeUV2ZW50KGluc3QsIGluZm8uZXZlbnROYW1lLCB2YWx1ZSwgcGF0aCk7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlciBmdW5jdGlvbiBmb3IgMi13YXkgbm90aWZpY2F0aW9uIGV2ZW50cy4gUmVjZWl2ZXMgY29udGV4dFxuICAgKiBpbmZvcm1hdGlvbiBjYXB0dXJlZCBpbiB0aGUgYGFkZE5vdGlmeUxpc3RlbmVyYCBjbG9zdXJlIGZyb20gdGhlXG4gICAqIGBfX25vdGlmeUxpc3RlbmVyc2AgbWV0YWRhdGEuXG4gICAqXG4gICAqIFNldHMgdGhlIHZhbHVlIG9mIHRoZSBub3RpZmllZCBwcm9wZXJ0eSB0byB0aGUgaG9zdCBwcm9wZXJ0eSBvciBwYXRoLiAgSWZcbiAgICogdGhlIGV2ZW50IGNvbnRhaW5lZCBwYXRoIGluZm9ybWF0aW9uLCB0cmFuc2xhdGUgdGhhdCBwYXRoIHRvIHRoZSBob3N0XG4gICAqIHNjb3BlJ3MgbmFtZSBmb3IgdGhhdCBwYXRoIGZpcnN0LlxuICAgKlxuICAgKiBAcGFyYW0ge0N1c3RvbUV2ZW50fSBldmVudCBOb3RpZmljYXRpb24gZXZlbnQgKGUuZy4gJzxwcm9wZXJ0eT4tY2hhbmdlZCcpXG4gICAqIEBwYXJhbSB7IVByb3BlcnR5RWZmZWN0c1R5cGV9IGluc3QgSG9zdCBlbGVtZW50IGluc3RhbmNlIGhhbmRsaW5nIHRoZSBub3RpZmljYXRpb24gZXZlbnRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZyb21Qcm9wIENoaWxkIGVsZW1lbnQgcHJvcGVydHkgdGhhdCB3YXMgYm91bmRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRvUGF0aCBIb3N0IHByb3BlcnR5L3BhdGggdGhhdCB3YXMgYm91bmRcbiAgICogQHBhcmFtIHtib29sZWFufSBuZWdhdGUgV2hldGhlciB0aGUgYmluZGluZyB3YXMgbmVnYXRlZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gaGFuZGxlTm90aWZpY2F0aW9uKGV2ZW50LCBpbnN0LCBmcm9tUHJvcCwgdG9QYXRoLCBuZWdhdGUpIHtcbiAgICBsZXQgdmFsdWU7XG4gICAgbGV0IGRldGFpbCA9IC8qKiBAdHlwZSB7T2JqZWN0fSAqLyhldmVudC5kZXRhaWwpO1xuICAgIGxldCBmcm9tUGF0aCA9IGRldGFpbCAmJiBkZXRhaWwucGF0aDtcbiAgICBpZiAoZnJvbVBhdGgpIHtcbiAgICAgIHRvUGF0aCA9IFBvbHltZXIuUGF0aC50cmFuc2xhdGUoZnJvbVByb3AsIHRvUGF0aCwgZnJvbVBhdGgpO1xuICAgICAgdmFsdWUgPSBkZXRhaWwgJiYgZGV0YWlsLnZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSA9IGV2ZW50LnRhcmdldFtmcm9tUHJvcF07XG4gICAgfVxuICAgIHZhbHVlID0gbmVnYXRlID8gIXZhbHVlIDogdmFsdWU7XG4gICAgaWYgKCFpbnN0W1RZUEVTLlJFQURfT05MWV0gfHwgIWluc3RbVFlQRVMuUkVBRF9PTkxZXVt0b1BhdGhdKSB7XG4gICAgICBpZiAoaW5zdC5fc2V0UGVuZGluZ1Byb3BlcnR5T3JQYXRoKHRvUGF0aCwgdmFsdWUsIHRydWUsIEJvb2xlYW4oZnJvbVBhdGgpKVxuICAgICAgICAmJiAoIWRldGFpbCB8fCAhZGV0YWlsLnF1ZXVlUHJvcGVydHkpKSB7XG4gICAgICAgIGluc3QuX2ludmFsaWRhdGVQcm9wZXJ0aWVzKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEltcGxlbWVudHMgdGhlIFwicmVmbGVjdFwiIGVmZmVjdC5cbiAgICpcbiAgICogU2V0cyB0aGUgYXR0cmlidXRlIG5hbWVkIGBpbmZvLmF0dHJOYW1lYCB0byB0aGUgZ2l2ZW4gcHJvcGVydHkgdmFsdWUuXG4gICAqXG4gICAqIEBwYXJhbSB7IVByb3BlcnR5RWZmZWN0c1R5cGV9IGluc3QgVGhlIGluc3RhbmNlIHRoZSBlZmZlY3Qgd2lsbCBiZSBydW4gb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IE5hbWUgb2YgcHJvcGVydHlcbiAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzIEJhZyBvZiBjdXJyZW50IHByb3BlcnR5IGNoYW5nZXNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9sZFByb3BzIEJhZyBvZiBwcmV2aW91cyB2YWx1ZXMgZm9yIGNoYW5nZWQgcHJvcGVydGllc1xuICAgKiBAcGFyYW0gez99IGluZm8gRWZmZWN0IG1ldGFkYXRhXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBydW5SZWZsZWN0RWZmZWN0KGluc3QsIHByb3BlcnR5LCBwcm9wcywgb2xkUHJvcHMsIGluZm8pIHtcbiAgICBsZXQgdmFsdWUgPSBpbnN0Ll9fZGF0YVtwcm9wZXJ0eV07XG4gICAgaWYgKFBvbHltZXIuc2FuaXRpemVET01WYWx1ZSkge1xuICAgICAgdmFsdWUgPSBQb2x5bWVyLnNhbml0aXplRE9NVmFsdWUodmFsdWUsIGluZm8uYXR0ck5hbWUsICdhdHRyaWJ1dGUnLCAvKiogQHR5cGUge05vZGV9ICovKGluc3QpKTtcbiAgICB9XG4gICAgaW5zdC5fcHJvcGVydHlUb0F0dHJpYnV0ZShwcm9wZXJ0eSwgaW5mby5hdHRyTmFtZSwgdmFsdWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJ1bnMgXCJjb21wdXRlZFwiIGVmZmVjdHMgZm9yIGEgc2V0IG9mIGNoYW5nZWQgcHJvcGVydGllcy5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgZGlmZmVycyBmcm9tIHRoZSBnZW5lcmljIGBydW5FZmZlY3RzYCBtZXRob2QgaW4gdGhhdCBpdFxuICAgKiBjb250aW51ZXMgdG8gcnVuIGNvbXB1dGVkIGVmZmVjdHMgYmFzZWQgb24gdGhlIG91dHB1dCBvZiBlYWNoIHBhc3MgdW50aWxcbiAgICogdGhlcmUgYXJlIG5vIG1vcmUgbmV3bHkgY29tcHV0ZWQgcHJvcGVydGllcy4gIFRoaXMgZW5zdXJlcyB0aGF0IGFsbFxuICAgKiBwcm9wZXJ0aWVzIHRoYXQgd2lsbCBiZSBjb21wdXRlZCBieSB0aGUgaW5pdGlhbCBzZXQgb2YgY2hhbmdlcyBhcmVcbiAgICogY29tcHV0ZWQgYmVmb3JlIG90aGVyIGVmZmVjdHMgKGJpbmRpbmcgcHJvcGFnYXRpb24sIG9ic2VydmVycywgYW5kIG5vdGlmeSlcbiAgICogcnVuLlxuICAgKlxuICAgKiBAcGFyYW0geyFQcm9wZXJ0eUVmZmVjdHNUeXBlfSBpbnN0IFRoZSBpbnN0YW5jZSB0aGUgZWZmZWN0IHdpbGwgYmUgcnVuIG9uXG4gICAqIEBwYXJhbSB7IU9iamVjdH0gY2hhbmdlZFByb3BzIEJhZyBvZiBjaGFuZ2VkIHByb3BlcnRpZXNcbiAgICogQHBhcmFtIHshT2JqZWN0fSBvbGRQcm9wcyBCYWcgb2YgcHJldmlvdXMgdmFsdWVzIGZvciBjaGFuZ2VkIHByb3BlcnRpZXNcbiAgICogQHBhcmFtIHtib29sZWFufSBoYXNQYXRocyBUcnVlIHdpdGggYHByb3BzYCBjb250YWlucyBvbmUgb3IgbW9yZSBwYXRoc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gcnVuQ29tcHV0ZWRFZmZlY3RzKGluc3QsIGNoYW5nZWRQcm9wcywgb2xkUHJvcHMsIGhhc1BhdGhzKSB7XG4gICAgbGV0IGNvbXB1dGVFZmZlY3RzID0gaW5zdFtUWVBFUy5DT01QVVRFXTtcbiAgICBpZiAoY29tcHV0ZUVmZmVjdHMpIHtcbiAgICAgIGxldCBpbnB1dFByb3BzID0gY2hhbmdlZFByb3BzO1xuICAgICAgd2hpbGUgKHJ1bkVmZmVjdHMoaW5zdCwgY29tcHV0ZUVmZmVjdHMsIGlucHV0UHJvcHMsIG9sZFByb3BzLCBoYXNQYXRocykpIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihvbGRQcm9wcywgaW5zdC5fX2RhdGFPbGQpO1xuICAgICAgICBPYmplY3QuYXNzaWduKGNoYW5nZWRQcm9wcywgaW5zdC5fX2RhdGFQZW5kaW5nKTtcbiAgICAgICAgaW5wdXRQcm9wcyA9IGluc3QuX19kYXRhUGVuZGluZztcbiAgICAgICAgaW5zdC5fX2RhdGFQZW5kaW5nID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSW1wbGVtZW50cyB0aGUgXCJjb21wdXRlZCBwcm9wZXJ0eVwiIGVmZmVjdCBieSBydW5uaW5nIHRoZSBtZXRob2Qgd2l0aCB0aGVcbiAgICogdmFsdWVzIG9mIHRoZSBhcmd1bWVudHMgc3BlY2lmaWVkIGluIHRoZSBgaW5mb2Agb2JqZWN0IGFuZCBzZXR0aW5nIHRoZVxuICAgKiByZXR1cm4gdmFsdWUgdG8gdGhlIGNvbXB1dGVkIHByb3BlcnR5IHNwZWNpZmllZC5cbiAgICpcbiAgICogQHBhcmFtIHshUHJvcGVydHlFZmZlY3RzVHlwZX0gaW5zdCBUaGUgaW5zdGFuY2UgdGhlIGVmZmVjdCB3aWxsIGJlIHJ1biBvblxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgTmFtZSBvZiBwcm9wZXJ0eVxuICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgQmFnIG9mIGN1cnJlbnQgcHJvcGVydHkgY2hhbmdlc1xuICAgKiBAcGFyYW0ge09iamVjdH0gb2xkUHJvcHMgQmFnIG9mIHByZXZpb3VzIHZhbHVlcyBmb3IgY2hhbmdlZCBwcm9wZXJ0aWVzXG4gICAqIEBwYXJhbSB7P30gaW5mbyBFZmZlY3QgbWV0YWRhdGFcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIHJ1bkNvbXB1dGVkRWZmZWN0KGluc3QsIHByb3BlcnR5LCBwcm9wcywgb2xkUHJvcHMsIGluZm8pIHtcbiAgICBsZXQgcmVzdWx0ID0gcnVuTWV0aG9kRWZmZWN0KGluc3QsIHByb3BlcnR5LCBwcm9wcywgb2xkUHJvcHMsIGluZm8pO1xuICAgIGxldCBjb21wdXRlZFByb3AgPSBpbmZvLm1ldGhvZEluZm87XG4gICAgaWYgKGluc3QuX19kYXRhSGFzQWNjZXNzb3IgJiYgaW5zdC5fX2RhdGFIYXNBY2Nlc3Nvcltjb21wdXRlZFByb3BdKSB7XG4gICAgICBpbnN0Ll9zZXRQZW5kaW5nUHJvcGVydHkoY29tcHV0ZWRQcm9wLCByZXN1bHQsIHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnN0W2NvbXB1dGVkUHJvcF0gPSByZXN1bHQ7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbXB1dGVzIHBhdGggY2hhbmdlcyBiYXNlZCBvbiBwYXRoIGxpbmtzIHNldCB1cCB1c2luZyB0aGUgYGxpbmtQYXRoc2BcbiAgICogQVBJLlxuICAgKlxuICAgKiBAcGFyYW0geyFQcm9wZXJ0eUVmZmVjdHNUeXBlfSBpbnN0IFRoZSBpbnN0YW5jZSB3aG9zZSBwcm9wcyBhcmUgY2hhbmdpbmdcbiAgICogQHBhcmFtIHtzdHJpbmcgfCAhQXJyYXk8KHN0cmluZ3xudW1iZXIpPn0gcGF0aCBQYXRoIHRoYXQgaGFzIGNoYW5nZWRcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSBvZiBjaGFuZ2VkIHBhdGhcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIGNvbXB1dGVMaW5rZWRQYXRocyhpbnN0LCBwYXRoLCB2YWx1ZSkge1xuICAgIGxldCBsaW5rcyA9IGluc3QuX19kYXRhTGlua2VkUGF0aHM7XG4gICAgaWYgKGxpbmtzKSB7XG4gICAgICBsZXQgbGluaztcbiAgICAgIGZvciAobGV0IGEgaW4gbGlua3MpIHtcbiAgICAgICAgbGV0IGIgPSBsaW5rc1thXTtcbiAgICAgICAgaWYgKFBvbHltZXIuUGF0aC5pc0Rlc2NlbmRhbnQoYSwgcGF0aCkpIHtcbiAgICAgICAgICBsaW5rID0gUG9seW1lci5QYXRoLnRyYW5zbGF0ZShhLCBiLCBwYXRoKTtcbiAgICAgICAgICBpbnN0Ll9zZXRQZW5kaW5nUHJvcGVydHlPclBhdGgobGluaywgdmFsdWUsIHRydWUsIHRydWUpO1xuICAgICAgICB9IGVsc2UgaWYgKFBvbHltZXIuUGF0aC5pc0Rlc2NlbmRhbnQoYiwgcGF0aCkpIHtcbiAgICAgICAgICBsaW5rID0gUG9seW1lci5QYXRoLnRyYW5zbGF0ZShiLCBhLCBwYXRoKTtcbiAgICAgICAgICBpbnN0Ll9zZXRQZW5kaW5nUHJvcGVydHlPclBhdGgobGluaywgdmFsdWUsIHRydWUsIHRydWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gLS0gYmluZGluZ3MgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8qKlxuICAgKiBBZGRzIGJpbmRpbmcgbWV0YWRhdGEgdG8gdGhlIGN1cnJlbnQgYG5vZGVJbmZvYCwgYW5kIGJpbmRpbmcgZWZmZWN0c1xuICAgKiBmb3IgYWxsIHBhcnQgZGVwZW5kZW5jaWVzIHRvIGB0ZW1wbGF0ZUluZm9gLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb25zdHJ1Y3RvciBDbGFzcyB0aGF0IGBfcGFyc2VUZW1wbGF0ZWAgaXMgY3VycmVudGx5XG4gICAqICAgcnVubmluZyBvblxuICAgKiBAcGFyYW0ge1RlbXBsYXRlSW5mb30gdGVtcGxhdGVJbmZvIFRlbXBsYXRlIG1ldGFkYXRhIGZvciBjdXJyZW50IHRlbXBsYXRlXG4gICAqIEBwYXJhbSB7Tm9kZUluZm99IG5vZGVJbmZvIE5vZGUgbWV0YWRhdGEgZm9yIGN1cnJlbnQgdGVtcGxhdGUgbm9kZVxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2luZCBCaW5kaW5nIGtpbmQsIGVpdGhlciAncHJvcGVydHknLCAnYXR0cmlidXRlJywgb3IgJ3RleHQnXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0YXJnZXQgVGFyZ2V0IHByb3BlcnR5IG5hbWVcbiAgICogQHBhcmFtIHshQXJyYXk8IUJpbmRpbmdQYXJ0Pn0gcGFydHMgQXJyYXkgb2YgYmluZGluZyBwYXJ0IG1ldGFkYXRhXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gbGl0ZXJhbCBMaXRlcmFsIHRleHQgc3Vycm91bmRpbmcgYmluZGluZyBwYXJ0cyAoc3BlY2lmaWVkXG4gICAqICAgb25seSBmb3IgJ3Byb3BlcnR5JyBiaW5kaW5ncywgc2luY2UgdGhlc2UgbXVzdCBiZSBpbml0aWFsaXplZCBhcyBwYXJ0XG4gICAqICAgb2YgYm9vdC11cClcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIGFkZEJpbmRpbmcoY29uc3RydWN0b3IsIHRlbXBsYXRlSW5mbywgbm9kZUluZm8sIGtpbmQsIHRhcmdldCwgcGFydHMsIGxpdGVyYWwpIHtcbiAgICAvLyBDcmVhdGUgYmluZGluZyBtZXRhZGF0YSBhbmQgYWRkIHRvIG5vZGVJbmZvXG4gICAgbm9kZUluZm8uYmluZGluZ3MgPSBub2RlSW5mby5iaW5kaW5ncyB8fCBbXTtcbiAgICBsZXQgLyoqIEJpbmRpbmcgKi8gYmluZGluZyA9IHsga2luZCwgdGFyZ2V0LCBwYXJ0cywgbGl0ZXJhbCwgaXNDb21wb3VuZDogKHBhcnRzLmxlbmd0aCAhPT0gMSkgfTtcbiAgICBub2RlSW5mby5iaW5kaW5ncy5wdXNoKGJpbmRpbmcpO1xuICAgIC8vIEFkZCBsaXN0ZW5lciBpbmZvIHRvIGJpbmRpbmcgbWV0YWRhdGFcbiAgICBpZiAoc2hvdWxkQWRkTGlzdGVuZXIoYmluZGluZykpIHtcbiAgICAgIGxldCB7ZXZlbnQsIG5lZ2F0ZX0gPSBiaW5kaW5nLnBhcnRzWzBdO1xuICAgICAgYmluZGluZy5saXN0ZW5lckV2ZW50ID0gZXZlbnQgfHwgKENhc2VNYXAuY2FtZWxUb0Rhc2hDYXNlKHRhcmdldCkgKyAnLWNoYW5nZWQnKTtcbiAgICAgIGJpbmRpbmcubGlzdGVuZXJOZWdhdGUgPSBuZWdhdGU7XG4gICAgfVxuICAgIC8vIEFkZCBcInByb3BhZ2F0ZVwiIHByb3BlcnR5IGVmZmVjdHMgdG8gdGVtcGxhdGVJbmZvXG4gICAgbGV0IGluZGV4ID0gdGVtcGxhdGVJbmZvLm5vZGVJbmZvTGlzdC5sZW5ndGg7XG4gICAgZm9yIChsZXQgaT0wOyBpPGJpbmRpbmcucGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBwYXJ0ID0gYmluZGluZy5wYXJ0c1tpXTtcbiAgICAgIHBhcnQuY29tcG91bmRJbmRleCA9IGk7XG4gICAgICBhZGRFZmZlY3RGb3JCaW5kaW5nUGFydChjb25zdHJ1Y3RvciwgdGVtcGxhdGVJbmZvLCBiaW5kaW5nLCBwYXJ0LCBpbmRleCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgcHJvcGVydHkgZWZmZWN0cyB0byB0aGUgZ2l2ZW4gYHRlbXBsYXRlSW5mb2AgZm9yIHRoZSBnaXZlbiBiaW5kaW5nXG4gICAqIHBhcnQuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbnN0cnVjdG9yIENsYXNzIHRoYXQgYF9wYXJzZVRlbXBsYXRlYCBpcyBjdXJyZW50bHlcbiAgICogICBydW5uaW5nIG9uXG4gICAqIEBwYXJhbSB7VGVtcGxhdGVJbmZvfSB0ZW1wbGF0ZUluZm8gVGVtcGxhdGUgbWV0YWRhdGEgZm9yIGN1cnJlbnQgdGVtcGxhdGVcbiAgICogQHBhcmFtIHshQmluZGluZ30gYmluZGluZyBCaW5kaW5nIG1ldGFkYXRhXG4gICAqIEBwYXJhbSB7IUJpbmRpbmdQYXJ0fSBwYXJ0IEJpbmRpbmcgcGFydCBtZXRhZGF0YVxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSW5kZXggaW50byBgbm9kZUluZm9MaXN0YCBmb3IgdGhpcyBub2RlXG4gICAqL1xuICBmdW5jdGlvbiBhZGRFZmZlY3RGb3JCaW5kaW5nUGFydChjb25zdHJ1Y3RvciwgdGVtcGxhdGVJbmZvLCBiaW5kaW5nLCBwYXJ0LCBpbmRleCkge1xuICAgIGlmICghcGFydC5saXRlcmFsKSB7XG4gICAgICBpZiAoYmluZGluZy5raW5kID09PSAnYXR0cmlidXRlJyAmJiBiaW5kaW5nLnRhcmdldFswXSA9PT0gJy0nKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignQ2Fubm90IHNldCBhdHRyaWJ1dGUgJyArIGJpbmRpbmcudGFyZ2V0ICtcbiAgICAgICAgICAnIGJlY2F1c2UgXCItXCIgaXMgbm90IGEgdmFsaWQgYXR0cmlidXRlIHN0YXJ0aW5nIGNoYXJhY3RlcicpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IGRlcGVuZGVuY2llcyA9IHBhcnQuZGVwZW5kZW5jaWVzO1xuICAgICAgICBsZXQgaW5mbyA9IHsgaW5kZXgsIGJpbmRpbmcsIHBhcnQsIGV2YWx1YXRvcjogY29uc3RydWN0b3IgfTtcbiAgICAgICAgZm9yIChsZXQgaj0wOyBqPGRlcGVuZGVuY2llcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGxldCB0cmlnZ2VyID0gZGVwZW5kZW5jaWVzW2pdO1xuICAgICAgICAgIGlmICh0eXBlb2YgdHJpZ2dlciA9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdHJpZ2dlciA9IHBhcnNlQXJnKHRyaWdnZXIpO1xuICAgICAgICAgICAgdHJpZ2dlci53aWxkY2FyZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0cnVjdG9yLl9hZGRUZW1wbGF0ZVByb3BlcnR5RWZmZWN0KHRlbXBsYXRlSW5mbywgdHJpZ2dlci5yb290UHJvcGVydHksIHtcbiAgICAgICAgICAgIGZuOiBydW5CaW5kaW5nRWZmZWN0LFxuICAgICAgICAgICAgaW5mbywgdHJpZ2dlclxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEltcGxlbWVudHMgdGhlIFwiYmluZGluZ1wiIChwcm9wZXJ0eS9wYXRoIGJpbmRpbmcpIGVmZmVjdC5cbiAgICpcbiAgICogTm90ZSB0aGF0IGJpbmRpbmcgc3ludGF4IGlzIG92ZXJyaWRhYmxlIHZpYSBgX3BhcnNlQmluZGluZ3NgIGFuZFxuICAgKiBgX2V2YWx1YXRlQmluZGluZ2AuICBUaGlzIG1ldGhvZCB3aWxsIGNhbGwgYF9ldmFsdWF0ZUJpbmRpbmdgIGZvciBhbnlcbiAgICogbm9uLWxpdGVyYWwgcGFydHMgcmV0dXJuZWQgZnJvbSBgX3BhcnNlQmluZGluZ3NgLiAgSG93ZXZlcixcbiAgICogdGhlcmUgaXMgbm8gc3VwcG9ydCBmb3IgX3BhdGhfIGJpbmRpbmdzIHZpYSBjdXN0b20gYmluZGluZyBwYXJ0cyxcbiAgICogYXMgdGhpcyBpcyBzcGVjaWZpYyB0byBQb2x5bWVyJ3MgcGF0aCBiaW5kaW5nIHN5bnRheC5cbiAgICpcbiAgICogQHBhcmFtIHshUHJvcGVydHlFZmZlY3RzVHlwZX0gaW5zdCBUaGUgaW5zdGFuY2UgdGhlIGVmZmVjdCB3aWxsIGJlIHJ1biBvblxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBOYW1lIG9mIHByb3BlcnR5XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBCYWcgb2YgY3VycmVudCBwcm9wZXJ0eSBjaGFuZ2VzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvbGRQcm9wcyBCYWcgb2YgcHJldmlvdXMgdmFsdWVzIGZvciBjaGFuZ2VkIHByb3BlcnRpZXNcbiAgICogQHBhcmFtIHs/fSBpbmZvIEVmZmVjdCBtZXRhZGF0YVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhhc1BhdGhzIFRydWUgd2l0aCBgcHJvcHNgIGNvbnRhaW5zIG9uZSBvciBtb3JlIHBhdGhzXG4gICAqIEBwYXJhbSB7QXJyYXl9IG5vZGVMaXN0IExpc3Qgb2Ygbm9kZXMgYXNzb2NpYXRlZCB3aXRoIGBub2RlSW5mb0xpc3RgIHRlbXBsYXRlXG4gICAqICAgbWV0YWRhdGFcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIHJ1bkJpbmRpbmdFZmZlY3QoaW5zdCwgcGF0aCwgcHJvcHMsIG9sZFByb3BzLCBpbmZvLCBoYXNQYXRocywgbm9kZUxpc3QpIHtcbiAgICBsZXQgbm9kZSA9IG5vZGVMaXN0W2luZm8uaW5kZXhdO1xuICAgIGxldCBiaW5kaW5nID0gaW5mby5iaW5kaW5nO1xuICAgIGxldCBwYXJ0ID0gaW5mby5wYXJ0O1xuICAgIC8vIFN1YnBhdGggbm90aWZpY2F0aW9uOiB0cmFuc2Zvcm0gcGF0aCBhbmQgc2V0IHRvIGNsaWVudFxuICAgIC8vIGUuZy46IGZvbz1cInt7b2JqLnN1Yn19XCIsIHBhdGg6ICdvYmouc3ViLnByb3AnLCBzZXQgJ2Zvby5wcm9wJz1vYmouc3ViLnByb3BcbiAgICBpZiAoaGFzUGF0aHMgJiYgcGFydC5zb3VyY2UgJiYgKHBhdGgubGVuZ3RoID4gcGFydC5zb3VyY2UubGVuZ3RoKSAmJlxuICAgICAgICAoYmluZGluZy5raW5kID09ICdwcm9wZXJ0eScpICYmICFiaW5kaW5nLmlzQ29tcG91bmQgJiZcbiAgICAgICAgbm9kZS5fX2RhdGFIYXNBY2Nlc3NvciAmJiBub2RlLl9fZGF0YUhhc0FjY2Vzc29yW2JpbmRpbmcudGFyZ2V0XSkge1xuICAgICAgbGV0IHZhbHVlID0gcHJvcHNbcGF0aF07XG4gICAgICBwYXRoID0gUG9seW1lci5QYXRoLnRyYW5zbGF0ZShwYXJ0LnNvdXJjZSwgYmluZGluZy50YXJnZXQsIHBhdGgpO1xuICAgICAgaWYgKG5vZGUuX3NldFBlbmRpbmdQcm9wZXJ0eU9yUGF0aChwYXRoLCB2YWx1ZSwgZmFsc2UsIHRydWUpKSB7XG4gICAgICAgIGluc3QuX2VucXVldWVDbGllbnQobm9kZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCB2YWx1ZSA9IGluZm8uZXZhbHVhdG9yLl9ldmFsdWF0ZUJpbmRpbmcoaW5zdCwgcGFydCwgcGF0aCwgcHJvcHMsIG9sZFByb3BzLCBoYXNQYXRocyk7XG4gICAgICAvLyBQcm9wYWdhdGUgdmFsdWUgdG8gY2hpbGRcbiAgICAgIGFwcGx5QmluZGluZ1ZhbHVlKGluc3QsIG5vZGUsIGJpbmRpbmcsIHBhcnQsIHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgdmFsdWUgZm9yIGFuIFwiYmluZGluZ1wiIChiaW5kaW5nKSBlZmZlY3QgdG8gYSBub2RlLFxuICAgKiBlaXRoZXIgYXMgYSBwcm9wZXJ0eSBvciBhdHRyaWJ1dGUuXG4gICAqXG4gICAqIEBwYXJhbSB7IVByb3BlcnR5RWZmZWN0c1R5cGV9IGluc3QgVGhlIGluc3RhbmNlIG93bmluZyB0aGUgYmluZGluZyBlZmZlY3RcbiAgICogQHBhcmFtIHtOb2RlfSBub2RlIFRhcmdldCBub2RlIGZvciBiaW5kaW5nXG4gICAqIEBwYXJhbSB7IUJpbmRpbmd9IGJpbmRpbmcgQmluZGluZyBtZXRhZGF0YVxuICAgKiBAcGFyYW0geyFCaW5kaW5nUGFydH0gcGFydCBCaW5kaW5nIHBhcnQgbWV0YWRhdGFcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byBzZXRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIGFwcGx5QmluZGluZ1ZhbHVlKGluc3QsIG5vZGUsIGJpbmRpbmcsIHBhcnQsIHZhbHVlKSB7XG4gICAgdmFsdWUgPSBjb21wdXRlQmluZGluZ1ZhbHVlKG5vZGUsIHZhbHVlLCBiaW5kaW5nLCBwYXJ0KTtcbiAgICBpZiAoUG9seW1lci5zYW5pdGl6ZURPTVZhbHVlKSB7XG4gICAgICB2YWx1ZSA9IFBvbHltZXIuc2FuaXRpemVET01WYWx1ZSh2YWx1ZSwgYmluZGluZy50YXJnZXQsIGJpbmRpbmcua2luZCwgbm9kZSk7XG4gICAgfVxuICAgIGlmIChiaW5kaW5nLmtpbmQgPT0gJ2F0dHJpYnV0ZScpIHtcbiAgICAgIC8vIEF0dHJpYnV0ZSBiaW5kaW5nXG4gICAgICBpbnN0Ll92YWx1ZVRvTm9kZUF0dHJpYnV0ZSgvKiogQHR5cGUge0VsZW1lbnR9ICovKG5vZGUpLCB2YWx1ZSwgYmluZGluZy50YXJnZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBQcm9wZXJ0eSBiaW5kaW5nXG4gICAgICBsZXQgcHJvcCA9IGJpbmRpbmcudGFyZ2V0O1xuICAgICAgaWYgKG5vZGUuX19kYXRhSGFzQWNjZXNzb3IgJiYgbm9kZS5fX2RhdGFIYXNBY2Nlc3Nvcltwcm9wXSkge1xuICAgICAgICBpZiAoIW5vZGVbVFlQRVMuUkVBRF9PTkxZXSB8fCAhbm9kZVtUWVBFUy5SRUFEX09OTFldW3Byb3BdKSB7XG4gICAgICAgICAgaWYgKG5vZGUuX3NldFBlbmRpbmdQcm9wZXJ0eShwcm9wLCB2YWx1ZSkpIHtcbiAgICAgICAgICAgIGluc3QuX2VucXVldWVDbGllbnQobm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgIHtcbiAgICAgICAgaW5zdC5fc2V0VW5tYW5hZ2VkUHJvcGVydHlUb05vZGUobm9kZSwgcHJvcCwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUcmFuc2Zvcm1zIGFuIFwiYmluZGluZ1wiIGVmZmVjdCB2YWx1ZSBiYXNlZCBvbiBjb21wb3VuZCAmIG5lZ2F0aW9uXG4gICAqIGVmZmVjdCBtZXRhZGF0YSwgYXMgd2VsbCBhcyBoYW5kbGluZyBmb3Igc3BlY2lhbC1jYXNlIHByb3BlcnRpZXNcbiAgICpcbiAgICogQHBhcmFtIHtOb2RlfSBub2RlIE5vZGUgdGhlIHZhbHVlIHdpbGwgYmUgc2V0IHRvXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgdG8gc2V0XG4gICAqIEBwYXJhbSB7IUJpbmRpbmd9IGJpbmRpbmcgQmluZGluZyBtZXRhZGF0YVxuICAgKiBAcGFyYW0geyFCaW5kaW5nUGFydH0gcGFydCBCaW5kaW5nIHBhcnQgbWV0YWRhdGFcbiAgICogQHJldHVybiB7Kn0gVHJhbnNmb3JtZWQgdmFsdWUgdG8gc2V0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBjb21wdXRlQmluZGluZ1ZhbHVlKG5vZGUsIHZhbHVlLCBiaW5kaW5nLCBwYXJ0KSB7XG4gICAgaWYgKGJpbmRpbmcuaXNDb21wb3VuZCkge1xuICAgICAgbGV0IHN0b3JhZ2UgPSBub2RlLl9fZGF0YUNvbXBvdW5kU3RvcmFnZVtiaW5kaW5nLnRhcmdldF07XG4gICAgICBzdG9yYWdlW3BhcnQuY29tcG91bmRJbmRleF0gPSB2YWx1ZTtcbiAgICAgIHZhbHVlID0gc3RvcmFnZS5qb2luKCcnKTtcbiAgICB9XG4gICAgaWYgKGJpbmRpbmcua2luZCAhPT0gJ2F0dHJpYnV0ZScpIHtcbiAgICAgIC8vIFNvbWUgYnJvd3NlcnMgc2VyaWFsaXplIGB1bmRlZmluZWRgIHRvIGBcInVuZGVmaW5lZFwiYFxuICAgICAgaWYgKGJpbmRpbmcudGFyZ2V0ID09PSAndGV4dENvbnRlbnQnIHx8XG4gICAgICAgICAgKG5vZGUubG9jYWxOYW1lID09ICdpbnB1dCcgJiYgYmluZGluZy50YXJnZXQgPT0gJ3ZhbHVlJykpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZSA9PSB1bmRlZmluZWQgPyAnJyA6IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIGEgYmluZGluZydzIG1ldGFkYXRhIG1lZXRzIGFsbCB0aGUgcmVxdWlyZW1lbnRzIHRvIGFsbG93XG4gICAqIDItd2F5IGJpbmRpbmcsIGFuZCB0aGVyZWZvcmUgYSBgPHByb3BlcnR5Pi1jaGFuZ2VkYCBldmVudCBsaXN0ZW5lciBzaG91bGQgYmVcbiAgICogYWRkZWQ6XG4gICAqIC0gdXNlZCBjdXJseSBicmFjZXNcbiAgICogLSBpcyBhIHByb3BlcnR5IChub3QgYXR0cmlidXRlKSBiaW5kaW5nXG4gICAqIC0gaXMgbm90IGEgdGV4dENvbnRlbnQgYmluZGluZ1xuICAgKiAtIGlzIG5vdCBjb21wb3VuZFxuICAgKlxuICAgKiBAcGFyYW0geyFCaW5kaW5nfSBiaW5kaW5nIEJpbmRpbmcgbWV0YWRhdGFcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiAyLXdheSBsaXN0ZW5lciBzaG91bGQgYmUgYWRkZWRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIHNob3VsZEFkZExpc3RlbmVyKGJpbmRpbmcpIHtcbiAgICByZXR1cm4gQm9vbGVhbihiaW5kaW5nLnRhcmdldCkgJiZcbiAgICAgICAgICAgYmluZGluZy5raW5kICE9ICdhdHRyaWJ1dGUnICYmXG4gICAgICAgICAgIGJpbmRpbmcua2luZCAhPSAndGV4dCcgJiZcbiAgICAgICAgICAgIWJpbmRpbmcuaXNDb21wb3VuZCAmJlxuICAgICAgICAgICBiaW5kaW5nLnBhcnRzWzBdLm1vZGUgPT09ICd7JztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXR1cCBjb21wb3VuZCBiaW5kaW5nIHN0b3JhZ2Ugc3RydWN0dXJlcywgbm90aWZ5IGxpc3RlbmVycywgYW5kIGRhdGFIb3N0XG4gICAqIHJlZmVyZW5jZXMgb250byB0aGUgYm91bmQgbm9kZUxpc3QuXG4gICAqXG4gICAqIEBwYXJhbSB7IVByb3BlcnR5RWZmZWN0c1R5cGV9IGluc3QgSW5zdGFuY2UgdGhhdCBiYXMgYmVlbiBwcmV2aW91c2x5IGJvdW5kXG4gICAqIEBwYXJhbSB7VGVtcGxhdGVJbmZvfSB0ZW1wbGF0ZUluZm8gVGVtcGxhdGUgbWV0YWRhdGFcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIHNldHVwQmluZGluZ3MoaW5zdCwgdGVtcGxhdGVJbmZvKSB7XG4gICAgLy8gU2V0dXAgY29tcG91bmQgc3RvcmFnZSwgZGF0YUhvc3QsIGFuZCBub3RpZnkgbGlzdGVuZXJzXG4gICAgbGV0IHtub2RlTGlzdCwgbm9kZUluZm9MaXN0fSA9IHRlbXBsYXRlSW5mbztcbiAgICBpZiAobm9kZUluZm9MaXN0Lmxlbmd0aCkge1xuICAgICAgZm9yIChsZXQgaT0wOyBpIDwgbm9kZUluZm9MaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBpbmZvID0gbm9kZUluZm9MaXN0W2ldO1xuICAgICAgICBsZXQgbm9kZSA9IG5vZGVMaXN0W2ldO1xuICAgICAgICBsZXQgYmluZGluZ3MgPSBpbmZvLmJpbmRpbmdzO1xuICAgICAgICBpZiAoYmluZGluZ3MpIHtcbiAgICAgICAgICBmb3IgKGxldCBpPTA7IGk8YmluZGluZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBiaW5kaW5nID0gYmluZGluZ3NbaV07XG4gICAgICAgICAgICBzZXR1cENvbXBvdW5kU3RvcmFnZShub2RlLCBiaW5kaW5nKTtcbiAgICAgICAgICAgIGFkZE5vdGlmeUxpc3RlbmVyKG5vZGUsIGluc3QsIGJpbmRpbmcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBub2RlLl9fZGF0YUhvc3QgPSBpbnN0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyBgX19kYXRhQ29tcG91bmRTdG9yYWdlYCBsb2NhbCBzdG9yYWdlIG9uIGEgYm91bmQgbm9kZSB3aXRoXG4gICAqIGluaXRpYWwgbGl0ZXJhbCBkYXRhIGZvciBjb21wb3VuZCBiaW5kaW5ncywgYW5kIHNldHMgdGhlIGpvaW5lZFxuICAgKiBsaXRlcmFsIHBhcnRzIHRvIHRoZSBib3VuZCBwcm9wZXJ0eS5cbiAgICpcbiAgICogV2hlbiBjaGFuZ2VzIHRvIGNvbXBvdW5kIHBhcnRzIG9jY3VyLCB0aGV5IGFyZSBmaXJzdCBzZXQgaW50byB0aGUgY29tcG91bmRcbiAgICogc3RvcmFnZSBhcnJheSBmb3IgdGhhdCBwcm9wZXJ0eSwgYW5kIHRoZW4gdGhlIGFycmF5IGlzIGpvaW5lZCB0byByZXN1bHQgaW5cbiAgICogdGhlIGZpbmFsIHZhbHVlIHNldCB0byB0aGUgcHJvcGVydHkvYXR0cmlidXRlLlxuICAgKlxuICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgQm91bmQgbm9kZSB0byBpbml0aWFsaXplXG4gICAqIEBwYXJhbSB7QmluZGluZ30gYmluZGluZyBCaW5kaW5nIG1ldGFkYXRhXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBzZXR1cENvbXBvdW5kU3RvcmFnZShub2RlLCBiaW5kaW5nKSB7XG4gICAgaWYgKGJpbmRpbmcuaXNDb21wb3VuZCkge1xuICAgICAgLy8gQ3JlYXRlIGNvbXBvdW5kIHN0b3JhZ2UgbWFwXG4gICAgICBsZXQgc3RvcmFnZSA9IG5vZGUuX19kYXRhQ29tcG91bmRTdG9yYWdlIHx8XG4gICAgICAgIChub2RlLl9fZGF0YUNvbXBvdW5kU3RvcmFnZSA9IHt9KTtcbiAgICAgIGxldCBwYXJ0cyA9IGJpbmRpbmcucGFydHM7XG4gICAgICAvLyBDb3B5IGxpdGVyYWxzIGZyb20gcGFydHMgaW50byBzdG9yYWdlIGZvciB0aGlzIGJpbmRpbmdcbiAgICAgIGxldCBsaXRlcmFscyA9IG5ldyBBcnJheShwYXJ0cy5sZW5ndGgpO1xuICAgICAgZm9yIChsZXQgaj0wOyBqPHBhcnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGxpdGVyYWxzW2pdID0gcGFydHNbal0ubGl0ZXJhbDtcbiAgICAgIH1cbiAgICAgIGxldCB0YXJnZXQgPSBiaW5kaW5nLnRhcmdldDtcbiAgICAgIHN0b3JhZ2VbdGFyZ2V0XSA9IGxpdGVyYWxzO1xuICAgICAgLy8gQ29uZmlndXJlIHByb3BlcnRpZXMgd2l0aCB0aGVpciBsaXRlcmFsIHBhcnRzXG4gICAgICBpZiAoYmluZGluZy5saXRlcmFsICYmIGJpbmRpbmcua2luZCA9PSAncHJvcGVydHknKSB7XG4gICAgICAgIG5vZGVbdGFyZ2V0XSA9IGJpbmRpbmcubGl0ZXJhbDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhIDItd2F5IGJpbmRpbmcgbm90aWZpY2F0aW9uIGV2ZW50IGxpc3RlbmVyIHRvIHRoZSBub2RlIHNwZWNpZmllZFxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gbm9kZSBDaGlsZCBlbGVtZW50IHRvIGFkZCBsaXN0ZW5lciB0b1xuICAgKiBAcGFyYW0geyFQcm9wZXJ0eUVmZmVjdHNUeXBlfSBpbnN0IEhvc3QgZWxlbWVudCBpbnN0YW5jZSB0byBoYW5kbGUgbm90aWZpY2F0aW9uIGV2ZW50XG4gICAqIEBwYXJhbSB7QmluZGluZ30gYmluZGluZyBCaW5kaW5nIG1ldGFkYXRhXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBhZGROb3RpZnlMaXN0ZW5lcihub2RlLCBpbnN0LCBiaW5kaW5nKSB7XG4gICAgaWYgKGJpbmRpbmcubGlzdGVuZXJFdmVudCkge1xuICAgICAgbGV0IHBhcnQgPSBiaW5kaW5nLnBhcnRzWzBdO1xuICAgICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKGJpbmRpbmcubGlzdGVuZXJFdmVudCwgZnVuY3Rpb24oZSkge1xuICAgICAgICBoYW5kbGVOb3RpZmljYXRpb24oZSwgaW5zdCwgYmluZGluZy50YXJnZXQsIHBhcnQuc291cmNlLCBwYXJ0Lm5lZ2F0ZSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvLyAtLSBmb3IgbWV0aG9kLWJhc2VkIGVmZmVjdHMgKGNvbXBsZXhPYnNlcnZlciAmIGNvbXB1dGVkKSAtLS0tLS0tLS0tLS0tLVxuXG4gIC8qKlxuICAgKiBBZGRzIHByb3BlcnR5IGVmZmVjdHMgZm9yIGVhY2ggYXJndW1lbnQgaW4gdGhlIG1ldGhvZCBzaWduYXR1cmUgKGFuZFxuICAgKiBvcHRpb25hbGx5LCBmb3IgdGhlIG1ldGhvZCBuYW1lIGlmIGBkeW5hbWljYCBpcyB0cnVlKSB0aGF0IGNhbGxzIHRoZVxuICAgKiBwcm92aWRlZCBlZmZlY3QgZnVuY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7RWxlbWVudCB8IE9iamVjdH0gbW9kZWwgUHJvdG90eXBlIG9yIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7IU1ldGhvZFNpZ25hdHVyZX0gc2lnIE1ldGhvZCBzaWduYXR1cmUgbWV0YWRhdGFcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgVHlwZSBvZiBwcm9wZXJ0eSBlZmZlY3QgdG8gYWRkXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGVmZmVjdEZuIEZ1bmN0aW9uIHRvIHJ1biB3aGVuIGFyZ3VtZW50cyBjaGFuZ2VcbiAgICogQHBhcmFtIHsqPX0gbWV0aG9kSW5mbyBFZmZlY3Qtc3BlY2lmaWMgaW5mb3JtYXRpb24gdG8gYmUgaW5jbHVkZWQgaW5cbiAgICogICBtZXRob2QgZWZmZWN0IG1ldGFkYXRhXG4gICAqIEBwYXJhbSB7Ym9vbGVhbnxPYmplY3Q9fSBkeW5hbWljRm4gQm9vbGVhbiBvciBvYmplY3QgbWFwIGluZGljYXRpbmcgd2hldGhlclxuICAgKiAgIG1ldGhvZCBuYW1lcyBzaG91bGQgYmUgaW5jbHVkZWQgYXMgYSBkZXBlbmRlbmN5IHRvIHRoZSBlZmZlY3QuIE5vdGUsXG4gICAqICAgZGVmYXVsdHMgdG8gdHJ1ZSBpZiB0aGUgc2lnbmF0dXJlIGlzIHN0YXRpYyAoc2lnLnN0YXRpYyBpcyB0cnVlKS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIGNyZWF0ZU1ldGhvZEVmZmVjdChtb2RlbCwgc2lnLCB0eXBlLCBlZmZlY3RGbiwgbWV0aG9kSW5mbywgZHluYW1pY0ZuKSB7XG4gICAgZHluYW1pY0ZuID0gc2lnLnN0YXRpYyB8fCAoZHluYW1pY0ZuICYmXG4gICAgICAodHlwZW9mIGR5bmFtaWNGbiAhPT0gJ29iamVjdCcgfHwgZHluYW1pY0ZuW3NpZy5tZXRob2ROYW1lXSkpO1xuICAgIGxldCBpbmZvID0ge1xuICAgICAgbWV0aG9kTmFtZTogc2lnLm1ldGhvZE5hbWUsXG4gICAgICBhcmdzOiBzaWcuYXJncyxcbiAgICAgIG1ldGhvZEluZm8sXG4gICAgICBkeW5hbWljRm5cbiAgICB9O1xuICAgIGZvciAobGV0IGk9MCwgYXJnOyAoaTxzaWcuYXJncy5sZW5ndGgpICYmIChhcmc9c2lnLmFyZ3NbaV0pOyBpKyspIHtcbiAgICAgIGlmICghYXJnLmxpdGVyYWwpIHtcbiAgICAgICAgbW9kZWwuX2FkZFByb3BlcnR5RWZmZWN0KGFyZy5yb290UHJvcGVydHksIHR5cGUsIHtcbiAgICAgICAgICBmbjogZWZmZWN0Rm4sIGluZm86IGluZm8sIHRyaWdnZXI6IGFyZ1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGR5bmFtaWNGbikge1xuICAgICAgbW9kZWwuX2FkZFByb3BlcnR5RWZmZWN0KHNpZy5tZXRob2ROYW1lLCB0eXBlLCB7XG4gICAgICAgIGZuOiBlZmZlY3RGbiwgaW5mbzogaW5mb1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENhbGxzIGEgbWV0aG9kIHdpdGggYXJndW1lbnRzIG1hcnNoYWxlZCBmcm9tIHByb3BlcnRpZXMgb24gdGhlIGluc3RhbmNlXG4gICAqIGJhc2VkIG9uIHRoZSBtZXRob2Qgc2lnbmF0dXJlIGNvbnRhaW5lZCBpbiB0aGUgZWZmZWN0IG1ldGFkYXRhLlxuICAgKlxuICAgKiBNdWx0aS1wcm9wZXJ0eSBvYnNlcnZlcnMsIGNvbXB1dGVkIHByb3BlcnRpZXMsIGFuZCBpbmxpbmUgY29tcHV0aW5nXG4gICAqIGZ1bmN0aW9ucyBjYWxsIHRoaXMgZnVuY3Rpb24gdG8gaW52b2tlIHRoZSBtZXRob2QsIHRoZW4gdXNlIHRoZSByZXR1cm5cbiAgICogdmFsdWUgYWNjb3JkaW5nbHkuXG4gICAqXG4gICAqIEBwYXJhbSB7IVByb3BlcnR5RWZmZWN0c1R5cGV9IGluc3QgVGhlIGluc3RhbmNlIHRoZSBlZmZlY3Qgd2lsbCBiZSBydW4gb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IE5hbWUgb2YgcHJvcGVydHlcbiAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzIEJhZyBvZiBjdXJyZW50IHByb3BlcnR5IGNoYW5nZXNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9sZFByb3BzIEJhZyBvZiBwcmV2aW91cyB2YWx1ZXMgZm9yIGNoYW5nZWQgcHJvcGVydGllc1xuICAgKiBAcGFyYW0gez99IGluZm8gRWZmZWN0IG1ldGFkYXRhXG4gICAqIEByZXR1cm4geyp9IFJldHVybnMgdGhlIHJldHVybiB2YWx1ZSBmcm9tIHRoZSBtZXRob2QgaW52b2NhdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gcnVuTWV0aG9kRWZmZWN0KGluc3QsIHByb3BlcnR5LCBwcm9wcywgb2xkUHJvcHMsIGluZm8pIHtcbiAgICAvLyBJbnN0YW5jZXMgY2FuIG9wdGlvbmFsbHkgaGF2ZSBhIF9tZXRob2RIb3N0IHdoaWNoIGFsbG93cyByZWRpcmVjdGluZyB3aGVyZVxuICAgIC8vIHRvIGZpbmQgbWV0aG9kcy4gQ3VycmVudGx5IHVzZWQgYnkgYHRlbXBsYXRpemVgLlxuICAgIGxldCBjb250ZXh0ID0gaW5zdC5fbWV0aG9kSG9zdCB8fCBpbnN0O1xuICAgIGxldCBmbiA9IGNvbnRleHRbaW5mby5tZXRob2ROYW1lXTtcbiAgICBpZiAoZm4pIHtcbiAgICAgIGxldCBhcmdzID0gbWFyc2hhbEFyZ3MoaW5zdC5fX2RhdGEsIGluZm8uYXJncywgcHJvcGVydHksIHByb3BzKTtcbiAgICAgIHJldHVybiBmbi5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICB9IGVsc2UgaWYgKCFpbmZvLmR5bmFtaWNGbikge1xuICAgICAgY29uc29sZS53YXJuKCdtZXRob2QgYCcgKyBpbmZvLm1ldGhvZE5hbWUgKyAnYCBub3QgZGVmaW5lZCcpO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGVtcHR5QXJyYXkgPSBbXTtcblxuICAvLyBSZWd1bGFyIGV4cHJlc3Npb25zIHVzZWQgZm9yIGJpbmRpbmdcbiAgY29uc3QgSURFTlQgID0gJyg/OicgKyAnW2EtekEtWl8kXVtcXFxcdy46JFxcXFwtKl0qJyArICcpJztcbiAgY29uc3QgTlVNQkVSID0gJyg/OicgKyAnWy0rXT9bMC05XSpcXFxcLj9bMC05XSsoPzpbZUVdWy0rXT9bMC05XSspPycgKyAnKSc7XG4gIGNvbnN0IFNRVU9URV9TVFJJTkcgPSAnKD86JyArICdcXCcoPzpbXlxcJ1xcXFxcXFxcXXxcXFxcXFxcXC4pKlxcJycgKyAnKSc7XG4gIGNvbnN0IERRVU9URV9TVFJJTkcgPSAnKD86JyArICdcIig/OlteXCJcXFxcXFxcXF18XFxcXFxcXFwuKSpcIicgKyAnKSc7XG4gIGNvbnN0IFNUUklORyA9ICcoPzonICsgU1FVT1RFX1NUUklORyArICd8JyArIERRVU9URV9TVFJJTkcgKyAnKSc7XG4gIGNvbnN0IEFSR1VNRU5UID0gJyg/OignICsgSURFTlQgKyAnfCcgKyBOVU1CRVIgKyAnfCcgKyAgU1RSSU5HICsgJylcXFxccyonICsgJyknO1xuICBjb25zdCBBUkdVTUVOVFMgPSAnKD86JyArIEFSR1VNRU5UICsgJyg/OixcXFxccyonICsgQVJHVU1FTlQgKyAnKSonICsgJyknO1xuICBjb25zdCBBUkdVTUVOVF9MSVNUID0gJyg/OicgKyAnXFxcXChcXFxccyonICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyg/OicgKyBBUkdVTUVOVFMgKyAnPycgKyAnKScgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1xcXFwpXFxcXHMqJyArICcpJztcbiAgY29uc3QgQklORElORyA9ICcoJyArIElERU5UICsgJ1xcXFxzKicgKyBBUkdVTUVOVF9MSVNUICsgJz8nICsgJyknOyAvLyBHcm91cCAzXG4gIGNvbnN0IE9QRU5fQlJBQ0tFVCA9ICcoXFxcXFtcXFxcW3x7eyknICsgJ1xcXFxzKic7XG4gIGNvbnN0IENMT1NFX0JSQUNLRVQgPSAnKD86XV18fX0pJztcbiAgY29uc3QgTkVHQVRFID0gJyg/OighKVxcXFxzKik/JzsgLy8gR3JvdXAgMlxuICBjb25zdCBFWFBSRVNTSU9OID0gT1BFTl9CUkFDS0VUICsgTkVHQVRFICsgQklORElORyArIENMT1NFX0JSQUNLRVQ7XG4gIGNvbnN0IGJpbmRpbmdSZWdleCA9IG5ldyBSZWdFeHAoRVhQUkVTU0lPTiwgXCJnXCIpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBzdHJpbmcgZnJvbSBiaW5kaW5nIHBhcnRzIG9mIGFsbCB0aGUgbGl0ZXJhbCBwYXJ0c1xuICAgKlxuICAgKiBAcGFyYW0geyFBcnJheTxCaW5kaW5nUGFydD59IHBhcnRzIEFsbCBwYXJ0cyB0byBzdHJpbmdpZnlcbiAgICogQHJldHVybiB7c3RyaW5nfSBTdHJpbmcgbWFkZSBmcm9tIHRoZSBsaXRlcmFsIHBhcnRzXG4gICAqL1xuICBmdW5jdGlvbiBsaXRlcmFsRnJvbVBhcnRzKHBhcnRzKSB7XG4gICAgbGV0IHMgPSAnJztcbiAgICBmb3IgKGxldCBpPTA7IGk8cGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBsaXRlcmFsID0gcGFydHNbaV0ubGl0ZXJhbDtcbiAgICAgIHMgKz0gbGl0ZXJhbCB8fCAnJztcbiAgICB9XG4gICAgcmV0dXJuIHM7XG4gIH1cblxuICAvKipcbiAgICogUGFyc2VzIGFuIGV4cHJlc3Npb24gc3RyaW5nIGZvciBhIG1ldGhvZCBzaWduYXR1cmUsIGFuZCByZXR1cm5zIGEgbWV0YWRhdGFcbiAgICogZGVzY3JpYmluZyB0aGUgbWV0aG9kIGluIHRlcm1zIG9mIGBtZXRob2ROYW1lYCwgYHN0YXRpY2AgKHdoZXRoZXIgYWxsIHRoZVxuICAgKiBhcmd1bWVudHMgYXJlIGxpdGVyYWxzKSwgYW5kIGFuIGFycmF5IG9mIGBhcmdzYFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXhwcmVzc2lvbiBUaGUgZXhwcmVzc2lvbiB0byBwYXJzZVxuICAgKiBAcmV0dXJuIHs/TWV0aG9kU2lnbmF0dXJlfSBUaGUgbWV0aG9kIG1ldGFkYXRhIG9iamVjdCBpZiBhIG1ldGhvZCBleHByZXNzaW9uIHdhc1xuICAgKiAgIGZvdW5kLCBvdGhlcndpc2UgYHVuZGVmaW5lZGBcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIHBhcnNlTWV0aG9kKGV4cHJlc3Npb24pIHtcbiAgICAvLyB0cmllcyB0byBtYXRjaCB2YWxpZCBqYXZhc2NyaXB0IHByb3BlcnR5IG5hbWVzXG4gICAgbGV0IG0gPSBleHByZXNzaW9uLm1hdGNoKC8oW15cXHNdKz8pXFwoKFtcXHNcXFNdKilcXCkvKTtcbiAgICBpZiAobSkge1xuICAgICAgbGV0IG1ldGhvZE5hbWUgPSBtWzFdO1xuICAgICAgbGV0IHNpZyA9IHsgbWV0aG9kTmFtZSwgc3RhdGljOiB0cnVlLCBhcmdzOiBlbXB0eUFycmF5IH07XG4gICAgICBpZiAobVsyXS50cmltKCkpIHtcbiAgICAgICAgLy8gcmVwbGFjZSBlc2NhcGVkIGNvbW1hcyB3aXRoIGNvbW1hIGVudGl0eSwgc3BsaXQgb24gdW4tZXNjYXBlZCBjb21tYXNcbiAgICAgICAgbGV0IGFyZ3MgPSBtWzJdLnJlcGxhY2UoL1xcXFwsL2csICcmY29tbWE7Jykuc3BsaXQoJywnKTtcbiAgICAgICAgcmV0dXJuIHBhcnNlQXJncyhhcmdzLCBzaWcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHNpZztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcbiAgICogUGFyc2VzIGFuIGFycmF5IG9mIGFyZ3VtZW50cyBhbmQgc2V0cyB0aGUgYGFyZ3NgIHByb3BlcnR5IG9mIHRoZSBzdXBwbGllZFxuICAgKiBzaWduYXR1cmUgbWV0YWRhdGEgb2JqZWN0LiBTZXRzIHRoZSBgc3RhdGljYCBwcm9wZXJ0eSB0byBmYWxzZSBpZiBhbnlcbiAgICogYXJndW1lbnQgaXMgYSBub24tbGl0ZXJhbC5cbiAgICpcbiAgICogQHBhcmFtIHshQXJyYXk8c3RyaW5nPn0gYXJnTGlzdCBBcnJheSBvZiBhcmd1bWVudCBuYW1lc1xuICAgKiBAcGFyYW0geyFNZXRob2RTaWduYXR1cmV9IHNpZyBNZXRob2Qgc2lnbmF0dXJlIG1ldGFkYXRhIG9iamVjdFxuICAgKiBAcmV0dXJuIHshTWV0aG9kU2lnbmF0dXJlfSBUaGUgdXBkYXRlZCBzaWduYXR1cmUgbWV0YWRhdGEgb2JqZWN0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBwYXJzZUFyZ3MoYXJnTGlzdCwgc2lnKSB7XG4gICAgc2lnLmFyZ3MgPSBhcmdMaXN0Lm1hcChmdW5jdGlvbihyYXdBcmcpIHtcbiAgICAgIGxldCBhcmcgPSBwYXJzZUFyZyhyYXdBcmcpO1xuICAgICAgaWYgKCFhcmcubGl0ZXJhbCkge1xuICAgICAgICBzaWcuc3RhdGljID0gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJnO1xuICAgIH0sIHRoaXMpO1xuICAgIHJldHVybiBzaWc7XG4gIH1cblxuICAvKipcbiAgICogUGFyc2VzIGFuIGluZGl2aWR1YWwgYXJndW1lbnQsIGFuZCByZXR1cm5zIGFuIGFyZ3VtZW50IG1ldGFkYXRhIG9iamVjdFxuICAgKiB3aXRoIHRoZSBmb2xsb3dpbmcgZmllbGRzOlxuICAgKlxuICAgKiAgIHtcbiAgICogICAgIHZhbHVlOiAncHJvcCcsICAgICAgICAvLyBwcm9wZXJ0eS9wYXRoIG9yIGxpdGVyYWwgdmFsdWVcbiAgICogICAgIGxpdGVyYWw6IGZhbHNlLCAgICAgICAvLyB3aGV0aGVyIGFyZ3VtZW50IGlzIGEgbGl0ZXJhbFxuICAgKiAgICAgc3RydWN0dXJlZDogZmFsc2UsICAgIC8vIHdoZXRoZXIgdGhlIHByb3BlcnR5IGlzIGEgcGF0aFxuICAgKiAgICAgcm9vdFByb3BlcnR5OiAncHJvcCcsIC8vIHRoZSByb290IHByb3BlcnR5IG9mIHRoZSBwYXRoXG4gICAqICAgICB3aWxkY2FyZDogZmFsc2UgICAgICAgLy8gd2hldGhlciB0aGUgYXJndW1lbnQgd2FzIGEgd2lsZGNhcmQgJy4qJyBwYXRoXG4gICAqICAgfVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmF3QXJnIFRoZSBzdHJpbmcgdmFsdWUgb2YgdGhlIGFyZ3VtZW50XG4gICAqIEByZXR1cm4geyFNZXRob2RBcmd9IEFyZ3VtZW50IG1ldGFkYXRhIG9iamVjdFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gcGFyc2VBcmcocmF3QXJnKSB7XG4gICAgLy8gY2xlYW4gdXAgd2hpdGVzcGFjZVxuICAgIGxldCBhcmcgPSByYXdBcmcudHJpbSgpXG4gICAgICAvLyByZXBsYWNlIGNvbW1hIGVudGl0eSB3aXRoIGNvbW1hXG4gICAgICAucmVwbGFjZSgvJmNvbW1hOy9nLCAnLCcpXG4gICAgICAvLyByZXBhaXIgZXh0cmEgZXNjYXBlIHNlcXVlbmNlczsgbm90ZSBvbmx5IGNvbW1hcyBzdHJpY3RseSBuZWVkXG4gICAgICAvLyBlc2NhcGluZywgYnV0IHdlIGFsbG93IGFueSBvdGhlciBjaGFyIHRvIGJlIGVzY2FwZWQgc2luY2UgaXRzXG4gICAgICAvLyBsaWtlbHkgdXNlcnMgd2lsbCBkbyB0aGlzXG4gICAgICAucmVwbGFjZSgvXFxcXCguKS9nLCAnXFwkMScpXG4gICAgICA7XG4gICAgLy8gYmFzaWMgYXJndW1lbnQgZGVzY3JpcHRvclxuICAgIGxldCBhID0ge1xuICAgICAgbmFtZTogYXJnLFxuICAgICAgdmFsdWU6ICcnLFxuICAgICAgbGl0ZXJhbDogZmFsc2VcbiAgICB9O1xuICAgIC8vIGRldGVjdCBsaXRlcmFsIHZhbHVlIChtdXN0IGJlIFN0cmluZyBvciBOdW1iZXIpXG4gICAgbGV0IGZjID0gYXJnWzBdO1xuICAgIGlmIChmYyA9PT0gJy0nKSB7XG4gICAgICBmYyA9IGFyZ1sxXTtcbiAgICB9XG4gICAgaWYgKGZjID49ICcwJyAmJiBmYyA8PSAnOScpIHtcbiAgICAgIGZjID0gJyMnO1xuICAgIH1cbiAgICBzd2l0Y2goZmMpIHtcbiAgICAgIGNhc2UgXCInXCI6XG4gICAgICBjYXNlICdcIic6XG4gICAgICAgIGEudmFsdWUgPSBhcmcuc2xpY2UoMSwgLTEpO1xuICAgICAgICBhLmxpdGVyYWwgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJyMnOlxuICAgICAgICBhLnZhbHVlID0gTnVtYmVyKGFyZyk7XG4gICAgICAgIGEubGl0ZXJhbCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAvLyBpZiBub3QgbGl0ZXJhbCwgbG9vayBmb3Igc3RydWN0dXJlZCBwYXRoXG4gICAgaWYgKCFhLmxpdGVyYWwpIHtcbiAgICAgIGEucm9vdFByb3BlcnR5ID0gUG9seW1lci5QYXRoLnJvb3QoYXJnKTtcbiAgICAgIC8vIGRldGVjdCBzdHJ1Y3R1cmVkIHBhdGggKGhhcyBkb3RzKVxuICAgICAgYS5zdHJ1Y3R1cmVkID0gUG9seW1lci5QYXRoLmlzUGF0aChhcmcpO1xuICAgICAgaWYgKGEuc3RydWN0dXJlZCkge1xuICAgICAgICBhLndpbGRjYXJkID0gKGFyZy5zbGljZSgtMikgPT0gJy4qJyk7XG4gICAgICAgIGlmIChhLndpbGRjYXJkKSB7XG4gICAgICAgICAgYS5uYW1lID0gYXJnLnNsaWNlKDAsIC0yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHYXRoZXIgdGhlIGFyZ3VtZW50IHZhbHVlcyBmb3IgYSBtZXRob2Qgc3BlY2lmaWVkIGluIHRoZSBwcm92aWRlZCBhcnJheVxuICAgKiBvZiBhcmd1bWVudCBtZXRhZGF0YS5cbiAgICpcbiAgICogVGhlIGBwYXRoYCBhbmQgYHZhbHVlYCBhcmd1bWVudHMgYXJlIHVzZWQgdG8gZmlsbCBpbiB3aWxkY2FyZCBkZXNjcmlwdG9yXG4gICAqIHdoZW4gdGhlIG1ldGhvZCBpcyBiZWluZyBjYWxsZWQgYXMgYSByZXN1bHQgb2YgYSBwYXRoIG5vdGlmaWNhdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgSW5zdGFuY2UgZGF0YSBzdG9yYWdlIG9iamVjdCB0byByZWFkIHByb3BlcnRpZXMgZnJvbVxuICAgKiBAcGFyYW0geyFBcnJheTwhTWV0aG9kQXJnPn0gYXJncyBBcnJheSBvZiBhcmd1bWVudCBtZXRhZGF0YVxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBQcm9wZXJ0eS9wYXRoIG5hbWUgdGhhdCB0cmlnZ2VyZWQgdGhlIG1ldGhvZCBlZmZlY3RcbiAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzIEJhZyBvZiBjdXJyZW50IHByb3BlcnR5IGNoYW5nZXNcbiAgICogQHJldHVybiB7QXJyYXk8Kj59IEFycmF5IG9mIGFyZ3VtZW50IHZhbHVlc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gbWFyc2hhbEFyZ3MoZGF0YSwgYXJncywgcGF0aCwgcHJvcHMpIHtcbiAgICBsZXQgdmFsdWVzID0gW107XG4gICAgZm9yIChsZXQgaT0wLCBsPWFyZ3MubGVuZ3RoOyBpPGw7IGkrKykge1xuICAgICAgbGV0IGFyZyA9IGFyZ3NbaV07XG4gICAgICBsZXQgbmFtZSA9IGFyZy5uYW1lO1xuICAgICAgbGV0IHY7XG4gICAgICBpZiAoYXJnLmxpdGVyYWwpIHtcbiAgICAgICAgdiA9IGFyZy52YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChhcmcuc3RydWN0dXJlZCkge1xuICAgICAgICAgIHYgPSBQb2x5bWVyLlBhdGguZ2V0KGRhdGEsIG5hbWUpO1xuICAgICAgICAgIC8vIHdoZW4gZGF0YSBpcyBub3Qgc3RvcmVkIGUuZy4gYHNwbGljZXNgXG4gICAgICAgICAgaWYgKHYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdiA9IHByb3BzW25hbWVdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2ID0gZGF0YVtuYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGFyZy53aWxkY2FyZCkge1xuICAgICAgICAvLyBPbmx5IHNlbmQgdGhlIGFjdHVhbCBwYXRoIGNoYW5nZWQgaW5mbyBpZiB0aGUgY2hhbmdlIHRoYXRcbiAgICAgICAgLy8gY2F1c2VkIHRoZSBvYnNlcnZlciB0byBydW4gbWF0Y2hlZCB0aGUgd2lsZGNhcmRcbiAgICAgICAgbGV0IGJhc2VDaGFuZ2VkID0gKG5hbWUuaW5kZXhPZihwYXRoICsgJy4nKSA9PT0gMCk7XG4gICAgICAgIGxldCBtYXRjaGVzID0gKHBhdGguaW5kZXhPZihuYW1lKSA9PT0gMCAmJiAhYmFzZUNoYW5nZWQpO1xuICAgICAgICB2YWx1ZXNbaV0gPSB7XG4gICAgICAgICAgcGF0aDogbWF0Y2hlcyA/IHBhdGggOiBuYW1lLFxuICAgICAgICAgIHZhbHVlOiBtYXRjaGVzID8gcHJvcHNbcGF0aF0gOiB2LFxuICAgICAgICAgIGJhc2U6IHZcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlc1tpXSA9IHY7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZXM7XG4gIH1cblxuICAvLyBkYXRhIGFwaVxuXG4gIC8qKlxuICAgKiBTZW5kcyBhcnJheSBzcGxpY2Ugbm90aWZpY2F0aW9ucyAoYC5zcGxpY2VzYCBhbmQgYC5sZW5ndGhgKVxuICAgKlxuICAgKiBOb3RlOiB0aGlzIGltcGxlbWVudGF0aW9uIG9ubHkgYWNjZXB0cyBub3JtYWxpemVkIHBhdGhzXG4gICAqXG4gICAqIEBwYXJhbSB7IVByb3BlcnR5RWZmZWN0c1R5cGV9IGluc3QgSW5zdGFuY2UgdG8gc2VuZCBub3RpZmljYXRpb25zIHRvXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0aGUgbXV0YXRpb25zIG9jY3VycmVkIG9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIHRoZSBhcnJheSB0aGF0IHdhcyBtdXRhdGVkXG4gICAqIEBwYXJhbSB7QXJyYXl9IHNwbGljZXMgQXJyYXkgb2Ygc3BsaWNlIHJlY29yZHNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIG5vdGlmeVNwbGljZXMoaW5zdCwgYXJyYXksIHBhdGgsIHNwbGljZXMpIHtcbiAgICBsZXQgc3BsaWNlc1BhdGggPSBwYXRoICsgJy5zcGxpY2VzJztcbiAgICBpbnN0Lm5vdGlmeVBhdGgoc3BsaWNlc1BhdGgsIHsgaW5kZXhTcGxpY2VzOiBzcGxpY2VzIH0pO1xuICAgIGluc3Qubm90aWZ5UGF0aChwYXRoICsgJy5sZW5ndGgnLCBhcnJheS5sZW5ndGgpO1xuICAgIC8vIE51bGwgaGVyZSB0byBhbGxvdyBwb3RlbnRpYWxseSBsYXJnZSBzcGxpY2UgcmVjb3JkcyB0byBiZSBHQydlZC5cbiAgICBpbnN0Ll9fZGF0YVtzcGxpY2VzUGF0aF0gPSB7aW5kZXhTcGxpY2VzOiBudWxsfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgc3BsaWNlIHJlY29yZCBhbmQgc2VuZHMgYW4gYXJyYXkgc3BsaWNlIG5vdGlmaWNhdGlvbiBmb3JcbiAgICogdGhlIGRlc2NyaWJlZCBtdXRhdGlvblxuICAgKlxuICAgKiBOb3RlOiB0aGlzIGltcGxlbWVudGF0aW9uIG9ubHkgYWNjZXB0cyBub3JtYWxpemVkIHBhdGhzXG4gICAqXG4gICAqIEBwYXJhbSB7IVByb3BlcnR5RWZmZWN0c1R5cGV9IGluc3QgSW5zdGFuY2UgdG8gc2VuZCBub3RpZmljYXRpb25zIHRvXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0aGUgbXV0YXRpb25zIG9jY3VycmVkIG9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIHRoZSBhcnJheSB0aGF0IHdhcyBtdXRhdGVkXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleCBhdCB3aGljaCB0aGUgYXJyYXkgbXV0YXRpb24gb2NjdXJyZWRcbiAgICogQHBhcmFtIHtudW1iZXJ9IGFkZGVkQ291bnQgTnVtYmVyIG9mIGFkZGVkIGl0ZW1zXG4gICAqIEBwYXJhbSB7QXJyYXl9IHJlbW92ZWQgQXJyYXkgb2YgcmVtb3ZlZCBpdGVtc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gbm90aWZ5U3BsaWNlKGluc3QsIGFycmF5LCBwYXRoLCBpbmRleCwgYWRkZWRDb3VudCwgcmVtb3ZlZCkge1xuICAgIG5vdGlmeVNwbGljZXMoaW5zdCwgYXJyYXksIHBhdGgsIFt7XG4gICAgICBpbmRleDogaW5kZXgsXG4gICAgICBhZGRlZENvdW50OiBhZGRlZENvdW50LFxuICAgICAgcmVtb3ZlZDogcmVtb3ZlZCxcbiAgICAgIG9iamVjdDogYXJyYXksXG4gICAgICB0eXBlOiAnc3BsaWNlJ1xuICAgIH1dKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIHVwcGVyLWNhc2VkIHZlcnNpb24gb2YgdGhlIHN0cmluZy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgU3RyaW5nIHRvIHVwcGVyY2FzZVxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFVwcGVyY2FzZWQgc3RyaW5nXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiB1cHBlcihuYW1lKSB7XG4gICAgcmV0dXJuIG5hbWVbMF0udG9VcHBlckNhc2UoKSArIG5hbWUuc3Vic3RyaW5nKDEpO1xuICB9XG5cbiAgLyoqXG4gICAqIEVsZW1lbnQgY2xhc3MgbWl4aW4gdGhhdCBwcm92aWRlcyBtZXRhLXByb2dyYW1taW5nIGZvciBQb2x5bWVyJ3MgdGVtcGxhdGVcbiAgICogYmluZGluZyBhbmQgZGF0YSBvYnNlcnZhdGlvbiAoY29sbGVjdGl2ZWx5LCBcInByb3BlcnR5IGVmZmVjdHNcIikgc3lzdGVtLlxuICAgKlxuICAgKiBUaGlzIG1peGluIHVzZXMgcHJvdmlkZXMgdGhlIGZvbGxvd2luZyBrZXkgc3RhdGljIG1ldGhvZHMgZm9yIGFkZGluZ1xuICAgKiBwcm9wZXJ0eSBlZmZlY3RzIHRvIGFuIGVsZW1lbnQgY2xhc3M6XG4gICAqIC0gYGFkZFByb3BlcnR5RWZmZWN0YFxuICAgKiAtIGBjcmVhdGVQcm9wZXJ0eU9ic2VydmVyYFxuICAgKiAtIGBjcmVhdGVNZXRob2RPYnNlcnZlcmBcbiAgICogLSBgY3JlYXRlTm90aWZ5aW5nUHJvcGVydHlgXG4gICAqIC0gYGNyZWF0ZVJlYWRPbmx5UHJvcGVydHlgXG4gICAqIC0gYGNyZWF0ZVJlZmxlY3RlZFByb3BlcnR5YFxuICAgKiAtIGBjcmVhdGVDb21wdXRlZFByb3BlcnR5YFxuICAgKiAtIGBiaW5kVGVtcGxhdGVgXG4gICAqXG4gICAqIEVhY2ggbWV0aG9kIGNyZWF0ZXMgb25lIG9yIG1vcmUgcHJvcGVydHkgYWNjZXNzb3JzLCBhbG9uZyB3aXRoIG1ldGFkYXRhXG4gICAqIHVzZWQgYnkgdGhpcyBtaXhpbidzIGltcGxlbWVudGF0aW9uIG9mIGBfcHJvcGVydGllc0NoYW5nZWRgIHRvIHBlcmZvcm1cbiAgICogdGhlIHByb3BlcnR5IGVmZmVjdHMuXG4gICAqXG4gICAqIFVuZGVyc2NvcmVkIHZlcnNpb25zIG9mIHRoZSBhYm92ZSBtZXRob2RzIGFsc28gZXhpc3Qgb24gdGhlIGVsZW1lbnRcbiAgICogcHJvdG90eXBlIGZvciBhZGRpbmcgcHJvcGVydHkgZWZmZWN0cyBvbiBpbnN0YW5jZXMgYXQgcnVudGltZS5cbiAgICpcbiAgICogTm90ZSB0aGF0IHRoaXMgbWl4aW4gb3ZlcnJpZGVzIHNldmVyYWwgYFByb3BlcnR5QWNjZXNzb3JzYCBtZXRob2RzLCBpblxuICAgKiBtYW55IGNhc2VzIHRvIG1haW50YWluIGd1YXJhbnRlZXMgcHJvdmlkZWQgYnkgdGhlIFBvbHltZXIgMS54IGZlYXR1cmVzO1xuICAgKiBub3RhYmx5IGl0IGNoYW5nZXMgcHJvcGVydHkgYWNjZXNzb3JzIHRvIGJlIHN5bmNocm9ub3VzIGJ5IGRlZmF1bHRcbiAgICogd2hlcmVhcyB0aGUgZGVmYXVsdCB3aGVuIHVzaW5nIGBQcm9wZXJ0eUFjY2Vzc29yc2Agc3RhbmRhbG9uZSBpcyB0byBiZVxuICAgKiBhc3luYyBieSBkZWZhdWx0LlxuICAgKlxuICAgKiBAbWl4aW5GdW5jdGlvblxuICAgKiBAcG9seW1lclxuICAgKiBAYXBwbGllc01peGluIFBvbHltZXIuVGVtcGxhdGVTdGFtcFxuICAgKiBAYXBwbGllc01peGluIFBvbHltZXIuUHJvcGVydHlBY2Nlc3NvcnNcbiAgICogQG1lbWJlcm9mIFBvbHltZXJcbiAgICogQHN1bW1hcnkgRWxlbWVudCBjbGFzcyBtaXhpbiB0aGF0IHByb3ZpZGVzIG1ldGEtcHJvZ3JhbW1pbmcgZm9yIFBvbHltZXInc1xuICAgKiB0ZW1wbGF0ZSBiaW5kaW5nIGFuZCBkYXRhIG9ic2VydmF0aW9uIHN5c3RlbS5cbiAgICovXG4gIFBvbHltZXIuUHJvcGVydHlFZmZlY3RzID0gUG9seW1lci5kZWR1cGluZ01peGluKHN1cGVyQ2xhc3MgPT4ge1xuXG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQGV4dGVuZHMge3N1cGVyQ2xhc3N9XG4gICAgICogQGltcGxlbWVudHMge1BvbHltZXJfUHJvcGVydHlBY2Nlc3NvcnN9XG4gICAgICogQGltcGxlbWVudHMge1BvbHltZXJfVGVtcGxhdGVTdGFtcH1cbiAgICAgKiBAdW5yZXN0cmljdGVkXG4gICAgICovXG4gICAgY29uc3QgcHJvcGVydHlFZmZlY3RzQmFzZSA9IFBvbHltZXIuVGVtcGxhdGVTdGFtcChQb2x5bWVyLlByb3BlcnR5QWNjZXNzb3JzKHN1cGVyQ2xhc3MpKTtcblxuICAgIC8qKlxuICAgICAqIEBwb2x5bWVyXG4gICAgICogQG1peGluQ2xhc3NcbiAgICAgKiBAaW1wbGVtZW50cyB7UG9seW1lcl9Qcm9wZXJ0eUVmZmVjdHN9XG4gICAgICogQGV4dGVuZHMge3Byb3BlcnR5RWZmZWN0c0Jhc2V9XG4gICAgICogQHVucmVzdHJpY3RlZFxuICAgICAqL1xuICAgIGNsYXNzIFByb3BlcnR5RWZmZWN0cyBleHRlbmRzIHByb3BlcnR5RWZmZWN0c0Jhc2Uge1xuXG4gICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLyoqIEB0eXBlIHtib29sZWFufSAqL1xuICAgICAgICB0aGlzLl9fZGF0YUNsaWVudHNSZWFkeTtcbiAgICAgICAgLyoqIEB0eXBlIHtBcnJheX0gKi9cbiAgICAgICAgdGhpcy5fX2RhdGFQZW5kaW5nQ2xpZW50cztcbiAgICAgICAgLyoqIEB0eXBlIHtPYmplY3R9ICovXG4gICAgICAgIHRoaXMuX19kYXRhVG9Ob3RpZnk7XG4gICAgICAgIC8qKiBAdHlwZSB7T2JqZWN0fSAqL1xuICAgICAgICB0aGlzLl9fZGF0YUxpbmtlZFBhdGhzO1xuICAgICAgICAvKiogQHR5cGUge2Jvb2xlYW59ICovXG4gICAgICAgIHRoaXMuX19kYXRhSGFzUGF0aHM7XG4gICAgICAgIC8qKiBAdHlwZSB7T2JqZWN0fSAqL1xuICAgICAgICB0aGlzLl9fZGF0YUNvbXBvdW5kU3RvcmFnZTtcbiAgICAgICAgLyoqIEB0eXBlIHtQb2x5bWVyX1Byb3BlcnR5RWZmZWN0c30gKi9cbiAgICAgICAgdGhpcy5fX2RhdGFIb3N0O1xuICAgICAgICAvKiogQHR5cGUgeyFPYmplY3R9ICovXG4gICAgICAgIHRoaXMuX19kYXRhVGVtcDtcbiAgICAgICAgLyoqIEB0eXBlIHtib29sZWFufSAqL1xuICAgICAgICB0aGlzLl9fZGF0YUNsaWVudHNJbml0aWFsaXplZDtcbiAgICAgICAgLyoqIEB0eXBlIHshT2JqZWN0fSAqL1xuICAgICAgICB0aGlzLl9fZGF0YTtcbiAgICAgICAgLyoqIEB0eXBlIHshT2JqZWN0fSAqL1xuICAgICAgICB0aGlzLl9fZGF0YVBlbmRpbmc7XG4gICAgICAgIC8qKiBAdHlwZSB7IU9iamVjdH0gKi9cbiAgICAgICAgdGhpcy5fX2RhdGFPbGQ7XG4gICAgICAgIC8qKiBAdHlwZSB7T2JqZWN0fSAqL1xuICAgICAgICB0aGlzLl9fY29tcHV0ZUVmZmVjdHM7XG4gICAgICAgIC8qKiBAdHlwZSB7T2JqZWN0fSAqL1xuICAgICAgICB0aGlzLl9fcmVmbGVjdEVmZmVjdHM7XG4gICAgICAgIC8qKiBAdHlwZSB7T2JqZWN0fSAqL1xuICAgICAgICB0aGlzLl9fbm90aWZ5RWZmZWN0cztcbiAgICAgICAgLyoqIEB0eXBlIHtPYmplY3R9ICovXG4gICAgICAgIHRoaXMuX19wcm9wYWdhdGVFZmZlY3RzO1xuICAgICAgICAvKiogQHR5cGUge09iamVjdH0gKi9cbiAgICAgICAgdGhpcy5fX29ic2VydmVFZmZlY3RzO1xuICAgICAgICAvKiogQHR5cGUge09iamVjdH0gKi9cbiAgICAgICAgdGhpcy5fX3JlYWRPbmx5O1xuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy5fX2RhdGFDb3VudGVyO1xuICAgICAgICAvKiogQHR5cGUgeyFUZW1wbGF0ZUluZm99ICovXG4gICAgICAgIHRoaXMuX190ZW1wbGF0ZUluZm87XG4gICAgICB9XG5cbiAgICAgIGdldCBQUk9QRVJUWV9FRkZFQ1RfVFlQRVMoKSB7XG4gICAgICAgIHJldHVybiBUWVBFUztcbiAgICAgIH1cblxuICAgICAgX2luaXRpYWxpemVQcm9wZXJ0aWVzKCkge1xuICAgICAgICBzdXBlci5faW5pdGlhbGl6ZVByb3BlcnRpZXMoKTtcbiAgICAgICAgaG9zdFN0YWNrLnJlZ2lzdGVySG9zdCh0aGlzKTtcbiAgICAgICAgdGhpcy5fX2RhdGFDbGllbnRzUmVhZHkgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fX2RhdGFQZW5kaW5nQ2xpZW50cyA9IG51bGw7XG4gICAgICAgIHRoaXMuX19kYXRhVG9Ob3RpZnkgPSBudWxsO1xuICAgICAgICB0aGlzLl9fZGF0YUxpbmtlZFBhdGhzID0gbnVsbDtcbiAgICAgICAgdGhpcy5fX2RhdGFIYXNQYXRocyA9IGZhbHNlO1xuICAgICAgICAvLyBNYXkgYmUgc2V0IG9uIGluc3RhbmNlIHByaW9yIHRvIHVwZ3JhZGVcbiAgICAgICAgdGhpcy5fX2RhdGFDb21wb3VuZFN0b3JhZ2UgPSB0aGlzLl9fZGF0YUNvbXBvdW5kU3RvcmFnZSB8fCBudWxsO1xuICAgICAgICB0aGlzLl9fZGF0YUhvc3QgPSB0aGlzLl9fZGF0YUhvc3QgfHwgbnVsbDtcbiAgICAgICAgdGhpcy5fX2RhdGFUZW1wID0ge307XG4gICAgICAgIHRoaXMuX19kYXRhQ2xpZW50c0luaXRpYWxpemVkID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogT3ZlcnJpZGVzIGBQb2x5bWVyLlByb3BlcnR5QWNjZXNzb3JzYCBpbXBsZW1lbnRhdGlvbiB0byBwcm92aWRlIGFcbiAgICAgICAqIG1vcmUgZWZmaWNpZW50IGltcGxlbWVudGF0aW9uIG9mIGluaXRpYWxpemluZyBwcm9wZXJ0aWVzIGZyb21cbiAgICAgICAqIHRoZSBwcm90b3R5cGUgb24gdGhlIGluc3RhbmNlLlxuICAgICAgICpcbiAgICAgICAqIEBvdmVycmlkZVxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzIFByb3BlcnRpZXMgdG8gaW5pdGlhbGl6ZSBvbiB0aGUgcHJvdG90eXBlXG4gICAgICAgKi9cbiAgICAgIF9pbml0aWFsaXplUHJvdG9Qcm9wZXJ0aWVzKHByb3BzKSB7XG4gICAgICAgIHRoaXMuX19kYXRhID0gT2JqZWN0LmNyZWF0ZShwcm9wcyk7XG4gICAgICAgIHRoaXMuX19kYXRhUGVuZGluZyA9IE9iamVjdC5jcmVhdGUocHJvcHMpO1xuICAgICAgICB0aGlzLl9fZGF0YU9sZCA9IHt9O1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIE92ZXJyaWRlcyBgUG9seW1lci5Qcm9wZXJ0eUFjY2Vzc29yc2AgaW1wbGVtZW50YXRpb24gdG8gYXZvaWQgc2V0dGluZ1xuICAgICAgICogYF9zZXRQcm9wZXJ0eWAncyBgc2hvdWxkTm90aWZ5OiB0cnVlYC5cbiAgICAgICAqXG4gICAgICAgKiBAb3ZlcnJpZGVcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBQcm9wZXJ0aWVzIHRvIGluaXRpYWxpemUgb24gdGhlIGluc3RhbmNlXG4gICAgICAgKi9cbiAgICAgIF9pbml0aWFsaXplSW5zdGFuY2VQcm9wZXJ0aWVzKHByb3BzKSB7XG4gICAgICAgIGxldCByZWFkT25seSA9IHRoaXNbVFlQRVMuUkVBRF9PTkxZXTtcbiAgICAgICAgZm9yIChsZXQgcHJvcCBpbiBwcm9wcykge1xuICAgICAgICAgIGlmICghcmVhZE9ubHkgfHwgIXJlYWRPbmx5W3Byb3BdKSB7XG4gICAgICAgICAgICB0aGlzLl9fZGF0YVBlbmRpbmcgPSB0aGlzLl9fZGF0YVBlbmRpbmcgfHwge307XG4gICAgICAgICAgICB0aGlzLl9fZGF0YU9sZCA9IHRoaXMuX19kYXRhT2xkIHx8IHt9O1xuICAgICAgICAgICAgdGhpcy5fX2RhdGFbcHJvcF0gPSB0aGlzLl9fZGF0YVBlbmRpbmdbcHJvcF0gPSBwcm9wc1twcm9wXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gUHJvdG90eXBlIHNldHVwIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgLyoqXG4gICAgICAgKiBFcXVpdmFsZW50IHRvIHN0YXRpYyBgYWRkUHJvcGVydHlFZmZlY3RgIEFQSSBidXQgY2FuIGJlIGNhbGxlZCBvblxuICAgICAgICogYW4gaW5zdGFuY2UgdG8gYWRkIGVmZmVjdHMgYXQgcnVudGltZS4gIFNlZSB0aGF0IG1ldGhvZCBmb3JcbiAgICAgICAqIGZ1bGwgQVBJIGRvY3MuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IHRoYXQgc2hvdWxkIHRyaWdnZXIgdGhlIGVmZmVjdFxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgRWZmZWN0IHR5cGUsIGZyb20gdGhpcy5QUk9QRVJUWV9FRkZFQ1RfVFlQRVNcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0PX0gZWZmZWN0IEVmZmVjdCBtZXRhZGF0YSBvYmplY3RcbiAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAqL1xuICAgICAgX2FkZFByb3BlcnR5RWZmZWN0KHByb3BlcnR5LCB0eXBlLCBlZmZlY3QpIHtcbiAgICAgICAgdGhpcy5fY3JlYXRlUHJvcGVydHlBY2Nlc3Nvcihwcm9wZXJ0eSwgdHlwZSA9PSBUWVBFUy5SRUFEX09OTFkpO1xuICAgICAgICAvLyBlZmZlY3RzIGFyZSBhY2N1bXVsYXRlZCBpbnRvIGFycmF5cyBwZXIgcHJvcGVydHkgYmFzZWQgb24gdHlwZVxuICAgICAgICBsZXQgZWZmZWN0cyA9IGVuc3VyZU93bkVmZmVjdE1hcCh0aGlzLCB0eXBlKVtwcm9wZXJ0eV07XG4gICAgICAgIGlmICghZWZmZWN0cykge1xuICAgICAgICAgIGVmZmVjdHMgPSB0aGlzW3R5cGVdW3Byb3BlcnR5XSA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGVmZmVjdHMucHVzaChlZmZlY3QpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJlbW92ZXMgdGhlIGdpdmVuIHByb3BlcnR5IGVmZmVjdC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgdGhlIGVmZmVjdCB3YXMgYXNzb2NpYXRlZCB3aXRoXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBFZmZlY3QgdHlwZSwgZnJvbSB0aGlzLlBST1BFUlRZX0VGRkVDVF9UWVBFU1xuICAgICAgICogQHBhcmFtIHtPYmplY3Q9fSBlZmZlY3QgRWZmZWN0IG1ldGFkYXRhIG9iamVjdCB0byByZW1vdmVcbiAgICAgICAqL1xuICAgICAgX3JlbW92ZVByb3BlcnR5RWZmZWN0KHByb3BlcnR5LCB0eXBlLCBlZmZlY3QpIHtcbiAgICAgICAgbGV0IGVmZmVjdHMgPSBlbnN1cmVPd25FZmZlY3RNYXAodGhpcywgdHlwZSlbcHJvcGVydHldO1xuICAgICAgICBsZXQgaWR4ID0gZWZmZWN0cy5pbmRleE9mKGVmZmVjdCk7XG4gICAgICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgICAgIGVmZmVjdHMuc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGN1cnJlbnQgcHJvdG90eXBlL2luc3RhbmNlIGhhcyBhIHByb3BlcnR5IGVmZmVjdFxuICAgICAgICogb2YgYSBjZXJ0YWluIHR5cGUuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IG5hbWVcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nPX0gdHlwZSBFZmZlY3QgdHlwZSwgZnJvbSB0aGlzLlBST1BFUlRZX0VGRkVDVF9UWVBFU1xuICAgICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgcHJvdG90eXBlL2luc3RhbmNlIGhhcyBhbiBlZmZlY3Qgb2YgdGhpcyB0eXBlXG4gICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgKi9cbiAgICAgIF9oYXNQcm9wZXJ0eUVmZmVjdChwcm9wZXJ0eSwgdHlwZSkge1xuICAgICAgICBsZXQgZWZmZWN0cyA9IHRoaXNbdHlwZV07XG4gICAgICAgIHJldHVybiBCb29sZWFuKGVmZmVjdHMgJiYgZWZmZWN0c1twcm9wZXJ0eV0pO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgY3VycmVudCBwcm90b3R5cGUvaW5zdGFuY2UgaGFzIGEgXCJyZWFkIG9ubHlcIlxuICAgICAgICogYWNjZXNzb3IgZm9yIHRoZSBnaXZlbiBwcm9wZXJ0eS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgbmFtZVxuICAgICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgcHJvdG90eXBlL2luc3RhbmNlIGhhcyBhbiBlZmZlY3Qgb2YgdGhpcyB0eXBlXG4gICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgKi9cbiAgICAgIF9oYXNSZWFkT25seUVmZmVjdChwcm9wZXJ0eSkge1xuICAgICAgICByZXR1cm4gdGhpcy5faGFzUHJvcGVydHlFZmZlY3QocHJvcGVydHksIFRZUEVTLlJFQURfT05MWSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBjdXJyZW50IHByb3RvdHlwZS9pbnN0YW5jZSBoYXMgYSBcIm5vdGlmeVwiXG4gICAgICAgKiBwcm9wZXJ0eSBlZmZlY3QgZm9yIHRoZSBnaXZlbiBwcm9wZXJ0eS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgbmFtZVxuICAgICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgcHJvdG90eXBlL2luc3RhbmNlIGhhcyBhbiBlZmZlY3Qgb2YgdGhpcyB0eXBlXG4gICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgKi9cbiAgICAgIF9oYXNOb3RpZnlFZmZlY3QocHJvcGVydHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hhc1Byb3BlcnR5RWZmZWN0KHByb3BlcnR5LCBUWVBFUy5OT1RJRlkpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgY3VycmVudCBwcm90b3R5cGUvaW5zdGFuY2UgaGFzIGEgXCJyZWZsZWN0IHRvIGF0dHJpYnV0ZVwiXG4gICAgICAgKiBwcm9wZXJ0eSBlZmZlY3QgZm9yIHRoZSBnaXZlbiBwcm9wZXJ0eS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgbmFtZVxuICAgICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgcHJvdG90eXBlL2luc3RhbmNlIGhhcyBhbiBlZmZlY3Qgb2YgdGhpcyB0eXBlXG4gICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgKi9cbiAgICAgIF9oYXNSZWZsZWN0RWZmZWN0KHByb3BlcnR5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oYXNQcm9wZXJ0eUVmZmVjdChwcm9wZXJ0eSwgVFlQRVMuUkVGTEVDVCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBjdXJyZW50IHByb3RvdHlwZS9pbnN0YW5jZSBoYXMgYSBcImNvbXB1dGVkXCJcbiAgICAgICAqIHByb3BlcnR5IGVmZmVjdCBmb3IgdGhlIGdpdmVuIHByb3BlcnR5LlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSBuYW1lXG4gICAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBwcm90b3R5cGUvaW5zdGFuY2UgaGFzIGFuIGVmZmVjdCBvZiB0aGlzIHR5cGVcbiAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAqL1xuICAgICAgX2hhc0NvbXB1dGVkRWZmZWN0KHByb3BlcnR5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oYXNQcm9wZXJ0eUVmZmVjdChwcm9wZXJ0eSwgVFlQRVMuQ09NUFVURSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFJ1bnRpbWUgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAvKipcbiAgICAgICAqIFNldHMgYSBwZW5kaW5nIHByb3BlcnR5IG9yIHBhdGguICBJZiB0aGUgcm9vdCBwcm9wZXJ0eSBvZiB0aGUgcGF0aCBpblxuICAgICAgICogcXVlc3Rpb24gaGFkIG5vIGFjY2Vzc29yLCB0aGUgcGF0aCBpcyBzZXQsIG90aGVyd2lzZSBpdCBpcyBlbnF1ZXVlZFxuICAgICAgICogdmlhIGBfc2V0UGVuZGluZ1Byb3BlcnR5YC5cbiAgICAgICAqXG4gICAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzb2xhdGVzIHJlbGF0aXZlbHkgZXhwZW5zaXZlIGZ1bmN0aW9uYWxpdHkgbmVjZXNzYXJ5XG4gICAgICAgKiBmb3IgdGhlIHB1YmxpYyBBUEkgKGBzZXRgLCBgc2V0UHJvcGVydGllc2AsIGBub3RpZnlQYXRoYCwgYW5kIHByb3BlcnR5XG4gICAgICAgKiBjaGFuZ2UgbGlzdGVuZXJzIHZpYSB7ey4uLn19IGJpbmRpbmdzKSwgc3VjaCB0aGF0IGl0IGlzIG9ubHkgZG9uZVxuICAgICAgICogd2hlbiBwYXRocyBlbnRlciB0aGUgc3lzdGVtLCBhbmQgbm90IGF0IGV2ZXJ5IHByb3BhZ2F0aW9uIHN0ZXAuICBJdFxuICAgICAgICogYWxzbyBzZXRzIGEgYF9fZGF0YUhhc1BhdGhzYCBmbGFnIG9uIHRoZSBpbnN0YW5jZSB3aGljaCBpcyB1c2VkIHRvXG4gICAgICAgKiBmYXN0LXBhdGggc2xvd2VyIHBhdGgtbWF0Y2hpbmcgY29kZSBpbiB0aGUgcHJvcGVydHkgZWZmZWN0cyBob3N0IHBhdGhzLlxuICAgICAgICpcbiAgICAgICAqIGBwYXRoYCBjYW4gYmUgYSBwYXRoIHN0cmluZyBvciBhcnJheSBvZiBwYXRoIHBhcnRzIGFzIGFjY2VwdGVkIGJ5IHRoZVxuICAgICAgICogcHVibGljIEFQSS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZyB8ICFBcnJheTxudW1iZXJ8c3RyaW5nPn0gcGF0aCBQYXRoIHRvIHNldFxuICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byBzZXRcbiAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IHNob3VsZE5vdGlmeSBTZXQgdG8gdHJ1ZSBpZiB0aGlzIGNoYW5nZSBzaG91bGRcbiAgICAgICAqICBjYXVzZSBhIHByb3BlcnR5IG5vdGlmaWNhdGlvbiBldmVudCBkaXNwYXRjaFxuICAgICAgICogQHBhcmFtIHtib29sZWFuPX0gaXNQYXRoTm90aWZpY2F0aW9uIElmIHRoZSBwYXRoIGJlaW5nIHNldCBpcyBhIHBhdGhcbiAgICAgICAqICAgbm90aWZpY2F0aW9uIG9mIGFuIGFscmVhZHkgY2hhbmdlZCB2YWx1ZSwgYXMgb3Bwb3NlZCB0byBhIHJlcXVlc3RcbiAgICAgICAqICAgdG8gc2V0IGFuZCBub3RpZnkgdGhlIGNoYW5nZS4gIEluIHRoZSBsYXR0ZXIgYGZhbHNlYCBjYXNlLCBhIGRpcnR5XG4gICAgICAgKiAgIGNoZWNrIGlzIHBlcmZvcm1lZCBhbmQgdGhlbiB0aGUgdmFsdWUgaXMgc2V0IHRvIHRoZSBwYXRoIGJlZm9yZVxuICAgICAgICogICBlbnF1ZXVpbmcgdGhlIHBlbmRpbmcgcHJvcGVydHkgY2hhbmdlLlxuICAgICAgICogQHJldHVybiB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZSBwcm9wZXJ0eS9wYXRoIHdhcyBlbnF1ZXVlZCBpblxuICAgICAgICogICB0aGUgcGVuZGluZyBjaGFuZ2VzIGJhZy5cbiAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAqL1xuICAgICAgX3NldFBlbmRpbmdQcm9wZXJ0eU9yUGF0aChwYXRoLCB2YWx1ZSwgc2hvdWxkTm90aWZ5LCBpc1BhdGhOb3RpZmljYXRpb24pIHtcbiAgICAgICAgaWYgKGlzUGF0aE5vdGlmaWNhdGlvbiB8fFxuICAgICAgICAgICAgUG9seW1lci5QYXRoLnJvb3QoQXJyYXkuaXNBcnJheShwYXRoKSA/IHBhdGhbMF0gOiBwYXRoKSAhPT0gcGF0aCkge1xuICAgICAgICAgIC8vIERpcnR5IGNoZWNrIGNoYW5nZXMgYmVpbmcgc2V0IHRvIGEgcGF0aCBhZ2FpbnN0IHRoZSBhY3R1YWwgb2JqZWN0LFxuICAgICAgICAgIC8vIHNpbmNlIHRoaXMgaXMgdGhlIGVudHJ5IHBvaW50IGZvciBwYXRocyBpbnRvIHRoZSBzeXN0ZW07IGZyb20gaGVyZVxuICAgICAgICAgIC8vIHRoZSBvbmx5IGRpcnR5IGNoZWNrcyBhcmUgYWdhaW5zdCB0aGUgYF9fZGF0YVRlbXBgIGNhY2hlIHRvIHByZXZlbnRcbiAgICAgICAgICAvLyBkdXBsaWNhdGUgd29yayBpbiB0aGUgc2FtZSB0dXJuIG9ubHkuIE5vdGUsIGlmIHRoaXMgd2FzIGEgbm90aWZpY2F0aW9uXG4gICAgICAgICAgLy8gb2YgYSBjaGFuZ2UgYWxyZWFkeSBzZXQgdG8gYSBwYXRoIChpc1BhdGhOb3RpZmljYXRpb246IHRydWUpLFxuICAgICAgICAgIC8vIHdlIGFsd2F5cyBsZXQgdGhlIGNoYW5nZSB0aHJvdWdoIGFuZCBza2lwIHRoZSBgc2V0YCBzaW5jZSBpdCB3YXNcbiAgICAgICAgICAvLyBhbHJlYWR5IGRpcnR5IGNoZWNrZWQgYXQgdGhlIHBvaW50IG9mIGVudHJ5IGFuZCB0aGUgdW5kZXJseWluZ1xuICAgICAgICAgIC8vIG9iamVjdCBoYXMgYWxyZWFkeSBiZWVuIHVwZGF0ZWRcbiAgICAgICAgICBpZiAoIWlzUGF0aE5vdGlmaWNhdGlvbikge1xuICAgICAgICAgICAgbGV0IG9sZCA9IFBvbHltZXIuUGF0aC5nZXQodGhpcywgcGF0aCk7XG4gICAgICAgICAgICBwYXRoID0gLyoqIEB0eXBlIHtzdHJpbmd9ICovIChQb2x5bWVyLlBhdGguc2V0KHRoaXMsIHBhdGgsIHZhbHVlKSk7XG4gICAgICAgICAgICAvLyBVc2UgcHJvcGVydHktYWNjZXNzb3IncyBzaW1wbGVyIGRpcnR5IGNoZWNrXG4gICAgICAgICAgICBpZiAoIXBhdGggfHwgIXN1cGVyLl9zaG91bGRQcm9wZXJ0eUNoYW5nZShwYXRoLCB2YWx1ZSwgb2xkKSkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX19kYXRhSGFzUGF0aHMgPSB0cnVlO1xuICAgICAgICAgIGlmICh0aGlzLl9zZXRQZW5kaW5nUHJvcGVydHkoLyoqQHR5cGV7c3RyaW5nfSovKHBhdGgpLCB2YWx1ZSwgc2hvdWxkTm90aWZ5KSkge1xuICAgICAgICAgICAgY29tcHV0ZUxpbmtlZFBhdGhzKHRoaXMsIHBhdGgsIHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodGhpcy5fX2RhdGFIYXNBY2Nlc3NvciAmJiB0aGlzLl9fZGF0YUhhc0FjY2Vzc29yW3BhdGhdKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2V0UGVuZGluZ1Byb3BlcnR5KC8qKkB0eXBle3N0cmluZ30qLyhwYXRoKSwgdmFsdWUsIHNob3VsZE5vdGlmeSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXNbcGF0aF0gPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEFwcGxpZXMgYSB2YWx1ZSB0byBhIG5vbi1Qb2x5bWVyIGVsZW1lbnQvbm9kZSdzIHByb3BlcnR5LlxuICAgICAgICpcbiAgICAgICAqIFRoZSBpbXBsZW1lbnRhdGlvbiBtYWtlcyBhIGJlc3QtZWZmb3J0IGF0IGJpbmRpbmcgaW50ZXJvcDpcbiAgICAgICAqIFNvbWUgbmF0aXZlIGVsZW1lbnQgcHJvcGVydGllcyBoYXZlIHNpZGUtZWZmZWN0cyB3aGVuXG4gICAgICAgKiByZS1zZXR0aW5nIHRoZSBzYW1lIHZhbHVlIChlLmcuIHNldHRpbmcgYDxpbnB1dD4udmFsdWVgIHJlc2V0cyB0aGVcbiAgICAgICAqIGN1cnNvciBwb3NpdGlvbiksIHNvIHdlIGRvIGEgZGlydHktY2hlY2sgYmVmb3JlIHNldHRpbmcgdGhlIHZhbHVlLlxuICAgICAgICogSG93ZXZlciwgZm9yIGJldHRlciBpbnRlcm9wIHdpdGggbm9uLVBvbHltZXIgY3VzdG9tIGVsZW1lbnRzIHRoYXRcbiAgICAgICAqIGFjY2VwdCBvYmplY3RzLCB3ZSBleHBsaWNpdGx5IHJlLXNldCBvYmplY3QgY2hhbmdlcyBjb21pbmcgZnJvbSB0aGVcbiAgICAgICAqIFBvbHltZXIgd29ybGQgKHdoaWNoIG1heSBpbmNsdWRlIGRlZXAgb2JqZWN0IGNoYW5nZXMgd2l0aG91dCB0aGVcbiAgICAgICAqIHRvcCByZWZlcmVuY2UgY2hhbmdpbmcpLCBlcnJpbmcgb24gdGhlIHNpZGUgb2YgcHJvdmlkaW5nIG1vcmVcbiAgICAgICAqIGluZm9ybWF0aW9uLlxuICAgICAgICpcbiAgICAgICAqIFVzZXJzIG1heSBvdmVycmlkZSB0aGlzIG1ldGhvZCB0byBwcm92aWRlIGFsdGVybmF0ZSBhcHByb2FjaGVzLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBUaGUgbm9kZSB0byBzZXQgYSBwcm9wZXJ0eSBvblxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3AgVGhlIHByb3BlcnR5IHRvIHNldFxuICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0XG4gICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgKi9cbiAgICAgIF9zZXRVbm1hbmFnZWRQcm9wZXJ0eVRvTm9kZShub2RlLCBwcm9wLCB2YWx1ZSkge1xuICAgICAgICAvLyBJdCBpcyBhIGp1ZGdtZW50IGNhbGwgdGhhdCByZXNldHRpbmcgcHJpbWl0aXZlcyBpc1xuICAgICAgICAvLyBcImJhZFwiIGFuZCByZXNldHRpbmdzIG9iamVjdHMgaXMgYWxzbyBcImdvb2RcIjsgYWx0ZXJuYXRpdmVseSB3ZSBjb3VsZFxuICAgICAgICAvLyBpbXBsZW1lbnQgYSB3aGl0ZWxpc3Qgb2YgdGFnICYgcHJvcGVydHkgdmFsdWVzIHRoYXQgc2hvdWxkIG5ldmVyXG4gICAgICAgIC8vIGJlIHJlc2V0IChlLmcuIDxpbnB1dD4udmFsdWUgJiYgPHNlbGVjdD4udmFsdWUpXG4gICAgICAgIGlmICh2YWx1ZSAhPT0gbm9kZVtwcm9wXSB8fCB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBub2RlW3Byb3BdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBPdmVycmlkZXMgdGhlIGBQcm9wZXJ0eUFjY2Vzc29yc2AgaW1wbGVtZW50YXRpb24gdG8gaW50cm9kdWNlIHNwZWNpYWxcbiAgICAgICAqIGRpcnR5IGNoZWNrIGxvZ2ljIGRlcGVuZGluZyBvbiB0aGUgcHJvcGVydHkgJiB2YWx1ZSBiZWluZyBzZXQ6XG4gICAgICAgKlxuICAgICAgICogMS4gQW55IHZhbHVlIHNldCB0byBhIHBhdGggKGUuZy4gJ29iai5wcm9wJzogNDIgb3IgJ29iai5wcm9wJzogey4uLn0pXG4gICAgICAgKiAgICBTdG9yZWQgaW4gYF9fZGF0YVRlbXBgLCBkaXJ0eSBjaGVja2VkIGFnYWluc3QgYF9fZGF0YVRlbXBgXG4gICAgICAgKiAyLiBPYmplY3Qgc2V0IHRvIHNpbXBsZSBwcm9wZXJ0eSAoZS5nLiAncHJvcCc6IHsuLi59KVxuICAgICAgICogICAgU3RvcmVkIGluIGBfX2RhdGFUZW1wYCBhbmQgYF9fZGF0YWAsIGRpcnR5IGNoZWNrZWQgYWdhaW5zdFxuICAgICAgICogICAgYF9fZGF0YVRlbXBgIGJ5IGRlZmF1bHQgaW1wbGVtZW50YXRpb24gb2YgYF9zaG91bGRQcm9wZXJ0eUNoYW5nZWBcbiAgICAgICAqIDMuIFByaW1pdGl2ZSB2YWx1ZSBzZXQgdG8gc2ltcGxlIHByb3BlcnR5IChlLmcuICdwcm9wJzogNDIpXG4gICAgICAgKiAgICBTdG9yZWQgaW4gYF9fZGF0YWAsIGRpcnR5IGNoZWNrZWQgYWdhaW5zdCBgX19kYXRhYFxuICAgICAgICpcbiAgICAgICAqIFRoZSBkaXJ0eS1jaGVjayBpcyBpbXBvcnRhbnQgdG8gcHJldmVudCBjeWNsZXMgZHVlIHRvIHR3by13YXlcbiAgICAgICAqIG5vdGlmaWNhdGlvbiwgYnV0IHBhdGhzIGFuZCBvYmplY3RzIGFyZSBvbmx5IGRpcnR5IGNoZWNrZWQgYWdhaW5zdCBhbnlcbiAgICAgICAqIHByZXZpb3VzIHZhbHVlIHNldCBkdXJpbmcgdGhpcyB0dXJuIHZpYSBhIFwidGVtcG9yYXJ5IGNhY2hlXCIgdGhhdCBpc1xuICAgICAgICogY2xlYXJlZCB3aGVuIHRoZSBsYXN0IGBfcHJvcGVydGllc0NoYWdlZGAgZXhpdHMuIFRoaXMgaXMgc286XG4gICAgICAgKiBhLiBhbnkgY2FjaGVkIGFycmF5IHBhdGhzIChlLmcuICdhcnJheS4zLnByb3AnKSBtYXkgYmUgaW52YWxpZGF0ZWRcbiAgICAgICAqICAgIGR1ZSB0byBhcnJheSBtdXRhdGlvbnMgbGlrZSBzaGlmdC91bnNoaWZ0L3NwbGljZTsgdGhpcyBpcyBmaW5lXG4gICAgICAgKiAgICBzaW5jZSBwYXRoIGNoYW5nZXMgYXJlIGRpcnR5LWNoZWNrZWQgYXQgdXNlciBlbnRyeSBwb2ludHMgbGlrZSBgc2V0YFxuICAgICAgICogYi4gZGlydHktY2hlY2tpbmcgZm9yIG9iamVjdHMgb25seSBsYXN0cyBvbmUgdHVybiB0byBhbGxvdyB0aGUgdXNlclxuICAgICAgICogICAgdG8gbXV0YXRlIHRoZSBvYmplY3QgaW4tcGxhY2UgYW5kIHJlLXNldCBpdCB3aXRoIHRoZSBzYW1lIGlkZW50aXR5XG4gICAgICAgKiAgICBhbmQgaGF2ZSBhbGwgc3ViLXByb3BlcnRpZXMgcmUtcHJvcGFnYXRlZCBpbiBhIHN1YnNlcXVlbnQgdHVybi5cbiAgICAgICAqXG4gICAgICAgKiBUaGUgdGVtcCBjYWNoZSBpcyBub3QgbmVjZXNzYXJpbHkgc3VmZmljaWVudCB0byBwcmV2ZW50IGludmFsaWQgYXJyYXlcbiAgICAgICAqIHBhdGhzLCBzaW5jZSBhIHNwbGljZSBjYW4gaGFwcGVuIGR1cmluZyB0aGUgc2FtZSB0dXJuICh3aXRoIHBhdGhvbG9naWNhbFxuICAgICAgICogdXNlciBjb2RlKTsgd2UgY291bGQgaW50cm9kdWNlIGEgXCJmaXh1cFwiIGZvciB0ZW1wb3JhcmlseSBjYWNoZWQgYXJyYXlcbiAgICAgICAqIHBhdGhzIGlmIG5lZWRlZDogaHR0cHM6Ly9naXRodWIuY29tL1BvbHltZXIvcG9seW1lci9pc3N1ZXMvNDIyN1xuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBOYW1lIG9mIHRoZSBwcm9wZXJ0eVxuICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byBzZXRcbiAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IHNob3VsZE5vdGlmeSBUcnVlIGlmIHByb3BlcnR5IHNob3VsZCBmaXJlIG5vdGlmaWNhdGlvblxuICAgICAgICogICBldmVudCAoYXBwbGllcyBvbmx5IGZvciBgbm90aWZ5OiB0cnVlYCBwcm9wZXJ0aWVzKVxuICAgICAgICogQHJldHVybiB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZSBwcm9wZXJ0eSBjaGFuZ2VkXG4gICAgICAgKiBAb3ZlcnJpZGVcbiAgICAgICAqL1xuICAgICAgX3NldFBlbmRpbmdQcm9wZXJ0eShwcm9wZXJ0eSwgdmFsdWUsIHNob3VsZE5vdGlmeSkge1xuICAgICAgICBsZXQgaXNQYXRoID0gdGhpcy5fX2RhdGFIYXNQYXRocyAmJiBQb2x5bWVyLlBhdGguaXNQYXRoKHByb3BlcnR5KTtcbiAgICAgICAgbGV0IHByZXZQcm9wcyA9IGlzUGF0aCA/IHRoaXMuX19kYXRhVGVtcCA6IHRoaXMuX19kYXRhO1xuICAgICAgICBpZiAodGhpcy5fc2hvdWxkUHJvcGVydHlDaGFuZ2UocHJvcGVydHksIHZhbHVlLCBwcmV2UHJvcHNbcHJvcGVydHldKSkge1xuICAgICAgICAgIGlmICghdGhpcy5fX2RhdGFQZW5kaW5nKSB7XG4gICAgICAgICAgICB0aGlzLl9fZGF0YVBlbmRpbmcgPSB7fTtcbiAgICAgICAgICAgIHRoaXMuX19kYXRhT2xkID0ge307XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIEVuc3VyZSBvbGQgaXMgY2FwdHVyZWQgZnJvbSB0aGUgbGFzdCB0dXJuXG4gICAgICAgICAgaWYgKCEocHJvcGVydHkgaW4gdGhpcy5fX2RhdGFPbGQpKSB7XG4gICAgICAgICAgICB0aGlzLl9fZGF0YU9sZFtwcm9wZXJ0eV0gPSB0aGlzLl9fZGF0YVtwcm9wZXJ0eV07XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFBhdGhzIGFyZSBzdG9yZWQgaW4gdGVtcG9yYXJ5IGNhY2hlIChjbGVhcmVkIGF0IGVuZCBvZiB0dXJuKSxcbiAgICAgICAgICAvLyB3aGljaCBpcyB1c2VkIGZvciBkaXJ0eS1jaGVja2luZywgYWxsIG90aGVycyBzdG9yZWQgaW4gX19kYXRhXG4gICAgICAgICAgaWYgKGlzUGF0aCkge1xuICAgICAgICAgICAgdGhpcy5fX2RhdGFUZW1wW3Byb3BlcnR5XSA9IHZhbHVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9fZGF0YVtwcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gQWxsIGNoYW5nZXMgZ28gaW50byBwZW5kaW5nIHByb3BlcnR5IGJhZywgcGFzc2VkIHRvIF9wcm9wZXJ0aWVzQ2hhbmdlZFxuICAgICAgICAgIHRoaXMuX19kYXRhUGVuZGluZ1twcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICAgICAgICAvLyBUcmFjayBwcm9wZXJ0aWVzIHRoYXQgc2hvdWxkIG5vdGlmeSBzZXBhcmF0ZWx5XG4gICAgICAgICAgaWYgKGlzUGF0aCB8fCAodGhpc1tUWVBFUy5OT1RJRlldICYmIHRoaXNbVFlQRVMuTk9USUZZXVtwcm9wZXJ0eV0pKSB7XG4gICAgICAgICAgICB0aGlzLl9fZGF0YVRvTm90aWZ5ID0gdGhpcy5fX2RhdGFUb05vdGlmeSB8fCB7fTtcbiAgICAgICAgICAgIHRoaXMuX19kYXRhVG9Ob3RpZnlbcHJvcGVydHldID0gc2hvdWxkTm90aWZ5O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogT3ZlcnJpZGVzIGJhc2UgaW1wbGVtZW50YXRpb24gdG8gZW5zdXJlIGFsbCBhY2Nlc3NvcnMgc2V0IGBzaG91bGROb3RpZnlgXG4gICAgICAgKiB0byB0cnVlLCBmb3IgcGVyLXByb3BlcnR5IG5vdGlmaWNhdGlvbiB0cmFja2luZy5cbiAgICAgICAqXG4gICAgICAgKiBAb3ZlcnJpZGVcbiAgICAgICAqL1xuICAgICAgX3NldFByb3BlcnR5KHByb3BlcnR5LCB2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5fc2V0UGVuZGluZ1Byb3BlcnR5KHByb3BlcnR5LCB2YWx1ZSwgdHJ1ZSkpIHtcbiAgICAgICAgICB0aGlzLl9pbnZhbGlkYXRlUHJvcGVydGllcygpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogT3ZlcnJpZGVzIGBQcm9wZXJ0eUFjY2Vzc29yYCdzIGRlZmF1bHQgYXN5bmMgcXVldWluZyBvZlxuICAgICAgICogYF9wcm9wZXJ0aWVzQ2hhbmdlZGA6IGlmIGBfX2RhdGFSZWFkeWAgaXMgZmFsc2UgKGhhcyBub3QgeWV0IGJlZW5cbiAgICAgICAqIG1hbnVhbGx5IGZsdXNoZWQpLCB0aGUgZnVuY3Rpb24gbm8tb3BzOyBvdGhlcndpc2UgZmx1c2hlc1xuICAgICAgICogYF9wcm9wZXJ0aWVzQ2hhbmdlZGAgc3luY2hyb25vdXNseS5cbiAgICAgICAqXG4gICAgICAgKiBAb3ZlcnJpZGVcbiAgICAgICAqL1xuICAgICAgX2ludmFsaWRhdGVQcm9wZXJ0aWVzKCkge1xuICAgICAgICBpZiAodGhpcy5fX2RhdGFSZWFkeSkge1xuICAgICAgICAgIHRoaXMuX2ZsdXNoUHJvcGVydGllcygpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogRW5xdWV1ZXMgdGhlIGdpdmVuIGNsaWVudCBvbiBhIGxpc3Qgb2YgcGVuZGluZyBjbGllbnRzLCB3aG9zZVxuICAgICAgICogcGVuZGluZyBwcm9wZXJ0eSBjaGFuZ2VzIGNhbiBsYXRlciBiZSBmbHVzaGVkIHZpYSBhIGNhbGwgdG9cbiAgICAgICAqIGBfZmx1c2hDbGllbnRzYC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2xpZW50IFByb3BlcnR5RWZmZWN0cyBjbGllbnQgdG8gZW5xdWV1ZVxuICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICovXG4gICAgICBfZW5xdWV1ZUNsaWVudChjbGllbnQpIHtcbiAgICAgICAgdGhpcy5fX2RhdGFQZW5kaW5nQ2xpZW50cyA9IHRoaXMuX19kYXRhUGVuZGluZ0NsaWVudHMgfHwgW107XG4gICAgICAgIGlmIChjbGllbnQgIT09IHRoaXMpIHtcbiAgICAgICAgICB0aGlzLl9fZGF0YVBlbmRpbmdDbGllbnRzLnB1c2goY2xpZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEZsdXNoZXMgYW55IGNsaWVudHMgcHJldmlvdXNseSBlbnF1ZXVlZCB2aWEgYF9lbnF1ZXVlQ2xpZW50YCwgY2F1c2luZ1xuICAgICAgICogdGhlaXIgYF9mbHVzaFByb3BlcnRpZXNgIG1ldGhvZCB0byBydW4uXG4gICAgICAgKlxuICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICovXG4gICAgICBfZmx1c2hDbGllbnRzKCkge1xuICAgICAgICBpZiAoIXRoaXMuX19kYXRhQ2xpZW50c1JlYWR5KSB7XG4gICAgICAgICAgdGhpcy5fX2RhdGFDbGllbnRzUmVhZHkgPSB0cnVlO1xuICAgICAgICAgIHRoaXMuX3JlYWR5Q2xpZW50cygpO1xuICAgICAgICAgIC8vIE92ZXJyaWRlIHBvaW50IHdoZXJlIGFjY2Vzc29ycyBhcmUgdHVybmVkIG9uOyBpbXBvcnRhbnRseSxcbiAgICAgICAgICAvLyB0aGlzIGlzIGFmdGVyIGNsaWVudHMgaGF2ZSBmdWxseSByZWFkaWVkLCBwcm92aWRpbmcgYSBndWFyYW50ZWVcbiAgICAgICAgICAvLyB0aGF0IGFueSBwcm9wZXJ0eSBlZmZlY3RzIG9jY3VyIG9ubHkgYWZ0ZXIgYWxsIGNsaWVudHMgYXJlIHJlYWR5LlxuICAgICAgICAgIHRoaXMuX19kYXRhUmVhZHkgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX19lbmFibGVPckZsdXNoQ2xpZW50cygpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIE5PVEU6IFdlIGVuc3VyZSBjbGllbnRzIGVpdGhlciBlbmFibGUgb3IgZmx1c2ggYXMgYXBwcm9wcmlhdGUuIFRoaXNcbiAgICAgIC8vIGhhbmRsZXMgdHdvIGNvcm5lciBjYXNlczpcbiAgICAgIC8vICgxKSBjbGllbnRzIGZsdXNoIHByb3Blcmx5IHdoZW4gY29ubmVjdGVkL2VuYWJsZWQgYmVmb3JlIHRoZSBob3N0XG4gICAgICAvLyBlbmFibGVzOyBlLmcuXG4gICAgICAvLyAgIChhKSBUZW1wbGF0aXplIHN0YW1wcyB3aXRoIG5vIHByb3BlcnRpZXMgYW5kIGRvZXMgbm90IGZsdXNoIGFuZFxuICAgICAgLy8gICAoYikgdGhlIGluc3RhbmNlIGlzIGluc2VydGVkIGludG8gZG9tIGFuZFxuICAgICAgLy8gICAoYykgdGhlbiB0aGUgaW5zdGFuY2UgZmx1c2hlcy5cbiAgICAgIC8vICgyKSBjbGllbnRzIGVuYWJsZSBwcm9wZXJseSB3aGVuIG5vdCBjb25uZWN0ZWQvZW5hYmxlZCB3aGVuIHRoZSBob3N0XG4gICAgICAvLyBmbHVzaGVzOyBlLmcuXG4gICAgICAvLyAgIChhKSBhIHRlbXBsYXRlIGlzIHJ1bnRpbWUgc3RhbXBlZCBhbmQgbm90IHlldCBjb25uZWN0ZWQvZW5hYmxlZFxuICAgICAgLy8gICAoYikgYSBob3N0IHNldHMgYSBwcm9wZXJ0eSwgY2F1c2luZyBzdGFtcGVkIGRvbSB0byBmbHVzaFxuICAgICAgLy8gICAoYykgdGhlIHN0YW1wZWQgZG9tIGVuYWJsZXMuXG4gICAgICBfX2VuYWJsZU9yRmx1c2hDbGllbnRzKCkge1xuICAgICAgICBsZXQgY2xpZW50cyA9IHRoaXMuX19kYXRhUGVuZGluZ0NsaWVudHM7XG4gICAgICAgIGlmIChjbGllbnRzKSB7XG4gICAgICAgICAgdGhpcy5fX2RhdGFQZW5kaW5nQ2xpZW50cyA9IG51bGw7XG4gICAgICAgICAgZm9yIChsZXQgaT0wOyBpIDwgY2xpZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGNsaWVudCA9IGNsaWVudHNbaV07XG4gICAgICAgICAgICBpZiAoIWNsaWVudC5fX2RhdGFFbmFibGVkKSB7XG4gICAgICAgICAgICAgIGNsaWVudC5fZW5hYmxlUHJvcGVydGllcygpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjbGllbnQuX19kYXRhUGVuZGluZykge1xuICAgICAgICAgICAgICBjbGllbnQuX2ZsdXNoUHJvcGVydGllcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFBlcmZvcm0gYW55IGluaXRpYWwgc2V0dXAgb24gY2xpZW50IGRvbS4gQ2FsbGVkIGJlZm9yZSB0aGUgZmlyc3RcbiAgICAgICAqIGBfZmx1c2hQcm9wZXJ0aWVzYCBjYWxsIG9uIGNsaWVudCBkb20gYW5kIGJlZm9yZSBhbnkgZWxlbWVudFxuICAgICAgICogb2JzZXJ2ZXJzIGFyZSBjYWxsZWQuXG4gICAgICAgKlxuICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICovXG4gICAgICBfcmVhZHlDbGllbnRzKCkge1xuICAgICAgICB0aGlzLl9fZW5hYmxlT3JGbHVzaENsaWVudHMoKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBTZXRzIGEgYmFnIG9mIHByb3BlcnR5IGNoYW5nZXMgdG8gdGhpcyBpbnN0YW5jZSwgYW5kXG4gICAgICAgKiBzeW5jaHJvbm91c2x5IHByb2Nlc3NlcyBhbGwgZWZmZWN0cyBvZiB0aGUgcHJvcGVydGllcyBhcyBhIGJhdGNoLlxuICAgICAgICpcbiAgICAgICAqIFByb3BlcnR5IG5hbWVzIG11c3QgYmUgc2ltcGxlIHByb3BlcnRpZXMsIG5vdCBwYXRocy4gIEJhdGNoZWRcbiAgICAgICAqIHBhdGggcHJvcGFnYXRpb24gaXMgbm90IHN1cHBvcnRlZC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgQmFnIG9mIG9uZSBvciBtb3JlIGtleS12YWx1ZSBwYWlycyB3aG9zZSBrZXkgaXNcbiAgICAgICAqICAgYSBwcm9wZXJ0eSBhbmQgdmFsdWUgaXMgdGhlIG5ldyB2YWx1ZSB0byBzZXQgZm9yIHRoYXQgcHJvcGVydHkuXG4gICAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBzZXRSZWFkT25seSBXaGVuIHRydWUsIGFueSBwcml2YXRlIHZhbHVlcyBzZXQgaW5cbiAgICAgICAqICAgYHByb3BzYCB3aWxsIGJlIHNldC4gQnkgZGVmYXVsdCwgYHNldFByb3BlcnRpZXNgIHdpbGwgbm90IHNldFxuICAgICAgICogICBgcmVhZE9ubHk6IHRydWVgIHJvb3QgcHJvcGVydGllcy5cbiAgICAgICAqIEBwdWJsaWNcbiAgICAgICAqL1xuICAgICAgc2V0UHJvcGVydGllcyhwcm9wcywgc2V0UmVhZE9ubHkpIHtcbiAgICAgICAgZm9yIChsZXQgcGF0aCBpbiBwcm9wcykge1xuICAgICAgICAgIGlmIChzZXRSZWFkT25seSB8fCAhdGhpc1tUWVBFUy5SRUFEX09OTFldIHx8ICF0aGlzW1RZUEVTLlJFQURfT05MWV1bcGF0aF0pIHtcbiAgICAgICAgICAgIC8vVE9ETyhrc2NoYWFmKTogZXhwbGljaXRseSBkaXNhbGxvdyBwYXRocyBpbiBzZXRQcm9wZXJ0eT9cbiAgICAgICAgICAgIC8vIHdpbGRjYXJkIG9ic2VydmVycyBjdXJyZW50bHkgb25seSBwYXNzIHRoZSBmaXJzdCBjaGFuZ2VkIHBhdGhcbiAgICAgICAgICAgIC8vIGluIHRoZSBgaW5mb2Agb2JqZWN0LCBhbmQgeW91IGNvdWxkIGRvIHNvbWUgb2RkIHRoaW5ncyBiYXRjaGluZ1xuICAgICAgICAgICAgLy8gcGF0aHMsIGUuZy4geydmb28uYmFyJzogey4uLn0sICdmb28nOiBudWxsfVxuICAgICAgICAgICAgdGhpcy5fc2V0UGVuZGluZ1Byb3BlcnR5T3JQYXRoKHBhdGgsIHByb3BzW3BhdGhdLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faW52YWxpZGF0ZVByb3BlcnRpZXMoKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBPdmVycmlkZXMgYFByb3BlcnR5QWNjZXNzb3JzYCBzbyB0aGF0IHByb3BlcnR5IGFjY2Vzc29yXG4gICAgICAgKiBzaWRlIGVmZmVjdHMgYXJlIG5vdCBlbmFibGVkIHVudGlsIGFmdGVyIGNsaWVudCBkb20gaXMgZnVsbHkgcmVhZHkuXG4gICAgICAgKiBBbHNvIGNhbGxzIGBfZmx1c2hDbGllbnRzYCBjYWxsYmFjayB0byBlbnN1cmUgY2xpZW50IGRvbSBpcyBlbmFibGVkXG4gICAgICAgKiB0aGF0IHdhcyBub3QgZW5hYmxlZCBhcyBhIHJlc3VsdCBvZiBmbHVzaGluZyBwcm9wZXJ0aWVzLlxuICAgICAgICpcbiAgICAgICAqIEBvdmVycmlkZVxuICAgICAgICovXG4gICAgICByZWFkeSgpIHtcbiAgICAgICAgLy8gSXQgaXMgaW1wb3J0YW50IHRoYXQgYHN1cGVyLnJlYWR5KClgIGlzIG5vdCBjYWxsZWQgaGVyZSBhcyBpdFxuICAgICAgICAvLyBpbW1lZGlhdGVseSB0dXJucyBvbiBhY2Nlc3NvcnMuIEluc3RlYWQsIHdlIHdhaXQgdW50aWwgYHJlYWR5Q2xpZW50c2BcbiAgICAgICAgLy8gdG8gZW5hYmxlIGFjY2Vzc29ycyB0byBwcm92aWRlIGEgZ3VhcmFudGVlIHRoYXQgY2xpZW50cyBhcmUgcmVhZHlcbiAgICAgICAgLy8gYmVmb3JlIHByb2Nlc3NpbmcgYW55IGFjY2Vzc29ycyBzaWRlIGVmZmVjdHMuXG4gICAgICAgIHRoaXMuX2ZsdXNoUHJvcGVydGllcygpO1xuICAgICAgICAvLyBJZiBubyBkYXRhIHdhcyBwZW5kaW5nLCBgX2ZsdXNoUHJvcGVydGllc2Agd2lsbCBub3QgYGZsdXNoQ2xpZW50c2BcbiAgICAgICAgLy8gc28gZW5zdXJlIHRoaXMgaXMgZG9uZS5cbiAgICAgICAgaWYgKCF0aGlzLl9fZGF0YUNsaWVudHNSZWFkeSkge1xuICAgICAgICAgIHRoaXMuX2ZsdXNoQ2xpZW50cygpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEJlZm9yZSByZWFkeSwgY2xpZW50IG5vdGlmaWNhdGlvbnMgZG8gbm90IHRyaWdnZXIgX2ZsdXNoUHJvcGVydGllcy5cbiAgICAgICAgLy8gVGhlcmVmb3JlIGEgZmx1c2ggaXMgbmVjZXNzYXJ5IGhlcmUgaWYgZGF0YSBoYXMgYmVlbiBzZXQuXG4gICAgICAgIGlmICh0aGlzLl9fZGF0YVBlbmRpbmcpIHtcbiAgICAgICAgICB0aGlzLl9mbHVzaFByb3BlcnRpZXMoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEltcGxlbWVudHMgYFByb3BlcnR5QWNjZXNzb3JzYCdzIHByb3BlcnRpZXMgY2hhbmdlZCBjYWxsYmFjay5cbiAgICAgICAqXG4gICAgICAgKiBSdW5zIGVhY2ggY2xhc3Mgb2YgZWZmZWN0cyBmb3IgdGhlIGJhdGNoIG9mIGNoYW5nZWQgcHJvcGVydGllcyBpblxuICAgICAgICogYSBzcGVjaWZpYyBvcmRlciAoY29tcHV0ZSwgcHJvcGFnYXRlLCByZWZsZWN0LCBvYnNlcnZlLCBub3RpZnkpLlxuICAgICAgICpcbiAgICAgICAqIEBvdmVycmlkZVxuICAgICAgICovXG4gICAgICBfcHJvcGVydGllc0NoYW5nZWQoY3VycmVudFByb3BzLCBjaGFuZ2VkUHJvcHMsIG9sZFByb3BzKSB7XG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gbGV0IGMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhjaGFuZ2VkUHJvcHMgfHwge30pO1xuICAgICAgICAvLyB3aW5kb3cuZGVidWcgJiYgY29uc29sZS5ncm91cCh0aGlzLmxvY2FsTmFtZSArICcjJyArIHRoaXMuaWQgKyAnOiAnICsgYyk7XG4gICAgICAgIC8vIGlmICh3aW5kb3cuZGVidWcpIHsgZGVidWdnZXI7IH1cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICBsZXQgaGFzUGF0aHMgPSB0aGlzLl9fZGF0YUhhc1BhdGhzO1xuICAgICAgICB0aGlzLl9fZGF0YUhhc1BhdGhzID0gZmFsc2U7XG4gICAgICAgIC8vIENvbXB1dGUgcHJvcGVydGllc1xuICAgICAgICBydW5Db21wdXRlZEVmZmVjdHModGhpcywgY2hhbmdlZFByb3BzLCBvbGRQcm9wcywgaGFzUGF0aHMpO1xuICAgICAgICAvLyBDbGVhciBub3RpZnkgcHJvcGVydGllcyBwcmlvciB0byBwb3NzaWJsZSByZWVudHJ5IChwcm9wYWdhdGUsIG9ic2VydmUpLFxuICAgICAgICAvLyBidXQgYWZ0ZXIgY29tcHV0aW5nIGVmZmVjdHMgaGF2ZSBhIGNoYW5jZSB0byBhZGQgdG8gdGhlbVxuICAgICAgICBsZXQgbm90aWZ5UHJvcHMgPSB0aGlzLl9fZGF0YVRvTm90aWZ5O1xuICAgICAgICB0aGlzLl9fZGF0YVRvTm90aWZ5ID0gbnVsbDtcbiAgICAgICAgLy8gUHJvcGFnYXRlIHByb3BlcnRpZXMgdG8gY2xpZW50c1xuICAgICAgICB0aGlzLl9wcm9wYWdhdGVQcm9wZXJ0eUNoYW5nZXMoY2hhbmdlZFByb3BzLCBvbGRQcm9wcywgaGFzUGF0aHMpO1xuICAgICAgICAvLyBGbHVzaCBjbGllbnRzXG4gICAgICAgIHRoaXMuX2ZsdXNoQ2xpZW50cygpO1xuICAgICAgICAvLyBSZWZsZWN0IHByb3BlcnRpZXNcbiAgICAgICAgcnVuRWZmZWN0cyh0aGlzLCB0aGlzW1RZUEVTLlJFRkxFQ1RdLCBjaGFuZ2VkUHJvcHMsIG9sZFByb3BzLCBoYXNQYXRocyk7XG4gICAgICAgIC8vIE9ic2VydmUgcHJvcGVydGllc1xuICAgICAgICBydW5FZmZlY3RzKHRoaXMsIHRoaXNbVFlQRVMuT0JTRVJWRV0sIGNoYW5nZWRQcm9wcywgb2xkUHJvcHMsIGhhc1BhdGhzKTtcbiAgICAgICAgLy8gTm90aWZ5IHByb3BlcnRpZXMgdG8gaG9zdFxuICAgICAgICBpZiAobm90aWZ5UHJvcHMpIHtcbiAgICAgICAgICBydW5Ob3RpZnlFZmZlY3RzKHRoaXMsIG5vdGlmeVByb3BzLCBjaGFuZ2VkUHJvcHMsIG9sZFByb3BzLCBoYXNQYXRocyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2xlYXIgdGVtcG9yYXJ5IGNhY2hlIGF0IGVuZCBvZiB0dXJuXG4gICAgICAgIGlmICh0aGlzLl9fZGF0YUNvdW50ZXIgPT0gMSkge1xuICAgICAgICAgIHRoaXMuX19kYXRhVGVtcCA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gd2luZG93LmRlYnVnICYmIGNvbnNvbGUuZ3JvdXBFbmQodGhpcy5sb2NhbE5hbWUgKyAnIycgKyB0aGlzLmlkICsgJzogJyArIGMpO1xuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ2FsbGVkIHRvIHByb3BhZ2F0ZSBhbnkgcHJvcGVydHkgY2hhbmdlcyB0byBzdGFtcGVkIHRlbXBsYXRlIG5vZGVzXG4gICAgICAgKiBtYW5hZ2VkIGJ5IHRoaXMgZWxlbWVudC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2hhbmdlZFByb3BzIEJhZyBvZiBjaGFuZ2VkIHByb3BlcnRpZXNcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvbGRQcm9wcyBCYWcgb2YgcHJldmlvdXMgdmFsdWVzIGZvciBjaGFuZ2VkIHByb3BlcnRpZXNcbiAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaGFzUGF0aHMgVHJ1ZSB3aXRoIGBwcm9wc2AgY29udGFpbnMgb25lIG9yIG1vcmUgcGF0aHNcbiAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAqL1xuICAgICAgX3Byb3BhZ2F0ZVByb3BlcnR5Q2hhbmdlcyhjaGFuZ2VkUHJvcHMsIG9sZFByb3BzLCBoYXNQYXRocykge1xuICAgICAgICBpZiAodGhpc1tUWVBFUy5QUk9QQUdBVEVdKSB7XG4gICAgICAgICAgcnVuRWZmZWN0cyh0aGlzLCB0aGlzW1RZUEVTLlBST1BBR0FURV0sIGNoYW5nZWRQcm9wcywgb2xkUHJvcHMsIGhhc1BhdGhzKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdGVtcGxhdGVJbmZvID0gdGhpcy5fX3RlbXBsYXRlSW5mbztcbiAgICAgICAgd2hpbGUgKHRlbXBsYXRlSW5mbykge1xuICAgICAgICAgIHJ1bkVmZmVjdHModGhpcywgdGVtcGxhdGVJbmZvLnByb3BlcnR5RWZmZWN0cywgY2hhbmdlZFByb3BzLCBvbGRQcm9wcyxcbiAgICAgICAgICAgIGhhc1BhdGhzLCB0ZW1wbGF0ZUluZm8ubm9kZUxpc3QpO1xuICAgICAgICAgIHRlbXBsYXRlSW5mbyA9IHRlbXBsYXRlSW5mby5uZXh0VGVtcGxhdGVJbmZvO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQWxpYXNlcyBvbmUgZGF0YSBwYXRoIGFzIGFub3RoZXIsIHN1Y2ggdGhhdCBwYXRoIG5vdGlmaWNhdGlvbnMgZnJvbSBvbmVcbiAgICAgICAqIGFyZSByb3V0ZWQgdG8gdGhlIG90aGVyLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgIUFycmF5PHN0cmluZ3xudW1iZXI+fSB0byBUYXJnZXQgcGF0aCB0byBsaW5rLlxuICAgICAgICogQHBhcmFtIHtzdHJpbmcgfCAhQXJyYXk8c3RyaW5nfG51bWJlcj59IGZyb20gU291cmNlIHBhdGggdG8gbGluay5cbiAgICAgICAqIEBwdWJsaWNcbiAgICAgICAqL1xuICAgICAgbGlua1BhdGhzKHRvLCBmcm9tKSB7XG4gICAgICAgIHRvID0gUG9seW1lci5QYXRoLm5vcm1hbGl6ZSh0byk7XG4gICAgICAgIGZyb20gPSBQb2x5bWVyLlBhdGgubm9ybWFsaXplKGZyb20pO1xuICAgICAgICB0aGlzLl9fZGF0YUxpbmtlZFBhdGhzID0gdGhpcy5fX2RhdGFMaW5rZWRQYXRocyB8fCB7fTtcbiAgICAgICAgdGhpcy5fX2RhdGFMaW5rZWRQYXRoc1t0b10gPSBmcm9tO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJlbW92ZXMgYSBkYXRhIHBhdGggYWxpYXMgcHJldmlvdXNseSBlc3RhYmxpc2hlZCB3aXRoIGBfbGlua1BhdGhzYC5cbiAgICAgICAqXG4gICAgICAgKiBOb3RlLCB0aGUgcGF0aCB0byB1bmxpbmsgc2hvdWxkIGJlIHRoZSB0YXJnZXQgKGB0b2ApIHVzZWQgd2hlblxuICAgICAgICogbGlua2luZyB0aGUgcGF0aHMuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmcgfCAhQXJyYXk8c3RyaW5nfG51bWJlcj59IHBhdGggVGFyZ2V0IHBhdGggdG8gdW5saW5rLlxuICAgICAgICogQHB1YmxpY1xuICAgICAgICovXG4gICAgICB1bmxpbmtQYXRocyhwYXRoKSB7XG4gICAgICAgIHBhdGggPSBQb2x5bWVyLlBhdGgubm9ybWFsaXplKHBhdGgpO1xuICAgICAgICBpZiAodGhpcy5fX2RhdGFMaW5rZWRQYXRocykge1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLl9fZGF0YUxpbmtlZFBhdGhzW3BhdGhdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogTm90aWZ5IHRoYXQgYW4gYXJyYXkgaGFzIGNoYW5nZWQuXG4gICAgICAgKlxuICAgICAgICogRXhhbXBsZTpcbiAgICAgICAqXG4gICAgICAgKiAgICAgdGhpcy5pdGVtcyA9IFsge25hbWU6ICdKaW0nfSwge25hbWU6ICdUb2RkJ30sIHtuYW1lOiAnQmlsbCd9IF07XG4gICAgICAgKiAgICAgLi4uXG4gICAgICAgKiAgICAgdGhpcy5pdGVtcy5zcGxpY2UoMSwgMSwge25hbWU6ICdTYW0nfSk7XG4gICAgICAgKiAgICAgdGhpcy5pdGVtcy5wdXNoKHtuYW1lOiAnQm9iJ30pO1xuICAgICAgICogICAgIHRoaXMubm90aWZ5U3BsaWNlcygnaXRlbXMnLCBbXG4gICAgICAgKiAgICAgICB7IGluZGV4OiAxLCByZW1vdmVkOiBbe25hbWU6ICdUb2RkJ31dLCBhZGRlZENvdW50OiAxLCBvYmVjdDogdGhpcy5pdGVtcywgdHlwZTogJ3NwbGljZScgfSxcbiAgICAgICAqICAgICAgIHsgaW5kZXg6IDMsIHJlbW92ZWQ6IFtdLCBhZGRlZENvdW50OiAxLCBvYmplY3Q6IHRoaXMuaXRlbXMsIHR5cGU6ICdzcGxpY2UnfVxuICAgICAgICogICAgIF0pO1xuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFBhdGggdGhhdCBzaG91bGQgYmUgbm90aWZpZWQuXG4gICAgICAgKiBAcGFyYW0ge0FycmF5fSBzcGxpY2VzIEFycmF5IG9mIHNwbGljZSByZWNvcmRzIGluZGljYXRpbmcgb3JkZXJlZFxuICAgICAgICogICBjaGFuZ2VzIHRoYXQgb2NjdXJyZWQgdG8gdGhlIGFycmF5LiBFYWNoIHJlY29yZCBzaG91bGQgaGF2ZSB0aGVcbiAgICAgICAqICAgZm9sbG93aW5nIGZpZWxkczpcbiAgICAgICAqICAgICogaW5kZXg6IGluZGV4IGF0IHdoaWNoIHRoZSBjaGFuZ2Ugb2NjdXJyZWRcbiAgICAgICAqICAgICogcmVtb3ZlZDogYXJyYXkgb2YgaXRlbXMgdGhhdCB3ZXJlIHJlbW92ZWQgZnJvbSB0aGlzIGluZGV4XG4gICAgICAgKiAgICAqIGFkZGVkQ291bnQ6IG51bWJlciBvZiBuZXcgaXRlbXMgYWRkZWQgYXQgdGhpcyBpbmRleFxuICAgICAgICogICAgKiBvYmplY3Q6IGEgcmVmZXJlbmNlIHRvIHRoZSBhcnJheSBpbiBxdWVzdGlvblxuICAgICAgICogICAgKiB0eXBlOiB0aGUgc3RyaW5nIGxpdGVyYWwgJ3NwbGljZSdcbiAgICAgICAqXG4gICAgICAgKiAgIE5vdGUgdGhhdCBzcGxpY2UgcmVjb3JkcyBfbXVzdF8gYmUgbm9ybWFsaXplZCBzdWNoIHRoYXQgdGhleSBhcmVcbiAgICAgICAqICAgcmVwb3J0ZWQgaW4gaW5kZXggb3JkZXIgKHJhdyByZXN1bHRzIGZyb20gYE9iamVjdC5vYnNlcnZlYCBhcmUgbm90XG4gICAgICAgKiAgIG9yZGVyZWQgYW5kIG11c3QgYmUgbm9ybWFsaXplZC9tZXJnZWQgYmVmb3JlIG5vdGlmeWluZykuXG4gICAgICAgKiBAcHVibGljXG4gICAgICAqL1xuICAgICAgbm90aWZ5U3BsaWNlcyhwYXRoLCBzcGxpY2VzKSB7XG4gICAgICAgIGxldCBpbmZvID0ge3BhdGg6ICcnfTtcbiAgICAgICAgbGV0IGFycmF5ID0gLyoqIEB0eXBlIHtBcnJheX0gKi8oUG9seW1lci5QYXRoLmdldCh0aGlzLCBwYXRoLCBpbmZvKSk7XG4gICAgICAgIG5vdGlmeVNwbGljZXModGhpcywgYXJyYXksIGluZm8ucGF0aCwgc3BsaWNlcyk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ29udmVuaWVuY2UgbWV0aG9kIGZvciByZWFkaW5nIGEgdmFsdWUgZnJvbSBhIHBhdGguXG4gICAgICAgKlxuICAgICAgICogTm90ZSwgaWYgYW55IHBhcnQgaW4gdGhlIHBhdGggaXMgdW5kZWZpbmVkLCB0aGlzIG1ldGhvZCByZXR1cm5zXG4gICAgICAgKiBgdW5kZWZpbmVkYCAodGhpcyBtZXRob2QgZG9lcyBub3QgdGhyb3cgd2hlbiBkZXJlZmVyZW5jaW5nIHVuZGVmaW5lZFxuICAgICAgICogcGF0aHMpLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7KHN0cmluZ3whQXJyYXk8KHN0cmluZ3xudW1iZXIpPil9IHBhdGggUGF0aCB0byB0aGUgdmFsdWVcbiAgICAgICAqICAgdG8gcmVhZC4gIFRoZSBwYXRoIG1heSBiZSBzcGVjaWZpZWQgYXMgYSBzdHJpbmcgKGUuZy4gYGZvby5iYXIuYmF6YClcbiAgICAgICAqICAgb3IgYW4gYXJyYXkgb2YgcGF0aCBwYXJ0cyAoZS5nLiBgWydmb28uYmFyJywgJ2JheiddYCkuICBOb3RlIHRoYXRcbiAgICAgICAqICAgYnJhY2tldGVkIGV4cHJlc3Npb25zIGFyZSBub3Qgc3VwcG9ydGVkOyBzdHJpbmctYmFzZWQgcGF0aCBwYXJ0c1xuICAgICAgICogICAqbXVzdCogYmUgc2VwYXJhdGVkIGJ5IGRvdHMuICBOb3RlIHRoYXQgd2hlbiBkZXJlZmVyZW5jaW5nIGFycmF5XG4gICAgICAgKiAgIGluZGljZXMsIHRoZSBpbmRleCBtYXkgYmUgdXNlZCBhcyBhIGRvdHRlZCBwYXJ0IGRpcmVjdGx5XG4gICAgICAgKiAgIChlLmcuIGB1c2Vycy4xMi5uYW1lYCBvciBgWyd1c2VycycsIDEyLCAnbmFtZSddYCkuXG4gICAgICAgKiBAcGFyYW0ge09iamVjdD19IHJvb3QgUm9vdCBvYmplY3QgZnJvbSB3aGljaCB0aGUgcGF0aCBpcyBldmFsdWF0ZWQuXG4gICAgICAgKiBAcmV0dXJuIHsqfSBWYWx1ZSBhdCB0aGUgcGF0aCwgb3IgYHVuZGVmaW5lZGAgaWYgYW55IHBhcnQgb2YgdGhlIHBhdGhcbiAgICAgICAqICAgaXMgdW5kZWZpbmVkLlxuICAgICAgICogQHB1YmxpY1xuICAgICAgICovXG4gICAgICBnZXQocGF0aCwgcm9vdCkge1xuICAgICAgICByZXR1cm4gUG9seW1lci5QYXRoLmdldChyb290IHx8IHRoaXMsIHBhdGgpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENvbnZlbmllbmNlIG1ldGhvZCBmb3Igc2V0dGluZyBhIHZhbHVlIHRvIGEgcGF0aCBhbmQgbm90aWZ5aW5nIGFueVxuICAgICAgICogZWxlbWVudHMgYm91bmQgdG8gdGhlIHNhbWUgcGF0aC5cbiAgICAgICAqXG4gICAgICAgKiBOb3RlLCBpZiBhbnkgcGFydCBpbiB0aGUgcGF0aCBleGNlcHQgZm9yIHRoZSBsYXN0IGlzIHVuZGVmaW5lZCxcbiAgICAgICAqIHRoaXMgbWV0aG9kIGRvZXMgbm90aGluZyAodGhpcyBtZXRob2QgZG9lcyBub3QgdGhyb3cgd2hlblxuICAgICAgICogZGVyZWZlcmVuY2luZyB1bmRlZmluZWQgcGF0aHMpLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7KHN0cmluZ3whQXJyYXk8KHN0cmluZ3xudW1iZXIpPil9IHBhdGggUGF0aCB0byB0aGUgdmFsdWVcbiAgICAgICAqICAgdG8gd3JpdGUuICBUaGUgcGF0aCBtYXkgYmUgc3BlY2lmaWVkIGFzIGEgc3RyaW5nIChlLmcuIGAnZm9vLmJhci5iYXonYClcbiAgICAgICAqICAgb3IgYW4gYXJyYXkgb2YgcGF0aCBwYXJ0cyAoZS5nLiBgWydmb28uYmFyJywgJ2JheiddYCkuICBOb3RlIHRoYXRcbiAgICAgICAqICAgYnJhY2tldGVkIGV4cHJlc3Npb25zIGFyZSBub3Qgc3VwcG9ydGVkOyBzdHJpbmctYmFzZWQgcGF0aCBwYXJ0c1xuICAgICAgICogICAqbXVzdCogYmUgc2VwYXJhdGVkIGJ5IGRvdHMuICBOb3RlIHRoYXQgd2hlbiBkZXJlZmVyZW5jaW5nIGFycmF5XG4gICAgICAgKiAgIGluZGljZXMsIHRoZSBpbmRleCBtYXkgYmUgdXNlZCBhcyBhIGRvdHRlZCBwYXJ0IGRpcmVjdGx5XG4gICAgICAgKiAgIChlLmcuIGAndXNlcnMuMTIubmFtZSdgIG9yIGBbJ3VzZXJzJywgMTIsICduYW1lJ11gKS5cbiAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgdG8gc2V0IGF0IHRoZSBzcGVjaWZpZWQgcGF0aC5cbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0PX0gcm9vdCBSb290IG9iamVjdCBmcm9tIHdoaWNoIHRoZSBwYXRoIGlzIGV2YWx1YXRlZC5cbiAgICAgICAqICAgV2hlbiBzcGVjaWZpZWQsIG5vIG5vdGlmaWNhdGlvbiB3aWxsIG9jY3VyLlxuICAgICAgICogQHB1YmxpY1xuICAgICAgKi9cbiAgICAgIHNldChwYXRoLCB2YWx1ZSwgcm9vdCkge1xuICAgICAgICBpZiAocm9vdCkge1xuICAgICAgICAgIFBvbHltZXIuUGF0aC5zZXQocm9vdCwgcGF0aCwgdmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICghdGhpc1tUWVBFUy5SRUFEX09OTFldIHx8ICF0aGlzW1RZUEVTLlJFQURfT05MWV1bLyoqIEB0eXBlIHtzdHJpbmd9ICovKHBhdGgpXSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3NldFBlbmRpbmdQcm9wZXJ0eU9yUGF0aChwYXRoLCB2YWx1ZSwgdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgdGhpcy5faW52YWxpZGF0ZVByb3BlcnRpZXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBBZGRzIGl0ZW1zIG9udG8gdGhlIGVuZCBvZiB0aGUgYXJyYXkgYXQgdGhlIHBhdGggc3BlY2lmaWVkLlxuICAgICAgICpcbiAgICAgICAqIFRoZSBhcmd1bWVudHMgYWZ0ZXIgYHBhdGhgIGFuZCByZXR1cm4gdmFsdWUgbWF0Y2ggdGhhdCBvZlxuICAgICAgICogYEFycmF5LnByb3RvdHlwZS5wdXNoYC5cbiAgICAgICAqXG4gICAgICAgKiBUaGlzIG1ldGhvZCBub3RpZmllcyBvdGhlciBwYXRocyB0byB0aGUgc2FtZSBhcnJheSB0aGF0IGFcbiAgICAgICAqIHNwbGljZSBvY2N1cnJlZCB0byB0aGUgYXJyYXkuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggUGF0aCB0byBhcnJheS5cbiAgICAgICAqIEBwYXJhbSB7Li4uKn0gaXRlbXMgSXRlbXMgdG8gcHVzaCBvbnRvIGFycmF5XG4gICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IE5ldyBsZW5ndGggb2YgdGhlIGFycmF5LlxuICAgICAgICogQHB1YmxpY1xuICAgICAgICovXG4gICAgICBwdXNoKHBhdGgsIC4uLml0ZW1zKSB7XG4gICAgICAgIGxldCBpbmZvID0ge3BhdGg6ICcnfTtcbiAgICAgICAgbGV0IGFycmF5ID0gLyoqIEB0eXBlIHtBcnJheX0qLyhQb2x5bWVyLlBhdGguZ2V0KHRoaXMsIHBhdGgsIGluZm8pKTtcbiAgICAgICAgbGV0IGxlbiA9IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgbGV0IHJldCA9IGFycmF5LnB1c2goLi4uaXRlbXMpO1xuICAgICAgICBpZiAoaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgbm90aWZ5U3BsaWNlKHRoaXMsIGFycmF5LCBpbmZvLnBhdGgsIGxlbiwgaXRlbXMubGVuZ3RoLCBbXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZW1vdmVzIGFuIGl0ZW0gZnJvbSB0aGUgZW5kIG9mIGFycmF5IGF0IHRoZSBwYXRoIHNwZWNpZmllZC5cbiAgICAgICAqXG4gICAgICAgKiBUaGUgYXJndW1lbnRzIGFmdGVyIGBwYXRoYCBhbmQgcmV0dXJuIHZhbHVlIG1hdGNoIHRoYXQgb2ZcbiAgICAgICAqIGBBcnJheS5wcm90b3R5cGUucG9wYC5cbiAgICAgICAqXG4gICAgICAgKiBUaGlzIG1ldGhvZCBub3RpZmllcyBvdGhlciBwYXRocyB0byB0aGUgc2FtZSBhcnJheSB0aGF0IGFcbiAgICAgICAqIHNwbGljZSBvY2N1cnJlZCB0byB0aGUgYXJyYXkuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggUGF0aCB0byBhcnJheS5cbiAgICAgICAqIEByZXR1cm4geyp9IEl0ZW0gdGhhdCB3YXMgcmVtb3ZlZC5cbiAgICAgICAqIEBwdWJsaWNcbiAgICAgICAqL1xuICAgICAgcG9wKHBhdGgpIHtcbiAgICAgICAgbGV0IGluZm8gPSB7cGF0aDogJyd9O1xuICAgICAgICBsZXQgYXJyYXkgPSAvKiogQHR5cGUge0FycmF5fSAqLyhQb2x5bWVyLlBhdGguZ2V0KHRoaXMsIHBhdGgsIGluZm8pKTtcbiAgICAgICAgbGV0IGhhZExlbmd0aCA9IEJvb2xlYW4oYXJyYXkubGVuZ3RoKTtcbiAgICAgICAgbGV0IHJldCA9IGFycmF5LnBvcCgpO1xuICAgICAgICBpZiAoaGFkTGVuZ3RoKSB7XG4gICAgICAgICAgbm90aWZ5U3BsaWNlKHRoaXMsIGFycmF5LCBpbmZvLnBhdGgsIGFycmF5Lmxlbmd0aCwgMCwgW3JldF0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogU3RhcnRpbmcgZnJvbSB0aGUgc3RhcnQgaW5kZXggc3BlY2lmaWVkLCByZW1vdmVzIDAgb3IgbW9yZSBpdGVtc1xuICAgICAgICogZnJvbSB0aGUgYXJyYXkgYW5kIGluc2VydHMgMCBvciBtb3JlIG5ldyBpdGVtcyBpbiB0aGVpciBwbGFjZS5cbiAgICAgICAqXG4gICAgICAgKiBUaGUgYXJndW1lbnRzIGFmdGVyIGBwYXRoYCBhbmQgcmV0dXJuIHZhbHVlIG1hdGNoIHRoYXQgb2ZcbiAgICAgICAqIGBBcnJheS5wcm90b3R5cGUuc3BsaWNlYC5cbiAgICAgICAqXG4gICAgICAgKiBUaGlzIG1ldGhvZCBub3RpZmllcyBvdGhlciBwYXRocyB0byB0aGUgc2FtZSBhcnJheSB0aGF0IGFcbiAgICAgICAqIHNwbGljZSBvY2N1cnJlZCB0byB0aGUgYXJyYXkuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggUGF0aCB0byBhcnJheS5cbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBJbmRleCBmcm9tIHdoaWNoIHRvIHN0YXJ0IHJlbW92aW5nL2luc2VydGluZy5cbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkZWxldGVDb3VudCBOdW1iZXIgb2YgaXRlbXMgdG8gcmVtb3ZlLlxuICAgICAgICogQHBhcmFtIHsuLi4qfSBpdGVtcyBJdGVtcyB0byBpbnNlcnQgaW50byBhcnJheS5cbiAgICAgICAqIEByZXR1cm4ge0FycmF5fSBBcnJheSBvZiByZW1vdmVkIGl0ZW1zLlxuICAgICAgICogQHB1YmxpY1xuICAgICAgICovXG4gICAgICBzcGxpY2UocGF0aCwgc3RhcnQsIGRlbGV0ZUNvdW50LCAuLi5pdGVtcykge1xuICAgICAgICBsZXQgaW5mbyA9IHtwYXRoIDogJyd9O1xuICAgICAgICBsZXQgYXJyYXkgPSAvKiogQHR5cGUge0FycmF5fSAqLyhQb2x5bWVyLlBhdGguZ2V0KHRoaXMsIHBhdGgsIGluZm8pKTtcbiAgICAgICAgLy8gTm9ybWFsaXplIGZhbmN5IG5hdGl2ZSBzcGxpY2UgaGFuZGxpbmcgb2YgY3Jhenkgc3RhcnQgdmFsdWVzXG4gICAgICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgICAgICBzdGFydCA9IGFycmF5Lmxlbmd0aCAtIE1hdGguZmxvb3IoLXN0YXJ0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdGFydCA9IE1hdGguZmxvb3Ioc3RhcnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc3RhcnQpIHtcbiAgICAgICAgICBzdGFydCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJldCA9IGFycmF5LnNwbGljZShzdGFydCwgZGVsZXRlQ291bnQsIC4uLml0ZW1zKTtcbiAgICAgICAgaWYgKGl0ZW1zLmxlbmd0aCB8fCByZXQubGVuZ3RoKSB7XG4gICAgICAgICAgbm90aWZ5U3BsaWNlKHRoaXMsIGFycmF5LCBpbmZvLnBhdGgsIHN0YXJ0LCBpdGVtcy5sZW5ndGgsIHJldCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZW1vdmVzIGFuIGl0ZW0gZnJvbSB0aGUgYmVnaW5uaW5nIG9mIGFycmF5IGF0IHRoZSBwYXRoIHNwZWNpZmllZC5cbiAgICAgICAqXG4gICAgICAgKiBUaGUgYXJndW1lbnRzIGFmdGVyIGBwYXRoYCBhbmQgcmV0dXJuIHZhbHVlIG1hdGNoIHRoYXQgb2ZcbiAgICAgICAqIGBBcnJheS5wcm90b3R5cGUucG9wYC5cbiAgICAgICAqXG4gICAgICAgKiBUaGlzIG1ldGhvZCBub3RpZmllcyBvdGhlciBwYXRocyB0byB0aGUgc2FtZSBhcnJheSB0aGF0IGFcbiAgICAgICAqIHNwbGljZSBvY2N1cnJlZCB0byB0aGUgYXJyYXkuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggUGF0aCB0byBhcnJheS5cbiAgICAgICAqIEByZXR1cm4geyp9IEl0ZW0gdGhhdCB3YXMgcmVtb3ZlZC5cbiAgICAgICAqIEBwdWJsaWNcbiAgICAgICAqL1xuICAgICAgc2hpZnQocGF0aCkge1xuICAgICAgICBsZXQgaW5mbyA9IHtwYXRoOiAnJ307XG4gICAgICAgIGxldCBhcnJheSA9IC8qKiBAdHlwZSB7QXJyYXl9ICovKFBvbHltZXIuUGF0aC5nZXQodGhpcywgcGF0aCwgaW5mbykpO1xuICAgICAgICBsZXQgaGFkTGVuZ3RoID0gQm9vbGVhbihhcnJheS5sZW5ndGgpO1xuICAgICAgICBsZXQgcmV0ID0gYXJyYXkuc2hpZnQoKTtcbiAgICAgICAgaWYgKGhhZExlbmd0aCkge1xuICAgICAgICAgIG5vdGlmeVNwbGljZSh0aGlzLCBhcnJheSwgaW5mby5wYXRoLCAwLCAwLCBbcmV0XSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBBZGRzIGl0ZW1zIG9udG8gdGhlIGJlZ2lubmluZyBvZiB0aGUgYXJyYXkgYXQgdGhlIHBhdGggc3BlY2lmaWVkLlxuICAgICAgICpcbiAgICAgICAqIFRoZSBhcmd1bWVudHMgYWZ0ZXIgYHBhdGhgIGFuZCByZXR1cm4gdmFsdWUgbWF0Y2ggdGhhdCBvZlxuICAgICAgICogYEFycmF5LnByb3RvdHlwZS5wdXNoYC5cbiAgICAgICAqXG4gICAgICAgKiBUaGlzIG1ldGhvZCBub3RpZmllcyBvdGhlciBwYXRocyB0byB0aGUgc2FtZSBhcnJheSB0aGF0IGFcbiAgICAgICAqIHNwbGljZSBvY2N1cnJlZCB0byB0aGUgYXJyYXkuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggUGF0aCB0byBhcnJheS5cbiAgICAgICAqIEBwYXJhbSB7Li4uKn0gaXRlbXMgSXRlbXMgdG8gaW5zZXJ0IGluZm8gYXJyYXlcbiAgICAgICAqIEByZXR1cm4ge251bWJlcn0gTmV3IGxlbmd0aCBvZiB0aGUgYXJyYXkuXG4gICAgICAgKiBAcHVibGljXG4gICAgICAgKi9cbiAgICAgIHVuc2hpZnQocGF0aCwgLi4uaXRlbXMpIHtcbiAgICAgICAgbGV0IGluZm8gPSB7cGF0aDogJyd9O1xuICAgICAgICBsZXQgYXJyYXkgPSAvKiogQHR5cGUge0FycmF5fSAqLyhQb2x5bWVyLlBhdGguZ2V0KHRoaXMsIHBhdGgsIGluZm8pKTtcbiAgICAgICAgbGV0IHJldCA9IGFycmF5LnVuc2hpZnQoLi4uaXRlbXMpO1xuICAgICAgICBpZiAoaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgbm90aWZ5U3BsaWNlKHRoaXMsIGFycmF5LCBpbmZvLnBhdGgsIDAsIGl0ZW1zLmxlbmd0aCwgW10pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogTm90aWZ5IHRoYXQgYSBwYXRoIGhhcyBjaGFuZ2VkLlxuICAgICAgICpcbiAgICAgICAqIEV4YW1wbGU6XG4gICAgICAgKlxuICAgICAgICogICAgIHRoaXMuaXRlbS51c2VyLm5hbWUgPSAnQm9iJztcbiAgICAgICAqICAgICB0aGlzLm5vdGlmeVBhdGgoJ2l0ZW0udXNlci5uYW1lJyk7XG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggUGF0aCB0aGF0IHNob3VsZCBiZSBub3RpZmllZC5cbiAgICAgICAqIEBwYXJhbSB7Kj19IHZhbHVlIFZhbHVlIGF0IHRoZSBwYXRoIChvcHRpb25hbCkuXG4gICAgICAgKiBAcHVibGljXG4gICAgICAqL1xuICAgICAgbm90aWZ5UGF0aChwYXRoLCB2YWx1ZSkge1xuICAgICAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgICAgICAgbGV0IHByb3BQYXRoO1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgLy8gR2V0IHZhbHVlIGlmIG5vdCBzdXBwbGllZFxuICAgICAgICAgIGxldCBpbmZvID0ge3BhdGg6ICcnfTtcbiAgICAgICAgICB2YWx1ZSA9IFBvbHltZXIuUGF0aC5nZXQodGhpcywgcGF0aCwgaW5mbyk7XG4gICAgICAgICAgcHJvcFBhdGggPSBpbmZvLnBhdGg7XG4gICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShwYXRoKSkge1xuICAgICAgICAgIC8vIE5vcm1hbGl6ZSBwYXRoIGlmIG5lZWRlZFxuICAgICAgICAgIHByb3BQYXRoID0gUG9seW1lci5QYXRoLm5vcm1hbGl6ZShwYXRoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcm9wUGF0aCA9IC8qKiBAdHlwZXtzdHJpbmd9ICovKHBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9zZXRQZW5kaW5nUHJvcGVydHlPclBhdGgocHJvcFBhdGgsIHZhbHVlLCB0cnVlLCB0cnVlKSkge1xuICAgICAgICAgIHRoaXMuX2ludmFsaWRhdGVQcm9wZXJ0aWVzKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBFcXVpdmFsZW50IHRvIHN0YXRpYyBgY3JlYXRlUmVhZE9ubHlQcm9wZXJ0eWAgQVBJIGJ1dCBjYW4gYmUgY2FsbGVkIG9uXG4gICAgICAgKiBhbiBpbnN0YW5jZSB0byBhZGQgZWZmZWN0cyBhdCBydW50aW1lLiAgU2VlIHRoYXQgbWV0aG9kIGZvclxuICAgICAgICogZnVsbCBBUEkgZG9jcy5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgbmFtZVxuICAgICAgICogQHBhcmFtIHtib29sZWFuPX0gcHJvdGVjdGVkU2V0dGVyIENyZWF0ZXMgYSBjdXN0b20gcHJvdGVjdGVkIHNldHRlclxuICAgICAgICogICB3aGVuIGB0cnVlYC5cbiAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAqL1xuICAgICAgX2NyZWF0ZVJlYWRPbmx5UHJvcGVydHkocHJvcGVydHksIHByb3RlY3RlZFNldHRlcikge1xuICAgICAgICB0aGlzLl9hZGRQcm9wZXJ0eUVmZmVjdChwcm9wZXJ0eSwgVFlQRVMuUkVBRF9PTkxZKTtcbiAgICAgICAgaWYgKHByb3RlY3RlZFNldHRlcikge1xuICAgICAgICAgIHRoaXNbJ19zZXQnICsgdXBwZXIocHJvcGVydHkpXSA9IC8qKiBAdGhpcyB7UHJvcGVydHlFZmZlY3RzfSAqL2Z1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9zZXRQcm9wZXJ0eShwcm9wZXJ0eSwgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEVxdWl2YWxlbnQgdG8gc3RhdGljIGBjcmVhdGVQcm9wZXJ0eU9ic2VydmVyYCBBUEkgYnV0IGNhbiBiZSBjYWxsZWQgb25cbiAgICAgICAqIGFuIGluc3RhbmNlIHRvIGFkZCBlZmZlY3RzIGF0IHJ1bnRpbWUuICBTZWUgdGhhdCBtZXRob2QgZm9yXG4gICAgICAgKiBmdWxsIEFQSSBkb2NzLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSBuYW1lXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kTmFtZSBOYW1lIG9mIG9ic2VydmVyIG1ldGhvZCB0byBjYWxsXG4gICAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBkeW5hbWljRm4gV2hldGhlciB0aGUgbWV0aG9kIG5hbWUgc2hvdWxkIGJlIGluY2x1ZGVkIGFzXG4gICAgICAgKiAgIGEgZGVwZW5kZW5jeSB0byB0aGUgZWZmZWN0LlxuICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICovXG4gICAgICBfY3JlYXRlUHJvcGVydHlPYnNlcnZlcihwcm9wZXJ0eSwgbWV0aG9kTmFtZSwgZHluYW1pY0ZuKSB7XG4gICAgICAgIGxldCBpbmZvID0geyBwcm9wZXJ0eSwgbWV0aG9kTmFtZSwgZHluYW1pY0ZuOiBCb29sZWFuKGR5bmFtaWNGbikgfTtcbiAgICAgICAgdGhpcy5fYWRkUHJvcGVydHlFZmZlY3QocHJvcGVydHksIFRZUEVTLk9CU0VSVkUsIHtcbiAgICAgICAgICBmbjogcnVuT2JzZXJ2ZXJFZmZlY3QsIGluZm8sIHRyaWdnZXI6IHtuYW1lOiBwcm9wZXJ0eX1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChkeW5hbWljRm4pIHtcbiAgICAgICAgICB0aGlzLl9hZGRQcm9wZXJ0eUVmZmVjdChtZXRob2ROYW1lLCBUWVBFUy5PQlNFUlZFLCB7XG4gICAgICAgICAgICBmbjogcnVuT2JzZXJ2ZXJFZmZlY3QsIGluZm8sIHRyaWdnZXI6IHtuYW1lOiBtZXRob2ROYW1lfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogRXF1aXZhbGVudCB0byBzdGF0aWMgYGNyZWF0ZU1ldGhvZE9ic2VydmVyYCBBUEkgYnV0IGNhbiBiZSBjYWxsZWQgb25cbiAgICAgICAqIGFuIGluc3RhbmNlIHRvIGFkZCBlZmZlY3RzIGF0IHJ1bnRpbWUuICBTZWUgdGhhdCBtZXRob2QgZm9yXG4gICAgICAgKiBmdWxsIEFQSSBkb2NzLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBleHByZXNzaW9uIE1ldGhvZCBleHByZXNzaW9uXG4gICAgICAgKiBAcGFyYW0ge2Jvb2xlYW58T2JqZWN0PX0gZHluYW1pY0ZuIEJvb2xlYW4gb3Igb2JqZWN0IG1hcCBpbmRpY2F0aW5nXG4gICAgICAgKiAgIHdoZXRoZXIgbWV0aG9kIG5hbWVzIHNob3VsZCBiZSBpbmNsdWRlZCBhcyBhIGRlcGVuZGVuY3kgdG8gdGhlIGVmZmVjdC5cbiAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAqL1xuICAgICAgX2NyZWF0ZU1ldGhvZE9ic2VydmVyKGV4cHJlc3Npb24sIGR5bmFtaWNGbikge1xuICAgICAgICBsZXQgc2lnID0gcGFyc2VNZXRob2QoZXhwcmVzc2lvbik7XG4gICAgICAgIGlmICghc2lnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWFsZm9ybWVkIG9ic2VydmVyIGV4cHJlc3Npb24gJ1wiICsgZXhwcmVzc2lvbiArIFwiJ1wiKTtcbiAgICAgICAgfVxuICAgICAgICBjcmVhdGVNZXRob2RFZmZlY3QodGhpcywgc2lnLCBUWVBFUy5PQlNFUlZFLCBydW5NZXRob2RFZmZlY3QsIG51bGwsIGR5bmFtaWNGbik7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogRXF1aXZhbGVudCB0byBzdGF0aWMgYGNyZWF0ZU5vdGlmeWluZ1Byb3BlcnR5YCBBUEkgYnV0IGNhbiBiZSBjYWxsZWQgb25cbiAgICAgICAqIGFuIGluc3RhbmNlIHRvIGFkZCBlZmZlY3RzIGF0IHJ1bnRpbWUuICBTZWUgdGhhdCBtZXRob2QgZm9yXG4gICAgICAgKiBmdWxsIEFQSSBkb2NzLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSBuYW1lXG4gICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgKi9cbiAgICAgIF9jcmVhdGVOb3RpZnlpbmdQcm9wZXJ0eShwcm9wZXJ0eSkge1xuICAgICAgICB0aGlzLl9hZGRQcm9wZXJ0eUVmZmVjdChwcm9wZXJ0eSwgVFlQRVMuTk9USUZZLCB7XG4gICAgICAgICAgZm46IHJ1bk5vdGlmeUVmZmVjdCxcbiAgICAgICAgICBpbmZvOiB7XG4gICAgICAgICAgICBldmVudE5hbWU6IENhc2VNYXAuY2FtZWxUb0Rhc2hDYXNlKHByb3BlcnR5KSArICctY2hhbmdlZCcsXG4gICAgICAgICAgICBwcm9wZXJ0eTogcHJvcGVydHlcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEVxdWl2YWxlbnQgdG8gc3RhdGljIGBjcmVhdGVSZWZsZWN0ZWRQcm9wZXJ0eWAgQVBJIGJ1dCBjYW4gYmUgY2FsbGVkIG9uXG4gICAgICAgKiBhbiBpbnN0YW5jZSB0byBhZGQgZWZmZWN0cyBhdCBydW50aW1lLiAgU2VlIHRoYXQgbWV0aG9kIGZvclxuICAgICAgICogZnVsbCBBUEkgZG9jcy5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgbmFtZVxuICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICovXG4gICAgICBfY3JlYXRlUmVmbGVjdGVkUHJvcGVydHkocHJvcGVydHkpIHtcbiAgICAgICAgbGV0IGF0dHIgPSBDYXNlTWFwLmNhbWVsVG9EYXNoQ2FzZShwcm9wZXJ0eSk7XG4gICAgICAgIGlmIChhdHRyWzBdID09PSAnLScpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ1Byb3BlcnR5ICcgKyBwcm9wZXJ0eSArICcgY2Fubm90IGJlIHJlZmxlY3RlZCB0byBhdHRyaWJ1dGUgJyArXG4gICAgICAgICAgICBhdHRyICsgJyBiZWNhdXNlIFwiLVwiIGlzIG5vdCBhIHZhbGlkIHN0YXJ0aW5nIGF0dHJpYnV0ZSBuYW1lLiBVc2UgYSBsb3dlcmNhc2UgZmlyc3QgbGV0dGVyIGZvciB0aGUgcHJvcGVydHkgdGhpc2VhZC4nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9hZGRQcm9wZXJ0eUVmZmVjdChwcm9wZXJ0eSwgVFlQRVMuUkVGTEVDVCwge1xuICAgICAgICAgICAgZm46IHJ1blJlZmxlY3RFZmZlY3QsXG4gICAgICAgICAgICBpbmZvOiB7XG4gICAgICAgICAgICAgIGF0dHJOYW1lOiBhdHRyXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBFcXVpdmFsZW50IHRvIHN0YXRpYyBgY3JlYXRlQ29tcHV0ZWRQcm9wZXJ0eWAgQVBJIGJ1dCBjYW4gYmUgY2FsbGVkIG9uXG4gICAgICAgKiBhbiBpbnN0YW5jZSB0byBhZGQgZWZmZWN0cyBhdCBydW50aW1lLiAgU2VlIHRoYXQgbWV0aG9kIGZvclxuICAgICAgICogZnVsbCBBUEkgZG9jcy5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgTmFtZSBvZiBjb21wdXRlZCBwcm9wZXJ0eSB0byBzZXRcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBleHByZXNzaW9uIE1ldGhvZCBleHByZXNzaW9uXG4gICAgICAgKiBAcGFyYW0ge2Jvb2xlYW58T2JqZWN0PX0gZHluYW1pY0ZuIEJvb2xlYW4gb3Igb2JqZWN0IG1hcCBpbmRpY2F0aW5nXG4gICAgICAgKiAgIHdoZXRoZXIgbWV0aG9kIG5hbWVzIHNob3VsZCBiZSBpbmNsdWRlZCBhcyBhIGRlcGVuZGVuY3kgdG8gdGhlIGVmZmVjdC5cbiAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAqL1xuICAgICAgX2NyZWF0ZUNvbXB1dGVkUHJvcGVydHkocHJvcGVydHksIGV4cHJlc3Npb24sIGR5bmFtaWNGbikge1xuICAgICAgICBsZXQgc2lnID0gcGFyc2VNZXRob2QoZXhwcmVzc2lvbik7XG4gICAgICAgIGlmICghc2lnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWFsZm9ybWVkIGNvbXB1dGVkIGV4cHJlc3Npb24gJ1wiICsgZXhwcmVzc2lvbiArIFwiJ1wiKTtcbiAgICAgICAgfVxuICAgICAgICBjcmVhdGVNZXRob2RFZmZlY3QodGhpcywgc2lnLCBUWVBFUy5DT01QVVRFLCBydW5Db21wdXRlZEVmZmVjdCwgcHJvcGVydHksIGR5bmFtaWNGbik7XG4gICAgICB9XG5cbiAgICAgIC8vIC0tIHN0YXRpYyBjbGFzcyBtZXRob2RzIC0tLS0tLS0tLS0tLVxuXG4gICAgICAvKipcbiAgICAgICAqIEVuc3VyZXMgYW4gYWNjZXNzb3IgZXhpc3RzIGZvciB0aGUgc3BlY2lmaWVkIHByb3BlcnR5LCBhbmQgYWRkc1xuICAgICAgICogdG8gYSBsaXN0IG9mIFwicHJvcGVydHkgZWZmZWN0c1wiIHRoYXQgd2lsbCBydW4gd2hlbiB0aGUgYWNjZXNzb3IgZm9yXG4gICAgICAgKiB0aGUgc3BlY2lmaWVkIHByb3BlcnR5IGlzIHNldC4gIEVmZmVjdHMgYXJlIGdyb3VwZWQgYnkgXCJ0eXBlXCIsIHdoaWNoXG4gICAgICAgKiByb3VnaGx5IGNvcnJlc3BvbmRzIHRvIGEgcGhhc2UgaW4gZWZmZWN0IHByb2Nlc3NpbmcuICBUaGUgZWZmZWN0XG4gICAgICAgKiBtZXRhZGF0YSBzaG91bGQgYmUgaW4gdGhlIGZvbGxvd2luZyBmb3JtOlxuICAgICAgICpcbiAgICAgICAqICAge1xuICAgICAgICogICAgIGZuOiBlZmZlY3RGdW5jdGlvbiwgLy8gUmVmZXJlbmNlIHRvIGZ1bmN0aW9uIHRvIGNhbGwgdG8gcGVyZm9ybSBlZmZlY3RcbiAgICAgICAqICAgICBpbmZvOiB7IC4uLiB9ICAgICAgIC8vIEVmZmVjdCBtZXRhZGF0YSBwYXNzZWQgdG8gZnVuY3Rpb25cbiAgICAgICAqICAgICB0cmlnZ2VyOiB7ICAgICAgICAgIC8vIE9wdGlvbmFsIHRyaWdnZXJpbmcgbWV0YWRhdGE7IGlmIG5vdCBwcm92aWRlZFxuICAgICAgICogICAgICAgbmFtZTogc3RyaW5nICAgICAgLy8gdGhlIHByb3BlcnR5IGlzIHRyZWF0ZWQgYXMgYSB3aWxkY2FyZFxuICAgICAgICogICAgICAgc3RydWN0dXJlZDogYm9vbGVhblxuICAgICAgICogICAgICAgd2lsZGNhcmQ6IGJvb2xlYW5cbiAgICAgICAqICAgICB9XG4gICAgICAgKiAgIH1cbiAgICAgICAqXG4gICAgICAgKiBFZmZlY3RzIGFyZSBjYWxsZWQgZnJvbSBgX3Byb3BlcnRpZXNDaGFuZ2VkYCBpbiB0aGUgZm9sbG93aW5nIG9yZGVyIGJ5XG4gICAgICAgKiB0eXBlOlxuICAgICAgICpcbiAgICAgICAqIDEuIENPTVBVVEVcbiAgICAgICAqIDIuIFBST1BBR0FURVxuICAgICAgICogMy4gUkVGTEVDVFxuICAgICAgICogNC4gT0JTRVJWRVxuICAgICAgICogNS4gTk9USUZZXG4gICAgICAgKlxuICAgICAgICogRWZmZWN0IGZ1bmN0aW9ucyBhcmUgY2FsbGVkIHdpdGggdGhlIGZvbGxvd2luZyBzaWduYXR1cmU6XG4gICAgICAgKlxuICAgICAgICogICBlZmZlY3RGdW5jdGlvbihpbnN0LCBwYXRoLCBwcm9wcywgb2xkUHJvcHMsIGluZm8sIGhhc1BhdGhzKVxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSB0aGF0IHNob3VsZCB0cmlnZ2VyIHRoZSBlZmZlY3RcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIEVmZmVjdCB0eXBlLCBmcm9tIHRoaXMuUFJPUEVSVFlfRUZGRUNUX1RZUEVTXG4gICAgICAgKiBAcGFyYW0ge09iamVjdD19IGVmZmVjdCBFZmZlY3QgbWV0YWRhdGEgb2JqZWN0XG4gICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgKi9cbiAgICAgIHN0YXRpYyBhZGRQcm9wZXJ0eUVmZmVjdChwcm9wZXJ0eSwgdHlwZSwgZWZmZWN0KSB7XG4gICAgICAgIHRoaXMucHJvdG90eXBlLl9hZGRQcm9wZXJ0eUVmZmVjdChwcm9wZXJ0eSwgdHlwZSwgZWZmZWN0KTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDcmVhdGVzIGEgc2luZ2xlLXByb3BlcnR5IG9ic2VydmVyIGZvciB0aGUgZ2l2ZW4gcHJvcGVydHkuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IG5hbWVcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2ROYW1lIE5hbWUgb2Ygb2JzZXJ2ZXIgbWV0aG9kIHRvIGNhbGxcbiAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IGR5bmFtaWNGbiBXaGV0aGVyIHRoZSBtZXRob2QgbmFtZSBzaG91bGQgYmUgaW5jbHVkZWQgYXNcbiAgICAgICAqICAgYSBkZXBlbmRlbmN5IHRvIHRoZSBlZmZlY3QuXG4gICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgKi9cbiAgICAgIHN0YXRpYyBjcmVhdGVQcm9wZXJ0eU9ic2VydmVyKHByb3BlcnR5LCBtZXRob2ROYW1lLCBkeW5hbWljRm4pIHtcbiAgICAgICAgdGhpcy5wcm90b3R5cGUuX2NyZWF0ZVByb3BlcnR5T2JzZXJ2ZXIocHJvcGVydHksIG1ldGhvZE5hbWUsIGR5bmFtaWNGbik7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ3JlYXRlcyBhIG11bHRpLXByb3BlcnR5IFwibWV0aG9kIG9ic2VydmVyXCIgYmFzZWQgb24gdGhlIHByb3ZpZGVkXG4gICAgICAgKiBleHByZXNzaW9uLCB3aGljaCBzaG91bGQgYmUgYSBzdHJpbmcgaW4gdGhlIGZvcm0gb2YgYSBub3JtYWwgSmF2YXNjcmlwdFxuICAgICAgICogZnVuY3Rpb24gc2lnbmF0dXJlOiBgJ21ldGhvZE5hbWUoYXJnMSwgWy4uLiwgYXJnbl0pJ2AuICBFYWNoIGFyZ3VtZW50XG4gICAgICAgKiBzaG91bGQgY29ycmVzcG9uZCB0byBhIHByb3BlcnR5IG9yIHBhdGggaW4gdGhlIGNvbnRleHQgb2YgdGhpc1xuICAgICAgICogcHJvdG90eXBlIChvciBpbnN0YW5jZSksIG9yIG1heSBiZSBhIGxpdGVyYWwgc3RyaW5nIG9yIG51bWJlci5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXhwcmVzc2lvbiBNZXRob2QgZXhwcmVzc2lvblxuICAgICAgICogQHBhcmFtIHtib29sZWFufE9iamVjdD19IGR5bmFtaWNGbiBCb29sZWFuIG9yIG9iamVjdCBtYXAgaW5kaWNhdGluZ1xuICAgICAgICogICB3aGV0aGVyIG1ldGhvZCBuYW1lcyBzaG91bGQgYmUgaW5jbHVkZWQgYXMgYSBkZXBlbmRlbmN5IHRvIHRoZSBlZmZlY3QuXG4gICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgKi9cbiAgICAgIHN0YXRpYyBjcmVhdGVNZXRob2RPYnNlcnZlcihleHByZXNzaW9uLCBkeW5hbWljRm4pIHtcbiAgICAgICAgdGhpcy5wcm90b3R5cGUuX2NyZWF0ZU1ldGhvZE9ic2VydmVyKGV4cHJlc3Npb24sIGR5bmFtaWNGbik7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ2F1c2VzIHRoZSBzZXR0ZXIgZm9yIHRoZSBnaXZlbiBwcm9wZXJ0eSB0byBkaXNwYXRjaCBgPHByb3BlcnR5Pi1jaGFuZ2VkYFxuICAgICAgICogZXZlbnRzIHRvIG5vdGlmeSBvZiBjaGFuZ2VzIHRvIHRoZSBwcm9wZXJ0eS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgbmFtZVxuICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICovXG4gICAgICBzdGF0aWMgY3JlYXRlTm90aWZ5aW5nUHJvcGVydHkocHJvcGVydHkpIHtcbiAgICAgICAgdGhpcy5wcm90b3R5cGUuX2NyZWF0ZU5vdGlmeWluZ1Byb3BlcnR5KHByb3BlcnR5KTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDcmVhdGVzIGEgcmVhZC1vbmx5IGFjY2Vzc29yIGZvciB0aGUgZ2l2ZW4gcHJvcGVydHkuXG4gICAgICAgKlxuICAgICAgICogVG8gc2V0IHRoZSBwcm9wZXJ0eSwgdXNlIHRoZSBwcm90ZWN0ZWQgYF9zZXRQcm9wZXJ0eWAgQVBJLlxuICAgICAgICogVG8gY3JlYXRlIGEgY3VzdG9tIHByb3RlY3RlZCBzZXR0ZXIgKGUuZy4gYF9zZXRNeVByb3AoKWAgZm9yXG4gICAgICAgKiBwcm9wZXJ0eSBgbXlQcm9wYCksIHBhc3MgYHRydWVgIGZvciBgcHJvdGVjdGVkU2V0dGVyYC5cbiAgICAgICAqXG4gICAgICAgKiBOb3RlLCBpZiB0aGUgcHJvcGVydHkgd2lsbCBoYXZlIG90aGVyIHByb3BlcnR5IGVmZmVjdHMsIHRoaXMgbWV0aG9kXG4gICAgICAgKiBzaG91bGQgYmUgY2FsbGVkIGZpcnN0LCBiZWZvcmUgYWRkaW5nIG90aGVyIGVmZmVjdHMuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IG5hbWVcbiAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IHByb3RlY3RlZFNldHRlciBDcmVhdGVzIGEgY3VzdG9tIHByb3RlY3RlZCBzZXR0ZXJcbiAgICAgICAqICAgd2hlbiBgdHJ1ZWAuXG4gICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgKi9cbiAgICAgIHN0YXRpYyBjcmVhdGVSZWFkT25seVByb3BlcnR5KHByb3BlcnR5LCBwcm90ZWN0ZWRTZXR0ZXIpIHtcbiAgICAgICAgdGhpcy5wcm90b3R5cGUuX2NyZWF0ZVJlYWRPbmx5UHJvcGVydHkocHJvcGVydHksIHByb3RlY3RlZFNldHRlcik7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ2F1c2VzIHRoZSBzZXR0ZXIgZm9yIHRoZSBnaXZlbiBwcm9wZXJ0eSB0byByZWZsZWN0IHRoZSBwcm9wZXJ0eSB2YWx1ZVxuICAgICAgICogdG8gYSAoZGFzaC1jYXNlZCkgYXR0cmlidXRlIG9mIHRoZSBzYW1lIG5hbWUuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IG5hbWVcbiAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAqL1xuICAgICAgc3RhdGljIGNyZWF0ZVJlZmxlY3RlZFByb3BlcnR5KHByb3BlcnR5KSB7XG4gICAgICAgIHRoaXMucHJvdG90eXBlLl9jcmVhdGVSZWZsZWN0ZWRQcm9wZXJ0eShwcm9wZXJ0eSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ3JlYXRlcyBhIGNvbXB1dGVkIHByb3BlcnR5IHdob3NlIHZhbHVlIGlzIHNldCB0byB0aGUgcmVzdWx0IG9mIHRoZVxuICAgICAgICogbWV0aG9kIGRlc2NyaWJlZCBieSB0aGUgZ2l2ZW4gYGV4cHJlc3Npb25gIGVhY2ggdGltZSBvbmUgb3IgbW9yZVxuICAgICAgICogYXJndW1lbnRzIHRvIHRoZSBtZXRob2QgY2hhbmdlcy4gIFRoZSBleHByZXNzaW9uIHNob3VsZCBiZSBhIHN0cmluZ1xuICAgICAgICogaW4gdGhlIGZvcm0gb2YgYSBub3JtYWwgSmF2YXNjcmlwdCBmdW5jdGlvbiBzaWduYXR1cmU6XG4gICAgICAgKiBgJ21ldGhvZE5hbWUoYXJnMSwgWy4uLiwgYXJnbl0pJ2BcbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgTmFtZSBvZiBjb21wdXRlZCBwcm9wZXJ0eSB0byBzZXRcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBleHByZXNzaW9uIE1ldGhvZCBleHByZXNzaW9uXG4gICAgICAgKiBAcGFyYW0ge2Jvb2xlYW58T2JqZWN0PX0gZHluYW1pY0ZuIEJvb2xlYW4gb3Igb2JqZWN0IG1hcCBpbmRpY2F0aW5nIHdoZXRoZXJcbiAgICAgICAqICAgbWV0aG9kIG5hbWVzIHNob3VsZCBiZSBpbmNsdWRlZCBhcyBhIGRlcGVuZGVuY3kgdG8gdGhlIGVmZmVjdC5cbiAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAqL1xuICAgICAgc3RhdGljIGNyZWF0ZUNvbXB1dGVkUHJvcGVydHkocHJvcGVydHksIGV4cHJlc3Npb24sIGR5bmFtaWNGbikge1xuICAgICAgICB0aGlzLnByb3RvdHlwZS5fY3JlYXRlQ29tcHV0ZWRQcm9wZXJ0eShwcm9wZXJ0eSwgZXhwcmVzc2lvbiwgZHluYW1pY0ZuKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBQYXJzZXMgdGhlIHByb3ZpZGVkIHRlbXBsYXRlIHRvIGVuc3VyZSBiaW5kaW5nIGVmZmVjdHMgYXJlIGNyZWF0ZWRcbiAgICAgICAqIGZvciB0aGVtLCBhbmQgdGhlbiBlbnN1cmVzIHByb3BlcnR5IGFjY2Vzc29ycyBhcmUgY3JlYXRlZCBmb3IgYW55XG4gICAgICAgKiBkZXBlbmRlbnQgcHJvcGVydGllcyBpbiB0aGUgdGVtcGxhdGUuICBCaW5kaW5nIGVmZmVjdHMgZm9yIGJvdW5kXG4gICAgICAgKiB0ZW1wbGF0ZXMgYXJlIHN0b3JlZCBpbiBhIGxpbmtlZCBsaXN0IG9uIHRoZSBpbnN0YW5jZSBzbyB0aGF0XG4gICAgICAgKiB0ZW1wbGF0ZXMgY2FuIGJlIGVmZmljaWVudGx5IHN0YW1wZWQgYW5kIHVuc3RhbXBlZC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge0hUTUxUZW1wbGF0ZUVsZW1lbnR9IHRlbXBsYXRlIFRlbXBsYXRlIGNvbnRhaW5pbmcgYmluZGluZ1xuICAgICAgICogICBiaW5kaW5nc1xuICAgICAgICogQHJldHVybiB7T2JqZWN0fSBUZW1wbGF0ZSBtZXRhZGF0YSBvYmplY3RcbiAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAqL1xuICAgICAgc3RhdGljIGJpbmRUZW1wbGF0ZSh0ZW1wbGF0ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm90b3R5cGUuX2JpbmRUZW1wbGF0ZSh0ZW1wbGF0ZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIC0tIGJpbmRpbmcgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAvKipcbiAgICAgICAqIEVxdWl2YWxlbnQgdG8gc3RhdGljIGBiaW5kVGVtcGxhdGVgIEFQSSBidXQgY2FuIGJlIGNhbGxlZCBvblxuICAgICAgICogYW4gaW5zdGFuY2UgdG8gYWRkIGVmZmVjdHMgYXQgcnVudGltZS4gIFNlZSB0aGF0IG1ldGhvZCBmb3JcbiAgICAgICAqIGZ1bGwgQVBJIGRvY3MuXG4gICAgICAgKlxuICAgICAgICogVGhpcyBtZXRob2QgbWF5IGJlIGNhbGxlZCBvbiB0aGUgcHJvdG90eXBlIChmb3IgcHJvdG90eXBpY2FsIHRlbXBsYXRlXG4gICAgICAgKiBiaW5kaW5nLCB0byBhdm9pZCBjcmVhdGluZyBhY2Nlc3NvcnMgZXZlcnkgaW5zdGFuY2UpIG9uY2UgcGVyIHByb3RvdHlwZSxcbiAgICAgICAqIGFuZCB3aWxsIGJlIGNhbGxlZCB3aXRoIGBydW50aW1lQmluZGluZzogdHJ1ZWAgYnkgYF9zdGFtcFRlbXBsYXRlYCB0b1xuICAgICAgICogY3JlYXRlIGFuZCBsaW5rIGFuIGluc3RhbmNlIG9mIHRoZSB0ZW1wbGF0ZSBtZXRhZGF0YSBhc3NvY2lhdGVkIHdpdGggYVxuICAgICAgICogcGFydGljdWxhciBzdGFtcGluZy5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge0hUTUxUZW1wbGF0ZUVsZW1lbnR9IHRlbXBsYXRlIFRlbXBsYXRlIGNvbnRhaW5pbmcgYmluZGluZ1xuICAgICAgICogICBiaW5kaW5nc1xuICAgICAgICogQHBhcmFtIHtib29sZWFuPX0gaW5zdGFuY2VCaW5kaW5nIFdoZW4gZmFsc2UgKGRlZmF1bHQpLCBwZXJmb3Jtc1xuICAgICAgICogICBcInByb3RvdHlwaWNhbFwiIGJpbmRpbmcgb2YgdGhlIHRlbXBsYXRlIGFuZCBvdmVyd3JpdGVzIGFueSBwcmV2aW91c2x5XG4gICAgICAgKiAgIGJvdW5kIHRlbXBsYXRlIGZvciB0aGUgY2xhc3MuIFdoZW4gdHJ1ZSAoYXMgcGFzc2VkIGZyb21cbiAgICAgICAqICAgYF9zdGFtcFRlbXBsYXRlYCksIHRoZSB0ZW1wbGF0ZSBpbmZvIGlzIGluc3RhbmNlZCBhbmQgbGlua2VkIGludG9cbiAgICAgICAqICAgdGhlIGxpc3Qgb2YgYm91bmQgdGVtcGxhdGVzLlxuICAgICAgICogQHJldHVybiB7IVRlbXBsYXRlSW5mb30gVGVtcGxhdGUgbWV0YWRhdGEgb2JqZWN0OyBmb3IgYHJ1bnRpbWVCaW5kaW5nYCxcbiAgICAgICAqICAgdGhpcyBpcyBhbiBpbnN0YW5jZSBvZiB0aGUgcHJvdG90eXBpY2FsIHRlbXBsYXRlIGluZm9cbiAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAqL1xuICAgICAgX2JpbmRUZW1wbGF0ZSh0ZW1wbGF0ZSwgaW5zdGFuY2VCaW5kaW5nKSB7XG4gICAgICAgIGxldCB0ZW1wbGF0ZUluZm8gPSB0aGlzLmNvbnN0cnVjdG9yLl9wYXJzZVRlbXBsYXRlKHRlbXBsYXRlKTtcbiAgICAgICAgbGV0IHdhc1ByZUJvdW5kID0gdGhpcy5fX3RlbXBsYXRlSW5mbyA9PSB0ZW1wbGF0ZUluZm87XG4gICAgICAgIC8vIE9wdGltaXphdGlvbjogc2luY2UgdGhpcyBpcyBjYWxsZWQgdHdpY2UgZm9yIHByb3RvLWJvdW5kIHRlbXBsYXRlcyxcbiAgICAgICAgLy8gZG9uJ3QgYXR0ZW1wdCB0byByZWNyZWF0ZSBhY2Nlc3NvcnMgaWYgdGhpcyB0ZW1wbGF0ZSB3YXMgcHJlLWJvdW5kXG4gICAgICAgIGlmICghd2FzUHJlQm91bmQpIHtcbiAgICAgICAgICBmb3IgKGxldCBwcm9wIGluIHRlbXBsYXRlSW5mby5wcm9wZXJ0eUVmZmVjdHMpIHtcbiAgICAgICAgICAgIHRoaXMuX2NyZWF0ZVByb3BlcnR5QWNjZXNzb3IocHJvcCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpbnN0YW5jZUJpbmRpbmcpIHtcbiAgICAgICAgICAvLyBGb3IgaW5zdGFuY2UtdGltZSBiaW5kaW5nLCBjcmVhdGUgaW5zdGFuY2Ugb2YgdGVtcGxhdGUgbWV0YWRhdGFcbiAgICAgICAgICAvLyBhbmQgbGluayBpbnRvIGxpc3Qgb2YgdGVtcGxhdGVzIGlmIG5lY2Vzc2FyeVxuICAgICAgICAgIHRlbXBsYXRlSW5mbyA9IC8qKiBAdHlwZSB7IVRlbXBsYXRlSW5mb30gKi8oT2JqZWN0LmNyZWF0ZSh0ZW1wbGF0ZUluZm8pKTtcbiAgICAgICAgICB0ZW1wbGF0ZUluZm8ud2FzUHJlQm91bmQgPSB3YXNQcmVCb3VuZDtcbiAgICAgICAgICBpZiAoIXdhc1ByZUJvdW5kICYmIHRoaXMuX190ZW1wbGF0ZUluZm8pIHtcbiAgICAgICAgICAgIGxldCBsYXN0ID0gdGhpcy5fX3RlbXBsYXRlSW5mb0xhc3QgfHwgdGhpcy5fX3RlbXBsYXRlSW5mbztcbiAgICAgICAgICAgIHRoaXMuX190ZW1wbGF0ZUluZm9MYXN0ID0gbGFzdC5uZXh0VGVtcGxhdGVJbmZvID0gdGVtcGxhdGVJbmZvO1xuICAgICAgICAgICAgdGVtcGxhdGVJbmZvLnByZXZpb3VzVGVtcGxhdGVJbmZvID0gbGFzdDtcbiAgICAgICAgICAgIHJldHVybiB0ZW1wbGF0ZUluZm87XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9fdGVtcGxhdGVJbmZvID0gdGVtcGxhdGVJbmZvO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEFkZHMgYSBwcm9wZXJ0eSBlZmZlY3QgdG8gdGhlIGdpdmVuIHRlbXBsYXRlIG1ldGFkYXRhLCB3aGljaCBpcyBydW5cbiAgICAgICAqIGF0IHRoZSBcInByb3BhZ2F0ZVwiIHN0YWdlIG9mIGBfcHJvcGVydGllc0NoYW5nZWRgIHdoZW4gdGhlIHRlbXBsYXRlXG4gICAgICAgKiBoYXMgYmVlbiBib3VuZCB0byB0aGUgZWxlbWVudCB2aWEgYF9iaW5kVGVtcGxhdGVgLlxuICAgICAgICpcbiAgICAgICAqIFRoZSBgZWZmZWN0YCBvYmplY3Qgc2hvdWxkIG1hdGNoIHRoZSBmb3JtYXQgaW4gYF9hZGRQcm9wZXJ0eUVmZmVjdGAuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IHRlbXBsYXRlSW5mbyBUZW1wbGF0ZSBtZXRhZGF0YSB0byBhZGQgZWZmZWN0IHRvXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcCBQcm9wZXJ0eSB0aGF0IHNob3VsZCB0cmlnZ2VyIHRoZSBlZmZlY3RcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0PX0gZWZmZWN0IEVmZmVjdCBtZXRhZGF0YSBvYmplY3RcbiAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAqL1xuICAgICAgc3RhdGljIF9hZGRUZW1wbGF0ZVByb3BlcnR5RWZmZWN0KHRlbXBsYXRlSW5mbywgcHJvcCwgZWZmZWN0KSB7XG4gICAgICAgIGxldCBob3N0UHJvcHMgPSB0ZW1wbGF0ZUluZm8uaG9zdFByb3BzID0gdGVtcGxhdGVJbmZvLmhvc3RQcm9wcyB8fCB7fTtcbiAgICAgICAgaG9zdFByb3BzW3Byb3BdID0gdHJ1ZTtcbiAgICAgICAgbGV0IGVmZmVjdHMgPSB0ZW1wbGF0ZUluZm8ucHJvcGVydHlFZmZlY3RzID0gdGVtcGxhdGVJbmZvLnByb3BlcnR5RWZmZWN0cyB8fCB7fTtcbiAgICAgICAgbGV0IHByb3BFZmZlY3RzID0gZWZmZWN0c1twcm9wXSA9IGVmZmVjdHNbcHJvcF0gfHwgW107XG4gICAgICAgIHByb3BFZmZlY3RzLnB1c2goZWZmZWN0KTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBTdGFtcHMgdGhlIHByb3ZpZGVkIHRlbXBsYXRlIGFuZCBwZXJmb3JtcyBpbnN0YW5jZS10aW1lIHNldHVwIGZvclxuICAgICAgICogUG9seW1lciB0ZW1wbGF0ZSBmZWF0dXJlcywgaW5jbHVkaW5nIGRhdGEgYmluZGluZ3MsIGRlY2xhcmF0aXZlIGV2ZW50XG4gICAgICAgKiBsaXN0ZW5lcnMsIGFuZCB0aGUgYHRoaXMuJGAgbWFwIG9mIGBpZGAncyB0byBub2Rlcy4gIEEgZG9jdW1lbnQgZnJhZ21lbnRcbiAgICAgICAqIGlzIHJldHVybmVkIGNvbnRhaW5pbmcgdGhlIHN0YW1wZWQgRE9NLCByZWFkeSBmb3IgaW5zZXJ0aW9uIGludG8gdGhlXG4gICAgICAgKiBET00uXG4gICAgICAgKlxuICAgICAgICogVGhpcyBtZXRob2QgbWF5IGJlIGNhbGxlZCBtb3JlIHRoYW4gb25jZTsgaG93ZXZlciBub3RlIHRoYXQgZHVlIHRvXG4gICAgICAgKiBgc2hhZHljc3NgIHBvbHlmaWxsIGxpbWl0YXRpb25zLCBvbmx5IHN0eWxlcyBmcm9tIHRlbXBsYXRlcyBwcmVwYXJlZFxuICAgICAgICogdXNpbmcgYFNoYWR5Q1NTLnByZXBhcmVUZW1wbGF0ZWAgd2lsbCBiZSBjb3JyZWN0bHkgcG9seWZpbGxlZCAoc2NvcGVkXG4gICAgICAgKiB0byB0aGUgc2hhZG93IHJvb3QgYW5kIHN1cHBvcnQgQ1NTIGN1c3RvbSBwcm9wZXJ0aWVzKSwgYW5kIG5vdGUgdGhhdFxuICAgICAgICogYFNoYWR5Q1NTLnByZXBhcmVUZW1wbGF0ZWAgbWF5IG9ubHkgYmUgY2FsbGVkIG9uY2UgcGVyIGVsZW1lbnQuIEFzIHN1Y2gsXG4gICAgICAgKiBhbnkgc3R5bGVzIHJlcXVpcmVkIGJ5IGluIHJ1bnRpbWUtc3RhbXBlZCB0ZW1wbGF0ZXMgbXVzdCBiZSBpbmNsdWRlZFxuICAgICAgICogaW4gdGhlIG1haW4gZWxlbWVudCB0ZW1wbGF0ZS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0geyFIVE1MVGVtcGxhdGVFbGVtZW50fSB0ZW1wbGF0ZSBUZW1wbGF0ZSB0byBzdGFtcFxuICAgICAgICogQHJldHVybiB7IVN0YW1wZWRUZW1wbGF0ZX0gQ2xvbmVkIHRlbXBsYXRlIGNvbnRlbnRcbiAgICAgICAqIEBvdmVycmlkZVxuICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICovXG4gICAgICBfc3RhbXBUZW1wbGF0ZSh0ZW1wbGF0ZSkge1xuICAgICAgICAvLyBFbnN1cmVzIHRoYXQgY3JlYXRlZCBkb20gaXMgYF9lbnF1ZXVlQ2xpZW50YCdkIHRvIHRoaXMgZWxlbWVudCBzb1xuICAgICAgICAvLyB0aGF0IGl0IGNhbiBiZSBmbHVzaGVkIG9uIG5leHQgY2FsbCB0byBgX2ZsdXNoUHJvcGVydGllc2BcbiAgICAgICAgaG9zdFN0YWNrLmJlZ2luSG9zdGluZyh0aGlzKTtcbiAgICAgICAgbGV0IGRvbSA9IHN1cGVyLl9zdGFtcFRlbXBsYXRlKHRlbXBsYXRlKTtcbiAgICAgICAgaG9zdFN0YWNrLmVuZEhvc3RpbmcodGhpcyk7XG4gICAgICAgIGxldCB0ZW1wbGF0ZUluZm8gPSAvKiogQHR5cGUgeyFUZW1wbGF0ZUluZm99ICovKHRoaXMuX2JpbmRUZW1wbGF0ZSh0ZW1wbGF0ZSwgdHJ1ZSkpO1xuICAgICAgICAvLyBBZGQgdGVtcGxhdGUtaW5zdGFuY2Utc3BlY2lmaWMgZGF0YSB0byBpbnN0YW5jZWQgdGVtcGxhdGVJbmZvXG4gICAgICAgIHRlbXBsYXRlSW5mby5ub2RlTGlzdCA9IGRvbS5ub2RlTGlzdDtcbiAgICAgICAgLy8gQ2FwdHVyZSBjaGlsZCBub2RlcyB0byBhbGxvdyB1bnN0YW1waW5nIG9mIG5vbi1wcm90b3R5cGljYWwgdGVtcGxhdGVzXG4gICAgICAgIGlmICghdGVtcGxhdGVJbmZvLndhc1ByZUJvdW5kKSB7XG4gICAgICAgICAgbGV0IG5vZGVzID0gdGVtcGxhdGVJbmZvLmNoaWxkTm9kZXMgPSBbXTtcbiAgICAgICAgICBmb3IgKGxldCBuPWRvbS5maXJzdENoaWxkOyBuOyBuPW4ubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICAgIG5vZGVzLnB1c2gobik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGRvbS50ZW1wbGF0ZUluZm8gPSB0ZW1wbGF0ZUluZm87XG4gICAgICAgIC8vIFNldHVwIGNvbXBvdW5kIHN0b3JhZ2UsIDItd2F5IGxpc3RlbmVycywgYW5kIGRhdGFIb3N0IGZvciBiaW5kaW5nc1xuICAgICAgICBzZXR1cEJpbmRpbmdzKHRoaXMsIHRlbXBsYXRlSW5mbyk7XG4gICAgICAgIC8vIEZsdXNoIHByb3BlcnRpZXMgaW50byB0ZW1wbGF0ZSBub2RlcyBpZiBhbHJlYWR5IGJvb3RlZFxuICAgICAgICBpZiAodGhpcy5fX2RhdGFSZWFkeSkge1xuICAgICAgICAgIHJ1bkVmZmVjdHModGhpcywgdGVtcGxhdGVJbmZvLnByb3BlcnR5RWZmZWN0cywgdGhpcy5fX2RhdGEsIG51bGwsXG4gICAgICAgICAgICBmYWxzZSwgdGVtcGxhdGVJbmZvLm5vZGVMaXN0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZG9tO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJlbW92ZXMgYW5kIHVuYmluZHMgdGhlIG5vZGVzIHByZXZpb3VzbHkgY29udGFpbmVkIGluIHRoZSBwcm92aWRlZFxuICAgICAgICogRG9jdW1lbnRGcmFnbWVudCByZXR1cm5lZCBmcm9tIGBfc3RhbXBUZW1wbGF0ZWAuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHshU3RhbXBlZFRlbXBsYXRlfSBkb20gRG9jdW1lbnRGcmFnbWVudCBwcmV2aW91c2x5IHJldHVybmVkXG4gICAgICAgKiAgIGZyb20gYF9zdGFtcFRlbXBsYXRlYCBhc3NvY2lhdGVkIHdpdGggdGhlIG5vZGVzIHRvIGJlIHJlbW92ZWRcbiAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAqL1xuICAgICAgX3JlbW92ZUJvdW5kRG9tKGRvbSkge1xuICAgICAgICAvLyBVbmxpbmsgdGVtcGxhdGUgaW5mb1xuICAgICAgICBsZXQgdGVtcGxhdGVJbmZvID0gZG9tLnRlbXBsYXRlSW5mbztcbiAgICAgICAgaWYgKHRlbXBsYXRlSW5mby5wcmV2aW91c1RlbXBsYXRlSW5mbykge1xuICAgICAgICAgIHRlbXBsYXRlSW5mby5wcmV2aW91c1RlbXBsYXRlSW5mby5uZXh0VGVtcGxhdGVJbmZvID1cbiAgICAgICAgICAgIHRlbXBsYXRlSW5mby5uZXh0VGVtcGxhdGVJbmZvO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0ZW1wbGF0ZUluZm8ubmV4dFRlbXBsYXRlSW5mbykge1xuICAgICAgICAgIHRlbXBsYXRlSW5mby5uZXh0VGVtcGxhdGVJbmZvLnByZXZpb3VzVGVtcGxhdGVJbmZvID1cbiAgICAgICAgICAgIHRlbXBsYXRlSW5mby5wcmV2aW91c1RlbXBsYXRlSW5mbztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fX3RlbXBsYXRlSW5mb0xhc3QgPT0gdGVtcGxhdGVJbmZvKSB7XG4gICAgICAgICAgdGhpcy5fX3RlbXBsYXRlSW5mb0xhc3QgPSB0ZW1wbGF0ZUluZm8ucHJldmlvdXNUZW1wbGF0ZUluZm87XG4gICAgICAgIH1cbiAgICAgICAgdGVtcGxhdGVJbmZvLnByZXZpb3VzVGVtcGxhdGVJbmZvID0gdGVtcGxhdGVJbmZvLm5leHRUZW1wbGF0ZUluZm8gPSBudWxsO1xuICAgICAgICAvLyBSZW1vdmUgc3RhbXBlZCBub2Rlc1xuICAgICAgICBsZXQgbm9kZXMgPSB0ZW1wbGF0ZUluZm8uY2hpbGROb2RlcztcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgbGV0IG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgICBub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBPdmVycmlkZXMgZGVmYXVsdCBgVGVtcGxhdGVTdGFtcGAgaW1wbGVtZW50YXRpb24gdG8gYWRkIHN1cHBvcnQgZm9yXG4gICAgICAgKiBwYXJzaW5nIGJpbmRpbmdzIGZyb20gYFRleHROb2RlYCdzJyBgdGV4dENvbnRlbnRgLiAgQSBgYmluZGluZ3NgXG4gICAgICAgKiBhcnJheSBpcyBhZGRlZCB0byBgbm9kZUluZm9gIGFuZCBwb3B1bGF0ZWQgd2l0aCBiaW5kaW5nIG1ldGFkYXRhXG4gICAgICAgKiB3aXRoIGluZm9ybWF0aW9uIGNhcHR1cmluZyB0aGUgYmluZGluZyB0YXJnZXQsIGFuZCBhIGBwYXJ0c2AgYXJyYXlcbiAgICAgICAqIHdpdGggb25lIG9yIG1vcmUgbWV0YWRhdGEgb2JqZWN0cyBjYXB0dXJpbmcgdGhlIHNvdXJjZShzKSBvZiB0aGVcbiAgICAgICAqIGJpbmRpbmcuXG4gICAgICAgKlxuICAgICAgICogQG92ZXJyaWRlXG4gICAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgTm9kZSB0byBwYXJzZVxuICAgICAgICogQHBhcmFtIHtUZW1wbGF0ZUluZm99IHRlbXBsYXRlSW5mbyBUZW1wbGF0ZSBtZXRhZGF0YSBmb3IgY3VycmVudCB0ZW1wbGF0ZVxuICAgICAgICogQHBhcmFtIHtOb2RlSW5mb30gbm9kZUluZm8gTm9kZSBtZXRhZGF0YSBmb3IgY3VycmVudCB0ZW1wbGF0ZSBub2RlXG4gICAgICAgKiBAcmV0dXJuIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIHZpc2l0ZWQgbm9kZSBhZGRlZCBub2RlLXNwZWNpZmljXG4gICAgICAgKiAgIG1ldGFkYXRhIHRvIGBub2RlSW5mb2BcbiAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAqIEBzdXBwcmVzcyB7bWlzc2luZ1Byb3BlcnRpZXN9IEludGVyZmFjZXMgaW4gY2xvc3VyZSBkbyBub3QgaW5oZXJpdCBzdGF0aWNzLCBidXQgY2xhc3NlcyBkb1xuICAgICAgICovXG4gICAgICBzdGF0aWMgX3BhcnNlVGVtcGxhdGVOb2RlKG5vZGUsIHRlbXBsYXRlSW5mbywgbm9kZUluZm8pIHtcbiAgICAgICAgbGV0IG5vdGVkID0gc3VwZXIuX3BhcnNlVGVtcGxhdGVOb2RlKG5vZGUsIHRlbXBsYXRlSW5mbywgbm9kZUluZm8pO1xuICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUpIHtcbiAgICAgICAgICBsZXQgcGFydHMgPSB0aGlzLl9wYXJzZUJpbmRpbmdzKG5vZGUudGV4dENvbnRlbnQsIHRlbXBsYXRlSW5mbyk7XG4gICAgICAgICAgaWYgKHBhcnRzKSB7XG4gICAgICAgICAgICAvLyBJbml0aWFsaXplIHRoZSB0ZXh0Q29udGVudCB3aXRoIGFueSBsaXRlcmFsIHBhcnRzXG4gICAgICAgICAgICAvLyBOT1RFOiBkZWZhdWx0IHRvIGEgc3BhY2UgaGVyZSBzbyB0aGUgdGV4dE5vZGUgcmVtYWluczsgc29tZSBicm93c2Vyc1xuICAgICAgICAgICAgLy8gKElFKSBldmFjaXBhdGUgYW4gZW1wdHkgdGV4dE5vZGUgZm9sbG93aW5nIGNsb25lTm9kZS9pbXBvcnROb2RlLlxuICAgICAgICAgICAgbm9kZS50ZXh0Q29udGVudCA9IGxpdGVyYWxGcm9tUGFydHMocGFydHMpIHx8ICcgJztcbiAgICAgICAgICAgIGFkZEJpbmRpbmcodGhpcywgdGVtcGxhdGVJbmZvLCBub2RlSW5mbywgJ3RleHQnLCAndGV4dENvbnRlbnQnLCBwYXJ0cyk7XG4gICAgICAgICAgICBub3RlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub3RlZDtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBPdmVycmlkZXMgZGVmYXVsdCBgVGVtcGxhdGVTdGFtcGAgaW1wbGVtZW50YXRpb24gdG8gYWRkIHN1cHBvcnQgZm9yXG4gICAgICAgKiBwYXJzaW5nIGJpbmRpbmdzIGZyb20gYXR0cmlidXRlcy4gIEEgYGJpbmRpbmdzYFxuICAgICAgICogYXJyYXkgaXMgYWRkZWQgdG8gYG5vZGVJbmZvYCBhbmQgcG9wdWxhdGVkIHdpdGggYmluZGluZyBtZXRhZGF0YVxuICAgICAgICogd2l0aCBpbmZvcm1hdGlvbiBjYXB0dXJpbmcgdGhlIGJpbmRpbmcgdGFyZ2V0LCBhbmQgYSBgcGFydHNgIGFycmF5XG4gICAgICAgKiB3aXRoIG9uZSBvciBtb3JlIG1ldGFkYXRhIG9iamVjdHMgY2FwdHVyaW5nIHRoZSBzb3VyY2Uocykgb2YgdGhlXG4gICAgICAgKiBiaW5kaW5nLlxuICAgICAgICpcbiAgICAgICAqIEBvdmVycmlkZVxuICAgICAgICogQHBhcmFtIHtFbGVtZW50fSBub2RlIE5vZGUgdG8gcGFyc2VcbiAgICAgICAqIEBwYXJhbSB7VGVtcGxhdGVJbmZvfSB0ZW1wbGF0ZUluZm8gVGVtcGxhdGUgbWV0YWRhdGEgZm9yIGN1cnJlbnQgdGVtcGxhdGVcbiAgICAgICAqIEBwYXJhbSB7Tm9kZUluZm99IG5vZGVJbmZvIE5vZGUgbWV0YWRhdGEgZm9yIGN1cnJlbnQgdGVtcGxhdGUgbm9kZVxuICAgICAgICogQHJldHVybiB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSB2aXNpdGVkIG5vZGUgYWRkZWQgbm9kZS1zcGVjaWZpY1xuICAgICAgICogICBtZXRhZGF0YSB0byBgbm9kZUluZm9gXG4gICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgKiBAc3VwcHJlc3Mge21pc3NpbmdQcm9wZXJ0aWVzfSBJbnRlcmZhY2VzIGluIGNsb3N1cmUgZG8gbm90IGluaGVyaXQgc3RhdGljcywgYnV0IGNsYXNzZXMgZG9cbiAgICAgICAqL1xuICAgICAgc3RhdGljIF9wYXJzZVRlbXBsYXRlTm9kZUF0dHJpYnV0ZShub2RlLCB0ZW1wbGF0ZUluZm8sIG5vZGVJbmZvLCBuYW1lLCB2YWx1ZSkge1xuICAgICAgICBsZXQgcGFydHMgPSB0aGlzLl9wYXJzZUJpbmRpbmdzKHZhbHVlLCB0ZW1wbGF0ZUluZm8pO1xuICAgICAgICBpZiAocGFydHMpIHtcbiAgICAgICAgICAvLyBBdHRyaWJ1dGUgb3IgcHJvcGVydHlcbiAgICAgICAgICBsZXQgb3JpZ05hbWUgPSBuYW1lO1xuICAgICAgICAgIGxldCBraW5kID0gJ3Byb3BlcnR5JztcbiAgICAgICAgICBpZiAobmFtZVtuYW1lLmxlbmd0aC0xXSA9PSAnJCcpIHtcbiAgICAgICAgICAgIG5hbWUgPSBuYW1lLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgICAgIGtpbmQgPSAnYXR0cmlidXRlJztcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gSW5pdGlhbGl6ZSBhdHRyaWJ1dGUgYmluZGluZ3Mgd2l0aCBhbnkgbGl0ZXJhbCBwYXJ0c1xuICAgICAgICAgIGxldCBsaXRlcmFsID0gbGl0ZXJhbEZyb21QYXJ0cyhwYXJ0cyk7XG4gICAgICAgICAgaWYgKGxpdGVyYWwgJiYga2luZCA9PSAnYXR0cmlidXRlJykge1xuICAgICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUobmFtZSwgbGl0ZXJhbCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIENsZWFyIGF0dHJpYnV0ZSBiZWZvcmUgcmVtb3ZpbmcsIHNpbmNlIElFIHdvbid0IGFsbG93IHJlbW92aW5nXG4gICAgICAgICAgLy8gYHZhbHVlYCBhdHRyaWJ1dGUgaWYgaXQgcHJldmlvdXNseSBoYWQgYSB2YWx1ZSAoY2FuJ3RcbiAgICAgICAgICAvLyB1bmNvbmRpdGlvbmFsbHkgc2V0ICcnIGJlZm9yZSByZW1vdmluZyBzaW5jZSBhdHRyaWJ1dGVzIHdpdGggYCRgXG4gICAgICAgICAgLy8gY2FuJ3QgYmUgc2V0IHVzaW5nIHNldEF0dHJpYnV0ZSlcbiAgICAgICAgICBpZiAobm9kZS5sb2NhbE5hbWUgPT09ICdpbnB1dCcgJiYgb3JpZ05hbWUgPT09ICd2YWx1ZScpIHtcbiAgICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKG9yaWdOYW1lLCAnJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFJlbW92ZSBhbm5vdGF0aW9uXG4gICAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUob3JpZ05hbWUpO1xuICAgICAgICAgIC8vIENhc2UgaGFja2VyeTogYXR0cmlidXRlcyBhcmUgbG93ZXItY2FzZSwgYnV0IGJpbmQgdGFyZ2V0c1xuICAgICAgICAgIC8vIChwcm9wZXJ0aWVzKSBhcmUgY2FzZSBzZW5zaXRpdmUuIEdhbWJpdCBpcyB0byBtYXAgZGFzaC1jYXNlIHRvXG4gICAgICAgICAgLy8gY2FtZWwtY2FzZTogYGZvby1iYXJgIGJlY29tZXMgYGZvb0JhcmAuXG4gICAgICAgICAgLy8gQXR0cmlidXRlIGJpbmRpbmdzIGFyZSBleGNlcHRlZC5cbiAgICAgICAgICBpZiAoa2luZCA9PT0gJ3Byb3BlcnR5Jykge1xuICAgICAgICAgICAgbmFtZSA9IFBvbHltZXIuQ2FzZU1hcC5kYXNoVG9DYW1lbENhc2UobmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGFkZEJpbmRpbmcodGhpcywgdGVtcGxhdGVJbmZvLCBub2RlSW5mbywga2luZCwgbmFtZSwgcGFydHMsIGxpdGVyYWwpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBzdXBlci5fcGFyc2VUZW1wbGF0ZU5vZGVBdHRyaWJ1dGUobm9kZSwgdGVtcGxhdGVJbmZvLCBub2RlSW5mbywgbmFtZSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogT3ZlcnJpZGVzIGRlZmF1bHQgYFRlbXBsYXRlU3RhbXBgIGltcGxlbWVudGF0aW9uIHRvIGFkZCBzdXBwb3J0IGZvclxuICAgICAgICogYmluZGluZyB0aGUgcHJvcGVydGllcyB0aGF0IGEgbmVzdGVkIHRlbXBsYXRlIGRlcGVuZHMgb24gdG8gdGhlIHRlbXBsYXRlXG4gICAgICAgKiBhcyBgX2hvc3RfPHByb3BlcnR5PmAuXG4gICAgICAgKlxuICAgICAgICogQG92ZXJyaWRlXG4gICAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgTm9kZSB0byBwYXJzZVxuICAgICAgICogQHBhcmFtIHtUZW1wbGF0ZUluZm99IHRlbXBsYXRlSW5mbyBUZW1wbGF0ZSBtZXRhZGF0YSBmb3IgY3VycmVudCB0ZW1wbGF0ZVxuICAgICAgICogQHBhcmFtIHtOb2RlSW5mb30gbm9kZUluZm8gTm9kZSBtZXRhZGF0YSBmb3IgY3VycmVudCB0ZW1wbGF0ZSBub2RlXG4gICAgICAgKiBAcmV0dXJuIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIHZpc2l0ZWQgbm9kZSBhZGRlZCBub2RlLXNwZWNpZmljXG4gICAgICAgKiAgIG1ldGFkYXRhIHRvIGBub2RlSW5mb2BcbiAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAqIEBzdXBwcmVzcyB7bWlzc2luZ1Byb3BlcnRpZXN9IEludGVyZmFjZXMgaW4gY2xvc3VyZSBkbyBub3QgaW5oZXJpdCBzdGF0aWNzLCBidXQgY2xhc3NlcyBkb1xuICAgICAgICovXG4gICAgICBzdGF0aWMgX3BhcnNlVGVtcGxhdGVOZXN0ZWRUZW1wbGF0ZShub2RlLCB0ZW1wbGF0ZUluZm8sIG5vZGVJbmZvKSB7XG4gICAgICAgIGxldCBub3RlZCA9IHN1cGVyLl9wYXJzZVRlbXBsYXRlTmVzdGVkVGVtcGxhdGUobm9kZSwgdGVtcGxhdGVJbmZvLCBub2RlSW5mbyk7XG4gICAgICAgIC8vIE1lcmdlIGhvc3QgcHJvcHMgaW50byBvdXRlciB0ZW1wbGF0ZSBhbmQgYWRkIGJpbmRpbmdzXG4gICAgICAgIGxldCBob3N0UHJvcHMgPSBub2RlSW5mby50ZW1wbGF0ZUluZm8uaG9zdFByb3BzO1xuICAgICAgICBsZXQgbW9kZSA9ICd7JztcbiAgICAgICAgZm9yIChsZXQgc291cmNlIGluIGhvc3RQcm9wcykge1xuICAgICAgICAgIGxldCBwYXJ0cyA9IFt7IG1vZGUsIHNvdXJjZSwgZGVwZW5kZW5jaWVzOiBbc291cmNlXSB9XTtcbiAgICAgICAgICBhZGRCaW5kaW5nKHRoaXMsIHRlbXBsYXRlSW5mbywgbm9kZUluZm8sICdwcm9wZXJ0eScsICdfaG9zdF8nICsgc291cmNlLCBwYXJ0cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vdGVkO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENhbGxlZCB0byBwYXJzZSB0ZXh0IGluIGEgdGVtcGxhdGUgKGVpdGhlciBhdHRyaWJ1dGUgdmFsdWVzIG9yXG4gICAgICAgKiB0ZXh0Q29udGVudCkgaW50byBiaW5kaW5nIG1ldGFkYXRhLlxuICAgICAgICpcbiAgICAgICAqIEFueSBvdmVycmlkZXMgb2YgdGhpcyBtZXRob2Qgc2hvdWxkIHJldHVybiBhbiBhcnJheSBvZiBiaW5kaW5nIHBhcnRcbiAgICAgICAqIG1ldGFkYXRhICByZXByZXNlbnRpbmcgb25lIG9yIG1vcmUgYmluZGluZ3MgZm91bmQgaW4gdGhlIHByb3ZpZGVkIHRleHRcbiAgICAgICAqIGFuZCBhbnkgXCJsaXRlcmFsXCIgdGV4dCBpbiBiZXR3ZWVuLiAgQW55IG5vbi1saXRlcmFsIHBhcnRzIHdpbGwgYmUgcGFzc2VkXG4gICAgICAgKiB0byBgX2V2YWx1YXRlQmluZGluZ2Agd2hlbiBhbnkgZGVwZW5kZW5jaWVzIGNoYW5nZS4gIFRoZSBvbmx5IHJlcXVpcmVkXG4gICAgICAgKiBmaWVsZHMgb2YgZWFjaCBcInBhcnRcIiBpbiB0aGUgcmV0dXJuZWQgYXJyYXkgYXJlIGFzIGZvbGxvd3M6XG4gICAgICAgKlxuICAgICAgICogLSBgZGVwZW5kZW5jaWVzYCAtIEFycmF5IGNvbnRhaW5pbmcgdHJpZ2dlciBtZXRhZGF0YSBmb3IgZWFjaCBwcm9wZXJ0eVxuICAgICAgICogICB0aGF0IHNob3VsZCB0cmlnZ2VyIHRoZSBiaW5kaW5nIHRvIHVwZGF0ZVxuICAgICAgICogLSBgbGl0ZXJhbGAgLSBTdHJpbmcgY29udGFpbmluZyB0ZXh0IGlmIHRoZSBwYXJ0IHJlcHJlc2VudHMgYSBsaXRlcmFsO1xuICAgICAgICogICBpbiB0aGlzIGNhc2Ugbm8gYGRlcGVuZGVuY2llc2AgYXJlIG5lZWRlZFxuICAgICAgICpcbiAgICAgICAqIEFkZGl0aW9uYWwgbWV0YWRhdGEgZm9yIHVzZSBieSBgX2V2YWx1YXRlQmluZGluZ2AgbWF5IGJlIHByb3ZpZGVkIGluXG4gICAgICAgKiBlYWNoIHBhcnQgb2JqZWN0IGFzIG5lZWRlZC5cbiAgICAgICAqXG4gICAgICAgKiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBoYW5kbGVzIHRoZSBmb2xsb3dpbmcgdHlwZXMgb2YgYmluZGluZ3NcbiAgICAgICAqIChvbmUgb3IgbW9yZSBtYXkgYmUgaW50ZXJtaXhlZCB3aXRoIGxpdGVyYWwgc3RyaW5ncyk6XG4gICAgICAgKiAtIFByb3BlcnR5IGJpbmRpbmc6IGBbW3Byb3BdXWBcbiAgICAgICAqIC0gUGF0aCBiaW5kaW5nOiBgW1tvYmplY3QucHJvcF1dYFxuICAgICAgICogLSBOZWdhdGVkIHByb3BlcnR5IG9yIHBhdGggYmluZGluZ3M6IGBbWyFwcm9wXV1gIG9yIGBbWyFvYmplY3QucHJvcF1dYFxuICAgICAgICogLSBUd28td2F5IHByb3BlcnR5IG9yIHBhdGggYmluZGluZ3MgKHN1cHBvcnRzIG5lZ2F0aW9uKTpcbiAgICAgICAqICAgYHt7cHJvcH19YCwgYHt7b2JqZWN0LnByb3B9fWAsIGB7eyFwcm9wfX1gIG9yIGB7eyFvYmplY3QucHJvcH19YFxuICAgICAgICogLSBJbmxpbmUgY29tcHV0ZWQgbWV0aG9kIChzdXBwb3J0cyBuZWdhdGlvbik6XG4gICAgICAgKiAgIGBbW2NvbXB1dGUoYSwgJ2xpdGVyYWwnLCBiKV1dYCwgYFtbIWNvbXB1dGUoYSwgJ2xpdGVyYWwnLCBiKV1dYFxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IFRleHQgdG8gcGFyc2UgZnJvbSBhdHRyaWJ1dGUgb3IgdGV4dENvbnRlbnRcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0ZW1wbGF0ZUluZm8gQ3VycmVudCB0ZW1wbGF0ZSBtZXRhZGF0YVxuICAgICAgICogQHJldHVybiB7QXJyYXk8IUJpbmRpbmdQYXJ0Pn0gQXJyYXkgb2YgYmluZGluZyBwYXJ0IG1ldGFkYXRhXG4gICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgKi9cbiAgICAgIHN0YXRpYyBfcGFyc2VCaW5kaW5ncyh0ZXh0LCB0ZW1wbGF0ZUluZm8pIHtcbiAgICAgICAgbGV0IHBhcnRzID0gW107XG4gICAgICAgIGxldCBsYXN0SW5kZXggPSAwO1xuICAgICAgICBsZXQgbTtcbiAgICAgICAgLy8gRXhhbXBsZTogXCJsaXRlcmFsMXt7cHJvcH19bGl0ZXJhbDJbWyFjb21wdXRlKGZvbyxiYXIpXV1maW5hbFwiXG4gICAgICAgIC8vIFJlZ2V4IG1hdGNoZXM6XG4gICAgICAgIC8vICAgICAgICBJdGVyYXRpb24gMTogIEl0ZXJhdGlvbiAyOlxuICAgICAgICAvLyBtWzFdOiAne3snICAgICAgICAgICdbWydcbiAgICAgICAgLy8gbVsyXTogJycgICAgICAgICAgICAnISdcbiAgICAgICAgLy8gbVszXTogJ3Byb3AnICAgICAgICAnY29tcHV0ZShmb28sYmFyKSdcbiAgICAgICAgd2hpbGUgKChtID0gYmluZGluZ1JlZ2V4LmV4ZWModGV4dCkpICE9PSBudWxsKSB7XG4gICAgICAgICAgLy8gQWRkIGxpdGVyYWwgcGFydFxuICAgICAgICAgIGlmIChtLmluZGV4ID4gbGFzdEluZGV4KSB7XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKHtsaXRlcmFsOiB0ZXh0LnNsaWNlKGxhc3RJbmRleCwgbS5pbmRleCl9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gQWRkIGJpbmRpbmcgcGFydFxuICAgICAgICAgIGxldCBtb2RlID0gbVsxXVswXTtcbiAgICAgICAgICBsZXQgbmVnYXRlID0gQm9vbGVhbihtWzJdKTtcbiAgICAgICAgICBsZXQgc291cmNlID0gbVszXS50cmltKCk7XG4gICAgICAgICAgbGV0IGN1c3RvbUV2ZW50ID0gZmFsc2UsIG5vdGlmeUV2ZW50ID0gJycsIGNvbG9uID0gLTE7XG4gICAgICAgICAgaWYgKG1vZGUgPT0gJ3snICYmIChjb2xvbiA9IHNvdXJjZS5pbmRleE9mKCc6OicpKSA+IDApIHtcbiAgICAgICAgICAgIG5vdGlmeUV2ZW50ID0gc291cmNlLnN1YnN0cmluZyhjb2xvbiArIDIpO1xuICAgICAgICAgICAgc291cmNlID0gc291cmNlLnN1YnN0cmluZygwLCBjb2xvbik7XG4gICAgICAgICAgICBjdXN0b21FdmVudCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCBzaWduYXR1cmUgPSBwYXJzZU1ldGhvZChzb3VyY2UpO1xuICAgICAgICAgIGxldCBkZXBlbmRlbmNpZXMgPSBbXTtcbiAgICAgICAgICBpZiAoc2lnbmF0dXJlKSB7XG4gICAgICAgICAgICAvLyBJbmxpbmUgY29tcHV0ZWQgZnVuY3Rpb25cbiAgICAgICAgICAgIGxldCB7YXJncywgbWV0aG9kTmFtZX0gPSBzaWduYXR1cmU7XG4gICAgICAgICAgICBmb3IgKGxldCBpPTA7IGk8YXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBsZXQgYXJnID0gYXJnc1tpXTtcbiAgICAgICAgICAgICAgaWYgKCFhcmcubGl0ZXJhbCkge1xuICAgICAgICAgICAgICAgIGRlcGVuZGVuY2llcy5wdXNoKGFyZyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBkeW5hbWljRm5zID0gdGVtcGxhdGVJbmZvLmR5bmFtaWNGbnM7XG4gICAgICAgICAgICBpZiAoZHluYW1pY0ZucyAmJiBkeW5hbWljRm5zW21ldGhvZE5hbWVdIHx8IHNpZ25hdHVyZS5zdGF0aWMpIHtcbiAgICAgICAgICAgICAgZGVwZW5kZW5jaWVzLnB1c2gobWV0aG9kTmFtZSk7XG4gICAgICAgICAgICAgIHNpZ25hdHVyZS5keW5hbWljRm4gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBQcm9wZXJ0eSBvciBwYXRoXG4gICAgICAgICAgICBkZXBlbmRlbmNpZXMucHVzaChzb3VyY2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwYXJ0cy5wdXNoKHtcbiAgICAgICAgICAgIHNvdXJjZSwgbW9kZSwgbmVnYXRlLCBjdXN0b21FdmVudCwgc2lnbmF0dXJlLCBkZXBlbmRlbmNpZXMsXG4gICAgICAgICAgICBldmVudDogbm90aWZ5RXZlbnRcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBsYXN0SW5kZXggPSBiaW5kaW5nUmVnZXgubGFzdEluZGV4O1xuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCBhIGZpbmFsIGxpdGVyYWwgcGFydFxuICAgICAgICBpZiAobGFzdEluZGV4ICYmIGxhc3RJbmRleCA8IHRleHQubGVuZ3RoKSB7XG4gICAgICAgICAgbGV0IGxpdGVyYWwgPSB0ZXh0LnN1YnN0cmluZyhsYXN0SW5kZXgpO1xuICAgICAgICAgIGlmIChsaXRlcmFsKSB7XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKHtcbiAgICAgICAgICAgICAgbGl0ZXJhbDogbGl0ZXJhbFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0cy5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gcGFydHM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDYWxsZWQgdG8gZXZhbHVhdGUgYSBwcmV2aW91c2x5IHBhcnNlZCBiaW5kaW5nIHBhcnQgYmFzZWQgb24gYSBzZXQgb2ZcbiAgICAgICAqIG9uZSBvciBtb3JlIGNoYW5nZWQgZGVwZW5kZW5jaWVzLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7dGhpc30gaW5zdCBFbGVtZW50IHRoYXQgc2hvdWxkIGJlIHVzZWQgYXMgc2NvcGUgZm9yXG4gICAgICAgKiAgIGJpbmRpbmcgZGVwZW5kZW5jaWVzXG4gICAgICAgKiBAcGFyYW0ge0JpbmRpbmdQYXJ0fSBwYXJ0IEJpbmRpbmcgcGFydCBtZXRhZGF0YVxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggUHJvcGVydHkvcGF0aCB0aGF0IHRyaWdnZXJlZCB0aGlzIGVmZmVjdFxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzIEJhZyBvZiBjdXJyZW50IHByb3BlcnR5IGNoYW5nZXNcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvbGRQcm9wcyBCYWcgb2YgcHJldmlvdXMgdmFsdWVzIGZvciBjaGFuZ2VkIHByb3BlcnRpZXNcbiAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaGFzUGF0aHMgVHJ1ZSB3aXRoIGBwcm9wc2AgY29udGFpbnMgb25lIG9yIG1vcmUgcGF0aHNcbiAgICAgICAqIEByZXR1cm4geyp9IFZhbHVlIHRoZSBiaW5kaW5nIHBhcnQgZXZhbHVhdGVkIHRvXG4gICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgKi9cbiAgICAgIHN0YXRpYyBfZXZhbHVhdGVCaW5kaW5nKGluc3QsIHBhcnQsIHBhdGgsIHByb3BzLCBvbGRQcm9wcywgaGFzUGF0aHMpIHtcbiAgICAgICAgbGV0IHZhbHVlO1xuICAgICAgICBpZiAocGFydC5zaWduYXR1cmUpIHtcbiAgICAgICAgICB2YWx1ZSA9IHJ1bk1ldGhvZEVmZmVjdChpbnN0LCBwYXRoLCBwcm9wcywgb2xkUHJvcHMsIHBhcnQuc2lnbmF0dXJlKTtcbiAgICAgICAgfSBlbHNlIGlmIChwYXRoICE9IHBhcnQuc291cmNlKSB7XG4gICAgICAgICAgdmFsdWUgPSBQb2x5bWVyLlBhdGguZ2V0KGluc3QsIHBhcnQuc291cmNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoaGFzUGF0aHMgJiYgUG9seW1lci5QYXRoLmlzUGF0aChwYXRoKSkge1xuICAgICAgICAgICAgdmFsdWUgPSBQb2x5bWVyLlBhdGguZ2V0KGluc3QsIHBhdGgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGluc3QuX19kYXRhW3BhdGhdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydC5uZWdhdGUpIHtcbiAgICAgICAgICB2YWx1ZSA9ICF2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG5cbiAgICB9XG5cbiAgICAvLyBtYWtlIGEgdHlwaW5nIGZvciBjbG9zdXJlIDpQXG4gICAgUHJvcGVydHlFZmZlY3RzVHlwZSA9IFByb3BlcnR5RWZmZWN0cztcblxuICAgIHJldHVybiBQcm9wZXJ0eUVmZmVjdHM7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBIZWxwZXIgYXBpIGZvciBlbnF1ZWluZyBjbGllbnQgZG9tIGNyZWF0ZWQgYnkgYSBob3N0IGVsZW1lbnQuXG4gICAqXG4gICAqIEJ5IGRlZmF1bHQgZWxlbWVudHMgYXJlIGZsdXNoZWQgdmlhIGBfZmx1c2hQcm9wZXJ0aWVzYCB3aGVuXG4gICAqIGBjb25uZWN0ZWRDYWxsYmFja2AgaXMgY2FsbGVkLiBFbGVtZW50cyBhdHRhY2ggdGhlaXIgY2xpZW50IGRvbSB0b1xuICAgKiB0aGVtc2VsdmVzIGF0IGByZWFkeWAgdGltZSB3aGljaCByZXN1bHRzIGZyb20gdGhpcyBmaXJzdCBmbHVzaC5cbiAgICogVGhpcyBwcm92aWRlcyBhbiBvcmRlcmluZyBndWFyYW50ZWUgdGhhdCB0aGUgY2xpZW50IGRvbSBhbiBlbGVtZW50XG4gICAqIGNyZWF0ZXMgaXMgZmx1c2hlZCBiZWZvcmUgdGhlIGVsZW1lbnQgaXRzZWxmIChpLmUuIGNsaWVudCBgcmVhZHlgXG4gICAqIGZpcmVzIGJlZm9yZSBob3N0IGByZWFkeWApLlxuICAgKlxuICAgKiBIb3dldmVyLCBpZiBgX2ZsdXNoUHJvcGVydGllc2AgaXMgY2FsbGVkICpiZWZvcmUqIGFuIGVsZW1lbnQgaXMgY29ubmVjdGVkLFxuICAgKiBhcyBmb3IgZXhhbXBsZSBgVGVtcGxhdGl6ZWAgZG9lcywgdGhpcyBvcmRlcmluZyBndWFyYW50ZWUgY2Fubm90IGJlXG4gICAqIHNhdGlzZmllZCBiZWNhdXNlIG5vIGVsZW1lbnRzIGFyZSBjb25uZWN0ZWQuIChOb3RlOiBCb3VuZCBlbGVtZW50cyB0aGF0XG4gICAqIHJlY2VpdmUgZGF0YSBkbyBiZWNvbWUgZW5xdWV1ZWQgY2xpZW50cyBhbmQgYXJlIHByb3Blcmx5IG9yZGVyZWQgYnV0XG4gICAqIHVuYm91bmQgZWxlbWVudHMgYXJlIG5vdC4pXG4gICAqXG4gICAqIFRvIG1haW50YWluIHRoZSBkZXNpcmVkIFwiY2xpZW50IGJlZm9yZSBob3N0XCIgb3JkZXJpbmcgZ3VhcmFudGVlIGZvciB0aGlzXG4gICAqIGNhc2Ugd2UgcmVseSBvbiB0aGUgXCJob3N0IHN0YWNrLiBDbGllbnQgbm9kZXMgcmVnaXN0ZXJzIHRoZW1zZWx2ZXMgd2l0aFxuICAgKiB0aGUgY3JlYXRpbmcgaG9zdCBlbGVtZW50IHdoZW4gY3JlYXRlZC4gVGhpcyBlbnN1cmVzIHRoYXQgYWxsIGNsaWVudCBkb21cbiAgICogaXMgcmVhZGllZCBpbiB0aGUgcHJvcGVyIG9yZGVyLCBtYWludGFpbmluZyB0aGUgZGVzaXJlZCBndWFyYW50ZWUuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBsZXQgaG9zdFN0YWNrID0ge1xuXG4gICAgc3RhY2s6IFtdLFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHsqfSBpbnN0IEluc3RhbmNlIHRvIGFkZCB0byBob3N0U3RhY2tcbiAgICAgKiBAdGhpcyB7aG9zdFN0YWNrfVxuICAgICAqL1xuICAgIHJlZ2lzdGVySG9zdChpbnN0KSB7XG4gICAgICBpZiAodGhpcy5zdGFjay5sZW5ndGgpIHtcbiAgICAgICAgbGV0IGhvc3QgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoLTFdO1xuICAgICAgICBob3N0Ll9lbnF1ZXVlQ2xpZW50KGluc3QpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyp9IGluc3QgSW5zdGFuY2UgdG8gYmVnaW4gaG9zdGluZ1xuICAgICAqIEB0aGlzIHtob3N0U3RhY2t9XG4gICAgICovXG4gICAgYmVnaW5Ib3N0aW5nKGluc3QpIHtcbiAgICAgIHRoaXMuc3RhY2sucHVzaChpbnN0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHsqfSBpbnN0IEluc3RhbmNlIHRvIGVuZCBob3N0aW5nXG4gICAgICogQHRoaXMge2hvc3RTdGFja31cbiAgICAgKi9cbiAgICBlbmRIb3N0aW5nKGluc3QpIHtcbiAgICAgIGxldCBzdGFja0xlbiA9IHRoaXMuc3RhY2subGVuZ3RoO1xuICAgICAgaWYgKHN0YWNrTGVuICYmIHRoaXMuc3RhY2tbc3RhY2tMZW4tMV0gPT0gaW5zdCkge1xuICAgICAgICB0aGlzLnN0YWNrLnBvcCgpO1xuICAgICAgfVxuICAgIH1cblxuICB9XG5cbn0pKCk7XG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvbWl4aW5zL3Byb3BlcnR5LWVmZmVjdHMuaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCJib290Lmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCJtaXhpbi5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiYXN5bmMuaHRtbFwiPlxuXG48c2NyaXB0PlxuKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLyoqIEB0eXBlZGVmIHt7cnVuOiBmdW5jdGlvbihmdW5jdGlvbigpLCBudW1iZXI9KTpudW1iZXIsIGNhbmNlbDogZnVuY3Rpb24obnVtYmVyKX19ICovXG4gIGxldCBBc3luY01vZHVsZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuXG4gIC8qKlxuICAgKiBAc3VtbWFyeSBDb2xsYXBzZSBtdWx0aXBsZSBjYWxsYmFja3MgaW50byBvbmUgaW52b2NhdGlvbiBhZnRlciBhIHRpbWVyLlxuICAgKiBAbWVtYmVyb2YgUG9seW1lclxuICAgKi9cbiAgY2xhc3MgRGVib3VuY2VyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgIHRoaXMuX2FzeW5jTW9kdWxlID0gbnVsbDtcbiAgICAgIHRoaXMuX2NhbGxiYWNrID0gbnVsbDtcbiAgICAgIHRoaXMuX3RpbWVyID0gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgc2NoZWR1bGVyOyB0aGF0IGlzLCBhIG1vZHVsZSB3aXRoIHRoZSBBc3luYyBpbnRlcmZhY2UsXG4gICAgICogYSBjYWxsYmFjayBhbmQgb3B0aW9uYWwgYXJndW1lbnRzIHRvIGJlIHBhc3NlZCB0byB0aGUgcnVuIGZ1bmN0aW9uXG4gICAgICogZnJvbSB0aGUgYXN5bmMgbW9kdWxlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHshQXN5bmNNb2R1bGV9IGFzeW5jTW9kdWxlIE9iamVjdCB3aXRoIEFzeW5jIGludGVyZmFjZS5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCl9IGNhbGxiYWNrIENhbGxiYWNrIHRvIHJ1bi5cbiAgICAgKi9cbiAgICBzZXRDb25maWcoYXN5bmNNb2R1bGUsIGNhbGxiYWNrKSB7XG4gICAgICB0aGlzLl9hc3luY01vZHVsZSA9IGFzeW5jTW9kdWxlO1xuICAgICAgdGhpcy5fY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgIHRoaXMuX3RpbWVyID0gdGhpcy5fYXN5bmNNb2R1bGUucnVuKCgpID0+IHtcbiAgICAgICAgdGhpcy5fdGltZXIgPSBudWxsO1xuICAgICAgICB0aGlzLl9jYWxsYmFjaygpXG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FuY2VscyBhbiBhY3RpdmUgZGVib3VuY2VyIGFuZCByZXR1cm5zIGEgcmVmZXJlbmNlIHRvIGl0c2VsZi5cbiAgICAgKi9cbiAgICBjYW5jZWwoKSB7XG4gICAgICBpZiAodGhpcy5pc0FjdGl2ZSgpKSB7XG4gICAgICAgIHRoaXMuX2FzeW5jTW9kdWxlLmNhbmNlbCh0aGlzLl90aW1lcik7XG4gICAgICAgIHRoaXMuX3RpbWVyID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRmx1c2hlcyBhbiBhY3RpdmUgZGVib3VuY2VyIGFuZCByZXR1cm5zIGEgcmVmZXJlbmNlIHRvIGl0c2VsZi5cbiAgICAgKi9cbiAgICBmbHVzaCgpIHtcbiAgICAgIGlmICh0aGlzLmlzQWN0aXZlKCkpIHtcbiAgICAgICAgdGhpcy5jYW5jZWwoKTtcbiAgICAgICAgdGhpcy5fY2FsbGJhY2soKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBkZWJvdW5jZXIgaXMgYWN0aXZlLlxuICAgICAqXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBhY3RpdmUuXG4gICAgICovXG4gICAgaXNBY3RpdmUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdGltZXIgIT0gbnVsbDtcbiAgICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgZGVib3VuY2VyIGlmIG5vIGRlYm91bmNlciBpcyBwYXNzZWQgYXMgYSBwYXJhbWV0ZXJcbiAgICogb3IgaXQgY2FuY2VscyBhbiBhY3RpdmUgZGVib3VuY2VyIG90aGVyd2lzZS4gVGhlIGZvbGxvd2luZ1xuICAgKiBleGFtcGxlIHNob3dzIGhvdyBhIGRlYm91bmNlciBjYW4gYmUgY2FsbGVkIG11bHRpcGxlIHRpbWVzIHdpdGhpbiBhXG4gICAqIG1pY3JvdGFzayBhbmQgXCJkZWJvdW5jZWRcIiBzdWNoIHRoYXQgdGhlIHByb3ZpZGVkIGNhbGxiYWNrIGZ1bmN0aW9uIGlzXG4gICAqIGNhbGxlZCBvbmNlLiBBZGQgdGhpcyBtZXRob2QgdG8gYSBjdXN0b20gZWxlbWVudDpcbiAgICpcbiAgICogX2RlYm91bmNlV29yaygpIHtcbiAgICogICB0aGlzLl9kZWJvdW5jZUpvYiA9IFBvbHltZXIuRGVib3VuY2VyLmRlYm91bmNlKHRoaXMuX2RlYm91bmNlSm9iLFxuICAgKiAgICAgICBQb2x5bWVyLkFzeW5jLm1pY3JvVGFzaywgKCkgPT4ge1xuICAgKiAgICAgdGhpcy5fZG9Xb3JrKCk7XG4gICAqICAgfSk7XG4gICAqIH1cbiAgICpcbiAgICogSWYgdGhlIGBfZGVib3VuY2VXb3JrYCBtZXRob2QgaXMgY2FsbGVkIG11bHRpcGxlIHRpbWVzIHdpdGhpbiB0aGUgc2FtZVxuICAgKiBtaWNyb3Rhc2ssIHRoZSBgX2RvV29ya2AgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgb25seSBvbmNlIGF0IHRoZSBuZXh0XG4gICAqIG1pY3JvdGFzayBjaGVja3BvaW50LlxuICAgKlxuICAgKiBOb3RlOiBJbiB0ZXN0aW5nIGl0IGlzIG9mdGVuIGNvbnZlbmllbnQgdG8gYXZvaWQgYXN5bmNocm9ueS4gVG8gYWNjb21wbGlzaFxuICAgKiB0aGlzIHdpdGggYSBkZWJvdW5jZXIsIHlvdSBjYW4gdXNlIGBQb2x5bWVyLmVucXVldWVEZWJvdW5jZXJgIGFuZFxuICAgKiBgUG9seW1lci5mbHVzaGAuIEZvciBleGFtcGxlLCBleHRlbmQgdGhlIGFib3ZlIGV4YW1wbGUgYnkgYWRkaW5nXG4gICAqIGBQb2x5bWVyLmVucXVldWVEZWJvdW5jZXIodGhpcy5fZGVib3VuY2VKb2IpYCBhdCB0aGUgZW5kIG9mIHRoZVxuICAgKiBgX2RlYm91bmNlV29ya2AgbWV0aG9kLiBUaGVuIGluIGEgdGVzdCwgY2FsbCBgUG9seW1lci5mbHVzaGAgdG8gZW5zdXJlXG4gICAqIHRoZSBkZWJvdW5jZXIgaGFzIGNvbXBsZXRlZC5cbiAgICpcbiAgICogQHBhcmFtIHtEZWJvdW5jZXI/fSBkZWJvdW5jZXIgRGVib3VuY2VyIG9iamVjdC5cbiAgICogQHBhcmFtIHshQXN5bmNNb2R1bGV9IGFzeW5jTW9kdWxlIE9iamVjdCB3aXRoIEFzeW5jIGludGVyZmFjZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCl9IGNhbGxiYWNrIENhbGxiYWNrIHRvIHJ1bi5cbiAgICogQHJldHVybiB7IURlYm91bmNlcn0gUmV0dXJucyBhIGRlYm91bmNlciBvYmplY3QuXG4gICAqL1xuICAgIHN0YXRpYyBkZWJvdW5jZShkZWJvdW5jZXIsIGFzeW5jTW9kdWxlLCBjYWxsYmFjaykge1xuICAgICAgaWYgKGRlYm91bmNlciBpbnN0YW5jZW9mIERlYm91bmNlcikge1xuICAgICAgICBkZWJvdW5jZXIuY2FuY2VsKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWJvdW5jZXIgPSBuZXcgRGVib3VuY2VyKCk7XG4gICAgICB9XG4gICAgICBkZWJvdW5jZXIuc2V0Q29uZmlnKGFzeW5jTW9kdWxlLCBjYWxsYmFjayk7XG4gICAgICByZXR1cm4gZGVib3VuY2VyO1xuICAgIH1cbiAgfVxuXG4gIFBvbHltZXIuRGVib3VuY2VyID0gRGVib3VuY2VyO1xufSkoKTtcbjwvc2NyaXB0PlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi91dGlscy9kZWJvdW5jZS5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cImJvb3QuaHRtbFwiPlxuPHNjcmlwdD5cbihmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIGxldCBkZWJvdW5jZXJRdWV1ZSA9IFtdO1xuXG4gIC8qKlxuICAgKiBBZGRzIGEgYFBvbHltZXIuRGVib3VuY2VyYCB0byBhIGxpc3Qgb2YgZ2xvYmFsbHkgZmx1c2hhYmxlIHRhc2tzLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgUG9seW1lclxuICAgKiBAcGFyYW0ge1BvbHltZXIuRGVib3VuY2VyfSBkZWJvdW5jZXIgRGVib3VuY2VyIHRvIGVucXVldWVcbiAgICovXG4gIFBvbHltZXIuZW5xdWV1ZURlYm91bmNlciA9IGZ1bmN0aW9uKGRlYm91bmNlcikge1xuICAgIGRlYm91bmNlclF1ZXVlLnB1c2goZGVib3VuY2VyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZsdXNoRGVib3VuY2VycygpIHtcbiAgICBjb25zdCBkaWRGbHVzaCA9IEJvb2xlYW4oZGVib3VuY2VyUXVldWUubGVuZ3RoKTtcbiAgICB3aGlsZSAoZGVib3VuY2VyUXVldWUubGVuZ3RoKSB7XG4gICAgICB0cnkge1xuICAgICAgICBkZWJvdW5jZXJRdWV1ZS5zaGlmdCgpLmZsdXNoKCk7XG4gICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkaWRGbHVzaDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGb3JjZXMgc2V2ZXJhbCBjbGFzc2VzIG9mIGFzeW5jaHJvbm91c2x5IHF1ZXVlZCB0YXNrcyB0byBmbHVzaDpcbiAgICogLSBEZWJvdW5jZXJzIGFkZGVkIHZpYSBgZW5xdWV1ZURlYm91bmNlcmBcbiAgICogLSBTaGFkeURPTSBkaXN0cmlidXRpb25cbiAgICpcbiAgICogQG1lbWJlcm9mIFBvbHltZXJcbiAgICovXG4gIFBvbHltZXIuZmx1c2ggPSBmdW5jdGlvbigpIHtcbiAgICBsZXQgc2hhZHlET00sIGRlYm91bmNlcnM7XG4gICAgZG8ge1xuICAgICAgc2hhZHlET00gPSB3aW5kb3cuU2hhZHlET00gJiYgU2hhZHlET00uZmx1c2goKTtcbiAgICAgIGlmICh3aW5kb3cuU2hhZHlDU1MgJiYgd2luZG93LlNoYWR5Q1NTLlNjb3BpbmdTaGltKSB7XG4gICAgICAgIHdpbmRvdy5TaGFkeUNTUy5TY29waW5nU2hpbS5mbHVzaCgpO1xuICAgICAgfVxuICAgICAgZGVib3VuY2VycyA9IGZsdXNoRGVib3VuY2VycygpO1xuICAgIH0gd2hpbGUgKHNoYWR5RE9NIHx8IGRlYm91bmNlcnMpO1xuICB9XG5cbn0pKCk7XG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvdXRpbHMvZmx1c2guaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cblxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cImJvb3QuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL21peGlucy9wcm9wZXJ0eS1lZmZlY3RzLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi9taXhpbnMvbXV0YWJsZS1kYXRhLmh0bWxcIj5cblxuPHNjcmlwdD5cbiAgKGZ1bmN0aW9uKCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIC8vIEJhc2UgY2xhc3MgZm9yIEhUTUxUZW1wbGF0ZUVsZW1lbnQgZXh0ZW5zaW9uIHRoYXQgaGFzIHByb3BlcnR5IGVmZmVjdHNcbiAgICAvLyBtYWNoaW5lcnkgZm9yIHByb3BhZ2F0aW5nIGhvc3QgcHJvcGVydGllcyB0byBjaGlsZHJlbi4gVGhpcyBpcyBhbiBFUzVcbiAgICAvLyBjbGFzcyBvbmx5IGJlY2F1c2UgQmFiZWwgKGluY29ycmVjdGx5KSByZXF1aXJlcyBzdXBlcigpIGluIHRoZSBjbGFzc1xuICAgIC8vIGNvbnN0cnVjdG9yIGV2ZW4gdGhvdWdoIG5vIGB0aGlzYCBpcyB1c2VkIGFuZCBpdCByZXR1cm5zIGFuIGluc3RhbmNlLlxuICAgIGxldCBuZXdJbnN0YW5jZSA9IG51bGw7XG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQGV4dGVuZHMge0hUTUxUZW1wbGF0ZUVsZW1lbnR9XG4gICAgICovXG4gICAgZnVuY3Rpb24gSFRNTFRlbXBsYXRlRWxlbWVudEV4dGVuc2lvbigpIHsgcmV0dXJuIG5ld0luc3RhbmNlOyB9XG4gICAgSFRNTFRlbXBsYXRlRWxlbWVudEV4dGVuc2lvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEhUTUxUZW1wbGF0ZUVsZW1lbnQucHJvdG90eXBlLCB7XG4gICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICB2YWx1ZTogSFRNTFRlbXBsYXRlRWxlbWVudEV4dGVuc2lvbixcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAaW1wbGVtZW50cyB7UG9seW1lcl9Qcm9wZXJ0eUVmZmVjdHN9XG4gICAgICogQGV4dGVuZHMge0hUTUxUZW1wbGF0ZUVsZW1lbnRFeHRlbnNpb259XG4gICAgICovXG4gICAgY29uc3QgRGF0YVRlbXBsYXRlID0gUG9seW1lci5Qcm9wZXJ0eUVmZmVjdHMoSFRNTFRlbXBsYXRlRWxlbWVudEV4dGVuc2lvbik7XG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQGltcGxlbWVudHMge1BvbHltZXJfTXV0YWJsZURhdGF9XG4gICAgICogQGV4dGVuZHMge0RhdGFUZW1wbGF0ZX1cbiAgICAgKi9cbiAgICBjb25zdCBNdXRhYmxlRGF0YVRlbXBsYXRlID0gUG9seW1lci5NdXRhYmxlRGF0YShEYXRhVGVtcGxhdGUpO1xuXG4gICAgLy8gQXBwbGllcyBhIERhdGFUZW1wbGF0ZSBzdWJjbGFzcyB0byBhIDx0ZW1wbGF0ZT4gaW5zdGFuY2VcbiAgICBmdW5jdGlvbiB1cGdyYWRlVGVtcGxhdGUodGVtcGxhdGUsIGNvbnN0cnVjdG9yKSB7XG4gICAgICBuZXdJbnN0YW5jZSA9IHRlbXBsYXRlO1xuICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRlbXBsYXRlLCBjb25zdHJ1Y3Rvci5wcm90b3R5cGUpO1xuICAgICAgbmV3IGNvbnN0cnVjdG9yKCk7XG4gICAgICBuZXdJbnN0YW5jZSA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gQmFzZSBjbGFzcyBmb3IgVGVtcGxhdGVJbnN0YW5jZSdzXG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQGltcGxlbWVudHMge1BvbHltZXJfUHJvcGVydHlFZmZlY3RzfVxuICAgICAqL1xuICAgIGNvbnN0IGJhc2UgPSBQb2x5bWVyLlByb3BlcnR5RWZmZWN0cyhjbGFzcyB7fSk7XG5cbiAgICAvKipcbiAgICAgKiBAcG9seW1lclxuICAgICAqIEBjdXN0b21FbGVtZW50XG4gICAgICogQGFwcGxpZXNNaXhpbiBQb2x5bWVyLlByb3BlcnR5RWZmZWN0c1xuICAgICAqIEB1bnJlc3RyaWN0ZWRcbiAgICAgKi9cbiAgICBjbGFzcyBUZW1wbGF0ZUluc3RhbmNlQmFzZSBleHRlbmRzIGJhc2Uge1xuICAgICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5fY29uZmlndXJlUHJvcGVydGllcyhwcm9wcyk7XG4gICAgICAgIHRoaXMucm9vdCA9IHRoaXMuX3N0YW1wVGVtcGxhdGUodGhpcy5fX2RhdGFIb3N0KTtcbiAgICAgICAgLy8gU2F2ZSBsaXN0IG9mIHN0YW1wZWQgY2hpbGRyZW5cbiAgICAgICAgbGV0IGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbiA9IFtdO1xuICAgICAgICBmb3IgKGxldCBuID0gdGhpcy5yb290LmZpcnN0Q2hpbGQ7IG47IG49bi5uZXh0U2libGluZykge1xuICAgICAgICAgIGNoaWxkcmVuLnB1c2gobik7XG4gICAgICAgICAgbi5fX3RlbXBsYXRpemVJbnN0YW5jZSA9IHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX190ZW1wbGF0aXplT3duZXIuX19oaWRlVGVtcGxhdGVDaGlsZHJlbl9fKSB7XG4gICAgICAgICAgdGhpcy5fc2hvd0hpZGVDaGlsZHJlbih0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGbHVzaCBwcm9wcyBvbmx5IHdoZW4gcHJvcHMgYXJlIHBhc3NlZCBpZiBpbnN0YW5jZSBwcm9wcyBleGlzdFxuICAgICAgICAvLyBvciB3aGVuIHRoZXJlIGlzbid0IGluc3RhbmNlIHByb3BzLlxuICAgICAgICBsZXQgb3B0aW9ucyA9IHRoaXMuX190ZW1wbGF0aXplT3B0aW9ucztcbiAgICAgICAgaWYgKChwcm9wcyAmJiBvcHRpb25zLmluc3RhbmNlUHJvcHMpIHx8ICFvcHRpb25zLmluc3RhbmNlUHJvcHMpIHtcbiAgICAgICAgICB0aGlzLl9lbmFibGVQcm9wZXJ0aWVzKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogQ29uZmlndXJlIHRoZSBnaXZlbiBgcHJvcHNgIGJ5IGNhbGxpbmcgYF9zZXRQZW5kaW5nUHJvcGVydHlgLiBBbHNvXG4gICAgICAgKiBzZXRzIGFueSBwcm9wZXJ0aWVzIHN0b3JlZCBpbiBgX19ob3N0UHJvcHNgLlxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBPYmplY3Qgb2YgcHJvcGVydHkgbmFtZS12YWx1ZSBwYWlycyB0byBzZXQuXG4gICAgICAgKi9cbiAgICAgIF9jb25maWd1cmVQcm9wZXJ0aWVzKHByb3BzKSB7XG4gICAgICAgIGxldCBvcHRpb25zID0gdGhpcy5fX3RlbXBsYXRpemVPcHRpb25zO1xuICAgICAgICBpZiAocHJvcHMpIHtcbiAgICAgICAgICBmb3IgKGxldCBpcHJvcCBpbiBvcHRpb25zLmluc3RhbmNlUHJvcHMpIHtcbiAgICAgICAgICAgIGlmIChpcHJvcCBpbiBwcm9wcykge1xuICAgICAgICAgICAgICB0aGlzLl9zZXRQZW5kaW5nUHJvcGVydHkoaXByb3AsIHByb3BzW2lwcm9wXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGhwcm9wIGluIHRoaXMuX19ob3N0UHJvcHMpIHtcbiAgICAgICAgICB0aGlzLl9zZXRQZW5kaW5nUHJvcGVydHkoaHByb3AsIHRoaXMuX19kYXRhSG9zdFsnX2hvc3RfJyArIGhwcm9wXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogRm9yd2FyZHMgYSBob3N0IHByb3BlcnR5IHRvIHRoaXMgaW5zdGFuY2UuICBUaGlzIG1ldGhvZCBzaG91bGQgYmVcbiAgICAgICAqIGNhbGxlZCBvbiBpbnN0YW5jZXMgZnJvbSB0aGUgYG9wdGlvbnMuZm9yd2FyZEhvc3RQcm9wYCBjYWxsYmFja1xuICAgICAgICogdG8gcHJvcGFnYXRlIGNoYW5nZXMgb2YgaG9zdCBwcm9wZXJ0aWVzIHRvIGVhY2ggaW5zdGFuY2UuXG4gICAgICAgKlxuICAgICAgICogTm90ZSB0aGlzIG1ldGhvZCBlbnF1ZXVlcyB0aGUgY2hhbmdlLCB3aGljaCBhcmUgZmx1c2hlZCBhcyBhIGJhdGNoLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wIFByb3BlcnR5IG9yIHBhdGggbmFtZVxuICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSBvZiB0aGUgcHJvcGVydHkgdG8gZm9yd2FyZFxuICAgICAgICovXG4gICAgICBmb3J3YXJkSG9zdFByb3AocHJvcCwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuX3NldFBlbmRpbmdQcm9wZXJ0eU9yUGF0aChwcm9wLCB2YWx1ZSwgZmFsc2UsIHRydWUpKSB7XG4gICAgICAgICAgdGhpcy5fX2RhdGFIb3N0Ll9lbnF1ZXVlQ2xpZW50KHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIEBvdmVycmlkZVxuICAgICAgICovXG4gICAgICBfYWRkRXZlbnRMaXN0ZW5lclRvTm9kZShub2RlLCBldmVudE5hbWUsIGhhbmRsZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuX21ldGhvZEhvc3QgJiYgdGhpcy5fX3RlbXBsYXRpemVPcHRpb25zLnBhcmVudE1vZGVsKSB7XG4gICAgICAgICAgLy8gSWYgdGhpcyBpbnN0YW5jZSBzaG91bGQgYmUgY29uc2lkZXJlZCBhIHBhcmVudCBtb2RlbCwgZGVjb3JhdGVcbiAgICAgICAgICAvLyBldmVudHMgdGhpcyB0ZW1wbGF0ZSBpbnN0YW5jZSBhcyBgbW9kZWxgXG4gICAgICAgICAgdGhpcy5fbWV0aG9kSG9zdC5fYWRkRXZlbnRMaXN0ZW5lclRvTm9kZShub2RlLCBldmVudE5hbWUsIChlKSA9PiB7XG4gICAgICAgICAgICBlLm1vZGVsID0gdGhpcztcbiAgICAgICAgICAgIGhhbmRsZXIoZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gT3RoZXJ3aXNlIGRlbGVnYXRlIHRvIHRoZSB0ZW1wbGF0ZSdzIGhvc3QgKHdoaWNoIGNvdWxkIGJlKVxuICAgICAgICAgIC8vIGFub3RoZXIgdGVtcGxhdGUgaW5zdGFuY2VcbiAgICAgICAgICBsZXQgdGVtcGxhdGVIb3N0ID0gdGhpcy5fX2RhdGFIb3N0Ll9fZGF0YUhvc3Q7XG4gICAgICAgICAgaWYgKHRlbXBsYXRlSG9zdCkge1xuICAgICAgICAgICAgdGVtcGxhdGVIb3N0Ll9hZGRFdmVudExpc3RlbmVyVG9Ob2RlKG5vZGUsIGV2ZW50TmFtZSwgaGFuZGxlcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIFNob3dzIG9yIGhpZGVzIHRoZSB0ZW1wbGF0ZSBpbnN0YW5jZSB0b3AgbGV2ZWwgY2hpbGQgZWxlbWVudHMuIEZvclxuICAgICAgICogdGV4dCBub2RlcywgYHRleHRDb250ZW50YCBpcyByZW1vdmVkIHdoaWxlIFwiaGlkZGVuXCIgYW5kIHJlcGxhY2VkIHdoZW5cbiAgICAgICAqIFwic2hvd24uXCJcbiAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaGlkZSBTZXQgdG8gdHJ1ZSB0byBoaWRlIHRoZSBjaGlsZHJlbjtcbiAgICAgICAqIHNldCB0byBmYWxzZSB0byBzaG93IHRoZW0uXG4gICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgKi9cbiAgICAgIF9zaG93SGlkZUNoaWxkcmVuKGhpZGUpIHtcbiAgICAgICAgbGV0IGMgPSB0aGlzLmNoaWxkcmVuO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8Yy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGxldCBuID0gY1tpXTtcbiAgICAgICAgICAvLyBJZ25vcmUgbm9uLWNoYW5nZXNcbiAgICAgICAgICBpZiAoQm9vbGVhbihoaWRlKSAhPSBCb29sZWFuKG4uX19oaWRlVGVtcGxhdGVDaGlsZHJlbl9fKSkge1xuICAgICAgICAgICAgaWYgKG4ubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFKSB7XG4gICAgICAgICAgICAgIGlmIChoaWRlKSB7XG4gICAgICAgICAgICAgICAgbi5fX3BvbHltZXJUZXh0Q29udGVudF9fID0gbi50ZXh0Q29udGVudDtcbiAgICAgICAgICAgICAgICBuLnRleHRDb250ZW50ID0gJyc7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbi50ZXh0Q29udGVudCA9IG4uX19wb2x5bWVyVGV4dENvbnRlbnRfXztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChuLnN0eWxlKSB7XG4gICAgICAgICAgICAgIGlmIChoaWRlKSB7XG4gICAgICAgICAgICAgICAgbi5fX3BvbHltZXJEaXNwbGF5X18gPSBuLnN0eWxlLmRpc3BsYXk7XG4gICAgICAgICAgICAgICAgbi5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG4uc3R5bGUuZGlzcGxheSA9IG4uX19wb2x5bWVyRGlzcGxheV9fO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIG4uX19oaWRlVGVtcGxhdGVDaGlsZHJlbl9fID0gaGlkZTtcbiAgICAgICAgICBpZiAobi5fc2hvd0hpZGVDaGlsZHJlbikge1xuICAgICAgICAgICAgbi5fc2hvd0hpZGVDaGlsZHJlbihoaWRlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogT3ZlcnJpZGVzIGRlZmF1bHQgcHJvcGVydHktZWZmZWN0cyBpbXBsZW1lbnRhdGlvbiB0byBpbnRlcmNlcHRcbiAgICAgICAqIHRleHRDb250ZW50IGJpbmRpbmdzIHdoaWxlIGNoaWxkcmVuIGFyZSBcImhpZGRlblwiIGFuZCBjYWNoZSBpblxuICAgICAgICogcHJpdmF0ZSBzdG9yYWdlIGZvciBsYXRlciByZXRyaWV2YWwuXG4gICAgICAgKlxuICAgICAgICogQG92ZXJyaWRlXG4gICAgICAgKi9cbiAgICAgIF9zZXRVbm1hbmFnZWRQcm9wZXJ0eVRvTm9kZShub2RlLCBwcm9wLCB2YWx1ZSkge1xuICAgICAgICBpZiAobm9kZS5fX2hpZGVUZW1wbGF0ZUNoaWxkcmVuX18gJiZcbiAgICAgICAgICAgIG5vZGUubm9kZVR5cGUgPT0gTm9kZS5URVhUX05PREUgJiYgcHJvcCA9PSAndGV4dENvbnRlbnQnKSB7XG4gICAgICAgICAgbm9kZS5fX3BvbHltZXJUZXh0Q29udGVudF9fID0gdmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3VwZXIuX3NldFVubWFuYWdlZFByb3BlcnR5VG9Ob2RlKG5vZGUsIHByb3AsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBGaW5kIHRoZSBwYXJlbnQgbW9kZWwgb2YgdGhpcyB0ZW1wbGF0ZSBpbnN0YW5jZS4gIFRoZSBwYXJlbnQgbW9kZWxcbiAgICAgICAqIGlzIGVpdGhlciBhbm90aGVyIHRlbXBsYXRpemUgaW5zdGFuY2UgdGhhdCBoYWQgb3B0aW9uIGBwYXJlbnRNb2RlbDogdHJ1ZWAsXG4gICAgICAgKiBvciBlbHNlIHRoZSBob3N0IGVsZW1lbnQuXG4gICAgICAgKlxuICAgICAgICogQHJldHVybiB7UG9seW1lcl9Qcm9wZXJ0eUVmZmVjdHN9IFRoZSBwYXJlbnQgbW9kZWwgb2YgdGhpcyBpbnN0YW5jZVxuICAgICAgICovXG4gICAgICBnZXQgcGFyZW50TW9kZWwoKSB7XG4gICAgICAgIGxldCBtb2RlbCA9IHRoaXMuX19wYXJlbnRNb2RlbDtcbiAgICAgICAgaWYgKCFtb2RlbCkge1xuICAgICAgICAgIGxldCBvcHRpb25zO1xuICAgICAgICAgIG1vZGVsID0gdGhpc1xuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIC8vIEEgdGVtcGxhdGUgaW5zdGFuY2UncyBgX19kYXRhSG9zdGAgaXMgYSA8dGVtcGxhdGU+XG4gICAgICAgICAgICAvLyBgbW9kZWwuX19kYXRhSG9zdC5fX2RhdGFIb3N0YCBpcyB0aGUgdGVtcGxhdGUncyBob3N0XG4gICAgICAgICAgICBtb2RlbCA9IG1vZGVsLl9fZGF0YUhvc3QuX19kYXRhSG9zdDtcbiAgICAgICAgICB9IHdoaWxlICgob3B0aW9ucyA9IG1vZGVsLl9fdGVtcGxhdGl6ZU9wdGlvbnMpICYmICFvcHRpb25zLnBhcmVudE1vZGVsKVxuICAgICAgICAgIHRoaXMuX19wYXJlbnRNb2RlbCA9IG1vZGVsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtb2RlbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogQHR5cGUgeyFEYXRhVGVtcGxhdGV9ICovXG4gICAgVGVtcGxhdGVJbnN0YW5jZUJhc2UucHJvdG90eXBlLl9fZGF0YUhvc3Q7XG4gICAgLyoqIEB0eXBlIHshVGVtcGxhdGl6ZU9wdGlvbnN9ICovXG4gICAgVGVtcGxhdGVJbnN0YW5jZUJhc2UucHJvdG90eXBlLl9fdGVtcGxhdGl6ZU9wdGlvbnM7XG4gICAgLyoqIEB0eXBlIHshUG9seW1lcl9Qcm9wZXJ0eUVmZmVjdHN9ICovXG4gICAgVGVtcGxhdGVJbnN0YW5jZUJhc2UucHJvdG90eXBlLl9tZXRob2RIb3N0O1xuICAgIC8qKiBAdHlwZSB7IU9iamVjdH0gKi9cbiAgICBUZW1wbGF0ZUluc3RhbmNlQmFzZS5wcm90b3R5cGUuX190ZW1wbGF0aXplT3duZXI7XG4gICAgLyoqIEB0eXBlIHshT2JqZWN0fSAqL1xuICAgIFRlbXBsYXRlSW5zdGFuY2VCYXNlLnByb3RvdHlwZS5fX2hvc3RQcm9wcztcblxuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBleHRlbmRzIHtUZW1wbGF0ZUluc3RhbmNlQmFzZX1cbiAgICAgKiBAaW1wbGVtZW50cyB7UG9seW1lcl9NdXRhYmxlRGF0YX1cbiAgICAgKi9cbiAgICBjb25zdCBNdXRhYmxlVGVtcGxhdGVJbnN0YW5jZUJhc2UgPSBQb2x5bWVyLk11dGFibGVEYXRhKFRlbXBsYXRlSW5zdGFuY2VCYXNlKTtcblxuICAgIGZ1bmN0aW9uIGZpbmRNZXRob2RIb3N0KHRlbXBsYXRlKSB7XG4gICAgICAvLyBUZWNobmljYWxseSB0aGlzIHNob3VsZCBiZSB0aGUgb3duZXIgb2YgdGhlIG91dGVybW9zdCB0ZW1wbGF0ZS5cbiAgICAgIC8vIEluIHNoYWRvdyBkb20sIHRoaXMgaXMgYWx3YXlzIGdldFJvb3ROb2RlKCkuaG9zdCwgYnV0IHdlIGNhblxuICAgICAgLy8gYXBwcm94aW1hdGUgdGhpcyB2aWEgY29vcGVyYXRpb24gd2l0aCBvdXIgZGF0YUhvc3QgYWx3YXlzIHNldHRpbmdcbiAgICAgIC8vIGBfbWV0aG9kSG9zdGAgYXMgbG9uZyBhcyB0aGVyZSB3ZXJlIGJpbmRpbmdzIChvciBpZCdzKSBvbiB0aGlzXG4gICAgICAvLyBpbnN0YW5jZSBjYXVzaW5nIGl0IHRvIGdldCBhIGRhdGFIb3N0LlxuICAgICAgbGV0IHRlbXBsYXRlSG9zdCA9IHRlbXBsYXRlLl9fZGF0YUhvc3Q7XG4gICAgICByZXR1cm4gdGVtcGxhdGVIb3N0ICYmIHRlbXBsYXRlSG9zdC5fbWV0aG9kSG9zdCB8fCB0ZW1wbGF0ZUhvc3Q7XG4gICAgfVxuXG4gICAgLyogZXNsaW50LWRpc2FibGUgdmFsaWQtanNkb2MgKi9cbiAgICAvKipcbiAgICAgKiBAc3VwcHJlc3Mge21pc3NpbmdQcm9wZXJ0aWVzfSBjbGFzcy5wcm90b3R5cGUgaXMgbm90IGRlZmluZWQgZm9yIHNvbWUgcmVhc29uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlVGVtcGxhdGl6ZXJDbGFzcyh0ZW1wbGF0ZSwgdGVtcGxhdGVJbmZvLCBvcHRpb25zKSB7XG4gICAgICAvLyBBbm9ueW1vdXMgY2xhc3MgY3JlYXRlZCBieSB0aGUgdGVtcGxhdGl6ZVxuICAgICAgbGV0IGJhc2UgPSBvcHRpb25zLm11dGFibGVEYXRhID9cbiAgICAgICAgTXV0YWJsZVRlbXBsYXRlSW5zdGFuY2VCYXNlIDogVGVtcGxhdGVJbnN0YW5jZUJhc2U7XG4gICAgICAvKipcbiAgICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAgICogQGV4dGVuZHMge2Jhc2V9XG4gICAgICAgKi9cbiAgICAgIGxldCBrbGFzcyA9IGNsYXNzIGV4dGVuZHMgYmFzZSB7IH1cbiAgICAgIGtsYXNzLnByb3RvdHlwZS5fX3RlbXBsYXRpemVPcHRpb25zID0gb3B0aW9ucztcbiAgICAgIGtsYXNzLnByb3RvdHlwZS5fYmluZFRlbXBsYXRlKHRlbXBsYXRlKTtcbiAgICAgIGFkZE5vdGlmeUVmZmVjdHMoa2xhc3MsIHRlbXBsYXRlLCB0ZW1wbGF0ZUluZm8sIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIGtsYXNzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBzdXBwcmVzcyB7bWlzc2luZ1Byb3BlcnRpZXN9IGNsYXNzLnByb3RvdHlwZSBpcyBub3QgZGVmaW5lZCBmb3Igc29tZSByZWFzb25cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhZGRQcm9wYWdhdGVFZmZlY3RzKHRlbXBsYXRlLCB0ZW1wbGF0ZUluZm8sIG9wdGlvbnMpIHtcbiAgICAgIGxldCB1c2VyRm9yd2FyZEhvc3RQcm9wID0gb3B0aW9ucy5mb3J3YXJkSG9zdFByb3A7XG4gICAgICBpZiAodXNlckZvcndhcmRIb3N0UHJvcCkge1xuICAgICAgICAvLyBQcm92aWRlIGRhdGEgQVBJIGFuZCBwcm9wZXJ0eSBlZmZlY3RzIG9uIG1lbW9pemVkIHRlbXBsYXRlIGNsYXNzXG4gICAgICAgIGxldCBrbGFzcyA9IHRlbXBsYXRlSW5mby50ZW1wbGF0aXplVGVtcGxhdGVDbGFzcztcbiAgICAgICAgaWYgKCFrbGFzcykge1xuICAgICAgICAgIGxldCBiYXNlID0gb3B0aW9ucy5tdXRhYmxlRGF0YSA/IE11dGFibGVEYXRhVGVtcGxhdGUgOiBEYXRhVGVtcGxhdGU7XG4gICAgICAgICAga2xhc3MgPSB0ZW1wbGF0ZUluZm8udGVtcGxhdGl6ZVRlbXBsYXRlQ2xhc3MgPVxuICAgICAgICAgICAgY2xhc3MgVGVtcGxhdGl6ZWRUZW1wbGF0ZSBleHRlbmRzIGJhc2Uge31cbiAgICAgICAgICAvLyBBZGQgdGVtcGxhdGUgLSA+aW5zdGFuY2VzIGVmZmVjdHNcbiAgICAgICAgICAvLyBhbmQgaG9zdCA8LSB0ZW1wbGF0ZSBlZmZlY3RzXG4gICAgICAgICAgbGV0IGhvc3RQcm9wcyA9IHRlbXBsYXRlSW5mby5ob3N0UHJvcHM7XG4gICAgICAgICAgZm9yIChsZXQgcHJvcCBpbiBob3N0UHJvcHMpIHtcbiAgICAgICAgICAgIGtsYXNzLnByb3RvdHlwZS5fYWRkUHJvcGVydHlFZmZlY3QoJ19ob3N0XycgKyBwcm9wLFxuICAgICAgICAgICAgICBrbGFzcy5wcm90b3R5cGUuUFJPUEVSVFlfRUZGRUNUX1RZUEVTLlBST1BBR0FURSxcbiAgICAgICAgICAgICAge2ZuOiBjcmVhdGVGb3J3YXJkSG9zdFByb3BFZmZlY3QocHJvcCwgdXNlckZvcndhcmRIb3N0UHJvcCl9KTtcbiAgICAgICAgICAgIGtsYXNzLnByb3RvdHlwZS5fY3JlYXRlTm90aWZ5aW5nUHJvcGVydHkoJ19ob3N0XycgKyBwcm9wKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdXBncmFkZVRlbXBsYXRlKHRlbXBsYXRlLCBrbGFzcyk7XG4gICAgICAgIC8vIE1peCBhbnkgcHJlLWJvdW5kIGRhdGEgaW50byBfX2RhdGE7IG5vIG5lZWQgdG8gZmx1c2ggdGhpcyB0b1xuICAgICAgICAvLyBpbnN0YW5jZXMgc2luY2UgdGhleSBwdWxsIGZyb20gdGhlIHRlbXBsYXRlIGF0IGluc3RhbmNlLXRpbWVcbiAgICAgICAgaWYgKHRlbXBsYXRlLl9fZGF0YVByb3RvKSB7XG4gICAgICAgICAgLy8gTm90ZSwgZ2VuZXJhbGx5IGBfX2RhdGFQcm90b2AgY291bGQgYmUgY2hhaW5lZCwgYnV0IGl0J3MgZ3VhcmFudGVlZFxuICAgICAgICAgIC8vIHRvIG5vdCBiZSBzaW5jZSB0aGlzIGlzIGEgdmFuaWxsYSB0ZW1wbGF0ZSB3ZSBqdXN0IGFkZGVkIGVmZmVjdHMgdG9cbiAgICAgICAgICBPYmplY3QuYXNzaWduKHRlbXBsYXRlLl9fZGF0YSwgdGVtcGxhdGUuX19kYXRhUHJvdG8pO1xuICAgICAgICB9XG4gICAgICAgIC8vIENsZWFyIGFueSBwZW5kaW5nIGRhdGEgZm9yIHBlcmZvcm1hbmNlXG4gICAgICAgIHRlbXBsYXRlLl9fZGF0YVRlbXAgPSB7fTtcbiAgICAgICAgdGVtcGxhdGUuX19kYXRhUGVuZGluZyA9IG51bGw7XG4gICAgICAgIHRlbXBsYXRlLl9fZGF0YU9sZCA9IG51bGw7XG4gICAgICAgIHRlbXBsYXRlLl9lbmFibGVQcm9wZXJ0aWVzKCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qIGVzbGludC1lbmFibGUgdmFsaWQtanNkb2MgKi9cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUZvcndhcmRIb3N0UHJvcEVmZmVjdChob3N0UHJvcCwgdXNlckZvcndhcmRIb3N0UHJvcCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIGZvcndhcmRIb3N0UHJvcCh0ZW1wbGF0ZSwgcHJvcCwgcHJvcHMpIHtcbiAgICAgICAgdXNlckZvcndhcmRIb3N0UHJvcC5jYWxsKHRlbXBsYXRlLl9fdGVtcGxhdGl6ZU93bmVyLFxuICAgICAgICAgIHByb3Auc3Vic3RyaW5nKCdfaG9zdF8nLmxlbmd0aCksIHByb3BzW3Byb3BdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGROb3RpZnlFZmZlY3RzKGtsYXNzLCB0ZW1wbGF0ZSwgdGVtcGxhdGVJbmZvLCBvcHRpb25zKSB7XG4gICAgICBsZXQgaG9zdFByb3BzID0gdGVtcGxhdGVJbmZvLmhvc3RQcm9wcyB8fCB7fTtcbiAgICAgIGZvciAobGV0IGlwcm9wIGluIG9wdGlvbnMuaW5zdGFuY2VQcm9wcykge1xuICAgICAgICBkZWxldGUgaG9zdFByb3BzW2lwcm9wXTtcbiAgICAgICAgbGV0IHVzZXJOb3RpZnlJbnN0YW5jZVByb3AgPSBvcHRpb25zLm5vdGlmeUluc3RhbmNlUHJvcDtcbiAgICAgICAgaWYgKHVzZXJOb3RpZnlJbnN0YW5jZVByb3ApIHtcbiAgICAgICAgICBrbGFzcy5wcm90b3R5cGUuX2FkZFByb3BlcnR5RWZmZWN0KGlwcm9wLFxuICAgICAgICAgICAga2xhc3MucHJvdG90eXBlLlBST1BFUlRZX0VGRkVDVF9UWVBFUy5OT1RJRlksXG4gICAgICAgICAgICB7Zm46IGNyZWF0ZU5vdGlmeUluc3RhbmNlUHJvcEVmZmVjdChpcHJvcCwgdXNlck5vdGlmeUluc3RhbmNlUHJvcCl9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuZm9yd2FyZEhvc3RQcm9wICYmIHRlbXBsYXRlLl9fZGF0YUhvc3QpIHtcbiAgICAgICAgZm9yIChsZXQgaHByb3AgaW4gaG9zdFByb3BzKSB7XG4gICAgICAgICAga2xhc3MucHJvdG90eXBlLl9hZGRQcm9wZXJ0eUVmZmVjdChocHJvcCxcbiAgICAgICAgICAgIGtsYXNzLnByb3RvdHlwZS5QUk9QRVJUWV9FRkZFQ1RfVFlQRVMuTk9USUZZLFxuICAgICAgICAgICAge2ZuOiBjcmVhdGVOb3RpZnlIb3N0UHJvcEVmZmVjdCgpfSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZU5vdGlmeUluc3RhbmNlUHJvcEVmZmVjdChpbnN0UHJvcCwgdXNlck5vdGlmeUluc3RhbmNlUHJvcCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIG5vdGlmeUluc3RhbmNlUHJvcChpbnN0LCBwcm9wLCBwcm9wcykge1xuICAgICAgICB1c2VyTm90aWZ5SW5zdGFuY2VQcm9wLmNhbGwoaW5zdC5fX3RlbXBsYXRpemVPd25lcixcbiAgICAgICAgICBpbnN0LCBwcm9wLCBwcm9wc1twcm9wXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlTm90aWZ5SG9zdFByb3BFZmZlY3QoKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gbm90aWZ5SG9zdFByb3AoaW5zdCwgcHJvcCwgcHJvcHMpIHtcbiAgICAgICAgaW5zdC5fX2RhdGFIb3N0Ll9zZXRQZW5kaW5nUHJvcGVydHlPclBhdGgoJ19ob3N0XycgKyBwcm9wLCBwcm9wc1twcm9wXSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTW9kdWxlIGZvciBwcmVwYXJpbmcgYW5kIHN0YW1waW5nIGluc3RhbmNlcyBvZiB0ZW1wbGF0ZXMgdGhhdCB1dGlsaXplXG4gICAgICogUG9seW1lcidzIGRhdGEtYmluZGluZyBhbmQgZGVjbGFyYXRpdmUgZXZlbnQgbGlzdGVuZXIgZmVhdHVyZXMuXG4gICAgICpcbiAgICAgKiBFeGFtcGxlOlxuICAgICAqXG4gICAgICogICAgIC8vIEdldCBhIHRlbXBsYXRlIGZyb20gc29tZXdoZXJlLCBlLmcuIGxpZ2h0IERPTVxuICAgICAqICAgICBsZXQgdGVtcGxhdGUgPSB0aGlzLnF1ZXJ5U2VsZWN0b3IoJ3RlbXBsYXRlJyk7XG4gICAgICogICAgIC8vIFByZXBhcmUgdGhlIHRlbXBsYXRlXG4gICAgICogICAgIGxldCBUZW1wbGF0ZUNsYXNzID0gUG9seW1lci5UZW1wbGF0aXplLnRlbXBsYXRpemUodGVtcGxhdGUpO1xuICAgICAqICAgICAvLyBJbnN0YW5jZSB0aGUgdGVtcGxhdGUgd2l0aCBhbiBpbml0aWFsIGRhdGEgbW9kZWxcbiAgICAgKiAgICAgbGV0IGluc3RhbmNlID0gbmV3IFRlbXBsYXRlQ2xhc3Moe215UHJvcDogJ2luaXRpYWwnfSk7XG4gICAgICogICAgIC8vIEluc2VydCB0aGUgaW5zdGFuY2UncyBET00gc29tZXdoZXJlLCBlLmcuIGVsZW1lbnQncyBzaGFkb3cgRE9NXG4gICAgICogICAgIHRoaXMuc2hhZG93Um9vdC5hcHBlbmRDaGlsZChpbnN0YW5jZS5yb290KTtcbiAgICAgKiAgICAgLy8gQ2hhbmdpbmcgYSBwcm9wZXJ0eSBvbiB0aGUgaW5zdGFuY2Ugd2lsbCBwcm9wYWdhdGUgdG8gYmluZGluZ3NcbiAgICAgKiAgICAgLy8gaW4gdGhlIHRlbXBsYXRlXG4gICAgICogICAgIGluc3RhbmNlLm15UHJvcCA9ICduZXcgdmFsdWUnO1xuICAgICAqXG4gICAgICogVGhlIGBvcHRpb25zYCBkaWN0aW9uYXJ5IHBhc3NlZCB0byBgdGVtcGxhdGl6ZWAgYWxsb3dzIGZvciBjdXN0b21pemluZ1xuICAgICAqIGZlYXR1cmVzIG9mIHRoZSBnZW5lcmF0ZWQgdGVtcGxhdGUgY2xhc3MsIGluY2x1ZGluZyBob3cgb3V0ZXItc2NvcGUgaG9zdFxuICAgICAqIHByb3BlcnRpZXMgc2hvdWxkIGJlIGZvcndhcmRlZCBpbnRvIHRlbXBsYXRlIGluc3RhbmNlcywgaG93IGFueSBpbnN0YW5jZVxuICAgICAqIHByb3BlcnRpZXMgYWRkZWQgaW50byB0aGUgdGVtcGxhdGUncyBzY29wZSBzaG91bGQgYmUgbm90aWZpZWQgb3V0IHRvXG4gICAgICogdGhlIGhvc3QsIGFuZCB3aGV0aGVyIHRoZSBpbnN0YW5jZSBzaG91bGQgYmUgZGVjb3JhdGVkIGFzIGEgXCJwYXJlbnQgbW9kZWxcIlxuICAgICAqIG9mIGFueSBldmVudCBoYW5kbGVycy5cbiAgICAgKlxuICAgICAqICAgICAvLyBDdXN0b216ZSBwcm9wZXJ0eSBmb3J3YXJkaW5nIGFuZCBldmVudCBtb2RlbCBkZWNvcmF0aW9uXG4gICAgICogICAgIGxldCBUZW1wbGF0ZUNsYXNzID0gUG9seW1lci5UZW1wbGF0aXplLnRlbXBsYXRpemUodGVtcGxhdGUsIHRoaXMsIHtcbiAgICAgKiAgICAgICBwYXJlbnRNb2RlbDogdHJ1ZSxcbiAgICAgKiAgICAgICBpbnN0YW5jZVByb3BzOiB7Li4ufSxcbiAgICAgKiAgICAgICBmb3J3YXJkSG9zdFByb3AocHJvcGVydHksIHZhbHVlKSB7Li4ufSxcbiAgICAgKiAgICAgICBub3RpZnlJbnN0YW5jZVByb3AoaW5zdGFuY2UsIHByb3BlcnR5LCB2YWx1ZSkgey4uLn0sXG4gICAgICogICAgIH0pO1xuICAgICAqXG4gICAgICpcbiAgICAgKiBAbmFtZXNwYWNlXG4gICAgICogQG1lbWJlcm9mIFBvbHltZXJcbiAgICAgKiBAc3VtbWFyeSBNb2R1bGUgZm9yIHByZXBhcmluZyBhbmQgc3RhbXBpbmcgaW5zdGFuY2VzIG9mIHRlbXBsYXRlc1xuICAgICAqICAgdXRpbGl6aW5nIFBvbHltZXIgdGVtcGxhdGluZyBmZWF0dXJlcy5cbiAgICAgKi9cblxuICAgIGNvbnN0IFRlbXBsYXRpemUgPSB7XG5cbiAgICAgIC8qKlxuICAgICAgICogUmV0dXJucyBhbiBhbm9ueW1vdXMgYFBvbHltZXIuUHJvcGVydHlFZmZlY3RzYCBjbGFzcyBib3VuZCB0byB0aGVcbiAgICAgICAqIGA8dGVtcGxhdGU+YCBwcm92aWRlZC4gIEluc3RhbmNpbmcgdGhlIGNsYXNzIHdpbGwgcmVzdWx0IGluIHRoZVxuICAgICAgICogdGVtcGxhdGUgYmVpbmcgc3RhbXBlZCBpbnRvIGRvY3VtZW50IGZyYWdtZW50IHN0b3JlZCBhcyB0aGUgaW5zdGFuY2Unc1xuICAgICAgICogYHJvb3RgIHByb3BlcnR5LCBhZnRlciB3aGljaCBpdCBjYW4gYmUgYXBwZW5kZWQgdG8gdGhlIERPTS5cbiAgICAgICAqXG4gICAgICAgKiBUZW1wbGF0ZXMgbWF5IHV0aWxpemUgYWxsIFBvbHltZXIgZGF0YS1iaW5kaW5nIGZlYXR1cmVzIGFzIHdlbGwgYXNcbiAgICAgICAqIGRlY2xhcmF0aXZlIGV2ZW50IGxpc3RlbmVycy4gIEV2ZW50IGxpc3RlbmVycyBhbmQgaW5saW5lIGNvbXB1dGluZ1xuICAgICAgICogZnVuY3Rpb25zIGluIHRoZSB0ZW1wbGF0ZSB3aWxsIGJlIGNhbGxlZCBvbiB0aGUgaG9zdCBvZiB0aGUgdGVtcGxhdGUuXG4gICAgICAgKlxuICAgICAgICogVGhlIGNvbnN0cnVjdG9yIHJldHVybmVkIHRha2VzIGEgc2luZ2xlIGFyZ3VtZW50IGRpY3Rpb25hcnkgb2YgaW5pdGlhbFxuICAgICAgICogcHJvcGVydHkgdmFsdWVzIHRvIHByb3BhZ2F0ZSBpbnRvIHRlbXBsYXRlIGJpbmRpbmdzLiAgQWRkaXRpb25hbGx5XG4gICAgICAgKiBob3N0IHByb3BlcnRpZXMgY2FuIGJlIGZvcndhcmRlZCBpbiwgYW5kIGluc3RhbmNlIHByb3BlcnRpZXMgY2FuIGJlXG4gICAgICAgKiBub3RpZmllZCBvdXQgYnkgcHJvdmlkaW5nIG9wdGlvbmFsIGNhbGxiYWNrcyBpbiB0aGUgYG9wdGlvbnNgIGRpY3Rpb25hcnkuXG4gICAgICAgKlxuICAgICAgICogVmFsaWQgY29uZmlndXJhdGlvbiBpbiBgb3B0aW9uc2AgYXJlIGFzIGZvbGxvd3M6XG4gICAgICAgKlxuICAgICAgICogLSBgZm9yd2FyZEhvc3RQcm9wKHByb3BlcnR5LCB2YWx1ZSlgOiBDYWxsZWQgd2hlbiBhIHByb3BlcnR5IHJlZmVyZW5jZWRcbiAgICAgICAqICAgaW4gdGhlIHRlbXBsYXRlIGNoYW5nZWQgb24gdGhlIHRlbXBsYXRlJ3MgaG9zdC4gQXMgdGhpcyBsaWJyYXJ5IGRvZXNcbiAgICAgICAqICAgbm90IHJldGFpbiByZWZlcmVuY2VzIHRvIHRlbXBsYXRlcyBpbnN0YW5jZWQgYnkgdGhlIHVzZXIsIGl0IGlzIHRoZVxuICAgICAgICogICB0ZW1wbGF0aXplIG93bmVyJ3MgcmVzcG9uc2liaWxpdHkgdG8gZm9yd2FyZCBob3N0IHByb3BlcnR5IGNoYW5nZXMgaW50b1xuICAgICAgICogICB1c2VyLXN0YW1wZWQgaW5zdGFuY2VzLiAgVGhlIGBpbnN0YW5jZS5mb3J3YXJkSG9zdFByb3AocHJvcGVydHksIHZhbHVlKWBcbiAgICAgICAqICAgIG1ldGhvZCBvbiB0aGUgZ2VuZXJhdGVkIGNsYXNzIHNob3VsZCBiZSBjYWxsZWQgdG8gZm9yd2FyZCBob3N0XG4gICAgICAgKiAgIHByb3BlcnRpZXMgaW50byB0aGUgdGVtcGxhdGUgdG8gcHJldmVudCB1bm5lY2Vzc2FyeSBwcm9wZXJ0eS1jaGFuZ2VkXG4gICAgICAgKiAgIG5vdGlmaWNhdGlvbnMuIEFueSBwcm9wZXJ0aWVzIHJlZmVyZW5jZWQgaW4gdGhlIHRlbXBsYXRlIHRoYXQgYXJlIG5vdFxuICAgICAgICogICBkZWZpbmVkIGluIGBpbnN0YW5jZVByb3BzYCB3aWxsIGJlIG5vdGlmaWVkIHVwIHRvIHRoZSB0ZW1wbGF0ZSdzIGhvc3RcbiAgICAgICAqICAgYXV0b21hdGljYWxseS5cbiAgICAgICAqIC0gYGluc3RhbmNlUHJvcHNgOiBEaWN0aW9uYXJ5IG9mIHByb3BlcnR5IG5hbWVzIHRoYXQgd2lsbCBiZSBhZGRlZFxuICAgICAgICogICB0byB0aGUgaW5zdGFuY2UgYnkgdGhlIHRlbXBsYXRpemUgb3duZXIuICBUaGVzZSBwcm9wZXJ0aWVzIHNoYWRvdyBhbnlcbiAgICAgICAqICAgaG9zdCBwcm9wZXJ0aWVzLCBhbmQgY2hhbmdlcyB3aXRoaW4gdGhlIHRlbXBsYXRlIHRvIHRoZXNlIHByb3BlcnRpZXNcbiAgICAgICAqICAgd2lsbCByZXN1bHQgaW4gYG5vdGlmeUluc3RhbmNlUHJvcGAgYmVpbmcgY2FsbGVkLlxuICAgICAgICogLSBgbXV0YWJsZURhdGFgOiBXaGVuIGB0cnVlYCwgdGhlIGdlbmVyYXRlZCBjbGFzcyB3aWxsIHNraXAgc3RyaWN0XG4gICAgICAgKiAgIGRpcnR5LWNoZWNraW5nIGZvciBvYmplY3RzIGFuZCBhcnJheXMgKGFsd2F5cyBjb25zaWRlciB0aGVtIHRvIGJlXG4gICAgICAgKiAgIFwiZGlydHlcIikuXG4gICAgICAgKiAtIGBub3RpZnlJbnN0YW5jZVByb3AoaW5zdGFuY2UsIHByb3BlcnR5LCB2YWx1ZSlgOiBDYWxsZWQgd2hlblxuICAgICAgICogICBhbiBpbnN0YW5jZSBwcm9wZXJ0eSBjaGFuZ2VzLiAgVXNlcnMgbWF5IGNob29zZSB0byBjYWxsIGBub3RpZnlQYXRoYFxuICAgICAgICogICBvbiBlLmcuIHRoZSBvd25lciB0byBub3RpZnkgdGhlIGNoYW5nZS5cbiAgICAgICAqIC0gYHBhcmVudE1vZGVsYDogV2hlbiBgdHJ1ZWAsIGV2ZW50cyBoYW5kbGVkIGJ5IGRlY2xhcmF0aXZlIGV2ZW50IGxpc3RlbmVyc1xuICAgICAgICogICAoYG9uLWV2ZW50PVwiaGFuZGxlclwiYCkgd2lsbCBiZSBkZWNvcmF0ZWQgd2l0aCBhIGBtb2RlbGAgcHJvcGVydHkgcG9pbnRpbmdcbiAgICAgICAqICAgdG8gdGhlIHRlbXBsYXRlIGluc3RhbmNlIHRoYXQgc3RhbXBlZCBpdC4gIEl0IHdpbGwgYWxzbyBiZSByZXR1cm5lZFxuICAgICAgICogICBmcm9tIGBpbnN0YW5jZS5wYXJlbnRNb2RlbGAgaW4gY2FzZXMgd2hlcmUgdGVtcGxhdGUgaW5zdGFuY2UgbmVzdGluZ1xuICAgICAgICogICBjYXVzZXMgYW4gaW5uZXIgbW9kZWwgdG8gc2hhZG93IGFuIG91dGVyIG1vZGVsLlxuICAgICAgICpcbiAgICAgICAqIE5vdGUgdGhhdCB0aGUgY2xhc3MgcmV0dXJuZWQgZnJvbSBgdGVtcGxhdGl6ZWAgaXMgZ2VuZXJhdGVkIG9ubHkgb25jZVxuICAgICAgICogZm9yIGEgZ2l2ZW4gYDx0ZW1wbGF0ZT5gIHVzaW5nIGBvcHRpb25zYCBmcm9tIHRoZSBmaXJzdCBjYWxsIGZvciB0aGF0XG4gICAgICAgKiB0ZW1wbGF0ZSwgYW5kIHRoZSBjYWNoZWQgY2xhc3MgaXMgcmV0dXJuZWQgZm9yIGFsbCBzdWJzZXF1ZW50IGNhbGxzIHRvXG4gICAgICAgKiBgdGVtcGxhdGl6ZWAgZm9yIHRoYXQgdGVtcGxhdGUuICBBcyBzdWNoLCBgb3B0aW9uc2AgY2FsbGJhY2tzIHNob3VsZCBub3RcbiAgICAgICAqIGNsb3NlIG92ZXIgb3duZXItc3BlY2lmaWMgcHJvcGVydGllcyBzaW5jZSBvbmx5IHRoZSBmaXJzdCBgb3B0aW9uc2AgaXNcbiAgICAgICAqIHVzZWQ7IHJhdGhlciwgY2FsbGJhY2tzIGFyZSBjYWxsZWQgYm91bmQgdG8gdGhlIGBvd25lcmAsIGFuZCBzbyBjb250ZXh0XG4gICAgICAgKiBuZWVkZWQgZnJvbSB0aGUgY2FsbGJhY2tzIChzdWNoIGFzIHJlZmVyZW5jZXMgdG8gYGluc3RhbmNlc2Agc3RhbXBlZClcbiAgICAgICAqIHNob3VsZCBiZSBzdG9yZWQgb24gdGhlIGBvd25lcmAgc3VjaCB0aGF0IHRoZXkgY2FuIGJlIHJldHJpZXZlZCB2aWEgYHRoaXNgLlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJvZiBQb2x5bWVyLlRlbXBsYXRpemVcbiAgICAgICAqIEBwYXJhbSB7IUhUTUxUZW1wbGF0ZUVsZW1lbnR9IHRlbXBsYXRlIFRlbXBsYXRlIHRvIHRlbXBsYXRpemVcbiAgICAgICAqIEBwYXJhbSB7IVBvbHltZXJfUHJvcGVydHlFZmZlY3RzfSBvd25lciBPd25lciBvZiB0aGUgdGVtcGxhdGUgaW5zdGFuY2VzO1xuICAgICAgICogICBhbnkgb3B0aW9uYWwgY2FsbGJhY2tzIHdpbGwgYmUgYm91bmQgdG8gdGhpcyBvd25lci5cbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9ucyBPcHRpb25zIGRpY3Rpb25hcnkgKHNlZSBzdW1tYXJ5IGZvciBkZXRhaWxzKVxuICAgICAgICogQHJldHVybiB7ZnVuY3Rpb24obmV3OlRlbXBsYXRlSW5zdGFuY2VCYXNlKX0gR2VuZXJhdGVkIGNsYXNzIGJvdW5kIHRvIHRoZSB0ZW1wbGF0ZVxuICAgICAgICogICBwcm92aWRlZFxuICAgICAgICogQHN1cHByZXNzIHtpbnZhbGlkQ2FzdHN9XG4gICAgICAgKi9cbiAgICAgIHRlbXBsYXRpemUodGVtcGxhdGUsIG93bmVyLCBvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSAvKiogQHR5cGUgeyFUZW1wbGF0aXplT3B0aW9uc30gKi8ob3B0aW9ucyB8fCB7fSk7XG4gICAgICAgIGlmICh0ZW1wbGF0ZS5fX3RlbXBsYXRpemVPd25lcikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQSA8dGVtcGxhdGU+IGNhbiBvbmx5IGJlIHRlbXBsYXRpemVkIG9uY2UnKTtcbiAgICAgICAgfVxuICAgICAgICB0ZW1wbGF0ZS5fX3RlbXBsYXRpemVPd25lciA9IG93bmVyO1xuICAgICAgICBsZXQgdGVtcGxhdGVJbmZvID0gb3duZXIuY29uc3RydWN0b3IuX3BhcnNlVGVtcGxhdGUodGVtcGxhdGUpO1xuICAgICAgICAvLyBHZXQgbWVtb2l6ZWQgYmFzZSBjbGFzcyBmb3IgdGhlIHByb3RvdHlwaWNhbCB0ZW1wbGF0ZSwgd2hpY2hcbiAgICAgICAgLy8gaW5jbHVkZXMgcHJvcGVydHkgZWZmZWN0cyBmb3IgYmluZGluZyB0ZW1wbGF0ZSAmIGZvcndhcmRpbmdcbiAgICAgICAgbGV0IGJhc2VDbGFzcyA9IHRlbXBsYXRlSW5mby50ZW1wbGF0aXplSW5zdGFuY2VDbGFzcztcbiAgICAgICAgaWYgKCFiYXNlQ2xhc3MpIHtcbiAgICAgICAgICBiYXNlQ2xhc3MgPSBjcmVhdGVUZW1wbGF0aXplckNsYXNzKHRlbXBsYXRlLCB0ZW1wbGF0ZUluZm8sIG9wdGlvbnMpO1xuICAgICAgICAgIHRlbXBsYXRlSW5mby50ZW1wbGF0aXplSW5zdGFuY2VDbGFzcyA9IGJhc2VDbGFzcztcbiAgICAgICAgfVxuICAgICAgICAvLyBIb3N0IHByb3BlcnR5IGZvcndhcmRpbmcgbXVzdCBiZSBpbnN0YWxsZWQgb250byB0ZW1wbGF0ZSBpbnN0YW5jZVxuICAgICAgICBhZGRQcm9wYWdhdGVFZmZlY3RzKHRlbXBsYXRlLCB0ZW1wbGF0ZUluZm8sIG9wdGlvbnMpO1xuICAgICAgICAvLyBTdWJjbGFzcyBiYXNlIGNsYXNzIGFuZCBhZGQgcmVmZXJlbmNlIGZvciB0aGlzIHNwZWNpZmljIHRlbXBsYXRlXG4gICAgICAgIGxldCBrbGFzcyA9IGNsYXNzIFRlbXBsYXRlSW5zdGFuY2UgZXh0ZW5kcyBiYXNlQ2xhc3Mge307XG4gICAgICAgIGtsYXNzLnByb3RvdHlwZS5fbWV0aG9kSG9zdCA9IGZpbmRNZXRob2RIb3N0KHRlbXBsYXRlKTtcbiAgICAgICAga2xhc3MucHJvdG90eXBlLl9fZGF0YUhvc3QgPSB0ZW1wbGF0ZTtcbiAgICAgICAga2xhc3MucHJvdG90eXBlLl9fdGVtcGxhdGl6ZU93bmVyID0gb3duZXI7XG4gICAgICAgIGtsYXNzLnByb3RvdHlwZS5fX2hvc3RQcm9wcyA9IHRlbXBsYXRlSW5mby5ob3N0UHJvcHM7XG4gICAgICAgIHJldHVybiAvKiogQHR5cGUge2Z1bmN0aW9uKG5ldzpUZW1wbGF0ZUluc3RhbmNlQmFzZSl9ICovKGtsYXNzKTtcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogUmV0dXJucyB0aGUgdGVtcGxhdGUgXCJtb2RlbFwiIGFzc29jaWF0ZWQgd2l0aCBhIGdpdmVuIGVsZW1lbnQsIHdoaWNoXG4gICAgICAgKiBzZXJ2ZXMgYXMgdGhlIGJpbmRpbmcgc2NvcGUgZm9yIHRoZSB0ZW1wbGF0ZSBpbnN0YW5jZSB0aGUgZWxlbWVudCBpc1xuICAgICAgICogY29udGFpbmVkIGluLiBBIHRlbXBsYXRlIG1vZGVsIGlzIGFuIGluc3RhbmNlIG9mXG4gICAgICAgKiBgVGVtcGxhdGVJbnN0YW5jZUJhc2VgLCBhbmQgc2hvdWxkIGJlIHVzZWQgdG8gbWFuaXB1bGF0ZSBkYXRhXG4gICAgICAgKiBhc3NvY2lhdGVkIHdpdGggdGhpcyB0ZW1wbGF0ZSBpbnN0YW5jZS5cbiAgICAgICAqXG4gICAgICAgKiBFeGFtcGxlOlxuICAgICAgICpcbiAgICAgICAqICAgbGV0IG1vZGVsID0gbW9kZWxGb3JFbGVtZW50KGVsKTtcbiAgICAgICAqICAgaWYgKG1vZGVsLmluZGV4IDwgMTApIHtcbiAgICAgICAqICAgICBtb2RlbC5zZXQoJ2l0ZW0uY2hlY2tlZCcsIHRydWUpO1xuICAgICAgICogICB9XG4gICAgICAgKlxuICAgICAgICogQG1lbWJlcm9mIFBvbHltZXIuVGVtcGxhdGl6ZVxuICAgICAgICogQHBhcmFtIHtIVE1MVGVtcGxhdGVFbGVtZW50fSB0ZW1wbGF0ZSBUaGUgbW9kZWwgd2lsbCBiZSByZXR1cm5lZCBmb3JcbiAgICAgICAqICAgZWxlbWVudHMgc3RhbXBlZCBmcm9tIHRoaXMgdGVtcGxhdGVcbiAgICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBOb2RlIGZvciB3aGljaCB0byByZXR1cm4gYSB0ZW1wbGF0ZSBtb2RlbC5cbiAgICAgICAqIEByZXR1cm4ge1RlbXBsYXRlSW5zdGFuY2VCYXNlfSBUZW1wbGF0ZSBpbnN0YW5jZSByZXByZXNlbnRpbmcgdGhlXG4gICAgICAgKiAgIGJpbmRpbmcgc2NvcGUgZm9yIHRoZSBlbGVtZW50XG4gICAgICAgKi9cbiAgICAgIG1vZGVsRm9yRWxlbWVudCh0ZW1wbGF0ZSwgbm9kZSkge1xuICAgICAgICBsZXQgbW9kZWw7XG4gICAgICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgICAgLy8gQW4gZWxlbWVudCB3aXRoIGEgX190ZW1wbGF0aXplSW5zdGFuY2UgbWFya3MgdGhlIHRvcCBib3VuZGFyeVxuICAgICAgICAgIC8vIG9mIGEgc2NvcGU7IHdhbGsgdXAgdW50aWwgd2UgZmluZCBvbmUsIGFuZCB0aGVuIGVuc3VyZSB0aGF0XG4gICAgICAgICAgLy8gaXRzIF9fZGF0YUhvc3QgbWF0Y2hlcyBgdGhpc2AsIG1lYW5pbmcgdGhpcyBkb20tcmVwZWF0IHN0YW1wZWQgaXRcbiAgICAgICAgICBpZiAoKG1vZGVsID0gbm9kZS5fX3RlbXBsYXRpemVJbnN0YW5jZSkpIHtcbiAgICAgICAgICAgIC8vIEZvdW5kIGFuIGVsZW1lbnQgc3RhbXBlZCBieSBhbm90aGVyIHRlbXBsYXRlOyBrZWVwIHdhbGtpbmcgdXBcbiAgICAgICAgICAgIC8vIGZyb20gaXRzIF9fZGF0YUhvc3RcbiAgICAgICAgICAgIGlmIChtb2RlbC5fX2RhdGFIb3N0ICE9IHRlbXBsYXRlKSB7XG4gICAgICAgICAgICAgIG5vZGUgPSBtb2RlbC5fX2RhdGFIb3N0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG1vZGVsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBTdGlsbCBpbiBhIHRlbXBsYXRlIHNjb3BlLCBrZWVwIGdvaW5nIHVwIHVudGlsXG4gICAgICAgICAgICAvLyBhIF9fdGVtcGxhdGl6ZUluc3RhbmNlIGlzIGZvdW5kXG4gICAgICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBQb2x5bWVyLlRlbXBsYXRpemUgPSBUZW1wbGF0aXplO1xuICAgIFBvbHltZXIuVGVtcGxhdGVJbnN0YW5jZUJhc2UgPSBUZW1wbGF0ZUluc3RhbmNlQmFzZTtcblxuICB9KSgpO1xuXG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvdXRpbHMvdGVtcGxhdGl6ZS5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNiBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuXG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vLi4vcG9seW1lci9wb2x5bWVyLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi8uLi9pcm9uLXJlc2l6YWJsZS1iZWhhdmlvci9pcm9uLXJlc2l6YWJsZS1iZWhhdmlvci5odG1sXCI+XG5cbjxzY3JpcHQ+XG5cbiAgLyoqXG4gICAqIEBwb2x5bWVyQmVoYXZpb3IgUG9seW1lci5BcHBMYXlvdXRCZWhhdmlvclxuICAgKiovXG4gIFBvbHltZXIuQXBwTGF5b3V0QmVoYXZpb3IgPSBbXG4gICAgUG9seW1lci5Jcm9uUmVzaXphYmxlQmVoYXZpb3IsIHtcblxuICAgIGxpc3RlbmVyczoge1xuICAgICAgJ2FwcC1yZXNldC1sYXlvdXQnOiAnX2FwcFJlc2V0TGF5b3V0SGFuZGxlcicsXG4gICAgICAnaXJvbi1yZXNpemUnOiAncmVzZXRMYXlvdXQnXG4gICAgfSxcblxuICAgIGF0dGFjaGVkOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZmlyZSgnYXBwLXJlc2V0LWxheW91dCcpO1xuICAgIH0sXG5cbiAgICBfYXBwUmVzZXRMYXlvdXRIYW5kbGVyOiBmdW5jdGlvbihlKSB7XG4gICAgICBpZiAoUG9seW1lci5kb20oZSkucGF0aFswXSA9PT0gdGhpcykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLnJlc2V0TGF5b3V0KCk7XG4gICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH0sXG5cbiAgICBfdXBkYXRlTGF5b3V0U3RhdGVzOiBmdW5jdGlvbigpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ3VuaW1wbGVtZW50ZWQnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVzZXRzIHRoZSBsYXlvdXQuIElmIHlvdSBjaGFuZ2VkIHRoZSBzaXplIG9mIHRoaXMgZWxlbWVudCB2aWEgQ1NTXG4gICAgICogeW91IGNhbiBub3RpZnkgdGhlIGNoYW5nZXMgYnkgZWl0aGVyIGZpcmluZyB0aGUgYGlyb24tcmVzaXplYCBldmVudFxuICAgICAqIG9yIGNhbGxpbmcgYHJlc2V0TGF5b3V0YCBkaXJlY3RseS5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgcmVzZXRMYXlvdXRcbiAgICAgKi9cbiAgICByZXNldExheW91dDogZnVuY3Rpb24oKSB7XG4gICAgICAvLyBQb2x5bWVyIHYyLnhcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBjYiA9IHRoaXMuX3VwZGF0ZUxheW91dFN0YXRlcy5iaW5kKHRoaXMpO1xuICAgICAgaWYgKFBvbHltZXIuQXN5bmMgJiYgUG9seW1lci5Bc3luYy5hbmltYXRpb25GcmFtZSkge1xuICAgICAgICB0aGlzLl9sYXlvdXREZWJvdW5jZXIgPSBQb2x5bWVyLkRlYm91bmNlci5kZWJvdW5jZShcbiAgICAgICAgICAgIHRoaXMuX2xheW91dERlYm91bmNlcixcbiAgICAgICAgICAgIFBvbHltZXIuQXN5bmMuYW5pbWF0aW9uRnJhbWUsXG4gICAgICAgICAgICBjYik7XG4gICAgICAgIFBvbHltZXIuZW5xdWV1ZURlYm91bmNlcih0aGlzLl9sYXlvdXREZWJvdW5jZXIpO1xuICAgICAgfVxuICAgICAgLy8gUG9seW1lciB2MS54XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5kZWJvdW5jZSgncmVzZXRMYXlvdXQnLCBjYik7XG4gICAgICB9XG4gICAgICB0aGlzLl9ub3RpZnlEZXNjZW5kYW50UmVzaXplKCk7XG4gICAgfSxcblxuICAgIF9ub3RpZnlMYXlvdXRDaGFuZ2VkOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIC8vIFRPRE86IHRoZSBldmVudCBgYXBwLXJlc2V0LWxheW91dGAgY2FuIGJlIGZpcmVkIHN5bmNocm9ub3VzbHlcbiAgICAgIC8vIGFzIGxvbmcgYXMgYF91cGRhdGVMYXlvdXRTdGF0ZXNgIHdhaXRzIGZvciBhbGwgdGhlIG1pY3JvdGFza3MgYWZ0ZXIgckFGLlxuICAgICAgLy8gRS5nLiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoc2V0VGltZU91dCgpKVxuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCkge1xuICAgICAgICBzZWxmLmZpcmUoJ2FwcC1yZXNldC1sYXlvdXQnKTtcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBfbm90aWZ5RGVzY2VuZGFudFJlc2l6ZTogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXRoaXMuaXNBdHRhY2hlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl9pbnRlcmVzdGVkUmVzaXphYmxlcy5mb3JFYWNoKGZ1bmN0aW9uKHJlc2l6YWJsZSkge1xuICAgICAgICBpZiAodGhpcy5yZXNpemVyU2hvdWxkTm90aWZ5KHJlc2l6YWJsZSkpIHtcbiAgICAgICAgICB0aGlzLl9ub3RpZnlEZXNjZW5kYW50KHJlc2l6YWJsZSk7XG4gICAgICAgIH1cbiAgICAgIH0sIHRoaXMpO1xuICAgIH1cbiAgfV07XG5cbjwvc2NyaXB0PlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9hcHAtbGF5b3V0L2FwcC1sYXlvdXQtYmVoYXZpb3IvYXBwLWxheW91dC1iZWhhdmlvci5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNSBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuXG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vcG9seW1lci9wb2x5bWVyLmh0bWxcIj5cblxuPHNjcmlwdD5cbiAgKGZ1bmN0aW9uKCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIC8qKlxuICAgICAqIENocm9tZSB1c2VzIGFuIG9sZGVyIHZlcnNpb24gb2YgRE9NIExldmVsIDMgS2V5Ym9hcmQgRXZlbnRzXG4gICAgICpcbiAgICAgKiBNb3N0IGtleXMgYXJlIGxhYmVsZWQgYXMgdGV4dCwgYnV0IHNvbWUgYXJlIFVuaWNvZGUgY29kZXBvaW50cy5cbiAgICAgKiBWYWx1ZXMgdGFrZW4gZnJvbTogaHR0cDovL3d3dy53My5vcmcvVFIvMjAwNy9XRC1ET00tTGV2ZWwtMy1FdmVudHMtMjAwNzEyMjEva2V5c2V0Lmh0bWwjS2V5U2V0LVNldFxuICAgICAqL1xuICAgIHZhciBLRVlfSURFTlRJRklFUiA9IHtcbiAgICAgICdVKzAwMDgnOiAnYmFja3NwYWNlJyxcbiAgICAgICdVKzAwMDknOiAndGFiJyxcbiAgICAgICdVKzAwMUInOiAnZXNjJyxcbiAgICAgICdVKzAwMjAnOiAnc3BhY2UnLFxuICAgICAgJ1UrMDA3Ric6ICdkZWwnXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNwZWNpYWwgdGFibGUgZm9yIEtleWJvYXJkRXZlbnQua2V5Q29kZS5cbiAgICAgKiBLZXlib2FyZEV2ZW50LmtleUlkZW50aWZpZXIgaXMgYmV0dGVyLCBhbmQgS2V5Qm9hcmRFdmVudC5rZXkgaXMgZXZlbiBiZXR0ZXJcbiAgICAgKiB0aGFuIHRoYXQuXG4gICAgICpcbiAgICAgKiBWYWx1ZXMgZnJvbTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0tleWJvYXJkRXZlbnQua2V5Q29kZSNWYWx1ZV9vZl9rZXlDb2RlXG4gICAgICovXG4gICAgdmFyIEtFWV9DT0RFID0ge1xuICAgICAgODogJ2JhY2tzcGFjZScsXG4gICAgICA5OiAndGFiJyxcbiAgICAgIDEzOiAnZW50ZXInLFxuICAgICAgMjc6ICdlc2MnLFxuICAgICAgMzM6ICdwYWdldXAnLFxuICAgICAgMzQ6ICdwYWdlZG93bicsXG4gICAgICAzNTogJ2VuZCcsXG4gICAgICAzNjogJ2hvbWUnLFxuICAgICAgMzI6ICdzcGFjZScsXG4gICAgICAzNzogJ2xlZnQnLFxuICAgICAgMzg6ICd1cCcsXG4gICAgICAzOTogJ3JpZ2h0JyxcbiAgICAgIDQwOiAnZG93bicsXG4gICAgICA0NjogJ2RlbCcsXG4gICAgICAxMDY6ICcqJ1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBNT0RJRklFUl9LRVlTIG1hcHMgdGhlIHNob3J0IG5hbWUgZm9yIG1vZGlmaWVyIGtleXMgdXNlZCBpbiBhIGtleVxuICAgICAqIGNvbWJvIHN0cmluZyB0byB0aGUgcHJvcGVydHkgbmFtZSB0aGF0IHJlZmVyZW5jZXMgdGhvc2Ugc2FtZSBrZXlzXG4gICAgICogaW4gYSBLZXlib2FyZEV2ZW50IGluc3RhbmNlLlxuICAgICAqL1xuICAgIHZhciBNT0RJRklFUl9LRVlTID0ge1xuICAgICAgJ3NoaWZ0JzogJ3NoaWZ0S2V5JyxcbiAgICAgICdjdHJsJzogJ2N0cmxLZXknLFxuICAgICAgJ2FsdCc6ICdhbHRLZXknLFxuICAgICAgJ21ldGEnOiAnbWV0YUtleSdcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogS2V5Ym9hcmRFdmVudC5rZXkgaXMgbW9zdGx5IHJlcHJlc2VudGVkIGJ5IHByaW50YWJsZSBjaGFyYWN0ZXIgbWFkZSBieVxuICAgICAqIHRoZSBrZXlib2FyZCwgd2l0aCB1bnByaW50YWJsZSBrZXlzIGxhYmVsZWQgbmljZWx5LlxuICAgICAqXG4gICAgICogSG93ZXZlciwgb24gT1MgWCwgQWx0K2NoYXIgY2FuIG1ha2UgYSBVbmljb2RlIGNoYXJhY3RlciB0aGF0IGZvbGxvd3MgYW5cbiAgICAgKiBBcHBsZS1zcGVjaWZpYyBtYXBwaW5nLiBJbiB0aGlzIGNhc2UsIHdlIGZhbGwgYmFjayB0byAua2V5Q29kZS5cbiAgICAgKi9cbiAgICB2YXIgS0VZX0NIQVIgPSAvW2EtejAtOSpdLztcblxuICAgIC8qKlxuICAgICAqIE1hdGNoZXMgYSBrZXlJZGVudGlmaWVyIHN0cmluZy5cbiAgICAgKi9cbiAgICB2YXIgSURFTlRfQ0hBUiA9IC9VXFwrLztcblxuICAgIC8qKlxuICAgICAqIE1hdGNoZXMgYXJyb3cga2V5cyBpbiBHZWNrbyAyNy4wK1xuICAgICAqL1xuICAgIHZhciBBUlJPV19LRVkgPSAvXmFycm93LztcblxuICAgIC8qKlxuICAgICAqIE1hdGNoZXMgc3BhY2Uga2V5cyBldmVyeXdoZXJlIChub3RhYmx5IGluY2x1ZGluZyBJRTEwJ3MgZXhjZXB0aW9uYWwgbmFtZVxuICAgICAqIGBzcGFjZWJhcmApLlxuICAgICAqL1xuICAgIHZhciBTUEFDRV9LRVkgPSAvXnNwYWNlKGJhcik/LztcblxuICAgIC8qKlxuICAgICAqIE1hdGNoZXMgRVNDIGtleS5cbiAgICAgKlxuICAgICAqIFZhbHVlIGZyb206IGh0dHA6Ly93M2MuZ2l0aHViLmlvL3VpZXZlbnRzLWtleS8ja2V5LUVzY2FwZVxuICAgICAqL1xuICAgIHZhciBFU0NfS0VZID0gL15lc2NhcGUkLztcblxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybXMgdGhlIGtleS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBLZXlCb2FyZEV2ZW50LmtleVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW25vU3BlY2lhbENoYXJzXSBMaW1pdHMgdGhlIHRyYW5zZm9ybWF0aW9uIHRvXG4gICAgICogYWxwaGEtbnVtZXJpYyBjaGFyYWN0ZXJzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRyYW5zZm9ybUtleShrZXksIG5vU3BlY2lhbENoYXJzKSB7XG4gICAgICB2YXIgdmFsaWRLZXkgPSAnJztcbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgdmFyIGxLZXkgPSBrZXkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKGxLZXkgPT09ICcgJyB8fCBTUEFDRV9LRVkudGVzdChsS2V5KSkge1xuICAgICAgICAgIHZhbGlkS2V5ID0gJ3NwYWNlJztcbiAgICAgICAgfSBlbHNlIGlmIChFU0NfS0VZLnRlc3QobEtleSkpIHtcbiAgICAgICAgICB2YWxpZEtleSA9ICdlc2MnO1xuICAgICAgICB9IGVsc2UgaWYgKGxLZXkubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICBpZiAoIW5vU3BlY2lhbENoYXJzIHx8IEtFWV9DSEFSLnRlc3QobEtleSkpIHtcbiAgICAgICAgICAgIHZhbGlkS2V5ID0gbEtleTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoQVJST1dfS0VZLnRlc3QobEtleSkpIHtcbiAgICAgICAgICB2YWxpZEtleSA9IGxLZXkucmVwbGFjZSgnYXJyb3cnLCAnJyk7XG4gICAgICAgIH0gZWxzZSBpZiAobEtleSA9PSAnbXVsdGlwbHknKSB7XG4gICAgICAgICAgLy8gbnVtcGFkICcqJyBjYW4gbWFwIHRvIE11bHRpcGx5IG9uIElFL1dpbmRvd3NcbiAgICAgICAgICB2YWxpZEtleSA9ICcqJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWxpZEtleSA9IGxLZXk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWxpZEtleTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0cmFuc2Zvcm1LZXlJZGVudGlmaWVyKGtleUlkZW50KSB7XG4gICAgICB2YXIgdmFsaWRLZXkgPSAnJztcbiAgICAgIGlmIChrZXlJZGVudCkge1xuICAgICAgICBpZiAoa2V5SWRlbnQgaW4gS0VZX0lERU5USUZJRVIpIHtcbiAgICAgICAgICB2YWxpZEtleSA9IEtFWV9JREVOVElGSUVSW2tleUlkZW50XTtcbiAgICAgICAgfSBlbHNlIGlmIChJREVOVF9DSEFSLnRlc3Qoa2V5SWRlbnQpKSB7XG4gICAgICAgICAga2V5SWRlbnQgPSBwYXJzZUludChrZXlJZGVudC5yZXBsYWNlKCdVKycsICcweCcpLCAxNik7XG4gICAgICAgICAgdmFsaWRLZXkgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGtleUlkZW50KS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbGlkS2V5ID0ga2V5SWRlbnQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbGlkS2V5O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRyYW5zZm9ybUtleUNvZGUoa2V5Q29kZSkge1xuICAgICAgdmFyIHZhbGlkS2V5ID0gJyc7XG4gICAgICBpZiAoTnVtYmVyKGtleUNvZGUpKSB7XG4gICAgICAgIGlmIChrZXlDb2RlID49IDY1ICYmIGtleUNvZGUgPD0gOTApIHtcbiAgICAgICAgICAvLyBhc2NpaSBhLXpcbiAgICAgICAgICAvLyBsb3dlcmNhc2UgaXMgMzIgb2Zmc2V0IGZyb20gdXBwZXJjYXNlXG4gICAgICAgICAgdmFsaWRLZXkgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDMyICsga2V5Q29kZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoa2V5Q29kZSA+PSAxMTIgJiYga2V5Q29kZSA8PSAxMjMpIHtcbiAgICAgICAgICAvLyBmdW5jdGlvbiBrZXlzIGYxLWYxMlxuICAgICAgICAgIHZhbGlkS2V5ID0gJ2YnICsgKGtleUNvZGUgLSAxMTIgKyAxKTtcbiAgICAgICAgfSBlbHNlIGlmIChrZXlDb2RlID49IDQ4ICYmIGtleUNvZGUgPD0gNTcpIHtcbiAgICAgICAgICAvLyB0b3AgMC05IGtleXNcbiAgICAgICAgICB2YWxpZEtleSA9IFN0cmluZyhrZXlDb2RlIC0gNDgpO1xuICAgICAgICB9IGVsc2UgaWYgKGtleUNvZGUgPj0gOTYgJiYga2V5Q29kZSA8PSAxMDUpIHtcbiAgICAgICAgICAvLyBudW0gcGFkIDAtOVxuICAgICAgICAgIHZhbGlkS2V5ID0gU3RyaW5nKGtleUNvZGUgLSA5Nik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsaWRLZXkgPSBLRVlfQ09ERVtrZXlDb2RlXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbGlkS2V5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAgKiBDYWxjdWxhdGVzIHRoZSBub3JtYWxpemVkIGtleSBmb3IgYSBLZXlib2FyZEV2ZW50LlxuICAgICAgKiBAcGFyYW0ge0tleWJvYXJkRXZlbnR9IGtleUV2ZW50XG4gICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW25vU3BlY2lhbENoYXJzXSBTZXQgdG8gdHJ1ZSB0byBsaW1pdCBrZXlFdmVudC5rZXlcbiAgICAgICogdHJhbnNmb3JtYXRpb24gdG8gYWxwaGEtbnVtZXJpYyBjaGFycy4gVGhpcyBpcyB1c2VmdWwgd2l0aCBrZXlcbiAgICAgICogY29tYmluYXRpb25zIGxpa2Ugc2hpZnQgKyAyLCB3aGljaCBvbiBGRiBmb3IgTWFjT1MgcHJvZHVjZXNcbiAgICAgICoga2V5RXZlbnQua2V5ID0gQFxuICAgICAgKiBUbyBnZXQgMiByZXR1cm5lZCwgc2V0IG5vU3BlY2lhbENoYXJzID0gdHJ1ZVxuICAgICAgKiBUbyBnZXQgQCByZXR1cm5lZCwgc2V0IG5vU3BlY2lhbENoYXJzID0gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBub3JtYWxpemVkS2V5Rm9yRXZlbnQoa2V5RXZlbnQsIG5vU3BlY2lhbENoYXJzKSB7XG4gICAgICAvLyBGYWxsIGJhY2sgZnJvbSAua2V5LCB0byAuZGV0YWlsLmtleSBmb3IgYXJ0aWZpY2FsIGtleWJvYXJkIGV2ZW50cyxcbiAgICAgIC8vIGFuZCB0aGVuIHRvIGRlcHJlY2F0ZWQgLmtleUlkZW50aWZpZXIgYW5kIC5rZXlDb2RlLlxuICAgICAgaWYgKGtleUV2ZW50LmtleSkge1xuICAgICAgICByZXR1cm4gdHJhbnNmb3JtS2V5KGtleUV2ZW50LmtleSwgbm9TcGVjaWFsQ2hhcnMpO1xuICAgICAgfVxuICAgICAgaWYgKGtleUV2ZW50LmRldGFpbCAmJiBrZXlFdmVudC5kZXRhaWwua2V5KSB7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1LZXkoa2V5RXZlbnQuZGV0YWlsLmtleSwgbm9TcGVjaWFsQ2hhcnMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRyYW5zZm9ybUtleUlkZW50aWZpZXIoa2V5RXZlbnQua2V5SWRlbnRpZmllcikgfHxcbiAgICAgICAgdHJhbnNmb3JtS2V5Q29kZShrZXlFdmVudC5rZXlDb2RlKSB8fCAnJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBrZXlDb21ib01hdGNoZXNFdmVudChrZXlDb21ibywgZXZlbnQpIHtcbiAgICAgIC8vIEZvciBjb21ib3Mgd2l0aCBtb2RpZmllcnMgd2Ugc3VwcG9ydCBvbmx5IGFscGhhLW51bWVyaWMga2V5c1xuICAgICAgdmFyIGtleUV2ZW50ID0gbm9ybWFsaXplZEtleUZvckV2ZW50KGV2ZW50LCBrZXlDb21iby5oYXNNb2RpZmllcnMpO1xuICAgICAgcmV0dXJuIGtleUV2ZW50ID09PSBrZXlDb21iby5rZXkgJiZcbiAgICAgICAgKCFrZXlDb21iby5oYXNNb2RpZmllcnMgfHwgKFxuICAgICAgICAgICEhZXZlbnQuc2hpZnRLZXkgPT09ICEha2V5Q29tYm8uc2hpZnRLZXkgJiZcbiAgICAgICAgICAhIWV2ZW50LmN0cmxLZXkgPT09ICEha2V5Q29tYm8uY3RybEtleSAmJlxuICAgICAgICAgICEhZXZlbnQuYWx0S2V5ID09PSAhIWtleUNvbWJvLmFsdEtleSAmJlxuICAgICAgICAgICEhZXZlbnQubWV0YUtleSA9PT0gISFrZXlDb21iby5tZXRhS2V5KVxuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlS2V5Q29tYm9TdHJpbmcoa2V5Q29tYm9TdHJpbmcpIHtcbiAgICAgIGlmIChrZXlDb21ib1N0cmluZy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBjb21ibzoga2V5Q29tYm9TdHJpbmcsXG4gICAgICAgICAga2V5OiBrZXlDb21ib1N0cmluZyxcbiAgICAgICAgICBldmVudDogJ2tleWRvd24nXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ga2V5Q29tYm9TdHJpbmcuc3BsaXQoJysnKS5yZWR1Y2UoZnVuY3Rpb24ocGFyc2VkS2V5Q29tYm8sIGtleUNvbWJvUGFydCkge1xuICAgICAgICB2YXIgZXZlbnRQYXJ0cyA9IGtleUNvbWJvUGFydC5zcGxpdCgnOicpO1xuICAgICAgICB2YXIga2V5TmFtZSA9IGV2ZW50UGFydHNbMF07XG4gICAgICAgIHZhciBldmVudCA9IGV2ZW50UGFydHNbMV07XG5cbiAgICAgICAgaWYgKGtleU5hbWUgaW4gTU9ESUZJRVJfS0VZUykge1xuICAgICAgICAgIHBhcnNlZEtleUNvbWJvW01PRElGSUVSX0tFWVNba2V5TmFtZV1dID0gdHJ1ZTtcbiAgICAgICAgICBwYXJzZWRLZXlDb21iby5oYXNNb2RpZmllcnMgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhcnNlZEtleUNvbWJvLmtleSA9IGtleU5hbWU7XG4gICAgICAgICAgcGFyc2VkS2V5Q29tYm8uZXZlbnQgPSBldmVudCB8fCAna2V5ZG93bic7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGFyc2VkS2V5Q29tYm87XG4gICAgICB9LCB7XG4gICAgICAgIGNvbWJvOiBrZXlDb21ib1N0cmluZy5zcGxpdCgnOicpLnNoaWZ0KClcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlRXZlbnRTdHJpbmcoZXZlbnRTdHJpbmcpIHtcbiAgICAgIHJldHVybiBldmVudFN0cmluZy50cmltKCkuc3BsaXQoJyAnKS5tYXAoZnVuY3Rpb24oa2V5Q29tYm9TdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlS2V5Q29tYm9TdHJpbmcoa2V5Q29tYm9TdHJpbmcpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogYFBvbHltZXIuSXJvbkExMXlLZXlzQmVoYXZpb3JgIHByb3ZpZGVzIGEgbm9ybWFsaXplZCBpbnRlcmZhY2UgZm9yIHByb2Nlc3NpbmdcbiAgICAgKiBrZXlib2FyZCBjb21tYW5kcyB0aGF0IHBlcnRhaW4gdG8gW1dBSS1BUklBIGJlc3QgcHJhY3RpY2VzXShodHRwOi8vd3d3LnczLm9yZy9UUi93YWktYXJpYS1wcmFjdGljZXMvI2tiZF9nZW5lcmFsX2JpbmRpbmcpLlxuICAgICAqIFRoZSBlbGVtZW50IHRha2VzIGNhcmUgb2YgYnJvd3NlciBkaWZmZXJlbmNlcyB3aXRoIHJlc3BlY3QgdG8gS2V5Ym9hcmQgZXZlbnRzXG4gICAgICogYW5kIHVzZXMgYW4gZXhwcmVzc2l2ZSBzeW50YXggdG8gZmlsdGVyIGtleSBwcmVzc2VzLlxuICAgICAqXG4gICAgICogVXNlIHRoZSBga2V5QmluZGluZ3NgIHByb3RvdHlwZSBwcm9wZXJ0eSB0byBleHByZXNzIHdoYXQgY29tYmluYXRpb24gb2Yga2V5c1xuICAgICAqIHdpbGwgdHJpZ2dlciB0aGUgY2FsbGJhY2suIEEga2V5IGJpbmRpbmcgaGFzIHRoZSBmb3JtYXRcbiAgICAgKiBgXCJLRVkrTU9ESUZJRVI6RVZFTlRcIjogXCJjYWxsYmFja1wiYCAoYFwiS0VZXCI6IFwiY2FsbGJhY2tcImAgb3JcbiAgICAgKiBgXCJLRVk6RVZFTlRcIjogXCJjYWxsYmFja1wiYCBhcmUgdmFsaWQgYXMgd2VsbCkuIFNvbWUgZXhhbXBsZXM6XG4gICAgICpcbiAgICAgKiAgICAgIGtleUJpbmRpbmdzOiB7XG4gICAgICogICAgICAgICdzcGFjZSc6ICdfb25LZXlkb3duJywgLy8gc2FtZSBhcyAnc3BhY2U6a2V5ZG93bidcbiAgICAgKiAgICAgICAgJ3NoaWZ0K3RhYic6ICdfb25LZXlkb3duJyxcbiAgICAgKiAgICAgICAgJ2VudGVyOmtleXByZXNzJzogJ19vbktleXByZXNzJyxcbiAgICAgKiAgICAgICAgJ2VzYzprZXl1cCc6ICdfb25LZXl1cCdcbiAgICAgKiAgICAgIH1cbiAgICAgKlxuICAgICAqIFRoZSBjYWxsYmFjayB3aWxsIHJlY2VpdmUgd2l0aCBhbiBldmVudCBjb250YWluaW5nIHRoZSBmb2xsb3dpbmcgaW5mb3JtYXRpb24gaW4gYGV2ZW50LmRldGFpbGA6XG4gICAgICpcbiAgICAgKiAgICAgIF9vbktleWRvd246IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICogICAgICAgIGNvbnNvbGUubG9nKGV2ZW50LmRldGFpbC5jb21ibyk7IC8vIEtFWStNT0RJRklFUiwgZS5nLiBcInNoaWZ0K3RhYlwiXG4gICAgICogICAgICAgIGNvbnNvbGUubG9nKGV2ZW50LmRldGFpbC5rZXkpOyAvLyBLRVkgb25seSwgZS5nLiBcInRhYlwiXG4gICAgICogICAgICAgIGNvbnNvbGUubG9nKGV2ZW50LmRldGFpbC5ldmVudCk7IC8vIEVWRU5ULCBlLmcuIFwia2V5ZG93blwiXG4gICAgICogICAgICAgIGNvbnNvbGUubG9nKGV2ZW50LmRldGFpbC5rZXlib2FyZEV2ZW50KTsgLy8gdGhlIG9yaWdpbmFsIEtleWJvYXJkRXZlbnRcbiAgICAgKiAgICAgIH1cbiAgICAgKlxuICAgICAqIFVzZSB0aGUgYGtleUV2ZW50VGFyZ2V0YCBhdHRyaWJ1dGUgdG8gc2V0IHVwIGV2ZW50IGhhbmRsZXJzIG9uIGEgc3BlY2lmaWNcbiAgICAgKiBub2RlLlxuICAgICAqXG4gICAgICogU2VlIHRoZSBbZGVtbyBzb3VyY2UgY29kZV0oaHR0cHM6Ly9naXRodWIuY29tL1BvbHltZXJFbGVtZW50cy9pcm9uLWExMXkta2V5cy1iZWhhdmlvci9ibG9iL21hc3Rlci9kZW1vL3gta2V5LWF3YXJlLmh0bWwpXG4gICAgICogZm9yIGFuIGV4YW1wbGUuXG4gICAgICpcbiAgICAgKiBAZGVtbyBkZW1vL2luZGV4Lmh0bWxcbiAgICAgKiBAcG9seW1lckJlaGF2aW9yXG4gICAgICovXG4gICAgUG9seW1lci5Jcm9uQTExeUtleXNCZWhhdmlvciA9IHtcbiAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBFdmVudFRhcmdldCB0aGF0IHdpbGwgYmUgZmlyaW5nIHJlbGV2YW50IEtleWJvYXJkRXZlbnRzLiBTZXQgaXQgdG9cbiAgICAgICAgICogYG51bGxgIHRvIGRpc2FibGUgdGhlIGxpc3RlbmVycy5cbiAgICAgICAgICogQHR5cGUgez9FdmVudFRhcmdldH1cbiAgICAgICAgICovXG4gICAgICAgIGtleUV2ZW50VGFyZ2V0OiB7XG4gICAgICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgdHJ1ZSwgdGhpcyBwcm9wZXJ0eSB3aWxsIGNhdXNlIHRoZSBpbXBsZW1lbnRpbmcgZWxlbWVudCB0b1xuICAgICAgICAgKiBhdXRvbWF0aWNhbGx5IHN0b3AgcHJvcGFnYXRpb24gb24gYW55IGhhbmRsZWQgS2V5Ym9hcmRFdmVudHMuXG4gICAgICAgICAqL1xuICAgICAgICBzdG9wS2V5Ym9hcmRFdmVudFByb3BhZ2F0aW9uOiB7XG4gICAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgfSxcblxuICAgICAgICBfYm91bmRLZXlIYW5kbGVyczoge1xuICAgICAgICAgIHR5cGU6IEFycmF5LFxuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gV2UgdXNlIHRoaXMgZHVlIHRvIGEgbGltaXRhdGlvbiBpbiBJRTEwIHdoZXJlIGluc3RhbmNlcyB3aWxsIGhhdmVcbiAgICAgICAgLy8gb3duIHByb3BlcnRpZXMgb2YgZXZlcnl0aGluZyBvbiB0aGUgXCJwcm90b3R5cGVcIi5cbiAgICAgICAgX2ltcGVyYXRpdmVLZXlCaW5kaW5nczoge1xuICAgICAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBvYnNlcnZlcnM6IFtcbiAgICAgICAgJ19yZXNldEtleUV2ZW50TGlzdGVuZXJzKGtleUV2ZW50VGFyZ2V0LCBfYm91bmRLZXlIYW5kbGVycyknXG4gICAgICBdLFxuXG5cbiAgICAgIC8qKlxuICAgICAgICogVG8gYmUgdXNlZCB0byBleHByZXNzIHdoYXQgY29tYmluYXRpb24gb2Yga2V5cyAgd2lsbCB0cmlnZ2VyIHRoZSByZWxhdGl2ZVxuICAgICAgICogY2FsbGJhY2suIGUuZy4gYGtleUJpbmRpbmdzOiB7ICdlc2MnOiAnX29uRXNjUHJlc3NlZCd9YFxuICAgICAgICogQHR5cGUgeyFPYmplY3R9XG4gICAgICAgKi9cbiAgICAgIGtleUJpbmRpbmdzOiB7fSxcblxuICAgICAgcmVnaXN0ZXJlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX3ByZXBLZXlCaW5kaW5ncygpO1xuICAgICAgfSxcblxuICAgICAgYXR0YWNoZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9saXN0ZW5LZXlFdmVudExpc3RlbmVycygpO1xuICAgICAgfSxcblxuICAgICAgZGV0YWNoZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl91bmxpc3RlbktleUV2ZW50TGlzdGVuZXJzKCk7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIENhbiBiZSB1c2VkIHRvIGltcGVyYXRpdmVseSBhZGQgYSBrZXkgYmluZGluZyB0byB0aGUgaW1wbGVtZW50aW5nXG4gICAgICAgKiBlbGVtZW50LiBUaGlzIGlzIHRoZSBpbXBlcmF0aXZlIGVxdWl2YWxlbnQgb2YgZGVjbGFyaW5nIGEga2V5YmluZGluZ1xuICAgICAgICogaW4gdGhlIGBrZXlCaW5kaW5nc2AgcHJvdG90eXBlIHByb3BlcnR5LlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFN0cmluZ1xuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGhhbmRsZXJOYW1lXG4gICAgICAgKi9cbiAgICAgIGFkZE93bktleUJpbmRpbmc6IGZ1bmN0aW9uKGV2ZW50U3RyaW5nLCBoYW5kbGVyTmFtZSkge1xuICAgICAgICB0aGlzLl9pbXBlcmF0aXZlS2V5QmluZGluZ3NbZXZlbnRTdHJpbmddID0gaGFuZGxlck5hbWU7XG4gICAgICAgIHRoaXMuX3ByZXBLZXlCaW5kaW5ncygpO1xuICAgICAgICB0aGlzLl9yZXNldEtleUV2ZW50TGlzdGVuZXJzKCk7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFdoZW4gY2FsbGVkLCB3aWxsIHJlbW92ZSBhbGwgaW1wZXJhdGl2ZWx5LWFkZGVkIGtleSBiaW5kaW5ncy5cbiAgICAgICAqL1xuICAgICAgcmVtb3ZlT3duS2V5QmluZGluZ3M6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9pbXBlcmF0aXZlS2V5QmluZGluZ3MgPSB7fTtcbiAgICAgICAgdGhpcy5fcHJlcEtleUJpbmRpbmdzKCk7XG4gICAgICAgIHRoaXMuX3Jlc2V0S2V5RXZlbnRMaXN0ZW5lcnMoKTtcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogUmV0dXJucyB0cnVlIGlmIGEga2V5Ym9hcmQgZXZlbnQgbWF0Y2hlcyBgZXZlbnRTdHJpbmdgLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7S2V5Ym9hcmRFdmVudH0gZXZlbnRcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFN0cmluZ1xuICAgICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgICAqL1xuICAgICAga2V5Ym9hcmRFdmVudE1hdGNoZXNLZXlzOiBmdW5jdGlvbihldmVudCwgZXZlbnRTdHJpbmcpIHtcbiAgICAgICAgdmFyIGtleUNvbWJvcyA9IHBhcnNlRXZlbnRTdHJpbmcoZXZlbnRTdHJpbmcpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleUNvbWJvcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGlmIChrZXlDb21ib01hdGNoZXNFdmVudChrZXlDb21ib3NbaV0sIGV2ZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0sXG5cbiAgICAgIF9jb2xsZWN0S2V5QmluZGluZ3M6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIga2V5QmluZGluZ3MgPSB0aGlzLmJlaGF2aW9ycy5tYXAoZnVuY3Rpb24oYmVoYXZpb3IpIHtcbiAgICAgICAgICByZXR1cm4gYmVoYXZpb3Iua2V5QmluZGluZ3M7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChrZXlCaW5kaW5ncy5pbmRleE9mKHRoaXMua2V5QmluZGluZ3MpID09PSAtMSkge1xuICAgICAgICAgIGtleUJpbmRpbmdzLnB1c2godGhpcy5rZXlCaW5kaW5ncyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ga2V5QmluZGluZ3M7XG4gICAgICB9LFxuXG4gICAgICBfcHJlcEtleUJpbmRpbmdzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fa2V5QmluZGluZ3MgPSB7fTtcblxuICAgICAgICB0aGlzLl9jb2xsZWN0S2V5QmluZGluZ3MoKS5mb3JFYWNoKGZ1bmN0aW9uKGtleUJpbmRpbmdzKSB7XG4gICAgICAgICAgZm9yICh2YXIgZXZlbnRTdHJpbmcgaW4ga2V5QmluZGluZ3MpIHtcbiAgICAgICAgICAgIHRoaXMuX2FkZEtleUJpbmRpbmcoZXZlbnRTdHJpbmcsIGtleUJpbmRpbmdzW2V2ZW50U3RyaW5nXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICBmb3IgKHZhciBldmVudFN0cmluZyBpbiB0aGlzLl9pbXBlcmF0aXZlS2V5QmluZGluZ3MpIHtcbiAgICAgICAgICB0aGlzLl9hZGRLZXlCaW5kaW5nKGV2ZW50U3RyaW5nLCB0aGlzLl9pbXBlcmF0aXZlS2V5QmluZGluZ3NbZXZlbnRTdHJpbmddKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEdpdmUgcHJlY2VkZW5jZSB0byBjb21ib3Mgd2l0aCBtb2RpZmllcnMgdG8gYmUgY2hlY2tlZCBmaXJzdC5cbiAgICAgICAgZm9yICh2YXIgZXZlbnROYW1lIGluIHRoaXMuX2tleUJpbmRpbmdzKSB7XG4gICAgICAgICAgdGhpcy5fa2V5QmluZGluZ3NbZXZlbnROYW1lXS5zb3J0KGZ1bmN0aW9uIChrYjEsIGtiMikge1xuICAgICAgICAgICAgdmFyIGIxID0ga2IxWzBdLmhhc01vZGlmaWVycztcbiAgICAgICAgICAgIHZhciBiMiA9IGtiMlswXS5oYXNNb2RpZmllcnM7XG4gICAgICAgICAgICByZXR1cm4gKGIxID09PSBiMikgPyAwIDogYjEgPyAtMSA6IDE7XG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgX2FkZEtleUJpbmRpbmc6IGZ1bmN0aW9uKGV2ZW50U3RyaW5nLCBoYW5kbGVyTmFtZSkge1xuICAgICAgICBwYXJzZUV2ZW50U3RyaW5nKGV2ZW50U3RyaW5nKS5mb3JFYWNoKGZ1bmN0aW9uKGtleUNvbWJvKSB7XG4gICAgICAgICAgdGhpcy5fa2V5QmluZGluZ3Nba2V5Q29tYm8uZXZlbnRdID1cbiAgICAgICAgICAgIHRoaXMuX2tleUJpbmRpbmdzW2tleUNvbWJvLmV2ZW50XSB8fCBbXTtcblxuICAgICAgICAgIHRoaXMuX2tleUJpbmRpbmdzW2tleUNvbWJvLmV2ZW50XS5wdXNoKFtcbiAgICAgICAgICAgIGtleUNvbWJvLFxuICAgICAgICAgICAgaGFuZGxlck5hbWVcbiAgICAgICAgICBdKTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICB9LFxuXG4gICAgICBfcmVzZXRLZXlFdmVudExpc3RlbmVyczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX3VubGlzdGVuS2V5RXZlbnRMaXN0ZW5lcnMoKTtcblxuICAgICAgICBpZiAodGhpcy5pc0F0dGFjaGVkKSB7XG4gICAgICAgICAgdGhpcy5fbGlzdGVuS2V5RXZlbnRMaXN0ZW5lcnMoKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgX2xpc3RlbktleUV2ZW50TGlzdGVuZXJzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmtleUV2ZW50VGFyZ2V0KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5rZXlzKHRoaXMuX2tleUJpbmRpbmdzKS5mb3JFYWNoKGZ1bmN0aW9uKGV2ZW50TmFtZSkge1xuICAgICAgICAgIHZhciBrZXlCaW5kaW5ncyA9IHRoaXMuX2tleUJpbmRpbmdzW2V2ZW50TmFtZV07XG4gICAgICAgICAgdmFyIGJvdW5kS2V5SGFuZGxlciA9IHRoaXMuX29uS2V5QmluZGluZ0V2ZW50LmJpbmQodGhpcywga2V5QmluZGluZ3MpO1xuXG4gICAgICAgICAgdGhpcy5fYm91bmRLZXlIYW5kbGVycy5wdXNoKFt0aGlzLmtleUV2ZW50VGFyZ2V0LCBldmVudE5hbWUsIGJvdW5kS2V5SGFuZGxlcl0pO1xuXG4gICAgICAgICAgdGhpcy5rZXlFdmVudFRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgYm91bmRLZXlIYW5kbGVyKTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICB9LFxuXG4gICAgICBfdW5saXN0ZW5LZXlFdmVudExpc3RlbmVyczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBrZXlIYW5kbGVyVHVwbGU7XG4gICAgICAgIHZhciBrZXlFdmVudFRhcmdldDtcbiAgICAgICAgdmFyIGV2ZW50TmFtZTtcbiAgICAgICAgdmFyIGJvdW5kS2V5SGFuZGxlcjtcblxuICAgICAgICB3aGlsZSAodGhpcy5fYm91bmRLZXlIYW5kbGVycy5sZW5ndGgpIHtcbiAgICAgICAgICAvLyBNeSBraW5nZG9tIGZvciBibG9jay1zY29wZSBiaW5kaW5nIGFuZCBkZXN0cnVjdHVyaW5nIGFzc2lnbm1lbnQuLlxuICAgICAgICAgIGtleUhhbmRsZXJUdXBsZSA9IHRoaXMuX2JvdW5kS2V5SGFuZGxlcnMucG9wKCk7XG4gICAgICAgICAga2V5RXZlbnRUYXJnZXQgPSBrZXlIYW5kbGVyVHVwbGVbMF07XG4gICAgICAgICAgZXZlbnROYW1lID0ga2V5SGFuZGxlclR1cGxlWzFdO1xuICAgICAgICAgIGJvdW5kS2V5SGFuZGxlciA9IGtleUhhbmRsZXJUdXBsZVsyXTtcblxuICAgICAgICAgIGtleUV2ZW50VGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBib3VuZEtleUhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBfb25LZXlCaW5kaW5nRXZlbnQ6IGZ1bmN0aW9uKGtleUJpbmRpbmdzLCBldmVudCkge1xuICAgICAgICBpZiAodGhpcy5zdG9wS2V5Ym9hcmRFdmVudFByb3BhZ2F0aW9uKSB7XG4gICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiBldmVudCBoYXMgYmVlbiBhbHJlYWR5IHByZXZlbnRlZCwgZG9uJ3QgZG8gYW55dGhpbmdcbiAgICAgICAgaWYgKGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleUJpbmRpbmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGtleUNvbWJvID0ga2V5QmluZGluZ3NbaV1bMF07XG4gICAgICAgICAgdmFyIGhhbmRsZXJOYW1lID0ga2V5QmluZGluZ3NbaV1bMV07XG4gICAgICAgICAgaWYgKGtleUNvbWJvTWF0Y2hlc0V2ZW50KGtleUNvbWJvLCBldmVudCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3RyaWdnZXJLZXlIYW5kbGVyKGtleUNvbWJvLCBoYW5kbGVyTmFtZSwgZXZlbnQpO1xuICAgICAgICAgICAgLy8gZXhpdCB0aGUgbG9vcCBpZiBldmVudERlZmF1bHQgd2FzIHByZXZlbnRlZFxuICAgICAgICAgICAgaWYgKGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgX3RyaWdnZXJLZXlIYW5kbGVyOiBmdW5jdGlvbihrZXlDb21ibywgaGFuZGxlck5hbWUsIGtleWJvYXJkRXZlbnQpIHtcbiAgICAgICAgdmFyIGRldGFpbCA9IE9iamVjdC5jcmVhdGUoa2V5Q29tYm8pO1xuICAgICAgICBkZXRhaWwua2V5Ym9hcmRFdmVudCA9IGtleWJvYXJkRXZlbnQ7XG4gICAgICAgIHZhciBldmVudCA9IG5ldyBDdXN0b21FdmVudChrZXlDb21iby5ldmVudCwge1xuICAgICAgICAgIGRldGFpbDogZGV0YWlsLFxuICAgICAgICAgIGNhbmNlbGFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXNbaGFuZGxlck5hbWVdLmNhbGwodGhpcywgZXZlbnQpO1xuICAgICAgICBpZiAoZXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICAgIGtleWJvYXJkRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH0pKCk7XG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvaXJvbi1hMTF5LWtleXMtYmVoYXZpb3IvaXJvbi1hMTF5LWtleXMtYmVoYXZpb3IuaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTUgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cblxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3BvbHltZXIvcG9seW1lci5odG1sXCI+XG5cbjxzY3JpcHQ+XG4gIC8qKlxuICAgKiBgSXJvblJlc2l6YWJsZUJlaGF2aW9yYCBpcyBhIGJlaGF2aW9yIHRoYXQgY2FuIGJlIHVzZWQgaW4gUG9seW1lciBlbGVtZW50cyB0b1xuICAgKiBjb29yZGluYXRlIHRoZSBmbG93IG9mIHJlc2l6ZSBldmVudHMgYmV0d2VlbiBcInJlc2l6ZXJzXCIgKGVsZW1lbnRzIHRoYXQgY29udHJvbCB0aGVcbiAgICogc2l6ZSBvciBoaWRkZW4gc3RhdGUgb2YgdGhlaXIgY2hpbGRyZW4pIGFuZCBcInJlc2l6YWJsZXNcIiAoZWxlbWVudHMgdGhhdCBuZWVkIHRvIGJlXG4gICAqIG5vdGlmaWVkIHdoZW4gdGhleSBhcmUgcmVzaXplZCBvciB1bi1oaWRkZW4gYnkgdGhlaXIgcGFyZW50cyBpbiBvcmRlciB0byB0YWtlXG4gICAqIGFjdGlvbiBvbiB0aGVpciBuZXcgbWVhc3VyZW1lbnRzKS5cbiAgICpcbiAgICogRWxlbWVudHMgdGhhdCBwZXJmb3JtIG1lYXN1cmVtZW50IHNob3VsZCBhZGQgdGhlIGBJcm9uUmVzaXphYmxlQmVoYXZpb3JgIGJlaGF2aW9yIHRvXG4gICAqIHRoZWlyIGVsZW1lbnQgZGVmaW5pdGlvbiBhbmQgbGlzdGVuIGZvciB0aGUgYGlyb24tcmVzaXplYCBldmVudCBvbiB0aGVtc2VsdmVzLlxuICAgKiBUaGlzIGV2ZW50IHdpbGwgYmUgZmlyZWQgd2hlbiB0aGV5IGJlY29tZSBzaG93aW5nIGFmdGVyIGhhdmluZyBiZWVuIGhpZGRlbixcbiAgICogd2hlbiB0aGV5IGFyZSByZXNpemVkIGV4cGxpY2l0bHkgYnkgYW5vdGhlciByZXNpemFibGUsIG9yIHdoZW4gdGhlIHdpbmRvdyBoYXMgYmVlblxuICAgKiByZXNpemVkLlxuICAgKlxuICAgKiBOb3RlLCB0aGUgYGlyb24tcmVzaXplYCBldmVudCBpcyBub24tYnViYmxpbmcuXG4gICAqXG4gICAqIEBwb2x5bWVyQmVoYXZpb3IgUG9seW1lci5Jcm9uUmVzaXphYmxlQmVoYXZpb3JcbiAgICogQGRlbW8gZGVtby9pbmRleC5odG1sXG4gICAqKi9cbiAgUG9seW1lci5Jcm9uUmVzaXphYmxlQmVoYXZpb3IgPSB7XG4gICAgcHJvcGVydGllczoge1xuICAgICAgLyoqXG4gICAgICAgKiBUaGUgY2xvc2VzdCBhbmNlc3RvciBlbGVtZW50IHRoYXQgaW1wbGVtZW50cyBgSXJvblJlc2l6YWJsZUJlaGF2aW9yYC5cbiAgICAgICAqL1xuICAgICAgX3BhcmVudFJlc2l6YWJsZToge1xuICAgICAgICB0eXBlOiBPYmplY3QsXG4gICAgICAgIG9ic2VydmVyOiAnX3BhcmVudFJlc2l6YWJsZUNoYW5nZWQnXG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFRydWUgaWYgdGhpcyBlbGVtZW50IGlzIGN1cnJlbnRseSBub3RpZnlpbmcgaXRzIGRlc2NlbmRhbnQgZWxlbWVudHMgb2ZcbiAgICAgICAqIHJlc2l6ZS5cbiAgICAgICAqL1xuICAgICAgX25vdGlmeWluZ0Rlc2NlbmRhbnQ6IHtcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICB9XG4gICAgfSxcblxuICAgIGxpc3RlbmVyczoge1xuICAgICAgJ2lyb24tcmVxdWVzdC1yZXNpemUtbm90aWZpY2F0aW9ucyc6ICdfb25Jcm9uUmVxdWVzdFJlc2l6ZU5vdGlmaWNhdGlvbnMnXG4gICAgfSxcblxuICAgIGNyZWF0ZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gV2UgZG9uJ3QgcmVhbGx5IG5lZWQgcHJvcGVydHkgZWZmZWN0cyBvbiB0aGVzZSwgYW5kIGFsc28gd2Ugd2FudCB0aGVtXG4gICAgICAvLyB0byBiZSBjcmVhdGVkIGJlZm9yZSB0aGUgYF9wYXJlbnRSZXNpemFibGVgIG9ic2VydmVyIGZpcmVzOlxuICAgICAgdGhpcy5faW50ZXJlc3RlZFJlc2l6YWJsZXMgPSBbXTtcbiAgICAgIHRoaXMuX2JvdW5kTm90aWZ5UmVzaXplID0gdGhpcy5ub3RpZnlSZXNpemUuYmluZCh0aGlzKTtcbiAgICB9LFxuXG4gICAgYXR0YWNoZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fcmVxdWVzdFJlc2l6ZU5vdGlmaWNhdGlvbnMoKTtcbiAgICB9LFxuXG4gICAgZGV0YWNoZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuX3BhcmVudFJlc2l6YWJsZSkge1xuICAgICAgICB0aGlzLl9wYXJlbnRSZXNpemFibGUuc3RvcFJlc2l6ZU5vdGlmaWNhdGlvbnNGb3IodGhpcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5fYm91bmROb3RpZnlSZXNpemUpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9wYXJlbnRSZXNpemFibGUgPSBudWxsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYW4gYmUgY2FsbGVkIHRvIG1hbnVhbGx5IG5vdGlmeSBhIHJlc2l6YWJsZSBhbmQgaXRzIGRlc2NlbmRhbnRcbiAgICAgKiByZXNpemFibGVzIG9mIGEgcmVzaXplIGNoYW5nZS5cbiAgICAgKi9cbiAgICBub3RpZnlSZXNpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLmlzQXR0YWNoZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9pbnRlcmVzdGVkUmVzaXphYmxlcy5mb3JFYWNoKGZ1bmN0aW9uKHJlc2l6YWJsZSkge1xuICAgICAgICBpZiAodGhpcy5yZXNpemVyU2hvdWxkTm90aWZ5KHJlc2l6YWJsZSkpIHtcbiAgICAgICAgICB0aGlzLl9ub3RpZnlEZXNjZW5kYW50KHJlc2l6YWJsZSk7XG4gICAgICAgIH1cbiAgICAgIH0sIHRoaXMpO1xuXG4gICAgICB0aGlzLl9maXJlUmVzaXplKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gYXNzaWduIHRoZSBjbG9zZXN0IHJlc2l6YWJsZSBhbmNlc3RvciB0byB0aGlzIHJlc2l6YWJsZVxuICAgICAqIGlmIHRoZSBhbmNlc3RvciBkZXRlY3RzIGEgcmVxdWVzdCBmb3Igbm90aWZpY2F0aW9ucy5cbiAgICAgKi9cbiAgICBhc3NpZ25QYXJlbnRSZXNpemFibGU6IGZ1bmN0aW9uKHBhcmVudFJlc2l6YWJsZSkge1xuICAgICAgdGhpcy5fcGFyZW50UmVzaXphYmxlID0gcGFyZW50UmVzaXphYmxlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIHJlbW92ZSBhIHJlc2l6YWJsZSBkZXNjZW5kYW50IGZyb20gdGhlIGxpc3Qgb2YgZGVzY2VuZGFudHNcbiAgICAgKiB0aGF0IHNob3VsZCBiZSBub3RpZmllZCBvZiBhIHJlc2l6ZSBjaGFuZ2UuXG4gICAgICovXG4gICAgc3RvcFJlc2l6ZU5vdGlmaWNhdGlvbnNGb3I6IGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgdmFyIGluZGV4ID0gdGhpcy5faW50ZXJlc3RlZFJlc2l6YWJsZXMuaW5kZXhPZih0YXJnZXQpO1xuXG4gICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICB0aGlzLl9pbnRlcmVzdGVkUmVzaXphYmxlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB0aGlzLnVubGlzdGVuKHRhcmdldCwgJ2lyb24tcmVzaXplJywgJ19vbkRlc2NlbmRhbnRJcm9uUmVzaXplJyk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGNhbiBiZSBvdmVycmlkZGVuIHRvIGZpbHRlciBuZXN0ZWQgZWxlbWVudHMgdGhhdCBzaG91bGQgb3JcbiAgICAgKiBzaG91bGQgbm90IGJlIG5vdGlmaWVkIGJ5IHRoZSBjdXJyZW50IGVsZW1lbnQuIFJldHVybiB0cnVlIGlmIGFuIGVsZW1lbnRcbiAgICAgKiBzaG91bGQgYmUgbm90aWZpZWQsIG9yIGZhbHNlIGlmIGl0IHNob3VsZCBub3QgYmUgbm90aWZpZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IEEgY2FuZGlkYXRlIGRlc2NlbmRhbnQgZWxlbWVudCB0aGF0XG4gICAgICogaW1wbGVtZW50cyBgSXJvblJlc2l6YWJsZUJlaGF2aW9yYC5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBgZWxlbWVudGAgc2hvdWxkIGJlIG5vdGlmaWVkIG9mIHJlc2l6ZS5cbiAgICAgKi9cbiAgICByZXNpemVyU2hvdWxkTm90aWZ5OiBmdW5jdGlvbihlbGVtZW50KSB7IHJldHVybiB0cnVlOyB9LFxuXG4gICAgX29uRGVzY2VuZGFudElyb25SZXNpemU6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICBpZiAodGhpcy5fbm90aWZ5aW5nRGVzY2VuZGFudCkge1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBOT1RFKGNkYXRhKTogSW4gU2hhZG93RE9NLCBldmVudCByZXRhcmdldGluZyBtYWtlcyBlY2hvaW5nIG9mIHRoZVxuICAgICAgLy8gb3RoZXJ3aXNlIG5vbi1idWJibGluZyBldmVudCBcImp1c3Qgd29yay5cIiBXZSBkbyBpdCBtYW51YWxseSBoZXJlIGZvclxuICAgICAgLy8gdGhlIGNhc2Ugd2hlcmUgUG9seW1lciBpcyBub3QgdXNpbmcgc2hhZG93IHJvb3RzIGZvciB3aGF0ZXZlciByZWFzb246XG4gICAgICBpZiAoIVBvbHltZXIuU2V0dGluZ3MudXNlU2hhZG93KSB7XG4gICAgICAgIHRoaXMuX2ZpcmVSZXNpemUoKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgX2ZpcmVSZXNpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5maXJlKCdpcm9uLXJlc2l6ZScsIG51bGwsIHtcbiAgICAgICAgbm9kZTogdGhpcyxcbiAgICAgICAgYnViYmxlczogZmFsc2VcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBfb25Jcm9uUmVxdWVzdFJlc2l6ZU5vdGlmaWNhdGlvbnM6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICB2YXIgdGFyZ2V0ID0gLyoqIEB0eXBlIHshRXZlbnRUYXJnZXR9ICovIChQb2x5bWVyLmRvbShldmVudCkucm9vdFRhcmdldCk7XG4gICAgICBpZiAodGFyZ2V0ID09PSB0aGlzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2ludGVyZXN0ZWRSZXNpemFibGVzLmluZGV4T2YodGFyZ2V0KSA9PT0gLTEpIHtcbiAgICAgICAgdGhpcy5faW50ZXJlc3RlZFJlc2l6YWJsZXMucHVzaCh0YXJnZXQpO1xuICAgICAgICB0aGlzLmxpc3Rlbih0YXJnZXQsICdpcm9uLXJlc2l6ZScsICdfb25EZXNjZW5kYW50SXJvblJlc2l6ZScpO1xuICAgICAgfVxuXG4gICAgICB0YXJnZXQuYXNzaWduUGFyZW50UmVzaXphYmxlKHRoaXMpO1xuICAgICAgdGhpcy5fbm90aWZ5RGVzY2VuZGFudCh0YXJnZXQpO1xuXG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9LFxuXG4gICAgX3BhcmVudFJlc2l6YWJsZUNoYW5nZWQ6IGZ1bmN0aW9uKHBhcmVudFJlc2l6YWJsZSkge1xuICAgICAgaWYgKHBhcmVudFJlc2l6YWJsZSkge1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5fYm91bmROb3RpZnlSZXNpemUpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBfbm90aWZ5RGVzY2VuZGFudDogZnVuY3Rpb24oZGVzY2VuZGFudCkge1xuICAgICAgLy8gTk9URShjZGF0YSk6IEluIElFMTAsIGF0dGFjaGVkIGlzIGZpcmVkIG9uIGNoaWxkcmVuIGZpcnN0LCBzbyBpdCdzXG4gICAgICAvLyBpbXBvcnRhbnQgbm90IHRvIG5vdGlmeSB0aGVtIGlmIHRoZSBwYXJlbnQgaXMgbm90IGF0dGFjaGVkIHlldCAob3JcbiAgICAgIC8vIGVsc2UgdGhleSB3aWxsIGdldCByZWR1bmRhbnRseSBub3RpZmllZCB3aGVuIHRoZSBwYXJlbnQgYXR0YWNoZXMpLlxuICAgICAgaWYgKCF0aGlzLmlzQXR0YWNoZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9ub3RpZnlpbmdEZXNjZW5kYW50ID0gdHJ1ZTtcbiAgICAgIGRlc2NlbmRhbnQubm90aWZ5UmVzaXplKCk7XG4gICAgICB0aGlzLl9ub3RpZnlpbmdEZXNjZW5kYW50ID0gZmFsc2U7XG4gICAgfSxcbiAgICBcbiAgICBfcmVxdWVzdFJlc2l6ZU5vdGlmaWNhdGlvbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLmlzQXR0YWNoZWQpXG4gICAgICAgIHJldHVybjtcbiAgICAgIFxuICAgICAgLy8gTk9URSh2YWxkcmluKSBJbiBDdXN0b21FbGVtZW50cyB2MSB3aXRoIG5hdGl2ZSBIVE1MSW1wb3J0cywgdGhlIG9yZGVyXG4gICAgICAvLyBvZiBpbXBvcnRzIGFmZmVjdHMgdGhlIG9yZGVyIG9mIGBhdHRhY2hlZGAgY2FsbGJhY2tzIChzZWUgd2ViY29tcG9uZW50cy9jdXN0b20tZWxlbWVudHMjMTUpLlxuICAgICAgLy8gVGhpcyBtaWdodCBjYXVzZSBhIGNoaWxkIHRvIG5vdGlmeSBwYXJlbnRzIHRvbyBlYXJseSAoYXMgdGhlIHBhcmVudFxuICAgICAgLy8gc3RpbGwgaGFzIHRvIGJlIHVwZ3JhZGVkKSwgcmVzdWx0aW5nIGluIGEgcGFyZW50IG5vdCBhYmxlIHRvIGtlZXAgdHJhY2tcbiAgICAgIC8vIG9mIHRoZSBgX2ludGVyZXN0ZWRSZXNpemFibGVzYC4gVG8gc29sdmUgdGhpcywgd2Ugd2FpdCBmb3IgdGhlIGRvY3VtZW50XG4gICAgICAvLyB0byBiZSBkb25lIGxvYWRpbmcgYmVmb3JlIGZpcmluZyB0aGUgZXZlbnQuXG4gICAgICBpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gJ2xvYWRpbmcnKSB7XG4gICAgICAgIHZhciBfcmVxdWVzdFJlc2l6ZU5vdGlmaWNhdGlvbnMgPSB0aGlzLl9yZXF1ZXN0UmVzaXplTm90aWZpY2F0aW9ucy5iaW5kKHRoaXMpO1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdyZWFkeXN0YXRlY2hhbmdlJywgZnVuY3Rpb24gcmVhZHlzdGF0ZWNoYW5nZWQoKSB7XG4gICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVhZHlzdGF0ZWNoYW5nZScsIHJlYWR5c3RhdGVjaGFuZ2VkKTtcbiAgICAgICAgICBfcmVxdWVzdFJlc2l6ZU5vdGlmaWNhdGlvbnMoKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmZpcmUoJ2lyb24tcmVxdWVzdC1yZXNpemUtbm90aWZpY2F0aW9ucycsIG51bGwsIHtcbiAgICAgICAgICBub2RlOiB0aGlzLFxuICAgICAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICAgICAgY2FuY2VsYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoIXRoaXMuX3BhcmVudFJlc2l6YWJsZSkge1xuICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLl9ib3VuZE5vdGlmeVJlc2l6ZSk7XG4gICAgICAgICAgdGhpcy5ub3RpZnlSZXNpemUoKTtcbiAgICAgICAgfSBcbiAgICAgIH1cbiAgICB9XG4gIH07XG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvaXJvbi1yZXNpemFibGUtYmVoYXZpb3IvaXJvbi1yZXNpemFibGUtYmVoYXZpb3IuaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTUgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cblxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3BvbHltZXIvcG9seW1lci5odG1sXCI+XG5cbjwhLS1cbmBpcm9uLW1ldGFgIGlzIGEgZ2VuZXJpYyBlbGVtZW50IHlvdSBjYW4gdXNlIGZvciBzaGFyaW5nIGluZm9ybWF0aW9uIGFjcm9zcyB0aGUgRE9NIHRyZWUuXG5JdCB1c2VzIFttb25vc3RhdGUgcGF0dGVybl0oaHR0cDovL2MyLmNvbS9jZ2kvd2lraT9Nb25vc3RhdGVQYXR0ZXJuKSBzdWNoIHRoYXQgYW55XG5pbnN0YW5jZSBvZiBpcm9uLW1ldGEgaGFzIGFjY2VzcyB0byB0aGUgc2hhcmVkXG5pbmZvcm1hdGlvbi4gWW91IGNhbiB1c2UgYGlyb24tbWV0YWAgdG8gc2hhcmUgd2hhdGV2ZXIgeW91IHdhbnQgKG9yIGNyZWF0ZSBhbiBleHRlbnNpb25cbltsaWtlIHgtbWV0YV0gZm9yIGVuaGFuY2VtZW50cykuXG5cblRoZSBgaXJvbi1tZXRhYCBpbnN0YW5jZXMgY29udGFpbmluZyB5b3VyIGFjdHVhbCBkYXRhIGNhbiBiZSBsb2FkZWQgaW4gYW4gaW1wb3J0LFxub3IgY29uc3RydWN0ZWQgaW4gYW55IHdheSB5b3Ugc2VlIGZpdC4gVGhlIG9ubHkgcmVxdWlyZW1lbnQgaXMgdGhhdCB5b3UgY3JlYXRlIHRoZW1cbmJlZm9yZSB5b3UgdHJ5IHRvIGFjY2VzcyB0aGVtLlxuXG5FeGFtcGxlczpcblxuSWYgSSBjcmVhdGUgYW4gaW5zdGFuY2UgbGlrZSB0aGlzOlxuXG4gICAgPGlyb24tbWV0YSBrZXk9XCJpbmZvXCIgdmFsdWU9XCJmb28vYmFyXCI+PC9pcm9uLW1ldGE+XG5cbk5vdGUgdGhhdCB2YWx1ZT1cImZvby9iYXJcIiBpcyB0aGUgbWV0YWRhdGEgSSd2ZSBkZWZpbmVkLiBJIGNvdWxkIGRlZmluZSBtb3JlXG5hdHRyaWJ1dGVzIG9yIHVzZSBjaGlsZCBub2RlcyB0byBkZWZpbmUgYWRkaXRpb25hbCBtZXRhZGF0YS5cblxuTm93IEkgY2FuIGFjY2VzcyB0aGF0IGVsZW1lbnQgKGFuZCBpdCdzIG1ldGFkYXRhKSBmcm9tIGFueSBpcm9uLW1ldGEgaW5zdGFuY2VcbnZpYSB0aGUgYnlLZXkgbWV0aG9kLCBlLmcuXG5cbiAgICBtZXRhLmJ5S2V5KCdpbmZvJyk7XG5cblB1cmUgaW1wZXJhdGl2ZSBmb3JtIHdvdWxkIGJlIGxpa2U6XG5cbiAgICBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpcm9uLW1ldGEnKS5ieUtleSgnaW5mbycpO1xuXG5PciwgaW4gYSBQb2x5bWVyIGVsZW1lbnQsIHlvdSBjYW4gaW5jbHVkZSBhIG1ldGEgaW4geW91ciB0ZW1wbGF0ZTpcblxuICAgIDxpcm9uLW1ldGEgaWQ9XCJtZXRhXCI+PC9pcm9uLW1ldGE+XG4gICAgLi4uXG4gICAgdGhpcy4kLm1ldGEuYnlLZXkoJ2luZm8nKTtcblxuQGdyb3VwIElyb24gRWxlbWVudHNcbkBkZW1vIGRlbW8vaW5kZXguaHRtbFxuQGhlcm8gaGVyby5zdmdcbkBlbGVtZW50IGlyb24tbWV0YVxuLS0+XG5cbjxzY3JpcHQ+XG5cbiAgKGZ1bmN0aW9uKCkge1xuXG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHt7dHlwZTogKHN0cmluZ3xudWxsKSwga2V5OiAoc3RyaW5nfG51bGwpLCB2YWx1ZTogKn19IG9wdGlvbnNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBJcm9uTWV0YShvcHRpb25zKSB7XG4gICAgICB0aGlzLnR5cGUgPSAob3B0aW9ucyAmJiBvcHRpb25zLnR5cGUpIHx8ICdkZWZhdWx0JztcbiAgICAgIHRoaXMua2V5ID0gb3B0aW9ucyAmJiBvcHRpb25zLmtleTtcbiAgICAgIGlmICgndmFsdWUnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IG9wdGlvbnMudmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgSXJvbk1ldGEudHlwZXMgPSB7fTtcblxuICAgIElyb25NZXRhLnByb3RvdHlwZSA9IHtcbiAgICAgIGdldCB2YWx1ZSgpIHtcbiAgICAgICAgdmFyIHR5cGUgPSB0aGlzLnR5cGU7XG4gICAgICAgIHZhciBrZXkgPSB0aGlzLmtleTtcblxuICAgICAgICBpZiAodHlwZSAmJiBrZXkpIHtcbiAgICAgICAgICByZXR1cm4gSXJvbk1ldGEudHlwZXNbdHlwZV0gJiYgSXJvbk1ldGEudHlwZXNbdHlwZV1ba2V5XTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgc2V0IHZhbHVlKHZhbHVlKSB7XG4gICAgICAgIHZhciB0eXBlID0gdGhpcy50eXBlO1xuICAgICAgICB2YXIga2V5ID0gdGhpcy5rZXk7XG5cbiAgICAgICAgaWYgKHR5cGUgJiYga2V5KSB7XG4gICAgICAgICAgdHlwZSA9IElyb25NZXRhLnR5cGVzW3R5cGVdID0gSXJvbk1ldGEudHlwZXNbdHlwZV0gfHwge307XG4gICAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0eXBlW2tleV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHR5cGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgZ2V0IGxpc3QoKSB7XG4gICAgICAgIHZhciB0eXBlID0gdGhpcy50eXBlO1xuXG4gICAgICAgIGlmICh0eXBlKSB7XG4gICAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKElyb25NZXRhLnR5cGVzW3RoaXMudHlwZV0pLm1hcChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBtZXRhRGF0YXNbdGhpcy50eXBlXVtrZXldO1xuICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBieUtleTogZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgUG9seW1lci5Jcm9uTWV0YSA9IElyb25NZXRhO1xuXG4gICAgdmFyIG1ldGFEYXRhcyA9IFBvbHltZXIuSXJvbk1ldGEudHlwZXM7XG5cbiAgICBQb2x5bWVyKHtcblxuICAgICAgaXM6ICdpcm9uLW1ldGEnLFxuXG4gICAgICBwcm9wZXJ0aWVzOiB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0eXBlIG9mIG1ldGEtZGF0YS4gIEFsbCBtZXRhLWRhdGEgb2YgdGhlIHNhbWUgdHlwZSBpcyBzdG9yZWRcbiAgICAgICAgICogdG9nZXRoZXIuXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0eXBlOiB7XG4gICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgIHZhbHVlOiAnZGVmYXVsdCcsXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBrZXkgdXNlZCB0byBzdG9yZSBgdmFsdWVgIHVuZGVyIHRoZSBgdHlwZWAgbmFtZXNwYWNlLlxuICAgICAgICAgKiBAdHlwZSB7P3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIGtleToge1xuICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG1ldGEtZGF0YSB0byBzdG9yZSBvciByZXRyaWV2ZS5cbiAgICAgICAgICogQHR5cGUgeyp9XG4gICAgICAgICAqL1xuICAgICAgICB2YWx1ZToge1xuICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICBub3RpZnk6IHRydWUsXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHRydWUsIGB2YWx1ZWAgaXMgc2V0IHRvIHRoZSBpcm9uLW1ldGEgaW5zdGFuY2UgaXRzZWxmLlxuICAgICAgICAgKi9cbiAgICAgICAgIHNlbGY6IHtcbiAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgIG9ic2VydmVyOiAnX3NlbGZDaGFuZ2VkJ1xuICAgICAgICB9LFxuXG4gICAgICAgIF9fbWV0YToge1xuICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgICAgY29tcHV0ZWQ6ICdfX2NvbXB1dGVNZXRhKHR5cGUsIGtleSwgdmFsdWUpJ1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBob3N0QXR0cmlidXRlczoge1xuICAgICAgICBoaWRkZW46IHRydWVcbiAgICAgIH0sXG5cbiAgICAgIF9fY29tcHV0ZU1ldGE6IGZ1bmN0aW9uKHR5cGUsIGtleSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIG1ldGEgPSBuZXcgUG9seW1lci5Jcm9uTWV0YSh7XG4gICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICBrZXk6IGtleVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbWV0YS52YWx1ZSkge1xuICAgICAgICAgIG1ldGEudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnZhbHVlICE9PSBtZXRhLnZhbHVlKSB7XG4gICAgICAgICAgdGhpcy52YWx1ZSA9IG1ldGEudmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWV0YTtcbiAgICAgIH0sXG5cbiAgICAgIGdldCBsaXN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX21ldGEgJiYgdGhpcy5fX21ldGEubGlzdDtcbiAgICAgIH0sXG5cbiAgICAgIF9zZWxmQ2hhbmdlZDogZnVuY3Rpb24oc2VsZikge1xuICAgICAgICBpZiAoc2VsZikge1xuICAgICAgICAgIHRoaXMudmFsdWUgPSB0aGlzO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFJldHJpZXZlcyBtZXRhIGRhdGEgdmFsdWUgYnkga2V5LlxuICAgICAgICpcbiAgICAgICAqIEBtZXRob2QgYnlLZXlcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgbWV0YS1kYXRhIHRvIGJlIHJldHVybmVkLlxuICAgICAgICogQHJldHVybiB7Kn1cbiAgICAgICAqL1xuICAgICAgYnlLZXk6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICByZXR1cm4gbmV3IFBvbHltZXIuSXJvbk1ldGEoe1xuICAgICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAgICBrZXk6IGtleVxuICAgICAgICB9KS52YWx1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSkoKTtcbjwvc2NyaXB0PlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9pcm9uLW1ldGEvaXJvbi1tZXRhLmh0bWwiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi91dGlscy9ib290Lmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi91dGlscy9zZXR0aW5ncy5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vdXRpbHMvbWl4aW4uaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3V0aWxzL2Nhc2UtbWFwLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi91dGlscy9zdHlsZS1nYXRoZXIuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3V0aWxzL3Jlc29sdmUtdXJsLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi9lbGVtZW50cy9kb20tbW9kdWxlLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCJwcm9wZXJ0eS1lZmZlY3RzLmh0bWxcIj5cblxuPHNjcmlwdD5cbihmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8qKlxuICAgKiBFbGVtZW50IGNsYXNzIG1peGluIHRoYXQgcHJvdmlkZXMgdGhlIGNvcmUgQVBJIGZvciBQb2x5bWVyJ3MgbWV0YS1wcm9ncmFtbWluZ1xuICAgKiBmZWF0dXJlcyBpbmNsdWRpbmcgdGVtcGxhdGUgc3RhbXBpbmcsIGRhdGEtYmluZGluZywgYXR0cmlidXRlIGRlc2VyaWFsaXphdGlvbixcbiAgICogYW5kIHByb3BlcnR5IGNoYW5nZSBvYnNlcnZhdGlvbi5cbiAgICpcbiAgICogU3ViY2xhc3NlcnMgbWF5IHByb3ZpZGUgdGhlIGZvbGxvd2luZyBzdGF0aWMgZ2V0dGVycyB0byByZXR1cm4gbWV0YWRhdGFcbiAgICogdXNlZCB0byBjb25maWd1cmUgUG9seW1lcidzIGZlYXR1cmVzIGZvciB0aGUgY2xhc3M6XG4gICAqXG4gICAqIC0gYHN0YXRpYyBnZXQgaXMoKWA6IFdoZW4gdGhlIHRlbXBsYXRlIGlzIHByb3ZpZGVkIHZpYSBhIGBkb20tbW9kdWxlYCxcbiAgICogICB1c2VycyBzaG91bGQgcmV0dXJuIHRoZSBgZG9tLW1vZHVsZWAgaWQgZnJvbSBhIHN0YXRpYyBgaXNgIGdldHRlci4gIElmXG4gICAqICAgbm8gdGVtcGxhdGUgaXMgbmVlZGVkIG9yIHRoZSB0ZW1wbGF0ZSBpcyBwcm92aWRlZCBkaXJlY3RseSB2aWEgdGhlXG4gICAqICAgYHRlbXBsYXRlYCBnZXR0ZXIsIHRoZXJlIGlzIG5vIG5lZWQgdG8gZGVmaW5lIGBpc2AgZm9yIHRoZSBlbGVtZW50LlxuICAgKlxuICAgKiAtIGBzdGF0aWMgZ2V0IHRlbXBsYXRlKClgOiBVc2VycyBtYXkgcHJvdmlkZSB0aGUgdGVtcGxhdGUgZGlyZWN0bHkgKGFzXG4gICAqICAgb3Bwb3NlZCB0byB2aWEgYGRvbS1tb2R1bGVgKSBieSBpbXBsZW1lbnRpbmcgYSBzdGF0aWMgYHRlbXBsYXRlYCBnZXR0ZXIuXG4gICAqICAgVGhlIGdldHRlciBtYXkgcmV0dXJuIGFuIGBIVE1MVGVtcGxhdGVFbGVtZW50YCBvciBhIHN0cmluZywgd2hpY2ggd2lsbFxuICAgKiAgIGF1dG9tYXRpY2FsbHkgYmUgcGFyc2VkIGludG8gYSB0ZW1wbGF0ZS5cbiAgICpcbiAgICogLSBgc3RhdGljIGdldCBwcm9wZXJ0aWVzKClgOiBTaG91bGQgcmV0dXJuIGFuIG9iamVjdCBkZXNjcmliaW5nXG4gICAqICAgcHJvcGVydHktcmVsYXRlZCBtZXRhZGF0YSB1c2VkIGJ5IFBvbHltZXIgZmVhdHVyZXMgKGtleTogcHJvcGVydHkgbmFtZVxuICAgKiAgIHZhbHVlOiBvYmplY3QgY29udGFpbmluZyBwcm9wZXJ0eSBtZXRhZGF0YSkuIFZhbGlkIGtleXMgaW4gcGVyLXByb3BlcnR5XG4gICAqICAgbWV0YWRhdGEgaW5jbHVkZTpcbiAgICogICAtIGB0eXBlYCAoU3RyaW5nfE51bWJlcnxPYmplY3R8QXJyYXl8Li4uKTogVXNlZCBieVxuICAgKiAgICAgYGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFja2AgdG8gZGV0ZXJtaW5lIGhvdyBzdHJpbmctYmFzZWQgYXR0cmlidXRlc1xuICAgKiAgICAgYXJlIGRlc2VyaWFsaXplZCB0byBKYXZhU2NyaXB0IHByb3BlcnR5IHZhbHVlcy5cbiAgICogICAtIGBub3RpZnlgIChib29sZWFuKTogQ2F1c2VzIGEgY2hhbmdlIGluIHRoZSBwcm9wZXJ0eSB0byBmaXJlIGFcbiAgICogICAgIG5vbi1idWJibGluZyBldmVudCBjYWxsZWQgYDxwcm9wZXJ0eT4tY2hhbmdlZGAuIEVsZW1lbnRzIHRoYXQgaGF2ZVxuICAgKiAgICAgZW5hYmxlZCB0d28td2F5IGJpbmRpbmcgdG8gdGhlIHByb3BlcnR5IHVzZSB0aGlzIGV2ZW50IHRvIG9ic2VydmUgY2hhbmdlcy5cbiAgICogICAtIGByZWFkT25seWAgKGJvb2xlYW4pOiBDcmVhdGVzIGEgZ2V0dGVyIGZvciB0aGUgcHJvcGVydHksIGJ1dCBubyBzZXR0ZXIuXG4gICAqICAgICBUbyBzZXQgYSByZWFkLW9ubHkgcHJvcGVydHksIHVzZSB0aGUgcHJpdmF0ZSBzZXR0ZXIgbWV0aG9kXG4gICAqICAgICBgX3NldFByb3BlcnR5KHByb3BlcnR5LCB2YWx1ZSlgLlxuICAgKiAgIC0gYG9ic2VydmVyYCAoc3RyaW5nKTogT2JzZXJ2ZXIgbWV0aG9kIG5hbWUgdGhhdCB3aWxsIGJlIGNhbGxlZCB3aGVuXG4gICAqICAgICB0aGUgcHJvcGVydHkgY2hhbmdlcy4gVGhlIGFyZ3VtZW50cyBvZiB0aGUgbWV0aG9kIGFyZVxuICAgKiAgICAgYCh2YWx1ZSwgcHJldmlvdXNWYWx1ZSlgLlxuICAgKiAgIC0gYGNvbXB1dGVkYCAoc3RyaW5nKTogU3RyaW5nIGRlc2NyaWJpbmcgbWV0aG9kIGFuZCBkZXBlbmRlbnQgcHJvcGVydGllc1xuICAgKiAgICAgZm9yIGNvbXB1dGluZyB0aGUgdmFsdWUgb2YgdGhpcyBwcm9wZXJ0eSAoZS5nLiBgJ2NvbXB1dGVGb28oYmFyLCB6b3QpJ2ApLlxuICAgKiAgICAgQ29tcHV0ZWQgcHJvcGVydGllcyBhcmUgcmVhZC1vbmx5IGJ5IGRlZmF1bHQgYW5kIGNhbiBvbmx5IGJlIGNoYW5nZWRcbiAgICogICAgIHZpYSB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBjb21wdXRpbmcgbWV0aG9kLlxuICAgKlxuICAgKiAtIGBzdGF0aWMgZ2V0IG9ic2VydmVycygpYDogQXJyYXkgb2Ygc3RyaW5ncyBkZXNjcmliaW5nIG11bHRpLXByb3BlcnR5XG4gICAqICAgb2JzZXJ2ZXIgbWV0aG9kcyBhbmQgdGhlaXIgZGVwZW5kZW50IHByb3BlcnRpZXMgKGUuZy5cbiAgICogICBgJ29ic2VydmVBQkMoYSwgYiwgYyknYCkuXG4gICAqXG4gICAqIFRoZSBiYXNlIGNsYXNzIHByb3ZpZGVzIGRlZmF1bHQgaW1wbGVtZW50YXRpb25zIGZvciB0aGUgZm9sbG93aW5nIHN0YW5kYXJkXG4gICAqIGN1c3RvbSBlbGVtZW50IGxpZmVjeWNsZSBjYWxsYmFja3M7IHVzZXJzIG1heSBvdmVycmlkZSB0aGVzZSwgYnV0IHNob3VsZFxuICAgKiBjYWxsIHRoZSBzdXBlciBtZXRob2QgdG8gZW5zdXJlXG4gICAqIC0gYGNvbnN0cnVjdG9yYDogUnVuIHdoZW4gdGhlIGVsZW1lbnQgaXMgY3JlYXRlZCBvciB1cGdyYWRlZFxuICAgKiAtIGBjb25uZWN0ZWRDYWxsYmFja2A6IFJ1biBlYWNoIHRpbWUgdGhlIGVsZW1lbnQgaXMgY29ubmVjdGVkIHRvIHRoZVxuICAgKiAgIGRvY3VtZW50XG4gICAqIC0gYGRpc2Nvbm5lY3RlZENhbGxiYWNrYDogUnVuIGVhY2ggdGltZSB0aGUgZWxlbWVudCBpcyBkaXNjb25uZWN0ZWQgZnJvbVxuICAgKiAgIHRoZSBkb2N1bWVudFxuICAgKiAtIGBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2tgOiBSdW4gZWFjaCB0aW1lIGFuIGF0dHJpYnV0ZSBpblxuICAgKiAgIGBvYnNlcnZlZEF0dHJpYnV0ZXNgIGlzIHNldCBvciByZW1vdmVkIChub3RlOiB0aGlzIGVsZW1lbnQncyBkZWZhdWx0XG4gICAqICAgYG9ic2VydmVkQXR0cmlidXRlc2AgaW1wbGVtZW50YXRpb24gd2lsbCBhdXRvbWF0aWNhbGx5IHJldHVybiBhbiBhcnJheVxuICAgKiAgIG9mIGRhc2gtY2FzZWQgYXR0cmlidXRlcyBiYXNlZCBvbiBgcHJvcGVydGllc2ApXG4gICAqXG4gICAqIEBtaXhpbkZ1bmN0aW9uXG4gICAqIEBwb2x5bWVyXG4gICAqIEBhcHBsaWVzTWl4aW4gUG9seW1lci5Qcm9wZXJ0eUVmZmVjdHNcbiAgICogQG1lbWJlcm9mIFBvbHltZXJcbiAgICogQHByb3BlcnR5IHJvb3RQYXRoIHtzdHJpbmd9IFNldCB0byB0aGUgdmFsdWUgb2YgYFBvbHltZXIucm9vdFBhdGhgLFxuICAgKiAgIHdoaWNoIGRlZmF1bHRzIHRvIHRoZSBtYWluIGRvY3VtZW50IHBhdGhcbiAgICogQHByb3BlcnR5IGltcG9ydFBhdGgge3N0cmluZ30gU2V0IHRvIHRoZSB2YWx1ZSBvZiB0aGUgY2xhc3MncyBzdGF0aWNcbiAgICogICBgaW1wb3J0UGF0aGAgcHJvcGVydHksIHdoaWNoIGRlZmF1bHRzIHRvIHRoZSBwYXRoIG9mIHRoaXMgZWxlbWVudCdzXG4gICAqICAgYGRvbS1tb2R1bGVgICh3aGVuIGBpc2AgaXMgdXNlZCksIGJ1dCBjYW4gYmUgb3ZlcnJpZGRlbiBmb3Igb3RoZXJcbiAgICogICBpbXBvcnQgc3RyYXRlZ2llcy5cbiAgICogQHN1bW1hcnkgRWxlbWVudCBjbGFzcyBtaXhpbiB0aGF0IHByb3ZpZGVzIHRoZSBjb3JlIEFQSSBmb3IgUG9seW1lcidzXG4gICAqIG1ldGEtcHJvZ3JhbW1pbmcgZmVhdHVyZXMuXG4gICAqL1xuICBQb2x5bWVyLkVsZW1lbnRNaXhpbiA9IFBvbHltZXIuZGVkdXBpbmdNaXhpbihiYXNlID0+IHtcblxuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBleHRlbmRzIHtiYXNlfVxuICAgICAqIEBpbXBsZW1lbnRzIHtQb2x5bWVyX1Byb3BlcnR5RWZmZWN0c31cbiAgICAgKi9cbiAgICBjb25zdCBwb2x5bWVyRWxlbWVudEJhc2UgPSBQb2x5bWVyLlByb3BlcnR5RWZmZWN0cyhiYXNlKTtcblxuICAgIGxldCBjYXNlTWFwID0gUG9seW1lci5DYXNlTWFwO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYHByb3BlcnRpZXNgIG9iamVjdCBzcGVjaWZpY2FsbHkgb24gYGtsYXNzYC4gVXNlIGZvcjpcbiAgICAgKiAoMSkgc3VwZXIgY2hhaW4gbWl4ZXMgdG9ndGhlciB0byBtYWtlIGBwcm9wZXJ0aWVzRm9yQ2xhc3NgIHdoaWNoIGlzXG4gICAgICogdGhlbiB1c2VkIHRvIG1ha2UgYG9ic2VydmVkQXR0cmlidXRlc2AuXG4gICAgICogKDIpIHByb3BlcnRpZXMgZWZmZWN0cyBhbmQgb2JzZXJ2ZXJzIGFyZSBjcmVhdGVkIGZyb20gaXQgYXQgYGZpbmFsaXplYCB0aW1lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0ga2xhc3MgRWxlbWVudCBjbGFzc1xuICAgICAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0IGNvbnRhaW5pbmcgb3duIHByb3BlcnRpZXMgZm9yIHRoaXMgY2xhc3NcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG93blByb3BlcnRpZXNGb3JDbGFzcyhrbGFzcykge1xuICAgICAgaWYgKCFrbGFzcy5oYXNPd25Qcm9wZXJ0eShcbiAgICAgICAgSlNDb21waWxlcl9yZW5hbWVQcm9wZXJ0eSgnX19vd25Qcm9wZXJ0aWVzJywga2xhc3MpKSkge1xuICAgICAgICBrbGFzcy5fX293blByb3BlcnRpZXMgPVxuICAgICAgICAgIGtsYXNzLmhhc093blByb3BlcnR5KEpTQ29tcGlsZXJfcmVuYW1lUHJvcGVydHkoJ3Byb3BlcnRpZXMnLCBrbGFzcykpID9cbiAgICAgICAgICAvKiogQHR5cGUgUG9seW1lckVsZW1lbnRDb25zdHJ1Y3RvciAqLyAoa2xhc3MpLnByb3BlcnRpZXMgOiB7fTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBrbGFzcy5fX293blByb3BlcnRpZXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYG9ic2VydmVyc2AgYXJyYXkgc3BlY2lmaWNhbGx5IG9uIGBrbGFzc2AuIFVzZSBmb3JcbiAgICAgKiBzZXR0aW5nIHVwIG9ic2VydmVycy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGtsYXNzIEVsZW1lbnQgY2xhc3NcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gQXJyYXkgY29udGFpbmluZyBvd24gb2JzZXJ2ZXJzIGZvciB0aGlzIGNsYXNzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvd25PYnNlcnZlcnNGb3JDbGFzcyhrbGFzcykge1xuICAgICAgaWYgKCFrbGFzcy5oYXNPd25Qcm9wZXJ0eShcbiAgICAgICAgSlNDb21waWxlcl9yZW5hbWVQcm9wZXJ0eSgnX19vd25PYnNlcnZlcnMnLCBrbGFzcykpKSB7XG4gICAgICAgIGtsYXNzLl9fb3duT2JzZXJ2ZXJzID1cbiAgICAgICAgICBrbGFzcy5oYXNPd25Qcm9wZXJ0eShKU0NvbXBpbGVyX3JlbmFtZVByb3BlcnR5KCdvYnNlcnZlcnMnLCBrbGFzcykpID9cbiAgICAgICAgICAvKiogQHR5cGUgUG9seW1lckVsZW1lbnRDb25zdHJ1Y3RvciAqLyAoa2xhc3MpLm9ic2VydmVycyA6IFtdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGtsYXNzLl9fb3duT2JzZXJ2ZXJzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1peGVzIGBwcm9wc2AgaW50byBgZmxhdHRlbmVkUHJvcHNgIGJ1dCB1cGdyYWRlcyBzaG9ydGhhbmQgdHlwZVxuICAgICAqIHN5bnRheCB0byB7IHR5cGU6IFR5cGV9LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGZsYXR0ZW5lZFByb3BzIEJhZyB0byBjb2xsZWN0IGZsYXR0ZW5lZCBwcm9wZXJ0aWVzIGludG9cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgQmFnIG9mIHByb3BlcnRpZXMgdG8gYWRkIHRvIGBmbGF0dGVuZWRQcm9wc2BcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBpbnB1dCBgZmxhdHRlbmVkUHJvcHNgIGJhZ1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmxhdHRlblByb3BlcnRpZXMoZmxhdHRlbmVkUHJvcHMsIHByb3BzKSB7XG4gICAgICBmb3IgKGxldCBwIGluIHByb3BzKSB7XG4gICAgICAgIGxldCBvID0gcHJvcHNbcF07XG4gICAgICAgIGlmICh0eXBlb2YgbyA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgbyA9IHsgdHlwZTogbyB9O1xuICAgICAgICB9XG4gICAgICAgIGZsYXR0ZW5lZFByb3BzW3BdID0gbztcbiAgICAgIH1cbiAgICAgIHJldHVybiBmbGF0dGVuZWRQcm9wcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgZmxhdHRlbmVkIGxpc3Qgb2YgcHJvcGVydGllcyBtaXhlZCB0b2dldGhlciBmcm9tIHRoZSBjaGFpbiBvZiBhbGxcbiAgICAgKiBjb25zdHJ1Y3RvcidzIGBjb25maWcucHJvcGVydGllc2AuIFRoaXMgbGlzdCBpcyB1c2VkIHRvIGNyZWF0ZVxuICAgICAqICgxKSBvYnNlcnZlZEF0dHJpYnV0ZXMsXG4gICAgICogKDIpIGNsYXNzIHByb3BlcnR5IGRlZmF1bHQgdmFsdWVzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BvbHltZXJFbGVtZW50Q29uc3RydWN0b3J9IGtsYXNzIEVsZW1lbnQgY2xhc3NcbiAgICAgKiBAcmV0dXJuIHtQb2x5bWVyRWxlbWVudFByb3BlcnRpZXN9IEZsYXR0ZW5lZCBwcm9wZXJ0aWVzIGZvciB0aGlzIGNsYXNzXG4gICAgICogQHN1cHByZXNzIHttaXNzaW5nUHJvcGVydGllc30gY2xhc3MucHJvdG90eXBlIGlzIG5vdCBhIHByb3BlcnR5IGZvciBzb21lIHJlYXNvbj9cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHByb3BlcnRpZXNGb3JDbGFzcyhrbGFzcykge1xuICAgICAgaWYgKCFrbGFzcy5oYXNPd25Qcm9wZXJ0eShcbiAgICAgICAgSlNDb21waWxlcl9yZW5hbWVQcm9wZXJ0eSgnX19jbGFzc1Byb3BlcnRpZXMnLCBrbGFzcykpKSB7XG4gICAgICAgIGtsYXNzLl9fY2xhc3NQcm9wZXJ0aWVzID1cbiAgICAgICAgZmxhdHRlblByb3BlcnRpZXMoe30sIG93blByb3BlcnRpZXNGb3JDbGFzcyhrbGFzcykpO1xuICAgICAgICBsZXQgc3VwZXJDdG9yID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGtsYXNzLnByb3RvdHlwZSkuY29uc3RydWN0b3I7XG4gICAgICAgIGlmIChzdXBlckN0b3IucHJvdG90eXBlIGluc3RhbmNlb2YgUG9seW1lckVsZW1lbnQpIHtcbiAgICAgICAgICBrbGFzcy5fX2NsYXNzUHJvcGVydGllcyA9IE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAgICBPYmplY3QuY3JlYXRlKHByb3BlcnRpZXNGb3JDbGFzcygvKiogQHR5cGUgUG9seW1lckVsZW1lbnRDb25zdHJ1Y3RvciAqLyhzdXBlckN0b3IpKSksXG4gICAgICAgICAgICBrbGFzcy5fX2NsYXNzUHJvcGVydGllcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBrbGFzcy5fX2NsYXNzUHJvcGVydGllcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBwcm9wZXJ0aWVzIHdpdGggZGVmYXVsdCB2YWx1ZXMuXG4gICAgICogVGhpcyBsaXN0IGlzIGNyZWF0ZWQgYXMgYW4gb3B0aW1pemF0aW9uIHNpbmNlIGl0IGlzIGEgc3Vic2V0IG9mXG4gICAgICogdGhlIGxpc3QgcmV0dXJuZWQgZnJvbSBgcHJvcGVydGllc0ZvckNsYXNzYC5cbiAgICAgKiBUaGlzIGxpc3QgaXMgdXNlZCBpbiBgX2luaXRpYWxpemVQcm9wZXJ0aWVzYCB0byBzZXQgcHJvcGVydHkgZGVmYXVsdHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BvbHltZXJFbGVtZW50Q29uc3RydWN0b3J9IGtsYXNzIEVsZW1lbnQgY2xhc3NcbiAgICAgKiBAcmV0dXJuIHtQb2x5bWVyRWxlbWVudFByb3BlcnRpZXN9IEZsYXR0ZW5lZCBwcm9wZXJ0aWVzIGZvciB0aGlzIGNsYXNzXG4gICAgICogICB0aGF0IGhhdmUgZGVmYXVsdCB2YWx1ZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHByb3BlcnR5RGVmYXVsdHNGb3JDbGFzcyhrbGFzcykge1xuICAgICAgaWYgKCFrbGFzcy5oYXNPd25Qcm9wZXJ0eShcbiAgICAgICAgSlNDb21waWxlcl9yZW5hbWVQcm9wZXJ0eSgnX19jbGFzc1Byb3BlcnR5RGVmYXVsdHMnLCBrbGFzcykpKSB7XG4gICAgICAgIGtsYXNzLl9fY2xhc3NQcm9wZXJ0eURlZmF1bHRzID0gbnVsbDtcbiAgICAgICAgbGV0IHByb3BzID0gcHJvcGVydGllc0ZvckNsYXNzKGtsYXNzKTtcbiAgICAgICAgZm9yIChsZXQgcCBpbiBwcm9wcykge1xuICAgICAgICAgIGxldCBpbmZvID0gcHJvcHNbcF07XG4gICAgICAgICAgaWYgKCd2YWx1ZScgaW4gaW5mbykge1xuICAgICAgICAgICAga2xhc3MuX19jbGFzc1Byb3BlcnR5RGVmYXVsdHMgPSBrbGFzcy5fX2NsYXNzUHJvcGVydHlEZWZhdWx0cyB8fCB7fTtcbiAgICAgICAgICAgIGtsYXNzLl9fY2xhc3NQcm9wZXJ0eURlZmF1bHRzW3BdID0gaW5mbztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBrbGFzcy5fX2NsYXNzUHJvcGVydHlEZWZhdWx0cztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgYSBga2xhc3NgIGhhcyBmaW5hbGl6ZWQuIENhbGxlZCBpbiBgRWxlbWVudENsYXNzLmZpbmFsaXplKClgXG4gICAgICogQHBhcmFtIHtQb2x5bWVyRWxlbWVudENvbnN0cnVjdG9yfSBrbGFzcyBFbGVtZW50IGNsYXNzXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBhbGwgbWV0YXByb2dyYW1taW5nIGZvciB0aGlzIGNsYXNzIGhhcyBiZWVuXG4gICAgICogICBjb21wbGV0ZWRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhhc0NsYXNzRmluYWxpemVkKGtsYXNzKSB7XG4gICAgICByZXR1cm4ga2xhc3MuaGFzT3duUHJvcGVydHkoSlNDb21waWxlcl9yZW5hbWVQcm9wZXJ0eSgnX19maW5hbGl6ZWQnLCBrbGFzcykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGxlZCBieSBgRWxlbWVudENsYXNzLmZpbmFsaXplKClgLiBFbnN1cmVzIHRoaXMgYGtsYXNzYCBhbmRcbiAgICAgKiAqYWxsIHN1cGVyY2xhc3NlcyogYXJlIGZpbmFsaXplZCBieSB0cmF2ZXJzaW5nIHRoZSBwcm90b3R5cGUgY2hhaW5cbiAgICAgKiBhbmQgY2FsbGluZyBga2xhc3MuZmluYWxpemUoKWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BvbHltZXJFbGVtZW50Q29uc3RydWN0b3J9IGtsYXNzIEVsZW1lbnQgY2xhc3NcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbmFsaXplQ2xhc3NBbmRTdXBlcihrbGFzcykge1xuICAgICAgbGV0IHByb3RvID0gLyoqIEB0eXBlIFBvbHltZXJFbGVtZW50Q29uc3RydWN0b3IgKi8gKGtsYXNzKS5wcm90b3R5cGU7XG4gICAgICBsZXQgc3VwZXJDdG9yID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvKS5jb25zdHJ1Y3RvcjtcbiAgICAgIGlmIChzdXBlckN0b3IucHJvdG90eXBlIGluc3RhbmNlb2YgUG9seW1lckVsZW1lbnQpIHtcbiAgICAgICAgc3VwZXJDdG9yLmZpbmFsaXplKCk7XG4gICAgICB9XG4gICAgICBmaW5hbGl6ZUNsYXNzKGtsYXNzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb25maWd1cmVzIGEgYGtsYXNzYCBiYXNlZCBvbiBhIHN0YWljIGBrbGFzcy5jb25maWdgIG9iamVjdCBhbmRcbiAgICAgKiBhIGB0ZW1wbGF0ZWAuIFRoaXMgaW5jbHVkZXMgY3JlYXRpbmcgYWNjZXNzb3JzIGFuZCBlZmZlY3RzXG4gICAgICogZm9yIHByb3BlcnRpZXMgaW4gYGNvbmZpZ2AgYW5kIHRoZSBgdGVtcGxhdGVgIGFzIHdlbGwgYXMgcHJlcGFyaW5nIHRoZVxuICAgICAqIGB0ZW1wbGF0ZWAgZm9yIHN0YW1waW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQb2x5bWVyRWxlbWVudENvbnN0cnVjdG9yfSBrbGFzcyBFbGVtZW50IGNsYXNzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5hbGl6ZUNsYXNzKGtsYXNzKSB7XG4gICAgICBrbGFzcy5fX2ZpbmFsaXplZCA9IHRydWU7XG4gICAgICBsZXQgcHJvdG8gPSAvKiogQHR5cGUgUG9seW1lckVsZW1lbnRDb25zdHJ1Y3RvciAqLyAoa2xhc3MpLnByb3RvdHlwZTtcbiAgICAgIGlmIChrbGFzcy5oYXNPd25Qcm9wZXJ0eShcbiAgICAgICAgSlNDb21waWxlcl9yZW5hbWVQcm9wZXJ0eSgnaXMnLCBrbGFzcykpICYmIGtsYXNzLmlzKSB7XG4gICAgICAgIFBvbHltZXIudGVsZW1ldHJ5LnJlZ2lzdGVyKHByb3RvKTtcbiAgICAgIH1cbiAgICAgIGxldCBwcm9wcyA9IG93blByb3BlcnRpZXNGb3JDbGFzcyhrbGFzcyk7XG4gICAgICBpZiAocHJvcHMpIHtcbiAgICAgICAgZmluYWxpemVQcm9wZXJ0aWVzKHByb3RvLCBwcm9wcyk7XG4gICAgICB9XG4gICAgICBsZXQgb2JzZXJ2ZXJzID0gb3duT2JzZXJ2ZXJzRm9yQ2xhc3Moa2xhc3MpO1xuICAgICAgaWYgKG9ic2VydmVycykge1xuICAgICAgICBmaW5hbGl6ZU9ic2VydmVycyhwcm90bywgb2JzZXJ2ZXJzLCBwcm9wcyk7XG4gICAgICB9XG4gICAgICAvLyBub3RlOiBjcmVhdGUgXCJ3b3JraW5nXCIgdGVtcGxhdGUgdGhhdCBpcyBmaW5hbGl6ZWQgYXQgaW5zdGFuY2UgdGltZVxuICAgICAgbGV0IHRlbXBsYXRlID0gLyoqIEB0eXBlIFBvbHltZXJFbGVtZW50Q29uc3RydWN0b3IgKi8gKGtsYXNzKS50ZW1wbGF0ZTtcbiAgICAgIGlmICh0ZW1wbGF0ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHRlbXBsYXRlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGxldCB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKTtcbiAgICAgICAgICB0LmlubmVySFRNTCA9IHRlbXBsYXRlO1xuICAgICAgICAgIHRlbXBsYXRlID0gdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ZW1wbGF0ZSA9IHRlbXBsYXRlLmNsb25lTm9kZSh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBwcm90by5fdGVtcGxhdGUgPSB0ZW1wbGF0ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb25maWd1cmVzIGEgYHByb3RvYCBiYXNlZCBvbiBhIGBwcm9wZXJ0aWVzYCBvYmplY3QuXG4gICAgICogTGV2ZXJhZ2VzIGBQcm9wZXJ0eUVmZmVjdHNgIHRvIGNyZWF0ZSBwcm9wZXJ0eSBhY2Nlc3NvcnMgYW5kIGVmZmVjdHNcbiAgICAgKiBzdXBwb3J0aW5nLCBvYnNlcnZlcnMsIHJlZmxlY3RpbmcgdG8gYXR0cmlidXRlcywgY2hhbmdlIG5vdGlmaWNhdGlvbixcbiAgICAgKiBjb21wdXRlZCBwcm9wZXJ0aWVzLCBhbmQgcmVhZCBvbmx5IHByb3BlcnRpZXMuXG4gICAgICogQHBhcmFtIHtQb2x5bWVyRWxlbWVudH0gcHJvdG8gRWxlbWVudCBjbGFzcyBwcm90b3R5cGUgdG8gYWRkIGFjY2Vzc29yc1xuICAgICAqICAgIGFuZCBlZmZlY3RzIHRvXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3BlcnRpZXMgRmxhdHRlbmVkIGJhZyBvZiBwcm9wZXJ0eSBkZXNjcmlwdG9ycyBmb3JcbiAgICAgKiAgICB0aGlzIGNsYXNzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5hbGl6ZVByb3BlcnRpZXMocHJvdG8sIHByb3BlcnRpZXMpIHtcbiAgICAgIGZvciAobGV0IHAgaW4gcHJvcGVydGllcykge1xuICAgICAgICBjcmVhdGVQcm9wZXJ0eUZyb21Db25maWcocHJvdG8sIHAsIHByb3BlcnRpZXNbcF0sIHByb3BlcnRpZXMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbmZpZ3VyZXMgYSBgcHJvdG9gIGJhc2VkIG9uIGEgYG9ic2VydmVyc2AgYXJyYXkuXG4gICAgICogTGV2ZXJhZ2VzIGBQcm9wZXJ0eUVmZmVjdHNgIHRvIGNyZWF0ZSBvYnNlcnZlcnMuXG4gICAgICogQHBhcmFtIHtQb2x5bWVyRWxlbWVudH0gcHJvdG8gRWxlbWVudCBjbGFzcyBwcm90b3R5cGUgdG8gYWRkIGFjY2Vzc29yc1xuICAgICAqICAgYW5kIGVmZmVjdHMgdG9cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JzZXJ2ZXJzIEZsYXR0ZW5lZCBhcnJheSBvZiBvYnNlcnZlciBkZXNjcmlwdG9ycyBmb3JcbiAgICAgKiAgIHRoaXMgY2xhc3NcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZHluYW1pY0ZucyBPYmplY3QgY29udGFpbmluZyBrZXlzIGZvciBhbnkgcHJvcGVydGllc1xuICAgICAqICAgdGhhdCBhcmUgZnVuY3Rpb25zIGFuZCBzaG91bGQgdHJpZ2dlciB0aGUgZWZmZWN0IHdoZW4gdGhlIGZ1bmN0aW9uXG4gICAgICogICByZWZlcmVuY2UgaXMgY2hhbmdlZFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmluYWxpemVPYnNlcnZlcnMocHJvdG8sIG9ic2VydmVycywgZHluYW1pY0Zucykge1xuICAgICAgZm9yIChsZXQgaT0wOyBpIDwgb2JzZXJ2ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHByb3RvLl9jcmVhdGVNZXRob2RPYnNlcnZlcihvYnNlcnZlcnNbaV0sIGR5bmFtaWNGbnMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgZWZmZWN0cyBmb3IgYSBwcm9wZXJ0eS5cbiAgICAgKlxuICAgICAqIE5vdGUsIG9uY2UgYSBwcm9wZXJ0eSBoYXMgYmVlbiBzZXQgdG9cbiAgICAgKiBgcmVhZE9ubHlgLCBgY29tcHV0ZWRgLCBgcmVmbGVjdFRvQXR0cmlidXRlYCwgb3IgYG5vdGlmeWBcbiAgICAgKiB0aGVzZSB2YWx1ZXMgbWF5IG5vdCBiZSBjaGFuZ2VkLiBGb3IgZXhhbXBsZSwgYSBzdWJjbGFzcyBjYW5ub3RcbiAgICAgKiBhbHRlciB0aGVzZSBzZXR0aW5ncy4gSG93ZXZlciwgYWRkaXRpb25hbCBgb2JzZXJ2ZXJzYCBtYXkgYmUgYWRkZWRcbiAgICAgKiBieSBzdWJjbGFzc2VzLlxuICAgICAqXG4gICAgICogVGhlIGluZm8gb2JqZWN0IHNob3VsZCBtYXkgY29udGFpbiBwcm9wZXJ0eSBtZXRhZGF0YSBhcyBmb2xsb3dzOlxuICAgICAqXG4gICAgICogKiBgdHlwZWA6IHtmdW5jdGlvbn0gdHlwZSB0byB3aGljaCBhbiBhdHRyaWJ1dGUgbWF0Y2hpbmcgdGhlIHByb3BlcnR5XG4gICAgICogaXMgZGVzZXJpYWxpemVkLiBOb3RlIHRoZSBwcm9wZXJ0eSBpcyBjYW1lbC1jYXNlZCBmcm9tIGEgZGFzaC1jYXNlZFxuICAgICAqIGF0dHJpYnV0ZS4gRm9yIGV4YW1wbGUsICdmb28tYmFyJyBhdHRyaWJ1dGUgaXMgZGVyc2lhbGl6ZWQgdG8gYVxuICAgICAqIHByb3BlcnR5IG5hbWVkICdmb29CYXInLlxuICAgICAqXG4gICAgICogKiBgcmVhZE9ubHlgOiB7Ym9vbGVhbn0gY3JlYXRlcyBhIHJlYWRPbmx5IHByb3BlcnR5IGFuZFxuICAgICAqIG1ha2VzIGEgcHJpdmF0ZSBzZXR0ZXIgZm9yIHRoZSBwcml2YXRlIG9mIHRoZSBmb3JtICdfc2V0Rm9vJyBmb3IgYVxuICAgICAqIHByb3BlcnR5ICdmb28nLFxuICAgICAqXG4gICAgICogKiBgY29tcHV0ZWRgOiB7c3RyaW5nfSBjcmVhdGVzIGEgY29tcHV0ZWQgcHJvcGVydHkuIEEgY29tcHV0ZWQgcHJvcGVydHlcbiAgICAgKiBhbHNvIGF1dG9tYXRpY2FsbHkgaXMgc2V0IHRvIGByZWFkT25seTogdHJ1ZWAuIFRoZSB2YWx1ZSBpcyBjYWxjdWxhdGVkXG4gICAgICogYnkgcnVubmluZyBhIG1ldGhvZCBhbmQgYXJndW1lbnRzIHBhcnNlZCBmcm9tIHRoZSBnaXZlbiBzdHJpbmcuIEZvclxuICAgICAqIGV4YW1wbGUgJ2NvbXB1dGUoZm9vKScgd2lsbCBjb21wdXRlIGEgZ2l2ZW4gcHJvcGVydHkgd2hlbiB0aGVcbiAgICAgKiAnZm9vJyBwcm9wZXJ0eSBjaGFuZ2VzIGJ5IGV4ZWN1dGluZyB0aGUgJ2NvbXB1dGUnIG1ldGhvZC4gVGhpcyBtZXRob2RcbiAgICAgKiBtdXN0IHJldHVybiB0aGUgY29tcHV0ZWQgdmFsdWUuXG4gICAgICpcbiAgICAgKiAqIGByZWZsZWN0VG9BdHRyaXV0ZWA6IHtib29sZWFufSBJZiB0cnVlLCB0aGUgcHJvcGVydHkgdmFsdWUgaXMgcmVmbGVjdGVkXG4gICAgICogdG8gYW4gYXR0cmlidXRlIG9mIHRoZSBzYW1lIG5hbWUuIE5vdGUsIHRoZSBhdHRyaWJ1dGUgaXMgZGFzaC1jYXNlZFxuICAgICAqIHNvIGEgcHJvcGVydHkgbmFtZWQgJ2Zvb0JhcicgaXMgcmVmbGVjdGVkIGFzICdmb28tYmFyJy5cbiAgICAgKlxuICAgICAqICogYG5vdGlmeWA6IHtib29sZWFufSBzZW5kcyBhIG5vbi1idWJibGluZyBub3RpZmljYXRpb24gZXZlbnQgd2hlblxuICAgICAqIHRoZSBwcm9wZXJ0eSBjaGFuZ2VzLiBGb3IgZXhhbXBsZSwgYSBwcm9wZXJ0eSBuYW1lZCAnZm9vJyBzZW5kcyBhblxuICAgICAqIGV2ZW50IG5hbWVkICdmb28tY2hhbmdlZCcgd2l0aCBgZXZlbnQuZGV0YWlsYCBzZXQgdG8gdGhlIHZhbHVlIG9mXG4gICAgICogdGhlIHByb3BlcnR5LlxuICAgICAqXG4gICAgICogKiBvYnNlcnZlcjoge3N0cmluZ30gbmFtZSBvZiBhIG1ldGhvZCB0aGF0IHJ1bnMgd2hlbiB0aGUgcHJvcGVydHlcbiAgICAgKiBjaGFuZ2VzLiBUaGUgYXJndW1lbnRzIG9mIHRoZSBtZXRob2QgYXJlICh2YWx1ZSwgcHJldmlvdXNWYWx1ZSkuXG4gICAgICpcbiAgICAgKiBOb3RlOiBVc2VycyBtYXkgd2FudCBjb250cm9sIG92ZXIgbW9kaWZ5aW5nIHByb3BlcnR5XG4gICAgICogZWZmZWN0cyB2aWEgc3ViY2xhc3NpbmcuIEZvciBleGFtcGxlLCBhIHVzZXIgbWlnaHQgd2FudCB0byBtYWtlIGFcbiAgICAgKiByZWZsZWN0VG9BdHRyaWJ1dGUgcHJvcGVydHkgbm90IGRvIHNvIGluIGEgc3ViY2xhc3MuIFdlJ3ZlIGNob3NlbiB0b1xuICAgICAqIGRpc2FibGUgdGhpcyBiZWNhdXNlIGl0IGxlYWRzIHRvIGFkZGl0aW9uYWwgY29tcGxpY2F0aW9uLlxuICAgICAqIEZvciBleGFtcGxlLCBhIHJlYWRPbmx5IGVmZmVjdCBnZW5lcmF0ZXMgYSBzcGVjaWFsIHNldHRlci4gSWYgYSBzdWJjbGFzc1xuICAgICAqIGRpc2FibGVzIHRoZSBlZmZlY3QsIHRoZSBzZXR0ZXIgd291bGQgZmFpbCB1bmV4cGVjdGVkbHkuXG4gICAgICogQmFzZWQgb24gZmVlZGJhY2ssIHdlIG1heSB3YW50IHRvIHRyeSB0byBtYWtlIGVmZmVjdHMgbW9yZSBtYWxsZWFibGVcbiAgICAgKiBhbmQvb3IgcHJvdmlkZSBhbiBhZHZhbmNlZCBhcGkgZm9yIG1hbmlwdWxhdGluZyB0aGVtLlxuICAgICAqIEFsc28gY29uc2lkZXIgYWRkaW5nIHdhcm5pbmdzIHdoZW4gYW4gZWZmZWN0IGNhbm5vdCBiZSBjaGFuZ2VkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQb2x5bWVyRWxlbWVudH0gcHJvdG8gRWxlbWVudCBjbGFzcyBwcm90b3R5cGUgdG8gYWRkIGFjY2Vzc29yc1xuICAgICAqICAgYW5kIGVmZmVjdHMgdG9cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBOYW1lIG9mIHRoZSBwcm9wZXJ0eS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5mbyBJbmZvIG9iamVjdCBmcm9tIHdoaWNoIHRvIGNyZWF0ZSBwcm9wZXJ0eSBlZmZlY3RzLlxuICAgICAqIFN1cHBvcnRlZCBrZXlzOlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhbGxQcm9wcyBGbGF0dGVuZWQgbWFwIG9mIGFsbCBwcm9wZXJ0aWVzIGRlZmluZWQgaW4gdGhpc1xuICAgICAqICAgZWxlbWVudCAoaW5jbHVkaW5nIGluaGVyaXRlZCBwcm9wZXJ0aWVzKVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlUHJvcGVydHlGcm9tQ29uZmlnKHByb3RvLCBuYW1lLCBpbmZvLCBhbGxQcm9wcykge1xuICAgICAgLy8gY29tcHV0ZWQgZm9yY2VzIHJlYWRPbmx5Li4uXG4gICAgICBpZiAoaW5mby5jb21wdXRlZCkge1xuICAgICAgICBpbmZvLnJlYWRPbmx5ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIC8vIE5vdGUsIHNpbmNlIGFsbCBjb21wdXRlZCBwcm9wZXJ0aWVzIGFyZSByZWFkT25seSwgdGhpcyBwcmV2ZW50c1xuICAgICAgLy8gYWRkaW5nIGFkZGl0aW9uYWwgY29tcHV0ZWQgcHJvcGVydHkgZWZmZWN0cyAod2hpY2ggbGVhZHMgdG8gYSBjb25mdXNpbmdcbiAgICAgIC8vIHNldHVwIHdoZXJlIG11bHRpcGxlIHRyaWdnZXJzIGZvciBzZXR0aW5nIGEgcHJvcGVydHkpXG4gICAgICAvLyBXaGlsZSB3ZSBkbyBoYXZlIGBoYXNDb21wdXRlZEVmZmVjdGAgdGhpcyBpcyBzZXQgb24gdGhlIHByb3BlcnR5J3NcbiAgICAgIC8vIGRlcGVuZGVuY2llcyByYXRoZXIgdGhhbiBpdHNlbGYuXG4gICAgICBpZiAoaW5mby5jb21wdXRlZCAgJiYgIXByb3RvLl9oYXNSZWFkT25seUVmZmVjdChuYW1lKSkge1xuICAgICAgICBwcm90by5fY3JlYXRlQ29tcHV0ZWRQcm9wZXJ0eShuYW1lLCBpbmZvLmNvbXB1dGVkLCBhbGxQcm9wcyk7XG4gICAgICB9XG4gICAgICBpZiAoaW5mby5yZWFkT25seSAmJiAhcHJvdG8uX2hhc1JlYWRPbmx5RWZmZWN0KG5hbWUpKSB7XG4gICAgICAgIHByb3RvLl9jcmVhdGVSZWFkT25seVByb3BlcnR5KG5hbWUsICFpbmZvLmNvbXB1dGVkKTtcbiAgICAgIH1cbiAgICAgIGlmIChpbmZvLnJlZmxlY3RUb0F0dHJpYnV0ZSAmJiAhcHJvdG8uX2hhc1JlZmxlY3RFZmZlY3QobmFtZSkpIHtcbiAgICAgICAgcHJvdG8uX2NyZWF0ZVJlZmxlY3RlZFByb3BlcnR5KG5hbWUpO1xuICAgICAgfVxuICAgICAgaWYgKGluZm8ubm90aWZ5ICYmICFwcm90by5faGFzTm90aWZ5RWZmZWN0KG5hbWUpKSB7XG4gICAgICAgIHByb3RvLl9jcmVhdGVOb3RpZnlpbmdQcm9wZXJ0eShuYW1lKTtcbiAgICAgIH1cbiAgICAgIC8vIGFsd2F5cyBhZGQgb2JzZXJ2ZXJcbiAgICAgIGlmIChpbmZvLm9ic2VydmVyKSB7XG4gICAgICAgIHByb3RvLl9jcmVhdGVQcm9wZXJ0eU9ic2VydmVyKG5hbWUsIGluZm8ub2JzZXJ2ZXIsIGFsbFByb3BzW2luZm8ub2JzZXJ2ZXJdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb25maWd1cmVzIGFuIGVsZW1lbnQgYHByb3RvYCB0byBmdW5jdGlvbiB3aXRoIGEgZ2l2ZW4gYHRlbXBsYXRlYC5cbiAgICAgKiBUaGUgZWxlbWVudCBuYW1lIGBpc2AgYW5kIGV4dGVuZHMgYGV4dGAgbXVzdCBiZSBzcGVjaWZpZWQgZm9yIFNoYWR5Q1NTXG4gICAgICogc3R5bGUgc2NvcGluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UG9seW1lckVsZW1lbnR9IHByb3RvIEVsZW1lbnQgY2xhc3MgcHJvdG90eXBlIHRvIGFkZCBhY2Nlc3NvcnNcbiAgICAgKiAgIGFuZCBlZmZlY3RzIHRvXG4gICAgICogQHBhcmFtIHshSFRNTFRlbXBsYXRlRWxlbWVudH0gdGVtcGxhdGUgVGVtcGxhdGUgdG8gcHJvY2VzcyBhbmQgYmluZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlVVJJIFVSTCBhZ2FpbnN0IHdoaWNoIHRvIHJlc29sdmUgdXJscyBpblxuICAgICAqICAgc3R5bGUgZWxlbWVudCBjc3NUZXh0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlzIFRhZyBuYW1lIChvciB0eXBlIGV4dGVuc2lvbiBuYW1lKSBmb3IgdGhpcyBlbGVtZW50XG4gICAgICogQHBhcmFtIHtzdHJpbmc9fSBleHQgRm9yIHR5cGUgZXh0ZW5zaW9ucywgdGhlIHRhZyBuYW1lIHRoYXQgd2FzIGV4dGVuZGVkXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5hbGl6ZVRlbXBsYXRlKHByb3RvLCB0ZW1wbGF0ZSwgYmFzZVVSSSwgaXMsIGV4dCkge1xuICAgICAgLy8gc3VwcG9ydCBgaW5jbHVkZT1cIm1vZHVsZS1uYW1lXCJgXG4gICAgICBsZXQgY3NzVGV4dCA9XG4gICAgICAgIFBvbHltZXIuU3R5bGVHYXRoZXIuY3NzRnJvbVRlbXBsYXRlKHRlbXBsYXRlLCBiYXNlVVJJKSArXG4gICAgICAgIFBvbHltZXIuU3R5bGVHYXRoZXIuY3NzRnJvbU1vZHVsZUltcG9ydHMoaXMpO1xuICAgICAgaWYgKGNzc1RleHQpIHtcbiAgICAgICAgbGV0IHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICAgICAgc3R5bGUudGV4dENvbnRlbnQgPSBjc3NUZXh0O1xuICAgICAgICB0ZW1wbGF0ZS5jb250ZW50Lmluc2VydEJlZm9yZShzdHlsZSwgdGVtcGxhdGUuY29udGVudC5maXJzdENoaWxkKTtcbiAgICAgIH1cbiAgICAgIGlmICh3aW5kb3cuU2hhZHlDU1MpIHtcbiAgICAgICAgd2luZG93LlNoYWR5Q1NTLnByZXBhcmVUZW1wbGF0ZSh0ZW1wbGF0ZSwgaXMsIGV4dCk7XG4gICAgICB9XG4gICAgICBwcm90by5fYmluZFRlbXBsYXRlKHRlbXBsYXRlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcG9seW1lclxuICAgICAqIEBtaXhpbkNsYXNzXG4gICAgICogQHVucmVzdHJpY3RlZFxuICAgICAqIEBpbXBsZW1lbnRzIHtQb2x5bWVyX0VsZW1lbnRNaXhpbn1cbiAgICAgKi9cbiAgICBjbGFzcyBQb2x5bWVyRWxlbWVudCBleHRlbmRzIHBvbHltZXJFbGVtZW50QmFzZSB7XG5cbiAgICAgIC8qKlxuICAgICAgICogU3RhbmRhcmQgQ3VzdG9tIEVsZW1lbnRzIFYxIEFQSS4gIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIHJldHVybnNcbiAgICAgICAqIGEgbGlzdCBvZiBkYXNoLWNhc2VkIGF0dHJpYnV0ZXMgYmFzZWQgb24gYSBmbGF0dGVuaW5nIG9mIGFsbCBwcm9wZXJ0aWVzXG4gICAgICAgKiBkZWNsYXJlZCBpbiBgc3RhdGljIGdldCBwcm9wZXJ0aWVzKClgIGZvciB0aGlzIGVsZW1lbnQgYW5kIGFueVxuICAgICAgICogc3VwZXJjbGFzc2VzLlxuICAgICAgICpcbiAgICAgICAqIEByZXR1cm4ge0FycmF5fSBPYnNlcnZlZCBhdHRyaWJ1dGUgbGlzdFxuICAgICAgICovXG4gICAgICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhc093blByb3BlcnR5KEpTQ29tcGlsZXJfcmVuYW1lUHJvcGVydHkoJ19fb2JzZXJ2ZWRBdHRyaWJ1dGVzJywgdGhpcykpKSB7XG4gICAgICAgICAgbGV0IGxpc3QgPSBbXTtcbiAgICAgICAgICBsZXQgcHJvcGVydGllcyA9IHByb3BlcnRpZXNGb3JDbGFzcyh0aGlzKTtcbiAgICAgICAgICBmb3IgKGxldCBwcm9wIGluIHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIGxpc3QucHVzaChQb2x5bWVyLkNhc2VNYXAuY2FtZWxUb0Rhc2hDYXNlKHByb3ApKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fX29ic2VydmVkQXR0cmlidXRlcyA9IGxpc3Q7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX19vYnNlcnZlZEF0dHJpYnV0ZXM7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ2FsbGVkIGF1dG9tYXRpY2FsbHkgd2hlbiB0aGUgZmlyc3QgZWxlbWVudCBpbnN0YW5jZSBpcyBjcmVhdGVkIHRvXG4gICAgICAgKiBlbnN1cmUgdGhhdCBjbGFzcyBmaW5hbGl6YXRpb24gd29yayBoYXMgYmVlbiBjb21wbGV0ZWQuXG4gICAgICAgKiBNYXkgYmUgY2FsbGVkIGJ5IHVzZXJzIHRvIGVhZ2VybHkgcGVyZm9ybSBjbGFzcyBmaW5hbGl6YXRpb24gd29ya1xuICAgICAgICogcHJpb3IgdG8gdGhlIGNyZWF0aW9uIG9mIHRoZSBmaXJzdCBlbGVtZW50IGluc3RhbmNlLlxuICAgICAgICpcbiAgICAgICAqIENsYXNzIGZpbmFsaXphdGlvbiB3b3JrIGdlbmVyYWxseSBpbmNsdWRlcyBtZXRhLXByb2dyYW1taW5nIHN1Y2ggYXNcbiAgICAgICAqIGNyZWF0aW5nIHByb3BlcnR5IGFjY2Vzc29ycyBhbmQgYW55IHByb3BlcnR5IGVmZmVjdCBtZXRhZGF0YSBuZWVkZWQgZm9yXG4gICAgICAgKiB0aGUgZmVhdHVyZXMgdXNlZC5cbiAgICAgICAqXG4gICAgICAgKiBAcHVibGljXG4gICAgICAgKi9cbiAgICAgIHN0YXRpYyBmaW5hbGl6ZSgpIHtcbiAgICAgICAgaWYgKCFoYXNDbGFzc0ZpbmFsaXplZCh0aGlzKSkge1xuICAgICAgICAgIGZpbmFsaXplQ2xhc3NBbmRTdXBlcih0aGlzKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJldHVybnMgdGhlIHRlbXBsYXRlIHRoYXQgd2lsbCBiZSBzdGFtcGVkIGludG8gdGhpcyBlbGVtZW50J3Mgc2hhZG93IHJvb3QuXG4gICAgICAgKlxuICAgICAgICogSWYgYSBgc3RhdGljIGdldCBpcygpYCBnZXR0ZXIgaXMgZGVmaW5lZCwgdGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb25cbiAgICAgICAqIHdpbGwgcmV0dXJuIHRoZSBmaXJzdCBgPHRlbXBsYXRlPmAgaW4gYSBgZG9tLW1vZHVsZWAgd2hvc2UgYGlkYFxuICAgICAgICogbWF0Y2hlcyB0aGlzIGVsZW1lbnQncyBgaXNgLlxuICAgICAgICpcbiAgICAgICAqIFVzZXJzIG1heSBvdmVycmlkZSB0aGlzIGdldHRlciB0byByZXR1cm4gYW4gYXJiaXRyYXJ5IHRlbXBsYXRlXG4gICAgICAgKiAoaW4gd2hpY2ggY2FzZSB0aGUgYGlzYCBnZXR0ZXIgaXMgdW5uZWNlc3NhcnkpLiBUaGUgdGVtcGxhdGUgcmV0dXJuZWRcbiAgICAgICAqIG1heSBiZSBlaXRoZXIgYW4gYEhUTUxUZW1wbGF0ZUVsZW1lbnRgIG9yIGEgc3RyaW5nIHRoYXQgd2lsbCBiZVxuICAgICAgICogYXV0b21hdGljYWxseSBwYXJzZWQgaW50byBhIHRlbXBsYXRlLlxuICAgICAgICpcbiAgICAgICAqIE5vdGUgdGhhdCB3aGVuIHN1YmNsYXNzaW5nLCBpZiB0aGUgc3VwZXIgY2xhc3Mgb3ZlcnJvZGUgdGhlIGRlZmF1bHRcbiAgICAgICAqIGltcGxlbWVudGF0aW9uIGFuZCB0aGUgc3ViY2xhc3Mgd291bGQgbGlrZSB0byBwcm92aWRlIGFuIGFsdGVybmF0ZVxuICAgICAgICogdGVtcGxhdGUgdmlhIGEgYGRvbS1tb2R1bGVgLCBpdCBzaG91bGQgb3ZlcnJpZGUgdGhpcyBnZXR0ZXIgYW5kXG4gICAgICAgKiByZXR1cm4gYFBvbHltZXIuRG9tTW9kdWxlLmltcG9ydCh0aGlzLmlzLCAndGVtcGxhdGUnKWAuXG4gICAgICAgKlxuICAgICAgICogSWYgYSBzdWJjbGFzcyB3b3VsZCBsaWtlIHRvIG1vZGlmeSB0aGUgc3VwZXIgY2xhc3MgdGVtcGxhdGUsIGl0IHNob3VsZFxuICAgICAgICogY2xvbmUgaXQgcmF0aGVyIHRoYW4gbW9kaWZ5IGl0IGluIHBsYWNlLiAgSWYgdGhlIGdldHRlciBkb2VzIGV4cGVuc2l2ZVxuICAgICAgICogd29yayBzdWNoIGFzIGNsb25pbmcvbW9kaWZ5aW5nIGEgdGVtcGxhdGUsIGl0IHNob3VsZCBtZW1vaXplIHRoZVxuICAgICAgICogdGVtcGxhdGUgZm9yIG1heGltdW0gcGVyZm9ybWFuY2U6XG4gICAgICAgKlxuICAgICAgICogICBsZXQgbWVtb2l6ZWRUZW1wbGF0ZTtcbiAgICAgICAqICAgY2xhc3MgTXlTdWJDbGFzcyBleHRlbmRzIE15U3VwZXJDbGFzcyB7XG4gICAgICAgKiAgICAgc3RhdGljIGdldCB0ZW1wbGF0ZSgpIHtcbiAgICAgICAqICAgICAgIGlmICghbWVtb2l6ZWRUZW1wbGF0ZSkge1xuICAgICAgICogICAgICAgICBtZW1vaXplZFRlbXBsYXRlID0gc3VwZXIudGVtcGxhdGUuY2xvbmVOb2RlKHRydWUpO1xuICAgICAgICogICAgICAgICBsZXQgc3ViQ29udGVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICogICAgICAgICBzdWJDb250ZW50LnRleHRDb250ZW50ID0gJ1RoaXMgY2FtZSBmcm9tIE15U3ViQ2xhc3MnO1xuICAgICAgICogICAgICAgICBtZW1vaXplZFRlbXBsYXRlLmNvbnRlbnQuYXBwZW5kQ2hpbGQoc3ViQ29udGVudCk7XG4gICAgICAgKiAgICAgICB9XG4gICAgICAgKiAgICAgICByZXR1cm4gbWVtb2l6ZWRUZW1wbGF0ZTtcbiAgICAgICAqICAgICB9XG4gICAgICAgKiAgIH1cbiAgICAgICAqXG4gICAgICAgKiBAcmV0dXJuIHtIVE1MVGVtcGxhdGVFbGVtZW50fHN0cmluZ30gVGVtcGxhdGUgdG8gYmUgc3RhbXBlZFxuICAgICAgICovXG4gICAgICBzdGF0aWMgZ2V0IHRlbXBsYXRlKCkge1xuICAgICAgICBpZiAoIXRoaXMuaGFzT3duUHJvcGVydHkoSlNDb21waWxlcl9yZW5hbWVQcm9wZXJ0eSgnX3RlbXBsYXRlJywgdGhpcykpKSB7XG4gICAgICAgICAgdGhpcy5fdGVtcGxhdGUgPSBQb2x5bWVyLkRvbU1vZHVsZSAmJiBQb2x5bWVyLkRvbU1vZHVsZS5pbXBvcnQoXG4gICAgICAgICAgICAvKiogQHR5cGUgUG9seW1lckVsZW1lbnRDb25zdHJ1Y3RvciovICh0aGlzKS5pcywgJ3RlbXBsYXRlJykgfHxcbiAgICAgICAgICAgIC8vIG5vdGU6IGltcGxlbWVudGVkIHNvIGEgc3ViY2xhc3MgY2FuIHJldHJpZXZlIHRoZSBzdXBlclxuICAgICAgICAgICAgLy8gdGVtcGxhdGU7IGNhbGwgdGhlIHN1cGVyIGltcGwgdGhpcyB3YXkgc28gdGhhdCBgdGhpc2AgcG9pbnRzXG4gICAgICAgICAgICAvLyB0byB0aGUgc3VwZXJjbGFzcy5cbiAgICAgICAgICAgIE9iamVjdC5nZXRQcm90b3R5cGVPZigvKiogQHR5cGUgUG9seW1lckVsZW1lbnRDb25zdHJ1Y3RvciovICh0aGlzKS5wcm90b3R5cGUpLmNvbnN0cnVjdG9yLnRlbXBsYXRlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl90ZW1wbGF0ZTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBQYXRoIG1hdGNoaW5nIHRoZSB1cmwgZnJvbSB3aGljaCB0aGUgZWxlbWVudCB3YXMgaW1wb3J0ZWQuXG4gICAgICAgKiBUaGlzIHBhdGggaXMgdXNlZCB0byByZXNvbHZlIHVybCdzIGluIHRlbXBsYXRlIHN0eWxlIGNzc1RleHQuXG4gICAgICAgKiBUaGUgYGltcG9ydFBhdGhgIHByb3BlcnR5IGlzIGFsc28gc2V0IG9uIGVsZW1lbnQgaW5zdGFuY2VzIGFuZCBjYW4gYmVcbiAgICAgICAqIHVzZWQgdG8gY3JlYXRlIGJpbmRpbmdzIHJlbGF0aXZlIHRvIHRoZSBpbXBvcnQgcGF0aC5cbiAgICAgICAqIERlZmF1bHRzIHRvIHRoZSBwYXRoIG1hdGNoaW5nIHRoZSB1cmwgY29udGFpbmluZyBhIGBkb20tbW9kdWxlYCBlbGVtZW50XG4gICAgICAgKiBtYXRjaGluZyB0aGlzIGVsZW1lbnQncyBzdGF0aWMgYGlzYCBwcm9wZXJ0eS5cbiAgICAgICAqIE5vdGUsIHRoaXMgcGF0aCBzaG91bGQgY29udGFpbiBhIHRyYWlsaW5nIGAvYC5cbiAgICAgICAqXG4gICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBpbXBvcnQgcGF0aCBmb3IgdGhpcyBlbGVtZW50IGNsYXNzXG4gICAgICAgKi9cbiAgICAgIHN0YXRpYyBnZXQgaW1wb3J0UGF0aCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhc093blByb3BlcnR5KEpTQ29tcGlsZXJfcmVuYW1lUHJvcGVydHkoJ19pbXBvcnRQYXRoJywgdGhpcykpKSB7XG4gICAgICAgICAgICBjb25zdCBtb2R1bGUgPSBQb2x5bWVyLkRvbU1vZHVsZSAmJiBQb2x5bWVyLkRvbU1vZHVsZS5pbXBvcnQoLyoqIEB0eXBlIFBvbHltZXJFbGVtZW50Q29uc3RydWN0b3IgKi8gKHRoaXMpLmlzKTtcbiAgICAgICAgICAgIHRoaXMuX2ltcG9ydFBhdGggPSBtb2R1bGUgPyBtb2R1bGUuYXNzZXRwYXRoIDogJycgfHxcbiAgICAgICAgICAgIE9iamVjdC5nZXRQcm90b3R5cGVPZigvKiogQHR5cGUgUG9seW1lckVsZW1lbnRDb25zdHJ1Y3RvciovICh0aGlzKS5wcm90b3R5cGUpLmNvbnN0cnVjdG9yLmltcG9ydFBhdGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2ltcG9ydFBhdGg7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogT3ZlcnJpZGVzIHRoZSBkZWZhdWx0IGBQb2x5bWVyLlByb3BlcnR5QWNjZXNzb3JzYCB0byBlbnN1cmUgY2xhc3NcbiAgICAgICAqIG1ldGFwcm9ncmFtbWluZyByZWxhdGVkIHRvIHByb3BlcnR5IGFjY2Vzc29ycyBhbmQgZWZmZWN0cyBoYXNcbiAgICAgICAqIGNvbXBsZXRlZCAoY2FsbHMgYGZpbmFsaXplYCkuXG4gICAgICAgKlxuICAgICAgICogSXQgYWxzbyBpbml0aWFsaXplcyBhbnkgcHJvcGVydHkgZGVmYXVsdHMgcHJvdmlkZWQgdmlhIGB2YWx1ZWAgaW5cbiAgICAgICAqIGBwcm9wZXJ0aWVzYCBtZXRhZGF0YS5cbiAgICAgICAqXG4gICAgICAgKiBAb3ZlcnJpZGVcbiAgICAgICAqIEBzdXBwcmVzcyB7aW52YWxpZENhc3RzfVxuICAgICAgICovXG4gICAgICBfaW5pdGlhbGl6ZVByb3BlcnRpZXMoKSB7XG4gICAgICAgIFBvbHltZXIudGVsZW1ldHJ5Lmluc3RhbmNlQ291bnQrKztcbiAgICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5maW5hbGl6ZSgpO1xuICAgICAgICBjb25zdCBpbXBvcnRQYXRoID0gdGhpcy5jb25zdHJ1Y3Rvci5pbXBvcnRQYXRoO1xuICAgICAgICAvLyBub3RlOiBmaW5hbGl6ZSB0ZW1wbGF0ZSB3aGVuIHdlIGhhdmUgYWNjZXNzIHRvIGBsb2NhbE5hbWVgIHRvXG4gICAgICAgIC8vIGF2b2lkIGRlcGVuZGVuY2Ugb24gYGlzYCBmb3IgcG9seWZpbGxpbmcgc3R5bGluZy5cbiAgICAgICAgaWYgKHRoaXMuX3RlbXBsYXRlICYmICF0aGlzLl90ZW1wbGF0ZS5fX3BvbHltZXJGaW5hbGl6ZWQpIHtcbiAgICAgICAgICB0aGlzLl90ZW1wbGF0ZS5fX3BvbHltZXJGaW5hbGl6ZWQgPSB0cnVlO1xuICAgICAgICAgIGNvbnN0IGJhc2VVUkkgPVxuICAgICAgICAgICAgaW1wb3J0UGF0aCA/IFBvbHltZXIuUmVzb2x2ZVVybC5yZXNvbHZlVXJsKGltcG9ydFBhdGgpIDogJyc7XG4gICAgICAgICAgZmluYWxpemVUZW1wbGF0ZSgvKiogQHR5cGUgeyFQb2x5bWVyRWxlbWVudH0gKi8odGhpcy5fX3Byb3RvX18pLCB0aGlzLl90ZW1wbGF0ZSwgYmFzZVVSSSxcbiAgICAgICAgICAgIC8qKkB0eXBlIHshSFRNTEVsZW1lbnR9Ki8odGhpcykubG9jYWxOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlci5faW5pdGlhbGl6ZVByb3BlcnRpZXMoKTtcbiAgICAgICAgLy8gc2V0IHBhdGggZGVmYXVsdHNcbiAgICAgICAgdGhpcy5yb290UGF0aCA9IFBvbHltZXIucm9vdFBhdGg7XG4gICAgICAgIHRoaXMuaW1wb3J0UGF0aCA9IGltcG9ydFBhdGg7XG4gICAgICAgIC8vIGFwcGx5IHByb3BlcnR5IGRlZmF1bHRzLi4uXG4gICAgICAgIGxldCBwJCA9IHByb3BlcnR5RGVmYXVsdHNGb3JDbGFzcyh0aGlzLmNvbnN0cnVjdG9yKTtcbiAgICAgICAgaWYgKCFwJCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBwIGluIHAkKSB7XG4gICAgICAgICAgbGV0IGluZm8gPSBwJFtwXTtcbiAgICAgICAgICAvLyBEb24ndCBzZXQgZGVmYXVsdCB2YWx1ZSBpZiB0aGVyZSBpcyBhbHJlYWR5IGFuIG93biBwcm9wZXJ0eSwgd2hpY2hcbiAgICAgICAgICAvLyBoYXBwZW5zIHdoZW4gYSBgcHJvcGVydGllc2AgcHJvcGVydHkgd2l0aCBkZWZhdWx0IGJ1dCBubyBlZmZlY3RzIGhhZFxuICAgICAgICAgIC8vIGEgcHJvcGVydHkgc2V0IChlLmcuIGJvdW5kKSBieSBpdHMgaG9zdCBiZWZvcmUgdXBncmFkZVxuICAgICAgICAgIGlmICghdGhpcy5oYXNPd25Qcm9wZXJ0eShwKSkge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gdHlwZW9mIGluZm8udmFsdWUgPT0gJ2Z1bmN0aW9uJyA/XG4gICAgICAgICAgICAgIGluZm8udmFsdWUuY2FsbCh0aGlzKSA6XG4gICAgICAgICAgICAgIGluZm8udmFsdWU7XG4gICAgICAgICAgICAvLyBTZXQgdmlhIGBfc2V0UHJvcGVydHlgIGlmIHRoZXJlIGlzIGFuIGFjY2Vzc29yLCB0byBlbmFibGVcbiAgICAgICAgICAgIC8vIGluaXRpYWxpemluZyByZWFkT25seSBwcm9wZXJ0eSBkZWZhdWx0c1xuICAgICAgICAgICAgaWYgKHRoaXMuX2hhc0FjY2Vzc29yKHApKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3NldFBlbmRpbmdQcm9wZXJ0eShwLCB2YWx1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzW3BdID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUHJvdmlkZXMgYSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIG9mIHRoZSBzdGFuZGFyZCBDdXN0b20gRWxlbWVudHNcbiAgICAgICAqIGBjb25uZWN0ZWRDYWxsYmFja2AuXG4gICAgICAgKlxuICAgICAgICogVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gZW5hYmxlcyB0aGUgcHJvcGVydHkgZWZmZWN0cyBzeXN0ZW0gYW5kXG4gICAgICAgKiBmbHVzaGVzIGFueSBwZW5kaW5nIHByb3BlcnRpZXMsIGFuZCB1cGRhdGVzIHNoaW1tZWQgQ1NTIHByb3BlcnRpZXNcbiAgICAgICAqIHdoZW4gdXNpbmcgdGhlIFNoYWR5Q1NTIHNjb3BpbmcvY3VzdG9tIHByb3BlcnRpZXMgcG9seWZpbGwuXG4gICAgICAgKlxuICAgICAgICogQHN1cHByZXNzIHtpbnZhbGlkQ2FzdHN9XG4gICAgICAgKi9cbiAgICAgIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgICAgICBpZiAod2luZG93LlNoYWR5Q1NTICYmIHRoaXMuX3RlbXBsYXRlKSB7XG4gICAgICAgICAgd2luZG93LlNoYWR5Q1NTLnN0eWxlRWxlbWVudCgvKiogQHR5cGUgeyFIVE1MRWxlbWVudH0gKi8odGhpcykpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2VuYWJsZVByb3BlcnRpZXMoKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBQcm92aWRlcyBhIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gb2YgdGhlIHN0YW5kYXJkIEN1c3RvbSBFbGVtZW50c1xuICAgICAgICogYGRpc2Nvbm5lY3RlZENhbGxiYWNrYC5cbiAgICAgICAqL1xuICAgICAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7fVxuXG4gICAgICAvKipcbiAgICAgICAqIFN0YW1wcyB0aGUgZWxlbWVudCB0ZW1wbGF0ZS5cbiAgICAgICAqXG4gICAgICAgKiBAb3ZlcnJpZGVcbiAgICAgICAqL1xuICAgICAgcmVhZHkoKSB7XG4gICAgICAgIGlmICh0aGlzLl90ZW1wbGF0ZSkge1xuICAgICAgICAgIHRoaXMucm9vdCA9IHRoaXMuX3N0YW1wVGVtcGxhdGUodGhpcy5fdGVtcGxhdGUpO1xuICAgICAgICAgIHRoaXMuJCA9IHRoaXMucm9vdC4kO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyLnJlYWR5KCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogSW1wbGVtZW50cyBgUHJvcGVydHlFZmZlY3RzYCdzIGBfcmVhZHlDbGllbnRzYCBjYWxsLiBBdHRhY2hlc1xuICAgICAgICogZWxlbWVudCBkb20gYnkgY2FsbGluZyBgX2F0dGFjaERvbWAgd2l0aCB0aGUgZG9tIHN0YW1wZWQgZnJvbSB0aGVcbiAgICAgICAqIGVsZW1lbnQncyB0ZW1wbGF0ZSB2aWEgYF9zdGFtcFRlbXBsYXRlYC4gTm90ZSB0aGF0IHRoaXMgYWxsb3dzXG4gICAgICAgKiBjbGllbnQgZG9tIHRvIGJlIGF0dGFjaGVkIHRvIHRoZSBlbGVtZW50IHByaW9yIHRvIGFueSBvYnNlcnZlcnNcbiAgICAgICAqIHJ1bm5pbmcuXG4gICAgICAgKlxuICAgICAgICogQG92ZXJyaWRlXG4gICAgICAgKi9cbiAgICAgIF9yZWFkeUNsaWVudHMoKSB7XG4gICAgICAgIGlmICh0aGlzLl90ZW1wbGF0ZSkge1xuICAgICAgICAgIHRoaXMucm9vdCA9IHRoaXMuX2F0dGFjaERvbSh0aGlzLnJvb3QpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoZSBzdXBlci5fcmVhZHlDbGllbnRzIGhlcmUgc2V0cyB0aGUgY2xpZW50cyBpbml0aWFsaXplZCBmbGFnLlxuICAgICAgICAvLyBXZSBtdXN0IHdhaXQgdG8gZG8gdGhpcyB1bnRpbCBhZnRlciBjbGllbnQgZG9tIGlzIGNyZWF0ZWQvYXR0YWNoZWRcbiAgICAgICAgLy8gc28gdGhhdCB0aGlzIGZsYWcgY2FuIGJlIGNoZWNrZWQgdG8gcHJldmVudCBub3RpZmljYXRpb25zIGZpcmVkXG4gICAgICAgIC8vIGR1cmluZyB0aGlzIHByb2Nlc3MgZnJvbSBiZWluZyBoYW5kbGVkIGJlZm9yZSBjbGllbnRzIGFyZSByZWFkeS5cbiAgICAgICAgc3VwZXIuX3JlYWR5Q2xpZW50cygpO1xuICAgICAgfVxuXG5cbiAgICAgIC8qKlxuICAgICAgICogQXR0YWNoZXMgYW4gZWxlbWVudCdzIHN0YW1wZWQgZG9tIHRvIGl0c2VsZi4gQnkgZGVmYXVsdCxcbiAgICAgICAqIHRoaXMgbWV0aG9kIGNyZWF0ZXMgYSBgc2hhZG93Um9vdGAgYW5kIGFkZHMgdGhlIGRvbSB0byBpdC5cbiAgICAgICAqIEhvd2V2ZXIsIHRoaXMgbWV0aG9kIG1heSBiZSBvdmVycmlkZGVuIHRvIGFsbG93IGFuIGVsZW1lbnRcbiAgICAgICAqIHRvIHB1dCBpdHMgZG9tIGluIGFub3RoZXIgbG9jYXRpb24uXG4gICAgICAgKlxuICAgICAgICogQHRocm93cyB7RXJyb3J9XG4gICAgICAgKiBAc3VwcHJlc3Mge21pc3NpbmdSZXR1cm59XG4gICAgICAgKiBAcGFyYW0ge05vZGVMaXN0fSBkb20gdG8gYXR0YWNoIHRvIHRoZSBlbGVtZW50LlxuICAgICAgICogQHJldHVybiB7Tm9kZX0gbm9kZSB0byB3aGljaCB0aGUgZG9tIGhhcyBiZWVuIGF0dGFjaGVkLlxuICAgICAgICovXG4gICAgICBfYXR0YWNoRG9tKGRvbSkge1xuICAgICAgICBpZiAodGhpcy5hdHRhY2hTaGFkb3cpIHtcbiAgICAgICAgICBpZiAoZG9tKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuc2hhZG93Um9vdCkge1xuICAgICAgICAgICAgICB0aGlzLmF0dGFjaFNoYWRvdyh7bW9kZTogJ29wZW4nfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNoYWRvd1Jvb3QuYXBwZW5kQ2hpbGQoZG9tKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNoYWRvd1Jvb3Q7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU2hhZG93RE9NIG5vdCBhdmFpbGFibGUuICcgK1xuICAgICAgICAgICAgLy8gVE9ETyhzb3J2ZWxsKTogbW92ZSB0byBjb21waWxlLXRpbWUgY29uZGl0aW9uYWwgd2hlbiBzdXBwb3J0ZWRcbiAgICAgICAgICAnUG9seW1lci5FbGVtZW50IGNhbiBjcmVhdGUgZG9tIGFzIGNoaWxkcmVuIGluc3RlYWQgb2YgaW4gJyArXG4gICAgICAgICAgJ1NoYWRvd0RPTSBieSBzZXR0aW5nIGB0aGlzLnJvb3QgPSB0aGlzO1xcYCBiZWZvcmUgXFxgcmVhZHlcXGAuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBQcm92aWRlcyBhIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gb2YgdGhlIHN0YW5kYXJkIEN1c3RvbSBFbGVtZW50c1xuICAgICAgICogYGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFja2AuXG4gICAgICAgKlxuICAgICAgICogQnkgZGVmYXVsdCwgYXR0cmlidXRlcyBkZWNsYXJlZCBpbiBgcHJvcGVydGllc2AgbWV0YWRhdGEgYXJlXG4gICAgICAgKiBkZXNlcmlhbGl6ZWQgdXNpbmcgdGhlaXIgYHR5cGVgIGluZm9ybWF0aW9uIHRvIHByb3BlcnRpZXMgb2YgdGhlXG4gICAgICAgKiBzYW1lIG5hbWUuICBcIkRhc2gtY2FzZWRcIiBhdHRyaWJ1dGVzIGFyZSBkZXNlcmlhbHplZCB0byBcImNhbWVsQ2FzZVwiXG4gICAgICAgKiBwcm9wZXJ0aWVzLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE5hbWUgb2YgYXR0cmlidXRlLlxuICAgICAgICogQHBhcmFtIHs/c3RyaW5nfSBvbGQgT2xkIHZhbHVlIG9mIGF0dHJpYnV0ZS5cbiAgICAgICAqIEBwYXJhbSB7P3N0cmluZ30gdmFsdWUgQ3VycmVudCB2YWx1ZSBvZiBhdHRyaWJ1dGUuXG4gICAgICAgKiBAb3ZlcnJpZGVcbiAgICAgICAqL1xuICAgICAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIG9sZCwgdmFsdWUpIHtcbiAgICAgICAgaWYgKG9sZCAhPT0gdmFsdWUpIHtcbiAgICAgICAgICBsZXQgcHJvcGVydHkgPSBjYXNlTWFwLmRhc2hUb0NhbWVsQ2FzZShuYW1lKTtcbiAgICAgICAgICBsZXQgdHlwZSA9IHByb3BlcnRpZXNGb3JDbGFzcyh0aGlzLmNvbnN0cnVjdG9yKVtwcm9wZXJ0eV0udHlwZTtcbiAgICAgICAgICBpZiAoIXRoaXMuX2hhc1JlYWRPbmx5RWZmZWN0KHByb3BlcnR5KSkge1xuICAgICAgICAgICAgdGhpcy5fYXR0cmlidXRlVG9Qcm9wZXJ0eShuYW1lLCB2YWx1ZSwgdHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogV2hlbiB1c2luZyB0aGUgU2hhZHlDU1Mgc2NvcGluZyBhbmQgY3VzdG9tIHByb3BlcnR5IHNoaW0sIGNhdXNlcyBhbGxcbiAgICAgICAqIHNoaW1tZWQgc3R5bGVzIGluIHRoaXMgZWxlbWVudCAoYW5kIGl0cyBzdWJ0cmVlKSB0byBiZSB1cGRhdGVkXG4gICAgICAgKiBiYXNlZCBvbiBjdXJyZW50IGN1c3RvbSBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICAgKlxuICAgICAgICogVGhlIG9wdGlvbmFsIHBhcmFtZXRlciBvdmVycmlkZXMgaW5saW5lIGN1c3RvbSBwcm9wZXJ0eSBzdHlsZXMgd2l0aCBhblxuICAgICAgICogb2JqZWN0IG9mIHByb3BlcnRpZXMgd2hlcmUgdGhlIGtleXMgYXJlIENTUyBwcm9wZXJ0aWVzLCBhbmQgdGhlIHZhbHVlc1xuICAgICAgICogYXJlIHN0cmluZ3MuXG4gICAgICAgKlxuICAgICAgICogRXhhbXBsZTogYHRoaXMudXBkYXRlU3R5bGVzKHsnLS1jb2xvcic6ICdibHVlJ30pYFxuICAgICAgICpcbiAgICAgICAqIFRoZXNlIHByb3BlcnRpZXMgYXJlIHJldGFpbmVkIHVubGVzcyBhIHZhbHVlIG9mIGBudWxsYCBpcyBzZXQuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtPYmplY3Q9fSBwcm9wZXJ0aWVzIEJhZyBvZiBjdXN0b20gcHJvcGVydHkga2V5L3ZhbHVlcyB0b1xuICAgICAgICogICBhcHBseSB0byB0aGlzIGVsZW1lbnQuXG4gICAgICAgKiBAc3VwcHJlc3Mge2ludmFsaWRDYXN0c31cbiAgICAgICAqL1xuICAgICAgdXBkYXRlU3R5bGVzKHByb3BlcnRpZXMpIHtcbiAgICAgICAgaWYgKHdpbmRvdy5TaGFkeUNTUykge1xuICAgICAgICAgIHdpbmRvdy5TaGFkeUNTUy5zdHlsZVN1YnRyZWUoLyoqIEB0eXBlIHshSFRNTEVsZW1lbnR9ICovKHRoaXMpLCBwcm9wZXJ0aWVzKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJld3JpdGVzIGEgZ2l2ZW4gVVJMIHJlbGF0aXZlIHRvIGEgYmFzZSBVUkwuIFRoZSBiYXNlIFVSTCBkZWZhdWx0cyB0b1xuICAgICAgICogdGhlIG9yaWdpbmFsIGxvY2F0aW9uIG9mIHRoZSBkb2N1bWVudCBjb250YWluaW5nIHRoZSBgZG9tLW1vZHVsZWAgZm9yXG4gICAgICAgKiB0aGlzIGVsZW1lbnQuIFRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuIHRoZSBzYW1lIFVSTCBiZWZvcmUgYW5kIGFmdGVyXG4gICAgICAgKiBidW5kbGluZy5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsIFVSTCB0byByZXNvbHZlLlxuICAgICAgICogQHBhcmFtIHtzdHJpbmc9fSBiYXNlIE9wdGlvbmFsIGJhc2UgVVJMIHRvIHJlc29sdmUgYWdhaW5zdCwgZGVmYXVsdHNcbiAgICAgICAqIHRvIHRoZSBlbGVtZW50J3MgYGltcG9ydFBhdGhgXG4gICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFJld3JpdHRlbiBVUkwgcmVsYXRpdmUgdG8gYmFzZVxuICAgICAgICovXG4gICAgICByZXNvbHZlVXJsKHVybCwgYmFzZSkge1xuICAgICAgICBpZiAoIWJhc2UgJiYgdGhpcy5pbXBvcnRQYXRoKSB7XG4gICAgICAgICAgYmFzZSA9IFBvbHltZXIuUmVzb2x2ZVVybC5yZXNvbHZlVXJsKHRoaXMuaW1wb3J0UGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFBvbHltZXIuUmVzb2x2ZVVybC5yZXNvbHZlVXJsKHVybCwgYmFzZSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogT3ZlcnJpZGVzIGBQcm9wZXJ0eUFjY2Vzc29yc2AgdG8gYWRkIG1hcCBvZiBkeW5hbWljIGZ1bmN0aW9ucyBvblxuICAgICAgICogdGVtcGxhdGUgaW5mbywgZm9yIGNvbnN1bXB0aW9uIGJ5IGBQcm9wZXJ0eUVmZmVjdHNgIHRlbXBsYXRlIGJpbmRpbmdcbiAgICAgICAqIGNvZGUuIFRoaXMgbWFwIGRldGVybWluZXMgd2hpY2ggbWV0aG9kIHRlbXBsYXRlcyBzaG91bGQgaGF2ZSBhY2Nlc3NvcnNcbiAgICAgICAqIGNyZWF0ZWQgZm9yIHRoZW0uXG4gICAgICAgKlxuICAgICAgICogQG92ZXJyaWRlXG4gICAgICAgKiBAc3VwcHJlc3Mge21pc3NpbmdQcm9wZXJ0aWVzfSBJbnRlcmZhY2VzIGluIGNsb3N1cmUgZG8gbm90IGluaGVyaXQgc3RhdGljcywgYnV0IGNsYXNzZXMgZG9cbiAgICAgICAqL1xuICAgICAgc3RhdGljIF9wYXJzZVRlbXBsYXRlQ29udGVudCh0ZW1wbGF0ZSwgdGVtcGxhdGVJbmZvLCBub2RlSW5mbykge1xuICAgICAgICB0ZW1wbGF0ZUluZm8uZHluYW1pY0ZucyA9IHRlbXBsYXRlSW5mby5keW5hbWljRm5zIHx8IHByb3BlcnRpZXNGb3JDbGFzcyh0aGlzKTtcbiAgICAgICAgcmV0dXJuIHN1cGVyLl9wYXJzZVRlbXBsYXRlQ29udGVudCh0ZW1wbGF0ZSwgdGVtcGxhdGVJbmZvLCBub2RlSW5mbyk7XG4gICAgICB9XG5cbiAgICB9XG5cbiAgICByZXR1cm4gUG9seW1lckVsZW1lbnQ7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBQcm92aWRlcyBiYXNpYyB0cmFja2luZyBvZiBlbGVtZW50IGRlZmluaXRpb25zIChyZWdpc3RyYXRpb25zKSBhbmRcbiAgICogaW5zdGFuY2UgY291bnRzLlxuICAgKlxuICAgKiBAbmFtZXNwYWNlXG4gICAqIEBzdW1tYXJ5IFByb3ZpZGVzIGJhc2ljIHRyYWNraW5nIG9mIGVsZW1lbnQgZGVmaW5pdGlvbnMgKHJlZ2lzdHJhdGlvbnMpIGFuZFxuICAgKiBpbnN0YW5jZSBjb3VudHMuXG4gICAqL1xuICBQb2x5bWVyLnRlbGVtZXRyeSA9IHtcbiAgICAvKipcbiAgICAgKiBUb3RhbCBudW1iZXIgb2YgUG9seW1lciBlbGVtZW50IGluc3RhbmNlcyBjcmVhdGVkLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgaW5zdGFuY2VDb3VudDogMCxcbiAgICAvKipcbiAgICAgKiBBcnJheSBvZiBQb2x5bWVyIGVsZW1lbnQgY2xhc3NlcyB0aGF0IGhhdmUgYmVlbiBmaW5hbGl6ZWQuXG4gICAgICogQHR5cGUge0FycmF5PFBvbHltZXIuRWxlbWVudD59XG4gICAgICovXG4gICAgcmVnaXN0cmF0aW9uczogW10sXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshUG9seW1lckVsZW1lbnRDb25zdHJ1Y3Rvcn0gcHJvdG90eXBlIEVsZW1lbnQgcHJvdG90eXBlIHRvIGxvZ1xuICAgICAqIEB0aGlzIHt0aGlzfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlZ0xvZzogZnVuY3Rpb24ocHJvdG90eXBlKSB7XG4gICAgICBjb25zb2xlLmxvZygnWycgKyBwcm90b3R5cGUuaXMgKyAnXTogcmVnaXN0ZXJlZCcpXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYSBjbGFzcyBwcm90b3R5cGUgZm9yIHRlbGVtZXRyeSBwdXJwb3Nlcy5cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwcm90b3R5cGUgRWxlbWVudCBwcm90b3R5cGUgdG8gcmVnaXN0ZXJcbiAgICAgKiBAdGhpcyB7dGhpc31cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgcmVnaXN0ZXI6IGZ1bmN0aW9uKHByb3RvdHlwZSkge1xuICAgICAgdGhpcy5yZWdpc3RyYXRpb25zLnB1c2gocHJvdG90eXBlKTtcbiAgICAgIFBvbHltZXIubG9nICYmIHRoaXMuX3JlZ0xvZyhwcm90b3R5cGUpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogTG9ncyBhbGwgZWxlbWVudHMgcmVnaXN0ZXJlZCB3aXRoIGFuIGBpc2AgdG8gdGhlIGNvbnNvbGUuXG4gICAgICogQHB1YmxpY1xuICAgICAqIEB0aGlzIHt0aGlzfVxuICAgICAqL1xuICAgIGR1bXBSZWdpc3RyYXRpb25zOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMucmVnaXN0cmF0aW9ucy5mb3JFYWNoKHRoaXMuX3JlZ0xvZyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBXaGVuIHVzaW5nIHRoZSBTaGFkeUNTUyBzY29waW5nIGFuZCBjdXN0b20gcHJvcGVydHkgc2hpbSwgY2F1c2VzIGFsbFxuICAgKiBzaGltbWVkIGBzdHlsZXNgICh2aWEgYGN1c3RvbS1zdHlsZWApIGluIHRoZSBkb2N1bWVudCAoYW5kIGl0cyBzdWJ0cmVlKVxuICAgKiB0byBiZSB1cGRhdGVkIGJhc2VkIG9uIGN1cnJlbnQgY3VzdG9tIHByb3BlcnR5IHZhbHVlcy5cbiAgICpcbiAgICogVGhlIG9wdGlvbmFsIHBhcmFtZXRlciBvdmVycmlkZXMgaW5saW5lIGN1c3RvbSBwcm9wZXJ0eSBzdHlsZXMgd2l0aCBhblxuICAgKiBvYmplY3Qgb2YgcHJvcGVydGllcyB3aGVyZSB0aGUga2V5cyBhcmUgQ1NTIHByb3BlcnRpZXMsIGFuZCB0aGUgdmFsdWVzXG4gICAqIGFyZSBzdHJpbmdzLlxuICAgKlxuICAgKiBFeGFtcGxlOiBgUG9seW1lci51cGRhdGVTdHlsZXMoeyctLWNvbG9yJzogJ2JsdWUnfSlgXG4gICAqXG4gICAqIFRoZXNlIHByb3BlcnRpZXMgYXJlIHJldGFpbmVkIHVubGVzcyBhIHZhbHVlIG9mIGBudWxsYCBpcyBzZXQuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0PX0gcHJvcHMgQmFnIG9mIGN1c3RvbSBwcm9wZXJ0eSBrZXkvdmFsdWVzIHRvXG4gICAqICAgYXBwbHkgdG8gdGhlIGRvY3VtZW50LlxuICAgKi9cbiAgUG9seW1lci51cGRhdGVTdHlsZXMgPSBmdW5jdGlvbihwcm9wcykge1xuICAgIGlmICh3aW5kb3cuU2hhZHlDU1MpIHtcbiAgICAgIHdpbmRvdy5TaGFkeUNTUy5zdHlsZURvY3VtZW50KHByb3BzKTtcbiAgICB9XG4gIH07XG5cbn0pKCk7XG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvbWl4aW5zL2VsZW1lbnQtbWl4aW4uaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cblxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3V0aWxzL2Jvb3QuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3V0aWxzL3Jlc29sdmUtdXJsLmh0bWxcIj5cblxuPHNjcmlwdD5cbi8qKiBAc3VwcHJlc3Mge2RlcHJlY2F0ZWR9ICovXG4oZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvKipcbiAgICogTGVnYWN5IHNldHRpbmdzLlxuICAgKiBAbmFtZXNwYWNlXG4gICAqIEBtZW1iZXJvZiBQb2x5bWVyXG4gICAqL1xuICBjb25zdCBzZXR0aW5ncyA9IFBvbHltZXIuU2V0dGluZ3MgfHwge307XG4gIHNldHRpbmdzLnVzZVNoYWRvdyA9ICEod2luZG93LlNoYWR5RE9NKTtcbiAgc2V0dGluZ3MudXNlTmF0aXZlQ1NTUHJvcGVydGllcyA9XG4gICAgQm9vbGVhbighd2luZG93LlNoYWR5Q1NTIHx8IHdpbmRvdy5TaGFkeUNTUy5uYXRpdmVDc3MpO1xuICBzZXR0aW5ncy51c2VOYXRpdmVDdXN0b21FbGVtZW50cyA9XG4gICAgISh3aW5kb3cuY3VzdG9tRWxlbWVudHMucG9seWZpbGxXcmFwRmx1c2hDYWxsYmFjayk7XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGdsb2JhbCwgbGVnYWN5IHNldHRpbmdzLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZFxuICAgKiBAbWVtYmVyb2YgUG9seW1lclxuICAgKi9cbiAgUG9seW1lci5TZXR0aW5ncyA9IHNldHRpbmdzO1xuXG4gIC8qKlxuICAgKiBHbG9iYWxseSBzZXR0YWJsZSBwcm9wZXJ0eSB0aGF0IGlzIGF1dG9tYXRpY2FsbHkgYXNzaWduZWQgdG9cbiAgICogYFBvbHltZXIuRWxlbWVudE1peGluYCBpbnN0YW5jZXMsIHVzZWZ1bCBmb3IgYmluZGluZyBpbiB0ZW1wbGF0ZXMgdG9cbiAgICogbWFrZSBVUkwncyByZWxhdGl2ZSB0byBhbiBhcHBsaWNhdGlvbidzIHJvb3QuICBEZWZhdWx0cyB0byB0aGUgbWFpblxuICAgKiBkb2N1bWVudCBVUkwsIGJ1dCBjYW4gYmUgb3ZlcnJpZGRlbiBieSB1c2Vycy4gIEl0IG1heSBiZSB1c2VmdWwgdG8gc2V0XG4gICAqIGBQb2x5bWVyLnJvb3RQYXRoYCB0byBwcm92aWRlIGEgc3RhYmxlIGFwcGxpY2F0aW9uIG1vdW50IHBhdGggd2hlblxuICAgKiB1c2luZyBjbGllbnQgc2lkZSByb3V0aW5nLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgUG9seW1lclxuICAgKi9cbiAgbGV0IHJvb3RQYXRoID0gUG9seW1lci5yb290UGF0aCB8fFxuICAgIFBvbHltZXIuUmVzb2x2ZVVybC5wYXRoRnJvbVVybChkb2N1bWVudC5iYXNlVVJJIHx8IHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcblxuICBQb2x5bWVyLnJvb3RQYXRoID0gcm9vdFBhdGg7XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGdsb2JhbCByb290UGF0aCBwcm9wZXJ0eSB1c2VkIGJ5IGBQb2x5bWVyLkVsZW1lbnRNaXhpbmAgYW5kXG4gICAqIGF2YWlsYWJsZSB2aWEgYFBvbHltZXIucm9vdFBhdGhgLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgUG9seW1lclxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBUaGUgbmV3IHJvb3QgcGF0aFxuICAgKi9cbiAgUG9seW1lci5zZXRSb290UGF0aCA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgICBQb2x5bWVyLnJvb3RQYXRoID0gcGF0aDtcbiAgfVxufSkoKTtcbjwvc2NyaXB0PlxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvdXRpbHMvc2V0dGluZ3MuaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCJyZXNvbHZlLXVybC5odG1sXCI+XG48c2NyaXB0PlxuKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgY29uc3QgTU9EVUxFX1NUWUxFX0xJTktfU0VMRUNUT1IgPSAnbGlua1tyZWw9aW1wb3J0XVt0eXBlfj1jc3NdJztcbiAgY29uc3QgSU5DTFVERV9BVFRSID0gJ2luY2x1ZGUnO1xuXG4gIGZ1bmN0aW9uIGltcG9ydE1vZHVsZShtb2R1bGVJZCkge1xuICAgIGlmICghUG9seW1lci5Eb21Nb2R1bGUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gUG9seW1lci5Eb21Nb2R1bGUuaW1wb3J0KG1vZHVsZUlkKTtcbiAgfVxuXG4gIC8qKiBAdHlwZWRlZiB7e2Fzc2V0cGF0aDogc3RyaW5nfX0gKi9cbiAgbGV0IHRlbXBsYXRlV2l0aEFzc2V0UGF0aDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuXG4gIC8qKlxuICAgKiBNb2R1bGUgd2l0aCB1dGlsaXRpZXMgZm9yIGNvbGxlY3Rpb24gQ1NTIHRleHQgZnJvbSBgPHRlbXBsYXRlcz5gLCBleHRlcm5hbFxuICAgKiBzdHlsZXNoZWV0cywgYW5kIGBkb20tbW9kdWxlYHMuXG4gICAqXG4gICAqIEBuYW1lc3BhY2VcbiAgICogQG1lbWJlcm9mIFBvbHltZXJcbiAgICogQHN1bW1hcnkgTW9kdWxlIHdpdGggdXRpbGl0aWVzIGZvciBjb2xsZWN0aW9uIENTUyB0ZXh0IGZyb20gdmFyaW91cyBzb3VyY2VzLlxuICAgKi9cbiAgY29uc3QgU3R5bGVHYXRoZXIgPSB7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIENTUyB0ZXh0IG9mIHN0eWxlcyBpbiBhIHNwYWNlLXNlcGFyYXRlZCBsaXN0IG9mIGBkb20tbW9kdWxlYHMuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgUG9seW1lci5TdHlsZUdhdGhlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtb2R1bGVJZHMgTGlzdCBvZiBkb20tbW9kdWxlIGlkJ3Mgd2l0aGluIHdoaWNoIHRvXG4gICAgICogc2VhcmNoIGZvciBjc3MuXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBDb25jYXRlbmF0ZWQgQ1NTIGNvbnRlbnQgZnJvbSBzcGVjaWZpZWQgYGRvbS1tb2R1bGVgc1xuICAgICAqIEB0aGlzIHtTdHlsZUdhdGhlcn1cbiAgICAgKi9cbiAgICBjc3NGcm9tTW9kdWxlcyhtb2R1bGVJZHMpIHtcbiAgICAgIGxldCBtb2R1bGVzID0gbW9kdWxlSWRzLnRyaW0oKS5zcGxpdCgnICcpO1xuICAgICAgbGV0IGNzc1RleHQgPSAnJztcbiAgICAgIGZvciAobGV0IGk9MDsgaSA8IG1vZHVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY3NzVGV4dCArPSB0aGlzLmNzc0Zyb21Nb2R1bGUobW9kdWxlc1tpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY3NzVGV4dDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBDU1MgdGV4dCBvZiBzdHlsZXMgaW4gYSBnaXZlbiBgZG9tLW1vZHVsZWAuICBDU1MgaW4gYSBgZG9tLW1vZHVsZWBcbiAgICAgKiBjYW4gY29tZSBlaXRoZXIgZnJvbSBgPHN0eWxlPmBzIHdpdGhpbiB0aGUgZmlyc3QgYDx0ZW1wbGF0ZT5gLCBvciBlbHNlXG4gICAgICogZnJvbSBvbmUgb3IgbW9yZSBgPGxpbmsgcmVsPVwiaW1wb3J0XCIgdHlwZT1cImNzc1wiPmAgbGlua3Mgb3V0c2lkZSB0aGVcbiAgICAgKiB0ZW1wbGF0ZS5cbiAgICAgKlxuICAgICAqIEFueSBgPHN0eWxlcz5gIHByb2Nlc3NlZCBhcmUgcmVtb3ZlZCBmcm9tIHRoZWlyIG9yaWdpbmFsIGxvY2F0aW9uLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIFBvbHltZXIuU3R5bGVHYXRoZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbW9kdWxlSWQgZG9tLW1vZHVsZSBpZCB0byBnYXRoZXIgc3R5bGVzIGZyb21cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IENvbmNhdGVuYXRlZCBDU1MgY29udGVudCBmcm9tIHNwZWNpZmllZCBgZG9tLW1vZHVsZWBcbiAgICAgKiBAdGhpcyB7U3R5bGVHYXRoZXJ9XG4gICAgICovXG4gICAgY3NzRnJvbU1vZHVsZShtb2R1bGVJZCkge1xuICAgICAgbGV0IG0gPSBpbXBvcnRNb2R1bGUobW9kdWxlSWQpO1xuICAgICAgaWYgKG0gJiYgbS5fY3NzVGV4dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCBjc3NUZXh0ID0gJyc7XG4gICAgICAgIC8vIGluY2x1ZGUgY3NzIGZyb20gdGhlIGZpcnN0IHRlbXBsYXRlIGluIHRoZSBtb2R1bGVcbiAgICAgICAgbGV0IHQgPSBtLnF1ZXJ5U2VsZWN0b3IoJ3RlbXBsYXRlJyk7XG4gICAgICAgIGlmICh0KSB7XG4gICAgICAgICAgY3NzVGV4dCArPSB0aGlzLmNzc0Zyb21UZW1wbGF0ZSh0LCAvKiogQHR5cGUge3RlbXBsYXRlV2l0aEFzc2V0UGF0aCB9Ki8obSkuYXNzZXRwYXRoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBtb2R1bGUgaW1wb3J0czogPGxpbmsgcmVsPVwiaW1wb3J0XCIgdHlwZT1cImNzc1wiPlxuICAgICAgICBjc3NUZXh0ICs9IHRoaXMuY3NzRnJvbU1vZHVsZUltcG9ydHMobW9kdWxlSWQpO1xuICAgICAgICBtLl9jc3NUZXh0ID0gY3NzVGV4dCB8fCBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKCFtKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignQ291bGQgbm90IGZpbmQgc3R5bGUgZGF0YSBpbiBtb2R1bGUgbmFtZWQnLCBtb2R1bGVJZCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbSAmJiBtLl9jc3NUZXh0IHx8ICcnO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIENTUyB0ZXh0IG9mIGA8c3R5bGVzPmAgd2l0aGluIGEgZ2l2ZW4gdGVtcGxhdGUuXG4gICAgICpcbiAgICAgKiBBbnkgYDxzdHlsZXM+YCBwcm9jZXNzZWQgYXJlIHJlbW92ZWQgZnJvbSB0aGVpciBvcmlnaW5hbCBsb2NhdGlvbi5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBQb2x5bWVyLlN0eWxlR2F0aGVyXG4gICAgICogQHBhcmFtIHtIVE1MVGVtcGxhdGVFbGVtZW50fSB0ZW1wbGF0ZSBUZW1wbGF0ZSB0byBnYXRoZXIgc3R5bGVzIGZyb21cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYmFzZVVSSSBCYXNlIFVSSSB0byByZXNvbHZlIHRoZSBVUkwgYWdhaW5zdFxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gQ29uY2F0ZW5hdGVkIENTUyBjb250ZW50IGZyb20gc3BlY2lmaWVkIHRlbXBsYXRlXG4gICAgICogQHRoaXMge1N0eWxlR2F0aGVyfVxuICAgICAqL1xuICAgIGNzc0Zyb21UZW1wbGF0ZSh0ZW1wbGF0ZSwgYmFzZVVSSSkge1xuICAgICAgbGV0IGNzc1RleHQgPSAnJztcbiAgICAgIC8vIGlmIGVsZW1lbnQgaXMgYSB0ZW1wbGF0ZSwgZ2V0IGNvbnRlbnQgZnJvbSBpdHMgLmNvbnRlbnRcbiAgICAgIGxldCBlJCA9IHRlbXBsYXRlLmNvbnRlbnQucXVlcnlTZWxlY3RvckFsbCgnc3R5bGUnKTtcbiAgICAgIGZvciAobGV0IGk9MDsgaSA8IGUkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBlID0gZSRbaV07XG4gICAgICAgIC8vIHN1cHBvcnQgc3R5bGUgc2hhcmluZyBieSBhbGxvd2luZyBzdHlsZXMgdG8gXCJpbmNsdWRlXCJcbiAgICAgICAgLy8gb3RoZXIgZG9tLW1vZHVsZXMgdGhhdCBjb250YWluIHN0eWxpbmdcbiAgICAgICAgbGV0IGluY2x1ZGUgPSBlLmdldEF0dHJpYnV0ZShJTkNMVURFX0FUVFIpO1xuICAgICAgICBpZiAoaW5jbHVkZSkge1xuICAgICAgICAgIGNzc1RleHQgKz0gdGhpcy5jc3NGcm9tTW9kdWxlcyhpbmNsdWRlKTtcbiAgICAgICAgfVxuICAgICAgICBlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZSk7XG4gICAgICAgIGNzc1RleHQgKz0gYmFzZVVSSSA/XG4gICAgICAgICAgUG9seW1lci5SZXNvbHZlVXJsLnJlc29sdmVDc3MoZS50ZXh0Q29udGVudCwgYmFzZVVSSSkgOiBlLnRleHRDb250ZW50O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNzc1RleHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgQ1NTIHRleHQgZnJvbSBzdHlsc2hlZXRzIGxvYWRlZCB2aWEgYDxsaW5rIHJlbD1cImltcG9ydFwiIHR5cGU9XCJjc3NcIj5gXG4gICAgICogbGlua3Mgd2l0aGluIHRoZSBzcGVjaWZpZWQgYGRvbS1tb2R1bGVgLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIFBvbHltZXIuU3R5bGVHYXRoZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbW9kdWxlSWQgSWQgb2YgYGRvbS1tb2R1bGVgIHRvIGdhdGhlciBDU1MgZnJvbVxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gQ29uY2F0ZW5hdGVkIENTUyBjb250ZW50IGZyb20gbGlua3MgaW4gc3BlY2lmaWVkIGBkb20tbW9kdWxlYFxuICAgICAqIEB0aGlzIHtTdHlsZUdhdGhlcn1cbiAgICAgKi9cbiAgICBjc3NGcm9tTW9kdWxlSW1wb3J0cyhtb2R1bGVJZCkge1xuICAgICAgbGV0IGNzc1RleHQgPSAnJztcbiAgICAgIGxldCBtID0gaW1wb3J0TW9kdWxlKG1vZHVsZUlkKTtcbiAgICAgIGlmICghbSkge1xuICAgICAgICByZXR1cm4gY3NzVGV4dDtcbiAgICAgIH1cbiAgICAgIGxldCBwJCA9IG0ucXVlcnlTZWxlY3RvckFsbChNT0RVTEVfU1RZTEVfTElOS19TRUxFQ1RPUik7XG4gICAgICBmb3IgKGxldCBpPTA7IGkgPCBwJC5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgcCA9IHAkW2ldO1xuICAgICAgICBpZiAocC5pbXBvcnQpIHtcbiAgICAgICAgICBsZXQgaW1wb3J0RG9jID0gcC5pbXBvcnQ7XG4gICAgICAgICAgLy8gTk9URTogcG9seWZpbGwgYWZmb3JkYW5jZS5cbiAgICAgICAgICAvLyB1bmRlciB0aGUgSFRNTEltcG9ydHMgcG9seWZpbGwsIHRoZXJlIHdpbGwgYmUgbm8gJ2JvZHknLFxuICAgICAgICAgIC8vIGJ1dCB0aGUgaW1wb3J0IHBzZXVkby1kb2MgY2FuIGJlIHVzZWQgZGlyZWN0bHkuXG4gICAgICAgICAgbGV0IGNvbnRhaW5lciA9IGltcG9ydERvYy5ib2R5ID8gaW1wb3J0RG9jLmJvZHkgOiBpbXBvcnREb2M7XG4gICAgICAgICAgY3NzVGV4dCArPVxuICAgICAgICAgICAgUG9seW1lci5SZXNvbHZlVXJsLnJlc29sdmVDc3MoY29udGFpbmVyLnRleHRDb250ZW50LFxuICAgICAgICAgICAgICBpbXBvcnREb2MuYmFzZVVSSSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBjc3NUZXh0O1xuICAgIH1cbiAgfTtcblxuICBQb2x5bWVyLlN0eWxlR2F0aGVyID0gU3R5bGVHYXRoZXI7XG59KSgpO1xuPC9zY3JpcHQ+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL3BvbHltZXIvbGliL3V0aWxzL3N0eWxlLWdhdGhlci5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuXG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vLi4vLi4vc2hhZHljc3MvYXBwbHktc2hpbS5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vbWl4aW5zL2VsZW1lbnQtbWl4aW4uaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL21peGlucy9nZXN0dXJlLWV2ZW50LWxpc3RlbmVycy5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vdXRpbHMvbWl4aW4uaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3V0aWxzL2ltcG9ydC1ocmVmLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi91dGlscy9yZW5kZXItc3RhdHVzLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi91dGlscy91bnJlc29sdmVkLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCJwb2x5bWVyLmRvbS5odG1sXCI+XG5cbjxzY3JpcHQ+XG4oZnVuY3Rpb24oKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIGxldCBzdHlsZUludGVyZmFjZSA9IHdpbmRvdy5TaGFkeUNTUztcblxuICAvKipcbiAgICogRWxlbWVudCBjbGFzcyBtaXhpbiB0aGF0IHByb3ZpZGVzIFBvbHltZXIncyBcImxlZ2FjeVwiIEFQSSBpbnRlbmRlZCB0byBiZVxuICAgKiBiYWNrd2FyZC1jb21wYXRpYmxlIHRvIHRoZSBncmVhdGVzdCBleHRlbnQgcG9zc2libGUgd2l0aCB0aGUgQVBJXG4gICAqIGZvdW5kIG9uIHRoZSBQb2x5bWVyIDEueCBgUG9seW1lci5CYXNlYCBwcm90b3R5cGUgYXBwbGllZCB0byBhbGwgZWxlbWVudHNcbiAgICogZGVmaW5lZCB1c2luZyB0aGUgYFBvbHltZXIoey4uLn0pYCBmdW5jdGlvbi5cbiAgICpcbiAgICogQG1peGluRnVuY3Rpb25cbiAgICogQHBvbHltZXJcbiAgICogQGFwcGxpZXNNaXhpbiBQb2x5bWVyLkVsZW1lbnRNaXhpblxuICAgKiBAYXBwbGllc01peGluIFBvbHltZXIuR2VzdHVyZUV2ZW50TGlzdGVuZXJzXG4gICAqIEBwcm9wZXJ0eSBpc0F0dGFjaGVkIHtib29sZWFufSBTZXQgdG8gYHRydWVgIGluIHRoaXMgZWxlbWVudCdzXG4gICAqICAgYGNvbm5lY3RlZENhbGxiYWNrYCBhbmQgYGZhbHNlYCBpbiBgZGlzY29ubmVjdGVkQ2FsbGJhY2tgXG4gICAqIEBtZW1iZXJvZiBQb2x5bWVyXG4gICAqIEBzdW1tYXJ5IEVsZW1lbnQgY2xhc3MgbWl4aW4gdGhhdCBwcm92aWRlcyBQb2x5bWVyJ3MgXCJsZWdhY3lcIiBBUElcbiAgICovXG4gIFBvbHltZXIuTGVnYWN5RWxlbWVudE1peGluID0gUG9seW1lci5kZWR1cGluZ01peGluKChiYXNlKSA9PiB7XG5cbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAZXh0ZW5kcyB7YmFzZX1cbiAgICAgKiBAaW1wbGVtZW50cyB7UG9seW1lcl9FbGVtZW50TWl4aW59XG4gICAgICogQGltcGxlbWVudHMge1BvbHltZXJfR2VzdHVyZUV2ZW50TGlzdGVuZXJzfVxuICAgICAqL1xuICAgIGNvbnN0IGxlZ2FjeUVsZW1lbnRCYXNlID0gUG9seW1lci5HZXN0dXJlRXZlbnRMaXN0ZW5lcnMoUG9seW1lci5FbGVtZW50TWl4aW4oYmFzZSkpO1xuXG4gICAgLyoqXG4gICAgICogTWFwIG9mIHNpbXBsZSBuYW1lcyB0byB0b3VjaCBhY3Rpb24gbmFtZXNcbiAgICAgKiBAZGljdFxuICAgICAqL1xuICAgIGNvbnN0IERJUkVDVElPTl9NQVAgPSB7XG4gICAgICAneCc6ICdwYW4teCcsXG4gICAgICAneSc6ICdwYW4teScsXG4gICAgICAnbm9uZSc6ICdub25lJyxcbiAgICAgICdhbGwnOiAnYXV0bydcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHBvbHltZXJcbiAgICAgKiBAbWl4aW5DbGFzc1xuICAgICAqIEBleHRlbmRzIHtsZWdhY3lFbGVtZW50QmFzZX1cbiAgICAgKiBAaW1wbGVtZW50cyB7UG9seW1lcl9MZWdhY3lFbGVtZW50TWl4aW59XG4gICAgICogQHVucmVzdHJpY3RlZFxuICAgICAqL1xuICAgIGNsYXNzIExlZ2FjeUVsZW1lbnQgZXh0ZW5kcyBsZWdhY3lFbGVtZW50QmFzZSB7XG5cbiAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnJvb3QgPSB0aGlzO1xuICAgICAgICB0aGlzLmNyZWF0ZWQoKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBMZWdhY3kgY2FsbGJhY2sgY2FsbGVkIGR1cmluZyB0aGUgYGNvbnN0cnVjdG9yYCwgZm9yIG92ZXJyaWRpbmdcbiAgICAgICAqIGJ5IHRoZSB1c2VyLlxuICAgICAgICovXG4gICAgICBjcmVhdGVkKCkge31cblxuICAgICAgLyoqXG4gICAgICAgKiBQcm92aWRlcyBhbiBpbXBsZW1lbnRhdGlvbiBvZiBgY29ubmVjdGVkQ2FsbGJhY2tgXG4gICAgICAgKiB3aGljaCBhZGRzIFBvbHltZXIgbGVnYWN5IEFQSSdzIGBhdHRhY2hlZGAgbWV0aG9kLlxuICAgICAgICogQG92ZXJyaWRlXG4gICAgICAgKi9cbiAgICAgIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgICAgICBzdXBlci5jb25uZWN0ZWRDYWxsYmFjaygpO1xuICAgICAgICB0aGlzLmlzQXR0YWNoZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmF0dGFjaGVkKCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogTGVnYWN5IGNhbGxiYWNrIGNhbGxlZCBkdXJpbmcgYGNvbm5lY3RlZENhbGxiYWNrYCwgZm9yIG92ZXJyaWRpbmdcbiAgICAgICAqIGJ5IHRoZSB1c2VyLlxuICAgICAgICovXG4gICAgICBhdHRhY2hlZCgpIHt9XG5cbiAgICAgIC8qKlxuICAgICAgICogUHJvdmlkZXMgYW4gaW1wbGVtZW50YXRpb24gb2YgYGRpc2Nvbm5lY3RlZENhbGxiYWNrYFxuICAgICAgICogd2hpY2ggYWRkcyBQb2x5bWVyIGxlZ2FjeSBBUEkncyBgZGV0YWNoZWRgIG1ldGhvZC5cbiAgICAgICAqIEBvdmVycmlkZVxuICAgICAgICovXG4gICAgICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgICAgc3VwZXIuZGlzY29ubmVjdGVkQ2FsbGJhY2soKTtcbiAgICAgICAgdGhpcy5pc0F0dGFjaGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZGV0YWNoZWQoKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBMZWdhY3kgY2FsbGJhY2sgY2FsbGVkIGR1cmluZyBgZGlzY29ubmVjdGVkQ2FsbGJhY2tgLCBmb3Igb3ZlcnJpZGluZ1xuICAgICAgICogYnkgdGhlIHVzZXIuXG4gICAgICAgKi9cbiAgICAgIGRldGFjaGVkKCkge31cblxuICAgICAgLyoqXG4gICAgICAgKiBQcm92aWRlcyBhbiBvdmVycmlkZSBpbXBsZW1lbnRhdGlvbiBvZiBgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrYFxuICAgICAgICogd2hpY2ggYWRkcyB0aGUgUG9seW1lciBsZWdhY3kgQVBJJ3MgYGF0dHJpYnV0ZUNoYW5nZWRgIG1ldGhvZC5cbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE5hbWUgb2YgYXR0cmlidXRlLlxuICAgICAgICogQHBhcmFtIHs/c3RyaW5nfSBvbGQgT2xkIHZhbHVlIG9mIGF0dHJpYnV0ZS5cbiAgICAgICAqIEBwYXJhbSB7P3N0cmluZ30gdmFsdWUgQ3VycmVudCB2YWx1ZSBvZiBhdHRyaWJ1dGUuXG4gICAgICAgKiBAb3ZlcnJpZGVcbiAgICAgICAqL1xuICAgICAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIG9sZCwgdmFsdWUpIHtcbiAgICAgICAgaWYgKG9sZCAhPT0gdmFsdWUpIHtcbiAgICAgICAgICBzdXBlci5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgb2xkLCB2YWx1ZSk7XG4gICAgICAgICAgdGhpcy5hdHRyaWJ1dGVDaGFuZ2VkKG5hbWUsIG9sZCwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogTGVnYWN5IGNhbGxiYWNrIGNhbGxlZCBkdXJpbmcgYGF0dHJpYnV0ZUNoYW5nZWRDaGFsbGJhY2tgLCBmb3Igb3ZlcnJpZGluZ1xuICAgICAgICogYnkgdGhlIHVzZXIuXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBOYW1lIG9mIGF0dHJpYnV0ZS5cbiAgICAgICAqIEBwYXJhbSB7P3N0cmluZ30gb2xkIE9sZCB2YWx1ZSBvZiBhdHRyaWJ1dGUuXG4gICAgICAgKiBAcGFyYW0gez9zdHJpbmd9IHZhbHVlIEN1cnJlbnQgdmFsdWUgb2YgYXR0cmlidXRlLlxuICAgICAgICovXG4gICAgICBhdHRyaWJ1dGVDaGFuZ2VkKG5hbWUsIG9sZCwgdmFsdWUpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblxuICAgICAgLyoqXG4gICAgICAgKiBPdmVycmlkZXMgdGhlIGRlZmF1bHQgYFBvbHltZXIuUHJvcGVydHlFZmZlY3RzYCBpbXBsZW1lbnRhdGlvbiB0b1xuICAgICAgICogYWRkIHN1cHBvcnQgZm9yIGNsYXNzIGluaXRpYWxpemF0aW9uIHZpYSB0aGUgYF9yZWdpc3RlcmVkYCBjYWxsYmFjay5cbiAgICAgICAqIFRoaXMgaXMgY2FsbGVkIG9ubHkgd2hlbiB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgdGhlIGVsZW1lbnQgaXMgY3JlYXRlZC5cbiAgICAgICAqXG4gICAgICAgKiBAb3ZlcnJpZGVcbiAgICAgICAqL1xuICAgICAgX2luaXRpYWxpemVQcm9wZXJ0aWVzKCkge1xuICAgICAgICBsZXQgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcyk7XG4gICAgICAgIGlmICghcHJvdG8uaGFzT3duUHJvcGVydHkoJ19faGFzUmVnaXN0ZXJGaW5pc2hlZCcpKSB7XG4gICAgICAgICAgcHJvdG8uX19oYXNSZWdpc3RlckZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLl9yZWdpc3RlcmVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIuX2luaXRpYWxpemVQcm9wZXJ0aWVzKCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ2FsbGVkIGF1dG9tYXRpY2FsbHkgd2hlbiBhbiBlbGVtZW50IGlzIGluaXRpYWxpemluZy5cbiAgICAgICAqIFVzZXJzIG1heSBvdmVycmlkZSB0aGlzIG1ldGhvZCB0byBwZXJmb3JtIGNsYXNzIHJlZ2lzdHJhdGlvbiB0aW1lXG4gICAgICAgKiB3b3JrLiBUaGUgaW1wbGVtZW50YXRpb24gc2hvdWxkIGVuc3VyZSB0aGUgd29yayBpcyBwZXJmb3JtZWRcbiAgICAgICAqIG9ubHkgb25jZSBmb3IgdGhlIGNsYXNzLlxuICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICovXG4gICAgICBfcmVnaXN0ZXJlZCgpIHt9XG5cbiAgICAgIC8qKlxuICAgICAgICogT3ZlcnJpZGVzIHRoZSBkZWZhdWx0IGBQb2x5bWVyLlByb3BlcnR5RWZmZWN0c2AgaW1wbGVtZW50YXRpb24gdG9cbiAgICAgICAqIGFkZCBzdXBwb3J0IGZvciBpbnN0YWxsaW5nIGBob3N0QXR0cmlidXRlc2AgYW5kIGBsaXN0ZW5lcnNgLlxuICAgICAgICpcbiAgICAgICAqIEBvdmVycmlkZVxuICAgICAgICovXG4gICAgICByZWFkeSgpIHtcbiAgICAgICAgdGhpcy5fZW5zdXJlQXR0cmlidXRlcygpO1xuICAgICAgICB0aGlzLl9hcHBseUxpc3RlbmVycygpO1xuICAgICAgICBzdXBlci5yZWFkeSgpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEVuc3VyZXMgYW4gZWxlbWVudCBoYXMgcmVxdWlyZWQgYXR0cmlidXRlcy4gQ2FsbGVkIHdoZW4gdGhlIGVsZW1lbnRcbiAgICAgICAqIGlzIGJlaW5nIHJlYWRpZWQgdmlhIGByZWFkeWAuIFVzZXJzIHNob3VsZCBvdmVycmlkZSB0byBzZXQgdGhlXG4gICAgICAgKiBlbGVtZW50J3MgcmVxdWlyZWQgYXR0cmlidXRlcy4gVGhlIGltcGxlbWVudGF0aW9uIHNob3VsZCBiZSBzdXJlXG4gICAgICAgKiB0byBjaGVjayBhbmQgbm90IG92ZXJyaWRlIGV4aXN0aW5nIGF0dHJpYnV0ZXMgYWRkZWQgYnlcbiAgICAgICAqIHRoZSB1c2VyIG9mIHRoZSBlbGVtZW50LiBUeXBpY2FsbHksIHNldHRpbmcgYXR0cmlidXRlcyBzaG91bGQgYmUgbGVmdFxuICAgICAgICogdG8gdGhlIGVsZW1lbnQgdXNlciBhbmQgbm90IGRvbmUgaGVyZTsgcmVhc29uYWJsZSBleGNlcHRpb25zIGluY2x1ZGVcbiAgICAgICAqIHNldHRpbmcgYXJpYSByb2xlcyBhbmQgZm9jdXNhYmlsaXR5LlxuICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICovXG4gICAgICBfZW5zdXJlQXR0cmlidXRlcygpIHt9XG5cbiAgICAgIC8qKlxuICAgICAgICogQWRkcyBlbGVtZW50IGV2ZW50IGxpc3RlbmVycy4gQ2FsbGVkIHdoZW4gdGhlIGVsZW1lbnRcbiAgICAgICAqIGlzIGJlaW5nIHJlYWRpZWQgdmlhIGByZWFkeWAuIFVzZXJzIHNob3VsZCBvdmVycmlkZSB0b1xuICAgICAgICogYWRkIGFueSByZXF1aXJlZCBlbGVtZW50IGV2ZW50IGxpc3RlbmVycy5cbiAgICAgICAqIEluIHBlcmZvcm1hbmNlIGNyaXRpY2FsIGVsZW1lbnRzLCB0aGUgd29yayBkb25lIGhlcmUgc2hvdWxkIGJlIGtlcHRcbiAgICAgICAqIHRvIGEgbWluaW11bSBzaW5jZSBpdCBpcyBkb25lIGJlZm9yZSB0aGUgZWxlbWVudCBpcyByZW5kZXJlZC4gSW5cbiAgICAgICAqIHRoZXNlIGVsZW1lbnRzLCBjb25zaWRlciBhZGRpbmcgbGlzdGVuZXJzIGFzeWNocm9ub3VzbHkgc28gYXMgbm90IHRvXG4gICAgICAgKiBibG9jayByZW5kZXIuXG4gICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgKi9cbiAgICAgIF9hcHBseUxpc3RlbmVycygpIHt9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ29udmVydHMgYSB0eXBlZCBKYXZhU2NyaXB0IHZhbHVlIHRvIGEgc3RyaW5nLlxuICAgICAgICpcbiAgICAgICAqIE5vdGUgdGhpcyBtZXRob2QgaXMgcHJvdmlkZWQgYXMgYmFja3dhcmQtY29tcGF0aWJsZSBsZWdhY3kgQVBJXG4gICAgICAgKiBvbmx5LiAgSXQgaXMgbm90IGRpcmVjdGx5IGNhbGxlZCBieSBhbnkgUG9seW1lciBmZWF0dXJlcy4gVG8gY3VzdG9taXplXG4gICAgICAgKiBob3cgcHJvcGVydGllcyBhcmUgc2VyaWFsaXplZCB0byBhdHRyaWJ1dGVzIGZvciBhdHRyaWJ1dGUgYmluZGluZ3MgYW5kXG4gICAgICAgKiBgcmVmbGVjdFRvQXR0cmlidXRlOiB0cnVlYCBwcm9wZXJ0aWVzIGFzIHdlbGwgYXMgdGhpcyBtZXRob2QsIG92ZXJyaWRlXG4gICAgICAgKiB0aGUgYF9zZXJpYWxpemVWYWx1ZWAgbWV0aG9kIHByb3ZpZGVkIGJ5IGBQb2x5bWVyLlByb3BlcnR5QWNjZXNzb3JzYC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIGRlc2VyaWFsaXplXG4gICAgICAgKiBAcmV0dXJuIHtzdHJpbmcgfCB1bmRlZmluZWR9IFNlcmlhbGl6ZWQgdmFsdWVcbiAgICAgICAqL1xuICAgICAgc2VyaWFsaXplKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZXJpYWxpemVWYWx1ZSh2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ29udmVydHMgYSBzdHJpbmcgdG8gYSB0eXBlZCBKYXZhU2NyaXB0IHZhbHVlLlxuICAgICAgICpcbiAgICAgICAqIE5vdGUgdGhpcyBtZXRob2QgaXMgcHJvdmlkZWQgYXMgYmFja3dhcmQtY29tcGF0aWJsZSBsZWdhY3kgQVBJXG4gICAgICAgKiBvbmx5LiAgSXQgaXMgbm90IGRpcmVjdGx5IGNhbGxlZCBieSBhbnkgUG9seW1lciBmZWF0dXJlcy4gIFRvIGN1c3RvbWl6ZVxuICAgICAgICogaG93IGF0dHJpYnV0ZXMgYXJlIGRlc2VyaWFsaXplZCB0byBwcm9wZXJ0aWVzIGZvciBpblxuICAgICAgICogYGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFja2AsIG92ZXJyaWRlIGBfZGVzZXJpYWxpemVWYWx1ZWAgbWV0aG9kXG4gICAgICAgKiBwcm92aWRlZCBieSBgUG9seW1lci5Qcm9wZXJ0eUFjY2Vzc29yc2AuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIFN0cmluZyB0byBkZXNlcmlhbGl6ZVxuICAgICAgICogQHBhcmFtIHsqfSB0eXBlIFR5cGUgdG8gZGVzZXJpYWxpemUgdGhlIHN0cmluZyB0b1xuICAgICAgICogQHJldHVybiB7Kn0gUmV0dXJucyB0aGUgZGVzZXJpYWxpemVkIHZhbHVlIGluIHRoZSBgdHlwZWAgZ2l2ZW4uXG4gICAgICAgKi9cbiAgICAgIGRlc2VyaWFsaXplKHZhbHVlLCB0eXBlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZXNlcmlhbGl6ZVZhbHVlKHZhbHVlLCB0eXBlKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBTZXJpYWxpemVzIGEgcHJvcGVydHkgdG8gaXRzIGFzc29jaWF0ZWQgYXR0cmlidXRlLlxuICAgICAgICpcbiAgICAgICAqIE5vdGUgdGhpcyBtZXRob2QgaXMgcHJvdmlkZWQgYXMgYmFja3dhcmQtY29tcGF0aWJsZSBsZWdhY3kgQVBJXG4gICAgICAgKiBvbmx5LiAgSXQgaXMgbm90IGRpcmVjdGx5IGNhbGxlZCBieSBhbnkgUG9seW1lciBmZWF0dXJlcy5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgbmFtZSB0byByZWZsZWN0LlxuICAgICAgICogQHBhcmFtIHtzdHJpbmc9fSBhdHRyaWJ1dGUgQXR0cmlidXRlIG5hbWUgdG8gcmVmbGVjdC5cbiAgICAgICAqIEBwYXJhbSB7Kj19IHZhbHVlIFByb3BlcnR5IHZhbHVlIHRvIHJlZmVjdC5cbiAgICAgICAqL1xuICAgICAgcmVmbGVjdFByb3BlcnR5VG9BdHRyaWJ1dGUocHJvcGVydHksIGF0dHJpYnV0ZSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5fcHJvcGVydHlUb0F0dHJpYnV0ZShwcm9wZXJ0eSwgYXR0cmlidXRlLCB2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogU2V0cyBhIHR5cGVkIHZhbHVlIHRvIGFuIEhUTUwgYXR0cmlidXRlIG9uIGEgbm9kZS5cbiAgICAgICAqXG4gICAgICAgKiBOb3RlIHRoaXMgbWV0aG9kIGlzIHByb3ZpZGVkIGFzIGJhY2t3YXJkLWNvbXBhdGlibGUgbGVnYWN5IEFQSVxuICAgICAgICogb25seS4gIEl0IGlzIG5vdCBkaXJlY3RseSBjYWxsZWQgYnkgYW55IFBvbHltZXIgZmVhdHVyZXMuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byBzZXJpYWxpemUuXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlIEF0dHJpYnV0ZSBuYW1lIHRvIHNlcmlhbGl6ZSB0by5cbiAgICAgICAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZSBFbGVtZW50IHRvIHNldCBhdHRyaWJ1dGUgdG8uXG4gICAgICAgKi9cbiAgICAgIHNlcmlhbGl6ZVZhbHVlVG9BdHRyaWJ1dGUodmFsdWUsIGF0dHJpYnV0ZSwgbm9kZSkge1xuICAgICAgICB0aGlzLl92YWx1ZVRvTm9kZUF0dHJpYnV0ZSgvKiogQHR5cGUge0VsZW1lbnR9ICovIChub2RlIHx8IHRoaXMpLCB2YWx1ZSwgYXR0cmlidXRlKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDb3BpZXMgb3duIHByb3BlcnRpZXMgKGluY2x1ZGluZyBhY2Nlc3NvciBkZXNjcmlwdG9ycykgZnJvbSBhIHNvdXJjZVxuICAgICAgICogb2JqZWN0IHRvIGEgdGFyZ2V0IG9iamVjdC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvdG90eXBlIFRhcmdldCBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIHRvLlxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IGFwaSBTb3VyY2Ugb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tLlxuICAgICAgICogQHJldHVybiB7T2JqZWN0fSBwcm90b3R5cGUgb2JqZWN0IHRoYXQgd2FzIHBhc3NlZCBhcyBmaXJzdCBhcmd1bWVudC5cbiAgICAgICAqL1xuICAgICAgZXh0ZW5kKHByb3RvdHlwZSwgYXBpKSB7XG4gICAgICAgIGlmICghKHByb3RvdHlwZSAmJiBhcGkpKSB7XG4gICAgICAgICAgcmV0dXJuIHByb3RvdHlwZSB8fCBhcGk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG4kID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYXBpKTtcbiAgICAgICAgZm9yIChsZXQgaT0wLCBuOyAoaTxuJC5sZW5ndGgpICYmIChuPW4kW2ldKTsgaSsrKSB7XG4gICAgICAgICAgbGV0IHBkID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihhcGksIG4pO1xuICAgICAgICAgIGlmIChwZCkge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvdHlwZSwgbiwgcGQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJvdG90eXBlO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENvcGllcyBwcm9wcyBmcm9tIGEgc291cmNlIG9iamVjdCB0byBhIHRhcmdldCBvYmplY3QuXG4gICAgICAgKlxuICAgICAgICogTm90ZSwgdGhpcyBtZXRob2QgdXNlcyBhIHNpbXBsZSBgZm9yLi4uaW5gIHN0cmF0ZWd5IGZvciBlbnVtZXJhdGluZ1xuICAgICAgICogcHJvcGVydGllcy4gIFRvIGVuc3VyZSBvbmx5IGBvd25Qcm9wZXJ0aWVzYCBhcmUgY29waWVkIGZyb20gc291cmNlXG4gICAgICAgKiB0byB0YXJnZXQgYW5kIHRoYXQgYWNjZXNzb3IgaW1wbGVtZW50YXRpb25zIGFyZSBjb3BpZWQsIHVzZSBgZXh0ZW5kYC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IFRhcmdldCBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIHRvLlxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBTb3VyY2Ugb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tLlxuICAgICAgICogQHJldHVybiB7T2JqZWN0fSBUYXJnZXQgb2JqZWN0IHRoYXQgd2FzIHBhc3NlZCBhcyBmaXJzdCBhcmd1bWVudC5cbiAgICAgICAqL1xuICAgICAgbWl4aW4odGFyZ2V0LCBzb3VyY2UpIHtcbiAgICAgICAgZm9yIChsZXQgaSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICB0YXJnZXRbaV0gPSBzb3VyY2VbaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBTZXRzIHRoZSBwcm90b3R5cGUgb2YgYW4gb2JqZWN0LlxuICAgICAgICpcbiAgICAgICAqIE5vdGUgdGhpcyBtZXRob2QgaXMgcHJvdmlkZWQgYXMgYmFja3dhcmQtY29tcGF0aWJsZSBsZWdhY3kgQVBJXG4gICAgICAgKiBvbmx5LiAgSXQgaXMgbm90IGRpcmVjdGx5IGNhbGxlZCBieSBhbnkgUG9seW1lciBmZWF0dXJlcy5cbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCBvbiB3aGljaCB0byBzZXQgdGhlIHByb3RvdHlwZS5cbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm90b3R5cGUgVGhlIHByb3RvdHlwZSB0aGF0IHdpbGwgYmUgc2V0IG9uIHRoZSBnaXZlblxuICAgICAgICogYG9iamVjdGAuXG4gICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFJldHVybnMgdGhlIGdpdmVuIGBvYmplY3RgIHdpdGggaXRzIHByb3RvdHlwZSBzZXRcbiAgICAgICAqIHRvIHRoZSBnaXZlbiBgcHJvdG90eXBlYCBvYmplY3QuXG4gICAgICAgKi9cbiAgICAgIGNoYWluT2JqZWN0KG9iamVjdCwgcHJvdG90eXBlKSB7XG4gICAgICAgIGlmIChvYmplY3QgJiYgcHJvdG90eXBlICYmIG9iamVjdCAhPT0gcHJvdG90eXBlKSB7XG4gICAgICAgICAgb2JqZWN0Ll9fcHJvdG9fXyA9IHByb3RvdHlwZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgfVxuXG4gICAgICAvKiAqKioqIEJlZ2luIFRlbXBsYXRlICoqKiogKi9cblxuICAgICAgLyoqXG4gICAgICAgKiBDYWxscyBgaW1wb3J0Tm9kZWAgb24gdGhlIGBjb250ZW50YCBvZiB0aGUgYHRlbXBsYXRlYCBzcGVjaWZpZWQgYW5kXG4gICAgICAgKiByZXR1cm5zIGEgZG9jdW1lbnQgZnJhZ21lbnQgY29udGFpbmluZyB0aGUgaW1wb3J0ZWQgY29udGVudC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge0hUTUxUZW1wbGF0ZUVsZW1lbnR9IHRlbXBsYXRlIEhUTUwgdGVtcGxhdGUgZWxlbWVudCB0byBpbnN0YW5jZS5cbiAgICAgICAqIEByZXR1cm4ge0RvY3VtZW50RnJhZ21lbnR9IERvY3VtZW50IGZyYWdtZW50IGNvbnRhaW5pbmcgdGhlIGltcG9ydGVkXG4gICAgICAgKiAgIHRlbXBsYXRlIGNvbnRlbnQuXG4gICAgICAqL1xuICAgICAgaW5zdGFuY2VUZW1wbGF0ZSh0ZW1wbGF0ZSkge1xuICAgICAgICBsZXQgY29udGVudCA9IHRoaXMuY29uc3RydWN0b3IuX2NvbnRlbnRGb3JUZW1wbGF0ZSh0ZW1wbGF0ZSk7XG4gICAgICAgIGxldCBkb20gPSAvKiogQHR5cGUge0RvY3VtZW50RnJhZ21lbnR9ICovXG4gICAgICAgICAgKGRvY3VtZW50LmltcG9ydE5vZGUoY29udGVudCwgdHJ1ZSkpO1xuICAgICAgICByZXR1cm4gZG9tO1xuICAgICAgfVxuXG4gICAgICAvKiAqKioqIEJlZ2luIEV2ZW50cyAqKioqICovXG5cblxuXG4gICAgICAvKipcbiAgICAgICAqIERpc3BhdGNoZXMgYSBjdXN0b20gZXZlbnQgd2l0aCBhbiBvcHRpb25hbCBkZXRhaWwgdmFsdWUuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgTmFtZSBvZiBldmVudCB0eXBlLlxuICAgICAgICogQHBhcmFtIHsqPX0gZGV0YWlsIERldGFpbCB2YWx1ZSBjb250YWluaW5nIGV2ZW50LXNwZWNpZmljXG4gICAgICAgKiAgIHBheWxvYWQuXG4gICAgICAgKiBAcGFyYW0ge3sgYnViYmxlczogKGJvb2xlYW58dW5kZWZpbmVkKSwgY2FuY2VsYWJsZTogKGJvb2xlYW58dW5kZWZpbmVkKSwgY29tcG9zZWQ6IChib29sZWFufHVuZGVmaW5lZCkgfT19XG4gICAgICAgKiAgb3B0aW9ucyBPYmplY3Qgc3BlY2lmeWluZyBvcHRpb25zLiAgVGhlc2UgbWF5IGluY2x1ZGU6XG4gICAgICAgKiAgYGJ1YmJsZXNgIChib29sZWFuLCBkZWZhdWx0cyB0byBgdHJ1ZWApLFxuICAgICAgICogIGBjYW5jZWxhYmxlYCAoYm9vbGVhbiwgZGVmYXVsdHMgdG8gZmFsc2UpLCBhbmRcbiAgICAgICAqICBgbm9kZWAgb24gd2hpY2ggdG8gZmlyZSB0aGUgZXZlbnQgKEhUTUxFbGVtZW50LCBkZWZhdWx0cyB0byBgdGhpc2ApLlxuICAgICAgICogQHJldHVybiB7RXZlbnR9IFRoZSBuZXcgZXZlbnQgdGhhdCB3YXMgZmlyZWQuXG4gICAgICAgKi9cbiAgICAgIGZpcmUodHlwZSwgZGV0YWlsLCBvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICBkZXRhaWwgPSAoZGV0YWlsID09PSBudWxsIHx8IGRldGFpbCA9PT0gdW5kZWZpbmVkKSA/IHt9IDogZGV0YWlsO1xuICAgICAgICBsZXQgZXZlbnQgPSBuZXcgRXZlbnQodHlwZSwge1xuICAgICAgICAgIGJ1YmJsZXM6IG9wdGlvbnMuYnViYmxlcyA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IG9wdGlvbnMuYnViYmxlcyxcbiAgICAgICAgICBjYW5jZWxhYmxlOiBCb29sZWFuKG9wdGlvbnMuY2FuY2VsYWJsZSksXG4gICAgICAgICAgY29tcG9zZWQ6IG9wdGlvbnMuY29tcG9zZWQgPT09IHVuZGVmaW5lZCA/IHRydWU6IG9wdGlvbnMuY29tcG9zZWRcbiAgICAgICAgfSk7XG4gICAgICAgIGV2ZW50LmRldGFpbCA9IGRldGFpbDtcbiAgICAgICAgbGV0IG5vZGUgPSBvcHRpb25zLm5vZGUgfHwgdGhpcztcbiAgICAgICAgbm9kZS5kaXNwYXRjaEV2ZW50KGV2ZW50KVxuICAgICAgICByZXR1cm4gZXZlbnQ7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ29udmVuaWVuY2UgbWV0aG9kIHRvIGFkZCBhbiBldmVudCBsaXN0ZW5lciBvbiBhIGdpdmVuIGVsZW1lbnQsXG4gICAgICAgKiBsYXRlIGJvdW5kIHRvIGEgbmFtZWQgbWV0aG9kIG9uIHRoaXMgZWxlbWVudC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgRWxlbWVudCB0byBhZGQgZXZlbnQgbGlzdGVuZXIgdG8uXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIE5hbWUgb2YgZXZlbnQgdG8gbGlzdGVuIGZvci5cbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2ROYW1lIE5hbWUgb2YgaGFuZGxlciBtZXRob2Qgb24gYHRoaXNgIHRvIGNhbGwuXG4gICAgICAgKi9cbiAgICAgIGxpc3Rlbihub2RlLCBldmVudE5hbWUsIG1ldGhvZE5hbWUpIHtcbiAgICAgICAgbm9kZSA9IC8qKiBAdHlwZSB7RWxlbWVudH0gKi8gKG5vZGUgfHwgdGhpcyk7XG4gICAgICAgIGxldCBoYmwgPSB0aGlzLl9fYm91bmRMaXN0ZW5lcnMgfHxcbiAgICAgICAgICAodGhpcy5fX2JvdW5kTGlzdGVuZXJzID0gbmV3IFdlYWtNYXAoKSk7XG4gICAgICAgIGxldCBibCA9IGhibC5nZXQobm9kZSk7XG4gICAgICAgIGlmICghYmwpIHtcbiAgICAgICAgICBibCA9IHt9O1xuICAgICAgICAgIGhibC5zZXQobm9kZSwgYmwpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBrZXkgPSBldmVudE5hbWUgKyBtZXRob2ROYW1lO1xuICAgICAgICBpZiAoIWJsW2tleV0pIHtcbiAgICAgICAgICBibFtrZXldID0gdGhpcy5fYWRkTWV0aG9kRXZlbnRMaXN0ZW5lclRvTm9kZShcbiAgICAgICAgICAgIG5vZGUsIGV2ZW50TmFtZSwgbWV0aG9kTmFtZSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDb252ZW5pZW5jZSBtZXRob2QgdG8gcmVtb3ZlIGFuIGV2ZW50IGxpc3RlbmVyIGZyb20gYSBnaXZlbiBlbGVtZW50LFxuICAgICAgICogbGF0ZSBib3VuZCB0byBhIG5hbWVkIG1ldGhvZCBvbiB0aGlzIGVsZW1lbnQuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtFbGVtZW50fSBub2RlIEVsZW1lbnQgdG8gcmVtb3ZlIGV2ZW50IGxpc3RlbmVyIGZyb20uXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIE5hbWUgb2YgZXZlbnQgdG8gc3RvcCBsaXN0ZW5pbmcgdG8uXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kTmFtZSBOYW1lIG9mIGhhbmRsZXIgbWV0aG9kIG9uIGB0aGlzYCB0byBub3QgY2FsbFxuICAgICAgIGFueW1vcmUuXG4gICAgICAgKi9cbiAgICAgIHVubGlzdGVuKG5vZGUsIGV2ZW50TmFtZSwgbWV0aG9kTmFtZSkge1xuICAgICAgICBub2RlID0gLyoqIEB0eXBlIHtFbGVtZW50fSAqLyAobm9kZSB8fCB0aGlzKTtcbiAgICAgICAgbGV0IGJsID0gdGhpcy5fX2JvdW5kTGlzdGVuZXJzICYmIHRoaXMuX19ib3VuZExpc3RlbmVycy5nZXQobm9kZSk7XG4gICAgICAgIGxldCBrZXkgPSBldmVudE5hbWUgKyBtZXRob2ROYW1lO1xuICAgICAgICBsZXQgaGFuZGxlciA9IGJsICYmIGJsW2tleV07XG4gICAgICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICAgICAgdGhpcy5fcmVtb3ZlRXZlbnRMaXN0ZW5lckZyb21Ob2RlKG5vZGUsIGV2ZW50TmFtZSwgaGFuZGxlcik7XG4gICAgICAgICAgYmxba2V5XSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBPdmVycmlkZSBzY3JvbGxpbmcgYmVoYXZpb3IgdG8gYWxsIGRpcmVjdGlvbiwgb25lIGRpcmVjdGlvbiwgb3Igbm9uZS5cbiAgICAgICAqXG4gICAgICAgKiBWYWxpZCBzY3JvbGwgZGlyZWN0aW9uczpcbiAgICAgICAqICAgLSAnYWxsJzogc2Nyb2xsIGluIGFueSBkaXJlY3Rpb25cbiAgICAgICAqICAgLSAneCc6IHNjcm9sbCBvbmx5IGluIHRoZSAneCcgZGlyZWN0aW9uXG4gICAgICAgKiAgIC0gJ3knOiBzY3JvbGwgb25seSBpbiB0aGUgJ3knIGRpcmVjdGlvblxuICAgICAgICogICAtICdub25lJzogZGlzYWJsZSBzY3JvbGxpbmcgZm9yIHRoaXMgbm9kZVxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nPX0gZGlyZWN0aW9uIERpcmVjdGlvbiB0byBhbGxvdyBzY3JvbGxpbmdcbiAgICAgICAqIERlZmF1bHRzIHRvIGBhbGxgLlxuICAgICAgICogQHBhcmFtIHtFbGVtZW50PX0gbm9kZSBFbGVtZW50IHRvIGFwcGx5IHNjcm9sbCBkaXJlY3Rpb24gc2V0dGluZy5cbiAgICAgICAqIERlZmF1bHRzIHRvIGB0aGlzYC5cbiAgICAgICAqL1xuICAgICAgc2V0U2Nyb2xsRGlyZWN0aW9uKGRpcmVjdGlvbiwgbm9kZSkge1xuICAgICAgICBQb2x5bWVyLkdlc3R1cmVzLnNldFRvdWNoQWN0aW9uKC8qKiBAdHlwZSB7RWxlbWVudH0gKi8gKG5vZGUgfHwgdGhpcyksIERJUkVDVElPTl9NQVBbZGlyZWN0aW9uXSB8fCAnYXV0bycpO1xuICAgICAgfVxuICAgICAgLyogKioqKiBFbmQgRXZlbnRzICoqKiogKi9cblxuICAgICAgLyoqXG4gICAgICAgKiBDb252ZW5pZW5jZSBtZXRob2QgdG8gcnVuIGBxdWVyeVNlbGVjdG9yYCBvbiB0aGlzIGxvY2FsIERPTSBzY29wZS5cbiAgICAgICAqXG4gICAgICAgKiBUaGlzIGZ1bmN0aW9uIGNhbGxzIGBQb2x5bWVyLmRvbSh0aGlzLnJvb3QpLnF1ZXJ5U2VsZWN0b3Ioc2xjdHIpYC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2xjdHIgU2VsZWN0b3IgdG8gcnVuIG9uIHRoaXMgbG9jYWwgRE9NIHNjb3BlXG4gICAgICAgKiBAcmV0dXJuIHtFbGVtZW50fSBFbGVtZW50IGZvdW5kIGJ5IHRoZSBzZWxlY3Rvciwgb3IgbnVsbCBpZiBub3QgZm91bmQuXG4gICAgICAgKi9cbiAgICAgICQkKHNsY3RyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvb3QucXVlcnlTZWxlY3RvcihzbGN0cik7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUmV0dXJuIHRoZSBlbGVtZW50IHdob3NlIGxvY2FsIGRvbSB3aXRoaW4gd2hpY2ggdGhpcyBlbGVtZW50XG4gICAgICAgKiBpcyBjb250YWluZWQuIFRoaXMgaXMgYSBzaG9ydGhhbmQgZm9yXG4gICAgICAgKiBgdGhpcy5nZXRSb290Tm9kZSgpLmhvc3RgLlxuICAgICAgICogQHRoaXMge0VsZW1lbnR9XG4gICAgICAgKi9cbiAgICAgIGdldCBkb21Ib3N0KCkge1xuICAgICAgICBsZXQgcm9vdCA9IHRoaXMuZ2V0Um9vdE5vZGUoKTtcbiAgICAgICAgcmV0dXJuIChyb290IGluc3RhbmNlb2YgRG9jdW1lbnRGcmFnbWVudCkgPyAvKiogQHR5cGUge1NoYWRvd1Jvb3R9ICovIChyb290KS5ob3N0IDogcm9vdDtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBGb3JjZSB0aGlzIGVsZW1lbnQgdG8gZGlzdHJpYnV0ZSBpdHMgY2hpbGRyZW4gdG8gaXRzIGxvY2FsIGRvbS5cbiAgICAgICAqIFRoaXMgc2hvdWxkIG5vdCBiZSBuZWNlc3NhcnkgYXMgb2YgUG9seW1lciAyLjAuMiBhbmQgaXMgcHJvdmlkZWQgb25seVxuICAgICAgICogZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuICAgICAgICovXG4gICAgICBkaXN0cmlidXRlQ29udGVudCgpIHtcbiAgICAgICAgaWYgKHdpbmRvdy5TaGFkeURPTSAmJiB0aGlzLnNoYWRvd1Jvb3QpIHtcbiAgICAgICAgICBTaGFkeURPTS5mbHVzaCgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUmV0dXJucyBhIGxpc3Qgb2Ygbm9kZXMgdGhhdCBhcmUgdGhlIGVmZmVjdGl2ZSBjaGlsZE5vZGVzLiBUaGUgZWZmZWN0aXZlXG4gICAgICAgKiBjaGlsZE5vZGVzIGxpc3QgaXMgdGhlIHNhbWUgYXMgdGhlIGVsZW1lbnQncyBjaGlsZE5vZGVzIGV4Y2VwdCB0aGF0XG4gICAgICAgKiBhbnkgYDxjb250ZW50PmAgZWxlbWVudHMgYXJlIHJlcGxhY2VkIHdpdGggdGhlIGxpc3Qgb2Ygbm9kZXMgZGlzdHJpYnV0ZWRcbiAgICAgICAqIHRvIHRoZSBgPGNvbnRlbnQ+YCwgdGhlIHJlc3VsdCBvZiBpdHMgYGdldERpc3RyaWJ1dGVkTm9kZXNgIG1ldGhvZC5cbiAgICAgICAqIEB0aGlzIHtFbGVtZW50fVxuICAgICAgICogQHJldHVybiB7QXJyYXk8Tm9kZT59IExpc3Qgb2YgZWZmY3RpdmUgY2hpbGQgbm9kZXMuXG4gICAgICAgKi9cbiAgICAgIGdldEVmZmVjdGl2ZUNoaWxkTm9kZXMoKSB7XG4gICAgICAgIHJldHVybiAvKiogQHR5cGUge1BvbHltZXIuRG9tQXBpfSAqLyAoUG9seW1lci5kb20odGhpcykpLmdldEVmZmVjdGl2ZUNoaWxkTm9kZXMoKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBub2RlcyBkaXN0cmlidXRlZCB3aXRoaW4gdGhpcyBlbGVtZW50IHRoYXQgbWF0Y2hcbiAgICAgICAqIGBzZWxlY3RvcmAuIFRoZXNlIGNhbiBiZSBkb20gY2hpbGRyZW4gb3IgZWxlbWVudHMgZGlzdHJpYnV0ZWQgdG9cbiAgICAgICAqIGNoaWxkcmVuIHRoYXQgYXJlIGluc2VydGlvbiBwb2ludHMuXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3IgU2VsZWN0b3IgdG8gcnVuLlxuICAgICAgICogQHRoaXMge0VsZW1lbnR9XG4gICAgICAgKiBAcmV0dXJuIHtBcnJheTxOb2RlPn0gTGlzdCBvZiBkaXN0cmlidXRlZCBlbGVtZW50cyB0aGF0IG1hdGNoIHNlbGVjdG9yLlxuICAgICAgICovXG4gICAgICBxdWVyeURpc3RyaWJ1dGVkRWxlbWVudHMoc2VsZWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIC8qKiBAdHlwZSB7UG9seW1lci5Eb21BcGl9ICovIChQb2x5bWVyLmRvbSh0aGlzKSkucXVlcnlEaXN0cmlidXRlZEVsZW1lbnRzKHNlbGVjdG9yKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBlbGVtZW50cyB0aGF0IGFyZSB0aGUgZWZmZWN0aXZlIGNoaWxkcmVuLiBUaGUgZWZmZWN0aXZlXG4gICAgICAgKiBjaGlsZHJlbiBsaXN0IGlzIHRoZSBzYW1lIGFzIHRoZSBlbGVtZW50J3MgY2hpbGRyZW4gZXhjZXB0IHRoYXRcbiAgICAgICAqIGFueSBgPGNvbnRlbnQ+YCBlbGVtZW50cyBhcmUgcmVwbGFjZWQgd2l0aCB0aGUgbGlzdCBvZiBlbGVtZW50c1xuICAgICAgICogZGlzdHJpYnV0ZWQgdG8gdGhlIGA8Y29udGVudD5gLlxuICAgICAgICpcbiAgICAgICAqIEByZXR1cm4ge0FycmF5PE5vZGU+fSBMaXN0IG9mIGVmZmN0aXZlIGNoaWxkcmVuLlxuICAgICAgICovXG4gICAgICBnZXRFZmZlY3RpdmVDaGlsZHJlbigpIHtcbiAgICAgICAgbGV0IGxpc3QgPSB0aGlzLmdldEVmZmVjdGl2ZUNoaWxkTm9kZXMoKTtcbiAgICAgICAgcmV0dXJuIGxpc3QuZmlsdGVyKGZ1bmN0aW9uKC8qKiBAdHlwZSB7Tm9kZX0gKi8gbikge1xuICAgICAgICAgIHJldHVybiAobi5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIG9mIHRleHQgY29udGVudCB0aGF0IGlzIHRoZSBjb25jYXRlbmF0aW9uIG9mIHRoZVxuICAgICAgICogdGV4dCBjb250ZW50J3Mgb2YgdGhlIGVsZW1lbnQncyBlZmZlY3RpdmUgY2hpbGROb2RlcyAodGhlIGVsZW1lbnRzXG4gICAgICAgKiByZXR1cm5lZCBieSA8YSBocmVmPVwiI2dldEVmZmVjdGl2ZUNoaWxkTm9kZXM+Z2V0RWZmZWN0aXZlQ2hpbGROb2RlczwvYT4uXG4gICAgICAgKlxuICAgICAgICogQHJldHVybiB7c3RyaW5nfSBMaXN0IG9mIGVmZmN0aXZlIGNoaWxkcmVuLlxuICAgICAgICovXG4gICAgICBnZXRFZmZlY3RpdmVUZXh0Q29udGVudCgpIHtcbiAgICAgICAgbGV0IGNuID0gdGhpcy5nZXRFZmZlY3RpdmVDaGlsZE5vZGVzKCk7XG4gICAgICAgIGxldCB0YyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpPTAsIGM7IChjID0gY25baV0pOyBpKyspIHtcbiAgICAgICAgICBpZiAoYy5ub2RlVHlwZSAhPT0gTm9kZS5DT01NRU5UX05PREUpIHtcbiAgICAgICAgICAgIHRjLnB1c2goYy50ZXh0Q29udGVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0Yy5qb2luKCcnKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZXR1cm5zIHRoZSBmaXJzdCBlZmZlY3RpdmUgY2hpbGROb2RlIHdpdGhpbiB0aGlzIGVsZW1lbnQgdGhhdFxuICAgICAgICogbWF0Y2ggYHNlbGVjdG9yYC4gVGhlc2UgY2FuIGJlIGRvbSBjaGlsZCBub2RlcyBvciBlbGVtZW50cyBkaXN0cmlidXRlZFxuICAgICAgICogdG8gY2hpbGRyZW4gdGhhdCBhcmUgaW5zZXJ0aW9uIHBvaW50cy5cbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzZWxlY3RvciBTZWxlY3RvciB0byBydW4uXG4gICAgICAgKiBAcmV0dXJuIHtPYmplY3Q8Tm9kZT59IEZpcnN0IGVmZmVjdGl2ZSBjaGlsZCBub2RlIHRoYXQgbWF0Y2hlcyBzZWxlY3Rvci5cbiAgICAgICAqL1xuICAgICAgcXVlcnlFZmZlY3RpdmVDaGlsZHJlbihzZWxlY3Rvcikge1xuICAgICAgICBsZXQgZSQgPSB0aGlzLnF1ZXJ5RGlzdHJpYnV0ZWRFbGVtZW50cyhzZWxlY3Rvcik7XG4gICAgICAgIHJldHVybiBlJCAmJiBlJFswXTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBlZmZlY3RpdmUgY2hpbGROb2RlcyB3aXRoaW4gdGhpcyBlbGVtZW50IHRoYXRcbiAgICAgICAqIG1hdGNoIGBzZWxlY3RvcmAuIFRoZXNlIGNhbiBiZSBkb20gY2hpbGQgbm9kZXMgb3IgZWxlbWVudHMgZGlzdHJpYnV0ZWRcbiAgICAgICAqIHRvIGNoaWxkcmVuIHRoYXQgYXJlIGluc2VydGlvbiBwb2ludHMuXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3IgU2VsZWN0b3IgdG8gcnVuLlxuICAgICAgICogQHJldHVybiB7QXJyYXk8Tm9kZT59IExpc3Qgb2YgZWZmZWN0aXZlIGNoaWxkIG5vZGVzIHRoYXQgbWF0Y2ggc2VsZWN0b3IuXG4gICAgICAgKi9cbiAgICAgIHF1ZXJ5QWxsRWZmZWN0aXZlQ2hpbGRyZW4oc2VsZWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucXVlcnlEaXN0cmlidXRlZEVsZW1lbnRzKHNlbGVjdG9yKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBub2RlcyBkaXN0cmlidXRlZCB0byB0aGlzIGVsZW1lbnQncyBgPHNsb3Q+YC5cbiAgICAgICAqXG4gICAgICAgKiBJZiB0aGlzIGVsZW1lbnQgY29udGFpbnMgbW9yZSB0aGFuIG9uZSBgPHNsb3Q+YCBpbiBpdHMgbG9jYWwgRE9NLFxuICAgICAgICogYW4gb3B0aW9uYWwgc2VsZWN0b3IgbWF5IGJlIHBhc3NlZCB0byBjaG9vc2UgdGhlIGRlc2lyZWQgY29udGVudC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZz19IHNsY3RyIENTUyBzZWxlY3RvciB0byBjaG9vc2UgdGhlIGRlc2lyZWRcbiAgICAgICAqICAgYDxzbG90PmAuICBEZWZhdWx0cyB0byBgY29udGVudGAuXG4gICAgICAgKiBAcmV0dXJuIHtBcnJheTxOb2RlPn0gTGlzdCBvZiBkaXN0cmlidXRlZCBub2RlcyBmb3IgdGhlIGA8c2xvdD5gLlxuICAgICAgICovXG4gICAgICBnZXRDb250ZW50Q2hpbGROb2RlcyhzbGN0cikge1xuICAgICAgICBsZXQgY29udGVudCA9IHRoaXMucm9vdC5xdWVyeVNlbGVjdG9yKHNsY3RyIHx8ICdzbG90Jyk7XG4gICAgICAgIHJldHVybiBjb250ZW50ID8gLyoqIEB0eXBlIHtQb2x5bWVyLkRvbUFwaX0gKi8oUG9seW1lci5kb20oY29udGVudCkpLmdldERpc3RyaWJ1dGVkTm9kZXMoKSA6IFtdO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJldHVybnMgYSBsaXN0IG9mIGVsZW1lbnQgY2hpbGRyZW4gZGlzdHJpYnV0ZWQgdG8gdGhpcyBlbGVtZW50J3NcbiAgICAgICAqIGA8c2xvdD5gLlxuICAgICAgICpcbiAgICAgICAqIElmIHRoaXMgZWxlbWVudCBjb250YWlucyBtb3JlIHRoYW4gb25lIGA8c2xvdD5gIGluIGl0c1xuICAgICAgICogbG9jYWwgRE9NLCBhbiBvcHRpb25hbCBzZWxlY3RvciBtYXkgYmUgcGFzc2VkIHRvIGNob29zZSB0aGUgZGVzaXJlZFxuICAgICAgICogY29udGVudC4gIFRoaXMgbWV0aG9kIGRpZmZlcnMgZnJvbSBgZ2V0Q29udGVudENoaWxkTm9kZXNgIGluIHRoYXQgb25seVxuICAgICAgICogZWxlbWVudHMgYXJlIHJldHVybmVkLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nPX0gc2xjdHIgQ1NTIHNlbGVjdG9yIHRvIGNob29zZSB0aGUgZGVzaXJlZFxuICAgICAgICogICBgPGNvbnRlbnQ+YC4gIERlZmF1bHRzIHRvIGBjb250ZW50YC5cbiAgICAgICAqIEByZXR1cm4ge0FycmF5PEhUTUxFbGVtZW50Pn0gTGlzdCBvZiBkaXN0cmlidXRlZCBub2RlcyBmb3IgdGhlXG4gICAgICAgKiAgIGA8c2xvdD5gLlxuICAgICAgICogQHN1cHByZXNzIHtpbnZhbGlkQ2FzdHN9XG4gICAgICAgKi9cbiAgICAgIGdldENvbnRlbnRDaGlsZHJlbihzbGN0cikge1xuICAgICAgICByZXR1cm4gLyoqIEB0eXBlIHtBcnJheTxIVE1MRWxlbWVudD59ICovKHRoaXMuZ2V0Q29udGVudENoaWxkTm9kZXMoc2xjdHIpLmZpbHRlcihmdW5jdGlvbihuKSB7XG4gICAgICAgICAgcmV0dXJuIChuLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSk7XG4gICAgICAgIH0pKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDaGVja3Mgd2hldGhlciBhbiBlbGVtZW50IGlzIGluIHRoaXMgZWxlbWVudCdzIGxpZ2h0IERPTSB0cmVlLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7P05vZGV9IG5vZGUgVGhlIGVsZW1lbnQgdG8gYmUgY2hlY2tlZC5cbiAgICAgICAqIEB0aGlzIHtFbGVtZW50fVxuICAgICAgICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiBub2RlIGlzIGluIHRoaXMgZWxlbWVudCdzIGxpZ2h0IERPTSB0cmVlLlxuICAgICAgICovXG4gICAgICBpc0xpZ2h0RGVzY2VuZGFudChub2RlKSB7XG4gICAgICAgIHJldHVybiB0aGlzICE9PSBub2RlICYmIHRoaXMuY29udGFpbnMobm9kZSkgJiZcbiAgICAgICAgICAgIHRoaXMuZ2V0Um9vdE5vZGUoKSA9PT0gbm9kZS5nZXRSb290Tm9kZSgpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENoZWNrcyB3aGV0aGVyIGFuIGVsZW1lbnQgaXMgaW4gdGhpcyBlbGVtZW50J3MgbG9jYWwgRE9NIHRyZWUuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtFbGVtZW50PX0gbm9kZSBUaGUgZWxlbWVudCB0byBiZSBjaGVja2VkLlxuICAgICAgICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiBub2RlIGlzIGluIHRoaXMgZWxlbWVudCdzIGxvY2FsIERPTSB0cmVlLlxuICAgICAgICovXG4gICAgICBpc0xvY2FsRGVzY2VuZGFudChub2RlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvb3QgPT09IG5vZGUuZ2V0Um9vdE5vZGUoKTtcbiAgICAgIH1cblxuICAgICAgLy8gTk9URTogc2hvdWxkIG5vdyBiZSBoYW5kbGVkIGJ5IFNoYWR5Q3NzIGxpYnJhcnkuXG4gICAgICBzY29wZVN1YnRyZWUoY29udGFpbmVyLCBzaG91bGRPYnNlcnZlKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZXR1cm5zIHRoZSBjb21wdXRlZCBzdHlsZSB2YWx1ZSBmb3IgdGhlIGdpdmVuIHByb3BlcnR5LlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFRoZSBjc3MgcHJvcGVydHkgbmFtZS5cbiAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gUmV0dXJucyB0aGUgY29tcHV0ZWQgY3NzIHByb3BlcnR5IHZhbHVlIGZvciB0aGUgZ2l2ZW5cbiAgICAgICAqIGBwcm9wZXJ0eWAuXG4gICAgICAgKi9cbiAgICAgIGdldENvbXB1dGVkU3R5bGVWYWx1ZShwcm9wZXJ0eSkge1xuICAgICAgICByZXR1cm4gc3R5bGVJbnRlcmZhY2UuZ2V0Q29tcHV0ZWRTdHlsZVZhbHVlKHRoaXMsIHByb3BlcnR5KTtcbiAgICAgIH1cblxuICAgICAgLy8gZGVib3VuY2VcblxuICAgICAgLyoqXG4gICAgICAgKiBDYWxsIGBkZWJvdW5jZWAgdG8gY29sbGFwc2UgbXVsdGlwbGUgcmVxdWVzdHMgZm9yIGEgbmFtZWQgdGFzayBpbnRvXG4gICAgICAgKiBvbmUgaW52b2NhdGlvbiB3aGljaCBpcyBtYWRlIGFmdGVyIHRoZSB3YWl0IHRpbWUgaGFzIGVsYXBzZWQgd2l0aFxuICAgICAgICogbm8gbmV3IHJlcXVlc3QuICBJZiBubyB3YWl0IHRpbWUgaXMgZ2l2ZW4sIHRoZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZFxuICAgICAgICogYXQgbWljcm90YXNrIHRpbWluZyAoZ3VhcmFudGVlZCBiZWZvcmUgcGFpbnQpLlxuICAgICAgICpcbiAgICAgICAqICAgICBkZWJvdW5jZWRDbGlja0FjdGlvbihlKSB7XG4gICAgICAgKiAgICAgICAvLyB3aWxsIG5vdCBjYWxsIGBwcm9jZXNzQ2xpY2tgIG1vcmUgdGhhbiBvbmNlIHBlciAxMDBtc1xuICAgICAgICogICAgICAgdGhpcy5kZWJvdW5jZSgnY2xpY2snLCBmdW5jdGlvbigpIHtcbiAgICAgICAqICAgICAgICB0aGlzLnByb2Nlc3NDbGljaygpO1xuICAgICAgICogICAgICAgfSAxMDApO1xuICAgICAgICogICAgIH1cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gam9iTmFtZSBTdHJpbmcgdG8gaW5kZW50aWZ5IHRoZSBkZWJvdW5jZSBqb2IuXG4gICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCl9IGNhbGxiYWNrIEZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkICh3aXRoIGB0aGlzYFxuICAgICAgICogICBjb250ZXh0KSB3aGVuIHRoZSB3YWl0IHRpbWUgZWxhcHNlcy5cbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3YWl0IE9wdGlvbmFsIHdhaXQgdGltZSBpbiBtaWxsaXNlY29uZHMgKG1zKSBhZnRlciB0aGVcbiAgICAgICAqICAgbGFzdCBzaWduYWwgdGhhdCBtdXN0IGVsYXBzZSBiZWZvcmUgaW52b2tpbmcgYGNhbGxiYWNrYFxuICAgICAgICogQHJldHVybiB7T2JqZWN0fSBSZXR1cm5zIGEgZGVib3VuY2VyIG9iamVjdCBvbiB3aGljaCBleGlzdHMgdGhlXG4gICAgICAgKiBmb2xsb3dpbmcgbWV0aG9kczogYGlzQWN0aXZlKClgIHJldHVybnMgdHJ1ZSBpZiB0aGUgZGVib3VuY2VyIGlzXG4gICAgICAgKiBhY3RpdmU7IGBjYW5jZWwoKWAgY2FuY2VscyB0aGUgZGVib3VuY2VyIGlmIGl0IGlzIGFjdGl2ZTtcbiAgICAgICAqIGBmbHVzaCgpYCBpbW1lZGlhdGVseSBpbnZva2VzIHRoZSBkZWJvdW5jZWQgY2FsbGJhY2sgaWYgdGhlIGRlYm91bmNlclxuICAgICAgICogaXMgYWN0aXZlLlxuICAgICAgICovXG4gICAgICBkZWJvdW5jZShqb2JOYW1lLCBjYWxsYmFjaywgd2FpdCkge1xuICAgICAgICB0aGlzLl9kZWJvdW5jZXJzID0gdGhpcy5fZGVib3VuY2VycyB8fCB7fTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlYm91bmNlcnNbam9iTmFtZV0gPSBQb2x5bWVyLkRlYm91bmNlci5kZWJvdW5jZShcbiAgICAgICAgICAgICAgdGhpcy5fZGVib3VuY2Vyc1tqb2JOYW1lXVxuICAgICAgICAgICAgLCB3YWl0ID4gMCA/IFBvbHltZXIuQXN5bmMudGltZU91dC5hZnRlcih3YWl0KSA6IFBvbHltZXIuQXN5bmMubWljcm9UYXNrXG4gICAgICAgICAgICAsIGNhbGxiYWNrLmJpbmQodGhpcykpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJldHVybnMgd2hldGhlciBhIG5hbWVkIGRlYm91bmNlciBpcyBhY3RpdmUuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGpvYk5hbWUgVGhlIG5hbWUgb2YgdGhlIGRlYm91bmNlciBzdGFydGVkIHdpdGggYGRlYm91bmNlYFxuICAgICAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgZGVib3VuY2VyIGlzIGFjdGl2ZSAoaGFzIG5vdCB5ZXQgZmlyZWQpLlxuICAgICAgICovXG4gICAgICBpc0RlYm91bmNlckFjdGl2ZShqb2JOYW1lKSB7XG4gICAgICAgIHRoaXMuX2RlYm91bmNlcnMgPSB0aGlzLl9kZWJvdW5jZXJzIHx8IHt9O1xuICAgICAgICBsZXQgZGVib3VuY2VyID0gdGhpcy5fZGVib3VuY2Vyc1tqb2JOYW1lXTtcbiAgICAgICAgcmV0dXJuICEhKGRlYm91bmNlciAmJiBkZWJvdW5jZXIuaXNBY3RpdmUoKSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogSW1tZWRpYXRlbHkgY2FsbHMgdGhlIGRlYm91bmNlciBgY2FsbGJhY2tgIGFuZCBpbmFjdGl2YXRlcyBpdC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gam9iTmFtZSBUaGUgbmFtZSBvZiB0aGUgZGVib3VuY2VyIHN0YXJ0ZWQgd2l0aCBgZGVib3VuY2VgXG4gICAgICAgKi9cbiAgICAgIGZsdXNoRGVib3VuY2VyKGpvYk5hbWUpIHtcbiAgICAgICAgdGhpcy5fZGVib3VuY2VycyA9IHRoaXMuX2RlYm91bmNlcnMgfHwge307XG4gICAgICAgIGxldCBkZWJvdW5jZXIgPSB0aGlzLl9kZWJvdW5jZXJzW2pvYk5hbWVdO1xuICAgICAgICBpZiAoZGVib3VuY2VyKSB7XG4gICAgICAgICAgZGVib3VuY2VyLmZsdXNoKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDYW5jZWxzIGFuIGFjdGl2ZSBkZWJvdW5jZXIuICBUaGUgYGNhbGxiYWNrYCB3aWxsIG5vdCBiZSBjYWxsZWQuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGpvYk5hbWUgVGhlIG5hbWUgb2YgdGhlIGRlYm91bmNlciBzdGFydGVkIHdpdGggYGRlYm91bmNlYFxuICAgICAgICovXG4gICAgICBjYW5jZWxEZWJvdW5jZXIoam9iTmFtZSkge1xuICAgICAgICB0aGlzLl9kZWJvdW5jZXJzID0gdGhpcy5fZGVib3VuY2VycyB8fCB7fVxuICAgICAgICBsZXQgZGVib3VuY2VyID0gdGhpcy5fZGVib3VuY2Vyc1tqb2JOYW1lXTtcbiAgICAgICAgaWYgKGRlYm91bmNlcikge1xuICAgICAgICAgIGRlYm91bmNlci5jYW5jZWwoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJ1bnMgYSBjYWxsYmFjayBmdW5jdGlvbiBhc3luY3Jvbm91c2x5LlxuICAgICAgICpcbiAgICAgICAqIEJ5IGRlZmF1bHQgKGlmIG5vIHdhaXRUaW1lIGlzIHNwZWNpZmllZCksIGFzeW5jIGNhbGxiYWNrcyBhcmUgcnVuIGF0XG4gICAgICAgKiBtaWNyb3Rhc2sgdGltaW5nLCB3aGljaCB3aWxsIG9jY3VyIGJlZm9yZSBwYWludC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgY2FsbGJhY2sgZnVuY3Rpb24gdG8gcnVuLCBib3VuZCB0byBgdGhpc2AuXG4gICAgICAgKiBAcGFyYW0ge251bWJlcj19IHdhaXRUaW1lIFRpbWUgdG8gd2FpdCBiZWZvcmUgY2FsbGluZyB0aGVcbiAgICAgICAqICAgYGNhbGxiYWNrYC4gIElmIHVuc3BlY2lmaWVkIG9yIDAsIHRoZSBjYWxsYmFjayB3aWxsIGJlIHJ1biBhdCBtaWNyb3Rhc2tcbiAgICAgICAqICAgdGltaW5nIChiZWZvcmUgcGFpbnQpLlxuICAgICAgICogQHJldHVybiB7bnVtYmVyfSBIYW5kbGUgdGhhdCBtYXkgYmUgdXNlZCB0byBjYW5jZWwgdGhlIGFzeW5jIGpvYi5cbiAgICAgICAqL1xuICAgICAgYXN5bmMoY2FsbGJhY2ssIHdhaXRUaW1lKSB7XG4gICAgICAgIHJldHVybiB3YWl0VGltZSA+IDAgPyBQb2x5bWVyLkFzeW5jLnRpbWVPdXQucnVuKGNhbGxiYWNrLmJpbmQodGhpcyksIHdhaXRUaW1lKSA6XG4gICAgICAgICAgICB+UG9seW1lci5Bc3luYy5taWNyb1Rhc2sucnVuKGNhbGxiYWNrLmJpbmQodGhpcykpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENhbmNlbHMgYW4gYXN5bmMgb3BlcmF0aW9uIHN0YXJ0ZWQgd2l0aCBgYXN5bmNgLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoYW5kbGUgSGFuZGxlIHJldHVybmVkIGZyb20gb3JpZ2luYWwgYGFzeW5jYCBjYWxsIHRvXG4gICAgICAgKiAgIGNhbmNlbC5cbiAgICAgICAqL1xuICAgICAgY2FuY2VsQXN5bmMoaGFuZGxlKSB7XG4gICAgICAgIGhhbmRsZSA8IDAgPyBQb2x5bWVyLkFzeW5jLm1pY3JvVGFzay5jYW5jZWwofmhhbmRsZSkgOlxuICAgICAgICAgICAgUG9seW1lci5Bc3luYy50aW1lT3V0LmNhbmNlbChoYW5kbGUpO1xuICAgICAgfVxuXG4gICAgICAvLyBvdGhlclxuXG4gICAgICAvKipcbiAgICAgICAqIENvbnZlbmllbmNlIG1ldGhvZCBmb3IgY3JlYXRpbmcgYW4gZWxlbWVudCBhbmQgY29uZmlndXJpbmcgaXQuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHRhZyBIVE1MIGVsZW1lbnQgdGFnIHRvIGNyZWF0ZS5cbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBPYmplY3Qgb2YgcHJvcGVydGllcyB0byBjb25maWd1cmUgb24gdGhlXG4gICAgICAgKiAgICBpbnN0YW5jZS5cbiAgICAgICAqIEByZXR1cm4ge0VsZW1lbnR9IE5ld2x5IGNyZWF0ZWQgYW5kIGNvbmZpZ3VyZWQgZWxlbWVudC5cbiAgICAgICAqL1xuICAgICAgY3JlYXRlKHRhZywgcHJvcHMpIHtcbiAgICAgICAgbGV0IGVsdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgICAgaWYgKHByb3BzKSB7XG4gICAgICAgICAgaWYgKGVsdC5zZXRQcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICBlbHQuc2V0UHJvcGVydGllcyhwcm9wcyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvciAobGV0IG4gaW4gcHJvcHMpIHtcbiAgICAgICAgICAgICAgZWx0W25dID0gcHJvcHNbbl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbHQ7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ29udmVuaWVuY2UgbWV0aG9kIGZvciBpbXBvcnRpbmcgYW4gSFRNTCBkb2N1bWVudCBpbXBlcmF0aXZlbHkuXG4gICAgICAgKlxuICAgICAgICogVGhpcyBtZXRob2QgY3JlYXRlcyBhIG5ldyBgPGxpbmsgcmVsPVwiaW1wb3J0XCI+YCBlbGVtZW50IHdpdGhcbiAgICAgICAqIHRoZSBwcm92aWRlZCBVUkwgYW5kIGFwcGVuZHMgaXQgdG8gdGhlIGRvY3VtZW50IHRvIHN0YXJ0IGxvYWRpbmcuXG4gICAgICAgKiBJbiB0aGUgYG9ubG9hZGAgY2FsbGJhY2ssIHRoZSBgaW1wb3J0YCBwcm9wZXJ0eSBvZiB0aGUgYGxpbmtgXG4gICAgICAgKiBlbGVtZW50IHdpbGwgY29udGFpbiB0aGUgaW1wb3J0ZWQgZG9jdW1lbnQgY29udGVudHMuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGhyZWYgVVJMIHRvIGRvY3VtZW50IHRvIGxvYWQuXG4gICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvbmxvYWQgQ2FsbGJhY2sgdG8gbm90aWZ5IHdoZW4gYW4gaW1wb3J0IHN1Y2Nlc3NmdWxseVxuICAgICAgICogICBsb2FkZWQuXG4gICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvbmVycm9yIENhbGxiYWNrIHRvIG5vdGlmeSB3aGVuIGFuIGltcG9ydFxuICAgICAgICogICB1bnN1Y2Nlc3NmdWxseSBsb2FkZWQuXG4gICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IG9wdEFzeW5jIFRydWUgaWYgdGhlIGltcG9ydCBzaG91bGQgYmUgbG9hZGVkIGBhc3luY2AuXG4gICAgICAgKiAgIERlZmF1bHRzIHRvIGBmYWxzZWAuXG4gICAgICAgKiBAcmV0dXJuIHtIVE1MTGlua0VsZW1lbnR9IFRoZSBsaW5rIGVsZW1lbnQgZm9yIHRoZSBVUkwgdG8gYmUgbG9hZGVkLlxuICAgICAgICovXG4gICAgICBpbXBvcnRIcmVmKGhyZWYsIG9ubG9hZCwgb25lcnJvciwgb3B0QXN5bmMpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgICBsZXQgbG9hZEZuID0gb25sb2FkID8gb25sb2FkLmJpbmQodGhpcykgOiBudWxsO1xuICAgICAgICBsZXQgZXJyb3JGbiA9IG9uZXJyb3IgPyBvbmVycm9yLmJpbmQodGhpcykgOiBudWxsO1xuICAgICAgICByZXR1cm4gUG9seW1lci5pbXBvcnRIcmVmKGhyZWYsIGxvYWRGbiwgZXJyb3JGbiwgb3B0QXN5bmMpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFBvbHlmaWxsIGZvciBFbGVtZW50LnByb3RvdHlwZS5tYXRjaGVzLCB3aGljaCBpcyBzb21ldGltZXMgc3RpbGxcbiAgICAgICAqIHByZWZpeGVkLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzZWxlY3RvciBTZWxlY3RvciB0byB0ZXN0LlxuICAgICAgICogQHBhcmFtIHtFbGVtZW50PX0gbm9kZSBFbGVtZW50IHRvIHRlc3QgdGhlIHNlbGVjdG9yIGFnYWluc3QuXG4gICAgICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBlbGVtZW50IG1hdGNoZXMgdGhlIHNlbGVjdG9yLlxuICAgICAgICovXG4gICAgICBlbGVtZW50TWF0Y2hlcyhzZWxlY3Rvciwgbm9kZSkge1xuICAgICAgICByZXR1cm4gUG9seW1lci5kb20ubWF0Y2hlc1NlbGVjdG9yKC8qKiBAdHlwZSB7IUVsZW1lbnR9ICovIChub2RlIHx8IHRoaXMpLCBzZWxlY3Rvcik7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogVG9nZ2xlcyBhbiBIVE1MIGF0dHJpYnV0ZSBvbiBvciBvZmYuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgSFRNTCBhdHRyaWJ1dGUgbmFtZVxuICAgICAgICogQHBhcmFtIHtib29sZWFuPX0gYm9vbCBCb29sZWFuIHRvIGZvcmNlIHRoZSBhdHRyaWJ1dGUgb24gb3Igb2ZmLlxuICAgICAgICogICAgV2hlbiB1bnNwZWNpZmllZCwgdGhlIHN0YXRlIG9mIHRoZSBhdHRyaWJ1dGUgd2lsbCBiZSByZXZlcnNlZC5cbiAgICAgICAqIEBwYXJhbSB7RWxlbWVudD19IG5vZGUgTm9kZSB0byB0YXJnZXQuICBEZWZhdWx0cyB0byBgdGhpc2AuXG4gICAgICAgKi9cbiAgICAgIHRvZ2dsZUF0dHJpYnV0ZShuYW1lLCBib29sLCBub2RlKSB7XG4gICAgICAgIG5vZGUgPSAvKiogQHR5cGUge0VsZW1lbnR9ICovIChub2RlIHx8IHRoaXMpO1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgYm9vbCA9ICFub2RlLmhhc0F0dHJpYnV0ZShuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYm9vbCkge1xuICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKG5hbWUsICcnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG5cbiAgICAgIC8qKlxuICAgICAgICogVG9nZ2xlcyBhIENTUyBjbGFzcyBvbiBvciBvZmYuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgQ1NTIGNsYXNzIG5hbWVcbiAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IGJvb2wgQm9vbGVhbiB0byBmb3JjZSB0aGUgY2xhc3Mgb24gb3Igb2ZmLlxuICAgICAgICogICAgV2hlbiB1bnNwZWNpZmllZCwgdGhlIHN0YXRlIG9mIHRoZSBjbGFzcyB3aWxsIGJlIHJldmVyc2VkLlxuICAgICAgICogQHBhcmFtIHtFbGVtZW50PX0gbm9kZSBOb2RlIHRvIHRhcmdldC4gIERlZmF1bHRzIHRvIGB0aGlzYC5cbiAgICAgICAqL1xuICAgICAgdG9nZ2xlQ2xhc3MobmFtZSwgYm9vbCwgbm9kZSkge1xuICAgICAgICBub2RlID0gLyoqIEB0eXBlIHtFbGVtZW50fSAqLyAobm9kZSB8fCB0aGlzKTtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMSkge1xuICAgICAgICAgIGJvb2wgPSAhbm9kZS5jbGFzc0xpc3QuY29udGFpbnMobmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJvb2wpIHtcbiAgICAgICAgICBub2RlLmNsYXNzTGlzdC5hZGQobmFtZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9kZS5jbGFzc0xpc3QucmVtb3ZlKG5hbWUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ3Jvc3MtcGxhdGZvcm0gaGVscGVyIGZvciBzZXR0aW5nIGFuIGVsZW1lbnQncyBDU1MgYHRyYW5zZm9ybWAgcHJvcGVydHkuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHRyYW5zZm9ybVRleHQgVHJhbnNmb3JtIHNldHRpbmcuXG4gICAgICAgKiBAcGFyYW0ge0VsZW1lbnQ9fSBub2RlIEVsZW1lbnQgdG8gYXBwbHkgdGhlIHRyYW5zZm9ybSB0by5cbiAgICAgICAqIERlZmF1bHRzIHRvIGB0aGlzYFxuICAgICAgICovXG4gICAgICB0cmFuc2Zvcm0odHJhbnNmb3JtVGV4dCwgbm9kZSkge1xuICAgICAgICBub2RlID0gLyoqIEB0eXBlIHtFbGVtZW50fSAqLyAobm9kZSB8fCB0aGlzKTtcbiAgICAgICAgbm9kZS5zdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSB0cmFuc2Zvcm1UZXh0O1xuICAgICAgICBub2RlLnN0eWxlLnRyYW5zZm9ybSA9IHRyYW5zZm9ybVRleHQ7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ3Jvc3MtcGxhdGZvcm0gaGVscGVyIGZvciBzZXR0aW5nIGFuIGVsZW1lbnQncyBDU1MgYHRyYW5zbGF0ZTNkYFxuICAgICAgICogcHJvcGVydHkuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHggWCBvZmZzZXQuXG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0geSBZIG9mZnNldC5cbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB6IFogb2Zmc2V0LlxuICAgICAgICogQHBhcmFtIHtFbGVtZW50PX0gbm9kZSBFbGVtZW50IHRvIGFwcGx5IHRoZSB0cmFuc2Zvcm0gdG8uXG4gICAgICAgKiBEZWZhdWx0cyB0byBgdGhpc2AuXG4gICAgICAgKi9cbiAgICAgIHRyYW5zbGF0ZTNkKHgsIHksIHosIG5vZGUpIHtcbiAgICAgICAgbm9kZSA9IC8qKiBAdHlwZSB7RWxlbWVudH0gKi8gKG5vZGUgfHwgdGhpcyk7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtKCd0cmFuc2xhdGUzZCgnICsgeCArICcsJyArIHkgKyAnLCcgKyB6ICsgJyknLCBub2RlKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZW1vdmVzIGFuIGl0ZW0gZnJvbSBhbiBhcnJheSwgaWYgaXQgZXhpc3RzLlxuICAgICAgICpcbiAgICAgICAqIElmIHRoZSBhcnJheSBpcyBzcGVjaWZpZWQgYnkgcGF0aCwgYSBjaGFuZ2Ugbm90aWZpY2F0aW9uIGlzXG4gICAgICAgKiBnZW5lcmF0ZWQsIHNvIHRoYXQgb2JzZXJ2ZXJzLCBkYXRhIGJpbmRpbmdzIGFuZCBjb21wdXRlZFxuICAgICAgICogcHJvcGVydGllcyB3YXRjaGluZyB0aGF0IHBhdGggY2FuIHVwZGF0ZS5cbiAgICAgICAqXG4gICAgICAgKiBJZiB0aGUgYXJyYXkgaXMgcGFzc2VkIGRpcmVjdGx5LCAqKm5vIGNoYW5nZVxuICAgICAgICogbm90aWZpY2F0aW9uIGlzIGdlbmVyYXRlZCoqLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgIUFycmF5PG51bWJlcnxzdHJpbmc+fSBhcnJheU9yUGF0aCBQYXRoIHRvIGFycmF5IGZyb20gd2hpY2ggdG8gcmVtb3ZlIHRoZSBpdGVtXG4gICAgICAgKiAgIChvciB0aGUgYXJyYXkgaXRzZWxmKS5cbiAgICAgICAqIEBwYXJhbSB7Kn0gaXRlbSBJdGVtIHRvIHJlbW92ZS5cbiAgICAgICAqIEByZXR1cm4ge0FycmF5fSBBcnJheSBjb250YWluaW5nIGl0ZW0gcmVtb3ZlZC5cbiAgICAgICAqL1xuICAgICAgYXJyYXlEZWxldGUoYXJyYXlPclBhdGgsIGl0ZW0pIHtcbiAgICAgICAgbGV0IGluZGV4O1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhcnJheU9yUGF0aCkpIHtcbiAgICAgICAgICBpbmRleCA9IGFycmF5T3JQYXRoLmluZGV4T2YoaXRlbSk7XG4gICAgICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgICAgIHJldHVybiBhcnJheU9yUGF0aC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsZXQgYXJyID0gUG9seW1lci5QYXRoLmdldCh0aGlzLCBhcnJheU9yUGF0aCk7XG4gICAgICAgICAgaW5kZXggPSBhcnIuaW5kZXhPZihpdGVtKTtcbiAgICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3BsaWNlKGFycmF5T3JQYXRoLCBpbmRleCwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICAvLyBsb2dnaW5nXG5cbiAgICAgIC8qKlxuICAgICAgICogRmFjYWRlcyBgY29uc29sZS5sb2dgL2B3YXJuYC9gZXJyb3JgIGFzIG92ZXJyaWRlIHBvaW50LlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsZXZlbCBPbmUgb2YgJ2xvZycsICd3YXJuJywgJ2Vycm9yJ1xuICAgICAgICogQHBhcmFtIHtBcnJheX0gYXJncyBBcnJheSBvZiBzdHJpbmdzIG9yIG9iamVjdHMgdG8gbG9nXG4gICAgICAgKi9cbiAgICAgIF9sb2dnZXIobGV2ZWwsIGFyZ3MpIHtcbiAgICAgICAgLy8gYWNjZXB0IFsnZm9vJywgJ2JhciddIGFuZCBbWydmb28nLCAnYmFyJ11dXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFyZ3MpICYmIGFyZ3MubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgYXJncyA9IGFyZ3NbMF07XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoKGxldmVsKSB7XG4gICAgICAgICAgY2FzZSAnbG9nJzpcbiAgICAgICAgICBjYXNlICd3YXJuJzpcbiAgICAgICAgICBjYXNlICdlcnJvcic6XG4gICAgICAgICAgICBjb25zb2xlW2xldmVsXSguLi5hcmdzKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEZhY2FkZXMgYGNvbnNvbGUubG9nYCBhcyBhbiBvdmVycmlkZSBwb2ludC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0gey4uLip9IGFyZ3MgQXJyYXkgb2Ygc3RyaW5ncyBvciBvYmplY3RzIHRvIGxvZ1xuICAgICAgICovXG4gICAgICBfbG9nKC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5fbG9nZ2VyKCdsb2cnLCBhcmdzKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBGYWNhZGVzIGBjb25zb2xlLndhcm5gIGFzIGFuIG92ZXJyaWRlIHBvaW50LlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7Li4uKn0gYXJncyBBcnJheSBvZiBzdHJpbmdzIG9yIG9iamVjdHMgdG8gbG9nXG4gICAgICAgKi9cbiAgICAgIF93YXJuKC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5fbG9nZ2VyKCd3YXJuJywgYXJncyk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogRmFjYWRlcyBgY29uc29sZS5lcnJvcmAgYXMgYW4gb3ZlcnJpZGUgcG9pbnQuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHsuLi4qfSBhcmdzIEFycmF5IG9mIHN0cmluZ3Mgb3Igb2JqZWN0cyB0byBsb2dcbiAgICAgICAqL1xuICAgICAgX2Vycm9yKC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5fbG9nZ2VyKCdlcnJvcicsIGFyZ3MpXG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogRm9ybWF0cyBhIG1lc3NhZ2UgdXNpbmcgdGhlIGVsZW1lbnQgdHlwZSBhbiBhIG1ldGhvZCBuYW1lLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2ROYW1lIE1ldGhvZCBuYW1lIHRvIGFzc29jaWF0ZSB3aXRoIG1lc3NhZ2VcbiAgICAgICAqIEBwYXJhbSB7Li4uKn0gYXJncyBBcnJheSBvZiBzdHJpbmdzIG9yIG9iamVjdHMgdG8gbG9nXG4gICAgICAgKiBAcmV0dXJuIHtBcnJheX0gQXJyYXkgd2l0aCBmb3JtYXR0aW5nIGluZm9ybWF0aW9uIGZvciBgY29uc29sZWBcbiAgICAgICAqICAgbG9nZ2luZy5cbiAgICAgICAqL1xuICAgICAgX2xvZ2YobWV0aG9kTmFtZSwgLi4uYXJncykge1xuICAgICAgICByZXR1cm4gWydbJXM6OiVzXScsIHRoaXMuaXMsIG1ldGhvZE5hbWUsIC4uLmFyZ3NdO1xuICAgICAgfVxuXG4gICAgfVxuXG4gICAgTGVnYWN5RWxlbWVudC5wcm90b3R5cGUuaXMgPSAnJztcblxuICAgIHJldHVybiBMZWdhY3lFbGVtZW50O1xuXG4gIH0pO1xuXG59KSgpO1xuPC9zY3JpcHQ+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL3BvbHltZXIvbGliL2xlZ2FjeS9sZWdhY3ktZWxlbWVudC1taXhpbi5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3V0aWxzL2Jvb3QuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3V0aWxzL21peGluLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi91dGlscy9nZXN0dXJlcy5odG1sXCI+XG5cbjxzY3JpcHQ+XG4oZnVuY3Rpb24oKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8qKlxuICAgKiBAY29uc3Qge1BvbHltZXIuR2VzdHVyZXN9XG4gICAqL1xuICBjb25zdCBnZXN0dXJlcyA9IFBvbHltZXIuR2VzdHVyZXM7XG5cbiAgLyoqXG4gICAqIEVsZW1lbnQgY2xhc3MgbWl4aW4gdGhhdCBwcm92aWRlcyBBUEkgZm9yIGFkZGluZyBQb2x5bWVyJ3MgY3Jvc3MtcGxhdGZvcm1cbiAgICogZ2VzdHVyZSBldmVudHMgdG8gbm9kZXMuXG4gICAqXG4gICAqIFRoZSBBUEkgaXMgZGVzaWduZWQgdG8gYmUgY29tcGF0aWJsZSB3aXRoIG92ZXJyaWRlIHBvaW50cyBpbXBsZW1lbnRlZFxuICAgKiBpbiBgUG9seW1lci5UZW1wbGF0ZVN0YW1wYCBzdWNoIHRoYXQgZGVjbGFyYXRpdmUgZXZlbnQgbGlzdGVuZXJzIGluXG4gICAqIHRlbXBsYXRlcyB3aWxsIHN1cHBvcnQgZ2VzdHVyZSBldmVudHMgd2hlbiB0aGlzIG1peGluIGlzIGFwcGxpZWQgYWxvbmcgd2l0aFxuICAgKiBgUG9seW1lci5UZW1wbGF0ZVN0YW1wYC5cbiAgICpcbiAgICogQG1peGluRnVuY3Rpb25cbiAgICogQHBvbHltZXJcbiAgICogQG1lbWJlcm9mIFBvbHltZXJcbiAgICogQHN1bW1hcnkgRWxlbWVudCBjbGFzcyBtaXhpbiB0aGF0IHByb3ZpZGVzIEFQSSBmb3IgYWRkaW5nIFBvbHltZXIncyBjcm9zcy1wbGF0Zm9ybVxuICAgKiBnZXN0dXJlIGV2ZW50cyB0byBub2Rlc1xuICAgKi9cbiAgUG9seW1lci5HZXN0dXJlRXZlbnRMaXN0ZW5lcnMgPSBQb2x5bWVyLmRlZHVwaW5nTWl4aW4oc3VwZXJDbGFzcyA9PiB7XG5cbiAgICAvKipcbiAgICAgKiBAcG9seW1lclxuICAgICAqIEBtaXhpbkNsYXNzXG4gICAgICogQGltcGxlbWVudHMge1BvbHltZXJfR2VzdHVyZUV2ZW50TGlzdGVuZXJzfVxuICAgICAqL1xuICAgIGNsYXNzIEdlc3R1cmVFdmVudExpc3RlbmVycyBleHRlbmRzIHN1cGVyQ2xhc3Mge1xuXG4gICAgICBfYWRkRXZlbnRMaXN0ZW5lclRvTm9kZShub2RlLCBldmVudE5hbWUsIGhhbmRsZXIpIHtcbiAgICAgICAgaWYgKCFnZXN0dXJlcy5hZGRMaXN0ZW5lcihub2RlLCBldmVudE5hbWUsIGhhbmRsZXIpKSB7XG4gICAgICAgICAgc3VwZXIuX2FkZEV2ZW50TGlzdGVuZXJUb05vZGUobm9kZSwgZXZlbnROYW1lLCBoYW5kbGVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBfcmVtb3ZlRXZlbnRMaXN0ZW5lckZyb21Ob2RlKG5vZGUsIGV2ZW50TmFtZSwgaGFuZGxlcikge1xuICAgICAgICBpZiAoIWdlc3R1cmVzLnJlbW92ZUxpc3RlbmVyKG5vZGUsIGV2ZW50TmFtZSwgaGFuZGxlcikpIHtcbiAgICAgICAgICBzdXBlci5fcmVtb3ZlRXZlbnRMaXN0ZW5lckZyb21Ob2RlKG5vZGUsIGV2ZW50TmFtZSwgaGFuZGxlcik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgIH1cblxuICAgIHJldHVybiBHZXN0dXJlRXZlbnRMaXN0ZW5lcnM7XG5cbiAgfSk7XG5cbn0pKCk7XG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvbWl4aW5zL2dlc3R1cmUtZXZlbnQtbGlzdGVuZXJzLmh0bWwiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiYm9vdC5odG1sXCI+XG48c2NyaXB0PlxuKGZ1bmN0aW9uKCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICBmdW5jdGlvbiBuZXdTcGxpY2UoaW5kZXgsIHJlbW92ZWQsIGFkZGVkQ291bnQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgcmVtb3ZlZDogcmVtb3ZlZCxcbiAgICAgIGFkZGVkQ291bnQ6IGFkZGVkQ291bnRcbiAgICB9O1xuICB9XG5cbiAgY29uc3QgRURJVF9MRUFWRSA9IDA7XG4gIGNvbnN0IEVESVRfVVBEQVRFID0gMTtcbiAgY29uc3QgRURJVF9BREQgPSAyO1xuICBjb25zdCBFRElUX0RFTEVURSA9IDM7XG5cbiAgLy8gTm90ZTogVGhpcyBmdW5jdGlvbiBpcyAqYmFzZWQqIG9uIHRoZSBjb21wdXRhdGlvbiBvZiB0aGUgTGV2ZW5zaHRlaW5cbiAgLy8gXCJlZGl0XCIgZGlzdGFuY2UuIFRoZSBvbmUgY2hhbmdlIGlzIHRoYXQgXCJ1cGRhdGVzXCIgYXJlIHRyZWF0ZWQgYXMgdHdvXG4gIC8vIGVkaXRzIC0gbm90IG9uZS4gV2l0aCBBcnJheSBzcGxpY2VzLCBhbiB1cGRhdGUgaXMgcmVhbGx5IGEgZGVsZXRlXG4gIC8vIGZvbGxvd2VkIGJ5IGFuIGFkZC4gQnkgcmV0YWluaW5nIHRoaXMsIHdlIG9wdGltaXplIGZvciBcImtlZXBpbmdcIiB0aGVcbiAgLy8gbWF4aW11bSBhcnJheSBpdGVtcyBpbiB0aGUgb3JpZ2luYWwgYXJyYXkuIEZvciBleGFtcGxlOlxuICAvL1xuICAvLyAgICd4eHh4MTIzJyAtPiAnMTIzeXl5eSdcbiAgLy9cbiAgLy8gV2l0aCAxLWVkaXQgdXBkYXRlcywgdGhlIHNob3J0ZXN0IHBhdGggd291bGQgYmUganVzdCB0byB1cGRhdGUgYWxsIHNldmVuXG4gIC8vIGNoYXJhY3RlcnMuIFdpdGggMi1lZGl0IHVwZGF0ZXMsIHdlIGRlbGV0ZSA0LCBsZWF2ZSAzLCBhbmQgYWRkIDQuIFRoaXNcbiAgLy8gbGVhdmVzIHRoZSBzdWJzdHJpbmcgJzEyMycgaW50YWN0LlxuICBmdW5jdGlvbiBjYWxjRWRpdERpc3RhbmNlcyhjdXJyZW50LCBjdXJyZW50U3RhcnQsIGN1cnJlbnRFbmQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbGQsIG9sZFN0YXJ0LCBvbGRFbmQpIHtcbiAgICAvLyBcIkRlbGV0aW9uXCIgY29sdW1uc1xuICAgIGxldCByb3dDb3VudCA9IG9sZEVuZCAtIG9sZFN0YXJ0ICsgMTtcbiAgICBsZXQgY29sdW1uQ291bnQgPSBjdXJyZW50RW5kIC0gY3VycmVudFN0YXJ0ICsgMTtcbiAgICBsZXQgZGlzdGFuY2VzID0gbmV3IEFycmF5KHJvd0NvdW50KTtcblxuICAgIC8vIFwiQWRkaXRpb25cIiByb3dzLiBJbml0aWFsaXplIG51bGwgY29sdW1uLlxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcm93Q291bnQ7IGkrKykge1xuICAgICAgZGlzdGFuY2VzW2ldID0gbmV3IEFycmF5KGNvbHVtbkNvdW50KTtcbiAgICAgIGRpc3RhbmNlc1tpXVswXSA9IGk7XG4gICAgfVxuXG4gICAgLy8gSW5pdGlhbGl6ZSBudWxsIHJvd1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgY29sdW1uQ291bnQ7IGorKylcbiAgICAgIGRpc3RhbmNlc1swXVtqXSA9IGo7XG5cbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IHJvd0NvdW50OyBpKyspIHtcbiAgICAgIGZvciAobGV0IGogPSAxOyBqIDwgY29sdW1uQ291bnQ7IGorKykge1xuICAgICAgICBpZiAoZXF1YWxzKGN1cnJlbnRbY3VycmVudFN0YXJ0ICsgaiAtIDFdLCBvbGRbb2xkU3RhcnQgKyBpIC0gMV0pKVxuICAgICAgICAgIGRpc3RhbmNlc1tpXVtqXSA9IGRpc3RhbmNlc1tpIC0gMV1baiAtIDFdO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBsZXQgbm9ydGggPSBkaXN0YW5jZXNbaSAtIDFdW2pdICsgMTtcbiAgICAgICAgICBsZXQgd2VzdCA9IGRpc3RhbmNlc1tpXVtqIC0gMV0gKyAxO1xuICAgICAgICAgIGRpc3RhbmNlc1tpXVtqXSA9IG5vcnRoIDwgd2VzdCA/IG5vcnRoIDogd2VzdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBkaXN0YW5jZXM7XG4gIH1cblxuICAvLyBUaGlzIHN0YXJ0cyBhdCB0aGUgZmluYWwgd2VpZ2h0LCBhbmQgd2Fsa3MgXCJiYWNrd2FyZFwiIGJ5IGZpbmRpbmdcbiAgLy8gdGhlIG1pbmltdW0gcHJldmlvdXMgd2VpZ2h0IHJlY3Vyc2l2ZWx5IHVudGlsIHRoZSBvcmlnaW4gb2YgdGhlIHdlaWdodFxuICAvLyBtYXRyaXguXG4gIGZ1bmN0aW9uIHNwbGljZU9wZXJhdGlvbnNGcm9tRWRpdERpc3RhbmNlcyhkaXN0YW5jZXMpIHtcbiAgICBsZXQgaSA9IGRpc3RhbmNlcy5sZW5ndGggLSAxO1xuICAgIGxldCBqID0gZGlzdGFuY2VzWzBdLmxlbmd0aCAtIDE7XG4gICAgbGV0IGN1cnJlbnQgPSBkaXN0YW5jZXNbaV1bal07XG4gICAgbGV0IGVkaXRzID0gW107XG4gICAgd2hpbGUgKGkgPiAwIHx8IGogPiAwKSB7XG4gICAgICBpZiAoaSA9PSAwKSB7XG4gICAgICAgIGVkaXRzLnB1c2goRURJVF9BREQpO1xuICAgICAgICBqLS07XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKGogPT0gMCkge1xuICAgICAgICBlZGl0cy5wdXNoKEVESVRfREVMRVRFKTtcbiAgICAgICAgaS0tO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGxldCBub3J0aFdlc3QgPSBkaXN0YW5jZXNbaSAtIDFdW2ogLSAxXTtcbiAgICAgIGxldCB3ZXN0ID0gZGlzdGFuY2VzW2kgLSAxXVtqXTtcbiAgICAgIGxldCBub3J0aCA9IGRpc3RhbmNlc1tpXVtqIC0gMV07XG5cbiAgICAgIGxldCBtaW47XG4gICAgICBpZiAod2VzdCA8IG5vcnRoKVxuICAgICAgICBtaW4gPSB3ZXN0IDwgbm9ydGhXZXN0ID8gd2VzdCA6IG5vcnRoV2VzdDtcbiAgICAgIGVsc2VcbiAgICAgICAgbWluID0gbm9ydGggPCBub3J0aFdlc3QgPyBub3J0aCA6IG5vcnRoV2VzdDtcblxuICAgICAgaWYgKG1pbiA9PSBub3J0aFdlc3QpIHtcbiAgICAgICAgaWYgKG5vcnRoV2VzdCA9PSBjdXJyZW50KSB7XG4gICAgICAgICAgZWRpdHMucHVzaChFRElUX0xFQVZFKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlZGl0cy5wdXNoKEVESVRfVVBEQVRFKTtcbiAgICAgICAgICBjdXJyZW50ID0gbm9ydGhXZXN0O1xuICAgICAgICB9XG4gICAgICAgIGktLTtcbiAgICAgICAgai0tO1xuICAgICAgfSBlbHNlIGlmIChtaW4gPT0gd2VzdCkge1xuICAgICAgICBlZGl0cy5wdXNoKEVESVRfREVMRVRFKTtcbiAgICAgICAgaS0tO1xuICAgICAgICBjdXJyZW50ID0gd2VzdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVkaXRzLnB1c2goRURJVF9BREQpO1xuICAgICAgICBqLS07XG4gICAgICAgIGN1cnJlbnQgPSBub3J0aDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBlZGl0cy5yZXZlcnNlKCk7XG4gICAgcmV0dXJuIGVkaXRzO1xuICB9XG5cbiAgLyoqXG4gICAqIFNwbGljZSBQcm9qZWN0aW9uIGZ1bmN0aW9uczpcbiAgICpcbiAgICogQSBzcGxpY2UgbWFwIGlzIGEgcmVwcmVzZW50YXRpb24gb2YgaG93IGEgcHJldmlvdXMgYXJyYXkgb2YgaXRlbXNcbiAgICogd2FzIHRyYW5zZm9ybWVkIGludG8gYSBuZXcgYXJyYXkgb2YgaXRlbXMuIENvbmNlcHR1YWxseSBpdCBpcyBhIGxpc3Qgb2ZcbiAgICogdHVwbGVzIG9mXG4gICAqXG4gICAqICAgPGluZGV4LCByZW1vdmVkLCBhZGRlZENvdW50PlxuICAgKlxuICAgKiB3aGljaCBhcmUga2VwdCBpbiBhc2NlbmRpbmcgaW5kZXggb3JkZXIgb2YuIFRoZSB0dXBsZSByZXByZXNlbnRzIHRoYXQgYXRcbiAgICogdGhlIHxpbmRleHwsIHxyZW1vdmVkfCBzZXF1ZW5jZSBvZiBpdGVtcyB3ZXJlIHJlbW92ZWQsIGFuZCBjb3VudGluZyBmb3J3YXJkXG4gICAqIGZyb20gfGluZGV4fCwgfGFkZGVkQ291bnR8IGl0ZW1zIHdlcmUgYWRkZWQuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBMYWNraW5nIGluZGl2aWR1YWwgc3BsaWNlIG11dGF0aW9uIGluZm9ybWF0aW9uLCB0aGUgbWluaW1hbCBzZXQgb2ZcbiAgICogc3BsaWNlcyBjYW4gYmUgc3ludGhlc2l6ZWQgZ2l2ZW4gdGhlIHByZXZpb3VzIHN0YXRlIGFuZCBmaW5hbCBzdGF0ZSBvZiBhblxuICAgKiBhcnJheS4gVGhlIGJhc2ljIGFwcHJvYWNoIGlzIHRvIGNhbGN1bGF0ZSB0aGUgZWRpdCBkaXN0YW5jZSBtYXRyaXggYW5kXG4gICAqIGNob29zZSB0aGUgc2hvcnRlc3QgcGF0aCB0aHJvdWdoIGl0LlxuICAgKlxuICAgKiBDb21wbGV4aXR5OiBPKGwgKiBwKVxuICAgKiAgIGw6IFRoZSBsZW5ndGggb2YgdGhlIGN1cnJlbnQgYXJyYXlcbiAgICogICBwOiBUaGUgbGVuZ3RoIG9mIHRoZSBvbGQgYXJyYXlcbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gY3VycmVudCBUaGUgY3VycmVudCBcImNoYW5nZWRcIiBhcnJheSBmb3Igd2hpY2ggdG9cbiAgICogY2FsY3VsYXRlIHNwbGljZXMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjdXJyZW50U3RhcnQgU3RhcnRpbmcgaW5kZXggaW4gdGhlIGBjdXJyZW50YCBhcnJheSBmb3JcbiAgICogd2hpY2ggc3BsaWNlcyBhcmUgY2FsY3VsYXRlZC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGN1cnJlbnRFbmQgRW5kaW5nIGluZGV4IGluIHRoZSBgY3VycmVudGAgYXJyYXkgZm9yXG4gICAqIHdoaWNoIHNwbGljZXMgYXJlIGNhbGN1bGF0ZWQuXG4gICAqIEBwYXJhbSB7QXJyYXl9IG9sZCBUaGUgb3JpZ2luYWwgXCJ1bmNoYW5nZWRcIiBhcnJheSB0byBjb21wYXJlIGBjdXJyZW50YFxuICAgKiBhZ2FpbnN0IHRvIGRldGVybWluZSBzcGxpY2VzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gb2xkU3RhcnQgU3RhcnRpbmcgaW5kZXggaW4gdGhlIGBvbGRgIGFycmF5IGZvclxuICAgKiB3aGljaCBzcGxpY2VzIGFyZSBjYWxjdWxhdGVkLlxuICAgKiBAcGFyYW0ge251bWJlcn0gb2xkRW5kIEVuZGluZyBpbmRleCBpbiB0aGUgYG9sZGAgYXJyYXkgZm9yXG4gICAqIHdoaWNoIHNwbGljZXMgYXJlIGNhbGN1bGF0ZWQuXG4gICAqIEByZXR1cm4ge0FycmF5fSBSZXR1cm5zIGFuIGFycmF5IG9mIHNwbGljZSByZWNvcmQgb2JqZWN0cy4gRWFjaCBvZiB0aGVzZVxuICAgKiBjb250YWluczogYGluZGV4YCB0aGUgbG9jYXRpb24gd2hlcmUgdGhlIHNwbGljZSBvY2N1cnJlZDsgYHJlbW92ZWRgXG4gICAqIHRoZSBhcnJheSBvZiByZW1vdmVkIGl0ZW1zIGZyb20gdGhpcyBsb2NhdGlvbjsgYGFkZGVkQ291bnRgIHRoZSBudW1iZXJcbiAgICogb2YgaXRlbXMgYWRkZWQgYXQgdGhpcyBsb2NhdGlvbi5cbiAgICovXG4gIGZ1bmN0aW9uIGNhbGNTcGxpY2VzKGN1cnJlbnQsIGN1cnJlbnRTdGFydCwgY3VycmVudEVuZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9sZCwgb2xkU3RhcnQsIG9sZEVuZCkge1xuICAgIGxldCBwcmVmaXhDb3VudCA9IDA7XG4gICAgbGV0IHN1ZmZpeENvdW50ID0gMDtcbiAgICBsZXQgc3BsaWNlO1xuXG4gICAgbGV0IG1pbkxlbmd0aCA9IE1hdGgubWluKGN1cnJlbnRFbmQgLSBjdXJyZW50U3RhcnQsIG9sZEVuZCAtIG9sZFN0YXJ0KTtcbiAgICBpZiAoY3VycmVudFN0YXJ0ID09IDAgJiYgb2xkU3RhcnQgPT0gMClcbiAgICAgIHByZWZpeENvdW50ID0gc2hhcmVkUHJlZml4KGN1cnJlbnQsIG9sZCwgbWluTGVuZ3RoKTtcblxuICAgIGlmIChjdXJyZW50RW5kID09IGN1cnJlbnQubGVuZ3RoICYmIG9sZEVuZCA9PSBvbGQubGVuZ3RoKVxuICAgICAgc3VmZml4Q291bnQgPSBzaGFyZWRTdWZmaXgoY3VycmVudCwgb2xkLCBtaW5MZW5ndGggLSBwcmVmaXhDb3VudCk7XG5cbiAgICBjdXJyZW50U3RhcnQgKz0gcHJlZml4Q291bnQ7XG4gICAgb2xkU3RhcnQgKz0gcHJlZml4Q291bnQ7XG4gICAgY3VycmVudEVuZCAtPSBzdWZmaXhDb3VudDtcbiAgICBvbGRFbmQgLT0gc3VmZml4Q291bnQ7XG5cbiAgICBpZiAoY3VycmVudEVuZCAtIGN1cnJlbnRTdGFydCA9PSAwICYmIG9sZEVuZCAtIG9sZFN0YXJ0ID09IDApXG4gICAgICByZXR1cm4gW107XG5cbiAgICBpZiAoY3VycmVudFN0YXJ0ID09IGN1cnJlbnRFbmQpIHtcbiAgICAgIHNwbGljZSA9IG5ld1NwbGljZShjdXJyZW50U3RhcnQsIFtdLCAwKTtcbiAgICAgIHdoaWxlIChvbGRTdGFydCA8IG9sZEVuZClcbiAgICAgICAgc3BsaWNlLnJlbW92ZWQucHVzaChvbGRbb2xkU3RhcnQrK10pO1xuXG4gICAgICByZXR1cm4gWyBzcGxpY2UgXTtcbiAgICB9IGVsc2UgaWYgKG9sZFN0YXJ0ID09IG9sZEVuZClcbiAgICAgIHJldHVybiBbIG5ld1NwbGljZShjdXJyZW50U3RhcnQsIFtdLCBjdXJyZW50RW5kIC0gY3VycmVudFN0YXJ0KSBdO1xuXG4gICAgbGV0IG9wcyA9IHNwbGljZU9wZXJhdGlvbnNGcm9tRWRpdERpc3RhbmNlcyhcbiAgICAgICAgY2FsY0VkaXREaXN0YW5jZXMoY3VycmVudCwgY3VycmVudFN0YXJ0LCBjdXJyZW50RW5kLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9sZCwgb2xkU3RhcnQsIG9sZEVuZCkpO1xuXG4gICAgc3BsaWNlID0gdW5kZWZpbmVkO1xuICAgIGxldCBzcGxpY2VzID0gW107XG4gICAgbGV0IGluZGV4ID0gY3VycmVudFN0YXJ0O1xuICAgIGxldCBvbGRJbmRleCA9IG9sZFN0YXJ0O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBzd2l0Y2gob3BzW2ldKSB7XG4gICAgICAgIGNhc2UgRURJVF9MRUFWRTpcbiAgICAgICAgICBpZiAoc3BsaWNlKSB7XG4gICAgICAgICAgICBzcGxpY2VzLnB1c2goc3BsaWNlKTtcbiAgICAgICAgICAgIHNwbGljZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpbmRleCsrO1xuICAgICAgICAgIG9sZEluZGV4Kys7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgRURJVF9VUERBVEU6XG4gICAgICAgICAgaWYgKCFzcGxpY2UpXG4gICAgICAgICAgICBzcGxpY2UgPSBuZXdTcGxpY2UoaW5kZXgsIFtdLCAwKTtcblxuICAgICAgICAgIHNwbGljZS5hZGRlZENvdW50Kys7XG4gICAgICAgICAgaW5kZXgrKztcblxuICAgICAgICAgIHNwbGljZS5yZW1vdmVkLnB1c2gob2xkW29sZEluZGV4XSk7XG4gICAgICAgICAgb2xkSW5kZXgrKztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBFRElUX0FERDpcbiAgICAgICAgICBpZiAoIXNwbGljZSlcbiAgICAgICAgICAgIHNwbGljZSA9IG5ld1NwbGljZShpbmRleCwgW10sIDApO1xuXG4gICAgICAgICAgc3BsaWNlLmFkZGVkQ291bnQrKztcbiAgICAgICAgICBpbmRleCsrO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEVESVRfREVMRVRFOlxuICAgICAgICAgIGlmICghc3BsaWNlKVxuICAgICAgICAgICAgc3BsaWNlID0gbmV3U3BsaWNlKGluZGV4LCBbXSwgMCk7XG5cbiAgICAgICAgICBzcGxpY2UucmVtb3ZlZC5wdXNoKG9sZFtvbGRJbmRleF0pO1xuICAgICAgICAgIG9sZEluZGV4Kys7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHNwbGljZSkge1xuICAgICAgc3BsaWNlcy5wdXNoKHNwbGljZSk7XG4gICAgfVxuICAgIHJldHVybiBzcGxpY2VzO1xuICB9XG5cbiAgZnVuY3Rpb24gc2hhcmVkUHJlZml4KGN1cnJlbnQsIG9sZCwgc2VhcmNoTGVuZ3RoKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWFyY2hMZW5ndGg7IGkrKylcbiAgICAgIGlmICghZXF1YWxzKGN1cnJlbnRbaV0sIG9sZFtpXSkpXG4gICAgICAgIHJldHVybiBpO1xuICAgIHJldHVybiBzZWFyY2hMZW5ndGg7XG4gIH1cblxuICBmdW5jdGlvbiBzaGFyZWRTdWZmaXgoY3VycmVudCwgb2xkLCBzZWFyY2hMZW5ndGgpIHtcbiAgICBsZXQgaW5kZXgxID0gY3VycmVudC5sZW5ndGg7XG4gICAgbGV0IGluZGV4MiA9IG9sZC5sZW5ndGg7XG4gICAgbGV0IGNvdW50ID0gMDtcbiAgICB3aGlsZSAoY291bnQgPCBzZWFyY2hMZW5ndGggJiYgZXF1YWxzKGN1cnJlbnRbLS1pbmRleDFdLCBvbGRbLS1pbmRleDJdKSlcbiAgICAgIGNvdW50Kys7XG5cbiAgICByZXR1cm4gY291bnQ7XG4gIH1cblxuICBmdW5jdGlvbiBjYWxjdWxhdGVTcGxpY2VzKGN1cnJlbnQsIHByZXZpb3VzKSB7XG4gICAgcmV0dXJuIGNhbGNTcGxpY2VzKGN1cnJlbnQsIDAsIGN1cnJlbnQubGVuZ3RoLCBwcmV2aW91cywgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2aW91cy5sZW5ndGgpO1xuICB9XG5cbiAgZnVuY3Rpb24gZXF1YWxzKGN1cnJlbnRWYWx1ZSwgcHJldmlvdXNWYWx1ZSkge1xuICAgIHJldHVybiBjdXJyZW50VmFsdWUgPT09IHByZXZpb3VzVmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogQG5hbWVzcGFjZVxuICAgKiBAbWVtYmVyb2YgUG9seW1lclxuICAgKiBAc3VtbWFyeSBNb2R1bGUgdGhhdCBwcm92aWRlcyB1dGlsaXRpZXMgZm9yIGRpZmZpbmcgYXJyYXlzLlxuICAgKi9cbiAgUG9seW1lci5BcnJheVNwbGljZSA9IHtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIHNwbGljZSByZWNvcmRzIGluZGljYXRpbmcgdGhlIG1pbmltdW0gZWRpdHMgcmVxdWlyZWRcbiAgICAgKiB0byB0cmFuc2Zvcm0gdGhlIGBwcmV2aW91c2AgYXJyYXkgaW50byB0aGUgYGN1cnJlbnRgIGFycmF5LlxuICAgICAqXG4gICAgICogU3BsaWNlIHJlY29yZHMgYXJlIG9yZGVyZWQgYnkgaW5kZXggYW5kIGNvbnRhaW4gdGhlIGZvbGxvd2luZyBmaWVsZHM6XG4gICAgICogLSBgaW5kZXhgOiBpbmRleCB3aGVyZSBlZGl0IHN0YXJ0ZWRcbiAgICAgKiAtIGByZW1vdmVkYDogYXJyYXkgb2YgcmVtb3ZlZCBpdGVtcyBmcm9tIHRoaXMgaW5kZXhcbiAgICAgKiAtIGBhZGRlZENvdW50YDogbnVtYmVyIG9mIGl0ZW1zIGFkZGVkIGF0IHRoaXMgaW5kZXhcbiAgICAgKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgYmFzZWQgb24gdGhlIExldmVuc2h0ZWluIFwibWluaW11bSBlZGl0IGRpc3RhbmNlXCJcbiAgICAgKiBhbGdvcml0aG0uIE5vdGUgdGhhdCB1cGRhdGVzIGFyZSB0cmVhdGVkIGFzIHJlbW92YWwgZm9sbG93ZWQgYnkgYWRkaXRpb24uXG4gICAgICpcbiAgICAgKiBUaGUgd29yc3QtY2FzZSB0aW1lIGNvbXBsZXhpdHkgb2YgdGhpcyBhbGdvcml0aG0gaXMgYE8obCAqIHApYFxuICAgICAqICAgbDogVGhlIGxlbmd0aCBvZiB0aGUgY3VycmVudCBhcnJheVxuICAgICAqICAgcDogVGhlIGxlbmd0aCBvZiB0aGUgcHJldmlvdXMgYXJyYXlcbiAgICAgKlxuICAgICAqIEhvd2V2ZXIsIHRoZSB3b3JzdC1jYXNlIGNvbXBsZXhpdHkgaXMgcmVkdWNlZCBieSBhbiBgTyhuKWAgb3B0aW1pemF0aW9uXG4gICAgICogdG8gZGV0ZWN0IGFueSBzaGFyZWQgcHJlZml4ICYgc3VmZml4IGJldHdlZW4gdGhlIHR3byBhcnJheXMgYW5kIG9ubHlcbiAgICAgKiBwZXJmb3JtIHRoZSBtb3JlIGV4cGVuc2l2ZSBtaW5pbXVtIGVkaXQgZGlzdGFuY2UgY2FsY3VsYXRpb24gb3ZlciB0aGVcbiAgICAgKiBub24tc2hhcmVkIHBvcnRpb25zIG9mIHRoZSBhcnJheXMuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgUG9seW1lci5BcnJheVNwbGljZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGN1cnJlbnQgVGhlIFwiY2hhbmdlZFwiIGFycmF5IGZvciB3aGljaCBzcGxpY2VzIHdpbGwgYmVcbiAgICAgKiBjYWxjdWxhdGVkLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHByZXZpb3VzIFRoZSBcInVuY2hhbmdlZFwiIG9yaWdpbmFsIGFycmF5IHRvIGNvbXBhcmVcbiAgICAgKiBgY3VycmVudGAgYWdhaW5zdCB0byBkZXRlcm1pbmUgdGhlIHNwbGljZXMuXG4gICAgICogQHJldHVybiB7QXJyYXl9IFJldHVybnMgYW4gYXJyYXkgb2Ygc3BsaWNlIHJlY29yZCBvYmplY3RzLiBFYWNoIG9mIHRoZXNlXG4gICAgICogY29udGFpbnM6IGBpbmRleGAgdGhlIGxvY2F0aW9uIHdoZXJlIHRoZSBzcGxpY2Ugb2NjdXJyZWQ7IGByZW1vdmVkYFxuICAgICAqIHRoZSBhcnJheSBvZiByZW1vdmVkIGl0ZW1zIGZyb20gdGhpcyBsb2NhdGlvbjsgYGFkZGVkQ291bnRgIHRoZSBudW1iZXJcbiAgICAgKiBvZiBpdGVtcyBhZGRlZCBhdCB0aGlzIGxvY2F0aW9uLlxuICAgICAqL1xuICAgIGNhbGN1bGF0ZVNwbGljZXNcbiAgfVxuXG59KSgpO1xuPC9zY3JpcHQ+XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi91dGlscy9hcnJheS1zcGxpY2UuaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTYgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cblxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL2FwcC1zY3JvbGwtZWZmZWN0cy1iZWhhdmlvci5odG1sXCI+XG5cbjxzY3JpcHQ+XG4gIC8qKlxuICAgKiBXaGlsZSBzY3JvbGxpbmcgZG93biwgZmFkZSBpbiB0aGUgcmVhciBiYWNrZ3JvdW5kIGxheWVyIGFuZCBmYWRlIG91dCB0aGUgZnJvbnQgYmFja2dyb3VuZFxuICAgKiBsYXllciAob3BhY2l0eSBpbnRlcnBvbGF0ZWQgYmFzZWQgb24gc2Nyb2xsIHBvc2l0aW9uKS5cbiAgICovXG4gIFBvbHltZXIuQXBwTGF5b3V0LnJlZ2lzdGVyRWZmZWN0KCdibGVuZC1iYWNrZ3JvdW5kJywge1xuICAgIC8qKiBAdGhpcyBQb2x5bWVyLkFwcExheW91dC5FbGVtZW50V2l0aEJhY2tncm91bmQgKi9cbiAgICBzZXRVcDogZnVuY3Rpb24gc2V0VXAoKSB7XG4gICAgICB2YXIgZnggPSB7fTtcbiAgICAgIGZ4LmJhY2tncm91bmRGcm9udExheWVyID0gdGhpcy5fZ2V0RE9NUmVmKCdiYWNrZ3JvdW5kRnJvbnRMYXllcicpO1xuICAgICAgZnguYmFja2dyb3VuZFJlYXJMYXllciA9IHRoaXMuX2dldERPTVJlZignYmFja2dyb3VuZFJlYXJMYXllcicpO1xuICAgICAgZnguYmFja2dyb3VuZEZyb250TGF5ZXIuc3R5bGUud2lsbENoYW5nZSA9ICdvcGFjaXR5JztcbiAgICAgIGZ4LmJhY2tncm91bmRGcm9udExheWVyLnN0eWxlLnRyYW5zZm9ybSA9ICd0cmFuc2xhdGVaKDApJztcbiAgICAgIGZ4LmJhY2tncm91bmRSZWFyTGF5ZXIuc3R5bGUud2lsbENoYW5nZSA9ICdvcGFjaXR5JztcbiAgICAgIGZ4LmJhY2tncm91bmRSZWFyTGF5ZXIuc3R5bGUudHJhbnNmb3JtID0gJ3RyYW5zbGF0ZVooMCknO1xuICAgICAgZnguYmFja2dyb3VuZFJlYXJMYXllci5zdHlsZS5vcGFjaXR5ID0gMDtcbiAgICAgIHRoaXMuX2Z4QmxlbmRCYWNrZ3JvdW5kID0gZng7XG4gICAgfSxcbiAgICAvKiogQHRoaXMgUG9seW1lci5BcHBMYXlvdXQuRWxlbWVudFdpdGhCYWNrZ3JvdW5kICovXG4gICAgcnVuOiBmdW5jdGlvbiBydW4ocCwgeSkge1xuICAgICAgdmFyIGZ4ID0gdGhpcy5fZnhCbGVuZEJhY2tncm91bmQ7XG4gICAgICBmeC5iYWNrZ3JvdW5kRnJvbnRMYXllci5zdHlsZS5vcGFjaXR5ID0gMSAtIHA7XG4gICAgICBmeC5iYWNrZ3JvdW5kUmVhckxheWVyLnN0eWxlLm9wYWNpdHkgPSBwO1xuICAgIH0sXG4gICAgLyoqIEB0aGlzIFBvbHltZXIuQXBwTGF5b3V0LkVsZW1lbnRXaXRoQmFja2dyb3VuZCAqL1xuICAgIHRlYXJEb3duOiBmdW5jdGlvbiB0ZWFyRG93bigpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLl9meEJsZW5kQmFja2dyb3VuZDtcbiAgICB9XG4gIH0pO1xuPC9zY3JpcHQ+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL2FwcC1sYXlvdXQvYXBwLXNjcm9sbC1lZmZlY3RzL2VmZmVjdHMvYmxlbmQtYmFja2dyb3VuZC5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNiBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuXG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vYXBwLXNjcm9sbC1lZmZlY3RzLWJlaGF2aW9yLmh0bWxcIj5cblxuPHNjcmlwdD5cbiAgLyoqXG4gICAqIFRvZ2dsZXMgdGhlIHNoYWRvdyBwcm9wZXJ0eSBpbiBhcHAtaGVhZGVyIHdoZW4gY29udGVudCBpcyBzY3JvbGxlZCB0byBjcmVhdGUgYSBzZW5zZSBvZiBkZXB0aFxuICAgKiBiZXR3ZWVuIHRoZSBlbGVtZW50IGFuZCB0aGUgY29udGVudCB1bmRlcm5lYXRoLlxuICAgKi9cbiAgUG9seW1lci5BcHBMYXlvdXQucmVnaXN0ZXJFZmZlY3QoJ3dhdGVyZmFsbCcsIHtcbiAgICAvKipcbiAgICAgKiAgQHRoaXMgUG9seW1lci5BcHBMYXlvdXQuRWxlbWVudFdpdGhCYWNrZ3JvdW5kXG4gICAgICovXG4gICAgcnVuOiBmdW5jdGlvbiBydW4oKSB7XG4gICAgICB0aGlzLnNoYWRvdyA9IHRoaXMuaXNPblNjcmVlbigpICYmIHRoaXMuaXNDb250ZW50QmVsb3coKTtcbiAgICB9XG4gIH0pO1xuPC9zY3JpcHQ+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL2FwcC1sYXlvdXQvYXBwLXNjcm9sbC1lZmZlY3RzL2VmZmVjdHMvd2F0ZXJmYWxsLmh0bWwiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi9hcHAtc2Nyb2xsLWVmZmVjdHMtYmVoYXZpb3IuaHRtbFwiPlxuXG48c2NyaXB0PlxuICAoZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gaW50ZXJwb2xhdGUocHJvZ3Jlc3MsIHBvaW50cywgZm4sIGN0eCkge1xuICAgICAgZm4uYXBwbHkoY3R4LCBwb2ludHMubWFwKGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgICAgIHJldHVybiBwb2ludFswXSArIChwb2ludFsxXSAtIHBvaW50WzBdKSAqIHByb2dyZXNzO1xuICAgICAgfSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybSB0aGUgZm9udCBzaXplIG9mIGEgZGVzaWduYXRlZCB0aXRsZSBlbGVtZW50IGJldHdlZW4gdHdvIHZhbHVlcyBiYXNlZCBvbiB0aGUgc2Nyb2xsXG4gICAgICogcG9zaXRpb24uXG4gICAgICovXG4gICAgUG9seW1lci5BcHBMYXlvdXQucmVnaXN0ZXJFZmZlY3QoJ3Jlc2l6ZS10aXRsZScsIHtcbiAgICAgIC8qKiBAdGhpcyBQb2x5bWVyLkFwcExheW91dC5FbGVtZW50V2l0aEJhY2tncm91bmQgKi9cbiAgICAgIHNldFVwOiBmdW5jdGlvbiBzZXRVcCgpIHtcbiAgICAgICAgdmFyIHRpdGxlID0gdGhpcy5fZ2V0RE9NUmVmKCdtYWluVGl0bGUnKTtcbiAgICAgICAgdmFyIGNvbmRlbnNlZFRpdGxlID0gdGhpcy5fZ2V0RE9NUmVmKCdjb25kZW5zZWRUaXRsZScpO1xuXG4gICAgICAgIGlmICghY29uZGVuc2VkVGl0bGUpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ1Njcm9sbCBlZmZlY3QgYHJlc2l6ZS10aXRsZWA6IHVuZGVmaW5lZCBgY29uZGVuc2VkLXRpdGxlYCcpO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRpdGxlKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKCdTY3JvbGwgZWZmZWN0IGByZXNpemUtdGl0bGVgOiB1bmRlZmluZWQgYG1haW4tdGl0bGVgJyk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uZGVuc2VkVGl0bGUuc3R5bGUud2lsbENoYW5nZSA9ICdvcGFjaXR5JztcbiAgICAgICAgY29uZGVuc2VkVGl0bGUuc3R5bGUud2Via2l0VHJhbnNmb3JtID0gJ3RyYW5zbGF0ZVooMCknO1xuICAgICAgICBjb25kZW5zZWRUaXRsZS5zdHlsZS50cmFuc2Zvcm0gPSAndHJhbnNsYXRlWigwKSc7XG4gICAgICAgIGNvbmRlbnNlZFRpdGxlLnN0eWxlLndlYmtpdFRyYW5zZm9ybU9yaWdpbiA9ICdsZWZ0IHRvcCc7XG4gICAgICAgIGNvbmRlbnNlZFRpdGxlLnN0eWxlLnRyYW5zZm9ybU9yaWdpbiA9ICdsZWZ0IHRvcCc7XG5cbiAgICAgICAgdGl0bGUuc3R5bGUud2lsbENoYW5nZSA9ICdvcGFjaXR5JztcbiAgICAgICAgdGl0bGUuc3R5bGUud2Via2l0VHJhbnNmb3JtT3JpZ2luID0gJ2xlZnQgdG9wJztcbiAgICAgICAgdGl0bGUuc3R5bGUudHJhbnNmb3JtT3JpZ2luID0gJ2xlZnQgdG9wJztcbiAgICAgICAgdGl0bGUuc3R5bGUud2Via2l0VHJhbnNmb3JtID0gJ3RyYW5zbGF0ZVooMCknO1xuICAgICAgICB0aXRsZS5zdHlsZS50cmFuc2Zvcm0gPSAndHJhbnNsYXRlWigwKSc7XG5cbiAgICAgICAgdmFyIHRpdGxlQ2xpZW50UmVjdCA9IHRpdGxlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB2YXIgY29uZGVuc2VkVGl0bGVDbGllbnRSZWN0ID0gY29uZGVuc2VkVGl0bGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHZhciBmeCA9IHt9O1xuXG4gICAgICAgIGZ4LnNjYWxlID0gcGFyc2VJbnQod2luZG93LmdldENvbXB1dGVkU3R5bGUoY29uZGVuc2VkVGl0bGUpWydmb250LXNpemUnXSwgMTApIC9cbiAgICAgICAgICAgIHBhcnNlSW50KHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRpdGxlKVsnZm9udC1zaXplJ10sIDEwKTtcbiAgICAgICAgZngudGl0bGVEWCA9IHRpdGxlQ2xpZW50UmVjdC5sZWZ0IC0gY29uZGVuc2VkVGl0bGVDbGllbnRSZWN0LmxlZnQ7XG4gICAgICAgIGZ4LnRpdGxlRFkgPSB0aXRsZUNsaWVudFJlY3QudG9wIC0gY29uZGVuc2VkVGl0bGVDbGllbnRSZWN0LnRvcDtcbiAgICAgICAgZnguY29uZGVuc2VkVGl0bGUgPSBjb25kZW5zZWRUaXRsZTtcbiAgICAgICAgZngudGl0bGUgPSB0aXRsZTtcblxuICAgICAgICB0aGlzLl9meFJlc2l6ZVRpdGxlID0gZng7XG4gICAgICB9LFxuICAgICAgLyoqIEB0aGlzIFBvbHltZXJFbGVtZW50ICovXG4gICAgICBydW46IGZ1bmN0aW9uIHJ1bihwLCB5KSB7XG4gICAgICAgIHZhciBmeCA9IHRoaXMuX2Z4UmVzaXplVGl0bGU7XG4gICAgICAgIGlmICghdGhpcy5jb25kZW5zZXMpIHtcbiAgICAgICAgICB5ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocCA+PSAxKSB7XG4gICAgICAgICAgZngudGl0bGUuc3R5bGUub3BhY2l0eSA9IDA7XG4gICAgICAgICAgZnguY29uZGVuc2VkVGl0bGUuc3R5bGUub3BhY2l0eSA9IDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZngudGl0bGUuc3R5bGUub3BhY2l0eSA9IDE7XG4gICAgICAgICAgZnguY29uZGVuc2VkVGl0bGUuc3R5bGUub3BhY2l0eSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaW50ZXJwb2xhdGUoTWF0aC5taW4oMSwgcCksIFsgWzEsIGZ4LnNjYWxlXSwgWzAsIC1meC50aXRsZURYXSwgW3ksIHktZngudGl0bGVEWV0gXSxcbiAgICAgICAgICBmdW5jdGlvbihzY2FsZSwgdHJhbnNsYXRlWCwgdHJhbnNsYXRlWSkge1xuICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm0oJ3RyYW5zbGF0ZSgnICsgdHJhbnNsYXRlWCArICdweCwgJyArIHRyYW5zbGF0ZVkgKyAncHgpICcgK1xuICAgICAgICAgICAgICAgICdzY2FsZTNkKCcgKyBzY2FsZSArICcsICcgKyBzY2FsZSArICcsIDEpJywgZngudGl0bGUpO1xuICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgfSxcbiAgICAgIC8qKiBAdGhpcyBQb2x5bWVyLkFwcExheW91dC5FbGVtZW50V2l0aEJhY2tncm91bmQgKi9cbiAgICAgIHRlYXJEb3duOiBmdW5jdGlvbiB0ZWFyRG93bigpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuX2Z4UmVzaXplVGl0bGU7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pKCk7XG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvYXBwLWxheW91dC9hcHAtc2Nyb2xsLWVmZmVjdHMvZWZmZWN0cy9yZXNpemUtdGl0bGUuaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTYgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cblxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL2FwcC1zY3JvbGwtZWZmZWN0cy1iZWhhdmlvci5odG1sXCI+XG5cbjxzY3JpcHQ+XG4gIC8qKlxuICAgKiBWZXJ0aWNhbGx5IHRyYW5zbGF0ZSB0aGUgYmFja2dyb3VuZCBiYXNlZCBvbiBhIGZhY3RvciBvZiB0aGUgc2Nyb2xsIHBvc2l0aW9uLlxuICAgKi9cbiAgUG9seW1lci5BcHBMYXlvdXQucmVnaXN0ZXJFZmZlY3QoJ3BhcmFsbGF4LWJhY2tncm91bmQnLCB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHt7c2NhbGFyOiBzdHJpbmd9fSBjb25maWdcbiAgICAgKiBAdGhpcyBQb2x5bWVyLkFwcExheW91dC5FbGVtZW50V2l0aEJhY2tncm91bmRcbiAgICAgKi9cbiAgICBzZXRVcDogZnVuY3Rpb24gc2V0VXAoY29uZmlnKSB7XG4gICAgICB2YXIgZnggPSB7fTtcbiAgICAgIHZhciBzY2FsYXIgPSBwYXJzZUZsb2F0KGNvbmZpZy5zY2FsYXIpO1xuICAgICAgZnguYmFja2dyb3VuZCA9IHRoaXMuX2dldERPTVJlZignYmFja2dyb3VuZCcpO1xuICAgICAgZnguYmFja2dyb3VuZEZyb250TGF5ZXIgPSB0aGlzLl9nZXRET01SZWYoJ2JhY2tncm91bmRGcm9udExheWVyJyk7XG4gICAgICBmeC5iYWNrZ3JvdW5kUmVhckxheWVyID0gdGhpcy5fZ2V0RE9NUmVmKCdiYWNrZ3JvdW5kUmVhckxheWVyJyk7XG4gICAgICBmeC5kZWx0YUJnID0gZnguYmFja2dyb3VuZEZyb250TGF5ZXIub2Zmc2V0SGVpZ2h0IC0gZnguYmFja2dyb3VuZC5vZmZzZXRIZWlnaHQ7XG4gICAgICBpZiAoZnguZGVsdGFCZyA9PT0gMCkge1xuICAgICAgICBpZiAoaXNOYU4oc2NhbGFyKSkge1xuICAgICAgICAgIHNjYWxhciA9IDAuODtcbiAgICAgICAgfVxuICAgICAgICBmeC5kZWx0YUJnID0gdGhpcy5fZEhlaWdodCAqIHNjYWxhcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc05hTihzY2FsYXIpKSB7XG4gICAgICAgICAgc2NhbGFyID0gMTtcbiAgICAgICAgfVxuICAgICAgICBmeC5kZWx0YUJnID0gZnguZGVsdGFCZyAqIHNjYWxhcjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2Z4UGFyYWxsYXhCYWNrZ3JvdW5kID0gZng7XG4gICAgfSxcbiAgICAvKiogQHRoaXMgUG9seW1lci5BcHBMYXlvdXQuRWxlbWVudFdpdGhCYWNrZ3JvdW5kICovXG4gICAgcnVuOiBmdW5jdGlvbiBydW4ocCwgeSkge1xuICAgICAgdmFyIGZ4ID0gdGhpcy5fZnhQYXJhbGxheEJhY2tncm91bmQ7XG4gICAgICB0aGlzLnRyYW5zZm9ybSgndHJhbnNsYXRlM2QoMHB4LCAnICsgKGZ4LmRlbHRhQmcgKiBNYXRoLm1pbigxLCBwKSkgKyAncHgsIDBweCknLCBmeC5iYWNrZ3JvdW5kRnJvbnRMYXllcik7XG4gICAgICBpZiAoZnguYmFja2dyb3VuZFJlYXJMYXllcikge1xuICAgICAgICB0aGlzLnRyYW5zZm9ybSgndHJhbnNsYXRlM2QoMHB4LCAnICsgKGZ4LmRlbHRhQmcgKiBNYXRoLm1pbigxLCBwKSkgKyAncHgsIDBweCknLCBmeC5iYWNrZ3JvdW5kUmVhckxheWVyKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8qKiBAdGhpcyBQb2x5bWVyLkFwcExheW91dC5FbGVtZW50V2l0aEJhY2tncm91bmQgKi9cbiAgICB0ZWFyRG93bjogZnVuY3Rpb24gdGVhckRvd24oKSB7XG4gICAgICBkZWxldGUgdGhpcy5fZnhQYXJhbGxheEJhY2tncm91bmQ7XG4gICAgfVxuICB9KTtcbjwvc2NyaXB0PlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9hcHAtbGF5b3V0L2FwcC1zY3JvbGwtZWZmZWN0cy9lZmZlY3RzL3BhcmFsbGF4LWJhY2tncm91bmQuaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTUgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cblxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3BvbHltZXIvcG9seW1lci5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiaXJvbi1zZWxlY3Rpb24uaHRtbFwiPlxuXG48c2NyaXB0PlxuICAvKipcbiAgICogQHBvbHltZXJCZWhhdmlvciBQb2x5bWVyLklyb25TZWxlY3RhYmxlQmVoYXZpb3JcbiAgICovXG4gIFBvbHltZXIuSXJvblNlbGVjdGFibGVCZWhhdmlvciA9IHtcblxuICAgICAgLyoqXG4gICAgICAgKiBGaXJlZCB3aGVuIGlyb24tc2VsZWN0b3IgaXMgYWN0aXZhdGVkIChzZWxlY3RlZCBvciBkZXNlbGVjdGVkKS5cbiAgICAgICAqIEl0IGlzIGZpcmVkIGJlZm9yZSB0aGUgc2VsZWN0ZWQgaXRlbXMgYXJlIGNoYW5nZWQuXG4gICAgICAgKiBDYW5jZWwgdGhlIGV2ZW50IHRvIGFib3J0IHNlbGVjdGlvbi5cbiAgICAgICAqXG4gICAgICAgKiBAZXZlbnQgaXJvbi1hY3RpdmF0ZVxuICAgICAgICovXG5cbiAgICAgIC8qKlxuICAgICAgICogRmlyZWQgd2hlbiBhbiBpdGVtIGlzIHNlbGVjdGVkXG4gICAgICAgKlxuICAgICAgICogQGV2ZW50IGlyb24tc2VsZWN0XG4gICAgICAgKi9cblxuICAgICAgLyoqXG4gICAgICAgKiBGaXJlZCB3aGVuIGFuIGl0ZW0gaXMgZGVzZWxlY3RlZFxuICAgICAgICpcbiAgICAgICAqIEBldmVudCBpcm9uLWRlc2VsZWN0XG4gICAgICAgKi9cblxuICAgICAgLyoqXG4gICAgICAgKiBGaXJlZCB3aGVuIHRoZSBsaXN0IG9mIHNlbGVjdGFibGUgaXRlbXMgY2hhbmdlcyAoZS5nLiwgaXRlbXMgYXJlXG4gICAgICAgKiBhZGRlZCBvciByZW1vdmVkKS4gVGhlIGRldGFpbCBvZiB0aGUgZXZlbnQgaXMgYSBtdXRhdGlvbiByZWNvcmQgdGhhdFxuICAgICAgICogZGVzY3JpYmVzIHdoYXQgY2hhbmdlZC5cbiAgICAgICAqXG4gICAgICAgKiBAZXZlbnQgaXJvbi1pdGVtcy1jaGFuZ2VkXG4gICAgICAgKi9cblxuICAgIHByb3BlcnRpZXM6IHtcblxuICAgICAgLyoqXG4gICAgICAgKiBJZiB5b3Ugd2FudCB0byB1c2UgYW4gYXR0cmlidXRlIHZhbHVlIG9yIHByb3BlcnR5IG9mIGFuIGVsZW1lbnQgZm9yXG4gICAgICAgKiBgc2VsZWN0ZWRgIGluc3RlYWQgb2YgdGhlIGluZGV4LCBzZXQgdGhpcyB0byB0aGUgbmFtZSBvZiB0aGUgYXR0cmlidXRlXG4gICAgICAgKiBvciBwcm9wZXJ0eS4gSHlwaGVuYXRlZCB2YWx1ZXMgYXJlIGNvbnZlcnRlZCB0byBjYW1lbCBjYXNlIHdoZW4gdXNlZCB0b1xuICAgICAgICogbG9vayB1cCB0aGUgcHJvcGVydHkgb2YgYSBzZWxlY3RhYmxlIGVsZW1lbnQuIENhbWVsIGNhc2VkIHZhbHVlcyBhcmVcbiAgICAgICAqICpub3QqIGNvbnZlcnRlZCB0byBoeXBoZW5hdGVkIHZhbHVlcyBmb3IgYXR0cmlidXRlIGxvb2t1cC4gSXQnc1xuICAgICAgICogcmVjb21tZW5kZWQgdGhhdCB5b3UgcHJvdmlkZSB0aGUgaHlwaGVuYXRlZCBmb3JtIG9mIHRoZSBuYW1lIHNvIHRoYXRcbiAgICAgICAqIHNlbGVjdGlvbiB3b3JrcyBpbiBib3RoIGNhc2VzLiAoVXNlIGBhdHRyLW9yLXByb3BlcnR5LW5hbWVgIGluc3RlYWQgb2ZcbiAgICAgICAqIGBhdHRyT3JQcm9wZXJ0eU5hbWVgLilcbiAgICAgICAqL1xuICAgICAgYXR0ckZvclNlbGVjdGVkOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgdmFsdWU6IG51bGxcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBzZWxlY3RlZCBlbGVtZW50LiBUaGUgZGVmYXVsdCBpcyB0byB1c2UgdGhlIGluZGV4IG9mIHRoZSBpdGVtLlxuICAgICAgICogQHR5cGUge3N0cmluZ3xudW1iZXJ9XG4gICAgICAgKi9cbiAgICAgIHNlbGVjdGVkOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgbm90aWZ5OiB0cnVlXG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBpdGVtLlxuICAgICAgICpcbiAgICAgICAqIEB0eXBlIHs/T2JqZWN0fVxuICAgICAgICovXG4gICAgICBzZWxlY3RlZEl0ZW06IHtcbiAgICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgICByZWFkT25seTogdHJ1ZSxcbiAgICAgICAgbm90aWZ5OiB0cnVlXG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFRoZSBldmVudCB0aGF0IGZpcmVzIGZyb20gaXRlbXMgd2hlbiB0aGV5IGFyZSBzZWxlY3RlZC4gU2VsZWN0YWJsZVxuICAgICAgICogd2lsbCBsaXN0ZW4gZm9yIHRoaXMgZXZlbnQgZnJvbSBpdGVtcyBhbmQgdXBkYXRlIHRoZSBzZWxlY3Rpb24gc3RhdGUuXG4gICAgICAgKiBTZXQgdG8gZW1wdHkgc3RyaW5nIHRvIGxpc3RlbiB0byBubyBldmVudHMuXG4gICAgICAgKi9cbiAgICAgIGFjdGl2YXRlRXZlbnQ6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICB2YWx1ZTogJ3RhcCcsXG4gICAgICAgIG9ic2VydmVyOiAnX2FjdGl2YXRlRXZlbnRDaGFuZ2VkJ1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBUaGlzIGlzIGEgQ1NTIHNlbGVjdG9yIHN0cmluZy4gIElmIHRoaXMgaXMgc2V0LCBvbmx5IGl0ZW1zIHRoYXQgbWF0Y2ggdGhlIENTUyBzZWxlY3RvclxuICAgICAgICogYXJlIHNlbGVjdGFibGUuXG4gICAgICAgKi9cbiAgICAgIHNlbGVjdGFibGU6IFN0cmluZyxcblxuICAgICAgLyoqXG4gICAgICAgKiBUaGUgY2xhc3MgdG8gc2V0IG9uIGVsZW1lbnRzIHdoZW4gc2VsZWN0ZWQuXG4gICAgICAgKi9cbiAgICAgIHNlbGVjdGVkQ2xhc3M6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICB2YWx1ZTogJ2lyb24tc2VsZWN0ZWQnXG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFRoZSBhdHRyaWJ1dGUgdG8gc2V0IG9uIGVsZW1lbnRzIHdoZW4gc2VsZWN0ZWQuXG4gICAgICAgKi9cbiAgICAgIHNlbGVjdGVkQXR0cmlidXRlOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgdmFsdWU6IG51bGxcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogRGVmYXVsdCBmYWxsYmFjayBpZiB0aGUgc2VsZWN0aW9uIGJhc2VkIG9uIHNlbGVjdGVkIHdpdGggYGF0dHJGb3JTZWxlY3RlZGBcbiAgICAgICAqIGlzIG5vdCBmb3VuZC5cbiAgICAgICAqL1xuICAgICAgZmFsbGJhY2tTZWxlY3Rpb246IHtcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICB2YWx1ZTogbnVsbFxuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBUaGUgbGlzdCBvZiBpdGVtcyBmcm9tIHdoaWNoIGEgc2VsZWN0aW9uIGNhbiBiZSBtYWRlLlxuICAgICAgICovXG4gICAgICBpdGVtczoge1xuICAgICAgICB0eXBlOiBBcnJheSxcbiAgICAgICAgcmVhZE9ubHk6IHRydWUsXG4gICAgICAgIG5vdGlmeTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBUaGUgc2V0IG9mIGV4Y2x1ZGVkIGVsZW1lbnRzIHdoZXJlIHRoZSBrZXkgaXMgdGhlIGBsb2NhbE5hbWVgXG4gICAgICAgKiBvZiB0aGUgZWxlbWVudCB0aGF0IHdpbGwgYmUgaWdub3JlZCBmcm9tIHRoZSBpdGVtIGxpc3QuXG4gICAgICAgKlxuICAgICAgICogQGRlZmF1bHQge3RlbXBsYXRlOiAxfVxuICAgICAgICovXG4gICAgICBfZXhjbHVkZWRMb2NhbE5hbWVzOiB7XG4gICAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAndGVtcGxhdGUnOiAxLFxuICAgICAgICAgICAgJ2RvbS1iaW5kJzogMSxcbiAgICAgICAgICAgICdkb20taWYnOiAxLFxuICAgICAgICAgICAgJ2RvbS1yZXBlYXQnOiAxLFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgb2JzZXJ2ZXJzOiBbXG4gICAgICAnX3VwZGF0ZUF0dHJGb3JTZWxlY3RlZChhdHRyRm9yU2VsZWN0ZWQpJyxcbiAgICAgICdfdXBkYXRlU2VsZWN0ZWQoc2VsZWN0ZWQpJyxcbiAgICAgICdfY2hlY2tGYWxsYmFjayhmYWxsYmFja1NlbGVjdGlvbiknXG4gICAgXSxcblxuICAgIGNyZWF0ZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fYmluZEZpbHRlckl0ZW0gPSB0aGlzLl9maWx0ZXJJdGVtLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLl9zZWxlY3Rpb24gPSBuZXcgUG9seW1lci5Jcm9uU2VsZWN0aW9uKHRoaXMuX2FwcGx5U2VsZWN0aW9uLmJpbmQodGhpcykpO1xuICAgIH0sXG5cbiAgICBhdHRhY2hlZDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9vYnNlcnZlciA9IHRoaXMuX29ic2VydmVJdGVtcyh0aGlzKTtcbiAgICAgIHRoaXMuX2FkZExpc3RlbmVyKHRoaXMuYWN0aXZhdGVFdmVudCk7XG4gICAgfSxcblxuICAgIGRldGFjaGVkOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLl9vYnNlcnZlcikge1xuICAgICAgICBQb2x5bWVyLmRvbSh0aGlzKS51bm9ic2VydmVOb2Rlcyh0aGlzLl9vYnNlcnZlcik7XG4gICAgICB9XG4gICAgICB0aGlzLl9yZW1vdmVMaXN0ZW5lcih0aGlzLmFjdGl2YXRlRXZlbnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZ2l2ZW4gaXRlbS5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgaW5kZXhPZlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtXG4gICAgICogQHJldHVybnMgUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGl0ZW1cbiAgICAgKi9cbiAgICBpbmRleE9mOiBmdW5jdGlvbihpdGVtKSB7XG4gICAgICByZXR1cm4gdGhpcy5pdGVtcy5pbmRleE9mKGl0ZW0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZWxlY3RzIHRoZSBnaXZlbiB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBtZXRob2Qgc2VsZWN0XG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSB2YWx1ZSB0aGUgdmFsdWUgdG8gc2VsZWN0LlxuICAgICAqL1xuICAgIHNlbGVjdDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHRoaXMuc2VsZWN0ZWQgPSB2YWx1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2VsZWN0cyB0aGUgcHJldmlvdXMgaXRlbS5cbiAgICAgKlxuICAgICAqIEBtZXRob2Qgc2VsZWN0UHJldmlvdXNcbiAgICAgKi9cbiAgICBzZWxlY3RQcmV2aW91czogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gdGhpcy5pdGVtcy5sZW5ndGg7XG4gICAgICB2YXIgaW5kZXggPSAoTnVtYmVyKHRoaXMuX3ZhbHVlVG9JbmRleCh0aGlzLnNlbGVjdGVkKSkgLSAxICsgbGVuZ3RoKSAlIGxlbmd0aDtcbiAgICAgIHRoaXMuc2VsZWN0ZWQgPSB0aGlzLl9pbmRleFRvVmFsdWUoaW5kZXgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZWxlY3RzIHRoZSBuZXh0IGl0ZW0uXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHNlbGVjdE5leHRcbiAgICAgKi9cbiAgICBzZWxlY3ROZXh0OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBpbmRleCA9IChOdW1iZXIodGhpcy5fdmFsdWVUb0luZGV4KHRoaXMuc2VsZWN0ZWQpKSArIDEpICUgdGhpcy5pdGVtcy5sZW5ndGg7XG4gICAgICB0aGlzLnNlbGVjdGVkID0gdGhpcy5faW5kZXhUb1ZhbHVlKGluZGV4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2VsZWN0cyB0aGUgaXRlbSBhdCB0aGUgZ2l2ZW4gaW5kZXguXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHNlbGVjdEluZGV4XG4gICAgICovXG4gICAgc2VsZWN0SW5kZXg6IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICB0aGlzLnNlbGVjdCh0aGlzLl9pbmRleFRvVmFsdWUoaW5kZXgpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRm9yY2UgYSBzeW5jaHJvbm91cyB1cGRhdGUgb2YgdGhlIGBpdGVtc2AgcHJvcGVydHkuXG4gICAgICpcbiAgICAgKiBOT1RFOiBDb25zaWRlciBsaXN0ZW5pbmcgZm9yIHRoZSBgaXJvbi1pdGVtcy1jaGFuZ2VkYCBldmVudCB0byByZXNwb25kIHRvXG4gICAgICogdXBkYXRlcyB0byB0aGUgc2V0IG9mIHNlbGVjdGFibGUgaXRlbXMgYWZ0ZXIgdXBkYXRlcyB0byB0aGUgRE9NIGxpc3QgYW5kXG4gICAgICogc2VsZWN0aW9uIHN0YXRlIGhhdmUgYmVlbiBtYWRlLlxuICAgICAqXG4gICAgICogV0FSTklORzogSWYgeW91IGFyZSB1c2luZyB0aGlzIG1ldGhvZCwgeW91IHNob3VsZCBwcm9iYWJseSBjb25zaWRlciBhblxuICAgICAqIGFsdGVybmF0ZSBhcHByb2FjaC4gU3luY2hyb25vdXNseSBxdWVyeWluZyBmb3IgaXRlbXMgaXMgcG90ZW50aWFsbHlcbiAgICAgKiBzbG93IGZvciBtYW55IHVzZSBjYXNlcy4gVGhlIGBpdGVtc2AgcHJvcGVydHkgd2lsbCB1cGRhdGUgYXN5bmNocm9ub3VzbHlcbiAgICAgKiBvbiBpdHMgb3duIHRvIHJlZmxlY3Qgc2VsZWN0YWJsZSBpdGVtcyBpbiB0aGUgRE9NLlxuICAgICAqL1xuICAgIGZvcmNlU3luY2hyb25vdXNJdGVtVXBkYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLl9vYnNlcnZlciAmJiB0eXBlb2YgdGhpcy5fb2JzZXJ2ZXIuZmx1c2ggPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAvLyBOT1RFKGJpY2tuZWxscik6IGBQb2x5bWVyLmRvbS5mbHVzaGAgYWJvdmUgaXMgbm8gbG9uZ2VyIHN1ZmZpY2llbnQgdG9cbiAgICAgICAgLy8gdHJpZ2dlciBgb2JzZXJ2ZU5vZGVzYCBjYWxsYmFja3MuIFBvbHltZXIgMi54IHJldHVybnMgYW4gb2JqZWN0IGZyb21cbiAgICAgICAgLy8gYG9ic2VydmVOb2Rlc2Agd2l0aCBhIGBmbHVzaGAgdGhhdCBzeW5jaHJvbm91c2x5IGdpdmVzIHRoZSBjYWxsYmFja1xuICAgICAgICAvLyBhbnkgcGVuZGluZyBNdXRhdGlvblJlY29yZHMgKHJldHJpZXZlZCB3aXRoIGB0YWtlUmVjb3Jkc2ApLiBBbnkgY2FzZVxuICAgICAgICAvLyB3aGVyZSBTaGFkeURPTSBmbHVzaGVzIHdlcmUgZXhwZWN0ZWQgdG8gc3luY2hyb25vdXNseSB0cmlnZ2VyIGl0ZW1cbiAgICAgICAgLy8gdXBkYXRlcyB3aWxsIG5vdyByZXF1aXJlIGNhbGxpbmcgYGZvcmNlU3luY2hyb25vdXNJdGVtVXBkYXRlYC5cbiAgICAgICAgdGhpcy5fb2JzZXJ2ZXIuZmx1c2goKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUl0ZW1zKCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8vIFVOVVNFRCwgRk9SIEFQSSBDT01QQVRJQklMSVRZXG4gICAgZ2V0IF9zaG91bGRVcGRhdGVTZWxlY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZWxlY3RlZCAhPSBudWxsO1xuICAgIH0sXG5cbiAgICBfY2hlY2tGYWxsYmFjazogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl91cGRhdGVTZWxlY3RlZCgpO1xuICAgIH0sXG5cbiAgICBfYWRkTGlzdGVuZXI6IGZ1bmN0aW9uKGV2ZW50TmFtZSkge1xuICAgICAgdGhpcy5saXN0ZW4odGhpcywgZXZlbnROYW1lLCAnX2FjdGl2YXRlSGFuZGxlcicpO1xuICAgIH0sXG5cbiAgICBfcmVtb3ZlTGlzdGVuZXI6IGZ1bmN0aW9uKGV2ZW50TmFtZSkge1xuICAgICAgdGhpcy51bmxpc3Rlbih0aGlzLCBldmVudE5hbWUsICdfYWN0aXZhdGVIYW5kbGVyJyk7XG4gICAgfSxcblxuICAgIF9hY3RpdmF0ZUV2ZW50Q2hhbmdlZDogZnVuY3Rpb24oZXZlbnROYW1lLCBvbGQpIHtcbiAgICAgIHRoaXMuX3JlbW92ZUxpc3RlbmVyKG9sZCk7XG4gICAgICB0aGlzLl9hZGRMaXN0ZW5lcihldmVudE5hbWUpO1xuICAgIH0sXG5cbiAgICBfdXBkYXRlSXRlbXM6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG5vZGVzID0gUG9seW1lci5kb20odGhpcykucXVlcnlEaXN0cmlidXRlZEVsZW1lbnRzKHRoaXMuc2VsZWN0YWJsZSB8fCAnKicpO1xuICAgICAgbm9kZXMgPSBBcnJheS5wcm90b3R5cGUuZmlsdGVyLmNhbGwobm9kZXMsIHRoaXMuX2JpbmRGaWx0ZXJJdGVtKTtcbiAgICAgIHRoaXMuX3NldEl0ZW1zKG5vZGVzKTtcbiAgICB9LFxuXG4gICAgX3VwZGF0ZUF0dHJGb3JTZWxlY3RlZDogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5zZWxlY3RlZEl0ZW0pIHtcbiAgICAgICAgdGhpcy5zZWxlY3RlZCA9IHRoaXMuX3ZhbHVlRm9ySXRlbSh0aGlzLnNlbGVjdGVkSXRlbSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIF91cGRhdGVTZWxlY3RlZDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9zZWxlY3RTZWxlY3RlZCh0aGlzLnNlbGVjdGVkKTtcbiAgICB9LFxuXG4gICAgX3NlbGVjdFNlbGVjdGVkOiBmdW5jdGlvbihzZWxlY3RlZCkge1xuICAgICAgaWYgKCF0aGlzLml0ZW1zKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGl0ZW0gPSB0aGlzLl92YWx1ZVRvSXRlbSh0aGlzLnNlbGVjdGVkKTtcbiAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgIHRoaXMuX3NlbGVjdGlvbi5zZWxlY3QoaXRlbSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9zZWxlY3Rpb24uY2xlYXIoKTtcbiAgICAgIH1cbiAgICAgIC8vIENoZWNrIGZvciBpdGVtcywgc2luY2UgdGhpcyBhcnJheSBpcyBwb3B1bGF0ZWQgb25seSB3aGVuIGF0dGFjaGVkXG4gICAgICAvLyBTaW5jZSBOdW1iZXIoMCkgaXMgZmFsc3ksIGV4cGxpY2l0bHkgY2hlY2sgZm9yIHVuZGVmaW5lZFxuICAgICAgaWYgKHRoaXMuZmFsbGJhY2tTZWxlY3Rpb24gJiYgdGhpcy5pdGVtcy5sZW5ndGggJiYgKHRoaXMuX3NlbGVjdGlvbi5nZXQoKSA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICB0aGlzLnNlbGVjdGVkID0gdGhpcy5mYWxsYmFja1NlbGVjdGlvbjtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgX2ZpbHRlckl0ZW06IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHJldHVybiAhdGhpcy5fZXhjbHVkZWRMb2NhbE5hbWVzW25vZGUubG9jYWxOYW1lXTtcbiAgICB9LFxuXG4gICAgX3ZhbHVlVG9JdGVtOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuICh2YWx1ZSA9PSBudWxsKSA/IG51bGwgOiB0aGlzLml0ZW1zW3RoaXMuX3ZhbHVlVG9JbmRleCh2YWx1ZSldO1xuICAgIH0sXG5cbiAgICBfdmFsdWVUb0luZGV4OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgaWYgKHRoaXMuYXR0ckZvclNlbGVjdGVkKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBpdGVtOyBpdGVtID0gdGhpcy5pdGVtc1tpXTsgaSsrKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX3ZhbHVlRm9ySXRlbShpdGVtKSA9PSB2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gTnVtYmVyKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgX2luZGV4VG9WYWx1ZTogZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgIGlmICh0aGlzLmF0dHJGb3JTZWxlY3RlZCkge1xuICAgICAgICB2YXIgaXRlbSA9IHRoaXMuaXRlbXNbaW5kZXhdO1xuICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl92YWx1ZUZvckl0ZW0oaXRlbSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgX3ZhbHVlRm9ySXRlbTogZnVuY3Rpb24oaXRlbSkge1xuICAgICAgaWYgKCFpdGVtKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgcHJvcFZhbHVlID0gaXRlbVtQb2x5bWVyLkNhc2VNYXAuZGFzaFRvQ2FtZWxDYXNlKHRoaXMuYXR0ckZvclNlbGVjdGVkKV07XG4gICAgICByZXR1cm4gcHJvcFZhbHVlICE9IHVuZGVmaW5lZCA/IHByb3BWYWx1ZSA6IGl0ZW0uZ2V0QXR0cmlidXRlKHRoaXMuYXR0ckZvclNlbGVjdGVkKTtcbiAgICB9LFxuXG4gICAgX2FwcGx5U2VsZWN0aW9uOiBmdW5jdGlvbihpdGVtLCBpc1NlbGVjdGVkKSB7XG4gICAgICBpZiAodGhpcy5zZWxlY3RlZENsYXNzKSB7XG4gICAgICAgIHRoaXMudG9nZ2xlQ2xhc3ModGhpcy5zZWxlY3RlZENsYXNzLCBpc1NlbGVjdGVkLCBpdGVtKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnNlbGVjdGVkQXR0cmlidXRlKSB7XG4gICAgICAgIHRoaXMudG9nZ2xlQXR0cmlidXRlKHRoaXMuc2VsZWN0ZWRBdHRyaWJ1dGUsIGlzU2VsZWN0ZWQsIGl0ZW0pO1xuICAgICAgfVxuICAgICAgdGhpcy5fc2VsZWN0aW9uQ2hhbmdlKCk7XG4gICAgICB0aGlzLmZpcmUoJ2lyb24tJyArIChpc1NlbGVjdGVkID8gJ3NlbGVjdCcgOiAnZGVzZWxlY3QnKSwge2l0ZW06IGl0ZW19KTtcbiAgICB9LFxuXG4gICAgX3NlbGVjdGlvbkNoYW5nZTogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9zZXRTZWxlY3RlZEl0ZW0odGhpcy5fc2VsZWN0aW9uLmdldCgpKTtcbiAgICB9LFxuXG4gICAgLy8gb2JzZXJ2ZSBpdGVtcyBjaGFuZ2UgdW5kZXIgdGhlIGdpdmVuIG5vZGUuXG4gICAgX29ic2VydmVJdGVtczogZnVuY3Rpb24obm9kZSkge1xuICAgICAgcmV0dXJuIFBvbHltZXIuZG9tKG5vZGUpLm9ic2VydmVOb2RlcyhmdW5jdGlvbihtdXRhdGlvbikge1xuICAgICAgICB0aGlzLl91cGRhdGVJdGVtcygpO1xuICAgICAgICB0aGlzLl91cGRhdGVTZWxlY3RlZCgpO1xuXG4gICAgICAgIC8vIExldCBvdGhlciBpbnRlcmVzdGVkIHBhcnRpZXMga25vdyBhYm91dCB0aGUgY2hhbmdlIHNvIHRoYXRcbiAgICAgICAgLy8gd2UgZG9uJ3QgaGF2ZSB0byByZWNyZWF0ZSBtdXRhdGlvbiBvYnNlcnZlcnMgZXZlcnl3aGVyZS5cbiAgICAgICAgdGhpcy5maXJlKCdpcm9uLWl0ZW1zLWNoYW5nZWQnLCBtdXRhdGlvbiwge1xuICAgICAgICAgIGJ1YmJsZXM6IGZhbHNlLFxuICAgICAgICAgIGNhbmNlbGFibGU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSxcblxuICAgIF9hY3RpdmF0ZUhhbmRsZXI6IGZ1bmN0aW9uKGUpIHtcbiAgICAgIHZhciB0ID0gZS50YXJnZXQ7XG4gICAgICB2YXIgaXRlbXMgPSB0aGlzLml0ZW1zO1xuICAgICAgd2hpbGUgKHQgJiYgdCAhPSB0aGlzKSB7XG4gICAgICAgIHZhciBpID0gaXRlbXMuaW5kZXhPZih0KTtcbiAgICAgICAgaWYgKGkgPj0gMCkge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuX2luZGV4VG9WYWx1ZShpKTtcbiAgICAgICAgICB0aGlzLl9pdGVtQWN0aXZhdGUodmFsdWUsIHQpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0ID0gdC5wYXJlbnROb2RlO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBfaXRlbUFjdGl2YXRlOiBmdW5jdGlvbih2YWx1ZSwgaXRlbSkge1xuICAgICAgaWYgKCF0aGlzLmZpcmUoJ2lyb24tYWN0aXZhdGUnLFxuICAgICAgICAgIHtzZWxlY3RlZDogdmFsdWUsIGl0ZW06IGl0ZW19LCB7Y2FuY2VsYWJsZTogdHJ1ZX0pLmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgdGhpcy5zZWxlY3QodmFsdWUpO1xuICAgICAgfVxuICAgIH1cblxuICB9O1xuXG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvaXJvbi1zZWxlY3Rvci9pcm9uLXNlbGVjdGFibGUuaHRtbCIsIlxucmVxdWlyZSgnLi4vcG9seW1lci9wb2x5bWVyLmh0bWwnKTtcblxucmVxdWlyZSgnLi9jb2xvci5odG1sJyk7XG5cbmNvbnN0IFJlZ2lzdGVySHRtbFRlbXBsYXRlID0gcmVxdWlyZSgncG9seW1lci13ZWJwYWNrLWxvYWRlci9yZWdpc3Rlci1odG1sLXRlbXBsYXRlJyk7XG5cblJlZ2lzdGVySHRtbFRlbXBsYXRlLnRvQm9keShcIjxjdXN0b20tc3R5bGU+IDxzdHlsZSBpcz1jdXN0b20tc3R5bGU+aHRtbHstLXByaW1hcnktdGV4dC1jb2xvcjp2YXIoLS1saWdodC10aGVtZS10ZXh0LWNvbG9yKTstLXByaW1hcnktYmFja2dyb3VuZC1jb2xvcjp2YXIoLS1saWdodC10aGVtZS1iYWNrZ3JvdW5kLWNvbG9yKTstLXNlY29uZGFyeS10ZXh0LWNvbG9yOnZhcigtLWxpZ2h0LXRoZW1lLXNlY29uZGFyeS1jb2xvcik7LS1kaXNhYmxlZC10ZXh0LWNvbG9yOnZhcigtLWxpZ2h0LXRoZW1lLWRpc2FibGVkLWNvbG9yKTstLWRpdmlkZXItY29sb3I6dmFyKC0tbGlnaHQtdGhlbWUtZGl2aWRlci1jb2xvcik7LS1lcnJvci1jb2xvcjp2YXIoLS1wYXBlci1kZWVwLW9yYW5nZS1hNzAwKTstLXByaW1hcnktY29sb3I6dmFyKC0tcGFwZXItaW5kaWdvLTUwMCk7LS1saWdodC1wcmltYXJ5LWNvbG9yOnZhcigtLXBhcGVyLWluZGlnby0xMDApOy0tZGFyay1wcmltYXJ5LWNvbG9yOnZhcigtLXBhcGVyLWluZGlnby03MDApOy0tYWNjZW50LWNvbG9yOnZhcigtLXBhcGVyLXBpbmstYTIwMCk7LS1saWdodC1hY2NlbnQtY29sb3I6dmFyKC0tcGFwZXItcGluay1hMTAwKTstLWRhcmstYWNjZW50LWNvbG9yOnZhcigtLXBhcGVyLXBpbmstYTQwMCk7LS1saWdodC10aGVtZS1iYWNrZ3JvdW5kLWNvbG9yOiNmZmZmZmY7LS1saWdodC10aGVtZS1iYXNlLWNvbG9yOiMwMDAwMDA7LS1saWdodC10aGVtZS10ZXh0LWNvbG9yOnZhcigtLXBhcGVyLWdyZXktOTAwKTstLWxpZ2h0LXRoZW1lLXNlY29uZGFyeS1jb2xvcjojNzM3MzczOy0tbGlnaHQtdGhlbWUtZGlzYWJsZWQtY29sb3I6IzliOWI5YjstLWxpZ2h0LXRoZW1lLWRpdmlkZXItY29sb3I6I2RiZGJkYjstLWRhcmstdGhlbWUtYmFja2dyb3VuZC1jb2xvcjp2YXIoLS1wYXBlci1ncmV5LTkwMCk7LS1kYXJrLXRoZW1lLWJhc2UtY29sb3I6I2ZmZmZmZjstLWRhcmstdGhlbWUtdGV4dC1jb2xvcjojZmZmZmZmOy0tZGFyay10aGVtZS1zZWNvbmRhcnktY29sb3I6I2JjYmNiYzstLWRhcmstdGhlbWUtZGlzYWJsZWQtY29sb3I6IzY0NjQ2NDstLWRhcmstdGhlbWUtZGl2aWRlci1jb2xvcjojM2MzYzNjOy0tdGV4dC1wcmltYXJ5LWNvbG9yOnZhcigtLWRhcmstdGhlbWUtdGV4dC1jb2xvcik7LS1kZWZhdWx0LXByaW1hcnktY29sb3I6dmFyKC0tcHJpbWFyeS1jb2xvcil9PC9zdHlsZT4gPC9jdXN0b20tc3R5bGU+XCIpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9wYXBlci1zdHlsZXMvZGVmYXVsdC10aGVtZS5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNSBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuXG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vcG9seW1lci9wb2x5bWVyLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi9pcm9uLWljb24vaXJvbi1pY29uLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi9wYXBlci1iZWhhdmlvcnMvcGFwZXItaW5reS1mb2N1cy1iZWhhdmlvci5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vcGFwZXItc3R5bGVzL2RlZmF1bHQtdGhlbWUuaHRtbFwiPlxuXG48IS0tXG5NYXRlcmlhbCBkZXNpZ246IFtJY29uIHRvZ2dsZXNdKGh0dHBzOi8vd3d3Lmdvb2dsZS5jb20vZGVzaWduL3NwZWMvY29tcG9uZW50cy9idXR0b25zLmh0bWwjYnV0dG9ucy10b2dnbGUtYnV0dG9ucylcblxuYHBhcGVyLWljb24tYnV0dG9uYCBpcyBhIGJ1dHRvbiB3aXRoIGFuIGltYWdlIHBsYWNlZCBhdCB0aGUgY2VudGVyLiBXaGVuIHRoZSB1c2VyIHRvdWNoZXNcbnRoZSBidXR0b24sIGEgcmlwcGxlIGVmZmVjdCBlbWFuYXRlcyBmcm9tIHRoZSBjZW50ZXIgb2YgdGhlIGJ1dHRvbi5cblxuYHBhcGVyLWljb24tYnV0dG9uYCBkb2VzIG5vdCBpbmNsdWRlIGEgZGVmYXVsdCBpY29uIHNldC4gVG8gdXNlIGljb25zIGZyb20gdGhlIGRlZmF1bHRcbnNldCwgaW5jbHVkZSBgUG9seW1lckVsZW1lbnRzL2lyb24taWNvbnMvaXJvbi1pY29ucy5odG1sYCwgYW5kIHVzZSB0aGUgYGljb25gIGF0dHJpYnV0ZSB0byBzcGVjaWZ5IHdoaWNoIGljb25cbmZyb20gdGhlIGljb24gc2V0IHRvIHVzZS5cblxuICAgIDxwYXBlci1pY29uLWJ1dHRvbiBpY29uPVwibWVudVwiPjwvcGFwZXItaWNvbi1idXR0b24+XG5cblNlZSBbYGlyb24taWNvbnNldGBdKGlyb24taWNvbnNldCkgZm9yIG1vcmUgaW5mb3JtYXRpb24gYWJvdXRcbmhvdyB0byB1c2UgYSBjdXN0b20gaWNvbiBzZXQuXG5cbkV4YW1wbGU6XG5cbiAgICA8bGluayBocmVmPVwicGF0aC90by9pcm9uLWljb25zL2lyb24taWNvbnMuaHRtbFwiIHJlbD1cImltcG9ydFwiPlxuXG4gICAgPHBhcGVyLWljb24tYnV0dG9uIGljb249XCJmYXZvcml0ZVwiPjwvcGFwZXItaWNvbi1idXR0b24+XG4gICAgPHBhcGVyLWljb24tYnV0dG9uIHNyYz1cInN0YXIucG5nXCI+PC9wYXBlci1pY29uLWJ1dHRvbj5cblxuVG8gdXNlIGBwYXBlci1pY29uLWJ1dHRvbmAgYXMgYSBsaW5rLCB3cmFwIGl0IGluIGFuIGFuY2hvciB0YWcuIFNpbmNlIGBwYXBlci1pY29uLWJ1dHRvbmBcbndpbGwgYWxyZWFkeSByZWNlaXZlIGZvY3VzLCB5b3UgbWF5IHdhbnQgdG8gcHJldmVudCB0aGUgYW5jaG9yIHRhZyBmcm9tIHJlY2VpdmluZyBmb2N1c1xuYXMgd2VsbCBieSBzZXR0aW5nIGl0cyB0YWJpbmRleCB0byAtMS5cblxuICAgIDxhIGhyZWY9XCJodHRwczovL3d3dy5wb2x5bWVyLXByb2plY3Qub3JnXCIgdGFiaW5kZXg9XCItMVwiPlxuICAgICAgPHBhcGVyLWljb24tYnV0dG9uIGljb249XCJwb2x5bWVyXCI+PC9wYXBlci1pY29uLWJ1dHRvbj5cbiAgICA8L2E+XG5cbiMjIyBTdHlsaW5nXG5cblN0eWxlIHRoZSBidXR0b24gd2l0aCBDU1MgYXMgeW91IHdvdWxkIGEgbm9ybWFsIERPTSBlbGVtZW50LiBJZiB5b3UgYXJlIHVzaW5nIHRoZSBpY29uc1xucHJvdmlkZWQgYnkgYGlyb24taWNvbnNgLCB0aGV5IHdpbGwgaW5oZXJpdCB0aGUgZm9yZWdyb3VuZCBjb2xvciBvZiB0aGUgYnV0dG9uLlxuXG4gICAgLyogbWFrZSBhIHJlZCBcImZhdm9yaXRlXCIgYnV0dG9uICovXG4gICAgPHBhcGVyLWljb24tYnV0dG9uIGljb249XCJmYXZvcml0ZVwiIHN0eWxlPVwiY29sb3I6IHJlZDtcIj48L3BhcGVyLWljb24tYnV0dG9uPlxuXG5CeSBkZWZhdWx0LCB0aGUgcmlwcGxlIGlzIHRoZSBzYW1lIGNvbG9yIGFzIHRoZSBmb3JlZ3JvdW5kIGF0IDI1JSBvcGFjaXR5LiBZb3UgbWF5XG5jdXN0b21pemUgdGhlIGNvbG9yIHVzaW5nIHRoZSBgLS1wYXBlci1pY29uLWJ1dHRvbi1pbmstY29sb3JgIGN1c3RvbSBwcm9wZXJ0eS5cblxuVGhlIGZvbGxvd2luZyBjdXN0b20gcHJvcGVydGllcyBhbmQgbWl4aW5zIGFyZSBhdmFpbGFibGUgZm9yIHN0eWxpbmc6XG5cbkN1c3RvbSBwcm9wZXJ0eSB8IERlc2NyaXB0aW9uIHwgRGVmYXVsdFxuLS0tLS0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tfC0tLS0tLS0tLS1cbmAtLXBhcGVyLWljb24tYnV0dG9uLWRpc2FibGVkLXRleHRgIHwgVGhlIGNvbG9yIG9mIHRoZSBkaXNhYmxlZCBidXR0b24gfCBgLS1kaXNhYmxlZC10ZXh0LWNvbG9yYFxuYC0tcGFwZXItaWNvbi1idXR0b24taW5rLWNvbG9yYCB8IFNlbGVjdGVkL2ZvY3VzIHJpcHBsZSBjb2xvciB8IGAtLXByaW1hcnktdGV4dC1jb2xvcmBcbmAtLXBhcGVyLWljb24tYnV0dG9uYCB8IE1peGluIGZvciBhIGJ1dHRvbiB8IGB7fWBcbmAtLXBhcGVyLWljb24tYnV0dG9uLWRpc2FibGVkYCB8IE1peGluIGZvciBhIGRpc2FibGVkIGJ1dHRvbiB8IGB7fWBcbmAtLXBhcGVyLWljb24tYnV0dG9uLWhvdmVyYCB8IE1peGluIGZvciBidXR0b24gb24gaG92ZXIgfCBge31gXG5cbkBncm91cCBQYXBlciBFbGVtZW50c1xuQGVsZW1lbnQgcGFwZXItaWNvbi1idXR0b25cbkBkZW1vIGRlbW8vaW5kZXguaHRtbFxuLS0+XG5cbjxkb20tbW9kdWxlIGlkPVwicGFwZXItaWNvbi1idXR0b25cIj5cbiAgPHRlbXBsYXRlIHN0cmlwLXdoaXRlc3BhY2U+XG4gICAgPHN0eWxlPlxuICAgICAgOmhvc3Qge1xuICAgICAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgcGFkZGluZzogOHB4O1xuICAgICAgICBvdXRsaW5lOiBub25lO1xuICAgICAgICAtd2Via2l0LXVzZXItc2VsZWN0OiBub25lO1xuICAgICAgICAtbW96LXVzZXItc2VsZWN0OiBub25lO1xuICAgICAgICAtbXMtdXNlci1zZWxlY3Q6IG5vbmU7XG4gICAgICAgIHVzZXItc2VsZWN0OiBub25lO1xuICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgICAgIHotaW5kZXg6IDA7XG4gICAgICAgIGxpbmUtaGVpZ2h0OiAxO1xuXG4gICAgICAgIHdpZHRoOiA0MHB4O1xuICAgICAgICBoZWlnaHQ6IDQwcHg7XG5cbiAgICAgICAgLyogTk9URTogQm90aCB2YWx1ZXMgYXJlIG5lZWRlZCwgc2luY2Ugc29tZSBwaG9uZXMgcmVxdWlyZSB0aGUgdmFsdWUgdG8gYmUgYHRyYW5zcGFyZW50YC4gKi9cbiAgICAgICAgLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yOiByZ2JhKDAsIDAsIDAsIDApO1xuICAgICAgICAtd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3I6IHRyYW5zcGFyZW50O1xuXG4gICAgICAgIC8qIEJlY2F1c2Ugb2YgcG9seW1lci8yNTU4LCB0aGlzIHN0eWxlIGhhcyBsb3dlciBzcGVjaWZpY2l0eSB0aGFuICogKi9cbiAgICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveCAhaW1wb3J0YW50O1xuXG4gICAgICAgIEBhcHBseSAtLXBhcGVyLWljb24tYnV0dG9uO1xuICAgICAgfVxuXG4gICAgICA6aG9zdCAjaW5rIHtcbiAgICAgICAgY29sb3I6IHZhcigtLXBhcGVyLWljb24tYnV0dG9uLWluay1jb2xvciwgdmFyKC0tcHJpbWFyeS10ZXh0LWNvbG9yKSk7XG4gICAgICAgIG9wYWNpdHk6IDAuNjtcbiAgICAgIH1cblxuICAgICAgOmhvc3QoW2Rpc2FibGVkXSkge1xuICAgICAgICBjb2xvcjogdmFyKC0tcGFwZXItaWNvbi1idXR0b24tZGlzYWJsZWQtdGV4dCwgdmFyKC0tZGlzYWJsZWQtdGV4dC1jb2xvcikpO1xuICAgICAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcbiAgICAgICAgY3Vyc29yOiBhdXRvO1xuXG4gICAgICAgIEBhcHBseSAtLXBhcGVyLWljb24tYnV0dG9uLWRpc2FibGVkO1xuICAgICAgfVxuXG4gICAgICA6aG9zdChbaGlkZGVuXSkge1xuICAgICAgICBkaXNwbGF5OiBub25lICFpbXBvcnRhbnQ7XG4gICAgICB9XG5cbiAgICAgIDpob3N0KDpob3Zlcikge1xuICAgICAgICBAYXBwbHkgLS1wYXBlci1pY29uLWJ1dHRvbi1ob3ZlcjtcbiAgICAgIH1cblxuICAgICAgaXJvbi1pY29uIHtcbiAgICAgICAgLS1pcm9uLWljb24td2lkdGg6IDEwMCU7XG4gICAgICAgIC0taXJvbi1pY29uLWhlaWdodDogMTAwJTtcbiAgICAgIH1cbiAgICA8L3N0eWxlPlxuXG4gICAgPGlyb24taWNvbiBpZD1cImljb25cIiBzcmM9XCJbW3NyY11dXCIgaWNvbj1cIltbaWNvbl1dXCIgYWx0JD1cIltbYWx0XV1cIj48L2lyb24taWNvbj5cbiAgPC90ZW1wbGF0ZT5cblxuICA8c2NyaXB0PlxuICAgIFBvbHltZXIoe1xuICAgICAgaXM6ICdwYXBlci1pY29uLWJ1dHRvbicsXG5cbiAgICAgIGhvc3RBdHRyaWJ1dGVzOiB7XG4gICAgICAgIHJvbGU6ICdidXR0b24nLFxuICAgICAgICB0YWJpbmRleDogJzAnXG4gICAgICB9LFxuXG4gICAgICBiZWhhdmlvcnM6IFtcbiAgICAgICAgUG9seW1lci5QYXBlcklua3lGb2N1c0JlaGF2aW9yXG4gICAgICBdLFxuXG4gICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgVVJMIG9mIGFuIGltYWdlIGZvciB0aGUgaWNvbi4gSWYgdGhlIHNyYyBwcm9wZXJ0eSBpcyBzcGVjaWZpZWQsXG4gICAgICAgICAqIHRoZSBpY29uIHByb3BlcnR5IHNob3VsZCBub3QgYmUuXG4gICAgICAgICAqL1xuICAgICAgICBzcmM6IHtcbiAgICAgICAgICB0eXBlOiBTdHJpbmdcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmaWVzIHRoZSBpY29uIG5hbWUgb3IgaW5kZXggaW4gdGhlIHNldCBvZiBpY29ucyBhdmFpbGFibGUgaW5cbiAgICAgICAgICogdGhlIGljb24ncyBpY29uIHNldC4gSWYgdGhlIGljb24gcHJvcGVydHkgaXMgc3BlY2lmaWVkLFxuICAgICAgICAgKiB0aGUgc3JjIHByb3BlcnR5IHNob3VsZCBub3QgYmUuXG4gICAgICAgICAqL1xuICAgICAgICBpY29uOiB7XG4gICAgICAgICAgdHlwZTogU3RyaW5nXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB0aGUgYWx0ZXJuYXRlIHRleHQgZm9yIHRoZSBidXR0b24sIGZvciBhY2Nlc3NpYmlsaXR5LlxuICAgICAgICAgKi9cbiAgICAgICAgYWx0OiB7XG4gICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgIG9ic2VydmVyOiBcIl9hbHRDaGFuZ2VkXCJcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgX2FsdENoYW5nZWQ6IGZ1bmN0aW9uKG5ld1ZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICB2YXIgbGFiZWwgPSB0aGlzLmdldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcpO1xuXG4gICAgICAgIC8vIERvbid0IHN0b21wIG92ZXIgYSB1c2VyLXNldCBhcmlhLWxhYmVsLlxuICAgICAgICBpZiAoIWxhYmVsIHx8IG9sZFZhbHVlID09IGxhYmVsKSB7XG4gICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnLCBuZXdWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgPC9zY3JpcHQ+XG48L2RvbS1tb2R1bGU+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL3BhcGVyLWljb24tYnV0dG9uL3BhcGVyLWljb24tYnV0dG9uLmh0bWwiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE1IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi9wb2x5bWVyL3BvbHltZXIuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL2lyb24tbWV0YS9pcm9uLW1ldGEuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL2lyb24tZmxleC1sYXlvdXQvaXJvbi1mbGV4LWxheW91dC5odG1sXCI+XG5cbjwhLS1cblxuVGhlIGBpcm9uLWljb25gIGVsZW1lbnQgZGlzcGxheXMgYW4gaWNvbi4gQnkgZGVmYXVsdCBhbiBpY29uIHJlbmRlcnMgYXMgYSAyNHB4IHNxdWFyZS5cblxuRXhhbXBsZSB1c2luZyBzcmM6XG5cbiAgICA8aXJvbi1pY29uIHNyYz1cInN0YXIucG5nXCI+PC9pcm9uLWljb24+XG5cbkV4YW1wbGUgc2V0dGluZyBzaXplIHRvIDMycHggeCAzMnB4OlxuXG4gICAgPGlyb24taWNvbiBjbGFzcz1cImJpZ1wiIHNyYz1cImJpZ19zdGFyLnBuZ1wiPjwvaXJvbi1pY29uPlxuXG4gICAgPHN0eWxlIGlzPVwiY3VzdG9tLXN0eWxlXCI+XG4gICAgICAuYmlnIHtcbiAgICAgICAgLS1pcm9uLWljb24taGVpZ2h0OiAzMnB4O1xuICAgICAgICAtLWlyb24taWNvbi13aWR0aDogMzJweDtcbiAgICAgIH1cbiAgICA8L3N0eWxlPlxuXG5UaGUgaXJvbiBlbGVtZW50cyBpbmNsdWRlIHNldmVyYWwgc2V0cyBvZiBpY29ucy5cblRvIHVzZSB0aGUgZGVmYXVsdCBzZXQgb2YgaWNvbnMsIGltcG9ydCBgaXJvbi1pY29ucy5odG1sYCBhbmQgdXNlIHRoZSBgaWNvbmAgYXR0cmlidXRlIHRvIHNwZWNpZnkgYW4gaWNvbjpcblxuICAgIDxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIvY29tcG9uZW50cy9pcm9uLWljb25zL2lyb24taWNvbnMuaHRtbFwiPlxuXG4gICAgPGlyb24taWNvbiBpY29uPVwibWVudVwiPjwvaXJvbi1pY29uPlxuXG5UbyB1c2UgYSBkaWZmZXJlbnQgYnVpbHQtaW4gc2V0IG9mIGljb25zLCBpbXBvcnQgdGhlIHNwZWNpZmljIGBpcm9uLWljb25zLzxpY29uc2V0Pi1pY29ucy5odG1sYCwgYW5kXG5zcGVjaWZ5IHRoZSBpY29uIGFzIGA8aWNvbnNldD46PGljb24+YC4gRm9yIGV4YW1wbGUsIHRvIHVzZSBhIGNvbW11bmljYXRpb24gaWNvbiwgeW91IHdvdWxkXG51c2U6XG5cbiAgICA8bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiL2NvbXBvbmVudHMvaXJvbi1pY29ucy9jb21tdW5pY2F0aW9uLWljb25zLmh0bWxcIj5cblxuICAgIDxpcm9uLWljb24gaWNvbj1cImNvbW11bmljYXRpb246ZW1haWxcIj48L2lyb24taWNvbj5cblxuWW91IGNhbiBhbHNvIGNyZWF0ZSBjdXN0b20gaWNvbiBzZXRzIG9mIGJpdG1hcCBvciBTVkcgaWNvbnMuXG5cbkV4YW1wbGUgb2YgdXNpbmcgYW4gaWNvbiBuYW1lZCBgY2hlcnJ5YCBmcm9tIGEgY3VzdG9tIGljb25zZXQgd2l0aCB0aGUgSUQgYGZydWl0YDpcblxuICAgIDxpcm9uLWljb24gaWNvbj1cImZydWl0OmNoZXJyeVwiPjwvaXJvbi1pY29uPlxuXG5TZWUgW2lyb24taWNvbnNldF0oaXJvbi1pY29uc2V0KSBhbmQgW2lyb24taWNvbnNldC1zdmddKGlyb24taWNvbnNldC1zdmcpIGZvciBtb3JlIGluZm9ybWF0aW9uIGFib3V0XG5ob3cgdG8gY3JlYXRlIGEgY3VzdG9tIGljb25zZXQuXG5cblNlZSB0aGUgW2lyb24taWNvbnMgZGVtb10oaXJvbi1pY29ucz92aWV3PWRlbW86ZGVtby9pbmRleC5odG1sKSB0byBzZWUgdGhlIGljb25zIGF2YWlsYWJsZVxuaW4gdGhlIHZhcmlvdXMgaWNvbnNldHMuXG5cblRvIGxvYWQgYSBzdWJzZXQgb2YgaWNvbnMgZnJvbSBvbmUgb2YgdGhlIGRlZmF1bHQgYGlyb24taWNvbnNgIHNldHMsIHlvdSBjYW5cbnVzZSB0aGUgW3BvbHktaWNvbl0oaHR0cHM6Ly9wb2x5LWljb24uYXBwc3BvdC5jb20vKSB0b29sLiBJdCBhbGxvd3MgeW91XG50byBzZWxlY3QgaW5kaXZpZHVhbCBpY29ucywgYW5kIGNyZWF0ZXMgYW4gaWNvbnNldCBmcm9tIHRoZW0gdGhhdCB5b3UgY2FuXG51c2UgZGlyZWN0bHkgaW4geW91ciBlbGVtZW50cy5cblxuIyMjIFN0eWxpbmdcblxuVGhlIGZvbGxvd2luZyBjdXN0b20gcHJvcGVydGllcyBhcmUgYXZhaWxhYmxlIGZvciBzdHlsaW5nOlxuXG5DdXN0b20gcHJvcGVydHkgfCBEZXNjcmlwdGlvbiB8IERlZmF1bHRcbi0tLS0tLS0tLS0tLS0tLS18LS0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tXG5gLS1pcm9uLWljb25gIHwgTWl4aW4gYXBwbGllZCB0byB0aGUgaWNvbiB8IHt9XG5gLS1pcm9uLWljb24td2lkdGhgIHwgV2lkdGggb2YgdGhlIGljb24gfCBgMjRweGBcbmAtLWlyb24taWNvbi1oZWlnaHRgIHwgSGVpZ2h0IG9mIHRoZSBpY29uIHwgYDI0cHhgXG5gLS1pcm9uLWljb24tZmlsbC1jb2xvcmAgfCBGaWxsIGNvbG9yIG9mIHRoZSBzdmcgaWNvbiB8IGBjdXJyZW50Y29sb3JgXG5gLS1pcm9uLWljb24tc3Ryb2tlLWNvbG9yYCB8IFN0cm9rZSBjb2xvciBvZiB0aGUgc3ZnIGljb24gfCBub25lXG5cbkBncm91cCBJcm9uIEVsZW1lbnRzXG5AZWxlbWVudCBpcm9uLWljb25cbkBkZW1vIGRlbW8vaW5kZXguaHRtbFxuQGhlcm8gaGVyby5zdmdcbkBob21lcGFnZSBwb2x5bWVyLmdpdGh1Yi5pb1xuLS0+XG5cbjxkb20tbW9kdWxlIGlkPVwiaXJvbi1pY29uXCI+XG4gIDx0ZW1wbGF0ZT5cbiAgICA8c3R5bGU+XG4gICAgICA6aG9zdCB7XG4gICAgICAgIEBhcHBseSAtLWxheW91dC1pbmxpbmU7XG4gICAgICAgIEBhcHBseSAtLWxheW91dC1jZW50ZXItY2VudGVyO1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG5cbiAgICAgICAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcblxuICAgICAgICBmaWxsOiB2YXIoLS1pcm9uLWljb24tZmlsbC1jb2xvciwgY3VycmVudGNvbG9yKTtcbiAgICAgICAgc3Ryb2tlOiB2YXIoLS1pcm9uLWljb24tc3Ryb2tlLWNvbG9yLCBub25lKTtcblxuICAgICAgICB3aWR0aDogdmFyKC0taXJvbi1pY29uLXdpZHRoLCAyNHB4KTtcbiAgICAgICAgaGVpZ2h0OiB2YXIoLS1pcm9uLWljb24taGVpZ2h0LCAyNHB4KTtcbiAgICAgICAgQGFwcGx5IC0taXJvbi1pY29uO1xuICAgICAgfVxuXG4gICAgICA6aG9zdChbaGlkZGVuXSkge1xuICAgICAgICBkaXNwbGF5OiBub25lO1xuICAgICAgfVxuICAgIDwvc3R5bGU+XG4gIDwvdGVtcGxhdGU+XG5cbiAgPHNjcmlwdD5cblxuICAgIFBvbHltZXIoe1xuXG4gICAgICBpczogJ2lyb24taWNvbicsXG5cbiAgICAgIHByb3BlcnRpZXM6IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG5hbWUgb2YgdGhlIGljb24gdG8gdXNlLiBUaGUgbmFtZSBzaG91bGQgYmUgb2YgdGhlIGZvcm06XG4gICAgICAgICAqIGBpY29uc2V0X25hbWU6aWNvbl9uYW1lYC5cbiAgICAgICAgICovXG4gICAgICAgIGljb246IHtcbiAgICAgICAgICB0eXBlOiBTdHJpbmdcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG5hbWUgb2YgdGhlIHRoZW1lIHRvIHVzZWQsIGlmIG9uZSBpcyBzcGVjaWZpZWQgYnkgdGhlXG4gICAgICAgICAqIGljb25zZXQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGVtZToge1xuICAgICAgICAgIHR5cGU6IFN0cmluZ1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB1c2luZyBpcm9uLWljb24gd2l0aG91dCBhbiBpY29uc2V0LCB5b3UgY2FuIHNldCB0aGUgc3JjIHRvIGJlXG4gICAgICAgICAqIHRoZSBVUkwgb2YgYW4gaW5kaXZpZHVhbCBpY29uIGltYWdlIGZpbGUuIE5vdGUgdGhhdCB0aGlzIHdpbGwgdGFrZVxuICAgICAgICAgKiBwcmVjZWRlbmNlIG92ZXIgYSBnaXZlbiBpY29uIGF0dHJpYnV0ZS5cbiAgICAgICAgICovXG4gICAgICAgIHNyYzoge1xuICAgICAgICAgIHR5cGU6IFN0cmluZ1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7IVBvbHltZXIuSXJvbk1ldGF9XG4gICAgICAgICAqL1xuICAgICAgICBfbWV0YToge1xuICAgICAgICAgIHZhbHVlOiBQb2x5bWVyLkJhc2UuY3JlYXRlKCdpcm9uLW1ldGEnLCB7dHlwZTogJ2ljb25zZXQnfSlcbiAgICAgICAgfVxuXG4gICAgICB9LFxuXG4gICAgICBvYnNlcnZlcnM6IFtcbiAgICAgICAgJ191cGRhdGVJY29uKF9tZXRhLCBpc0F0dGFjaGVkKScsXG4gICAgICAgICdfdXBkYXRlSWNvbih0aGVtZSwgaXNBdHRhY2hlZCknLFxuICAgICAgICAnX3NyY0NoYW5nZWQoc3JjLCBpc0F0dGFjaGVkKScsXG4gICAgICAgICdfaWNvbkNoYW5nZWQoaWNvbiwgaXNBdHRhY2hlZCknXG4gICAgICBdLFxuXG4gICAgICBfREVGQVVMVF9JQ09OU0VUOiAnaWNvbnMnLFxuXG4gICAgICBfaWNvbkNoYW5nZWQ6IGZ1bmN0aW9uKGljb24pIHtcbiAgICAgICAgdmFyIHBhcnRzID0gKGljb24gfHwgJycpLnNwbGl0KCc6Jyk7XG4gICAgICAgIHRoaXMuX2ljb25OYW1lID0gcGFydHMucG9wKCk7XG4gICAgICAgIHRoaXMuX2ljb25zZXROYW1lID0gcGFydHMucG9wKCkgfHwgdGhpcy5fREVGQVVMVF9JQ09OU0VUO1xuICAgICAgICB0aGlzLl91cGRhdGVJY29uKCk7XG4gICAgICB9LFxuXG4gICAgICBfc3JjQ2hhbmdlZDogZnVuY3Rpb24oc3JjKSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUljb24oKTtcbiAgICAgIH0sXG5cbiAgICAgIF91c2VzSWNvbnNldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmljb24gfHwgIXRoaXMuc3JjO1xuICAgICAgfSxcblxuICAgICAgLyoqIEBzdXBwcmVzcyB7dmlzaWJpbGl0eX0gKi9cbiAgICAgIF91cGRhdGVJY29uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX3VzZXNJY29uc2V0KCkpIHtcbiAgICAgICAgICBpZiAodGhpcy5faW1nICYmIHRoaXMuX2ltZy5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICBQb2x5bWVyLmRvbSh0aGlzLnJvb3QpLnJlbW92ZUNoaWxkKHRoaXMuX2ltZyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLl9pY29uTmFtZSA9PT0gXCJcIikge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2ljb25zZXQpIHtcbiAgICAgICAgICAgICAgdGhpcy5faWNvbnNldC5yZW1vdmVJY29uKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5faWNvbnNldE5hbWUgJiYgdGhpcy5fbWV0YSkge1xuICAgICAgICAgICAgdGhpcy5faWNvbnNldCA9IC8qKiBAdHlwZSB7P1BvbHltZXIuSWNvbnNldH0gKi8gKFxuICAgICAgICAgICAgICB0aGlzLl9tZXRhLmJ5S2V5KHRoaXMuX2ljb25zZXROYW1lKSk7XG4gICAgICAgICAgICBpZiAodGhpcy5faWNvbnNldCkge1xuICAgICAgICAgICAgICB0aGlzLl9pY29uc2V0LmFwcGx5SWNvbih0aGlzLCB0aGlzLl9pY29uTmFtZSwgdGhpcy50aGVtZSk7XG4gICAgICAgICAgICAgIHRoaXMudW5saXN0ZW4od2luZG93LCAnaXJvbi1pY29uc2V0LWFkZGVkJywgJ191cGRhdGVJY29uJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLmxpc3Rlbih3aW5kb3csICdpcm9uLWljb25zZXQtYWRkZWQnLCAnX3VwZGF0ZUljb24nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHRoaXMuX2ljb25zZXQpIHtcbiAgICAgICAgICAgIHRoaXMuX2ljb25zZXQucmVtb3ZlSWNvbih0aGlzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCF0aGlzLl9pbWcpIHtcbiAgICAgICAgICAgIHRoaXMuX2ltZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpO1xuICAgICAgICAgICAgdGhpcy5faW1nLnN0eWxlLndpZHRoID0gJzEwMCUnO1xuICAgICAgICAgICAgdGhpcy5faW1nLnN0eWxlLmhlaWdodCA9ICcxMDAlJztcbiAgICAgICAgICAgIHRoaXMuX2ltZy5kcmFnZ2FibGUgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5faW1nLnNyYyA9IHRoaXMuc3JjO1xuICAgICAgICAgIFBvbHltZXIuZG9tKHRoaXMucm9vdCkuYXBwZW5kQ2hpbGQodGhpcy5faW1nKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgfSk7XG5cbiAgPC9zY3JpcHQ+XG5cbjwvZG9tLW1vZHVsZT5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvaXJvbi1pY29uL2lyb24taWNvbi5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNSBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuXG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vcG9seW1lci9wb2x5bWVyLmh0bWxcIj5cblxuPHNjcmlwdD5cblxuICAvKipcbiAgICogQGRlbW8gZGVtby9pbmRleC5odG1sXG4gICAqIEBwb2x5bWVyQmVoYXZpb3JcbiAgICovXG4gIFBvbHltZXIuSXJvbkNvbnRyb2xTdGF0ZSA9IHtcblxuICAgIHByb3BlcnRpZXM6IHtcblxuICAgICAgLyoqXG4gICAgICAgKiBJZiB0cnVlLCB0aGUgZWxlbWVudCBjdXJyZW50bHkgaGFzIGZvY3VzLlxuICAgICAgICovXG4gICAgICBmb2N1c2VkOiB7XG4gICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgIHZhbHVlOiBmYWxzZSxcbiAgICAgICAgbm90aWZ5OiB0cnVlLFxuICAgICAgICByZWFkT25seTogdHJ1ZSxcbiAgICAgICAgcmVmbGVjdFRvQXR0cmlidXRlOiB0cnVlXG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIElmIHRydWUsIHRoZSB1c2VyIGNhbm5vdCBpbnRlcmFjdCB3aXRoIHRoaXMgZWxlbWVudC5cbiAgICAgICAqL1xuICAgICAgZGlzYWJsZWQ6IHtcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgdmFsdWU6IGZhbHNlLFxuICAgICAgICBub3RpZnk6IHRydWUsXG4gICAgICAgIG9ic2VydmVyOiAnX2Rpc2FibGVkQ2hhbmdlZCcsXG4gICAgICAgIHJlZmxlY3RUb0F0dHJpYnV0ZTogdHJ1ZVxuICAgICAgfSxcblxuICAgICAgX29sZFRhYkluZGV4OiB7XG4gICAgICAgIHR5cGU6IE51bWJlclxuICAgICAgfSxcblxuICAgICAgX2JvdW5kRm9jdXNCbHVySGFuZGxlcjoge1xuICAgICAgICB0eXBlOiBGdW5jdGlvbixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9mb2N1c0JsdXJIYW5kbGVyLmJpbmQodGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIF9faGFuZGxlRXZlbnRSZXRhcmdldGluZzoge1xuICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuICF0aGlzLnNoYWRvd1Jvb3QgJiYgIVBvbHltZXIuRWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBvYnNlcnZlcnM6IFtcbiAgICAgICdfY2hhbmdlZENvbnRyb2xTdGF0ZShmb2N1c2VkLCBkaXNhYmxlZCknXG4gICAgXSxcblxuICAgIHJlYWR5OiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXMnLCB0aGlzLl9ib3VuZEZvY3VzQmx1ckhhbmRsZXIsIHRydWUpO1xuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgdGhpcy5fYm91bmRGb2N1c0JsdXJIYW5kbGVyLCB0cnVlKTtcbiAgICB9LFxuXG4gICAgX2ZvY3VzQmx1ckhhbmRsZXI6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAvLyBJbiBQb2x5bWVyIDIuMCwgdGhlIGxpYnJhcnkgdGFrZXMgY2FyZSBvZiByZXRhcmdldGluZyBldmVudHMuXG4gICAgICBpZiAoUG9seW1lci5FbGVtZW50KSB7XG4gICAgICAgIHRoaXMuX3NldEZvY3VzZWQoZXZlbnQudHlwZSA9PT0gJ2ZvY3VzJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gTk9URShjZGF0YSk6ICBpZiB3ZSBhcmUgaW4gU2hhZG93RE9NIGxhbmQsIGBldmVudC50YXJnZXRgIHdpbGxcbiAgICAgIC8vIGV2ZW50dWFsbHkgYmVjb21lIGB0aGlzYCBkdWUgdG8gcmV0YXJnZXRpbmc7IGlmIHdlIGFyZSBub3QgaW5cbiAgICAgIC8vIFNoYWRvd0RPTSBsYW5kLCBgZXZlbnQudGFyZ2V0YCB3aWxsIGV2ZW50dWFsbHkgYmVjb21lIGB0aGlzYCBkdWVcbiAgICAgIC8vIHRvIHRoZSBzZWNvbmQgY29uZGl0aW9uYWwgd2hpY2ggZmlyZXMgYSBzeW50aGV0aWMgZXZlbnQgKHRoYXQgaXMgYWxzb1xuICAgICAgLy8gaGFuZGxlZCkuIEluIGVpdGhlciBjYXNlLCB3ZSBjYW4gZGlzcmVnYXJkIGBldmVudC5wYXRoYC5cbiAgICAgIGlmIChldmVudC50YXJnZXQgPT09IHRoaXMpIHtcbiAgICAgICAgdGhpcy5fc2V0Rm9jdXNlZChldmVudC50eXBlID09PSAnZm9jdXMnKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fX2hhbmRsZUV2ZW50UmV0YXJnZXRpbmcpIHtcbiAgICAgICAgdmFyIHRhcmdldCA9IC8qKiBAdHlwZSB7Tm9kZX0gKi8oUG9seW1lci5kb20oZXZlbnQpLmxvY2FsVGFyZ2V0KTtcbiAgICAgICAgaWYgKCF0aGlzLmlzTGlnaHREZXNjZW5kYW50KHRhcmdldCkpIHtcbiAgICAgICAgICB0aGlzLmZpcmUoZXZlbnQudHlwZSwge3NvdXJjZUV2ZW50OiBldmVudH0sIHtcbiAgICAgICAgICAgIG5vZGU6IHRoaXMsXG4gICAgICAgICAgICBidWJibGVzOiBldmVudC5idWJibGVzLFxuICAgICAgICAgICAgY2FuY2VsYWJsZTogZXZlbnQuY2FuY2VsYWJsZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIF9kaXNhYmxlZENoYW5nZWQ6IGZ1bmN0aW9uKGRpc2FibGVkLCBvbGQpIHtcbiAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdhcmlhLWRpc2FibGVkJywgZGlzYWJsZWQgPyAndHJ1ZScgOiAnZmFsc2UnKTtcbiAgICAgIHRoaXMuc3R5bGUucG9pbnRlckV2ZW50cyA9IGRpc2FibGVkID8gJ25vbmUnIDogJyc7XG4gICAgICBpZiAoZGlzYWJsZWQpIHtcbiAgICAgICAgdGhpcy5fb2xkVGFiSW5kZXggPSB0aGlzLnRhYkluZGV4O1xuICAgICAgICB0aGlzLl9zZXRGb2N1c2VkKGZhbHNlKTtcbiAgICAgICAgdGhpcy50YWJJbmRleCA9IC0xO1xuICAgICAgICB0aGlzLmJsdXIoKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fb2xkVGFiSW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLnRhYkluZGV4ID0gdGhpcy5fb2xkVGFiSW5kZXg7XG4gICAgICB9XG4gICAgfSxcblxuICAgIF9jaGFuZ2VkQ29udHJvbFN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgIC8vIF9jb250cm9sU3RhdGVDaGFuZ2VkIGlzIGFic3RyYWN0LCBmb2xsb3ctb24gYmVoYXZpb3JzIG1heSBpbXBsZW1lbnQgaXRcbiAgICAgIGlmICh0aGlzLl9jb250cm9sU3RhdGVDaGFuZ2VkKSB7XG4gICAgICAgIHRoaXMuX2NvbnRyb2xTdGF0ZUNoYW5nZWQoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgfTtcblxuPC9zY3JpcHQ+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL2lyb24tYmVoYXZpb3JzL2lyb24tY29udHJvbC1zdGF0ZS5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNCBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuXG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vcG9seW1lci9wb2x5bWVyLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi9pcm9uLWExMXkta2V5cy1iZWhhdmlvci9pcm9uLWExMXkta2V5cy1iZWhhdmlvci5odG1sXCI+XG5cbjwhLS1cbk1hdGVyaWFsIGRlc2lnbjogW1N1cmZhY2UgcmVhY3Rpb25dKGh0dHBzOi8vd3d3Lmdvb2dsZS5jb20vZGVzaWduL3NwZWMvYW5pbWF0aW9uL3Jlc3BvbnNpdmUtaW50ZXJhY3Rpb24uaHRtbCNyZXNwb25zaXZlLWludGVyYWN0aW9uLXN1cmZhY2UtcmVhY3Rpb24pXG5cbmBwYXBlci1yaXBwbGVgIHByb3ZpZGVzIGEgdmlzdWFsIGVmZmVjdCB0aGF0IG90aGVyIHBhcGVyIGVsZW1lbnRzIGNhblxudXNlIHRvIHNpbXVsYXRlIGEgcmlwcGxpbmcgZWZmZWN0IGVtYW5hdGluZyBmcm9tIHRoZSBwb2ludCBvZiBjb250YWN0LiAgVGhlXG5lZmZlY3QgY2FuIGJlIHZpc3VhbGl6ZWQgYXMgYSBjb25jZW50cmljIGNpcmNsZSB3aXRoIG1vdGlvbi5cblxuRXhhbXBsZTpcblxuICAgIDxkaXYgc3R5bGU9XCJwb3NpdGlvbjpyZWxhdGl2ZVwiPlxuICAgICAgPHBhcGVyLXJpcHBsZT48L3BhcGVyLXJpcHBsZT5cbiAgICA8L2Rpdj5cblxuTm90ZSwgaXQncyBpbXBvcnRhbnQgdGhhdCB0aGUgcGFyZW50IGNvbnRhaW5lciBvZiB0aGUgcmlwcGxlIGJlIHJlbGF0aXZlIHBvc2l0aW9uLCBvdGhlcndpc2VcbnRoZSByaXBwbGUgd2lsbCBlbWFuYXRlIG91dHNpZGUgb2YgdGhlIGRlc2lyZWQgY29udGFpbmVyLlxuXG5gcGFwZXItcmlwcGxlYCBsaXN0ZW5zIHRvIFwibW91c2Vkb3duXCIgYW5kIFwibW91c2V1cFwiIGV2ZW50cyBzbyBpdCB3b3VsZCBkaXNwbGF5IHJpcHBsZVxuZWZmZWN0IHdoZW4gdG91Y2hlcyBvbiBpdC4gIFlvdSBjYW4gYWxzbyBkZWZlYXQgdGhlIGRlZmF1bHQgYmVoYXZpb3IgYW5kXG5tYW51YWxseSByb3V0ZSB0aGUgZG93biBhbmQgdXAgYWN0aW9ucyB0byB0aGUgcmlwcGxlIGVsZW1lbnQuICBOb3RlIHRoYXQgaXQgaXNcbmltcG9ydGFudCBpZiB5b3UgY2FsbCBgZG93bkFjdGlvbigpYCB5b3Ugd2lsbCBoYXZlIHRvIG1ha2Ugc3VyZSB0byBjYWxsXG5gdXBBY3Rpb24oKWAgc28gdGhhdCBgcGFwZXItcmlwcGxlYCB3b3VsZCBlbmQgdGhlIGFuaW1hdGlvbiBsb29wLlxuXG5FeGFtcGxlOlxuXG4gICAgPHBhcGVyLXJpcHBsZSBpZD1cInJpcHBsZVwiIHN0eWxlPVwicG9pbnRlci1ldmVudHM6IG5vbmU7XCI+PC9wYXBlci1yaXBwbGU+XG4gICAgLi4uXG4gICAgZG93bkFjdGlvbjogZnVuY3Rpb24oZSkge1xuICAgICAgdGhpcy4kLnJpcHBsZS5kb3duQWN0aW9uKGUuZGV0YWlsKTtcbiAgICB9LFxuICAgIHVwQWN0aW9uOiBmdW5jdGlvbihlKSB7XG4gICAgICB0aGlzLiQucmlwcGxlLnVwQWN0aW9uKCk7XG4gICAgfVxuXG5TdHlsaW5nIHJpcHBsZSBlZmZlY3Q6XG5cbiAgVXNlIENTUyBjb2xvciBwcm9wZXJ0eSB0byBzdHlsZSB0aGUgcmlwcGxlOlxuXG4gICAgcGFwZXItcmlwcGxlIHtcbiAgICAgIGNvbG9yOiAjNDI4NWY0O1xuICAgIH1cblxuICBOb3RlIHRoYXQgQ1NTIGNvbG9yIHByb3BlcnR5IGlzIGluaGVyaXRlZCBzbyBpdCBpcyBub3QgcmVxdWlyZWQgdG8gc2V0IGl0IG9uXG4gIHRoZSBgcGFwZXItcmlwcGxlYCBlbGVtZW50IGRpcmVjdGx5LlxuXG5CeSBkZWZhdWx0LCB0aGUgcmlwcGxlIGlzIGNlbnRlcmVkIG9uIHRoZSBwb2ludCBvZiBjb250YWN0LiAgQXBwbHkgdGhlIGByZWNlbnRlcnNgXG5hdHRyaWJ1dGUgdG8gaGF2ZSB0aGUgcmlwcGxlIGdyb3cgdG93YXJkIHRoZSBjZW50ZXIgb2YgaXRzIGNvbnRhaW5lci5cblxuICAgIDxwYXBlci1yaXBwbGUgcmVjZW50ZXJzPjwvcGFwZXItcmlwcGxlPlxuXG5Zb3UgY2FuIGFsc28gIGNlbnRlciB0aGUgcmlwcGxlIGluc2lkZSBpdHMgY29udGFpbmVyIGZyb20gdGhlIHN0YXJ0LlxuXG4gICAgPHBhcGVyLXJpcHBsZSBjZW50ZXI+PC9wYXBlci1yaXBwbGU+XG5cbkFwcGx5IGBjaXJjbGVgIGNsYXNzIHRvIG1ha2UgdGhlIHJpcHBsaW5nIGVmZmVjdCB3aXRoaW4gYSBjaXJjbGUuXG5cbiAgICA8cGFwZXItcmlwcGxlIGNsYXNzPVwiY2lyY2xlXCI+PC9wYXBlci1yaXBwbGU+XG5cbkBncm91cCBQYXBlciBFbGVtZW50c1xuQGVsZW1lbnQgcGFwZXItcmlwcGxlXG5AaGVybyBoZXJvLnN2Z1xuQGRlbW8gZGVtby9pbmRleC5odG1sXG4tLT5cblxuPGRvbS1tb2R1bGUgaWQ9XCJwYXBlci1yaXBwbGVcIj5cblxuICA8dGVtcGxhdGU+XG4gICAgPHN0eWxlPlxuICAgICAgOmhvc3Qge1xuICAgICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICBib3JkZXItcmFkaXVzOiBpbmhlcml0O1xuICAgICAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgICAgICB0b3A6IDA7XG4gICAgICAgIGxlZnQ6IDA7XG4gICAgICAgIHJpZ2h0OiAwO1xuICAgICAgICBib3R0b206IDA7XG5cbiAgICAgICAgLyogU2VlIFBvbHltZXJFbGVtZW50cy9wYXBlci1iZWhhdmlvcnMvaXNzdWVzLzM0LiBPbiBub24tQ2hyb21lIGJyb3dzZXJzLFxuICAgICAgICAgKiBjcmVhdGluZyBhIG5vZGUgKHdpdGggYSBwb3NpdGlvbjphYnNvbHV0ZSkgaW4gdGhlIG1pZGRsZSBvZiBhbiBldmVudFxuICAgICAgICAgKiBoYW5kbGVyIFwiaW50ZXJydXB0c1wiIHRoYXQgZXZlbnQgaGFuZGxlciAod2hpY2ggaGFwcGVucyB3aGVuIHRoZVxuICAgICAgICAgKiByaXBwbGUgaXMgY3JlYXRlZCBvbiBkZW1hbmQpICovXG4gICAgICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xuICAgICAgfVxuXG4gICAgICA6aG9zdChbYW5pbWF0aW5nXSkge1xuICAgICAgICAvKiBUaGlzIHJlc29sdmVzIGEgcmVuZGVyaW5nIGlzc3VlIGluIENocm9tZSAoYXMgb2YgNDApIHdoZXJlIHRoZVxuICAgICAgICAgICByaXBwbGUgaXMgbm90IHByb3Blcmx5IGNsaXBwZWQgYnkgaXRzIHBhcmVudCAod2hpY2ggbWF5IGhhdmVcbiAgICAgICAgICAgcm91bmRlZCBjb3JuZXJzKS4gU2VlOiBodHRwOi8vanNiaW4uY29tL3RlbWV4YS80XG5cbiAgICAgICAgICAgTm90ZTogV2Ugb25seSBhcHBseSB0aGlzIHN0eWxlIGNvbmRpdGlvbmFsbHkuIE90aGVyd2lzZSwgdGhlIGJyb3dzZXJcbiAgICAgICAgICAgd2lsbCBjcmVhdGUgYSBuZXcgY29tcG9zaXRpbmcgbGF5ZXIgZm9yIGV2ZXJ5IHJpcHBsZSBlbGVtZW50IG9uIHRoZVxuICAgICAgICAgICBwYWdlLCBhbmQgdGhhdCB3b3VsZCBiZSBiYWQuICovXG4gICAgICAgIC13ZWJraXQtdHJhbnNmb3JtOiB0cmFuc2xhdGUoMCwgMCk7XG4gICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoMCwgMCwgMCk7XG4gICAgICB9XG5cbiAgICAgICNiYWNrZ3JvdW5kLFxuICAgICAgI3dhdmVzLFxuICAgICAgLndhdmUtY29udGFpbmVyLFxuICAgICAgLndhdmUge1xuICAgICAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICB0b3A6IDA7XG4gICAgICAgIGxlZnQ6IDA7XG4gICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICBoZWlnaHQ6IDEwMCU7XG4gICAgICB9XG5cbiAgICAgICNiYWNrZ3JvdW5kLFxuICAgICAgLndhdmUge1xuICAgICAgICBvcGFjaXR5OiAwO1xuICAgICAgfVxuXG4gICAgICAjd2F2ZXMsXG4gICAgICAud2F2ZSB7XG4gICAgICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgICB9XG5cbiAgICAgIC53YXZlLWNvbnRhaW5lcixcbiAgICAgIC53YXZlIHtcbiAgICAgICAgYm9yZGVyLXJhZGl1czogNTAlO1xuICAgICAgfVxuXG4gICAgICA6aG9zdCguY2lyY2xlKSAjYmFja2dyb3VuZCxcbiAgICAgIDpob3N0KC5jaXJjbGUpICN3YXZlcyB7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDUwJTtcbiAgICAgIH1cblxuICAgICAgOmhvc3QoLmNpcmNsZSkgLndhdmUtY29udGFpbmVyIHtcbiAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICAgIH1cbiAgICA8L3N0eWxlPlxuXG4gICAgPGRpdiBpZD1cImJhY2tncm91bmRcIj48L2Rpdj5cbiAgICA8ZGl2IGlkPVwid2F2ZXNcIj48L2Rpdj5cbiAgPC90ZW1wbGF0ZT5cbjwvZG9tLW1vZHVsZT5cbjxzY3JpcHQ+XG4gIChmdW5jdGlvbigpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgVXRpbGl0eSA9IHtcbiAgICAgIGRpc3RhbmNlOiBmdW5jdGlvbih4MSwgeTEsIHgyLCB5Mikge1xuICAgICAgICB2YXIgeERlbHRhID0gKHgxIC0geDIpO1xuICAgICAgICB2YXIgeURlbHRhID0gKHkxIC0geTIpO1xuXG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQoeERlbHRhICogeERlbHRhICsgeURlbHRhICogeURlbHRhKTtcbiAgICAgIH0sXG5cbiAgICAgIG5vdzogd2luZG93LnBlcmZvcm1hbmNlICYmIHdpbmRvdy5wZXJmb3JtYW5jZS5ub3cgP1xuICAgICAgICAgIHdpbmRvdy5wZXJmb3JtYW5jZS5ub3cuYmluZCh3aW5kb3cucGVyZm9ybWFuY2UpIDogRGF0ZS5ub3dcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEVsZW1lbnRNZXRyaWNzKGVsZW1lbnQpIHtcbiAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICB0aGlzLndpZHRoID0gdGhpcy5ib3VuZGluZ1JlY3Qud2lkdGg7XG4gICAgICB0aGlzLmhlaWdodCA9IHRoaXMuYm91bmRpbmdSZWN0LmhlaWdodDtcblxuICAgICAgdGhpcy5zaXplID0gTWF0aC5tYXgodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgIH1cblxuICAgIEVsZW1lbnRNZXRyaWNzLnByb3RvdHlwZSA9IHtcbiAgICAgIGdldCBib3VuZGluZ1JlY3QgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgfSxcblxuICAgICAgZnVydGhlc3RDb3JuZXJEaXN0YW5jZUZyb206IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgdmFyIHRvcExlZnQgPSBVdGlsaXR5LmRpc3RhbmNlKHgsIHksIDAsIDApO1xuICAgICAgICB2YXIgdG9wUmlnaHQgPSBVdGlsaXR5LmRpc3RhbmNlKHgsIHksIHRoaXMud2lkdGgsIDApO1xuICAgICAgICB2YXIgYm90dG9tTGVmdCA9IFV0aWxpdHkuZGlzdGFuY2UoeCwgeSwgMCwgdGhpcy5oZWlnaHQpO1xuICAgICAgICB2YXIgYm90dG9tUmlnaHQgPSBVdGlsaXR5LmRpc3RhbmNlKHgsIHksIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcblxuICAgICAgICByZXR1cm4gTWF0aC5tYXgodG9wTGVmdCwgdG9wUmlnaHQsIGJvdHRvbUxlZnQsIGJvdHRvbVJpZ2h0KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFJpcHBsZShlbGVtZW50KSB7XG4gICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgdGhpcy5jb2xvciA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLmNvbG9yO1xuXG4gICAgICB0aGlzLndhdmUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHRoaXMud2F2ZUNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgdGhpcy53YXZlLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IHRoaXMuY29sb3I7XG4gICAgICB0aGlzLndhdmUuY2xhc3NMaXN0LmFkZCgnd2F2ZScpO1xuICAgICAgdGhpcy53YXZlQ29udGFpbmVyLmNsYXNzTGlzdC5hZGQoJ3dhdmUtY29udGFpbmVyJyk7XG4gICAgICBQb2x5bWVyLmRvbSh0aGlzLndhdmVDb250YWluZXIpLmFwcGVuZENoaWxkKHRoaXMud2F2ZSk7XG5cbiAgICAgIHRoaXMucmVzZXRJbnRlcmFjdGlvblN0YXRlKCk7XG4gICAgfVxuXG4gICAgUmlwcGxlLk1BWF9SQURJVVMgPSAzMDA7XG5cbiAgICBSaXBwbGUucHJvdG90eXBlID0ge1xuICAgICAgZ2V0IHJlY2VudGVycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudC5yZWNlbnRlcnM7XG4gICAgICB9LFxuXG4gICAgICBnZXQgY2VudGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50LmNlbnRlcjtcbiAgICAgIH0sXG5cbiAgICAgIGdldCBtb3VzZURvd25FbGFwc2VkKCkge1xuICAgICAgICB2YXIgZWxhcHNlZDtcblxuICAgICAgICBpZiAoIXRoaXMubW91c2VEb3duU3RhcnQpIHtcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsYXBzZWQgPSBVdGlsaXR5Lm5vdygpIC0gdGhpcy5tb3VzZURvd25TdGFydDtcblxuICAgICAgICBpZiAodGhpcy5tb3VzZVVwU3RhcnQpIHtcbiAgICAgICAgICBlbGFwc2VkIC09IHRoaXMubW91c2VVcEVsYXBzZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZWxhcHNlZDtcbiAgICAgIH0sXG5cbiAgICAgIGdldCBtb3VzZVVwRWxhcHNlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW91c2VVcFN0YXJ0ID9cbiAgICAgICAgICBVdGlsaXR5Lm5vdyAoKSAtIHRoaXMubW91c2VVcFN0YXJ0IDogMDtcbiAgICAgIH0sXG5cbiAgICAgIGdldCBtb3VzZURvd25FbGFwc2VkU2Vjb25kcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW91c2VEb3duRWxhcHNlZCAvIDEwMDA7XG4gICAgICB9LFxuXG4gICAgICBnZXQgbW91c2VVcEVsYXBzZWRTZWNvbmRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb3VzZVVwRWxhcHNlZCAvIDEwMDA7XG4gICAgICB9LFxuXG4gICAgICBnZXQgbW91c2VJbnRlcmFjdGlvblNlY29uZHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vdXNlRG93bkVsYXBzZWRTZWNvbmRzICsgdGhpcy5tb3VzZVVwRWxhcHNlZFNlY29uZHM7XG4gICAgICB9LFxuXG4gICAgICBnZXQgaW5pdGlhbE9wYWNpdHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnQuaW5pdGlhbE9wYWNpdHk7XG4gICAgICB9LFxuXG4gICAgICBnZXQgb3BhY2l0eURlY2F5VmVsb2NpdHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnQub3BhY2l0eURlY2F5VmVsb2NpdHk7XG4gICAgICB9LFxuXG4gICAgICBnZXQgcmFkaXVzKCkge1xuICAgICAgICB2YXIgd2lkdGgyID0gdGhpcy5jb250YWluZXJNZXRyaWNzLndpZHRoICogdGhpcy5jb250YWluZXJNZXRyaWNzLndpZHRoO1xuICAgICAgICB2YXIgaGVpZ2h0MiA9IHRoaXMuY29udGFpbmVyTWV0cmljcy5oZWlnaHQgKiB0aGlzLmNvbnRhaW5lck1ldHJpY3MuaGVpZ2h0O1xuICAgICAgICB2YXIgd2F2ZVJhZGl1cyA9IE1hdGgubWluKFxuICAgICAgICAgIE1hdGguc3FydCh3aWR0aDIgKyBoZWlnaHQyKSxcbiAgICAgICAgICBSaXBwbGUuTUFYX1JBRElVU1xuICAgICAgICApICogMS4xICsgNTtcblxuICAgICAgICB2YXIgZHVyYXRpb24gPSAxLjEgLSAwLjIgKiAod2F2ZVJhZGl1cyAvIFJpcHBsZS5NQVhfUkFESVVTKTtcbiAgICAgICAgdmFyIHRpbWVOb3cgPSB0aGlzLm1vdXNlSW50ZXJhY3Rpb25TZWNvbmRzIC8gZHVyYXRpb247XG4gICAgICAgIHZhciBzaXplID0gd2F2ZVJhZGl1cyAqICgxIC0gTWF0aC5wb3coODAsIC10aW1lTm93KSk7XG5cbiAgICAgICAgcmV0dXJuIE1hdGguYWJzKHNpemUpO1xuICAgICAgfSxcblxuICAgICAgZ2V0IG9wYWNpdHkoKSB7XG4gICAgICAgIGlmICghdGhpcy5tb3VzZVVwU3RhcnQpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5pbml0aWFsT3BhY2l0eTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBNYXRoLm1heChcbiAgICAgICAgICAwLFxuICAgICAgICAgIHRoaXMuaW5pdGlhbE9wYWNpdHkgLSB0aGlzLm1vdXNlVXBFbGFwc2VkU2Vjb25kcyAqIHRoaXMub3BhY2l0eURlY2F5VmVsb2NpdHlcbiAgICAgICAgKTtcbiAgICAgIH0sXG5cbiAgICAgIGdldCBvdXRlck9wYWNpdHkoKSB7XG4gICAgICAgIC8vIExpbmVhciBpbmNyZWFzZSBpbiBiYWNrZ3JvdW5kIG9wYWNpdHksIGNhcHBlZCBhdCB0aGUgb3BhY2l0eVxuICAgICAgICAvLyBvZiB0aGUgd2F2ZWZyb250ICh3YXZlT3BhY2l0eSkuXG4gICAgICAgIHZhciBvdXRlck9wYWNpdHkgPSB0aGlzLm1vdXNlVXBFbGFwc2VkU2Vjb25kcyAqIDAuMztcbiAgICAgICAgdmFyIHdhdmVPcGFjaXR5ID0gdGhpcy5vcGFjaXR5O1xuXG4gICAgICAgIHJldHVybiBNYXRoLm1heChcbiAgICAgICAgICAwLFxuICAgICAgICAgIE1hdGgubWluKG91dGVyT3BhY2l0eSwgd2F2ZU9wYWNpdHkpXG4gICAgICAgICk7XG4gICAgICB9LFxuXG4gICAgICBnZXQgaXNPcGFjaXR5RnVsbHlEZWNheWVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcGFjaXR5IDwgMC4wMSAmJlxuICAgICAgICAgIHRoaXMucmFkaXVzID49IE1hdGgubWluKHRoaXMubWF4UmFkaXVzLCBSaXBwbGUuTUFYX1JBRElVUyk7XG4gICAgICB9LFxuXG4gICAgICBnZXQgaXNSZXN0aW5nQXRNYXhSYWRpdXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wYWNpdHkgPj0gdGhpcy5pbml0aWFsT3BhY2l0eSAmJlxuICAgICAgICAgIHRoaXMucmFkaXVzID49IE1hdGgubWluKHRoaXMubWF4UmFkaXVzLCBSaXBwbGUuTUFYX1JBRElVUyk7XG4gICAgICB9LFxuXG4gICAgICBnZXQgaXNBbmltYXRpb25Db21wbGV0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW91c2VVcFN0YXJ0ID9cbiAgICAgICAgICB0aGlzLmlzT3BhY2l0eUZ1bGx5RGVjYXllZCA6IHRoaXMuaXNSZXN0aW5nQXRNYXhSYWRpdXM7XG4gICAgICB9LFxuXG4gICAgICBnZXQgdHJhbnNsYXRpb25GcmFjdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubWluKFxuICAgICAgICAgIDEsXG4gICAgICAgICAgdGhpcy5yYWRpdXMgLyB0aGlzLmNvbnRhaW5lck1ldHJpY3Muc2l6ZSAqIDIgLyBNYXRoLnNxcnQoMilcbiAgICAgICAgKTtcbiAgICAgIH0sXG5cbiAgICAgIGdldCB4Tm93KCkge1xuICAgICAgICBpZiAodGhpcy54RW5kKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMueFN0YXJ0ICsgdGhpcy50cmFuc2xhdGlvbkZyYWN0aW9uICogKHRoaXMueEVuZCAtIHRoaXMueFN0YXJ0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLnhTdGFydDtcbiAgICAgIH0sXG5cbiAgICAgIGdldCB5Tm93KCkge1xuICAgICAgICBpZiAodGhpcy55RW5kKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMueVN0YXJ0ICsgdGhpcy50cmFuc2xhdGlvbkZyYWN0aW9uICogKHRoaXMueUVuZCAtIHRoaXMueVN0YXJ0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLnlTdGFydDtcbiAgICAgIH0sXG5cbiAgICAgIGdldCBpc01vdXNlRG93bigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW91c2VEb3duU3RhcnQgJiYgIXRoaXMubW91c2VVcFN0YXJ0O1xuICAgICAgfSxcblxuICAgICAgcmVzZXRJbnRlcmFjdGlvblN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5tYXhSYWRpdXMgPSAwO1xuICAgICAgICB0aGlzLm1vdXNlRG93blN0YXJ0ID0gMDtcbiAgICAgICAgdGhpcy5tb3VzZVVwU3RhcnQgPSAwO1xuXG4gICAgICAgIHRoaXMueFN0YXJ0ID0gMDtcbiAgICAgICAgdGhpcy55U3RhcnQgPSAwO1xuICAgICAgICB0aGlzLnhFbmQgPSAwO1xuICAgICAgICB0aGlzLnlFbmQgPSAwO1xuICAgICAgICB0aGlzLnNsaWRlRGlzdGFuY2UgPSAwO1xuXG4gICAgICAgIHRoaXMuY29udGFpbmVyTWV0cmljcyA9IG5ldyBFbGVtZW50TWV0cmljcyh0aGlzLmVsZW1lbnQpO1xuICAgICAgfSxcblxuICAgICAgZHJhdzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzY2FsZTtcbiAgICAgICAgdmFyIHRyYW5zbGF0ZVN0cmluZztcbiAgICAgICAgdmFyIGR4O1xuICAgICAgICB2YXIgZHk7XG5cbiAgICAgICAgdGhpcy53YXZlLnN0eWxlLm9wYWNpdHkgPSB0aGlzLm9wYWNpdHk7XG5cbiAgICAgICAgc2NhbGUgPSB0aGlzLnJhZGl1cyAvICh0aGlzLmNvbnRhaW5lck1ldHJpY3Muc2l6ZSAvIDIpO1xuICAgICAgICBkeCA9IHRoaXMueE5vdyAtICh0aGlzLmNvbnRhaW5lck1ldHJpY3Mud2lkdGggLyAyKTtcbiAgICAgICAgZHkgPSB0aGlzLnlOb3cgLSAodGhpcy5jb250YWluZXJNZXRyaWNzLmhlaWdodCAvIDIpO1xuXG5cbiAgICAgICAgLy8gMmQgdHJhbnNmb3JtIGZvciBzYWZhcmkgYmVjYXVzZSBvZiBib3JkZXItcmFkaXVzIGFuZCBvdmVyZmxvdzpoaWRkZW4gY2xpcHBpbmcgYnVnLlxuICAgICAgICAvLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9OTg1MzhcbiAgICAgICAgdGhpcy53YXZlQ29udGFpbmVyLnN0eWxlLndlYmtpdFRyYW5zZm9ybSA9ICd0cmFuc2xhdGUoJyArIGR4ICsgJ3B4LCAnICsgZHkgKyAncHgpJztcbiAgICAgICAgdGhpcy53YXZlQ29udGFpbmVyLnN0eWxlLnRyYW5zZm9ybSA9ICd0cmFuc2xhdGUzZCgnICsgZHggKyAncHgsICcgKyBkeSArICdweCwgMCknO1xuICAgICAgICB0aGlzLndhdmUuc3R5bGUud2Via2l0VHJhbnNmb3JtID0gJ3NjYWxlKCcgKyBzY2FsZSArICcsJyArIHNjYWxlICsgJyknO1xuICAgICAgICB0aGlzLndhdmUuc3R5bGUudHJhbnNmb3JtID0gJ3NjYWxlM2QoJyArIHNjYWxlICsgJywnICsgc2NhbGUgKyAnLDEpJztcbiAgICAgIH0sXG5cbiAgICAgIC8qKiBAcGFyYW0ge0V2ZW50PX0gZXZlbnQgKi9cbiAgICAgIGRvd25BY3Rpb246IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIHZhciB4Q2VudGVyID0gdGhpcy5jb250YWluZXJNZXRyaWNzLndpZHRoIC8gMjtcbiAgICAgICAgdmFyIHlDZW50ZXIgPSB0aGlzLmNvbnRhaW5lck1ldHJpY3MuaGVpZ2h0IC8gMjtcblxuICAgICAgICB0aGlzLnJlc2V0SW50ZXJhY3Rpb25TdGF0ZSgpO1xuICAgICAgICB0aGlzLm1vdXNlRG93blN0YXJ0ID0gVXRpbGl0eS5ub3coKTtcblxuICAgICAgICBpZiAodGhpcy5jZW50ZXIpIHtcbiAgICAgICAgICB0aGlzLnhTdGFydCA9IHhDZW50ZXI7XG4gICAgICAgICAgdGhpcy55U3RhcnQgPSB5Q2VudGVyO1xuICAgICAgICAgIHRoaXMuc2xpZGVEaXN0YW5jZSA9IFV0aWxpdHkuZGlzdGFuY2UoXG4gICAgICAgICAgICB0aGlzLnhTdGFydCwgdGhpcy55U3RhcnQsIHRoaXMueEVuZCwgdGhpcy55RW5kXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnhTdGFydCA9IGV2ZW50ID9cbiAgICAgICAgICAgICAgZXZlbnQuZGV0YWlsLnggLSB0aGlzLmNvbnRhaW5lck1ldHJpY3MuYm91bmRpbmdSZWN0LmxlZnQgOlxuICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lck1ldHJpY3Mud2lkdGggLyAyO1xuICAgICAgICAgIHRoaXMueVN0YXJ0ID0gZXZlbnQgP1xuICAgICAgICAgICAgICBldmVudC5kZXRhaWwueSAtIHRoaXMuY29udGFpbmVyTWV0cmljcy5ib3VuZGluZ1JlY3QudG9wIDpcbiAgICAgICAgICAgICAgdGhpcy5jb250YWluZXJNZXRyaWNzLmhlaWdodCAvIDI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5yZWNlbnRlcnMpIHtcbiAgICAgICAgICB0aGlzLnhFbmQgPSB4Q2VudGVyO1xuICAgICAgICAgIHRoaXMueUVuZCA9IHlDZW50ZXI7XG4gICAgICAgICAgdGhpcy5zbGlkZURpc3RhbmNlID0gVXRpbGl0eS5kaXN0YW5jZShcbiAgICAgICAgICAgIHRoaXMueFN0YXJ0LCB0aGlzLnlTdGFydCwgdGhpcy54RW5kLCB0aGlzLnlFbmRcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5tYXhSYWRpdXMgPSB0aGlzLmNvbnRhaW5lck1ldHJpY3MuZnVydGhlc3RDb3JuZXJEaXN0YW5jZUZyb20oXG4gICAgICAgICAgdGhpcy54U3RhcnQsXG4gICAgICAgICAgdGhpcy55U3RhcnRcbiAgICAgICAgKTtcblxuICAgICAgICB0aGlzLndhdmVDb250YWluZXIuc3R5bGUudG9wID1cbiAgICAgICAgICAodGhpcy5jb250YWluZXJNZXRyaWNzLmhlaWdodCAtIHRoaXMuY29udGFpbmVyTWV0cmljcy5zaXplKSAvIDIgKyAncHgnO1xuICAgICAgICB0aGlzLndhdmVDb250YWluZXIuc3R5bGUubGVmdCA9XG4gICAgICAgICAgKHRoaXMuY29udGFpbmVyTWV0cmljcy53aWR0aCAtIHRoaXMuY29udGFpbmVyTWV0cmljcy5zaXplKSAvIDIgKyAncHgnO1xuXG4gICAgICAgIHRoaXMud2F2ZUNvbnRhaW5lci5zdHlsZS53aWR0aCA9IHRoaXMuY29udGFpbmVyTWV0cmljcy5zaXplICsgJ3B4JztcbiAgICAgICAgdGhpcy53YXZlQ29udGFpbmVyLnN0eWxlLmhlaWdodCA9IHRoaXMuY29udGFpbmVyTWV0cmljcy5zaXplICsgJ3B4JztcbiAgICAgIH0sXG5cbiAgICAgIC8qKiBAcGFyYW0ge0V2ZW50PX0gZXZlbnQgKi9cbiAgICAgIHVwQWN0aW9uOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNNb3VzZURvd24pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm1vdXNlVXBTdGFydCA9IFV0aWxpdHkubm93KCk7XG4gICAgICB9LFxuXG4gICAgICByZW1vdmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBQb2x5bWVyLmRvbSh0aGlzLndhdmVDb250YWluZXIucGFyZW50Tm9kZSkucmVtb3ZlQ2hpbGQoXG4gICAgICAgICAgdGhpcy53YXZlQ29udGFpbmVyXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIFBvbHltZXIoe1xuICAgICAgaXM6ICdwYXBlci1yaXBwbGUnLFxuXG4gICAgICBiZWhhdmlvcnM6IFtcbiAgICAgICAgUG9seW1lci5Jcm9uQTExeUtleXNCZWhhdmlvclxuICAgICAgXSxcblxuICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGluaXRpYWwgb3BhY2l0eSBzZXQgb24gdGhlIHdhdmUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBhdHRyaWJ1dGUgaW5pdGlhbE9wYWNpdHlcbiAgICAgICAgICogQHR5cGUgbnVtYmVyXG4gICAgICAgICAqIEBkZWZhdWx0IDAuMjVcbiAgICAgICAgICovXG4gICAgICAgIGluaXRpYWxPcGFjaXR5OiB7XG4gICAgICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgICAgIHZhbHVlOiAwLjI1XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEhvdyBmYXN0IChvcGFjaXR5IHBlciBzZWNvbmQpIHRoZSB3YXZlIGZhZGVzIG91dC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGF0dHJpYnV0ZSBvcGFjaXR5RGVjYXlWZWxvY2l0eVxuICAgICAgICAgKiBAdHlwZSBudW1iZXJcbiAgICAgICAgICogQGRlZmF1bHQgMC44XG4gICAgICAgICAqL1xuICAgICAgICBvcGFjaXR5RGVjYXlWZWxvY2l0eToge1xuICAgICAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgICAgICB2YWx1ZTogMC44XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHRydWUsIHJpcHBsZXMgd2lsbCBleGhpYml0IGEgZ3Jhdml0YXRpb25hbCBwdWxsIHRvd2FyZHNcbiAgICAgICAgICogdGhlIGNlbnRlciBvZiB0aGVpciBjb250YWluZXIgYXMgdGhleSBmYWRlIGF3YXkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBhdHRyaWJ1dGUgcmVjZW50ZXJzXG4gICAgICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIHJlY2VudGVyczoge1xuICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHRydWUsIHJpcHBsZXMgd2lsbCBjZW50ZXIgaW5zaWRlIGl0cyBjb250YWluZXJcbiAgICAgICAgICpcbiAgICAgICAgICogQGF0dHJpYnV0ZSByZWNlbnRlcnNcbiAgICAgICAgICogQHR5cGUgYm9vbGVhblxuICAgICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgY2VudGVyOiB7XG4gICAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQSBsaXN0IG9mIHRoZSB2aXN1YWwgcmlwcGxlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQGF0dHJpYnV0ZSByaXBwbGVzXG4gICAgICAgICAqIEB0eXBlIEFycmF5XG4gICAgICAgICAqIEBkZWZhdWx0IFtdXG4gICAgICAgICAqL1xuICAgICAgICByaXBwbGVzOiB7XG4gICAgICAgICAgdHlwZTogQXJyYXksXG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVHJ1ZSB3aGVuIHRoZXJlIGFyZSB2aXNpYmxlIHJpcHBsZXMgYW5pbWF0aW5nIHdpdGhpbiB0aGVcbiAgICAgICAgICogZWxlbWVudC5cbiAgICAgICAgICovXG4gICAgICAgIGFuaW1hdGluZzoge1xuICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgICAgcmVhZE9ubHk6IHRydWUsXG4gICAgICAgICAgcmVmbGVjdFRvQXR0cmlidXRlOiB0cnVlLFxuICAgICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0cnVlLCB0aGUgcmlwcGxlIHdpbGwgcmVtYWluIGluIHRoZSBcImRvd25cIiBzdGF0ZSB1bnRpbCBgaG9sZERvd25gXG4gICAgICAgICAqIGlzIHNldCB0byBmYWxzZSBhZ2Fpbi5cbiAgICAgICAgICovXG4gICAgICAgIGhvbGREb3duOiB7XG4gICAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgICB2YWx1ZTogZmFsc2UsXG4gICAgICAgICAgb2JzZXJ2ZXI6ICdfaG9sZERvd25DaGFuZ2VkJ1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0cnVlLCB0aGUgcmlwcGxlIHdpbGwgbm90IGdlbmVyYXRlIGEgcmlwcGxlIGVmZmVjdFxuICAgICAgICAgKiB2aWEgcG9pbnRlciBpbnRlcmFjdGlvbi5cbiAgICAgICAgICogQ2FsbGluZyByaXBwbGUncyBpbXBlcmF0aXZlIGFwaSBsaWtlIGBzaW11bGF0ZWRSaXBwbGVgIHdpbGxcbiAgICAgICAgICogc3RpbGwgZ2VuZXJhdGUgdGhlIHJpcHBsZSBlZmZlY3QuXG4gICAgICAgICAqL1xuICAgICAgICBub2luazoge1xuICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgIH0sXG5cbiAgICAgICAgX2FuaW1hdGluZzoge1xuICAgICAgICAgIHR5cGU6IEJvb2xlYW5cbiAgICAgICAgfSxcblxuICAgICAgICBfYm91bmRBbmltYXRlOiB7XG4gICAgICAgICAgdHlwZTogRnVuY3Rpb24sXG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYW5pbWF0ZS5iaW5kKHRoaXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgZ2V0IHRhcmdldCAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmtleUV2ZW50VGFyZ2V0O1xuICAgICAgfSxcblxuICAgICAga2V5QmluZGluZ3M6IHtcbiAgICAgICAgJ2VudGVyOmtleWRvd24nOiAnX29uRW50ZXJLZXlkb3duJyxcbiAgICAgICAgJ3NwYWNlOmtleWRvd24nOiAnX29uU3BhY2VLZXlkb3duJyxcbiAgICAgICAgJ3NwYWNlOmtleXVwJzogJ19vblNwYWNlS2V5dXAnXG4gICAgICB9LFxuXG4gICAgICBhdHRhY2hlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIFNldCB1cCBhMTF5S2V5c0JlaGF2aW9yIHRvIGxpc3RlbiB0byBrZXkgZXZlbnRzIG9uIHRoZSB0YXJnZXQsXG4gICAgICAgIC8vIHNvIHRoYXQgc3BhY2UgYW5kIGVudGVyIGFjdGl2YXRlIHRoZSByaXBwbGUgZXZlbiBpZiB0aGUgdGFyZ2V0IGRvZXNuJ3RcbiAgICAgICAgLy8gaGFuZGxlIGtleSBldmVudHMuIFRoZSBrZXkgaGFuZGxlcnMgZGVhbCB3aXRoIGBub2lua2AgdGhlbXNlbHZlcy5cbiAgICAgICAgaWYgKHRoaXMucGFyZW50Tm9kZS5ub2RlVHlwZSA9PSAxMSkgeyAvLyBET0NVTUVOVF9GUkFHTUVOVF9OT0RFXG4gICAgICAgICAgdGhpcy5rZXlFdmVudFRhcmdldCA9IFBvbHltZXIuZG9tKHRoaXMpLmdldE93bmVyUm9vdCgpLmhvc3Q7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5rZXlFdmVudFRhcmdldCA9IHRoaXMucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIga2V5RXZlbnRUYXJnZXQgPSAvKiogQHR5cGUgeyFFdmVudFRhcmdldH0gKi8gKHRoaXMua2V5RXZlbnRUYXJnZXQpO1xuICAgICAgICB0aGlzLmxpc3RlbihrZXlFdmVudFRhcmdldCwgJ3VwJywgJ3VpVXBBY3Rpb24nKTtcbiAgICAgICAgdGhpcy5saXN0ZW4oa2V5RXZlbnRUYXJnZXQsICdkb3duJywgJ3VpRG93bkFjdGlvbicpO1xuICAgICAgfSxcblxuICAgICAgZGV0YWNoZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnVubGlzdGVuKHRoaXMua2V5RXZlbnRUYXJnZXQsICd1cCcsICd1aVVwQWN0aW9uJyk7XG4gICAgICAgIHRoaXMudW5saXN0ZW4odGhpcy5rZXlFdmVudFRhcmdldCwgJ2Rvd24nLCAndWlEb3duQWN0aW9uJyk7XG4gICAgICAgIHRoaXMua2V5RXZlbnRUYXJnZXQgPSBudWxsO1xuICAgICAgfSxcblxuICAgICAgZ2V0IHNob3VsZEtlZXBBbmltYXRpbmcgKCkge1xuICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5yaXBwbGVzLmxlbmd0aDsgKytpbmRleCkge1xuICAgICAgICAgIGlmICghdGhpcy5yaXBwbGVzW2luZGV4XS5pc0FuaW1hdGlvbkNvbXBsZXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9LFxuXG4gICAgICBzaW11bGF0ZWRSaXBwbGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmRvd25BY3Rpb24obnVsbCk7XG5cbiAgICAgICAgLy8gUGxlYXNlIHNlZSBwb2x5bWVyL3BvbHltZXIjMTMwNVxuICAgICAgICB0aGlzLmFzeW5jKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHRoaXMudXBBY3Rpb24oKTtcbiAgICAgICAgfSwgMSk7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFByb3Zva2VzIGEgcmlwcGxlIGRvd24gZWZmZWN0IHZpYSBhIFVJIGV2ZW50LFxuICAgICAgICogcmVzcGVjdGluZyB0aGUgYG5vaW5rYCBwcm9wZXJ0eS5cbiAgICAgICAqIEBwYXJhbSB7RXZlbnQ9fSBldmVudFxuICAgICAgICovXG4gICAgICB1aURvd25BY3Rpb246IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIGlmICghdGhpcy5ub2luaykge1xuICAgICAgICAgIHRoaXMuZG93bkFjdGlvbihldmVudCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogUHJvdm9rZXMgYSByaXBwbGUgZG93biBlZmZlY3QgdmlhIGEgVUkgZXZlbnQsXG4gICAgICAgKiAqbm90KiByZXNwZWN0aW5nIHRoZSBgbm9pbmtgIHByb3BlcnR5LlxuICAgICAgICogQHBhcmFtIHtFdmVudD19IGV2ZW50XG4gICAgICAgKi9cbiAgICAgIGRvd25BY3Rpb246IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmhvbGREb3duICYmIHRoaXMucmlwcGxlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJpcHBsZSA9IHRoaXMuYWRkUmlwcGxlKCk7XG5cbiAgICAgICAgcmlwcGxlLmRvd25BY3Rpb24oZXZlbnQpO1xuXG4gICAgICAgIGlmICghdGhpcy5fYW5pbWF0aW5nKSB7XG4gICAgICAgICAgdGhpcy5fYW5pbWF0aW5nID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLmFuaW1hdGUoKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBQcm92b2tlcyBhIHJpcHBsZSB1cCBlZmZlY3QgdmlhIGEgVUkgZXZlbnQsXG4gICAgICAgKiByZXNwZWN0aW5nIHRoZSBgbm9pbmtgIHByb3BlcnR5LlxuICAgICAgICogQHBhcmFtIHtFdmVudD19IGV2ZW50XG4gICAgICAgKi9cbiAgICAgIHVpVXBBY3Rpb246IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIGlmICghdGhpcy5ub2luaykge1xuICAgICAgICAgIHRoaXMudXBBY3Rpb24oZXZlbnQpO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFByb3Zva2VzIGEgcmlwcGxlIHVwIGVmZmVjdCB2aWEgYSBVSSBldmVudCxcbiAgICAgICAqICpub3QqIHJlc3BlY3RpbmcgdGhlIGBub2lua2AgcHJvcGVydHkuXG4gICAgICAgKiBAcGFyYW0ge0V2ZW50PX0gZXZlbnRcbiAgICAgICAqL1xuICAgICAgdXBBY3Rpb246IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmhvbGREb3duKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5yaXBwbGVzLmZvckVhY2goZnVuY3Rpb24ocmlwcGxlKSB7XG4gICAgICAgICAgcmlwcGxlLnVwQWN0aW9uKGV2ZW50KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5fYW5pbWF0aW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5hbmltYXRlKCk7XG4gICAgICB9LFxuXG4gICAgICBvbkFuaW1hdGlvbkNvbXBsZXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fYW5pbWF0aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuJC5iYWNrZ3JvdW5kLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IG51bGw7XG4gICAgICAgIHRoaXMuZmlyZSgndHJhbnNpdGlvbmVuZCcpO1xuICAgICAgfSxcblxuICAgICAgYWRkUmlwcGxlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJpcHBsZSA9IG5ldyBSaXBwbGUodGhpcyk7XG5cbiAgICAgICAgUG9seW1lci5kb20odGhpcy4kLndhdmVzKS5hcHBlbmRDaGlsZChyaXBwbGUud2F2ZUNvbnRhaW5lcik7XG4gICAgICAgIHRoaXMuJC5iYWNrZ3JvdW5kLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IHJpcHBsZS5jb2xvcjtcbiAgICAgICAgdGhpcy5yaXBwbGVzLnB1c2gocmlwcGxlKTtcblxuICAgICAgICB0aGlzLl9zZXRBbmltYXRpbmcodHJ1ZSk7XG5cbiAgICAgICAgcmV0dXJuIHJpcHBsZTtcbiAgICAgIH0sXG5cbiAgICAgIHJlbW92ZVJpcHBsZTogZnVuY3Rpb24ocmlwcGxlKSB7XG4gICAgICAgIHZhciByaXBwbGVJbmRleCA9IHRoaXMucmlwcGxlcy5pbmRleE9mKHJpcHBsZSk7XG5cbiAgICAgICAgaWYgKHJpcHBsZUluZGV4IDwgMCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucmlwcGxlcy5zcGxpY2UocmlwcGxlSW5kZXgsIDEpO1xuXG4gICAgICAgIHJpcHBsZS5yZW1vdmUoKTtcblxuICAgICAgICBpZiAoIXRoaXMucmlwcGxlcy5sZW5ndGgpIHtcbiAgICAgICAgICB0aGlzLl9zZXRBbmltYXRpbmcoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFRoaXMgY29uZmxpY3RzIHdpdGggRWxlbWVudCNhbnRpbWF0ZSgpLlxuICAgICAgICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0VsZW1lbnQvYW5pbWF0ZVxuICAgICAgICogQHN1cHByZXNzIHtjaGVja1R5cGVzfVxuICAgICAgICovXG4gICAgICBhbmltYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9hbmltYXRpbmcpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGluZGV4O1xuICAgICAgICB2YXIgcmlwcGxlO1xuXG4gICAgICAgIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IHRoaXMucmlwcGxlcy5sZW5ndGg7ICsraW5kZXgpIHtcbiAgICAgICAgICByaXBwbGUgPSB0aGlzLnJpcHBsZXNbaW5kZXhdO1xuXG4gICAgICAgICAgcmlwcGxlLmRyYXcoKTtcblxuICAgICAgICAgIHRoaXMuJC5iYWNrZ3JvdW5kLnN0eWxlLm9wYWNpdHkgPSByaXBwbGUub3V0ZXJPcGFjaXR5O1xuXG4gICAgICAgICAgaWYgKHJpcHBsZS5pc09wYWNpdHlGdWxseURlY2F5ZWQgJiYgIXJpcHBsZS5pc1Jlc3RpbmdBdE1heFJhZGl1cykge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVSaXBwbGUocmlwcGxlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuc2hvdWxkS2VlcEFuaW1hdGluZyAmJiB0aGlzLnJpcHBsZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5vbkFuaW1hdGlvbkNvbXBsZXRlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLl9ib3VuZEFuaW1hdGUpO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBfb25FbnRlcktleWRvd246IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnVpRG93bkFjdGlvbigpO1xuICAgICAgICB0aGlzLmFzeW5jKHRoaXMudWlVcEFjdGlvbiwgMSk7XG4gICAgICB9LFxuXG4gICAgICBfb25TcGFjZUtleWRvd246IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnVpRG93bkFjdGlvbigpO1xuICAgICAgfSxcblxuICAgICAgX29uU3BhY2VLZXl1cDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMudWlVcEFjdGlvbigpO1xuICAgICAgfSxcblxuICAgICAgLy8gbm90ZTogaG9sZERvd24gZG9lcyBub3QgcmVzcGVjdCBub2luayBzaW5jZSBpdCBjYW4gYmUgYSBmb2N1cyBiYXNlZFxuICAgICAgLy8gZWZmZWN0LlxuICAgICAgX2hvbGREb3duQ2hhbmdlZDogZnVuY3Rpb24obmV3VmFsLCBvbGRWYWwpIHtcbiAgICAgICAgaWYgKG9sZFZhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXdWYWwpIHtcbiAgICAgICAgICB0aGlzLmRvd25BY3Rpb24oKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnVwQWN0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICBGaXJlZCB3aGVuIHRoZSBhbmltYXRpb24gZmluaXNoZXMuXG4gICAgICBUaGlzIGlzIHVzZWZ1bCBpZiB5b3Ugd2FudCB0byB3YWl0IHVudGlsXG4gICAgICB0aGUgcmlwcGxlIGFuaW1hdGlvbiBmaW5pc2hlcyB0byBwZXJmb3JtIHNvbWUgYWN0aW9uLlxuXG4gICAgICBAZXZlbnQgdHJhbnNpdGlvbmVuZFxuICAgICAgQHBhcmFtIHt7bm9kZTogT2JqZWN0fX0gZGV0YWlsIENvbnRhaW5zIHRoZSBhbmltYXRlZCBub2RlLlxuICAgICAgKi9cbiAgICB9KTtcbiAgfSkoKTtcbjwvc2NyaXB0PlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9wYXBlci1yaXBwbGUvcGFwZXItcmlwcGxlLmh0bWwiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE1IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi9wb2x5bWVyL3BvbHltZXIuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL2lyb24tbWV0YS9pcm9uLW1ldGEuaHRtbFwiPlxuXG48c2NyaXB0PlxuICAvKipcbiAgICogVGhlIGBpcm9uLWljb25zZXQtc3ZnYCBlbGVtZW50IGFsbG93cyB1c2VycyB0byBkZWZpbmUgdGhlaXIgb3duIGljb24gc2V0c1xuICAgKiB0aGF0IGNvbnRhaW4gc3ZnIGljb25zLiBUaGUgc3ZnIGljb24gZWxlbWVudHMgc2hvdWxkIGJlIGNoaWxkcmVuIG9mIHRoZVxuICAgKiBgaXJvbi1pY29uc2V0LXN2Z2AgZWxlbWVudC4gTXVsdGlwbGUgaWNvbnMgc2hvdWxkIGJlIGdpdmVuIGRpc3RpbmN0IGlkJ3MuXG4gICAqXG4gICAqIFVzaW5nIHN2ZyBlbGVtZW50cyB0byBjcmVhdGUgaWNvbnMgaGFzIGEgZmV3IGFkdmFudGFnZXMgb3ZlciB0cmFkaXRpb25hbFxuICAgKiBiaXRtYXAgZ3JhcGhpY3MgbGlrZSBqcGcgb3IgcG5nLiBJY29ucyB0aGF0IHVzZSBzdmcgYXJlIHZlY3RvciBiYXNlZCBzb1xuICAgKiB0aGV5IGFyZSByZXNvbHV0aW9uIGluZGVwZW5kZW50IGFuZCBzaG91bGQgbG9vayBnb29kIG9uIGFueSBkZXZpY2UuIFRoZXlcbiAgICogYXJlIHN0eWxhYmxlIHZpYSBjc3MuIEljb25zIGNhbiBiZSB0aGVtZWQsIGNvbG9yaXplZCwgYW5kIGV2ZW4gYW5pbWF0ZWQuXG4gICAqXG4gICAqIEV4YW1wbGU6XG4gICAqXG4gICAqICAgICA8aXJvbi1pY29uc2V0LXN2ZyBuYW1lPVwibXktc3ZnLWljb25zXCIgc2l6ZT1cIjI0XCI+XG4gICAqICAgICAgIDxzdmc+XG4gICAqICAgICAgICAgPGRlZnM+XG4gICAqICAgICAgICAgICA8ZyBpZD1cInNoYXBlXCI+XG4gICAqICAgICAgICAgICAgIDxyZWN0IHg9XCIxMlwiIHk9XCIwXCIgd2lkdGg9XCIxMlwiIGhlaWdodD1cIjI0XCIgLz5cbiAgICogICAgICAgICAgICAgPGNpcmNsZSBjeD1cIjEyXCIgY3k9XCIxMlwiIHI9XCIxMlwiIC8+XG4gICAqICAgICAgICAgICA8L2c+XG4gICAqICAgICAgICAgPC9kZWZzPlxuICAgKiAgICAgICA8L3N2Zz5cbiAgICogICAgIDwvaXJvbi1pY29uc2V0LXN2Zz5cbiAgICpcbiAgICogVGhpcyB3aWxsIGF1dG9tYXRpY2FsbHkgcmVnaXN0ZXIgdGhlIGljb24gc2V0IFwibXktc3ZnLWljb25zXCIgdG8gdGhlIGljb25zZXRcbiAgICogZGF0YWJhc2UuICBUbyB1c2UgdGhlc2UgaWNvbnMgZnJvbSB3aXRoaW4gYW5vdGhlciBlbGVtZW50LCBtYWtlIGFcbiAgICogYGlyb24taWNvbnNldGAgZWxlbWVudCBhbmQgY2FsbCB0aGUgYGJ5SWRgIG1ldGhvZFxuICAgKiB0byByZXRyaWV2ZSBhIGdpdmVuIGljb25zZXQuIFRvIGFwcGx5IGEgcGFydGljdWxhciBpY29uIGluc2lkZSBhblxuICAgKiBlbGVtZW50IHVzZSB0aGUgYGFwcGx5SWNvbmAgbWV0aG9kLiBGb3IgZXhhbXBsZTpcbiAgICpcbiAgICogICAgIGljb25zZXQuYXBwbHlJY29uKGljb25Ob2RlLCAnY2FyJyk7XG4gICAqXG4gICAqIEBlbGVtZW50IGlyb24taWNvbnNldC1zdmdcbiAgICogQGRlbW8gZGVtby9pbmRleC5odG1sXG4gICAqIEBpbXBsZW1lbnRzIHtQb2x5bWVyLkljb25zZXR9XG4gICAqL1xuICBQb2x5bWVyKHtcbiAgICBpczogJ2lyb24taWNvbnNldC1zdmcnLFxuXG4gICAgcHJvcGVydGllczoge1xuXG4gICAgICAvKipcbiAgICAgICAqIFRoZSBuYW1lIG9mIHRoZSBpY29uc2V0LlxuICAgICAgICovXG4gICAgICBuYW1lOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgb2JzZXJ2ZXI6ICdfbmFtZUNoYW5nZWQnXG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFRoZSBzaXplIG9mIGFuIGluZGl2aWR1YWwgaWNvbi4gTm90ZSB0aGF0IGljb25zIG11c3QgYmUgc3F1YXJlLlxuICAgICAgICovXG4gICAgICBzaXplOiB7XG4gICAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgICAgdmFsdWU6IDI0XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFNldCB0byB0cnVlIHRvIGVuYWJsZSBtaXJyb3Jpbmcgb2YgaWNvbnMgd2hlcmUgc3BlY2lmaWVkIHdoZW4gdGhleSBhcmVcbiAgICAgICAqIHN0YW1wZWQuIEljb25zIHRoYXQgc2hvdWxkIGJlIG1pcnJvcmVkIHNob3VsZCBiZSBkZWNvcmF0ZWQgd2l0aCBhXG4gICAgICAgKiBgbWlycm9yLWluLXJ0bGAgYXR0cmlidXRlLlxuICAgICAgICpcbiAgICAgICAqIE5PVEU6IEZvciBwZXJmb3JtYW5jZSByZWFzb25zLCBkaXJlY3Rpb24gd2lsbCBiZSByZXNvbHZlZCBvbmNlIHBlclxuICAgICAgICogZG9jdW1lbnQgcGVyIGljb25zZXQsIHNvIG1vdmluZyBpY29ucyBpbiBhbmQgb3V0IG9mIFJUTCBzdWJ0cmVlcyB3aWxsXG4gICAgICAgKiBub3QgY2F1c2UgdGhlaXIgbWlycm9yZWQgc3RhdGUgdG8gY2hhbmdlLlxuICAgICAgICovXG4gICAgICBydGxNaXJyb3Jpbmc6IHtcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFNldCB0byB0cnVlIHRvIG1lYXN1cmUgUlRMIGJhc2VkIG9uIHRoZSBkaXIgYXR0cmlidXRlIG9uIHRoZSBib2R5IG9yXG4gICAgICAgKiBodG1sIGVsZW1lbnRzIChtZWFzdXJlZCBvbiBkb2N1bWVudC5ib2R5IG9yIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCBhc1xuICAgICAgICogYXZhaWxhYmxlKS5cbiAgICAgICAqL1xuICAgICAgdXNlR2xvYmFsUnRsQXR0cmlidXRlOiB7XG4gICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBjcmVhdGVkOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX21ldGEgPSBuZXcgUG9seW1lci5Jcm9uTWV0YSh7dHlwZTogJ2ljb25zZXQnLCBrZXk6IG51bGwsIHZhbHVlOiBudWxsfSk7XG4gICAgfSxcblxuICAgIGF0dGFjaGVkOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGFuIGFycmF5IG9mIGFsbCBpY29uIG5hbWVzIGluIHRoaXMgaWNvbnNldC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4geyFBcnJheX0gQXJyYXkgb2YgaWNvbiBuYW1lcy5cbiAgICAgKi9cbiAgICBnZXRJY29uTmFtZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5faWNvbnMgPSB0aGlzLl9jcmVhdGVJY29uTWFwKCk7XG4gICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5faWNvbnMpLm1hcChmdW5jdGlvbihuKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5hbWUgKyAnOicgKyBuO1xuICAgICAgfSwgdGhpcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgYW4gaWNvbiB0byB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEFuIHN2ZyBpY29uIGlzIHByZXBlbmRlZCB0byB0aGUgZWxlbWVudCdzIHNoYWRvd1Jvb3QgaWYgaXQgZXhpc3RzLFxuICAgICAqIG90aGVyd2lzZSB0byB0aGUgZWxlbWVudCBpdHNlbGYuXG4gICAgICpcbiAgICAgKiBJZiBSVEwgbWlycm9yaW5nIGlzIGVuYWJsZWQsIGFuZCB0aGUgaWNvbiBpcyBtYXJrZWQgdG8gYmUgbWlycm9yZWQgaW5cbiAgICAgKiBSVEwsIHRoZSBlbGVtZW50IHdpbGwgYmUgdGVzdGVkIChvbmNlIGFuZCBvbmx5IG9uY2UgZXZlciBmb3IgZWFjaFxuICAgICAqIGljb25zZXQpIHRvIGRldGVybWluZSB0aGUgZGlyZWN0aW9uIG9mIHRoZSBzdWJ0cmVlIHRoZSBlbGVtZW50IGlzIGluLlxuICAgICAqIFRoaXMgZGlyZWN0aW9uIHdpbGwgYXBwbHkgdG8gYWxsIGZ1dHVyZSBpY29uIGFwcGxpY2F0aW9ucywgYWx0aG91Z2ggb25seVxuICAgICAqIGljb25zIG1hcmtlZCB0byBiZSBtaXJyb3JlZCB3aWxsIGJlIGFmZmVjdGVkLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBhcHBseUljb25cbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0byB3aGljaCB0aGUgaWNvbiBpcyBhcHBsaWVkLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpY29uTmFtZSBOYW1lIG9mIHRoZSBpY29uIHRvIGFwcGx5LlxuICAgICAqIEByZXR1cm4gez9FbGVtZW50fSBUaGUgc3ZnIGVsZW1lbnQgd2hpY2ggcmVuZGVycyB0aGUgaWNvbi5cbiAgICAgKi9cbiAgICBhcHBseUljb246IGZ1bmN0aW9uKGVsZW1lbnQsIGljb25OYW1lKSB7XG4gICAgICAvLyBSZW1vdmUgb2xkIHN2ZyBlbGVtZW50XG4gICAgICB0aGlzLnJlbW92ZUljb24oZWxlbWVudCk7XG4gICAgICAvLyBpbnN0YWxsIG5ldyBzdmcgZWxlbWVudFxuICAgICAgdmFyIHN2ZyA9IHRoaXMuX2Nsb25lSWNvbihpY29uTmFtZSxcbiAgICAgICAgICB0aGlzLnJ0bE1pcnJvcmluZyAmJiB0aGlzLl90YXJnZXRJc1JUTChlbGVtZW50KSk7XG4gICAgICBpZiAoc3ZnKSB7XG4gICAgICAgIC8vIGluc2VydCBzdmcgZWxlbWVudCBpbnRvIHNoYWRvdyByb290LCBpZiBpdCBleGlzdHNcbiAgICAgICAgdmFyIHBkZSA9IFBvbHltZXIuZG9tKGVsZW1lbnQucm9vdCB8fCBlbGVtZW50KTtcbiAgICAgICAgcGRlLmluc2VydEJlZm9yZShzdmcsIHBkZS5jaGlsZE5vZGVzWzBdKTtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQuX3N2Z0ljb24gPSBzdmc7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGFuIGljb24gZnJvbSB0aGUgZ2l2ZW4gZWxlbWVudCBieSB1bmRvaW5nIHRoZSBjaGFuZ2VzIGVmZmVjdGVkXG4gICAgICogYnkgYGFwcGx5SWNvbmAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgVGhlIGVsZW1lbnQgZnJvbSB3aGljaCB0aGUgaWNvbiBpcyByZW1vdmVkLlxuICAgICAqL1xuICAgIHJlbW92ZUljb246IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgIC8vIFJlbW92ZSBvbGQgc3ZnIGVsZW1lbnRcbiAgICAgIGlmIChlbGVtZW50Ll9zdmdJY29uKSB7XG4gICAgICAgIFBvbHltZXIuZG9tKGVsZW1lbnQucm9vdCB8fCBlbGVtZW50KS5yZW1vdmVDaGlsZChlbGVtZW50Ll9zdmdJY29uKTtcbiAgICAgICAgZWxlbWVudC5fc3ZnSWNvbiA9IG51bGw7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1lYXN1cmVzIGFuZCBtZW1vaXplcyB0aGUgZGlyZWN0aW9uIG9mIHRoZSBlbGVtZW50LiBOb3RlIHRoYXQgdGhpc1xuICAgICAqIG1lYXN1cmVtZW50IGlzIG9ubHkgZG9uZSBvbmNlIGFuZCB0aGUgcmVzdWx0IGlzIG1lbW9pemVkIGZvciBmdXR1cmVcbiAgICAgKiBpbnZvY2F0aW9ucy5cbiAgICAgKi9cbiAgICBfdGFyZ2V0SXNSVEw6IGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgaWYgKHRoaXMuX190YXJnZXRJc1JUTCA9PSBudWxsKSB7XG4gICAgICAgIGlmICh0aGlzLnVzZUdsb2JhbFJ0bEF0dHJpYnV0ZSkge1xuICAgICAgICAgIHZhciBnbG9iYWxFbGVtZW50ID1cbiAgICAgICAgICAgICAgKGRvY3VtZW50LmJvZHkgJiYgZG9jdW1lbnQuYm9keS5oYXNBdHRyaWJ1dGUoJ2RpcicpKVxuICAgICAgICAgICAgICAgICAgPyBkb2N1bWVudC5ib2R5XG4gICAgICAgICAgICAgICAgICA6IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblxuICAgICAgICAgIHRoaXMuX190YXJnZXRJc1JUTCA9IGdsb2JhbEVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkaXInKSA9PT0gJ3J0bCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHRhcmdldCAmJiB0YXJnZXQubm9kZVR5cGUgIT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICB0YXJnZXQgPSB0YXJnZXQuaG9zdDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLl9fdGFyZ2V0SXNSVEwgPSB0YXJnZXQgJiZcbiAgICAgICAgICAgICAgd2luZG93LmdldENvbXB1dGVkU3R5bGUodGFyZ2V0KVsnZGlyZWN0aW9uJ10gPT09ICdydGwnO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9fdGFyZ2V0SXNSVEw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogV2hlbiBuYW1lIGlzIGNoYW5nZWQsIHJlZ2lzdGVyIGljb25zZXQgbWV0YWRhdGFcbiAgICAgKlxuICAgICAqL1xuICAgIF9uYW1lQ2hhbmdlZDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9tZXRhLnZhbHVlID0gbnVsbDtcbiAgICAgIHRoaXMuX21ldGEua2V5ID0gdGhpcy5uYW1lO1xuICAgICAgdGhpcy5fbWV0YS52YWx1ZSA9IHRoaXM7XG5cbiAgICAgIHRoaXMuYXN5bmMoZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZmlyZSgnaXJvbi1pY29uc2V0LWFkZGVkJywgdGhpcywge25vZGU6IHdpbmRvd30pO1xuICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG1hcCBvZiBjaGlsZCBTVkcgZWxlbWVudHMgYnkgaWQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHshT2JqZWN0fSBNYXAgb2YgaWQncyB0byBTVkcgZWxlbWVudHMuXG4gICAgICovXG4gICAgX2NyZWF0ZUljb25NYXA6IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gT2JqZWN0cyBjaGFpbmVkIHRvIE9iamVjdC5wcm90b3R5cGUgKGB7fWApIGhhdmUgbWVtYmVycy4gU3BlY2lmaWNhbGx5LFxuICAgICAgLy8gb24gRkYgdGhlcmUgaXMgYSBgd2F0Y2hgIG1ldGhvZCB0aGF0IGNvbmZ1c2VzIHRoZSBpY29uIG1hcCwgc28gd2VcbiAgICAgIC8vIG5lZWQgdG8gdXNlIGEgbnVsbC1iYXNlZCBvYmplY3QgaGVyZS5cbiAgICAgIHZhciBpY29ucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICBQb2x5bWVyLmRvbSh0aGlzKS5xdWVyeVNlbGVjdG9yQWxsKCdbaWRdJylcbiAgICAgICAgLmZvckVhY2goZnVuY3Rpb24oaWNvbikge1xuICAgICAgICAgIGljb25zW2ljb24uaWRdID0gaWNvbjtcbiAgICAgICAgfSk7XG4gICAgICByZXR1cm4gaWNvbnM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFByb2R1Y2UgaW5zdGFsbGFibGUgY2xvbmUgb2YgdGhlIFNWRyBlbGVtZW50IG1hdGNoaW5nIGBpZGAgaW4gdGhpc1xuICAgICAqIGljb25zZXQsIG9yIGB1bmRlZmluZWRgIGlmIHRoZXJlIGlzIG5vIG1hdGNoaW5nIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtFbGVtZW50fSBSZXR1cm5zIGFuIGluc3RhbGxhYmxlIGNsb25lIG9mIHRoZSBTVkcgZWxlbWVudFxuICAgICAqIG1hdGNoaW5nIGBpZGAuXG4gICAgICovXG4gICAgX2Nsb25lSWNvbjogZnVuY3Rpb24oaWQsIG1pcnJvckFsbG93ZWQpIHtcbiAgICAgIC8vIGNyZWF0ZSB0aGUgaWNvbiBtYXAgb24tZGVtYW5kLCBzaW5jZSB0aGUgaWNvbnNldCBpdHNlbGYgaGFzIG5vIGRpc2NyZXRlXG4gICAgICAvLyBzaWduYWwgdG8ga25vdyB3aGVuIGl0J3MgY2hpbGRyZW4gYXJlIGZ1bGx5IHBhcnNlZFxuICAgICAgdGhpcy5faWNvbnMgPSB0aGlzLl9pY29ucyB8fCB0aGlzLl9jcmVhdGVJY29uTWFwKCk7XG4gICAgICByZXR1cm4gdGhpcy5fcHJlcGFyZVN2Z0Nsb25lKHRoaXMuX2ljb25zW2lkXSwgdGhpcy5zaXplLCBtaXJyb3JBbGxvd2VkKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBzb3VyY2VTdmdcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2l6ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gbWlycm9yQWxsb3dlZFxuICAgICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAgICovXG4gICAgX3ByZXBhcmVTdmdDbG9uZTogZnVuY3Rpb24oc291cmNlU3ZnLCBzaXplLCBtaXJyb3JBbGxvd2VkKSB7XG4gICAgICBpZiAoc291cmNlU3ZnKSB7XG4gICAgICAgIHZhciBjb250ZW50ID0gc291cmNlU3ZnLmNsb25lTm9kZSh0cnVlKSxcbiAgICAgICAgICAgIHN2ZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCAnc3ZnJyksXG4gICAgICAgICAgICB2aWV3Qm94ID0gY29udGVudC5nZXRBdHRyaWJ1dGUoJ3ZpZXdCb3gnKSB8fCAnMCAwICcgKyBzaXplICsgJyAnICsgc2l6ZSxcbiAgICAgICAgICAgIGNzc1RleHQgPSAncG9pbnRlci1ldmVudHM6IG5vbmU7IGRpc3BsYXk6IGJsb2NrOyB3aWR0aDogMTAwJTsgaGVpZ2h0OiAxMDAlOyc7XG5cbiAgICAgICAgaWYgKG1pcnJvckFsbG93ZWQgJiYgY29udGVudC5oYXNBdHRyaWJ1dGUoJ21pcnJvci1pbi1ydGwnKSkge1xuICAgICAgICAgIGNzc1RleHQgKz0gJy13ZWJraXQtdHJhbnNmb3JtOnNjYWxlKC0xLDEpO3RyYW5zZm9ybTpzY2FsZSgtMSwxKTsnO1xuICAgICAgICB9XG5cbiAgICAgICAgc3ZnLnNldEF0dHJpYnV0ZSgndmlld0JveCcsIHZpZXdCb3gpO1xuICAgICAgICBzdmcuc2V0QXR0cmlidXRlKCdwcmVzZXJ2ZUFzcGVjdFJhdGlvJywgJ3hNaWRZTWlkIG1lZXQnKTtcbiAgICAgICAgc3ZnLnNldEF0dHJpYnV0ZSgnZm9jdXNhYmxlJywgJ2ZhbHNlJyk7XG4gICAgICAgIC8vIFRPRE8oZGZyZWVkbSk6IGBwb2ludGVyLWV2ZW50czogbm9uZWAgd29ya3MgYXJvdW5kIGh0dHBzOi8vY3JidWcuY29tLzM3MDEzNlxuICAgICAgICAvLyBUT0RPKHNqbWlsZXMpOiBpbmxpbmUgc3R5bGUgbWF5IG5vdCBiZSBpZGVhbCwgYnV0IGF2b2lkcyByZXF1aXJpbmcgYSBzaGFkb3ctcm9vdFxuICAgICAgICBzdmcuc3R5bGUuY3NzVGV4dCA9IGNzc1RleHQ7XG4gICAgICAgIHN2Zy5hcHBlbmRDaGlsZChjb250ZW50KS5yZW1vdmVBdHRyaWJ1dGUoJ2lkJyk7XG4gICAgICAgIHJldHVybiBzdmc7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgfSk7XG5cbjwvc2NyaXB0PlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9pcm9uLWljb25zZXQtc3ZnL2lyb24taWNvbnNldC1zdmcuaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTYgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cblxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3BvbHltZXIvcG9seW1lci5odG1sXCI+XG5cbjxzY3JpcHQ+XG5cbiAgLyoqXG4gICAqIGBQb2x5bWVyLklyb25TY3JvbGxUYXJnZXRCZWhhdmlvcmAgYWxsb3dzIGFuIGVsZW1lbnQgdG8gcmVzcG9uZCB0byBzY3JvbGwgZXZlbnRzIGZyb20gYVxuICAgKiBkZXNpZ25hdGVkIHNjcm9sbCB0YXJnZXQuXG4gICAqXG4gICAqIEVsZW1lbnRzIHRoYXQgY29uc3VtZSB0aGlzIGJlaGF2aW9yIGNhbiBvdmVycmlkZSB0aGUgYF9zY3JvbGxIYW5kbGVyYFxuICAgKiBtZXRob2QgdG8gYWRkIGxvZ2ljIG9uIHRoZSBzY3JvbGwgZXZlbnQuXG4gICAqXG4gICAqIEBkZW1vIGRlbW8vc2Nyb2xsaW5nLXJlZ2lvbi5odG1sIFNjcm9sbGluZyBSZWdpb25cbiAgICogQGRlbW8gZGVtby9kb2N1bWVudC5odG1sIERvY3VtZW50IEVsZW1lbnRcbiAgICogQHBvbHltZXJCZWhhdmlvclxuICAgKi9cbiAgUG9seW1lci5Jcm9uU2Nyb2xsVGFyZ2V0QmVoYXZpb3IgPSB7XG5cbiAgICBwcm9wZXJ0aWVzOiB7XG5cbiAgICAgIC8qKlxuICAgICAgICogU3BlY2lmaWVzIHRoZSBlbGVtZW50IHRoYXQgd2lsbCBoYW5kbGUgdGhlIHNjcm9sbCBldmVudFxuICAgICAgICogb24gdGhlIGJlaGFsZiBvZiB0aGUgY3VycmVudCBlbGVtZW50LiBUaGlzIGlzIHR5cGljYWxseSBhIHJlZmVyZW5jZSB0byBhbiBlbGVtZW50LFxuICAgICAgICogYnV0IHRoZXJlIGFyZSBhIGZldyBtb3JlIHBvc2liaWxpdGllczpcbiAgICAgICAqXG4gICAgICAgKiAjIyMgRWxlbWVudHMgaWRcbiAgICAgICAqXG4gICAgICAgKmBgYGh0bWxcbiAgICAgICAqIDxkaXYgaWQ9XCJzY3JvbGxhYmxlLWVsZW1lbnRcIiBzdHlsZT1cIm92ZXJmbG93OiBhdXRvO1wiPlxuICAgICAgICogIDx4LWVsZW1lbnQgc2Nyb2xsLXRhcmdldD1cInNjcm9sbGFibGUtZWxlbWVudFwiPlxuICAgICAgICogICAgPCEtLSBDb250ZW50LS0+XG4gICAgICAgKiAgPC94LWVsZW1lbnQ+XG4gICAgICAgKiA8L2Rpdj5cbiAgICAgICAqYGBgXG4gICAgICAgKiBJbiB0aGlzIGNhc2UsIHRoZSBgc2Nyb2xsVGFyZ2V0YCB3aWxsIHBvaW50IHRvIHRoZSBvdXRlciBkaXYgZWxlbWVudC5cbiAgICAgICAqXG4gICAgICAgKiAjIyMgRG9jdW1lbnQgc2Nyb2xsaW5nXG4gICAgICAgKlxuICAgICAgICogRm9yIGRvY3VtZW50IHNjcm9sbGluZywgeW91IGNhbiB1c2UgdGhlIHJlc2VydmVkIHdvcmQgYGRvY3VtZW50YDpcbiAgICAgICAqXG4gICAgICAgKmBgYGh0bWxcbiAgICAgICAqIDx4LWVsZW1lbnQgc2Nyb2xsLXRhcmdldD1cImRvY3VtZW50XCI+XG4gICAgICAgKiAgIDwhLS0gQ29udGVudCAtLT5cbiAgICAgICAqIDwveC1lbGVtZW50PlxuICAgICAgICpgYGBcbiAgICAgICAqXG4gICAgICAgKiAjIyMgRWxlbWVudHMgcmVmZXJlbmNlXG4gICAgICAgKlxuICAgICAgICpgYGBqc1xuICAgICAgICogYXBwSGVhZGVyLnNjcm9sbFRhcmdldCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNzY3JvbGxhYmxlLWVsZW1lbnQnKTtcbiAgICAgICAqYGBgXG4gICAgICAgKlxuICAgICAgICogQHR5cGUge0hUTUxFbGVtZW50fVxuICAgICAgICogQGRlZmF1bHQgZG9jdW1lbnRcbiAgICAgICAqL1xuICAgICAgc2Nyb2xsVGFyZ2V0OiB7XG4gICAgICAgIHR5cGU6IEhUTUxFbGVtZW50LFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2RlZmF1bHRTY3JvbGxUYXJnZXQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgb2JzZXJ2ZXJzOiBbXG4gICAgICAnX3Njcm9sbFRhcmdldENoYW5nZWQoc2Nyb2xsVGFyZ2V0LCBpc0F0dGFjaGVkKSdcbiAgICBdLFxuXG4gICAgLyoqXG4gICAgICogVHJ1ZSBpZiB0aGUgZXZlbnQgbGlzdGVuZXIgc2hvdWxkIGJlIGluc3RhbGxlZC5cbiAgICAgKi9cbiAgICBfc2hvdWxkSGF2ZUxpc3RlbmVyOiB0cnVlLFxuXG4gICAgX3Njcm9sbFRhcmdldENoYW5nZWQ6IGZ1bmN0aW9uKHNjcm9sbFRhcmdldCwgaXNBdHRhY2hlZCkge1xuICAgICAgdmFyIGV2ZW50VGFyZ2V0O1xuXG4gICAgICBpZiAodGhpcy5fb2xkU2Nyb2xsVGFyZ2V0KSB7XG4gICAgICAgIHRoaXMuX3RvZ2dsZVNjcm9sbExpc3RlbmVyKGZhbHNlLCB0aGlzLl9vbGRTY3JvbGxUYXJnZXQpO1xuICAgICAgICB0aGlzLl9vbGRTY3JvbGxUYXJnZXQgPSBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKCFpc0F0dGFjaGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIFN1cHBvcnQgZWxlbWVudCBpZCByZWZlcmVuY2VzXG4gICAgICBpZiAoc2Nyb2xsVGFyZ2V0ID09PSAnZG9jdW1lbnQnKSB7XG5cbiAgICAgICAgdGhpcy5zY3JvbGxUYXJnZXQgPSB0aGlzLl9kb2M7XG5cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHNjcm9sbFRhcmdldCA9PT0gJ3N0cmluZycpIHtcblxuICAgICAgICB2YXIgZG9tSG9zdCA9IHRoaXMuZG9tSG9zdDtcblxuICAgICAgICB0aGlzLnNjcm9sbFRhcmdldCA9IGRvbUhvc3QgJiYgZG9tSG9zdC4kID8gZG9tSG9zdC4kW3Njcm9sbFRhcmdldF0gOlxuICAgICAgICAgICAgUG9seW1lci5kb20odGhpcy5vd25lckRvY3VtZW50KS5xdWVyeVNlbGVjdG9yKCcjJyArIHNjcm9sbFRhcmdldCk7XG5cbiAgICAgIH0gZWxzZSBpZiAodGhpcy5faXNWYWxpZFNjcm9sbFRhcmdldCgpKSB7XG5cbiAgICAgICAgdGhpcy5fb2xkU2Nyb2xsVGFyZ2V0ID0gc2Nyb2xsVGFyZ2V0O1xuICAgICAgICB0aGlzLl90b2dnbGVTY3JvbGxMaXN0ZW5lcih0aGlzLl9zaG91bGRIYXZlTGlzdGVuZXIsIHNjcm9sbFRhcmdldCk7XG5cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUnVucyBvbiBldmVyeSBzY3JvbGwgZXZlbnQuIENvbnN1bWVyIG9mIHRoaXMgYmVoYXZpb3IgbWF5IG92ZXJyaWRlIHRoaXMgbWV0aG9kLlxuICAgICAqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9zY3JvbGxIYW5kbGVyOiBmdW5jdGlvbiBzY3JvbGxIYW5kbGVyKCkge30sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGVmYXVsdCBzY3JvbGwgdGFyZ2V0LiBDb25zdW1lcnMgb2YgdGhpcyBiZWhhdmlvciBtYXkgd2FudCB0byBjdXN0b21pemVcbiAgICAgKiB0aGUgZGVmYXVsdCBzY3JvbGwgdGFyZ2V0LlxuICAgICAqXG4gICAgICogQHR5cGUge0VsZW1lbnR9XG4gICAgICovXG4gICAgZ2V0IF9kZWZhdWx0U2Nyb2xsVGFyZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2RvYztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2hvcnRjdXQgZm9yIHRoZSBkb2N1bWVudCBlbGVtZW50XG4gICAgICpcbiAgICAgKiBAdHlwZSB7RWxlbWVudH1cbiAgICAgKi9cbiAgICBnZXQgX2RvYygpIHtcbiAgICAgIHJldHVybiB0aGlzLm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBudW1iZXIgb2YgcGl4ZWxzIHRoYXQgdGhlIGNvbnRlbnQgb2YgYW4gZWxlbWVudCBpcyBzY3JvbGxlZCB1cHdhcmQuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldCBfc2Nyb2xsVG9wKCkge1xuICAgICAgaWYgKHRoaXMuX2lzVmFsaWRTY3JvbGxUYXJnZXQoKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zY3JvbGxUYXJnZXQgPT09IHRoaXMuX2RvYyA/IHdpbmRvdy5wYWdlWU9mZnNldCA6IHRoaXMuc2Nyb2xsVGFyZ2V0LnNjcm9sbFRvcDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBudW1iZXIgb2YgcGl4ZWxzIHRoYXQgdGhlIGNvbnRlbnQgb2YgYW4gZWxlbWVudCBpcyBzY3JvbGxlZCB0byB0aGUgbGVmdC5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IF9zY3JvbGxMZWZ0KCkge1xuICAgICAgaWYgKHRoaXMuX2lzVmFsaWRTY3JvbGxUYXJnZXQoKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zY3JvbGxUYXJnZXQgPT09IHRoaXMuX2RvYyA/IHdpbmRvdy5wYWdlWE9mZnNldCA6IHRoaXMuc2Nyb2xsVGFyZ2V0LnNjcm9sbExlZnQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gMDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgbnVtYmVyIG9mIHBpeGVscyB0aGF0IHRoZSBjb250ZW50IG9mIGFuIGVsZW1lbnQgaXMgc2Nyb2xsZWQgdXB3YXJkLlxuICAgICAqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICBzZXQgX3Njcm9sbFRvcCh0b3ApIHtcbiAgICAgIGlmICh0aGlzLnNjcm9sbFRhcmdldCA9PT0gdGhpcy5fZG9jKSB7XG4gICAgICAgIHdpbmRvdy5zY3JvbGxUbyh3aW5kb3cucGFnZVhPZmZzZXQsIHRvcCk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX2lzVmFsaWRTY3JvbGxUYXJnZXQoKSkge1xuICAgICAgICB0aGlzLnNjcm9sbFRhcmdldC5zY3JvbGxUb3AgPSB0b3A7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIG51bWJlciBvZiBwaXhlbHMgdGhhdCB0aGUgY29udGVudCBvZiBhbiBlbGVtZW50IGlzIHNjcm9sbGVkIHRvIHRoZSBsZWZ0LlxuICAgICAqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICBzZXQgX3Njcm9sbExlZnQobGVmdCkge1xuICAgICAgaWYgKHRoaXMuc2Nyb2xsVGFyZ2V0ID09PSB0aGlzLl9kb2MpIHtcbiAgICAgICAgd2luZG93LnNjcm9sbFRvKGxlZnQsIHdpbmRvdy5wYWdlWU9mZnNldCk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX2lzVmFsaWRTY3JvbGxUYXJnZXQoKSkge1xuICAgICAgICB0aGlzLnNjcm9sbFRhcmdldC5zY3JvbGxMZWZ0ID0gbGVmdDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2Nyb2xscyB0aGUgY29udGVudCB0byBhIHBhcnRpY3VsYXIgcGxhY2UuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHNjcm9sbFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsZWZ0IFRoZSBsZWZ0IHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRvcCBUaGUgdG9wIHBvc2l0aW9uXG4gICAgICovXG4gICAgc2Nyb2xsOiBmdW5jdGlvbihsZWZ0LCB0b3ApIHtcbiAgICAgICBpZiAodGhpcy5zY3JvbGxUYXJnZXQgPT09IHRoaXMuX2RvYykge1xuICAgICAgICB3aW5kb3cuc2Nyb2xsVG8obGVmdCwgdG9wKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5faXNWYWxpZFNjcm9sbFRhcmdldCgpKSB7XG4gICAgICAgIHRoaXMuc2Nyb2xsVGFyZ2V0LnNjcm9sbExlZnQgPSBsZWZ0O1xuICAgICAgICB0aGlzLnNjcm9sbFRhcmdldC5zY3JvbGxUb3AgPSB0b3A7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHdpZHRoIG9mIHRoZSBzY3JvbGwgdGFyZ2V0LlxuICAgICAqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgX3Njcm9sbFRhcmdldFdpZHRoKCkge1xuICAgICAgaWYgKHRoaXMuX2lzVmFsaWRTY3JvbGxUYXJnZXQoKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zY3JvbGxUYXJnZXQgPT09IHRoaXMuX2RvYyA/IHdpbmRvdy5pbm5lcldpZHRoIDogdGhpcy5zY3JvbGxUYXJnZXQub2Zmc2V0V2lkdGg7XG4gICAgICB9XG4gICAgICByZXR1cm4gMDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgaGVpZ2h0IG9mIHRoZSBzY3JvbGwgdGFyZ2V0LlxuICAgICAqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgX3Njcm9sbFRhcmdldEhlaWdodCgpIHtcbiAgICAgIGlmICh0aGlzLl9pc1ZhbGlkU2Nyb2xsVGFyZ2V0KCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2Nyb2xsVGFyZ2V0ID09PSB0aGlzLl9kb2MgPyB3aW5kb3cuaW5uZXJIZWlnaHQgOiB0aGlzLnNjcm9sbFRhcmdldC5vZmZzZXRIZWlnaHQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gMDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBzY3JvbGwgdGFyZ2V0IGlzIGEgdmFsaWQgSFRNTEVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuICAgIF9pc1ZhbGlkU2Nyb2xsVGFyZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnNjcm9sbFRhcmdldCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50O1xuICAgIH0sXG5cbiAgICBfdG9nZ2xlU2Nyb2xsTGlzdGVuZXI6IGZ1bmN0aW9uKHllcywgc2Nyb2xsVGFyZ2V0KSB7XG4gICAgICB2YXIgZXZlbnRUYXJnZXQgPSBzY3JvbGxUYXJnZXQgPT09IHRoaXMuX2RvYyA/IHdpbmRvdyA6IHNjcm9sbFRhcmdldDtcbiAgICAgIGlmICh5ZXMpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9ib3VuZFNjcm9sbEhhbmRsZXIpIHtcbiAgICAgICAgICB0aGlzLl9ib3VuZFNjcm9sbEhhbmRsZXIgPSB0aGlzLl9zY3JvbGxIYW5kbGVyLmJpbmQodGhpcyk7XG4gICAgICAgICAgZXZlbnRUYXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy5fYm91bmRTY3JvbGxIYW5kbGVyKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuX2JvdW5kU2Nyb2xsSGFuZGxlcikge1xuICAgICAgICAgIGV2ZW50VGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMuX2JvdW5kU2Nyb2xsSGFuZGxlcik7XG4gICAgICAgICAgdGhpcy5fYm91bmRTY3JvbGxIYW5kbGVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBFbmFibGVzIG9yIGRpc2FibGVzIHRoZSBzY3JvbGwgZXZlbnQgbGlzdGVuZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHllcyBUcnVlIHRvIGFkZCB0aGUgZXZlbnQsIEZhbHNlIHRvIHJlbW92ZSBpdC5cbiAgICAgKi9cbiAgICB0b2dnbGVTY3JvbGxMaXN0ZW5lcjogZnVuY3Rpb24oeWVzKSB7XG4gICAgICB0aGlzLl9zaG91bGRIYXZlTGlzdGVuZXIgPSB5ZXM7XG4gICAgICB0aGlzLl90b2dnbGVTY3JvbGxMaXN0ZW5lcih5ZXMsIHRoaXMuc2Nyb2xsVGFyZ2V0KTtcbiAgICB9XG5cbiAgfTtcblxuPC9zY3JpcHQ+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL2lyb24tc2Nyb2xsLXRhcmdldC1iZWhhdmlvci9pcm9uLXNjcm9sbC10YXJnZXQtYmVoYXZpb3IuaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTUgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cblxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3BvbHltZXIvcG9seW1lci5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vaXJvbi1hMTF5LWtleXMtYmVoYXZpb3IvaXJvbi1hMTF5LWtleXMtYmVoYXZpb3IuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cImlyb24tY29udHJvbC1zdGF0ZS5odG1sXCI+XG5cbjxzY3JpcHQ+XG5cbiAgLyoqXG4gICAqIEBkZW1vIGRlbW8vaW5kZXguaHRtbFxuICAgKiBAcG9seW1lckJlaGF2aW9yIFBvbHltZXIuSXJvbkJ1dHRvblN0YXRlXG4gICAqL1xuICBQb2x5bWVyLklyb25CdXR0b25TdGF0ZUltcGwgPSB7XG5cbiAgICBwcm9wZXJ0aWVzOiB7XG5cbiAgICAgIC8qKlxuICAgICAgICogSWYgdHJ1ZSwgdGhlIHVzZXIgaXMgY3VycmVudGx5IGhvbGRpbmcgZG93biB0aGUgYnV0dG9uLlxuICAgICAgICovXG4gICAgICBwcmVzc2VkOiB7XG4gICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgIHJlYWRPbmx5OiB0cnVlLFxuICAgICAgICB2YWx1ZTogZmFsc2UsXG4gICAgICAgIHJlZmxlY3RUb0F0dHJpYnV0ZTogdHJ1ZSxcbiAgICAgICAgb2JzZXJ2ZXI6ICdfcHJlc3NlZENoYW5nZWQnXG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIElmIHRydWUsIHRoZSBidXR0b24gdG9nZ2xlcyB0aGUgYWN0aXZlIHN0YXRlIHdpdGggZWFjaCB0YXAgb3IgcHJlc3NcbiAgICAgICAqIG9mIHRoZSBzcGFjZWJhci5cbiAgICAgICAqL1xuICAgICAgdG9nZ2xlczoge1xuICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICB2YWx1ZTogZmFsc2UsXG4gICAgICAgIHJlZmxlY3RUb0F0dHJpYnV0ZTogdHJ1ZVxuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBJZiB0cnVlLCB0aGUgYnV0dG9uIGlzIGEgdG9nZ2xlIGFuZCBpcyBjdXJyZW50bHkgaW4gdGhlIGFjdGl2ZSBzdGF0ZS5cbiAgICAgICAqL1xuICAgICAgYWN0aXZlOiB7XG4gICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgIHZhbHVlOiBmYWxzZSxcbiAgICAgICAgbm90aWZ5OiB0cnVlLFxuICAgICAgICByZWZsZWN0VG9BdHRyaWJ1dGU6IHRydWVcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogVHJ1ZSBpZiB0aGUgZWxlbWVudCBpcyBjdXJyZW50bHkgYmVpbmcgcHJlc3NlZCBieSBhIFwicG9pbnRlcixcIiB3aGljaFxuICAgICAgICogaXMgbG9vc2VseSBkZWZpbmVkIGFzIG1vdXNlIG9yIHRvdWNoIGlucHV0IChidXQgc3BlY2lmaWNhbGx5IGV4Y2x1ZGluZ1xuICAgICAgICoga2V5Ym9hcmQgaW5wdXQpLlxuICAgICAgICovXG4gICAgICBwb2ludGVyRG93bjoge1xuICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICByZWFkT25seTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFRydWUgaWYgdGhlIGlucHV0IGRldmljZSB0aGF0IGNhdXNlZCB0aGUgZWxlbWVudCB0byByZWNlaXZlIGZvY3VzXG4gICAgICAgKiB3YXMgYSBrZXlib2FyZC5cbiAgICAgICAqL1xuICAgICAgcmVjZWl2ZWRGb2N1c0Zyb21LZXlib2FyZDoge1xuICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICByZWFkT25seTogdHJ1ZVxuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBUaGUgYXJpYSBhdHRyaWJ1dGUgdG8gYmUgc2V0IGlmIHRoZSBidXR0b24gaXMgYSB0b2dnbGUgYW5kIGluIHRoZVxuICAgICAgICogYWN0aXZlIHN0YXRlLlxuICAgICAgICovXG4gICAgICBhcmlhQWN0aXZlQXR0cmlidXRlOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgdmFsdWU6ICdhcmlhLXByZXNzZWQnLFxuICAgICAgICBvYnNlcnZlcjogJ19hcmlhQWN0aXZlQXR0cmlidXRlQ2hhbmdlZCdcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgbGlzdGVuZXJzOiB7XG4gICAgICBkb3duOiAnX2Rvd25IYW5kbGVyJyxcbiAgICAgIHVwOiAnX3VwSGFuZGxlcicsXG4gICAgICB0YXA6ICdfdGFwSGFuZGxlcidcbiAgICB9LFxuXG4gICAgb2JzZXJ2ZXJzOiBbXG4gICAgICAnX2ZvY3VzQ2hhbmdlZChmb2N1c2VkKScsXG4gICAgICAnX2FjdGl2ZUNoYW5nZWQoYWN0aXZlLCBhcmlhQWN0aXZlQXR0cmlidXRlKSdcbiAgICBdLFxuXG4gICAga2V5QmluZGluZ3M6IHtcbiAgICAgICdlbnRlcjprZXlkb3duJzogJ19hc3luY0NsaWNrJyxcbiAgICAgICdzcGFjZTprZXlkb3duJzogJ19zcGFjZUtleURvd25IYW5kbGVyJyxcbiAgICAgICdzcGFjZTprZXl1cCc6ICdfc3BhY2VLZXlVcEhhbmRsZXInLFxuICAgIH0sXG5cbiAgICBfbW91c2VFdmVudFJlOiAvXm1vdXNlLyxcblxuICAgIF90YXBIYW5kbGVyOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLnRvZ2dsZXMpIHtcbiAgICAgICAvLyBhIHRhcCBpcyBuZWVkZWQgdG8gdG9nZ2xlIHRoZSBhY3RpdmUgc3RhdGVcbiAgICAgICAgdGhpcy5fdXNlckFjdGl2YXRlKCF0aGlzLmFjdGl2ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBfZm9jdXNDaGFuZ2VkOiBmdW5jdGlvbihmb2N1c2VkKSB7XG4gICAgICB0aGlzLl9kZXRlY3RLZXlib2FyZEZvY3VzKGZvY3VzZWQpO1xuXG4gICAgICBpZiAoIWZvY3VzZWQpIHtcbiAgICAgICAgdGhpcy5fc2V0UHJlc3NlZChmYWxzZSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIF9kZXRlY3RLZXlib2FyZEZvY3VzOiBmdW5jdGlvbihmb2N1c2VkKSB7XG4gICAgICB0aGlzLl9zZXRSZWNlaXZlZEZvY3VzRnJvbUtleWJvYXJkKCF0aGlzLnBvaW50ZXJEb3duICYmIGZvY3VzZWQpO1xuICAgIH0sXG5cbiAgICAvLyB0byBlbXVsYXRlIG5hdGl2ZSBjaGVja2JveCwgKGRlLSlhY3RpdmF0aW9ucyBmcm9tIGEgdXNlciBpbnRlcmFjdGlvbiBmaXJlXG4gICAgLy8gJ2NoYW5nZScgZXZlbnRzXG4gICAgX3VzZXJBY3RpdmF0ZTogZnVuY3Rpb24oYWN0aXZlKSB7XG4gICAgICBpZiAodGhpcy5hY3RpdmUgIT09IGFjdGl2ZSkge1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IGFjdGl2ZTtcbiAgICAgICAgdGhpcy5maXJlKCdjaGFuZ2UnKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgX2Rvd25IYW5kbGVyOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgdGhpcy5fc2V0UG9pbnRlckRvd24odHJ1ZSk7XG4gICAgICB0aGlzLl9zZXRQcmVzc2VkKHRydWUpO1xuICAgICAgdGhpcy5fc2V0UmVjZWl2ZWRGb2N1c0Zyb21LZXlib2FyZChmYWxzZSk7XG4gICAgfSxcblxuICAgIF91cEhhbmRsZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fc2V0UG9pbnRlckRvd24oZmFsc2UpO1xuICAgICAgdGhpcy5fc2V0UHJlc3NlZChmYWxzZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IUtleWJvYXJkRXZlbnR9IGV2ZW50IC5cbiAgICAgKi9cbiAgICBfc3BhY2VLZXlEb3duSGFuZGxlcjogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIHZhciBrZXlib2FyZEV2ZW50ID0gZXZlbnQuZGV0YWlsLmtleWJvYXJkRXZlbnQ7XG4gICAgICB2YXIgdGFyZ2V0ID0gUG9seW1lci5kb20oa2V5Ym9hcmRFdmVudCkubG9jYWxUYXJnZXQ7XG5cbiAgICAgIC8vIElnbm9yZSB0aGUgZXZlbnQgaWYgdGhpcyBpcyBjb21pbmcgZnJvbSBhIGZvY3VzZWQgbGlnaHQgY2hpbGQsIHNpbmNlIHRoYXRcbiAgICAgIC8vIGVsZW1lbnQgd2lsbCBkZWFsIHdpdGggaXQuXG4gICAgICBpZiAodGhpcy5pc0xpZ2h0RGVzY2VuZGFudCgvKiogQHR5cGUge05vZGV9ICovKHRhcmdldCkpKVxuICAgICAgICByZXR1cm47XG5cbiAgICAgIGtleWJvYXJkRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGtleWJvYXJkRXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICB0aGlzLl9zZXRQcmVzc2VkKHRydWUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyFLZXlib2FyZEV2ZW50fSBldmVudCAuXG4gICAgICovXG4gICAgX3NwYWNlS2V5VXBIYW5kbGVyOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgdmFyIGtleWJvYXJkRXZlbnQgPSBldmVudC5kZXRhaWwua2V5Ym9hcmRFdmVudDtcbiAgICAgIHZhciB0YXJnZXQgPSBQb2x5bWVyLmRvbShrZXlib2FyZEV2ZW50KS5sb2NhbFRhcmdldDtcblxuICAgICAgLy8gSWdub3JlIHRoZSBldmVudCBpZiB0aGlzIGlzIGNvbWluZyBmcm9tIGEgZm9jdXNlZCBsaWdodCBjaGlsZCwgc2luY2UgdGhhdFxuICAgICAgLy8gZWxlbWVudCB3aWxsIGRlYWwgd2l0aCBpdC5cbiAgICAgIGlmICh0aGlzLmlzTGlnaHREZXNjZW5kYW50KC8qKiBAdHlwZSB7Tm9kZX0gKi8odGFyZ2V0KSkpXG4gICAgICAgIHJldHVybjtcblxuICAgICAgaWYgKHRoaXMucHJlc3NlZCkge1xuICAgICAgICB0aGlzLl9hc3luY0NsaWNrKCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9zZXRQcmVzc2VkKGZhbHNlKTtcbiAgICB9LFxuXG4gICAgLy8gdHJpZ2dlciBjbGljayBhc3luY2hyb25vdXNseSwgdGhlIGFzeW5jaHJvbnkgaXMgdXNlZnVsIHRvIGFsbG93IG9uZVxuICAgIC8vIGV2ZW50IGhhbmRsZXIgdG8gdW53aW5kIGJlZm9yZSB0cmlnZ2VyaW5nIGFub3RoZXIgZXZlbnRcbiAgICBfYXN5bmNDbGljazogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmFzeW5jKGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmNsaWNrKCk7XG4gICAgICB9LCAxKTtcbiAgICB9LFxuXG4gICAgLy8gYW55IG9mIHRoZXNlIGNoYW5nZXMgYXJlIGNvbnNpZGVyZWQgYSBjaGFuZ2UgdG8gYnV0dG9uIHN0YXRlXG5cbiAgICBfcHJlc3NlZENoYW5nZWQ6IGZ1bmN0aW9uKHByZXNzZWQpIHtcbiAgICAgIHRoaXMuX2NoYW5nZWRCdXR0b25TdGF0ZSgpO1xuICAgIH0sXG5cbiAgICBfYXJpYUFjdGl2ZUF0dHJpYnV0ZUNoYW5nZWQ6IGZ1bmN0aW9uKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgaWYgKG9sZFZhbHVlICYmIG9sZFZhbHVlICE9IHZhbHVlICYmIHRoaXMuaGFzQXR0cmlidXRlKG9sZFZhbHVlKSkge1xuICAgICAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZShvbGRWYWx1ZSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIF9hY3RpdmVDaGFuZ2VkOiBmdW5jdGlvbihhY3RpdmUsIGFyaWFBY3RpdmVBdHRyaWJ1dGUpIHtcbiAgICAgIGlmICh0aGlzLnRvZ2dsZXMpIHtcbiAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUodGhpcy5hcmlhQWN0aXZlQXR0cmlidXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmUgPyAndHJ1ZScgOiAnZmFsc2UnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlKHRoaXMuYXJpYUFjdGl2ZUF0dHJpYnV0ZSk7XG4gICAgICB9XG4gICAgICB0aGlzLl9jaGFuZ2VkQnV0dG9uU3RhdGUoKTtcbiAgICB9LFxuXG4gICAgX2NvbnRyb2xTdGF0ZUNoYW5nZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgdGhpcy5fc2V0UHJlc3NlZChmYWxzZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9jaGFuZ2VkQnV0dG9uU3RhdGUoKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gcHJvdmlkZSBob29rIGZvciBmb2xsb3ctb24gYmVoYXZpb3JzIHRvIHJlYWN0IHRvIGJ1dHRvbi1zdGF0ZVxuXG4gICAgX2NoYW5nZWRCdXR0b25TdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5fYnV0dG9uU3RhdGVDaGFuZ2VkKSB7XG4gICAgICAgIHRoaXMuX2J1dHRvblN0YXRlQ2hhbmdlZCgpOyAvLyBhYnN0cmFjdFxuICAgICAgfVxuICAgIH1cblxuICB9O1xuXG4gIC8qKiBAcG9seW1lckJlaGF2aW9yICovXG4gIFBvbHltZXIuSXJvbkJ1dHRvblN0YXRlID0gW1xuICAgIFBvbHltZXIuSXJvbkExMXlLZXlzQmVoYXZpb3IsXG4gICAgUG9seW1lci5Jcm9uQnV0dG9uU3RhdGVJbXBsXG4gIF07XG5cbjwvc2NyaXB0PlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9pcm9uLWJlaGF2aW9ycy9pcm9uLWJ1dHRvbi1zdGF0ZS5odG1sIiwiXG5yZXF1aXJlKCcuLi9wb2x5bWVyL3BvbHltZXIuaHRtbCcpO1xuXG5jb25zdCBSZWdpc3Rlckh0bWxUZW1wbGF0ZSA9IHJlcXVpcmUoJ3BvbHltZXItd2VicGFjay1sb2FkZXIvcmVnaXN0ZXItaHRtbC10ZW1wbGF0ZScpO1xuXG5SZWdpc3Rlckh0bWxUZW1wbGF0ZS50b0JvZHkoXCI8Y3VzdG9tLXN0eWxlPiA8c3R5bGUgaXM9Y3VzdG9tLXN0eWxlPmh0bWx7LS1nb29nbGUtcmVkLTEwMDojZjRjN2MzOy0tZ29vZ2xlLXJlZC0zMDA6I2U2N2M3MzstLWdvb2dsZS1yZWQtNTAwOiNkYjQ0Mzc7LS1nb29nbGUtcmVkLTcwMDojYzUzOTI5Oy0tZ29vZ2xlLWJsdWUtMTAwOiNjNmRhZmM7LS1nb29nbGUtYmx1ZS0zMDA6IzdiYWFmNzstLWdvb2dsZS1ibHVlLTUwMDojNDI4NWY0Oy0tZ29vZ2xlLWJsdWUtNzAwOiMzMzY3ZDY7LS1nb29nbGUtZ3JlZW4tMTAwOiNiN2UxY2Q7LS1nb29nbGUtZ3JlZW4tMzAwOiM1N2JiOGE7LS1nb29nbGUtZ3JlZW4tNTAwOiMwZjlkNTg7LS1nb29nbGUtZ3JlZW4tNzAwOiMwYjgwNDM7LS1nb29nbGUteWVsbG93LTEwMDojZmNlOGIyOy0tZ29vZ2xlLXllbGxvdy0zMDA6I2Y3Y2I0ZDstLWdvb2dsZS15ZWxsb3ctNTAwOiNmNGI0MDA7LS1nb29nbGUteWVsbG93LTcwMDojZjA5MzAwOy0tZ29vZ2xlLWdyZXktMTAwOiNmNWY1ZjU7LS1nb29nbGUtZ3JleS0zMDA6I2UwZTBlMDstLWdvb2dsZS1ncmV5LTUwMDojOWU5ZTllOy0tZ29vZ2xlLWdyZXktNzAwOiM2MTYxNjE7LS1wYXBlci1yZWQtNTA6I2ZmZWJlZTstLXBhcGVyLXJlZC0xMDA6I2ZmY2RkMjstLXBhcGVyLXJlZC0yMDA6I2VmOWE5YTstLXBhcGVyLXJlZC0zMDA6I2U1NzM3MzstLXBhcGVyLXJlZC00MDA6I2VmNTM1MDstLXBhcGVyLXJlZC01MDA6I2Y0NDMzNjstLXBhcGVyLXJlZC02MDA6I2U1MzkzNTstLXBhcGVyLXJlZC03MDA6I2QzMmYyZjstLXBhcGVyLXJlZC04MDA6I2M2MjgyODstLXBhcGVyLXJlZC05MDA6I2I3MWMxYzstLXBhcGVyLXJlZC1hMTAwOiNmZjhhODA7LS1wYXBlci1yZWQtYTIwMDojZmY1MjUyOy0tcGFwZXItcmVkLWE0MDA6I2ZmMTc0NDstLXBhcGVyLXJlZC1hNzAwOiNkNTAwMDA7LS1wYXBlci1waW5rLTUwOiNmY2U0ZWM7LS1wYXBlci1waW5rLTEwMDojZjhiYmQwOy0tcGFwZXItcGluay0yMDA6I2Y0OGZiMTstLXBhcGVyLXBpbmstMzAwOiNmMDYyOTI7LS1wYXBlci1waW5rLTQwMDojZWM0MDdhOy0tcGFwZXItcGluay01MDA6I2U5MWU2MzstLXBhcGVyLXBpbmstNjAwOiNkODFiNjA7LS1wYXBlci1waW5rLTcwMDojYzIxODViOy0tcGFwZXItcGluay04MDA6I2FkMTQ1NzstLXBhcGVyLXBpbmstOTAwOiM4ODBlNGY7LS1wYXBlci1waW5rLWExMDA6I2ZmODBhYjstLXBhcGVyLXBpbmstYTIwMDojZmY0MDgxOy0tcGFwZXItcGluay1hNDAwOiNmNTAwNTc7LS1wYXBlci1waW5rLWE3MDA6I2M1MTE2MjstLXBhcGVyLXB1cnBsZS01MDojZjNlNWY1Oy0tcGFwZXItcHVycGxlLTEwMDojZTFiZWU3Oy0tcGFwZXItcHVycGxlLTIwMDojY2U5M2Q4Oy0tcGFwZXItcHVycGxlLTMwMDojYmE2OGM4Oy0tcGFwZXItcHVycGxlLTQwMDojYWI0N2JjOy0tcGFwZXItcHVycGxlLTUwMDojOWMyN2IwOy0tcGFwZXItcHVycGxlLTYwMDojOGUyNGFhOy0tcGFwZXItcHVycGxlLTcwMDojN2IxZmEyOy0tcGFwZXItcHVycGxlLTgwMDojNmExYjlhOy0tcGFwZXItcHVycGxlLTkwMDojNGExNDhjOy0tcGFwZXItcHVycGxlLWExMDA6I2VhODBmYzstLXBhcGVyLXB1cnBsZS1hMjAwOiNlMDQwZmI7LS1wYXBlci1wdXJwbGUtYTQwMDojZDUwMGY5Oy0tcGFwZXItcHVycGxlLWE3MDA6I2FhMDBmZjstLXBhcGVyLWRlZXAtcHVycGxlLTUwOiNlZGU3ZjY7LS1wYXBlci1kZWVwLXB1cnBsZS0xMDA6I2QxYzRlOTstLXBhcGVyLWRlZXAtcHVycGxlLTIwMDojYjM5ZGRiOy0tcGFwZXItZGVlcC1wdXJwbGUtMzAwOiM5NTc1Y2Q7LS1wYXBlci1kZWVwLXB1cnBsZS00MDA6IzdlNTdjMjstLXBhcGVyLWRlZXAtcHVycGxlLTUwMDojNjczYWI3Oy0tcGFwZXItZGVlcC1wdXJwbGUtNjAwOiM1ZTM1YjE7LS1wYXBlci1kZWVwLXB1cnBsZS03MDA6IzUxMmRhODstLXBhcGVyLWRlZXAtcHVycGxlLTgwMDojNDUyN2EwOy0tcGFwZXItZGVlcC1wdXJwbGUtOTAwOiMzMTFiOTI7LS1wYXBlci1kZWVwLXB1cnBsZS1hMTAwOiNiMzg4ZmY7LS1wYXBlci1kZWVwLXB1cnBsZS1hMjAwOiM3YzRkZmY7LS1wYXBlci1kZWVwLXB1cnBsZS1hNDAwOiM2NTFmZmY7LS1wYXBlci1kZWVwLXB1cnBsZS1hNzAwOiM2MjAwZWE7LS1wYXBlci1pbmRpZ28tNTA6I2U4ZWFmNjstLXBhcGVyLWluZGlnby0xMDA6I2M1Y2FlOTstLXBhcGVyLWluZGlnby0yMDA6IzlmYThkYTstLXBhcGVyLWluZGlnby0zMDA6Izc5ODZjYjstLXBhcGVyLWluZGlnby00MDA6IzVjNmJjMDstLXBhcGVyLWluZGlnby01MDA6IzNmNTFiNTstLXBhcGVyLWluZGlnby02MDA6IzM5NDlhYjstLXBhcGVyLWluZGlnby03MDA6IzMwM2Y5ZjstLXBhcGVyLWluZGlnby04MDA6IzI4MzU5MzstLXBhcGVyLWluZGlnby05MDA6IzFhMjM3ZTstLXBhcGVyLWluZGlnby1hMTAwOiM4YzllZmY7LS1wYXBlci1pbmRpZ28tYTIwMDojNTM2ZGZlOy0tcGFwZXItaW5kaWdvLWE0MDA6IzNkNWFmZTstLXBhcGVyLWluZGlnby1hNzAwOiMzMDRmZmU7LS1wYXBlci1ibHVlLTUwOiNlM2YyZmQ7LS1wYXBlci1ibHVlLTEwMDojYmJkZWZiOy0tcGFwZXItYmx1ZS0yMDA6IzkwY2FmOTstLXBhcGVyLWJsdWUtMzAwOiM2NGI1ZjY7LS1wYXBlci1ibHVlLTQwMDojNDJhNWY1Oy0tcGFwZXItYmx1ZS01MDA6IzIxOTZmMzstLXBhcGVyLWJsdWUtNjAwOiMxZTg4ZTU7LS1wYXBlci1ibHVlLTcwMDojMTk3NmQyOy0tcGFwZXItYmx1ZS04MDA6IzE1NjVjMDstLXBhcGVyLWJsdWUtOTAwOiMwZDQ3YTE7LS1wYXBlci1ibHVlLWExMDA6IzgyYjFmZjstLXBhcGVyLWJsdWUtYTIwMDojNDQ4YWZmOy0tcGFwZXItYmx1ZS1hNDAwOiMyOTc5ZmY7LS1wYXBlci1ibHVlLWE3MDA6IzI5NjJmZjstLXBhcGVyLWxpZ2h0LWJsdWUtNTA6I2UxZjVmZTstLXBhcGVyLWxpZ2h0LWJsdWUtMTAwOiNiM2U1ZmM7LS1wYXBlci1saWdodC1ibHVlLTIwMDojODFkNGZhOy0tcGFwZXItbGlnaHQtYmx1ZS0zMDA6IzRmYzNmNzstLXBhcGVyLWxpZ2h0LWJsdWUtNDAwOiMyOWI2ZjY7LS1wYXBlci1saWdodC1ibHVlLTUwMDojMDNhOWY0Oy0tcGFwZXItbGlnaHQtYmx1ZS02MDA6IzAzOWJlNTstLXBhcGVyLWxpZ2h0LWJsdWUtNzAwOiMwMjg4ZDE7LS1wYXBlci1saWdodC1ibHVlLTgwMDojMDI3N2JkOy0tcGFwZXItbGlnaHQtYmx1ZS05MDA6IzAxNTc5YjstLXBhcGVyLWxpZ2h0LWJsdWUtYTEwMDojODBkOGZmOy0tcGFwZXItbGlnaHQtYmx1ZS1hMjAwOiM0MGM0ZmY7LS1wYXBlci1saWdodC1ibHVlLWE0MDA6IzAwYjBmZjstLXBhcGVyLWxpZ2h0LWJsdWUtYTcwMDojMDA5MWVhOy0tcGFwZXItY3lhbi01MDojZTBmN2ZhOy0tcGFwZXItY3lhbi0xMDA6I2IyZWJmMjstLXBhcGVyLWN5YW4tMjAwOiM4MGRlZWE7LS1wYXBlci1jeWFuLTMwMDojNGRkMGUxOy0tcGFwZXItY3lhbi00MDA6IzI2YzZkYTstLXBhcGVyLWN5YW4tNTAwOiMwMGJjZDQ7LS1wYXBlci1jeWFuLTYwMDojMDBhY2MxOy0tcGFwZXItY3lhbi03MDA6IzAwOTdhNzstLXBhcGVyLWN5YW4tODAwOiMwMDgzOGY7LS1wYXBlci1jeWFuLTkwMDojMDA2MDY0Oy0tcGFwZXItY3lhbi1hMTAwOiM4NGZmZmY7LS1wYXBlci1jeWFuLWEyMDA6IzE4ZmZmZjstLXBhcGVyLWN5YW4tYTQwMDojMDBlNWZmOy0tcGFwZXItY3lhbi1hNzAwOiMwMGI4ZDQ7LS1wYXBlci10ZWFsLTUwOiNlMGYyZjE7LS1wYXBlci10ZWFsLTEwMDojYjJkZmRiOy0tcGFwZXItdGVhbC0yMDA6IzgwY2JjNDstLXBhcGVyLXRlYWwtMzAwOiM0ZGI2YWM7LS1wYXBlci10ZWFsLTQwMDojMjZhNjlhOy0tcGFwZXItdGVhbC01MDA6IzAwOTY4ODstLXBhcGVyLXRlYWwtNjAwOiMwMDg5N2I7LS1wYXBlci10ZWFsLTcwMDojMDA3OTZiOy0tcGFwZXItdGVhbC04MDA6IzAwNjk1YzstLXBhcGVyLXRlYWwtOTAwOiMwMDRkNDA7LS1wYXBlci10ZWFsLWExMDA6I2E3ZmZlYjstLXBhcGVyLXRlYWwtYTIwMDojNjRmZmRhOy0tcGFwZXItdGVhbC1hNDAwOiMxZGU5YjY7LS1wYXBlci10ZWFsLWE3MDA6IzAwYmZhNTstLXBhcGVyLWdyZWVuLTUwOiNlOGY1ZTk7LS1wYXBlci1ncmVlbi0xMDA6I2M4ZTZjOTstLXBhcGVyLWdyZWVuLTIwMDojYTVkNmE3Oy0tcGFwZXItZ3JlZW4tMzAwOiM4MWM3ODQ7LS1wYXBlci1ncmVlbi00MDA6IzY2YmI2YTstLXBhcGVyLWdyZWVuLTUwMDojNGNhZjUwOy0tcGFwZXItZ3JlZW4tNjAwOiM0M2EwNDc7LS1wYXBlci1ncmVlbi03MDA6IzM4OGUzYzstLXBhcGVyLWdyZWVuLTgwMDojMmU3ZDMyOy0tcGFwZXItZ3JlZW4tOTAwOiMxYjVlMjA7LS1wYXBlci1ncmVlbi1hMTAwOiNiOWY2Y2E7LS1wYXBlci1ncmVlbi1hMjAwOiM2OWYwYWU7LS1wYXBlci1ncmVlbi1hNDAwOiMwMGU2NzY7LS1wYXBlci1ncmVlbi1hNzAwOiMwMGM4NTM7LS1wYXBlci1saWdodC1ncmVlbi01MDojZjFmOGU5Oy0tcGFwZXItbGlnaHQtZ3JlZW4tMTAwOiNkY2VkYzg7LS1wYXBlci1saWdodC1ncmVlbi0yMDA6I2M1ZTFhNTstLXBhcGVyLWxpZ2h0LWdyZWVuLTMwMDojYWVkNTgxOy0tcGFwZXItbGlnaHQtZ3JlZW4tNDAwOiM5Y2NjNjU7LS1wYXBlci1saWdodC1ncmVlbi01MDA6IzhiYzM0YTstLXBhcGVyLWxpZ2h0LWdyZWVuLTYwMDojN2NiMzQyOy0tcGFwZXItbGlnaHQtZ3JlZW4tNzAwOiM2ODlmMzg7LS1wYXBlci1saWdodC1ncmVlbi04MDA6IzU1OGIyZjstLXBhcGVyLWxpZ2h0LWdyZWVuLTkwMDojMzM2OTFlOy0tcGFwZXItbGlnaHQtZ3JlZW4tYTEwMDojY2NmZjkwOy0tcGFwZXItbGlnaHQtZ3JlZW4tYTIwMDojYjJmZjU5Oy0tcGFwZXItbGlnaHQtZ3JlZW4tYTQwMDojNzZmZjAzOy0tcGFwZXItbGlnaHQtZ3JlZW4tYTcwMDojNjRkZDE3Oy0tcGFwZXItbGltZS01MDojZjlmYmU3Oy0tcGFwZXItbGltZS0xMDA6I2YwZjRjMzstLXBhcGVyLWxpbWUtMjAwOiNlNmVlOWM7LS1wYXBlci1saW1lLTMwMDojZGNlNzc1Oy0tcGFwZXItbGltZS00MDA6I2Q0ZTE1NzstLXBhcGVyLWxpbWUtNTAwOiNjZGRjMzk7LS1wYXBlci1saW1lLTYwMDojYzBjYTMzOy0tcGFwZXItbGltZS03MDA6I2FmYjQyYjstLXBhcGVyLWxpbWUtODAwOiM5ZTlkMjQ7LS1wYXBlci1saW1lLTkwMDojODI3NzE3Oy0tcGFwZXItbGltZS1hMTAwOiNmNGZmODE7LS1wYXBlci1saW1lLWEyMDA6I2VlZmY0MTstLXBhcGVyLWxpbWUtYTQwMDojYzZmZjAwOy0tcGFwZXItbGltZS1hNzAwOiNhZWVhMDA7LS1wYXBlci15ZWxsb3ctNTA6I2ZmZmRlNzstLXBhcGVyLXllbGxvdy0xMDA6I2ZmZjljNDstLXBhcGVyLXllbGxvdy0yMDA6I2ZmZjU5ZDstLXBhcGVyLXllbGxvdy0zMDA6I2ZmZjE3NjstLXBhcGVyLXllbGxvdy00MDA6I2ZmZWU1ODstLXBhcGVyLXllbGxvdy01MDA6I2ZmZWIzYjstLXBhcGVyLXllbGxvdy02MDA6I2ZkZDgzNTstLXBhcGVyLXllbGxvdy03MDA6I2ZiYzAyZDstLXBhcGVyLXllbGxvdy04MDA6I2Y5YTgyNTstLXBhcGVyLXllbGxvdy05MDA6I2Y1N2YxNzstLXBhcGVyLXllbGxvdy1hMTAwOiNmZmZmOGQ7LS1wYXBlci15ZWxsb3ctYTIwMDojZmZmZjAwOy0tcGFwZXIteWVsbG93LWE0MDA6I2ZmZWEwMDstLXBhcGVyLXllbGxvdy1hNzAwOiNmZmQ2MDA7LS1wYXBlci1hbWJlci01MDojZmZmOGUxOy0tcGFwZXItYW1iZXItMTAwOiNmZmVjYjM7LS1wYXBlci1hbWJlci0yMDA6I2ZmZTA4MjstLXBhcGVyLWFtYmVyLTMwMDojZmZkNTRmOy0tcGFwZXItYW1iZXItNDAwOiNmZmNhMjg7LS1wYXBlci1hbWJlci01MDA6I2ZmYzEwNzstLXBhcGVyLWFtYmVyLTYwMDojZmZiMzAwOy0tcGFwZXItYW1iZXItNzAwOiNmZmEwMDA7LS1wYXBlci1hbWJlci04MDA6I2ZmOGYwMDstLXBhcGVyLWFtYmVyLTkwMDojZmY2ZjAwOy0tcGFwZXItYW1iZXItYTEwMDojZmZlNTdmOy0tcGFwZXItYW1iZXItYTIwMDojZmZkNzQwOy0tcGFwZXItYW1iZXItYTQwMDojZmZjNDAwOy0tcGFwZXItYW1iZXItYTcwMDojZmZhYjAwOy0tcGFwZXItb3JhbmdlLTUwOiNmZmYzZTA7LS1wYXBlci1vcmFuZ2UtMTAwOiNmZmUwYjI7LS1wYXBlci1vcmFuZ2UtMjAwOiNmZmNjODA7LS1wYXBlci1vcmFuZ2UtMzAwOiNmZmI3NGQ7LS1wYXBlci1vcmFuZ2UtNDAwOiNmZmE3MjY7LS1wYXBlci1vcmFuZ2UtNTAwOiNmZjk4MDA7LS1wYXBlci1vcmFuZ2UtNjAwOiNmYjhjMDA7LS1wYXBlci1vcmFuZ2UtNzAwOiNmNTdjMDA7LS1wYXBlci1vcmFuZ2UtODAwOiNlZjZjMDA7LS1wYXBlci1vcmFuZ2UtOTAwOiNlNjUxMDA7LS1wYXBlci1vcmFuZ2UtYTEwMDojZmZkMTgwOy0tcGFwZXItb3JhbmdlLWEyMDA6I2ZmYWI0MDstLXBhcGVyLW9yYW5nZS1hNDAwOiNmZjkxMDA7LS1wYXBlci1vcmFuZ2UtYTcwMDojZmY2NTAwOy0tcGFwZXItZGVlcC1vcmFuZ2UtNTA6I2ZiZTllNzstLXBhcGVyLWRlZXAtb3JhbmdlLTEwMDojZmZjY2JjOy0tcGFwZXItZGVlcC1vcmFuZ2UtMjAwOiNmZmFiOTE7LS1wYXBlci1kZWVwLW9yYW5nZS0zMDA6I2ZmOGE2NTstLXBhcGVyLWRlZXAtb3JhbmdlLTQwMDojZmY3MDQzOy0tcGFwZXItZGVlcC1vcmFuZ2UtNTAwOiNmZjU3MjI7LS1wYXBlci1kZWVwLW9yYW5nZS02MDA6I2Y0NTExZTstLXBhcGVyLWRlZXAtb3JhbmdlLTcwMDojZTY0YTE5Oy0tcGFwZXItZGVlcC1vcmFuZ2UtODAwOiNkODQzMTU7LS1wYXBlci1kZWVwLW9yYW5nZS05MDA6I2JmMzYwYzstLXBhcGVyLWRlZXAtb3JhbmdlLWExMDA6I2ZmOWU4MDstLXBhcGVyLWRlZXAtb3JhbmdlLWEyMDA6I2ZmNmU0MDstLXBhcGVyLWRlZXAtb3JhbmdlLWE0MDA6I2ZmM2QwMDstLXBhcGVyLWRlZXAtb3JhbmdlLWE3MDA6I2RkMmMwMDstLXBhcGVyLWJyb3duLTUwOiNlZmViZTk7LS1wYXBlci1icm93bi0xMDA6I2Q3Y2NjODstLXBhcGVyLWJyb3duLTIwMDojYmNhYWE0Oy0tcGFwZXItYnJvd24tMzAwOiNhMTg4N2Y7LS1wYXBlci1icm93bi00MDA6IzhkNmU2MzstLXBhcGVyLWJyb3duLTUwMDojNzk1NTQ4Oy0tcGFwZXItYnJvd24tNjAwOiM2ZDRjNDE7LS1wYXBlci1icm93bi03MDA6IzVkNDAzNzstLXBhcGVyLWJyb3duLTgwMDojNGUzNDJlOy0tcGFwZXItYnJvd24tOTAwOiMzZTI3MjM7LS1wYXBlci1ncmV5LTUwOiNmYWZhZmE7LS1wYXBlci1ncmV5LTEwMDojZjVmNWY1Oy0tcGFwZXItZ3JleS0yMDA6I2VlZWVlZTstLXBhcGVyLWdyZXktMzAwOiNlMGUwZTA7LS1wYXBlci1ncmV5LTQwMDojYmRiZGJkOy0tcGFwZXItZ3JleS01MDA6IzllOWU5ZTstLXBhcGVyLWdyZXktNjAwOiM3NTc1NzU7LS1wYXBlci1ncmV5LTcwMDojNjE2MTYxOy0tcGFwZXItZ3JleS04MDA6IzQyNDI0MjstLXBhcGVyLWdyZXktOTAwOiMyMTIxMjE7LS1wYXBlci1ibHVlLWdyZXktNTA6I2VjZWZmMTstLXBhcGVyLWJsdWUtZ3JleS0xMDA6I2NmZDhkYzstLXBhcGVyLWJsdWUtZ3JleS0yMDA6I2IwYmVjNTstLXBhcGVyLWJsdWUtZ3JleS0zMDA6IzkwYTRhZTstLXBhcGVyLWJsdWUtZ3JleS00MDA6Izc4OTA5YzstLXBhcGVyLWJsdWUtZ3JleS01MDA6IzYwN2Q4YjstLXBhcGVyLWJsdWUtZ3JleS02MDA6IzU0NmU3YTstLXBhcGVyLWJsdWUtZ3JleS03MDA6IzQ1NWE2NDstLXBhcGVyLWJsdWUtZ3JleS04MDA6IzM3NDc0ZjstLXBhcGVyLWJsdWUtZ3JleS05MDA6IzI2MzIzODstLWRhcmstZGl2aWRlci1vcGFjaXR5OjAuMTI7LS1kYXJrLWRpc2FibGVkLW9wYWNpdHk6MC4zODstLWRhcmstc2Vjb25kYXJ5LW9wYWNpdHk6MC41NDstLWRhcmstcHJpbWFyeS1vcGFjaXR5OjAuODc7LS1saWdodC1kaXZpZGVyLW9wYWNpdHk6MC4xMjstLWxpZ2h0LWRpc2FibGVkLW9wYWNpdHk6MC4zOy0tbGlnaHQtc2Vjb25kYXJ5LW9wYWNpdHk6MC43Oy0tbGlnaHQtcHJpbWFyeS1vcGFjaXR5OjEuMH08L3N0eWxlPiA8L2N1c3RvbS1zdHlsZT5cIik7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL3BhcGVyLXN0eWxlcy9jb2xvci5odG1sIiwiPCEtLVxyXG5AbGljZW5zZVxyXG5Db3B5cmlnaHQgKGMpIDIwMTYgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XHJcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XHJcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxyXG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xyXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxyXG4tLT5cclxuXHJcbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi9ib3dlcl9jb21wb25lbnRzL3BvbHltZXIvcG9seW1lci1lbGVtZW50Lmh0bWxcIj5cclxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL2Jvd2VyX2NvbXBvbmVudHMvYXBwLWxheW91dC9hcHAtZHJhd2VyL2FwcC1kcmF3ZXIuaHRtbFwiPlxyXG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vYm93ZXJfY29tcG9uZW50cy9hcHAtbGF5b3V0L2FwcC1kcmF3ZXItbGF5b3V0L2FwcC1kcmF3ZXItbGF5b3V0Lmh0bWxcIj5cclxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL2Jvd2VyX2NvbXBvbmVudHMvYXBwLWxheW91dC9hcHAtaGVhZGVyL2FwcC1oZWFkZXIuaHRtbFwiPlxyXG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vYm93ZXJfY29tcG9uZW50cy9hcHAtbGF5b3V0L2FwcC1oZWFkZXItbGF5b3V0L2FwcC1oZWFkZXItbGF5b3V0Lmh0bWxcIj5cclxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL2Jvd2VyX2NvbXBvbmVudHMvYXBwLWxheW91dC9hcHAtc2Nyb2xsLWVmZmVjdHMvYXBwLXNjcm9sbC1lZmZlY3RzLmh0bWxcIj5cclxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL2Jvd2VyX2NvbXBvbmVudHMvYXBwLWxheW91dC9hcHAtdG9vbGJhci9hcHAtdG9vbGJhci5odG1sXCI+XHJcbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi9ib3dlcl9jb21wb25lbnRzL2FwcC1yb3V0ZS9hcHAtbG9jYXRpb24uaHRtbFwiPlxyXG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vYm93ZXJfY29tcG9uZW50cy9hcHAtcm91dGUvYXBwLXJvdXRlLmh0bWxcIj5cclxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL2Jvd2VyX2NvbXBvbmVudHMvaXJvbi1wYWdlcy9pcm9uLXBhZ2VzLmh0bWxcIj5cclxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL2Jvd2VyX2NvbXBvbmVudHMvaXJvbi1zZWxlY3Rvci9pcm9uLXNlbGVjdG9yLmh0bWxcIj5cclxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL2Jvd2VyX2NvbXBvbmVudHMvcGFwZXItaWNvbi1idXR0b24vcGFwZXItaWNvbi1idXR0b24uaHRtbFwiPlxyXG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwibXktaWNvbnMuaHRtbFwiPlxyXG5cclxuPGRvbS1tb2R1bGUgaWQ9XCJsdWRpbmctYXBwXCI+XHJcbiAgPHRlbXBsYXRlPlxyXG4gICAgPHN0eWxlPlxyXG4gICAgICAgOmhvc3Qge1xyXG4gICAgICAgIC0tYXBwLXByaW1hcnktY29sb3I6ICMzRDI4MTQ7XHJcbiAgICAgICAgLS1hcHAtc2Vjb25kYXJ5LWNvbG9yOiAjRkYzQzNDO1xyXG5cclxuICAgICAgICBkaXNwbGF5OiBibG9jaztcclxuICAgICAgfVxyXG5cclxuICAgICAgYXBwLWRyYXdlci1sYXlvdXQ6bm90KFtuYXJyb3ddKSBbZHJhd2VyLXRvZ2dsZV0ge1xyXG4gICAgICAgIGRpc3BsYXk6IG5vbmU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGFwcC1oZWFkZXIge1xyXG4gICAgICAgIGNvbG9yOiAjZmZmO1xyXG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWFwcC1wcmltYXJ5LWNvbG9yKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgYXBwLWhlYWRlciBwYXBlci1pY29uLWJ1dHRvbiB7XHJcbiAgICAgICAgLS1wYXBlci1pY29uLWJ1dHRvbi1pbmstY29sb3I6IHdoaXRlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAuZHJhd2VyLWxpc3Qge1xyXG4gICAgICAgIG1hcmdpbjogMCAyMHB4O1xyXG4gICAgICB9XHJcblxyXG4gICAgICAuZHJhd2VyLWxpc3QgYSB7XHJcbiAgICAgICAgZGlzcGxheTogYmxvY2s7XHJcbiAgICAgICAgcGFkZGluZzogMCAxNnB4O1xyXG4gICAgICAgIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcclxuICAgICAgICBjb2xvcjogdmFyKC0tYXBwLXNlY29uZGFyeS1jb2xvcik7XHJcbiAgICAgICAgbGluZS1oZWlnaHQ6IDQwcHg7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC5kcmF3ZXItbGlzdCBhLmlyb24tc2VsZWN0ZWQge1xyXG4gICAgICAgIGNvbG9yOiBibGFjaztcclxuICAgICAgICBmb250LXdlaWdodDogYm9sZDtcclxuICAgICAgfVxyXG4gICAgPC9zdHlsZT5cclxuXHJcbiAgICA8YXBwLWxvY2F0aW9uIHJvdXRlPVwie3tyb3V0ZX19XCIgdXJsLXNwYWNlLXJlZ2V4PVwiXltbcm9vdFBhdGhdXVwiPjwvYXBwLWxvY2F0aW9uPlxyXG4gICAgPGFwcC1yb3V0ZSByb3V0ZT1cInt7cm91dGV9fVwiIHBhdHRlcm49XCJbW3Jvb3RQYXRoXV06cGFnZVwiIGRhdGE9XCJ7e3JvdXRlRGF0YX19XCIgdGFpbD1cInt7c3Vicm91dGV9fVwiPjwvYXBwLXJvdXRlPlxyXG5cclxuICAgIDxhcHAtZHJhd2VyLWxheW91dCBmdWxsYmxlZWQ+XHJcbiAgICAgIDwhLS0gRHJhd2VyIGNvbnRlbnQgLS0+XHJcbiAgICAgIDxhcHAtZHJhd2VyIGlkPVwiZHJhd2VyXCIgc2xvdD1cImRyYXdlclwiPlxyXG4gICAgICAgIDxhcHAtdG9vbGJhcj5MdWRpbmcub3JnPC9hcHAtdG9vbGJhcj5cclxuICAgICAgICA8aXJvbi1zZWxlY3RvciBzZWxlY3RlZD1cIltbcGFnZV1dXCIgYXR0ci1mb3Itc2VsZWN0ZWQ9XCJuYW1lXCIgY2xhc3M9XCJkcmF3ZXItbGlzdFwiIHJvbGU9XCJuYXZpZ2F0aW9uXCI+XHJcbiAgICAgICAgICA8YSBuYW1lPVwidmlldzJcIiBocmVmJD1cIltbcm9vdFBhdGhdXXZpZXcyXCI+TmV3czwvYT5cclxuICAgICAgICAgIDxhIG5hbWU9XCJnYW1lc1wiIGhyZWYkPVwiW1tyb290UGF0aF1dZ2FtZXNcIj5TcGllbGU8L2E+XHJcbiAgICAgICAgICA8YSBuYW1lPVwiYXV0aG9yc1wiIGhyZWYkPVwiW1tyb290UGF0aF1dYXV0aG9yc1wiPkF1dG9yZW48L2E+XHJcbiAgICAgICAgICA8YSBuYW1lPVwicHVibGlzaGVyc1wiIGhyZWYkPVwiW1tyb290UGF0aF1dcHVibGlzaGVyc1wiPlZlcmxhZ2U8L2E+XHJcbiAgICAgICAgICA8YSBuYW1lPVwiZGVzaWduZXJzXCIgaHJlZiQ9XCJbW3Jvb3RQYXRoXV1kZXNpZ25lcnNcIj5EZXNpZ25lcjwvYT5cclxuICAgICAgICAgIDxhIG5hbWU9XCJyZXZpZXdzXCIgaHJlZiQ9XCJbW3Jvb3RQYXRoXV1yZXZpZXdzXCI+UmV6ZW5zZW5pb25lbjwvYT5cclxuICAgICAgICAgIDxhIG5hbWU9XCJ2aWV3M1wiIGhyZWYkPVwiW1tyb290UGF0aF1ddmlldzNcIj5QcmVpc2U8L2E+XHJcbiAgICAgICAgICA8aHI+XHJcbiAgICAgICAgICA8YSBuYW1lPVwidmlldzNcIiBocmVmJD1cIltbcm9vdFBhdGhdXXZpZXczXCI+U2FtbWx1bmc8L2E+XHJcbiAgICAgICAgICA8YSBuYW1lPVwidmlldzNcIiBocmVmJD1cIltbcm9vdFBhdGhdXXZpZXczXCI+U2V0dGluZ3M8L2E+XHJcbiAgICAgICAgPC9pcm9uLXNlbGVjdG9yPlxyXG4gICAgICA8L2FwcC1kcmF3ZXI+XHJcblxyXG4gICAgICA8IS0tIE1haW4gY29udGVudCAtLT5cclxuICAgICAgPGFwcC1oZWFkZXItbGF5b3V0IGhhcy1zY3JvbGxpbmctcmVnaW9uPlxyXG5cclxuICAgICAgICA8YXBwLWhlYWRlciBzbG90PVwiaGVhZGVyXCIgY29uZGVuc2VzIHJldmVhbHMgZWZmZWN0cz1cIndhdGVyZmFsbFwiPlxyXG4gICAgICAgICAgPGFwcC10b29sYmFyPlxyXG4gICAgICAgICAgICA8cGFwZXItaWNvbi1idXR0b24gaWNvbj1cIm15LWljb25zOm1lbnVcIiBkcmF3ZXItdG9nZ2xlPjwvcGFwZXItaWNvbi1idXR0b24+XHJcbiAgICAgICAgICAgIDxkaXYgbWFpbi10aXRsZT57e3BhZ2V0aXRsZX19PC9kaXY+XHJcbiAgICAgICAgICA8L2FwcC10b29sYmFyPlxyXG4gICAgICAgIDwvYXBwLWhlYWRlcj5cclxuXHJcbiAgICAgICAgPGlyb24tcGFnZXMgc2VsZWN0ZWQ9XCJbW3BhZ2VdXVwiIGF0dHItZm9yLXNlbGVjdGVkPVwibmFtZVwiIGZhbGxiYWNrLXNlbGVjdGlvbj1cInZpZXc0MDRcIiByb2xlPVwibWFpblwiPlxyXG4gICAgICAgICAgPGdhbWVzLWxpc3QgbmFtZT1cImdhbWVzXCI+PC9nYW1lcy1saXN0PlxyXG4gICAgICAgICAgPG15LXZpZXcyIG5hbWU9XCJ2aWV3MlwiPjwvbXktdmlldzI+XHJcbiAgICAgICAgICA8YXV0aG9ycy1saXN0IG5hbWU9XCJhdXRob3JzXCI+PC9hdXRob3JzLWxpc3Q+XHJcbiAgICAgICAgICA8cHVibGlzaGVycy1saXN0IG5hbWU9XCJwdWJsaXNoZXJzXCI+PC9wdWJsaXNoZXJzLWxpc3Q+XHJcbiAgICAgICAgICA8bXktdmlldzMgbmFtZT1cInZpZXczXCI+PC9teS12aWV3Mz5cclxuICAgICAgICAgIDxteS12aWV3NDA0IG5hbWU9XCJ2aWV3NDA0XCI+PC9teS12aWV3NDA0PlxyXG4gICAgICAgIDwvaXJvbi1wYWdlcz5cclxuICAgICAgPC9hcHAtaGVhZGVyLWxheW91dD5cclxuICAgIDwvYXBwLWRyYXdlci1sYXlvdXQ+XHJcbiAgPC90ZW1wbGF0ZT5cclxuXHJcbiAgPHNjcmlwdD5cclxuICAgIGNsYXNzIE15QXBwIGV4dGVuZHMgUG9seW1lci5FbGVtZW50IHtcclxuXHJcbiAgICAgIHN0YXRpYyBnZXQgaXMoKSB7IHJldHVybiAnbHVkaW5nLWFwcCc7IH1cclxuXHJcbiAgICAgIHN0YXRpYyBnZXQgcHJvcGVydGllcygpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgcGFnZToge1xyXG4gICAgICAgICAgICB0eXBlOiBTdHJpbmcsXHJcbiAgICAgICAgICAgIHJlZmxlY3RUb0F0dHJpYnV0ZTogdHJ1ZSxcclxuICAgICAgICAgICAgb2JzZXJ2ZXI6ICdfcGFnZUNoYW5nZWQnLFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIHBhZ2V0aXRsZTogeyBcclxuICAgICAgICAgICAgdHlwZTogU3RyaW5nLCBcclxuICAgICAgICAgICAgdmFsdWU6ICdkaWUgQnJldHRzcGllbGRhdGVuYmFuaydcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICByb3V0ZURhdGE6IE9iamVjdCxcclxuICAgICAgICAgIHN1YnJvdXRlOiBTdHJpbmcsXHJcbiAgICAgICAgICByb290UGF0aDoge1xyXG4gICAgICAgICAgICB0eXBlOiBTdHJpbmcsXHJcbiAgICAgICAgICAgIHZhbHVlOiAnLydcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBsYXp5UGFnZXM6IHtcclxuICAgICAgICAgICAgdHlwZTogT2JqZWN0LFxyXG4gICAgICAgICAgICB2YWx1ZToge1xyXG4gICAgICAgICAgICAgIHZpZXcyOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBpbXBvcnQoLyogd2VicGFja0NodW5rTmFtZTogXCJteS12aWV3MlwiICovICcuL215LXZpZXcyLmh0bWwnKTtcclxuICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgIGdhbWVzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBpbXBvcnQoLyogd2VicGFja0NodW5rTmFtZTogXCJnYW1lcy1saXN0XCIgKi8gJy4vZ2FtZXMtbGlzdC5odG1sJyk7XHJcbiAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICBhdXRob3JzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBpbXBvcnQoLyogd2VicGFja0NodW5rTmFtZTogXCJhdXRob3JzLWxpc3RcIiAqLyAnLi9hdXRob3JzLWxpc3QuaHRtbCcpO1xyXG4gICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgcHVibGlzaGVyczogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgaW1wb3J0KC8qIHdlYnBhY2tDaHVua05hbWU6IFwicHVibGlzaGVycy1saXN0XCIgKi8gJy4vcHVibGlzaGVycy1saXN0Lmh0bWwnKTtcclxuICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgIHZpZXczOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBpbXBvcnQoLyogd2VicGFja0NodW5rTmFtZTogXCJteS12aWV3M1wiICovICcuL215LXZpZXczLmh0bWwnKTtcclxuICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgIHZpZXc0MDQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGltcG9ydCgvKiB3ZWJwYWNrQ2h1bmtOYW1lOiBcIm15LXZpZXc0MDRcIiAqLyAnLi9teS12aWV3NDA0Lmh0bWwnKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICB9XHJcblxyXG4gICAgICBzdGF0aWMgZ2V0IG9ic2VydmVycygpIHtcclxuICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgJ19yb3V0ZVBhZ2VDaGFuZ2VkKHJvdXRlRGF0YS5wYWdlKScsXHJcbiAgICAgICAgXTtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgX3JvdXRlUGFnZUNoYW5nZWQocGFnZSkge1xyXG4gICAgICAgIC8vIFBvbHltZXIgMi4wIHdpbGwgY2FsbCB3aXRoIGB1bmRlZmluZWRgIG9uIGluaXRpYWxpemF0aW9uLlxyXG4gICAgICAgIC8vIElnbm9yZSB1bnRpbCB3ZSBhcmUgcHJvcGVybHkgY2FsbGVkIHdpdGggYSBzdHJpbmcuXHJcbiAgICAgICAgaWYgKHBhZ2UgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gSWYgbm8gcGFnZSB3YXMgZm91bmQgaW4gdGhlIHJvdXRlIGRhdGEsIHBhZ2Ugd2lsbCBiZSBhbiBlbXB0eSBzdHJpbmcuXHJcbiAgICAgICAgLy8gRGVhdWx0IHRvICd2aWV3MScgaW4gdGhhdCBjYXNlLlxyXG4gICAgICAgIHRoaXMucGFnZSA9IHBhZ2UgfHwgJ3ZpZXcxJztcclxuXHJcbiAgICAgICAgLy8gQ2xvc2UgYSBub24tcGVyc2lzdGVudCBkcmF3ZXIgd2hlbiB0aGUgcGFnZSAmIHJvdXRlIGFyZSBjaGFuZ2VkLlxyXG4gICAgICAgIGlmICghdGhpcy4kLmRyYXdlci5wZXJzaXN0ZW50KSB7XHJcbiAgICAgICAgICB0aGlzLiQuZHJhd2VyLmNsb3NlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBfcGFnZUNoYW5nZWQocGFnZSkge1xyXG4gICAgICAgIGlmICh0aGlzLmxhenlQYWdlc1twYWdlXSkge1xyXG4gICAgICAgICAgdGhpcy5sYXp5UGFnZXNbcGFnZV0oKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdGhpcy5fc2hvd1BhZ2U0MDQoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIF9zaG93UGFnZTQwNCgpIHtcclxuICAgICAgICB0aGlzLnBhZ2UgPSAndmlldzQwNCc7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB3aW5kb3cuY3VzdG9tRWxlbWVudHMuZGVmaW5lKE15QXBwLmlzLCBNeUFwcCk7XHJcbiAgPC9zY3JpcHQ+XHJcbjwvZG9tLW1vZHVsZT5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvbHVkaW5nLWFwcC5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3V0aWxzL2Jvb3QuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3V0aWxzL3Jlc29sdmUtdXJsLmh0bWxcIj5cbjxzY3JpcHQ+XG4oZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBsZXQgbW9kdWxlcyA9IHt9O1xuICBsZXQgbGNNb2R1bGVzID0ge307XG4gIGZ1bmN0aW9uIGZpbmRNb2R1bGUoaWQpIHtcbiAgICByZXR1cm4gbW9kdWxlc1tpZF0gfHwgbGNNb2R1bGVzW2lkLnRvTG93ZXJDYXNlKCldO1xuICB9XG5cbiAgZnVuY3Rpb24gc3R5bGVPdXRzaWRlVGVtcGxhdGVDaGVjayhpbnN0KSB7XG4gICAgaWYgKGluc3QucXVlcnlTZWxlY3Rvcignc3R5bGUnKSkge1xuICAgICAgY29uc29sZS53YXJuKCdkb20tbW9kdWxlICVzIGhhcyBzdHlsZSBvdXRzaWRlIHRlbXBsYXRlJywgaW5zdC5pZCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBgZG9tLW1vZHVsZWAgZWxlbWVudCByZWdpc3RlcnMgdGhlIGRvbSBpdCBjb250YWlucyB0byB0aGUgbmFtZSBnaXZlblxuICAgKiBieSB0aGUgbW9kdWxlJ3MgaWQgYXR0cmlidXRlLiBJdCBwcm92aWRlcyBhIHVuaWZpZWQgZGF0YWJhc2Ugb2YgZG9tXG4gICAqIGFjY2Vzc2libGUgdmlhIGl0cyBzdGF0aWMgYGltcG9ydGAgQVBJLlxuICAgKlxuICAgKiBBIGtleSB1c2UgY2FzZSBvZiBgZG9tLW1vZHVsZWAgaXMgZm9yIHByb3ZpZGluZyBjdXN0b20gZWxlbWVudCBgPHRlbXBsYXRlPmBzXG4gICAqIHZpYSBIVE1MIGltcG9ydHMgdGhhdCBhcmUgcGFyc2VkIGJ5IHRoZSBuYXRpdmUgSFRNTCBwYXJzZXIsIHRoYXQgY2FuIGJlXG4gICAqIHJlbG9jYXRlZCBkdXJpbmcgYSBidW5kbGluZyBwYXNzIGFuZCBzdGlsbCBsb29rZWQgdXAgYnkgYGlkYC5cbiAgICpcbiAgICogRXhhbXBsZTpcbiAgICpcbiAgICogICAgIDxkb20tbW9kdWxlIGlkPVwiZm9vXCI+XG4gICAqICAgICAgIDxpbWcgc3JjPVwic3R1ZmYucG5nXCI+XG4gICAqICAgICA8L2RvbS1tb2R1bGU+XG4gICAqXG4gICAqIFRoZW4gaW4gY29kZSBpbiBzb21lIG90aGVyIGxvY2F0aW9uIHRoYXQgY2Fubm90IGFjY2VzcyB0aGUgZG9tLW1vZHVsZSBhYm92ZVxuICAgKlxuICAgKiAgICAgbGV0IGltZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RvbS1tb2R1bGUnKS5pbXBvcnQoJ2ZvbycsICdpbWcnKTtcbiAgICpcbiAgICogQGN1c3RvbUVsZW1lbnRcbiAgICogQGV4dGVuZHMgSFRNTEVsZW1lbnRcbiAgICogQG1lbWJlcm9mIFBvbHltZXJcbiAgICogQHN1bW1hcnkgQ3VzdG9tIGVsZW1lbnQgdGhhdCBwcm92aWRlcyBhIHJlZ2lzdHJ5IG9mIHJlbG9jYXRhYmxlIERPTSBjb250ZW50XG4gICAqICAgYnkgYGlkYCB0aGF0IGlzIGFnbm9zdGljIHRvIGJ1bmRsaW5nLlxuICAgKiBAdW5yZXN0cmljdGVkXG4gICAqL1xuICBjbGFzcyBEb21Nb2R1bGUgZXh0ZW5kcyBIVE1MRWxlbWVudCB7XG5cbiAgICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHsgcmV0dXJuIFsnaWQnXSB9XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIGVsZW1lbnQgc3BlY2lmaWVkIGJ5IHRoZSBjc3MgYHNlbGVjdG9yYCBpbiB0aGUgbW9kdWxlXG4gICAgICogcmVnaXN0ZXJlZCBieSBgaWRgLiBGb3IgZXhhbXBsZSwgdGhpcy5pbXBvcnQoJ2ZvbycsICdpbWcnKTtcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgVGhlIGlkIG9mIHRoZSBkb20tbW9kdWxlIGluIHdoaWNoIHRvIHNlYXJjaC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZz19IHNlbGVjdG9yIFRoZSBjc3Mgc2VsZWN0b3IgYnkgd2hpY2ggdG8gZmluZCB0aGUgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJuIHtFbGVtZW50fSBSZXR1cm5zIHRoZSBlbGVtZW50IHdoaWNoIG1hdGNoZXMgYHNlbGVjdG9yYCBpbiB0aGVcbiAgICAgKiBtb2R1bGUgcmVnaXN0ZXJlZCBhdCB0aGUgc3BlY2lmaWVkIGBpZGAuXG4gICAgICovXG4gICAgc3RhdGljIGltcG9ydChpZCwgc2VsZWN0b3IpIHtcbiAgICAgIGlmIChpZCkge1xuICAgICAgICBsZXQgbSA9IGZpbmRNb2R1bGUoaWQpO1xuICAgICAgICBpZiAobSAmJiBzZWxlY3Rvcikge1xuICAgICAgICAgIHJldHVybiBtLnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIG9sZCwgdmFsdWUpIHtcbiAgICAgIGlmIChvbGQgIT09IHZhbHVlKSB7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYWJzb2x1dGUgVVJMIG9mIHRoZSBvcmlnaW5hbCBsb2NhdGlvbiBvZiB0aGlzIGBkb20tbW9kdWxlYC5cbiAgICAgKlxuICAgICAqIFRoaXMgdmFsdWUgd2lsbCBkaWZmZXIgZnJvbSB0aGlzIGVsZW1lbnQncyBgb3duZXJEb2N1bWVudGAgaW4gdGhlXG4gICAgICogZm9sbG93aW5nIHdheXM6XG4gICAgICogLSBUYWtlcyBpbnRvIGFjY291bnQgYW55IGBhc3NldHBhdGhgIGF0dHJpYnV0ZSBhZGRlZCBkdXJpbmcgYnVuZGxpbmdcbiAgICAgKiAgIHRvIGluZGljYXRlIHRoZSBvcmlnaW5hbCBsb2NhdGlvbiByZWxhdGl2ZSB0byB0aGUgYnVuZGxlZCBsb2NhdGlvblxuICAgICAqIC0gVXNlcyB0aGUgSFRNTEltcG9ydHMgcG9seWZpbGwncyBgaW1wb3J0Rm9yRWxlbWVudGAgQVBJIHRvIGVuc3VyZVxuICAgICAqICAgdGhlIHBhdGggaXMgcmVsYXRpdmUgdG8gdGhlIGltcG9ydCBkb2N1bWVudCdzIGxvY2F0aW9uIHNpbmNlXG4gICAgICogICBgb3duZXJEb2N1bWVudGAgaXMgbm90IGN1cnJlbnRseSBwb2x5ZmlsbGVkXG4gICAgICovXG4gICAgZ2V0IGFzc2V0cGF0aCgpIHtcbiAgICAgIC8vIERvbid0IG92ZXJyaWRlIGV4aXN0aW5nIGFzc2V0cGF0aC5cbiAgICAgIGlmICghdGhpcy5fX2Fzc2V0cGF0aCkge1xuICAgICAgICAvLyBub3RlOiBhc3NldHBhdGggc2V0IHZpYSBhbiBhdHRyaWJ1dGUgbXVzdCBiZSByZWxhdGl2ZSB0byB0aGlzXG4gICAgICAgIC8vIGVsZW1lbnQncyBsb2NhdGlvbjsgYWNjb21vZGF0ZSBwb2x5ZmlsbGVkIEhUTUxJbXBvcnRzXG4gICAgICAgIGNvbnN0IG93bmVyID0gd2luZG93LkhUTUxJbXBvcnRzICYmIEhUTUxJbXBvcnRzLmltcG9ydEZvckVsZW1lbnQgP1xuICAgICAgICAgIEhUTUxJbXBvcnRzLmltcG9ydEZvckVsZW1lbnQodGhpcykgfHwgZG9jdW1lbnQgOiB0aGlzLm93bmVyRG9jdW1lbnQ7XG4gICAgICAgIGNvbnN0IHVybCA9IFBvbHltZXIuUmVzb2x2ZVVybC5yZXNvbHZlVXJsKFxuICAgICAgICAgIHRoaXMuZ2V0QXR0cmlidXRlKCdhc3NldHBhdGgnKSB8fCAnJywgb3duZXIuYmFzZVVSSSk7XG4gICAgICAgIHRoaXMuX19hc3NldHBhdGggPSBQb2x5bWVyLlJlc29sdmVVcmwucGF0aEZyb21VcmwodXJsKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9fYXNzZXRwYXRoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyB0aGUgZG9tLW1vZHVsZSBhdCBhIGdpdmVuIGlkLiBUaGlzIG1ldGhvZCBzaG91bGQgb25seSBiZSBjYWxsZWRcbiAgICAgKiB3aGVuIGEgZG9tLW1vZHVsZSBpcyBpbXBlcmF0aXZlbHkgY3JlYXRlZC4gRm9yXG4gICAgICogZXhhbXBsZSwgYGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RvbS1tb2R1bGUnKS5yZWdpc3RlcignZm9vJylgLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nPX0gaWQgVGhlIGlkIGF0IHdoaWNoIHRvIHJlZ2lzdGVyIHRoZSBkb20tbW9kdWxlLlxuICAgICAqL1xuICAgIHJlZ2lzdGVyKGlkKSB7XG4gICAgICBpZCA9IGlkIHx8IHRoaXMuaWQ7XG4gICAgICBpZiAoaWQpIHtcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICAvLyBzdG9yZSBpZCBzZXBhcmF0ZSBmcm9tIGxvd2VyY2FzZWQgaWQgc28gdGhhdFxuICAgICAgICAvLyBpbiBhbGwgY2FzZXMgbWl4ZWRDYXNlIGlkIHdpbGwgc3RvcmVkIGRpc3RpbmN0bHlcbiAgICAgICAgLy8gYW5kIGxvd2VyY2FzZSB2ZXJzaW9uIGlzIGEgZmFsbGJhY2tcbiAgICAgICAgbW9kdWxlc1tpZF0gPSB0aGlzO1xuICAgICAgICBsY01vZHVsZXNbaWQudG9Mb3dlckNhc2UoKV0gPSB0aGlzO1xuICAgICAgICBzdHlsZU91dHNpZGVUZW1wbGF0ZUNoZWNrKHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIERvbU1vZHVsZS5wcm90b3R5cGVbJ21vZHVsZXMnXSA9IG1vZHVsZXM7XG5cbiAgY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdkb20tbW9kdWxlJywgRG9tTW9kdWxlKTtcblxuICAvLyBleHBvcnRcbiAgUG9seW1lci5Eb21Nb2R1bGUgPSBEb21Nb2R1bGU7XG5cbn0pKCk7XG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvZWxlbWVudHMvZG9tLW1vZHVsZS5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuXG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiYm9vdC5odG1sXCI+XG5cbjxzY3JpcHQ+XG4oZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvKipcbiAgICogTW9kdWxlIHdpdGggdXRpbGl0aWVzIGZvciBtYW5pcHVsYXRpbmcgc3RydWN0dXJlZCBkYXRhIHBhdGggc3RyaW5ncy5cbiAgICpcbiAgICogQG5hbWVzcGFjZVxuICAgKiBAbWVtYmVyb2YgUG9seW1lclxuICAgKiBAc3VtbWFyeSBNb2R1bGUgd2l0aCB1dGlsaXRpZXMgZm9yIG1hbmlwdWxhdGluZyBzdHJ1Y3R1cmVkIGRhdGEgcGF0aCBzdHJpbmdzLlxuICAgKi9cbiAgY29uc3QgUGF0aCA9IHtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gc3RyaW5nIGlzIGEgc3RydWN0dXJlZCBkYXRhIHBhdGggKGhhcyBkb3RzKS5cbiAgICAgKlxuICAgICAqIEV4YW1wbGU6XG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiBQb2x5bWVyLlBhdGguaXNQYXRoKCdmb28uYmFyLmJheicpIC8vIHRydWVcbiAgICAgKiBQb2x5bWVyLlBhdGguaXNQYXRoKCdmb28nKSAgICAgICAgIC8vIGZhbHNlXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgUG9seW1lci5QYXRoXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggUGF0aCBzdHJpbmdcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBzdHJpbmcgY29udGFpbmVkIG9uZSBvciBtb3JlIGRvdHNcbiAgICAgKi9cbiAgICBpc1BhdGg6IGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgIHJldHVybiBwYXRoLmluZGV4T2YoJy4nKSA+PSAwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSByb290IHByb3BlcnR5IG5hbWUgZm9yIHRoZSBnaXZlbiBwYXRoLlxuICAgICAqXG4gICAgICogRXhhbXBsZTpcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIFBvbHltZXIuUGF0aC5yb290KCdmb28uYmFyLmJheicpIC8vICdmb28nXG4gICAgICogUG9seW1lci5QYXRoLnJvb3QoJ2ZvbycpICAgICAgICAgLy8gJ2ZvbydcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBQb2x5bWVyLlBhdGhcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBQYXRoIHN0cmluZ1xuICAgICAqIEByZXR1cm4ge3N0cmluZ30gUm9vdCBwcm9wZXJ0eSBuYW1lXG4gICAgICovXG4gICAgcm9vdDogZnVuY3Rpb24ocGF0aCkge1xuICAgICAgbGV0IGRvdEluZGV4ID0gcGF0aC5pbmRleE9mKCcuJyk7XG4gICAgICBpZiAoZG90SW5kZXggPT09IC0xKSB7XG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhdGguc2xpY2UoMCwgZG90SW5kZXgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHaXZlbiBgYmFzZWAgaXMgYGZvby5iYXJgLCBgZm9vYCBpcyBhbiBhbmNlc3RvciwgYGZvby5iYXJgIGlzIG5vdFxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gcGF0aCBpcyBhbiBhbmNlc3RvciBvZiB0aGUgYmFzZSBwYXRoLlxuICAgICAqXG4gICAgICogRXhhbXBsZTpcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIFBvbHltZXIuUGF0aC5pc0FuY2VzdG9yKCdmb28uYmFyJywgJ2ZvbycpICAgICAgICAgLy8gdHJ1ZVxuICAgICAqIFBvbHltZXIuUGF0aC5pc0FuY2VzdG9yKCdmb28uYmFyJywgJ2Zvby5iYXInKSAgICAgLy8gZmFsc2VcbiAgICAgKiBQb2x5bWVyLlBhdGguaXNBbmNlc3RvcignZm9vLmJhcicsICdmb28uYmFyLmJheicpIC8vIGZhbHNlXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgUG9seW1lci5QYXRoXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGJhc2UgUGF0aCBzdHJpbmcgdG8gdGVzdCBhZ2FpbnN0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFBhdGggc3RyaW5nIHRvIHRlc3QuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBgcGF0aGAgaXMgYW4gYW5jZXN0b3Igb2YgYGJhc2VgLlxuICAgICAqL1xuICAgIGlzQW5jZXN0b3I6IGZ1bmN0aW9uKGJhc2UsIHBhdGgpIHtcbiAgICAgIC8vICAgICBiYXNlLnN0YXJ0c1dpdGgocGF0aCArICcuJyk7XG4gICAgICByZXR1cm4gYmFzZS5pbmRleE9mKHBhdGggKyAnLicpID09PSAwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHaXZlbiBgYmFzZWAgaXMgYGZvby5iYXJgLCBgZm9vLmJhci5iYXpgIGlzIGFuIGRlc2NlbmRhbnRcbiAgICAgKlxuICAgICAqIEV4YW1wbGU6XG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiBQb2x5bWVyLlBhdGguaXNEZXNjZW5kYW50KCdmb28uYmFyJywgJ2Zvby5iYXIuYmF6JykgLy8gdHJ1ZVxuICAgICAqIFBvbHltZXIuUGF0aC5pc0Rlc2NlbmRhbnQoJ2Zvby5iYXInLCAnZm9vLmJhcicpICAgICAvLyBmYWxzZVxuICAgICAqIFBvbHltZXIuUGF0aC5pc0Rlc2NlbmRhbnQoJ2Zvby5iYXInLCAnZm9vJykgICAgICAgICAvLyBmYWxzZVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIFBvbHltZXIuUGF0aFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlIFBhdGggc3RyaW5nIHRvIHRlc3QgYWdhaW5zdC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBQYXRoIHN0cmluZyB0byB0ZXN0LlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYHBhdGhgIGlzIGEgZGVzY2VuZGFudCBvZiBgYmFzZWAuXG4gICAgICovXG4gICAgaXNEZXNjZW5kYW50OiBmdW5jdGlvbihiYXNlLCBwYXRoKSB7XG4gICAgICAvLyAgICAgcGF0aC5zdGFydHNXaXRoKGJhc2UgKyAnLicpO1xuICAgICAgcmV0dXJuIHBhdGguaW5kZXhPZihiYXNlICsgJy4nKSA9PT0gMDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVwbGFjZXMgYSBwcmV2aW91cyBiYXNlIHBhdGggd2l0aCBhIG5ldyBiYXNlIHBhdGgsIHByZXNlcnZpbmcgdGhlXG4gICAgICogcmVtYWluZGVyIG9mIHRoZSBwYXRoLlxuICAgICAqXG4gICAgICogVXNlciBtdXN0IGVuc3VyZSBgcGF0aGAgaGFzIGEgcHJlZml4IG9mIGBiYXNlYC5cbiAgICAgKlxuICAgICAqIEV4YW1wbGU6XG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiBQb2x5bWVyLlBhdGgudHJhbnNsYXRlKCdmb28uYmFyJywgJ3pvdCcgJ2Zvby5iYXIuYmF6JykgLy8gJ3pvdC5iYXonXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgUG9seW1lci5QYXRoXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGJhc2UgQ3VycmVudCBiYXNlIHN0cmluZyB0byByZW1vdmVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV3QmFzZSBOZXcgYmFzZSBzdHJpbmcgdG8gcmVwbGFjZSB3aXRoXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggUGF0aCB0byB0cmFuc2xhdGVcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRyYW5zbGF0ZWQgc3RyaW5nXG4gICAgICovXG4gICAgdHJhbnNsYXRlOiBmdW5jdGlvbihiYXNlLCBuZXdCYXNlLCBwYXRoKSB7XG4gICAgICByZXR1cm4gbmV3QmFzZSArIHBhdGguc2xpY2UoYmFzZS5sZW5ndGgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYmFzZSBQYXRoIHN0cmluZyB0byB0ZXN0IGFnYWluc3RcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBQYXRoIHN0cmluZyB0byB0ZXN0XG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBgcGF0aGAgaXMgZXF1YWwgdG8gYGJhc2VgXG4gICAgICogQHRoaXMge1BhdGh9XG4gICAgICovXG4gICAgbWF0Y2hlczogZnVuY3Rpb24oYmFzZSwgcGF0aCkge1xuICAgICAgcmV0dXJuIChiYXNlID09PSBwYXRoKSB8fFxuICAgICAgICAgICAgIHRoaXMuaXNBbmNlc3RvcihiYXNlLCBwYXRoKSB8fFxuICAgICAgICAgICAgIHRoaXMuaXNEZXNjZW5kYW50KGJhc2UsIHBhdGgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhcnJheS1iYXNlZCBwYXRocyB0byBmbGF0dGVuZWQgcGF0aC4gIFN0cmluZy1iYXNlZCBwYXRoc1xuICAgICAqIGFyZSByZXR1cm5lZCBhcy1pcy5cbiAgICAgKlxuICAgICAqIEV4YW1wbGU6XG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiBQb2x5bWVyLlBhdGgubm9ybWFsaXplKFsnZm9vLmJhcicsIDAsICdiYXonXSkgIC8vICdmb28uYmFyLjAuYmF6J1xuICAgICAqIFBvbHltZXIuUGF0aC5ub3JtYWxpemUoJ2Zvby5iYXIuMC5iYXonKSAgICAgICAgLy8gJ2Zvby5iYXIuMC5iYXonXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgUG9seW1lci5QYXRoXG4gICAgICogQHBhcmFtIHtzdHJpbmcgfCAhQXJyYXk8c3RyaW5nfG51bWJlcj59IHBhdGggSW5wdXQgcGF0aFxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gRmxhdHRlbmVkIHBhdGhcbiAgICAgKi9cbiAgICBub3JtYWxpemU6IGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhdGgpKSB7XG4gICAgICAgIGxldCBwYXJ0cyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8cGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGxldCBhcmdzID0gcGF0aFtpXS50b1N0cmluZygpLnNwbGl0KCcuJyk7XG4gICAgICAgICAgZm9yIChsZXQgaj0wOyBqPGFyZ3MubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIHBhcnRzLnB1c2goYXJnc1tqXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJ0cy5qb2luKCcuJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcGF0aDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU3BsaXRzIGEgcGF0aCBpbnRvIGFuIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLiBBY2NlcHRzIGVpdGhlciBhcnJheXNcbiAgICAgKiBvZiBwYXRoIHBhcnRzIG9yIHN0cmluZ3MuXG4gICAgICpcbiAgICAgKiBFeGFtcGxlOlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogUG9seW1lci5QYXRoLnNwbGl0KFsnZm9vLmJhcicsIDAsICdiYXonXSkgIC8vIFsnZm9vJywgJ2JhcicsICcwJywgJ2JheiddXG4gICAgICogUG9seW1lci5QYXRoLnNwbGl0KCdmb28uYmFyLjAuYmF6JykgICAgICAgIC8vIFsnZm9vJywgJ2JhcicsICcwJywgJ2JheiddXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgUG9seW1lci5QYXRoXG4gICAgICogQHBhcmFtIHtzdHJpbmcgfCAhQXJyYXk8c3RyaW5nfG51bWJlcj59IHBhdGggSW5wdXQgcGF0aFxuICAgICAqIEByZXR1cm4geyFBcnJheTxzdHJpbmc+fSBBcnJheSBvZiBwYXRoIHBhcnRzXG4gICAgICogQHRoaXMge1BhdGh9XG4gICAgICogQHN1cHByZXNzIHtjaGVja1R5cGVzfVxuICAgICAqL1xuICAgIHNwbGl0OiBmdW5jdGlvbihwYXRoKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXRoKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5ub3JtYWxpemUocGF0aCkuc3BsaXQoJy4nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXRoLnRvU3RyaW5nKCkuc3BsaXQoJy4nKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVhZHMgYSB2YWx1ZSBmcm9tIGEgcGF0aC4gIElmIGFueSBzdWItcHJvcGVydHkgaW4gdGhlIHBhdGggaXMgYHVuZGVmaW5lZGAsXG4gICAgICogdGhpcyBtZXRob2QgcmV0dXJucyBgdW5kZWZpbmVkYCAod2lsbCBuZXZlciB0aHJvdy5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBQb2x5bWVyLlBhdGhcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcm9vdCBPYmplY3QgZnJvbSB3aGljaCB0byBkZXJlZmVyZW5jZSBwYXRoIGZyb21cbiAgICAgKiBAcGFyYW0ge3N0cmluZyB8ICFBcnJheTxzdHJpbmd8bnVtYmVyPn0gcGF0aCBQYXRoIHRvIHJlYWRcbiAgICAgKiBAcGFyYW0ge09iamVjdD19IGluZm8gSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIHRvIGBpbmZvYCwgdGhlIG5vcm1hbGl6ZWRcbiAgICAgKiAgKGZsYXR0ZW5lZCkgcGF0aCB3aWxsIGJlIHNldCB0byBgaW5mby5wYXRoYC5cbiAgICAgKiBAcmV0dXJuIHsqfSBWYWx1ZSBhdCBwYXRoLCBvciBgdW5kZWZpbmVkYCBpZiB0aGUgcGF0aCBjb3VsZCBub3QgYmVcbiAgICAgKiAgZnVsbHkgZGVyZWZlcmVuY2VkLlxuICAgICAqIEB0aGlzIHtQYXRofVxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24ocm9vdCwgcGF0aCwgaW5mbykge1xuICAgICAgbGV0IHByb3AgPSByb290O1xuICAgICAgbGV0IHBhcnRzID0gdGhpcy5zcGxpdChwYXRoKTtcbiAgICAgIC8vIExvb3Agb3ZlciBwYXRoIHBhcnRzWzAuLm4tMV0gYW5kIGRlcmVmZXJlbmNlXG4gICAgICBmb3IgKGxldCBpPTA7IGk8cGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCFwcm9wKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwYXJ0ID0gcGFydHNbaV07XG4gICAgICAgIHByb3AgPSBwcm9wW3BhcnRdO1xuICAgICAgfVxuICAgICAgaWYgKGluZm8pIHtcbiAgICAgICAgaW5mby5wYXRoID0gcGFydHMuam9pbignLicpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHByb3A7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgYSB2YWx1ZSB0byBhIHBhdGguICBJZiBhbnkgc3ViLXByb3BlcnR5IGluIHRoZSBwYXRoIGlzIGB1bmRlZmluZWRgLFxuICAgICAqIHRoaXMgbWV0aG9kIHdpbGwgbm8tb3AuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgUG9seW1lci5QYXRoXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJvb3QgT2JqZWN0IGZyb20gd2hpY2ggdG8gZGVyZWZlcmVuY2UgcGF0aCBmcm9tXG4gICAgICogQHBhcmFtIHtzdHJpbmcgfCAhQXJyYXk8c3RyaW5nfG51bWJlcj59IHBhdGggUGF0aCB0byBzZXRcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIHNldCB0byBwYXRoXG4gICAgICogQHJldHVybiB7c3RyaW5nIHwgdW5kZWZpbmVkfSBUaGUgbm9ybWFsaXplZCB2ZXJzaW9uIG9mIHRoZSBpbnB1dCBwYXRoXG4gICAgICogQHRoaXMge1BhdGh9XG4gICAgICovXG4gICAgc2V0OiBmdW5jdGlvbihyb290LCBwYXRoLCB2YWx1ZSkge1xuICAgICAgbGV0IHByb3AgPSByb290O1xuICAgICAgbGV0IHBhcnRzID0gdGhpcy5zcGxpdChwYXRoKTtcbiAgICAgIGxldCBsYXN0ID0gcGFydHNbcGFydHMubGVuZ3RoLTFdO1xuICAgICAgaWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgLy8gTG9vcCBvdmVyIHBhdGggcGFydHNbMC4ubi0yXSBhbmQgZGVyZWZlcmVuY2VcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPHBhcnRzLmxlbmd0aC0xOyBpKyspIHtcbiAgICAgICAgICBsZXQgcGFydCA9IHBhcnRzW2ldO1xuICAgICAgICAgIHByb3AgPSBwcm9wW3BhcnRdO1xuICAgICAgICAgIGlmICghcHJvcCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBTZXQgdmFsdWUgdG8gb2JqZWN0IGF0IGVuZCBvZiBwYXRoXG4gICAgICAgIHByb3BbbGFzdF0gPSB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFNpbXBsZSBwcm9wZXJ0eSBzZXRcbiAgICAgICAgcHJvcFtwYXRoXSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcnRzLmpvaW4oJy4nKTtcbiAgICB9XG5cbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBzdHJpbmcgaXMgYSBzdHJ1Y3R1cmVkIGRhdGEgcGF0aCAoaGFzIGRvdHMpLlxuICAgKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGRlcHJlY2F0ZWQuICBVc2UgYFBvbHltZXIuUGF0aC5pc1BhdGhgIGluc3RlYWQuXG4gICAqXG4gICAqIEV4YW1wbGU6XG4gICAqXG4gICAqIGBgYFxuICAgKiBQb2x5bWVyLlBhdGguaXNEZWVwKCdmb28uYmFyLmJheicpIC8vIHRydWVcbiAgICogUG9seW1lci5QYXRoLmlzRGVlcCgnZm9vJykgICAgICAgICAvLyBmYWxzZVxuICAgKiBgYGBcbiAgICpcbiAgICogQGRlcHJlY2F0ZWRcbiAgICogQG1lbWJlcm9mIFBvbHltZXIuUGF0aFxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBQYXRoIHN0cmluZ1xuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBzdHJpbmcgY29udGFpbmVkIG9uZSBvciBtb3JlIGRvdHNcbiAgICovXG4gIFBhdGguaXNEZWVwID0gUGF0aC5pc1BhdGg7XG5cbiAgUG9seW1lci5QYXRoID0gUGF0aDtcblxufSkoKTtcbjwvc2NyaXB0PlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi91dGlscy9wYXRoLmh0bWwiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi91dGlscy9ib290Lmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi91dGlscy9taXhpbi5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vdXRpbHMvY2FzZS1tYXAuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3V0aWxzL2FzeW5jLmh0bWxcIj5cblxuPHNjcmlwdD5cbihmdW5jdGlvbigpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgbGV0IGNhc2VNYXAgPSBQb2x5bWVyLkNhc2VNYXA7XG5cbiAgbGV0IG1pY3JvdGFzayA9IFBvbHltZXIuQXN5bmMubWljcm9UYXNrO1xuXG4gIC8vIFNhdmUgbWFwIG9mIG5hdGl2ZSBwcm9wZXJ0aWVzOyB0aGlzIGZvcm1zIGEgYmxhY2tsaXN0IG9yIHByb3BlcnRpZXNcbiAgLy8gdGhhdCB3b24ndCBoYXZlIHRoZWlyIHZhbHVlcyBcInNhdmVkXCIgYnkgYHNhdmVBY2Nlc3NvclZhbHVlYCwgc2luY2VcbiAgLy8gcmVhZGluZyBmcm9tIGFuIEhUTUxFbGVtZW50IGFjY2Vzc29yIGZyb20gdGhlIGNvbnRleHQgb2YgYSBwcm90b3R5cGUgdGhyb3dzXG4gIGNvbnN0IG5hdGl2ZVByb3BlcnRpZXMgPSB7fTtcbiAgbGV0IHByb3RvID0gSFRNTEVsZW1lbnQucHJvdG90eXBlO1xuICB3aGlsZSAocHJvdG8pIHtcbiAgICBsZXQgcHJvcHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhwcm90byk7XG4gICAgZm9yIChsZXQgaT0wOyBpPHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBuYXRpdmVQcm9wZXJ0aWVzW3Byb3BzW2ldXSA9IHRydWU7XG4gICAgfVxuICAgIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIHRvIHNhdmUgdGhlIHZhbHVlIG9mIGEgcHJvcGVydHkgdGhhdCB3aWxsIGJlIG92ZXJyaWRkZW4gd2l0aFxuICAgKiBhbiBhY2Nlc3Nvci4gSWYgdGhlIGBtb2RlbGAgaXMgYSBwcm90b3R5cGUsIHRoZSB2YWx1ZXMgd2lsbCBiZSBzYXZlZFxuICAgKiBpbiBgX19kYXRhUHJvdG9gLCBhbmQgaXQncyB1cCB0byB0aGUgdXNlciAob3IgZG93bnN0cmVhbSBtaXhpbikgdG9cbiAgICogZGVjaWRlIGhvdy93aGVuIHRvIHNldCB0aGVzZSB2YWx1ZXMgYmFjayBpbnRvIHRoZSBhY2Nlc3NvcnMuXG4gICAqIElmIGBtb2RlbGAgaXMgYWxyZWFkeSBhbiBpbnN0YW5jZSAoaXQgaGFzIGEgYF9fZGF0YWAgcHJvcGVydHkpLCB0aGVuXG4gICAqIHRoZSB2YWx1ZSB3aWxsIGJlIHNldCBhcyBhIHBlbmRpbmcgcHJvcGVydHksIG1lYW5pbmcgdGhlIHVzZXIgc2hvdWxkXG4gICAqIGNhbGwgYF9pbnZhbGlkYXRlUHJvcGVydGllc2Agb3IgYF9mbHVzaFByb3BlcnRpZXNgIHRvIHRha2UgZWZmZWN0XG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBtb2RlbCBQcm90b3R5cGUgb3IgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IE5hbWUgb2YgcHJvcGVydHlcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIHNhdmVBY2Nlc3NvclZhbHVlKG1vZGVsLCBwcm9wZXJ0eSkge1xuICAgIC8vIERvbid0IHJlYWQvc3RvcmUgdmFsdWUgZm9yIGFueSBuYXRpdmUgcHJvcGVydGllcyBzaW5jZSB0aGV5IGNvdWxkIHRocm93XG4gICAgaWYgKCFuYXRpdmVQcm9wZXJ0aWVzW3Byb3BlcnR5XSkge1xuICAgICAgbGV0IHZhbHVlID0gbW9kZWxbcHJvcGVydHldO1xuICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKG1vZGVsLl9fZGF0YSkge1xuICAgICAgICAgIC8vIEFkZGluZyBhY2Nlc3NvciB0byBpbnN0YW5jZTsgdXBkYXRlIHRoZSBwcm9wZXJ0eVxuICAgICAgICAgIC8vIEl0IGlzIHRoZSB1c2VyJ3MgcmVzcG9uc2liaWxpdHkgdG8gY2FsbCBfZmx1c2hQcm9wZXJ0aWVzXG4gICAgICAgICAgbW9kZWwuX3NldFBlbmRpbmdQcm9wZXJ0eShwcm9wZXJ0eSwgdmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEFkZGluZyBhY2Nlc3NvciB0byBwcm90bzsgc2F2ZSBwcm90bydzIHZhbHVlIGZvciBpbnN0YW5jZS10aW1lIHVzZVxuICAgICAgICAgIGlmICghbW9kZWwuX19kYXRhUHJvdG8pIHtcbiAgICAgICAgICAgIG1vZGVsLl9fZGF0YVByb3RvID0ge307XG4gICAgICAgICAgfSBlbHNlIGlmICghbW9kZWwuaGFzT3duUHJvcGVydHkoSlNDb21waWxlcl9yZW5hbWVQcm9wZXJ0eSgnX19kYXRhUHJvdG8nLCBtb2RlbCkpKSB7XG4gICAgICAgICAgICBtb2RlbC5fX2RhdGFQcm90byA9IE9iamVjdC5jcmVhdGUobW9kZWwuX19kYXRhUHJvdG8pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtb2RlbC5fX2RhdGFQcm90b1twcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBFbGVtZW50IGNsYXNzIG1peGluIHRoYXQgcHJvdmlkZXMgYmFzaWMgbWV0YS1wcm9ncmFtbWluZyBmb3IgY3JlYXRpbmcgb25lXG4gICAqIG9yIG1vcmUgcHJvcGVydHkgYWNjZXNzb3JzIChnZXR0ZXIvc2V0dGVyIHBhaXIpIHRoYXQgZW5xdWV1ZSBhbiBhc3luY1xuICAgKiAoYmF0Y2hlZCkgYF9wcm9wZXJ0aWVzQ2hhbmdlZGAgY2FsbGJhY2suXG4gICAqXG4gICAqIEZvciBiYXNpYyB1c2FnZSBvZiB0aGlzIG1peGluLCBzaW1wbHkgZGVjbGFyZSBhdHRyaWJ1dGVzIHRvIG9ic2VydmUgdmlhXG4gICAqIHRoZSBzdGFuZGFyZCBgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKWAsIGltcGxlbWVudCBgX3Byb3BlcnRpZXNDaGFuZ2VkYFxuICAgKiBvbiB0aGUgY2xhc3MsIGFuZCB0aGVuIGNhbGwgYE15Q2xhc3MuY3JlYXRlUHJvcGVydGllc0ZvckF0dHJpYnV0ZXMoKWAgb25jZVxuICAgKiBvbiB0aGUgY2xhc3MgdG8gZ2VuZXJhdGUgcHJvcGVydHkgYWNjZXNzb3JzIGZvciBlYWNoIG9ic2VydmVkIGF0dHJpYnV0ZVxuICAgKiBwcmlvciB0byBpbnN0YW5jaW5nLiAgTGFzdCwgY2FsbCBgdGhpcy5fZmx1c2hQcm9wZXJ0aWVzKClgIG9uY2UgdG8gZW5hYmxlXG4gICAqIHRoZSBhY2Nlc3NvcnMuXG4gICAqXG4gICAqIEFueSBgb2JzZXJ2ZWRBdHRyaWJ1dGVzYCB3aWxsIGF1dG9tYXRpY2FsbHkgYmVcbiAgICogZGVzZXJpYWxpemVkIHZpYSBgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrYCBhbmQgc2V0IHRvIHRoZSBhc3NvY2lhdGVkXG4gICAqIHByb3BlcnR5IHVzaW5nIGBkYXNoLWNhc2VgLXRvLWBjYW1lbENhc2VgIGNvbnZlbnRpb24uXG4gICAqXG4gICAqIEBtaXhpbkZ1bmN0aW9uXG4gICAqIEBwb2x5bWVyXG4gICAqIEBtZW1iZXJvZiBQb2x5bWVyXG4gICAqIEBzdW1tYXJ5IEVsZW1lbnQgY2xhc3MgbWl4aW4gZm9yIHJlYWN0aW5nIHRvIHByb3BlcnR5IGNoYW5nZXMgZnJvbVxuICAgKiAgIGdlbmVyYXRlZCBwcm9wZXJ0eSBhY2Nlc3NvcnMuXG4gICAqL1xuICBQb2x5bWVyLlByb3BlcnR5QWNjZXNzb3JzID0gUG9seW1lci5kZWR1cGluZ01peGluKHN1cGVyQ2xhc3MgPT4ge1xuXG4gICAgLyoqXG4gICAgICogQHBvbHltZXJcbiAgICAgKiBAbWl4aW5DbGFzc1xuICAgICAqIEBpbXBsZW1lbnRzIHtQb2x5bWVyX1Byb3BlcnR5QWNjZXNzb3JzfVxuICAgICAqIEBleHRlbmRzIEhUTUxFbGVtZW50XG4gICAgICogQHVucmVzdHJpY3RlZFxuICAgICAqL1xuICAgIGNsYXNzIFByb3BlcnR5QWNjZXNzb3JzIGV4dGVuZHMgc3VwZXJDbGFzcyB7XG5cbiAgICAgIC8qKlxuICAgICAgICogR2VuZXJhdGVzIHByb3BlcnR5IGFjY2Vzc29ycyBmb3IgYWxsIGF0dHJpYnV0ZXMgaW4gdGhlIHN0YW5kYXJkXG4gICAgICAgKiBzdGF0aWMgYG9ic2VydmVkQXR0cmlidXRlc2AgYXJyYXkuXG4gICAgICAgKlxuICAgICAgICogQXR0cmlidXRlIG5hbWVzIGFyZSBtYXBwZWQgdG8gcHJvcGVydHkgbmFtZXMgdXNpbmcgdGhlIGBkYXNoLWNhc2VgIHRvXG4gICAgICAgKiBgY2FtZWxDYXNlYCBjb252ZW50aW9uXG4gICAgICAgKlxuICAgICAgICovXG4gICAgICBzdGF0aWMgY3JlYXRlUHJvcGVydGllc0ZvckF0dHJpYnV0ZXMoKSB7XG4gICAgICAgIGxldCBhJCA9IHRoaXMub2JzZXJ2ZWRBdHRyaWJ1dGVzO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGkgPCBhJC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHRoaXMucHJvdG90eXBlLl9jcmVhdGVQcm9wZXJ0eUFjY2Vzc29yKGNhc2VNYXAuZGFzaFRvQ2FtZWxDYXNlKGEkW2ldKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cbiAgICAgICAgdGhpcy5fX3NlcmlhbGl6aW5nO1xuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy5fX2RhdGFDb3VudGVyO1xuICAgICAgICAvKiogQHR5cGUge2Jvb2xlYW59ICovXG4gICAgICAgIHRoaXMuX19kYXRhRW5hYmxlZDtcbiAgICAgICAgLyoqIEB0eXBlIHtib29sZWFufSAqL1xuICAgICAgICB0aGlzLl9fZGF0YVJlYWR5O1xuICAgICAgICAvKiogQHR5cGUge2Jvb2xlYW59ICovXG4gICAgICAgIHRoaXMuX19kYXRhSW52YWxpZDtcbiAgICAgICAgLyoqIEB0eXBlIHshT2JqZWN0fSAqL1xuICAgICAgICB0aGlzLl9fZGF0YTtcbiAgICAgICAgLyoqIEB0eXBlIHtPYmplY3R9ICovXG4gICAgICAgIHRoaXMuX19kYXRhUGVuZGluZztcbiAgICAgICAgLyoqIEB0eXBlIHtPYmplY3R9ICovXG4gICAgICAgIHRoaXMuX19kYXRhT2xkO1xuICAgICAgICAvKiogQHR5cGUge09iamVjdH0gKi9cbiAgICAgICAgdGhpcy5fX2RhdGFQcm90bztcbiAgICAgICAgLyoqIEB0eXBlIHtPYmplY3R9ICovXG4gICAgICAgIHRoaXMuX19kYXRhSGFzQWNjZXNzb3I7XG4gICAgICAgIC8qKiBAdHlwZSB7T2JqZWN0fSAqL1xuICAgICAgICB0aGlzLl9fZGF0YUluc3RhbmNlUHJvcHM7XG4gICAgICAgIHRoaXMuX2luaXRpYWxpemVQcm9wZXJ0aWVzKCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogSW1wbGVtZW50cyBuYXRpdmUgQ3VzdG9tIEVsZW1lbnRzIGBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2tgIHRvXG4gICAgICAgKiBzZXQgYW4gYXR0cmlidXRlIHZhbHVlIHRvIGEgcHJvcGVydHkgdmlhIGBfYXR0cmlidXRlVG9Qcm9wZXJ0eWAuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgTmFtZSBvZiBhdHRyaWJ1dGUgdGhhdCBjaGFuZ2VkXG4gICAgICAgKiBAcGFyYW0gez9zdHJpbmd9IG9sZCBPbGQgYXR0cmlidXRlIHZhbHVlXG4gICAgICAgKiBAcGFyYW0gez9zdHJpbmd9IHZhbHVlIE5ldyBhdHRyaWJ1dGUgdmFsdWVcbiAgICAgICAqL1xuICAgICAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIG9sZCwgdmFsdWUpIHtcbiAgICAgICAgaWYgKG9sZCAhPT0gdmFsdWUpIHtcbiAgICAgICAgICB0aGlzLl9hdHRyaWJ1dGVUb1Byb3BlcnR5KG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEluaXRpYWxpemVzIHRoZSBsb2NhbCBzdG9yYWdlIGZvciBwcm9wZXJ0eSBhY2Nlc3NvcnMuXG4gICAgICAgKlxuICAgICAgICogUHJvdmlkZWQgYXMgYW4gb3ZlcnJpZGUgcG9pbnQgZm9yIHBlcmZvcm1pbmcgYW55IHNldHVwIHdvcmsgcHJpb3JcbiAgICAgICAqIHRvIGluaXRpYWxpemluZyB0aGUgcHJvcGVydHkgYWNjZXNzb3Igc3lzdGVtLlxuICAgICAgICpcbiAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAqL1xuICAgICAgX2luaXRpYWxpemVQcm9wZXJ0aWVzKCkge1xuICAgICAgICB0aGlzLl9fc2VyaWFsaXppbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fX2RhdGFDb3VudGVyID0gMDtcbiAgICAgICAgdGhpcy5fX2RhdGFFbmFibGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX19kYXRhUmVhZHkgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fX2RhdGFJbnZhbGlkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX19kYXRhID0ge307XG4gICAgICAgIHRoaXMuX19kYXRhUGVuZGluZyA9IG51bGw7XG4gICAgICAgIHRoaXMuX19kYXRhT2xkID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuX19kYXRhUHJvdG8pIHtcbiAgICAgICAgICB0aGlzLl9pbml0aWFsaXplUHJvdG9Qcm9wZXJ0aWVzKHRoaXMuX19kYXRhUHJvdG8pO1xuICAgICAgICAgIHRoaXMuX19kYXRhUHJvdG8gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIENhcHR1cmUgaW5zdGFuY2UgcHJvcGVydGllczsgdGhlc2Ugd2lsbCBiZSBzZXQgaW50byBhY2Nlc3NvcnNcbiAgICAgICAgLy8gZHVyaW5nIGZpcnN0IGZsdXNoLiBEb24ndCBzZXQgdGhlbSBoZXJlLCBzaW5jZSB3ZSB3YW50XG4gICAgICAgIC8vIHRoZXNlIHRvIG92ZXJ3cml0ZSBkZWZhdWx0cy9jb25zdHJ1Y3RvciBhc3NpZ25tZW50c1xuICAgICAgICBmb3IgKGxldCBwIGluIHRoaXMuX19kYXRhSGFzQWNjZXNzb3IpIHtcbiAgICAgICAgICBpZiAodGhpcy5oYXNPd25Qcm9wZXJ0eShwKSkge1xuICAgICAgICAgICAgdGhpcy5fX2RhdGFJbnN0YW5jZVByb3BzID0gdGhpcy5fX2RhdGFJbnN0YW5jZVByb3BzIHx8IHt9O1xuICAgICAgICAgICAgdGhpcy5fX2RhdGFJbnN0YW5jZVByb3BzW3BdID0gdGhpc1twXTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzW3BdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENhbGxlZCBhdCBpbnN0YW5jZSB0aW1lIHdpdGggYmFnIG9mIHByb3BlcnRpZXMgdGhhdCB3ZXJlIG92ZXJ3cml0dGVuXG4gICAgICAgKiBieSBhY2Nlc3NvcnMgb24gdGhlIHByb3RvdHlwZSB3aGVuIGFjY2Vzc29ycyB3ZXJlIGNyZWF0ZWQuXG4gICAgICAgKlxuICAgICAgICogVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gc2V0cyB0aGVzZSBwcm9wZXJ0aWVzIGJhY2sgaW50byB0aGVcbiAgICAgICAqIHNldHRlciBhdCBpbnN0YW5jZSB0aW1lLiAgVGhpcyBtZXRob2QgaXMgcHJvdmlkZWQgYXMgYW4gb3ZlcnJpZGVcbiAgICAgICAqIHBvaW50IGZvciBjdXN0b21pemluZyBvciBwcm92aWRpbmcgbW9yZSBlZmZpY2llbnQgaW5pdGlhbGl6YXRpb24uXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzIEJhZyBvZiBwcm9wZXJ0eSB2YWx1ZXMgdGhhdCB3ZXJlIG92ZXJ3cml0dGVuXG4gICAgICAgKiAgIHdoZW4gY3JlYXRpbmcgcHJvcGVydHkgYWNjZXNzb3JzLlxuICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICovXG4gICAgICBfaW5pdGlhbGl6ZVByb3RvUHJvcGVydGllcyhwcm9wcykge1xuICAgICAgICBmb3IgKGxldCBwIGluIHByb3BzKSB7XG4gICAgICAgICAgdGhpcy5fc2V0UHJvcGVydHkocCwgcHJvcHNbcF0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ2FsbGVkIGF0IHJlYWR5IHRpbWUgd2l0aCBiYWcgb2YgaW5zdGFuY2UgcHJvcGVydGllcyB0aGF0IG92ZXJ3cm90ZVxuICAgICAgICogYWNjZXNzb3JzIHdoZW4gdGhlIGVsZW1lbnQgdXBncmFkZWQuXG4gICAgICAgKlxuICAgICAgICogVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gc2V0cyB0aGVzZSBwcm9wZXJ0aWVzIGJhY2sgaW50byB0aGVcbiAgICAgICAqIHNldHRlciBhdCByZWFkeSB0aW1lLiAgVGhpcyBtZXRob2QgaXMgcHJvdmlkZWQgYXMgYW4gb3ZlcnJpZGVcbiAgICAgICAqIHBvaW50IGZvciBjdXN0b21pemluZyBvciBwcm92aWRpbmcgbW9yZSBlZmZpY2llbnQgaW5pdGlhbGl6YXRpb24uXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzIEJhZyBvZiBwcm9wZXJ0eSB2YWx1ZXMgdGhhdCB3ZXJlIG92ZXJ3cml0dGVuXG4gICAgICAgKiAgIHdoZW4gY3JlYXRpbmcgcHJvcGVydHkgYWNjZXNzb3JzLlxuICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICovXG4gICAgICBfaW5pdGlhbGl6ZUluc3RhbmNlUHJvcGVydGllcyhwcm9wcykge1xuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMsIHByb3BzKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBFbnN1cmVzIHRoZSBlbGVtZW50IGhhcyB0aGUgZ2l2ZW4gYXR0cmlidXRlLiBJZiBpdCBkb2VzIG5vdCxcbiAgICAgICAqIGFzc2lnbnMgdGhlIGdpdmVuIHZhbHVlIHRvIHRoZSBhdHRyaWJ1dGUuXG4gICAgICAgKlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGUgTmFtZSBvZiBhdHRyaWJ1dGUgdG8gZW5zdXJlIGlzIHNldC5cbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSBvZiB0aGUgYXR0cmlidXRlLlxuICAgICAgICovXG4gICAgICBfZW5zdXJlQXR0cmlidXRlKGF0dHJpYnV0ZSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhc0F0dHJpYnV0ZShhdHRyaWJ1dGUpKSB7XG4gICAgICAgICAgdGhpcy5fdmFsdWVUb05vZGVBdHRyaWJ1dGUodGhpcywgdmFsdWUsIGF0dHJpYnV0ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBEZXNlcmlhbGl6ZXMgYW4gYXR0cmlidXRlIHRvIGl0cyBhc3NvY2lhdGVkIHByb3BlcnR5LlxuICAgICAgICpcbiAgICAgICAqIFRoaXMgbWV0aG9kIGNhbGxzIHRoZSBgX2Rlc2VyaWFsaXplVmFsdWVgIG1ldGhvZCB0byBjb252ZXJ0IHRoZSBzdHJpbmcgdG9cbiAgICAgICAqIGEgdHlwZWQgdmFsdWUuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGF0dHJpYnV0ZSBOYW1lIG9mIGF0dHJpYnV0ZSB0byBkZXNlcmlhbGl6ZS5cbiAgICAgICAqIEBwYXJhbSB7P3N0cmluZ30gdmFsdWUgb2YgdGhlIGF0dHJpYnV0ZS5cbiAgICAgICAqIEBwYXJhbSB7Kj19IHR5cGUgdHlwZSB0byBkZXNlcmlhbGl6ZSB0by5cbiAgICAgICAqL1xuICAgICAgX2F0dHJpYnV0ZVRvUHJvcGVydHkoYXR0cmlidXRlLCB2YWx1ZSwgdHlwZSkge1xuICAgICAgICAvLyBEb24ndCBkZXNlcmlhbGl6ZSBiYWNrIHRvIHByb3BlcnR5IGlmIGN1cnJlbnRseSByZWZsZWN0aW5nXG4gICAgICAgIGlmICghdGhpcy5fX3NlcmlhbGl6aW5nKSB7XG4gICAgICAgICAgbGV0IHByb3BlcnR5ID0gY2FzZU1hcC5kYXNoVG9DYW1lbENhc2UoYXR0cmlidXRlKTtcbiAgICAgICAgICB0aGlzW3Byb3BlcnR5XSA9IHRoaXMuX2Rlc2VyaWFsaXplVmFsdWUodmFsdWUsIHR5cGUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogU2VyaWFsaXplcyBhIHByb3BlcnR5IHRvIGl0cyBhc3NvY2lhdGVkIGF0dHJpYnV0ZS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgbmFtZSB0byByZWZsZWN0LlxuICAgICAgICogQHBhcmFtIHtzdHJpbmc9fSBhdHRyaWJ1dGUgQXR0cmlidXRlIG5hbWUgdG8gcmVmbGVjdC5cbiAgICAgICAqIEBwYXJhbSB7Kj19IHZhbHVlIFByb3BlcnR5IHZhbHVlIHRvIHJlZmVjdC5cbiAgICAgICAqL1xuICAgICAgX3Byb3BlcnR5VG9BdHRyaWJ1dGUocHJvcGVydHksIGF0dHJpYnV0ZSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5fX3NlcmlhbGl6aW5nID0gdHJ1ZTtcbiAgICAgICAgdmFsdWUgPSAoYXJndW1lbnRzLmxlbmd0aCA8IDMpID8gdGhpc1twcm9wZXJ0eV0gOiB2YWx1ZTtcbiAgICAgICAgdGhpcy5fdmFsdWVUb05vZGVBdHRyaWJ1dGUodGhpcywgdmFsdWUsXG4gICAgICAgICAgYXR0cmlidXRlIHx8IGNhc2VNYXAuY2FtZWxUb0Rhc2hDYXNlKHByb3BlcnR5KSk7XG4gICAgICAgIHRoaXMuX19zZXJpYWxpemluZyA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFNldHMgYSB0eXBlZCB2YWx1ZSB0byBhbiBIVE1MIGF0dHJpYnV0ZSBvbiBhIG5vZGUuXG4gICAgICAgKlxuICAgICAgICogVGhpcyBtZXRob2QgY2FsbHMgdGhlIGBfc2VyaWFsaXplVmFsdWVgIG1ldGhvZCB0byBjb252ZXJ0IHRoZSB0eXBlZFxuICAgICAgICogdmFsdWUgdG8gYSBzdHJpbmcuICBJZiB0aGUgYF9zZXJpYWxpemVWYWx1ZWAgbWV0aG9kIHJldHVybnMgYHVuZGVmaW5lZGAsXG4gICAgICAgKiB0aGUgYXR0cmlidXRlIHdpbGwgYmUgcmVtb3ZlZCAodGhpcyBpcyB0aGUgZGVmYXVsdCBmb3IgYm9vbGVhblxuICAgICAgICogdHlwZSBgZmFsc2VgKS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgRWxlbWVudCB0byBzZXQgYXR0cmlidXRlIHRvLlxuICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byBzZXJpYWxpemUuXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlIEF0dHJpYnV0ZSBuYW1lIHRvIHNlcmlhbGl6ZSB0by5cbiAgICAgICAqL1xuICAgICAgX3ZhbHVlVG9Ob2RlQXR0cmlidXRlKG5vZGUsIHZhbHVlLCBhdHRyaWJ1dGUpIHtcbiAgICAgICAgbGV0IHN0ciA9IHRoaXMuX3NlcmlhbGl6ZVZhbHVlKHZhbHVlKTtcbiAgICAgICAgaWYgKHN0ciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUoYXR0cmlidXRlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShhdHRyaWJ1dGUsIHN0cik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDb252ZXJ0cyBhIHR5cGVkIEphdmFTY3JpcHQgdmFsdWUgdG8gYSBzdHJpbmcuXG4gICAgICAgKlxuICAgICAgICogVGhpcyBtZXRob2QgaXMgY2FsbGVkIGJ5IFBvbHltZXIgd2hlbiBzZXR0aW5nIEpTIHByb3BlcnR5IHZhbHVlcyB0b1xuICAgICAgICogSFRNTCBhdHRyaWJ1dGVzLiAgVXNlcnMgbWF5IG92ZXJyaWRlIHRoaXMgbWV0aG9kIG9uIFBvbHltZXIgZWxlbWVudFxuICAgICAgICogcHJvdG90eXBlcyB0byBwcm92aWRlIHNlcmlhbGl6YXRpb24gZm9yIGN1c3RvbSB0eXBlcy5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFByb3BlcnR5IHZhbHVlIHRvIHNlcmlhbGl6ZS5cbiAgICAgICAqIEByZXR1cm4ge3N0cmluZyB8IHVuZGVmaW5lZH0gU3RyaW5nIHNlcmlhbGl6ZWQgZnJvbSB0aGUgcHJvdmlkZWQgcHJvcGVydHkgdmFsdWUuXG4gICAgICAgKi9cbiAgICAgIF9zZXJpYWxpemVWYWx1ZSh2YWx1ZSkge1xuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1mYWxsdGhyb3VnaCAqL1xuICAgICAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlID8gJycgOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICAgICAgICAgICAgICB9IGNhdGNoKHgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgIT0gbnVsbCA/IHZhbHVlLnRvU3RyaW5nKCkgOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDb252ZXJ0cyBhIHN0cmluZyB0byBhIHR5cGVkIEphdmFTY3JpcHQgdmFsdWUuXG4gICAgICAgKlxuICAgICAgICogVGhpcyBtZXRob2QgaXMgY2FsbGVkIGJ5IFBvbHltZXIgd2hlbiByZWFkaW5nIEhUTUwgYXR0cmlidXRlIHZhbHVlcyB0b1xuICAgICAgICogSlMgcHJvcGVydGllcy4gIFVzZXJzIG1heSBvdmVycmlkZSB0aGlzIG1ldGhvZCBvbiBQb2x5bWVyIGVsZW1lbnRcbiAgICAgICAqIHByb3RvdHlwZXMgdG8gcHJvdmlkZSBkZXNlcmlhbGl6YXRpb24gZm9yIGN1c3RvbSBgdHlwZWBzLiAgTm90ZSxcbiAgICAgICAqIHRoZSBgdHlwZWAgYXJndW1lbnQgaXMgdGhlIHZhbHVlIG9mIHRoZSBgdHlwZWAgZmllbGQgcHJvdmlkZWQgaW4gdGhlXG4gICAgICAgKiBgcHJvcGVydGllc2AgY29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGEgZ2l2ZW4gcHJvcGVydHksIGFuZCBpc1xuICAgICAgICogYnkgY29udmVudGlvbiB0aGUgY29uc3RydWN0b3IgZm9yIHRoZSB0eXBlIHRvIGRlc2VyaWFsaXplLlxuICAgICAgICpcbiAgICAgICAqIE5vdGU6IFRoZSByZXR1cm4gdmFsdWUgb2YgYHVuZGVmaW5lZGAgaXMgdXNlZCBhcyBhIHNlbnRpbmVsIHZhbHVlIHRvXG4gICAgICAgKiBpbmRpY2F0ZSB0aGUgYXR0cmlidXRlIHNob3VsZCBiZSByZW1vdmVkLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7P3N0cmluZ30gdmFsdWUgQXR0cmlidXRlIHZhbHVlIHRvIGRlc2VyaWFsaXplLlxuICAgICAgICogQHBhcmFtIHsqPX0gdHlwZSBUeXBlIHRvIGRlc2VyaWFsaXplIHRoZSBzdHJpbmcgdG8uXG4gICAgICAgKiBAcmV0dXJuIHsqfSBUeXBlZCB2YWx1ZSBkZXNlcmlhbGl6ZWQgZnJvbSB0aGUgcHJvdmlkZWQgc3RyaW5nLlxuICAgICAgICovXG4gICAgICBfZGVzZXJpYWxpemVWYWx1ZSh2YWx1ZSwgdHlwZSkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUgeyp9XG4gICAgICAgICAqL1xuICAgICAgICBsZXQgb3V0VmFsdWU7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgIGNhc2UgTnVtYmVyOlxuICAgICAgICAgICAgb3V0VmFsdWUgPSBOdW1iZXIodmFsdWUpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIEJvb2xlYW46XG4gICAgICAgICAgICBvdXRWYWx1ZSA9ICh2YWx1ZSAhPT0gbnVsbCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgT2JqZWN0OlxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgb3V0VmFsdWUgPSBKU09OLnBhcnNlKC8qKiBAdHlwZSBzdHJpbmcgKi8odmFsdWUpKTtcbiAgICAgICAgICAgIH0gY2F0Y2goeCkge1xuICAgICAgICAgICAgICAvLyBhbGxvdyBub24tSlNPTiBsaXRlcmFscyBsaWtlIFN0cmluZ3MgYW5kIE51bWJlcnNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBBcnJheTpcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIG91dFZhbHVlID0gSlNPTi5wYXJzZSgvKiogQHR5cGUgc3RyaW5nICovKHZhbHVlKSk7XG4gICAgICAgICAgICB9IGNhdGNoKHgpIHtcbiAgICAgICAgICAgICAgb3V0VmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYFBvbHltZXI6OkF0dHJpYnV0ZXM6IGNvdWxkbid0IGRlY29kZSBBcnJheSBhcyBKU09OOiAke3ZhbHVlfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIERhdGU6XG4gICAgICAgICAgICBvdXRWYWx1ZSA9IG5ldyBEYXRlKHZhbHVlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBTdHJpbmc6XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIG91dFZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvdXRWYWx1ZTtcbiAgICAgIH1cbiAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tZmFsbHRocm91Z2ggKi9cblxuICAgICAgLyoqXG4gICAgICAgKiBDcmVhdGVzIGEgc2V0dGVyL2dldHRlciBwYWlyIGZvciB0aGUgbmFtZWQgcHJvcGVydHkgd2l0aCBpdHMgb3duXG4gICAgICAgKiBsb2NhbCBzdG9yYWdlLiAgVGhlIGdldHRlciByZXR1cm5zIHRoZSB2YWx1ZSBpbiB0aGUgbG9jYWwgc3RvcmFnZSxcbiAgICAgICAqIGFuZCB0aGUgc2V0dGVyIGNhbGxzIGBfc2V0UHJvcGVydHlgLCB3aGljaCB1cGRhdGVzIHRoZSBsb2NhbCBzdG9yYWdlXG4gICAgICAgKiBmb3IgdGhlIHByb3BlcnR5IGFuZCBlbnF1ZXVlcyBhIGBfcHJvcGVydGllc0NoYW5nZWRgIGNhbGxiYWNrLlxuICAgICAgICpcbiAgICAgICAqIFRoaXMgbWV0aG9kIG1heSBiZSBjYWxsZWQgb24gYSBwcm90b3R5cGUgb3IgYW4gaW5zdGFuY2UuICBDYWxsaW5nXG4gICAgICAgKiB0aGlzIG1ldGhvZCBtYXkgb3ZlcndyaXRlIGEgcHJvcGVydHkgdmFsdWUgdGhhdCBhbHJlYWR5IGV4aXN0cyBvblxuICAgICAgICogdGhlIHByb3RvdHlwZS9pbnN0YW5jZSBieSBjcmVhdGluZyB0aGUgYWNjZXNzb3IuICBXaGVuIGNhbGxpbmcgb25cbiAgICAgICAqIGEgcHJvdG90eXBlLCBhbnkgb3ZlcndyaXR0ZW4gdmFsdWVzIGFyZSBzYXZlZCBpbiBgX19kYXRhUHJvdG9gLFxuICAgICAgICogYW5kIGl0IGlzIHVwIHRvIHRoZSBzdWJjbGFzc2VyIHRvIGRlY2lkZSBob3cvd2hlbiB0byBzZXQgdGhvc2VcbiAgICAgICAqIHByb3BlcnRpZXMgYmFjayBpbnRvIHRoZSBhY2Nlc3Nvci4gIFdoZW4gY2FsbGluZyBvbiBhbiBpbnN0YW5jZSxcbiAgICAgICAqIHRoZSBvdmVyd3JpdHRlbiB2YWx1ZSBpcyBzZXQgdmlhIGBfc2V0UGVuZGluZ1Byb3BlcnR5YCwgYW5kIHRoZVxuICAgICAgICogdXNlciBzaG91bGQgY2FsbCBgX2ludmFsaWRhdGVQcm9wZXJ0aWVzYCBvciBgX2ZsdXNoUHJvcGVydGllc2BcbiAgICAgICAqIGZvciB0aGUgdmFsdWVzIHRvIHRha2UgZWZmZWN0LlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBOYW1lIG9mIHRoZSBwcm9wZXJ0eVxuICAgICAgICogQHBhcmFtIHtib29sZWFuPX0gcmVhZE9ubHkgV2hlbiB0cnVlLCBubyBzZXR0ZXIgaXMgY3JlYXRlZDsgdGhlXG4gICAgICAgKiAgIHByb3RlY3RlZCBgX3NldFByb3BlcnR5YCBmdW5jdGlvbiBtdXN0IGJlIHVzZWQgdG8gc2V0IHRoZSBwcm9wZXJ0eVxuICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICovXG4gICAgICBfY3JlYXRlUHJvcGVydHlBY2Nlc3Nvcihwcm9wZXJ0eSwgcmVhZE9ubHkpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhc093blByb3BlcnR5KCdfX2RhdGFIYXNBY2Nlc3NvcicpKSB7XG4gICAgICAgICAgdGhpcy5fX2RhdGFIYXNBY2Nlc3NvciA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuX19kYXRhSGFzQWNjZXNzb3IpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5fX2RhdGFIYXNBY2Nlc3Nvcltwcm9wZXJ0eV0pIHtcbiAgICAgICAgICB0aGlzLl9fZGF0YUhhc0FjY2Vzc29yW3Byb3BlcnR5XSA9IHRydWU7XG4gICAgICAgICAgc2F2ZUFjY2Vzc29yVmFsdWUodGhpcywgcHJvcGVydHkpO1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBwcm9wZXJ0eSwge1xuICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgdmFsaWQtanNkb2MgKi9cbiAgICAgICAgICAgIC8qKiBAdGhpcyB7UHJvcGVydHlBY2Nlc3NvcnN9ICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fX2RhdGFbcHJvcGVydHldO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8qKiBAdGhpcyB7UHJvcGVydHlBY2Nlc3NvcnN9ICovXG4gICAgICAgICAgICBzZXQ6IHJlYWRPbmx5ID8gZnVuY3Rpb24oKSB7fSA6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3NldFByb3BlcnR5KHByb3BlcnR5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBlc2xpbnQtZW5hYmxlICovXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBsaWJyYXJ5IGNyZWF0ZWQgYW4gYWNjZXNzb3IgZm9yIHRoZSBnaXZlbiBwcm9wZXJ0eS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgbmFtZVxuICAgICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBhbiBhY2Nlc3NvciB3YXMgY3JlYXRlZFxuICAgICAgICovXG4gICAgICBfaGFzQWNjZXNzb3IocHJvcGVydHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19kYXRhSGFzQWNjZXNzb3IgJiYgdGhpcy5fX2RhdGFIYXNBY2Nlc3Nvcltwcm9wZXJ0eV07XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogVXBkYXRlcyB0aGUgbG9jYWwgc3RvcmFnZSBmb3IgYSBwcm9wZXJ0eSAodmlhIGBfc2V0UGVuZGluZ1Byb3BlcnR5YClcbiAgICAgICAqIGFuZCBlbnF1ZXVlcyBhIGBfcHJvZXBydGllc0NoYW5nZWRgIGNhbGxiYWNrLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBOYW1lIG9mIHRoZSBwcm9wZXJ0eVxuICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byBzZXRcbiAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAqL1xuICAgICAgX3NldFByb3BlcnR5KHByb3BlcnR5LCB2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5fc2V0UGVuZGluZ1Byb3BlcnR5KHByb3BlcnR5LCB2YWx1ZSkpIHtcbiAgICAgICAgICB0aGlzLl9pbnZhbGlkYXRlUHJvcGVydGllcygpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogVXBkYXRlcyB0aGUgbG9jYWwgc3RvcmFnZSBmb3IgYSBwcm9wZXJ0eSwgcmVjb3JkcyB0aGUgcHJldmlvdXMgdmFsdWUsXG4gICAgICAgKiBhbmQgYWRkcyBpdCB0byB0aGUgc2V0IG9mIFwicGVuZGluZyBjaGFuZ2VzXCIgdGhhdCB3aWxsIGJlIHBhc3NlZCB0byB0aGVcbiAgICAgICAqIGBfcHJvcGVydGllc0NoYW5nZWRgIGNhbGxiYWNrLiAgVGhpcyBtZXRob2QgZG9lcyBub3QgZW5xdWV1ZSB0aGVcbiAgICAgICAqIGBfcHJvcGVydGllc0NoYW5nZWRgIGNhbGxiYWNrLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBOYW1lIG9mIHRoZSBwcm9wZXJ0eVxuICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byBzZXRcbiAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGUgcHJvcGVydHkgY2hhbmdlZFxuICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICovXG4gICAgICBfc2V0UGVuZGluZ1Byb3BlcnR5KHByb3BlcnR5LCB2YWx1ZSkge1xuICAgICAgICBsZXQgb2xkID0gdGhpcy5fX2RhdGFbcHJvcGVydHldO1xuICAgICAgICBsZXQgY2hhbmdlZCA9IHRoaXMuX3Nob3VsZFByb3BlcnR5Q2hhbmdlKHByb3BlcnR5LCB2YWx1ZSwgb2xkKVxuICAgICAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgICAgIGlmICghdGhpcy5fX2RhdGFQZW5kaW5nKSB7XG4gICAgICAgICAgICB0aGlzLl9fZGF0YVBlbmRpbmcgPSB7fTtcbiAgICAgICAgICAgIHRoaXMuX19kYXRhT2xkID0ge307XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIEVuc3VyZSBvbGQgaXMgY2FwdHVyZWQgZnJvbSB0aGUgbGFzdCB0dXJuXG4gICAgICAgICAgaWYgKHRoaXMuX19kYXRhT2xkICYmICEocHJvcGVydHkgaW4gdGhpcy5fX2RhdGFPbGQpKSB7XG4gICAgICAgICAgICB0aGlzLl9fZGF0YU9sZFtwcm9wZXJ0eV0gPSBvbGQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX19kYXRhW3Byb3BlcnR5XSA9IHZhbHVlO1xuICAgICAgICAgIHRoaXMuX19kYXRhUGVuZGluZ1twcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hhbmdlZDtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHNwZWNpZmllZCBwcm9wZXJ0eSBoYXMgYSBwZW5kaW5nIGNoYW5nZS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcCBQcm9wZXJ0eSBuYW1lXG4gICAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHByb3BlcnR5IGhhcyBhIHBlbmRpbmcgY2hhbmdlXG4gICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgKi9cbiAgICAgIF9pc1Byb3BlcnR5UGVuZGluZyhwcm9wKSB7XG4gICAgICAgIHJldHVybiBCb29sZWFuKHRoaXMuX19kYXRhUGVuZGluZyAmJiAocHJvcCBpbiB0aGlzLl9fZGF0YVBlbmRpbmcpKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBNYXJrcyB0aGUgcHJvcGVydGllcyBhcyBpbnZhbGlkLCBhbmQgZW5xdWV1ZXMgYW4gYXN5bmNcbiAgICAgICAqIGBfcHJvcGVydGllc0NoYW5nZWRgIGNhbGxiYWNrLlxuICAgICAgICpcbiAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAqL1xuICAgICAgX2ludmFsaWRhdGVQcm9wZXJ0aWVzKCkge1xuICAgICAgICBpZiAoIXRoaXMuX19kYXRhSW52YWxpZCAmJiB0aGlzLl9fZGF0YVJlYWR5KSB7XG4gICAgICAgICAgdGhpcy5fX2RhdGFJbnZhbGlkID0gdHJ1ZTtcbiAgICAgICAgICBtaWNyb3Rhc2sucnVuKCgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9fZGF0YUludmFsaWQpIHtcbiAgICAgICAgICAgICAgdGhpcy5fX2RhdGFJbnZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgIHRoaXMuX2ZsdXNoUHJvcGVydGllcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ2FsbCB0byBlbmFibGUgcHJvcGVydHkgYWNjZXNzb3IgcHJvY2Vzc2luZy4gQmVmb3JlIHRoaXMgbWV0aG9kIGlzXG4gICAgICAgKiBjYWxsZWQgYWNjZXNzb3IgdmFsdWVzIHdpbGwgYmUgc2V0IGJ1dCBzaWRlIGVmZmVjdHMgYXJlXG4gICAgICAgKiBxdWV1ZWQuIFdoZW4gY2FsbGVkLCBhbnkgcGVuZGluZyBzaWRlIGVmZmVjdHMgb2NjdXIgaW1tZWRpYXRlbHkuXG4gICAgICAgKiBGb3IgZWxlbWVudHMsIGdlbmVyYWxseSBgY29ubmVjdGVkQ2FsbGJhY2tgIGlzIGEgbm9ybWFsIHNwb3QgdG8gZG8gc28uXG4gICAgICAgKiBJdCBpcyBzYWZlIHRvIGNhbGwgdGhpcyBtZXRob2QgbXVsdGlwbGUgdGltZXMgYXMgaXQgb25seSB0dXJucyBvblxuICAgICAgICogcHJvcGVydHkgYWNjZXNzb3JzIG9uY2UuXG4gICAgICAgKi9cbiAgICAgIF9lbmFibGVQcm9wZXJ0aWVzKCkge1xuICAgICAgICBpZiAoIXRoaXMuX19kYXRhRW5hYmxlZCkge1xuICAgICAgICAgIHRoaXMuX19kYXRhRW5hYmxlZCA9IHRydWU7XG4gICAgICAgICAgaWYgKHRoaXMuX19kYXRhSW5zdGFuY2VQcm9wcykge1xuICAgICAgICAgICAgdGhpcy5faW5pdGlhbGl6ZUluc3RhbmNlUHJvcGVydGllcyh0aGlzLl9fZGF0YUluc3RhbmNlUHJvcHMpO1xuICAgICAgICAgICAgdGhpcy5fX2RhdGFJbnN0YW5jZVByb3BzID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5yZWFkeSgpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDYWxscyB0aGUgYF9wcm9wZXJ0aWVzQ2hhbmdlZGAgY2FsbGJhY2sgd2l0aCB0aGUgY3VycmVudCBzZXQgb2ZcbiAgICAgICAqIHBlbmRpbmcgY2hhbmdlcyAoYW5kIG9sZCB2YWx1ZXMgcmVjb3JkZWQgd2hlbiBwZW5kaW5nIGNoYW5nZXMgd2VyZVxuICAgICAgICogc2V0KSwgYW5kIHJlc2V0cyB0aGUgcGVuZGluZyBzZXQgb2YgY2hhbmdlcy4gR2VuZXJhbGx5LCB0aGlzIG1ldGhvZFxuICAgICAgICogc2hvdWxkIG5vdCBiZSBjYWxsZWQgaW4gdXNlciBjb2RlLlxuICAgICAgICpcbiAgICAgICAqXG4gICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgKi9cbiAgICAgIF9mbHVzaFByb3BlcnRpZXMoKSB7XG4gICAgICAgIGlmICh0aGlzLl9fZGF0YVBlbmRpbmcgJiYgdGhpcy5fX2RhdGFPbGQpIHtcbiAgICAgICAgICBsZXQgY2hhbmdlZFByb3BzID0gdGhpcy5fX2RhdGFQZW5kaW5nO1xuICAgICAgICAgIHRoaXMuX19kYXRhUGVuZGluZyA9IG51bGw7XG4gICAgICAgICAgdGhpcy5fX2RhdGFDb3VudGVyKys7XG4gICAgICAgICAgdGhpcy5fcHJvcGVydGllc0NoYW5nZWQodGhpcy5fX2RhdGEsIGNoYW5nZWRQcm9wcywgdGhpcy5fX2RhdGFPbGQpO1xuICAgICAgICAgIHRoaXMuX19kYXRhQ291bnRlci0tO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogTGlmZWN5Y2xlIGNhbGxiYWNrIGNhbGxlZCB0aGUgZmlyc3QgdGltZSBwcm9wZXJ0aWVzIGFyZSBiZWluZyBmbHVzaGVkLlxuICAgICAgICogUHJpb3IgdG8gYHJlYWR5YCwgYWxsIHByb3BlcnR5IHNldHMgdGhyb3VnaCBhY2Nlc3NvcnMgYXJlIHF1ZXVlZCBhbmRcbiAgICAgICAqIHRoZWlyIGVmZmVjdHMgYXJlIGZsdXNoZWQgYWZ0ZXIgdGhpcyBtZXRob2QgcmV0dXJucy5cbiAgICAgICAqXG4gICAgICAgKiBVc2VycyBtYXkgb3ZlcnJpZGUgdGhpcyBmdW5jdGlvbiB0byBpbXBsZW1lbnQgYmVoYXZpb3IgdGhhdCBpc1xuICAgICAgICogZGVwZW5kZW50IG9uIHRoZSBlbGVtZW50IGhhdmluZyBpdHMgcHJvcGVydGllcyBpbml0aWFsaXplZCwgZS5nLlxuICAgICAgICogZnJvbSBkZWZhdWx0cyAoaW5pdGlhbGl6ZWQgZnJvbSBgY29uc3RydWN0b3JgLCBgX2luaXRpYWxpemVQcm9wZXJ0aWVzYCksXG4gICAgICAgKiBgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrYCwgb3IgdmFsdWVzIHByb3BhZ2F0ZWQgZnJvbSBob3N0IGUuZy4gdmlhXG4gICAgICAgKiBiaW5kaW5ncy4gIGBzdXBlci5yZWFkeSgpYCBtdXN0IGJlIGNhbGxlZCB0byBlbnN1cmUgdGhlIGRhdGEgc3lzdGVtXG4gICAgICAgKiBiZWNvbWVzIGVuYWJsZWQuXG4gICAgICAgKlxuICAgICAgICogQHB1YmxpY1xuICAgICAgICovXG4gICAgICByZWFkeSgpIHtcbiAgICAgICAgdGhpcy5fX2RhdGFSZWFkeSA9IHRydWU7XG4gICAgICAgIC8vIFJ1biBub3JtYWwgZmx1c2hcbiAgICAgICAgdGhpcy5fZmx1c2hQcm9wZXJ0aWVzKCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ2FsbGJhY2sgY2FsbGVkIHdoZW4gYW55IHByb3BlcnRpZXMgd2l0aCBhY2Nlc3NvcnMgY3JlYXRlZCB2aWFcbiAgICAgICAqIGBfY3JlYXRlUHJvcGVydHlBY2Nlc3NvcmAgaGF2ZSBiZWVuIHNldC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0geyFPYmplY3R9IGN1cnJlbnRQcm9wcyBCYWcgb2YgYWxsIGN1cnJlbnQgYWNjZXNzb3IgdmFsdWVzXG4gICAgICAgKiBAcGFyYW0geyFPYmplY3R9IGNoYW5nZWRQcm9wcyBCYWcgb2YgcHJvcGVydGllcyBjaGFuZ2VkIHNpbmNlIHRoZSBsYXN0XG4gICAgICAgKiAgIGNhbGwgdG8gYF9wcm9wZXJ0aWVzQ2hhbmdlZGBcbiAgICAgICAqIEBwYXJhbSB7IU9iamVjdH0gb2xkUHJvcHMgQmFnIG9mIHByZXZpb3VzIHZhbHVlcyBmb3IgZWFjaCBwcm9wZXJ0eVxuICAgICAgICogICBpbiBgY2hhbmdlZFByb3BzYFxuICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICovXG4gICAgICBfcHJvcGVydGllc0NoYW5nZWQoY3VycmVudFByb3BzLCBjaGFuZ2VkUHJvcHMsIG9sZFByb3BzKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBNZXRob2QgY2FsbGVkIHRvIGRldGVybWluZSB3aGV0aGVyIGEgcHJvcGVydHkgdmFsdWUgc2hvdWxkIGJlXG4gICAgICAgKiBjb25zaWRlcmVkIGFzIGEgY2hhbmdlIGFuZCBjYXVzZSB0aGUgYF9wcm9wZXJ0aWVzQ2hhbmdlZGAgY2FsbGJhY2tcbiAgICAgICAqIHRvIGJlIGVucXVldWVkLlxuICAgICAgICpcbiAgICAgICAqIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIHJldHVybnMgYHRydWVgIGZvciBwcmltaXRpdmUgdHlwZXMgaWYgYVxuICAgICAgICogc3RyaWN0IGVxdWFsaXR5IGNoZWNrIGZhaWxzLCBhbmQgcmV0dXJucyBgdHJ1ZWAgZm9yIGFsbCBPYmplY3QvQXJyYXlzLlxuICAgICAgICogVGhlIG1ldGhvZCBhbHdheXMgcmV0dXJucyBmYWxzZSBmb3IgYE5hTmAuXG4gICAgICAgKlxuICAgICAgICogT3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gZS5nLiBwcm92aWRlIHN0cmljdGVyIGNoZWNraW5nIGZvclxuICAgICAgICogT2JqZWN0cy9BcnJheXMgd2hlbiB1c2luZyBpbW11dGFibGUgcGF0dGVybnMuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IG5hbWVcbiAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgTmV3IHByb3BlcnR5IHZhbHVlXG4gICAgICAgKiBAcGFyYW0geyp9IG9sZCBQcmV2aW91cyBwcm9wZXJ0eSB2YWx1ZVxuICAgICAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgcHJvcGVydHkgc2hvdWxkIGJlIGNvbnNpZGVyZWQgYSBjaGFuZ2VcbiAgICAgICAqICAgYW5kIGVucXVldWUgYSBgX3Byb2VwcnRpZXNDaGFuZ2VkYCBjYWxsYmFja1xuICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICovXG4gICAgICBfc2hvdWxkUHJvcGVydHlDaGFuZ2UocHJvcGVydHksIHZhbHVlLCBvbGQpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAvLyBTdHJpY3QgZXF1YWxpdHkgY2hlY2tcbiAgICAgICAgICAob2xkICE9PSB2YWx1ZSAmJlxuICAgICAgICAgICAvLyBUaGlzIGVuc3VyZXMgKG9sZD09TmFOLCB2YWx1ZT09TmFOKSBhbHdheXMgcmV0dXJucyBmYWxzZVxuICAgICAgICAgICAob2xkID09PSBvbGQgfHwgdmFsdWUgPT09IHZhbHVlKSlcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgIH1cblxuICAgIHJldHVybiBQcm9wZXJ0eUFjY2Vzc29ycztcblxuICB9KTtcblxufSkoKTtcbjwvc2NyaXB0PlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi9taXhpbnMvcHJvcGVydHktYWNjZXNzb3JzLmh0bWwiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi91dGlscy9ib290Lmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi91dGlscy9taXhpbi5odG1sXCI+XG5cbjxzY3JpcHQ+XG4oZnVuY3Rpb24oKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIDEueCBiYWNrd2FyZHMtY29tcGF0aWJsZSBhdXRvLXdyYXBwZXIgZm9yIHRlbXBsYXRlIHR5cGUgZXh0ZW5zaW9uc1xuICAvLyBUaGlzIGlzIGEgY2xlYXIgbGF5ZXJpbmcgdmlvbGF0aW9uIGFuZCBnaXZlcyBmYXZvcmVkLW5hdGlvbiBzdGF0dXMgdG9cbiAgLy8gZG9tLWlmIGFuZCBkb20tcmVwZWF0IHRlbXBsYXRlcy4gIFRoaXMgaXMgYSBjb25jZWl0IHdlJ3JlIGNob29zaW5nIHRvIGtlZXBcbiAgLy8gYS4pIHRvIGVhc2UgMS54IGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5IGR1ZSB0byBsb3NzIG9mIGBpc2AsIGFuZFxuICAvLyBiLikgdG8gbWFpbnRhaW4gaWYvcmVwZWF0IGNhcGFiaWxpdHkgaW4gcGFyc2VyLWNvbnN0cmFpbmVkIGVsZW1lbnRzXG4gIC8vICAgICAoZS5nLiB0YWJsZSwgc2VsZWN0KSBpbiBsaWV1IG9mIG5hdGl2ZSBDRSB0eXBlIGV4dGVuc2lvbnMgd2l0aG91dFxuICAvLyAgICAgbWFzc2l2ZSBuZXcgaW52ZW50aW9uIGluIHRoaXMgc3BhY2UgKGUuZy4gZGlyZWN0aXZlIHN5c3RlbSlcbiAgY29uc3QgdGVtcGxhdGVFeHRlbnNpb25zID0ge1xuICAgICdkb20taWYnOiB0cnVlLFxuICAgICdkb20tcmVwZWF0JzogdHJ1ZVxuICB9O1xuICBmdW5jdGlvbiB3cmFwVGVtcGxhdGVFeHRlbnNpb24obm9kZSkge1xuICAgIGxldCBpcyA9IG5vZGUuZ2V0QXR0cmlidXRlKCdpcycpO1xuICAgIGlmIChpcyAmJiB0ZW1wbGF0ZUV4dGVuc2lvbnNbaXNdKSB7XG4gICAgICBsZXQgdCA9IG5vZGU7XG4gICAgICB0LnJlbW92ZUF0dHJpYnV0ZSgnaXMnKTtcbiAgICAgIG5vZGUgPSB0Lm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudChpcyk7XG4gICAgICB0LnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKG5vZGUsIHQpO1xuICAgICAgbm9kZS5hcHBlbmRDaGlsZCh0KTtcbiAgICAgIHdoaWxlKHQuYXR0cmlidXRlcy5sZW5ndGgpIHtcbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUodC5hdHRyaWJ1dGVzWzBdLm5hbWUsIHQuYXR0cmlidXRlc1swXS52YWx1ZSk7XG4gICAgICAgIHQucmVtb3ZlQXR0cmlidXRlKHQuYXR0cmlidXRlc1swXS5uYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICBmdW5jdGlvbiBmaW5kVGVtcGxhdGVOb2RlKHJvb3QsIG5vZGVJbmZvKSB7XG4gICAgLy8gcmVjdXJzaXZlbHkgYXNjZW5kIHRyZWUgdW50aWwgd2UgaGl0IHJvb3RcbiAgICBsZXQgcGFyZW50ID0gbm9kZUluZm8ucGFyZW50SW5mbyAmJiBmaW5kVGVtcGxhdGVOb2RlKHJvb3QsIG5vZGVJbmZvLnBhcmVudEluZm8pO1xuICAgIC8vIHVud2luZCB0aGUgc3RhY2ssIHJldHVybmluZyB0aGUgaW5kZXhlZCBub2RlIGF0IGVhY2ggbGV2ZWxcbiAgICBpZiAocGFyZW50KSB7XG4gICAgICAvLyBub3RlOiBtYXJnaW5hbGx5IGZhc3RlciB0aGFuIGluZGV4aW5nIHZpYSBjaGlsZE5vZGVzXG4gICAgICAvLyAoaHR0cDovL2pzcGVyZi5jb20vY2hpbGRub2Rlcy1sb29rdXApXG4gICAgICBmb3IgKGxldCBuPXBhcmVudC5maXJzdENoaWxkLCBpPTA7IG47IG49bi5uZXh0U2libGluZykge1xuICAgICAgICBpZiAobm9kZUluZm8ucGFyZW50SW5kZXggPT09IGkrKykge1xuICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiByb290O1xuICAgIH1cbiAgfVxuXG4gIC8vIGNvbnN0cnVjdCBgJGAgbWFwIChmcm9tIGlkIGFubm90YXRpb25zKVxuICBmdW5jdGlvbiBhcHBseUlkVG9NYXAoaW5zdCwgbWFwLCBub2RlLCBub2RlSW5mbykge1xuICAgIGlmIChub2RlSW5mby5pZCkge1xuICAgICAgbWFwW25vZGVJbmZvLmlkXSA9IG5vZGU7XG4gICAgfVxuICB9XG5cbiAgLy8gaW5zdGFsbCBldmVudCBsaXN0ZW5lcnMgKGZyb20gZXZlbnQgYW5ub3RhdGlvbnMpXG4gIGZ1bmN0aW9uIGFwcGx5RXZlbnRMaXN0ZW5lcihpbnN0LCBub2RlLCBub2RlSW5mbykge1xuICAgIGlmIChub2RlSW5mby5ldmVudHMgJiYgbm9kZUluZm8uZXZlbnRzLmxlbmd0aCkge1xuICAgICAgZm9yIChsZXQgaj0wLCBlJD1ub2RlSW5mby5ldmVudHMsIGU7IChqPGUkLmxlbmd0aCkgJiYgKGU9ZSRbal0pOyBqKyspIHtcbiAgICAgICAgaW5zdC5fYWRkTWV0aG9kRXZlbnRMaXN0ZW5lclRvTm9kZShub2RlLCBlLm5hbWUsIGUudmFsdWUsIGluc3QpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIHB1c2ggY29uZmlndXJhdGlvbiByZWZlcmVuY2VzIGF0IGNvbmZpZ3VyZSB0aW1lXG4gIGZ1bmN0aW9uIGFwcGx5VGVtcGxhdGVDb250ZW50KGluc3QsIG5vZGUsIG5vZGVJbmZvKSB7XG4gICAgaWYgKG5vZGVJbmZvLnRlbXBsYXRlSW5mbykge1xuICAgICAgbm9kZS5fdGVtcGxhdGVJbmZvID0gbm9kZUluZm8udGVtcGxhdGVJbmZvO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZU5vZGVFdmVudEhhbmRsZXIoY29udGV4dCwgZXZlbnROYW1lLCBtZXRob2ROYW1lKSB7XG4gICAgLy8gSW5zdGFuY2VzIGNhbiBvcHRpb25hbGx5IGhhdmUgYSBfbWV0aG9kSG9zdCB3aGljaCBhbGxvd3MgcmVkaXJlY3Rpbmcgd2hlcmVcbiAgICAvLyB0byBmaW5kIG1ldGhvZHMuIEN1cnJlbnRseSB1c2VkIGJ5IGB0ZW1wbGF0aXplYC5cbiAgICBjb250ZXh0ID0gY29udGV4dC5fbWV0aG9kSG9zdCB8fCBjb250ZXh0O1xuICAgIGxldCBoYW5kbGVyID0gZnVuY3Rpb24oZSkge1xuICAgICAgaWYgKGNvbnRleHRbbWV0aG9kTmFtZV0pIHtcbiAgICAgICAgY29udGV4dFttZXRob2ROYW1lXShlLCBlLmRldGFpbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4oJ2xpc3RlbmVyIG1ldGhvZCBgJyArIG1ldGhvZE5hbWUgKyAnYCBub3QgZGVmaW5lZCcpO1xuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIGhhbmRsZXI7XG4gIH1cblxuICAvKipcbiAgICogRWxlbWVudCBtaXhpbiB0aGF0IHByb3ZpZGVzIGJhc2ljIHRlbXBsYXRlIHBhcnNpbmcgYW5kIHN0YW1waW5nLCBpbmNsdWRpbmdcbiAgICogdGhlIGZvbGxvd2luZyB0ZW1wbGF0ZS1yZWxhdGVkIGZlYXR1cmVzIGZvciBzdGFtcGVkIHRlbXBsYXRlczpcbiAgICpcbiAgICogLSBEZWNsYXJhdGl2ZSBldmVudCBsaXN0ZW5lcnMgKGBvbi1ldmVudG5hbWU9XCJsaXN0ZW5lclwiYClcbiAgICogLSBNYXAgb2Ygbm9kZSBpZCdzIHRvIHN0YW1wZWQgbm9kZSBpbnN0YW5jZXMgKGB0aGlzLiQuaWRgKVxuICAgKiAtIE5lc3RlZCB0ZW1wbGF0ZSBjb250ZW50IGNhY2hpbmcvcmVtb3ZhbCBhbmQgcmUtaW5zdGFsbGF0aW9uIChwZXJmb3JtYW5jZVxuICAgKiAgIG9wdGltaXphdGlvbilcbiAgICpcbiAgICogQG1peGluRnVuY3Rpb25cbiAgICogQHBvbHltZXJcbiAgICogQG1lbWJlcm9mIFBvbHltZXJcbiAgICogQHN1bW1hcnkgRWxlbWVudCBjbGFzcyBtaXhpbiB0aGF0IHByb3ZpZGVzIGJhc2ljIHRlbXBsYXRlIHBhcnNpbmcgYW5kIHN0YW1waW5nXG4gICAqL1xuICBQb2x5bWVyLlRlbXBsYXRlU3RhbXAgPSBQb2x5bWVyLmRlZHVwaW5nTWl4aW4oc3VwZXJDbGFzcyA9PiB7XG5cbiAgICAvKipcbiAgICAgKiBAcG9seW1lclxuICAgICAqIEBtaXhpbkNsYXNzXG4gICAgICogQGltcGxlbWVudHMge1BvbHltZXJfVGVtcGxhdGVTdGFtcH1cbiAgICAgKi9cbiAgICBjbGFzcyBUZW1wbGF0ZVN0YW1wIGV4dGVuZHMgc3VwZXJDbGFzcyB7XG5cbiAgICAgIC8qKlxuICAgICAgICogU2NhbnMgYSB0ZW1wbGF0ZSB0byBwcm9kdWNlIHRlbXBsYXRlIG1ldGFkYXRhLlxuICAgICAgICpcbiAgICAgICAqIFRlbXBsYXRlLXNwZWNpZmljIG1ldGFkYXRhIGFyZSBzdG9yZWQgaW4gdGhlIG9iamVjdCByZXR1cm5lZCwgYW5kIG5vZGUtXG4gICAgICAgKiBzcGVjaWZpYyBtZXRhZGF0YSBhcmUgc3RvcmVkIGluIG9iamVjdHMgaW4gaXRzIGZsYXR0ZW5lZCBgbm9kZUluZm9MaXN0YFxuICAgICAgICogYXJyYXkuICBPbmx5IG5vZGVzIGluIHRoZSB0ZW1wbGF0ZSB0aGF0IHdlcmUgcGFyc2VkIGFzIG5vZGVzIG9mXG4gICAgICAgKiBpbnRlcmVzdCBjb250YWluIGFuIG9iamVjdCBpbiBgbm9kZUluZm9MaXN0YC4gIEVhY2ggYG5vZGVJbmZvYCBvYmplY3RcbiAgICAgICAqIGNvbnRhaW5zIGFuIGBpbmRleGAgKGBjaGlsZE5vZGVzYCBpbmRleCBpbiBwYXJlbnQpIGFuZCBvcHRpb25hbGx5XG4gICAgICAgKiBgcGFyZW50YCwgd2hpY2ggcG9pbnRzIHRvIG5vZGUgaW5mbyBvZiBpdHMgcGFyZW50IChpbmNsdWRpbmcgaXRzIGluZGV4KS5cbiAgICAgICAqXG4gICAgICAgKiBUaGUgdGVtcGxhdGUgbWV0YWRhdGEgb2JqZWN0IHJldHVybmVkIGZyb20gdGhpcyBtZXRob2QgaGFzIHRoZSBmb2xsb3dpbmdcbiAgICAgICAqIHN0cnVjdHVyZSAobWFueSBmaWVsZHMgb3B0aW9uYWwpOlxuICAgICAgICpcbiAgICAgICAqIGBgYGpzXG4gICAgICAgKiAgIHtcbiAgICAgICAqICAgICAvLyBGbGF0dGVuZWQgbGlzdCBvZiBub2RlIG1ldGFkYXRhIChmb3Igbm9kZXMgdGhhdCBnZW5lcmF0ZWQgbWV0YWRhdGEpXG4gICAgICAgKiAgICAgbm9kZUluZm9MaXN0OiBbXG4gICAgICAgKiAgICAgICB7XG4gICAgICAgKiAgICAgICAgIC8vIGBpZGAgYXR0cmlidXRlIGZvciBhbnkgbm9kZXMgd2l0aCBpZCdzIGZvciBnZW5lcmF0aW5nIGAkYCBtYXBcbiAgICAgICAqICAgICAgICAgaWQ6IHtzdHJpbmd9LFxuICAgICAgICogICAgICAgICAvLyBgb24tZXZlbnQ9XCJoYW5kbGVyXCJgIG1ldGFkYXRhXG4gICAgICAgKiAgICAgICAgIGV2ZW50czogW1xuICAgICAgICogICAgICAgICAgIHtcbiAgICAgICAqICAgICAgICAgICAgIG5hbWU6IHtzdHJpbmd9LCAgIC8vIGV2ZW50IG5hbWVcbiAgICAgICAqICAgICAgICAgICAgIHZhbHVlOiB7c3RyaW5nfSwgIC8vIGhhbmRsZXIgbWV0aG9kIG5hbWVcbiAgICAgICAqICAgICAgICAgICB9LCAuLi5cbiAgICAgICAqICAgICAgICAgXSxcbiAgICAgICAqICAgICAgICAgLy8gTm90ZXMgd2hlbiB0aGUgdGVtcGxhdGUgY29udGFpbmVkIGEgYDxzbG90PmAgZm9yIHNoYWR5IERPTVxuICAgICAgICogICAgICAgICAvLyBvcHRpbWl6YXRpb24gcHVycG9zZXNcbiAgICAgICAqICAgICAgICAgaGFzSW5zZXJ0aW9uUG9pbnQ6IHtib29sZWFufSxcbiAgICAgICAqICAgICAgICAgLy8gRm9yIG5lc3RlZCBgPHRlbXBsYXRlPmBgIG5vZGVzLCBuZXN0ZWQgdGVtcGxhdGUgbWV0YWRhdGFcbiAgICAgICAqICAgICAgICAgdGVtcGxhdGVJbmZvOiB7b2JqZWN0fSwgLy8gbmVzdGVkIHRlbXBsYXRlIG1ldGFkYXRhXG4gICAgICAgKiAgICAgICAgIC8vIE1ldGFkYXRhIHRvIGFsbG93IGVmZmljaWVudCByZXRyaWV2YWwgb2YgaW5zdGFuY2VkIG5vZGVcbiAgICAgICAqICAgICAgICAgLy8gY29ycmVzcG9uZGluZyB0byB0aGlzIG1ldGFkYXRhXG4gICAgICAgKiAgICAgICAgIHBhcmVudEluZm86IHtudW1iZXJ9LCAgIC8vIHJlZmVyZW5jZSB0byBwYXJlbnQgbm9kZUluZm8+XG4gICAgICAgKiAgICAgICAgIHBhcmVudEluZGV4OiB7bnVtYmVyfSwgIC8vIGluZGV4IGluIHBhcmVudCdzIGBjaGlsZE5vZGVzYCBjb2xsZWN0aW9uXG4gICAgICAgKiAgICAgICAgIGluZm9JbmRleDoge251bWJlcn0sICAgIC8vIGluZGV4IG9mIHRoaXMgYG5vZGVJbmZvYCBpbiBgdGVtcGxhdGVJbmZvLm5vZGVJbmZvTGlzdGBcbiAgICAgICAqICAgICAgIH0sXG4gICAgICAgKiAgICAgICAuLi5cbiAgICAgICAqICAgICBdLFxuICAgICAgICogICAgIC8vIFdoZW4gdHJ1ZSwgdGhlIHRlbXBsYXRlIGhhZCB0aGUgYHN0cmlwLXdoaXRlc3BhY2VgIGF0dHJpYnV0ZVxuICAgICAgICogICAgIC8vIG9yIHdhcyBuZXN0ZWQgaW4gYSB0ZW1wbGF0ZSB3aXRoIHRoYXQgc2V0dGluZ1xuICAgICAgICogICAgIHN0cmlwV2hpdGVzcGFjZToge2Jvb2xlYW59LFxuICAgICAgICogICAgIC8vIEZvciBuZXN0ZWQgdGVtcGxhdGVzLCBuZXN0ZWQgdGVtcGxhdGUgY29udGVudCBpcyBtb3ZlZCBpbnRvXG4gICAgICAgKiAgICAgLy8gYSBkb2N1bWVudCBmcmFnbWVudCBzdG9yZWQgaGVyZTsgdGhpcyBpcyBhbiBvcHRpbWl6YXRpb24gdG9cbiAgICAgICAqICAgICAvLyBhdm9pZCB0aGUgY29zdCBvZiBuZXN0ZWQgdGVtcGxhdGUgY2xvbmluZ1xuICAgICAgICogICAgIGNvbnRlbnQ6IHtEb2N1bWVudEZyYWdtZW50fVxuICAgICAgICogICB9XG4gICAgICAgKiBgYGBcbiAgICAgICAqXG4gICAgICAgKiBUaGlzIG1ldGhvZCBraWNrcyBvZmYgYSByZWN1cnNpdmUgdHJlZXdhbGsgYXMgZm9sbG93czpcbiAgICAgICAqXG4gICAgICAgKiBgYGBcbiAgICAgICAqICAgIF9wYXJzZVRlbXBsYXRlIDwtLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgKiAgICAgIF9wYXJzZVRlbXBsYXRlQ29udGVudCAgICAgICAgICAgICAgfFxuICAgICAgICogICAgICAgIF9wYXJzZVRlbXBsYXRlTm9kZSAgPC0tLS0tLS0tLS0tLXwtLStcbiAgICAgICAqICAgICAgICAgIF9wYXJzZVRlbXBsYXRlTmVzdGVkVGVtcGxhdGUgLS0rICB8XG4gICAgICAgKiAgICAgICAgICBfcGFyc2VUZW1wbGF0ZUNoaWxkTm9kZXMgLS0tLS0tLS0tK1xuICAgICAgICogICAgICAgICAgX3BhcnNlVGVtcGxhdGVOb2RlQXR0cmlidXRlc1xuICAgICAgICogICAgICAgICAgICBfcGFyc2VUZW1wbGF0ZU5vZGVBdHRyaWJ1dGVcbiAgICAgICAqXG4gICAgICAgKiBgYGBcbiAgICAgICAqXG4gICAgICAgKiBUaGVzZSBtZXRob2RzIG1heSBiZSBvdmVycmlkZGVuIHRvIGFkZCBjdXN0b20gbWV0YWRhdGEgYWJvdXQgdGVtcGxhdGVzXG4gICAgICAgKiB0byBlaXRoZXIgYHRlbXBsYXRlSW5mb2Agb3IgYG5vZGVJbmZvYC5cbiAgICAgICAqXG4gICAgICAgKiBOb3RlIHRoYXQgdGhpcyBtZXRob2QgbWF5IGJlIGRlc3RydWN0aXZlIHRvIHRoZSB0ZW1wbGF0ZSwgaW4gdGhhdFxuICAgICAgICogZS5nLiBldmVudCBhbm5vdGF0aW9ucyBtYXkgYmUgcmVtb3ZlZCBhZnRlciBiZWluZyBub3RlZCBpbiB0aGVcbiAgICAgICAqIHRlbXBsYXRlIG1ldGFkYXRhLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7IUhUTUxUZW1wbGF0ZUVsZW1lbnR9IHRlbXBsYXRlIFRlbXBsYXRlIHRvIHBhcnNlXG4gICAgICAgKiBAcGFyYW0ge1RlbXBsYXRlSW5mbz19IG91dGVyVGVtcGxhdGVJbmZvIFRlbXBsYXRlIG1ldGFkYXRhIGZyb20gdGhlIG91dGVyXG4gICAgICAgKiAgIHRlbXBsYXRlLCBmb3IgcGFyc2luZyBuZXN0ZWQgdGVtcGxhdGVzXG4gICAgICAgKiBAcmV0dXJuIHshVGVtcGxhdGVJbmZvfSBQYXJzZWQgdGVtcGxhdGUgbWV0YWRhdGFcbiAgICAgICAqL1xuICAgICAgc3RhdGljIF9wYXJzZVRlbXBsYXRlKHRlbXBsYXRlLCBvdXRlclRlbXBsYXRlSW5mbykge1xuICAgICAgICAvLyBzaW5jZSBhIHRlbXBsYXRlIG1heSBiZSByZS11c2VkLCBtZW1vLWl6ZSBtZXRhZGF0YVxuICAgICAgICBpZiAoIXRlbXBsYXRlLl90ZW1wbGF0ZUluZm8pIHtcbiAgICAgICAgICBsZXQgdGVtcGxhdGVJbmZvID0gdGVtcGxhdGUuX3RlbXBsYXRlSW5mbyA9IHt9O1xuICAgICAgICAgIHRlbXBsYXRlSW5mby5ub2RlSW5mb0xpc3QgPSBbXTtcbiAgICAgICAgICB0ZW1wbGF0ZUluZm8uc3RyaXBXaGl0ZVNwYWNlID1cbiAgICAgICAgICAgIChvdXRlclRlbXBsYXRlSW5mbyAmJiBvdXRlclRlbXBsYXRlSW5mby5zdHJpcFdoaXRlU3BhY2UpIHx8XG4gICAgICAgICAgICB0ZW1wbGF0ZS5oYXNBdHRyaWJ1dGUoJ3N0cmlwLXdoaXRlc3BhY2UnKTtcbiAgICAgICAgICB0aGlzLl9wYXJzZVRlbXBsYXRlQ29udGVudCh0ZW1wbGF0ZSwgdGVtcGxhdGVJbmZvLCB7cGFyZW50OiBudWxsfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRlbXBsYXRlLl90ZW1wbGF0ZUluZm87XG4gICAgICB9XG5cbiAgICAgIHN0YXRpYyBfcGFyc2VUZW1wbGF0ZUNvbnRlbnQodGVtcGxhdGUsIHRlbXBsYXRlSW5mbywgbm9kZUluZm8pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcnNlVGVtcGxhdGVOb2RlKHRlbXBsYXRlLmNvbnRlbnQsIHRlbXBsYXRlSW5mbywgbm9kZUluZm8pO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFBhcnNlcyB0ZW1wbGF0ZSBub2RlIGFuZCBhZGRzIHRlbXBsYXRlIGFuZCBub2RlIG1ldGFkYXRhIGJhc2VkIG9uXG4gICAgICAgKiB0aGUgY3VycmVudCBub2RlLCBhbmQgaXRzIGBjaGlsZE5vZGVzYCBhbmQgYGF0dHJpYnV0ZXNgLlxuICAgICAgICpcbiAgICAgICAqIFRoaXMgbWV0aG9kIG1heSBiZSBvdmVycmlkZGVuIHRvIGFkZCBjdXN0b20gbm9kZSBvciB0ZW1wbGF0ZSBzcGVjaWZpY1xuICAgICAgICogbWV0YWRhdGEgYmFzZWQgb24gdGhpcyBub2RlLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBOb2RlIHRvIHBhcnNlXG4gICAgICAgKiBAcGFyYW0geyFUZW1wbGF0ZUluZm99IHRlbXBsYXRlSW5mbyBUZW1wbGF0ZSBtZXRhZGF0YSBmb3IgY3VycmVudCB0ZW1wbGF0ZVxuICAgICAgICogQHBhcmFtIHshTm9kZUluZm99IG5vZGVJbmZvIE5vZGUgbWV0YWRhdGEgZm9yIGN1cnJlbnQgdGVtcGxhdGUuXG4gICAgICAgKiBAcmV0dXJuIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIHZpc2l0ZWQgbm9kZSBhZGRlZCBub2RlLXNwZWNpZmljXG4gICAgICAgKiAgIG1ldGFkYXRhIHRvIGBub2RlSW5mb2BcbiAgICAgICAqL1xuICAgICAgc3RhdGljIF9wYXJzZVRlbXBsYXRlTm9kZShub2RlLCB0ZW1wbGF0ZUluZm8sIG5vZGVJbmZvKSB7XG4gICAgICAgIGxldCBub3RlZDtcbiAgICAgICAgbGV0IGVsZW1lbnQgPSAvKiogQHR5cGUgRWxlbWVudCAqLyhub2RlKTtcbiAgICAgICAgaWYgKGVsZW1lbnQubG9jYWxOYW1lID09ICd0ZW1wbGF0ZScgJiYgIWVsZW1lbnQuaGFzQXR0cmlidXRlKCdwcmVzZXJ2ZS1jb250ZW50JykpIHtcbiAgICAgICAgICBub3RlZCA9IHRoaXMuX3BhcnNlVGVtcGxhdGVOZXN0ZWRUZW1wbGF0ZShlbGVtZW50LCB0ZW1wbGF0ZUluZm8sIG5vZGVJbmZvKSB8fCBub3RlZDtcbiAgICAgICAgfSBlbHNlIGlmIChlbGVtZW50LmxvY2FsTmFtZSA9PT0gJ3Nsb3QnKSB7XG4gICAgICAgICAgLy8gRm9yIFNoYWR5RG9tIG9wdGltaXphdGlvbiwgaW5kaWNhdGluZyB0aGVyZSBpcyBhbiBpbnNlcnRpb24gcG9pbnRcbiAgICAgICAgICB0ZW1wbGF0ZUluZm8uaGFzSW5zZXJ0aW9uUG9pbnQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbGVtZW50LmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICBub3RlZCA9IHRoaXMuX3BhcnNlVGVtcGxhdGVDaGlsZE5vZGVzKGVsZW1lbnQsIHRlbXBsYXRlSW5mbywgbm9kZUluZm8pIHx8IG5vdGVkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbGVtZW50Lmhhc0F0dHJpYnV0ZXMgJiYgZWxlbWVudC5oYXNBdHRyaWJ1dGVzKCkpIHtcbiAgICAgICAgICBub3RlZCA9IHRoaXMuX3BhcnNlVGVtcGxhdGVOb2RlQXR0cmlidXRlcyhlbGVtZW50LCB0ZW1wbGF0ZUluZm8sIG5vZGVJbmZvKSB8fCBub3RlZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm90ZWQ7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUGFyc2VzIHRlbXBsYXRlIGNoaWxkIG5vZGVzIGZvciB0aGUgZ2l2ZW4gcm9vdCBub2RlLlxuICAgICAgICpcbiAgICAgICAqIFRoaXMgbWV0aG9kIGFsc28gd3JhcHMgd2hpdGVsaXN0ZWQgbGVnYWN5IHRlbXBsYXRlIGV4dGVuc2lvbnNcbiAgICAgICAqIChgaXM9XCJkb20taWZcImAgYW5kIGBpcz1cImRvbS1yZXBlYXRcImApIHdpdGggdGhlaXIgZXF1aXZhbGVudCBlbGVtZW50XG4gICAgICAgKiB3cmFwcGVycywgY29sbGFwc2VzIHRleHQgbm9kZXMsIGFuZCBzdHJpcHMgd2hpdGVzcGFjZSBmcm9tIHRoZSB0ZW1wbGF0ZVxuICAgICAgICogaWYgdGhlIGB0ZW1wbGF0ZUluZm8uc3RyaXBXaGl0ZXNwYWNlYCBzZXR0aW5nIHdhcyBwcm92aWRlZC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge05vZGV9IHJvb3QgUm9vdCBub2RlIHdob3NlIGBjaGlsZE5vZGVzYCB3aWxsIGJlIHBhcnNlZFxuICAgICAgICogQHBhcmFtIHshVGVtcGxhdGVJbmZvfSB0ZW1wbGF0ZUluZm8gVGVtcGxhdGUgbWV0YWRhdGEgZm9yIGN1cnJlbnQgdGVtcGxhdGVcbiAgICAgICAqIEBwYXJhbSB7IU5vZGVJbmZvfSBub2RlSW5mbyBOb2RlIG1ldGFkYXRhIGZvciBjdXJyZW50IHRlbXBsYXRlLlxuICAgICAgICovXG4gICAgICBzdGF0aWMgX3BhcnNlVGVtcGxhdGVDaGlsZE5vZGVzKHJvb3QsIHRlbXBsYXRlSW5mbywgbm9kZUluZm8pIHtcbiAgICAgICAgZm9yIChsZXQgbm9kZT1yb290LmZpcnN0Q2hpbGQsIHBhcmVudEluZGV4PTAsIG5leHQ7IG5vZGU7IG5vZGU9bmV4dCkge1xuICAgICAgICAgIC8vIFdyYXAgdGVtcGxhdGVzXG4gICAgICAgICAgaWYgKG5vZGUubG9jYWxOYW1lID09ICd0ZW1wbGF0ZScpIHtcbiAgICAgICAgICAgIG5vZGUgPSB3cmFwVGVtcGxhdGVFeHRlbnNpb24obm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGNvbGxhcHNlIGFkamFjZW50IHRleHROb2RlczogZml4ZXMgYW4gSUUgaXNzdWUgdGhhdCBjYW4gY2F1c2VcbiAgICAgICAgICAvLyB0ZXh0IG5vZGVzIHRvIGJlIGluZXhwbGljYWJseSBzcGxpdCA9KFxuICAgICAgICAgIC8vIG5vdGUgdGhhdCByb290Lm5vcm1hbGl6ZSgpIHNob3VsZCB3b3JrIGJ1dCBkb2VzIG5vdCBzbyB3ZSBkbyB0aGlzXG4gICAgICAgICAgLy8gbWFudWFsbHkuXG4gICAgICAgICAgbmV4dCA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFKSB7XG4gICAgICAgICAgICBsZXQgLyoqIE5vZGUgKi8gbiA9IG5leHQ7XG4gICAgICAgICAgICB3aGlsZSAobiAmJiAobi5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUpKSB7XG4gICAgICAgICAgICAgIG5vZGUudGV4dENvbnRlbnQgKz0gbi50ZXh0Q29udGVudDtcbiAgICAgICAgICAgICAgbmV4dCA9IG4ubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgIHJvb3QucmVtb3ZlQ2hpbGQobik7XG4gICAgICAgICAgICAgIG4gPSBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gb3B0aW9uYWxseSBzdHJpcCB3aGl0ZXNwYWNlXG4gICAgICAgICAgICBpZiAodGVtcGxhdGVJbmZvLnN0cmlwV2hpdGVTcGFjZSAmJiAhbm9kZS50ZXh0Q29udGVudC50cmltKCkpIHtcbiAgICAgICAgICAgICAgcm9vdC5yZW1vdmVDaGlsZChub2RlKTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCBjaGlsZEluZm8gPSB7IHBhcmVudEluZGV4LCBwYXJlbnRJbmZvOiBub2RlSW5mbyB9O1xuICAgICAgICAgIGlmICh0aGlzLl9wYXJzZVRlbXBsYXRlTm9kZShub2RlLCB0ZW1wbGF0ZUluZm8sIGNoaWxkSW5mbykpIHtcbiAgICAgICAgICAgIGNoaWxkSW5mby5pbmZvSW5kZXggPSB0ZW1wbGF0ZUluZm8ubm9kZUluZm9MaXN0LnB1c2goLyoqIEB0eXBlIHshTm9kZUluZm99ICovKGNoaWxkSW5mbykpIC0gMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gSW5jcmVtZW50IGlmIG5vdCByZW1vdmVkXG4gICAgICAgICAgaWYgKG5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgcGFyZW50SW5kZXgrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBQYXJzZXMgdGVtcGxhdGUgY29udGVudCBmb3IgdGhlIGdpdmVuIG5lc3RlZCBgPHRlbXBsYXRlPmAuXG4gICAgICAgKlxuICAgICAgICogTmVzdGVkIHRlbXBsYXRlIGluZm8gaXMgc3RvcmVkIGFzIGB0ZW1wbGF0ZUluZm9gIGluIHRoZSBjdXJyZW50IG5vZGUnc1xuICAgICAgICogYG5vZGVJbmZvYC4gYHRlbXBsYXRlLmNvbnRlbnRgIGlzIHJlbW92ZWQgYW5kIHN0b3JlZCBpbiBgdGVtcGxhdGVJbmZvYC5cbiAgICAgICAqIEl0IHdpbGwgdGhlbiBiZSB0aGUgcmVzcG9uc2liaWxpdHkgb2YgdGhlIGhvc3QgdG8gc2V0IGl0IGJhY2sgdG8gdGhlXG4gICAgICAgKiB0ZW1wbGF0ZSBhbmQgZm9yIHVzZXJzIHN0YW1waW5nIG5lc3RlZCB0ZW1wbGF0ZXMgdG8gdXNlIHRoZVxuICAgICAgICogYF9jb250ZW50Rm9yVGVtcGxhdGVgIG1ldGhvZCB0byByZXRyaWV2ZSB0aGUgY29udGVudCBmb3IgdGhpcyB0ZW1wbGF0ZVxuICAgICAgICogKGFuIG9wdGltaXphdGlvbiB0byBhdm9pZCB0aGUgY29zdCBvZiBjbG9uaW5nIG5lc3RlZCB0ZW1wbGF0ZSBjb250ZW50KS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge0hUTUxUZW1wbGF0ZUVsZW1lbnR9IG5vZGUgTm9kZSB0byBwYXJzZSAoYSA8dGVtcGxhdGU+KVxuICAgICAgICogQHBhcmFtIHtUZW1wbGF0ZUluZm99IG91dGVyVGVtcGxhdGVJbmZvIFRlbXBsYXRlIG1ldGFkYXRhIGZvciBjdXJyZW50IHRlbXBsYXRlXG4gICAgICAgKiAgIHRoYXQgaW5jbHVkZXMgdGhlIHRlbXBsYXRlIGBub2RlYFxuICAgICAgICogQHBhcmFtIHshTm9kZUluZm99IG5vZGVJbmZvIE5vZGUgbWV0YWRhdGEgZm9yIGN1cnJlbnQgdGVtcGxhdGUuXG4gICAgICAgKiBAcmV0dXJuIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIHZpc2l0ZWQgbm9kZSBhZGRlZCBub2RlLXNwZWNpZmljXG4gICAgICAgKiAgIG1ldGFkYXRhIHRvIGBub2RlSW5mb2BcbiAgICAgICAqL1xuICAgICAgc3RhdGljIF9wYXJzZVRlbXBsYXRlTmVzdGVkVGVtcGxhdGUobm9kZSwgb3V0ZXJUZW1wbGF0ZUluZm8sIG5vZGVJbmZvKSB7XG4gICAgICAgIGxldCB0ZW1wbGF0ZUluZm8gPSB0aGlzLl9wYXJzZVRlbXBsYXRlKG5vZGUsIG91dGVyVGVtcGxhdGVJbmZvKTtcbiAgICAgICAgbGV0IGNvbnRlbnQgPSB0ZW1wbGF0ZUluZm8uY29udGVudCA9XG4gICAgICAgICAgbm9kZS5jb250ZW50Lm93bmVyRG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgICAgICBjb250ZW50LmFwcGVuZENoaWxkKG5vZGUuY29udGVudCk7XG4gICAgICAgIG5vZGVJbmZvLnRlbXBsYXRlSW5mbyA9IHRlbXBsYXRlSW5mbztcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUGFyc2VzIHRlbXBsYXRlIG5vZGUgYXR0cmlidXRlcyBhbmQgYWRkcyBub2RlIG1ldGFkYXRhIHRvIGBub2RlSW5mb2BcbiAgICAgICAqIGZvciBub2RlcyBvZiBpbnRlcmVzdC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgTm9kZSB0byBwYXJzZVxuICAgICAgICogQHBhcmFtIHtUZW1wbGF0ZUluZm99IHRlbXBsYXRlSW5mbyBUZW1wbGF0ZSBtZXRhZGF0YSBmb3IgY3VycmVudCB0ZW1wbGF0ZVxuICAgICAgICogQHBhcmFtIHtOb2RlSW5mb30gbm9kZUluZm8gTm9kZSBtZXRhZGF0YSBmb3IgY3VycmVudCB0ZW1wbGF0ZS5cbiAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgdmlzaXRlZCBub2RlIGFkZGVkIG5vZGUtc3BlY2lmaWNcbiAgICAgICAqICAgbWV0YWRhdGEgdG8gYG5vZGVJbmZvYFxuICAgICAgICovXG4gICAgICBzdGF0aWMgX3BhcnNlVGVtcGxhdGVOb2RlQXR0cmlidXRlcyhub2RlLCB0ZW1wbGF0ZUluZm8sIG5vZGVJbmZvKSB7XG4gICAgICAgIC8vIE1ha2UgY29weSBvZiBvcmlnaW5hbCBhdHRyaWJ1dGUgbGlzdCwgc2luY2UgdGhlIG9yZGVyIG1heSBjaGFuZ2VcbiAgICAgICAgLy8gYXMgYXR0cmlidXRlcyBhcmUgYWRkZWQgYW5kIHJlbW92ZWRcbiAgICAgICAgbGV0IG5vdGVkID0gZmFsc2U7XG4gICAgICAgIGxldCBhdHRycyA9IEFycmF5LmZyb20obm9kZS5hdHRyaWJ1dGVzKTtcbiAgICAgICAgZm9yIChsZXQgaT1hdHRycy5sZW5ndGgtMSwgYTsgKGE9YXR0cnNbaV0pOyBpLS0pIHtcbiAgICAgICAgICBub3RlZCA9IHRoaXMuX3BhcnNlVGVtcGxhdGVOb2RlQXR0cmlidXRlKG5vZGUsIHRlbXBsYXRlSW5mbywgbm9kZUluZm8sIGEubmFtZSwgYS52YWx1ZSkgfHwgbm90ZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vdGVkO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFBhcnNlcyBhIHNpbmdsZSB0ZW1wbGF0ZSBub2RlIGF0dHJpYnV0ZSBhbmQgYWRkcyBub2RlIG1ldGFkYXRhIHRvXG4gICAgICAgKiBgbm9kZUluZm9gIGZvciBhdHRyaWJ1dGVzIG9mIGludGVyZXN0LlxuICAgICAgICpcbiAgICAgICAqIFRoaXMgaW1wbGVtZW50YXRpb24gYWRkcyBtZXRhZGF0YSBmb3IgYG9uLWV2ZW50PVwiaGFuZGxlclwiYCBhdHRyaWJ1dGVzXG4gICAgICAgKiBhbmQgYGlkYCBhdHRyaWJ1dGVzLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZSBOb2RlIHRvIHBhcnNlXG4gICAgICAgKiBAcGFyYW0geyFUZW1wbGF0ZUluZm99IHRlbXBsYXRlSW5mbyBUZW1wbGF0ZSBtZXRhZGF0YSBmb3IgY3VycmVudCB0ZW1wbGF0ZVxuICAgICAgICogQHBhcmFtIHshTm9kZUluZm99IG5vZGVJbmZvIE5vZGUgbWV0YWRhdGEgZm9yIGN1cnJlbnQgdGVtcGxhdGUuXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBBdHRyaWJ1dGUgbmFtZVxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIEF0dHJpYnV0ZSB2YWx1ZVxuICAgICAgICogQHJldHVybiB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSB2aXNpdGVkIG5vZGUgYWRkZWQgbm9kZS1zcGVjaWZpY1xuICAgICAgICogICBtZXRhZGF0YSB0byBgbm9kZUluZm9gXG4gICAgICAgKi9cbiAgICAgIHN0YXRpYyBfcGFyc2VUZW1wbGF0ZU5vZGVBdHRyaWJ1dGUobm9kZSwgdGVtcGxhdGVJbmZvLCBub2RlSW5mbywgbmFtZSwgdmFsdWUpIHtcbiAgICAgICAgLy8gZXZlbnRzIChvbi0qKVxuICAgICAgICBpZiAobmFtZS5zbGljZSgwLCAzKSA9PT0gJ29uLScpIHtcbiAgICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICAgICAgICBub2RlSW5mby5ldmVudHMgPSBub2RlSW5mby5ldmVudHMgfHwgW107XG4gICAgICAgICAgbm9kZUluZm8uZXZlbnRzLnB1c2goe1xuICAgICAgICAgICAgbmFtZTogbmFtZS5zbGljZSgzKSxcbiAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc3RhdGljIGlkXG4gICAgICAgIGVsc2UgaWYgKG5hbWUgPT09ICdpZCcpIHtcbiAgICAgICAgICBub2RlSW5mby5pZCA9IHZhbHVlO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZXR1cm5zIHRoZSBgY29udGVudGAgZG9jdW1lbnQgZnJhZ21lbnQgZm9yIGEgZ2l2ZW4gdGVtcGxhdGUuXG4gICAgICAgKlxuICAgICAgICogRm9yIG5lc3RlZCB0ZW1wbGF0ZXMsIFBvbHltZXIgcGVyZm9ybXMgYW4gb3B0aW1pemF0aW9uIHRvIGNhY2hlIG5lc3RlZFxuICAgICAgICogdGVtcGxhdGUgY29udGVudCB0byBhdm9pZCB0aGUgY29zdCBvZiBjbG9uaW5nIGRlZXBseSBuZXN0ZWQgdGVtcGxhdGVzLlxuICAgICAgICogVGhpcyBtZXRob2QgcmV0cmlldmVzIHRoZSBjYWNoZWQgY29udGVudCBmb3IgYSBnaXZlbiB0ZW1wbGF0ZS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge0hUTUxUZW1wbGF0ZUVsZW1lbnR9IHRlbXBsYXRlIFRlbXBsYXRlIHRvIHJldHJpZXZlIGBjb250ZW50YCBmb3JcbiAgICAgICAqIEByZXR1cm4ge0RvY3VtZW50RnJhZ21lbnR9IENvbnRlbnQgZnJhZ21lbnRcbiAgICAgICAqL1xuICAgICAgc3RhdGljIF9jb250ZW50Rm9yVGVtcGxhdGUodGVtcGxhdGUpIHtcbiAgICAgICAgbGV0IHRlbXBsYXRlSW5mbyA9IC8qKiBAdHlwZSB7SFRNTFRlbXBsYXRlRWxlbWVudFdpdGhJbmZvfSAqLyAodGVtcGxhdGUpLl90ZW1wbGF0ZUluZm87XG4gICAgICAgIHJldHVybiAodGVtcGxhdGVJbmZvICYmIHRlbXBsYXRlSW5mby5jb250ZW50KSB8fCB0ZW1wbGF0ZS5jb250ZW50O1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENsb25lcyB0aGUgcHJvdmlkZWQgdGVtcGxhdGUgY29udGVudCBhbmQgcmV0dXJucyBhIGRvY3VtZW50IGZyYWdtZW50XG4gICAgICAgKiBjb250YWluaW5nIHRoZSBjbG9uZWQgZG9tLlxuICAgICAgICpcbiAgICAgICAqIFRoZSB0ZW1wbGF0ZSBpcyBwYXJzZWQgKG9uY2UgYW5kIG1lbW9pemVkKSB1c2luZyB0aGlzIGxpYnJhcnknc1xuICAgICAgICogdGVtcGxhdGUgcGFyc2luZyBmZWF0dXJlcywgYW5kIHByb3ZpZGVzIHRoZSBmb2xsb3dpbmcgdmFsdWUtYWRkZWRcbiAgICAgICAqIGZlYXR1cmVzOlxuICAgICAgICogKiBBZGRzIGRlY2xhcmF0aXZlIGV2ZW50IGxpc3RlbmVycyBmb3IgYG9uLWV2ZW50PVwiaGFuZGxlclwiYCBhdHRyaWJ1dGVzXG4gICAgICAgKiAqIEdlbmVyYXRlcyBhbiBcImlkIG1hcFwiIGZvciBhbGwgbm9kZXMgd2l0aCBpZCdzIHVuZGVyIGAkYCBvbiByZXR1cm5lZFxuICAgICAgICogICBkb2N1bWVudCBmcmFnbWVudFxuICAgICAgICogKiBQYXNzZXMgdGVtcGxhdGUgaW5mbyBpbmNsdWRpbmcgYGNvbnRlbnRgIGJhY2sgdG8gdGVtcGxhdGVzIGFzXG4gICAgICAgKiAgIGBfdGVtcGxhdGVJbmZvYCAoYSBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb24gdG8gYXZvaWQgZGVlcCB0ZW1wbGF0ZVxuICAgICAgICogICBjbG9uaW5nKVxuICAgICAgICpcbiAgICAgICAqIE5vdGUgdGhhdCB0aGUgbWVtb2l6ZWQgdGVtcGxhdGUgcGFyc2luZyBwcm9jZXNzIGlzIGRlc3RydWN0aXZlIHRvIHRoZVxuICAgICAgICogdGVtcGxhdGU6IGF0dHJpYnV0ZXMgZm9yIGJpbmRpbmdzIGFuZCBkZWNsYXJhdGl2ZSBldmVudCBsaXN0ZW5lcnMgYXJlXG4gICAgICAgKiByZW1vdmVkIGFmdGVyIGJlaW5nIG5vdGVkIGluIG5vdGVzLCBhbmQgYW55IG5lc3RlZCBgPHRlbXBsYXRlPi5jb250ZW50YFxuICAgICAgICogaXMgcmVtb3ZlZCBhbmQgc3RvcmVkIGluIG5vdGVzIGFzIHdlbGwuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHshSFRNTFRlbXBsYXRlRWxlbWVudH0gdGVtcGxhdGUgVGVtcGxhdGUgdG8gc3RhbXBcbiAgICAgICAqIEByZXR1cm4geyFTdGFtcGVkVGVtcGxhdGV9IENsb25lZCB0ZW1wbGF0ZSBjb250ZW50XG4gICAgICAgKi9cbiAgICAgIF9zdGFtcFRlbXBsYXRlKHRlbXBsYXRlKSB7XG4gICAgICAgIC8vIFBvbHlmaWxsIHN1cHBvcnQ6IGJvb3RzdHJhcCB0aGUgdGVtcGxhdGUgaWYgaXQgaGFzIG5vdCBhbHJlYWR5IGJlZW5cbiAgICAgICAgaWYgKHRlbXBsYXRlICYmICF0ZW1wbGF0ZS5jb250ZW50ICYmXG4gICAgICAgICAgICB3aW5kb3cuSFRNTFRlbXBsYXRlRWxlbWVudCAmJiBIVE1MVGVtcGxhdGVFbGVtZW50LmRlY29yYXRlKSB7XG4gICAgICAgICAgSFRNTFRlbXBsYXRlRWxlbWVudC5kZWNvcmF0ZSh0ZW1wbGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRlbXBsYXRlSW5mbyA9IHRoaXMuY29uc3RydWN0b3IuX3BhcnNlVGVtcGxhdGUodGVtcGxhdGUpO1xuICAgICAgICBsZXQgbm9kZUluZm8gPSB0ZW1wbGF0ZUluZm8ubm9kZUluZm9MaXN0O1xuICAgICAgICBsZXQgY29udGVudCA9IHRlbXBsYXRlSW5mby5jb250ZW50IHx8IHRlbXBsYXRlLmNvbnRlbnQ7XG4gICAgICAgIGxldCBkb20gPSAvKiogQHR5cGUgRG9jdW1lbnRGcmFnbWVudCAqLyAoZG9jdW1lbnQuaW1wb3J0Tm9kZShjb250ZW50LCB0cnVlKSk7XG4gICAgICAgIC8vIE5PVEU6IFNoYWR5RG9tIG9wdGltaXphdGlvbiBpbmRpY2F0aW5nIHRoZXJlIGlzIGFuIGluc2VydGlvbiBwb2ludFxuICAgICAgICBkb20uX19ub0luc2VydGlvblBvaW50ID0gIXRlbXBsYXRlSW5mby5oYXNJbnNlcnRpb25Qb2ludDtcbiAgICAgICAgbGV0IG5vZGVzID0gZG9tLm5vZGVMaXN0ID0gbmV3IEFycmF5KG5vZGVJbmZvLmxlbmd0aCk7XG4gICAgICAgIGRvbS4kID0ge307XG4gICAgICAgIGZvciAobGV0IGk9MCwgbD1ub2RlSW5mby5sZW5ndGgsIGluZm87IChpPGwpICYmIChpbmZvPW5vZGVJbmZvW2ldKTsgaSsrKSB7XG4gICAgICAgICAgbGV0IG5vZGUgPSBub2Rlc1tpXSA9IGZpbmRUZW1wbGF0ZU5vZGUoZG9tLCBpbmZvKTtcbiAgICAgICAgICBhcHBseUlkVG9NYXAodGhpcywgZG9tLiQsIG5vZGUsIGluZm8pO1xuICAgICAgICAgIGFwcGx5VGVtcGxhdGVDb250ZW50KHRoaXMsIG5vZGUsIGluZm8pO1xuICAgICAgICAgIGFwcGx5RXZlbnRMaXN0ZW5lcih0aGlzLCBub2RlLCBpbmZvKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLyoqIEB0eXBlIHshU3RhbXBlZFRlbXBsYXRlfSAqLyhkb20pO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEFkZHMgYW4gZXZlbnQgbGlzdGVuZXIgYnkgbWV0aG9kIG5hbWUgZm9yIHRoZSBldmVudCBwcm92aWRlZC5cbiAgICAgICAqXG4gICAgICAgKiBUaGlzIG1ldGhvZCBnZW5lcmF0ZXMgYSBoYW5kbGVyIGZ1bmN0aW9uIHRoYXQgbG9va3MgdXAgdGhlIG1ldGhvZFxuICAgICAgICogbmFtZSBhdCBoYW5kbGluZyB0aW1lLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBOb2RlIHRvIGFkZCBsaXN0ZW5lciBvblxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBOYW1lIG9mIGV2ZW50XG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kTmFtZSBOYW1lIG9mIG1ldGhvZFxuICAgICAgICogQHBhcmFtIHsqPX0gY29udGV4dCBDb250ZXh0IHRoZSBtZXRob2Qgd2lsbCBiZSBjYWxsZWQgb24gKGRlZmF1bHRzXG4gICAgICAgKiAgIHRvIGBub2RlYClcbiAgICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBHZW5lcmF0ZWQgaGFuZGxlciBmdW5jdGlvblxuICAgICAgICovXG4gICAgICBfYWRkTWV0aG9kRXZlbnRMaXN0ZW5lclRvTm9kZShub2RlLCBldmVudE5hbWUsIG1ldGhvZE5hbWUsIGNvbnRleHQpIHtcbiAgICAgICAgY29udGV4dCA9IGNvbnRleHQgfHwgbm9kZTtcbiAgICAgICAgbGV0IGhhbmRsZXIgPSBjcmVhdGVOb2RlRXZlbnRIYW5kbGVyKGNvbnRleHQsIGV2ZW50TmFtZSwgbWV0aG9kTmFtZSk7XG4gICAgICAgIHRoaXMuX2FkZEV2ZW50TGlzdGVuZXJUb05vZGUobm9kZSwgZXZlbnROYW1lLCBoYW5kbGVyKTtcbiAgICAgICAgcmV0dXJuIGhhbmRsZXI7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogT3ZlcnJpZGUgcG9pbnQgZm9yIGFkZGluZyBjdXN0b20gb3Igc2ltdWxhdGVkIGV2ZW50IGhhbmRsaW5nLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBOb2RlIHRvIGFkZCBldmVudCBsaXN0ZW5lciB0b1xuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBOYW1lIG9mIGV2ZW50XG4gICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIExpc3RlbmVyIGZ1bmN0aW9uIHRvIGFkZFxuICAgICAgICovXG4gICAgICBfYWRkRXZlbnRMaXN0ZW5lclRvTm9kZShub2RlLCBldmVudE5hbWUsIGhhbmRsZXIpIHtcbiAgICAgICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgaGFuZGxlcik7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogT3ZlcnJpZGUgcG9pbnQgZm9yIGFkZGluZyBjdXN0b20gb3Igc2ltdWxhdGVkIGV2ZW50IGhhbmRsaW5nLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBOb2RlIHRvIHJlbW92ZSBldmVudCBsaXN0ZW5lciBmcm9tXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIE5hbWUgb2YgZXZlbnRcbiAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIgTGlzdGVuZXIgZnVuY3Rpb24gdG8gcmVtb3ZlXG4gICAgICAgKi9cbiAgICAgIF9yZW1vdmVFdmVudExpc3RlbmVyRnJvbU5vZGUobm9kZSwgZXZlbnROYW1lLCBoYW5kbGVyKSB7XG4gICAgICAgIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGhhbmRsZXIpO1xuICAgICAgfVxuXG4gICAgfVxuXG4gICAgcmV0dXJuIFRlbXBsYXRlU3RhbXA7XG5cbiAgfSk7XG5cbn0pKCk7XG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvbWl4aW5zL3RlbXBsYXRlLXN0YW1wLmh0bWwiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE1IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi8uLi9wb2x5bWVyL3BvbHltZXIuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uLy4uL2lyb24tZmxleC1sYXlvdXQvaXJvbi1mbGV4LWxheW91dC5odG1sXCI+XG5cbjwhLS1cbmFwcC1kcmF3ZXIgaXMgYSBuYXZpZ2F0aW9uIGRyYXdlciB0aGF0IGNhbiBzbGlkZSBpbiBmcm9tIHRoZSBsZWZ0IG9yIHJpZ2h0LlxuXG5FeGFtcGxlOlxuXG5BbGlnbiB0aGUgZHJhd2VyIGF0IHRoZSBzdGFydCwgd2hpY2ggaXMgbGVmdCBpbiBMVFIgbGF5b3V0cyAoZGVmYXVsdCk6XG5cbmBgYGh0bWxcbjxhcHAtZHJhd2VyIG9wZW5lZD48L2FwcC1kcmF3ZXI+XG5gYGBcblxuQWxpZ24gdGhlIGRyYXdlciBhdCB0aGUgZW5kOlxuXG5gYGBodG1sXG48YXBwLWRyYXdlciBhbGlnbj1cImVuZFwiIG9wZW5lZD48L2FwcC1kcmF3ZXI+XG5gYGBcblxuVG8gbWFrZSB0aGUgY29udGVudHMgb2YgdGhlIGRyYXdlciBzY3JvbGxhYmxlLCBjcmVhdGUgYSB3cmFwcGVyIGZvciB0aGUgc2Nyb2xsXG5jb250ZW50LCBhbmQgYXBwbHkgaGVpZ2h0IGFuZCBvdmVyZmxvdyBzdHlsZXMgdG8gaXQuXG5cbmBgYGh0bWxcbjxhcHAtZHJhd2VyPlxuICA8ZGl2IHN0eWxlPVwiaGVpZ2h0OiAxMDAlOyBvdmVyZmxvdzogYXV0bztcIj48L2Rpdj5cbjwvYXBwLWRyYXdlcj5cbmBgYFxuXG4jIyMgU3R5bGluZ1xuXG5DdXN0b20gcHJvcGVydHkgICAgICAgICAgICAgICAgICB8IERlc2NyaXB0aW9uICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgRGVmYXVsdFxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18LS0tLS0tLS0tLS0tLS0tLS0tLS1cbmAtLWFwcC1kcmF3ZXItd2lkdGhgICAgICAgICAgICAgIHwgV2lkdGggb2YgdGhlIGRyYXdlciAgICAgICAgICAgICAgICAgICAgfCAyNTZweFxuYC0tYXBwLWRyYXdlci1jb250ZW50LWNvbnRhaW5lcmAgfCBNaXhpbiBmb3IgdGhlIGRyYXdlciBjb250ZW50IGNvbnRhaW5lciB8IHt9XG5gLS1hcHAtZHJhd2VyLXNjcmltLWJhY2tncm91bmRgICB8IEJhY2tncm91bmQgZm9yIHRoZSBzY3JpbSAgICAgICAgICAgICAgIHwgcmdiYSgwLCAwLCAwLCAwLjUpXG5cbioqTk9URToqKiBJZiB5b3UgdXNlIDxhcHAtZHJhd2VyPiB3aXRoIDxhcHAtZHJhd2VyLWxheW91dD4gYW5kIHNwZWNpZnkgYSB2YWx1ZSBmb3JcbmAtLWFwcC1kcmF3ZXItd2lkdGhgLCB0aGF0IHZhbHVlIG11c3QgYmUgYWNjZXNzaWJsZSBieSBib3RoIGVsZW1lbnRzLiBUaGlzIGNhbiBiZSBkb25lIGJ5XG5kZWZpbmluZyB0aGUgdmFsdWUgb24gdGhlIGA6aG9zdGAgdGhhdCBjb250YWlucyA8YXBwLWRyYXdlci1sYXlvdXQ+IChvciBgaHRtbGAgaWYgb3V0c2lkZVxuYSBzaGFkb3cgcm9vdCk6XG5cbmBgYGNzc1xuOmhvc3Qge1xuICAtLWFwcC1kcmF3ZXItd2lkdGg6IDMwMHB4O1xufVxuYGBgXG5cbkBncm91cCBBcHAgRWxlbWVudHNcbkBlbGVtZW50IGFwcC1kcmF3ZXJcbkBkZW1vIGFwcC1kcmF3ZXIvZGVtby9sZWZ0LWRyYXdlci5odG1sIFNpbXBsZSBMZWZ0IERyYXdlclxuQGRlbW8gYXBwLWRyYXdlci9kZW1vL3JpZ2h0LWRyYXdlci5odG1sIFJpZ2h0IERyYXdlciB3aXRoIEljb25zXG4tLT5cblxuPGRvbS1tb2R1bGUgaWQ9XCJhcHAtZHJhd2VyXCI+XG4gIDx0ZW1wbGF0ZT5cbiAgICA8c3R5bGU+XG4gICAgICA6aG9zdCB7XG4gICAgICAgIHBvc2l0aW9uOiBmaXhlZDtcbiAgICAgICAgdG9wOiAtMTIwcHg7XG4gICAgICAgIHJpZ2h0OiAwO1xuICAgICAgICBib3R0b206IC0xMjBweDtcbiAgICAgICAgbGVmdDogMDtcblxuICAgICAgICB2aXNpYmlsaXR5OiBoaWRkZW47XG5cbiAgICAgICAgdHJhbnNpdGlvbi1wcm9wZXJ0eTogdmlzaWJpbGl0eTtcbiAgICAgIH1cblxuICAgICAgOmhvc3QoW29wZW5lZF0pIHtcbiAgICAgICAgdmlzaWJpbGl0eTogdmlzaWJsZTtcbiAgICAgIH1cblxuICAgICAgOmhvc3QoW3BlcnNpc3RlbnRdKSB7XG4gICAgICAgIHdpZHRoOiB2YXIoLS1hcHAtZHJhd2VyLXdpZHRoLCAyNTZweCk7XG4gICAgICB9XG5cbiAgICAgIDpob3N0KFtwZXJzaXN0ZW50XVtwb3NpdGlvbj1sZWZ0XSkge1xuICAgICAgICByaWdodDogYXV0bztcbiAgICAgIH1cblxuICAgICAgOmhvc3QoW3BlcnNpc3RlbnRdW3Bvc2l0aW9uPXJpZ2h0XSkge1xuICAgICAgICBsZWZ0OiBhdXRvO1xuICAgICAgfVxuXG4gICAgICAjY29udGVudENvbnRhaW5lciB7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgdG9wOiAwO1xuICAgICAgICBib3R0b206IDA7XG4gICAgICAgIGxlZnQ6IDA7XG5cbiAgICAgICAgd2lkdGg6IHZhcigtLWFwcC1kcmF3ZXItd2lkdGgsIDI1NnB4KTtcbiAgICAgICAgcGFkZGluZzogMTIwcHggMDtcblxuICAgICAgICB0cmFuc2l0aW9uLXByb3BlcnR5OiAtd2Via2l0LXRyYW5zZm9ybTtcbiAgICAgICAgdHJhbnNpdGlvbi1wcm9wZXJ0eTogdHJhbnNmb3JtO1xuICAgICAgICAtd2Via2l0LXRyYW5zZm9ybTogdHJhbnNsYXRlM2QoLTEwMCUsIDAsIDApO1xuICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKC0xMDAlLCAwLCAwKTtcblxuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjRkZGO1xuXG4gICAgICAgIEBhcHBseSAtLWFwcC1kcmF3ZXItY29udGVudC1jb250YWluZXI7XG4gICAgICB9XG5cbiAgICAgICNjb250ZW50Q29udGFpbmVyW3BlcnNpc3RlbnRdIHtcbiAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICB9XG5cbiAgICAgICNjb250ZW50Q29udGFpbmVyW3Bvc2l0aW9uPXJpZ2h0XSB7XG4gICAgICAgIHJpZ2h0OiAwO1xuICAgICAgICBsZWZ0OiBhdXRvO1xuXG4gICAgICAgIC13ZWJraXQtdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgxMDAlLCAwLCAwKTtcbiAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgxMDAlLCAwLCAwKTtcbiAgICAgIH1cblxuICAgICAgI2NvbnRlbnRDb250YWluZXJbc3dpcGUtb3Blbl06OmFmdGVyIHtcbiAgICAgICAgcG9zaXRpb246IGZpeGVkO1xuICAgICAgICB0b3A6IDA7XG4gICAgICAgIGJvdHRvbTogMDtcbiAgICAgICAgbGVmdDogMTAwJTtcblxuICAgICAgICB2aXNpYmlsaXR5OiB2aXNpYmxlO1xuXG4gICAgICAgIHdpZHRoOiAyMHB4O1xuXG4gICAgICAgIGNvbnRlbnQ6ICcnO1xuICAgICAgfVxuXG4gICAgICAjY29udGVudENvbnRhaW5lcltzd2lwZS1vcGVuXVtwb3NpdGlvbj1yaWdodF06OmFmdGVyIHtcbiAgICAgICAgcmlnaHQ6IDEwMCU7XG4gICAgICAgIGxlZnQ6IGF1dG87XG4gICAgICB9XG5cbiAgICAgICNjb250ZW50Q29udGFpbmVyW29wZW5lZF0ge1xuICAgICAgICAtd2Via2l0LXRyYW5zZm9ybTogdHJhbnNsYXRlM2QoMCwgMCwgMCk7XG4gICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoMCwgMCwgMCk7XG4gICAgICB9XG5cbiAgICAgICNzY3JpbSB7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgdG9wOiAwO1xuICAgICAgICByaWdodDogMDtcbiAgICAgICAgYm90dG9tOiAwO1xuICAgICAgICBsZWZ0OiAwO1xuXG4gICAgICAgIHRyYW5zaXRpb24tcHJvcGVydHk6IG9wYWNpdHk7XG4gICAgICAgIC13ZWJraXQtdHJhbnNmb3JtOiB0cmFuc2xhdGVaKDApO1xuICAgICAgICB0cmFuc2Zvcm06ICB0cmFuc2xhdGVaKDApO1xuXG4gICAgICAgIG9wYWNpdHk6IDA7XG4gICAgICAgIGJhY2tncm91bmQ6IHZhcigtLWFwcC1kcmF3ZXItc2NyaW0tYmFja2dyb3VuZCwgcmdiYSgwLCAwLCAwLCAwLjUpKTtcbiAgICAgIH1cblxuICAgICAgI3NjcmltLnZpc2libGUge1xuICAgICAgICBvcGFjaXR5OiAxO1xuICAgICAgfVxuXG4gICAgICA6aG9zdChbbm8tdHJhbnNpdGlvbl0pICNjb250ZW50Q29udGFpbmVyIHtcbiAgICAgICAgdHJhbnNpdGlvbi1wcm9wZXJ0eTogbm9uZTtcbiAgICAgIH1cbiAgICA8L3N0eWxlPlxuXG4gICAgPGRpdiBpZD1cInNjcmltXCIgb24tY2xpY2s9XCJjbG9zZVwiPjwvZGl2PlxuXG4gICAgPCEtLSBIQUNLKGtlYW51bGVlKTogQmluZCBhdHRyaWJ1dGVzIGhlcmUgKGluIGFkZGl0aW9uIHRvIDpob3N0KSBmb3Igc3R5bGluZyB0byB3b3JrYXJvdW5kIFNhZmFyaVxuICAgIGJ1Zy4gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE3MDc2MiAtLT5cbiAgICA8ZGl2IGlkPVwiY29udGVudENvbnRhaW5lclwiIG9wZW5lZCQ9XCJbW29wZW5lZF1dXCIgcGVyc2lzdGVudCQ9XCJbW3BlcnNpc3RlbnRdXVwiXG4gICAgICAgIHBvc2l0aW9uJD1cIltbcG9zaXRpb25dXVwiIHN3aXBlLW9wZW4kPVwiW1tzd2lwZU9wZW5dXVwiPlxuICAgICAgPHNsb3Q+PC9zbG90PlxuICAgIDwvZGl2PlxuICA8L3RlbXBsYXRlPlxuXG4gIDxzY3JpcHQ+XG5cbiAgICBQb2x5bWVyKHtcbiAgICAgIGlzOiAnYXBwLWRyYXdlcicsXG5cbiAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBvcGVuZWQgc3RhdGUgb2YgdGhlIGRyYXdlci5cbiAgICAgICAgICovXG4gICAgICAgIG9wZW5lZDoge1xuICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgICAgdmFsdWU6IGZhbHNlLFxuICAgICAgICAgIG5vdGlmeTogdHJ1ZSxcbiAgICAgICAgICByZWZsZWN0VG9BdHRyaWJ1dGU6IHRydWVcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGRyYXdlciBkb2VzIG5vdCBoYXZlIGEgc2NyaW0gYW5kIGNhbm5vdCBiZSBzd2lwZWQgY2xvc2UuXG4gICAgICAgICAqL1xuICAgICAgICBwZXJzaXN0ZW50OiB7XG4gICAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgICB2YWx1ZTogZmFsc2UsXG4gICAgICAgICAgcmVmbGVjdFRvQXR0cmlidXRlOiB0cnVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0cmFuc2l0aW9uIGR1cmF0aW9uIG9mIHRoZSBkcmF3ZXIgaW4gbWlsbGlzZWNvbmRzLlxuICAgICAgICAgKi9cbiAgICAgICAgdHJhbnNpdGlvbkR1cmF0aW9uOiB7XG4gICAgICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgICAgIHZhbHVlOiAyMDBcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGFsaWdubWVudCBvZiB0aGUgZHJhd2VyIG9uIHRoZSBzY3JlZW4gKCdsZWZ0JywgJ3JpZ2h0JywgJ3N0YXJ0JyBvciAnZW5kJykuXG4gICAgICAgICAqICdzdGFydCcgY29tcHV0ZXMgdG8gbGVmdCBhbmQgJ2VuZCcgdG8gcmlnaHQgaW4gTFRSIGxheW91dCBhbmQgdmljZSB2ZXJzYSBpbiBSVExcbiAgICAgICAgICogbGF5b3V0LlxuICAgICAgICAgKi9cbiAgICAgICAgYWxpZ246IHtcbiAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgdmFsdWU6ICdsZWZ0J1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY29tcHV0ZWQsIHJlYWQtb25seSBwb3NpdGlvbiBvZiB0aGUgZHJhd2VyIG9uIHRoZSBzY3JlZW4gKCdsZWZ0JyBvciAncmlnaHQnKS5cbiAgICAgICAgICovXG4gICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgIHJlYWRPbmx5OiB0cnVlLFxuICAgICAgICAgIHJlZmxlY3RUb0F0dHJpYnV0ZTogdHJ1ZVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgYW4gYXJlYSBhdCB0aGUgZWRnZSBvZiB0aGUgc2NyZWVuIHRvIHN3aXBlIG9wZW4gdGhlIGRyYXdlci5cbiAgICAgICAgICovXG4gICAgICAgIHN3aXBlT3Blbjoge1xuICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgICAgdmFsdWU6IGZhbHNlLFxuICAgICAgICAgIHJlZmxlY3RUb0F0dHJpYnV0ZTogdHJ1ZVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcmFwIGtleWJvYXJkIGZvY3VzIHdoZW4gdGhlIGRyYXdlciBpcyBvcGVuZWQgYW5kIG5vdCBwZXJzaXN0ZW50LlxuICAgICAgICAgKi9cbiAgICAgICAgbm9Gb2N1c1RyYXA6IHtcbiAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEaXNhYmxlcyBzd2lwaW5nIG9uIHRoZSBkcmF3ZXIuXG4gICAgICAgICAqL1xuICAgICAgICBkaXNhYmxlU3dpcGU6IHtcbiAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBvYnNlcnZlcnM6IFtcbiAgICAgICAgJ3Jlc2V0TGF5b3V0KHBvc2l0aW9uLCBpc0F0dGFjaGVkKScsXG4gICAgICAgICdfcmVzZXRQb3NpdGlvbihhbGlnbiwgaXNBdHRhY2hlZCknLFxuICAgICAgICAnX3N0eWxlVHJhbnNpdGlvbkR1cmF0aW9uKHRyYW5zaXRpb25EdXJhdGlvbiknLFxuICAgICAgICAnX29wZW5lZFBlcnNpc3RlbnRDaGFuZ2VkKG9wZW5lZCwgcGVyc2lzdGVudCknXG4gICAgICBdLFxuXG4gICAgICBfdHJhbnNsYXRlT2Zmc2V0OiAwLFxuXG4gICAgICBfdHJhY2tEZXRhaWxzOiBudWxsLFxuXG4gICAgICBfZHJhd2VyU3RhdGU6IDAsXG5cbiAgICAgIF9ib3VuZEVzY0tleWRvd25IYW5kbGVyOiBudWxsLFxuXG4gICAgICBfZmlyc3RUYWJTdG9wOiBudWxsLFxuXG4gICAgICBfbGFzdFRhYlN0b3A6IG51bGwsXG5cbiAgICAgIGF0dGFjaGVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgUG9seW1lci5SZW5kZXJTdGF0dXMuYWZ0ZXJOZXh0UmVuZGVyKHRoaXMsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHRoaXMuX2JvdW5kRXNjS2V5ZG93bkhhbmRsZXIgPSB0aGlzLl9lc2NLZXlkb3duSGFuZGxlci5iaW5kKHRoaXMpO1xuICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuX3RhYktleWRvd25IYW5kbGVyLmJpbmQodGhpcykpXG5cbiAgICAgICAgICAvLyBPbmx5IGxpc3RlbiBmb3IgaG9yaXpvbnRhbCB0cmFjayBzbyB5b3UgY2FuIHZlcnRpY2FsbHkgc2Nyb2xsIGluc2lkZSB0aGUgZHJhd2VyLlxuICAgICAgICAgIHRoaXMubGlzdGVuKHRoaXMsICd0cmFjaycsICdfdHJhY2snKTtcbiAgICAgICAgICB0aGlzLnNldFNjcm9sbERpcmVjdGlvbigneScpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmZpcmUoJ2FwcC1yZXNldC1sYXlvdXQnKTtcbiAgICAgIH0sXG5cbiAgICAgIGRldGFjaGVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuX2JvdW5kRXNjS2V5ZG93bkhhbmRsZXIpO1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBPcGVucyB0aGUgZHJhd2VyLlxuICAgICAgICovXG4gICAgICBvcGVuOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5vcGVuZWQgPSB0cnVlO1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBDbG9zZXMgdGhlIGRyYXdlci5cbiAgICAgICAqL1xuICAgICAgY2xvc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLm9wZW5lZCA9IGZhbHNlO1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBUb2dnbGVzIHRoZSBkcmF3ZXIgb3BlbiBhbmQgY2xvc2UuXG4gICAgICAgKi9cbiAgICAgIHRvZ2dsZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMub3BlbmVkID0gIXRoaXMub3BlbmVkO1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBHZXRzIHRoZSB3aWR0aCBvZiB0aGUgZHJhd2VyLlxuICAgICAgICpcbiAgICAgICAqIEByZXR1cm4ge251bWJlcn0gVGhlIHdpZHRoIG9mIHRoZSBkcmF3ZXIgaW4gcGl4ZWxzLlxuICAgICAgICovXG4gICAgICBnZXRXaWR0aDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zYXZlZFdpZHRoIHx8IHRoaXMuJC5jb250ZW50Q29udGFpbmVyLm9mZnNldFdpZHRoO1xuICAgICAgfSxcblxuICAgICAgX2lzUlRMOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMpLmRpcmVjdGlvbiA9PT0gJ3J0bCc7XG4gICAgICB9LFxuXG4gICAgICBfcmVzZXRQb3NpdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5hbGlnbikge1xuICAgICAgICAgIGNhc2UgJ3N0YXJ0JzpcbiAgICAgICAgICAgIHRoaXMuX3NldFBvc2l0aW9uKHRoaXMuX2lzUlRMKCkgPyAncmlnaHQnIDogJ2xlZnQnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBjYXNlICdlbmQnOlxuICAgICAgICAgICAgdGhpcy5fc2V0UG9zaXRpb24odGhpcy5faXNSVEwoKSA/ICdsZWZ0JyA6ICdyaWdodCcpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NldFBvc2l0aW9uKHRoaXMuYWxpZ24pO1xuICAgICAgfSxcblxuICAgICAgX2VzY0tleWRvd25IYW5kbGVyOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICB2YXIgRVNDX0tFWUNPREUgPSAyNztcbiAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT09IEVTQ19LRVlDT0RFKSB7XG4gICAgICAgICAgLy8gUHJldmVudCBhbnkgc2lkZSBlZmZlY3RzIGlmIGFwcC1kcmF3ZXIgY2xvc2VzLlxuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBfdHJhY2s6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLnBlcnNpc3RlbnQgfHwgdGhpcy5kaXNhYmxlU3dpcGUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEaXNhYmxlIHVzZXIgc2VsZWN0aW9uIG9uIGRlc2t0b3AuXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgc3dpdGNoIChldmVudC5kZXRhaWwuc3RhdGUpIHtcbiAgICAgICAgICBjYXNlICdzdGFydCc6XG4gICAgICAgICAgICB0aGlzLl90cmFja1N0YXJ0KGV2ZW50KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3RyYWNrJzpcbiAgICAgICAgICAgIHRoaXMuX3RyYWNrTW92ZShldmVudCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdlbmQnOlxuICAgICAgICAgICAgdGhpcy5fdHJhY2tFbmQoZXZlbnQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIF90cmFja1N0YXJ0OiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICB0aGlzLl9kcmF3ZXJTdGF0ZSA9IHRoaXMuX0RSQVdFUl9TVEFURS5UUkFDS0lORztcblxuICAgICAgICB2YXIgcmVjdCA9IHRoaXMuJC5jb250ZW50Q29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB0aGlzLl9zYXZlZFdpZHRoID0gcmVjdC53aWR0aDtcbiAgICAgICAgaWYgKHRoaXMucG9zaXRpb24gPT09ICdsZWZ0Jykge1xuICAgICAgICAgIHRoaXMuX3RyYW5zbGF0ZU9mZnNldCA9IHJlY3QubGVmdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl90cmFuc2xhdGVPZmZzZXQgPSByZWN0LnJpZ2h0IC0gd2luZG93LmlubmVyV2lkdGg7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl90cmFja0RldGFpbHMgPSBbXTtcblxuICAgICAgICAvLyBEaXNhYmxlIHRyYW5zaXRpb25zIHNpbmNlIHN0eWxlIGF0dHJpYnV0ZXMgd2lsbCByZWZsZWN0IHVzZXIgdHJhY2sgZXZlbnRzLlxuICAgICAgICB0aGlzLl9zdHlsZVRyYW5zaXRpb25EdXJhdGlvbigwKTtcbiAgICAgICAgdGhpcy5zdHlsZS52aXNpYmlsaXR5ID0gJ3Zpc2libGUnO1xuICAgICAgfSxcblxuICAgICAgX3RyYWNrTW92ZTogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgdGhpcy5fdHJhbnNsYXRlRHJhd2VyKGV2ZW50LmRldGFpbC5keCArIHRoaXMuX3RyYW5zbGF0ZU9mZnNldCk7XG5cbiAgICAgICAgLy8gVXNlIERhdGUubm93KCkgc2luY2UgZXZlbnQudGltZVN0YW1wIGlzIGluY29uc2lzdGVudCBhY3Jvc3MgYnJvd3NlcnMgKGUuZy4gbW9zdFxuICAgICAgICAvLyBicm93c2VycyB1c2UgbWlsbGlzZWNvbmRzIGJ1dCBGRiA0NCB1c2VzIG1pY3Jvc2Vjb25kcykuXG4gICAgICAgIHRoaXMuX3RyYWNrRGV0YWlscy5wdXNoKHtcbiAgICAgICAgICBkeDogZXZlbnQuZGV0YWlsLmR4LFxuICAgICAgICAgIHRpbWVTdGFtcDogRGF0ZS5ub3coKVxuICAgICAgICB9KTtcbiAgICAgIH0sXG5cbiAgICAgIF90cmFja0VuZDogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgdmFyIHggPSBldmVudC5kZXRhaWwuZHggKyB0aGlzLl90cmFuc2xhdGVPZmZzZXQ7XG4gICAgICAgIHZhciBkcmF3ZXJXaWR0aCA9IHRoaXMuZ2V0V2lkdGgoKTtcbiAgICAgICAgdmFyIGlzUG9zaXRpb25MZWZ0ID0gdGhpcy5wb3NpdGlvbiA9PT0gJ2xlZnQnO1xuICAgICAgICB2YXIgaXNJbkVuZFN0YXRlID0gaXNQb3NpdGlvbkxlZnQgPyAoeCA+PSAwIHx8IHggPD0gLWRyYXdlcldpZHRoKSA6XG4gICAgICAgICAgKHggPD0gMCB8fCB4ID49IGRyYXdlcldpZHRoKTtcblxuICAgICAgICBpZiAoIWlzSW5FbmRTdGF0ZSkge1xuICAgICAgICAgIC8vIE5vIGxvbmdlciBuZWVkIHRoZSB0cmFjayBldmVudHMgYWZ0ZXIgdGhpcyBtZXRob2QgcmV0dXJucyAtIGFsbG93IHRoZW0gdG8gYmUgR0MnZC5cbiAgICAgICAgICB2YXIgdHJhY2tEZXRhaWxzID0gdGhpcy5fdHJhY2tEZXRhaWxzO1xuICAgICAgICAgIHRoaXMuX3RyYWNrRGV0YWlscyA9IG51bGw7XG5cbiAgICAgICAgICB0aGlzLl9mbGluZ0RyYXdlcihldmVudCwgdHJhY2tEZXRhaWxzKTtcbiAgICAgICAgICBpZiAodGhpcy5fZHJhd2VyU3RhdGUgPT09IHRoaXMuX0RSQVdFUl9TVEFURS5GTElOR0lORykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHRoZSBkcmF3ZXIgaXMgbm90IGZsaW5naW5nLCB0b2dnbGUgdGhlIG9wZW5lZCBzdGF0ZSBiYXNlZCBvbiB0aGUgcG9zaXRpb24gb2ZcbiAgICAgICAgLy8gdGhlIGRyYXdlci5cbiAgICAgICAgdmFyIGhhbGZXaWR0aCA9IGRyYXdlcldpZHRoIC8gMjtcbiAgICAgICAgaWYgKGV2ZW50LmRldGFpbC5keCA8IC1oYWxmV2lkdGgpIHtcbiAgICAgICAgICB0aGlzLm9wZW5lZCA9IHRoaXMucG9zaXRpb24gPT09ICdyaWdodCc7XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnQuZGV0YWlsLmR4ID4gaGFsZldpZHRoKSB7XG4gICAgICAgICAgdGhpcy5vcGVuZWQgPSB0aGlzLnBvc2l0aW9uID09PSAnbGVmdCc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNJbkVuZFN0YXRlKSB7XG4gICAgICAgICAgdGhpcy5kZWJvdW5jZSgnX3Jlc2V0RHJhd2VyU3RhdGUnLCB0aGlzLl9yZXNldERyYXdlclN0YXRlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmRlYm91bmNlKCdfcmVzZXREcmF3ZXJTdGF0ZScsIHRoaXMuX3Jlc2V0RHJhd2VyU3RhdGUsIHRoaXMudHJhbnNpdGlvbkR1cmF0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3N0eWxlVHJhbnNpdGlvbkR1cmF0aW9uKHRoaXMudHJhbnNpdGlvbkR1cmF0aW9uKTtcbiAgICAgICAgdGhpcy5fcmVzZXREcmF3ZXJUcmFuc2xhdGUoKTtcbiAgICAgICAgdGhpcy5zdHlsZS52aXNpYmlsaXR5ID0gJyc7XG4gICAgICB9LFxuXG4gICAgICBfY2FsY3VsYXRlVmVsb2NpdHk6IGZ1bmN0aW9uKGV2ZW50LCB0cmFja0RldGFpbHMpIHtcbiAgICAgICAgLy8gRmluZCB0aGUgb2xkZXN0IHRyYWNrIGV2ZW50IHRoYXQgaXMgd2l0aGluIDEwMG1zIHVzaW5nIGJpbmFyeSBzZWFyY2guXG4gICAgICAgIHZhciBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICB2YXIgdGltZUxvd2VyQm91bmQgPSBub3cgLSAxMDA7XG4gICAgICAgIHZhciB0cmFja0RldGFpbDtcbiAgICAgICAgdmFyIG1pbiA9IDA7XG4gICAgICAgIHZhciBtYXggPSB0cmFja0RldGFpbHMubGVuZ3RoIC0gMTtcblxuICAgICAgICB3aGlsZSAobWluIDw9IG1heCkge1xuICAgICAgICAgIC8vIEZsb29yIG9mIGF2ZXJhZ2Ugb2YgbWluIGFuZCBtYXguXG4gICAgICAgICAgdmFyIG1pZCA9IChtaW4gKyBtYXgpID4+IDE7XG4gICAgICAgICAgdmFyIGQgPSB0cmFja0RldGFpbHNbbWlkXTtcbiAgICAgICAgICBpZiAoZC50aW1lU3RhbXAgPj0gdGltZUxvd2VyQm91bmQpIHtcbiAgICAgICAgICAgIHRyYWNrRGV0YWlsID0gZDtcbiAgICAgICAgICAgIG1heCA9IG1pZCAtIDE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1pbiA9IG1pZCArIDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRyYWNrRGV0YWlsKSB7XG4gICAgICAgICAgdmFyIGR4ID0gZXZlbnQuZGV0YWlsLmR4IC0gdHJhY2tEZXRhaWwuZHg7XG4gICAgICAgICAgdmFyIGR0ID0gKG5vdyAtIHRyYWNrRGV0YWlsLnRpbWVTdGFtcCkgfHwgMTtcbiAgICAgICAgICByZXR1cm4gZHggLyBkdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH0sXG5cbiAgICAgIF9mbGluZ0RyYXdlcjogZnVuY3Rpb24oZXZlbnQsIHRyYWNrRGV0YWlscykge1xuICAgICAgICB2YXIgdmVsb2NpdHkgPSB0aGlzLl9jYWxjdWxhdGVWZWxvY2l0eShldmVudCwgdHJhY2tEZXRhaWxzKTtcblxuICAgICAgICAvLyBEbyBub3QgZmxpbmcgaWYgdmVsb2NpdHkgaXMgbm90IGFib3ZlIGEgdGhyZXNob2xkLlxuICAgICAgICBpZiAoTWF0aC5hYnModmVsb2NpdHkpIDwgdGhpcy5fTUlOX0ZMSU5HX1RIUkVTSE9MRCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2RyYXdlclN0YXRlID0gdGhpcy5fRFJBV0VSX1NUQVRFLkZMSU5HSU5HO1xuXG4gICAgICAgIHZhciB4ID0gZXZlbnQuZGV0YWlsLmR4ICsgdGhpcy5fdHJhbnNsYXRlT2Zmc2V0O1xuICAgICAgICB2YXIgZHJhd2VyV2lkdGggPSB0aGlzLmdldFdpZHRoKCk7XG4gICAgICAgIHZhciBpc1Bvc2l0aW9uTGVmdCA9IHRoaXMucG9zaXRpb24gPT09ICdsZWZ0JztcbiAgICAgICAgdmFyIGlzVmVsb2NpdHlQb3NpdGl2ZSA9IHZlbG9jaXR5ID4gMDtcbiAgICAgICAgdmFyIGlzQ2xvc2luZ0xlZnQgPSAhaXNWZWxvY2l0eVBvc2l0aXZlICYmIGlzUG9zaXRpb25MZWZ0O1xuICAgICAgICB2YXIgaXNDbG9zaW5nUmlnaHQgPSBpc1ZlbG9jaXR5UG9zaXRpdmUgJiYgIWlzUG9zaXRpb25MZWZ0O1xuICAgICAgICB2YXIgZHg7XG4gICAgICAgIGlmIChpc0Nsb3NpbmdMZWZ0KSB7XG4gICAgICAgICAgZHggPSAtKHggKyBkcmF3ZXJXaWR0aCk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNDbG9zaW5nUmlnaHQpIHtcbiAgICAgICAgICBkeCA9IChkcmF3ZXJXaWR0aCAtIHgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGR4ID0gLXg7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBFbmZvcmNlIGEgbWluaW11bSB0cmFuc2l0aW9uIHZlbG9jaXR5IHRvIG1ha2UgdGhlIGRyYXdlciBmZWVsIHNuYXBweS5cbiAgICAgICAgaWYgKGlzVmVsb2NpdHlQb3NpdGl2ZSkge1xuICAgICAgICAgIHZlbG9jaXR5ID0gTWF0aC5tYXgodmVsb2NpdHksIHRoaXMuX01JTl9UUkFOU0lUSU9OX1ZFTE9DSVRZKTtcbiAgICAgICAgICB0aGlzLm9wZW5lZCA9IHRoaXMucG9zaXRpb24gPT09ICdsZWZ0JztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2ZWxvY2l0eSA9IE1hdGgubWluKHZlbG9jaXR5LCAtdGhpcy5fTUlOX1RSQU5TSVRJT05fVkVMT0NJVFkpO1xuICAgICAgICAgIHRoaXMub3BlbmVkID0gdGhpcy5wb3NpdGlvbiA9PT0gJ3JpZ2h0JztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgYW1vdW50IG9mIHRpbWUgbmVlZGVkIHRvIGZpbmlzaCB0aGUgdHJhbnNpdGlvbiBiYXNlZCBvbiB0aGVcbiAgICAgICAgLy8gaW5pdGlhbCBzbG9wZSBvZiB0aGUgdGltaW5nIGZ1bmN0aW9uLlxuICAgICAgICB2YXIgdCA9IHRoaXMuX0ZMSU5HX0lOSVRJQUxfU0xPUEUgKiBkeCAvIHZlbG9jaXR5XG4gICAgICAgIHRoaXMuX3N0eWxlVHJhbnNpdGlvbkR1cmF0aW9uKHQpO1xuICAgICAgICB0aGlzLl9zdHlsZVRyYW5zaXRpb25UaW1pbmdGdW5jdGlvbih0aGlzLl9GTElOR19USU1JTkdfRlVOQ1RJT04pO1xuXG4gICAgICAgIHRoaXMuX3Jlc2V0RHJhd2VyVHJhbnNsYXRlKCk7XG4gICAgICAgIHRoaXMuZGVib3VuY2UoJ19yZXNldERyYXdlclN0YXRlJywgdGhpcy5fcmVzZXREcmF3ZXJTdGF0ZSwgdCk7XG4gICAgICB9LFxuXG4gICAgICBfc3R5bGVUcmFuc2l0aW9uRHVyYXRpb246IGZ1bmN0aW9uKGR1cmF0aW9uKSB7XG4gICAgICAgIHRoaXMuc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID0gZHVyYXRpb24gKyAnbXMnO1xuICAgICAgICB0aGlzLiQuY29udGVudENvbnRhaW5lci5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPSBkdXJhdGlvbiArICdtcyc7XG4gICAgICAgIHRoaXMuJC5zY3JpbS5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPSBkdXJhdGlvbiArICdtcyc7XG4gICAgICB9LFxuXG4gICAgICBfc3R5bGVUcmFuc2l0aW9uVGltaW5nRnVuY3Rpb246IGZ1bmN0aW9uKHRpbWluZ0Z1bmN0aW9uKSB7XG4gICAgICAgIHRoaXMuJC5jb250ZW50Q29udGFpbmVyLnN0eWxlLnRyYW5zaXRpb25UaW1pbmdGdW5jdGlvbiA9IHRpbWluZ0Z1bmN0aW9uO1xuICAgICAgICB0aGlzLiQuc2NyaW0uc3R5bGUudHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uID0gdGltaW5nRnVuY3Rpb247XG4gICAgICB9LFxuXG4gICAgICBfdHJhbnNsYXRlRHJhd2VyOiBmdW5jdGlvbih4KSB7XG4gICAgICAgIHZhciBkcmF3ZXJXaWR0aCA9IHRoaXMuZ2V0V2lkdGgoKTtcblxuICAgICAgICBpZiAodGhpcy5wb3NpdGlvbiA9PT0gJ2xlZnQnKSB7XG4gICAgICAgICAgeCA9IE1hdGgubWF4KC1kcmF3ZXJXaWR0aCwgTWF0aC5taW4oeCwgMCkpO1xuICAgICAgICAgIHRoaXMuJC5zY3JpbS5zdHlsZS5vcGFjaXR5ID0gMSArIHggLyBkcmF3ZXJXaWR0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB4ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oeCwgZHJhd2VyV2lkdGgpKTtcbiAgICAgICAgICB0aGlzLiQuc2NyaW0uc3R5bGUub3BhY2l0eSA9IDEgLSB4IC8gZHJhd2VyV2lkdGg7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnRyYW5zbGF0ZTNkKHggKyAncHgnLCAnMCcsICcwJywgdGhpcy4kLmNvbnRlbnRDb250YWluZXIpO1xuICAgICAgfSxcblxuICAgICAgX3Jlc2V0RHJhd2VyVHJhbnNsYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy4kLnNjcmltLnN0eWxlLm9wYWNpdHkgPSAnJztcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0oJycsIHRoaXMuJC5jb250ZW50Q29udGFpbmVyKTtcbiAgICAgIH0sXG5cbiAgICAgIF9yZXNldERyYXdlclN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG9sZFN0YXRlID0gdGhpcy5fZHJhd2VyU3RhdGU7XG5cbiAgICAgICAgLy8gSWYgdGhlIGRyYXdlciB3YXMgZmxpbmdpbmcsIHdlIG5lZWQgdG8gcmVzZXQgdGhlIHN0eWxlIGF0dHJpYnV0ZXMuXG4gICAgICAgIGlmIChvbGRTdGF0ZSA9PT0gdGhpcy5fRFJBV0VSX1NUQVRFLkZMSU5HSU5HKSB7XG4gICAgICAgICAgdGhpcy5fc3R5bGVUcmFuc2l0aW9uRHVyYXRpb24odGhpcy50cmFuc2l0aW9uRHVyYXRpb24pO1xuICAgICAgICAgIHRoaXMuX3N0eWxlVHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uKCcnKTtcbiAgICAgICAgICB0aGlzLnN0eWxlLnZpc2liaWxpdHkgPSAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3NhdmVkV2lkdGggPSBudWxsO1xuXG4gICAgICAgIGlmICh0aGlzLm9wZW5lZCkge1xuICAgICAgICAgIHRoaXMuX2RyYXdlclN0YXRlID0gdGhpcy5wZXJzaXN0ZW50ID9cbiAgICAgICAgICAgIHRoaXMuX0RSQVdFUl9TVEFURS5PUEVORURfUEVSU0lTVEVOVCA6IHRoaXMuX0RSQVdFUl9TVEFURS5PUEVORUQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fZHJhd2VyU3RhdGUgPSB0aGlzLl9EUkFXRVJfU1RBVEUuQ0xPU0VEO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9sZFN0YXRlICE9PSB0aGlzLl9kcmF3ZXJTdGF0ZSkge1xuICAgICAgICAgIGlmICh0aGlzLl9kcmF3ZXJTdGF0ZSA9PT0gdGhpcy5fRFJBV0VSX1NUQVRFLk9QRU5FRCkge1xuICAgICAgICAgICAgdGhpcy5fc2V0S2V5Ym9hcmRGb2N1c1RyYXAoKTtcbiAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLl9ib3VuZEVzY0tleWRvd25IYW5kbGVyKTtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuX2JvdW5kRXNjS2V5ZG93bkhhbmRsZXIpO1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5zdHlsZS5vdmVyZmxvdyA9ICcnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIERvbid0IGZpcmUgdGhlIGV2ZW50IG9uIGluaXRpYWwgbG9hZC5cbiAgICAgICAgICBpZiAob2xkU3RhdGUgIT09IHRoaXMuX0RSQVdFUl9TVEFURS5JTklUKSB7XG4gICAgICAgICAgICB0aGlzLmZpcmUoJ2FwcC1kcmF3ZXItdHJhbnNpdGlvbmVkJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFJlc2V0cyB0aGUgbGF5b3V0LlxuICAgICAgICpcbiAgICAgICAqIEBtZXRob2QgcmVzZXRMYXlvdXRcbiAgICAgICAqL1xuICAgICAgcmVzZXRMYXlvdXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmZpcmUoJ2FwcC1yZXNldC1sYXlvdXQnKTtcbiAgICAgIH0sXG5cbiAgICAgIF9zZXRLZXlib2FyZEZvY3VzVHJhcDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLm5vRm9jdXNUcmFwKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTk9URTogVW5sZXNzIHdlIHVzZSAvZGVlcC8gKHdoaWNoIHdlIHNob3VsZG4ndCBzaW5jZSBpdCdzIGRlcHJlY2F0ZWQpLCB0aGlzIHdpbGxcbiAgICAgICAgLy8gbm90IHNlbGVjdCBmb2N1c2FibGUgZWxlbWVudHMgaW5zaWRlIHNoYWRvdyByb290cy5cbiAgICAgICAgdmFyIGZvY3VzYWJsZUVsZW1lbnRzU2VsZWN0b3IgPSBbXG4gICAgICAgICAgICAnYVtocmVmXTpub3QoW3RhYmluZGV4PVwiLTFcIl0pJyxcbiAgICAgICAgICAgICdhcmVhW2hyZWZdOm5vdChbdGFiaW5kZXg9XCItMVwiXSknLFxuICAgICAgICAgICAgJ2lucHV0Om5vdChbZGlzYWJsZWRdKTpub3QoW3RhYmluZGV4PVwiLTFcIl0pJyxcbiAgICAgICAgICAgICdzZWxlY3Q6bm90KFtkaXNhYmxlZF0pOm5vdChbdGFiaW5kZXg9XCItMVwiXSknLFxuICAgICAgICAgICAgJ3RleHRhcmVhOm5vdChbZGlzYWJsZWRdKTpub3QoW3RhYmluZGV4PVwiLTFcIl0pJyxcbiAgICAgICAgICAgICdidXR0b246bm90KFtkaXNhYmxlZF0pOm5vdChbdGFiaW5kZXg9XCItMVwiXSknLFxuICAgICAgICAgICAgJ2lmcmFtZTpub3QoW3RhYmluZGV4PVwiLTFcIl0pJyxcbiAgICAgICAgICAgICdbdGFiaW5kZXhdOm5vdChbdGFiaW5kZXg9XCItMVwiXSknLFxuICAgICAgICAgICAgJ1tjb250ZW50RWRpdGFibGU9dHJ1ZV06bm90KFt0YWJpbmRleD1cIi0xXCJdKSdcbiAgICAgICAgICBdLmpvaW4oJywnKTtcbiAgICAgICAgdmFyIGZvY3VzYWJsZUVsZW1lbnRzID0gUG9seW1lci5kb20odGhpcykucXVlcnlTZWxlY3RvckFsbChmb2N1c2FibGVFbGVtZW50c1NlbGVjdG9yKTtcblxuICAgICAgICBpZiAoZm9jdXNhYmxlRWxlbWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHRoaXMuX2ZpcnN0VGFiU3RvcCA9IGZvY3VzYWJsZUVsZW1lbnRzWzBdO1xuICAgICAgICAgIHRoaXMuX2xhc3RUYWJTdG9wID0gZm9jdXNhYmxlRWxlbWVudHNbZm9jdXNhYmxlRWxlbWVudHMubGVuZ3RoIC0gMV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gUmVzZXQgc2F2ZWQgdGFiIHN0b3BzIHdoZW4gdGhlcmUgYXJlIG5vIGZvY3VzYWJsZSBlbGVtZW50cyBpbiB0aGUgZHJhd2VyLlxuICAgICAgICAgIHRoaXMuX2ZpcnN0VGFiU3RvcCA9IG51bGw7XG4gICAgICAgICAgdGhpcy5fbGFzdFRhYlN0b3AgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRm9jdXMgb24gYXBwLWRyYXdlciBpZiBpdCBoYXMgbm9uLXplcm8gdGFiaW5kZXguIE90aGVyd2lzZSwgZm9jdXMgdGhlIGZpcnN0IGZvY3VzYWJsZVxuICAgICAgICAvLyBlbGVtZW50IGluIHRoZSBkcmF3ZXIsIGlmIGl0IGV4aXN0cy4gVXNlIHRoZSB0YWJpbmRleCBhdHRyaWJ1dGUgc2luY2UgdGhlIHRoaXMudGFiSW5kZXhcbiAgICAgICAgLy8gcHJvcGVydHkgaW4gSUUvRWRnZSByZXR1cm5zIDAgKGluc3RlYWQgb2YgLTEpIHdoZW4gdGhlIGF0dHJpYnV0ZSBpcyBub3Qgc2V0LlxuICAgICAgICB2YXIgdGFiaW5kZXggPSB0aGlzLmdldEF0dHJpYnV0ZSgndGFiaW5kZXgnKTtcbiAgICAgICAgaWYgKHRhYmluZGV4ICYmIHBhcnNlSW50KHRhYmluZGV4LCAxMCkgPiAtMSkge1xuICAgICAgICAgIHRoaXMuZm9jdXMoKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9maXJzdFRhYlN0b3ApIHtcbiAgICAgICAgICB0aGlzLl9maXJzdFRhYlN0b3AuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgX3RhYktleWRvd25IYW5kbGVyOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICBpZiAodGhpcy5ub0ZvY3VzVHJhcCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBUQUJfS0VZQ09ERSA9IDk7XG4gICAgICAgIGlmICh0aGlzLl9kcmF3ZXJTdGF0ZSA9PT0gdGhpcy5fRFJBV0VSX1NUQVRFLk9QRU5FRCAmJiBldmVudC5rZXlDb2RlID09PSBUQUJfS0VZQ09ERSkge1xuICAgICAgICAgIGlmIChldmVudC5zaGlmdEtleSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2ZpcnN0VGFiU3RvcCAmJiBQb2x5bWVyLmRvbShldmVudCkubG9jYWxUYXJnZXQgPT09IHRoaXMuX2ZpcnN0VGFiU3RvcCkge1xuICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICB0aGlzLl9sYXN0VGFiU3RvcC5mb2N1cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fbGFzdFRhYlN0b3AgJiYgUG9seW1lci5kb20oZXZlbnQpLmxvY2FsVGFyZ2V0ID09PSB0aGlzLl9sYXN0VGFiU3RvcCkge1xuICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICB0aGlzLl9maXJzdFRhYlN0b3AuZm9jdXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIF9vcGVuZWRQZXJzaXN0ZW50Q2hhbmdlZDogZnVuY3Rpb24ob3BlbmVkLCBwZXJzaXN0ZW50KSB7XG4gICAgICAgIHRoaXMudG9nZ2xlQ2xhc3MoJ3Zpc2libGUnLCBvcGVuZWQgJiYgIXBlcnNpc3RlbnQsIHRoaXMuJC5zY3JpbSk7XG5cbiAgICAgICAgLy8gVXNlIGEgZGVib3VuY2UgdGltZXIgaW5zdGVhZCBvZiB0cmFuc2l0aW9uZW5kIHNpbmNlIHRyYW5zaXRpb25lbmQgd29uJ3QgZmlyZSB3aGVuXG4gICAgICAgIC8vIGFwcC1kcmF3ZXIgaXMgZGlzcGxheTogbm9uZS5cbiAgICAgICAgdGhpcy5kZWJvdW5jZSgnX3Jlc2V0RHJhd2VyU3RhdGUnLCB0aGlzLl9yZXNldERyYXdlclN0YXRlLCB0aGlzLnRyYW5zaXRpb25EdXJhdGlvbik7XG4gICAgICB9LFxuXG4gICAgICBfTUlOX0ZMSU5HX1RIUkVTSE9MRDogMC4yLFxuXG4gICAgICBfTUlOX1RSQU5TSVRJT05fVkVMT0NJVFk6IDEuMixcblxuICAgICAgX0ZMSU5HX1RJTUlOR19GVU5DVElPTjogJ2N1YmljLWJlemllcigwLjY2NywgMSwgMC42NjcsIDEpJyxcblxuICAgICAgX0ZMSU5HX0lOSVRJQUxfU0xPUEU6IDEuNSxcblxuICAgICAgX0RSQVdFUl9TVEFURToge1xuICAgICAgICBJTklUOiAwLFxuICAgICAgICBPUEVORUQ6IDEsXG4gICAgICAgIE9QRU5FRF9QRVJTSVNURU5UOiAyLFxuICAgICAgICBDTE9TRUQ6IDMsXG4gICAgICAgIFRSQUNLSU5HOiA0LFxuICAgICAgICBGTElOR0lORzogNVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEZpcmVkIHdoZW4gdGhlIGxheW91dCBvZiBhcHAtZHJhd2VyIGhhcyBjaGFuZ2VkLlxuICAgICAgICpcbiAgICAgICAqIEBldmVudCBhcHAtcmVzZXQtbGF5b3V0XG4gICAgICAgKi9cblxuICAgICAgLyoqXG4gICAgICAgKiBGaXJlZCB3aGVuIGFwcC1kcmF3ZXIgaGFzIGZpbmlzaGVkIHRyYW5zaXRpb25pbmcuXG4gICAgICAgKlxuICAgICAgICogQGV2ZW50IGFwcC1kcmF3ZXItdHJhbnNpdGlvbmVkXG4gICAgICAgKi9cbiAgICB9KTtcbiAgPC9zY3JpcHQ+XG48L2RvbS1tb2R1bGU+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL2FwcC1sYXlvdXQvYXBwLWRyYXdlci9hcHAtZHJhd2VyLmh0bWwiLCJcbnJlcXVpcmUoJy4vYXBwbHktc2hpbS5taW4uanMnKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvc2hhZHljc3MvYXBwbHktc2hpbS5odG1sIiwiKGZ1bmN0aW9uKCl7LypcblxuQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuKi9cbid1c2Ugc3RyaWN0Jzt2YXIgaz17fTtmdW5jdGlvbiBuKCl7dGhpcy5lbmQ9dGhpcy5zdGFydD0wO3RoaXMucnVsZXM9dGhpcy5wYXJlbnQ9dGhpcy5wcmV2aW91cz1udWxsO3RoaXMuY3NzVGV4dD10aGlzLnBhcnNlZENzc1RleHQ9XCJcIjt0aGlzLmF0UnVsZT0hMTt0aGlzLnR5cGU9MDt0aGlzLnBhcnNlZFNlbGVjdG9yPXRoaXMuc2VsZWN0b3I9dGhpcy5rZXlmcmFtZXNOYW1lPVwiXCJ9XG5mdW5jdGlvbiBwKGEpe2E9YS5yZXBsYWNlKGFhLFwiXCIpLnJlcGxhY2UoYmEsXCJcIik7dmFyIGI9cSxjPWEsZD1uZXcgbjtkLnN0YXJ0PTA7ZC5lbmQ9Yy5sZW5ndGg7Zm9yKHZhciBlPWQsZj0wLGg9Yy5sZW5ndGg7ZjxoO2YrKylpZihcIntcIj09PWNbZl0pe2UucnVsZXN8fChlLnJ1bGVzPVtdKTt2YXIgZz1lLG09Zy5ydWxlc1tnLnJ1bGVzLmxlbmd0aC0xXXx8bnVsbDtlPW5ldyBuO2Uuc3RhcnQ9ZisxO2UucGFyZW50PWc7ZS5wcmV2aW91cz1tO2cucnVsZXMucHVzaChlKX1lbHNlXCJ9XCI9PT1jW2ZdJiYoZS5lbmQ9ZisxLGU9ZS5wYXJlbnR8fGQpO3JldHVybiBiKGQsYSl9XG5mdW5jdGlvbiBxKGEsYil7dmFyIGM9Yi5zdWJzdHJpbmcoYS5zdGFydCxhLmVuZC0xKTthLnBhcnNlZENzc1RleHQ9YS5jc3NUZXh0PWMudHJpbSgpO2EucGFyZW50JiYoYz1iLnN1YnN0cmluZyhhLnByZXZpb3VzP2EucHJldmlvdXMuZW5kOmEucGFyZW50LnN0YXJ0LGEuc3RhcnQtMSksYz1jYShjKSxjPWMucmVwbGFjZShyLFwiIFwiKSxjPWMuc3Vic3RyaW5nKGMubGFzdEluZGV4T2YoXCI7XCIpKzEpLGM9YS5wYXJzZWRTZWxlY3Rvcj1hLnNlbGVjdG9yPWMudHJpbSgpLGEuYXRSdWxlPTA9PT1jLmluZGV4T2YoXCJAXCIpLGEuYXRSdWxlPzA9PT1jLmluZGV4T2YoXCJAbWVkaWFcIik/YS50eXBlPXQ6Yy5tYXRjaChkYSkmJihhLnR5cGU9dSxhLmtleWZyYW1lc05hbWU9YS5zZWxlY3Rvci5zcGxpdChyKS5wb3AoKSk6YS50eXBlPTA9PT1jLmluZGV4T2YoXCItLVwiKT92OngpO2lmKGM9YS5ydWxlcylmb3IodmFyIGQ9MCxlPWMubGVuZ3RoLGY7ZDxlJiYoZj1jW2RdKTtkKyspcShmLGIpO3JldHVybiBhfVxuZnVuY3Rpb24gY2EoYSl7cmV0dXJuIGEucmVwbGFjZSgvXFxcXChbMC05YS1mXXsxLDZ9KVxccy9naSxmdW5jdGlvbihhLGMpe2E9Yztmb3IoYz02LWEubGVuZ3RoO2MtLTspYT1cIjBcIithO3JldHVyblwiXFxcXFwiK2F9KX1cbmZ1bmN0aW9uIHkoYSxiLGMpe2M9dm9pZCAwPT09Yz9cIlwiOmM7dmFyIGQ9XCJcIjtpZihhLmNzc1RleHR8fGEucnVsZXMpe3ZhciBlPWEucnVsZXMsZjtpZihmPWUpZj1lWzBdLGY9IShmJiZmLnNlbGVjdG9yJiYwPT09Zi5zZWxlY3Rvci5pbmRleE9mKFwiLS1cIikpO2lmKGYpe2Y9MDtmb3IodmFyIGg9ZS5sZW5ndGgsZztmPGgmJihnPWVbZl0pO2YrKylkPXkoZyxiLGQpfWVsc2UgYj9iPWEuY3NzVGV4dDooYj1hLmNzc1RleHQsYj1iLnJlcGxhY2UoZWEsXCJcIikucmVwbGFjZShmYSxcIlwiKSxiPWIucmVwbGFjZShoYSxcIlwiKS5yZXBsYWNlKGlhLFwiXCIpKSwoZD1iLnRyaW0oKSkmJihkPVwiICBcIitkK1wiXFxuXCIpfWQmJihhLnNlbGVjdG9yJiYoYys9YS5zZWxlY3RvcitcIiB7XFxuXCIpLGMrPWQsYS5zZWxlY3RvciYmKGMrPVwifVxcblxcblwiKSk7cmV0dXJuIGN9XG52YXIgeD0xLHU9Nyx0PTQsdj0xRTMsYWE9L1xcL1xcKlteKl0qXFwqKyhbXi8qXVteKl0qXFwqKykqXFwvL2dpbSxiYT0vQGltcG9ydFteO10qOy9naW0sZWE9Lyg/Ol5bXjtcXC1cXHN9XSspPy0tW147e31dKj86W157fTtdKj8oPzpbO1xcbl18JCkvZ2ltLGZhPS8oPzpeW147XFwtXFxzfV0rKT8tLVteO3t9XSo/Oltee307XSo/e1tefV0qP30oPzpbO1xcbl18JCk/L2dpbSxoYT0vQGFwcGx5XFxzKlxcKD9bXik7XSpcXCk/XFxzKig/Ols7XFxuXXwkKT8vZ2ltLGlhPS9bXjs6XSo/OlteO10qP3ZhclxcKFteO10qXFwpKD86WztcXG5dfCQpPy9naW0sZGE9L15AW15cXHNdKmtleWZyYW1lcy8scj0vXFxzKy9nO3ZhciBqYT1Qcm9taXNlLnJlc29sdmUoKTtmdW5jdGlvbiBrYShhKXtpZihhPWtbYV0pYS5fYXBwbHlTaGltQ3VycmVudFZlcnNpb249YS5fYXBwbHlTaGltQ3VycmVudFZlcnNpb258fDAsYS5fYXBwbHlTaGltVmFsaWRhdGluZ1ZlcnNpb249YS5fYXBwbHlTaGltVmFsaWRhdGluZ1ZlcnNpb258fDAsYS5fYXBwbHlTaGltTmV4dFZlcnNpb249KGEuX2FwcGx5U2hpbU5leHRWZXJzaW9ufHwwKSsxfWZ1bmN0aW9uIHooYSl7cmV0dXJuIGEuX2FwcGx5U2hpbUN1cnJlbnRWZXJzaW9uPT09YS5fYXBwbHlTaGltTmV4dFZlcnNpb259ZnVuY3Rpb24gbGEoYSl7YS5fYXBwbHlTaGltVmFsaWRhdGluZ1ZlcnNpb249YS5fYXBwbHlTaGltTmV4dFZlcnNpb247YS5hfHwoYS5hPSEwLGphLnRoZW4oZnVuY3Rpb24oKXthLl9hcHBseVNoaW1DdXJyZW50VmVyc2lvbj1hLl9hcHBseVNoaW1OZXh0VmVyc2lvbjthLmE9ITF9KSl9O3ZhciBBPSEod2luZG93LlNoYWR5RE9NJiZ3aW5kb3cuU2hhZHlET00uaW5Vc2UpLEI7ZnVuY3Rpb24gQyhhKXtCPWEmJmEuc2hpbWNzc3Byb3BlcnRpZXM/ITE6QXx8IShuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9BcHBsZVdlYktpdFxcLzYwMXxFZGdlXFwvMTUvKXx8IXdpbmRvdy5DU1N8fCFDU1Muc3VwcG9ydHN8fCFDU1Muc3VwcG9ydHMoXCJib3gtc2hhZG93XCIsXCIwIDAgMCB2YXIoLS1mb28pXCIpKX13aW5kb3cuU2hhZHlDU1MmJnZvaWQgMCE9PXdpbmRvdy5TaGFkeUNTUy5uYXRpdmVDc3M/Qj13aW5kb3cuU2hhZHlDU1MubmF0aXZlQ3NzOndpbmRvdy5TaGFkeUNTUz8oQyh3aW5kb3cuU2hhZHlDU1MpLHdpbmRvdy5TaGFkeUNTUz12b2lkIDApOkMod2luZG93LldlYkNvbXBvbmVudHMmJndpbmRvdy5XZWJDb21wb25lbnRzLmZsYWdzKTt2YXIgRT1CO3ZhciBGPS8oPzpefFs7XFxze11cXHMqKSgtLVtcXHctXSo/KVxccyo6XFxzKig/OigoPzonKD86XFxcXCd8LikqPyd8XCIoPzpcXFxcXCJ8LikqP1wifFxcKFteKV0qP1xcKXxbXn07e10pKyl8XFx7KFtefV0qKVxcfSg/Oig/PVs7XFxzfV0pfCQpKS9naSxHPS8oPzpefFxcVyspQGFwcGx5XFxzKlxcKD8oW14pO1xcbl0qKVxcKT8vZ2ksbWE9L0BtZWRpYVxccyguKikvO2Z1bmN0aW9uIEgoYSl7aWYoIWEpcmV0dXJuXCJcIjtcInN0cmluZ1wiPT09dHlwZW9mIGEmJihhPXAoYSkpO3JldHVybiB5KGEsRSl9ZnVuY3Rpb24gSShhKXshYS5fX2Nzc1J1bGVzJiZhLnRleHRDb250ZW50JiYoYS5fX2Nzc1J1bGVzPXAoYS50ZXh0Q29udGVudCkpO3JldHVybiBhLl9fY3NzUnVsZXN8fG51bGx9ZnVuY3Rpb24gSihhLGIsYyxkKXtpZihhKXt2YXIgZT0hMSxmPWEudHlwZTtpZihkJiZmPT09dCl7dmFyIGg9YS5zZWxlY3Rvci5tYXRjaChtYSk7aCYmKHdpbmRvdy5tYXRjaE1lZGlhKGhbMV0pLm1hdGNoZXN8fChlPSEwKSl9Zj09PXg/YihhKTpjJiZmPT09dT9jKGEpOmY9PT12JiYoZT0hMCk7aWYoKGE9YS5ydWxlcykmJiFlKXtlPTA7Zj1hLmxlbmd0aDtmb3IodmFyIGc7ZTxmJiYoZz1hW2VdKTtlKyspSihnLGIsYyxkKX19fVxuZnVuY3Rpb24gSyhhLGIpe3ZhciBjPWEuaW5kZXhPZihcInZhcihcIik7aWYoLTE9PT1jKXJldHVybiBiKGEsXCJcIixcIlwiLFwiXCIpO2E6e3ZhciBkPTA7dmFyIGU9YyszO2Zvcih2YXIgZj1hLmxlbmd0aDtlPGY7ZSsrKWlmKFwiKFwiPT09YVtlXSlkKys7ZWxzZSBpZihcIilcIj09PWFbZV0mJjA9PT0tLWQpYnJlYWsgYTtlPS0xfWQ9YS5zdWJzdHJpbmcoYys0LGUpO2M9YS5zdWJzdHJpbmcoMCxjKTthPUsoYS5zdWJzdHJpbmcoZSsxKSxiKTtlPWQuaW5kZXhPZihcIixcIik7cmV0dXJuLTE9PT1lP2IoYyxkLnRyaW0oKSxcIlwiLGEpOmIoYyxkLnN1YnN0cmluZygwLGUpLnRyaW0oKSxkLnN1YnN0cmluZyhlKzEpLnRyaW0oKSxhKX07dmFyIG5hPS87XFxzKi9tLG9hPS9eXFxzKihpbml0aWFsKXwoaW5oZXJpdClcXHMqJC87ZnVuY3Rpb24gTCgpe3RoaXMuYT17fX1MLnByb3RvdHlwZS5zZXQ9ZnVuY3Rpb24oYSxiKXthPWEudHJpbSgpO3RoaXMuYVthXT17aDpiLGk6e319fTtMLnByb3RvdHlwZS5nZXQ9ZnVuY3Rpb24oYSl7YT1hLnRyaW0oKTtyZXR1cm4gdGhpcy5hW2FdfHxudWxsfTt2YXIgTT1udWxsO2Z1bmN0aW9uIE4oKXt0aGlzLmI9dGhpcy5jPW51bGw7dGhpcy5hPW5ldyBMfU4ucHJvdG90eXBlLm89ZnVuY3Rpb24oYSl7YT1HLnRlc3QoYSl8fEYudGVzdChhKTtHLmxhc3RJbmRleD0wO0YubGFzdEluZGV4PTA7cmV0dXJuIGF9O04ucHJvdG90eXBlLm09ZnVuY3Rpb24oYSxiKXthPWEuY29udGVudC5xdWVyeVNlbGVjdG9yKFwic3R5bGVcIik7dmFyIGM9bnVsbDthJiYoYz10aGlzLmooYSxiKSk7cmV0dXJuIGN9O1xuTi5wcm90b3R5cGUuaj1mdW5jdGlvbihhLGIpe2I9dm9pZCAwPT09Yj9cIlwiOmI7dmFyIGM9SShhKTt0aGlzLmwoYyxiKTthLnRleHRDb250ZW50PUgoYyk7cmV0dXJuIGN9O04ucHJvdG90eXBlLmY9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcyxjPUkoYSk7SihjLGZ1bmN0aW9uKGEpe1wiOnJvb3RcIj09PWEuc2VsZWN0b3ImJihhLnNlbGVjdG9yPVwiaHRtbFwiKTtiLmcoYSl9KTthLnRleHRDb250ZW50PUgoYyk7cmV0dXJuIGN9O04ucHJvdG90eXBlLmw9ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzO3RoaXMuYz1iO0ooYSxmdW5jdGlvbihhKXtjLmcoYSl9KTt0aGlzLmM9bnVsbH07Ti5wcm90b3R5cGUuZz1mdW5jdGlvbihhKXthLmNzc1RleHQ9cGEodGhpcyxhLnBhcnNlZENzc1RleHQpO1wiOnJvb3RcIj09PWEuc2VsZWN0b3ImJihhLnNlbGVjdG9yPVwiOmhvc3QgPiAqXCIpfTtcbmZ1bmN0aW9uIHBhKGEsYil7Yj1iLnJlcGxhY2UoRixmdW5jdGlvbihiLGQsZSxmKXtyZXR1cm4gcWEoYSxiLGQsZSxmKX0pO3JldHVybiBPKGEsYil9ZnVuY3Rpb24gTyhhLGIpe2Zvcih2YXIgYztjPUcuZXhlYyhiKTspe3ZhciBkPWNbMF0sZT1jWzFdO2M9Yy5pbmRleDt2YXIgZj1iLnNsaWNlKDAsYytkLmluZGV4T2YoXCJAYXBwbHlcIikpO2I9Yi5zbGljZShjK2QubGVuZ3RoKTt2YXIgaD1QKGEsZik7ZD12b2lkIDA7dmFyIGc9YTtlPWUucmVwbGFjZShuYSxcIlwiKTt2YXIgbT1bXTt2YXIgbD1nLmEuZ2V0KGUpO2x8fChnLmEuc2V0KGUse30pLGw9Zy5hLmdldChlKSk7aWYobClmb3IoZCBpbiBnLmMmJihsLmlbZy5jXT0hMCksbC5oKWc9aCYmaFtkXSxsPVtkLFwiOiB2YXIoXCIsZSxcIl8tX1wiLGRdLGcmJmwucHVzaChcIixcIixnKSxsLnB1c2goXCIpXCIpLG0ucHVzaChsLmpvaW4oXCJcIikpO2Q9bS5qb2luKFwiOyBcIik7Yj1cIlwiK2YrZCtiO0cubGFzdEluZGV4PWMrZC5sZW5ndGh9cmV0dXJuIGJ9XG5mdW5jdGlvbiBQKGEsYil7Yj1iLnNwbGl0KFwiO1wiKTtmb3IodmFyIGMsZCxlPXt9LGY9MCxoO2Y8Yi5sZW5ndGg7ZisrKWlmKGM9YltmXSlpZihoPWMuc3BsaXQoXCI6XCIpLDE8aC5sZW5ndGgpe2M9aFswXS50cmltKCk7dmFyIGc9YTtkPWM7aD1oLnNsaWNlKDEpLmpvaW4oXCI6XCIpO3ZhciBtPW9hLmV4ZWMoaCk7bSYmKG1bMV0/KGcuYnx8KGcuYj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibWV0YVwiKSxnLmIuc2V0QXR0cmlidXRlKFwiYXBwbHktc2hpbS1tZWFzdXJlXCIsXCJcIiksZy5iLnN0eWxlLmFsbD1cImluaXRpYWxcIixkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKGcuYikpLGQ9d2luZG93LmdldENvbXB1dGVkU3R5bGUoZy5iKS5nZXRQcm9wZXJ0eVZhbHVlKGQpKTpkPVwiYXBwbHktc2hpbS1pbmhlcml0XCIsaD1kKTtkPWg7ZVtjXT1kfXJldHVybiBlfWZ1bmN0aW9uIHJhKGEsYil7aWYoTSlmb3IodmFyIGMgaW4gYi5pKWMhPT1hLmMmJk0oYyl9XG5mdW5jdGlvbiBxYShhLGIsYyxkLGUpe2QmJksoZCxmdW5jdGlvbihiLGMpe2MmJmEuYS5nZXQoYykmJihlPVwiQGFwcGx5IFwiK2MrXCI7XCIpfSk7aWYoIWUpcmV0dXJuIGI7dmFyIGY9TyhhLGUpLGg9Yi5zbGljZSgwLGIuaW5kZXhPZihcIi0tXCIpKSxnPWY9UChhLGYpLG09YS5hLmdldChjKSxsPW0mJm0uaDtsP2c9T2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKGwpLGYpOmEuYS5zZXQoYyxnKTt2YXIgWD1bXSx3LFk9ITE7Zm9yKHcgaW4gZyl7dmFyIEQ9Zlt3XTt2b2lkIDA9PT1EJiYoRD1cImluaXRpYWxcIik7IWx8fHcgaW4gbHx8KFk9ITApO1gucHVzaChcIlwiK2MrXCJfLV9cIit3K1wiOiBcIitEKX1ZJiZyYShhLG0pO20mJihtLmg9Zyk7ZCYmKGg9YitcIjtcIitoKTtyZXR1cm5cIlwiK2grWC5qb2luKFwiOyBcIikrXCI7XCJ9Ti5wcm90b3R5cGUuZGV0ZWN0TWl4aW49Ti5wcm90b3R5cGUubztOLnByb3RvdHlwZS50cmFuc2Zvcm1TdHlsZT1OLnByb3RvdHlwZS5qO1xuTi5wcm90b3R5cGUudHJhbnNmb3JtQ3VzdG9tU3R5bGU9Ti5wcm90b3R5cGUuZjtOLnByb3RvdHlwZS50cmFuc2Zvcm1SdWxlcz1OLnByb3RvdHlwZS5sO04ucHJvdG90eXBlLnRyYW5zZm9ybVJ1bGU9Ti5wcm90b3R5cGUuZztOLnByb3RvdHlwZS50cmFuc2Zvcm1UZW1wbGF0ZT1OLnByb3RvdHlwZS5tO04ucHJvdG90eXBlLl9zZXBhcmF0b3I9XCJfLV9cIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoTi5wcm90b3R5cGUsXCJpbnZhbGlkQ2FsbGJhY2tcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIE19LHNldDpmdW5jdGlvbihhKXtNPWF9fSk7dmFyIFE9bnVsbCxSPXdpbmRvdy5IVE1MSW1wb3J0cyYmd2luZG93LkhUTUxJbXBvcnRzLndoZW5SZWFkeXx8bnVsbCxTO2Z1bmN0aW9uIHNhKGEpe3JlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbigpe1I/UihhKTooUXx8KFE9bmV3IFByb21pc2UoZnVuY3Rpb24oYSl7Uz1hfSksXCJjb21wbGV0ZVwiPT09ZG9jdW1lbnQucmVhZHlTdGF0ZT9TKCk6ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInJlYWR5c3RhdGVjaGFuZ2VcIixmdW5jdGlvbigpe1wiY29tcGxldGVcIj09PWRvY3VtZW50LnJlYWR5U3RhdGUmJlMoKX0pKSxRLnRoZW4oZnVuY3Rpb24oKXthJiZhKCl9KSl9KX07dmFyIFQ9bmV3IE47ZnVuY3Rpb24gVSgpe3ZhciBhPXRoaXM7dGhpcy5hPW51bGw7c2EoZnVuY3Rpb24oKXtWKGEpfSk7VC5pbnZhbGlkQ2FsbGJhY2s9a2F9ZnVuY3Rpb24gVihhKXthLmF8fChhLmE9d2luZG93LlNoYWR5Q1NTLkN1c3RvbVN0eWxlSW50ZXJmYWNlLGEuYSYmKGEuYS50cmFuc2Zvcm1DYWxsYmFjaz1mdW5jdGlvbihhKXtULmYoYSl9LGEuYS52YWxpZGF0ZUNhbGxiYWNrPWZ1bmN0aW9uKCl7cmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCl7YS5hLmVucXVldWVkJiZXKGEpfSl9KSl9VS5wcm90b3R5cGUucHJlcGFyZVRlbXBsYXRlPWZ1bmN0aW9uKGEsYil7Vih0aGlzKTtrW2JdPWE7Yj1ULm0oYSxiKTthLl9zdHlsZUFzdD1ifTtcbmZ1bmN0aW9uIFcoYSl7VihhKTtpZihhLmEpe3ZhciBiPWEuYS5wcm9jZXNzU3R5bGVzKCk7aWYoYS5hLmVucXVldWVkKXtmb3IodmFyIGM9MDtjPGIubGVuZ3RoO2MrKyl7dmFyIGQ9YS5hLmdldFN0eWxlRm9yQ3VzdG9tU3R5bGUoYltjXSk7ZCYmVC5mKGQpfWEuYS5lbnF1ZXVlZD0hMX19fVUucHJvdG90eXBlLnN0eWxlU3VidHJlZT1mdW5jdGlvbihhLGIpe1YodGhpcyk7aWYoYilmb3IodmFyIGMgaW4gYiludWxsPT09Yz9hLnN0eWxlLnJlbW92ZVByb3BlcnR5KGMpOmEuc3R5bGUuc2V0UHJvcGVydHkoYyxiW2NdKTtpZihhLnNoYWRvd1Jvb3QpZm9yKHRoaXMuc3R5bGVFbGVtZW50KGEpLGE9YS5zaGFkb3dSb290LmNoaWxkcmVufHxhLnNoYWRvd1Jvb3QuY2hpbGROb2RlcyxiPTA7YjxhLmxlbmd0aDtiKyspdGhpcy5zdHlsZVN1YnRyZWUoYVtiXSk7ZWxzZSBmb3IoYT1hLmNoaWxkcmVufHxhLmNoaWxkTm9kZXMsYj0wO2I8YS5sZW5ndGg7YisrKXRoaXMuc3R5bGVTdWJ0cmVlKGFbYl0pfTtcblUucHJvdG90eXBlLnN0eWxlRWxlbWVudD1mdW5jdGlvbihhKXtWKHRoaXMpO3ZhciBiPWEubG9jYWxOYW1lLGM7Yj8tMTxiLmluZGV4T2YoXCItXCIpP2M9YjpjPWEuZ2V0QXR0cmlidXRlJiZhLmdldEF0dHJpYnV0ZShcImlzXCIpfHxcIlwiOmM9YS5pcztpZigoYj1rW2NdKSYmIXooYikpe2lmKHooYil8fGIuX2FwcGx5U2hpbVZhbGlkYXRpbmdWZXJzaW9uIT09Yi5fYXBwbHlTaGltTmV4dFZlcnNpb24pdGhpcy5wcmVwYXJlVGVtcGxhdGUoYixjKSxsYShiKTtpZihhPWEuc2hhZG93Um9vdClpZihhPWEucXVlcnlTZWxlY3RvcihcInN0eWxlXCIpKWEuX19jc3NSdWxlcz1iLl9zdHlsZUFzdCxhLnRleHRDb250ZW50PUgoYi5fc3R5bGVBc3QpfX07VS5wcm90b3R5cGUuc3R5bGVEb2N1bWVudD1mdW5jdGlvbihhKXtWKHRoaXMpO3RoaXMuc3R5bGVTdWJ0cmVlKGRvY3VtZW50LmJvZHksYSl9O1xuaWYoIXdpbmRvdy5TaGFkeUNTU3x8IXdpbmRvdy5TaGFkeUNTUy5TY29waW5nU2hpbSl7dmFyIFo9bmV3IFUsdGE9d2luZG93LlNoYWR5Q1NTJiZ3aW5kb3cuU2hhZHlDU1MuQ3VzdG9tU3R5bGVJbnRlcmZhY2U7d2luZG93LlNoYWR5Q1NTPXtwcmVwYXJlVGVtcGxhdGU6ZnVuY3Rpb24oYSxiKXtXKFopO1oucHJlcGFyZVRlbXBsYXRlKGEsYil9LHN0eWxlU3VidHJlZTpmdW5jdGlvbihhLGIpe1coWik7Wi5zdHlsZVN1YnRyZWUoYSxiKX0sc3R5bGVFbGVtZW50OmZ1bmN0aW9uKGEpe1coWik7Wi5zdHlsZUVsZW1lbnQoYSl9LHN0eWxlRG9jdW1lbnQ6ZnVuY3Rpb24oYSl7VyhaKTtaLnN0eWxlRG9jdW1lbnQoYSl9LGdldENvbXB1dGVkU3R5bGVWYWx1ZTpmdW5jdGlvbihhLGIpe3JldHVybihhPXdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGEpLmdldFByb3BlcnR5VmFsdWUoYikpP2EudHJpbSgpOlwiXCJ9LG5hdGl2ZUNzczpFLG5hdGl2ZVNoYWRvdzpBfTt0YSYmKHdpbmRvdy5TaGFkeUNTUy5DdXN0b21TdHlsZUludGVyZmFjZT1cbnRhKX13aW5kb3cuU2hhZHlDU1MuQXBwbHlTaGltPVQ7fSkuY2FsbCh0aGlzKTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXBwbHktc2hpbS5taW4uanMubWFwXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL3NoYWR5Y3NzL2FwcGx5LXNoaW0ubWluLmpzIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cImJvb3QuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cImFzeW5jLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCJkZWJvdW5jZS5odG1sXCI+XG5cbjxzY3JpcHQ+XG4oZnVuY3Rpb24oKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIGRldGVjdCBuYXRpdmUgdG91Y2ggYWN0aW9uIHN1cHBvcnRcbiAgbGV0IEhBU19OQVRJVkVfVEEgPSB0eXBlb2YgZG9jdW1lbnQuaGVhZC5zdHlsZS50b3VjaEFjdGlvbiA9PT0gJ3N0cmluZyc7XG4gIGxldCBHRVNUVVJFX0tFWSA9ICdfX3BvbHltZXJHZXN0dXJlcyc7XG4gIGxldCBIQU5ETEVEX09CSiA9ICdfX3BvbHltZXJHZXN0dXJlc0hhbmRsZWQnO1xuICBsZXQgVE9VQ0hfQUNUSU9OID0gJ19fcG9seW1lckdlc3R1cmVzVG91Y2hBY3Rpb24nO1xuICAvLyByYWRpdXMgZm9yIHRhcCBhbmQgdHJhY2tcbiAgbGV0IFRBUF9ESVNUQU5DRSA9IDI1O1xuICBsZXQgVFJBQ0tfRElTVEFOQ0UgPSA1O1xuICAvLyBudW1iZXIgb2YgbGFzdCBOIHRyYWNrIHBvc2l0aW9ucyB0byBrZWVwXG4gIGxldCBUUkFDS19MRU5HVEggPSAyO1xuXG4gIC8vIERpc2FibGluZyBcIm1vdXNlXCIgaGFuZGxlcnMgZm9yIDI1MDBtcyBpcyBlbm91Z2hcbiAgbGV0IE1PVVNFX1RJTUVPVVQgPSAyNTAwO1xuICBsZXQgTU9VU0VfRVZFTlRTID0gWydtb3VzZWRvd24nLCAnbW91c2Vtb3ZlJywgJ21vdXNldXAnLCAnY2xpY2snXTtcbiAgLy8gYW4gYXJyYXkgb2YgYml0bWFzayB2YWx1ZXMgZm9yIG1hcHBpbmcgTW91c2VFdmVudC53aGljaCB0byBNb3VzZUV2ZW50LmJ1dHRvbnNcbiAgbGV0IE1PVVNFX1dISUNIX1RPX0JVVFRPTlMgPSBbMCwgMSwgNCwgMl07XG4gIGxldCBNT1VTRV9IQVNfQlVUVE9OUyA9IChmdW5jdGlvbigpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIG5ldyBNb3VzZUV2ZW50KCd0ZXN0Jywge2J1dHRvbnM6IDF9KS5idXR0b25zID09PSAxO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0pKCk7XG5cbiAgLyogZXNsaW50IG5vLWVtcHR5OiBbXCJlcnJvclwiLCB7IFwiYWxsb3dFbXB0eUNhdGNoXCI6IHRydWUgfV0gKi9cbiAgLy8gY2hlY2sgZm9yIHBhc3NpdmUgZXZlbnQgbGlzdGVuZXJzXG4gIGxldCBTVVBQT1JUU19QQVNTSVZFID0gZmFsc2U7XG4gIChmdW5jdGlvbigpIHtcbiAgICB0cnkge1xuICAgICAgbGV0IG9wdHMgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdwYXNzaXZlJywge2dldDogZnVuY3Rpb24oKSB7U1VQUE9SVFNfUEFTU0lWRSA9IHRydWU7fX0pXG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndGVzdCcsIG51bGwsIG9wdHMpO1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Rlc3QnLCBudWxsLCBvcHRzKTtcbiAgICB9IGNhdGNoKGUpIHt9XG4gIH0pKCk7XG5cbiAgLy8gQ2hlY2sgZm9yIHRvdWNoLW9ubHkgZGV2aWNlc1xuICBsZXQgSVNfVE9VQ0hfT05MWSA9IG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL2lQKD86W29hXWR8aG9uZSl8QW5kcm9pZC8pO1xuXG4gIGxldCBHZXN0dXJlUmVjb2duaXplciA9IGZ1bmN0aW9uKCl7fTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICBHZXN0dXJlUmVjb2duaXplci5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbigpe307XG4gIC8qKiBAdHlwZSB7ZnVuY3Rpb24oTW91c2VFdmVudCkgfCB1bmRlZmluZWR9ICovXG4gIEdlc3R1cmVSZWNvZ25pemVyLnByb3RvdHlwZS5tb3VzZWRvd247XG4gIC8qKiBAdHlwZSB7KGZ1bmN0aW9uKE1vdXNlRXZlbnQpIHwgdW5kZWZpbmVkKX0gKi9cbiAgR2VzdHVyZVJlY29nbml6ZXIucHJvdG90eXBlLm1vdXNlbW92ZTtcbiAgLyoqIEB0eXBlIHsoZnVuY3Rpb24oTW91c2VFdmVudCkgfCB1bmRlZmluZWQpfSAqL1xuICBHZXN0dXJlUmVjb2duaXplci5wcm90b3R5cGUubW91c2V1cDtcbiAgLyoqIEB0eXBlIHsoZnVuY3Rpb24oVG91Y2hFdmVudCkgfCB1bmRlZmluZWQpfSAqL1xuICBHZXN0dXJlUmVjb2duaXplci5wcm90b3R5cGUudG91Y2hzdGFydDtcbiAgLyoqIEB0eXBlIHsoZnVuY3Rpb24oVG91Y2hFdmVudCkgfCB1bmRlZmluZWQpfSAqL1xuICBHZXN0dXJlUmVjb2duaXplci5wcm90b3R5cGUudG91Y2htb3ZlO1xuICAvKiogQHR5cGUgeyhmdW5jdGlvbihUb3VjaEV2ZW50KSB8IHVuZGVmaW5lZCl9ICovXG4gIEdlc3R1cmVSZWNvZ25pemVyLnByb3RvdHlwZS50b3VjaGVuZDtcbiAgLyoqIEB0eXBlIHsoZnVuY3Rpb24oTW91c2VFdmVudCkgfCB1bmRlZmluZWQpfSAqL1xuICBHZXN0dXJlUmVjb2duaXplci5wcm90b3R5cGUuY2xpY2s7XG5cbiAgLy8gdG91Y2ggd2lsbCBtYWtlIHN5bnRoZXRpYyBtb3VzZSBldmVudHNcbiAgLy8gYHByZXZlbnREZWZhdWx0YCBvbiB0b3VjaGVuZCB3aWxsIGNhbmNlbCB0aGVtLFxuICAvLyBidXQgdGhpcyBicmVha3MgYDxpbnB1dD5gIGZvY3VzIGFuZCBsaW5rIGNsaWNrc1xuICAvLyBkaXNhYmxlIG1vdXNlIGhhbmRsZXJzIGZvciBNT1VTRV9USU1FT1VUIG1zIGFmdGVyXG4gIC8vIGEgdG91Y2hlbmQgdG8gaWdub3JlIHN5bnRoZXRpYyBtb3VzZSBldmVudHNcbiAgbGV0IG1vdXNlQ2FuY2VsbGVyID0gZnVuY3Rpb24obW91c2VFdmVudCkge1xuICAgIC8vIENoZWNrIGZvciBzb3VyY2VDYXBhYmlsaXRpZXMsIHVzZWQgdG8gZGlzdGluZ3Vpc2ggc3ludGhldGljIGV2ZW50c1xuICAgIC8vIGlmIG1vdXNlRXZlbnQgZGlkIG5vdCBjb21lIGZyb20gYSBkZXZpY2UgdGhhdCBmaXJlcyB0b3VjaCBldmVudHMsXG4gICAgLy8gaXQgd2FzIG1hZGUgYnkgYSByZWFsIG1vdXNlIGFuZCBzaG91bGQgYmUgY291bnRlZFxuICAgIC8vIGh0dHA6Ly93aWNnLmdpdGh1Yi5pby9JbnB1dERldmljZUNhcGFiaWxpdGllcy8jZG9tLWlucHV0ZGV2aWNlY2FwYWJpbGl0aWVzLWZpcmVzdG91Y2hldmVudHNcbiAgICBsZXQgc2MgPSBtb3VzZUV2ZW50LnNvdXJjZUNhcGFiaWxpdGllcztcbiAgICBpZiAoc2MgJiYgIXNjLmZpcmVzVG91Y2hFdmVudHMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gc2tpcCBzeW50aGV0aWMgbW91c2UgZXZlbnRzXG4gICAgbW91c2VFdmVudFtIQU5ETEVEX09CSl0gPSB7c2tpcDogdHJ1ZX07XG4gICAgLy8gZGlzYWJsZSBcImdob3N0IGNsaWNrc1wiXG4gICAgaWYgKG1vdXNlRXZlbnQudHlwZSA9PT0gJ2NsaWNrJykge1xuICAgICAgbGV0IHBhdGggPSBtb3VzZUV2ZW50LmNvbXBvc2VkUGF0aCAmJiBtb3VzZUV2ZW50LmNvbXBvc2VkUGF0aCgpO1xuICAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKHBhdGhbaV0gPT09IFBPSU5URVJTVEFURS5tb3VzZS50YXJnZXQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG1vdXNlRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIG1vdXNlRXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBzZXR1cCBUcnVlIHRvIGFkZCwgZmFsc2UgdG8gcmVtb3ZlLlxuICAgKi9cbiAgZnVuY3Rpb24gc2V0dXBUZWFyZG93bk1vdXNlQ2FuY2VsbGVyKHNldHVwKSB7XG4gICAgbGV0IGV2ZW50cyA9IElTX1RPVUNIX09OTFkgPyBbJ2NsaWNrJ10gOiBNT1VTRV9FVkVOVFM7XG4gICAgZm9yIChsZXQgaSA9IDAsIGVuOyBpIDwgZXZlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBlbiA9IGV2ZW50c1tpXTtcbiAgICAgIGlmIChzZXR1cCkge1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKGVuLCBtb3VzZUNhbmNlbGxlciwgdHJ1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGVuLCBtb3VzZUNhbmNlbGxlciwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaWdub3JlTW91c2UoZSkge1xuICAgIGlmICghUE9JTlRFUlNUQVRFLm1vdXNlLm1vdXNlSWdub3JlSm9iKSB7XG4gICAgICBzZXR1cFRlYXJkb3duTW91c2VDYW5jZWxsZXIodHJ1ZSk7XG4gICAgfVxuICAgIGxldCB1bnNldCA9IGZ1bmN0aW9uKCkge1xuICAgICAgc2V0dXBUZWFyZG93bk1vdXNlQ2FuY2VsbGVyKCk7XG4gICAgICBQT0lOVEVSU1RBVEUubW91c2UudGFyZ2V0ID0gbnVsbDtcbiAgICAgIFBPSU5URVJTVEFURS5tb3VzZS5tb3VzZUlnbm9yZUpvYiA9IG51bGw7XG4gICAgfTtcbiAgICBQT0lOVEVSU1RBVEUubW91c2UudGFyZ2V0ID0gZS5jb21wb3NlZFBhdGgoKVswXTtcbiAgICBQT0lOVEVSU1RBVEUubW91c2UubW91c2VJZ25vcmVKb2IgPSBQb2x5bWVyLkRlYm91bmNlci5kZWJvdW5jZShcbiAgICAgICAgICBQT0lOVEVSU1RBVEUubW91c2UubW91c2VJZ25vcmVKb2JcbiAgICAgICAgLCBQb2x5bWVyLkFzeW5jLnRpbWVPdXQuYWZ0ZXIoTU9VU0VfVElNRU9VVClcbiAgICAgICAgLCB1bnNldCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBldiBldmVudCB0byB0ZXN0IGZvciBsZWZ0IG1vdXNlIGJ1dHRvbiBkb3duXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IGhhcyBsZWZ0IG1vdXNlIGJ1dHRvbiBkb3duXG4gICAqL1xuICBmdW5jdGlvbiBoYXNMZWZ0TW91c2VCdXR0b24oZXYpIHtcbiAgICBsZXQgdHlwZSA9IGV2LnR5cGU7XG4gICAgLy8gZXhpdCBlYXJseSBpZiB0aGUgZXZlbnQgaXMgbm90IGEgbW91c2UgZXZlbnRcbiAgICBpZiAoTU9VU0VfRVZFTlRTLmluZGV4T2YodHlwZSkgPT09IC0xKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIGV2LmJ1dHRvbiBpcyBub3QgcmVsaWFibGUgZm9yIG1vdXNlbW92ZSAoMCBpcyBvdmVybG9hZGVkIGFzIGJvdGggbGVmdCBidXR0b24gYW5kIG5vIGJ1dHRvbnMpXG4gICAgLy8gaW5zdGVhZCB3ZSB1c2UgZXYuYnV0dG9ucyAoYml0bWFzayBvZiBidXR0b25zKSBvciBmYWxsIGJhY2sgdG8gZXYud2hpY2ggKGRlcHJlY2F0ZWQsIDAgZm9yIG5vIGJ1dHRvbnMsIDEgZm9yIGxlZnQgYnV0dG9uKVxuICAgIGlmICh0eXBlID09PSAnbW91c2Vtb3ZlJykge1xuICAgICAgLy8gYWxsb3cgdW5kZWZpbmVkIGZvciB0ZXN0aW5nIGV2ZW50c1xuICAgICAgbGV0IGJ1dHRvbnMgPSBldi5idXR0b25zID09PSB1bmRlZmluZWQgPyAxIDogZXYuYnV0dG9ucztcbiAgICAgIGlmICgoZXYgaW5zdGFuY2VvZiB3aW5kb3cuTW91c2VFdmVudCkgJiYgIU1PVVNFX0hBU19CVVRUT05TKSB7XG4gICAgICAgIGJ1dHRvbnMgPSBNT1VTRV9XSElDSF9UT19CVVRUT05TW2V2LndoaWNoXSB8fCAwO1xuICAgICAgfVxuICAgICAgLy8gYnV0dG9ucyBpcyBhIGJpdG1hc2ssIGNoZWNrIHRoYXQgdGhlIGxlZnQgYnV0dG9uIGJpdCBpcyBzZXQgKDEpXG4gICAgICByZXR1cm4gQm9vbGVhbihidXR0b25zICYgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGFsbG93IHVuZGVmaW5lZCBmb3IgdGVzdGluZyBldmVudHNcbiAgICAgIGxldCBidXR0b24gPSBldi5idXR0b24gPT09IHVuZGVmaW5lZCA/IDAgOiBldi5idXR0b247XG4gICAgICAvLyBldi5idXR0b24gaXMgMCBpbiBtb3VzZWRvd24vbW91c2V1cC9jbGljayBmb3IgbGVmdCBidXR0b24gYWN0aXZhdGlvblxuICAgICAgcmV0dXJuIGJ1dHRvbiA9PT0gMDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc1N5bnRoZXRpY0NsaWNrKGV2KSB7XG4gICAgaWYgKGV2LnR5cGUgPT09ICdjbGljaycpIHtcbiAgICAgIC8vIGV2LmRldGFpbCBpcyAwIGZvciBIVE1MRWxlbWVudC5jbGljayBpbiBtb3N0IGJyb3dzZXJzXG4gICAgICBpZiAoZXYuZGV0YWlsID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgLy8gaW4gdGhlIHdvcnN0IGNhc2UsIGNoZWNrIHRoYXQgdGhlIHgveSBwb3NpdGlvbiBvZiB0aGUgY2xpY2sgaXMgd2l0aGluXG4gICAgICAvLyB0aGUgYm91bmRpbmcgYm94IG9mIHRoZSB0YXJnZXQgb2YgdGhlIGV2ZW50XG4gICAgICAvLyBUaGFua3MgSUUgMTAgPjooXG4gICAgICBsZXQgdCA9IEdlc3R1cmVzLl9maW5kT3JpZ2luYWxUYXJnZXQoZXYpO1xuICAgICAgLy8gbWFrZSBzdXJlIHRoZSB0YXJnZXQgb2YgdGhlIGV2ZW50IGlzIGFuIGVsZW1lbnQgc28gd2UgY2FuIHVzZSBnZXRCb3VuZGluZ0NsaWVudFJlY3QsXG4gICAgICAvLyBpZiBub3QsIGp1c3QgYXNzdW1lIGl0IGlzIGEgc3ludGhldGljIGNsaWNrXG4gICAgICBpZiAoIXQubm9kZVR5cGUgfHwgLyoqIEB0eXBlIHtFbGVtZW50fSAqLyh0KS5ub2RlVHlwZSAhPT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBsZXQgYmNyID0gLyoqIEB0eXBlIHtFbGVtZW50fSAqLyh0KS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIC8vIHVzZSBwYWdlIHgveSB0byBhY2NvdW50IGZvciBzY3JvbGxpbmdcbiAgICAgIGxldCB4ID0gZXYucGFnZVgsIHkgPSBldi5wYWdlWTtcbiAgICAgIC8vIGV2IGlzIGEgc3ludGhldGljIGNsaWNrIGlmIHRoZSBwb3NpdGlvbiBpcyBvdXRzaWRlIHRoZSBib3VuZGluZyBib3ggb2YgdGhlIHRhcmdldFxuICAgICAgcmV0dXJuICEoKHggPj0gYmNyLmxlZnQgJiYgeCA8PSBiY3IucmlnaHQpICYmICh5ID49IGJjci50b3AgJiYgeSA8PSBiY3IuYm90dG9tKSk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGxldCBQT0lOVEVSU1RBVEUgPSB7XG4gICAgbW91c2U6IHtcbiAgICAgIHRhcmdldDogbnVsbCxcbiAgICAgIG1vdXNlSWdub3JlSm9iOiBudWxsXG4gICAgfSxcbiAgICB0b3VjaDoge1xuICAgICAgeDogMCxcbiAgICAgIHk6IDAsXG4gICAgICBpZDogLTEsXG4gICAgICBzY3JvbGxEZWNpZGVkOiBmYWxzZVxuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBmaXJzdFRvdWNoQWN0aW9uKGV2KSB7XG4gICAgbGV0IHRhID0gJ2F1dG8nO1xuICAgIGxldCBwYXRoID0gZXYuY29tcG9zZWRQYXRoICYmIGV2LmNvbXBvc2VkUGF0aCgpO1xuICAgIGlmIChwYXRoKSB7XG4gICAgICBmb3IgKGxldCBpID0gMCwgbjsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbiA9IHBhdGhbaV07XG4gICAgICAgIGlmIChuW1RPVUNIX0FDVElPTl0pIHtcbiAgICAgICAgICB0YSA9IG5bVE9VQ0hfQUNUSU9OXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGE7XG4gIH1cblxuICBmdW5jdGlvbiB0cmFja0RvY3VtZW50KHN0YXRlT2JqLCBtb3ZlZm4sIHVwZm4pIHtcbiAgICBzdGF0ZU9iai5tb3ZlZm4gPSBtb3ZlZm47XG4gICAgc3RhdGVPYmoudXBmbiA9IHVwZm47XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgbW92ZWZuKTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdXBmbik7XG4gIH1cblxuICBmdW5jdGlvbiB1bnRyYWNrRG9jdW1lbnQoc3RhdGVPYmopIHtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBzdGF0ZU9iai5tb3ZlZm4pO1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBzdGF0ZU9iai51cGZuKTtcbiAgICBzdGF0ZU9iai5tb3ZlZm4gPSBudWxsO1xuICAgIHN0YXRlT2JqLnVwZm4gPSBudWxsO1xuICB9XG5cbiAgLy8gdXNlIGEgZG9jdW1lbnQtd2lkZSB0b3VjaGVuZCBsaXN0ZW5lciB0byBzdGFydCB0aGUgZ2hvc3QtY2xpY2sgcHJldmVudGlvbiBtZWNoYW5pc21cbiAgLy8gVXNlIHBhc3NpdmUgZXZlbnQgbGlzdGVuZXJzLCBpZiBzdXBwb3J0ZWQsIHRvIG5vdCBhZmZlY3Qgc2Nyb2xsaW5nIHBlcmZvcm1hbmNlXG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgaWdub3JlTW91c2UsIFNVUFBPUlRTX1BBU1NJVkUgPyB7cGFzc2l2ZTogdHJ1ZX0gOiBmYWxzZSk7XG5cbiAgLyoqXG4gICAqIE1vZHVsZSBmb3IgYWRkaW5nIGxpc3RlbmVycyB0byBhIG5vZGUgZm9yIHRoZSBmb2xsb3dpbmcgbm9ybWFsaXplZFxuICAgKiBjcm9zcy1wbGF0Zm9ybSBcImdlc3R1cmVcIiBldmVudHM6XG4gICAqIC0gYGRvd25gIC0gbW91c2Ugb3IgdG91Y2ggd2VudCBkb3duXG4gICAqIC0gYHVwYCAtIG1vdXNlIG9yIHRvdWNoIHdlbnQgdXBcbiAgICogLSBgdGFwYCAtIG1vdXNlIGNsaWNrIG9yIGZpbmdlciB0YXBcbiAgICogLSBgdHJhY2tgIC0gbW91c2UgZHJhZyBvciB0b3VjaCBtb3ZlXG4gICAqXG4gICAqIEBuYW1lc3BhY2VcbiAgICogQG1lbWJlcm9mIFBvbHltZXJcbiAgICogQHN1bW1hcnkgTW9kdWxlIGZvciBhZGRpbmcgY3Jvc3MtcGxhdGZvcm0gZ2VzdHVyZSBldmVudCBsaXN0ZW5lcnMuXG4gICAqL1xuICBjb25zdCBHZXN0dXJlcyA9IHtcbiAgICBnZXN0dXJlczoge30sXG4gICAgcmVjb2duaXplcnM6IFtdLFxuXG4gICAgLyoqXG4gICAgICogRmluZHMgdGhlIGVsZW1lbnQgcmVuZGVyZWQgb24gdGhlIHNjcmVlbiBhdCB0aGUgcHJvdmlkZWQgY29vcmRpbmF0ZXMuXG4gICAgICpcbiAgICAgKiBTaW1pbGFyIHRvIGBkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50YCwgYnV0IHBpZXJjZXMgdGhyb3VnaFxuICAgICAqIHNoYWRvdyByb290cy5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBQb2x5bWVyLkdlc3R1cmVzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggSG9yaXpvbnRhbCBwaXhlbCBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgVmVydGljYWwgcGl4ZWwgY29vcmRpbmF0ZVxuICAgICAqIEByZXR1cm4ge0VsZW1lbnR9IFJldHVybnMgdGhlIGRlZXBlc3Qgc2hhZG93Um9vdCBpbmNsdXNpdmUgZWxlbWVudFxuICAgICAqIGZvdW5kIGF0IHRoZSBzY3JlZW4gcG9zaXRpb24gZ2l2ZW4uXG4gICAgICovXG4gICAgZGVlcFRhcmdldEZpbmQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgIGxldCBub2RlID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludCh4LCB5KTtcbiAgICAgIGxldCBuZXh0ID0gbm9kZTtcbiAgICAgIC8vIHRoaXMgY29kZSBwYXRoIGlzIG9ubHkgdGFrZW4gd2hlbiBuYXRpdmUgU2hhZG93RE9NIGlzIHVzZWRcbiAgICAgIC8vIGlmIHRoZXJlIGlzIGEgc2hhZG93cm9vdCwgaXQgbWF5IGhhdmUgYSBub2RlIGF0IHgveVxuICAgICAgLy8gaWYgdGhlcmUgaXMgbm90IGEgc2hhZG93cm9vdCwgZXhpdCB0aGUgbG9vcFxuICAgICAgd2hpbGUgKG5leHQgJiYgbmV4dC5zaGFkb3dSb290ICYmICF3aW5kb3cuU2hhZHlET00pIHtcbiAgICAgICAgLy8gaWYgdGhlcmUgaXMgYSBub2RlIGF0IHgveSBpbiB0aGUgc2hhZG93cm9vdCwgbG9vayBkZWVwZXJcbiAgICAgICAgbGV0IG9sZE5leHQgPSBuZXh0O1xuICAgICAgICBuZXh0ID0gbmV4dC5zaGFkb3dSb290LmVsZW1lbnRGcm9tUG9pbnQoeCwgeSk7XG4gICAgICAgIC8vIG9uIFNhZmFyaSwgZWxlbWVudEZyb21Qb2ludCBtYXkgcmV0dXJuIHRoZSBzaGFkb3dSb290IGhvc3RcbiAgICAgICAgaWYgKG9sZE5leHQgPT09IG5leHQpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAobmV4dCkge1xuICAgICAgICAgIG5vZGUgPSBuZXh0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIGEgY2hlYXBlciBjaGVjayB0aGFuIGV2LmNvbXBvc2VkUGF0aCgpWzBdO1xuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBldiBFdmVudC5cbiAgICAgKiBAcmV0dXJuIHtFdmVudFRhcmdldH0gUmV0dXJucyB0aGUgZXZlbnQgdGFyZ2V0LlxuICAgICAqL1xuICAgIF9maW5kT3JpZ2luYWxUYXJnZXQ6IGZ1bmN0aW9uKGV2KSB7XG4gICAgICAvLyBzaGFkb3dkb21cbiAgICAgIGlmIChldi5jb21wb3NlZFBhdGgpIHtcbiAgICAgICAgcmV0dXJuIC8qKiBAdHlwZSB7RXZlbnRUYXJnZXR9ICovKGV2LmNvbXBvc2VkUGF0aCgpWzBdKTtcbiAgICAgIH1cbiAgICAgIC8vIHNoYWR5ZG9tXG4gICAgICByZXR1cm4gZXYudGFyZ2V0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2IEV2ZW50LlxuICAgICAqL1xuICAgIF9oYW5kbGVOYXRpdmU6IGZ1bmN0aW9uKGV2KSB7XG4gICAgICBsZXQgaGFuZGxlZDtcbiAgICAgIGxldCB0eXBlID0gZXYudHlwZTtcbiAgICAgIGxldCBub2RlID0gZXYuY3VycmVudFRhcmdldDtcbiAgICAgIGxldCBnb2JqID0gbm9kZVtHRVNUVVJFX0tFWV07XG4gICAgICBpZiAoIWdvYmopIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGV0IGdzID0gZ29ialt0eXBlXTtcbiAgICAgIGlmICghZ3MpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCFldltIQU5ETEVEX09CSl0pIHtcbiAgICAgICAgZXZbSEFORExFRF9PQkpdID0ge307XG4gICAgICAgIGlmICh0eXBlLnNsaWNlKDAsIDUpID09PSAndG91Y2gnKSB7XG4gICAgICAgICAgZXYgPSAvKiogQHR5cGUge1RvdWNoRXZlbnR9ICovKGV2KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWFzc2lnblxuICAgICAgICAgIGxldCB0ID0gZXYuY2hhbmdlZFRvdWNoZXNbMF07XG4gICAgICAgICAgaWYgKHR5cGUgPT09ICd0b3VjaHN0YXJ0Jykge1xuICAgICAgICAgICAgLy8gb25seSBoYW5kbGUgdGhlIGZpcnN0IGZpbmdlclxuICAgICAgICAgICAgaWYgKGV2LnRvdWNoZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgIFBPSU5URVJTVEFURS50b3VjaC5pZCA9IHQuaWRlbnRpZmllcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKFBPSU5URVJTVEFURS50b3VjaC5pZCAhPT0gdC5pZGVudGlmaWVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghSEFTX05BVElWRV9UQSkge1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09ICd0b3VjaHN0YXJ0JyB8fCB0eXBlID09PSAndG91Y2htb3ZlJykge1xuICAgICAgICAgICAgICBHZXN0dXJlcy5faGFuZGxlVG91Y2hBY3Rpb24oZXYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaGFuZGxlZCA9IGV2W0hBTkRMRURfT0JKXTtcbiAgICAgIC8vIHVzZWQgdG8gaWdub3JlIHN5bnRoZXRpYyBtb3VzZSBldmVudHNcbiAgICAgIGlmIChoYW5kbGVkLnNraXApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGV0IHJlY29nbml6ZXJzID0gR2VzdHVyZXMucmVjb2duaXplcnM7XG4gICAgICAvLyByZXNldCByZWNvZ25pemVyIHN0YXRlXG4gICAgICBmb3IgKGxldCBpID0gMCwgcjsgaSA8IHJlY29nbml6ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHIgPSByZWNvZ25pemVyc1tpXTtcbiAgICAgICAgaWYgKGdzW3IubmFtZV0gJiYgIWhhbmRsZWRbci5uYW1lXSkge1xuICAgICAgICAgIGlmIChyLmZsb3cgJiYgci5mbG93LnN0YXJ0LmluZGV4T2YoZXYudHlwZSkgPiAtMSAmJiByLnJlc2V0KSB7XG4gICAgICAgICAgICByLnJlc2V0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBlbmZvcmNlIGdlc3R1cmUgcmVjb2duaXplciBvcmRlclxuICAgICAgZm9yIChsZXQgaSA9IDAsIHI7IGkgPCByZWNvZ25pemVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICByID0gcmVjb2duaXplcnNbaV07XG4gICAgICAgIGlmIChnc1tyLm5hbWVdICYmICFoYW5kbGVkW3IubmFtZV0pIHtcbiAgICAgICAgICBoYW5kbGVkW3IubmFtZV0gPSB0cnVlO1xuICAgICAgICAgIHJbdHlwZV0oZXYpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtUb3VjaEV2ZW50fSBldiBFdmVudC5cbiAgICAgKi9cbiAgICBfaGFuZGxlVG91Y2hBY3Rpb246IGZ1bmN0aW9uKGV2KSB7XG4gICAgICBsZXQgdCA9IGV2LmNoYW5nZWRUb3VjaGVzWzBdO1xuICAgICAgbGV0IHR5cGUgPSBldi50eXBlO1xuICAgICAgaWYgKHR5cGUgPT09ICd0b3VjaHN0YXJ0Jykge1xuICAgICAgICBQT0lOVEVSU1RBVEUudG91Y2gueCA9IHQuY2xpZW50WDtcbiAgICAgICAgUE9JTlRFUlNUQVRFLnRvdWNoLnkgPSB0LmNsaWVudFk7XG4gICAgICAgIFBPSU5URVJTVEFURS50b3VjaC5zY3JvbGxEZWNpZGVkID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICd0b3VjaG1vdmUnKSB7XG4gICAgICAgIGlmIChQT0lOVEVSU1RBVEUudG91Y2guc2Nyb2xsRGVjaWRlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBQT0lOVEVSU1RBVEUudG91Y2guc2Nyb2xsRGVjaWRlZCA9IHRydWU7XG4gICAgICAgIGxldCB0YSA9IGZpcnN0VG91Y2hBY3Rpb24oZXYpO1xuICAgICAgICBsZXQgcHJldmVudCA9IGZhbHNlO1xuICAgICAgICBsZXQgZHggPSBNYXRoLmFicyhQT0lOVEVSU1RBVEUudG91Y2gueCAtIHQuY2xpZW50WCk7XG4gICAgICAgIGxldCBkeSA9IE1hdGguYWJzKFBPSU5URVJTVEFURS50b3VjaC55IC0gdC5jbGllbnRZKTtcbiAgICAgICAgaWYgKCFldi5jYW5jZWxhYmxlKSB7XG4gICAgICAgICAgLy8gc2Nyb2xsaW5nIGlzIGhhcHBlbmluZ1xuICAgICAgICB9IGVsc2UgaWYgKHRhID09PSAnbm9uZScpIHtcbiAgICAgICAgICBwcmV2ZW50ID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmICh0YSA9PT0gJ3Bhbi14Jykge1xuICAgICAgICAgIHByZXZlbnQgPSBkeSA+IGR4O1xuICAgICAgICB9IGVsc2UgaWYgKHRhID09PSAncGFuLXknKSB7XG4gICAgICAgICAgcHJldmVudCA9IGR4ID4gZHk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByZXZlbnQpIHtcbiAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIEdlc3R1cmVzLnByZXZlbnQoJ3RyYWNrJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhbiBldmVudCBsaXN0ZW5lciB0byBhIG5vZGUgZm9yIHRoZSBnaXZlbiBnZXN0dXJlIHR5cGUuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgUG9seW1lci5HZXN0dXJlc1xuICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBOb2RlIHRvIGFkZCBsaXN0ZW5lciBvblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldlR5cGUgR2VzdHVyZSB0eXBlOiBgZG93bmAsIGB1cGAsIGB0cmFja2AsIG9yIGB0YXBgXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciBFdmVudCBsaXN0ZW5lciBmdW5jdGlvbiB0byBjYWxsXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIGEgZ2VzdHVyZSBldmVudCBsaXN0ZW5lciB3YXMgYWRkZWQuXG4gICAgICogQHRoaXMge0dlc3R1cmVzfVxuICAgICAqL1xuICAgIGFkZExpc3RlbmVyOiBmdW5jdGlvbihub2RlLCBldlR5cGUsIGhhbmRsZXIpIHtcbiAgICAgIGlmICh0aGlzLmdlc3R1cmVzW2V2VHlwZV0pIHtcbiAgICAgICAgdGhpcy5fYWRkKG5vZGUsIGV2VHlwZSwgaGFuZGxlcik7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFuIGV2ZW50IGxpc3RlbmVyIGZyb20gYSBub2RlIGZvciB0aGUgZ2l2ZW4gZ2VzdHVyZSB0eXBlLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIFBvbHltZXIuR2VzdHVyZXNcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgTm9kZSB0byByZW1vdmUgbGlzdGVuZXIgZnJvbVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldlR5cGUgR2VzdHVyZSB0eXBlOiBgZG93bmAsIGB1cGAsIGB0cmFja2AsIG9yIGB0YXBgXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciBFdmVudCBsaXN0ZW5lciBmdW5jdGlvbiBwcmV2aW91c2x5IHBhc3NlZCB0b1xuICAgICAqICBgYWRkTGlzdGVuZXJgLlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiBhIGdlc3R1cmUgZXZlbnQgbGlzdGVuZXIgd2FzIHJlbW92ZWQuXG4gICAgICogQHRoaXMge0dlc3R1cmVzfVxuICAgICAqL1xuICAgIHJlbW92ZUxpc3RlbmVyOiBmdW5jdGlvbihub2RlLCBldlR5cGUsIGhhbmRsZXIpIHtcbiAgICAgIGlmICh0aGlzLmdlc3R1cmVzW2V2VHlwZV0pIHtcbiAgICAgICAgdGhpcy5fcmVtb3ZlKG5vZGUsIGV2VHlwZSwgaGFuZGxlcik7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBhdXRvbWF0ZSB0aGUgZXZlbnQgbGlzdGVuZXJzIGZvciB0aGUgbmF0aXZlIGV2ZW50c1xuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBub2RlIE5vZGUgb24gd2hpY2ggdG8gYWRkIHRoZSBldmVudC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZUeXBlIEV2ZW50IHR5cGUgdG8gYWRkLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oRXZlbnQ/KX0gaGFuZGxlciBFdmVudCBoYW5kbGVyIGZ1bmN0aW9uLlxuICAgICAqIEB0aGlzIHtHZXN0dXJlc31cbiAgICAgKi9cbiAgICBfYWRkOiBmdW5jdGlvbihub2RlLCBldlR5cGUsIGhhbmRsZXIpIHtcbiAgICAgIGxldCByZWNvZ25pemVyID0gdGhpcy5nZXN0dXJlc1tldlR5cGVdO1xuICAgICAgbGV0IGRlcHMgPSByZWNvZ25pemVyLmRlcHM7XG4gICAgICBsZXQgbmFtZSA9IHJlY29nbml6ZXIubmFtZTtcbiAgICAgIGxldCBnb2JqID0gbm9kZVtHRVNUVVJFX0tFWV07XG4gICAgICBpZiAoIWdvYmopIHtcbiAgICAgICAgbm9kZVtHRVNUVVJFX0tFWV0gPSBnb2JqID0ge307XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBpID0gMCwgZGVwLCBnZDsgaSA8IGRlcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZGVwID0gZGVwc1tpXTtcbiAgICAgICAgLy8gZG9uJ3QgYWRkIG1vdXNlIGhhbmRsZXJzIG9uIGlPUyBiZWNhdXNlIHRoZXkgY2F1c2UgZ3JheSBzZWxlY3Rpb24gb3ZlcmxheXNcbiAgICAgICAgaWYgKElTX1RPVUNIX09OTFkgJiYgTU9VU0VfRVZFTlRTLmluZGV4T2YoZGVwKSA+IC0xICYmIGRlcCAhPT0gJ2NsaWNrJykge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGdkID0gZ29ialtkZXBdO1xuICAgICAgICBpZiAoIWdkKSB7XG4gICAgICAgICAgZ29ialtkZXBdID0gZ2QgPSB7X2NvdW50OiAwfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ2QuX2NvdW50ID09PSAwKSB7XG4gICAgICAgICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKGRlcCwgdGhpcy5faGFuZGxlTmF0aXZlKTtcbiAgICAgICAgfVxuICAgICAgICBnZFtuYW1lXSA9IChnZFtuYW1lXSB8fCAwKSArIDE7XG4gICAgICAgIGdkLl9jb3VudCA9IChnZC5fY291bnQgfHwgMCkgKyAxO1xuICAgICAgfVxuICAgICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKGV2VHlwZSwgaGFuZGxlcik7XG4gICAgICBpZiAocmVjb2duaXplci50b3VjaEFjdGlvbikge1xuICAgICAgICB0aGlzLnNldFRvdWNoQWN0aW9uKG5vZGUsIHJlY29nbml6ZXIudG91Y2hBY3Rpb24pO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBhdXRvbWF0ZSBldmVudCBsaXN0ZW5lciByZW1vdmFsIGZvciBuYXRpdmUgZXZlbnRzXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG5vZGUgTm9kZSBvbiB3aGljaCB0byByZW1vdmUgdGhlIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldlR5cGUgRXZlbnQgdHlwZSB0byByZW1vdmUuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihFdmVudD8pfSBoYW5kbGVyIEV2ZW50IGhhbmRsZXIgZnVuY3Rpb24uXG4gICAgICogQHRoaXMge0dlc3R1cmVzfVxuICAgICAqL1xuICAgIF9yZW1vdmU6IGZ1bmN0aW9uKG5vZGUsIGV2VHlwZSwgaGFuZGxlcikge1xuICAgICAgbGV0IHJlY29nbml6ZXIgPSB0aGlzLmdlc3R1cmVzW2V2VHlwZV07XG4gICAgICBsZXQgZGVwcyA9IHJlY29nbml6ZXIuZGVwcztcbiAgICAgIGxldCBuYW1lID0gcmVjb2duaXplci5uYW1lO1xuICAgICAgbGV0IGdvYmogPSBub2RlW0dFU1RVUkVfS0VZXTtcbiAgICAgIGlmIChnb2JqKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBkZXAsIGdkOyBpIDwgZGVwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGRlcCA9IGRlcHNbaV07XG4gICAgICAgICAgZ2QgPSBnb2JqW2RlcF07XG4gICAgICAgICAgaWYgKGdkICYmIGdkW25hbWVdKSB7XG4gICAgICAgICAgICBnZFtuYW1lXSA9IChnZFtuYW1lXSB8fCAxKSAtIDE7XG4gICAgICAgICAgICBnZC5fY291bnQgPSAoZ2QuX2NvdW50IHx8IDEpIC0gMTtcbiAgICAgICAgICAgIGlmIChnZC5fY291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKGRlcCwgdGhpcy5faGFuZGxlTmF0aXZlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihldlR5cGUsIGhhbmRsZXIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYSBuZXcgZ2VzdHVyZSBldmVudCByZWNvZ25pemVyIGZvciBhZGRpbmcgbmV3IGN1c3RvbVxuICAgICAqIGdlc3R1cmUgZXZlbnQgdHlwZXMuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgUG9seW1lci5HZXN0dXJlc1xuICAgICAqIEBwYXJhbSB7R2VzdHVyZVJlY29nbml6ZXJ9IHJlY29nIEdlc3R1cmUgcmVjb2duaXplciBkZXNjcmlwdG9yXG4gICAgICogQHRoaXMge0dlc3R1cmVzfVxuICAgICAqL1xuICAgIHJlZ2lzdGVyOiBmdW5jdGlvbihyZWNvZykge1xuICAgICAgdGhpcy5yZWNvZ25pemVycy5wdXNoKHJlY29nKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVjb2cuZW1pdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5nZXN0dXJlc1tyZWNvZy5lbWl0c1tpXV0gPSByZWNvZztcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZOYW1lIEV2ZW50IG5hbWUuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBSZXR1cm5zIHRoZSBnZXN0dXJlIGZvciB0aGUgZ2l2ZW4gZXZlbnQgbmFtZS5cbiAgICAgKiBAdGhpcyB7R2VzdHVyZXN9XG4gICAgICovXG4gICAgX2ZpbmRSZWNvZ25pemVyQnlFdmVudDogZnVuY3Rpb24oZXZOYW1lKSB7XG4gICAgICBmb3IgKGxldCBpID0gMCwgcjsgaSA8IHRoaXMucmVjb2duaXplcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgciA9IHRoaXMucmVjb2duaXplcnNbaV07XG4gICAgICAgIGZvciAobGV0IGogPSAwLCBuOyBqIDwgci5lbWl0cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIG4gPSByLmVtaXRzW2pdO1xuICAgICAgICAgIGlmIChuID09PSBldk5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiByO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgc2Nyb2xsaW5nIGRpcmVjdGlvbiBvbiBub2RlLlxuICAgICAqXG4gICAgICogVGhpcyB2YWx1ZSBpcyBjaGVja2VkIG9uIGZpcnN0IG1vdmUsIHRodXMgaXQgc2hvdWxkIGJlIGNhbGxlZCBwcmlvciB0b1xuICAgICAqIGFkZGluZyBldmVudCBsaXN0ZW5lcnMuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgUG9seW1lci5HZXN0dXJlc1xuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZSBOb2RlIHRvIHNldCB0b3VjaCBhY3Rpb24gc2V0dGluZyBvblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSBUb3VjaCBhY3Rpb24gdmFsdWVcbiAgICAgKi9cbiAgICBzZXRUb3VjaEFjdGlvbjogZnVuY3Rpb24obm9kZSwgdmFsdWUpIHtcbiAgICAgIGlmIChIQVNfTkFUSVZFX1RBKSB7XG4gICAgICAgIG5vZGUuc3R5bGUudG91Y2hBY3Rpb24gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIG5vZGVbVE9VQ0hfQUNUSU9OXSA9IHZhbHVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEaXNwYXRjaGVzIGFuIGV2ZW50IG9uIHRoZSBgdGFyZ2V0YCBlbGVtZW50IG9mIGB0eXBlYCB3aXRoIHRoZSBnaXZlblxuICAgICAqIGBkZXRhaWxgLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudFRhcmdldH0gdGFyZ2V0IFRoZSBlbGVtZW50IG9uIHdoaWNoIHRvIGZpcmUgYW4gZXZlbnQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgVGhlIHR5cGUgb2YgZXZlbnQgdG8gZmlyZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdD19IGRldGFpbCBUaGUgZGV0YWlsIG9iamVjdCB0byBwb3B1bGF0ZSBvbiB0aGUgZXZlbnQuXG4gICAgICovXG4gICAgX2ZpcmU6IGZ1bmN0aW9uKHRhcmdldCwgdHlwZSwgZGV0YWlsKSB7XG4gICAgICBsZXQgZXYgPSBuZXcgRXZlbnQodHlwZSwgeyBidWJibGVzOiB0cnVlLCBjYW5jZWxhYmxlOiB0cnVlLCBjb21wb3NlZDogdHJ1ZSB9KTtcbiAgICAgIGV2LmRldGFpbCA9IGRldGFpbDtcbiAgICAgIHRhcmdldC5kaXNwYXRjaEV2ZW50KGV2KTtcbiAgICAgIC8vIGZvcndhcmQgYHByZXZlbnREZWZhdWx0YCBpbiBhIGNsZWFuIHdheVxuICAgICAgaWYgKGV2LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgbGV0IHByZXZlbnRlciA9IGRldGFpbC5wcmV2ZW50ZXIgfHwgZGV0YWlsLnNvdXJjZUV2ZW50O1xuICAgICAgICBpZiAocHJldmVudGVyICYmIHByZXZlbnRlci5wcmV2ZW50RGVmYXVsdCkge1xuICAgICAgICAgIHByZXZlbnRlci5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFByZXZlbnRzIHRoZSBkaXNwYXRjaCBhbmQgZGVmYXVsdCBhY3Rpb24gb2YgdGhlIGdpdmVuIGV2ZW50IG5hbWUuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgUG9seW1lci5HZXN0dXJlc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldk5hbWUgRXZlbnQgbmFtZS5cbiAgICAgKiBAdGhpcyB7R2VzdHVyZXN9XG4gICAgICovXG4gICAgcHJldmVudDogZnVuY3Rpb24oZXZOYW1lKSB7XG4gICAgICBsZXQgcmVjb2duaXplciA9IHRoaXMuX2ZpbmRSZWNvZ25pemVyQnlFdmVudChldk5hbWUpO1xuICAgICAgaWYgKHJlY29nbml6ZXIuaW5mbykge1xuICAgICAgICByZWNvZ25pemVyLmluZm8ucHJldmVudCA9IHRydWU7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlc2V0IHRoZSAyNTAwbXMgdGltZW91dCBvbiBwcm9jZXNzaW5nIG1vdXNlIGlucHV0IGFmdGVyIGRldGVjdGluZyB0b3VjaCBpbnB1dC5cbiAgICAgKlxuICAgICAqIFRvdWNoIGlucHV0cyBjcmVhdGUgc3ludGhlc2l6ZWQgbW91c2UgaW5wdXRzIGFueXdoZXJlIGZyb20gMCB0byAyMDAwbXMgYWZ0ZXIgdGhlIHRvdWNoLlxuICAgICAqIFRoaXMgbWV0aG9kIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBkdXJpbmcgdGVzdGluZyB3aXRoIHNpbXVsYXRlZCB0b3VjaCBpbnB1dHMuXG4gICAgICogQ2FsbGluZyB0aGlzIG1ldGhvZCBpbiBwcm9kdWN0aW9uIG1heSBjYXVzZSBkdXBsaWNhdGUgdGFwcyBvciBvdGhlciBHZXN0dXJlcy5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBQb2x5bWVyLkdlc3R1cmVzXG4gICAgICovXG4gICAgcmVzZXRNb3VzZUNhbmNlbGxlcjogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoUE9JTlRFUlNUQVRFLm1vdXNlLm1vdXNlSWdub3JlSm9iKSB7XG4gICAgICAgIFBPSU5URVJTVEFURS5tb3VzZS5tb3VzZUlnbm9yZUpvYi5mbHVzaCgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKiBlc2xpbnQtZGlzYWJsZSB2YWxpZC1qc2RvYyAqL1xuXG4gIEdlc3R1cmVzLnJlZ2lzdGVyKHtcbiAgICBuYW1lOiAnZG93bnVwJyxcbiAgICBkZXBzOiBbJ21vdXNlZG93bicsICd0b3VjaHN0YXJ0JywgJ3RvdWNoZW5kJ10sXG4gICAgZmxvdzoge1xuICAgICAgc3RhcnQ6IFsnbW91c2Vkb3duJywgJ3RvdWNoc3RhcnQnXSxcbiAgICAgIGVuZDogWydtb3VzZXVwJywgJ3RvdWNoZW5kJ11cbiAgICB9LFxuICAgIGVtaXRzOiBbJ2Rvd24nLCAndXAnXSxcblxuICAgIGluZm86IHtcbiAgICAgIG1vdmVmbjogbnVsbCxcbiAgICAgIHVwZm46IG51bGxcbiAgICB9LFxuXG4gICAgLyoqIEB0aGlzIHtHZXN0dXJlUmVjb2duaXplcn0gKi9cbiAgICByZXNldDogZnVuY3Rpb24oKSB7XG4gICAgICB1bnRyYWNrRG9jdW1lbnQodGhpcy5pbmZvKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHRoaXMge0dlc3R1cmVSZWNvZ25pemVyfVxuICAgICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZVxuICAgICAqL1xuICAgIG1vdXNlZG93bjogZnVuY3Rpb24oZSkge1xuICAgICAgaWYgKCFoYXNMZWZ0TW91c2VCdXR0b24oZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGV0IHQgPSBHZXN0dXJlcy5fZmluZE9yaWdpbmFsVGFyZ2V0KGUpO1xuICAgICAgbGV0IHNlbGYgPSB0aGlzO1xuICAgICAgbGV0IG1vdmVmbiA9IGZ1bmN0aW9uIG1vdmVmbihlKSB7XG4gICAgICAgIGlmICghaGFzTGVmdE1vdXNlQnV0dG9uKGUpKSB7XG4gICAgICAgICAgc2VsZi5fZmlyZSgndXAnLCB0LCBlKTtcbiAgICAgICAgICB1bnRyYWNrRG9jdW1lbnQoc2VsZi5pbmZvKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGxldCB1cGZuID0gZnVuY3Rpb24gdXBmbihlKSB7XG4gICAgICAgIGlmIChoYXNMZWZ0TW91c2VCdXR0b24oZSkpIHtcbiAgICAgICAgICBzZWxmLl9maXJlKCd1cCcsIHQsIGUpO1xuICAgICAgICB9XG4gICAgICAgIHVudHJhY2tEb2N1bWVudChzZWxmLmluZm8pO1xuICAgICAgfTtcbiAgICAgIHRyYWNrRG9jdW1lbnQodGhpcy5pbmZvLCBtb3ZlZm4sIHVwZm4pO1xuICAgICAgdGhpcy5fZmlyZSgnZG93bicsIHQsIGUpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQHRoaXMge0dlc3R1cmVSZWNvZ25pemVyfVxuICAgICAqIEBwYXJhbSB7VG91Y2hFdmVudH0gZVxuICAgICAqL1xuICAgIHRvdWNoc3RhcnQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgIHRoaXMuX2ZpcmUoJ2Rvd24nLCBHZXN0dXJlcy5fZmluZE9yaWdpbmFsVGFyZ2V0KGUpLCBlLmNoYW5nZWRUb3VjaGVzWzBdLCBlKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEB0aGlzIHtHZXN0dXJlUmVjb2duaXplcn1cbiAgICAgKiBAcGFyYW0ge1RvdWNoRXZlbnR9IGVcbiAgICAgKi9cbiAgICB0b3VjaGVuZDogZnVuY3Rpb24oZSkge1xuICAgICAgdGhpcy5fZmlyZSgndXAnLCBHZXN0dXJlcy5fZmluZE9yaWdpbmFsVGFyZ2V0KGUpLCBlLmNoYW5nZWRUb3VjaGVzWzBdLCBlKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAgICogQHBhcmFtIHtFdmVudFRhcmdldH0gdGFyZ2V0XG4gICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmV2ZW50ZXJcbiAgICAgKi9cbiAgICBfZmlyZTogZnVuY3Rpb24odHlwZSwgdGFyZ2V0LCBldmVudCwgcHJldmVudGVyKSB7XG4gICAgICBHZXN0dXJlcy5fZmlyZSh0YXJnZXQsIHR5cGUsIHtcbiAgICAgICAgeDogZXZlbnQuY2xpZW50WCxcbiAgICAgICAgeTogZXZlbnQuY2xpZW50WSxcbiAgICAgICAgc291cmNlRXZlbnQ6IGV2ZW50LFxuICAgICAgICBwcmV2ZW50ZXI6IHByZXZlbnRlcixcbiAgICAgICAgcHJldmVudDogZnVuY3Rpb24oZSkge1xuICAgICAgICAgIHJldHVybiBHZXN0dXJlcy5wcmV2ZW50KGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuXG4gIEdlc3R1cmVzLnJlZ2lzdGVyKHtcbiAgICBuYW1lOiAndHJhY2snLFxuICAgIHRvdWNoQWN0aW9uOiAnbm9uZScsXG4gICAgZGVwczogWydtb3VzZWRvd24nLCAndG91Y2hzdGFydCcsICd0b3VjaG1vdmUnLCAndG91Y2hlbmQnXSxcbiAgICBmbG93OiB7XG4gICAgICBzdGFydDogWydtb3VzZWRvd24nLCAndG91Y2hzdGFydCddLFxuICAgICAgZW5kOiBbJ21vdXNldXAnLCAndG91Y2hlbmQnXVxuICAgIH0sXG4gICAgZW1pdHM6IFsndHJhY2snXSxcblxuICAgIGluZm86IHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwLFxuICAgICAgc3RhdGU6ICdzdGFydCcsXG4gICAgICBzdGFydGVkOiBmYWxzZSxcbiAgICAgIG1vdmVzOiBbXSxcbiAgICAgIC8qKiBAdGhpcyB7R2VzdHVyZVJlY29nbml6ZXJ9ICovXG4gICAgICBhZGRNb3ZlOiBmdW5jdGlvbihtb3ZlKSB7XG4gICAgICAgIGlmICh0aGlzLm1vdmVzLmxlbmd0aCA+IFRSQUNLX0xFTkdUSCkge1xuICAgICAgICAgIHRoaXMubW92ZXMuc2hpZnQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1vdmVzLnB1c2gobW92ZSk7XG4gICAgICB9LFxuICAgICAgbW92ZWZuOiBudWxsLFxuICAgICAgdXBmbjogbnVsbCxcbiAgICAgIHByZXZlbnQ6IGZhbHNlXG4gICAgfSxcblxuICAgIC8qKiBAdGhpcyB7R2VzdHVyZVJlY29nbml6ZXJ9ICovXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5pbmZvLnN0YXRlID0gJ3N0YXJ0JztcbiAgICAgIHRoaXMuaW5mby5zdGFydGVkID0gZmFsc2U7XG4gICAgICB0aGlzLmluZm8ubW92ZXMgPSBbXTtcbiAgICAgIHRoaXMuaW5mby54ID0gMDtcbiAgICAgIHRoaXMuaW5mby55ID0gMDtcbiAgICAgIHRoaXMuaW5mby5wcmV2ZW50ID0gZmFsc2U7XG4gICAgICB1bnRyYWNrRG9jdW1lbnQodGhpcy5pbmZvKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHRoaXMge0dlc3R1cmVSZWNvZ25pemVyfVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuICAgIGhhc01vdmVkRW5vdWdoOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICBpZiAodGhpcy5pbmZvLnByZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuaW5mby5zdGFydGVkKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgbGV0IGR4ID0gTWF0aC5hYnModGhpcy5pbmZvLnggLSB4KTtcbiAgICAgIGxldCBkeSA9IE1hdGguYWJzKHRoaXMuaW5mby55IC0geSk7XG4gICAgICByZXR1cm4gKGR4ID49IFRSQUNLX0RJU1RBTkNFIHx8IGR5ID49IFRSQUNLX0RJU1RBTkNFKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEB0aGlzIHtHZXN0dXJlUmVjb2duaXplcn1cbiAgICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGVcbiAgICAgKi9cbiAgICBtb3VzZWRvd246IGZ1bmN0aW9uKGUpIHtcbiAgICAgIGlmICghaGFzTGVmdE1vdXNlQnV0dG9uKGUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxldCB0ID0gR2VzdHVyZXMuX2ZpbmRPcmlnaW5hbFRhcmdldChlKTtcbiAgICAgIGxldCBzZWxmID0gdGhpcztcbiAgICAgIGxldCBtb3ZlZm4gPSBmdW5jdGlvbiBtb3ZlZm4oZSkge1xuICAgICAgICBsZXQgeCA9IGUuY2xpZW50WCwgeSA9IGUuY2xpZW50WTtcbiAgICAgICAgaWYgKHNlbGYuaGFzTW92ZWRFbm91Z2goeCwgeSkpIHtcbiAgICAgICAgICAvLyBmaXJzdCBtb3ZlIGlzICdzdGFydCcsIHN1YnNlcXVlbnQgbW92ZXMgYXJlICdtb3ZlJywgbW91c2V1cCBpcyAnZW5kJ1xuICAgICAgICAgIHNlbGYuaW5mby5zdGF0ZSA9IHNlbGYuaW5mby5zdGFydGVkID8gKGUudHlwZSA9PT0gJ21vdXNldXAnID8gJ2VuZCcgOiAndHJhY2snKSA6ICdzdGFydCc7XG4gICAgICAgICAgaWYgKHNlbGYuaW5mby5zdGF0ZSA9PT0gJ3N0YXJ0Jykge1xuICAgICAgICAgICAgLy8gaWYgYW5kIG9ubHkgaWYgdHJhY2tpbmcsIGFsd2F5cyBwcmV2ZW50IHRhcFxuICAgICAgICAgICAgR2VzdHVyZXMucHJldmVudCgndGFwJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNlbGYuaW5mby5hZGRNb3ZlKHt4OiB4LCB5OiB5fSk7XG4gICAgICAgICAgaWYgKCFoYXNMZWZ0TW91c2VCdXR0b24oZSkpIHtcbiAgICAgICAgICAgIC8vIGFsd2F5cyBfZmlyZSBcImVuZFwiXG4gICAgICAgICAgICBzZWxmLmluZm8uc3RhdGUgPSAnZW5kJztcbiAgICAgICAgICAgIHVudHJhY2tEb2N1bWVudChzZWxmLmluZm8pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzZWxmLl9maXJlKHQsIGUpO1xuICAgICAgICAgIHNlbGYuaW5mby5zdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGxldCB1cGZuID0gZnVuY3Rpb24gdXBmbihlKSB7XG4gICAgICAgIGlmIChzZWxmLmluZm8uc3RhcnRlZCkge1xuICAgICAgICAgIG1vdmVmbihlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlbW92ZSB0aGUgdGVtcG9yYXJ5IGxpc3RlbmVyc1xuICAgICAgICB1bnRyYWNrRG9jdW1lbnQoc2VsZi5pbmZvKTtcbiAgICAgIH07XG4gICAgICAvLyBhZGQgdGVtcG9yYXJ5IGRvY3VtZW50IGxpc3RlbmVycyBhcyBtb3VzZSByZXRhcmdldHNcbiAgICAgIHRyYWNrRG9jdW1lbnQodGhpcy5pbmZvLCBtb3ZlZm4sIHVwZm4pO1xuICAgICAgdGhpcy5pbmZvLnggPSBlLmNsaWVudFg7XG4gICAgICB0aGlzLmluZm8ueSA9IGUuY2xpZW50WTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEB0aGlzIHtHZXN0dXJlUmVjb2duaXplcn1cbiAgICAgKiBAcGFyYW0ge1RvdWNoRXZlbnR9IGVcbiAgICAgKi9cbiAgICB0b3VjaHN0YXJ0OiBmdW5jdGlvbihlKSB7XG4gICAgICBsZXQgY3QgPSBlLmNoYW5nZWRUb3VjaGVzWzBdO1xuICAgICAgdGhpcy5pbmZvLnggPSBjdC5jbGllbnRYO1xuICAgICAgdGhpcy5pbmZvLnkgPSBjdC5jbGllbnRZO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQHRoaXMge0dlc3R1cmVSZWNvZ25pemVyfVxuICAgICAqIEBwYXJhbSB7VG91Y2hFdmVudH0gZVxuICAgICAqL1xuICAgIHRvdWNobW92ZTogZnVuY3Rpb24oZSkge1xuICAgICAgbGV0IHQgPSBHZXN0dXJlcy5fZmluZE9yaWdpbmFsVGFyZ2V0KGUpO1xuICAgICAgbGV0IGN0ID0gZS5jaGFuZ2VkVG91Y2hlc1swXTtcbiAgICAgIGxldCB4ID0gY3QuY2xpZW50WCwgeSA9IGN0LmNsaWVudFk7XG4gICAgICBpZiAodGhpcy5oYXNNb3ZlZEVub3VnaCh4LCB5KSkge1xuICAgICAgICBpZiAodGhpcy5pbmZvLnN0YXRlID09PSAnc3RhcnQnKSB7XG4gICAgICAgICAgLy8gaWYgYW5kIG9ubHkgaWYgdHJhY2tpbmcsIGFsd2F5cyBwcmV2ZW50IHRhcFxuICAgICAgICAgIEdlc3R1cmVzLnByZXZlbnQoJ3RhcCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5mby5hZGRNb3ZlKHt4OiB4LCB5OiB5fSk7XG4gICAgICAgIHRoaXMuX2ZpcmUodCwgY3QpO1xuICAgICAgICB0aGlzLmluZm8uc3RhdGUgPSAndHJhY2snO1xuICAgICAgICB0aGlzLmluZm8uc3RhcnRlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBAdGhpcyB7R2VzdHVyZVJlY29nbml6ZXJ9XG4gICAgICogQHBhcmFtIHtUb3VjaEV2ZW50fSBlXG4gICAgICovXG4gICAgdG91Y2hlbmQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgIGxldCB0ID0gR2VzdHVyZXMuX2ZpbmRPcmlnaW5hbFRhcmdldChlKTtcbiAgICAgIGxldCBjdCA9IGUuY2hhbmdlZFRvdWNoZXNbMF07XG4gICAgICAvLyBvbmx5IHRyYWNrZW5kIGlmIHRyYWNrIHdhcyBzdGFydGVkIGFuZCBub3QgYWJvcnRlZFxuICAgICAgaWYgKHRoaXMuaW5mby5zdGFydGVkKSB7XG4gICAgICAgIC8vIHJlc2V0IHN0YXJ0ZWQgc3RhdGUgb24gdXBcbiAgICAgICAgdGhpcy5pbmZvLnN0YXRlID0gJ2VuZCc7XG4gICAgICAgIHRoaXMuaW5mby5hZGRNb3ZlKHt4OiBjdC5jbGllbnRYLCB5OiBjdC5jbGllbnRZfSk7XG4gICAgICAgIHRoaXMuX2ZpcmUodCwgY3QsIGUpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAdGhpcyB7R2VzdHVyZVJlY29nbml6ZXJ9XG4gICAgICogQHBhcmFtIHtFdmVudFRhcmdldH0gdGFyZ2V0XG4gICAgICogQHBhcmFtIHtUb3VjaH0gdG91Y2hcbiAgICAgKi9cbiAgICBfZmlyZTogZnVuY3Rpb24odGFyZ2V0LCB0b3VjaCkge1xuICAgICAgbGV0IHNlY29uZGxhc3QgPSB0aGlzLmluZm8ubW92ZXNbdGhpcy5pbmZvLm1vdmVzLmxlbmd0aCAtIDJdO1xuICAgICAgbGV0IGxhc3Rtb3ZlID0gdGhpcy5pbmZvLm1vdmVzW3RoaXMuaW5mby5tb3Zlcy5sZW5ndGggLSAxXTtcbiAgICAgIGxldCBkeCA9IGxhc3Rtb3ZlLnggLSB0aGlzLmluZm8ueDtcbiAgICAgIGxldCBkeSA9IGxhc3Rtb3ZlLnkgLSB0aGlzLmluZm8ueTtcbiAgICAgIGxldCBkZHgsIGRkeSA9IDA7XG4gICAgICBpZiAoc2Vjb25kbGFzdCkge1xuICAgICAgICBkZHggPSBsYXN0bW92ZS54IC0gc2Vjb25kbGFzdC54O1xuICAgICAgICBkZHkgPSBsYXN0bW92ZS55IC0gc2Vjb25kbGFzdC55O1xuICAgICAgfVxuICAgICAgR2VzdHVyZXMuX2ZpcmUodGFyZ2V0LCAndHJhY2snLCB7XG4gICAgICAgIHN0YXRlOiB0aGlzLmluZm8uc3RhdGUsXG4gICAgICAgIHg6IHRvdWNoLmNsaWVudFgsXG4gICAgICAgIHk6IHRvdWNoLmNsaWVudFksXG4gICAgICAgIGR4OiBkeCxcbiAgICAgICAgZHk6IGR5LFxuICAgICAgICBkZHg6IGRkeCxcbiAgICAgICAgZGR5OiBkZHksXG4gICAgICAgIHNvdXJjZUV2ZW50OiB0b3VjaCxcbiAgICAgICAgaG92ZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBHZXN0dXJlcy5kZWVwVGFyZ2V0RmluZCh0b3VjaC5jbGllbnRYLCB0b3VjaC5jbGllbnRZKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gIH0pO1xuXG4gIEdlc3R1cmVzLnJlZ2lzdGVyKHtcbiAgICBuYW1lOiAndGFwJyxcbiAgICBkZXBzOiBbJ21vdXNlZG93bicsICdjbGljaycsICd0b3VjaHN0YXJ0JywgJ3RvdWNoZW5kJ10sXG4gICAgZmxvdzoge1xuICAgICAgc3RhcnQ6IFsnbW91c2Vkb3duJywgJ3RvdWNoc3RhcnQnXSxcbiAgICAgIGVuZDogWydjbGljaycsICd0b3VjaGVuZCddXG4gICAgfSxcbiAgICBlbWl0czogWyd0YXAnXSxcbiAgICBpbmZvOiB7XG4gICAgICB4OiBOYU4sXG4gICAgICB5OiBOYU4sXG4gICAgICBwcmV2ZW50OiBmYWxzZVxuICAgIH0sXG4gICAgLyoqIEB0aGlzIHtHZXN0dXJlUmVjb2duaXplcn0gKi9cbiAgICByZXNldDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmluZm8ueCA9IE5hTjtcbiAgICAgIHRoaXMuaW5mby55ID0gTmFOO1xuICAgICAgdGhpcy5pbmZvLnByZXZlbnQgPSBmYWxzZTtcbiAgICB9LFxuICAgIC8qKiBAdGhpcyB7R2VzdHVyZVJlY29nbml6ZXJ9ICovXG4gICAgc2F2ZTogZnVuY3Rpb24oZSkge1xuICAgICAgdGhpcy5pbmZvLnggPSBlLmNsaWVudFg7XG4gICAgICB0aGlzLmluZm8ueSA9IGUuY2xpZW50WTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEB0aGlzIHtHZXN0dXJlUmVjb2duaXplcn1cbiAgICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGVcbiAgICAgKi9cbiAgICBtb3VzZWRvd246IGZ1bmN0aW9uKGUpIHtcbiAgICAgIGlmIChoYXNMZWZ0TW91c2VCdXR0b24oZSkpIHtcbiAgICAgICAgdGhpcy5zYXZlKGUpO1xuICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogQHRoaXMge0dlc3R1cmVSZWNvZ25pemVyfVxuICAgICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZVxuICAgICAqL1xuICAgIGNsaWNrOiBmdW5jdGlvbihlKSB7XG4gICAgICBpZiAoaGFzTGVmdE1vdXNlQnV0dG9uKGUpKSB7XG4gICAgICAgIHRoaXMuZm9yd2FyZChlKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEB0aGlzIHtHZXN0dXJlUmVjb2duaXplcn1cbiAgICAgKiBAcGFyYW0ge1RvdWNoRXZlbnR9IGVcbiAgICAgKi9cbiAgICB0b3VjaHN0YXJ0OiBmdW5jdGlvbihlKSB7XG4gICAgICB0aGlzLnNhdmUoZS5jaGFuZ2VkVG91Y2hlc1swXSwgZSk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBAdGhpcyB7R2VzdHVyZVJlY29nbml6ZXJ9XG4gICAgICogQHBhcmFtIHtUb3VjaEV2ZW50fSBlXG4gICAgICovXG4gICAgdG91Y2hlbmQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgIHRoaXMuZm9yd2FyZChlLmNoYW5nZWRUb3VjaGVzWzBdLCBlKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEB0aGlzIHtHZXN0dXJlUmVjb2duaXplcn1cbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJldmVudGVyXG4gICAgICovXG4gICAgZm9yd2FyZDogZnVuY3Rpb24oZSwgcHJldmVudGVyKSB7XG4gICAgICBsZXQgZHggPSBNYXRoLmFicyhlLmNsaWVudFggLSB0aGlzLmluZm8ueCk7XG4gICAgICBsZXQgZHkgPSBNYXRoLmFicyhlLmNsaWVudFkgLSB0aGlzLmluZm8ueSk7XG4gICAgICBsZXQgdCA9IEdlc3R1cmVzLl9maW5kT3JpZ2luYWxUYXJnZXQoZSk7XG4gICAgICAvLyBkeCxkeSBjYW4gYmUgTmFOIGlmIGBjbGlja2AgaGFzIGJlZW4gc2ltdWxhdGVkIGFuZCB0aGVyZSB3YXMgbm8gYGRvd25gIGZvciBgc3RhcnRgXG4gICAgICBpZiAoaXNOYU4oZHgpIHx8IGlzTmFOKGR5KSB8fCAoZHggPD0gVEFQX0RJU1RBTkNFICYmIGR5IDw9IFRBUF9ESVNUQU5DRSkgfHwgaXNTeW50aGV0aWNDbGljayhlKSkge1xuICAgICAgICAvLyBwcmV2ZW50IHRhcHMgZnJvbSBiZWluZyBnZW5lcmF0ZWQgaWYgYW4gZXZlbnQgaGFzIGNhbmNlbGVkIHRoZW1cbiAgICAgICAgaWYgKCF0aGlzLmluZm8ucHJldmVudCkge1xuICAgICAgICAgIEdlc3R1cmVzLl9maXJlKHQsICd0YXAnLCB7XG4gICAgICAgICAgICB4OiBlLmNsaWVudFgsXG4gICAgICAgICAgICB5OiBlLmNsaWVudFksXG4gICAgICAgICAgICBzb3VyY2VFdmVudDogZSxcbiAgICAgICAgICAgIHByZXZlbnRlcjogcHJldmVudGVyXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIC8qIGVzbGludC1lbmFibGUgdmFsaWQtanNkb2MgKi9cblxuICAvKiogQGRlcHJlY2F0ZWQgKi9cbiAgR2VzdHVyZXMuZmluZE9yaWdpbmFsVGFyZ2V0ID0gR2VzdHVyZXMuX2ZpbmRPcmlnaW5hbFRhcmdldDtcblxuICAvKiogQGRlcHJlY2F0ZWQgKi9cbiAgR2VzdHVyZXMuYWRkID0gR2VzdHVyZXMuYWRkTGlzdGVuZXI7XG5cbiAgLyoqIEBkZXByZWNhdGVkICovXG4gIEdlc3R1cmVzLnJlbW92ZSA9IEdlc3R1cmVzLnJlbW92ZUxpc3RlbmVyO1xuXG4gIFBvbHltZXIuR2VzdHVyZXMgPSBHZXN0dXJlcztcblxufSkoKTtcbjwvc2NyaXB0PlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi91dGlscy9nZXN0dXJlcy5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuXG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiYm9vdC5odG1sXCI+XG5cbjxzY3JpcHQ+XG5cbihmdW5jdGlvbigpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgLy8gcnVuIGEgY2FsbGJhY2sgd2hlbiBIVE1MSW1wb3J0cyBhcmUgcmVhZHkgb3IgaW1tZWRpYXRlbHkgaWZcbiAgLy8gdGhpcyBhcGkgaXMgbm90IGF2YWlsYWJsZS5cbiAgZnVuY3Rpb24gd2hlbkltcG9ydHNSZWFkeShjYikge1xuICAgIGlmICh3aW5kb3cuSFRNTEltcG9ydHMpIHtcbiAgICAgIEhUTUxJbXBvcnRzLndoZW5SZWFkeShjYik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNiKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlbmllbmNlIG1ldGhvZCBmb3IgaW1wb3J0aW5nIGFuIEhUTUwgZG9jdW1lbnQgaW1wZXJhdGl2ZWx5LlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBjcmVhdGVzIGEgbmV3IGA8bGluayByZWw9XCJpbXBvcnRcIj5gIGVsZW1lbnQgd2l0aFxuICAgKiB0aGUgcHJvdmlkZWQgVVJMIGFuZCBhcHBlbmRzIGl0IHRvIHRoZSBkb2N1bWVudCB0byBzdGFydCBsb2FkaW5nLlxuICAgKiBJbiB0aGUgYG9ubG9hZGAgY2FsbGJhY2ssIHRoZSBgaW1wb3J0YCBwcm9wZXJ0eSBvZiB0aGUgYGxpbmtgXG4gICAqIGVsZW1lbnQgd2lsbCBjb250YWluIHRoZSBpbXBvcnRlZCBkb2N1bWVudCBjb250ZW50cy5cbiAgICpcbiAgICogQG1lbWJlcm9mIFBvbHltZXJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGhyZWYgVVJMIHRvIGRvY3VtZW50IHRvIGxvYWQuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBvbmxvYWQgQ2FsbGJhY2sgdG8gbm90aWZ5IHdoZW4gYW4gaW1wb3J0IHN1Y2Nlc3NmdWxseVxuICAgKiAgIGxvYWRlZC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IG9uZXJyb3IgQ2FsbGJhY2sgdG8gbm90aWZ5IHdoZW4gYW4gaW1wb3J0XG4gICAqICAgdW5zdWNjZXNzZnVsbHkgbG9hZGVkLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBvcHRBc3luYyBUcnVlIGlmIHRoZSBpbXBvcnQgc2hvdWxkIGJlIGxvYWRlZCBgYXN5bmNgLlxuICAgKiAgIERlZmF1bHRzIHRvIGBmYWxzZWAuXG4gICAqIEByZXR1cm4ge0hUTUxMaW5rRWxlbWVudH0gVGhlIGxpbmsgZWxlbWVudCBmb3IgdGhlIFVSTCB0byBiZSBsb2FkZWQuXG4gICAqL1xuICBQb2x5bWVyLmltcG9ydEhyZWYgPSBmdW5jdGlvbihocmVmLCBvbmxvYWQsIG9uZXJyb3IsIG9wdEFzeW5jKSB7XG4gICAgbGV0IGxpbmsgPSAvKiogQHR5cGUge0hUTUxMaW5rRWxlbWVudH0gKi9cbiAgICAgIChkb2N1bWVudC5oZWFkLnF1ZXJ5U2VsZWN0b3IoJ2xpbmtbaHJlZj1cIicgKyBocmVmICsgJ1wiXVtpbXBvcnQtaHJlZl0nKSk7XG4gICAgaWYgKCFsaW5rKSB7XG4gICAgICBsaW5rID0gLyoqIEB0eXBlIHtIVE1MTGlua0VsZW1lbnR9ICovIChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaW5rJykpO1xuICAgICAgbGluay5yZWwgPSAnaW1wb3J0JztcbiAgICAgIGxpbmsuaHJlZiA9IGhyZWY7XG4gICAgICBsaW5rLnNldEF0dHJpYnV0ZSgnaW1wb3J0LWhyZWYnLCAnJyk7XG4gICAgfVxuICAgIC8vIGFsd2F5cyBlbnN1cmUgbGluayBoYXMgYGFzeW5jYCBhdHRyaWJ1dGUgaWYgdXNlciBzcGVjaWZpZWQgb25lLFxuICAgIC8vIGV2ZW4gaWYgaXQgd2FzIHByZXZpb3VzbHkgbm90IGFzeW5jLiBUaGlzIGlzIGNvbnNpZGVyZWQgbGVzcyBjb25mdXNpbmcuXG4gICAgaWYgKG9wdEFzeW5jKSB7XG4gICAgICBsaW5rLnNldEF0dHJpYnV0ZSgnYXN5bmMnLCAnJyk7XG4gICAgfVxuICAgIC8vIE5PVEU6IHRoZSBsaW5rIG1heSBub3cgYmUgaW4gMyBzdGF0ZXM6ICgxKSBwZW5kaW5nIGluc2VydGlvbixcbiAgICAvLyAoMikgaW5mbGlnaHQsICgzKSBhbHJlYWR5IGxhb2RlZC4gSW4gZWFjaCBjYXNlLCB3ZSBuZWVkIHRvIGFkZFxuICAgIC8vIGV2ZW50IGxpc3RlbmVycyB0byBwcm9jZXNzIGNhbGxiYWNrcy5cbiAgICBsZXQgY2xlYW51cCA9IGZ1bmN0aW9uKCkge1xuICAgICAgbGluay5yZW1vdmVFdmVudExpc3RlbmVyKCdsb2FkJywgbG9hZExpc3RlbmVyKTtcbiAgICAgIGxpbmsucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCBlcnJvckxpc3RlbmVyKTtcbiAgICB9XG4gICAgbGV0IGxvYWRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICBjbGVhbnVwKCk7XG4gICAgICAvLyBJbiBjYXNlIG9mIGEgc3VjY2Vzc2Z1bCBsb2FkLCBjYWNoZSB0aGUgbG9hZCBldmVudCBvbiB0aGUgbGluayBzb1xuICAgICAgLy8gdGhhdCBpdCBjYW4gYmUgdXNlZCB0byBzaG9ydC1jaXJjdWl0IHRoaXMgbWV0aG9kIGluIHRoZSBmdXR1cmUgd2hlblxuICAgICAgLy8gaXQgaXMgY2FsbGVkIHdpdGggdGhlIHNhbWUgaHJlZiBwYXJhbS5cbiAgICAgIGxpbmsuX19keW5hbWljSW1wb3J0TG9hZGVkID0gdHJ1ZTtcbiAgICAgIGlmIChvbmxvYWQpIHtcbiAgICAgICAgd2hlbkltcG9ydHNSZWFkeSgoKSA9PiB7XG4gICAgICAgICAgb25sb2FkKGV2ZW50KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBsZXQgZXJyb3JMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICBjbGVhbnVwKCk7XG4gICAgICAvLyBJbiBjYXNlIG9mIGFuIGVycm9yLCByZW1vdmUgdGhlIGxpbmsgZnJvbSB0aGUgZG9jdW1lbnQgc28gdGhhdCBpdFxuICAgICAgLy8gd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGNyZWF0ZWQgYWdhaW4gdGhlIG5leHQgdGltZSBgaW1wb3J0SHJlZmAgaXNcbiAgICAgIC8vIGNhbGxlZC5cbiAgICAgIGlmIChsaW5rLnBhcmVudE5vZGUpIHtcbiAgICAgICAgbGluay5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGxpbmspO1xuICAgICAgfVxuICAgICAgaWYgKG9uZXJyb3IpIHtcbiAgICAgICAgd2hlbkltcG9ydHNSZWFkeSgoKSA9PiB7XG4gICAgICAgICAgb25lcnJvcihldmVudCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gICAgbGluay5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgbG9hZExpc3RlbmVyKTtcbiAgICBsaW5rLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgZXJyb3JMaXN0ZW5lcik7XG4gICAgaWYgKGxpbmsucGFyZW50Tm9kZSA9PSBudWxsKSB7XG4gICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKGxpbmspO1xuICAgIC8vIGlmIHRoZSBsaW5rIGFscmVhZHkgbG9hZGVkLCBkaXNwYXRjaCBhIGZha2UgbG9hZCBldmVudFxuICAgIC8vIHNvIHRoYXQgbGlzdGVuZXJzIGFyZSBjYWxsZWQgYW5kIGdldCBhIHByb3BlciBldmVudCBhcmd1bWVudC5cbiAgICB9IGVsc2UgaWYgKGxpbmsuX19keW5hbWljSW1wb3J0TG9hZGVkKSB7XG4gICAgICBsaW5rLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdsb2FkJykpO1xuICAgIH1cbiAgICByZXR1cm4gbGluaztcbiAgfTtcblxufSkoKTtcbjwvc2NyaXB0PlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi91dGlscy9pbXBvcnQtaHJlZi5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cImJvb3QuaHRtbFwiPlxuXG48c2NyaXB0PlxuKGZ1bmN0aW9uKCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICBsZXQgc2NoZWR1bGVkID0gZmFsc2U7XG4gIGxldCBiZWZvcmVSZW5kZXJRdWV1ZSA9IFtdO1xuICBsZXQgYWZ0ZXJSZW5kZXJRdWV1ZSA9IFtdO1xuXG4gIGZ1bmN0aW9uIHNjaGVkdWxlKCkge1xuICAgIHNjaGVkdWxlZCA9IHRydWU7XG4gICAgLy8gYmVmb3JlIG5leHQgcmVuZGVyXG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCkge1xuICAgICAgc2NoZWR1bGVkID0gZmFsc2U7XG4gICAgICBmbHVzaFF1ZXVlKGJlZm9yZVJlbmRlclF1ZXVlKTtcbiAgICAgIC8vIGFmdGVyIHRoZSByZW5kZXJcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJ1blF1ZXVlKGFmdGVyUmVuZGVyUXVldWUpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBmbHVzaFF1ZXVlKHF1ZXVlKSB7XG4gICAgd2hpbGUgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgY2FsbE1ldGhvZChxdWV1ZS5zaGlmdCgpKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBydW5RdWV1ZShxdWV1ZSkge1xuICAgIGZvciAobGV0IGk9MCwgbD1xdWV1ZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGNhbGxNZXRob2QocXVldWUuc2hpZnQoKSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2FsbE1ldGhvZChpbmZvKSB7XG4gICAgY29uc3QgY29udGV4dCA9IGluZm9bMF07XG4gICAgY29uc3QgY2FsbGJhY2sgPSBpbmZvWzFdO1xuICAgIGNvbnN0IGFyZ3MgPSBpbmZvWzJdO1xuICAgIHRyeSB7XG4gICAgICBjYWxsYmFjay5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICB9IGNhdGNoKGUpIHtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBmbHVzaCgpIHtcbiAgICB3aGlsZSAoYmVmb3JlUmVuZGVyUXVldWUubGVuZ3RoIHx8IGFmdGVyUmVuZGVyUXVldWUubGVuZ3RoKSB7XG4gICAgICBmbHVzaFF1ZXVlKGJlZm9yZVJlbmRlclF1ZXVlKTtcbiAgICAgIGZsdXNoUXVldWUoYWZ0ZXJSZW5kZXJRdWV1ZSk7XG4gICAgfVxuICAgIHNjaGVkdWxlZCA9IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIE1vZHVsZSBmb3Igc2NoZWR1bGluZyBmbHVzaGFibGUgcHJlLXJlbmRlciBhbmQgcG9zdC1yZW5kZXIgdGFza3MuXG4gICAqXG4gICAqIEBuYW1lc3BhY2VcbiAgICogQG1lbWJlcm9mIFBvbHltZXJcbiAgICogQHN1bW1hcnkgTW9kdWxlIGZvciBzY2hlZHVsaW5nIGZsdXNoYWJsZSBwcmUtcmVuZGVyIGFuZCBwb3N0LXJlbmRlciB0YXNrcy5cbiAgICovXG4gIFBvbHltZXIuUmVuZGVyU3RhdHVzID0ge1xuXG4gICAgLyoqXG4gICAgICogRW5xdWV1ZXMgYSBjYWxsYmFjayB3aGljaCB3aWxsIGJlIHJ1biBiZWZvcmUgdGhlIG5leHQgcmVuZGVyLCBhdFxuICAgICAqIGByZXF1ZXN0QW5pbWF0aW9uRnJhbWVgIHRpbWluZy5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIHVzZWZ1bCBmb3IgZW5xdWV1aW5nIHdvcmsgdGhhdCByZXF1aXJlcyBET00gbWVhc3VyZW1lbnQsXG4gICAgICogc2luY2UgbWVhc3VyZW1lbnQgbWF5IG5vdCBiZSByZWxpYWJsZSBpbiBjdXN0b20gZWxlbWVudCBjYWxsYmFja3MgYmVmb3JlXG4gICAgICogdGhlIGZpcnN0IHJlbmRlciwgYXMgd2VsbCBhcyBmb3IgYmF0Y2hpbmcgbWVhc3VyZW1lbnQgdGFza3MgaW4gZ2VuZXJhbC5cbiAgICAgKlxuICAgICAqIFRhc2tzIGluIHRoaXMgcXVldWUgbWF5IGJlIGZsdXNoZWQgYnkgY2FsbGluZyBgUG9seW1lci5SZW5kZXJTdGF0dXMuZmx1c2goKWAuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgUG9seW1lci5SZW5kZXJTdGF0dXNcbiAgICAgKiBAcGFyYW0geyp9IGNvbnRleHQgQ29udGV4dCBvYmplY3QgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHdpbGwgYmUgYm91bmQgdG9cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCl9IGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJncyBBbiBhcnJheSBvZiBhcmd1bWVudHMgdG8gY2FsbCB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gd2l0aFxuICAgICAqL1xuICAgIGJlZm9yZU5leHRSZW5kZXI6IGZ1bmN0aW9uKGNvbnRleHQsIGNhbGxiYWNrLCBhcmdzKSB7XG4gICAgICBpZiAoIXNjaGVkdWxlZCkge1xuICAgICAgICBzY2hlZHVsZSgpO1xuICAgICAgfVxuICAgICAgYmVmb3JlUmVuZGVyUXVldWUucHVzaChbY29udGV4dCwgY2FsbGJhY2ssIGFyZ3NdKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRW5xdWV1ZXMgYSBjYWxsYmFjayB3aGljaCB3aWxsIGJlIHJ1biBhZnRlciB0aGUgbmV4dCByZW5kZXIsIGVxdWl2YWxlbnRcbiAgICAgKiB0byBvbmUgdGFzayAoYHNldFRpbWVvdXRgKSBhZnRlciB0aGUgbmV4dCBgcmVxdWVzdEFuaW1hdGlvbkZyYW1lYC5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIHVzZWZ1bCBmb3IgdHVuaW5nIHRoZSBmaXJzdC1yZW5kZXIgcGVyZm9ybWFuY2Ugb2YgYW5cbiAgICAgKiBlbGVtZW50IG9yIGFwcGxpY2F0aW9uIGJ5IGRlZmVycmluZyBub24tY3JpdGljYWwgd29yayB1bnRpbCBhZnRlciB0aGVcbiAgICAgKiBmaXJzdCBwYWludC4gIFR5cGljYWwgbm9uLXJlbmRlci1jcml0aWNhbCB3b3JrIG1heSBpbmNsdWRlIGFkZGluZyBVSVxuICAgICAqIGV2ZW50IGxpc3RlbmVycyBhbmQgYXJpYSBhdHRyaWJ1dGVzLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIFBvbHltZXIuUmVuZGVyU3RhdHVzXG4gICAgICogQHBhcmFtIHsqfSBjb250ZXh0IENvbnRleHQgb2JqZWN0IHRoZSBjYWxsYmFjayBmdW5jdGlvbiB3aWxsIGJlIGJvdW5kIHRvXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbigpfSBjYWxsYmFjayBDYWxsYmFjayBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgQW4gYXJyYXkgb2YgYXJndW1lbnRzIHRvIGNhbGwgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHdpdGhcbiAgICAgKi9cbiAgICBhZnRlck5leHRSZW5kZXI6IGZ1bmN0aW9uKGNvbnRleHQsIGNhbGxiYWNrLCBhcmdzKSB7XG4gICAgICBpZiAoIXNjaGVkdWxlZCkge1xuICAgICAgICBzY2hlZHVsZSgpO1xuICAgICAgfVxuICAgICAgYWZ0ZXJSZW5kZXJRdWV1ZS5wdXNoKFtjb250ZXh0LCBjYWxsYmFjaywgYXJnc10pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGbHVzaGVzIGFsbCBgYmVmb3JlTmV4dFJlbmRlcmAgdGFza3MsIGZvbGxvd2VkIGJ5IGFsbCBgYWZ0ZXJOZXh0UmVuZGVyYFxuICAgICAqIHRhc2tzLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIFBvbHltZXIuUmVuZGVyU3RhdHVzXG4gICAgICovXG4gICAgZmx1c2g6IGZsdXNoXG5cbiAgfTtcblxufSkoKTtcbjwvc2NyaXB0PlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi91dGlscy9yZW5kZXItc3RhdHVzLmh0bWwiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG48c2NyaXB0PlxuKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLy8gdW5yZXNvbHZlZFxuXG4gIGZ1bmN0aW9uIHJlc29sdmUoKSB7XG4gICAgZG9jdW1lbnQuYm9keS5yZW1vdmVBdHRyaWJ1dGUoJ3VucmVzb2x2ZWQnKTtcbiAgfVxuXG4gIGlmICh3aW5kb3cuV2ViQ29tcG9uZW50cykge1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdXZWJDb21wb25lbnRzUmVhZHknLCByZXNvbHZlKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gJ2ludGVyYWN0aXZlJyB8fCBkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnY29tcGxldGUnKSB7XG4gICAgICByZXNvbHZlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgcmVzb2x2ZSk7XG4gICAgfVxuICB9XG5cbn0pKCk7XG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvdXRpbHMvdW5yZXNvbHZlZC5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3V0aWxzL2Jvb3QuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3V0aWxzL3NldHRpbmdzLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi91dGlscy9mbGF0dGVuZWQtbm9kZXMtb2JzZXJ2ZXIuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3V0aWxzL2ZsdXNoLmh0bWxcIj5cbjxzY3JpcHQ+XG4oZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBjb25zdCBwID0gRWxlbWVudC5wcm90b3R5cGU7XG4gIC8qKlxuICAgKiBAY29uc3Qge2Z1bmN0aW9uKHRoaXM6RWxlbWVudCwgc3RyaW5nKTogYm9vbGVhbn1cbiAgICovXG4gIGNvbnN0IG5vcm1hbGl6ZWRNYXRjaGVzU2VsZWN0b3IgPSBwLm1hdGNoZXMgfHwgcC5tYXRjaGVzU2VsZWN0b3IgfHxcbiAgICBwLm1vek1hdGNoZXNTZWxlY3RvciB8fCBwLm1zTWF0Y2hlc1NlbGVjdG9yIHx8XG4gICAgcC5vTWF0Y2hlc1NlbGVjdG9yIHx8IHAud2Via2l0TWF0Y2hlc1NlbGVjdG9yO1xuXG4gIC8qKlxuICAgKiBDcm9zcy1wbGF0Zm9ybSBgZWxlbWVudC5tYXRjaGVzYCBzaGltLlxuICAgKlxuICAgKiBAZnVuY3Rpb24gbWF0Y2hlc1NlbGVjdG9yXG4gICAqIEBtZW1iZXJvZiBQb2x5bWVyLmRvbVxuICAgKiBAcGFyYW0geyFFbGVtZW50fSBub2RlIE5vZGUgdG8gY2hlY2sgc2VsZWN0b3IgYWdhaW5zdFxuICAgKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3IgU2VsZWN0b3IgdG8gbWF0Y2hcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBub2RlIG1hdGNoZWQgc2VsZWN0b3JcbiAgICovXG4gIGNvbnN0IG1hdGNoZXNTZWxlY3RvciA9IGZ1bmN0aW9uKG5vZGUsIHNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIG5vcm1hbGl6ZWRNYXRjaGVzU2VsZWN0b3IuY2FsbChub2RlLCBzZWxlY3Rvcik7XG4gIH1cblxuICAvKipcbiAgICogTm9kZSBBUEkgd3JhcHBlciBjbGFzcyByZXR1cm5lZCBmcm9tIGBQb2x5bWVyLmRvbS4odGFyZ2V0KWAgd2hlblxuICAgKiBgdGFyZ2V0YCBpcyBhIGBOb2RlYC5cbiAgICovXG4gIGNsYXNzIERvbUFwaSB7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgTm9kZSBmb3Igd2hpY2ggdG8gY3JlYXRlIGEgUG9seW1lci5kb20gaGVscGVyIG9iamVjdC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihub2RlKSB7XG4gICAgICB0aGlzLm5vZGUgPSBub2RlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gaW5zdGFuY2Ugb2YgYFBvbHltZXIuRmxhdHRlbmVkTm9kZXNPYnNlcnZlcmAgdGhhdFxuICAgICAqIGxpc3RlbnMgZm9yIG5vZGUgY2hhbmdlcyBvbiB0aGlzIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgd2hlbiBkaXJlY3Qgb3IgZGlzdHJpYnV0ZWQgY2hpbGRyZW5cbiAgICAgKiAgIG9mIHRoaXMgZWxlbWVudCBjaGFuZ2VzXG4gICAgICogQHJldHVybiB7UG9seW1lci5GbGF0dGVuZWROb2Rlc09ic2VydmVyfSBPYnNlcnZlciBpbnN0YW5jZVxuICAgICAqL1xuICAgIG9ic2VydmVOb2RlcyhjYWxsYmFjaykge1xuICAgICAgcmV0dXJuIG5ldyBQb2x5bWVyLkZsYXR0ZW5lZE5vZGVzT2JzZXJ2ZXIodGhpcy5ub2RlLCBjYWxsYmFjayk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGlzY29ubmVjdHMgYW4gb2JzZXJ2ZXIgcHJldmlvdXNseSBjcmVhdGVkIHZpYSBgb2JzZXJ2ZU5vZGVzYFxuICAgICAqXG4gICAgICogQHBhcmFtIHtQb2x5bWVyLkZsYXR0ZW5lZE5vZGVzT2JzZXJ2ZXJ9IG9ic2VydmVySGFuZGxlIE9ic2VydmVyIGluc3RhbmNlXG4gICAgICogICB0byBkaXNjb25uZWN0LlxuICAgICAqL1xuICAgIHVub2JzZXJ2ZU5vZGVzKG9ic2VydmVySGFuZGxlKSB7XG4gICAgICBvYnNlcnZlckhhbmRsZS5kaXNjb25uZWN0KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHJvdmlkZWQgYXMgYSBiYWNrd2FyZHMtY29tcGF0aWJsZSBBUEkgb25seS4gIFRoaXMgbWV0aG9kIGRvZXMgbm90aGluZy5cbiAgICAgKi9cbiAgICBub3RpZnlPYnNlcnZlcigpIHt9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHByb3ZpZGVkIG5vZGUgaXMgY29udGFpbmVkIHdpdGggdGhpcyBlbGVtZW50J3NcbiAgICAgKiBsaWdodC1ET00gY2hpbGRyZW4gb3Igc2hhZG93IHJvb3QsIGluY2x1ZGluZyBhbnkgbmVzdGVkIHNoYWRvdyByb290c1xuICAgICAqIG9mIGNoaWxkcmVuIHRoZXJlaW4uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgTm9kZSB0byB0ZXN0XG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBgbm9kZWAgaXMgY29udGFpbmVkIHdpdGhpblxuICAgICAqICAgdGhpcyBlbGVtZW50J3MgbGlnaHQgb3Igc2hhZG93IERPTS5cbiAgICAgKi9cbiAgICBkZWVwQ29udGFpbnMobm9kZSkge1xuICAgICAgaWYgKHRoaXMubm9kZS5jb250YWlucyhub2RlKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGxldCBuID0gbm9kZTtcbiAgICAgIGxldCBkb2MgPSBub2RlLm93bmVyRG9jdW1lbnQ7XG4gICAgICAvLyB3YWxrIGZyb20gbm9kZSB0byBgdGhpc2Agb3IgYGRvY3VtZW50YFxuICAgICAgd2hpbGUgKG4gJiYgbiAhPT0gZG9jICYmIG4gIT09IHRoaXMubm9kZSkge1xuICAgICAgICAvLyB1c2UgbG9naWNhbCBwYXJlbnRub2RlLCBvciBuYXRpdmUgU2hhZG93Um9vdCBob3N0XG4gICAgICAgIG4gPSBuLnBhcmVudE5vZGUgfHwgbi5ob3N0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIG4gPT09IHRoaXMubm9kZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSByb290IG5vZGUgb2YgdGhpcyBub2RlLiAgRXF1aXZhbGVudCB0byBgZ2V0Um9vZE5vZGUoKWAuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtOb2RlfSBUb3AgbW9zdCBlbGVtZW50IGluIHRoZSBkb20gdHJlZSBpbiB3aGljaCB0aGUgbm9kZVxuICAgICAqIGV4aXN0cy4gSWYgdGhlIG5vZGUgaXMgY29ubmVjdGVkIHRvIGEgZG9jdW1lbnQgdGhpcyBpcyBlaXRoZXIgYVxuICAgICAqIHNoYWRvd1Jvb3Qgb3IgdGhlIGRvY3VtZW50OyBvdGhlcndpc2UsIGl0IG1heSBiZSB0aGUgbm9kZVxuICAgICAqIGl0c2VsZiBvciBhIG5vZGUgb3IgZG9jdW1lbnQgZnJhZ21lbnQgY29udGFpbmluZyBpdC5cbiAgICAgKi9cbiAgICBnZXRPd25lclJvb3QoKSB7XG4gICAgICByZXR1cm4gdGhpcy5ub2RlLmdldFJvb3ROb2RlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRm9yIHNsb3QgZWxlbWVudHMsIHJldHVybnMgdGhlIG5vZGVzIGFzc2lnbmVkIHRvIHRoZSBzbG90OyBvdGhlcndpc2VcbiAgICAgKiBhbiBlbXB0eSBhcnJheS4gSXQgaXMgZXF1aXZhbGVudCB0byBgPHNsb3Q+LmFkZGlnbmVkTm9kZXMoe2ZsYXR0ZW46dHJ1ZX0pYC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0FycmF5PE5vZGU+fSBBcnJheSBvZiBhc3NpZ25lZCBub2Rlc1xuICAgICAqL1xuICAgIGdldERpc3RyaWJ1dGVkTm9kZXMoKSB7XG4gICAgICByZXR1cm4gKHRoaXMubm9kZS5sb2NhbE5hbWUgPT09ICdzbG90JykgP1xuICAgICAgICB0aGlzLm5vZGUuYXNzaWduZWROb2Rlcyh7ZmxhdHRlbjogdHJ1ZX0pIDpcbiAgICAgICAgW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBhcnJheSBvZiBhbGwgc2xvdHMgdGhpcyBlbGVtZW50IHdhcyBkaXN0cmlidXRlZCB0by5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0FycmF5PEhUTUxTbG90RWxlbWVudD59IERlc2NyaXB0aW9uXG4gICAgICovXG4gICAgZ2V0RGVzdGluYXRpb25JbnNlcnRpb25Qb2ludHMoKSB7XG4gICAgICBsZXQgaXAkID0gW107XG4gICAgICBsZXQgbiA9IHRoaXMubm9kZS5hc3NpZ25lZFNsb3Q7XG4gICAgICB3aGlsZSAobikge1xuICAgICAgICBpcCQucHVzaChuKTtcbiAgICAgICAgbiA9IG4uYXNzaWduZWRTbG90O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlwJDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxscyBgaW1wb3J0Tm9kZWAgb24gdGhlIGBvd25lckRvY3VtZW50YCBmb3IgdGhpcyBub2RlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlIE5vZGUgdG8gaW1wb3J0XG4gICAgICogQHBhcmFtIHtib29sZWFufSBkZWVwIFRydWUgaWYgdGhlIG5vZGUgc2hvdWxkIGJlIGNsb25lZCBkZWVwbHkgZHVyaW5nXG4gICAgICogICBpbXBvcnRcbiAgICAgKiBAcmV0dXJuIHtOb2RlfSBDbG9uZSBvZiBnaXZlbiBub2RlIGltcG9ydGVkIHRvIHRoaXMgb3duZXIgZG9jdW1lbnRcbiAgICAgKi9cbiAgICBpbXBvcnROb2RlKG5vZGUsIGRlZXApIHtcbiAgICAgIGxldCBkb2MgPSB0aGlzLm5vZGUgaW5zdGFuY2VvZiBEb2N1bWVudCA/IHRoaXMubm9kZSA6XG4gICAgICAgIHRoaXMubm9kZS5vd25lckRvY3VtZW50O1xuICAgICAgcmV0dXJuIGRvYy5pbXBvcnROb2RlKG5vZGUsIGRlZXApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge0FycmF5fSBSZXR1cm5zIGEgZmxhdHRlbmVkIGxpc3Qgb2YgYWxsIGNoaWxkIG5vZGVzIGFuZCBub2RlcyBhc3NpZ25lZFxuICAgICAqIHRvIGNoaWxkIHNsb3RzLlxuICAgICAqL1xuICAgIGdldEVmZmVjdGl2ZUNoaWxkTm9kZXMoKSB7XG4gICAgICByZXR1cm4gUG9seW1lci5GbGF0dGVuZWROb2Rlc09ic2VydmVyLmdldEZsYXR0ZW5lZE5vZGVzKHRoaXMubm9kZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGZpbHRlcmVkIGxpc3Qgb2YgZmxhdHRlbmVkIGNoaWxkIGVsZW1lbnRzIGZvciB0aGlzIGVsZW1lbnQgYmFzZWRcbiAgICAgKiBvbiB0aGUgZ2l2ZW4gc2VsZWN0b3IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3IgU2VsZWN0b3IgdG8gZmlsdGVyIG5vZGVzIGFnYWluc3RcbiAgICAgKiBAcmV0dXJuIHtBcnJheTxIVE1MRWxlbWVudD59IExpc3Qgb2YgZmxhdHRlbmVkIGNoaWxkIGVsZW1lbnRzXG4gICAgICovXG4gICAgcXVlcnlEaXN0cmlidXRlZEVsZW1lbnRzKHNlbGVjdG9yKSB7XG4gICAgICBsZXQgYyQgPSB0aGlzLmdldEVmZmVjdGl2ZUNoaWxkTm9kZXMoKTtcbiAgICAgIGxldCBsaXN0ID0gW107XG4gICAgICBmb3IgKGxldCBpPTAsIGw9YyQubGVuZ3RoLCBjOyAoaTxsKSAmJiAoYz1jJFtpXSk7IGkrKykge1xuICAgICAgICBpZiAoKGMubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKSAmJlxuICAgICAgICAgICAgbWF0Y2hlc1NlbGVjdG9yKGMsIHNlbGVjdG9yKSkge1xuICAgICAgICAgIGxpc3QucHVzaChjKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRm9yIHNoYWRvdyByb290cywgcmV0dXJucyB0aGUgY3VycmVudGx5IGZvY3VzZWQgZWxlbWVudCB3aXRoaW4gdGhpc1xuICAgICAqIHNoYWRvdyByb290LlxuICAgICAqXG4gICAgICogQHJldHVybiB7Tm9kZXx1bmRlZmluZWR9IEN1cnJlbnRseSBmb2N1c2VkIGVsZW1lbnRcbiAgICAgKi9cbiAgICBnZXQgYWN0aXZlRWxlbWVudCgpIHtcbiAgICAgIGxldCBub2RlID0gdGhpcy5ub2RlO1xuICAgICAgcmV0dXJuIG5vZGUuX2FjdGl2ZUVsZW1lbnQgIT09IHVuZGVmaW5lZCA/IG5vZGUuX2FjdGl2ZUVsZW1lbnQgOiBub2RlLmFjdGl2ZUVsZW1lbnQ7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZm9yd2FyZE1ldGhvZHMocHJvdG8sIG1ldGhvZHMpIHtcbiAgICBmb3IgKGxldCBpPTA7IGkgPCBtZXRob2RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgbWV0aG9kID0gbWV0aG9kc1tpXTtcbiAgICAgIHByb3RvW21ldGhvZF0gPSAvKiogQHRoaXMge0RvbUFwaX0gKi8gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGVbbWV0aG9kXS5hcHBseSh0aGlzLm5vZGUsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZm9yd2FyZFJlYWRPbmx5UHJvcGVydGllcyhwcm90bywgcHJvcGVydGllcykge1xuICAgIGZvciAobGV0IGk9MDsgaSA8IHByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBuYW1lID0gcHJvcGVydGllc1tpXTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90bywgbmFtZSwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiAvKiogQHR5cGUge0RvbUFwaX0gKi8gKHRoaXMpLm5vZGVbbmFtZV07XG4gICAgICAgIH0sXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZm9yd2FyZFByb3BlcnRpZXMocHJvdG8sIHByb3BlcnRpZXMpIHtcbiAgICBmb3IgKGxldCBpPTA7IGkgPCBwcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgbmFtZSA9IHByb3BlcnRpZXNbaV07XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG8sIG5hbWUsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gLyoqIEB0eXBlIHtEb21BcGl9ICovICh0aGlzKS5ub2RlW25hbWVdO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgLyoqIEB0eXBlIHtEb21BcGl9ICovICh0aGlzKS5ub2RlW25hbWVdID0gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgZm9yd2FyZE1ldGhvZHMoRG9tQXBpLnByb3RvdHlwZSwgW1xuICAgICdjbG9uZU5vZGUnLCAnYXBwZW5kQ2hpbGQnLCAnaW5zZXJ0QmVmb3JlJywgJ3JlbW92ZUNoaWxkJyxcbiAgICAncmVwbGFjZUNoaWxkJywgJ3NldEF0dHJpYnV0ZScsICdyZW1vdmVBdHRyaWJ1dGUnLFxuICAgICdxdWVyeVNlbGVjdG9yJywgJ3F1ZXJ5U2VsZWN0b3JBbGwnXG4gIF0pO1xuXG4gIGZvcndhcmRSZWFkT25seVByb3BlcnRpZXMoRG9tQXBpLnByb3RvdHlwZSwgW1xuICAgICdwYXJlbnROb2RlJywgJ2ZpcnN0Q2hpbGQnLCAnbGFzdENoaWxkJyxcbiAgICAnbmV4dFNpYmxpbmcnLCAncHJldmlvdXNTaWJsaW5nJywgJ2ZpcnN0RWxlbWVudENoaWxkJyxcbiAgICAnbGFzdEVsZW1lbnRDaGlsZCcsICduZXh0RWxlbWVudFNpYmxpbmcnLCAncHJldmlvdXNFbGVtZW50U2libGluZycsXG4gICAgJ2NoaWxkTm9kZXMnLCAnY2hpbGRyZW4nLCAnY2xhc3NMaXN0J1xuICBdKTtcblxuICBmb3J3YXJkUHJvcGVydGllcyhEb21BcGkucHJvdG90eXBlLCBbXG4gICAgJ3RleHRDb250ZW50JywgJ2lubmVySFRNTCdcbiAgXSk7XG5cblxuICAvKipcbiAgICogRXZlbnQgQVBJIHdyYXBwZXIgY2xhc3MgcmV0dXJuZWQgZnJvbSBgUG9seW1lci5kb20uKHRhcmdldClgIHdoZW5cbiAgICogYHRhcmdldGAgaXMgYW4gYEV2ZW50YC5cbiAgICovXG4gIGNsYXNzIEV2ZW50QXBpIHtcbiAgICBjb25zdHJ1Y3RvcihldmVudCkge1xuICAgICAgdGhpcy5ldmVudCA9IGV2ZW50O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGZpcnN0IG5vZGUgb24gdGhlIGBjb21wb3NlZFBhdGhgIG9mIHRoaXMgZXZlbnQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtOb2RlfSBUaGUgbm9kZSB0aGlzIGV2ZW50IHdhcyBkaXNwYXRjaGVkIHRvXG4gICAgICovXG4gICAgZ2V0IHJvb3RUYXJnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5ldmVudC5jb21wb3NlZFBhdGgoKVswXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBsb2NhbCAocmUtdGFyZ2V0ZWQpIHRhcmdldCBmb3IgdGhpcyBldmVudC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge05vZGV9IFRoZSBsb2NhbCAocmUtdGFyZ2V0ZWQpIHRhcmdldCBmb3IgdGhpcyBldmVudC5cbiAgICAgKi9cbiAgICBnZXQgbG9jYWxUYXJnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5ldmVudC50YXJnZXQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYGNvbXBvc2VkUGF0aGAgZm9yIHRoaXMgZXZlbnQuXG4gICAgICovXG4gICAgZ2V0IHBhdGgoKSB7XG4gICAgICByZXR1cm4gdGhpcy5ldmVudC5jb21wb3NlZFBhdGgoKTtcbiAgICB9XG4gIH1cblxuICBQb2x5bWVyLkRvbUFwaSA9IERvbUFwaTtcblxuICAvKipcbiAgICogTGVnYWN5IERPTSBhbmQgRXZlbnQgbWFuaXB1bGF0aW9uIEFQSSB3cmFwcGVyIGZhY3RvcnkgdXNlZCB0byBhYnN0cmFjdFxuICAgKiBkaWZmZXJlbmNlcyBiZXR3ZWVuIG5hdGl2ZSBTaGFkb3cgRE9NIGFuZCBcIlNoYWR5IERPTVwiIHdoZW4gcG9seWZpbGxpbmcgb25cbiAgICogb2xkZXIgYnJvd3NlcnMuXG4gICAqXG4gICAqIE5vdGUgdGhhdCBpbiBQb2x5bWVyIDIueCB1c2Ugb2YgYFBvbHltZXIuZG9tYCBpcyBubyBsb25nZXIgcmVxdWlyZWQgYW5kXG4gICAqIGluIHRoZSBtYWpvcml0eSBvZiBjYXNlcyBzaW1wbHkgZmFjYWRlcyBkaXJlY3RseSB0byB0aGUgc3RhbmRhcmQgbmF0aXZlXG4gICAqIEFQSS5cbiAgICpcbiAgICogQG5hbWVzcGFjZVxuICAgKiBAc3VtbWFyeSBMZWdhY3kgRE9NIGFuZCBFdmVudCBtYW5pcHVsYXRpb24gQVBJIHdyYXBwZXIgZmFjdG9yeSB1c2VkIHRvXG4gICAqIGFic3RyYWN0IGRpZmZlcmVuY2VzIGJldHdlZW4gbmF0aXZlIFNoYWRvdyBET00gYW5kIFwiU2hhZHkgRE9NLlwiXG4gICAqIEBtZW1iZXJvZiBQb2x5bWVyXG4gICAqIEBwYXJhbSB7IU5vZGV8RXZlbnR9IG9iaiBOb2RlIG9yIGV2ZW50IHRvIG9wZXJhdGUgb25cbiAgICogQHJldHVybiB7RG9tQXBpfEV2ZW50QXBpfSBXcmFwcGVyIHByb3ZpZGluZyBlaXRoZXIgbm9kZSBBUEkgb3IgZXZlbnQgQVBJXG4gICAqL1xuICBQb2x5bWVyLmRvbSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIG9iaiA9IG9iaiB8fCBkb2N1bWVudDtcbiAgICBpZiAoIW9iai5fX2RvbUFwaSkge1xuICAgICAgbGV0IGhlbHBlcjtcbiAgICAgIGlmIChvYmogaW5zdGFuY2VvZiBFdmVudCkge1xuICAgICAgICBoZWxwZXIgPSBuZXcgRXZlbnRBcGkob2JqKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhlbHBlciA9IG5ldyBEb21BcGkob2JqKTtcbiAgICAgIH1cbiAgICAgIG9iai5fX2RvbUFwaSA9IGhlbHBlcjtcbiAgICB9XG4gICAgcmV0dXJuIG9iai5fX2RvbUFwaTtcbiAgfTtcblxuICBQb2x5bWVyLmRvbS5tYXRjaGVzU2VsZWN0b3IgPSBtYXRjaGVzU2VsZWN0b3I7XG5cbiAgLyoqXG4gICAqIEZvcmNlcyBzZXZlcmFsIGNsYXNzZXMgb2YgYXN5bmNocm9ub3VzbHkgcXVldWVkIHRhc2tzIHRvIGZsdXNoOlxuICAgKiAtIERlYm91bmNlcnMgYWRkZWQgdmlhIGBQb2x5bWVyLmVucXVldWVEZWJvdW5jZXJgXG4gICAqIC0gU2hhZHlET00gZGlzdHJpYnV0aW9uXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGZhY2FkZXMgdG8gYFBvbHltZXIuZmx1c2hgLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgUG9seW1lci5kb21cbiAgICovXG4gIFBvbHltZXIuZG9tLmZsdXNoID0gUG9seW1lci5mbHVzaDtcblxuICAvKipcbiAgICogQWRkcyBhIGBQb2x5bWVyLkRlYm91bmNlcmAgdG8gYSBsaXN0IG9mIGdsb2JhbGx5IGZsdXNoYWJsZSB0YXNrcy5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgZmFjYWRlcyB0byBgUG9seW1lci5lbnF1ZXVlRGVib3VuY2VyYC5cbiAgICpcbiAgICogQG1lbWJlcm9mIFBvbHltZXIuZG9tXG4gICAqIEBwYXJhbSB7UG9seW1lci5EZWJvdW5jZXJ9IGRlYm91bmNlciBEZWJvdW5jZXIgdG8gZW5xdWV1ZVxuICAgKi9cbiAgUG9seW1lci5kb20uYWRkRGVib3VuY2VyID0gUG9seW1lci5lbnF1ZXVlRGVib3VuY2VyO1xufSkoKTtcbjwvc2NyaXB0PlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi9sZWdhY3kvcG9seW1lci5kb20uaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi91dGlscy9ib290Lmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi91dGlscy9hcnJheS1zcGxpY2UuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3V0aWxzL2FzeW5jLmh0bWxcIj5cbjxzY3JpcHQ+XG4oZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIGBub2RlYCBpcyBhIHNsb3QgZWxlbWVudFxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBub2RlIE5vZGUgdG8gdGVzdC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBgbm9kZWAgaXMgYSBzbG90XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBpc1Nsb3Qobm9kZSkge1xuICAgIHJldHVybiAobm9kZS5sb2NhbE5hbWUgPT09ICdzbG90Jyk7XG4gIH1cblxuICAvKipcbiAgICogQ2xhc3MgdGhhdCBsaXN0ZW5zIGZvciBjaGFuZ2VzIChhZGRpdGlvbnMgb3IgcmVtb3ZhbHMpIHRvXG4gICAqIFwiZmxhdHRlbmVkIG5vZGVzXCIgb24gYSBnaXZlbiBgbm9kZWAuIFRoZSBsaXN0IG9mIGZsYXR0ZW5lZCBub2RlcyBjb25zaXN0c1xuICAgKiBvZiBhIG5vZGUncyBjaGlsZHJlbiBhbmQsIGZvciBhbnkgY2hpbGRyZW4gdGhhdCBhcmUgYDxzbG90PmAgZWxlbWVudHMsXG4gICAqIHRoZSBleHBhbmRlZCBmbGF0dGVuZWQgbGlzdCBvZiBgYXNzaWduZWROb2Rlc2AuXG4gICAqIEZvciBleGFtcGxlLCBpZiB0aGUgb2JzZXJ2ZWQgbm9kZSBoYXMgY2hpbGRyZW4gYDxhPjwvYT48c2xvdD48L3Nsb3Q+PGI+PC9iPmBcbiAgICogYW5kIHRoZSBgPHNsb3Q+YCBoYXMgb25lIGA8ZGl2PmAgYXNzaWduZWQgdG8gaXQsIHRoZW4gdGhlIGZsYXR0ZW5lZFxuICAgKiBub2RlcyBsaXN0IGlzIGA8YT48L2E+PGRpdj48L2Rpdj48Yj48L2I+YC4gSWYgdGhlIGA8c2xvdD5gIGhhcyBvdGhlclxuICAgKiBgPHNsb3Q+YCBlbGVtZW50cyBhc3NpZ25lZCB0byBpdCwgdGhlc2UgYXJlIGZsYXR0ZW5lZCBhcyB3ZWxsLlxuICAgKlxuICAgKiBUaGUgcHJvdmlkZWQgYGNhbGxiYWNrYCBpcyBjYWxsZWQgd2hlbmV2ZXIgYW55IGNoYW5nZSB0byB0aGlzIGxpc3RcbiAgICogb2YgZmxhdHRlbmVkIG5vZGVzIG9jY3Vycywgd2hlcmUgYW4gYWRkaXRpb24gb3IgcmVtb3ZhbCBvZiBhIG5vZGUgaXNcbiAgICogY29uc2lkZXJlZCBhIGNoYW5nZS4gVGhlIGBjYWxsYmFja2AgaXMgY2FsbGVkIHdpdGggb25lIGFyZ3VtZW50LCBhbiBvYmplY3RcbiAgICogY29udGFpbmluZyBhbiBhcnJheSBvZiBhbnkgYGFkZGVkTm9kZXNgIGFuZCBgcmVtb3ZlZE5vZGVzYC5cbiAgICpcbiAgICogTm90ZTogdGhlIGNhbGxiYWNrIGlzIGNhbGxlZCBhc3luY2hyb25vdXMgdG8gYW55IGNoYW5nZXNcbiAgICogYXQgYSBtaWNyb3Rhc2sgY2hlY2twb2ludC4gVGhpcyBpcyBiZWNhdXNlIG9ic2VydmF0aW9uIGlzIHBlcmZvcm1lZCB1c2luZ1xuICAgKiBgTXV0YXRpb25PYnNlcnZlcmAgYW5kIHRoZSBgPHNsb3Q+YCBlbGVtZW50J3MgYHNsb3RjaGFuZ2VgIGV2ZW50IHdoaWNoXG4gICAqIGFyZSBhc3luY2hyb25vdXMuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBQb2x5bWVyXG4gICAqIEBzdW1tYXJ5IENsYXNzIHRoYXQgbGlzdGVucyBmb3IgY2hhbmdlcyAoYWRkaXRpb25zIG9yIHJlbW92YWxzKSB0b1xuICAgKiBcImZsYXR0ZW5lZCBub2Rlc1wiIG9uIGEgZ2l2ZW4gYG5vZGVgLlxuICAgKi9cbiAgY2xhc3MgRmxhdHRlbmVkTm9kZXNPYnNlcnZlciB7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBsaXN0IG9mIGZsYXR0ZW5lZCBub2RlcyBmb3IgdGhlIGdpdmVuIGBub2RlYC5cbiAgICAgKiBUaGlzIGxpc3QgY29uc2lzdHMgb2YgYSBub2RlJ3MgY2hpbGRyZW4gYW5kLCBmb3IgYW55IGNoaWxkcmVuXG4gICAgICogdGhhdCBhcmUgYDxzbG90PmAgZWxlbWVudHMsIHRoZSBleHBhbmRlZCBmbGF0dGVuZWQgbGlzdCBvZiBgYXNzaWduZWROb2Rlc2AuXG4gICAgICogRm9yIGV4YW1wbGUsIGlmIHRoZSBvYnNlcnZlZCBub2RlIGhhcyBjaGlsZHJlbiBgPGE+PC9hPjxzbG90Pjwvc2xvdD48Yj48L2I+YFxuICAgICAqIGFuZCB0aGUgYDxzbG90PmAgaGFzIG9uZSBgPGRpdj5gIGFzc2lnbmVkIHRvIGl0LCB0aGVuIHRoZSBmbGF0dGVuZWRcbiAgICAgKiBub2RlcyBsaXN0IGlzIGA8YT48L2E+PGRpdj48L2Rpdj48Yj48L2I+YC4gSWYgdGhlIGA8c2xvdD5gIGhhcyBvdGhlclxuICAgICAqIGA8c2xvdD5gIGVsZW1lbnRzIGFzc2lnbmVkIHRvIGl0LCB0aGVzZSBhcmUgZmxhdHRlbmVkIGFzIHdlbGwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fEhUTUxTbG90RWxlbWVudH0gbm9kZSBUaGUgbm9kZSBmb3Igd2hpY2ggdG8gcmV0dXJuIHRoZSBsaXN0IG9mIGZsYXR0ZW5lZCBub2Rlcy5cbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gVGhlIGxpc3Qgb2YgZmxhdHRlbmVkIG5vZGVzIGZvciB0aGUgZ2l2ZW4gYG5vZGVgLlxuICAgICovXG4gICAgc3RhdGljIGdldEZsYXR0ZW5lZE5vZGVzKG5vZGUpIHtcbiAgICAgIGlmIChpc1Nsb3Qobm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIC8qKiBAdHlwZSB7SFRNTFNsb3RFbGVtZW50fSAqLyAobm9kZSkuYXNzaWduZWROb2Rlcyh7ZmxhdHRlbjogdHJ1ZX0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20obm9kZS5jaGlsZE5vZGVzKS5tYXAobm9kZSA9PiB7XG4gICAgICAgICAgaWYgKGlzU2xvdChub2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuIC8qKiBAdHlwZSB7SFRNTFNsb3RFbGVtZW50fSAqLyAobm9kZSkuYXNzaWduZWROb2Rlcyh7ZmxhdHRlbjogdHJ1ZX0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gW25vZGVdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkucmVkdWNlKChhLCBiKSA9PiBhLmNvbmNhdChiKSwgW10pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Tm9kZX0gdGFyZ2V0IE5vZGUgb24gd2hpY2ggdG8gbGlzdGVuIGZvciBjaGFuZ2VzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIEZ1bmN0aW9uIGNhbGxlZCB3aGVuIHRoZXJlIGFyZSBhZGRpdGlvbnNcbiAgICAgKiBvciByZW1vdmFscyBmcm9tIHRoZSB0YXJnZXQncyBsaXN0IG9mIGZsYXR0ZW5lZCBub2Rlcy5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHRhcmdldCwgY2FsbGJhY2spIHtcbiAgICAgIC8qKiBAdHlwZSB7TXV0YXRpb25PYnNlcnZlcn0gKi9cbiAgICAgIHRoaXMuX3NoYWR5Q2hpbGRyZW5PYnNlcnZlciA9IG51bGw7XG4gICAgICAvKiogQHR5cGUge011dGF0aW9uT2JzZXJ2ZXJ9ICovXG4gICAgICB0aGlzLl9uYXRpdmVDaGlsZHJlbk9ic2VydmVyID0gbnVsbDtcbiAgICAgIHRoaXMuX2Nvbm5lY3RlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5fdGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgdGhpcy5fZWZmZWN0aXZlTm9kZXMgPSBbXTtcbiAgICAgIHRoaXMuX29ic2VydmVyID0gbnVsbDtcbiAgICAgIHRoaXMuX3NjaGVkdWxlZCA9IGZhbHNlO1xuICAgICAgLyoqIEB0eXBlIHtmdW5jdGlvbigpfSAqL1xuICAgICAgdGhpcy5fYm91bmRTY2hlZHVsZSA9ICgpID0+IHtcbiAgICAgICAgdGhpcy5fc2NoZWR1bGUoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY29ubmVjdCgpO1xuICAgICAgdGhpcy5fc2NoZWR1bGUoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBY3RpdmF0ZXMgYW4gb2JzZXJ2ZXIuIFRoaXMgbWV0aG9kIGlzIGF1dG9tYXRpY2FsbHkgY2FsbGVkIHdoZW5cbiAgICAgKiBhIGBGbGF0dGVuZWROb2Rlc09ic2VydmVyYCBpcyBjcmVhdGVkLiBJdCBzaG91bGQgb25seSBiZSBjYWxsZWQgdG9cbiAgICAgKiByZS1hY3RpdmF0ZSBhbiBvYnNlcnZlciB0aGF0IGhhcyBiZWVuIGRlYWN0aXZhdGVkIHZpYSB0aGUgYGRpc2Nvbm5lY3RgIG1ldGhvZC5cbiAgICAgKi9cbiAgICBjb25uZWN0KCkge1xuICAgICAgaWYgKGlzU2xvdCh0aGlzLl90YXJnZXQpKSB7XG4gICAgICAgIHRoaXMuX2xpc3RlblNsb3RzKFt0aGlzLl90YXJnZXRdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2xpc3RlblNsb3RzKHRoaXMuX3RhcmdldC5jaGlsZHJlbik7XG4gICAgICAgIGlmICh3aW5kb3cuU2hhZHlET00pIHtcbiAgICAgICAgICB0aGlzLl9zaGFkeUNoaWxkcmVuT2JzZXJ2ZXIgPVxuICAgICAgICAgICAgU2hhZHlET00ub2JzZXJ2ZUNoaWxkcmVuKHRoaXMuX3RhcmdldCwgKG11dGF0aW9ucykgPT4ge1xuICAgICAgICAgICAgICB0aGlzLl9wcm9jZXNzTXV0YXRpb25zKG11dGF0aW9ucyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9uYXRpdmVDaGlsZHJlbk9ic2VydmVyID1cbiAgICAgICAgICAgIG5ldyBNdXRhdGlvbk9ic2VydmVyKChtdXRhdGlvbnMpID0+IHtcbiAgICAgICAgICAgICAgdGhpcy5fcHJvY2Vzc011dGF0aW9ucyhtdXRhdGlvbnMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy5fbmF0aXZlQ2hpbGRyZW5PYnNlcnZlci5vYnNlcnZlKHRoaXMuX3RhcmdldCwge2NoaWxkTGlzdDogdHJ1ZX0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLl9jb25uZWN0ZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlYWN0aXZhdGVzIHRoZSBmbGF0dGVuZWQgbm9kZXMgb2JzZXJ2ZXIuIEFmdGVyIGNhbGxpbmcgdGhpcyBtZXRob2RcbiAgICAgKiB0aGUgb2JzZXJ2ZXIgY2FsbGJhY2sgd2lsbCBub3QgYmUgY2FsbGVkIHdoZW4gY2hhbmdlcyB0byBmbGF0dGVuZWQgbm9kZXNcbiAgICAgKiBvY2N1ci4gVGhlIGBjb25uZWN0YCBtZXRob2QgbWF5IGJlIHN1YnNlcXVlbnRseSBjYWxsZWQgdG8gcmVhY3RpdmF0ZVxuICAgICAqIHRoZSBvYnNlcnZlci5cbiAgICAgKi9cbiAgICBkaXNjb25uZWN0KCkge1xuICAgICAgaWYgKGlzU2xvdCh0aGlzLl90YXJnZXQpKSB7XG4gICAgICAgIHRoaXMuX3VubGlzdGVuU2xvdHMoW3RoaXMuX3RhcmdldF0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fdW5saXN0ZW5TbG90cyh0aGlzLl90YXJnZXQuY2hpbGRyZW4pO1xuICAgICAgICBpZiAod2luZG93LlNoYWR5RE9NICYmIHRoaXMuX3NoYWR5Q2hpbGRyZW5PYnNlcnZlcikge1xuICAgICAgICAgIFNoYWR5RE9NLnVub2JzZXJ2ZUNoaWxkcmVuKHRoaXMuX3NoYWR5Q2hpbGRyZW5PYnNlcnZlcik7XG4gICAgICAgICAgdGhpcy5fc2hhZHlDaGlsZHJlbk9ic2VydmVyID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9uYXRpdmVDaGlsZHJlbk9ic2VydmVyKSB7XG4gICAgICAgICAgdGhpcy5fbmF0aXZlQ2hpbGRyZW5PYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgdGhpcy5fbmF0aXZlQ2hpbGRyZW5PYnNlcnZlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuX2Nvbm5lY3RlZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIF9zY2hlZHVsZSgpIHtcbiAgICAgIGlmICghdGhpcy5fc2NoZWR1bGVkKSB7XG4gICAgICAgIHRoaXMuX3NjaGVkdWxlZCA9IHRydWU7XG4gICAgICAgIFBvbHltZXIuQXN5bmMubWljcm9UYXNrLnJ1bigoKSA9PiB0aGlzLmZsdXNoKCkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIF9wcm9jZXNzTXV0YXRpb25zKG11dGF0aW9ucykge1xuICAgICAgdGhpcy5fcHJvY2Vzc1Nsb3RNdXRhdGlvbnMobXV0YXRpb25zKTtcbiAgICAgIHRoaXMuZmx1c2goKTtcbiAgICB9XG5cbiAgICBfcHJvY2Vzc1Nsb3RNdXRhdGlvbnMobXV0YXRpb25zKSB7XG4gICAgICBpZiAobXV0YXRpb25zKSB7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaSA8IG11dGF0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGxldCBtdXRhdGlvbiA9IG11dGF0aW9uc1tpXTtcbiAgICAgICAgICBpZiAobXV0YXRpb24uYWRkZWROb2Rlcykge1xuICAgICAgICAgICAgdGhpcy5fbGlzdGVuU2xvdHMobXV0YXRpb24uYWRkZWROb2Rlcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtdXRhdGlvbi5yZW1vdmVkTm9kZXMpIHtcbiAgICAgICAgICAgIHRoaXMuX3VubGlzdGVuU2xvdHMobXV0YXRpb24ucmVtb3ZlZE5vZGVzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGbHVzaGVzIHRoZSBvYnNlcnZlciBjYXVzaW5nIGFueSBwZW5kaW5nIGNoYW5nZXMgdG8gYmUgaW1tZWRpYXRlbHlcbiAgICAgKiBkZWxpdmVyZWQgdGhlIG9ic2VydmVyIGNhbGxiYWNrLiBCeSBkZWZhdWx0IHRoZXNlIGNoYW5nZXMgYXJlIGRlbGl2ZXJlZFxuICAgICAqIGFzeW5jaHJvbm91c2x5IGF0IHRoZSBuZXh0IG1pY3JvdGFzayBjaGVja3BvaW50LlxuICAgICAqXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIGFueSBwZW5kaW5nIGNoYW5nZXMgY2F1c2VkIHRoZSBvYnNlcnZlclxuICAgICAqIGNhbGxiYWNrIHRvIHJ1bi5cbiAgICAgKi9cbiAgICBmbHVzaCgpIHtcbiAgICAgIGlmICghdGhpcy5fY29ubmVjdGVkKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICh3aW5kb3cuU2hhZHlET00pIHtcbiAgICAgICAgU2hhZHlET00uZmx1c2goKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9uYXRpdmVDaGlsZHJlbk9ic2VydmVyKSB7XG4gICAgICAgIHRoaXMuX3Byb2Nlc3NTbG90TXV0YXRpb25zKHRoaXMuX25hdGl2ZUNoaWxkcmVuT2JzZXJ2ZXIudGFrZVJlY29yZHMoKSk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX3NoYWR5Q2hpbGRyZW5PYnNlcnZlcikge1xuICAgICAgICB0aGlzLl9wcm9jZXNzU2xvdE11dGF0aW9ucyh0aGlzLl9zaGFkeUNoaWxkcmVuT2JzZXJ2ZXIudGFrZVJlY29yZHMoKSk7XG4gICAgICB9XG4gICAgICB0aGlzLl9zY2hlZHVsZWQgPSBmYWxzZTtcbiAgICAgIGxldCBpbmZvID0ge1xuICAgICAgICB0YXJnZXQ6IHRoaXMuX3RhcmdldCxcbiAgICAgICAgYWRkZWROb2RlczogW10sXG4gICAgICAgIHJlbW92ZWROb2RlczogW11cbiAgICAgIH07XG4gICAgICBsZXQgbmV3Tm9kZXMgPSB0aGlzLmNvbnN0cnVjdG9yLmdldEZsYXR0ZW5lZE5vZGVzKHRoaXMuX3RhcmdldCk7XG4gICAgICBsZXQgc3BsaWNlcyA9IFBvbHltZXIuQXJyYXlTcGxpY2UuY2FsY3VsYXRlU3BsaWNlcyhuZXdOb2RlcyxcbiAgICAgICAgdGhpcy5fZWZmZWN0aXZlTm9kZXMpO1xuICAgICAgLy8gcHJvY2VzcyByZW1vdmFsc1xuICAgICAgZm9yIChsZXQgaT0wLCBzOyAoaTxzcGxpY2VzLmxlbmd0aCkgJiYgKHM9c3BsaWNlc1tpXSk7IGkrKykge1xuICAgICAgICBmb3IgKGxldCBqPTAsIG47IChqIDwgcy5yZW1vdmVkLmxlbmd0aCkgJiYgKG49cy5yZW1vdmVkW2pdKTsgaisrKSB7XG4gICAgICAgICAgaW5mby5yZW1vdmVkTm9kZXMucHVzaChuKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gcHJvY2VzcyBhZGRzXG4gICAgICBmb3IgKGxldCBpPTAsIHM7IChpPHNwbGljZXMubGVuZ3RoKSAmJiAocz1zcGxpY2VzW2ldKTsgaSsrKSB7XG4gICAgICAgIGZvciAobGV0IGo9cy5pbmRleDsgaiA8IHMuaW5kZXggKyBzLmFkZGVkQ291bnQ7IGorKykge1xuICAgICAgICAgIGluZm8uYWRkZWROb2Rlcy5wdXNoKG5ld05vZGVzW2pdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gdXBkYXRlIGNhY2hlXG4gICAgICB0aGlzLl9lZmZlY3RpdmVOb2RlcyA9IG5ld05vZGVzO1xuICAgICAgbGV0IGRpZEZsdXNoID0gZmFsc2U7XG4gICAgICBpZiAoaW5mby5hZGRlZE5vZGVzLmxlbmd0aCB8fCBpbmZvLnJlbW92ZWROb2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgZGlkRmx1c2ggPSB0cnVlO1xuICAgICAgICB0aGlzLmNhbGxiYWNrLmNhbGwodGhpcy5fdGFyZ2V0LCBpbmZvKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkaWRGbHVzaDtcbiAgICB9XG5cbiAgICBfbGlzdGVuU2xvdHMobm9kZUxpc3QpIHtcbiAgICAgIGZvciAobGV0IGk9MDsgaSA8IG5vZGVMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBuID0gbm9kZUxpc3RbaV07XG4gICAgICAgIGlmIChpc1Nsb3QobikpIHtcbiAgICAgICAgICBuLmFkZEV2ZW50TGlzdGVuZXIoJ3Nsb3RjaGFuZ2UnLCB0aGlzLl9ib3VuZFNjaGVkdWxlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIF91bmxpc3RlblNsb3RzKG5vZGVMaXN0KSB7XG4gICAgICBmb3IgKGxldCBpPTA7IGkgPCBub2RlTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgbiA9IG5vZGVMaXN0W2ldO1xuICAgICAgICBpZiAoaXNTbG90KG4pKSB7XG4gICAgICAgICAgbi5yZW1vdmVFdmVudExpc3RlbmVyKCdzbG90Y2hhbmdlJywgdGhpcy5fYm91bmRTY2hlZHVsZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgfVxuXG4gIFBvbHltZXIuRmxhdHRlbmVkTm9kZXNPYnNlcnZlciA9IEZsYXR0ZW5lZE5vZGVzT2JzZXJ2ZXI7XG5cbn0pKCk7XG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvdXRpbHMvZmxhdHRlbmVkLW5vZGVzLW9ic2VydmVyLmh0bWwiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCJjbGFzcy5odG1sXCI+XG5cbjxzY3JpcHQ+XG5cbiAgKGZ1bmN0aW9uKCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIC8qKlxuICAgICAqIExlZ2FjeSBjbGFzcyBmYWN0b3J5IGFuZCByZWdpc3RyYXRpb24gaGVscGVyIGZvciBkZWZpbmluZyBQb2x5bWVyXG4gICAgICogZWxlbWVudHMuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBlcXVpdmFsZW50IHRvXG4gICAgICogYGN1c3RvbUVsZW1lbnRzLmRlZmluZShpbmZvLmlzLCBQb2x5bWVyLkNsYXNzKGluZm8pKTtgXG4gICAgICpcbiAgICAgKiBTZWUgYFBvbHltZXIuQ2xhc3NgIGZvciBkZXRhaWxzIG9uIHZhbGlkIGxlZ2FjeSBtZXRhZGF0YSBmb3JtYXQgZm9yIGBpbmZvYC5cbiAgICAgKlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqIEBmdW5jdGlvbiBQb2x5bWVyXG4gICAgICogQHBhcmFtIHshUG9seW1lckluaXR9IGluZm8gT2JqZWN0IGNvbnRhaW5pbmcgUG9seW1lciBtZXRhZGF0YSBhbmQgZnVuY3Rpb25zXG4gICAgICogICB0byBiZWNvbWUgY2xhc3MgbWV0aG9kcy5cbiAgICAgKiBAcmV0dXJuIHshSFRNTEVsZW1lbnR9IEdlbmVyYXRlZCBjbGFzc1xuICAgICAqIEBzdXBwcmVzcyB7ZHVwbGljYXRlLCBpbnZhbGlkQ2FzdHMsIGNoZWNrVHlwZXN9XG4gICAgICovXG4gICAgd2luZG93LlBvbHltZXIuX3BvbHltZXJGbiA9IGZ1bmN0aW9uKGluZm8pIHtcbiAgICAgIC8vIGlmIGlucHV0IGlzIGEgYGNsYXNzYCAoYWthIGEgZnVuY3Rpb24gd2l0aCBhIHByb3RvdHlwZSksIHVzZSB0aGUgcHJvdG90eXBlXG4gICAgICAvLyByZW1lbWJlciB0aGF0IHRoZSBgY29uc3RydWN0b3JgIHdpbGwgbmV2ZXIgYmUgY2FsbGVkXG4gICAgICBsZXQga2xhc3M7XG4gICAgICBpZiAodHlwZW9mIGluZm8gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAga2xhc3MgPSBpbmZvO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAga2xhc3MgPSBQb2x5bWVyLkNsYXNzKGluZm8pO1xuICAgICAgfVxuICAgICAgY3VzdG9tRWxlbWVudHMuZGVmaW5lKGtsYXNzLmlzLCAvKiogQHR5cGUgeyFIVE1MRWxlbWVudH0gKi8oa2xhc3MpKTtcbiAgICAgIHJldHVybiBrbGFzcztcbiAgICB9O1xuXG4gIH0pKCk7XG5cbjwvc2NyaXB0PlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi9sZWdhY3kvcG9seW1lci1mbi5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cImxlZ2FjeS1lbGVtZW50LW1peGluLmh0bWxcIj5cbjxzY3JpcHQ+XG5cbiAgKGZ1bmN0aW9uKCkge1xuXG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgbGV0IG1ldGFQcm9wcyA9IHtcbiAgICAgIGF0dGFjaGVkOiB0cnVlLFxuICAgICAgZGV0YWNoZWQ6IHRydWUsXG4gICAgICByZWFkeTogdHJ1ZSxcbiAgICAgIGNyZWF0ZWQ6IHRydWUsXG4gICAgICBiZWZvcmVSZWdpc3RlcjogdHJ1ZSxcbiAgICAgIHJlZ2lzdGVyZWQ6IHRydWUsXG4gICAgICBhdHRyaWJ1dGVDaGFuZ2VkOiB0cnVlLFxuICAgICAgLy8gbWV0YSBvYmplY3RzXG4gICAgICBiZWhhdmlvcnM6IHRydWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIGEgXCJsZWdhY3lcIiBiZWhhdmlvciBvciBhcnJheSBvZiBiZWhhdmlvcnMgdG8gdGhlIHByb3ZpZGVkIGNsYXNzLlxuICAgICAqXG4gICAgICogTm90ZTogdGhpcyBtZXRob2Qgd2lsbCBhdXRvbWF0aWNhbGx5IGFsc28gYXBwbHkgdGhlIGBQb2x5bWVyLkxlZ2FjeUVsZW1lbnRNaXhpbmBcbiAgICAgKiB0byBlbnN1cmUgdGhhdCBhbnkgbGVnYWN5IGJlaGF2aW9ycyBjYW4gcmVseSBvbiBsZWdhY3kgUG9seW1lciBBUEkgb25cbiAgICAgKiB0aGUgdW5kZXJseWluZyBlbGVtZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHshKE9iamVjdHxBcnJheSl9IGJlaGF2aW9ycyBCZWhhdmlvciBvYmplY3Qgb3IgYXJyYXkgb2YgYmVoYXZpb3JzLlxuICAgICAqIEBwYXJhbSB7IUhUTUxFbGVtZW50fGZ1bmN0aW9uKG5ldzpIVE1MRWxlbWVudCl9IGtsYXNzIEVsZW1lbnQgY2xhc3MuXG4gICAgICogQHJldHVybiB7ZnVuY3Rpb24obmV3OkhUTUxFbGVtZW50KX0gUmV0dXJucyBhIG5ldyBFbGVtZW50IGNsYXNzIGV4dGVuZGVkIGJ5IHRoZVxuICAgICAqIHBhc3NlZCBpbiBgYmVoYXZpb3JzYCBhbmQgYWxzbyBieSBgUG9seW1lci5MZWdhY3lFbGVtZW50TWl4aW5gLlxuICAgICAqIEBtZW1iZXJvZiBQb2x5bWVyXG4gICAgICogQHN1cHByZXNzIHtpbnZhbGlkQ2FzdHMsIGNoZWNrVHlwZXN9XG4gICAgICovXG4gICAgZnVuY3Rpb24gbWl4aW5CZWhhdmlvcnMoYmVoYXZpb3JzLCBrbGFzcykge1xuICAgICAgaWYgKCFiZWhhdmlvcnMpIHtcbiAgICAgICAgcmV0dXJuIC8qKiBAdHlwZSB7SFRNTEVsZW1lbnR9ICovKGtsYXNzKTtcbiAgICAgIH1cbiAgICAgIC8vIE5PVEU6IGVuc3VyZSB0aGUgYmFoZXZpb3IgaXMgZXh0ZW5kaW5nIGEgY2xhc3Mgd2l0aFxuICAgICAgLy8gbGVnYWN5IGVsZW1lbnQgYXBpLiBUaGlzIGlzIG5lY2Vzc2FyeSBzaW5jZSBiZWhhdmlvcnMgZXhwZWN0IHRvIGJlIGFibGVcbiAgICAgIC8vIHRvIGFjY2VzcyAxLnggbGVnYWN5IGFwaS5cbiAgICAgIGtsYXNzID0gUG9seW1lci5MZWdhY3lFbGVtZW50TWl4aW4oa2xhc3MpO1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGJlaGF2aW9ycykpIHtcbiAgICAgICAgYmVoYXZpb3JzID0gW2JlaGF2aW9yc107XG4gICAgICB9XG4gICAgICBsZXQgc3VwZXJCZWhhdmlvcnMgPSBrbGFzcy5wcm90b3R5cGUuYmVoYXZpb3JzO1xuICAgICAgLy8gZ2V0IGZsYXR0ZW5lZCwgZGVkdXBlZCBsaXN0IG9mIGJlaGF2aW9ycyAqbm90KiBhbHJlYWR5IG9uIHN1cGVyIGNsYXNzXG4gICAgICBiZWhhdmlvcnMgPSBmbGF0dGVuQmVoYXZpb3JzKGJlaGF2aW9ycywgbnVsbCwgc3VwZXJCZWhhdmlvcnMpO1xuICAgICAgLy8gbWl4aW4gbmV3IGJlaGF2aW9yc1xuICAgICAga2xhc3MgPSBfbWl4aW5CZWhhdmlvcnMoYmVoYXZpb3JzLCBrbGFzcyk7XG4gICAgICBpZiAoc3VwZXJCZWhhdmlvcnMpIHtcbiAgICAgICAgYmVoYXZpb3JzID0gc3VwZXJCZWhhdmlvcnMuY29uY2F0KGJlaGF2aW9ycyk7XG4gICAgICB9XG4gICAgICAvLyBTZXQgYmVoYXZpb3JzIG9uIHByb3RvdHlwZSBmb3IgQkMuLi5cbiAgICAgIGtsYXNzLnByb3RvdHlwZS5iZWhhdmlvcnMgPSBiZWhhdmlvcnM7XG4gICAgICByZXR1cm4ga2xhc3M7XG4gICAgfVxuXG4gICAgLy8gTk9URTpcbiAgICAvLyAxLnhcbiAgICAvLyBCZWhhdmlvcnMgd2VyZSBtaXhlZCBpbiAqaW4gcmV2ZXJzZSBvcmRlciogYW5kIGRlLWR1cGVkIG9uIHRoZSBmbHkuXG4gICAgLy8gVGhlIHJ1bGUgd2FzIHRoYXQgYmVoYXZpb3IgcHJvcGVydGllcyB3ZXJlIGNvcGllZCBvbnRvIHRoZSBlbGVtZW50XG4gICAgLy8gcHJvdG90eXBlIGlmIGFuZCBvbmx5IGlmIHRoZSBwcm9wZXJ0eSBkaWQgbm90IGFscmVhZHkgZXhpc3QuXG4gICAgLy8gR2l2ZW46IFBvbHltZXJ7IGJlaGF2aW9yczogW0EsIEIsIEMsIEEsIEJdfSwgcHJvcGVydHkgY29weSBvcmRlciB3YXM6XG4gICAgLy8gKDEpLCBCLCAoMiksIEEsICgzKSBDLiBUaGlzIG1lYW5zIHByb3RvdHlwZSBwcm9wZXJ0aWVzIHdpbiBvdmVyXG4gICAgLy8gQiBwcm9wZXJ0aWVzIHdpbiBvdmVyIEEgd2luIG92ZXIgQy4gVGhpcyBtaXJyb3JzIHdoYXQgd291bGQgaGFwcGVuXG4gICAgLy8gd2l0aCBpbmhlcml0YW5jZSBpZiBlbGVtZW50IGV4dGVuZGVkIEIgZXh0ZW5kZWQgQSBleHRlbmRlZCBDLlxuICAgIC8vXG4gICAgLy8gQWdhaW4gZ2l2ZW4sIFBvbHltZXJ7IGJlaGF2aW9yczogW0EsIEIsIEMsIEEsIEJdfSwgdGhlIHJlc3VsdGluZ1xuICAgIC8vIGBiZWhhdmlvcnNgIGFycmF5IHdhcyBbQywgQSwgQl0uXG4gICAgLy8gQmVoYXZpb3IgbGlmZWN5Y2xlIG1ldGhvZHMgd2VyZSBjYWxsZWQgaW4gYmVoYXZpb3IgYXJyYXkgb3JkZXJcbiAgICAvLyBmb2xsb3dlZCBieSB0aGUgZWxlbWVudCwgZS5nLiAoMSkgQy5jcmVhdGVkLCAoMikgQS5jcmVhdGVkLFxuICAgIC8vICgzKSBCLmNyZWF0ZWQsICg0KSBlbGVtZW50LmNyZWF0ZWQuIFRoZXJlIHdhcyBubyBzdXBwb3J0IGZvclxuICAgIC8vIHN1cGVyLCBhbmQgXCJzdXBlci1iZWhhdmlvclwiIG1ldGhvZHMgd2VyZSBjYWxsYWJsZSBvbmx5IGJ5IG5hbWUpLlxuICAgIC8vXG4gICAgLy8gMi54XG4gICAgLy8gQmVoYXZpb3JzIGFyZSBtYWRlIGludG8gcHJvcGVyIG1peGlucyB3aGljaCBsaXZlIGluIHRoZVxuICAgIC8vIGVsZW1lbnQncyBwcm90b3R5cGUgY2hhaW4uIEJlaGF2aW9ycyBhcmUgcGxhY2VkIGluIHRoZSBlbGVtZW50IHByb3RvdHlwZVxuICAgIC8vIGVsZGVzdCB0byB5b3VuZ2VzdCBhbmQgZGUtZHVwZWQgeW91bmdlc3QgdG8gb2xkZXN0OlxuICAgIC8vIFNvLCBmaXJzdCBbQSwgQiwgQywgQSwgQl0gYmVjb21lcyBbQywgQSwgQl0gdGhlbixcbiAgICAvLyB0aGUgZWxlbWVudCBwcm90b3R5cGUgYmVjb21lcyAob2xkZXN0KSAoMSkgUG9seW1lci5FbGVtZW50LCAoMikgY2xhc3MoQyksXG4gICAgLy8gKDMpIGNsYXNzKEEpLCAoNCkgY2xhc3MoQiksICg1KSBjbGFzcyhQb2x5bWVyKHsuLi59KSkuXG4gICAgLy8gUmVzdWx0OlxuICAgIC8vIFRoaXMgbWVhbnMgZWxlbWVudCBwcm9wZXJ0aWVzIHdpbiBvdmVyIEIgcHJvcGVydGllcyB3aW4gb3ZlciBBIHdpblxuICAgIC8vIG92ZXIgQy4gKHNhbWUgYXMgMS54KVxuICAgIC8vIElmIGxpZmVjeWNsZSBpcyBjYWxsZWQgKHN1cGVyIHRoZW4gbWUpLCBvcmRlciBpc1xuICAgIC8vICgxKSBDLmNyZWF0ZWQsICgyKSBBLmNyZWF0ZWQsICgzKSBCLmNyZWF0ZWQsICg0KSBlbGVtZW50LmNyZWF0ZWRcbiAgICAvLyAoYWdhaW4gc2FtZSBhcyAxLngpXG4gICAgZnVuY3Rpb24gX21peGluQmVoYXZpb3JzKGJlaGF2aW9ycywga2xhc3MpIHtcbiAgICAgIGZvciAobGV0IGk9MDsgaTxiZWhhdmlvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGIgPSBiZWhhdmlvcnNbaV07XG4gICAgICAgIGlmIChiKSB7XG4gICAgICAgICAga2xhc3MgPSBBcnJheS5pc0FycmF5KGIpID8gX21peGluQmVoYXZpb3JzKGIsIGtsYXNzKSA6XG4gICAgICAgICAgICBHZW5lcmF0ZUNsYXNzRnJvbUluZm8oYiwga2xhc3MpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4ga2xhc3M7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBcnJheX0gYmVoYXZpb3JzIExpc3Qgb2YgYmVoYXZpb3JzIHRvIGZsYXR0ZW4uXG4gICAgICogQHBhcmFtIHtBcnJheT19IGxpc3QgVGFyZ2V0IGxpc3QgdG8gZmxhdHRlbiBiZWhhdmlvcnMgaW50by5cbiAgICAgKiBAcGFyYW0ge0FycmF5PX0gZXhjbHVkZSBMaXN0IG9mIGJlaGF2aW9ycyB0byBleGNsdWRlIGZyb20gdGhlIGxpc3QuXG4gICAgICogQHJldHVybiB7IUFycmF5fSBSZXR1cm5zIHRoZSBsaXN0IG9mIGZsYXR0ZW5lZCBiZWhhdmlvcnMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmxhdHRlbkJlaGF2aW9ycyhiZWhhdmlvcnMsIGxpc3QsIGV4Y2x1ZGUpIHtcbiAgICAgIGxpc3QgPSBsaXN0IHx8IFtdO1xuICAgICAgZm9yIChsZXQgaT1iZWhhdmlvcnMubGVuZ3RoLTE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGxldCBiID0gYmVoYXZpb3JzW2ldO1xuICAgICAgICBpZiAoYikge1xuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGIpKSB7XG4gICAgICAgICAgICBmbGF0dGVuQmVoYXZpb3JzKGIsIGxpc3QpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBkZWR1cFxuICAgICAgICAgICAgaWYgKGxpc3QuaW5kZXhPZihiKSA8IDAgJiYgKCFleGNsdWRlIHx8IGV4Y2x1ZGUuaW5kZXhPZihiKSA8IDApKSB7XG4gICAgICAgICAgICAgIGxpc3QudW5zaGlmdChiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKCdiZWhhdmlvciBpcyBudWxsLCBjaGVjayBmb3IgbWlzc2luZyBvciA0MDQgaW1wb3J0Jyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBsaXN0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IVBvbHltZXJJbml0fSBpbmZvIFBvbHltZXIgaW5mbyBvYmplY3RcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKG5ldzpIVE1MRWxlbWVudCl9IEJhc2UgYmFzZSBjbGFzcyB0byBleHRlbmQgd2l0aCBpbmZvIG9iamVjdFxuICAgICAqIEByZXR1cm4ge2Z1bmN0aW9uKG5ldzpIVE1MRWxlbWVudCl9IEdlbmVyYXRlZCBjbGFzc1xuICAgICAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlc31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEdlbmVyYXRlQ2xhc3NGcm9tSW5mbyhpbmZvLCBCYXNlKSB7XG5cbiAgICAgIGNsYXNzIFBvbHltZXJHZW5lcmF0ZWQgZXh0ZW5kcyBCYXNlIHtcblxuICAgICAgICBzdGF0aWMgZ2V0IHByb3BlcnRpZXMoKSB7XG4gICAgICAgICAgcmV0dXJuIGluZm8ucHJvcGVydGllcztcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRpYyBnZXQgb2JzZXJ2ZXJzKCkge1xuICAgICAgICAgIHJldHVybiBpbmZvLm9ic2VydmVycztcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHtIVE1MVGVtcGxhdGVFbGVtZW50fSB0ZW1wbGF0ZSBmb3IgdGhpcyBjbGFzc1xuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGdldCB0ZW1wbGF0ZSgpIHtcbiAgICAgICAgICAvLyBnZXQgdGVtcGxhdGUgZmlyc3QgZnJvbSBhbnkgaW1wZXJhdGl2ZSBzZXQgaW4gYGluZm8uX3RlbXBsYXRlYFxuICAgICAgICAgIHJldHVybiBpbmZvLl90ZW1wbGF0ZSB8fFxuICAgICAgICAgICAgLy8gbmV4dCBsb29rIGluIGRvbS1tb2R1bGUgYXNzb2NpYXRlZCB3aXRoIHRoaXMgZWxlbWVudCdzIGlzLlxuICAgICAgICAgICAgUG9seW1lci5Eb21Nb2R1bGUgJiYgUG9seW1lci5Eb21Nb2R1bGUuaW1wb3J0KHRoaXMuaXMsICd0ZW1wbGF0ZScpIHx8XG4gICAgICAgICAgICAvLyBuZXh0IGxvb2sgZm9yIHN1cGVyY2xhc3MgdGVtcGxhdGUgKG5vdGU6IHVzZSBzdXBlcmNsYXNzIHN5bWJvbFxuICAgICAgICAgICAgLy8gdG8gZW5zdXJlIGNvcnJlY3QgYHRoaXMuaXNgKVxuICAgICAgICAgICAgQmFzZS50ZW1wbGF0ZSB8fFxuICAgICAgICAgICAgLy8gZmluYWxseSBmYWxsIGJhY2sgdG8gYF90ZW1wbGF0ZWAgaW4gZWxlbWVudCdzIHByb3RveXBlLlxuICAgICAgICAgICAgdGhpcy5wcm90b3R5cGUuX3RlbXBsYXRlIHx8XG4gICAgICAgICAgICBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgY3JlYXRlZCgpIHtcbiAgICAgICAgICBzdXBlci5jcmVhdGVkKCk7XG4gICAgICAgICAgaWYgKGluZm8uY3JlYXRlZCkge1xuICAgICAgICAgICAgaW5mby5jcmVhdGVkLmNhbGwodGhpcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgX3JlZ2lzdGVyZWQoKSB7XG4gICAgICAgICAgc3VwZXIuX3JlZ2lzdGVyZWQoKTtcbiAgICAgICAgICAvKiBOT1RFOiBgYmVmb3JlUmVnaXN0ZXJgIGlzIGNhbGxlZCBoZXJlIGZvciBiYywgYnV0IHRoZSBiZWhhdmlvclxuICAgICAgICAgICBpcyBkaWZmZXJlbnQgdGhhbiBpbiAxLnguIEluIDEuMCwgdGhlIG1ldGhvZCB3YXMgY2FsbGVkICphZnRlcipcbiAgICAgICAgICAgbWl4aW5nIHByb3RvdHlwZXMgdG9nZXRoZXIgYnV0ICpiZWZvcmUqIHByb2Nlc3Npbmcgb2YgbWV0YS1vYmplY3RzLlxuICAgICAgICAgICBIb3dldmVyLCBkeW5hbWljIGVmZmVjdHMgY2FuIHN0aWxsIGJlIHNldCBoZXJlIGFuZCBjYW4gYmUgZG9uZSBlaXRoZXJcbiAgICAgICAgICAgaW4gYGJlZm9yZVJlZ2lzdGVyYCBvciBgcmVnaXN0ZXJlZGAuIEl0IGlzIG5vIGxvbmdlciBwb3NzaWJsZSB0byBzZXRcbiAgICAgICAgICAgYGlzYCBpbiBgYmVmb3JlUmVnaXN0ZXJgIGFzIHlvdSBjb3VsZCBpbiAxLnguXG4gICAgICAgICAgKi9cbiAgICAgICAgICBpZiAoaW5mby5iZWZvcmVSZWdpc3Rlcikge1xuICAgICAgICAgICAgaW5mby5iZWZvcmVSZWdpc3Rlci5jYWxsKE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpbmZvLnJlZ2lzdGVyZWQpIHtcbiAgICAgICAgICAgIGluZm8ucmVnaXN0ZXJlZC5jYWxsKE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgX2FwcGx5TGlzdGVuZXJzKCkge1xuICAgICAgICAgIHN1cGVyLl9hcHBseUxpc3RlbmVycygpO1xuICAgICAgICAgIGlmIChpbmZvLmxpc3RlbmVycykge1xuICAgICAgICAgICAgZm9yIChsZXQgbCBpbiBpbmZvLmxpc3RlbmVycykge1xuICAgICAgICAgICAgICB0aGlzLl9hZGRNZXRob2RFdmVudExpc3RlbmVyVG9Ob2RlKHRoaXMsIGwsIGluZm8ubGlzdGVuZXJzW2xdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBub3RlOiBleGNlcHRpb24gdG8gXCJzdXBlciB0aGVuIG1lXCIgcnVsZTtcbiAgICAgICAgLy8gZG8gd29yayBiZWZvcmUgY2FsbGluZyBzdXBlciBzbyB0aGF0IHN1cGVyIGF0dHJpYnV0ZXNcbiAgICAgICAgLy8gb25seSBhcHBseSBpZiBub3QgYWxyZWFkeSBzZXQuXG4gICAgICAgIF9lbnN1cmVBdHRyaWJ1dGVzKCkge1xuICAgICAgICAgIGlmIChpbmZvLmhvc3RBdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBhIGluIGluZm8uaG9zdEF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgICAgdGhpcy5fZW5zdXJlQXR0cmlidXRlKGEsIGluZm8uaG9zdEF0dHJpYnV0ZXNbYV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBzdXBlci5fZW5zdXJlQXR0cmlidXRlcygpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVhZHkoKSB7XG4gICAgICAgICAgc3VwZXIucmVhZHkoKTtcbiAgICAgICAgICBpZiAoaW5mby5yZWFkeSkge1xuICAgICAgICAgICAgaW5mby5yZWFkeS5jYWxsKHRoaXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGF0dGFjaGVkKCkge1xuICAgICAgICAgIHN1cGVyLmF0dGFjaGVkKCk7XG4gICAgICAgICAgaWYgKGluZm8uYXR0YWNoZWQpIHtcbiAgICAgICAgICAgIGluZm8uYXR0YWNoZWQuY2FsbCh0aGlzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBkZXRhY2hlZCgpIHtcbiAgICAgICAgICBzdXBlci5kZXRhY2hlZCgpO1xuICAgICAgICAgIGlmIChpbmZvLmRldGFjaGVkKSB7XG4gICAgICAgICAgICBpbmZvLmRldGFjaGVkLmNhbGwodGhpcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYXR0cmlidXRlQ2hhbmdlZChuYW1lLCBvbGQsIHZhbHVlKSB7XG4gICAgICAgICAgc3VwZXIuYXR0cmlidXRlQ2hhbmdlZChuYW1lLCBvbGQsIHZhbHVlKTtcbiAgICAgICAgICBpZiAoaW5mby5hdHRyaWJ1dGVDaGFuZ2VkKSB7XG4gICAgICAgICAgICBpbmZvLmF0dHJpYnV0ZUNoYW5nZWQuY2FsbCh0aGlzLCBuYW1lLCBvbGQsIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgfVxuICAgICAgfVxuXG4gICAgICBQb2x5bWVyR2VuZXJhdGVkLmdlbmVyYXRlZEZyb20gPSBpbmZvXG5cbiAgICAgIGZvciAobGV0IHAgaW4gaW5mbykge1xuICAgICAgICAvLyBOT1RFOiBjYW5ub3QgY29weSBgbWV0YVByb3BzYCBtZXRob2RzIG9udG8gcHJvdG90eXBlIGF0IGxlYXN0IGJlY2F1c2VcbiAgICAgICAgLy8gYHN1cGVyLnJlYWR5YCBtdXN0IGJlIGNhbGxlZCBhbmQgaXMgbm90IGluY2x1ZGVkIGluIHRoZSB1c2VyIGZuLlxuICAgICAgICBpZiAoIShwIGluIG1ldGFQcm9wcykpIHtcbiAgICAgICAgICBsZXQgcGQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGluZm8sIHApO1xuICAgICAgICAgIGlmIChwZCkge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFBvbHltZXJHZW5lcmF0ZWQucHJvdG90eXBlLCBwLCBwZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBQb2x5bWVyR2VuZXJhdGVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhIGNsYXNzIHRoYXQgZXh0ZW5kcyBgUG9seW1lci5MZWdhY3lFbGVtZW50YCBiYXNlZCBvbiB0aGVcbiAgICAgKiBwcm92aWRlZCBpbmZvIG9iamVjdC4gIE1ldGFkYXRhIG9iamVjdHMgb24gdGhlIGBpbmZvYCBvYmplY3RcbiAgICAgKiAoYHByb3BlcnRpZXNgLCBgb2JzZXJ2ZXJzYCwgYGxpc3RlbmVyc2AsIGBiZWhhdmlvcnNgLCBgaXNgKSBhcmUgdXNlZFxuICAgICAqIGZvciBQb2x5bWVyJ3MgbWV0YS1wcm9ncmFtbWluZyBzeXN0ZW1zLCBhbmQgYW55IGZ1bmN0aW9ucyBhcmUgY29waWVkXG4gICAgICogdG8gdGhlIGdlbmVyYXRlZCBjbGFzcy5cbiAgICAgKlxuICAgICAqIFZhbGlkIFwibWV0YWRhdGFcIiB2YWx1ZXMgYXJlIGFzIGZvbGxvd3M6XG4gICAgICpcbiAgICAgKiBgaXNgOiBTdHJpbmcgcHJvdmlkaW5nIHRoZSB0YWcgbmFtZSB0byByZWdpc3RlciB0aGUgZWxlbWVudCB1bmRlci4gSW5cbiAgICAgKiBhZGRpdGlvbiwgaWYgYSBgZG9tLW1vZHVsZWAgd2l0aCB0aGUgc2FtZSBpZCBleGlzdHMsIHRoZSBmaXJzdCB0ZW1wbGF0ZVxuICAgICAqIGluIHRoYXQgYGRvbS1tb2R1bGVgIHdpbGwgYmUgc3RhbXBlZCBpbnRvIHRoZSBzaGFkb3cgcm9vdCBvZiB0aGlzIGVsZW1lbnQsXG4gICAgICogd2l0aCBzdXBwb3J0IGZvciBkZWNsYXJhdGl2ZSBldmVudCBsaXN0ZW5lcnMgKGBvbi0uLi5gKSwgUG9seW1lciBkYXRhXG4gICAgICogYmluZGluZ3MgKGBbWy4uLl1dYCBhbmQgYHt7Li4ufX1gKSwgYW5kIGlkLWJhc2VkIG5vZGUgZmluZGluZyBpbnRvXG4gICAgICogYHRoaXMuJGAuXG4gICAgICpcbiAgICAgKiBgcHJvcGVydGllc2A6IE9iamVjdCBkZXNjcmliaW5nIHByb3BlcnR5LXJlbGF0ZWQgbWV0YWRhdGEgdXNlZCBieSBQb2x5bWVyXG4gICAgICogZmVhdHVyZXMgKGtleTogcHJvcGVydHkgbmFtZXMsIHZhbHVlOiBvYmplY3QgY29udGFpbmluZyBwcm9wZXJ0eSBtZXRhZGF0YSkuXG4gICAgICogVmFsaWQga2V5cyBpbiBwZXItcHJvcGVydHkgbWV0YWRhdGEgaW5jbHVkZTpcbiAgICAgKiAtIGB0eXBlYCAoU3RyaW5nfE51bWJlcnxPYmplY3R8QXJyYXl8Li4uKTogVXNlZCBieVxuICAgICAqICAgYGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFja2AgdG8gZGV0ZXJtaW5lIGhvdyBzdHJpbmctYmFzZWQgYXR0cmlidXRlc1xuICAgICAqICAgYXJlIGRlc2VyaWFsaXplZCB0byBKYXZhU2NyaXB0IHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKiAtIGBub3RpZnlgIChib29sZWFuKTogQ2F1c2VzIGEgY2hhbmdlIGluIHRoZSBwcm9wZXJ0eSB0byBmaXJlIGFcbiAgICAgKiAgIG5vbi1idWJibGluZyBldmVudCBjYWxsZWQgYDxwcm9wZXJ0eT4tY2hhbmdlZGAuIEVsZW1lbnRzIHRoYXQgaGF2ZVxuICAgICAqICAgZW5hYmxlZCB0d28td2F5IGJpbmRpbmcgdG8gdGhlIHByb3BlcnR5IHVzZSB0aGlzIGV2ZW50IHRvIG9ic2VydmUgY2hhbmdlcy5cbiAgICAgKiAtIGByZWFkT25seWAgKGJvb2xlYW4pOiBDcmVhdGVzIGEgZ2V0dGVyIGZvciB0aGUgcHJvcGVydHksIGJ1dCBubyBzZXR0ZXIuXG4gICAgICogICBUbyBzZXQgYSByZWFkLW9ubHkgcHJvcGVydHksIHVzZSB0aGUgcHJpdmF0ZSBzZXR0ZXIgbWV0aG9kXG4gICAgICogICBgX3NldFByb3BlcnR5KHByb3BlcnR5LCB2YWx1ZSlgLlxuICAgICAqIC0gYG9ic2VydmVyYCAoc3RyaW5nKTogT2JzZXJ2ZXIgbWV0aG9kIG5hbWUgdGhhdCB3aWxsIGJlIGNhbGxlZCB3aGVuXG4gICAgICogICB0aGUgcHJvcGVydHkgY2hhbmdlcy4gVGhlIGFyZ3VtZW50cyBvZiB0aGUgbWV0aG9kIGFyZVxuICAgICAqICAgYCh2YWx1ZSwgcHJldmlvdXNWYWx1ZSlgLlxuICAgICAqIC0gYGNvbXB1dGVkYCAoc3RyaW5nKTogU3RyaW5nIGRlc2NyaWJpbmcgbWV0aG9kIGFuZCBkZXBlbmRlbnQgcHJvcGVydGllc1xuICAgICAqICAgZm9yIGNvbXB1dGluZyB0aGUgdmFsdWUgb2YgdGhpcyBwcm9wZXJ0eSAoZS5nLiBgJ2NvbXB1dGVGb28oYmFyLCB6b3QpJ2ApLlxuICAgICAqICAgQ29tcHV0ZWQgcHJvcGVydGllcyBhcmUgcmVhZC1vbmx5IGJ5IGRlZmF1bHQgYW5kIGNhbiBvbmx5IGJlIGNoYW5nZWRcbiAgICAgKiAgIHZpYSB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBjb21wdXRpbmcgbWV0aG9kLlxuICAgICAqXG4gICAgICogYG9ic2VydmVyc2A6IEFycmF5IG9mIHN0cmluZ3MgZGVzY3JpYmluZyBtdWx0aS1wcm9wZXJ0eSBvYnNlcnZlciBtZXRob2RzXG4gICAgICogIGFuZCB0aGVpciBkZXBlbmRlbnQgcHJvcGVydGllcyAoZS5nLiBgJ29ic2VydmVBQkMoYSwgYiwgYyknYCkuXG4gICAgICpcbiAgICAgKiBgbGlzdGVuZXJzYDogT2JqZWN0IGRlc2NyaWJpbmcgZXZlbnQgbGlzdGVuZXJzIHRvIGJlIGFkZGVkIHRvIGVhY2hcbiAgICAgKiAgaW5zdGFuY2Ugb2YgdGhpcyBlbGVtZW50IChrZXk6IGV2ZW50IG5hbWUsIHZhbHVlOiBtZXRob2QgbmFtZSkuXG4gICAgICpcbiAgICAgKiBgYmVoYXZpb3JzYDogQXJyYXkgb2YgYWRkaXRpb25hbCBgaW5mb2Agb2JqZWN0cyBjb250YWluaW5nIG1ldGFkYXRhXG4gICAgICogYW5kIGNhbGxiYWNrcyBpbiB0aGUgc2FtZSBmb3JtYXQgYXMgdGhlIGBpbmZvYCBvYmplY3QgaGVyZSB3aGljaCBhcmVcbiAgICAgKiBtZXJnZWQgaW50byB0aGlzIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBgaG9zdEF0dHJpYnV0ZXNgOiBPYmplY3QgbGlzdGluZyBhdHRyaWJ1dGVzIHRvIGJlIGFwcGxpZWQgdG8gdGhlIGhvc3RcbiAgICAgKiAgb25jZSBjcmVhdGVkIChrZXk6IGF0dHJpYnV0ZSBuYW1lLCB2YWx1ZTogYXR0cmlidXRlIHZhbHVlKS4gIFZhbHVlc1xuICAgICAqICBhcmUgc2VyaWFsaXplZCBiYXNlZCBvbiB0aGUgdHlwZSBvZiB0aGUgdmFsdWUuICBIb3N0IGF0dHJpYnV0ZXMgc2hvdWxkXG4gICAgICogIGdlbmVyYWxseSBiZSBsaW1pdGVkIHRvIGF0dHJpYnV0ZXMgc3VjaCBhcyBgdGFiSW5kZXhgIGFuZCBgYXJpYS0uLi5gLlxuICAgICAqICBBdHRyaWJ1dGVzIGluIGBob3N0QXR0cmlidXRlc2AgYXJlIG9ubHkgYXBwbGllZCBpZiBhIHVzZXItc3VwcGxpZWRcbiAgICAgKiAgYXR0cmlidXRlIGlzIG5vdCBhbHJlYWR5IHByZXNlbnQgKGF0dHJpYnV0ZXMgaW4gbWFya3VwIG92ZXJyaWRlXG4gICAgICogIGBob3N0QXR0cmlidXRlc2ApLlxuICAgICAqXG4gICAgICogSW4gYWRkaXRpb24sIHRoZSBmb2xsb3dpbmcgUG9seW1lci1zcGVjaWZpYyBjYWxsYmFja3MgbWF5IGJlIHByb3ZpZGVkOlxuICAgICAqIC0gYHJlZ2lzdGVyZWRgOiBjYWxsZWQgYWZ0ZXIgZmlyc3QgaW5zdGFuY2Ugb2YgdGhpcyBlbGVtZW50LFxuICAgICAqIC0gYGNyZWF0ZWRgOiBjYWxsZWQgZHVyaW5nIGBjb25zdHJ1Y3RvcmBcbiAgICAgKiAtIGBhdHRhY2hlZGA6IGNhbGxlZCBkdXJpbmcgYGNvbm5lY3RlZENhbGxiYWNrYFxuICAgICAqIC0gYGRldGFjaGVkYDogY2FsbGVkIGR1cmluZyBgZGlzY29ubmVjdGVkQ2FsbGJhY2tgXG4gICAgICogLSBgcmVhZHlgOiBjYWxsZWQgYmVmb3JlIGZpcnN0IGBhdHRhY2hlZGAsIGFmdGVyIGFsbCBwcm9wZXJ0aWVzIG9mXG4gICAgICogICB0aGlzIGVsZW1lbnQgaGF2ZSBiZWVuIHByb3BhZ2F0ZWQgdG8gaXRzIHRlbXBsYXRlIGFuZCBhbGwgb2JzZXJ2ZXJzXG4gICAgICogICBoYXZlIHJ1blxuICAgICAqXG4gICAgICogQHBhcmFtIHshUG9seW1lckluaXR9IGluZm8gT2JqZWN0IGNvbnRhaW5pbmcgUG9seW1lciBtZXRhZGF0YSBhbmQgZnVuY3Rpb25zXG4gICAgICogICB0byBiZWNvbWUgY2xhc3MgbWV0aG9kcy5cbiAgICAgKiBAcmV0dXJuIHtmdW5jdGlvbihuZXc6SFRNTEVsZW1lbnQpfSBHZW5lcmF0ZWQgY2xhc3NcbiAgICAgKiBAbWVtYmVyb2YgUG9seW1lclxuICAgICAqL1xuICAgIFBvbHltZXIuQ2xhc3MgPSBmdW5jdGlvbihpbmZvKSB7XG4gICAgICBpZiAoIWluZm8pIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdQb2x5bWVyLkNsYXNzIHJlcXVpcmVzIGBpbmZvYCBhcmd1bWVudCcpO1xuICAgICAgfVxuICAgICAgbGV0IGtsYXNzID0gR2VuZXJhdGVDbGFzc0Zyb21JbmZvKGluZm8sIGluZm8uYmVoYXZpb3JzID9cbiAgICAgICAgLy8gbm90ZTogbWl4aW5CZWhhdmlvcnMgZW5zdXJlcyBgTGVnYWN5RWxlbWVudE1peGluYC5cbiAgICAgICAgbWl4aW5CZWhhdmlvcnMoaW5mby5iZWhhdmlvcnMsIEhUTUxFbGVtZW50KSA6XG4gICAgICAgIFBvbHltZXIuTGVnYWN5RWxlbWVudE1peGluKEhUTUxFbGVtZW50KSk7XG4gICAgICAvLyBkZWNvcmF0ZSBrbGFzcyB3aXRoIHJlZ2lzdHJhdGlvbiBpbmZvXG4gICAgICBrbGFzcy5pcyA9IGluZm8uaXM7XG4gICAgICByZXR1cm4ga2xhc3M7XG4gICAgfVxuXG4gICAgUG9seW1lci5taXhpbkJlaGF2aW9ycyA9IG1peGluQmVoYXZpb3JzO1xuXG4gIH0pKCk7XG5cbjwvc2NyaXB0PlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi9sZWdhY3kvY2xhc3MuaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cblxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3V0aWxzL3RlbXBsYXRpemUuaHRtbFwiPlxuXG48c2NyaXB0PlxuICAoZnVuY3Rpb24oKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgbGV0IFRlbXBsYXRlSW5zdGFuY2VCYXNlID0gUG9seW1lci5UZW1wbGF0ZUluc3RhbmNlQmFzZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYge3tcbiAgICAgKiAgIF90ZW1wbGF0aXplclRlbXBsYXRlOiBIVE1MVGVtcGxhdGVFbGVtZW50LFxuICAgICAqICAgX3BhcmVudE1vZGVsOiBib29sZWFuLFxuICAgICAqICAgX2luc3RhbmNlUHJvcHM6IE9iamVjdCxcbiAgICAgKiAgIF9mb3J3YXJkSG9zdFByb3BWMjogRnVuY3Rpb24sXG4gICAgICogICBfbm90aWZ5SW5zdGFuY2VQcm9wVjI6IEZ1bmN0aW9uLFxuICAgICAqICAgY3RvcjogVGVtcGxhdGVJbnN0YW5jZUJhc2VcbiAgICAgKiB9fVxuICAgICAqL1xuICAgIGxldCBUZW1wbGF0aXplclVzZXI7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICAgIC8qKlxuICAgICAqIFRoZSBgUG9seW1lci5UZW1wbGF0aXplcmAgYmVoYXZpb3IgYWRkcyBtZXRob2RzIHRvIGdlbmVyYXRlIGluc3RhbmNlcyBvZlxuICAgICAqIHRlbXBsYXRlcyB0aGF0IGFyZSBlYWNoIG1hbmFnZWQgYnkgYW4gYW5vbnltb3VzIGBQb2x5bWVyLlByb3BlcnR5RWZmZWN0c2BcbiAgICAgKiBpbnN0YW5jZSB3aGVyZSBkYXRhLWJpbmRpbmdzIGluIHRoZSBzdGFtcGVkIHRlbXBsYXRlIGNvbnRlbnQgYXJlIGJvdW5kIHRvXG4gICAgICogYWNjZXNzb3JzIG9uIGl0c2VsZi5cbiAgICAgKlxuICAgICAqIFRoaXMgYmVoYXZpb3IgaXMgcHJvdmlkZWQgaW4gUG9seW1lciAyLnggYXMgYSBoeWJyaWQtZWxlbWVudCBjb252ZW5pZW5jZVxuICAgICAqIG9ubHkuICBGb3Igbm9uLWh5YnJpZCB1c2FnZSwgdGhlIGBQb2x5bWVyLlRlbXBsYXRpemVgIGxpYnJhcnlcbiAgICAgKiBzaG91bGQgYmUgdXNlZCBpbnN0ZWFkLlxuICAgICAqXG4gICAgICogRXhhbXBsZTpcbiAgICAgKlxuICAgICAqICAgICAvLyBHZXQgYSB0ZW1wbGF0ZSBmcm9tIHNvbWV3aGVyZSwgZS5nLiBsaWdodCBET01cbiAgICAgKiAgICAgbGV0IHRlbXBsYXRlID0gdGhpcy5xdWVyeVNlbGVjdG9yKCd0ZW1wbGF0ZScpO1xuICAgICAqICAgICAvLyBQcmVwYXJlIHRoZSB0ZW1wbGF0ZVxuICAgICAqICAgICB0aGlzLnRlbXBsYXRpemUodGVtcGxhdGUpO1xuICAgICAqICAgICAvLyBJbnN0YW5jZSB0aGUgdGVtcGxhdGUgd2l0aCBhbiBpbml0aWFsIGRhdGEgbW9kZWxcbiAgICAgKiAgICAgbGV0IGluc3RhbmNlID0gdGhpcy5zdGFtcCh7bXlQcm9wOiAnaW5pdGlhbCd9KTtcbiAgICAgKiAgICAgLy8gSW5zZXJ0IHRoZSBpbnN0YW5jZSdzIERPTSBzb21ld2hlcmUsIGUuZy4gbGlnaHQgRE9NXG4gICAgICogICAgIFBvbHltZXIuZG9tKHRoaXMpLmFwcGVuZENoaWxkKGluc3RhbmNlLnJvb3QpO1xuICAgICAqICAgICAvLyBDaGFuZ2luZyBhIHByb3BlcnR5IG9uIHRoZSBpbnN0YW5jZSB3aWxsIHByb3BhZ2F0ZSB0byBiaW5kaW5nc1xuICAgICAqICAgICAvLyBpbiB0aGUgdGVtcGxhdGVcbiAgICAgKiAgICAgaW5zdGFuY2UubXlQcm9wID0gJ25ldyB2YWx1ZSc7XG4gICAgICpcbiAgICAgKiBVc2VycyBvZiBgVGVtcGxhdGl6ZXJgIG1heSBuZWVkIHRvIGltcGxlbWVudCB0aGUgZm9sbG93aW5nIGFic3RyYWN0XG4gICAgICogQVBJJ3MgdG8gZGV0ZXJtaW5lIGhvdyBwcm9wZXJ0aWVzIGFuZCBwYXRocyBmcm9tIHRoZSBob3N0IHNob3VsZCBiZVxuICAgICAqIGZvcndhcmRlZCBpbnRvIHRvIGluc3RhbmNlczpcbiAgICAgKlxuICAgICAqICAgICBfZm9yd2FyZEhvc3RQcm9wVjI6IGZ1bmN0aW9uKHByb3AsIHZhbHVlKVxuICAgICAqXG4gICAgICogTGlrZXdpc2UsIHVzZXJzIG1heSBpbXBsZW1lbnQgdGhlc2UgYWRkaXRpb25hbCBhYnN0cmFjdCBBUEkncyB0byBkZXRlcm1pbmVcbiAgICAgKiBob3cgaW5zdGFuY2Utc3BlY2lmaWMgcHJvcGVydGllcyB0aGF0IGNoYW5nZSBvbiB0aGUgaW5zdGFuY2Ugc2hvdWxkIGJlXG4gICAgICogZm9yd2FyZGVkIG91dCB0byB0aGUgaG9zdCwgaWYgbmVjZXNzYXJ5LlxuICAgICAqXG4gICAgICogICAgIF9ub3RpZnlJbnN0YW5jZVByb3BWMjogZnVuY3Rpb24oaW5zdCwgcHJvcCwgdmFsdWUpXG4gICAgICpcbiAgICAgKiBJbiBvcmRlciB0byBkZXRlcm1pbmUgd2hpY2ggcHJvcGVydGllcyBhcmUgaW5zdGFuY2Utc3BlY2lmaWMgYW5kIHJlcXVpcmVcbiAgICAgKiBjdXN0b20gbm90aWZpY2F0aW9uIHZpYSBgX25vdGlmeUluc3RhbmNlUHJvcGAsIGRlZmluZSBhbiBgX2luc3RhbmNlUHJvcHNgXG4gICAgICogb2JqZWN0IGNvbnRhaW5pbmcga2V5cyBmb3IgZWFjaCBpbnN0YW5jZSBwcm9wLCBmb3IgZXhhbXBsZTpcbiAgICAgKlxuICAgICAqICAgICBfaW5zdGFuY2VQcm9wczoge1xuICAgICAqICAgICAgIGl0ZW06IHRydWUsXG4gICAgICogICAgICAgaW5kZXg6IHRydWVcbiAgICAgKiAgICAgfVxuICAgICAqXG4gICAgICogQW55IHByb3BlcnRpZXMgdXNlZCBpbiB0aGUgdGVtcGxhdGUgdGhhdCBhcmUgbm90IGRlZmluZWQgaW4gX2luc3RhbmNlUHJvcFxuICAgICAqIHdpbGwgYmUgZm9yd2FyZGVkIG91dCB0byB0aGUgVGVtcGxhdGl6ZSBgb3duZXJgIGF1dG9tYXRpY2FsbHkuXG4gICAgICpcbiAgICAgKiBVc2VycyBtYXkgYWxzbyBpbXBsZW1lbnQgdGhlIGZvbGxvd2luZyBhYnN0cmFjdCBmdW5jdGlvbiB0byBzaG93IG9yXG4gICAgICogaGlkZSBhbnkgRE9NIGdlbmVyYXRlZCB1c2luZyBgc3RhbXBgOlxuICAgICAqXG4gICAgICogICAgIF9zaG93SGlkZUNoaWxkcmVuOiBmdW5jdGlvbihzaG91bGRIaWRlKVxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IHNvbWUgY2FsbGJhY2tzIGFyZSBzdWZmaXhlZCB3aXRoIGBWMmAgaW4gdGhlIFBvbHltZXIgMi54IGJlaGF2aW9yXG4gICAgICogYXMgdGhlIGltcGxlbWVudGF0aW9ucyB3aWxsIG5lZWQgdG8gZGlmZmVyIGZyb20gdGhlIGNhbGxiYWNrcyByZXF1aXJlZFxuICAgICAqIGJ5IHRoZSAxLnggVGVtcGxhdGl6ZXIgQVBJIGR1ZSB0byBjaGFuZ2VzIGluIHRoZSBgVGVtcGxhdGVJbnN0YW5jZWAgQVBJXG4gICAgICogYmV0d2VlbiB2ZXJzaW9ucyAxLnggYW5kIDIueC5cbiAgICAgKlxuICAgICAqIEBwb2x5bWVyQmVoYXZpb3JcbiAgICAgKiBAbWVtYmVyb2YgUG9seW1lclxuICAgICAqL1xuICAgIGxldCBUZW1wbGF0aXplciA9IHtcblxuICAgICAgLyoqXG4gICAgICAgKiBHZW5lcmF0ZXMgYW4gYW5vbnltb3VzIGBUZW1wbGF0ZUluc3RhbmNlYCBjbGFzcyAoc3RvcmVkIGFzIGB0aGlzLmN0b3JgKVxuICAgICAgICogZm9yIHRoZSBwcm92aWRlZCB0ZW1wbGF0ZS4gIFRoaXMgbWV0aG9kIHNob3VsZCBiZSBjYWxsZWQgb25jZSBwZXJcbiAgICAgICAqIHRlbXBsYXRlIHRvIHByZXBhcmUgYW4gZWxlbWVudCBmb3Igc3RhbXBpbmcgdGhlIHRlbXBsYXRlLCBmb2xsb3dlZFxuICAgICAgICogYnkgYHN0YW1wYCB0byBjcmVhdGUgbmV3IGluc3RhbmNlcyBvZiB0aGUgdGVtcGxhdGUuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtIVE1MVGVtcGxhdGVFbGVtZW50fSB0ZW1wbGF0ZSBUZW1wbGF0ZSB0byBwcmVwYXJlXG4gICAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBtdXRhYmxlRGF0YSBXaGVuIGB0cnVlYCwgdGhlIGdlbmVyYXRlZCBjbGFzcyB3aWxsIHNraXBcbiAgICAgICAqICAgc3RyaWN0IGRpcnR5LWNoZWNraW5nIGZvciBvYmplY3RzIGFuZCBhcnJheXMgKGFsd2F5cyBjb25zaWRlciB0aGVtIHRvXG4gICAgICAgKiAgIGJlIFwiZGlydHlcIikuIERlZmF1bHRzIHRvIGZhbHNlLlxuICAgICAgICogQHRoaXMge1RlbXBsYXRpemVyVXNlcn1cbiAgICAgICAqL1xuICAgICAgdGVtcGxhdGl6ZSh0ZW1wbGF0ZSwgbXV0YWJsZURhdGEpIHtcbiAgICAgICAgdGhpcy5fdGVtcGxhdGl6ZXJUZW1wbGF0ZSA9IHRlbXBsYXRlO1xuICAgICAgICB0aGlzLmN0b3IgPSBQb2x5bWVyLlRlbXBsYXRpemUudGVtcGxhdGl6ZSh0ZW1wbGF0ZSwgdGhpcywge1xuICAgICAgICAgIG11dGFibGVEYXRhOiBCb29sZWFuKG11dGFibGVEYXRhKSxcbiAgICAgICAgICBwYXJlbnRNb2RlbDogdGhpcy5fcGFyZW50TW9kZWwsXG4gICAgICAgICAgaW5zdGFuY2VQcm9wczogdGhpcy5faW5zdGFuY2VQcm9wcyxcbiAgICAgICAgICBmb3J3YXJkSG9zdFByb3A6IHRoaXMuX2ZvcndhcmRIb3N0UHJvcFYyLFxuICAgICAgICAgIG5vdGlmeUluc3RhbmNlUHJvcDogdGhpcy5fbm90aWZ5SW5zdGFuY2VQcm9wVjJcbiAgICAgICAgfSk7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhlIHRlbXBsYXRlIHByZXBhcmVkIGJ5IGB0ZW1wbGF0aXplYC4gIFRoZSBvYmplY3RcbiAgICAgICAqIHJldHVybmVkIGlzIGFuIGluc3RhbmNlIG9mIHRoZSBhbm9ueW1vdXMgY2xhc3MgZ2VuZXJhdGVkIGJ5IGB0ZW1wbGF0aXplYFxuICAgICAgICogd2hvc2UgYHJvb3RgIHByb3BlcnR5IGlzIGEgZG9jdW1lbnQgZnJhZ21lbnQgY29udGFpbmluZyBuZXdseSBjbG9uZWRcbiAgICAgICAqIHRlbXBsYXRlIGNvbnRlbnQsIGFuZCB3aGljaCBoYXMgcHJvcGVydHkgYWNjZXNzb3JzIGNvcnJlc3BvbmRpbmcgdG9cbiAgICAgICAqIHByb3BlcnRpZXMgcmVmZXJlbmNlZCBpbiB0ZW1wbGF0ZSBiaW5kaW5ncy5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge09iamVjdD19IG1vZGVsIE9iamVjdCBjb250YWluaW5nIGluaXRpYWwgcHJvcGVydHkgdmFsdWVzIHRvXG4gICAgICAgKiAgIHBvcHVsYXRlIGludG8gdGhlIHRlbXBsYXRlIGJpbmRpbmdzLlxuICAgICAgICogQHJldHVybiB7VGVtcGxhdGVJbnN0YW5jZUJhc2V9IFJldHVybnMgdGhlIGNyZWF0ZWQgaW5zdGFuY2Ugb2ZcbiAgICAgICAqIHRoZSB0ZW1wbGF0ZSBwcmVwYXJlZCBieSBgdGVtcGxhdGl6ZWAuXG4gICAgICAgKiBAdGhpcyB7VGVtcGxhdGl6ZXJVc2VyfVxuICAgICAgICovXG4gICAgICBzdGFtcChtb2RlbCkge1xuICAgICAgICByZXR1cm4gbmV3IHRoaXMuY3Rvcihtb2RlbCk7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFJldHVybnMgdGhlIHRlbXBsYXRlIFwibW9kZWxcIiAoYFRlbXBsYXRlSW5zdGFuY2VgKSBhc3NvY2lhdGVkIHdpdGhcbiAgICAgICAqIGEgZ2l2ZW4gZWxlbWVudCwgd2hpY2ggc2VydmVzIGFzIHRoZSBiaW5kaW5nIHNjb3BlIGZvciB0aGUgdGVtcGxhdGVcbiAgICAgICAqIGluc3RhbmNlIHRoZSBlbGVtZW50IGlzIGNvbnRhaW5lZCBpbi4gIEEgdGVtcGxhdGUgbW9kZWwgc2hvdWxkIGJlIHVzZWRcbiAgICAgICAqIHRvIG1hbmlwdWxhdGUgZGF0YSBhc3NvY2lhdGVkIHdpdGggdGhpcyB0ZW1wbGF0ZSBpbnN0YW5jZS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCBFbGVtZW50IGZvciB3aGljaCB0byByZXR1cm4gYSB0ZW1wbGF0ZSBtb2RlbC5cbiAgICAgICAqIEByZXR1cm4ge1RlbXBsYXRlSW5zdGFuY2VCYXNlfSBNb2RlbCByZXByZXNlbnRpbmcgdGhlIGJpbmRpbmcgc2NvcGUgZm9yXG4gICAgICAgKiAgIHRoZSBlbGVtZW50LlxuICAgICAgICogQHRoaXMge1RlbXBsYXRpemVyVXNlcn1cbiAgICAgICAqL1xuICAgICAgbW9kZWxGb3JFbGVtZW50KGVsKSB7XG4gICAgICAgIHJldHVybiBQb2x5bWVyLlRlbXBsYXRpemUubW9kZWxGb3JFbGVtZW50KHRoaXMuX3RlbXBsYXRpemVyVGVtcGxhdGUsIGVsKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgUG9seW1lci5UZW1wbGF0aXplciA9IFRlbXBsYXRpemVyO1xuXG4gIH0pKCk7XG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvbGVnYWN5L3RlbXBsYXRpemVyLWJlaGF2aW9yLmh0bWwiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi91dGlscy9ib290Lmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi9taXhpbnMvcHJvcGVydHktZWZmZWN0cy5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vbWl4aW5zL211dGFibGUtZGF0YS5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vbWl4aW5zL2dlc3R1cmUtZXZlbnQtbGlzdGVuZXJzLmh0bWxcIj5cblxuPHNjcmlwdD5cblxuICAoZnVuY3Rpb24oKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQGV4dGVuZHMge0hUTUxFbGVtZW50fVxuICAgICAqIEBpbXBsZW1lbnRzIHtQb2x5bWVyX1Byb3BlcnR5RWZmZWN0c31cbiAgICAgKiBAaW1wbGVtZW50cyB7UG9seW1lcl9PcHRpb25hbE11dGFibGVEYXRhfVxuICAgICAqIEBpbXBsZW1lbnRzIHtQb2x5bWVyX0dlc3R1cmVFdmVudExpc3RlbmVyc31cbiAgICAgKi9cbiAgICBjb25zdCBkb21CaW5kQmFzZSA9XG4gICAgICBQb2x5bWVyLkdlc3R1cmVFdmVudExpc3RlbmVycyhcbiAgICAgICAgUG9seW1lci5PcHRpb25hbE11dGFibGVEYXRhKFxuICAgICAgICAgIFBvbHltZXIuUHJvcGVydHlFZmZlY3RzKEhUTUxFbGVtZW50KSkpO1xuXG4gICAgLyoqXG4gICAgICogQ3VzdG9tIGVsZW1lbnQgdG8gYWxsb3cgdXNpbmcgUG9seW1lcidzIHRlbXBsYXRlIGZlYXR1cmVzIChkYXRhIGJpbmRpbmcsXG4gICAgICogZGVjbGFyYXRpdmUgZXZlbnQgbGlzdGVuZXJzLCBldGMuKSBpbiB0aGUgbWFpbiBkb2N1bWVudCB3aXRob3V0IGRlZmluaW5nXG4gICAgICogYSBuZXcgY3VzdG9tIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBgPHRlbXBsYXRlPmAgdGFncyB1dGlsaXppbmcgYmluZGluZ3MgbWF5IGJlIHdyYXBwZWQgd2l0aCB0aGUgYDxkb20tYmluZD5gXG4gICAgICogZWxlbWVudCwgd2hpY2ggd2lsbCBpbW1lZGlhdGVseSBzdGFtcCB0aGUgd3JhcHBlZCB0ZW1wbGF0ZSBpbnRvIHRoZSBtYWluXG4gICAgICogZG9jdW1lbnQgYW5kIGJpbmQgZWxlbWVudHMgdG8gdGhlIGBkb20tYmluZGAgZWxlbWVudCBpdHNlbGYgYXMgdGhlXG4gICAgICogYmluZGluZyBzY29wZS5cbiAgICAgKlxuICAgICAqIEBwb2x5bWVyXG4gICAgICogQGN1c3RvbUVsZW1lbnRcbiAgICAgKiBAYXBwbGllc01peGluIFBvbHltZXIuUHJvcGVydHlFZmZlY3RzXG4gICAgICogQGFwcGxpZXNNaXhpbiBQb2x5bWVyLk9wdGlvbmFsTXV0YWJsZURhdGFcbiAgICAgKiBAYXBwbGllc01peGluIFBvbHltZXIuR2VzdHVyZUV2ZW50TGlzdGVuZXJzXG4gICAgICogQGV4dGVuZHMge2RvbUJpbmRCYXNlfVxuICAgICAqIEBtZW1iZXJvZiBQb2x5bWVyXG4gICAgICogQHN1bW1hcnkgQ3VzdG9tIGVsZW1lbnQgdG8gYWxsb3cgdXNpbmcgUG9seW1lcidzIHRlbXBsYXRlIGZlYXR1cmVzIChkYXRhXG4gICAgICogICBiaW5kaW5nLCBkZWNsYXJhdGl2ZSBldmVudCBsaXN0ZW5lcnMsIGV0Yy4pIGluIHRoZSBtYWluIGRvY3VtZW50LlxuICAgICAqL1xuICAgIGNsYXNzIERvbUJpbmQgZXh0ZW5kcyBkb21CaW5kQmFzZSB7XG5cbiAgICAgIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkgeyByZXR1cm4gWydtdXRhYmxlLWRhdGEnXSB9XG5cbiAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnJvb3QgPSBudWxsO1xuICAgICAgICB0aGlzLiQgPSBudWxsO1xuICAgICAgICB0aGlzLl9fY2hpbGRyZW4gPSBudWxsO1xuICAgICAgfVxuXG4gICAgICAvLyBhc3N1bWVzIG9ubHkgb25lIG9ic2VydmVkIGF0dHJpYnV0ZVxuICAgICAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKCkge1xuICAgICAgICB0aGlzLm11dGFibGVEYXRhID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgICB9XG5cbiAgICAgIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgICAgICB0aGlzLl9fcmVtb3ZlQ2hpbGRyZW4oKTtcbiAgICAgIH1cblxuICAgICAgX19pbnNlcnRDaGlsZHJlbigpIHtcbiAgICAgICAgdGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzLnJvb3QsIHRoaXMpO1xuICAgICAgfVxuXG4gICAgICBfX3JlbW92ZUNoaWxkcmVuKCkge1xuICAgICAgICBpZiAodGhpcy5fX2NoaWxkcmVuKSB7XG4gICAgICAgICAgZm9yIChsZXQgaT0wOyBpPHRoaXMuX19jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5yb290LmFwcGVuZENoaWxkKHRoaXMuX19jaGlsZHJlbltpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogRm9yY2VzIHRoZSBlbGVtZW50IHRvIHJlbmRlciBpdHMgY29udGVudC4gVGhpcyBpcyB0eXBpY2FsbHkgb25seVxuICAgICAgICogbmVjZXNzYXJ5IHRvIGNhbGwgaWYgSFRNTEltcG9ydHMgd2l0aCB0aGUgYXN5bmMgYXR0cmlidXRlIGFyZSB1c2VkLlxuICAgICAgICovXG4gICAgICByZW5kZXIoKSB7XG4gICAgICAgIGxldCB0ZW1wbGF0ZTtcbiAgICAgICAgaWYgKCF0aGlzLl9fY2hpbGRyZW4pIHtcbiAgICAgICAgICB0ZW1wbGF0ZSA9IC8qKiBAdHlwZSB7SFRNTFRlbXBsYXRlRWxlbWVudH0gKi8odGVtcGxhdGUgfHwgdGhpcy5xdWVyeVNlbGVjdG9yKCd0ZW1wbGF0ZScpKTtcbiAgICAgICAgICBpZiAoIXRlbXBsYXRlKSB7XG4gICAgICAgICAgICAvLyBXYWl0IHVudGlsIGNoaWxkTGlzdCBjaGFuZ2VzIGFuZCB0ZW1wbGF0ZSBzaG91bGQgYmUgdGhlcmUgYnkgdGhlblxuICAgICAgICAgICAgbGV0IG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoKCkgPT4ge1xuICAgICAgICAgICAgICB0ZW1wbGF0ZSA9IC8qKiBAdHlwZSB7SFRNTFRlbXBsYXRlRWxlbWVudH0gKi8odGhpcy5xdWVyeVNlbGVjdG9yKCd0ZW1wbGF0ZScpKTtcbiAgICAgICAgICAgICAgaWYgKHRlbXBsYXRlKSB7XG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkb20tYmluZCByZXF1aXJlcyBhIDx0ZW1wbGF0ZT4gY2hpbGQnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIG9ic2VydmVyLm9ic2VydmUodGhpcywge2NoaWxkTGlzdDogdHJ1ZX0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnJvb3QgPSB0aGlzLl9zdGFtcFRlbXBsYXRlKHRlbXBsYXRlKTtcbiAgICAgICAgICB0aGlzLiQgPSB0aGlzLnJvb3QuJDtcbiAgICAgICAgICB0aGlzLl9fY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgICBmb3IgKGxldCBuPXRoaXMucm9vdC5maXJzdENoaWxkOyBuOyBuPW4ubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuX19jaGlsZHJlblt0aGlzLl9fY2hpbGRyZW4ubGVuZ3RoXSA9IG47XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX2VuYWJsZVByb3BlcnRpZXMoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9faW5zZXJ0Q2hpbGRyZW4oKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnZG9tLWNoYW5nZScsIHtcbiAgICAgICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgICAgIGNvbXBvc2VkOiB0cnVlXG4gICAgICAgIH0pKTtcbiAgICAgIH1cblxuICAgIH1cblxuICAgIGN1c3RvbUVsZW1lbnRzLmRlZmluZSgnZG9tLWJpbmQnLCBEb21CaW5kKTtcblxuICB9KSgpO1xuXG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvZWxlbWVudHMvZG9tLWJpbmQuaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cblxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uLy4uL3BvbHltZXItZWxlbWVudC5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vdXRpbHMvdGVtcGxhdGl6ZS5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vdXRpbHMvZGVib3VuY2UuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3V0aWxzL2ZsdXNoLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi9taXhpbnMvbXV0YWJsZS1kYXRhLmh0bWxcIj5cblxuPHNjcmlwdD5cbihmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIGxldCBUZW1wbGF0ZUluc3RhbmNlQmFzZSA9IFBvbHltZXIuVGVtcGxhdGVJbnN0YW5jZUJhc2U7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBpbXBsZW1lbnRzIHtQb2x5bWVyX09wdGlvbmFsTXV0YWJsZURhdGF9XG4gICAqIEBleHRlbmRzIHtQb2x5bWVyLkVsZW1lbnR9XG4gICAqL1xuICBjb25zdCBkb21SZXBlYXRCYXNlID0gUG9seW1lci5PcHRpb25hbE11dGFibGVEYXRhKFBvbHltZXIuRWxlbWVudCk7XG5cbiAgLyoqXG4gICAqIFRoZSBgPGRvbS1yZXBlYXQ+YCBlbGVtZW50IHdpbGwgYXV0b21hdGljYWxseSBzdGFtcCBhbmQgYmluZHMgb25lIGluc3RhbmNlXG4gICAqIG9mIHRlbXBsYXRlIGNvbnRlbnQgdG8gZWFjaCBvYmplY3QgaW4gYSB1c2VyLXByb3ZpZGVkIGFycmF5LlxuICAgKiBgZG9tLXJlcGVhdGAgYWNjZXB0cyBhbiBgaXRlbXNgIHByb3BlcnR5LCBhbmQgb25lIGluc3RhbmNlIG9mIHRoZSB0ZW1wbGF0ZVxuICAgKiBpcyBzdGFtcGVkIGZvciBlYWNoIGl0ZW0gaW50byB0aGUgRE9NIGF0IHRoZSBsb2NhdGlvbiBvZiB0aGUgYGRvbS1yZXBlYXRgXG4gICAqIGVsZW1lbnQuICBUaGUgYGl0ZW1gIHByb3BlcnR5IHdpbGwgYmUgc2V0IG9uIGVhY2ggaW5zdGFuY2UncyBiaW5kaW5nXG4gICAqIHNjb3BlLCB0aHVzIHRlbXBsYXRlcyBzaG91bGQgYmluZCB0byBzdWItcHJvcGVydGllcyBvZiBgaXRlbWAuXG4gICAqXG4gICAqIEV4YW1wbGU6XG4gICAqXG4gICAqIGBgYGh0bWxcbiAgICogPGRvbS1tb2R1bGUgaWQ9XCJlbXBsb3llZS1saXN0XCI+XG4gICAqXG4gICAqICAgPHRlbXBsYXRlPlxuICAgKlxuICAgKiAgICAgPGRpdj4gRW1wbG95ZWUgbGlzdDogPC9kaXY+XG4gICAqICAgICA8dGVtcGxhdGUgaXM9XCJkb20tcmVwZWF0XCIgaXRlbXM9XCJ7e2VtcGxveWVlc319XCI+XG4gICAqICAgICAgICAgPGRpdj5GaXJzdCBuYW1lOiA8c3Bhbj57e2l0ZW0uZmlyc3R9fTwvc3Bhbj48L2Rpdj5cbiAgICogICAgICAgICA8ZGl2Pkxhc3QgbmFtZTogPHNwYW4+e3tpdGVtLmxhc3R9fTwvc3Bhbj48L2Rpdj5cbiAgICogICAgIDwvdGVtcGxhdGU+XG4gICAqXG4gICAqICAgPC90ZW1wbGF0ZT5cbiAgICpcbiAgICogICA8c2NyaXB0PlxuICAgKiAgICAgUG9seW1lcih7XG4gICAqICAgICAgIGlzOiAnZW1wbG95ZWUtbGlzdCcsXG4gICAqICAgICAgIHJlYWR5OiBmdW5jdGlvbigpIHtcbiAgICogICAgICAgICB0aGlzLmVtcGxveWVlcyA9IFtcbiAgICogICAgICAgICAgICAge2ZpcnN0OiAnQm9iJywgbGFzdDogJ1NtaXRoJ30sXG4gICAqICAgICAgICAgICAgIHtmaXJzdDogJ1NhbGx5JywgbGFzdDogJ0pvaG5zb24nfSxcbiAgICogICAgICAgICAgICAgLi4uXG4gICAqICAgICAgICAgXTtcbiAgICogICAgICAgfVxuICAgKiAgICAgfSk7XG4gICAqICAgPCAvc2NyaXB0PlxuICAgKlxuICAgKiA8L2RvbS1tb2R1bGU+XG4gICAqIGBgYFxuICAgKlxuICAgKiBOb3RpZmljYXRpb25zIGZvciBjaGFuZ2VzIHRvIGl0ZW1zIHN1Yi1wcm9wZXJ0aWVzIHdpbGwgYmUgZm9yd2FyZGVkIHRvIHRlbXBsYXRlXG4gICAqIGluc3RhbmNlcywgd2hpY2ggd2lsbCB1cGRhdGUgdmlhIHRoZSBub3JtYWwgc3RydWN0dXJlZCBkYXRhIG5vdGlmaWNhdGlvbiBzeXN0ZW0uXG4gICAqXG4gICAqIE11dGF0aW9ucyB0byB0aGUgYGl0ZW1zYCBhcnJheSBpdHNlbGYgc2hvdWxkIGJlIG1hZGUgdXNpbmcgdGhlIEFycmF5XG4gICAqIG11dGF0aW9uIEFQSSdzIG9uIGBQb2x5bWVyLkJhc2VgIChgcHVzaGAsIGBwb3BgLCBgc3BsaWNlYCwgYHNoaWZ0YCxcbiAgICogYHVuc2hpZnRgKSwgYW5kIHRlbXBsYXRlIGluc3RhbmNlcyB3aWxsIGJlIGtlcHQgaW4gc3luYyB3aXRoIHRoZSBkYXRhIGluIHRoZVxuICAgKiBhcnJheS5cbiAgICpcbiAgICogRXZlbnRzIGNhdWdodCBieSBldmVudCBoYW5kbGVycyB3aXRoaW4gdGhlIGBkb20tcmVwZWF0YCB0ZW1wbGF0ZSB3aWxsIGJlXG4gICAqIGRlY29yYXRlZCB3aXRoIGEgYG1vZGVsYCBwcm9wZXJ0eSwgd2hpY2ggcmVwcmVzZW50cyB0aGUgYmluZGluZyBzY29wZSBmb3JcbiAgICogZWFjaCB0ZW1wbGF0ZSBpbnN0YW5jZS4gIFRoZSBtb2RlbCBpcyBhbiBpbnN0YW5jZSBvZiBQb2x5bWVyLkJhc2UsIGFuZCBzaG91bGRcbiAgICogYmUgdXNlZCB0byBtYW5pcHVsYXRlIGRhdGEgb24gdGhlIGluc3RhbmNlLCBmb3IgZXhhbXBsZVxuICAgKiBgZXZlbnQubW9kZWwuc2V0KCdpdGVtLmNoZWNrZWQnLCB0cnVlKTtgLlxuICAgKlxuICAgKiBBbHRlcm5hdGl2ZWx5LCB0aGUgbW9kZWwgZm9yIGEgdGVtcGxhdGUgaW5zdGFuY2UgZm9yIGFuIGVsZW1lbnQgc3RhbXBlZCBieVxuICAgKiBhIGBkb20tcmVwZWF0YCBjYW4gYmUgb2J0YWluZWQgdXNpbmcgdGhlIGBtb2RlbEZvckVsZW1lbnRgIEFQSSBvbiB0aGVcbiAgICogYGRvbS1yZXBlYXRgIHRoYXQgc3RhbXBlZCBpdCwgZm9yIGV4YW1wbGVcbiAgICogYHRoaXMuJC5kb21SZXBlYXQubW9kZWxGb3JFbGVtZW50KGV2ZW50LnRhcmdldCkuc2V0KCdpdGVtLmNoZWNrZWQnLCB0cnVlKTtgLlxuICAgKiBUaGlzIG1heSBiZSB1c2VmdWwgZm9yIG1hbmlwdWxhdGluZyBpbnN0YW5jZSBkYXRhIG9mIGV2ZW50IHRhcmdldHMgb2J0YWluZWRcbiAgICogYnkgZXZlbnQgaGFuZGxlcnMgb24gcGFyZW50cyBvZiB0aGUgYGRvbS1yZXBlYXRgIChldmVudCBkZWxlZ2F0aW9uKS5cbiAgICpcbiAgICogQSB2aWV3LXNwZWNpZmljIGZpbHRlci9zb3J0IG1heSBiZSBhcHBsaWVkIHRvIGVhY2ggYGRvbS1yZXBlYXRgIGJ5IHN1cHBseWluZyBhXG4gICAqIGBmaWx0ZXJgIGFuZC9vciBgc29ydGAgcHJvcGVydHkuICBUaGlzIG1heSBiZSBhIHN0cmluZyB0aGF0IG5hbWVzIGEgZnVuY3Rpb24gb25cbiAgICogdGhlIGhvc3QsIG9yIGEgZnVuY3Rpb24gbWF5IGJlIGFzc2lnbmVkIHRvIHRoZSBwcm9wZXJ0eSBkaXJlY3RseS4gIFRoZSBmdW5jdGlvbnNcbiAgICogc2hvdWxkIGltcGxlbWVudGVkIGZvbGxvd2luZyB0aGUgc3RhbmRhcmQgYEFycmF5YCBmaWx0ZXIvc29ydCBBUEkuXG4gICAqXG4gICAqIEluIG9yZGVyIHRvIHJlLXJ1biB0aGUgZmlsdGVyIG9yIHNvcnQgZnVuY3Rpb25zIGJhc2VkIG9uIGNoYW5nZXMgdG8gc3ViLWZpZWxkc1xuICAgKiBvZiBgaXRlbXNgLCB0aGUgYG9ic2VydmVgIHByb3BlcnR5IG1heSBiZSBzZXQgYXMgYSBzcGFjZS1zZXBhcmF0ZWQgbGlzdCBvZlxuICAgKiBgaXRlbWAgc3ViLWZpZWxkcyB0aGF0IHNob3VsZCBjYXVzZSBhIHJlLWZpbHRlci9zb3J0IHdoZW4gbW9kaWZpZWQuICBJZlxuICAgKiB0aGUgZmlsdGVyIG9yIHNvcnQgZnVuY3Rpb24gZGVwZW5kcyBvbiBwcm9wZXJ0aWVzIG5vdCBjb250YWluZWQgaW4gYGl0ZW1zYCxcbiAgICogdGhlIHVzZXIgc2hvdWxkIG9ic2VydmUgY2hhbmdlcyB0byB0aG9zZSBwcm9wZXJ0aWVzIGFuZCBjYWxsIGByZW5kZXJgIHRvIHVwZGF0ZVxuICAgKiB0aGUgdmlldyBiYXNlZCBvbiB0aGUgZGVwZW5kZW5jeSBjaGFuZ2UuXG4gICAqXG4gICAqIEZvciBleGFtcGxlLCBmb3IgYW4gYGRvbS1yZXBlYXRgIHdpdGggYSBmaWx0ZXIgb2YgdGhlIGZvbGxvd2luZzpcbiAgICpcbiAgICogYGBganNcbiAgICogaXNFbmdpbmVlcjogZnVuY3Rpb24oaXRlbSkge1xuICAgKiAgICAgcmV0dXJuIGl0ZW0udHlwZSA9PSAnZW5naW5lZXInIHx8IGl0ZW0ubWFuYWdlci50eXBlID09ICdlbmdpbmVlcic7XG4gICAqIH1cbiAgICogYGBgXG4gICAqXG4gICAqIFRoZW4gdGhlIGBvYnNlcnZlYCBwcm9wZXJ0eSBzaG91bGQgYmUgY29uZmlndXJlZCBhcyBmb2xsb3dzOlxuICAgKlxuICAgKiBgYGBodG1sXG4gICAqIDx0ZW1wbGF0ZSBpcz1cImRvbS1yZXBlYXRcIiBpdGVtcz1cInt7ZW1wbG95ZWVzfX1cIlxuICAgKiAgICAgICAgICAgZmlsdGVyPVwiaXNFbmdpbmVlclwiIG9ic2VydmU9XCJ0eXBlIG1hbmFnZXIudHlwZVwiPlxuICAgKiBgYGBcbiAgICpcbiAgICogQGN1c3RvbUVsZW1lbnRcbiAgICogQHBvbHltZXJcbiAgICogQG1lbWJlcm9mIFBvbHltZXJcbiAgICogQGV4dGVuZHMge2RvbVJlcGVhdEJhc2V9XG4gICAqIEBhcHBsaWVzTWl4aW4gUG9seW1lci5PcHRpb25hbE11dGFibGVEYXRhXG4gICAqIEBzdW1tYXJ5IEN1c3RvbSBlbGVtZW50IGZvciBzdGFtcGluZyBpbnN0YW5jZSBvZiBhIHRlbXBsYXRlIGJvdW5kIHRvXG4gICAqICAgaXRlbXMgaW4gYW4gYXJyYXkuXG4gICAqL1xuICBjbGFzcyBEb21SZXBlYXQgZXh0ZW5kcyBkb21SZXBlYXRCYXNlIHtcblxuICAgIC8vIE5vdCBuZWVkZWQgdG8gZmluZCB0ZW1wbGF0ZTsgY2FuIGJlIHJlbW92ZWQgb25jZSB0aGUgYW5hbHl6ZXJcbiAgICAvLyBjYW4gZmluZCB0aGUgdGFnIG5hbWUgZnJvbSBjdXN0b21FbGVtZW50cy5kZWZpbmUgY2FsbFxuICAgIHN0YXRpYyBnZXQgaXMoKSB7IHJldHVybiAnZG9tLXJlcGVhdCc7IH1cblxuICAgIHN0YXRpYyBnZXQgdGVtcGxhdGUoKSB7IHJldHVybiBudWxsOyB9XG5cbiAgICBzdGF0aWMgZ2V0IHByb3BlcnRpZXMoKSB7XG5cbiAgICAgIC8qKlxuICAgICAgICogRmlyZWQgd2hlbmV2ZXIgRE9NIGlzIGFkZGVkIG9yIHJlbW92ZWQgYnkgdGhpcyB0ZW1wbGF0ZSAoYnlcbiAgICAgICAqIGRlZmF1bHQsIHJlbmRlcmluZyBvY2N1cnMgbGF6aWx5KS4gIFRvIGZvcmNlIGltbWVkaWF0ZSByZW5kZXJpbmcsIGNhbGxcbiAgICAgICAqIGByZW5kZXJgLlxuICAgICAgICpcbiAgICAgICAqIEBldmVudCBkb20tY2hhbmdlXG4gICAgICAgKi9cbiAgICAgIHJldHVybiB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIGFycmF5IGNvbnRhaW5pbmcgaXRlbXMgZGV0ZXJtaW5pbmcgaG93IG1hbnkgaW5zdGFuY2VzIG9mIHRoZSB0ZW1wbGF0ZVxuICAgICAgICAgKiB0byBzdGFtcCBhbmQgdGhhdCB0aGF0IGVhY2ggdGVtcGxhdGUgaW5zdGFuY2Ugc2hvdWxkIGJpbmQgdG8uXG4gICAgICAgICAqL1xuICAgICAgICBpdGVtczoge1xuICAgICAgICAgIHR5cGU6IEFycmF5XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBuYW1lIG9mIHRoZSB2YXJpYWJsZSB0byBhZGQgdG8gdGhlIGJpbmRpbmcgc2NvcGUgZm9yIHRoZSBhcnJheVxuICAgICAgICAgKiBlbGVtZW50IGFzc29jaWF0ZWQgd2l0aCBhIGdpdmVuIHRlbXBsYXRlIGluc3RhbmNlLlxuICAgICAgICAgKi9cbiAgICAgICAgYXM6IHtcbiAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgdmFsdWU6ICdpdGVtJ1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbmFtZSBvZiB0aGUgdmFyaWFibGUgdG8gYWRkIHRvIHRoZSBiaW5kaW5nIHNjb3BlIHdpdGggdGhlIGluZGV4XG4gICAgICAgICAqIG9mIHRoZSBpbnN0YW5jZSBpbiB0aGUgc29ydGVkIGFuZCBmaWx0ZXJlZCBsaXN0IG9mIHJlbmRlcmVkIGl0ZW1zLlxuICAgICAgICAgKiBOb3RlLCBmb3IgdGhlIGluZGV4IGluIHRoZSBgdGhpcy5pdGVtc2AgYXJyYXksIHVzZSB0aGUgdmFsdWUgb2YgdGhlXG4gICAgICAgICAqIGBpdGVtc0luZGV4QXNgIHByb3BlcnR5LlxuICAgICAgICAgKi9cbiAgICAgICAgaW5kZXhBczoge1xuICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICB2YWx1ZTogJ2luZGV4J1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbmFtZSBvZiB0aGUgdmFyaWFibGUgdG8gYWRkIHRvIHRoZSBiaW5kaW5nIHNjb3BlIHdpdGggdGhlIGluZGV4XG4gICAgICAgICAqIG9mIHRoZSBpbnN0YW5jZSBpbiB0aGUgYHRoaXMuaXRlbXNgIGFycmF5LiBOb3RlLCBmb3IgdGhlIGluZGV4IG9mXG4gICAgICAgICAqIHRoaXMgaW5zdGFuY2UgaW4gdGhlIHNvcnRlZCBhbmQgZmlsdGVyZWQgbGlzdCBvZiByZW5kZXJlZCBpdGVtcyxcbiAgICAgICAgICogdXNlIHRoZSB2YWx1ZSBvZiB0aGUgYGluZGV4QXNgIHByb3BlcnR5LlxuICAgICAgICAgKi9cbiAgICAgICAgaXRlbXNJbmRleEFzOiB7XG4gICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgIHZhbHVlOiAnaXRlbXNJbmRleCdcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQSBmdW5jdGlvbiB0aGF0IHNob3VsZCBkZXRlcm1pbmUgdGhlIHNvcnQgb3JkZXIgb2YgdGhlIGl0ZW1zLiAgVGhpc1xuICAgICAgICAgKiBwcm9wZXJ0eSBzaG91bGQgZWl0aGVyIGJlIHByb3ZpZGVkIGFzIGEgc3RyaW5nLCBpbmRpY2F0aW5nIGEgbWV0aG9kXG4gICAgICAgICAqIG5hbWUgb24gdGhlIGVsZW1lbnQncyBob3N0LCBvciBlbHNlIGJlIGFuIGFjdHVhbCBmdW5jdGlvbi4gIFRoZVxuICAgICAgICAgKiBmdW5jdGlvbiBzaG91bGQgbWF0Y2ggdGhlIHNvcnQgZnVuY3Rpb24gcGFzc2VkIHRvIGBBcnJheS5zb3J0YC5cbiAgICAgICAgICogVXNpbmcgYSBzb3J0IGZ1bmN0aW9uIGhhcyBubyBlZmZlY3Qgb24gdGhlIHVuZGVybHlpbmcgYGl0ZW1zYCBhcnJheS5cbiAgICAgICAgICovXG4gICAgICAgIHNvcnQ6IHtcbiAgICAgICAgICB0eXBlOiBGdW5jdGlvbixcbiAgICAgICAgICBvYnNlcnZlcjogJ19fc29ydENoYW5nZWQnXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCB0byBmaWx0ZXIgaXRlbXMgb3V0IG9mIHRoZSB2aWV3LiAgVGhpc1xuICAgICAgICAgKiBwcm9wZXJ0eSBzaG91bGQgZWl0aGVyIGJlIHByb3ZpZGVkIGFzIGEgc3RyaW5nLCBpbmRpY2F0aW5nIGEgbWV0aG9kXG4gICAgICAgICAqIG5hbWUgb24gdGhlIGVsZW1lbnQncyBob3N0LCBvciBlbHNlIGJlIGFuIGFjdHVhbCBmdW5jdGlvbi4gIFRoZVxuICAgICAgICAgKiBmdW5jdGlvbiBzaG91bGQgbWF0Y2ggdGhlIHNvcnQgZnVuY3Rpb24gcGFzc2VkIHRvIGBBcnJheS5maWx0ZXJgLlxuICAgICAgICAgKiBVc2luZyBhIGZpbHRlciBmdW5jdGlvbiBoYXMgbm8gZWZmZWN0IG9uIHRoZSB1bmRlcmx5aW5nIGBpdGVtc2AgYXJyYXkuXG4gICAgICAgICAqL1xuICAgICAgICBmaWx0ZXI6IHtcbiAgICAgICAgICB0eXBlOiBGdW5jdGlvbixcbiAgICAgICAgICBvYnNlcnZlcjogJ19fZmlsdGVyQ2hhbmdlZCdcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogV2hlbiB1c2luZyBhIGBmaWx0ZXJgIG9yIGBzb3J0YCBmdW5jdGlvbiwgdGhlIGBvYnNlcnZlYCBwcm9wZXJ0eVxuICAgICAgICAgKiBzaG91bGQgYmUgc2V0IHRvIGEgc3BhY2Utc2VwYXJhdGVkIGxpc3Qgb2YgdGhlIG5hbWVzIG9mIGl0ZW1cbiAgICAgICAgICogc3ViLWZpZWxkcyB0aGF0IHNob3VsZCB0cmlnZ2VyIGEgcmUtc29ydCBvciByZS1maWx0ZXIgd2hlbiBjaGFuZ2VkLlxuICAgICAgICAgKiBUaGVzZSBzaG91bGQgZ2VuZXJhbGx5IGJlIGZpZWxkcyBvZiBgaXRlbWAgdGhhdCB0aGUgc29ydCBvciBmaWx0ZXJcbiAgICAgICAgICogZnVuY3Rpb24gZGVwZW5kcyBvbi5cbiAgICAgICAgICovXG4gICAgICAgIG9ic2VydmU6IHtcbiAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgb2JzZXJ2ZXI6ICdfX29ic2VydmVDaGFuZ2VkJ1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGVuIHVzaW5nIGEgYGZpbHRlcmAgb3IgYHNvcnRgIGZ1bmN0aW9uLCB0aGUgYGRlbGF5YCBwcm9wZXJ0eVxuICAgICAgICAgKiBkZXRlcm1pbmVzIGEgZGVib3VuY2UgdGltZSBhZnRlciBhIGNoYW5nZSB0byBvYnNlcnZlZCBpdGVtXG4gICAgICAgICAqIHByb3BlcnRpZXMgdGhhdCBtdXN0IHBhc3MgYmVmb3JlIHRoZSBmaWx0ZXIgb3Igc29ydCBpcyByZS1ydW4uXG4gICAgICAgICAqIFRoaXMgaXMgdXNlZnVsIGluIHJhdGUtbGltaXRpbmcgc2h1ZmZpbmcgb2YgdGhlIHZpZXcgd2hlblxuICAgICAgICAgKiBpdGVtIGNoYW5nZXMgbWF5IGJlIGZyZXF1ZW50LlxuICAgICAgICAgKi9cbiAgICAgICAgZGVsYXk6IE51bWJlcixcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ291bnQgb2YgY3VycmVudGx5IHJlbmRlcmVkIGl0ZW1zIGFmdGVyIGBmaWx0ZXJgIChpZiBhbnkpIGhhcyBiZWVuIGFwcGxpZWQuXG4gICAgICAgICAqIElmIFwiY2h1bmtpbmcgbW9kZVwiIGlzIGVuYWJsZWQsIGByZW5kZXJlZEl0ZW1Db3VudGAgaXMgdXBkYXRlZCBlYWNoIHRpbWUgYVxuICAgICAgICAgKiBzZXQgb2YgdGVtcGxhdGUgaW5zdGFuY2VzIGlzIHJlbmRlcmVkLlxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgcmVuZGVyZWRJdGVtQ291bnQ6IHtcbiAgICAgICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICAgICAgbm90aWZ5OiB0cnVlLFxuICAgICAgICAgIHJlYWRPbmx5OiB0cnVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlZmluZXMgYW4gaW5pdGlhbCBjb3VudCBvZiB0ZW1wbGF0ZSBpbnN0YW5jZXMgdG8gcmVuZGVyIGFmdGVyIHNldHRpbmdcbiAgICAgICAgICogdGhlIGBpdGVtc2AgYXJyYXksIGJlZm9yZSB0aGUgbmV4dCBwYWludCwgYW5kIHB1dHMgdGhlIGBkb20tcmVwZWF0YFxuICAgICAgICAgKiBpbnRvIFwiY2h1bmtpbmcgbW9kZVwiLiAgVGhlIHJlbWFpbmluZyBpdGVtcyB3aWxsIGJlIGNyZWF0ZWQgYW5kIHJlbmRlcmVkXG4gICAgICAgICAqIGluY3JlbWVudGFsbHkgYXQgZWFjaCBhbmltYXRpb24gZnJhbWUgdGhlcm9mIHVudGlsIGFsbCBpbnN0YW5jZXMgaGF2ZVxuICAgICAgICAgKiBiZWVuIHJlbmRlcmVkLlxuICAgICAgICAgKi9cbiAgICAgICAgaW5pdGlhbENvdW50OiB7XG4gICAgICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgICAgIG9ic2VydmVyOiAnX19pbml0aWFsaXplQ2h1bmtpbmcnXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZW4gYGluaXRpYWxDb3VudGAgaXMgdXNlZCwgdGhpcyBwcm9wZXJ0eSBkZWZpbmVzIGEgZnJhbWUgcmF0ZSB0b1xuICAgICAgICAgKiB0YXJnZXQgYnkgdGhyb3R0bGluZyB0aGUgbnVtYmVyIG9mIGluc3RhbmNlcyByZW5kZXJlZCBlYWNoIGZyYW1lIHRvXG4gICAgICAgICAqIG5vdCBleGNlZWQgdGhlIGJ1ZGdldCBmb3IgdGhlIHRhcmdldCBmcmFtZSByYXRlLiAgU2V0dGluZyB0aGlzIHRvIGFcbiAgICAgICAgICogaGlnaGVyIG51bWJlciB3aWxsIGFsbG93IGxvd2VyIGxhdGVuY3kgYW5kIGhpZ2hlciB0aHJvdWdocHV0IGZvclxuICAgICAgICAgKiB0aGluZ3MgbGlrZSBldmVudCBoYW5kbGVycywgYnV0IHdpbGwgcmVzdWx0IGluIGEgbG9uZ2VyIHRpbWUgZm9yIHRoZVxuICAgICAgICAgKiByZW1haW5pbmcgaXRlbXMgdG8gY29tcGxldGUgcmVuZGVyaW5nLlxuICAgICAgICAgKi9cbiAgICAgICAgdGFyZ2V0RnJhbWVyYXRlOiB7XG4gICAgICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgICAgIHZhbHVlOiAyMFxuICAgICAgICB9LFxuXG4gICAgICAgIF90YXJnZXRGcmFtZVRpbWU6IHtcbiAgICAgICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICAgICAgY29tcHV0ZWQ6ICdfX2NvbXB1dGVGcmFtZVRpbWUodGFyZ2V0RnJhbWVyYXRlKSdcbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0IG9ic2VydmVycygpIHtcbiAgICAgIHJldHVybiBbICdfX2l0ZW1zQ2hhbmdlZChpdGVtcy4qKScgXVxuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgc3VwZXIoKTtcbiAgICAgIHRoaXMuX19pbnN0YW5jZXMgPSBbXTtcbiAgICAgIHRoaXMuX19saW1pdCA9IEluZmluaXR5O1xuICAgICAgdGhpcy5fX3Bvb2wgPSBbXTtcbiAgICAgIHRoaXMuX19yZW5kZXJEZWJvdW5jZXIgPSBudWxsO1xuICAgICAgdGhpcy5fX2l0ZW1zSWR4VG9JbnN0SWR4ID0ge307XG4gICAgICB0aGlzLl9fY2h1bmtDb3VudCA9IG51bGw7XG4gICAgICB0aGlzLl9fbGFzdENodW5rVGltZSA9IG51bGw7XG4gICAgICB0aGlzLl9fc29ydEZuID0gbnVsbDtcbiAgICAgIHRoaXMuX19maWx0ZXJGbiA9IG51bGw7XG4gICAgICB0aGlzLl9fb2JzZXJ2ZVBhdGhzID0gbnVsbDtcbiAgICAgIHRoaXMuX19jdG9yID0gbnVsbDtcbiAgICAgIHRoaXMuX19pc0RldGFjaGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMudGVtcGxhdGUgPSBudWxsO1xuICAgIH1cblxuICAgIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgICAgc3VwZXIuZGlzY29ubmVjdGVkQ2FsbGJhY2soKTtcbiAgICAgIHRoaXMuX19pc0RldGFjaGVkID0gdHJ1ZTtcbiAgICAgIGZvciAobGV0IGk9MDsgaTx0aGlzLl9faW5zdGFuY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuX19kZXRhY2hJbnN0YW5jZShpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgIHN1cGVyLmNvbm5lY3RlZENhbGxiYWNrKCk7XG4gICAgICAvLyBvbmx5IHBlcmZvcm0gYXR0YWNobWVudCBpZiB0aGUgZWxlbWVudCB3YXMgcHJldmlvdXNseSBkZXRhY2hlZC5cbiAgICAgIGlmICh0aGlzLl9faXNEZXRhY2hlZCkge1xuICAgICAgICB0aGlzLl9faXNEZXRhY2hlZCA9IGZhbHNlO1xuICAgICAgICBsZXQgcGFyZW50ID0gdGhpcy5wYXJlbnROb2RlO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8dGhpcy5fX2luc3RhbmNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHRoaXMuX19hdHRhY2hJbnN0YW5jZShpLCBwYXJlbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgX19lbnN1cmVUZW1wbGF0aXplZCgpIHtcbiAgICAgIC8vIFRlbXBsYXRpemluZyAoZ2VuZXJhdGluZyB0aGUgaW5zdGFuY2UgY29uc3RydWN0b3IpIG5lZWRzIHRvIHdhaXRcbiAgICAgIC8vIHVudGlsIHJlYWR5LCBzaW5jZSB3b24ndCBoYXZlIGl0cyB0ZW1wbGF0ZSBjb250ZW50IGhhbmRlZCBiYWNrIHRvXG4gICAgICAvLyBpdCB1bnRpbCB0aGVuXG4gICAgICBpZiAoIXRoaXMuX19jdG9yKSB7XG4gICAgICAgIGxldCB0ZW1wbGF0ZSA9IHRoaXMudGVtcGxhdGUgPSB0aGlzLnF1ZXJ5U2VsZWN0b3IoJ3RlbXBsYXRlJyk7XG4gICAgICAgIGlmICghdGVtcGxhdGUpIHtcbiAgICAgICAgICAvLyAvLyBXYWl0IHVudGlsIGNoaWxkTGlzdCBjaGFuZ2VzIGFuZCB0ZW1wbGF0ZSBzaG91bGQgYmUgdGhlcmUgYnkgdGhlblxuICAgICAgICAgIGxldCBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKCgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLnF1ZXJ5U2VsZWN0b3IoJ3RlbXBsYXRlJykpIHtcbiAgICAgICAgICAgICAgb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgICB0aGlzLl9fcmVuZGVyKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RvbS1yZXBlYXQgcmVxdWlyZXMgYSA8dGVtcGxhdGU+IGNoaWxkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgICBvYnNlcnZlci5vYnNlcnZlKHRoaXMsIHtjaGlsZExpc3Q6IHRydWV9KTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGVtcGxhdGUgaW5zdGFuY2UgcHJvcHMgdGhhdCBzaG91bGQgYmUgZXhjbHVkZWQgZnJvbSBmb3J3YXJkaW5nXG4gICAgICAgIGxldCBpbnN0YW5jZVByb3BzID0ge307XG4gICAgICAgIGluc3RhbmNlUHJvcHNbdGhpcy5hc10gPSB0cnVlO1xuICAgICAgICBpbnN0YW5jZVByb3BzW3RoaXMuaW5kZXhBc10gPSB0cnVlO1xuICAgICAgICBpbnN0YW5jZVByb3BzW3RoaXMuaXRlbXNJbmRleEFzXSA9IHRydWU7XG4gICAgICAgIHRoaXMuX19jdG9yID0gUG9seW1lci5UZW1wbGF0aXplLnRlbXBsYXRpemUodGVtcGxhdGUsIHRoaXMsIHtcbiAgICAgICAgICBtdXRhYmxlRGF0YTogdGhpcy5tdXRhYmxlRGF0YSxcbiAgICAgICAgICBwYXJlbnRNb2RlbDogdHJ1ZSxcbiAgICAgICAgICBpbnN0YW5jZVByb3BzOiBpbnN0YW5jZVByb3BzLFxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIEB0aGlzIHt0aGlzfVxuICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wIFByb3BlcnR5IHRvIHNldFxuICAgICAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgdG8gc2V0IHByb3BlcnR5IHRvXG4gICAgICAgICAgICovXG4gICAgICAgICAgZm9yd2FyZEhvc3RQcm9wOiBmdW5jdGlvbihwcm9wLCB2YWx1ZSkge1xuICAgICAgICAgICAgbGV0IGkkID0gdGhpcy5fX2luc3RhbmNlcztcbiAgICAgICAgICAgIGZvciAobGV0IGk9MCwgaW5zdDsgKGk8aSQubGVuZ3RoKSAmJiAoaW5zdD1pJFtpXSk7IGkrKykge1xuICAgICAgICAgICAgICBpbnN0LmZvcndhcmRIb3N0UHJvcChwcm9wLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBAdGhpcyB7dGhpc31cbiAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5zdCBJbnN0YW5jZSB0byBub3RpZnlcbiAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcCBQcm9wZXJ0eSB0byBub3RpZnlcbiAgICAgICAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIG5vdGlmeVxuICAgICAgICAgICAqL1xuICAgICAgICAgIG5vdGlmeUluc3RhbmNlUHJvcDogZnVuY3Rpb24oaW5zdCwgcHJvcCwgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChQb2x5bWVyLlBhdGgubWF0Y2hlcyh0aGlzLmFzLCBwcm9wKSkge1xuICAgICAgICAgICAgICBsZXQgaWR4ID0gaW5zdFt0aGlzLml0ZW1zSW5kZXhBc107XG4gICAgICAgICAgICAgIGlmIChwcm9wID09IHRoaXMuYXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLml0ZW1zW2lkeF0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBsZXQgcGF0aCA9IFBvbHltZXIuUGF0aC50cmFuc2xhdGUodGhpcy5hcywgJ2l0ZW1zLicgKyBpZHgsIHByb3ApO1xuICAgICAgICAgICAgICB0aGlzLm5vdGlmeVBhdGgocGF0aCwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBfX2dldE1ldGhvZEhvc3QoKSB7XG4gICAgICAvLyBUZWNobmljYWxseSB0aGlzIHNob3VsZCBiZSB0aGUgb3duZXIgb2YgdGhlIG91dGVybW9zdCB0ZW1wbGF0ZS5cbiAgICAgIC8vIEluIHNoYWRvdyBkb20sIHRoaXMgaXMgYWx3YXlzIGdldFJvb3ROb2RlKCkuaG9zdCwgYnV0IHdlIGNhblxuICAgICAgLy8gYXBwcm94aW1hdGUgdGhpcyB2aWEgY29vcGVyYXRpb24gd2l0aCBvdXIgZGF0YUhvc3QgYWx3YXlzIHNldHRpbmdcbiAgICAgIC8vIGBfbWV0aG9kSG9zdGAgYXMgbG9uZyBhcyB0aGVyZSB3ZXJlIGJpbmRpbmdzIChvciBpZCdzKSBvbiB0aGlzXG4gICAgICAvLyBpbnN0YW5jZSBjYXVzaW5nIGl0IHRvIGdldCBhIGRhdGFIb3N0LlxuICAgICAgcmV0dXJuIHRoaXMuX19kYXRhSG9zdC5fbWV0aG9kSG9zdCB8fCB0aGlzLl9fZGF0YUhvc3Q7XG4gICAgfVxuXG4gICAgX19zb3J0Q2hhbmdlZChzb3J0KSB7XG4gICAgICBsZXQgbWV0aG9kSG9zdCA9IHRoaXMuX19nZXRNZXRob2RIb3N0KCk7XG4gICAgICB0aGlzLl9fc29ydEZuID0gc29ydCAmJiAodHlwZW9mIHNvcnQgPT0gJ2Z1bmN0aW9uJyA/IHNvcnQgOlxuICAgICAgICBmdW5jdGlvbigpIHsgcmV0dXJuIG1ldGhvZEhvc3Rbc29ydF0uYXBwbHkobWV0aG9kSG9zdCwgYXJndW1lbnRzKTsgfSk7XG4gICAgICBpZiAodGhpcy5pdGVtcykge1xuICAgICAgICB0aGlzLl9fZGVib3VuY2VSZW5kZXIodGhpcy5fX3JlbmRlcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgX19maWx0ZXJDaGFuZ2VkKGZpbHRlcikge1xuICAgICAgbGV0IG1ldGhvZEhvc3QgPSB0aGlzLl9fZ2V0TWV0aG9kSG9zdCgpO1xuICAgICAgdGhpcy5fX2ZpbHRlckZuID0gZmlsdGVyICYmICh0eXBlb2YgZmlsdGVyID09ICdmdW5jdGlvbicgPyBmaWx0ZXIgOlxuICAgICAgICBmdW5jdGlvbigpIHsgcmV0dXJuIG1ldGhvZEhvc3RbZmlsdGVyXS5hcHBseShtZXRob2RIb3N0LCBhcmd1bWVudHMpOyB9KTtcbiAgICAgIGlmICh0aGlzLml0ZW1zKSB7XG4gICAgICAgIHRoaXMuX19kZWJvdW5jZVJlbmRlcih0aGlzLl9fcmVuZGVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfX2NvbXB1dGVGcmFtZVRpbWUocmF0ZSkge1xuICAgICAgcmV0dXJuIE1hdGguY2VpbCgxMDAwL3JhdGUpO1xuICAgIH1cblxuICAgIF9faW5pdGlhbGl6ZUNodW5raW5nKCkge1xuICAgICAgaWYgKHRoaXMuaW5pdGlhbENvdW50KSB7XG4gICAgICAgIHRoaXMuX19saW1pdCA9IHRoaXMuaW5pdGlhbENvdW50O1xuICAgICAgICB0aGlzLl9fY2h1bmtDb3VudCA9IHRoaXMuaW5pdGlhbENvdW50O1xuICAgICAgICB0aGlzLl9fbGFzdENodW5rVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgfVxuICAgIH1cblxuICAgIF9fdHJ5UmVuZGVyQ2h1bmsoKSB7XG4gICAgICAvLyBEZWJvdW5jZWQgc28gdGhhdCBtdWx0aXBsZSBjYWxscyB0aHJvdWdoIGBfcmVuZGVyYCBiZXR3ZWVuIGFuaW1hdGlvblxuICAgICAgLy8gZnJhbWVzIG9ubHkgcXVldWUgb25lIG5ldyByQUYgKGUuZy4gYXJyYXkgbXV0YXRpb24gJiBjaHVua2VkIHJlbmRlcilcbiAgICAgIGlmICh0aGlzLml0ZW1zICYmIHRoaXMuX19saW1pdCA8IHRoaXMuaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuX19kZWJvdW5jZVJlbmRlcih0aGlzLl9fcmVxdWVzdFJlbmRlckNodW5rKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfX3JlcXVlc3RSZW5kZXJDaHVuaygpIHtcbiAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKT0+dGhpcy5fX3JlbmRlckNodW5rKCkpO1xuICAgIH1cblxuICAgIF9fcmVuZGVyQ2h1bmsoKSB7XG4gICAgICAvLyBTaW1wbGUgYXV0byBjaHVua1NpemUgdGhyb3R0bGluZyBhbGdvcml0aG0gYmFzZWQgb24gZmVlZGJhY2sgbG9vcDpcbiAgICAgIC8vIG1lYXN1cmUgYWN0dWFsIHRpbWUgYmV0d2VlbiBmcmFtZXMgYW5kIHNjYWxlIGNodW5rIGNvdW50IGJ5IHJhdGlvXG4gICAgICAvLyBvZiB0YXJnZXQvYWN0dWFsIGZyYW1lIHRpbWVcbiAgICAgIGxldCBjdXJyQ2h1bmtUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBsZXQgcmF0aW8gPSB0aGlzLl90YXJnZXRGcmFtZVRpbWUgLyAoY3VyckNodW5rVGltZSAtIHRoaXMuX19sYXN0Q2h1bmtUaW1lKTtcbiAgICAgIHRoaXMuX19jaHVua0NvdW50ID0gTWF0aC5yb3VuZCh0aGlzLl9fY2h1bmtDb3VudCAqIHJhdGlvKSB8fCAxO1xuICAgICAgdGhpcy5fX2xpbWl0ICs9IHRoaXMuX19jaHVua0NvdW50O1xuICAgICAgdGhpcy5fX2xhc3RDaHVua1RpbWUgPSBjdXJyQ2h1bmtUaW1lO1xuICAgICAgdGhpcy5fX2RlYm91bmNlUmVuZGVyKHRoaXMuX19yZW5kZXIpO1xuICAgIH1cblxuICAgIF9fb2JzZXJ2ZUNoYW5nZWQoKSB7XG4gICAgICB0aGlzLl9fb2JzZXJ2ZVBhdGhzID0gdGhpcy5vYnNlcnZlICYmXG4gICAgICAgIHRoaXMub2JzZXJ2ZS5yZXBsYWNlKCcuKicsICcuJykuc3BsaXQoJyAnKTtcbiAgICB9XG5cbiAgICBfX2l0ZW1zQ2hhbmdlZChjaGFuZ2UpIHtcbiAgICAgIGlmICh0aGlzLml0ZW1zICYmICFBcnJheS5pc0FycmF5KHRoaXMuaXRlbXMpKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignZG9tLXJlcGVhdCBleHBlY3RlZCBhcnJheSBmb3IgYGl0ZW1zYCwgZm91bmQnLCB0aGlzLml0ZW1zKTtcbiAgICAgIH1cbiAgICAgIC8vIElmIHBhdGggd2FzIHRvIGFuIGl0ZW0gKGUuZy4gJ2l0ZW1zLjMnIG9yICdpdGVtcy4zLmZvbycpLCBmb3J3YXJkIHRoZVxuICAgICAgLy8gcGF0aCB0byB0aGF0IGluc3RhbmNlIHN5bmNocm9ub3VzbHkgKHJldHVucyBmYWxzZSBmb3Igbm9uLWl0ZW0gcGF0aHMpXG4gICAgICBpZiAoIXRoaXMuX19oYW5kbGVJdGVtUGF0aChjaGFuZ2UucGF0aCwgY2hhbmdlLnZhbHVlKSkge1xuICAgICAgICAvLyBPdGhlcndpc2UsIHRoZSBhcnJheSB3YXMgcmVzZXQgKCdpdGVtcycpIG9yIHNwbGljZWQgKCdpdGVtcy5zcGxpY2VzJyksXG4gICAgICAgIC8vIHNvIHF1ZXVlIGEgZnVsbCByZWZyZXNoXG4gICAgICAgIHRoaXMuX19pbml0aWFsaXplQ2h1bmtpbmcoKTtcbiAgICAgICAgdGhpcy5fX2RlYm91bmNlUmVuZGVyKHRoaXMuX19yZW5kZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIF9faGFuZGxlT2JzZXJ2ZWRQYXRocyhwYXRoKSB7XG4gICAgICBpZiAodGhpcy5fX29ic2VydmVQYXRocykge1xuICAgICAgICBwYXRoID0gcGF0aC5zdWJzdHJpbmcocGF0aC5pbmRleE9mKCcuJykgKyAxKTtcbiAgICAgICAgbGV0IHBhdGhzID0gdGhpcy5fX29ic2VydmVQYXRocztcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPHBhdGhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKHBhdGguaW5kZXhPZihwYXRoc1tpXSkgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuX19kZWJvdW5jZVJlbmRlcih0aGlzLl9fcmVuZGVyLCB0aGlzLmRlbGF5KTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24odGhpczpEb21SZXBlYXQpfSBmbiBGdW5jdGlvbiB0byBkZWJvdW5jZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcj19IGRlbGF5IERlbGF5IGluIG1zIHRvIGRlYm91bmNlIGJ5LlxuICAgICAqL1xuICAgIF9fZGVib3VuY2VSZW5kZXIoZm4sIGRlbGF5ID0gMCkge1xuICAgICAgdGhpcy5fX3JlbmRlckRlYm91bmNlciA9IFBvbHltZXIuRGVib3VuY2VyLmRlYm91bmNlKFxuICAgICAgICAgICAgdGhpcy5fX3JlbmRlckRlYm91bmNlclxuICAgICAgICAgICwgZGVsYXkgPiAwID8gUG9seW1lci5Bc3luYy50aW1lT3V0LmFmdGVyKGRlbGF5KSA6IFBvbHltZXIuQXN5bmMubWljcm9UYXNrXG4gICAgICAgICAgLCBmbi5iaW5kKHRoaXMpKTtcbiAgICAgIFBvbHltZXIuZW5xdWV1ZURlYm91bmNlcih0aGlzLl9fcmVuZGVyRGVib3VuY2VyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGb3JjZXMgdGhlIGVsZW1lbnQgdG8gcmVuZGVyIGl0cyBjb250ZW50LiBOb3JtYWxseSByZW5kZXJpbmcgaXNcbiAgICAgKiBhc3luY2hyb25vdXMgdG8gYSBwcm92b2tpbmcgY2hhbmdlLiBUaGlzIGlzIGRvbmUgZm9yIGVmZmljaWVuY3kgc29cbiAgICAgKiB0aGF0IG11bHRpcGxlIGNoYW5nZXMgdHJpZ2dlciBvbmx5IGEgc2luZ2xlIHJlbmRlci4gVGhlIHJlbmRlciBtZXRob2RcbiAgICAgKiBzaG91bGQgYmUgY2FsbGVkIGlmLCBmb3IgZXhhbXBsZSwgdGVtcGxhdGUgcmVuZGVyaW5nIGlzIHJlcXVpcmVkIHRvXG4gICAgICogdmFsaWRhdGUgYXBwbGljYXRpb24gc3RhdGUuXG4gICAgICovXG4gICAgcmVuZGVyKCkge1xuICAgICAgLy8gUXVldWUgdGhpcyByZXBlYXRlciwgdGhlbiBmbHVzaCBhbGwgaW4gb3JkZXJcbiAgICAgIHRoaXMuX19kZWJvdW5jZVJlbmRlcih0aGlzLl9fcmVuZGVyKTtcbiAgICAgIFBvbHltZXIuZmx1c2goKTtcbiAgICB9XG5cbiAgICBfX3JlbmRlcigpIHtcbiAgICAgIGlmICghdGhpcy5fX2Vuc3VyZVRlbXBsYXRpemVkKCkpIHtcbiAgICAgICAgLy8gTm8gdGVtcGxhdGUgZm91bmQgeWV0XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX19hcHBseUZ1bGxSZWZyZXNoKCk7XG4gICAgICAvLyBSZXNldCB0aGUgcG9vbFxuICAgICAgLy8gVE9ETyhrc2NoYWFmKTogUmV1c2UgcG9vbCBhY3Jvc3MgdHVybnMgYW5kIG5lc3RlZCB0ZW1wbGF0ZXNcbiAgICAgIC8vIE5vdyB0aGF0IG9iamVjdHMvYXJyYXlzIGFyZSByZS1ldmFsdWF0ZWQgd2hlbiBzZXQsIHdlIGNhbiBzYWZlbHlcbiAgICAgIC8vIHJldXNlIHBvb2xlZCBpbnN0YW5jZXMgYWNyb3NzIHR1cm5zLCBob3dldmVyIHdlIHN0aWxsIG5lZWQgdG8gZGVjaWRlXG4gICAgICAvLyBzZW1hbnRpY3MgcmVnYXJkaW5nIGhvdyBsb25nIHRvIGhvbGQsIGhvdyBtYW55IHRvIGhvbGQsIGV0Yy5cbiAgICAgIHRoaXMuX19wb29sLmxlbmd0aCA9IDA7XG4gICAgICAvLyBTZXQgcmVuZGVyZWQgaXRlbSBjb3VudFxuICAgICAgdGhpcy5fc2V0UmVuZGVyZWRJdGVtQ291bnQodGhpcy5fX2luc3RhbmNlcy5sZW5ndGgpO1xuICAgICAgLy8gTm90aWZ5IHVzZXJzXG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KCdkb20tY2hhbmdlJywge1xuICAgICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgICBjb21wb3NlZDogdHJ1ZVxuICAgICAgfSkpO1xuICAgICAgLy8gQ2hlY2sgdG8gc2VlIGlmIHdlIG5lZWQgdG8gcmVuZGVyIG1vcmUgaXRlbXNcbiAgICAgIHRoaXMuX190cnlSZW5kZXJDaHVuaygpO1xuICAgIH1cblxuICAgIF9fYXBwbHlGdWxsUmVmcmVzaCgpIHtcbiAgICAgIGxldCBpdGVtcyA9IHRoaXMuaXRlbXMgfHwgW107XG4gICAgICBsZXQgaXNudElkeFRvSXRlbXNJZHggPSBuZXcgQXJyYXkoaXRlbXMubGVuZ3RoKTtcbiAgICAgIGZvciAobGV0IGk9MDsgaTxpdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpc250SWR4VG9JdGVtc0lkeFtpXSA9IGk7XG4gICAgICB9XG4gICAgICAvLyBBcHBseSB1c2VyIGZpbHRlclxuICAgICAgaWYgKHRoaXMuX19maWx0ZXJGbikge1xuICAgICAgICBpc250SWR4VG9JdGVtc0lkeCA9IGlzbnRJZHhUb0l0ZW1zSWR4LmZpbHRlcigoaSwgaWR4LCBhcnJheSkgPT5cbiAgICAgICAgICB0aGlzLl9fZmlsdGVyRm4oaXRlbXNbaV0sIGlkeCwgYXJyYXkpKTtcbiAgICAgIH1cbiAgICAgIC8vIEFwcGx5IHVzZXIgc29ydFxuICAgICAgaWYgKHRoaXMuX19zb3J0Rm4pIHtcbiAgICAgICAgaXNudElkeFRvSXRlbXNJZHguc29ydCgoYSwgYikgPT4gdGhpcy5fX3NvcnRGbihpdGVtc1thXSwgaXRlbXNbYl0pKTtcbiAgICAgIH1cbiAgICAgIC8vIGl0ZW1zLT5pbnN0IG1hcCBrZXB0IGZvciBpdGVtIHBhdGggZm9yd2FyZGluZ1xuICAgICAgY29uc3QgaXRlbXNJZHhUb0luc3RJZHggPSB0aGlzLl9faXRlbXNJZHhUb0luc3RJZHggPSB7fTtcbiAgICAgIGxldCBpbnN0SWR4ID0gMDtcbiAgICAgIC8vIEdlbmVyYXRlIGluc3RhbmNlcyBhbmQgYXNzaWduIGl0ZW1zXG4gICAgICBjb25zdCBsaW1pdCA9IE1hdGgubWluKGlzbnRJZHhUb0l0ZW1zSWR4Lmxlbmd0aCwgdGhpcy5fX2xpbWl0KTtcbiAgICAgIGZvciAoOyBpbnN0SWR4PGxpbWl0OyBpbnN0SWR4KyspIHtcbiAgICAgICAgbGV0IGluc3QgPSB0aGlzLl9faW5zdGFuY2VzW2luc3RJZHhdO1xuICAgICAgICBsZXQgaXRlbUlkeCA9IGlzbnRJZHhUb0l0ZW1zSWR4W2luc3RJZHhdO1xuICAgICAgICBsZXQgaXRlbSA9IGl0ZW1zW2l0ZW1JZHhdO1xuICAgICAgICBpdGVtc0lkeFRvSW5zdElkeFtpdGVtSWR4XSA9IGluc3RJZHg7XG4gICAgICAgIGlmIChpbnN0ICYmIGluc3RJZHggPCB0aGlzLl9fbGltaXQpIHtcbiAgICAgICAgICBpbnN0Ll9zZXRQZW5kaW5nUHJvcGVydHkodGhpcy5hcywgaXRlbSk7XG4gICAgICAgICAgaW5zdC5fc2V0UGVuZGluZ1Byb3BlcnR5KHRoaXMuaW5kZXhBcywgaW5zdElkeCk7XG4gICAgICAgICAgaW5zdC5fc2V0UGVuZGluZ1Byb3BlcnR5KHRoaXMuaXRlbXNJbmRleEFzLCBpdGVtSWR4KTtcbiAgICAgICAgICBpbnN0Ll9mbHVzaFByb3BlcnRpZXMoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9faW5zZXJ0SW5zdGFuY2UoaXRlbSwgaW5zdElkeCwgaXRlbUlkeCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIFJlbW92ZSBhbnkgZXh0cmEgaW5zdGFuY2VzIGZyb20gcHJldmlvdXMgc3RhdGVcbiAgICAgIGZvciAobGV0IGk9dGhpcy5fX2luc3RhbmNlcy5sZW5ndGgtMTsgaT49aW5zdElkeDsgaS0tKSB7XG4gICAgICAgIHRoaXMuX19kZXRhY2hBbmRSZW1vdmVJbnN0YW5jZShpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfX2RldGFjaEluc3RhbmNlKGlkeCkge1xuICAgICAgbGV0IGluc3QgPSB0aGlzLl9faW5zdGFuY2VzW2lkeF07XG4gICAgICBmb3IgKGxldCBpPTA7IGk8aW5zdC5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgZWwgPSBpbnN0LmNoaWxkcmVuW2ldO1xuICAgICAgICBpbnN0LnJvb3QuYXBwZW5kQ2hpbGQoZWwpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGluc3Q7XG4gICAgfVxuXG4gICAgX19hdHRhY2hJbnN0YW5jZShpZHgsIHBhcmVudCkge1xuICAgICAgbGV0IGluc3QgPSB0aGlzLl9faW5zdGFuY2VzW2lkeF07XG4gICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKGluc3Qucm9vdCwgdGhpcyk7XG4gICAgfVxuXG4gICAgX19kZXRhY2hBbmRSZW1vdmVJbnN0YW5jZShpZHgpIHtcbiAgICAgIGxldCBpbnN0ID0gdGhpcy5fX2RldGFjaEluc3RhbmNlKGlkeCk7XG4gICAgICBpZiAoaW5zdCkge1xuICAgICAgICB0aGlzLl9fcG9vbC5wdXNoKGluc3QpO1xuICAgICAgfVxuICAgICAgdGhpcy5fX2luc3RhbmNlcy5zcGxpY2UoaWR4LCAxKTtcbiAgICB9XG5cbiAgICBfX3N0YW1wSW5zdGFuY2UoaXRlbSwgaW5zdElkeCwgaXRlbUlkeCkge1xuICAgICAgbGV0IG1vZGVsID0ge307XG4gICAgICBtb2RlbFt0aGlzLmFzXSA9IGl0ZW07XG4gICAgICBtb2RlbFt0aGlzLmluZGV4QXNdID0gaW5zdElkeDtcbiAgICAgIG1vZGVsW3RoaXMuaXRlbXNJbmRleEFzXSA9IGl0ZW1JZHg7XG4gICAgICByZXR1cm4gbmV3IHRoaXMuX19jdG9yKG1vZGVsKTtcbiAgICB9XG5cbiAgICBfX2luc2VydEluc3RhbmNlKGl0ZW0sIGluc3RJZHgsIGl0ZW1JZHgpIHtcbiAgICAgIGxldCBpbnN0ID0gdGhpcy5fX3Bvb2wucG9wKCk7XG4gICAgICBpZiAoaW5zdCkge1xuICAgICAgICAvLyBUT0RPKGtzY2hhYWYpOiBJZiB0aGUgcG9vbCBpcyBzaGFyZWQgYWNyb3NzIHR1cm5zLCBob3N0UHJvcHNcbiAgICAgICAgLy8gbmVlZCB0byBiZSByZS1zZXQgdG8gcmV1c2VkIGluc3RhbmNlcyBpbiBhZGRpdGlvbiB0byBpdGVtXG4gICAgICAgIGluc3QuX3NldFBlbmRpbmdQcm9wZXJ0eSh0aGlzLmFzLCBpdGVtKTtcbiAgICAgICAgaW5zdC5fc2V0UGVuZGluZ1Byb3BlcnR5KHRoaXMuaW5kZXhBcywgaW5zdElkeCk7XG4gICAgICAgIGluc3QuX3NldFBlbmRpbmdQcm9wZXJ0eSh0aGlzLml0ZW1zSW5kZXhBcywgaXRlbUlkeCk7XG4gICAgICAgIGluc3QuX2ZsdXNoUHJvcGVydGllcygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5zdCA9IHRoaXMuX19zdGFtcEluc3RhbmNlKGl0ZW0sIGluc3RJZHgsIGl0ZW1JZHgpO1xuICAgICAgfVxuICAgICAgbGV0IGJlZm9yZVJvdyA9IHRoaXMuX19pbnN0YW5jZXNbaW5zdElkeCArIDFdO1xuICAgICAgbGV0IGJlZm9yZU5vZGUgPSBiZWZvcmVSb3cgPyBiZWZvcmVSb3cuY2hpbGRyZW5bMF0gOiB0aGlzO1xuICAgICAgdGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZShpbnN0LnJvb3QsIGJlZm9yZU5vZGUpO1xuICAgICAgdGhpcy5fX2luc3RhbmNlc1tpbnN0SWR4XSA9IGluc3Q7XG4gICAgICByZXR1cm4gaW5zdDtcbiAgICB9XG5cbiAgICAvLyBJbXBsZW1lbnRzIGV4dGVuc2lvbiBwb2ludCBmcm9tIFRlbXBsYXRpemUgbWl4aW5cbiAgICBfc2hvd0hpZGVDaGlsZHJlbihoaWRkZW4pIHtcbiAgICAgIGZvciAobGV0IGk9MDsgaTx0aGlzLl9faW5zdGFuY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuX19pbnN0YW5jZXNbaV0uX3Nob3dIaWRlQ2hpbGRyZW4oaGlkZGVuKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDYWxsZWQgYXMgYSBzaWRlIGVmZmVjdCBvZiBhIGhvc3QgaXRlbXMuPGtleT4uPHBhdGg+IHBhdGggY2hhbmdlLFxuICAgIC8vIHJlc3BvbnNpYmxlIGZvciBub3RpZnlpbmcgaXRlbS48cGF0aD4gY2hhbmdlcyB0byBpbnN0IGZvciBrZXlcbiAgICBfX2hhbmRsZUl0ZW1QYXRoKHBhdGgsIHZhbHVlKSB7XG4gICAgICBsZXQgaXRlbXNQYXRoID0gcGF0aC5zbGljZSg2KTsgLy8gJ2l0ZW1zLicubGVuZ3RoID09IDZcbiAgICAgIGxldCBkb3QgPSBpdGVtc1BhdGguaW5kZXhPZignLicpO1xuICAgICAgbGV0IGl0ZW1zSWR4ID0gZG90IDwgMCA/IGl0ZW1zUGF0aCA6IGl0ZW1zUGF0aC5zdWJzdHJpbmcoMCwgZG90KTtcbiAgICAgIC8vIElmIHBhdGggd2FzIGluZGV4IGludG8gYXJyYXkuLi5cbiAgICAgIGlmIChpdGVtc0lkeCA9PSBwYXJzZUludChpdGVtc0lkeCwgMTApKSB7XG4gICAgICAgIGxldCBpdGVtU3ViUGF0aCA9IGRvdCA8IDAgPyAnJyA6IGl0ZW1zUGF0aC5zdWJzdHJpbmcoZG90KzEpO1xuICAgICAgICAvLyBJZiB0aGUgcGF0aCBpcyBvYnNlcnZlZCwgaXQgd2lsbCB0cmlnZ2VyIGEgZnVsbCByZWZyZXNoXG4gICAgICAgIHRoaXMuX19oYW5kbGVPYnNlcnZlZFBhdGhzKGl0ZW1TdWJQYXRoKTtcbiAgICAgICAgLy8gTm90ZSwgZXZlbiBpZiBhIHJ1bGwgcmVmcmVzaCBpcyB0cmlnZ2VyZWQsIGFsd2F5cyBkbyB0aGUgcGF0aFxuICAgICAgICAvLyBub3RpZmljYXRpb24gYmVjYXVzZSB1bmxlc3MgbXV0YWJsZURhdGEgaXMgdXNlZCBmb3IgZG9tLXJlcGVhdFxuICAgICAgICAvLyBhbmQgYWxsIGVsZW1lbnRzIGluIHRoZSBpbnN0YW5jZSBzdWJ0cmVlLCBhIGZ1bGwgcmVmcmVzaCBtYXlcbiAgICAgICAgLy8gbm90IHRyaWdnZXIgdGhlIHByb3BlciB1cGRhdGUuXG4gICAgICAgIGxldCBpbnN0SWR4ID0gdGhpcy5fX2l0ZW1zSWR4VG9JbnN0SWR4W2l0ZW1zSWR4XTtcbiAgICAgICAgbGV0IGluc3QgPSB0aGlzLl9faW5zdGFuY2VzW2luc3RJZHhdO1xuICAgICAgICBpZiAoaW5zdCkge1xuICAgICAgICAgIGxldCBpdGVtUGF0aCA9IHRoaXMuYXMgKyAoaXRlbVN1YlBhdGggPyAnLicgKyBpdGVtU3ViUGF0aCA6ICcnKTtcbiAgICAgICAgICAvLyBUaGlzIGlzIGVmZmVjdGl2ZWx5IGBub3RpZnlQYXRoYCwgYnV0IGF2b2lkcyBzb21lIG9mIHRoZSBvdmVyaGVhZFxuICAgICAgICAgIC8vIG9mIHRoZSBwdWJsaWMgQVBJXG4gICAgICAgICAgaW5zdC5fc2V0UGVuZGluZ1Byb3BlcnR5T3JQYXRoKGl0ZW1QYXRoLCB2YWx1ZSwgZmFsc2UsIHRydWUpO1xuICAgICAgICAgIGluc3QuX2ZsdXNoUHJvcGVydGllcygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGl0ZW0gYXNzb2NpYXRlZCB3aXRoIGEgZ2l2ZW4gZWxlbWVudCBzdGFtcGVkIGJ5XG4gICAgICogdGhpcyBgZG9tLXJlcGVhdGAuXG4gICAgICpcbiAgICAgKiBOb3RlLCB0byBtb2RpZnkgc3ViLXByb3BlcnRpZXMgb2YgdGhlIGl0ZW0sXG4gICAgICogYG1vZGVsRm9yRWxlbWVudChlbCkuc2V0KCdpdGVtLjxzdWItcHJvcD4nLCB2YWx1ZSlgXG4gICAgICogc2hvdWxkIGJlIHVzZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCBFbGVtZW50IGZvciB3aGljaCB0byByZXR1cm4gdGhlIGl0ZW0uXG4gICAgICogQHJldHVybiB7Kn0gSXRlbSBhc3NvY2lhdGVkIHdpdGggdGhlIGVsZW1lbnQuXG4gICAgICovXG4gICAgaXRlbUZvckVsZW1lbnQoZWwpIHtcbiAgICAgIGxldCBpbnN0YW5jZSA9IHRoaXMubW9kZWxGb3JFbGVtZW50KGVsKTtcbiAgICAgIHJldHVybiBpbnN0YW5jZSAmJiBpbnN0YW5jZVt0aGlzLmFzXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBpbnN0IGluZGV4IGZvciBhIGdpdmVuIGVsZW1lbnQgc3RhbXBlZCBieSB0aGlzIGBkb20tcmVwZWF0YC5cbiAgICAgKiBJZiBgc29ydGAgaXMgcHJvdmlkZWQsIHRoZSBpbmRleCB3aWxsIHJlZmxlY3QgdGhlIHNvcnRlZCBvcmRlciAocmF0aGVyXG4gICAgICogdGhhbiB0aGUgb3JpZ2luYWwgYXJyYXkgb3JkZXIpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgRWxlbWVudCBmb3Igd2hpY2ggdG8gcmV0dXJuIHRoZSBpbmRleC5cbiAgICAgKiBAcmV0dXJuIHsqfSBSb3cgaW5kZXggYXNzb2NpYXRlZCB3aXRoIHRoZSBlbGVtZW50IChub3RlIHRoaXMgbWF5XG4gICAgICogICBub3QgY29ycmVzcG9uZCB0byB0aGUgYXJyYXkgaW5kZXggaWYgYSB1c2VyIGBzb3J0YCBpcyBhcHBsaWVkKS5cbiAgICAgKi9cbiAgICBpbmRleEZvckVsZW1lbnQoZWwpIHtcbiAgICAgIGxldCBpbnN0YW5jZSA9IHRoaXMubW9kZWxGb3JFbGVtZW50KGVsKTtcbiAgICAgIHJldHVybiBpbnN0YW5jZSAmJiBpbnN0YW5jZVt0aGlzLmluZGV4QXNdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHRlbXBsYXRlIFwibW9kZWxcIiBhc3NvY2lhdGVkIHdpdGggYSBnaXZlbiBlbGVtZW50LCB3aGljaFxuICAgICAqIHNlcnZlcyBhcyB0aGUgYmluZGluZyBzY29wZSBmb3IgdGhlIHRlbXBsYXRlIGluc3RhbmNlIHRoZSBlbGVtZW50IGlzXG4gICAgICogY29udGFpbmVkIGluLiBBIHRlbXBsYXRlIG1vZGVsIGlzIGFuIGluc3RhbmNlIG9mIGBQb2x5bWVyLkJhc2VgLCBhbmRcbiAgICAgKiBzaG91bGQgYmUgdXNlZCB0byBtYW5pcHVsYXRlIGRhdGEgYXNzb2NpYXRlZCB3aXRoIHRoaXMgdGVtcGxhdGUgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBFeGFtcGxlOlxuICAgICAqXG4gICAgICogICBsZXQgbW9kZWwgPSBtb2RlbEZvckVsZW1lbnQoZWwpO1xuICAgICAqICAgaWYgKG1vZGVsLmluZGV4IDwgMTApIHtcbiAgICAgKiAgICAgbW9kZWwuc2V0KCdpdGVtLmNoZWNrZWQnLCB0cnVlKTtcbiAgICAgKiAgIH1cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIEVsZW1lbnQgZm9yIHdoaWNoIHRvIHJldHVybiBhIHRlbXBsYXRlIG1vZGVsLlxuICAgICAqIEByZXR1cm4ge1RlbXBsYXRlSW5zdGFuY2VCYXNlfSBNb2RlbCByZXByZXNlbnRpbmcgdGhlIGJpbmRpbmcgc2NvcGUgZm9yXG4gICAgICogICB0aGUgZWxlbWVudC5cbiAgICAgKi9cbiAgICBtb2RlbEZvckVsZW1lbnQoZWwpIHtcbiAgICAgIHJldHVybiBQb2x5bWVyLlRlbXBsYXRpemUubW9kZWxGb3JFbGVtZW50KHRoaXMudGVtcGxhdGUsIGVsKTtcbiAgICB9XG5cbiAgfVxuXG4gIGN1c3RvbUVsZW1lbnRzLmRlZmluZShEb21SZXBlYXQuaXMsIERvbVJlcGVhdCk7XG5cbiAgUG9seW1lci5Eb21SZXBlYXQgPSBEb21SZXBlYXQ7XG5cbn0pKCk7XG5cbjwvc2NyaXB0PlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi9lbGVtZW50cy9kb20tcmVwZWF0Lmh0bWwiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi8uLi9wb2x5bWVyLWVsZW1lbnQuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3V0aWxzL3RlbXBsYXRpemUuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3V0aWxzL2RlYm91bmNlLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi91dGlscy9mbHVzaC5odG1sXCI+XG5cbjxzY3JpcHQ+XG5cbihmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8qKlxuICAgKiBUaGUgYDxkb20taWY+YCBlbGVtZW50IHdpbGwgc3RhbXAgYSBsaWdodC1kb20gYDx0ZW1wbGF0ZT5gIGNoaWxkIHdoZW5cbiAgICogdGhlIGBpZmAgcHJvcGVydHkgYmVjb21lcyB0cnV0aHksIGFuZCB0aGUgdGVtcGxhdGUgY2FuIHVzZSBQb2x5bWVyXG4gICAqIGRhdGEtYmluZGluZyBhbmQgZGVjbGFyYXRpdmUgZXZlbnQgZmVhdHVyZXMgd2hlbiB1c2VkIGluIHRoZSBjb250ZXh0IG9mXG4gICAqIGEgUG9seW1lciBlbGVtZW50J3MgdGVtcGxhdGUuXG4gICAqXG4gICAqIFdoZW4gYGlmYCBiZWNvbWVzIGZhbHNleSwgdGhlIHN0YW1wZWQgY29udGVudCBpcyBoaWRkZW4gYnV0IG5vdFxuICAgKiByZW1vdmVkIGZyb20gZG9tLiBXaGVuIGBpZmAgc3Vic2VxdWVudGx5IGJlY29tZXMgdHJ1dGh5IGFnYWluLCB0aGUgY29udGVudFxuICAgKiBpcyBzaW1wbHkgcmUtc2hvd24uIFRoaXMgYXBwcm9hY2ggaXMgdXNlZCBkdWUgdG8gaXRzIGZhdm9yYWJsZSBwZXJmb3JtYW5jZVxuICAgKiBjaGFyYWN0ZXJpc3RpY3M6IHRoZSBleHBlbnNlIG9mIGNyZWF0aW5nIHRlbXBsYXRlIGNvbnRlbnQgaXMgcGFpZCBvbmx5XG4gICAqIG9uY2UgYW5kIGxhemlseS5cbiAgICpcbiAgICogU2V0IHRoZSBgcmVzdGFtcGAgcHJvcGVydHkgdG8gdHJ1ZSB0byBmb3JjZSB0aGUgc3RhbXBlZCBjb250ZW50IHRvIGJlXG4gICAqIGNyZWF0ZWQgLyBkZXN0cm95ZWQgd2hlbiB0aGUgYGlmYCBjb25kaXRpb24gY2hhbmdlcy5cbiAgICpcbiAgICogQGN1c3RvbUVsZW1lbnRcbiAgICogQHBvbHltZXJcbiAgICogQGV4dGVuZHMgUG9seW1lci5FbGVtZW50XG4gICAqIEBtZW1iZXJvZiBQb2x5bWVyXG4gICAqIEBzdW1tYXJ5IEN1c3RvbSBlbGVtZW50IHRoYXQgY29uZGl0aW9uYWxseSBzdGFtcHMgYW5kIGhpZGVzIG9yIHJlbW92ZXNcbiAgICogICB0ZW1wbGF0ZSBjb250ZW50IGJhc2VkIG9uIGEgYm9vbGVhbiBmbGFnLlxuICAgKi9cbiAgY2xhc3MgRG9tSWYgZXh0ZW5kcyBQb2x5bWVyLkVsZW1lbnQge1xuXG4gICAgLy8gTm90IG5lZWRlZCB0byBmaW5kIHRlbXBsYXRlOyBjYW4gYmUgcmVtb3ZlZCBvbmNlIHRoZSBhbmFseXplclxuICAgIC8vIGNhbiBmaW5kIHRoZSB0YWcgbmFtZSBmcm9tIGN1c3RvbUVsZW1lbnRzLmRlZmluZSBjYWxsXG4gICAgc3RhdGljIGdldCBpcygpIHsgcmV0dXJuICdkb20taWYnOyB9XG5cbiAgICBzdGF0aWMgZ2V0IHRlbXBsYXRlKCkgeyByZXR1cm4gbnVsbDsgfVxuXG4gICAgc3RhdGljIGdldCBwcm9wZXJ0aWVzKCkge1xuXG4gICAgICByZXR1cm4ge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlZCB3aGVuZXZlciBET00gaXMgYWRkZWQgb3IgcmVtb3ZlZC9oaWRkZW4gYnkgdGhpcyB0ZW1wbGF0ZSAoYnlcbiAgICAgICAgICogZGVmYXVsdCwgcmVuZGVyaW5nIG9jY3VycyBsYXppbHkpLiAgVG8gZm9yY2UgaW1tZWRpYXRlIHJlbmRlcmluZywgY2FsbFxuICAgICAgICAgKiBgcmVuZGVyYC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV2ZW50IGRvbS1jaGFuZ2VcbiAgICAgICAgICovXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhpcyB0ZW1wbGF0ZSBzaG91bGQgc3RhbXAuXG4gICAgICAgICAqL1xuICAgICAgICBpZjoge1xuICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgICAgb2JzZXJ2ZXI6ICdfX2RlYm91bmNlUmVuZGVyJ1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGVuIHRydWUsIGVsZW1lbnRzIHdpbGwgYmUgcmVtb3ZlZCBmcm9tIERPTSBhbmQgZGlzY2FyZGVkIHdoZW4gYGlmYFxuICAgICAgICAgKiBiZWNvbWVzIGZhbHNlIGFuZCByZS1jcmVhdGVkIGFuZCBhZGRlZCBiYWNrIHRvIHRoZSBET00gd2hlbiBgaWZgXG4gICAgICAgICAqIGJlY29tZXMgdHJ1ZS4gIEJ5IGRlZmF1bHQsIHN0YW1wZWQgZWxlbWVudHMgd2lsbCBiZSBoaWRkZW4gYnV0IGxlZnRcbiAgICAgICAgICogaW4gdGhlIERPTSB3aGVuIGBpZmAgYmVjb21lcyBmYWxzZSwgd2hpY2ggaXMgZ2VuZXJhbGx5IHJlc3VsdHNcbiAgICAgICAgICogaW4gYmV0dGVyIHBlcmZvcm1hbmNlLlxuICAgICAgICAgKi9cbiAgICAgICAgcmVzdGFtcDoge1xuICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgICAgb2JzZXJ2ZXI6ICdfX2RlYm91bmNlUmVuZGVyJ1xuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgc3VwZXIoKTtcbiAgICAgIHRoaXMuX19yZW5kZXJEZWJvdW5jZXIgPSBudWxsO1xuICAgICAgdGhpcy5fX2ludmFsaWRQcm9wcyA9IG51bGw7XG4gICAgICB0aGlzLl9faW5zdGFuY2UgPSBudWxsO1xuICAgICAgdGhpcy5fbGFzdElmID0gZmFsc2U7XG4gICAgICB0aGlzLl9fY3RvciA9IG51bGw7XG4gICAgfVxuXG4gICAgX19kZWJvdW5jZVJlbmRlcigpIHtcbiAgICAgIC8vIFJlbmRlciBpcyBhc3luYyBmb3IgMiByZWFzb25zOlxuICAgICAgLy8gMS4gVG8gZWxpbWluYXRlIGRvbSBjcmVhdGlvbiB0cmFzaGluZyBpZiB1c2VyIGNvZGUgdGhyYXNoZXMgYGlmYCBpbiB0aGVcbiAgICAgIC8vICAgIHNhbWUgdHVybi4gVGhpcyB3YXMgbW9yZSBjb21tb24gaW4gMS54IHdoZXJlIGEgY29tcG91bmQgY29tcHV0ZWRcbiAgICAgIC8vICAgIHByb3BlcnR5IGNvdWxkIHJlc3VsdCBpbiB0aGUgcmVzdWx0IGNoYW5naW5nIG11bHRpcGxlIHRpbWVzLCBidXQgaXNcbiAgICAgIC8vICAgIG1pdGlnYXRlZCB0byBhIGxhcmdlIGV4dGVudCBieSBiYXRjaGVkIHByb3BlcnR5IHByb2Nlc3NpbmcgaW4gMi54LlxuICAgICAgLy8gMi4gVG8gYXZvaWQgZG91YmxlIG9iamVjdCBwcm9wYWdhdGlvbiB3aGVuIGEgYmFnIGluY2x1ZGluZyB2YWx1ZXMgYm91bmRcbiAgICAgIC8vICAgIHRvIHRoZSBgaWZgIHByb3BlcnR5IGFzIHdlbGwgYXMgb25lIG9yIG1vcmUgaG9zdFByb3BzIGNvdWxkIGVucXVldWVcbiAgICAgIC8vICAgIHRoZSA8ZG9tLWlmPiB0byBmbHVzaCBiZWZvcmUgdGhlIDx0ZW1wbGF0ZT4ncyBob3N0IHByb3BlcnR5XG4gICAgICAvLyAgICBmb3J3YXJkaW5nLiBJbiB0aGF0IHNjZW5hcmlvIGNyZWF0aW5nIGFuIGluc3RhbmNlIHdvdWxkIHJlc3VsdCBpblxuICAgICAgLy8gICAgdGhlIGhvc3QgcHJvcHMgYmVpbmcgc2V0IG9uY2UsIGFuZCB0aGVuIHRoZSBlbnF1ZXVlZCBjaGFuZ2VzIG9uIHRoZVxuICAgICAgLy8gICAgdGVtcGxhdGUgd291bGQgc2V0IHByb3BlcnRpZXMgYSBzZWNvbmQgdGltZSwgcG90ZW50aWFsbHkgY2F1c2luZyBhblxuICAgICAgLy8gICAgb2JqZWN0IHRvIGJlIHNldCB0byBhbiBpbnN0YW5jZSBtb3JlIHRoYW4gb25jZS4gIENyZWF0aW5nIHRoZVxuICAgICAgLy8gICAgaW5zdGFuY2UgYXN5bmMgZnJvbSBmbHVzaGluZyBkYXRhIGVuc3VyZXMgdGhpcyBkb2Vzbid0IGhhcHBlbi4gSWZcbiAgICAgIC8vICAgIHdlIHdhbnRlZCBhIHN5bmMgb3B0aW9uIGluIHRoZSBmdXR1cmUsIHNpbXBseSBoYXZpbmcgPGRvbS1pZj4gZmx1c2hcbiAgICAgIC8vICAgIChvciBjbGVhcikgaXRzIHRlbXBsYXRlJ3MgcGVuZGluZyBob3N0IHByb3BlcnRpZXMgYmVmb3JlIGNyZWF0aW5nXG4gICAgICAvLyAgICB0aGUgaW5zdGFuY2Ugd291bGQgYWxzbyBhdm9pZCB0aGUgcHJvYmxlbS5cbiAgICAgIHRoaXMuX19yZW5kZXJEZWJvdW5jZXIgPSBQb2x5bWVyLkRlYm91bmNlci5kZWJvdW5jZShcbiAgICAgICAgICAgIHRoaXMuX19yZW5kZXJEZWJvdW5jZXJcbiAgICAgICAgICAsIFBvbHltZXIuQXN5bmMubWljcm9UYXNrXG4gICAgICAgICAgLCAoKSA9PiB0aGlzLl9fcmVuZGVyKCkpO1xuICAgICAgUG9seW1lci5lbnF1ZXVlRGVib3VuY2VyKHRoaXMuX19yZW5kZXJEZWJvdW5jZXIpO1xuICAgIH1cblxuICAgIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgICAgc3VwZXIuZGlzY29ubmVjdGVkQ2FsbGJhY2soKTtcbiAgICAgIGlmICghdGhpcy5wYXJlbnROb2RlIHx8XG4gICAgICAgICAgKHRoaXMucGFyZW50Tm9kZS5ub2RlVHlwZSA9PSBOb2RlLkRPQ1VNRU5UX0ZSQUdNRU5UX05PREUgJiZcbiAgICAgICAgICAgIXRoaXMucGFyZW50Tm9kZS5ob3N0KSkge1xuICAgICAgICB0aGlzLl9fdGVhcmRvd25JbnN0YW5jZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgICAgc3VwZXIuY29ubmVjdGVkQ2FsbGJhY2soKTtcbiAgICAgIGlmICh0aGlzLmlmKSB7XG4gICAgICAgIHRoaXMuX19kZWJvdW5jZVJlbmRlcigpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZvcmNlcyB0aGUgZWxlbWVudCB0byByZW5kZXIgaXRzIGNvbnRlbnQuIE5vcm1hbGx5IHJlbmRlcmluZyBpc1xuICAgICAqIGFzeW5jaHJvbm91cyB0byBhIHByb3Zva2luZyBjaGFuZ2UuIFRoaXMgaXMgZG9uZSBmb3IgZWZmaWNpZW5jeSBzb1xuICAgICAqIHRoYXQgbXVsdGlwbGUgY2hhbmdlcyB0cmlnZ2VyIG9ubHkgYSBzaW5nbGUgcmVuZGVyLiBUaGUgcmVuZGVyIG1ldGhvZFxuICAgICAqIHNob3VsZCBiZSBjYWxsZWQgaWYsIGZvciBleGFtcGxlLCB0ZW1wbGF0ZSByZW5kZXJpbmcgaXMgcmVxdWlyZWQgdG9cbiAgICAgKiB2YWxpZGF0ZSBhcHBsaWNhdGlvbiBzdGF0ZS5cbiAgICAgKi9cbiAgICByZW5kZXIoKSB7XG4gICAgICBQb2x5bWVyLmZsdXNoKCk7XG4gICAgfVxuXG4gICAgX19yZW5kZXIoKSB7XG4gICAgICBpZiAodGhpcy5pZikge1xuICAgICAgICBpZiAoIXRoaXMuX19lbnN1cmVJbnN0YW5jZSgpKSB7XG4gICAgICAgICAgLy8gTm8gdGVtcGxhdGUgZm91bmQgeWV0XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3Nob3dIaWRlQ2hpbGRyZW4oKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5yZXN0YW1wKSB7XG4gICAgICAgIHRoaXMuX190ZWFyZG93bkluc3RhbmNlKCk7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMucmVzdGFtcCAmJiB0aGlzLl9faW5zdGFuY2UpIHtcbiAgICAgICAgdGhpcy5fc2hvd0hpZGVDaGlsZHJlbigpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuaWYgIT0gdGhpcy5fbGFzdElmKSB7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ2RvbS1jaGFuZ2UnLCB7XG4gICAgICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgICAgICBjb21wb3NlZDogdHJ1ZVxuICAgICAgICB9KSk7XG4gICAgICAgIHRoaXMuX2xhc3RJZiA9IHRoaXMuaWY7XG4gICAgICB9XG4gICAgfVxuXG4gICAgX19lbnN1cmVJbnN0YW5jZSgpIHtcbiAgICAgIGxldCBwYXJlbnROb2RlID0gdGhpcy5wYXJlbnROb2RlO1xuICAgICAgLy8gR3VhcmQgYWdhaW5zdCBlbGVtZW50IGJlaW5nIGRldGFjaGVkIHdoaWxlIHJlbmRlciB3YXMgcXVldWVkXG4gICAgICBpZiAocGFyZW50Tm9kZSkge1xuICAgICAgICBpZiAoIXRoaXMuX19jdG9yKSB7XG4gICAgICAgICAgbGV0IHRlbXBsYXRlID0gdGhpcy5xdWVyeVNlbGVjdG9yKCd0ZW1wbGF0ZScpO1xuICAgICAgICAgIGlmICghdGVtcGxhdGUpIHtcbiAgICAgICAgICAgIC8vIFdhaXQgdW50aWwgY2hpbGRMaXN0IGNoYW5nZXMgYW5kIHRlbXBsYXRlIHNob3VsZCBiZSB0aGVyZSBieSB0aGVuXG4gICAgICAgICAgICBsZXQgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcigoKSA9PiB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLnF1ZXJ5U2VsZWN0b3IoJ3RlbXBsYXRlJykpIHtcbiAgICAgICAgICAgICAgICBvYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fX3JlbmRlcigpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZG9tLWlmIHJlcXVpcmVzIGEgPHRlbXBsYXRlPiBjaGlsZCcpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgb2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLCB7Y2hpbGRMaXN0OiB0cnVlfSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX19jdG9yID0gUG9seW1lci5UZW1wbGF0aXplLnRlbXBsYXRpemUodGVtcGxhdGUsIHRoaXMsIHtcbiAgICAgICAgICAgIC8vIGRvbS1pZiB0ZW1wbGF0aXplciBpbnN0YW5jZXMgcmVxdWlyZSBgbXV0YWJsZTogdHJ1ZWAsIGFzXG4gICAgICAgICAgICAvLyBgX19zeW5jSG9zdFByb3BlcnRpZXNgIHJlbGllcyBvbiB0aGF0IGJlaGF2aW9yIHRvIHN5bmMgb2JqZWN0c1xuICAgICAgICAgICAgbXV0YWJsZURhdGE6IHRydWUsXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wIFByb3BlcnR5IHRvIGZvcndhcmRcbiAgICAgICAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgb2YgcHJvcGVydHlcbiAgICAgICAgICAgICAqIEB0aGlzIHt0aGlzfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmb3J3YXJkSG9zdFByb3A6IGZ1bmN0aW9uKHByb3AsIHZhbHVlKSB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLl9faW5zdGFuY2UpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pZikge1xuICAgICAgICAgICAgICAgICAgdGhpcy5fX2luc3RhbmNlLmZvcndhcmRIb3N0UHJvcChwcm9wLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgYW4gaW5zdGFuY2UgYnV0IGFyZSBzcXVlbGNoaW5nIGhvc3QgcHJvcGVydHlcbiAgICAgICAgICAgICAgICAgIC8vIGZvcndhcmRpbmcgZHVlIHRvIGlmIGJlaW5nIGZhbHNlLCBub3RlIHRoZSBpbnZhbGlkYXRlZFxuICAgICAgICAgICAgICAgICAgLy8gcHJvcGVydGllcyBzbyBgX19zeW5jSG9zdFByb3BlcnRpZXNgIGNhbiBzeW5jIHRoZW0gdGhlIG5leHRcbiAgICAgICAgICAgICAgICAgIC8vIHRpbWUgYGlmYCBiZWNvbWVzIHRydWVcbiAgICAgICAgICAgICAgICAgIHRoaXMuX19pbnZhbGlkUHJvcHMgPSB0aGlzLl9faW52YWxpZFByb3BzIHx8IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9faW52YWxpZFByb3BzW1BvbHltZXIuUGF0aC5yb290KHByb3ApXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9faW5zdGFuY2UpIHtcbiAgICAgICAgICB0aGlzLl9faW5zdGFuY2UgPSBuZXcgdGhpcy5fX2N0b3IoKTtcbiAgICAgICAgICBwYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzLl9faW5zdGFuY2Uucm9vdCwgdGhpcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fX3N5bmNIb3N0UHJvcGVydGllcygpO1xuICAgICAgICAgIGxldCBjJCA9IHRoaXMuX19pbnN0YW5jZS5jaGlsZHJlbjtcbiAgICAgICAgICBpZiAoYyQgJiYgYyQubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBEZXRlY3QgY2FzZSB3aGVyZSBkb20taWYgd2FzIHJlLWF0dGFjaGVkIGluIG5ldyBwb3NpdGlvblxuICAgICAgICAgICAgbGV0IGxhc3RDaGlsZCA9IHRoaXMucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICAgICAgaWYgKGxhc3RDaGlsZCAhPT0gYyRbYyQubGVuZ3RoLTFdKSB7XG4gICAgICAgICAgICAgIGZvciAobGV0IGk9MCwgbjsgKGk8YyQubGVuZ3RoKSAmJiAobj1jJFtpXSk7IGkrKykge1xuICAgICAgICAgICAgICAgIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG4sIHRoaXMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBfX3N5bmNIb3N0UHJvcGVydGllcygpIHtcbiAgICAgIGxldCBwcm9wcyA9IHRoaXMuX19pbnZhbGlkUHJvcHM7XG4gICAgICBpZiAocHJvcHMpIHtcbiAgICAgICAgZm9yIChsZXQgcHJvcCBpbiBwcm9wcykge1xuICAgICAgICAgIHRoaXMuX19pbnN0YW5jZS5fc2V0UGVuZGluZ1Byb3BlcnR5KHByb3AsIHRoaXMuX19kYXRhSG9zdFtwcm9wXSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fX2ludmFsaWRQcm9wcyA9IG51bGw7XG4gICAgICAgIHRoaXMuX19pbnN0YW5jZS5fZmx1c2hQcm9wZXJ0aWVzKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgX190ZWFyZG93bkluc3RhbmNlKCkge1xuICAgICAgaWYgKHRoaXMuX19pbnN0YW5jZSkge1xuICAgICAgICBsZXQgYyQgPSB0aGlzLl9faW5zdGFuY2UuY2hpbGRyZW47XG4gICAgICAgIGlmIChjJCAmJiBjJC5sZW5ndGgpIHtcbiAgICAgICAgICAvLyB1c2UgZmlyc3QgY2hpbGQgcGFyZW50LCBmb3IgY2FzZSB3aGVuIGRvbS1pZiBtYXkgaGF2ZSBiZWVuIGRldGFjaGVkXG4gICAgICAgICAgbGV0IHBhcmVudCA9IGMkWzBdLnBhcmVudE5vZGU7XG4gICAgICAgICAgZm9yIChsZXQgaT0wLCBuOyAoaTxjJC5sZW5ndGgpICYmIChuPWMkW2ldKTsgaSsrKSB7XG4gICAgICAgICAgICBwYXJlbnQucmVtb3ZlQ2hpbGQobik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX19pbnN0YW5jZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX19pbnZhbGlkUHJvcHMgPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIF9zaG93SGlkZUNoaWxkcmVuKCkge1xuICAgICAgbGV0IGhpZGRlbiA9IHRoaXMuX19oaWRlVGVtcGxhdGVDaGlsZHJlbl9fIHx8ICF0aGlzLmlmO1xuICAgICAgaWYgKHRoaXMuX19pbnN0YW5jZSkge1xuICAgICAgICB0aGlzLl9faW5zdGFuY2UuX3Nob3dIaWRlQ2hpbGRyZW4oaGlkZGVuKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgfVxuXG4gIGN1c3RvbUVsZW1lbnRzLmRlZmluZShEb21JZi5pcywgRG9tSWYpO1xuXG4gIFBvbHltZXIuRG9tSWYgPSBEb21JZjtcblxufSkoKTtcbjwvc2NyaXB0PlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi9lbGVtZW50cy9kb20taWYuaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cblxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uLy4uL3BvbHltZXItZWxlbWVudC5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vdXRpbHMvbWl4aW4uaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3V0aWxzL2FycmF5LXNwbGljZS5odG1sXCI+XG5cbjxzY3JpcHQ+XG4oZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvKipcbiAgICogRWxlbWVudCBtaXhpbiBmb3IgcmVjb3JkaW5nIGR5bmFtaWMgYXNzb2NpYXRpb25zIGJldHdlZW4gaXRlbSBwYXRocyBpbiBhXG4gICAqIG1hc3RlciBgaXRlbXNgIGFycmF5IGFuZCBhIGBzZWxlY3RlZGAgYXJyYXkgc3VjaCB0aGF0IHBhdGggY2hhbmdlcyB0byB0aGVcbiAgICogbWFzdGVyIGFycmF5IChhdCB0aGUgaG9zdCkgZWxlbWVudCBvciBlbHNld2hlcmUgdmlhIGRhdGEtYmluZGluZykgYXJlXG4gICAqIGNvcnJlY3RseSBwcm9wYWdhdGVkIHRvIGl0ZW1zIGluIHRoZSBzZWxlY3RlZCBhcnJheSBhbmQgdmljZS12ZXJzYS5cbiAgICpcbiAgICogVGhlIGBpdGVtc2AgcHJvcGVydHkgYWNjZXB0cyBhbiBhcnJheSBvZiB1c2VyIGRhdGEsIGFuZCB2aWEgdGhlXG4gICAqIGBzZWxlY3QoaXRlbSlgIGFuZCBgZGVzZWxlY3QoaXRlbSlgIEFQSSwgdXBkYXRlcyB0aGUgYHNlbGVjdGVkYCBwcm9wZXJ0eVxuICAgKiB3aGljaCBtYXkgYmUgYm91bmQgdG8gb3RoZXIgcGFydHMgb2YgdGhlIGFwcGxpY2F0aW9uLCBhbmQgYW55IGNoYW5nZXMgdG9cbiAgICogc3ViLWZpZWxkcyBvZiBgc2VsZWN0ZWRgIGl0ZW0ocykgd2lsbCBiZSBrZXB0IGluIHN5bmMgd2l0aCBpdGVtcyBpbiB0aGVcbiAgICogYGl0ZW1zYCBhcnJheS4gIFdoZW4gYG11bHRpYCBpcyBmYWxzZSwgYHNlbGVjdGVkYCBpcyBhIHByb3BlcnR5XG4gICAqIHJlcHJlc2VudGluZyB0aGUgbGFzdCBzZWxlY3RlZCBpdGVtLiAgV2hlbiBgbXVsdGlgIGlzIHRydWUsIGBzZWxlY3RlZGBcbiAgICogaXMgYW4gYXJyYXkgb2YgbXVsdGlwbHkgc2VsZWN0ZWQgaXRlbXMuXG4gICAqXG4gICAqIEBwb2x5bWVyXG4gICAqIEBtaXhpbkZ1bmN0aW9uXG4gICAqIEBhcHBsaWVzTWl4aW4gUG9seW1lci5FbGVtZW50TWl4aW5cbiAgICogQG1lbWJlcm9mIFBvbHltZXJcbiAgICogQHN1bW1hcnkgRWxlbWVudCBtaXhpbiBmb3IgcmVjb3JkaW5nIGR5bmFtaWMgYXNzb2NpYXRpb25zIGJldHdlZW4gaXRlbSBwYXRocyBpbiBhXG4gICAqIG1hc3RlciBgaXRlbXNgIGFycmF5IGFuZCBhIGBzZWxlY3RlZGAgYXJyYXlcbiAgICovXG4gIGxldCBBcnJheVNlbGVjdG9yTWl4aW4gPSBQb2x5bWVyLmRlZHVwaW5nTWl4aW4oc3VwZXJDbGFzcyA9PiB7XG5cbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAZXh0ZW5kcyB7c3VwZXJDbGFzc31cbiAgICAgKiBAaW1wbGVtZW50cyB7UG9seW1lcl9FbGVtZW50TWl4aW59XG4gICAgICovXG4gICAgbGV0IGVsZW1lbnRCYXNlID0gUG9seW1lci5FbGVtZW50TWl4aW4oc3VwZXJDbGFzcyk7XG5cbiAgICAvKipcbiAgICAgKiBAcG9seW1lclxuICAgICAqIEBtaXhpbkNsYXNzXG4gICAgICogQGltcGxlbWVudHMge1BvbHltZXJfQXJyYXlTZWxlY3Rvck1peGlufVxuICAgICAqIEB1bnJlc3RyaWN0ZWRcbiAgICAgKi9cbiAgICBjbGFzcyBBcnJheVNlbGVjdG9yTWl4aW4gZXh0ZW5kcyBlbGVtZW50QmFzZSB7XG5cbiAgICAgIHN0YXRpYyBnZXQgcHJvcGVydGllcygpIHtcblxuICAgICAgICByZXR1cm4ge1xuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogQW4gYXJyYXkgY29udGFpbmluZyBpdGVtcyBmcm9tIHdoaWNoIHNlbGVjdGlvbiB3aWxsIGJlIG1hZGUuXG4gICAgICAgICAgICovXG4gICAgICAgICAgaXRlbXM6IHtcbiAgICAgICAgICAgIHR5cGU6IEFycmF5LFxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBXaGVuIGB0cnVlYCwgbXVsdGlwbGUgaXRlbXMgbWF5IGJlIHNlbGVjdGVkIGF0IG9uY2UgKGluIHRoaXMgY2FzZSxcbiAgICAgICAgICAgKiBgc2VsZWN0ZWRgIGlzIGFuIGFycmF5IG9mIGN1cnJlbnRseSBzZWxlY3RlZCBpdGVtcykuICBXaGVuIGBmYWxzZWAsXG4gICAgICAgICAgICogb25seSBvbmUgaXRlbSBtYXkgYmUgc2VsZWN0ZWQgYXQgYSB0aW1lLlxuICAgICAgICAgICAqL1xuICAgICAgICAgIG11bHRpOiB7XG4gICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgICAgdmFsdWU6IGZhbHNlLFxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBXaGVuIGBtdWx0aWAgaXMgdHJ1ZSwgdGhpcyBpcyBhbiBhcnJheSB0aGF0IGNvbnRhaW5zIGFueSBzZWxlY3RlZC5cbiAgICAgICAgICAgKiBXaGVuIGBtdWx0aWAgaXMgZmFsc2UsIHRoaXMgaXMgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBpdGVtLCBvciBgbnVsbGBcbiAgICAgICAgICAgKiBpZiBubyBpdGVtIGlzIHNlbGVjdGVkLlxuICAgICAgICAgICAqIEB0eXBlIHs/KE9iamVjdHxBcnJheTwhT2JqZWN0Pil9XG4gICAgICAgICAgICovXG4gICAgICAgICAgc2VsZWN0ZWQ6IHtcbiAgICAgICAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgICAgICAgIG5vdGlmeTogdHJ1ZVxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBXaGVuIGBtdWx0aWAgaXMgZmFsc2UsIHRoaXMgaXMgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBpdGVtLCBvciBgbnVsbGBcbiAgICAgICAgICAgKiBpZiBubyBpdGVtIGlzIHNlbGVjdGVkLlxuICAgICAgICAgICAqIEB0eXBlIHs/T2JqZWN0fVxuICAgICAgICAgICAqL1xuICAgICAgICAgIHNlbGVjdGVkSXRlbToge1xuICAgICAgICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgICAgICAgbm90aWZ5OiB0cnVlXG4gICAgICAgICAgfSxcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFdoZW4gYHRydWVgLCBjYWxsaW5nIGBzZWxlY3RgIG9uIGFuIGl0ZW0gdGhhdCBpcyBhbHJlYWR5IHNlbGVjdGVkXG4gICAgICAgICAgICogd2lsbCBkZXNlbGVjdCB0aGUgaXRlbS5cbiAgICAgICAgICAgKi9cbiAgICAgICAgICB0b2dnbGU6IHtcbiAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzdGF0aWMgZ2V0IG9ic2VydmVycygpIHtcbiAgICAgICAgcmV0dXJuIFsnX191cGRhdGVTZWxlY3Rpb24obXVsdGksIGl0ZW1zLiopJ11cbiAgICAgIH1cblxuICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX19sYXN0SXRlbXMgPSBudWxsO1xuICAgICAgICB0aGlzLl9fbGFzdE11bHRpID0gbnVsbDtcbiAgICAgICAgdGhpcy5fX3NlbGVjdGVkTWFwID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgX191cGRhdGVTZWxlY3Rpb24obXVsdGksIGl0ZW1zSW5mbykge1xuICAgICAgICBsZXQgcGF0aCA9IGl0ZW1zSW5mby5wYXRoO1xuICAgICAgICBpZiAocGF0aCA9PSAnaXRlbXMnKSB7XG4gICAgICAgICAgLy8gQ2FzZSAxIC0gaXRlbXMgYXJyYXkgY2hhbmdlZCwgc28gZGlmZiBhZ2FpbnN0IHByZXZpb3VzIGFycmF5IGFuZFxuICAgICAgICAgIC8vIGRlc2VsZWN0IGFueSByZW1vdmVkIGl0ZW1zIGFuZCBhZGp1c3Qgc2VsZWN0ZWQgaW5kaWNlc1xuICAgICAgICAgIGxldCBuZXdJdGVtcyA9IGl0ZW1zSW5mby5iYXNlIHx8IFtdO1xuICAgICAgICAgIGxldCBsYXN0SXRlbXMgPSB0aGlzLl9fbGFzdEl0ZW1zO1xuICAgICAgICAgIGxldCBsYXN0TXVsdGkgPSB0aGlzLl9fbGFzdE11bHRpO1xuICAgICAgICAgIGlmIChtdWx0aSAhPT0gbGFzdE11bHRpKSB7XG4gICAgICAgICAgICB0aGlzLmNsZWFyU2VsZWN0aW9uKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChsYXN0SXRlbXMpIHtcbiAgICAgICAgICAgIGxldCBzcGxpY2VzID0gUG9seW1lci5BcnJheVNwbGljZS5jYWxjdWxhdGVTcGxpY2VzKG5ld0l0ZW1zLCBsYXN0SXRlbXMpO1xuICAgICAgICAgICAgdGhpcy5fX2FwcGx5U3BsaWNlcyhzcGxpY2VzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fX2xhc3RJdGVtcyA9IG5ld0l0ZW1zO1xuICAgICAgICAgIHRoaXMuX19sYXN0TXVsdGkgPSBtdWx0aTtcbiAgICAgICAgfSBlbHNlIGlmIChpdGVtc0luZm8ucGF0aCA9PSAnaXRlbXMuc3BsaWNlcycpIHtcbiAgICAgICAgICAvLyBDYXNlIDIgLSBnb3Qgc3BlY2lmaWMgc3BsaWNlIGluZm9ybWF0aW9uIGRlc2NyaWJpbmcgdGhlIGFycmF5IG11dGF0aW9uOlxuICAgICAgICAgIC8vIGRlc2VsZWN0IGFueSByZW1vdmVkIGl0ZW1zIGFuZCBhZGp1c3Qgc2VsZWN0ZWQgaW5kaWNlc1xuICAgICAgICAgIHRoaXMuX19hcHBseVNwbGljZXMoaXRlbXNJbmZvLnZhbHVlLmluZGV4U3BsaWNlcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gQ2FzZSAzIC0gYW4gYXJyYXkgZWxlbWVudCB3YXMgY2hhbmdlZCwgc28gZGVzZWxlY3QgdGhlIHByZXZpb3VzXG4gICAgICAgICAgLy8gaXRlbSBmb3IgdGhhdCBpbmRleCBpZiBpdCB3YXMgcHJldmlvdXNseSBzZWxlY3RlZFxuICAgICAgICAgIGxldCBwYXJ0ID0gcGF0aC5zbGljZSgnaXRlbXMuJy5sZW5ndGgpO1xuICAgICAgICAgIGxldCBpZHggPSBwYXJzZUludChwYXJ0LCAxMCk7XG4gICAgICAgICAgaWYgKChwYXJ0LmluZGV4T2YoJy4nKSA8IDApICYmIHBhcnQgPT0gaWR4KSB7XG4gICAgICAgICAgICB0aGlzLl9fZGVzZWxlY3RDaGFuZ2VkSWR4KGlkeCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIF9fYXBwbHlTcGxpY2VzKHNwbGljZXMpIHtcbiAgICAgICAgbGV0IHNlbGVjdGVkID0gdGhpcy5fX3NlbGVjdGVkTWFwO1xuICAgICAgICAvLyBBZGp1c3Qgc2VsZWN0ZWQgaW5kaWNlcyBhbmQgbWFyayByZW1vdmFsc1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8c3BsaWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGxldCBzID0gc3BsaWNlc1tpXTtcbiAgICAgICAgICBzZWxlY3RlZC5mb3JFYWNoKChpZHgsIGl0ZW0pID0+IHtcbiAgICAgICAgICAgIGlmIChpZHggPCBzLmluZGV4KSB7XG4gICAgICAgICAgICAgIC8vIG5vIGNoYW5nZVxuICAgICAgICAgICAgfSBlbHNlIGlmIChpZHggPj0gcy5pbmRleCArIHMucmVtb3ZlZC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgLy8gYWRqdXN0IGluZGV4XG4gICAgICAgICAgICAgIHNlbGVjdGVkLnNldChpdGVtLCBpZHggKyBzLmFkZGVkQ291bnQgLSBzLnJlbW92ZWQubGVuZ3RoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIHJlbW92ZSBpbmRleFxuICAgICAgICAgICAgICBzZWxlY3RlZC5zZXQoaXRlbSwgLTEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGZvciAobGV0IGo9MDsgajxzLmFkZGVkQ291bnQ7IGorKykge1xuICAgICAgICAgICAgbGV0IGlkeCA9IHMuaW5kZXggKyBqO1xuICAgICAgICAgICAgaWYgKHNlbGVjdGVkLmhhcyh0aGlzLml0ZW1zW2lkeF0pKSB7XG4gICAgICAgICAgICAgIHNlbGVjdGVkLnNldCh0aGlzLml0ZW1zW2lkeF0sIGlkeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFVwZGF0ZSBsaW5rZWQgcGF0aHNcbiAgICAgICAgdGhpcy5fX3VwZGF0ZUxpbmtzKCk7XG4gICAgICAgIC8vIFJlbW92ZSBzZWxlY3RlZCBpdGVtcyB0aGF0IHdlcmUgcmVtb3ZlZCBmcm9tIHRoZSBpdGVtcyBhcnJheVxuICAgICAgICBsZXQgc2lkeCA9IDA7XG4gICAgICAgIHNlbGVjdGVkLmZvckVhY2goKGlkeCwgaXRlbSkgPT4ge1xuICAgICAgICAgIGlmIChpZHggPCAwKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5tdWx0aSkge1xuICAgICAgICAgICAgICB0aGlzLnNwbGljZSgnc2VsZWN0ZWQnLCBzaWR4LCAxKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWQgPSB0aGlzLnNlbGVjdGVkSXRlbSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxlY3RlZC5kZWxldGUoaXRlbSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNpZHgrKztcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBfX3VwZGF0ZUxpbmtzKCkge1xuICAgICAgICB0aGlzLl9fZGF0YUxpbmtlZFBhdGhzID0ge307XG4gICAgICAgIGlmICh0aGlzLm11bHRpKSB7XG4gICAgICAgICAgbGV0IHNpZHggPSAwO1xuICAgICAgICAgIHRoaXMuX19zZWxlY3RlZE1hcC5mb3JFYWNoKGlkeCA9PiB7XG4gICAgICAgICAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgICAgICAgICAgdGhpcy5saW5rUGF0aHMoJ2l0ZW1zLicgKyBpZHgsICdzZWxlY3RlZC4nICsgc2lkeCsrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9fc2VsZWN0ZWRNYXAuZm9yRWFjaChpZHggPT4ge1xuICAgICAgICAgICAgdGhpcy5saW5rUGF0aHMoJ3NlbGVjdGVkJywgJ2l0ZW1zLicgKyBpZHgpO1xuICAgICAgICAgICAgdGhpcy5saW5rUGF0aHMoJ3NlbGVjdGVkSXRlbScsICdpdGVtcy4nICsgaWR4KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENsZWFycyB0aGUgc2VsZWN0aW9uIHN0YXRlLlxuICAgICAgICpcbiAgICAgICAqL1xuICAgICAgY2xlYXJTZWxlY3Rpb24oKSB7XG4gICAgICAgIC8vIFVuYmluZCBwcmV2aW91cyBzZWxlY3Rpb25cbiAgICAgICAgdGhpcy5fX2RhdGFMaW5rZWRQYXRocyA9IHt9O1xuICAgICAgICAvLyBUaGUgc2VsZWN0ZWQgbWFwIHN0b3JlcyAzIHBpZWNlcyBvZiBpbmZvcm1hdGlvbjpcbiAgICAgICAgLy8ga2V5OiBpdGVtcyBhcnJheSBvYmplY3RcbiAgICAgICAgLy8gdmFsdWU6IGl0ZW1zIGFycmF5IGluZGV4XG4gICAgICAgIC8vIG9yZGVyOiBzZWxlY3RlZCBhcnJheSBpbmRleFxuICAgICAgICB0aGlzLl9fc2VsZWN0ZWRNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8vIEluaXRpYWxpemUgc2VsZWN0aW9uXG4gICAgICAgIHRoaXMuc2VsZWN0ZWQgPSB0aGlzLm11bHRpID8gW10gOiBudWxsXG4gICAgICAgIHRoaXMuc2VsZWN0ZWRJdGVtID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGl0ZW0gaXMgY3VycmVudGx5IHNlbGVjdGVkLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7Kn0gaXRlbSBJdGVtIGZyb20gYGl0ZW1zYCBhcnJheSB0byB0ZXN0XG4gICAgICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBpdGVtIGlzIHNlbGVjdGVkXG4gICAgICAgKi9cbiAgICAgIGlzU2VsZWN0ZWQoaXRlbSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX3NlbGVjdGVkTWFwLmhhcyhpdGVtKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGl0ZW0gaXMgY3VycmVudGx5IHNlbGVjdGVkLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpZHggSW5kZXggZnJvbSBgaXRlbXNgIGFycmF5IHRvIHRlc3RcbiAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIGl0ZW0gaXMgc2VsZWN0ZWRcbiAgICAgICAqL1xuICAgICAgaXNJbmRleFNlbGVjdGVkKGlkeCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1NlbGVjdGVkKHRoaXMuaXRlbXNbaWR4XSk7XG4gICAgICB9XG5cbiAgICAgIF9fZGVzZWxlY3RDaGFuZ2VkSWR4KGlkeCkge1xuICAgICAgICBsZXQgc2lkeCA9IHRoaXMuX19zZWxlY3RlZEluZGV4Rm9ySXRlbUluZGV4KGlkeCk7XG4gICAgICAgIGlmIChzaWR4ID49IDApIHtcbiAgICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgICAgdGhpcy5fX3NlbGVjdGVkTWFwLmZvckVhY2goKGlkeCwgaXRlbSkgPT4ge1xuICAgICAgICAgICAgaWYgKHNpZHggPT0gaSsrKSB7XG4gICAgICAgICAgICAgIHRoaXMuZGVzZWxlY3QoaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgX19zZWxlY3RlZEluZGV4Rm9ySXRlbUluZGV4KGlkeCkge1xuICAgICAgICBsZXQgc2VsZWN0ZWQgPSB0aGlzLl9fZGF0YUxpbmtlZFBhdGhzWydpdGVtcy4nICsgaWR4XTtcbiAgICAgICAgaWYgKHNlbGVjdGVkKSB7XG4gICAgICAgICAgcmV0dXJuIHBhcnNlSW50KHNlbGVjdGVkLnNsaWNlKCdzZWxlY3RlZC4nLmxlbmd0aCksIDEwKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIERlc2VsZWN0cyB0aGUgZ2l2ZW4gaXRlbSBpZiBpdCBpcyBhbHJlYWR5IHNlbGVjdGVkLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7Kn0gaXRlbSBJdGVtIGZyb20gYGl0ZW1zYCBhcnJheSB0byBkZXNlbGVjdFxuICAgICAgICovXG4gICAgICBkZXNlbGVjdChpdGVtKSB7XG4gICAgICAgIGxldCBpZHggPSB0aGlzLl9fc2VsZWN0ZWRNYXAuZ2V0KGl0ZW0pO1xuICAgICAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgICAgICB0aGlzLl9fc2VsZWN0ZWRNYXAuZGVsZXRlKGl0ZW0pO1xuICAgICAgICAgIGxldCBzaWR4O1xuICAgICAgICAgIGlmICh0aGlzLm11bHRpKSB7XG4gICAgICAgICAgICBzaWR4ID0gdGhpcy5fX3NlbGVjdGVkSW5kZXhGb3JJdGVtSW5kZXgoaWR4KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fX3VwZGF0ZUxpbmtzKCk7XG4gICAgICAgICAgaWYgKHRoaXMubXVsdGkpIHtcbiAgICAgICAgICAgIHRoaXMuc3BsaWNlKCdzZWxlY3RlZCcsIHNpZHgsIDEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkID0gdGhpcy5zZWxlY3RlZEl0ZW0gPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIERlc2VsZWN0cyB0aGUgZ2l2ZW4gaW5kZXggaWYgaXQgaXMgYWxyZWFkeSBzZWxlY3RlZC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0gaWR4IEluZGV4IGZyb20gYGl0ZW1zYCBhcnJheSB0byBkZXNlbGVjdFxuICAgICAgICovXG4gICAgICBkZXNlbGVjdEluZGV4KGlkeCkge1xuICAgICAgICB0aGlzLmRlc2VsZWN0KHRoaXMuaXRlbXNbaWR4XSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogU2VsZWN0cyB0aGUgZ2l2ZW4gaXRlbS4gIFdoZW4gYHRvZ2dsZWAgaXMgdHJ1ZSwgdGhpcyB3aWxsIGF1dG9tYXRpY2FsbHlcbiAgICAgICAqIGRlc2VsZWN0IHRoZSBpdGVtIGlmIGFscmVhZHkgc2VsZWN0ZWQuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHsqfSBpdGVtIEl0ZW0gZnJvbSBgaXRlbXNgIGFycmF5IHRvIHNlbGVjdFxuICAgICAgICovXG4gICAgICBzZWxlY3QoaXRlbSkge1xuICAgICAgICB0aGlzLnNlbGVjdEluZGV4KHRoaXMuaXRlbXMuaW5kZXhPZihpdGVtKSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogU2VsZWN0cyB0aGUgZ2l2ZW4gaW5kZXguICBXaGVuIGB0b2dnbGVgIGlzIHRydWUsIHRoaXMgd2lsbCBhdXRvbWF0aWNhbGx5XG4gICAgICAgKiBkZXNlbGVjdCB0aGUgaXRlbSBpZiBhbHJlYWR5IHNlbGVjdGVkLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpZHggSW5kZXggZnJvbSBgaXRlbXNgIGFycmF5IHRvIHNlbGVjdFxuICAgICAgICovXG4gICAgICBzZWxlY3RJbmRleChpZHgpIHtcbiAgICAgICAgbGV0IGl0ZW0gPSB0aGlzLml0ZW1zW2lkeF07XG4gICAgICAgIGlmICghdGhpcy5pc1NlbGVjdGVkKGl0ZW0pKSB7XG4gICAgICAgICAgaWYgKCF0aGlzLm11bHRpKSB7XG4gICAgICAgICAgICB0aGlzLl9fc2VsZWN0ZWRNYXAuY2xlYXIoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fX3NlbGVjdGVkTWFwLnNldChpdGVtLCBpZHgpO1xuICAgICAgICAgIHRoaXMuX191cGRhdGVMaW5rcygpO1xuICAgICAgICAgIGlmICh0aGlzLm11bHRpKSB7XG4gICAgICAgICAgICB0aGlzLnB1c2goJ3NlbGVjdGVkJywgaXRlbSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWQgPSB0aGlzLnNlbGVjdGVkSXRlbSA9IGl0ZW07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMudG9nZ2xlKSB7XG4gICAgICAgICAgdGhpcy5kZXNlbGVjdEluZGV4KGlkeCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgIH1cblxuICAgIHJldHVybiBBcnJheVNlbGVjdG9yTWl4aW47XG5cbiAgfSk7XG5cbiAgLy8gZXhwb3J0IG1peGluXG4gIFBvbHltZXIuQXJyYXlTZWxlY3Rvck1peGluID0gQXJyYXlTZWxlY3Rvck1peGluO1xuXG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQGV4dGVuZHMge1BvbHltZXIuRWxlbWVudH1cbiAgICogQGltcGxlbWVudHMge1BvbHltZXJfQXJyYXlTZWxlY3Rvck1peGlufVxuICAgKi9cbiAgbGV0IGJhc2VBcnJheVNlbGVjdG9yID0gQXJyYXlTZWxlY3Rvck1peGluKFBvbHltZXIuRWxlbWVudCk7XG5cbiAgLyoqXG4gICAqIEVsZW1lbnQgaW1wbGVtZW50aW5nIHRoZSBgUG9seW1lci5BcnJheVNlbGVjdG9yYCBtaXhpbiwgd2hpY2ggcmVjb3Jkc1xuICAgKiBkeW5hbWljIGFzc29jaWF0aW9ucyBiZXR3ZWVuIGl0ZW0gcGF0aHMgaW4gYSBtYXN0ZXIgYGl0ZW1zYCBhcnJheSBhbmQgYVxuICAgKiBgc2VsZWN0ZWRgIGFycmF5IHN1Y2ggdGhhdCBwYXRoIGNoYW5nZXMgdG8gdGhlIG1hc3RlciBhcnJheSAoYXQgdGhlIGhvc3QpXG4gICAqIGVsZW1lbnQgb3IgZWxzZXdoZXJlIHZpYSBkYXRhLWJpbmRpbmcpIGFyZSBjb3JyZWN0bHkgcHJvcGFnYXRlZCB0byBpdGVtc1xuICAgKiBpbiB0aGUgc2VsZWN0ZWQgYXJyYXkgYW5kIHZpY2UtdmVyc2EuXG4gICAqXG4gICAqIFRoZSBgaXRlbXNgIHByb3BlcnR5IGFjY2VwdHMgYW4gYXJyYXkgb2YgdXNlciBkYXRhLCBhbmQgdmlhIHRoZVxuICAgKiBgc2VsZWN0KGl0ZW0pYCBhbmQgYGRlc2VsZWN0KGl0ZW0pYCBBUEksIHVwZGF0ZXMgdGhlIGBzZWxlY3RlZGAgcHJvcGVydHlcbiAgICogd2hpY2ggbWF5IGJlIGJvdW5kIHRvIG90aGVyIHBhcnRzIG9mIHRoZSBhcHBsaWNhdGlvbiwgYW5kIGFueSBjaGFuZ2VzIHRvXG4gICAqIHN1Yi1maWVsZHMgb2YgYHNlbGVjdGVkYCBpdGVtKHMpIHdpbGwgYmUga2VwdCBpbiBzeW5jIHdpdGggaXRlbXMgaW4gdGhlXG4gICAqIGBpdGVtc2AgYXJyYXkuICBXaGVuIGBtdWx0aWAgaXMgZmFsc2UsIGBzZWxlY3RlZGAgaXMgYSBwcm9wZXJ0eVxuICAgKiByZXByZXNlbnRpbmcgdGhlIGxhc3Qgc2VsZWN0ZWQgaXRlbS4gIFdoZW4gYG11bHRpYCBpcyB0cnVlLCBgc2VsZWN0ZWRgXG4gICAqIGlzIGFuIGFycmF5IG9mIG11bHRpcGx5IHNlbGVjdGVkIGl0ZW1zLlxuICAgKlxuICAgKiBFeGFtcGxlOlxuICAgKlxuICAgKiBgYGBodG1sXG4gICAqIDxkb20tbW9kdWxlIGlkPVwiZW1wbG95ZWUtbGlzdFwiPlxuICAgKlxuICAgKiAgIDx0ZW1wbGF0ZT5cbiAgICpcbiAgICogICAgIDxkaXY+IEVtcGxveWVlIGxpc3Q6IDwvZGl2PlxuICAgKiAgICAgPHRlbXBsYXRlIGlzPVwiZG9tLXJlcGVhdFwiIGlkPVwiZW1wbG95ZWVMaXN0XCIgaXRlbXM9XCJ7e2VtcGxveWVlc319XCI+XG4gICAqICAgICAgICAgPGRpdj5GaXJzdCBuYW1lOiA8c3Bhbj57e2l0ZW0uZmlyc3R9fTwvc3Bhbj48L2Rpdj5cbiAgICogICAgICAgICA8ZGl2Pkxhc3QgbmFtZTogPHNwYW4+e3tpdGVtLmxhc3R9fTwvc3Bhbj48L2Rpdj5cbiAgICogICAgICAgICA8YnV0dG9uIG9uLWNsaWNrPVwidG9nZ2xlU2VsZWN0aW9uXCI+U2VsZWN0PC9idXR0b24+XG4gICAqICAgICA8L3RlbXBsYXRlPlxuICAgKlxuICAgKiAgICAgPGFycmF5LXNlbGVjdG9yIGlkPVwic2VsZWN0b3JcIiBpdGVtcz1cInt7ZW1wbG95ZWVzfX1cIiBzZWxlY3RlZD1cInt7c2VsZWN0ZWR9fVwiIG11bHRpIHRvZ2dsZT48L2FycmF5LXNlbGVjdG9yPlxuICAgKlxuICAgKiAgICAgPGRpdj4gU2VsZWN0ZWQgZW1wbG95ZWVzOiA8L2Rpdj5cbiAgICogICAgIDx0ZW1wbGF0ZSBpcz1cImRvbS1yZXBlYXRcIiBpdGVtcz1cInt7c2VsZWN0ZWR9fVwiPlxuICAgKiAgICAgICAgIDxkaXY+Rmlyc3QgbmFtZTogPHNwYW4+e3tpdGVtLmZpcnN0fX08L3NwYW4+PC9kaXY+XG4gICAqICAgICAgICAgPGRpdj5MYXN0IG5hbWU6IDxzcGFuPnt7aXRlbS5sYXN0fX08L3NwYW4+PC9kaXY+XG4gICAqICAgICA8L3RlbXBsYXRlPlxuICAgKlxuICAgKiAgIDwvdGVtcGxhdGU+XG4gICAqXG4gICAqIDwvZG9tLW1vZHVsZT5cbiAgICogYGBgXG4gICAqXG4gICAqIGBgYGpzXG4gICAqIFBvbHltZXIoe1xuICAgKiAgIGlzOiAnZW1wbG95ZWUtbGlzdCcsXG4gICAqICAgcmVhZHkoKSB7XG4gICAqICAgICB0aGlzLmVtcGxveWVlcyA9IFtcbiAgICogICAgICAgICB7Zmlyc3Q6ICdCb2InLCBsYXN0OiAnU21pdGgnfSxcbiAgICogICAgICAgICB7Zmlyc3Q6ICdTYWxseScsIGxhc3Q6ICdKb2huc29uJ30sXG4gICAqICAgICAgICAgLi4uXG4gICAqICAgICBdO1xuICAgKiAgIH0sXG4gICAqICAgdG9nZ2xlU2VsZWN0aW9uKGUpIHtcbiAgICogICAgIGxldCBpdGVtID0gdGhpcy4kLmVtcGxveWVlTGlzdC5pdGVtRm9yRWxlbWVudChlLnRhcmdldCk7XG4gICAqICAgICB0aGlzLiQuc2VsZWN0b3Iuc2VsZWN0KGl0ZW0pO1xuICAgKiAgIH1cbiAgICogfSk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBAcG9seW1lclxuICAgKiBAY3VzdG9tRWxlbWVudFxuICAgKiBAZXh0ZW5kcyB7YmFzZUFycmF5U2VsZWN0b3J9XG4gICAqIEBhcHBsaWVzTWl4aW4gUG9seW1lci5BcnJheVNlbGVjdG9yTWl4aW5cbiAgICogQG1lbWJlcm9mIFBvbHltZXJcbiAgICogQHN1bW1hcnkgQ3VzdG9tIGVsZW1lbnQgdGhhdCBsaW5rcyBwYXRocyBiZXR3ZWVuIGFuIGlucHV0IGBpdGVtc2AgYXJyYXkgYW5kXG4gICAqICAgYW4gb3V0cHV0IGBzZWxlY3RlZGAgaXRlbSBvciBhcnJheSBiYXNlZCBvbiBjYWxscyB0byBpdHMgc2VsZWN0aW9uIEFQSS5cbiAgICovXG4gIGNsYXNzIEFycmF5U2VsZWN0b3IgZXh0ZW5kcyBiYXNlQXJyYXlTZWxlY3RvciB7XG4gICAgLy8gTm90IG5lZWRlZCB0byBmaW5kIHRlbXBsYXRlOyBjYW4gYmUgcmVtb3ZlZCBvbmNlIHRoZSBhbmFseXplclxuICAgIC8vIGNhbiBmaW5kIHRoZSB0YWcgbmFtZSBmcm9tIGN1c3RvbUVsZW1lbnRzLmRlZmluZSBjYWxsXG4gICAgc3RhdGljIGdldCBpcygpIHsgcmV0dXJuICdhcnJheS1zZWxlY3RvcicgfVxuICB9XG4gIGN1c3RvbUVsZW1lbnRzLmRlZmluZShBcnJheVNlbGVjdG9yLmlzLCBBcnJheVNlbGVjdG9yKTtcbiAgUG9seW1lci5BcnJheVNlbGVjdG9yID0gQXJyYXlTZWxlY3RvcjtcblxufSkoKTtcblxuPC9zY3JpcHQ+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL3BvbHltZXIvbGliL2VsZW1lbnRzL2FycmF5LXNlbGVjdG9yLmh0bWwiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vLi4vLi4vc2hhZHljc3MvY3VzdG9tLXN0eWxlLWludGVyZmFjZS5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vdXRpbHMvc3R5bGUtZ2F0aGVyLmh0bWxcIj5cbjxzY3JpcHQ+XG4oZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBjb25zdCBhdHRyID0gJ2luY2x1ZGUnO1xuXG4gIGNvbnN0IEN1c3RvbVN0eWxlSW50ZXJmYWNlID0gd2luZG93LlNoYWR5Q1NTLkN1c3RvbVN0eWxlSW50ZXJmYWNlO1xuXG4gIC8qKlxuICAgKiBDdXN0b20gZWxlbWVudCBmb3IgZGVmaW5pbmcgc3R5bGVzIGluIHRoZSBtYWluIGRvY3VtZW50IHRoYXQgY2FuIHRha2VcbiAgICogYWR2YW50YWdlIG9mIHNldmVyYWwgc3BlY2lhbCBmZWF0dXJlcyBvZiBQb2x5bWVyJ3Mgc3R5bGluZyBzeXN0ZW06XG4gICAqXG4gICAqIC0gRG9jdW1lbnQgc3R5bGVzIGRlZmluZWQgaW4gYSBjdXN0b20tc3R5bGUgYXJlIHNoaW1tZWQgdG8gZW5zdXJlIHRoZXlcbiAgICogICBkbyBub3QgbGVhayBpbnRvIGxvY2FsIERPTSB3aGVuIHJ1bm5pbmcgb24gYnJvd3NlcnMgd2l0aG91dCBuYXRpdmVcbiAgICogICBTaGFkb3cgRE9NLlxuICAgKiAtIEN1c3RvbSBwcm9wZXJ0aWVzIHVzZWQgYnkgUG9seW1lcidzIHNoaW0gZm9yIGNyb3NzLXNjb3BlIHN0eWxpbmcgbWF5XG4gICAqICAgYmUgZGVmaW5lZCBpbiBhbiBjdXN0b20tc3R5bGUuIFVzZSB0aGUgOnJvb3Qgc2VsZWN0b3IgdG8gZGVmaW5lIGN1c3RvbVxuICAgKiAgIHByb3BlcnRpZXMgdGhhdCBhcHBseSB0byBhbGwgY3VzdG9tIGVsZW1lbnRzLlxuICAgKlxuICAgKiBUbyB1c2UsIHNpbXBseSB3cmFwIGFuIGlubGluZSBgPHN0eWxlPmAgdGFnIGluIHRoZSBtYWluIGRvY3VtZW50IHdob3NlXG4gICAqIENTUyB1c2VzIHRoZXNlIGZlYXR1cmVzIHdpdGggYSBgPGN1c3RvbS1zdHlsZT5gIGVsZW1lbnQuXG4gICAqXG4gICAqIEBjdXN0b21FbGVtZW50XG4gICAqIEBleHRlbmRzIEhUTUxFbGVtZW50XG4gICAqIEBtZW1iZXJvZiBQb2x5bWVyXG4gICAqIEBzdW1tYXJ5IEN1c3RvbSBlbGVtZW50IGZvciBkZWZpbmluZyBzdHlsZXMgaW4gdGhlIG1haW4gZG9jdW1lbnQgdGhhdCBjYW5cbiAgICogICB0YWtlIGFkdmFudGFnZSBvZiBQb2x5bWVyJ3Mgc3R5bGUgc2NvcGluZyBhbmQgY3VzdG9tIHByb3BlcnRpZXMgc2hpbXMuXG4gICAqL1xuICBjbGFzcyBDdXN0b21TdHlsZSBleHRlbmRzIEhUTUxFbGVtZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgIHN1cGVyKCk7XG4gICAgICB0aGlzLl9zdHlsZSA9IG51bGw7XG4gICAgICBDdXN0b21TdHlsZUludGVyZmFjZS5hZGRDdXN0b21TdHlsZSh0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbGlnaHQtRE9NIGA8c3R5bGU+YCBjaGlsZCB0aGlzIGVsZW1lbnQgd3JhcHMuICBVcG9uIGZpcnN0XG4gICAgICogY2FsbCBhbnkgc3R5bGUgbW9kdWxlcyByZWZlcmVuY2VkIHZpYSB0aGUgYGluY2x1ZGVgIGF0dHJpYnV0ZSB3aWxsIGJlXG4gICAgICogY29uY2F0ZW5hdGVkIHRvIHRoaXMgZWxlbWVudCdzIGA8c3R5bGU+YC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0hUTUxTdHlsZUVsZW1lbnR9IFRoaXMgZWxlbWVudCdzIGxpZ2h0LURPTSBgPHN0eWxlPmBcbiAgICAgKi9cbiAgICBnZXRTdHlsZSgpIHtcbiAgICAgIGlmICh0aGlzLl9zdHlsZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3R5bGU7XG4gICAgICB9XG4gICAgICBjb25zdCBzdHlsZSA9IC8qKiBAdHlwZSB7SFRNTFN0eWxlRWxlbWVudH0gKi8odGhpcy5xdWVyeVNlbGVjdG9yKCdzdHlsZScpKTtcbiAgICAgIGlmICghc3R5bGUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICB0aGlzLl9zdHlsZSA9IHN0eWxlO1xuICAgICAgY29uc3QgaW5jbHVkZSA9IHN0eWxlLmdldEF0dHJpYnV0ZShhdHRyKTtcbiAgICAgIGlmIChpbmNsdWRlKSB7XG4gICAgICAgIHN0eWxlLnJlbW92ZUF0dHJpYnV0ZShhdHRyKTtcbiAgICAgICAgc3R5bGUudGV4dENvbnRlbnQgPSBQb2x5bWVyLlN0eWxlR2F0aGVyLmNzc0Zyb21Nb2R1bGVzKGluY2x1ZGUpICsgc3R5bGUudGV4dENvbnRlbnQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fc3R5bGU7XG4gICAgfVxuICB9XG5cbiAgd2luZG93LmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnY3VzdG9tLXN0eWxlJywgQ3VzdG9tU3R5bGUpO1xuICBQb2x5bWVyLkN1c3RvbVN0eWxlID0gQ3VzdG9tU3R5bGU7XG59KSgpO1xuPC9zY3JpcHQ+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL3BvbHltZXIvbGliL2VsZW1lbnRzL2N1c3RvbS1zdHlsZS5odG1sIiwiXG5yZXF1aXJlKCcuL2N1c3RvbS1zdHlsZS1pbnRlcmZhY2UubWluLmpzJyk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL3NoYWR5Y3NzL2N1c3RvbS1zdHlsZS1pbnRlcmZhY2UuaHRtbCIsIihmdW5jdGlvbigpey8qXG5cbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiovXG4ndXNlIHN0cmljdCc7dmFyIGM9ISh3aW5kb3cuU2hhZHlET00mJndpbmRvdy5TaGFkeURPTS5pblVzZSksZjtmdW5jdGlvbiBnKGEpe2Y9YSYmYS5zaGltY3NzcHJvcGVydGllcz8hMTpjfHwhKG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL0FwcGxlV2ViS2l0XFwvNjAxfEVkZ2VcXC8xNS8pfHwhd2luZG93LkNTU3x8IUNTUy5zdXBwb3J0c3x8IUNTUy5zdXBwb3J0cyhcImJveC1zaGFkb3dcIixcIjAgMCAwIHZhcigtLWZvbylcIikpfXdpbmRvdy5TaGFkeUNTUyYmdm9pZCAwIT09d2luZG93LlNoYWR5Q1NTLm5hdGl2ZUNzcz9mPXdpbmRvdy5TaGFkeUNTUy5uYXRpdmVDc3M6d2luZG93LlNoYWR5Q1NTPyhnKHdpbmRvdy5TaGFkeUNTUyksd2luZG93LlNoYWR5Q1NTPXZvaWQgMCk6Zyh3aW5kb3cuV2ViQ29tcG9uZW50cyYmd2luZG93LldlYkNvbXBvbmVudHMuZmxhZ3MpO3ZhciBoPWY7ZnVuY3Rpb24gayhhLGIpe2Zvcih2YXIgZCBpbiBiKW51bGw9PT1kP2Euc3R5bGUucmVtb3ZlUHJvcGVydHkoZCk6YS5zdHlsZS5zZXRQcm9wZXJ0eShkLGJbZF0pfTt2YXIgbD1udWxsLG09d2luZG93LkhUTUxJbXBvcnRzJiZ3aW5kb3cuSFRNTEltcG9ydHMud2hlblJlYWR5fHxudWxsLG47ZnVuY3Rpb24gcCgpe3ZhciBhPXE7cmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCl7bT9tKGEpOihsfHwobD1uZXcgUHJvbWlzZShmdW5jdGlvbihhKXtuPWF9KSxcImNvbXBsZXRlXCI9PT1kb2N1bWVudC5yZWFkeVN0YXRlP24oKTpkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwicmVhZHlzdGF0ZWNoYW5nZVwiLGZ1bmN0aW9uKCl7XCJjb21wbGV0ZVwiPT09ZG9jdW1lbnQucmVhZHlTdGF0ZSYmbigpfSkpLGwudGhlbihmdW5jdGlvbigpe2EmJmEoKX0pKX0pfTt2YXIgcj1udWxsLHE9bnVsbDtmdW5jdGlvbiB0KCl7dGhpcy5jdXN0b21TdHlsZXM9W107dGhpcy5lbnF1ZXVlZD0hMX1mdW5jdGlvbiB1KGEpeyFhLmVucXVldWVkJiZxJiYoYS5lbnF1ZXVlZD0hMCxwKCkpfXQucHJvdG90eXBlLmM9ZnVuY3Rpb24oYSl7YS5fX3NlZW5CeVNoYWR5Q1NTfHwoYS5fX3NlZW5CeVNoYWR5Q1NTPSEwLHRoaXMuY3VzdG9tU3R5bGVzLnB1c2goYSksdSh0aGlzKSl9O3QucHJvdG90eXBlLmI9ZnVuY3Rpb24oYSl7aWYoYS5fX3NoYWR5Q1NTQ2FjaGVkU3R5bGUpcmV0dXJuIGEuX19zaGFkeUNTU0NhY2hlZFN0eWxlO3ZhciBiO2EuZ2V0U3R5bGU/Yj1hLmdldFN0eWxlKCk6Yj1hO3JldHVybiBifTtcbnQucHJvdG90eXBlLmE9ZnVuY3Rpb24oKXtmb3IodmFyIGE9dGhpcy5jdXN0b21TdHlsZXMsYj0wO2I8YS5sZW5ndGg7YisrKXt2YXIgZD1hW2JdO2lmKCFkLl9fc2hhZHlDU1NDYWNoZWRTdHlsZSl7dmFyIGU9dGhpcy5iKGQpO2UmJihlPWUuX19hcHBsaWVkRWxlbWVudHx8ZSxyJiZyKGUpLGQuX19zaGFkeUNTU0NhY2hlZFN0eWxlPWUpfX1yZXR1cm4gYX07dC5wcm90b3R5cGUuYWRkQ3VzdG9tU3R5bGU9dC5wcm90b3R5cGUuYzt0LnByb3RvdHlwZS5nZXRTdHlsZUZvckN1c3RvbVN0eWxlPXQucHJvdG90eXBlLmI7dC5wcm90b3R5cGUucHJvY2Vzc1N0eWxlcz10LnByb3RvdHlwZS5hO1xuT2JqZWN0LmRlZmluZVByb3BlcnRpZXModC5wcm90b3R5cGUse3RyYW5zZm9ybUNhbGxiYWNrOntnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gcn0sc2V0OmZ1bmN0aW9uKGEpe3I9YX19LHZhbGlkYXRlQ2FsbGJhY2s6e2dldDpmdW5jdGlvbigpe3JldHVybiBxfSxzZXQ6ZnVuY3Rpb24oYSl7dmFyIGI9ITE7cXx8KGI9ITApO3E9YTtiJiZ1KHRoaXMpfX19KTt2YXIgdj1uZXcgdDt3aW5kb3cuU2hhZHlDU1N8fCh3aW5kb3cuU2hhZHlDU1M9e3ByZXBhcmVUZW1wbGF0ZTpmdW5jdGlvbigpe30sc3R5bGVTdWJ0cmVlOmZ1bmN0aW9uKGEsYil7di5hKCk7ayhhLGIpfSxzdHlsZUVsZW1lbnQ6ZnVuY3Rpb24oKXt2LmEoKX0sc3R5bGVEb2N1bWVudDpmdW5jdGlvbihhKXt2LmEoKTtrKGRvY3VtZW50LmJvZHksYSl9LGdldENvbXB1dGVkU3R5bGVWYWx1ZTpmdW5jdGlvbihhLGIpe3JldHVybihhPXdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGEpLmdldFByb3BlcnR5VmFsdWUoYikpP2EudHJpbSgpOlwiXCJ9LG5hdGl2ZUNzczpoLG5hdGl2ZVNoYWRvdzpjfSk7d2luZG93LlNoYWR5Q1NTLkN1c3RvbVN0eWxlSW50ZXJmYWNlPXY7fSkuY2FsbCh0aGlzKTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3VzdG9tLXN0eWxlLWludGVyZmFjZS5taW4uanMubWFwXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL3NoYWR5Y3NzL2N1c3RvbS1zdHlsZS1pbnRlcmZhY2UubWluLmpzIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuXG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vbWl4aW5zL211dGFibGUtZGF0YS5odG1sXCI+XG5cbjxzY3JpcHQ+XG4oZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBsZXQgbXV0YWJsZVByb3BlcnR5Q2hhbmdlO1xuICAoXG4gICAgLyoqIEBzdXBwcmVzcyB7bWlzc2luZ1Byb3BlcnRpZXN9ICovXG4gICAgZnVuY3Rpb24oKSB7XG4gICAgbXV0YWJsZVByb3BlcnR5Q2hhbmdlID0gUG9seW1lci5NdXRhYmxlRGF0YS5fbXV0YWJsZVByb3BlcnR5Q2hhbmdlO1xuICB9KSgpO1xuXG4gIC8qKlxuICAgKiBMZWdhY3kgZWxlbWVudCBiZWhhdmlvciB0byBza2lwIHN0cmljdCBkaXJ0eS1jaGVja2luZyBmb3Igb2JqZWN0cyBhbmQgYXJyYXlzLFxuICAgKiAoYWx3YXlzIGNvbnNpZGVyIHRoZW0gdG8gYmUgXCJkaXJ0eVwiKSBmb3IgdXNlIG9uIGxlZ2FjeSBBUEkgUG9seW1lciBlbGVtZW50cy5cbiAgICpcbiAgICogQnkgZGVmYXVsdCwgYFBvbHltZXIuUHJvcGVydHlFZmZlY3RzYCBwZXJmb3JtcyBzdHJpY3QgZGlydHkgY2hlY2tpbmcgb25cbiAgICogb2JqZWN0cywgd2hpY2ggbWVhbnMgdGhhdCBhbnkgZGVlcCBtb2RpZmljYXRpb25zIHRvIGFuIG9iamVjdCBvciBhcnJheSB3aWxsXG4gICAqIG5vdCBiZSBwcm9wYWdhdGVkIHVubGVzcyBcImltbXV0YWJsZVwiIGRhdGEgcGF0dGVybnMgYXJlIHVzZWQgKGkuZS4gYWxsIG9iamVjdFxuICAgKiByZWZlcmVuY2VzIGZyb20gdGhlIHJvb3QgdG8gdGhlIG11dGF0aW9uIHdlcmUgY2hhbmdlZCkuXG4gICAqXG4gICAqIFBvbHltZXIgYWxzbyBwcm92aWRlcyBhIHByb3ByaWV0YXJ5IGRhdGEgbXV0YXRpb24gYW5kIHBhdGggbm90aWZpY2F0aW9uIEFQSVxuICAgKiAoZS5nLiBgbm90aWZ5UGF0aGAsIGBzZXRgLCBhbmQgYXJyYXkgbXV0YXRpb24gQVBJJ3MpIHRoYXQgYWxsb3cgZWZmaWNpZW50XG4gICAqIG11dGF0aW9uIGFuZCBub3RpZmljYXRpb24gb2YgZGVlcCBjaGFuZ2VzIGluIGFuIG9iamVjdCBncmFwaCB0byBhbGwgZWxlbWVudHNcbiAgICogYm91bmQgdG8gdGhlIHNhbWUgb2JqZWN0IGdyYXBoLlxuICAgKlxuICAgKiBJbiBjYXNlcyB3aGVyZSBuZWl0aGVyIGltbXV0YWJsZSBwYXR0ZXJucyBub3IgdGhlIGRhdGEgbXV0YXRpb24gQVBJIGNhbiBiZVxuICAgKiB1c2VkLCBhcHBseWluZyB0aGlzIG1peGluIHdpbGwgY2F1c2UgUG9seW1lciB0byBza2lwIGRpcnR5IGNoZWNraW5nIGZvclxuICAgKiBvYmplY3RzIGFuZCBhcnJheXMgKGFsd2F5cyBjb25zaWRlciB0aGVtIHRvIGJlIFwiZGlydHlcIikuICBUaGlzIGFsbG93cyBhXG4gICAqIHVzZXIgdG8gbWFrZSBhIGRlZXAgbW9kaWZpY2F0aW9uIHRvIGEgYm91bmQgb2JqZWN0IGdyYXBoLCBhbmQgdGhlbiBlaXRoZXJcbiAgICogc2ltcGx5IHJlLXNldCB0aGUgb2JqZWN0IChlLmcuIGB0aGlzLml0ZW1zID0gdGhpcy5pdGVtc2ApIG9yIGNhbGwgYG5vdGlmeVBhdGhgXG4gICAqIChlLmcuIGB0aGlzLm5vdGlmeVBhdGgoJ2l0ZW1zJylgKSB0byB1cGRhdGUgdGhlIHRyZWUuICBOb3RlIHRoYXQgYWxsXG4gICAqIGVsZW1lbnRzIHRoYXQgd2lzaCB0byBiZSB1cGRhdGVkIGJhc2VkIG9uIGRlZXAgbXV0YXRpb25zIG11c3QgYXBwbHkgdGhpc1xuICAgKiBtaXhpbiBvciBvdGhlcndpc2Ugc2tpcCBzdHJpY3QgZGlydHkgY2hlY2tpbmcgZm9yIG9iamVjdHMvYXJyYXlzLlxuICAgKlxuICAgKiBJbiBvcmRlciB0byBtYWtlIHRoZSBkaXJ0eSBjaGVjayBzdHJhdGVneSBjb25maWd1cmFibGUsIHNlZVxuICAgKiBgUG9seW1lci5PcHRpb25hbE11dGFibGVEYXRhQmVoYXZpb3JgLlxuICAgKlxuICAgKiBOb3RlLCB0aGUgcGVyZm9ybWFuY2UgY2hhcmFjdGVyaXN0aWNzIG9mIHByb3BhZ2F0aW5nIGxhcmdlIG9iamVjdCBncmFwaHNcbiAgICogd2lsbCBiZSB3b3JzZSBhcyBvcHBvc2VkIHRvIHVzaW5nIHN0cmljdCBkaXJ0eSBjaGVja2luZyB3aXRoIGltbXV0YWJsZVxuICAgKiBwYXR0ZXJucyBvciBQb2x5bWVyJ3MgcGF0aCBub3RpZmljYXRpb24gQVBJLlxuICAgKlxuICAgKiBAcG9seW1lckJlaGF2aW9yXG4gICAqIEBtZW1iZXJvZiBQb2x5bWVyXG4gICAqIEBzdW1tYXJ5IEJlaGF2aW9yIHRvIHNraXAgc3RyaWN0IGRpcnR5LWNoZWNraW5nIGZvciBvYmplY3RzIGFuZFxuICAgKiAgIGFycmF5c1xuICAgKi9cbiAgUG9seW1lci5NdXRhYmxlRGF0YUJlaGF2aW9yID0ge1xuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGVzIGBQb2x5bWVyLlByb3BlcnR5RWZmZWN0c2AgdG8gcHJvdmlkZSBvcHRpb24gZm9yIHNraXBwaW5nXG4gICAgICogc3RyaWN0IGVxdWFsaXR5IGNoZWNraW5nIGZvciBPYmplY3RzIGFuZCBBcnJheXMuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBwdWxscyB0aGUgdmFsdWUgdG8gZGlydHkgY2hlY2sgYWdhaW5zdCBmcm9tIHRoZSBgX19kYXRhVGVtcGBcbiAgICAgKiBjYWNoZSAocmF0aGVyIHRoYW4gdGhlIG5vcm1hbCBgX19kYXRhYCBjYWNoZSkgZm9yIE9iamVjdHMuICBTaW5jZSB0aGUgdGVtcFxuICAgICAqIGNhY2hlIGlzIGNsZWFyZWQgYXQgdGhlIGVuZCBvZiBhIHR1cm4sIHRoaXMgaW1wbGVtZW50YXRpb24gYWxsb3dzXG4gICAgICogc2lkZS1lZmZlY3RzIG9mIGRlZXAgb2JqZWN0IGNoYW5nZXMgdG8gYmUgcHJvY2Vzc2VkIGJ5IHJlLXNldHRpbmcgdGhlXG4gICAgICogc2FtZSBvYmplY3QgKHVzaW5nIHRoZSB0ZW1wIGNhY2hlIGFzIGFuIGluLXR1cm4gYmFja3N0b3AgdG8gcHJldmVudFxuICAgICAqIGN5Y2xlcyBkdWUgdG8gMi13YXkgbm90aWZpY2F0aW9uKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSBuYW1lXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBOZXcgcHJvcGVydHkgdmFsdWVcbiAgICAgKiBAcGFyYW0geyp9IG9sZCBQcmV2aW91cyBwcm9wZXJ0eSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIHByb3BlcnR5IHNob3VsZCBiZSBjb25zaWRlcmVkIGEgY2hhbmdlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9zaG91bGRQcm9wZXJ0eUNoYW5nZShwcm9wZXJ0eSwgdmFsdWUsIG9sZCkge1xuICAgICAgcmV0dXJuIG11dGFibGVQcm9wZXJ0eUNoYW5nZSh0aGlzLCBwcm9wZXJ0eSwgdmFsdWUsIG9sZCwgdHJ1ZSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBMZWdhY3kgZWxlbWVudCBiZWhhdmlvciB0byBhZGQgdGhlIG9wdGlvbmFsIGFiaWxpdHkgdG8gc2tpcCBzdHJpY3RcbiAgICogZGlydHktY2hlY2tpbmcgZm9yIG9iamVjdHMgYW5kIGFycmF5cyAoYWx3YXlzIGNvbnNpZGVyIHRoZW0gdG8gYmVcbiAgICogXCJkaXJ0eVwiKSBieSBzZXR0aW5nIGEgYG11dGFibGUtZGF0YWAgYXR0cmlidXRlIG9uIGFuIGVsZW1lbnQgaW5zdGFuY2UuXG4gICAqXG4gICAqIEJ5IGRlZmF1bHQsIGBQb2x5bWVyLlByb3BlcnR5RWZmZWN0c2AgcGVyZm9ybXMgc3RyaWN0IGRpcnR5IGNoZWNraW5nIG9uXG4gICAqIG9iamVjdHMsIHdoaWNoIG1lYW5zIHRoYXQgYW55IGRlZXAgbW9kaWZpY2F0aW9ucyB0byBhbiBvYmplY3Qgb3IgYXJyYXkgd2lsbFxuICAgKiBub3QgYmUgcHJvcGFnYXRlZCB1bmxlc3MgXCJpbW11dGFibGVcIiBkYXRhIHBhdHRlcm5zIGFyZSB1c2VkIChpLmUuIGFsbCBvYmplY3RcbiAgICogcmVmZXJlbmNlcyBmcm9tIHRoZSByb290IHRvIHRoZSBtdXRhdGlvbiB3ZXJlIGNoYW5nZWQpLlxuICAgKlxuICAgKiBQb2x5bWVyIGFsc28gcHJvdmlkZXMgYSBwcm9wcmlldGFyeSBkYXRhIG11dGF0aW9uIGFuZCBwYXRoIG5vdGlmaWNhdGlvbiBBUElcbiAgICogKGUuZy4gYG5vdGlmeVBhdGhgLCBgc2V0YCwgYW5kIGFycmF5IG11dGF0aW9uIEFQSSdzKSB0aGF0IGFsbG93IGVmZmljaWVudFxuICAgKiBtdXRhdGlvbiBhbmQgbm90aWZpY2F0aW9uIG9mIGRlZXAgY2hhbmdlcyBpbiBhbiBvYmplY3QgZ3JhcGggdG8gYWxsIGVsZW1lbnRzXG4gICAqIGJvdW5kIHRvIHRoZSBzYW1lIG9iamVjdCBncmFwaC5cbiAgICpcbiAgICogSW4gY2FzZXMgd2hlcmUgbmVpdGhlciBpbW11dGFibGUgcGF0dGVybnMgbm9yIHRoZSBkYXRhIG11dGF0aW9uIEFQSSBjYW4gYmVcbiAgICogdXNlZCwgYXBwbHlpbmcgdGhpcyBtaXhpbiB3aWxsIGFsbG93IFBvbHltZXIgdG8gc2tpcCBkaXJ0eSBjaGVja2luZyBmb3JcbiAgICogb2JqZWN0cyBhbmQgYXJyYXlzIChhbHdheXMgY29uc2lkZXIgdGhlbSB0byBiZSBcImRpcnR5XCIpLiAgVGhpcyBhbGxvd3MgYVxuICAgKiB1c2VyIHRvIG1ha2UgYSBkZWVwIG1vZGlmaWNhdGlvbiB0byBhIGJvdW5kIG9iamVjdCBncmFwaCwgYW5kIHRoZW4gZWl0aGVyXG4gICAqIHNpbXBseSByZS1zZXQgdGhlIG9iamVjdCAoZS5nLiBgdGhpcy5pdGVtcyA9IHRoaXMuaXRlbXNgKSBvciBjYWxsIGBub3RpZnlQYXRoYFxuICAgKiAoZS5nLiBgdGhpcy5ub3RpZnlQYXRoKCdpdGVtcycpYCkgdG8gdXBkYXRlIHRoZSB0cmVlLiAgTm90ZSB0aGF0IGFsbFxuICAgKiBlbGVtZW50cyB0aGF0IHdpc2ggdG8gYmUgdXBkYXRlZCBiYXNlZCBvbiBkZWVwIG11dGF0aW9ucyBtdXN0IGFwcGx5IHRoaXNcbiAgICogbWl4aW4gb3Igb3RoZXJ3aXNlIHNraXAgc3RyaWN0IGRpcnR5IGNoZWNraW5nIGZvciBvYmplY3RzL2FycmF5cy5cbiAgICpcbiAgICogV2hpbGUgdGhpcyBiZWhhdmlvciBhZGRzIHRoZSBhYmlsaXR5IHRvIGZvcmdvIE9iamVjdC9BcnJheSBkaXJ0eSBjaGVja2luZyxcbiAgICogdGhlIGBtdXRhYmxlRGF0YWAgZmxhZyBkZWZhdWx0cyB0byBmYWxzZSBhbmQgbXVzdCBiZSBzZXQgb24gdGhlIGluc3RhbmNlLlxuICAgKlxuICAgKiBOb3RlLCB0aGUgcGVyZm9ybWFuY2UgY2hhcmFjdGVyaXN0aWNzIG9mIHByb3BhZ2F0aW5nIGxhcmdlIG9iamVjdCBncmFwaHNcbiAgICogd2lsbCBiZSB3b3JzZSBieSByZWx5aW5nIG9uIGBtdXRhYmxlRGF0YTogdHJ1ZWAgYXMgb3Bwb3NlZCB0byB1c2luZ1xuICAgKiBzdHJpY3QgZGlydHkgY2hlY2tpbmcgd2l0aCBpbW11dGFibGUgcGF0dGVybnMgb3IgUG9seW1lcidzIHBhdGggbm90aWZpY2F0aW9uXG4gICAqIEFQSS5cbiAgICpcbiAgICogQHBvbHltZXJCZWhhdmlvclxuICAgKiBAbWVtYmVyb2YgUG9seW1lclxuICAgKiBAc3VtbWFyeSBCZWhhdmlvciB0byBvcHRpb25hbGx5IHNraXAgc3RyaWN0IGRpcnR5LWNoZWNraW5nIGZvciBvYmplY3RzIGFuZFxuICAgKiAgIGFycmF5c1xuICAgKi9cbiAgUG9seW1lci5PcHRpb25hbE11dGFibGVEYXRhQmVoYXZpb3IgPSB7XG5cbiAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAvKipcbiAgICAgICAqIEluc3RhbmNlLWxldmVsIGZsYWcgZm9yIGNvbmZpZ3VyaW5nIHRoZSBkaXJ0eS1jaGVja2luZyBzdHJhdGVneVxuICAgICAgICogZm9yIHRoaXMgZWxlbWVudC4gIFdoZW4gdHJ1ZSwgT2JqZWN0cyBhbmQgQXJyYXlzIHdpbGwgc2tpcCBkaXJ0eVxuICAgICAgICogY2hlY2tpbmcsIG90aGVyd2lzZSBzdHJpY3QgZXF1YWxpdHkgY2hlY2tpbmcgd2lsbCBiZSB1c2VkLlxuICAgICAgICovXG4gICAgICBtdXRhYmxlRGF0YTogQm9vbGVhblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZXMgYFBvbHltZXIuUHJvcGVydHlFZmZlY3RzYCB0byBza2lwIHN0cmljdCBlcXVhbGl0eSBjaGVja2luZ1xuICAgICAqIGZvciBPYmplY3RzIGFuZCBBcnJheXMuXG4gICAgICpcbiAgICAgKiBQdWxscyB0aGUgdmFsdWUgdG8gZGlydHkgY2hlY2sgYWdhaW5zdCBmcm9tIHRoZSBgX19kYXRhVGVtcGAgY2FjaGVcbiAgICAgKiAocmF0aGVyIHRoYW4gdGhlIG5vcm1hbCBgX19kYXRhYCBjYWNoZSkgZm9yIE9iamVjdHMuICBTaW5jZSB0aGUgdGVtcFxuICAgICAqIGNhY2hlIGlzIGNsZWFyZWQgYXQgdGhlIGVuZCBvZiBhIHR1cm4sIHRoaXMgaW1wbGVtZW50YXRpb24gYWxsb3dzXG4gICAgICogc2lkZS1lZmZlY3RzIG9mIGRlZXAgb2JqZWN0IGNoYW5nZXMgdG8gYmUgcHJvY2Vzc2VkIGJ5IHJlLXNldHRpbmcgdGhlXG4gICAgICogc2FtZSBvYmplY3QgKHVzaW5nIHRoZSB0ZW1wIGNhY2hlIGFzIGFuIGluLXR1cm4gYmFja3N0b3AgdG8gcHJldmVudFxuICAgICAqIGN5Y2xlcyBkdWUgdG8gMi13YXkgbm90aWZpY2F0aW9uKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSBuYW1lXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBOZXcgcHJvcGVydHkgdmFsdWVcbiAgICAgKiBAcGFyYW0geyp9IG9sZCBQcmV2aW91cyBwcm9wZXJ0eSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIHByb3BlcnR5IHNob3VsZCBiZSBjb25zaWRlcmVkIGEgY2hhbmdlXG4gICAgICogQHRoaXMge3RoaXN9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9zaG91bGRQcm9wZXJ0eUNoYW5nZShwcm9wZXJ0eSwgdmFsdWUsIG9sZCkge1xuICAgICAgcmV0dXJuIG11dGFibGVQcm9wZXJ0eUNoYW5nZSh0aGlzLCBwcm9wZXJ0eSwgdmFsdWUsIG9sZCwgdGhpcy5tdXRhYmxlRGF0YSk7XG4gICAgfVxuICB9O1xuXG59KSgpO1xuXG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvbGVnYWN5L211dGFibGUtZGF0YS1iZWhhdmlvci5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNSBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuXG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vLi4vcG9seW1lci9wb2x5bWVyLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi8uLi9pcm9uLW1lZGlhLXF1ZXJ5L2lyb24tbWVkaWEtcXVlcnkuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL2FwcC1sYXlvdXQtYmVoYXZpb3IvYXBwLWxheW91dC1iZWhhdmlvci5odG1sXCI+XG5cbjwhLS1cbmFwcC1kcmF3ZXItbGF5b3V0IGlzIGEgd3JhcHBlciBlbGVtZW50IHRoYXQgcG9zaXRpb25zIGFuIGFwcC1kcmF3ZXIgYW5kIG90aGVyIGNvbnRlbnQuIFdoZW5cbnRoZSB2aWV3cG9ydCB3aWR0aCBpcyBzbWFsbGVyIHRoYW4gYHJlc3BvbnNpdmVXaWR0aGAsIHRoaXMgZWxlbWVudCBjaGFuZ2VzIHRvIG5hcnJvdyBsYXlvdXQuXG5JbiBuYXJyb3cgbGF5b3V0LCB0aGUgZHJhd2VyIHdpbGwgYmUgc3RhY2tlZCBvbiB0b3Agb2YgdGhlIG1haW4gY29udGVudC4gVGhlIGRyYXdlciB3aWxsIHNsaWRlXG5pbi9vdXQgdG8gaGlkZS9yZXZlYWwgdGhlIG1haW4gY29udGVudC5cblxuQnkgZGVmYXVsdCB0aGUgZHJhd2VyIGlzIGFsaWduZWQgdG8gdGhlIHN0YXJ0LCB3aGljaCBpcyBsZWZ0IGluIExUUiBsYXlvdXRzOlxuXG5gYGBodG1sXG48YXBwLWRyYXdlci1sYXlvdXQ+XG4gIDxhcHAtZHJhd2VyIHNsb3Q9XCJkcmF3ZXJcIj5cbiAgICBkcmF3ZXIgY29udGVudFxuICA8L2FwcC1kcmF3ZXI+XG4gIDxkaXY+XG4gICAgbWFpbiBjb250ZW50XG4gIDwvZGl2PlxuPC9hcHAtZHJhd2VyLWxheW91dD5cbmBgYFxuXG5BbGlnbiB0aGUgZHJhd2VyIGF0IHRoZSBlbmQ6XG5cbmBgYGh0bWxcbjxhcHAtZHJhd2VyLWxheW91dD5cbiAgPGFwcC1kcmF3ZXIgc2xvdD1cImRyYXdlclwiIGFsaWduPVwiZW5kXCI+XG4gICAgIGRyYXdlciBjb250ZW50XG4gIDwvYXBwLWRyYXdlcj5cbiAgPGRpdj5cbiAgICBtYWluIGNvbnRlbnRcbiAgPC9kaXY+XG48L2FwcC1kcmF3ZXItbGF5b3V0PlxuYGBgXG5cbldpdGggYW4gYXBwLWhlYWRlci1sYXlvdXQ6XG5cbmBgYGh0bWxcbjxhcHAtZHJhd2VyLWxheW91dD5cbiAgPGFwcC1kcmF3ZXIgc2xvdD1cImRyYXdlclwiPlxuICAgIGRyYXdlci1jb250ZW50XG4gIDwvYXBwLWRyYXdlcj5cbiAgPGFwcC1oZWFkZXItbGF5b3V0PlxuICAgIDxhcHAtaGVhZGVyIHNsb3Q9XCJoZWFkZXJcIj5cbiAgICAgIDxhcHAtdG9vbGJhcj5cbiAgICAgICAgPGRpdiBtYWluLXRpdGxlPkFwcCBuYW1lPC9kaXY+XG4gICAgICA8L2FwcC10b29sYmFyPlxuICAgIDwvYXBwLWhlYWRlcj5cblxuICAgIG1haW4gY29udGVudFxuXG4gIDwvYXBwLWhlYWRlci1sYXlvdXQ+XG48L2FwcC1kcmF3ZXItbGF5b3V0PlxuYGBgXG5cbkFkZCB0aGUgYGRyYXdlci10b2dnbGVgIGF0dHJpYnV0ZSB0byBlbGVtZW50cyBpbnNpZGUgYGFwcC1kcmF3ZXItbGF5b3V0YCB0aGF0IHRvZ2dsZSB0aGUgZHJhd2VyIG9uIGNsaWNrIGV2ZW50czpcblxuYGBgaHRtbFxuPGFwcC1kcmF3ZXItbGF5b3V0PlxuICA8YXBwLWRyYXdlciBzbG90PVwiZHJhd2VyXCI+XG4gICAgZHJhd2VyLWNvbnRlbnRcbiAgPC9hcHAtZHJhd2VyPlxuICA8YXBwLWhlYWRlci1sYXlvdXQ+XG4gICAgPGFwcC1oZWFkZXIgc2xvdD1cImhlYWRlclwiPlxuICAgICAgPGFwcC10b29sYmFyPlxuICAgICAgICA8cGFwZXItaWNvbi1idXR0b24gaWNvbj1cIm1lbnVcIiBkcmF3ZXItdG9nZ2xlPjwvcGFwZXItaWNvbi1idXR0b24+XG4gICAgICAgIDxkaXYgbWFpbi10aXRsZT5BcHAgbmFtZTwvZGl2PlxuICAgICAgPC9hcHAtdG9vbGJhcj5cbiAgICA8L2FwcC1oZWFkZXI+XG5cbiAgICBtYWluIGNvbnRlbnRcblxuICA8L2FwcC1oZWFkZXItbGF5b3V0PlxuPC9hcHAtZHJhd2VyLWxheW91dD5cbmBgYFxuXG4qKk5PVEU6KiogV2l0aCBhcHAtbGF5b3V0IDIuMCwgdGhlIGBkcmF3ZXItdG9nZ2xlYCBlbGVtZW50IHdpbGwgbm90IGJlIGF1dG9tYXRpY2FsbHkgaGlkZGVuXG53aGVuIGFwcC1kcmF3ZXItbGF5b3V0IGlzIG5vdCBpbiBuYXJyb3cgbGF5b3V0LiBUbyBhZGQgdGhpcywgYWRkIHRoZSBmb2xsb3dpbmcgQ1NTIHJ1bGUgd2hlcmVcbmFwcC1kcmF3ZXItbGF5b3V0IGlzIHVzZWQ6XG5cbmBgYGNzc1xuYXBwLWRyYXdlci1sYXlvdXQ6bm90KFtuYXJyb3ddKSBbZHJhd2VyLXRvZ2dsZV0ge1xuICBkaXNwbGF5OiBub25lO1xufVxuYGBgXG5cbkFkZCB0aGUgYGZ1bGxibGVlZGAgYXR0cmlidXRlIHRvIGFwcC1kcmF3ZXItbGF5b3V0IHRvIG1ha2UgaXQgZml0IHRoZSBzaXplIG9mIGl0cyBjb250YWluZXI6XG5cbmBgYGh0bWxcbjxhcHAtZHJhd2VyLWxheW91dCBmdWxsYmxlZWQ+XG4gIDxhcHAtZHJhd2VyIHNsb3Q9XCJkcmF3ZXJcIj5cbiAgICAgZHJhd2VyIGNvbnRlbnRcbiAgPC9hcHAtZHJhd2VyPlxuICA8ZGl2PlxuICAgIG1haW4gY29udGVudFxuICA8L2Rpdj5cbjwvYXBwLWRyYXdlci1sYXlvdXQ+XG5gYGBcblxuIyMjIFN0eWxpbmdcblxuQ3VzdG9tIHByb3BlcnR5ICAgICAgICAgICAgICAgICAgICAgICAgICB8IERlc2NyaXB0aW9uICAgICAgICAgICAgICAgICAgICAgICAgICB8IERlZmF1bHRcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfC0tLS0tLS0tLVxuYC0tYXBwLWRyYXdlci13aWR0aGAgICAgICAgICAgICAgICAgICAgICB8IFdpZHRoIG9mIHRoZSBkcmF3ZXIgICAgICAgICAgICAgICAgICB8IDI1NnB4XG5gLS1hcHAtZHJhd2VyLWxheW91dC1jb250ZW50LXRyYW5zaXRpb25gIHwgVHJhbnNpdGlvbiBmb3IgdGhlIGNvbnRlbnQgY29udGFpbmVyIHwgbm9uZVxuXG4qKk5PVEU6KiogSWYgeW91IHVzZSA8YXBwLWRyYXdlcj4gd2l0aCA8YXBwLWRyYXdlci1sYXlvdXQ+IGFuZCBzcGVjaWZ5IGEgdmFsdWUgZm9yXG5gLS1hcHAtZHJhd2VyLXdpZHRoYCwgdGhhdCB2YWx1ZSBtdXN0IGJlIGFjY2Vzc2libGUgYnkgYm90aCBlbGVtZW50cy4gVGhpcyBjYW4gYmUgZG9uZSBieVxuZGVmaW5pbmcgdGhlIHZhbHVlIG9uIHRoZSBgOmhvc3RgIHRoYXQgY29udGFpbnMgPGFwcC1kcmF3ZXItbGF5b3V0PiAob3IgYGh0bWxgIGlmIG91dHNpZGVcbmEgc2hhZG93IHJvb3QpOlxuXG5gYGBjc3Ncbjpob3N0IHtcbiAgLS1hcHAtZHJhd2VyLXdpZHRoOiAzMDBweDtcbn1cbmBgYFxuXG5AZ3JvdXAgQXBwIEVsZW1lbnRzXG5AZWxlbWVudCBhcHAtZHJhd2VyLWxheW91dFxuQGRlbW8gYXBwLWRyYXdlci1sYXlvdXQvZGVtby9pbmRleC5odG1sXG4tLT5cblxuPGRvbS1tb2R1bGUgaWQ9XCJhcHAtZHJhd2VyLWxheW91dFwiPlxuICA8dGVtcGxhdGU+XG4gICAgPHN0eWxlPlxuICAgICAgOmhvc3Qge1xuICAgICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZvcmNlIGFwcC1kcmF3ZXItbGF5b3V0IHRvIGhhdmUgaXRzIG93biBzdGFja2luZyBjb250ZXh0IHNvIHRoYXQgaXRzIHBhcmVudCBjYW5cbiAgICAgICAgICogY29udHJvbCB0aGUgc3RhY2tpbmcgb2YgaXQgcmVsYXRpdmUgdG8gb3RoZXIgZWxlbWVudHMuXG4gICAgICAgICAqL1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgIHotaW5kZXg6IDA7XG4gICAgICB9XG5cbiAgICAgIDpob3N0IDo6c2xvdHRlZChbc2xvdD1kcmF3ZXJdKSB7XG4gICAgICAgIHotaW5kZXg6IDE7XG4gICAgICB9XG5cbiAgICAgIDpob3N0KFtmdWxsYmxlZWRdKSB7XG4gICAgICAgIEBhcHBseSAtLWxheW91dC1maXQ7XG4gICAgICB9XG5cbiAgICAgICNjb250ZW50Q29udGFpbmVyIHtcbiAgICAgICAgLyogQ3JlYXRlIGEgc3RhY2tpbmcgY29udGV4dCBoZXJlIHNvIHRoYXQgYWxsIGNoaWxkcmVuIGFwcGVhciBiZWxvdyB0aGUgaGVhZGVyLiAqL1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgIHotaW5kZXg6IDA7XG4gICAgICAgIGhlaWdodDogMTAwJTtcbiAgICAgICAgdHJhbnNpdGlvbjogdmFyKC0tYXBwLWRyYXdlci1sYXlvdXQtY29udGVudC10cmFuc2l0aW9uLCBub25lKTtcbiAgICAgIH1cblxuICAgICAgI2NvbnRlbnRDb250YWluZXJbZHJhd2VyLXBvc2l0aW9uPWxlZnRdIHtcbiAgICAgICAgbWFyZ2luLWxlZnQ6IHZhcigtLWFwcC1kcmF3ZXItd2lkdGgsIDI1NnB4KTtcbiAgICAgIH1cblxuICAgICAgI2NvbnRlbnRDb250YWluZXJbZHJhd2VyLXBvc2l0aW9uPXJpZ2h0XSB7XG4gICAgICAgIG1hcmdpbi1yaWdodDogdmFyKC0tYXBwLWRyYXdlci13aWR0aCwgMjU2cHgpO1xuICAgICAgfVxuICAgIDwvc3R5bGU+XG5cbiAgICA8c2xvdCBpZD1cImRyYXdlclNsb3RcIiBuYW1lPVwiZHJhd2VyXCI+PC9zbG90PlxuXG4gICAgPGRpdiBpZD1cImNvbnRlbnRDb250YWluZXJcIiBkcmF3ZXItcG9zaXRpb24kPVwiW1tfZHJhd2VyUG9zaXRpb25dXVwiPlxuICAgICAgPHNsb3Q+PC9zbG90PlxuICAgIDwvZGl2PlxuXG4gICAgPGlyb24tbWVkaWEtcXVlcnlcbiAgICAgICAgcXVlcnk9XCJbW19jb21wdXRlTWVkaWFRdWVyeShmb3JjZU5hcnJvdywgcmVzcG9uc2l2ZVdpZHRoKV1dXCJcbiAgICAgICAgb24tcXVlcnktbWF0Y2hlcy1jaGFuZ2VkPVwiX29uUXVlcnlNYXRjaGVzQ2hhbmdlZFwiPjwvaXJvbi1tZWRpYS1xdWVyeT5cbiAgPC90ZW1wbGF0ZT5cblxuICA8c2NyaXB0PlxuICAgIFBvbHltZXIoe1xuICAgICAgaXM6ICdhcHAtZHJhd2VyLWxheW91dCcsXG5cbiAgICAgIGJlaGF2aW9yczogW1xuICAgICAgICBQb2x5bWVyLkFwcExheW91dEJlaGF2aW9yXG4gICAgICBdLFxuXG4gICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0cnVlLCBpZ25vcmUgYHJlc3BvbnNpdmVXaWR0aGAgc2V0dGluZyBhbmQgZm9yY2UgdGhlIG5hcnJvdyBsYXlvdXQuXG4gICAgICAgICAqL1xuICAgICAgICBmb3JjZU5hcnJvdzoge1xuICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHRoZSB2aWV3cG9ydCdzIHdpZHRoIGlzIHNtYWxsZXIgdGhhbiB0aGlzIHZhbHVlLCB0aGUgcGFuZWwgd2lsbCBjaGFuZ2UgdG8gbmFycm93XG4gICAgICAgICAqIGxheW91dC4gSW4gdGhlIG1vZGUgdGhlIGRyYXdlciB3aWxsIGJlIGNsb3NlZC5cbiAgICAgICAgICovXG4gICAgICAgIHJlc3BvbnNpdmVXaWR0aDoge1xuICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICB2YWx1ZTogJzY0MHB4J1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRydWUgaWYgaXQgaXMgaW4gbmFycm93IGxheW91dC4gVGhpcyBpcyB1c2VmdWwgaWYgeW91IG5lZWQgdG8gc2hvdy9oaWRlXG4gICAgICAgICAqIGVsZW1lbnRzIGJhc2VkIG9uIHRoZSBsYXlvdXQuXG4gICAgICAgICAqL1xuICAgICAgICBuYXJyb3c6IHtcbiAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgIHJlZmxlY3RUb0F0dHJpYnV0ZTogdHJ1ZSxcbiAgICAgICAgICByZWFkT25seTogdHJ1ZSxcbiAgICAgICAgICBub3RpZnk6IHRydWVcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgdHJ1ZSwgdGhlIGRyYXdlciB3aWxsIGluaXRpYWxseSBiZSBvcGVuZWQgd2hlbiBpbiBuYXJyb3cgbGF5b3V0IG1vZGUuXG4gICAgICAgICAqL1xuICAgICAgICBvcGVuZWRXaGVuTmFycm93OiB7XG4gICAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgfSxcblxuICAgICAgICBfZHJhd2VyUG9zaXRpb246IHtcbiAgICAgICAgICB0eXBlOiBTdHJpbmdcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgbGlzdGVuZXJzOiB7XG4gICAgICAgICdjbGljayc6ICdfY2xpY2tIYW5kbGVyJ1xuICAgICAgfSxcblxuICAgICAgb2JzZXJ2ZXJzOiBbXG4gICAgICAgICdfbmFycm93Q2hhbmdlZChuYXJyb3cpJ1xuICAgICAgXSxcblxuICAgICAgLyoqXG4gICAgICAgKiBBIHJlZmVyZW5jZSB0byB0aGUgYXBwLWRyYXdlciBlbGVtZW50LlxuICAgICAgICpcbiAgICAgICAqIEBwcm9wZXJ0eSBkcmF3ZXJcbiAgICAgICAqL1xuICAgICAgZ2V0IGRyYXdlcigpIHtcbiAgICAgICAgcmV0dXJuIFBvbHltZXIuZG9tKHRoaXMuJC5kcmF3ZXJTbG90KS5nZXREaXN0cmlidXRlZE5vZGVzKClbMF07XG4gICAgICB9LFxuXG4gICAgICBhdHRhY2hlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIERpc2FibGUgZHJhd2VyIHRyYW5zaXRpb25zIHVudGlsIGFmdGVyIGFwcC1kcmF3ZXItbGF5b3V0IHNldHMgdGhlIGluaXRpYWwgb3BlbmVkIHN0YXRlLlxuICAgICAgICB2YXIgZHJhd2VyID0gdGhpcy5kcmF3ZXI7XG4gICAgICAgIGlmIChkcmF3ZXIpIHtcbiAgICAgICAgICBkcmF3ZXIuc2V0QXR0cmlidXRlKCduby10cmFuc2l0aW9uJywgJycpO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBfY2xpY2tIYW5kbGVyOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIHZhciB0YXJnZXQgPSBQb2x5bWVyLmRvbShlKS5sb2NhbFRhcmdldDtcbiAgICAgICAgaWYgKHRhcmdldCAmJiB0YXJnZXQuaGFzQXR0cmlidXRlKCdkcmF3ZXItdG9nZ2xlJykpIHtcbiAgICAgICAgICB2YXIgZHJhd2VyID0gdGhpcy5kcmF3ZXI7XG4gICAgICAgICAgaWYgKGRyYXdlciAmJiAhZHJhd2VyLnBlcnNpc3RlbnQpIHtcbiAgICAgICAgICAgIGRyYXdlci50b2dnbGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIF91cGRhdGVMYXlvdXRTdGF0ZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZHJhd2VyID0gdGhpcy5kcmF3ZXI7XG4gICAgICAgIGlmICghdGhpcy5pc0F0dGFjaGVkIHx8ICFkcmF3ZXIpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9kcmF3ZXJQb3NpdGlvbiA9IHRoaXMubmFycm93ID8gbnVsbCA6IGRyYXdlci5wb3NpdGlvbjtcbiAgICAgICAgaWYgKHRoaXMuX2RyYXdlck5lZWRzUmVzZXQpIHtcbiAgICAgICAgICBpZiAodGhpcy5uYXJyb3cpIHtcbiAgICAgICAgICAgIGRyYXdlci5vcGVuZWQgPSB0aGlzLm9wZW5lZFdoZW5OYXJyb3c7XG4gICAgICAgICAgICBkcmF3ZXIucGVyc2lzdGVudCA9IGZhbHNlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkcmF3ZXIub3BlbmVkID0gZHJhd2VyLnBlcnNpc3RlbnQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZHJhd2VyLmhhc0F0dHJpYnV0ZSgnbm8tdHJhbnNpdGlvbicpKSB7XG4gICAgICAgICAgICAvLyBFbmFibGUgZHJhd2VyIHRyYW5zaXRpb25zIGFmdGVyIGFwcC1kcmF3ZXItbGF5b3V0IHNldHMgdGhlIGluaXRpYWwgb3BlbmVkIHN0YXRlLlxuICAgICAgICAgICAgUG9seW1lci5SZW5kZXJTdGF0dXMuYWZ0ZXJOZXh0UmVuZGVyKHRoaXMsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBkcmF3ZXIucmVtb3ZlQXR0cmlidXRlKCduby10cmFuc2l0aW9uJyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fZHJhd2VyTmVlZHNSZXNldCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBfbmFycm93Q2hhbmdlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX2RyYXdlck5lZWRzUmVzZXQgPSB0cnVlO1xuICAgICAgICB0aGlzLnJlc2V0TGF5b3V0KCk7XG4gICAgICB9LFxuXG4gICAgICBfb25RdWVyeU1hdGNoZXNDaGFuZ2VkOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICB0aGlzLl9zZXROYXJyb3coZXZlbnQuZGV0YWlsLnZhbHVlKTtcbiAgICAgIH0sXG5cbiAgICAgIF9jb21wdXRlTWVkaWFRdWVyeTogZnVuY3Rpb24oZm9yY2VOYXJyb3csIHJlc3BvbnNpdmVXaWR0aCkge1xuICAgICAgICByZXR1cm4gZm9yY2VOYXJyb3cgPyAnKG1pbi13aWR0aDogMHB4KScgOiAnKG1heC13aWR0aDogJyArIHJlc3BvbnNpdmVXaWR0aCArICcpJztcbiAgICAgIH1cbiAgICB9KTtcbiAgPC9zY3JpcHQ+XG48L2RvbS1tb2R1bGU+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL2FwcC1sYXlvdXQvYXBwLWRyYXdlci1sYXlvdXQvYXBwLWRyYXdlci1sYXlvdXQuaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTUgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cblxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3BvbHltZXIvcG9seW1lci5odG1sXCI+XG5cbjwhLS1cbmBpcm9uLW1lZGlhLXF1ZXJ5YCBjYW4gYmUgdXNlZCB0byBkYXRhIGJpbmQgdG8gYSBDU1MgbWVkaWEgcXVlcnkuXG5UaGUgYHF1ZXJ5YCBwcm9wZXJ0eSBpcyBhIGJhcmUgQ1NTIG1lZGlhIHF1ZXJ5LlxuVGhlIGBxdWVyeS1tYXRjaGVzYCBwcm9wZXJ0eSBpcyBhIGJvb2xlYW4gcmVwcmVzZW50aW5nIHdoZXRoZXIgdGhlIHBhZ2UgbWF0Y2hlcyB0aGF0IG1lZGlhIHF1ZXJ5LlxuXG5FeGFtcGxlOlxuXG4gICAgPGlyb24tbWVkaWEtcXVlcnkgcXVlcnk9XCIobWluLXdpZHRoOiA2MDBweClcIiBxdWVyeS1tYXRjaGVzPVwie3txdWVyeU1hdGNoZXN9fVwiPjwvaXJvbi1tZWRpYS1xdWVyeT5cblxuQGdyb3VwIElyb24gRWxlbWVudHNcbkBkZW1vIGRlbW8vaW5kZXguaHRtbFxuQGhlcm8gaGVyby5zdmdcbkBlbGVtZW50IGlyb24tbWVkaWEtcXVlcnlcbi0tPlxuXG48c2NyaXB0PlxuXG4gIFBvbHltZXIoe1xuXG4gICAgaXM6ICdpcm9uLW1lZGlhLXF1ZXJ5JyxcblxuICAgIHByb3BlcnRpZXM6IHtcblxuICAgICAgLyoqXG4gICAgICAgKiBUaGUgQm9vbGVhbiByZXR1cm4gdmFsdWUgb2YgdGhlIG1lZGlhIHF1ZXJ5LlxuICAgICAgICovXG4gICAgICBxdWVyeU1hdGNoZXM6IHtcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgdmFsdWU6IGZhbHNlLFxuICAgICAgICByZWFkT25seTogdHJ1ZSxcbiAgICAgICAgbm90aWZ5OiB0cnVlXG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFRoZSBDU1MgbWVkaWEgcXVlcnkgdG8gZXZhbHVhdGUuXG4gICAgICAgKi9cbiAgICAgIHF1ZXJ5OiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgb2JzZXJ2ZXI6ICdxdWVyeUNoYW5nZWQnXG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIElmIHRydWUsIHRoZSBxdWVyeSBhdHRyaWJ1dGUgaXMgYXNzdW1lZCB0byBiZSBhIGNvbXBsZXRlIG1lZGlhIHF1ZXJ5XG4gICAgICAgKiBzdHJpbmcgcmF0aGVyIHRoYW4gYSBzaW5nbGUgbWVkaWEgZmVhdHVyZS5cbiAgICAgICAqL1xuICAgICAgZnVsbDoge1xuICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogQHR5cGUge2Z1bmN0aW9uKE1lZGlhUXVlcnlMaXN0KX1cbiAgICAgICAqL1xuICAgICAgX2JvdW5kTVFIYW5kbGVyOiB7XG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5xdWVyeUhhbmRsZXIuYmluZCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBAdHlwZSB7TWVkaWFRdWVyeUxpc3R9XG4gICAgICAgKi9cbiAgICAgIF9tcToge1xuICAgICAgICB2YWx1ZTogbnVsbFxuICAgICAgfVxuICAgIH0sXG5cbiAgICBhdHRhY2hlZDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICB0aGlzLnF1ZXJ5Q2hhbmdlZCgpO1xuICAgIH0sXG5cbiAgICBkZXRhY2hlZDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9yZW1vdmUoKTtcbiAgICB9LFxuXG4gICAgX2FkZDogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5fbXEpIHtcbiAgICAgICAgdGhpcy5fbXEuYWRkTGlzdGVuZXIodGhpcy5fYm91bmRNUUhhbmRsZXIpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBfcmVtb3ZlOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLl9tcSkge1xuICAgICAgICB0aGlzLl9tcS5yZW1vdmVMaXN0ZW5lcih0aGlzLl9ib3VuZE1RSGFuZGxlcik7XG4gICAgICB9XG4gICAgICB0aGlzLl9tcSA9IG51bGw7XG4gICAgfSxcblxuICAgIHF1ZXJ5Q2hhbmdlZDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9yZW1vdmUoKTtcbiAgICAgIHZhciBxdWVyeSA9IHRoaXMucXVlcnk7XG4gICAgICBpZiAoIXF1ZXJ5KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5mdWxsICYmIHF1ZXJ5WzBdICE9PSAnKCcpIHtcbiAgICAgICAgcXVlcnkgPSAnKCcgKyBxdWVyeSArICcpJztcbiAgICAgIH1cbiAgICAgIHRoaXMuX21xID0gd2luZG93Lm1hdGNoTWVkaWEocXVlcnkpO1xuICAgICAgdGhpcy5fYWRkKCk7XG4gICAgICB0aGlzLnF1ZXJ5SGFuZGxlcih0aGlzLl9tcSk7XG4gICAgfSxcblxuICAgIHF1ZXJ5SGFuZGxlcjogZnVuY3Rpb24obXEpIHtcbiAgICAgIHRoaXMuX3NldFF1ZXJ5TWF0Y2hlcyhtcS5tYXRjaGVzKTtcbiAgICB9XG5cbiAgfSk7XG5cbjwvc2NyaXB0PlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9pcm9uLW1lZGlhLXF1ZXJ5L2lyb24tbWVkaWEtcXVlcnkuaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTUgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cblxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uLy4uL3BvbHltZXIvcG9seW1lci5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vLi4vaXJvbi1mbGV4LWxheW91dC9pcm9uLWZsZXgtbGF5b3V0Lmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi9hcHAtc2Nyb2xsLWVmZmVjdHMvYXBwLXNjcm9sbC1lZmZlY3RzLWJlaGF2aW9yLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi9hcHAtbGF5b3V0LWJlaGF2aW9yL2FwcC1sYXlvdXQtYmVoYXZpb3IuaHRtbFwiPlxuXG48IS0tXG5hcHAtaGVhZGVyIGlzIGNvbnRhaW5lciBlbGVtZW50IGZvciBhcHAtdG9vbGJhcnMgYXQgdGhlIHRvcCBvZiB0aGUgc2NyZWVuIHRoYXQgY2FuIGhhdmUgc2Nyb2xsXG5lZmZlY3RzLiBCeSBkZWZhdWx0LCBhbiBhcHAtaGVhZGVyIG1vdmVzIGF3YXkgZnJvbSB0aGUgdmlld3BvcnQgd2hlbiBzY3JvbGxpbmcgZG93biBhbmRcbmlmIHVzaW5nIGByZXZlYWxzYCwgdGhlIGhlYWRlciBzbGlkZXMgYmFjayB3aGVuIHNjcm9sbGluZyBiYWNrIHVwLiBGb3IgZXhhbXBsZTpcblxuYGBgaHRtbFxuPGFwcC1oZWFkZXIgcmV2ZWFscz5cbiAgPGFwcC10b29sYmFyPlxuICAgIDxkaXYgbWFpbi10aXRsZT5BcHAgbmFtZTwvZGl2PlxuICA8L2FwcC10b29sYmFyPlxuPC9hcHAtaGVhZGVyPlxuYGBgXG5cbmFwcC1oZWFkZXIgY2FuIGFsc28gY29uZGVuc2Ugd2hlbiBzY3JvbGxpbmcgZG93bi4gVG8gYWNoaWV2ZSB0aGlzIGJlaGF2aW9yLCB0aGUgaGVhZGVyXG5tdXN0IGhhdmUgYSBsYXJnZXIgaGVpZ2h0IHRoYW4gdGhlIGBzdGlja3lgIGVsZW1lbnQgaW4gdGhlIGxpZ2h0IERPTS4gRm9yIGV4YW1wbGU6XG5cbmBgYGh0bWxcbjxhcHAtaGVhZGVyIHN0eWxlPVwiaGVpZ2h0OiA5NnB4O1wiIGNvbmRlbnNlcyBmaXhlZD5cbiAgPGFwcC10b29sYmFyIHN0eWxlPVwiaGVpZ2h0OiA2NHB4O1wiPlxuICAgIDxkaXYgbWFpbi10aXRsZT5BcHAgbmFtZTwvZGl2PlxuICA8L2FwcC10b29sYmFyPlxuPC9hcHAtaGVhZGVyPlxuYGBgXG5cbkluIHRoaXMgY2FzZSB0aGUgaGVhZGVyIGlzIGluaXRpYWxseSBgOTZweGAgdGFsbCwgYW5kIGl0IHNocmlua3MgdG8gYDY0cHhgIHdoZW4gc2Nyb2xsaW5nIGRvd24uXG5UaGF0IGlzIHdoYXQgaXMgbWVhbnQgYnkgXCJjb25kZW5zaW5nXCIuXG5cbiMjIyBTdGlja3kgZWxlbWVudFxuXG5UaGUgZWxlbWVudCB0aGF0IGlzIHBvc2l0aW9uZWQgZml4ZWQgdG8gdG9wIG9mIHRoZSBoZWFkZXIncyBgc2Nyb2xsVGFyZ2V0YCB3aGVuIGEgdGhyZXNob2xkXG5pcyByZWFjaGVkLCBzaW1pbGFyIHRvIGBwb3NpdGlvbjogc3RpY2t5YCBpbiBDU1MuIFRoaXMgZWxlbWVudCAqKm11c3QqKiBiZSBhbiBpbW1lZGlhdGVcbmNoaWxkIG9mIGFwcC1oZWFkZXIuIEJ5IGRlZmF1bHQsIHRoZSBgc3RpY2t5YCBlbGVtZW50IGlzIHRoZSBmaXJzdCBgYXBwLXRvb2xiYXIgdGhhdFxuaXMgYW4gaW1tZWRpYXRlIGNoaWxkIG9mIGFwcC1oZWFkZXIuXG5cbmBgYGh0bWxcbjxhcHAtaGVhZGVyIGNvbmRlbnNlcz5cbiAgPGFwcC10b29sYmFyPiBTdGlja3kgZWxlbWVudCA8L2FwcC10b29sYmFyPlxuPC9hcHAtaGVhZGVyPlxuYGBgXG5cbiMjIyMgQ3VzdG9taXppbmcgdGhlIHN0aWNreSBlbGVtZW50XG5cbmBgYGh0bWxcbjxhcHAtaGVhZGVyIGNvbmRlbnNlcz5cbiAgPGFwcC10b29sYmFyPjwvYXBwLXRvb2xiYXI+XG4gIDxhcHAtdG9vbGJhciBzdGlja3k+IFN0aWNreSBlbGVtZW50IDwvYXBwLXRvb2xiYXI+XG48L2FwcC1oZWFkZXI+XG5gYGBcblxuIyMjIFNjcm9sbCB0YXJnZXRcblxuVGhlIGFwcC1oZWFkZXIncyBgc2Nyb2xsVGFyZ2V0YCBwcm9wZXJ0eSBhbGxvd3MgdG8gY3VzdG9taXplIHRoZSBzY3JvbGxhYmxlIGVsZW1lbnQgdG8gd2hpY2hcbnRoZSBoZWFkZXIgcmVzcG9uZHMgd2hlbiB0aGUgdXNlciBzY3JvbGxzLiBCeSBkZWZhdWx0LCBhcHAtaGVhZGVyIHVzZXMgdGhlIGRvY3VtZW50IGFzXG50aGUgc2Nyb2xsIHRhcmdldCwgYnV0IHlvdSBjYW4gY3VzdG9taXplIHRoaXMgcHJvcGVydHkgYnkgc2V0dGluZyB0aGUgaWQgb2YgdGhlIGVsZW1lbnQsIGUuZy5cblxuYGBgaHRtbFxuPGRpdiBpZD1cInNjcm9sbGluZ1JlZ2lvblwiIHN0eWxlPVwib3ZlcmZsb3cteTogYXV0bztcIj5cbiAgPGFwcC1oZWFkZXIgc2Nyb2xsLXRhcmdldD1cInNjcm9sbGluZ1JlZ2lvblwiPlxuICA8L2FwcC1oZWFkZXI+XG48L2Rpdj5cbmBgYFxuXG5JbiB0aGlzIGNhc2UsIHRoZSBgc2Nyb2xsVGFyZ2V0YCBwcm9wZXJ0eSBwb2ludHMgdG8gdGhlIG91dGVyIGRpdiBlbGVtZW50LiBBbHRlcm5hdGl2ZWx5LFxueW91IGNhbiBzZXQgdGhpcyBwcm9wZXJ0eSBwcm9ncmFtbWF0aWNhbGx5OlxuXG5gYGBqc1xuYXBwSGVhZGVyLnNjcm9sbFRhcmdldCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjc2Nyb2xsaW5nUmVnaW9uXCIpO1xuYGBgXG5cbiMjIEJhY2tncm91bmRzXG5hcHAtaGVhZGVyIGhhcyB0d28gYmFja2dyb3VuZCBsYXllcnMgdGhhdCBjYW4gYmUgdXNlZCBmb3Igc3R5bGluZyB3aGVuIHRoZSBoZWFkZXIgaXMgY29uZGVuc2VkXG5vciB3aGVuIHRoZSBzY3JvbGxhYmxlIGVsZW1lbnQgaXMgc2Nyb2xsZWQgdG8gdGhlIHRvcC5cblxuIyMgU2Nyb2xsIGVmZmVjdHNcblxuU2Nyb2xsIGVmZmVjdHMgYXJlIF9vcHRpb25hbF8gdmlzdWFsIGVmZmVjdHMgYXBwbGllZCBpbiBhcHAtaGVhZGVyIGJhc2VkIG9uIHNjcm9sbCBwb3NpdGlvbi4gRm9yIGV4YW1wbGUsXG5UaGUgW01hdGVyaWFsIERlc2lnbiBzY3JvbGxpbmcgdGVjaG5pcXVlc10oaHR0cHM6Ly93d3cuZ29vZ2xlLmNvbS9kZXNpZ24vc3BlYy9wYXR0ZXJucy9zY3JvbGxpbmctdGVjaG5pcXVlcy5odG1sKVxucmVjb21tZW5kcyBlZmZlY3RzIHRoYXQgY2FuIGJlIGluc3RhbGxlZCB2aWEgdGhlIGBlZmZlY3RzYCBwcm9wZXJ0eS4gZS5nLlxuXG5gYGBodG1sXG48YXBwLWhlYWRlciBlZmZlY3RzPVwid2F0ZXJmYWxsXCI+XG4gIDxhcHAtdG9vbGJhcj5BcHAgbmFtZTwvYXBwLXRvb2xiYXI+XG48L2FwcC1oZWFkZXI+XG5gYGBcblxuIyMjIyBJbXBvcnRpbmcgdGhlIGVmZmVjdHNcblxuVG8gdXNlIHRoZSBzY3JvbGwgZWZmZWN0cywgeW91IG11c3QgZXhwbGljaXRseSBpbXBvcnQgdGhlbSBpbiBhZGRpdGlvbiB0byBgYXBwLWhlYWRlcmA6XG5cbmBgYGh0bWxcbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIvYm93ZXJfY29tcG9uZW50cy9hcHAtbGF5b3V0L2FwcC1zY3JvbGwtZWZmZWN0cy9hcHAtc2Nyb2xsLWVmZmVjdHMuaHRtbFwiPlxuYGBgXG5cbiMjIyMgTGlzdCBvZiBlZmZlY3RzXG5cbiogKipibGVuZC1iYWNrZ3JvdW5kKipcbkZhZGVzIGluL291dCB0d28gYmFja2dyb3VuZCBlbGVtZW50cyBieSBhcHBseWluZyBDU1Mgb3BhY2l0eSBiYXNlZCBvbiBzY3JvbGwgcG9zaXRpb24uXG5Zb3UgY2FuIHVzZSB0aGlzIGVmZmVjdCB0byBzbW9vdGhseSBjaGFuZ2UgdGhlIGJhY2tncm91bmQgY29sb3Igb3IgaW1hZ2Ugb2YgdGhlIGhlYWRlci5cbkZvciBleGFtcGxlLCB1c2luZyB0aGUgbWl4aW4gYC0tYXBwLWhlYWRlci1iYWNrZ3JvdW5kLXJlYXItbGF5ZXJgIGxldHMgeW91IGFzc2lnbiBhIGRpZmZlcmVudFxuYmFja2dyb3VuZCB3aGVuIHRoZSBoZWFkZXIgaXMgY29uZGVuc2VkOlxuXG5gYGBjc3NcbmFwcC1oZWFkZXIge1xuICBiYWNrZ3JvdW5kLWNvbG9yOiByZWQ7XG4gIC0tYXBwLWhlYWRlci1iYWNrZ3JvdW5kLXJlYXItbGF5ZXI6IHtcbiAgICAvKiBUaGUgaGVhZGVyIGlzIGJsdWUgd2hlbiBjb25kZW5zZWQgKi9cbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiBibHVlO1xuICB9O1xufVxuYGBgXG5cbiogKipmYWRlLWJhY2tncm91bmQqKlxuVXBvbiBzY3JvbGxpbmcgcGFzdCBhIHRocmVzaG9sZCwgdGhpcyBlZmZlY3Qgd2lsbCB0cmlnZ2VyIGFuIG9wYWNpdHkgdHJhbnNpdGlvbiB0b1xuZmFkZSBpbi9vdXQgdGhlIGJhY2tncm91bmRzLiBDb21wYXJlZCB0byB0aGUgYGJsZW5kLWJhY2tncm91bmRgIGVmZmVjdCxcbnRoaXMgZWZmZWN0IGRvZXNuJ3QgaW50ZXJwb2xhdGUgdGhlIG9wYWNpdHkgYmFzZWQgb24gc2Nyb2xsIHBvc2l0aW9uLlxuXG5cbiogKipwYXJhbGxheC1iYWNrZ3JvdW5kKipcbkEgc2ltcGxlIHBhcmFsbGF4IGVmZmVjdCB0aGF0IHZlcnRpY2FsbHkgdHJhbnNsYXRlcyB0aGUgYmFja2dyb3VuZHMgYmFzZWQgb24gYSBmcmFjdGlvblxub2YgdGhlIHNjcm9sbCBwb3NpdGlvbi4gRm9yIGV4YW1wbGU6XG5cbmBgYGNzc1xuYXBwLWhlYWRlciB7XG4gIC0tYXBwLWhlYWRlci1iYWNrZ3JvdW5kLWZyb250LWxheWVyOiB7XG4gICAgYmFja2dyb3VuZC1pbWFnZTogdXJsKC4uLik7XG4gIH07XG59XG5gYGBcbmBgYGh0bWxcbjxhcHAtaGVhZGVyIHN0eWxlPVwiaGVpZ2h0OiAzMDBweDtcIiBlZmZlY3RzPVwicGFyYWxsYXgtYmFja2dyb3VuZFwiPlxuICA8YXBwLXRvb2xiYXI+QXBwIG5hbWU8L2FwcC10b29sYmFyPlxuPC9hcHAtaGVhZGVyPlxuYGBgXG5cblRoZSBmcmFjdGlvbiBkZXRlcm1pbmVzIGhvdyBmYXIgdGhlIGJhY2tncm91bmQgbW92ZXMgcmVsYXRpdmUgdG8gdGhlIHNjcm9sbCBwb3NpdGlvbi5cblRoaXMgdmFsdWUgY2FuIGJlIGFzc2lnbmVkIHZpYSB0aGUgYHNjYWxhcmAgY29uZmlnIHZhbHVlIGFuZCBpdCBpcyB0eXBpY2FsbHkgYSB2YWx1ZVxuYmV0d2VlbiAwIGFuZCAxIGluY2x1c2l2ZS4gSWYgYHNjYWxhcj0wYCwgdGhlIGJhY2tncm91bmQgZG9lc24ndCBtb3ZlIGF3YXkgZnJvbSB0aGUgaGVhZGVyLlxuXG4qICoqcmVzaXplLXRpdGxlKipcblByb2dyZXNzaXZlbHkgaW50ZXJwb2xhdGVzIHRoZSBzaXplIG9mIHRoZSB0aXRsZSBmcm9tIHRoZSBlbGVtZW50IHdpdGggdGhlIGBtYWluLXRpdGxlYCBhdHRyaWJ1dGVcbnRvIHRoZSBlbGVtZW50IHdpdGggdGhlIGBjb25kZW5zZWQtdGl0bGVgIGF0dHJpYnV0ZSBhcyB0aGUgaGVhZGVyIGNvbmRlbnNlcy4gRm9yIGV4YW1wbGU6XG5cbmBgYGh0bWxcbjxhcHAtaGVhZGVyIGNvbmRlbnNlcyByZXZlYWxzIGVmZmVjdHM9XCJyZXNpemUtdGl0bGVcIj5cbiAgPGFwcC10b29sYmFyPlxuICAgICAgPGg0IGNvbmRlbnNlZC10aXRsZT5BcHAgbmFtZTwvaDQ+XG4gIDwvYXBwLXRvb2xiYXI+XG4gIDxhcHAtdG9vbGJhcj5cbiAgICAgIDxoMSBtYWluLXRpdGxlPkFwcCBuYW1lPC9oMT5cbiAgPC9hcHAtdG9vbGJhcj5cbjwvYXBwLWhlYWRlcj5cbmBgYFxuXG4qICoqcmVzaXplLXNuYXBwZWQtdGl0bGUqKlxuVXBvbiBzY3JvbGxpbmcgcGFzdCBhIHRocmVzaG9sZCwgdGhpcyBlZmZlY3QgZmFkZXMgaW4vb3V0IHRoZSB0aXRsZXMgdXNpbmcgb3BhY2l0eSB0cmFuc2l0aW9ucy5cblNpbWlsYXJseSB0byBgcmVzaXplLXRpdGxlYCwgdGhlIGBtYWluLXRpdGxlYCBhbmQgYGNvbmRlbnNlZC10aXRsZWAgZWxlbWVudHMgbXVzdCBiZSBwbGFjZWQgaW4gdGhlXG5saWdodCBET00uXG5cbiogKip3YXRlcmZhbGwqKlxuVG9nZ2xlcyB0aGUgc2hhZG93IHByb3BlcnR5IGluIGFwcC1oZWFkZXIgdG8gY3JlYXRlIGEgc2Vuc2Ugb2YgZGVwdGggKGFzIHJlY29tbWVuZGVkIGluIHRoZVxuTUQgc3BlYykgYmV0d2VlbiB0aGUgaGVhZGVyIGFuZCB0aGUgdW5kZXJuZWF0aCBjb250ZW50LiBZb3UgY2FuIGNoYW5nZSB0aGUgc2hhZG93IGJ5XG5jdXN0b21pemluZyB0aGUgYC0tYXBwLWhlYWRlci1zaGFkb3dgIG1peGluLiBGb3IgZXhhbXBsZTpcblxuYGBgY3NzXG5hcHAtaGVhZGVyIHtcbiAgLS1hcHAtaGVhZGVyLXNoYWRvdzoge1xuICAgIGJveC1zaGFkb3c6IGluc2V0IDBweCA1cHggMnB4IC0zcHggcmdiYSgwLCAwLCAwLCAwLjIpO1xuICB9O1xufVxuYGBgXG5cbmBgYGh0bWxcbjxhcHAtaGVhZGVyIGNvbmRlbnNlcyByZXZlYWxzIGVmZmVjdHM9XCJ3YXRlcmZhbGxcIj5cbiAgPGFwcC10b29sYmFyPlxuICAgICAgPGgxIG1haW4tdGl0bGU+QXBwIG5hbWU8L2gxPlxuICA8L2FwcC10b29sYmFyPlxuPC9hcHAtaGVhZGVyPlxuYGBgXG5cbiogKiptYXRlcmlhbCoqXG5JbnN0YWxscyB0aGUgd2F0ZXJmYWxsLCByZXNpemUtdGl0bGUsIGJsZW5kLWJhY2tncm91bmQgYW5kIHBhcmFsbGF4LWJhY2tncm91bmQgZWZmZWN0cy5cblxuIyMjIENvbnRlbnQgYXR0cmlidXRlc1xuXG5BdHRyaWJ1dGUgfCBEZXNjcmlwdGlvbiAgICAgICAgIHwgRGVmYXVsdFxuLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tLS0tLS0tLS18LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuYHN0aWNreWAgfCBFbGVtZW50IHRoYXQgcmVtYWlucyBhdCB0aGUgdG9wIHdoZW4gdGhlIGhlYWRlciBjb25kZW5zZXMuIHwgVGhlIGZpcnN0IGFwcC10b29sYmFyIGluIHRoZSBsaWdodCBET00uXG5cblxuIyMgU3R5bGluZ1xuXG5NaXhpbiB8IERlc2NyaXB0aW9uIHwgRGVmYXVsdFxuLS0tLS0tfC0tLS0tLS0tLS0tLS18LS0tLS0tLS0tLVxuYC0tYXBwLWhlYWRlci1iYWNrZ3JvdW5kLWZyb250LWxheWVyYCB8IEFwcGxpZXMgdG8gdGhlIGZyb250IGxheWVyIG9mIHRoZSBiYWNrZ3JvdW5kLiB8IHt9XG5gLS1hcHAtaGVhZGVyLWJhY2tncm91bmQtcmVhci1sYXllcmAgfCBBcHBsaWVzIHRvIHRoZSByZWFyIGxheWVyIG9mIHRoZSBiYWNrZ3JvdW5kLiB8IHt9XG5gLS1hcHAtaGVhZGVyLXNoYWRvd2AgfCBBcHBsaWVzIHRvIHRoZSBzaGFkb3cuIHwge31cblxuQGdyb3VwIEFwcCBFbGVtZW50c1xuQGVsZW1lbnQgYXBwLWhlYWRlclxuQGRlbW8gYXBwLWhlYWRlci9kZW1vL2JsZW5kLWJhY2tncm91bmQtMS5odG1sIEJsZW5kIEJhY2tncm91bmQgSW1hZ2VcbkBkZW1vIGFwcC1oZWFkZXIvZGVtby9ibGVuZC1iYWNrZ3JvdW5kLTIuaHRtbCBCbGVuZCAyIEJhY2tncm91bmQgSW1hZ2VzXG5AZGVtbyBhcHAtaGVhZGVyL2RlbW8vYmxlbmQtYmFja2dyb3VuZC0zLmh0bWwgQmxlbmQgQmFja2dyb3VuZCBDb2xvcnNcbkBkZW1vIGFwcC1oZWFkZXIvZGVtby9jb250YWN0cy5odG1sIENvbnRhY3RzIERlbW9cbkBkZW1vIGFwcC1oZWFkZXIvZGVtby9naXZlLmh0bWwgUmVzaXplIFNuYXBwZWQgVGl0bGUgRGVtb1xuQGRlbW8gYXBwLWhlYWRlci9kZW1vL211c2ljLmh0bWwgUmV2ZWFscyBEZW1vXG5AZGVtbyBhcHAtaGVhZGVyL2RlbW8vbm8tZWZmZWN0cy5odG1sIENvbmRlbnNlcyBhbmQgUmV2ZWFscyBEZW1vXG5AZGVtbyBhcHAtaGVhZGVyL2RlbW8vbm90ZXMuaHRtbCBGaXhlZCB3aXRoIER5bmFtaWMgU2hhZG93IERlbW9cbkBkZW1vIGFwcC1oZWFkZXIvZGVtby9jdXN0b20tc3RpY2t5LWVsZW1lbnQtMS5odG1sIEN1c3RvbSBTdGlja3kgRWxlbWVudCBEZW1vIDFcbkBkZW1vIGFwcC1oZWFkZXIvZGVtby9jdXN0b20tc3RpY2t5LWVsZW1lbnQtMi5odG1sIEN1c3RvbSBTdGlja3kgRWxlbWVudCBEZW1vIDJcblxuLS0+XG5cbjxkb20tbW9kdWxlIGlkPVwiYXBwLWhlYWRlclwiPlxuICA8dGVtcGxhdGU+XG4gICAgPHN0eWxlPlxuICAgICAgOmhvc3Qge1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgICAgICB0cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvbjogbGluZWFyO1xuICAgICAgICB0cmFuc2l0aW9uLXByb3BlcnR5OiAtd2Via2l0LXRyYW5zZm9ybTtcbiAgICAgICAgdHJhbnNpdGlvbi1wcm9wZXJ0eTogdHJhbnNmb3JtO1xuICAgICAgfVxuXG4gICAgICA6aG9zdDo6YmVmb3JlIHtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICByaWdodDogMHB4O1xuICAgICAgICBib3R0b206IC01cHg7XG4gICAgICAgIGxlZnQ6IDBweDtcbiAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgIGhlaWdodDogNXB4O1xuICAgICAgICBjb250ZW50OiBcIlwiO1xuICAgICAgICB0cmFuc2l0aW9uOiBvcGFjaXR5IDAuNHM7XG4gICAgICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xuICAgICAgICBvcGFjaXR5OiAwO1xuICAgICAgICBib3gtc2hhZG93OiBpbnNldCAwcHggNXB4IDZweCAtM3B4IHJnYmEoMCwgMCwgMCwgMC40KTtcbiAgICAgICAgd2lsbC1jaGFuZ2U6IG9wYWNpdHk7XG4gICAgICAgIEBhcHBseSAtLWFwcC1oZWFkZXItc2hhZG93O1xuICAgICAgfVxuXG4gICAgICA6aG9zdChbc2hhZG93XSk6OmJlZm9yZSB7XG4gICAgICAgIG9wYWNpdHk6IDE7XG4gICAgICB9XG5cbiAgICAgICNiYWNrZ3JvdW5kIHtcbiAgICAgICAgQGFwcGx5IC0tbGF5b3V0LWZpdDtcbiAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICAgIH1cblxuICAgICAgI2JhY2tncm91bmRGcm9udExheWVyLFxuICAgICAgI2JhY2tncm91bmRSZWFyTGF5ZXIge1xuICAgICAgICBAYXBwbHkgLS1sYXlvdXQtZml0O1xuICAgICAgICBoZWlnaHQ6IDEwMCU7XG4gICAgICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xuICAgICAgICBiYWNrZ3JvdW5kLXNpemU6IGNvdmVyO1xuICAgICAgfVxuXG4gICAgICAjYmFja2dyb3VuZEZyb250TGF5ZXIge1xuICAgICAgICBAYXBwbHkgLS1hcHAtaGVhZGVyLWJhY2tncm91bmQtZnJvbnQtbGF5ZXI7XG4gICAgICB9XG5cbiAgICAgICNiYWNrZ3JvdW5kUmVhckxheWVyIHtcbiAgICAgICAgb3BhY2l0eTogMDtcbiAgICAgICAgQGFwcGx5IC0tYXBwLWhlYWRlci1iYWNrZ3JvdW5kLXJlYXItbGF5ZXI7XG4gICAgICB9XG5cbiAgICAgICNjb250ZW50Q29udGFpbmVyIHtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgaGVpZ2h0OiAxMDAlO1xuICAgICAgfVxuXG4gICAgICA6aG9zdChbZGlzYWJsZWRdKSxcbiAgICAgIDpob3N0KFtkaXNhYmxlZF0pOjphZnRlcixcbiAgICAgIDpob3N0KFtkaXNhYmxlZF0pICNiYWNrZ3JvdW5kRnJvbnRMYXllcixcbiAgICAgIDpob3N0KFtkaXNhYmxlZF0pICNiYWNrZ3JvdW5kUmVhckxheWVyLFxuICAgICAgLyogU2lsZW50IHNjcm9sbGluZyBzaG91bGQgbm90IHJ1biBDU1MgdHJhbnNpdGlvbnMgKi9cbiAgICAgIDpob3N0KFtzaWxlbnQtc2Nyb2xsXSksXG4gICAgICA6aG9zdChbc2lsZW50LXNjcm9sbF0pOjphZnRlcixcbiAgICAgIDpob3N0KFtzaWxlbnQtc2Nyb2xsXSkgI2JhY2tncm91bmRGcm9udExheWVyLFxuICAgICAgOmhvc3QoW3NpbGVudC1zY3JvbGxdKSAjYmFja2dyb3VuZFJlYXJMYXllciB7XG4gICAgICAgIHRyYW5zaXRpb246IG5vbmUgIWltcG9ydGFudDtcbiAgICAgIH1cblxuICAgICAgOmhvc3QoW2Rpc2FibGVkXSkgOjpzbG90dGVkKGFwcC10b29sYmFyOmZpcnN0LW9mLXR5cGUpLFxuICAgICAgOmhvc3QoW2Rpc2FibGVkXSkgOjpzbG90dGVkKFtzdGlja3ldKSxcbiAgICAgIC8qIFNpbGVudCBzY3JvbGxpbmcgc2hvdWxkIG5vdCBydW4gQ1NTIHRyYW5zaXRpb25zICovXG4gICAgICA6aG9zdChbc2lsZW50LXNjcm9sbF0pIDo6c2xvdHRlZChhcHAtdG9vbGJhcjpmaXJzdC1vZi10eXBlKSxcbiAgICAgIDpob3N0KFtzaWxlbnQtc2Nyb2xsXSkgOjpzbG90dGVkKFtzdGlja3ldKSB7XG4gICAgICAgIHRyYW5zaXRpb246IG5vbmUgIWltcG9ydGFudDtcbiAgICAgIH1cblxuICAgIDwvc3R5bGU+XG4gICAgPGRpdiBpZD1cImNvbnRlbnRDb250YWluZXJcIj5cbiAgICAgIDxzbG90IGlkPVwic2xvdFwiPjwvc2xvdD5cbiAgICA8L2Rpdj5cbiAgPC90ZW1wbGF0ZT5cblxuICA8c2NyaXB0PlxuICAgIFBvbHltZXIoe1xuICAgICAgaXM6ICdhcHAtaGVhZGVyJyxcblxuICAgICAgYmVoYXZpb3JzOiBbXG4gICAgICAgIFBvbHltZXIuQXBwU2Nyb2xsRWZmZWN0c0JlaGF2aW9yLFxuICAgICAgICBQb2x5bWVyLkFwcExheW91dEJlaGF2aW9yXG4gICAgICBdLFxuXG4gICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0cnVlLCB0aGUgaGVhZGVyIHdpbGwgYXV0b21hdGljYWxseSBjb2xsYXBzZSB3aGVuIHNjcm9sbGluZyBkb3duLlxuICAgICAgICAgKiBUaGF0IGlzLCB0aGUgYHN0aWNreWAgZWxlbWVudCByZW1haW5zIHZpc2libGUgd2hlbiB0aGUgaGVhZGVyIGlzIGZ1bGx5IGNvbmRlbnNlZFxuICAgICAgICAgKiB3aGVyZWFzIHRoZSByZXN0IG9mIHRoZSBlbGVtZW50cyB3aWxsIGNvbGxhcHNlIGJlbG93IGBzdGlja3lgIGVsZW1lbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEJ5IGRlZmF1bHQsIHRoZSBgc3RpY2t5YCBlbGVtZW50IGlzIHRoZSBmaXJzdCB0b29sYmFyIGluIHRoZSBsaWdodCBET006XG4gICAgICAgICAqXG4gICAgICAgICAqYGBgaHRtbFxuICAgICAgICAgKiA8YXBwLWhlYWRlciBjb25kZW5zZXM+XG4gICAgICAgICAqICAgPGFwcC10b29sYmFyPlRoaXMgdG9vbGJhciByZW1haW5zIG9uIHRvcDwvYXBwLXRvb2xiYXI+XG4gICAgICAgICAqICAgPGFwcC10b29sYmFyPjwvYXBwLXRvb2xiYXI+XG4gICAgICAgICAqICAgPGFwcC10b29sYmFyPjwvYXBwLXRvb2xiYXI+XG4gICAgICAgICAqIDwvYXBwLWhlYWRlcj5cbiAgICAgICAgICogYGBgXG4gICAgICAgICAqXG4gICAgICAgICAqIEFkZGl0aW9uYWxseSwgeW91IGNhbiBzcGVjaWZ5IHdoaWNoIHRvb2xiYXIgb3IgZWxlbWVudCByZW1haW5zIHZpc2libGUgaW4gY29uZGVuc2VkIG1vZGVcbiAgICAgICAgICogYnkgYWRkaW5nIHRoZSBgc3RpY2t5YCBhdHRyaWJ1dGUgdG8gdGhhdCBlbGVtZW50LiBGb3IgZXhhbXBsZTogaWYgd2Ugd2FudCB0aGUgbGFzdFxuICAgICAgICAgKiB0b29sYmFyIHRvIHJlbWFpbiB2aXNpYmxlLCB3ZSBjYW4gYWRkIHRoZSBgc3RpY2t5YCBhdHRyaWJ1dGUgdG8gaXQuXG4gICAgICAgICAqXG4gICAgICAgICAqYGBgaHRtbFxuICAgICAgICAgKiA8YXBwLWhlYWRlciBjb25kZW5zZXM+XG4gICAgICAgICAqICAgPGFwcC10b29sYmFyPjwvYXBwLXRvb2xiYXI+XG4gICAgICAgICAqICAgPGFwcC10b29sYmFyPjwvYXBwLXRvb2xiYXI+XG4gICAgICAgICAqICAgPGFwcC10b29sYmFyIHN0aWNreT5UaGlzIHRvb2xiYXIgcmVtYWlucyBvbiB0b3A8L2FwcC10b29sYmFyPlxuICAgICAgICAgKiA8L2FwcC1oZWFkZXI+XG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKlxuICAgICAgICAgKiBOb3RlIHRoZSBgc3RpY2t5YCBlbGVtZW50IG11c3QgYmUgYSBkaXJlY3QgY2hpbGQgb2YgYGFwcC1oZWFkZXJgLlxuICAgICAgICAgKi9cbiAgICAgICAgY29uZGVuc2VzOiB7XG4gICAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogTWFudGFpbnMgdGhlIGhlYWRlciBmaXhlZCBhdCB0aGUgdG9wIHNvIGl0IG5ldmVyIG1vdmVzIGF3YXkuXG4gICAgICAgICAqL1xuICAgICAgICBmaXhlZDoge1xuICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNsaWRlcyBiYWNrIHRoZSBoZWFkZXIgd2hlbiBzY3JvbGxpbmcgYmFjayB1cC5cbiAgICAgICAgICovXG4gICAgICAgIHJldmVhbHM6IHtcbiAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEaXNwbGF5cyBhIHNoYWRvdyBiZWxvdyB0aGUgaGVhZGVyLlxuICAgICAgICAgKi9cbiAgICAgICAgc2hhZG93OiB7XG4gICAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgICByZWZsZWN0VG9BdHRyaWJ1dGU6IHRydWUsXG4gICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIG9ic2VydmVyczogW1xuICAgICAgICAnX2NvbmZpZ0NoYW5nZWQoaXNBdHRhY2hlZCwgY29uZGVuc2VzLCBmaXhlZCknXG4gICAgICBdLFxuXG4gICAgICAvKipcbiAgICAgICAqIEEgY2FjaGVkIG9mZnNldEhlaWdodCBvZiB0aGUgY3VycmVudCBlbGVtZW50LlxuICAgICAgICpcbiAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgKi9cbiAgICAgIF9oZWlnaHQ6IDAsXG5cbiAgICAgIC8qKlxuICAgICAgICogVGhlIGRpc3RhbmNlIGluIHBpeGVscyB0aGUgaGVhZGVyIHdpbGwgYmUgdHJhbnNsYXRlZCB0byB3aGVuIHNjcm9sbGluZy5cbiAgICAgICAqXG4gICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICovXG4gICAgICBfZEhlaWdodDogMCxcblxuICAgICAgLyoqXG4gICAgICAgKiBUaGUgb2Zmc2V0VG9wIG9mIGBfc3RpY2t5RWxgXG4gICAgICAgKlxuICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAqL1xuICAgICAgX3N0aWNreUVsVG9wOiAwLFxuXG4gICAgICAvKipcbiAgICAgICAqIEEgcmVmZXJlbmNlIHRvIHRoZSBlbGVtZW50IHRoYXQgcmVtYWlucyB2aXNpYmxlIHdoZW4gdGhlIGhlYWRlciBjb25kZW5zZXMuXG4gICAgICAgKlxuICAgICAgICogQHR5cGUge0hUTUxFbGVtZW50fVxuICAgICAgICovXG4gICAgICBfc3RpY2t5RWxSZWY6IG51bGwsXG5cbiAgICAgIC8qKlxuICAgICAgICogVGhlIGhlYWRlcidzIHRvcCB2YWx1ZSB1c2VkIGZvciB0aGUgYHRyYW5zZm9ybVlgXG4gICAgICAgKlxuICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAqL1xuICAgICAgX3RvcDogMCxcblxuICAgICAgLyoqXG4gICAgICAgKiBUaGUgY3VycmVudCBzY3JvbGwgcHJvZ3Jlc3MuXG4gICAgICAgKlxuICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAqL1xuICAgICAgX3Byb2dyZXNzOiAwLFxuXG4gICAgICBfd2FzU2Nyb2xsaW5nRG93bjogZmFsc2UsXG4gICAgICBfaW5pdFNjcm9sbFRvcDogMCxcbiAgICAgIF9pbml0VGltZXN0YW1wOiAwLFxuICAgICAgX2xhc3RUaW1lc3RhbXA6IDAsXG4gICAgICBfbGFzdFNjcm9sbFRvcDogMCxcblxuICAgICAgLyoqXG4gICAgICAgKiBUaGUgZGlzdGFuY2UgdGhlIGhlYWRlciBpcyBhbGxvd2VkIHRvIG1vdmUgYXdheS5cbiAgICAgICAqXG4gICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICovXG4gICAgICBnZXQgX21heEhlYWRlclRvcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZml4ZWQgPyB0aGlzLl9kSGVpZ2h0IDogdGhpcy5faGVpZ2h0ICsgNTtcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogUmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgc3RpY2t5IGVsZW1lbnQuXG4gICAgICAgKlxuICAgICAgICogQHJldHVybiB7SFRNTEVsZW1lbnR9P1xuICAgICAgICovXG4gICAgICBnZXQgX3N0aWNreUVsKCkge1xuICAgICAgICBpZiAodGhpcy5fc3RpY2t5RWxSZWYpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fc3RpY2t5RWxSZWY7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5vZGVzID0gUG9seW1lci5kb20odGhpcy4kLnNsb3QpLmdldERpc3RyaWJ1dGVkTm9kZXMoKTtcbiAgICAgICAgLy8gR2V0IHRoZSBlbGVtZW50IHdpdGggdGhlIHN0aWNreSBhdHRyaWJ1dGUgb24gaXQgb3IgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIGxpZ2h0IERPTS5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG5vZGU7IG5vZGUgPSBub2Rlc1tpXTsgaSsrKSB7XG4gICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5oYXNBdHRyaWJ1dGUoJ3N0aWNreScpKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3N0aWNreUVsUmVmID0gbm9kZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLl9zdGlja3lFbFJlZikge1xuICAgICAgICAgICAgICB0aGlzLl9zdGlja3lFbFJlZiA9IG5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGlja3lFbFJlZjtcbiAgICAgIH0sXG5cbiAgICAgIF9jb25maWdDaGFuZ2VkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5yZXNldExheW91dCgpO1xuICAgICAgICB0aGlzLl9ub3RpZnlMYXlvdXRDaGFuZ2VkKCk7XG4gICAgICB9LFxuXG4gICAgICBfdXBkYXRlTGF5b3V0U3RhdGVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMub2Zmc2V0V2lkdGggPT09IDAgJiYgdGhpcy5vZmZzZXRIZWlnaHQgPT09IDApIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNjcm9sbFRvcCA9IHRoaXMuX2NsYW1wZWRTY3JvbGxUb3A7XG4gICAgICAgIHZhciBmaXJzdFNldHVwID0gdGhpcy5faGVpZ2h0ID09PSAwIHx8IHNjcm9sbFRvcCA9PT0gMDtcbiAgICAgICAgdmFyIGN1cnJlbnREaXNhYmxlZCA9IHRoaXMuZGlzYWJsZWQ7XG4gICAgICAgIHRoaXMuX2hlaWdodCA9IHRoaXMub2Zmc2V0SGVpZ2h0O1xuICAgICAgICB0aGlzLl9zdGlja3lFbFJlZiA9IG51bGw7XG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICAvLyBwcmVwYXJlIGZvciBtZWFzdXJlbWVudFxuICAgICAgICBpZiAgKCFmaXJzdFNldHVwKSB7XG4gICAgICAgICAgdGhpcy5fdXBkYXRlU2Nyb2xsU3RhdGUoMCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX21heU1vdmUoKSkge1xuICAgICAgICAgIHRoaXMuX2RIZWlnaHQgPSB0aGlzLl9zdGlja3lFbCA/IHRoaXMuX2hlaWdodCAtIHRoaXMuX3N0aWNreUVsLm9mZnNldEhlaWdodCA6IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fZEhlaWdodCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc3RpY2t5RWxUb3AgPSB0aGlzLl9zdGlja3lFbCA/IHRoaXMuX3N0aWNreUVsLm9mZnNldFRvcCA6IDA7XG4gICAgICAgIHRoaXMuX3NldFVwRWZmZWN0KCk7XG4gICAgICAgIGlmIChmaXJzdFNldHVwKSB7XG4gICAgICAgICAgdGhpcy5fdXBkYXRlU2Nyb2xsU3RhdGUoc2Nyb2xsVG9wLCB0cnVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl91cGRhdGVTY3JvbGxTdGF0ZSh0aGlzLl9sYXN0U2Nyb2xsVG9wLCB0cnVlKTtcbiAgICAgICAgICB0aGlzLl9sYXlvdXRJZkRpcnR5KCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVzdG9yZSBubyB0cmFuc2l0aW9uXG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSBjdXJyZW50RGlzYWJsZWQ7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFVwZGF0ZXMgdGhlIHNjcm9sbCBzdGF0ZS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0gc2Nyb2xsVG9wXG4gICAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBmb3JjZVVwZGF0ZSAoZGVmYXVsdDogZmFsc2UpXG4gICAgICAgKi9cbiAgICAgIF91cGRhdGVTY3JvbGxTdGF0ZTogZnVuY3Rpb24oc2Nyb2xsVG9wLCBmb3JjZVVwZGF0ZSkge1xuICAgICAgICBpZiAodGhpcy5faGVpZ2h0ID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwcm9ncmVzcyA9IDA7XG4gICAgICAgIHZhciB0b3AgPSAwO1xuICAgICAgICB2YXIgbGFzdFRvcCA9IHRoaXMuX3RvcDtcbiAgICAgICAgdmFyIGxhc3RTY3JvbGxUb3AgPSB0aGlzLl9sYXN0U2Nyb2xsVG9wO1xuICAgICAgICB2YXIgbWF4SGVhZGVyVG9wID0gdGhpcy5fbWF4SGVhZGVyVG9wO1xuICAgICAgICB2YXIgZFNjcm9sbFRvcCA9IHNjcm9sbFRvcCAtIHRoaXMuX2xhc3RTY3JvbGxUb3A7XG4gICAgICAgIHZhciBhYnNEU2Nyb2xsVG9wID0gTWF0aC5hYnMoZFNjcm9sbFRvcCk7XG4gICAgICAgIHZhciBpc1Njcm9sbGluZ0Rvd24gPSBzY3JvbGxUb3AgPiB0aGlzLl9sYXN0U2Nyb2xsVG9wO1xuICAgICAgICB2YXIgbm93ID0gcGVyZm9ybWFuY2Uubm93KCk7XG5cbiAgICAgICAgaWYgKHRoaXMuX21heU1vdmUoKSkge1xuICAgICAgICAgIHRvcCA9IHRoaXMuX2NsYW1wKHRoaXMucmV2ZWFscyA/IGxhc3RUb3AgKyBkU2Nyb2xsVG9wIDogc2Nyb2xsVG9wLCAwLCBtYXhIZWFkZXJUb3ApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzY3JvbGxUb3AgPj0gdGhpcy5fZEhlaWdodCkge1xuICAgICAgICAgIHRvcCA9IHRoaXMuY29uZGVuc2VzICYmICF0aGlzLmZpeGVkID8gTWF0aC5tYXgodGhpcy5fZEhlaWdodCwgdG9wKSA6IHRvcDtcbiAgICAgICAgICB0aGlzLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9ICcwbXMnO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnJldmVhbHMgJiYgIXRoaXMuZGlzYWJsZWQgJiYgYWJzRFNjcm9sbFRvcCA8IDEwMCkge1xuICAgICAgICAgIC8vIHNldCB0aGUgaW5pdGlhbCBzY3JvbGwgcG9zaXRpb25cbiAgICAgICAgICBpZiAobm93IC0gdGhpcy5faW5pdFRpbWVzdGFtcCA+IDMwMCB8fCB0aGlzLl93YXNTY3JvbGxpbmdEb3duICE9PSBpc1Njcm9sbGluZ0Rvd24pIHtcbiAgICAgICAgICAgIHRoaXMuX2luaXRTY3JvbGxUb3AgPSBzY3JvbGxUb3A7XG4gICAgICAgICAgICB0aGlzLl9pbml0VGltZXN0YW1wID0gbm93O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc2Nyb2xsVG9wID49IG1heEhlYWRlclRvcCkge1xuICAgICAgICAgICAgLy8gY2hlY2sgaWYgdGhlIGhlYWRlciBpcyBhbGxvd2VkIHRvIHNuYXBcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyh0aGlzLl9pbml0U2Nyb2xsVG9wIC0gc2Nyb2xsVG9wKSA+IDMwIHx8IGFic0RTY3JvbGxUb3AgPiAxMCkge1xuICAgICAgICAgICAgICBpZiAoaXNTY3JvbGxpbmdEb3duICYmIHNjcm9sbFRvcCA+PSBtYXhIZWFkZXJUb3ApIHtcbiAgICAgICAgICAgICAgICB0b3AgPSBtYXhIZWFkZXJUb3A7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWlzU2Nyb2xsaW5nRG93biAmJiBzY3JvbGxUb3AgPj0gdGhpcy5fZEhlaWdodCkge1xuICAgICAgICAgICAgICAgIHRvcCA9IHRoaXMuY29uZGVuc2VzICYmICF0aGlzLmZpeGVkID8gdGhpcy5fZEhlaWdodCA6IDA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFyIHNjcm9sbFZlbG9jaXR5ID0gZFNjcm9sbFRvcCAvIChub3cgLSB0aGlzLl9sYXN0VGltZXN0YW1wKTtcbiAgICAgICAgICAgICAgdGhpcy5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPSB0aGlzLl9jbGFtcCgodG9wIC0gbGFzdFRvcCkgLyBzY3JvbGxWZWxvY2l0eSwgMCwgMzAwKSArICdtcyc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0b3AgPSB0aGlzLl90b3A7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9kSGVpZ2h0ID09PSAwKSB7XG4gICAgICAgICAgcHJvZ3Jlc3MgPSBzY3JvbGxUb3AgPiAwID8gMSA6IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJvZ3Jlc3MgPSB0b3AgLyB0aGlzLl9kSGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIGlmICghZm9yY2VVcGRhdGUpIHtcbiAgICAgICAgICB0aGlzLl9sYXN0U2Nyb2xsVG9wID0gc2Nyb2xsVG9wO1xuICAgICAgICAgIHRoaXMuX3RvcCA9IHRvcDtcbiAgICAgICAgICB0aGlzLl93YXNTY3JvbGxpbmdEb3duID0gaXNTY3JvbGxpbmdEb3duO1xuICAgICAgICAgIHRoaXMuX2xhc3RUaW1lc3RhbXAgPSBub3c7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvcmNlVXBkYXRlIHx8IHByb2dyZXNzICE9PSB0aGlzLl9wcm9ncmVzcyB8fCBsYXN0VG9wICE9PSB0b3AgfHwgc2Nyb2xsVG9wID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5fcHJvZ3Jlc3MgPSBwcm9ncmVzcztcbiAgICAgICAgICB0aGlzLl9ydW5FZmZlY3RzKHByb2dyZXNzLCB0b3ApO1xuICAgICAgICAgIHRoaXMuX3RyYW5zZm9ybUhlYWRlcih0b3ApO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgY3VycmVudCBoZWFkZXIgaXMgYWxsb3dlZCB0byBtb3ZlIGFzIHRoZSB1c2VyIHNjcm9sbHMuXG4gICAgICAgKlxuICAgICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgICAqL1xuICAgICAgX21heU1vdmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25kZW5zZXMgfHwgIXRoaXMuZml4ZWQ7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgY3VycmVudCBoZWFkZXIgd2lsbCBjb25kZW5zZSBiYXNlZCBvbiB0aGUgc2l6ZSBvZiB0aGUgaGVhZGVyXG4gICAgICAgKiBhbmQgdGhlIGBjb25zZW5zZXNgIHByb3BlcnR5LlxuICAgICAgICpcbiAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICAgKi9cbiAgICAgIHdpbGxDb25kZW5zZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kSGVpZ2h0ID4gMCAmJiB0aGlzLmNvbmRlbnNlcztcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBjdXJyZW50IGVsZW1lbnQgaXMgb24gdGhlIHNjcmVlbi5cbiAgICAgICAqIFRoYXQgaXMsIHZpc2libGUgaW4gdGhlIGN1cnJlbnQgdmlld3BvcnQuXG4gICAgICAgKlxuICAgICAgICogQG1ldGhvZCBpc09uU2NyZWVuXG4gICAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAgICovXG4gICAgICBpc09uU2NyZWVuOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hlaWdodCAhPT0gMCAmJiB0aGlzLl90b3AgPCB0aGlzLl9oZWlnaHQ7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGVyZSdzIGNvbnRlbnQgYmVsb3cgdGhlIGN1cnJlbnQgZWxlbWVudC5cbiAgICAgICAqXG4gICAgICAgKiBAbWV0aG9kIGlzQ29udGVudEJlbG93XG4gICAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAgICovXG4gICAgICBpc0NvbnRlbnRCZWxvdzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90b3AgPT09IDAgPyB0aGlzLl9jbGFtcGVkU2Nyb2xsVG9wID4gMCA6XG4gICAgICAgICAgICB0aGlzLl9jbGFtcGVkU2Nyb2xsVG9wIC0gdGhpcy5fbWF4SGVhZGVyVG9wID49IDA7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFRyYW5zZm9ybXMgdGhlIGhlYWRlci5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgICAgICovXG4gICAgICBfdHJhbnNmb3JtSGVhZGVyOiBmdW5jdGlvbih5KSB7XG4gICAgICAgIHRoaXMudHJhbnNsYXRlM2QoMCwgKC15KSArICdweCcsIDApO1xuICAgICAgICBpZiAodGhpcy5fc3RpY2t5RWwpIHtcbiAgICAgICAgICB0aGlzLnRyYW5zbGF0ZTNkKDAsIHRoaXMuY29uZGVuc2VzICYmIHkgPj0gdGhpcy5fc3RpY2t5RWxUb3AgP1xuICAgICAgICAgICAgICAoTWF0aC5taW4oeSwgdGhpcy5fZEhlaWdodCkgLSB0aGlzLl9zdGlja3lFbFRvcCkgKyAncHgnIDogMCwgIDAsIHRoaXMuX3N0aWNreUVsKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgX2NsYW1wOiBmdW5jdGlvbih2LCBtaW4sIG1heCkge1xuICAgICAgICByZXR1cm4gTWF0aC5taW4obWF4LCBNYXRoLm1heChtaW4sIHYpKTtcbiAgICAgIH0sXG5cbiAgICAgIF9lbnN1cmVCZ0NvbnRhaW5lcnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2JnQ29udGFpbmVyKSB7XG4gICAgICAgICAgdGhpcy5fYmdDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICB0aGlzLl9iZ0NvbnRhaW5lci5pZCA9ICdiYWNrZ3JvdW5kJztcbiAgICAgICAgICB0aGlzLl9iZ1JlYXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICB0aGlzLl9iZ1JlYXIuaWQgPSAnYmFja2dyb3VuZFJlYXJMYXllcic7XG4gICAgICAgICAgdGhpcy5fYmdDb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5fYmdSZWFyKTtcbiAgICAgICAgICB0aGlzLl9iZ0Zyb250ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgdGhpcy5fYmdGcm9udC5pZCA9ICdiYWNrZ3JvdW5kRnJvbnRMYXllcic7XG4gICAgICAgICAgdGhpcy5fYmdDb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5fYmdGcm9udCk7XG4gICAgICAgICAgUG9seW1lci5kb20odGhpcy5yb290KS5pbnNlcnRCZWZvcmUodGhpcy5fYmdDb250YWluZXIsIHRoaXMuJC5jb250ZW50Q29udGFpbmVyKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgX2dldERPTVJlZjogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgc3dpdGNoIChpZCkge1xuICAgICAgICAgIGNhc2UgJ2JhY2tncm91bmRGcm9udExheWVyJzpcbiAgICAgICAgICAgIHRoaXMuX2Vuc3VyZUJnQ29udGFpbmVycygpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2JnRnJvbnQ7XG4gICAgICAgICAgY2FzZSAnYmFja2dyb3VuZFJlYXJMYXllcic6XG4gICAgICAgICAgICB0aGlzLl9lbnN1cmVCZ0NvbnRhaW5lcnMoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9iZ1JlYXI7XG4gICAgICAgICAgY2FzZSAnYmFja2dyb3VuZCc6XG4gICAgICAgICAgICB0aGlzLl9lbnN1cmVCZ0NvbnRhaW5lcnMoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9iZ0NvbnRhaW5lcjtcbiAgICAgICAgICBjYXNlICdtYWluVGl0bGUnOlxuICAgICAgICAgICAgcmV0dXJuIFBvbHltZXIuZG9tKHRoaXMpLnF1ZXJ5U2VsZWN0b3IoJ1ttYWluLXRpdGxlXScpO1xuICAgICAgICAgIGNhc2UgJ2NvbmRlbnNlZFRpdGxlJzpcbiAgICAgICAgICAgIHJldHVybiBQb2x5bWVyLmRvbSh0aGlzKS5xdWVyeVNlbGVjdG9yKCdbY29uZGVuc2VkLXRpdGxlXScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBSZXR1cm5zIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSBwcm9ncmVzcyB2YWx1ZSBvZiB0aGUgc2Nyb2xsIGVmZmVjdHNcbiAgICAgICAqIGFuZCB0aGUgdG9wIHBvc2l0aW9uIG9mIHRoZSBoZWFkZXIuXG4gICAgICAgKlxuICAgICAgICogQG1ldGhvZCBnZXRTY3JvbGxTdGF0ZVxuICAgICAgICogQHJldHVybiB7T2JqZWN0fVxuICAgICAgICovXG4gICAgICBnZXRTY3JvbGxTdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB7IHByb2dyZXNzOiB0aGlzLl9wcm9ncmVzcywgdG9wOiB0aGlzLl90b3AgfTtcbiAgICAgIH1cbiAgICB9KTtcbiAgPC9zY3JpcHQ+XG48L2RvbS1tb2R1bGU+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL2FwcC1sYXlvdXQvYXBwLWhlYWRlci9hcHAtaGVhZGVyLmh0bWwiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi8uLi9wb2x5bWVyL3BvbHltZXIuaHRtbFwiPlxuXG48c2NyaXB0PlxuICBQb2x5bWVyLkFwcExheW91dCA9IFBvbHltZXIuQXBwTGF5b3V0IHx8IHt9O1xuXG4gIFBvbHltZXIuQXBwTGF5b3V0Ll9zY3JvbGxFZmZlY3RzID0gUG9seW1lci5BcHBMYXlvdXQuX3Njcm9sbEVmZmVjdHMgfHwge307XG5cbiAgUG9seW1lci5BcHBMYXlvdXQuc2Nyb2xsVGltaW5nRnVuY3Rpb24gPSBmdW5jdGlvbiBlYXNlT3V0UXVhZCh0LCBiLCBjLCBkKSB7XG4gICAgdCAvPSBkO1xuICAgIHJldHVybiAtYyAqIHQqKHQtMikgKyBiO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgYSBzY3JvbGwgZWZmZWN0IHRvIGJlIHVzZWQgaW4gZWxlbWVudHMgdGhhdCBpbXBsZW1lbnQgdGhlXG4gICAqIGBQb2x5bWVyLkFwcFNjcm9sbEVmZmVjdHNCZWhhdmlvcmAgYmVoYXZpb3IuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBlZmZlY3ROYW1lIFRoZSBlZmZlY3QgbmFtZS5cbiAgICogQHBhcmFtIHtPYmplY3R9IGVmZmVjdERlZiBUaGUgZWZmZWN0IGRlZmluaXRpb24uXG4gICAqL1xuICBQb2x5bWVyLkFwcExheW91dC5yZWdpc3RlckVmZmVjdCA9IGZ1bmN0aW9uIHJlZ2lzdGVyRWZmZWN0KGVmZmVjdE5hbWUsIGVmZmVjdERlZikge1xuICAgIGlmIChQb2x5bWVyLkFwcExheW91dC5fc2Nyb2xsRWZmZWN0c1tlZmZlY3ROYW1lXSAhPSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2VmZmVjdCBgJysgZWZmZWN0TmFtZSArICdgIGlzIGFscmVhZHkgcmVnaXN0ZXJlZC4nKTtcbiAgICB9XG4gICAgUG9seW1lci5BcHBMYXlvdXQuX3Njcm9sbEVmZmVjdHNbZWZmZWN0TmFtZV0gPSBlZmZlY3REZWY7XG4gIH07XG5cblxuICBQb2x5bWVyLkFwcExheW91dC5xdWVyeUFsbFJvb3QgPSBmdW5jdGlvbihzZWxlY3Rvciwgcm9vdCkge1xuICAgIHZhciBxdWV1ZSA9IFtyb290XTtcbiAgICB2YXIgbWF0Y2hlcyA9IFtdO1xuXG4gICAgd2hpbGUgKHF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgIHZhciBub2RlID0gcXVldWUuc2hpZnQoKTtcbiAgICAgIG1hdGNoZXMucHVzaC5hcHBseShtYXRjaGVzLCBub2RlLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpKTtcbiAgICAgIGZvciAoaSA9IDA7IG5vZGUuY2hpbGRyZW5baV07IGkrKykge1xuICAgICAgICBpZiAobm9kZS5jaGlsZHJlbltpXS5zaGFkb3dSb290KSB7XG4gICAgICAgICAgcXVldWUucHVzaChub2RlLmNoaWxkcmVuW2ldLnNoYWRvd1Jvb3QpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtYXRjaGVzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTY3JvbGxzIHRvIGEgcGFydGljdWxhciBzZXQgb2YgY29vcmRpbmF0ZXMgaW4gYSBzY3JvbGwgdGFyZ2V0LlxuICAgKiBJZiB0aGUgc2Nyb2xsIHRhcmdldCBpcyBub3QgZGVmaW5lZCwgdGhlbiBpdCB3b3VsZCB1c2UgdGhlIG1haW4gZG9jdW1lbnQgYXMgdGhlIHRhcmdldC5cbiAgICpcbiAgICogVG8gc2Nyb2xsIGluIGEgc21vb3RoIGZhc2hpb24sIHlvdSBjYW4gc2V0IHRoZSBvcHRpb24gYGJlaGF2aW9yOiAnc21vb3RoJ2AuIGUuZy5cbiAgICpcbiAgICogYGBganNcbiAgICogUG9seW1lci5BcHBMYXlvdXQuc2Nyb2xsKHt0b3A6IDAsIGJlaGF2aW9yOiAnc21vb3RoJ30pO1xuICAgKiBgYGBcbiAgICpcbiAgICogVG8gc2Nyb2xsIGluIGEgc2lsZW50IG1vZGUsIHdpdGhvdXQgbm90aWZ5aW5nIHNjcm9sbCBjaGFuZ2VzIHRvIGFueSBhcHAtbGF5b3V0IGVsZW1lbnRzLFxuICAgKiB5b3UgY2FuIHNldCB0aGUgb3B0aW9uIGBiZWhhdmlvcjogJ3NpbGVudCdgLiBUaGlzIGlzIHBhcnRpY3VsYXJseSB1c2VmdWwgd2UgeW91IGFyZSB1c2luZ1xuICAgKiBgYXBwLWhlYWRlcmAgYW5kIHlvdSBkZXNpcmUgdG8gc2Nyb2xsIHRvIHRoZSB0b3Agb2YgYSBzY3JvbGxpbmcgcmVnaW9uIHdpdGhvdXQgcnVubmluZ1xuICAgKiBzY3JvbGwgZWZmZWN0cy4gZS5nLlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiBQb2x5bWVyLkFwcExheW91dC5zY3JvbGwoe3RvcDogMCwgYmVoYXZpb3I6ICdzaWxlbnQnfSk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyB7dG9wOiBOdW1iZXIsIGxlZnQ6IE51bWJlciwgYmVoYXZpb3I6IFN0cmluZyhzbW9vdGggfCBzaWxlbnQpfVxuICAgKi9cbiAgUG9seW1lci5BcHBMYXlvdXQuc2Nyb2xsID0gZnVuY3Rpb24gc2Nyb2xsKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIHZhciBkb2NFbCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICB2YXIgdGFyZ2V0ID0gb3B0aW9ucy50YXJnZXQgfHwgZG9jRWw7XG4gICAgdmFyIGhhc05hdGl2ZVNjcm9sbEJlaGF2aW9yID0gJ3Njcm9sbEJlaGF2aW9yJyBpbiB0YXJnZXQuc3R5bGUgJiYgdGFyZ2V0LnNjcm9sbDtcbiAgICB2YXIgc2Nyb2xsQ2xhc3NOYW1lID0gJ2FwcC1sYXlvdXQtc2lsZW50LXNjcm9sbCc7XG4gICAgdmFyIHNjcm9sbFRvcCA9IG9wdGlvbnMudG9wIHx8IDA7XG4gICAgdmFyIHNjcm9sbExlZnQgPSBvcHRpb25zLmxlZnQgfHwgMDtcbiAgICB2YXIgc2Nyb2xsVG8gPSB0YXJnZXQgPT09IGRvY0VsID8gd2luZG93LnNjcm9sbFRvIDpcbiAgICAgIGZ1bmN0aW9uIHNjcm9sbFRvKHNjcm9sbExlZnQsIHNjcm9sbFRvcCkge1xuICAgICAgICB0YXJnZXQuc2Nyb2xsTGVmdCA9IHNjcm9sbExlZnQ7XG4gICAgICAgIHRhcmdldC5zY3JvbGxUb3AgPSBzY3JvbGxUb3A7XG4gICAgICB9O1xuXG4gICAgaWYgKG9wdGlvbnMuYmVoYXZpb3IgPT09ICdzbW9vdGgnKSB7XG5cbiAgICAgIGlmIChoYXNOYXRpdmVTY3JvbGxCZWhhdmlvcikge1xuXG4gICAgICAgIHRhcmdldC5zY3JvbGwob3B0aW9ucyk7XG5cbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgdmFyIHRpbWluZ0ZuID0gUG9seW1lci5BcHBMYXlvdXQuc2Nyb2xsVGltaW5nRnVuY3Rpb247XG4gICAgICAgIHZhciBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICB2YXIgY3VycmVudFNjcm9sbFRvcCA9IHRhcmdldCA9PT0gZG9jRWwgPyB3aW5kb3cucGFnZVlPZmZzZXQgOiB0YXJnZXQuc2Nyb2xsVG9wO1xuICAgICAgICB2YXIgY3VycmVudFNjcm9sbExlZnQgPSB0YXJnZXQgPT09IGRvY0VsID8gd2luZG93LnBhZ2VYT2Zmc2V0IDogdGFyZ2V0LnNjcm9sbExlZnQ7XG4gICAgICAgIHZhciBkZWx0YVNjcm9sbFRvcCA9IHNjcm9sbFRvcCAtIGN1cnJlbnRTY3JvbGxUb3A7XG4gICAgICAgIHZhciBkZWx0YVNjcm9sbExlZnQgPSBzY3JvbGxMZWZ0IC0gY3VycmVudFNjcm9sbExlZnQ7XG4gICAgICAgIHZhciBkdXJhdGlvbiA9IDMwMDtcbiAgICAgICAgdmFyIHVwZGF0ZUZyYW1lID0gKGZ1bmN0aW9uIHVwZGF0ZUZyYW1lKCkge1xuICAgICAgICAgIHZhciBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICAgIHZhciBlbGFwc2VkVGltZSA9IG5vdyAtIHN0YXJ0VGltZTtcblxuICAgICAgICAgIGlmIChlbGFwc2VkVGltZSA8IGR1cmF0aW9uKSB7XG4gICAgICAgICAgICBzY3JvbGxUbyh0aW1pbmdGbihlbGFwc2VkVGltZSwgY3VycmVudFNjcm9sbExlZnQsIGRlbHRhU2Nyb2xsTGVmdCwgZHVyYXRpb24pLFxuICAgICAgICAgICAgICAgIHRpbWluZ0ZuKGVsYXBzZWRUaW1lLCBjdXJyZW50U2Nyb2xsVG9wLCBkZWx0YVNjcm9sbFRvcCwgZHVyYXRpb24pKTtcbiAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSh1cGRhdGVGcmFtZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNjcm9sbFRvKHNjcm9sbExlZnQsIHNjcm9sbFRvcCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KS5iaW5kKHRoaXMpO1xuXG4gICAgICAgIHVwZGF0ZUZyYW1lKCk7XG4gICAgICB9XG5cbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMuYmVoYXZpb3IgPT09ICdzaWxlbnQnKSB7XG4gICAgICB2YXIgaGVhZGVycyA9IFBvbHltZXIuQXBwTGF5b3V0LnF1ZXJ5QWxsUm9vdCgnYXBwLWhlYWRlcicsIGRvY3VtZW50LmJvZHkpO1xuXG4gICAgICBoZWFkZXJzLmZvckVhY2goZnVuY3Rpb24oaGVhZGVyKSB7XG4gICAgICAgIGhlYWRlci5zZXRBdHRyaWJ1dGUoJ3NpbGVudC1zY3JvbGwnLCAnJyk7XG4gICAgICB9KTtcblxuICAgICAgLy8gQnJvd3NlcnMga2VlcCB0aGUgc2Nyb2xsIG1vbWVudHVtIGV2ZW4gaWYgdGhlIGJvdHRvbSBvZiB0aGUgc2Nyb2xsaW5nIGNvbnRlbnRcbiAgICAgIC8vIHdhcyByZWFjaGVkLiBUaGlzIG1lYW5zIHRoYXQgY2FsbGluZyBzY3JvbGwoe3RvcDogMCwgYmVoYXZpb3I6ICdzaWxlbnQnfSkgd2hlblxuICAgICAgLy8gdGhlIG1vbWVudHVtIGlzIHN0aWxsIGdvaW5nIHdpbGwgcmVzdWx0IGluIG1vcmUgc2Nyb2xsIGV2ZW50cyBhbmQgdGh1cyBzY3JvbGwgZWZmZWN0cy5cbiAgICAgIC8vIFRoaXMgc2VlbXMgdG8gb25seSBhcHBseSB3aGVuIHVzaW5nIGRvY3VtZW50IHNjcm9sbGluZy5cbiAgICAgIC8vIFRoZXJlZm9yZSwgd2hlbiBzaG91bGQgd2UgcmVtb3ZlIHRoZSBjbGFzcyBmcm9tIHRoZSBkb2N1bWVudCBlbGVtZW50P1xuXG4gICAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUoUG9seW1lci5BcHBMYXlvdXQuX3Njcm9sbFRpbWVyKTtcblxuICAgICAgUG9seW1lci5BcHBMYXlvdXQuX3Njcm9sbFRpbWVyID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbigpIHtcbiAgICAgICAgaGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uKGhlYWRlcikge1xuICAgICAgICAgIGhlYWRlci5yZW1vdmVBdHRyaWJ1dGUoJ3NpbGVudC1zY3JvbGwnKTtcbiAgICAgICAgfSk7XG4gICAgICAgIFBvbHltZXIuQXBwTGF5b3V0Ll9zY3JvbGxUaW1lciA9IG51bGw7XG4gICAgICB9KTtcblxuICAgICAgc2Nyb2xsVG8oc2Nyb2xsTGVmdCwgc2Nyb2xsVG9wKTtcblxuICAgIH0gZWxzZSB7XG5cbiAgICAgIHNjcm9sbFRvKHNjcm9sbExlZnQsIHNjcm9sbFRvcCk7XG5cbiAgICB9XG4gIH07XG5cbjwvc2NyaXB0PlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9hcHAtbGF5b3V0L2hlbHBlcnMvaGVscGVycy5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNSBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuXG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vLi4vcG9seW1lci9wb2x5bWVyLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi8uLi9pcm9uLWZsZXgtbGF5b3V0L2lyb24tZmxleC1sYXlvdXQuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL2FwcC1sYXlvdXQtYmVoYXZpb3IvYXBwLWxheW91dC1iZWhhdmlvci5odG1sXCI+XG5cbjwhLS1cbmFwcC1oZWFkZXItbGF5b3V0IGlzIGEgd3JhcHBlciBlbGVtZW50IHRoYXQgcG9zaXRpb25zIGFuIGFwcC1oZWFkZXIgYW5kIG90aGVyIGNvbnRlbnQuIFRoaXNcbmVsZW1lbnQgdXNlcyB0aGUgZG9jdW1lbnQgc2Nyb2xsIGJ5IGRlZmF1bHQsIGJ1dCBpdCBjYW4gYWxzbyBkZWZpbmUgaXRzIG93biBzY3JvbGxpbmcgcmVnaW9uLlxuXG5Vc2luZyB0aGUgZG9jdW1lbnQgc2Nyb2xsOlxuXG5gYGBodG1sXG48YXBwLWhlYWRlci1sYXlvdXQ+XG4gIDxhcHAtaGVhZGVyIHNsb3Q9XCJoZWFkZXJcIiBmaXhlZCBjb25kZW5zZXMgZWZmZWN0cz1cIndhdGVyZmFsbFwiPlxuICAgIDxhcHAtdG9vbGJhcj5cbiAgICAgIDxkaXYgbWFpbi10aXRsZT5BcHAgbmFtZTwvZGl2PlxuICAgIDwvYXBwLXRvb2xiYXI+XG4gIDwvYXBwLWhlYWRlcj5cbiAgPGRpdj5cbiAgICBtYWluIGNvbnRlbnRcbiAgPC9kaXY+XG48L2FwcC1oZWFkZXItbGF5b3V0PlxuYGBgXG5cblVzaW5nIGFuIG93biBzY3JvbGxpbmcgcmVnaW9uOlxuXG5gYGBodG1sXG48YXBwLWhlYWRlci1sYXlvdXQgaGFzLXNjcm9sbGluZy1yZWdpb24gc3R5bGU9XCJ3aWR0aDogMzAwcHg7IGhlaWdodDogNDAwcHg7XCI+XG4gIDxhcHAtaGVhZGVyIHNsb3Q9XCJoZWFkZXJcIiBmaXhlZCBjb25kZW5zZXMgZWZmZWN0cz1cIndhdGVyZmFsbFwiPlxuICAgIDxhcHAtdG9vbGJhcj5cbiAgICAgIDxkaXYgbWFpbi10aXRsZT5BcHAgbmFtZTwvZGl2PlxuICAgIDwvYXBwLXRvb2xiYXI+XG4gIDwvYXBwLWhlYWRlcj5cbiAgPGRpdj5cbiAgICBtYWluIGNvbnRlbnRcbiAgPC9kaXY+XG48L2FwcC1oZWFkZXItbGF5b3V0PlxuYGBgXG5cbkFkZCB0aGUgYGZ1bGxibGVlZGAgYXR0cmlidXRlIHRvIGFwcC1oZWFkZXItbGF5b3V0IHRvIG1ha2UgaXQgZml0IHRoZSBzaXplIG9mIGl0cyBjb250YWluZXI6XG5cbmBgYGh0bWxcbjxhcHAtaGVhZGVyLWxheW91dCBmdWxsYmxlZWQ+XG4gLi4uXG48L2FwcC1oZWFkZXItbGF5b3V0PlxuYGBgXG5cbkBncm91cCBBcHAgRWxlbWVudHNcbkBlbGVtZW50IGFwcC1oZWFkZXItbGF5b3V0XG5AZGVtbyBhcHAtaGVhZGVyLWxheW91dC9kZW1vL3NpbXBsZS5odG1sIFNpbXBsZSBEZW1vXG5AZGVtbyBhcHAtaGVhZGVyLWxheW91dC9kZW1vL3Njcm9sbGluZy1yZWdpb24uaHRtbCBTY3JvbGxpbmcgUmVnaW9uXG5AZGVtbyBhcHAtaGVhZGVyLWxheW91dC9kZW1vL211c2ljLmh0bWwgTXVzaWMgRGVtb1xuQGRlbW8gYXBwLWhlYWRlci1sYXlvdXQvZGVtby9mb290ZXIuaHRtbCBGb290ZXIgRGVtb1xuLS0+XG5cbjxkb20tbW9kdWxlIGlkPVwiYXBwLWhlYWRlci1sYXlvdXRcIj5cbiAgPHRlbXBsYXRlPlxuICAgIDxzdHlsZT5cbiAgICAgIDpob3N0IHtcbiAgICAgICAgZGlzcGxheTogYmxvY2s7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGb3JjZSBhcHAtaGVhZGVyLWxheW91dCB0byBoYXZlIGl0cyBvd24gc3RhY2tpbmcgY29udGV4dCBzbyB0aGF0IGl0cyBwYXJlbnQgY2FuXG4gICAgICAgICAqIGNvbnRyb2wgdGhlIHN0YWNraW5nIG9mIGl0IHJlbGF0aXZlIHRvIG90aGVyIGVsZW1lbnRzIChlLmcuIGFwcC1kcmF3ZXItbGF5b3V0KS5cbiAgICAgICAgICogVGhpcyBjb3VsZCBiZSBkb25lIHVzaW5nIGBpc29sYXRpb246IGlzb2xhdGVgLCBidXQgdGhhdCdzIG5vdCB3ZWxsIHN1cHBvcnRlZFxuICAgICAgICAgKiBhY3Jvc3MgYnJvd3NlcnMuXG4gICAgICAgICAqL1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgIHotaW5kZXg6IDA7XG4gICAgICB9XG5cbiAgICAgICN3cmFwcGVyIDo6c2xvdHRlZChbc2xvdD1oZWFkZXJdKSB7XG4gICAgICAgIEBhcHBseSAtLWxheW91dC1maXhlZC10b3A7XG4gICAgICAgIHotaW5kZXg6IDE7XG4gICAgICB9XG5cbiAgICAgICN3cmFwcGVyLmluaXRpYWxpemluZyA6OnNsb3R0ZWQoW3Nsb3Q9aGVhZGVyXSkge1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICB9XG5cbiAgICAgIDpob3N0KFtoYXMtc2Nyb2xsaW5nLXJlZ2lvbl0pIHtcbiAgICAgICAgaGVpZ2h0OiAxMDAlO1xuICAgICAgfVxuXG4gICAgICA6aG9zdChbaGFzLXNjcm9sbGluZy1yZWdpb25dKSAjd3JhcHBlciA6OnNsb3R0ZWQoW3Nsb3Q9aGVhZGVyXSkge1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICB9XG5cbiAgICAgIDpob3N0KFtoYXMtc2Nyb2xsaW5nLXJlZ2lvbl0pICN3cmFwcGVyLmluaXRpYWxpemluZyA6OnNsb3R0ZWQoW3Nsb3Q9aGVhZGVyXSkge1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICB9XG5cbiAgICAgIDpob3N0KFtoYXMtc2Nyb2xsaW5nLXJlZ2lvbl0pICN3cmFwcGVyICNjb250ZW50Q29udGFpbmVyIHtcbiAgICAgICAgQGFwcGx5IC0tbGF5b3V0LWZpdDtcbiAgICAgICAgb3ZlcmZsb3cteTogYXV0bztcbiAgICAgICAgLXdlYmtpdC1vdmVyZmxvdy1zY3JvbGxpbmc6IHRvdWNoO1xuICAgICAgfVxuXG4gICAgICA6aG9zdChbaGFzLXNjcm9sbGluZy1yZWdpb25dKSAjd3JhcHBlci5pbml0aWFsaXppbmcgI2NvbnRlbnRDb250YWluZXIge1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICB9XG5cbiAgICAgIDpob3N0KFtmdWxsYmxlZWRdKSB7XG4gICAgICAgIEBhcHBseSAtLWxheW91dC12ZXJ0aWNhbDtcbiAgICAgICAgQGFwcGx5IC0tbGF5b3V0LWZpdDtcbiAgICAgIH1cblxuICAgICAgOmhvc3QoW2Z1bGxibGVlZF0pICN3cmFwcGVyLFxuICAgICAgOmhvc3QoW2Z1bGxibGVlZF0pICN3cmFwcGVyICNjb250ZW50Q29udGFpbmVyIHtcbiAgICAgICAgQGFwcGx5IC0tbGF5b3V0LXZlcnRpY2FsO1xuICAgICAgICBAYXBwbHkgLS1sYXlvdXQtZmxleDtcbiAgICAgIH1cblxuICAgICAgI2NvbnRlbnRDb250YWluZXIge1xuICAgICAgICAvKiBDcmVhdGUgYSBzdGFja2luZyBjb250ZXh0IGhlcmUgc28gdGhhdCBhbGwgY2hpbGRyZW4gYXBwZWFyIGJlbG93IHRoZSBoZWFkZXIuICovXG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgei1pbmRleDogMDtcbiAgICAgIH1cblxuICAgIDwvc3R5bGU+XG5cbiAgICA8ZGl2IGlkPVwid3JhcHBlclwiIGNsYXNzPVwiaW5pdGlhbGl6aW5nXCI+XG4gICAgICA8c2xvdCBpZD1cImhlYWRlclNsb3RcIiBuYW1lPVwiaGVhZGVyXCI+PC9zbG90PlxuXG4gICAgICA8ZGl2IGlkPVwiY29udGVudENvbnRhaW5lclwiPlxuICAgICAgICA8c2xvdD48L3Nsb3Q+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cblxuICA8L3RlbXBsYXRlPlxuXG4gIDxzY3JpcHQ+XG4gICAgUG9seW1lcih7XG4gICAgICBpczogJ2FwcC1oZWFkZXItbGF5b3V0JyxcblxuICAgICAgYmVoYXZpb3JzOiBbXG4gICAgICAgIFBvbHltZXIuQXBwTGF5b3V0QmVoYXZpb3JcbiAgICAgIF0sXG5cbiAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHRydWUsIHRoZSBjdXJyZW50IGVsZW1lbnQgd2lsbCBoYXZlIGl0cyBvd24gc2Nyb2xsaW5nIHJlZ2lvbi5cbiAgICAgICAgICogT3RoZXJ3aXNlLCBpdCB3aWxsIHVzZSB0aGUgZG9jdW1lbnQgc2Nyb2xsIHRvIGNvbnRyb2wgdGhlIGhlYWRlci5cbiAgICAgICAgICovXG4gICAgICAgIGhhc1Njcm9sbGluZ1JlZ2lvbjoge1xuICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgICAgdmFsdWU6IGZhbHNlLFxuICAgICAgICAgIHJlZmxlY3RUb0F0dHJpYnV0ZTogdHJ1ZVxuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBvYnNlcnZlcnM6IFtcbiAgICAgICAgJ3Jlc2V0TGF5b3V0KGlzQXR0YWNoZWQsIGhhc1Njcm9sbGluZ1JlZ2lvbiknXG4gICAgICBdLFxuXG4gICAgICAvKipcbiAgICAgICAqIEEgcmVmZXJlbmNlIHRvIHRoZSBhcHAtaGVhZGVyIGVsZW1lbnQuXG4gICAgICAgKlxuICAgICAgICogQHByb3BlcnR5IGhlYWRlclxuICAgICAgICovXG4gICAgICBnZXQgaGVhZGVyKCkge1xuICAgICAgICByZXR1cm4gUG9seW1lci5kb20odGhpcy4kLmhlYWRlclNsb3QpLmdldERpc3RyaWJ1dGVkTm9kZXMoKVswXTtcbiAgICAgIH0sXG5cbiAgICAgIF91cGRhdGVMYXlvdXRTdGF0ZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaGVhZGVyID0gdGhpcy5oZWFkZXI7XG4gICAgICAgIGlmICghdGhpcy5pc0F0dGFjaGVkIHx8ICFoZWFkZXIpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBpbml0aWFsaXppbmcgY2xhc3MsIHdoaWNoIHN0YXRpY2x5IHBvc2l0aW9ucyB0aGUgaGVhZGVyIGFuZCB0aGUgY29udGVudFxuICAgICAgICAvLyB1bnRpbCB0aGUgaGVpZ2h0IG9mIHRoZSBoZWFkZXIgY2FuIGJlIHJlYWQuXG4gICAgICAgIHRoaXMuJC53cmFwcGVyLmNsYXNzTGlzdC5yZW1vdmUoJ2luaXRpYWxpemluZycpO1xuICAgICAgICAvLyBVcGRhdGUgc2Nyb2xsIHRhcmdldC5cbiAgICAgICAgaGVhZGVyLnNjcm9sbFRhcmdldCA9IHRoaXMuaGFzU2Nyb2xsaW5nUmVnaW9uID9cbiAgICAgICAgICAgIHRoaXMuJC5jb250ZW50Q29udGFpbmVyIDogdGhpcy5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgLy8gR2V0IGhlYWRlciBoZWlnaHQgaGVyZSBzbyB0aGF0IHN0eWxlIHJlYWRzIGFyZSBiYXRjaGVkIHRvZ2V0aGVyIGJlZm9yZSBzdHlsZSB3cml0ZXNcbiAgICAgICAgLy8gKGkuZS4gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkgYmVsb3cpLlxuICAgICAgICB2YXIgaGVhZGVySGVpZ2h0ID0gaGVhZGVyLm9mZnNldEhlaWdodDtcbiAgICAgICAgLy8gVXBkYXRlIHRoZSBoZWFkZXIgcG9zaXRpb24uXG4gICAgICAgIGlmICghdGhpcy5oYXNTY3JvbGxpbmdSZWdpb24pIHtcbiAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgcmVjdCA9IHRoaXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICB2YXIgcmlnaHRPZmZzZXQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGggLSByZWN0LnJpZ2h0O1xuICAgICAgICAgICAgaGVhZGVyLnN0eWxlLmxlZnQgPSByZWN0LmxlZnQgKyAncHgnO1xuICAgICAgICAgICAgaGVhZGVyLnN0eWxlLnJpZ2h0ID0gcmlnaHRPZmZzZXQgKyAncHgnO1xuICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaGVhZGVyLnN0eWxlLmxlZnQgPSAnJztcbiAgICAgICAgICBoZWFkZXIuc3R5bGUucmlnaHQgPSAnJztcbiAgICAgICAgfVxuICAgICAgICAvLyBVcGRhdGUgdGhlIGNvbnRlbnQgY29udGFpbmVyIHBvc2l0aW9uLlxuICAgICAgICB2YXIgY29udGFpbmVyU3R5bGUgPSB0aGlzLiQuY29udGVudENvbnRhaW5lci5zdHlsZTtcbiAgICAgICAgaWYgKGhlYWRlci5maXhlZCAmJiAhaGVhZGVyLmNvbmRlbnNlcyAmJiB0aGlzLmhhc1Njcm9sbGluZ1JlZ2lvbikge1xuICAgICAgICAgIC8vIElmIHRoZSBoZWFkZXIgc2l6ZSBkb2VzIG5vdCBjaGFuZ2UgYW5kIHdlJ3JlIHVzaW5nIGEgc2Nyb2xsaW5nIHJlZ2lvbiwgZXhjbHVkZVxuICAgICAgICAgIC8vIHRoZSBoZWFkZXIgYXJlYSBmcm9tIHRoZSBzY3JvbGxpbmcgcmVnaW9uIHNvIHRoYXQgdGhlIGhlYWRlciBkb2Vzbid0IG92ZXJsYXBcbiAgICAgICAgICAvLyB0aGUgc2Nyb2xsYmFyLlxuICAgICAgICAgIGNvbnRhaW5lclN0eWxlLm1hcmdpblRvcCA9IGhlYWRlckhlaWdodCArICdweCc7XG4gICAgICAgICAgY29udGFpbmVyU3R5bGUucGFkZGluZ1RvcCA9ICcnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnRhaW5lclN0eWxlLnBhZGRpbmdUb3AgPSBoZWFkZXJIZWlnaHQgKyAncHgnO1xuICAgICAgICAgIGNvbnRhaW5lclN0eWxlLm1hcmdpblRvcCA9ICcnO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICB9KTtcbiAgPC9zY3JpcHQ+XG48L2RvbS1tb2R1bGU+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL2FwcC1sYXlvdXQvYXBwLWhlYWRlci1sYXlvdXQvYXBwLWhlYWRlci1sYXlvdXQuaHRtbCIsIlxucmVxdWlyZSgnLi9lZmZlY3RzL2JsZW5kLWJhY2tncm91bmQuaHRtbCcpO1xuXG5yZXF1aXJlKCcuL2VmZmVjdHMvZmFkZS1iYWNrZ3JvdW5kLmh0bWwnKTtcblxucmVxdWlyZSgnLi9lZmZlY3RzL21hdGVyaWFsLmh0bWwnKTtcblxucmVxdWlyZSgnLi9lZmZlY3RzL3BhcmFsbGF4LWJhY2tncm91bmQuaHRtbCcpO1xuXG5yZXF1aXJlKCcuL2VmZmVjdHMvcmVzaXplLXNuYXBwZWQtdGl0bGUuaHRtbCcpO1xuXG5yZXF1aXJlKCcuL2VmZmVjdHMvcmVzaXplLXRpdGxlLmh0bWwnKTtcblxucmVxdWlyZSgnLi9lZmZlY3RzL3dhdGVyZmFsbC5odG1sJyk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL2FwcC1sYXlvdXQvYXBwLXNjcm9sbC1lZmZlY3RzL2FwcC1zY3JvbGwtZWZmZWN0cy5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNiBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuXG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vYXBwLXNjcm9sbC1lZmZlY3RzLWJlaGF2aW9yLmh0bWxcIj5cblxuPHNjcmlwdD5cbiAgLyoqXG4gICAqIFVwb24gc2Nyb2xsaW5nIHBhc3QgYSB0aHJlc2hvbGQsIGZhZGUgaW4gdGhlIHJlYXIgYmFja2dyb3VuZCBsYXllciBhbmQgZmFkZSBvdXQgdGhlIGZyb250XG4gICAqIGJhY2tncm91bmQgbGF5ZXIgKG9wYWNpdHkgQ1NTIHRyYW5zaXRpb25lZCBvdmVyIHRpbWUpLlxuICAgKlxuICAgKlxuICAgKi9cbiAgUG9seW1lci5BcHBMYXlvdXQucmVnaXN0ZXJFZmZlY3QoJ2ZhZGUtYmFja2dyb3VuZCcsIHtcbiAgICAvKiogQHRoaXMgUG9seW1lci5BcHBMYXlvdXQuRWxlbWVudFdpdGhCYWNrZ3JvdW5kICovXG4gICAgc2V0VXA6IGZ1bmN0aW9uIHNldFVwKGNvbmZpZykge1xuICAgICAgdmFyIGZ4ID0ge307XG4gICAgICB2YXIgZHVyYXRpb24gPSBjb25maWcuZHVyYXRpb24gfHwgJzAuNXMnO1xuICAgICAgZnguYmFja2dyb3VuZEZyb250TGF5ZXIgPSB0aGlzLl9nZXRET01SZWYoJ2JhY2tncm91bmRGcm9udExheWVyJyk7XG4gICAgICBmeC5iYWNrZ3JvdW5kUmVhckxheWVyID0gdGhpcy5fZ2V0RE9NUmVmKCdiYWNrZ3JvdW5kUmVhckxheWVyJyk7XG4gICAgICBmeC5iYWNrZ3JvdW5kRnJvbnRMYXllci5zdHlsZS53aWxsQ2hhbmdlID0gJ29wYWNpdHknO1xuICAgICAgZnguYmFja2dyb3VuZEZyb250TGF5ZXIuc3R5bGUud2Via2l0VHJhbnNmb3JtID0gJ3RyYW5zbGF0ZVooMCknO1xuICAgICAgZnguYmFja2dyb3VuZEZyb250TGF5ZXIuc3R5bGUudHJhbnNpdGlvblByb3BlcnR5ID0gJ29wYWNpdHknO1xuICAgICAgZnguYmFja2dyb3VuZEZyb250TGF5ZXIuc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID0gZHVyYXRpb247XG4gICAgICBmeC5iYWNrZ3JvdW5kUmVhckxheWVyLnN0eWxlLndpbGxDaGFuZ2UgPSAnb3BhY2l0eSc7XG4gICAgICBmeC5iYWNrZ3JvdW5kUmVhckxheWVyLnN0eWxlLndlYmtpdFRyYW5zZm9ybSA9ICd0cmFuc2xhdGVaKDApJztcbiAgICAgIGZ4LmJhY2tncm91bmRSZWFyTGF5ZXIuc3R5bGUudHJhbnNpdGlvblByb3BlcnR5ID0gJ29wYWNpdHknO1xuICAgICAgZnguYmFja2dyb3VuZFJlYXJMYXllci5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPSBkdXJhdGlvbjtcbiAgICAgIHRoaXMuX2Z4RmFkZUJhY2tncm91bmQgPSBmeDtcbiAgICB9LFxuICAgIC8qKiBAdGhpcyBQb2x5bWVyLkFwcExheW91dC5FbGVtZW50V2l0aEJhY2tncm91bmQgKi9cbiAgICBydW46IGZ1bmN0aW9uIHJ1bihwLCB5KSB7XG4gICAgICB2YXIgZnggPSB0aGlzLl9meEZhZGVCYWNrZ3JvdW5kO1xuICAgICAgaWYgKHAgPj0gMSkge1xuICAgICAgICBmeC5iYWNrZ3JvdW5kRnJvbnRMYXllci5zdHlsZS5vcGFjaXR5ID0gMDtcbiAgICAgICAgZnguYmFja2dyb3VuZFJlYXJMYXllci5zdHlsZS5vcGFjaXR5ID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZ4LmJhY2tncm91bmRGcm9udExheWVyLnN0eWxlLm9wYWNpdHkgPSAxO1xuICAgICAgICBmeC5iYWNrZ3JvdW5kUmVhckxheWVyLnN0eWxlLm9wYWNpdHkgPSAwO1xuICAgICAgfVxuICAgIH0sXG4gICAgLyoqIEB0aGlzIFBvbHltZXIuQXBwTGF5b3V0LkVsZW1lbnRXaXRoQmFja2dyb3VuZCAqL1xuICAgIHRlYXJEb3duOiBmdW5jdGlvbiB0ZWFyRG93bigpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLl9meEZhZGVCYWNrZ3JvdW5kO1xuICAgIH1cbiAgfSk7XG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvYXBwLWxheW91dC9hcHAtc2Nyb2xsLWVmZmVjdHMvZWZmZWN0cy9mYWRlLWJhY2tncm91bmQuaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTYgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cblxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL2FwcC1zY3JvbGwtZWZmZWN0cy1iZWhhdmlvci5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwid2F0ZXJmYWxsLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCJyZXNpemUtdGl0bGUuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cImJsZW5kLWJhY2tncm91bmQuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cInBhcmFsbGF4LWJhY2tncm91bmQuaHRtbFwiPlxuXG48c2NyaXB0PlxuICAvKipcbiAgICogU2hvcnRoYW5kIGZvciB0aGUgd2F0ZXJmYWxsLCByZXNpemUtdGl0bGUsIGJsZW5kLWJhY2tncm91bmQsIGFuZCBwYXJhbGxheC1iYWNrZ3JvdW5kIGVmZmVjdHMuXG4gICAqL1xuICBQb2x5bWVyLkFwcExheW91dC5yZWdpc3RlckVmZmVjdCgnbWF0ZXJpYWwnLCB7XG4gICAgLyoqXG4gICAgICogQHRoaXMgUG9seW1lci5BcHBMYXlvdXQuRWxlbWVudFdpdGhCYWNrZ3JvdW5kXG4gICAgICovXG4gICAgc2V0VXA6IGZ1bmN0aW9uIHNldFVwKCkge1xuICAgICAgdGhpcy5lZmZlY3RzID0gJ3dhdGVyZmFsbCByZXNpemUtdGl0bGUgYmxlbmQtYmFja2dyb3VuZCBwYXJhbGxheC1iYWNrZ3JvdW5kJztcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0pO1xuPC9zY3JpcHQ+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL2FwcC1sYXlvdXQvYXBwLXNjcm9sbC1lZmZlY3RzL2VmZmVjdHMvbWF0ZXJpYWwuaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTYgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cblxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL2FwcC1zY3JvbGwtZWZmZWN0cy1iZWhhdmlvci5odG1sXCI+XG5cbjxzY3JpcHQ+XG4gIC8qKlxuICAgKiBVcG9uIHNjcm9sbGluZyBwYXN0IGEgdGhyZXNob2xkLCBDU1MgdHJhbnNpdGlvbiB0aGUgZm9udCBzaXplIG9mIGEgZGVzaWduYXRlZCB0aXRsZSBlbGVtZW50XG4gICAqIGJldHdlZW4gdHdvIHZhbHVlcy5cbiAgICovXG4gIFBvbHltZXIuQXBwTGF5b3V0LnJlZ2lzdGVyRWZmZWN0KCdyZXNpemUtc25hcHBlZC10aXRsZScsIHtcbiAgICAvKipcbiAgICAgKiBAdGhpcyBQb2x5bWVyLkFwcExheW91dC5FbGVtZW50V2l0aEJhY2tncm91bmRcbiAgICAgKi9cbiAgICBzZXRVcDogZnVuY3Rpb24gc2V0VXAoY29uZmlnKSB7XG4gICAgICB2YXIgdGl0bGUgPSB0aGlzLl9nZXRET01SZWYoJ21haW5UaXRsZScpO1xuICAgICAgdmFyIGNvbmRlbnNlZFRpdGxlID0gdGhpcy5fZ2V0RE9NUmVmKCdjb25kZW5zZWRUaXRsZScpO1xuICAgICAgdmFyIGR1cmF0aW9uID0gY29uZmlnLmR1cmF0aW9uIHx8ICcwLjJzJztcbiAgICAgIHZhciBmeCA9IHt9O1xuXG4gICAgICBpZiAoIWNvbmRlbnNlZFRpdGxlKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignU2Nyb2xsIGVmZmVjdCBgcmVzaXplLXNuYXBwZWQtdGl0bGVgOiB1bmRlZmluZWQgYGNvbmRlbnNlZC10aXRsZWAnKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKCF0aXRsZSkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1Njcm9sbCBlZmZlY3QgYHJlc2l6ZS1zbmFwcGVkLXRpdGxlYDogdW5kZWZpbmVkIGBtYWluLXRpdGxlYCcpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHRpdGxlLnN0eWxlLnRyYW5zaXRpb25Qcm9wZXJ0eSA9ICdvcGFjaXR5JztcbiAgICAgIHRpdGxlLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9IGR1cmF0aW9uO1xuICAgICAgY29uZGVuc2VkVGl0bGUuc3R5bGUudHJhbnNpdGlvblByb3BlcnR5ID0gJ29wYWNpdHknO1xuICAgICAgY29uZGVuc2VkVGl0bGUuc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID0gZHVyYXRpb247XG4gICAgICBmeC5jb25kZW5zZWRUaXRsZSA9IGNvbmRlbnNlZFRpdGxlO1xuICAgICAgZngudGl0bGUgPSB0aXRsZTtcbiAgICAgIHRoaXMuX2Z4UmVzaXplU25hcHBlZFRpdGxlID0gZng7XG4gICAgfSxcbiAgICAvKiogQHRoaXMgUG9seW1lci5BcHBMYXlvdXQuRWxlbWVudFdpdGhCYWNrZ3JvdW5kICovXG4gICAgcnVuOiBmdW5jdGlvbiBydW4ocCwgeSkge1xuICAgICAgdmFyIGZ4ID0gdGhpcy5fZnhSZXNpemVTbmFwcGVkVGl0bGU7XG4gICAgICBpZiAocCA+IDApIHtcbiAgICAgICAgZngudGl0bGUuc3R5bGUub3BhY2l0eSA9IDA7XG4gICAgICAgIGZ4LmNvbmRlbnNlZFRpdGxlLnN0eWxlLm9wYWNpdHkgPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZngudGl0bGUuc3R5bGUub3BhY2l0eSA9IDE7XG4gICAgICAgIGZ4LmNvbmRlbnNlZFRpdGxlLnN0eWxlLm9wYWNpdHkgPSAwO1xuICAgICAgfVxuICAgIH0sXG4gICAgLyoqIEB0aGlzIFBvbHltZXIuQXBwTGF5b3V0LkVsZW1lbnRXaXRoQmFja2dyb3VuZCAqL1xuICAgIHRlYXJEb3duOiBmdW5jdGlvbiB0ZWFyRG93bigpIHtcbiAgICAgIHZhciBmeCA9IHRoaXMuX2Z4UmVzaXplU25hcHBlZFRpdGxlO1xuICAgICAgZngudGl0bGUuc3R5bGUudHJhbnNpdGlvbiA9ICcnO1xuICAgICAgZnguY29uZGVuc2VkVGl0bGUuc3R5bGUudHJhbnNpdGlvbiA9ICcnO1xuICAgICAgZGVsZXRlIHRoaXMuX2Z4UmVzaXplU25hcHBlZFRpdGxlO1xuICAgIH1cbiAgfSk7XG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvYXBwLWxheW91dC9hcHAtc2Nyb2xsLWVmZmVjdHMvZWZmZWN0cy9yZXNpemUtc25hcHBlZC10aXRsZS5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNSBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuXG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vLi4vcG9seW1lci9wb2x5bWVyLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi8uLi9pcm9uLWZsZXgtbGF5b3V0L2lyb24tZmxleC1sYXlvdXQuaHRtbFwiPlxuXG48IS0tXG5hcHAtdG9vbGJhciBpcyBhIGhvcml6b250YWwgdG9vbGJhciBjb250YWluaW5nIGl0ZW1zIHRoYXQgY2FuIGJlIHVzZWQgZm9yXG5sYWJlbCwgbmF2aWdhdGlvbiwgc2VhcmNoIGFuZCBhY3Rpb25zLlxuXG4jIyMgRXhhbXBsZVxuXG5BZGQgYSB0aXRsZSB0byB0aGUgdG9vbGJhci5cblxuYGBgaHRtbFxuPGFwcC10b29sYmFyPlxuICA8ZGl2IG1haW4tdGl0bGU+QXBwIG5hbWU8L2Rpdj5cbjwvYXBwLXRvb2xiYXI+XG5gYGBcblxuQWRkIGEgYnV0dG9uIHRvIHRoZSBsZWZ0IGFuZCByaWdodCBzaWRlIG9mIHRoZSB0b29sYmFyLlxuXG5gYGBodG1sXG48YXBwLXRvb2xiYXI+XG4gIDxwYXBlci1pY29uLWJ1dHRvbiBpY29uPVwibWVudVwiPjwvcGFwZXItaWNvbi1idXR0b24+XG4gIDxkaXYgbWFpbi10aXRsZT5BcHAgbmFtZTwvZGl2PlxuICA8cGFwZXItaWNvbi1idXR0b24gaWNvbj1cInNlYXJjaFwiPjwvcGFwZXItaWNvbi1idXR0b24+XG48L2FwcC10b29sYmFyPlxuYGBgXG5cbllvdSBjYW4gdXNlIHRoZSBhdHRyaWJ1dGVzIGB0b3AtaXRlbWAgb3IgYGJvdHRvbS1pdGVtYCB0byBjb21wbGV0ZWx5IGZpdCBhbiBlbGVtZW50XG50byB0aGUgdG9wIG9yIGJvdHRvbSBvZiB0aGUgdG9vbGJhciByZXNwZWN0aXZlbHkuXG5cbiMjIyBDb250ZW50IGF0dHJpYnV0ZXNcblxuQXR0cmlidXRlICAgICAgICAgICAgfCBEZXNjcmlwdGlvblxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuYG1haW4tdGl0bGVgICAgICAgICAgfCBUaGUgbWFpbiB0aXRsZSBlbGVtZW50LlxuYGNvbmRlbnNlZC10aXRsZWAgICAgfCBUaGUgdGl0bGUgZWxlbWVudCBpZiB1c2VkIGluc2lkZSBhIGNvbmRlbnNlZCBhcHAtaGVhZGVyLlxuYHNwYWNlcmAgICAgICAgICAgICAgfCBBZGRzIGEgbGVmdCBtYXJnaW4gb2YgYDY0cHhgLlxuYGJvdHRvbS1pdGVtYCAgICAgICAgfCBTdGlja3MgdGhlIGVsZW1lbnQgdG8gdGhlIGJvdHRvbSBvZiB0aGUgdG9vbGJhci5cbmB0b3AtaXRlbWAgICAgICAgICAgIHwgU3RpY2tzIHRoZSBlbGVtZW50IHRvIHRoZSB0b3Agb2YgdGhlIHRvb2xiYXIuXG5cbiMjIyBTdHlsaW5nXG5cbkN1c3RvbSBwcm9wZXJ0eSAgICAgICAgICAgICAgfCBEZXNjcmlwdGlvbiAgICAgICAgICAgICAgICAgIHwgRGVmYXVsdFxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5gLS1hcHAtdG9vbGJhci1mb250LXNpemVgICAgIHwgVG9vbGJhciBmb250IHNpemUgICAgICAgICAgICB8IDIwcHhcblxuQGdyb3VwIEFwcCBFbGVtZW50c1xuQGVsZW1lbnQgYXBwLXRvb2xiYXJcbkBkZW1vIGFwcC10b29sYmFyL2RlbW8vaW5kZXguaHRtbFxuLS0+XG5cbjxkb20tbW9kdWxlIGlkPVwiYXBwLXRvb2xiYXJcIj5cbiAgPHRlbXBsYXRlPlxuICAgIDxzdHlsZT5cblxuICAgICAgOmhvc3Qge1xuICAgICAgICBAYXBwbHkgLS1sYXlvdXQtaG9yaXpvbnRhbDtcbiAgICAgICAgQGFwcGx5IC0tbGF5b3V0LWNlbnRlcjtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICBoZWlnaHQ6IDY0cHg7XG4gICAgICAgIHBhZGRpbmc6IDAgMTZweDtcbiAgICAgICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG4gICAgICAgIGZvbnQtc2l6ZTogdmFyKC0tYXBwLXRvb2xiYXItZm9udC1zaXplLCAyMHB4KTtcbiAgICAgIH1cblxuICAgICAgOmhvc3QgOjpzbG90dGVkKCopIHtcbiAgICAgICAgcG9pbnRlci1ldmVudHM6IGF1dG87XG4gICAgICB9XG5cbiAgICAgIDpob3N0IDo6c2xvdHRlZChwYXBlci1pY29uLWJ1dHRvbikge1xuICAgICAgICAvKiBwYXBlci1pY29uLWJ1dHRvbi9pc3N1ZXMvMzMgKi9cbiAgICAgICAgZm9udC1zaXplOiAwO1xuICAgICAgfVxuXG4gICAgICA6aG9zdCA6OnNsb3R0ZWQoW21haW4tdGl0bGVdKSxcbiAgICAgIDpob3N0IDo6c2xvdHRlZChbY29uZGVuc2VkLXRpdGxlXSkge1xuICAgICAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcbiAgICAgICAgQGFwcGx5IC0tbGF5b3V0LWZsZXg7XG4gICAgICB9XG5cbiAgICAgIDpob3N0IDo6c2xvdHRlZChbYm90dG9tLWl0ZW1dKSB7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgcmlnaHQ6IDA7XG4gICAgICAgIGJvdHRvbTogMDtcbiAgICAgICAgbGVmdDogMDtcbiAgICAgIH1cblxuICAgICAgOmhvc3QgOjpzbG90dGVkKFt0b3AtaXRlbV0pIHtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICB0b3A6IDA7XG4gICAgICAgIHJpZ2h0OiAwO1xuICAgICAgICBsZWZ0OiAwO1xuICAgICAgfVxuXG4gICAgICA6aG9zdCA6OnNsb3R0ZWQoW3NwYWNlcl0pIHtcbiAgICAgICAgbWFyZ2luLWxlZnQ6IDY0cHg7XG4gICAgICB9XG4gICAgPC9zdHlsZT5cblxuICAgIDxzbG90Pjwvc2xvdD5cblxuICA8L3RlbXBsYXRlPlxuXG4gIDxzY3JpcHQ+XG4gICAgUG9seW1lcih7XG4gICAgICBpczogJ2FwcC10b29sYmFyJ1xuICAgIH0pO1xuICA8L3NjcmlwdD5cbjwvZG9tLW1vZHVsZT5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvYXBwLWxheW91dC9hcHAtdG9vbGJhci9hcHAtdG9vbGJhci5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNiBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3BvbHltZXIvcG9seW1lci5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vaXJvbi1sb2NhdGlvbi9pcm9uLWxvY2F0aW9uLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi9pcm9uLWxvY2F0aW9uL2lyb24tcXVlcnktcGFyYW1zLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCJhcHAtcm91dGUtY29udmVydGVyLWJlaGF2aW9yLmh0bWxcIj5cblxuPCEtLVxuYGFwcC1sb2NhdGlvbmAgaXMgYW4gZWxlbWVudCB0aGF0IHByb3ZpZGVzIHN5bmNocm9uaXphdGlvbiBiZXR3ZWVuIHRoZVxuYnJvd3NlciBsb2NhdGlvbiBiYXIgYW5kIHRoZSBzdGF0ZSBvZiBhbiBhcHAuIFdoZW4gY3JlYXRlZCwgYGFwcC1sb2NhdGlvbmBcbmVsZW1lbnRzIHdpbGwgYXV0b21hdGljYWxseSB3YXRjaCB0aGUgZ2xvYmFsIGxvY2F0aW9uIGZvciBjaGFuZ2VzLiBBcyBjaGFuZ2VzXG5vY2N1ciwgYGFwcC1sb2NhdGlvbmAgcHJvZHVjZXMgYW5kIHVwZGF0ZXMgYW4gb2JqZWN0IGNhbGxlZCBgcm91dGVgLiBUaGlzXG5gcm91dGVgIG9iamVjdCBpcyBzdWl0YWJsZSBmb3IgcGFzc2luZyBpbnRvIGEgYGFwcC1yb3V0ZWAsIGFuZCBvdGhlciBzaW1pbGFyXG5lbGVtZW50cy5cblxuQW4gZXhhbXBsZSBvZiB0aGUgcHVibGljIEFQSSBvZiBhIHJvdXRlIG9iamVjdCB0aGF0IGRlc2NyaWJlcyB0aGUgVVJMXG5gaHR0cHM6Ly9lbGVtZW50cy5wb2x5bWVyLXByb2plY3Qub3JnL2VsZW1lbnRzL2FwcC1sb2NhdGlvbmA6XG5cbiAgICB7XG4gICAgICBwcmVmaXg6ICcnLFxuICAgICAgcGF0aDogJy9lbGVtZW50cy9hcHAtbG9jYXRpb24nXG4gICAgfVxuXG5FeGFtcGxlIFVzYWdlOlxuXG4gICAgPGFwcC1sb2NhdGlvbiByb3V0ZT1cInt7cm91dGV9fVwiPjwvYXBwLWxvY2F0aW9uPlxuICAgIDxhcHAtcm91dGUgcm91dGU9XCJ7e3JvdXRlfX1cIiBwYXR0ZXJuPVwiLzpwYWdlXCIgZGF0YT1cInt7ZGF0YX19XCI+PC9hcHAtcm91dGU+XG5cbkFzIHlvdSBjYW4gc2VlIGFib3ZlLCB0aGUgYGFwcC1sb2NhdGlvbmAgZWxlbWVudCBwcm9kdWNlcyBhIGByb3V0ZWAgYW5kIHRoYXRcbnByb3BlcnR5IGlzIHRoZW4gYm91bmQgaW50byB0aGUgYGFwcC1yb3V0ZWAgZWxlbWVudC4gVGhlIGJpbmRpbmdzIGFyZSB0d28tXG5kaXJlY3Rpb25hbCwgc28gd2hlbiBjaGFuZ2VzIHRvIHRoZSBgcm91dGVgIG9iamVjdCBvY2N1ciB3aXRoaW4gYGFwcC1yb3V0ZWAsXG50aGV5IGF1dG9tYXRpY2FsbHkgcmVmbGVjdCBiYWNrIHRvIHRoZSBnbG9iYWwgbG9jYXRpb24uXG5cbiMjIyBIYXNoZXMgdnMgUGF0aHNcblxuQnkgZGVmYXVsdCBgYXBwLWxvY2F0aW9uYCByb3V0ZXMgdXNpbmcgdGhlIHBhdGhuYW1lIHBvcnRpb24gb2YgdGhlIFVSTC4gVGhpcyBoYXNcbmJyb2FkIGJyb3dzZXIgc3VwcG9ydCBidXQgaXQgZG9lcyByZXF1aXJlIGNvb3BlcmF0aW9uIG9mIHRoZSBiYWNrZW5kIHNlcnZlci4gQW5cbmBhcHAtbG9jYXRpb25gIGNhbiBiZSBjb25maWd1cmVkIHRvIHVzZSB0aGUgaGFzaCBwYXJ0IG9mIGEgVVJMIGluc3RlYWQgdXNpbmdcbnRoZSBgdXNlLWhhc2gtYXMtcGF0aGAgYXR0cmlidXRlLCBsaWtlIHNvOlxuXG4gICAgPGFwcC1sb2NhdGlvbiByb3V0ZT1cInt7cm91dGV9fVwiIHVzZS1oYXNoLWFzLXBhdGg+PC9hcHAtbG9jYXRpb24+XG5cbiMjIyBJbnRlZ3JhdGluZyB3aXRoIG90aGVyIHJvdXRpbmcgY29kZVxuXG5UaGVyZSBpcyBubyBzdGFuZGFyZCBldmVudCB0aGF0IGlzIGZpcmVkIHdoZW4gd2luZG93LmxvY2F0aW9uIGlzIG1vZGlmaWVkLlxuYGFwcC1sb2NhdGlvbmAgZmlyZXMgYSBgbG9jYXRpb24tY2hhbmdlZGAgZXZlbnQgb24gYHdpbmRvd2Agd2hlbiBpdCB1cGRhdGVzIHRoZVxubG9jYXRpb24uIEl0IGFsc28gbGlzdGVucyBmb3IgdGhhdCBzYW1lIGV2ZW50LCBhbmQgcmUtcmVhZHMgdGhlIFVSTCB3aGVuIGl0J3NcbmZpcmVkLiBUaGlzIG1ha2VzIGl0IHZlcnkgZWFzeSB0byBpbnRlcm9wIHdpdGggb3RoZXIgcm91dGluZyBjb2RlLlxuXG5TbyBmb3IgZXhhbXBsZSBpZiB5b3Ugd2FudCB0byBuYXZpZ2F0ZSB0byBgL25ld19wYXRoYCBpbXBlcmF0aXZlbHkgeW91IGNvdWxkXG5jYWxsIGB3aW5kb3cubG9jYXRpb24ucHVzaFN0YXRlYCBvciBgd2luZG93LmxvY2F0aW9uLnJlcGxhY2VTdGF0ZWAgZm9sbG93ZWQgYnlcbmZpcmluZyBhIGBsb2NhdGlvbi1jaGFuZ2VkYCBldmVudCBvbiBgd2luZG93YC4gaS5lLlxuXG4gICAgd2luZG93Lmhpc3RvcnkucHVzaFN0YXRlKHt9LCBudWxsLCAnL25ld19wYXRoJyk7XG4gICAgd2luZG93LmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KCdsb2NhdGlvbi1jaGFuZ2VkJykpO1xuXG5AZWxlbWVudCBhcHAtbG9jYXRpb25cbkBkZW1vIGRlbW8vaW5kZXguaHRtbFxuLS0+XG48ZG9tLW1vZHVsZSBpZD1cImFwcC1sb2NhdGlvblwiPlxuICA8dGVtcGxhdGU+XG4gICAgPGlyb24tcXVlcnktcGFyYW1zXG4gICAgICAgIHBhcmFtcy1zdHJpbmc9XCJ7e19fcXVlcnl9fVwiXG4gICAgICAgIHBhcmFtcy1vYmplY3Q9XCJ7e3F1ZXJ5UGFyYW1zfX1cIj5cbiAgICA8L2lyb24tcXVlcnktcGFyYW1zPlxuICAgIDxpcm9uLWxvY2F0aW9uXG4gICAgICAgIHBhdGg9XCJ7e19fcGF0aH19XCJcbiAgICAgICAgcXVlcnk9XCJ7e19fcXVlcnl9fVwiXG4gICAgICAgIGhhc2g9XCJ7e19faGFzaH19XCJcbiAgICAgICAgdXJsLXNwYWNlLXJlZ2V4PXt7dXJsU3BhY2VSZWdleH19PlxuICAgIDwvaXJvbi1sb2NhdGlvbj5cbiAgPC90ZW1wbGF0ZT5cbiAgPHNjcmlwdD5cbiAgICAoZnVuY3Rpb24oKSB7XG4gICAgICAndXNlIHN0cmljdCc7XG5cbiAgICAgIFBvbHltZXIoe1xuICAgICAgICBpczogJ2FwcC1sb2NhdGlvbicsXG5cbiAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIEEgbW9kZWwgcmVwcmVzZW50aW5nIHRoZSBkZXNlcmlhbGl6ZWQgcGF0aCB0aHJvdWdoIHRoZSByb3V0ZSB0cmVlLCBhc1xuICAgICAgICAgICAqIHdlbGwgYXMgdGhlIGN1cnJlbnQgcXVlcnlQYXJhbXMuXG4gICAgICAgICAgICovXG4gICAgICAgICAgcm91dGU6IHtcbiAgICAgICAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgICAgICAgIG5vdGlmeTogdHJ1ZVxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBJbiBtYW55IHNjZW5hcmlvcywgaXQgaXMgY29udmVuaWVudCB0byB0cmVhdCB0aGUgYGhhc2hgIGFzIGEgc3RhbmQtaW5cbiAgICAgICAgICAgKiBhbHRlcm5hdGl2ZSB0byB0aGUgYHBhdGhgLiBGb3IgZXhhbXBsZSwgaWYgZGVwbG95aW5nIGFuIGFwcCB0byBhIHN0YXRpY1xuICAgICAgICAgICAqIHdlYiBzZXJ2ZXIgKGUuZy4sIEdpdGh1YiBQYWdlcykgLSB3aGVyZSBvbmUgZG9lcyBub3QgaGF2ZSBjb250cm9sIG92ZXJcbiAgICAgICAgICAgKiBzZXJ2ZXItc2lkZSByb3V0aW5nIC0gaXQgaXMgdXN1YWxseSBhIGJldHRlciBleHBlcmllbmNlIHRvIHVzZSB0aGUgaGFzaFxuICAgICAgICAgICAqIHRvIHJlcHJlc2VudCBwYXRocyB0aHJvdWdoIG9uZSdzIGFwcC5cbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIFdoZW4gdGhpcyBwcm9wZXJ0eSBpcyBzZXQgdG8gdHJ1ZSwgdGhlIGBoYXNoYCB3aWxsIGJlIHVzZWQgaW4gcGxhY2Ugb2ZcblxuICAgICAgICAgICAqIHRoZSBgcGF0aGAgZm9yIGdlbmVyYXRpbmcgYSBgcm91dGVgLlxuICAgICAgICAgICAqL1xuICAgICAgICAgIHVzZUhhc2hBc1BhdGg6IHtcbiAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogQSByZWdleHAgdGhhdCBkZWZpbmVzIHRoZSBzZXQgb2YgVVJMcyB0aGF0IHNob3VsZCBiZSBjb25zaWRlcmVkIHBhcnRcbiAgICAgICAgICAgKiBvZiB0aGlzIHdlYiBhcHAuXG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiBDbGlja2luZyBvbiBhIGxpbmsgdGhhdCBtYXRjaGVzIHRoaXMgcmVnZXggd29uJ3QgcmVzdWx0IGluIGEgZnVsbCBwYWdlXG4gICAgICAgICAgICogbmF2aWdhdGlvbiwgYnV0IHdpbGwgaW5zdGVhZCBqdXN0IHVwZGF0ZSB0aGUgVVJMIHN0YXRlIGluIHBsYWNlLlxuICAgICAgICAgICAqXG4gICAgICAgICAgICogVGhpcyByZWdleHAgaXMgZ2l2ZW4gZXZlcnl0aGluZyBhZnRlciB0aGUgb3JpZ2luIGluIGFuIGFic29sdXRlXG4gICAgICAgICAgICogVVJMLiBTbyB0byBtYXRjaCBqdXN0IFVSTHMgdGhhdCBzdGFydCB3aXRoIC9zZWFyY2gvIGRvOlxuICAgICAgICAgICAqICAgICB1cmwtc3BhY2UtcmVnZXg9XCJeL3NlYXJjaC9cIlxuICAgICAgICAgICAqXG4gICAgICAgICAgICogQHR5cGUge3N0cmluZ3xSZWdFeHB9XG4gICAgICAgICAgICovXG4gICAgICAgICAgdXJsU3BhY2VSZWdleDoge1xuICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgICAgbm90aWZ5OiB0cnVlXG4gICAgICAgICAgfSxcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIEEgc2V0IG9mIGtleS92YWx1ZSBwYWlycyB0aGF0IGFyZSB1bml2ZXJzYWxseSBhY2Nlc3NpYmxlIHRvIGJyYW5jaGVzXG4gICAgICAgICAgICogb2YgdGhlIHJvdXRlIHRyZWUuXG4gICAgICAgICAgICovXG4gICAgICAgICAgX19xdWVyeVBhcmFtczoge1xuICAgICAgICAgICAgdHlwZTogT2JqZWN0XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFRoZSBwYXRobmFtZSBjb21wb25lbnQgb2YgdGhlIGN1cnJlbnQgVVJMLlxuICAgICAgICAgICAqL1xuICAgICAgICAgIF9fcGF0aDoge1xuICAgICAgICAgICAgdHlwZTogU3RyaW5nXG4gICAgICAgICAgfSxcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFRoZSBxdWVyeSBzdHJpbmcgcG9ydGlvbiBvZiB0aGUgY3VycmVudCBVUkwuXG4gICAgICAgICAgICovXG4gICAgICAgICAgX19xdWVyeToge1xuICAgICAgICAgICAgdHlwZTogU3RyaW5nXG4gICAgICAgICAgfSxcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFRoZSBoYXNoIHBvcnRpb24gb2YgdGhlIGN1cnJlbnQgVVJMLlxuICAgICAgICAgICAqL1xuICAgICAgICAgIF9faGFzaDoge1xuICAgICAgICAgICAgdHlwZTogU3RyaW5nXG4gICAgICAgICAgfSxcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFRoZSByb3V0ZSBwYXRoLCB3aGljaCB3aWxsIGJlIGVpdGhlciB0aGUgaGFzaCBvciB0aGUgcGF0aCwgZGVwZW5kaW5nXG4gICAgICAgICAgICogb24gdXNlSGFzaEFzUGF0aC5cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBwYXRoOiB7XG4gICAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgICBvYnNlcnZlcjogJ19fb25QYXRoQ2hhbmdlZCdcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogV2hldGhlciBvciBub3QgdGhlIHJlYWR5IGZ1bmN0aW9uIGhhcyBiZWVuIGNhbGxlZC5cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBfaXNSZWFkeToge1xuICAgICAgICAgICAgdHlwZTogQm9vbGVhblxuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBiZWhhdmlvcnM6IFtQb2x5bWVyLkFwcFJvdXRlQ29udmVydGVyQmVoYXZpb3JdLFxuXG4gICAgICAgIG9ic2VydmVyczogW1xuICAgICAgICAgICdfX2NvbXB1dGVSb3V0ZVBhdGgodXNlSGFzaEFzUGF0aCwgX19oYXNoLCBfX3BhdGgpJ1xuICAgICAgICBdLFxuXG4gICAgICAgIHJlYWR5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB0aGlzLl9pc1JlYWR5ID0gdHJ1ZTtcbiAgICAgICAgfSxcblxuICAgICAgICBfX2NvbXB1dGVSb3V0ZVBhdGg6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHRoaXMucGF0aCA9IHRoaXMudXNlSGFzaEFzUGF0aCA/IHRoaXMuX19oYXNoIDogdGhpcy5fX3BhdGg7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX19vblBhdGhDaGFuZ2VkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAoIXRoaXMuX2lzUmVhZHkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodGhpcy51c2VIYXNoQXNQYXRoKSB7XG4gICAgICAgICAgICB0aGlzLl9faGFzaCA9IHRoaXMucGF0aDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fX3BhdGggPSB0aGlzLnBhdGg7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KSgpO1xuICA8L3NjcmlwdD5cbjwvZG9tLW1vZHVsZT5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvYXBwLXJvdXRlL2FwcC1sb2NhdGlvbi5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNSBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuXG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vcG9seW1lci9wb2x5bWVyLmh0bWxcIj5cblxuPCEtLVxuXG5UaGUgYGlyb24tbG9jYXRpb25gIGVsZW1lbnQgbWFuYWdlcyBiaW5kaW5nIHRvIGFuZCBmcm9tIHRoZSBjdXJyZW50IFVSTC5cblxuaXJvbi1sb2NhdGlvbiBpcyB0aGUgZmlyc3QsIGFuZCBsb3dlc3QgbGV2ZWwgZWxlbWVudCBpbiB0aGUgUG9seW1lciB0ZWFtJ3NcbnJvdXRpbmcgc3lzdGVtLiBUaGlzIGlzIGEgYmV0YSByZWxlYXNlIG9mIGlyb24tbG9jYXRpb24gYXMgd2UgY29udGludWUgd29ya1xub24gaGlnaGVyIGxldmVsIGVsZW1lbnRzLCBhbmQgYXMgc3VjaCBpcm9uLWxvY2F0aW9uIG1heSB1bmRlcmdvIGJyZWFraW5nXG5jaGFuZ2VzLlxuXG4jIyMjIFByb3BlcnRpZXNcblxuV2hlbiB0aGUgVVJMIGlzOiBgL3NlYXJjaD9xdWVyeT01ODMjZGV0YWlsc2AgaXJvbi1sb2NhdGlvbidzIHByb3BlcnRpZXMgd2lsbCBiZTpcblxuICAtIHBhdGg6IGAnL3NlYXJjaCdgXG4gIC0gcXVlcnk6IGAncXVlcnk9NTgzJ2BcbiAgLSBoYXNoOiBgJ2RldGFpbHMnYFxuXG5UaGVzZSBiaW5kaW5ncyBhcmUgYmlkaXJlY3Rpb25hbC4gTW9kaWZ5aW5nIHRoZW0gd2lsbCBpbiB0dXJuIG1vZGlmeSB0aGUgVVJMLlxuXG5pcm9uLWxvY2F0aW9uIGlzIG9ubHkgYWN0aXZlIHdoaWxlIGl0IGlzIGF0dGFjaGVkIHRvIHRoZSBkb2N1bWVudC5cblxuIyMjIyBMaW5rc1xuXG5XaGlsZSBpcm9uLWxvY2F0aW9uIGlzIGFjdGl2ZSBpbiB0aGUgZG9jdW1lbnQgaXQgd2lsbCBpbnRlcmNlcHQgY2xpY2tzIG9uIGxpbmtzXG53aXRoaW4geW91ciBzaXRlLCB1cGRhdGluZyB0aGUgVVJMIHB1c2hpbmcgdGhlIHVwZGF0ZWQgVVJMIG91dCB0aHJvdWdoIHRoZVxuZGF0YWJpbmRpbmcgc3lzdGVtLiBpcm9uLWxvY2F0aW9uIG9ubHkgaW50ZXJjZXB0cyBjbGlja3Mgd2l0aCB0aGUgaW50ZW50IHRvXG5vcGVuIGluIHRoZSBzYW1lIHdpbmRvdywgc28gbWlkZGxlIG1vdXNlIGNsaWNrcyBhbmQgY3RybC9jbWQgY2xpY2tzIHdvcmsgZmluZS5cblxuWW91IGNhbiBjdXN0b21pemUgdGhpcyBiZWhhdmlvciB3aXRoIHRoZSBgdXJsU3BhY2VSZWdleGAuXG5cbiMjIyMgRHdlbGwgVGltZVxuXG5pcm9uLWxvY2F0aW9uIHByb3RlY3RzIGFnYWluc3QgYWNjaWRlbnRhbCBoaXN0b3J5IHNwYW1taW5nIGJ5IG9ubHkgYWRkaW5nXG5lbnRyaWVzIHRvIHRoZSB1c2VyJ3MgaGlzdG9yeSBpZiB0aGUgVVJMIHN0YXlzIHVuY2hhbmdlZCBmb3IgYGR3ZWxsVGltZWBcbm1pbGxpc2Vjb25kcy5cblxuQGRlbW8gZGVtby9pbmRleC5odG1sXG5cbiAtLT5cbjxzY3JpcHQ+XG4gIChmdW5jdGlvbigpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgd29ya2luZ1VSTDtcblxuICAgIHZhciB1cmxEb2MsIHVybEJhc2UsIGFuY2hvcjtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoXG4gICAgICogQHBhcmFtIHtzdHJpbmc9fSBiYXNlXG4gICAgICogQHJldHVybiB7IVVSTHwhSFRNTEFuY2hvckVsZW1lbnR9XG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVzb2x2ZVVSTChwYXRoLCBiYXNlKSB7XG4gICAgICBpZiAod29ya2luZ1VSTCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHdvcmtpbmdVUkwgPSBmYWxzZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgdSA9IG5ldyBVUkwoJ2InLCAnaHR0cDovL2EnKTtcbiAgICAgICAgICB1LnBhdGhuYW1lID0gJ2MlMjBkJztcbiAgICAgICAgICB3b3JraW5nVVJMID0gKHUuaHJlZiA9PT0gJ2h0dHA6Ly9hL2MlMjBkJyk7XG4gICAgICAgICAgd29ya2luZ1VSTCA9IHdvcmtpbmdVUkwgJiYgKG5ldyBVUkwoJ2h0dHA6Ly93d3cuZ29vZ2xlLmNvbS8/Zm9vIGJhcicpLmhyZWYgPT09ICdodHRwOi8vd3d3Lmdvb2dsZS5jb20vP2ZvbyUyMGJhcicpO1xuICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgfVxuICAgICAgaWYgKHdvcmtpbmdVUkwpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVUkwocGF0aCwgYmFzZSk7XG4gICAgICB9XG4gICAgICBpZiAoIXVybERvYykge1xuICAgICAgICB1cmxEb2MgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoJ3VybCcpO1xuICAgICAgICB1cmxCYXNlID0gdXJsRG9jLmNyZWF0ZUVsZW1lbnQoJ2Jhc2UnKTtcbiAgICAgICAgdXJsRG9jLmhlYWQuYXBwZW5kQ2hpbGQodXJsQmFzZSk7XG4gICAgICAgIGFuY2hvciA9IC8qKiBAdHlwZSB7SFRNTEFuY2hvckVsZW1lbnR9Ki8odXJsRG9jLmNyZWF0ZUVsZW1lbnQoJ2EnKSk7XG4gICAgICB9XG4gICAgICB1cmxCYXNlLmhyZWYgPSBiYXNlO1xuICAgICAgYW5jaG9yLmhyZWYgPSBwYXRoLnJlcGxhY2UoLyAvZywgJyUyMCcpO1xuICAgICAgcmV0dXJuIGFuY2hvcjtcbiAgICB9XG5cbiAgICBQb2x5bWVyKHtcbiAgICAgIGlzOiAnaXJvbi1sb2NhdGlvbicsXG5cbiAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBwYXRobmFtZSBjb21wb25lbnQgb2YgdGhlIFVSTC5cbiAgICAgICAgICovXG4gICAgICAgIHBhdGg6IHtcbiAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgbm90aWZ5OiB0cnVlLFxuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB3aW5kb3cuZGVjb2RlVVJJQ29tcG9uZW50KHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgcXVlcnkgc3RyaW5nIHBvcnRpb24gb2YgdGhlIFVSTC5cbiAgICAgICAgICovXG4gICAgICAgIHF1ZXJ5OiB7XG4gICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgIG5vdGlmeTogdHJ1ZSxcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gd2luZG93LmxvY2F0aW9uLnNlYXJjaC5zbGljZSgxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBoYXNoIGNvbXBvbmVudCBvZiB0aGUgVVJMLlxuICAgICAgICAgKi9cbiAgICAgICAgaGFzaDoge1xuICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICBub3RpZnk6IHRydWUsXG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5kZWNvZGVVUklDb21wb25lbnQod2luZG93LmxvY2F0aW9uLmhhc2guc2xpY2UoMSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgdGhlIHVzZXIgd2FzIG9uIGEgVVJMIGZvciBsZXNzIHRoYW4gYGR3ZWxsVGltZWAgbWlsbGlzZWNvbmRzLCBpdFxuICAgICAgICAgKiB3b24ndCBiZSBhZGRlZCB0byB0aGUgYnJvd3NlcidzIGhpc3RvcnksIGJ1dCBpbnN0ZWFkIHdpbGwgYmUgcmVwbGFjZWRcbiAgICAgICAgICogYnkgdGhlIG5leHQgZW50cnkuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgaXMgdG8gcHJldmVudCBsYXJnZSBudW1iZXJzIG9mIGVudHJpZXMgZnJvbSBjbG9nZ2luZyB1cCB0aGUgdXNlcidzXG4gICAgICAgICAqIGJyb3dzZXIgaGlzdG9yeS4gRGlzYWJsZSBieSBzZXR0aW5nIHRvIGEgbmVnYXRpdmUgbnVtYmVyLlxuICAgICAgICAgKi9cbiAgICAgICAgZHdlbGxUaW1lOiB7XG4gICAgICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgICAgIHZhbHVlOiAyMDAwXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgcmVnZXhwIHRoYXQgZGVmaW5lcyB0aGUgc2V0IG9mIFVSTHMgdGhhdCBzaG91bGQgYmUgY29uc2lkZXJlZCBwYXJ0XG4gICAgICAgICAqIG9mIHRoaXMgd2ViIGFwcC5cbiAgICAgICAgICpcbiAgICAgICAgICogQ2xpY2tpbmcgb24gYSBsaW5rIHRoYXQgbWF0Y2hlcyB0aGlzIHJlZ2V4IHdvbid0IHJlc3VsdCBpbiBhIGZ1bGwgcGFnZVxuICAgICAgICAgKiBuYXZpZ2F0aW9uLCBidXQgd2lsbCBpbnN0ZWFkIGp1c3QgdXBkYXRlIHRoZSBVUkwgc3RhdGUgaW4gcGxhY2UuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgcmVnZXhwIGlzIGdpdmVuIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIG9yaWdpbiBpbiBhbiBhYnNvbHV0ZVxuICAgICAgICAgKiBVUkwuIFNvIHRvIG1hdGNoIGp1c3QgVVJMcyB0aGF0IHN0YXJ0IHdpdGggL3NlYXJjaC8gZG86XG4gICAgICAgICAqICAgICB1cmwtc3BhY2UtcmVnZXg9XCJeL3NlYXJjaC9cIlxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfFJlZ0V4cH1cbiAgICAgICAgICovXG4gICAgICAgIHVybFNwYWNlUmVnZXg6IHtcbiAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgdmFsdWU6ICcnXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHVybFNwYWNlUmVnZXgsIGJ1dCBjb2VyY2VkIGludG8gYSByZWdleHAuXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtSZWdFeHB9XG4gICAgICAgICAqL1xuICAgICAgICBfdXJsU3BhY2VSZWdFeHA6IHtcbiAgICAgICAgICBjb21wdXRlZDogJ19tYWtlUmVnRXhwKHVybFNwYWNlUmVnZXgpJ1xuICAgICAgICB9LFxuXG4gICAgICAgIF9sYXN0Q2hhbmdlZEF0OiB7XG4gICAgICAgICAgdHlwZTogTnVtYmVyXG4gICAgICAgIH0sXG5cbiAgICAgICAgX2luaXRpYWxpemVkOiB7XG4gICAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgaG9zdEF0dHJpYnV0ZXM6IHtcbiAgICAgICAgaGlkZGVuOiB0cnVlXG4gICAgICB9LFxuXG4gICAgICBvYnNlcnZlcnM6IFtcbiAgICAgICAgJ191cGRhdGVVcmwocGF0aCwgcXVlcnksIGhhc2gpJ1xuICAgICAgXSxcblxuICAgICAgYXR0YWNoZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmxpc3Rlbih3aW5kb3csICdoYXNoY2hhbmdlJywgJ19oYXNoQ2hhbmdlZCcpO1xuICAgICAgICB0aGlzLmxpc3Rlbih3aW5kb3csICdsb2NhdGlvbi1jaGFuZ2VkJywgJ191cmxDaGFuZ2VkJyk7XG4gICAgICAgIHRoaXMubGlzdGVuKHdpbmRvdywgJ3BvcHN0YXRlJywgJ191cmxDaGFuZ2VkJyk7XG4gICAgICAgIHRoaXMubGlzdGVuKC8qKiBAdHlwZSB7IUhUTUxCb2R5RWxlbWVudH0gKi8oZG9jdW1lbnQuYm9keSksICdjbGljaycsICdfZ2xvYmFsT25DbGljaycpO1xuICAgICAgICAvLyBHaXZlIGEgMjAwbXMgZ3JhY2UgcGVyaW9kIHRvIG1ha2UgaW5pdGlhbCByZWRpcmVjdHMgd2l0aG91dCBhbnlcbiAgICAgICAgLy8gYWRkaXRpb25zIHRvIHRoZSB1c2VyJ3MgaGlzdG9yeS5cbiAgICAgICAgdGhpcy5fbGFzdENoYW5nZWRBdCA9IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKSAtICh0aGlzLmR3ZWxsVGltZSAtIDIwMCk7XG4gICAgICAgIHRoaXMuX2luaXRpYWxpemVkID0gdHJ1ZTtcblxuICAgICAgICB0aGlzLl91cmxDaGFuZ2VkKCk7XG4gICAgICB9LFxuXG4gICAgICBkZXRhY2hlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMudW5saXN0ZW4od2luZG93LCAnaGFzaGNoYW5nZScsICdfaGFzaENoYW5nZWQnKTtcbiAgICAgICAgdGhpcy51bmxpc3Rlbih3aW5kb3csICdsb2NhdGlvbi1jaGFuZ2VkJywgJ191cmxDaGFuZ2VkJyk7XG4gICAgICAgIHRoaXMudW5saXN0ZW4od2luZG93LCAncG9wc3RhdGUnLCAnX3VybENoYW5nZWQnKTtcbiAgICAgICAgdGhpcy51bmxpc3RlbigvKiogQHR5cGUgeyFIVE1MQm9keUVsZW1lbnR9ICovKGRvY3VtZW50LmJvZHkpLCAnY2xpY2snLCAnX2dsb2JhbE9uQ2xpY2snKTtcbiAgICAgICAgdGhpcy5faW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICAgIH0sXG5cbiAgICAgIF9oYXNoQ2hhbmdlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuaGFzaCA9IHdpbmRvdy5kZWNvZGVVUklDb21wb25lbnQod2luZG93LmxvY2F0aW9uLmhhc2guc3Vic3RyaW5nKDEpKTtcbiAgICAgIH0sXG5cbiAgICAgIF91cmxDaGFuZ2VkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gV2Ugd2FudCB0byBleHRyYWN0IGFsbCBpbmZvIG91dCBvZiB0aGUgdXBkYXRlZCBVUkwgYmVmb3JlIHdlXG4gICAgICAgIC8vIHRyeSB0byB3cml0ZSBhbnl0aGluZyBiYWNrIGludG8gaXQuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIGkuZS4gd2l0aG91dCBfZG9udFVwZGF0ZVVybCB3ZSdkIG92ZXJ3cml0ZSB0aGUgbmV3IHBhdGggd2l0aCB0aGUgb2xkXG4gICAgICAgIC8vIG9uZSB3aGVuIHdlIHNldCB0aGlzLmhhc2guIExpa2V3aXNlIGZvciBxdWVyeS5cbiAgICAgICAgdGhpcy5fZG9udFVwZGF0ZVVybCA9IHRydWU7XG4gICAgICAgIHRoaXMuX2hhc2hDaGFuZ2VkKCk7XG4gICAgICAgIHRoaXMucGF0aCA9IHdpbmRvdy5kZWNvZGVVUklDb21wb25lbnQod2luZG93LmxvY2F0aW9uLnBhdGhuYW1lKTtcbiAgICAgICAgdGhpcy5xdWVyeSA9IHdpbmRvdy5sb2NhdGlvbi5zZWFyY2guc3Vic3RyaW5nKDEpO1xuICAgICAgICB0aGlzLl9kb250VXBkYXRlVXJsID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVVybCgpO1xuICAgICAgfSxcblxuICAgICAgX2dldFVybDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwYXJ0aWFsbHlFbmNvZGVkUGF0aCA9IHdpbmRvdy5lbmNvZGVVUkkoXG4gICAgICAgICAgICB0aGlzLnBhdGgpLnJlcGxhY2UoL1xcIy9nLCAnJTIzJykucmVwbGFjZSgvXFw/L2csICclM0YnKTtcbiAgICAgICAgdmFyIHBhcnRpYWxseUVuY29kZWRRdWVyeSA9ICcnO1xuICAgICAgICBpZiAodGhpcy5xdWVyeSkge1xuICAgICAgICAgIHBhcnRpYWxseUVuY29kZWRRdWVyeSA9ICc/JyArIHRoaXMucXVlcnkucmVwbGFjZSgvXFwjL2csICclMjMnKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcGFydGlhbGx5RW5jb2RlZEhhc2ggPSAnJztcbiAgICAgICAgaWYgKHRoaXMuaGFzaCkge1xuICAgICAgICAgIHBhcnRpYWxseUVuY29kZWRIYXNoID0gJyMnICsgd2luZG93LmVuY29kZVVSSSh0aGlzLmhhc2gpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBwYXJ0aWFsbHlFbmNvZGVkUGF0aCArIHBhcnRpYWxseUVuY29kZWRRdWVyeSArIHBhcnRpYWxseUVuY29kZWRIYXNoKTtcbiAgICAgIH0sXG5cbiAgICAgIF91cGRhdGVVcmw6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fZG9udFVwZGF0ZVVybCB8fCAhdGhpcy5faW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5wYXRoID09PSB3aW5kb3cuZGVjb2RlVVJJQ29tcG9uZW50KHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSkgJiZcbiAgICAgICAgICAgIHRoaXMucXVlcnkgPT09IHdpbmRvdy5sb2NhdGlvbi5zZWFyY2guc3Vic3RyaW5nKDEpICYmXG4gICAgICAgICAgICB0aGlzLmhhc2ggPT09IHdpbmRvdy5kZWNvZGVVUklDb21wb25lbnQoXG4gICAgICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhhc2guc3Vic3RyaW5nKDEpKSkge1xuICAgICAgICAgIC8vIE5vdGhpbmcgdG8gZG8sIHRoZSBjdXJyZW50IFVSTCBpcyBhIHJlcHJlc2VudGF0aW9uIG9mIG91ciBwcm9wZXJ0aWVzLlxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBuZXdVcmwgPSB0aGlzLl9nZXRVcmwoKTtcbiAgICAgICAgLy8gTmVlZCB0byB1c2UgYSBmdWxsIFVSTCBpbiBjYXNlIHRoZSBjb250YWluaW5nIHBhZ2UgaGFzIGEgYmFzZSBVUkkuXG4gICAgICAgIHZhciBmdWxsTmV3VXJsID0gcmVzb2x2ZVVSTChuZXdVcmwsIHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCArICcvLycgKyB3aW5kb3cubG9jYXRpb24uaG9zdCkuaHJlZjtcbiAgICAgICAgdmFyIG5vdyA9IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgdmFyIHNob3VsZFJlcGxhY2UgPSB0aGlzLl9sYXN0Q2hhbmdlZEF0ICsgdGhpcy5kd2VsbFRpbWUgPiBub3c7XG4gICAgICAgIHRoaXMuX2xhc3RDaGFuZ2VkQXQgPSBub3c7XG5cbiAgICAgICAgaWYgKHNob3VsZFJlcGxhY2UpIHtcbiAgICAgICAgICB3aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGUoe30sICcnLCBmdWxsTmV3VXJsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUoe30sICcnLCBmdWxsTmV3VXJsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZmlyZSgnbG9jYXRpb24tY2hhbmdlZCcsIHt9LCB7bm9kZTogd2luZG93fSk7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIEEgbmVjZXNzYXJ5IGV2aWwgc28gdGhhdCBsaW5rcyB3b3JrIGFzIGV4cGVjdGVkLiBEb2VzIGl0cyBiZXN0IHRvXG4gICAgICAgKiBiYWlsIG91dCBlYXJseSBpZiBwb3NzaWJsZS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGV2ZW50IC5cbiAgICAgICAqL1xuICAgICAgX2dsb2JhbE9uQ2xpY2s6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIC8vIElmIGFub3RoZXIgZXZlbnQgaGFuZGxlciBoYXMgc3RvcHBlZCB0aGlzIGV2ZW50IHRoZW4gdGhlcmUncyBub3RoaW5nXG4gICAgICAgIC8vIGZvciB1cyB0byBkby4gVGhpcyBjYW4gaGFwcGVuIGUuZy4gd2hlbiB0aGVyZSBhcmUgbXVsdGlwbGVcbiAgICAgICAgLy8gaXJvbi1sb2NhdGlvbiBlbGVtZW50cyBpbiBhIHBhZ2UuXG4gICAgICAgIGlmIChldmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGhyZWYgPSB0aGlzLl9nZXRTYW1lT3JpZ2luTGlua0hyZWYoZXZlbnQpO1xuXG4gICAgICAgIGlmICghaHJlZikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgLy8gSWYgdGhlIG5hdmlnYXRpb24gaXMgdG8gdGhlIGN1cnJlbnQgcGFnZSB3ZSBzaG91bGRuJ3QgYWRkIGEgaGlzdG9yeVxuICAgICAgICAvLyBlbnRyeSBvciBmaXJlIGEgY2hhbmdlIGV2ZW50LlxuICAgICAgICBpZiAoaHJlZiA9PT0gd2luZG93LmxvY2F0aW9uLmhyZWYpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUoe30sICcnLCBocmVmKTtcbiAgICAgICAgdGhpcy5maXJlKCdsb2NhdGlvbi1jaGFuZ2VkJywge30sIHtub2RlOiB3aW5kb3d9KTtcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogUmV0dXJucyB0aGUgYWJzb2x1dGUgVVJMIG9mIHRoZSBsaW5rIChpZiBhbnkpIHRoYXQgdGhpcyBjbGljayBldmVudFxuICAgICAgICogaXMgY2xpY2tpbmcgb24sIGlmIHdlIGNhbiBhbmQgc2hvdWxkIG92ZXJyaWRlIHRoZSByZXN1bHRpbmcgZnVsbFxuICAgICAgICogcGFnZSBuYXZpZ2F0aW9uLiBSZXR1cm5zIG51bGwgb3RoZXJ3aXNlLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZXZlbnQgLlxuICAgICAgICogQHJldHVybiB7c3RyaW5nP30gLlxuICAgICAgICovXG4gICAgICBfZ2V0U2FtZU9yaWdpbkxpbmtIcmVmOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAvLyBXZSBvbmx5IGNhcmUgYWJvdXQgbGVmdC1jbGlja3MuXG4gICAgICAgIGlmIChldmVudC5idXR0b24gIT09IDApIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdlIGRvbid0IHdhbnQgbW9kaWZpZWQgY2xpY2tzLCB3aGVyZSB0aGUgaW50ZW50IGlzIHRvIG9wZW4gdGhlIHBhZ2VcbiAgICAgICAgLy8gaW4gYSBuZXcgdGFiLlxuICAgICAgICBpZiAoZXZlbnQubWV0YUtleSB8fCBldmVudC5jdHJsS2V5KSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZXZlbnRQYXRoID0gUG9seW1lci5kb20oZXZlbnQpLnBhdGg7XG4gICAgICAgIHZhciBhbmNob3IgPSBudWxsO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXZlbnRQYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGVsZW1lbnQgPSBldmVudFBhdGhbaV07XG5cbiAgICAgICAgICBpZiAoZWxlbWVudC50YWdOYW1lID09PSAnQScgJiYgZWxlbWVudC5ocmVmKSB7XG4gICAgICAgICAgICBhbmNob3IgPSBlbGVtZW50O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgdGhlcmUncyBubyBsaW5rIHRoZXJlJ3Mgbm90aGluZyB0byBkby5cbiAgICAgICAgaWYgKCFhbmNob3IpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRhcmdldCBibGFuayBpcyBhIG5ldyB0YWIsIGRvbid0IGludGVyY2VwdC5cbiAgICAgICAgaWYgKGFuY2hvci50YXJnZXQgPT09ICdfYmxhbmsnKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGUgbGluayBpcyBmb3IgYW4gZXhpc3RpbmcgcGFyZW50IGZyYW1lLCBkb24ndCBpbnRlcmNlcHQuXG4gICAgICAgIGlmICgoYW5jaG9yLnRhcmdldCA9PT0gJ190b3AnIHx8XG4gICAgICAgICAgICBhbmNob3IudGFyZ2V0ID09PSAnX3BhcmVudCcpICYmXG4gICAgICAgICAgICB3aW5kb3cudG9wICE9PSB3aW5kb3cpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBocmVmID0gYW5jaG9yLmhyZWY7XG5cbiAgICAgICAgLy8gSXQgb25seSBtYWtlcyBzZW5zZSBmb3IgdXMgdG8gaW50ZXJjZXB0IHNhbWUtb3JpZ2luIG5hdmlnYXRpb25zLlxuICAgICAgICAvLyBwdXNoU3RhdGUvcmVwbGFjZVN0YXRlIGRvbid0IHdvcmsgd2l0aCBjcm9zcy1vcmlnaW4gbGlua3MuXG4gICAgICAgIHZhciB1cmw7XG5cbiAgICAgICAgaWYgKGRvY3VtZW50LmJhc2VVUkkgIT0gbnVsbCkge1xuICAgICAgICAgIHVybCA9IHJlc29sdmVVUkwoaHJlZiwgLyoqIEB0eXBlIHtzdHJpbmd9ICovKGRvY3VtZW50LmJhc2VVUkkpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB1cmwgPSByZXNvbHZlVVJMKGhyZWYpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG9yaWdpbjtcblxuICAgICAgICAvLyBJRSBQb2x5ZmlsbFxuICAgICAgICBpZiAod2luZG93LmxvY2F0aW9uLm9yaWdpbikge1xuICAgICAgICAgIG9yaWdpbiA9IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3JpZ2luID0gd2luZG93LmxvY2F0aW9uLnByb3RvY29sICsgJy8vJyArIHdpbmRvdy5sb2NhdGlvbi5ob3N0O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHVybE9yaWdpbjtcblxuICAgICAgICBpZiAodXJsLm9yaWdpbikge1xuICAgICAgICAgIHVybE9yaWdpbiA9IHVybC5vcmlnaW47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdXJsT3JpZ2luID0gdXJsLnByb3RvY29sICsgJy8vJyArIHVybC5ob3N0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHVybE9yaWdpbiAhPT0gb3JpZ2luKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbm9ybWFsaXplZEhyZWYgPSB1cmwucGF0aG5hbWUgKyB1cmwuc2VhcmNoICsgdXJsLmhhc2g7XG5cbiAgICAgICAgLy8gcGF0aG5hbWUgc2hvdWxkIHN0YXJ0IHdpdGggJy8nLCBidXQgbWF5IG5vdCBpZiBgbmV3IFVSTGAgaXMgbm90IHN1cHBvcnRlZFxuICAgICAgICBpZiAobm9ybWFsaXplZEhyZWZbMF0gIT09ICcvJykge1xuICAgICAgICAgIG5vcm1hbGl6ZWRIcmVmID0gJy8nICsgbm9ybWFsaXplZEhyZWY7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB3ZSd2ZSBiZWVuIGNvbmZpZ3VyZWQgbm90IHRvIGhhbmRsZSB0aGlzIHVybC4uLiBkb24ndCBoYW5kbGUgaXQhXG4gICAgICAgIGlmICh0aGlzLl91cmxTcGFjZVJlZ0V4cCAmJlxuICAgICAgICAgICAgIXRoaXMuX3VybFNwYWNlUmVnRXhwLnRlc3Qobm9ybWFsaXplZEhyZWYpKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBOZWVkIHRvIHVzZSBhIGZ1bGwgVVJMIGluIGNhc2UgdGhlIGNvbnRhaW5pbmcgcGFnZSBoYXMgYSBiYXNlIFVSSS5cbiAgICAgICAgdmFyIGZ1bGxOb3JtYWxpemVkSHJlZiA9IHJlc29sdmVVUkwoXG4gICAgICAgICAgICBub3JtYWxpemVkSHJlZiwgd2luZG93LmxvY2F0aW9uLmhyZWYpLmhyZWY7XG4gICAgICAgIHJldHVybiBmdWxsTm9ybWFsaXplZEhyZWY7XG4gICAgICB9LFxuXG4gICAgICBfbWFrZVJlZ0V4cDogZnVuY3Rpb24odXJsU3BhY2VSZWdleCkge1xuICAgICAgICByZXR1cm4gUmVnRXhwKHVybFNwYWNlUmVnZXgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KSgpO1xuPC9zY3JpcHQ+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL2lyb24tbG9jYXRpb24vaXJvbi1sb2NhdGlvbi5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNSBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcblxuQGRlbW8gZGVtby9pcm9uLXF1ZXJ5LXBhcmFtcy5odG1sXG4tLT5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi9wb2x5bWVyL3BvbHltZXIuaHRtbFwiPlxuXG48c2NyaXB0PlxuICAndXNlIHN0cmljdCc7XG5cbiAgUG9seW1lcih7XG4gICAgaXM6ICdpcm9uLXF1ZXJ5LXBhcmFtcycsXG5cbiAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICBwYXJhbXNTdHJpbmc6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICBub3RpZnk6IHRydWUsXG4gICAgICAgIG9ic2VydmVyOiAncGFyYW1zU3RyaW5nQ2hhbmdlZCcsXG4gICAgICB9LFxuXG4gICAgICBwYXJhbXNPYmplY3Q6IHtcbiAgICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgICBub3RpZnk6IHRydWUsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIF9kb250UmVhY3Q6IHtcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICB9XG4gICAgfSxcblxuICAgIGhvc3RBdHRyaWJ1dGVzOiB7XG4gICAgICBoaWRkZW46IHRydWVcbiAgICB9LFxuXG4gICAgb2JzZXJ2ZXJzOiBbXG4gICAgICAncGFyYW1zT2JqZWN0Q2hhbmdlZChwYXJhbXNPYmplY3QuKiknXG4gICAgXSxcblxuICAgIHBhcmFtc1N0cmluZ0NoYW5nZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fZG9udFJlYWN0ID0gdHJ1ZTtcbiAgICAgIHRoaXMucGFyYW1zT2JqZWN0ID0gdGhpcy5fZGVjb2RlUGFyYW1zKHRoaXMucGFyYW1zU3RyaW5nKTtcbiAgICAgIHRoaXMuX2RvbnRSZWFjdCA9IGZhbHNlO1xuICAgIH0sXG5cbiAgICBwYXJhbXNPYmplY3RDaGFuZ2VkOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLl9kb250UmVhY3QpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5wYXJhbXNTdHJpbmcgPSB0aGlzLl9lbmNvZGVQYXJhbXModGhpcy5wYXJhbXNPYmplY3QpXG4gICAgICAgICAgLnJlcGxhY2UoLyUzRi9nLCAnPycpLnJlcGxhY2UoLyUyRi9nLCAnLycpLnJlcGxhY2UoLycvZywgJyUyNycpO1xuICAgIH0sXG5cbiAgICBfZW5jb2RlUGFyYW1zOiBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgIHZhciBlbmNvZGVkUGFyYW1zID0gW107XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gcGFyYW1zW2tleV07XG5cbiAgICAgICAgaWYgKHZhbHVlID09PSAnJykge1xuICAgICAgICAgIGVuY29kZWRQYXJhbXMucHVzaChlbmNvZGVVUklDb21wb25lbnQoa2V5KSk7XG5cbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSkge1xuICAgICAgICAgIGVuY29kZWRQYXJhbXMucHVzaChcbiAgICAgICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KGtleSkgK1xuICAgICAgICAgICAgICAnPScgK1xuICAgICAgICAgICAgICBlbmNvZGVVUklDb21wb25lbnQodmFsdWUudG9TdHJpbmcoKSlcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZW5jb2RlZFBhcmFtcy5qb2luKCcmJyk7XG4gICAgfSxcblxuICAgIF9kZWNvZGVQYXJhbXM6IGZ1bmN0aW9uKHBhcmFtU3RyaW5nKSB7XG4gICAgICB2YXIgcGFyYW1zID0ge307XG4gICAgICAvLyBXb3JrIGFyb3VuZCBhIGJ1ZyBpbiBkZWNvZGVVUklDb21wb25lbnQgd2hlcmUgKyBpcyBub3RcbiAgICAgIC8vIGNvbnZlcnRlZCB0byBzcGFjZXM6XG4gICAgICBwYXJhbVN0cmluZyA9IChwYXJhbVN0cmluZyB8fCAnJykucmVwbGFjZSgvXFwrL2csICclMjAnKTtcbiAgICAgIHZhciBwYXJhbUxpc3QgPSBwYXJhbVN0cmluZy5zcGxpdCgnJicpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJhbUxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHBhcmFtID0gcGFyYW1MaXN0W2ldLnNwbGl0KCc9Jyk7XG4gICAgICAgIGlmIChwYXJhbVswXSkge1xuICAgICAgICAgIHBhcmFtc1tkZWNvZGVVUklDb21wb25lbnQocGFyYW1bMF0pXSA9XG4gICAgICAgICAgICAgIGRlY29kZVVSSUNvbXBvbmVudChwYXJhbVsxXSB8fCAnJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfVxuICB9KTtcbjwvc2NyaXB0PlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9pcm9uLWxvY2F0aW9uL2lyb24tcXVlcnktcGFyYW1zLmh0bWwiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG48c2NyaXB0PlxuICAoZnVuY3Rpb24oKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgLyoqXG4gICAgICogUHJvdmlkZXMgYmlkaXJlY3Rpb25hbCBtYXBwaW5nIGJldHdlZW4gYHBhdGhgIGFuZCBgcXVlcnlQYXJhbXNgIGFuZCBhXG4gICAgICogYXBwLXJvdXRlIGNvbXBhdGlibGUgYHJvdXRlYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgc2VlIHRoZSBkb2NzIGZvciBgYXBwLXJvdXRlLWNvbnZlcnRlcmAuXG4gICAgICpcbiAgICAgKiBAcG9seW1lckJlaGF2aW9yXG4gICAgICovXG4gICAgUG9seW1lci5BcHBSb3V0ZUNvbnZlcnRlckJlaGF2aW9yID0ge1xuICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBtb2RlbCByZXByZXNlbnRpbmcgdGhlIGRlc2VyaWFsaXplZCBwYXRoIHRocm91Z2ggdGhlIHJvdXRlIHRyZWUsIGFzXG4gICAgICAgICAqIHdlbGwgYXMgdGhlIGN1cnJlbnQgcXVlcnlQYXJhbXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEEgcm91dGUgb2JqZWN0IGlzIHRoZSBrZXJuZWwgb2YgdGhlIHJvdXRpbmcgc3lzdGVtLiBJdCBpcyBpbnRlbmRlZCB0b1xuICAgICAgICAgKiBiZSBmZWQgaW50byBjb25zdW1pbmcgZWxlbWVudHMgc3VjaCBhcyBgYXBwLXJvdXRlYC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUgez9PYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICByb3V0ZToge1xuICAgICAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgICAgICBub3RpZnk6IHRydWVcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQSBzZXQgb2Yga2V5L3ZhbHVlIHBhaXJzIHRoYXQgYXJlIHVuaXZlcnNhbGx5IGFjY2Vzc2libGUgdG8gYnJhbmNoZXMgb2ZcbiAgICAgICAgICogdGhlIHJvdXRlIHRyZWUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHs/T2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgcXVlcnlQYXJhbXM6IHtcbiAgICAgICAgICB0eXBlOiBPYmplY3QsXG4gICAgICAgICAgbm90aWZ5OiB0cnVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBzZXJpYWxpemVkIHBhdGggdGhyb3VnaCB0aGUgcm91dGUgdHJlZS4gVGhpcyBjb3JyZXNwb25kcyB0byB0aGVcbiAgICAgICAgICogYHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZWAgdmFsdWUsIGFuZCB3aWxsIHVwZGF0ZSB0byByZWZsZWN0IGNoYW5nZXNcbiAgICAgICAgICogdG8gdGhhdCB2YWx1ZS5cbiAgICAgICAgICovXG4gICAgICAgIHBhdGg6IHtcbiAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgbm90aWZ5OiB0cnVlLFxuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBvYnNlcnZlcnM6IFtcbiAgICAgICAgJ19sb2NhdGlvbkNoYW5nZWQocGF0aCwgcXVlcnlQYXJhbXMpJyxcbiAgICAgICAgJ19yb3V0ZUNoYW5nZWQocm91dGUucHJlZml4LCByb3V0ZS5wYXRoKScsXG4gICAgICAgICdfcm91dGVRdWVyeVBhcmFtc0NoYW5nZWQocm91dGUuX19xdWVyeVBhcmFtcyknXG4gICAgICBdLFxuXG4gICAgICBjcmVhdGVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5saW5rUGF0aHMoJ3JvdXRlLl9fcXVlcnlQYXJhbXMnLCAncXVlcnlQYXJhbXMnKTtcbiAgICAgICAgdGhpcy5saW5rUGF0aHMoJ3F1ZXJ5UGFyYW1zJywgJ3JvdXRlLl9fcXVlcnlQYXJhbXMnKTtcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogSGFuZGxlciBjYWxsZWQgd2hlbiB0aGUgcGF0aCBvciBxdWVyeVBhcmFtcyBjaGFuZ2UuXG4gICAgICAgKi9cbiAgICAgIF9sb2NhdGlvbkNoYW5nZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5yb3V0ZSAmJlxuICAgICAgICAgICAgdGhpcy5yb3V0ZS5wYXRoID09PSB0aGlzLnBhdGggJiZcbiAgICAgICAgICAgIHRoaXMucXVlcnlQYXJhbXMgPT09IHRoaXMucm91dGUuX19xdWVyeVBhcmFtcykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJvdXRlID0ge1xuICAgICAgICAgIHByZWZpeDogJycsXG4gICAgICAgICAgcGF0aDogdGhpcy5wYXRoLFxuICAgICAgICAgIF9fcXVlcnlQYXJhbXM6IHRoaXMucXVlcnlQYXJhbXNcbiAgICAgICAgfTtcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogSGFuZGxlciBjYWxsZWQgd2hlbiB0aGUgcm91dGUgcHJlZml4IGFuZCByb3V0ZSBwYXRoIGNoYW5nZS5cbiAgICAgICAqL1xuICAgICAgX3JvdXRlQ2hhbmdlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5yb3V0ZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucGF0aCA9IHRoaXMucm91dGUucHJlZml4ICsgdGhpcy5yb3V0ZS5wYXRoO1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBIYW5kbGVyIGNhbGxlZCB3aGVuIHRoZSByb3V0ZSBxdWVyeVBhcmFtcyBjaGFuZ2UuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtICB7T2JqZWN0fSBxdWVyeVBhcmFtcyBBIHNldCBvZiBrZXkvdmFsdWUgcGFpcnMgdGhhdCBhcmVcbiAgICAgICAqIHVuaXZlcnNhbGx5IGFjY2Vzc2libGUgdG8gYnJhbmNoZXMgb2YgdGhlIHJvdXRlIHRyZWUuXG4gICAgICAgKi9cbiAgICAgIF9yb3V0ZVF1ZXJ5UGFyYW1zQ2hhbmdlZDogZnVuY3Rpb24ocXVlcnlQYXJhbXMpIHtcbiAgICAgICAgaWYgKCF0aGlzLnJvdXRlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucXVlcnlQYXJhbXMgPSBxdWVyeVBhcmFtcztcbiAgICAgIH1cbiAgICB9O1xuICB9KSgpO1xuPC9zY3JpcHQ+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL2FwcC1yb3V0ZS9hcHAtcm91dGUtY29udmVydGVyLWJlaGF2aW9yLmh0bWwiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi9wb2x5bWVyL3BvbHltZXIuaHRtbFwiPlxuXG48IS0tXG5gYXBwLXJvdXRlYCBpcyBhbiBlbGVtZW50IHRoYXQgZW5hYmxlcyBkZWNsYXJhdGl2ZSwgc2VsZi1kZXNjcmliaW5nIHJvdXRpbmdcbmZvciBhIHdlYiBhcHAuXG5cbj4gKm4uYi4gYXBwLXJvdXRlIGlzIHN0aWxsIGluIGJldGEuIFdlIGV4cGVjdCBpdCB3aWxsIG5lZWQgc29tZSBjaGFuZ2VzLiBXZSdyZSBjb3VudGluZyBvbiB5b3VyIGZlZWRiYWNrISpcblxuSW4gaXRzIHR5cGljYWwgdXNhZ2UsIGEgYGFwcC1yb3V0ZWAgZWxlbWVudCBjb25zdW1lcyBhbiBvYmplY3QgdGhhdCBkZXNjcmliZXNcbnNvbWUgc3RhdGUgYWJvdXQgdGhlIGN1cnJlbnQgcm91dGUsIHZpYSB0aGUgYHJvdXRlYCBwcm9wZXJ0eS4gSXQgdGhlbiBwYXJzZXNcbnRoYXQgc3RhdGUgdXNpbmcgdGhlIGBwYXR0ZXJuYCBwcm9wZXJ0eSwgYW5kIHByb2R1Y2VzIHR3byBhcnRpZmFjdHM6IHNvbWUgYGRhdGFgXG5yZWxhdGVkIHRvIHRoZSBgcm91dGVgLCBhbmQgYSBgdGFpbGAgdGhhdCBjb250YWlucyB0aGUgcmVzdCBvZiB0aGUgYHJvdXRlYCB0aGF0XG5kaWQgbm90IG1hdGNoLlxuXG5IZXJlIGlzIGEgYmFzaWMgZXhhbXBsZSwgd2hlbiB1c2VkIHdpdGggYGFwcC1sb2NhdGlvbmA6XG5cbiAgICA8YXBwLWxvY2F0aW9uIHJvdXRlPVwie3tyb3V0ZX19XCI+PC9hcHAtbG9jYXRpb24+XG4gICAgPGFwcC1yb3V0ZVxuICAgICAgICByb3V0ZT1cInt7cm91dGV9fVwiXG4gICAgICAgIHBhdHRlcm49XCIvOnBhZ2VcIlxuICAgICAgICBkYXRhPVwie3tkYXRhfX1cIlxuICAgICAgICB0YWlsPVwie3t0YWlsfX1cIj5cbiAgICA8L2FwcC1yb3V0ZT5cblxuSW4gdGhlIGFib3ZlIGV4YW1wbGUsIHRoZSBgYXBwLWxvY2F0aW9uYCBwcm9kdWNlcyBhIGByb3V0ZWAgdmFsdWUuIFRoZW4sIHRoZVxuYHJvdXRlLnBhdGhgIHByb3BlcnR5IGlzIG1hdGNoZWQgYnkgY29tcGFyaW5nIGl0IHRvIHRoZSBgcGF0dGVybmAgcHJvcGVydHkuIElmXG50aGUgYHBhdHRlcm5gIHByb3BlcnR5IG1hdGNoZXMgYHJvdXRlLnBhdGhgLCB0aGUgYGFwcC1yb3V0ZWAgd2lsbCBzZXQgb3IgdXBkYXRlXG5pdHMgYGRhdGFgIHByb3BlcnR5IHdpdGggYW4gb2JqZWN0IHdob3NlIHByb3BlcnRpZXMgY29ycmVzcG9uZCB0byB0aGUgcGFyYW1ldGVyc1xuaW4gYHBhdHRlcm5gLiBTbywgaW4gdGhlIGFib3ZlIGV4YW1wbGUsIGlmIGByb3V0ZS5wYXRoYCB3YXMgYCcvYWJvdXQnYCwgdGhlIHZhbHVlXG5vZiBgZGF0YWAgd291bGQgYmUgYHtcInBhZ2VcIjogXCJhYm91dFwifWAuXG5cblRoZSBgdGFpbGAgcHJvcGVydHkgcmVwcmVzZW50cyB0aGUgcmVtYWluaW5nIHBhcnQgb2YgdGhlIHJvdXRlIHN0YXRlIGFmdGVyIHRoZVxuYHBhdHRlcm5gIGhhcyBiZWVuIGFwcGxpZWQgdG8gYSBtYXRjaGluZyBgcm91dGVgLlxuXG5IZXJlIGlzIGFub3RoZXIgZXhhbXBsZSwgd2hlcmUgYHRhaWxgIGlzIHVzZWQ6XG5cbiAgICA8YXBwLWxvY2F0aW9uIHJvdXRlPVwie3tyb3V0ZX19XCI+PC9hcHAtbG9jYXRpb24+XG4gICAgPGFwcC1yb3V0ZVxuICAgICAgICByb3V0ZT1cInt7cm91dGV9fVwiXG4gICAgICAgIHBhdHRlcm49XCIvOnBhZ2VcIlxuICAgICAgICBkYXRhPVwie3tyb3V0ZURhdGF9fVwiXG4gICAgICAgIHRhaWw9XCJ7e3N1YnJvdXRlfX1cIj5cbiAgICA8L2FwcC1yb3V0ZT5cbiAgICA8YXBwLXJvdXRlXG4gICAgICAgIHJvdXRlPVwie3tzdWJyb3V0ZX19XCJcbiAgICAgICAgcGF0dGVybj1cIi86aWRcIlxuICAgICAgICBkYXRhPVwie3tzdWJyb3V0ZURhdGF9fVwiPlxuICAgIDwvYXBwLXJvdXRlPlxuXG5JbiB0aGUgYWJvdmUgZXhhbXBsZSwgdGhlcmUgYXJlIHR3byBgYXBwLXJvdXRlYCBlbGVtZW50cy4gVGhlIGZpcnN0XG5gYXBwLXJvdXRlYCBjb25zdW1lcyBhIGByb3V0ZWAuIFdoZW4gdGhlIGByb3V0ZWAgaXMgbWF0Y2hlZCwgdGhlIGZpcnN0XG5gYXBwLXJvdXRlYCBhbHNvIHByb2R1Y2VzIGByb3V0ZURhdGFgIGZyb20gaXRzIGBkYXRhYCwgYW5kIGBzdWJyb3V0ZWAgZnJvbVxuaXRzIGB0YWlsYC4gVGhlIHNlY29uZCBgYXBwLXJvdXRlYCBjb25zdW1lcyB0aGUgYHN1YnJvdXRlYCwgYW5kIHdoZW4gaXRcbm1hdGNoZXMsIGl0IHByb2R1Y2VzIGFuIG9iamVjdCBjYWxsZWQgYHN1YnJvdXRlRGF0YWAgZnJvbSBpdHMgYGRhdGFgLlxuXG5Tbywgd2hlbiBgcm91dGUucGF0aGAgaXMgYCcvYWJvdXQnYCwgdGhlIGByb3V0ZURhdGFgIG9iamVjdCB3aWxsIGxvb2sgbGlrZVxudGhpczogYHsgcGFnZTogJ2Fib3V0JyB9YFxuXG5BbmQgYHN1YnJvdXRlRGF0YWAgd2lsbCBiZSBudWxsLiBIb3dldmVyLCBpZiBgcm91dGUucGF0aGAgY2hhbmdlcyB0b1xuYCcvYXJ0aWNsZS8xMjMnYCwgdGhlIGByb3V0ZURhdGFgIG9iamVjdCB3aWxsIGxvb2sgbGlrZSB0aGlzOlxuYHsgcGFnZTogJ2FydGljbGUnIH1gXG5cbkFuZCB0aGUgYHN1YnJvdXRlRGF0YWAgd2lsbCBsb29rIGxpa2UgdGhpczogYHsgaWQ6ICcxMjMnIH1gXG5cbmBhcHAtcm91dGVgIGlzIHJlc3BvbnNpdmUgdG8gYmktZGlyZWN0aW9uYWwgY2hhbmdlcyB0byB0aGUgYGRhdGFgIG9iamVjdHNcbnRoZXkgcHJvZHVjZS4gU28sIGlmIGByb3V0ZURhdGEucGFnZWAgY2hhbmdlZCBmcm9tIGAnYXJ0aWNsZSdgIHRvIGAnYWJvdXQnYCxcbnRoZSBgYXBwLXJvdXRlYCB3aWxsIHVwZGF0ZSBgcm91dGUucGF0aGAuIFRoaXMgaW4tdHVybiB3aWxsIHVwZGF0ZSB0aGVcbmBhcHAtbG9jYXRpb25gLCBhbmQgY2F1c2UgdGhlIGdsb2JhbCBsb2NhdGlvbiBiYXIgdG8gY2hhbmdlIGl0cyB2YWx1ZS5cblxuQGVsZW1lbnQgYXBwLXJvdXRlXG5AZGVtbyBkZW1vL2luZGV4Lmh0bWxcbkBkZW1vIGRlbW8vZGF0YS1sb2FkaW5nLWRlbW8uaHRtbFxuQGRlbW8gZGVtby9zaW1wbGUtZGVtby5odG1sXG4tLT5cblxuPHNjcmlwdD5cbiAgKGZ1bmN0aW9uKCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIFBvbHltZXIoe1xuICAgICAgaXM6ICdhcHAtcm91dGUnLFxuXG4gICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgVVJMIGNvbXBvbmVudCBtYW5hZ2VkIGJ5IHRoaXMgZWxlbWVudC5cbiAgICAgICAgICovXG4gICAgICAgIHJvdXRlOiB7XG4gICAgICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgICAgIG5vdGlmeTogdHJ1ZVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgcGF0dGVybiBvZiBzbGFzaC1zZXBhcmF0ZWQgc2VnbWVudHMgdG8gbWF0Y2ggYHJvdXRlLnBhdGhgIGFnYWluc3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBleGFtcGxlIHRoZSBwYXR0ZXJuIFwiL2Zvb1wiIHdpbGwgbWF0Y2ggXCIvZm9vXCIgb3IgXCIvZm9vL2JhclwiXG4gICAgICAgICAqIGJ1dCBub3QgXCIvZm9vYmFyXCIuXG4gICAgICAgICAqXG4gICAgICAgICAqIFBhdGggc2VnbWVudHMgbGlrZSBgLzpuYW1lZGAgYXJlIG1hcHBlZCB0byBwcm9wZXJ0aWVzIG9uIHRoZSBgZGF0YWAgb2JqZWN0LlxuICAgICAgICAgKi9cbiAgICAgICAgcGF0dGVybjoge1xuICAgICAgICAgIHR5cGU6IFN0cmluZ1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgcGFyYW1ldGVyaXplZCB2YWx1ZXMgdGhhdCBhcmUgZXh0cmFjdGVkIGZyb20gdGhlIHJvdXRlIGFzXG4gICAgICAgICAqIGRlc2NyaWJlZCBieSBgcGF0dGVybmAuXG4gICAgICAgICAqL1xuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHtyZXR1cm4ge307fSxcbiAgICAgICAgICBub3RpZnk6IHRydWVcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUgez9PYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICBxdWVyeVBhcmFtczoge1xuICAgICAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgICAgfSxcbiAgICAgICAgICBub3RpZnk6IHRydWVcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHBhcnQgb2YgYHJvdXRlLnBhdGhgIE5PVCBjb25zdW1lZCBieSBgcGF0dGVybmAuXG4gICAgICAgICAqL1xuICAgICAgICB0YWlsOiB7XG4gICAgICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHtyZXR1cm4ge3BhdGg6IG51bGwsIHByZWZpeDogbnVsbCwgX19xdWVyeVBhcmFtczogbnVsbH07fSxcbiAgICAgICAgICBub3RpZnk6IHRydWVcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGUgY3VycmVudCByb3V0ZSBpcyBhY3RpdmUuIFRydWUgaWYgYHJvdXRlLnBhdGhgIG1hdGNoZXMgdGhlXG4gICAgICAgICAqIGBwYXR0ZXJuYCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAgICAgKi9cbiAgICAgICAgYWN0aXZlOiB7XG4gICAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgICBub3RpZnk6IHRydWUsXG4gICAgICAgICAgcmVhZE9ubHk6IHRydWVcbiAgICAgICAgfSxcblxuICAgICAgICBfcXVlcnlQYXJhbXNVcGRhdGluZzoge1xuICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7P3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIF9tYXRjaGVkOiB7XG4gICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgIHZhbHVlOiAnJ1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBvYnNlcnZlcnM6IFtcbiAgICAgICAgJ19fdHJ5VG9NYXRjaChyb3V0ZS5wYXRoLCBwYXR0ZXJuKScsXG4gICAgICAgICdfX3VwZGF0ZVBhdGhPbkRhdGFDaGFuZ2UoZGF0YS4qKScsXG4gICAgICAgICdfX3RhaWxQYXRoQ2hhbmdlZCh0YWlsLnBhdGgpJyxcbiAgICAgICAgJ19fcm91dGVRdWVyeVBhcmFtc0NoYW5nZWQocm91dGUuX19xdWVyeVBhcmFtcyknLFxuICAgICAgICAnX190YWlsUXVlcnlQYXJhbXNDaGFuZ2VkKHRhaWwuX19xdWVyeVBhcmFtcyknLFxuICAgICAgICAnX19xdWVyeVBhcmFtc0NoYW5nZWQocXVlcnlQYXJhbXMuKiknXG4gICAgICBdLFxuXG4gICAgICBjcmVhdGVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5saW5rUGF0aHMoJ3JvdXRlLl9fcXVlcnlQYXJhbXMnLCAndGFpbC5fX3F1ZXJ5UGFyYW1zJyk7XG4gICAgICAgIHRoaXMubGlua1BhdGhzKCd0YWlsLl9fcXVlcnlQYXJhbXMnLCAncm91dGUuX19xdWVyeVBhcmFtcycpO1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBEZWFsIHdpdGggdGhlIHF1ZXJ5IHBhcmFtcyBvYmplY3QgYmVpbmcgYXNzaWduZWQgdG8gd2hvbGVzYWxlLlxuICAgICAgICovXG4gICAgICBfX3JvdXRlUXVlcnlQYXJhbXNDaGFuZ2VkOiBmdW5jdGlvbihxdWVyeVBhcmFtcykge1xuICAgICAgICBpZiAocXVlcnlQYXJhbXMgJiYgdGhpcy50YWlsKSB7XG4gICAgICAgICAgaWYgKHRoaXMudGFpbC5fX3F1ZXJ5UGFyYW1zICE9PSBxdWVyeVBhcmFtcykge1xuICAgICAgICAgICAgdGhpcy5zZXQoJ3RhaWwuX19xdWVyeVBhcmFtcycsIHF1ZXJ5UGFyYW1zKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIXRoaXMuYWN0aXZlIHx8IHRoaXMuX3F1ZXJ5UGFyYW1zVXBkYXRpbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBDb3B5IHF1ZXJ5UGFyYW1zIGFuZCB0cmFjayB3aGV0aGVyIHRoZXJlIGFyZSBhbnkgZGlmZmVyZW5jZXMgY29tcGFyZWRcbiAgICAgICAgICAvLyB0byB0aGUgZXhpc3RpbmcgcXVlcnkgcGFyYW1zLlxuICAgICAgICAgIHZhciBjb3B5T2ZRdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICAgIHZhciBhbnl0aGluZ0NoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gcXVlcnlQYXJhbXMpIHtcbiAgICAgICAgICAgIGNvcHlPZlF1ZXJ5UGFyYW1zW2tleV0gPSBxdWVyeVBhcmFtc1trZXldO1xuICAgICAgICAgICAgaWYgKGFueXRoaW5nQ2hhbmdlZCB8fFxuICAgICAgICAgICAgICAgICF0aGlzLnF1ZXJ5UGFyYW1zIHx8XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXNba2V5XSAhPT0gdGhpcy5xdWVyeVBhcmFtc1trZXldKSB7XG4gICAgICAgICAgICAgIGFueXRoaW5nQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIE5lZWQgdG8gY2hlY2sgd2hldGhlciBhbnkga2V5cyB3ZXJlIGRlbGV0ZWRcbiAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5xdWVyeVBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFueXRoaW5nQ2hhbmdlZCB8fCAhKGtleSBpbiBxdWVyeVBhcmFtcykpIHtcbiAgICAgICAgICAgICAgYW55dGhpbmdDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFhbnl0aGluZ0NoYW5nZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fcXVlcnlQYXJhbXNVcGRhdGluZyA9IHRydWU7XG4gICAgICAgICAgdGhpcy5zZXQoJ3F1ZXJ5UGFyYW1zJywgY29weU9mUXVlcnlQYXJhbXMpO1xuICAgICAgICAgIHRoaXMuX3F1ZXJ5UGFyYW1zVXBkYXRpbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgX190YWlsUXVlcnlQYXJhbXNDaGFuZ2VkOiBmdW5jdGlvbihxdWVyeVBhcmFtcykge1xuICAgICAgICBpZiAocXVlcnlQYXJhbXMgJiYgdGhpcy5yb3V0ZSAmJiB0aGlzLnJvdXRlLl9fcXVlcnlQYXJhbXMgIT0gcXVlcnlQYXJhbXMpIHtcbiAgICAgICAgICB0aGlzLnNldCgncm91dGUuX19xdWVyeVBhcmFtcycsIHF1ZXJ5UGFyYW1zKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgX19xdWVyeVBhcmFtc0NoYW5nZWQ6IGZ1bmN0aW9uKGNoYW5nZXMpIHtcbiAgICAgICAgaWYgKCF0aGlzLmFjdGl2ZSB8fCB0aGlzLl9xdWVyeVBhcmFtc1VwZGF0aW5nKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zZXQoJ3JvdXRlLl9fJyArIGNoYW5nZXMucGF0aCwgY2hhbmdlcy52YWx1ZSk7XG4gICAgICB9LFxuXG4gICAgICBfX3Jlc2V0UHJvcGVydGllczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX3NldEFjdGl2ZShmYWxzZSk7XG4gICAgICAgIHRoaXMuX21hdGNoZWQgPSBudWxsO1xuICAgICAgfSxcblxuICAgICAgX190cnlUb01hdGNoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLnJvdXRlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBhdGggPSB0aGlzLnJvdXRlLnBhdGg7XG4gICAgICAgIHZhciBwYXR0ZXJuID0gdGhpcy5wYXR0ZXJuO1xuXG4gICAgICAgIGlmICghcGF0dGVybikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcGF0aCkge1xuICAgICAgICAgIHRoaXMuX19yZXNldFByb3BlcnRpZXMoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVtYWluaW5nUGllY2VzID0gcGF0aC5zcGxpdCgnLycpO1xuICAgICAgICB2YXIgcGF0dGVyblBpZWNlcyA9IHBhdHRlcm4uc3BsaXQoJy8nKTtcblxuICAgICAgICB2YXIgbWF0Y2hlZCA9IFtdO1xuICAgICAgICB2YXIgbmFtZWRNYXRjaGVzID0ge307XG5cbiAgICAgICAgZm9yICh2YXIgaT0wOyBpIDwgcGF0dGVyblBpZWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBwYXR0ZXJuUGllY2UgPSBwYXR0ZXJuUGllY2VzW2ldO1xuICAgICAgICAgIGlmICghcGF0dGVyblBpZWNlICYmIHBhdHRlcm5QaWVjZSAhPT0gJycpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgcGF0aFBpZWNlID0gcmVtYWluaW5nUGllY2VzLnNoaWZ0KCk7XG5cbiAgICAgICAgICAvLyBXZSBkb24ndCBtYXRjaCB0aGlzIHBhdGguXG4gICAgICAgICAgaWYgKCFwYXRoUGllY2UgJiYgcGF0aFBpZWNlICE9PSAnJykge1xuICAgICAgICAgICAgdGhpcy5fX3Jlc2V0UHJvcGVydGllcygpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtYXRjaGVkLnB1c2gocGF0aFBpZWNlKTtcblxuICAgICAgICAgIGlmIChwYXR0ZXJuUGllY2UuY2hhckF0KDApID09ICc6Jykge1xuICAgICAgICAgICAgbmFtZWRNYXRjaGVzW3BhdHRlcm5QaWVjZS5zbGljZSgxKV0gPSBwYXRoUGllY2U7XG4gICAgICAgICAgfSBlbHNlIGlmIChwYXR0ZXJuUGllY2UgIT09IHBhdGhQaWVjZSkge1xuICAgICAgICAgICAgdGhpcy5fX3Jlc2V0UHJvcGVydGllcygpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX21hdGNoZWQgPSBtYXRjaGVkLmpvaW4oJy8nKTtcblxuICAgICAgICAvLyBQcm9wZXJ0aWVzIHRoYXQgbXVzdCBiZSB1cGRhdGVkIGF0b21pY2FsbHkuXG4gICAgICAgIHZhciBwcm9wZXJ0eVVwZGF0ZXMgPSB7fTtcblxuICAgICAgICAvL3RoaXMuYWN0aXZlXG4gICAgICAgIGlmICghdGhpcy5hY3RpdmUpIHtcbiAgICAgICAgICBwcm9wZXJ0eVVwZGF0ZXMuYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRoaXMudGFpbFxuICAgICAgICB2YXIgdGFpbFByZWZpeCA9IHRoaXMucm91dGUucHJlZml4ICsgdGhpcy5fbWF0Y2hlZDtcbiAgICAgICAgdmFyIHRhaWxQYXRoID0gcmVtYWluaW5nUGllY2VzLmpvaW4oJy8nKTtcbiAgICAgICAgaWYgKHJlbWFpbmluZ1BpZWNlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdGFpbFBhdGggPSAnLycgKyB0YWlsUGF0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMudGFpbCB8fFxuICAgICAgICAgICAgdGhpcy50YWlsLnByZWZpeCAhPT0gdGFpbFByZWZpeCB8fFxuICAgICAgICAgICAgdGhpcy50YWlsLnBhdGggIT09IHRhaWxQYXRoKSB7XG4gICAgICAgICAgcHJvcGVydHlVcGRhdGVzLnRhaWwgPSB7XG4gICAgICAgICAgICBwcmVmaXg6IHRhaWxQcmVmaXgsXG4gICAgICAgICAgICBwYXRoOiB0YWlsUGF0aCxcbiAgICAgICAgICAgIF9fcXVlcnlQYXJhbXM6IHRoaXMucm91dGUuX19xdWVyeVBhcmFtc1xuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0aGlzLmRhdGFcbiAgICAgICAgcHJvcGVydHlVcGRhdGVzLmRhdGEgPSBuYW1lZE1hdGNoZXM7XG4gICAgICAgIHRoaXMuX2RhdGFJblVybCA9IHt9O1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gbmFtZWRNYXRjaGVzKSB7XG4gICAgICAgICAgdGhpcy5fZGF0YUluVXJsW2tleV0gPSBuYW1lZE1hdGNoZXNba2V5XTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnNldFByb3BlcnRpZXMpIHtcbiAgICAgICAgICBpZiAoIXRoaXMuYWN0aXZlKSB7XG4gICAgICAgICAgICB0aGlzLl9zZXRBY3RpdmUodHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGF0b21pYyB1cGRhdGVcbiAgICAgICAgICB0aGlzLnNldFByb3BlcnRpZXMocHJvcGVydHlVcGRhdGVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9fc2V0TXVsdGkocHJvcGVydHlVcGRhdGVzKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgX190YWlsUGF0aENoYW5nZWQ6IGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmFjdGl2ZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdGFpbFBhdGggPSBwYXRoO1xuICAgICAgICB2YXIgbmV3UGF0aCA9IHRoaXMuX21hdGNoZWQ7XG4gICAgICAgIGlmICh0YWlsUGF0aCkge1xuICAgICAgICAgIGlmICh0YWlsUGF0aC5jaGFyQXQoMCkgIT09ICcvJykge1xuICAgICAgICAgICAgdGFpbFBhdGggPSAnLycgKyB0YWlsUGF0aDtcbiAgICAgICAgICB9XG4gICAgICAgICAgbmV3UGF0aCArPSB0YWlsUGF0aDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldCgncm91dGUucGF0aCcsIG5ld1BhdGgpO1xuICAgICAgfSxcblxuICAgICAgX191cGRhdGVQYXRoT25EYXRhQ2hhbmdlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLnJvdXRlIHx8ICF0aGlzLmFjdGl2ZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmV3UGF0aCA9IHRoaXMuX19nZXRMaW5rKHt9KTtcbiAgICAgICAgdmFyIG9sZFBhdGggPSB0aGlzLl9fZ2V0TGluayh0aGlzLl9kYXRhSW5VcmwpO1xuICAgICAgICBpZiAobmV3UGF0aCA9PT0gb2xkUGF0aCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldCgncm91dGUucGF0aCcsIG5ld1BhdGgpO1xuICAgICAgfSxcblxuICAgICAgX19nZXRMaW5rOiBmdW5jdGlvbihvdmVycmlkZVZhbHVlcykge1xuICAgICAgICB2YXIgdmFsdWVzID0ge3RhaWw6IG51bGx9O1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5kYXRhKSB7XG4gICAgICAgICAgdmFsdWVzW2tleV0gPSB0aGlzLmRhdGFba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gb3ZlcnJpZGVWYWx1ZXMpIHtcbiAgICAgICAgICB2YWx1ZXNba2V5XSA9IG92ZXJyaWRlVmFsdWVzW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBhdHRlcm5QaWVjZXMgPSB0aGlzLnBhdHRlcm4uc3BsaXQoJy8nKTtcbiAgICAgICAgdmFyIGludGVycCA9IHBhdHRlcm5QaWVjZXMubWFwKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgaWYgKHZhbHVlWzBdID09ICc6Jykge1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZXNbdmFsdWUuc2xpY2UoMSldO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgICBpZiAodmFsdWVzLnRhaWwgJiYgdmFsdWVzLnRhaWwucGF0aCkge1xuICAgICAgICAgIGlmIChpbnRlcnAubGVuZ3RoID4gMCAmJiB2YWx1ZXMudGFpbC5wYXRoLmNoYXJBdCgwKSA9PT0gJy8nKSB7XG4gICAgICAgICAgICBpbnRlcnAucHVzaCh2YWx1ZXMudGFpbC5wYXRoLnNsaWNlKDEpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW50ZXJwLnB1c2godmFsdWVzLnRhaWwucGF0aCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnRlcnAuam9pbignLycpO1xuICAgICAgfSxcblxuICAgICAgX19zZXRNdWx0aTogZnVuY3Rpb24oc2V0T2JqKSB7XG4gICAgICAgIC8vIEhBQ0socmljdGljKTogc2tpcnRpbmcgYXJvdW5kIDEuMCdzIGxhY2sgb2YgYSBzZXRNdWx0aSBieSBwb2tpbmcgYXRcbiAgICAgICAgLy8gICAgIGludGVybmFsIGRhdGEgc3RydWN0dXJlcy4gSSB3b3VsZCBub3QgYWR2aXNlIHRoYXQgeW91IGNvcHkgdGhpc1xuICAgICAgICAvLyAgICAgZXhhbXBsZS5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gICAgIEluIHRoZSBmdXR1cmUgdGhpcyB3aWxsIGJlIGEgZmVhdHVyZSBvZiBQb2x5bWVyIGl0c2VsZi5cbiAgICAgICAgLy8gICAgIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL1BvbHltZXIvcG9seW1lci9pc3N1ZXMvMzY0MFxuICAgICAgICAvL1xuICAgICAgICAvLyAgICAgSGFja2luZyBhcm91bmQgd2l0aCBwcml2YXRlIG1ldGhvZHMgbGlrZSB0aGlzIGlzIGp1Z2dsaW5nIGZvb3RndW5zLFxuICAgICAgICAvLyAgICAgYW5kIGlzIGxpa2VseSB0byBoYXZlIHVuZXhwZWN0ZWQgYW5kIHVuc3VwcG9ydGVkIHJvdWdoIGVkZ2VzLlxuICAgICAgICAvL1xuICAgICAgICAvLyAgICAgQmUgeWUgc28gd2FybmVkLlxuICAgICAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiBzZXRPYmopIHtcbiAgICAgICAgICB0aGlzLl9wcm9wZXJ0eVNldHRlcihwcm9wZXJ0eSwgc2V0T2JqW3Byb3BlcnR5XSk7XG4gICAgICAgIH1cbiAgICAgICAgLy9ub3RpZnkgaW4gYSBzcGVjaWZpYyBvcmRlclxuICAgICAgICBpZiAoc2V0T2JqLmRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMuX3BhdGhFZmZlY3RvcignZGF0YScsIHRoaXMuZGF0YSk7XG4gICAgICAgICAgdGhpcy5fbm90aWZ5Q2hhbmdlKCdkYXRhJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNldE9iai5hY3RpdmUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMuX3BhdGhFZmZlY3RvcignYWN0aXZlJywgdGhpcy5hY3RpdmUpO1xuICAgICAgICAgIHRoaXMuX25vdGlmeUNoYW5nZSgnYWN0aXZlJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNldE9iai50YWlsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLl9wYXRoRWZmZWN0b3IoJ3RhaWwnLCB0aGlzLnRhaWwpO1xuICAgICAgICAgIHRoaXMuX25vdGlmeUNoYW5nZSgndGFpbCcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH0pKCk7XG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvYXBwLXJvdXRlL2FwcC1yb3V0ZS5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNSBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuXG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vcG9seW1lci9wb2x5bWVyLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi9pcm9uLXJlc2l6YWJsZS1iZWhhdmlvci9pcm9uLXJlc2l6YWJsZS1iZWhhdmlvci5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vaXJvbi1zZWxlY3Rvci9pcm9uLXNlbGVjdGFibGUuaHRtbFwiPlxuXG48IS0tXG5gaXJvbi1wYWdlc2AgaXMgdXNlZCB0byBzZWxlY3Qgb25lIG9mIGl0cyBjaGlsZHJlbiB0byBzaG93LiBPbmUgdXNlIGlzIHRvIGN5Y2xlIHRocm91Z2ggYSBsaXN0IG9mXG5jaGlsZHJlbiBcInBhZ2VzXCIuXG5cbkV4YW1wbGU6XG5cbiAgICA8aXJvbi1wYWdlcyBzZWxlY3RlZD1cIjBcIj5cbiAgICAgIDxkaXY+T25lPC9kaXY+XG4gICAgICA8ZGl2PlR3bzwvZGl2PlxuICAgICAgPGRpdj5UaHJlZTwvZGl2PlxuICAgIDwvaXJvbi1wYWdlcz5cblxuICAgIDxzY3JpcHQ+XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdmFyIHBhZ2VzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignaXJvbi1wYWdlcycpO1xuICAgICAgICBwYWdlcy5zZWxlY3ROZXh0KCk7XG4gICAgICB9KTtcbiAgICA8L3NjcmlwdD5cblxuQGdyb3VwIElyb24gRWxlbWVudHNcbkBoZXJvIGhlcm8uc3ZnXG5AZGVtbyBkZW1vL2luZGV4Lmh0bWxcbi0tPlxuXG48ZG9tLW1vZHVsZSBpZD1cImlyb24tcGFnZXNcIj5cblxuICA8dGVtcGxhdGU+XG4gICAgPHN0eWxlPlxuICAgICAgOmhvc3Qge1xuICAgICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgIH1cblxuICAgICAgOmhvc3QgPiA6OnNsb3R0ZWQoOm5vdCguaXJvbi1zZWxlY3RlZCkpIHtcbiAgICAgICAgZGlzcGxheTogbm9uZSAhaW1wb3J0YW50O1xuICAgICAgfVxuICAgIDwvc3R5bGU+XG5cbiAgICA8c2xvdD48L3Nsb3Q+XG4gIDwvdGVtcGxhdGU+XG5cbiAgPHNjcmlwdD5cbiAgICBQb2x5bWVyKHtcblxuICAgICAgaXM6ICdpcm9uLXBhZ2VzJyxcblxuICAgICAgYmVoYXZpb3JzOiBbXG4gICAgICAgIFBvbHltZXIuSXJvblJlc2l6YWJsZUJlaGF2aW9yLFxuICAgICAgICBQb2x5bWVyLklyb25TZWxlY3RhYmxlQmVoYXZpb3JcbiAgICAgIF0sXG5cbiAgICAgIHByb3BlcnRpZXM6IHtcblxuICAgICAgICAvLyBhcyB0aGUgc2VsZWN0ZWQgcGFnZSBpcyB0aGUgb25seSBvbmUgdmlzaWJsZSwgYWN0aXZhdGVFdmVudFxuICAgICAgICAvLyBpcyBib3RoIG5vbi1zZW5zaWNhbCBhbmQgcHJvYmxlbWF0aWM7IGUuZy4gaW4gY2FzZXMgd2hlcmUgYSB1c2VyXG4gICAgICAgIC8vIGhhbmRsZXIgYXR0ZW1wdHMgdG8gY2hhbmdlIHRoZSBwYWdlIGFuZCB0aGUgYWN0aXZhdGVFdmVudFxuICAgICAgICAvLyBoYW5kbGVyIGltbWVkaWF0ZWx5IGNoYW5nZXMgaXQgYmFja1xuICAgICAgICBhY3RpdmF0ZUV2ZW50OiB7XG4gICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgIHZhbHVlOiBudWxsXG4gICAgICAgIH1cblxuICAgICAgfSxcblxuICAgICAgb2JzZXJ2ZXJzOiBbXG4gICAgICAgICdfc2VsZWN0ZWRQYWdlQ2hhbmdlZChzZWxlY3RlZCknXG4gICAgICBdLFxuXG4gICAgICBfc2VsZWN0ZWRQYWdlQ2hhbmdlZDogZnVuY3Rpb24oc2VsZWN0ZWQsIG9sZCkge1xuICAgICAgICB0aGlzLmFzeW5jKHRoaXMubm90aWZ5UmVzaXplKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICA8L3NjcmlwdD5cbjwvZG9tLW1vZHVsZT5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvaXJvbi1wYWdlcy9pcm9uLXBhZ2VzLmh0bWwiLCJcbjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTUgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cblxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3BvbHltZXIvcG9seW1lci5odG1sXCI+XG5cbjxzY3JpcHQ+XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IUZ1bmN0aW9ufSBzZWxlY3RDYWxsYmFja1xuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG4gIFBvbHltZXIuSXJvblNlbGVjdGlvbiA9IGZ1bmN0aW9uKHNlbGVjdENhbGxiYWNrKSB7XG4gICAgdGhpcy5zZWxlY3Rpb24gPSBbXTtcbiAgICB0aGlzLnNlbGVjdENhbGxiYWNrID0gc2VsZWN0Q2FsbGJhY2s7XG4gIH07XG5cbiAgUG9seW1lci5Jcm9uU2VsZWN0aW9uLnByb3RvdHlwZSA9IHtcblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgc2VsZWN0ZWQgaXRlbShzKS5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgZ2V0XG4gICAgICogQHJldHVybnMgUmV0dXJucyB0aGUgc2VsZWN0ZWQgaXRlbShzKS4gSWYgdGhlIG11bHRpIHByb3BlcnR5IGlzIHRydWUsXG4gICAgICogYGdldGAgd2lsbCByZXR1cm4gYW4gYXJyYXksIG90aGVyd2lzZSBpdCB3aWxsIHJldHVyblxuICAgICAqIHRoZSBzZWxlY3RlZCBpdGVtIG9yIHVuZGVmaW5lZCBpZiB0aGVyZSBpcyBubyBzZWxlY3Rpb24uXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLm11bHRpID8gdGhpcy5zZWxlY3Rpb24uc2xpY2UoKSA6IHRoaXMuc2VsZWN0aW9uWzBdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgYWxsIHRoZSBzZWxlY3Rpb24gZXhjZXB0IHRoZSBvbmVzIGluZGljYXRlZC5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgY2xlYXJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBleGNsdWRlcyBpdGVtcyB0byBiZSBleGNsdWRlZC5cbiAgICAgKi9cbiAgICBjbGVhcjogZnVuY3Rpb24oZXhjbHVkZXMpIHtcbiAgICAgIHRoaXMuc2VsZWN0aW9uLnNsaWNlKCkuZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgIGlmICghZXhjbHVkZXMgfHwgZXhjbHVkZXMuaW5kZXhPZihpdGVtKSA8IDApIHtcbiAgICAgICAgICB0aGlzLnNldEl0ZW1TZWxlY3RlZChpdGVtLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH0sIHRoaXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgaWYgYSBnaXZlbiBpdGVtIGlzIHNlbGVjdGVkLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBpc1NlbGVjdGVkXG4gICAgICogQHBhcmFtIHsqfSBpdGVtIFRoZSBpdGVtIHdob3NlIHNlbGVjdGlvbiBzdGF0ZSBzaG91bGQgYmUgY2hlY2tlZC5cbiAgICAgKiBAcmV0dXJucyBSZXR1cm5zIHRydWUgaWYgYGl0ZW1gIGlzIHNlbGVjdGVkLlxuICAgICAqL1xuICAgIGlzU2VsZWN0ZWQ6IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgIHJldHVybiB0aGlzLnNlbGVjdGlvbi5pbmRleE9mKGl0ZW0pID49IDA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHNlbGVjdGlvbiBzdGF0ZSBmb3IgYSBnaXZlbiBpdGVtIHRvIGVpdGhlciBzZWxlY3RlZCBvciBkZXNlbGVjdGVkLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBzZXRJdGVtU2VsZWN0ZWRcbiAgICAgKiBAcGFyYW0geyp9IGl0ZW0gVGhlIGl0ZW0gdG8gc2VsZWN0LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNTZWxlY3RlZCBUcnVlIGZvciBzZWxlY3RlZCwgZmFsc2UgZm9yIGRlc2VsZWN0ZWQuXG4gICAgICovXG4gICAgc2V0SXRlbVNlbGVjdGVkOiBmdW5jdGlvbihpdGVtLCBpc1NlbGVjdGVkKSB7XG4gICAgICBpZiAoaXRlbSAhPSBudWxsKSB7XG4gICAgICAgIGlmIChpc1NlbGVjdGVkICE9PSB0aGlzLmlzU2VsZWN0ZWQoaXRlbSkpIHtcbiAgICAgICAgICAvLyBwcm9jZWVkIHRvIHVwZGF0ZSBzZWxlY3Rpb24gb25seSBpZiByZXF1ZXN0ZWQgc3RhdGUgZGlmZmVycyBmcm9tIGN1cnJlbnRcbiAgICAgICAgICBpZiAoaXNTZWxlY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24ucHVzaChpdGVtKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGkgPSB0aGlzLnNlbGVjdGlvbi5pbmRleE9mKGl0ZW0pO1xuICAgICAgICAgICAgaWYgKGkgPj0gMCkge1xuICAgICAgICAgICAgICB0aGlzLnNlbGVjdGlvbi5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLnNlbGVjdENhbGxiYWNrKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdENhbGxiYWNrKGl0ZW0sIGlzU2VsZWN0ZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBzZWxlY3Rpb24gc3RhdGUgZm9yIGEgZ2l2ZW4gaXRlbS4gSWYgdGhlIGBtdWx0aWAgcHJvcGVydHlcbiAgICAgKiBpcyB0cnVlLCB0aGVuIHRoZSBzZWxlY3RlZCBzdGF0ZSBvZiBgaXRlbWAgd2lsbCBiZSB0b2dnbGVkOyBvdGhlcndpc2VcbiAgICAgKiB0aGUgYGl0ZW1gIHdpbGwgYmUgc2VsZWN0ZWQuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHNlbGVjdFxuICAgICAqIEBwYXJhbSB7Kn0gaXRlbSBUaGUgaXRlbSB0byBzZWxlY3QuXG4gICAgICovXG4gICAgc2VsZWN0OiBmdW5jdGlvbihpdGVtKSB7XG4gICAgICBpZiAodGhpcy5tdWx0aSkge1xuICAgICAgICB0aGlzLnRvZ2dsZShpdGVtKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5nZXQoKSAhPT0gaXRlbSkge1xuICAgICAgICB0aGlzLnNldEl0ZW1TZWxlY3RlZCh0aGlzLmdldCgpLCBmYWxzZSk7XG4gICAgICAgIHRoaXMuc2V0SXRlbVNlbGVjdGVkKGl0ZW0sIHRydWUpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUb2dnbGVzIHRoZSBzZWxlY3Rpb24gc3RhdGUgZm9yIGBpdGVtYC5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgdG9nZ2xlXG4gICAgICogQHBhcmFtIHsqfSBpdGVtIFRoZSBpdGVtIHRvIHRvZ2dsZS5cbiAgICAgKi9cbiAgICB0b2dnbGU6IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgIHRoaXMuc2V0SXRlbVNlbGVjdGVkKGl0ZW0sICF0aGlzLmlzU2VsZWN0ZWQoaXRlbSkpO1xuICAgIH1cblxuICB9O1xuXG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvaXJvbi1zZWxlY3Rvci9pcm9uLXNlbGVjdGlvbi5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNSBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuXG5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi9wb2x5bWVyL3BvbHltZXIuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cImlyb24tbXVsdGktc2VsZWN0YWJsZS5odG1sXCI+XG5cbjxzY3JpcHQ+XG4gIC8qKlxuICBgaXJvbi1zZWxlY3RvcmAgaXMgYW4gZWxlbWVudCB3aGljaCBjYW4gYmUgdXNlZCB0byBtYW5hZ2UgYSBsaXN0IG9mIGVsZW1lbnRzXG4gIHRoYXQgY2FuIGJlIHNlbGVjdGVkLiAgVGFwcGluZyBvbiB0aGUgaXRlbSB3aWxsIG1ha2UgdGhlIGl0ZW0gc2VsZWN0ZWQuICBUaGUgYHNlbGVjdGVkYCBpbmRpY2F0ZXNcbiAgd2hpY2ggaXRlbSBpcyBiZWluZyBzZWxlY3RlZC4gIFRoZSBkZWZhdWx0IGlzIHRvIHVzZSB0aGUgaW5kZXggb2YgdGhlIGl0ZW0uXG5cbiAgRXhhbXBsZTpcblxuICAgICAgPGlyb24tc2VsZWN0b3Igc2VsZWN0ZWQ9XCIwXCI+XG4gICAgICAgIDxkaXY+SXRlbSAxPC9kaXY+XG4gICAgICAgIDxkaXY+SXRlbSAyPC9kaXY+XG4gICAgICAgIDxkaXY+SXRlbSAzPC9kaXY+XG4gICAgICA8L2lyb24tc2VsZWN0b3I+XG5cbiAgSWYgeW91IHdhbnQgdG8gdXNlIHRoZSBhdHRyaWJ1dGUgdmFsdWUgb2YgYW4gZWxlbWVudCBmb3IgYHNlbGVjdGVkYCBpbnN0ZWFkIG9mIHRoZSBpbmRleCxcbiAgc2V0IGBhdHRyRm9yU2VsZWN0ZWRgIHRvIHRoZSBuYW1lIG9mIHRoZSBhdHRyaWJ1dGUuICBGb3IgZXhhbXBsZSwgaWYgeW91IHdhbnQgdG8gc2VsZWN0IGl0ZW0gYnlcbiAgYG5hbWVgLCBzZXQgYGF0dHJGb3JTZWxlY3RlZGAgdG8gYG5hbWVgLlxuXG4gIEV4YW1wbGU6XG5cbiAgICAgIDxpcm9uLXNlbGVjdG9yIGF0dHItZm9yLXNlbGVjdGVkPVwibmFtZVwiIHNlbGVjdGVkPVwiZm9vXCI+XG4gICAgICAgIDxkaXYgbmFtZT1cImZvb1wiPkZvbzwvZGl2PlxuICAgICAgICA8ZGl2IG5hbWU9XCJiYXJcIj5CYXI8L2Rpdj5cbiAgICAgICAgPGRpdiBuYW1lPVwiem90XCI+Wm90PC9kaXY+XG4gICAgICA8L2lyb24tc2VsZWN0b3I+XG5cbiAgWW91IGNhbiBzcGVjaWZ5IGEgZGVmYXVsdCBmYWxsYmFjayB3aXRoIGBmYWxsYmFja1NlbGVjdGlvbmAgaW4gY2FzZSB0aGUgYHNlbGVjdGVkYCBhdHRyaWJ1dGUgZG9lc1xuICBub3QgbWF0Y2ggdGhlIGBhdHRyRm9yU2VsZWN0ZWRgIGF0dHJpYnV0ZSBvZiBhbnkgZWxlbWVudHMuXG5cbiAgRXhhbXBsZTpcblxuICAgICAgICA8aXJvbi1zZWxlY3RvciBhdHRyLWZvci1zZWxlY3RlZD1cIm5hbWVcIiBzZWxlY3RlZD1cIm5vbi1leGlzdGluZ1wiXG4gICAgICAgICAgICAgICAgICAgICAgIGZhbGxiYWNrLXNlbGVjdGlvbj1cImRlZmF1bHRcIj5cbiAgICAgICAgICA8ZGl2IG5hbWU9XCJmb29cIj5Gb288L2Rpdj5cbiAgICAgICAgICA8ZGl2IG5hbWU9XCJiYXJcIj5CYXI8L2Rpdj5cbiAgICAgICAgICA8ZGl2IG5hbWU9XCJkZWZhdWx0XCI+RGVmYXVsdDwvZGl2PlxuICAgICAgICA8L2lyb24tc2VsZWN0b3I+XG5cbiAgTm90ZTogV2hlbiB0aGUgc2VsZWN0b3IgaXMgbXVsdGksIHRoZSBzZWxlY3Rpb24gd2lsbCBzZXQgdG8gYGZhbGxiYWNrU2VsZWN0aW9uYCBpZmZcbiAgdGhlIG51bWJlciBvZiBtYXRjaGluZyBlbGVtZW50cyBpcyB6ZXJvLlxuXG4gIGBpcm9uLXNlbGVjdG9yYCBpcyBub3Qgc3R5bGVkLiBVc2UgdGhlIGBpcm9uLXNlbGVjdGVkYCBDU1MgY2xhc3MgdG8gc3R5bGUgdGhlIHNlbGVjdGVkIGVsZW1lbnQuXG5cbiAgRXhhbXBsZTpcblxuICAgICAgPHN0eWxlPlxuICAgICAgICAuaXJvbi1zZWxlY3RlZCB7XG4gICAgICAgICAgYmFja2dyb3VuZDogI2VlZTtcbiAgICAgICAgfVxuICAgICAgPC9zdHlsZT5cblxuICAgICAgLi4uXG5cbiAgICAgIDxpcm9uLXNlbGVjdG9yIHNlbGVjdGVkPVwiMFwiPlxuICAgICAgICA8ZGl2Pkl0ZW0gMTwvZGl2PlxuICAgICAgICA8ZGl2Pkl0ZW0gMjwvZGl2PlxuICAgICAgICA8ZGl2Pkl0ZW0gMzwvZGl2PlxuICAgICAgPC9pcm9uLXNlbGVjdG9yPlxuXG4gIEBkZW1vIGRlbW8vaW5kZXguaHRtbFxuICAqL1xuXG4gIFBvbHltZXIoe1xuXG4gICAgaXM6ICdpcm9uLXNlbGVjdG9yJyxcblxuICAgIGJlaGF2aW9yczogW1xuICAgICAgUG9seW1lci5Jcm9uTXVsdGlTZWxlY3RhYmxlQmVoYXZpb3JcbiAgICBdXG5cbiAgfSk7XG5cbjwvc2NyaXB0PlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9pcm9uLXNlbGVjdG9yL2lyb24tc2VsZWN0b3IuaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTUgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cblxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3BvbHltZXIvcG9seW1lci5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiaXJvbi1zZWxlY3RhYmxlLmh0bWxcIj5cblxuPHNjcmlwdD5cbiAgLyoqXG4gICAqIEBwb2x5bWVyQmVoYXZpb3IgUG9seW1lci5Jcm9uTXVsdGlTZWxlY3RhYmxlQmVoYXZpb3JcbiAgICovXG4gIFBvbHltZXIuSXJvbk11bHRpU2VsZWN0YWJsZUJlaGF2aW9ySW1wbCA9IHtcbiAgICBwcm9wZXJ0aWVzOiB7XG5cbiAgICAgIC8qKlxuICAgICAgICogSWYgdHJ1ZSwgbXVsdGlwbGUgc2VsZWN0aW9ucyBhcmUgYWxsb3dlZC5cbiAgICAgICAqL1xuICAgICAgbXVsdGk6IHtcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgdmFsdWU6IGZhbHNlLFxuICAgICAgICBvYnNlcnZlcjogJ211bHRpQ2hhbmdlZCdcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBzZWxlY3RlZCBlbGVtZW50cy4gVGhpcyBpcyB1c2VkIGluc3RlYWQgb2YgYHNlbGVjdGVkYCB3aGVuIGBtdWx0aWBcbiAgICAgICAqIGlzIHRydWUuXG4gICAgICAgKi9cbiAgICAgIHNlbGVjdGVkVmFsdWVzOiB7XG4gICAgICAgIHR5cGU6IEFycmF5LFxuICAgICAgICBub3RpZnk6IHRydWUsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogUmV0dXJucyBhbiBhcnJheSBvZiBjdXJyZW50bHkgc2VsZWN0ZWQgaXRlbXMuXG4gICAgICAgKi9cbiAgICAgIHNlbGVjdGVkSXRlbXM6IHtcbiAgICAgICAgdHlwZTogQXJyYXksXG4gICAgICAgIHJlYWRPbmx5OiB0cnVlLFxuICAgICAgICBub3RpZnk6IHRydWUsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICB9LFxuXG4gICAgb2JzZXJ2ZXJzOiBbXG4gICAgICAnX3VwZGF0ZVNlbGVjdGVkKHNlbGVjdGVkVmFsdWVzLnNwbGljZXMpJ1xuICAgIF0sXG5cbiAgICAvKipcbiAgICAgKiBTZWxlY3RzIHRoZSBnaXZlbiB2YWx1ZS4gSWYgdGhlIGBtdWx0aWAgcHJvcGVydHkgaXMgdHJ1ZSwgdGhlbiB0aGUgc2VsZWN0ZWQgc3RhdGUgb2YgdGhlXG4gICAgICogYHZhbHVlYCB3aWxsIGJlIHRvZ2dsZWQ7IG90aGVyd2lzZSB0aGUgYHZhbHVlYCB3aWxsIGJlIHNlbGVjdGVkLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBzZWxlY3RcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IHZhbHVlIHRoZSB2YWx1ZSB0byBzZWxlY3QuXG4gICAgICovXG4gICAgc2VsZWN0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgaWYgKHRoaXMubXVsdGkpIHtcbiAgICAgICAgdGhpcy5fdG9nZ2xlU2VsZWN0ZWQodmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zZWxlY3RlZCA9IHZhbHVlO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBtdWx0aUNoYW5nZWQ6IGZ1bmN0aW9uKG11bHRpKSB7XG4gICAgICB0aGlzLl9zZWxlY3Rpb24ubXVsdGkgPSBtdWx0aTtcbiAgICAgIHRoaXMuX3VwZGF0ZVNlbGVjdGVkKCk7XG4gICAgfSxcblxuICAgIC8vIFVOVVNFRCwgRk9SIEFQSSBDT01QQVRJQklMSVRZXG4gICAgZ2V0IF9zaG91bGRVcGRhdGVTZWxlY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZWxlY3RlZCAhPSBudWxsIHx8XG4gICAgICAgICh0aGlzLnNlbGVjdGVkVmFsdWVzICE9IG51bGwgJiYgdGhpcy5zZWxlY3RlZFZhbHVlcy5sZW5ndGgpO1xuICAgIH0sXG5cbiAgICBfdXBkYXRlQXR0ckZvclNlbGVjdGVkOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5tdWx0aSkge1xuICAgICAgICBQb2x5bWVyLklyb25TZWxlY3RhYmxlQmVoYXZpb3IuX3VwZGF0ZUF0dHJGb3JTZWxlY3RlZC5hcHBseSh0aGlzKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5zZWxlY3RlZEl0ZW1zICYmIHRoaXMuc2VsZWN0ZWRJdGVtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRWYWx1ZXMgPSB0aGlzLnNlbGVjdGVkSXRlbXMubWFwKGZ1bmN0aW9uKHNlbGVjdGVkSXRlbSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9pbmRleFRvVmFsdWUodGhpcy5pbmRleE9mKHNlbGVjdGVkSXRlbSkpO1xuICAgICAgICB9LCB0aGlzKS5maWx0ZXIoZnVuY3Rpb24odW5maWx0ZXJlZFZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIHVuZmlsdGVyZWRWYWx1ZSAhPSBudWxsO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgX3VwZGF0ZVNlbGVjdGVkOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLm11bHRpKSB7XG4gICAgICAgIHRoaXMuX3NlbGVjdE11bHRpKHRoaXMuc2VsZWN0ZWRWYWx1ZXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fc2VsZWN0U2VsZWN0ZWQodGhpcy5zZWxlY3RlZCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIF9zZWxlY3RNdWx0aTogZnVuY3Rpb24odmFsdWVzKSB7XG4gICAgICB2YWx1ZXMgPSB2YWx1ZXMgfHwgW107XG5cbiAgICAgIHZhciBzZWxlY3RlZEl0ZW1zID0gKHRoaXMuX3ZhbHVlc1RvSXRlbXModmFsdWVzKSB8fCBbXSkuZmlsdGVyKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0gIT09IG51bGwgJiYgaXRlbSAhPT0gdW5kZWZpbmVkO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIGNsZWFyIGFsbCBidXQgdGhlIGN1cnJlbnQgc2VsZWN0ZWQgaXRlbXNcbiAgICAgIHRoaXMuX3NlbGVjdGlvbi5jbGVhcihzZWxlY3RlZEl0ZW1zKTtcblxuICAgICAgLy8gc2VsZWN0IG9ubHkgdGhvc2Ugbm90IHNlbGVjdGVkIHlldFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxlY3RlZEl0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuX3NlbGVjdGlvbi5zZXRJdGVtU2VsZWN0ZWQoc2VsZWN0ZWRJdGVtc1tpXSwgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIGZvciBpdGVtcywgc2luY2UgdGhpcyBhcnJheSBpcyBwb3B1bGF0ZWQgb25seSB3aGVuIGF0dGFjaGVkXG4gICAgICBpZiAodGhpcy5mYWxsYmFja1NlbGVjdGlvbiAmJiAhdGhpcy5fc2VsZWN0aW9uLmdldCgpLmxlbmd0aCkge1xuICAgICAgICB2YXIgZmFsbGJhY2sgPSB0aGlzLl92YWx1ZVRvSXRlbSh0aGlzLmZhbGxiYWNrU2VsZWN0aW9uKTtcbiAgICAgICAgaWYgKGZhbGxiYWNrKSB7XG4gICAgICAgICAgdGhpcy5zZWxlY3QodGhpcy5mYWxsYmFja1NlbGVjdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgX3NlbGVjdGlvbkNoYW5nZTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcyA9IHRoaXMuX3NlbGVjdGlvbi5nZXQoKTtcbiAgICAgIGlmICh0aGlzLm11bHRpKSB7XG4gICAgICAgIHRoaXMuX3NldFNlbGVjdGVkSXRlbXMocyk7XG4gICAgICAgIHRoaXMuX3NldFNlbGVjdGVkSXRlbShzLmxlbmd0aCA/IHNbMF0gOiBudWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChzICE9PSBudWxsICYmIHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMuX3NldFNlbGVjdGVkSXRlbXMoW3NdKTtcbiAgICAgICAgICB0aGlzLl9zZXRTZWxlY3RlZEl0ZW0ocyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fc2V0U2VsZWN0ZWRJdGVtcyhbXSk7XG4gICAgICAgICAgdGhpcy5fc2V0U2VsZWN0ZWRJdGVtKG51bGwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIF90b2dnbGVTZWxlY3RlZDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHZhciBpID0gdGhpcy5zZWxlY3RlZFZhbHVlcy5pbmRleE9mKHZhbHVlKTtcbiAgICAgIHZhciB1bnNlbGVjdGVkID0gaSA8IDA7XG4gICAgICBpZiAodW5zZWxlY3RlZCkge1xuICAgICAgICB0aGlzLnB1c2goJ3NlbGVjdGVkVmFsdWVzJyx2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNwbGljZSgnc2VsZWN0ZWRWYWx1ZXMnLGksMSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIF92YWx1ZXNUb0l0ZW1zOiBmdW5jdGlvbih2YWx1ZXMpIHtcbiAgICAgIHJldHVybiAodmFsdWVzID09IG51bGwpID8gbnVsbCA6IHZhbHVlcy5tYXAoZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlVG9JdGVtKHZhbHVlKTtcbiAgICAgIH0sIHRoaXMpO1xuICAgIH1cbiAgfTtcblxuICAvKiogQHBvbHltZXJCZWhhdmlvciAqL1xuICBQb2x5bWVyLklyb25NdWx0aVNlbGVjdGFibGVCZWhhdmlvciA9IFtcbiAgICBQb2x5bWVyLklyb25TZWxlY3RhYmxlQmVoYXZpb3IsXG4gICAgUG9seW1lci5Jcm9uTXVsdGlTZWxlY3RhYmxlQmVoYXZpb3JJbXBsXG4gIF07XG5cbjwvc2NyaXB0PlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9pcm9uLXNlbGVjdG9yL2lyb24tbXVsdGktc2VsZWN0YWJsZS5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNSBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuXG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vcG9seW1lci9wb2x5bWVyLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi9pcm9uLWJlaGF2aW9ycy9pcm9uLWJ1dHRvbi1zdGF0ZS5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwicGFwZXItcmlwcGxlLWJlaGF2aW9yLmh0bWxcIj5cblxuPHNjcmlwdD5cbiAgLyoqXG4gICAqIGBQb2x5bWVyLlBhcGVySW5reUZvY3VzQmVoYXZpb3JgIGltcGxlbWVudHMgYSByaXBwbGUgd2hlbiB0aGUgZWxlbWVudCBoYXMga2V5Ym9hcmQgZm9jdXMuXG4gICAqXG4gICAqIEBwb2x5bWVyQmVoYXZpb3IgUG9seW1lci5QYXBlcklua3lGb2N1c0JlaGF2aW9yXG4gICAqL1xuICBQb2x5bWVyLlBhcGVySW5reUZvY3VzQmVoYXZpb3JJbXBsID0ge1xuICAgIG9ic2VydmVyczogW1xuICAgICAgJ19mb2N1c2VkQ2hhbmdlZChyZWNlaXZlZEZvY3VzRnJvbUtleWJvYXJkKSdcbiAgICBdLFxuXG4gICAgX2ZvY3VzZWRDaGFuZ2VkOiBmdW5jdGlvbihyZWNlaXZlZEZvY3VzRnJvbUtleWJvYXJkKSB7XG4gICAgICBpZiAocmVjZWl2ZWRGb2N1c0Zyb21LZXlib2FyZCkge1xuICAgICAgICB0aGlzLmVuc3VyZVJpcHBsZSgpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuaGFzUmlwcGxlKCkpIHtcbiAgICAgICAgdGhpcy5fcmlwcGxlLmhvbGREb3duID0gcmVjZWl2ZWRGb2N1c0Zyb21LZXlib2FyZDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgX2NyZWF0ZVJpcHBsZTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcmlwcGxlID0gUG9seW1lci5QYXBlclJpcHBsZUJlaGF2aW9yLl9jcmVhdGVSaXBwbGUoKTtcbiAgICAgIHJpcHBsZS5pZCA9ICdpbmsnO1xuICAgICAgcmlwcGxlLnNldEF0dHJpYnV0ZSgnY2VudGVyJywgJycpO1xuICAgICAgcmlwcGxlLmNsYXNzTGlzdC5hZGQoJ2NpcmNsZScpO1xuICAgICAgcmV0dXJuIHJpcHBsZTtcbiAgICB9XG4gIH07XG5cbiAgLyoqIEBwb2x5bWVyQmVoYXZpb3IgUG9seW1lci5QYXBlcklua3lGb2N1c0JlaGF2aW9yICovXG4gIFBvbHltZXIuUGFwZXJJbmt5Rm9jdXNCZWhhdmlvciA9IFtcbiAgICBQb2x5bWVyLklyb25CdXR0b25TdGF0ZSxcbiAgICBQb2x5bWVyLklyb25Db250cm9sU3RhdGUsXG4gICAgUG9seW1lci5QYXBlclJpcHBsZUJlaGF2aW9yLFxuICAgIFBvbHltZXIuUGFwZXJJbmt5Rm9jdXNCZWhhdmlvckltcGxcbiAgXTtcbjwvc2NyaXB0PlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9wYXBlci1iZWhhdmlvcnMvcGFwZXItaW5reS1mb2N1cy1iZWhhdmlvci5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNSBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuXG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vcG9seW1lci9wb2x5bWVyLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi9wYXBlci1yaXBwbGUvcGFwZXItcmlwcGxlLmh0bWxcIj5cblxuPHNjcmlwdD5cbiAgLyoqXG4gICAqIGBQb2x5bWVyLlBhcGVyUmlwcGxlQmVoYXZpb3JgIGR5bmFtaWNhbGx5IGltcGxlbWVudHMgYSByaXBwbGVcbiAgICogd2hlbiB0aGUgZWxlbWVudCBoYXMgZm9jdXMgdmlhIHBvaW50ZXIgb3Iga2V5Ym9hcmQuXG4gICAqXG4gICAqIE5PVEU6IFRoaXMgYmVoYXZpb3IgaXMgaW50ZW5kZWQgdG8gYmUgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIGFuZCBhZnRlclxuICAgKiBgUG9seW1lci5Jcm9uQnV0dG9uU3RhdGVgIGFuZCBgUG9seW1lci5Jcm9uQ29udHJvbFN0YXRlYC5cbiAgICpcbiAgICogQHBvbHltZXJCZWhhdmlvciBQb2x5bWVyLlBhcGVyUmlwcGxlQmVoYXZpb3JcbiAgICovXG4gIFBvbHltZXIuUGFwZXJSaXBwbGVCZWhhdmlvciA9IHtcbiAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAvKipcbiAgICAgICAqIElmIHRydWUsIHRoZSBlbGVtZW50IHdpbGwgbm90IHByb2R1Y2UgYSByaXBwbGUgZWZmZWN0IHdoZW4gaW50ZXJhY3RlZFxuICAgICAgICogd2l0aCB2aWEgdGhlIHBvaW50ZXIuXG4gICAgICAgKi9cbiAgICAgIG5vaW5rOiB7XG4gICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgIG9ic2VydmVyOiAnX25vaW5rQ2hhbmdlZCdcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogQHR5cGUge0VsZW1lbnR8dW5kZWZpbmVkfVxuICAgICAgICovXG4gICAgICBfcmlwcGxlQ29udGFpbmVyOiB7XG4gICAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRW5zdXJlcyBhIGA8cGFwZXItcmlwcGxlPmAgZWxlbWVudCBpcyBhdmFpbGFibGUgd2hlbiB0aGUgZWxlbWVudCBpc1xuICAgICAqIGZvY3VzZWQuXG4gICAgICovXG4gICAgX2J1dHRvblN0YXRlQ2hhbmdlZDogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5mb2N1c2VkKSB7XG4gICAgICAgIHRoaXMuZW5zdXJlUmlwcGxlKCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEluIGFkZGl0aW9uIHRvIHRoZSBmdW5jdGlvbmFsaXR5IHByb3ZpZGVkIGluIGBJcm9uQnV0dG9uU3RhdGVgLCBlbnN1cmVzXG4gICAgICogYSByaXBwbGUgZWZmZWN0IGlzIGNyZWF0ZWQgd2hlbiB0aGUgZWxlbWVudCBpcyBpbiBhIGBwcmVzc2VkYCBzdGF0ZS5cbiAgICAgKi9cbiAgICBfZG93bkhhbmRsZXI6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICBQb2x5bWVyLklyb25CdXR0b25TdGF0ZUltcGwuX2Rvd25IYW5kbGVyLmNhbGwodGhpcywgZXZlbnQpO1xuICAgICAgaWYgKHRoaXMucHJlc3NlZCkge1xuICAgICAgICB0aGlzLmVuc3VyZVJpcHBsZShldmVudCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEVuc3VyZXMgdGhpcyBlbGVtZW50IGNvbnRhaW5zIGEgcmlwcGxlIGVmZmVjdC4gRm9yIHN0YXJ0dXAgZWZmaWNpZW5jeVxuICAgICAqIHRoZSByaXBwbGUgZWZmZWN0IGlzIGR5bmFtaWNhbGx5IG9uIGRlbWFuZCB3aGVuIG5lZWRlZC5cbiAgICAgKiBAcGFyYW0geyFFdmVudD19IG9wdFRyaWdnZXJpbmdFdmVudCAob3B0aW9uYWwpIGV2ZW50IHRoYXQgdHJpZ2dlcmVkIHRoZVxuICAgICAqIHJpcHBsZS5cbiAgICAgKi9cbiAgICBlbnN1cmVSaXBwbGU6IGZ1bmN0aW9uKG9wdFRyaWdnZXJpbmdFdmVudCkge1xuICAgICAgaWYgKCF0aGlzLmhhc1JpcHBsZSgpKSB7XG4gICAgICAgIHRoaXMuX3JpcHBsZSA9IHRoaXMuX2NyZWF0ZVJpcHBsZSgpO1xuICAgICAgICB0aGlzLl9yaXBwbGUubm9pbmsgPSB0aGlzLm5vaW5rO1xuICAgICAgICB2YXIgcmlwcGxlQ29udGFpbmVyID0gdGhpcy5fcmlwcGxlQ29udGFpbmVyIHx8IHRoaXMucm9vdDtcbiAgICAgICAgaWYgKHJpcHBsZUNvbnRhaW5lcikge1xuICAgICAgICAgIFBvbHltZXIuZG9tKHJpcHBsZUNvbnRhaW5lcikuYXBwZW5kQ2hpbGQodGhpcy5fcmlwcGxlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0VHJpZ2dlcmluZ0V2ZW50KSB7XG4gICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGV2ZW50IGhhcHBlbmVkIGluc2lkZSBvZiB0aGUgcmlwcGxlIGNvbnRhaW5lclxuICAgICAgICAgIC8vIEZhbGwgYmFjayB0byBob3N0IGluc3RlYWQgb2YgdGhlIHJvb3QgYmVjYXVzZSBkaXN0cmlidXRlZCB0ZXh0XG4gICAgICAgICAgLy8gbm9kZXMgYXJlIG5vdCB2YWxpZCBldmVudCB0YXJnZXRzXG4gICAgICAgICAgdmFyIGRvbUNvbnRhaW5lciA9IFBvbHltZXIuZG9tKHRoaXMuX3JpcHBsZUNvbnRhaW5lciB8fCB0aGlzKTtcbiAgICAgICAgICB2YXIgdGFyZ2V0ID0gUG9seW1lci5kb20ob3B0VHJpZ2dlcmluZ0V2ZW50KS5yb290VGFyZ2V0O1xuICAgICAgICAgIGlmIChkb21Db250YWluZXIuZGVlcENvbnRhaW5zKCAvKiogQHR5cGUge05vZGV9ICovKHRhcmdldCkpKSB7XG4gICAgICAgICAgICB0aGlzLl9yaXBwbGUudWlEb3duQWN0aW9uKG9wdFRyaWdnZXJpbmdFdmVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGA8cGFwZXItcmlwcGxlPmAgZWxlbWVudCB1c2VkIGJ5IHRoaXMgZWxlbWVudCB0byBjcmVhdGVcbiAgICAgKiByaXBwbGUgZWZmZWN0cy4gVGhlIGVsZW1lbnQncyByaXBwbGUgaXMgY3JlYXRlZCBvbiBkZW1hbmQsIHdoZW5cbiAgICAgKiBuZWNlc3NhcnksIGFuZCBjYWxsaW5nIHRoaXMgbWV0aG9kIHdpbGwgZm9yY2UgdGhlXG4gICAgICogcmlwcGxlIHRvIGJlIGNyZWF0ZWQuXG4gICAgICovXG4gICAgZ2V0UmlwcGxlOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZW5zdXJlUmlwcGxlKCk7XG4gICAgICByZXR1cm4gdGhpcy5fcmlwcGxlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBlbGVtZW50IGN1cnJlbnRseSBjb250YWlucyBhIHJpcHBsZSBlZmZlY3QuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBoYXNSaXBwbGU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIEJvb2xlYW4odGhpcy5fcmlwcGxlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHRoZSBlbGVtZW50J3MgcmlwcGxlIGVmZmVjdCB2aWEgY3JlYXRpbmcgYSBgPHBhcGVyLXJpcHBsZT5gLlxuICAgICAqIE92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIGN1c3RvbWl6ZSB0aGUgcmlwcGxlIGVsZW1lbnQuXG4gICAgICogQHJldHVybiB7IVBhcGVyUmlwcGxlRWxlbWVudH0gUmV0dXJucyBhIGA8cGFwZXItcmlwcGxlPmAgZWxlbWVudC5cbiAgICAgKi9cbiAgICBfY3JlYXRlUmlwcGxlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAvKiogQHR5cGUgeyFQYXBlclJpcHBsZUVsZW1lbnR9ICovIChcbiAgICAgICAgICBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwYXBlci1yaXBwbGUnKSk7XG4gICAgfSxcblxuICAgIF9ub2lua0NoYW5nZWQ6IGZ1bmN0aW9uKG5vaW5rKSB7XG4gICAgICBpZiAodGhpcy5oYXNSaXBwbGUoKSkge1xuICAgICAgICB0aGlzLl9yaXBwbGUubm9pbmsgPSBub2luaztcbiAgICAgIH1cbiAgICB9XG4gIH07XG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvcGFwZXItYmVoYXZpb3JzL3BhcGVyLXJpcHBsZS1iZWhhdmlvci5odG1sIiwiXG5yZXF1aXJlKCcuLi9ib3dlcl9jb21wb25lbnRzL2lyb24taWNvbnNldC1zdmcvaXJvbi1pY29uc2V0LXN2Zy5odG1sJyk7XG5cbmNvbnN0IFJlZ2lzdGVySHRtbFRlbXBsYXRlID0gcmVxdWlyZSgncG9seW1lci13ZWJwYWNrLWxvYWRlci9yZWdpc3Rlci1odG1sLXRlbXBsYXRlJyk7XG5cblJlZ2lzdGVySHRtbFRlbXBsYXRlLnRvQm9keShcIjxpcm9uLWljb25zZXQtc3ZnIG5hbWU9bXktaWNvbnMgc2l6ZT0yND4gPHN2Zz4gPGRlZnM+IDxnIGlkPWFycm93LWJhY2s+IDxwYXRoIGQ9XFxcIk0yMCAxMUg3LjgzbDUuNTktNS41OUwxMiA0bC04IDggOCA4IDEuNDEtMS40MUw3LjgzIDEzSDIwdi0yelxcXCI+PC9wYXRoPiA8L2c+IDxnIGlkPW1lbnU+IDxwYXRoIGQ9XFxcIk0zIDE4aDE4di0ySDN2MnptMC01aDE4di0ySDN2MnptMC03djJoMThWNkgzelxcXCI+PC9wYXRoPiA8L2c+IDxnIGlkPWNoZXZyb24tcmlnaHQ+IDxwYXRoIGQ9XFxcIk0xMCA2TDguNTkgNy40MSAxMy4xNyAxMmwtNC41OCA0LjU5TDEwIDE4bDYtNnpcXFwiPjwvcGF0aD4gPC9nPiA8ZyBpZD1jbG9zZT4gPHBhdGggZD1cXFwiTTE5IDYuNDFMMTcuNTkgNSAxMiAxMC41OSA2LjQxIDUgNSA2LjQxIDEwLjU5IDEyIDUgMTcuNTkgNi40MSAxOSAxMiAxMy40MSAxNy41OSAxOSAxOSAxNy41OSAxMy40MSAxMnpcXFwiPjwvcGF0aD4gPC9nPiA8ZyBpZD1zZWFyY2g+PHBhdGggZD1cXFwiTTE1LjUgMTRoLS43OWwtLjI4LS4yN0MxNS40MSAxMi41OSAxNiAxMS4xMSAxNiA5LjUgMTYgNS45MSAxMy4wOSAzIDkuNSAzUzMgNS45MSAzIDkuNSA1LjkxIDE2IDkuNSAxNmMxLjYxIDAgMy4wOS0uNTkgNC4yMy0xLjU3bC4yNy4yOHYuNzlsNSA0Ljk5TDIwLjQ5IDE5bC00Ljk5LTV6bS02IDBDNy4wMSAxNCA1IDExLjk5IDUgOS41UzcuMDEgNSA5LjUgNSAxNCA3LjAxIDE0IDkuNSAxMS45OSAxNCA5LjUgMTR6XFxcIj48L3BhdGg+IDwvZz4gPC9kZWZzPiA8L3N2Zz4gPC9pcm9uLWljb25zZXQtc3ZnPlwiKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9teS1pY29ucy5odG1sIl0sInNvdXJjZVJvb3QiOiIifQ==