/******/ (function(modules) { // webpackBootstrap
/******/ 	// install a JSONP callback for chunk loading
/******/ 	var parentJsonpFunction = window["webpackJsonp"];
/******/ 	window["webpackJsonp"] = function webpackJsonpCallback(chunkIds, moreModules, executeModules) {
/******/ 		// add "moreModules" to the modules object,
/******/ 		// then flag all "chunkIds" as loaded and fire callback
/******/ 		var moduleId, chunkId, i = 0, resolves = [], result;
/******/ 		for(;i < chunkIds.length; i++) {
/******/ 			chunkId = chunkIds[i];
/******/ 			if(installedChunks[chunkId]) {
/******/ 				resolves.push(installedChunks[chunkId][0]);
/******/ 			}
/******/ 			installedChunks[chunkId] = 0;
/******/ 		}
/******/ 		for(moduleId in moreModules) {
/******/ 			if(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
/******/ 				modules[moduleId] = moreModules[moduleId];
/******/ 			}
/******/ 		}
/******/ 		if(parentJsonpFunction) parentJsonpFunction(chunkIds, moreModules, executeModules);
/******/ 		while(resolves.length) {
/******/ 			resolves.shift()();
/******/ 		}
/******/
/******/ 	};
/******/
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// objects to store loaded and loading chunks
/******/ 	var installedChunks = {
/******/ 		4: 0
/******/ 	};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/ 	// This file contains only the entry chunk.
/******/ 	// The chunk loading function for additional chunks
/******/ 	__webpack_require__.e = function requireEnsure(chunkId) {
/******/ 		var installedChunkData = installedChunks[chunkId];
/******/ 		if(installedChunkData === 0) {
/******/ 			return new Promise(function(resolve) { resolve(); });
/******/ 		}
/******/
/******/ 		// a Promise means "currently loading".
/******/ 		if(installedChunkData) {
/******/ 			return installedChunkData[2];
/******/ 		}
/******/
/******/ 		// setup Promise in chunk cache
/******/ 		var promise = new Promise(function(resolve, reject) {
/******/ 			installedChunkData = installedChunks[chunkId] = [resolve, reject];
/******/ 		});
/******/ 		installedChunkData[2] = promise;
/******/
/******/ 		// start chunk loading
/******/ 		var head = document.getElementsByTagName('head')[0];
/******/ 		var script = document.createElement('script');
/******/ 		script.type = 'text/javascript';
/******/ 		script.charset = 'utf-8';
/******/ 		script.async = true;
/******/ 		script.timeout = 120000;
/******/
/******/ 		if (__webpack_require__.nc) {
/******/ 			script.setAttribute("nonce", __webpack_require__.nc);
/******/ 		}
/******/ 		script.src = __webpack_require__.p + "" + chunkId + ".bundle.js";
/******/ 		var timeout = setTimeout(onScriptComplete, 120000);
/******/ 		script.onerror = script.onload = onScriptComplete;
/******/ 		function onScriptComplete() {
/******/ 			// avoid mem leaks in IE.
/******/ 			script.onerror = script.onload = null;
/******/ 			clearTimeout(timeout);
/******/ 			var chunk = installedChunks[chunkId];
/******/ 			if(chunk !== 0) {
/******/ 				if(chunk) {
/******/ 					chunk[1](new Error('Loading chunk ' + chunkId + ' failed.'));
/******/ 				}
/******/ 				installedChunks[chunkId] = undefined;
/******/ 			}
/******/ 		};
/******/ 		head.appendChild(script);
/******/
/******/ 		return promise;
/******/ 	};
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "dist/";
/******/
/******/ 	// on error function for async loading
/******/ 	__webpack_require__.oe = function(err) { console.error(err); throw err; };
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 39);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(22);

__webpack_require__(53);

__webpack_require__(55);

__webpack_require__(56);

__webpack_require__(57);

__webpack_require__(58);

__webpack_require__(59);

__webpack_require__(60);

__webpack_require__(63);

// bc
Polymer.Base = Polymer.LegacyElementMixin(HTMLElement).prototype;

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


(function () {
  'use strict';

  var userPolymer = window.Polymer;

  /**
   * @namespace Polymer
   * @summary Polymer is a lightweight library built on top of the web
   *   standards-based Web Components API's, and makes it easy to build your
   *   own custom HTML elements.
   * @param {!PolymerInit} info Prototype for the custom element. It must contain
   *   an `is` property to specify the element name. Other properties populate
   *   the element prototype. The `properties`, `observers`, `hostAttributes`,
   *   and `listeners` properties are processed to create element features.
   * @return {!Object} Returns a custom element class for the given provided
   *   prototype `info` object. The name of the element if given by `info.is`.
   */
  window.Polymer = function (info) {
    return window.Polymer._polymerFn(info);
  };

  // support user settings on the Polymer object
  if (userPolymer) {
    Object.assign(Polymer, userPolymer);
  }

  // To be plugged by legacy implementation if loaded
  /* eslint-disable valid-jsdoc */
  /**
   * @param {!PolymerInit} info Prototype for the custom element. It must contain
   *   an `is` property to specify the element name. Other properties populate
   *   the element prototype. The `properties`, `observers`, `hostAttributes`,
   *   and `listeners` properties are processed to create element features.
   * @return {!Object} Returns a custom element class for the given provided
   *   prototype `info` object. The name of the element if given by `info.is`.
   */
  window.Polymer._polymerFn = function (info) {
    // eslint-disable-line no-unused-vars
    throw new Error('Load polymer.html to use the Polymer() function.');
  };
  /* eslint-enable */

  window.Polymer.version = '2.0.1';

  /* eslint-disable no-unused-vars */
  /*
  When using Closure Compiler, JSCompiler_renameProperty(property, object) is replaced by the munged name for object[property]
  We cannot alias this function, so we have to use a small shim that has the same behavior when not compiling.
  */
  window.JSCompiler_renameProperty = function (prop, obj) {
    return prop;
  };
  /* eslint-enable */
})();

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/* eslint-env browser */

var RegisterHtmlTemplate = function () {
  function RegisterHtmlTemplate() {
    _classCallCheck(this, RegisterHtmlTemplate);
  }

  _createClass(RegisterHtmlTemplate, null, [{
    key: 'register',

    /**
     * Create a `<template>` element to hold `<dom-module>` content.
     * This bit of code will execute in the context of the main document,
     * calling `importNode` on the `<template>`, which in turn triggers
     * the lifecycle of the `<dom-module>` and allows it to insert its
     * content into Polymer's global module map. When a Polymer element
     * boots up it will fetch its template from this module map.
     * https://github.com/Polymer/polymer/blob/master/lib/mixins/element-mixin.html#L501-L538
     * @param {string} val A `<dom-module>` as an HTML string
     */
    value: function register(val) {
      var content = void 0;
      var template = document.createElement('template');
      template.innerHTML = val;
      if (template.content) {
        content = template.content; // eslint-disable-line prefer-destructuring
      } else {
        content = document.createDocumentFragment();
        while (template.firstChild) {
          content.appendChild(template.firstChild);
        }
      }
      document.importNode(content, true);
    }
    /**
     * Content that will be injected into the main document. This is primarily
     * for things like `<iron-iconset>` and `<custom-style>` which do not have
     * templates but rely on HTML Imports ability to apply content to the main
     * document.
     * @param {string} val An HTML string
     */

  }, {
    key: 'toBody',
    value: function toBody(val) {
      var trimmedVal = val.trim();
      if (trimmedVal) {
        var div = document.createElement('div');
        div.innerHTML = trimmedVal;
        if (div.firstChild) {
          if (document.body) {
            document.body.insertBefore(div.firstChild, document.body.firstChild);
          } else {
            document.addEventListener('DOMContentLoaded', function () {
              document.body.insertBefore(div.firstChild, document.body.firstChild);
            });
          }
        }
      }
    }
  }]);

  return RegisterHtmlTemplate;
}();

module.exports = RegisterHtmlTemplate;

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(1);

(function () {

  'use strict';

  // unique global id for deduping mixins.

  var dedupeId = 0;

  /**
   * @constructor
   * @extends {Function}
   */
  function MixinFunction() {}
  /** @type {(WeakMap | undefined)} */
  MixinFunction.prototype.__mixinApplications;
  /** @type {(Object | undefined)} */
  MixinFunction.prototype.__mixinSet;

  /* eslint-disable valid-jsdoc */
  /**
   * Wraps an ES6 class expression mixin such that the mixin is only applied
   * if it has not already been applied its base argument.  Also memoizes mixin
   * applications.
   *
   * @memberof Polymer
   * @template T
   * @param {T} mixin ES6 class expression mixin to wrap
   * @suppress {invalidCasts}
   */
  Polymer.dedupingMixin = function (mixin) {
    var mixinApplications = /** @type {!MixinFunction} */mixin.__mixinApplications;
    if (!mixinApplications) {
      mixinApplications = new WeakMap();
      /** @type {!MixinFunction} */mixin.__mixinApplications = mixinApplications;
    }
    // maintain a unique id for each mixin
    var mixinDedupeId = dedupeId++;
    function dedupingMixin(base) {
      var baseSet = /** @type {!MixinFunction} */base.__mixinSet;
      if (baseSet && baseSet[mixinDedupeId]) {
        return base;
      }
      var map = mixinApplications;
      var extended = map.get(base);
      if (!extended) {
        extended = /** @type {!Function} */mixin(base);
        map.set(base, extended);
      }
      // copy inherited mixin set from the extended class, or the base class
      // NOTE: we avoid use of Set here because some browser (IE11)
      // cannot extend a base Set via the constructor.
      var mixinSet = Object.create( /** @type {!MixinFunction} */extended.__mixinSet || baseSet || null);
      mixinSet[mixinDedupeId] = true;
      /** @type {!MixinFunction} */extended.__mixinSet = mixinSet;
      return extended;
    }

    return dedupingMixin;
  };
  /* eslint-enable valid-jsdoc */
})();

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

__webpack_require__(36);

__webpack_require__(67);

/**
 * `Polymer.AppScrollEffectsBehavior` provides an interface that allows an element to use scrolls effects.
 *
 * ### Importing the app-layout effects
 *
 * app-layout provides a set of scroll effects that can be used by explicitly importing
 * `app-scroll-effects.html`:
 *
 * ```html
 * <link rel="import" href="/bower_components/app-layout/app-scroll-effects/app-scroll-effects.html">
 * ```
 *
 * The scroll effects can also be used by individually importing
 * `app-layout/app-scroll-effects/effects/[effectName].html`. For example:
 *
 * ```html
 *  <link rel="import" href="/bower_components/app-layout/app-scroll-effects/effects/waterfall.html">
 * ```
 *
 * ### Consuming effects
 *
 * Effects can be consumed via the `effects` property. For example:
 *
 * ```html
 * <app-header effects="waterfall"></app-header>
 * ```
 *
 * ### Creating scroll effects
 *
 * You may want to create a custom scroll effect if you need to modify the CSS of an element
 * based on the scroll position.
 *
 * A scroll effect definition is an object with `setUp()`, `tearDown()` and `run()` functions.
 *
 * To register the effect, you can use `Polymer.AppLayout.registerEffect(effectName, effectDef)`
 * For example, let's define an effect that resizes the header's logo:
 *
 * ```js
 * Polymer.AppLayout.registerEffect('resizable-logo', {
 *   setUp: function(config) {
 *     // the effect's config is passed to the setUp.
 *     this._fxResizeLogo = { logo: Polymer.dom(this).querySelector('[logo]') };
 *   },
 *
 *   run: function(progress) {
 *      // the progress of the effect
 *      this.transform('scale3d(' + progress + ', '+ progress +', 1)',  this._fxResizeLogo.logo);
 *   },
 *
 *   tearDown: function() {
 *      // clean up and reset of states
 *      delete this._fxResizeLogo;
 *   }
 * });
 * ```
 * Now, you can consume the effect:
 *
 * ```html
 * <app-header id="appHeader" effects="resizable-logo">
 *   <img logo src="logo.svg">
 * </app-header>
 * ```
 *
 * ### Imperative API
 *
 * ```js
 * var logoEffect = appHeader.createEffect('resizable-logo', effectConfig);
 * // run the effect: logoEffect.run(progress);
 * // tear down the effect: logoEffect.tearDown();
 * ```
 *
 * ### Configuring effects
 *
 * For effects installed via the `effects` property, their configuration can be set
 * via the `effectsConfig` property. For example:
 *
 * ```html
 * <app-header effects="waterfall"
 *   effects-config='{"waterfall": {"startsAt": 0, "endsAt": 0.5}}'>
 * </app-header>
 * ```
 *
 * All effects have a `startsAt` and `endsAt` config property. They specify at what
 * point the effect should start and end. This value goes from 0 to 1 inclusive.
 *
 * @polymerBehavior
 */
Polymer.AppScrollEffectsBehavior = [Polymer.IronScrollTargetBehavior, {

  properties: {

    /**
     * A space-separated list of the effects names that will be triggered when the user scrolls.
     * e.g. `waterfall parallax-background` installs the `waterfall` and `parallax-background`.
     */
    effects: {
      type: String
    },

    /**
     * An object that configurates the effects installed via the `effects` property. e.g.
     * ```js
     *  element.effectsConfig = {
     *   "blend-background": {
     *     "startsAt": 0.5
     *   }
     * };
     * ```
     * Every effect has at least two config properties: `startsAt` and `endsAt`.
     * These properties indicate when the event should start and end respectively
     * and relative to the overall element progress. So for example, if `blend-background`
     * starts at `0.5`, the effect will only start once the current element reaches 0.5
     * of its progress. In this context, the progress is a value in the range of `[0, 1]`
     * that indicates where this element is on the screen relative to the viewport.
     */
    effectsConfig: {
      type: Object,
      value: function value() {
        return {};
      }
    },

    /**
     * Disables CSS transitions and scroll effects on the element.
     */
    disabled: {
      type: Boolean,
      reflectToAttribute: true,
      value: false
    },

    /**
     * Allows to set a `scrollTop` threshold. When greater than 0, `thresholdTriggered`
     * is true only when the scroll target's `scrollTop` has reached this value.
     *
     * For example, if `threshold = 100`, `thresholdTriggered` is true when the `scrollTop`
     * is at least `100`.
     */
    threshold: {
      type: Number,
      value: 0
    },

    /**
     * True if the `scrollTop` threshold (set in `scrollTopThreshold`) has
     * been reached.
     */
    thresholdTriggered: {
      type: Boolean,
      notify: true,
      readOnly: true,
      reflectToAttribute: true
    }
  },

  observers: ['_effectsChanged(effects, effectsConfig, isAttached)'],

  /**
   * Updates the scroll state. This method should be overridden
   * by the consumer of this behavior.
   *
   * @method _updateScrollState
   */
  _updateScrollState: function _updateScrollState() {},

  /**
   * Returns true if the current element is on the screen.
   * That is, visible in the current viewport. This method should be
   * overridden by the consumer of this behavior.
   *
   * @method isOnScreen
   * @return {boolean}
   */
  isOnScreen: function isOnScreen() {
    return false;
  },

  /**
   * Returns true if there's content below the current element. This method
   * should be overridden by the consumer of this behavior.
   *
   * @method isContentBelow
   * @return {boolean}
   */
  isContentBelow: function isContentBelow() {
    return false;
  },

  /**
   * List of effects handlers that will take place during scroll.
   *
   * @type {Array<Function>}
   */
  _effectsRunFn: null,

  /**
   * List of the effects definitions installed via the `effects` property.
   *
   * @type {Array<Object>}
   */
  _effects: null,

  /**
   * The clamped value of `_scrollTop`.
   * @type number
   */
  get _clampedScrollTop() {
    return Math.max(0, this._scrollTop);
  },

  detached: function detached() {
    this._tearDownEffects();
  },

  /**
   * Creates an effect object from an effect's name that can be used to run
   * effects programmatically.
   *
   * @method createEffect
   * @param {string} effectName The effect's name registered via `Polymer.AppLayout.registerEffect`.
   * @param {Object=} effectConfig The effect config object. (Optional)
   * @return {Object} An effect object with the following functions:
   *
   *  * `effect.setUp()`, Sets up the requirements for the effect.
   *       This function is called automatically before the `effect` function returns.
   *  * `effect.run(progress, y)`, Runs the effect given a `progress`.
   *  * `effect.tearDown()`, Cleans up any DOM nodes or element references used by the effect.
   *
   * Example:
   * ```js
   * var parallax = element.createEffect('parallax-background');
   * // runs the effect
   * parallax.run(0.5, 0);
   * ```
   */
  createEffect: function createEffect(effectName, effectConfig) {
    var effectDef = Polymer.AppLayout._scrollEffects[effectName];
    if (!effectDef) {
      throw new ReferenceError(this._getUndefinedMsg(effectName));
    }
    var prop = this._boundEffect(effectDef, effectConfig || {});
    prop.setUp();
    return prop;
  },

  /**
   * Called when `effects` or `effectsConfig` changes.
   */
  _effectsChanged: function _effectsChanged(effects, effectsConfig, isAttached) {
    this._tearDownEffects();

    if (!effects || !isAttached) {
      return;
    }
    effects.split(' ').forEach(function (effectName) {
      var effectDef;
      if (effectName !== '') {
        if (effectDef = Polymer.AppLayout._scrollEffects[effectName]) {
          this._effects.push(this._boundEffect(effectDef, effectsConfig[effectName]));
        } else {
          console.warn(this._getUndefinedMsg(effectName));
        }
      }
    }, this);

    this._setUpEffect();
  },

  /**
   * Forces layout
   */
  _layoutIfDirty: function _layoutIfDirty() {
    return this.offsetWidth;
  },

  /**
   * Returns an effect object bound to the current context.
   *
   * @param {Object} effectDef
   * @param {Object=} effectsConfig The effect config object if the effect accepts config values. (Optional)
   */
  _boundEffect: function _boundEffect(effectDef, effectsConfig) {
    effectsConfig = effectsConfig || {};
    var startsAt = parseFloat(effectsConfig.startsAt || 0);
    var endsAt = parseFloat(effectsConfig.endsAt || 1);
    var deltaS = endsAt - startsAt;
    var noop = function noop() {};
    // fast path if possible
    var runFn = startsAt === 0 && endsAt === 1 ? effectDef.run : function (progress, y) {
      effectDef.run.call(this, Math.max(0, (progress - startsAt) / deltaS), y);
    };
    return {
      setUp: effectDef.setUp ? effectDef.setUp.bind(this, effectsConfig) : noop,
      run: effectDef.run ? runFn.bind(this) : noop,
      tearDown: effectDef.tearDown ? effectDef.tearDown.bind(this) : noop
    };
  },

  /**
   * Sets up the effects.
   */
  _setUpEffect: function _setUpEffect() {
    if (this.isAttached && this._effects) {
      this._effectsRunFn = [];
      this._effects.forEach(function (effectDef) {
        // install the effect only if no error was reported
        if (effectDef.setUp() !== false) {
          this._effectsRunFn.push(effectDef.run);
        }
      }, this);
    }
  },

  /**
   * Tears down the effects.
   */
  _tearDownEffects: function _tearDownEffects() {
    if (this._effects) {
      this._effects.forEach(function (effectDef) {
        effectDef.tearDown();
      });
    }
    this._effectsRunFn = [];
    this._effects = [];
  },

  /**
   * Runs the effects.
   *
   * @param {number} p The progress
   * @param {number} y The top position of the current element relative to the viewport.
   */
  _runEffects: function _runEffects(p, y) {
    if (this._effectsRunFn) {
      this._effectsRunFn.forEach(function (run) {
        run(p, y);
      });
    }
  },

  /**
   * Overrides the `_scrollHandler`.
   */
  _scrollHandler: function _scrollHandler() {
    if (!this.disabled) {
      var scrollTop = this._clampedScrollTop;
      this._updateScrollState(scrollTop);
      if (this.threshold > 0) {
        this._setThresholdTriggered(scrollTop >= this.threshold);
      }
    }
  },

  /**
   * Override this method to return a reference to a node in the local DOM.
   * The node is consumed by a scroll effect.
   *
   * @param {string} id The id for the node.
   */
  _getDOMRef: function _getDOMRef(id) {
    console.warn('_getDOMRef', '`' + id + '` is undefined');
  },

  _getUndefinedMsg: function _getUndefinedMsg(effectName) {
    return 'Scroll effect `' + effectName + '` is undefined. ' + 'Did you forget to import app-layout/app-scroll-effects/effects/' + effectName + '.html ?';
  }

}];

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

var RegisterHtmlTemplate = __webpack_require__(2);

RegisterHtmlTemplate.toBody("<custom-style> <style is=custom-style>html{--layout:{display:-ms-flexbox;display:-webkit-flex;display:flex};--layout-inline:{display:-ms-inline-flexbox;display:-webkit-inline-flex;display:inline-flex};--layout-horizontal:{@apply --layout;-ms-flex-direction:row;-webkit-flex-direction:row;flex-direction:row};--layout-horizontal-reverse:{@apply --layout;-ms-flex-direction:row-reverse;-webkit-flex-direction:row-reverse;flex-direction:row-reverse};--layout-vertical:{@apply --layout;-ms-flex-direction:column;-webkit-flex-direction:column;flex-direction:column};--layout-vertical-reverse:{@apply --layout;-ms-flex-direction:column-reverse;-webkit-flex-direction:column-reverse;flex-direction:column-reverse};--layout-wrap:{-ms-flex-wrap:wrap;-webkit-flex-wrap:wrap;flex-wrap:wrap};--layout-wrap-reverse:{-ms-flex-wrap:wrap-reverse;-webkit-flex-wrap:wrap-reverse;flex-wrap:wrap-reverse};--layout-flex-auto:{-ms-flex:1 1 auto;-webkit-flex:1 1 auto;flex:1 1 auto};--layout-flex-none:{-ms-flex:none;-webkit-flex:none;flex:none};--layout-flex:{-ms-flex:1 1 .000000001px;-webkit-flex:1;flex:1;-webkit-flex-basis:.000000001px;flex-basis:.000000001px};--layout-flex-2:{-ms-flex:2;-webkit-flex:2;flex:2};--layout-flex-3:{-ms-flex:3;-webkit-flex:3;flex:3};--layout-flex-4:{-ms-flex:4;-webkit-flex:4;flex:4};--layout-flex-5:{-ms-flex:5;-webkit-flex:5;flex:5};--layout-flex-6:{-ms-flex:6;-webkit-flex:6;flex:6};--layout-flex-7:{-ms-flex:7;-webkit-flex:7;flex:7};--layout-flex-8:{-ms-flex:8;-webkit-flex:8;flex:8};--layout-flex-9:{-ms-flex:9;-webkit-flex:9;flex:9};--layout-flex-10:{-ms-flex:10;-webkit-flex:10;flex:10};--layout-flex-11:{-ms-flex:11;-webkit-flex:11;flex:11};--layout-flex-12:{-ms-flex:12;-webkit-flex:12;flex:12};--layout-start:{-ms-flex-align:start;-webkit-align-items:flex-start;align-items:flex-start};--layout-center:{-ms-flex-align:center;-webkit-align-items:center;align-items:center};--layout-end:{-ms-flex-align:end;-webkit-align-items:flex-end;align-items:flex-end};--layout-baseline:{-ms-flex-align:baseline;-webkit-align-items:baseline;align-items:baseline};--layout-start-justified:{-ms-flex-pack:start;-webkit-justify-content:flex-start;justify-content:flex-start};--layout-center-justified:{-ms-flex-pack:center;-webkit-justify-content:center;justify-content:center};--layout-end-justified:{-ms-flex-pack:end;-webkit-justify-content:flex-end;justify-content:flex-end};--layout-around-justified:{-ms-flex-pack:distribute;-webkit-justify-content:space-around;justify-content:space-around};--layout-justified:{-ms-flex-pack:justify;-webkit-justify-content:space-between;justify-content:space-between};--layout-center-center:{@apply --layout-center;@apply --layout-center-justified;};--layout-self-start:{-ms-align-self:flex-start;-webkit-align-self:flex-start;align-self:flex-start};--layout-self-center:{-ms-align-self:center;-webkit-align-self:center;align-self:center};--layout-self-end:{-ms-align-self:flex-end;-webkit-align-self:flex-end;align-self:flex-end};--layout-self-stretch:{-ms-align-self:stretch;-webkit-align-self:stretch;align-self:stretch};--layout-self-baseline:{-ms-align-self:baseline;-webkit-align-self:baseline;align-self:baseline};--layout-start-aligned:{-ms-flex-line-pack:start;-ms-align-content:flex-start;-webkit-align-content:flex-start;align-content:flex-start};--layout-end-aligned:{-ms-flex-line-pack:end;-ms-align-content:flex-end;-webkit-align-content:flex-end;align-content:flex-end};--layout-center-aligned:{-ms-flex-line-pack:center;-ms-align-content:center;-webkit-align-content:center;align-content:center};--layout-between-aligned:{-ms-flex-line-pack:justify;-ms-align-content:space-between;-webkit-align-content:space-between;align-content:space-between};--layout-around-aligned:{-ms-flex-line-pack:distribute;-ms-align-content:space-around;-webkit-align-content:space-around;align-content:space-around};--layout-block:{display:block};--layout-invisible:{visibility:hidden!important};--layout-relative:{position:relative};--layout-fit:{position:absolute;top:0;right:0;bottom:0;left:0};--layout-scroll:{-webkit-overflow-scrolling:touch;overflow:auto};--layout-fullbleed:{margin:0;height:100vh};--layout-fixed-top:{position:fixed;top:0;left:0;right:0};--layout-fixed-right:{position:fixed;top:0;right:0;bottom:0};--layout-fixed-bottom:{position:fixed;right:0;bottom:0;left:0};--layout-fixed-left:{position:fixed;top:0;bottom:0;left:0};}</style> </custom-style>");

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(19);

(function () {
  'use strict';

  /**
   * Base class that provides the core API for Polymer's meta-programming
   * features including template stamping, data-binding, attribute deserialization,
   * and property change observation.
   *
   * @customElement
   * @polymer
   * @memberof Polymer
   * @constructor
   * @implements {Polymer_ElementMixin}
   * @extends HTMLElement
   * @appliesMixin Polymer.ElementMixin
   * @summary Custom element base class that provides the core API for Polymer's
   *   key meta-programming features including template stamping, data-binding,
   *   attribute deserialization, and property change observation
   */

  var Element = Polymer.ElementMixin(HTMLElement);
  /**
   * @constructor
   * @implements {Polymer_ElementMixin}
   * @extends {HTMLElement}
   */
  Polymer.Element = Element;
})();

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(1);

(function () {
  'use strict';

  var CSS_URL_RX = /(url\()([^)]*)(\))/g;
  var ABS_URL = /(^\/)|(^#)|(^[\w-\d]*:)/;
  var workingURL = void 0;
  var resolveDoc = void 0;
  /**
   * Resolves the given URL against the provided `baseUri'.
   *
   * @memberof Polymer.ResolveUrl
   * @param {string} url Input URL to resolve
   * @param {?string=} baseURI Base URI to resolve the URL against
   * @return {string} resolved URL
   */
  function resolveUrl(url, baseURI) {
    if (url && ABS_URL.test(url)) {
      return url;
    }
    // Lazy feature detection.
    if (workingURL === undefined) {
      workingURL = false;
      try {
        var u = new URL('b', 'http://a');
        u.pathname = 'c%20d';
        workingURL = u.href === 'http://a/c%20d';
      } catch (e) {
        // silently fail
      }
    }
    if (!baseURI) {
      baseURI = document.baseURI || window.location.href;
    }
    if (workingURL) {
      return new URL(url, baseURI).href;
    }
    // Fallback to creating an anchor into a disconnected document.
    if (!resolveDoc) {
      resolveDoc = document.implementation.createHTMLDocument('temp');
      resolveDoc.base = resolveDoc.createElement('base');
      resolveDoc.head.appendChild(resolveDoc.base);
      resolveDoc.anchor = resolveDoc.createElement('a');
      resolveDoc.body.appendChild(resolveDoc.anchor);
    }
    resolveDoc.base.href = baseURI;
    resolveDoc.anchor.href = url;
    return resolveDoc.anchor.href || url;
  }

  /**
   * Resolves any relative URL's in the given CSS text against the provided
   * `ownerDocument`'s `baseURI`.
   *
   * @memberof Polymer.ResolveUrl
   * @param {string} cssText CSS text to process
   * @param {string} baseURI Base URI to resolve the URL against
   * @return {string} Processed CSS text with resolved URL's
   */
  function resolveCss(cssText, baseURI) {
    return cssText.replace(CSS_URL_RX, function (m, pre, url, post) {
      return pre + '\'' + resolveUrl(url.replace(/["']/g, ''), baseURI) + '\'' + post;
    });
  }

  /**
   * Returns a path from a given `url`. The path includes the trailing
   * `/` from the url.
   *
   * @memberof Polymer.ResolveUrl
   * @param {string} url Input URL to transform
   * @return {string} resolved path
   */
  function pathFromUrl(url) {
    return url.substring(0, url.lastIndexOf('/') + 1);
  }

  /**
   * Module with utilities for resolving relative URL's.
   *
   * @namespace
   * @memberof Polymer
   * @summary Module with utilities for resolving relative URL's.
   */
  Polymer.ResolveUrl = {
    resolveCss: resolveCss,
    resolveUrl: resolveUrl,
    pathFromUrl: pathFromUrl
  };
})();

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(1);

(function () {

  'use strict';

  /** @typedef {{run: function(function(), number=):number, cancel: function(number)}} */

  var AsyncInterface = void 0; // eslint-disable-line no-unused-vars

  // Microtask implemented using Mutation Observer
  var microtaskCurrHandle = 0;
  var microtaskLastHandle = 0;
  var microtaskCallbacks = [];
  var microtaskNodeContent = 0;
  var microtaskNode = document.createTextNode('');
  new window.MutationObserver(microtaskFlush).observe(microtaskNode, { characterData: true });

  function microtaskFlush() {
    var len = microtaskCallbacks.length;
    for (var i = 0; i < len; i++) {
      var cb = microtaskCallbacks[i];
      if (cb) {
        try {
          cb();
        } catch (e) {
          setTimeout(function () {
            throw e;
          });
        }
      }
    }
    microtaskCallbacks.splice(0, len);
    microtaskLastHandle += len;
  }

  /**
   * Module that provides a number of strategies for enqueuing asynchronous
   * tasks.  Each sub-module provides a standard `run(fn)` interface that returns a
   * handle, and a `cancel(handle)` interface for canceling async tasks before
   * they run.
   *
   * @namespace
   * @memberof Polymer
   * @summary Module that provides a number of strategies for enqueuing asynchronous
   * tasks.
   */
  Polymer.Async = {

    /**
     * Async interface wrapper around `setTimeout`.
     *
     * @namespace
     * @memberof Polymer.Async
     * @summary Async interface wrapper around `setTimeout`.
     */
    timeOut: {
      /**
       * Returns a sub-module with the async interface providing the provided
       * delay.
       *
       * @memberof Polymer.Async.timeOut
       * @param {number} delay Time to wait before calling callbacks in ms
       * @return {AsyncInterface} An async timeout interface
       */
      after: function after(delay) {
        return {
          run: function run(fn) {
            return setTimeout(fn, delay);
          },

          cancel: window.clearTimeout.bind(window)
        };
      },

      /**
       * Enqueues a function called in the next task.
       *
       * @memberof Polymer.Async.timeOut
       * @param {Function} fn Callback to run
       * @return {number} Handle used for canceling task
       */
      run: window.setTimeout.bind(window),
      /**
       * Cancels a previously enqueued `timeOut` callback.
       *
       * @memberof Polymer.Async.timeOut
       * @param {number} handle Handle returned from `run` of callback to cancel
       */
      cancel: window.clearTimeout.bind(window)
    },

    /**
     * Async interface wrapper around `requestAnimationFrame`.
     *
     * @namespace
     * @memberof Polymer.Async
     * @summary Async interface wrapper around `requestAnimationFrame`.
     */
    animationFrame: {
      /**
       * Enqueues a function called at `requestAnimationFrame` timing.
       *
       * @memberof Polymer.Async.animationFrame
       * @param {Function} fn Callback to run
       * @return {number} Handle used for canceling task
       */
      run: window.requestAnimationFrame.bind(window),
      /**
       * Cancels a previously enqueued `animationFrame` callback.
       *
       * @memberof Polymer.Async.timeOut
       * @param {number} handle Handle returned from `run` of callback to cancel
       */
      cancel: window.cancelAnimationFrame.bind(window)
    },

    /**
     * Async interface wrapper around `requestIdleCallback`.  Falls back to
     * `setTimeout` on browsers that do not support `requestIdleCallback`.
     *
     * @namespace
     * @memberof Polymer.Async
     * @summary Async interface wrapper around `requestIdleCallback`.
     */
    idlePeriod: {
      /**
       * Enqueues a function called at `requestIdleCallback` timing.
       *
       * @memberof Polymer.Async.idlePeriod
       * @param {function(IdleDeadline)} fn Callback to run
       * @return {number} Handle used for canceling task
       */
      run: function run(fn) {
        return window.requestIdleCallback ? window.requestIdleCallback(fn) : window.setTimeout(fn, 16);
      },

      /**
       * Cancels a previously enqueued `idlePeriod` callback.
       *
       * @memberof Polymer.Async.idlePeriod
       * @param {number} handle Handle returned from `run` of callback to cancel
       */
      cancel: function cancel(handle) {
        window.cancelIdleCallback ? window.cancelIdleCallback(handle) : window.clearTimeout(handle);
      }
    },

    /**
     * Async interface for enqueueing callbacks that run at microtask timing.
     *
     * Note that microtask timing is achieved via a single `MutationObserver`,
     * and thus callbacks enqueued with this API will all run in a single
     * batch, and not interleaved with other microtasks such as promises.
     * Promises are avoided as an implementation choice for the time being
     * due to Safari bugs that cause Promises to lack microtask guarantees.
     *
     * @namespace
     * @memberof Polymer.Async
     * @summary Async interface for enqueueing callbacks that run at microtask
     *   timing.
     */
    microTask: {

      /**
       * Enqueues a function called at microtask timing.
       *
       * @memberof Polymer.Async.microTask
       * @param {Function} callback Callback to run
       * @return {number} Handle used for canceling task
       */
      run: function run(callback) {
        microtaskNode.textContent = microtaskNodeContent++;
        microtaskCallbacks.push(callback);
        return microtaskCurrHandle++;
      },


      /**
       * Cancels a previously enqueued `microTask` callback.
       *
       * @memberof Polymer.Async.microTask
       * @param {number} handle Handle returned from `run` of callback to cancel
       */
      cancel: function cancel(handle) {
        var idx = handle - microtaskLastHandle;
        if (idx >= 0) {
          if (!microtaskCallbacks[idx]) {
            throw new Error('invalid async handle: ' + handle);
          }
          microtaskCallbacks[idx] = null;
        }
      }
    }
  };
})();

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

__webpack_require__(3);

(function () {
  'use strict';

  // Common implementation for mixin & behavior

  function mutablePropertyChange(inst, property, value, old, mutableData) {
    var isObject = void 0;
    if (mutableData) {
      isObject = (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && value !== null;
      // Pull `old` for Objects from temp cache, but treat `null` as a primitive
      if (isObject) {
        old = inst.__dataTemp[property];
      }
    }
    // Strict equality check, but return false for NaN===NaN
    var shouldChange = old !== value && (old === old || value === value);
    // Objects are stored in temporary cache (cleared at end of
    // turn), which is used for dirty-checking
    if (isObject && shouldChange) {
      inst.__dataTemp[property] = value;
    }
    return shouldChange;
  }

  /**
   * Element class mixin to skip strict dirty-checking for objects and arrays
   * (always consider them to be "dirty"), for use on elements utilizing
   * `Polymer.PropertyEffects`
   *
   * By default, `Polymer.PropertyEffects` performs strict dirty checking on
   * objects, which means that any deep modifications to an object or array will
   * not be propagated unless "immutable" data patterns are used (i.e. all object
   * references from the root to the mutation were changed).
   *
   * Polymer also provides a proprietary data mutation and path notification API
   * (e.g. `notifyPath`, `set`, and array mutation API's) that allow efficient
   * mutation and notification of deep changes in an object graph to all elements
   * bound to the same object graph.
   *
   * In cases where neither immutable patterns nor the data mutation API can be
   * used, applying this mixin will cause Polymer to skip dirty checking for
   * objects and arrays (always consider them to be "dirty").  This allows a
   * user to make a deep modification to a bound object graph, and then either
   * simply re-set the object (e.g. `this.items = this.items`) or call `notifyPath`
   * (e.g. `this.notifyPath('items')`) to update the tree.  Note that all
   * elements that wish to be updated based on deep mutations must apply this
   * mixin or otherwise skip strict dirty checking for objects/arrays.
   *
   * In order to make the dirty check strategy configurable, see
   * `Polymer.OptionalMutableData`.
   *
   * Note, the performance characteristics of propagating large object graphs
   * will be worse as opposed to using strict dirty checking with immutable
   * patterns or Polymer's path notification API.
   *
   * @mixinFunction
   * @polymer
   * @memberof Polymer
   * @summary Element class mixin to skip strict dirty-checking for objects
   *   and arrays
   */
  Polymer.MutableData = Polymer.dedupingMixin(function (superClass) {

    /**
     * @polymer
     * @mixinClass
     * @implements {Polymer_MutableData}
     */
    var MutableData = function (_superClass) {
      _inherits(MutableData, _superClass);

      function MutableData() {
        _classCallCheck(this, MutableData);

        return _possibleConstructorReturn(this, (MutableData.__proto__ || Object.getPrototypeOf(MutableData)).apply(this, arguments));
      }

      _createClass(MutableData, [{
        key: '_shouldPropertyChange',

        /**
         * Overrides `Polymer.PropertyEffects` to provide option for skipping
         * strict equality checking for Objects and Arrays.
         *
         * This method pulls the value to dirty check against from the `__dataTemp`
         * cache (rather than the normal `__data` cache) for Objects.  Since the temp
         * cache is cleared at the end of a turn, this implementation allows
         * side-effects of deep object changes to be processed by re-setting the
         * same object (using the temp cache as an in-turn backstop to prevent
         * cycles due to 2-way notification).
         *
         * @param {string} property Property name
         * @param {*} value New property value
         * @param {*} old Previous property value
         * @return {boolean} Whether the property should be considered a change
         * @protected
         */
        value: function _shouldPropertyChange(property, value, old) {
          return mutablePropertyChange(this, property, value, old, true);
        }
      }]);

      return MutableData;
    }(superClass);
    /** @type {boolean} */


    MutableData.prototype.mutableData = false;

    return MutableData;
  });

  /**
   * Element class mixin to add the optional ability to skip strict
   * dirty-checking for objects and arrays (always consider them to be
   * "dirty") by setting a `mutable-data` attribute on an element instance.
   *
   * By default, `Polymer.PropertyEffects` performs strict dirty checking on
   * objects, which means that any deep modifications to an object or array will
   * not be propagated unless "immutable" data patterns are used (i.e. all object
   * references from the root to the mutation were changed).
   *
   * Polymer also provides a proprietary data mutation and path notification API
   * (e.g. `notifyPath`, `set`, and array mutation API's) that allow efficient
   * mutation and notification of deep changes in an object graph to all elements
   * bound to the same object graph.
   *
   * In cases where neither immutable patterns nor the data mutation API can be
   * used, applying this mixin will allow Polymer to skip dirty checking for
   * objects and arrays (always consider them to be "dirty").  This allows a
   * user to make a deep modification to a bound object graph, and then either
   * simply re-set the object (e.g. `this.items = this.items`) or call `notifyPath`
   * (e.g. `this.notifyPath('items')`) to update the tree.  Note that all
   * elements that wish to be updated based on deep mutations must apply this
   * mixin or otherwise skip strict dirty checking for objects/arrays.
   *
   * While this mixin adds the ability to forgo Object/Array dirty checking,
   * the `mutableData` flag defaults to false and must be set on the instance.
   *
   * Note, the performance characteristics of propagating large object graphs
   * will be worse by relying on `mutableData: true` as opposed to using
   * strict dirty checking with immutable patterns or Polymer's path notification
   * API.
   *
   * @mixinFunction
   * @polymer
   * @memberof Polymer
   * @summary Element class mixin to optionally skip strict dirty-checking
   *   for objects and arrays
   */
  Polymer.OptionalMutableData = Polymer.dedupingMixin(function (superClass) {

    /**
     * @mixinClass
     * @polymer
     * @implements {Polymer_OptionalMutableData}
     */
    var OptionalMutableData = function (_superClass2) {
      _inherits(OptionalMutableData, _superClass2);

      function OptionalMutableData() {
        _classCallCheck(this, OptionalMutableData);

        return _possibleConstructorReturn(this, (OptionalMutableData.__proto__ || Object.getPrototypeOf(OptionalMutableData)).apply(this, arguments));
      }

      _createClass(OptionalMutableData, [{
        key: '_shouldPropertyChange',


        /**
         * Overrides `Polymer.PropertyEffects` to provide option for skipping
         * strict equality checking for Objects and Arrays.
         *
         * When `this.mutableData` is true on this instance, this method
         * pulls the value to dirty check against from the `__dataTemp` cache
         * (rather than the normal `__data` cache) for Objects.  Since the temp
         * cache is cleared at the end of a turn, this implementation allows
         * side-effects of deep object changes to be processed by re-setting the
         * same object (using the temp cache as an in-turn backstop to prevent
         * cycles due to 2-way notification).
         *
         * @param {string} property Property name
         * @param {*} value New property value
         * @param {*} old Previous property value
         * @return {boolean} Whether the property should be considered a change
         * @protected
         */
        value: function _shouldPropertyChange(property, value, old) {
          return mutablePropertyChange(this, property, value, old, this.mutableData);
        }
      }], [{
        key: 'properties',
        get: function get() {
          return {
            /**
             * Instance-level flag for configuring the dirty-checking strategy
             * for this element.  When true, Objects and Arrays will skip dirty
             * checking, otherwise strict equality checking will be used.
             */
            mutableData: Boolean
          };
        }
      }]);

      return OptionalMutableData;
    }(superClass);

    return OptionalMutableData;
  });

  // Export for use by legacy behavior
  Polymer.MutableData._mutablePropertyChange = mutablePropertyChange;
})();

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(1);

(function () {
  'use strict';

  var caseMap = {};
  var DASH_TO_CAMEL = /-[a-z]/g;
  var CAMEL_TO_DASH = /([A-Z])/g;

  /**
   * Module with utilities for converting between "dash-case" and "camelCase"
   * identifiers.
   *
   * @namespace
   * @memberof Polymer
   * @summary Module that provides utilities for converting between "dash-case"
   *   and "camelCase".
   */
  var CaseMap = {

    /**
     * Converts "dash-case" identifier (e.g. `foo-bar-baz`) to "camelCase"
     * (e.g. `fooBarBaz`).
     *
     * @memberof Polymer.CaseMap
     * @param {string} dash Dash-case identifier
     * @return {string} Camel-case representation of the identifier
     */
    dashToCamelCase: function dashToCamelCase(dash) {
      return caseMap[dash] || (caseMap[dash] = dash.indexOf('-') < 0 ? dash : dash.replace(DASH_TO_CAMEL, function (m) {
        return m[1].toUpperCase();
      }));
    },


    /**
     * Converts "camelCase" identifier (e.g. `fooBarBaz`) to "dash-case"
     * (e.g. `foo-bar-baz`).
     *
     * @memberof Polymer.CaseMap
     * @param {string} camel Camel-case identifier
     * @return {string} Dash-case representation of the identifier
     */
    camelToDashCase: function camelToDashCase(camel) {
      return caseMap[camel] || (caseMap[camel] = camel.replace(CAMEL_TO_DASH, '-$1').toLowerCase());
    }
  };

  Polymer.CaseMap = CaseMap;
})();

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

__webpack_require__(1);

__webpack_require__(3);

__webpack_require__(41);

__webpack_require__(10);

__webpack_require__(42);

__webpack_require__(43);

(function () {

  'use strict';

  /** @const {Object} */

  var CaseMap = Polymer.CaseMap;

  // Monotonically increasing unique ID used for de-duping effects triggered
  // from multiple properties in the same turn
  var dedupeId = 0;

  /**
   * Property effect types; effects are stored on the prototype using these keys
   * @enum {string}
   */
  var TYPES = {
    COMPUTE: '__computeEffects',
    REFLECT: '__reflectEffects',
    NOTIFY: '__notifyEffects',
    PROPAGATE: '__propagateEffects',
    OBSERVE: '__observeEffects',
    READ_ONLY: '__readOnly'

    /**
     * @typedef {{
     * name: (string | undefined),
     * structured: (boolean | undefined),
     * wildcard: (boolean | undefined)
     * }}
     */
  };var DataTrigger = void 0; //eslint-disable-line no-unused-vars

  /**
   * @typedef {{
   * info: ?,
   * trigger: (!DataTrigger | undefined),
   * fn: (!Function | undefined)
   * }}
   */
  var DataEffect = void 0; //eslint-disable-line no-unused-vars

  var PropertyEffectsType = void 0; //eslint-disable-line no-unused-vars

  /**
   * Ensures that the model has an own-property map of effects for the given type.
   * The model may be a prototype or an instance.
   *
   * Property effects are stored as arrays of effects by property in a map,
   * by named type on the model. e.g.
   *
   *   __computeEffects: {
   *     foo: [ ... ],
   *     bar: [ ... ]
   *   }
   *
   * If the model does not yet have an effect map for the type, one is created
   * and returned.  If it does, but it is not an own property (i.e. the
   * prototype had effects), the the map is deeply cloned and the copy is
   * set on the model and returned, ready for new effects to be added.
   *
   * @param {Object} model Prototype or instance
   * @param {string} type Property effect type
   * @return {Object} The own-property map of effects for the given type
   * @private
   */
  function ensureOwnEffectMap(model, type) {
    var effects = model[type];
    if (!effects) {
      effects = model[type] = {};
    } else if (!model.hasOwnProperty(type)) {
      effects = model[type] = Object.create(model[type]);
      for (var p in effects) {
        var protoFx = effects[p];
        var instFx = effects[p] = Array(protoFx.length);
        for (var i = 0; i < protoFx.length; i++) {
          instFx[i] = protoFx[i];
        }
      }
    }
    return effects;
  }

  // -- effects ----------------------------------------------

  /**
   * Runs all effects of a given type for the given set of property changes
   * on an instance.
   *
   * @param {!PropertyEffectsType} inst The instance with effects to run
   * @param {Object} effects Object map of property-to-Array of effects
   * @param {Object} props Bag of current property changes
   * @param {Object=} oldProps Bag of previous values for changed properties
   * @param {boolean=} hasPaths True with `props` contains one or more paths
   * @param {*=} extraArgs Additional metadata to pass to effect function
   * @return {boolean} True if an effect ran for this property
   * @private
   */
  function runEffects(inst, effects, props, oldProps, hasPaths, extraArgs) {
    if (effects) {
      var ran = false;
      var id = dedupeId++;
      for (var prop in props) {
        if (runEffectsForProperty(inst, effects, id, prop, props, oldProps, hasPaths, extraArgs)) {
          ran = true;
        }
      }
      return ran;
    }
    return false;
  }

  /**
   * Runs a list of effects for a given property.
   *
   * @param {!PropertyEffectsType} inst The instance with effects to run
   * @param {Object} effects Object map of property-to-Array of effects
   * @param {number} dedupeId Counter used for de-duping effects
   * @param {string} prop Name of changed property
   * @param {*} props Changed properties
   * @param {*} oldProps Old properties
   * @param {boolean=} hasPaths True with `props` contains one or more paths
   * @param {*=} extraArgs Additional metadata to pass to effect function
   * @return {boolean} True if an effect ran for this property
   * @private
   */
  function runEffectsForProperty(inst, effects, dedupeId, prop, props, oldProps, hasPaths, extraArgs) {
    var ran = false;
    var rootProperty = hasPaths ? Polymer.Path.root(prop) : prop;
    var fxs = effects[rootProperty];
    if (fxs) {
      for (var i = 0, l = fxs.length, fx; i < l && (fx = fxs[i]); i++) {
        if ((!fx.info || fx.info.lastRun !== dedupeId) && (!hasPaths || pathMatchesTrigger(prop, fx.trigger))) {
          if (fx.info) {
            fx.info.lastRun = dedupeId;
          }
          fx.fn(inst, prop, props, oldProps, fx.info, hasPaths, extraArgs);
          ran = true;
        }
      }
    }
    return ran;
  }

  /**
   * Determines whether a property/path that has changed matches the trigger
   * criteria for an effect.  A trigger is a descriptor with the following
   * structure, which matches the descriptors returned from `parseArg`.
   * e.g. for `foo.bar.*`:
   * ```
   * trigger: {
   *   name: 'a.b',
   *   structured: true,
   *   wildcard: true
   * }
   * ```
   * If no trigger is given, the path is deemed to match.
   *
   * @param {string} path Path or property that changed
   * @param {DataTrigger} trigger Descriptor
   * @return {boolean} Whether the path matched the trigger
   */
  function pathMatchesTrigger(path, trigger) {
    if (trigger) {
      var triggerPath = trigger.name;
      return triggerPath == path || trigger.structured && Polymer.Path.isAncestor(triggerPath, path) || trigger.wildcard && Polymer.Path.isDescendant(triggerPath, path);
    } else {
      return true;
    }
  }

  /**
   * Implements the "observer" effect.
   *
   * Calls the method with `info.methodName` on the instance, passing the
   * new and old values.
   *
   * @param {!PropertyEffectsType} inst The instance the effect will be run on
   * @param {string} property Name of property
   * @param {Object} props Bag of current property changes
   * @param {Object} oldProps Bag of previous values for changed properties
   * @param {?} info Effect metadata
   * @private
   */
  function runObserverEffect(inst, property, props, oldProps, info) {
    var fn = inst[info.methodName];
    var changedProp = info.property;
    if (fn) {
      fn.call(inst, inst.__data[changedProp], oldProps[changedProp]);
    } else if (!info.dynamicFn) {
      console.warn('observer method `' + info.methodName + '` not defined');
    }
  }

  /**
   * Runs "notify" effects for a set of changed properties.
   *
   * This method differs from the generic `runEffects` method in that it
   * will dispatch path notification events in the case that the property
   * changed was a path and the root property for that path didn't have a
   * "notify" effect.  This is to maintain 1.0 behavior that did not require
   * `notify: true` to ensure object sub-property notifications were
   * sent.
   *
   * @param {!PropertyEffectsType} inst The instance with effects to run
   * @param {Object} notifyProps Bag of properties to notify
   * @param {Object} props Bag of current property changes
   * @param {Object} oldProps Bag of previous values for changed properties
   * @param {boolean} hasPaths True with `props` contains one or more paths
   * @private
   */
  function runNotifyEffects(inst, notifyProps, props, oldProps, hasPaths) {
    // Notify
    var fxs = inst[TYPES.NOTIFY];
    var notified = void 0;
    var id = dedupeId++;
    // Try normal notify effects; if none, fall back to try path notification
    for (var prop in notifyProps) {
      if (notifyProps[prop]) {
        if (fxs && runEffectsForProperty(inst, fxs, id, prop, props, oldProps, hasPaths)) {
          notified = true;
        } else if (hasPaths && notifyPath(inst, prop, props)) {
          notified = true;
        }
      }
    }
    // Flush host if we actually notified and host was batching
    // And the host has already initialized clients; this prevents
    // an issue with a host observing data changes before clients are ready.
    var host = void 0;
    if (notified && (host = inst.__dataHost) && host._invalidateProperties) {
      host._invalidateProperties();
    }
  }

  /**
   * Dispatches {property}-changed events with path information in the detail
   * object to indicate a sub-path of the property was changed.
   *
   * @param {!PropertyEffectsType} inst The element from which to fire the event
   * @param {string} path The path that was changed
   * @param {Object} props Bag of current property changes
   * @return {boolean} Returns true if the path was notified
   * @private
   */
  function notifyPath(inst, path, props) {
    var rootProperty = Polymer.Path.root(path);
    if (rootProperty !== path) {
      var eventName = Polymer.CaseMap.camelToDashCase(rootProperty) + '-changed';
      dispatchNotifyEvent(inst, eventName, props[path], path);
      return true;
    }
    return false;
  }

  /**
   * Dispatches {property}-changed events to indicate a property (or path)
   * changed.
   *
   * @param {!PropertyEffectsType} inst The element from which to fire the event
   * @param {string} eventName The name of the event to send ('{property}-changed')
   * @param {*} value The value of the changed property
   * @param {string | null | undefined} path If a sub-path of this property changed, the path
   *   that changed (optional).
   * @private
   * @suppress {invalidCasts}
   */
  function dispatchNotifyEvent(inst, eventName, value, path) {
    var detail = {
      value: value,
      queueProperty: true
    };
    if (path) {
      detail.path = path;
    }
    /** @type {!HTMLElement} */inst.dispatchEvent(new CustomEvent(eventName, { detail: detail }));
  }

  /**
   * Implements the "notify" effect.
   *
   * Dispatches a non-bubbling event named `info.eventName` on the instance
   * with a detail object containing the new `value`.
   *
   * @param {!PropertyEffectsType} inst The instance the effect will be run on
   * @param {string} property Name of property
   * @param {Object} props Bag of current property changes
   * @param {Object} oldProps Bag of previous values for changed properties
   * @param {?} info Effect metadata
   * @param {boolean} hasPaths True with `props` contains one or more paths
   * @private
   */
  function runNotifyEffect(inst, property, props, oldProps, info, hasPaths) {
    var rootProperty = hasPaths ? Polymer.Path.root(property) : property;
    var path = rootProperty != property ? property : null;
    var value = path ? Polymer.Path.get(inst, path) : inst.__data[property];
    if (path && value === undefined) {
      value = props[property]; // specifically for .splices
    }
    dispatchNotifyEvent(inst, info.eventName, value, path);
  }

  /**
   * Handler function for 2-way notification events. Receives context
   * information captured in the `addNotifyListener` closure from the
   * `__notifyListeners` metadata.
   *
   * Sets the value of the notified property to the host property or path.  If
   * the event contained path information, translate that path to the host
   * scope's name for that path first.
   *
   * @param {CustomEvent} event Notification event (e.g. '<property>-changed')
   * @param {!PropertyEffectsType} inst Host element instance handling the notification event
   * @param {string} fromProp Child element property that was bound
   * @param {string} toPath Host property/path that was bound
   * @param {boolean} negate Whether the binding was negated
   * @private
   */
  function handleNotification(event, inst, fromProp, toPath, negate) {
    var value = void 0;
    var detail = /** @type {Object} */event.detail;
    var fromPath = detail && detail.path;
    if (fromPath) {
      toPath = Polymer.Path.translate(fromProp, toPath, fromPath);
      value = detail && detail.value;
    } else {
      value = event.target[fromProp];
    }
    value = negate ? !value : value;
    if (!inst[TYPES.READ_ONLY] || !inst[TYPES.READ_ONLY][toPath]) {
      if (inst._setPendingPropertyOrPath(toPath, value, true, Boolean(fromPath)) && (!detail || !detail.queueProperty)) {
        inst._invalidateProperties();
      }
    }
  }

  /**
   * Implements the "reflect" effect.
   *
   * Sets the attribute named `info.attrName` to the given property value.
   *
   * @param {!PropertyEffectsType} inst The instance the effect will be run on
   * @param {string} property Name of property
   * @param {Object} props Bag of current property changes
   * @param {Object} oldProps Bag of previous values for changed properties
   * @param {?} info Effect metadata
   * @private
   */
  function runReflectEffect(inst, property, props, oldProps, info) {
    var value = inst.__data[property];
    if (Polymer.sanitizeDOMValue) {
      value = Polymer.sanitizeDOMValue(value, info.attrName, 'attribute', /** @type {Node} */inst);
    }
    inst._propertyToAttribute(property, info.attrName, value);
  }

  /**
   * Runs "computed" effects for a set of changed properties.
   *
   * This method differs from the generic `runEffects` method in that it
   * continues to run computed effects based on the output of each pass until
   * there are no more newly computed properties.  This ensures that all
   * properties that will be computed by the initial set of changes are
   * computed before other effects (binding propagation, observers, and notify)
   * run.
   *
   * @param {!PropertyEffectsType} inst The instance the effect will be run on
   * @param {!Object} changedProps Bag of changed properties
   * @param {!Object} oldProps Bag of previous values for changed properties
   * @param {boolean} hasPaths True with `props` contains one or more paths
   * @private
   */
  function runComputedEffects(inst, changedProps, oldProps, hasPaths) {
    var computeEffects = inst[TYPES.COMPUTE];
    if (computeEffects) {
      var inputProps = changedProps;
      while (runEffects(inst, computeEffects, inputProps, oldProps, hasPaths)) {
        Object.assign(oldProps, inst.__dataOld);
        Object.assign(changedProps, inst.__dataPending);
        inputProps = inst.__dataPending;
        inst.__dataPending = null;
      }
    }
  }

  /**
   * Implements the "computed property" effect by running the method with the
   * values of the arguments specified in the `info` object and setting the
   * return value to the computed property specified.
   *
   * @param {!PropertyEffectsType} inst The instance the effect will be run on
   * @param {string} property Name of property
   * @param {Object} props Bag of current property changes
   * @param {Object} oldProps Bag of previous values for changed properties
   * @param {?} info Effect metadata
   * @private
   */
  function runComputedEffect(inst, property, props, oldProps, info) {
    var result = runMethodEffect(inst, property, props, oldProps, info);
    var computedProp = info.methodInfo;
    if (inst.__dataHasAccessor && inst.__dataHasAccessor[computedProp]) {
      inst._setPendingProperty(computedProp, result, true);
    } else {
      inst[computedProp] = result;
    }
  }

  /**
   * Computes path changes based on path links set up using the `linkPaths`
   * API.
   *
   * @param {!PropertyEffectsType} inst The instance whose props are changing
   * @param {string | !Array<(string|number)>} path Path that has changed
   * @param {*} value Value of changed path
   * @private
   */
  function computeLinkedPaths(inst, path, value) {
    var links = inst.__dataLinkedPaths;
    if (links) {
      var link = void 0;
      for (var a in links) {
        var b = links[a];
        if (Polymer.Path.isDescendant(a, path)) {
          link = Polymer.Path.translate(a, b, path);
          inst._setPendingPropertyOrPath(link, value, true, true);
        } else if (Polymer.Path.isDescendant(b, path)) {
          link = Polymer.Path.translate(b, a, path);
          inst._setPendingPropertyOrPath(link, value, true, true);
        }
      }
    }
  }

  // -- bindings ----------------------------------------------

  /**
   * Adds binding metadata to the current `nodeInfo`, and binding effects
   * for all part dependencies to `templateInfo`.
   *
   * @param {Function} constructor Class that `_parseTemplate` is currently
   *   running on
   * @param {TemplateInfo} templateInfo Template metadata for current template
   * @param {NodeInfo} nodeInfo Node metadata for current template node
   * @param {string} kind Binding kind, either 'property', 'attribute', or 'text'
   * @param {string} target Target property name
   * @param {!Array<!BindingPart>} parts Array of binding part metadata
   * @param {string=} literal Literal text surrounding binding parts (specified
   *   only for 'property' bindings, since these must be initialized as part
   *   of boot-up)
   * @private
   */
  function addBinding(constructor, templateInfo, nodeInfo, kind, target, parts, literal) {
    // Create binding metadata and add to nodeInfo
    nodeInfo.bindings = nodeInfo.bindings || [];
    var /** Binding */binding = { kind: kind, target: target, parts: parts, literal: literal, isCompound: parts.length !== 1 };
    nodeInfo.bindings.push(binding);
    // Add listener info to binding metadata
    if (shouldAddListener(binding)) {
      var _binding$parts$ = binding.parts[0],
          event = _binding$parts$.event,
          negate = _binding$parts$.negate;

      binding.listenerEvent = event || CaseMap.camelToDashCase(target) + '-changed';
      binding.listenerNegate = negate;
    }
    // Add "propagate" property effects to templateInfo
    var index = templateInfo.nodeInfoList.length;
    for (var i = 0; i < binding.parts.length; i++) {
      var part = binding.parts[i];
      part.compoundIndex = i;
      addEffectForBindingPart(constructor, templateInfo, binding, part, index);
    }
  }

  /**
   * Adds property effects to the given `templateInfo` for the given binding
   * part.
   *
   * @param {Function} constructor Class that `_parseTemplate` is currently
   *   running on
   * @param {TemplateInfo} templateInfo Template metadata for current template
   * @param {!Binding} binding Binding metadata
   * @param {!BindingPart} part Binding part metadata
   * @param {number} index Index into `nodeInfoList` for this node
   */
  function addEffectForBindingPart(constructor, templateInfo, binding, part, index) {
    if (!part.literal) {
      if (binding.kind === 'attribute' && binding.target[0] === '-') {
        console.warn('Cannot set attribute ' + binding.target + ' because "-" is not a valid attribute starting character');
      } else {
        var dependencies = part.dependencies;
        var info = { index: index, binding: binding, part: part, evaluator: constructor };
        for (var j = 0; j < dependencies.length; j++) {
          var trigger = dependencies[j];
          if (typeof trigger == 'string') {
            trigger = parseArg(trigger);
            trigger.wildcard = true;
          }
          constructor._addTemplatePropertyEffect(templateInfo, trigger.rootProperty, {
            fn: runBindingEffect,
            info: info, trigger: trigger
          });
        }
      }
    }
  }

  /**
   * Implements the "binding" (property/path binding) effect.
   *
   * Note that binding syntax is overridable via `_parseBindings` and
   * `_evaluateBinding`.  This method will call `_evaluateBinding` for any
   * non-literal parts returned from `_parseBindings`.  However,
   * there is no support for _path_ bindings via custom binding parts,
   * as this is specific to Polymer's path binding syntax.
   *
   * @param {!PropertyEffectsType} inst The instance the effect will be run on
   * @param {string} path Name of property
   * @param {Object} props Bag of current property changes
   * @param {Object} oldProps Bag of previous values for changed properties
   * @param {?} info Effect metadata
   * @param {boolean} hasPaths True with `props` contains one or more paths
   * @param {Array} nodeList List of nodes associated with `nodeInfoList` template
   *   metadata
   * @private
   */
  function runBindingEffect(inst, path, props, oldProps, info, hasPaths, nodeList) {
    var node = nodeList[info.index];
    var binding = info.binding;
    var part = info.part;
    // Subpath notification: transform path and set to client
    // e.g.: foo="{{obj.sub}}", path: 'obj.sub.prop', set 'foo.prop'=obj.sub.prop
    if (hasPaths && part.source && path.length > part.source.length && binding.kind == 'property' && !binding.isCompound && node.__dataHasAccessor && node.__dataHasAccessor[binding.target]) {
      var value = props[path];
      path = Polymer.Path.translate(part.source, binding.target, path);
      if (node._setPendingPropertyOrPath(path, value, false, true)) {
        inst._enqueueClient(node);
      }
    } else {
      var _value = info.evaluator._evaluateBinding(inst, part, path, props, oldProps, hasPaths);
      // Propagate value to child
      applyBindingValue(inst, node, binding, part, _value);
    }
  }

  /**
   * Sets the value for an "binding" (binding) effect to a node,
   * either as a property or attribute.
   *
   * @param {!PropertyEffectsType} inst The instance owning the binding effect
   * @param {Node} node Target node for binding
   * @param {!Binding} binding Binding metadata
   * @param {!BindingPart} part Binding part metadata
   * @param {*} value Value to set
   * @private
   */
  function applyBindingValue(inst, node, binding, part, value) {
    value = computeBindingValue(node, value, binding, part);
    if (Polymer.sanitizeDOMValue) {
      value = Polymer.sanitizeDOMValue(value, binding.target, binding.kind, node);
    }
    if (binding.kind == 'attribute') {
      // Attribute binding
      inst._valueToNodeAttribute( /** @type {Element} */node, value, binding.target);
    } else {
      // Property binding
      var prop = binding.target;
      if (node.__dataHasAccessor && node.__dataHasAccessor[prop]) {
        if (!node[TYPES.READ_ONLY] || !node[TYPES.READ_ONLY][prop]) {
          if (node._setPendingProperty(prop, value)) {
            inst._enqueueClient(node);
          }
        }
      } else {
        inst._setUnmanagedPropertyToNode(node, prop, value);
      }
    }
  }

  /**
   * Transforms an "binding" effect value based on compound & negation
   * effect metadata, as well as handling for special-case properties
   *
   * @param {Node} node Node the value will be set to
   * @param {*} value Value to set
   * @param {!Binding} binding Binding metadata
   * @param {!BindingPart} part Binding part metadata
   * @return {*} Transformed value to set
   * @private
   */
  function computeBindingValue(node, value, binding, part) {
    if (binding.isCompound) {
      var storage = node.__dataCompoundStorage[binding.target];
      storage[part.compoundIndex] = value;
      value = storage.join('');
    }
    if (binding.kind !== 'attribute') {
      // Some browsers serialize `undefined` to `"undefined"`
      if (binding.target === 'textContent' || node.localName == 'input' && binding.target == 'value') {
        value = value == undefined ? '' : value;
      }
    }
    return value;
  }

  /**
   * Returns true if a binding's metadata meets all the requirements to allow
   * 2-way binding, and therefore a `<property>-changed` event listener should be
   * added:
   * - used curly braces
   * - is a property (not attribute) binding
   * - is not a textContent binding
   * - is not compound
   *
   * @param {!Binding} binding Binding metadata
   * @return {boolean} True if 2-way listener should be added
   * @private
   */
  function shouldAddListener(binding) {
    return Boolean(binding.target) && binding.kind != 'attribute' && binding.kind != 'text' && !binding.isCompound && binding.parts[0].mode === '{';
  }

  /**
   * Setup compound binding storage structures, notify listeners, and dataHost
   * references onto the bound nodeList.
   *
   * @param {!PropertyEffectsType} inst Instance that bas been previously bound
   * @param {TemplateInfo} templateInfo Template metadata
   * @private
   */
  function setupBindings(inst, templateInfo) {
    // Setup compound storage, dataHost, and notify listeners
    var nodeList = templateInfo.nodeList,
        nodeInfoList = templateInfo.nodeInfoList;

    if (nodeInfoList.length) {
      for (var i = 0; i < nodeInfoList.length; i++) {
        var info = nodeInfoList[i];
        var node = nodeList[i];
        var bindings = info.bindings;
        if (bindings) {
          for (var _i = 0; _i < bindings.length; _i++) {
            var binding = bindings[_i];
            setupCompoundStorage(node, binding);
            addNotifyListener(node, inst, binding);
          }
        }
        node.__dataHost = inst;
      }
    }
  }

  /**
   * Initializes `__dataCompoundStorage` local storage on a bound node with
   * initial literal data for compound bindings, and sets the joined
   * literal parts to the bound property.
   *
   * When changes to compound parts occur, they are first set into the compound
   * storage array for that property, and then the array is joined to result in
   * the final value set to the property/attribute.
   *
   * @param {Node} node Bound node to initialize
   * @param {Binding} binding Binding metadata
   * @private
   */
  function setupCompoundStorage(node, binding) {
    if (binding.isCompound) {
      // Create compound storage map
      var storage = node.__dataCompoundStorage || (node.__dataCompoundStorage = {});
      var parts = binding.parts;
      // Copy literals from parts into storage for this binding
      var literals = new Array(parts.length);
      for (var j = 0; j < parts.length; j++) {
        literals[j] = parts[j].literal;
      }
      var target = binding.target;
      storage[target] = literals;
      // Configure properties with their literal parts
      if (binding.literal && binding.kind == 'property') {
        node[target] = binding.literal;
      }
    }
  }

  /**
   * Adds a 2-way binding notification event listener to the node specified
   *
   * @param {Object} node Child element to add listener to
   * @param {!PropertyEffectsType} inst Host element instance to handle notification event
   * @param {Binding} binding Binding metadata
   * @private
   */
  function addNotifyListener(node, inst, binding) {
    if (binding.listenerEvent) {
      var part = binding.parts[0];
      node.addEventListener(binding.listenerEvent, function (e) {
        handleNotification(e, inst, binding.target, part.source, part.negate);
      });
    }
  }

  // -- for method-based effects (complexObserver & computed) --------------

  /**
   * Adds property effects for each argument in the method signature (and
   * optionally, for the method name if `dynamic` is true) that calls the
   * provided effect function.
   *
   * @param {Element | Object} model Prototype or instance
   * @param {!MethodSignature} sig Method signature metadata
   * @param {string} type Type of property effect to add
   * @param {Function} effectFn Function to run when arguments change
   * @param {*=} methodInfo Effect-specific information to be included in
   *   method effect metadata
   * @param {boolean|Object=} dynamicFn Boolean or object map indicating whether
   *   method names should be included as a dependency to the effect. Note,
   *   defaults to true if the signature is static (sig.static is true).
   * @private
   */
  function createMethodEffect(model, sig, type, effectFn, methodInfo, dynamicFn) {
    dynamicFn = sig.static || dynamicFn && ((typeof dynamicFn === 'undefined' ? 'undefined' : _typeof(dynamicFn)) !== 'object' || dynamicFn[sig.methodName]);
    var info = {
      methodName: sig.methodName,
      args: sig.args,
      methodInfo: methodInfo,
      dynamicFn: dynamicFn
    };
    for (var i = 0, arg; i < sig.args.length && (arg = sig.args[i]); i++) {
      if (!arg.literal) {
        model._addPropertyEffect(arg.rootProperty, type, {
          fn: effectFn, info: info, trigger: arg
        });
      }
    }
    if (dynamicFn) {
      model._addPropertyEffect(sig.methodName, type, {
        fn: effectFn, info: info
      });
    }
  }

  /**
   * Calls a method with arguments marshaled from properties on the instance
   * based on the method signature contained in the effect metadata.
   *
   * Multi-property observers, computed properties, and inline computing
   * functions call this function to invoke the method, then use the return
   * value accordingly.
   *
   * @param {!PropertyEffectsType} inst The instance the effect will be run on
   * @param {string} property Name of property
   * @param {Object} props Bag of current property changes
   * @param {Object} oldProps Bag of previous values for changed properties
   * @param {?} info Effect metadata
   * @return {*} Returns the return value from the method invocation
   * @private
   */
  function runMethodEffect(inst, property, props, oldProps, info) {
    // Instances can optionally have a _methodHost which allows redirecting where
    // to find methods. Currently used by `templatize`.
    var context = inst._methodHost || inst;
    var fn = context[info.methodName];
    if (fn) {
      var args = marshalArgs(inst.__data, info.args, property, props);
      return fn.apply(context, args);
    } else if (!info.dynamicFn) {
      console.warn('method `' + info.methodName + '` not defined');
    }
  }

  var emptyArray = [];

  // Regular expressions used for binding
  var IDENT = '(?:' + '[a-zA-Z_$][\\w.:$\\-*]*' + ')';
  var NUMBER = '(?:' + '[-+]?[0-9]*\\.?[0-9]+(?:[eE][-+]?[0-9]+)?' + ')';
  var SQUOTE_STRING = '(?:' + '\'(?:[^\'\\\\]|\\\\.)*\'' + ')';
  var DQUOTE_STRING = '(?:' + '"(?:[^"\\\\]|\\\\.)*"' + ')';
  var STRING = '(?:' + SQUOTE_STRING + '|' + DQUOTE_STRING + ')';
  var ARGUMENT = '(?:(' + IDENT + '|' + NUMBER + '|' + STRING + ')\\s*' + ')';
  var ARGUMENTS = '(?:' + ARGUMENT + '(?:,\\s*' + ARGUMENT + ')*' + ')';
  var ARGUMENT_LIST = '(?:' + '\\(\\s*' + '(?:' + ARGUMENTS + '?' + ')' + '\\)\\s*' + ')';
  var BINDING = '(' + IDENT + '\\s*' + ARGUMENT_LIST + '?' + ')'; // Group 3
  var OPEN_BRACKET = '(\\[\\[|{{)' + '\\s*';
  var CLOSE_BRACKET = '(?:]]|}})';
  var NEGATE = '(?:(!)\\s*)?'; // Group 2
  var EXPRESSION = OPEN_BRACKET + NEGATE + BINDING + CLOSE_BRACKET;
  var bindingRegex = new RegExp(EXPRESSION, "g");

  /**
   * Create a string from binding parts of all the literal parts
   *
   * @param {!Array<BindingPart>} parts All parts to stringify
   * @return {string} String made from the literal parts
   */
  function literalFromParts(parts) {
    var s = '';
    for (var i = 0; i < parts.length; i++) {
      var literal = parts[i].literal;
      s += literal || '';
    }
    return s;
  }

  /**
   * Parses an expression string for a method signature, and returns a metadata
   * describing the method in terms of `methodName`, `static` (whether all the
   * arguments are literals), and an array of `args`
   *
   * @param {string} expression The expression to parse
   * @return {?MethodSignature} The method metadata object if a method expression was
   *   found, otherwise `undefined`
   * @private
   */
  function parseMethod(expression) {
    // tries to match valid javascript property names
    var m = expression.match(/([^\s]+?)\(([\s\S]*)\)/);
    if (m) {
      var methodName = m[1];
      var sig = { methodName: methodName, static: true, args: emptyArray };
      if (m[2].trim()) {
        // replace escaped commas with comma entity, split on un-escaped commas
        var args = m[2].replace(/\\,/g, '&comma;').split(',');
        return parseArgs(args, sig);
      } else {
        return sig;
      }
    }
    return null;
  }

  /**
   * Parses an array of arguments and sets the `args` property of the supplied
   * signature metadata object. Sets the `static` property to false if any
   * argument is a non-literal.
   *
   * @param {!Array<string>} argList Array of argument names
   * @param {!MethodSignature} sig Method signature metadata object
   * @return {!MethodSignature} The updated signature metadata object
   * @private
   */
  function parseArgs(argList, sig) {
    sig.args = argList.map(function (rawArg) {
      var arg = parseArg(rawArg);
      if (!arg.literal) {
        sig.static = false;
      }
      return arg;
    }, this);
    return sig;
  }

  /**
   * Parses an individual argument, and returns an argument metadata object
   * with the following fields:
   *
   *   {
   *     value: 'prop',        // property/path or literal value
   *     literal: false,       // whether argument is a literal
   *     structured: false,    // whether the property is a path
   *     rootProperty: 'prop', // the root property of the path
   *     wildcard: false       // whether the argument was a wildcard '.*' path
   *   }
   *
   * @param {string} rawArg The string value of the argument
   * @return {!MethodArg} Argument metadata object
   * @private
   */
  function parseArg(rawArg) {
    // clean up whitespace
    var arg = rawArg.trim()
    // replace comma entity with comma
    .replace(/&comma;/g, ',')
    // repair extra escape sequences; note only commas strictly need
    // escaping, but we allow any other char to be escaped since its
    // likely users will do this
    .replace(/\\(.)/g, '\$1');
    // basic argument descriptor
    var a = {
      name: arg,
      value: '',
      literal: false
    };
    // detect literal value (must be String or Number)
    var fc = arg[0];
    if (fc === '-') {
      fc = arg[1];
    }
    if (fc >= '0' && fc <= '9') {
      fc = '#';
    }
    switch (fc) {
      case "'":
      case '"':
        a.value = arg.slice(1, -1);
        a.literal = true;
        break;
      case '#':
        a.value = Number(arg);
        a.literal = true;
        break;
    }
    // if not literal, look for structured path
    if (!a.literal) {
      a.rootProperty = Polymer.Path.root(arg);
      // detect structured path (has dots)
      a.structured = Polymer.Path.isPath(arg);
      if (a.structured) {
        a.wildcard = arg.slice(-2) == '.*';
        if (a.wildcard) {
          a.name = arg.slice(0, -2);
        }
      }
    }
    return a;
  }

  /**
   * Gather the argument values for a method specified in the provided array
   * of argument metadata.
   *
   * The `path` and `value` arguments are used to fill in wildcard descriptor
   * when the method is being called as a result of a path notification.
   *
   * @param {Object} data Instance data storage object to read properties from
   * @param {!Array<!MethodArg>} args Array of argument metadata
   * @param {string} path Property/path name that triggered the method effect
   * @param {Object} props Bag of current property changes
   * @return {Array<*>} Array of argument values
   * @private
   */
  function marshalArgs(data, args, path, props) {
    var values = [];
    for (var i = 0, l = args.length; i < l; i++) {
      var arg = args[i];
      var name = arg.name;
      var v = void 0;
      if (arg.literal) {
        v = arg.value;
      } else {
        if (arg.structured) {
          v = Polymer.Path.get(data, name);
          // when data is not stored e.g. `splices`
          if (v === undefined) {
            v = props[name];
          }
        } else {
          v = data[name];
        }
      }
      if (arg.wildcard) {
        // Only send the actual path changed info if the change that
        // caused the observer to run matched the wildcard
        var baseChanged = name.indexOf(path + '.') === 0;
        var matches = path.indexOf(name) === 0 && !baseChanged;
        values[i] = {
          path: matches ? path : name,
          value: matches ? props[path] : v,
          base: v
        };
      } else {
        values[i] = v;
      }
    }
    return values;
  }

  // data api

  /**
   * Sends array splice notifications (`.splices` and `.length`)
   *
   * Note: this implementation only accepts normalized paths
   *
   * @param {!PropertyEffectsType} inst Instance to send notifications to
   * @param {Array} array The array the mutations occurred on
   * @param {string} path The path to the array that was mutated
   * @param {Array} splices Array of splice records
   * @private
   */
  function _notifySplices(inst, array, path, splices) {
    var splicesPath = path + '.splices';
    inst.notifyPath(splicesPath, { indexSplices: splices });
    inst.notifyPath(path + '.length', array.length);
    // Null here to allow potentially large splice records to be GC'ed.
    inst.__data[splicesPath] = { indexSplices: null };
  }

  /**
   * Creates a splice record and sends an array splice notification for
   * the described mutation
   *
   * Note: this implementation only accepts normalized paths
   *
   * @param {!PropertyEffectsType} inst Instance to send notifications to
   * @param {Array} array The array the mutations occurred on
   * @param {string} path The path to the array that was mutated
   * @param {number} index Index at which the array mutation occurred
   * @param {number} addedCount Number of added items
   * @param {Array} removed Array of removed items
   * @private
   */
  function notifySplice(inst, array, path, index, addedCount, removed) {
    _notifySplices(inst, array, path, [{
      index: index,
      addedCount: addedCount,
      removed: removed,
      object: array,
      type: 'splice'
    }]);
  }

  /**
   * Returns an upper-cased version of the string.
   *
   * @param {string} name String to uppercase
   * @return {string} Uppercased string
   * @private
   */
  function upper(name) {
    return name[0].toUpperCase() + name.substring(1);
  }

  /**
   * Element class mixin that provides meta-programming for Polymer's template
   * binding and data observation (collectively, "property effects") system.
   *
   * This mixin uses provides the following key static methods for adding
   * property effects to an element class:
   * - `addPropertyEffect`
   * - `createPropertyObserver`
   * - `createMethodObserver`
   * - `createNotifyingProperty`
   * - `createReadOnlyProperty`
   * - `createReflectedProperty`
   * - `createComputedProperty`
   * - `bindTemplate`
   *
   * Each method creates one or more property accessors, along with metadata
   * used by this mixin's implementation of `_propertiesChanged` to perform
   * the property effects.
   *
   * Underscored versions of the above methods also exist on the element
   * prototype for adding property effects on instances at runtime.
   *
   * Note that this mixin overrides several `PropertyAccessors` methods, in
   * many cases to maintain guarantees provided by the Polymer 1.x features;
   * notably it changes property accessors to be synchronous by default
   * whereas the default when using `PropertyAccessors` standalone is to be
   * async by default.
   *
   * @mixinFunction
   * @polymer
   * @appliesMixin Polymer.TemplateStamp
   * @appliesMixin Polymer.PropertyAccessors
   * @memberof Polymer
   * @summary Element class mixin that provides meta-programming for Polymer's
   * template binding and data observation system.
   */
  Polymer.PropertyEffects = Polymer.dedupingMixin(function (superClass) {

    /**
     * @constructor
     * @extends {superClass}
     * @implements {Polymer_PropertyAccessors}
     * @implements {Polymer_TemplateStamp}
     * @unrestricted
     */
    var propertyEffectsBase = Polymer.TemplateStamp(Polymer.PropertyAccessors(superClass));

    /**
     * @polymer
     * @mixinClass
     * @implements {Polymer_PropertyEffects}
     * @extends {propertyEffectsBase}
     * @unrestricted
     */

    var PropertyEffects = function (_propertyEffectsBase) {
      _inherits(PropertyEffects, _propertyEffectsBase);

      function PropertyEffects() {
        _classCallCheck(this, PropertyEffects);

        /** @type {boolean} */
        var _this = _possibleConstructorReturn(this, (PropertyEffects.__proto__ || Object.getPrototypeOf(PropertyEffects)).call(this));

        _this.__dataClientsReady;
        /** @type {Array} */
        _this.__dataPendingClients;
        /** @type {Object} */
        _this.__dataToNotify;
        /** @type {Object} */
        _this.__dataLinkedPaths;
        /** @type {boolean} */
        _this.__dataHasPaths;
        /** @type {Object} */
        _this.__dataCompoundStorage;
        /** @type {Polymer_PropertyEffects} */
        _this.__dataHost;
        /** @type {!Object} */
        _this.__dataTemp;
        /** @type {boolean} */
        _this.__dataClientsInitialized;
        /** @type {!Object} */
        _this.__data;
        /** @type {!Object} */
        _this.__dataPending;
        /** @type {!Object} */
        _this.__dataOld;
        /** @type {Object} */
        _this.__computeEffects;
        /** @type {Object} */
        _this.__reflectEffects;
        /** @type {Object} */
        _this.__notifyEffects;
        /** @type {Object} */
        _this.__propagateEffects;
        /** @type {Object} */
        _this.__observeEffects;
        /** @type {Object} */
        _this.__readOnly;
        /** @type {number} */
        _this.__dataCounter;
        /** @type {!TemplateInfo} */
        _this.__templateInfo;
        return _this;
      }

      _createClass(PropertyEffects, [{
        key: '_initializeProperties',
        value: function _initializeProperties() {
          _get(PropertyEffects.prototype.__proto__ || Object.getPrototypeOf(PropertyEffects.prototype), '_initializeProperties', this).call(this);
          hostStack.registerHost(this);
          this.__dataClientsReady = false;
          this.__dataPendingClients = null;
          this.__dataToNotify = null;
          this.__dataLinkedPaths = null;
          this.__dataHasPaths = false;
          // May be set on instance prior to upgrade
          this.__dataCompoundStorage = this.__dataCompoundStorage || null;
          this.__dataHost = this.__dataHost || null;
          this.__dataTemp = {};
          this.__dataClientsInitialized = false;
        }

        /**
         * Overrides `Polymer.PropertyAccessors` implementation to provide a
         * more efficient implementation of initializing properties from
         * the prototype on the instance.
         *
         * @override
         * @param {Object} props Properties to initialize on the prototype
         */

      }, {
        key: '_initializeProtoProperties',
        value: function _initializeProtoProperties(props) {
          this.__data = Object.create(props);
          this.__dataPending = Object.create(props);
          this.__dataOld = {};
        }

        /**
         * Overrides `Polymer.PropertyAccessors` implementation to avoid setting
         * `_setProperty`'s `shouldNotify: true`.
         *
         * @override
         * @param {Object} props Properties to initialize on the instance
         */

      }, {
        key: '_initializeInstanceProperties',
        value: function _initializeInstanceProperties(props) {
          var readOnly = this[TYPES.READ_ONLY];
          for (var prop in props) {
            if (!readOnly || !readOnly[prop]) {
              this.__dataPending = this.__dataPending || {};
              this.__dataOld = this.__dataOld || {};
              this.__data[prop] = this.__dataPending[prop] = props[prop];
            }
          }
        }

        // Prototype setup ----------------------------------------

        /**
         * Equivalent to static `addPropertyEffect` API but can be called on
         * an instance to add effects at runtime.  See that method for
         * full API docs.
         *
         * @param {string} property Property that should trigger the effect
         * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES
         * @param {Object=} effect Effect metadata object
         * @protected
         */

      }, {
        key: '_addPropertyEffect',
        value: function _addPropertyEffect(property, type, effect) {
          this._createPropertyAccessor(property, type == TYPES.READ_ONLY);
          // effects are accumulated into arrays per property based on type
          var effects = ensureOwnEffectMap(this, type)[property];
          if (!effects) {
            effects = this[type][property] = [];
          }
          effects.push(effect);
        }

        /**
         * Removes the given property effect.
         *
         * @param {string} property Property the effect was associated with
         * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES
         * @param {Object=} effect Effect metadata object to remove
         */

      }, {
        key: '_removePropertyEffect',
        value: function _removePropertyEffect(property, type, effect) {
          var effects = ensureOwnEffectMap(this, type)[property];
          var idx = effects.indexOf(effect);
          if (idx >= 0) {
            effects.splice(idx, 1);
          }
        }

        /**
         * Returns whether the current prototype/instance has a property effect
         * of a certain type.
         *
         * @param {string} property Property name
         * @param {string=} type Effect type, from this.PROPERTY_EFFECT_TYPES
         * @return {boolean} True if the prototype/instance has an effect of this type
         * @protected
         */

      }, {
        key: '_hasPropertyEffect',
        value: function _hasPropertyEffect(property, type) {
          var effects = this[type];
          return Boolean(effects && effects[property]);
        }

        /**
         * Returns whether the current prototype/instance has a "read only"
         * accessor for the given property.
         *
         * @param {string} property Property name
         * @return {boolean} True if the prototype/instance has an effect of this type
         * @protected
         */

      }, {
        key: '_hasReadOnlyEffect',
        value: function _hasReadOnlyEffect(property) {
          return this._hasPropertyEffect(property, TYPES.READ_ONLY);
        }

        /**
         * Returns whether the current prototype/instance has a "notify"
         * property effect for the given property.
         *
         * @param {string} property Property name
         * @return {boolean} True if the prototype/instance has an effect of this type
         * @protected
         */

      }, {
        key: '_hasNotifyEffect',
        value: function _hasNotifyEffect(property) {
          return this._hasPropertyEffect(property, TYPES.NOTIFY);
        }

        /**
         * Returns whether the current prototype/instance has a "reflect to attribute"
         * property effect for the given property.
         *
         * @param {string} property Property name
         * @return {boolean} True if the prototype/instance has an effect of this type
         * @protected
         */

      }, {
        key: '_hasReflectEffect',
        value: function _hasReflectEffect(property) {
          return this._hasPropertyEffect(property, TYPES.REFLECT);
        }

        /**
         * Returns whether the current prototype/instance has a "computed"
         * property effect for the given property.
         *
         * @param {string} property Property name
         * @return {boolean} True if the prototype/instance has an effect of this type
         * @protected
         */

      }, {
        key: '_hasComputedEffect',
        value: function _hasComputedEffect(property) {
          return this._hasPropertyEffect(property, TYPES.COMPUTE);
        }

        // Runtime ----------------------------------------

        /**
         * Sets a pending property or path.  If the root property of the path in
         * question had no accessor, the path is set, otherwise it is enqueued
         * via `_setPendingProperty`.
         *
         * This function isolates relatively expensive functionality necessary
         * for the public API (`set`, `setProperties`, `notifyPath`, and property
         * change listeners via {{...}} bindings), such that it is only done
         * when paths enter the system, and not at every propagation step.  It
         * also sets a `__dataHasPaths` flag on the instance which is used to
         * fast-path slower path-matching code in the property effects host paths.
         *
         * `path` can be a path string or array of path parts as accepted by the
         * public API.
         *
         * @param {string | !Array<number|string>} path Path to set
         * @param {*} value Value to set
         * @param {boolean=} shouldNotify Set to true if this change should
         *  cause a property notification event dispatch
         * @param {boolean=} isPathNotification If the path being set is a path
         *   notification of an already changed value, as opposed to a request
         *   to set and notify the change.  In the latter `false` case, a dirty
         *   check is performed and then the value is set to the path before
         *   enqueuing the pending property change.
         * @return {boolean} Returns true if the property/path was enqueued in
         *   the pending changes bag.
         * @protected
         */

      }, {
        key: '_setPendingPropertyOrPath',
        value: function _setPendingPropertyOrPath(path, value, shouldNotify, isPathNotification) {
          if (isPathNotification || Polymer.Path.root(Array.isArray(path) ? path[0] : path) !== path) {
            // Dirty check changes being set to a path against the actual object,
            // since this is the entry point for paths into the system; from here
            // the only dirty checks are against the `__dataTemp` cache to prevent
            // duplicate work in the same turn only. Note, if this was a notification
            // of a change already set to a path (isPathNotification: true),
            // we always let the change through and skip the `set` since it was
            // already dirty checked at the point of entry and the underlying
            // object has already been updated
            if (!isPathNotification) {
              var old = Polymer.Path.get(this, path);
              path = /** @type {string} */Polymer.Path.set(this, path, value);
              // Use property-accessor's simpler dirty check
              if (!path || !_get(PropertyEffects.prototype.__proto__ || Object.getPrototypeOf(PropertyEffects.prototype), '_shouldPropertyChange', this).call(this, path, value, old)) {
                return false;
              }
            }
            this.__dataHasPaths = true;
            if (this._setPendingProperty( /**@type{string}*/path, value, shouldNotify)) {
              computeLinkedPaths(this, path, value);
              return true;
            }
          } else {
            if (this.__dataHasAccessor && this.__dataHasAccessor[path]) {
              return this._setPendingProperty( /**@type{string}*/path, value, shouldNotify);
            } else {
              this[path] = value;
            }
          }
          return false;
        }

        /**
         * Applies a value to a non-Polymer element/node's property.
         *
         * The implementation makes a best-effort at binding interop:
         * Some native element properties have side-effects when
         * re-setting the same value (e.g. setting `<input>.value` resets the
         * cursor position), so we do a dirty-check before setting the value.
         * However, for better interop with non-Polymer custom elements that
         * accept objects, we explicitly re-set object changes coming from the
         * Polymer world (which may include deep object changes without the
         * top reference changing), erring on the side of providing more
         * information.
         *
         * Users may override this method to provide alternate approaches.
         *
         * @param {Node} node The node to set a property on
         * @param {string} prop The property to set
         * @param {*} value The value to set
         * @protected
         */

      }, {
        key: '_setUnmanagedPropertyToNode',
        value: function _setUnmanagedPropertyToNode(node, prop, value) {
          // It is a judgment call that resetting primitives is
          // "bad" and resettings objects is also "good"; alternatively we could
          // implement a whitelist of tag & property values that should never
          // be reset (e.g. <input>.value && <select>.value)
          if (value !== node[prop] || (typeof value === 'undefined' ? 'undefined' : _typeof(value)) == 'object') {
            node[prop] = value;
          }
        }

        /**
         * Overrides the `PropertyAccessors` implementation to introduce special
         * dirty check logic depending on the property & value being set:
         *
         * 1. Any value set to a path (e.g. 'obj.prop': 42 or 'obj.prop': {...})
         *    Stored in `__dataTemp`, dirty checked against `__dataTemp`
         * 2. Object set to simple property (e.g. 'prop': {...})
         *    Stored in `__dataTemp` and `__data`, dirty checked against
         *    `__dataTemp` by default implementation of `_shouldPropertyChange`
         * 3. Primitive value set to simple property (e.g. 'prop': 42)
         *    Stored in `__data`, dirty checked against `__data`
         *
         * The dirty-check is important to prevent cycles due to two-way
         * notification, but paths and objects are only dirty checked against any
         * previous value set during this turn via a "temporary cache" that is
         * cleared when the last `_propertiesChaged` exits. This is so:
         * a. any cached array paths (e.g. 'array.3.prop') may be invalidated
         *    due to array mutations like shift/unshift/splice; this is fine
         *    since path changes are dirty-checked at user entry points like `set`
         * b. dirty-checking for objects only lasts one turn to allow the user
         *    to mutate the object in-place and re-set it with the same identity
         *    and have all sub-properties re-propagated in a subsequent turn.
         *
         * The temp cache is not necessarily sufficient to prevent invalid array
         * paths, since a splice can happen during the same turn (with pathological
         * user code); we could introduce a "fixup" for temporarily cached array
         * paths if needed: https://github.com/Polymer/polymer/issues/4227
         *
         * @param {string} property Name of the property
         * @param {*} value Value to set
         * @param {boolean=} shouldNotify True if property should fire notification
         *   event (applies only for `notify: true` properties)
         * @return {boolean} Returns true if the property changed
         * @override
         */

      }, {
        key: '_setPendingProperty',
        value: function _setPendingProperty(property, value, shouldNotify) {
          var isPath = this.__dataHasPaths && Polymer.Path.isPath(property);
          var prevProps = isPath ? this.__dataTemp : this.__data;
          if (this._shouldPropertyChange(property, value, prevProps[property])) {
            if (!this.__dataPending) {
              this.__dataPending = {};
              this.__dataOld = {};
            }
            // Ensure old is captured from the last turn
            if (!(property in this.__dataOld)) {
              this.__dataOld[property] = this.__data[property];
            }
            // Paths are stored in temporary cache (cleared at end of turn),
            // which is used for dirty-checking, all others stored in __data
            if (isPath) {
              this.__dataTemp[property] = value;
            } else {
              this.__data[property] = value;
            }
            // All changes go into pending property bag, passed to _propertiesChanged
            this.__dataPending[property] = value;
            // Track properties that should notify separately
            if (isPath || this[TYPES.NOTIFY] && this[TYPES.NOTIFY][property]) {
              this.__dataToNotify = this.__dataToNotify || {};
              this.__dataToNotify[property] = shouldNotify;
            }
            return true;
          }
          return false;
        }

        /**
         * Overrides base implementation to ensure all accessors set `shouldNotify`
         * to true, for per-property notification tracking.
         *
         * @override
         */

      }, {
        key: '_setProperty',
        value: function _setProperty(property, value) {
          if (this._setPendingProperty(property, value, true)) {
            this._invalidateProperties();
          }
        }

        /**
         * Overrides `PropertyAccessor`'s default async queuing of
         * `_propertiesChanged`: if `__dataReady` is false (has not yet been
         * manually flushed), the function no-ops; otherwise flushes
         * `_propertiesChanged` synchronously.
         *
         * @override
         */

      }, {
        key: '_invalidateProperties',
        value: function _invalidateProperties() {
          if (this.__dataReady) {
            this._flushProperties();
          }
        }

        /**
         * Enqueues the given client on a list of pending clients, whose
         * pending property changes can later be flushed via a call to
         * `_flushClients`.
         *
         * @param {Object} client PropertyEffects client to enqueue
         * @protected
         */

      }, {
        key: '_enqueueClient',
        value: function _enqueueClient(client) {
          this.__dataPendingClients = this.__dataPendingClients || [];
          if (client !== this) {
            this.__dataPendingClients.push(client);
          }
        }

        /**
         * Flushes any clients previously enqueued via `_enqueueClient`, causing
         * their `_flushProperties` method to run.
         *
         * @protected
         */

      }, {
        key: '_flushClients',
        value: function _flushClients() {
          if (!this.__dataClientsReady) {
            this.__dataClientsReady = true;
            this._readyClients();
            // Override point where accessors are turned on; importantly,
            // this is after clients have fully readied, providing a guarantee
            // that any property effects occur only after all clients are ready.
            this.__dataReady = true;
          } else {
            this.__enableOrFlushClients();
          }
        }

        // NOTE: We ensure clients either enable or flush as appropriate. This
        // handles two corner cases:
        // (1) clients flush properly when connected/enabled before the host
        // enables; e.g.
        //   (a) Templatize stamps with no properties and does not flush and
        //   (b) the instance is inserted into dom and
        //   (c) then the instance flushes.
        // (2) clients enable properly when not connected/enabled when the host
        // flushes; e.g.
        //   (a) a template is runtime stamped and not yet connected/enabled
        //   (b) a host sets a property, causing stamped dom to flush
        //   (c) the stamped dom enables.

      }, {
        key: '__enableOrFlushClients',
        value: function __enableOrFlushClients() {
          var clients = this.__dataPendingClients;
          if (clients) {
            this.__dataPendingClients = null;
            for (var i = 0; i < clients.length; i++) {
              var client = clients[i];
              if (!client.__dataEnabled) {
                client._enableProperties();
              } else if (client.__dataPending) {
                client._flushProperties();
              }
            }
          }
        }

        /**
         * Perform any initial setup on client dom. Called before the first
         * `_flushProperties` call on client dom and before any element
         * observers are called.
         *
         * @protected
         */

      }, {
        key: '_readyClients',
        value: function _readyClients() {
          this.__enableOrFlushClients();
        }

        /**
         * Sets a bag of property changes to this instance, and
         * synchronously processes all effects of the properties as a batch.
         *
         * Property names must be simple properties, not paths.  Batched
         * path propagation is not supported.
         *
         * @param {Object} props Bag of one or more key-value pairs whose key is
         *   a property and value is the new value to set for that property.
         * @param {boolean=} setReadOnly When true, any private values set in
         *   `props` will be set. By default, `setProperties` will not set
         *   `readOnly: true` root properties.
         * @public
         */

      }, {
        key: 'setProperties',
        value: function setProperties(props, setReadOnly) {
          for (var path in props) {
            if (setReadOnly || !this[TYPES.READ_ONLY] || !this[TYPES.READ_ONLY][path]) {
              //TODO(kschaaf): explicitly disallow paths in setProperty?
              // wildcard observers currently only pass the first changed path
              // in the `info` object, and you could do some odd things batching
              // paths, e.g. {'foo.bar': {...}, 'foo': null}
              this._setPendingPropertyOrPath(path, props[path], true);
            }
          }
          this._invalidateProperties();
        }

        /**
         * Overrides `PropertyAccessors` so that property accessor
         * side effects are not enabled until after client dom is fully ready.
         * Also calls `_flushClients` callback to ensure client dom is enabled
         * that was not enabled as a result of flushing properties.
         *
         * @override
         */

      }, {
        key: 'ready',
        value: function ready() {
          // It is important that `super.ready()` is not called here as it
          // immediately turns on accessors. Instead, we wait until `readyClients`
          // to enable accessors to provide a guarantee that clients are ready
          // before processing any accessors side effects.
          this._flushProperties();
          // If no data was pending, `_flushProperties` will not `flushClients`
          // so ensure this is done.
          if (!this.__dataClientsReady) {
            this._flushClients();
          }
          // Before ready, client notifications do not trigger _flushProperties.
          // Therefore a flush is necessary here if data has been set.
          if (this.__dataPending) {
            this._flushProperties();
          }
        }

        /**
         * Implements `PropertyAccessors`'s properties changed callback.
         *
         * Runs each class of effects for the batch of changed properties in
         * a specific order (compute, propagate, reflect, observe, notify).
         *
         * @override
         */

      }, {
        key: '_propertiesChanged',
        value: function _propertiesChanged(currentProps, changedProps, oldProps) {
          // ----------------------------
          // let c = Object.getOwnPropertyNames(changedProps || {});
          // window.debug && console.group(this.localName + '#' + this.id + ': ' + c);
          // if (window.debug) { debugger; }
          // ----------------------------
          var hasPaths = this.__dataHasPaths;
          this.__dataHasPaths = false;
          // Compute properties
          runComputedEffects(this, changedProps, oldProps, hasPaths);
          // Clear notify properties prior to possible reentry (propagate, observe),
          // but after computing effects have a chance to add to them
          var notifyProps = this.__dataToNotify;
          this.__dataToNotify = null;
          // Propagate properties to clients
          this._propagatePropertyChanges(changedProps, oldProps, hasPaths);
          // Flush clients
          this._flushClients();
          // Reflect properties
          runEffects(this, this[TYPES.REFLECT], changedProps, oldProps, hasPaths);
          // Observe properties
          runEffects(this, this[TYPES.OBSERVE], changedProps, oldProps, hasPaths);
          // Notify properties to host
          if (notifyProps) {
            runNotifyEffects(this, notifyProps, changedProps, oldProps, hasPaths);
          }
          // Clear temporary cache at end of turn
          if (this.__dataCounter == 1) {
            this.__dataTemp = {};
          }
          // ----------------------------
          // window.debug && console.groupEnd(this.localName + '#' + this.id + ': ' + c);
          // ----------------------------
        }

        /**
         * Called to propagate any property changes to stamped template nodes
         * managed by this element.
         *
         * @param {Object} changedProps Bag of changed properties
         * @param {Object} oldProps Bag of previous values for changed properties
         * @param {boolean} hasPaths True with `props` contains one or more paths
         * @protected
         */

      }, {
        key: '_propagatePropertyChanges',
        value: function _propagatePropertyChanges(changedProps, oldProps, hasPaths) {
          if (this[TYPES.PROPAGATE]) {
            runEffects(this, this[TYPES.PROPAGATE], changedProps, oldProps, hasPaths);
          }
          var templateInfo = this.__templateInfo;
          while (templateInfo) {
            runEffects(this, templateInfo.propertyEffects, changedProps, oldProps, hasPaths, templateInfo.nodeList);
            templateInfo = templateInfo.nextTemplateInfo;
          }
        }

        /**
         * Aliases one data path as another, such that path notifications from one
         * are routed to the other.
         *
         * @param {string | !Array<string|number>} to Target path to link.
         * @param {string | !Array<string|number>} from Source path to link.
         * @public
         */

      }, {
        key: 'linkPaths',
        value: function linkPaths(to, from) {
          to = Polymer.Path.normalize(to);
          from = Polymer.Path.normalize(from);
          this.__dataLinkedPaths = this.__dataLinkedPaths || {};
          this.__dataLinkedPaths[to] = from;
        }

        /**
         * Removes a data path alias previously established with `_linkPaths`.
         *
         * Note, the path to unlink should be the target (`to`) used when
         * linking the paths.
         *
         * @param {string | !Array<string|number>} path Target path to unlink.
         * @public
         */

      }, {
        key: 'unlinkPaths',
        value: function unlinkPaths(path) {
          path = Polymer.Path.normalize(path);
          if (this.__dataLinkedPaths) {
            delete this.__dataLinkedPaths[path];
          }
        }

        /**
         * Notify that an array has changed.
         *
         * Example:
         *
         *     this.items = [ {name: 'Jim'}, {name: 'Todd'}, {name: 'Bill'} ];
         *     ...
         *     this.items.splice(1, 1, {name: 'Sam'});
         *     this.items.push({name: 'Bob'});
         *     this.notifySplices('items', [
         *       { index: 1, removed: [{name: 'Todd'}], addedCount: 1, obect: this.items, type: 'splice' },
         *       { index: 3, removed: [], addedCount: 1, object: this.items, type: 'splice'}
         *     ]);
         *
         * @param {string} path Path that should be notified.
         * @param {Array} splices Array of splice records indicating ordered
         *   changes that occurred to the array. Each record should have the
         *   following fields:
         *    * index: index at which the change occurred
         *    * removed: array of items that were removed from this index
         *    * addedCount: number of new items added at this index
         *    * object: a reference to the array in question
         *    * type: the string literal 'splice'
         *
         *   Note that splice records _must_ be normalized such that they are
         *   reported in index order (raw results from `Object.observe` are not
         *   ordered and must be normalized/merged before notifying).
         * @public
        */

      }, {
        key: 'notifySplices',
        value: function notifySplices(path, splices) {
          var info = { path: '' };
          var array = /** @type {Array} */Polymer.Path.get(this, path, info);
          _notifySplices(this, array, info.path, splices);
        }

        /**
         * Convenience method for reading a value from a path.
         *
         * Note, if any part in the path is undefined, this method returns
         * `undefined` (this method does not throw when dereferencing undefined
         * paths).
         *
         * @param {(string|!Array<(string|number)>)} path Path to the value
         *   to read.  The path may be specified as a string (e.g. `foo.bar.baz`)
         *   or an array of path parts (e.g. `['foo.bar', 'baz']`).  Note that
         *   bracketed expressions are not supported; string-based path parts
         *   *must* be separated by dots.  Note that when dereferencing array
         *   indices, the index may be used as a dotted part directly
         *   (e.g. `users.12.name` or `['users', 12, 'name']`).
         * @param {Object=} root Root object from which the path is evaluated.
         * @return {*} Value at the path, or `undefined` if any part of the path
         *   is undefined.
         * @public
         */

      }, {
        key: 'get',
        value: function get(path, root) {
          return Polymer.Path.get(root || this, path);
        }

        /**
         * Convenience method for setting a value to a path and notifying any
         * elements bound to the same path.
         *
         * Note, if any part in the path except for the last is undefined,
         * this method does nothing (this method does not throw when
         * dereferencing undefined paths).
         *
         * @param {(string|!Array<(string|number)>)} path Path to the value
         *   to write.  The path may be specified as a string (e.g. `'foo.bar.baz'`)
         *   or an array of path parts (e.g. `['foo.bar', 'baz']`).  Note that
         *   bracketed expressions are not supported; string-based path parts
         *   *must* be separated by dots.  Note that when dereferencing array
         *   indices, the index may be used as a dotted part directly
         *   (e.g. `'users.12.name'` or `['users', 12, 'name']`).
         * @param {*} value Value to set at the specified path.
         * @param {Object=} root Root object from which the path is evaluated.
         *   When specified, no notification will occur.
         * @public
        */

      }, {
        key: 'set',
        value: function set(path, value, root) {
          if (root) {
            Polymer.Path.set(root, path, value);
          } else {
            if (!this[TYPES.READ_ONLY] || !this[TYPES.READ_ONLY][/** @type {string} */path]) {
              if (this._setPendingPropertyOrPath(path, value, true)) {
                this._invalidateProperties();
              }
            }
          }
        }

        /**
         * Adds items onto the end of the array at the path specified.
         *
         * The arguments after `path` and return value match that of
         * `Array.prototype.push`.
         *
         * This method notifies other paths to the same array that a
         * splice occurred to the array.
         *
         * @param {string} path Path to array.
         * @param {...*} items Items to push onto array
         * @return {number} New length of the array.
         * @public
         */

      }, {
        key: 'push',
        value: function push(path) {
          var info = { path: '' };
          var array = /** @type {Array}*/Polymer.Path.get(this, path, info);
          var len = array.length;

          for (var _len = arguments.length, items = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            items[_key - 1] = arguments[_key];
          }

          var ret = array.push.apply(array, items);
          if (items.length) {
            notifySplice(this, array, info.path, len, items.length, []);
          }
          return ret;
        }

        /**
         * Removes an item from the end of array at the path specified.
         *
         * The arguments after `path` and return value match that of
         * `Array.prototype.pop`.
         *
         * This method notifies other paths to the same array that a
         * splice occurred to the array.
         *
         * @param {string} path Path to array.
         * @return {*} Item that was removed.
         * @public
         */

      }, {
        key: 'pop',
        value: function pop(path) {
          var info = { path: '' };
          var array = /** @type {Array} */Polymer.Path.get(this, path, info);
          var hadLength = Boolean(array.length);
          var ret = array.pop();
          if (hadLength) {
            notifySplice(this, array, info.path, array.length, 0, [ret]);
          }
          return ret;
        }

        /**
         * Starting from the start index specified, removes 0 or more items
         * from the array and inserts 0 or more new items in their place.
         *
         * The arguments after `path` and return value match that of
         * `Array.prototype.splice`.
         *
         * This method notifies other paths to the same array that a
         * splice occurred to the array.
         *
         * @param {string} path Path to array.
         * @param {number} start Index from which to start removing/inserting.
         * @param {number} deleteCount Number of items to remove.
         * @param {...*} items Items to insert into array.
         * @return {Array} Array of removed items.
         * @public
         */

      }, {
        key: 'splice',
        value: function splice(path, start, deleteCount) {
          var info = { path: '' };
          var array = /** @type {Array} */Polymer.Path.get(this, path, info);
          // Normalize fancy native splice handling of crazy start values
          if (start < 0) {
            start = array.length - Math.floor(-start);
          } else {
            start = Math.floor(start);
          }
          if (!start) {
            start = 0;
          }

          for (var _len2 = arguments.length, items = Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {
            items[_key2 - 3] = arguments[_key2];
          }

          var ret = array.splice.apply(array, [start, deleteCount].concat(items));
          if (items.length || ret.length) {
            notifySplice(this, array, info.path, start, items.length, ret);
          }
          return ret;
        }

        /**
         * Removes an item from the beginning of array at the path specified.
         *
         * The arguments after `path` and return value match that of
         * `Array.prototype.pop`.
         *
         * This method notifies other paths to the same array that a
         * splice occurred to the array.
         *
         * @param {string} path Path to array.
         * @return {*} Item that was removed.
         * @public
         */

      }, {
        key: 'shift',
        value: function shift(path) {
          var info = { path: '' };
          var array = /** @type {Array} */Polymer.Path.get(this, path, info);
          var hadLength = Boolean(array.length);
          var ret = array.shift();
          if (hadLength) {
            notifySplice(this, array, info.path, 0, 0, [ret]);
          }
          return ret;
        }

        /**
         * Adds items onto the beginning of the array at the path specified.
         *
         * The arguments after `path` and return value match that of
         * `Array.prototype.push`.
         *
         * This method notifies other paths to the same array that a
         * splice occurred to the array.
         *
         * @param {string} path Path to array.
         * @param {...*} items Items to insert info array
         * @return {number} New length of the array.
         * @public
         */

      }, {
        key: 'unshift',
        value: function unshift(path) {
          var info = { path: '' };
          var array = /** @type {Array} */Polymer.Path.get(this, path, info);

          for (var _len3 = arguments.length, items = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
            items[_key3 - 1] = arguments[_key3];
          }

          var ret = array.unshift.apply(array, items);
          if (items.length) {
            notifySplice(this, array, info.path, 0, items.length, []);
          }
          return ret;
        }

        /**
         * Notify that a path has changed.
         *
         * Example:
         *
         *     this.item.user.name = 'Bob';
         *     this.notifyPath('item.user.name');
         *
         * @param {string} path Path that should be notified.
         * @param {*=} value Value at the path (optional).
         * @public
        */

      }, {
        key: 'notifyPath',
        value: function notifyPath(path, value) {
          /** @type {string} */
          var propPath = void 0;
          if (arguments.length == 1) {
            // Get value if not supplied
            var info = { path: '' };
            value = Polymer.Path.get(this, path, info);
            propPath = info.path;
          } else if (Array.isArray(path)) {
            // Normalize path if needed
            propPath = Polymer.Path.normalize(path);
          } else {
            propPath = /** @type{string} */path;
          }
          if (this._setPendingPropertyOrPath(propPath, value, true, true)) {
            this._invalidateProperties();
          }
        }

        /**
         * Equivalent to static `createReadOnlyProperty` API but can be called on
         * an instance to add effects at runtime.  See that method for
         * full API docs.
         *
         * @param {string} property Property name
         * @param {boolean=} protectedSetter Creates a custom protected setter
         *   when `true`.
         * @protected
         */

      }, {
        key: '_createReadOnlyProperty',
        value: function _createReadOnlyProperty(property, protectedSetter) {
          this._addPropertyEffect(property, TYPES.READ_ONLY);
          if (protectedSetter) {
            this['_set' + upper(property)] = /** @this {PropertyEffects} */function (value) {
              this._setProperty(property, value);
            };
          }
        }

        /**
         * Equivalent to static `createPropertyObserver` API but can be called on
         * an instance to add effects at runtime.  See that method for
         * full API docs.
         *
         * @param {string} property Property name
         * @param {string} methodName Name of observer method to call
         * @param {boolean=} dynamicFn Whether the method name should be included as
         *   a dependency to the effect.
         * @protected
         */

      }, {
        key: '_createPropertyObserver',
        value: function _createPropertyObserver(property, methodName, dynamicFn) {
          var info = { property: property, methodName: methodName, dynamicFn: Boolean(dynamicFn) };
          this._addPropertyEffect(property, TYPES.OBSERVE, {
            fn: runObserverEffect, info: info, trigger: { name: property }
          });
          if (dynamicFn) {
            this._addPropertyEffect(methodName, TYPES.OBSERVE, {
              fn: runObserverEffect, info: info, trigger: { name: methodName }
            });
          }
        }

        /**
         * Equivalent to static `createMethodObserver` API but can be called on
         * an instance to add effects at runtime.  See that method for
         * full API docs.
         *
         * @param {string} expression Method expression
         * @param {boolean|Object=} dynamicFn Boolean or object map indicating
         *   whether method names should be included as a dependency to the effect.
         * @protected
         */

      }, {
        key: '_createMethodObserver',
        value: function _createMethodObserver(expression, dynamicFn) {
          var sig = parseMethod(expression);
          if (!sig) {
            throw new Error("Malformed observer expression '" + expression + "'");
          }
          createMethodEffect(this, sig, TYPES.OBSERVE, runMethodEffect, null, dynamicFn);
        }

        /**
         * Equivalent to static `createNotifyingProperty` API but can be called on
         * an instance to add effects at runtime.  See that method for
         * full API docs.
         *
         * @param {string} property Property name
         * @protected
         */

      }, {
        key: '_createNotifyingProperty',
        value: function _createNotifyingProperty(property) {
          this._addPropertyEffect(property, TYPES.NOTIFY, {
            fn: runNotifyEffect,
            info: {
              eventName: CaseMap.camelToDashCase(property) + '-changed',
              property: property
            }
          });
        }

        /**
         * Equivalent to static `createReflectedProperty` API but can be called on
         * an instance to add effects at runtime.  See that method for
         * full API docs.
         *
         * @param {string} property Property name
         * @protected
         */

      }, {
        key: '_createReflectedProperty',
        value: function _createReflectedProperty(property) {
          var attr = CaseMap.camelToDashCase(property);
          if (attr[0] === '-') {
            console.warn('Property ' + property + ' cannot be reflected to attribute ' + attr + ' because "-" is not a valid starting attribute name. Use a lowercase first letter for the property thisead.');
          } else {
            this._addPropertyEffect(property, TYPES.REFLECT, {
              fn: runReflectEffect,
              info: {
                attrName: attr
              }
            });
          }
        }

        /**
         * Equivalent to static `createComputedProperty` API but can be called on
         * an instance to add effects at runtime.  See that method for
         * full API docs.
         *
         * @param {string} property Name of computed property to set
         * @param {string} expression Method expression
         * @param {boolean|Object=} dynamicFn Boolean or object map indicating
         *   whether method names should be included as a dependency to the effect.
         * @protected
         */

      }, {
        key: '_createComputedProperty',
        value: function _createComputedProperty(property, expression, dynamicFn) {
          var sig = parseMethod(expression);
          if (!sig) {
            throw new Error("Malformed computed expression '" + expression + "'");
          }
          createMethodEffect(this, sig, TYPES.COMPUTE, runComputedEffect, property, dynamicFn);
        }

        // -- static class methods ------------

        /**
         * Ensures an accessor exists for the specified property, and adds
         * to a list of "property effects" that will run when the accessor for
         * the specified property is set.  Effects are grouped by "type", which
         * roughly corresponds to a phase in effect processing.  The effect
         * metadata should be in the following form:
         *
         *   {
         *     fn: effectFunction, // Reference to function to call to perform effect
         *     info: { ... }       // Effect metadata passed to function
         *     trigger: {          // Optional triggering metadata; if not provided
         *       name: string      // the property is treated as a wildcard
         *       structured: boolean
         *       wildcard: boolean
         *     }
         *   }
         *
         * Effects are called from `_propertiesChanged` in the following order by
         * type:
         *
         * 1. COMPUTE
         * 2. PROPAGATE
         * 3. REFLECT
         * 4. OBSERVE
         * 5. NOTIFY
         *
         * Effect functions are called with the following signature:
         *
         *   effectFunction(inst, path, props, oldProps, info, hasPaths)
         *
         * @param {string} property Property that should trigger the effect
         * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES
         * @param {Object=} effect Effect metadata object
         * @protected
         */

      }, {
        key: '_bindTemplate',


        // -- binding ----------------------------------------------

        /**
         * Equivalent to static `bindTemplate` API but can be called on
         * an instance to add effects at runtime.  See that method for
         * full API docs.
         *
         * This method may be called on the prototype (for prototypical template
         * binding, to avoid creating accessors every instance) once per prototype,
         * and will be called with `runtimeBinding: true` by `_stampTemplate` to
         * create and link an instance of the template metadata associated with a
         * particular stamping.
         *
         * @param {HTMLTemplateElement} template Template containing binding
         *   bindings
         * @param {boolean=} instanceBinding When false (default), performs
         *   "prototypical" binding of the template and overwrites any previously
         *   bound template for the class. When true (as passed from
         *   `_stampTemplate`), the template info is instanced and linked into
         *   the list of bound templates.
         * @return {!TemplateInfo} Template metadata object; for `runtimeBinding`,
         *   this is an instance of the prototypical template info
         * @protected
         */
        value: function _bindTemplate(template, instanceBinding) {
          var templateInfo = this.constructor._parseTemplate(template);
          var wasPreBound = this.__templateInfo == templateInfo;
          // Optimization: since this is called twice for proto-bound templates,
          // don't attempt to recreate accessors if this template was pre-bound
          if (!wasPreBound) {
            for (var prop in templateInfo.propertyEffects) {
              this._createPropertyAccessor(prop);
            }
          }
          if (instanceBinding) {
            // For instance-time binding, create instance of template metadata
            // and link into list of templates if necessary
            templateInfo = /** @type {!TemplateInfo} */Object.create(templateInfo);
            templateInfo.wasPreBound = wasPreBound;
            if (!wasPreBound && this.__templateInfo) {
              var last = this.__templateInfoLast || this.__templateInfo;
              this.__templateInfoLast = last.nextTemplateInfo = templateInfo;
              templateInfo.previousTemplateInfo = last;
              return templateInfo;
            }
          }
          return this.__templateInfo = templateInfo;
        }

        /**
         * Adds a property effect to the given template metadata, which is run
         * at the "propagate" stage of `_propertiesChanged` when the template
         * has been bound to the element via `_bindTemplate`.
         *
         * The `effect` object should match the format in `_addPropertyEffect`.
         *
         * @param {Object} templateInfo Template metadata to add effect to
         * @param {string} prop Property that should trigger the effect
         * @param {Object=} effect Effect metadata object
         * @protected
         */

      }, {
        key: '_stampTemplate',


        /**
         * Stamps the provided template and performs instance-time setup for
         * Polymer template features, including data bindings, declarative event
         * listeners, and the `this.$` map of `id`'s to nodes.  A document fragment
         * is returned containing the stamped DOM, ready for insertion into the
         * DOM.
         *
         * This method may be called more than once; however note that due to
         * `shadycss` polyfill limitations, only styles from templates prepared
         * using `ShadyCSS.prepareTemplate` will be correctly polyfilled (scoped
         * to the shadow root and support CSS custom properties), and note that
         * `ShadyCSS.prepareTemplate` may only be called once per element. As such,
         * any styles required by in runtime-stamped templates must be included
         * in the main element template.
         *
         * @param {!HTMLTemplateElement} template Template to stamp
         * @return {!StampedTemplate} Cloned template content
         * @override
         * @protected
         */
        value: function _stampTemplate(template) {
          // Ensures that created dom is `_enqueueClient`'d to this element so
          // that it can be flushed on next call to `_flushProperties`
          hostStack.beginHosting(this);
          var dom = _get(PropertyEffects.prototype.__proto__ || Object.getPrototypeOf(PropertyEffects.prototype), '_stampTemplate', this).call(this, template);
          hostStack.endHosting(this);
          var templateInfo = /** @type {!TemplateInfo} */this._bindTemplate(template, true);
          // Add template-instance-specific data to instanced templateInfo
          templateInfo.nodeList = dom.nodeList;
          // Capture child nodes to allow unstamping of non-prototypical templates
          if (!templateInfo.wasPreBound) {
            var nodes = templateInfo.childNodes = [];
            for (var n = dom.firstChild; n; n = n.nextSibling) {
              nodes.push(n);
            }
          }
          dom.templateInfo = templateInfo;
          // Setup compound storage, 2-way listeners, and dataHost for bindings
          setupBindings(this, templateInfo);
          // Flush properties into template nodes if already booted
          if (this.__dataReady) {
            runEffects(this, templateInfo.propertyEffects, this.__data, null, false, templateInfo.nodeList);
          }
          return dom;
        }

        /**
         * Removes and unbinds the nodes previously contained in the provided
         * DocumentFragment returned from `_stampTemplate`.
         *
         * @param {!StampedTemplate} dom DocumentFragment previously returned
         *   from `_stampTemplate` associated with the nodes to be removed
         * @protected
         */

      }, {
        key: '_removeBoundDom',
        value: function _removeBoundDom(dom) {
          // Unlink template info
          var templateInfo = dom.templateInfo;
          if (templateInfo.previousTemplateInfo) {
            templateInfo.previousTemplateInfo.nextTemplateInfo = templateInfo.nextTemplateInfo;
          }
          if (templateInfo.nextTemplateInfo) {
            templateInfo.nextTemplateInfo.previousTemplateInfo = templateInfo.previousTemplateInfo;
          }
          if (this.__templateInfoLast == templateInfo) {
            this.__templateInfoLast = templateInfo.previousTemplateInfo;
          }
          templateInfo.previousTemplateInfo = templateInfo.nextTemplateInfo = null;
          // Remove stamped nodes
          var nodes = templateInfo.childNodes;
          for (var i = 0; i < nodes.length; i++) {
            var node = nodes[i];
            node.parentNode.removeChild(node);
          }
        }

        /**
         * Overrides default `TemplateStamp` implementation to add support for
         * parsing bindings from `TextNode`'s' `textContent`.  A `bindings`
         * array is added to `nodeInfo` and populated with binding metadata
         * with information capturing the binding target, and a `parts` array
         * with one or more metadata objects capturing the source(s) of the
         * binding.
         *
         * @override
         * @param {Node} node Node to parse
         * @param {TemplateInfo} templateInfo Template metadata for current template
         * @param {NodeInfo} nodeInfo Node metadata for current template node
         * @return {boolean} `true` if the visited node added node-specific
         *   metadata to `nodeInfo`
         * @protected
         * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
         */

      }, {
        key: 'PROPERTY_EFFECT_TYPES',
        get: function get() {
          return TYPES;
        }
      }], [{
        key: 'addPropertyEffect',
        value: function addPropertyEffect(property, type, effect) {
          this.prototype._addPropertyEffect(property, type, effect);
        }

        /**
         * Creates a single-property observer for the given property.
         *
         * @param {string} property Property name
         * @param {string} methodName Name of observer method to call
         * @param {boolean=} dynamicFn Whether the method name should be included as
         *   a dependency to the effect.
         * @protected
         */

      }, {
        key: 'createPropertyObserver',
        value: function createPropertyObserver(property, methodName, dynamicFn) {
          this.prototype._createPropertyObserver(property, methodName, dynamicFn);
        }

        /**
         * Creates a multi-property "method observer" based on the provided
         * expression, which should be a string in the form of a normal Javascript
         * function signature: `'methodName(arg1, [..., argn])'`.  Each argument
         * should correspond to a property or path in the context of this
         * prototype (or instance), or may be a literal string or number.
         *
         * @param {string} expression Method expression
         * @param {boolean|Object=} dynamicFn Boolean or object map indicating
         *   whether method names should be included as a dependency to the effect.
         * @protected
         */

      }, {
        key: 'createMethodObserver',
        value: function createMethodObserver(expression, dynamicFn) {
          this.prototype._createMethodObserver(expression, dynamicFn);
        }

        /**
         * Causes the setter for the given property to dispatch `<property>-changed`
         * events to notify of changes to the property.
         *
         * @param {string} property Property name
         * @protected
         */

      }, {
        key: 'createNotifyingProperty',
        value: function createNotifyingProperty(property) {
          this.prototype._createNotifyingProperty(property);
        }

        /**
         * Creates a read-only accessor for the given property.
         *
         * To set the property, use the protected `_setProperty` API.
         * To create a custom protected setter (e.g. `_setMyProp()` for
         * property `myProp`), pass `true` for `protectedSetter`.
         *
         * Note, if the property will have other property effects, this method
         * should be called first, before adding other effects.
         *
         * @param {string} property Property name
         * @param {boolean=} protectedSetter Creates a custom protected setter
         *   when `true`.
         * @protected
         */

      }, {
        key: 'createReadOnlyProperty',
        value: function createReadOnlyProperty(property, protectedSetter) {
          this.prototype._createReadOnlyProperty(property, protectedSetter);
        }

        /**
         * Causes the setter for the given property to reflect the property value
         * to a (dash-cased) attribute of the same name.
         *
         * @param {string} property Property name
         * @protected
         */

      }, {
        key: 'createReflectedProperty',
        value: function createReflectedProperty(property) {
          this.prototype._createReflectedProperty(property);
        }

        /**
         * Creates a computed property whose value is set to the result of the
         * method described by the given `expression` each time one or more
         * arguments to the method changes.  The expression should be a string
         * in the form of a normal Javascript function signature:
         * `'methodName(arg1, [..., argn])'`
         *
         * @param {string} property Name of computed property to set
         * @param {string} expression Method expression
         * @param {boolean|Object=} dynamicFn Boolean or object map indicating whether
         *   method names should be included as a dependency to the effect.
         * @protected
         */

      }, {
        key: 'createComputedProperty',
        value: function createComputedProperty(property, expression, dynamicFn) {
          this.prototype._createComputedProperty(property, expression, dynamicFn);
        }

        /**
         * Parses the provided template to ensure binding effects are created
         * for them, and then ensures property accessors are created for any
         * dependent properties in the template.  Binding effects for bound
         * templates are stored in a linked list on the instance so that
         * templates can be efficiently stamped and unstamped.
         *
         * @param {HTMLTemplateElement} template Template containing binding
         *   bindings
         * @return {Object} Template metadata object
         * @protected
         */

      }, {
        key: 'bindTemplate',
        value: function bindTemplate(template) {
          return this.prototype._bindTemplate(template);
        }
      }, {
        key: '_addTemplatePropertyEffect',
        value: function _addTemplatePropertyEffect(templateInfo, prop, effect) {
          var hostProps = templateInfo.hostProps = templateInfo.hostProps || {};
          hostProps[prop] = true;
          var effects = templateInfo.propertyEffects = templateInfo.propertyEffects || {};
          var propEffects = effects[prop] = effects[prop] || [];
          propEffects.push(effect);
        }
      }, {
        key: '_parseTemplateNode',
        value: function _parseTemplateNode(node, templateInfo, nodeInfo) {
          var noted = _get(PropertyEffects.__proto__ || Object.getPrototypeOf(PropertyEffects), '_parseTemplateNode', this).call(this, node, templateInfo, nodeInfo);
          if (node.nodeType === Node.TEXT_NODE) {
            var parts = this._parseBindings(node.textContent, templateInfo);
            if (parts) {
              // Initialize the textContent with any literal parts
              // NOTE: default to a space here so the textNode remains; some browsers
              // (IE) evacipate an empty textNode following cloneNode/importNode.
              node.textContent = literalFromParts(parts) || ' ';
              addBinding(this, templateInfo, nodeInfo, 'text', 'textContent', parts);
              noted = true;
            }
          }
          return noted;
        }

        /**
         * Overrides default `TemplateStamp` implementation to add support for
         * parsing bindings from attributes.  A `bindings`
         * array is added to `nodeInfo` and populated with binding metadata
         * with information capturing the binding target, and a `parts` array
         * with one or more metadata objects capturing the source(s) of the
         * binding.
         *
         * @override
         * @param {Element} node Node to parse
         * @param {TemplateInfo} templateInfo Template metadata for current template
         * @param {NodeInfo} nodeInfo Node metadata for current template node
         * @return {boolean} `true` if the visited node added node-specific
         *   metadata to `nodeInfo`
         * @protected
         * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
         */

      }, {
        key: '_parseTemplateNodeAttribute',
        value: function _parseTemplateNodeAttribute(node, templateInfo, nodeInfo, name, value) {
          var parts = this._parseBindings(value, templateInfo);
          if (parts) {
            // Attribute or property
            var origName = name;
            var kind = 'property';
            if (name[name.length - 1] == '$') {
              name = name.slice(0, -1);
              kind = 'attribute';
            }
            // Initialize attribute bindings with any literal parts
            var literal = literalFromParts(parts);
            if (literal && kind == 'attribute') {
              node.setAttribute(name, literal);
            }
            // Clear attribute before removing, since IE won't allow removing
            // `value` attribute if it previously had a value (can't
            // unconditionally set '' before removing since attributes with `$`
            // can't be set using setAttribute)
            if (node.localName === 'input' && origName === 'value') {
              node.setAttribute(origName, '');
            }
            // Remove annotation
            node.removeAttribute(origName);
            // Case hackery: attributes are lower-case, but bind targets
            // (properties) are case sensitive. Gambit is to map dash-case to
            // camel-case: `foo-bar` becomes `fooBar`.
            // Attribute bindings are excepted.
            if (kind === 'property') {
              name = Polymer.CaseMap.dashToCamelCase(name);
            }
            addBinding(this, templateInfo, nodeInfo, kind, name, parts, literal);
            return true;
          } else {
            return _get(PropertyEffects.__proto__ || Object.getPrototypeOf(PropertyEffects), '_parseTemplateNodeAttribute', this).call(this, node, templateInfo, nodeInfo, name, value);
          }
        }

        /**
         * Overrides default `TemplateStamp` implementation to add support for
         * binding the properties that a nested template depends on to the template
         * as `_host_<property>`.
         *
         * @override
         * @param {Node} node Node to parse
         * @param {TemplateInfo} templateInfo Template metadata for current template
         * @param {NodeInfo} nodeInfo Node metadata for current template node
         * @return {boolean} `true` if the visited node added node-specific
         *   metadata to `nodeInfo`
         * @protected
         * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
         */

      }, {
        key: '_parseTemplateNestedTemplate',
        value: function _parseTemplateNestedTemplate(node, templateInfo, nodeInfo) {
          var noted = _get(PropertyEffects.__proto__ || Object.getPrototypeOf(PropertyEffects), '_parseTemplateNestedTemplate', this).call(this, node, templateInfo, nodeInfo);
          // Merge host props into outer template and add bindings
          var hostProps = nodeInfo.templateInfo.hostProps;
          var mode = '{';
          for (var source in hostProps) {
            var parts = [{ mode: mode, source: source, dependencies: [source] }];
            addBinding(this, templateInfo, nodeInfo, 'property', '_host_' + source, parts);
          }
          return noted;
        }

        /**
         * Called to parse text in a template (either attribute values or
         * textContent) into binding metadata.
         *
         * Any overrides of this method should return an array of binding part
         * metadata  representing one or more bindings found in the provided text
         * and any "literal" text in between.  Any non-literal parts will be passed
         * to `_evaluateBinding` when any dependencies change.  The only required
         * fields of each "part" in the returned array are as follows:
         *
         * - `dependencies` - Array containing trigger metadata for each property
         *   that should trigger the binding to update
         * - `literal` - String containing text if the part represents a literal;
         *   in this case no `dependencies` are needed
         *
         * Additional metadata for use by `_evaluateBinding` may be provided in
         * each part object as needed.
         *
         * The default implementation handles the following types of bindings
         * (one or more may be intermixed with literal strings):
         * - Property binding: `[[prop]]`
         * - Path binding: `[[object.prop]]`
         * - Negated property or path bindings: `[[!prop]]` or `[[!object.prop]]`
         * - Two-way property or path bindings (supports negation):
         *   `{{prop}}`, `{{object.prop}}`, `{{!prop}}` or `{{!object.prop}}`
         * - Inline computed method (supports negation):
         *   `[[compute(a, 'literal', b)]]`, `[[!compute(a, 'literal', b)]]`
         *
         * @param {string} text Text to parse from attribute or textContent
         * @param {Object} templateInfo Current template metadata
         * @return {Array<!BindingPart>} Array of binding part metadata
         * @protected
         */

      }, {
        key: '_parseBindings',
        value: function _parseBindings(text, templateInfo) {
          var parts = [];
          var lastIndex = 0;
          var m = void 0;
          // Example: "literal1{{prop}}literal2[[!compute(foo,bar)]]final"
          // Regex matches:
          //        Iteration 1:  Iteration 2:
          // m[1]: '{{'          '[['
          // m[2]: ''            '!'
          // m[3]: 'prop'        'compute(foo,bar)'
          while ((m = bindingRegex.exec(text)) !== null) {
            // Add literal part
            if (m.index > lastIndex) {
              parts.push({ literal: text.slice(lastIndex, m.index) });
            }
            // Add binding part
            var mode = m[1][0];
            var negate = Boolean(m[2]);
            var source = m[3].trim();
            var customEvent = false,
                notifyEvent = '',
                colon = -1;
            if (mode == '{' && (colon = source.indexOf('::')) > 0) {
              notifyEvent = source.substring(colon + 2);
              source = source.substring(0, colon);
              customEvent = true;
            }
            var signature = parseMethod(source);
            var dependencies = [];
            if (signature) {
              // Inline computed function
              var args = signature.args,
                  methodName = signature.methodName;

              for (var i = 0; i < args.length; i++) {
                var arg = args[i];
                if (!arg.literal) {
                  dependencies.push(arg);
                }
              }
              var dynamicFns = templateInfo.dynamicFns;
              if (dynamicFns && dynamicFns[methodName] || signature.static) {
                dependencies.push(methodName);
                signature.dynamicFn = true;
              }
            } else {
              // Property or path
              dependencies.push(source);
            }
            parts.push({
              source: source, mode: mode, negate: negate, customEvent: customEvent, signature: signature, dependencies: dependencies,
              event: notifyEvent
            });
            lastIndex = bindingRegex.lastIndex;
          }
          // Add a final literal part
          if (lastIndex && lastIndex < text.length) {
            var literal = text.substring(lastIndex);
            if (literal) {
              parts.push({
                literal: literal
              });
            }
          }
          if (parts.length) {
            return parts;
          } else {
            return null;
          }
        }

        /**
         * Called to evaluate a previously parsed binding part based on a set of
         * one or more changed dependencies.
         *
         * @param {this} inst Element that should be used as scope for
         *   binding dependencies
         * @param {BindingPart} part Binding part metadata
         * @param {string} path Property/path that triggered this effect
         * @param {Object} props Bag of current property changes
         * @param {Object} oldProps Bag of previous values for changed properties
         * @param {boolean} hasPaths True with `props` contains one or more paths
         * @return {*} Value the binding part evaluated to
         * @protected
         */

      }, {
        key: '_evaluateBinding',
        value: function _evaluateBinding(inst, part, path, props, oldProps, hasPaths) {
          var value = void 0;
          if (part.signature) {
            value = runMethodEffect(inst, path, props, oldProps, part.signature);
          } else if (path != part.source) {
            value = Polymer.Path.get(inst, part.source);
          } else {
            if (hasPaths && Polymer.Path.isPath(path)) {
              value = Polymer.Path.get(inst, path);
            } else {
              value = inst.__data[path];
            }
          }
          if (part.negate) {
            value = !value;
          }
          return value;
        }
      }]);

      return PropertyEffects;
    }(propertyEffectsBase);

    // make a typing for closure :P


    PropertyEffectsType = PropertyEffects;

    return PropertyEffects;
  });

  /**
   * Helper api for enqueing client dom created by a host element.
   *
   * By default elements are flushed via `_flushProperties` when
   * `connectedCallback` is called. Elements attach their client dom to
   * themselves at `ready` time which results from this first flush.
   * This provides an ordering guarantee that the client dom an element
   * creates is flushed before the element itself (i.e. client `ready`
   * fires before host `ready`).
   *
   * However, if `_flushProperties` is called *before* an element is connected,
   * as for example `Templatize` does, this ordering guarantee cannot be
   * satisfied because no elements are connected. (Note: Bound elements that
   * receive data do become enqueued clients and are properly ordered but
   * unbound elements are not.)
   *
   * To maintain the desired "client before host" ordering guarantee for this
   * case we rely on the "host stack. Client nodes registers themselves with
   * the creating host element when created. This ensures that all client dom
   * is readied in the proper order, maintaining the desired guarantee.
   *
   * @private
   */
  var hostStack = {

    stack: [],

    /**
     * @param {*} inst Instance to add to hostStack
     * @this {hostStack}
     */
    registerHost: function registerHost(inst) {
      if (this.stack.length) {
        var host = this.stack[this.stack.length - 1];
        host._enqueueClient(inst);
      }
    },


    /**
     * @param {*} inst Instance to begin hosting
     * @this {hostStack}
     */
    beginHosting: function beginHosting(inst) {
      this.stack.push(inst);
    },


    /**
     * @param {*} inst Instance to end hosting
     * @this {hostStack}
     */
    endHosting: function endHosting(inst) {
      var stackLen = this.stack.length;
      if (stackLen && this.stack[stackLen - 1] == inst) {
        this.stack.pop();
      }
    }
  };
})();

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

__webpack_require__(1);

__webpack_require__(3);

__webpack_require__(8);

(function () {
  'use strict';

  /** @typedef {{run: function(function(), number=):number, cancel: function(number)}} */

  var AsyncModule = void 0; // eslint-disable-line no-unused-vars

  /**
   * @summary Collapse multiple callbacks into one invocation after a timer.
   * @memberof Polymer
   */

  var Debouncer = function () {
    function Debouncer() {
      _classCallCheck(this, Debouncer);

      this._asyncModule = null;
      this._callback = null;
      this._timer = null;
    }
    /**
     * Sets the scheduler; that is, a module with the Async interface,
     * a callback and optional arguments to be passed to the run function
     * from the async module.
     *
     * @param {!AsyncModule} asyncModule Object with Async interface.
     * @param {function()} callback Callback to run.
     */


    _createClass(Debouncer, [{
      key: 'setConfig',
      value: function setConfig(asyncModule, callback) {
        var _this = this;

        this._asyncModule = asyncModule;
        this._callback = callback;
        this._timer = this._asyncModule.run(function () {
          _this._timer = null;
          _this._callback();
        });
      }
      /**
       * Cancels an active debouncer and returns a reference to itself.
       */

    }, {
      key: 'cancel',
      value: function cancel() {
        if (this.isActive()) {
          this._asyncModule.cancel(this._timer);
          this._timer = null;
        }
      }
      /**
       * Flushes an active debouncer and returns a reference to itself.
       */

    }, {
      key: 'flush',
      value: function flush() {
        if (this.isActive()) {
          this.cancel();
          this._callback();
        }
      }
      /**
       * Returns true if the debouncer is active.
       *
       * @return {boolean} True if active.
       */

    }, {
      key: 'isActive',
      value: function isActive() {
        return this._timer != null;
      }
      /**
       * Creates a debouncer if no debouncer is passed as a parameter
       * or it cancels an active debouncer otherwise. The following
       * example shows how a debouncer can be called multiple times within a
       * microtask and "debounced" such that the provided callback function is
       * called once. Add this method to a custom element:
       *
       * _debounceWork() {
       *   this._debounceJob = Polymer.Debouncer.debounce(this._debounceJob,
       *       Polymer.Async.microTask, () => {
       *     this._doWork();
       *   });
       * }
       *
       * If the `_debounceWork` method is called multiple times within the same
       * microtask, the `_doWork` function will be called only once at the next
       * microtask checkpoint.
       *
       * Note: In testing it is often convenient to avoid asynchrony. To accomplish
       * this with a debouncer, you can use `Polymer.enqueueDebouncer` and
       * `Polymer.flush`. For example, extend the above example by adding
       * `Polymer.enqueueDebouncer(this._debounceJob)` at the end of the
       * `_debounceWork` method. Then in a test, call `Polymer.flush` to ensure
       * the debouncer has completed.
       *
       * @param {Debouncer?} debouncer Debouncer object.
       * @param {!AsyncModule} asyncModule Object with Async interface
       * @param {function()} callback Callback to run.
       * @return {!Debouncer} Returns a debouncer object.
       */

    }], [{
      key: 'debounce',
      value: function debounce(debouncer, asyncModule, callback) {
        if (debouncer instanceof Debouncer) {
          debouncer.cancel();
        } else {
          debouncer = new Debouncer();
        }
        debouncer.setConfig(asyncModule, callback);
        return debouncer;
      }
    }]);

    return Debouncer;
  }();

  Polymer.Debouncer = Debouncer;
})();

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(1);

(function () {
  'use strict';

  var debouncerQueue = [];

  /**
   * Adds a `Polymer.Debouncer` to a list of globally flushable tasks.
   *
   * @memberof Polymer
   * @param {Polymer.Debouncer} debouncer Debouncer to enqueue
   */
  Polymer.enqueueDebouncer = function (debouncer) {
    debouncerQueue.push(debouncer);
  };

  function flushDebouncers() {
    var didFlush = Boolean(debouncerQueue.length);
    while (debouncerQueue.length) {
      try {
        debouncerQueue.shift().flush();
      } catch (e) {
        setTimeout(function () {
          throw e;
        });
      }
    }
    return didFlush;
  }

  /**
   * Forces several classes of asynchronously queued tasks to flush:
   * - Debouncers added via `enqueueDebouncer`
   * - ShadyDOM distribution
   *
   * @memberof Polymer
   */
  Polymer.flush = function () {
    var shadyDOM = void 0,
        debouncers = void 0;
    do {
      shadyDOM = window.ShadyDOM && ShadyDOM.flush();
      if (window.ShadyCSS && window.ShadyCSS.ScopingShim) {
        window.ShadyCSS.ScopingShim.flush();
      }
      debouncers = flushDebouncers();
    } while (shadyDOM || debouncers);
  };
})();

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

__webpack_require__(1);

__webpack_require__(11);

__webpack_require__(9);

(function () {
  'use strict';

  // Base class for HTMLTemplateElement extension that has property effects
  // machinery for propagating host properties to children. This is an ES5
  // class only because Babel (incorrectly) requires super() in the class
  // constructor even though no `this` is used and it returns an instance.

  var newInstance = null;
  /**
   * @constructor
   * @extends {HTMLTemplateElement}
   */
  function HTMLTemplateElementExtension() {
    return newInstance;
  }
  HTMLTemplateElementExtension.prototype = Object.create(HTMLTemplateElement.prototype, {
    constructor: {
      value: HTMLTemplateElementExtension,
      writable: true
    }
  });
  /**
   * @constructor
   * @implements {Polymer_PropertyEffects}
   * @extends {HTMLTemplateElementExtension}
   */
  var DataTemplate = Polymer.PropertyEffects(HTMLTemplateElementExtension);
  /**
   * @constructor
   * @implements {Polymer_MutableData}
   * @extends {DataTemplate}
   */
  var MutableDataTemplate = Polymer.MutableData(DataTemplate);

  // Applies a DataTemplate subclass to a <template> instance
  function upgradeTemplate(template, constructor) {
    newInstance = template;
    Object.setPrototypeOf(template, constructor.prototype);
    new constructor();
    newInstance = null;
  }

  // Base class for TemplateInstance's
  /**
   * @constructor
   * @implements {Polymer_PropertyEffects}
   */
  var base = Polymer.PropertyEffects(function () {
    function _class() {
      _classCallCheck(this, _class);
    }

    return _class;
  }());

  /**
   * @polymer
   * @customElement
   * @appliesMixin Polymer.PropertyEffects
   * @unrestricted
   */

  var TemplateInstanceBase = function (_base) {
    _inherits(TemplateInstanceBase, _base);

    function TemplateInstanceBase(props) {
      _classCallCheck(this, TemplateInstanceBase);

      var _this = _possibleConstructorReturn(this, (TemplateInstanceBase.__proto__ || Object.getPrototypeOf(TemplateInstanceBase)).call(this));

      _this._configureProperties(props);
      _this.root = _this._stampTemplate(_this.__dataHost);
      // Save list of stamped children
      var children = _this.children = [];
      for (var n = _this.root.firstChild; n; n = n.nextSibling) {
        children.push(n);
        n.__templatizeInstance = _this;
      }
      if (_this.__templatizeOwner.__hideTemplateChildren__) {
        _this._showHideChildren(true);
      }
      // Flush props only when props are passed if instance props exist
      // or when there isn't instance props.
      var options = _this.__templatizeOptions;
      if (props && options.instanceProps || !options.instanceProps) {
        _this._enableProperties();
      }
      return _this;
    }
    /**
     * Configure the given `props` by calling `_setPendingProperty`. Also
     * sets any properties stored in `__hostProps`.
     * @private
     * @param {Object} props Object of property name-value pairs to set.
     */


    _createClass(TemplateInstanceBase, [{
      key: '_configureProperties',
      value: function _configureProperties(props) {
        var options = this.__templatizeOptions;
        if (props) {
          for (var iprop in options.instanceProps) {
            if (iprop in props) {
              this._setPendingProperty(iprop, props[iprop]);
            }
          }
        }
        for (var hprop in this.__hostProps) {
          this._setPendingProperty(hprop, this.__dataHost['_host_' + hprop]);
        }
      }
      /**
       * Forwards a host property to this instance.  This method should be
       * called on instances from the `options.forwardHostProp` callback
       * to propagate changes of host properties to each instance.
       *
       * Note this method enqueues the change, which are flushed as a batch.
       *
       * @param {string} prop Property or path name
       * @param {*} value Value of the property to forward
       */

    }, {
      key: 'forwardHostProp',
      value: function forwardHostProp(prop, value) {
        if (this._setPendingPropertyOrPath(prop, value, false, true)) {
          this.__dataHost._enqueueClient(this);
        }
      }
      /**
       * @override
       */

    }, {
      key: '_addEventListenerToNode',
      value: function _addEventListenerToNode(node, eventName, handler) {
        var _this2 = this;

        if (this._methodHost && this.__templatizeOptions.parentModel) {
          // If this instance should be considered a parent model, decorate
          // events this template instance as `model`
          this._methodHost._addEventListenerToNode(node, eventName, function (e) {
            e.model = _this2;
            handler(e);
          });
        } else {
          // Otherwise delegate to the template's host (which could be)
          // another template instance
          var templateHost = this.__dataHost.__dataHost;
          if (templateHost) {
            templateHost._addEventListenerToNode(node, eventName, handler);
          }
        }
      }
      /**
       * Shows or hides the template instance top level child elements. For
       * text nodes, `textContent` is removed while "hidden" and replaced when
       * "shown."
       * @param {boolean} hide Set to true to hide the children;
       * set to false to show them.
       * @protected
       */

    }, {
      key: '_showHideChildren',
      value: function _showHideChildren(hide) {
        var c = this.children;
        for (var i = 0; i < c.length; i++) {
          var n = c[i];
          // Ignore non-changes
          if (Boolean(hide) != Boolean(n.__hideTemplateChildren__)) {
            if (n.nodeType === Node.TEXT_NODE) {
              if (hide) {
                n.__polymerTextContent__ = n.textContent;
                n.textContent = '';
              } else {
                n.textContent = n.__polymerTextContent__;
              }
            } else if (n.style) {
              if (hide) {
                n.__polymerDisplay__ = n.style.display;
                n.style.display = 'none';
              } else {
                n.style.display = n.__polymerDisplay__;
              }
            }
          }
          n.__hideTemplateChildren__ = hide;
          if (n._showHideChildren) {
            n._showHideChildren(hide);
          }
        }
      }
      /**
       * Overrides default property-effects implementation to intercept
       * textContent bindings while children are "hidden" and cache in
       * private storage for later retrieval.
       *
       * @override
       */

    }, {
      key: '_setUnmanagedPropertyToNode',
      value: function _setUnmanagedPropertyToNode(node, prop, value) {
        if (node.__hideTemplateChildren__ && node.nodeType == Node.TEXT_NODE && prop == 'textContent') {
          node.__polymerTextContent__ = value;
        } else {
          _get(TemplateInstanceBase.prototype.__proto__ || Object.getPrototypeOf(TemplateInstanceBase.prototype), '_setUnmanagedPropertyToNode', this).call(this, node, prop, value);
        }
      }
      /**
       * Find the parent model of this template instance.  The parent model
       * is either another templatize instance that had option `parentModel: true`,
       * or else the host element.
       *
       * @return {Polymer_PropertyEffects} The parent model of this instance
       */

    }, {
      key: 'parentModel',
      get: function get() {
        var model = this.__parentModel;
        if (!model) {
          var options = void 0;
          model = this;
          do {
            // A template instance's `__dataHost` is a <template>
            // `model.__dataHost.__dataHost` is the template's host
            model = model.__dataHost.__dataHost;
          } while ((options = model.__templatizeOptions) && !options.parentModel);
          this.__parentModel = model;
        }
        return model;
      }
    }]);

    return TemplateInstanceBase;
  }(base);

  /** @type {!DataTemplate} */


  TemplateInstanceBase.prototype.__dataHost;
  /** @type {!TemplatizeOptions} */
  TemplateInstanceBase.prototype.__templatizeOptions;
  /** @type {!Polymer_PropertyEffects} */
  TemplateInstanceBase.prototype._methodHost;
  /** @type {!Object} */
  TemplateInstanceBase.prototype.__templatizeOwner;
  /** @type {!Object} */
  TemplateInstanceBase.prototype.__hostProps;

  /**
   * @constructor
   * @extends {TemplateInstanceBase}
   * @implements {Polymer_MutableData}
   */
  var MutableTemplateInstanceBase = Polymer.MutableData(TemplateInstanceBase);

  function findMethodHost(template) {
    // Technically this should be the owner of the outermost template.
    // In shadow dom, this is always getRootNode().host, but we can
    // approximate this via cooperation with our dataHost always setting
    // `_methodHost` as long as there were bindings (or id's) on this
    // instance causing it to get a dataHost.
    var templateHost = template.__dataHost;
    return templateHost && templateHost._methodHost || templateHost;
  }

  /* eslint-disable valid-jsdoc */
  /**
   * @suppress {missingProperties} class.prototype is not defined for some reason
   */
  function createTemplatizerClass(template, templateInfo, options) {
    // Anonymous class created by the templatize
    var base = options.mutableData ? MutableTemplateInstanceBase : TemplateInstanceBase;
    /**
     * @constructor
     * @extends {base}
     */
    var klass = function (_base2) {
      _inherits(klass, _base2);

      function klass() {
        _classCallCheck(this, klass);

        return _possibleConstructorReturn(this, (klass.__proto__ || Object.getPrototypeOf(klass)).apply(this, arguments));
      }

      return klass;
    }(base);
    klass.prototype.__templatizeOptions = options;
    klass.prototype._bindTemplate(template);
    addNotifyEffects(klass, template, templateInfo, options);
    return klass;
  }

  /**
   * @suppress {missingProperties} class.prototype is not defined for some reason
   */
  function addPropagateEffects(template, templateInfo, options) {
    var userForwardHostProp = options.forwardHostProp;
    if (userForwardHostProp) {
      // Provide data API and property effects on memoized template class
      var klass = templateInfo.templatizeTemplateClass;
      if (!klass) {
        var _base3 = options.mutableData ? MutableDataTemplate : DataTemplate;
        klass = templateInfo.templatizeTemplateClass = function (_base4) {
          _inherits(TemplatizedTemplate, _base4);

          function TemplatizedTemplate() {
            _classCallCheck(this, TemplatizedTemplate);

            return _possibleConstructorReturn(this, (TemplatizedTemplate.__proto__ || Object.getPrototypeOf(TemplatizedTemplate)).apply(this, arguments));
          }

          return TemplatizedTemplate;
        }(_base3);
        // Add template - >instances effects
        // and host <- template effects
        var hostProps = templateInfo.hostProps;
        for (var prop in hostProps) {
          klass.prototype._addPropertyEffect('_host_' + prop, klass.prototype.PROPERTY_EFFECT_TYPES.PROPAGATE, { fn: createForwardHostPropEffect(prop, userForwardHostProp) });
          klass.prototype._createNotifyingProperty('_host_' + prop);
        }
      }
      upgradeTemplate(template, klass);
      // Mix any pre-bound data into __data; no need to flush this to
      // instances since they pull from the template at instance-time
      if (template.__dataProto) {
        // Note, generally `__dataProto` could be chained, but it's guaranteed
        // to not be since this is a vanilla template we just added effects to
        Object.assign(template.__data, template.__dataProto);
      }
      // Clear any pending data for performance
      template.__dataTemp = {};
      template.__dataPending = null;
      template.__dataOld = null;
      template._enableProperties();
    }
  }
  /* eslint-enable valid-jsdoc */

  function createForwardHostPropEffect(hostProp, userForwardHostProp) {
    return function forwardHostProp(template, prop, props) {
      userForwardHostProp.call(template.__templatizeOwner, prop.substring('_host_'.length), props[prop]);
    };
  }

  function addNotifyEffects(klass, template, templateInfo, options) {
    var hostProps = templateInfo.hostProps || {};
    for (var iprop in options.instanceProps) {
      delete hostProps[iprop];
      var userNotifyInstanceProp = options.notifyInstanceProp;
      if (userNotifyInstanceProp) {
        klass.prototype._addPropertyEffect(iprop, klass.prototype.PROPERTY_EFFECT_TYPES.NOTIFY, { fn: createNotifyInstancePropEffect(iprop, userNotifyInstanceProp) });
      }
    }
    if (options.forwardHostProp && template.__dataHost) {
      for (var hprop in hostProps) {
        klass.prototype._addPropertyEffect(hprop, klass.prototype.PROPERTY_EFFECT_TYPES.NOTIFY, { fn: createNotifyHostPropEffect() });
      }
    }
  }

  function createNotifyInstancePropEffect(instProp, userNotifyInstanceProp) {
    return function notifyInstanceProp(inst, prop, props) {
      userNotifyInstanceProp.call(inst.__templatizeOwner, inst, prop, props[prop]);
    };
  }

  function createNotifyHostPropEffect() {
    return function notifyHostProp(inst, prop, props) {
      inst.__dataHost._setPendingPropertyOrPath('_host_' + prop, props[prop], true, true);
    };
  }

  /**
   * Module for preparing and stamping instances of templates that utilize
   * Polymer's data-binding and declarative event listener features.
   *
   * Example:
   *
   *     // Get a template from somewhere, e.g. light DOM
   *     let template = this.querySelector('template');
   *     // Prepare the template
   *     let TemplateClass = Polymer.Templatize.templatize(template);
   *     // Instance the template with an initial data model
   *     let instance = new TemplateClass({myProp: 'initial'});
   *     // Insert the instance's DOM somewhere, e.g. element's shadow DOM
   *     this.shadowRoot.appendChild(instance.root);
   *     // Changing a property on the instance will propagate to bindings
   *     // in the template
   *     instance.myProp = 'new value';
   *
   * The `options` dictionary passed to `templatize` allows for customizing
   * features of the generated template class, including how outer-scope host
   * properties should be forwarded into template instances, how any instance
   * properties added into the template's scope should be notified out to
   * the host, and whether the instance should be decorated as a "parent model"
   * of any event handlers.
   *
   *     // Customze property forwarding and event model decoration
   *     let TemplateClass = Polymer.Templatize.templatize(template, this, {
   *       parentModel: true,
   *       instanceProps: {...},
   *       forwardHostProp(property, value) {...},
   *       notifyInstanceProp(instance, property, value) {...},
   *     });
   *
   *
   * @namespace
   * @memberof Polymer
   * @summary Module for preparing and stamping instances of templates
   *   utilizing Polymer templating features.
   */

  var Templatize = {

    /**
     * Returns an anonymous `Polymer.PropertyEffects` class bound to the
     * `<template>` provided.  Instancing the class will result in the
     * template being stamped into document fragment stored as the instance's
     * `root` property, after which it can be appended to the DOM.
     *
     * Templates may utilize all Polymer data-binding features as well as
     * declarative event listeners.  Event listeners and inline computing
     * functions in the template will be called on the host of the template.
     *
     * The constructor returned takes a single argument dictionary of initial
     * property values to propagate into template bindings.  Additionally
     * host properties can be forwarded in, and instance properties can be
     * notified out by providing optional callbacks in the `options` dictionary.
     *
     * Valid configuration in `options` are as follows:
     *
     * - `forwardHostProp(property, value)`: Called when a property referenced
     *   in the template changed on the template's host. As this library does
     *   not retain references to templates instanced by the user, it is the
     *   templatize owner's responsibility to forward host property changes into
     *   user-stamped instances.  The `instance.forwardHostProp(property, value)`
     *    method on the generated class should be called to forward host
     *   properties into the template to prevent unnecessary property-changed
     *   notifications. Any properties referenced in the template that are not
     *   defined in `instanceProps` will be notified up to the template's host
     *   automatically.
     * - `instanceProps`: Dictionary of property names that will be added
     *   to the instance by the templatize owner.  These properties shadow any
     *   host properties, and changes within the template to these properties
     *   will result in `notifyInstanceProp` being called.
     * - `mutableData`: When `true`, the generated class will skip strict
     *   dirty-checking for objects and arrays (always consider them to be
     *   "dirty").
     * - `notifyInstanceProp(instance, property, value)`: Called when
     *   an instance property changes.  Users may choose to call `notifyPath`
     *   on e.g. the owner to notify the change.
     * - `parentModel`: When `true`, events handled by declarative event listeners
     *   (`on-event="handler"`) will be decorated with a `model` property pointing
     *   to the template instance that stamped it.  It will also be returned
     *   from `instance.parentModel` in cases where template instance nesting
     *   causes an inner model to shadow an outer model.
     *
     * Note that the class returned from `templatize` is generated only once
     * for a given `<template>` using `options` from the first call for that
     * template, and the cached class is returned for all subsequent calls to
     * `templatize` for that template.  As such, `options` callbacks should not
     * close over owner-specific properties since only the first `options` is
     * used; rather, callbacks are called bound to the `owner`, and so context
     * needed from the callbacks (such as references to `instances` stamped)
     * should be stored on the `owner` such that they can be retrieved via `this`.
     *
     * @memberof Polymer.Templatize
     * @param {!HTMLTemplateElement} template Template to templatize
     * @param {!Polymer_PropertyEffects} owner Owner of the template instances;
     *   any optional callbacks will be bound to this owner.
     * @param {Object=} options Options dictionary (see summary for details)
     * @return {function(new:TemplateInstanceBase)} Generated class bound to the template
     *   provided
     * @suppress {invalidCasts}
     */
    templatize: function templatize(template, owner, options) {
      options = /** @type {!TemplatizeOptions} */options || {};
      if (template.__templatizeOwner) {
        throw new Error('A <template> can only be templatized once');
      }
      template.__templatizeOwner = owner;
      var templateInfo = owner.constructor._parseTemplate(template);
      // Get memoized base class for the prototypical template, which
      // includes property effects for binding template & forwarding
      var baseClass = templateInfo.templatizeInstanceClass;
      if (!baseClass) {
        baseClass = createTemplatizerClass(template, templateInfo, options);
        templateInfo.templatizeInstanceClass = baseClass;
      }
      // Host property forwarding must be installed onto template instance
      addPropagateEffects(template, templateInfo, options);
      // Subclass base class and add reference for this specific template
      var klass = function (_baseClass) {
        _inherits(TemplateInstance, _baseClass);

        function TemplateInstance() {
          _classCallCheck(this, TemplateInstance);

          return _possibleConstructorReturn(this, (TemplateInstance.__proto__ || Object.getPrototypeOf(TemplateInstance)).apply(this, arguments));
        }

        return TemplateInstance;
      }(baseClass);
      klass.prototype._methodHost = findMethodHost(template);
      klass.prototype.__dataHost = template;
      klass.prototype.__templatizeOwner = owner;
      klass.prototype.__hostProps = templateInfo.hostProps;
      return (/** @type {function(new:TemplateInstanceBase)} */klass
      );
    },


    /**
     * Returns the template "model" associated with a given element, which
     * serves as the binding scope for the template instance the element is
     * contained in. A template model is an instance of
     * `TemplateInstanceBase`, and should be used to manipulate data
     * associated with this template instance.
     *
     * Example:
     *
     *   let model = modelForElement(el);
     *   if (model.index < 10) {
     *     model.set('item.checked', true);
     *   }
     *
     * @memberof Polymer.Templatize
     * @param {HTMLTemplateElement} template The model will be returned for
     *   elements stamped from this template
     * @param {Node} node Node for which to return a template model.
     * @return {TemplateInstanceBase} Template instance representing the
     *   binding scope for the element
     */
    modelForElement: function modelForElement(template, node) {
      var model = void 0;
      while (node) {
        // An element with a __templatizeInstance marks the top boundary
        // of a scope; walk up until we find one, and then ensure that
        // its __dataHost matches `this`, meaning this dom-repeat stamped it
        if (model = node.__templatizeInstance) {
          // Found an element stamped by another template; keep walking up
          // from its __dataHost
          if (model.__dataHost != template) {
            node = model.__dataHost;
          } else {
            return model;
          }
        } else {
          // Still in a template scope, keep going up until
          // a __templatizeInstance is found
          node = node.parentNode;
        }
      }
      return null;
    }
  };

  Polymer.Templatize = Templatize;
  Polymer.TemplateInstanceBase = TemplateInstanceBase;
})();

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

__webpack_require__(17);

/**
 * @polymerBehavior Polymer.AppLayoutBehavior
 **/
Polymer.AppLayoutBehavior = [Polymer.IronResizableBehavior, {

  listeners: {
    'app-reset-layout': '_appResetLayoutHandler',
    'iron-resize': 'resetLayout'
  },

  attached: function attached() {
    this.fire('app-reset-layout');
  },

  _appResetLayoutHandler: function _appResetLayoutHandler(e) {
    if (Polymer.dom(e).path[0] === this) {
      return;
    }
    this.resetLayout();
    e.stopPropagation();
  },

  _updateLayoutStates: function _updateLayoutStates() {
    console.error('unimplemented');
  },

  /**
   * Resets the layout. If you changed the size of this element via CSS
   * you can notify the changes by either firing the `iron-resize` event
   * or calling `resetLayout` directly.
   *
   * @method resetLayout
   */
  resetLayout: function resetLayout() {
    // Polymer v2.x
    var self = this;
    var cb = this._updateLayoutStates.bind(this);
    if (Polymer.Async && Polymer.Async.animationFrame) {
      this._layoutDebouncer = Polymer.Debouncer.debounce(this._layoutDebouncer, Polymer.Async.animationFrame, cb);
      Polymer.enqueueDebouncer(this._layoutDebouncer);
    }
    // Polymer v1.x
    else {
        this.debounce('resetLayout', cb);
      }
    this._notifyDescendantResize();
  },

  _notifyLayoutChanged: function _notifyLayoutChanged() {
    var self = this;
    // TODO: the event `app-reset-layout` can be fired synchronously
    // as long as `_updateLayoutStates` waits for all the microtasks after rAF.
    // E.g. requestAnimationFrame(setTimeOut())
    requestAnimationFrame(function () {
      self.fire('app-reset-layout');
    });
  },

  _notifyDescendantResize: function _notifyDescendantResize() {
    if (!this.isAttached) {
      return;
    }
    this._interestedResizables.forEach(function (resizable) {
      if (this.resizerShouldNotify(resizable)) {
        this._notifyDescendant(resizable);
      }
    }, this);
  }
}];

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

(function () {
  'use strict';

  /**
   * Chrome uses an older version of DOM Level 3 Keyboard Events
   *
   * Most keys are labeled as text, but some are Unicode codepoints.
   * Values taken from: http://www.w3.org/TR/2007/WD-DOM-Level-3-Events-20071221/keyset.html#KeySet-Set
   */

  var KEY_IDENTIFIER = {
    'U+0008': 'backspace',
    'U+0009': 'tab',
    'U+001B': 'esc',
    'U+0020': 'space',
    'U+007F': 'del'
  };

  /**
   * Special table for KeyboardEvent.keyCode.
   * KeyboardEvent.keyIdentifier is better, and KeyBoardEvent.key is even better
   * than that.
   *
   * Values from: https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent.keyCode#Value_of_keyCode
   */
  var KEY_CODE = {
    8: 'backspace',
    9: 'tab',
    13: 'enter',
    27: 'esc',
    33: 'pageup',
    34: 'pagedown',
    35: 'end',
    36: 'home',
    32: 'space',
    37: 'left',
    38: 'up',
    39: 'right',
    40: 'down',
    46: 'del',
    106: '*'
  };

  /**
   * MODIFIER_KEYS maps the short name for modifier keys used in a key
   * combo string to the property name that references those same keys
   * in a KeyboardEvent instance.
   */
  var MODIFIER_KEYS = {
    'shift': 'shiftKey',
    'ctrl': 'ctrlKey',
    'alt': 'altKey',
    'meta': 'metaKey'
  };

  /**
   * KeyboardEvent.key is mostly represented by printable character made by
   * the keyboard, with unprintable keys labeled nicely.
   *
   * However, on OS X, Alt+char can make a Unicode character that follows an
   * Apple-specific mapping. In this case, we fall back to .keyCode.
   */
  var KEY_CHAR = /[a-z0-9*]/;

  /**
   * Matches a keyIdentifier string.
   */
  var IDENT_CHAR = /U\+/;

  /**
   * Matches arrow keys in Gecko 27.0+
   */
  var ARROW_KEY = /^arrow/;

  /**
   * Matches space keys everywhere (notably including IE10's exceptional name
   * `spacebar`).
   */
  var SPACE_KEY = /^space(bar)?/;

  /**
   * Matches ESC key.
   *
   * Value from: http://w3c.github.io/uievents-key/#key-Escape
   */
  var ESC_KEY = /^escape$/;

  /**
   * Transforms the key.
   * @param {string} key The KeyBoardEvent.key
   * @param {Boolean} [noSpecialChars] Limits the transformation to
   * alpha-numeric characters.
   */
  function transformKey(key, noSpecialChars) {
    var validKey = '';
    if (key) {
      var lKey = key.toLowerCase();
      if (lKey === ' ' || SPACE_KEY.test(lKey)) {
        validKey = 'space';
      } else if (ESC_KEY.test(lKey)) {
        validKey = 'esc';
      } else if (lKey.length == 1) {
        if (!noSpecialChars || KEY_CHAR.test(lKey)) {
          validKey = lKey;
        }
      } else if (ARROW_KEY.test(lKey)) {
        validKey = lKey.replace('arrow', '');
      } else if (lKey == 'multiply') {
        // numpad '*' can map to Multiply on IE/Windows
        validKey = '*';
      } else {
        validKey = lKey;
      }
    }
    return validKey;
  }

  function transformKeyIdentifier(keyIdent) {
    var validKey = '';
    if (keyIdent) {
      if (keyIdent in KEY_IDENTIFIER) {
        validKey = KEY_IDENTIFIER[keyIdent];
      } else if (IDENT_CHAR.test(keyIdent)) {
        keyIdent = parseInt(keyIdent.replace('U+', '0x'), 16);
        validKey = String.fromCharCode(keyIdent).toLowerCase();
      } else {
        validKey = keyIdent.toLowerCase();
      }
    }
    return validKey;
  }

  function transformKeyCode(keyCode) {
    var validKey = '';
    if (Number(keyCode)) {
      if (keyCode >= 65 && keyCode <= 90) {
        // ascii a-z
        // lowercase is 32 offset from uppercase
        validKey = String.fromCharCode(32 + keyCode);
      } else if (keyCode >= 112 && keyCode <= 123) {
        // function keys f1-f12
        validKey = 'f' + (keyCode - 112 + 1);
      } else if (keyCode >= 48 && keyCode <= 57) {
        // top 0-9 keys
        validKey = String(keyCode - 48);
      } else if (keyCode >= 96 && keyCode <= 105) {
        // num pad 0-9
        validKey = String(keyCode - 96);
      } else {
        validKey = KEY_CODE[keyCode];
      }
    }
    return validKey;
  }

  /**
    * Calculates the normalized key for a KeyboardEvent.
    * @param {KeyboardEvent} keyEvent
    * @param {Boolean} [noSpecialChars] Set to true to limit keyEvent.key
    * transformation to alpha-numeric chars. This is useful with key
    * combinations like shift + 2, which on FF for MacOS produces
    * keyEvent.key = @
    * To get 2 returned, set noSpecialChars = true
    * To get @ returned, set noSpecialChars = false
   */
  function normalizedKeyForEvent(keyEvent, noSpecialChars) {
    // Fall back from .key, to .detail.key for artifical keyboard events,
    // and then to deprecated .keyIdentifier and .keyCode.
    if (keyEvent.key) {
      return transformKey(keyEvent.key, noSpecialChars);
    }
    if (keyEvent.detail && keyEvent.detail.key) {
      return transformKey(keyEvent.detail.key, noSpecialChars);
    }
    return transformKeyIdentifier(keyEvent.keyIdentifier) || transformKeyCode(keyEvent.keyCode) || '';
  }

  function keyComboMatchesEvent(keyCombo, event) {
    // For combos with modifiers we support only alpha-numeric keys
    var keyEvent = normalizedKeyForEvent(event, keyCombo.hasModifiers);
    return keyEvent === keyCombo.key && (!keyCombo.hasModifiers || !!event.shiftKey === !!keyCombo.shiftKey && !!event.ctrlKey === !!keyCombo.ctrlKey && !!event.altKey === !!keyCombo.altKey && !!event.metaKey === !!keyCombo.metaKey);
  }

  function parseKeyComboString(keyComboString) {
    if (keyComboString.length === 1) {
      return {
        combo: keyComboString,
        key: keyComboString,
        event: 'keydown'
      };
    }
    return keyComboString.split('+').reduce(function (parsedKeyCombo, keyComboPart) {
      var eventParts = keyComboPart.split(':');
      var keyName = eventParts[0];
      var event = eventParts[1];

      if (keyName in MODIFIER_KEYS) {
        parsedKeyCombo[MODIFIER_KEYS[keyName]] = true;
        parsedKeyCombo.hasModifiers = true;
      } else {
        parsedKeyCombo.key = keyName;
        parsedKeyCombo.event = event || 'keydown';
      }

      return parsedKeyCombo;
    }, {
      combo: keyComboString.split(':').shift()
    });
  }

  function parseEventString(eventString) {
    return eventString.trim().split(' ').map(function (keyComboString) {
      return parseKeyComboString(keyComboString);
    });
  }

  /**
   * `Polymer.IronA11yKeysBehavior` provides a normalized interface for processing
   * keyboard commands that pertain to [WAI-ARIA best practices](http://www.w3.org/TR/wai-aria-practices/#kbd_general_binding).
   * The element takes care of browser differences with respect to Keyboard events
   * and uses an expressive syntax to filter key presses.
   *
   * Use the `keyBindings` prototype property to express what combination of keys
   * will trigger the callback. A key binding has the format
   * `"KEY+MODIFIER:EVENT": "callback"` (`"KEY": "callback"` or
   * `"KEY:EVENT": "callback"` are valid as well). Some examples:
   *
   *      keyBindings: {
   *        'space': '_onKeydown', // same as 'space:keydown'
   *        'shift+tab': '_onKeydown',
   *        'enter:keypress': '_onKeypress',
   *        'esc:keyup': '_onKeyup'
   *      }
   *
   * The callback will receive with an event containing the following information in `event.detail`:
   *
   *      _onKeydown: function(event) {
   *        console.log(event.detail.combo); // KEY+MODIFIER, e.g. "shift+tab"
   *        console.log(event.detail.key); // KEY only, e.g. "tab"
   *        console.log(event.detail.event); // EVENT, e.g. "keydown"
   *        console.log(event.detail.keyboardEvent); // the original KeyboardEvent
   *      }
   *
   * Use the `keyEventTarget` attribute to set up event handlers on a specific
   * node.
   *
   * See the [demo source code](https://github.com/PolymerElements/iron-a11y-keys-behavior/blob/master/demo/x-key-aware.html)
   * for an example.
   *
   * @demo demo/index.html
   * @polymerBehavior
   */
  Polymer.IronA11yKeysBehavior = {
    properties: {
      /**
       * The EventTarget that will be firing relevant KeyboardEvents. Set it to
       * `null` to disable the listeners.
       * @type {?EventTarget}
       */
      keyEventTarget: {
        type: Object,
        value: function value() {
          return this;
        }
      },

      /**
       * If true, this property will cause the implementing element to
       * automatically stop propagation on any handled KeyboardEvents.
       */
      stopKeyboardEventPropagation: {
        type: Boolean,
        value: false
      },

      _boundKeyHandlers: {
        type: Array,
        value: function value() {
          return [];
        }
      },

      // We use this due to a limitation in IE10 where instances will have
      // own properties of everything on the "prototype".
      _imperativeKeyBindings: {
        type: Object,
        value: function value() {
          return {};
        }
      }
    },

    observers: ['_resetKeyEventListeners(keyEventTarget, _boundKeyHandlers)'],

    /**
     * To be used to express what combination of keys  will trigger the relative
     * callback. e.g. `keyBindings: { 'esc': '_onEscPressed'}`
     * @type {!Object}
     */
    keyBindings: {},

    registered: function registered() {
      this._prepKeyBindings();
    },

    attached: function attached() {
      this._listenKeyEventListeners();
    },

    detached: function detached() {
      this._unlistenKeyEventListeners();
    },

    /**
     * Can be used to imperatively add a key binding to the implementing
     * element. This is the imperative equivalent of declaring a keybinding
     * in the `keyBindings` prototype property.
     *
     * @param {string} eventString
     * @param {string} handlerName
     */
    addOwnKeyBinding: function addOwnKeyBinding(eventString, handlerName) {
      this._imperativeKeyBindings[eventString] = handlerName;
      this._prepKeyBindings();
      this._resetKeyEventListeners();
    },

    /**
     * When called, will remove all imperatively-added key bindings.
     */
    removeOwnKeyBindings: function removeOwnKeyBindings() {
      this._imperativeKeyBindings = {};
      this._prepKeyBindings();
      this._resetKeyEventListeners();
    },

    /**
     * Returns true if a keyboard event matches `eventString`.
     *
     * @param {KeyboardEvent} event
     * @param {string} eventString
     * @return {boolean}
     */
    keyboardEventMatchesKeys: function keyboardEventMatchesKeys(event, eventString) {
      var keyCombos = parseEventString(eventString);
      for (var i = 0; i < keyCombos.length; ++i) {
        if (keyComboMatchesEvent(keyCombos[i], event)) {
          return true;
        }
      }
      return false;
    },

    _collectKeyBindings: function _collectKeyBindings() {
      var keyBindings = this.behaviors.map(function (behavior) {
        return behavior.keyBindings;
      });

      if (keyBindings.indexOf(this.keyBindings) === -1) {
        keyBindings.push(this.keyBindings);
      }

      return keyBindings;
    },

    _prepKeyBindings: function _prepKeyBindings() {
      this._keyBindings = {};

      this._collectKeyBindings().forEach(function (keyBindings) {
        for (var eventString in keyBindings) {
          this._addKeyBinding(eventString, keyBindings[eventString]);
        }
      }, this);

      for (var eventString in this._imperativeKeyBindings) {
        this._addKeyBinding(eventString, this._imperativeKeyBindings[eventString]);
      }

      // Give precedence to combos with modifiers to be checked first.
      for (var eventName in this._keyBindings) {
        this._keyBindings[eventName].sort(function (kb1, kb2) {
          var b1 = kb1[0].hasModifiers;
          var b2 = kb2[0].hasModifiers;
          return b1 === b2 ? 0 : b1 ? -1 : 1;
        });
      }
    },

    _addKeyBinding: function _addKeyBinding(eventString, handlerName) {
      parseEventString(eventString).forEach(function (keyCombo) {
        this._keyBindings[keyCombo.event] = this._keyBindings[keyCombo.event] || [];

        this._keyBindings[keyCombo.event].push([keyCombo, handlerName]);
      }, this);
    },

    _resetKeyEventListeners: function _resetKeyEventListeners() {
      this._unlistenKeyEventListeners();

      if (this.isAttached) {
        this._listenKeyEventListeners();
      }
    },

    _listenKeyEventListeners: function _listenKeyEventListeners() {
      if (!this.keyEventTarget) {
        return;
      }
      Object.keys(this._keyBindings).forEach(function (eventName) {
        var keyBindings = this._keyBindings[eventName];
        var boundKeyHandler = this._onKeyBindingEvent.bind(this, keyBindings);

        this._boundKeyHandlers.push([this.keyEventTarget, eventName, boundKeyHandler]);

        this.keyEventTarget.addEventListener(eventName, boundKeyHandler);
      }, this);
    },

    _unlistenKeyEventListeners: function _unlistenKeyEventListeners() {
      var keyHandlerTuple;
      var keyEventTarget;
      var eventName;
      var boundKeyHandler;

      while (this._boundKeyHandlers.length) {
        // My kingdom for block-scope binding and destructuring assignment..
        keyHandlerTuple = this._boundKeyHandlers.pop();
        keyEventTarget = keyHandlerTuple[0];
        eventName = keyHandlerTuple[1];
        boundKeyHandler = keyHandlerTuple[2];

        keyEventTarget.removeEventListener(eventName, boundKeyHandler);
      }
    },

    _onKeyBindingEvent: function _onKeyBindingEvent(keyBindings, event) {
      if (this.stopKeyboardEventPropagation) {
        event.stopPropagation();
      }

      // if event has been already prevented, don't do anything
      if (event.defaultPrevented) {
        return;
      }

      for (var i = 0; i < keyBindings.length; i++) {
        var keyCombo = keyBindings[i][0];
        var handlerName = keyBindings[i][1];
        if (keyComboMatchesEvent(keyCombo, event)) {
          this._triggerKeyHandler(keyCombo, handlerName, event);
          // exit the loop if eventDefault was prevented
          if (event.defaultPrevented) {
            return;
          }
        }
      }
    },

    _triggerKeyHandler: function _triggerKeyHandler(keyCombo, handlerName, keyboardEvent) {
      var detail = Object.create(keyCombo);
      detail.keyboardEvent = keyboardEvent;
      var event = new CustomEvent(keyCombo.event, {
        detail: detail,
        cancelable: true
      });
      this[handlerName].call(this, event);
      if (event.defaultPrevented) {
        keyboardEvent.preventDefault();
      }
    }
  };
})();

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

/**
 * `IronResizableBehavior` is a behavior that can be used in Polymer elements to
 * coordinate the flow of resize events between "resizers" (elements that control the
 * size or hidden state of their children) and "resizables" (elements that need to be
 * notified when they are resized or un-hidden by their parents in order to take
 * action on their new measurements).
 *
 * Elements that perform measurement should add the `IronResizableBehavior` behavior to
 * their element definition and listen for the `iron-resize` event on themselves.
 * This event will be fired when they become showing after having been hidden,
 * when they are resized explicitly by another resizable, or when the window has been
 * resized.
 *
 * Note, the `iron-resize` event is non-bubbling.
 *
 * @polymerBehavior Polymer.IronResizableBehavior
 * @demo demo/index.html
 **/
Polymer.IronResizableBehavior = {
  properties: {
    /**
     * The closest ancestor element that implements `IronResizableBehavior`.
     */
    _parentResizable: {
      type: Object,
      observer: '_parentResizableChanged'
    },

    /**
     * True if this element is currently notifying its descendant elements of
     * resize.
     */
    _notifyingDescendant: {
      type: Boolean,
      value: false
    }
  },

  listeners: {
    'iron-request-resize-notifications': '_onIronRequestResizeNotifications'
  },

  created: function created() {
    // We don't really need property effects on these, and also we want them
    // to be created before the `_parentResizable` observer fires:
    this._interestedResizables = [];
    this._boundNotifyResize = this.notifyResize.bind(this);
  },

  attached: function attached() {
    this._requestResizeNotifications();
  },

  detached: function detached() {
    if (this._parentResizable) {
      this._parentResizable.stopResizeNotificationsFor(this);
    } else {
      window.removeEventListener('resize', this._boundNotifyResize);
    }

    this._parentResizable = null;
  },

  /**
   * Can be called to manually notify a resizable and its descendant
   * resizables of a resize change.
   */
  notifyResize: function notifyResize() {
    if (!this.isAttached) {
      return;
    }

    this._interestedResizables.forEach(function (resizable) {
      if (this.resizerShouldNotify(resizable)) {
        this._notifyDescendant(resizable);
      }
    }, this);

    this._fireResize();
  },

  /**
   * Used to assign the closest resizable ancestor to this resizable
   * if the ancestor detects a request for notifications.
   */
  assignParentResizable: function assignParentResizable(parentResizable) {
    this._parentResizable = parentResizable;
  },

  /**
   * Used to remove a resizable descendant from the list of descendants
   * that should be notified of a resize change.
   */
  stopResizeNotificationsFor: function stopResizeNotificationsFor(target) {
    var index = this._interestedResizables.indexOf(target);

    if (index > -1) {
      this._interestedResizables.splice(index, 1);
      this.unlisten(target, 'iron-resize', '_onDescendantIronResize');
    }
  },

  /**
   * This method can be overridden to filter nested elements that should or
   * should not be notified by the current element. Return true if an element
   * should be notified, or false if it should not be notified.
   *
   * @param {HTMLElement} element A candidate descendant element that
   * implements `IronResizableBehavior`.
   * @return {boolean} True if the `element` should be notified of resize.
   */
  resizerShouldNotify: function resizerShouldNotify(element) {
    return true;
  },

  _onDescendantIronResize: function _onDescendantIronResize(event) {
    if (this._notifyingDescendant) {
      event.stopPropagation();
      return;
    }

    // NOTE(cdata): In ShadowDOM, event retargeting makes echoing of the
    // otherwise non-bubbling event "just work." We do it manually here for
    // the case where Polymer is not using shadow roots for whatever reason:
    if (!Polymer.Settings.useShadow) {
      this._fireResize();
    }
  },

  _fireResize: function _fireResize() {
    this.fire('iron-resize', null, {
      node: this,
      bubbles: false
    });
  },

  _onIronRequestResizeNotifications: function _onIronRequestResizeNotifications(event) {
    var target = /** @type {!EventTarget} */Polymer.dom(event).rootTarget;
    if (target === this) {
      return;
    }

    if (this._interestedResizables.indexOf(target) === -1) {
      this._interestedResizables.push(target);
      this.listen(target, 'iron-resize', '_onDescendantIronResize');
    }

    target.assignParentResizable(this);
    this._notifyDescendant(target);

    event.stopPropagation();
  },

  _parentResizableChanged: function _parentResizableChanged(parentResizable) {
    if (parentResizable) {
      window.removeEventListener('resize', this._boundNotifyResize);
    }
  },

  _notifyDescendant: function _notifyDescendant(descendant) {
    // NOTE(cdata): In IE10, attached is fired on children first, so it's
    // important not to notify them if the parent is not attached yet (or
    // else they will get redundantly notified when the parent attaches).
    if (!this.isAttached) {
      return;
    }

    this._notifyingDescendant = true;
    descendant.notifyResize();
    this._notifyingDescendant = false;
  },

  _requestResizeNotifications: function _requestResizeNotifications() {
    if (!this.isAttached) return;

    // NOTE(valdrin) In CustomElements v1 with native HTMLImports, the order
    // of imports affects the order of `attached` callbacks (see webcomponents/custom-elements#15).
    // This might cause a child to notify parents too early (as the parent
    // still has to be upgraded), resulting in a parent not able to keep track
    // of the `_interestedResizables`. To solve this, we wait for the document
    // to be done loading before firing the event.
    if (document.readyState === 'loading') {
      var _requestResizeNotifications = this._requestResizeNotifications.bind(this);
      document.addEventListener('readystatechange', function readystatechanged() {
        document.removeEventListener('readystatechange', readystatechanged);
        _requestResizeNotifications();
      });
    } else {
      this.fire('iron-request-resize-notifications', null, {
        node: this,
        bubbles: true,
        cancelable: true
      });

      if (!this._parentResizable) {
        window.addEventListener('resize', this._boundNotifyResize);
        this.notifyResize();
      }
    }
  }
};

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

(function () {

  /**
   * @constructor
   * @param {{type: (string|null), key: (string|null), value: *}} options
   */
  function IronMeta(options) {
    this.type = options && options.type || 'default';
    this.key = options && options.key;
    if ('value' in options) {
      this.value = options.value;
    }
  }

  IronMeta.types = {};

  IronMeta.prototype = {
    get value() {
      var type = this.type;
      var key = this.key;

      if (type && key) {
        return IronMeta.types[type] && IronMeta.types[type][key];
      }
    },

    set value(value) {
      var type = this.type;
      var key = this.key;

      if (type && key) {
        type = IronMeta.types[type] = IronMeta.types[type] || {};
        if (value == null) {
          delete type[key];
        } else {
          type[key] = value;
        }
      }
    },

    get list() {
      var type = this.type;

      if (type) {
        return Object.keys(IronMeta.types[this.type]).map(function (key) {
          return metaDatas[this.type][key];
        }, this);
      }
    },

    byKey: function byKey(key) {
      this.key = key;
      return this.value;
    }
  };

  Polymer.IronMeta = IronMeta;

  var metaDatas = Polymer.IronMeta.types;

  Polymer({

    is: 'iron-meta',

    properties: {

      /**
       * The type of meta-data.  All meta-data of the same type is stored
       * together.
       * @type {string}
       */
      type: {
        type: String,
        value: 'default'
      },

      /**
       * The key used to store `value` under the `type` namespace.
       * @type {?string}
       */
      key: {
        type: String
      },

      /**
       * The meta-data to store or retrieve.
       * @type {*}
       */
      value: {
        type: String,
        notify: true
      },

      /**
       * If true, `value` is set to the iron-meta instance itself.
       */
      self: {
        type: Boolean,
        observer: '_selfChanged'
      },

      __meta: {
        type: Boolean,
        computed: '__computeMeta(type, key, value)'
      }
    },

    hostAttributes: {
      hidden: true
    },

    __computeMeta: function __computeMeta(type, key, value) {
      var meta = new Polymer.IronMeta({
        type: type,
        key: key
      });

      if (value !== undefined && value !== meta.value) {
        meta.value = value;
      } else if (this.value !== meta.value) {
        this.value = meta.value;
      }

      return meta;
    },

    get list() {
      return this.__meta && this.__meta.list;
    },

    _selfChanged: function _selfChanged(self) {
      if (self) {
        this.value = this;
      }
    },

    /**
     * Retrieves meta data value by key.
     *
     * @method byKey
     * @param {string} key The key of the meta-data to be returned.
     * @return {*}
     */
    byKey: function byKey(key) {
      return new Polymer.IronMeta({
        type: this.type,
        key: key
      }).value;
    }
  });
})();

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

__webpack_require__(1);

__webpack_require__(20);

__webpack_require__(3);

__webpack_require__(10);

__webpack_require__(21);

__webpack_require__(7);

__webpack_require__(40);

__webpack_require__(11);

(function () {
  'use strict';

  /**
   * Element class mixin that provides the core API for Polymer's meta-programming
   * features including template stamping, data-binding, attribute deserialization,
   * and property change observation.
   *
   * Subclassers may provide the following static getters to return metadata
   * used to configure Polymer's features for the class:
   *
   * - `static get is()`: When the template is provided via a `dom-module`,
   *   users should return the `dom-module` id from a static `is` getter.  If
   *   no template is needed or the template is provided directly via the
   *   `template` getter, there is no need to define `is` for the element.
   *
   * - `static get template()`: Users may provide the template directly (as
   *   opposed to via `dom-module`) by implementing a static `template` getter.
   *   The getter may return an `HTMLTemplateElement` or a string, which will
   *   automatically be parsed into a template.
   *
   * - `static get properties()`: Should return an object describing
   *   property-related metadata used by Polymer features (key: property name
   *   value: object containing property metadata). Valid keys in per-property
   *   metadata include:
   *   - `type` (String|Number|Object|Array|...): Used by
   *     `attributeChangedCallback` to determine how string-based attributes
   *     are deserialized to JavaScript property values.
   *   - `notify` (boolean): Causes a change in the property to fire a
   *     non-bubbling event called `<property>-changed`. Elements that have
   *     enabled two-way binding to the property use this event to observe changes.
   *   - `readOnly` (boolean): Creates a getter for the property, but no setter.
   *     To set a read-only property, use the private setter method
   *     `_setProperty(property, value)`.
   *   - `observer` (string): Observer method name that will be called when
   *     the property changes. The arguments of the method are
   *     `(value, previousValue)`.
   *   - `computed` (string): String describing method and dependent properties
   *     for computing the value of this property (e.g. `'computeFoo(bar, zot)'`).
   *     Computed properties are read-only by default and can only be changed
   *     via the return value of the computing method.
   *
   * - `static get observers()`: Array of strings describing multi-property
   *   observer methods and their dependent properties (e.g.
   *   `'observeABC(a, b, c)'`).
   *
   * The base class provides default implementations for the following standard
   * custom element lifecycle callbacks; users may override these, but should
   * call the super method to ensure
   * - `constructor`: Run when the element is created or upgraded
   * - `connectedCallback`: Run each time the element is connected to the
   *   document
   * - `disconnectedCallback`: Run each time the element is disconnected from
   *   the document
   * - `attributeChangedCallback`: Run each time an attribute in
   *   `observedAttributes` is set or removed (note: this element's default
   *   `observedAttributes` implementation will automatically return an array
   *   of dash-cased attributes based on `properties`)
   *
   * @mixinFunction
   * @polymer
   * @appliesMixin Polymer.PropertyEffects
   * @memberof Polymer
   * @property rootPath {string} Set to the value of `Polymer.rootPath`,
   *   which defaults to the main document path
   * @property importPath {string} Set to the value of the class's static
   *   `importPath` property, which defaults to the path of this element's
   *   `dom-module` (when `is` is used), but can be overridden for other
   *   import strategies.
   * @summary Element class mixin that provides the core API for Polymer's
   * meta-programming features.
   */

  Polymer.ElementMixin = Polymer.dedupingMixin(function (base) {

    /**
     * @constructor
     * @extends {base}
     * @implements {Polymer_PropertyEffects}
     */
    var polymerElementBase = Polymer.PropertyEffects(base);

    var caseMap = Polymer.CaseMap;

    /**
     * Returns the `properties` object specifically on `klass`. Use for:
     * (1) super chain mixes togther to make `propertiesForClass` which is
     * then used to make `observedAttributes`.
     * (2) properties effects and observers are created from it at `finalize` time.
     *
     * @param {HTMLElement} klass Element class
     * @return {Object} Object containing own properties for this class
     * @private
     */
    function ownPropertiesForClass(klass) {
      if (!klass.hasOwnProperty(JSCompiler_renameProperty('__ownProperties', klass))) {
        klass.__ownProperties = klass.hasOwnProperty(JSCompiler_renameProperty('properties', klass)) ?
        /** @type PolymerElementConstructor */klass.properties : {};
      }
      return klass.__ownProperties;
    }

    /**
     * Returns the `observers` array specifically on `klass`. Use for
     * setting up observers.
     *
     * @param {HTMLElement} klass Element class
     * @return {Array} Array containing own observers for this class
     * @private
     */
    function ownObserversForClass(klass) {
      if (!klass.hasOwnProperty(JSCompiler_renameProperty('__ownObservers', klass))) {
        klass.__ownObservers = klass.hasOwnProperty(JSCompiler_renameProperty('observers', klass)) ?
        /** @type PolymerElementConstructor */klass.observers : [];
      }
      return klass.__ownObservers;
    }

    /**
     * Mixes `props` into `flattenedProps` but upgrades shorthand type
     * syntax to { type: Type}.
     *
     * @param {Object} flattenedProps Bag to collect flattened properties into
     * @param {Object} props Bag of properties to add to `flattenedProps`
     * @return {Object} The input `flattenedProps` bag
     * @private
     */
    function flattenProperties(flattenedProps, props) {
      for (var p in props) {
        var o = props[p];
        if (typeof o == 'function') {
          o = { type: o };
        }
        flattenedProps[p] = o;
      }
      return flattenedProps;
    }

    /**
     * Returns a flattened list of properties mixed together from the chain of all
     * constructor's `config.properties`. This list is used to create
     * (1) observedAttributes,
     * (2) class property default values
     *
     * @param {PolymerElementConstructor} klass Element class
     * @return {PolymerElementProperties} Flattened properties for this class
     * @suppress {missingProperties} class.prototype is not a property for some reason?
     * @private
     */
    function propertiesForClass(klass) {
      if (!klass.hasOwnProperty(JSCompiler_renameProperty('__classProperties', klass))) {
        klass.__classProperties = flattenProperties({}, ownPropertiesForClass(klass));
        var superCtor = Object.getPrototypeOf(klass.prototype).constructor;
        if (superCtor.prototype instanceof PolymerElement) {
          klass.__classProperties = Object.assign(Object.create(propertiesForClass( /** @type PolymerElementConstructor */superCtor)), klass.__classProperties);
        }
      }
      return klass.__classProperties;
    }

    /**
     * Returns a list of properties with default values.
     * This list is created as an optimization since it is a subset of
     * the list returned from `propertiesForClass`.
     * This list is used in `_initializeProperties` to set property defaults.
     *
     * @param {PolymerElementConstructor} klass Element class
     * @return {PolymerElementProperties} Flattened properties for this class
     *   that have default values
     * @private
     */
    function propertyDefaultsForClass(klass) {
      if (!klass.hasOwnProperty(JSCompiler_renameProperty('__classPropertyDefaults', klass))) {
        klass.__classPropertyDefaults = null;
        var props = propertiesForClass(klass);
        for (var p in props) {
          var info = props[p];
          if ('value' in info) {
            klass.__classPropertyDefaults = klass.__classPropertyDefaults || {};
            klass.__classPropertyDefaults[p] = info;
          }
        }
      }
      return klass.__classPropertyDefaults;
    }

    /**
     * Returns true if a `klass` has finalized. Called in `ElementClass.finalize()`
     * @param {PolymerElementConstructor} klass Element class
     * @return {boolean} True if all metaprogramming for this class has been
     *   completed
     * @private
     */
    function hasClassFinalized(klass) {
      return klass.hasOwnProperty(JSCompiler_renameProperty('__finalized', klass));
    }

    /**
     * Called by `ElementClass.finalize()`. Ensures this `klass` and
     * *all superclasses* are finalized by traversing the prototype chain
     * and calling `klass.finalize()`.
     *
     * @param {PolymerElementConstructor} klass Element class
     * @private
     */
    function finalizeClassAndSuper(klass) {
      var proto = /** @type PolymerElementConstructor */klass.prototype;
      var superCtor = Object.getPrototypeOf(proto).constructor;
      if (superCtor.prototype instanceof PolymerElement) {
        superCtor.finalize();
      }
      finalizeClass(klass);
    }

    /**
     * Configures a `klass` based on a staic `klass.config` object and
     * a `template`. This includes creating accessors and effects
     * for properties in `config` and the `template` as well as preparing the
     * `template` for stamping.
     *
     * @param {PolymerElementConstructor} klass Element class
     * @private
     */
    function finalizeClass(klass) {
      klass.__finalized = true;
      var proto = /** @type PolymerElementConstructor */klass.prototype;
      if (klass.hasOwnProperty(JSCompiler_renameProperty('is', klass)) && klass.is) {
        Polymer.telemetry.register(proto);
      }
      var props = ownPropertiesForClass(klass);
      if (props) {
        finalizeProperties(proto, props);
      }
      var observers = ownObserversForClass(klass);
      if (observers) {
        finalizeObservers(proto, observers, props);
      }
      // note: create "working" template that is finalized at instance time
      var template = /** @type PolymerElementConstructor */klass.template;
      if (template) {
        if (typeof template === 'string') {
          var t = document.createElement('template');
          t.innerHTML = template;
          template = t;
        } else {
          template = template.cloneNode(true);
        }
        proto._template = template;
      }
    }

    /**
     * Configures a `proto` based on a `properties` object.
     * Leverages `PropertyEffects` to create property accessors and effects
     * supporting, observers, reflecting to attributes, change notification,
     * computed properties, and read only properties.
     * @param {PolymerElement} proto Element class prototype to add accessors
     *    and effects to
     * @param {Object} properties Flattened bag of property descriptors for
     *    this class
     * @private
     */
    function finalizeProperties(proto, properties) {
      for (var p in properties) {
        createPropertyFromConfig(proto, p, properties[p], properties);
      }
    }

    /**
     * Configures a `proto` based on a `observers` array.
     * Leverages `PropertyEffects` to create observers.
     * @param {PolymerElement} proto Element class prototype to add accessors
     *   and effects to
     * @param {Object} observers Flattened array of observer descriptors for
     *   this class
     * @param {Object} dynamicFns Object containing keys for any properties
     *   that are functions and should trigger the effect when the function
     *   reference is changed
     * @private
     */
    function finalizeObservers(proto, observers, dynamicFns) {
      for (var i = 0; i < observers.length; i++) {
        proto._createMethodObserver(observers[i], dynamicFns);
      }
    }

    /**
     * Creates effects for a property.
     *
     * Note, once a property has been set to
     * `readOnly`, `computed`, `reflectToAttribute`, or `notify`
     * these values may not be changed. For example, a subclass cannot
     * alter these settings. However, additional `observers` may be added
     * by subclasses.
     *
     * The info object should may contain property metadata as follows:
     *
     * * `type`: {function} type to which an attribute matching the property
     * is deserialized. Note the property is camel-cased from a dash-cased
     * attribute. For example, 'foo-bar' attribute is dersialized to a
     * property named 'fooBar'.
     *
     * * `readOnly`: {boolean} creates a readOnly property and
     * makes a private setter for the private of the form '_setFoo' for a
     * property 'foo',
     *
     * * `computed`: {string} creates a computed property. A computed property
     * also automatically is set to `readOnly: true`. The value is calculated
     * by running a method and arguments parsed from the given string. For
     * example 'compute(foo)' will compute a given property when the
     * 'foo' property changes by executing the 'compute' method. This method
     * must return the computed value.
     *
     * * `reflectToAttriute`: {boolean} If true, the property value is reflected
     * to an attribute of the same name. Note, the attribute is dash-cased
     * so a property named 'fooBar' is reflected as 'foo-bar'.
     *
     * * `notify`: {boolean} sends a non-bubbling notification event when
     * the property changes. For example, a property named 'foo' sends an
     * event named 'foo-changed' with `event.detail` set to the value of
     * the property.
     *
     * * observer: {string} name of a method that runs when the property
     * changes. The arguments of the method are (value, previousValue).
     *
     * Note: Users may want control over modifying property
     * effects via subclassing. For example, a user might want to make a
     * reflectToAttribute property not do so in a subclass. We've chosen to
     * disable this because it leads to additional complication.
     * For example, a readOnly effect generates a special setter. If a subclass
     * disables the effect, the setter would fail unexpectedly.
     * Based on feedback, we may want to try to make effects more malleable
     * and/or provide an advanced api for manipulating them.
     * Also consider adding warnings when an effect cannot be changed.
     *
     * @param {PolymerElement} proto Element class prototype to add accessors
     *   and effects to
     * @param {string} name Name of the property.
     * @param {Object} info Info object from which to create property effects.
     * Supported keys:
     * @param {Object} allProps Flattened map of all properties defined in this
     *   element (including inherited properties)
     * @private
     */
    function createPropertyFromConfig(proto, name, info, allProps) {
      // computed forces readOnly...
      if (info.computed) {
        info.readOnly = true;
      }
      // Note, since all computed properties are readOnly, this prevents
      // adding additional computed property effects (which leads to a confusing
      // setup where multiple triggers for setting a property)
      // While we do have `hasComputedEffect` this is set on the property's
      // dependencies rather than itself.
      if (info.computed && !proto._hasReadOnlyEffect(name)) {
        proto._createComputedProperty(name, info.computed, allProps);
      }
      if (info.readOnly && !proto._hasReadOnlyEffect(name)) {
        proto._createReadOnlyProperty(name, !info.computed);
      }
      if (info.reflectToAttribute && !proto._hasReflectEffect(name)) {
        proto._createReflectedProperty(name);
      }
      if (info.notify && !proto._hasNotifyEffect(name)) {
        proto._createNotifyingProperty(name);
      }
      // always add observer
      if (info.observer) {
        proto._createPropertyObserver(name, info.observer, allProps[info.observer]);
      }
    }

    /**
     * Configures an element `proto` to function with a given `template`.
     * The element name `is` and extends `ext` must be specified for ShadyCSS
     * style scoping.
     *
     * @param {PolymerElement} proto Element class prototype to add accessors
     *   and effects to
     * @param {!HTMLTemplateElement} template Template to process and bind
     * @param {string} baseURI URL against which to resolve urls in
     *   style element cssText
     * @param {string} is Tag name (or type extension name) for this element
     * @param {string=} ext For type extensions, the tag name that was extended
     * @private
     */
    function finalizeTemplate(proto, template, baseURI, is, ext) {
      // support `include="module-name"`
      var cssText = Polymer.StyleGather.cssFromTemplate(template, baseURI) + Polymer.StyleGather.cssFromModuleImports(is);
      if (cssText) {
        var style = document.createElement('style');
        style.textContent = cssText;
        template.content.insertBefore(style, template.content.firstChild);
      }
      if (window.ShadyCSS) {
        window.ShadyCSS.prepareTemplate(template, is, ext);
      }
      proto._bindTemplate(template);
    }

    /**
     * @polymer
     * @mixinClass
     * @unrestricted
     * @implements {Polymer_ElementMixin}
     */

    var PolymerElement = function (_polymerElementBase) {
      _inherits(PolymerElement, _polymerElementBase);

      function PolymerElement() {
        _classCallCheck(this, PolymerElement);

        return _possibleConstructorReturn(this, (PolymerElement.__proto__ || Object.getPrototypeOf(PolymerElement)).apply(this, arguments));
      }

      _createClass(PolymerElement, [{
        key: '_initializeProperties',


        /**
         * Overrides the default `Polymer.PropertyAccessors` to ensure class
         * metaprogramming related to property accessors and effects has
         * completed (calls `finalize`).
         *
         * It also initializes any property defaults provided via `value` in
         * `properties` metadata.
         *
         * @override
         * @suppress {invalidCasts}
         */
        value: function _initializeProperties() {
          Polymer.telemetry.instanceCount++;
          this.constructor.finalize();
          var importPath = this.constructor.importPath;
          // note: finalize template when we have access to `localName` to
          // avoid dependence on `is` for polyfilling styling.
          if (this._template && !this._template.__polymerFinalized) {
            this._template.__polymerFinalized = true;
            var baseURI = importPath ? Polymer.ResolveUrl.resolveUrl(importPath) : '';
            finalizeTemplate( /** @type {!PolymerElement} */this.__proto__, this._template, baseURI,
            /**@type {!HTMLElement}*/this.localName);
          }
          _get(PolymerElement.prototype.__proto__ || Object.getPrototypeOf(PolymerElement.prototype), '_initializeProperties', this).call(this);
          // set path defaults
          this.rootPath = Polymer.rootPath;
          this.importPath = importPath;
          // apply property defaults...
          var p$ = propertyDefaultsForClass(this.constructor);
          if (!p$) {
            return;
          }
          for (var p in p$) {
            var info = p$[p];
            // Don't set default value if there is already an own property, which
            // happens when a `properties` property with default but no effects had
            // a property set (e.g. bound) by its host before upgrade
            if (!this.hasOwnProperty(p)) {
              var value = typeof info.value == 'function' ? info.value.call(this) : info.value;
              // Set via `_setProperty` if there is an accessor, to enable
              // initializing readOnly property defaults
              if (this._hasAccessor(p)) {
                this._setPendingProperty(p, value, true);
              } else {
                this[p] = value;
              }
            }
          }
        }

        /**
         * Provides a default implementation of the standard Custom Elements
         * `connectedCallback`.
         *
         * The default implementation enables the property effects system and
         * flushes any pending properties, and updates shimmed CSS properties
         * when using the ShadyCSS scoping/custom properties polyfill.
         *
         * @suppress {invalidCasts}
         */

      }, {
        key: 'connectedCallback',
        value: function connectedCallback() {
          if (window.ShadyCSS && this._template) {
            window.ShadyCSS.styleElement( /** @type {!HTMLElement} */this);
          }
          this._enableProperties();
        }

        /**
         * Provides a default implementation of the standard Custom Elements
         * `disconnectedCallback`.
         */

      }, {
        key: 'disconnectedCallback',
        value: function disconnectedCallback() {}

        /**
         * Stamps the element template.
         *
         * @override
         */

      }, {
        key: 'ready',
        value: function ready() {
          if (this._template) {
            this.root = this._stampTemplate(this._template);
            this.$ = this.root.$;
          }
          _get(PolymerElement.prototype.__proto__ || Object.getPrototypeOf(PolymerElement.prototype), 'ready', this).call(this);
        }

        /**
         * Implements `PropertyEffects`'s `_readyClients` call. Attaches
         * element dom by calling `_attachDom` with the dom stamped from the
         * element's template via `_stampTemplate`. Note that this allows
         * client dom to be attached to the element prior to any observers
         * running.
         *
         * @override
         */

      }, {
        key: '_readyClients',
        value: function _readyClients() {
          if (this._template) {
            this.root = this._attachDom(this.root);
          }
          // The super._readyClients here sets the clients initialized flag.
          // We must wait to do this until after client dom is created/attached
          // so that this flag can be checked to prevent notifications fired
          // during this process from being handled before clients are ready.
          _get(PolymerElement.prototype.__proto__ || Object.getPrototypeOf(PolymerElement.prototype), '_readyClients', this).call(this);
        }

        /**
         * Attaches an element's stamped dom to itself. By default,
         * this method creates a `shadowRoot` and adds the dom to it.
         * However, this method may be overridden to allow an element
         * to put its dom in another location.
         *
         * @throws {Error}
         * @suppress {missingReturn}
         * @param {NodeList} dom to attach to the element.
         * @return {Node} node to which the dom has been attached.
         */

      }, {
        key: '_attachDom',
        value: function _attachDom(dom) {
          if (this.attachShadow) {
            if (dom) {
              if (!this.shadowRoot) {
                this.attachShadow({ mode: 'open' });
              }
              this.shadowRoot.appendChild(dom);
              return this.shadowRoot;
            }
            return null;
          } else {
            throw new Error('ShadowDOM not available. ' +
            // TODO(sorvell): move to compile-time conditional when supported
            'Polymer.Element can create dom as children instead of in ' + 'ShadowDOM by setting `this.root = this;\` before \`ready\`.');
          }
        }

        /**
         * Provides a default implementation of the standard Custom Elements
         * `attributeChangedCallback`.
         *
         * By default, attributes declared in `properties` metadata are
         * deserialized using their `type` information to properties of the
         * same name.  "Dash-cased" attributes are deserialzed to "camelCase"
         * properties.
         *
         * @param {string} name Name of attribute.
         * @param {?string} old Old value of attribute.
         * @param {?string} value Current value of attribute.
         * @override
         */

      }, {
        key: 'attributeChangedCallback',
        value: function attributeChangedCallback(name, old, value) {
          if (old !== value) {
            var property = caseMap.dashToCamelCase(name);
            var type = propertiesForClass(this.constructor)[property].type;
            if (!this._hasReadOnlyEffect(property)) {
              this._attributeToProperty(name, value, type);
            }
          }
        }

        /**
         * When using the ShadyCSS scoping and custom property shim, causes all
         * shimmed styles in this element (and its subtree) to be updated
         * based on current custom property values.
         *
         * The optional parameter overrides inline custom property styles with an
         * object of properties where the keys are CSS properties, and the values
         * are strings.
         *
         * Example: `this.updateStyles({'--color': 'blue'})`
         *
         * These properties are retained unless a value of `null` is set.
         *
         * @param {Object=} properties Bag of custom property key/values to
         *   apply to this element.
         * @suppress {invalidCasts}
         */

      }, {
        key: 'updateStyles',
        value: function updateStyles(properties) {
          if (window.ShadyCSS) {
            window.ShadyCSS.styleSubtree( /** @type {!HTMLElement} */this, properties);
          }
        }

        /**
         * Rewrites a given URL relative to a base URL. The base URL defaults to
         * the original location of the document containing the `dom-module` for
         * this element. This method will return the same URL before and after
         * bundling.
         *
         * @param {string} url URL to resolve.
         * @param {string=} base Optional base URL to resolve against, defaults
         * to the element's `importPath`
         * @return {string} Rewritten URL relative to base
         */

      }, {
        key: 'resolveUrl',
        value: function resolveUrl(url, base) {
          if (!base && this.importPath) {
            base = Polymer.ResolveUrl.resolveUrl(this.importPath);
          }
          return Polymer.ResolveUrl.resolveUrl(url, base);
        }

        /**
         * Overrides `PropertyAccessors` to add map of dynamic functions on
         * template info, for consumption by `PropertyEffects` template binding
         * code. This map determines which method templates should have accessors
         * created for them.
         *
         * @override
         * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
         */

      }], [{
        key: 'finalize',


        /**
         * Called automatically when the first element instance is created to
         * ensure that class finalization work has been completed.
         * May be called by users to eagerly perform class finalization work
         * prior to the creation of the first element instance.
         *
         * Class finalization work generally includes meta-programming such as
         * creating property accessors and any property effect metadata needed for
         * the features used.
         *
         * @public
         */
        value: function finalize() {
          if (!hasClassFinalized(this)) {
            finalizeClassAndSuper(this);
          }
        }

        /**
         * Returns the template that will be stamped into this element's shadow root.
         *
         * If a `static get is()` getter is defined, the default implementation
         * will return the first `<template>` in a `dom-module` whose `id`
         * matches this element's `is`.
         *
         * Users may override this getter to return an arbitrary template
         * (in which case the `is` getter is unnecessary). The template returned
         * may be either an `HTMLTemplateElement` or a string that will be
         * automatically parsed into a template.
         *
         * Note that when subclassing, if the super class overrode the default
         * implementation and the subclass would like to provide an alternate
         * template via a `dom-module`, it should override this getter and
         * return `Polymer.DomModule.import(this.is, 'template')`.
         *
         * If a subclass would like to modify the super class template, it should
         * clone it rather than modify it in place.  If the getter does expensive
         * work such as cloning/modifying a template, it should memoize the
         * template for maximum performance:
         *
         *   let memoizedTemplate;
         *   class MySubClass extends MySuperClass {
         *     static get template() {
         *       if (!memoizedTemplate) {
         *         memoizedTemplate = super.template.cloneNode(true);
         *         let subContent = document.createElement('div');
         *         subContent.textContent = 'This came from MySubClass';
         *         memoizedTemplate.content.appendChild(subContent);
         *       }
         *       return memoizedTemplate;
         *     }
         *   }
         *
         * @return {HTMLTemplateElement|string} Template to be stamped
         */

      }, {
        key: '_parseTemplateContent',
        value: function _parseTemplateContent(template, templateInfo, nodeInfo) {
          templateInfo.dynamicFns = templateInfo.dynamicFns || propertiesForClass(this);
          return _get(PolymerElement.__proto__ || Object.getPrototypeOf(PolymerElement), '_parseTemplateContent', this).call(this, template, templateInfo, nodeInfo);
        }
      }, {
        key: 'observedAttributes',


        /**
         * Standard Custom Elements V1 API.  The default implementation returns
         * a list of dash-cased attributes based on a flattening of all properties
         * declared in `static get properties()` for this element and any
         * superclasses.
         *
         * @return {Array} Observed attribute list
         */
        get: function get() {
          if (!this.hasOwnProperty(JSCompiler_renameProperty('__observedAttributes', this))) {
            var list = [];
            var properties = propertiesForClass(this);
            for (var prop in properties) {
              list.push(Polymer.CaseMap.camelToDashCase(prop));
            }
            this.__observedAttributes = list;
          }
          return this.__observedAttributes;
        }
      }, {
        key: 'template',
        get: function get() {
          if (!this.hasOwnProperty(JSCompiler_renameProperty('_template', this))) {
            this._template = Polymer.DomModule && Polymer.DomModule.import(
            /** @type PolymerElementConstructor*/this.is, 'template') ||
            // note: implemented so a subclass can retrieve the super
            // template; call the super impl this way so that `this` points
            // to the superclass.
            Object.getPrototypeOf( /** @type PolymerElementConstructor*/this.prototype).constructor.template;
          }
          return this._template;
        }

        /**
         * Path matching the url from which the element was imported.
         * This path is used to resolve url's in template style cssText.
         * The `importPath` property is also set on element instances and can be
         * used to create bindings relative to the import path.
         * Defaults to the path matching the url containing a `dom-module` element
         * matching this element's static `is` property.
         * Note, this path should contain a trailing `/`.
         *
         * @return {string} The import path for this element class
         */

      }, {
        key: 'importPath',
        get: function get() {
          if (!this.hasOwnProperty(JSCompiler_renameProperty('_importPath', this))) {
            var module = Polymer.DomModule && Polymer.DomModule.import( /** @type PolymerElementConstructor */this.is);
            this._importPath = module ? module.assetpath : '' || Object.getPrototypeOf( /** @type PolymerElementConstructor*/this.prototype).constructor.importPath;
          }
          return this._importPath;
        }
      }]);

      return PolymerElement;
    }(polymerElementBase);

    return PolymerElement;
  });

  /**
   * Provides basic tracking of element definitions (registrations) and
   * instance counts.
   *
   * @namespace
   * @summary Provides basic tracking of element definitions (registrations) and
   * instance counts.
   */
  Polymer.telemetry = {
    /**
     * Total number of Polymer element instances created.
     * @type {number}
     */
    instanceCount: 0,
    /**
     * Array of Polymer element classes that have been finalized.
     * @type {Array<Polymer.Element>}
     */
    registrations: [],
    /**
     * @param {!PolymerElementConstructor} prototype Element prototype to log
     * @this {this}
     * @private
     */
    _regLog: function _regLog(prototype) {
      console.log('[' + prototype.is + ']: registered');
    },
    /**
     * Registers a class prototype for telemetry purposes.
     * @param {HTMLElement} prototype Element prototype to register
     * @this {this}
     * @protected
     */
    register: function register(prototype) {
      this.registrations.push(prototype);
      Polymer.log && this._regLog(prototype);
    },
    /**
     * Logs all elements registered with an `is` to the console.
     * @public
     * @this {this}
     */
    dumpRegistrations: function dumpRegistrations() {
      this.registrations.forEach(this._regLog);
    }
  };

  /**
   * When using the ShadyCSS scoping and custom property shim, causes all
   * shimmed `styles` (via `custom-style`) in the document (and its subtree)
   * to be updated based on current custom property values.
   *
   * The optional parameter overrides inline custom property styles with an
   * object of properties where the keys are CSS properties, and the values
   * are strings.
   *
   * Example: `Polymer.updateStyles({'--color': 'blue'})`
   *
   * These properties are retained unless a value of `null` is set.
   *
   * @param {Object=} props Bag of custom property key/values to
   *   apply to the document.
   */
  Polymer.updateStyles = function (props) {
    if (window.ShadyCSS) {
      window.ShadyCSS.styleDocument(props);
    }
  };
})();

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(1);

__webpack_require__(7);

/** @suppress {deprecated} */
(function () {
  'use strict';

  /**
   * Legacy settings.
   * @namespace
   * @memberof Polymer
   */

  var settings = Polymer.Settings || {};
  settings.useShadow = !window.ShadyDOM;
  settings.useNativeCSSProperties = Boolean(!window.ShadyCSS || window.ShadyCSS.nativeCss);
  settings.useNativeCustomElements = !window.customElements.polyfillWrapFlushCallback;

  /**
   * Sets the global, legacy settings.
   *
   * @deprecated
   * @memberof Polymer
   */
  Polymer.Settings = settings;

  /**
   * Globally settable property that is automatically assigned to
   * `Polymer.ElementMixin` instances, useful for binding in templates to
   * make URL's relative to an application's root.  Defaults to the main
   * document URL, but can be overridden by users.  It may be useful to set
   * `Polymer.rootPath` to provide a stable application mount path when
   * using client side routing.
   *
   * @memberof Polymer
   */
  var rootPath = Polymer.rootPath || Polymer.ResolveUrl.pathFromUrl(document.baseURI || window.location.href);

  Polymer.rootPath = rootPath;

  /**
   * Sets the global rootPath property used by `Polymer.ElementMixin` and
   * available via `Polymer.rootPath`.
   *
   * @memberof Polymer
   * @param {string} path The new root path
   */
  Polymer.setRootPath = function (path) {
    Polymer.rootPath = path;
  };
})();

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(7);

(function () {
  'use strict';

  var MODULE_STYLE_LINK_SELECTOR = 'link[rel=import][type~=css]';
  var INCLUDE_ATTR = 'include';

  function importModule(moduleId) {
    if (!Polymer.DomModule) {
      return null;
    }
    return Polymer.DomModule.import(moduleId);
  }

  /** @typedef {{assetpath: string}} */
  var templateWithAssetPath = void 0; // eslint-disable-line no-unused-vars

  /**
   * Module with utilities for collection CSS text from `<templates>`, external
   * stylesheets, and `dom-module`s.
   *
   * @namespace
   * @memberof Polymer
   * @summary Module with utilities for collection CSS text from various sources.
   */
  var StyleGather = {

    /**
     * Returns CSS text of styles in a space-separated list of `dom-module`s.
     *
     * @memberof Polymer.StyleGather
     * @param {string} moduleIds List of dom-module id's within which to
     * search for css.
     * @return {string} Concatenated CSS content from specified `dom-module`s
     * @this {StyleGather}
     */
    cssFromModules: function cssFromModules(moduleIds) {
      var modules = moduleIds.trim().split(' ');
      var cssText = '';
      for (var i = 0; i < modules.length; i++) {
        cssText += this.cssFromModule(modules[i]);
      }
      return cssText;
    },


    /**
     * Returns CSS text of styles in a given `dom-module`.  CSS in a `dom-module`
     * can come either from `<style>`s within the first `<template>`, or else
     * from one or more `<link rel="import" type="css">` links outside the
     * template.
     *
     * Any `<styles>` processed are removed from their original location.
     *
     * @memberof Polymer.StyleGather
     * @param {string} moduleId dom-module id to gather styles from
     * @return {string} Concatenated CSS content from specified `dom-module`
     * @this {StyleGather}
     */
    cssFromModule: function cssFromModule(moduleId) {
      var m = importModule(moduleId);
      if (m && m._cssText === undefined) {
        var cssText = '';
        // include css from the first template in the module
        var t = m.querySelector('template');
        if (t) {
          cssText += this.cssFromTemplate(t, /** @type {templateWithAssetPath }*/m.assetpath);
        }
        // module imports: <link rel="import" type="css">
        cssText += this.cssFromModuleImports(moduleId);
        m._cssText = cssText || null;
      }
      if (!m) {
        console.warn('Could not find style data in module named', moduleId);
      }
      return m && m._cssText || '';
    },


    /**
     * Returns CSS text of `<styles>` within a given template.
     *
     * Any `<styles>` processed are removed from their original location.
     *
     * @memberof Polymer.StyleGather
     * @param {HTMLTemplateElement} template Template to gather styles from
     * @param {string} baseURI Base URI to resolve the URL against
     * @return {string} Concatenated CSS content from specified template
     * @this {StyleGather}
     */
    cssFromTemplate: function cssFromTemplate(template, baseURI) {
      var cssText = '';
      // if element is a template, get content from its .content
      var e$ = template.content.querySelectorAll('style');
      for (var i = 0; i < e$.length; i++) {
        var e = e$[i];
        // support style sharing by allowing styles to "include"
        // other dom-modules that contain styling
        var include = e.getAttribute(INCLUDE_ATTR);
        if (include) {
          cssText += this.cssFromModules(include);
        }
        e.parentNode.removeChild(e);
        cssText += baseURI ? Polymer.ResolveUrl.resolveCss(e.textContent, baseURI) : e.textContent;
      }
      return cssText;
    },


    /**
     * Returns CSS text from stylsheets loaded via `<link rel="import" type="css">`
     * links within the specified `dom-module`.
     *
     * @memberof Polymer.StyleGather
     * @param {string} moduleId Id of `dom-module` to gather CSS from
     * @return {string} Concatenated CSS content from links in specified `dom-module`
     * @this {StyleGather}
     */
    cssFromModuleImports: function cssFromModuleImports(moduleId) {
      var cssText = '';
      var m = importModule(moduleId);
      if (!m) {
        return cssText;
      }
      var p$ = m.querySelectorAll(MODULE_STYLE_LINK_SELECTOR);
      for (var i = 0; i < p$.length; i++) {
        var p = p$[i];
        if (p.import) {
          var importDoc = p.import;
          // NOTE: polyfill affordance.
          // under the HTMLImports polyfill, there will be no 'body',
          // but the import pseudo-doc can be used directly.
          var container = importDoc.body ? importDoc.body : importDoc;
          cssText += Polymer.ResolveUrl.resolveCss(container.textContent, importDoc.baseURI);
        }
      }
      return cssText;
    }
  };

  Polymer.StyleGather = StyleGather;
})();

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

__webpack_require__(45);

__webpack_require__(19);

__webpack_require__(23);

__webpack_require__(3);

__webpack_require__(48);

__webpack_require__(49);

__webpack_require__(50);

__webpack_require__(51);

(function () {

  'use strict';

  var styleInterface = window.ShadyCSS;

  /**
   * Element class mixin that provides Polymer's "legacy" API intended to be
   * backward-compatible to the greatest extent possible with the API
   * found on the Polymer 1.x `Polymer.Base` prototype applied to all elements
   * defined using the `Polymer({...})` function.
   *
   * @mixinFunction
   * @polymer
   * @appliesMixin Polymer.ElementMixin
   * @appliesMixin Polymer.GestureEventListeners
   * @property isAttached {boolean} Set to `true` in this element's
   *   `connectedCallback` and `false` in `disconnectedCallback`
   * @memberof Polymer
   * @summary Element class mixin that provides Polymer's "legacy" API
   */
  Polymer.LegacyElementMixin = Polymer.dedupingMixin(function (base) {

    /**
     * @constructor
     * @extends {base}
     * @implements {Polymer_ElementMixin}
     * @implements {Polymer_GestureEventListeners}
     */
    var legacyElementBase = Polymer.GestureEventListeners(Polymer.ElementMixin(base));

    /**
     * Map of simple names to touch action names
     * @dict
     */
    var DIRECTION_MAP = {
      'x': 'pan-x',
      'y': 'pan-y',
      'none': 'none',
      'all': 'auto'
    };

    /**
     * @polymer
     * @mixinClass
     * @extends {legacyElementBase}
     * @implements {Polymer_LegacyElementMixin}
     * @unrestricted
     */

    var LegacyElement = function (_legacyElementBase) {
      _inherits(LegacyElement, _legacyElementBase);

      function LegacyElement() {
        _classCallCheck(this, LegacyElement);

        var _this = _possibleConstructorReturn(this, (LegacyElement.__proto__ || Object.getPrototypeOf(LegacyElement)).call(this));

        _this.root = _this;
        _this.created();
        return _this;
      }

      /**
       * Legacy callback called during the `constructor`, for overriding
       * by the user.
       */


      _createClass(LegacyElement, [{
        key: 'created',
        value: function created() {}

        /**
         * Provides an implementation of `connectedCallback`
         * which adds Polymer legacy API's `attached` method.
         * @override
         */

      }, {
        key: 'connectedCallback',
        value: function connectedCallback() {
          _get(LegacyElement.prototype.__proto__ || Object.getPrototypeOf(LegacyElement.prototype), 'connectedCallback', this).call(this);
          this.isAttached = true;
          this.attached();
        }

        /**
         * Legacy callback called during `connectedCallback`, for overriding
         * by the user.
         */

      }, {
        key: 'attached',
        value: function attached() {}

        /**
         * Provides an implementation of `disconnectedCallback`
         * which adds Polymer legacy API's `detached` method.
         * @override
         */

      }, {
        key: 'disconnectedCallback',
        value: function disconnectedCallback() {
          _get(LegacyElement.prototype.__proto__ || Object.getPrototypeOf(LegacyElement.prototype), 'disconnectedCallback', this).call(this);
          this.isAttached = false;
          this.detached();
        }

        /**
         * Legacy callback called during `disconnectedCallback`, for overriding
         * by the user.
         */

      }, {
        key: 'detached',
        value: function detached() {}

        /**
         * Provides an override implementation of `attributeChangedCallback`
         * which adds the Polymer legacy API's `attributeChanged` method.
         * @param {string} name Name of attribute.
         * @param {?string} old Old value of attribute.
         * @param {?string} value Current value of attribute.
         * @override
         */

      }, {
        key: 'attributeChangedCallback',
        value: function attributeChangedCallback(name, old, value) {
          if (old !== value) {
            _get(LegacyElement.prototype.__proto__ || Object.getPrototypeOf(LegacyElement.prototype), 'attributeChangedCallback', this).call(this, name, old, value);
            this.attributeChanged(name, old, value);
          }
        }

        /**
         * Legacy callback called during `attributeChangedChallback`, for overriding
         * by the user.
         * @param {string} name Name of attribute.
         * @param {?string} old Old value of attribute.
         * @param {?string} value Current value of attribute.
         */

      }, {
        key: 'attributeChanged',
        value: function attributeChanged(name, old, value) {} // eslint-disable-line no-unused-vars

        /**
         * Overrides the default `Polymer.PropertyEffects` implementation to
         * add support for class initialization via the `_registered` callback.
         * This is called only when the first instance of the element is created.
         *
         * @override
         */

      }, {
        key: '_initializeProperties',
        value: function _initializeProperties() {
          var proto = Object.getPrototypeOf(this);
          if (!proto.hasOwnProperty('__hasRegisterFinished')) {
            proto.__hasRegisterFinished = true;
            this._registered();
          }
          _get(LegacyElement.prototype.__proto__ || Object.getPrototypeOf(LegacyElement.prototype), '_initializeProperties', this).call(this);
        }

        /**
         * Called automatically when an element is initializing.
         * Users may override this method to perform class registration time
         * work. The implementation should ensure the work is performed
         * only once for the class.
         * @protected
         */

      }, {
        key: '_registered',
        value: function _registered() {}

        /**
         * Overrides the default `Polymer.PropertyEffects` implementation to
         * add support for installing `hostAttributes` and `listeners`.
         *
         * @override
         */

      }, {
        key: 'ready',
        value: function ready() {
          this._ensureAttributes();
          this._applyListeners();
          _get(LegacyElement.prototype.__proto__ || Object.getPrototypeOf(LegacyElement.prototype), 'ready', this).call(this);
        }

        /**
         * Ensures an element has required attributes. Called when the element
         * is being readied via `ready`. Users should override to set the
         * element's required attributes. The implementation should be sure
         * to check and not override existing attributes added by
         * the user of the element. Typically, setting attributes should be left
         * to the element user and not done here; reasonable exceptions include
         * setting aria roles and focusability.
         * @protected
         */

      }, {
        key: '_ensureAttributes',
        value: function _ensureAttributes() {}

        /**
         * Adds element event listeners. Called when the element
         * is being readied via `ready`. Users should override to
         * add any required element event listeners.
         * In performance critical elements, the work done here should be kept
         * to a minimum since it is done before the element is rendered. In
         * these elements, consider adding listeners asychronously so as not to
         * block render.
         * @protected
         */

      }, {
        key: '_applyListeners',
        value: function _applyListeners() {}

        /**
         * Converts a typed JavaScript value to a string.
         *
         * Note this method is provided as backward-compatible legacy API
         * only.  It is not directly called by any Polymer features. To customize
         * how properties are serialized to attributes for attribute bindings and
         * `reflectToAttribute: true` properties as well as this method, override
         * the `_serializeValue` method provided by `Polymer.PropertyAccessors`.
         *
         * @param {*} value Value to deserialize
         * @return {string | undefined} Serialized value
         */

      }, {
        key: 'serialize',
        value: function serialize(value) {
          return this._serializeValue(value);
        }

        /**
         * Converts a string to a typed JavaScript value.
         *
         * Note this method is provided as backward-compatible legacy API
         * only.  It is not directly called by any Polymer features.  To customize
         * how attributes are deserialized to properties for in
         * `attributeChangedCallback`, override `_deserializeValue` method
         * provided by `Polymer.PropertyAccessors`.
         *
         * @param {string} value String to deserialize
         * @param {*} type Type to deserialize the string to
         * @return {*} Returns the deserialized value in the `type` given.
         */

      }, {
        key: 'deserialize',
        value: function deserialize(value, type) {
          return this._deserializeValue(value, type);
        }

        /**
         * Serializes a property to its associated attribute.
         *
         * Note this method is provided as backward-compatible legacy API
         * only.  It is not directly called by any Polymer features.
         *
         * @param {string} property Property name to reflect.
         * @param {string=} attribute Attribute name to reflect.
         * @param {*=} value Property value to refect.
         */

      }, {
        key: 'reflectPropertyToAttribute',
        value: function reflectPropertyToAttribute(property, attribute, value) {
          this._propertyToAttribute(property, attribute, value);
        }

        /**
         * Sets a typed value to an HTML attribute on a node.
         *
         * Note this method is provided as backward-compatible legacy API
         * only.  It is not directly called by any Polymer features.
         *
         * @param {*} value Value to serialize.
         * @param {string} attribute Attribute name to serialize to.
         * @param {Element} node Element to set attribute to.
         */

      }, {
        key: 'serializeValueToAttribute',
        value: function serializeValueToAttribute(value, attribute, node) {
          this._valueToNodeAttribute( /** @type {Element} */node || this, value, attribute);
        }

        /**
         * Copies own properties (including accessor descriptors) from a source
         * object to a target object.
         *
         * @param {Object} prototype Target object to copy properties to.
         * @param {Object} api Source object to copy properties from.
         * @return {Object} prototype object that was passed as first argument.
         */

      }, {
        key: 'extend',
        value: function extend(prototype, api) {
          if (!(prototype && api)) {
            return prototype || api;
          }
          var n$ = Object.getOwnPropertyNames(api);
          for (var i = 0, n; i < n$.length && (n = n$[i]); i++) {
            var pd = Object.getOwnPropertyDescriptor(api, n);
            if (pd) {
              Object.defineProperty(prototype, n, pd);
            }
          }
          return prototype;
        }

        /**
         * Copies props from a source object to a target object.
         *
         * Note, this method uses a simple `for...in` strategy for enumerating
         * properties.  To ensure only `ownProperties` are copied from source
         * to target and that accessor implementations are copied, use `extend`.
         *
         * @param {Object} target Target object to copy properties to.
         * @param {Object} source Source object to copy properties from.
         * @return {Object} Target object that was passed as first argument.
         */

      }, {
        key: 'mixin',
        value: function mixin(target, source) {
          for (var i in source) {
            target[i] = source[i];
          }
          return target;
        }

        /**
         * Sets the prototype of an object.
         *
         * Note this method is provided as backward-compatible legacy API
         * only.  It is not directly called by any Polymer features.
         * @param {Object} object The object on which to set the prototype.
         * @param {Object} prototype The prototype that will be set on the given
         * `object`.
         * @return {Object} Returns the given `object` with its prototype set
         * to the given `prototype` object.
         */

      }, {
        key: 'chainObject',
        value: function chainObject(object, prototype) {
          if (object && prototype && object !== prototype) {
            object.__proto__ = prototype;
          }
          return object;
        }

        /* **** Begin Template **** */

        /**
         * Calls `importNode` on the `content` of the `template` specified and
         * returns a document fragment containing the imported content.
         *
         * @param {HTMLTemplateElement} template HTML template element to instance.
         * @return {DocumentFragment} Document fragment containing the imported
         *   template content.
        */

      }, {
        key: 'instanceTemplate',
        value: function instanceTemplate(template) {
          var content = this.constructor._contentForTemplate(template);
          var dom = /** @type {DocumentFragment} */
          document.importNode(content, true);
          return dom;
        }

        /* **** Begin Events **** */

        /**
         * Dispatches a custom event with an optional detail value.
         *
         * @param {string} type Name of event type.
         * @param {*=} detail Detail value containing event-specific
         *   payload.
         * @param {{ bubbles: (boolean|undefined), cancelable: (boolean|undefined), composed: (boolean|undefined) }=}
         *  options Object specifying options.  These may include:
         *  `bubbles` (boolean, defaults to `true`),
         *  `cancelable` (boolean, defaults to false), and
         *  `node` on which to fire the event (HTMLElement, defaults to `this`).
         * @return {Event} The new event that was fired.
         */

      }, {
        key: 'fire',
        value: function fire(type, detail, options) {
          options = options || {};
          detail = detail === null || detail === undefined ? {} : detail;
          var event = new Event(type, {
            bubbles: options.bubbles === undefined ? true : options.bubbles,
            cancelable: Boolean(options.cancelable),
            composed: options.composed === undefined ? true : options.composed
          });
          event.detail = detail;
          var node = options.node || this;
          node.dispatchEvent(event);
          return event;
        }

        /**
         * Convenience method to add an event listener on a given element,
         * late bound to a named method on this element.
         *
         * @param {Element} node Element to add event listener to.
         * @param {string} eventName Name of event to listen for.
         * @param {string} methodName Name of handler method on `this` to call.
         */

      }, {
        key: 'listen',
        value: function listen(node, eventName, methodName) {
          node = /** @type {Element} */node || this;
          var hbl = this.__boundListeners || (this.__boundListeners = new WeakMap());
          var bl = hbl.get(node);
          if (!bl) {
            bl = {};
            hbl.set(node, bl);
          }
          var key = eventName + methodName;
          if (!bl[key]) {
            bl[key] = this._addMethodEventListenerToNode(node, eventName, methodName, this);
          }
        }

        /**
         * Convenience method to remove an event listener from a given element,
         * late bound to a named method on this element.
         *
         * @param {Element} node Element to remove event listener from.
         * @param {string} eventName Name of event to stop listening to.
         * @param {string} methodName Name of handler method on `this` to not call
         anymore.
         */

      }, {
        key: 'unlisten',
        value: function unlisten(node, eventName, methodName) {
          node = /** @type {Element} */node || this;
          var bl = this.__boundListeners && this.__boundListeners.get(node);
          var key = eventName + methodName;
          var handler = bl && bl[key];
          if (handler) {
            this._removeEventListenerFromNode(node, eventName, handler);
            bl[key] = null;
          }
        }

        /**
         * Override scrolling behavior to all direction, one direction, or none.
         *
         * Valid scroll directions:
         *   - 'all': scroll in any direction
         *   - 'x': scroll only in the 'x' direction
         *   - 'y': scroll only in the 'y' direction
         *   - 'none': disable scrolling for this node
         *
         * @param {string=} direction Direction to allow scrolling
         * Defaults to `all`.
         * @param {Element=} node Element to apply scroll direction setting.
         * Defaults to `this`.
         */

      }, {
        key: 'setScrollDirection',
        value: function setScrollDirection(direction, node) {
          Polymer.Gestures.setTouchAction( /** @type {Element} */node || this, DIRECTION_MAP[direction] || 'auto');
        }
        /* **** End Events **** */

        /**
         * Convenience method to run `querySelector` on this local DOM scope.
         *
         * This function calls `Polymer.dom(this.root).querySelector(slctr)`.
         *
         * @param {string} slctr Selector to run on this local DOM scope
         * @return {Element} Element found by the selector, or null if not found.
         */

      }, {
        key: '$$',
        value: function $$(slctr) {
          return this.root.querySelector(slctr);
        }

        /**
         * Return the element whose local dom within which this element
         * is contained. This is a shorthand for
         * `this.getRootNode().host`.
         * @this {Element}
         */

      }, {
        key: 'distributeContent',


        /**
         * Force this element to distribute its children to its local dom.
         * This should not be necessary as of Polymer 2.0.2 and is provided only
         * for backwards compatibility.
         */
        value: function distributeContent() {
          if (window.ShadyDOM && this.shadowRoot) {
            ShadyDOM.flush();
          }
        }

        /**
         * Returns a list of nodes that are the effective childNodes. The effective
         * childNodes list is the same as the element's childNodes except that
         * any `<content>` elements are replaced with the list of nodes distributed
         * to the `<content>`, the result of its `getDistributedNodes` method.
         * @this {Element}
         * @return {Array<Node>} List of effctive child nodes.
         */

      }, {
        key: 'getEffectiveChildNodes',
        value: function getEffectiveChildNodes() {
          return (/** @type {Polymer.DomApi} */Polymer.dom(this).getEffectiveChildNodes()
          );
        }

        /**
         * Returns a list of nodes distributed within this element that match
         * `selector`. These can be dom children or elements distributed to
         * children that are insertion points.
         * @param {string} selector Selector to run.
         * @this {Element}
         * @return {Array<Node>} List of distributed elements that match selector.
         */

      }, {
        key: 'queryDistributedElements',
        value: function queryDistributedElements(selector) {
          return (/** @type {Polymer.DomApi} */Polymer.dom(this).queryDistributedElements(selector)
          );
        }

        /**
         * Returns a list of elements that are the effective children. The effective
         * children list is the same as the element's children except that
         * any `<content>` elements are replaced with the list of elements
         * distributed to the `<content>`.
         *
         * @return {Array<Node>} List of effctive children.
         */

      }, {
        key: 'getEffectiveChildren',
        value: function getEffectiveChildren() {
          var list = this.getEffectiveChildNodes();
          return list.filter(function ( /** @type {Node} */n) {
            return n.nodeType === Node.ELEMENT_NODE;
          });
        }

        /**
         * Returns a string of text content that is the concatenation of the
         * text content's of the element's effective childNodes (the elements
         * returned by <a href="#getEffectiveChildNodes>getEffectiveChildNodes</a>.
         *
         * @return {string} List of effctive children.
         */

      }, {
        key: 'getEffectiveTextContent',
        value: function getEffectiveTextContent() {
          var cn = this.getEffectiveChildNodes();
          var tc = [];
          for (var i = 0, c; c = cn[i]; i++) {
            if (c.nodeType !== Node.COMMENT_NODE) {
              tc.push(c.textContent);
            }
          }
          return tc.join('');
        }

        /**
         * Returns the first effective childNode within this element that
         * match `selector`. These can be dom child nodes or elements distributed
         * to children that are insertion points.
         * @param {string} selector Selector to run.
         * @return {Object<Node>} First effective child node that matches selector.
         */

      }, {
        key: 'queryEffectiveChildren',
        value: function queryEffectiveChildren(selector) {
          var e$ = this.queryDistributedElements(selector);
          return e$ && e$[0];
        }

        /**
         * Returns a list of effective childNodes within this element that
         * match `selector`. These can be dom child nodes or elements distributed
         * to children that are insertion points.
         * @param {string} selector Selector to run.
         * @return {Array<Node>} List of effective child nodes that match selector.
         */

      }, {
        key: 'queryAllEffectiveChildren',
        value: function queryAllEffectiveChildren(selector) {
          return this.queryDistributedElements(selector);
        }

        /**
         * Returns a list of nodes distributed to this element's `<slot>`.
         *
         * If this element contains more than one `<slot>` in its local DOM,
         * an optional selector may be passed to choose the desired content.
         *
         * @param {string=} slctr CSS selector to choose the desired
         *   `<slot>`.  Defaults to `content`.
         * @return {Array<Node>} List of distributed nodes for the `<slot>`.
         */

      }, {
        key: 'getContentChildNodes',
        value: function getContentChildNodes(slctr) {
          var content = this.root.querySelector(slctr || 'slot');
          return content ? /** @type {Polymer.DomApi} */Polymer.dom(content).getDistributedNodes() : [];
        }

        /**
         * Returns a list of element children distributed to this element's
         * `<slot>`.
         *
         * If this element contains more than one `<slot>` in its
         * local DOM, an optional selector may be passed to choose the desired
         * content.  This method differs from `getContentChildNodes` in that only
         * elements are returned.
         *
         * @param {string=} slctr CSS selector to choose the desired
         *   `<content>`.  Defaults to `content`.
         * @return {Array<HTMLElement>} List of distributed nodes for the
         *   `<slot>`.
         * @suppress {invalidCasts}
         */

      }, {
        key: 'getContentChildren',
        value: function getContentChildren(slctr) {
          return (/** @type {Array<HTMLElement>} */this.getContentChildNodes(slctr).filter(function (n) {
              return n.nodeType === Node.ELEMENT_NODE;
            })
          );
        }

        /**
         * Checks whether an element is in this element's light DOM tree.
         *
         * @param {?Node} node The element to be checked.
         * @this {Element}
         * @return {boolean} true if node is in this element's light DOM tree.
         */

      }, {
        key: 'isLightDescendant',
        value: function isLightDescendant(node) {
          return this !== node && this.contains(node) && this.getRootNode() === node.getRootNode();
        }

        /**
         * Checks whether an element is in this element's local DOM tree.
         *
         * @param {Element=} node The element to be checked.
         * @return {boolean} true if node is in this element's local DOM tree.
         */

      }, {
        key: 'isLocalDescendant',
        value: function isLocalDescendant(node) {
          return this.root === node.getRootNode();
        }

        // NOTE: should now be handled by ShadyCss library.

      }, {
        key: 'scopeSubtree',
        value: function scopeSubtree(container, shouldObserve) {} // eslint-disable-line no-unused-vars


        /**
         * Returns the computed style value for the given property.
         * @param {string} property The css property name.
         * @return {string} Returns the computed css property value for the given
         * `property`.
         */

      }, {
        key: 'getComputedStyleValue',
        value: function getComputedStyleValue(property) {
          return styleInterface.getComputedStyleValue(this, property);
        }

        // debounce

        /**
         * Call `debounce` to collapse multiple requests for a named task into
         * one invocation which is made after the wait time has elapsed with
         * no new request.  If no wait time is given, the callback will be called
         * at microtask timing (guaranteed before paint).
         *
         *     debouncedClickAction(e) {
         *       // will not call `processClick` more than once per 100ms
         *       this.debounce('click', function() {
         *        this.processClick();
         *       } 100);
         *     }
         *
         * @param {string} jobName String to indentify the debounce job.
         * @param {function()} callback Function that is called (with `this`
         *   context) when the wait time elapses.
         * @param {number} wait Optional wait time in milliseconds (ms) after the
         *   last signal that must elapse before invoking `callback`
         * @return {Object} Returns a debouncer object on which exists the
         * following methods: `isActive()` returns true if the debouncer is
         * active; `cancel()` cancels the debouncer if it is active;
         * `flush()` immediately invokes the debounced callback if the debouncer
         * is active.
         */

      }, {
        key: 'debounce',
        value: function debounce(jobName, callback, wait) {
          this._debouncers = this._debouncers || {};
          return this._debouncers[jobName] = Polymer.Debouncer.debounce(this._debouncers[jobName], wait > 0 ? Polymer.Async.timeOut.after(wait) : Polymer.Async.microTask, callback.bind(this));
        }

        /**
         * Returns whether a named debouncer is active.
         *
         * @param {string} jobName The name of the debouncer started with `debounce`
         * @return {boolean} Whether the debouncer is active (has not yet fired).
         */

      }, {
        key: 'isDebouncerActive',
        value: function isDebouncerActive(jobName) {
          this._debouncers = this._debouncers || {};
          var debouncer = this._debouncers[jobName];
          return !!(debouncer && debouncer.isActive());
        }

        /**
         * Immediately calls the debouncer `callback` and inactivates it.
         *
         * @param {string} jobName The name of the debouncer started with `debounce`
         */

      }, {
        key: 'flushDebouncer',
        value: function flushDebouncer(jobName) {
          this._debouncers = this._debouncers || {};
          var debouncer = this._debouncers[jobName];
          if (debouncer) {
            debouncer.flush();
          }
        }

        /**
         * Cancels an active debouncer.  The `callback` will not be called.
         *
         * @param {string} jobName The name of the debouncer started with `debounce`
         */

      }, {
        key: 'cancelDebouncer',
        value: function cancelDebouncer(jobName) {
          this._debouncers = this._debouncers || {};
          var debouncer = this._debouncers[jobName];
          if (debouncer) {
            debouncer.cancel();
          }
        }

        /**
         * Runs a callback function asyncronously.
         *
         * By default (if no waitTime is specified), async callbacks are run at
         * microtask timing, which will occur before paint.
         *
         * @param {Function} callback The callback function to run, bound to `this`.
         * @param {number=} waitTime Time to wait before calling the
         *   `callback`.  If unspecified or 0, the callback will be run at microtask
         *   timing (before paint).
         * @return {number} Handle that may be used to cancel the async job.
         */

      }, {
        key: 'async',
        value: function async(callback, waitTime) {
          return waitTime > 0 ? Polymer.Async.timeOut.run(callback.bind(this), waitTime) : ~Polymer.Async.microTask.run(callback.bind(this));
        }

        /**
         * Cancels an async operation started with `async`.
         *
         * @param {number} handle Handle returned from original `async` call to
         *   cancel.
         */

      }, {
        key: 'cancelAsync',
        value: function cancelAsync(handle) {
          handle < 0 ? Polymer.Async.microTask.cancel(~handle) : Polymer.Async.timeOut.cancel(handle);
        }

        // other

        /**
         * Convenience method for creating an element and configuring it.
         *
         * @param {string} tag HTML element tag to create.
         * @param {Object} props Object of properties to configure on the
         *    instance.
         * @return {Element} Newly created and configured element.
         */

      }, {
        key: 'create',
        value: function create(tag, props) {
          var elt = document.createElement(tag);
          if (props) {
            if (elt.setProperties) {
              elt.setProperties(props);
            } else {
              for (var n in props) {
                elt[n] = props[n];
              }
            }
          }
          return elt;
        }

        /**
         * Convenience method for importing an HTML document imperatively.
         *
         * This method creates a new `<link rel="import">` element with
         * the provided URL and appends it to the document to start loading.
         * In the `onload` callback, the `import` property of the `link`
         * element will contain the imported document contents.
         *
         * @param {string} href URL to document to load.
         * @param {Function} onload Callback to notify when an import successfully
         *   loaded.
         * @param {Function} onerror Callback to notify when an import
         *   unsuccessfully loaded.
         * @param {boolean} optAsync True if the import should be loaded `async`.
         *   Defaults to `false`.
         * @return {HTMLLinkElement} The link element for the URL to be loaded.
         */

      }, {
        key: 'importHref',
        value: function importHref(href, onload, onerror, optAsync) {
          // eslint-disable-line no-unused-vars
          var loadFn = onload ? onload.bind(this) : null;
          var errorFn = onerror ? onerror.bind(this) : null;
          return Polymer.importHref(href, loadFn, errorFn, optAsync);
        }

        /**
         * Polyfill for Element.prototype.matches, which is sometimes still
         * prefixed.
         *
         * @param {string} selector Selector to test.
         * @param {Element=} node Element to test the selector against.
         * @return {boolean} Whether the element matches the selector.
         */

      }, {
        key: 'elementMatches',
        value: function elementMatches(selector, node) {
          return Polymer.dom.matchesSelector( /** @type {!Element} */node || this, selector);
        }

        /**
         * Toggles an HTML attribute on or off.
         *
         * @param {string} name HTML attribute name
         * @param {boolean=} bool Boolean to force the attribute on or off.
         *    When unspecified, the state of the attribute will be reversed.
         * @param {Element=} node Node to target.  Defaults to `this`.
         */

      }, {
        key: 'toggleAttribute',
        value: function toggleAttribute(name, bool, node) {
          node = /** @type {Element} */node || this;
          if (arguments.length == 1) {
            bool = !node.hasAttribute(name);
          }
          if (bool) {
            node.setAttribute(name, '');
          } else {
            node.removeAttribute(name);
          }
        }

        /**
         * Toggles a CSS class on or off.
         *
         * @param {string} name CSS class name
         * @param {boolean=} bool Boolean to force the class on or off.
         *    When unspecified, the state of the class will be reversed.
         * @param {Element=} node Node to target.  Defaults to `this`.
         */

      }, {
        key: 'toggleClass',
        value: function toggleClass(name, bool, node) {
          node = /** @type {Element} */node || this;
          if (arguments.length == 1) {
            bool = !node.classList.contains(name);
          }
          if (bool) {
            node.classList.add(name);
          } else {
            node.classList.remove(name);
          }
        }

        /**
         * Cross-platform helper for setting an element's CSS `transform` property.
         *
         * @param {string} transformText Transform setting.
         * @param {Element=} node Element to apply the transform to.
         * Defaults to `this`
         */

      }, {
        key: 'transform',
        value: function transform(transformText, node) {
          node = /** @type {Element} */node || this;
          node.style.webkitTransform = transformText;
          node.style.transform = transformText;
        }

        /**
         * Cross-platform helper for setting an element's CSS `translate3d`
         * property.
         *
         * @param {number} x X offset.
         * @param {number} y Y offset.
         * @param {number} z Z offset.
         * @param {Element=} node Element to apply the transform to.
         * Defaults to `this`.
         */

      }, {
        key: 'translate3d',
        value: function translate3d(x, y, z, node) {
          node = /** @type {Element} */node || this;
          this.transform('translate3d(' + x + ',' + y + ',' + z + ')', node);
        }

        /**
         * Removes an item from an array, if it exists.
         *
         * If the array is specified by path, a change notification is
         * generated, so that observers, data bindings and computed
         * properties watching that path can update.
         *
         * If the array is passed directly, **no change
         * notification is generated**.
         *
         * @param {string | !Array<number|string>} arrayOrPath Path to array from which to remove the item
         *   (or the array itself).
         * @param {*} item Item to remove.
         * @return {Array} Array containing item removed.
         */

      }, {
        key: 'arrayDelete',
        value: function arrayDelete(arrayOrPath, item) {
          var index = void 0;
          if (Array.isArray(arrayOrPath)) {
            index = arrayOrPath.indexOf(item);
            if (index >= 0) {
              return arrayOrPath.splice(index, 1);
            }
          } else {
            var arr = Polymer.Path.get(this, arrayOrPath);
            index = arr.indexOf(item);
            if (index >= 0) {
              return this.splice(arrayOrPath, index, 1);
            }
          }
          return null;
        }

        // logging

        /**
         * Facades `console.log`/`warn`/`error` as override point.
         *
         * @param {string} level One of 'log', 'warn', 'error'
         * @param {Array} args Array of strings or objects to log
         */

      }, {
        key: '_logger',
        value: function _logger(level, args) {
          var _console;

          // accept ['foo', 'bar'] and [['foo', 'bar']]
          if (Array.isArray(args) && args.length === 1) {
            args = args[0];
          }
          switch (level) {
            case 'log':
            case 'warn':
            case 'error':
              (_console = console)[level].apply(_console, _toConsumableArray(args));
          }
        }

        /**
         * Facades `console.log` as an override point.
         *
         * @param {...*} args Array of strings or objects to log
         */

      }, {
        key: '_log',
        value: function _log() {
          for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          this._logger('log', args);
        }

        /**
         * Facades `console.warn` as an override point.
         *
         * @param {...*} args Array of strings or objects to log
         */

      }, {
        key: '_warn',
        value: function _warn() {
          for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }

          this._logger('warn', args);
        }

        /**
         * Facades `console.error` as an override point.
         *
         * @param {...*} args Array of strings or objects to log
         */

      }, {
        key: '_error',
        value: function _error() {
          for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
            args[_key3] = arguments[_key3];
          }

          this._logger('error', args);
        }

        /**
         * Formats a message using the element type an a method name.
         *
         * @param {string} methodName Method name to associate with message
         * @param {...*} args Array of strings or objects to log
         * @return {Array} Array with formatting information for `console`
         *   logging.
         */

      }, {
        key: '_logf',
        value: function _logf(methodName) {
          for (var _len4 = arguments.length, args = Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
            args[_key4 - 1] = arguments[_key4];
          }

          return ['[%s::%s]', this.is, methodName].concat(args);
        }
      }, {
        key: 'domHost',
        get: function get() {
          var root = this.getRootNode();
          return root instanceof DocumentFragment ? /** @type {ShadowRoot} */root.host : root;
        }
      }]);

      return LegacyElement;
    }(legacyElementBase);

    LegacyElement.prototype.is = '';

    return LegacyElement;
  });
})();

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

__webpack_require__(1);

__webpack_require__(3);

__webpack_require__(47);

(function () {

  'use strict';

  /**
   * @const {Polymer.Gestures}
   */

  var gestures = Polymer.Gestures;

  /**
   * Element class mixin that provides API for adding Polymer's cross-platform
   * gesture events to nodes.
   *
   * The API is designed to be compatible with override points implemented
   * in `Polymer.TemplateStamp` such that declarative event listeners in
   * templates will support gesture events when this mixin is applied along with
   * `Polymer.TemplateStamp`.
   *
   * @mixinFunction
   * @polymer
   * @memberof Polymer
   * @summary Element class mixin that provides API for adding Polymer's cross-platform
   * gesture events to nodes
   */
  Polymer.GestureEventListeners = Polymer.dedupingMixin(function (superClass) {

    /**
     * @polymer
     * @mixinClass
     * @implements {Polymer_GestureEventListeners}
     */
    var GestureEventListeners = function (_superClass) {
      _inherits(GestureEventListeners, _superClass);

      function GestureEventListeners() {
        _classCallCheck(this, GestureEventListeners);

        return _possibleConstructorReturn(this, (GestureEventListeners.__proto__ || Object.getPrototypeOf(GestureEventListeners)).apply(this, arguments));
      }

      _createClass(GestureEventListeners, [{
        key: '_addEventListenerToNode',
        value: function _addEventListenerToNode(node, eventName, handler) {
          if (!gestures.addListener(node, eventName, handler)) {
            _get(GestureEventListeners.prototype.__proto__ || Object.getPrototypeOf(GestureEventListeners.prototype), '_addEventListenerToNode', this).call(this, node, eventName, handler);
          }
        }
      }, {
        key: '_removeEventListenerFromNode',
        value: function _removeEventListenerFromNode(node, eventName, handler) {
          if (!gestures.removeListener(node, eventName, handler)) {
            _get(GestureEventListeners.prototype.__proto__ || Object.getPrototypeOf(GestureEventListeners.prototype), '_removeEventListenerFromNode', this).call(this, node, eventName, handler);
          }
        }
      }]);

      return GestureEventListeners;
    }(superClass);

    return GestureEventListeners;
  });
})();

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(1);

(function () {

  'use strict';

  function newSplice(index, removed, addedCount) {
    return {
      index: index,
      removed: removed,
      addedCount: addedCount
    };
  }

  var EDIT_LEAVE = 0;
  var EDIT_UPDATE = 1;
  var EDIT_ADD = 2;
  var EDIT_DELETE = 3;

  // Note: This function is *based* on the computation of the Levenshtein
  // "edit" distance. The one change is that "updates" are treated as two
  // edits - not one. With Array splices, an update is really a delete
  // followed by an add. By retaining this, we optimize for "keeping" the
  // maximum array items in the original array. For example:
  //
  //   'xxxx123' -> '123yyyy'
  //
  // With 1-edit updates, the shortest path would be just to update all seven
  // characters. With 2-edit updates, we delete 4, leave 3, and add 4. This
  // leaves the substring '123' intact.
  function calcEditDistances(current, currentStart, currentEnd, old, oldStart, oldEnd) {
    // "Deletion" columns
    var rowCount = oldEnd - oldStart + 1;
    var columnCount = currentEnd - currentStart + 1;
    var distances = new Array(rowCount);

    // "Addition" rows. Initialize null column.
    for (var i = 0; i < rowCount; i++) {
      distances[i] = new Array(columnCount);
      distances[i][0] = i;
    }

    // Initialize null row
    for (var j = 0; j < columnCount; j++) {
      distances[0][j] = j;
    }for (var _i = 1; _i < rowCount; _i++) {
      for (var _j = 1; _j < columnCount; _j++) {
        if (equals(current[currentStart + _j - 1], old[oldStart + _i - 1])) distances[_i][_j] = distances[_i - 1][_j - 1];else {
          var north = distances[_i - 1][_j] + 1;
          var west = distances[_i][_j - 1] + 1;
          distances[_i][_j] = north < west ? north : west;
        }
      }
    }

    return distances;
  }

  // This starts at the final weight, and walks "backward" by finding
  // the minimum previous weight recursively until the origin of the weight
  // matrix.
  function spliceOperationsFromEditDistances(distances) {
    var i = distances.length - 1;
    var j = distances[0].length - 1;
    var current = distances[i][j];
    var edits = [];
    while (i > 0 || j > 0) {
      if (i == 0) {
        edits.push(EDIT_ADD);
        j--;
        continue;
      }
      if (j == 0) {
        edits.push(EDIT_DELETE);
        i--;
        continue;
      }
      var northWest = distances[i - 1][j - 1];
      var west = distances[i - 1][j];
      var north = distances[i][j - 1];

      var min = void 0;
      if (west < north) min = west < northWest ? west : northWest;else min = north < northWest ? north : northWest;

      if (min == northWest) {
        if (northWest == current) {
          edits.push(EDIT_LEAVE);
        } else {
          edits.push(EDIT_UPDATE);
          current = northWest;
        }
        i--;
        j--;
      } else if (min == west) {
        edits.push(EDIT_DELETE);
        i--;
        current = west;
      } else {
        edits.push(EDIT_ADD);
        j--;
        current = north;
      }
    }

    edits.reverse();
    return edits;
  }

  /**
   * Splice Projection functions:
   *
   * A splice map is a representation of how a previous array of items
   * was transformed into a new array of items. Conceptually it is a list of
   * tuples of
   *
   *   <index, removed, addedCount>
   *
   * which are kept in ascending index order of. The tuple represents that at
   * the |index|, |removed| sequence of items were removed, and counting forward
   * from |index|, |addedCount| items were added.
   */

  /**
   * Lacking individual splice mutation information, the minimal set of
   * splices can be synthesized given the previous state and final state of an
   * array. The basic approach is to calculate the edit distance matrix and
   * choose the shortest path through it.
   *
   * Complexity: O(l * p)
   *   l: The length of the current array
   *   p: The length of the old array
   *
   * @param {Array} current The current "changed" array for which to
   * calculate splices.
   * @param {number} currentStart Starting index in the `current` array for
   * which splices are calculated.
   * @param {number} currentEnd Ending index in the `current` array for
   * which splices are calculated.
   * @param {Array} old The original "unchanged" array to compare `current`
   * against to determine splices.
   * @param {number} oldStart Starting index in the `old` array for
   * which splices are calculated.
   * @param {number} oldEnd Ending index in the `old` array for
   * which splices are calculated.
   * @return {Array} Returns an array of splice record objects. Each of these
   * contains: `index` the location where the splice occurred; `removed`
   * the array of removed items from this location; `addedCount` the number
   * of items added at this location.
   */
  function calcSplices(current, currentStart, currentEnd, old, oldStart, oldEnd) {
    var prefixCount = 0;
    var suffixCount = 0;
    var splice = void 0;

    var minLength = Math.min(currentEnd - currentStart, oldEnd - oldStart);
    if (currentStart == 0 && oldStart == 0) prefixCount = sharedPrefix(current, old, minLength);

    if (currentEnd == current.length && oldEnd == old.length) suffixCount = sharedSuffix(current, old, minLength - prefixCount);

    currentStart += prefixCount;
    oldStart += prefixCount;
    currentEnd -= suffixCount;
    oldEnd -= suffixCount;

    if (currentEnd - currentStart == 0 && oldEnd - oldStart == 0) return [];

    if (currentStart == currentEnd) {
      splice = newSplice(currentStart, [], 0);
      while (oldStart < oldEnd) {
        splice.removed.push(old[oldStart++]);
      }return [splice];
    } else if (oldStart == oldEnd) return [newSplice(currentStart, [], currentEnd - currentStart)];

    var ops = spliceOperationsFromEditDistances(calcEditDistances(current, currentStart, currentEnd, old, oldStart, oldEnd));

    splice = undefined;
    var splices = [];
    var index = currentStart;
    var oldIndex = oldStart;
    for (var i = 0; i < ops.length; i++) {
      switch (ops[i]) {
        case EDIT_LEAVE:
          if (splice) {
            splices.push(splice);
            splice = undefined;
          }

          index++;
          oldIndex++;
          break;
        case EDIT_UPDATE:
          if (!splice) splice = newSplice(index, [], 0);

          splice.addedCount++;
          index++;

          splice.removed.push(old[oldIndex]);
          oldIndex++;
          break;
        case EDIT_ADD:
          if (!splice) splice = newSplice(index, [], 0);

          splice.addedCount++;
          index++;
          break;
        case EDIT_DELETE:
          if (!splice) splice = newSplice(index, [], 0);

          splice.removed.push(old[oldIndex]);
          oldIndex++;
          break;
      }
    }

    if (splice) {
      splices.push(splice);
    }
    return splices;
  }

  function sharedPrefix(current, old, searchLength) {
    for (var i = 0; i < searchLength; i++) {
      if (!equals(current[i], old[i])) return i;
    }return searchLength;
  }

  function sharedSuffix(current, old, searchLength) {
    var index1 = current.length;
    var index2 = old.length;
    var count = 0;
    while (count < searchLength && equals(current[--index1], old[--index2])) {
      count++;
    }return count;
  }

  function calculateSplices(current, previous) {
    return calcSplices(current, 0, current.length, previous, 0, previous.length);
  }

  function equals(currentValue, previousValue) {
    return currentValue === previousValue;
  }

  /**
   * @namespace
   * @memberof Polymer
   * @summary Module that provides utilities for diffing arrays.
   */
  Polymer.ArraySplice = {
    /**
     * Returns an array of splice records indicating the minimum edits required
     * to transform the `previous` array into the `current` array.
     *
     * Splice records are ordered by index and contain the following fields:
     * - `index`: index where edit started
     * - `removed`: array of removed items from this index
     * - `addedCount`: number of items added at this index
     *
     * This function is based on the Levenshtein "minimum edit distance"
     * algorithm. Note that updates are treated as removal followed by addition.
     *
     * The worst-case time complexity of this algorithm is `O(l * p)`
     *   l: The length of the current array
     *   p: The length of the previous array
     *
     * However, the worst-case complexity is reduced by an `O(n)` optimization
     * to detect any shared prefix & suffix between the two arrays and only
     * perform the more expensive minimum edit distance calculation over the
     * non-shared portions of the arrays.
     *
     * @memberof Polymer.ArraySplice
     * @param {Array} current The "changed" array for which splices will be
     * calculated.
     * @param {Array} previous The "unchanged" original array to compare
     * `current` against to determine the splices.
     * @return {Array} Returns an array of splice record objects. Each of these
     * contains: `index` the location where the splice occurred; `removed`
     * the array of removed items from this location; `addedCount` the number
     * of items added at this location.
     */
    calculateSplices: calculateSplices
  };
})();

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(4);

/**
 * While scrolling down, fade in the rear background layer and fade out the front background
 * layer (opacity interpolated based on scroll position).
 */
Polymer.AppLayout.registerEffect('blend-background', {
  /** @this Polymer.AppLayout.ElementWithBackground */
  setUp: function setUp() {
    var fx = {};
    fx.backgroundFrontLayer = this._getDOMRef('backgroundFrontLayer');
    fx.backgroundRearLayer = this._getDOMRef('backgroundRearLayer');
    fx.backgroundFrontLayer.style.willChange = 'opacity';
    fx.backgroundFrontLayer.style.transform = 'translateZ(0)';
    fx.backgroundRearLayer.style.willChange = 'opacity';
    fx.backgroundRearLayer.style.transform = 'translateZ(0)';
    fx.backgroundRearLayer.style.opacity = 0;
    this._fxBlendBackground = fx;
  },
  /** @this Polymer.AppLayout.ElementWithBackground */
  run: function run(p, y) {
    var fx = this._fxBlendBackground;
    fx.backgroundFrontLayer.style.opacity = 1 - p;
    fx.backgroundRearLayer.style.opacity = p;
  },
  /** @this Polymer.AppLayout.ElementWithBackground */
  tearDown: function tearDown() {
    delete this._fxBlendBackground;
  }
});

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(4);

/**
 * Toggles the shadow property in app-header when content is scrolled to create a sense of depth
 * between the element and the content underneath.
 */
Polymer.AppLayout.registerEffect('waterfall', {
  /**
   *  @this Polymer.AppLayout.ElementWithBackground
   */
  run: function run() {
    this.shadow = this.isOnScreen() && this.isContentBelow();
  }
});

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(4);

(function () {
  function interpolate(progress, points, fn, ctx) {
    fn.apply(ctx, points.map(function (point) {
      return point[0] + (point[1] - point[0]) * progress;
    }));
  }

  /**
   * Transform the font size of a designated title element between two values based on the scroll
   * position.
   */
  Polymer.AppLayout.registerEffect('resize-title', {
    /** @this Polymer.AppLayout.ElementWithBackground */
    setUp: function setUp() {
      var title = this._getDOMRef('mainTitle');
      var condensedTitle = this._getDOMRef('condensedTitle');

      if (!condensedTitle) {
        console.warn('Scroll effect `resize-title`: undefined `condensed-title`');
        return false;
      }
      if (!title) {
        console.warn('Scroll effect `resize-title`: undefined `main-title`');
        return false;
      }

      condensedTitle.style.willChange = 'opacity';
      condensedTitle.style.webkitTransform = 'translateZ(0)';
      condensedTitle.style.transform = 'translateZ(0)';
      condensedTitle.style.webkitTransformOrigin = 'left top';
      condensedTitle.style.transformOrigin = 'left top';

      title.style.willChange = 'opacity';
      title.style.webkitTransformOrigin = 'left top';
      title.style.transformOrigin = 'left top';
      title.style.webkitTransform = 'translateZ(0)';
      title.style.transform = 'translateZ(0)';

      var titleClientRect = title.getBoundingClientRect();
      var condensedTitleClientRect = condensedTitle.getBoundingClientRect();
      var fx = {};

      fx.scale = parseInt(window.getComputedStyle(condensedTitle)['font-size'], 10) / parseInt(window.getComputedStyle(title)['font-size'], 10);
      fx.titleDX = titleClientRect.left - condensedTitleClientRect.left;
      fx.titleDY = titleClientRect.top - condensedTitleClientRect.top;
      fx.condensedTitle = condensedTitle;
      fx.title = title;

      this._fxResizeTitle = fx;
    },
    /** @this PolymerElement */
    run: function run(p, y) {
      var fx = this._fxResizeTitle;
      if (!this.condenses) {
        y = 0;
      }
      if (p >= 1) {
        fx.title.style.opacity = 0;
        fx.condensedTitle.style.opacity = 1;
      } else {
        fx.title.style.opacity = 1;
        fx.condensedTitle.style.opacity = 0;
      }
      interpolate(Math.min(1, p), [[1, fx.scale], [0, -fx.titleDX], [y, y - fx.titleDY]], function (scale, translateX, translateY) {
        this.transform('translate(' + translateX + 'px, ' + translateY + 'px) ' + 'scale3d(' + scale + ', ' + scale + ', 1)', fx.title);
      }, this);
    },
    /** @this Polymer.AppLayout.ElementWithBackground */
    tearDown: function tearDown() {
      delete this._fxResizeTitle;
    }
  });
})();

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(4);

/**
 * Vertically translate the background based on a factor of the scroll position.
 */
Polymer.AppLayout.registerEffect('parallax-background', {
  /**
   * @param {{scalar: string}} config
   * @this Polymer.AppLayout.ElementWithBackground
   */
  setUp: function setUp(config) {
    var fx = {};
    var scalar = parseFloat(config.scalar);
    fx.background = this._getDOMRef('background');
    fx.backgroundFrontLayer = this._getDOMRef('backgroundFrontLayer');
    fx.backgroundRearLayer = this._getDOMRef('backgroundRearLayer');
    fx.deltaBg = fx.backgroundFrontLayer.offsetHeight - fx.background.offsetHeight;
    if (fx.deltaBg === 0) {
      if (isNaN(scalar)) {
        scalar = 0.8;
      }
      fx.deltaBg = this._dHeight * scalar;
    } else {
      if (isNaN(scalar)) {
        scalar = 1;
      }
      fx.deltaBg = fx.deltaBg * scalar;
    }
    this._fxParallaxBackground = fx;
  },
  /** @this Polymer.AppLayout.ElementWithBackground */
  run: function run(p, y) {
    var fx = this._fxParallaxBackground;
    this.transform('translate3d(0px, ' + fx.deltaBg * Math.min(1, p) + 'px, 0px)', fx.backgroundFrontLayer);
    if (fx.backgroundRearLayer) {
      this.transform('translate3d(0px, ' + fx.deltaBg * Math.min(1, p) + 'px, 0px)', fx.backgroundRearLayer);
    }
  },
  /** @this Polymer.AppLayout.ElementWithBackground */
  tearDown: function tearDown() {
    delete this._fxParallaxBackground;
  }
});

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

__webpack_require__(80);

/**
 * @polymerBehavior Polymer.IronSelectableBehavior
 */
Polymer.IronSelectableBehavior = {

  /**
   * Fired when iron-selector is activated (selected or deselected).
   * It is fired before the selected items are changed.
   * Cancel the event to abort selection.
   *
   * @event iron-activate
   */

  /**
   * Fired when an item is selected
   *
   * @event iron-select
   */

  /**
   * Fired when an item is deselected
   *
   * @event iron-deselect
   */

  /**
   * Fired when the list of selectable items changes (e.g., items are
   * added or removed). The detail of the event is a mutation record that
   * describes what changed.
   *
   * @event iron-items-changed
   */

  properties: {

    /**
     * If you want to use an attribute value or property of an element for
     * `selected` instead of the index, set this to the name of the attribute
     * or property. Hyphenated values are converted to camel case when used to
     * look up the property of a selectable element. Camel cased values are
     * *not* converted to hyphenated values for attribute lookup. It's
     * recommended that you provide the hyphenated form of the name so that
     * selection works in both cases. (Use `attr-or-property-name` instead of
     * `attrOrPropertyName`.)
     */
    attrForSelected: {
      type: String,
      value: null
    },

    /**
     * Gets or sets the selected element. The default is to use the index of the item.
     * @type {string|number}
     */
    selected: {
      type: String,
      notify: true
    },

    /**
     * Returns the currently selected item.
     *
     * @type {?Object}
     */
    selectedItem: {
      type: Object,
      readOnly: true,
      notify: true
    },

    /**
     * The event that fires from items when they are selected. Selectable
     * will listen for this event from items and update the selection state.
     * Set to empty string to listen to no events.
     */
    activateEvent: {
      type: String,
      value: 'tap',
      observer: '_activateEventChanged'
    },

    /**
     * This is a CSS selector string.  If this is set, only items that match the CSS selector
     * are selectable.
     */
    selectable: String,

    /**
     * The class to set on elements when selected.
     */
    selectedClass: {
      type: String,
      value: 'iron-selected'
    },

    /**
     * The attribute to set on elements when selected.
     */
    selectedAttribute: {
      type: String,
      value: null
    },

    /**
     * Default fallback if the selection based on selected with `attrForSelected`
     * is not found.
     */
    fallbackSelection: {
      type: String,
      value: null
    },

    /**
     * The list of items from which a selection can be made.
     */
    items: {
      type: Array,
      readOnly: true,
      notify: true,
      value: function value() {
        return [];
      }
    },

    /**
     * The set of excluded elements where the key is the `localName`
     * of the element that will be ignored from the item list.
     *
     * @default {template: 1}
     */
    _excludedLocalNames: {
      type: Object,
      value: function value() {
        return {
          'template': 1,
          'dom-bind': 1,
          'dom-if': 1,
          'dom-repeat': 1
        };
      }
    }
  },

  observers: ['_updateAttrForSelected(attrForSelected)', '_updateSelected(selected)', '_checkFallback(fallbackSelection)'],

  created: function created() {
    this._bindFilterItem = this._filterItem.bind(this);
    this._selection = new Polymer.IronSelection(this._applySelection.bind(this));
  },

  attached: function attached() {
    this._observer = this._observeItems(this);
    this._addListener(this.activateEvent);
  },

  detached: function detached() {
    if (this._observer) {
      Polymer.dom(this).unobserveNodes(this._observer);
    }
    this._removeListener(this.activateEvent);
  },

  /**
   * Returns the index of the given item.
   *
   * @method indexOf
   * @param {Object} item
   * @returns Returns the index of the item
   */
  indexOf: function indexOf(item) {
    return this.items.indexOf(item);
  },

  /**
   * Selects the given value.
   *
   * @method select
   * @param {string|number} value the value to select.
   */
  select: function select(value) {
    this.selected = value;
  },

  /**
   * Selects the previous item.
   *
   * @method selectPrevious
   */
  selectPrevious: function selectPrevious() {
    var length = this.items.length;
    var index = (Number(this._valueToIndex(this.selected)) - 1 + length) % length;
    this.selected = this._indexToValue(index);
  },

  /**
   * Selects the next item.
   *
   * @method selectNext
   */
  selectNext: function selectNext() {
    var index = (Number(this._valueToIndex(this.selected)) + 1) % this.items.length;
    this.selected = this._indexToValue(index);
  },

  /**
   * Selects the item at the given index.
   *
   * @method selectIndex
   */
  selectIndex: function selectIndex(index) {
    this.select(this._indexToValue(index));
  },

  /**
   * Force a synchronous update of the `items` property.
   *
   * NOTE: Consider listening for the `iron-items-changed` event to respond to
   * updates to the set of selectable items after updates to the DOM list and
   * selection state have been made.
   *
   * WARNING: If you are using this method, you should probably consider an
   * alternate approach. Synchronously querying for items is potentially
   * slow for many use cases. The `items` property will update asynchronously
   * on its own to reflect selectable items in the DOM.
   */
  forceSynchronousItemUpdate: function forceSynchronousItemUpdate() {
    if (this._observer && typeof this._observer.flush === "function") {
      // NOTE(bicknellr): `Polymer.dom.flush` above is no longer sufficient to
      // trigger `observeNodes` callbacks. Polymer 2.x returns an object from
      // `observeNodes` with a `flush` that synchronously gives the callback
      // any pending MutationRecords (retrieved with `takeRecords`). Any case
      // where ShadyDOM flushes were expected to synchronously trigger item
      // updates will now require calling `forceSynchronousItemUpdate`.
      this._observer.flush();
    } else {
      this._updateItems();
    }
  },

  // UNUSED, FOR API COMPATIBILITY
  get _shouldUpdateSelection() {
    return this.selected != null;
  },

  _checkFallback: function _checkFallback() {
    this._updateSelected();
  },

  _addListener: function _addListener(eventName) {
    this.listen(this, eventName, '_activateHandler');
  },

  _removeListener: function _removeListener(eventName) {
    this.unlisten(this, eventName, '_activateHandler');
  },

  _activateEventChanged: function _activateEventChanged(eventName, old) {
    this._removeListener(old);
    this._addListener(eventName);
  },

  _updateItems: function _updateItems() {
    var nodes = Polymer.dom(this).queryDistributedElements(this.selectable || '*');
    nodes = Array.prototype.filter.call(nodes, this._bindFilterItem);
    this._setItems(nodes);
  },

  _updateAttrForSelected: function _updateAttrForSelected() {
    if (this.selectedItem) {
      this.selected = this._valueForItem(this.selectedItem);
    }
  },

  _updateSelected: function _updateSelected() {
    this._selectSelected(this.selected);
  },

  _selectSelected: function _selectSelected(selected) {
    if (!this.items) {
      return;
    }

    var item = this._valueToItem(this.selected);
    if (item) {
      this._selection.select(item);
    } else {
      this._selection.clear();
    }
    // Check for items, since this array is populated only when attached
    // Since Number(0) is falsy, explicitly check for undefined
    if (this.fallbackSelection && this.items.length && this._selection.get() === undefined) {
      this.selected = this.fallbackSelection;
    }
  },

  _filterItem: function _filterItem(node) {
    return !this._excludedLocalNames[node.localName];
  },

  _valueToItem: function _valueToItem(value) {
    return value == null ? null : this.items[this._valueToIndex(value)];
  },

  _valueToIndex: function _valueToIndex(value) {
    if (this.attrForSelected) {
      for (var i = 0, item; item = this.items[i]; i++) {
        if (this._valueForItem(item) == value) {
          return i;
        }
      }
    } else {
      return Number(value);
    }
  },

  _indexToValue: function _indexToValue(index) {
    if (this.attrForSelected) {
      var item = this.items[index];
      if (item) {
        return this._valueForItem(item);
      }
    } else {
      return index;
    }
  },

  _valueForItem: function _valueForItem(item) {
    if (!item) {
      return null;
    }

    var propValue = item[Polymer.CaseMap.dashToCamelCase(this.attrForSelected)];
    return propValue != undefined ? propValue : item.getAttribute(this.attrForSelected);
  },

  _applySelection: function _applySelection(item, isSelected) {
    if (this.selectedClass) {
      this.toggleClass(this.selectedClass, isSelected, item);
    }
    if (this.selectedAttribute) {
      this.toggleAttribute(this.selectedAttribute, isSelected, item);
    }
    this._selectionChange();
    this.fire('iron-' + (isSelected ? 'select' : 'deselect'), { item: item });
  },

  _selectionChange: function _selectionChange() {
    this._setSelectedItem(this._selection.get());
  },

  // observe items change under the given node.
  _observeItems: function _observeItems(node) {
    return Polymer.dom(node).observeNodes(function (mutation) {
      this._updateItems();
      this._updateSelected();

      // Let other interested parties know about the change so that
      // we don't have to recreate mutation observers everywhere.
      this.fire('iron-items-changed', mutation, {
        bubbles: false,
        cancelable: false
      });
    });
  },

  _activateHandler: function _activateHandler(e) {
    var t = e.target;
    var items = this.items;
    while (t && t != this) {
      var i = items.indexOf(t);
      if (i >= 0) {
        var value = this._indexToValue(i);
        this._itemActivate(value, t);
        return;
      }
      t = t.parentNode;
    }
  },

  _itemActivate: function _itemActivate(value, item) {
    if (!this.fire('iron-activate', { selected: value, item: item }, { cancelable: true }).defaultPrevented) {
      this.select(value);
    }
  }

};

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

__webpack_require__(38);

var RegisterHtmlTemplate = __webpack_require__(2);

RegisterHtmlTemplate.toBody("<custom-style> <style is=custom-style>html{--primary-text-color:var(--light-theme-text-color);--primary-background-color:var(--light-theme-background-color);--secondary-text-color:var(--light-theme-secondary-color);--disabled-text-color:var(--light-theme-disabled-color);--divider-color:var(--light-theme-divider-color);--error-color:var(--paper-deep-orange-a700);--primary-color:var(--paper-indigo-500);--light-primary-color:var(--paper-indigo-100);--dark-primary-color:var(--paper-indigo-700);--accent-color:var(--paper-pink-a200);--light-accent-color:var(--paper-pink-a100);--dark-accent-color:var(--paper-pink-a400);--light-theme-background-color:#ffffff;--light-theme-base-color:#000000;--light-theme-text-color:var(--paper-grey-900);--light-theme-secondary-color:#737373;--light-theme-disabled-color:#9b9b9b;--light-theme-divider-color:#dbdbdb;--dark-theme-background-color:var(--paper-grey-900);--dark-theme-base-color:#ffffff;--dark-theme-text-color:#ffffff;--dark-theme-secondary-color:#bcbcbc;--dark-theme-disabled-color:#646464;--dark-theme-divider-color:#3c3c3c;--text-primary-color:var(--dark-theme-text-color);--default-primary-color:var(--primary-color)}</style> </custom-style>");

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

__webpack_require__(32);

__webpack_require__(83);

__webpack_require__(30);

var RegisterHtmlTemplate = __webpack_require__(2);

RegisterHtmlTemplate.register("<dom-module id=paper-icon-button> <template strip-whitespace=\"\"> <style>:host{display:inline-block;position:relative;padding:8px;outline:0;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;z-index:0;line-height:1;width:40px;height:40px;-webkit-tap-highlight-color:transparent;-webkit-tap-highlight-color:transparent;box-sizing:border-box!important;@apply --paper-icon-button;}:host #ink{color:var(--paper-icon-button-ink-color,var(--primary-text-color));opacity:.6}:host([disabled]){color:var(--paper-icon-button-disabled-text,var(--disabled-text-color));pointer-events:none;cursor:auto;@apply --paper-icon-button-disabled;}:host([hidden]){display:none!important}:host(:hover){@apply --paper-icon-button-hover;}iron-icon{--iron-icon-width:100%;--iron-icon-height:100%}</style> <iron-icon id=icon src=[[src]] icon=[[icon]] alt$=[[alt]]></iron-icon> </template> </dom-module>");

Polymer({
  is: 'paper-icon-button',

  hostAttributes: {
    role: 'button',
    tabindex: '0'
  },

  behaviors: [Polymer.PaperInkyFocusBehavior],

  properties: {
    /**
     * The URL of an image for the icon. If the src property is specified,
     * the icon property should not be.
     */
    src: {
      type: String
    },

    /**
     * Specifies the icon name or index in the set of icons available in
     * the icon's icon set. If the icon property is specified,
     * the src property should not be.
     */
    icon: {
      type: String
    },

    /**
     * Specifies the alternate text for the button, for accessibility.
     */
    alt: {
      type: String,
      observer: "_altChanged"
    }
  },

  _altChanged: function _altChanged(newValue, oldValue) {
    var label = this.getAttribute('aria-label');

    // Don't stomp over a user-set aria-label.
    if (!label || oldValue == label) {
      this.setAttribute('aria-label', newValue);
    }
  }
});

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

__webpack_require__(18);

__webpack_require__(5);

var RegisterHtmlTemplate = __webpack_require__(2);

RegisterHtmlTemplate.register("<dom-module id=iron-icon> <template> <style>:host{@apply --layout-inline;@apply --layout-center-center;position:relative;vertical-align:middle;fill:var(--iron-icon-fill-color,currentcolor);stroke:var(--iron-icon-stroke-color,none);width:var(--iron-icon-width,24px);height:var(--iron-icon-height,24px);@apply --iron-icon;}:host([hidden]){display:none}</style> </template> </dom-module>");

Polymer({

  is: 'iron-icon',

  properties: {

    /**
     * The name of the icon to use. The name should be of the form:
     * `iconset_name:icon_name`.
     */
    icon: {
      type: String
    },

    /**
     * The name of the theme to used, if one is specified by the
     * iconset.
     */
    theme: {
      type: String
    },

    /**
     * If using iron-icon without an iconset, you can set the src to be
     * the URL of an individual icon image file. Note that this will take
     * precedence over a given icon attribute.
     */
    src: {
      type: String
    },

    /**
     * @type {!Polymer.IronMeta}
     */
    _meta: {
      value: Polymer.Base.create('iron-meta', { type: 'iconset' })
    }

  },

  observers: ['_updateIcon(_meta, isAttached)', '_updateIcon(theme, isAttached)', '_srcChanged(src, isAttached)', '_iconChanged(icon, isAttached)'],

  _DEFAULT_ICONSET: 'icons',

  _iconChanged: function _iconChanged(icon) {
    var parts = (icon || '').split(':');
    this._iconName = parts.pop();
    this._iconsetName = parts.pop() || this._DEFAULT_ICONSET;
    this._updateIcon();
  },

  _srcChanged: function _srcChanged(src) {
    this._updateIcon();
  },

  _usesIconset: function _usesIconset() {
    return this.icon || !this.src;
  },

  /** @suppress {visibility} */
  _updateIcon: function _updateIcon() {
    if (this._usesIconset()) {
      if (this._img && this._img.parentNode) {
        Polymer.dom(this.root).removeChild(this._img);
      }
      if (this._iconName === "") {
        if (this._iconset) {
          this._iconset.removeIcon(this);
        }
      } else if (this._iconsetName && this._meta) {
        this._iconset = /** @type {?Polymer.Iconset} */this._meta.byKey(this._iconsetName);
        if (this._iconset) {
          this._iconset.applyIcon(this, this._iconName, this.theme);
          this.unlisten(window, 'iron-iconset-added', '_updateIcon');
        } else {
          this.listen(window, 'iron-iconset-added', '_updateIcon');
        }
      }
    } else {
      if (this._iconset) {
        this._iconset.removeIcon(this);
      }
      if (!this._img) {
        this._img = document.createElement('img');
        this._img.style.width = '100%';
        this._img.style.height = '100%';
        this._img.draggable = false;
      }
      this._img.src = this.src;
      Polymer.dom(this.root).appendChild(this._img);
    }
  }

});

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

/**
 * @demo demo/index.html
 * @polymerBehavior
 */
Polymer.IronControlState = {

  properties: {

    /**
     * If true, the element currently has focus.
     */
    focused: {
      type: Boolean,
      value: false,
      notify: true,
      readOnly: true,
      reflectToAttribute: true
    },

    /**
     * If true, the user cannot interact with this element.
     */
    disabled: {
      type: Boolean,
      value: false,
      notify: true,
      observer: '_disabledChanged',
      reflectToAttribute: true
    },

    _oldTabIndex: {
      type: Number
    },

    _boundFocusBlurHandler: {
      type: Function,
      value: function value() {
        return this._focusBlurHandler.bind(this);
      }
    },

    __handleEventRetargeting: {
      type: Boolean,
      value: function value() {
        return !this.shadowRoot && !Polymer.Element;
      }
    }
  },

  observers: ['_changedControlState(focused, disabled)'],

  ready: function ready() {
    this.addEventListener('focus', this._boundFocusBlurHandler, true);
    this.addEventListener('blur', this._boundFocusBlurHandler, true);
  },

  _focusBlurHandler: function _focusBlurHandler(event) {
    // In Polymer 2.0, the library takes care of retargeting events.
    if (Polymer.Element) {
      this._setFocused(event.type === 'focus');
      return;
    }

    // NOTE(cdata):  if we are in ShadowDOM land, `event.target` will
    // eventually become `this` due to retargeting; if we are not in
    // ShadowDOM land, `event.target` will eventually become `this` due
    // to the second conditional which fires a synthetic event (that is also
    // handled). In either case, we can disregard `event.path`.
    if (event.target === this) {
      this._setFocused(event.type === 'focus');
    } else if (this.__handleEventRetargeting) {
      var target = /** @type {Node} */Polymer.dom(event).localTarget;
      if (!this.isLightDescendant(target)) {
        this.fire(event.type, { sourceEvent: event }, {
          node: this,
          bubbles: event.bubbles,
          cancelable: event.cancelable
        });
      }
    }
  },

  _disabledChanged: function _disabledChanged(disabled, old) {
    this.setAttribute('aria-disabled', disabled ? 'true' : 'false');
    this.style.pointerEvents = disabled ? 'none' : '';
    if (disabled) {
      this._oldTabIndex = this.tabIndex;
      this._setFocused(false);
      this.tabIndex = -1;
      this.blur();
    } else if (this._oldTabIndex !== undefined) {
      this.tabIndex = this._oldTabIndex;
    }
  },

  _changedControlState: function _changedControlState() {
    // _controlStateChanged is abstract, follow-on behaviors may implement it
    if (this._controlStateChanged) {
      this._controlStateChanged();
    }
  }

};

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

__webpack_require__(16);

var RegisterHtmlTemplate = __webpack_require__(2);

RegisterHtmlTemplate.register("<dom-module id=paper-ripple> <template> <style>:host{display:block;position:absolute;border-radius:inherit;overflow:hidden;top:0;left:0;right:0;bottom:0;pointer-events:none}:host([animating]){-webkit-transform:translate(0,0);transform:translate3d(0,0,0)}#background,#waves,.wave,.wave-container{pointer-events:none;position:absolute;top:0;left:0;width:100%;height:100%}#background,.wave{opacity:0}#waves,.wave{overflow:hidden}.wave,.wave-container{border-radius:50%}:host(.circle) #background,:host(.circle) #waves{border-radius:50%}:host(.circle) .wave-container{overflow:hidden}</style> <div id=background></div> <div id=waves></div> </template> </dom-module>");

(function () {
  'use strict';

  var Utility = {
    distance: function distance(x1, y1, x2, y2) {
      var xDelta = x1 - x2;
      var yDelta = y1 - y2;

      return Math.sqrt(xDelta * xDelta + yDelta * yDelta);
    },

    now: window.performance && window.performance.now ? window.performance.now.bind(window.performance) : Date.now
  };

  /**
   * @param {HTMLElement} element
   * @constructor
   */
  function ElementMetrics(element) {
    this.element = element;
    this.width = this.boundingRect.width;
    this.height = this.boundingRect.height;

    this.size = Math.max(this.width, this.height);
  }

  ElementMetrics.prototype = {
    get boundingRect() {
      return this.element.getBoundingClientRect();
    },

    furthestCornerDistanceFrom: function furthestCornerDistanceFrom(x, y) {
      var topLeft = Utility.distance(x, y, 0, 0);
      var topRight = Utility.distance(x, y, this.width, 0);
      var bottomLeft = Utility.distance(x, y, 0, this.height);
      var bottomRight = Utility.distance(x, y, this.width, this.height);

      return Math.max(topLeft, topRight, bottomLeft, bottomRight);
    }
  };

  /**
   * @param {HTMLElement} element
   * @constructor
   */
  function Ripple(element) {
    this.element = element;
    this.color = window.getComputedStyle(element).color;

    this.wave = document.createElement('div');
    this.waveContainer = document.createElement('div');
    this.wave.style.backgroundColor = this.color;
    this.wave.classList.add('wave');
    this.waveContainer.classList.add('wave-container');
    Polymer.dom(this.waveContainer).appendChild(this.wave);

    this.resetInteractionState();
  }

  Ripple.MAX_RADIUS = 300;

  Ripple.prototype = {
    get recenters() {
      return this.element.recenters;
    },

    get center() {
      return this.element.center;
    },

    get mouseDownElapsed() {
      var elapsed;

      if (!this.mouseDownStart) {
        return 0;
      }

      elapsed = Utility.now() - this.mouseDownStart;

      if (this.mouseUpStart) {
        elapsed -= this.mouseUpElapsed;
      }

      return elapsed;
    },

    get mouseUpElapsed() {
      return this.mouseUpStart ? Utility.now() - this.mouseUpStart : 0;
    },

    get mouseDownElapsedSeconds() {
      return this.mouseDownElapsed / 1000;
    },

    get mouseUpElapsedSeconds() {
      return this.mouseUpElapsed / 1000;
    },

    get mouseInteractionSeconds() {
      return this.mouseDownElapsedSeconds + this.mouseUpElapsedSeconds;
    },

    get initialOpacity() {
      return this.element.initialOpacity;
    },

    get opacityDecayVelocity() {
      return this.element.opacityDecayVelocity;
    },

    get radius() {
      var width2 = this.containerMetrics.width * this.containerMetrics.width;
      var height2 = this.containerMetrics.height * this.containerMetrics.height;
      var waveRadius = Math.min(Math.sqrt(width2 + height2), Ripple.MAX_RADIUS) * 1.1 + 5;

      var duration = 1.1 - 0.2 * (waveRadius / Ripple.MAX_RADIUS);
      var timeNow = this.mouseInteractionSeconds / duration;
      var size = waveRadius * (1 - Math.pow(80, -timeNow));

      return Math.abs(size);
    },

    get opacity() {
      if (!this.mouseUpStart) {
        return this.initialOpacity;
      }

      return Math.max(0, this.initialOpacity - this.mouseUpElapsedSeconds * this.opacityDecayVelocity);
    },

    get outerOpacity() {
      // Linear increase in background opacity, capped at the opacity
      // of the wavefront (waveOpacity).
      var outerOpacity = this.mouseUpElapsedSeconds * 0.3;
      var waveOpacity = this.opacity;

      return Math.max(0, Math.min(outerOpacity, waveOpacity));
    },

    get isOpacityFullyDecayed() {
      return this.opacity < 0.01 && this.radius >= Math.min(this.maxRadius, Ripple.MAX_RADIUS);
    },

    get isRestingAtMaxRadius() {
      return this.opacity >= this.initialOpacity && this.radius >= Math.min(this.maxRadius, Ripple.MAX_RADIUS);
    },

    get isAnimationComplete() {
      return this.mouseUpStart ? this.isOpacityFullyDecayed : this.isRestingAtMaxRadius;
    },

    get translationFraction() {
      return Math.min(1, this.radius / this.containerMetrics.size * 2 / Math.sqrt(2));
    },

    get xNow() {
      if (this.xEnd) {
        return this.xStart + this.translationFraction * (this.xEnd - this.xStart);
      }

      return this.xStart;
    },

    get yNow() {
      if (this.yEnd) {
        return this.yStart + this.translationFraction * (this.yEnd - this.yStart);
      }

      return this.yStart;
    },

    get isMouseDown() {
      return this.mouseDownStart && !this.mouseUpStart;
    },

    resetInteractionState: function resetInteractionState() {
      this.maxRadius = 0;
      this.mouseDownStart = 0;
      this.mouseUpStart = 0;

      this.xStart = 0;
      this.yStart = 0;
      this.xEnd = 0;
      this.yEnd = 0;
      this.slideDistance = 0;

      this.containerMetrics = new ElementMetrics(this.element);
    },

    draw: function draw() {
      var scale;
      var translateString;
      var dx;
      var dy;

      this.wave.style.opacity = this.opacity;

      scale = this.radius / (this.containerMetrics.size / 2);
      dx = this.xNow - this.containerMetrics.width / 2;
      dy = this.yNow - this.containerMetrics.height / 2;

      // 2d transform for safari because of border-radius and overflow:hidden clipping bug.
      // https://bugs.webkit.org/show_bug.cgi?id=98538
      this.waveContainer.style.webkitTransform = 'translate(' + dx + 'px, ' + dy + 'px)';
      this.waveContainer.style.transform = 'translate3d(' + dx + 'px, ' + dy + 'px, 0)';
      this.wave.style.webkitTransform = 'scale(' + scale + ',' + scale + ')';
      this.wave.style.transform = 'scale3d(' + scale + ',' + scale + ',1)';
    },

    /** @param {Event=} event */
    downAction: function downAction(event) {
      var xCenter = this.containerMetrics.width / 2;
      var yCenter = this.containerMetrics.height / 2;

      this.resetInteractionState();
      this.mouseDownStart = Utility.now();

      if (this.center) {
        this.xStart = xCenter;
        this.yStart = yCenter;
        this.slideDistance = Utility.distance(this.xStart, this.yStart, this.xEnd, this.yEnd);
      } else {
        this.xStart = event ? event.detail.x - this.containerMetrics.boundingRect.left : this.containerMetrics.width / 2;
        this.yStart = event ? event.detail.y - this.containerMetrics.boundingRect.top : this.containerMetrics.height / 2;
      }

      if (this.recenters) {
        this.xEnd = xCenter;
        this.yEnd = yCenter;
        this.slideDistance = Utility.distance(this.xStart, this.yStart, this.xEnd, this.yEnd);
      }

      this.maxRadius = this.containerMetrics.furthestCornerDistanceFrom(this.xStart, this.yStart);

      this.waveContainer.style.top = (this.containerMetrics.height - this.containerMetrics.size) / 2 + 'px';
      this.waveContainer.style.left = (this.containerMetrics.width - this.containerMetrics.size) / 2 + 'px';

      this.waveContainer.style.width = this.containerMetrics.size + 'px';
      this.waveContainer.style.height = this.containerMetrics.size + 'px';
    },

    /** @param {Event=} event */
    upAction: function upAction(event) {
      if (!this.isMouseDown) {
        return;
      }

      this.mouseUpStart = Utility.now();
    },

    remove: function remove() {
      Polymer.dom(this.waveContainer.parentNode).removeChild(this.waveContainer);
    }
  };

  Polymer({
    is: 'paper-ripple',

    behaviors: [Polymer.IronA11yKeysBehavior],

    properties: {
      /**
       * The initial opacity set on the wave.
       *
       * @attribute initialOpacity
       * @type number
       * @default 0.25
       */
      initialOpacity: {
        type: Number,
        value: 0.25
      },

      /**
       * How fast (opacity per second) the wave fades out.
       *
       * @attribute opacityDecayVelocity
       * @type number
       * @default 0.8
       */
      opacityDecayVelocity: {
        type: Number,
        value: 0.8
      },

      /**
       * If true, ripples will exhibit a gravitational pull towards
       * the center of their container as they fade away.
       *
       * @attribute recenters
       * @type boolean
       * @default false
       */
      recenters: {
        type: Boolean,
        value: false
      },

      /**
       * If true, ripples will center inside its container
       *
       * @attribute recenters
       * @type boolean
       * @default false
       */
      center: {
        type: Boolean,
        value: false
      },

      /**
       * A list of the visual ripples.
       *
       * @attribute ripples
       * @type Array
       * @default []
       */
      ripples: {
        type: Array,
        value: function value() {
          return [];
        }
      },

      /**
       * True when there are visible ripples animating within the
       * element.
       */
      animating: {
        type: Boolean,
        readOnly: true,
        reflectToAttribute: true,
        value: false
      },

      /**
       * If true, the ripple will remain in the "down" state until `holdDown`
       * is set to false again.
       */
      holdDown: {
        type: Boolean,
        value: false,
        observer: '_holdDownChanged'
      },

      /**
       * If true, the ripple will not generate a ripple effect
       * via pointer interaction.
       * Calling ripple's imperative api like `simulatedRipple` will
       * still generate the ripple effect.
       */
      noink: {
        type: Boolean,
        value: false
      },

      _animating: {
        type: Boolean
      },

      _boundAnimate: {
        type: Function,
        value: function value() {
          return this.animate.bind(this);
        }
      }
    },

    get target() {
      return this.keyEventTarget;
    },

    keyBindings: {
      'enter:keydown': '_onEnterKeydown',
      'space:keydown': '_onSpaceKeydown',
      'space:keyup': '_onSpaceKeyup'
    },

    attached: function attached() {
      // Set up a11yKeysBehavior to listen to key events on the target,
      // so that space and enter activate the ripple even if the target doesn't
      // handle key events. The key handlers deal with `noink` themselves.
      if (this.parentNode.nodeType == 11) {
        // DOCUMENT_FRAGMENT_NODE
        this.keyEventTarget = Polymer.dom(this).getOwnerRoot().host;
      } else {
        this.keyEventTarget = this.parentNode;
      }
      var keyEventTarget = /** @type {!EventTarget} */this.keyEventTarget;
      this.listen(keyEventTarget, 'up', 'uiUpAction');
      this.listen(keyEventTarget, 'down', 'uiDownAction');
    },

    detached: function detached() {
      this.unlisten(this.keyEventTarget, 'up', 'uiUpAction');
      this.unlisten(this.keyEventTarget, 'down', 'uiDownAction');
      this.keyEventTarget = null;
    },

    get shouldKeepAnimating() {
      for (var index = 0; index < this.ripples.length; ++index) {
        if (!this.ripples[index].isAnimationComplete) {
          return true;
        }
      }

      return false;
    },

    simulatedRipple: function simulatedRipple() {
      this.downAction(null);

      // Please see polymer/polymer#1305
      this.async(function () {
        this.upAction();
      }, 1);
    },

    /**
     * Provokes a ripple down effect via a UI event,
     * respecting the `noink` property.
     * @param {Event=} event
     */
    uiDownAction: function uiDownAction(event) {
      if (!this.noink) {
        this.downAction(event);
      }
    },

    /**
     * Provokes a ripple down effect via a UI event,
     * *not* respecting the `noink` property.
     * @param {Event=} event
     */
    downAction: function downAction(event) {
      if (this.holdDown && this.ripples.length > 0) {
        return;
      }

      var ripple = this.addRipple();

      ripple.downAction(event);

      if (!this._animating) {
        this._animating = true;
        this.animate();
      }
    },

    /**
     * Provokes a ripple up effect via a UI event,
     * respecting the `noink` property.
     * @param {Event=} event
     */
    uiUpAction: function uiUpAction(event) {
      if (!this.noink) {
        this.upAction(event);
      }
    },

    /**
     * Provokes a ripple up effect via a UI event,
     * *not* respecting the `noink` property.
     * @param {Event=} event
     */
    upAction: function upAction(event) {
      if (this.holdDown) {
        return;
      }

      this.ripples.forEach(function (ripple) {
        ripple.upAction(event);
      });

      this._animating = true;
      this.animate();
    },

    onAnimationComplete: function onAnimationComplete() {
      this._animating = false;
      this.$.background.style.backgroundColor = null;
      this.fire('transitionend');
    },

    addRipple: function addRipple() {
      var ripple = new Ripple(this);

      Polymer.dom(this.$.waves).appendChild(ripple.waveContainer);
      this.$.background.style.backgroundColor = ripple.color;
      this.ripples.push(ripple);

      this._setAnimating(true);

      return ripple;
    },

    removeRipple: function removeRipple(ripple) {
      var rippleIndex = this.ripples.indexOf(ripple);

      if (rippleIndex < 0) {
        return;
      }

      this.ripples.splice(rippleIndex, 1);

      ripple.remove();

      if (!this.ripples.length) {
        this._setAnimating(false);
      }
    },

    /**
     * This conflicts with Element#antimate().
     * https://developer.mozilla.org/en-US/docs/Web/API/Element/animate
     * @suppress {checkTypes}
     */
    animate: function animate() {
      if (!this._animating) {
        return;
      }
      var index;
      var ripple;

      for (index = 0; index < this.ripples.length; ++index) {
        ripple = this.ripples[index];

        ripple.draw();

        this.$.background.style.opacity = ripple.outerOpacity;

        if (ripple.isOpacityFullyDecayed && !ripple.isRestingAtMaxRadius) {
          this.removeRipple(ripple);
        }
      }

      if (!this.shouldKeepAnimating && this.ripples.length === 0) {
        this.onAnimationComplete();
      } else {
        window.requestAnimationFrame(this._boundAnimate);
      }
    },

    _onEnterKeydown: function _onEnterKeydown() {
      this.uiDownAction();
      this.async(this.uiUpAction, 1);
    },

    _onSpaceKeydown: function _onSpaceKeydown() {
      this.uiDownAction();
    },

    _onSpaceKeyup: function _onSpaceKeyup() {
      this.uiUpAction();
    },

    // note: holdDown does not respect noink since it can be a focus based
    // effect.
    _holdDownChanged: function _holdDownChanged(newVal, oldVal) {
      if (oldVal === undefined) {
        return;
      }
      if (newVal) {
        this.downAction();
      } else {
        this.upAction();
      }
    }

    /**
    Fired when the animation finishes.
    This is useful if you want to wait until
    the ripple animation finishes to perform some action.
     @event transitionend
    @param {{node: Object}} detail Contains the animated node.
    */
  });
})();

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

__webpack_require__(18);

/**
 * The `iron-iconset-svg` element allows users to define their own icon sets
 * that contain svg icons. The svg icon elements should be children of the
 * `iron-iconset-svg` element. Multiple icons should be given distinct id's.
 *
 * Using svg elements to create icons has a few advantages over traditional
 * bitmap graphics like jpg or png. Icons that use svg are vector based so
 * they are resolution independent and should look good on any device. They
 * are stylable via css. Icons can be themed, colorized, and even animated.
 *
 * Example:
 *
 *     <iron-iconset-svg name="my-svg-icons" size="24">
 *       <svg>
 *         <defs>
 *           <g id="shape">
 *             <rect x="12" y="0" width="12" height="24" />
 *             <circle cx="12" cy="12" r="12" />
 *           </g>
 *         </defs>
 *       </svg>
 *     </iron-iconset-svg>
 *
 * This will automatically register the icon set "my-svg-icons" to the iconset
 * database.  To use these icons from within another element, make a
 * `iron-iconset` element and call the `byId` method
 * to retrieve a given iconset. To apply a particular icon inside an
 * element use the `applyIcon` method. For example:
 *
 *     iconset.applyIcon(iconNode, 'car');
 *
 * @element iron-iconset-svg
 * @demo demo/index.html
 * @implements {Polymer.Iconset}
 */
Polymer({
  is: 'iron-iconset-svg',

  properties: {

    /**
     * The name of the iconset.
     */
    name: {
      type: String,
      observer: '_nameChanged'
    },

    /**
     * The size of an individual icon. Note that icons must be square.
     */
    size: {
      type: Number,
      value: 24
    },

    /**
     * Set to true to enable mirroring of icons where specified when they are
     * stamped. Icons that should be mirrored should be decorated with a
     * `mirror-in-rtl` attribute.
     *
     * NOTE: For performance reasons, direction will be resolved once per
     * document per iconset, so moving icons in and out of RTL subtrees will
     * not cause their mirrored state to change.
     */
    rtlMirroring: {
      type: Boolean,
      value: false
    },

    /**
     * Set to true to measure RTL based on the dir attribute on the body or
     * html elements (measured on document.body or document.documentElement as
     * available).
     */
    useGlobalRtlAttribute: {
      type: Boolean,
      value: false
    }
  },

  created: function created() {
    this._meta = new Polymer.IronMeta({ type: 'iconset', key: null, value: null });
  },

  attached: function attached() {
    this.style.display = 'none';
  },

  /**
   * Construct an array of all icon names in this iconset.
   *
   * @return {!Array} Array of icon names.
   */
  getIconNames: function getIconNames() {
    this._icons = this._createIconMap();
    return Object.keys(this._icons).map(function (n) {
      return this.name + ':' + n;
    }, this);
  },

  /**
   * Applies an icon to the given element.
   *
   * An svg icon is prepended to the element's shadowRoot if it exists,
   * otherwise to the element itself.
   *
   * If RTL mirroring is enabled, and the icon is marked to be mirrored in
   * RTL, the element will be tested (once and only once ever for each
   * iconset) to determine the direction of the subtree the element is in.
   * This direction will apply to all future icon applications, although only
   * icons marked to be mirrored will be affected.
   *
   * @method applyIcon
   * @param {Element} element Element to which the icon is applied.
   * @param {string} iconName Name of the icon to apply.
   * @return {?Element} The svg element which renders the icon.
   */
  applyIcon: function applyIcon(element, iconName) {
    // Remove old svg element
    this.removeIcon(element);
    // install new svg element
    var svg = this._cloneIcon(iconName, this.rtlMirroring && this._targetIsRTL(element));
    if (svg) {
      // insert svg element into shadow root, if it exists
      var pde = Polymer.dom(element.root || element);
      pde.insertBefore(svg, pde.childNodes[0]);
      return element._svgIcon = svg;
    }
    return null;
  },

  /**
   * Remove an icon from the given element by undoing the changes effected
   * by `applyIcon`.
   *
   * @param {Element} element The element from which the icon is removed.
   */
  removeIcon: function removeIcon(element) {
    // Remove old svg element
    if (element._svgIcon) {
      Polymer.dom(element.root || element).removeChild(element._svgIcon);
      element._svgIcon = null;
    }
  },

  /**
   * Measures and memoizes the direction of the element. Note that this
   * measurement is only done once and the result is memoized for future
   * invocations.
   */
  _targetIsRTL: function _targetIsRTL(target) {
    if (this.__targetIsRTL == null) {
      if (this.useGlobalRtlAttribute) {
        var globalElement = document.body && document.body.hasAttribute('dir') ? document.body : document.documentElement;

        this.__targetIsRTL = globalElement.getAttribute('dir') === 'rtl';
      } else {
        if (target && target.nodeType !== Node.ELEMENT_NODE) {
          target = target.host;
        }

        this.__targetIsRTL = target && window.getComputedStyle(target)['direction'] === 'rtl';
      }
    }

    return this.__targetIsRTL;
  },

  /**
   *
   * When name is changed, register iconset metadata
   *
   */
  _nameChanged: function _nameChanged() {
    this._meta.value = null;
    this._meta.key = this.name;
    this._meta.value = this;

    this.async(function () {
      this.fire('iron-iconset-added', this, { node: window });
    });
  },

  /**
   * Create a map of child SVG elements by id.
   *
   * @return {!Object} Map of id's to SVG elements.
   */
  _createIconMap: function _createIconMap() {
    // Objects chained to Object.prototype (`{}`) have members. Specifically,
    // on FF there is a `watch` method that confuses the icon map, so we
    // need to use a null-based object here.
    var icons = Object.create(null);
    Polymer.dom(this).querySelectorAll('[id]').forEach(function (icon) {
      icons[icon.id] = icon;
    });
    return icons;
  },

  /**
   * Produce installable clone of the SVG element matching `id` in this
   * iconset, or `undefined` if there is no matching element.
   *
   * @return {Element} Returns an installable clone of the SVG element
   * matching `id`.
   */
  _cloneIcon: function _cloneIcon(id, mirrorAllowed) {
    // create the icon map on-demand, since the iconset itself has no discrete
    // signal to know when it's children are fully parsed
    this._icons = this._icons || this._createIconMap();
    return this._prepareSvgClone(this._icons[id], this.size, mirrorAllowed);
  },

  /**
   * @param {Element} sourceSvg
   * @param {number} size
   * @param {Boolean} mirrorAllowed
   * @return {Element}
   */
  _prepareSvgClone: function _prepareSvgClone(sourceSvg, size, mirrorAllowed) {
    if (sourceSvg) {
      var content = sourceSvg.cloneNode(true),
          svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg'),
          viewBox = content.getAttribute('viewBox') || '0 0 ' + size + ' ' + size,
          cssText = 'pointer-events: none; display: block; width: 100%; height: 100%;';

      if (mirrorAllowed && content.hasAttribute('mirror-in-rtl')) {
        cssText += '-webkit-transform:scale(-1,1);transform:scale(-1,1);';
      }

      svg.setAttribute('viewBox', viewBox);
      svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');
      svg.setAttribute('focusable', 'false');
      // TODO(dfreedm): `pointer-events: none` works around https://crbug.com/370136
      // TODO(sjmiles): inline style may not be ideal, but avoids requiring a shadow-root
      svg.style.cssText = cssText;
      svg.appendChild(content).removeAttribute('id');
      return svg;
    }
    return null;
  }

});

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

/**
 * `Polymer.IronScrollTargetBehavior` allows an element to respond to scroll events from a
 * designated scroll target.
 *
 * Elements that consume this behavior can override the `_scrollHandler`
 * method to add logic on the scroll event.
 *
 * @demo demo/scrolling-region.html Scrolling Region
 * @demo demo/document.html Document Element
 * @polymerBehavior
 */
Polymer.IronScrollTargetBehavior = {

  properties: {

    /**
     * Specifies the element that will handle the scroll event
     * on the behalf of the current element. This is typically a reference to an element,
     * but there are a few more posibilities:
     *
     * ### Elements id
     *
     *```html
     * <div id="scrollable-element" style="overflow: auto;">
     *  <x-element scroll-target="scrollable-element">
     *    <!-- Content-->
     *  </x-element>
     * </div>
     *```
     * In this case, the `scrollTarget` will point to the outer div element.
     *
     * ### Document scrolling
     *
     * For document scrolling, you can use the reserved word `document`:
     *
     *```html
     * <x-element scroll-target="document">
     *   <!-- Content -->
     * </x-element>
     *```
     *
     * ### Elements reference
     *
     *```js
     * appHeader.scrollTarget = document.querySelector('#scrollable-element');
     *```
     *
     * @type {HTMLElement}
     * @default document
     */
    scrollTarget: {
      type: HTMLElement,
      value: function value() {
        return this._defaultScrollTarget;
      }
    }
  },

  observers: ['_scrollTargetChanged(scrollTarget, isAttached)'],

  /**
   * True if the event listener should be installed.
   */
  _shouldHaveListener: true,

  _scrollTargetChanged: function _scrollTargetChanged(scrollTarget, isAttached) {
    var eventTarget;

    if (this._oldScrollTarget) {
      this._toggleScrollListener(false, this._oldScrollTarget);
      this._oldScrollTarget = null;
    }
    if (!isAttached) {
      return;
    }
    // Support element id references
    if (scrollTarget === 'document') {

      this.scrollTarget = this._doc;
    } else if (typeof scrollTarget === 'string') {

      var domHost = this.domHost;

      this.scrollTarget = domHost && domHost.$ ? domHost.$[scrollTarget] : Polymer.dom(this.ownerDocument).querySelector('#' + scrollTarget);
    } else if (this._isValidScrollTarget()) {

      this._oldScrollTarget = scrollTarget;
      this._toggleScrollListener(this._shouldHaveListener, scrollTarget);
    }
  },

  /**
   * Runs on every scroll event. Consumer of this behavior may override this method.
   *
   * @protected
   */
  _scrollHandler: function scrollHandler() {},

  /**
   * The default scroll target. Consumers of this behavior may want to customize
   * the default scroll target.
   *
   * @type {Element}
   */
  get _defaultScrollTarget() {
    return this._doc;
  },

  /**
   * Shortcut for the document element
   *
   * @type {Element}
   */
  get _doc() {
    return this.ownerDocument.documentElement;
  },

  /**
   * Gets the number of pixels that the content of an element is scrolled upward.
   *
   * @type {number}
   */
  get _scrollTop() {
    if (this._isValidScrollTarget()) {
      return this.scrollTarget === this._doc ? window.pageYOffset : this.scrollTarget.scrollTop;
    }
    return 0;
  },

  /**
   * Gets the number of pixels that the content of an element is scrolled to the left.
   *
   * @type {number}
   */
  get _scrollLeft() {
    if (this._isValidScrollTarget()) {
      return this.scrollTarget === this._doc ? window.pageXOffset : this.scrollTarget.scrollLeft;
    }
    return 0;
  },

  /**
   * Sets the number of pixels that the content of an element is scrolled upward.
   *
   * @type {number}
   */
  set _scrollTop(top) {
    if (this.scrollTarget === this._doc) {
      window.scrollTo(window.pageXOffset, top);
    } else if (this._isValidScrollTarget()) {
      this.scrollTarget.scrollTop = top;
    }
  },

  /**
   * Sets the number of pixels that the content of an element is scrolled to the left.
   *
   * @type {number}
   */
  set _scrollLeft(left) {
    if (this.scrollTarget === this._doc) {
      window.scrollTo(left, window.pageYOffset);
    } else if (this._isValidScrollTarget()) {
      this.scrollTarget.scrollLeft = left;
    }
  },

  /**
   * Scrolls the content to a particular place.
   *
   * @method scroll
   * @param {number} left The left position
   * @param {number} top The top position
   */
  scroll: function scroll(left, top) {
    if (this.scrollTarget === this._doc) {
      window.scrollTo(left, top);
    } else if (this._isValidScrollTarget()) {
      this.scrollTarget.scrollLeft = left;
      this.scrollTarget.scrollTop = top;
    }
  },

  /**
   * Gets the width of the scroll target.
   *
   * @type {number}
   */
  get _scrollTargetWidth() {
    if (this._isValidScrollTarget()) {
      return this.scrollTarget === this._doc ? window.innerWidth : this.scrollTarget.offsetWidth;
    }
    return 0;
  },

  /**
   * Gets the height of the scroll target.
   *
   * @type {number}
   */
  get _scrollTargetHeight() {
    if (this._isValidScrollTarget()) {
      return this.scrollTarget === this._doc ? window.innerHeight : this.scrollTarget.offsetHeight;
    }
    return 0;
  },

  /**
   * Returns true if the scroll target is a valid HTMLElement.
   *
   * @return {boolean}
   */
  _isValidScrollTarget: function _isValidScrollTarget() {
    return this.scrollTarget instanceof HTMLElement;
  },

  _toggleScrollListener: function _toggleScrollListener(yes, scrollTarget) {
    var eventTarget = scrollTarget === this._doc ? window : scrollTarget;
    if (yes) {
      if (!this._boundScrollHandler) {
        this._boundScrollHandler = this._scrollHandler.bind(this);
        eventTarget.addEventListener('scroll', this._boundScrollHandler);
      }
    } else {
      if (this._boundScrollHandler) {
        eventTarget.removeEventListener('scroll', this._boundScrollHandler);
        this._boundScrollHandler = null;
      }
    }
  },

  /**
   * Enables or disables the scroll event listener.
   *
   * @param {boolean} yes True to add the event, False to remove it.
   */
  toggleScrollListener: function toggleScrollListener(yes) {
    this._shouldHaveListener = yes;
    this._toggleScrollListener(yes, this.scrollTarget);
  }

};

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

__webpack_require__(16);

__webpack_require__(33);

/**
 * @demo demo/index.html
 * @polymerBehavior Polymer.IronButtonState
 */
Polymer.IronButtonStateImpl = {

  properties: {

    /**
     * If true, the user is currently holding down the button.
     */
    pressed: {
      type: Boolean,
      readOnly: true,
      value: false,
      reflectToAttribute: true,
      observer: '_pressedChanged'
    },

    /**
     * If true, the button toggles the active state with each tap or press
     * of the spacebar.
     */
    toggles: {
      type: Boolean,
      value: false,
      reflectToAttribute: true
    },

    /**
     * If true, the button is a toggle and is currently in the active state.
     */
    active: {
      type: Boolean,
      value: false,
      notify: true,
      reflectToAttribute: true
    },

    /**
     * True if the element is currently being pressed by a "pointer," which
     * is loosely defined as mouse or touch input (but specifically excluding
     * keyboard input).
     */
    pointerDown: {
      type: Boolean,
      readOnly: true,
      value: false
    },

    /**
     * True if the input device that caused the element to receive focus
     * was a keyboard.
     */
    receivedFocusFromKeyboard: {
      type: Boolean,
      readOnly: true
    },

    /**
     * The aria attribute to be set if the button is a toggle and in the
     * active state.
     */
    ariaActiveAttribute: {
      type: String,
      value: 'aria-pressed',
      observer: '_ariaActiveAttributeChanged'
    }
  },

  listeners: {
    down: '_downHandler',
    up: '_upHandler',
    tap: '_tapHandler'
  },

  observers: ['_focusChanged(focused)', '_activeChanged(active, ariaActiveAttribute)'],

  keyBindings: {
    'enter:keydown': '_asyncClick',
    'space:keydown': '_spaceKeyDownHandler',
    'space:keyup': '_spaceKeyUpHandler'
  },

  _mouseEventRe: /^mouse/,

  _tapHandler: function _tapHandler() {
    if (this.toggles) {
      // a tap is needed to toggle the active state
      this._userActivate(!this.active);
    } else {
      this.active = false;
    }
  },

  _focusChanged: function _focusChanged(focused) {
    this._detectKeyboardFocus(focused);

    if (!focused) {
      this._setPressed(false);
    }
  },

  _detectKeyboardFocus: function _detectKeyboardFocus(focused) {
    this._setReceivedFocusFromKeyboard(!this.pointerDown && focused);
  },

  // to emulate native checkbox, (de-)activations from a user interaction fire
  // 'change' events
  _userActivate: function _userActivate(active) {
    if (this.active !== active) {
      this.active = active;
      this.fire('change');
    }
  },

  _downHandler: function _downHandler(event) {
    this._setPointerDown(true);
    this._setPressed(true);
    this._setReceivedFocusFromKeyboard(false);
  },

  _upHandler: function _upHandler() {
    this._setPointerDown(false);
    this._setPressed(false);
  },

  /**
   * @param {!KeyboardEvent} event .
   */
  _spaceKeyDownHandler: function _spaceKeyDownHandler(event) {
    var keyboardEvent = event.detail.keyboardEvent;
    var target = Polymer.dom(keyboardEvent).localTarget;

    // Ignore the event if this is coming from a focused light child, since that
    // element will deal with it.
    if (this.isLightDescendant( /** @type {Node} */target)) return;

    keyboardEvent.preventDefault();
    keyboardEvent.stopImmediatePropagation();
    this._setPressed(true);
  },

  /**
   * @param {!KeyboardEvent} event .
   */
  _spaceKeyUpHandler: function _spaceKeyUpHandler(event) {
    var keyboardEvent = event.detail.keyboardEvent;
    var target = Polymer.dom(keyboardEvent).localTarget;

    // Ignore the event if this is coming from a focused light child, since that
    // element will deal with it.
    if (this.isLightDescendant( /** @type {Node} */target)) return;

    if (this.pressed) {
      this._asyncClick();
    }
    this._setPressed(false);
  },

  // trigger click asynchronously, the asynchrony is useful to allow one
  // event handler to unwind before triggering another event
  _asyncClick: function _asyncClick() {
    this.async(function () {
      this.click();
    }, 1);
  },

  // any of these changes are considered a change to button state

  _pressedChanged: function _pressedChanged(pressed) {
    this._changedButtonState();
  },

  _ariaActiveAttributeChanged: function _ariaActiveAttributeChanged(value, oldValue) {
    if (oldValue && oldValue != value && this.hasAttribute(oldValue)) {
      this.removeAttribute(oldValue);
    }
  },

  _activeChanged: function _activeChanged(active, ariaActiveAttribute) {
    if (this.toggles) {
      this.setAttribute(this.ariaActiveAttribute, active ? 'true' : 'false');
    } else {
      this.removeAttribute(this.ariaActiveAttribute);
    }
    this._changedButtonState();
  },

  _controlStateChanged: function _controlStateChanged() {
    if (this.disabled) {
      this._setPressed(false);
    } else {
      this._changedButtonState();
    }
  },

  // provide hook for follow-on behaviors to react to button-state

  _changedButtonState: function _changedButtonState() {
    if (this._buttonStateChanged) {
      this._buttonStateChanged(); // abstract
    }
  }

};

/** @polymerBehavior */
Polymer.IronButtonState = [Polymer.IronA11yKeysBehavior, Polymer.IronButtonStateImpl];

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

var RegisterHtmlTemplate = __webpack_require__(2);

RegisterHtmlTemplate.toBody("<custom-style> <style is=custom-style>html{--google-red-100:#f4c7c3;--google-red-300:#e67c73;--google-red-500:#db4437;--google-red-700:#c53929;--google-blue-100:#c6dafc;--google-blue-300:#7baaf7;--google-blue-500:#4285f4;--google-blue-700:#3367d6;--google-green-100:#b7e1cd;--google-green-300:#57bb8a;--google-green-500:#0f9d58;--google-green-700:#0b8043;--google-yellow-100:#fce8b2;--google-yellow-300:#f7cb4d;--google-yellow-500:#f4b400;--google-yellow-700:#f09300;--google-grey-100:#f5f5f5;--google-grey-300:#e0e0e0;--google-grey-500:#9e9e9e;--google-grey-700:#616161;--paper-red-50:#ffebee;--paper-red-100:#ffcdd2;--paper-red-200:#ef9a9a;--paper-red-300:#e57373;--paper-red-400:#ef5350;--paper-red-500:#f44336;--paper-red-600:#e53935;--paper-red-700:#d32f2f;--paper-red-800:#c62828;--paper-red-900:#b71c1c;--paper-red-a100:#ff8a80;--paper-red-a200:#ff5252;--paper-red-a400:#ff1744;--paper-red-a700:#d50000;--paper-pink-50:#fce4ec;--paper-pink-100:#f8bbd0;--paper-pink-200:#f48fb1;--paper-pink-300:#f06292;--paper-pink-400:#ec407a;--paper-pink-500:#e91e63;--paper-pink-600:#d81b60;--paper-pink-700:#c2185b;--paper-pink-800:#ad1457;--paper-pink-900:#880e4f;--paper-pink-a100:#ff80ab;--paper-pink-a200:#ff4081;--paper-pink-a400:#f50057;--paper-pink-a700:#c51162;--paper-purple-50:#f3e5f5;--paper-purple-100:#e1bee7;--paper-purple-200:#ce93d8;--paper-purple-300:#ba68c8;--paper-purple-400:#ab47bc;--paper-purple-500:#9c27b0;--paper-purple-600:#8e24aa;--paper-purple-700:#7b1fa2;--paper-purple-800:#6a1b9a;--paper-purple-900:#4a148c;--paper-purple-a100:#ea80fc;--paper-purple-a200:#e040fb;--paper-purple-a400:#d500f9;--paper-purple-a700:#aa00ff;--paper-deep-purple-50:#ede7f6;--paper-deep-purple-100:#d1c4e9;--paper-deep-purple-200:#b39ddb;--paper-deep-purple-300:#9575cd;--paper-deep-purple-400:#7e57c2;--paper-deep-purple-500:#673ab7;--paper-deep-purple-600:#5e35b1;--paper-deep-purple-700:#512da8;--paper-deep-purple-800:#4527a0;--paper-deep-purple-900:#311b92;--paper-deep-purple-a100:#b388ff;--paper-deep-purple-a200:#7c4dff;--paper-deep-purple-a400:#651fff;--paper-deep-purple-a700:#6200ea;--paper-indigo-50:#e8eaf6;--paper-indigo-100:#c5cae9;--paper-indigo-200:#9fa8da;--paper-indigo-300:#7986cb;--paper-indigo-400:#5c6bc0;--paper-indigo-500:#3f51b5;--paper-indigo-600:#3949ab;--paper-indigo-700:#303f9f;--paper-indigo-800:#283593;--paper-indigo-900:#1a237e;--paper-indigo-a100:#8c9eff;--paper-indigo-a200:#536dfe;--paper-indigo-a400:#3d5afe;--paper-indigo-a700:#304ffe;--paper-blue-50:#e3f2fd;--paper-blue-100:#bbdefb;--paper-blue-200:#90caf9;--paper-blue-300:#64b5f6;--paper-blue-400:#42a5f5;--paper-blue-500:#2196f3;--paper-blue-600:#1e88e5;--paper-blue-700:#1976d2;--paper-blue-800:#1565c0;--paper-blue-900:#0d47a1;--paper-blue-a100:#82b1ff;--paper-blue-a200:#448aff;--paper-blue-a400:#2979ff;--paper-blue-a700:#2962ff;--paper-light-blue-50:#e1f5fe;--paper-light-blue-100:#b3e5fc;--paper-light-blue-200:#81d4fa;--paper-light-blue-300:#4fc3f7;--paper-light-blue-400:#29b6f6;--paper-light-blue-500:#03a9f4;--paper-light-blue-600:#039be5;--paper-light-blue-700:#0288d1;--paper-light-blue-800:#0277bd;--paper-light-blue-900:#01579b;--paper-light-blue-a100:#80d8ff;--paper-light-blue-a200:#40c4ff;--paper-light-blue-a400:#00b0ff;--paper-light-blue-a700:#0091ea;--paper-cyan-50:#e0f7fa;--paper-cyan-100:#b2ebf2;--paper-cyan-200:#80deea;--paper-cyan-300:#4dd0e1;--paper-cyan-400:#26c6da;--paper-cyan-500:#00bcd4;--paper-cyan-600:#00acc1;--paper-cyan-700:#0097a7;--paper-cyan-800:#00838f;--paper-cyan-900:#006064;--paper-cyan-a100:#84ffff;--paper-cyan-a200:#18ffff;--paper-cyan-a400:#00e5ff;--paper-cyan-a700:#00b8d4;--paper-teal-50:#e0f2f1;--paper-teal-100:#b2dfdb;--paper-teal-200:#80cbc4;--paper-teal-300:#4db6ac;--paper-teal-400:#26a69a;--paper-teal-500:#009688;--paper-teal-600:#00897b;--paper-teal-700:#00796b;--paper-teal-800:#00695c;--paper-teal-900:#004d40;--paper-teal-a100:#a7ffeb;--paper-teal-a200:#64ffda;--paper-teal-a400:#1de9b6;--paper-teal-a700:#00bfa5;--paper-green-50:#e8f5e9;--paper-green-100:#c8e6c9;--paper-green-200:#a5d6a7;--paper-green-300:#81c784;--paper-green-400:#66bb6a;--paper-green-500:#4caf50;--paper-green-600:#43a047;--paper-green-700:#388e3c;--paper-green-800:#2e7d32;--paper-green-900:#1b5e20;--paper-green-a100:#b9f6ca;--paper-green-a200:#69f0ae;--paper-green-a400:#00e676;--paper-green-a700:#00c853;--paper-light-green-50:#f1f8e9;--paper-light-green-100:#dcedc8;--paper-light-green-200:#c5e1a5;--paper-light-green-300:#aed581;--paper-light-green-400:#9ccc65;--paper-light-green-500:#8bc34a;--paper-light-green-600:#7cb342;--paper-light-green-700:#689f38;--paper-light-green-800:#558b2f;--paper-light-green-900:#33691e;--paper-light-green-a100:#ccff90;--paper-light-green-a200:#b2ff59;--paper-light-green-a400:#76ff03;--paper-light-green-a700:#64dd17;--paper-lime-50:#f9fbe7;--paper-lime-100:#f0f4c3;--paper-lime-200:#e6ee9c;--paper-lime-300:#dce775;--paper-lime-400:#d4e157;--paper-lime-500:#cddc39;--paper-lime-600:#c0ca33;--paper-lime-700:#afb42b;--paper-lime-800:#9e9d24;--paper-lime-900:#827717;--paper-lime-a100:#f4ff81;--paper-lime-a200:#eeff41;--paper-lime-a400:#c6ff00;--paper-lime-a700:#aeea00;--paper-yellow-50:#fffde7;--paper-yellow-100:#fff9c4;--paper-yellow-200:#fff59d;--paper-yellow-300:#fff176;--paper-yellow-400:#ffee58;--paper-yellow-500:#ffeb3b;--paper-yellow-600:#fdd835;--paper-yellow-700:#fbc02d;--paper-yellow-800:#f9a825;--paper-yellow-900:#f57f17;--paper-yellow-a100:#ffff8d;--paper-yellow-a200:#ffff00;--paper-yellow-a400:#ffea00;--paper-yellow-a700:#ffd600;--paper-amber-50:#fff8e1;--paper-amber-100:#ffecb3;--paper-amber-200:#ffe082;--paper-amber-300:#ffd54f;--paper-amber-400:#ffca28;--paper-amber-500:#ffc107;--paper-amber-600:#ffb300;--paper-amber-700:#ffa000;--paper-amber-800:#ff8f00;--paper-amber-900:#ff6f00;--paper-amber-a100:#ffe57f;--paper-amber-a200:#ffd740;--paper-amber-a400:#ffc400;--paper-amber-a700:#ffab00;--paper-orange-50:#fff3e0;--paper-orange-100:#ffe0b2;--paper-orange-200:#ffcc80;--paper-orange-300:#ffb74d;--paper-orange-400:#ffa726;--paper-orange-500:#ff9800;--paper-orange-600:#fb8c00;--paper-orange-700:#f57c00;--paper-orange-800:#ef6c00;--paper-orange-900:#e65100;--paper-orange-a100:#ffd180;--paper-orange-a200:#ffab40;--paper-orange-a400:#ff9100;--paper-orange-a700:#ff6500;--paper-deep-orange-50:#fbe9e7;--paper-deep-orange-100:#ffccbc;--paper-deep-orange-200:#ffab91;--paper-deep-orange-300:#ff8a65;--paper-deep-orange-400:#ff7043;--paper-deep-orange-500:#ff5722;--paper-deep-orange-600:#f4511e;--paper-deep-orange-700:#e64a19;--paper-deep-orange-800:#d84315;--paper-deep-orange-900:#bf360c;--paper-deep-orange-a100:#ff9e80;--paper-deep-orange-a200:#ff6e40;--paper-deep-orange-a400:#ff3d00;--paper-deep-orange-a700:#dd2c00;--paper-brown-50:#efebe9;--paper-brown-100:#d7ccc8;--paper-brown-200:#bcaaa4;--paper-brown-300:#a1887f;--paper-brown-400:#8d6e63;--paper-brown-500:#795548;--paper-brown-600:#6d4c41;--paper-brown-700:#5d4037;--paper-brown-800:#4e342e;--paper-brown-900:#3e2723;--paper-grey-50:#fafafa;--paper-grey-100:#f5f5f5;--paper-grey-200:#eeeeee;--paper-grey-300:#e0e0e0;--paper-grey-400:#bdbdbd;--paper-grey-500:#9e9e9e;--paper-grey-600:#757575;--paper-grey-700:#616161;--paper-grey-800:#424242;--paper-grey-900:#212121;--paper-blue-grey-50:#eceff1;--paper-blue-grey-100:#cfd8dc;--paper-blue-grey-200:#b0bec5;--paper-blue-grey-300:#90a4ae;--paper-blue-grey-400:#78909c;--paper-blue-grey-500:#607d8b;--paper-blue-grey-600:#546e7a;--paper-blue-grey-700:#455a64;--paper-blue-grey-800:#37474f;--paper-blue-grey-900:#263238;--dark-divider-opacity:0.12;--dark-disabled-opacity:0.38;--dark-secondary-opacity:0.54;--dark-primary-opacity:0.87;--light-divider-opacity:0.12;--light-disabled-opacity:0.3;--light-secondary-opacity:0.7;--light-primary-opacity:1.0}</style> </custom-style>");

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

__webpack_require__(6);

__webpack_require__(44);

__webpack_require__(64);

__webpack_require__(66);

__webpack_require__(68);

__webpack_require__(69);

__webpack_require__(73);

__webpack_require__(74);

__webpack_require__(78);

__webpack_require__(79);

__webpack_require__(81);

__webpack_require__(31);

__webpack_require__(85);

var RegisterHtmlTemplate = __webpack_require__(2);

RegisterHtmlTemplate.register("<dom-module id=my-app> <template> <style>:host{--app-primary-color:#3D2814;--app-secondary-color:#FF3C3C;display:block}app-drawer-layout:not([narrow]) [drawer-toggle]{display:none}app-header{color:#fff;background-color:var(--app-primary-color)}app-header paper-icon-button{--paper-icon-button-ink-color:white}.drawer-list{margin:0 20px}.drawer-list a{display:block;padding:0 16px;text-decoration:none;color:var(--app-secondary-color);line-height:40px}.drawer-list a.iron-selected{color:#000;font-weight:700}</style> <app-location route={{route}} url-space-regex=^[[rootPath]]></app-location> <app-route route={{route}} pattern=[[rootPath]]:page data={{routeData}} tail={{subroute}}></app-route> <app-drawer-layout fullbleed=\"\"> <app-drawer id=drawer slot=drawer> <app-toolbar>Spiele</app-toolbar> <iron-selector selected=[[page]] attr-for-selected=name class=drawer-list role=navigation> <a name=view1 href$=[[rootPath]]view1>Spiele</a> <a name=view2 href$=[[rootPath]]view1>News</a> <a name=view2 href$=[[rootPath]]view2>Verlage</a> <a name=view3 href$=[[rootPath]]view3>Autoren</a> <a name=view3 href$=[[rootPath]]view3>Designer</a> <a name=view3 href$=[[rootPath]]view3>Rezensenionen</a> <a name=view3 href$=[[rootPath]]view3>Preise</a> <hr> <a name=view3 href$=[[rootPath]]view3>Sammlung</a> <a name=view3 href$=[[rootPath]]view3>Settings</a> </iron-selector> </app-drawer> <app-header-layout has-scrolling-region=\"\"> <app-header slot=header condenses=\"\" reveals=\"\" effects=waterfall> <app-toolbar> <paper-icon-button icon=my-icons:menu drawer-toggle=\"\"></paper-icon-button> <div main-title=\"\">Luding.org</div> </app-toolbar> </app-header> <iron-pages selected=[[page]] attr-for-selected=name fallback-selection=view404 role=main> <my-view1 name=view1></my-view1> <my-view2 name=view2></my-view2> <my-view3 name=view3></my-view3> <my-view404 name=view404></my-view404> </iron-pages> </app-header-layout> </app-drawer-layout> </template> </dom-module>");

var MyApp = function (_Polymer$Element) {
  _inherits(MyApp, _Polymer$Element);

  _createClass(MyApp, null, [{
    key: 'is',
    get: function get() {
      return 'my-app';
    }
  }, {
    key: 'properties',
    get: function get() {
      return {
        page: {
          type: String,
          reflectToAttribute: true,
          observer: '_pageChanged'
        },
        routeData: Object,
        subroute: String,
        rootPath: {
          type: String,
          value: '/'
        },
        lazyPages: {
          type: Object,
          value: {
            view1: function view1() {
              __webpack_require__.e/* import() */(0).then(__webpack_require__.bind(null, 86));
            },
            view2: function view2() {
              __webpack_require__.e/* import() */(2).then(__webpack_require__.bind(null, 87));
            },
            view3: function view3() {
              __webpack_require__.e/* import() */(1).then(__webpack_require__.bind(null, 88));
            },
            view404: function view404() {
              __webpack_require__.e/* import() */(3).then(__webpack_require__.bind(null, 89));
            }
          }
        }
      };
    }
  }, {
    key: 'observers',
    get: function get() {
      return ['_routePageChanged(routeData.page)'];
    }
  }]);

  function MyApp() {
    _classCallCheck(this, MyApp);

    return _possibleConstructorReturn(this, (MyApp.__proto__ || Object.getPrototypeOf(MyApp)).call(this));
  }

  _createClass(MyApp, [{
    key: '_routePageChanged',
    value: function _routePageChanged(page) {
      // Polymer 2.0 will call with `undefined` on initialization.
      // Ignore until we are properly called with a string.
      if (page === undefined) {
        return;
      }

      // If no page was found in the route data, page will be an empty string.
      // Deault to 'view1' in that case.
      this.page = page || 'view1';

      // Close a non-persistent drawer when the page & route are changed.
      if (!this.$.drawer.persistent) {
        this.$.drawer.close();
      }
    }
  }, {
    key: '_pageChanged',
    value: function _pageChanged(page) {
      if (this.lazyPages[page]) {
        this.lazyPages[page]();
      } else {
        this._showPage404();
      }
    }
  }, {
    key: '_showPage404',
    value: function _showPage404() {
      this.page = 'view404';
    }
  }]);

  return MyApp;
}(Polymer.Element);

window.customElements.define(MyApp.is, MyApp);

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

__webpack_require__(1);

__webpack_require__(7);

(function () {
  'use strict';

  var modules = {};
  var lcModules = {};
  function findModule(id) {
    return modules[id] || lcModules[id.toLowerCase()];
  }

  function styleOutsideTemplateCheck(inst) {
    if (inst.querySelector('style')) {
      console.warn('dom-module %s has style outside template', inst.id);
    }
  }

  /**
   * The `dom-module` element registers the dom it contains to the name given
   * by the module's id attribute. It provides a unified database of dom
   * accessible via its static `import` API.
   *
   * A key use case of `dom-module` is for providing custom element `<template>`s
   * via HTML imports that are parsed by the native HTML parser, that can be
   * relocated during a bundling pass and still looked up by `id`.
   *
   * Example:
   *
   *     <dom-module id="foo">
   *       <img src="stuff.png">
   *     </dom-module>
   *
   * Then in code in some other location that cannot access the dom-module above
   *
   *     let img = document.createElement('dom-module').import('foo', 'img');
   *
   * @customElement
   * @extends HTMLElement
   * @memberof Polymer
   * @summary Custom element that provides a registry of relocatable DOM content
   *   by `id` that is agnostic to bundling.
   * @unrestricted
   */

  var DomModule = function (_HTMLElement) {
    _inherits(DomModule, _HTMLElement);

    function DomModule() {
      _classCallCheck(this, DomModule);

      return _possibleConstructorReturn(this, (DomModule.__proto__ || Object.getPrototypeOf(DomModule)).apply(this, arguments));
    }

    _createClass(DomModule, [{
      key: 'attributeChangedCallback',
      value: function attributeChangedCallback(name, old, value) {
        if (old !== value) {
          this.register();
        }
      }

      /**
       * The absolute URL of the original location of this `dom-module`.
       *
       * This value will differ from this element's `ownerDocument` in the
       * following ways:
       * - Takes into account any `assetpath` attribute added during bundling
       *   to indicate the original location relative to the bundled location
       * - Uses the HTMLImports polyfill's `importForElement` API to ensure
       *   the path is relative to the import document's location since
       *   `ownerDocument` is not currently polyfilled
       */

    }, {
      key: 'register',


      /**
       * Registers the dom-module at a given id. This method should only be called
       * when a dom-module is imperatively created. For
       * example, `document.createElement('dom-module').register('foo')`.
       * @param {string=} id The id at which to register the dom-module.
       */
      value: function register(id) {
        id = id || this.id;
        if (id) {
          this.id = id;
          // store id separate from lowercased id so that
          // in all cases mixedCase id will stored distinctly
          // and lowercase version is a fallback
          modules[id] = this;
          lcModules[id.toLowerCase()] = this;
          styleOutsideTemplateCheck(this);
        }
      }
    }, {
      key: 'assetpath',
      get: function get() {
        // Don't override existing assetpath.
        if (!this.__assetpath) {
          // note: assetpath set via an attribute must be relative to this
          // element's location; accomodate polyfilled HTMLImports
          var owner = window.HTMLImports && HTMLImports.importForElement ? HTMLImports.importForElement(this) || document : this.ownerDocument;
          var url = Polymer.ResolveUrl.resolveUrl(this.getAttribute('assetpath') || '', owner.baseURI);
          this.__assetpath = Polymer.ResolveUrl.pathFromUrl(url);
        }
        return this.__assetpath;
      }
    }], [{
      key: 'import',


      /**
       * Retrieves the element specified by the css `selector` in the module
       * registered by `id`. For example, this.import('foo', 'img');
       * @param {string} id The id of the dom-module in which to search.
       * @param {string=} selector The css selector by which to find the element.
       * @return {Element} Returns the element which matches `selector` in the
       * module registered at the specified `id`.
       */
      value: function _import(id, selector) {
        if (id) {
          var m = findModule(id);
          if (m && selector) {
            return m.querySelector(selector);
          }
          return m;
        }
        return null;
      }
    }, {
      key: 'observedAttributes',
      get: function get() {
        return ['id'];
      }
    }]);

    return DomModule;
  }(HTMLElement);

  DomModule.prototype['modules'] = modules;

  customElements.define('dom-module', DomModule);

  // export
  Polymer.DomModule = DomModule;
})();

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(1);

(function () {
  'use strict';

  /**
   * Module with utilities for manipulating structured data path strings.
   *
   * @namespace
   * @memberof Polymer
   * @summary Module with utilities for manipulating structured data path strings.
   */

  var Path = {

    /**
     * Returns true if the given string is a structured data path (has dots).
     *
     * Example:
     *
     * ```
     * Polymer.Path.isPath('foo.bar.baz') // true
     * Polymer.Path.isPath('foo')         // false
     * ```
     *
     * @memberof Polymer.Path
     * @param {string} path Path string
     * @return {boolean} True if the string contained one or more dots
     */
    isPath: function isPath(path) {
      return path.indexOf('.') >= 0;
    },

    /**
     * Returns the root property name for the given path.
     *
     * Example:
     *
     * ```
     * Polymer.Path.root('foo.bar.baz') // 'foo'
     * Polymer.Path.root('foo')         // 'foo'
     * ```
     *
     * @memberof Polymer.Path
     * @param {string} path Path string
     * @return {string} Root property name
     */
    root: function root(path) {
      var dotIndex = path.indexOf('.');
      if (dotIndex === -1) {
        return path;
      }
      return path.slice(0, dotIndex);
    },

    /**
     * Given `base` is `foo.bar`, `foo` is an ancestor, `foo.bar` is not
     * Returns true if the given path is an ancestor of the base path.
     *
     * Example:
     *
     * ```
     * Polymer.Path.isAncestor('foo.bar', 'foo')         // true
     * Polymer.Path.isAncestor('foo.bar', 'foo.bar')     // false
     * Polymer.Path.isAncestor('foo.bar', 'foo.bar.baz') // false
     * ```
     *
     * @memberof Polymer.Path
     * @param {string} base Path string to test against.
     * @param {string} path Path string to test.
     * @return {boolean} True if `path` is an ancestor of `base`.
     */
    isAncestor: function isAncestor(base, path) {
      //     base.startsWith(path + '.');
      return base.indexOf(path + '.') === 0;
    },

    /**
     * Given `base` is `foo.bar`, `foo.bar.baz` is an descendant
     *
     * Example:
     *
     * ```
     * Polymer.Path.isDescendant('foo.bar', 'foo.bar.baz') // true
     * Polymer.Path.isDescendant('foo.bar', 'foo.bar')     // false
     * Polymer.Path.isDescendant('foo.bar', 'foo')         // false
     * ```
     *
     * @memberof Polymer.Path
     * @param {string} base Path string to test against.
     * @param {string} path Path string to test.
     * @return {boolean} True if `path` is a descendant of `base`.
     */
    isDescendant: function isDescendant(base, path) {
      //     path.startsWith(base + '.');
      return path.indexOf(base + '.') === 0;
    },

    /**
     * Replaces a previous base path with a new base path, preserving the
     * remainder of the path.
     *
     * User must ensure `path` has a prefix of `base`.
     *
     * Example:
     *
     * ```
     * Polymer.Path.translate('foo.bar', 'zot' 'foo.bar.baz') // 'zot.baz'
     * ```
     *
     * @memberof Polymer.Path
     * @param {string} base Current base string to remove
     * @param {string} newBase New base string to replace with
     * @param {string} path Path to translate
     * @return {string} Translated string
     */
    translate: function translate(base, newBase, path) {
      return newBase + path.slice(base.length);
    },

    /**
     * @param {string} base Path string to test against
     * @param {string} path Path string to test
     * @return {boolean} True if `path` is equal to `base`
     * @this {Path}
     */
    matches: function matches(base, path) {
      return base === path || this.isAncestor(base, path) || this.isDescendant(base, path);
    },

    /**
     * Converts array-based paths to flattened path.  String-based paths
     * are returned as-is.
     *
     * Example:
     *
     * ```
     * Polymer.Path.normalize(['foo.bar', 0, 'baz'])  // 'foo.bar.0.baz'
     * Polymer.Path.normalize('foo.bar.0.baz')        // 'foo.bar.0.baz'
     * ```
     *
     * @memberof Polymer.Path
     * @param {string | !Array<string|number>} path Input path
     * @return {string} Flattened path
     */
    normalize: function normalize(path) {
      if (Array.isArray(path)) {
        var parts = [];
        for (var i = 0; i < path.length; i++) {
          var args = path[i].toString().split('.');
          for (var j = 0; j < args.length; j++) {
            parts.push(args[j]);
          }
        }
        return parts.join('.');
      } else {
        return path;
      }
    },

    /**
     * Splits a path into an array of property names. Accepts either arrays
     * of path parts or strings.
     *
     * Example:
     *
     * ```
     * Polymer.Path.split(['foo.bar', 0, 'baz'])  // ['foo', 'bar', '0', 'baz']
     * Polymer.Path.split('foo.bar.0.baz')        // ['foo', 'bar', '0', 'baz']
     * ```
     *
     * @memberof Polymer.Path
     * @param {string | !Array<string|number>} path Input path
     * @return {!Array<string>} Array of path parts
     * @this {Path}
     * @suppress {checkTypes}
     */
    split: function split(path) {
      if (Array.isArray(path)) {
        return this.normalize(path).split('.');
      }
      return path.toString().split('.');
    },

    /**
     * Reads a value from a path.  If any sub-property in the path is `undefined`,
     * this method returns `undefined` (will never throw.
     *
     * @memberof Polymer.Path
     * @param {Object} root Object from which to dereference path from
     * @param {string | !Array<string|number>} path Path to read
     * @param {Object=} info If an object is provided to `info`, the normalized
     *  (flattened) path will be set to `info.path`.
     * @return {*} Value at path, or `undefined` if the path could not be
     *  fully dereferenced.
     * @this {Path}
     */
    get: function get(root, path, info) {
      var prop = root;
      var parts = this.split(path);
      // Loop over path parts[0..n-1] and dereference
      for (var i = 0; i < parts.length; i++) {
        if (!prop) {
          return;
        }
        var part = parts[i];
        prop = prop[part];
      }
      if (info) {
        info.path = parts.join('.');
      }
      return prop;
    },

    /**
     * Sets a value to a path.  If any sub-property in the path is `undefined`,
     * this method will no-op.
     *
     * @memberof Polymer.Path
     * @param {Object} root Object from which to dereference path from
     * @param {string | !Array<string|number>} path Path to set
     * @param {*} value Value to set to path
     * @return {string | undefined} The normalized version of the input path
     * @this {Path}
     */
    set: function set(root, path, value) {
      var prop = root;
      var parts = this.split(path);
      var last = parts[parts.length - 1];
      if (parts.length > 1) {
        // Loop over path parts[0..n-2] and dereference
        for (var i = 0; i < parts.length - 1; i++) {
          var part = parts[i];
          prop = prop[part];
          if (!prop) {
            return;
          }
        }
        // Set value to object at end of path
        prop[last] = value;
      } else {
        // Simple property set
        prop[path] = value;
      }
      return parts.join('.');
    }

  };

  /**
   * Returns true if the given string is a structured data path (has dots).
   *
   * This function is deprecated.  Use `Polymer.Path.isPath` instead.
   *
   * Example:
   *
   * ```
   * Polymer.Path.isDeep('foo.bar.baz') // true
   * Polymer.Path.isDeep('foo')         // false
   * ```
   *
   * @deprecated
   * @memberof Polymer.Path
   * @param {string} path Path string
   * @return {boolean} True if the string contained one or more dots
   */
  Path.isDeep = Path.isPath;

  Polymer.Path = Path;
})();

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

__webpack_require__(1);

__webpack_require__(3);

__webpack_require__(10);

__webpack_require__(8);

(function () {

  'use strict';

  var caseMap = Polymer.CaseMap;

  var microtask = Polymer.Async.microTask;

  // Save map of native properties; this forms a blacklist or properties
  // that won't have their values "saved" by `saveAccessorValue`, since
  // reading from an HTMLElement accessor from the context of a prototype throws
  var nativeProperties = {};
  var proto = HTMLElement.prototype;
  while (proto) {
    var props = Object.getOwnPropertyNames(proto);
    for (var i = 0; i < props.length; i++) {
      nativeProperties[props[i]] = true;
    }
    proto = Object.getPrototypeOf(proto);
  }

  /**
   * Used to save the value of a property that will be overridden with
   * an accessor. If the `model` is a prototype, the values will be saved
   * in `__dataProto`, and it's up to the user (or downstream mixin) to
   * decide how/when to set these values back into the accessors.
   * If `model` is already an instance (it has a `__data` property), then
   * the value will be set as a pending property, meaning the user should
   * call `_invalidateProperties` or `_flushProperties` to take effect
   *
   * @param {Object} model Prototype or instance
   * @param {string} property Name of property
   * @private
   */
  function saveAccessorValue(model, property) {
    // Don't read/store value for any native properties since they could throw
    if (!nativeProperties[property]) {
      var value = model[property];
      if (value !== undefined) {
        if (model.__data) {
          // Adding accessor to instance; update the property
          // It is the user's responsibility to call _flushProperties
          model._setPendingProperty(property, value);
        } else {
          // Adding accessor to proto; save proto's value for instance-time use
          if (!model.__dataProto) {
            model.__dataProto = {};
          } else if (!model.hasOwnProperty(JSCompiler_renameProperty('__dataProto', model))) {
            model.__dataProto = Object.create(model.__dataProto);
          }
          model.__dataProto[property] = value;
        }
      }
    }
  }

  /**
   * Element class mixin that provides basic meta-programming for creating one
   * or more property accessors (getter/setter pair) that enqueue an async
   * (batched) `_propertiesChanged` callback.
   *
   * For basic usage of this mixin, simply declare attributes to observe via
   * the standard `static get observedAttributes()`, implement `_propertiesChanged`
   * on the class, and then call `MyClass.createPropertiesForAttributes()` once
   * on the class to generate property accessors for each observed attribute
   * prior to instancing.  Last, call `this._flushProperties()` once to enable
   * the accessors.
   *
   * Any `observedAttributes` will automatically be
   * deserialized via `attributeChangedCallback` and set to the associated
   * property using `dash-case`-to-`camelCase` convention.
   *
   * @mixinFunction
   * @polymer
   * @memberof Polymer
   * @summary Element class mixin for reacting to property changes from
   *   generated property accessors.
   */
  Polymer.PropertyAccessors = Polymer.dedupingMixin(function (superClass) {

    /**
     * @polymer
     * @mixinClass
     * @implements {Polymer_PropertyAccessors}
     * @extends HTMLElement
     * @unrestricted
     */
    var PropertyAccessors = function (_superClass) {
      _inherits(PropertyAccessors, _superClass);

      _createClass(PropertyAccessors, null, [{
        key: 'createPropertiesForAttributes',


        /**
         * Generates property accessors for all attributes in the standard
         * static `observedAttributes` array.
         *
         * Attribute names are mapped to property names using the `dash-case` to
         * `camelCase` convention
         *
         */
        value: function createPropertiesForAttributes() {
          var a$ = this.observedAttributes;
          for (var _i = 0; _i < a$.length; _i++) {
            this.prototype._createPropertyAccessor(caseMap.dashToCamelCase(a$[_i]));
          }
        }
      }]);

      function PropertyAccessors() {
        _classCallCheck(this, PropertyAccessors);

        /** @type {boolean} */
        var _this = _possibleConstructorReturn(this, (PropertyAccessors.__proto__ || Object.getPrototypeOf(PropertyAccessors)).call(this));

        _this.__serializing;
        /** @type {number} */
        _this.__dataCounter;
        /** @type {boolean} */
        _this.__dataEnabled;
        /** @type {boolean} */
        _this.__dataReady;
        /** @type {boolean} */
        _this.__dataInvalid;
        /** @type {!Object} */
        _this.__data;
        /** @type {Object} */
        _this.__dataPending;
        /** @type {Object} */
        _this.__dataOld;
        /** @type {Object} */
        _this.__dataProto;
        /** @type {Object} */
        _this.__dataHasAccessor;
        /** @type {Object} */
        _this.__dataInstanceProps;
        _this._initializeProperties();
        return _this;
      }

      /**
       * Implements native Custom Elements `attributeChangedCallback` to
       * set an attribute value to a property via `_attributeToProperty`.
       *
       * @param {string} name Name of attribute that changed
       * @param {?string} old Old attribute value
       * @param {?string} value New attribute value
       */


      _createClass(PropertyAccessors, [{
        key: 'attributeChangedCallback',
        value: function attributeChangedCallback(name, old, value) {
          if (old !== value) {
            this._attributeToProperty(name, value);
          }
        }

        /**
         * Initializes the local storage for property accessors.
         *
         * Provided as an override point for performing any setup work prior
         * to initializing the property accessor system.
         *
         * @protected
         */

      }, {
        key: '_initializeProperties',
        value: function _initializeProperties() {
          this.__serializing = false;
          this.__dataCounter = 0;
          this.__dataEnabled = false;
          this.__dataReady = false;
          this.__dataInvalid = false;
          this.__data = {};
          this.__dataPending = null;
          this.__dataOld = null;
          if (this.__dataProto) {
            this._initializeProtoProperties(this.__dataProto);
            this.__dataProto = null;
          }
          // Capture instance properties; these will be set into accessors
          // during first flush. Don't set them here, since we want
          // these to overwrite defaults/constructor assignments
          for (var p in this.__dataHasAccessor) {
            if (this.hasOwnProperty(p)) {
              this.__dataInstanceProps = this.__dataInstanceProps || {};
              this.__dataInstanceProps[p] = this[p];
              delete this[p];
            }
          }
        }

        /**
         * Called at instance time with bag of properties that were overwritten
         * by accessors on the prototype when accessors were created.
         *
         * The default implementation sets these properties back into the
         * setter at instance time.  This method is provided as an override
         * point for customizing or providing more efficient initialization.
         *
         * @param {Object} props Bag of property values that were overwritten
         *   when creating property accessors.
         * @protected
         */

      }, {
        key: '_initializeProtoProperties',
        value: function _initializeProtoProperties(props) {
          for (var p in props) {
            this._setProperty(p, props[p]);
          }
        }

        /**
         * Called at ready time with bag of instance properties that overwrote
         * accessors when the element upgraded.
         *
         * The default implementation sets these properties back into the
         * setter at ready time.  This method is provided as an override
         * point for customizing or providing more efficient initialization.
         *
         * @param {Object} props Bag of property values that were overwritten
         *   when creating property accessors.
         * @protected
         */

      }, {
        key: '_initializeInstanceProperties',
        value: function _initializeInstanceProperties(props) {
          Object.assign(this, props);
        }

        /**
         * Ensures the element has the given attribute. If it does not,
         * assigns the given value to the attribute.
         *
         *
         * @param {string} attribute Name of attribute to ensure is set.
         * @param {string} value of the attribute.
         */

      }, {
        key: '_ensureAttribute',
        value: function _ensureAttribute(attribute, value) {
          if (!this.hasAttribute(attribute)) {
            this._valueToNodeAttribute(this, value, attribute);
          }
        }

        /**
         * Deserializes an attribute to its associated property.
         *
         * This method calls the `_deserializeValue` method to convert the string to
         * a typed value.
         *
         * @param {string} attribute Name of attribute to deserialize.
         * @param {?string} value of the attribute.
         * @param {*=} type type to deserialize to.
         */

      }, {
        key: '_attributeToProperty',
        value: function _attributeToProperty(attribute, value, type) {
          // Don't deserialize back to property if currently reflecting
          if (!this.__serializing) {
            var property = caseMap.dashToCamelCase(attribute);
            this[property] = this._deserializeValue(value, type);
          }
        }

        /**
         * Serializes a property to its associated attribute.
         *
         * @param {string} property Property name to reflect.
         * @param {string=} attribute Attribute name to reflect.
         * @param {*=} value Property value to refect.
         */

      }, {
        key: '_propertyToAttribute',
        value: function _propertyToAttribute(property, attribute, value) {
          this.__serializing = true;
          value = arguments.length < 3 ? this[property] : value;
          this._valueToNodeAttribute(this, value, attribute || caseMap.camelToDashCase(property));
          this.__serializing = false;
        }

        /**
         * Sets a typed value to an HTML attribute on a node.
         *
         * This method calls the `_serializeValue` method to convert the typed
         * value to a string.  If the `_serializeValue` method returns `undefined`,
         * the attribute will be removed (this is the default for boolean
         * type `false`).
         *
         * @param {Element} node Element to set attribute to.
         * @param {*} value Value to serialize.
         * @param {string} attribute Attribute name to serialize to.
         */

      }, {
        key: '_valueToNodeAttribute',
        value: function _valueToNodeAttribute(node, value, attribute) {
          var str = this._serializeValue(value);
          if (str === undefined) {
            node.removeAttribute(attribute);
          } else {
            node.setAttribute(attribute, str);
          }
        }

        /**
         * Converts a typed JavaScript value to a string.
         *
         * This method is called by Polymer when setting JS property values to
         * HTML attributes.  Users may override this method on Polymer element
         * prototypes to provide serialization for custom types.
         *
         * @param {*} value Property value to serialize.
         * @return {string | undefined} String serialized from the provided property value.
         */

      }, {
        key: '_serializeValue',
        value: function _serializeValue(value) {
          /* eslint-disable no-fallthrough */
          switch (typeof value === 'undefined' ? 'undefined' : _typeof(value)) {
            case 'boolean':
              return value ? '' : undefined;

            case 'object':
              if (value instanceof Date) {
                return value.toString();
              } else if (value) {
                try {
                  return JSON.stringify(value);
                } catch (x) {
                  return '';
                }
              }

            default:
              return value != null ? value.toString() : undefined;
          }
        }

        /**
         * Converts a string to a typed JavaScript value.
         *
         * This method is called by Polymer when reading HTML attribute values to
         * JS properties.  Users may override this method on Polymer element
         * prototypes to provide deserialization for custom `type`s.  Note,
         * the `type` argument is the value of the `type` field provided in the
         * `properties` configuration object for a given property, and is
         * by convention the constructor for the type to deserialize.
         *
         * Note: The return value of `undefined` is used as a sentinel value to
         * indicate the attribute should be removed.
         *
         * @param {?string} value Attribute value to deserialize.
         * @param {*=} type Type to deserialize the string to.
         * @return {*} Typed value deserialized from the provided string.
         */

      }, {
        key: '_deserializeValue',
        value: function _deserializeValue(value, type) {
          /**
           * @type {*}
           */
          var outValue = void 0;
          switch (type) {
            case Number:
              outValue = Number(value);
              break;

            case Boolean:
              outValue = value !== null;
              break;

            case Object:
              try {
                outValue = JSON.parse( /** @type string */value);
              } catch (x) {
                // allow non-JSON literals like Strings and Numbers
              }
              break;

            case Array:
              try {
                outValue = JSON.parse( /** @type string */value);
              } catch (x) {
                outValue = null;
                console.warn('Polymer::Attributes: couldn\'t decode Array as JSON: ' + value);
              }
              break;

            case Date:
              outValue = new Date(value);
              break;

            case String:
            default:
              outValue = value;
              break;
          }

          return outValue;
        }
        /* eslint-enable no-fallthrough */

        /**
         * Creates a setter/getter pair for the named property with its own
         * local storage.  The getter returns the value in the local storage,
         * and the setter calls `_setProperty`, which updates the local storage
         * for the property and enqueues a `_propertiesChanged` callback.
         *
         * This method may be called on a prototype or an instance.  Calling
         * this method may overwrite a property value that already exists on
         * the prototype/instance by creating the accessor.  When calling on
         * a prototype, any overwritten values are saved in `__dataProto`,
         * and it is up to the subclasser to decide how/when to set those
         * properties back into the accessor.  When calling on an instance,
         * the overwritten value is set via `_setPendingProperty`, and the
         * user should call `_invalidateProperties` or `_flushProperties`
         * for the values to take effect.
         *
         * @param {string} property Name of the property
         * @param {boolean=} readOnly When true, no setter is created; the
         *   protected `_setProperty` function must be used to set the property
         * @protected
         */

      }, {
        key: '_createPropertyAccessor',
        value: function _createPropertyAccessor(property, readOnly) {
          if (!this.hasOwnProperty('__dataHasAccessor')) {
            this.__dataHasAccessor = Object.assign({}, this.__dataHasAccessor);
          }
          if (!this.__dataHasAccessor[property]) {
            this.__dataHasAccessor[property] = true;
            saveAccessorValue(this, property);
            Object.defineProperty(this, property, {
              /* eslint-disable valid-jsdoc */
              /** @this {PropertyAccessors} */
              get: function get() {
                return this.__data[property];
              },
              /** @this {PropertyAccessors} */
              set: readOnly ? function () {} : function (value) {
                this._setProperty(property, value);
              }
              /* eslint-enable */
            });
          }
        }

        /**
         * Returns true if this library created an accessor for the given property.
         *
         * @param {string} property Property name
         * @return {boolean} True if an accessor was created
         */

      }, {
        key: '_hasAccessor',
        value: function _hasAccessor(property) {
          return this.__dataHasAccessor && this.__dataHasAccessor[property];
        }

        /**
         * Updates the local storage for a property (via `_setPendingProperty`)
         * and enqueues a `_proeprtiesChanged` callback.
         *
         * @param {string} property Name of the property
         * @param {*} value Value to set
         * @protected
         */

      }, {
        key: '_setProperty',
        value: function _setProperty(property, value) {
          if (this._setPendingProperty(property, value)) {
            this._invalidateProperties();
          }
        }

        /**
         * Updates the local storage for a property, records the previous value,
         * and adds it to the set of "pending changes" that will be passed to the
         * `_propertiesChanged` callback.  This method does not enqueue the
         * `_propertiesChanged` callback.
         *
         * @param {string} property Name of the property
         * @param {*} value Value to set
         * @return {boolean} Returns true if the property changed
         * @protected
         */

      }, {
        key: '_setPendingProperty',
        value: function _setPendingProperty(property, value) {
          var old = this.__data[property];
          var changed = this._shouldPropertyChange(property, value, old);
          if (changed) {
            if (!this.__dataPending) {
              this.__dataPending = {};
              this.__dataOld = {};
            }
            // Ensure old is captured from the last turn
            if (this.__dataOld && !(property in this.__dataOld)) {
              this.__dataOld[property] = old;
            }
            this.__data[property] = value;
            this.__dataPending[property] = value;
          }
          return changed;
        }

        /**
         * Returns true if the specified property has a pending change.
         *
         * @param {string} prop Property name
         * @return {boolean} True if property has a pending change
         * @protected
         */

      }, {
        key: '_isPropertyPending',
        value: function _isPropertyPending(prop) {
          return Boolean(this.__dataPending && prop in this.__dataPending);
        }

        /**
         * Marks the properties as invalid, and enqueues an async
         * `_propertiesChanged` callback.
         *
         * @protected
         */

      }, {
        key: '_invalidateProperties',
        value: function _invalidateProperties() {
          var _this2 = this;

          if (!this.__dataInvalid && this.__dataReady) {
            this.__dataInvalid = true;
            microtask.run(function () {
              if (_this2.__dataInvalid) {
                _this2.__dataInvalid = false;
                _this2._flushProperties();
              }
            });
          }
        }

        /**
         * Call to enable property accessor processing. Before this method is
         * called accessor values will be set but side effects are
         * queued. When called, any pending side effects occur immediately.
         * For elements, generally `connectedCallback` is a normal spot to do so.
         * It is safe to call this method multiple times as it only turns on
         * property accessors once.
         */

      }, {
        key: '_enableProperties',
        value: function _enableProperties() {
          if (!this.__dataEnabled) {
            this.__dataEnabled = true;
            if (this.__dataInstanceProps) {
              this._initializeInstanceProperties(this.__dataInstanceProps);
              this.__dataInstanceProps = null;
            }
            this.ready();
          }
        }

        /**
         * Calls the `_propertiesChanged` callback with the current set of
         * pending changes (and old values recorded when pending changes were
         * set), and resets the pending set of changes. Generally, this method
         * should not be called in user code.
         *
         *
         * @protected
         */

      }, {
        key: '_flushProperties',
        value: function _flushProperties() {
          if (this.__dataPending && this.__dataOld) {
            var changedProps = this.__dataPending;
            this.__dataPending = null;
            this.__dataCounter++;
            this._propertiesChanged(this.__data, changedProps, this.__dataOld);
            this.__dataCounter--;
          }
        }

        /**
         * Lifecycle callback called the first time properties are being flushed.
         * Prior to `ready`, all property sets through accessors are queued and
         * their effects are flushed after this method returns.
         *
         * Users may override this function to implement behavior that is
         * dependent on the element having its properties initialized, e.g.
         * from defaults (initialized from `constructor`, `_initializeProperties`),
         * `attributeChangedCallback`, or values propagated from host e.g. via
         * bindings.  `super.ready()` must be called to ensure the data system
         * becomes enabled.
         *
         * @public
         */

      }, {
        key: 'ready',
        value: function ready() {
          this.__dataReady = true;
          // Run normal flush
          this._flushProperties();
        }

        /**
         * Callback called when any properties with accessors created via
         * `_createPropertyAccessor` have been set.
         *
         * @param {!Object} currentProps Bag of all current accessor values
         * @param {!Object} changedProps Bag of properties changed since the last
         *   call to `_propertiesChanged`
         * @param {!Object} oldProps Bag of previous values for each property
         *   in `changedProps`
         * @protected
         */

      }, {
        key: '_propertiesChanged',
        value: function _propertiesChanged(currentProps, changedProps, oldProps) {} // eslint-disable-line no-unused-vars


        /**
         * Method called to determine whether a property value should be
         * considered as a change and cause the `_propertiesChanged` callback
         * to be enqueued.
         *
         * The default implementation returns `true` for primitive types if a
         * strict equality check fails, and returns `true` for all Object/Arrays.
         * The method always returns false for `NaN`.
         *
         * Override this method to e.g. provide stricter checking for
         * Objects/Arrays when using immutable patterns.
         *
         * @param {string} property Property name
         * @param {*} value New property value
         * @param {*} old Previous property value
         * @return {boolean} Whether the property should be considered a change
         *   and enqueue a `_proeprtiesChanged` callback
         * @protected
         */

      }, {
        key: '_shouldPropertyChange',
        value: function _shouldPropertyChange(property, value, old) {
          return (
            // Strict equality check
            old !== value && (
            // This ensures (old==NaN, value==NaN) always returns false
            old === old || value === value)
          );
        }
      }]);

      return PropertyAccessors;
    }(superClass);

    return PropertyAccessors;
  });
})();

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

__webpack_require__(1);

__webpack_require__(3);

(function () {

  'use strict';

  // 1.x backwards-compatible auto-wrapper for template type extensions
  // This is a clear layering violation and gives favored-nation status to
  // dom-if and dom-repeat templates.  This is a conceit we're choosing to keep
  // a.) to ease 1.x backwards-compatibility due to loss of `is`, and
  // b.) to maintain if/repeat capability in parser-constrained elements
  //     (e.g. table, select) in lieu of native CE type extensions without
  //     massive new invention in this space (e.g. directive system)

  var templateExtensions = {
    'dom-if': true,
    'dom-repeat': true
  };
  function wrapTemplateExtension(node) {
    var is = node.getAttribute('is');
    if (is && templateExtensions[is]) {
      var t = node;
      t.removeAttribute('is');
      node = t.ownerDocument.createElement(is);
      t.parentNode.replaceChild(node, t);
      node.appendChild(t);
      while (t.attributes.length) {
        node.setAttribute(t.attributes[0].name, t.attributes[0].value);
        t.removeAttribute(t.attributes[0].name);
      }
    }
    return node;
  }

  function findTemplateNode(root, nodeInfo) {
    // recursively ascend tree until we hit root
    var parent = nodeInfo.parentInfo && findTemplateNode(root, nodeInfo.parentInfo);
    // unwind the stack, returning the indexed node at each level
    if (parent) {
      // note: marginally faster than indexing via childNodes
      // (http://jsperf.com/childnodes-lookup)
      for (var n = parent.firstChild, i = 0; n; n = n.nextSibling) {
        if (nodeInfo.parentIndex === i++) {
          return n;
        }
      }
    } else {
      return root;
    }
  }

  // construct `$` map (from id annotations)
  function applyIdToMap(inst, map, node, nodeInfo) {
    if (nodeInfo.id) {
      map[nodeInfo.id] = node;
    }
  }

  // install event listeners (from event annotations)
  function applyEventListener(inst, node, nodeInfo) {
    if (nodeInfo.events && nodeInfo.events.length) {
      for (var j = 0, e$ = nodeInfo.events, e; j < e$.length && (e = e$[j]); j++) {
        inst._addMethodEventListenerToNode(node, e.name, e.value, inst);
      }
    }
  }

  // push configuration references at configure time
  function applyTemplateContent(inst, node, nodeInfo) {
    if (nodeInfo.templateInfo) {
      node._templateInfo = nodeInfo.templateInfo;
    }
  }

  function createNodeEventHandler(context, eventName, methodName) {
    // Instances can optionally have a _methodHost which allows redirecting where
    // to find methods. Currently used by `templatize`.
    context = context._methodHost || context;
    var handler = function handler(e) {
      if (context[methodName]) {
        context[methodName](e, e.detail);
      } else {
        console.warn('listener method `' + methodName + '` not defined');
      }
    };
    return handler;
  }

  /**
   * Element mixin that provides basic template parsing and stamping, including
   * the following template-related features for stamped templates:
   *
   * - Declarative event listeners (`on-eventname="listener"`)
   * - Map of node id's to stamped node instances (`this.$.id`)
   * - Nested template content caching/removal and re-installation (performance
   *   optimization)
   *
   * @mixinFunction
   * @polymer
   * @memberof Polymer
   * @summary Element class mixin that provides basic template parsing and stamping
   */
  Polymer.TemplateStamp = Polymer.dedupingMixin(function (superClass) {

    /**
     * @polymer
     * @mixinClass
     * @implements {Polymer_TemplateStamp}
     */
    var TemplateStamp = function (_superClass) {
      _inherits(TemplateStamp, _superClass);

      function TemplateStamp() {
        _classCallCheck(this, TemplateStamp);

        return _possibleConstructorReturn(this, (TemplateStamp.__proto__ || Object.getPrototypeOf(TemplateStamp)).apply(this, arguments));
      }

      _createClass(TemplateStamp, [{
        key: '_stampTemplate',


        /**
         * Clones the provided template content and returns a document fragment
         * containing the cloned dom.
         *
         * The template is parsed (once and memoized) using this library's
         * template parsing features, and provides the following value-added
         * features:
         * * Adds declarative event listeners for `on-event="handler"` attributes
         * * Generates an "id map" for all nodes with id's under `$` on returned
         *   document fragment
         * * Passes template info including `content` back to templates as
         *   `_templateInfo` (a performance optimization to avoid deep template
         *   cloning)
         *
         * Note that the memoized template parsing process is destructive to the
         * template: attributes for bindings and declarative event listeners are
         * removed after being noted in notes, and any nested `<template>.content`
         * is removed and stored in notes as well.
         *
         * @param {!HTMLTemplateElement} template Template to stamp
         * @return {!StampedTemplate} Cloned template content
         */
        value: function _stampTemplate(template) {
          // Polyfill support: bootstrap the template if it has not already been
          if (template && !template.content && window.HTMLTemplateElement && HTMLTemplateElement.decorate) {
            HTMLTemplateElement.decorate(template);
          }
          var templateInfo = this.constructor._parseTemplate(template);
          var nodeInfo = templateInfo.nodeInfoList;
          var content = templateInfo.content || template.content;
          var dom = /** @type DocumentFragment */document.importNode(content, true);
          // NOTE: ShadyDom optimization indicating there is an insertion point
          dom.__noInsertionPoint = !templateInfo.hasInsertionPoint;
          var nodes = dom.nodeList = new Array(nodeInfo.length);
          dom.$ = {};
          for (var i = 0, l = nodeInfo.length, info; i < l && (info = nodeInfo[i]); i++) {
            var node = nodes[i] = findTemplateNode(dom, info);
            applyIdToMap(this, dom.$, node, info);
            applyTemplateContent(this, node, info);
            applyEventListener(this, node, info);
          }
          return (/** @type {!StampedTemplate} */dom
          );
        }

        /**
         * Adds an event listener by method name for the event provided.
         *
         * This method generates a handler function that looks up the method
         * name at handling time.
         *
         * @param {Node} node Node to add listener on
         * @param {string} eventName Name of event
         * @param {string} methodName Name of method
         * @param {*=} context Context the method will be called on (defaults
         *   to `node`)
         * @return {Function} Generated handler function
         */

      }, {
        key: '_addMethodEventListenerToNode',
        value: function _addMethodEventListenerToNode(node, eventName, methodName, context) {
          context = context || node;
          var handler = createNodeEventHandler(context, eventName, methodName);
          this._addEventListenerToNode(node, eventName, handler);
          return handler;
        }

        /**
         * Override point for adding custom or simulated event handling.
         *
         * @param {Node} node Node to add event listener to
         * @param {string} eventName Name of event
         * @param {Function} handler Listener function to add
         */

      }, {
        key: '_addEventListenerToNode',
        value: function _addEventListenerToNode(node, eventName, handler) {
          node.addEventListener(eventName, handler);
        }

        /**
         * Override point for adding custom or simulated event handling.
         *
         * @param {Node} node Node to remove event listener from
         * @param {string} eventName Name of event
         * @param {Function} handler Listener function to remove
         */

      }, {
        key: '_removeEventListenerFromNode',
        value: function _removeEventListenerFromNode(node, eventName, handler) {
          node.removeEventListener(eventName, handler);
        }
      }], [{
        key: '_parseTemplate',


        /**
         * Scans a template to produce template metadata.
         *
         * Template-specific metadata are stored in the object returned, and node-
         * specific metadata are stored in objects in its flattened `nodeInfoList`
         * array.  Only nodes in the template that were parsed as nodes of
         * interest contain an object in `nodeInfoList`.  Each `nodeInfo` object
         * contains an `index` (`childNodes` index in parent) and optionally
         * `parent`, which points to node info of its parent (including its index).
         *
         * The template metadata object returned from this method has the following
         * structure (many fields optional):
         *
         * ```js
         *   {
         *     // Flattened list of node metadata (for nodes that generated metadata)
         *     nodeInfoList: [
         *       {
         *         // `id` attribute for any nodes with id's for generating `$` map
         *         id: {string},
         *         // `on-event="handler"` metadata
         *         events: [
         *           {
         *             name: {string},   // event name
         *             value: {string},  // handler method name
         *           }, ...
         *         ],
         *         // Notes when the template contained a `<slot>` for shady DOM
         *         // optimization purposes
         *         hasInsertionPoint: {boolean},
         *         // For nested `<template>`` nodes, nested template metadata
         *         templateInfo: {object}, // nested template metadata
         *         // Metadata to allow efficient retrieval of instanced node
         *         // corresponding to this metadata
         *         parentInfo: {number},   // reference to parent nodeInfo>
         *         parentIndex: {number},  // index in parent's `childNodes` collection
         *         infoIndex: {number},    // index of this `nodeInfo` in `templateInfo.nodeInfoList`
         *       },
         *       ...
         *     ],
         *     // When true, the template had the `strip-whitespace` attribute
         *     // or was nested in a template with that setting
         *     stripWhitespace: {boolean},
         *     // For nested templates, nested template content is moved into
         *     // a document fragment stored here; this is an optimization to
         *     // avoid the cost of nested template cloning
         *     content: {DocumentFragment}
         *   }
         * ```
         *
         * This method kicks off a recursive treewalk as follows:
         *
         * ```
         *    _parseTemplate <---------------------+
         *      _parseTemplateContent              |
         *        _parseTemplateNode  <------------|--+
         *          _parseTemplateNestedTemplate --+  |
         *          _parseTemplateChildNodes ---------+
         *          _parseTemplateNodeAttributes
         *            _parseTemplateNodeAttribute
         *
         * ```
         *
         * These methods may be overridden to add custom metadata about templates
         * to either `templateInfo` or `nodeInfo`.
         *
         * Note that this method may be destructive to the template, in that
         * e.g. event annotations may be removed after being noted in the
         * template metadata.
         *
         * @param {!HTMLTemplateElement} template Template to parse
         * @param {TemplateInfo=} outerTemplateInfo Template metadata from the outer
         *   template, for parsing nested templates
         * @return {!TemplateInfo} Parsed template metadata
         */
        value: function _parseTemplate(template, outerTemplateInfo) {
          // since a template may be re-used, memo-ize metadata
          if (!template._templateInfo) {
            var templateInfo = template._templateInfo = {};
            templateInfo.nodeInfoList = [];
            templateInfo.stripWhiteSpace = outerTemplateInfo && outerTemplateInfo.stripWhiteSpace || template.hasAttribute('strip-whitespace');
            this._parseTemplateContent(template, templateInfo, { parent: null });
          }
          return template._templateInfo;
        }
      }, {
        key: '_parseTemplateContent',
        value: function _parseTemplateContent(template, templateInfo, nodeInfo) {
          return this._parseTemplateNode(template.content, templateInfo, nodeInfo);
        }

        /**
         * Parses template node and adds template and node metadata based on
         * the current node, and its `childNodes` and `attributes`.
         *
         * This method may be overridden to add custom node or template specific
         * metadata based on this node.
         *
         * @param {Node} node Node to parse
         * @param {!TemplateInfo} templateInfo Template metadata for current template
         * @param {!NodeInfo} nodeInfo Node metadata for current template.
         * @return {boolean} `true` if the visited node added node-specific
         *   metadata to `nodeInfo`
         */

      }, {
        key: '_parseTemplateNode',
        value: function _parseTemplateNode(node, templateInfo, nodeInfo) {
          var noted = void 0;
          var element = /** @type Element */node;
          if (element.localName == 'template' && !element.hasAttribute('preserve-content')) {
            noted = this._parseTemplateNestedTemplate(element, templateInfo, nodeInfo) || noted;
          } else if (element.localName === 'slot') {
            // For ShadyDom optimization, indicating there is an insertion point
            templateInfo.hasInsertionPoint = true;
          }
          if (element.firstChild) {
            noted = this._parseTemplateChildNodes(element, templateInfo, nodeInfo) || noted;
          }
          if (element.hasAttributes && element.hasAttributes()) {
            noted = this._parseTemplateNodeAttributes(element, templateInfo, nodeInfo) || noted;
          }
          return noted;
        }

        /**
         * Parses template child nodes for the given root node.
         *
         * This method also wraps whitelisted legacy template extensions
         * (`is="dom-if"` and `is="dom-repeat"`) with their equivalent element
         * wrappers, collapses text nodes, and strips whitespace from the template
         * if the `templateInfo.stripWhitespace` setting was provided.
         *
         * @param {Node} root Root node whose `childNodes` will be parsed
         * @param {!TemplateInfo} templateInfo Template metadata for current template
         * @param {!NodeInfo} nodeInfo Node metadata for current template.
         */

      }, {
        key: '_parseTemplateChildNodes',
        value: function _parseTemplateChildNodes(root, templateInfo, nodeInfo) {
          for (var node = root.firstChild, parentIndex = 0, next; node; node = next) {
            // Wrap templates
            if (node.localName == 'template') {
              node = wrapTemplateExtension(node);
            }
            // collapse adjacent textNodes: fixes an IE issue that can cause
            // text nodes to be inexplicably split =(
            // note that root.normalize() should work but does not so we do this
            // manually.
            next = node.nextSibling;
            if (node.nodeType === Node.TEXT_NODE) {
              var /** Node */n = next;
              while (n && n.nodeType === Node.TEXT_NODE) {
                node.textContent += n.textContent;
                next = n.nextSibling;
                root.removeChild(n);
                n = next;
              }
              // optionally strip whitespace
              if (templateInfo.stripWhiteSpace && !node.textContent.trim()) {
                root.removeChild(node);
                continue;
              }
            }
            var childInfo = { parentIndex: parentIndex, parentInfo: nodeInfo };
            if (this._parseTemplateNode(node, templateInfo, childInfo)) {
              childInfo.infoIndex = templateInfo.nodeInfoList.push( /** @type {!NodeInfo} */childInfo) - 1;
            }
            // Increment if not removed
            if (node.parentNode) {
              parentIndex++;
            }
          }
        }

        /**
         * Parses template content for the given nested `<template>`.
         *
         * Nested template info is stored as `templateInfo` in the current node's
         * `nodeInfo`. `template.content` is removed and stored in `templateInfo`.
         * It will then be the responsibility of the host to set it back to the
         * template and for users stamping nested templates to use the
         * `_contentForTemplate` method to retrieve the content for this template
         * (an optimization to avoid the cost of cloning nested template content).
         *
         * @param {HTMLTemplateElement} node Node to parse (a <template>)
         * @param {TemplateInfo} outerTemplateInfo Template metadata for current template
         *   that includes the template `node`
         * @param {!NodeInfo} nodeInfo Node metadata for current template.
         * @return {boolean} `true` if the visited node added node-specific
         *   metadata to `nodeInfo`
         */

      }, {
        key: '_parseTemplateNestedTemplate',
        value: function _parseTemplateNestedTemplate(node, outerTemplateInfo, nodeInfo) {
          var templateInfo = this._parseTemplate(node, outerTemplateInfo);
          var content = templateInfo.content = node.content.ownerDocument.createDocumentFragment();
          content.appendChild(node.content);
          nodeInfo.templateInfo = templateInfo;
          return true;
        }

        /**
         * Parses template node attributes and adds node metadata to `nodeInfo`
         * for nodes of interest.
         *
         * @param {Element} node Node to parse
         * @param {TemplateInfo} templateInfo Template metadata for current template
         * @param {NodeInfo} nodeInfo Node metadata for current template.
         * @return {boolean} `true` if the visited node added node-specific
         *   metadata to `nodeInfo`
         */

      }, {
        key: '_parseTemplateNodeAttributes',
        value: function _parseTemplateNodeAttributes(node, templateInfo, nodeInfo) {
          // Make copy of original attribute list, since the order may change
          // as attributes are added and removed
          var noted = false;
          var attrs = Array.from(node.attributes);
          for (var i = attrs.length - 1, a; a = attrs[i]; i--) {
            noted = this._parseTemplateNodeAttribute(node, templateInfo, nodeInfo, a.name, a.value) || noted;
          }
          return noted;
        }

        /**
         * Parses a single template node attribute and adds node metadata to
         * `nodeInfo` for attributes of interest.
         *
         * This implementation adds metadata for `on-event="handler"` attributes
         * and `id` attributes.
         *
         * @param {Element} node Node to parse
         * @param {!TemplateInfo} templateInfo Template metadata for current template
         * @param {!NodeInfo} nodeInfo Node metadata for current template.
         * @param {string} name Attribute name
         * @param {string} value Attribute value
         * @return {boolean} `true` if the visited node added node-specific
         *   metadata to `nodeInfo`
         */

      }, {
        key: '_parseTemplateNodeAttribute',
        value: function _parseTemplateNodeAttribute(node, templateInfo, nodeInfo, name, value) {
          // events (on-*)
          if (name.slice(0, 3) === 'on-') {
            node.removeAttribute(name);
            nodeInfo.events = nodeInfo.events || [];
            nodeInfo.events.push({
              name: name.slice(3),
              value: value
            });
            return true;
          }
          // static id
          else if (name === 'id') {
              nodeInfo.id = value;
              return true;
            }
          return false;
        }

        /**
         * Returns the `content` document fragment for a given template.
         *
         * For nested templates, Polymer performs an optimization to cache nested
         * template content to avoid the cost of cloning deeply nested templates.
         * This method retrieves the cached content for a given template.
         *
         * @param {HTMLTemplateElement} template Template to retrieve `content` for
         * @return {DocumentFragment} Content fragment
         */

      }, {
        key: '_contentForTemplate',
        value: function _contentForTemplate(template) {
          var templateInfo = /** @type {HTMLTemplateElementWithInfo} */template._templateInfo;
          return templateInfo && templateInfo.content || template.content;
        }
      }]);

      return TemplateStamp;
    }(superClass);

    return TemplateStamp;
  });
})();

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

__webpack_require__(5);

var RegisterHtmlTemplate = __webpack_require__(2);

RegisterHtmlTemplate.register("<dom-module id=app-drawer> <template> <style>:host{position:fixed;top:-120px;right:0;bottom:-120px;left:0;visibility:hidden;transition-property:visibility}:host([opened]){visibility:visible}:host([persistent]){width:var(--app-drawer-width,256px)}:host([persistent][position=left]){right:auto}:host([persistent][position=right]){left:auto}#contentContainer{position:absolute;top:0;bottom:0;left:0;width:var(--app-drawer-width,256px);padding:120px 0;transition-property:-webkit-transform;transition-property:transform;-webkit-transform:translate3d(-100%,0,0);transform:translate3d(-100%,0,0);background-color:#fff;@apply --app-drawer-content-container;}#contentContainer[persistent]{width:100%}#contentContainer[position=right]{right:0;left:auto;-webkit-transform:translate3d(100%,0,0);transform:translate3d(100%,0,0)}#contentContainer[swipe-open]::after{position:fixed;top:0;bottom:0;left:100%;visibility:visible;width:20px;content:''}#contentContainer[swipe-open][position=right]::after{right:100%;left:auto}#contentContainer[opened]{-webkit-transform:translate3d(0,0,0);transform:translate3d(0,0,0)}#scrim{position:absolute;top:0;right:0;bottom:0;left:0;transition-property:opacity;-webkit-transform:translateZ(0);transform:translateZ(0);opacity:0;background:var(--app-drawer-scrim-background,rgba(0,0,0,.5))}#scrim.visible{opacity:1}:host([no-transition]) #contentContainer{transition-property:none}</style> <div id=scrim on-click=close></div> <div id=contentContainer opened$=[[opened]] persistent$=[[persistent]] position$=[[position]] swipe-open$=[[swipeOpen]]> <slot></slot> </div> </template> </dom-module>");

Polymer({
  is: 'app-drawer',

  properties: {
    /**
     * The opened state of the drawer.
     */
    opened: {
      type: Boolean,
      value: false,
      notify: true,
      reflectToAttribute: true
    },

    /**
     * The drawer does not have a scrim and cannot be swiped close.
     */
    persistent: {
      type: Boolean,
      value: false,
      reflectToAttribute: true
    },

    /**
     * The transition duration of the drawer in milliseconds.
     */
    transitionDuration: {
      type: Number,
      value: 200
    },

    /**
     * The alignment of the drawer on the screen ('left', 'right', 'start' or 'end').
     * 'start' computes to left and 'end' to right in LTR layout and vice versa in RTL
     * layout.
     */
    align: {
      type: String,
      value: 'left'
    },

    /**
     * The computed, read-only position of the drawer on the screen ('left' or 'right').
     */
    position: {
      type: String,
      readOnly: true,
      reflectToAttribute: true
    },

    /**
     * Create an area at the edge of the screen to swipe open the drawer.
     */
    swipeOpen: {
      type: Boolean,
      value: false,
      reflectToAttribute: true
    },

    /**
     * Trap keyboard focus when the drawer is opened and not persistent.
     */
    noFocusTrap: {
      type: Boolean,
      value: false
    },

    /**
     * Disables swiping on the drawer.
     */
    disableSwipe: {
      type: Boolean,
      value: false
    }
  },

  observers: ['resetLayout(position, isAttached)', '_resetPosition(align, isAttached)', '_styleTransitionDuration(transitionDuration)', '_openedPersistentChanged(opened, persistent)'],

  _translateOffset: 0,

  _trackDetails: null,

  _drawerState: 0,

  _boundEscKeydownHandler: null,

  _firstTabStop: null,

  _lastTabStop: null,

  attached: function attached() {
    Polymer.RenderStatus.afterNextRender(this, function () {
      this._boundEscKeydownHandler = this._escKeydownHandler.bind(this);
      this.addEventListener('keydown', this._tabKeydownHandler.bind(this));

      // Only listen for horizontal track so you can vertically scroll inside the drawer.
      this.listen(this, 'track', '_track');
      this.setScrollDirection('y');
    });

    this.fire('app-reset-layout');
  },

  detached: function detached() {
    document.removeEventListener('keydown', this._boundEscKeydownHandler);
  },

  /**
   * Opens the drawer.
   */
  open: function open() {
    this.opened = true;
  },

  /**
   * Closes the drawer.
   */
  close: function close() {
    this.opened = false;
  },

  /**
   * Toggles the drawer open and close.
   */
  toggle: function toggle() {
    this.opened = !this.opened;
  },

  /**
   * Gets the width of the drawer.
   *
   * @return {number} The width of the drawer in pixels.
   */
  getWidth: function getWidth() {
    return this._savedWidth || this.$.contentContainer.offsetWidth;
  },

  _isRTL: function _isRTL() {
    return window.getComputedStyle(this).direction === 'rtl';
  },

  _resetPosition: function _resetPosition() {
    switch (this.align) {
      case 'start':
        this._setPosition(this._isRTL() ? 'right' : 'left');
        return;
      case 'end':
        this._setPosition(this._isRTL() ? 'left' : 'right');
        return;
    }
    this._setPosition(this.align);
  },

  _escKeydownHandler: function _escKeydownHandler(event) {
    var ESC_KEYCODE = 27;
    if (event.keyCode === ESC_KEYCODE) {
      // Prevent any side effects if app-drawer closes.
      event.preventDefault();
      this.close();
    }
  },

  _track: function _track(event) {
    if (this.persistent || this.disableSwipe) {
      return;
    }

    // Disable user selection on desktop.
    event.preventDefault();

    switch (event.detail.state) {
      case 'start':
        this._trackStart(event);
        break;
      case 'track':
        this._trackMove(event);
        break;
      case 'end':
        this._trackEnd(event);
        break;
    }
  },

  _trackStart: function _trackStart(event) {
    this._drawerState = this._DRAWER_STATE.TRACKING;

    var rect = this.$.contentContainer.getBoundingClientRect();
    this._savedWidth = rect.width;
    if (this.position === 'left') {
      this._translateOffset = rect.left;
    } else {
      this._translateOffset = rect.right - window.innerWidth;
    }

    this._trackDetails = [];

    // Disable transitions since style attributes will reflect user track events.
    this._styleTransitionDuration(0);
    this.style.visibility = 'visible';
  },

  _trackMove: function _trackMove(event) {
    this._translateDrawer(event.detail.dx + this._translateOffset);

    // Use Date.now() since event.timeStamp is inconsistent across browsers (e.g. most
    // browsers use milliseconds but FF 44 uses microseconds).
    this._trackDetails.push({
      dx: event.detail.dx,
      timeStamp: Date.now()
    });
  },

  _trackEnd: function _trackEnd(event) {
    var x = event.detail.dx + this._translateOffset;
    var drawerWidth = this.getWidth();
    var isPositionLeft = this.position === 'left';
    var isInEndState = isPositionLeft ? x >= 0 || x <= -drawerWidth : x <= 0 || x >= drawerWidth;

    if (!isInEndState) {
      // No longer need the track events after this method returns - allow them to be GC'd.
      var trackDetails = this._trackDetails;
      this._trackDetails = null;

      this._flingDrawer(event, trackDetails);
      if (this._drawerState === this._DRAWER_STATE.FLINGING) {
        return;
      }
    }

    // If the drawer is not flinging, toggle the opened state based on the position of
    // the drawer.
    var halfWidth = drawerWidth / 2;
    if (event.detail.dx < -halfWidth) {
      this.opened = this.position === 'right';
    } else if (event.detail.dx > halfWidth) {
      this.opened = this.position === 'left';
    }

    if (isInEndState) {
      this.debounce('_resetDrawerState', this._resetDrawerState);
    } else {
      this.debounce('_resetDrawerState', this._resetDrawerState, this.transitionDuration);
    }

    this._styleTransitionDuration(this.transitionDuration);
    this._resetDrawerTranslate();
    this.style.visibility = '';
  },

  _calculateVelocity: function _calculateVelocity(event, trackDetails) {
    // Find the oldest track event that is within 100ms using binary search.
    var now = Date.now();
    var timeLowerBound = now - 100;
    var trackDetail;
    var min = 0;
    var max = trackDetails.length - 1;

    while (min <= max) {
      // Floor of average of min and max.
      var mid = min + max >> 1;
      var d = trackDetails[mid];
      if (d.timeStamp >= timeLowerBound) {
        trackDetail = d;
        max = mid - 1;
      } else {
        min = mid + 1;
      }
    }

    if (trackDetail) {
      var dx = event.detail.dx - trackDetail.dx;
      var dt = now - trackDetail.timeStamp || 1;
      return dx / dt;
    }
    return 0;
  },

  _flingDrawer: function _flingDrawer(event, trackDetails) {
    var velocity = this._calculateVelocity(event, trackDetails);

    // Do not fling if velocity is not above a threshold.
    if (Math.abs(velocity) < this._MIN_FLING_THRESHOLD) {
      return;
    }

    this._drawerState = this._DRAWER_STATE.FLINGING;

    var x = event.detail.dx + this._translateOffset;
    var drawerWidth = this.getWidth();
    var isPositionLeft = this.position === 'left';
    var isVelocityPositive = velocity > 0;
    var isClosingLeft = !isVelocityPositive && isPositionLeft;
    var isClosingRight = isVelocityPositive && !isPositionLeft;
    var dx;
    if (isClosingLeft) {
      dx = -(x + drawerWidth);
    } else if (isClosingRight) {
      dx = drawerWidth - x;
    } else {
      dx = -x;
    }

    // Enforce a minimum transition velocity to make the drawer feel snappy.
    if (isVelocityPositive) {
      velocity = Math.max(velocity, this._MIN_TRANSITION_VELOCITY);
      this.opened = this.position === 'left';
    } else {
      velocity = Math.min(velocity, -this._MIN_TRANSITION_VELOCITY);
      this.opened = this.position === 'right';
    }

    // Calculate the amount of time needed to finish the transition based on the
    // initial slope of the timing function.
    var t = this._FLING_INITIAL_SLOPE * dx / velocity;
    this._styleTransitionDuration(t);
    this._styleTransitionTimingFunction(this._FLING_TIMING_FUNCTION);

    this._resetDrawerTranslate();
    this.debounce('_resetDrawerState', this._resetDrawerState, t);
  },

  _styleTransitionDuration: function _styleTransitionDuration(duration) {
    this.style.transitionDuration = duration + 'ms';
    this.$.contentContainer.style.transitionDuration = duration + 'ms';
    this.$.scrim.style.transitionDuration = duration + 'ms';
  },

  _styleTransitionTimingFunction: function _styleTransitionTimingFunction(timingFunction) {
    this.$.contentContainer.style.transitionTimingFunction = timingFunction;
    this.$.scrim.style.transitionTimingFunction = timingFunction;
  },

  _translateDrawer: function _translateDrawer(x) {
    var drawerWidth = this.getWidth();

    if (this.position === 'left') {
      x = Math.max(-drawerWidth, Math.min(x, 0));
      this.$.scrim.style.opacity = 1 + x / drawerWidth;
    } else {
      x = Math.max(0, Math.min(x, drawerWidth));
      this.$.scrim.style.opacity = 1 - x / drawerWidth;
    }

    this.translate3d(x + 'px', '0', '0', this.$.contentContainer);
  },

  _resetDrawerTranslate: function _resetDrawerTranslate() {
    this.$.scrim.style.opacity = '';
    this.transform('', this.$.contentContainer);
  },

  _resetDrawerState: function _resetDrawerState() {
    var oldState = this._drawerState;

    // If the drawer was flinging, we need to reset the style attributes.
    if (oldState === this._DRAWER_STATE.FLINGING) {
      this._styleTransitionDuration(this.transitionDuration);
      this._styleTransitionTimingFunction('');
      this.style.visibility = '';
    }

    this._savedWidth = null;

    if (this.opened) {
      this._drawerState = this.persistent ? this._DRAWER_STATE.OPENED_PERSISTENT : this._DRAWER_STATE.OPENED;
    } else {
      this._drawerState = this._DRAWER_STATE.CLOSED;
    }

    if (oldState !== this._drawerState) {
      if (this._drawerState === this._DRAWER_STATE.OPENED) {
        this._setKeyboardFocusTrap();
        document.addEventListener('keydown', this._boundEscKeydownHandler);
        document.body.style.overflow = 'hidden';
      } else {
        document.removeEventListener('keydown', this._boundEscKeydownHandler);
        document.body.style.overflow = '';
      }

      // Don't fire the event on initial load.
      if (oldState !== this._DRAWER_STATE.INIT) {
        this.fire('app-drawer-transitioned');
      }
    }
  },

  /**
   * Resets the layout.
   *
   * @method resetLayout
   */
  resetLayout: function resetLayout() {
    this.fire('app-reset-layout');
  },

  _setKeyboardFocusTrap: function _setKeyboardFocusTrap() {
    if (this.noFocusTrap) {
      return;
    }

    // NOTE: Unless we use /deep/ (which we shouldn't since it's deprecated), this will
    // not select focusable elements inside shadow roots.
    var focusableElementsSelector = ['a[href]:not([tabindex="-1"])', 'area[href]:not([tabindex="-1"])', 'input:not([disabled]):not([tabindex="-1"])', 'select:not([disabled]):not([tabindex="-1"])', 'textarea:not([disabled]):not([tabindex="-1"])', 'button:not([disabled]):not([tabindex="-1"])', 'iframe:not([tabindex="-1"])', '[tabindex]:not([tabindex="-1"])', '[contentEditable=true]:not([tabindex="-1"])'].join(',');
    var focusableElements = Polymer.dom(this).querySelectorAll(focusableElementsSelector);

    if (focusableElements.length > 0) {
      this._firstTabStop = focusableElements[0];
      this._lastTabStop = focusableElements[focusableElements.length - 1];
    } else {
      // Reset saved tab stops when there are no focusable elements in the drawer.
      this._firstTabStop = null;
      this._lastTabStop = null;
    }

    // Focus on app-drawer if it has non-zero tabindex. Otherwise, focus the first focusable
    // element in the drawer, if it exists. Use the tabindex attribute since the this.tabIndex
    // property in IE/Edge returns 0 (instead of -1) when the attribute is not set.
    var tabindex = this.getAttribute('tabindex');
    if (tabindex && parseInt(tabindex, 10) > -1) {
      this.focus();
    } else if (this._firstTabStop) {
      this._firstTabStop.focus();
    }
  },

  _tabKeydownHandler: function _tabKeydownHandler(event) {
    if (this.noFocusTrap) {
      return;
    }

    var TAB_KEYCODE = 9;
    if (this._drawerState === this._DRAWER_STATE.OPENED && event.keyCode === TAB_KEYCODE) {
      if (event.shiftKey) {
        if (this._firstTabStop && Polymer.dom(event).localTarget === this._firstTabStop) {
          event.preventDefault();
          this._lastTabStop.focus();
        }
      } else {
        if (this._lastTabStop && Polymer.dom(event).localTarget === this._lastTabStop) {
          event.preventDefault();
          this._firstTabStop.focus();
        }
      }
    }
  },

  _openedPersistentChanged: function _openedPersistentChanged(opened, persistent) {
    this.toggleClass('visible', opened && !persistent, this.$.scrim);

    // Use a debounce timer instead of transitionend since transitionend won't fire when
    // app-drawer is display: none.
    this.debounce('_resetDrawerState', this._resetDrawerState, this.transitionDuration);
  },

  _MIN_FLING_THRESHOLD: 0.2,

  _MIN_TRANSITION_VELOCITY: 1.2,

  _FLING_TIMING_FUNCTION: 'cubic-bezier(0.667, 1, 0.667, 1)',

  _FLING_INITIAL_SLOPE: 1.5,

  _DRAWER_STATE: {
    INIT: 0,
    OPENED: 1,
    OPENED_PERSISTENT: 2,
    CLOSED: 3,
    TRACKING: 4,
    FLINGING: 5

    /**
     * Fired when the layout of app-drawer has changed.
     *
     * @event app-reset-layout
     */

    /**
     * Fired when app-drawer has finished transitioning.
     *
     * @event app-drawer-transitioned
     */
  } });

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(46);

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


(function () {
  /*
  Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
  This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
  The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
  The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
  Code distributed by Google as part of the polymer project is also
  subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
  */
  'use strict';
  var k = {};function n() {
    this.end = this.start = 0;this.rules = this.parent = this.previous = null;this.cssText = this.parsedCssText = "";this.atRule = !1;this.type = 0;this.parsedSelector = this.selector = this.keyframesName = "";
  }
  function p(a) {
    a = a.replace(aa, "").replace(ba, "");var b = q,
        c = a,
        d = new n();d.start = 0;d.end = c.length;for (var e = d, f = 0, h = c.length; f < h; f++) {
      if ("{" === c[f]) {
        e.rules || (e.rules = []);var g = e,
            m = g.rules[g.rules.length - 1] || null;e = new n();e.start = f + 1;e.parent = g;e.previous = m;g.rules.push(e);
      } else "}" === c[f] && (e.end = f + 1, e = e.parent || d);
    }return b(d, a);
  }
  function q(a, b) {
    var c = b.substring(a.start, a.end - 1);a.parsedCssText = a.cssText = c.trim();a.parent && (c = b.substring(a.previous ? a.previous.end : a.parent.start, a.start - 1), c = ca(c), c = c.replace(r, " "), c = c.substring(c.lastIndexOf(";") + 1), c = a.parsedSelector = a.selector = c.trim(), a.atRule = 0 === c.indexOf("@"), a.atRule ? 0 === c.indexOf("@media") ? a.type = t : c.match(da) && (a.type = u, a.keyframesName = a.selector.split(r).pop()) : a.type = 0 === c.indexOf("--") ? v : x);if (c = a.rules) for (var d = 0, e = c.length, f; d < e && (f = c[d]); d++) {
      q(f, b);
    }return a;
  }
  function ca(a) {
    return a.replace(/\\([0-9a-f]{1,6})\s/gi, function (a, c) {
      a = c;for (c = 6 - a.length; c--;) {
        a = "0" + a;
      }return "\\" + a;
    });
  }
  function y(a, b, c) {
    c = void 0 === c ? "" : c;var d = "";if (a.cssText || a.rules) {
      var e = a.rules,
          f;if (f = e) f = e[0], f = !(f && f.selector && 0 === f.selector.indexOf("--"));if (f) {
        f = 0;for (var h = e.length, g; f < h && (g = e[f]); f++) {
          d = y(g, b, d);
        }
      } else b ? b = a.cssText : (b = a.cssText, b = b.replace(ea, "").replace(fa, ""), b = b.replace(ha, "").replace(ia, "")), (d = b.trim()) && (d = "  " + d + "\n");
    }d && (a.selector && (c += a.selector + " {\n"), c += d, a.selector && (c += "}\n\n"));return c;
  }
  var x = 1,
      u = 7,
      t = 4,
      v = 1E3,
      aa = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//gim,
      ba = /@import[^;]*;/gim,
      ea = /(?:^[^;\-\s}]+)?--[^;{}]*?:[^{};]*?(?:[;\n]|$)/gim,
      fa = /(?:^[^;\-\s}]+)?--[^;{}]*?:[^{};]*?{[^}]*?}(?:[;\n]|$)?/gim,
      ha = /@apply\s*\(?[^);]*\)?\s*(?:[;\n]|$)?/gim,
      ia = /[^;:]*?:[^;]*?var\([^;]*\)(?:[;\n]|$)?/gim,
      da = /^@[^\s]*keyframes/,
      r = /\s+/g;var ja = Promise.resolve();function ka(a) {
    if (a = k[a]) a._applyShimCurrentVersion = a._applyShimCurrentVersion || 0, a._applyShimValidatingVersion = a._applyShimValidatingVersion || 0, a._applyShimNextVersion = (a._applyShimNextVersion || 0) + 1;
  }function z(a) {
    return a._applyShimCurrentVersion === a._applyShimNextVersion;
  }function la(a) {
    a._applyShimValidatingVersion = a._applyShimNextVersion;a.a || (a.a = !0, ja.then(function () {
      a._applyShimCurrentVersion = a._applyShimNextVersion;a.a = !1;
    }));
  };var A = !(window.ShadyDOM && window.ShadyDOM.inUse),
      B;function C(a) {
    B = a && a.shimcssproperties ? !1 : A || !(navigator.userAgent.match(/AppleWebKit\/601|Edge\/15/) || !window.CSS || !CSS.supports || !CSS.supports("box-shadow", "0 0 0 var(--foo)"));
  }window.ShadyCSS && void 0 !== window.ShadyCSS.nativeCss ? B = window.ShadyCSS.nativeCss : window.ShadyCSS ? (C(window.ShadyCSS), window.ShadyCSS = void 0) : C(window.WebComponents && window.WebComponents.flags);var E = B;var F = /(?:^|[;\s{]\s*)(--[\w-]*?)\s*:\s*(?:((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};{])+)|\{([^}]*)\}(?:(?=[;\s}])|$))/gi,
      G = /(?:^|\W+)@apply\s*\(?([^);\n]*)\)?/gi,
      ma = /@media\s(.*)/;function H(a) {
    if (!a) return "";"string" === typeof a && (a = p(a));return y(a, E);
  }function I(a) {
    !a.__cssRules && a.textContent && (a.__cssRules = p(a.textContent));return a.__cssRules || null;
  }function J(a, b, c, d) {
    if (a) {
      var e = !1,
          f = a.type;if (d && f === t) {
        var h = a.selector.match(ma);h && (window.matchMedia(h[1]).matches || (e = !0));
      }f === x ? b(a) : c && f === u ? c(a) : f === v && (e = !0);if ((a = a.rules) && !e) {
        e = 0;f = a.length;for (var g; e < f && (g = a[e]); e++) {
          J(g, b, c, d);
        }
      }
    }
  }
  function K(a, b) {
    var c = a.indexOf("var(");if (-1 === c) return b(a, "", "", "");a: {
      var d = 0;var e = c + 3;for (var f = a.length; e < f; e++) {
        if ("(" === a[e]) d++;else if (")" === a[e] && 0 === --d) break a;
      }e = -1;
    }d = a.substring(c + 4, e);c = a.substring(0, c);a = K(a.substring(e + 1), b);e = d.indexOf(",");return -1 === e ? b(c, d.trim(), "", a) : b(c, d.substring(0, e).trim(), d.substring(e + 1).trim(), a);
  };var na = /;\s*/m,
      oa = /^\s*(initial)|(inherit)\s*$/;function L() {
    this.a = {};
  }L.prototype.set = function (a, b) {
    a = a.trim();this.a[a] = { h: b, i: {} };
  };L.prototype.get = function (a) {
    a = a.trim();return this.a[a] || null;
  };var M = null;function N() {
    this.b = this.c = null;this.a = new L();
  }N.prototype.o = function (a) {
    a = G.test(a) || F.test(a);G.lastIndex = 0;F.lastIndex = 0;return a;
  };N.prototype.m = function (a, b) {
    a = a.content.querySelector("style");var c = null;a && (c = this.j(a, b));return c;
  };
  N.prototype.j = function (a, b) {
    b = void 0 === b ? "" : b;var c = I(a);this.l(c, b);a.textContent = H(c);return c;
  };N.prototype.f = function (a) {
    var b = this,
        c = I(a);J(c, function (a) {
      ":root" === a.selector && (a.selector = "html");b.g(a);
    });a.textContent = H(c);return c;
  };N.prototype.l = function (a, b) {
    var c = this;this.c = b;J(a, function (a) {
      c.g(a);
    });this.c = null;
  };N.prototype.g = function (a) {
    a.cssText = pa(this, a.parsedCssText);":root" === a.selector && (a.selector = ":host > *");
  };
  function pa(a, b) {
    b = b.replace(F, function (b, d, e, f) {
      return qa(a, b, d, e, f);
    });return O(a, b);
  }function O(a, b) {
    for (var c; c = G.exec(b);) {
      var d = c[0],
          e = c[1];c = c.index;var f = b.slice(0, c + d.indexOf("@apply"));b = b.slice(c + d.length);var h = P(a, f);d = void 0;var g = a;e = e.replace(na, "");var m = [];var l = g.a.get(e);l || (g.a.set(e, {}), l = g.a.get(e));if (l) for (d in g.c && (l.i[g.c] = !0), l.h) {
        g = h && h[d], l = [d, ": var(", e, "_-_", d], g && l.push(",", g), l.push(")"), m.push(l.join(""));
      }d = m.join("; ");b = "" + f + d + b;G.lastIndex = c + d.length;
    }return b;
  }
  function P(a, b) {
    b = b.split(";");for (var c, d, e = {}, f = 0, h; f < b.length; f++) {
      if (c = b[f]) if (h = c.split(":"), 1 < h.length) {
        c = h[0].trim();var g = a;d = c;h = h.slice(1).join(":");var m = oa.exec(h);m && (m[1] ? (g.b || (g.b = document.createElement("meta"), g.b.setAttribute("apply-shim-measure", ""), g.b.style.all = "initial", document.head.appendChild(g.b)), d = window.getComputedStyle(g.b).getPropertyValue(d)) : d = "apply-shim-inherit", h = d);d = h;e[c] = d;
      }
    }return e;
  }function ra(a, b) {
    if (M) for (var c in b.i) {
      c !== a.c && M(c);
    }
  }
  function qa(a, b, c, d, e) {
    d && K(d, function (b, c) {
      c && a.a.get(c) && (e = "@apply " + c + ";");
    });if (!e) return b;var f = O(a, e),
        h = b.slice(0, b.indexOf("--")),
        g = f = P(a, f),
        m = a.a.get(c),
        l = m && m.h;l ? g = Object.assign(Object.create(l), f) : a.a.set(c, g);var X = [],
        w,
        Y = !1;for (w in g) {
      var D = f[w];void 0 === D && (D = "initial");!l || w in l || (Y = !0);X.push("" + c + "_-_" + w + ": " + D);
    }Y && ra(a, m);m && (m.h = g);d && (h = b + ";" + h);return "" + h + X.join("; ") + ";";
  }N.prototype.detectMixin = N.prototype.o;N.prototype.transformStyle = N.prototype.j;
  N.prototype.transformCustomStyle = N.prototype.f;N.prototype.transformRules = N.prototype.l;N.prototype.transformRule = N.prototype.g;N.prototype.transformTemplate = N.prototype.m;N.prototype._separator = "_-_";Object.defineProperty(N.prototype, "invalidCallback", { get: function get() {
      return M;
    }, set: function set(a) {
      M = a;
    } });var Q = null,
      R = window.HTMLImports && window.HTMLImports.whenReady || null,
      S;function sa(a) {
    requestAnimationFrame(function () {
      R ? R(a) : (Q || (Q = new Promise(function (a) {
        S = a;
      }), "complete" === document.readyState ? S() : document.addEventListener("readystatechange", function () {
        "complete" === document.readyState && S();
      })), Q.then(function () {
        a && a();
      }));
    });
  };var T = new N();function U() {
    var a = this;this.a = null;sa(function () {
      V(a);
    });T.invalidCallback = ka;
  }function V(a) {
    a.a || (a.a = window.ShadyCSS.CustomStyleInterface, a.a && (a.a.transformCallback = function (a) {
      T.f(a);
    }, a.a.validateCallback = function () {
      requestAnimationFrame(function () {
        a.a.enqueued && W(a);
      });
    }));
  }U.prototype.prepareTemplate = function (a, b) {
    V(this);k[b] = a;b = T.m(a, b);a._styleAst = b;
  };
  function W(a) {
    V(a);if (a.a) {
      var b = a.a.processStyles();if (a.a.enqueued) {
        for (var c = 0; c < b.length; c++) {
          var d = a.a.getStyleForCustomStyle(b[c]);d && T.f(d);
        }a.a.enqueued = !1;
      }
    }
  }U.prototype.styleSubtree = function (a, b) {
    V(this);if (b) for (var c in b) {
      null === c ? a.style.removeProperty(c) : a.style.setProperty(c, b[c]);
    }if (a.shadowRoot) for (this.styleElement(a), a = a.shadowRoot.children || a.shadowRoot.childNodes, b = 0; b < a.length; b++) {
      this.styleSubtree(a[b]);
    } else for (a = a.children || a.childNodes, b = 0; b < a.length; b++) {
      this.styleSubtree(a[b]);
    }
  };
  U.prototype.styleElement = function (a) {
    V(this);var b = a.localName,
        c;b ? -1 < b.indexOf("-") ? c = b : c = a.getAttribute && a.getAttribute("is") || "" : c = a.is;if ((b = k[c]) && !z(b)) {
      if (z(b) || b._applyShimValidatingVersion !== b._applyShimNextVersion) this.prepareTemplate(b, c), la(b);if (a = a.shadowRoot) if (a = a.querySelector("style")) a.__cssRules = b._styleAst, a.textContent = H(b._styleAst);
    }
  };U.prototype.styleDocument = function (a) {
    V(this);this.styleSubtree(document.body, a);
  };
  if (!window.ShadyCSS || !window.ShadyCSS.ScopingShim) {
    var Z = new U(),
        ta = window.ShadyCSS && window.ShadyCSS.CustomStyleInterface;window.ShadyCSS = { prepareTemplate: function prepareTemplate(a, b) {
        W(Z);Z.prepareTemplate(a, b);
      }, styleSubtree: function styleSubtree(a, b) {
        W(Z);Z.styleSubtree(a, b);
      }, styleElement: function styleElement(a) {
        W(Z);Z.styleElement(a);
      }, styleDocument: function styleDocument(a) {
        W(Z);Z.styleDocument(a);
      }, getComputedStyleValue: function getComputedStyleValue(a, b) {
        return (a = window.getComputedStyle(a).getPropertyValue(b)) ? a.trim() : "";
      }, nativeCss: E, nativeShadow: A };ta && (window.ShadyCSS.CustomStyleInterface = ta);
  }window.ShadyCSS.ApplyShim = T;
}).call(undefined);

//# sourceMappingURL=apply-shim.min.js.map

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(1);

__webpack_require__(8);

__webpack_require__(12);

(function () {

  'use strict';

  // detect native touch action support

  var HAS_NATIVE_TA = typeof document.head.style.touchAction === 'string';
  var GESTURE_KEY = '__polymerGestures';
  var HANDLED_OBJ = '__polymerGesturesHandled';
  var TOUCH_ACTION = '__polymerGesturesTouchAction';
  // radius for tap and track
  var TAP_DISTANCE = 25;
  var TRACK_DISTANCE = 5;
  // number of last N track positions to keep
  var TRACK_LENGTH = 2;

  // Disabling "mouse" handlers for 2500ms is enough
  var MOUSE_TIMEOUT = 2500;
  var MOUSE_EVENTS = ['mousedown', 'mousemove', 'mouseup', 'click'];
  // an array of bitmask values for mapping MouseEvent.which to MouseEvent.buttons
  var MOUSE_WHICH_TO_BUTTONS = [0, 1, 4, 2];
  var MOUSE_HAS_BUTTONS = function () {
    try {
      return new MouseEvent('test', { buttons: 1 }).buttons === 1;
    } catch (e) {
      return false;
    }
  }();

  /* eslint no-empty: ["error", { "allowEmptyCatch": true }] */
  // check for passive event listeners
  var SUPPORTS_PASSIVE = false;
  (function () {
    try {
      var opts = Object.defineProperty({}, 'passive', { get: function get() {
          SUPPORTS_PASSIVE = true;
        } });
      window.addEventListener('test', null, opts);
      window.removeEventListener('test', null, opts);
    } catch (e) {}
  })();

  // Check for touch-only devices
  var IS_TOUCH_ONLY = navigator.userAgent.match(/iP(?:[oa]d|hone)|Android/);

  var GestureRecognizer = function GestureRecognizer() {}; // eslint-disable-line no-unused-vars
  GestureRecognizer.prototype.reset = function () {};
  /** @type {function(MouseEvent) | undefined} */
  GestureRecognizer.prototype.mousedown;
  /** @type {(function(MouseEvent) | undefined)} */
  GestureRecognizer.prototype.mousemove;
  /** @type {(function(MouseEvent) | undefined)} */
  GestureRecognizer.prototype.mouseup;
  /** @type {(function(TouchEvent) | undefined)} */
  GestureRecognizer.prototype.touchstart;
  /** @type {(function(TouchEvent) | undefined)} */
  GestureRecognizer.prototype.touchmove;
  /** @type {(function(TouchEvent) | undefined)} */
  GestureRecognizer.prototype.touchend;
  /** @type {(function(MouseEvent) | undefined)} */
  GestureRecognizer.prototype.click;

  // touch will make synthetic mouse events
  // `preventDefault` on touchend will cancel them,
  // but this breaks `<input>` focus and link clicks
  // disable mouse handlers for MOUSE_TIMEOUT ms after
  // a touchend to ignore synthetic mouse events
  var mouseCanceller = function mouseCanceller(mouseEvent) {
    // Check for sourceCapabilities, used to distinguish synthetic events
    // if mouseEvent did not come from a device that fires touch events,
    // it was made by a real mouse and should be counted
    // http://wicg.github.io/InputDeviceCapabilities/#dom-inputdevicecapabilities-firestouchevents
    var sc = mouseEvent.sourceCapabilities;
    if (sc && !sc.firesTouchEvents) {
      return;
    }
    // skip synthetic mouse events
    mouseEvent[HANDLED_OBJ] = { skip: true };
    // disable "ghost clicks"
    if (mouseEvent.type === 'click') {
      var path = mouseEvent.composedPath && mouseEvent.composedPath();
      if (path) {
        for (var i = 0; i < path.length; i++) {
          if (path[i] === POINTERSTATE.mouse.target) {
            return;
          }
        }
      }
      mouseEvent.preventDefault();
      mouseEvent.stopPropagation();
    }
  };

  /**
   * @param {boolean=} setup True to add, false to remove.
   */
  function setupTeardownMouseCanceller(setup) {
    var events = IS_TOUCH_ONLY ? ['click'] : MOUSE_EVENTS;
    for (var i = 0, en; i < events.length; i++) {
      en = events[i];
      if (setup) {
        document.addEventListener(en, mouseCanceller, true);
      } else {
        document.removeEventListener(en, mouseCanceller, true);
      }
    }
  }

  function ignoreMouse(e) {
    if (!POINTERSTATE.mouse.mouseIgnoreJob) {
      setupTeardownMouseCanceller(true);
    }
    var unset = function unset() {
      setupTeardownMouseCanceller();
      POINTERSTATE.mouse.target = null;
      POINTERSTATE.mouse.mouseIgnoreJob = null;
    };
    POINTERSTATE.mouse.target = e.composedPath()[0];
    POINTERSTATE.mouse.mouseIgnoreJob = Polymer.Debouncer.debounce(POINTERSTATE.mouse.mouseIgnoreJob, Polymer.Async.timeOut.after(MOUSE_TIMEOUT), unset);
  }

  /**
   * @param {MouseEvent} ev event to test for left mouse button down
   * @return {boolean} has left mouse button down
   */
  function hasLeftMouseButton(ev) {
    var type = ev.type;
    // exit early if the event is not a mouse event
    if (MOUSE_EVENTS.indexOf(type) === -1) {
      return false;
    }
    // ev.button is not reliable for mousemove (0 is overloaded as both left button and no buttons)
    // instead we use ev.buttons (bitmask of buttons) or fall back to ev.which (deprecated, 0 for no buttons, 1 for left button)
    if (type === 'mousemove') {
      // allow undefined for testing events
      var buttons = ev.buttons === undefined ? 1 : ev.buttons;
      if (ev instanceof window.MouseEvent && !MOUSE_HAS_BUTTONS) {
        buttons = MOUSE_WHICH_TO_BUTTONS[ev.which] || 0;
      }
      // buttons is a bitmask, check that the left button bit is set (1)
      return Boolean(buttons & 1);
    } else {
      // allow undefined for testing events
      var button = ev.button === undefined ? 0 : ev.button;
      // ev.button is 0 in mousedown/mouseup/click for left button activation
      return button === 0;
    }
  }

  function isSyntheticClick(ev) {
    if (ev.type === 'click') {
      // ev.detail is 0 for HTMLElement.click in most browsers
      if (ev.detail === 0) {
        return true;
      }
      // in the worst case, check that the x/y position of the click is within
      // the bounding box of the target of the event
      // Thanks IE 10 >:(
      var t = Gestures._findOriginalTarget(ev);
      // make sure the target of the event is an element so we can use getBoundingClientRect,
      // if not, just assume it is a synthetic click
      if (!t.nodeType || /** @type {Element} */t.nodeType !== Node.ELEMENT_NODE) {
        return true;
      }
      var bcr = /** @type {Element} */t.getBoundingClientRect();
      // use page x/y to account for scrolling
      var x = ev.pageX,
          y = ev.pageY;
      // ev is a synthetic click if the position is outside the bounding box of the target
      return !(x >= bcr.left && x <= bcr.right && y >= bcr.top && y <= bcr.bottom);
    }
    return false;
  }

  var POINTERSTATE = {
    mouse: {
      target: null,
      mouseIgnoreJob: null
    },
    touch: {
      x: 0,
      y: 0,
      id: -1,
      scrollDecided: false
    }
  };

  function firstTouchAction(ev) {
    var ta = 'auto';
    var path = ev.composedPath && ev.composedPath();
    if (path) {
      for (var i = 0, n; i < path.length; i++) {
        n = path[i];
        if (n[TOUCH_ACTION]) {
          ta = n[TOUCH_ACTION];
          break;
        }
      }
    }
    return ta;
  }

  function trackDocument(stateObj, movefn, upfn) {
    stateObj.movefn = movefn;
    stateObj.upfn = upfn;
    document.addEventListener('mousemove', movefn);
    document.addEventListener('mouseup', upfn);
  }

  function untrackDocument(stateObj) {
    document.removeEventListener('mousemove', stateObj.movefn);
    document.removeEventListener('mouseup', stateObj.upfn);
    stateObj.movefn = null;
    stateObj.upfn = null;
  }

  // use a document-wide touchend listener to start the ghost-click prevention mechanism
  // Use passive event listeners, if supported, to not affect scrolling performance
  document.addEventListener('touchend', ignoreMouse, SUPPORTS_PASSIVE ? { passive: true } : false);

  /**
   * Module for adding listeners to a node for the following normalized
   * cross-platform "gesture" events:
   * - `down` - mouse or touch went down
   * - `up` - mouse or touch went up
   * - `tap` - mouse click or finger tap
   * - `track` - mouse drag or touch move
   *
   * @namespace
   * @memberof Polymer
   * @summary Module for adding cross-platform gesture event listeners.
   */
  var Gestures = {
    gestures: {},
    recognizers: [],

    /**
     * Finds the element rendered on the screen at the provided coordinates.
     *
     * Similar to `document.elementFromPoint`, but pierces through
     * shadow roots.
     *
     * @memberof Polymer.Gestures
     * @param {number} x Horizontal pixel coordinate
     * @param {number} y Vertical pixel coordinate
     * @return {Element} Returns the deepest shadowRoot inclusive element
     * found at the screen position given.
     */
    deepTargetFind: function deepTargetFind(x, y) {
      var node = document.elementFromPoint(x, y);
      var next = node;
      // this code path is only taken when native ShadowDOM is used
      // if there is a shadowroot, it may have a node at x/y
      // if there is not a shadowroot, exit the loop
      while (next && next.shadowRoot && !window.ShadyDOM) {
        // if there is a node at x/y in the shadowroot, look deeper
        var oldNext = next;
        next = next.shadowRoot.elementFromPoint(x, y);
        // on Safari, elementFromPoint may return the shadowRoot host
        if (oldNext === next) {
          break;
        }
        if (next) {
          node = next;
        }
      }
      return node;
    },
    /**
     * a cheaper check than ev.composedPath()[0];
     *
     * @private
     * @param {Event} ev Event.
     * @return {EventTarget} Returns the event target.
     */
    _findOriginalTarget: function _findOriginalTarget(ev) {
      // shadowdom
      if (ev.composedPath) {
        return (/** @type {EventTarget} */ev.composedPath()[0]
        );
      }
      // shadydom
      return ev.target;
    },

    /**
     * @private
     * @param {Event} ev Event.
     */
    _handleNative: function _handleNative(ev) {
      var handled = void 0;
      var type = ev.type;
      var node = ev.currentTarget;
      var gobj = node[GESTURE_KEY];
      if (!gobj) {
        return;
      }
      var gs = gobj[type];
      if (!gs) {
        return;
      }
      if (!ev[HANDLED_OBJ]) {
        ev[HANDLED_OBJ] = {};
        if (type.slice(0, 5) === 'touch') {
          ev = /** @type {TouchEvent} */ev; // eslint-disable-line no-self-assign
          var t = ev.changedTouches[0];
          if (type === 'touchstart') {
            // only handle the first finger
            if (ev.touches.length === 1) {
              POINTERSTATE.touch.id = t.identifier;
            }
          }
          if (POINTERSTATE.touch.id !== t.identifier) {
            return;
          }
          if (!HAS_NATIVE_TA) {
            if (type === 'touchstart' || type === 'touchmove') {
              Gestures._handleTouchAction(ev);
            }
          }
        }
      }
      handled = ev[HANDLED_OBJ];
      // used to ignore synthetic mouse events
      if (handled.skip) {
        return;
      }
      var recognizers = Gestures.recognizers;
      // reset recognizer state
      for (var i = 0, r; i < recognizers.length; i++) {
        r = recognizers[i];
        if (gs[r.name] && !handled[r.name]) {
          if (r.flow && r.flow.start.indexOf(ev.type) > -1 && r.reset) {
            r.reset();
          }
        }
      }
      // enforce gesture recognizer order
      for (var _i = 0, _r; _i < recognizers.length; _i++) {
        _r = recognizers[_i];
        if (gs[_r.name] && !handled[_r.name]) {
          handled[_r.name] = true;
          _r[type](ev);
        }
      }
    },

    /**
     * @private
     * @param {TouchEvent} ev Event.
     */
    _handleTouchAction: function _handleTouchAction(ev) {
      var t = ev.changedTouches[0];
      var type = ev.type;
      if (type === 'touchstart') {
        POINTERSTATE.touch.x = t.clientX;
        POINTERSTATE.touch.y = t.clientY;
        POINTERSTATE.touch.scrollDecided = false;
      } else if (type === 'touchmove') {
        if (POINTERSTATE.touch.scrollDecided) {
          return;
        }
        POINTERSTATE.touch.scrollDecided = true;
        var ta = firstTouchAction(ev);
        var prevent = false;
        var dx = Math.abs(POINTERSTATE.touch.x - t.clientX);
        var dy = Math.abs(POINTERSTATE.touch.y - t.clientY);
        if (!ev.cancelable) {
          // scrolling is happening
        } else if (ta === 'none') {
          prevent = true;
        } else if (ta === 'pan-x') {
          prevent = dy > dx;
        } else if (ta === 'pan-y') {
          prevent = dx > dy;
        }
        if (prevent) {
          ev.preventDefault();
        } else {
          Gestures.prevent('track');
        }
      }
    },

    /**
     * Adds an event listener to a node for the given gesture type.
     *
     * @memberof Polymer.Gestures
     * @param {Node} node Node to add listener on
     * @param {string} evType Gesture type: `down`, `up`, `track`, or `tap`
     * @param {Function} handler Event listener function to call
     * @return {boolean} Returns true if a gesture event listener was added.
     * @this {Gestures}
     */
    addListener: function addListener(node, evType, handler) {
      if (this.gestures[evType]) {
        this._add(node, evType, handler);
        return true;
      }
      return false;
    },

    /**
     * Removes an event listener from a node for the given gesture type.
     *
     * @memberof Polymer.Gestures
     * @param {Node} node Node to remove listener from
     * @param {string} evType Gesture type: `down`, `up`, `track`, or `tap`
     * @param {Function} handler Event listener function previously passed to
     *  `addListener`.
     * @return {boolean} Returns true if a gesture event listener was removed.
     * @this {Gestures}
     */
    removeListener: function removeListener(node, evType, handler) {
      if (this.gestures[evType]) {
        this._remove(node, evType, handler);
        return true;
      }
      return false;
    },

    /**
     * automate the event listeners for the native events
     *
     * @private
     * @param {HTMLElement} node Node on which to add the event.
     * @param {string} evType Event type to add.
     * @param {function(Event?)} handler Event handler function.
     * @this {Gestures}
     */
    _add: function _add(node, evType, handler) {
      var recognizer = this.gestures[evType];
      var deps = recognizer.deps;
      var name = recognizer.name;
      var gobj = node[GESTURE_KEY];
      if (!gobj) {
        node[GESTURE_KEY] = gobj = {};
      }
      for (var i = 0, dep, gd; i < deps.length; i++) {
        dep = deps[i];
        // don't add mouse handlers on iOS because they cause gray selection overlays
        if (IS_TOUCH_ONLY && MOUSE_EVENTS.indexOf(dep) > -1 && dep !== 'click') {
          continue;
        }
        gd = gobj[dep];
        if (!gd) {
          gobj[dep] = gd = { _count: 0 };
        }
        if (gd._count === 0) {
          node.addEventListener(dep, this._handleNative);
        }
        gd[name] = (gd[name] || 0) + 1;
        gd._count = (gd._count || 0) + 1;
      }
      node.addEventListener(evType, handler);
      if (recognizer.touchAction) {
        this.setTouchAction(node, recognizer.touchAction);
      }
    },

    /**
     * automate event listener removal for native events
     *
     * @private
     * @param {HTMLElement} node Node on which to remove the event.
     * @param {string} evType Event type to remove.
     * @param {function(Event?)} handler Event handler function.
     * @this {Gestures}
     */
    _remove: function _remove(node, evType, handler) {
      var recognizer = this.gestures[evType];
      var deps = recognizer.deps;
      var name = recognizer.name;
      var gobj = node[GESTURE_KEY];
      if (gobj) {
        for (var i = 0, dep, gd; i < deps.length; i++) {
          dep = deps[i];
          gd = gobj[dep];
          if (gd && gd[name]) {
            gd[name] = (gd[name] || 1) - 1;
            gd._count = (gd._count || 1) - 1;
            if (gd._count === 0) {
              node.removeEventListener(dep, this._handleNative);
            }
          }
        }
      }
      node.removeEventListener(evType, handler);
    },

    /**
     * Registers a new gesture event recognizer for adding new custom
     * gesture event types.
     *
     * @memberof Polymer.Gestures
     * @param {GestureRecognizer} recog Gesture recognizer descriptor
     * @this {Gestures}
     */
    register: function register(recog) {
      this.recognizers.push(recog);
      for (var i = 0; i < recog.emits.length; i++) {
        this.gestures[recog.emits[i]] = recog;
      }
    },

    /**
     * @private
     * @param {string} evName Event name.
     * @return {Object} Returns the gesture for the given event name.
     * @this {Gestures}
     */
    _findRecognizerByEvent: function _findRecognizerByEvent(evName) {
      for (var i = 0, r; i < this.recognizers.length; i++) {
        r = this.recognizers[i];
        for (var j = 0, n; j < r.emits.length; j++) {
          n = r.emits[j];
          if (n === evName) {
            return r;
          }
        }
      }
      return null;
    },

    /**
     * Sets scrolling direction on node.
     *
     * This value is checked on first move, thus it should be called prior to
     * adding event listeners.
     *
     * @memberof Polymer.Gestures
     * @param {Element} node Node to set touch action setting on
     * @param {string} value Touch action value
     */
    setTouchAction: function setTouchAction(node, value) {
      if (HAS_NATIVE_TA) {
        node.style.touchAction = value;
      }
      node[TOUCH_ACTION] = value;
    },

    /**
     * Dispatches an event on the `target` element of `type` with the given
     * `detail`.
     * @private
     * @param {EventTarget} target The element on which to fire an event.
     * @param {string} type The type of event to fire.
     * @param {Object=} detail The detail object to populate on the event.
     */
    _fire: function _fire(target, type, detail) {
      var ev = new Event(type, { bubbles: true, cancelable: true, composed: true });
      ev.detail = detail;
      target.dispatchEvent(ev);
      // forward `preventDefault` in a clean way
      if (ev.defaultPrevented) {
        var preventer = detail.preventer || detail.sourceEvent;
        if (preventer && preventer.preventDefault) {
          preventer.preventDefault();
        }
      }
    },

    /**
     * Prevents the dispatch and default action of the given event name.
     *
     * @memberof Polymer.Gestures
     * @param {string} evName Event name.
     * @this {Gestures}
     */
    prevent: function prevent(evName) {
      var recognizer = this._findRecognizerByEvent(evName);
      if (recognizer.info) {
        recognizer.info.prevent = true;
      }
    },

    /**
     * Reset the 2500ms timeout on processing mouse input after detecting touch input.
     *
     * Touch inputs create synthesized mouse inputs anywhere from 0 to 2000ms after the touch.
     * This method should only be called during testing with simulated touch inputs.
     * Calling this method in production may cause duplicate taps or other Gestures.
     *
     * @memberof Polymer.Gestures
     */
    resetMouseCanceller: function resetMouseCanceller() {
      if (POINTERSTATE.mouse.mouseIgnoreJob) {
        POINTERSTATE.mouse.mouseIgnoreJob.flush();
      }
    }
  };

  /* eslint-disable valid-jsdoc */

  Gestures.register({
    name: 'downup',
    deps: ['mousedown', 'touchstart', 'touchend'],
    flow: {
      start: ['mousedown', 'touchstart'],
      end: ['mouseup', 'touchend']
    },
    emits: ['down', 'up'],

    info: {
      movefn: null,
      upfn: null
    },

    /** @this {GestureRecognizer} */
    reset: function reset() {
      untrackDocument(this.info);
    },

    /**
     * @this {GestureRecognizer}
     * @param {MouseEvent} e
     */
    mousedown: function mousedown(e) {
      if (!hasLeftMouseButton(e)) {
        return;
      }
      var t = Gestures._findOriginalTarget(e);
      var self = this;
      var movefn = function movefn(e) {
        if (!hasLeftMouseButton(e)) {
          self._fire('up', t, e);
          untrackDocument(self.info);
        }
      };
      var upfn = function upfn(e) {
        if (hasLeftMouseButton(e)) {
          self._fire('up', t, e);
        }
        untrackDocument(self.info);
      };
      trackDocument(this.info, movefn, upfn);
      this._fire('down', t, e);
    },
    /**
     * @this {GestureRecognizer}
     * @param {TouchEvent} e
     */
    touchstart: function touchstart(e) {
      this._fire('down', Gestures._findOriginalTarget(e), e.changedTouches[0], e);
    },
    /**
     * @this {GestureRecognizer}
     * @param {TouchEvent} e
     */
    touchend: function touchend(e) {
      this._fire('up', Gestures._findOriginalTarget(e), e.changedTouches[0], e);
    },
    /**
     * @param {string} type
     * @param {EventTarget} target
     * @param {Event} event
     * @param {Function} preventer
     */
    _fire: function _fire(type, target, event, preventer) {
      Gestures._fire(target, type, {
        x: event.clientX,
        y: event.clientY,
        sourceEvent: event,
        preventer: preventer,
        prevent: function prevent(e) {
          return Gestures.prevent(e);
        }
      });
    }
  });

  Gestures.register({
    name: 'track',
    touchAction: 'none',
    deps: ['mousedown', 'touchstart', 'touchmove', 'touchend'],
    flow: {
      start: ['mousedown', 'touchstart'],
      end: ['mouseup', 'touchend']
    },
    emits: ['track'],

    info: {
      x: 0,
      y: 0,
      state: 'start',
      started: false,
      moves: [],
      /** @this {GestureRecognizer} */
      addMove: function addMove(move) {
        if (this.moves.length > TRACK_LENGTH) {
          this.moves.shift();
        }
        this.moves.push(move);
      },
      movefn: null,
      upfn: null,
      prevent: false
    },

    /** @this {GestureRecognizer} */
    reset: function reset() {
      this.info.state = 'start';
      this.info.started = false;
      this.info.moves = [];
      this.info.x = 0;
      this.info.y = 0;
      this.info.prevent = false;
      untrackDocument(this.info);
    },

    /**
     * @this {GestureRecognizer}
     * @param {number} x
     * @param {number} y
     * @return {boolean}
     */
    hasMovedEnough: function hasMovedEnough(x, y) {
      if (this.info.prevent) {
        return false;
      }
      if (this.info.started) {
        return true;
      }
      var dx = Math.abs(this.info.x - x);
      var dy = Math.abs(this.info.y - y);
      return dx >= TRACK_DISTANCE || dy >= TRACK_DISTANCE;
    },
    /**
     * @this {GestureRecognizer}
     * @param {MouseEvent} e
     */
    mousedown: function mousedown(e) {
      if (!hasLeftMouseButton(e)) {
        return;
      }
      var t = Gestures._findOriginalTarget(e);
      var self = this;
      var movefn = function movefn(e) {
        var x = e.clientX,
            y = e.clientY;
        if (self.hasMovedEnough(x, y)) {
          // first move is 'start', subsequent moves are 'move', mouseup is 'end'
          self.info.state = self.info.started ? e.type === 'mouseup' ? 'end' : 'track' : 'start';
          if (self.info.state === 'start') {
            // if and only if tracking, always prevent tap
            Gestures.prevent('tap');
          }
          self.info.addMove({ x: x, y: y });
          if (!hasLeftMouseButton(e)) {
            // always _fire "end"
            self.info.state = 'end';
            untrackDocument(self.info);
          }
          self._fire(t, e);
          self.info.started = true;
        }
      };
      var upfn = function upfn(e) {
        if (self.info.started) {
          movefn(e);
        }

        // remove the temporary listeners
        untrackDocument(self.info);
      };
      // add temporary document listeners as mouse retargets
      trackDocument(this.info, movefn, upfn);
      this.info.x = e.clientX;
      this.info.y = e.clientY;
    },
    /**
     * @this {GestureRecognizer}
     * @param {TouchEvent} e
     */
    touchstart: function touchstart(e) {
      var ct = e.changedTouches[0];
      this.info.x = ct.clientX;
      this.info.y = ct.clientY;
    },
    /**
     * @this {GestureRecognizer}
     * @param {TouchEvent} e
     */
    touchmove: function touchmove(e) {
      var t = Gestures._findOriginalTarget(e);
      var ct = e.changedTouches[0];
      var x = ct.clientX,
          y = ct.clientY;
      if (this.hasMovedEnough(x, y)) {
        if (this.info.state === 'start') {
          // if and only if tracking, always prevent tap
          Gestures.prevent('tap');
        }
        this.info.addMove({ x: x, y: y });
        this._fire(t, ct);
        this.info.state = 'track';
        this.info.started = true;
      }
    },
    /**
     * @this {GestureRecognizer}
     * @param {TouchEvent} e
     */
    touchend: function touchend(e) {
      var t = Gestures._findOriginalTarget(e);
      var ct = e.changedTouches[0];
      // only trackend if track was started and not aborted
      if (this.info.started) {
        // reset started state on up
        this.info.state = 'end';
        this.info.addMove({ x: ct.clientX, y: ct.clientY });
        this._fire(t, ct, e);
      }
    },

    /**
     * @this {GestureRecognizer}
     * @param {EventTarget} target
     * @param {Touch} touch
     */
    _fire: function _fire(target, touch) {
      var secondlast = this.info.moves[this.info.moves.length - 2];
      var lastmove = this.info.moves[this.info.moves.length - 1];
      var dx = lastmove.x - this.info.x;
      var dy = lastmove.y - this.info.y;
      var ddx = void 0,
          ddy = 0;
      if (secondlast) {
        ddx = lastmove.x - secondlast.x;
        ddy = lastmove.y - secondlast.y;
      }
      Gestures._fire(target, 'track', {
        state: this.info.state,
        x: touch.clientX,
        y: touch.clientY,
        dx: dx,
        dy: dy,
        ddx: ddx,
        ddy: ddy,
        sourceEvent: touch,
        hover: function hover() {
          return Gestures.deepTargetFind(touch.clientX, touch.clientY);
        }
      });
    }

  });

  Gestures.register({
    name: 'tap',
    deps: ['mousedown', 'click', 'touchstart', 'touchend'],
    flow: {
      start: ['mousedown', 'touchstart'],
      end: ['click', 'touchend']
    },
    emits: ['tap'],
    info: {
      x: NaN,
      y: NaN,
      prevent: false
    },
    /** @this {GestureRecognizer} */
    reset: function reset() {
      this.info.x = NaN;
      this.info.y = NaN;
      this.info.prevent = false;
    },
    /** @this {GestureRecognizer} */
    save: function save(e) {
      this.info.x = e.clientX;
      this.info.y = e.clientY;
    },
    /**
     * @this {GestureRecognizer}
     * @param {MouseEvent} e
     */
    mousedown: function mousedown(e) {
      if (hasLeftMouseButton(e)) {
        this.save(e);
      }
    },
    /**
     * @this {GestureRecognizer}
     * @param {MouseEvent} e
     */
    click: function click(e) {
      if (hasLeftMouseButton(e)) {
        this.forward(e);
      }
    },
    /**
     * @this {GestureRecognizer}
     * @param {TouchEvent} e
     */
    touchstart: function touchstart(e) {
      this.save(e.changedTouches[0], e);
    },
    /**
     * @this {GestureRecognizer}
     * @param {TouchEvent} e
     */
    touchend: function touchend(e) {
      this.forward(e.changedTouches[0], e);
    },
    /**
     * @this {GestureRecognizer}
     * @param {Event} e
     * @param {Function} preventer
     */
    forward: function forward(e, preventer) {
      var dx = Math.abs(e.clientX - this.info.x);
      var dy = Math.abs(e.clientY - this.info.y);
      var t = Gestures._findOriginalTarget(e);
      // dx,dy can be NaN if `click` has been simulated and there was no `down` for `start`
      if (isNaN(dx) || isNaN(dy) || dx <= TAP_DISTANCE && dy <= TAP_DISTANCE || isSyntheticClick(e)) {
        // prevent taps from being generated if an event has canceled them
        if (!this.info.prevent) {
          Gestures._fire(t, 'tap', {
            x: e.clientX,
            y: e.clientY,
            sourceEvent: e,
            preventer: preventer
          });
        }
      }
    }
  });

  /* eslint-enable valid-jsdoc */

  /** @deprecated */
  Gestures.findOriginalTarget = Gestures._findOriginalTarget;

  /** @deprecated */
  Gestures.add = Gestures.addListener;

  /** @deprecated */
  Gestures.remove = Gestures.removeListener;

  Polymer.Gestures = Gestures;
})();

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(1);

(function () {

  'use strict';

  // run a callback when HTMLImports are ready or immediately if
  // this api is not available.

  function whenImportsReady(cb) {
    if (window.HTMLImports) {
      HTMLImports.whenReady(cb);
    } else {
      cb();
    }
  }

  /**
   * Convenience method for importing an HTML document imperatively.
   *
   * This method creates a new `<link rel="import">` element with
   * the provided URL and appends it to the document to start loading.
   * In the `onload` callback, the `import` property of the `link`
   * element will contain the imported document contents.
   *
   * @memberof Polymer
   * @param {string} href URL to document to load.
   * @param {Function=} onload Callback to notify when an import successfully
   *   loaded.
   * @param {Function=} onerror Callback to notify when an import
   *   unsuccessfully loaded.
   * @param {boolean=} optAsync True if the import should be loaded `async`.
   *   Defaults to `false`.
   * @return {HTMLLinkElement} The link element for the URL to be loaded.
   */
  Polymer.importHref = function (href, onload, onerror, optAsync) {
    var link = /** @type {HTMLLinkElement} */
    document.head.querySelector('link[href="' + href + '"][import-href]');
    if (!link) {
      link = /** @type {HTMLLinkElement} */document.createElement('link');
      link.rel = 'import';
      link.href = href;
      link.setAttribute('import-href', '');
    }
    // always ensure link has `async` attribute if user specified one,
    // even if it was previously not async. This is considered less confusing.
    if (optAsync) {
      link.setAttribute('async', '');
    }
    // NOTE: the link may now be in 3 states: (1) pending insertion,
    // (2) inflight, (3) already laoded. In each case, we need to add
    // event listeners to process callbacks.
    var cleanup = function cleanup() {
      link.removeEventListener('load', loadListener);
      link.removeEventListener('error', errorListener);
    };
    var loadListener = function loadListener(event) {
      cleanup();
      // In case of a successful load, cache the load event on the link so
      // that it can be used to short-circuit this method in the future when
      // it is called with the same href param.
      link.__dynamicImportLoaded = true;
      if (onload) {
        whenImportsReady(function () {
          onload(event);
        });
      }
    };
    var errorListener = function errorListener(event) {
      cleanup();
      // In case of an error, remove the link from the document so that it
      // will be automatically created again the next time `importHref` is
      // called.
      if (link.parentNode) {
        link.parentNode.removeChild(link);
      }
      if (onerror) {
        whenImportsReady(function () {
          onerror(event);
        });
      }
    };
    link.addEventListener('load', loadListener);
    link.addEventListener('error', errorListener);
    if (link.parentNode == null) {
      document.head.appendChild(link);
      // if the link already loaded, dispatch a fake load event
      // so that listeners are called and get a proper event argument.
    } else if (link.__dynamicImportLoaded) {
      link.dispatchEvent(new Event('load'));
    }
    return link;
  };
})();

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(1);

(function () {

  'use strict';

  var scheduled = false;
  var beforeRenderQueue = [];
  var afterRenderQueue = [];

  function schedule() {
    scheduled = true;
    // before next render
    requestAnimationFrame(function () {
      scheduled = false;
      flushQueue(beforeRenderQueue);
      // after the render
      setTimeout(function () {
        runQueue(afterRenderQueue);
      });
    });
  }

  function flushQueue(queue) {
    while (queue.length) {
      callMethod(queue.shift());
    }
  }

  function runQueue(queue) {
    for (var i = 0, l = queue.length; i < l; i++) {
      callMethod(queue.shift());
    }
  }

  function callMethod(info) {
    var context = info[0];
    var callback = info[1];
    var args = info[2];
    try {
      callback.apply(context, args);
    } catch (e) {
      setTimeout(function () {
        throw e;
      });
    }
  }

  function flush() {
    while (beforeRenderQueue.length || afterRenderQueue.length) {
      flushQueue(beforeRenderQueue);
      flushQueue(afterRenderQueue);
    }
    scheduled = false;
  }

  /**
   * Module for scheduling flushable pre-render and post-render tasks.
   *
   * @namespace
   * @memberof Polymer
   * @summary Module for scheduling flushable pre-render and post-render tasks.
   */
  Polymer.RenderStatus = {

    /**
     * Enqueues a callback which will be run before the next render, at
     * `requestAnimationFrame` timing.
     *
     * This method is useful for enqueuing work that requires DOM measurement,
     * since measurement may not be reliable in custom element callbacks before
     * the first render, as well as for batching measurement tasks in general.
     *
     * Tasks in this queue may be flushed by calling `Polymer.RenderStatus.flush()`.
     *
     * @memberof Polymer.RenderStatus
     * @param {*} context Context object the callback function will be bound to
     * @param {function()} callback Callback function
     * @param {Array} args An array of arguments to call the callback function with
     */
    beforeNextRender: function beforeNextRender(context, callback, args) {
      if (!scheduled) {
        schedule();
      }
      beforeRenderQueue.push([context, callback, args]);
    },

    /**
     * Enqueues a callback which will be run after the next render, equivalent
     * to one task (`setTimeout`) after the next `requestAnimationFrame`.
     *
     * This method is useful for tuning the first-render performance of an
     * element or application by deferring non-critical work until after the
     * first paint.  Typical non-render-critical work may include adding UI
     * event listeners and aria attributes.
     *
     * @memberof Polymer.RenderStatus
     * @param {*} context Context object the callback function will be bound to
     * @param {function()} callback Callback function
     * @param {Array} args An array of arguments to call the callback function with
     */
    afterNextRender: function afterNextRender(context, callback, args) {
      if (!scheduled) {
        schedule();
      }
      afterRenderQueue.push([context, callback, args]);
    },

    /**
     * Flushes all `beforeNextRender` tasks, followed by all `afterNextRender`
     * tasks.
     *
     * @memberof Polymer.RenderStatus
     */
    flush: flush

  };
})();

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


(function () {
  'use strict';

  // unresolved

  function resolve() {
    document.body.removeAttribute('unresolved');
  }

  if (window.WebComponents) {
    window.addEventListener('WebComponentsReady', resolve);
  } else {
    if (document.readyState === 'interactive' || document.readyState === 'complete') {
      resolve();
    } else {
      window.addEventListener('DOMContentLoaded', resolve);
    }
  }
})();

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

__webpack_require__(1);

__webpack_require__(20);

__webpack_require__(52);

__webpack_require__(13);

(function () {
  'use strict';

  var p = Element.prototype;
  /**
   * @const {function(this:Element, string): boolean}
   */
  var normalizedMatchesSelector = p.matches || p.matchesSelector || p.mozMatchesSelector || p.msMatchesSelector || p.oMatchesSelector || p.webkitMatchesSelector;

  /**
   * Cross-platform `element.matches` shim.
   *
   * @function matchesSelector
   * @memberof Polymer.dom
   * @param {!Element} node Node to check selector against
   * @param {string} selector Selector to match
   * @return {boolean} True if node matched selector
   */
  var matchesSelector = function matchesSelector(node, selector) {
    return normalizedMatchesSelector.call(node, selector);
  };

  /**
   * Node API wrapper class returned from `Polymer.dom.(target)` when
   * `target` is a `Node`.
   */

  var DomApi = function () {

    /**
     * @param {Node} node Node for which to create a Polymer.dom helper object.
     */
    function DomApi(node) {
      _classCallCheck(this, DomApi);

      this.node = node;
    }

    /**
     * Returns an instance of `Polymer.FlattenedNodesObserver` that
     * listens for node changes on this element.
     *
     * @param {Function} callback Called when direct or distributed children
     *   of this element changes
     * @return {Polymer.FlattenedNodesObserver} Observer instance
     */


    _createClass(DomApi, [{
      key: 'observeNodes',
      value: function observeNodes(callback) {
        return new Polymer.FlattenedNodesObserver(this.node, callback);
      }

      /**
       * Disconnects an observer previously created via `observeNodes`
       *
       * @param {Polymer.FlattenedNodesObserver} observerHandle Observer instance
       *   to disconnect.
       */

    }, {
      key: 'unobserveNodes',
      value: function unobserveNodes(observerHandle) {
        observerHandle.disconnect();
      }

      /**
       * Provided as a backwards-compatible API only.  This method does nothing.
       */

    }, {
      key: 'notifyObserver',
      value: function notifyObserver() {}

      /**
       * Returns true if the provided node is contained with this element's
       * light-DOM children or shadow root, including any nested shadow roots
       * of children therein.
       *
       * @param {Node} node Node to test
       * @return {boolean} Returns true if the given `node` is contained within
       *   this element's light or shadow DOM.
       */

    }, {
      key: 'deepContains',
      value: function deepContains(node) {
        if (this.node.contains(node)) {
          return true;
        }
        var n = node;
        var doc = node.ownerDocument;
        // walk from node to `this` or `document`
        while (n && n !== doc && n !== this.node) {
          // use logical parentnode, or native ShadowRoot host
          n = n.parentNode || n.host;
        }
        return n === this.node;
      }

      /**
       * Returns the root node of this node.  Equivalent to `getRoodNode()`.
       *
       * @return {Node} Top most element in the dom tree in which the node
       * exists. If the node is connected to a document this is either a
       * shadowRoot or the document; otherwise, it may be the node
       * itself or a node or document fragment containing it.
       */

    }, {
      key: 'getOwnerRoot',
      value: function getOwnerRoot() {
        return this.node.getRootNode();
      }

      /**
       * For slot elements, returns the nodes assigned to the slot; otherwise
       * an empty array. It is equivalent to `<slot>.addignedNodes({flatten:true})`.
       *
       * @return {Array<Node>} Array of assigned nodes
       */

    }, {
      key: 'getDistributedNodes',
      value: function getDistributedNodes() {
        return this.node.localName === 'slot' ? this.node.assignedNodes({ flatten: true }) : [];
      }

      /**
       * Returns an array of all slots this element was distributed to.
       *
       * @return {Array<HTMLSlotElement>} Description
       */

    }, {
      key: 'getDestinationInsertionPoints',
      value: function getDestinationInsertionPoints() {
        var ip$ = [];
        var n = this.node.assignedSlot;
        while (n) {
          ip$.push(n);
          n = n.assignedSlot;
        }
        return ip$;
      }

      /**
       * Calls `importNode` on the `ownerDocument` for this node.
       *
       * @param {Node} node Node to import
       * @param {boolean} deep True if the node should be cloned deeply during
       *   import
       * @return {Node} Clone of given node imported to this owner document
       */

    }, {
      key: 'importNode',
      value: function importNode(node, deep) {
        var doc = this.node instanceof Document ? this.node : this.node.ownerDocument;
        return doc.importNode(node, deep);
      }

      /**
       * @return {Array} Returns a flattened list of all child nodes and nodes assigned
       * to child slots.
       */

    }, {
      key: 'getEffectiveChildNodes',
      value: function getEffectiveChildNodes() {
        return Polymer.FlattenedNodesObserver.getFlattenedNodes(this.node);
      }

      /**
       * Returns a filtered list of flattened child elements for this element based
       * on the given selector.
       *
       * @param {string} selector Selector to filter nodes against
       * @return {Array<HTMLElement>} List of flattened child elements
       */

    }, {
      key: 'queryDistributedElements',
      value: function queryDistributedElements(selector) {
        var c$ = this.getEffectiveChildNodes();
        var list = [];
        for (var i = 0, l = c$.length, c; i < l && (c = c$[i]); i++) {
          if (c.nodeType === Node.ELEMENT_NODE && matchesSelector(c, selector)) {
            list.push(c);
          }
        }
        return list;
      }

      /**
       * For shadow roots, returns the currently focused element within this
       * shadow root.
       *
       * @return {Node|undefined} Currently focused element
       */

    }, {
      key: 'activeElement',
      get: function get() {
        var node = this.node;
        return node._activeElement !== undefined ? node._activeElement : node.activeElement;
      }
    }]);

    return DomApi;
  }();

  function forwardMethods(proto, methods) {
    var _loop = function _loop(i) {
      var method = methods[i];
      proto[method] = /** @this {DomApi} */function () {
        return this.node[method].apply(this.node, arguments);
      };
    };

    for (var i = 0; i < methods.length; i++) {
      _loop(i);
    }
  }

  function forwardReadOnlyProperties(proto, properties) {
    var _loop2 = function _loop2(i) {
      var name = properties[i];
      Object.defineProperty(proto, name, {
        get: function get() {
          return (/** @type {DomApi} */this.node[name]
          );
        },
        configurable: true
      });
    };

    for (var i = 0; i < properties.length; i++) {
      _loop2(i);
    }
  }

  function forwardProperties(proto, properties) {
    var _loop3 = function _loop3(i) {
      var name = properties[i];
      Object.defineProperty(proto, name, {
        get: function get() {
          return (/** @type {DomApi} */this.node[name]
          );
        },
        set: function set(value) {
          /** @type {DomApi} */this.node[name] = value;
        },
        configurable: true
      });
    };

    for (var i = 0; i < properties.length; i++) {
      _loop3(i);
    }
  }

  forwardMethods(DomApi.prototype, ['cloneNode', 'appendChild', 'insertBefore', 'removeChild', 'replaceChild', 'setAttribute', 'removeAttribute', 'querySelector', 'querySelectorAll']);

  forwardReadOnlyProperties(DomApi.prototype, ['parentNode', 'firstChild', 'lastChild', 'nextSibling', 'previousSibling', 'firstElementChild', 'lastElementChild', 'nextElementSibling', 'previousElementSibling', 'childNodes', 'children', 'classList']);

  forwardProperties(DomApi.prototype, ['textContent', 'innerHTML']);

  /**
   * Event API wrapper class returned from `Polymer.dom.(target)` when
   * `target` is an `Event`.
   */

  var EventApi = function () {
    function EventApi(event) {
      _classCallCheck(this, EventApi);

      this.event = event;
    }

    /**
     * Returns the first node on the `composedPath` of this event.
     *
     * @return {Node} The node this event was dispatched to
     */


    _createClass(EventApi, [{
      key: 'rootTarget',
      get: function get() {
        return this.event.composedPath()[0];
      }

      /**
       * Returns the local (re-targeted) target for this event.
       *
       * @return {Node} The local (re-targeted) target for this event.
       */

    }, {
      key: 'localTarget',
      get: function get() {
        return this.event.target;
      }

      /**
       * Returns the `composedPath` for this event.
       */

    }, {
      key: 'path',
      get: function get() {
        return this.event.composedPath();
      }
    }]);

    return EventApi;
  }();

  Polymer.DomApi = DomApi;

  /**
   * Legacy DOM and Event manipulation API wrapper factory used to abstract
   * differences between native Shadow DOM and "Shady DOM" when polyfilling on
   * older browsers.
   *
   * Note that in Polymer 2.x use of `Polymer.dom` is no longer required and
   * in the majority of cases simply facades directly to the standard native
   * API.
   *
   * @namespace
   * @summary Legacy DOM and Event manipulation API wrapper factory used to
   * abstract differences between native Shadow DOM and "Shady DOM."
   * @memberof Polymer
   * @param {!Node|Event} obj Node or event to operate on
   * @return {DomApi|EventApi} Wrapper providing either node API or event API
   */
  Polymer.dom = function (obj) {
    obj = obj || document;
    if (!obj.__domApi) {
      var helper = void 0;
      if (obj instanceof Event) {
        helper = new EventApi(obj);
      } else {
        helper = new DomApi(obj);
      }
      obj.__domApi = helper;
    }
    return obj.__domApi;
  };

  Polymer.dom.matchesSelector = matchesSelector;

  /**
   * Forces several classes of asynchronously queued tasks to flush:
   * - Debouncers added via `Polymer.enqueueDebouncer`
   * - ShadyDOM distribution
   *
   * This method facades to `Polymer.flush`.
   *
   * @memberof Polymer.dom
   */
  Polymer.dom.flush = Polymer.flush;

  /**
   * Adds a `Polymer.Debouncer` to a list of globally flushable tasks.
   *
   * This method facades to `Polymer.enqueueDebouncer`.
   *
   * @memberof Polymer.dom
   * @param {Polymer.Debouncer} debouncer Debouncer to enqueue
   */
  Polymer.dom.addDebouncer = Polymer.enqueueDebouncer;
})();

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

__webpack_require__(1);

__webpack_require__(24);

__webpack_require__(8);

(function () {
  'use strict';

  /**
   * Returns true if `node` is a slot element
   * @param {HTMLElement} node Node to test.
   * @return {boolean} Returns true if the given `node` is a slot
   * @private
   */

  function isSlot(node) {
    return node.localName === 'slot';
  }

  /**
   * Class that listens for changes (additions or removals) to
   * "flattened nodes" on a given `node`. The list of flattened nodes consists
   * of a node's children and, for any children that are `<slot>` elements,
   * the expanded flattened list of `assignedNodes`.
   * For example, if the observed node has children `<a></a><slot></slot><b></b>`
   * and the `<slot>` has one `<div>` assigned to it, then the flattened
   * nodes list is `<a></a><div></div><b></b>`. If the `<slot>` has other
   * `<slot>` elements assigned to it, these are flattened as well.
   *
   * The provided `callback` is called whenever any change to this list
   * of flattened nodes occurs, where an addition or removal of a node is
   * considered a change. The `callback` is called with one argument, an object
   * containing an array of any `addedNodes` and `removedNodes`.
   *
   * Note: the callback is called asynchronous to any changes
   * at a microtask checkpoint. This is because observation is performed using
   * `MutationObserver` and the `<slot>` element's `slotchange` event which
   * are asynchronous.
   *
   * @memberof Polymer
   * @summary Class that listens for changes (additions or removals) to
   * "flattened nodes" on a given `node`.
   */

  var FlattenedNodesObserver = function () {
    _createClass(FlattenedNodesObserver, null, [{
      key: 'getFlattenedNodes',


      /**
       * Returns the list of flattened nodes for the given `node`.
       * This list consists of a node's children and, for any children
       * that are `<slot>` elements, the expanded flattened list of `assignedNodes`.
       * For example, if the observed node has children `<a></a><slot></slot><b></b>`
       * and the `<slot>` has one `<div>` assigned to it, then the flattened
       * nodes list is `<a></a><div></div><b></b>`. If the `<slot>` has other
       * `<slot>` elements assigned to it, these are flattened as well.
       *
       * @param {HTMLElement|HTMLSlotElement} node The node for which to return the list of flattened nodes.
       * @return {Array} The list of flattened nodes for the given `node`.
      */
      value: function getFlattenedNodes(node) {
        if (isSlot(node)) {
          return (/** @type {HTMLSlotElement} */node.assignedNodes({ flatten: true })
          );
        } else {
          return Array.from(node.childNodes).map(function (node) {
            if (isSlot(node)) {
              return (/** @type {HTMLSlotElement} */node.assignedNodes({ flatten: true })
              );
            } else {
              return [node];
            }
          }).reduce(function (a, b) {
            return a.concat(b);
          }, []);
        }
      }

      /**
       * @param {Node} target Node on which to listen for changes.
       * @param {Function} callback Function called when there are additions
       * or removals from the target's list of flattened nodes.
      */

    }]);

    function FlattenedNodesObserver(target, callback) {
      var _this = this;

      _classCallCheck(this, FlattenedNodesObserver);

      /** @type {MutationObserver} */
      this._shadyChildrenObserver = null;
      /** @type {MutationObserver} */
      this._nativeChildrenObserver = null;
      this._connected = false;
      this._target = target;
      this.callback = callback;
      this._effectiveNodes = [];
      this._observer = null;
      this._scheduled = false;
      /** @type {function()} */
      this._boundSchedule = function () {
        _this._schedule();
      };
      this.connect();
      this._schedule();
    }

    /**
     * Activates an observer. This method is automatically called when
     * a `FlattenedNodesObserver` is created. It should only be called to
     * re-activate an observer that has been deactivated via the `disconnect` method.
     */


    _createClass(FlattenedNodesObserver, [{
      key: 'connect',
      value: function connect() {
        var _this2 = this;

        if (isSlot(this._target)) {
          this._listenSlots([this._target]);
        } else {
          this._listenSlots(this._target.children);
          if (window.ShadyDOM) {
            this._shadyChildrenObserver = ShadyDOM.observeChildren(this._target, function (mutations) {
              _this2._processMutations(mutations);
            });
          } else {
            this._nativeChildrenObserver = new MutationObserver(function (mutations) {
              _this2._processMutations(mutations);
            });
            this._nativeChildrenObserver.observe(this._target, { childList: true });
          }
        }
        this._connected = true;
      }

      /**
       * Deactivates the flattened nodes observer. After calling this method
       * the observer callback will not be called when changes to flattened nodes
       * occur. The `connect` method may be subsequently called to reactivate
       * the observer.
       */

    }, {
      key: 'disconnect',
      value: function disconnect() {
        if (isSlot(this._target)) {
          this._unlistenSlots([this._target]);
        } else {
          this._unlistenSlots(this._target.children);
          if (window.ShadyDOM && this._shadyChildrenObserver) {
            ShadyDOM.unobserveChildren(this._shadyChildrenObserver);
            this._shadyChildrenObserver = null;
          } else if (this._nativeChildrenObserver) {
            this._nativeChildrenObserver.disconnect();
            this._nativeChildrenObserver = null;
          }
        }
        this._connected = false;
      }
    }, {
      key: '_schedule',
      value: function _schedule() {
        var _this3 = this;

        if (!this._scheduled) {
          this._scheduled = true;
          Polymer.Async.microTask.run(function () {
            return _this3.flush();
          });
        }
      }
    }, {
      key: '_processMutations',
      value: function _processMutations(mutations) {
        this._processSlotMutations(mutations);
        this.flush();
      }
    }, {
      key: '_processSlotMutations',
      value: function _processSlotMutations(mutations) {
        if (mutations) {
          for (var i = 0; i < mutations.length; i++) {
            var mutation = mutations[i];
            if (mutation.addedNodes) {
              this._listenSlots(mutation.addedNodes);
            }
            if (mutation.removedNodes) {
              this._unlistenSlots(mutation.removedNodes);
            }
          }
        }
      }

      /**
       * Flushes the observer causing any pending changes to be immediately
       * delivered the observer callback. By default these changes are delivered
       * asynchronously at the next microtask checkpoint.
       *
       * @return {boolean} Returns true if any pending changes caused the observer
       * callback to run.
       */

    }, {
      key: 'flush',
      value: function flush() {
        if (!this._connected) {
          return false;
        }
        if (window.ShadyDOM) {
          ShadyDOM.flush();
        }
        if (this._nativeChildrenObserver) {
          this._processSlotMutations(this._nativeChildrenObserver.takeRecords());
        } else if (this._shadyChildrenObserver) {
          this._processSlotMutations(this._shadyChildrenObserver.takeRecords());
        }
        this._scheduled = false;
        var info = {
          target: this._target,
          addedNodes: [],
          removedNodes: []
        };
        var newNodes = this.constructor.getFlattenedNodes(this._target);
        var splices = Polymer.ArraySplice.calculateSplices(newNodes, this._effectiveNodes);
        // process removals
        for (var i = 0, s; i < splices.length && (s = splices[i]); i++) {
          for (var j = 0, n; j < s.removed.length && (n = s.removed[j]); j++) {
            info.removedNodes.push(n);
          }
        }
        // process adds
        for (var _i = 0, _s; _i < splices.length && (_s = splices[_i]); _i++) {
          for (var _j = _s.index; _j < _s.index + _s.addedCount; _j++) {
            info.addedNodes.push(newNodes[_j]);
          }
        }
        // update cache
        this._effectiveNodes = newNodes;
        var didFlush = false;
        if (info.addedNodes.length || info.removedNodes.length) {
          didFlush = true;
          this.callback.call(this._target, info);
        }
        return didFlush;
      }
    }, {
      key: '_listenSlots',
      value: function _listenSlots(nodeList) {
        for (var i = 0; i < nodeList.length; i++) {
          var n = nodeList[i];
          if (isSlot(n)) {
            n.addEventListener('slotchange', this._boundSchedule);
          }
        }
      }
    }, {
      key: '_unlistenSlots',
      value: function _unlistenSlots(nodeList) {
        for (var i = 0; i < nodeList.length; i++) {
          var n = nodeList[i];
          if (isSlot(n)) {
            n.removeEventListener('slotchange', this._boundSchedule);
          }
        }
      }
    }]);

    return FlattenedNodesObserver;
  }();

  Polymer.FlattenedNodesObserver = FlattenedNodesObserver;
})();

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(54);

(function () {
  'use strict';

  /**
   * Legacy class factory and registration helper for defining Polymer
   * elements.
   *
   * This method is equivalent to
   * `customElements.define(info.is, Polymer.Class(info));`
   *
   * See `Polymer.Class` for details on valid legacy metadata format for `info`.
   *
   * @override
   * @function Polymer
   * @param {!PolymerInit} info Object containing Polymer metadata and functions
   *   to become class methods.
   * @return {!HTMLElement} Generated class
   * @suppress {duplicate, invalidCasts, checkTypes}
   */

  window.Polymer._polymerFn = function (info) {
    // if input is a `class` (aka a function with a prototype), use the prototype
    // remember that the `constructor` will never be called
    var klass = void 0;
    if (typeof info === 'function') {
      klass = info;
    } else {
      klass = Polymer.Class(info);
    }
    customElements.define(klass.is, /** @type {!HTMLElement} */klass);
    return klass;
  };
})();

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

__webpack_require__(22);

(function () {

  'use strict';

  var metaProps = {
    attached: true,
    detached: true,
    ready: true,
    created: true,
    beforeRegister: true,
    registered: true,
    attributeChanged: true,
    // meta objects
    behaviors: true

    /**
     * Applies a "legacy" behavior or array of behaviors to the provided class.
     *
     * Note: this method will automatically also apply the `Polymer.LegacyElementMixin`
     * to ensure that any legacy behaviors can rely on legacy Polymer API on
     * the underlying element.
     *
     * @param {!(Object|Array)} behaviors Behavior object or array of behaviors.
     * @param {!HTMLElement|function(new:HTMLElement)} klass Element class.
     * @return {function(new:HTMLElement)} Returns a new Element class extended by the
     * passed in `behaviors` and also by `Polymer.LegacyElementMixin`.
     * @memberof Polymer
     * @suppress {invalidCasts, checkTypes}
     */
  };function mixinBehaviors(behaviors, klass) {
    if (!behaviors) {
      return (/** @type {HTMLElement} */klass
      );
    }
    // NOTE: ensure the bahevior is extending a class with
    // legacy element api. This is necessary since behaviors expect to be able
    // to access 1.x legacy api.
    klass = Polymer.LegacyElementMixin(klass);
    if (!Array.isArray(behaviors)) {
      behaviors = [behaviors];
    }
    var superBehaviors = klass.prototype.behaviors;
    // get flattened, deduped list of behaviors *not* already on super class
    behaviors = flattenBehaviors(behaviors, null, superBehaviors);
    // mixin new behaviors
    klass = _mixinBehaviors(behaviors, klass);
    if (superBehaviors) {
      behaviors = superBehaviors.concat(behaviors);
    }
    // Set behaviors on prototype for BC...
    klass.prototype.behaviors = behaviors;
    return klass;
  }

  // NOTE:
  // 1.x
  // Behaviors were mixed in *in reverse order* and de-duped on the fly.
  // The rule was that behavior properties were copied onto the element
  // prototype if and only if the property did not already exist.
  // Given: Polymer{ behaviors: [A, B, C, A, B]}, property copy order was:
  // (1), B, (2), A, (3) C. This means prototype properties win over
  // B properties win over A win over C. This mirrors what would happen
  // with inheritance if element extended B extended A extended C.
  //
  // Again given, Polymer{ behaviors: [A, B, C, A, B]}, the resulting
  // `behaviors` array was [C, A, B].
  // Behavior lifecycle methods were called in behavior array order
  // followed by the element, e.g. (1) C.created, (2) A.created,
  // (3) B.created, (4) element.created. There was no support for
  // super, and "super-behavior" methods were callable only by name).
  //
  // 2.x
  // Behaviors are made into proper mixins which live in the
  // element's prototype chain. Behaviors are placed in the element prototype
  // eldest to youngest and de-duped youngest to oldest:
  // So, first [A, B, C, A, B] becomes [C, A, B] then,
  // the element prototype becomes (oldest) (1) Polymer.Element, (2) class(C),
  // (3) class(A), (4) class(B), (5) class(Polymer({...})).
  // Result:
  // This means element properties win over B properties win over A win
  // over C. (same as 1.x)
  // If lifecycle is called (super then me), order is
  // (1) C.created, (2) A.created, (3) B.created, (4) element.created
  // (again same as 1.x)
  function _mixinBehaviors(behaviors, klass) {
    for (var i = 0; i < behaviors.length; i++) {
      var b = behaviors[i];
      if (b) {
        klass = Array.isArray(b) ? _mixinBehaviors(b, klass) : GenerateClassFromInfo(b, klass);
      }
    }
    return klass;
  }

  /**
   * @param {Array} behaviors List of behaviors to flatten.
   * @param {Array=} list Target list to flatten behaviors into.
   * @param {Array=} exclude List of behaviors to exclude from the list.
   * @return {!Array} Returns the list of flattened behaviors.
   */
  function flattenBehaviors(behaviors, list, exclude) {
    list = list || [];
    for (var i = behaviors.length - 1; i >= 0; i--) {
      var b = behaviors[i];
      if (b) {
        if (Array.isArray(b)) {
          flattenBehaviors(b, list);
        } else {
          // dedup
          if (list.indexOf(b) < 0 && (!exclude || exclude.indexOf(b) < 0)) {
            list.unshift(b);
          }
        }
      } else {
        console.warn('behavior is null, check for missing or 404 import');
      }
    }
    return list;
  }

  /**
   * @param {!PolymerInit} info Polymer info object
   * @param {function(new:HTMLElement)} Base base class to extend with info object
   * @return {function(new:HTMLElement)} Generated class
   * @suppress {checkTypes}
   * @private
   */
  function GenerateClassFromInfo(info, Base) {
    var PolymerGenerated = function (_Base) {
      _inherits(PolymerGenerated, _Base);

      function PolymerGenerated() {
        _classCallCheck(this, PolymerGenerated);

        return _possibleConstructorReturn(this, (PolymerGenerated.__proto__ || Object.getPrototypeOf(PolymerGenerated)).apply(this, arguments));
      }

      _createClass(PolymerGenerated, [{
        key: 'created',
        value: function created() {
          _get(PolymerGenerated.prototype.__proto__ || Object.getPrototypeOf(PolymerGenerated.prototype), 'created', this).call(this);
          if (info.created) {
            info.created.call(this);
          }
        }
      }, {
        key: '_registered',
        value: function _registered() {
          _get(PolymerGenerated.prototype.__proto__ || Object.getPrototypeOf(PolymerGenerated.prototype), '_registered', this).call(this);
          /* NOTE: `beforeRegister` is called here for bc, but the behavior
           is different than in 1.x. In 1.0, the method was called *after*
           mixing prototypes together but *before* processing of meta-objects.
           However, dynamic effects can still be set here and can be done either
           in `beforeRegister` or `registered`. It is no longer possible to set
           `is` in `beforeRegister` as you could in 1.x.
          */
          if (info.beforeRegister) {
            info.beforeRegister.call(Object.getPrototypeOf(this));
          }
          if (info.registered) {
            info.registered.call(Object.getPrototypeOf(this));
          }
        }
      }, {
        key: '_applyListeners',
        value: function _applyListeners() {
          _get(PolymerGenerated.prototype.__proto__ || Object.getPrototypeOf(PolymerGenerated.prototype), '_applyListeners', this).call(this);
          if (info.listeners) {
            for (var l in info.listeners) {
              this._addMethodEventListenerToNode(this, l, info.listeners[l]);
            }
          }
        }

        // note: exception to "super then me" rule;
        // do work before calling super so that super attributes
        // only apply if not already set.

      }, {
        key: '_ensureAttributes',
        value: function _ensureAttributes() {
          if (info.hostAttributes) {
            for (var a in info.hostAttributes) {
              this._ensureAttribute(a, info.hostAttributes[a]);
            }
          }
          _get(PolymerGenerated.prototype.__proto__ || Object.getPrototypeOf(PolymerGenerated.prototype), '_ensureAttributes', this).call(this);
        }
      }, {
        key: 'ready',
        value: function ready() {
          _get(PolymerGenerated.prototype.__proto__ || Object.getPrototypeOf(PolymerGenerated.prototype), 'ready', this).call(this);
          if (info.ready) {
            info.ready.call(this);
          }
        }
      }, {
        key: 'attached',
        value: function attached() {
          _get(PolymerGenerated.prototype.__proto__ || Object.getPrototypeOf(PolymerGenerated.prototype), 'attached', this).call(this);
          if (info.attached) {
            info.attached.call(this);
          }
        }
      }, {
        key: 'detached',
        value: function detached() {
          _get(PolymerGenerated.prototype.__proto__ || Object.getPrototypeOf(PolymerGenerated.prototype), 'detached', this).call(this);
          if (info.detached) {
            info.detached.call(this);
          }
        }
      }, {
        key: 'attributeChanged',
        value: function attributeChanged(name, old, value) {
          _get(PolymerGenerated.prototype.__proto__ || Object.getPrototypeOf(PolymerGenerated.prototype), 'attributeChanged', this).call(this, name, old, value);
          if (info.attributeChanged) {
            info.attributeChanged.call(this, name, old, value);
          }
        }
      }], [{
        key: 'properties',
        get: function get() {
          return info.properties;
        }
      }, {
        key: 'observers',
        get: function get() {
          return info.observers;
        }

        /**
         * @return {HTMLTemplateElement} template for this class
         */

      }, {
        key: 'template',
        get: function get() {
          // get template first from any imperative set in `info._template`
          return info._template ||
          // next look in dom-module associated with this element's is.
          Polymer.DomModule && Polymer.DomModule.import(this.is, 'template') ||
          // next look for superclass template (note: use superclass symbol
          // to ensure correct `this.is`)
          Base.template ||
          // finally fall back to `_template` in element's protoype.
          this.prototype._template || null;
        }
      }]);

      return PolymerGenerated;
    }(Base);

    PolymerGenerated.generatedFrom = info;

    for (var p in info) {
      // NOTE: cannot copy `metaProps` methods onto prototype at least because
      // `super.ready` must be called and is not included in the user fn.
      if (!(p in metaProps)) {
        var pd = Object.getOwnPropertyDescriptor(info, p);
        if (pd) {
          Object.defineProperty(PolymerGenerated.prototype, p, pd);
        }
      }
    }

    return PolymerGenerated;
  }

  /**
   * Generates a class that extends `Polymer.LegacyElement` based on the
   * provided info object.  Metadata objects on the `info` object
   * (`properties`, `observers`, `listeners`, `behaviors`, `is`) are used
   * for Polymer's meta-programming systems, and any functions are copied
   * to the generated class.
   *
   * Valid "metadata" values are as follows:
   *
   * `is`: String providing the tag name to register the element under. In
   * addition, if a `dom-module` with the same id exists, the first template
   * in that `dom-module` will be stamped into the shadow root of this element,
   * with support for declarative event listeners (`on-...`), Polymer data
   * bindings (`[[...]]` and `{{...}}`), and id-based node finding into
   * `this.$`.
   *
   * `properties`: Object describing property-related metadata used by Polymer
   * features (key: property names, value: object containing property metadata).
   * Valid keys in per-property metadata include:
   * - `type` (String|Number|Object|Array|...): Used by
   *   `attributeChangedCallback` to determine how string-based attributes
   *   are deserialized to JavaScript property values.
   * - `notify` (boolean): Causes a change in the property to fire a
   *   non-bubbling event called `<property>-changed`. Elements that have
   *   enabled two-way binding to the property use this event to observe changes.
   * - `readOnly` (boolean): Creates a getter for the property, but no setter.
   *   To set a read-only property, use the private setter method
   *   `_setProperty(property, value)`.
   * - `observer` (string): Observer method name that will be called when
   *   the property changes. The arguments of the method are
   *   `(value, previousValue)`.
   * - `computed` (string): String describing method and dependent properties
   *   for computing the value of this property (e.g. `'computeFoo(bar, zot)'`).
   *   Computed properties are read-only by default and can only be changed
   *   via the return value of the computing method.
   *
   * `observers`: Array of strings describing multi-property observer methods
   *  and their dependent properties (e.g. `'observeABC(a, b, c)'`).
   *
   * `listeners`: Object describing event listeners to be added to each
   *  instance of this element (key: event name, value: method name).
   *
   * `behaviors`: Array of additional `info` objects containing metadata
   * and callbacks in the same format as the `info` object here which are
   * merged into this element.
   *
   * `hostAttributes`: Object listing attributes to be applied to the host
   *  once created (key: attribute name, value: attribute value).  Values
   *  are serialized based on the type of the value.  Host attributes should
   *  generally be limited to attributes such as `tabIndex` and `aria-...`.
   *  Attributes in `hostAttributes` are only applied if a user-supplied
   *  attribute is not already present (attributes in markup override
   *  `hostAttributes`).
   *
   * In addition, the following Polymer-specific callbacks may be provided:
   * - `registered`: called after first instance of this element,
   * - `created`: called during `constructor`
   * - `attached`: called during `connectedCallback`
   * - `detached`: called during `disconnectedCallback`
   * - `ready`: called before first `attached`, after all properties of
   *   this element have been propagated to its template and all observers
   *   have run
   *
   * @param {!PolymerInit} info Object containing Polymer metadata and functions
   *   to become class methods.
   * @return {function(new:HTMLElement)} Generated class
   * @memberof Polymer
   */
  Polymer.Class = function (info) {
    if (!info) {
      console.warn('Polymer.Class requires `info` argument');
    }
    var klass = GenerateClassFromInfo(info, info.behaviors ?
    // note: mixinBehaviors ensures `LegacyElementMixin`.
    mixinBehaviors(info.behaviors, HTMLElement) : Polymer.LegacyElementMixin(HTMLElement));
    // decorate klass with registration info
    klass.is = info.is;
    return klass;
  };

  Polymer.mixinBehaviors = mixinBehaviors;
})();

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(14);

(function () {
  'use strict';

  var TemplateInstanceBase = Polymer.TemplateInstanceBase; // eslint-disable-line

  /**
   * @typedef {{
   *   _templatizerTemplate: HTMLTemplateElement,
   *   _parentModel: boolean,
   *   _instanceProps: Object,
   *   _forwardHostPropV2: Function,
   *   _notifyInstancePropV2: Function,
   *   ctor: TemplateInstanceBase
   * }}
   */
  var TemplatizerUser = void 0; // eslint-disable-line

  /**
   * The `Polymer.Templatizer` behavior adds methods to generate instances of
   * templates that are each managed by an anonymous `Polymer.PropertyEffects`
   * instance where data-bindings in the stamped template content are bound to
   * accessors on itself.
   *
   * This behavior is provided in Polymer 2.x as a hybrid-element convenience
   * only.  For non-hybrid usage, the `Polymer.Templatize` library
   * should be used instead.
   *
   * Example:
   *
   *     // Get a template from somewhere, e.g. light DOM
   *     let template = this.querySelector('template');
   *     // Prepare the template
   *     this.templatize(template);
   *     // Instance the template with an initial data model
   *     let instance = this.stamp({myProp: 'initial'});
   *     // Insert the instance's DOM somewhere, e.g. light DOM
   *     Polymer.dom(this).appendChild(instance.root);
   *     // Changing a property on the instance will propagate to bindings
   *     // in the template
   *     instance.myProp = 'new value';
   *
   * Users of `Templatizer` may need to implement the following abstract
   * API's to determine how properties and paths from the host should be
   * forwarded into to instances:
   *
   *     _forwardHostPropV2: function(prop, value)
   *
   * Likewise, users may implement these additional abstract API's to determine
   * how instance-specific properties that change on the instance should be
   * forwarded out to the host, if necessary.
   *
   *     _notifyInstancePropV2: function(inst, prop, value)
   *
   * In order to determine which properties are instance-specific and require
   * custom notification via `_notifyInstanceProp`, define an `_instanceProps`
   * object containing keys for each instance prop, for example:
   *
   *     _instanceProps: {
   *       item: true,
   *       index: true
   *     }
   *
   * Any properties used in the template that are not defined in _instanceProp
   * will be forwarded out to the Templatize `owner` automatically.
   *
   * Users may also implement the following abstract function to show or
   * hide any DOM generated using `stamp`:
   *
   *     _showHideChildren: function(shouldHide)
   *
   * Note that some callbacks are suffixed with `V2` in the Polymer 2.x behavior
   * as the implementations will need to differ from the callbacks required
   * by the 1.x Templatizer API due to changes in the `TemplateInstance` API
   * between versions 1.x and 2.x.
   *
   * @polymerBehavior
   * @memberof Polymer
   */
  var Templatizer = {

    /**
     * Generates an anonymous `TemplateInstance` class (stored as `this.ctor`)
     * for the provided template.  This method should be called once per
     * template to prepare an element for stamping the template, followed
     * by `stamp` to create new instances of the template.
     *
     * @param {HTMLTemplateElement} template Template to prepare
     * @param {boolean=} mutableData When `true`, the generated class will skip
     *   strict dirty-checking for objects and arrays (always consider them to
     *   be "dirty"). Defaults to false.
     * @this {TemplatizerUser}
     */
    templatize: function templatize(template, mutableData) {
      this._templatizerTemplate = template;
      this.ctor = Polymer.Templatize.templatize(template, this, {
        mutableData: Boolean(mutableData),
        parentModel: this._parentModel,
        instanceProps: this._instanceProps,
        forwardHostProp: this._forwardHostPropV2,
        notifyInstanceProp: this._notifyInstancePropV2
      });
    },


    /**
     * Creates an instance of the template prepared by `templatize`.  The object
     * returned is an instance of the anonymous class generated by `templatize`
     * whose `root` property is a document fragment containing newly cloned
     * template content, and which has property accessors corresponding to
     * properties referenced in template bindings.
     *
     * @param {Object=} model Object containing initial property values to
     *   populate into the template bindings.
     * @return {TemplateInstanceBase} Returns the created instance of
     * the template prepared by `templatize`.
     * @this {TemplatizerUser}
     */
    stamp: function stamp(model) {
      return new this.ctor(model);
    },


    /**
     * Returns the template "model" (`TemplateInstance`) associated with
     * a given element, which serves as the binding scope for the template
     * instance the element is contained in.  A template model should be used
     * to manipulate data associated with this template instance.
     *
     * @param {HTMLElement} el Element for which to return a template model.
     * @return {TemplateInstanceBase} Model representing the binding scope for
     *   the element.
     * @this {TemplatizerUser}
     */
    modelForElement: function modelForElement(el) {
      return Polymer.Templatize.modelForElement(this._templatizerTemplate, el);
    }
  };

  Polymer.Templatizer = Templatizer;
})();

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

__webpack_require__(1);

__webpack_require__(11);

__webpack_require__(9);

__webpack_require__(23);

(function () {
  'use strict';

  /**
   * @constructor
   * @extends {HTMLElement}
   * @implements {Polymer_PropertyEffects}
   * @implements {Polymer_OptionalMutableData}
   * @implements {Polymer_GestureEventListeners}
   */

  var domBindBase = Polymer.GestureEventListeners(Polymer.OptionalMutableData(Polymer.PropertyEffects(HTMLElement)));

  /**
   * Custom element to allow using Polymer's template features (data binding,
   * declarative event listeners, etc.) in the main document without defining
   * a new custom element.
   *
   * `<template>` tags utilizing bindings may be wrapped with the `<dom-bind>`
   * element, which will immediately stamp the wrapped template into the main
   * document and bind elements to the `dom-bind` element itself as the
   * binding scope.
   *
   * @polymer
   * @customElement
   * @appliesMixin Polymer.PropertyEffects
   * @appliesMixin Polymer.OptionalMutableData
   * @appliesMixin Polymer.GestureEventListeners
   * @extends {domBindBase}
   * @memberof Polymer
   * @summary Custom element to allow using Polymer's template features (data
   *   binding, declarative event listeners, etc.) in the main document.
   */

  var DomBind = function (_domBindBase) {
    _inherits(DomBind, _domBindBase);

    _createClass(DomBind, null, [{
      key: 'observedAttributes',
      get: function get() {
        return ['mutable-data'];
      }
    }]);

    function DomBind() {
      _classCallCheck(this, DomBind);

      var _this = _possibleConstructorReturn(this, (DomBind.__proto__ || Object.getPrototypeOf(DomBind)).call(this));

      _this.root = null;
      _this.$ = null;
      _this.__children = null;
      return _this;
    }

    // assumes only one observed attribute


    _createClass(DomBind, [{
      key: 'attributeChangedCallback',
      value: function attributeChangedCallback() {
        this.mutableData = true;
      }
    }, {
      key: 'connectedCallback',
      value: function connectedCallback() {
        this.render();
      }
    }, {
      key: 'disconnectedCallback',
      value: function disconnectedCallback() {
        this.__removeChildren();
      }
    }, {
      key: '__insertChildren',
      value: function __insertChildren() {
        this.parentNode.insertBefore(this.root, this);
      }
    }, {
      key: '__removeChildren',
      value: function __removeChildren() {
        if (this.__children) {
          for (var i = 0; i < this.__children.length; i++) {
            this.root.appendChild(this.__children[i]);
          }
        }
      }

      /**
       * Forces the element to render its content. This is typically only
       * necessary to call if HTMLImports with the async attribute are used.
       */

    }, {
      key: 'render',
      value: function render() {
        var _this2 = this;

        var template = void 0;
        if (!this.__children) {
          template = /** @type {HTMLTemplateElement} */template || this.querySelector('template');
          if (!template) {
            // Wait until childList changes and template should be there by then
            var observer = new MutationObserver(function () {
              template = /** @type {HTMLTemplateElement} */_this2.querySelector('template');
              if (template) {
                observer.disconnect();
                _this2.render();
              } else {
                throw new Error('dom-bind requires a <template> child');
              }
            });
            observer.observe(this, { childList: true });
            return;
          }
          this.root = this._stampTemplate(template);
          this.$ = this.root.$;
          this.__children = [];
          for (var n = this.root.firstChild; n; n = n.nextSibling) {
            this.__children[this.__children.length] = n;
          }
          this._enableProperties();
        }
        this.__insertChildren();
        this.dispatchEvent(new CustomEvent('dom-change', {
          bubbles: true,
          composed: true
        }));
      }
    }]);

    return DomBind;
  }(domBindBase);

  customElements.define('dom-bind', DomBind);
})();

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

__webpack_require__(6);

__webpack_require__(14);

__webpack_require__(12);

__webpack_require__(13);

__webpack_require__(9);

(function () {
  'use strict';

  var TemplateInstanceBase = Polymer.TemplateInstanceBase; // eslint-disable-line

  /**
   * @constructor
   * @implements {Polymer_OptionalMutableData}
   * @extends {Polymer.Element}
   */
  var domRepeatBase = Polymer.OptionalMutableData(Polymer.Element);

  /**
   * The `<dom-repeat>` element will automatically stamp and binds one instance
   * of template content to each object in a user-provided array.
   * `dom-repeat` accepts an `items` property, and one instance of the template
   * is stamped for each item into the DOM at the location of the `dom-repeat`
   * element.  The `item` property will be set on each instance's binding
   * scope, thus templates should bind to sub-properties of `item`.
   *
   * Example:
   *
   * ```html
   * <dom-module id="employee-list">
   *
   *   <template>
   *
   *     <div> Employee list: </div>
   *     <template is="dom-repeat" items="{{employees}}">
   *         <div>First name: <span>{{item.first}}</span></div>
   *         <div>Last name: <span>{{item.last}}</span></div>
   *     </template>
   *
   *   </template>
   *
   *   <script>
   *     Polymer({
   *       is: 'employee-list',
   *       ready: function() {
   *         this.employees = [
   *             {first: 'Bob', last: 'Smith'},
   *             {first: 'Sally', last: 'Johnson'},
   *             ...
   *         ];
   *       }
   *     });
   *   < /script>
   *
   * </dom-module>
   * ```
   *
   * Notifications for changes to items sub-properties will be forwarded to template
   * instances, which will update via the normal structured data notification system.
   *
   * Mutations to the `items` array itself should be made using the Array
   * mutation API's on `Polymer.Base` (`push`, `pop`, `splice`, `shift`,
   * `unshift`), and template instances will be kept in sync with the data in the
   * array.
   *
   * Events caught by event handlers within the `dom-repeat` template will be
   * decorated with a `model` property, which represents the binding scope for
   * each template instance.  The model is an instance of Polymer.Base, and should
   * be used to manipulate data on the instance, for example
   * `event.model.set('item.checked', true);`.
   *
   * Alternatively, the model for a template instance for an element stamped by
   * a `dom-repeat` can be obtained using the `modelForElement` API on the
   * `dom-repeat` that stamped it, for example
   * `this.$.domRepeat.modelForElement(event.target).set('item.checked', true);`.
   * This may be useful for manipulating instance data of event targets obtained
   * by event handlers on parents of the `dom-repeat` (event delegation).
   *
   * A view-specific filter/sort may be applied to each `dom-repeat` by supplying a
   * `filter` and/or `sort` property.  This may be a string that names a function on
   * the host, or a function may be assigned to the property directly.  The functions
   * should implemented following the standard `Array` filter/sort API.
   *
   * In order to re-run the filter or sort functions based on changes to sub-fields
   * of `items`, the `observe` property may be set as a space-separated list of
   * `item` sub-fields that should cause a re-filter/sort when modified.  If
   * the filter or sort function depends on properties not contained in `items`,
   * the user should observe changes to those properties and call `render` to update
   * the view based on the dependency change.
   *
   * For example, for an `dom-repeat` with a filter of the following:
   *
   * ```js
   * isEngineer: function(item) {
   *     return item.type == 'engineer' || item.manager.type == 'engineer';
   * }
   * ```
   *
   * Then the `observe` property should be configured as follows:
   *
   * ```html
   * <template is="dom-repeat" items="{{employees}}"
   *           filter="isEngineer" observe="type manager.type">
   * ```
   *
   * @customElement
   * @polymer
   * @memberof Polymer
   * @extends {domRepeatBase}
   * @appliesMixin Polymer.OptionalMutableData
   * @summary Custom element for stamping instance of a template bound to
   *   items in an array.
   */

  var DomRepeat = function (_domRepeatBase) {
    _inherits(DomRepeat, _domRepeatBase);

    _createClass(DomRepeat, null, [{
      key: 'is',


      // Not needed to find template; can be removed once the analyzer
      // can find the tag name from customElements.define call
      get: function get() {
        return 'dom-repeat';
      }
    }, {
      key: 'template',
      get: function get() {
        return null;
      }
    }, {
      key: 'properties',
      get: function get() {

        /**
         * Fired whenever DOM is added or removed by this template (by
         * default, rendering occurs lazily).  To force immediate rendering, call
         * `render`.
         *
         * @event dom-change
         */
        return {

          /**
           * An array containing items determining how many instances of the template
           * to stamp and that that each template instance should bind to.
           */
          items: {
            type: Array
          },

          /**
           * The name of the variable to add to the binding scope for the array
           * element associated with a given template instance.
           */
          as: {
            type: String,
            value: 'item'
          },

          /**
           * The name of the variable to add to the binding scope with the index
           * of the instance in the sorted and filtered list of rendered items.
           * Note, for the index in the `this.items` array, use the value of the
           * `itemsIndexAs` property.
           */
          indexAs: {
            type: String,
            value: 'index'
          },

          /**
           * The name of the variable to add to the binding scope with the index
           * of the instance in the `this.items` array. Note, for the index of
           * this instance in the sorted and filtered list of rendered items,
           * use the value of the `indexAs` property.
           */
          itemsIndexAs: {
            type: String,
            value: 'itemsIndex'
          },

          /**
           * A function that should determine the sort order of the items.  This
           * property should either be provided as a string, indicating a method
           * name on the element's host, or else be an actual function.  The
           * function should match the sort function passed to `Array.sort`.
           * Using a sort function has no effect on the underlying `items` array.
           */
          sort: {
            type: Function,
            observer: '__sortChanged'
          },

          /**
           * A function that can be used to filter items out of the view.  This
           * property should either be provided as a string, indicating a method
           * name on the element's host, or else be an actual function.  The
           * function should match the sort function passed to `Array.filter`.
           * Using a filter function has no effect on the underlying `items` array.
           */
          filter: {
            type: Function,
            observer: '__filterChanged'
          },

          /**
           * When using a `filter` or `sort` function, the `observe` property
           * should be set to a space-separated list of the names of item
           * sub-fields that should trigger a re-sort or re-filter when changed.
           * These should generally be fields of `item` that the sort or filter
           * function depends on.
           */
          observe: {
            type: String,
            observer: '__observeChanged'
          },

          /**
           * When using a `filter` or `sort` function, the `delay` property
           * determines a debounce time after a change to observed item
           * properties that must pass before the filter or sort is re-run.
           * This is useful in rate-limiting shuffing of the view when
           * item changes may be frequent.
           */
          delay: Number,

          /**
           * Count of currently rendered items after `filter` (if any) has been applied.
           * If "chunking mode" is enabled, `renderedItemCount` is updated each time a
           * set of template instances is rendered.
           *
           */
          renderedItemCount: {
            type: Number,
            notify: true,
            readOnly: true
          },

          /**
           * Defines an initial count of template instances to render after setting
           * the `items` array, before the next paint, and puts the `dom-repeat`
           * into "chunking mode".  The remaining items will be created and rendered
           * incrementally at each animation frame therof until all instances have
           * been rendered.
           */
          initialCount: {
            type: Number,
            observer: '__initializeChunking'
          },

          /**
           * When `initialCount` is used, this property defines a frame rate to
           * target by throttling the number of instances rendered each frame to
           * not exceed the budget for the target frame rate.  Setting this to a
           * higher number will allow lower latency and higher throughput for
           * things like event handlers, but will result in a longer time for the
           * remaining items to complete rendering.
           */
          targetFramerate: {
            type: Number,
            value: 20
          },

          _targetFrameTime: {
            type: Number,
            computed: '__computeFrameTime(targetFramerate)'
          }

        };
      }
    }, {
      key: 'observers',
      get: function get() {
        return ['__itemsChanged(items.*)'];
      }
    }]);

    function DomRepeat() {
      _classCallCheck(this, DomRepeat);

      var _this = _possibleConstructorReturn(this, (DomRepeat.__proto__ || Object.getPrototypeOf(DomRepeat)).call(this));

      _this.__instances = [];
      _this.__limit = Infinity;
      _this.__pool = [];
      _this.__renderDebouncer = null;
      _this.__itemsIdxToInstIdx = {};
      _this.__chunkCount = null;
      _this.__lastChunkTime = null;
      _this.__sortFn = null;
      _this.__filterFn = null;
      _this.__observePaths = null;
      _this.__ctor = null;
      _this.__isDetached = true;
      _this.template = null;
      return _this;
    }

    _createClass(DomRepeat, [{
      key: 'disconnectedCallback',
      value: function disconnectedCallback() {
        _get(DomRepeat.prototype.__proto__ || Object.getPrototypeOf(DomRepeat.prototype), 'disconnectedCallback', this).call(this);
        this.__isDetached = true;
        for (var i = 0; i < this.__instances.length; i++) {
          this.__detachInstance(i);
        }
      }
    }, {
      key: 'connectedCallback',
      value: function connectedCallback() {
        _get(DomRepeat.prototype.__proto__ || Object.getPrototypeOf(DomRepeat.prototype), 'connectedCallback', this).call(this);
        // only perform attachment if the element was previously detached.
        if (this.__isDetached) {
          this.__isDetached = false;
          var parent = this.parentNode;
          for (var i = 0; i < this.__instances.length; i++) {
            this.__attachInstance(i, parent);
          }
        }
      }
    }, {
      key: '__ensureTemplatized',
      value: function __ensureTemplatized() {
        var _this2 = this;

        // Templatizing (generating the instance constructor) needs to wait
        // until ready, since won't have its template content handed back to
        // it until then
        if (!this.__ctor) {
          var template = this.template = this.querySelector('template');
          if (!template) {
            // // Wait until childList changes and template should be there by then
            var observer = new MutationObserver(function () {
              if (_this2.querySelector('template')) {
                observer.disconnect();
                _this2.__render();
              } else {
                throw new Error('dom-repeat requires a <template> child');
              }
            });
            observer.observe(this, { childList: true });
            return false;
          }
          // Template instance props that should be excluded from forwarding
          var instanceProps = {};
          instanceProps[this.as] = true;
          instanceProps[this.indexAs] = true;
          instanceProps[this.itemsIndexAs] = true;
          this.__ctor = Polymer.Templatize.templatize(template, this, {
            mutableData: this.mutableData,
            parentModel: true,
            instanceProps: instanceProps,
            /**
             * @this {this}
             * @param {string} prop Property to set
             * @param {*} value Value to set property to
             */
            forwardHostProp: function forwardHostProp(prop, value) {
              var i$ = this.__instances;
              for (var i = 0, inst; i < i$.length && (inst = i$[i]); i++) {
                inst.forwardHostProp(prop, value);
              }
            },
            /**
             * @this {this}
             * @param {Object} inst Instance to notify
             * @param {string} prop Property to notify
             * @param {*} value Value to notify
             */
            notifyInstanceProp: function notifyInstanceProp(inst, prop, value) {
              if (Polymer.Path.matches(this.as, prop)) {
                var idx = inst[this.itemsIndexAs];
                if (prop == this.as) {
                  this.items[idx] = value;
                }
                var path = Polymer.Path.translate(this.as, 'items.' + idx, prop);
                this.notifyPath(path, value);
              }
            }
          });
        }
        return true;
      }
    }, {
      key: '__getMethodHost',
      value: function __getMethodHost() {
        // Technically this should be the owner of the outermost template.
        // In shadow dom, this is always getRootNode().host, but we can
        // approximate this via cooperation with our dataHost always setting
        // `_methodHost` as long as there were bindings (or id's) on this
        // instance causing it to get a dataHost.
        return this.__dataHost._methodHost || this.__dataHost;
      }
    }, {
      key: '__sortChanged',
      value: function __sortChanged(sort) {
        var methodHost = this.__getMethodHost();
        this.__sortFn = sort && (typeof sort == 'function' ? sort : function () {
          return methodHost[sort].apply(methodHost, arguments);
        });
        if (this.items) {
          this.__debounceRender(this.__render);
        }
      }
    }, {
      key: '__filterChanged',
      value: function __filterChanged(filter) {
        var methodHost = this.__getMethodHost();
        this.__filterFn = filter && (typeof filter == 'function' ? filter : function () {
          return methodHost[filter].apply(methodHost, arguments);
        });
        if (this.items) {
          this.__debounceRender(this.__render);
        }
      }
    }, {
      key: '__computeFrameTime',
      value: function __computeFrameTime(rate) {
        return Math.ceil(1000 / rate);
      }
    }, {
      key: '__initializeChunking',
      value: function __initializeChunking() {
        if (this.initialCount) {
          this.__limit = this.initialCount;
          this.__chunkCount = this.initialCount;
          this.__lastChunkTime = performance.now();
        }
      }
    }, {
      key: '__tryRenderChunk',
      value: function __tryRenderChunk() {
        // Debounced so that multiple calls through `_render` between animation
        // frames only queue one new rAF (e.g. array mutation & chunked render)
        if (this.items && this.__limit < this.items.length) {
          this.__debounceRender(this.__requestRenderChunk);
        }
      }
    }, {
      key: '__requestRenderChunk',
      value: function __requestRenderChunk() {
        var _this3 = this;

        requestAnimationFrame(function () {
          return _this3.__renderChunk();
        });
      }
    }, {
      key: '__renderChunk',
      value: function __renderChunk() {
        // Simple auto chunkSize throttling algorithm based on feedback loop:
        // measure actual time between frames and scale chunk count by ratio
        // of target/actual frame time
        var currChunkTime = performance.now();
        var ratio = this._targetFrameTime / (currChunkTime - this.__lastChunkTime);
        this.__chunkCount = Math.round(this.__chunkCount * ratio) || 1;
        this.__limit += this.__chunkCount;
        this.__lastChunkTime = currChunkTime;
        this.__debounceRender(this.__render);
      }
    }, {
      key: '__observeChanged',
      value: function __observeChanged() {
        this.__observePaths = this.observe && this.observe.replace('.*', '.').split(' ');
      }
    }, {
      key: '__itemsChanged',
      value: function __itemsChanged(change) {
        if (this.items && !Array.isArray(this.items)) {
          console.warn('dom-repeat expected array for `items`, found', this.items);
        }
        // If path was to an item (e.g. 'items.3' or 'items.3.foo'), forward the
        // path to that instance synchronously (retuns false for non-item paths)
        if (!this.__handleItemPath(change.path, change.value)) {
          // Otherwise, the array was reset ('items') or spliced ('items.splices'),
          // so queue a full refresh
          this.__initializeChunking();
          this.__debounceRender(this.__render);
        }
      }
    }, {
      key: '__handleObservedPaths',
      value: function __handleObservedPaths(path) {
        if (this.__observePaths) {
          path = path.substring(path.indexOf('.') + 1);
          var paths = this.__observePaths;
          for (var i = 0; i < paths.length; i++) {
            if (path.indexOf(paths[i]) === 0) {
              this.__debounceRender(this.__render, this.delay);
              return true;
            }
          }
        }
      }

      /**
       * @param {function(this:DomRepeat)} fn Function to debounce.
       * @param {number=} delay Delay in ms to debounce by.
       */

    }, {
      key: '__debounceRender',
      value: function __debounceRender(fn) {
        var delay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

        this.__renderDebouncer = Polymer.Debouncer.debounce(this.__renderDebouncer, delay > 0 ? Polymer.Async.timeOut.after(delay) : Polymer.Async.microTask, fn.bind(this));
        Polymer.enqueueDebouncer(this.__renderDebouncer);
      }

      /**
       * Forces the element to render its content. Normally rendering is
       * asynchronous to a provoking change. This is done for efficiency so
       * that multiple changes trigger only a single render. The render method
       * should be called if, for example, template rendering is required to
       * validate application state.
       */

    }, {
      key: 'render',
      value: function render() {
        // Queue this repeater, then flush all in order
        this.__debounceRender(this.__render);
        Polymer.flush();
      }
    }, {
      key: '__render',
      value: function __render() {
        if (!this.__ensureTemplatized()) {
          // No template found yet
          return;
        }
        this.__applyFullRefresh();
        // Reset the pool
        // TODO(kschaaf): Reuse pool across turns and nested templates
        // Now that objects/arrays are re-evaluated when set, we can safely
        // reuse pooled instances across turns, however we still need to decide
        // semantics regarding how long to hold, how many to hold, etc.
        this.__pool.length = 0;
        // Set rendered item count
        this._setRenderedItemCount(this.__instances.length);
        // Notify users
        this.dispatchEvent(new CustomEvent('dom-change', {
          bubbles: true,
          composed: true
        }));
        // Check to see if we need to render more items
        this.__tryRenderChunk();
      }
    }, {
      key: '__applyFullRefresh',
      value: function __applyFullRefresh() {
        var _this4 = this;

        var items = this.items || [];
        var isntIdxToItemsIdx = new Array(items.length);
        for (var i = 0; i < items.length; i++) {
          isntIdxToItemsIdx[i] = i;
        }
        // Apply user filter
        if (this.__filterFn) {
          isntIdxToItemsIdx = isntIdxToItemsIdx.filter(function (i, idx, array) {
            return _this4.__filterFn(items[i], idx, array);
          });
        }
        // Apply user sort
        if (this.__sortFn) {
          isntIdxToItemsIdx.sort(function (a, b) {
            return _this4.__sortFn(items[a], items[b]);
          });
        }
        // items->inst map kept for item path forwarding
        var itemsIdxToInstIdx = this.__itemsIdxToInstIdx = {};
        var instIdx = 0;
        // Generate instances and assign items
        var limit = Math.min(isntIdxToItemsIdx.length, this.__limit);
        for (; instIdx < limit; instIdx++) {
          var inst = this.__instances[instIdx];
          var itemIdx = isntIdxToItemsIdx[instIdx];
          var item = items[itemIdx];
          itemsIdxToInstIdx[itemIdx] = instIdx;
          if (inst && instIdx < this.__limit) {
            inst._setPendingProperty(this.as, item);
            inst._setPendingProperty(this.indexAs, instIdx);
            inst._setPendingProperty(this.itemsIndexAs, itemIdx);
            inst._flushProperties();
          } else {
            this.__insertInstance(item, instIdx, itemIdx);
          }
        }
        // Remove any extra instances from previous state
        for (var _i = this.__instances.length - 1; _i >= instIdx; _i--) {
          this.__detachAndRemoveInstance(_i);
        }
      }
    }, {
      key: '__detachInstance',
      value: function __detachInstance(idx) {
        var inst = this.__instances[idx];
        for (var i = 0; i < inst.children.length; i++) {
          var el = inst.children[i];
          inst.root.appendChild(el);
        }
        return inst;
      }
    }, {
      key: '__attachInstance',
      value: function __attachInstance(idx, parent) {
        var inst = this.__instances[idx];
        parent.insertBefore(inst.root, this);
      }
    }, {
      key: '__detachAndRemoveInstance',
      value: function __detachAndRemoveInstance(idx) {
        var inst = this.__detachInstance(idx);
        if (inst) {
          this.__pool.push(inst);
        }
        this.__instances.splice(idx, 1);
      }
    }, {
      key: '__stampInstance',
      value: function __stampInstance(item, instIdx, itemIdx) {
        var model = {};
        model[this.as] = item;
        model[this.indexAs] = instIdx;
        model[this.itemsIndexAs] = itemIdx;
        return new this.__ctor(model);
      }
    }, {
      key: '__insertInstance',
      value: function __insertInstance(item, instIdx, itemIdx) {
        var inst = this.__pool.pop();
        if (inst) {
          // TODO(kschaaf): If the pool is shared across turns, hostProps
          // need to be re-set to reused instances in addition to item
          inst._setPendingProperty(this.as, item);
          inst._setPendingProperty(this.indexAs, instIdx);
          inst._setPendingProperty(this.itemsIndexAs, itemIdx);
          inst._flushProperties();
        } else {
          inst = this.__stampInstance(item, instIdx, itemIdx);
        }
        var beforeRow = this.__instances[instIdx + 1];
        var beforeNode = beforeRow ? beforeRow.children[0] : this;
        this.parentNode.insertBefore(inst.root, beforeNode);
        this.__instances[instIdx] = inst;
        return inst;
      }

      // Implements extension point from Templatize mixin

    }, {
      key: '_showHideChildren',
      value: function _showHideChildren(hidden) {
        for (var i = 0; i < this.__instances.length; i++) {
          this.__instances[i]._showHideChildren(hidden);
        }
      }

      // Called as a side effect of a host items.<key>.<path> path change,
      // responsible for notifying item.<path> changes to inst for key

    }, {
      key: '__handleItemPath',
      value: function __handleItemPath(path, value) {
        var itemsPath = path.slice(6); // 'items.'.length == 6
        var dot = itemsPath.indexOf('.');
        var itemsIdx = dot < 0 ? itemsPath : itemsPath.substring(0, dot);
        // If path was index into array...
        if (itemsIdx == parseInt(itemsIdx, 10)) {
          var itemSubPath = dot < 0 ? '' : itemsPath.substring(dot + 1);
          // If the path is observed, it will trigger a full refresh
          this.__handleObservedPaths(itemSubPath);
          // Note, even if a rull refresh is triggered, always do the path
          // notification because unless mutableData is used for dom-repeat
          // and all elements in the instance subtree, a full refresh may
          // not trigger the proper update.
          var instIdx = this.__itemsIdxToInstIdx[itemsIdx];
          var inst = this.__instances[instIdx];
          if (inst) {
            var itemPath = this.as + (itemSubPath ? '.' + itemSubPath : '');
            // This is effectively `notifyPath`, but avoids some of the overhead
            // of the public API
            inst._setPendingPropertyOrPath(itemPath, value, false, true);
            inst._flushProperties();
          }
          return true;
        }
      }

      /**
       * Returns the item associated with a given element stamped by
       * this `dom-repeat`.
       *
       * Note, to modify sub-properties of the item,
       * `modelForElement(el).set('item.<sub-prop>', value)`
       * should be used.
       *
       * @param {HTMLElement} el Element for which to return the item.
       * @return {*} Item associated with the element.
       */

    }, {
      key: 'itemForElement',
      value: function itemForElement(el) {
        var instance = this.modelForElement(el);
        return instance && instance[this.as];
      }

      /**
       * Returns the inst index for a given element stamped by this `dom-repeat`.
       * If `sort` is provided, the index will reflect the sorted order (rather
       * than the original array order).
       *
       * @param {HTMLElement} el Element for which to return the index.
       * @return {*} Row index associated with the element (note this may
       *   not correspond to the array index if a user `sort` is applied).
       */

    }, {
      key: 'indexForElement',
      value: function indexForElement(el) {
        var instance = this.modelForElement(el);
        return instance && instance[this.indexAs];
      }

      /**
       * Returns the template "model" associated with a given element, which
       * serves as the binding scope for the template instance the element is
       * contained in. A template model is an instance of `Polymer.Base`, and
       * should be used to manipulate data associated with this template instance.
       *
       * Example:
       *
       *   let model = modelForElement(el);
       *   if (model.index < 10) {
       *     model.set('item.checked', true);
       *   }
       *
       * @param {HTMLElement} el Element for which to return a template model.
       * @return {TemplateInstanceBase} Model representing the binding scope for
       *   the element.
       */

    }, {
      key: 'modelForElement',
      value: function modelForElement(el) {
        return Polymer.Templatize.modelForElement(this.template, el);
      }
    }]);

    return DomRepeat;
  }(domRepeatBase);

  customElements.define(DomRepeat.is, DomRepeat);

  Polymer.DomRepeat = DomRepeat;
})();

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

__webpack_require__(6);

__webpack_require__(14);

__webpack_require__(12);

__webpack_require__(13);

(function () {
  'use strict';

  /**
   * The `<dom-if>` element will stamp a light-dom `<template>` child when
   * the `if` property becomes truthy, and the template can use Polymer
   * data-binding and declarative event features when used in the context of
   * a Polymer element's template.
   *
   * When `if` becomes falsey, the stamped content is hidden but not
   * removed from dom. When `if` subsequently becomes truthy again, the content
   * is simply re-shown. This approach is used due to its favorable performance
   * characteristics: the expense of creating template content is paid only
   * once and lazily.
   *
   * Set the `restamp` property to true to force the stamped content to be
   * created / destroyed when the `if` condition changes.
   *
   * @customElement
   * @polymer
   * @extends Polymer.Element
   * @memberof Polymer
   * @summary Custom element that conditionally stamps and hides or removes
   *   template content based on a boolean flag.
   */

  var DomIf = function (_Polymer$Element) {
    _inherits(DomIf, _Polymer$Element);

    _createClass(DomIf, null, [{
      key: 'is',


      // Not needed to find template; can be removed once the analyzer
      // can find the tag name from customElements.define call
      get: function get() {
        return 'dom-if';
      }
    }, {
      key: 'template',
      get: function get() {
        return null;
      }
    }, {
      key: 'properties',
      get: function get() {

        return {

          /**
           * Fired whenever DOM is added or removed/hidden by this template (by
           * default, rendering occurs lazily).  To force immediate rendering, call
           * `render`.
           *
           * @event dom-change
           */

          /**
           * A boolean indicating whether this template should stamp.
           */
          if: {
            type: Boolean,
            observer: '__debounceRender'
          },

          /**
           * When true, elements will be removed from DOM and discarded when `if`
           * becomes false and re-created and added back to the DOM when `if`
           * becomes true.  By default, stamped elements will be hidden but left
           * in the DOM when `if` becomes false, which is generally results
           * in better performance.
           */
          restamp: {
            type: Boolean,
            observer: '__debounceRender'
          }

        };
      }
    }]);

    function DomIf() {
      _classCallCheck(this, DomIf);

      var _this = _possibleConstructorReturn(this, (DomIf.__proto__ || Object.getPrototypeOf(DomIf)).call(this));

      _this.__renderDebouncer = null;
      _this.__invalidProps = null;
      _this.__instance = null;
      _this._lastIf = false;
      _this.__ctor = null;
      return _this;
    }

    _createClass(DomIf, [{
      key: '__debounceRender',
      value: function __debounceRender() {
        var _this2 = this;

        // Render is async for 2 reasons:
        // 1. To eliminate dom creation trashing if user code thrashes `if` in the
        //    same turn. This was more common in 1.x where a compound computed
        //    property could result in the result changing multiple times, but is
        //    mitigated to a large extent by batched property processing in 2.x.
        // 2. To avoid double object propagation when a bag including values bound
        //    to the `if` property as well as one or more hostProps could enqueue
        //    the <dom-if> to flush before the <template>'s host property
        //    forwarding. In that scenario creating an instance would result in
        //    the host props being set once, and then the enqueued changes on the
        //    template would set properties a second time, potentially causing an
        //    object to be set to an instance more than once.  Creating the
        //    instance async from flushing data ensures this doesn't happen. If
        //    we wanted a sync option in the future, simply having <dom-if> flush
        //    (or clear) its template's pending host properties before creating
        //    the instance would also avoid the problem.
        this.__renderDebouncer = Polymer.Debouncer.debounce(this.__renderDebouncer, Polymer.Async.microTask, function () {
          return _this2.__render();
        });
        Polymer.enqueueDebouncer(this.__renderDebouncer);
      }
    }, {
      key: 'disconnectedCallback',
      value: function disconnectedCallback() {
        _get(DomIf.prototype.__proto__ || Object.getPrototypeOf(DomIf.prototype), 'disconnectedCallback', this).call(this);
        if (!this.parentNode || this.parentNode.nodeType == Node.DOCUMENT_FRAGMENT_NODE && !this.parentNode.host) {
          this.__teardownInstance();
        }
      }
    }, {
      key: 'connectedCallback',
      value: function connectedCallback() {
        _get(DomIf.prototype.__proto__ || Object.getPrototypeOf(DomIf.prototype), 'connectedCallback', this).call(this);
        if (this.if) {
          this.__debounceRender();
        }
      }

      /**
       * Forces the element to render its content. Normally rendering is
       * asynchronous to a provoking change. This is done for efficiency so
       * that multiple changes trigger only a single render. The render method
       * should be called if, for example, template rendering is required to
       * validate application state.
       */

    }, {
      key: 'render',
      value: function render() {
        Polymer.flush();
      }
    }, {
      key: '__render',
      value: function __render() {
        if (this.if) {
          if (!this.__ensureInstance()) {
            // No template found yet
            return;
          }
          this._showHideChildren();
        } else if (this.restamp) {
          this.__teardownInstance();
        }
        if (!this.restamp && this.__instance) {
          this._showHideChildren();
        }
        if (this.if != this._lastIf) {
          this.dispatchEvent(new CustomEvent('dom-change', {
            bubbles: true,
            composed: true
          }));
          this._lastIf = this.if;
        }
      }
    }, {
      key: '__ensureInstance',
      value: function __ensureInstance() {
        var _this3 = this;

        var parentNode = this.parentNode;
        // Guard against element being detached while render was queued
        if (parentNode) {
          if (!this.__ctor) {
            var template = this.querySelector('template');
            if (!template) {
              // Wait until childList changes and template should be there by then
              var observer = new MutationObserver(function () {
                if (_this3.querySelector('template')) {
                  observer.disconnect();
                  _this3.__render();
                } else {
                  throw new Error('dom-if requires a <template> child');
                }
              });
              observer.observe(this, { childList: true });
              return false;
            }
            this.__ctor = Polymer.Templatize.templatize(template, this, {
              // dom-if templatizer instances require `mutable: true`, as
              // `__syncHostProperties` relies on that behavior to sync objects
              mutableData: true,
              /**
               * @param {string} prop Property to forward
               * @param {*} value Value of property
               * @this {this}
               */
              forwardHostProp: function forwardHostProp(prop, value) {
                if (this.__instance) {
                  if (this.if) {
                    this.__instance.forwardHostProp(prop, value);
                  } else {
                    // If we have an instance but are squelching host property
                    // forwarding due to if being false, note the invalidated
                    // properties so `__syncHostProperties` can sync them the next
                    // time `if` becomes true
                    this.__invalidProps = this.__invalidProps || Object.create(null);
                    this.__invalidProps[Polymer.Path.root(prop)] = true;
                  }
                }
              }
            });
          }
          if (!this.__instance) {
            this.__instance = new this.__ctor();
            parentNode.insertBefore(this.__instance.root, this);
          } else {
            this.__syncHostProperties();
            var c$ = this.__instance.children;
            if (c$ && c$.length) {
              // Detect case where dom-if was re-attached in new position
              var lastChild = this.previousSibling;
              if (lastChild !== c$[c$.length - 1]) {
                for (var i = 0, n; i < c$.length && (n = c$[i]); i++) {
                  parentNode.insertBefore(n, this);
                }
              }
            }
          }
        }
        return true;
      }
    }, {
      key: '__syncHostProperties',
      value: function __syncHostProperties() {
        var props = this.__invalidProps;
        if (props) {
          for (var prop in props) {
            this.__instance._setPendingProperty(prop, this.__dataHost[prop]);
          }
          this.__invalidProps = null;
          this.__instance._flushProperties();
        }
      }
    }, {
      key: '__teardownInstance',
      value: function __teardownInstance() {
        if (this.__instance) {
          var c$ = this.__instance.children;
          if (c$ && c$.length) {
            // use first child parent, for case when dom-if may have been detached
            var parent = c$[0].parentNode;
            for (var i = 0, n; i < c$.length && (n = c$[i]); i++) {
              parent.removeChild(n);
            }
          }
          this.__instance = null;
          this.__invalidProps = null;
        }
      }
    }, {
      key: '_showHideChildren',
      value: function _showHideChildren() {
        var hidden = this.__hideTemplateChildren__ || !this.if;
        if (this.__instance) {
          this.__instance._showHideChildren(hidden);
        }
      }
    }]);

    return DomIf;
  }(Polymer.Element);

  customElements.define(DomIf.is, DomIf);

  Polymer.DomIf = DomIf;
})();

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

__webpack_require__(6);

__webpack_require__(3);

__webpack_require__(24);

(function () {
  'use strict';

  /**
   * Element mixin for recording dynamic associations between item paths in a
   * master `items` array and a `selected` array such that path changes to the
   * master array (at the host) element or elsewhere via data-binding) are
   * correctly propagated to items in the selected array and vice-versa.
   *
   * The `items` property accepts an array of user data, and via the
   * `select(item)` and `deselect(item)` API, updates the `selected` property
   * which may be bound to other parts of the application, and any changes to
   * sub-fields of `selected` item(s) will be kept in sync with items in the
   * `items` array.  When `multi` is false, `selected` is a property
   * representing the last selected item.  When `multi` is true, `selected`
   * is an array of multiply selected items.
   *
   * @polymer
   * @mixinFunction
   * @appliesMixin Polymer.ElementMixin
   * @memberof Polymer
   * @summary Element mixin for recording dynamic associations between item paths in a
   * master `items` array and a `selected` array
   */

  var ArraySelectorMixin = Polymer.dedupingMixin(function (superClass) {

    /**
     * @constructor
     * @extends {superClass}
     * @implements {Polymer_ElementMixin}
     */
    var elementBase = Polymer.ElementMixin(superClass);

    /**
     * @polymer
     * @mixinClass
     * @implements {Polymer_ArraySelectorMixin}
     * @unrestricted
     */

    var ArraySelectorMixin = function (_elementBase) {
      _inherits(ArraySelectorMixin, _elementBase);

      _createClass(ArraySelectorMixin, null, [{
        key: 'properties',
        get: function get() {

          return {

            /**
             * An array containing items from which selection will be made.
             */
            items: {
              type: Array
            },

            /**
             * When `true`, multiple items may be selected at once (in this case,
             * `selected` is an array of currently selected items).  When `false`,
             * only one item may be selected at a time.
             */
            multi: {
              type: Boolean,
              value: false
            },

            /**
             * When `multi` is true, this is an array that contains any selected.
             * When `multi` is false, this is the currently selected item, or `null`
             * if no item is selected.
             * @type {?(Object|Array<!Object>)}
             */
            selected: {
              type: Object,
              notify: true
            },

            /**
             * When `multi` is false, this is the currently selected item, or `null`
             * if no item is selected.
             * @type {?Object}
             */
            selectedItem: {
              type: Object,
              notify: true
            },

            /**
             * When `true`, calling `select` on an item that is already selected
             * will deselect the item.
             */
            toggle: {
              type: Boolean,
              value: false
            }

          };
        }
      }, {
        key: 'observers',
        get: function get() {
          return ['__updateSelection(multi, items.*)'];
        }
      }]);

      function ArraySelectorMixin() {
        _classCallCheck(this, ArraySelectorMixin);

        var _this = _possibleConstructorReturn(this, (ArraySelectorMixin.__proto__ || Object.getPrototypeOf(ArraySelectorMixin)).call(this));

        _this.__lastItems = null;
        _this.__lastMulti = null;
        _this.__selectedMap = null;
        return _this;
      }

      _createClass(ArraySelectorMixin, [{
        key: '__updateSelection',
        value: function __updateSelection(multi, itemsInfo) {
          var path = itemsInfo.path;
          if (path == 'items') {
            // Case 1 - items array changed, so diff against previous array and
            // deselect any removed items and adjust selected indices
            var newItems = itemsInfo.base || [];
            var lastItems = this.__lastItems;
            var lastMulti = this.__lastMulti;
            if (multi !== lastMulti) {
              this.clearSelection();
            }
            if (lastItems) {
              var splices = Polymer.ArraySplice.calculateSplices(newItems, lastItems);
              this.__applySplices(splices);
            }
            this.__lastItems = newItems;
            this.__lastMulti = multi;
          } else if (itemsInfo.path == 'items.splices') {
            // Case 2 - got specific splice information describing the array mutation:
            // deselect any removed items and adjust selected indices
            this.__applySplices(itemsInfo.value.indexSplices);
          } else {
            // Case 3 - an array element was changed, so deselect the previous
            // item for that index if it was previously selected
            var part = path.slice('items.'.length);
            var idx = parseInt(part, 10);
            if (part.indexOf('.') < 0 && part == idx) {
              this.__deselectChangedIdx(idx);
            }
          }
        }
      }, {
        key: '__applySplices',
        value: function __applySplices(splices) {
          var _this2 = this;

          var selected = this.__selectedMap;
          // Adjust selected indices and mark removals

          var _loop = function _loop(i) {
            var s = splices[i];
            selected.forEach(function (idx, item) {
              if (idx < s.index) {
                // no change
              } else if (idx >= s.index + s.removed.length) {
                // adjust index
                selected.set(item, idx + s.addedCount - s.removed.length);
              } else {
                // remove index
                selected.set(item, -1);
              }
            });
            for (var j = 0; j < s.addedCount; j++) {
              var idx = s.index + j;
              if (selected.has(_this2.items[idx])) {
                selected.set(_this2.items[idx], idx);
              }
            }
          };

          for (var i = 0; i < splices.length; i++) {
            _loop(i);
          }
          // Update linked paths
          this.__updateLinks();
          // Remove selected items that were removed from the items array
          var sidx = 0;
          selected.forEach(function (idx, item) {
            if (idx < 0) {
              if (_this2.multi) {
                _this2.splice('selected', sidx, 1);
              } else {
                _this2.selected = _this2.selectedItem = null;
              }
              selected.delete(item);
            } else {
              sidx++;
            }
          });
        }
      }, {
        key: '__updateLinks',
        value: function __updateLinks() {
          var _this3 = this;

          this.__dataLinkedPaths = {};
          if (this.multi) {
            var sidx = 0;
            this.__selectedMap.forEach(function (idx) {
              if (idx >= 0) {
                _this3.linkPaths('items.' + idx, 'selected.' + sidx++);
              }
            });
          } else {
            this.__selectedMap.forEach(function (idx) {
              _this3.linkPaths('selected', 'items.' + idx);
              _this3.linkPaths('selectedItem', 'items.' + idx);
            });
          }
        }

        /**
         * Clears the selection state.
         *
         */

      }, {
        key: 'clearSelection',
        value: function clearSelection() {
          // Unbind previous selection
          this.__dataLinkedPaths = {};
          // The selected map stores 3 pieces of information:
          // key: items array object
          // value: items array index
          // order: selected array index
          this.__selectedMap = new Map();
          // Initialize selection
          this.selected = this.multi ? [] : null;
          this.selectedItem = null;
        }

        /**
         * Returns whether the item is currently selected.
         *
         * @param {*} item Item from `items` array to test
         * @return {boolean} Whether the item is selected
         */

      }, {
        key: 'isSelected',
        value: function isSelected(item) {
          return this.__selectedMap.has(item);
        }

        /**
         * Returns whether the item is currently selected.
         *
         * @param {number} idx Index from `items` array to test
         * @return {boolean} Whether the item is selected
         */

      }, {
        key: 'isIndexSelected',
        value: function isIndexSelected(idx) {
          return this.isSelected(this.items[idx]);
        }
      }, {
        key: '__deselectChangedIdx',
        value: function __deselectChangedIdx(idx) {
          var _this4 = this;

          var sidx = this.__selectedIndexForItemIndex(idx);
          if (sidx >= 0) {
            var i = 0;
            this.__selectedMap.forEach(function (idx, item) {
              if (sidx == i++) {
                _this4.deselect(item);
              }
            });
          }
        }
      }, {
        key: '__selectedIndexForItemIndex',
        value: function __selectedIndexForItemIndex(idx) {
          var selected = this.__dataLinkedPaths['items.' + idx];
          if (selected) {
            return parseInt(selected.slice('selected.'.length), 10);
          }
        }

        /**
         * Deselects the given item if it is already selected.
         *
         * @param {*} item Item from `items` array to deselect
         */

      }, {
        key: 'deselect',
        value: function deselect(item) {
          var idx = this.__selectedMap.get(item);
          if (idx >= 0) {
            this.__selectedMap.delete(item);
            var sidx = void 0;
            if (this.multi) {
              sidx = this.__selectedIndexForItemIndex(idx);
            }
            this.__updateLinks();
            if (this.multi) {
              this.splice('selected', sidx, 1);
            } else {
              this.selected = this.selectedItem = null;
            }
          }
        }

        /**
         * Deselects the given index if it is already selected.
         *
         * @param {number} idx Index from `items` array to deselect
         */

      }, {
        key: 'deselectIndex',
        value: function deselectIndex(idx) {
          this.deselect(this.items[idx]);
        }

        /**
         * Selects the given item.  When `toggle` is true, this will automatically
         * deselect the item if already selected.
         *
         * @param {*} item Item from `items` array to select
         */

      }, {
        key: 'select',
        value: function select(item) {
          this.selectIndex(this.items.indexOf(item));
        }

        /**
         * Selects the given index.  When `toggle` is true, this will automatically
         * deselect the item if already selected.
         *
         * @param {number} idx Index from `items` array to select
         */

      }, {
        key: 'selectIndex',
        value: function selectIndex(idx) {
          var item = this.items[idx];
          if (!this.isSelected(item)) {
            if (!this.multi) {
              this.__selectedMap.clear();
            }
            this.__selectedMap.set(item, idx);
            this.__updateLinks();
            if (this.multi) {
              this.push('selected', item);
            } else {
              this.selected = this.selectedItem = item;
            }
          } else if (this.toggle) {
            this.deselectIndex(idx);
          }
        }
      }]);

      return ArraySelectorMixin;
    }(elementBase);

    return ArraySelectorMixin;
  });

  // export mixin
  Polymer.ArraySelectorMixin = ArraySelectorMixin;

  /**
   * @constructor
   * @extends {Polymer.Element}
   * @implements {Polymer_ArraySelectorMixin}
   */
  var baseArraySelector = ArraySelectorMixin(Polymer.Element);

  /**
   * Element implementing the `Polymer.ArraySelector` mixin, which records
   * dynamic associations between item paths in a master `items` array and a
   * `selected` array such that path changes to the master array (at the host)
   * element or elsewhere via data-binding) are correctly propagated to items
   * in the selected array and vice-versa.
   *
   * The `items` property accepts an array of user data, and via the
   * `select(item)` and `deselect(item)` API, updates the `selected` property
   * which may be bound to other parts of the application, and any changes to
   * sub-fields of `selected` item(s) will be kept in sync with items in the
   * `items` array.  When `multi` is false, `selected` is a property
   * representing the last selected item.  When `multi` is true, `selected`
   * is an array of multiply selected items.
   *
   * Example:
   *
   * ```html
   * <dom-module id="employee-list">
   *
   *   <template>
   *
   *     <div> Employee list: </div>
   *     <template is="dom-repeat" id="employeeList" items="{{employees}}">
   *         <div>First name: <span>{{item.first}}</span></div>
   *         <div>Last name: <span>{{item.last}}</span></div>
   *         <button on-click="toggleSelection">Select</button>
   *     </template>
   *
   *     <array-selector id="selector" items="{{employees}}" selected="{{selected}}" multi toggle></array-selector>
   *
   *     <div> Selected employees: </div>
   *     <template is="dom-repeat" items="{{selected}}">
   *         <div>First name: <span>{{item.first}}</span></div>
   *         <div>Last name: <span>{{item.last}}</span></div>
   *     </template>
   *
   *   </template>
   *
   * </dom-module>
   * ```
   *
   * ```js
   * Polymer({
   *   is: 'employee-list',
   *   ready() {
   *     this.employees = [
   *         {first: 'Bob', last: 'Smith'},
   *         {first: 'Sally', last: 'Johnson'},
   *         ...
   *     ];
   *   },
   *   toggleSelection(e) {
   *     let item = this.$.employeeList.itemForElement(e.target);
   *     this.$.selector.select(item);
   *   }
   * });
   * ```
   *
   * @polymer
   * @customElement
   * @extends {baseArraySelector}
   * @appliesMixin Polymer.ArraySelectorMixin
   * @memberof Polymer
   * @summary Custom element that links paths between an input `items` array and
   *   an output `selected` item or array based on calls to its selection API.
   */

  var ArraySelector = function (_baseArraySelector) {
    _inherits(ArraySelector, _baseArraySelector);

    function ArraySelector() {
      _classCallCheck(this, ArraySelector);

      return _possibleConstructorReturn(this, (ArraySelector.__proto__ || Object.getPrototypeOf(ArraySelector)).apply(this, arguments));
    }

    _createClass(ArraySelector, null, [{
      key: 'is',

      // Not needed to find template; can be removed once the analyzer
      // can find the tag name from customElements.define call
      get: function get() {
        return 'array-selector';
      }
    }]);

    return ArraySelector;
  }(baseArraySelector);

  customElements.define(ArraySelector.is, ArraySelector);
  Polymer.ArraySelector = ArraySelector;
})();

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

__webpack_require__(61);

__webpack_require__(21);

(function () {
  'use strict';

  var attr = 'include';

  var CustomStyleInterface = window.ShadyCSS.CustomStyleInterface;

  /**
   * Custom element for defining styles in the main document that can take
   * advantage of several special features of Polymer's styling system:
   *
   * - Document styles defined in a custom-style are shimmed to ensure they
   *   do not leak into local DOM when running on browsers without native
   *   Shadow DOM.
   * - Custom properties used by Polymer's shim for cross-scope styling may
   *   be defined in an custom-style. Use the :root selector to define custom
   *   properties that apply to all custom elements.
   *
   * To use, simply wrap an inline `<style>` tag in the main document whose
   * CSS uses these features with a `<custom-style>` element.
   *
   * @customElement
   * @extends HTMLElement
   * @memberof Polymer
   * @summary Custom element for defining styles in the main document that can
   *   take advantage of Polymer's style scoping and custom properties shims.
   */

  var CustomStyle = function (_HTMLElement) {
    _inherits(CustomStyle, _HTMLElement);

    function CustomStyle() {
      _classCallCheck(this, CustomStyle);

      var _this = _possibleConstructorReturn(this, (CustomStyle.__proto__ || Object.getPrototypeOf(CustomStyle)).call(this));

      _this._style = null;
      CustomStyleInterface.addCustomStyle(_this);
      return _this;
    }
    /**
     * Returns the light-DOM `<style>` child this element wraps.  Upon first
     * call any style modules referenced via the `include` attribute will be
     * concatenated to this element's `<style>`.
     *
     * @return {HTMLStyleElement} This element's light-DOM `<style>`
     */


    _createClass(CustomStyle, [{
      key: 'getStyle',
      value: function getStyle() {
        if (this._style) {
          return this._style;
        }
        var style = /** @type {HTMLStyleElement} */this.querySelector('style');
        if (!style) {
          return null;
        }
        this._style = style;
        var include = style.getAttribute(attr);
        if (include) {
          style.removeAttribute(attr);
          style.textContent = Polymer.StyleGather.cssFromModules(include) + style.textContent;
        }
        return this._style;
      }
    }]);

    return CustomStyle;
  }(HTMLElement);

  window.customElements.define('custom-style', CustomStyle);
  Polymer.CustomStyle = CustomStyle;
})();

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(62);

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


(function () {
  /*
  Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
  This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
  The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
  The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
  Code distributed by Google as part of the polymer project is also
  subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
  */
  'use strict';
  var c = !(window.ShadyDOM && window.ShadyDOM.inUse),
      f;function g(a) {
    f = a && a.shimcssproperties ? !1 : c || !(navigator.userAgent.match(/AppleWebKit\/601|Edge\/15/) || !window.CSS || !CSS.supports || !CSS.supports("box-shadow", "0 0 0 var(--foo)"));
  }window.ShadyCSS && void 0 !== window.ShadyCSS.nativeCss ? f = window.ShadyCSS.nativeCss : window.ShadyCSS ? (g(window.ShadyCSS), window.ShadyCSS = void 0) : g(window.WebComponents && window.WebComponents.flags);var h = f;function k(a, b) {
    for (var d in b) {
      null === d ? a.style.removeProperty(d) : a.style.setProperty(d, b[d]);
    }
  };var l = null,
      m = window.HTMLImports && window.HTMLImports.whenReady || null,
      n;function p() {
    var a = q;requestAnimationFrame(function () {
      m ? m(a) : (l || (l = new Promise(function (a) {
        n = a;
      }), "complete" === document.readyState ? n() : document.addEventListener("readystatechange", function () {
        "complete" === document.readyState && n();
      })), l.then(function () {
        a && a();
      }));
    });
  };var r = null,
      q = null;function t() {
    this.customStyles = [];this.enqueued = !1;
  }function u(a) {
    !a.enqueued && q && (a.enqueued = !0, p());
  }t.prototype.c = function (a) {
    a.__seenByShadyCSS || (a.__seenByShadyCSS = !0, this.customStyles.push(a), u(this));
  };t.prototype.b = function (a) {
    if (a.__shadyCSSCachedStyle) return a.__shadyCSSCachedStyle;var b;a.getStyle ? b = a.getStyle() : b = a;return b;
  };
  t.prototype.a = function () {
    for (var a = this.customStyles, b = 0; b < a.length; b++) {
      var d = a[b];if (!d.__shadyCSSCachedStyle) {
        var e = this.b(d);e && (e = e.__appliedElement || e, r && r(e), d.__shadyCSSCachedStyle = e);
      }
    }return a;
  };t.prototype.addCustomStyle = t.prototype.c;t.prototype.getStyleForCustomStyle = t.prototype.b;t.prototype.processStyles = t.prototype.a;
  Object.defineProperties(t.prototype, { transformCallback: { get: function get() {
        return r;
      }, set: function set(a) {
        r = a;
      } }, validateCallback: { get: function get() {
        return q;
      }, set: function set(a) {
        var b = !1;q || (b = !0);q = a;b && u(this);
      } } });var v = new t();window.ShadyCSS || (window.ShadyCSS = { prepareTemplate: function prepareTemplate() {}, styleSubtree: function styleSubtree(a, b) {
      v.a();k(a, b);
    }, styleElement: function styleElement() {
      v.a();
    }, styleDocument: function styleDocument(a) {
      v.a();k(document.body, a);
    }, getComputedStyleValue: function getComputedStyleValue(a, b) {
      return (a = window.getComputedStyle(a).getPropertyValue(b)) ? a.trim() : "";
    }, nativeCss: h, nativeShadow: c });window.ShadyCSS.CustomStyleInterface = v;
}).call(undefined);

//# sourceMappingURL=custom-style-interface.min.js.map

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(9);

(function () {
  'use strict';

  var mutablePropertyChange = void 0;
  (
  /** @suppress {missingProperties} */
  function () {
    mutablePropertyChange = Polymer.MutableData._mutablePropertyChange;
  })();

  /**
   * Legacy element behavior to skip strict dirty-checking for objects and arrays,
   * (always consider them to be "dirty") for use on legacy API Polymer elements.
   *
   * By default, `Polymer.PropertyEffects` performs strict dirty checking on
   * objects, which means that any deep modifications to an object or array will
   * not be propagated unless "immutable" data patterns are used (i.e. all object
   * references from the root to the mutation were changed).
   *
   * Polymer also provides a proprietary data mutation and path notification API
   * (e.g. `notifyPath`, `set`, and array mutation API's) that allow efficient
   * mutation and notification of deep changes in an object graph to all elements
   * bound to the same object graph.
   *
   * In cases where neither immutable patterns nor the data mutation API can be
   * used, applying this mixin will cause Polymer to skip dirty checking for
   * objects and arrays (always consider them to be "dirty").  This allows a
   * user to make a deep modification to a bound object graph, and then either
   * simply re-set the object (e.g. `this.items = this.items`) or call `notifyPath`
   * (e.g. `this.notifyPath('items')`) to update the tree.  Note that all
   * elements that wish to be updated based on deep mutations must apply this
   * mixin or otherwise skip strict dirty checking for objects/arrays.
   *
   * In order to make the dirty check strategy configurable, see
   * `Polymer.OptionalMutableDataBehavior`.
   *
   * Note, the performance characteristics of propagating large object graphs
   * will be worse as opposed to using strict dirty checking with immutable
   * patterns or Polymer's path notification API.
   *
   * @polymerBehavior
   * @memberof Polymer
   * @summary Behavior to skip strict dirty-checking for objects and
   *   arrays
   */
  Polymer.MutableDataBehavior = {

    /**
     * Overrides `Polymer.PropertyEffects` to provide option for skipping
     * strict equality checking for Objects and Arrays.
     *
     * This method pulls the value to dirty check against from the `__dataTemp`
     * cache (rather than the normal `__data` cache) for Objects.  Since the temp
     * cache is cleared at the end of a turn, this implementation allows
     * side-effects of deep object changes to be processed by re-setting the
     * same object (using the temp cache as an in-turn backstop to prevent
     * cycles due to 2-way notification).
     *
     * @param {string} property Property name
     * @param {*} value New property value
     * @param {*} old Previous property value
     * @return {boolean} Whether the property should be considered a change
     * @protected
     */
    _shouldPropertyChange: function _shouldPropertyChange(property, value, old) {
      return mutablePropertyChange(this, property, value, old, true);
    }
  };

  /**
   * Legacy element behavior to add the optional ability to skip strict
   * dirty-checking for objects and arrays (always consider them to be
   * "dirty") by setting a `mutable-data` attribute on an element instance.
   *
   * By default, `Polymer.PropertyEffects` performs strict dirty checking on
   * objects, which means that any deep modifications to an object or array will
   * not be propagated unless "immutable" data patterns are used (i.e. all object
   * references from the root to the mutation were changed).
   *
   * Polymer also provides a proprietary data mutation and path notification API
   * (e.g. `notifyPath`, `set`, and array mutation API's) that allow efficient
   * mutation and notification of deep changes in an object graph to all elements
   * bound to the same object graph.
   *
   * In cases where neither immutable patterns nor the data mutation API can be
   * used, applying this mixin will allow Polymer to skip dirty checking for
   * objects and arrays (always consider them to be "dirty").  This allows a
   * user to make a deep modification to a bound object graph, and then either
   * simply re-set the object (e.g. `this.items = this.items`) or call `notifyPath`
   * (e.g. `this.notifyPath('items')`) to update the tree.  Note that all
   * elements that wish to be updated based on deep mutations must apply this
   * mixin or otherwise skip strict dirty checking for objects/arrays.
   *
   * While this behavior adds the ability to forgo Object/Array dirty checking,
   * the `mutableData` flag defaults to false and must be set on the instance.
   *
   * Note, the performance characteristics of propagating large object graphs
   * will be worse by relying on `mutableData: true` as opposed to using
   * strict dirty checking with immutable patterns or Polymer's path notification
   * API.
   *
   * @polymerBehavior
   * @memberof Polymer
   * @summary Behavior to optionally skip strict dirty-checking for objects and
   *   arrays
   */
  Polymer.OptionalMutableDataBehavior = {

    properties: {
      /**
       * Instance-level flag for configuring the dirty-checking strategy
       * for this element.  When true, Objects and Arrays will skip dirty
       * checking, otherwise strict equality checking will be used.
       */
      mutableData: Boolean
    },

    /**
     * Overrides `Polymer.PropertyEffects` to skip strict equality checking
     * for Objects and Arrays.
     *
     * Pulls the value to dirty check against from the `__dataTemp` cache
     * (rather than the normal `__data` cache) for Objects.  Since the temp
     * cache is cleared at the end of a turn, this implementation allows
     * side-effects of deep object changes to be processed by re-setting the
     * same object (using the temp cache as an in-turn backstop to prevent
     * cycles due to 2-way notification).
     *
     * @param {string} property Property name
     * @param {*} value New property value
     * @param {*} old Previous property value
     * @return {boolean} Whether the property should be considered a change
     * @this {this}
     * @protected
     */
    _shouldPropertyChange: function _shouldPropertyChange(property, value, old) {
      return mutablePropertyChange(this, property, value, old, this.mutableData);
    }
  };
})();

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

__webpack_require__(65);

__webpack_require__(15);

var RegisterHtmlTemplate = __webpack_require__(2);

RegisterHtmlTemplate.register("<dom-module id=app-drawer-layout> <template> <style>:host{display:block;position:relative;z-index:0}:host ::slotted([slot=drawer]){z-index:1}:host([fullbleed]){@apply --layout-fit;}#contentContainer{position:relative;z-index:0;height:100%;transition:var(--app-drawer-layout-content-transition,none)}#contentContainer[drawer-position=left]{margin-left:var(--app-drawer-width,256px)}#contentContainer[drawer-position=right]{margin-right:var(--app-drawer-width,256px)}</style> <slot id=drawerSlot name=drawer></slot> <div id=contentContainer drawer-position$=[[_drawerPosition]]> <slot></slot> </div> <iron-media-query query=\"[[_computeMediaQuery(forceNarrow, responsiveWidth)]]\" on-query-matches-changed=_onQueryMatchesChanged></iron-media-query> </template> </dom-module>");

Polymer({
  is: 'app-drawer-layout',

  behaviors: [Polymer.AppLayoutBehavior],

  properties: {
    /**
     * If true, ignore `responsiveWidth` setting and force the narrow layout.
     */
    forceNarrow: {
      type: Boolean,
      value: false
    },

    /**
     * If the viewport's width is smaller than this value, the panel will change to narrow
     * layout. In the mode the drawer will be closed.
     */
    responsiveWidth: {
      type: String,
      value: '640px'
    },

    /**
     * Returns true if it is in narrow layout. This is useful if you need to show/hide
     * elements based on the layout.
     */
    narrow: {
      type: Boolean,
      reflectToAttribute: true,
      readOnly: true,
      notify: true
    },

    /**
     * If true, the drawer will initially be opened when in narrow layout mode.
     */
    openedWhenNarrow: {
      type: Boolean,
      value: false
    },

    _drawerPosition: {
      type: String
    }
  },

  listeners: {
    'click': '_clickHandler'
  },

  observers: ['_narrowChanged(narrow)'],

  /**
   * A reference to the app-drawer element.
   *
   * @property drawer
   */
  get drawer() {
    return Polymer.dom(this.$.drawerSlot).getDistributedNodes()[0];
  },

  attached: function attached() {
    // Disable drawer transitions until after app-drawer-layout sets the initial opened state.
    var drawer = this.drawer;
    if (drawer) {
      drawer.setAttribute('no-transition', '');
    }
  },

  _clickHandler: function _clickHandler(e) {
    var target = Polymer.dom(e).localTarget;
    if (target && target.hasAttribute('drawer-toggle')) {
      var drawer = this.drawer;
      if (drawer && !drawer.persistent) {
        drawer.toggle();
      }
    }
  },

  _updateLayoutStates: function _updateLayoutStates() {
    var drawer = this.drawer;
    if (!this.isAttached || !drawer) {
      return;
    }

    this._drawerPosition = this.narrow ? null : drawer.position;
    if (this._drawerNeedsReset) {
      if (this.narrow) {
        drawer.opened = this.openedWhenNarrow;
        drawer.persistent = false;
      } else {
        drawer.opened = drawer.persistent = true;
      }
      if (drawer.hasAttribute('no-transition')) {
        // Enable drawer transitions after app-drawer-layout sets the initial opened state.
        Polymer.RenderStatus.afterNextRender(this, function () {
          drawer.removeAttribute('no-transition');
        });
      }
      this._drawerNeedsReset = false;
    }
  },

  _narrowChanged: function _narrowChanged() {
    this._drawerNeedsReset = true;
    this.resetLayout();
  },

  _onQueryMatchesChanged: function _onQueryMatchesChanged(event) {
    this._setNarrow(event.detail.value);
  },

  _computeMediaQuery: function _computeMediaQuery(forceNarrow, responsiveWidth) {
    return forceNarrow ? '(min-width: 0px)' : '(max-width: ' + responsiveWidth + ')';
  }
});

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

Polymer({

  is: 'iron-media-query',

  properties: {

    /**
     * The Boolean return value of the media query.
     */
    queryMatches: {
      type: Boolean,
      value: false,
      readOnly: true,
      notify: true
    },

    /**
     * The CSS media query to evaluate.
     */
    query: {
      type: String,
      observer: 'queryChanged'
    },

    /**
     * If true, the query attribute is assumed to be a complete media query
     * string rather than a single media feature.
     */
    full: {
      type: Boolean,
      value: false
    },

    /**
     * @type {function(MediaQueryList)}
     */
    _boundMQHandler: {
      value: function value() {
        return this.queryHandler.bind(this);
      }
    },

    /**
     * @type {MediaQueryList}
     */
    _mq: {
      value: null
    }
  },

  attached: function attached() {
    this.style.display = 'none';
    this.queryChanged();
  },

  detached: function detached() {
    this._remove();
  },

  _add: function _add() {
    if (this._mq) {
      this._mq.addListener(this._boundMQHandler);
    }
  },

  _remove: function _remove() {
    if (this._mq) {
      this._mq.removeListener(this._boundMQHandler);
    }
    this._mq = null;
  },

  queryChanged: function queryChanged() {
    this._remove();
    var query = this.query;
    if (!query) {
      return;
    }
    if (!this.full && query[0] !== '(') {
      query = '(' + query + ')';
    }
    this._mq = window.matchMedia(query);
    this._add();
    this.queryHandler(this._mq);
  },

  queryHandler: function queryHandler(mq) {
    this._setQueryMatches(mq.matches);
  }

});

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

__webpack_require__(5);

__webpack_require__(4);

__webpack_require__(15);

var RegisterHtmlTemplate = __webpack_require__(2);

RegisterHtmlTemplate.register("<dom-module id=app-header> <template> <style>:host{position:relative;display:block;transition-timing-function:linear;transition-property:-webkit-transform;transition-property:transform}:host::before{position:absolute;right:0;bottom:-5px;left:0;width:100%;height:5px;content:\"\";transition:opacity .4s;pointer-events:none;opacity:0;box-shadow:inset 0 5px 6px -3px rgba(0,0,0,.4);will-change:opacity;@apply --app-header-shadow;}:host([shadow])::before{opacity:1}#background{@apply --layout-fit;overflow:hidden}#backgroundFrontLayer,#backgroundRearLayer{@apply --layout-fit;height:100%;pointer-events:none;background-size:cover}#backgroundFrontLayer{@apply --app-header-background-front-layer;}#backgroundRearLayer{opacity:0;@apply --app-header-background-rear-layer;}#contentContainer{position:relative;width:100%;height:100%}:host([disabled]),:host([disabled]) #backgroundFrontLayer,:host([disabled]) #backgroundRearLayer,:host([disabled])::after,:host([silent-scroll]),:host([silent-scroll]) #backgroundFrontLayer,:host([silent-scroll]) #backgroundRearLayer,:host([silent-scroll])::after{transition:none!important}:host([disabled]) ::slotted([sticky]),:host([disabled]) ::slotted(app-toolbar:first-of-type),:host([silent-scroll]) ::slotted([sticky]),:host([silent-scroll]) ::slotted(app-toolbar:first-of-type){transition:none!important}</style> <div id=contentContainer> <slot id=slot></slot> </div> </template> </dom-module>");

Polymer({
  is: 'app-header',

  behaviors: [Polymer.AppScrollEffectsBehavior, Polymer.AppLayoutBehavior],

  properties: {
    /**
     * If true, the header will automatically collapse when scrolling down.
     * That is, the `sticky` element remains visible when the header is fully condensed
     * whereas the rest of the elements will collapse below `sticky` element.
     *
     * By default, the `sticky` element is the first toolbar in the light DOM:
     *
     *```html
     * <app-header condenses>
     *   <app-toolbar>This toolbar remains on top</app-toolbar>
     *   <app-toolbar></app-toolbar>
     *   <app-toolbar></app-toolbar>
     * </app-header>
     * ```
     *
     * Additionally, you can specify which toolbar or element remains visible in condensed mode
     * by adding the `sticky` attribute to that element. For example: if we want the last
     * toolbar to remain visible, we can add the `sticky` attribute to it.
     *
     *```html
     * <app-header condenses>
     *   <app-toolbar></app-toolbar>
     *   <app-toolbar></app-toolbar>
     *   <app-toolbar sticky>This toolbar remains on top</app-toolbar>
     * </app-header>
     * ```
     *
     * Note the `sticky` element must be a direct child of `app-header`.
     */
    condenses: {
      type: Boolean,
      value: false
    },

    /**
     * Mantains the header fixed at the top so it never moves away.
     */
    fixed: {
      type: Boolean,
      value: false
    },

    /**
     * Slides back the header when scrolling back up.
     */
    reveals: {
      type: Boolean,
      value: false
    },

    /**
     * Displays a shadow below the header.
     */
    shadow: {
      type: Boolean,
      reflectToAttribute: true,
      value: false
    }
  },

  observers: ['_configChanged(isAttached, condenses, fixed)'],

  /**
   * A cached offsetHeight of the current element.
   *
   * @type {number}
   */
  _height: 0,

  /**
   * The distance in pixels the header will be translated to when scrolling.
   *
   * @type {number}
   */
  _dHeight: 0,

  /**
   * The offsetTop of `_stickyEl`
   *
   * @type {number}
   */
  _stickyElTop: 0,

  /**
   * A reference to the element that remains visible when the header condenses.
   *
   * @type {HTMLElement}
   */
  _stickyElRef: null,

  /**
   * The header's top value used for the `transformY`
   *
   * @type {number}
   */
  _top: 0,

  /**
   * The current scroll progress.
   *
   * @type {number}
   */
  _progress: 0,

  _wasScrollingDown: false,
  _initScrollTop: 0,
  _initTimestamp: 0,
  _lastTimestamp: 0,
  _lastScrollTop: 0,

  /**
   * The distance the header is allowed to move away.
   *
   * @type {number}
   */
  get _maxHeaderTop() {
    return this.fixed ? this._dHeight : this._height + 5;
  },

  /**
   * Returns a reference to the sticky element.
   *
   * @return {HTMLElement}?
   */
  get _stickyEl() {
    if (this._stickyElRef) {
      return this._stickyElRef;
    }
    var nodes = Polymer.dom(this.$.slot).getDistributedNodes();
    // Get the element with the sticky attribute on it or the first element in the light DOM.
    for (var i = 0, node; node = nodes[i]; i++) {
      if (node.nodeType === Node.ELEMENT_NODE) {
        if (node.hasAttribute('sticky')) {
          this._stickyElRef = node;
          break;
        } else if (!this._stickyElRef) {
          this._stickyElRef = node;
        }
      }
    }
    return this._stickyElRef;
  },

  _configChanged: function _configChanged() {
    this.resetLayout();
    this._notifyLayoutChanged();
  },

  _updateLayoutStates: function _updateLayoutStates() {
    if (this.offsetWidth === 0 && this.offsetHeight === 0) {
      return;
    }
    var scrollTop = this._clampedScrollTop;
    var firstSetup = this._height === 0 || scrollTop === 0;
    var currentDisabled = this.disabled;
    this._height = this.offsetHeight;
    this._stickyElRef = null;
    this.disabled = true;
    // prepare for measurement
    if (!firstSetup) {
      this._updateScrollState(0, true);
    }
    if (this._mayMove()) {
      this._dHeight = this._stickyEl ? this._height - this._stickyEl.offsetHeight : 0;
    } else {
      this._dHeight = 0;
    }
    this._stickyElTop = this._stickyEl ? this._stickyEl.offsetTop : 0;
    this._setUpEffect();
    if (firstSetup) {
      this._updateScrollState(scrollTop, true);
    } else {
      this._updateScrollState(this._lastScrollTop, true);
      this._layoutIfDirty();
    }
    // restore no transition
    this.disabled = currentDisabled;
  },

  /**
   * Updates the scroll state.
   *
   * @param {number} scrollTop
   * @param {boolean=} forceUpdate (default: false)
   */
  _updateScrollState: function _updateScrollState(scrollTop, forceUpdate) {
    if (this._height === 0) {
      return;
    }
    var progress = 0;
    var top = 0;
    var lastTop = this._top;
    var lastScrollTop = this._lastScrollTop;
    var maxHeaderTop = this._maxHeaderTop;
    var dScrollTop = scrollTop - this._lastScrollTop;
    var absDScrollTop = Math.abs(dScrollTop);
    var isScrollingDown = scrollTop > this._lastScrollTop;
    var now = performance.now();

    if (this._mayMove()) {
      top = this._clamp(this.reveals ? lastTop + dScrollTop : scrollTop, 0, maxHeaderTop);
    }
    if (scrollTop >= this._dHeight) {
      top = this.condenses && !this.fixed ? Math.max(this._dHeight, top) : top;
      this.style.transitionDuration = '0ms';
    }
    if (this.reveals && !this.disabled && absDScrollTop < 100) {
      // set the initial scroll position
      if (now - this._initTimestamp > 300 || this._wasScrollingDown !== isScrollingDown) {
        this._initScrollTop = scrollTop;
        this._initTimestamp = now;
      }
      if (scrollTop >= maxHeaderTop) {
        // check if the header is allowed to snap
        if (Math.abs(this._initScrollTop - scrollTop) > 30 || absDScrollTop > 10) {
          if (isScrollingDown && scrollTop >= maxHeaderTop) {
            top = maxHeaderTop;
          } else if (!isScrollingDown && scrollTop >= this._dHeight) {
            top = this.condenses && !this.fixed ? this._dHeight : 0;
          }
          var scrollVelocity = dScrollTop / (now - this._lastTimestamp);
          this.style.transitionDuration = this._clamp((top - lastTop) / scrollVelocity, 0, 300) + 'ms';
        } else {
          top = this._top;
        }
      }
    }
    if (this._dHeight === 0) {
      progress = scrollTop > 0 ? 1 : 0;
    } else {
      progress = top / this._dHeight;
    }
    if (!forceUpdate) {
      this._lastScrollTop = scrollTop;
      this._top = top;
      this._wasScrollingDown = isScrollingDown;
      this._lastTimestamp = now;
    }
    if (forceUpdate || progress !== this._progress || lastTop !== top || scrollTop === 0) {
      this._progress = progress;
      this._runEffects(progress, top);
      this._transformHeader(top);
    }
  },

  /**
   * Returns true if the current header is allowed to move as the user scrolls.
   *
   * @return {boolean}
   */
  _mayMove: function _mayMove() {
    return this.condenses || !this.fixed;
  },

  /**
   * Returns true if the current header will condense based on the size of the header
   * and the `consenses` property.
   *
   * @return {boolean}
   */
  willCondense: function willCondense() {
    return this._dHeight > 0 && this.condenses;
  },

  /**
   * Returns true if the current element is on the screen.
   * That is, visible in the current viewport.
   *
   * @method isOnScreen
   * @return {boolean}
   */
  isOnScreen: function isOnScreen() {
    return this._height !== 0 && this._top < this._height;
  },

  /**
   * Returns true if there's content below the current element.
   *
   * @method isContentBelow
   * @return {boolean}
   */
  isContentBelow: function isContentBelow() {
    return this._top === 0 ? this._clampedScrollTop > 0 : this._clampedScrollTop - this._maxHeaderTop >= 0;
  },

  /**
   * Transforms the header.
   *
   * @param {number} y
   */
  _transformHeader: function _transformHeader(y) {
    this.translate3d(0, -y + 'px', 0);
    if (this._stickyEl) {
      this.translate3d(0, this.condenses && y >= this._stickyElTop ? Math.min(y, this._dHeight) - this._stickyElTop + 'px' : 0, 0, this._stickyEl);
    }
  },

  _clamp: function _clamp(v, min, max) {
    return Math.min(max, Math.max(min, v));
  },

  _ensureBgContainers: function _ensureBgContainers() {
    if (!this._bgContainer) {
      this._bgContainer = document.createElement('div');
      this._bgContainer.id = 'background';
      this._bgRear = document.createElement('div');
      this._bgRear.id = 'backgroundRearLayer';
      this._bgContainer.appendChild(this._bgRear);
      this._bgFront = document.createElement('div');
      this._bgFront.id = 'backgroundFrontLayer';
      this._bgContainer.appendChild(this._bgFront);
      Polymer.dom(this.root).insertBefore(this._bgContainer, this.$.contentContainer);
    }
  },

  _getDOMRef: function _getDOMRef(id) {
    switch (id) {
      case 'backgroundFrontLayer':
        this._ensureBgContainers();
        return this._bgFront;
      case 'backgroundRearLayer':
        this._ensureBgContainers();
        return this._bgRear;
      case 'background':
        this._ensureBgContainers();
        return this._bgContainer;
      case 'mainTitle':
        return Polymer.dom(this).querySelector('[main-title]');
      case 'condensedTitle':
        return Polymer.dom(this).querySelector('[condensed-title]');
    }
    return null;
  },

  /**
   * Returns an object containing the progress value of the scroll effects
   * and the top position of the header.
   *
   * @method getScrollState
   * @return {Object}
   */
  getScrollState: function getScrollState() {
    return { progress: this._progress, top: this._top };
  }
});

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

Polymer.AppLayout = Polymer.AppLayout || {};

Polymer.AppLayout._scrollEffects = Polymer.AppLayout._scrollEffects || {};

Polymer.AppLayout.scrollTimingFunction = function easeOutQuad(t, b, c, d) {
  t /= d;
  return -c * t * (t - 2) + b;
};

/**
 * Registers a scroll effect to be used in elements that implement the
 * `Polymer.AppScrollEffectsBehavior` behavior.
 *
 * @param {string} effectName The effect name.
 * @param {Object} effectDef The effect definition.
 */
Polymer.AppLayout.registerEffect = function registerEffect(effectName, effectDef) {
  if (Polymer.AppLayout._scrollEffects[effectName] != null) {
    throw new Error('effect `' + effectName + '` is already registered.');
  }
  Polymer.AppLayout._scrollEffects[effectName] = effectDef;
};

Polymer.AppLayout.queryAllRoot = function (selector, root) {
  var queue = [root];
  var matches = [];

  while (queue.length > 0) {
    var node = queue.shift();
    matches.push.apply(matches, node.querySelectorAll(selector));
    for (i = 0; node.children[i]; i++) {
      if (node.children[i].shadowRoot) {
        queue.push(node.children[i].shadowRoot);
      }
    }
  }
  return matches;
};

/**
 * Scrolls to a particular set of coordinates in a scroll target.
 * If the scroll target is not defined, then it would use the main document as the target.
 *
 * To scroll in a smooth fashion, you can set the option `behavior: 'smooth'`. e.g.
 *
 * ```js
 * Polymer.AppLayout.scroll({top: 0, behavior: 'smooth'});
 * ```
 *
 * To scroll in a silent mode, without notifying scroll changes to any app-layout elements,
 * you can set the option `behavior: 'silent'`. This is particularly useful we you are using
 * `app-header` and you desire to scroll to the top of a scrolling region without running
 * scroll effects. e.g.
 *
 * ```js
 * Polymer.AppLayout.scroll({top: 0, behavior: 'silent'});
 * ```
 *
 * @param {Object} options {top: Number, left: Number, behavior: String(smooth | silent)}
 */
Polymer.AppLayout.scroll = function scroll(options) {
  options = options || {};

  var docEl = document.documentElement;
  var target = options.target || docEl;
  var hasNativeScrollBehavior = 'scrollBehavior' in target.style && target.scroll;
  var scrollClassName = 'app-layout-silent-scroll';
  var scrollTop = options.top || 0;
  var scrollLeft = options.left || 0;
  var scrollTo = target === docEl ? window.scrollTo : function scrollTo(scrollLeft, scrollTop) {
    target.scrollLeft = scrollLeft;
    target.scrollTop = scrollTop;
  };

  if (options.behavior === 'smooth') {

    if (hasNativeScrollBehavior) {

      target.scroll(options);
    } else {

      var timingFn = Polymer.AppLayout.scrollTimingFunction;
      var startTime = Date.now();
      var currentScrollTop = target === docEl ? window.pageYOffset : target.scrollTop;
      var currentScrollLeft = target === docEl ? window.pageXOffset : target.scrollLeft;
      var deltaScrollTop = scrollTop - currentScrollTop;
      var deltaScrollLeft = scrollLeft - currentScrollLeft;
      var duration = 300;
      var updateFrame = function updateFrame() {
        var now = Date.now();
        var elapsedTime = now - startTime;

        if (elapsedTime < duration) {
          scrollTo(timingFn(elapsedTime, currentScrollLeft, deltaScrollLeft, duration), timingFn(elapsedTime, currentScrollTop, deltaScrollTop, duration));
          requestAnimationFrame(updateFrame);
        } else {
          scrollTo(scrollLeft, scrollTop);
        }
      }.bind(this);

      updateFrame();
    }
  } else if (options.behavior === 'silent') {
    var headers = Polymer.AppLayout.queryAllRoot('app-header', document.body);

    headers.forEach(function (header) {
      header.setAttribute('silent-scroll', '');
    });

    // Browsers keep the scroll momentum even if the bottom of the scrolling content
    // was reached. This means that calling scroll({top: 0, behavior: 'silent'}) when
    // the momentum is still going will result in more scroll events and thus scroll effects.
    // This seems to only apply when using document scrolling.
    // Therefore, when should we remove the class from the document element?

    window.cancelAnimationFrame(Polymer.AppLayout._scrollTimer);

    Polymer.AppLayout._scrollTimer = window.requestAnimationFrame(function () {
      headers.forEach(function (header) {
        header.removeAttribute('silent-scroll');
      });
      Polymer.AppLayout._scrollTimer = null;
    });

    scrollTo(scrollLeft, scrollTop);
  } else {

    scrollTo(scrollLeft, scrollTop);
  }
};

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

__webpack_require__(5);

__webpack_require__(15);

var RegisterHtmlTemplate = __webpack_require__(2);

RegisterHtmlTemplate.register("<dom-module id=app-header-layout> <template> <style>:host{display:block;position:relative;z-index:0}#wrapper ::slotted([slot=header]){@apply --layout-fixed-top;z-index:1}#wrapper.initializing ::slotted([slot=header]){position:relative}:host([has-scrolling-region]){height:100%}:host([has-scrolling-region]) #wrapper ::slotted([slot=header]){position:absolute}:host([has-scrolling-region]) #wrapper.initializing ::slotted([slot=header]){position:relative}:host([has-scrolling-region]) #wrapper #contentContainer{@apply --layout-fit;overflow-y:auto;-webkit-overflow-scrolling:touch}:host([has-scrolling-region]) #wrapper.initializing #contentContainer{position:relative}:host([fullbleed]){@apply --layout-vertical;@apply --layout-fit;}:host([fullbleed]) #wrapper,:host([fullbleed]) #wrapper #contentContainer{@apply --layout-vertical;@apply --layout-flex;}#contentContainer{position:relative;z-index:0}</style> <div id=wrapper class=initializing> <slot id=headerSlot name=header></slot> <div id=contentContainer> <slot></slot> </div> </div> </template> </dom-module>");

Polymer({
  is: 'app-header-layout',

  behaviors: [Polymer.AppLayoutBehavior],

  properties: {
    /**
     * If true, the current element will have its own scrolling region.
     * Otherwise, it will use the document scroll to control the header.
     */
    hasScrollingRegion: {
      type: Boolean,
      value: false,
      reflectToAttribute: true
    }
  },

  observers: ['resetLayout(isAttached, hasScrollingRegion)'],

  /**
   * A reference to the app-header element.
   *
   * @property header
   */
  get header() {
    return Polymer.dom(this.$.headerSlot).getDistributedNodes()[0];
  },

  _updateLayoutStates: function _updateLayoutStates() {
    var header = this.header;
    if (!this.isAttached || !header) {
      return;
    }
    // Remove the initializing class, which staticly positions the header and the content
    // until the height of the header can be read.
    this.$.wrapper.classList.remove('initializing');
    // Update scroll target.
    header.scrollTarget = this.hasScrollingRegion ? this.$.contentContainer : this.ownerDocument.documentElement;
    // Get header height here so that style reads are batched together before style writes
    // (i.e. getBoundingClientRect() below).
    var headerHeight = header.offsetHeight;
    // Update the header position.
    if (!this.hasScrollingRegion) {
      requestAnimationFrame(function () {
        var rect = this.getBoundingClientRect();
        var rightOffset = document.documentElement.clientWidth - rect.right;
        header.style.left = rect.left + 'px';
        header.style.right = rightOffset + 'px';
      }.bind(this));
    } else {
      header.style.left = '';
      header.style.right = '';
    }
    // Update the content container position.
    var containerStyle = this.$.contentContainer.style;
    if (header.fixed && !header.condenses && this.hasScrollingRegion) {
      // If the header size does not change and we're using a scrolling region, exclude
      // the header area from the scrolling region so that the header doesn't overlap
      // the scrollbar.
      containerStyle.marginTop = headerHeight + 'px';
      containerStyle.paddingTop = '';
    } else {
      containerStyle.paddingTop = headerHeight + 'px';
      containerStyle.marginTop = '';
    }
  }

});

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(25);

__webpack_require__(70);

__webpack_require__(71);

__webpack_require__(28);

__webpack_require__(72);

__webpack_require__(27);

__webpack_require__(26);

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(4);

/**
 * Upon scrolling past a threshold, fade in the rear background layer and fade out the front
 * background layer (opacity CSS transitioned over time).
 *
 *
 */
Polymer.AppLayout.registerEffect('fade-background', {
  /** @this Polymer.AppLayout.ElementWithBackground */
  setUp: function setUp(config) {
    var fx = {};
    var duration = config.duration || '0.5s';
    fx.backgroundFrontLayer = this._getDOMRef('backgroundFrontLayer');
    fx.backgroundRearLayer = this._getDOMRef('backgroundRearLayer');
    fx.backgroundFrontLayer.style.willChange = 'opacity';
    fx.backgroundFrontLayer.style.webkitTransform = 'translateZ(0)';
    fx.backgroundFrontLayer.style.transitionProperty = 'opacity';
    fx.backgroundFrontLayer.style.transitionDuration = duration;
    fx.backgroundRearLayer.style.willChange = 'opacity';
    fx.backgroundRearLayer.style.webkitTransform = 'translateZ(0)';
    fx.backgroundRearLayer.style.transitionProperty = 'opacity';
    fx.backgroundRearLayer.style.transitionDuration = duration;
    this._fxFadeBackground = fx;
  },
  /** @this Polymer.AppLayout.ElementWithBackground */
  run: function run(p, y) {
    var fx = this._fxFadeBackground;
    if (p >= 1) {
      fx.backgroundFrontLayer.style.opacity = 0;
      fx.backgroundRearLayer.style.opacity = 1;
    } else {
      fx.backgroundFrontLayer.style.opacity = 1;
      fx.backgroundRearLayer.style.opacity = 0;
    }
  },
  /** @this Polymer.AppLayout.ElementWithBackground */
  tearDown: function tearDown() {
    delete this._fxFadeBackground;
  }
});

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(4);

__webpack_require__(26);

__webpack_require__(27);

__webpack_require__(25);

__webpack_require__(28);

/**
 * Shorthand for the waterfall, resize-title, blend-background, and parallax-background effects.
 */
Polymer.AppLayout.registerEffect('material', {
  /**
   * @this Polymer.AppLayout.ElementWithBackground
   */
  setUp: function setUp() {
    this.effects = 'waterfall resize-title blend-background parallax-background';
    return false;
  }
});

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(4);

/**
 * Upon scrolling past a threshold, CSS transition the font size of a designated title element
 * between two values.
 */
Polymer.AppLayout.registerEffect('resize-snapped-title', {
  /**
   * @this Polymer.AppLayout.ElementWithBackground
   */
  setUp: function setUp(config) {
    var title = this._getDOMRef('mainTitle');
    var condensedTitle = this._getDOMRef('condensedTitle');
    var duration = config.duration || '0.2s';
    var fx = {};

    if (!condensedTitle) {
      console.warn('Scroll effect `resize-snapped-title`: undefined `condensed-title`');
      return false;
    }
    if (!title) {
      console.warn('Scroll effect `resize-snapped-title`: undefined `main-title`');
      return false;
    }

    title.style.transitionProperty = 'opacity';
    title.style.transitionDuration = duration;
    condensedTitle.style.transitionProperty = 'opacity';
    condensedTitle.style.transitionDuration = duration;
    fx.condensedTitle = condensedTitle;
    fx.title = title;
    this._fxResizeSnappedTitle = fx;
  },
  /** @this Polymer.AppLayout.ElementWithBackground */
  run: function run(p, y) {
    var fx = this._fxResizeSnappedTitle;
    if (p > 0) {
      fx.title.style.opacity = 0;
      fx.condensedTitle.style.opacity = 1;
    } else {
      fx.title.style.opacity = 1;
      fx.condensedTitle.style.opacity = 0;
    }
  },
  /** @this Polymer.AppLayout.ElementWithBackground */
  tearDown: function tearDown() {
    var fx = this._fxResizeSnappedTitle;
    fx.title.style.transition = '';
    fx.condensedTitle.style.transition = '';
    delete this._fxResizeSnappedTitle;
  }
});

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

__webpack_require__(5);

var RegisterHtmlTemplate = __webpack_require__(2);

RegisterHtmlTemplate.register("<dom-module id=app-toolbar> <template> <style>:host{@apply --layout-horizontal;@apply --layout-center;position:relative;height:64px;padding:0 16px;pointer-events:none;font-size:var(--app-toolbar-font-size,20px)}:host ::slotted(*){pointer-events:auto}:host ::slotted(paper-icon-button){font-size:0}:host ::slotted([condensed-title]),:host ::slotted([main-title]){pointer-events:none;@apply --layout-flex;}:host ::slotted([bottom-item]){position:absolute;right:0;bottom:0;left:0}:host ::slotted([top-item]){position:absolute;top:0;right:0;left:0}:host ::slotted([spacer]){margin-left:64px}</style> <slot></slot> </template> </dom-module>");

Polymer({
  is: 'app-toolbar'
});

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

__webpack_require__(75);

__webpack_require__(76);

__webpack_require__(77);

var RegisterHtmlTemplate = __webpack_require__(2);

RegisterHtmlTemplate.register("<dom-module id=app-location> <template> <iron-query-params params-string={{__query}} params-object={{queryParams}}> </iron-query-params> <iron-location path={{__path}} query={{__query}} hash={{__hash}} url-space-regex={{urlSpaceRegex}}> </iron-location> </template> </dom-module>");

(function () {
  'use strict';

  Polymer({
    is: 'app-location',

    properties: {
      /**
       * A model representing the deserialized path through the route tree, as
       * well as the current queryParams.
       */
      route: {
        type: Object,
        notify: true
      },

      /**
       * In many scenarios, it is convenient to treat the `hash` as a stand-in
       * alternative to the `path`. For example, if deploying an app to a static
       * web server (e.g., Github Pages) - where one does not have control over
       * server-side routing - it is usually a better experience to use the hash
       * to represent paths through one's app.
       *
       * When this property is set to true, the `hash` will be used in place of
        * the `path` for generating a `route`.
       */
      useHashAsPath: {
        type: Boolean,
        value: false
      },

      /**
       * A regexp that defines the set of URLs that should be considered part
       * of this web app.
       *
       * Clicking on a link that matches this regex won't result in a full page
       * navigation, but will instead just update the URL state in place.
       *
       * This regexp is given everything after the origin in an absolute
       * URL. So to match just URLs that start with /search/ do:
       *     url-space-regex="^/search/"
       *
       * @type {string|RegExp}
       */
      urlSpaceRegex: {
        type: String,
        notify: true
      },

      /**
       * A set of key/value pairs that are universally accessible to branches
       * of the route tree.
       */
      __queryParams: {
        type: Object
      },

      /**
       * The pathname component of the current URL.
       */
      __path: {
        type: String
      },

      /**
       * The query string portion of the current URL.
       */
      __query: {
        type: String
      },

      /**
       * The hash portion of the current URL.
       */
      __hash: {
        type: String
      },

      /**
       * The route path, which will be either the hash or the path, depending
       * on useHashAsPath.
       */
      path: {
        type: String,
        observer: '__onPathChanged'
      },

      /**
       * Whether or not the ready function has been called.
       */
      _isReady: {
        type: Boolean
      }
    },

    behaviors: [Polymer.AppRouteConverterBehavior],

    observers: ['__computeRoutePath(useHashAsPath, __hash, __path)'],

    ready: function ready() {
      this._isReady = true;
    },

    __computeRoutePath: function __computeRoutePath() {
      this.path = this.useHashAsPath ? this.__hash : this.__path;
    },

    __onPathChanged: function __onPathChanged() {
      if (!this._isReady) {
        return;
      }

      if (this.useHashAsPath) {
        this.__hash = this.path;
      } else {
        this.__path = this.path;
      }
    }
  });
})();

/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

(function () {
  'use strict';

  var workingURL;

  var urlDoc, urlBase, anchor;

  /**
   * @param {string} path
   * @param {string=} base
   * @return {!URL|!HTMLAnchorElement}
   */
  function resolveURL(path, base) {
    if (workingURL === undefined) {
      workingURL = false;
      try {
        var u = new URL('b', 'http://a');
        u.pathname = 'c%20d';
        workingURL = u.href === 'http://a/c%20d';
        workingURL = workingURL && new URL('http://www.google.com/?foo bar').href === 'http://www.google.com/?foo%20bar';
      } catch (e) {}
    }
    if (workingURL) {
      return new URL(path, base);
    }
    if (!urlDoc) {
      urlDoc = document.implementation.createHTMLDocument('url');
      urlBase = urlDoc.createElement('base');
      urlDoc.head.appendChild(urlBase);
      anchor = /** @type {HTMLAnchorElement}*/urlDoc.createElement('a');
    }
    urlBase.href = base;
    anchor.href = path.replace(/ /g, '%20');
    return anchor;
  }

  Polymer({
    is: 'iron-location',

    properties: {
      /**
       * The pathname component of the URL.
       */
      path: {
        type: String,
        notify: true,
        value: function value() {
          return window.decodeURIComponent(window.location.pathname);
        }
      },

      /**
       * The query string portion of the URL.
       */
      query: {
        type: String,
        notify: true,
        value: function value() {
          return window.location.search.slice(1);
        }
      },

      /**
       * The hash component of the URL.
       */
      hash: {
        type: String,
        notify: true,
        value: function value() {
          return window.decodeURIComponent(window.location.hash.slice(1));
        }
      },

      /**
       * If the user was on a URL for less than `dwellTime` milliseconds, it
       * won't be added to the browser's history, but instead will be replaced
       * by the next entry.
       *
       * This is to prevent large numbers of entries from clogging up the user's
       * browser history. Disable by setting to a negative number.
       */
      dwellTime: {
        type: Number,
        value: 2000
      },

      /**
       * A regexp that defines the set of URLs that should be considered part
       * of this web app.
       *
       * Clicking on a link that matches this regex won't result in a full page
       * navigation, but will instead just update the URL state in place.
       *
       * This regexp is given everything after the origin in an absolute
       * URL. So to match just URLs that start with /search/ do:
       *     url-space-regex="^/search/"
       *
       * @type {string|RegExp}
       */
      urlSpaceRegex: {
        type: String,
        value: ''
      },

      /**
       * urlSpaceRegex, but coerced into a regexp.
       *
       * @type {RegExp}
       */
      _urlSpaceRegExp: {
        computed: '_makeRegExp(urlSpaceRegex)'
      },

      _lastChangedAt: {
        type: Number
      },

      _initialized: {
        type: Boolean,
        value: false
      }
    },

    hostAttributes: {
      hidden: true
    },

    observers: ['_updateUrl(path, query, hash)'],

    attached: function attached() {
      this.listen(window, 'hashchange', '_hashChanged');
      this.listen(window, 'location-changed', '_urlChanged');
      this.listen(window, 'popstate', '_urlChanged');
      this.listen( /** @type {!HTMLBodyElement} */document.body, 'click', '_globalOnClick');
      // Give a 200ms grace period to make initial redirects without any
      // additions to the user's history.
      this._lastChangedAt = window.performance.now() - (this.dwellTime - 200);
      this._initialized = true;

      this._urlChanged();
    },

    detached: function detached() {
      this.unlisten(window, 'hashchange', '_hashChanged');
      this.unlisten(window, 'location-changed', '_urlChanged');
      this.unlisten(window, 'popstate', '_urlChanged');
      this.unlisten( /** @type {!HTMLBodyElement} */document.body, 'click', '_globalOnClick');
      this._initialized = false;
    },

    _hashChanged: function _hashChanged() {
      this.hash = window.decodeURIComponent(window.location.hash.substring(1));
    },

    _urlChanged: function _urlChanged() {
      // We want to extract all info out of the updated URL before we
      // try to write anything back into it.
      //
      // i.e. without _dontUpdateUrl we'd overwrite the new path with the old
      // one when we set this.hash. Likewise for query.
      this._dontUpdateUrl = true;
      this._hashChanged();
      this.path = window.decodeURIComponent(window.location.pathname);
      this.query = window.location.search.substring(1);
      this._dontUpdateUrl = false;
      this._updateUrl();
    },

    _getUrl: function _getUrl() {
      var partiallyEncodedPath = window.encodeURI(this.path).replace(/\#/g, '%23').replace(/\?/g, '%3F');
      var partiallyEncodedQuery = '';
      if (this.query) {
        partiallyEncodedQuery = '?' + this.query.replace(/\#/g, '%23');
      }
      var partiallyEncodedHash = '';
      if (this.hash) {
        partiallyEncodedHash = '#' + window.encodeURI(this.hash);
      }
      return partiallyEncodedPath + partiallyEncodedQuery + partiallyEncodedHash;
    },

    _updateUrl: function _updateUrl() {
      if (this._dontUpdateUrl || !this._initialized) {
        return;
      }

      if (this.path === window.decodeURIComponent(window.location.pathname) && this.query === window.location.search.substring(1) && this.hash === window.decodeURIComponent(window.location.hash.substring(1))) {
        // Nothing to do, the current URL is a representation of our properties.
        return;
      }

      var newUrl = this._getUrl();
      // Need to use a full URL in case the containing page has a base URI.
      var fullNewUrl = resolveURL(newUrl, window.location.protocol + '//' + window.location.host).href;
      var now = window.performance.now();
      var shouldReplace = this._lastChangedAt + this.dwellTime > now;
      this._lastChangedAt = now;

      if (shouldReplace) {
        window.history.replaceState({}, '', fullNewUrl);
      } else {
        window.history.pushState({}, '', fullNewUrl);
      }

      this.fire('location-changed', {}, { node: window });
    },

    /**
     * A necessary evil so that links work as expected. Does its best to
     * bail out early if possible.
     *
     * @param {MouseEvent} event .
     */
    _globalOnClick: function _globalOnClick(event) {
      // If another event handler has stopped this event then there's nothing
      // for us to do. This can happen e.g. when there are multiple
      // iron-location elements in a page.
      if (event.defaultPrevented) {
        return;
      }

      var href = this._getSameOriginLinkHref(event);

      if (!href) {
        return;
      }

      event.preventDefault();

      // If the navigation is to the current page we shouldn't add a history
      // entry or fire a change event.
      if (href === window.location.href) {
        return;
      }

      window.history.pushState({}, '', href);
      this.fire('location-changed', {}, { node: window });
    },

    /**
     * Returns the absolute URL of the link (if any) that this click event
     * is clicking on, if we can and should override the resulting full
     * page navigation. Returns null otherwise.
     *
     * @param {MouseEvent} event .
     * @return {string?} .
     */
    _getSameOriginLinkHref: function _getSameOriginLinkHref(event) {
      // We only care about left-clicks.
      if (event.button !== 0) {
        return null;
      }

      // We don't want modified clicks, where the intent is to open the page
      // in a new tab.
      if (event.metaKey || event.ctrlKey) {
        return null;
      }

      var eventPath = Polymer.dom(event).path;
      var anchor = null;

      for (var i = 0; i < eventPath.length; i++) {
        var element = eventPath[i];

        if (element.tagName === 'A' && element.href) {
          anchor = element;
          break;
        }
      }

      // If there's no link there's nothing to do.
      if (!anchor) {
        return null;
      }

      // Target blank is a new tab, don't intercept.
      if (anchor.target === '_blank') {
        return null;
      }

      // If the link is for an existing parent frame, don't intercept.
      if ((anchor.target === '_top' || anchor.target === '_parent') && window.top !== window) {
        return null;
      }

      var href = anchor.href;

      // It only makes sense for us to intercept same-origin navigations.
      // pushState/replaceState don't work with cross-origin links.
      var url;

      if (document.baseURI != null) {
        url = resolveURL(href, /** @type {string} */document.baseURI);
      } else {
        url = resolveURL(href);
      }

      var origin;

      // IE Polyfill
      if (window.location.origin) {
        origin = window.location.origin;
      } else {
        origin = window.location.protocol + '//' + window.location.host;
      }

      var urlOrigin;

      if (url.origin) {
        urlOrigin = url.origin;
      } else {
        urlOrigin = url.protocol + '//' + url.host;
      }

      if (urlOrigin !== origin) {
        return null;
      }

      var normalizedHref = url.pathname + url.search + url.hash;

      // pathname should start with '/', but may not if `new URL` is not supported
      if (normalizedHref[0] !== '/') {
        normalizedHref = '/' + normalizedHref;
      }

      // If we've been configured not to handle this url... don't handle it!
      if (this._urlSpaceRegExp && !this._urlSpaceRegExp.test(normalizedHref)) {
        return null;
      }

      // Need to use a full URL in case the containing page has a base URI.
      var fullNormalizedHref = resolveURL(normalizedHref, window.location.href).href;
      return fullNormalizedHref;
    },

    _makeRegExp: function _makeRegExp(urlSpaceRegex) {
      return RegExp(urlSpaceRegex);
    }
  });
})();

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

'use strict';

Polymer({
  is: 'iron-query-params',

  properties: {
    paramsString: {
      type: String,
      notify: true,
      observer: 'paramsStringChanged'
    },

    paramsObject: {
      type: Object,
      notify: true,
      value: function value() {
        return {};
      }
    },

    _dontReact: {
      type: Boolean,
      value: false
    }
  },

  hostAttributes: {
    hidden: true
  },

  observers: ['paramsObjectChanged(paramsObject.*)'],

  paramsStringChanged: function paramsStringChanged() {
    this._dontReact = true;
    this.paramsObject = this._decodeParams(this.paramsString);
    this._dontReact = false;
  },

  paramsObjectChanged: function paramsObjectChanged() {
    if (this._dontReact) {
      return;
    }
    this.paramsString = this._encodeParams(this.paramsObject).replace(/%3F/g, '?').replace(/%2F/g, '/').replace(/'/g, '%27');
  },

  _encodeParams: function _encodeParams(params) {
    var encodedParams = [];

    for (var key in params) {
      var value = params[key];

      if (value === '') {
        encodedParams.push(encodeURIComponent(key));
      } else if (value) {
        encodedParams.push(encodeURIComponent(key) + '=' + encodeURIComponent(value.toString()));
      }
    }
    return encodedParams.join('&');
  },

  _decodeParams: function _decodeParams(paramString) {
    var params = {};
    // Work around a bug in decodeURIComponent where + is not
    // converted to spaces:
    paramString = (paramString || '').replace(/\+/g, '%20');
    var paramList = paramString.split('&');
    for (var i = 0; i < paramList.length; i++) {
      var param = paramList[i].split('=');
      if (param[0]) {
        params[decodeURIComponent(param[0])] = decodeURIComponent(param[1] || '');
      }
    }
    return params;
  }
});

/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


(function () {
  'use strict';

  /**
   * Provides bidirectional mapping between `path` and `queryParams` and a
   * app-route compatible `route` object.
   *
   * For more information, see the docs for `app-route-converter`.
   *
   * @polymerBehavior
   */

  Polymer.AppRouteConverterBehavior = {
    properties: {
      /**
       * A model representing the deserialized path through the route tree, as
       * well as the current queryParams.
       *
       * A route object is the kernel of the routing system. It is intended to
       * be fed into consuming elements such as `app-route`.
       *
       * @type {?Object}
       */
      route: {
        type: Object,
        notify: true
      },

      /**
       * A set of key/value pairs that are universally accessible to branches of
       * the route tree.
       *
       * @type {?Object}
       */
      queryParams: {
        type: Object,
        notify: true
      },

      /**
       * The serialized path through the route tree. This corresponds to the
       * `window.location.pathname` value, and will update to reflect changes
       * to that value.
       */
      path: {
        type: String,
        notify: true
      }
    },

    observers: ['_locationChanged(path, queryParams)', '_routeChanged(route.prefix, route.path)', '_routeQueryParamsChanged(route.__queryParams)'],

    created: function created() {
      this.linkPaths('route.__queryParams', 'queryParams');
      this.linkPaths('queryParams', 'route.__queryParams');
    },

    /**
     * Handler called when the path or queryParams change.
     */
    _locationChanged: function _locationChanged() {
      if (this.route && this.route.path === this.path && this.queryParams === this.route.__queryParams) {
        return;
      }
      this.route = {
        prefix: '',
        path: this.path,
        __queryParams: this.queryParams
      };
    },

    /**
     * Handler called when the route prefix and route path change.
     */
    _routeChanged: function _routeChanged() {
      if (!this.route) {
        return;
      }

      this.path = this.route.prefix + this.route.path;
    },

    /**
     * Handler called when the route queryParams change.
     *
     * @param  {Object} queryParams A set of key/value pairs that are
     * universally accessible to branches of the route tree.
     */
    _routeQueryParamsChanged: function _routeQueryParamsChanged(queryParams) {
      if (!this.route) {
        return;
      }
      this.queryParams = queryParams;
    }
  };
})();

/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

(function () {
  'use strict';

  Polymer({
    is: 'app-route',

    properties: {
      /**
       * The URL component managed by this element.
       */
      route: {
        type: Object,
        notify: true
      },

      /**
       * The pattern of slash-separated segments to match `route.path` against.
       *
       * For example the pattern "/foo" will match "/foo" or "/foo/bar"
       * but not "/foobar".
       *
       * Path segments like `/:named` are mapped to properties on the `data` object.
       */
      pattern: {
        type: String
      },

      /**
       * The parameterized values that are extracted from the route as
       * described by `pattern`.
       */
      data: {
        type: Object,
        value: function value() {
          return {};
        },
        notify: true
      },

      /**
       * @type {?Object}
       */
      queryParams: {
        type: Object,
        value: function value() {
          return {};
        },
        notify: true
      },

      /**
       * The part of `route.path` NOT consumed by `pattern`.
       */
      tail: {
        type: Object,
        value: function value() {
          return { path: null, prefix: null, __queryParams: null };
        },
        notify: true
      },

      /**
       * Whether the current route is active. True if `route.path` matches the
       * `pattern`, false otherwise.
       */
      active: {
        type: Boolean,
        notify: true,
        readOnly: true
      },

      _queryParamsUpdating: {
        type: Boolean,
        value: false
      },
      /**
       * @type {?string}
       */
      _matched: {
        type: String,
        value: ''
      }
    },

    observers: ['__tryToMatch(route.path, pattern)', '__updatePathOnDataChange(data.*)', '__tailPathChanged(tail.path)', '__routeQueryParamsChanged(route.__queryParams)', '__tailQueryParamsChanged(tail.__queryParams)', '__queryParamsChanged(queryParams.*)'],

    created: function created() {
      this.linkPaths('route.__queryParams', 'tail.__queryParams');
      this.linkPaths('tail.__queryParams', 'route.__queryParams');
    },

    /**
     * Deal with the query params object being assigned to wholesale.
     */
    __routeQueryParamsChanged: function __routeQueryParamsChanged(queryParams) {
      if (queryParams && this.tail) {
        if (this.tail.__queryParams !== queryParams) {
          this.set('tail.__queryParams', queryParams);
        }

        if (!this.active || this._queryParamsUpdating) {
          return;
        }

        // Copy queryParams and track whether there are any differences compared
        // to the existing query params.
        var copyOfQueryParams = {};
        var anythingChanged = false;
        for (var key in queryParams) {
          copyOfQueryParams[key] = queryParams[key];
          if (anythingChanged || !this.queryParams || queryParams[key] !== this.queryParams[key]) {
            anythingChanged = true;
          }
        }
        // Need to check whether any keys were deleted
        for (var key in this.queryParams) {
          if (anythingChanged || !(key in queryParams)) {
            anythingChanged = true;
            break;
          }
        }

        if (!anythingChanged) {
          return;
        }
        this._queryParamsUpdating = true;
        this.set('queryParams', copyOfQueryParams);
        this._queryParamsUpdating = false;
      }
    },

    __tailQueryParamsChanged: function __tailQueryParamsChanged(queryParams) {
      if (queryParams && this.route && this.route.__queryParams != queryParams) {
        this.set('route.__queryParams', queryParams);
      }
    },

    __queryParamsChanged: function __queryParamsChanged(changes) {
      if (!this.active || this._queryParamsUpdating) {
        return;
      }

      this.set('route.__' + changes.path, changes.value);
    },

    __resetProperties: function __resetProperties() {
      this._setActive(false);
      this._matched = null;
    },

    __tryToMatch: function __tryToMatch() {
      if (!this.route) {
        return;
      }

      var path = this.route.path;
      var pattern = this.pattern;

      if (!pattern) {
        return;
      }

      if (!path) {
        this.__resetProperties();
        return;
      }

      var remainingPieces = path.split('/');
      var patternPieces = pattern.split('/');

      var matched = [];
      var namedMatches = {};

      for (var i = 0; i < patternPieces.length; i++) {
        var patternPiece = patternPieces[i];
        if (!patternPiece && patternPiece !== '') {
          break;
        }
        var pathPiece = remainingPieces.shift();

        // We don't match this path.
        if (!pathPiece && pathPiece !== '') {
          this.__resetProperties();
          return;
        }
        matched.push(pathPiece);

        if (patternPiece.charAt(0) == ':') {
          namedMatches[patternPiece.slice(1)] = pathPiece;
        } else if (patternPiece !== pathPiece) {
          this.__resetProperties();
          return;
        }
      }

      this._matched = matched.join('/');

      // Properties that must be updated atomically.
      var propertyUpdates = {};

      //this.active
      if (!this.active) {
        propertyUpdates.active = true;
      }

      // this.tail
      var tailPrefix = this.route.prefix + this._matched;
      var tailPath = remainingPieces.join('/');
      if (remainingPieces.length > 0) {
        tailPath = '/' + tailPath;
      }
      if (!this.tail || this.tail.prefix !== tailPrefix || this.tail.path !== tailPath) {
        propertyUpdates.tail = {
          prefix: tailPrefix,
          path: tailPath,
          __queryParams: this.route.__queryParams
        };
      }

      // this.data
      propertyUpdates.data = namedMatches;
      this._dataInUrl = {};
      for (var key in namedMatches) {
        this._dataInUrl[key] = namedMatches[key];
      }

      if (this.setProperties) {
        if (!this.active) {
          this._setActive(true);
        }
        // atomic update
        this.setProperties(propertyUpdates);
      } else {
        this.__setMulti(propertyUpdates);
      }
    },

    __tailPathChanged: function __tailPathChanged(path) {
      if (!this.active) {
        return;
      }
      var tailPath = path;
      var newPath = this._matched;
      if (tailPath) {
        if (tailPath.charAt(0) !== '/') {
          tailPath = '/' + tailPath;
        }
        newPath += tailPath;
      }
      this.set('route.path', newPath);
    },

    __updatePathOnDataChange: function __updatePathOnDataChange() {
      if (!this.route || !this.active) {
        return;
      }
      var newPath = this.__getLink({});
      var oldPath = this.__getLink(this._dataInUrl);
      if (newPath === oldPath) {
        return;
      }
      this.set('route.path', newPath);
    },

    __getLink: function __getLink(overrideValues) {
      var values = { tail: null };
      for (var key in this.data) {
        values[key] = this.data[key];
      }
      for (var key in overrideValues) {
        values[key] = overrideValues[key];
      }
      var patternPieces = this.pattern.split('/');
      var interp = patternPieces.map(function (value) {
        if (value[0] == ':') {
          value = values[value.slice(1)];
        }
        return value;
      }, this);
      if (values.tail && values.tail.path) {
        if (interp.length > 0 && values.tail.path.charAt(0) === '/') {
          interp.push(values.tail.path.slice(1));
        } else {
          interp.push(values.tail.path);
        }
      }
      return interp.join('/');
    },

    __setMulti: function __setMulti(setObj) {
      // HACK(rictic): skirting around 1.0's lack of a setMulti by poking at
      //     internal data structures. I would not advise that you copy this
      //     example.
      //
      //     In the future this will be a feature of Polymer itself.
      //     See: https://github.com/Polymer/polymer/issues/3640
      //
      //     Hacking around with private methods like this is juggling footguns,
      //     and is likely to have unexpected and unsupported rough edges.
      //
      //     Be ye so warned.
      for (var property in setObj) {
        this._propertySetter(property, setObj[property]);
      }
      //notify in a specific order
      if (setObj.data !== undefined) {
        this._pathEffector('data', this.data);
        this._notifyChange('data');
      }
      if (setObj.active !== undefined) {
        this._pathEffector('active', this.active);
        this._notifyChange('active');
      }
      if (setObj.tail !== undefined) {
        this._pathEffector('tail', this.tail);
        this._notifyChange('tail');
      }
    }
  });
})();

/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

__webpack_require__(17);

__webpack_require__(29);

var RegisterHtmlTemplate = __webpack_require__(2);

RegisterHtmlTemplate.register("<dom-module id=iron-pages> <template> <style>:host{display:block}:host>::slotted(:not(.iron-selected)){display:none!important}</style> <slot></slot> </template> </dom-module>");

Polymer({

  is: 'iron-pages',

  behaviors: [Polymer.IronResizableBehavior, Polymer.IronSelectableBehavior],

  properties: {

    // as the selected page is the only one visible, activateEvent
    // is both non-sensical and problematic; e.g. in cases where a user
    // handler attempts to change the page and the activateEvent
    // handler immediately changes it back
    activateEvent: {
      type: String,
      value: null
    }

  },

  observers: ['_selectedPageChanged(selected)'],

  _selectedPageChanged: function _selectedPageChanged(selected, old) {
    this.async(this.notifyResize);
  }
});

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

/**
 * @param {!Function} selectCallback
 * @constructor
 */
Polymer.IronSelection = function (selectCallback) {
  this.selection = [];
  this.selectCallback = selectCallback;
};

Polymer.IronSelection.prototype = {

  /**
   * Retrieves the selected item(s).
   *
   * @method get
   * @returns Returns the selected item(s). If the multi property is true,
   * `get` will return an array, otherwise it will return
   * the selected item or undefined if there is no selection.
   */
  get: function get() {
    return this.multi ? this.selection.slice() : this.selection[0];
  },

  /**
   * Clears all the selection except the ones indicated.
   *
   * @method clear
   * @param {Array} excludes items to be excluded.
   */
  clear: function clear(excludes) {
    this.selection.slice().forEach(function (item) {
      if (!excludes || excludes.indexOf(item) < 0) {
        this.setItemSelected(item, false);
      }
    }, this);
  },

  /**
   * Indicates if a given item is selected.
   *
   * @method isSelected
   * @param {*} item The item whose selection state should be checked.
   * @returns Returns true if `item` is selected.
   */
  isSelected: function isSelected(item) {
    return this.selection.indexOf(item) >= 0;
  },

  /**
   * Sets the selection state for a given item to either selected or deselected.
   *
   * @method setItemSelected
   * @param {*} item The item to select.
   * @param {boolean} isSelected True for selected, false for deselected.
   */
  setItemSelected: function setItemSelected(item, isSelected) {
    if (item != null) {
      if (isSelected !== this.isSelected(item)) {
        // proceed to update selection only if requested state differs from current
        if (isSelected) {
          this.selection.push(item);
        } else {
          var i = this.selection.indexOf(item);
          if (i >= 0) {
            this.selection.splice(i, 1);
          }
        }
        if (this.selectCallback) {
          this.selectCallback(item, isSelected);
        }
      }
    }
  },

  /**
   * Sets the selection state for a given item. If the `multi` property
   * is true, then the selected state of `item` will be toggled; otherwise
   * the `item` will be selected.
   *
   * @method select
   * @param {*} item The item to select.
   */
  select: function select(item) {
    if (this.multi) {
      this.toggle(item);
    } else if (this.get() !== item) {
      this.setItemSelected(this.get(), false);
      this.setItemSelected(item, true);
    }
  },

  /**
   * Toggles the selection state for `item`.
   *
   * @method toggle
   * @param {*} item The item to toggle.
   */
  toggle: function toggle(item) {
    this.setItemSelected(item, !this.isSelected(item));
  }

};

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

__webpack_require__(82);

/**
`iron-selector` is an element which can be used to manage a list of elements
that can be selected.  Tapping on the item will make the item selected.  The `selected` indicates
which item is being selected.  The default is to use the index of the item.
 Example:
     <iron-selector selected="0">
      <div>Item 1</div>
      <div>Item 2</div>
      <div>Item 3</div>
    </iron-selector>
 If you want to use the attribute value of an element for `selected` instead of the index,
set `attrForSelected` to the name of the attribute.  For example, if you want to select item by
`name`, set `attrForSelected` to `name`.
 Example:
     <iron-selector attr-for-selected="name" selected="foo">
      <div name="foo">Foo</div>
      <div name="bar">Bar</div>
      <div name="zot">Zot</div>
    </iron-selector>
 You can specify a default fallback with `fallbackSelection` in case the `selected` attribute does
not match the `attrForSelected` attribute of any elements.
 Example:
       <iron-selector attr-for-selected="name" selected="non-existing"
                     fallback-selection="default">
        <div name="foo">Foo</div>
        <div name="bar">Bar</div>
        <div name="default">Default</div>
      </iron-selector>
 Note: When the selector is multi, the selection will set to `fallbackSelection` iff
the number of matching elements is zero.
 `iron-selector` is not styled. Use the `iron-selected` CSS class to style the selected element.
 Example:
     <style>
      .iron-selected {
        background: #eee;
      }
    </style>
     ...
     <iron-selector selected="0">
      <div>Item 1</div>
      <div>Item 2</div>
      <div>Item 3</div>
    </iron-selector>
 @demo demo/index.html
*/

Polymer({

  is: 'iron-selector',

  behaviors: [Polymer.IronMultiSelectableBehavior]

});

/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

__webpack_require__(29);

/**
 * @polymerBehavior Polymer.IronMultiSelectableBehavior
 */
Polymer.IronMultiSelectableBehaviorImpl = {
  properties: {

    /**
     * If true, multiple selections are allowed.
     */
    multi: {
      type: Boolean,
      value: false,
      observer: 'multiChanged'
    },

    /**
     * Gets or sets the selected elements. This is used instead of `selected` when `multi`
     * is true.
     */
    selectedValues: {
      type: Array,
      notify: true,
      value: function value() {
        return [];
      }
    },

    /**
     * Returns an array of currently selected items.
     */
    selectedItems: {
      type: Array,
      readOnly: true,
      notify: true,
      value: function value() {
        return [];
      }
    }

  },

  observers: ['_updateSelected(selectedValues.splices)'],

  /**
   * Selects the given value. If the `multi` property is true, then the selected state of the
   * `value` will be toggled; otherwise the `value` will be selected.
   *
   * @method select
   * @param {string|number} value the value to select.
   */
  select: function select(value) {
    if (this.multi) {
      this._toggleSelected(value);
    } else {
      this.selected = value;
    }
  },

  multiChanged: function multiChanged(multi) {
    this._selection.multi = multi;
    this._updateSelected();
  },

  // UNUSED, FOR API COMPATIBILITY
  get _shouldUpdateSelection() {
    return this.selected != null || this.selectedValues != null && this.selectedValues.length;
  },

  _updateAttrForSelected: function _updateAttrForSelected() {
    if (!this.multi) {
      Polymer.IronSelectableBehavior._updateAttrForSelected.apply(this);
    } else if (this.selectedItems && this.selectedItems.length > 0) {
      this.selectedValues = this.selectedItems.map(function (selectedItem) {
        return this._indexToValue(this.indexOf(selectedItem));
      }, this).filter(function (unfilteredValue) {
        return unfilteredValue != null;
      }, this);
    }
  },

  _updateSelected: function _updateSelected() {
    if (this.multi) {
      this._selectMulti(this.selectedValues);
    } else {
      this._selectSelected(this.selected);
    }
  },

  _selectMulti: function _selectMulti(values) {
    values = values || [];

    var selectedItems = (this._valuesToItems(values) || []).filter(function (item) {
      return item !== null && item !== undefined;
    });

    // clear all but the current selected items
    this._selection.clear(selectedItems);

    // select only those not selected yet
    for (var i = 0; i < selectedItems.length; i++) {
      this._selection.setItemSelected(selectedItems[i], true);
    }

    // Check for items, since this array is populated only when attached
    if (this.fallbackSelection && !this._selection.get().length) {
      var fallback = this._valueToItem(this.fallbackSelection);
      if (fallback) {
        this.select(this.fallbackSelection);
      }
    }
  },

  _selectionChange: function _selectionChange() {
    var s = this._selection.get();
    if (this.multi) {
      this._setSelectedItems(s);
      this._setSelectedItem(s.length ? s[0] : null);
    } else {
      if (s !== null && s !== undefined) {
        this._setSelectedItems([s]);
        this._setSelectedItem(s);
      } else {
        this._setSelectedItems([]);
        this._setSelectedItem(null);
      }
    }
  },

  _toggleSelected: function _toggleSelected(value) {
    var i = this.selectedValues.indexOf(value);
    var unselected = i < 0;
    if (unselected) {
      this.push('selectedValues', value);
    } else {
      this.splice('selectedValues', i, 1);
    }
  },

  _valuesToItems: function _valuesToItems(values) {
    return values == null ? null : values.map(function (value) {
      return this._valueToItem(value);
    }, this);
  }
};

/** @polymerBehavior */
Polymer.IronMultiSelectableBehavior = [Polymer.IronSelectableBehavior, Polymer.IronMultiSelectableBehaviorImpl];

/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

__webpack_require__(37);

__webpack_require__(84);

/**
 * `Polymer.PaperInkyFocusBehavior` implements a ripple when the element has keyboard focus.
 *
 * @polymerBehavior Polymer.PaperInkyFocusBehavior
 */
Polymer.PaperInkyFocusBehaviorImpl = {
  observers: ['_focusedChanged(receivedFocusFromKeyboard)'],

  _focusedChanged: function _focusedChanged(receivedFocusFromKeyboard) {
    if (receivedFocusFromKeyboard) {
      this.ensureRipple();
    }
    if (this.hasRipple()) {
      this._ripple.holdDown = receivedFocusFromKeyboard;
    }
  },

  _createRipple: function _createRipple() {
    var ripple = Polymer.PaperRippleBehavior._createRipple();
    ripple.id = 'ink';
    ripple.setAttribute('center', '');
    ripple.classList.add('circle');
    return ripple;
  }
};

/** @polymerBehavior Polymer.PaperInkyFocusBehavior */
Polymer.PaperInkyFocusBehavior = [Polymer.IronButtonState, Polymer.IronControlState, Polymer.PaperRippleBehavior, Polymer.PaperInkyFocusBehaviorImpl];

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

__webpack_require__(34);

/**
 * `Polymer.PaperRippleBehavior` dynamically implements a ripple
 * when the element has focus via pointer or keyboard.
 *
 * NOTE: This behavior is intended to be used in conjunction with and after
 * `Polymer.IronButtonState` and `Polymer.IronControlState`.
 *
 * @polymerBehavior Polymer.PaperRippleBehavior
 */
Polymer.PaperRippleBehavior = {
  properties: {
    /**
     * If true, the element will not produce a ripple effect when interacted
     * with via the pointer.
     */
    noink: {
      type: Boolean,
      observer: '_noinkChanged'
    },

    /**
     * @type {Element|undefined}
     */
    _rippleContainer: {
      type: Object
    }
  },

  /**
   * Ensures a `<paper-ripple>` element is available when the element is
   * focused.
   */
  _buttonStateChanged: function _buttonStateChanged() {
    if (this.focused) {
      this.ensureRipple();
    }
  },

  /**
   * In addition to the functionality provided in `IronButtonState`, ensures
   * a ripple effect is created when the element is in a `pressed` state.
   */
  _downHandler: function _downHandler(event) {
    Polymer.IronButtonStateImpl._downHandler.call(this, event);
    if (this.pressed) {
      this.ensureRipple(event);
    }
  },

  /**
   * Ensures this element contains a ripple effect. For startup efficiency
   * the ripple effect is dynamically on demand when needed.
   * @param {!Event=} optTriggeringEvent (optional) event that triggered the
   * ripple.
   */
  ensureRipple: function ensureRipple(optTriggeringEvent) {
    if (!this.hasRipple()) {
      this._ripple = this._createRipple();
      this._ripple.noink = this.noink;
      var rippleContainer = this._rippleContainer || this.root;
      if (rippleContainer) {
        Polymer.dom(rippleContainer).appendChild(this._ripple);
      }
      if (optTriggeringEvent) {
        // Check if the event happened inside of the ripple container
        // Fall back to host instead of the root because distributed text
        // nodes are not valid event targets
        var domContainer = Polymer.dom(this._rippleContainer || this);
        var target = Polymer.dom(optTriggeringEvent).rootTarget;
        if (domContainer.deepContains( /** @type {Node} */target)) {
          this._ripple.uiDownAction(optTriggeringEvent);
        }
      }
    }
  },

  /**
   * Returns the `<paper-ripple>` element used by this element to create
   * ripple effects. The element's ripple is created on demand, when
   * necessary, and calling this method will force the
   * ripple to be created.
   */
  getRipple: function getRipple() {
    this.ensureRipple();
    return this._ripple;
  },

  /**
   * Returns true if this element currently contains a ripple effect.
   * @return {boolean}
   */
  hasRipple: function hasRipple() {
    return Boolean(this._ripple);
  },

  /**
   * Create the element's ripple effect via creating a `<paper-ripple>`.
   * Override this method to customize the ripple element.
   * @return {!PaperRippleElement} Returns a `<paper-ripple>` element.
   */
  _createRipple: function _createRipple() {
    return (/** @type {!PaperRippleElement} */document.createElement('paper-ripple')
    );
  },

  _noinkChanged: function _noinkChanged(noink) {
    if (this.hasRipple()) {
      this._ripple.noink = noink;
    }
  }
};

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(35);

var RegisterHtmlTemplate = __webpack_require__(2);

RegisterHtmlTemplate.toBody("<iron-iconset-svg name=my-icons size=24> <svg> <defs> <g id=arrow-back> <path d=\"M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z\"></path> </g> <g id=menu> <path d=\"M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z\"></path> </g> <g id=chevron-right> <path d=\"M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z\"></path> </g> <g id=close> <path d=\"M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z\"></path> </g> <g id=search><path d=\"M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z\"></path> </g> </defs> </svg> </iron-iconset-svg>");

/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgZjJkMjAwMmY2MDAyYTQxNGYzNDUiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL3BvbHltZXIuaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL3BvbHltZXIvbGliL3V0aWxzL2Jvb3QuaHRtbCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcG9seW1lci13ZWJwYWNrLWxvYWRlci9yZWdpc3Rlci1odG1sLXRlbXBsYXRlLmpzIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvdXRpbHMvbWl4aW4uaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL2FwcC1sYXlvdXQvYXBwLXNjcm9sbC1lZmZlY3RzL2FwcC1zY3JvbGwtZWZmZWN0cy1iZWhhdmlvci5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvaXJvbi1mbGV4LWxheW91dC9pcm9uLWZsZXgtbGF5b3V0Lmh0bWwiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL3BvbHltZXItZWxlbWVudC5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvdXRpbHMvcmVzb2x2ZS11cmwuaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL3BvbHltZXIvbGliL3V0aWxzL2FzeW5jLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi9taXhpbnMvbXV0YWJsZS1kYXRhLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi91dGlscy9jYXNlLW1hcC5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvbWl4aW5zL3Byb3BlcnR5LWVmZmVjdHMuaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL3BvbHltZXIvbGliL3V0aWxzL2RlYm91bmNlLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi91dGlscy9mbHVzaC5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvdXRpbHMvdGVtcGxhdGl6ZS5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvYXBwLWxheW91dC9hcHAtbGF5b3V0LWJlaGF2aW9yL2FwcC1sYXlvdXQtYmVoYXZpb3IuaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL2lyb24tYTExeS1rZXlzLWJlaGF2aW9yL2lyb24tYTExeS1rZXlzLWJlaGF2aW9yLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9pcm9uLXJlc2l6YWJsZS1iZWhhdmlvci9pcm9uLXJlc2l6YWJsZS1iZWhhdmlvci5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvaXJvbi1tZXRhL2lyb24tbWV0YS5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvbWl4aW5zL2VsZW1lbnQtbWl4aW4uaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL3BvbHltZXIvbGliL3V0aWxzL3NldHRpbmdzLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi91dGlscy9zdHlsZS1nYXRoZXIuaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL3BvbHltZXIvbGliL2xlZ2FjeS9sZWdhY3ktZWxlbWVudC1taXhpbi5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvbWl4aW5zL2dlc3R1cmUtZXZlbnQtbGlzdGVuZXJzLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi91dGlscy9hcnJheS1zcGxpY2UuaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL2FwcC1sYXlvdXQvYXBwLXNjcm9sbC1lZmZlY3RzL2VmZmVjdHMvYmxlbmQtYmFja2dyb3VuZC5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvYXBwLWxheW91dC9hcHAtc2Nyb2xsLWVmZmVjdHMvZWZmZWN0cy93YXRlcmZhbGwuaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL2FwcC1sYXlvdXQvYXBwLXNjcm9sbC1lZmZlY3RzL2VmZmVjdHMvcmVzaXplLXRpdGxlLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9hcHAtbGF5b3V0L2FwcC1zY3JvbGwtZWZmZWN0cy9lZmZlY3RzL3BhcmFsbGF4LWJhY2tncm91bmQuaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL2lyb24tc2VsZWN0b3IvaXJvbi1zZWxlY3RhYmxlLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9wYXBlci1zdHlsZXMvZGVmYXVsdC10aGVtZS5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvcGFwZXItaWNvbi1idXR0b24vcGFwZXItaWNvbi1idXR0b24uaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL2lyb24taWNvbi9pcm9uLWljb24uaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL2lyb24tYmVoYXZpb3JzL2lyb24tY29udHJvbC1zdGF0ZS5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvcGFwZXItcmlwcGxlL3BhcGVyLXJpcHBsZS5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvaXJvbi1pY29uc2V0LXN2Zy9pcm9uLWljb25zZXQtc3ZnLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9pcm9uLXNjcm9sbC10YXJnZXQtYmVoYXZpb3IvaXJvbi1zY3JvbGwtdGFyZ2V0LWJlaGF2aW9yLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9pcm9uLWJlaGF2aW9ycy9pcm9uLWJ1dHRvbi1zdGF0ZS5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvcGFwZXItc3R5bGVzL2NvbG9yLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vc3JjL215LWFwcC5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvZWxlbWVudHMvZG9tLW1vZHVsZS5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvdXRpbHMvcGF0aC5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvbWl4aW5zL3Byb3BlcnR5LWFjY2Vzc29ycy5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvbWl4aW5zL3RlbXBsYXRlLXN0YW1wLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9hcHAtbGF5b3V0L2FwcC1kcmF3ZXIvYXBwLWRyYXdlci5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvc2hhZHljc3MvYXBwbHktc2hpbS5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvc2hhZHljc3MvYXBwbHktc2hpbS5taW4uanMiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi91dGlscy9nZXN0dXJlcy5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvdXRpbHMvaW1wb3J0LWhyZWYuaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL3BvbHltZXIvbGliL3V0aWxzL3JlbmRlci1zdGF0dXMuaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL3BvbHltZXIvbGliL3V0aWxzL3VucmVzb2x2ZWQuaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL3BvbHltZXIvbGliL2xlZ2FjeS9wb2x5bWVyLmRvbS5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvdXRpbHMvZmxhdHRlbmVkLW5vZGVzLW9ic2VydmVyLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi9sZWdhY3kvcG9seW1lci1mbi5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvbGVnYWN5L2NsYXNzLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi9sZWdhY3kvdGVtcGxhdGl6ZXItYmVoYXZpb3IuaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL3BvbHltZXIvbGliL2VsZW1lbnRzL2RvbS1iaW5kLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi9lbGVtZW50cy9kb20tcmVwZWF0Lmh0bWwiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi9lbGVtZW50cy9kb20taWYuaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL3BvbHltZXIvbGliL2VsZW1lbnRzL2FycmF5LXNlbGVjdG9yLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi9lbGVtZW50cy9jdXN0b20tc3R5bGUuaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL3NoYWR5Y3NzL2N1c3RvbS1zdHlsZS1pbnRlcmZhY2UuaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL3NoYWR5Y3NzL2N1c3RvbS1zdHlsZS1pbnRlcmZhY2UubWluLmpzIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvbGVnYWN5L211dGFibGUtZGF0YS1iZWhhdmlvci5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvYXBwLWxheW91dC9hcHAtZHJhd2VyLWxheW91dC9hcHAtZHJhd2VyLWxheW91dC5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvaXJvbi1tZWRpYS1xdWVyeS9pcm9uLW1lZGlhLXF1ZXJ5Lmh0bWwiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9hcHAtbGF5b3V0L2FwcC1oZWFkZXIvYXBwLWhlYWRlci5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvYXBwLWxheW91dC9oZWxwZXJzL2hlbHBlcnMuaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL2FwcC1sYXlvdXQvYXBwLWhlYWRlci1sYXlvdXQvYXBwLWhlYWRlci1sYXlvdXQuaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL2FwcC1sYXlvdXQvYXBwLXNjcm9sbC1lZmZlY3RzL2FwcC1zY3JvbGwtZWZmZWN0cy5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvYXBwLWxheW91dC9hcHAtc2Nyb2xsLWVmZmVjdHMvZWZmZWN0cy9mYWRlLWJhY2tncm91bmQuaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL2FwcC1sYXlvdXQvYXBwLXNjcm9sbC1lZmZlY3RzL2VmZmVjdHMvbWF0ZXJpYWwuaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL2FwcC1sYXlvdXQvYXBwLXNjcm9sbC1lZmZlY3RzL2VmZmVjdHMvcmVzaXplLXNuYXBwZWQtdGl0bGUuaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL2FwcC1sYXlvdXQvYXBwLXRvb2xiYXIvYXBwLXRvb2xiYXIuaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL2FwcC1yb3V0ZS9hcHAtbG9jYXRpb24uaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL2lyb24tbG9jYXRpb24vaXJvbi1sb2NhdGlvbi5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvaXJvbi1sb2NhdGlvbi9pcm9uLXF1ZXJ5LXBhcmFtcy5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvYXBwLXJvdXRlL2FwcC1yb3V0ZS1jb252ZXJ0ZXItYmVoYXZpb3IuaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL2FwcC1yb3V0ZS9hcHAtcm91dGUuaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL2lyb24tcGFnZXMvaXJvbi1wYWdlcy5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvaXJvbi1zZWxlY3Rvci9pcm9uLXNlbGVjdGlvbi5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvaXJvbi1zZWxlY3Rvci9pcm9uLXNlbGVjdG9yLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9pcm9uLXNlbGVjdG9yL2lyb24tbXVsdGktc2VsZWN0YWJsZS5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvcGFwZXItYmVoYXZpb3JzL3BhcGVyLWlua3ktZm9jdXMtYmVoYXZpb3IuaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL3BhcGVyLWJlaGF2aW9ycy9wYXBlci1yaXBwbGUtYmVoYXZpb3IuaHRtbCIsIndlYnBhY2s6Ly8vLi9zcmMvbXktaWNvbnMuaHRtbCJdLCJuYW1lcyI6WyJSZWdpc3Rlckh0bWxUZW1wbGF0ZSIsInZhbCIsImNvbnRlbnQiLCJ0ZW1wbGF0ZSIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImlubmVySFRNTCIsImNyZWF0ZURvY3VtZW50RnJhZ21lbnQiLCJmaXJzdENoaWxkIiwiYXBwZW5kQ2hpbGQiLCJpbXBvcnROb2RlIiwidHJpbW1lZFZhbCIsInRyaW0iLCJkaXYiLCJib2R5IiwiaW5zZXJ0QmVmb3JlIiwiYWRkRXZlbnRMaXN0ZW5lciIsIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIiwidG9Cb2R5IiwiayIsIm4iLCJlbmQiLCJzdGFydCIsInJ1bGVzIiwicGFyZW50IiwicHJldmlvdXMiLCJjc3NUZXh0IiwicGFyc2VkQ3NzVGV4dCIsImF0UnVsZSIsInR5cGUiLCJwYXJzZWRTZWxlY3RvciIsInNlbGVjdG9yIiwia2V5ZnJhbWVzTmFtZSIsInAiLCJhIiwicmVwbGFjZSIsImFhIiwiYmEiLCJiIiwicSIsImMiLCJkIiwibGVuZ3RoIiwiZSIsImYiLCJoIiwiZyIsIm0iLCJwdXNoIiwic3Vic3RyaW5nIiwiY2EiLCJyIiwibGFzdEluZGV4T2YiLCJpbmRleE9mIiwidCIsIm1hdGNoIiwiZGEiLCJ1Iiwic3BsaXQiLCJwb3AiLCJ2IiwieCIsInkiLCJlYSIsImZhIiwiaGEiLCJpYSIsImphIiwiUHJvbWlzZSIsInJlc29sdmUiLCJrYSIsIl9hcHBseVNoaW1DdXJyZW50VmVyc2lvbiIsIl9hcHBseVNoaW1WYWxpZGF0aW5nVmVyc2lvbiIsIl9hcHBseVNoaW1OZXh0VmVyc2lvbiIsInoiLCJsYSIsInRoZW4iLCJBIiwid2luZG93IiwiU2hhZHlET00iLCJpblVzZSIsIkIiLCJDIiwic2hpbWNzc3Byb3BlcnRpZXMiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJDU1MiLCJzdXBwb3J0cyIsIlNoYWR5Q1NTIiwibmF0aXZlQ3NzIiwiV2ViQ29tcG9uZW50cyIsImZsYWdzIiwiRSIsIkYiLCJHIiwibWEiLCJIIiwiSSIsIl9fY3NzUnVsZXMiLCJ0ZXh0Q29udGVudCIsIkoiLCJtYXRjaE1lZGlhIiwibWF0Y2hlcyIsIksiLCJuYSIsIm9hIiwiTCIsInByb3RvdHlwZSIsInNldCIsImkiLCJnZXQiLCJNIiwiTiIsIm8iLCJ0ZXN0IiwibGFzdEluZGV4IiwicXVlcnlTZWxlY3RvciIsImoiLCJsIiwicGEiLCJxYSIsIk8iLCJleGVjIiwiaW5kZXgiLCJzbGljZSIsIlAiLCJqb2luIiwic2V0QXR0cmlidXRlIiwic3R5bGUiLCJhbGwiLCJoZWFkIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImdldFByb3BlcnR5VmFsdWUiLCJyYSIsIk9iamVjdCIsImFzc2lnbiIsImNyZWF0ZSIsIlgiLCJ3IiwiWSIsIkQiLCJkZXRlY3RNaXhpbiIsInRyYW5zZm9ybVN0eWxlIiwidHJhbnNmb3JtQ3VzdG9tU3R5bGUiLCJ0cmFuc2Zvcm1SdWxlcyIsInRyYW5zZm9ybVJ1bGUiLCJ0cmFuc2Zvcm1UZW1wbGF0ZSIsIl9zZXBhcmF0b3IiLCJkZWZpbmVQcm9wZXJ0eSIsIlEiLCJSIiwiSFRNTEltcG9ydHMiLCJ3aGVuUmVhZHkiLCJTIiwic2EiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJyZWFkeVN0YXRlIiwiVCIsIlUiLCJWIiwiaW52YWxpZENhbGxiYWNrIiwiQ3VzdG9tU3R5bGVJbnRlcmZhY2UiLCJ0cmFuc2Zvcm1DYWxsYmFjayIsInZhbGlkYXRlQ2FsbGJhY2siLCJlbnF1ZXVlZCIsIlciLCJwcmVwYXJlVGVtcGxhdGUiLCJfc3R5bGVBc3QiLCJwcm9jZXNzU3R5bGVzIiwiZ2V0U3R5bGVGb3JDdXN0b21TdHlsZSIsInN0eWxlU3VidHJlZSIsInJlbW92ZVByb3BlcnR5Iiwic2V0UHJvcGVydHkiLCJzaGFkb3dSb290Iiwic3R5bGVFbGVtZW50IiwiY2hpbGRyZW4iLCJjaGlsZE5vZGVzIiwibG9jYWxOYW1lIiwiZ2V0QXR0cmlidXRlIiwiaXMiLCJzdHlsZURvY3VtZW50IiwiU2NvcGluZ1NoaW0iLCJaIiwidGEiLCJnZXRDb21wdXRlZFN0eWxlVmFsdWUiLCJuYXRpdmVTaGFkb3ciLCJBcHBseVNoaW0iLCJjYWxsIiwiY3VzdG9tU3R5bGVzIiwiX19zZWVuQnlTaGFkeUNTUyIsIl9fc2hhZHlDU1NDYWNoZWRTdHlsZSIsImdldFN0eWxlIiwiX19hcHBsaWVkRWxlbWVudCIsImFkZEN1c3RvbVN0eWxlIiwiZGVmaW5lUHJvcGVydGllcyJdLCJtYXBwaW5ncyI6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QixxQkFBcUJvQixNQUFyQixDQUE0Qiwrd0JBQTVCLEUiLCJmaWxlIjoibWFpbi5idW5kbGUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBpbnN0YWxsIGEgSlNPTlAgY2FsbGJhY2sgZm9yIGNodW5rIGxvYWRpbmdcbiBcdHZhciBwYXJlbnRKc29ucEZ1bmN0aW9uID0gd2luZG93W1wid2VicGFja0pzb25wXCJdO1xuIFx0d2luZG93W1wid2VicGFja0pzb25wXCJdID0gZnVuY3Rpb24gd2VicGFja0pzb25wQ2FsbGJhY2soY2h1bmtJZHMsIG1vcmVNb2R1bGVzLCBleGVjdXRlTW9kdWxlcykge1xuIFx0XHQvLyBhZGQgXCJtb3JlTW9kdWxlc1wiIHRvIHRoZSBtb2R1bGVzIG9iamVjdCxcbiBcdFx0Ly8gdGhlbiBmbGFnIGFsbCBcImNodW5rSWRzXCIgYXMgbG9hZGVkIGFuZCBmaXJlIGNhbGxiYWNrXG4gXHRcdHZhciBtb2R1bGVJZCwgY2h1bmtJZCwgaSA9IDAsIHJlc29sdmVzID0gW10sIHJlc3VsdDtcbiBcdFx0Zm9yKDtpIDwgY2h1bmtJZHMubGVuZ3RoOyBpKyspIHtcbiBcdFx0XHRjaHVua0lkID0gY2h1bmtJZHNbaV07XG4gXHRcdFx0aWYoaW5zdGFsbGVkQ2h1bmtzW2NodW5rSWRdKSB7XG4gXHRcdFx0XHRyZXNvbHZlcy5wdXNoKGluc3RhbGxlZENodW5rc1tjaHVua0lkXVswXSk7XG4gXHRcdFx0fVxuIFx0XHRcdGluc3RhbGxlZENodW5rc1tjaHVua0lkXSA9IDA7XG4gXHRcdH1cbiBcdFx0Zm9yKG1vZHVsZUlkIGluIG1vcmVNb2R1bGVzKSB7XG4gXHRcdFx0aWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vcmVNb2R1bGVzLCBtb2R1bGVJZCkpIHtcbiBcdFx0XHRcdG1vZHVsZXNbbW9kdWxlSWRdID0gbW9yZU1vZHVsZXNbbW9kdWxlSWRdO1xuIFx0XHRcdH1cbiBcdFx0fVxuIFx0XHRpZihwYXJlbnRKc29ucEZ1bmN0aW9uKSBwYXJlbnRKc29ucEZ1bmN0aW9uKGNodW5rSWRzLCBtb3JlTW9kdWxlcywgZXhlY3V0ZU1vZHVsZXMpO1xuIFx0XHR3aGlsZShyZXNvbHZlcy5sZW5ndGgpIHtcbiBcdFx0XHRyZXNvbHZlcy5zaGlmdCgpKCk7XG4gXHRcdH1cblxuIFx0fTtcblxuIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gb2JqZWN0cyB0byBzdG9yZSBsb2FkZWQgYW5kIGxvYWRpbmcgY2h1bmtzXG4gXHR2YXIgaW5zdGFsbGVkQ2h1bmtzID0ge1xuIFx0XHQ0OiAwXG4gXHR9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cbiBcdC8vIFRoaXMgZmlsZSBjb250YWlucyBvbmx5IHRoZSBlbnRyeSBjaHVuay5cbiBcdC8vIFRoZSBjaHVuayBsb2FkaW5nIGZ1bmN0aW9uIGZvciBhZGRpdGlvbmFsIGNodW5rc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5lID0gZnVuY3Rpb24gcmVxdWlyZUVuc3VyZShjaHVua0lkKSB7XG4gXHRcdHZhciBpbnN0YWxsZWRDaHVua0RhdGEgPSBpbnN0YWxsZWRDaHVua3NbY2h1bmtJZF07XG4gXHRcdGlmKGluc3RhbGxlZENodW5rRGF0YSA9PT0gMCkge1xuIFx0XHRcdHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlKSB7IHJlc29sdmUoKTsgfSk7XG4gXHRcdH1cblxuIFx0XHQvLyBhIFByb21pc2UgbWVhbnMgXCJjdXJyZW50bHkgbG9hZGluZ1wiLlxuIFx0XHRpZihpbnN0YWxsZWRDaHVua0RhdGEpIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkQ2h1bmtEYXRhWzJdO1xuIFx0XHR9XG5cbiBcdFx0Ly8gc2V0dXAgUHJvbWlzZSBpbiBjaHVuayBjYWNoZVxuIFx0XHR2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuIFx0XHRcdGluc3RhbGxlZENodW5rRGF0YSA9IGluc3RhbGxlZENodW5rc1tjaHVua0lkXSA9IFtyZXNvbHZlLCByZWplY3RdO1xuIFx0XHR9KTtcbiBcdFx0aW5zdGFsbGVkQ2h1bmtEYXRhWzJdID0gcHJvbWlzZTtcblxuIFx0XHQvLyBzdGFydCBjaHVuayBsb2FkaW5nXG4gXHRcdHZhciBoZWFkID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXTtcbiBcdFx0dmFyIHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuIFx0XHRzY3JpcHQudHlwZSA9ICd0ZXh0L2phdmFzY3JpcHQnO1xuIFx0XHRzY3JpcHQuY2hhcnNldCA9ICd1dGYtOCc7XG4gXHRcdHNjcmlwdC5hc3luYyA9IHRydWU7XG4gXHRcdHNjcmlwdC50aW1lb3V0ID0gMTIwMDAwO1xuXG4gXHRcdGlmIChfX3dlYnBhY2tfcmVxdWlyZV9fLm5jKSB7XG4gXHRcdFx0c2NyaXB0LnNldEF0dHJpYnV0ZShcIm5vbmNlXCIsIF9fd2VicGFja19yZXF1aXJlX18ubmMpO1xuIFx0XHR9XG4gXHRcdHNjcmlwdC5zcmMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fLnAgKyBcIlwiICsgY2h1bmtJZCArIFwiLmJ1bmRsZS5qc1wiO1xuIFx0XHR2YXIgdGltZW91dCA9IHNldFRpbWVvdXQob25TY3JpcHRDb21wbGV0ZSwgMTIwMDAwKTtcbiBcdFx0c2NyaXB0Lm9uZXJyb3IgPSBzY3JpcHQub25sb2FkID0gb25TY3JpcHRDb21wbGV0ZTtcbiBcdFx0ZnVuY3Rpb24gb25TY3JpcHRDb21wbGV0ZSgpIHtcbiBcdFx0XHQvLyBhdm9pZCBtZW0gbGVha3MgaW4gSUUuXG4gXHRcdFx0c2NyaXB0Lm9uZXJyb3IgPSBzY3JpcHQub25sb2FkID0gbnVsbDtcbiBcdFx0XHRjbGVhclRpbWVvdXQodGltZW91dCk7XG4gXHRcdFx0dmFyIGNodW5rID0gaW5zdGFsbGVkQ2h1bmtzW2NodW5rSWRdO1xuIFx0XHRcdGlmKGNodW5rICE9PSAwKSB7XG4gXHRcdFx0XHRpZihjaHVuaykge1xuIFx0XHRcdFx0XHRjaHVua1sxXShuZXcgRXJyb3IoJ0xvYWRpbmcgY2h1bmsgJyArIGNodW5rSWQgKyAnIGZhaWxlZC4nKSk7XG4gXHRcdFx0XHR9XG4gXHRcdFx0XHRpbnN0YWxsZWRDaHVua3NbY2h1bmtJZF0gPSB1bmRlZmluZWQ7XG4gXHRcdFx0fVxuIFx0XHR9O1xuIFx0XHRoZWFkLmFwcGVuZENoaWxkKHNjcmlwdCk7XG5cbiBcdFx0cmV0dXJuIHByb21pc2U7XG4gXHR9O1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuIFx0XHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcbiBcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4gXHRcdFx0XHRnZXQ6IGdldHRlclxuIFx0XHRcdH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcImRpc3QvXCI7XG5cbiBcdC8vIG9uIGVycm9yIGZ1bmN0aW9uIGZvciBhc3luYyBsb2FkaW5nXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm9lID0gZnVuY3Rpb24oZXJyKSB7IGNvbnNvbGUuZXJyb3IoZXJyKTsgdGhyb3cgZXJyOyB9O1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDM5KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrL2Jvb3RzdHJhcCBmMmQyMDAyZjYwMDJhNDE0ZjM0NSIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCJsaWIvbGVnYWN5L2xlZ2FjeS1lbGVtZW50LW1peGluLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCJsaWIvbGVnYWN5L3BvbHltZXItZm4uaHRtbFwiPlxuPCEtLSB0ZW1wbGF0ZSBlbGVtZW50cyAtLT5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCJsaWIvbGVnYWN5L3RlbXBsYXRpemVyLWJlaGF2aW9yLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCJsaWIvZWxlbWVudHMvZG9tLWJpbmQuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cImxpYi9lbGVtZW50cy9kb20tcmVwZWF0Lmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCJsaWIvZWxlbWVudHMvZG9tLWlmLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCJsaWIvZWxlbWVudHMvYXJyYXktc2VsZWN0b3IuaHRtbFwiPlxuPCEtLSBjdXN0b20tc3R5bGUgLS0+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwibGliL2VsZW1lbnRzL2N1c3RvbS1zdHlsZS5odG1sXCI+XG48IS0tIGJjIGJlaGF2aW9ycyAtLT5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCJsaWIvbGVnYWN5L211dGFibGUtZGF0YS1iZWhhdmlvci5odG1sXCI+XG48c2NyaXB0PlxuICAvLyBiY1xuICBQb2x5bWVyLkJhc2UgPSBQb2x5bWVyLkxlZ2FjeUVsZW1lbnRNaXhpbihIVE1MRWxlbWVudCkucHJvdG90eXBlO1xuPC9zY3JpcHQ+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL3BvbHltZXIvcG9seW1lci5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuPHNjcmlwdD5cbihmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIGNvbnN0IHVzZXJQb2x5bWVyID0gd2luZG93LlBvbHltZXI7XG5cbiAgLyoqXG4gICAqIEBuYW1lc3BhY2UgUG9seW1lclxuICAgKiBAc3VtbWFyeSBQb2x5bWVyIGlzIGEgbGlnaHR3ZWlnaHQgbGlicmFyeSBidWlsdCBvbiB0b3Agb2YgdGhlIHdlYlxuICAgKiAgIHN0YW5kYXJkcy1iYXNlZCBXZWIgQ29tcG9uZW50cyBBUEkncywgYW5kIG1ha2VzIGl0IGVhc3kgdG8gYnVpbGQgeW91clxuICAgKiAgIG93biBjdXN0b20gSFRNTCBlbGVtZW50cy5cbiAgICogQHBhcmFtIHshUG9seW1lckluaXR9IGluZm8gUHJvdG90eXBlIGZvciB0aGUgY3VzdG9tIGVsZW1lbnQuIEl0IG11c3QgY29udGFpblxuICAgKiAgIGFuIGBpc2AgcHJvcGVydHkgdG8gc3BlY2lmeSB0aGUgZWxlbWVudCBuYW1lLiBPdGhlciBwcm9wZXJ0aWVzIHBvcHVsYXRlXG4gICAqICAgdGhlIGVsZW1lbnQgcHJvdG90eXBlLiBUaGUgYHByb3BlcnRpZXNgLCBgb2JzZXJ2ZXJzYCwgYGhvc3RBdHRyaWJ1dGVzYCxcbiAgICogICBhbmQgYGxpc3RlbmVyc2AgcHJvcGVydGllcyBhcmUgcHJvY2Vzc2VkIHRvIGNyZWF0ZSBlbGVtZW50IGZlYXR1cmVzLlxuICAgKiBAcmV0dXJuIHshT2JqZWN0fSBSZXR1cm5zIGEgY3VzdG9tIGVsZW1lbnQgY2xhc3MgZm9yIHRoZSBnaXZlbiBwcm92aWRlZFxuICAgKiAgIHByb3RvdHlwZSBgaW5mb2Agb2JqZWN0LiBUaGUgbmFtZSBvZiB0aGUgZWxlbWVudCBpZiBnaXZlbiBieSBgaW5mby5pc2AuXG4gICAqL1xuICB3aW5kb3cuUG9seW1lciA9IGZ1bmN0aW9uKGluZm8pIHtcbiAgICByZXR1cm4gd2luZG93LlBvbHltZXIuX3BvbHltZXJGbihpbmZvKTtcbiAgfVxuXG4gIC8vIHN1cHBvcnQgdXNlciBzZXR0aW5ncyBvbiB0aGUgUG9seW1lciBvYmplY3RcbiAgaWYgKHVzZXJQb2x5bWVyKSB7XG4gICAgT2JqZWN0LmFzc2lnbihQb2x5bWVyLCB1c2VyUG9seW1lcik7XG4gIH1cblxuICAvLyBUbyBiZSBwbHVnZ2VkIGJ5IGxlZ2FjeSBpbXBsZW1lbnRhdGlvbiBpZiBsb2FkZWRcbiAgLyogZXNsaW50LWRpc2FibGUgdmFsaWQtanNkb2MgKi9cbiAgLyoqXG4gICAqIEBwYXJhbSB7IVBvbHltZXJJbml0fSBpbmZvIFByb3RvdHlwZSBmb3IgdGhlIGN1c3RvbSBlbGVtZW50LiBJdCBtdXN0IGNvbnRhaW5cbiAgICogICBhbiBgaXNgIHByb3BlcnR5IHRvIHNwZWNpZnkgdGhlIGVsZW1lbnQgbmFtZS4gT3RoZXIgcHJvcGVydGllcyBwb3B1bGF0ZVxuICAgKiAgIHRoZSBlbGVtZW50IHByb3RvdHlwZS4gVGhlIGBwcm9wZXJ0aWVzYCwgYG9ic2VydmVyc2AsIGBob3N0QXR0cmlidXRlc2AsXG4gICAqICAgYW5kIGBsaXN0ZW5lcnNgIHByb3BlcnRpZXMgYXJlIHByb2Nlc3NlZCB0byBjcmVhdGUgZWxlbWVudCBmZWF0dXJlcy5cbiAgICogQHJldHVybiB7IU9iamVjdH0gUmV0dXJucyBhIGN1c3RvbSBlbGVtZW50IGNsYXNzIGZvciB0aGUgZ2l2ZW4gcHJvdmlkZWRcbiAgICogICBwcm90b3R5cGUgYGluZm9gIG9iamVjdC4gVGhlIG5hbWUgb2YgdGhlIGVsZW1lbnQgaWYgZ2l2ZW4gYnkgYGluZm8uaXNgLlxuICAgKi9cbiAgd2luZG93LlBvbHltZXIuX3BvbHltZXJGbiA9IGZ1bmN0aW9uKGluZm8pIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIHRocm93IG5ldyBFcnJvcignTG9hZCBwb2x5bWVyLmh0bWwgdG8gdXNlIHRoZSBQb2x5bWVyKCkgZnVuY3Rpb24uJyk7XG4gIH1cbiAgLyogZXNsaW50LWVuYWJsZSAqL1xuXG4gIHdpbmRvdy5Qb2x5bWVyLnZlcnNpb24gPSAnMi4wLjEnO1xuXG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG4gIC8qXG4gIFdoZW4gdXNpbmcgQ2xvc3VyZSBDb21waWxlciwgSlNDb21waWxlcl9yZW5hbWVQcm9wZXJ0eShwcm9wZXJ0eSwgb2JqZWN0KSBpcyByZXBsYWNlZCBieSB0aGUgbXVuZ2VkIG5hbWUgZm9yIG9iamVjdFtwcm9wZXJ0eV1cbiAgV2UgY2Fubm90IGFsaWFzIHRoaXMgZnVuY3Rpb24sIHNvIHdlIGhhdmUgdG8gdXNlIGEgc21hbGwgc2hpbSB0aGF0IGhhcyB0aGUgc2FtZSBiZWhhdmlvciB3aGVuIG5vdCBjb21waWxpbmcuXG4gICovXG4gIHdpbmRvdy5KU0NvbXBpbGVyX3JlbmFtZVByb3BlcnR5ID0gZnVuY3Rpb24ocHJvcCwgb2JqKSB7XG4gICAgcmV0dXJuIHByb3A7XG4gIH1cbiAgLyogZXNsaW50LWVuYWJsZSAqL1xuXG59KSgpO1xuPC9zY3JpcHQ+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL3BvbHltZXIvbGliL3V0aWxzL2Jvb3QuaHRtbCIsIi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuXG5jbGFzcyBSZWdpc3Rlckh0bWxUZW1wbGF0ZSB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBgPHRlbXBsYXRlPmAgZWxlbWVudCB0byBob2xkIGA8ZG9tLW1vZHVsZT5gIGNvbnRlbnQuXG4gICAqIFRoaXMgYml0IG9mIGNvZGUgd2lsbCBleGVjdXRlIGluIHRoZSBjb250ZXh0IG9mIHRoZSBtYWluIGRvY3VtZW50LFxuICAgKiBjYWxsaW5nIGBpbXBvcnROb2RlYCBvbiB0aGUgYDx0ZW1wbGF0ZT5gLCB3aGljaCBpbiB0dXJuIHRyaWdnZXJzXG4gICAqIHRoZSBsaWZlY3ljbGUgb2YgdGhlIGA8ZG9tLW1vZHVsZT5gIGFuZCBhbGxvd3MgaXQgdG8gaW5zZXJ0IGl0c1xuICAgKiBjb250ZW50IGludG8gUG9seW1lcidzIGdsb2JhbCBtb2R1bGUgbWFwLiBXaGVuIGEgUG9seW1lciBlbGVtZW50XG4gICAqIGJvb3RzIHVwIGl0IHdpbGwgZmV0Y2ggaXRzIHRlbXBsYXRlIGZyb20gdGhpcyBtb2R1bGUgbWFwLlxuICAgKiBodHRwczovL2dpdGh1Yi5jb20vUG9seW1lci9wb2x5bWVyL2Jsb2IvbWFzdGVyL2xpYi9taXhpbnMvZWxlbWVudC1taXhpbi5odG1sI0w1MDEtTDUzOFxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsIEEgYDxkb20tbW9kdWxlPmAgYXMgYW4gSFRNTCBzdHJpbmdcbiAgICovXG4gIHN0YXRpYyByZWdpc3Rlcih2YWwpIHtcbiAgICBsZXQgY29udGVudDtcbiAgICBjb25zdCB0ZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJyk7XG4gICAgdGVtcGxhdGUuaW5uZXJIVE1MID0gdmFsO1xuICAgIGlmICh0ZW1wbGF0ZS5jb250ZW50KSB7XG4gICAgICBjb250ZW50ID0gdGVtcGxhdGUuY29udGVudDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBwcmVmZXItZGVzdHJ1Y3R1cmluZ1xuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgICAgd2hpbGUgKHRlbXBsYXRlLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgY29udGVudC5hcHBlbmRDaGlsZCh0ZW1wbGF0ZS5maXJzdENoaWxkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZG9jdW1lbnQuaW1wb3J0Tm9kZShjb250ZW50LCB0cnVlKTtcbiAgfVxuICAvKipcbiAgICogQ29udGVudCB0aGF0IHdpbGwgYmUgaW5qZWN0ZWQgaW50byB0aGUgbWFpbiBkb2N1bWVudC4gVGhpcyBpcyBwcmltYXJpbHlcbiAgICogZm9yIHRoaW5ncyBsaWtlIGA8aXJvbi1pY29uc2V0PmAgYW5kIGA8Y3VzdG9tLXN0eWxlPmAgd2hpY2ggZG8gbm90IGhhdmVcbiAgICogdGVtcGxhdGVzIGJ1dCByZWx5IG9uIEhUTUwgSW1wb3J0cyBhYmlsaXR5IHRvIGFwcGx5IGNvbnRlbnQgdG8gdGhlIG1haW5cbiAgICogZG9jdW1lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWwgQW4gSFRNTCBzdHJpbmdcbiAgICovXG4gIHN0YXRpYyB0b0JvZHkodmFsKSB7XG4gICAgY29uc3QgdHJpbW1lZFZhbCA9IHZhbC50cmltKCk7XG4gICAgaWYgKHRyaW1tZWRWYWwpIHtcbiAgICAgIGNvbnN0IGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgZGl2LmlubmVySFRNTCA9IHRyaW1tZWRWYWw7XG4gICAgICBpZiAoZGl2LmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgaWYgKGRvY3VtZW50LmJvZHkpIHtcbiAgICAgICAgICBkb2N1bWVudC5ib2R5Lmluc2VydEJlZm9yZShkaXYuZmlyc3RDaGlsZCwgZG9jdW1lbnQuYm9keS5maXJzdENoaWxkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgKCkgPT4ge1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5pbnNlcnRCZWZvcmUoZGl2LmZpcnN0Q2hpbGQsIGRvY3VtZW50LmJvZHkuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWdpc3Rlckh0bWxUZW1wbGF0ZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9wb2x5bWVyLXdlYnBhY2stbG9hZGVyL3JlZ2lzdGVyLWh0bWwtdGVtcGxhdGUuanMiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCJib290Lmh0bWxcIj5cblxuPHNjcmlwdD5cblxuKGZ1bmN0aW9uKCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICAvLyB1bmlxdWUgZ2xvYmFsIGlkIGZvciBkZWR1cGluZyBtaXhpbnMuXG4gIGxldCBkZWR1cGVJZCA9IDA7XG5cbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAZXh0ZW5kcyB7RnVuY3Rpb259XG4gICAqL1xuICBmdW5jdGlvbiBNaXhpbkZ1bmN0aW9uKCl7fVxuICAvKiogQHR5cGUgeyhXZWFrTWFwIHwgdW5kZWZpbmVkKX0gKi9cbiAgTWl4aW5GdW5jdGlvbi5wcm90b3R5cGUuX19taXhpbkFwcGxpY2F0aW9ucztcbiAgLyoqIEB0eXBlIHsoT2JqZWN0IHwgdW5kZWZpbmVkKX0gKi9cbiAgTWl4aW5GdW5jdGlvbi5wcm90b3R5cGUuX19taXhpblNldDtcblxuICAvKiBlc2xpbnQtZGlzYWJsZSB2YWxpZC1qc2RvYyAqL1xuICAvKipcbiAgICogV3JhcHMgYW4gRVM2IGNsYXNzIGV4cHJlc3Npb24gbWl4aW4gc3VjaCB0aGF0IHRoZSBtaXhpbiBpcyBvbmx5IGFwcGxpZWRcbiAgICogaWYgaXQgaGFzIG5vdCBhbHJlYWR5IGJlZW4gYXBwbGllZCBpdHMgYmFzZSBhcmd1bWVudC4gIEFsc28gbWVtb2l6ZXMgbWl4aW5cbiAgICogYXBwbGljYXRpb25zLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgUG9seW1lclxuICAgKiBAdGVtcGxhdGUgVFxuICAgKiBAcGFyYW0ge1R9IG1peGluIEVTNiBjbGFzcyBleHByZXNzaW9uIG1peGluIHRvIHdyYXBcbiAgICogQHN1cHByZXNzIHtpbnZhbGlkQ2FzdHN9XG4gICAqL1xuICBQb2x5bWVyLmRlZHVwaW5nTWl4aW4gPSBmdW5jdGlvbihtaXhpbikge1xuICAgIGxldCBtaXhpbkFwcGxpY2F0aW9ucyA9IC8qKiBAdHlwZSB7IU1peGluRnVuY3Rpb259ICovKG1peGluKS5fX21peGluQXBwbGljYXRpb25zO1xuICAgIGlmICghbWl4aW5BcHBsaWNhdGlvbnMpIHtcbiAgICAgIG1peGluQXBwbGljYXRpb25zID0gbmV3IFdlYWtNYXAoKTtcbiAgICAgIC8qKiBAdHlwZSB7IU1peGluRnVuY3Rpb259ICovKG1peGluKS5fX21peGluQXBwbGljYXRpb25zID0gbWl4aW5BcHBsaWNhdGlvbnM7XG4gICAgfVxuICAgIC8vIG1haW50YWluIGEgdW5pcXVlIGlkIGZvciBlYWNoIG1peGluXG4gICAgbGV0IG1peGluRGVkdXBlSWQgPSBkZWR1cGVJZCsrO1xuICAgIGZ1bmN0aW9uIGRlZHVwaW5nTWl4aW4oYmFzZSkge1xuICAgICAgbGV0IGJhc2VTZXQgPSAvKiogQHR5cGUgeyFNaXhpbkZ1bmN0aW9ufSAqLyhiYXNlKS5fX21peGluU2V0O1xuICAgICAgaWYgKGJhc2VTZXQgJiYgYmFzZVNldFttaXhpbkRlZHVwZUlkXSkge1xuICAgICAgICByZXR1cm4gYmFzZTtcbiAgICAgIH1cbiAgICAgIGxldCBtYXAgPSBtaXhpbkFwcGxpY2F0aW9ucztcbiAgICAgIGxldCBleHRlbmRlZCA9IG1hcC5nZXQoYmFzZSk7XG4gICAgICBpZiAoIWV4dGVuZGVkKSB7XG4gICAgICAgIGV4dGVuZGVkID0gLyoqIEB0eXBlIHshRnVuY3Rpb259ICovKG1peGluKShiYXNlKTtcbiAgICAgICAgbWFwLnNldChiYXNlLCBleHRlbmRlZCk7XG4gICAgICB9XG4gICAgICAvLyBjb3B5IGluaGVyaXRlZCBtaXhpbiBzZXQgZnJvbSB0aGUgZXh0ZW5kZWQgY2xhc3MsIG9yIHRoZSBiYXNlIGNsYXNzXG4gICAgICAvLyBOT1RFOiB3ZSBhdm9pZCB1c2Ugb2YgU2V0IGhlcmUgYmVjYXVzZSBzb21lIGJyb3dzZXIgKElFMTEpXG4gICAgICAvLyBjYW5ub3QgZXh0ZW5kIGEgYmFzZSBTZXQgdmlhIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgIGxldCBtaXhpblNldCA9IE9iamVjdC5jcmVhdGUoLyoqIEB0eXBlIHshTWl4aW5GdW5jdGlvbn0gKi8oZXh0ZW5kZWQpLl9fbWl4aW5TZXQgfHwgYmFzZVNldCB8fCBudWxsKTtcbiAgICAgIG1peGluU2V0W21peGluRGVkdXBlSWRdID0gdHJ1ZTtcbiAgICAgIC8qKiBAdHlwZSB7IU1peGluRnVuY3Rpb259ICovKGV4dGVuZGVkKS5fX21peGluU2V0ID0gbWl4aW5TZXQ7XG4gICAgICByZXR1cm4gZXh0ZW5kZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlZHVwaW5nTWl4aW47XG4gIH07XG4gIC8qIGVzbGludC1lbmFibGUgdmFsaWQtanNkb2MgKi9cblxufSkoKTtcblxuPC9zY3JpcHQ+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL3BvbHltZXIvbGliL3V0aWxzL21peGluLmh0bWwiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi8uLi9wb2x5bWVyL3BvbHltZXIuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uLy4uL2lyb24tc2Nyb2xsLXRhcmdldC1iZWhhdmlvci9pcm9uLXNjcm9sbC10YXJnZXQtYmVoYXZpb3IuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL2hlbHBlcnMvaGVscGVycy5odG1sXCI+XG5cbjxzY3JpcHQ+XG4gIC8qKlxuICAgKiBgUG9seW1lci5BcHBTY3JvbGxFZmZlY3RzQmVoYXZpb3JgIHByb3ZpZGVzIGFuIGludGVyZmFjZSB0aGF0IGFsbG93cyBhbiBlbGVtZW50IHRvIHVzZSBzY3JvbGxzIGVmZmVjdHMuXG4gICAqXG4gICAqICMjIyBJbXBvcnRpbmcgdGhlIGFwcC1sYXlvdXQgZWZmZWN0c1xuICAgKlxuICAgKiBhcHAtbGF5b3V0IHByb3ZpZGVzIGEgc2V0IG9mIHNjcm9sbCBlZmZlY3RzIHRoYXQgY2FuIGJlIHVzZWQgYnkgZXhwbGljaXRseSBpbXBvcnRpbmdcbiAgICogYGFwcC1zY3JvbGwtZWZmZWN0cy5odG1sYDpcbiAgICpcbiAgICogYGBgaHRtbFxuICAgKiA8bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiL2Jvd2VyX2NvbXBvbmVudHMvYXBwLWxheW91dC9hcHAtc2Nyb2xsLWVmZmVjdHMvYXBwLXNjcm9sbC1lZmZlY3RzLmh0bWxcIj5cbiAgICogYGBgXG4gICAqXG4gICAqIFRoZSBzY3JvbGwgZWZmZWN0cyBjYW4gYWxzbyBiZSB1c2VkIGJ5IGluZGl2aWR1YWxseSBpbXBvcnRpbmdcbiAgICogYGFwcC1sYXlvdXQvYXBwLXNjcm9sbC1lZmZlY3RzL2VmZmVjdHMvW2VmZmVjdE5hbWVdLmh0bWxgLiBGb3IgZXhhbXBsZTpcbiAgICpcbiAgICogYGBgaHRtbFxuICAgKiAgPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi9ib3dlcl9jb21wb25lbnRzL2FwcC1sYXlvdXQvYXBwLXNjcm9sbC1lZmZlY3RzL2VmZmVjdHMvd2F0ZXJmYWxsLmh0bWxcIj5cbiAgICogYGBgXG4gICAqXG4gICAqICMjIyBDb25zdW1pbmcgZWZmZWN0c1xuICAgKlxuICAgKiBFZmZlY3RzIGNhbiBiZSBjb25zdW1lZCB2aWEgdGhlIGBlZmZlY3RzYCBwcm9wZXJ0eS4gRm9yIGV4YW1wbGU6XG4gICAqXG4gICAqIGBgYGh0bWxcbiAgICogPGFwcC1oZWFkZXIgZWZmZWN0cz1cIndhdGVyZmFsbFwiPjwvYXBwLWhlYWRlcj5cbiAgICogYGBgXG4gICAqXG4gICAqICMjIyBDcmVhdGluZyBzY3JvbGwgZWZmZWN0c1xuICAgKlxuICAgKiBZb3UgbWF5IHdhbnQgdG8gY3JlYXRlIGEgY3VzdG9tIHNjcm9sbCBlZmZlY3QgaWYgeW91IG5lZWQgdG8gbW9kaWZ5IHRoZSBDU1Mgb2YgYW4gZWxlbWVudFxuICAgKiBiYXNlZCBvbiB0aGUgc2Nyb2xsIHBvc2l0aW9uLlxuICAgKlxuICAgKiBBIHNjcm9sbCBlZmZlY3QgZGVmaW5pdGlvbiBpcyBhbiBvYmplY3Qgd2l0aCBgc2V0VXAoKWAsIGB0ZWFyRG93bigpYCBhbmQgYHJ1bigpYCBmdW5jdGlvbnMuXG4gICAqXG4gICAqIFRvIHJlZ2lzdGVyIHRoZSBlZmZlY3QsIHlvdSBjYW4gdXNlIGBQb2x5bWVyLkFwcExheW91dC5yZWdpc3RlckVmZmVjdChlZmZlY3ROYW1lLCBlZmZlY3REZWYpYFxuICAgKiBGb3IgZXhhbXBsZSwgbGV0J3MgZGVmaW5lIGFuIGVmZmVjdCB0aGF0IHJlc2l6ZXMgdGhlIGhlYWRlcidzIGxvZ286XG4gICAqXG4gICAqIGBgYGpzXG4gICAqIFBvbHltZXIuQXBwTGF5b3V0LnJlZ2lzdGVyRWZmZWN0KCdyZXNpemFibGUtbG9nbycsIHtcbiAgICogICBzZXRVcDogZnVuY3Rpb24oY29uZmlnKSB7XG4gICAqICAgICAvLyB0aGUgZWZmZWN0J3MgY29uZmlnIGlzIHBhc3NlZCB0byB0aGUgc2V0VXAuXG4gICAqICAgICB0aGlzLl9meFJlc2l6ZUxvZ28gPSB7IGxvZ286IFBvbHltZXIuZG9tKHRoaXMpLnF1ZXJ5U2VsZWN0b3IoJ1tsb2dvXScpIH07XG4gICAqICAgfSxcbiAgICpcbiAgICogICBydW46IGZ1bmN0aW9uKHByb2dyZXNzKSB7XG4gICAqICAgICAgLy8gdGhlIHByb2dyZXNzIG9mIHRoZSBlZmZlY3RcbiAgICogICAgICB0aGlzLnRyYW5zZm9ybSgnc2NhbGUzZCgnICsgcHJvZ3Jlc3MgKyAnLCAnKyBwcm9ncmVzcyArJywgMSknLCAgdGhpcy5fZnhSZXNpemVMb2dvLmxvZ28pO1xuICAgKiAgIH0sXG4gICAqXG4gICAqICAgdGVhckRvd246IGZ1bmN0aW9uKCkge1xuICAgKiAgICAgIC8vIGNsZWFuIHVwIGFuZCByZXNldCBvZiBzdGF0ZXNcbiAgICogICAgICBkZWxldGUgdGhpcy5fZnhSZXNpemVMb2dvO1xuICAgKiAgIH1cbiAgICogfSk7XG4gICAqIGBgYFxuICAgKiBOb3csIHlvdSBjYW4gY29uc3VtZSB0aGUgZWZmZWN0OlxuICAgKlxuICAgKiBgYGBodG1sXG4gICAqIDxhcHAtaGVhZGVyIGlkPVwiYXBwSGVhZGVyXCIgZWZmZWN0cz1cInJlc2l6YWJsZS1sb2dvXCI+XG4gICAqICAgPGltZyBsb2dvIHNyYz1cImxvZ28uc3ZnXCI+XG4gICAqIDwvYXBwLWhlYWRlcj5cbiAgICogYGBgXG4gICAqXG4gICAqICMjIyBJbXBlcmF0aXZlIEFQSVxuICAgKlxuICAgKiBgYGBqc1xuICAgKiB2YXIgbG9nb0VmZmVjdCA9IGFwcEhlYWRlci5jcmVhdGVFZmZlY3QoJ3Jlc2l6YWJsZS1sb2dvJywgZWZmZWN0Q29uZmlnKTtcbiAgICogLy8gcnVuIHRoZSBlZmZlY3Q6IGxvZ29FZmZlY3QucnVuKHByb2dyZXNzKTtcbiAgICogLy8gdGVhciBkb3duIHRoZSBlZmZlY3Q6IGxvZ29FZmZlY3QudGVhckRvd24oKTtcbiAgICogYGBgXG4gICAqXG4gICAqICMjIyBDb25maWd1cmluZyBlZmZlY3RzXG4gICAqXG4gICAqIEZvciBlZmZlY3RzIGluc3RhbGxlZCB2aWEgdGhlIGBlZmZlY3RzYCBwcm9wZXJ0eSwgdGhlaXIgY29uZmlndXJhdGlvbiBjYW4gYmUgc2V0XG4gICAqIHZpYSB0aGUgYGVmZmVjdHNDb25maWdgIHByb3BlcnR5LiBGb3IgZXhhbXBsZTpcbiAgICpcbiAgICogYGBgaHRtbFxuICAgKiA8YXBwLWhlYWRlciBlZmZlY3RzPVwid2F0ZXJmYWxsXCJcbiAgICogICBlZmZlY3RzLWNvbmZpZz0ne1wid2F0ZXJmYWxsXCI6IHtcInN0YXJ0c0F0XCI6IDAsIFwiZW5kc0F0XCI6IDAuNX19Jz5cbiAgICogPC9hcHAtaGVhZGVyPlxuICAgKiBgYGBcbiAgICpcbiAgICogQWxsIGVmZmVjdHMgaGF2ZSBhIGBzdGFydHNBdGAgYW5kIGBlbmRzQXRgIGNvbmZpZyBwcm9wZXJ0eS4gVGhleSBzcGVjaWZ5IGF0IHdoYXRcbiAgICogcG9pbnQgdGhlIGVmZmVjdCBzaG91bGQgc3RhcnQgYW5kIGVuZC4gVGhpcyB2YWx1ZSBnb2VzIGZyb20gMCB0byAxIGluY2x1c2l2ZS5cbiAgICpcbiAgICogQHBvbHltZXJCZWhhdmlvclxuICAgKi9cbiAgUG9seW1lci5BcHBTY3JvbGxFZmZlY3RzQmVoYXZpb3IgPSBbXG4gICAgUG9seW1lci5Jcm9uU2Nyb2xsVGFyZ2V0QmVoYXZpb3IsXG4gICB7XG5cbiAgICBwcm9wZXJ0aWVzOiB7XG5cbiAgICAgIC8qKlxuICAgICAgICogQSBzcGFjZS1zZXBhcmF0ZWQgbGlzdCBvZiB0aGUgZWZmZWN0cyBuYW1lcyB0aGF0IHdpbGwgYmUgdHJpZ2dlcmVkIHdoZW4gdGhlIHVzZXIgc2Nyb2xscy5cbiAgICAgICAqIGUuZy4gYHdhdGVyZmFsbCBwYXJhbGxheC1iYWNrZ3JvdW5kYCBpbnN0YWxscyB0aGUgYHdhdGVyZmFsbGAgYW5kIGBwYXJhbGxheC1iYWNrZ3JvdW5kYC5cbiAgICAgICAqL1xuICAgICAgZWZmZWN0czoge1xuICAgICAgICB0eXBlOiBTdHJpbmdcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogQW4gb2JqZWN0IHRoYXQgY29uZmlndXJhdGVzIHRoZSBlZmZlY3RzIGluc3RhbGxlZCB2aWEgdGhlIGBlZmZlY3RzYCBwcm9wZXJ0eS4gZS5nLlxuICAgICAgICogYGBganNcbiAgICAgICAqICBlbGVtZW50LmVmZmVjdHNDb25maWcgPSB7XG4gICAgICAgKiAgIFwiYmxlbmQtYmFja2dyb3VuZFwiOiB7XG4gICAgICAgKiAgICAgXCJzdGFydHNBdFwiOiAwLjVcbiAgICAgICAqICAgfVxuICAgICAgICogfTtcbiAgICAgICAqIGBgYFxuICAgICAgICogRXZlcnkgZWZmZWN0IGhhcyBhdCBsZWFzdCB0d28gY29uZmlnIHByb3BlcnRpZXM6IGBzdGFydHNBdGAgYW5kIGBlbmRzQXRgLlxuICAgICAgICogVGhlc2UgcHJvcGVydGllcyBpbmRpY2F0ZSB3aGVuIHRoZSBldmVudCBzaG91bGQgc3RhcnQgYW5kIGVuZCByZXNwZWN0aXZlbHlcbiAgICAgICAqIGFuZCByZWxhdGl2ZSB0byB0aGUgb3ZlcmFsbCBlbGVtZW50IHByb2dyZXNzLiBTbyBmb3IgZXhhbXBsZSwgaWYgYGJsZW5kLWJhY2tncm91bmRgXG4gICAgICAgKiBzdGFydHMgYXQgYDAuNWAsIHRoZSBlZmZlY3Qgd2lsbCBvbmx5IHN0YXJ0IG9uY2UgdGhlIGN1cnJlbnQgZWxlbWVudCByZWFjaGVzIDAuNVxuICAgICAgICogb2YgaXRzIHByb2dyZXNzLiBJbiB0aGlzIGNvbnRleHQsIHRoZSBwcm9ncmVzcyBpcyBhIHZhbHVlIGluIHRoZSByYW5nZSBvZiBgWzAsIDFdYFxuICAgICAgICogdGhhdCBpbmRpY2F0ZXMgd2hlcmUgdGhpcyBlbGVtZW50IGlzIG9uIHRoZSBzY3JlZW4gcmVsYXRpdmUgdG8gdGhlIHZpZXdwb3J0LlxuICAgICAgICovXG4gICAgICBlZmZlY3RzQ29uZmlnOiB7XG4gICAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBEaXNhYmxlcyBDU1MgdHJhbnNpdGlvbnMgYW5kIHNjcm9sbCBlZmZlY3RzIG9uIHRoZSBlbGVtZW50LlxuICAgICAgICovXG4gICAgICBkaXNhYmxlZDoge1xuICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICByZWZsZWN0VG9BdHRyaWJ1dGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBBbGxvd3MgdG8gc2V0IGEgYHNjcm9sbFRvcGAgdGhyZXNob2xkLiBXaGVuIGdyZWF0ZXIgdGhhbiAwLCBgdGhyZXNob2xkVHJpZ2dlcmVkYFxuICAgICAgICogaXMgdHJ1ZSBvbmx5IHdoZW4gdGhlIHNjcm9sbCB0YXJnZXQncyBgc2Nyb2xsVG9wYCBoYXMgcmVhY2hlZCB0aGlzIHZhbHVlLlxuICAgICAgICpcbiAgICAgICAqIEZvciBleGFtcGxlLCBpZiBgdGhyZXNob2xkID0gMTAwYCwgYHRocmVzaG9sZFRyaWdnZXJlZGAgaXMgdHJ1ZSB3aGVuIHRoZSBgc2Nyb2xsVG9wYFxuICAgICAgICogaXMgYXQgbGVhc3QgYDEwMGAuXG4gICAgICAgKi9cbiAgICAgIHRocmVzaG9sZDoge1xuICAgICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICAgIHZhbHVlOiAwXG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFRydWUgaWYgdGhlIGBzY3JvbGxUb3BgIHRocmVzaG9sZCAoc2V0IGluIGBzY3JvbGxUb3BUaHJlc2hvbGRgKSBoYXNcbiAgICAgICAqIGJlZW4gcmVhY2hlZC5cbiAgICAgICAqL1xuICAgICAgdGhyZXNob2xkVHJpZ2dlcmVkOiB7XG4gICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgIG5vdGlmeTogdHJ1ZSxcbiAgICAgICAgcmVhZE9ubHk6IHRydWUsXG4gICAgICAgIHJlZmxlY3RUb0F0dHJpYnV0ZTogdHJ1ZVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBvYnNlcnZlcnM6IFtcbiAgICAgICdfZWZmZWN0c0NoYW5nZWQoZWZmZWN0cywgZWZmZWN0c0NvbmZpZywgaXNBdHRhY2hlZCknXG4gICAgXSxcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIHNjcm9sbCBzdGF0ZS4gVGhpcyBtZXRob2Qgc2hvdWxkIGJlIG92ZXJyaWRkZW5cbiAgICAgKiBieSB0aGUgY29uc3VtZXIgb2YgdGhpcyBiZWhhdmlvci5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgX3VwZGF0ZVNjcm9sbFN0YXRlXG4gICAgICovXG4gICAgX3VwZGF0ZVNjcm9sbFN0YXRlOiBmdW5jdGlvbigpIHt9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBjdXJyZW50IGVsZW1lbnQgaXMgb24gdGhlIHNjcmVlbi5cbiAgICAgKiBUaGF0IGlzLCB2aXNpYmxlIGluIHRoZSBjdXJyZW50IHZpZXdwb3J0LiBUaGlzIG1ldGhvZCBzaG91bGQgYmVcbiAgICAgKiBvdmVycmlkZGVuIGJ5IHRoZSBjb25zdW1lciBvZiB0aGlzIGJlaGF2aW9yLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBpc09uU2NyZWVuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc09uU2NyZWVuOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZXJlJ3MgY29udGVudCBiZWxvdyB0aGUgY3VycmVudCBlbGVtZW50LiBUaGlzIG1ldGhvZFxuICAgICAqIHNob3VsZCBiZSBvdmVycmlkZGVuIGJ5IHRoZSBjb25zdW1lciBvZiB0aGlzIGJlaGF2aW9yLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBpc0NvbnRlbnRCZWxvd1xuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgaXNDb250ZW50QmVsb3c6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBMaXN0IG9mIGVmZmVjdHMgaGFuZGxlcnMgdGhhdCB3aWxsIHRha2UgcGxhY2UgZHVyaW5nIHNjcm9sbC5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtBcnJheTxGdW5jdGlvbj59XG4gICAgICovXG4gICAgX2VmZmVjdHNSdW5GbjogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIExpc3Qgb2YgdGhlIGVmZmVjdHMgZGVmaW5pdGlvbnMgaW5zdGFsbGVkIHZpYSB0aGUgYGVmZmVjdHNgIHByb3BlcnR5LlxuICAgICAqXG4gICAgICogQHR5cGUge0FycmF5PE9iamVjdD59XG4gICAgICovXG4gICAgX2VmZmVjdHM6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgY2xhbXBlZCB2YWx1ZSBvZiBgX3Njcm9sbFRvcGAuXG4gICAgICogQHR5cGUgbnVtYmVyXG4gICAgICovXG4gICAgZ2V0IF9jbGFtcGVkU2Nyb2xsVG9wKCkge1xuICAgICAgcmV0dXJuIE1hdGgubWF4KDAsIHRoaXMuX3Njcm9sbFRvcCk7XG4gICAgfSxcblxuICAgIGRldGFjaGVkOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX3RlYXJEb3duRWZmZWN0cygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGVmZmVjdCBvYmplY3QgZnJvbSBhbiBlZmZlY3QncyBuYW1lIHRoYXQgY2FuIGJlIHVzZWQgdG8gcnVuXG4gICAgICogZWZmZWN0cyBwcm9ncmFtbWF0aWNhbGx5LlxuICAgICAqXG4gICAgICogQG1ldGhvZCBjcmVhdGVFZmZlY3RcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZWZmZWN0TmFtZSBUaGUgZWZmZWN0J3MgbmFtZSByZWdpc3RlcmVkIHZpYSBgUG9seW1lci5BcHBMYXlvdXQucmVnaXN0ZXJFZmZlY3RgLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0PX0gZWZmZWN0Q29uZmlnIFRoZSBlZmZlY3QgY29uZmlnIG9iamVjdC4gKE9wdGlvbmFsKVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gQW4gZWZmZWN0IG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgZnVuY3Rpb25zOlxuICAgICAqXG4gICAgICogICogYGVmZmVjdC5zZXRVcCgpYCwgU2V0cyB1cCB0aGUgcmVxdWlyZW1lbnRzIGZvciB0aGUgZWZmZWN0LlxuICAgICAqICAgICAgIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIGF1dG9tYXRpY2FsbHkgYmVmb3JlIHRoZSBgZWZmZWN0YCBmdW5jdGlvbiByZXR1cm5zLlxuICAgICAqICAqIGBlZmZlY3QucnVuKHByb2dyZXNzLCB5KWAsIFJ1bnMgdGhlIGVmZmVjdCBnaXZlbiBhIGBwcm9ncmVzc2AuXG4gICAgICogICogYGVmZmVjdC50ZWFyRG93bigpYCwgQ2xlYW5zIHVwIGFueSBET00gbm9kZXMgb3IgZWxlbWVudCByZWZlcmVuY2VzIHVzZWQgYnkgdGhlIGVmZmVjdC5cbiAgICAgKlxuICAgICAqIEV4YW1wbGU6XG4gICAgICogYGBganNcbiAgICAgKiB2YXIgcGFyYWxsYXggPSBlbGVtZW50LmNyZWF0ZUVmZmVjdCgncGFyYWxsYXgtYmFja2dyb3VuZCcpO1xuICAgICAqIC8vIHJ1bnMgdGhlIGVmZmVjdFxuICAgICAqIHBhcmFsbGF4LnJ1bigwLjUsIDApO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGNyZWF0ZUVmZmVjdDogZnVuY3Rpb24oZWZmZWN0TmFtZSwgZWZmZWN0Q29uZmlnKSB7XG4gICAgICB2YXIgZWZmZWN0RGVmID0gUG9seW1lci5BcHBMYXlvdXQuX3Njcm9sbEVmZmVjdHNbZWZmZWN0TmFtZV07XG4gICAgICBpZiAoIWVmZmVjdERlZikge1xuICAgICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IodGhpcy5fZ2V0VW5kZWZpbmVkTXNnKGVmZmVjdE5hbWUpKTtcbiAgICAgIH1cbiAgICAgIHZhciBwcm9wID0gdGhpcy5fYm91bmRFZmZlY3QoZWZmZWN0RGVmLCBlZmZlY3RDb25maWcgfHwge30pO1xuICAgICAgcHJvcC5zZXRVcCgpO1xuICAgICAgcmV0dXJuIHByb3A7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuIGBlZmZlY3RzYCBvciBgZWZmZWN0c0NvbmZpZ2AgY2hhbmdlcy5cbiAgICAgKi9cbiAgICBfZWZmZWN0c0NoYW5nZWQ6IGZ1bmN0aW9uKGVmZmVjdHMsIGVmZmVjdHNDb25maWcsIGlzQXR0YWNoZWQpIHtcbiAgICAgIHRoaXMuX3RlYXJEb3duRWZmZWN0cygpO1xuXG4gICAgICBpZiAoIWVmZmVjdHMgfHwgIWlzQXR0YWNoZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZWZmZWN0cy5zcGxpdCgnICcpLmZvckVhY2goZnVuY3Rpb24oZWZmZWN0TmFtZSkge1xuICAgICAgICB2YXIgZWZmZWN0RGVmO1xuICAgICAgICBpZiAoZWZmZWN0TmFtZSAhPT0gJycpIHtcbiAgICAgICAgICBpZiAoKGVmZmVjdERlZiA9IFBvbHltZXIuQXBwTGF5b3V0Ll9zY3JvbGxFZmZlY3RzW2VmZmVjdE5hbWVdKSkge1xuICAgICAgICAgICAgdGhpcy5fZWZmZWN0cy5wdXNoKHRoaXMuX2JvdW5kRWZmZWN0KGVmZmVjdERlZiwgZWZmZWN0c0NvbmZpZ1tlZmZlY3ROYW1lXSkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4odGhpcy5fZ2V0VW5kZWZpbmVkTXNnKGVmZmVjdE5hbWUpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIHRoaXMpO1xuXG4gICAgICB0aGlzLl9zZXRVcEVmZmVjdCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGb3JjZXMgbGF5b3V0XG4gICAgICovXG4gICAgX2xheW91dElmRGlydHk6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMub2Zmc2V0V2lkdGg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gZWZmZWN0IG9iamVjdCBib3VuZCB0byB0aGUgY3VycmVudCBjb250ZXh0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGVmZmVjdERlZlxuICAgICAqIEBwYXJhbSB7T2JqZWN0PX0gZWZmZWN0c0NvbmZpZyBUaGUgZWZmZWN0IGNvbmZpZyBvYmplY3QgaWYgdGhlIGVmZmVjdCBhY2NlcHRzIGNvbmZpZyB2YWx1ZXMuIChPcHRpb25hbClcbiAgICAgKi9cbiAgICBfYm91bmRFZmZlY3Q6IGZ1bmN0aW9uKGVmZmVjdERlZiwgZWZmZWN0c0NvbmZpZykge1xuICAgICAgZWZmZWN0c0NvbmZpZyA9IGVmZmVjdHNDb25maWcgfHwge307XG4gICAgICB2YXIgc3RhcnRzQXQgPSBwYXJzZUZsb2F0KGVmZmVjdHNDb25maWcuc3RhcnRzQXQgfHwgMCk7XG4gICAgICB2YXIgZW5kc0F0ID0gcGFyc2VGbG9hdChlZmZlY3RzQ29uZmlnLmVuZHNBdCB8fCAxKTtcbiAgICAgIHZhciBkZWx0YVMgPSBlbmRzQXQgLSBzdGFydHNBdDtcbiAgICAgIHZhciBub29wID0gZnVuY3Rpb24oKSB7fTtcbiAgICAgIC8vIGZhc3QgcGF0aCBpZiBwb3NzaWJsZVxuICAgICAgdmFyIHJ1bkZuID0gKHN0YXJ0c0F0ID09PSAwICYmIGVuZHNBdCA9PT0gMSkgPyBlZmZlY3REZWYucnVuIDpcbiAgICAgICAgZnVuY3Rpb24ocHJvZ3Jlc3MsIHkpIHtcbiAgICAgICAgICBlZmZlY3REZWYucnVuLmNhbGwodGhpcyxcbiAgICAgICAgICAgICAgTWF0aC5tYXgoMCwgKHByb2dyZXNzIC0gc3RhcnRzQXQpIC8gZGVsdGFTKSwgeSk7XG4gICAgICAgIH07XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzZXRVcDogZWZmZWN0RGVmLnNldFVwID8gZWZmZWN0RGVmLnNldFVwLmJpbmQodGhpcywgZWZmZWN0c0NvbmZpZykgOiBub29wLFxuICAgICAgICBydW46IGVmZmVjdERlZi5ydW4gPyBydW5Gbi5iaW5kKHRoaXMpIDogbm9vcCxcbiAgICAgICAgdGVhckRvd246IGVmZmVjdERlZi50ZWFyRG93biA/IGVmZmVjdERlZi50ZWFyRG93bi5iaW5kKHRoaXMpIDogbm9vcFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB1cCB0aGUgZWZmZWN0cy5cbiAgICAgKi9cbiAgICBfc2V0VXBFZmZlY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuaXNBdHRhY2hlZCAmJiB0aGlzLl9lZmZlY3RzKSB7XG4gICAgICAgIHRoaXMuX2VmZmVjdHNSdW5GbiA9IFtdO1xuICAgICAgICB0aGlzLl9lZmZlY3RzLmZvckVhY2goZnVuY3Rpb24oZWZmZWN0RGVmKSB7XG4gICAgICAgICAgLy8gaW5zdGFsbCB0aGUgZWZmZWN0IG9ubHkgaWYgbm8gZXJyb3Igd2FzIHJlcG9ydGVkXG4gICAgICAgICAgaWYgKGVmZmVjdERlZi5zZXRVcCgpICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgdGhpcy5fZWZmZWN0c1J1bkZuLnB1c2goZWZmZWN0RGVmLnJ1bik7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGVhcnMgZG93biB0aGUgZWZmZWN0cy5cbiAgICAgKi9cbiAgICBfdGVhckRvd25FZmZlY3RzOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLl9lZmZlY3RzKSB7XG4gICAgICAgIHRoaXMuX2VmZmVjdHMuZm9yRWFjaChmdW5jdGlvbihlZmZlY3REZWYpIHtcbiAgICAgICAgICBlZmZlY3REZWYudGVhckRvd24oKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB0aGlzLl9lZmZlY3RzUnVuRm4gPSBbXTtcbiAgICAgIHRoaXMuX2VmZmVjdHMgPSBbXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUnVucyB0aGUgZWZmZWN0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwIFRoZSBwcm9ncmVzc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IFRoZSB0b3AgcG9zaXRpb24gb2YgdGhlIGN1cnJlbnQgZWxlbWVudCByZWxhdGl2ZSB0byB0aGUgdmlld3BvcnQuXG4gICAgICovXG4gICAgX3J1bkVmZmVjdHM6IGZ1bmN0aW9uKHAsIHkpIHtcbiAgICAgIGlmICh0aGlzLl9lZmZlY3RzUnVuRm4pIHtcbiAgICAgICAgdGhpcy5fZWZmZWN0c1J1bkZuLmZvckVhY2goZnVuY3Rpb24ocnVuKSB7XG4gICAgICAgICAgcnVuKHAsIHkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGVzIHRoZSBgX3Njcm9sbEhhbmRsZXJgLlxuICAgICAqL1xuICAgIF9zY3JvbGxIYW5kbGVyOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5kaXNhYmxlZCkge1xuICAgICAgICB2YXIgc2Nyb2xsVG9wID0gdGhpcy5fY2xhbXBlZFNjcm9sbFRvcDtcbiAgICAgICAgdGhpcy5fdXBkYXRlU2Nyb2xsU3RhdGUoc2Nyb2xsVG9wKTtcbiAgICAgICAgaWYgKHRoaXMudGhyZXNob2xkID4gMCkge1xuICAgICAgICAgIHRoaXMuX3NldFRocmVzaG9sZFRyaWdnZXJlZChzY3JvbGxUb3AgPj0gdGhpcy50aHJlc2hvbGQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIHJldHVybiBhIHJlZmVyZW5jZSB0byBhIG5vZGUgaW4gdGhlIGxvY2FsIERPTS5cbiAgICAgKiBUaGUgbm9kZSBpcyBjb25zdW1lZCBieSBhIHNjcm9sbCBlZmZlY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgVGhlIGlkIGZvciB0aGUgbm9kZS5cbiAgICAgKi9cbiAgICBfZ2V0RE9NUmVmOiBmdW5jdGlvbihpZCkge1xuICAgICAgY29uc29sZS53YXJuKCdfZ2V0RE9NUmVmJywgJ2AnKyBpZCArJ2AgaXMgdW5kZWZpbmVkJyk7XG4gICAgfSxcblxuICAgIF9nZXRVbmRlZmluZWRNc2c6IGZ1bmN0aW9uKGVmZmVjdE5hbWUpIHtcbiAgICAgIHJldHVybiAnU2Nyb2xsIGVmZmVjdCBgJyArIGVmZmVjdE5hbWUgKyAnYCBpcyB1bmRlZmluZWQuICcgK1xuICAgICAgICAgICdEaWQgeW91IGZvcmdldCB0byBpbXBvcnQgYXBwLWxheW91dC9hcHAtc2Nyb2xsLWVmZmVjdHMvZWZmZWN0cy8nICsgZWZmZWN0TmFtZSArICcuaHRtbCA/JztcbiAgICB9XG5cbiAgfV07XG5cbjwvc2NyaXB0PlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9hcHAtbGF5b3V0L2FwcC1zY3JvbGwtZWZmZWN0cy9hcHAtc2Nyb2xsLWVmZmVjdHMtYmVoYXZpb3IuaHRtbCIsIlxucmVxdWlyZSgnLi4vcG9seW1lci9wb2x5bWVyLmh0bWwnKTtcblxuY29uc3QgUmVnaXN0ZXJIdG1sVGVtcGxhdGUgPSByZXF1aXJlKCdwb2x5bWVyLXdlYnBhY2stbG9hZGVyL3JlZ2lzdGVyLWh0bWwtdGVtcGxhdGUnKTtcblxuUmVnaXN0ZXJIdG1sVGVtcGxhdGUudG9Cb2R5KFwiPGN1c3RvbS1zdHlsZT4gPHN0eWxlIGlzPWN1c3RvbS1zdHlsZT5odG1sey0tbGF5b3V0OntkaXNwbGF5Oi1tcy1mbGV4Ym94O2Rpc3BsYXk6LXdlYmtpdC1mbGV4O2Rpc3BsYXk6ZmxleH07LS1sYXlvdXQtaW5saW5lOntkaXNwbGF5Oi1tcy1pbmxpbmUtZmxleGJveDtkaXNwbGF5Oi13ZWJraXQtaW5saW5lLWZsZXg7ZGlzcGxheTppbmxpbmUtZmxleH07LS1sYXlvdXQtaG9yaXpvbnRhbDp7QGFwcGx5IC0tbGF5b3V0Oy1tcy1mbGV4LWRpcmVjdGlvbjpyb3c7LXdlYmtpdC1mbGV4LWRpcmVjdGlvbjpyb3c7ZmxleC1kaXJlY3Rpb246cm93fTstLWxheW91dC1ob3Jpem9udGFsLXJldmVyc2U6e0BhcHBseSAtLWxheW91dDstbXMtZmxleC1kaXJlY3Rpb246cm93LXJldmVyc2U7LXdlYmtpdC1mbGV4LWRpcmVjdGlvbjpyb3ctcmV2ZXJzZTtmbGV4LWRpcmVjdGlvbjpyb3ctcmV2ZXJzZX07LS1sYXlvdXQtdmVydGljYWw6e0BhcHBseSAtLWxheW91dDstbXMtZmxleC1kaXJlY3Rpb246Y29sdW1uOy13ZWJraXQtZmxleC1kaXJlY3Rpb246Y29sdW1uO2ZsZXgtZGlyZWN0aW9uOmNvbHVtbn07LS1sYXlvdXQtdmVydGljYWwtcmV2ZXJzZTp7QGFwcGx5IC0tbGF5b3V0Oy1tcy1mbGV4LWRpcmVjdGlvbjpjb2x1bW4tcmV2ZXJzZTstd2Via2l0LWZsZXgtZGlyZWN0aW9uOmNvbHVtbi1yZXZlcnNlO2ZsZXgtZGlyZWN0aW9uOmNvbHVtbi1yZXZlcnNlfTstLWxheW91dC13cmFwOnstbXMtZmxleC13cmFwOndyYXA7LXdlYmtpdC1mbGV4LXdyYXA6d3JhcDtmbGV4LXdyYXA6d3JhcH07LS1sYXlvdXQtd3JhcC1yZXZlcnNlOnstbXMtZmxleC13cmFwOndyYXAtcmV2ZXJzZTstd2Via2l0LWZsZXgtd3JhcDp3cmFwLXJldmVyc2U7ZmxleC13cmFwOndyYXAtcmV2ZXJzZX07LS1sYXlvdXQtZmxleC1hdXRvOnstbXMtZmxleDoxIDEgYXV0bzstd2Via2l0LWZsZXg6MSAxIGF1dG87ZmxleDoxIDEgYXV0b307LS1sYXlvdXQtZmxleC1ub25lOnstbXMtZmxleDpub25lOy13ZWJraXQtZmxleDpub25lO2ZsZXg6bm9uZX07LS1sYXlvdXQtZmxleDp7LW1zLWZsZXg6MSAxIC4wMDAwMDAwMDFweDstd2Via2l0LWZsZXg6MTtmbGV4OjE7LXdlYmtpdC1mbGV4LWJhc2lzOi4wMDAwMDAwMDFweDtmbGV4LWJhc2lzOi4wMDAwMDAwMDFweH07LS1sYXlvdXQtZmxleC0yOnstbXMtZmxleDoyOy13ZWJraXQtZmxleDoyO2ZsZXg6Mn07LS1sYXlvdXQtZmxleC0zOnstbXMtZmxleDozOy13ZWJraXQtZmxleDozO2ZsZXg6M307LS1sYXlvdXQtZmxleC00OnstbXMtZmxleDo0Oy13ZWJraXQtZmxleDo0O2ZsZXg6NH07LS1sYXlvdXQtZmxleC01OnstbXMtZmxleDo1Oy13ZWJraXQtZmxleDo1O2ZsZXg6NX07LS1sYXlvdXQtZmxleC02OnstbXMtZmxleDo2Oy13ZWJraXQtZmxleDo2O2ZsZXg6Nn07LS1sYXlvdXQtZmxleC03OnstbXMtZmxleDo3Oy13ZWJraXQtZmxleDo3O2ZsZXg6N307LS1sYXlvdXQtZmxleC04OnstbXMtZmxleDo4Oy13ZWJraXQtZmxleDo4O2ZsZXg6OH07LS1sYXlvdXQtZmxleC05OnstbXMtZmxleDo5Oy13ZWJraXQtZmxleDo5O2ZsZXg6OX07LS1sYXlvdXQtZmxleC0xMDp7LW1zLWZsZXg6MTA7LXdlYmtpdC1mbGV4OjEwO2ZsZXg6MTB9Oy0tbGF5b3V0LWZsZXgtMTE6ey1tcy1mbGV4OjExOy13ZWJraXQtZmxleDoxMTtmbGV4OjExfTstLWxheW91dC1mbGV4LTEyOnstbXMtZmxleDoxMjstd2Via2l0LWZsZXg6MTI7ZmxleDoxMn07LS1sYXlvdXQtc3RhcnQ6ey1tcy1mbGV4LWFsaWduOnN0YXJ0Oy13ZWJraXQtYWxpZ24taXRlbXM6ZmxleC1zdGFydDthbGlnbi1pdGVtczpmbGV4LXN0YXJ0fTstLWxheW91dC1jZW50ZXI6ey1tcy1mbGV4LWFsaWduOmNlbnRlcjstd2Via2l0LWFsaWduLWl0ZW1zOmNlbnRlcjthbGlnbi1pdGVtczpjZW50ZXJ9Oy0tbGF5b3V0LWVuZDp7LW1zLWZsZXgtYWxpZ246ZW5kOy13ZWJraXQtYWxpZ24taXRlbXM6ZmxleC1lbmQ7YWxpZ24taXRlbXM6ZmxleC1lbmR9Oy0tbGF5b3V0LWJhc2VsaW5lOnstbXMtZmxleC1hbGlnbjpiYXNlbGluZTstd2Via2l0LWFsaWduLWl0ZW1zOmJhc2VsaW5lO2FsaWduLWl0ZW1zOmJhc2VsaW5lfTstLWxheW91dC1zdGFydC1qdXN0aWZpZWQ6ey1tcy1mbGV4LXBhY2s6c3RhcnQ7LXdlYmtpdC1qdXN0aWZ5LWNvbnRlbnQ6ZmxleC1zdGFydDtqdXN0aWZ5LWNvbnRlbnQ6ZmxleC1zdGFydH07LS1sYXlvdXQtY2VudGVyLWp1c3RpZmllZDp7LW1zLWZsZXgtcGFjazpjZW50ZXI7LXdlYmtpdC1qdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyO2p1c3RpZnktY29udGVudDpjZW50ZXJ9Oy0tbGF5b3V0LWVuZC1qdXN0aWZpZWQ6ey1tcy1mbGV4LXBhY2s6ZW5kOy13ZWJraXQtanVzdGlmeS1jb250ZW50OmZsZXgtZW5kO2p1c3RpZnktY29udGVudDpmbGV4LWVuZH07LS1sYXlvdXQtYXJvdW5kLWp1c3RpZmllZDp7LW1zLWZsZXgtcGFjazpkaXN0cmlidXRlOy13ZWJraXQtanVzdGlmeS1jb250ZW50OnNwYWNlLWFyb3VuZDtqdXN0aWZ5LWNvbnRlbnQ6c3BhY2UtYXJvdW5kfTstLWxheW91dC1qdXN0aWZpZWQ6ey1tcy1mbGV4LXBhY2s6anVzdGlmeTstd2Via2l0LWp1c3RpZnktY29udGVudDpzcGFjZS1iZXR3ZWVuO2p1c3RpZnktY29udGVudDpzcGFjZS1iZXR3ZWVufTstLWxheW91dC1jZW50ZXItY2VudGVyOntAYXBwbHkgLS1sYXlvdXQtY2VudGVyO0BhcHBseSAtLWxheW91dC1jZW50ZXItanVzdGlmaWVkO307LS1sYXlvdXQtc2VsZi1zdGFydDp7LW1zLWFsaWduLXNlbGY6ZmxleC1zdGFydDstd2Via2l0LWFsaWduLXNlbGY6ZmxleC1zdGFydDthbGlnbi1zZWxmOmZsZXgtc3RhcnR9Oy0tbGF5b3V0LXNlbGYtY2VudGVyOnstbXMtYWxpZ24tc2VsZjpjZW50ZXI7LXdlYmtpdC1hbGlnbi1zZWxmOmNlbnRlcjthbGlnbi1zZWxmOmNlbnRlcn07LS1sYXlvdXQtc2VsZi1lbmQ6ey1tcy1hbGlnbi1zZWxmOmZsZXgtZW5kOy13ZWJraXQtYWxpZ24tc2VsZjpmbGV4LWVuZDthbGlnbi1zZWxmOmZsZXgtZW5kfTstLWxheW91dC1zZWxmLXN0cmV0Y2g6ey1tcy1hbGlnbi1zZWxmOnN0cmV0Y2g7LXdlYmtpdC1hbGlnbi1zZWxmOnN0cmV0Y2g7YWxpZ24tc2VsZjpzdHJldGNofTstLWxheW91dC1zZWxmLWJhc2VsaW5lOnstbXMtYWxpZ24tc2VsZjpiYXNlbGluZTstd2Via2l0LWFsaWduLXNlbGY6YmFzZWxpbmU7YWxpZ24tc2VsZjpiYXNlbGluZX07LS1sYXlvdXQtc3RhcnQtYWxpZ25lZDp7LW1zLWZsZXgtbGluZS1wYWNrOnN0YXJ0Oy1tcy1hbGlnbi1jb250ZW50OmZsZXgtc3RhcnQ7LXdlYmtpdC1hbGlnbi1jb250ZW50OmZsZXgtc3RhcnQ7YWxpZ24tY29udGVudDpmbGV4LXN0YXJ0fTstLWxheW91dC1lbmQtYWxpZ25lZDp7LW1zLWZsZXgtbGluZS1wYWNrOmVuZDstbXMtYWxpZ24tY29udGVudDpmbGV4LWVuZDstd2Via2l0LWFsaWduLWNvbnRlbnQ6ZmxleC1lbmQ7YWxpZ24tY29udGVudDpmbGV4LWVuZH07LS1sYXlvdXQtY2VudGVyLWFsaWduZWQ6ey1tcy1mbGV4LWxpbmUtcGFjazpjZW50ZXI7LW1zLWFsaWduLWNvbnRlbnQ6Y2VudGVyOy13ZWJraXQtYWxpZ24tY29udGVudDpjZW50ZXI7YWxpZ24tY29udGVudDpjZW50ZXJ9Oy0tbGF5b3V0LWJldHdlZW4tYWxpZ25lZDp7LW1zLWZsZXgtbGluZS1wYWNrOmp1c3RpZnk7LW1zLWFsaWduLWNvbnRlbnQ6c3BhY2UtYmV0d2Vlbjstd2Via2l0LWFsaWduLWNvbnRlbnQ6c3BhY2UtYmV0d2VlbjthbGlnbi1jb250ZW50OnNwYWNlLWJldHdlZW59Oy0tbGF5b3V0LWFyb3VuZC1hbGlnbmVkOnstbXMtZmxleC1saW5lLXBhY2s6ZGlzdHJpYnV0ZTstbXMtYWxpZ24tY29udGVudDpzcGFjZS1hcm91bmQ7LXdlYmtpdC1hbGlnbi1jb250ZW50OnNwYWNlLWFyb3VuZDthbGlnbi1jb250ZW50OnNwYWNlLWFyb3VuZH07LS1sYXlvdXQtYmxvY2s6e2Rpc3BsYXk6YmxvY2t9Oy0tbGF5b3V0LWludmlzaWJsZTp7dmlzaWJpbGl0eTpoaWRkZW4haW1wb3J0YW50fTstLWxheW91dC1yZWxhdGl2ZTp7cG9zaXRpb246cmVsYXRpdmV9Oy0tbGF5b3V0LWZpdDp7cG9zaXRpb246YWJzb2x1dGU7dG9wOjA7cmlnaHQ6MDtib3R0b206MDtsZWZ0OjB9Oy0tbGF5b3V0LXNjcm9sbDp7LXdlYmtpdC1vdmVyZmxvdy1zY3JvbGxpbmc6dG91Y2g7b3ZlcmZsb3c6YXV0b307LS1sYXlvdXQtZnVsbGJsZWVkOnttYXJnaW46MDtoZWlnaHQ6MTAwdmh9Oy0tbGF5b3V0LWZpeGVkLXRvcDp7cG9zaXRpb246Zml4ZWQ7dG9wOjA7bGVmdDowO3JpZ2h0OjB9Oy0tbGF5b3V0LWZpeGVkLXJpZ2h0Ontwb3NpdGlvbjpmaXhlZDt0b3A6MDtyaWdodDowO2JvdHRvbTowfTstLWxheW91dC1maXhlZC1ib3R0b206e3Bvc2l0aW9uOmZpeGVkO3JpZ2h0OjA7Ym90dG9tOjA7bGVmdDowfTstLWxheW91dC1maXhlZC1sZWZ0Ontwb3NpdGlvbjpmaXhlZDt0b3A6MDtib3R0b206MDtsZWZ0OjB9O308L3N0eWxlPiA8L2N1c3RvbS1zdHlsZT5cIik7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL2lyb24tZmxleC1sYXlvdXQvaXJvbi1mbGV4LWxheW91dC5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cImxpYi9taXhpbnMvZWxlbWVudC1taXhpbi5odG1sXCI+XG48c2NyaXB0PlxuKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLyoqXG4gICAqIEJhc2UgY2xhc3MgdGhhdCBwcm92aWRlcyB0aGUgY29yZSBBUEkgZm9yIFBvbHltZXIncyBtZXRhLXByb2dyYW1taW5nXG4gICAqIGZlYXR1cmVzIGluY2x1ZGluZyB0ZW1wbGF0ZSBzdGFtcGluZywgZGF0YS1iaW5kaW5nLCBhdHRyaWJ1dGUgZGVzZXJpYWxpemF0aW9uLFxuICAgKiBhbmQgcHJvcGVydHkgY2hhbmdlIG9ic2VydmF0aW9uLlxuICAgKlxuICAgKiBAY3VzdG9tRWxlbWVudFxuICAgKiBAcG9seW1lclxuICAgKiBAbWVtYmVyb2YgUG9seW1lclxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQGltcGxlbWVudHMge1BvbHltZXJfRWxlbWVudE1peGlufVxuICAgKiBAZXh0ZW5kcyBIVE1MRWxlbWVudFxuICAgKiBAYXBwbGllc01peGluIFBvbHltZXIuRWxlbWVudE1peGluXG4gICAqIEBzdW1tYXJ5IEN1c3RvbSBlbGVtZW50IGJhc2UgY2xhc3MgdGhhdCBwcm92aWRlcyB0aGUgY29yZSBBUEkgZm9yIFBvbHltZXInc1xuICAgKiAgIGtleSBtZXRhLXByb2dyYW1taW5nIGZlYXR1cmVzIGluY2x1ZGluZyB0ZW1wbGF0ZSBzdGFtcGluZywgZGF0YS1iaW5kaW5nLFxuICAgKiAgIGF0dHJpYnV0ZSBkZXNlcmlhbGl6YXRpb24sIGFuZCBwcm9wZXJ0eSBjaGFuZ2Ugb2JzZXJ2YXRpb25cbiAgICovXG4gIGNvbnN0IEVsZW1lbnQgPSBQb2x5bWVyLkVsZW1lbnRNaXhpbihIVE1MRWxlbWVudCk7XG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQGltcGxlbWVudHMge1BvbHltZXJfRWxlbWVudE1peGlufVxuICAgKiBAZXh0ZW5kcyB7SFRNTEVsZW1lbnR9XG4gICAqL1xuICBQb2x5bWVyLkVsZW1lbnQgPSBFbGVtZW50O1xufSkoKTtcbjwvc2NyaXB0PlxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9wb2x5bWVyLWVsZW1lbnQuaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCJib290Lmh0bWxcIj5cblxuPHNjcmlwdD5cblxuICAoZnVuY3Rpb24oKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgbGV0IENTU19VUkxfUlggPSAvKHVybFxcKCkoW14pXSopKFxcKSkvZztcbiAgICBsZXQgQUJTX1VSTCA9IC8oXlxcLyl8KF4jKXwoXltcXHctXFxkXSo6KS87XG4gICAgbGV0IHdvcmtpbmdVUkw7XG4gICAgbGV0IHJlc29sdmVEb2M7XG4gICAgLyoqXG4gICAgICogUmVzb2x2ZXMgdGhlIGdpdmVuIFVSTCBhZ2FpbnN0IHRoZSBwcm92aWRlZCBgYmFzZVVyaScuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgUG9seW1lci5SZXNvbHZlVXJsXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVybCBJbnB1dCBVUkwgdG8gcmVzb2x2ZVxuICAgICAqIEBwYXJhbSB7P3N0cmluZz19IGJhc2VVUkkgQmFzZSBVUkkgdG8gcmVzb2x2ZSB0aGUgVVJMIGFnYWluc3RcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IHJlc29sdmVkIFVSTFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlc29sdmVVcmwodXJsLCBiYXNlVVJJKSB7XG4gICAgICBpZiAodXJsICYmIEFCU19VUkwudGVzdCh1cmwpKSB7XG4gICAgICAgIHJldHVybiB1cmw7XG4gICAgICB9XG4gICAgICAvLyBMYXp5IGZlYXR1cmUgZGV0ZWN0aW9uLlxuICAgICAgaWYgKHdvcmtpbmdVUkwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB3b3JraW5nVVJMID0gZmFsc2U7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgdSA9IG5ldyBVUkwoJ2InLCAnaHR0cDovL2EnKTtcbiAgICAgICAgICB1LnBhdGhuYW1lID0gJ2MlMjBkJztcbiAgICAgICAgICB3b3JraW5nVVJMID0gKHUuaHJlZiA9PT0gJ2h0dHA6Ly9hL2MlMjBkJyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAvLyBzaWxlbnRseSBmYWlsXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghYmFzZVVSSSkge1xuICAgICAgICBiYXNlVVJJID0gZG9jdW1lbnQuYmFzZVVSSSB8fCB3aW5kb3cubG9jYXRpb24uaHJlZjtcbiAgICAgIH1cbiAgICAgIGlmICh3b3JraW5nVVJMKSB7XG4gICAgICAgIHJldHVybiAobmV3IFVSTCh1cmwsIGJhc2VVUkkpKS5ocmVmO1xuICAgICAgfVxuICAgICAgLy8gRmFsbGJhY2sgdG8gY3JlYXRpbmcgYW4gYW5jaG9yIGludG8gYSBkaXNjb25uZWN0ZWQgZG9jdW1lbnQuXG4gICAgICBpZiAoIXJlc29sdmVEb2MpIHtcbiAgICAgICAgcmVzb2x2ZURvYyA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudCgndGVtcCcpO1xuICAgICAgICByZXNvbHZlRG9jLmJhc2UgPSByZXNvbHZlRG9jLmNyZWF0ZUVsZW1lbnQoJ2Jhc2UnKTtcbiAgICAgICAgcmVzb2x2ZURvYy5oZWFkLmFwcGVuZENoaWxkKHJlc29sdmVEb2MuYmFzZSk7XG4gICAgICAgIHJlc29sdmVEb2MuYW5jaG9yID0gcmVzb2x2ZURvYy5jcmVhdGVFbGVtZW50KCdhJyk7XG4gICAgICAgIHJlc29sdmVEb2MuYm9keS5hcHBlbmRDaGlsZChyZXNvbHZlRG9jLmFuY2hvcik7XG4gICAgICB9XG4gICAgICByZXNvbHZlRG9jLmJhc2UuaHJlZiA9IGJhc2VVUkk7XG4gICAgICByZXNvbHZlRG9jLmFuY2hvci5ocmVmID0gdXJsO1xuICAgICAgcmV0dXJuIHJlc29sdmVEb2MuYW5jaG9yLmhyZWYgfHwgdXJsO1xuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVzb2x2ZXMgYW55IHJlbGF0aXZlIFVSTCdzIGluIHRoZSBnaXZlbiBDU1MgdGV4dCBhZ2FpbnN0IHRoZSBwcm92aWRlZFxuICAgICAqIGBvd25lckRvY3VtZW50YCdzIGBiYXNlVVJJYC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBQb2x5bWVyLlJlc29sdmVVcmxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY3NzVGV4dCBDU1MgdGV4dCB0byBwcm9jZXNzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGJhc2VVUkkgQmFzZSBVUkkgdG8gcmVzb2x2ZSB0aGUgVVJMIGFnYWluc3RcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFByb2Nlc3NlZCBDU1MgdGV4dCB3aXRoIHJlc29sdmVkIFVSTCdzXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVzb2x2ZUNzcyhjc3NUZXh0LCBiYXNlVVJJKSB7XG4gICAgICByZXR1cm4gY3NzVGV4dC5yZXBsYWNlKENTU19VUkxfUlgsIGZ1bmN0aW9uKG0sIHByZSwgdXJsLCBwb3N0KSB7XG4gICAgICAgIHJldHVybiBwcmUgKyAnXFwnJyArXG4gICAgICAgICAgcmVzb2x2ZVVybCh1cmwucmVwbGFjZSgvW1wiJ10vZywgJycpLCBiYXNlVVJJKSArXG4gICAgICAgICAgJ1xcJycgKyBwb3N0O1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHBhdGggZnJvbSBhIGdpdmVuIGB1cmxgLiBUaGUgcGF0aCBpbmNsdWRlcyB0aGUgdHJhaWxpbmdcbiAgICAgKiBgL2AgZnJvbSB0aGUgdXJsLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIFBvbHltZXIuUmVzb2x2ZVVybFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgSW5wdXQgVVJMIHRvIHRyYW5zZm9ybVxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gcmVzb2x2ZWQgcGF0aFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBhdGhGcm9tVXJsKHVybCkge1xuICAgICAgcmV0dXJuIHVybC5zdWJzdHJpbmcoMCwgdXJsLmxhc3RJbmRleE9mKCcvJykgKyAxKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNb2R1bGUgd2l0aCB1dGlsaXRpZXMgZm9yIHJlc29sdmluZyByZWxhdGl2ZSBVUkwncy5cbiAgICAgKlxuICAgICAqIEBuYW1lc3BhY2VcbiAgICAgKiBAbWVtYmVyb2YgUG9seW1lclxuICAgICAqIEBzdW1tYXJ5IE1vZHVsZSB3aXRoIHV0aWxpdGllcyBmb3IgcmVzb2x2aW5nIHJlbGF0aXZlIFVSTCdzLlxuICAgICAqL1xuICAgIFBvbHltZXIuUmVzb2x2ZVVybCA9IHtcbiAgICAgIHJlc29sdmVDc3M6IHJlc29sdmVDc3MsXG4gICAgICByZXNvbHZlVXJsOiByZXNvbHZlVXJsLFxuICAgICAgcGF0aEZyb21Vcmw6IHBhdGhGcm9tVXJsXG4gICAgfTtcblxuICB9KSgpO1xuXG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvdXRpbHMvcmVzb2x2ZS11cmwuaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCJib290Lmh0bWxcIj5cblxuPHNjcmlwdD5cbihmdW5jdGlvbigpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgLyoqIEB0eXBlZGVmIHt7cnVuOiBmdW5jdGlvbihmdW5jdGlvbigpLCBudW1iZXI9KTpudW1iZXIsIGNhbmNlbDogZnVuY3Rpb24obnVtYmVyKX19ICovXG4gIGxldCBBc3luY0ludGVyZmFjZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuXG4gIC8vIE1pY3JvdGFzayBpbXBsZW1lbnRlZCB1c2luZyBNdXRhdGlvbiBPYnNlcnZlclxuICBsZXQgbWljcm90YXNrQ3VyckhhbmRsZSA9IDA7XG4gIGxldCBtaWNyb3Rhc2tMYXN0SGFuZGxlID0gMDtcbiAgbGV0IG1pY3JvdGFza0NhbGxiYWNrcyA9IFtdO1xuICBsZXQgbWljcm90YXNrTm9kZUNvbnRlbnQgPSAwO1xuICBsZXQgbWljcm90YXNrTm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnKTtcbiAgbmV3IHdpbmRvdy5NdXRhdGlvbk9ic2VydmVyKG1pY3JvdGFza0ZsdXNoKS5vYnNlcnZlKG1pY3JvdGFza05vZGUsIHtjaGFyYWN0ZXJEYXRhOiB0cnVlfSk7XG5cbiAgZnVuY3Rpb24gbWljcm90YXNrRmx1c2goKSB7XG4gICAgY29uc3QgbGVuID0gbWljcm90YXNrQ2FsbGJhY2tzLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBsZXQgY2IgPSBtaWNyb3Rhc2tDYWxsYmFja3NbaV07XG4gICAgICBpZiAoY2IpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjYigpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7IHRocm93IGUgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgbWljcm90YXNrQ2FsbGJhY2tzLnNwbGljZSgwLCBsZW4pO1xuICAgIG1pY3JvdGFza0xhc3RIYW5kbGUgKz0gbGVuO1xuICB9XG5cbiAgLyoqXG4gICAqIE1vZHVsZSB0aGF0IHByb3ZpZGVzIGEgbnVtYmVyIG9mIHN0cmF0ZWdpZXMgZm9yIGVucXVldWluZyBhc3luY2hyb25vdXNcbiAgICogdGFza3MuICBFYWNoIHN1Yi1tb2R1bGUgcHJvdmlkZXMgYSBzdGFuZGFyZCBgcnVuKGZuKWAgaW50ZXJmYWNlIHRoYXQgcmV0dXJucyBhXG4gICAqIGhhbmRsZSwgYW5kIGEgYGNhbmNlbChoYW5kbGUpYCBpbnRlcmZhY2UgZm9yIGNhbmNlbGluZyBhc3luYyB0YXNrcyBiZWZvcmVcbiAgICogdGhleSBydW4uXG4gICAqXG4gICAqIEBuYW1lc3BhY2VcbiAgICogQG1lbWJlcm9mIFBvbHltZXJcbiAgICogQHN1bW1hcnkgTW9kdWxlIHRoYXQgcHJvdmlkZXMgYSBudW1iZXIgb2Ygc3RyYXRlZ2llcyBmb3IgZW5xdWV1aW5nIGFzeW5jaHJvbm91c1xuICAgKiB0YXNrcy5cbiAgICovXG4gIFBvbHltZXIuQXN5bmMgPSB7XG5cbiAgICAvKipcbiAgICAgKiBBc3luYyBpbnRlcmZhY2Ugd3JhcHBlciBhcm91bmQgYHNldFRpbWVvdXRgLlxuICAgICAqXG4gICAgICogQG5hbWVzcGFjZVxuICAgICAqIEBtZW1iZXJvZiBQb2x5bWVyLkFzeW5jXG4gICAgICogQHN1bW1hcnkgQXN5bmMgaW50ZXJmYWNlIHdyYXBwZXIgYXJvdW5kIGBzZXRUaW1lb3V0YC5cbiAgICAgKi9cbiAgICB0aW1lT3V0OiB7XG4gICAgICAvKipcbiAgICAgICAqIFJldHVybnMgYSBzdWItbW9kdWxlIHdpdGggdGhlIGFzeW5jIGludGVyZmFjZSBwcm92aWRpbmcgdGhlIHByb3ZpZGVkXG4gICAgICAgKiBkZWxheS5cbiAgICAgICAqXG4gICAgICAgKiBAbWVtYmVyb2YgUG9seW1lci5Bc3luYy50aW1lT3V0XG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0gZGVsYXkgVGltZSB0byB3YWl0IGJlZm9yZSBjYWxsaW5nIGNhbGxiYWNrcyBpbiBtc1xuICAgICAgICogQHJldHVybiB7QXN5bmNJbnRlcmZhY2V9IEFuIGFzeW5jIHRpbWVvdXQgaW50ZXJmYWNlXG4gICAgICAgKi9cbiAgICAgIGFmdGVyKGRlbGF5KSB7XG4gICAgICAgIHJldHVybiAge1xuICAgICAgICAgIHJ1bihmbikgeyByZXR1cm4gc2V0VGltZW91dChmbiwgZGVsYXkpIH0sXG4gICAgICAgICAgY2FuY2VsOiB3aW5kb3cuY2xlYXJUaW1lb3V0LmJpbmQod2luZG93KVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLyoqXG4gICAgICAgKiBFbnF1ZXVlcyBhIGZ1bmN0aW9uIGNhbGxlZCBpbiB0aGUgbmV4dCB0YXNrLlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJvZiBQb2x5bWVyLkFzeW5jLnRpbWVPdXRcbiAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIENhbGxiYWNrIHRvIHJ1blxuICAgICAgICogQHJldHVybiB7bnVtYmVyfSBIYW5kbGUgdXNlZCBmb3IgY2FuY2VsaW5nIHRhc2tcbiAgICAgICAqL1xuICAgICAgcnVuOiB3aW5kb3cuc2V0VGltZW91dC5iaW5kKHdpbmRvdyksXG4gICAgICAvKipcbiAgICAgICAqIENhbmNlbHMgYSBwcmV2aW91c2x5IGVucXVldWVkIGB0aW1lT3V0YCBjYWxsYmFjay5cbiAgICAgICAqXG4gICAgICAgKiBAbWVtYmVyb2YgUG9seW1lci5Bc3luYy50aW1lT3V0XG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0gaGFuZGxlIEhhbmRsZSByZXR1cm5lZCBmcm9tIGBydW5gIG9mIGNhbGxiYWNrIHRvIGNhbmNlbFxuICAgICAgICovXG4gICAgICBjYW5jZWw6IHdpbmRvdy5jbGVhclRpbWVvdXQuYmluZCh3aW5kb3cpXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFzeW5jIGludGVyZmFjZSB3cmFwcGVyIGFyb3VuZCBgcmVxdWVzdEFuaW1hdGlvbkZyYW1lYC5cbiAgICAgKlxuICAgICAqIEBuYW1lc3BhY2VcbiAgICAgKiBAbWVtYmVyb2YgUG9seW1lci5Bc3luY1xuICAgICAqIEBzdW1tYXJ5IEFzeW5jIGludGVyZmFjZSB3cmFwcGVyIGFyb3VuZCBgcmVxdWVzdEFuaW1hdGlvbkZyYW1lYC5cbiAgICAgKi9cbiAgICBhbmltYXRpb25GcmFtZToge1xuICAgICAgLyoqXG4gICAgICAgKiBFbnF1ZXVlcyBhIGZ1bmN0aW9uIGNhbGxlZCBhdCBgcmVxdWVzdEFuaW1hdGlvbkZyYW1lYCB0aW1pbmcuXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlcm9mIFBvbHltZXIuQXN5bmMuYW5pbWF0aW9uRnJhbWVcbiAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIENhbGxiYWNrIHRvIHJ1blxuICAgICAgICogQHJldHVybiB7bnVtYmVyfSBIYW5kbGUgdXNlZCBmb3IgY2FuY2VsaW5nIHRhc2tcbiAgICAgICAqL1xuICAgICAgcnVuOiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lLmJpbmQod2luZG93KSxcbiAgICAgIC8qKlxuICAgICAgICogQ2FuY2VscyBhIHByZXZpb3VzbHkgZW5xdWV1ZWQgYGFuaW1hdGlvbkZyYW1lYCBjYWxsYmFjay5cbiAgICAgICAqXG4gICAgICAgKiBAbWVtYmVyb2YgUG9seW1lci5Bc3luYy50aW1lT3V0XG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0gaGFuZGxlIEhhbmRsZSByZXR1cm5lZCBmcm9tIGBydW5gIG9mIGNhbGxiYWNrIHRvIGNhbmNlbFxuICAgICAgICovXG4gICAgICBjYW5jZWw6IHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZS5iaW5kKHdpbmRvdylcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQXN5bmMgaW50ZXJmYWNlIHdyYXBwZXIgYXJvdW5kIGByZXF1ZXN0SWRsZUNhbGxiYWNrYC4gIEZhbGxzIGJhY2sgdG9cbiAgICAgKiBgc2V0VGltZW91dGAgb24gYnJvd3NlcnMgdGhhdCBkbyBub3Qgc3VwcG9ydCBgcmVxdWVzdElkbGVDYWxsYmFja2AuXG4gICAgICpcbiAgICAgKiBAbmFtZXNwYWNlXG4gICAgICogQG1lbWJlcm9mIFBvbHltZXIuQXN5bmNcbiAgICAgKiBAc3VtbWFyeSBBc3luYyBpbnRlcmZhY2Ugd3JhcHBlciBhcm91bmQgYHJlcXVlc3RJZGxlQ2FsbGJhY2tgLlxuICAgICAqL1xuICAgIGlkbGVQZXJpb2Q6IHtcbiAgICAgIC8qKlxuICAgICAgICogRW5xdWV1ZXMgYSBmdW5jdGlvbiBjYWxsZWQgYXQgYHJlcXVlc3RJZGxlQ2FsbGJhY2tgIHRpbWluZy5cbiAgICAgICAqXG4gICAgICAgKiBAbWVtYmVyb2YgUG9seW1lci5Bc3luYy5pZGxlUGVyaW9kXG4gICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKElkbGVEZWFkbGluZSl9IGZuIENhbGxiYWNrIHRvIHJ1blxuICAgICAgICogQHJldHVybiB7bnVtYmVyfSBIYW5kbGUgdXNlZCBmb3IgY2FuY2VsaW5nIHRhc2tcbiAgICAgICAqL1xuICAgICAgcnVuKGZuKSB7XG4gICAgICAgIHJldHVybiB3aW5kb3cucmVxdWVzdElkbGVDYWxsYmFjayA/XG4gICAgICAgICAgd2luZG93LnJlcXVlc3RJZGxlQ2FsbGJhY2soZm4pIDpcbiAgICAgICAgICB3aW5kb3cuc2V0VGltZW91dChmbiwgMTYpO1xuICAgICAgfSxcbiAgICAgIC8qKlxuICAgICAgICogQ2FuY2VscyBhIHByZXZpb3VzbHkgZW5xdWV1ZWQgYGlkbGVQZXJpb2RgIGNhbGxiYWNrLlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJvZiBQb2x5bWVyLkFzeW5jLmlkbGVQZXJpb2RcbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoYW5kbGUgSGFuZGxlIHJldHVybmVkIGZyb20gYHJ1bmAgb2YgY2FsbGJhY2sgdG8gY2FuY2VsXG4gICAgICAgKi9cbiAgICAgIGNhbmNlbChoYW5kbGUpIHtcbiAgICAgICAgd2luZG93LmNhbmNlbElkbGVDYWxsYmFjayA/XG4gICAgICAgICAgd2luZG93LmNhbmNlbElkbGVDYWxsYmFjayhoYW5kbGUpIDpcbiAgICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KGhhbmRsZSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFzeW5jIGludGVyZmFjZSBmb3IgZW5xdWV1ZWluZyBjYWxsYmFja3MgdGhhdCBydW4gYXQgbWljcm90YXNrIHRpbWluZy5cbiAgICAgKlxuICAgICAqIE5vdGUgdGhhdCBtaWNyb3Rhc2sgdGltaW5nIGlzIGFjaGlldmVkIHZpYSBhIHNpbmdsZSBgTXV0YXRpb25PYnNlcnZlcmAsXG4gICAgICogYW5kIHRodXMgY2FsbGJhY2tzIGVucXVldWVkIHdpdGggdGhpcyBBUEkgd2lsbCBhbGwgcnVuIGluIGEgc2luZ2xlXG4gICAgICogYmF0Y2gsIGFuZCBub3QgaW50ZXJsZWF2ZWQgd2l0aCBvdGhlciBtaWNyb3Rhc2tzIHN1Y2ggYXMgcHJvbWlzZXMuXG4gICAgICogUHJvbWlzZXMgYXJlIGF2b2lkZWQgYXMgYW4gaW1wbGVtZW50YXRpb24gY2hvaWNlIGZvciB0aGUgdGltZSBiZWluZ1xuICAgICAqIGR1ZSB0byBTYWZhcmkgYnVncyB0aGF0IGNhdXNlIFByb21pc2VzIHRvIGxhY2sgbWljcm90YXNrIGd1YXJhbnRlZXMuXG4gICAgICpcbiAgICAgKiBAbmFtZXNwYWNlXG4gICAgICogQG1lbWJlcm9mIFBvbHltZXIuQXN5bmNcbiAgICAgKiBAc3VtbWFyeSBBc3luYyBpbnRlcmZhY2UgZm9yIGVucXVldWVpbmcgY2FsbGJhY2tzIHRoYXQgcnVuIGF0IG1pY3JvdGFza1xuICAgICAqICAgdGltaW5nLlxuICAgICAqL1xuICAgIG1pY3JvVGFzazoge1xuXG4gICAgICAvKipcbiAgICAgICAqIEVucXVldWVzIGEgZnVuY3Rpb24gY2FsbGVkIGF0IG1pY3JvdGFzayB0aW1pbmcuXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlcm9mIFBvbHltZXIuQXN5bmMubWljcm9UYXNrXG4gICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayB0byBydW5cbiAgICAgICAqIEByZXR1cm4ge251bWJlcn0gSGFuZGxlIHVzZWQgZm9yIGNhbmNlbGluZyB0YXNrXG4gICAgICAgKi9cbiAgICAgIHJ1bihjYWxsYmFjaykge1xuICAgICAgICBtaWNyb3Rhc2tOb2RlLnRleHRDb250ZW50ID0gbWljcm90YXNrTm9kZUNvbnRlbnQrKztcbiAgICAgICAgbWljcm90YXNrQ2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICAgICAgICByZXR1cm4gbWljcm90YXNrQ3VyckhhbmRsZSsrO1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBDYW5jZWxzIGEgcHJldmlvdXNseSBlbnF1ZXVlZCBgbWljcm9UYXNrYCBjYWxsYmFjay5cbiAgICAgICAqXG4gICAgICAgKiBAbWVtYmVyb2YgUG9seW1lci5Bc3luYy5taWNyb1Rhc2tcbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoYW5kbGUgSGFuZGxlIHJldHVybmVkIGZyb20gYHJ1bmAgb2YgY2FsbGJhY2sgdG8gY2FuY2VsXG4gICAgICAgKi9cbiAgICAgIGNhbmNlbChoYW5kbGUpIHtcbiAgICAgICAgY29uc3QgaWR4ID0gaGFuZGxlIC0gbWljcm90YXNrTGFzdEhhbmRsZTtcbiAgICAgICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICAgICAgaWYgKCFtaWNyb3Rhc2tDYWxsYmFja3NbaWR4XSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFzeW5jIGhhbmRsZTogJyArIGhhbmRsZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG1pY3JvdGFza0NhbGxiYWNrc1tpZHhdID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgfVxuICB9O1xuXG59KSgpO1xuPC9zY3JpcHQ+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL3BvbHltZXIvbGliL3V0aWxzL2FzeW5jLmh0bWwiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi91dGlscy9taXhpbi5odG1sXCI+XG5cbjxzY3JpcHQ+XG4oZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvLyBDb21tb24gaW1wbGVtZW50YXRpb24gZm9yIG1peGluICYgYmVoYXZpb3JcbiAgZnVuY3Rpb24gbXV0YWJsZVByb3BlcnR5Q2hhbmdlKGluc3QsIHByb3BlcnR5LCB2YWx1ZSwgb2xkLCBtdXRhYmxlRGF0YSkge1xuICAgIGxldCBpc09iamVjdDtcbiAgICBpZiAobXV0YWJsZURhdGEpIHtcbiAgICAgIGlzT2JqZWN0ID0gKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGwpO1xuICAgICAgLy8gUHVsbCBgb2xkYCBmb3IgT2JqZWN0cyBmcm9tIHRlbXAgY2FjaGUsIGJ1dCB0cmVhdCBgbnVsbGAgYXMgYSBwcmltaXRpdmVcbiAgICAgIGlmIChpc09iamVjdCkge1xuICAgICAgICBvbGQgPSBpbnN0Ll9fZGF0YVRlbXBbcHJvcGVydHldO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBTdHJpY3QgZXF1YWxpdHkgY2hlY2ssIGJ1dCByZXR1cm4gZmFsc2UgZm9yIE5hTj09PU5hTlxuICAgIGxldCBzaG91bGRDaGFuZ2UgPSAob2xkICE9PSB2YWx1ZSAmJiAob2xkID09PSBvbGQgfHwgdmFsdWUgPT09IHZhbHVlKSk7XG4gICAgLy8gT2JqZWN0cyBhcmUgc3RvcmVkIGluIHRlbXBvcmFyeSBjYWNoZSAoY2xlYXJlZCBhdCBlbmQgb2ZcbiAgICAvLyB0dXJuKSwgd2hpY2ggaXMgdXNlZCBmb3IgZGlydHktY2hlY2tpbmdcbiAgICBpZiAoaXNPYmplY3QgJiYgc2hvdWxkQ2hhbmdlKSB7XG4gICAgICBpbnN0Ll9fZGF0YVRlbXBbcHJvcGVydHldID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBzaG91bGRDaGFuZ2U7XG4gIH1cblxuICAvKipcbiAgICogRWxlbWVudCBjbGFzcyBtaXhpbiB0byBza2lwIHN0cmljdCBkaXJ0eS1jaGVja2luZyBmb3Igb2JqZWN0cyBhbmQgYXJyYXlzXG4gICAqIChhbHdheXMgY29uc2lkZXIgdGhlbSB0byBiZSBcImRpcnR5XCIpLCBmb3IgdXNlIG9uIGVsZW1lbnRzIHV0aWxpemluZ1xuICAgKiBgUG9seW1lci5Qcm9wZXJ0eUVmZmVjdHNgXG4gICAqXG4gICAqIEJ5IGRlZmF1bHQsIGBQb2x5bWVyLlByb3BlcnR5RWZmZWN0c2AgcGVyZm9ybXMgc3RyaWN0IGRpcnR5IGNoZWNraW5nIG9uXG4gICAqIG9iamVjdHMsIHdoaWNoIG1lYW5zIHRoYXQgYW55IGRlZXAgbW9kaWZpY2F0aW9ucyB0byBhbiBvYmplY3Qgb3IgYXJyYXkgd2lsbFxuICAgKiBub3QgYmUgcHJvcGFnYXRlZCB1bmxlc3MgXCJpbW11dGFibGVcIiBkYXRhIHBhdHRlcm5zIGFyZSB1c2VkIChpLmUuIGFsbCBvYmplY3RcbiAgICogcmVmZXJlbmNlcyBmcm9tIHRoZSByb290IHRvIHRoZSBtdXRhdGlvbiB3ZXJlIGNoYW5nZWQpLlxuICAgKlxuICAgKiBQb2x5bWVyIGFsc28gcHJvdmlkZXMgYSBwcm9wcmlldGFyeSBkYXRhIG11dGF0aW9uIGFuZCBwYXRoIG5vdGlmaWNhdGlvbiBBUElcbiAgICogKGUuZy4gYG5vdGlmeVBhdGhgLCBgc2V0YCwgYW5kIGFycmF5IG11dGF0aW9uIEFQSSdzKSB0aGF0IGFsbG93IGVmZmljaWVudFxuICAgKiBtdXRhdGlvbiBhbmQgbm90aWZpY2F0aW9uIG9mIGRlZXAgY2hhbmdlcyBpbiBhbiBvYmplY3QgZ3JhcGggdG8gYWxsIGVsZW1lbnRzXG4gICAqIGJvdW5kIHRvIHRoZSBzYW1lIG9iamVjdCBncmFwaC5cbiAgICpcbiAgICogSW4gY2FzZXMgd2hlcmUgbmVpdGhlciBpbW11dGFibGUgcGF0dGVybnMgbm9yIHRoZSBkYXRhIG11dGF0aW9uIEFQSSBjYW4gYmVcbiAgICogdXNlZCwgYXBwbHlpbmcgdGhpcyBtaXhpbiB3aWxsIGNhdXNlIFBvbHltZXIgdG8gc2tpcCBkaXJ0eSBjaGVja2luZyBmb3JcbiAgICogb2JqZWN0cyBhbmQgYXJyYXlzIChhbHdheXMgY29uc2lkZXIgdGhlbSB0byBiZSBcImRpcnR5XCIpLiAgVGhpcyBhbGxvd3MgYVxuICAgKiB1c2VyIHRvIG1ha2UgYSBkZWVwIG1vZGlmaWNhdGlvbiB0byBhIGJvdW5kIG9iamVjdCBncmFwaCwgYW5kIHRoZW4gZWl0aGVyXG4gICAqIHNpbXBseSByZS1zZXQgdGhlIG9iamVjdCAoZS5nLiBgdGhpcy5pdGVtcyA9IHRoaXMuaXRlbXNgKSBvciBjYWxsIGBub3RpZnlQYXRoYFxuICAgKiAoZS5nLiBgdGhpcy5ub3RpZnlQYXRoKCdpdGVtcycpYCkgdG8gdXBkYXRlIHRoZSB0cmVlLiAgTm90ZSB0aGF0IGFsbFxuICAgKiBlbGVtZW50cyB0aGF0IHdpc2ggdG8gYmUgdXBkYXRlZCBiYXNlZCBvbiBkZWVwIG11dGF0aW9ucyBtdXN0IGFwcGx5IHRoaXNcbiAgICogbWl4aW4gb3Igb3RoZXJ3aXNlIHNraXAgc3RyaWN0IGRpcnR5IGNoZWNraW5nIGZvciBvYmplY3RzL2FycmF5cy5cbiAgICpcbiAgICogSW4gb3JkZXIgdG8gbWFrZSB0aGUgZGlydHkgY2hlY2sgc3RyYXRlZ3kgY29uZmlndXJhYmxlLCBzZWVcbiAgICogYFBvbHltZXIuT3B0aW9uYWxNdXRhYmxlRGF0YWAuXG4gICAqXG4gICAqIE5vdGUsIHRoZSBwZXJmb3JtYW5jZSBjaGFyYWN0ZXJpc3RpY3Mgb2YgcHJvcGFnYXRpbmcgbGFyZ2Ugb2JqZWN0IGdyYXBoc1xuICAgKiB3aWxsIGJlIHdvcnNlIGFzIG9wcG9zZWQgdG8gdXNpbmcgc3RyaWN0IGRpcnR5IGNoZWNraW5nIHdpdGggaW1tdXRhYmxlXG4gICAqIHBhdHRlcm5zIG9yIFBvbHltZXIncyBwYXRoIG5vdGlmaWNhdGlvbiBBUEkuXG4gICAqXG4gICAqIEBtaXhpbkZ1bmN0aW9uXG4gICAqIEBwb2x5bWVyXG4gICAqIEBtZW1iZXJvZiBQb2x5bWVyXG4gICAqIEBzdW1tYXJ5IEVsZW1lbnQgY2xhc3MgbWl4aW4gdG8gc2tpcCBzdHJpY3QgZGlydHktY2hlY2tpbmcgZm9yIG9iamVjdHNcbiAgICogICBhbmQgYXJyYXlzXG4gICAqL1xuICBQb2x5bWVyLk11dGFibGVEYXRhID0gUG9seW1lci5kZWR1cGluZ01peGluKHN1cGVyQ2xhc3MgPT4ge1xuXG4gICAgLyoqXG4gICAgICogQHBvbHltZXJcbiAgICAgKiBAbWl4aW5DbGFzc1xuICAgICAqIEBpbXBsZW1lbnRzIHtQb2x5bWVyX011dGFibGVEYXRhfVxuICAgICAqL1xuICAgIGNsYXNzIE11dGFibGVEYXRhIGV4dGVuZHMgc3VwZXJDbGFzcyB7XG4gICAgICAvKipcbiAgICAgICAqIE92ZXJyaWRlcyBgUG9seW1lci5Qcm9wZXJ0eUVmZmVjdHNgIHRvIHByb3ZpZGUgb3B0aW9uIGZvciBza2lwcGluZ1xuICAgICAgICogc3RyaWN0IGVxdWFsaXR5IGNoZWNraW5nIGZvciBPYmplY3RzIGFuZCBBcnJheXMuXG4gICAgICAgKlxuICAgICAgICogVGhpcyBtZXRob2QgcHVsbHMgdGhlIHZhbHVlIHRvIGRpcnR5IGNoZWNrIGFnYWluc3QgZnJvbSB0aGUgYF9fZGF0YVRlbXBgXG4gICAgICAgKiBjYWNoZSAocmF0aGVyIHRoYW4gdGhlIG5vcm1hbCBgX19kYXRhYCBjYWNoZSkgZm9yIE9iamVjdHMuICBTaW5jZSB0aGUgdGVtcFxuICAgICAgICogY2FjaGUgaXMgY2xlYXJlZCBhdCB0aGUgZW5kIG9mIGEgdHVybiwgdGhpcyBpbXBsZW1lbnRhdGlvbiBhbGxvd3NcbiAgICAgICAqIHNpZGUtZWZmZWN0cyBvZiBkZWVwIG9iamVjdCBjaGFuZ2VzIHRvIGJlIHByb2Nlc3NlZCBieSByZS1zZXR0aW5nIHRoZVxuICAgICAgICogc2FtZSBvYmplY3QgKHVzaW5nIHRoZSB0ZW1wIGNhY2hlIGFzIGFuIGluLXR1cm4gYmFja3N0b3AgdG8gcHJldmVudFxuICAgICAgICogY3ljbGVzIGR1ZSB0byAyLXdheSBub3RpZmljYXRpb24pLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSBuYW1lXG4gICAgICAgKiBAcGFyYW0geyp9IHZhbHVlIE5ldyBwcm9wZXJ0eSB2YWx1ZVxuICAgICAgICogQHBhcmFtIHsqfSBvbGQgUHJldmlvdXMgcHJvcGVydHkgdmFsdWVcbiAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIHByb3BlcnR5IHNob3VsZCBiZSBjb25zaWRlcmVkIGEgY2hhbmdlXG4gICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgKi9cbiAgICAgIF9zaG91bGRQcm9wZXJ0eUNoYW5nZShwcm9wZXJ0eSwgdmFsdWUsIG9sZCkge1xuICAgICAgICByZXR1cm4gbXV0YWJsZVByb3BlcnR5Q2hhbmdlKHRoaXMsIHByb3BlcnR5LCB2YWx1ZSwgb2xkLCB0cnVlKTtcbiAgICAgIH1cblxuICAgIH1cbiAgICAvKiogQHR5cGUge2Jvb2xlYW59ICovXG4gICAgTXV0YWJsZURhdGEucHJvdG90eXBlLm11dGFibGVEYXRhID0gZmFsc2U7XG5cbiAgICByZXR1cm4gTXV0YWJsZURhdGE7XG5cbiAgfSk7XG5cblxuICAvKipcbiAgICogRWxlbWVudCBjbGFzcyBtaXhpbiB0byBhZGQgdGhlIG9wdGlvbmFsIGFiaWxpdHkgdG8gc2tpcCBzdHJpY3RcbiAgICogZGlydHktY2hlY2tpbmcgZm9yIG9iamVjdHMgYW5kIGFycmF5cyAoYWx3YXlzIGNvbnNpZGVyIHRoZW0gdG8gYmVcbiAgICogXCJkaXJ0eVwiKSBieSBzZXR0aW5nIGEgYG11dGFibGUtZGF0YWAgYXR0cmlidXRlIG9uIGFuIGVsZW1lbnQgaW5zdGFuY2UuXG4gICAqXG4gICAqIEJ5IGRlZmF1bHQsIGBQb2x5bWVyLlByb3BlcnR5RWZmZWN0c2AgcGVyZm9ybXMgc3RyaWN0IGRpcnR5IGNoZWNraW5nIG9uXG4gICAqIG9iamVjdHMsIHdoaWNoIG1lYW5zIHRoYXQgYW55IGRlZXAgbW9kaWZpY2F0aW9ucyB0byBhbiBvYmplY3Qgb3IgYXJyYXkgd2lsbFxuICAgKiBub3QgYmUgcHJvcGFnYXRlZCB1bmxlc3MgXCJpbW11dGFibGVcIiBkYXRhIHBhdHRlcm5zIGFyZSB1c2VkIChpLmUuIGFsbCBvYmplY3RcbiAgICogcmVmZXJlbmNlcyBmcm9tIHRoZSByb290IHRvIHRoZSBtdXRhdGlvbiB3ZXJlIGNoYW5nZWQpLlxuICAgKlxuICAgKiBQb2x5bWVyIGFsc28gcHJvdmlkZXMgYSBwcm9wcmlldGFyeSBkYXRhIG11dGF0aW9uIGFuZCBwYXRoIG5vdGlmaWNhdGlvbiBBUElcbiAgICogKGUuZy4gYG5vdGlmeVBhdGhgLCBgc2V0YCwgYW5kIGFycmF5IG11dGF0aW9uIEFQSSdzKSB0aGF0IGFsbG93IGVmZmljaWVudFxuICAgKiBtdXRhdGlvbiBhbmQgbm90aWZpY2F0aW9uIG9mIGRlZXAgY2hhbmdlcyBpbiBhbiBvYmplY3QgZ3JhcGggdG8gYWxsIGVsZW1lbnRzXG4gICAqIGJvdW5kIHRvIHRoZSBzYW1lIG9iamVjdCBncmFwaC5cbiAgICpcbiAgICogSW4gY2FzZXMgd2hlcmUgbmVpdGhlciBpbW11dGFibGUgcGF0dGVybnMgbm9yIHRoZSBkYXRhIG11dGF0aW9uIEFQSSBjYW4gYmVcbiAgICogdXNlZCwgYXBwbHlpbmcgdGhpcyBtaXhpbiB3aWxsIGFsbG93IFBvbHltZXIgdG8gc2tpcCBkaXJ0eSBjaGVja2luZyBmb3JcbiAgICogb2JqZWN0cyBhbmQgYXJyYXlzIChhbHdheXMgY29uc2lkZXIgdGhlbSB0byBiZSBcImRpcnR5XCIpLiAgVGhpcyBhbGxvd3MgYVxuICAgKiB1c2VyIHRvIG1ha2UgYSBkZWVwIG1vZGlmaWNhdGlvbiB0byBhIGJvdW5kIG9iamVjdCBncmFwaCwgYW5kIHRoZW4gZWl0aGVyXG4gICAqIHNpbXBseSByZS1zZXQgdGhlIG9iamVjdCAoZS5nLiBgdGhpcy5pdGVtcyA9IHRoaXMuaXRlbXNgKSBvciBjYWxsIGBub3RpZnlQYXRoYFxuICAgKiAoZS5nLiBgdGhpcy5ub3RpZnlQYXRoKCdpdGVtcycpYCkgdG8gdXBkYXRlIHRoZSB0cmVlLiAgTm90ZSB0aGF0IGFsbFxuICAgKiBlbGVtZW50cyB0aGF0IHdpc2ggdG8gYmUgdXBkYXRlZCBiYXNlZCBvbiBkZWVwIG11dGF0aW9ucyBtdXN0IGFwcGx5IHRoaXNcbiAgICogbWl4aW4gb3Igb3RoZXJ3aXNlIHNraXAgc3RyaWN0IGRpcnR5IGNoZWNraW5nIGZvciBvYmplY3RzL2FycmF5cy5cbiAgICpcbiAgICogV2hpbGUgdGhpcyBtaXhpbiBhZGRzIHRoZSBhYmlsaXR5IHRvIGZvcmdvIE9iamVjdC9BcnJheSBkaXJ0eSBjaGVja2luZyxcbiAgICogdGhlIGBtdXRhYmxlRGF0YWAgZmxhZyBkZWZhdWx0cyB0byBmYWxzZSBhbmQgbXVzdCBiZSBzZXQgb24gdGhlIGluc3RhbmNlLlxuICAgKlxuICAgKiBOb3RlLCB0aGUgcGVyZm9ybWFuY2UgY2hhcmFjdGVyaXN0aWNzIG9mIHByb3BhZ2F0aW5nIGxhcmdlIG9iamVjdCBncmFwaHNcbiAgICogd2lsbCBiZSB3b3JzZSBieSByZWx5aW5nIG9uIGBtdXRhYmxlRGF0YTogdHJ1ZWAgYXMgb3Bwb3NlZCB0byB1c2luZ1xuICAgKiBzdHJpY3QgZGlydHkgY2hlY2tpbmcgd2l0aCBpbW11dGFibGUgcGF0dGVybnMgb3IgUG9seW1lcidzIHBhdGggbm90aWZpY2F0aW9uXG4gICAqIEFQSS5cbiAgICpcbiAgICogQG1peGluRnVuY3Rpb25cbiAgICogQHBvbHltZXJcbiAgICogQG1lbWJlcm9mIFBvbHltZXJcbiAgICogQHN1bW1hcnkgRWxlbWVudCBjbGFzcyBtaXhpbiB0byBvcHRpb25hbGx5IHNraXAgc3RyaWN0IGRpcnR5LWNoZWNraW5nXG4gICAqICAgZm9yIG9iamVjdHMgYW5kIGFycmF5c1xuICAgKi9cbiAgUG9seW1lci5PcHRpb25hbE11dGFibGVEYXRhID0gUG9seW1lci5kZWR1cGluZ01peGluKHN1cGVyQ2xhc3MgPT4ge1xuXG4gICAgLyoqXG4gICAgICogQG1peGluQ2xhc3NcbiAgICAgKiBAcG9seW1lclxuICAgICAqIEBpbXBsZW1lbnRzIHtQb2x5bWVyX09wdGlvbmFsTXV0YWJsZURhdGF9XG4gICAgICovXG4gICAgY2xhc3MgT3B0aW9uYWxNdXRhYmxlRGF0YSBleHRlbmRzIHN1cGVyQ2xhc3Mge1xuXG4gICAgICBzdGF0aWMgZ2V0IHByb3BlcnRpZXMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogSW5zdGFuY2UtbGV2ZWwgZmxhZyBmb3IgY29uZmlndXJpbmcgdGhlIGRpcnR5LWNoZWNraW5nIHN0cmF0ZWd5XG4gICAgICAgICAgICogZm9yIHRoaXMgZWxlbWVudC4gIFdoZW4gdHJ1ZSwgT2JqZWN0cyBhbmQgQXJyYXlzIHdpbGwgc2tpcCBkaXJ0eVxuICAgICAgICAgICAqIGNoZWNraW5nLCBvdGhlcndpc2Ugc3RyaWN0IGVxdWFsaXR5IGNoZWNraW5nIHdpbGwgYmUgdXNlZC5cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBtdXRhYmxlRGF0YTogQm9vbGVhblxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIE92ZXJyaWRlcyBgUG9seW1lci5Qcm9wZXJ0eUVmZmVjdHNgIHRvIHByb3ZpZGUgb3B0aW9uIGZvciBza2lwcGluZ1xuICAgICAgICogc3RyaWN0IGVxdWFsaXR5IGNoZWNraW5nIGZvciBPYmplY3RzIGFuZCBBcnJheXMuXG4gICAgICAgKlxuICAgICAgICogV2hlbiBgdGhpcy5tdXRhYmxlRGF0YWAgaXMgdHJ1ZSBvbiB0aGlzIGluc3RhbmNlLCB0aGlzIG1ldGhvZFxuICAgICAgICogcHVsbHMgdGhlIHZhbHVlIHRvIGRpcnR5IGNoZWNrIGFnYWluc3QgZnJvbSB0aGUgYF9fZGF0YVRlbXBgIGNhY2hlXG4gICAgICAgKiAocmF0aGVyIHRoYW4gdGhlIG5vcm1hbCBgX19kYXRhYCBjYWNoZSkgZm9yIE9iamVjdHMuICBTaW5jZSB0aGUgdGVtcFxuICAgICAgICogY2FjaGUgaXMgY2xlYXJlZCBhdCB0aGUgZW5kIG9mIGEgdHVybiwgdGhpcyBpbXBsZW1lbnRhdGlvbiBhbGxvd3NcbiAgICAgICAqIHNpZGUtZWZmZWN0cyBvZiBkZWVwIG9iamVjdCBjaGFuZ2VzIHRvIGJlIHByb2Nlc3NlZCBieSByZS1zZXR0aW5nIHRoZVxuICAgICAgICogc2FtZSBvYmplY3QgKHVzaW5nIHRoZSB0ZW1wIGNhY2hlIGFzIGFuIGluLXR1cm4gYmFja3N0b3AgdG8gcHJldmVudFxuICAgICAgICogY3ljbGVzIGR1ZSB0byAyLXdheSBub3RpZmljYXRpb24pLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSBuYW1lXG4gICAgICAgKiBAcGFyYW0geyp9IHZhbHVlIE5ldyBwcm9wZXJ0eSB2YWx1ZVxuICAgICAgICogQHBhcmFtIHsqfSBvbGQgUHJldmlvdXMgcHJvcGVydHkgdmFsdWVcbiAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIHByb3BlcnR5IHNob3VsZCBiZSBjb25zaWRlcmVkIGEgY2hhbmdlXG4gICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgKi9cbiAgICAgIF9zaG91bGRQcm9wZXJ0eUNoYW5nZShwcm9wZXJ0eSwgdmFsdWUsIG9sZCkge1xuICAgICAgICByZXR1cm4gbXV0YWJsZVByb3BlcnR5Q2hhbmdlKHRoaXMsIHByb3BlcnR5LCB2YWx1ZSwgb2xkLCB0aGlzLm11dGFibGVEYXRhKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gT3B0aW9uYWxNdXRhYmxlRGF0YTtcblxuICB9KTtcblxuICAvLyBFeHBvcnQgZm9yIHVzZSBieSBsZWdhY3kgYmVoYXZpb3JcbiAgUG9seW1lci5NdXRhYmxlRGF0YS5fbXV0YWJsZVByb3BlcnR5Q2hhbmdlID0gbXV0YWJsZVByb3BlcnR5Q2hhbmdlO1xuXG59KSgpO1xuPC9zY3JpcHQ+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL3BvbHltZXIvbGliL21peGlucy9tdXRhYmxlLWRhdGEuaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCJib290Lmh0bWxcIj5cbjxzY3JpcHQ+XG4oZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBjb25zdCBjYXNlTWFwID0ge307XG4gIGNvbnN0IERBU0hfVE9fQ0FNRUwgPSAvLVthLXpdL2c7XG4gIGNvbnN0IENBTUVMX1RPX0RBU0ggPSAvKFtBLVpdKS9nO1xuXG4gIC8qKlxuICAgKiBNb2R1bGUgd2l0aCB1dGlsaXRpZXMgZm9yIGNvbnZlcnRpbmcgYmV0d2VlbiBcImRhc2gtY2FzZVwiIGFuZCBcImNhbWVsQ2FzZVwiXG4gICAqIGlkZW50aWZpZXJzLlxuICAgKlxuICAgKiBAbmFtZXNwYWNlXG4gICAqIEBtZW1iZXJvZiBQb2x5bWVyXG4gICAqIEBzdW1tYXJ5IE1vZHVsZSB0aGF0IHByb3ZpZGVzIHV0aWxpdGllcyBmb3IgY29udmVydGluZyBiZXR3ZWVuIFwiZGFzaC1jYXNlXCJcbiAgICogICBhbmQgXCJjYW1lbENhc2VcIi5cbiAgICovXG4gIGNvbnN0IENhc2VNYXAgPSB7XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBcImRhc2gtY2FzZVwiIGlkZW50aWZpZXIgKGUuZy4gYGZvby1iYXItYmF6YCkgdG8gXCJjYW1lbENhc2VcIlxuICAgICAqIChlLmcuIGBmb29CYXJCYXpgKS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBQb2x5bWVyLkNhc2VNYXBcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGFzaCBEYXNoLWNhc2UgaWRlbnRpZmllclxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gQ2FtZWwtY2FzZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgaWRlbnRpZmllclxuICAgICAqL1xuICAgIGRhc2hUb0NhbWVsQ2FzZShkYXNoKSB7XG4gICAgICByZXR1cm4gY2FzZU1hcFtkYXNoXSB8fCAoXG4gICAgICAgIGNhc2VNYXBbZGFzaF0gPSBkYXNoLmluZGV4T2YoJy0nKSA8IDAgPyBkYXNoIDogZGFzaC5yZXBsYWNlKERBU0hfVE9fQ0FNRUwsXG4gICAgICAgICAgKG0pID0+IG1bMV0udG9VcHBlckNhc2UoKVxuICAgICAgICApXG4gICAgICApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBcImNhbWVsQ2FzZVwiIGlkZW50aWZpZXIgKGUuZy4gYGZvb0JhckJhemApIHRvIFwiZGFzaC1jYXNlXCJcbiAgICAgKiAoZS5nLiBgZm9vLWJhci1iYXpgKS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBQb2x5bWVyLkNhc2VNYXBcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2FtZWwgQ2FtZWwtY2FzZSBpZGVudGlmaWVyXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBEYXNoLWNhc2UgcmVwcmVzZW50YXRpb24gb2YgdGhlIGlkZW50aWZpZXJcbiAgICAgKi9cbiAgICBjYW1lbFRvRGFzaENhc2UoY2FtZWwpIHtcbiAgICAgIHJldHVybiBjYXNlTWFwW2NhbWVsXSB8fCAoXG4gICAgICAgIGNhc2VNYXBbY2FtZWxdID0gY2FtZWwucmVwbGFjZShDQU1FTF9UT19EQVNILCAnLSQxJykudG9Mb3dlckNhc2UoKVxuICAgICAgKTtcbiAgICB9XG5cbiAgfTtcblxuICBQb2x5bWVyLkNhc2VNYXAgPSBDYXNlTWFwO1xufSkoKTtcbjwvc2NyaXB0PlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi91dGlscy9jYXNlLW1hcC5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuXG5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi91dGlscy9ib290Lmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi91dGlscy9taXhpbi5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vdXRpbHMvcGF0aC5odG1sXCI+XG48IS0tIGZvciBub3RpZnksIHJlZmxlY3QgLS0+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vdXRpbHMvY2FzZS1tYXAuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cInByb3BlcnR5LWFjY2Vzc29ycy5odG1sXCI+XG48IS0tIGZvciBhbm5vdGF0ZWQgZWZmZWN0cyAtLT5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCJ0ZW1wbGF0ZS1zdGFtcC5odG1sXCI+XG5cblxuPHNjcmlwdD5cbihmdW5jdGlvbigpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgLyoqIEBjb25zdCB7T2JqZWN0fSAqL1xuICBjb25zdCBDYXNlTWFwID0gUG9seW1lci5DYXNlTWFwO1xuXG4gIC8vIE1vbm90b25pY2FsbHkgaW5jcmVhc2luZyB1bmlxdWUgSUQgdXNlZCBmb3IgZGUtZHVwaW5nIGVmZmVjdHMgdHJpZ2dlcmVkXG4gIC8vIGZyb20gbXVsdGlwbGUgcHJvcGVydGllcyBpbiB0aGUgc2FtZSB0dXJuXG4gIGxldCBkZWR1cGVJZCA9IDA7XG5cbiAgLyoqXG4gICAqIFByb3BlcnR5IGVmZmVjdCB0eXBlczsgZWZmZWN0cyBhcmUgc3RvcmVkIG9uIHRoZSBwcm90b3R5cGUgdXNpbmcgdGhlc2Uga2V5c1xuICAgKiBAZW51bSB7c3RyaW5nfVxuICAgKi9cbiAgY29uc3QgVFlQRVMgPSB7XG4gICAgQ09NUFVURTogJ19fY29tcHV0ZUVmZmVjdHMnLFxuICAgIFJFRkxFQ1Q6ICdfX3JlZmxlY3RFZmZlY3RzJyxcbiAgICBOT1RJRlk6ICdfX25vdGlmeUVmZmVjdHMnLFxuICAgIFBST1BBR0FURTogJ19fcHJvcGFnYXRlRWZmZWN0cycsXG4gICAgT0JTRVJWRTogJ19fb2JzZXJ2ZUVmZmVjdHMnLFxuICAgIFJFQURfT05MWTogJ19fcmVhZE9ubHknXG4gIH1cblxuICAvKipcbiAgICogQHR5cGVkZWYge3tcbiAgICogbmFtZTogKHN0cmluZyB8IHVuZGVmaW5lZCksXG4gICAqIHN0cnVjdHVyZWQ6IChib29sZWFuIHwgdW5kZWZpbmVkKSxcbiAgICogd2lsZGNhcmQ6IChib29sZWFuIHwgdW5kZWZpbmVkKVxuICAgKiB9fVxuICAgKi9cbiAgbGV0IERhdGFUcmlnZ2VyOyAvL2VzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblxuICAvKipcbiAgICogQHR5cGVkZWYge3tcbiAgICogaW5mbzogPyxcbiAgICogdHJpZ2dlcjogKCFEYXRhVHJpZ2dlciB8IHVuZGVmaW5lZCksXG4gICAqIGZuOiAoIUZ1bmN0aW9uIHwgdW5kZWZpbmVkKVxuICAgKiB9fVxuICAgKi9cbiAgbGV0IERhdGFFZmZlY3Q7IC8vZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuXG4gIGxldCBQcm9wZXJ0eUVmZmVjdHNUeXBlOyAvL2VzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblxuICAvKipcbiAgICogRW5zdXJlcyB0aGF0IHRoZSBtb2RlbCBoYXMgYW4gb3duLXByb3BlcnR5IG1hcCBvZiBlZmZlY3RzIGZvciB0aGUgZ2l2ZW4gdHlwZS5cbiAgICogVGhlIG1vZGVsIG1heSBiZSBhIHByb3RvdHlwZSBvciBhbiBpbnN0YW5jZS5cbiAgICpcbiAgICogUHJvcGVydHkgZWZmZWN0cyBhcmUgc3RvcmVkIGFzIGFycmF5cyBvZiBlZmZlY3RzIGJ5IHByb3BlcnR5IGluIGEgbWFwLFxuICAgKiBieSBuYW1lZCB0eXBlIG9uIHRoZSBtb2RlbC4gZS5nLlxuICAgKlxuICAgKiAgIF9fY29tcHV0ZUVmZmVjdHM6IHtcbiAgICogICAgIGZvbzogWyAuLi4gXSxcbiAgICogICAgIGJhcjogWyAuLi4gXVxuICAgKiAgIH1cbiAgICpcbiAgICogSWYgdGhlIG1vZGVsIGRvZXMgbm90IHlldCBoYXZlIGFuIGVmZmVjdCBtYXAgZm9yIHRoZSB0eXBlLCBvbmUgaXMgY3JlYXRlZFxuICAgKiBhbmQgcmV0dXJuZWQuICBJZiBpdCBkb2VzLCBidXQgaXQgaXMgbm90IGFuIG93biBwcm9wZXJ0eSAoaS5lLiB0aGVcbiAgICogcHJvdG90eXBlIGhhZCBlZmZlY3RzKSwgdGhlIHRoZSBtYXAgaXMgZGVlcGx5IGNsb25lZCBhbmQgdGhlIGNvcHkgaXNcbiAgICogc2V0IG9uIHRoZSBtb2RlbCBhbmQgcmV0dXJuZWQsIHJlYWR5IGZvciBuZXcgZWZmZWN0cyB0byBiZSBhZGRlZC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG1vZGVsIFByb3RvdHlwZSBvciBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBQcm9wZXJ0eSBlZmZlY3QgdHlwZVxuICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBvd24tcHJvcGVydHkgbWFwIG9mIGVmZmVjdHMgZm9yIHRoZSBnaXZlbiB0eXBlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBlbnN1cmVPd25FZmZlY3RNYXAobW9kZWwsIHR5cGUpIHtcbiAgICBsZXQgZWZmZWN0cyA9IG1vZGVsW3R5cGVdO1xuICAgIGlmICghZWZmZWN0cykge1xuICAgICAgZWZmZWN0cyA9IG1vZGVsW3R5cGVdID0ge307XG4gICAgfSBlbHNlIGlmICghbW9kZWwuaGFzT3duUHJvcGVydHkodHlwZSkpIHtcbiAgICAgIGVmZmVjdHMgPSBtb2RlbFt0eXBlXSA9IE9iamVjdC5jcmVhdGUobW9kZWxbdHlwZV0pO1xuICAgICAgZm9yIChsZXQgcCBpbiBlZmZlY3RzKSB7XG4gICAgICAgIGxldCBwcm90b0Z4ID0gZWZmZWN0c1twXTtcbiAgICAgICAgbGV0IGluc3RGeCA9IGVmZmVjdHNbcF0gPSBBcnJheShwcm90b0Z4Lmxlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxwcm90b0Z4Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaW5zdEZ4W2ldID0gcHJvdG9GeFtpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZWZmZWN0cztcbiAgfVxuXG4gIC8vIC0tIGVmZmVjdHMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8qKlxuICAgKiBSdW5zIGFsbCBlZmZlY3RzIG9mIGEgZ2l2ZW4gdHlwZSBmb3IgdGhlIGdpdmVuIHNldCBvZiBwcm9wZXJ0eSBjaGFuZ2VzXG4gICAqIG9uIGFuIGluc3RhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0geyFQcm9wZXJ0eUVmZmVjdHNUeXBlfSBpbnN0IFRoZSBpbnN0YW5jZSB3aXRoIGVmZmVjdHMgdG8gcnVuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlZmZlY3RzIE9iamVjdCBtYXAgb2YgcHJvcGVydHktdG8tQXJyYXkgb2YgZWZmZWN0c1xuICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgQmFnIG9mIGN1cnJlbnQgcHJvcGVydHkgY2hhbmdlc1xuICAgKiBAcGFyYW0ge09iamVjdD19IG9sZFByb3BzIEJhZyBvZiBwcmV2aW91cyB2YWx1ZXMgZm9yIGNoYW5nZWQgcHJvcGVydGllc1xuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBoYXNQYXRocyBUcnVlIHdpdGggYHByb3BzYCBjb250YWlucyBvbmUgb3IgbW9yZSBwYXRoc1xuICAgKiBAcGFyYW0geyo9fSBleHRyYUFyZ3MgQWRkaXRpb25hbCBtZXRhZGF0YSB0byBwYXNzIHRvIGVmZmVjdCBmdW5jdGlvblxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGFuIGVmZmVjdCByYW4gZm9yIHRoaXMgcHJvcGVydHlcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIHJ1bkVmZmVjdHMoaW5zdCwgZWZmZWN0cywgcHJvcHMsIG9sZFByb3BzLCBoYXNQYXRocywgZXh0cmFBcmdzKSB7XG4gICAgaWYgKGVmZmVjdHMpIHtcbiAgICAgIGxldCByYW4gPSBmYWxzZTtcbiAgICAgIGxldCBpZCA9IGRlZHVwZUlkKys7XG4gICAgICBmb3IgKGxldCBwcm9wIGluIHByb3BzKSB7XG4gICAgICAgIGlmIChydW5FZmZlY3RzRm9yUHJvcGVydHkoaW5zdCwgZWZmZWN0cywgaWQsIHByb3AsIHByb3BzLCBvbGRQcm9wcywgaGFzUGF0aHMsIGV4dHJhQXJncykpIHtcbiAgICAgICAgICByYW4gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmFuO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogUnVucyBhIGxpc3Qgb2YgZWZmZWN0cyBmb3IgYSBnaXZlbiBwcm9wZXJ0eS5cbiAgICpcbiAgICogQHBhcmFtIHshUHJvcGVydHlFZmZlY3RzVHlwZX0gaW5zdCBUaGUgaW5zdGFuY2Ugd2l0aCBlZmZlY3RzIHRvIHJ1blxuICAgKiBAcGFyYW0ge09iamVjdH0gZWZmZWN0cyBPYmplY3QgbWFwIG9mIHByb3BlcnR5LXRvLUFycmF5IG9mIGVmZmVjdHNcbiAgICogQHBhcmFtIHtudW1iZXJ9IGRlZHVwZUlkIENvdW50ZXIgdXNlZCBmb3IgZGUtZHVwaW5nIGVmZmVjdHNcbiAgICogQHBhcmFtIHtzdHJpbmd9IHByb3AgTmFtZSBvZiBjaGFuZ2VkIHByb3BlcnR5XG4gICAqIEBwYXJhbSB7Kn0gcHJvcHMgQ2hhbmdlZCBwcm9wZXJ0aWVzXG4gICAqIEBwYXJhbSB7Kn0gb2xkUHJvcHMgT2xkIHByb3BlcnRpZXNcbiAgICogQHBhcmFtIHtib29sZWFuPX0gaGFzUGF0aHMgVHJ1ZSB3aXRoIGBwcm9wc2AgY29udGFpbnMgb25lIG9yIG1vcmUgcGF0aHNcbiAgICogQHBhcmFtIHsqPX0gZXh0cmFBcmdzIEFkZGl0aW9uYWwgbWV0YWRhdGEgdG8gcGFzcyB0byBlZmZlY3QgZnVuY3Rpb25cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBhbiBlZmZlY3QgcmFuIGZvciB0aGlzIHByb3BlcnR5XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBydW5FZmZlY3RzRm9yUHJvcGVydHkoaW5zdCwgZWZmZWN0cywgZGVkdXBlSWQsIHByb3AsIHByb3BzLCBvbGRQcm9wcywgaGFzUGF0aHMsIGV4dHJhQXJncykge1xuICAgIGxldCByYW4gPSBmYWxzZTtcbiAgICBsZXQgcm9vdFByb3BlcnR5ID0gaGFzUGF0aHMgPyBQb2x5bWVyLlBhdGgucm9vdChwcm9wKSA6IHByb3A7XG4gICAgbGV0IGZ4cyA9IGVmZmVjdHNbcm9vdFByb3BlcnR5XTtcbiAgICBpZiAoZnhzKSB7XG4gICAgICBmb3IgKGxldCBpPTAsIGw9ZnhzLmxlbmd0aCwgZng7IChpPGwpICYmIChmeD1meHNbaV0pOyBpKyspIHtcbiAgICAgICAgaWYgKCghZnguaW5mbyB8fCBmeC5pbmZvLmxhc3RSdW4gIT09IGRlZHVwZUlkKSAmJlxuICAgICAgICAgICAgKCFoYXNQYXRocyB8fCBwYXRoTWF0Y2hlc1RyaWdnZXIocHJvcCwgZngudHJpZ2dlcikpKSB7XG4gICAgICAgICAgaWYgKGZ4LmluZm8pIHtcbiAgICAgICAgICAgIGZ4LmluZm8ubGFzdFJ1biA9IGRlZHVwZUlkO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmeC5mbihpbnN0LCBwcm9wLCBwcm9wcywgb2xkUHJvcHMsIGZ4LmluZm8sIGhhc1BhdGhzLCBleHRyYUFyZ3MpO1xuICAgICAgICAgIHJhbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJhbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgYSBwcm9wZXJ0eS9wYXRoIHRoYXQgaGFzIGNoYW5nZWQgbWF0Y2hlcyB0aGUgdHJpZ2dlclxuICAgKiBjcml0ZXJpYSBmb3IgYW4gZWZmZWN0LiAgQSB0cmlnZ2VyIGlzIGEgZGVzY3JpcHRvciB3aXRoIHRoZSBmb2xsb3dpbmdcbiAgICogc3RydWN0dXJlLCB3aGljaCBtYXRjaGVzIHRoZSBkZXNjcmlwdG9ycyByZXR1cm5lZCBmcm9tIGBwYXJzZUFyZ2AuXG4gICAqIGUuZy4gZm9yIGBmb28uYmFyLipgOlxuICAgKiBgYGBcbiAgICogdHJpZ2dlcjoge1xuICAgKiAgIG5hbWU6ICdhLmInLFxuICAgKiAgIHN0cnVjdHVyZWQ6IHRydWUsXG4gICAqICAgd2lsZGNhcmQ6IHRydWVcbiAgICogfVxuICAgKiBgYGBcbiAgICogSWYgbm8gdHJpZ2dlciBpcyBnaXZlbiwgdGhlIHBhdGggaXMgZGVlbWVkIHRvIG1hdGNoLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBQYXRoIG9yIHByb3BlcnR5IHRoYXQgY2hhbmdlZFxuICAgKiBAcGFyYW0ge0RhdGFUcmlnZ2VyfSB0cmlnZ2VyIERlc2NyaXB0b3JcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgcGF0aCBtYXRjaGVkIHRoZSB0cmlnZ2VyXG4gICAqL1xuICBmdW5jdGlvbiBwYXRoTWF0Y2hlc1RyaWdnZXIocGF0aCwgdHJpZ2dlcikge1xuICAgIGlmICh0cmlnZ2VyKSB7XG4gICAgICBsZXQgdHJpZ2dlclBhdGggPSB0cmlnZ2VyLm5hbWU7XG4gICAgICByZXR1cm4gKHRyaWdnZXJQYXRoID09IHBhdGgpIHx8XG4gICAgICAgICh0cmlnZ2VyLnN0cnVjdHVyZWQgJiYgUG9seW1lci5QYXRoLmlzQW5jZXN0b3IodHJpZ2dlclBhdGgsIHBhdGgpKSB8fFxuICAgICAgICAodHJpZ2dlci53aWxkY2FyZCAmJiBQb2x5bWVyLlBhdGguaXNEZXNjZW5kYW50KHRyaWdnZXJQYXRoLCBwYXRoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbXBsZW1lbnRzIHRoZSBcIm9ic2VydmVyXCIgZWZmZWN0LlxuICAgKlxuICAgKiBDYWxscyB0aGUgbWV0aG9kIHdpdGggYGluZm8ubWV0aG9kTmFtZWAgb24gdGhlIGluc3RhbmNlLCBwYXNzaW5nIHRoZVxuICAgKiBuZXcgYW5kIG9sZCB2YWx1ZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7IVByb3BlcnR5RWZmZWN0c1R5cGV9IGluc3QgVGhlIGluc3RhbmNlIHRoZSBlZmZlY3Qgd2lsbCBiZSBydW4gb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IE5hbWUgb2YgcHJvcGVydHlcbiAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzIEJhZyBvZiBjdXJyZW50IHByb3BlcnR5IGNoYW5nZXNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9sZFByb3BzIEJhZyBvZiBwcmV2aW91cyB2YWx1ZXMgZm9yIGNoYW5nZWQgcHJvcGVydGllc1xuICAgKiBAcGFyYW0gez99IGluZm8gRWZmZWN0IG1ldGFkYXRhXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBydW5PYnNlcnZlckVmZmVjdChpbnN0LCBwcm9wZXJ0eSwgcHJvcHMsIG9sZFByb3BzLCBpbmZvKSB7XG4gICAgbGV0IGZuID0gaW5zdFtpbmZvLm1ldGhvZE5hbWVdO1xuICAgIGxldCBjaGFuZ2VkUHJvcCA9IGluZm8ucHJvcGVydHk7XG4gICAgaWYgKGZuKSB7XG4gICAgICBmbi5jYWxsKGluc3QsIGluc3QuX19kYXRhW2NoYW5nZWRQcm9wXSwgb2xkUHJvcHNbY2hhbmdlZFByb3BdKTtcbiAgICB9IGVsc2UgaWYgKCFpbmZvLmR5bmFtaWNGbikge1xuICAgICAgY29uc29sZS53YXJuKCdvYnNlcnZlciBtZXRob2QgYCcgKyBpbmZvLm1ldGhvZE5hbWUgKyAnYCBub3QgZGVmaW5lZCcpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSdW5zIFwibm90aWZ5XCIgZWZmZWN0cyBmb3IgYSBzZXQgb2YgY2hhbmdlZCBwcm9wZXJ0aWVzLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBkaWZmZXJzIGZyb20gdGhlIGdlbmVyaWMgYHJ1bkVmZmVjdHNgIG1ldGhvZCBpbiB0aGF0IGl0XG4gICAqIHdpbGwgZGlzcGF0Y2ggcGF0aCBub3RpZmljYXRpb24gZXZlbnRzIGluIHRoZSBjYXNlIHRoYXQgdGhlIHByb3BlcnR5XG4gICAqIGNoYW5nZWQgd2FzIGEgcGF0aCBhbmQgdGhlIHJvb3QgcHJvcGVydHkgZm9yIHRoYXQgcGF0aCBkaWRuJ3QgaGF2ZSBhXG4gICAqIFwibm90aWZ5XCIgZWZmZWN0LiAgVGhpcyBpcyB0byBtYWludGFpbiAxLjAgYmVoYXZpb3IgdGhhdCBkaWQgbm90IHJlcXVpcmVcbiAgICogYG5vdGlmeTogdHJ1ZWAgdG8gZW5zdXJlIG9iamVjdCBzdWItcHJvcGVydHkgbm90aWZpY2F0aW9ucyB3ZXJlXG4gICAqIHNlbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7IVByb3BlcnR5RWZmZWN0c1R5cGV9IGluc3QgVGhlIGluc3RhbmNlIHdpdGggZWZmZWN0cyB0byBydW5cbiAgICogQHBhcmFtIHtPYmplY3R9IG5vdGlmeVByb3BzIEJhZyBvZiBwcm9wZXJ0aWVzIHRvIG5vdGlmeVxuICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgQmFnIG9mIGN1cnJlbnQgcHJvcGVydHkgY2hhbmdlc1xuICAgKiBAcGFyYW0ge09iamVjdH0gb2xkUHJvcHMgQmFnIG9mIHByZXZpb3VzIHZhbHVlcyBmb3IgY2hhbmdlZCBwcm9wZXJ0aWVzXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaGFzUGF0aHMgVHJ1ZSB3aXRoIGBwcm9wc2AgY29udGFpbnMgb25lIG9yIG1vcmUgcGF0aHNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIHJ1bk5vdGlmeUVmZmVjdHMoaW5zdCwgbm90aWZ5UHJvcHMsIHByb3BzLCBvbGRQcm9wcywgaGFzUGF0aHMpIHtcbiAgICAvLyBOb3RpZnlcbiAgICBsZXQgZnhzID0gaW5zdFtUWVBFUy5OT1RJRlldO1xuICAgIGxldCBub3RpZmllZDtcbiAgICBsZXQgaWQgPSBkZWR1cGVJZCsrO1xuICAgIC8vIFRyeSBub3JtYWwgbm90aWZ5IGVmZmVjdHM7IGlmIG5vbmUsIGZhbGwgYmFjayB0byB0cnkgcGF0aCBub3RpZmljYXRpb25cbiAgICBmb3IgKGxldCBwcm9wIGluIG5vdGlmeVByb3BzKSB7XG4gICAgICBpZiAobm90aWZ5UHJvcHNbcHJvcF0pIHtcbiAgICAgICAgaWYgKGZ4cyAmJiBydW5FZmZlY3RzRm9yUHJvcGVydHkoaW5zdCwgZnhzLCBpZCwgcHJvcCwgcHJvcHMsIG9sZFByb3BzLCBoYXNQYXRocykpIHtcbiAgICAgICAgICBub3RpZmllZCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoaGFzUGF0aHMgJiYgbm90aWZ5UGF0aChpbnN0LCBwcm9wLCBwcm9wcykpIHtcbiAgICAgICAgICBub3RpZmllZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gRmx1c2ggaG9zdCBpZiB3ZSBhY3R1YWxseSBub3RpZmllZCBhbmQgaG9zdCB3YXMgYmF0Y2hpbmdcbiAgICAvLyBBbmQgdGhlIGhvc3QgaGFzIGFscmVhZHkgaW5pdGlhbGl6ZWQgY2xpZW50czsgdGhpcyBwcmV2ZW50c1xuICAgIC8vIGFuIGlzc3VlIHdpdGggYSBob3N0IG9ic2VydmluZyBkYXRhIGNoYW5nZXMgYmVmb3JlIGNsaWVudHMgYXJlIHJlYWR5LlxuICAgIGxldCBob3N0O1xuICAgIGlmIChub3RpZmllZCAmJiAoaG9zdCA9IGluc3QuX19kYXRhSG9zdCkgJiYgaG9zdC5faW52YWxpZGF0ZVByb3BlcnRpZXMpIHtcbiAgICAgIGhvc3QuX2ludmFsaWRhdGVQcm9wZXJ0aWVzKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERpc3BhdGNoZXMge3Byb3BlcnR5fS1jaGFuZ2VkIGV2ZW50cyB3aXRoIHBhdGggaW5mb3JtYXRpb24gaW4gdGhlIGRldGFpbFxuICAgKiBvYmplY3QgdG8gaW5kaWNhdGUgYSBzdWItcGF0aCBvZiB0aGUgcHJvcGVydHkgd2FzIGNoYW5nZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7IVByb3BlcnR5RWZmZWN0c1R5cGV9IGluc3QgVGhlIGVsZW1lbnQgZnJvbSB3aGljaCB0byBmaXJlIHRoZSBldmVudFxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBUaGUgcGF0aCB0aGF0IHdhcyBjaGFuZ2VkXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBCYWcgb2YgY3VycmVudCBwcm9wZXJ0eSBjaGFuZ2VzXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGUgcGF0aCB3YXMgbm90aWZpZWRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIG5vdGlmeVBhdGgoaW5zdCwgcGF0aCwgcHJvcHMpIHtcbiAgICBsZXQgcm9vdFByb3BlcnR5ID0gUG9seW1lci5QYXRoLnJvb3QocGF0aCk7XG4gICAgaWYgKHJvb3RQcm9wZXJ0eSAhPT0gcGF0aCkge1xuICAgICAgbGV0IGV2ZW50TmFtZSA9IFBvbHltZXIuQ2FzZU1hcC5jYW1lbFRvRGFzaENhc2Uocm9vdFByb3BlcnR5KSArICctY2hhbmdlZCc7XG4gICAgICBkaXNwYXRjaE5vdGlmeUV2ZW50KGluc3QsIGV2ZW50TmFtZSwgcHJvcHNbcGF0aF0sIHBhdGgpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNwYXRjaGVzIHtwcm9wZXJ0eX0tY2hhbmdlZCBldmVudHMgdG8gaW5kaWNhdGUgYSBwcm9wZXJ0eSAob3IgcGF0aClcbiAgICogY2hhbmdlZC5cbiAgICpcbiAgICogQHBhcmFtIHshUHJvcGVydHlFZmZlY3RzVHlwZX0gaW5zdCBUaGUgZWxlbWVudCBmcm9tIHdoaWNoIHRvIGZpcmUgdGhlIGV2ZW50XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50IHRvIHNlbmQgKCd7cHJvcGVydHl9LWNoYW5nZWQnKVxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSBvZiB0aGUgY2hhbmdlZCBwcm9wZXJ0eVxuICAgKiBAcGFyYW0ge3N0cmluZyB8IG51bGwgfCB1bmRlZmluZWR9IHBhdGggSWYgYSBzdWItcGF0aCBvZiB0aGlzIHByb3BlcnR5IGNoYW5nZWQsIHRoZSBwYXRoXG4gICAqICAgdGhhdCBjaGFuZ2VkIChvcHRpb25hbCkuXG4gICAqIEBwcml2YXRlXG4gICAqIEBzdXBwcmVzcyB7aW52YWxpZENhc3RzfVxuICAgKi9cbiAgZnVuY3Rpb24gZGlzcGF0Y2hOb3RpZnlFdmVudChpbnN0LCBldmVudE5hbWUsIHZhbHVlLCBwYXRoKSB7XG4gICAgbGV0IGRldGFpbCA9IHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIHF1ZXVlUHJvcGVydHk6IHRydWVcbiAgICB9O1xuICAgIGlmIChwYXRoKSB7XG4gICAgICBkZXRhaWwucGF0aCA9IHBhdGg7XG4gICAgfVxuICAgIC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqLyhpbnN0KS5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudChldmVudE5hbWUsIHsgZGV0YWlsIH0pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbXBsZW1lbnRzIHRoZSBcIm5vdGlmeVwiIGVmZmVjdC5cbiAgICpcbiAgICogRGlzcGF0Y2hlcyBhIG5vbi1idWJibGluZyBldmVudCBuYW1lZCBgaW5mby5ldmVudE5hbWVgIG9uIHRoZSBpbnN0YW5jZVxuICAgKiB3aXRoIGEgZGV0YWlsIG9iamVjdCBjb250YWluaW5nIHRoZSBuZXcgYHZhbHVlYC5cbiAgICpcbiAgICogQHBhcmFtIHshUHJvcGVydHlFZmZlY3RzVHlwZX0gaW5zdCBUaGUgaW5zdGFuY2UgdGhlIGVmZmVjdCB3aWxsIGJlIHJ1biBvblxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgTmFtZSBvZiBwcm9wZXJ0eVxuICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgQmFnIG9mIGN1cnJlbnQgcHJvcGVydHkgY2hhbmdlc1xuICAgKiBAcGFyYW0ge09iamVjdH0gb2xkUHJvcHMgQmFnIG9mIHByZXZpb3VzIHZhbHVlcyBmb3IgY2hhbmdlZCBwcm9wZXJ0aWVzXG4gICAqIEBwYXJhbSB7P30gaW5mbyBFZmZlY3QgbWV0YWRhdGFcbiAgICogQHBhcmFtIHtib29sZWFufSBoYXNQYXRocyBUcnVlIHdpdGggYHByb3BzYCBjb250YWlucyBvbmUgb3IgbW9yZSBwYXRoc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gcnVuTm90aWZ5RWZmZWN0KGluc3QsIHByb3BlcnR5LCBwcm9wcywgb2xkUHJvcHMsIGluZm8sIGhhc1BhdGhzKSB7XG4gICAgbGV0IHJvb3RQcm9wZXJ0eSA9IGhhc1BhdGhzID8gUG9seW1lci5QYXRoLnJvb3QocHJvcGVydHkpIDogcHJvcGVydHk7XG4gICAgbGV0IHBhdGggPSByb290UHJvcGVydHkgIT0gcHJvcGVydHkgPyBwcm9wZXJ0eSA6IG51bGw7XG4gICAgbGV0IHZhbHVlID0gcGF0aCA/IFBvbHltZXIuUGF0aC5nZXQoaW5zdCwgcGF0aCkgOiBpbnN0Ll9fZGF0YVtwcm9wZXJ0eV07XG4gICAgaWYgKHBhdGggJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFsdWUgPSBwcm9wc1twcm9wZXJ0eV07ICAvLyBzcGVjaWZpY2FsbHkgZm9yIC5zcGxpY2VzXG4gICAgfVxuICAgIGRpc3BhdGNoTm90aWZ5RXZlbnQoaW5zdCwgaW5mby5ldmVudE5hbWUsIHZhbHVlLCBwYXRoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVyIGZ1bmN0aW9uIGZvciAyLXdheSBub3RpZmljYXRpb24gZXZlbnRzLiBSZWNlaXZlcyBjb250ZXh0XG4gICAqIGluZm9ybWF0aW9uIGNhcHR1cmVkIGluIHRoZSBgYWRkTm90aWZ5TGlzdGVuZXJgIGNsb3N1cmUgZnJvbSB0aGVcbiAgICogYF9fbm90aWZ5TGlzdGVuZXJzYCBtZXRhZGF0YS5cbiAgICpcbiAgICogU2V0cyB0aGUgdmFsdWUgb2YgdGhlIG5vdGlmaWVkIHByb3BlcnR5IHRvIHRoZSBob3N0IHByb3BlcnR5IG9yIHBhdGguICBJZlxuICAgKiB0aGUgZXZlbnQgY29udGFpbmVkIHBhdGggaW5mb3JtYXRpb24sIHRyYW5zbGF0ZSB0aGF0IHBhdGggdG8gdGhlIGhvc3RcbiAgICogc2NvcGUncyBuYW1lIGZvciB0aGF0IHBhdGggZmlyc3QuXG4gICAqXG4gICAqIEBwYXJhbSB7Q3VzdG9tRXZlbnR9IGV2ZW50IE5vdGlmaWNhdGlvbiBldmVudCAoZS5nLiAnPHByb3BlcnR5Pi1jaGFuZ2VkJylcbiAgICogQHBhcmFtIHshUHJvcGVydHlFZmZlY3RzVHlwZX0gaW5zdCBIb3N0IGVsZW1lbnQgaW5zdGFuY2UgaGFuZGxpbmcgdGhlIG5vdGlmaWNhdGlvbiBldmVudFxuICAgKiBAcGFyYW0ge3N0cmluZ30gZnJvbVByb3AgQ2hpbGQgZWxlbWVudCBwcm9wZXJ0eSB0aGF0IHdhcyBib3VuZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9QYXRoIEhvc3QgcHJvcGVydHkvcGF0aCB0aGF0IHdhcyBib3VuZFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IG5lZ2F0ZSBXaGV0aGVyIHRoZSBiaW5kaW5nIHdhcyBuZWdhdGVkXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBoYW5kbGVOb3RpZmljYXRpb24oZXZlbnQsIGluc3QsIGZyb21Qcm9wLCB0b1BhdGgsIG5lZ2F0ZSkge1xuICAgIGxldCB2YWx1ZTtcbiAgICBsZXQgZGV0YWlsID0gLyoqIEB0eXBlIHtPYmplY3R9ICovKGV2ZW50LmRldGFpbCk7XG4gICAgbGV0IGZyb21QYXRoID0gZGV0YWlsICYmIGRldGFpbC5wYXRoO1xuICAgIGlmIChmcm9tUGF0aCkge1xuICAgICAgdG9QYXRoID0gUG9seW1lci5QYXRoLnRyYW5zbGF0ZShmcm9tUHJvcCwgdG9QYXRoLCBmcm9tUGF0aCk7XG4gICAgICB2YWx1ZSA9IGRldGFpbCAmJiBkZXRhaWwudmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlID0gZXZlbnQudGFyZ2V0W2Zyb21Qcm9wXTtcbiAgICB9XG4gICAgdmFsdWUgPSBuZWdhdGUgPyAhdmFsdWUgOiB2YWx1ZTtcbiAgICBpZiAoIWluc3RbVFlQRVMuUkVBRF9PTkxZXSB8fCAhaW5zdFtUWVBFUy5SRUFEX09OTFldW3RvUGF0aF0pIHtcbiAgICAgIGlmIChpbnN0Ll9zZXRQZW5kaW5nUHJvcGVydHlPclBhdGgodG9QYXRoLCB2YWx1ZSwgdHJ1ZSwgQm9vbGVhbihmcm9tUGF0aCkpXG4gICAgICAgICYmICghZGV0YWlsIHx8ICFkZXRhaWwucXVldWVQcm9wZXJ0eSkpIHtcbiAgICAgICAgaW5zdC5faW52YWxpZGF0ZVByb3BlcnRpZXMoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSW1wbGVtZW50cyB0aGUgXCJyZWZsZWN0XCIgZWZmZWN0LlxuICAgKlxuICAgKiBTZXRzIHRoZSBhdHRyaWJ1dGUgbmFtZWQgYGluZm8uYXR0ck5hbWVgIHRvIHRoZSBnaXZlbiBwcm9wZXJ0eSB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIHshUHJvcGVydHlFZmZlY3RzVHlwZX0gaW5zdCBUaGUgaW5zdGFuY2UgdGhlIGVmZmVjdCB3aWxsIGJlIHJ1biBvblxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgTmFtZSBvZiBwcm9wZXJ0eVxuICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgQmFnIG9mIGN1cnJlbnQgcHJvcGVydHkgY2hhbmdlc1xuICAgKiBAcGFyYW0ge09iamVjdH0gb2xkUHJvcHMgQmFnIG9mIHByZXZpb3VzIHZhbHVlcyBmb3IgY2hhbmdlZCBwcm9wZXJ0aWVzXG4gICAqIEBwYXJhbSB7P30gaW5mbyBFZmZlY3QgbWV0YWRhdGFcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIHJ1blJlZmxlY3RFZmZlY3QoaW5zdCwgcHJvcGVydHksIHByb3BzLCBvbGRQcm9wcywgaW5mbykge1xuICAgIGxldCB2YWx1ZSA9IGluc3QuX19kYXRhW3Byb3BlcnR5XTtcbiAgICBpZiAoUG9seW1lci5zYW5pdGl6ZURPTVZhbHVlKSB7XG4gICAgICB2YWx1ZSA9IFBvbHltZXIuc2FuaXRpemVET01WYWx1ZSh2YWx1ZSwgaW5mby5hdHRyTmFtZSwgJ2F0dHJpYnV0ZScsIC8qKiBAdHlwZSB7Tm9kZX0gKi8oaW5zdCkpO1xuICAgIH1cbiAgICBpbnN0Ll9wcm9wZXJ0eVRvQXR0cmlidXRlKHByb3BlcnR5LCBpbmZvLmF0dHJOYW1lLCB2YWx1ZSk7XG4gIH1cblxuICAvKipcbiAgICogUnVucyBcImNvbXB1dGVkXCIgZWZmZWN0cyBmb3IgYSBzZXQgb2YgY2hhbmdlZCBwcm9wZXJ0aWVzLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBkaWZmZXJzIGZyb20gdGhlIGdlbmVyaWMgYHJ1bkVmZmVjdHNgIG1ldGhvZCBpbiB0aGF0IGl0XG4gICAqIGNvbnRpbnVlcyB0byBydW4gY29tcHV0ZWQgZWZmZWN0cyBiYXNlZCBvbiB0aGUgb3V0cHV0IG9mIGVhY2ggcGFzcyB1bnRpbFxuICAgKiB0aGVyZSBhcmUgbm8gbW9yZSBuZXdseSBjb21wdXRlZCBwcm9wZXJ0aWVzLiAgVGhpcyBlbnN1cmVzIHRoYXQgYWxsXG4gICAqIHByb3BlcnRpZXMgdGhhdCB3aWxsIGJlIGNvbXB1dGVkIGJ5IHRoZSBpbml0aWFsIHNldCBvZiBjaGFuZ2VzIGFyZVxuICAgKiBjb21wdXRlZCBiZWZvcmUgb3RoZXIgZWZmZWN0cyAoYmluZGluZyBwcm9wYWdhdGlvbiwgb2JzZXJ2ZXJzLCBhbmQgbm90aWZ5KVxuICAgKiBydW4uXG4gICAqXG4gICAqIEBwYXJhbSB7IVByb3BlcnR5RWZmZWN0c1R5cGV9IGluc3QgVGhlIGluc3RhbmNlIHRoZSBlZmZlY3Qgd2lsbCBiZSBydW4gb25cbiAgICogQHBhcmFtIHshT2JqZWN0fSBjaGFuZ2VkUHJvcHMgQmFnIG9mIGNoYW5nZWQgcHJvcGVydGllc1xuICAgKiBAcGFyYW0geyFPYmplY3R9IG9sZFByb3BzIEJhZyBvZiBwcmV2aW91cyB2YWx1ZXMgZm9yIGNoYW5nZWQgcHJvcGVydGllc1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhhc1BhdGhzIFRydWUgd2l0aCBgcHJvcHNgIGNvbnRhaW5zIG9uZSBvciBtb3JlIHBhdGhzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBydW5Db21wdXRlZEVmZmVjdHMoaW5zdCwgY2hhbmdlZFByb3BzLCBvbGRQcm9wcywgaGFzUGF0aHMpIHtcbiAgICBsZXQgY29tcHV0ZUVmZmVjdHMgPSBpbnN0W1RZUEVTLkNPTVBVVEVdO1xuICAgIGlmIChjb21wdXRlRWZmZWN0cykge1xuICAgICAgbGV0IGlucHV0UHJvcHMgPSBjaGFuZ2VkUHJvcHM7XG4gICAgICB3aGlsZSAocnVuRWZmZWN0cyhpbnN0LCBjb21wdXRlRWZmZWN0cywgaW5wdXRQcm9wcywgb2xkUHJvcHMsIGhhc1BhdGhzKSkge1xuICAgICAgICBPYmplY3QuYXNzaWduKG9sZFByb3BzLCBpbnN0Ll9fZGF0YU9sZCk7XG4gICAgICAgIE9iamVjdC5hc3NpZ24oY2hhbmdlZFByb3BzLCBpbnN0Ll9fZGF0YVBlbmRpbmcpO1xuICAgICAgICBpbnB1dFByb3BzID0gaW5zdC5fX2RhdGFQZW5kaW5nO1xuICAgICAgICBpbnN0Ll9fZGF0YVBlbmRpbmcgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbXBsZW1lbnRzIHRoZSBcImNvbXB1dGVkIHByb3BlcnR5XCIgZWZmZWN0IGJ5IHJ1bm5pbmcgdGhlIG1ldGhvZCB3aXRoIHRoZVxuICAgKiB2YWx1ZXMgb2YgdGhlIGFyZ3VtZW50cyBzcGVjaWZpZWQgaW4gdGhlIGBpbmZvYCBvYmplY3QgYW5kIHNldHRpbmcgdGhlXG4gICAqIHJldHVybiB2YWx1ZSB0byB0aGUgY29tcHV0ZWQgcHJvcGVydHkgc3BlY2lmaWVkLlxuICAgKlxuICAgKiBAcGFyYW0geyFQcm9wZXJ0eUVmZmVjdHNUeXBlfSBpbnN0IFRoZSBpbnN0YW5jZSB0aGUgZWZmZWN0IHdpbGwgYmUgcnVuIG9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBOYW1lIG9mIHByb3BlcnR5XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBCYWcgb2YgY3VycmVudCBwcm9wZXJ0eSBjaGFuZ2VzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvbGRQcm9wcyBCYWcgb2YgcHJldmlvdXMgdmFsdWVzIGZvciBjaGFuZ2VkIHByb3BlcnRpZXNcbiAgICogQHBhcmFtIHs/fSBpbmZvIEVmZmVjdCBtZXRhZGF0YVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gcnVuQ29tcHV0ZWRFZmZlY3QoaW5zdCwgcHJvcGVydHksIHByb3BzLCBvbGRQcm9wcywgaW5mbykge1xuICAgIGxldCByZXN1bHQgPSBydW5NZXRob2RFZmZlY3QoaW5zdCwgcHJvcGVydHksIHByb3BzLCBvbGRQcm9wcywgaW5mbyk7XG4gICAgbGV0IGNvbXB1dGVkUHJvcCA9IGluZm8ubWV0aG9kSW5mbztcbiAgICBpZiAoaW5zdC5fX2RhdGFIYXNBY2Nlc3NvciAmJiBpbnN0Ll9fZGF0YUhhc0FjY2Vzc29yW2NvbXB1dGVkUHJvcF0pIHtcbiAgICAgIGluc3QuX3NldFBlbmRpbmdQcm9wZXJ0eShjb21wdXRlZFByb3AsIHJlc3VsdCwgdHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluc3RbY29tcHV0ZWRQcm9wXSA9IHJlc3VsdDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ29tcHV0ZXMgcGF0aCBjaGFuZ2VzIGJhc2VkIG9uIHBhdGggbGlua3Mgc2V0IHVwIHVzaW5nIHRoZSBgbGlua1BhdGhzYFxuICAgKiBBUEkuXG4gICAqXG4gICAqIEBwYXJhbSB7IVByb3BlcnR5RWZmZWN0c1R5cGV9IGluc3QgVGhlIGluc3RhbmNlIHdob3NlIHByb3BzIGFyZSBjaGFuZ2luZ1xuICAgKiBAcGFyYW0ge3N0cmluZyB8ICFBcnJheTwoc3RyaW5nfG51bWJlcik+fSBwYXRoIFBhdGggdGhhdCBoYXMgY2hhbmdlZFxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIG9mIGNoYW5nZWQgcGF0aFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gY29tcHV0ZUxpbmtlZFBhdGhzKGluc3QsIHBhdGgsIHZhbHVlKSB7XG4gICAgbGV0IGxpbmtzID0gaW5zdC5fX2RhdGFMaW5rZWRQYXRocztcbiAgICBpZiAobGlua3MpIHtcbiAgICAgIGxldCBsaW5rO1xuICAgICAgZm9yIChsZXQgYSBpbiBsaW5rcykge1xuICAgICAgICBsZXQgYiA9IGxpbmtzW2FdO1xuICAgICAgICBpZiAoUG9seW1lci5QYXRoLmlzRGVzY2VuZGFudChhLCBwYXRoKSkge1xuICAgICAgICAgIGxpbmsgPSBQb2x5bWVyLlBhdGgudHJhbnNsYXRlKGEsIGIsIHBhdGgpO1xuICAgICAgICAgIGluc3QuX3NldFBlbmRpbmdQcm9wZXJ0eU9yUGF0aChsaW5rLCB2YWx1ZSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoUG9seW1lci5QYXRoLmlzRGVzY2VuZGFudChiLCBwYXRoKSkge1xuICAgICAgICAgIGxpbmsgPSBQb2x5bWVyLlBhdGgudHJhbnNsYXRlKGIsIGEsIHBhdGgpO1xuICAgICAgICAgIGluc3QuX3NldFBlbmRpbmdQcm9wZXJ0eU9yUGF0aChsaW5rLCB2YWx1ZSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyAtLSBiaW5kaW5ncyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLyoqXG4gICAqIEFkZHMgYmluZGluZyBtZXRhZGF0YSB0byB0aGUgY3VycmVudCBgbm9kZUluZm9gLCBhbmQgYmluZGluZyBlZmZlY3RzXG4gICAqIGZvciBhbGwgcGFydCBkZXBlbmRlbmNpZXMgdG8gYHRlbXBsYXRlSW5mb2AuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbnN0cnVjdG9yIENsYXNzIHRoYXQgYF9wYXJzZVRlbXBsYXRlYCBpcyBjdXJyZW50bHlcbiAgICogICBydW5uaW5nIG9uXG4gICAqIEBwYXJhbSB7VGVtcGxhdGVJbmZvfSB0ZW1wbGF0ZUluZm8gVGVtcGxhdGUgbWV0YWRhdGEgZm9yIGN1cnJlbnQgdGVtcGxhdGVcbiAgICogQHBhcmFtIHtOb2RlSW5mb30gbm9kZUluZm8gTm9kZSBtZXRhZGF0YSBmb3IgY3VycmVudCB0ZW1wbGF0ZSBub2RlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBraW5kIEJpbmRpbmcga2luZCwgZWl0aGVyICdwcm9wZXJ0eScsICdhdHRyaWJ1dGUnLCBvciAndGV4dCdcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRhcmdldCBUYXJnZXQgcHJvcGVydHkgbmFtZVxuICAgKiBAcGFyYW0geyFBcnJheTwhQmluZGluZ1BhcnQ+fSBwYXJ0cyBBcnJheSBvZiBiaW5kaW5nIHBhcnQgbWV0YWRhdGFcbiAgICogQHBhcmFtIHtzdHJpbmc9fSBsaXRlcmFsIExpdGVyYWwgdGV4dCBzdXJyb3VuZGluZyBiaW5kaW5nIHBhcnRzIChzcGVjaWZpZWRcbiAgICogICBvbmx5IGZvciAncHJvcGVydHknIGJpbmRpbmdzLCBzaW5jZSB0aGVzZSBtdXN0IGJlIGluaXRpYWxpemVkIGFzIHBhcnRcbiAgICogICBvZiBib290LXVwKVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gYWRkQmluZGluZyhjb25zdHJ1Y3RvciwgdGVtcGxhdGVJbmZvLCBub2RlSW5mbywga2luZCwgdGFyZ2V0LCBwYXJ0cywgbGl0ZXJhbCkge1xuICAgIC8vIENyZWF0ZSBiaW5kaW5nIG1ldGFkYXRhIGFuZCBhZGQgdG8gbm9kZUluZm9cbiAgICBub2RlSW5mby5iaW5kaW5ncyA9IG5vZGVJbmZvLmJpbmRpbmdzIHx8IFtdO1xuICAgIGxldCAvKiogQmluZGluZyAqLyBiaW5kaW5nID0geyBraW5kLCB0YXJnZXQsIHBhcnRzLCBsaXRlcmFsLCBpc0NvbXBvdW5kOiAocGFydHMubGVuZ3RoICE9PSAxKSB9O1xuICAgIG5vZGVJbmZvLmJpbmRpbmdzLnB1c2goYmluZGluZyk7XG4gICAgLy8gQWRkIGxpc3RlbmVyIGluZm8gdG8gYmluZGluZyBtZXRhZGF0YVxuICAgIGlmIChzaG91bGRBZGRMaXN0ZW5lcihiaW5kaW5nKSkge1xuICAgICAgbGV0IHtldmVudCwgbmVnYXRlfSA9IGJpbmRpbmcucGFydHNbMF07XG4gICAgICBiaW5kaW5nLmxpc3RlbmVyRXZlbnQgPSBldmVudCB8fCAoQ2FzZU1hcC5jYW1lbFRvRGFzaENhc2UodGFyZ2V0KSArICctY2hhbmdlZCcpO1xuICAgICAgYmluZGluZy5saXN0ZW5lck5lZ2F0ZSA9IG5lZ2F0ZTtcbiAgICB9XG4gICAgLy8gQWRkIFwicHJvcGFnYXRlXCIgcHJvcGVydHkgZWZmZWN0cyB0byB0ZW1wbGF0ZUluZm9cbiAgICBsZXQgaW5kZXggPSB0ZW1wbGF0ZUluZm8ubm9kZUluZm9MaXN0Lmxlbmd0aDtcbiAgICBmb3IgKGxldCBpPTA7IGk8YmluZGluZy5wYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IHBhcnQgPSBiaW5kaW5nLnBhcnRzW2ldO1xuICAgICAgcGFydC5jb21wb3VuZEluZGV4ID0gaTtcbiAgICAgIGFkZEVmZmVjdEZvckJpbmRpbmdQYXJ0KGNvbnN0cnVjdG9yLCB0ZW1wbGF0ZUluZm8sIGJpbmRpbmcsIHBhcnQsIGluZGV4KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBwcm9wZXJ0eSBlZmZlY3RzIHRvIHRoZSBnaXZlbiBgdGVtcGxhdGVJbmZvYCBmb3IgdGhlIGdpdmVuIGJpbmRpbmdcbiAgICogcGFydC5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY29uc3RydWN0b3IgQ2xhc3MgdGhhdCBgX3BhcnNlVGVtcGxhdGVgIGlzIGN1cnJlbnRseVxuICAgKiAgIHJ1bm5pbmcgb25cbiAgICogQHBhcmFtIHtUZW1wbGF0ZUluZm99IHRlbXBsYXRlSW5mbyBUZW1wbGF0ZSBtZXRhZGF0YSBmb3IgY3VycmVudCB0ZW1wbGF0ZVxuICAgKiBAcGFyYW0geyFCaW5kaW5nfSBiaW5kaW5nIEJpbmRpbmcgbWV0YWRhdGFcbiAgICogQHBhcmFtIHshQmluZGluZ1BhcnR9IHBhcnQgQmluZGluZyBwYXJ0IG1ldGFkYXRhXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleCBpbnRvIGBub2RlSW5mb0xpc3RgIGZvciB0aGlzIG5vZGVcbiAgICovXG4gIGZ1bmN0aW9uIGFkZEVmZmVjdEZvckJpbmRpbmdQYXJ0KGNvbnN0cnVjdG9yLCB0ZW1wbGF0ZUluZm8sIGJpbmRpbmcsIHBhcnQsIGluZGV4KSB7XG4gICAgaWYgKCFwYXJ0LmxpdGVyYWwpIHtcbiAgICAgIGlmIChiaW5kaW5nLmtpbmQgPT09ICdhdHRyaWJ1dGUnICYmIGJpbmRpbmcudGFyZ2V0WzBdID09PSAnLScpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdDYW5ub3Qgc2V0IGF0dHJpYnV0ZSAnICsgYmluZGluZy50YXJnZXQgK1xuICAgICAgICAgICcgYmVjYXVzZSBcIi1cIiBpcyBub3QgYSB2YWxpZCBhdHRyaWJ1dGUgc3RhcnRpbmcgY2hhcmFjdGVyJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgZGVwZW5kZW5jaWVzID0gcGFydC5kZXBlbmRlbmNpZXM7XG4gICAgICAgIGxldCBpbmZvID0geyBpbmRleCwgYmluZGluZywgcGFydCwgZXZhbHVhdG9yOiBjb25zdHJ1Y3RvciB9O1xuICAgICAgICBmb3IgKGxldCBqPTA7IGo8ZGVwZW5kZW5jaWVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgbGV0IHRyaWdnZXIgPSBkZXBlbmRlbmNpZXNbal07XG4gICAgICAgICAgaWYgKHR5cGVvZiB0cmlnZ2VyID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0cmlnZ2VyID0gcGFyc2VBcmcodHJpZ2dlcik7XG4gICAgICAgICAgICB0cmlnZ2VyLndpbGRjYXJkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3RydWN0b3IuX2FkZFRlbXBsYXRlUHJvcGVydHlFZmZlY3QodGVtcGxhdGVJbmZvLCB0cmlnZ2VyLnJvb3RQcm9wZXJ0eSwge1xuICAgICAgICAgICAgZm46IHJ1bkJpbmRpbmdFZmZlY3QsXG4gICAgICAgICAgICBpbmZvLCB0cmlnZ2VyXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSW1wbGVtZW50cyB0aGUgXCJiaW5kaW5nXCIgKHByb3BlcnR5L3BhdGggYmluZGluZykgZWZmZWN0LlxuICAgKlxuICAgKiBOb3RlIHRoYXQgYmluZGluZyBzeW50YXggaXMgb3ZlcnJpZGFibGUgdmlhIGBfcGFyc2VCaW5kaW5nc2AgYW5kXG4gICAqIGBfZXZhbHVhdGVCaW5kaW5nYC4gIFRoaXMgbWV0aG9kIHdpbGwgY2FsbCBgX2V2YWx1YXRlQmluZGluZ2AgZm9yIGFueVxuICAgKiBub24tbGl0ZXJhbCBwYXJ0cyByZXR1cm5lZCBmcm9tIGBfcGFyc2VCaW5kaW5nc2AuICBIb3dldmVyLFxuICAgKiB0aGVyZSBpcyBubyBzdXBwb3J0IGZvciBfcGF0aF8gYmluZGluZ3MgdmlhIGN1c3RvbSBiaW5kaW5nIHBhcnRzLFxuICAgKiBhcyB0aGlzIGlzIHNwZWNpZmljIHRvIFBvbHltZXIncyBwYXRoIGJpbmRpbmcgc3ludGF4LlxuICAgKlxuICAgKiBAcGFyYW0geyFQcm9wZXJ0eUVmZmVjdHNUeXBlfSBpbnN0IFRoZSBpbnN0YW5jZSB0aGUgZWZmZWN0IHdpbGwgYmUgcnVuIG9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIE5hbWUgb2YgcHJvcGVydHlcbiAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzIEJhZyBvZiBjdXJyZW50IHByb3BlcnR5IGNoYW5nZXNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9sZFByb3BzIEJhZyBvZiBwcmV2aW91cyB2YWx1ZXMgZm9yIGNoYW5nZWQgcHJvcGVydGllc1xuICAgKiBAcGFyYW0gez99IGluZm8gRWZmZWN0IG1ldGFkYXRhXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaGFzUGF0aHMgVHJ1ZSB3aXRoIGBwcm9wc2AgY29udGFpbnMgb25lIG9yIG1vcmUgcGF0aHNcbiAgICogQHBhcmFtIHtBcnJheX0gbm9kZUxpc3QgTGlzdCBvZiBub2RlcyBhc3NvY2lhdGVkIHdpdGggYG5vZGVJbmZvTGlzdGAgdGVtcGxhdGVcbiAgICogICBtZXRhZGF0YVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gcnVuQmluZGluZ0VmZmVjdChpbnN0LCBwYXRoLCBwcm9wcywgb2xkUHJvcHMsIGluZm8sIGhhc1BhdGhzLCBub2RlTGlzdCkge1xuICAgIGxldCBub2RlID0gbm9kZUxpc3RbaW5mby5pbmRleF07XG4gICAgbGV0IGJpbmRpbmcgPSBpbmZvLmJpbmRpbmc7XG4gICAgbGV0IHBhcnQgPSBpbmZvLnBhcnQ7XG4gICAgLy8gU3VicGF0aCBub3RpZmljYXRpb246IHRyYW5zZm9ybSBwYXRoIGFuZCBzZXQgdG8gY2xpZW50XG4gICAgLy8gZS5nLjogZm9vPVwie3tvYmouc3VifX1cIiwgcGF0aDogJ29iai5zdWIucHJvcCcsIHNldCAnZm9vLnByb3AnPW9iai5zdWIucHJvcFxuICAgIGlmIChoYXNQYXRocyAmJiBwYXJ0LnNvdXJjZSAmJiAocGF0aC5sZW5ndGggPiBwYXJ0LnNvdXJjZS5sZW5ndGgpICYmXG4gICAgICAgIChiaW5kaW5nLmtpbmQgPT0gJ3Byb3BlcnR5JykgJiYgIWJpbmRpbmcuaXNDb21wb3VuZCAmJlxuICAgICAgICBub2RlLl9fZGF0YUhhc0FjY2Vzc29yICYmIG5vZGUuX19kYXRhSGFzQWNjZXNzb3JbYmluZGluZy50YXJnZXRdKSB7XG4gICAgICBsZXQgdmFsdWUgPSBwcm9wc1twYXRoXTtcbiAgICAgIHBhdGggPSBQb2x5bWVyLlBhdGgudHJhbnNsYXRlKHBhcnQuc291cmNlLCBiaW5kaW5nLnRhcmdldCwgcGF0aCk7XG4gICAgICBpZiAobm9kZS5fc2V0UGVuZGluZ1Byb3BlcnR5T3JQYXRoKHBhdGgsIHZhbHVlLCBmYWxzZSwgdHJ1ZSkpIHtcbiAgICAgICAgaW5zdC5fZW5xdWV1ZUNsaWVudChub2RlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IHZhbHVlID0gaW5mby5ldmFsdWF0b3IuX2V2YWx1YXRlQmluZGluZyhpbnN0LCBwYXJ0LCBwYXRoLCBwcm9wcywgb2xkUHJvcHMsIGhhc1BhdGhzKTtcbiAgICAgIC8vIFByb3BhZ2F0ZSB2YWx1ZSB0byBjaGlsZFxuICAgICAgYXBwbHlCaW5kaW5nVmFsdWUoaW5zdCwgbm9kZSwgYmluZGluZywgcGFydCwgdmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSB2YWx1ZSBmb3IgYW4gXCJiaW5kaW5nXCIgKGJpbmRpbmcpIGVmZmVjdCB0byBhIG5vZGUsXG4gICAqIGVpdGhlciBhcyBhIHByb3BlcnR5IG9yIGF0dHJpYnV0ZS5cbiAgICpcbiAgICogQHBhcmFtIHshUHJvcGVydHlFZmZlY3RzVHlwZX0gaW5zdCBUaGUgaW5zdGFuY2Ugb3duaW5nIHRoZSBiaW5kaW5nIGVmZmVjdFxuICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgVGFyZ2V0IG5vZGUgZm9yIGJpbmRpbmdcbiAgICogQHBhcmFtIHshQmluZGluZ30gYmluZGluZyBCaW5kaW5nIG1ldGFkYXRhXG4gICAqIEBwYXJhbSB7IUJpbmRpbmdQYXJ0fSBwYXJ0IEJpbmRpbmcgcGFydCBtZXRhZGF0YVxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIHNldFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gYXBwbHlCaW5kaW5nVmFsdWUoaW5zdCwgbm9kZSwgYmluZGluZywgcGFydCwgdmFsdWUpIHtcbiAgICB2YWx1ZSA9IGNvbXB1dGVCaW5kaW5nVmFsdWUobm9kZSwgdmFsdWUsIGJpbmRpbmcsIHBhcnQpO1xuICAgIGlmIChQb2x5bWVyLnNhbml0aXplRE9NVmFsdWUpIHtcbiAgICAgIHZhbHVlID0gUG9seW1lci5zYW5pdGl6ZURPTVZhbHVlKHZhbHVlLCBiaW5kaW5nLnRhcmdldCwgYmluZGluZy5raW5kLCBub2RlKTtcbiAgICB9XG4gICAgaWYgKGJpbmRpbmcua2luZCA9PSAnYXR0cmlidXRlJykge1xuICAgICAgLy8gQXR0cmlidXRlIGJpbmRpbmdcbiAgICAgIGluc3QuX3ZhbHVlVG9Ob2RlQXR0cmlidXRlKC8qKiBAdHlwZSB7RWxlbWVudH0gKi8obm9kZSksIHZhbHVlLCBiaW5kaW5nLnRhcmdldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFByb3BlcnR5IGJpbmRpbmdcbiAgICAgIGxldCBwcm9wID0gYmluZGluZy50YXJnZXQ7XG4gICAgICBpZiAobm9kZS5fX2RhdGFIYXNBY2Nlc3NvciAmJiBub2RlLl9fZGF0YUhhc0FjY2Vzc29yW3Byb3BdKSB7XG4gICAgICAgIGlmICghbm9kZVtUWVBFUy5SRUFEX09OTFldIHx8ICFub2RlW1RZUEVTLlJFQURfT05MWV1bcHJvcF0pIHtcbiAgICAgICAgICBpZiAobm9kZS5fc2V0UGVuZGluZ1Byb3BlcnR5KHByb3AsIHZhbHVlKSkge1xuICAgICAgICAgICAgaW5zdC5fZW5xdWV1ZUNsaWVudChub2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSAge1xuICAgICAgICBpbnN0Ll9zZXRVbm1hbmFnZWRQcm9wZXJ0eVRvTm9kZShub2RlLCBwcm9wLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRyYW5zZm9ybXMgYW4gXCJiaW5kaW5nXCIgZWZmZWN0IHZhbHVlIGJhc2VkIG9uIGNvbXBvdW5kICYgbmVnYXRpb25cbiAgICogZWZmZWN0IG1ldGFkYXRhLCBhcyB3ZWxsIGFzIGhhbmRsaW5nIGZvciBzcGVjaWFsLWNhc2UgcHJvcGVydGllc1xuICAgKlxuICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgTm9kZSB0aGUgdmFsdWUgd2lsbCBiZSBzZXQgdG9cbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byBzZXRcbiAgICogQHBhcmFtIHshQmluZGluZ30gYmluZGluZyBCaW5kaW5nIG1ldGFkYXRhXG4gICAqIEBwYXJhbSB7IUJpbmRpbmdQYXJ0fSBwYXJ0IEJpbmRpbmcgcGFydCBtZXRhZGF0YVxuICAgKiBAcmV0dXJuIHsqfSBUcmFuc2Zvcm1lZCB2YWx1ZSB0byBzZXRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIGNvbXB1dGVCaW5kaW5nVmFsdWUobm9kZSwgdmFsdWUsIGJpbmRpbmcsIHBhcnQpIHtcbiAgICBpZiAoYmluZGluZy5pc0NvbXBvdW5kKSB7XG4gICAgICBsZXQgc3RvcmFnZSA9IG5vZGUuX19kYXRhQ29tcG91bmRTdG9yYWdlW2JpbmRpbmcudGFyZ2V0XTtcbiAgICAgIHN0b3JhZ2VbcGFydC5jb21wb3VuZEluZGV4XSA9IHZhbHVlO1xuICAgICAgdmFsdWUgPSBzdG9yYWdlLmpvaW4oJycpO1xuICAgIH1cbiAgICBpZiAoYmluZGluZy5raW5kICE9PSAnYXR0cmlidXRlJykge1xuICAgICAgLy8gU29tZSBicm93c2VycyBzZXJpYWxpemUgYHVuZGVmaW5lZGAgdG8gYFwidW5kZWZpbmVkXCJgXG4gICAgICBpZiAoYmluZGluZy50YXJnZXQgPT09ICd0ZXh0Q29udGVudCcgfHxcbiAgICAgICAgICAobm9kZS5sb2NhbE5hbWUgPT0gJ2lucHV0JyAmJiBiaW5kaW5nLnRhcmdldCA9PSAndmFsdWUnKSkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlID09IHVuZGVmaW5lZCA/ICcnIDogdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgYSBiaW5kaW5nJ3MgbWV0YWRhdGEgbWVldHMgYWxsIHRoZSByZXF1aXJlbWVudHMgdG8gYWxsb3dcbiAgICogMi13YXkgYmluZGluZywgYW5kIHRoZXJlZm9yZSBhIGA8cHJvcGVydHk+LWNoYW5nZWRgIGV2ZW50IGxpc3RlbmVyIHNob3VsZCBiZVxuICAgKiBhZGRlZDpcbiAgICogLSB1c2VkIGN1cmx5IGJyYWNlc1xuICAgKiAtIGlzIGEgcHJvcGVydHkgKG5vdCBhdHRyaWJ1dGUpIGJpbmRpbmdcbiAgICogLSBpcyBub3QgYSB0ZXh0Q29udGVudCBiaW5kaW5nXG4gICAqIC0gaXMgbm90IGNvbXBvdW5kXG4gICAqXG4gICAqIEBwYXJhbSB7IUJpbmRpbmd9IGJpbmRpbmcgQmluZGluZyBtZXRhZGF0YVxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIDItd2F5IGxpc3RlbmVyIHNob3VsZCBiZSBhZGRlZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gc2hvdWxkQWRkTGlzdGVuZXIoYmluZGluZykge1xuICAgIHJldHVybiBCb29sZWFuKGJpbmRpbmcudGFyZ2V0KSAmJlxuICAgICAgICAgICBiaW5kaW5nLmtpbmQgIT0gJ2F0dHJpYnV0ZScgJiZcbiAgICAgICAgICAgYmluZGluZy5raW5kICE9ICd0ZXh0JyAmJlxuICAgICAgICAgICAhYmluZGluZy5pc0NvbXBvdW5kICYmXG4gICAgICAgICAgIGJpbmRpbmcucGFydHNbMF0ubW9kZSA9PT0gJ3snO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHVwIGNvbXBvdW5kIGJpbmRpbmcgc3RvcmFnZSBzdHJ1Y3R1cmVzLCBub3RpZnkgbGlzdGVuZXJzLCBhbmQgZGF0YUhvc3RcbiAgICogcmVmZXJlbmNlcyBvbnRvIHRoZSBib3VuZCBub2RlTGlzdC5cbiAgICpcbiAgICogQHBhcmFtIHshUHJvcGVydHlFZmZlY3RzVHlwZX0gaW5zdCBJbnN0YW5jZSB0aGF0IGJhcyBiZWVuIHByZXZpb3VzbHkgYm91bmRcbiAgICogQHBhcmFtIHtUZW1wbGF0ZUluZm99IHRlbXBsYXRlSW5mbyBUZW1wbGF0ZSBtZXRhZGF0YVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gc2V0dXBCaW5kaW5ncyhpbnN0LCB0ZW1wbGF0ZUluZm8pIHtcbiAgICAvLyBTZXR1cCBjb21wb3VuZCBzdG9yYWdlLCBkYXRhSG9zdCwgYW5kIG5vdGlmeSBsaXN0ZW5lcnNcbiAgICBsZXQge25vZGVMaXN0LCBub2RlSW5mb0xpc3R9ID0gdGVtcGxhdGVJbmZvO1xuICAgIGlmIChub2RlSW5mb0xpc3QubGVuZ3RoKSB7XG4gICAgICBmb3IgKGxldCBpPTA7IGkgPCBub2RlSW5mb0xpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGluZm8gPSBub2RlSW5mb0xpc3RbaV07XG4gICAgICAgIGxldCBub2RlID0gbm9kZUxpc3RbaV07XG4gICAgICAgIGxldCBiaW5kaW5ncyA9IGluZm8uYmluZGluZ3M7XG4gICAgICAgIGlmIChiaW5kaW5ncykge1xuICAgICAgICAgIGZvciAobGV0IGk9MDsgaTxiaW5kaW5ncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGJpbmRpbmcgPSBiaW5kaW5nc1tpXTtcbiAgICAgICAgICAgIHNldHVwQ29tcG91bmRTdG9yYWdlKG5vZGUsIGJpbmRpbmcpO1xuICAgICAgICAgICAgYWRkTm90aWZ5TGlzdGVuZXIobm9kZSwgaW5zdCwgYmluZGluZyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG5vZGUuX19kYXRhSG9zdCA9IGluc3Q7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIGBfX2RhdGFDb21wb3VuZFN0b3JhZ2VgIGxvY2FsIHN0b3JhZ2Ugb24gYSBib3VuZCBub2RlIHdpdGhcbiAgICogaW5pdGlhbCBsaXRlcmFsIGRhdGEgZm9yIGNvbXBvdW5kIGJpbmRpbmdzLCBhbmQgc2V0cyB0aGUgam9pbmVkXG4gICAqIGxpdGVyYWwgcGFydHMgdG8gdGhlIGJvdW5kIHByb3BlcnR5LlxuICAgKlxuICAgKiBXaGVuIGNoYW5nZXMgdG8gY29tcG91bmQgcGFydHMgb2NjdXIsIHRoZXkgYXJlIGZpcnN0IHNldCBpbnRvIHRoZSBjb21wb3VuZFxuICAgKiBzdG9yYWdlIGFycmF5IGZvciB0aGF0IHByb3BlcnR5LCBhbmQgdGhlbiB0aGUgYXJyYXkgaXMgam9pbmVkIHRvIHJlc3VsdCBpblxuICAgKiB0aGUgZmluYWwgdmFsdWUgc2V0IHRvIHRoZSBwcm9wZXJ0eS9hdHRyaWJ1dGUuXG4gICAqXG4gICAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBCb3VuZCBub2RlIHRvIGluaXRpYWxpemVcbiAgICogQHBhcmFtIHtCaW5kaW5nfSBiaW5kaW5nIEJpbmRpbmcgbWV0YWRhdGFcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIHNldHVwQ29tcG91bmRTdG9yYWdlKG5vZGUsIGJpbmRpbmcpIHtcbiAgICBpZiAoYmluZGluZy5pc0NvbXBvdW5kKSB7XG4gICAgICAvLyBDcmVhdGUgY29tcG91bmQgc3RvcmFnZSBtYXBcbiAgICAgIGxldCBzdG9yYWdlID0gbm9kZS5fX2RhdGFDb21wb3VuZFN0b3JhZ2UgfHxcbiAgICAgICAgKG5vZGUuX19kYXRhQ29tcG91bmRTdG9yYWdlID0ge30pO1xuICAgICAgbGV0IHBhcnRzID0gYmluZGluZy5wYXJ0cztcbiAgICAgIC8vIENvcHkgbGl0ZXJhbHMgZnJvbSBwYXJ0cyBpbnRvIHN0b3JhZ2UgZm9yIHRoaXMgYmluZGluZ1xuICAgICAgbGV0IGxpdGVyYWxzID0gbmV3IEFycmF5KHBhcnRzLmxlbmd0aCk7XG4gICAgICBmb3IgKGxldCBqPTA7IGo8cGFydHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgbGl0ZXJhbHNbal0gPSBwYXJ0c1tqXS5saXRlcmFsO1xuICAgICAgfVxuICAgICAgbGV0IHRhcmdldCA9IGJpbmRpbmcudGFyZ2V0O1xuICAgICAgc3RvcmFnZVt0YXJnZXRdID0gbGl0ZXJhbHM7XG4gICAgICAvLyBDb25maWd1cmUgcHJvcGVydGllcyB3aXRoIHRoZWlyIGxpdGVyYWwgcGFydHNcbiAgICAgIGlmIChiaW5kaW5nLmxpdGVyYWwgJiYgYmluZGluZy5raW5kID09ICdwcm9wZXJ0eScpIHtcbiAgICAgICAgbm9kZVt0YXJnZXRdID0gYmluZGluZy5saXRlcmFsO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgMi13YXkgYmluZGluZyBub3RpZmljYXRpb24gZXZlbnQgbGlzdGVuZXIgdG8gdGhlIG5vZGUgc3BlY2lmaWVkXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBub2RlIENoaWxkIGVsZW1lbnQgdG8gYWRkIGxpc3RlbmVyIHRvXG4gICAqIEBwYXJhbSB7IVByb3BlcnR5RWZmZWN0c1R5cGV9IGluc3QgSG9zdCBlbGVtZW50IGluc3RhbmNlIHRvIGhhbmRsZSBub3RpZmljYXRpb24gZXZlbnRcbiAgICogQHBhcmFtIHtCaW5kaW5nfSBiaW5kaW5nIEJpbmRpbmcgbWV0YWRhdGFcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIGFkZE5vdGlmeUxpc3RlbmVyKG5vZGUsIGluc3QsIGJpbmRpbmcpIHtcbiAgICBpZiAoYmluZGluZy5saXN0ZW5lckV2ZW50KSB7XG4gICAgICBsZXQgcGFydCA9IGJpbmRpbmcucGFydHNbMF07XG4gICAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoYmluZGluZy5saXN0ZW5lckV2ZW50LCBmdW5jdGlvbihlKSB7XG4gICAgICAgIGhhbmRsZU5vdGlmaWNhdGlvbihlLCBpbnN0LCBiaW5kaW5nLnRhcmdldCwgcGFydC5zb3VyY2UsIHBhcnQubmVnYXRlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8vIC0tIGZvciBtZXRob2QtYmFzZWQgZWZmZWN0cyAoY29tcGxleE9ic2VydmVyICYgY29tcHV0ZWQpIC0tLS0tLS0tLS0tLS0tXG5cbiAgLyoqXG4gICAqIEFkZHMgcHJvcGVydHkgZWZmZWN0cyBmb3IgZWFjaCBhcmd1bWVudCBpbiB0aGUgbWV0aG9kIHNpZ25hdHVyZSAoYW5kXG4gICAqIG9wdGlvbmFsbHksIGZvciB0aGUgbWV0aG9kIG5hbWUgaWYgYGR5bmFtaWNgIGlzIHRydWUpIHRoYXQgY2FsbHMgdGhlXG4gICAqIHByb3ZpZGVkIGVmZmVjdCBmdW5jdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtFbGVtZW50IHwgT2JqZWN0fSBtb2RlbCBQcm90b3R5cGUgb3IgaW5zdGFuY2VcbiAgICogQHBhcmFtIHshTWV0aG9kU2lnbmF0dXJlfSBzaWcgTWV0aG9kIHNpZ25hdHVyZSBtZXRhZGF0YVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBUeXBlIG9mIHByb3BlcnR5IGVmZmVjdCB0byBhZGRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZWZmZWN0Rm4gRnVuY3Rpb24gdG8gcnVuIHdoZW4gYXJndW1lbnRzIGNoYW5nZVxuICAgKiBAcGFyYW0geyo9fSBtZXRob2RJbmZvIEVmZmVjdC1zcGVjaWZpYyBpbmZvcm1hdGlvbiB0byBiZSBpbmNsdWRlZCBpblxuICAgKiAgIG1ldGhvZCBlZmZlY3QgbWV0YWRhdGFcbiAgICogQHBhcmFtIHtib29sZWFufE9iamVjdD19IGR5bmFtaWNGbiBCb29sZWFuIG9yIG9iamVjdCBtYXAgaW5kaWNhdGluZyB3aGV0aGVyXG4gICAqICAgbWV0aG9kIG5hbWVzIHNob3VsZCBiZSBpbmNsdWRlZCBhcyBhIGRlcGVuZGVuY3kgdG8gdGhlIGVmZmVjdC4gTm90ZSxcbiAgICogICBkZWZhdWx0cyB0byB0cnVlIGlmIHRoZSBzaWduYXR1cmUgaXMgc3RhdGljIChzaWcuc3RhdGljIGlzIHRydWUpLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gY3JlYXRlTWV0aG9kRWZmZWN0KG1vZGVsLCBzaWcsIHR5cGUsIGVmZmVjdEZuLCBtZXRob2RJbmZvLCBkeW5hbWljRm4pIHtcbiAgICBkeW5hbWljRm4gPSBzaWcuc3RhdGljIHx8IChkeW5hbWljRm4gJiZcbiAgICAgICh0eXBlb2YgZHluYW1pY0ZuICE9PSAnb2JqZWN0JyB8fCBkeW5hbWljRm5bc2lnLm1ldGhvZE5hbWVdKSk7XG4gICAgbGV0IGluZm8gPSB7XG4gICAgICBtZXRob2ROYW1lOiBzaWcubWV0aG9kTmFtZSxcbiAgICAgIGFyZ3M6IHNpZy5hcmdzLFxuICAgICAgbWV0aG9kSW5mbyxcbiAgICAgIGR5bmFtaWNGblxuICAgIH07XG4gICAgZm9yIChsZXQgaT0wLCBhcmc7IChpPHNpZy5hcmdzLmxlbmd0aCkgJiYgKGFyZz1zaWcuYXJnc1tpXSk7IGkrKykge1xuICAgICAgaWYgKCFhcmcubGl0ZXJhbCkge1xuICAgICAgICBtb2RlbC5fYWRkUHJvcGVydHlFZmZlY3QoYXJnLnJvb3RQcm9wZXJ0eSwgdHlwZSwge1xuICAgICAgICAgIGZuOiBlZmZlY3RGbiwgaW5mbzogaW5mbywgdHJpZ2dlcjogYXJnXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZHluYW1pY0ZuKSB7XG4gICAgICBtb2RlbC5fYWRkUHJvcGVydHlFZmZlY3Qoc2lnLm1ldGhvZE5hbWUsIHR5cGUsIHtcbiAgICAgICAgZm46IGVmZmVjdEZuLCBpbmZvOiBpbmZvXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2FsbHMgYSBtZXRob2Qgd2l0aCBhcmd1bWVudHMgbWFyc2hhbGVkIGZyb20gcHJvcGVydGllcyBvbiB0aGUgaW5zdGFuY2VcbiAgICogYmFzZWQgb24gdGhlIG1ldGhvZCBzaWduYXR1cmUgY29udGFpbmVkIGluIHRoZSBlZmZlY3QgbWV0YWRhdGEuXG4gICAqXG4gICAqIE11bHRpLXByb3BlcnR5IG9ic2VydmVycywgY29tcHV0ZWQgcHJvcGVydGllcywgYW5kIGlubGluZSBjb21wdXRpbmdcbiAgICogZnVuY3Rpb25zIGNhbGwgdGhpcyBmdW5jdGlvbiB0byBpbnZva2UgdGhlIG1ldGhvZCwgdGhlbiB1c2UgdGhlIHJldHVyblxuICAgKiB2YWx1ZSBhY2NvcmRpbmdseS5cbiAgICpcbiAgICogQHBhcmFtIHshUHJvcGVydHlFZmZlY3RzVHlwZX0gaW5zdCBUaGUgaW5zdGFuY2UgdGhlIGVmZmVjdCB3aWxsIGJlIHJ1biBvblxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgTmFtZSBvZiBwcm9wZXJ0eVxuICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgQmFnIG9mIGN1cnJlbnQgcHJvcGVydHkgY2hhbmdlc1xuICAgKiBAcGFyYW0ge09iamVjdH0gb2xkUHJvcHMgQmFnIG9mIHByZXZpb3VzIHZhbHVlcyBmb3IgY2hhbmdlZCBwcm9wZXJ0aWVzXG4gICAqIEBwYXJhbSB7P30gaW5mbyBFZmZlY3QgbWV0YWRhdGFcbiAgICogQHJldHVybiB7Kn0gUmV0dXJucyB0aGUgcmV0dXJuIHZhbHVlIGZyb20gdGhlIG1ldGhvZCBpbnZvY2F0aW9uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBydW5NZXRob2RFZmZlY3QoaW5zdCwgcHJvcGVydHksIHByb3BzLCBvbGRQcm9wcywgaW5mbykge1xuICAgIC8vIEluc3RhbmNlcyBjYW4gb3B0aW9uYWxseSBoYXZlIGEgX21ldGhvZEhvc3Qgd2hpY2ggYWxsb3dzIHJlZGlyZWN0aW5nIHdoZXJlXG4gICAgLy8gdG8gZmluZCBtZXRob2RzLiBDdXJyZW50bHkgdXNlZCBieSBgdGVtcGxhdGl6ZWAuXG4gICAgbGV0IGNvbnRleHQgPSBpbnN0Ll9tZXRob2RIb3N0IHx8IGluc3Q7XG4gICAgbGV0IGZuID0gY29udGV4dFtpbmZvLm1ldGhvZE5hbWVdO1xuICAgIGlmIChmbikge1xuICAgICAgbGV0IGFyZ3MgPSBtYXJzaGFsQXJncyhpbnN0Ll9fZGF0YSwgaW5mby5hcmdzLCBwcm9wZXJ0eSwgcHJvcHMpO1xuICAgICAgcmV0dXJuIGZuLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgIH0gZWxzZSBpZiAoIWluZm8uZHluYW1pY0ZuKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ21ldGhvZCBgJyArIGluZm8ubWV0aG9kTmFtZSArICdgIG5vdCBkZWZpbmVkJyk7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgZW1wdHlBcnJheSA9IFtdO1xuXG4gIC8vIFJlZ3VsYXIgZXhwcmVzc2lvbnMgdXNlZCBmb3IgYmluZGluZ1xuICBjb25zdCBJREVOVCAgPSAnKD86JyArICdbYS16QS1aXyRdW1xcXFx3LjokXFxcXC0qXSonICsgJyknO1xuICBjb25zdCBOVU1CRVIgPSAnKD86JyArICdbLStdP1swLTldKlxcXFwuP1swLTldKyg/OltlRV1bLStdP1swLTldKyk/JyArICcpJztcbiAgY29uc3QgU1FVT1RFX1NUUklORyA9ICcoPzonICsgJ1xcJyg/OlteXFwnXFxcXFxcXFxdfFxcXFxcXFxcLikqXFwnJyArICcpJztcbiAgY29uc3QgRFFVT1RFX1NUUklORyA9ICcoPzonICsgJ1wiKD86W15cIlxcXFxcXFxcXXxcXFxcXFxcXC4pKlwiJyArICcpJztcbiAgY29uc3QgU1RSSU5HID0gJyg/OicgKyBTUVVPVEVfU1RSSU5HICsgJ3wnICsgRFFVT1RFX1NUUklORyArICcpJztcbiAgY29uc3QgQVJHVU1FTlQgPSAnKD86KCcgKyBJREVOVCArICd8JyArIE5VTUJFUiArICd8JyArICBTVFJJTkcgKyAnKVxcXFxzKicgKyAnKSc7XG4gIGNvbnN0IEFSR1VNRU5UUyA9ICcoPzonICsgQVJHVU1FTlQgKyAnKD86LFxcXFxzKicgKyBBUkdVTUVOVCArICcpKicgKyAnKSc7XG4gIGNvbnN0IEFSR1VNRU5UX0xJU1QgPSAnKD86JyArICdcXFxcKFxcXFxzKicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnKD86JyArIEFSR1VNRU5UUyArICc/JyArICcpJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnXFxcXClcXFxccyonICsgJyknO1xuICBjb25zdCBCSU5ESU5HID0gJygnICsgSURFTlQgKyAnXFxcXHMqJyArIEFSR1VNRU5UX0xJU1QgKyAnPycgKyAnKSc7IC8vIEdyb3VwIDNcbiAgY29uc3QgT1BFTl9CUkFDS0VUID0gJyhcXFxcW1xcXFxbfHt7KScgKyAnXFxcXHMqJztcbiAgY29uc3QgQ0xPU0VfQlJBQ0tFVCA9ICcoPzpdXXx9fSknO1xuICBjb25zdCBORUdBVEUgPSAnKD86KCEpXFxcXHMqKT8nOyAvLyBHcm91cCAyXG4gIGNvbnN0IEVYUFJFU1NJT04gPSBPUEVOX0JSQUNLRVQgKyBORUdBVEUgKyBCSU5ESU5HICsgQ0xPU0VfQlJBQ0tFVDtcbiAgY29uc3QgYmluZGluZ1JlZ2V4ID0gbmV3IFJlZ0V4cChFWFBSRVNTSU9OLCBcImdcIik7XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHN0cmluZyBmcm9tIGJpbmRpbmcgcGFydHMgb2YgYWxsIHRoZSBsaXRlcmFsIHBhcnRzXG4gICAqXG4gICAqIEBwYXJhbSB7IUFycmF5PEJpbmRpbmdQYXJ0Pn0gcGFydHMgQWxsIHBhcnRzIHRvIHN0cmluZ2lmeVxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFN0cmluZyBtYWRlIGZyb20gdGhlIGxpdGVyYWwgcGFydHNcbiAgICovXG4gIGZ1bmN0aW9uIGxpdGVyYWxGcm9tUGFydHMocGFydHMpIHtcbiAgICBsZXQgcyA9ICcnO1xuICAgIGZvciAobGV0IGk9MDsgaTxwYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IGxpdGVyYWwgPSBwYXJ0c1tpXS5saXRlcmFsO1xuICAgICAgcyArPSBsaXRlcmFsIHx8ICcnO1xuICAgIH1cbiAgICByZXR1cm4gcztcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZXMgYW4gZXhwcmVzc2lvbiBzdHJpbmcgZm9yIGEgbWV0aG9kIHNpZ25hdHVyZSwgYW5kIHJldHVybnMgYSBtZXRhZGF0YVxuICAgKiBkZXNjcmliaW5nIHRoZSBtZXRob2QgaW4gdGVybXMgb2YgYG1ldGhvZE5hbWVgLCBgc3RhdGljYCAod2hldGhlciBhbGwgdGhlXG4gICAqIGFyZ3VtZW50cyBhcmUgbGl0ZXJhbHMpLCBhbmQgYW4gYXJyYXkgb2YgYGFyZ3NgXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBleHByZXNzaW9uIFRoZSBleHByZXNzaW9uIHRvIHBhcnNlXG4gICAqIEByZXR1cm4gez9NZXRob2RTaWduYXR1cmV9IFRoZSBtZXRob2QgbWV0YWRhdGEgb2JqZWN0IGlmIGEgbWV0aG9kIGV4cHJlc3Npb24gd2FzXG4gICAqICAgZm91bmQsIG90aGVyd2lzZSBgdW5kZWZpbmVkYFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gcGFyc2VNZXRob2QoZXhwcmVzc2lvbikge1xuICAgIC8vIHRyaWVzIHRvIG1hdGNoIHZhbGlkIGphdmFzY3JpcHQgcHJvcGVydHkgbmFtZXNcbiAgICBsZXQgbSA9IGV4cHJlc3Npb24ubWF0Y2goLyhbXlxcc10rPylcXCgoW1xcc1xcU10qKVxcKS8pO1xuICAgIGlmIChtKSB7XG4gICAgICBsZXQgbWV0aG9kTmFtZSA9IG1bMV07XG4gICAgICBsZXQgc2lnID0geyBtZXRob2ROYW1lLCBzdGF0aWM6IHRydWUsIGFyZ3M6IGVtcHR5QXJyYXkgfTtcbiAgICAgIGlmIChtWzJdLnRyaW0oKSkge1xuICAgICAgICAvLyByZXBsYWNlIGVzY2FwZWQgY29tbWFzIHdpdGggY29tbWEgZW50aXR5LCBzcGxpdCBvbiB1bi1lc2NhcGVkIGNvbW1hc1xuICAgICAgICBsZXQgYXJncyA9IG1bMl0ucmVwbGFjZSgvXFxcXCwvZywgJyZjb21tYTsnKS5zcGxpdCgnLCcpO1xuICAgICAgICByZXR1cm4gcGFyc2VBcmdzKGFyZ3MsIHNpZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gc2lnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZXMgYW4gYXJyYXkgb2YgYXJndW1lbnRzIGFuZCBzZXRzIHRoZSBgYXJnc2AgcHJvcGVydHkgb2YgdGhlIHN1cHBsaWVkXG4gICAqIHNpZ25hdHVyZSBtZXRhZGF0YSBvYmplY3QuIFNldHMgdGhlIGBzdGF0aWNgIHByb3BlcnR5IHRvIGZhbHNlIGlmIGFueVxuICAgKiBhcmd1bWVudCBpcyBhIG5vbi1saXRlcmFsLlxuICAgKlxuICAgKiBAcGFyYW0geyFBcnJheTxzdHJpbmc+fSBhcmdMaXN0IEFycmF5IG9mIGFyZ3VtZW50IG5hbWVzXG4gICAqIEBwYXJhbSB7IU1ldGhvZFNpZ25hdHVyZX0gc2lnIE1ldGhvZCBzaWduYXR1cmUgbWV0YWRhdGEgb2JqZWN0XG4gICAqIEByZXR1cm4geyFNZXRob2RTaWduYXR1cmV9IFRoZSB1cGRhdGVkIHNpZ25hdHVyZSBtZXRhZGF0YSBvYmplY3RcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIHBhcnNlQXJncyhhcmdMaXN0LCBzaWcpIHtcbiAgICBzaWcuYXJncyA9IGFyZ0xpc3QubWFwKGZ1bmN0aW9uKHJhd0FyZykge1xuICAgICAgbGV0IGFyZyA9IHBhcnNlQXJnKHJhd0FyZyk7XG4gICAgICBpZiAoIWFyZy5saXRlcmFsKSB7XG4gICAgICAgIHNpZy5zdGF0aWMgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcmc7XG4gICAgfSwgdGhpcyk7XG4gICAgcmV0dXJuIHNpZztcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZXMgYW4gaW5kaXZpZHVhbCBhcmd1bWVudCwgYW5kIHJldHVybnMgYW4gYXJndW1lbnQgbWV0YWRhdGEgb2JqZWN0XG4gICAqIHdpdGggdGhlIGZvbGxvd2luZyBmaWVsZHM6XG4gICAqXG4gICAqICAge1xuICAgKiAgICAgdmFsdWU6ICdwcm9wJywgICAgICAgIC8vIHByb3BlcnR5L3BhdGggb3IgbGl0ZXJhbCB2YWx1ZVxuICAgKiAgICAgbGl0ZXJhbDogZmFsc2UsICAgICAgIC8vIHdoZXRoZXIgYXJndW1lbnQgaXMgYSBsaXRlcmFsXG4gICAqICAgICBzdHJ1Y3R1cmVkOiBmYWxzZSwgICAgLy8gd2hldGhlciB0aGUgcHJvcGVydHkgaXMgYSBwYXRoXG4gICAqICAgICByb290UHJvcGVydHk6ICdwcm9wJywgLy8gdGhlIHJvb3QgcHJvcGVydHkgb2YgdGhlIHBhdGhcbiAgICogICAgIHdpbGRjYXJkOiBmYWxzZSAgICAgICAvLyB3aGV0aGVyIHRoZSBhcmd1bWVudCB3YXMgYSB3aWxkY2FyZCAnLionIHBhdGhcbiAgICogICB9XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByYXdBcmcgVGhlIHN0cmluZyB2YWx1ZSBvZiB0aGUgYXJndW1lbnRcbiAgICogQHJldHVybiB7IU1ldGhvZEFyZ30gQXJndW1lbnQgbWV0YWRhdGEgb2JqZWN0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBwYXJzZUFyZyhyYXdBcmcpIHtcbiAgICAvLyBjbGVhbiB1cCB3aGl0ZXNwYWNlXG4gICAgbGV0IGFyZyA9IHJhd0FyZy50cmltKClcbiAgICAgIC8vIHJlcGxhY2UgY29tbWEgZW50aXR5IHdpdGggY29tbWFcbiAgICAgIC5yZXBsYWNlKC8mY29tbWE7L2csICcsJylcbiAgICAgIC8vIHJlcGFpciBleHRyYSBlc2NhcGUgc2VxdWVuY2VzOyBub3RlIG9ubHkgY29tbWFzIHN0cmljdGx5IG5lZWRcbiAgICAgIC8vIGVzY2FwaW5nLCBidXQgd2UgYWxsb3cgYW55IG90aGVyIGNoYXIgdG8gYmUgZXNjYXBlZCBzaW5jZSBpdHNcbiAgICAgIC8vIGxpa2VseSB1c2VycyB3aWxsIGRvIHRoaXNcbiAgICAgIC5yZXBsYWNlKC9cXFxcKC4pL2csICdcXCQxJylcbiAgICAgIDtcbiAgICAvLyBiYXNpYyBhcmd1bWVudCBkZXNjcmlwdG9yXG4gICAgbGV0IGEgPSB7XG4gICAgICBuYW1lOiBhcmcsXG4gICAgICB2YWx1ZTogJycsXG4gICAgICBsaXRlcmFsOiBmYWxzZVxuICAgIH07XG4gICAgLy8gZGV0ZWN0IGxpdGVyYWwgdmFsdWUgKG11c3QgYmUgU3RyaW5nIG9yIE51bWJlcilcbiAgICBsZXQgZmMgPSBhcmdbMF07XG4gICAgaWYgKGZjID09PSAnLScpIHtcbiAgICAgIGZjID0gYXJnWzFdO1xuICAgIH1cbiAgICBpZiAoZmMgPj0gJzAnICYmIGZjIDw9ICc5Jykge1xuICAgICAgZmMgPSAnIyc7XG4gICAgfVxuICAgIHN3aXRjaChmYykge1xuICAgICAgY2FzZSBcIidcIjpcbiAgICAgIGNhc2UgJ1wiJzpcbiAgICAgICAgYS52YWx1ZSA9IGFyZy5zbGljZSgxLCAtMSk7XG4gICAgICAgIGEubGl0ZXJhbCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnIyc6XG4gICAgICAgIGEudmFsdWUgPSBOdW1iZXIoYXJnKTtcbiAgICAgICAgYS5saXRlcmFsID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIC8vIGlmIG5vdCBsaXRlcmFsLCBsb29rIGZvciBzdHJ1Y3R1cmVkIHBhdGhcbiAgICBpZiAoIWEubGl0ZXJhbCkge1xuICAgICAgYS5yb290UHJvcGVydHkgPSBQb2x5bWVyLlBhdGgucm9vdChhcmcpO1xuICAgICAgLy8gZGV0ZWN0IHN0cnVjdHVyZWQgcGF0aCAoaGFzIGRvdHMpXG4gICAgICBhLnN0cnVjdHVyZWQgPSBQb2x5bWVyLlBhdGguaXNQYXRoKGFyZyk7XG4gICAgICBpZiAoYS5zdHJ1Y3R1cmVkKSB7XG4gICAgICAgIGEud2lsZGNhcmQgPSAoYXJnLnNsaWNlKC0yKSA9PSAnLionKTtcbiAgICAgICAgaWYgKGEud2lsZGNhcmQpIHtcbiAgICAgICAgICBhLm5hbWUgPSBhcmcuc2xpY2UoMCwgLTIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhO1xuICB9XG5cbiAgLyoqXG4gICAqIEdhdGhlciB0aGUgYXJndW1lbnQgdmFsdWVzIGZvciBhIG1ldGhvZCBzcGVjaWZpZWQgaW4gdGhlIHByb3ZpZGVkIGFycmF5XG4gICAqIG9mIGFyZ3VtZW50IG1ldGFkYXRhLlxuICAgKlxuICAgKiBUaGUgYHBhdGhgIGFuZCBgdmFsdWVgIGFyZ3VtZW50cyBhcmUgdXNlZCB0byBmaWxsIGluIHdpbGRjYXJkIGRlc2NyaXB0b3JcbiAgICogd2hlbiB0aGUgbWV0aG9kIGlzIGJlaW5nIGNhbGxlZCBhcyBhIHJlc3VsdCBvZiBhIHBhdGggbm90aWZpY2F0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSBJbnN0YW5jZSBkYXRhIHN0b3JhZ2Ugb2JqZWN0IHRvIHJlYWQgcHJvcGVydGllcyBmcm9tXG4gICAqIEBwYXJhbSB7IUFycmF5PCFNZXRob2RBcmc+fSBhcmdzIEFycmF5IG9mIGFyZ3VtZW50IG1ldGFkYXRhXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFByb3BlcnR5L3BhdGggbmFtZSB0aGF0IHRyaWdnZXJlZCB0aGUgbWV0aG9kIGVmZmVjdFxuICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgQmFnIG9mIGN1cnJlbnQgcHJvcGVydHkgY2hhbmdlc1xuICAgKiBAcmV0dXJuIHtBcnJheTwqPn0gQXJyYXkgb2YgYXJndW1lbnQgdmFsdWVzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBtYXJzaGFsQXJncyhkYXRhLCBhcmdzLCBwYXRoLCBwcm9wcykge1xuICAgIGxldCB2YWx1ZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpPTAsIGw9YXJncy5sZW5ndGg7IGk8bDsgaSsrKSB7XG4gICAgICBsZXQgYXJnID0gYXJnc1tpXTtcbiAgICAgIGxldCBuYW1lID0gYXJnLm5hbWU7XG4gICAgICBsZXQgdjtcbiAgICAgIGlmIChhcmcubGl0ZXJhbCkge1xuICAgICAgICB2ID0gYXJnLnZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGFyZy5zdHJ1Y3R1cmVkKSB7XG4gICAgICAgICAgdiA9IFBvbHltZXIuUGF0aC5nZXQoZGF0YSwgbmFtZSk7XG4gICAgICAgICAgLy8gd2hlbiBkYXRhIGlzIG5vdCBzdG9yZWQgZS5nLiBgc3BsaWNlc2BcbiAgICAgICAgICBpZiAodiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2ID0gcHJvcHNbbmFtZV07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHYgPSBkYXRhW25hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoYXJnLndpbGRjYXJkKSB7XG4gICAgICAgIC8vIE9ubHkgc2VuZCB0aGUgYWN0dWFsIHBhdGggY2hhbmdlZCBpbmZvIGlmIHRoZSBjaGFuZ2UgdGhhdFxuICAgICAgICAvLyBjYXVzZWQgdGhlIG9ic2VydmVyIHRvIHJ1biBtYXRjaGVkIHRoZSB3aWxkY2FyZFxuICAgICAgICBsZXQgYmFzZUNoYW5nZWQgPSAobmFtZS5pbmRleE9mKHBhdGggKyAnLicpID09PSAwKTtcbiAgICAgICAgbGV0IG1hdGNoZXMgPSAocGF0aC5pbmRleE9mKG5hbWUpID09PSAwICYmICFiYXNlQ2hhbmdlZCk7XG4gICAgICAgIHZhbHVlc1tpXSA9IHtcbiAgICAgICAgICBwYXRoOiBtYXRjaGVzID8gcGF0aCA6IG5hbWUsXG4gICAgICAgICAgdmFsdWU6IG1hdGNoZXMgPyBwcm9wc1twYXRoXSA6IHYsXG4gICAgICAgICAgYmFzZTogdlxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWVzW2ldID0gdjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfVxuXG4gIC8vIGRhdGEgYXBpXG5cbiAgLyoqXG4gICAqIFNlbmRzIGFycmF5IHNwbGljZSBub3RpZmljYXRpb25zIChgLnNwbGljZXNgIGFuZCBgLmxlbmd0aGApXG4gICAqXG4gICAqIE5vdGU6IHRoaXMgaW1wbGVtZW50YXRpb24gb25seSBhY2NlcHRzIG5vcm1hbGl6ZWQgcGF0aHNcbiAgICpcbiAgICogQHBhcmFtIHshUHJvcGVydHlFZmZlY3RzVHlwZX0gaW5zdCBJbnN0YW5jZSB0byBzZW5kIG5vdGlmaWNhdGlvbnMgdG9cbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRoZSBtdXRhdGlvbnMgb2NjdXJyZWQgb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gdGhlIGFycmF5IHRoYXQgd2FzIG11dGF0ZWRcbiAgICogQHBhcmFtIHtBcnJheX0gc3BsaWNlcyBBcnJheSBvZiBzcGxpY2UgcmVjb3Jkc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gbm90aWZ5U3BsaWNlcyhpbnN0LCBhcnJheSwgcGF0aCwgc3BsaWNlcykge1xuICAgIGxldCBzcGxpY2VzUGF0aCA9IHBhdGggKyAnLnNwbGljZXMnO1xuICAgIGluc3Qubm90aWZ5UGF0aChzcGxpY2VzUGF0aCwgeyBpbmRleFNwbGljZXM6IHNwbGljZXMgfSk7XG4gICAgaW5zdC5ub3RpZnlQYXRoKHBhdGggKyAnLmxlbmd0aCcsIGFycmF5Lmxlbmd0aCk7XG4gICAgLy8gTnVsbCBoZXJlIHRvIGFsbG93IHBvdGVudGlhbGx5IGxhcmdlIHNwbGljZSByZWNvcmRzIHRvIGJlIEdDJ2VkLlxuICAgIGluc3QuX19kYXRhW3NwbGljZXNQYXRoXSA9IHtpbmRleFNwbGljZXM6IG51bGx9O1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBzcGxpY2UgcmVjb3JkIGFuZCBzZW5kcyBhbiBhcnJheSBzcGxpY2Ugbm90aWZpY2F0aW9uIGZvclxuICAgKiB0aGUgZGVzY3JpYmVkIG11dGF0aW9uXG4gICAqXG4gICAqIE5vdGU6IHRoaXMgaW1wbGVtZW50YXRpb24gb25seSBhY2NlcHRzIG5vcm1hbGl6ZWQgcGF0aHNcbiAgICpcbiAgICogQHBhcmFtIHshUHJvcGVydHlFZmZlY3RzVHlwZX0gaW5zdCBJbnN0YW5jZSB0byBzZW5kIG5vdGlmaWNhdGlvbnMgdG9cbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRoZSBtdXRhdGlvbnMgb2NjdXJyZWQgb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gdGhlIGFycmF5IHRoYXQgd2FzIG11dGF0ZWRcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IEluZGV4IGF0IHdoaWNoIHRoZSBhcnJheSBtdXRhdGlvbiBvY2N1cnJlZFxuICAgKiBAcGFyYW0ge251bWJlcn0gYWRkZWRDb3VudCBOdW1iZXIgb2YgYWRkZWQgaXRlbXNcbiAgICogQHBhcmFtIHtBcnJheX0gcmVtb3ZlZCBBcnJheSBvZiByZW1vdmVkIGl0ZW1zXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBub3RpZnlTcGxpY2UoaW5zdCwgYXJyYXksIHBhdGgsIGluZGV4LCBhZGRlZENvdW50LCByZW1vdmVkKSB7XG4gICAgbm90aWZ5U3BsaWNlcyhpbnN0LCBhcnJheSwgcGF0aCwgW3tcbiAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgIGFkZGVkQ291bnQ6IGFkZGVkQ291bnQsXG4gICAgICByZW1vdmVkOiByZW1vdmVkLFxuICAgICAgb2JqZWN0OiBhcnJheSxcbiAgICAgIHR5cGU6ICdzcGxpY2UnXG4gICAgfV0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gdXBwZXItY2FzZWQgdmVyc2lvbiBvZiB0aGUgc3RyaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBTdHJpbmcgdG8gdXBwZXJjYXNlXG4gICAqIEByZXR1cm4ge3N0cmluZ30gVXBwZXJjYXNlZCBzdHJpbmdcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIHVwcGVyKG5hbWUpIHtcbiAgICByZXR1cm4gbmFtZVswXS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zdWJzdHJpbmcoMSk7XG4gIH1cblxuICAvKipcbiAgICogRWxlbWVudCBjbGFzcyBtaXhpbiB0aGF0IHByb3ZpZGVzIG1ldGEtcHJvZ3JhbW1pbmcgZm9yIFBvbHltZXIncyB0ZW1wbGF0ZVxuICAgKiBiaW5kaW5nIGFuZCBkYXRhIG9ic2VydmF0aW9uIChjb2xsZWN0aXZlbHksIFwicHJvcGVydHkgZWZmZWN0c1wiKSBzeXN0ZW0uXG4gICAqXG4gICAqIFRoaXMgbWl4aW4gdXNlcyBwcm92aWRlcyB0aGUgZm9sbG93aW5nIGtleSBzdGF0aWMgbWV0aG9kcyBmb3IgYWRkaW5nXG4gICAqIHByb3BlcnR5IGVmZmVjdHMgdG8gYW4gZWxlbWVudCBjbGFzczpcbiAgICogLSBgYWRkUHJvcGVydHlFZmZlY3RgXG4gICAqIC0gYGNyZWF0ZVByb3BlcnR5T2JzZXJ2ZXJgXG4gICAqIC0gYGNyZWF0ZU1ldGhvZE9ic2VydmVyYFxuICAgKiAtIGBjcmVhdGVOb3RpZnlpbmdQcm9wZXJ0eWBcbiAgICogLSBgY3JlYXRlUmVhZE9ubHlQcm9wZXJ0eWBcbiAgICogLSBgY3JlYXRlUmVmbGVjdGVkUHJvcGVydHlgXG4gICAqIC0gYGNyZWF0ZUNvbXB1dGVkUHJvcGVydHlgXG4gICAqIC0gYGJpbmRUZW1wbGF0ZWBcbiAgICpcbiAgICogRWFjaCBtZXRob2QgY3JlYXRlcyBvbmUgb3IgbW9yZSBwcm9wZXJ0eSBhY2Nlc3NvcnMsIGFsb25nIHdpdGggbWV0YWRhdGFcbiAgICogdXNlZCBieSB0aGlzIG1peGluJ3MgaW1wbGVtZW50YXRpb24gb2YgYF9wcm9wZXJ0aWVzQ2hhbmdlZGAgdG8gcGVyZm9ybVxuICAgKiB0aGUgcHJvcGVydHkgZWZmZWN0cy5cbiAgICpcbiAgICogVW5kZXJzY29yZWQgdmVyc2lvbnMgb2YgdGhlIGFib3ZlIG1ldGhvZHMgYWxzbyBleGlzdCBvbiB0aGUgZWxlbWVudFxuICAgKiBwcm90b3R5cGUgZm9yIGFkZGluZyBwcm9wZXJ0eSBlZmZlY3RzIG9uIGluc3RhbmNlcyBhdCBydW50aW1lLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgdGhpcyBtaXhpbiBvdmVycmlkZXMgc2V2ZXJhbCBgUHJvcGVydHlBY2Nlc3NvcnNgIG1ldGhvZHMsIGluXG4gICAqIG1hbnkgY2FzZXMgdG8gbWFpbnRhaW4gZ3VhcmFudGVlcyBwcm92aWRlZCBieSB0aGUgUG9seW1lciAxLnggZmVhdHVyZXM7XG4gICAqIG5vdGFibHkgaXQgY2hhbmdlcyBwcm9wZXJ0eSBhY2Nlc3NvcnMgdG8gYmUgc3luY2hyb25vdXMgYnkgZGVmYXVsdFxuICAgKiB3aGVyZWFzIHRoZSBkZWZhdWx0IHdoZW4gdXNpbmcgYFByb3BlcnR5QWNjZXNzb3JzYCBzdGFuZGFsb25lIGlzIHRvIGJlXG4gICAqIGFzeW5jIGJ5IGRlZmF1bHQuXG4gICAqXG4gICAqIEBtaXhpbkZ1bmN0aW9uXG4gICAqIEBwb2x5bWVyXG4gICAqIEBhcHBsaWVzTWl4aW4gUG9seW1lci5UZW1wbGF0ZVN0YW1wXG4gICAqIEBhcHBsaWVzTWl4aW4gUG9seW1lci5Qcm9wZXJ0eUFjY2Vzc29yc1xuICAgKiBAbWVtYmVyb2YgUG9seW1lclxuICAgKiBAc3VtbWFyeSBFbGVtZW50IGNsYXNzIG1peGluIHRoYXQgcHJvdmlkZXMgbWV0YS1wcm9ncmFtbWluZyBmb3IgUG9seW1lcidzXG4gICAqIHRlbXBsYXRlIGJpbmRpbmcgYW5kIGRhdGEgb2JzZXJ2YXRpb24gc3lzdGVtLlxuICAgKi9cbiAgUG9seW1lci5Qcm9wZXJ0eUVmZmVjdHMgPSBQb2x5bWVyLmRlZHVwaW5nTWl4aW4oc3VwZXJDbGFzcyA9PiB7XG5cbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAZXh0ZW5kcyB7c3VwZXJDbGFzc31cbiAgICAgKiBAaW1wbGVtZW50cyB7UG9seW1lcl9Qcm9wZXJ0eUFjY2Vzc29yc31cbiAgICAgKiBAaW1wbGVtZW50cyB7UG9seW1lcl9UZW1wbGF0ZVN0YW1wfVxuICAgICAqIEB1bnJlc3RyaWN0ZWRcbiAgICAgKi9cbiAgICBjb25zdCBwcm9wZXJ0eUVmZmVjdHNCYXNlID0gUG9seW1lci5UZW1wbGF0ZVN0YW1wKFBvbHltZXIuUHJvcGVydHlBY2Nlc3NvcnMoc3VwZXJDbGFzcykpO1xuXG4gICAgLyoqXG4gICAgICogQHBvbHltZXJcbiAgICAgKiBAbWl4aW5DbGFzc1xuICAgICAqIEBpbXBsZW1lbnRzIHtQb2x5bWVyX1Byb3BlcnR5RWZmZWN0c31cbiAgICAgKiBAZXh0ZW5kcyB7cHJvcGVydHlFZmZlY3RzQmFzZX1cbiAgICAgKiBAdW5yZXN0cmljdGVkXG4gICAgICovXG4gICAgY2xhc3MgUHJvcGVydHlFZmZlY3RzIGV4dGVuZHMgcHJvcGVydHlFZmZlY3RzQmFzZSB7XG5cbiAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICAvKiogQHR5cGUge2Jvb2xlYW59ICovXG4gICAgICAgIHRoaXMuX19kYXRhQ2xpZW50c1JlYWR5O1xuICAgICAgICAvKiogQHR5cGUge0FycmF5fSAqL1xuICAgICAgICB0aGlzLl9fZGF0YVBlbmRpbmdDbGllbnRzO1xuICAgICAgICAvKiogQHR5cGUge09iamVjdH0gKi9cbiAgICAgICAgdGhpcy5fX2RhdGFUb05vdGlmeTtcbiAgICAgICAgLyoqIEB0eXBlIHtPYmplY3R9ICovXG4gICAgICAgIHRoaXMuX19kYXRhTGlua2VkUGF0aHM7XG4gICAgICAgIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cbiAgICAgICAgdGhpcy5fX2RhdGFIYXNQYXRocztcbiAgICAgICAgLyoqIEB0eXBlIHtPYmplY3R9ICovXG4gICAgICAgIHRoaXMuX19kYXRhQ29tcG91bmRTdG9yYWdlO1xuICAgICAgICAvKiogQHR5cGUge1BvbHltZXJfUHJvcGVydHlFZmZlY3RzfSAqL1xuICAgICAgICB0aGlzLl9fZGF0YUhvc3Q7XG4gICAgICAgIC8qKiBAdHlwZSB7IU9iamVjdH0gKi9cbiAgICAgICAgdGhpcy5fX2RhdGFUZW1wO1xuICAgICAgICAvKiogQHR5cGUge2Jvb2xlYW59ICovXG4gICAgICAgIHRoaXMuX19kYXRhQ2xpZW50c0luaXRpYWxpemVkO1xuICAgICAgICAvKiogQHR5cGUgeyFPYmplY3R9ICovXG4gICAgICAgIHRoaXMuX19kYXRhO1xuICAgICAgICAvKiogQHR5cGUgeyFPYmplY3R9ICovXG4gICAgICAgIHRoaXMuX19kYXRhUGVuZGluZztcbiAgICAgICAgLyoqIEB0eXBlIHshT2JqZWN0fSAqL1xuICAgICAgICB0aGlzLl9fZGF0YU9sZDtcbiAgICAgICAgLyoqIEB0eXBlIHtPYmplY3R9ICovXG4gICAgICAgIHRoaXMuX19jb21wdXRlRWZmZWN0cztcbiAgICAgICAgLyoqIEB0eXBlIHtPYmplY3R9ICovXG4gICAgICAgIHRoaXMuX19yZWZsZWN0RWZmZWN0cztcbiAgICAgICAgLyoqIEB0eXBlIHtPYmplY3R9ICovXG4gICAgICAgIHRoaXMuX19ub3RpZnlFZmZlY3RzO1xuICAgICAgICAvKiogQHR5cGUge09iamVjdH0gKi9cbiAgICAgICAgdGhpcy5fX3Byb3BhZ2F0ZUVmZmVjdHM7XG4gICAgICAgIC8qKiBAdHlwZSB7T2JqZWN0fSAqL1xuICAgICAgICB0aGlzLl9fb2JzZXJ2ZUVmZmVjdHM7XG4gICAgICAgIC8qKiBAdHlwZSB7T2JqZWN0fSAqL1xuICAgICAgICB0aGlzLl9fcmVhZE9ubHk7XG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLl9fZGF0YUNvdW50ZXI7XG4gICAgICAgIC8qKiBAdHlwZSB7IVRlbXBsYXRlSW5mb30gKi9cbiAgICAgICAgdGhpcy5fX3RlbXBsYXRlSW5mbztcbiAgICAgIH1cblxuICAgICAgZ2V0IFBST1BFUlRZX0VGRkVDVF9UWVBFUygpIHtcbiAgICAgICAgcmV0dXJuIFRZUEVTO1xuICAgICAgfVxuXG4gICAgICBfaW5pdGlhbGl6ZVByb3BlcnRpZXMoKSB7XG4gICAgICAgIHN1cGVyLl9pbml0aWFsaXplUHJvcGVydGllcygpO1xuICAgICAgICBob3N0U3RhY2sucmVnaXN0ZXJIb3N0KHRoaXMpO1xuICAgICAgICB0aGlzLl9fZGF0YUNsaWVudHNSZWFkeSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9fZGF0YVBlbmRpbmdDbGllbnRzID0gbnVsbDtcbiAgICAgICAgdGhpcy5fX2RhdGFUb05vdGlmeSA9IG51bGw7XG4gICAgICAgIHRoaXMuX19kYXRhTGlua2VkUGF0aHMgPSBudWxsO1xuICAgICAgICB0aGlzLl9fZGF0YUhhc1BhdGhzID0gZmFsc2U7XG4gICAgICAgIC8vIE1heSBiZSBzZXQgb24gaW5zdGFuY2UgcHJpb3IgdG8gdXBncmFkZVxuICAgICAgICB0aGlzLl9fZGF0YUNvbXBvdW5kU3RvcmFnZSA9IHRoaXMuX19kYXRhQ29tcG91bmRTdG9yYWdlIHx8IG51bGw7XG4gICAgICAgIHRoaXMuX19kYXRhSG9zdCA9IHRoaXMuX19kYXRhSG9zdCB8fCBudWxsO1xuICAgICAgICB0aGlzLl9fZGF0YVRlbXAgPSB7fTtcbiAgICAgICAgdGhpcy5fX2RhdGFDbGllbnRzSW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBPdmVycmlkZXMgYFBvbHltZXIuUHJvcGVydHlBY2Nlc3NvcnNgIGltcGxlbWVudGF0aW9uIHRvIHByb3ZpZGUgYVxuICAgICAgICogbW9yZSBlZmZpY2llbnQgaW1wbGVtZW50YXRpb24gb2YgaW5pdGlhbGl6aW5nIHByb3BlcnRpZXMgZnJvbVxuICAgICAgICogdGhlIHByb3RvdHlwZSBvbiB0aGUgaW5zdGFuY2UuXG4gICAgICAgKlxuICAgICAgICogQG92ZXJyaWRlXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgUHJvcGVydGllcyB0byBpbml0aWFsaXplIG9uIHRoZSBwcm90b3R5cGVcbiAgICAgICAqL1xuICAgICAgX2luaXRpYWxpemVQcm90b1Byb3BlcnRpZXMocHJvcHMpIHtcbiAgICAgICAgdGhpcy5fX2RhdGEgPSBPYmplY3QuY3JlYXRlKHByb3BzKTtcbiAgICAgICAgdGhpcy5fX2RhdGFQZW5kaW5nID0gT2JqZWN0LmNyZWF0ZShwcm9wcyk7XG4gICAgICAgIHRoaXMuX19kYXRhT2xkID0ge307XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogT3ZlcnJpZGVzIGBQb2x5bWVyLlByb3BlcnR5QWNjZXNzb3JzYCBpbXBsZW1lbnRhdGlvbiB0byBhdm9pZCBzZXR0aW5nXG4gICAgICAgKiBgX3NldFByb3BlcnR5YCdzIGBzaG91bGROb3RpZnk6IHRydWVgLlxuICAgICAgICpcbiAgICAgICAqIEBvdmVycmlkZVxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzIFByb3BlcnRpZXMgdG8gaW5pdGlhbGl6ZSBvbiB0aGUgaW5zdGFuY2VcbiAgICAgICAqL1xuICAgICAgX2luaXRpYWxpemVJbnN0YW5jZVByb3BlcnRpZXMocHJvcHMpIHtcbiAgICAgICAgbGV0IHJlYWRPbmx5ID0gdGhpc1tUWVBFUy5SRUFEX09OTFldO1xuICAgICAgICBmb3IgKGxldCBwcm9wIGluIHByb3BzKSB7XG4gICAgICAgICAgaWYgKCFyZWFkT25seSB8fCAhcmVhZE9ubHlbcHJvcF0pIHtcbiAgICAgICAgICAgIHRoaXMuX19kYXRhUGVuZGluZyA9IHRoaXMuX19kYXRhUGVuZGluZyB8fCB7fTtcbiAgICAgICAgICAgIHRoaXMuX19kYXRhT2xkID0gdGhpcy5fX2RhdGFPbGQgfHwge307XG4gICAgICAgICAgICB0aGlzLl9fZGF0YVtwcm9wXSA9IHRoaXMuX19kYXRhUGVuZGluZ1twcm9wXSA9IHByb3BzW3Byb3BdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBQcm90b3R5cGUgc2V0dXAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAvKipcbiAgICAgICAqIEVxdWl2YWxlbnQgdG8gc3RhdGljIGBhZGRQcm9wZXJ0eUVmZmVjdGAgQVBJIGJ1dCBjYW4gYmUgY2FsbGVkIG9uXG4gICAgICAgKiBhbiBpbnN0YW5jZSB0byBhZGQgZWZmZWN0cyBhdCBydW50aW1lLiAgU2VlIHRoYXQgbWV0aG9kIGZvclxuICAgICAgICogZnVsbCBBUEkgZG9jcy5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgdGhhdCBzaG91bGQgdHJpZ2dlciB0aGUgZWZmZWN0XG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBFZmZlY3QgdHlwZSwgZnJvbSB0aGlzLlBST1BFUlRZX0VGRkVDVF9UWVBFU1xuICAgICAgICogQHBhcmFtIHtPYmplY3Q9fSBlZmZlY3QgRWZmZWN0IG1ldGFkYXRhIG9iamVjdFxuICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICovXG4gICAgICBfYWRkUHJvcGVydHlFZmZlY3QocHJvcGVydHksIHR5cGUsIGVmZmVjdCkge1xuICAgICAgICB0aGlzLl9jcmVhdGVQcm9wZXJ0eUFjY2Vzc29yKHByb3BlcnR5LCB0eXBlID09IFRZUEVTLlJFQURfT05MWSk7XG4gICAgICAgIC8vIGVmZmVjdHMgYXJlIGFjY3VtdWxhdGVkIGludG8gYXJyYXlzIHBlciBwcm9wZXJ0eSBiYXNlZCBvbiB0eXBlXG4gICAgICAgIGxldCBlZmZlY3RzID0gZW5zdXJlT3duRWZmZWN0TWFwKHRoaXMsIHR5cGUpW3Byb3BlcnR5XTtcbiAgICAgICAgaWYgKCFlZmZlY3RzKSB7XG4gICAgICAgICAgZWZmZWN0cyA9IHRoaXNbdHlwZV1bcHJvcGVydHldID0gW107XG4gICAgICAgIH1cbiAgICAgICAgZWZmZWN0cy5wdXNoKGVmZmVjdCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUmVtb3ZlcyB0aGUgZ2l2ZW4gcHJvcGVydHkgZWZmZWN0LlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSB0aGUgZWZmZWN0IHdhcyBhc3NvY2lhdGVkIHdpdGhcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIEVmZmVjdCB0eXBlLCBmcm9tIHRoaXMuUFJPUEVSVFlfRUZGRUNUX1RZUEVTXG4gICAgICAgKiBAcGFyYW0ge09iamVjdD19IGVmZmVjdCBFZmZlY3QgbWV0YWRhdGEgb2JqZWN0IHRvIHJlbW92ZVxuICAgICAgICovXG4gICAgICBfcmVtb3ZlUHJvcGVydHlFZmZlY3QocHJvcGVydHksIHR5cGUsIGVmZmVjdCkge1xuICAgICAgICBsZXQgZWZmZWN0cyA9IGVuc3VyZU93bkVmZmVjdE1hcCh0aGlzLCB0eXBlKVtwcm9wZXJ0eV07XG4gICAgICAgIGxldCBpZHggPSBlZmZlY3RzLmluZGV4T2YoZWZmZWN0KTtcbiAgICAgICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICAgICAgZWZmZWN0cy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgY3VycmVudCBwcm90b3R5cGUvaW5zdGFuY2UgaGFzIGEgcHJvcGVydHkgZWZmZWN0XG4gICAgICAgKiBvZiBhIGNlcnRhaW4gdHlwZS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgbmFtZVxuICAgICAgICogQHBhcmFtIHtzdHJpbmc9fSB0eXBlIEVmZmVjdCB0eXBlLCBmcm9tIHRoaXMuUFJPUEVSVFlfRUZGRUNUX1RZUEVTXG4gICAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBwcm90b3R5cGUvaW5zdGFuY2UgaGFzIGFuIGVmZmVjdCBvZiB0aGlzIHR5cGVcbiAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAqL1xuICAgICAgX2hhc1Byb3BlcnR5RWZmZWN0KHByb3BlcnR5LCB0eXBlKSB7XG4gICAgICAgIGxldCBlZmZlY3RzID0gdGhpc1t0eXBlXTtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4oZWZmZWN0cyAmJiBlZmZlY3RzW3Byb3BlcnR5XSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBjdXJyZW50IHByb3RvdHlwZS9pbnN0YW5jZSBoYXMgYSBcInJlYWQgb25seVwiXG4gICAgICAgKiBhY2Nlc3NvciBmb3IgdGhlIGdpdmVuIHByb3BlcnR5LlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSBuYW1lXG4gICAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBwcm90b3R5cGUvaW5zdGFuY2UgaGFzIGFuIGVmZmVjdCBvZiB0aGlzIHR5cGVcbiAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAqL1xuICAgICAgX2hhc1JlYWRPbmx5RWZmZWN0KHByb3BlcnR5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oYXNQcm9wZXJ0eUVmZmVjdChwcm9wZXJ0eSwgVFlQRVMuUkVBRF9PTkxZKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGN1cnJlbnQgcHJvdG90eXBlL2luc3RhbmNlIGhhcyBhIFwibm90aWZ5XCJcbiAgICAgICAqIHByb3BlcnR5IGVmZmVjdCBmb3IgdGhlIGdpdmVuIHByb3BlcnR5LlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSBuYW1lXG4gICAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBwcm90b3R5cGUvaW5zdGFuY2UgaGFzIGFuIGVmZmVjdCBvZiB0aGlzIHR5cGVcbiAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAqL1xuICAgICAgX2hhc05vdGlmeUVmZmVjdChwcm9wZXJ0eSkge1xuICAgICAgICByZXR1cm4gdGhpcy5faGFzUHJvcGVydHlFZmZlY3QocHJvcGVydHksIFRZUEVTLk5PVElGWSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBjdXJyZW50IHByb3RvdHlwZS9pbnN0YW5jZSBoYXMgYSBcInJlZmxlY3QgdG8gYXR0cmlidXRlXCJcbiAgICAgICAqIHByb3BlcnR5IGVmZmVjdCBmb3IgdGhlIGdpdmVuIHByb3BlcnR5LlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSBuYW1lXG4gICAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBwcm90b3R5cGUvaW5zdGFuY2UgaGFzIGFuIGVmZmVjdCBvZiB0aGlzIHR5cGVcbiAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAqL1xuICAgICAgX2hhc1JlZmxlY3RFZmZlY3QocHJvcGVydHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hhc1Byb3BlcnR5RWZmZWN0KHByb3BlcnR5LCBUWVBFUy5SRUZMRUNUKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGN1cnJlbnQgcHJvdG90eXBlL2luc3RhbmNlIGhhcyBhIFwiY29tcHV0ZWRcIlxuICAgICAgICogcHJvcGVydHkgZWZmZWN0IGZvciB0aGUgZ2l2ZW4gcHJvcGVydHkuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IG5hbWVcbiAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIHByb3RvdHlwZS9pbnN0YW5jZSBoYXMgYW4gZWZmZWN0IG9mIHRoaXMgdHlwZVxuICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICovXG4gICAgICBfaGFzQ29tcHV0ZWRFZmZlY3QocHJvcGVydHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hhc1Byb3BlcnR5RWZmZWN0KHByb3BlcnR5LCBUWVBFUy5DT01QVVRFKTtcbiAgICAgIH1cblxuICAgICAgLy8gUnVudGltZSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgIC8qKlxuICAgICAgICogU2V0cyBhIHBlbmRpbmcgcHJvcGVydHkgb3IgcGF0aC4gIElmIHRoZSByb290IHByb3BlcnR5IG9mIHRoZSBwYXRoIGluXG4gICAgICAgKiBxdWVzdGlvbiBoYWQgbm8gYWNjZXNzb3IsIHRoZSBwYXRoIGlzIHNldCwgb3RoZXJ3aXNlIGl0IGlzIGVucXVldWVkXG4gICAgICAgKiB2aWEgYF9zZXRQZW5kaW5nUHJvcGVydHlgLlxuICAgICAgICpcbiAgICAgICAqIFRoaXMgZnVuY3Rpb24gaXNvbGF0ZXMgcmVsYXRpdmVseSBleHBlbnNpdmUgZnVuY3Rpb25hbGl0eSBuZWNlc3NhcnlcbiAgICAgICAqIGZvciB0aGUgcHVibGljIEFQSSAoYHNldGAsIGBzZXRQcm9wZXJ0aWVzYCwgYG5vdGlmeVBhdGhgLCBhbmQgcHJvcGVydHlcbiAgICAgICAqIGNoYW5nZSBsaXN0ZW5lcnMgdmlhIHt7Li4ufX0gYmluZGluZ3MpLCBzdWNoIHRoYXQgaXQgaXMgb25seSBkb25lXG4gICAgICAgKiB3aGVuIHBhdGhzIGVudGVyIHRoZSBzeXN0ZW0sIGFuZCBub3QgYXQgZXZlcnkgcHJvcGFnYXRpb24gc3RlcC4gIEl0XG4gICAgICAgKiBhbHNvIHNldHMgYSBgX19kYXRhSGFzUGF0aHNgIGZsYWcgb24gdGhlIGluc3RhbmNlIHdoaWNoIGlzIHVzZWQgdG9cbiAgICAgICAqIGZhc3QtcGF0aCBzbG93ZXIgcGF0aC1tYXRjaGluZyBjb2RlIGluIHRoZSBwcm9wZXJ0eSBlZmZlY3RzIGhvc3QgcGF0aHMuXG4gICAgICAgKlxuICAgICAgICogYHBhdGhgIGNhbiBiZSBhIHBhdGggc3RyaW5nIG9yIGFycmF5IG9mIHBhdGggcGFydHMgYXMgYWNjZXB0ZWQgYnkgdGhlXG4gICAgICAgKiBwdWJsaWMgQVBJLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgIUFycmF5PG51bWJlcnxzdHJpbmc+fSBwYXRoIFBhdGggdG8gc2V0XG4gICAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIHNldFxuICAgICAgICogQHBhcmFtIHtib29sZWFuPX0gc2hvdWxkTm90aWZ5IFNldCB0byB0cnVlIGlmIHRoaXMgY2hhbmdlIHNob3VsZFxuICAgICAgICogIGNhdXNlIGEgcHJvcGVydHkgbm90aWZpY2F0aW9uIGV2ZW50IGRpc3BhdGNoXG4gICAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBpc1BhdGhOb3RpZmljYXRpb24gSWYgdGhlIHBhdGggYmVpbmcgc2V0IGlzIGEgcGF0aFxuICAgICAgICogICBub3RpZmljYXRpb24gb2YgYW4gYWxyZWFkeSBjaGFuZ2VkIHZhbHVlLCBhcyBvcHBvc2VkIHRvIGEgcmVxdWVzdFxuICAgICAgICogICB0byBzZXQgYW5kIG5vdGlmeSB0aGUgY2hhbmdlLiAgSW4gdGhlIGxhdHRlciBgZmFsc2VgIGNhc2UsIGEgZGlydHlcbiAgICAgICAqICAgY2hlY2sgaXMgcGVyZm9ybWVkIGFuZCB0aGVuIHRoZSB2YWx1ZSBpcyBzZXQgdG8gdGhlIHBhdGggYmVmb3JlXG4gICAgICAgKiAgIGVucXVldWluZyB0aGUgcGVuZGluZyBwcm9wZXJ0eSBjaGFuZ2UuXG4gICAgICAgKiBAcmV0dXJuIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgdGhlIHByb3BlcnR5L3BhdGggd2FzIGVucXVldWVkIGluXG4gICAgICAgKiAgIHRoZSBwZW5kaW5nIGNoYW5nZXMgYmFnLlxuICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICovXG4gICAgICBfc2V0UGVuZGluZ1Byb3BlcnR5T3JQYXRoKHBhdGgsIHZhbHVlLCBzaG91bGROb3RpZnksIGlzUGF0aE5vdGlmaWNhdGlvbikge1xuICAgICAgICBpZiAoaXNQYXRoTm90aWZpY2F0aW9uIHx8XG4gICAgICAgICAgICBQb2x5bWVyLlBhdGgucm9vdChBcnJheS5pc0FycmF5KHBhdGgpID8gcGF0aFswXSA6IHBhdGgpICE9PSBwYXRoKSB7XG4gICAgICAgICAgLy8gRGlydHkgY2hlY2sgY2hhbmdlcyBiZWluZyBzZXQgdG8gYSBwYXRoIGFnYWluc3QgdGhlIGFjdHVhbCBvYmplY3QsXG4gICAgICAgICAgLy8gc2luY2UgdGhpcyBpcyB0aGUgZW50cnkgcG9pbnQgZm9yIHBhdGhzIGludG8gdGhlIHN5c3RlbTsgZnJvbSBoZXJlXG4gICAgICAgICAgLy8gdGhlIG9ubHkgZGlydHkgY2hlY2tzIGFyZSBhZ2FpbnN0IHRoZSBgX19kYXRhVGVtcGAgY2FjaGUgdG8gcHJldmVudFxuICAgICAgICAgIC8vIGR1cGxpY2F0ZSB3b3JrIGluIHRoZSBzYW1lIHR1cm4gb25seS4gTm90ZSwgaWYgdGhpcyB3YXMgYSBub3RpZmljYXRpb25cbiAgICAgICAgICAvLyBvZiBhIGNoYW5nZSBhbHJlYWR5IHNldCB0byBhIHBhdGggKGlzUGF0aE5vdGlmaWNhdGlvbjogdHJ1ZSksXG4gICAgICAgICAgLy8gd2UgYWx3YXlzIGxldCB0aGUgY2hhbmdlIHRocm91Z2ggYW5kIHNraXAgdGhlIGBzZXRgIHNpbmNlIGl0IHdhc1xuICAgICAgICAgIC8vIGFscmVhZHkgZGlydHkgY2hlY2tlZCBhdCB0aGUgcG9pbnQgb2YgZW50cnkgYW5kIHRoZSB1bmRlcmx5aW5nXG4gICAgICAgICAgLy8gb2JqZWN0IGhhcyBhbHJlYWR5IGJlZW4gdXBkYXRlZFxuICAgICAgICAgIGlmICghaXNQYXRoTm90aWZpY2F0aW9uKSB7XG4gICAgICAgICAgICBsZXQgb2xkID0gUG9seW1lci5QYXRoLmdldCh0aGlzLCBwYXRoKTtcbiAgICAgICAgICAgIHBhdGggPSAvKiogQHR5cGUge3N0cmluZ30gKi8gKFBvbHltZXIuUGF0aC5zZXQodGhpcywgcGF0aCwgdmFsdWUpKTtcbiAgICAgICAgICAgIC8vIFVzZSBwcm9wZXJ0eS1hY2Nlc3NvcidzIHNpbXBsZXIgZGlydHkgY2hlY2tcbiAgICAgICAgICAgIGlmICghcGF0aCB8fCAhc3VwZXIuX3Nob3VsZFByb3BlcnR5Q2hhbmdlKHBhdGgsIHZhbHVlLCBvbGQpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fX2RhdGFIYXNQYXRocyA9IHRydWU7XG4gICAgICAgICAgaWYgKHRoaXMuX3NldFBlbmRpbmdQcm9wZXJ0eSgvKipAdHlwZXtzdHJpbmd9Ki8ocGF0aCksIHZhbHVlLCBzaG91bGROb3RpZnkpKSB7XG4gICAgICAgICAgICBjb21wdXRlTGlua2VkUGF0aHModGhpcywgcGF0aCwgdmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh0aGlzLl9fZGF0YUhhc0FjY2Vzc29yICYmIHRoaXMuX19kYXRhSGFzQWNjZXNzb3JbcGF0aF0pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zZXRQZW5kaW5nUHJvcGVydHkoLyoqQHR5cGV7c3RyaW5nfSovKHBhdGgpLCB2YWx1ZSwgc2hvdWxkTm90aWZ5KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpc1twYXRoXSA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQXBwbGllcyBhIHZhbHVlIHRvIGEgbm9uLVBvbHltZXIgZWxlbWVudC9ub2RlJ3MgcHJvcGVydHkuXG4gICAgICAgKlxuICAgICAgICogVGhlIGltcGxlbWVudGF0aW9uIG1ha2VzIGEgYmVzdC1lZmZvcnQgYXQgYmluZGluZyBpbnRlcm9wOlxuICAgICAgICogU29tZSBuYXRpdmUgZWxlbWVudCBwcm9wZXJ0aWVzIGhhdmUgc2lkZS1lZmZlY3RzIHdoZW5cbiAgICAgICAqIHJlLXNldHRpbmcgdGhlIHNhbWUgdmFsdWUgKGUuZy4gc2V0dGluZyBgPGlucHV0Pi52YWx1ZWAgcmVzZXRzIHRoZVxuICAgICAgICogY3Vyc29yIHBvc2l0aW9uKSwgc28gd2UgZG8gYSBkaXJ0eS1jaGVjayBiZWZvcmUgc2V0dGluZyB0aGUgdmFsdWUuXG4gICAgICAgKiBIb3dldmVyLCBmb3IgYmV0dGVyIGludGVyb3Agd2l0aCBub24tUG9seW1lciBjdXN0b20gZWxlbWVudHMgdGhhdFxuICAgICAgICogYWNjZXB0IG9iamVjdHMsIHdlIGV4cGxpY2l0bHkgcmUtc2V0IG9iamVjdCBjaGFuZ2VzIGNvbWluZyBmcm9tIHRoZVxuICAgICAgICogUG9seW1lciB3b3JsZCAod2hpY2ggbWF5IGluY2x1ZGUgZGVlcCBvYmplY3QgY2hhbmdlcyB3aXRob3V0IHRoZVxuICAgICAgICogdG9wIHJlZmVyZW5jZSBjaGFuZ2luZyksIGVycmluZyBvbiB0aGUgc2lkZSBvZiBwcm92aWRpbmcgbW9yZVxuICAgICAgICogaW5mb3JtYXRpb24uXG4gICAgICAgKlxuICAgICAgICogVXNlcnMgbWF5IG92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIHByb3ZpZGUgYWx0ZXJuYXRlIGFwcHJvYWNoZXMuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtOb2RlfSBub2RlIFRoZSBub2RlIHRvIHNldCBhIHByb3BlcnR5IG9uXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcCBUaGUgcHJvcGVydHkgdG8gc2V0XG4gICAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXRcbiAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAqL1xuICAgICAgX3NldFVubWFuYWdlZFByb3BlcnR5VG9Ob2RlKG5vZGUsIHByb3AsIHZhbHVlKSB7XG4gICAgICAgIC8vIEl0IGlzIGEganVkZ21lbnQgY2FsbCB0aGF0IHJlc2V0dGluZyBwcmltaXRpdmVzIGlzXG4gICAgICAgIC8vIFwiYmFkXCIgYW5kIHJlc2V0dGluZ3Mgb2JqZWN0cyBpcyBhbHNvIFwiZ29vZFwiOyBhbHRlcm5hdGl2ZWx5IHdlIGNvdWxkXG4gICAgICAgIC8vIGltcGxlbWVudCBhIHdoaXRlbGlzdCBvZiB0YWcgJiBwcm9wZXJ0eSB2YWx1ZXMgdGhhdCBzaG91bGQgbmV2ZXJcbiAgICAgICAgLy8gYmUgcmVzZXQgKGUuZy4gPGlucHV0Pi52YWx1ZSAmJiA8c2VsZWN0Pi52YWx1ZSlcbiAgICAgICAgaWYgKHZhbHVlICE9PSBub2RlW3Byb3BdIHx8IHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jykge1xuICAgICAgICAgIG5vZGVbcHJvcF0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIE92ZXJyaWRlcyB0aGUgYFByb3BlcnR5QWNjZXNzb3JzYCBpbXBsZW1lbnRhdGlvbiB0byBpbnRyb2R1Y2Ugc3BlY2lhbFxuICAgICAgICogZGlydHkgY2hlY2sgbG9naWMgZGVwZW5kaW5nIG9uIHRoZSBwcm9wZXJ0eSAmIHZhbHVlIGJlaW5nIHNldDpcbiAgICAgICAqXG4gICAgICAgKiAxLiBBbnkgdmFsdWUgc2V0IHRvIGEgcGF0aCAoZS5nLiAnb2JqLnByb3AnOiA0MiBvciAnb2JqLnByb3AnOiB7Li4ufSlcbiAgICAgICAqICAgIFN0b3JlZCBpbiBgX19kYXRhVGVtcGAsIGRpcnR5IGNoZWNrZWQgYWdhaW5zdCBgX19kYXRhVGVtcGBcbiAgICAgICAqIDIuIE9iamVjdCBzZXQgdG8gc2ltcGxlIHByb3BlcnR5IChlLmcuICdwcm9wJzogey4uLn0pXG4gICAgICAgKiAgICBTdG9yZWQgaW4gYF9fZGF0YVRlbXBgIGFuZCBgX19kYXRhYCwgZGlydHkgY2hlY2tlZCBhZ2FpbnN0XG4gICAgICAgKiAgICBgX19kYXRhVGVtcGAgYnkgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZiBgX3Nob3VsZFByb3BlcnR5Q2hhbmdlYFxuICAgICAgICogMy4gUHJpbWl0aXZlIHZhbHVlIHNldCB0byBzaW1wbGUgcHJvcGVydHkgKGUuZy4gJ3Byb3AnOiA0MilcbiAgICAgICAqICAgIFN0b3JlZCBpbiBgX19kYXRhYCwgZGlydHkgY2hlY2tlZCBhZ2FpbnN0IGBfX2RhdGFgXG4gICAgICAgKlxuICAgICAgICogVGhlIGRpcnR5LWNoZWNrIGlzIGltcG9ydGFudCB0byBwcmV2ZW50IGN5Y2xlcyBkdWUgdG8gdHdvLXdheVxuICAgICAgICogbm90aWZpY2F0aW9uLCBidXQgcGF0aHMgYW5kIG9iamVjdHMgYXJlIG9ubHkgZGlydHkgY2hlY2tlZCBhZ2FpbnN0IGFueVxuICAgICAgICogcHJldmlvdXMgdmFsdWUgc2V0IGR1cmluZyB0aGlzIHR1cm4gdmlhIGEgXCJ0ZW1wb3JhcnkgY2FjaGVcIiB0aGF0IGlzXG4gICAgICAgKiBjbGVhcmVkIHdoZW4gdGhlIGxhc3QgYF9wcm9wZXJ0aWVzQ2hhZ2VkYCBleGl0cy4gVGhpcyBpcyBzbzpcbiAgICAgICAqIGEuIGFueSBjYWNoZWQgYXJyYXkgcGF0aHMgKGUuZy4gJ2FycmF5LjMucHJvcCcpIG1heSBiZSBpbnZhbGlkYXRlZFxuICAgICAgICogICAgZHVlIHRvIGFycmF5IG11dGF0aW9ucyBsaWtlIHNoaWZ0L3Vuc2hpZnQvc3BsaWNlOyB0aGlzIGlzIGZpbmVcbiAgICAgICAqICAgIHNpbmNlIHBhdGggY2hhbmdlcyBhcmUgZGlydHktY2hlY2tlZCBhdCB1c2VyIGVudHJ5IHBvaW50cyBsaWtlIGBzZXRgXG4gICAgICAgKiBiLiBkaXJ0eS1jaGVja2luZyBmb3Igb2JqZWN0cyBvbmx5IGxhc3RzIG9uZSB0dXJuIHRvIGFsbG93IHRoZSB1c2VyXG4gICAgICAgKiAgICB0byBtdXRhdGUgdGhlIG9iamVjdCBpbi1wbGFjZSBhbmQgcmUtc2V0IGl0IHdpdGggdGhlIHNhbWUgaWRlbnRpdHlcbiAgICAgICAqICAgIGFuZCBoYXZlIGFsbCBzdWItcHJvcGVydGllcyByZS1wcm9wYWdhdGVkIGluIGEgc3Vic2VxdWVudCB0dXJuLlxuICAgICAgICpcbiAgICAgICAqIFRoZSB0ZW1wIGNhY2hlIGlzIG5vdCBuZWNlc3NhcmlseSBzdWZmaWNpZW50IHRvIHByZXZlbnQgaW52YWxpZCBhcnJheVxuICAgICAgICogcGF0aHMsIHNpbmNlIGEgc3BsaWNlIGNhbiBoYXBwZW4gZHVyaW5nIHRoZSBzYW1lIHR1cm4gKHdpdGggcGF0aG9sb2dpY2FsXG4gICAgICAgKiB1c2VyIGNvZGUpOyB3ZSBjb3VsZCBpbnRyb2R1Y2UgYSBcImZpeHVwXCIgZm9yIHRlbXBvcmFyaWx5IGNhY2hlZCBhcnJheVxuICAgICAgICogcGF0aHMgaWYgbmVlZGVkOiBodHRwczovL2dpdGh1Yi5jb20vUG9seW1lci9wb2x5bWVyL2lzc3Vlcy80MjI3XG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IE5hbWUgb2YgdGhlIHByb3BlcnR5XG4gICAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIHNldFxuICAgICAgICogQHBhcmFtIHtib29sZWFuPX0gc2hvdWxkTm90aWZ5IFRydWUgaWYgcHJvcGVydHkgc2hvdWxkIGZpcmUgbm90aWZpY2F0aW9uXG4gICAgICAgKiAgIGV2ZW50IChhcHBsaWVzIG9ubHkgZm9yIGBub3RpZnk6IHRydWVgIHByb3BlcnRpZXMpXG4gICAgICAgKiBAcmV0dXJuIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgdGhlIHByb3BlcnR5IGNoYW5nZWRcbiAgICAgICAqIEBvdmVycmlkZVxuICAgICAgICovXG4gICAgICBfc2V0UGVuZGluZ1Byb3BlcnR5KHByb3BlcnR5LCB2YWx1ZSwgc2hvdWxkTm90aWZ5KSB7XG4gICAgICAgIGxldCBpc1BhdGggPSB0aGlzLl9fZGF0YUhhc1BhdGhzICYmIFBvbHltZXIuUGF0aC5pc1BhdGgocHJvcGVydHkpO1xuICAgICAgICBsZXQgcHJldlByb3BzID0gaXNQYXRoID8gdGhpcy5fX2RhdGFUZW1wIDogdGhpcy5fX2RhdGE7XG4gICAgICAgIGlmICh0aGlzLl9zaG91bGRQcm9wZXJ0eUNoYW5nZShwcm9wZXJ0eSwgdmFsdWUsIHByZXZQcm9wc1twcm9wZXJ0eV0pKSB7XG4gICAgICAgICAgaWYgKCF0aGlzLl9fZGF0YVBlbmRpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuX19kYXRhUGVuZGluZyA9IHt9O1xuICAgICAgICAgICAgdGhpcy5fX2RhdGFPbGQgPSB7fTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gRW5zdXJlIG9sZCBpcyBjYXB0dXJlZCBmcm9tIHRoZSBsYXN0IHR1cm5cbiAgICAgICAgICBpZiAoIShwcm9wZXJ0eSBpbiB0aGlzLl9fZGF0YU9sZCkpIHtcbiAgICAgICAgICAgIHRoaXMuX19kYXRhT2xkW3Byb3BlcnR5XSA9IHRoaXMuX19kYXRhW3Byb3BlcnR5XTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gUGF0aHMgYXJlIHN0b3JlZCBpbiB0ZW1wb3JhcnkgY2FjaGUgKGNsZWFyZWQgYXQgZW5kIG9mIHR1cm4pLFxuICAgICAgICAgIC8vIHdoaWNoIGlzIHVzZWQgZm9yIGRpcnR5LWNoZWNraW5nLCBhbGwgb3RoZXJzIHN0b3JlZCBpbiBfX2RhdGFcbiAgICAgICAgICBpZiAoaXNQYXRoKSB7XG4gICAgICAgICAgICB0aGlzLl9fZGF0YVRlbXBbcHJvcGVydHldID0gdmFsdWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX19kYXRhW3Byb3BlcnR5XSA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBBbGwgY2hhbmdlcyBnbyBpbnRvIHBlbmRpbmcgcHJvcGVydHkgYmFnLCBwYXNzZWQgdG8gX3Byb3BlcnRpZXNDaGFuZ2VkXG4gICAgICAgICAgdGhpcy5fX2RhdGFQZW5kaW5nW3Byb3BlcnR5XSA9IHZhbHVlO1xuICAgICAgICAgIC8vIFRyYWNrIHByb3BlcnRpZXMgdGhhdCBzaG91bGQgbm90aWZ5IHNlcGFyYXRlbHlcbiAgICAgICAgICBpZiAoaXNQYXRoIHx8ICh0aGlzW1RZUEVTLk5PVElGWV0gJiYgdGhpc1tUWVBFUy5OT1RJRlldW3Byb3BlcnR5XSkpIHtcbiAgICAgICAgICAgIHRoaXMuX19kYXRhVG9Ob3RpZnkgPSB0aGlzLl9fZGF0YVRvTm90aWZ5IHx8IHt9O1xuICAgICAgICAgICAgdGhpcy5fX2RhdGFUb05vdGlmeVtwcm9wZXJ0eV0gPSBzaG91bGROb3RpZnk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBPdmVycmlkZXMgYmFzZSBpbXBsZW1lbnRhdGlvbiB0byBlbnN1cmUgYWxsIGFjY2Vzc29ycyBzZXQgYHNob3VsZE5vdGlmeWBcbiAgICAgICAqIHRvIHRydWUsIGZvciBwZXItcHJvcGVydHkgbm90aWZpY2F0aW9uIHRyYWNraW5nLlxuICAgICAgICpcbiAgICAgICAqIEBvdmVycmlkZVxuICAgICAgICovXG4gICAgICBfc2V0UHJvcGVydHkocHJvcGVydHksIHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLl9zZXRQZW5kaW5nUHJvcGVydHkocHJvcGVydHksIHZhbHVlLCB0cnVlKSkge1xuICAgICAgICAgIHRoaXMuX2ludmFsaWRhdGVQcm9wZXJ0aWVzKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBPdmVycmlkZXMgYFByb3BlcnR5QWNjZXNzb3JgJ3MgZGVmYXVsdCBhc3luYyBxdWV1aW5nIG9mXG4gICAgICAgKiBgX3Byb3BlcnRpZXNDaGFuZ2VkYDogaWYgYF9fZGF0YVJlYWR5YCBpcyBmYWxzZSAoaGFzIG5vdCB5ZXQgYmVlblxuICAgICAgICogbWFudWFsbHkgZmx1c2hlZCksIHRoZSBmdW5jdGlvbiBuby1vcHM7IG90aGVyd2lzZSBmbHVzaGVzXG4gICAgICAgKiBgX3Byb3BlcnRpZXNDaGFuZ2VkYCBzeW5jaHJvbm91c2x5LlxuICAgICAgICpcbiAgICAgICAqIEBvdmVycmlkZVxuICAgICAgICovXG4gICAgICBfaW52YWxpZGF0ZVByb3BlcnRpZXMoKSB7XG4gICAgICAgIGlmICh0aGlzLl9fZGF0YVJlYWR5KSB7XG4gICAgICAgICAgdGhpcy5fZmx1c2hQcm9wZXJ0aWVzKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBFbnF1ZXVlcyB0aGUgZ2l2ZW4gY2xpZW50IG9uIGEgbGlzdCBvZiBwZW5kaW5nIGNsaWVudHMsIHdob3NlXG4gICAgICAgKiBwZW5kaW5nIHByb3BlcnR5IGNoYW5nZXMgY2FuIGxhdGVyIGJlIGZsdXNoZWQgdmlhIGEgY2FsbCB0b1xuICAgICAgICogYF9mbHVzaENsaWVudHNgLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjbGllbnQgUHJvcGVydHlFZmZlY3RzIGNsaWVudCB0byBlbnF1ZXVlXG4gICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgKi9cbiAgICAgIF9lbnF1ZXVlQ2xpZW50KGNsaWVudCkge1xuICAgICAgICB0aGlzLl9fZGF0YVBlbmRpbmdDbGllbnRzID0gdGhpcy5fX2RhdGFQZW5kaW5nQ2xpZW50cyB8fCBbXTtcbiAgICAgICAgaWYgKGNsaWVudCAhPT0gdGhpcykge1xuICAgICAgICAgIHRoaXMuX19kYXRhUGVuZGluZ0NsaWVudHMucHVzaChjbGllbnQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogRmx1c2hlcyBhbnkgY2xpZW50cyBwcmV2aW91c2x5IGVucXVldWVkIHZpYSBgX2VucXVldWVDbGllbnRgLCBjYXVzaW5nXG4gICAgICAgKiB0aGVpciBgX2ZsdXNoUHJvcGVydGllc2AgbWV0aG9kIHRvIHJ1bi5cbiAgICAgICAqXG4gICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgKi9cbiAgICAgIF9mbHVzaENsaWVudHMoKSB7XG4gICAgICAgIGlmICghdGhpcy5fX2RhdGFDbGllbnRzUmVhZHkpIHtcbiAgICAgICAgICB0aGlzLl9fZGF0YUNsaWVudHNSZWFkeSA9IHRydWU7XG4gICAgICAgICAgdGhpcy5fcmVhZHlDbGllbnRzKCk7XG4gICAgICAgICAgLy8gT3ZlcnJpZGUgcG9pbnQgd2hlcmUgYWNjZXNzb3JzIGFyZSB0dXJuZWQgb247IGltcG9ydGFudGx5LFxuICAgICAgICAgIC8vIHRoaXMgaXMgYWZ0ZXIgY2xpZW50cyBoYXZlIGZ1bGx5IHJlYWRpZWQsIHByb3ZpZGluZyBhIGd1YXJhbnRlZVxuICAgICAgICAgIC8vIHRoYXQgYW55IHByb3BlcnR5IGVmZmVjdHMgb2NjdXIgb25seSBhZnRlciBhbGwgY2xpZW50cyBhcmUgcmVhZHkuXG4gICAgICAgICAgdGhpcy5fX2RhdGFSZWFkeSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fX2VuYWJsZU9yRmx1c2hDbGllbnRzKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gTk9URTogV2UgZW5zdXJlIGNsaWVudHMgZWl0aGVyIGVuYWJsZSBvciBmbHVzaCBhcyBhcHByb3ByaWF0ZS4gVGhpc1xuICAgICAgLy8gaGFuZGxlcyB0d28gY29ybmVyIGNhc2VzOlxuICAgICAgLy8gKDEpIGNsaWVudHMgZmx1c2ggcHJvcGVybHkgd2hlbiBjb25uZWN0ZWQvZW5hYmxlZCBiZWZvcmUgdGhlIGhvc3RcbiAgICAgIC8vIGVuYWJsZXM7IGUuZy5cbiAgICAgIC8vICAgKGEpIFRlbXBsYXRpemUgc3RhbXBzIHdpdGggbm8gcHJvcGVydGllcyBhbmQgZG9lcyBub3QgZmx1c2ggYW5kXG4gICAgICAvLyAgIChiKSB0aGUgaW5zdGFuY2UgaXMgaW5zZXJ0ZWQgaW50byBkb20gYW5kXG4gICAgICAvLyAgIChjKSB0aGVuIHRoZSBpbnN0YW5jZSBmbHVzaGVzLlxuICAgICAgLy8gKDIpIGNsaWVudHMgZW5hYmxlIHByb3Blcmx5IHdoZW4gbm90IGNvbm5lY3RlZC9lbmFibGVkIHdoZW4gdGhlIGhvc3RcbiAgICAgIC8vIGZsdXNoZXM7IGUuZy5cbiAgICAgIC8vICAgKGEpIGEgdGVtcGxhdGUgaXMgcnVudGltZSBzdGFtcGVkIGFuZCBub3QgeWV0IGNvbm5lY3RlZC9lbmFibGVkXG4gICAgICAvLyAgIChiKSBhIGhvc3Qgc2V0cyBhIHByb3BlcnR5LCBjYXVzaW5nIHN0YW1wZWQgZG9tIHRvIGZsdXNoXG4gICAgICAvLyAgIChjKSB0aGUgc3RhbXBlZCBkb20gZW5hYmxlcy5cbiAgICAgIF9fZW5hYmxlT3JGbHVzaENsaWVudHMoKSB7XG4gICAgICAgIGxldCBjbGllbnRzID0gdGhpcy5fX2RhdGFQZW5kaW5nQ2xpZW50cztcbiAgICAgICAgaWYgKGNsaWVudHMpIHtcbiAgICAgICAgICB0aGlzLl9fZGF0YVBlbmRpbmdDbGllbnRzID0gbnVsbDtcbiAgICAgICAgICBmb3IgKGxldCBpPTA7IGkgPCBjbGllbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY2xpZW50ID0gY2xpZW50c1tpXTtcbiAgICAgICAgICAgIGlmICghY2xpZW50Ll9fZGF0YUVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgY2xpZW50Ll9lbmFibGVQcm9wZXJ0aWVzKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNsaWVudC5fX2RhdGFQZW5kaW5nKSB7XG4gICAgICAgICAgICAgIGNsaWVudC5fZmx1c2hQcm9wZXJ0aWVzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUGVyZm9ybSBhbnkgaW5pdGlhbCBzZXR1cCBvbiBjbGllbnQgZG9tLiBDYWxsZWQgYmVmb3JlIHRoZSBmaXJzdFxuICAgICAgICogYF9mbHVzaFByb3BlcnRpZXNgIGNhbGwgb24gY2xpZW50IGRvbSBhbmQgYmVmb3JlIGFueSBlbGVtZW50XG4gICAgICAgKiBvYnNlcnZlcnMgYXJlIGNhbGxlZC5cbiAgICAgICAqXG4gICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgKi9cbiAgICAgIF9yZWFkeUNsaWVudHMoKSB7XG4gICAgICAgIHRoaXMuX19lbmFibGVPckZsdXNoQ2xpZW50cygpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFNldHMgYSBiYWcgb2YgcHJvcGVydHkgY2hhbmdlcyB0byB0aGlzIGluc3RhbmNlLCBhbmRcbiAgICAgICAqIHN5bmNocm9ub3VzbHkgcHJvY2Vzc2VzIGFsbCBlZmZlY3RzIG9mIHRoZSBwcm9wZXJ0aWVzIGFzIGEgYmF0Y2guXG4gICAgICAgKlxuICAgICAgICogUHJvcGVydHkgbmFtZXMgbXVzdCBiZSBzaW1wbGUgcHJvcGVydGllcywgbm90IHBhdGhzLiAgQmF0Y2hlZFxuICAgICAgICogcGF0aCBwcm9wYWdhdGlvbiBpcyBub3Qgc3VwcG9ydGVkLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBCYWcgb2Ygb25lIG9yIG1vcmUga2V5LXZhbHVlIHBhaXJzIHdob3NlIGtleSBpc1xuICAgICAgICogICBhIHByb3BlcnR5IGFuZCB2YWx1ZSBpcyB0aGUgbmV3IHZhbHVlIHRvIHNldCBmb3IgdGhhdCBwcm9wZXJ0eS5cbiAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IHNldFJlYWRPbmx5IFdoZW4gdHJ1ZSwgYW55IHByaXZhdGUgdmFsdWVzIHNldCBpblxuICAgICAgICogICBgcHJvcHNgIHdpbGwgYmUgc2V0LiBCeSBkZWZhdWx0LCBgc2V0UHJvcGVydGllc2Agd2lsbCBub3Qgc2V0XG4gICAgICAgKiAgIGByZWFkT25seTogdHJ1ZWAgcm9vdCBwcm9wZXJ0aWVzLlxuICAgICAgICogQHB1YmxpY1xuICAgICAgICovXG4gICAgICBzZXRQcm9wZXJ0aWVzKHByb3BzLCBzZXRSZWFkT25seSkge1xuICAgICAgICBmb3IgKGxldCBwYXRoIGluIHByb3BzKSB7XG4gICAgICAgICAgaWYgKHNldFJlYWRPbmx5IHx8ICF0aGlzW1RZUEVTLlJFQURfT05MWV0gfHwgIXRoaXNbVFlQRVMuUkVBRF9PTkxZXVtwYXRoXSkge1xuICAgICAgICAgICAgLy9UT0RPKGtzY2hhYWYpOiBleHBsaWNpdGx5IGRpc2FsbG93IHBhdGhzIGluIHNldFByb3BlcnR5P1xuICAgICAgICAgICAgLy8gd2lsZGNhcmQgb2JzZXJ2ZXJzIGN1cnJlbnRseSBvbmx5IHBhc3MgdGhlIGZpcnN0IGNoYW5nZWQgcGF0aFxuICAgICAgICAgICAgLy8gaW4gdGhlIGBpbmZvYCBvYmplY3QsIGFuZCB5b3UgY291bGQgZG8gc29tZSBvZGQgdGhpbmdzIGJhdGNoaW5nXG4gICAgICAgICAgICAvLyBwYXRocywgZS5nLiB7J2Zvby5iYXInOiB7Li4ufSwgJ2Zvbyc6IG51bGx9XG4gICAgICAgICAgICB0aGlzLl9zZXRQZW5kaW5nUHJvcGVydHlPclBhdGgocGF0aCwgcHJvcHNbcGF0aF0sIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pbnZhbGlkYXRlUHJvcGVydGllcygpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIE92ZXJyaWRlcyBgUHJvcGVydHlBY2Nlc3NvcnNgIHNvIHRoYXQgcHJvcGVydHkgYWNjZXNzb3JcbiAgICAgICAqIHNpZGUgZWZmZWN0cyBhcmUgbm90IGVuYWJsZWQgdW50aWwgYWZ0ZXIgY2xpZW50IGRvbSBpcyBmdWxseSByZWFkeS5cbiAgICAgICAqIEFsc28gY2FsbHMgYF9mbHVzaENsaWVudHNgIGNhbGxiYWNrIHRvIGVuc3VyZSBjbGllbnQgZG9tIGlzIGVuYWJsZWRcbiAgICAgICAqIHRoYXQgd2FzIG5vdCBlbmFibGVkIGFzIGEgcmVzdWx0IG9mIGZsdXNoaW5nIHByb3BlcnRpZXMuXG4gICAgICAgKlxuICAgICAgICogQG92ZXJyaWRlXG4gICAgICAgKi9cbiAgICAgIHJlYWR5KCkge1xuICAgICAgICAvLyBJdCBpcyBpbXBvcnRhbnQgdGhhdCBgc3VwZXIucmVhZHkoKWAgaXMgbm90IGNhbGxlZCBoZXJlIGFzIGl0XG4gICAgICAgIC8vIGltbWVkaWF0ZWx5IHR1cm5zIG9uIGFjY2Vzc29ycy4gSW5zdGVhZCwgd2Ugd2FpdCB1bnRpbCBgcmVhZHlDbGllbnRzYFxuICAgICAgICAvLyB0byBlbmFibGUgYWNjZXNzb3JzIHRvIHByb3ZpZGUgYSBndWFyYW50ZWUgdGhhdCBjbGllbnRzIGFyZSByZWFkeVxuICAgICAgICAvLyBiZWZvcmUgcHJvY2Vzc2luZyBhbnkgYWNjZXNzb3JzIHNpZGUgZWZmZWN0cy5cbiAgICAgICAgdGhpcy5fZmx1c2hQcm9wZXJ0aWVzKCk7XG4gICAgICAgIC8vIElmIG5vIGRhdGEgd2FzIHBlbmRpbmcsIGBfZmx1c2hQcm9wZXJ0aWVzYCB3aWxsIG5vdCBgZmx1c2hDbGllbnRzYFxuICAgICAgICAvLyBzbyBlbnN1cmUgdGhpcyBpcyBkb25lLlxuICAgICAgICBpZiAoIXRoaXMuX19kYXRhQ2xpZW50c1JlYWR5KSB7XG4gICAgICAgICAgdGhpcy5fZmx1c2hDbGllbnRzKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQmVmb3JlIHJlYWR5LCBjbGllbnQgbm90aWZpY2F0aW9ucyBkbyBub3QgdHJpZ2dlciBfZmx1c2hQcm9wZXJ0aWVzLlxuICAgICAgICAvLyBUaGVyZWZvcmUgYSBmbHVzaCBpcyBuZWNlc3NhcnkgaGVyZSBpZiBkYXRhIGhhcyBiZWVuIHNldC5cbiAgICAgICAgaWYgKHRoaXMuX19kYXRhUGVuZGluZykge1xuICAgICAgICAgIHRoaXMuX2ZsdXNoUHJvcGVydGllcygpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogSW1wbGVtZW50cyBgUHJvcGVydHlBY2Nlc3NvcnNgJ3MgcHJvcGVydGllcyBjaGFuZ2VkIGNhbGxiYWNrLlxuICAgICAgICpcbiAgICAgICAqIFJ1bnMgZWFjaCBjbGFzcyBvZiBlZmZlY3RzIGZvciB0aGUgYmF0Y2ggb2YgY2hhbmdlZCBwcm9wZXJ0aWVzIGluXG4gICAgICAgKiBhIHNwZWNpZmljIG9yZGVyIChjb21wdXRlLCBwcm9wYWdhdGUsIHJlZmxlY3QsIG9ic2VydmUsIG5vdGlmeSkuXG4gICAgICAgKlxuICAgICAgICogQG92ZXJyaWRlXG4gICAgICAgKi9cbiAgICAgIF9wcm9wZXJ0aWVzQ2hhbmdlZChjdXJyZW50UHJvcHMsIGNoYW5nZWRQcm9wcywgb2xkUHJvcHMpIHtcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyBsZXQgYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGNoYW5nZWRQcm9wcyB8fCB7fSk7XG4gICAgICAgIC8vIHdpbmRvdy5kZWJ1ZyAmJiBjb25zb2xlLmdyb3VwKHRoaXMubG9jYWxOYW1lICsgJyMnICsgdGhpcy5pZCArICc6ICcgKyBjKTtcbiAgICAgICAgLy8gaWYgKHdpbmRvdy5kZWJ1ZykgeyBkZWJ1Z2dlcjsgfVxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIGxldCBoYXNQYXRocyA9IHRoaXMuX19kYXRhSGFzUGF0aHM7XG4gICAgICAgIHRoaXMuX19kYXRhSGFzUGF0aHMgPSBmYWxzZTtcbiAgICAgICAgLy8gQ29tcHV0ZSBwcm9wZXJ0aWVzXG4gICAgICAgIHJ1bkNvbXB1dGVkRWZmZWN0cyh0aGlzLCBjaGFuZ2VkUHJvcHMsIG9sZFByb3BzLCBoYXNQYXRocyk7XG4gICAgICAgIC8vIENsZWFyIG5vdGlmeSBwcm9wZXJ0aWVzIHByaW9yIHRvIHBvc3NpYmxlIHJlZW50cnkgKHByb3BhZ2F0ZSwgb2JzZXJ2ZSksXG4gICAgICAgIC8vIGJ1dCBhZnRlciBjb21wdXRpbmcgZWZmZWN0cyBoYXZlIGEgY2hhbmNlIHRvIGFkZCB0byB0aGVtXG4gICAgICAgIGxldCBub3RpZnlQcm9wcyA9IHRoaXMuX19kYXRhVG9Ob3RpZnk7XG4gICAgICAgIHRoaXMuX19kYXRhVG9Ob3RpZnkgPSBudWxsO1xuICAgICAgICAvLyBQcm9wYWdhdGUgcHJvcGVydGllcyB0byBjbGllbnRzXG4gICAgICAgIHRoaXMuX3Byb3BhZ2F0ZVByb3BlcnR5Q2hhbmdlcyhjaGFuZ2VkUHJvcHMsIG9sZFByb3BzLCBoYXNQYXRocyk7XG4gICAgICAgIC8vIEZsdXNoIGNsaWVudHNcbiAgICAgICAgdGhpcy5fZmx1c2hDbGllbnRzKCk7XG4gICAgICAgIC8vIFJlZmxlY3QgcHJvcGVydGllc1xuICAgICAgICBydW5FZmZlY3RzKHRoaXMsIHRoaXNbVFlQRVMuUkVGTEVDVF0sIGNoYW5nZWRQcm9wcywgb2xkUHJvcHMsIGhhc1BhdGhzKTtcbiAgICAgICAgLy8gT2JzZXJ2ZSBwcm9wZXJ0aWVzXG4gICAgICAgIHJ1bkVmZmVjdHModGhpcywgdGhpc1tUWVBFUy5PQlNFUlZFXSwgY2hhbmdlZFByb3BzLCBvbGRQcm9wcywgaGFzUGF0aHMpO1xuICAgICAgICAvLyBOb3RpZnkgcHJvcGVydGllcyB0byBob3N0XG4gICAgICAgIGlmIChub3RpZnlQcm9wcykge1xuICAgICAgICAgIHJ1bk5vdGlmeUVmZmVjdHModGhpcywgbm90aWZ5UHJvcHMsIGNoYW5nZWRQcm9wcywgb2xkUHJvcHMsIGhhc1BhdGhzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDbGVhciB0ZW1wb3JhcnkgY2FjaGUgYXQgZW5kIG9mIHR1cm5cbiAgICAgICAgaWYgKHRoaXMuX19kYXRhQ291bnRlciA9PSAxKSB7XG4gICAgICAgICAgdGhpcy5fX2RhdGFUZW1wID0ge307XG4gICAgICAgIH1cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyB3aW5kb3cuZGVidWcgJiYgY29uc29sZS5ncm91cEVuZCh0aGlzLmxvY2FsTmFtZSArICcjJyArIHRoaXMuaWQgKyAnOiAnICsgYyk7XG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDYWxsZWQgdG8gcHJvcGFnYXRlIGFueSBwcm9wZXJ0eSBjaGFuZ2VzIHRvIHN0YW1wZWQgdGVtcGxhdGUgbm9kZXNcbiAgICAgICAqIG1hbmFnZWQgYnkgdGhpcyBlbGVtZW50LlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjaGFuZ2VkUHJvcHMgQmFnIG9mIGNoYW5nZWQgcHJvcGVydGllc1xuICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9sZFByb3BzIEJhZyBvZiBwcmV2aW91cyB2YWx1ZXMgZm9yIGNoYW5nZWQgcHJvcGVydGllc1xuICAgICAgICogQHBhcmFtIHtib29sZWFufSBoYXNQYXRocyBUcnVlIHdpdGggYHByb3BzYCBjb250YWlucyBvbmUgb3IgbW9yZSBwYXRoc1xuICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICovXG4gICAgICBfcHJvcGFnYXRlUHJvcGVydHlDaGFuZ2VzKGNoYW5nZWRQcm9wcywgb2xkUHJvcHMsIGhhc1BhdGhzKSB7XG4gICAgICAgIGlmICh0aGlzW1RZUEVTLlBST1BBR0FURV0pIHtcbiAgICAgICAgICBydW5FZmZlY3RzKHRoaXMsIHRoaXNbVFlQRVMuUFJPUEFHQVRFXSwgY2hhbmdlZFByb3BzLCBvbGRQcm9wcywgaGFzUGF0aHMpO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0ZW1wbGF0ZUluZm8gPSB0aGlzLl9fdGVtcGxhdGVJbmZvO1xuICAgICAgICB3aGlsZSAodGVtcGxhdGVJbmZvKSB7XG4gICAgICAgICAgcnVuRWZmZWN0cyh0aGlzLCB0ZW1wbGF0ZUluZm8ucHJvcGVydHlFZmZlY3RzLCBjaGFuZ2VkUHJvcHMsIG9sZFByb3BzLFxuICAgICAgICAgICAgaGFzUGF0aHMsIHRlbXBsYXRlSW5mby5ub2RlTGlzdCk7XG4gICAgICAgICAgdGVtcGxhdGVJbmZvID0gdGVtcGxhdGVJbmZvLm5leHRUZW1wbGF0ZUluZm87XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBBbGlhc2VzIG9uZSBkYXRhIHBhdGggYXMgYW5vdGhlciwgc3VjaCB0aGF0IHBhdGggbm90aWZpY2F0aW9ucyBmcm9tIG9uZVxuICAgICAgICogYXJlIHJvdXRlZCB0byB0aGUgb3RoZXIuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmcgfCAhQXJyYXk8c3RyaW5nfG51bWJlcj59IHRvIFRhcmdldCBwYXRoIHRvIGxpbmsuXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZyB8ICFBcnJheTxzdHJpbmd8bnVtYmVyPn0gZnJvbSBTb3VyY2UgcGF0aCB0byBsaW5rLlxuICAgICAgICogQHB1YmxpY1xuICAgICAgICovXG4gICAgICBsaW5rUGF0aHModG8sIGZyb20pIHtcbiAgICAgICAgdG8gPSBQb2x5bWVyLlBhdGgubm9ybWFsaXplKHRvKTtcbiAgICAgICAgZnJvbSA9IFBvbHltZXIuUGF0aC5ub3JtYWxpemUoZnJvbSk7XG4gICAgICAgIHRoaXMuX19kYXRhTGlua2VkUGF0aHMgPSB0aGlzLl9fZGF0YUxpbmtlZFBhdGhzIHx8IHt9O1xuICAgICAgICB0aGlzLl9fZGF0YUxpbmtlZFBhdGhzW3RvXSA9IGZyb207XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUmVtb3ZlcyBhIGRhdGEgcGF0aCBhbGlhcyBwcmV2aW91c2x5IGVzdGFibGlzaGVkIHdpdGggYF9saW5rUGF0aHNgLlxuICAgICAgICpcbiAgICAgICAqIE5vdGUsIHRoZSBwYXRoIHRvIHVubGluayBzaG91bGQgYmUgdGhlIHRhcmdldCAoYHRvYCkgdXNlZCB3aGVuXG4gICAgICAgKiBsaW5raW5nIHRoZSBwYXRocy5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZyB8ICFBcnJheTxzdHJpbmd8bnVtYmVyPn0gcGF0aCBUYXJnZXQgcGF0aCB0byB1bmxpbmsuXG4gICAgICAgKiBAcHVibGljXG4gICAgICAgKi9cbiAgICAgIHVubGlua1BhdGhzKHBhdGgpIHtcbiAgICAgICAgcGF0aCA9IFBvbHltZXIuUGF0aC5ub3JtYWxpemUocGF0aCk7XG4gICAgICAgIGlmICh0aGlzLl9fZGF0YUxpbmtlZFBhdGhzKSB7XG4gICAgICAgICAgZGVsZXRlIHRoaXMuX19kYXRhTGlua2VkUGF0aHNbcGF0aF07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBOb3RpZnkgdGhhdCBhbiBhcnJheSBoYXMgY2hhbmdlZC5cbiAgICAgICAqXG4gICAgICAgKiBFeGFtcGxlOlxuICAgICAgICpcbiAgICAgICAqICAgICB0aGlzLml0ZW1zID0gWyB7bmFtZTogJ0ppbSd9LCB7bmFtZTogJ1RvZGQnfSwge25hbWU6ICdCaWxsJ30gXTtcbiAgICAgICAqICAgICAuLi5cbiAgICAgICAqICAgICB0aGlzLml0ZW1zLnNwbGljZSgxLCAxLCB7bmFtZTogJ1NhbSd9KTtcbiAgICAgICAqICAgICB0aGlzLml0ZW1zLnB1c2goe25hbWU6ICdCb2InfSk7XG4gICAgICAgKiAgICAgdGhpcy5ub3RpZnlTcGxpY2VzKCdpdGVtcycsIFtcbiAgICAgICAqICAgICAgIHsgaW5kZXg6IDEsIHJlbW92ZWQ6IFt7bmFtZTogJ1RvZGQnfV0sIGFkZGVkQ291bnQ6IDEsIG9iZWN0OiB0aGlzLml0ZW1zLCB0eXBlOiAnc3BsaWNlJyB9LFxuICAgICAgICogICAgICAgeyBpbmRleDogMywgcmVtb3ZlZDogW10sIGFkZGVkQ291bnQ6IDEsIG9iamVjdDogdGhpcy5pdGVtcywgdHlwZTogJ3NwbGljZSd9XG4gICAgICAgKiAgICAgXSk7XG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggUGF0aCB0aGF0IHNob3VsZCBiZSBub3RpZmllZC5cbiAgICAgICAqIEBwYXJhbSB7QXJyYXl9IHNwbGljZXMgQXJyYXkgb2Ygc3BsaWNlIHJlY29yZHMgaW5kaWNhdGluZyBvcmRlcmVkXG4gICAgICAgKiAgIGNoYW5nZXMgdGhhdCBvY2N1cnJlZCB0byB0aGUgYXJyYXkuIEVhY2ggcmVjb3JkIHNob3VsZCBoYXZlIHRoZVxuICAgICAgICogICBmb2xsb3dpbmcgZmllbGRzOlxuICAgICAgICogICAgKiBpbmRleDogaW5kZXggYXQgd2hpY2ggdGhlIGNoYW5nZSBvY2N1cnJlZFxuICAgICAgICogICAgKiByZW1vdmVkOiBhcnJheSBvZiBpdGVtcyB0aGF0IHdlcmUgcmVtb3ZlZCBmcm9tIHRoaXMgaW5kZXhcbiAgICAgICAqICAgICogYWRkZWRDb3VudDogbnVtYmVyIG9mIG5ldyBpdGVtcyBhZGRlZCBhdCB0aGlzIGluZGV4XG4gICAgICAgKiAgICAqIG9iamVjdDogYSByZWZlcmVuY2UgdG8gdGhlIGFycmF5IGluIHF1ZXN0aW9uXG4gICAgICAgKiAgICAqIHR5cGU6IHRoZSBzdHJpbmcgbGl0ZXJhbCAnc3BsaWNlJ1xuICAgICAgICpcbiAgICAgICAqICAgTm90ZSB0aGF0IHNwbGljZSByZWNvcmRzIF9tdXN0XyBiZSBub3JtYWxpemVkIHN1Y2ggdGhhdCB0aGV5IGFyZVxuICAgICAgICogICByZXBvcnRlZCBpbiBpbmRleCBvcmRlciAocmF3IHJlc3VsdHMgZnJvbSBgT2JqZWN0Lm9ic2VydmVgIGFyZSBub3RcbiAgICAgICAqICAgb3JkZXJlZCBhbmQgbXVzdCBiZSBub3JtYWxpemVkL21lcmdlZCBiZWZvcmUgbm90aWZ5aW5nKS5cbiAgICAgICAqIEBwdWJsaWNcbiAgICAgICovXG4gICAgICBub3RpZnlTcGxpY2VzKHBhdGgsIHNwbGljZXMpIHtcbiAgICAgICAgbGV0IGluZm8gPSB7cGF0aDogJyd9O1xuICAgICAgICBsZXQgYXJyYXkgPSAvKiogQHR5cGUge0FycmF5fSAqLyhQb2x5bWVyLlBhdGguZ2V0KHRoaXMsIHBhdGgsIGluZm8pKTtcbiAgICAgICAgbm90aWZ5U3BsaWNlcyh0aGlzLCBhcnJheSwgaW5mby5wYXRoLCBzcGxpY2VzKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDb252ZW5pZW5jZSBtZXRob2QgZm9yIHJlYWRpbmcgYSB2YWx1ZSBmcm9tIGEgcGF0aC5cbiAgICAgICAqXG4gICAgICAgKiBOb3RlLCBpZiBhbnkgcGFydCBpbiB0aGUgcGF0aCBpcyB1bmRlZmluZWQsIHRoaXMgbWV0aG9kIHJldHVybnNcbiAgICAgICAqIGB1bmRlZmluZWRgICh0aGlzIG1ldGhvZCBkb2VzIG5vdCB0aHJvdyB3aGVuIGRlcmVmZXJlbmNpbmcgdW5kZWZpbmVkXG4gICAgICAgKiBwYXRocykuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHsoc3RyaW5nfCFBcnJheTwoc3RyaW5nfG51bWJlcik+KX0gcGF0aCBQYXRoIHRvIHRoZSB2YWx1ZVxuICAgICAgICogICB0byByZWFkLiAgVGhlIHBhdGggbWF5IGJlIHNwZWNpZmllZCBhcyBhIHN0cmluZyAoZS5nLiBgZm9vLmJhci5iYXpgKVxuICAgICAgICogICBvciBhbiBhcnJheSBvZiBwYXRoIHBhcnRzIChlLmcuIGBbJ2Zvby5iYXInLCAnYmF6J11gKS4gIE5vdGUgdGhhdFxuICAgICAgICogICBicmFja2V0ZWQgZXhwcmVzc2lvbnMgYXJlIG5vdCBzdXBwb3J0ZWQ7IHN0cmluZy1iYXNlZCBwYXRoIHBhcnRzXG4gICAgICAgKiAgICptdXN0KiBiZSBzZXBhcmF0ZWQgYnkgZG90cy4gIE5vdGUgdGhhdCB3aGVuIGRlcmVmZXJlbmNpbmcgYXJyYXlcbiAgICAgICAqICAgaW5kaWNlcywgdGhlIGluZGV4IG1heSBiZSB1c2VkIGFzIGEgZG90dGVkIHBhcnQgZGlyZWN0bHlcbiAgICAgICAqICAgKGUuZy4gYHVzZXJzLjEyLm5hbWVgIG9yIGBbJ3VzZXJzJywgMTIsICduYW1lJ11gKS5cbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0PX0gcm9vdCBSb290IG9iamVjdCBmcm9tIHdoaWNoIHRoZSBwYXRoIGlzIGV2YWx1YXRlZC5cbiAgICAgICAqIEByZXR1cm4geyp9IFZhbHVlIGF0IHRoZSBwYXRoLCBvciBgdW5kZWZpbmVkYCBpZiBhbnkgcGFydCBvZiB0aGUgcGF0aFxuICAgICAgICogICBpcyB1bmRlZmluZWQuXG4gICAgICAgKiBAcHVibGljXG4gICAgICAgKi9cbiAgICAgIGdldChwYXRoLCByb290KSB7XG4gICAgICAgIHJldHVybiBQb2x5bWVyLlBhdGguZ2V0KHJvb3QgfHwgdGhpcywgcGF0aCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ29udmVuaWVuY2UgbWV0aG9kIGZvciBzZXR0aW5nIGEgdmFsdWUgdG8gYSBwYXRoIGFuZCBub3RpZnlpbmcgYW55XG4gICAgICAgKiBlbGVtZW50cyBib3VuZCB0byB0aGUgc2FtZSBwYXRoLlxuICAgICAgICpcbiAgICAgICAqIE5vdGUsIGlmIGFueSBwYXJ0IGluIHRoZSBwYXRoIGV4Y2VwdCBmb3IgdGhlIGxhc3QgaXMgdW5kZWZpbmVkLFxuICAgICAgICogdGhpcyBtZXRob2QgZG9lcyBub3RoaW5nICh0aGlzIG1ldGhvZCBkb2VzIG5vdCB0aHJvdyB3aGVuXG4gICAgICAgKiBkZXJlZmVyZW5jaW5nIHVuZGVmaW5lZCBwYXRocykuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHsoc3RyaW5nfCFBcnJheTwoc3RyaW5nfG51bWJlcik+KX0gcGF0aCBQYXRoIHRvIHRoZSB2YWx1ZVxuICAgICAgICogICB0byB3cml0ZS4gIFRoZSBwYXRoIG1heSBiZSBzcGVjaWZpZWQgYXMgYSBzdHJpbmcgKGUuZy4gYCdmb28uYmFyLmJheidgKVxuICAgICAgICogICBvciBhbiBhcnJheSBvZiBwYXRoIHBhcnRzIChlLmcuIGBbJ2Zvby5iYXInLCAnYmF6J11gKS4gIE5vdGUgdGhhdFxuICAgICAgICogICBicmFja2V0ZWQgZXhwcmVzc2lvbnMgYXJlIG5vdCBzdXBwb3J0ZWQ7IHN0cmluZy1iYXNlZCBwYXRoIHBhcnRzXG4gICAgICAgKiAgICptdXN0KiBiZSBzZXBhcmF0ZWQgYnkgZG90cy4gIE5vdGUgdGhhdCB3aGVuIGRlcmVmZXJlbmNpbmcgYXJyYXlcbiAgICAgICAqICAgaW5kaWNlcywgdGhlIGluZGV4IG1heSBiZSB1c2VkIGFzIGEgZG90dGVkIHBhcnQgZGlyZWN0bHlcbiAgICAgICAqICAgKGUuZy4gYCd1c2Vycy4xMi5uYW1lJ2Agb3IgYFsndXNlcnMnLCAxMiwgJ25hbWUnXWApLlxuICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byBzZXQgYXQgdGhlIHNwZWNpZmllZCBwYXRoLlxuICAgICAgICogQHBhcmFtIHtPYmplY3Q9fSByb290IFJvb3Qgb2JqZWN0IGZyb20gd2hpY2ggdGhlIHBhdGggaXMgZXZhbHVhdGVkLlxuICAgICAgICogICBXaGVuIHNwZWNpZmllZCwgbm8gbm90aWZpY2F0aW9uIHdpbGwgb2NjdXIuXG4gICAgICAgKiBAcHVibGljXG4gICAgICAqL1xuICAgICAgc2V0KHBhdGgsIHZhbHVlLCByb290KSB7XG4gICAgICAgIGlmIChyb290KSB7XG4gICAgICAgICAgUG9seW1lci5QYXRoLnNldChyb290LCBwYXRoLCB2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCF0aGlzW1RZUEVTLlJFQURfT05MWV0gfHwgIXRoaXNbVFlQRVMuUkVBRF9PTkxZXVsvKiogQHR5cGUge3N0cmluZ30gKi8ocGF0aCldKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fc2V0UGVuZGluZ1Byb3BlcnR5T3JQYXRoKHBhdGgsIHZhbHVlLCB0cnVlKSkge1xuICAgICAgICAgICAgICB0aGlzLl9pbnZhbGlkYXRlUHJvcGVydGllcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEFkZHMgaXRlbXMgb250byB0aGUgZW5kIG9mIHRoZSBhcnJheSBhdCB0aGUgcGF0aCBzcGVjaWZpZWQuXG4gICAgICAgKlxuICAgICAgICogVGhlIGFyZ3VtZW50cyBhZnRlciBgcGF0aGAgYW5kIHJldHVybiB2YWx1ZSBtYXRjaCB0aGF0IG9mXG4gICAgICAgKiBgQXJyYXkucHJvdG90eXBlLnB1c2hgLlxuICAgICAgICpcbiAgICAgICAqIFRoaXMgbWV0aG9kIG5vdGlmaWVzIG90aGVyIHBhdGhzIHRvIHRoZSBzYW1lIGFycmF5IHRoYXQgYVxuICAgICAgICogc3BsaWNlIG9jY3VycmVkIHRvIHRoZSBhcnJheS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBQYXRoIHRvIGFycmF5LlxuICAgICAgICogQHBhcmFtIHsuLi4qfSBpdGVtcyBJdGVtcyB0byBwdXNoIG9udG8gYXJyYXlcbiAgICAgICAqIEByZXR1cm4ge251bWJlcn0gTmV3IGxlbmd0aCBvZiB0aGUgYXJyYXkuXG4gICAgICAgKiBAcHVibGljXG4gICAgICAgKi9cbiAgICAgIHB1c2gocGF0aCwgLi4uaXRlbXMpIHtcbiAgICAgICAgbGV0IGluZm8gPSB7cGF0aDogJyd9O1xuICAgICAgICBsZXQgYXJyYXkgPSAvKiogQHR5cGUge0FycmF5fSovKFBvbHltZXIuUGF0aC5nZXQodGhpcywgcGF0aCwgaW5mbykpO1xuICAgICAgICBsZXQgbGVuID0gYXJyYXkubGVuZ3RoO1xuICAgICAgICBsZXQgcmV0ID0gYXJyYXkucHVzaCguLi5pdGVtcyk7XG4gICAgICAgIGlmIChpdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICBub3RpZnlTcGxpY2UodGhpcywgYXJyYXksIGluZm8ucGF0aCwgbGVuLCBpdGVtcy5sZW5ndGgsIFtdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJlbW92ZXMgYW4gaXRlbSBmcm9tIHRoZSBlbmQgb2YgYXJyYXkgYXQgdGhlIHBhdGggc3BlY2lmaWVkLlxuICAgICAgICpcbiAgICAgICAqIFRoZSBhcmd1bWVudHMgYWZ0ZXIgYHBhdGhgIGFuZCByZXR1cm4gdmFsdWUgbWF0Y2ggdGhhdCBvZlxuICAgICAgICogYEFycmF5LnByb3RvdHlwZS5wb3BgLlxuICAgICAgICpcbiAgICAgICAqIFRoaXMgbWV0aG9kIG5vdGlmaWVzIG90aGVyIHBhdGhzIHRvIHRoZSBzYW1lIGFycmF5IHRoYXQgYVxuICAgICAgICogc3BsaWNlIG9jY3VycmVkIHRvIHRoZSBhcnJheS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBQYXRoIHRvIGFycmF5LlxuICAgICAgICogQHJldHVybiB7Kn0gSXRlbSB0aGF0IHdhcyByZW1vdmVkLlxuICAgICAgICogQHB1YmxpY1xuICAgICAgICovXG4gICAgICBwb3AocGF0aCkge1xuICAgICAgICBsZXQgaW5mbyA9IHtwYXRoOiAnJ307XG4gICAgICAgIGxldCBhcnJheSA9IC8qKiBAdHlwZSB7QXJyYXl9ICovKFBvbHltZXIuUGF0aC5nZXQodGhpcywgcGF0aCwgaW5mbykpO1xuICAgICAgICBsZXQgaGFkTGVuZ3RoID0gQm9vbGVhbihhcnJheS5sZW5ndGgpO1xuICAgICAgICBsZXQgcmV0ID0gYXJyYXkucG9wKCk7XG4gICAgICAgIGlmIChoYWRMZW5ndGgpIHtcbiAgICAgICAgICBub3RpZnlTcGxpY2UodGhpcywgYXJyYXksIGluZm8ucGF0aCwgYXJyYXkubGVuZ3RoLCAwLCBbcmV0XSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBTdGFydGluZyBmcm9tIHRoZSBzdGFydCBpbmRleCBzcGVjaWZpZWQsIHJlbW92ZXMgMCBvciBtb3JlIGl0ZW1zXG4gICAgICAgKiBmcm9tIHRoZSBhcnJheSBhbmQgaW5zZXJ0cyAwIG9yIG1vcmUgbmV3IGl0ZW1zIGluIHRoZWlyIHBsYWNlLlxuICAgICAgICpcbiAgICAgICAqIFRoZSBhcmd1bWVudHMgYWZ0ZXIgYHBhdGhgIGFuZCByZXR1cm4gdmFsdWUgbWF0Y2ggdGhhdCBvZlxuICAgICAgICogYEFycmF5LnByb3RvdHlwZS5zcGxpY2VgLlxuICAgICAgICpcbiAgICAgICAqIFRoaXMgbWV0aG9kIG5vdGlmaWVzIG90aGVyIHBhdGhzIHRvIHRoZSBzYW1lIGFycmF5IHRoYXQgYVxuICAgICAgICogc3BsaWNlIG9jY3VycmVkIHRvIHRoZSBhcnJheS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBQYXRoIHRvIGFycmF5LlxuICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IEluZGV4IGZyb20gd2hpY2ggdG8gc3RhcnQgcmVtb3ZpbmcvaW5zZXJ0aW5nLlxuICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGRlbGV0ZUNvdW50IE51bWJlciBvZiBpdGVtcyB0byByZW1vdmUuXG4gICAgICAgKiBAcGFyYW0gey4uLip9IGl0ZW1zIEl0ZW1zIHRvIGluc2VydCBpbnRvIGFycmF5LlxuICAgICAgICogQHJldHVybiB7QXJyYXl9IEFycmF5IG9mIHJlbW92ZWQgaXRlbXMuXG4gICAgICAgKiBAcHVibGljXG4gICAgICAgKi9cbiAgICAgIHNwbGljZShwYXRoLCBzdGFydCwgZGVsZXRlQ291bnQsIC4uLml0ZW1zKSB7XG4gICAgICAgIGxldCBpbmZvID0ge3BhdGggOiAnJ307XG4gICAgICAgIGxldCBhcnJheSA9IC8qKiBAdHlwZSB7QXJyYXl9ICovKFBvbHltZXIuUGF0aC5nZXQodGhpcywgcGF0aCwgaW5mbykpO1xuICAgICAgICAvLyBOb3JtYWxpemUgZmFuY3kgbmF0aXZlIHNwbGljZSBoYW5kbGluZyBvZiBjcmF6eSBzdGFydCB2YWx1ZXNcbiAgICAgICAgaWYgKHN0YXJ0IDwgMCkge1xuICAgICAgICAgIHN0YXJ0ID0gYXJyYXkubGVuZ3RoIC0gTWF0aC5mbG9vcigtc3RhcnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0YXJ0ID0gTWF0aC5mbG9vcihzdGFydCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzdGFydCkge1xuICAgICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmV0ID0gYXJyYXkuc3BsaWNlKHN0YXJ0LCBkZWxldGVDb3VudCwgLi4uaXRlbXMpO1xuICAgICAgICBpZiAoaXRlbXMubGVuZ3RoIHx8IHJldC5sZW5ndGgpIHtcbiAgICAgICAgICBub3RpZnlTcGxpY2UodGhpcywgYXJyYXksIGluZm8ucGF0aCwgc3RhcnQsIGl0ZW1zLmxlbmd0aCwgcmV0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJlbW92ZXMgYW4gaXRlbSBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgYXJyYXkgYXQgdGhlIHBhdGggc3BlY2lmaWVkLlxuICAgICAgICpcbiAgICAgICAqIFRoZSBhcmd1bWVudHMgYWZ0ZXIgYHBhdGhgIGFuZCByZXR1cm4gdmFsdWUgbWF0Y2ggdGhhdCBvZlxuICAgICAgICogYEFycmF5LnByb3RvdHlwZS5wb3BgLlxuICAgICAgICpcbiAgICAgICAqIFRoaXMgbWV0aG9kIG5vdGlmaWVzIG90aGVyIHBhdGhzIHRvIHRoZSBzYW1lIGFycmF5IHRoYXQgYVxuICAgICAgICogc3BsaWNlIG9jY3VycmVkIHRvIHRoZSBhcnJheS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBQYXRoIHRvIGFycmF5LlxuICAgICAgICogQHJldHVybiB7Kn0gSXRlbSB0aGF0IHdhcyByZW1vdmVkLlxuICAgICAgICogQHB1YmxpY1xuICAgICAgICovXG4gICAgICBzaGlmdChwYXRoKSB7XG4gICAgICAgIGxldCBpbmZvID0ge3BhdGg6ICcnfTtcbiAgICAgICAgbGV0IGFycmF5ID0gLyoqIEB0eXBlIHtBcnJheX0gKi8oUG9seW1lci5QYXRoLmdldCh0aGlzLCBwYXRoLCBpbmZvKSk7XG4gICAgICAgIGxldCBoYWRMZW5ndGggPSBCb29sZWFuKGFycmF5Lmxlbmd0aCk7XG4gICAgICAgIGxldCByZXQgPSBhcnJheS5zaGlmdCgpO1xuICAgICAgICBpZiAoaGFkTGVuZ3RoKSB7XG4gICAgICAgICAgbm90aWZ5U3BsaWNlKHRoaXMsIGFycmF5LCBpbmZvLnBhdGgsIDAsIDAsIFtyZXRdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEFkZHMgaXRlbXMgb250byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhcnJheSBhdCB0aGUgcGF0aCBzcGVjaWZpZWQuXG4gICAgICAgKlxuICAgICAgICogVGhlIGFyZ3VtZW50cyBhZnRlciBgcGF0aGAgYW5kIHJldHVybiB2YWx1ZSBtYXRjaCB0aGF0IG9mXG4gICAgICAgKiBgQXJyYXkucHJvdG90eXBlLnB1c2hgLlxuICAgICAgICpcbiAgICAgICAqIFRoaXMgbWV0aG9kIG5vdGlmaWVzIG90aGVyIHBhdGhzIHRvIHRoZSBzYW1lIGFycmF5IHRoYXQgYVxuICAgICAgICogc3BsaWNlIG9jY3VycmVkIHRvIHRoZSBhcnJheS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBQYXRoIHRvIGFycmF5LlxuICAgICAgICogQHBhcmFtIHsuLi4qfSBpdGVtcyBJdGVtcyB0byBpbnNlcnQgaW5mbyBhcnJheVxuICAgICAgICogQHJldHVybiB7bnVtYmVyfSBOZXcgbGVuZ3RoIG9mIHRoZSBhcnJheS5cbiAgICAgICAqIEBwdWJsaWNcbiAgICAgICAqL1xuICAgICAgdW5zaGlmdChwYXRoLCAuLi5pdGVtcykge1xuICAgICAgICBsZXQgaW5mbyA9IHtwYXRoOiAnJ307XG4gICAgICAgIGxldCBhcnJheSA9IC8qKiBAdHlwZSB7QXJyYXl9ICovKFBvbHltZXIuUGF0aC5nZXQodGhpcywgcGF0aCwgaW5mbykpO1xuICAgICAgICBsZXQgcmV0ID0gYXJyYXkudW5zaGlmdCguLi5pdGVtcyk7XG4gICAgICAgIGlmIChpdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICBub3RpZnlTcGxpY2UodGhpcywgYXJyYXksIGluZm8ucGF0aCwgMCwgaXRlbXMubGVuZ3RoLCBbXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBOb3RpZnkgdGhhdCBhIHBhdGggaGFzIGNoYW5nZWQuXG4gICAgICAgKlxuICAgICAgICogRXhhbXBsZTpcbiAgICAgICAqXG4gICAgICAgKiAgICAgdGhpcy5pdGVtLnVzZXIubmFtZSA9ICdCb2InO1xuICAgICAgICogICAgIHRoaXMubm90aWZ5UGF0aCgnaXRlbS51c2VyLm5hbWUnKTtcbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBQYXRoIHRoYXQgc2hvdWxkIGJlIG5vdGlmaWVkLlxuICAgICAgICogQHBhcmFtIHsqPX0gdmFsdWUgVmFsdWUgYXQgdGhlIHBhdGggKG9wdGlvbmFsKS5cbiAgICAgICAqIEBwdWJsaWNcbiAgICAgICovXG4gICAgICBub3RpZnlQYXRoKHBhdGgsIHZhbHVlKSB7XG4gICAgICAgIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgICAgICBsZXQgcHJvcFBhdGg7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAvLyBHZXQgdmFsdWUgaWYgbm90IHN1cHBsaWVkXG4gICAgICAgICAgbGV0IGluZm8gPSB7cGF0aDogJyd9O1xuICAgICAgICAgIHZhbHVlID0gUG9seW1lci5QYXRoLmdldCh0aGlzLCBwYXRoLCBpbmZvKTtcbiAgICAgICAgICBwcm9wUGF0aCA9IGluZm8ucGF0aDtcbiAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHBhdGgpKSB7XG4gICAgICAgICAgLy8gTm9ybWFsaXplIHBhdGggaWYgbmVlZGVkXG4gICAgICAgICAgcHJvcFBhdGggPSBQb2x5bWVyLlBhdGgubm9ybWFsaXplKHBhdGgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByb3BQYXRoID0gLyoqIEB0eXBle3N0cmluZ30gKi8ocGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3NldFBlbmRpbmdQcm9wZXJ0eU9yUGF0aChwcm9wUGF0aCwgdmFsdWUsIHRydWUsIHRydWUpKSB7XG4gICAgICAgICAgdGhpcy5faW52YWxpZGF0ZVByb3BlcnRpZXMoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEVxdWl2YWxlbnQgdG8gc3RhdGljIGBjcmVhdGVSZWFkT25seVByb3BlcnR5YCBBUEkgYnV0IGNhbiBiZSBjYWxsZWQgb25cbiAgICAgICAqIGFuIGluc3RhbmNlIHRvIGFkZCBlZmZlY3RzIGF0IHJ1bnRpbWUuICBTZWUgdGhhdCBtZXRob2QgZm9yXG4gICAgICAgKiBmdWxsIEFQSSBkb2NzLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSBuYW1lXG4gICAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBwcm90ZWN0ZWRTZXR0ZXIgQ3JlYXRlcyBhIGN1c3RvbSBwcm90ZWN0ZWQgc2V0dGVyXG4gICAgICAgKiAgIHdoZW4gYHRydWVgLlxuICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICovXG4gICAgICBfY3JlYXRlUmVhZE9ubHlQcm9wZXJ0eShwcm9wZXJ0eSwgcHJvdGVjdGVkU2V0dGVyKSB7XG4gICAgICAgIHRoaXMuX2FkZFByb3BlcnR5RWZmZWN0KHByb3BlcnR5LCBUWVBFUy5SRUFEX09OTFkpO1xuICAgICAgICBpZiAocHJvdGVjdGVkU2V0dGVyKSB7XG4gICAgICAgICAgdGhpc1snX3NldCcgKyB1cHBlcihwcm9wZXJ0eSldID0gLyoqIEB0aGlzIHtQcm9wZXJ0eUVmZmVjdHN9ICovZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX3NldFByb3BlcnR5KHByb3BlcnR5LCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogRXF1aXZhbGVudCB0byBzdGF0aWMgYGNyZWF0ZVByb3BlcnR5T2JzZXJ2ZXJgIEFQSSBidXQgY2FuIGJlIGNhbGxlZCBvblxuICAgICAgICogYW4gaW5zdGFuY2UgdG8gYWRkIGVmZmVjdHMgYXQgcnVudGltZS4gIFNlZSB0aGF0IG1ldGhvZCBmb3JcbiAgICAgICAqIGZ1bGwgQVBJIGRvY3MuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IG5hbWVcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2ROYW1lIE5hbWUgb2Ygb2JzZXJ2ZXIgbWV0aG9kIHRvIGNhbGxcbiAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IGR5bmFtaWNGbiBXaGV0aGVyIHRoZSBtZXRob2QgbmFtZSBzaG91bGQgYmUgaW5jbHVkZWQgYXNcbiAgICAgICAqICAgYSBkZXBlbmRlbmN5IHRvIHRoZSBlZmZlY3QuXG4gICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgKi9cbiAgICAgIF9jcmVhdGVQcm9wZXJ0eU9ic2VydmVyKHByb3BlcnR5LCBtZXRob2ROYW1lLCBkeW5hbWljRm4pIHtcbiAgICAgICAgbGV0IGluZm8gPSB7IHByb3BlcnR5LCBtZXRob2ROYW1lLCBkeW5hbWljRm46IEJvb2xlYW4oZHluYW1pY0ZuKSB9O1xuICAgICAgICB0aGlzLl9hZGRQcm9wZXJ0eUVmZmVjdChwcm9wZXJ0eSwgVFlQRVMuT0JTRVJWRSwge1xuICAgICAgICAgIGZuOiBydW5PYnNlcnZlckVmZmVjdCwgaW5mbywgdHJpZ2dlcjoge25hbWU6IHByb3BlcnR5fVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGR5bmFtaWNGbikge1xuICAgICAgICAgIHRoaXMuX2FkZFByb3BlcnR5RWZmZWN0KG1ldGhvZE5hbWUsIFRZUEVTLk9CU0VSVkUsIHtcbiAgICAgICAgICAgIGZuOiBydW5PYnNlcnZlckVmZmVjdCwgaW5mbywgdHJpZ2dlcjoge25hbWU6IG1ldGhvZE5hbWV9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBFcXVpdmFsZW50IHRvIHN0YXRpYyBgY3JlYXRlTWV0aG9kT2JzZXJ2ZXJgIEFQSSBidXQgY2FuIGJlIGNhbGxlZCBvblxuICAgICAgICogYW4gaW5zdGFuY2UgdG8gYWRkIGVmZmVjdHMgYXQgcnVudGltZS4gIFNlZSB0aGF0IG1ldGhvZCBmb3JcbiAgICAgICAqIGZ1bGwgQVBJIGRvY3MuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGV4cHJlc3Npb24gTWV0aG9kIGV4cHJlc3Npb25cbiAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbnxPYmplY3Q9fSBkeW5hbWljRm4gQm9vbGVhbiBvciBvYmplY3QgbWFwIGluZGljYXRpbmdcbiAgICAgICAqICAgd2hldGhlciBtZXRob2QgbmFtZXMgc2hvdWxkIGJlIGluY2x1ZGVkIGFzIGEgZGVwZW5kZW5jeSB0byB0aGUgZWZmZWN0LlxuICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICovXG4gICAgICBfY3JlYXRlTWV0aG9kT2JzZXJ2ZXIoZXhwcmVzc2lvbiwgZHluYW1pY0ZuKSB7XG4gICAgICAgIGxldCBzaWcgPSBwYXJzZU1ldGhvZChleHByZXNzaW9uKTtcbiAgICAgICAgaWYgKCFzaWcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNYWxmb3JtZWQgb2JzZXJ2ZXIgZXhwcmVzc2lvbiAnXCIgKyBleHByZXNzaW9uICsgXCInXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNyZWF0ZU1ldGhvZEVmZmVjdCh0aGlzLCBzaWcsIFRZUEVTLk9CU0VSVkUsIHJ1bk1ldGhvZEVmZmVjdCwgbnVsbCwgZHluYW1pY0ZuKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBFcXVpdmFsZW50IHRvIHN0YXRpYyBgY3JlYXRlTm90aWZ5aW5nUHJvcGVydHlgIEFQSSBidXQgY2FuIGJlIGNhbGxlZCBvblxuICAgICAgICogYW4gaW5zdGFuY2UgdG8gYWRkIGVmZmVjdHMgYXQgcnVudGltZS4gIFNlZSB0aGF0IG1ldGhvZCBmb3JcbiAgICAgICAqIGZ1bGwgQVBJIGRvY3MuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IG5hbWVcbiAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAqL1xuICAgICAgX2NyZWF0ZU5vdGlmeWluZ1Byb3BlcnR5KHByb3BlcnR5KSB7XG4gICAgICAgIHRoaXMuX2FkZFByb3BlcnR5RWZmZWN0KHByb3BlcnR5LCBUWVBFUy5OT1RJRlksIHtcbiAgICAgICAgICBmbjogcnVuTm90aWZ5RWZmZWN0LFxuICAgICAgICAgIGluZm86IHtcbiAgICAgICAgICAgIGV2ZW50TmFtZTogQ2FzZU1hcC5jYW1lbFRvRGFzaENhc2UocHJvcGVydHkpICsgJy1jaGFuZ2VkJyxcbiAgICAgICAgICAgIHByb3BlcnR5OiBwcm9wZXJ0eVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogRXF1aXZhbGVudCB0byBzdGF0aWMgYGNyZWF0ZVJlZmxlY3RlZFByb3BlcnR5YCBBUEkgYnV0IGNhbiBiZSBjYWxsZWQgb25cbiAgICAgICAqIGFuIGluc3RhbmNlIHRvIGFkZCBlZmZlY3RzIGF0IHJ1bnRpbWUuICBTZWUgdGhhdCBtZXRob2QgZm9yXG4gICAgICAgKiBmdWxsIEFQSSBkb2NzLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSBuYW1lXG4gICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgKi9cbiAgICAgIF9jcmVhdGVSZWZsZWN0ZWRQcm9wZXJ0eShwcm9wZXJ0eSkge1xuICAgICAgICBsZXQgYXR0ciA9IENhc2VNYXAuY2FtZWxUb0Rhc2hDYXNlKHByb3BlcnR5KTtcbiAgICAgICAgaWYgKGF0dHJbMF0gPT09ICctJykge1xuICAgICAgICAgIGNvbnNvbGUud2FybignUHJvcGVydHkgJyArIHByb3BlcnR5ICsgJyBjYW5ub3QgYmUgcmVmbGVjdGVkIHRvIGF0dHJpYnV0ZSAnICtcbiAgICAgICAgICAgIGF0dHIgKyAnIGJlY2F1c2UgXCItXCIgaXMgbm90IGEgdmFsaWQgc3RhcnRpbmcgYXR0cmlidXRlIG5hbWUuIFVzZSBhIGxvd2VyY2FzZSBmaXJzdCBsZXR0ZXIgZm9yIHRoZSBwcm9wZXJ0eSB0aGlzZWFkLicpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX2FkZFByb3BlcnR5RWZmZWN0KHByb3BlcnR5LCBUWVBFUy5SRUZMRUNULCB7XG4gICAgICAgICAgICBmbjogcnVuUmVmbGVjdEVmZmVjdCxcbiAgICAgICAgICAgIGluZm86IHtcbiAgICAgICAgICAgICAgYXR0ck5hbWU6IGF0dHJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEVxdWl2YWxlbnQgdG8gc3RhdGljIGBjcmVhdGVDb21wdXRlZFByb3BlcnR5YCBBUEkgYnV0IGNhbiBiZSBjYWxsZWQgb25cbiAgICAgICAqIGFuIGluc3RhbmNlIHRvIGFkZCBlZmZlY3RzIGF0IHJ1bnRpbWUuICBTZWUgdGhhdCBtZXRob2QgZm9yXG4gICAgICAgKiBmdWxsIEFQSSBkb2NzLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBOYW1lIG9mIGNvbXB1dGVkIHByb3BlcnR5IHRvIHNldFxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGV4cHJlc3Npb24gTWV0aG9kIGV4cHJlc3Npb25cbiAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbnxPYmplY3Q9fSBkeW5hbWljRm4gQm9vbGVhbiBvciBvYmplY3QgbWFwIGluZGljYXRpbmdcbiAgICAgICAqICAgd2hldGhlciBtZXRob2QgbmFtZXMgc2hvdWxkIGJlIGluY2x1ZGVkIGFzIGEgZGVwZW5kZW5jeSB0byB0aGUgZWZmZWN0LlxuICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICovXG4gICAgICBfY3JlYXRlQ29tcHV0ZWRQcm9wZXJ0eShwcm9wZXJ0eSwgZXhwcmVzc2lvbiwgZHluYW1pY0ZuKSB7XG4gICAgICAgIGxldCBzaWcgPSBwYXJzZU1ldGhvZChleHByZXNzaW9uKTtcbiAgICAgICAgaWYgKCFzaWcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNYWxmb3JtZWQgY29tcHV0ZWQgZXhwcmVzc2lvbiAnXCIgKyBleHByZXNzaW9uICsgXCInXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNyZWF0ZU1ldGhvZEVmZmVjdCh0aGlzLCBzaWcsIFRZUEVTLkNPTVBVVEUsIHJ1bkNvbXB1dGVkRWZmZWN0LCBwcm9wZXJ0eSwgZHluYW1pY0ZuKTtcbiAgICAgIH1cblxuICAgICAgLy8gLS0gc3RhdGljIGNsYXNzIG1ldGhvZHMgLS0tLS0tLS0tLS0tXG5cbiAgICAgIC8qKlxuICAgICAgICogRW5zdXJlcyBhbiBhY2Nlc3NvciBleGlzdHMgZm9yIHRoZSBzcGVjaWZpZWQgcHJvcGVydHksIGFuZCBhZGRzXG4gICAgICAgKiB0byBhIGxpc3Qgb2YgXCJwcm9wZXJ0eSBlZmZlY3RzXCIgdGhhdCB3aWxsIHJ1biB3aGVuIHRoZSBhY2Nlc3NvciBmb3JcbiAgICAgICAqIHRoZSBzcGVjaWZpZWQgcHJvcGVydHkgaXMgc2V0LiAgRWZmZWN0cyBhcmUgZ3JvdXBlZCBieSBcInR5cGVcIiwgd2hpY2hcbiAgICAgICAqIHJvdWdobHkgY29ycmVzcG9uZHMgdG8gYSBwaGFzZSBpbiBlZmZlY3QgcHJvY2Vzc2luZy4gIFRoZSBlZmZlY3RcbiAgICAgICAqIG1ldGFkYXRhIHNob3VsZCBiZSBpbiB0aGUgZm9sbG93aW5nIGZvcm06XG4gICAgICAgKlxuICAgICAgICogICB7XG4gICAgICAgKiAgICAgZm46IGVmZmVjdEZ1bmN0aW9uLCAvLyBSZWZlcmVuY2UgdG8gZnVuY3Rpb24gdG8gY2FsbCB0byBwZXJmb3JtIGVmZmVjdFxuICAgICAgICogICAgIGluZm86IHsgLi4uIH0gICAgICAgLy8gRWZmZWN0IG1ldGFkYXRhIHBhc3NlZCB0byBmdW5jdGlvblxuICAgICAgICogICAgIHRyaWdnZXI6IHsgICAgICAgICAgLy8gT3B0aW9uYWwgdHJpZ2dlcmluZyBtZXRhZGF0YTsgaWYgbm90IHByb3ZpZGVkXG4gICAgICAgKiAgICAgICBuYW1lOiBzdHJpbmcgICAgICAvLyB0aGUgcHJvcGVydHkgaXMgdHJlYXRlZCBhcyBhIHdpbGRjYXJkXG4gICAgICAgKiAgICAgICBzdHJ1Y3R1cmVkOiBib29sZWFuXG4gICAgICAgKiAgICAgICB3aWxkY2FyZDogYm9vbGVhblxuICAgICAgICogICAgIH1cbiAgICAgICAqICAgfVxuICAgICAgICpcbiAgICAgICAqIEVmZmVjdHMgYXJlIGNhbGxlZCBmcm9tIGBfcHJvcGVydGllc0NoYW5nZWRgIGluIHRoZSBmb2xsb3dpbmcgb3JkZXIgYnlcbiAgICAgICAqIHR5cGU6XG4gICAgICAgKlxuICAgICAgICogMS4gQ09NUFVURVxuICAgICAgICogMi4gUFJPUEFHQVRFXG4gICAgICAgKiAzLiBSRUZMRUNUXG4gICAgICAgKiA0LiBPQlNFUlZFXG4gICAgICAgKiA1LiBOT1RJRllcbiAgICAgICAqXG4gICAgICAgKiBFZmZlY3QgZnVuY3Rpb25zIGFyZSBjYWxsZWQgd2l0aCB0aGUgZm9sbG93aW5nIHNpZ25hdHVyZTpcbiAgICAgICAqXG4gICAgICAgKiAgIGVmZmVjdEZ1bmN0aW9uKGluc3QsIHBhdGgsIHByb3BzLCBvbGRQcm9wcywgaW5mbywgaGFzUGF0aHMpXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IHRoYXQgc2hvdWxkIHRyaWdnZXIgdGhlIGVmZmVjdFxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgRWZmZWN0IHR5cGUsIGZyb20gdGhpcy5QUk9QRVJUWV9FRkZFQ1RfVFlQRVNcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0PX0gZWZmZWN0IEVmZmVjdCBtZXRhZGF0YSBvYmplY3RcbiAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAqL1xuICAgICAgc3RhdGljIGFkZFByb3BlcnR5RWZmZWN0KHByb3BlcnR5LCB0eXBlLCBlZmZlY3QpIHtcbiAgICAgICAgdGhpcy5wcm90b3R5cGUuX2FkZFByb3BlcnR5RWZmZWN0KHByb3BlcnR5LCB0eXBlLCBlZmZlY3QpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENyZWF0ZXMgYSBzaW5nbGUtcHJvcGVydHkgb2JzZXJ2ZXIgZm9yIHRoZSBnaXZlbiBwcm9wZXJ0eS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgbmFtZVxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZE5hbWUgTmFtZSBvZiBvYnNlcnZlciBtZXRob2QgdG8gY2FsbFxuICAgICAgICogQHBhcmFtIHtib29sZWFuPX0gZHluYW1pY0ZuIFdoZXRoZXIgdGhlIG1ldGhvZCBuYW1lIHNob3VsZCBiZSBpbmNsdWRlZCBhc1xuICAgICAgICogICBhIGRlcGVuZGVuY3kgdG8gdGhlIGVmZmVjdC5cbiAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAqL1xuICAgICAgc3RhdGljIGNyZWF0ZVByb3BlcnR5T2JzZXJ2ZXIocHJvcGVydHksIG1ldGhvZE5hbWUsIGR5bmFtaWNGbikge1xuICAgICAgICB0aGlzLnByb3RvdHlwZS5fY3JlYXRlUHJvcGVydHlPYnNlcnZlcihwcm9wZXJ0eSwgbWV0aG9kTmFtZSwgZHluYW1pY0ZuKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDcmVhdGVzIGEgbXVsdGktcHJvcGVydHkgXCJtZXRob2Qgb2JzZXJ2ZXJcIiBiYXNlZCBvbiB0aGUgcHJvdmlkZWRcbiAgICAgICAqIGV4cHJlc3Npb24sIHdoaWNoIHNob3VsZCBiZSBhIHN0cmluZyBpbiB0aGUgZm9ybSBvZiBhIG5vcm1hbCBKYXZhc2NyaXB0XG4gICAgICAgKiBmdW5jdGlvbiBzaWduYXR1cmU6IGAnbWV0aG9kTmFtZShhcmcxLCBbLi4uLCBhcmduXSknYC4gIEVhY2ggYXJndW1lbnRcbiAgICAgICAqIHNob3VsZCBjb3JyZXNwb25kIHRvIGEgcHJvcGVydHkgb3IgcGF0aCBpbiB0aGUgY29udGV4dCBvZiB0aGlzXG4gICAgICAgKiBwcm90b3R5cGUgKG9yIGluc3RhbmNlKSwgb3IgbWF5IGJlIGEgbGl0ZXJhbCBzdHJpbmcgb3IgbnVtYmVyLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBleHByZXNzaW9uIE1ldGhvZCBleHByZXNzaW9uXG4gICAgICAgKiBAcGFyYW0ge2Jvb2xlYW58T2JqZWN0PX0gZHluYW1pY0ZuIEJvb2xlYW4gb3Igb2JqZWN0IG1hcCBpbmRpY2F0aW5nXG4gICAgICAgKiAgIHdoZXRoZXIgbWV0aG9kIG5hbWVzIHNob3VsZCBiZSBpbmNsdWRlZCBhcyBhIGRlcGVuZGVuY3kgdG8gdGhlIGVmZmVjdC5cbiAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAqL1xuICAgICAgc3RhdGljIGNyZWF0ZU1ldGhvZE9ic2VydmVyKGV4cHJlc3Npb24sIGR5bmFtaWNGbikge1xuICAgICAgICB0aGlzLnByb3RvdHlwZS5fY3JlYXRlTWV0aG9kT2JzZXJ2ZXIoZXhwcmVzc2lvbiwgZHluYW1pY0ZuKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDYXVzZXMgdGhlIHNldHRlciBmb3IgdGhlIGdpdmVuIHByb3BlcnR5IHRvIGRpc3BhdGNoIGA8cHJvcGVydHk+LWNoYW5nZWRgXG4gICAgICAgKiBldmVudHMgdG8gbm90aWZ5IG9mIGNoYW5nZXMgdG8gdGhlIHByb3BlcnR5LlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSBuYW1lXG4gICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgKi9cbiAgICAgIHN0YXRpYyBjcmVhdGVOb3RpZnlpbmdQcm9wZXJ0eShwcm9wZXJ0eSkge1xuICAgICAgICB0aGlzLnByb3RvdHlwZS5fY3JlYXRlTm90aWZ5aW5nUHJvcGVydHkocHJvcGVydHkpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENyZWF0ZXMgYSByZWFkLW9ubHkgYWNjZXNzb3IgZm9yIHRoZSBnaXZlbiBwcm9wZXJ0eS5cbiAgICAgICAqXG4gICAgICAgKiBUbyBzZXQgdGhlIHByb3BlcnR5LCB1c2UgdGhlIHByb3RlY3RlZCBgX3NldFByb3BlcnR5YCBBUEkuXG4gICAgICAgKiBUbyBjcmVhdGUgYSBjdXN0b20gcHJvdGVjdGVkIHNldHRlciAoZS5nLiBgX3NldE15UHJvcCgpYCBmb3JcbiAgICAgICAqIHByb3BlcnR5IGBteVByb3BgKSwgcGFzcyBgdHJ1ZWAgZm9yIGBwcm90ZWN0ZWRTZXR0ZXJgLlxuICAgICAgICpcbiAgICAgICAqIE5vdGUsIGlmIHRoZSBwcm9wZXJ0eSB3aWxsIGhhdmUgb3RoZXIgcHJvcGVydHkgZWZmZWN0cywgdGhpcyBtZXRob2RcbiAgICAgICAqIHNob3VsZCBiZSBjYWxsZWQgZmlyc3QsIGJlZm9yZSBhZGRpbmcgb3RoZXIgZWZmZWN0cy5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgbmFtZVxuICAgICAgICogQHBhcmFtIHtib29sZWFuPX0gcHJvdGVjdGVkU2V0dGVyIENyZWF0ZXMgYSBjdXN0b20gcHJvdGVjdGVkIHNldHRlclxuICAgICAgICogICB3aGVuIGB0cnVlYC5cbiAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAqL1xuICAgICAgc3RhdGljIGNyZWF0ZVJlYWRPbmx5UHJvcGVydHkocHJvcGVydHksIHByb3RlY3RlZFNldHRlcikge1xuICAgICAgICB0aGlzLnByb3RvdHlwZS5fY3JlYXRlUmVhZE9ubHlQcm9wZXJ0eShwcm9wZXJ0eSwgcHJvdGVjdGVkU2V0dGVyKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDYXVzZXMgdGhlIHNldHRlciBmb3IgdGhlIGdpdmVuIHByb3BlcnR5IHRvIHJlZmxlY3QgdGhlIHByb3BlcnR5IHZhbHVlXG4gICAgICAgKiB0byBhIChkYXNoLWNhc2VkKSBhdHRyaWJ1dGUgb2YgdGhlIHNhbWUgbmFtZS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgbmFtZVxuICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICovXG4gICAgICBzdGF0aWMgY3JlYXRlUmVmbGVjdGVkUHJvcGVydHkocHJvcGVydHkpIHtcbiAgICAgICAgdGhpcy5wcm90b3R5cGUuX2NyZWF0ZVJlZmxlY3RlZFByb3BlcnR5KHByb3BlcnR5KTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDcmVhdGVzIGEgY29tcHV0ZWQgcHJvcGVydHkgd2hvc2UgdmFsdWUgaXMgc2V0IHRvIHRoZSByZXN1bHQgb2YgdGhlXG4gICAgICAgKiBtZXRob2QgZGVzY3JpYmVkIGJ5IHRoZSBnaXZlbiBgZXhwcmVzc2lvbmAgZWFjaCB0aW1lIG9uZSBvciBtb3JlXG4gICAgICAgKiBhcmd1bWVudHMgdG8gdGhlIG1ldGhvZCBjaGFuZ2VzLiAgVGhlIGV4cHJlc3Npb24gc2hvdWxkIGJlIGEgc3RyaW5nXG4gICAgICAgKiBpbiB0aGUgZm9ybSBvZiBhIG5vcm1hbCBKYXZhc2NyaXB0IGZ1bmN0aW9uIHNpZ25hdHVyZTpcbiAgICAgICAqIGAnbWV0aG9kTmFtZShhcmcxLCBbLi4uLCBhcmduXSknYFxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBOYW1lIG9mIGNvbXB1dGVkIHByb3BlcnR5IHRvIHNldFxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGV4cHJlc3Npb24gTWV0aG9kIGV4cHJlc3Npb25cbiAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbnxPYmplY3Q9fSBkeW5hbWljRm4gQm9vbGVhbiBvciBvYmplY3QgbWFwIGluZGljYXRpbmcgd2hldGhlclxuICAgICAgICogICBtZXRob2QgbmFtZXMgc2hvdWxkIGJlIGluY2x1ZGVkIGFzIGEgZGVwZW5kZW5jeSB0byB0aGUgZWZmZWN0LlxuICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICovXG4gICAgICBzdGF0aWMgY3JlYXRlQ29tcHV0ZWRQcm9wZXJ0eShwcm9wZXJ0eSwgZXhwcmVzc2lvbiwgZHluYW1pY0ZuKSB7XG4gICAgICAgIHRoaXMucHJvdG90eXBlLl9jcmVhdGVDb21wdXRlZFByb3BlcnR5KHByb3BlcnR5LCBleHByZXNzaW9uLCBkeW5hbWljRm4pO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFBhcnNlcyB0aGUgcHJvdmlkZWQgdGVtcGxhdGUgdG8gZW5zdXJlIGJpbmRpbmcgZWZmZWN0cyBhcmUgY3JlYXRlZFxuICAgICAgICogZm9yIHRoZW0sIGFuZCB0aGVuIGVuc3VyZXMgcHJvcGVydHkgYWNjZXNzb3JzIGFyZSBjcmVhdGVkIGZvciBhbnlcbiAgICAgICAqIGRlcGVuZGVudCBwcm9wZXJ0aWVzIGluIHRoZSB0ZW1wbGF0ZS4gIEJpbmRpbmcgZWZmZWN0cyBmb3IgYm91bmRcbiAgICAgICAqIHRlbXBsYXRlcyBhcmUgc3RvcmVkIGluIGEgbGlua2VkIGxpc3Qgb24gdGhlIGluc3RhbmNlIHNvIHRoYXRcbiAgICAgICAqIHRlbXBsYXRlcyBjYW4gYmUgZWZmaWNpZW50bHkgc3RhbXBlZCBhbmQgdW5zdGFtcGVkLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7SFRNTFRlbXBsYXRlRWxlbWVudH0gdGVtcGxhdGUgVGVtcGxhdGUgY29udGFpbmluZyBiaW5kaW5nXG4gICAgICAgKiAgIGJpbmRpbmdzXG4gICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRlbXBsYXRlIG1ldGFkYXRhIG9iamVjdFxuICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICovXG4gICAgICBzdGF0aWMgYmluZFRlbXBsYXRlKHRlbXBsYXRlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3RvdHlwZS5fYmluZFRlbXBsYXRlKHRlbXBsYXRlKTtcbiAgICAgIH1cblxuICAgICAgLy8gLS0gYmluZGluZyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgIC8qKlxuICAgICAgICogRXF1aXZhbGVudCB0byBzdGF0aWMgYGJpbmRUZW1wbGF0ZWAgQVBJIGJ1dCBjYW4gYmUgY2FsbGVkIG9uXG4gICAgICAgKiBhbiBpbnN0YW5jZSB0byBhZGQgZWZmZWN0cyBhdCBydW50aW1lLiAgU2VlIHRoYXQgbWV0aG9kIGZvclxuICAgICAgICogZnVsbCBBUEkgZG9jcy5cbiAgICAgICAqXG4gICAgICAgKiBUaGlzIG1ldGhvZCBtYXkgYmUgY2FsbGVkIG9uIHRoZSBwcm90b3R5cGUgKGZvciBwcm90b3R5cGljYWwgdGVtcGxhdGVcbiAgICAgICAqIGJpbmRpbmcsIHRvIGF2b2lkIGNyZWF0aW5nIGFjY2Vzc29ycyBldmVyeSBpbnN0YW5jZSkgb25jZSBwZXIgcHJvdG90eXBlLFxuICAgICAgICogYW5kIHdpbGwgYmUgY2FsbGVkIHdpdGggYHJ1bnRpbWVCaW5kaW5nOiB0cnVlYCBieSBgX3N0YW1wVGVtcGxhdGVgIHRvXG4gICAgICAgKiBjcmVhdGUgYW5kIGxpbmsgYW4gaW5zdGFuY2Ugb2YgdGhlIHRlbXBsYXRlIG1ldGFkYXRhIGFzc29jaWF0ZWQgd2l0aCBhXG4gICAgICAgKiBwYXJ0aWN1bGFyIHN0YW1waW5nLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7SFRNTFRlbXBsYXRlRWxlbWVudH0gdGVtcGxhdGUgVGVtcGxhdGUgY29udGFpbmluZyBiaW5kaW5nXG4gICAgICAgKiAgIGJpbmRpbmdzXG4gICAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBpbnN0YW5jZUJpbmRpbmcgV2hlbiBmYWxzZSAoZGVmYXVsdCksIHBlcmZvcm1zXG4gICAgICAgKiAgIFwicHJvdG90eXBpY2FsXCIgYmluZGluZyBvZiB0aGUgdGVtcGxhdGUgYW5kIG92ZXJ3cml0ZXMgYW55IHByZXZpb3VzbHlcbiAgICAgICAqICAgYm91bmQgdGVtcGxhdGUgZm9yIHRoZSBjbGFzcy4gV2hlbiB0cnVlIChhcyBwYXNzZWQgZnJvbVxuICAgICAgICogICBgX3N0YW1wVGVtcGxhdGVgKSwgdGhlIHRlbXBsYXRlIGluZm8gaXMgaW5zdGFuY2VkIGFuZCBsaW5rZWQgaW50b1xuICAgICAgICogICB0aGUgbGlzdCBvZiBib3VuZCB0ZW1wbGF0ZXMuXG4gICAgICAgKiBAcmV0dXJuIHshVGVtcGxhdGVJbmZvfSBUZW1wbGF0ZSBtZXRhZGF0YSBvYmplY3Q7IGZvciBgcnVudGltZUJpbmRpbmdgLFxuICAgICAgICogICB0aGlzIGlzIGFuIGluc3RhbmNlIG9mIHRoZSBwcm90b3R5cGljYWwgdGVtcGxhdGUgaW5mb1xuICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICovXG4gICAgICBfYmluZFRlbXBsYXRlKHRlbXBsYXRlLCBpbnN0YW5jZUJpbmRpbmcpIHtcbiAgICAgICAgbGV0IHRlbXBsYXRlSW5mbyA9IHRoaXMuY29uc3RydWN0b3IuX3BhcnNlVGVtcGxhdGUodGVtcGxhdGUpO1xuICAgICAgICBsZXQgd2FzUHJlQm91bmQgPSB0aGlzLl9fdGVtcGxhdGVJbmZvID09IHRlbXBsYXRlSW5mbztcbiAgICAgICAgLy8gT3B0aW1pemF0aW9uOiBzaW5jZSB0aGlzIGlzIGNhbGxlZCB0d2ljZSBmb3IgcHJvdG8tYm91bmQgdGVtcGxhdGVzLFxuICAgICAgICAvLyBkb24ndCBhdHRlbXB0IHRvIHJlY3JlYXRlIGFjY2Vzc29ycyBpZiB0aGlzIHRlbXBsYXRlIHdhcyBwcmUtYm91bmRcbiAgICAgICAgaWYgKCF3YXNQcmVCb3VuZCkge1xuICAgICAgICAgIGZvciAobGV0IHByb3AgaW4gdGVtcGxhdGVJbmZvLnByb3BlcnR5RWZmZWN0cykge1xuICAgICAgICAgICAgdGhpcy5fY3JlYXRlUHJvcGVydHlBY2Nlc3Nvcihwcm9wKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluc3RhbmNlQmluZGluZykge1xuICAgICAgICAgIC8vIEZvciBpbnN0YW5jZS10aW1lIGJpbmRpbmcsIGNyZWF0ZSBpbnN0YW5jZSBvZiB0ZW1wbGF0ZSBtZXRhZGF0YVxuICAgICAgICAgIC8vIGFuZCBsaW5rIGludG8gbGlzdCBvZiB0ZW1wbGF0ZXMgaWYgbmVjZXNzYXJ5XG4gICAgICAgICAgdGVtcGxhdGVJbmZvID0gLyoqIEB0eXBlIHshVGVtcGxhdGVJbmZvfSAqLyhPYmplY3QuY3JlYXRlKHRlbXBsYXRlSW5mbykpO1xuICAgICAgICAgIHRlbXBsYXRlSW5mby53YXNQcmVCb3VuZCA9IHdhc1ByZUJvdW5kO1xuICAgICAgICAgIGlmICghd2FzUHJlQm91bmQgJiYgdGhpcy5fX3RlbXBsYXRlSW5mbykge1xuICAgICAgICAgICAgbGV0IGxhc3QgPSB0aGlzLl9fdGVtcGxhdGVJbmZvTGFzdCB8fCB0aGlzLl9fdGVtcGxhdGVJbmZvO1xuICAgICAgICAgICAgdGhpcy5fX3RlbXBsYXRlSW5mb0xhc3QgPSBsYXN0Lm5leHRUZW1wbGF0ZUluZm8gPSB0ZW1wbGF0ZUluZm87XG4gICAgICAgICAgICB0ZW1wbGF0ZUluZm8ucHJldmlvdXNUZW1wbGF0ZUluZm8gPSBsYXN0O1xuICAgICAgICAgICAgcmV0dXJuIHRlbXBsYXRlSW5mbztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX190ZW1wbGF0ZUluZm8gPSB0ZW1wbGF0ZUluZm87XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQWRkcyBhIHByb3BlcnR5IGVmZmVjdCB0byB0aGUgZ2l2ZW4gdGVtcGxhdGUgbWV0YWRhdGEsIHdoaWNoIGlzIHJ1blxuICAgICAgICogYXQgdGhlIFwicHJvcGFnYXRlXCIgc3RhZ2Ugb2YgYF9wcm9wZXJ0aWVzQ2hhbmdlZGAgd2hlbiB0aGUgdGVtcGxhdGVcbiAgICAgICAqIGhhcyBiZWVuIGJvdW5kIHRvIHRoZSBlbGVtZW50IHZpYSBgX2JpbmRUZW1wbGF0ZWAuXG4gICAgICAgKlxuICAgICAgICogVGhlIGBlZmZlY3RgIG9iamVjdCBzaG91bGQgbWF0Y2ggdGhlIGZvcm1hdCBpbiBgX2FkZFByb3BlcnR5RWZmZWN0YC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gdGVtcGxhdGVJbmZvIFRlbXBsYXRlIG1ldGFkYXRhIHRvIGFkZCBlZmZlY3QgdG9cbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wIFByb3BlcnR5IHRoYXQgc2hvdWxkIHRyaWdnZXIgdGhlIGVmZmVjdFxuICAgICAgICogQHBhcmFtIHtPYmplY3Q9fSBlZmZlY3QgRWZmZWN0IG1ldGFkYXRhIG9iamVjdFxuICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICovXG4gICAgICBzdGF0aWMgX2FkZFRlbXBsYXRlUHJvcGVydHlFZmZlY3QodGVtcGxhdGVJbmZvLCBwcm9wLCBlZmZlY3QpIHtcbiAgICAgICAgbGV0IGhvc3RQcm9wcyA9IHRlbXBsYXRlSW5mby5ob3N0UHJvcHMgPSB0ZW1wbGF0ZUluZm8uaG9zdFByb3BzIHx8IHt9O1xuICAgICAgICBob3N0UHJvcHNbcHJvcF0gPSB0cnVlO1xuICAgICAgICBsZXQgZWZmZWN0cyA9IHRlbXBsYXRlSW5mby5wcm9wZXJ0eUVmZmVjdHMgPSB0ZW1wbGF0ZUluZm8ucHJvcGVydHlFZmZlY3RzIHx8IHt9O1xuICAgICAgICBsZXQgcHJvcEVmZmVjdHMgPSBlZmZlY3RzW3Byb3BdID0gZWZmZWN0c1twcm9wXSB8fCBbXTtcbiAgICAgICAgcHJvcEVmZmVjdHMucHVzaChlZmZlY3QpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFN0YW1wcyB0aGUgcHJvdmlkZWQgdGVtcGxhdGUgYW5kIHBlcmZvcm1zIGluc3RhbmNlLXRpbWUgc2V0dXAgZm9yXG4gICAgICAgKiBQb2x5bWVyIHRlbXBsYXRlIGZlYXR1cmVzLCBpbmNsdWRpbmcgZGF0YSBiaW5kaW5ncywgZGVjbGFyYXRpdmUgZXZlbnRcbiAgICAgICAqIGxpc3RlbmVycywgYW5kIHRoZSBgdGhpcy4kYCBtYXAgb2YgYGlkYCdzIHRvIG5vZGVzLiAgQSBkb2N1bWVudCBmcmFnbWVudFxuICAgICAgICogaXMgcmV0dXJuZWQgY29udGFpbmluZyB0aGUgc3RhbXBlZCBET00sIHJlYWR5IGZvciBpbnNlcnRpb24gaW50byB0aGVcbiAgICAgICAqIERPTS5cbiAgICAgICAqXG4gICAgICAgKiBUaGlzIG1ldGhvZCBtYXkgYmUgY2FsbGVkIG1vcmUgdGhhbiBvbmNlOyBob3dldmVyIG5vdGUgdGhhdCBkdWUgdG9cbiAgICAgICAqIGBzaGFkeWNzc2AgcG9seWZpbGwgbGltaXRhdGlvbnMsIG9ubHkgc3R5bGVzIGZyb20gdGVtcGxhdGVzIHByZXBhcmVkXG4gICAgICAgKiB1c2luZyBgU2hhZHlDU1MucHJlcGFyZVRlbXBsYXRlYCB3aWxsIGJlIGNvcnJlY3RseSBwb2x5ZmlsbGVkIChzY29wZWRcbiAgICAgICAqIHRvIHRoZSBzaGFkb3cgcm9vdCBhbmQgc3VwcG9ydCBDU1MgY3VzdG9tIHByb3BlcnRpZXMpLCBhbmQgbm90ZSB0aGF0XG4gICAgICAgKiBgU2hhZHlDU1MucHJlcGFyZVRlbXBsYXRlYCBtYXkgb25seSBiZSBjYWxsZWQgb25jZSBwZXIgZWxlbWVudC4gQXMgc3VjaCxcbiAgICAgICAqIGFueSBzdHlsZXMgcmVxdWlyZWQgYnkgaW4gcnVudGltZS1zdGFtcGVkIHRlbXBsYXRlcyBtdXN0IGJlIGluY2x1ZGVkXG4gICAgICAgKiBpbiB0aGUgbWFpbiBlbGVtZW50IHRlbXBsYXRlLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7IUhUTUxUZW1wbGF0ZUVsZW1lbnR9IHRlbXBsYXRlIFRlbXBsYXRlIHRvIHN0YW1wXG4gICAgICAgKiBAcmV0dXJuIHshU3RhbXBlZFRlbXBsYXRlfSBDbG9uZWQgdGVtcGxhdGUgY29udGVudFxuICAgICAgICogQG92ZXJyaWRlXG4gICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgKi9cbiAgICAgIF9zdGFtcFRlbXBsYXRlKHRlbXBsYXRlKSB7XG4gICAgICAgIC8vIEVuc3VyZXMgdGhhdCBjcmVhdGVkIGRvbSBpcyBgX2VucXVldWVDbGllbnRgJ2QgdG8gdGhpcyBlbGVtZW50IHNvXG4gICAgICAgIC8vIHRoYXQgaXQgY2FuIGJlIGZsdXNoZWQgb24gbmV4dCBjYWxsIHRvIGBfZmx1c2hQcm9wZXJ0aWVzYFxuICAgICAgICBob3N0U3RhY2suYmVnaW5Ib3N0aW5nKHRoaXMpO1xuICAgICAgICBsZXQgZG9tID0gc3VwZXIuX3N0YW1wVGVtcGxhdGUodGVtcGxhdGUpO1xuICAgICAgICBob3N0U3RhY2suZW5kSG9zdGluZyh0aGlzKTtcbiAgICAgICAgbGV0IHRlbXBsYXRlSW5mbyA9IC8qKiBAdHlwZSB7IVRlbXBsYXRlSW5mb30gKi8odGhpcy5fYmluZFRlbXBsYXRlKHRlbXBsYXRlLCB0cnVlKSk7XG4gICAgICAgIC8vIEFkZCB0ZW1wbGF0ZS1pbnN0YW5jZS1zcGVjaWZpYyBkYXRhIHRvIGluc3RhbmNlZCB0ZW1wbGF0ZUluZm9cbiAgICAgICAgdGVtcGxhdGVJbmZvLm5vZGVMaXN0ID0gZG9tLm5vZGVMaXN0O1xuICAgICAgICAvLyBDYXB0dXJlIGNoaWxkIG5vZGVzIHRvIGFsbG93IHVuc3RhbXBpbmcgb2Ygbm9uLXByb3RvdHlwaWNhbCB0ZW1wbGF0ZXNcbiAgICAgICAgaWYgKCF0ZW1wbGF0ZUluZm8ud2FzUHJlQm91bmQpIHtcbiAgICAgICAgICBsZXQgbm9kZXMgPSB0ZW1wbGF0ZUluZm8uY2hpbGROb2RlcyA9IFtdO1xuICAgICAgICAgIGZvciAobGV0IG49ZG9tLmZpcnN0Q2hpbGQ7IG47IG49bi5uZXh0U2libGluZykge1xuICAgICAgICAgICAgbm9kZXMucHVzaChuKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZG9tLnRlbXBsYXRlSW5mbyA9IHRlbXBsYXRlSW5mbztcbiAgICAgICAgLy8gU2V0dXAgY29tcG91bmQgc3RvcmFnZSwgMi13YXkgbGlzdGVuZXJzLCBhbmQgZGF0YUhvc3QgZm9yIGJpbmRpbmdzXG4gICAgICAgIHNldHVwQmluZGluZ3ModGhpcywgdGVtcGxhdGVJbmZvKTtcbiAgICAgICAgLy8gRmx1c2ggcHJvcGVydGllcyBpbnRvIHRlbXBsYXRlIG5vZGVzIGlmIGFscmVhZHkgYm9vdGVkXG4gICAgICAgIGlmICh0aGlzLl9fZGF0YVJlYWR5KSB7XG4gICAgICAgICAgcnVuRWZmZWN0cyh0aGlzLCB0ZW1wbGF0ZUluZm8ucHJvcGVydHlFZmZlY3RzLCB0aGlzLl9fZGF0YSwgbnVsbCxcbiAgICAgICAgICAgIGZhbHNlLCB0ZW1wbGF0ZUluZm8ubm9kZUxpc3QpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkb207XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUmVtb3ZlcyBhbmQgdW5iaW5kcyB0aGUgbm9kZXMgcHJldmlvdXNseSBjb250YWluZWQgaW4gdGhlIHByb3ZpZGVkXG4gICAgICAgKiBEb2N1bWVudEZyYWdtZW50IHJldHVybmVkIGZyb20gYF9zdGFtcFRlbXBsYXRlYC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0geyFTdGFtcGVkVGVtcGxhdGV9IGRvbSBEb2N1bWVudEZyYWdtZW50IHByZXZpb3VzbHkgcmV0dXJuZWRcbiAgICAgICAqICAgZnJvbSBgX3N0YW1wVGVtcGxhdGVgIGFzc29jaWF0ZWQgd2l0aCB0aGUgbm9kZXMgdG8gYmUgcmVtb3ZlZFxuICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICovXG4gICAgICBfcmVtb3ZlQm91bmREb20oZG9tKSB7XG4gICAgICAgIC8vIFVubGluayB0ZW1wbGF0ZSBpbmZvXG4gICAgICAgIGxldCB0ZW1wbGF0ZUluZm8gPSBkb20udGVtcGxhdGVJbmZvO1xuICAgICAgICBpZiAodGVtcGxhdGVJbmZvLnByZXZpb3VzVGVtcGxhdGVJbmZvKSB7XG4gICAgICAgICAgdGVtcGxhdGVJbmZvLnByZXZpb3VzVGVtcGxhdGVJbmZvLm5leHRUZW1wbGF0ZUluZm8gPVxuICAgICAgICAgICAgdGVtcGxhdGVJbmZvLm5leHRUZW1wbGF0ZUluZm87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRlbXBsYXRlSW5mby5uZXh0VGVtcGxhdGVJbmZvKSB7XG4gICAgICAgICAgdGVtcGxhdGVJbmZvLm5leHRUZW1wbGF0ZUluZm8ucHJldmlvdXNUZW1wbGF0ZUluZm8gPVxuICAgICAgICAgICAgdGVtcGxhdGVJbmZvLnByZXZpb3VzVGVtcGxhdGVJbmZvO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9fdGVtcGxhdGVJbmZvTGFzdCA9PSB0ZW1wbGF0ZUluZm8pIHtcbiAgICAgICAgICB0aGlzLl9fdGVtcGxhdGVJbmZvTGFzdCA9IHRlbXBsYXRlSW5mby5wcmV2aW91c1RlbXBsYXRlSW5mbztcbiAgICAgICAgfVxuICAgICAgICB0ZW1wbGF0ZUluZm8ucHJldmlvdXNUZW1wbGF0ZUluZm8gPSB0ZW1wbGF0ZUluZm8ubmV4dFRlbXBsYXRlSW5mbyA9IG51bGw7XG4gICAgICAgIC8vIFJlbW92ZSBzdGFtcGVkIG5vZGVzXG4gICAgICAgIGxldCBub2RlcyA9IHRlbXBsYXRlSW5mby5jaGlsZE5vZGVzO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8bm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBsZXQgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICAgIG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIE92ZXJyaWRlcyBkZWZhdWx0IGBUZW1wbGF0ZVN0YW1wYCBpbXBsZW1lbnRhdGlvbiB0byBhZGQgc3VwcG9ydCBmb3JcbiAgICAgICAqIHBhcnNpbmcgYmluZGluZ3MgZnJvbSBgVGV4dE5vZGVgJ3MnIGB0ZXh0Q29udGVudGAuICBBIGBiaW5kaW5nc2BcbiAgICAgICAqIGFycmF5IGlzIGFkZGVkIHRvIGBub2RlSW5mb2AgYW5kIHBvcHVsYXRlZCB3aXRoIGJpbmRpbmcgbWV0YWRhdGFcbiAgICAgICAqIHdpdGggaW5mb3JtYXRpb24gY2FwdHVyaW5nIHRoZSBiaW5kaW5nIHRhcmdldCwgYW5kIGEgYHBhcnRzYCBhcnJheVxuICAgICAgICogd2l0aCBvbmUgb3IgbW9yZSBtZXRhZGF0YSBvYmplY3RzIGNhcHR1cmluZyB0aGUgc291cmNlKHMpIG9mIHRoZVxuICAgICAgICogYmluZGluZy5cbiAgICAgICAqXG4gICAgICAgKiBAb3ZlcnJpZGVcbiAgICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBOb2RlIHRvIHBhcnNlXG4gICAgICAgKiBAcGFyYW0ge1RlbXBsYXRlSW5mb30gdGVtcGxhdGVJbmZvIFRlbXBsYXRlIG1ldGFkYXRhIGZvciBjdXJyZW50IHRlbXBsYXRlXG4gICAgICAgKiBAcGFyYW0ge05vZGVJbmZvfSBub2RlSW5mbyBOb2RlIG1ldGFkYXRhIGZvciBjdXJyZW50IHRlbXBsYXRlIG5vZGVcbiAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgdmlzaXRlZCBub2RlIGFkZGVkIG5vZGUtc3BlY2lmaWNcbiAgICAgICAqICAgbWV0YWRhdGEgdG8gYG5vZGVJbmZvYFxuICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICogQHN1cHByZXNzIHttaXNzaW5nUHJvcGVydGllc30gSW50ZXJmYWNlcyBpbiBjbG9zdXJlIGRvIG5vdCBpbmhlcml0IHN0YXRpY3MsIGJ1dCBjbGFzc2VzIGRvXG4gICAgICAgKi9cbiAgICAgIHN0YXRpYyBfcGFyc2VUZW1wbGF0ZU5vZGUobm9kZSwgdGVtcGxhdGVJbmZvLCBub2RlSW5mbykge1xuICAgICAgICBsZXQgbm90ZWQgPSBzdXBlci5fcGFyc2VUZW1wbGF0ZU5vZGUobm9kZSwgdGVtcGxhdGVJbmZvLCBub2RlSW5mbyk7XG4gICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSkge1xuICAgICAgICAgIGxldCBwYXJ0cyA9IHRoaXMuX3BhcnNlQmluZGluZ3Mobm9kZS50ZXh0Q29udGVudCwgdGVtcGxhdGVJbmZvKTtcbiAgICAgICAgICBpZiAocGFydHMpIHtcbiAgICAgICAgICAgIC8vIEluaXRpYWxpemUgdGhlIHRleHRDb250ZW50IHdpdGggYW55IGxpdGVyYWwgcGFydHNcbiAgICAgICAgICAgIC8vIE5PVEU6IGRlZmF1bHQgdG8gYSBzcGFjZSBoZXJlIHNvIHRoZSB0ZXh0Tm9kZSByZW1haW5zOyBzb21lIGJyb3dzZXJzXG4gICAgICAgICAgICAvLyAoSUUpIGV2YWNpcGF0ZSBhbiBlbXB0eSB0ZXh0Tm9kZSBmb2xsb3dpbmcgY2xvbmVOb2RlL2ltcG9ydE5vZGUuXG4gICAgICAgICAgICBub2RlLnRleHRDb250ZW50ID0gbGl0ZXJhbEZyb21QYXJ0cyhwYXJ0cykgfHwgJyAnO1xuICAgICAgICAgICAgYWRkQmluZGluZyh0aGlzLCB0ZW1wbGF0ZUluZm8sIG5vZGVJbmZvLCAndGV4dCcsICd0ZXh0Q29udGVudCcsIHBhcnRzKTtcbiAgICAgICAgICAgIG5vdGVkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vdGVkO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIE92ZXJyaWRlcyBkZWZhdWx0IGBUZW1wbGF0ZVN0YW1wYCBpbXBsZW1lbnRhdGlvbiB0byBhZGQgc3VwcG9ydCBmb3JcbiAgICAgICAqIHBhcnNpbmcgYmluZGluZ3MgZnJvbSBhdHRyaWJ1dGVzLiAgQSBgYmluZGluZ3NgXG4gICAgICAgKiBhcnJheSBpcyBhZGRlZCB0byBgbm9kZUluZm9gIGFuZCBwb3B1bGF0ZWQgd2l0aCBiaW5kaW5nIG1ldGFkYXRhXG4gICAgICAgKiB3aXRoIGluZm9ybWF0aW9uIGNhcHR1cmluZyB0aGUgYmluZGluZyB0YXJnZXQsIGFuZCBhIGBwYXJ0c2AgYXJyYXlcbiAgICAgICAqIHdpdGggb25lIG9yIG1vcmUgbWV0YWRhdGEgb2JqZWN0cyBjYXB0dXJpbmcgdGhlIHNvdXJjZShzKSBvZiB0aGVcbiAgICAgICAqIGJpbmRpbmcuXG4gICAgICAgKlxuICAgICAgICogQG92ZXJyaWRlXG4gICAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgTm9kZSB0byBwYXJzZVxuICAgICAgICogQHBhcmFtIHtUZW1wbGF0ZUluZm99IHRlbXBsYXRlSW5mbyBUZW1wbGF0ZSBtZXRhZGF0YSBmb3IgY3VycmVudCB0ZW1wbGF0ZVxuICAgICAgICogQHBhcmFtIHtOb2RlSW5mb30gbm9kZUluZm8gTm9kZSBtZXRhZGF0YSBmb3IgY3VycmVudCB0ZW1wbGF0ZSBub2RlXG4gICAgICAgKiBAcmV0dXJuIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIHZpc2l0ZWQgbm9kZSBhZGRlZCBub2RlLXNwZWNpZmljXG4gICAgICAgKiAgIG1ldGFkYXRhIHRvIGBub2RlSW5mb2BcbiAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAqIEBzdXBwcmVzcyB7bWlzc2luZ1Byb3BlcnRpZXN9IEludGVyZmFjZXMgaW4gY2xvc3VyZSBkbyBub3QgaW5oZXJpdCBzdGF0aWNzLCBidXQgY2xhc3NlcyBkb1xuICAgICAgICovXG4gICAgICBzdGF0aWMgX3BhcnNlVGVtcGxhdGVOb2RlQXR0cmlidXRlKG5vZGUsIHRlbXBsYXRlSW5mbywgbm9kZUluZm8sIG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIGxldCBwYXJ0cyA9IHRoaXMuX3BhcnNlQmluZGluZ3ModmFsdWUsIHRlbXBsYXRlSW5mbyk7XG4gICAgICAgIGlmIChwYXJ0cykge1xuICAgICAgICAgIC8vIEF0dHJpYnV0ZSBvciBwcm9wZXJ0eVxuICAgICAgICAgIGxldCBvcmlnTmFtZSA9IG5hbWU7XG4gICAgICAgICAgbGV0IGtpbmQgPSAncHJvcGVydHknO1xuICAgICAgICAgIGlmIChuYW1lW25hbWUubGVuZ3RoLTFdID09ICckJykge1xuICAgICAgICAgICAgbmFtZSA9IG5hbWUuc2xpY2UoMCwgLTEpO1xuICAgICAgICAgICAga2luZCA9ICdhdHRyaWJ1dGUnO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBJbml0aWFsaXplIGF0dHJpYnV0ZSBiaW5kaW5ncyB3aXRoIGFueSBsaXRlcmFsIHBhcnRzXG4gICAgICAgICAgbGV0IGxpdGVyYWwgPSBsaXRlcmFsRnJvbVBhcnRzKHBhcnRzKTtcbiAgICAgICAgICBpZiAobGl0ZXJhbCAmJiBraW5kID09ICdhdHRyaWJ1dGUnKSB7XG4gICAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShuYW1lLCBsaXRlcmFsKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gQ2xlYXIgYXR0cmlidXRlIGJlZm9yZSByZW1vdmluZywgc2luY2UgSUUgd29uJ3QgYWxsb3cgcmVtb3ZpbmdcbiAgICAgICAgICAvLyBgdmFsdWVgIGF0dHJpYnV0ZSBpZiBpdCBwcmV2aW91c2x5IGhhZCBhIHZhbHVlIChjYW4ndFxuICAgICAgICAgIC8vIHVuY29uZGl0aW9uYWxseSBzZXQgJycgYmVmb3JlIHJlbW92aW5nIHNpbmNlIGF0dHJpYnV0ZXMgd2l0aCBgJGBcbiAgICAgICAgICAvLyBjYW4ndCBiZSBzZXQgdXNpbmcgc2V0QXR0cmlidXRlKVxuICAgICAgICAgIGlmIChub2RlLmxvY2FsTmFtZSA9PT0gJ2lucHV0JyAmJiBvcmlnTmFtZSA9PT0gJ3ZhbHVlJykge1xuICAgICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUob3JpZ05hbWUsICcnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gUmVtb3ZlIGFubm90YXRpb25cbiAgICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShvcmlnTmFtZSk7XG4gICAgICAgICAgLy8gQ2FzZSBoYWNrZXJ5OiBhdHRyaWJ1dGVzIGFyZSBsb3dlci1jYXNlLCBidXQgYmluZCB0YXJnZXRzXG4gICAgICAgICAgLy8gKHByb3BlcnRpZXMpIGFyZSBjYXNlIHNlbnNpdGl2ZS4gR2FtYml0IGlzIHRvIG1hcCBkYXNoLWNhc2UgdG9cbiAgICAgICAgICAvLyBjYW1lbC1jYXNlOiBgZm9vLWJhcmAgYmVjb21lcyBgZm9vQmFyYC5cbiAgICAgICAgICAvLyBBdHRyaWJ1dGUgYmluZGluZ3MgYXJlIGV4Y2VwdGVkLlxuICAgICAgICAgIGlmIChraW5kID09PSAncHJvcGVydHknKSB7XG4gICAgICAgICAgICBuYW1lID0gUG9seW1lci5DYXNlTWFwLmRhc2hUb0NhbWVsQ2FzZShuYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYWRkQmluZGluZyh0aGlzLCB0ZW1wbGF0ZUluZm8sIG5vZGVJbmZvLCBraW5kLCBuYW1lLCBwYXJ0cywgbGl0ZXJhbCk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHN1cGVyLl9wYXJzZVRlbXBsYXRlTm9kZUF0dHJpYnV0ZShub2RlLCB0ZW1wbGF0ZUluZm8sIG5vZGVJbmZvLCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBPdmVycmlkZXMgZGVmYXVsdCBgVGVtcGxhdGVTdGFtcGAgaW1wbGVtZW50YXRpb24gdG8gYWRkIHN1cHBvcnQgZm9yXG4gICAgICAgKiBiaW5kaW5nIHRoZSBwcm9wZXJ0aWVzIHRoYXQgYSBuZXN0ZWQgdGVtcGxhdGUgZGVwZW5kcyBvbiB0byB0aGUgdGVtcGxhdGVcbiAgICAgICAqIGFzIGBfaG9zdF88cHJvcGVydHk+YC5cbiAgICAgICAqXG4gICAgICAgKiBAb3ZlcnJpZGVcbiAgICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBOb2RlIHRvIHBhcnNlXG4gICAgICAgKiBAcGFyYW0ge1RlbXBsYXRlSW5mb30gdGVtcGxhdGVJbmZvIFRlbXBsYXRlIG1ldGFkYXRhIGZvciBjdXJyZW50IHRlbXBsYXRlXG4gICAgICAgKiBAcGFyYW0ge05vZGVJbmZvfSBub2RlSW5mbyBOb2RlIG1ldGFkYXRhIGZvciBjdXJyZW50IHRlbXBsYXRlIG5vZGVcbiAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgdmlzaXRlZCBub2RlIGFkZGVkIG5vZGUtc3BlY2lmaWNcbiAgICAgICAqICAgbWV0YWRhdGEgdG8gYG5vZGVJbmZvYFxuICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICogQHN1cHByZXNzIHttaXNzaW5nUHJvcGVydGllc30gSW50ZXJmYWNlcyBpbiBjbG9zdXJlIGRvIG5vdCBpbmhlcml0IHN0YXRpY3MsIGJ1dCBjbGFzc2VzIGRvXG4gICAgICAgKi9cbiAgICAgIHN0YXRpYyBfcGFyc2VUZW1wbGF0ZU5lc3RlZFRlbXBsYXRlKG5vZGUsIHRlbXBsYXRlSW5mbywgbm9kZUluZm8pIHtcbiAgICAgICAgbGV0IG5vdGVkID0gc3VwZXIuX3BhcnNlVGVtcGxhdGVOZXN0ZWRUZW1wbGF0ZShub2RlLCB0ZW1wbGF0ZUluZm8sIG5vZGVJbmZvKTtcbiAgICAgICAgLy8gTWVyZ2UgaG9zdCBwcm9wcyBpbnRvIG91dGVyIHRlbXBsYXRlIGFuZCBhZGQgYmluZGluZ3NcbiAgICAgICAgbGV0IGhvc3RQcm9wcyA9IG5vZGVJbmZvLnRlbXBsYXRlSW5mby5ob3N0UHJvcHM7XG4gICAgICAgIGxldCBtb2RlID0gJ3snO1xuICAgICAgICBmb3IgKGxldCBzb3VyY2UgaW4gaG9zdFByb3BzKSB7XG4gICAgICAgICAgbGV0IHBhcnRzID0gW3sgbW9kZSwgc291cmNlLCBkZXBlbmRlbmNpZXM6IFtzb3VyY2VdIH1dO1xuICAgICAgICAgIGFkZEJpbmRpbmcodGhpcywgdGVtcGxhdGVJbmZvLCBub2RlSW5mbywgJ3Byb3BlcnR5JywgJ19ob3N0XycgKyBzb3VyY2UsIHBhcnRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm90ZWQ7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ2FsbGVkIHRvIHBhcnNlIHRleHQgaW4gYSB0ZW1wbGF0ZSAoZWl0aGVyIGF0dHJpYnV0ZSB2YWx1ZXMgb3JcbiAgICAgICAqIHRleHRDb250ZW50KSBpbnRvIGJpbmRpbmcgbWV0YWRhdGEuXG4gICAgICAgKlxuICAgICAgICogQW55IG92ZXJyaWRlcyBvZiB0aGlzIG1ldGhvZCBzaG91bGQgcmV0dXJuIGFuIGFycmF5IG9mIGJpbmRpbmcgcGFydFxuICAgICAgICogbWV0YWRhdGEgIHJlcHJlc2VudGluZyBvbmUgb3IgbW9yZSBiaW5kaW5ncyBmb3VuZCBpbiB0aGUgcHJvdmlkZWQgdGV4dFxuICAgICAgICogYW5kIGFueSBcImxpdGVyYWxcIiB0ZXh0IGluIGJldHdlZW4uICBBbnkgbm9uLWxpdGVyYWwgcGFydHMgd2lsbCBiZSBwYXNzZWRcbiAgICAgICAqIHRvIGBfZXZhbHVhdGVCaW5kaW5nYCB3aGVuIGFueSBkZXBlbmRlbmNpZXMgY2hhbmdlLiAgVGhlIG9ubHkgcmVxdWlyZWRcbiAgICAgICAqIGZpZWxkcyBvZiBlYWNoIFwicGFydFwiIGluIHRoZSByZXR1cm5lZCBhcnJheSBhcmUgYXMgZm9sbG93czpcbiAgICAgICAqXG4gICAgICAgKiAtIGBkZXBlbmRlbmNpZXNgIC0gQXJyYXkgY29udGFpbmluZyB0cmlnZ2VyIG1ldGFkYXRhIGZvciBlYWNoIHByb3BlcnR5XG4gICAgICAgKiAgIHRoYXQgc2hvdWxkIHRyaWdnZXIgdGhlIGJpbmRpbmcgdG8gdXBkYXRlXG4gICAgICAgKiAtIGBsaXRlcmFsYCAtIFN0cmluZyBjb250YWluaW5nIHRleHQgaWYgdGhlIHBhcnQgcmVwcmVzZW50cyBhIGxpdGVyYWw7XG4gICAgICAgKiAgIGluIHRoaXMgY2FzZSBubyBgZGVwZW5kZW5jaWVzYCBhcmUgbmVlZGVkXG4gICAgICAgKlxuICAgICAgICogQWRkaXRpb25hbCBtZXRhZGF0YSBmb3IgdXNlIGJ5IGBfZXZhbHVhdGVCaW5kaW5nYCBtYXkgYmUgcHJvdmlkZWQgaW5cbiAgICAgICAqIGVhY2ggcGFydCBvYmplY3QgYXMgbmVlZGVkLlxuICAgICAgICpcbiAgICAgICAqIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIGhhbmRsZXMgdGhlIGZvbGxvd2luZyB0eXBlcyBvZiBiaW5kaW5nc1xuICAgICAgICogKG9uZSBvciBtb3JlIG1heSBiZSBpbnRlcm1peGVkIHdpdGggbGl0ZXJhbCBzdHJpbmdzKTpcbiAgICAgICAqIC0gUHJvcGVydHkgYmluZGluZzogYFtbcHJvcF1dYFxuICAgICAgICogLSBQYXRoIGJpbmRpbmc6IGBbW29iamVjdC5wcm9wXV1gXG4gICAgICAgKiAtIE5lZ2F0ZWQgcHJvcGVydHkgb3IgcGF0aCBiaW5kaW5nczogYFtbIXByb3BdXWAgb3IgYFtbIW9iamVjdC5wcm9wXV1gXG4gICAgICAgKiAtIFR3by13YXkgcHJvcGVydHkgb3IgcGF0aCBiaW5kaW5ncyAoc3VwcG9ydHMgbmVnYXRpb24pOlxuICAgICAgICogICBge3twcm9wfX1gLCBge3tvYmplY3QucHJvcH19YCwgYHt7IXByb3B9fWAgb3IgYHt7IW9iamVjdC5wcm9wfX1gXG4gICAgICAgKiAtIElubGluZSBjb21wdXRlZCBtZXRob2QgKHN1cHBvcnRzIG5lZ2F0aW9uKTpcbiAgICAgICAqICAgYFtbY29tcHV0ZShhLCAnbGl0ZXJhbCcsIGIpXV1gLCBgW1shY29tcHV0ZShhLCAnbGl0ZXJhbCcsIGIpXV1gXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgVGV4dCB0byBwYXJzZSBmcm9tIGF0dHJpYnV0ZSBvciB0ZXh0Q29udGVudFxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IHRlbXBsYXRlSW5mbyBDdXJyZW50IHRlbXBsYXRlIG1ldGFkYXRhXG4gICAgICAgKiBAcmV0dXJuIHtBcnJheTwhQmluZGluZ1BhcnQ+fSBBcnJheSBvZiBiaW5kaW5nIHBhcnQgbWV0YWRhdGFcbiAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAqL1xuICAgICAgc3RhdGljIF9wYXJzZUJpbmRpbmdzKHRleHQsIHRlbXBsYXRlSW5mbykge1xuICAgICAgICBsZXQgcGFydHMgPSBbXTtcbiAgICAgICAgbGV0IGxhc3RJbmRleCA9IDA7XG4gICAgICAgIGxldCBtO1xuICAgICAgICAvLyBFeGFtcGxlOiBcImxpdGVyYWwxe3twcm9wfX1saXRlcmFsMltbIWNvbXB1dGUoZm9vLGJhcildXWZpbmFsXCJcbiAgICAgICAgLy8gUmVnZXggbWF0Y2hlczpcbiAgICAgICAgLy8gICAgICAgIEl0ZXJhdGlvbiAxOiAgSXRlcmF0aW9uIDI6XG4gICAgICAgIC8vIG1bMV06ICd7eycgICAgICAgICAgJ1tbJ1xuICAgICAgICAvLyBtWzJdOiAnJyAgICAgICAgICAgICchJ1xuICAgICAgICAvLyBtWzNdOiAncHJvcCcgICAgICAgICdjb21wdXRlKGZvbyxiYXIpJ1xuICAgICAgICB3aGlsZSAoKG0gPSBiaW5kaW5nUmVnZXguZXhlYyh0ZXh0KSkgIT09IG51bGwpIHtcbiAgICAgICAgICAvLyBBZGQgbGl0ZXJhbCBwYXJ0XG4gICAgICAgICAgaWYgKG0uaW5kZXggPiBsYXN0SW5kZXgpIHtcbiAgICAgICAgICAgIHBhcnRzLnB1c2goe2xpdGVyYWw6IHRleHQuc2xpY2UobGFzdEluZGV4LCBtLmluZGV4KX0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBBZGQgYmluZGluZyBwYXJ0XG4gICAgICAgICAgbGV0IG1vZGUgPSBtWzFdWzBdO1xuICAgICAgICAgIGxldCBuZWdhdGUgPSBCb29sZWFuKG1bMl0pO1xuICAgICAgICAgIGxldCBzb3VyY2UgPSBtWzNdLnRyaW0oKTtcbiAgICAgICAgICBsZXQgY3VzdG9tRXZlbnQgPSBmYWxzZSwgbm90aWZ5RXZlbnQgPSAnJywgY29sb24gPSAtMTtcbiAgICAgICAgICBpZiAobW9kZSA9PSAneycgJiYgKGNvbG9uID0gc291cmNlLmluZGV4T2YoJzo6JykpID4gMCkge1xuICAgICAgICAgICAgbm90aWZ5RXZlbnQgPSBzb3VyY2Uuc3Vic3RyaW5nKGNvbG9uICsgMik7XG4gICAgICAgICAgICBzb3VyY2UgPSBzb3VyY2Uuc3Vic3RyaW5nKDAsIGNvbG9uKTtcbiAgICAgICAgICAgIGN1c3RvbUV2ZW50ID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IHNpZ25hdHVyZSA9IHBhcnNlTWV0aG9kKHNvdXJjZSk7XG4gICAgICAgICAgbGV0IGRlcGVuZGVuY2llcyA9IFtdO1xuICAgICAgICAgIGlmIChzaWduYXR1cmUpIHtcbiAgICAgICAgICAgIC8vIElubGluZSBjb21wdXRlZCBmdW5jdGlvblxuICAgICAgICAgICAgbGV0IHthcmdzLCBtZXRob2ROYW1lfSA9IHNpZ25hdHVyZTtcbiAgICAgICAgICAgIGZvciAobGV0IGk9MDsgaTxhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIGxldCBhcmcgPSBhcmdzW2ldO1xuICAgICAgICAgICAgICBpZiAoIWFyZy5saXRlcmFsKSB7XG4gICAgICAgICAgICAgICAgZGVwZW5kZW5jaWVzLnB1c2goYXJnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGR5bmFtaWNGbnMgPSB0ZW1wbGF0ZUluZm8uZHluYW1pY0ZucztcbiAgICAgICAgICAgIGlmIChkeW5hbWljRm5zICYmIGR5bmFtaWNGbnNbbWV0aG9kTmFtZV0gfHwgc2lnbmF0dXJlLnN0YXRpYykge1xuICAgICAgICAgICAgICBkZXBlbmRlbmNpZXMucHVzaChtZXRob2ROYW1lKTtcbiAgICAgICAgICAgICAgc2lnbmF0dXJlLmR5bmFtaWNGbiA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFByb3BlcnR5IG9yIHBhdGhcbiAgICAgICAgICAgIGRlcGVuZGVuY2llcy5wdXNoKHNvdXJjZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBhcnRzLnB1c2goe1xuICAgICAgICAgICAgc291cmNlLCBtb2RlLCBuZWdhdGUsIGN1c3RvbUV2ZW50LCBzaWduYXR1cmUsIGRlcGVuZGVuY2llcyxcbiAgICAgICAgICAgIGV2ZW50OiBub3RpZnlFdmVudFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGxhc3RJbmRleCA9IGJpbmRpbmdSZWdleC5sYXN0SW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIGEgZmluYWwgbGl0ZXJhbCBwYXJ0XG4gICAgICAgIGlmIChsYXN0SW5kZXggJiYgbGFzdEluZGV4IDwgdGV4dC5sZW5ndGgpIHtcbiAgICAgICAgICBsZXQgbGl0ZXJhbCA9IHRleHQuc3Vic3RyaW5nKGxhc3RJbmRleCk7XG4gICAgICAgICAgaWYgKGxpdGVyYWwpIHtcbiAgICAgICAgICAgIHBhcnRzLnB1c2goe1xuICAgICAgICAgICAgICBsaXRlcmFsOiBsaXRlcmFsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBwYXJ0cztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENhbGxlZCB0byBldmFsdWF0ZSBhIHByZXZpb3VzbHkgcGFyc2VkIGJpbmRpbmcgcGFydCBiYXNlZCBvbiBhIHNldCBvZlxuICAgICAgICogb25lIG9yIG1vcmUgY2hhbmdlZCBkZXBlbmRlbmNpZXMuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHt0aGlzfSBpbnN0IEVsZW1lbnQgdGhhdCBzaG91bGQgYmUgdXNlZCBhcyBzY29wZSBmb3JcbiAgICAgICAqICAgYmluZGluZyBkZXBlbmRlbmNpZXNcbiAgICAgICAqIEBwYXJhbSB7QmluZGluZ1BhcnR9IHBhcnQgQmluZGluZyBwYXJ0IG1ldGFkYXRhXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBQcm9wZXJ0eS9wYXRoIHRoYXQgdHJpZ2dlcmVkIHRoaXMgZWZmZWN0XG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgQmFnIG9mIGN1cnJlbnQgcHJvcGVydHkgY2hhbmdlc1xuICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9sZFByb3BzIEJhZyBvZiBwcmV2aW91cyB2YWx1ZXMgZm9yIGNoYW5nZWQgcHJvcGVydGllc1xuICAgICAgICogQHBhcmFtIHtib29sZWFufSBoYXNQYXRocyBUcnVlIHdpdGggYHByb3BzYCBjb250YWlucyBvbmUgb3IgbW9yZSBwYXRoc1xuICAgICAgICogQHJldHVybiB7Kn0gVmFsdWUgdGhlIGJpbmRpbmcgcGFydCBldmFsdWF0ZWQgdG9cbiAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAqL1xuICAgICAgc3RhdGljIF9ldmFsdWF0ZUJpbmRpbmcoaW5zdCwgcGFydCwgcGF0aCwgcHJvcHMsIG9sZFByb3BzLCBoYXNQYXRocykge1xuICAgICAgICBsZXQgdmFsdWU7XG4gICAgICAgIGlmIChwYXJ0LnNpZ25hdHVyZSkge1xuICAgICAgICAgIHZhbHVlID0gcnVuTWV0aG9kRWZmZWN0KGluc3QsIHBhdGgsIHByb3BzLCBvbGRQcm9wcywgcGFydC5zaWduYXR1cmUpO1xuICAgICAgICB9IGVsc2UgaWYgKHBhdGggIT0gcGFydC5zb3VyY2UpIHtcbiAgICAgICAgICB2YWx1ZSA9IFBvbHltZXIuUGF0aC5nZXQoaW5zdCwgcGFydC5zb3VyY2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChoYXNQYXRocyAmJiBQb2x5bWVyLlBhdGguaXNQYXRoKHBhdGgpKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IFBvbHltZXIuUGF0aC5nZXQoaW5zdCwgcGF0aCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbHVlID0gaW5zdC5fX2RhdGFbcGF0aF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0Lm5lZ2F0ZSkge1xuICAgICAgICAgIHZhbHVlID0gIXZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cblxuICAgIH1cblxuICAgIC8vIG1ha2UgYSB0eXBpbmcgZm9yIGNsb3N1cmUgOlBcbiAgICBQcm9wZXJ0eUVmZmVjdHNUeXBlID0gUHJvcGVydHlFZmZlY3RzO1xuXG4gICAgcmV0dXJuIFByb3BlcnR5RWZmZWN0cztcbiAgfSk7XG5cbiAgLyoqXG4gICAqIEhlbHBlciBhcGkgZm9yIGVucXVlaW5nIGNsaWVudCBkb20gY3JlYXRlZCBieSBhIGhvc3QgZWxlbWVudC5cbiAgICpcbiAgICogQnkgZGVmYXVsdCBlbGVtZW50cyBhcmUgZmx1c2hlZCB2aWEgYF9mbHVzaFByb3BlcnRpZXNgIHdoZW5cbiAgICogYGNvbm5lY3RlZENhbGxiYWNrYCBpcyBjYWxsZWQuIEVsZW1lbnRzIGF0dGFjaCB0aGVpciBjbGllbnQgZG9tIHRvXG4gICAqIHRoZW1zZWx2ZXMgYXQgYHJlYWR5YCB0aW1lIHdoaWNoIHJlc3VsdHMgZnJvbSB0aGlzIGZpcnN0IGZsdXNoLlxuICAgKiBUaGlzIHByb3ZpZGVzIGFuIG9yZGVyaW5nIGd1YXJhbnRlZSB0aGF0IHRoZSBjbGllbnQgZG9tIGFuIGVsZW1lbnRcbiAgICogY3JlYXRlcyBpcyBmbHVzaGVkIGJlZm9yZSB0aGUgZWxlbWVudCBpdHNlbGYgKGkuZS4gY2xpZW50IGByZWFkeWBcbiAgICogZmlyZXMgYmVmb3JlIGhvc3QgYHJlYWR5YCkuXG4gICAqXG4gICAqIEhvd2V2ZXIsIGlmIGBfZmx1c2hQcm9wZXJ0aWVzYCBpcyBjYWxsZWQgKmJlZm9yZSogYW4gZWxlbWVudCBpcyBjb25uZWN0ZWQsXG4gICAqIGFzIGZvciBleGFtcGxlIGBUZW1wbGF0aXplYCBkb2VzLCB0aGlzIG9yZGVyaW5nIGd1YXJhbnRlZSBjYW5ub3QgYmVcbiAgICogc2F0aXNmaWVkIGJlY2F1c2Ugbm8gZWxlbWVudHMgYXJlIGNvbm5lY3RlZC4gKE5vdGU6IEJvdW5kIGVsZW1lbnRzIHRoYXRcbiAgICogcmVjZWl2ZSBkYXRhIGRvIGJlY29tZSBlbnF1ZXVlZCBjbGllbnRzIGFuZCBhcmUgcHJvcGVybHkgb3JkZXJlZCBidXRcbiAgICogdW5ib3VuZCBlbGVtZW50cyBhcmUgbm90LilcbiAgICpcbiAgICogVG8gbWFpbnRhaW4gdGhlIGRlc2lyZWQgXCJjbGllbnQgYmVmb3JlIGhvc3RcIiBvcmRlcmluZyBndWFyYW50ZWUgZm9yIHRoaXNcbiAgICogY2FzZSB3ZSByZWx5IG9uIHRoZSBcImhvc3Qgc3RhY2suIENsaWVudCBub2RlcyByZWdpc3RlcnMgdGhlbXNlbHZlcyB3aXRoXG4gICAqIHRoZSBjcmVhdGluZyBob3N0IGVsZW1lbnQgd2hlbiBjcmVhdGVkLiBUaGlzIGVuc3VyZXMgdGhhdCBhbGwgY2xpZW50IGRvbVxuICAgKiBpcyByZWFkaWVkIGluIHRoZSBwcm9wZXIgb3JkZXIsIG1haW50YWluaW5nIHRoZSBkZXNpcmVkIGd1YXJhbnRlZS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGxldCBob3N0U3RhY2sgPSB7XG5cbiAgICBzdGFjazogW10sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyp9IGluc3QgSW5zdGFuY2UgdG8gYWRkIHRvIGhvc3RTdGFja1xuICAgICAqIEB0aGlzIHtob3N0U3RhY2t9XG4gICAgICovXG4gICAgcmVnaXN0ZXJIb3N0KGluc3QpIHtcbiAgICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aCkge1xuICAgICAgICBsZXQgaG9zdCA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGgtMV07XG4gICAgICAgIGhvc3QuX2VucXVldWVDbGllbnQoaW5zdCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Kn0gaW5zdCBJbnN0YW5jZSB0byBiZWdpbiBob3N0aW5nXG4gICAgICogQHRoaXMge2hvc3RTdGFja31cbiAgICAgKi9cbiAgICBiZWdpbkhvc3RpbmcoaW5zdCkge1xuICAgICAgdGhpcy5zdGFjay5wdXNoKGluc3QpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyp9IGluc3QgSW5zdGFuY2UgdG8gZW5kIGhvc3RpbmdcbiAgICAgKiBAdGhpcyB7aG9zdFN0YWNrfVxuICAgICAqL1xuICAgIGVuZEhvc3RpbmcoaW5zdCkge1xuICAgICAgbGV0IHN0YWNrTGVuID0gdGhpcy5zdGFjay5sZW5ndGg7XG4gICAgICBpZiAoc3RhY2tMZW4gJiYgdGhpcy5zdGFja1tzdGFja0xlbi0xXSA9PSBpbnN0KSB7XG4gICAgICAgIHRoaXMuc3RhY2sucG9wKCk7XG4gICAgICB9XG4gICAgfVxuXG4gIH1cblxufSkoKTtcbjwvc2NyaXB0PlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi9taXhpbnMvcHJvcGVydHktZWZmZWN0cy5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cImJvb3QuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIm1peGluLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCJhc3luYy5odG1sXCI+XG5cbjxzY3JpcHQ+XG4oZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvKiogQHR5cGVkZWYge3tydW46IGZ1bmN0aW9uKGZ1bmN0aW9uKCksIG51bWJlcj0pOm51bWJlciwgY2FuY2VsOiBmdW5jdGlvbihudW1iZXIpfX0gKi9cbiAgbGV0IEFzeW5jTW9kdWxlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cbiAgLyoqXG4gICAqIEBzdW1tYXJ5IENvbGxhcHNlIG11bHRpcGxlIGNhbGxiYWNrcyBpbnRvIG9uZSBpbnZvY2F0aW9uIGFmdGVyIGEgdGltZXIuXG4gICAqIEBtZW1iZXJvZiBQb2x5bWVyXG4gICAqL1xuICBjbGFzcyBEZWJvdW5jZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgdGhpcy5fYXN5bmNNb2R1bGUgPSBudWxsO1xuICAgICAgdGhpcy5fY2FsbGJhY2sgPSBudWxsO1xuICAgICAgdGhpcy5fdGltZXIgPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBzY2hlZHVsZXI7IHRoYXQgaXMsIGEgbW9kdWxlIHdpdGggdGhlIEFzeW5jIGludGVyZmFjZSxcbiAgICAgKiBhIGNhbGxiYWNrIGFuZCBvcHRpb25hbCBhcmd1bWVudHMgdG8gYmUgcGFzc2VkIHRvIHRoZSBydW4gZnVuY3Rpb25cbiAgICAgKiBmcm9tIHRoZSBhc3luYyBtb2R1bGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyFBc3luY01vZHVsZX0gYXN5bmNNb2R1bGUgT2JqZWN0IHdpdGggQXN5bmMgaW50ZXJmYWNlLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oKX0gY2FsbGJhY2sgQ2FsbGJhY2sgdG8gcnVuLlxuICAgICAqL1xuICAgIHNldENvbmZpZyhhc3luY01vZHVsZSwgY2FsbGJhY2spIHtcbiAgICAgIHRoaXMuX2FzeW5jTW9kdWxlID0gYXN5bmNNb2R1bGU7XG4gICAgICB0aGlzLl9jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgdGhpcy5fdGltZXIgPSB0aGlzLl9hc3luY01vZHVsZS5ydW4oKCkgPT4ge1xuICAgICAgICB0aGlzLl90aW1lciA9IG51bGw7XG4gICAgICAgIHRoaXMuX2NhbGxiYWNrKClcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYW5jZWxzIGFuIGFjdGl2ZSBkZWJvdW5jZXIgYW5kIHJldHVybnMgYSByZWZlcmVuY2UgdG8gaXRzZWxmLlxuICAgICAqL1xuICAgIGNhbmNlbCgpIHtcbiAgICAgIGlmICh0aGlzLmlzQWN0aXZlKCkpIHtcbiAgICAgICAgdGhpcy5fYXN5bmNNb2R1bGUuY2FuY2VsKHRoaXMuX3RpbWVyKTtcbiAgICAgICAgdGhpcy5fdGltZXIgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBGbHVzaGVzIGFuIGFjdGl2ZSBkZWJvdW5jZXIgYW5kIHJldHVybnMgYSByZWZlcmVuY2UgdG8gaXRzZWxmLlxuICAgICAqL1xuICAgIGZsdXNoKCkge1xuICAgICAgaWYgKHRoaXMuaXNBY3RpdmUoKSkge1xuICAgICAgICB0aGlzLmNhbmNlbCgpO1xuICAgICAgICB0aGlzLl9jYWxsYmFjaygpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGRlYm91bmNlciBpcyBhY3RpdmUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGFjdGl2ZS5cbiAgICAgKi9cbiAgICBpc0FjdGl2ZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLl90aW1lciAhPSBudWxsO1xuICAgIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBkZWJvdW5jZXIgaWYgbm8gZGVib3VuY2VyIGlzIHBhc3NlZCBhcyBhIHBhcmFtZXRlclxuICAgKiBvciBpdCBjYW5jZWxzIGFuIGFjdGl2ZSBkZWJvdW5jZXIgb3RoZXJ3aXNlLiBUaGUgZm9sbG93aW5nXG4gICAqIGV4YW1wbGUgc2hvd3MgaG93IGEgZGVib3VuY2VyIGNhbiBiZSBjYWxsZWQgbXVsdGlwbGUgdGltZXMgd2l0aGluIGFcbiAgICogbWljcm90YXNrIGFuZCBcImRlYm91bmNlZFwiIHN1Y2ggdGhhdCB0aGUgcHJvdmlkZWQgY2FsbGJhY2sgZnVuY3Rpb24gaXNcbiAgICogY2FsbGVkIG9uY2UuIEFkZCB0aGlzIG1ldGhvZCB0byBhIGN1c3RvbSBlbGVtZW50OlxuICAgKlxuICAgKiBfZGVib3VuY2VXb3JrKCkge1xuICAgKiAgIHRoaXMuX2RlYm91bmNlSm9iID0gUG9seW1lci5EZWJvdW5jZXIuZGVib3VuY2UodGhpcy5fZGVib3VuY2VKb2IsXG4gICAqICAgICAgIFBvbHltZXIuQXN5bmMubWljcm9UYXNrLCAoKSA9PiB7XG4gICAqICAgICB0aGlzLl9kb1dvcmsoKTtcbiAgICogICB9KTtcbiAgICogfVxuICAgKlxuICAgKiBJZiB0aGUgYF9kZWJvdW5jZVdvcmtgIG1ldGhvZCBpcyBjYWxsZWQgbXVsdGlwbGUgdGltZXMgd2l0aGluIHRoZSBzYW1lXG4gICAqIG1pY3JvdGFzaywgdGhlIGBfZG9Xb3JrYCBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCBvbmx5IG9uY2UgYXQgdGhlIG5leHRcbiAgICogbWljcm90YXNrIGNoZWNrcG9pbnQuXG4gICAqXG4gICAqIE5vdGU6IEluIHRlc3RpbmcgaXQgaXMgb2Z0ZW4gY29udmVuaWVudCB0byBhdm9pZCBhc3luY2hyb255LiBUbyBhY2NvbXBsaXNoXG4gICAqIHRoaXMgd2l0aCBhIGRlYm91bmNlciwgeW91IGNhbiB1c2UgYFBvbHltZXIuZW5xdWV1ZURlYm91bmNlcmAgYW5kXG4gICAqIGBQb2x5bWVyLmZsdXNoYC4gRm9yIGV4YW1wbGUsIGV4dGVuZCB0aGUgYWJvdmUgZXhhbXBsZSBieSBhZGRpbmdcbiAgICogYFBvbHltZXIuZW5xdWV1ZURlYm91bmNlcih0aGlzLl9kZWJvdW5jZUpvYilgIGF0IHRoZSBlbmQgb2YgdGhlXG4gICAqIGBfZGVib3VuY2VXb3JrYCBtZXRob2QuIFRoZW4gaW4gYSB0ZXN0LCBjYWxsIGBQb2x5bWVyLmZsdXNoYCB0byBlbnN1cmVcbiAgICogdGhlIGRlYm91bmNlciBoYXMgY29tcGxldGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge0RlYm91bmNlcj99IGRlYm91bmNlciBEZWJvdW5jZXIgb2JqZWN0LlxuICAgKiBAcGFyYW0geyFBc3luY01vZHVsZX0gYXN5bmNNb2R1bGUgT2JqZWN0IHdpdGggQXN5bmMgaW50ZXJmYWNlXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oKX0gY2FsbGJhY2sgQ2FsbGJhY2sgdG8gcnVuLlxuICAgKiBAcmV0dXJuIHshRGVib3VuY2VyfSBSZXR1cm5zIGEgZGVib3VuY2VyIG9iamVjdC5cbiAgICovXG4gICAgc3RhdGljIGRlYm91bmNlKGRlYm91bmNlciwgYXN5bmNNb2R1bGUsIGNhbGxiYWNrKSB7XG4gICAgICBpZiAoZGVib3VuY2VyIGluc3RhbmNlb2YgRGVib3VuY2VyKSB7XG4gICAgICAgIGRlYm91bmNlci5jYW5jZWwoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlYm91bmNlciA9IG5ldyBEZWJvdW5jZXIoKTtcbiAgICAgIH1cbiAgICAgIGRlYm91bmNlci5zZXRDb25maWcoYXN5bmNNb2R1bGUsIGNhbGxiYWNrKTtcbiAgICAgIHJldHVybiBkZWJvdW5jZXI7XG4gICAgfVxuICB9XG5cbiAgUG9seW1lci5EZWJvdW5jZXIgPSBEZWJvdW5jZXI7XG59KSgpO1xuPC9zY3JpcHQ+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL3BvbHltZXIvbGliL3V0aWxzL2RlYm91bmNlLmh0bWwiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiYm9vdC5odG1sXCI+XG48c2NyaXB0PlxuKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgbGV0IGRlYm91bmNlclF1ZXVlID0gW107XG5cbiAgLyoqXG4gICAqIEFkZHMgYSBgUG9seW1lci5EZWJvdW5jZXJgIHRvIGEgbGlzdCBvZiBnbG9iYWxseSBmbHVzaGFibGUgdGFza3MuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBQb2x5bWVyXG4gICAqIEBwYXJhbSB7UG9seW1lci5EZWJvdW5jZXJ9IGRlYm91bmNlciBEZWJvdW5jZXIgdG8gZW5xdWV1ZVxuICAgKi9cbiAgUG9seW1lci5lbnF1ZXVlRGVib3VuY2VyID0gZnVuY3Rpb24oZGVib3VuY2VyKSB7XG4gICAgZGVib3VuY2VyUXVldWUucHVzaChkZWJvdW5jZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZmx1c2hEZWJvdW5jZXJzKCkge1xuICAgIGNvbnN0IGRpZEZsdXNoID0gQm9vbGVhbihkZWJvdW5jZXJRdWV1ZS5sZW5ndGgpO1xuICAgIHdoaWxlIChkZWJvdW5jZXJRdWV1ZS5sZW5ndGgpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGRlYm91bmNlclF1ZXVlLnNoaWZ0KCkuZmx1c2goKTtcbiAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRpZEZsdXNoO1xuICB9XG5cbiAgLyoqXG4gICAqIEZvcmNlcyBzZXZlcmFsIGNsYXNzZXMgb2YgYXN5bmNocm9ub3VzbHkgcXVldWVkIHRhc2tzIHRvIGZsdXNoOlxuICAgKiAtIERlYm91bmNlcnMgYWRkZWQgdmlhIGBlbnF1ZXVlRGVib3VuY2VyYFxuICAgKiAtIFNoYWR5RE9NIGRpc3RyaWJ1dGlvblxuICAgKlxuICAgKiBAbWVtYmVyb2YgUG9seW1lclxuICAgKi9cbiAgUG9seW1lci5mbHVzaCA9IGZ1bmN0aW9uKCkge1xuICAgIGxldCBzaGFkeURPTSwgZGVib3VuY2VycztcbiAgICBkbyB7XG4gICAgICBzaGFkeURPTSA9IHdpbmRvdy5TaGFkeURPTSAmJiBTaGFkeURPTS5mbHVzaCgpO1xuICAgICAgaWYgKHdpbmRvdy5TaGFkeUNTUyAmJiB3aW5kb3cuU2hhZHlDU1MuU2NvcGluZ1NoaW0pIHtcbiAgICAgICAgd2luZG93LlNoYWR5Q1NTLlNjb3BpbmdTaGltLmZsdXNoKCk7XG4gICAgICB9XG4gICAgICBkZWJvdW5jZXJzID0gZmx1c2hEZWJvdW5jZXJzKCk7XG4gICAgfSB3aGlsZSAoc2hhZHlET00gfHwgZGVib3VuY2Vycyk7XG4gIH1cblxufSkoKTtcbjwvc2NyaXB0PlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi91dGlscy9mbHVzaC5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuXG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiYm9vdC5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vbWl4aW5zL3Byb3BlcnR5LWVmZmVjdHMuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL21peGlucy9tdXRhYmxlLWRhdGEuaHRtbFwiPlxuXG48c2NyaXB0PlxuICAoZnVuY3Rpb24oKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgLy8gQmFzZSBjbGFzcyBmb3IgSFRNTFRlbXBsYXRlRWxlbWVudCBleHRlbnNpb24gdGhhdCBoYXMgcHJvcGVydHkgZWZmZWN0c1xuICAgIC8vIG1hY2hpbmVyeSBmb3IgcHJvcGFnYXRpbmcgaG9zdCBwcm9wZXJ0aWVzIHRvIGNoaWxkcmVuLiBUaGlzIGlzIGFuIEVTNVxuICAgIC8vIGNsYXNzIG9ubHkgYmVjYXVzZSBCYWJlbCAoaW5jb3JyZWN0bHkpIHJlcXVpcmVzIHN1cGVyKCkgaW4gdGhlIGNsYXNzXG4gICAgLy8gY29uc3RydWN0b3IgZXZlbiB0aG91Z2ggbm8gYHRoaXNgIGlzIHVzZWQgYW5kIGl0IHJldHVybnMgYW4gaW5zdGFuY2UuXG4gICAgbGV0IG5ld0luc3RhbmNlID0gbnVsbDtcbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAZXh0ZW5kcyB7SFRNTFRlbXBsYXRlRWxlbWVudH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBIVE1MVGVtcGxhdGVFbGVtZW50RXh0ZW5zaW9uKCkgeyByZXR1cm4gbmV3SW5zdGFuY2U7IH1cbiAgICBIVE1MVGVtcGxhdGVFbGVtZW50RXh0ZW5zaW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSFRNTFRlbXBsYXRlRWxlbWVudC5wcm90b3R5cGUsIHtcbiAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgIHZhbHVlOiBIVE1MVGVtcGxhdGVFbGVtZW50RXh0ZW5zaW9uLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBpbXBsZW1lbnRzIHtQb2x5bWVyX1Byb3BlcnR5RWZmZWN0c31cbiAgICAgKiBAZXh0ZW5kcyB7SFRNTFRlbXBsYXRlRWxlbWVudEV4dGVuc2lvbn1cbiAgICAgKi9cbiAgICBjb25zdCBEYXRhVGVtcGxhdGUgPSBQb2x5bWVyLlByb3BlcnR5RWZmZWN0cyhIVE1MVGVtcGxhdGVFbGVtZW50RXh0ZW5zaW9uKTtcbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAaW1wbGVtZW50cyB7UG9seW1lcl9NdXRhYmxlRGF0YX1cbiAgICAgKiBAZXh0ZW5kcyB7RGF0YVRlbXBsYXRlfVxuICAgICAqL1xuICAgIGNvbnN0IE11dGFibGVEYXRhVGVtcGxhdGUgPSBQb2x5bWVyLk11dGFibGVEYXRhKERhdGFUZW1wbGF0ZSk7XG5cbiAgICAvLyBBcHBsaWVzIGEgRGF0YVRlbXBsYXRlIHN1YmNsYXNzIHRvIGEgPHRlbXBsYXRlPiBpbnN0YW5jZVxuICAgIGZ1bmN0aW9uIHVwZ3JhZGVUZW1wbGF0ZSh0ZW1wbGF0ZSwgY29uc3RydWN0b3IpIHtcbiAgICAgIG5ld0luc3RhbmNlID0gdGVtcGxhdGU7XG4gICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGVtcGxhdGUsIGNvbnN0cnVjdG9yLnByb3RvdHlwZSk7XG4gICAgICBuZXcgY29uc3RydWN0b3IoKTtcbiAgICAgIG5ld0luc3RhbmNlID0gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBCYXNlIGNsYXNzIGZvciBUZW1wbGF0ZUluc3RhbmNlJ3NcbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAaW1wbGVtZW50cyB7UG9seW1lcl9Qcm9wZXJ0eUVmZmVjdHN9XG4gICAgICovXG4gICAgY29uc3QgYmFzZSA9IFBvbHltZXIuUHJvcGVydHlFZmZlY3RzKGNsYXNzIHt9KTtcblxuICAgIC8qKlxuICAgICAqIEBwb2x5bWVyXG4gICAgICogQGN1c3RvbUVsZW1lbnRcbiAgICAgKiBAYXBwbGllc01peGluIFBvbHltZXIuUHJvcGVydHlFZmZlY3RzXG4gICAgICogQHVucmVzdHJpY3RlZFxuICAgICAqL1xuICAgIGNsYXNzIFRlbXBsYXRlSW5zdGFuY2VCYXNlIGV4dGVuZHMgYmFzZSB7XG4gICAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl9jb25maWd1cmVQcm9wZXJ0aWVzKHByb3BzKTtcbiAgICAgICAgdGhpcy5yb290ID0gdGhpcy5fc3RhbXBUZW1wbGF0ZSh0aGlzLl9fZGF0YUhvc3QpO1xuICAgICAgICAvLyBTYXZlIGxpc3Qgb2Ygc3RhbXBlZCBjaGlsZHJlblxuICAgICAgICBsZXQgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuID0gW107XG4gICAgICAgIGZvciAobGV0IG4gPSB0aGlzLnJvb3QuZmlyc3RDaGlsZDsgbjsgbj1uLm5leHRTaWJsaW5nKSB7XG4gICAgICAgICAgY2hpbGRyZW4ucHVzaChuKTtcbiAgICAgICAgICBuLl9fdGVtcGxhdGl6ZUluc3RhbmNlID0gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fX3RlbXBsYXRpemVPd25lci5fX2hpZGVUZW1wbGF0ZUNoaWxkcmVuX18pIHtcbiAgICAgICAgICB0aGlzLl9zaG93SGlkZUNoaWxkcmVuKHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZsdXNoIHByb3BzIG9ubHkgd2hlbiBwcm9wcyBhcmUgcGFzc2VkIGlmIGluc3RhbmNlIHByb3BzIGV4aXN0XG4gICAgICAgIC8vIG9yIHdoZW4gdGhlcmUgaXNuJ3QgaW5zdGFuY2UgcHJvcHMuXG4gICAgICAgIGxldCBvcHRpb25zID0gdGhpcy5fX3RlbXBsYXRpemVPcHRpb25zO1xuICAgICAgICBpZiAoKHByb3BzICYmIG9wdGlvbnMuaW5zdGFuY2VQcm9wcykgfHwgIW9wdGlvbnMuaW5zdGFuY2VQcm9wcykge1xuICAgICAgICAgIHRoaXMuX2VuYWJsZVByb3BlcnRpZXMoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBDb25maWd1cmUgdGhlIGdpdmVuIGBwcm9wc2AgYnkgY2FsbGluZyBgX3NldFBlbmRpbmdQcm9wZXJ0eWAuIEFsc29cbiAgICAgICAqIHNldHMgYW55IHByb3BlcnRpZXMgc3RvcmVkIGluIGBfX2hvc3RQcm9wc2AuXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzIE9iamVjdCBvZiBwcm9wZXJ0eSBuYW1lLXZhbHVlIHBhaXJzIHRvIHNldC5cbiAgICAgICAqL1xuICAgICAgX2NvbmZpZ3VyZVByb3BlcnRpZXMocHJvcHMpIHtcbiAgICAgICAgbGV0IG9wdGlvbnMgPSB0aGlzLl9fdGVtcGxhdGl6ZU9wdGlvbnM7XG4gICAgICAgIGlmIChwcm9wcykge1xuICAgICAgICAgIGZvciAobGV0IGlwcm9wIGluIG9wdGlvbnMuaW5zdGFuY2VQcm9wcykge1xuICAgICAgICAgICAgaWYgKGlwcm9wIGluIHByb3BzKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3NldFBlbmRpbmdQcm9wZXJ0eShpcHJvcCwgcHJvcHNbaXByb3BdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaHByb3AgaW4gdGhpcy5fX2hvc3RQcm9wcykge1xuICAgICAgICAgIHRoaXMuX3NldFBlbmRpbmdQcm9wZXJ0eShocHJvcCwgdGhpcy5fX2RhdGFIb3N0WydfaG9zdF8nICsgaHByb3BdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBGb3J3YXJkcyBhIGhvc3QgcHJvcGVydHkgdG8gdGhpcyBpbnN0YW5jZS4gIFRoaXMgbWV0aG9kIHNob3VsZCBiZVxuICAgICAgICogY2FsbGVkIG9uIGluc3RhbmNlcyBmcm9tIHRoZSBgb3B0aW9ucy5mb3J3YXJkSG9zdFByb3BgIGNhbGxiYWNrXG4gICAgICAgKiB0byBwcm9wYWdhdGUgY2hhbmdlcyBvZiBob3N0IHByb3BlcnRpZXMgdG8gZWFjaCBpbnN0YW5jZS5cbiAgICAgICAqXG4gICAgICAgKiBOb3RlIHRoaXMgbWV0aG9kIGVucXVldWVzIHRoZSBjaGFuZ2UsIHdoaWNoIGFyZSBmbHVzaGVkIGFzIGEgYmF0Y2guXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3AgUHJvcGVydHkgb3IgcGF0aCBuYW1lXG4gICAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIG9mIHRoZSBwcm9wZXJ0eSB0byBmb3J3YXJkXG4gICAgICAgKi9cbiAgICAgIGZvcndhcmRIb3N0UHJvcChwcm9wLCB2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5fc2V0UGVuZGluZ1Byb3BlcnR5T3JQYXRoKHByb3AsIHZhbHVlLCBmYWxzZSwgdHJ1ZSkpIHtcbiAgICAgICAgICB0aGlzLl9fZGF0YUhvc3QuX2VucXVldWVDbGllbnQodGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogQG92ZXJyaWRlXG4gICAgICAgKi9cbiAgICAgIF9hZGRFdmVudExpc3RlbmVyVG9Ob2RlKG5vZGUsIGV2ZW50TmFtZSwgaGFuZGxlcikge1xuICAgICAgICBpZiAodGhpcy5fbWV0aG9kSG9zdCAmJiB0aGlzLl9fdGVtcGxhdGl6ZU9wdGlvbnMucGFyZW50TW9kZWwpIHtcbiAgICAgICAgICAvLyBJZiB0aGlzIGluc3RhbmNlIHNob3VsZCBiZSBjb25zaWRlcmVkIGEgcGFyZW50IG1vZGVsLCBkZWNvcmF0ZVxuICAgICAgICAgIC8vIGV2ZW50cyB0aGlzIHRlbXBsYXRlIGluc3RhbmNlIGFzIGBtb2RlbGBcbiAgICAgICAgICB0aGlzLl9tZXRob2RIb3N0Ll9hZGRFdmVudExpc3RlbmVyVG9Ob2RlKG5vZGUsIGV2ZW50TmFtZSwgKGUpID0+IHtcbiAgICAgICAgICAgIGUubW9kZWwgPSB0aGlzO1xuICAgICAgICAgICAgaGFuZGxlcihlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBPdGhlcndpc2UgZGVsZWdhdGUgdG8gdGhlIHRlbXBsYXRlJ3MgaG9zdCAod2hpY2ggY291bGQgYmUpXG4gICAgICAgICAgLy8gYW5vdGhlciB0ZW1wbGF0ZSBpbnN0YW5jZVxuICAgICAgICAgIGxldCB0ZW1wbGF0ZUhvc3QgPSB0aGlzLl9fZGF0YUhvc3QuX19kYXRhSG9zdDtcbiAgICAgICAgICBpZiAodGVtcGxhdGVIb3N0KSB7XG4gICAgICAgICAgICB0ZW1wbGF0ZUhvc3QuX2FkZEV2ZW50TGlzdGVuZXJUb05vZGUobm9kZSwgZXZlbnROYW1lLCBoYW5kbGVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogU2hvd3Mgb3IgaGlkZXMgdGhlIHRlbXBsYXRlIGluc3RhbmNlIHRvcCBsZXZlbCBjaGlsZCBlbGVtZW50cy4gRm9yXG4gICAgICAgKiB0ZXh0IG5vZGVzLCBgdGV4dENvbnRlbnRgIGlzIHJlbW92ZWQgd2hpbGUgXCJoaWRkZW5cIiBhbmQgcmVwbGFjZWQgd2hlblxuICAgICAgICogXCJzaG93bi5cIlxuICAgICAgICogQHBhcmFtIHtib29sZWFufSBoaWRlIFNldCB0byB0cnVlIHRvIGhpZGUgdGhlIGNoaWxkcmVuO1xuICAgICAgICogc2V0IHRvIGZhbHNlIHRvIHNob3cgdGhlbS5cbiAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAqL1xuICAgICAgX3Nob3dIaWRlQ2hpbGRyZW4oaGlkZSkge1xuICAgICAgICBsZXQgYyA9IHRoaXMuY2hpbGRyZW47XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxjLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgbGV0IG4gPSBjW2ldO1xuICAgICAgICAgIC8vIElnbm9yZSBub24tY2hhbmdlc1xuICAgICAgICAgIGlmIChCb29sZWFuKGhpZGUpICE9IEJvb2xlYW4obi5fX2hpZGVUZW1wbGF0ZUNoaWxkcmVuX18pKSB7XG4gICAgICAgICAgICBpZiAobi5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUpIHtcbiAgICAgICAgICAgICAgaWYgKGhpZGUpIHtcbiAgICAgICAgICAgICAgICBuLl9fcG9seW1lclRleHRDb250ZW50X18gPSBuLnRleHRDb250ZW50O1xuICAgICAgICAgICAgICAgIG4udGV4dENvbnRlbnQgPSAnJztcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBuLnRleHRDb250ZW50ID0gbi5fX3BvbHltZXJUZXh0Q29udGVudF9fO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG4uc3R5bGUpIHtcbiAgICAgICAgICAgICAgaWYgKGhpZGUpIHtcbiAgICAgICAgICAgICAgICBuLl9fcG9seW1lckRpc3BsYXlfXyA9IG4uc3R5bGUuZGlzcGxheTtcbiAgICAgICAgICAgICAgICBuLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbi5zdHlsZS5kaXNwbGF5ID0gbi5fX3BvbHltZXJEaXNwbGF5X187XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgbi5fX2hpZGVUZW1wbGF0ZUNoaWxkcmVuX18gPSBoaWRlO1xuICAgICAgICAgIGlmIChuLl9zaG93SGlkZUNoaWxkcmVuKSB7XG4gICAgICAgICAgICBuLl9zaG93SGlkZUNoaWxkcmVuKGhpZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBPdmVycmlkZXMgZGVmYXVsdCBwcm9wZXJ0eS1lZmZlY3RzIGltcGxlbWVudGF0aW9uIHRvIGludGVyY2VwdFxuICAgICAgICogdGV4dENvbnRlbnQgYmluZGluZ3Mgd2hpbGUgY2hpbGRyZW4gYXJlIFwiaGlkZGVuXCIgYW5kIGNhY2hlIGluXG4gICAgICAgKiBwcml2YXRlIHN0b3JhZ2UgZm9yIGxhdGVyIHJldHJpZXZhbC5cbiAgICAgICAqXG4gICAgICAgKiBAb3ZlcnJpZGVcbiAgICAgICAqL1xuICAgICAgX3NldFVubWFuYWdlZFByb3BlcnR5VG9Ob2RlKG5vZGUsIHByb3AsIHZhbHVlKSB7XG4gICAgICAgIGlmIChub2RlLl9faGlkZVRlbXBsYXRlQ2hpbGRyZW5fXyAmJlxuICAgICAgICAgICAgbm9kZS5ub2RlVHlwZSA9PSBOb2RlLlRFWFRfTk9ERSAmJiBwcm9wID09ICd0ZXh0Q29udGVudCcpIHtcbiAgICAgICAgICBub2RlLl9fcG9seW1lclRleHRDb250ZW50X18gPSB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdXBlci5fc2V0VW5tYW5hZ2VkUHJvcGVydHlUb05vZGUobm9kZSwgcHJvcCwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIEZpbmQgdGhlIHBhcmVudCBtb2RlbCBvZiB0aGlzIHRlbXBsYXRlIGluc3RhbmNlLiAgVGhlIHBhcmVudCBtb2RlbFxuICAgICAgICogaXMgZWl0aGVyIGFub3RoZXIgdGVtcGxhdGl6ZSBpbnN0YW5jZSB0aGF0IGhhZCBvcHRpb24gYHBhcmVudE1vZGVsOiB0cnVlYCxcbiAgICAgICAqIG9yIGVsc2UgdGhlIGhvc3QgZWxlbWVudC5cbiAgICAgICAqXG4gICAgICAgKiBAcmV0dXJuIHtQb2x5bWVyX1Byb3BlcnR5RWZmZWN0c30gVGhlIHBhcmVudCBtb2RlbCBvZiB0aGlzIGluc3RhbmNlXG4gICAgICAgKi9cbiAgICAgIGdldCBwYXJlbnRNb2RlbCgpIHtcbiAgICAgICAgbGV0IG1vZGVsID0gdGhpcy5fX3BhcmVudE1vZGVsO1xuICAgICAgICBpZiAoIW1vZGVsKSB7XG4gICAgICAgICAgbGV0IG9wdGlvbnM7XG4gICAgICAgICAgbW9kZWwgPSB0aGlzXG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgLy8gQSB0ZW1wbGF0ZSBpbnN0YW5jZSdzIGBfX2RhdGFIb3N0YCBpcyBhIDx0ZW1wbGF0ZT5cbiAgICAgICAgICAgIC8vIGBtb2RlbC5fX2RhdGFIb3N0Ll9fZGF0YUhvc3RgIGlzIHRoZSB0ZW1wbGF0ZSdzIGhvc3RcbiAgICAgICAgICAgIG1vZGVsID0gbW9kZWwuX19kYXRhSG9zdC5fX2RhdGFIb3N0O1xuICAgICAgICAgIH0gd2hpbGUgKChvcHRpb25zID0gbW9kZWwuX190ZW1wbGF0aXplT3B0aW9ucykgJiYgIW9wdGlvbnMucGFyZW50TW9kZWwpXG4gICAgICAgICAgdGhpcy5fX3BhcmVudE1vZGVsID0gbW9kZWw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1vZGVsO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBAdHlwZSB7IURhdGFUZW1wbGF0ZX0gKi9cbiAgICBUZW1wbGF0ZUluc3RhbmNlQmFzZS5wcm90b3R5cGUuX19kYXRhSG9zdDtcbiAgICAvKiogQHR5cGUgeyFUZW1wbGF0aXplT3B0aW9uc30gKi9cbiAgICBUZW1wbGF0ZUluc3RhbmNlQmFzZS5wcm90b3R5cGUuX190ZW1wbGF0aXplT3B0aW9ucztcbiAgICAvKiogQHR5cGUgeyFQb2x5bWVyX1Byb3BlcnR5RWZmZWN0c30gKi9cbiAgICBUZW1wbGF0ZUluc3RhbmNlQmFzZS5wcm90b3R5cGUuX21ldGhvZEhvc3Q7XG4gICAgLyoqIEB0eXBlIHshT2JqZWN0fSAqL1xuICAgIFRlbXBsYXRlSW5zdGFuY2VCYXNlLnByb3RvdHlwZS5fX3RlbXBsYXRpemVPd25lcjtcbiAgICAvKiogQHR5cGUgeyFPYmplY3R9ICovXG4gICAgVGVtcGxhdGVJbnN0YW5jZUJhc2UucHJvdG90eXBlLl9faG9zdFByb3BzO1xuXG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQGV4dGVuZHMge1RlbXBsYXRlSW5zdGFuY2VCYXNlfVxuICAgICAqIEBpbXBsZW1lbnRzIHtQb2x5bWVyX011dGFibGVEYXRhfVxuICAgICAqL1xuICAgIGNvbnN0IE11dGFibGVUZW1wbGF0ZUluc3RhbmNlQmFzZSA9IFBvbHltZXIuTXV0YWJsZURhdGEoVGVtcGxhdGVJbnN0YW5jZUJhc2UpO1xuXG4gICAgZnVuY3Rpb24gZmluZE1ldGhvZEhvc3QodGVtcGxhdGUpIHtcbiAgICAgIC8vIFRlY2huaWNhbGx5IHRoaXMgc2hvdWxkIGJlIHRoZSBvd25lciBvZiB0aGUgb3V0ZXJtb3N0IHRlbXBsYXRlLlxuICAgICAgLy8gSW4gc2hhZG93IGRvbSwgdGhpcyBpcyBhbHdheXMgZ2V0Um9vdE5vZGUoKS5ob3N0LCBidXQgd2UgY2FuXG4gICAgICAvLyBhcHByb3hpbWF0ZSB0aGlzIHZpYSBjb29wZXJhdGlvbiB3aXRoIG91ciBkYXRhSG9zdCBhbHdheXMgc2V0dGluZ1xuICAgICAgLy8gYF9tZXRob2RIb3N0YCBhcyBsb25nIGFzIHRoZXJlIHdlcmUgYmluZGluZ3MgKG9yIGlkJ3MpIG9uIHRoaXNcbiAgICAgIC8vIGluc3RhbmNlIGNhdXNpbmcgaXQgdG8gZ2V0IGEgZGF0YUhvc3QuXG4gICAgICBsZXQgdGVtcGxhdGVIb3N0ID0gdGVtcGxhdGUuX19kYXRhSG9zdDtcbiAgICAgIHJldHVybiB0ZW1wbGF0ZUhvc3QgJiYgdGVtcGxhdGVIb3N0Ll9tZXRob2RIb3N0IHx8IHRlbXBsYXRlSG9zdDtcbiAgICB9XG5cbiAgICAvKiBlc2xpbnQtZGlzYWJsZSB2YWxpZC1qc2RvYyAqL1xuICAgIC8qKlxuICAgICAqIEBzdXBwcmVzcyB7bWlzc2luZ1Byb3BlcnRpZXN9IGNsYXNzLnByb3RvdHlwZSBpcyBub3QgZGVmaW5lZCBmb3Igc29tZSByZWFzb25cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVUZW1wbGF0aXplckNsYXNzKHRlbXBsYXRlLCB0ZW1wbGF0ZUluZm8sIG9wdGlvbnMpIHtcbiAgICAgIC8vIEFub255bW91cyBjbGFzcyBjcmVhdGVkIGJ5IHRoZSB0ZW1wbGF0aXplXG4gICAgICBsZXQgYmFzZSA9IG9wdGlvbnMubXV0YWJsZURhdGEgP1xuICAgICAgICBNdXRhYmxlVGVtcGxhdGVJbnN0YW5jZUJhc2UgOiBUZW1wbGF0ZUluc3RhbmNlQmFzZTtcbiAgICAgIC8qKlxuICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgKiBAZXh0ZW5kcyB7YmFzZX1cbiAgICAgICAqL1xuICAgICAgbGV0IGtsYXNzID0gY2xhc3MgZXh0ZW5kcyBiYXNlIHsgfVxuICAgICAga2xhc3MucHJvdG90eXBlLl9fdGVtcGxhdGl6ZU9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAga2xhc3MucHJvdG90eXBlLl9iaW5kVGVtcGxhdGUodGVtcGxhdGUpO1xuICAgICAgYWRkTm90aWZ5RWZmZWN0cyhrbGFzcywgdGVtcGxhdGUsIHRlbXBsYXRlSW5mbywgb3B0aW9ucyk7XG4gICAgICByZXR1cm4ga2xhc3M7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHN1cHByZXNzIHttaXNzaW5nUHJvcGVydGllc30gY2xhc3MucHJvdG90eXBlIGlzIG5vdCBkZWZpbmVkIGZvciBzb21lIHJlYXNvblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFkZFByb3BhZ2F0ZUVmZmVjdHModGVtcGxhdGUsIHRlbXBsYXRlSW5mbywgb3B0aW9ucykge1xuICAgICAgbGV0IHVzZXJGb3J3YXJkSG9zdFByb3AgPSBvcHRpb25zLmZvcndhcmRIb3N0UHJvcDtcbiAgICAgIGlmICh1c2VyRm9yd2FyZEhvc3RQcm9wKSB7XG4gICAgICAgIC8vIFByb3ZpZGUgZGF0YSBBUEkgYW5kIHByb3BlcnR5IGVmZmVjdHMgb24gbWVtb2l6ZWQgdGVtcGxhdGUgY2xhc3NcbiAgICAgICAgbGV0IGtsYXNzID0gdGVtcGxhdGVJbmZvLnRlbXBsYXRpemVUZW1wbGF0ZUNsYXNzO1xuICAgICAgICBpZiAoIWtsYXNzKSB7XG4gICAgICAgICAgbGV0IGJhc2UgPSBvcHRpb25zLm11dGFibGVEYXRhID8gTXV0YWJsZURhdGFUZW1wbGF0ZSA6IERhdGFUZW1wbGF0ZTtcbiAgICAgICAgICBrbGFzcyA9IHRlbXBsYXRlSW5mby50ZW1wbGF0aXplVGVtcGxhdGVDbGFzcyA9XG4gICAgICAgICAgICBjbGFzcyBUZW1wbGF0aXplZFRlbXBsYXRlIGV4dGVuZHMgYmFzZSB7fVxuICAgICAgICAgIC8vIEFkZCB0ZW1wbGF0ZSAtID5pbnN0YW5jZXMgZWZmZWN0c1xuICAgICAgICAgIC8vIGFuZCBob3N0IDwtIHRlbXBsYXRlIGVmZmVjdHNcbiAgICAgICAgICBsZXQgaG9zdFByb3BzID0gdGVtcGxhdGVJbmZvLmhvc3RQcm9wcztcbiAgICAgICAgICBmb3IgKGxldCBwcm9wIGluIGhvc3RQcm9wcykge1xuICAgICAgICAgICAga2xhc3MucHJvdG90eXBlLl9hZGRQcm9wZXJ0eUVmZmVjdCgnX2hvc3RfJyArIHByb3AsXG4gICAgICAgICAgICAgIGtsYXNzLnByb3RvdHlwZS5QUk9QRVJUWV9FRkZFQ1RfVFlQRVMuUFJPUEFHQVRFLFxuICAgICAgICAgICAgICB7Zm46IGNyZWF0ZUZvcndhcmRIb3N0UHJvcEVmZmVjdChwcm9wLCB1c2VyRm9yd2FyZEhvc3RQcm9wKX0pO1xuICAgICAgICAgICAga2xhc3MucHJvdG90eXBlLl9jcmVhdGVOb3RpZnlpbmdQcm9wZXJ0eSgnX2hvc3RfJyArIHByb3ApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB1cGdyYWRlVGVtcGxhdGUodGVtcGxhdGUsIGtsYXNzKTtcbiAgICAgICAgLy8gTWl4IGFueSBwcmUtYm91bmQgZGF0YSBpbnRvIF9fZGF0YTsgbm8gbmVlZCB0byBmbHVzaCB0aGlzIHRvXG4gICAgICAgIC8vIGluc3RhbmNlcyBzaW5jZSB0aGV5IHB1bGwgZnJvbSB0aGUgdGVtcGxhdGUgYXQgaW5zdGFuY2UtdGltZVxuICAgICAgICBpZiAodGVtcGxhdGUuX19kYXRhUHJvdG8pIHtcbiAgICAgICAgICAvLyBOb3RlLCBnZW5lcmFsbHkgYF9fZGF0YVByb3RvYCBjb3VsZCBiZSBjaGFpbmVkLCBidXQgaXQncyBndWFyYW50ZWVkXG4gICAgICAgICAgLy8gdG8gbm90IGJlIHNpbmNlIHRoaXMgaXMgYSB2YW5pbGxhIHRlbXBsYXRlIHdlIGp1c3QgYWRkZWQgZWZmZWN0cyB0b1xuICAgICAgICAgIE9iamVjdC5hc3NpZ24odGVtcGxhdGUuX19kYXRhLCB0ZW1wbGF0ZS5fX2RhdGFQcm90byk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2xlYXIgYW55IHBlbmRpbmcgZGF0YSBmb3IgcGVyZm9ybWFuY2VcbiAgICAgICAgdGVtcGxhdGUuX19kYXRhVGVtcCA9IHt9O1xuICAgICAgICB0ZW1wbGF0ZS5fX2RhdGFQZW5kaW5nID0gbnVsbDtcbiAgICAgICAgdGVtcGxhdGUuX19kYXRhT2xkID0gbnVsbDtcbiAgICAgICAgdGVtcGxhdGUuX2VuYWJsZVByb3BlcnRpZXMoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyogZXNsaW50LWVuYWJsZSB2YWxpZC1qc2RvYyAqL1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlRm9yd2FyZEhvc3RQcm9wRWZmZWN0KGhvc3RQcm9wLCB1c2VyRm9yd2FyZEhvc3RQcm9wKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gZm9yd2FyZEhvc3RQcm9wKHRlbXBsYXRlLCBwcm9wLCBwcm9wcykge1xuICAgICAgICB1c2VyRm9yd2FyZEhvc3RQcm9wLmNhbGwodGVtcGxhdGUuX190ZW1wbGF0aXplT3duZXIsXG4gICAgICAgICAgcHJvcC5zdWJzdHJpbmcoJ19ob3N0XycubGVuZ3RoKSwgcHJvcHNbcHJvcF0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZE5vdGlmeUVmZmVjdHMoa2xhc3MsIHRlbXBsYXRlLCB0ZW1wbGF0ZUluZm8sIG9wdGlvbnMpIHtcbiAgICAgIGxldCBob3N0UHJvcHMgPSB0ZW1wbGF0ZUluZm8uaG9zdFByb3BzIHx8IHt9O1xuICAgICAgZm9yIChsZXQgaXByb3AgaW4gb3B0aW9ucy5pbnN0YW5jZVByb3BzKSB7XG4gICAgICAgIGRlbGV0ZSBob3N0UHJvcHNbaXByb3BdO1xuICAgICAgICBsZXQgdXNlck5vdGlmeUluc3RhbmNlUHJvcCA9IG9wdGlvbnMubm90aWZ5SW5zdGFuY2VQcm9wO1xuICAgICAgICBpZiAodXNlck5vdGlmeUluc3RhbmNlUHJvcCkge1xuICAgICAgICAgIGtsYXNzLnByb3RvdHlwZS5fYWRkUHJvcGVydHlFZmZlY3QoaXByb3AsXG4gICAgICAgICAgICBrbGFzcy5wcm90b3R5cGUuUFJPUEVSVFlfRUZGRUNUX1RZUEVTLk5PVElGWSxcbiAgICAgICAgICAgIHtmbjogY3JlYXRlTm90aWZ5SW5zdGFuY2VQcm9wRWZmZWN0KGlwcm9wLCB1c2VyTm90aWZ5SW5zdGFuY2VQcm9wKX0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5mb3J3YXJkSG9zdFByb3AgJiYgdGVtcGxhdGUuX19kYXRhSG9zdCkge1xuICAgICAgICBmb3IgKGxldCBocHJvcCBpbiBob3N0UHJvcHMpIHtcbiAgICAgICAgICBrbGFzcy5wcm90b3R5cGUuX2FkZFByb3BlcnR5RWZmZWN0KGhwcm9wLFxuICAgICAgICAgICAga2xhc3MucHJvdG90eXBlLlBST1BFUlRZX0VGRkVDVF9UWVBFUy5OT1RJRlksXG4gICAgICAgICAgICB7Zm46IGNyZWF0ZU5vdGlmeUhvc3RQcm9wRWZmZWN0KCl9KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlTm90aWZ5SW5zdGFuY2VQcm9wRWZmZWN0KGluc3RQcm9wLCB1c2VyTm90aWZ5SW5zdGFuY2VQcm9wKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gbm90aWZ5SW5zdGFuY2VQcm9wKGluc3QsIHByb3AsIHByb3BzKSB7XG4gICAgICAgIHVzZXJOb3RpZnlJbnN0YW5jZVByb3AuY2FsbChpbnN0Ll9fdGVtcGxhdGl6ZU93bmVyLFxuICAgICAgICAgIGluc3QsIHByb3AsIHByb3BzW3Byb3BdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVOb3RpZnlIb3N0UHJvcEVmZmVjdCgpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiBub3RpZnlIb3N0UHJvcChpbnN0LCBwcm9wLCBwcm9wcykge1xuICAgICAgICBpbnN0Ll9fZGF0YUhvc3QuX3NldFBlbmRpbmdQcm9wZXJ0eU9yUGF0aCgnX2hvc3RfJyArIHByb3AsIHByb3BzW3Byb3BdLCB0cnVlLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNb2R1bGUgZm9yIHByZXBhcmluZyBhbmQgc3RhbXBpbmcgaW5zdGFuY2VzIG9mIHRlbXBsYXRlcyB0aGF0IHV0aWxpemVcbiAgICAgKiBQb2x5bWVyJ3MgZGF0YS1iaW5kaW5nIGFuZCBkZWNsYXJhdGl2ZSBldmVudCBsaXN0ZW5lciBmZWF0dXJlcy5cbiAgICAgKlxuICAgICAqIEV4YW1wbGU6XG4gICAgICpcbiAgICAgKiAgICAgLy8gR2V0IGEgdGVtcGxhdGUgZnJvbSBzb21ld2hlcmUsIGUuZy4gbGlnaHQgRE9NXG4gICAgICogICAgIGxldCB0ZW1wbGF0ZSA9IHRoaXMucXVlcnlTZWxlY3RvcigndGVtcGxhdGUnKTtcbiAgICAgKiAgICAgLy8gUHJlcGFyZSB0aGUgdGVtcGxhdGVcbiAgICAgKiAgICAgbGV0IFRlbXBsYXRlQ2xhc3MgPSBQb2x5bWVyLlRlbXBsYXRpemUudGVtcGxhdGl6ZSh0ZW1wbGF0ZSk7XG4gICAgICogICAgIC8vIEluc3RhbmNlIHRoZSB0ZW1wbGF0ZSB3aXRoIGFuIGluaXRpYWwgZGF0YSBtb2RlbFxuICAgICAqICAgICBsZXQgaW5zdGFuY2UgPSBuZXcgVGVtcGxhdGVDbGFzcyh7bXlQcm9wOiAnaW5pdGlhbCd9KTtcbiAgICAgKiAgICAgLy8gSW5zZXJ0IHRoZSBpbnN0YW5jZSdzIERPTSBzb21ld2hlcmUsIGUuZy4gZWxlbWVudCdzIHNoYWRvdyBET01cbiAgICAgKiAgICAgdGhpcy5zaGFkb3dSb290LmFwcGVuZENoaWxkKGluc3RhbmNlLnJvb3QpO1xuICAgICAqICAgICAvLyBDaGFuZ2luZyBhIHByb3BlcnR5IG9uIHRoZSBpbnN0YW5jZSB3aWxsIHByb3BhZ2F0ZSB0byBiaW5kaW5nc1xuICAgICAqICAgICAvLyBpbiB0aGUgdGVtcGxhdGVcbiAgICAgKiAgICAgaW5zdGFuY2UubXlQcm9wID0gJ25ldyB2YWx1ZSc7XG4gICAgICpcbiAgICAgKiBUaGUgYG9wdGlvbnNgIGRpY3Rpb25hcnkgcGFzc2VkIHRvIGB0ZW1wbGF0aXplYCBhbGxvd3MgZm9yIGN1c3RvbWl6aW5nXG4gICAgICogZmVhdHVyZXMgb2YgdGhlIGdlbmVyYXRlZCB0ZW1wbGF0ZSBjbGFzcywgaW5jbHVkaW5nIGhvdyBvdXRlci1zY29wZSBob3N0XG4gICAgICogcHJvcGVydGllcyBzaG91bGQgYmUgZm9yd2FyZGVkIGludG8gdGVtcGxhdGUgaW5zdGFuY2VzLCBob3cgYW55IGluc3RhbmNlXG4gICAgICogcHJvcGVydGllcyBhZGRlZCBpbnRvIHRoZSB0ZW1wbGF0ZSdzIHNjb3BlIHNob3VsZCBiZSBub3RpZmllZCBvdXQgdG9cbiAgICAgKiB0aGUgaG9zdCwgYW5kIHdoZXRoZXIgdGhlIGluc3RhbmNlIHNob3VsZCBiZSBkZWNvcmF0ZWQgYXMgYSBcInBhcmVudCBtb2RlbFwiXG4gICAgICogb2YgYW55IGV2ZW50IGhhbmRsZXJzLlxuICAgICAqXG4gICAgICogICAgIC8vIEN1c3RvbXplIHByb3BlcnR5IGZvcndhcmRpbmcgYW5kIGV2ZW50IG1vZGVsIGRlY29yYXRpb25cbiAgICAgKiAgICAgbGV0IFRlbXBsYXRlQ2xhc3MgPSBQb2x5bWVyLlRlbXBsYXRpemUudGVtcGxhdGl6ZSh0ZW1wbGF0ZSwgdGhpcywge1xuICAgICAqICAgICAgIHBhcmVudE1vZGVsOiB0cnVlLFxuICAgICAqICAgICAgIGluc3RhbmNlUHJvcHM6IHsuLi59LFxuICAgICAqICAgICAgIGZvcndhcmRIb3N0UHJvcChwcm9wZXJ0eSwgdmFsdWUpIHsuLi59LFxuICAgICAqICAgICAgIG5vdGlmeUluc3RhbmNlUHJvcChpbnN0YW5jZSwgcHJvcGVydHksIHZhbHVlKSB7Li4ufSxcbiAgICAgKiAgICAgfSk7XG4gICAgICpcbiAgICAgKlxuICAgICAqIEBuYW1lc3BhY2VcbiAgICAgKiBAbWVtYmVyb2YgUG9seW1lclxuICAgICAqIEBzdW1tYXJ5IE1vZHVsZSBmb3IgcHJlcGFyaW5nIGFuZCBzdGFtcGluZyBpbnN0YW5jZXMgb2YgdGVtcGxhdGVzXG4gICAgICogICB1dGlsaXppbmcgUG9seW1lciB0ZW1wbGF0aW5nIGZlYXR1cmVzLlxuICAgICAqL1xuXG4gICAgY29uc3QgVGVtcGxhdGl6ZSA9IHtcblxuICAgICAgLyoqXG4gICAgICAgKiBSZXR1cm5zIGFuIGFub255bW91cyBgUG9seW1lci5Qcm9wZXJ0eUVmZmVjdHNgIGNsYXNzIGJvdW5kIHRvIHRoZVxuICAgICAgICogYDx0ZW1wbGF0ZT5gIHByb3ZpZGVkLiAgSW5zdGFuY2luZyB0aGUgY2xhc3Mgd2lsbCByZXN1bHQgaW4gdGhlXG4gICAgICAgKiB0ZW1wbGF0ZSBiZWluZyBzdGFtcGVkIGludG8gZG9jdW1lbnQgZnJhZ21lbnQgc3RvcmVkIGFzIHRoZSBpbnN0YW5jZSdzXG4gICAgICAgKiBgcm9vdGAgcHJvcGVydHksIGFmdGVyIHdoaWNoIGl0IGNhbiBiZSBhcHBlbmRlZCB0byB0aGUgRE9NLlxuICAgICAgICpcbiAgICAgICAqIFRlbXBsYXRlcyBtYXkgdXRpbGl6ZSBhbGwgUG9seW1lciBkYXRhLWJpbmRpbmcgZmVhdHVyZXMgYXMgd2VsbCBhc1xuICAgICAgICogZGVjbGFyYXRpdmUgZXZlbnQgbGlzdGVuZXJzLiAgRXZlbnQgbGlzdGVuZXJzIGFuZCBpbmxpbmUgY29tcHV0aW5nXG4gICAgICAgKiBmdW5jdGlvbnMgaW4gdGhlIHRlbXBsYXRlIHdpbGwgYmUgY2FsbGVkIG9uIHRoZSBob3N0IG9mIHRoZSB0ZW1wbGF0ZS5cbiAgICAgICAqXG4gICAgICAgKiBUaGUgY29uc3RydWN0b3IgcmV0dXJuZWQgdGFrZXMgYSBzaW5nbGUgYXJndW1lbnQgZGljdGlvbmFyeSBvZiBpbml0aWFsXG4gICAgICAgKiBwcm9wZXJ0eSB2YWx1ZXMgdG8gcHJvcGFnYXRlIGludG8gdGVtcGxhdGUgYmluZGluZ3MuICBBZGRpdGlvbmFsbHlcbiAgICAgICAqIGhvc3QgcHJvcGVydGllcyBjYW4gYmUgZm9yd2FyZGVkIGluLCBhbmQgaW5zdGFuY2UgcHJvcGVydGllcyBjYW4gYmVcbiAgICAgICAqIG5vdGlmaWVkIG91dCBieSBwcm92aWRpbmcgb3B0aW9uYWwgY2FsbGJhY2tzIGluIHRoZSBgb3B0aW9uc2AgZGljdGlvbmFyeS5cbiAgICAgICAqXG4gICAgICAgKiBWYWxpZCBjb25maWd1cmF0aW9uIGluIGBvcHRpb25zYCBhcmUgYXMgZm9sbG93czpcbiAgICAgICAqXG4gICAgICAgKiAtIGBmb3J3YXJkSG9zdFByb3AocHJvcGVydHksIHZhbHVlKWA6IENhbGxlZCB3aGVuIGEgcHJvcGVydHkgcmVmZXJlbmNlZFxuICAgICAgICogICBpbiB0aGUgdGVtcGxhdGUgY2hhbmdlZCBvbiB0aGUgdGVtcGxhdGUncyBob3N0LiBBcyB0aGlzIGxpYnJhcnkgZG9lc1xuICAgICAgICogICBub3QgcmV0YWluIHJlZmVyZW5jZXMgdG8gdGVtcGxhdGVzIGluc3RhbmNlZCBieSB0aGUgdXNlciwgaXQgaXMgdGhlXG4gICAgICAgKiAgIHRlbXBsYXRpemUgb3duZXIncyByZXNwb25zaWJpbGl0eSB0byBmb3J3YXJkIGhvc3QgcHJvcGVydHkgY2hhbmdlcyBpbnRvXG4gICAgICAgKiAgIHVzZXItc3RhbXBlZCBpbnN0YW5jZXMuICBUaGUgYGluc3RhbmNlLmZvcndhcmRIb3N0UHJvcChwcm9wZXJ0eSwgdmFsdWUpYFxuICAgICAgICogICAgbWV0aG9kIG9uIHRoZSBnZW5lcmF0ZWQgY2xhc3Mgc2hvdWxkIGJlIGNhbGxlZCB0byBmb3J3YXJkIGhvc3RcbiAgICAgICAqICAgcHJvcGVydGllcyBpbnRvIHRoZSB0ZW1wbGF0ZSB0byBwcmV2ZW50IHVubmVjZXNzYXJ5IHByb3BlcnR5LWNoYW5nZWRcbiAgICAgICAqICAgbm90aWZpY2F0aW9ucy4gQW55IHByb3BlcnRpZXMgcmVmZXJlbmNlZCBpbiB0aGUgdGVtcGxhdGUgdGhhdCBhcmUgbm90XG4gICAgICAgKiAgIGRlZmluZWQgaW4gYGluc3RhbmNlUHJvcHNgIHdpbGwgYmUgbm90aWZpZWQgdXAgdG8gdGhlIHRlbXBsYXRlJ3MgaG9zdFxuICAgICAgICogICBhdXRvbWF0aWNhbGx5LlxuICAgICAgICogLSBgaW5zdGFuY2VQcm9wc2A6IERpY3Rpb25hcnkgb2YgcHJvcGVydHkgbmFtZXMgdGhhdCB3aWxsIGJlIGFkZGVkXG4gICAgICAgKiAgIHRvIHRoZSBpbnN0YW5jZSBieSB0aGUgdGVtcGxhdGl6ZSBvd25lci4gIFRoZXNlIHByb3BlcnRpZXMgc2hhZG93IGFueVxuICAgICAgICogICBob3N0IHByb3BlcnRpZXMsIGFuZCBjaGFuZ2VzIHdpdGhpbiB0aGUgdGVtcGxhdGUgdG8gdGhlc2UgcHJvcGVydGllc1xuICAgICAgICogICB3aWxsIHJlc3VsdCBpbiBgbm90aWZ5SW5zdGFuY2VQcm9wYCBiZWluZyBjYWxsZWQuXG4gICAgICAgKiAtIGBtdXRhYmxlRGF0YWA6IFdoZW4gYHRydWVgLCB0aGUgZ2VuZXJhdGVkIGNsYXNzIHdpbGwgc2tpcCBzdHJpY3RcbiAgICAgICAqICAgZGlydHktY2hlY2tpbmcgZm9yIG9iamVjdHMgYW5kIGFycmF5cyAoYWx3YXlzIGNvbnNpZGVyIHRoZW0gdG8gYmVcbiAgICAgICAqICAgXCJkaXJ0eVwiKS5cbiAgICAgICAqIC0gYG5vdGlmeUluc3RhbmNlUHJvcChpbnN0YW5jZSwgcHJvcGVydHksIHZhbHVlKWA6IENhbGxlZCB3aGVuXG4gICAgICAgKiAgIGFuIGluc3RhbmNlIHByb3BlcnR5IGNoYW5nZXMuICBVc2VycyBtYXkgY2hvb3NlIHRvIGNhbGwgYG5vdGlmeVBhdGhgXG4gICAgICAgKiAgIG9uIGUuZy4gdGhlIG93bmVyIHRvIG5vdGlmeSB0aGUgY2hhbmdlLlxuICAgICAgICogLSBgcGFyZW50TW9kZWxgOiBXaGVuIGB0cnVlYCwgZXZlbnRzIGhhbmRsZWQgYnkgZGVjbGFyYXRpdmUgZXZlbnQgbGlzdGVuZXJzXG4gICAgICAgKiAgIChgb24tZXZlbnQ9XCJoYW5kbGVyXCJgKSB3aWxsIGJlIGRlY29yYXRlZCB3aXRoIGEgYG1vZGVsYCBwcm9wZXJ0eSBwb2ludGluZ1xuICAgICAgICogICB0byB0aGUgdGVtcGxhdGUgaW5zdGFuY2UgdGhhdCBzdGFtcGVkIGl0LiAgSXQgd2lsbCBhbHNvIGJlIHJldHVybmVkXG4gICAgICAgKiAgIGZyb20gYGluc3RhbmNlLnBhcmVudE1vZGVsYCBpbiBjYXNlcyB3aGVyZSB0ZW1wbGF0ZSBpbnN0YW5jZSBuZXN0aW5nXG4gICAgICAgKiAgIGNhdXNlcyBhbiBpbm5lciBtb2RlbCB0byBzaGFkb3cgYW4gb3V0ZXIgbW9kZWwuXG4gICAgICAgKlxuICAgICAgICogTm90ZSB0aGF0IHRoZSBjbGFzcyByZXR1cm5lZCBmcm9tIGB0ZW1wbGF0aXplYCBpcyBnZW5lcmF0ZWQgb25seSBvbmNlXG4gICAgICAgKiBmb3IgYSBnaXZlbiBgPHRlbXBsYXRlPmAgdXNpbmcgYG9wdGlvbnNgIGZyb20gdGhlIGZpcnN0IGNhbGwgZm9yIHRoYXRcbiAgICAgICAqIHRlbXBsYXRlLCBhbmQgdGhlIGNhY2hlZCBjbGFzcyBpcyByZXR1cm5lZCBmb3IgYWxsIHN1YnNlcXVlbnQgY2FsbHMgdG9cbiAgICAgICAqIGB0ZW1wbGF0aXplYCBmb3IgdGhhdCB0ZW1wbGF0ZS4gIEFzIHN1Y2gsIGBvcHRpb25zYCBjYWxsYmFja3Mgc2hvdWxkIG5vdFxuICAgICAgICogY2xvc2Ugb3ZlciBvd25lci1zcGVjaWZpYyBwcm9wZXJ0aWVzIHNpbmNlIG9ubHkgdGhlIGZpcnN0IGBvcHRpb25zYCBpc1xuICAgICAgICogdXNlZDsgcmF0aGVyLCBjYWxsYmFja3MgYXJlIGNhbGxlZCBib3VuZCB0byB0aGUgYG93bmVyYCwgYW5kIHNvIGNvbnRleHRcbiAgICAgICAqIG5lZWRlZCBmcm9tIHRoZSBjYWxsYmFja3MgKHN1Y2ggYXMgcmVmZXJlbmNlcyB0byBgaW5zdGFuY2VzYCBzdGFtcGVkKVxuICAgICAgICogc2hvdWxkIGJlIHN0b3JlZCBvbiB0aGUgYG93bmVyYCBzdWNoIHRoYXQgdGhleSBjYW4gYmUgcmV0cmlldmVkIHZpYSBgdGhpc2AuXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlcm9mIFBvbHltZXIuVGVtcGxhdGl6ZVxuICAgICAgICogQHBhcmFtIHshSFRNTFRlbXBsYXRlRWxlbWVudH0gdGVtcGxhdGUgVGVtcGxhdGUgdG8gdGVtcGxhdGl6ZVxuICAgICAgICogQHBhcmFtIHshUG9seW1lcl9Qcm9wZXJ0eUVmZmVjdHN9IG93bmVyIE93bmVyIG9mIHRoZSB0ZW1wbGF0ZSBpbnN0YW5jZXM7XG4gICAgICAgKiAgIGFueSBvcHRpb25hbCBjYWxsYmFja3Mgd2lsbCBiZSBib3VuZCB0byB0aGlzIG93bmVyLlxuICAgICAgICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zIE9wdGlvbnMgZGljdGlvbmFyeSAoc2VlIHN1bW1hcnkgZm9yIGRldGFpbHMpXG4gICAgICAgKiBAcmV0dXJuIHtmdW5jdGlvbihuZXc6VGVtcGxhdGVJbnN0YW5jZUJhc2UpfSBHZW5lcmF0ZWQgY2xhc3MgYm91bmQgdG8gdGhlIHRlbXBsYXRlXG4gICAgICAgKiAgIHByb3ZpZGVkXG4gICAgICAgKiBAc3VwcHJlc3Mge2ludmFsaWRDYXN0c31cbiAgICAgICAqL1xuICAgICAgdGVtcGxhdGl6ZSh0ZW1wbGF0ZSwgb3duZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IC8qKiBAdHlwZSB7IVRlbXBsYXRpemVPcHRpb25zfSAqLyhvcHRpb25zIHx8IHt9KTtcbiAgICAgICAgaWYgKHRlbXBsYXRlLl9fdGVtcGxhdGl6ZU93bmVyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBIDx0ZW1wbGF0ZT4gY2FuIG9ubHkgYmUgdGVtcGxhdGl6ZWQgb25jZScpO1xuICAgICAgICB9XG4gICAgICAgIHRlbXBsYXRlLl9fdGVtcGxhdGl6ZU93bmVyID0gb3duZXI7XG4gICAgICAgIGxldCB0ZW1wbGF0ZUluZm8gPSBvd25lci5jb25zdHJ1Y3Rvci5fcGFyc2VUZW1wbGF0ZSh0ZW1wbGF0ZSk7XG4gICAgICAgIC8vIEdldCBtZW1vaXplZCBiYXNlIGNsYXNzIGZvciB0aGUgcHJvdG90eXBpY2FsIHRlbXBsYXRlLCB3aGljaFxuICAgICAgICAvLyBpbmNsdWRlcyBwcm9wZXJ0eSBlZmZlY3RzIGZvciBiaW5kaW5nIHRlbXBsYXRlICYgZm9yd2FyZGluZ1xuICAgICAgICBsZXQgYmFzZUNsYXNzID0gdGVtcGxhdGVJbmZvLnRlbXBsYXRpemVJbnN0YW5jZUNsYXNzO1xuICAgICAgICBpZiAoIWJhc2VDbGFzcykge1xuICAgICAgICAgIGJhc2VDbGFzcyA9IGNyZWF0ZVRlbXBsYXRpemVyQ2xhc3ModGVtcGxhdGUsIHRlbXBsYXRlSW5mbywgb3B0aW9ucyk7XG4gICAgICAgICAgdGVtcGxhdGVJbmZvLnRlbXBsYXRpemVJbnN0YW5jZUNsYXNzID0gYmFzZUNsYXNzO1xuICAgICAgICB9XG4gICAgICAgIC8vIEhvc3QgcHJvcGVydHkgZm9yd2FyZGluZyBtdXN0IGJlIGluc3RhbGxlZCBvbnRvIHRlbXBsYXRlIGluc3RhbmNlXG4gICAgICAgIGFkZFByb3BhZ2F0ZUVmZmVjdHModGVtcGxhdGUsIHRlbXBsYXRlSW5mbywgb3B0aW9ucyk7XG4gICAgICAgIC8vIFN1YmNsYXNzIGJhc2UgY2xhc3MgYW5kIGFkZCByZWZlcmVuY2UgZm9yIHRoaXMgc3BlY2lmaWMgdGVtcGxhdGVcbiAgICAgICAgbGV0IGtsYXNzID0gY2xhc3MgVGVtcGxhdGVJbnN0YW5jZSBleHRlbmRzIGJhc2VDbGFzcyB7fTtcbiAgICAgICAga2xhc3MucHJvdG90eXBlLl9tZXRob2RIb3N0ID0gZmluZE1ldGhvZEhvc3QodGVtcGxhdGUpO1xuICAgICAgICBrbGFzcy5wcm90b3R5cGUuX19kYXRhSG9zdCA9IHRlbXBsYXRlO1xuICAgICAgICBrbGFzcy5wcm90b3R5cGUuX190ZW1wbGF0aXplT3duZXIgPSBvd25lcjtcbiAgICAgICAga2xhc3MucHJvdG90eXBlLl9faG9zdFByb3BzID0gdGVtcGxhdGVJbmZvLmhvc3RQcm9wcztcbiAgICAgICAgcmV0dXJuIC8qKiBAdHlwZSB7ZnVuY3Rpb24obmV3OlRlbXBsYXRlSW5zdGFuY2VCYXNlKX0gKi8oa2xhc3MpO1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBSZXR1cm5zIHRoZSB0ZW1wbGF0ZSBcIm1vZGVsXCIgYXNzb2NpYXRlZCB3aXRoIGEgZ2l2ZW4gZWxlbWVudCwgd2hpY2hcbiAgICAgICAqIHNlcnZlcyBhcyB0aGUgYmluZGluZyBzY29wZSBmb3IgdGhlIHRlbXBsYXRlIGluc3RhbmNlIHRoZSBlbGVtZW50IGlzXG4gICAgICAgKiBjb250YWluZWQgaW4uIEEgdGVtcGxhdGUgbW9kZWwgaXMgYW4gaW5zdGFuY2Ugb2ZcbiAgICAgICAqIGBUZW1wbGF0ZUluc3RhbmNlQmFzZWAsIGFuZCBzaG91bGQgYmUgdXNlZCB0byBtYW5pcHVsYXRlIGRhdGFcbiAgICAgICAqIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHRlbXBsYXRlIGluc3RhbmNlLlxuICAgICAgICpcbiAgICAgICAqIEV4YW1wbGU6XG4gICAgICAgKlxuICAgICAgICogICBsZXQgbW9kZWwgPSBtb2RlbEZvckVsZW1lbnQoZWwpO1xuICAgICAgICogICBpZiAobW9kZWwuaW5kZXggPCAxMCkge1xuICAgICAgICogICAgIG1vZGVsLnNldCgnaXRlbS5jaGVja2VkJywgdHJ1ZSk7XG4gICAgICAgKiAgIH1cbiAgICAgICAqXG4gICAgICAgKiBAbWVtYmVyb2YgUG9seW1lci5UZW1wbGF0aXplXG4gICAgICAgKiBAcGFyYW0ge0hUTUxUZW1wbGF0ZUVsZW1lbnR9IHRlbXBsYXRlIFRoZSBtb2RlbCB3aWxsIGJlIHJldHVybmVkIGZvclxuICAgICAgICogICBlbGVtZW50cyBzdGFtcGVkIGZyb20gdGhpcyB0ZW1wbGF0ZVxuICAgICAgICogQHBhcmFtIHtOb2RlfSBub2RlIE5vZGUgZm9yIHdoaWNoIHRvIHJldHVybiBhIHRlbXBsYXRlIG1vZGVsLlxuICAgICAgICogQHJldHVybiB7VGVtcGxhdGVJbnN0YW5jZUJhc2V9IFRlbXBsYXRlIGluc3RhbmNlIHJlcHJlc2VudGluZyB0aGVcbiAgICAgICAqICAgYmluZGluZyBzY29wZSBmb3IgdGhlIGVsZW1lbnRcbiAgICAgICAqL1xuICAgICAgbW9kZWxGb3JFbGVtZW50KHRlbXBsYXRlLCBub2RlKSB7XG4gICAgICAgIGxldCBtb2RlbDtcbiAgICAgICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgICAvLyBBbiBlbGVtZW50IHdpdGggYSBfX3RlbXBsYXRpemVJbnN0YW5jZSBtYXJrcyB0aGUgdG9wIGJvdW5kYXJ5XG4gICAgICAgICAgLy8gb2YgYSBzY29wZTsgd2FsayB1cCB1bnRpbCB3ZSBmaW5kIG9uZSwgYW5kIHRoZW4gZW5zdXJlIHRoYXRcbiAgICAgICAgICAvLyBpdHMgX19kYXRhSG9zdCBtYXRjaGVzIGB0aGlzYCwgbWVhbmluZyB0aGlzIGRvbS1yZXBlYXQgc3RhbXBlZCBpdFxuICAgICAgICAgIGlmICgobW9kZWwgPSBub2RlLl9fdGVtcGxhdGl6ZUluc3RhbmNlKSkge1xuICAgICAgICAgICAgLy8gRm91bmQgYW4gZWxlbWVudCBzdGFtcGVkIGJ5IGFub3RoZXIgdGVtcGxhdGU7IGtlZXAgd2Fsa2luZyB1cFxuICAgICAgICAgICAgLy8gZnJvbSBpdHMgX19kYXRhSG9zdFxuICAgICAgICAgICAgaWYgKG1vZGVsLl9fZGF0YUhvc3QgIT0gdGVtcGxhdGUpIHtcbiAgICAgICAgICAgICAgbm9kZSA9IG1vZGVsLl9fZGF0YUhvc3Q7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gbW9kZWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFN0aWxsIGluIGEgdGVtcGxhdGUgc2NvcGUsIGtlZXAgZ29pbmcgdXAgdW50aWxcbiAgICAgICAgICAgIC8vIGEgX190ZW1wbGF0aXplSW5zdGFuY2UgaXMgZm91bmRcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIFBvbHltZXIuVGVtcGxhdGl6ZSA9IFRlbXBsYXRpemU7XG4gICAgUG9seW1lci5UZW1wbGF0ZUluc3RhbmNlQmFzZSA9IFRlbXBsYXRlSW5zdGFuY2VCYXNlO1xuXG4gIH0pKCk7XG5cbjwvc2NyaXB0PlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi91dGlscy90ZW1wbGF0aXplLmh0bWwiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi8uLi9wb2x5bWVyL3BvbHltZXIuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uLy4uL2lyb24tcmVzaXphYmxlLWJlaGF2aW9yL2lyb24tcmVzaXphYmxlLWJlaGF2aW9yLmh0bWxcIj5cblxuPHNjcmlwdD5cblxuICAvKipcbiAgICogQHBvbHltZXJCZWhhdmlvciBQb2x5bWVyLkFwcExheW91dEJlaGF2aW9yXG4gICAqKi9cbiAgUG9seW1lci5BcHBMYXlvdXRCZWhhdmlvciA9IFtcbiAgICBQb2x5bWVyLklyb25SZXNpemFibGVCZWhhdmlvciwge1xuXG4gICAgbGlzdGVuZXJzOiB7XG4gICAgICAnYXBwLXJlc2V0LWxheW91dCc6ICdfYXBwUmVzZXRMYXlvdXRIYW5kbGVyJyxcbiAgICAgICdpcm9uLXJlc2l6ZSc6ICdyZXNldExheW91dCdcbiAgICB9LFxuXG4gICAgYXR0YWNoZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5maXJlKCdhcHAtcmVzZXQtbGF5b3V0Jyk7XG4gICAgfSxcblxuICAgIF9hcHBSZXNldExheW91dEhhbmRsZXI6IGZ1bmN0aW9uKGUpIHtcbiAgICAgIGlmIChQb2x5bWVyLmRvbShlKS5wYXRoWzBdID09PSB0aGlzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMucmVzZXRMYXlvdXQoKTtcbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfSxcblxuICAgIF91cGRhdGVMYXlvdXRTdGF0ZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgY29uc29sZS5lcnJvcigndW5pbXBsZW1lbnRlZCcpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXNldHMgdGhlIGxheW91dC4gSWYgeW91IGNoYW5nZWQgdGhlIHNpemUgb2YgdGhpcyBlbGVtZW50IHZpYSBDU1NcbiAgICAgKiB5b3UgY2FuIG5vdGlmeSB0aGUgY2hhbmdlcyBieSBlaXRoZXIgZmlyaW5nIHRoZSBgaXJvbi1yZXNpemVgIGV2ZW50XG4gICAgICogb3IgY2FsbGluZyBgcmVzZXRMYXlvdXRgIGRpcmVjdGx5LlxuICAgICAqXG4gICAgICogQG1ldGhvZCByZXNldExheW91dFxuICAgICAqL1xuICAgIHJlc2V0TGF5b3V0OiBmdW5jdGlvbigpIHtcbiAgICAgIC8vIFBvbHltZXIgdjIueFxuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIGNiID0gdGhpcy5fdXBkYXRlTGF5b3V0U3RhdGVzLmJpbmQodGhpcyk7XG4gICAgICBpZiAoUG9seW1lci5Bc3luYyAmJiBQb2x5bWVyLkFzeW5jLmFuaW1hdGlvbkZyYW1lKSB7XG4gICAgICAgIHRoaXMuX2xheW91dERlYm91bmNlciA9IFBvbHltZXIuRGVib3VuY2VyLmRlYm91bmNlKFxuICAgICAgICAgICAgdGhpcy5fbGF5b3V0RGVib3VuY2VyLFxuICAgICAgICAgICAgUG9seW1lci5Bc3luYy5hbmltYXRpb25GcmFtZSxcbiAgICAgICAgICAgIGNiKTtcbiAgICAgICAgUG9seW1lci5lbnF1ZXVlRGVib3VuY2VyKHRoaXMuX2xheW91dERlYm91bmNlcik7XG4gICAgICB9XG4gICAgICAvLyBQb2x5bWVyIHYxLnhcbiAgICAgIGVsc2Uge1xuICAgICAgICB0aGlzLmRlYm91bmNlKCdyZXNldExheW91dCcsIGNiKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX25vdGlmeURlc2NlbmRhbnRSZXNpemUoKTtcbiAgICB9LFxuXG4gICAgX25vdGlmeUxheW91dENoYW5nZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgLy8gVE9ETzogdGhlIGV2ZW50IGBhcHAtcmVzZXQtbGF5b3V0YCBjYW4gYmUgZmlyZWQgc3luY2hyb25vdXNseVxuICAgICAgLy8gYXMgbG9uZyBhcyBgX3VwZGF0ZUxheW91dFN0YXRlc2Agd2FpdHMgZm9yIGFsbCB0aGUgbWljcm90YXNrcyBhZnRlciByQUYuXG4gICAgICAvLyBFLmcuIHJlcXVlc3RBbmltYXRpb25GcmFtZShzZXRUaW1lT3V0KCkpXG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKSB7XG4gICAgICAgIHNlbGYuZmlyZSgnYXBwLXJlc2V0LWxheW91dCcpO1xuICAgICAgfSk7XG4gICAgfSxcblxuICAgIF9ub3RpZnlEZXNjZW5kYW50UmVzaXplOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5pc0F0dGFjaGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2ludGVyZXN0ZWRSZXNpemFibGVzLmZvckVhY2goZnVuY3Rpb24ocmVzaXphYmxlKSB7XG4gICAgICAgIGlmICh0aGlzLnJlc2l6ZXJTaG91bGROb3RpZnkocmVzaXphYmxlKSkge1xuICAgICAgICAgIHRoaXMuX25vdGlmeURlc2NlbmRhbnQocmVzaXphYmxlKTtcbiAgICAgICAgfVxuICAgICAgfSwgdGhpcyk7XG4gICAgfVxuICB9XTtcblxuPC9zY3JpcHQ+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL2FwcC1sYXlvdXQvYXBwLWxheW91dC1iZWhhdmlvci9hcHAtbGF5b3V0LWJlaGF2aW9yLmh0bWwiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE1IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi9wb2x5bWVyL3BvbHltZXIuaHRtbFwiPlxuXG48c2NyaXB0PlxuICAoZnVuY3Rpb24oKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgLyoqXG4gICAgICogQ2hyb21lIHVzZXMgYW4gb2xkZXIgdmVyc2lvbiBvZiBET00gTGV2ZWwgMyBLZXlib2FyZCBFdmVudHNcbiAgICAgKlxuICAgICAqIE1vc3Qga2V5cyBhcmUgbGFiZWxlZCBhcyB0ZXh0LCBidXQgc29tZSBhcmUgVW5pY29kZSBjb2RlcG9pbnRzLlxuICAgICAqIFZhbHVlcyB0YWtlbiBmcm9tOiBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDA3L1dELURPTS1MZXZlbC0zLUV2ZW50cy0yMDA3MTIyMS9rZXlzZXQuaHRtbCNLZXlTZXQtU2V0XG4gICAgICovXG4gICAgdmFyIEtFWV9JREVOVElGSUVSID0ge1xuICAgICAgJ1UrMDAwOCc6ICdiYWNrc3BhY2UnLFxuICAgICAgJ1UrMDAwOSc6ICd0YWInLFxuICAgICAgJ1UrMDAxQic6ICdlc2MnLFxuICAgICAgJ1UrMDAyMCc6ICdzcGFjZScsXG4gICAgICAnVSswMDdGJzogJ2RlbCdcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU3BlY2lhbCB0YWJsZSBmb3IgS2V5Ym9hcmRFdmVudC5rZXlDb2RlLlxuICAgICAqIEtleWJvYXJkRXZlbnQua2V5SWRlbnRpZmllciBpcyBiZXR0ZXIsIGFuZCBLZXlCb2FyZEV2ZW50LmtleSBpcyBldmVuIGJldHRlclxuICAgICAqIHRoYW4gdGhhdC5cbiAgICAgKlxuICAgICAqIFZhbHVlcyBmcm9tOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvS2V5Ym9hcmRFdmVudC5rZXlDb2RlI1ZhbHVlX29mX2tleUNvZGVcbiAgICAgKi9cbiAgICB2YXIgS0VZX0NPREUgPSB7XG4gICAgICA4OiAnYmFja3NwYWNlJyxcbiAgICAgIDk6ICd0YWInLFxuICAgICAgMTM6ICdlbnRlcicsXG4gICAgICAyNzogJ2VzYycsXG4gICAgICAzMzogJ3BhZ2V1cCcsXG4gICAgICAzNDogJ3BhZ2Vkb3duJyxcbiAgICAgIDM1OiAnZW5kJyxcbiAgICAgIDM2OiAnaG9tZScsXG4gICAgICAzMjogJ3NwYWNlJyxcbiAgICAgIDM3OiAnbGVmdCcsXG4gICAgICAzODogJ3VwJyxcbiAgICAgIDM5OiAncmlnaHQnLFxuICAgICAgNDA6ICdkb3duJyxcbiAgICAgIDQ2OiAnZGVsJyxcbiAgICAgIDEwNjogJyonXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIE1PRElGSUVSX0tFWVMgbWFwcyB0aGUgc2hvcnQgbmFtZSBmb3IgbW9kaWZpZXIga2V5cyB1c2VkIGluIGEga2V5XG4gICAgICogY29tYm8gc3RyaW5nIHRvIHRoZSBwcm9wZXJ0eSBuYW1lIHRoYXQgcmVmZXJlbmNlcyB0aG9zZSBzYW1lIGtleXNcbiAgICAgKiBpbiBhIEtleWJvYXJkRXZlbnQgaW5zdGFuY2UuXG4gICAgICovXG4gICAgdmFyIE1PRElGSUVSX0tFWVMgPSB7XG4gICAgICAnc2hpZnQnOiAnc2hpZnRLZXknLFxuICAgICAgJ2N0cmwnOiAnY3RybEtleScsXG4gICAgICAnYWx0JzogJ2FsdEtleScsXG4gICAgICAnbWV0YSc6ICdtZXRhS2V5J1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBLZXlib2FyZEV2ZW50LmtleSBpcyBtb3N0bHkgcmVwcmVzZW50ZWQgYnkgcHJpbnRhYmxlIGNoYXJhY3RlciBtYWRlIGJ5XG4gICAgICogdGhlIGtleWJvYXJkLCB3aXRoIHVucHJpbnRhYmxlIGtleXMgbGFiZWxlZCBuaWNlbHkuXG4gICAgICpcbiAgICAgKiBIb3dldmVyLCBvbiBPUyBYLCBBbHQrY2hhciBjYW4gbWFrZSBhIFVuaWNvZGUgY2hhcmFjdGVyIHRoYXQgZm9sbG93cyBhblxuICAgICAqIEFwcGxlLXNwZWNpZmljIG1hcHBpbmcuIEluIHRoaXMgY2FzZSwgd2UgZmFsbCBiYWNrIHRvIC5rZXlDb2RlLlxuICAgICAqL1xuICAgIHZhciBLRVlfQ0hBUiA9IC9bYS16MC05Kl0vO1xuXG4gICAgLyoqXG4gICAgICogTWF0Y2hlcyBhIGtleUlkZW50aWZpZXIgc3RyaW5nLlxuICAgICAqL1xuICAgIHZhciBJREVOVF9DSEFSID0gL1VcXCsvO1xuXG4gICAgLyoqXG4gICAgICogTWF0Y2hlcyBhcnJvdyBrZXlzIGluIEdlY2tvIDI3LjArXG4gICAgICovXG4gICAgdmFyIEFSUk9XX0tFWSA9IC9eYXJyb3cvO1xuXG4gICAgLyoqXG4gICAgICogTWF0Y2hlcyBzcGFjZSBrZXlzIGV2ZXJ5d2hlcmUgKG5vdGFibHkgaW5jbHVkaW5nIElFMTAncyBleGNlcHRpb25hbCBuYW1lXG4gICAgICogYHNwYWNlYmFyYCkuXG4gICAgICovXG4gICAgdmFyIFNQQUNFX0tFWSA9IC9ec3BhY2UoYmFyKT8vO1xuXG4gICAgLyoqXG4gICAgICogTWF0Y2hlcyBFU0Mga2V5LlxuICAgICAqXG4gICAgICogVmFsdWUgZnJvbTogaHR0cDovL3czYy5naXRodWIuaW8vdWlldmVudHMta2V5LyNrZXktRXNjYXBlXG4gICAgICovXG4gICAgdmFyIEVTQ19LRVkgPSAvXmVzY2FwZSQvO1xuXG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtcyB0aGUga2V5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIEtleUJvYXJkRXZlbnQua2V5XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbbm9TcGVjaWFsQ2hhcnNdIExpbWl0cyB0aGUgdHJhbnNmb3JtYXRpb24gdG9cbiAgICAgKiBhbHBoYS1udW1lcmljIGNoYXJhY3RlcnMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJhbnNmb3JtS2V5KGtleSwgbm9TcGVjaWFsQ2hhcnMpIHtcbiAgICAgIHZhciB2YWxpZEtleSA9ICcnO1xuICAgICAgaWYgKGtleSkge1xuICAgICAgICB2YXIgbEtleSA9IGtleS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAobEtleSA9PT0gJyAnIHx8IFNQQUNFX0tFWS50ZXN0KGxLZXkpKSB7XG4gICAgICAgICAgdmFsaWRLZXkgPSAnc3BhY2UnO1xuICAgICAgICB9IGVsc2UgaWYgKEVTQ19LRVkudGVzdChsS2V5KSkge1xuICAgICAgICAgIHZhbGlkS2V5ID0gJ2VzYyc7XG4gICAgICAgIH0gZWxzZSBpZiAobEtleS5sZW5ndGggPT0gMSkge1xuICAgICAgICAgIGlmICghbm9TcGVjaWFsQ2hhcnMgfHwgS0VZX0NIQVIudGVzdChsS2V5KSkge1xuICAgICAgICAgICAgdmFsaWRLZXkgPSBsS2V5O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChBUlJPV19LRVkudGVzdChsS2V5KSkge1xuICAgICAgICAgIHZhbGlkS2V5ID0gbEtleS5yZXBsYWNlKCdhcnJvdycsICcnKTtcbiAgICAgICAgfSBlbHNlIGlmIChsS2V5ID09ICdtdWx0aXBseScpIHtcbiAgICAgICAgICAvLyBudW1wYWQgJyonIGNhbiBtYXAgdG8gTXVsdGlwbHkgb24gSUUvV2luZG93c1xuICAgICAgICAgIHZhbGlkS2V5ID0gJyonO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbGlkS2V5ID0gbEtleTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbGlkS2V5O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRyYW5zZm9ybUtleUlkZW50aWZpZXIoa2V5SWRlbnQpIHtcbiAgICAgIHZhciB2YWxpZEtleSA9ICcnO1xuICAgICAgaWYgKGtleUlkZW50KSB7XG4gICAgICAgIGlmIChrZXlJZGVudCBpbiBLRVlfSURFTlRJRklFUikge1xuICAgICAgICAgIHZhbGlkS2V5ID0gS0VZX0lERU5USUZJRVJba2V5SWRlbnRdO1xuICAgICAgICB9IGVsc2UgaWYgKElERU5UX0NIQVIudGVzdChrZXlJZGVudCkpIHtcbiAgICAgICAgICBrZXlJZGVudCA9IHBhcnNlSW50KGtleUlkZW50LnJlcGxhY2UoJ1UrJywgJzB4JyksIDE2KTtcbiAgICAgICAgICB2YWxpZEtleSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoa2V5SWRlbnQpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsaWRLZXkgPSBrZXlJZGVudC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsaWRLZXk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdHJhbnNmb3JtS2V5Q29kZShrZXlDb2RlKSB7XG4gICAgICB2YXIgdmFsaWRLZXkgPSAnJztcbiAgICAgIGlmIChOdW1iZXIoa2V5Q29kZSkpIHtcbiAgICAgICAgaWYgKGtleUNvZGUgPj0gNjUgJiYga2V5Q29kZSA8PSA5MCkge1xuICAgICAgICAgIC8vIGFzY2lpIGEtelxuICAgICAgICAgIC8vIGxvd2VyY2FzZSBpcyAzMiBvZmZzZXQgZnJvbSB1cHBlcmNhc2VcbiAgICAgICAgICB2YWxpZEtleSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMzIgKyBrZXlDb2RlKTtcbiAgICAgICAgfSBlbHNlIGlmIChrZXlDb2RlID49IDExMiAmJiBrZXlDb2RlIDw9IDEyMykge1xuICAgICAgICAgIC8vIGZ1bmN0aW9uIGtleXMgZjEtZjEyXG4gICAgICAgICAgdmFsaWRLZXkgPSAnZicgKyAoa2V5Q29kZSAtIDExMiArIDEpO1xuICAgICAgICB9IGVsc2UgaWYgKGtleUNvZGUgPj0gNDggJiYga2V5Q29kZSA8PSA1Nykge1xuICAgICAgICAgIC8vIHRvcCAwLTkga2V5c1xuICAgICAgICAgIHZhbGlkS2V5ID0gU3RyaW5nKGtleUNvZGUgLSA0OCk7XG4gICAgICAgIH0gZWxzZSBpZiAoa2V5Q29kZSA+PSA5NiAmJiBrZXlDb2RlIDw9IDEwNSkge1xuICAgICAgICAgIC8vIG51bSBwYWQgMC05XG4gICAgICAgICAgdmFsaWRLZXkgPSBTdHJpbmcoa2V5Q29kZSAtIDk2KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWxpZEtleSA9IEtFWV9DT0RFW2tleUNvZGVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsaWRLZXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICAqIENhbGN1bGF0ZXMgdGhlIG5vcm1hbGl6ZWQga2V5IGZvciBhIEtleWJvYXJkRXZlbnQuXG4gICAgICAqIEBwYXJhbSB7S2V5Ym9hcmRFdmVudH0ga2V5RXZlbnRcbiAgICAgICogQHBhcmFtIHtCb29sZWFufSBbbm9TcGVjaWFsQ2hhcnNdIFNldCB0byB0cnVlIHRvIGxpbWl0IGtleUV2ZW50LmtleVxuICAgICAgKiB0cmFuc2Zvcm1hdGlvbiB0byBhbHBoYS1udW1lcmljIGNoYXJzLiBUaGlzIGlzIHVzZWZ1bCB3aXRoIGtleVxuICAgICAgKiBjb21iaW5hdGlvbnMgbGlrZSBzaGlmdCArIDIsIHdoaWNoIG9uIEZGIGZvciBNYWNPUyBwcm9kdWNlc1xuICAgICAgKiBrZXlFdmVudC5rZXkgPSBAXG4gICAgICAqIFRvIGdldCAyIHJldHVybmVkLCBzZXQgbm9TcGVjaWFsQ2hhcnMgPSB0cnVlXG4gICAgICAqIFRvIGdldCBAIHJldHVybmVkLCBzZXQgbm9TcGVjaWFsQ2hhcnMgPSBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZWRLZXlGb3JFdmVudChrZXlFdmVudCwgbm9TcGVjaWFsQ2hhcnMpIHtcbiAgICAgIC8vIEZhbGwgYmFjayBmcm9tIC5rZXksIHRvIC5kZXRhaWwua2V5IGZvciBhcnRpZmljYWwga2V5Ym9hcmQgZXZlbnRzLFxuICAgICAgLy8gYW5kIHRoZW4gdG8gZGVwcmVjYXRlZCAua2V5SWRlbnRpZmllciBhbmQgLmtleUNvZGUuXG4gICAgICBpZiAoa2V5RXZlbnQua2V5KSB7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1LZXkoa2V5RXZlbnQua2V5LCBub1NwZWNpYWxDaGFycyk7XG4gICAgICB9XG4gICAgICBpZiAoa2V5RXZlbnQuZGV0YWlsICYmIGtleUV2ZW50LmRldGFpbC5rZXkpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybUtleShrZXlFdmVudC5kZXRhaWwua2V5LCBub1NwZWNpYWxDaGFycyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJhbnNmb3JtS2V5SWRlbnRpZmllcihrZXlFdmVudC5rZXlJZGVudGlmaWVyKSB8fFxuICAgICAgICB0cmFuc2Zvcm1LZXlDb2RlKGtleUV2ZW50LmtleUNvZGUpIHx8ICcnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGtleUNvbWJvTWF0Y2hlc0V2ZW50KGtleUNvbWJvLCBldmVudCkge1xuICAgICAgLy8gRm9yIGNvbWJvcyB3aXRoIG1vZGlmaWVycyB3ZSBzdXBwb3J0IG9ubHkgYWxwaGEtbnVtZXJpYyBrZXlzXG4gICAgICB2YXIga2V5RXZlbnQgPSBub3JtYWxpemVkS2V5Rm9yRXZlbnQoZXZlbnQsIGtleUNvbWJvLmhhc01vZGlmaWVycyk7XG4gICAgICByZXR1cm4ga2V5RXZlbnQgPT09IGtleUNvbWJvLmtleSAmJlxuICAgICAgICAoIWtleUNvbWJvLmhhc01vZGlmaWVycyB8fCAoXG4gICAgICAgICAgISFldmVudC5zaGlmdEtleSA9PT0gISFrZXlDb21iby5zaGlmdEtleSAmJlxuICAgICAgICAgICEhZXZlbnQuY3RybEtleSA9PT0gISFrZXlDb21iby5jdHJsS2V5ICYmXG4gICAgICAgICAgISFldmVudC5hbHRLZXkgPT09ICEha2V5Q29tYm8uYWx0S2V5ICYmXG4gICAgICAgICAgISFldmVudC5tZXRhS2V5ID09PSAhIWtleUNvbWJvLm1ldGFLZXkpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VLZXlDb21ib1N0cmluZyhrZXlDb21ib1N0cmluZykge1xuICAgICAgaWYgKGtleUNvbWJvU3RyaW5nLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGNvbWJvOiBrZXlDb21ib1N0cmluZyxcbiAgICAgICAgICBrZXk6IGtleUNvbWJvU3RyaW5nLFxuICAgICAgICAgIGV2ZW50OiAna2V5ZG93bidcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBrZXlDb21ib1N0cmluZy5zcGxpdCgnKycpLnJlZHVjZShmdW5jdGlvbihwYXJzZWRLZXlDb21ibywga2V5Q29tYm9QYXJ0KSB7XG4gICAgICAgIHZhciBldmVudFBhcnRzID0ga2V5Q29tYm9QYXJ0LnNwbGl0KCc6Jyk7XG4gICAgICAgIHZhciBrZXlOYW1lID0gZXZlbnRQYXJ0c1swXTtcbiAgICAgICAgdmFyIGV2ZW50ID0gZXZlbnRQYXJ0c1sxXTtcblxuICAgICAgICBpZiAoa2V5TmFtZSBpbiBNT0RJRklFUl9LRVlTKSB7XG4gICAgICAgICAgcGFyc2VkS2V5Q29tYm9bTU9ESUZJRVJfS0VZU1trZXlOYW1lXV0gPSB0cnVlO1xuICAgICAgICAgIHBhcnNlZEtleUNvbWJvLmhhc01vZGlmaWVycyA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGFyc2VkS2V5Q29tYm8ua2V5ID0ga2V5TmFtZTtcbiAgICAgICAgICBwYXJzZWRLZXlDb21iby5ldmVudCA9IGV2ZW50IHx8ICdrZXlkb3duJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwYXJzZWRLZXlDb21ibztcbiAgICAgIH0sIHtcbiAgICAgICAgY29tYm86IGtleUNvbWJvU3RyaW5nLnNwbGl0KCc6Jykuc2hpZnQoKVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VFdmVudFN0cmluZyhldmVudFN0cmluZykge1xuICAgICAgcmV0dXJuIGV2ZW50U3RyaW5nLnRyaW0oKS5zcGxpdCgnICcpLm1hcChmdW5jdGlvbihrZXlDb21ib1N0cmluZykge1xuICAgICAgICByZXR1cm4gcGFyc2VLZXlDb21ib1N0cmluZyhrZXlDb21ib1N0cmluZyk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBgUG9seW1lci5Jcm9uQTExeUtleXNCZWhhdmlvcmAgcHJvdmlkZXMgYSBub3JtYWxpemVkIGludGVyZmFjZSBmb3IgcHJvY2Vzc2luZ1xuICAgICAqIGtleWJvYXJkIGNvbW1hbmRzIHRoYXQgcGVydGFpbiB0byBbV0FJLUFSSUEgYmVzdCBwcmFjdGljZXNdKGh0dHA6Ly93d3cudzMub3JnL1RSL3dhaS1hcmlhLXByYWN0aWNlcy8ja2JkX2dlbmVyYWxfYmluZGluZykuXG4gICAgICogVGhlIGVsZW1lbnQgdGFrZXMgY2FyZSBvZiBicm93c2VyIGRpZmZlcmVuY2VzIHdpdGggcmVzcGVjdCB0byBLZXlib2FyZCBldmVudHNcbiAgICAgKiBhbmQgdXNlcyBhbiBleHByZXNzaXZlIHN5bnRheCB0byBmaWx0ZXIga2V5IHByZXNzZXMuXG4gICAgICpcbiAgICAgKiBVc2UgdGhlIGBrZXlCaW5kaW5nc2AgcHJvdG90eXBlIHByb3BlcnR5IHRvIGV4cHJlc3Mgd2hhdCBjb21iaW5hdGlvbiBvZiBrZXlzXG4gICAgICogd2lsbCB0cmlnZ2VyIHRoZSBjYWxsYmFjay4gQSBrZXkgYmluZGluZyBoYXMgdGhlIGZvcm1hdFxuICAgICAqIGBcIktFWStNT0RJRklFUjpFVkVOVFwiOiBcImNhbGxiYWNrXCJgIChgXCJLRVlcIjogXCJjYWxsYmFja1wiYCBvclxuICAgICAqIGBcIktFWTpFVkVOVFwiOiBcImNhbGxiYWNrXCJgIGFyZSB2YWxpZCBhcyB3ZWxsKS4gU29tZSBleGFtcGxlczpcbiAgICAgKlxuICAgICAqICAgICAga2V5QmluZGluZ3M6IHtcbiAgICAgKiAgICAgICAgJ3NwYWNlJzogJ19vbktleWRvd24nLCAvLyBzYW1lIGFzICdzcGFjZTprZXlkb3duJ1xuICAgICAqICAgICAgICAnc2hpZnQrdGFiJzogJ19vbktleWRvd24nLFxuICAgICAqICAgICAgICAnZW50ZXI6a2V5cHJlc3MnOiAnX29uS2V5cHJlc3MnLFxuICAgICAqICAgICAgICAnZXNjOmtleXVwJzogJ19vbktleXVwJ1xuICAgICAqICAgICAgfVxuICAgICAqXG4gICAgICogVGhlIGNhbGxiYWNrIHdpbGwgcmVjZWl2ZSB3aXRoIGFuIGV2ZW50IGNvbnRhaW5pbmcgdGhlIGZvbGxvd2luZyBpbmZvcm1hdGlvbiBpbiBgZXZlbnQuZGV0YWlsYDpcbiAgICAgKlxuICAgICAqICAgICAgX29uS2V5ZG93bjogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgKiAgICAgICAgY29uc29sZS5sb2coZXZlbnQuZGV0YWlsLmNvbWJvKTsgLy8gS0VZK01PRElGSUVSLCBlLmcuIFwic2hpZnQrdGFiXCJcbiAgICAgKiAgICAgICAgY29uc29sZS5sb2coZXZlbnQuZGV0YWlsLmtleSk7IC8vIEtFWSBvbmx5LCBlLmcuIFwidGFiXCJcbiAgICAgKiAgICAgICAgY29uc29sZS5sb2coZXZlbnQuZGV0YWlsLmV2ZW50KTsgLy8gRVZFTlQsIGUuZy4gXCJrZXlkb3duXCJcbiAgICAgKiAgICAgICAgY29uc29sZS5sb2coZXZlbnQuZGV0YWlsLmtleWJvYXJkRXZlbnQpOyAvLyB0aGUgb3JpZ2luYWwgS2V5Ym9hcmRFdmVudFxuICAgICAqICAgICAgfVxuICAgICAqXG4gICAgICogVXNlIHRoZSBga2V5RXZlbnRUYXJnZXRgIGF0dHJpYnV0ZSB0byBzZXQgdXAgZXZlbnQgaGFuZGxlcnMgb24gYSBzcGVjaWZpY1xuICAgICAqIG5vZGUuXG4gICAgICpcbiAgICAgKiBTZWUgdGhlIFtkZW1vIHNvdXJjZSBjb2RlXShodHRwczovL2dpdGh1Yi5jb20vUG9seW1lckVsZW1lbnRzL2lyb24tYTExeS1rZXlzLWJlaGF2aW9yL2Jsb2IvbWFzdGVyL2RlbW8veC1rZXktYXdhcmUuaHRtbClcbiAgICAgKiBmb3IgYW4gZXhhbXBsZS5cbiAgICAgKlxuICAgICAqIEBkZW1vIGRlbW8vaW5kZXguaHRtbFxuICAgICAqIEBwb2x5bWVyQmVoYXZpb3JcbiAgICAgKi9cbiAgICBQb2x5bWVyLklyb25BMTF5S2V5c0JlaGF2aW9yID0ge1xuICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIEV2ZW50VGFyZ2V0IHRoYXQgd2lsbCBiZSBmaXJpbmcgcmVsZXZhbnQgS2V5Ym9hcmRFdmVudHMuIFNldCBpdCB0b1xuICAgICAgICAgKiBgbnVsbGAgdG8gZGlzYWJsZSB0aGUgbGlzdGVuZXJzLlxuICAgICAgICAgKiBAdHlwZSB7P0V2ZW50VGFyZ2V0fVxuICAgICAgICAgKi9cbiAgICAgICAga2V5RXZlbnRUYXJnZXQ6IHtcbiAgICAgICAgICB0eXBlOiBPYmplY3QsXG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0cnVlLCB0aGlzIHByb3BlcnR5IHdpbGwgY2F1c2UgdGhlIGltcGxlbWVudGluZyBlbGVtZW50IHRvXG4gICAgICAgICAqIGF1dG9tYXRpY2FsbHkgc3RvcCBwcm9wYWdhdGlvbiBvbiBhbnkgaGFuZGxlZCBLZXlib2FyZEV2ZW50cy5cbiAgICAgICAgICovXG4gICAgICAgIHN0b3BLZXlib2FyZEV2ZW50UHJvcGFnYXRpb246IHtcbiAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgICB9LFxuXG4gICAgICAgIF9ib3VuZEtleUhhbmRsZXJzOiB7XG4gICAgICAgICAgdHlwZTogQXJyYXksXG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvLyBXZSB1c2UgdGhpcyBkdWUgdG8gYSBsaW1pdGF0aW9uIGluIElFMTAgd2hlcmUgaW5zdGFuY2VzIHdpbGwgaGF2ZVxuICAgICAgICAvLyBvd24gcHJvcGVydGllcyBvZiBldmVyeXRoaW5nIG9uIHRoZSBcInByb3RvdHlwZVwiLlxuICAgICAgICBfaW1wZXJhdGl2ZUtleUJpbmRpbmdzOiB7XG4gICAgICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIG9ic2VydmVyczogW1xuICAgICAgICAnX3Jlc2V0S2V5RXZlbnRMaXN0ZW5lcnMoa2V5RXZlbnRUYXJnZXQsIF9ib3VuZEtleUhhbmRsZXJzKSdcbiAgICAgIF0sXG5cblxuICAgICAgLyoqXG4gICAgICAgKiBUbyBiZSB1c2VkIHRvIGV4cHJlc3Mgd2hhdCBjb21iaW5hdGlvbiBvZiBrZXlzICB3aWxsIHRyaWdnZXIgdGhlIHJlbGF0aXZlXG4gICAgICAgKiBjYWxsYmFjay4gZS5nLiBga2V5QmluZGluZ3M6IHsgJ2VzYyc6ICdfb25Fc2NQcmVzc2VkJ31gXG4gICAgICAgKiBAdHlwZSB7IU9iamVjdH1cbiAgICAgICAqL1xuICAgICAga2V5QmluZGluZ3M6IHt9LFxuXG4gICAgICByZWdpc3RlcmVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fcHJlcEtleUJpbmRpbmdzKCk7XG4gICAgICB9LFxuXG4gICAgICBhdHRhY2hlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX2xpc3RlbktleUV2ZW50TGlzdGVuZXJzKCk7XG4gICAgICB9LFxuXG4gICAgICBkZXRhY2hlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX3VubGlzdGVuS2V5RXZlbnRMaXN0ZW5lcnMoKTtcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogQ2FuIGJlIHVzZWQgdG8gaW1wZXJhdGl2ZWx5IGFkZCBhIGtleSBiaW5kaW5nIHRvIHRoZSBpbXBsZW1lbnRpbmdcbiAgICAgICAqIGVsZW1lbnQuIFRoaXMgaXMgdGhlIGltcGVyYXRpdmUgZXF1aXZhbGVudCBvZiBkZWNsYXJpbmcgYSBrZXliaW5kaW5nXG4gICAgICAgKiBpbiB0aGUgYGtleUJpbmRpbmdzYCBwcm90b3R5cGUgcHJvcGVydHkuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50U3RyaW5nXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gaGFuZGxlck5hbWVcbiAgICAgICAqL1xuICAgICAgYWRkT3duS2V5QmluZGluZzogZnVuY3Rpb24oZXZlbnRTdHJpbmcsIGhhbmRsZXJOYW1lKSB7XG4gICAgICAgIHRoaXMuX2ltcGVyYXRpdmVLZXlCaW5kaW5nc1tldmVudFN0cmluZ10gPSBoYW5kbGVyTmFtZTtcbiAgICAgICAgdGhpcy5fcHJlcEtleUJpbmRpbmdzKCk7XG4gICAgICAgIHRoaXMuX3Jlc2V0S2V5RXZlbnRMaXN0ZW5lcnMoKTtcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogV2hlbiBjYWxsZWQsIHdpbGwgcmVtb3ZlIGFsbCBpbXBlcmF0aXZlbHktYWRkZWQga2V5IGJpbmRpbmdzLlxuICAgICAgICovXG4gICAgICByZW1vdmVPd25LZXlCaW5kaW5nczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX2ltcGVyYXRpdmVLZXlCaW5kaW5ncyA9IHt9O1xuICAgICAgICB0aGlzLl9wcmVwS2V5QmluZGluZ3MoKTtcbiAgICAgICAgdGhpcy5fcmVzZXRLZXlFdmVudExpc3RlbmVycygpO1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBSZXR1cm5zIHRydWUgaWYgYSBrZXlib2FyZCBldmVudCBtYXRjaGVzIGBldmVudFN0cmluZ2AuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtLZXlib2FyZEV2ZW50fSBldmVudFxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50U3RyaW5nXG4gICAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAgICovXG4gICAgICBrZXlib2FyZEV2ZW50TWF0Y2hlc0tleXM6IGZ1bmN0aW9uKGV2ZW50LCBldmVudFN0cmluZykge1xuICAgICAgICB2YXIga2V5Q29tYm9zID0gcGFyc2VFdmVudFN0cmluZyhldmVudFN0cmluZyk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5Q29tYm9zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgaWYgKGtleUNvbWJvTWF0Y2hlc0V2ZW50KGtleUNvbWJvc1tpXSwgZXZlbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSxcblxuICAgICAgX2NvbGxlY3RLZXlCaW5kaW5nczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBrZXlCaW5kaW5ncyA9IHRoaXMuYmVoYXZpb3JzLm1hcChmdW5jdGlvbihiZWhhdmlvcikge1xuICAgICAgICAgIHJldHVybiBiZWhhdmlvci5rZXlCaW5kaW5ncztcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGtleUJpbmRpbmdzLmluZGV4T2YodGhpcy5rZXlCaW5kaW5ncykgPT09IC0xKSB7XG4gICAgICAgICAga2V5QmluZGluZ3MucHVzaCh0aGlzLmtleUJpbmRpbmdzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBrZXlCaW5kaW5ncztcbiAgICAgIH0sXG5cbiAgICAgIF9wcmVwS2V5QmluZGluZ3M6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9rZXlCaW5kaW5ncyA9IHt9O1xuXG4gICAgICAgIHRoaXMuX2NvbGxlY3RLZXlCaW5kaW5ncygpLmZvckVhY2goZnVuY3Rpb24oa2V5QmluZGluZ3MpIHtcbiAgICAgICAgICBmb3IgKHZhciBldmVudFN0cmluZyBpbiBrZXlCaW5kaW5ncykge1xuICAgICAgICAgICAgdGhpcy5fYWRkS2V5QmluZGluZyhldmVudFN0cmluZywga2V5QmluZGluZ3NbZXZlbnRTdHJpbmddKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIGZvciAodmFyIGV2ZW50U3RyaW5nIGluIHRoaXMuX2ltcGVyYXRpdmVLZXlCaW5kaW5ncykge1xuICAgICAgICAgIHRoaXMuX2FkZEtleUJpbmRpbmcoZXZlbnRTdHJpbmcsIHRoaXMuX2ltcGVyYXRpdmVLZXlCaW5kaW5nc1tldmVudFN0cmluZ10pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gR2l2ZSBwcmVjZWRlbmNlIHRvIGNvbWJvcyB3aXRoIG1vZGlmaWVycyB0byBiZSBjaGVja2VkIGZpcnN0LlxuICAgICAgICBmb3IgKHZhciBldmVudE5hbWUgaW4gdGhpcy5fa2V5QmluZGluZ3MpIHtcbiAgICAgICAgICB0aGlzLl9rZXlCaW5kaW5nc1tldmVudE5hbWVdLnNvcnQoZnVuY3Rpb24gKGtiMSwga2IyKSB7XG4gICAgICAgICAgICB2YXIgYjEgPSBrYjFbMF0uaGFzTW9kaWZpZXJzO1xuICAgICAgICAgICAgdmFyIGIyID0ga2IyWzBdLmhhc01vZGlmaWVycztcbiAgICAgICAgICAgIHJldHVybiAoYjEgPT09IGIyKSA/IDAgOiBiMSA/IC0xIDogMTtcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBfYWRkS2V5QmluZGluZzogZnVuY3Rpb24oZXZlbnRTdHJpbmcsIGhhbmRsZXJOYW1lKSB7XG4gICAgICAgIHBhcnNlRXZlbnRTdHJpbmcoZXZlbnRTdHJpbmcpLmZvckVhY2goZnVuY3Rpb24oa2V5Q29tYm8pIHtcbiAgICAgICAgICB0aGlzLl9rZXlCaW5kaW5nc1trZXlDb21iby5ldmVudF0gPVxuICAgICAgICAgICAgdGhpcy5fa2V5QmluZGluZ3Nba2V5Q29tYm8uZXZlbnRdIHx8IFtdO1xuXG4gICAgICAgICAgdGhpcy5fa2V5QmluZGluZ3Nba2V5Q29tYm8uZXZlbnRdLnB1c2goW1xuICAgICAgICAgICAga2V5Q29tYm8sXG4gICAgICAgICAgICBoYW5kbGVyTmFtZVxuICAgICAgICAgIF0pO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICAgIH0sXG5cbiAgICAgIF9yZXNldEtleUV2ZW50TGlzdGVuZXJzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fdW5saXN0ZW5LZXlFdmVudExpc3RlbmVycygpO1xuXG4gICAgICAgIGlmICh0aGlzLmlzQXR0YWNoZWQpIHtcbiAgICAgICAgICB0aGlzLl9saXN0ZW5LZXlFdmVudExpc3RlbmVycygpO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBfbGlzdGVuS2V5RXZlbnRMaXN0ZW5lcnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMua2V5RXZlbnRUYXJnZXQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmtleXModGhpcy5fa2V5QmluZGluZ3MpLmZvckVhY2goZnVuY3Rpb24oZXZlbnROYW1lKSB7XG4gICAgICAgICAgdmFyIGtleUJpbmRpbmdzID0gdGhpcy5fa2V5QmluZGluZ3NbZXZlbnROYW1lXTtcbiAgICAgICAgICB2YXIgYm91bmRLZXlIYW5kbGVyID0gdGhpcy5fb25LZXlCaW5kaW5nRXZlbnQuYmluZCh0aGlzLCBrZXlCaW5kaW5ncyk7XG5cbiAgICAgICAgICB0aGlzLl9ib3VuZEtleUhhbmRsZXJzLnB1c2goW3RoaXMua2V5RXZlbnRUYXJnZXQsIGV2ZW50TmFtZSwgYm91bmRLZXlIYW5kbGVyXSk7XG5cbiAgICAgICAgICB0aGlzLmtleUV2ZW50VGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBib3VuZEtleUhhbmRsZXIpO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICAgIH0sXG5cbiAgICAgIF91bmxpc3RlbktleUV2ZW50TGlzdGVuZXJzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGtleUhhbmRsZXJUdXBsZTtcbiAgICAgICAgdmFyIGtleUV2ZW50VGFyZ2V0O1xuICAgICAgICB2YXIgZXZlbnROYW1lO1xuICAgICAgICB2YXIgYm91bmRLZXlIYW5kbGVyO1xuXG4gICAgICAgIHdoaWxlICh0aGlzLl9ib3VuZEtleUhhbmRsZXJzLmxlbmd0aCkge1xuICAgICAgICAgIC8vIE15IGtpbmdkb20gZm9yIGJsb2NrLXNjb3BlIGJpbmRpbmcgYW5kIGRlc3RydWN0dXJpbmcgYXNzaWdubWVudC4uXG4gICAgICAgICAga2V5SGFuZGxlclR1cGxlID0gdGhpcy5fYm91bmRLZXlIYW5kbGVycy5wb3AoKTtcbiAgICAgICAgICBrZXlFdmVudFRhcmdldCA9IGtleUhhbmRsZXJUdXBsZVswXTtcbiAgICAgICAgICBldmVudE5hbWUgPSBrZXlIYW5kbGVyVHVwbGVbMV07XG4gICAgICAgICAgYm91bmRLZXlIYW5kbGVyID0ga2V5SGFuZGxlclR1cGxlWzJdO1xuXG4gICAgICAgICAga2V5RXZlbnRUYXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGJvdW5kS2V5SGFuZGxlcik7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIF9vbktleUJpbmRpbmdFdmVudDogZnVuY3Rpb24oa2V5QmluZGluZ3MsIGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLnN0b3BLZXlib2FyZEV2ZW50UHJvcGFnYXRpb24pIHtcbiAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIGV2ZW50IGhhcyBiZWVuIGFscmVhZHkgcHJldmVudGVkLCBkb24ndCBkbyBhbnl0aGluZ1xuICAgICAgICBpZiAoZXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5QmluZGluZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIga2V5Q29tYm8gPSBrZXlCaW5kaW5nc1tpXVswXTtcbiAgICAgICAgICB2YXIgaGFuZGxlck5hbWUgPSBrZXlCaW5kaW5nc1tpXVsxXTtcbiAgICAgICAgICBpZiAoa2V5Q29tYm9NYXRjaGVzRXZlbnQoa2V5Q29tYm8sIGV2ZW50KSkge1xuICAgICAgICAgICAgdGhpcy5fdHJpZ2dlcktleUhhbmRsZXIoa2V5Q29tYm8sIGhhbmRsZXJOYW1lLCBldmVudCk7XG4gICAgICAgICAgICAvLyBleGl0IHRoZSBsb29wIGlmIGV2ZW50RGVmYXVsdCB3YXMgcHJldmVudGVkXG4gICAgICAgICAgICBpZiAoZXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBfdHJpZ2dlcktleUhhbmRsZXI6IGZ1bmN0aW9uKGtleUNvbWJvLCBoYW5kbGVyTmFtZSwga2V5Ym9hcmRFdmVudCkge1xuICAgICAgICB2YXIgZGV0YWlsID0gT2JqZWN0LmNyZWF0ZShrZXlDb21ibyk7XG4gICAgICAgIGRldGFpbC5rZXlib2FyZEV2ZW50ID0ga2V5Ym9hcmRFdmVudDtcbiAgICAgICAgdmFyIGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KGtleUNvbWJvLmV2ZW50LCB7XG4gICAgICAgICAgZGV0YWlsOiBkZXRhaWwsXG4gICAgICAgICAgY2FuY2VsYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpc1toYW5kbGVyTmFtZV0uY2FsbCh0aGlzLCBldmVudCk7XG4gICAgICAgIGlmIChldmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgICAga2V5Ym9hcmRFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfSkoKTtcbjwvc2NyaXB0PlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9pcm9uLWExMXkta2V5cy1iZWhhdmlvci9pcm9uLWExMXkta2V5cy1iZWhhdmlvci5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNSBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuXG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vcG9seW1lci9wb2x5bWVyLmh0bWxcIj5cblxuPHNjcmlwdD5cbiAgLyoqXG4gICAqIGBJcm9uUmVzaXphYmxlQmVoYXZpb3JgIGlzIGEgYmVoYXZpb3IgdGhhdCBjYW4gYmUgdXNlZCBpbiBQb2x5bWVyIGVsZW1lbnRzIHRvXG4gICAqIGNvb3JkaW5hdGUgdGhlIGZsb3cgb2YgcmVzaXplIGV2ZW50cyBiZXR3ZWVuIFwicmVzaXplcnNcIiAoZWxlbWVudHMgdGhhdCBjb250cm9sIHRoZVxuICAgKiBzaXplIG9yIGhpZGRlbiBzdGF0ZSBvZiB0aGVpciBjaGlsZHJlbikgYW5kIFwicmVzaXphYmxlc1wiIChlbGVtZW50cyB0aGF0IG5lZWQgdG8gYmVcbiAgICogbm90aWZpZWQgd2hlbiB0aGV5IGFyZSByZXNpemVkIG9yIHVuLWhpZGRlbiBieSB0aGVpciBwYXJlbnRzIGluIG9yZGVyIHRvIHRha2VcbiAgICogYWN0aW9uIG9uIHRoZWlyIG5ldyBtZWFzdXJlbWVudHMpLlxuICAgKlxuICAgKiBFbGVtZW50cyB0aGF0IHBlcmZvcm0gbWVhc3VyZW1lbnQgc2hvdWxkIGFkZCB0aGUgYElyb25SZXNpemFibGVCZWhhdmlvcmAgYmVoYXZpb3IgdG9cbiAgICogdGhlaXIgZWxlbWVudCBkZWZpbml0aW9uIGFuZCBsaXN0ZW4gZm9yIHRoZSBgaXJvbi1yZXNpemVgIGV2ZW50IG9uIHRoZW1zZWx2ZXMuXG4gICAqIFRoaXMgZXZlbnQgd2lsbCBiZSBmaXJlZCB3aGVuIHRoZXkgYmVjb21lIHNob3dpbmcgYWZ0ZXIgaGF2aW5nIGJlZW4gaGlkZGVuLFxuICAgKiB3aGVuIHRoZXkgYXJlIHJlc2l6ZWQgZXhwbGljaXRseSBieSBhbm90aGVyIHJlc2l6YWJsZSwgb3Igd2hlbiB0aGUgd2luZG93IGhhcyBiZWVuXG4gICAqIHJlc2l6ZWQuXG4gICAqXG4gICAqIE5vdGUsIHRoZSBgaXJvbi1yZXNpemVgIGV2ZW50IGlzIG5vbi1idWJibGluZy5cbiAgICpcbiAgICogQHBvbHltZXJCZWhhdmlvciBQb2x5bWVyLklyb25SZXNpemFibGVCZWhhdmlvclxuICAgKiBAZGVtbyBkZW1vL2luZGV4Lmh0bWxcbiAgICoqL1xuICBQb2x5bWVyLklyb25SZXNpemFibGVCZWhhdmlvciA9IHtcbiAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAvKipcbiAgICAgICAqIFRoZSBjbG9zZXN0IGFuY2VzdG9yIGVsZW1lbnQgdGhhdCBpbXBsZW1lbnRzIGBJcm9uUmVzaXphYmxlQmVoYXZpb3JgLlxuICAgICAgICovXG4gICAgICBfcGFyZW50UmVzaXphYmxlOiB7XG4gICAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgICAgb2JzZXJ2ZXI6ICdfcGFyZW50UmVzaXphYmxlQ2hhbmdlZCdcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogVHJ1ZSBpZiB0aGlzIGVsZW1lbnQgaXMgY3VycmVudGx5IG5vdGlmeWluZyBpdHMgZGVzY2VuZGFudCBlbGVtZW50cyBvZlxuICAgICAgICogcmVzaXplLlxuICAgICAgICovXG4gICAgICBfbm90aWZ5aW5nRGVzY2VuZGFudDoge1xuICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgbGlzdGVuZXJzOiB7XG4gICAgICAnaXJvbi1yZXF1ZXN0LXJlc2l6ZS1ub3RpZmljYXRpb25zJzogJ19vbklyb25SZXF1ZXN0UmVzaXplTm90aWZpY2F0aW9ucydcbiAgICB9LFxuXG4gICAgY3JlYXRlZDogZnVuY3Rpb24oKSB7XG4gICAgICAvLyBXZSBkb24ndCByZWFsbHkgbmVlZCBwcm9wZXJ0eSBlZmZlY3RzIG9uIHRoZXNlLCBhbmQgYWxzbyB3ZSB3YW50IHRoZW1cbiAgICAgIC8vIHRvIGJlIGNyZWF0ZWQgYmVmb3JlIHRoZSBgX3BhcmVudFJlc2l6YWJsZWAgb2JzZXJ2ZXIgZmlyZXM6XG4gICAgICB0aGlzLl9pbnRlcmVzdGVkUmVzaXphYmxlcyA9IFtdO1xuICAgICAgdGhpcy5fYm91bmROb3RpZnlSZXNpemUgPSB0aGlzLm5vdGlmeVJlc2l6ZS5iaW5kKHRoaXMpO1xuICAgIH0sXG5cbiAgICBhdHRhY2hlZDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9yZXF1ZXN0UmVzaXplTm90aWZpY2F0aW9ucygpO1xuICAgIH0sXG5cbiAgICBkZXRhY2hlZDogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5fcGFyZW50UmVzaXphYmxlKSB7XG4gICAgICAgIHRoaXMuX3BhcmVudFJlc2l6YWJsZS5zdG9wUmVzaXplTm90aWZpY2F0aW9uc0Zvcih0aGlzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLl9ib3VuZE5vdGlmeVJlc2l6ZSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3BhcmVudFJlc2l6YWJsZSA9IG51bGw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbiBiZSBjYWxsZWQgdG8gbWFudWFsbHkgbm90aWZ5IGEgcmVzaXphYmxlIGFuZCBpdHMgZGVzY2VuZGFudFxuICAgICAqIHJlc2l6YWJsZXMgb2YgYSByZXNpemUgY2hhbmdlLlxuICAgICAqL1xuICAgIG5vdGlmeVJlc2l6ZTogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXRoaXMuaXNBdHRhY2hlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2ludGVyZXN0ZWRSZXNpemFibGVzLmZvckVhY2goZnVuY3Rpb24ocmVzaXphYmxlKSB7XG4gICAgICAgIGlmICh0aGlzLnJlc2l6ZXJTaG91bGROb3RpZnkocmVzaXphYmxlKSkge1xuICAgICAgICAgIHRoaXMuX25vdGlmeURlc2NlbmRhbnQocmVzaXphYmxlKTtcbiAgICAgICAgfVxuICAgICAgfSwgdGhpcyk7XG5cbiAgICAgIHRoaXMuX2ZpcmVSZXNpemUoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVXNlZCB0byBhc3NpZ24gdGhlIGNsb3Nlc3QgcmVzaXphYmxlIGFuY2VzdG9yIHRvIHRoaXMgcmVzaXphYmxlXG4gICAgICogaWYgdGhlIGFuY2VzdG9yIGRldGVjdHMgYSByZXF1ZXN0IGZvciBub3RpZmljYXRpb25zLlxuICAgICAqL1xuICAgIGFzc2lnblBhcmVudFJlc2l6YWJsZTogZnVuY3Rpb24ocGFyZW50UmVzaXphYmxlKSB7XG4gICAgICB0aGlzLl9wYXJlbnRSZXNpemFibGUgPSBwYXJlbnRSZXNpemFibGU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gcmVtb3ZlIGEgcmVzaXphYmxlIGRlc2NlbmRhbnQgZnJvbSB0aGUgbGlzdCBvZiBkZXNjZW5kYW50c1xuICAgICAqIHRoYXQgc2hvdWxkIGJlIG5vdGlmaWVkIG9mIGEgcmVzaXplIGNoYW5nZS5cbiAgICAgKi9cbiAgICBzdG9wUmVzaXplTm90aWZpY2F0aW9uc0ZvcjogZnVuY3Rpb24odGFyZ2V0KSB7XG4gICAgICB2YXIgaW5kZXggPSB0aGlzLl9pbnRlcmVzdGVkUmVzaXphYmxlcy5pbmRleE9mKHRhcmdldCk7XG5cbiAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgIHRoaXMuX2ludGVyZXN0ZWRSZXNpemFibGVzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIHRoaXMudW5saXN0ZW4odGFyZ2V0LCAnaXJvbi1yZXNpemUnLCAnX29uRGVzY2VuZGFudElyb25SZXNpemUnKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgY2FuIGJlIG92ZXJyaWRkZW4gdG8gZmlsdGVyIG5lc3RlZCBlbGVtZW50cyB0aGF0IHNob3VsZCBvclxuICAgICAqIHNob3VsZCBub3QgYmUgbm90aWZpZWQgYnkgdGhlIGN1cnJlbnQgZWxlbWVudC4gUmV0dXJuIHRydWUgaWYgYW4gZWxlbWVudFxuICAgICAqIHNob3VsZCBiZSBub3RpZmllZCwgb3IgZmFsc2UgaWYgaXQgc2hvdWxkIG5vdCBiZSBub3RpZmllZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgQSBjYW5kaWRhdGUgZGVzY2VuZGFudCBlbGVtZW50IHRoYXRcbiAgICAgKiBpbXBsZW1lbnRzIGBJcm9uUmVzaXphYmxlQmVoYXZpb3JgLlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGBlbGVtZW50YCBzaG91bGQgYmUgbm90aWZpZWQgb2YgcmVzaXplLlxuICAgICAqL1xuICAgIHJlc2l6ZXJTaG91bGROb3RpZnk6IGZ1bmN0aW9uKGVsZW1lbnQpIHsgcmV0dXJuIHRydWU7IH0sXG5cbiAgICBfb25EZXNjZW5kYW50SXJvblJlc2l6ZTogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIGlmICh0aGlzLl9ub3RpZnlpbmdEZXNjZW5kYW50KSB7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIE5PVEUoY2RhdGEpOiBJbiBTaGFkb3dET00sIGV2ZW50IHJldGFyZ2V0aW5nIG1ha2VzIGVjaG9pbmcgb2YgdGhlXG4gICAgICAvLyBvdGhlcndpc2Ugbm9uLWJ1YmJsaW5nIGV2ZW50IFwianVzdCB3b3JrLlwiIFdlIGRvIGl0IG1hbnVhbGx5IGhlcmUgZm9yXG4gICAgICAvLyB0aGUgY2FzZSB3aGVyZSBQb2x5bWVyIGlzIG5vdCB1c2luZyBzaGFkb3cgcm9vdHMgZm9yIHdoYXRldmVyIHJlYXNvbjpcbiAgICAgIGlmICghUG9seW1lci5TZXR0aW5ncy51c2VTaGFkb3cpIHtcbiAgICAgICAgdGhpcy5fZmlyZVJlc2l6ZSgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBfZmlyZVJlc2l6ZTogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmZpcmUoJ2lyb24tcmVzaXplJywgbnVsbCwge1xuICAgICAgICBub2RlOiB0aGlzLFxuICAgICAgICBidWJibGVzOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfSxcblxuICAgIF9vbklyb25SZXF1ZXN0UmVzaXplTm90aWZpY2F0aW9uczogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIHZhciB0YXJnZXQgPSAvKiogQHR5cGUgeyFFdmVudFRhcmdldH0gKi8gKFBvbHltZXIuZG9tKGV2ZW50KS5yb290VGFyZ2V0KTtcbiAgICAgIGlmICh0YXJnZXQgPT09IHRoaXMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5faW50ZXJlc3RlZFJlc2l6YWJsZXMuaW5kZXhPZih0YXJnZXQpID09PSAtMSkge1xuICAgICAgICB0aGlzLl9pbnRlcmVzdGVkUmVzaXphYmxlcy5wdXNoKHRhcmdldCk7XG4gICAgICAgIHRoaXMubGlzdGVuKHRhcmdldCwgJ2lyb24tcmVzaXplJywgJ19vbkRlc2NlbmRhbnRJcm9uUmVzaXplJyk7XG4gICAgICB9XG5cbiAgICAgIHRhcmdldC5hc3NpZ25QYXJlbnRSZXNpemFibGUodGhpcyk7XG4gICAgICB0aGlzLl9ub3RpZnlEZXNjZW5kYW50KHRhcmdldCk7XG5cbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH0sXG5cbiAgICBfcGFyZW50UmVzaXphYmxlQ2hhbmdlZDogZnVuY3Rpb24ocGFyZW50UmVzaXphYmxlKSB7XG4gICAgICBpZiAocGFyZW50UmVzaXphYmxlKSB7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLl9ib3VuZE5vdGlmeVJlc2l6ZSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIF9ub3RpZnlEZXNjZW5kYW50OiBmdW5jdGlvbihkZXNjZW5kYW50KSB7XG4gICAgICAvLyBOT1RFKGNkYXRhKTogSW4gSUUxMCwgYXR0YWNoZWQgaXMgZmlyZWQgb24gY2hpbGRyZW4gZmlyc3QsIHNvIGl0J3NcbiAgICAgIC8vIGltcG9ydGFudCBub3QgdG8gbm90aWZ5IHRoZW0gaWYgdGhlIHBhcmVudCBpcyBub3QgYXR0YWNoZWQgeWV0IChvclxuICAgICAgLy8gZWxzZSB0aGV5IHdpbGwgZ2V0IHJlZHVuZGFudGx5IG5vdGlmaWVkIHdoZW4gdGhlIHBhcmVudCBhdHRhY2hlcykuXG4gICAgICBpZiAoIXRoaXMuaXNBdHRhY2hlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX25vdGlmeWluZ0Rlc2NlbmRhbnQgPSB0cnVlO1xuICAgICAgZGVzY2VuZGFudC5ub3RpZnlSZXNpemUoKTtcbiAgICAgIHRoaXMuX25vdGlmeWluZ0Rlc2NlbmRhbnQgPSBmYWxzZTtcbiAgICB9LFxuICAgIFxuICAgIF9yZXF1ZXN0UmVzaXplTm90aWZpY2F0aW9uczogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXRoaXMuaXNBdHRhY2hlZClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgXG4gICAgICAvLyBOT1RFKHZhbGRyaW4pIEluIEN1c3RvbUVsZW1lbnRzIHYxIHdpdGggbmF0aXZlIEhUTUxJbXBvcnRzLCB0aGUgb3JkZXJcbiAgICAgIC8vIG9mIGltcG9ydHMgYWZmZWN0cyB0aGUgb3JkZXIgb2YgYGF0dGFjaGVkYCBjYWxsYmFja3MgKHNlZSB3ZWJjb21wb25lbnRzL2N1c3RvbS1lbGVtZW50cyMxNSkuXG4gICAgICAvLyBUaGlzIG1pZ2h0IGNhdXNlIGEgY2hpbGQgdG8gbm90aWZ5IHBhcmVudHMgdG9vIGVhcmx5IChhcyB0aGUgcGFyZW50XG4gICAgICAvLyBzdGlsbCBoYXMgdG8gYmUgdXBncmFkZWQpLCByZXN1bHRpbmcgaW4gYSBwYXJlbnQgbm90IGFibGUgdG8ga2VlcCB0cmFja1xuICAgICAgLy8gb2YgdGhlIGBfaW50ZXJlc3RlZFJlc2l6YWJsZXNgLiBUbyBzb2x2ZSB0aGlzLCB3ZSB3YWl0IGZvciB0aGUgZG9jdW1lbnRcbiAgICAgIC8vIHRvIGJlIGRvbmUgbG9hZGluZyBiZWZvcmUgZmlyaW5nIHRoZSBldmVudC5cbiAgICAgIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnbG9hZGluZycpIHtcbiAgICAgICAgdmFyIF9yZXF1ZXN0UmVzaXplTm90aWZpY2F0aW9ucyA9IHRoaXMuX3JlcXVlc3RSZXNpemVOb3RpZmljYXRpb25zLmJpbmQodGhpcyk7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3JlYWR5c3RhdGVjaGFuZ2UnLCBmdW5jdGlvbiByZWFkeXN0YXRlY2hhbmdlZCgpIHtcbiAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdyZWFkeXN0YXRlY2hhbmdlJywgcmVhZHlzdGF0ZWNoYW5nZWQpO1xuICAgICAgICAgIF9yZXF1ZXN0UmVzaXplTm90aWZpY2F0aW9ucygpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZmlyZSgnaXJvbi1yZXF1ZXN0LXJlc2l6ZS1ub3RpZmljYXRpb25zJywgbnVsbCwge1xuICAgICAgICAgIG5vZGU6IHRoaXMsXG4gICAgICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgICAgICBjYW5jZWxhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICghdGhpcy5fcGFyZW50UmVzaXphYmxlKSB7XG4gICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuX2JvdW5kTm90aWZ5UmVzaXplKTtcbiAgICAgICAgICB0aGlzLm5vdGlmeVJlc2l6ZSgpO1xuICAgICAgICB9IFxuICAgICAgfVxuICAgIH1cbiAgfTtcbjwvc2NyaXB0PlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9pcm9uLXJlc2l6YWJsZS1iZWhhdmlvci9pcm9uLXJlc2l6YWJsZS1iZWhhdmlvci5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNSBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuXG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vcG9seW1lci9wb2x5bWVyLmh0bWxcIj5cblxuPCEtLVxuYGlyb24tbWV0YWAgaXMgYSBnZW5lcmljIGVsZW1lbnQgeW91IGNhbiB1c2UgZm9yIHNoYXJpbmcgaW5mb3JtYXRpb24gYWNyb3NzIHRoZSBET00gdHJlZS5cbkl0IHVzZXMgW21vbm9zdGF0ZSBwYXR0ZXJuXShodHRwOi8vYzIuY29tL2NnaS93aWtpP01vbm9zdGF0ZVBhdHRlcm4pIHN1Y2ggdGhhdCBhbnlcbmluc3RhbmNlIG9mIGlyb24tbWV0YSBoYXMgYWNjZXNzIHRvIHRoZSBzaGFyZWRcbmluZm9ybWF0aW9uLiBZb3UgY2FuIHVzZSBgaXJvbi1tZXRhYCB0byBzaGFyZSB3aGF0ZXZlciB5b3Ugd2FudCAob3IgY3JlYXRlIGFuIGV4dGVuc2lvblxuW2xpa2UgeC1tZXRhXSBmb3IgZW5oYW5jZW1lbnRzKS5cblxuVGhlIGBpcm9uLW1ldGFgIGluc3RhbmNlcyBjb250YWluaW5nIHlvdXIgYWN0dWFsIGRhdGEgY2FuIGJlIGxvYWRlZCBpbiBhbiBpbXBvcnQsXG5vciBjb25zdHJ1Y3RlZCBpbiBhbnkgd2F5IHlvdSBzZWUgZml0LiBUaGUgb25seSByZXF1aXJlbWVudCBpcyB0aGF0IHlvdSBjcmVhdGUgdGhlbVxuYmVmb3JlIHlvdSB0cnkgdG8gYWNjZXNzIHRoZW0uXG5cbkV4YW1wbGVzOlxuXG5JZiBJIGNyZWF0ZSBhbiBpbnN0YW5jZSBsaWtlIHRoaXM6XG5cbiAgICA8aXJvbi1tZXRhIGtleT1cImluZm9cIiB2YWx1ZT1cImZvby9iYXJcIj48L2lyb24tbWV0YT5cblxuTm90ZSB0aGF0IHZhbHVlPVwiZm9vL2JhclwiIGlzIHRoZSBtZXRhZGF0YSBJJ3ZlIGRlZmluZWQuIEkgY291bGQgZGVmaW5lIG1vcmVcbmF0dHJpYnV0ZXMgb3IgdXNlIGNoaWxkIG5vZGVzIHRvIGRlZmluZSBhZGRpdGlvbmFsIG1ldGFkYXRhLlxuXG5Ob3cgSSBjYW4gYWNjZXNzIHRoYXQgZWxlbWVudCAoYW5kIGl0J3MgbWV0YWRhdGEpIGZyb20gYW55IGlyb24tbWV0YSBpbnN0YW5jZVxudmlhIHRoZSBieUtleSBtZXRob2QsIGUuZy5cblxuICAgIG1ldGEuYnlLZXkoJ2luZm8nKTtcblxuUHVyZSBpbXBlcmF0aXZlIGZvcm0gd291bGQgYmUgbGlrZTpcblxuICAgIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lyb24tbWV0YScpLmJ5S2V5KCdpbmZvJyk7XG5cbk9yLCBpbiBhIFBvbHltZXIgZWxlbWVudCwgeW91IGNhbiBpbmNsdWRlIGEgbWV0YSBpbiB5b3VyIHRlbXBsYXRlOlxuXG4gICAgPGlyb24tbWV0YSBpZD1cIm1ldGFcIj48L2lyb24tbWV0YT5cbiAgICAuLi5cbiAgICB0aGlzLiQubWV0YS5ieUtleSgnaW5mbycpO1xuXG5AZ3JvdXAgSXJvbiBFbGVtZW50c1xuQGRlbW8gZGVtby9pbmRleC5odG1sXG5AaGVybyBoZXJvLnN2Z1xuQGVsZW1lbnQgaXJvbi1tZXRhXG4tLT5cblxuPHNjcmlwdD5cblxuICAoZnVuY3Rpb24oKSB7XG5cbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge3t0eXBlOiAoc3RyaW5nfG51bGwpLCBrZXk6IChzdHJpbmd8bnVsbCksIHZhbHVlOiAqfX0gb3B0aW9uc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIElyb25NZXRhKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMudHlwZSA9IChvcHRpb25zICYmIG9wdGlvbnMudHlwZSkgfHwgJ2RlZmF1bHQnO1xuICAgICAgdGhpcy5rZXkgPSBvcHRpb25zICYmIG9wdGlvbnMua2V5O1xuICAgICAgaWYgKCd2YWx1ZScgaW4gb3B0aW9ucykge1xuICAgICAgICB0aGlzLnZhbHVlID0gb3B0aW9ucy52YWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBJcm9uTWV0YS50eXBlcyA9IHt9O1xuXG4gICAgSXJvbk1ldGEucHJvdG90eXBlID0ge1xuICAgICAgZ2V0IHZhbHVlKCkge1xuICAgICAgICB2YXIgdHlwZSA9IHRoaXMudHlwZTtcbiAgICAgICAgdmFyIGtleSA9IHRoaXMua2V5O1xuXG4gICAgICAgIGlmICh0eXBlICYmIGtleSkge1xuICAgICAgICAgIHJldHVybiBJcm9uTWV0YS50eXBlc1t0eXBlXSAmJiBJcm9uTWV0YS50eXBlc1t0eXBlXVtrZXldO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBzZXQgdmFsdWUodmFsdWUpIHtcbiAgICAgICAgdmFyIHR5cGUgPSB0aGlzLnR5cGU7XG4gICAgICAgIHZhciBrZXkgPSB0aGlzLmtleTtcblxuICAgICAgICBpZiAodHlwZSAmJiBrZXkpIHtcbiAgICAgICAgICB0eXBlID0gSXJvbk1ldGEudHlwZXNbdHlwZV0gPSBJcm9uTWV0YS50eXBlc1t0eXBlXSB8fCB7fTtcbiAgICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgZGVsZXRlIHR5cGVba2V5XTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHlwZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBnZXQgbGlzdCgpIHtcbiAgICAgICAgdmFyIHR5cGUgPSB0aGlzLnR5cGU7XG5cbiAgICAgICAgaWYgKHR5cGUpIHtcbiAgICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMoSXJvbk1ldGEudHlwZXNbdGhpcy50eXBlXSkubWFwKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIG1ldGFEYXRhc1t0aGlzLnR5cGVdW2tleV07XG4gICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIGJ5S2V5OiBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBQb2x5bWVyLklyb25NZXRhID0gSXJvbk1ldGE7XG5cbiAgICB2YXIgbWV0YURhdGFzID0gUG9seW1lci5Jcm9uTWV0YS50eXBlcztcblxuICAgIFBvbHltZXIoe1xuXG4gICAgICBpczogJ2lyb24tbWV0YScsXG5cbiAgICAgIHByb3BlcnRpZXM6IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHR5cGUgb2YgbWV0YS1kYXRhLiAgQWxsIG1ldGEtZGF0YSBvZiB0aGUgc2FtZSB0eXBlIGlzIHN0b3JlZFxuICAgICAgICAgKiB0b2dldGhlci5cbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHR5cGU6IHtcbiAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgdmFsdWU6ICdkZWZhdWx0JyxcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGtleSB1c2VkIHRvIHN0b3JlIGB2YWx1ZWAgdW5kZXIgdGhlIGB0eXBlYCBuYW1lc3BhY2UuXG4gICAgICAgICAqIEB0eXBlIHs/c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAga2V5OiB7XG4gICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbWV0YS1kYXRhIHRvIHN0b3JlIG9yIHJldHJpZXZlLlxuICAgICAgICAgKiBAdHlwZSB7Kn1cbiAgICAgICAgICovXG4gICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgIG5vdGlmeTogdHJ1ZSxcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgdHJ1ZSwgYHZhbHVlYCBpcyBzZXQgdG8gdGhlIGlyb24tbWV0YSBpbnN0YW5jZSBpdHNlbGYuXG4gICAgICAgICAqL1xuICAgICAgICAgc2VsZjoge1xuICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgICAgb2JzZXJ2ZXI6ICdfc2VsZkNoYW5nZWQnXG4gICAgICAgIH0sXG5cbiAgICAgICAgX19tZXRhOiB7XG4gICAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgICBjb21wdXRlZDogJ19fY29tcHV0ZU1ldGEodHlwZSwga2V5LCB2YWx1ZSknXG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIGhvc3RBdHRyaWJ1dGVzOiB7XG4gICAgICAgIGhpZGRlbjogdHJ1ZVxuICAgICAgfSxcblxuICAgICAgX19jb21wdXRlTWV0YTogZnVuY3Rpb24odHlwZSwga2V5LCB2YWx1ZSkge1xuICAgICAgICB2YXIgbWV0YSA9IG5ldyBQb2x5bWVyLklyb25NZXRhKHtcbiAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgIGtleToga2V5XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBtZXRhLnZhbHVlKSB7XG4gICAgICAgICAgbWV0YS52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMudmFsdWUgIT09IG1ldGEudmFsdWUpIHtcbiAgICAgICAgICB0aGlzLnZhbHVlID0gbWV0YS52YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtZXRhO1xuICAgICAgfSxcblxuICAgICAgZ2V0IGxpc3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fbWV0YSAmJiB0aGlzLl9fbWV0YS5saXN0O1xuICAgICAgfSxcblxuICAgICAgX3NlbGZDaGFuZ2VkOiBmdW5jdGlvbihzZWxmKSB7XG4gICAgICAgIGlmIChzZWxmKSB7XG4gICAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXM7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogUmV0cmlldmVzIG1ldGEgZGF0YSB2YWx1ZSBieSBrZXkuXG4gICAgICAgKlxuICAgICAgICogQG1ldGhvZCBieUtleVxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBtZXRhLWRhdGEgdG8gYmUgcmV0dXJuZWQuXG4gICAgICAgKiBAcmV0dXJuIHsqfVxuICAgICAgICovXG4gICAgICBieUtleTogZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHJldHVybiBuZXcgUG9seW1lci5Jcm9uTWV0YSh7XG4gICAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICAgIGtleToga2V5XG4gICAgICAgIH0pLnZhbHVlO1xuICAgICAgfVxuICAgIH0pO1xuICB9KSgpO1xuPC9zY3JpcHQ+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL2lyb24tbWV0YS9pcm9uLW1ldGEuaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cblxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3V0aWxzL2Jvb3QuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3V0aWxzL3NldHRpbmdzLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi91dGlscy9taXhpbi5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vdXRpbHMvY2FzZS1tYXAuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3V0aWxzL3N0eWxlLWdhdGhlci5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vdXRpbHMvcmVzb2x2ZS11cmwuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL2VsZW1lbnRzL2RvbS1tb2R1bGUuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cInByb3BlcnR5LWVmZmVjdHMuaHRtbFwiPlxuXG48c2NyaXB0PlxuKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLyoqXG4gICAqIEVsZW1lbnQgY2xhc3MgbWl4aW4gdGhhdCBwcm92aWRlcyB0aGUgY29yZSBBUEkgZm9yIFBvbHltZXIncyBtZXRhLXByb2dyYW1taW5nXG4gICAqIGZlYXR1cmVzIGluY2x1ZGluZyB0ZW1wbGF0ZSBzdGFtcGluZywgZGF0YS1iaW5kaW5nLCBhdHRyaWJ1dGUgZGVzZXJpYWxpemF0aW9uLFxuICAgKiBhbmQgcHJvcGVydHkgY2hhbmdlIG9ic2VydmF0aW9uLlxuICAgKlxuICAgKiBTdWJjbGFzc2VycyBtYXkgcHJvdmlkZSB0aGUgZm9sbG93aW5nIHN0YXRpYyBnZXR0ZXJzIHRvIHJldHVybiBtZXRhZGF0YVxuICAgKiB1c2VkIHRvIGNvbmZpZ3VyZSBQb2x5bWVyJ3MgZmVhdHVyZXMgZm9yIHRoZSBjbGFzczpcbiAgICpcbiAgICogLSBgc3RhdGljIGdldCBpcygpYDogV2hlbiB0aGUgdGVtcGxhdGUgaXMgcHJvdmlkZWQgdmlhIGEgYGRvbS1tb2R1bGVgLFxuICAgKiAgIHVzZXJzIHNob3VsZCByZXR1cm4gdGhlIGBkb20tbW9kdWxlYCBpZCBmcm9tIGEgc3RhdGljIGBpc2AgZ2V0dGVyLiAgSWZcbiAgICogICBubyB0ZW1wbGF0ZSBpcyBuZWVkZWQgb3IgdGhlIHRlbXBsYXRlIGlzIHByb3ZpZGVkIGRpcmVjdGx5IHZpYSB0aGVcbiAgICogICBgdGVtcGxhdGVgIGdldHRlciwgdGhlcmUgaXMgbm8gbmVlZCB0byBkZWZpbmUgYGlzYCBmb3IgdGhlIGVsZW1lbnQuXG4gICAqXG4gICAqIC0gYHN0YXRpYyBnZXQgdGVtcGxhdGUoKWA6IFVzZXJzIG1heSBwcm92aWRlIHRoZSB0ZW1wbGF0ZSBkaXJlY3RseSAoYXNcbiAgICogICBvcHBvc2VkIHRvIHZpYSBgZG9tLW1vZHVsZWApIGJ5IGltcGxlbWVudGluZyBhIHN0YXRpYyBgdGVtcGxhdGVgIGdldHRlci5cbiAgICogICBUaGUgZ2V0dGVyIG1heSByZXR1cm4gYW4gYEhUTUxUZW1wbGF0ZUVsZW1lbnRgIG9yIGEgc3RyaW5nLCB3aGljaCB3aWxsXG4gICAqICAgYXV0b21hdGljYWxseSBiZSBwYXJzZWQgaW50byBhIHRlbXBsYXRlLlxuICAgKlxuICAgKiAtIGBzdGF0aWMgZ2V0IHByb3BlcnRpZXMoKWA6IFNob3VsZCByZXR1cm4gYW4gb2JqZWN0IGRlc2NyaWJpbmdcbiAgICogICBwcm9wZXJ0eS1yZWxhdGVkIG1ldGFkYXRhIHVzZWQgYnkgUG9seW1lciBmZWF0dXJlcyAoa2V5OiBwcm9wZXJ0eSBuYW1lXG4gICAqICAgdmFsdWU6IG9iamVjdCBjb250YWluaW5nIHByb3BlcnR5IG1ldGFkYXRhKS4gVmFsaWQga2V5cyBpbiBwZXItcHJvcGVydHlcbiAgICogICBtZXRhZGF0YSBpbmNsdWRlOlxuICAgKiAgIC0gYHR5cGVgIChTdHJpbmd8TnVtYmVyfE9iamVjdHxBcnJheXwuLi4pOiBVc2VkIGJ5XG4gICAqICAgICBgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrYCB0byBkZXRlcm1pbmUgaG93IHN0cmluZy1iYXNlZCBhdHRyaWJ1dGVzXG4gICAqICAgICBhcmUgZGVzZXJpYWxpemVkIHRvIEphdmFTY3JpcHQgcHJvcGVydHkgdmFsdWVzLlxuICAgKiAgIC0gYG5vdGlmeWAgKGJvb2xlYW4pOiBDYXVzZXMgYSBjaGFuZ2UgaW4gdGhlIHByb3BlcnR5IHRvIGZpcmUgYVxuICAgKiAgICAgbm9uLWJ1YmJsaW5nIGV2ZW50IGNhbGxlZCBgPHByb3BlcnR5Pi1jaGFuZ2VkYC4gRWxlbWVudHMgdGhhdCBoYXZlXG4gICAqICAgICBlbmFibGVkIHR3by13YXkgYmluZGluZyB0byB0aGUgcHJvcGVydHkgdXNlIHRoaXMgZXZlbnQgdG8gb2JzZXJ2ZSBjaGFuZ2VzLlxuICAgKiAgIC0gYHJlYWRPbmx5YCAoYm9vbGVhbik6IENyZWF0ZXMgYSBnZXR0ZXIgZm9yIHRoZSBwcm9wZXJ0eSwgYnV0IG5vIHNldHRlci5cbiAgICogICAgIFRvIHNldCBhIHJlYWQtb25seSBwcm9wZXJ0eSwgdXNlIHRoZSBwcml2YXRlIHNldHRlciBtZXRob2RcbiAgICogICAgIGBfc2V0UHJvcGVydHkocHJvcGVydHksIHZhbHVlKWAuXG4gICAqICAgLSBgb2JzZXJ2ZXJgIChzdHJpbmcpOiBPYnNlcnZlciBtZXRob2QgbmFtZSB0aGF0IHdpbGwgYmUgY2FsbGVkIHdoZW5cbiAgICogICAgIHRoZSBwcm9wZXJ0eSBjaGFuZ2VzLiBUaGUgYXJndW1lbnRzIG9mIHRoZSBtZXRob2QgYXJlXG4gICAqICAgICBgKHZhbHVlLCBwcmV2aW91c1ZhbHVlKWAuXG4gICAqICAgLSBgY29tcHV0ZWRgIChzdHJpbmcpOiBTdHJpbmcgZGVzY3JpYmluZyBtZXRob2QgYW5kIGRlcGVuZGVudCBwcm9wZXJ0aWVzXG4gICAqICAgICBmb3IgY29tcHV0aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIHByb3BlcnR5IChlLmcuIGAnY29tcHV0ZUZvbyhiYXIsIHpvdCknYCkuXG4gICAqICAgICBDb21wdXRlZCBwcm9wZXJ0aWVzIGFyZSByZWFkLW9ubHkgYnkgZGVmYXVsdCBhbmQgY2FuIG9ubHkgYmUgY2hhbmdlZFxuICAgKiAgICAgdmlhIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGNvbXB1dGluZyBtZXRob2QuXG4gICAqXG4gICAqIC0gYHN0YXRpYyBnZXQgb2JzZXJ2ZXJzKClgOiBBcnJheSBvZiBzdHJpbmdzIGRlc2NyaWJpbmcgbXVsdGktcHJvcGVydHlcbiAgICogICBvYnNlcnZlciBtZXRob2RzIGFuZCB0aGVpciBkZXBlbmRlbnQgcHJvcGVydGllcyAoZS5nLlxuICAgKiAgIGAnb2JzZXJ2ZUFCQyhhLCBiLCBjKSdgKS5cbiAgICpcbiAgICogVGhlIGJhc2UgY2xhc3MgcHJvdmlkZXMgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbnMgZm9yIHRoZSBmb2xsb3dpbmcgc3RhbmRhcmRcbiAgICogY3VzdG9tIGVsZW1lbnQgbGlmZWN5Y2xlIGNhbGxiYWNrczsgdXNlcnMgbWF5IG92ZXJyaWRlIHRoZXNlLCBidXQgc2hvdWxkXG4gICAqIGNhbGwgdGhlIHN1cGVyIG1ldGhvZCB0byBlbnN1cmVcbiAgICogLSBgY29uc3RydWN0b3JgOiBSdW4gd2hlbiB0aGUgZWxlbWVudCBpcyBjcmVhdGVkIG9yIHVwZ3JhZGVkXG4gICAqIC0gYGNvbm5lY3RlZENhbGxiYWNrYDogUnVuIGVhY2ggdGltZSB0aGUgZWxlbWVudCBpcyBjb25uZWN0ZWQgdG8gdGhlXG4gICAqICAgZG9jdW1lbnRcbiAgICogLSBgZGlzY29ubmVjdGVkQ2FsbGJhY2tgOiBSdW4gZWFjaCB0aW1lIHRoZSBlbGVtZW50IGlzIGRpc2Nvbm5lY3RlZCBmcm9tXG4gICAqICAgdGhlIGRvY3VtZW50XG4gICAqIC0gYGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFja2A6IFJ1biBlYWNoIHRpbWUgYW4gYXR0cmlidXRlIGluXG4gICAqICAgYG9ic2VydmVkQXR0cmlidXRlc2AgaXMgc2V0IG9yIHJlbW92ZWQgKG5vdGU6IHRoaXMgZWxlbWVudCdzIGRlZmF1bHRcbiAgICogICBgb2JzZXJ2ZWRBdHRyaWJ1dGVzYCBpbXBsZW1lbnRhdGlvbiB3aWxsIGF1dG9tYXRpY2FsbHkgcmV0dXJuIGFuIGFycmF5XG4gICAqICAgb2YgZGFzaC1jYXNlZCBhdHRyaWJ1dGVzIGJhc2VkIG9uIGBwcm9wZXJ0aWVzYClcbiAgICpcbiAgICogQG1peGluRnVuY3Rpb25cbiAgICogQHBvbHltZXJcbiAgICogQGFwcGxpZXNNaXhpbiBQb2x5bWVyLlByb3BlcnR5RWZmZWN0c1xuICAgKiBAbWVtYmVyb2YgUG9seW1lclxuICAgKiBAcHJvcGVydHkgcm9vdFBhdGgge3N0cmluZ30gU2V0IHRvIHRoZSB2YWx1ZSBvZiBgUG9seW1lci5yb290UGF0aGAsXG4gICAqICAgd2hpY2ggZGVmYXVsdHMgdG8gdGhlIG1haW4gZG9jdW1lbnQgcGF0aFxuICAgKiBAcHJvcGVydHkgaW1wb3J0UGF0aCB7c3RyaW5nfSBTZXQgdG8gdGhlIHZhbHVlIG9mIHRoZSBjbGFzcydzIHN0YXRpY1xuICAgKiAgIGBpbXBvcnRQYXRoYCBwcm9wZXJ0eSwgd2hpY2ggZGVmYXVsdHMgdG8gdGhlIHBhdGggb2YgdGhpcyBlbGVtZW50J3NcbiAgICogICBgZG9tLW1vZHVsZWAgKHdoZW4gYGlzYCBpcyB1c2VkKSwgYnV0IGNhbiBiZSBvdmVycmlkZGVuIGZvciBvdGhlclxuICAgKiAgIGltcG9ydCBzdHJhdGVnaWVzLlxuICAgKiBAc3VtbWFyeSBFbGVtZW50IGNsYXNzIG1peGluIHRoYXQgcHJvdmlkZXMgdGhlIGNvcmUgQVBJIGZvciBQb2x5bWVyJ3NcbiAgICogbWV0YS1wcm9ncmFtbWluZyBmZWF0dXJlcy5cbiAgICovXG4gIFBvbHltZXIuRWxlbWVudE1peGluID0gUG9seW1lci5kZWR1cGluZ01peGluKGJhc2UgPT4ge1xuXG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQGV4dGVuZHMge2Jhc2V9XG4gICAgICogQGltcGxlbWVudHMge1BvbHltZXJfUHJvcGVydHlFZmZlY3RzfVxuICAgICAqL1xuICAgIGNvbnN0IHBvbHltZXJFbGVtZW50QmFzZSA9IFBvbHltZXIuUHJvcGVydHlFZmZlY3RzKGJhc2UpO1xuXG4gICAgbGV0IGNhc2VNYXAgPSBQb2x5bWVyLkNhc2VNYXA7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBgcHJvcGVydGllc2Agb2JqZWN0IHNwZWNpZmljYWxseSBvbiBga2xhc3NgLiBVc2UgZm9yOlxuICAgICAqICgxKSBzdXBlciBjaGFpbiBtaXhlcyB0b2d0aGVyIHRvIG1ha2UgYHByb3BlcnRpZXNGb3JDbGFzc2Agd2hpY2ggaXNcbiAgICAgKiB0aGVuIHVzZWQgdG8gbWFrZSBgb2JzZXJ2ZWRBdHRyaWJ1dGVzYC5cbiAgICAgKiAoMikgcHJvcGVydGllcyBlZmZlY3RzIGFuZCBvYnNlcnZlcnMgYXJlIGNyZWF0ZWQgZnJvbSBpdCBhdCBgZmluYWxpemVgIHRpbWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBrbGFzcyBFbGVtZW50IGNsYXNzXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBPYmplY3QgY29udGFpbmluZyBvd24gcHJvcGVydGllcyBmb3IgdGhpcyBjbGFzc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZnVuY3Rpb24gb3duUHJvcGVydGllc0ZvckNsYXNzKGtsYXNzKSB7XG4gICAgICBpZiAoIWtsYXNzLmhhc093blByb3BlcnR5KFxuICAgICAgICBKU0NvbXBpbGVyX3JlbmFtZVByb3BlcnR5KCdfX293blByb3BlcnRpZXMnLCBrbGFzcykpKSB7XG4gICAgICAgIGtsYXNzLl9fb3duUHJvcGVydGllcyA9XG4gICAgICAgICAga2xhc3MuaGFzT3duUHJvcGVydHkoSlNDb21waWxlcl9yZW5hbWVQcm9wZXJ0eSgncHJvcGVydGllcycsIGtsYXNzKSkgP1xuICAgICAgICAgIC8qKiBAdHlwZSBQb2x5bWVyRWxlbWVudENvbnN0cnVjdG9yICovIChrbGFzcykucHJvcGVydGllcyA6IHt9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGtsYXNzLl9fb3duUHJvcGVydGllcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBgb2JzZXJ2ZXJzYCBhcnJheSBzcGVjaWZpY2FsbHkgb24gYGtsYXNzYC4gVXNlIGZvclxuICAgICAqIHNldHRpbmcgdXAgb2JzZXJ2ZXJzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0ga2xhc3MgRWxlbWVudCBjbGFzc1xuICAgICAqIEByZXR1cm4ge0FycmF5fSBBcnJheSBjb250YWluaW5nIG93biBvYnNlcnZlcnMgZm9yIHRoaXMgY2xhc3NcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG93bk9ic2VydmVyc0ZvckNsYXNzKGtsYXNzKSB7XG4gICAgICBpZiAoIWtsYXNzLmhhc093blByb3BlcnR5KFxuICAgICAgICBKU0NvbXBpbGVyX3JlbmFtZVByb3BlcnR5KCdfX293bk9ic2VydmVycycsIGtsYXNzKSkpIHtcbiAgICAgICAga2xhc3MuX19vd25PYnNlcnZlcnMgPVxuICAgICAgICAgIGtsYXNzLmhhc093blByb3BlcnR5KEpTQ29tcGlsZXJfcmVuYW1lUHJvcGVydHkoJ29ic2VydmVycycsIGtsYXNzKSkgP1xuICAgICAgICAgIC8qKiBAdHlwZSBQb2x5bWVyRWxlbWVudENvbnN0cnVjdG9yICovIChrbGFzcykub2JzZXJ2ZXJzIDogW107XG4gICAgICB9XG4gICAgICByZXR1cm4ga2xhc3MuX19vd25PYnNlcnZlcnM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWl4ZXMgYHByb3BzYCBpbnRvIGBmbGF0dGVuZWRQcm9wc2AgYnV0IHVwZ3JhZGVzIHNob3J0aGFuZCB0eXBlXG4gICAgICogc3ludGF4IHRvIHsgdHlwZTogVHlwZX0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZmxhdHRlbmVkUHJvcHMgQmFnIHRvIGNvbGxlY3QgZmxhdHRlbmVkIHByb3BlcnRpZXMgaW50b1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBCYWcgb2YgcHJvcGVydGllcyB0byBhZGQgdG8gYGZsYXR0ZW5lZFByb3BzYFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIGlucHV0IGBmbGF0dGVuZWRQcm9wc2AgYmFnXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmbGF0dGVuUHJvcGVydGllcyhmbGF0dGVuZWRQcm9wcywgcHJvcHMpIHtcbiAgICAgIGZvciAobGV0IHAgaW4gcHJvcHMpIHtcbiAgICAgICAgbGV0IG8gPSBwcm9wc1twXTtcbiAgICAgICAgaWYgKHR5cGVvZiBvID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBvID0geyB0eXBlOiBvIH07XG4gICAgICAgIH1cbiAgICAgICAgZmxhdHRlbmVkUHJvcHNbcF0gPSBvO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZsYXR0ZW5lZFByb3BzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBmbGF0dGVuZWQgbGlzdCBvZiBwcm9wZXJ0aWVzIG1peGVkIHRvZ2V0aGVyIGZyb20gdGhlIGNoYWluIG9mIGFsbFxuICAgICAqIGNvbnN0cnVjdG9yJ3MgYGNvbmZpZy5wcm9wZXJ0aWVzYC4gVGhpcyBsaXN0IGlzIHVzZWQgdG8gY3JlYXRlXG4gICAgICogKDEpIG9ic2VydmVkQXR0cmlidXRlcyxcbiAgICAgKiAoMikgY2xhc3MgcHJvcGVydHkgZGVmYXVsdCB2YWx1ZXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UG9seW1lckVsZW1lbnRDb25zdHJ1Y3Rvcn0ga2xhc3MgRWxlbWVudCBjbGFzc1xuICAgICAqIEByZXR1cm4ge1BvbHltZXJFbGVtZW50UHJvcGVydGllc30gRmxhdHRlbmVkIHByb3BlcnRpZXMgZm9yIHRoaXMgY2xhc3NcbiAgICAgKiBAc3VwcHJlc3Mge21pc3NpbmdQcm9wZXJ0aWVzfSBjbGFzcy5wcm90b3R5cGUgaXMgbm90IGEgcHJvcGVydHkgZm9yIHNvbWUgcmVhc29uP1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZnVuY3Rpb24gcHJvcGVydGllc0ZvckNsYXNzKGtsYXNzKSB7XG4gICAgICBpZiAoIWtsYXNzLmhhc093blByb3BlcnR5KFxuICAgICAgICBKU0NvbXBpbGVyX3JlbmFtZVByb3BlcnR5KCdfX2NsYXNzUHJvcGVydGllcycsIGtsYXNzKSkpIHtcbiAgICAgICAga2xhc3MuX19jbGFzc1Byb3BlcnRpZXMgPVxuICAgICAgICBmbGF0dGVuUHJvcGVydGllcyh7fSwgb3duUHJvcGVydGllc0ZvckNsYXNzKGtsYXNzKSk7XG4gICAgICAgIGxldCBzdXBlckN0b3IgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yoa2xhc3MucHJvdG90eXBlKS5jb25zdHJ1Y3RvcjtcbiAgICAgICAgaWYgKHN1cGVyQ3Rvci5wcm90b3R5cGUgaW5zdGFuY2VvZiBQb2x5bWVyRWxlbWVudCkge1xuICAgICAgICAgIGtsYXNzLl9fY2xhc3NQcm9wZXJ0aWVzID0gT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICAgIE9iamVjdC5jcmVhdGUocHJvcGVydGllc0ZvckNsYXNzKC8qKiBAdHlwZSBQb2x5bWVyRWxlbWVudENvbnN0cnVjdG9yICovKHN1cGVyQ3RvcikpKSxcbiAgICAgICAgICAgIGtsYXNzLl9fY2xhc3NQcm9wZXJ0aWVzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGtsYXNzLl9fY2xhc3NQcm9wZXJ0aWVzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBsaXN0IG9mIHByb3BlcnRpZXMgd2l0aCBkZWZhdWx0IHZhbHVlcy5cbiAgICAgKiBUaGlzIGxpc3QgaXMgY3JlYXRlZCBhcyBhbiBvcHRpbWl6YXRpb24gc2luY2UgaXQgaXMgYSBzdWJzZXQgb2ZcbiAgICAgKiB0aGUgbGlzdCByZXR1cm5lZCBmcm9tIGBwcm9wZXJ0aWVzRm9yQ2xhc3NgLlxuICAgICAqIFRoaXMgbGlzdCBpcyB1c2VkIGluIGBfaW5pdGlhbGl6ZVByb3BlcnRpZXNgIHRvIHNldCBwcm9wZXJ0eSBkZWZhdWx0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UG9seW1lckVsZW1lbnRDb25zdHJ1Y3Rvcn0ga2xhc3MgRWxlbWVudCBjbGFzc1xuICAgICAqIEByZXR1cm4ge1BvbHltZXJFbGVtZW50UHJvcGVydGllc30gRmxhdHRlbmVkIHByb3BlcnRpZXMgZm9yIHRoaXMgY2xhc3NcbiAgICAgKiAgIHRoYXQgaGF2ZSBkZWZhdWx0IHZhbHVlc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZnVuY3Rpb24gcHJvcGVydHlEZWZhdWx0c0ZvckNsYXNzKGtsYXNzKSB7XG4gICAgICBpZiAoIWtsYXNzLmhhc093blByb3BlcnR5KFxuICAgICAgICBKU0NvbXBpbGVyX3JlbmFtZVByb3BlcnR5KCdfX2NsYXNzUHJvcGVydHlEZWZhdWx0cycsIGtsYXNzKSkpIHtcbiAgICAgICAga2xhc3MuX19jbGFzc1Byb3BlcnR5RGVmYXVsdHMgPSBudWxsO1xuICAgICAgICBsZXQgcHJvcHMgPSBwcm9wZXJ0aWVzRm9yQ2xhc3Moa2xhc3MpO1xuICAgICAgICBmb3IgKGxldCBwIGluIHByb3BzKSB7XG4gICAgICAgICAgbGV0IGluZm8gPSBwcm9wc1twXTtcbiAgICAgICAgICBpZiAoJ3ZhbHVlJyBpbiBpbmZvKSB7XG4gICAgICAgICAgICBrbGFzcy5fX2NsYXNzUHJvcGVydHlEZWZhdWx0cyA9IGtsYXNzLl9fY2xhc3NQcm9wZXJ0eURlZmF1bHRzIHx8IHt9O1xuICAgICAgICAgICAga2xhc3MuX19jbGFzc1Byb3BlcnR5RGVmYXVsdHNbcF0gPSBpbmZvO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGtsYXNzLl9fY2xhc3NQcm9wZXJ0eURlZmF1bHRzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiBhIGBrbGFzc2AgaGFzIGZpbmFsaXplZC4gQ2FsbGVkIGluIGBFbGVtZW50Q2xhc3MuZmluYWxpemUoKWBcbiAgICAgKiBAcGFyYW0ge1BvbHltZXJFbGVtZW50Q29uc3RydWN0b3J9IGtsYXNzIEVsZW1lbnQgY2xhc3NcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGFsbCBtZXRhcHJvZ3JhbW1pbmcgZm9yIHRoaXMgY2xhc3MgaGFzIGJlZW5cbiAgICAgKiAgIGNvbXBsZXRlZFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaGFzQ2xhc3NGaW5hbGl6ZWQoa2xhc3MpIHtcbiAgICAgIHJldHVybiBrbGFzcy5oYXNPd25Qcm9wZXJ0eShKU0NvbXBpbGVyX3JlbmFtZVByb3BlcnR5KCdfX2ZpbmFsaXplZCcsIGtsYXNzKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIGJ5IGBFbGVtZW50Q2xhc3MuZmluYWxpemUoKWAuIEVuc3VyZXMgdGhpcyBga2xhc3NgIGFuZFxuICAgICAqICphbGwgc3VwZXJjbGFzc2VzKiBhcmUgZmluYWxpemVkIGJ5IHRyYXZlcnNpbmcgdGhlIHByb3RvdHlwZSBjaGFpblxuICAgICAqIGFuZCBjYWxsaW5nIGBrbGFzcy5maW5hbGl6ZSgpYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UG9seW1lckVsZW1lbnRDb25zdHJ1Y3Rvcn0ga2xhc3MgRWxlbWVudCBjbGFzc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmluYWxpemVDbGFzc0FuZFN1cGVyKGtsYXNzKSB7XG4gICAgICBsZXQgcHJvdG8gPSAvKiogQHR5cGUgUG9seW1lckVsZW1lbnRDb25zdHJ1Y3RvciAqLyAoa2xhc3MpLnByb3RvdHlwZTtcbiAgICAgIGxldCBzdXBlckN0b3IgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG8pLmNvbnN0cnVjdG9yO1xuICAgICAgaWYgKHN1cGVyQ3Rvci5wcm90b3R5cGUgaW5zdGFuY2VvZiBQb2x5bWVyRWxlbWVudCkge1xuICAgICAgICBzdXBlckN0b3IuZmluYWxpemUoKTtcbiAgICAgIH1cbiAgICAgIGZpbmFsaXplQ2xhc3Moa2xhc3MpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbmZpZ3VyZXMgYSBga2xhc3NgIGJhc2VkIG9uIGEgc3RhaWMgYGtsYXNzLmNvbmZpZ2Agb2JqZWN0IGFuZFxuICAgICAqIGEgYHRlbXBsYXRlYC4gVGhpcyBpbmNsdWRlcyBjcmVhdGluZyBhY2Nlc3NvcnMgYW5kIGVmZmVjdHNcbiAgICAgKiBmb3IgcHJvcGVydGllcyBpbiBgY29uZmlnYCBhbmQgdGhlIGB0ZW1wbGF0ZWAgYXMgd2VsbCBhcyBwcmVwYXJpbmcgdGhlXG4gICAgICogYHRlbXBsYXRlYCBmb3Igc3RhbXBpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BvbHltZXJFbGVtZW50Q29uc3RydWN0b3J9IGtsYXNzIEVsZW1lbnQgY2xhc3NcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbmFsaXplQ2xhc3Moa2xhc3MpIHtcbiAgICAgIGtsYXNzLl9fZmluYWxpemVkID0gdHJ1ZTtcbiAgICAgIGxldCBwcm90byA9IC8qKiBAdHlwZSBQb2x5bWVyRWxlbWVudENvbnN0cnVjdG9yICovIChrbGFzcykucHJvdG90eXBlO1xuICAgICAgaWYgKGtsYXNzLmhhc093blByb3BlcnR5KFxuICAgICAgICBKU0NvbXBpbGVyX3JlbmFtZVByb3BlcnR5KCdpcycsIGtsYXNzKSkgJiYga2xhc3MuaXMpIHtcbiAgICAgICAgUG9seW1lci50ZWxlbWV0cnkucmVnaXN0ZXIocHJvdG8pO1xuICAgICAgfVxuICAgICAgbGV0IHByb3BzID0gb3duUHJvcGVydGllc0ZvckNsYXNzKGtsYXNzKTtcbiAgICAgIGlmIChwcm9wcykge1xuICAgICAgICBmaW5hbGl6ZVByb3BlcnRpZXMocHJvdG8sIHByb3BzKTtcbiAgICAgIH1cbiAgICAgIGxldCBvYnNlcnZlcnMgPSBvd25PYnNlcnZlcnNGb3JDbGFzcyhrbGFzcyk7XG4gICAgICBpZiAob2JzZXJ2ZXJzKSB7XG4gICAgICAgIGZpbmFsaXplT2JzZXJ2ZXJzKHByb3RvLCBvYnNlcnZlcnMsIHByb3BzKTtcbiAgICAgIH1cbiAgICAgIC8vIG5vdGU6IGNyZWF0ZSBcIndvcmtpbmdcIiB0ZW1wbGF0ZSB0aGF0IGlzIGZpbmFsaXplZCBhdCBpbnN0YW5jZSB0aW1lXG4gICAgICBsZXQgdGVtcGxhdGUgPSAvKiogQHR5cGUgUG9seW1lckVsZW1lbnRDb25zdHJ1Y3RvciAqLyAoa2xhc3MpLnRlbXBsYXRlO1xuICAgICAgaWYgKHRlbXBsYXRlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGVtcGxhdGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgbGV0IHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScpO1xuICAgICAgICAgIHQuaW5uZXJIVE1MID0gdGVtcGxhdGU7XG4gICAgICAgICAgdGVtcGxhdGUgPSB0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRlbXBsYXRlID0gdGVtcGxhdGUuY2xvbmVOb2RlKHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHByb3RvLl90ZW1wbGF0ZSA9IHRlbXBsYXRlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbmZpZ3VyZXMgYSBgcHJvdG9gIGJhc2VkIG9uIGEgYHByb3BlcnRpZXNgIG9iamVjdC5cbiAgICAgKiBMZXZlcmFnZXMgYFByb3BlcnR5RWZmZWN0c2AgdG8gY3JlYXRlIHByb3BlcnR5IGFjY2Vzc29ycyBhbmQgZWZmZWN0c1xuICAgICAqIHN1cHBvcnRpbmcsIG9ic2VydmVycywgcmVmbGVjdGluZyB0byBhdHRyaWJ1dGVzLCBjaGFuZ2Ugbm90aWZpY2F0aW9uLFxuICAgICAqIGNvbXB1dGVkIHByb3BlcnRpZXMsIGFuZCByZWFkIG9ubHkgcHJvcGVydGllcy5cbiAgICAgKiBAcGFyYW0ge1BvbHltZXJFbGVtZW50fSBwcm90byBFbGVtZW50IGNsYXNzIHByb3RvdHlwZSB0byBhZGQgYWNjZXNzb3JzXG4gICAgICogICAgYW5kIGVmZmVjdHMgdG9cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcGVydGllcyBGbGF0dGVuZWQgYmFnIG9mIHByb3BlcnR5IGRlc2NyaXB0b3JzIGZvclxuICAgICAqICAgIHRoaXMgY2xhc3NcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbmFsaXplUHJvcGVydGllcyhwcm90bywgcHJvcGVydGllcykge1xuICAgICAgZm9yIChsZXQgcCBpbiBwcm9wZXJ0aWVzKSB7XG4gICAgICAgIGNyZWF0ZVByb3BlcnR5RnJvbUNvbmZpZyhwcm90bywgcCwgcHJvcGVydGllc1twXSwgcHJvcGVydGllcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29uZmlndXJlcyBhIGBwcm90b2AgYmFzZWQgb24gYSBgb2JzZXJ2ZXJzYCBhcnJheS5cbiAgICAgKiBMZXZlcmFnZXMgYFByb3BlcnR5RWZmZWN0c2AgdG8gY3JlYXRlIG9ic2VydmVycy5cbiAgICAgKiBAcGFyYW0ge1BvbHltZXJFbGVtZW50fSBwcm90byBFbGVtZW50IGNsYXNzIHByb3RvdHlwZSB0byBhZGQgYWNjZXNzb3JzXG4gICAgICogICBhbmQgZWZmZWN0cyB0b1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYnNlcnZlcnMgRmxhdHRlbmVkIGFycmF5IG9mIG9ic2VydmVyIGRlc2NyaXB0b3JzIGZvclxuICAgICAqICAgdGhpcyBjbGFzc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkeW5hbWljRm5zIE9iamVjdCBjb250YWluaW5nIGtleXMgZm9yIGFueSBwcm9wZXJ0aWVzXG4gICAgICogICB0aGF0IGFyZSBmdW5jdGlvbnMgYW5kIHNob3VsZCB0cmlnZ2VyIHRoZSBlZmZlY3Qgd2hlbiB0aGUgZnVuY3Rpb25cbiAgICAgKiAgIHJlZmVyZW5jZSBpcyBjaGFuZ2VkXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5hbGl6ZU9ic2VydmVycyhwcm90bywgb2JzZXJ2ZXJzLCBkeW5hbWljRm5zKSB7XG4gICAgICBmb3IgKGxldCBpPTA7IGkgPCBvYnNlcnZlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcHJvdG8uX2NyZWF0ZU1ldGhvZE9ic2VydmVyKG9ic2VydmVyc1tpXSwgZHluYW1pY0Zucyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBlZmZlY3RzIGZvciBhIHByb3BlcnR5LlxuICAgICAqXG4gICAgICogTm90ZSwgb25jZSBhIHByb3BlcnR5IGhhcyBiZWVuIHNldCB0b1xuICAgICAqIGByZWFkT25seWAsIGBjb21wdXRlZGAsIGByZWZsZWN0VG9BdHRyaWJ1dGVgLCBvciBgbm90aWZ5YFxuICAgICAqIHRoZXNlIHZhbHVlcyBtYXkgbm90IGJlIGNoYW5nZWQuIEZvciBleGFtcGxlLCBhIHN1YmNsYXNzIGNhbm5vdFxuICAgICAqIGFsdGVyIHRoZXNlIHNldHRpbmdzLiBIb3dldmVyLCBhZGRpdGlvbmFsIGBvYnNlcnZlcnNgIG1heSBiZSBhZGRlZFxuICAgICAqIGJ5IHN1YmNsYXNzZXMuXG4gICAgICpcbiAgICAgKiBUaGUgaW5mbyBvYmplY3Qgc2hvdWxkIG1heSBjb250YWluIHByb3BlcnR5IG1ldGFkYXRhIGFzIGZvbGxvd3M6XG4gICAgICpcbiAgICAgKiAqIGB0eXBlYDoge2Z1bmN0aW9ufSB0eXBlIHRvIHdoaWNoIGFuIGF0dHJpYnV0ZSBtYXRjaGluZyB0aGUgcHJvcGVydHlcbiAgICAgKiBpcyBkZXNlcmlhbGl6ZWQuIE5vdGUgdGhlIHByb3BlcnR5IGlzIGNhbWVsLWNhc2VkIGZyb20gYSBkYXNoLWNhc2VkXG4gICAgICogYXR0cmlidXRlLiBGb3IgZXhhbXBsZSwgJ2Zvby1iYXInIGF0dHJpYnV0ZSBpcyBkZXJzaWFsaXplZCB0byBhXG4gICAgICogcHJvcGVydHkgbmFtZWQgJ2Zvb0JhcicuXG4gICAgICpcbiAgICAgKiAqIGByZWFkT25seWA6IHtib29sZWFufSBjcmVhdGVzIGEgcmVhZE9ubHkgcHJvcGVydHkgYW5kXG4gICAgICogbWFrZXMgYSBwcml2YXRlIHNldHRlciBmb3IgdGhlIHByaXZhdGUgb2YgdGhlIGZvcm0gJ19zZXRGb28nIGZvciBhXG4gICAgICogcHJvcGVydHkgJ2ZvbycsXG4gICAgICpcbiAgICAgKiAqIGBjb21wdXRlZGA6IHtzdHJpbmd9IGNyZWF0ZXMgYSBjb21wdXRlZCBwcm9wZXJ0eS4gQSBjb21wdXRlZCBwcm9wZXJ0eVxuICAgICAqIGFsc28gYXV0b21hdGljYWxseSBpcyBzZXQgdG8gYHJlYWRPbmx5OiB0cnVlYC4gVGhlIHZhbHVlIGlzIGNhbGN1bGF0ZWRcbiAgICAgKiBieSBydW5uaW5nIGEgbWV0aG9kIGFuZCBhcmd1bWVudHMgcGFyc2VkIGZyb20gdGhlIGdpdmVuIHN0cmluZy4gRm9yXG4gICAgICogZXhhbXBsZSAnY29tcHV0ZShmb28pJyB3aWxsIGNvbXB1dGUgYSBnaXZlbiBwcm9wZXJ0eSB3aGVuIHRoZVxuICAgICAqICdmb28nIHByb3BlcnR5IGNoYW5nZXMgYnkgZXhlY3V0aW5nIHRoZSAnY29tcHV0ZScgbWV0aG9kLiBUaGlzIG1ldGhvZFxuICAgICAqIG11c3QgcmV0dXJuIHRoZSBjb21wdXRlZCB2YWx1ZS5cbiAgICAgKlxuICAgICAqICogYHJlZmxlY3RUb0F0dHJpdXRlYDoge2Jvb2xlYW59IElmIHRydWUsIHRoZSBwcm9wZXJ0eSB2YWx1ZSBpcyByZWZsZWN0ZWRcbiAgICAgKiB0byBhbiBhdHRyaWJ1dGUgb2YgdGhlIHNhbWUgbmFtZS4gTm90ZSwgdGhlIGF0dHJpYnV0ZSBpcyBkYXNoLWNhc2VkXG4gICAgICogc28gYSBwcm9wZXJ0eSBuYW1lZCAnZm9vQmFyJyBpcyByZWZsZWN0ZWQgYXMgJ2Zvby1iYXInLlxuICAgICAqXG4gICAgICogKiBgbm90aWZ5YDoge2Jvb2xlYW59IHNlbmRzIGEgbm9uLWJ1YmJsaW5nIG5vdGlmaWNhdGlvbiBldmVudCB3aGVuXG4gICAgICogdGhlIHByb3BlcnR5IGNoYW5nZXMuIEZvciBleGFtcGxlLCBhIHByb3BlcnR5IG5hbWVkICdmb28nIHNlbmRzIGFuXG4gICAgICogZXZlbnQgbmFtZWQgJ2Zvby1jaGFuZ2VkJyB3aXRoIGBldmVudC5kZXRhaWxgIHNldCB0byB0aGUgdmFsdWUgb2ZcbiAgICAgKiB0aGUgcHJvcGVydHkuXG4gICAgICpcbiAgICAgKiAqIG9ic2VydmVyOiB7c3RyaW5nfSBuYW1lIG9mIGEgbWV0aG9kIHRoYXQgcnVucyB3aGVuIHRoZSBwcm9wZXJ0eVxuICAgICAqIGNoYW5nZXMuIFRoZSBhcmd1bWVudHMgb2YgdGhlIG1ldGhvZCBhcmUgKHZhbHVlLCBwcmV2aW91c1ZhbHVlKS5cbiAgICAgKlxuICAgICAqIE5vdGU6IFVzZXJzIG1heSB3YW50IGNvbnRyb2wgb3ZlciBtb2RpZnlpbmcgcHJvcGVydHlcbiAgICAgKiBlZmZlY3RzIHZpYSBzdWJjbGFzc2luZy4gRm9yIGV4YW1wbGUsIGEgdXNlciBtaWdodCB3YW50IHRvIG1ha2UgYVxuICAgICAqIHJlZmxlY3RUb0F0dHJpYnV0ZSBwcm9wZXJ0eSBub3QgZG8gc28gaW4gYSBzdWJjbGFzcy4gV2UndmUgY2hvc2VuIHRvXG4gICAgICogZGlzYWJsZSB0aGlzIGJlY2F1c2UgaXQgbGVhZHMgdG8gYWRkaXRpb25hbCBjb21wbGljYXRpb24uXG4gICAgICogRm9yIGV4YW1wbGUsIGEgcmVhZE9ubHkgZWZmZWN0IGdlbmVyYXRlcyBhIHNwZWNpYWwgc2V0dGVyLiBJZiBhIHN1YmNsYXNzXG4gICAgICogZGlzYWJsZXMgdGhlIGVmZmVjdCwgdGhlIHNldHRlciB3b3VsZCBmYWlsIHVuZXhwZWN0ZWRseS5cbiAgICAgKiBCYXNlZCBvbiBmZWVkYmFjaywgd2UgbWF5IHdhbnQgdG8gdHJ5IHRvIG1ha2UgZWZmZWN0cyBtb3JlIG1hbGxlYWJsZVxuICAgICAqIGFuZC9vciBwcm92aWRlIGFuIGFkdmFuY2VkIGFwaSBmb3IgbWFuaXB1bGF0aW5nIHRoZW0uXG4gICAgICogQWxzbyBjb25zaWRlciBhZGRpbmcgd2FybmluZ3Mgd2hlbiBhbiBlZmZlY3QgY2Fubm90IGJlIGNoYW5nZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BvbHltZXJFbGVtZW50fSBwcm90byBFbGVtZW50IGNsYXNzIHByb3RvdHlwZSB0byBhZGQgYWNjZXNzb3JzXG4gICAgICogICBhbmQgZWZmZWN0cyB0b1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE5hbWUgb2YgdGhlIHByb3BlcnR5LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbmZvIEluZm8gb2JqZWN0IGZyb20gd2hpY2ggdG8gY3JlYXRlIHByb3BlcnR5IGVmZmVjdHMuXG4gICAgICogU3VwcG9ydGVkIGtleXM6XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFsbFByb3BzIEZsYXR0ZW5lZCBtYXAgb2YgYWxsIHByb3BlcnRpZXMgZGVmaW5lZCBpbiB0aGlzXG4gICAgICogICBlbGVtZW50IChpbmNsdWRpbmcgaW5oZXJpdGVkIHByb3BlcnRpZXMpXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVQcm9wZXJ0eUZyb21Db25maWcocHJvdG8sIG5hbWUsIGluZm8sIGFsbFByb3BzKSB7XG4gICAgICAvLyBjb21wdXRlZCBmb3JjZXMgcmVhZE9ubHkuLi5cbiAgICAgIGlmIChpbmZvLmNvbXB1dGVkKSB7XG4gICAgICAgIGluZm8ucmVhZE9ubHkgPSB0cnVlO1xuICAgICAgfVxuICAgICAgLy8gTm90ZSwgc2luY2UgYWxsIGNvbXB1dGVkIHByb3BlcnRpZXMgYXJlIHJlYWRPbmx5LCB0aGlzIHByZXZlbnRzXG4gICAgICAvLyBhZGRpbmcgYWRkaXRpb25hbCBjb21wdXRlZCBwcm9wZXJ0eSBlZmZlY3RzICh3aGljaCBsZWFkcyB0byBhIGNvbmZ1c2luZ1xuICAgICAgLy8gc2V0dXAgd2hlcmUgbXVsdGlwbGUgdHJpZ2dlcnMgZm9yIHNldHRpbmcgYSBwcm9wZXJ0eSlcbiAgICAgIC8vIFdoaWxlIHdlIGRvIGhhdmUgYGhhc0NvbXB1dGVkRWZmZWN0YCB0aGlzIGlzIHNldCBvbiB0aGUgcHJvcGVydHknc1xuICAgICAgLy8gZGVwZW5kZW5jaWVzIHJhdGhlciB0aGFuIGl0c2VsZi5cbiAgICAgIGlmIChpbmZvLmNvbXB1dGVkICAmJiAhcHJvdG8uX2hhc1JlYWRPbmx5RWZmZWN0KG5hbWUpKSB7XG4gICAgICAgIHByb3RvLl9jcmVhdGVDb21wdXRlZFByb3BlcnR5KG5hbWUsIGluZm8uY29tcHV0ZWQsIGFsbFByb3BzKTtcbiAgICAgIH1cbiAgICAgIGlmIChpbmZvLnJlYWRPbmx5ICYmICFwcm90by5faGFzUmVhZE9ubHlFZmZlY3QobmFtZSkpIHtcbiAgICAgICAgcHJvdG8uX2NyZWF0ZVJlYWRPbmx5UHJvcGVydHkobmFtZSwgIWluZm8uY29tcHV0ZWQpO1xuICAgICAgfVxuICAgICAgaWYgKGluZm8ucmVmbGVjdFRvQXR0cmlidXRlICYmICFwcm90by5faGFzUmVmbGVjdEVmZmVjdChuYW1lKSkge1xuICAgICAgICBwcm90by5fY3JlYXRlUmVmbGVjdGVkUHJvcGVydHkobmFtZSk7XG4gICAgICB9XG4gICAgICBpZiAoaW5mby5ub3RpZnkgJiYgIXByb3RvLl9oYXNOb3RpZnlFZmZlY3QobmFtZSkpIHtcbiAgICAgICAgcHJvdG8uX2NyZWF0ZU5vdGlmeWluZ1Byb3BlcnR5KG5hbWUpO1xuICAgICAgfVxuICAgICAgLy8gYWx3YXlzIGFkZCBvYnNlcnZlclxuICAgICAgaWYgKGluZm8ub2JzZXJ2ZXIpIHtcbiAgICAgICAgcHJvdG8uX2NyZWF0ZVByb3BlcnR5T2JzZXJ2ZXIobmFtZSwgaW5mby5vYnNlcnZlciwgYWxsUHJvcHNbaW5mby5vYnNlcnZlcl0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbmZpZ3VyZXMgYW4gZWxlbWVudCBgcHJvdG9gIHRvIGZ1bmN0aW9uIHdpdGggYSBnaXZlbiBgdGVtcGxhdGVgLlxuICAgICAqIFRoZSBlbGVtZW50IG5hbWUgYGlzYCBhbmQgZXh0ZW5kcyBgZXh0YCBtdXN0IGJlIHNwZWNpZmllZCBmb3IgU2hhZHlDU1NcbiAgICAgKiBzdHlsZSBzY29waW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQb2x5bWVyRWxlbWVudH0gcHJvdG8gRWxlbWVudCBjbGFzcyBwcm90b3R5cGUgdG8gYWRkIGFjY2Vzc29yc1xuICAgICAqICAgYW5kIGVmZmVjdHMgdG9cbiAgICAgKiBAcGFyYW0geyFIVE1MVGVtcGxhdGVFbGVtZW50fSB0ZW1wbGF0ZSBUZW1wbGF0ZSB0byBwcm9jZXNzIGFuZCBiaW5kXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGJhc2VVUkkgVVJMIGFnYWluc3Qgd2hpY2ggdG8gcmVzb2x2ZSB1cmxzIGluXG4gICAgICogICBzdHlsZSBlbGVtZW50IGNzc1RleHRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaXMgVGFnIG5hbWUgKG9yIHR5cGUgZXh0ZW5zaW9uIG5hbWUpIGZvciB0aGlzIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZz19IGV4dCBGb3IgdHlwZSBleHRlbnNpb25zLCB0aGUgdGFnIG5hbWUgdGhhdCB3YXMgZXh0ZW5kZWRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbmFsaXplVGVtcGxhdGUocHJvdG8sIHRlbXBsYXRlLCBiYXNlVVJJLCBpcywgZXh0KSB7XG4gICAgICAvLyBzdXBwb3J0IGBpbmNsdWRlPVwibW9kdWxlLW5hbWVcImBcbiAgICAgIGxldCBjc3NUZXh0ID1cbiAgICAgICAgUG9seW1lci5TdHlsZUdhdGhlci5jc3NGcm9tVGVtcGxhdGUodGVtcGxhdGUsIGJhc2VVUkkpICtcbiAgICAgICAgUG9seW1lci5TdHlsZUdhdGhlci5jc3NGcm9tTW9kdWxlSW1wb3J0cyhpcyk7XG4gICAgICBpZiAoY3NzVGV4dCkge1xuICAgICAgICBsZXQgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgICAgICBzdHlsZS50ZXh0Q29udGVudCA9IGNzc1RleHQ7XG4gICAgICAgIHRlbXBsYXRlLmNvbnRlbnQuaW5zZXJ0QmVmb3JlKHN0eWxlLCB0ZW1wbGF0ZS5jb250ZW50LmZpcnN0Q2hpbGQpO1xuICAgICAgfVxuICAgICAgaWYgKHdpbmRvdy5TaGFkeUNTUykge1xuICAgICAgICB3aW5kb3cuU2hhZHlDU1MucHJlcGFyZVRlbXBsYXRlKHRlbXBsYXRlLCBpcywgZXh0KTtcbiAgICAgIH1cbiAgICAgIHByb3RvLl9iaW5kVGVtcGxhdGUodGVtcGxhdGUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwb2x5bWVyXG4gICAgICogQG1peGluQ2xhc3NcbiAgICAgKiBAdW5yZXN0cmljdGVkXG4gICAgICogQGltcGxlbWVudHMge1BvbHltZXJfRWxlbWVudE1peGlufVxuICAgICAqL1xuICAgIGNsYXNzIFBvbHltZXJFbGVtZW50IGV4dGVuZHMgcG9seW1lckVsZW1lbnRCYXNlIHtcblxuICAgICAgLyoqXG4gICAgICAgKiBTdGFuZGFyZCBDdXN0b20gRWxlbWVudHMgVjEgQVBJLiAgVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gcmV0dXJuc1xuICAgICAgICogYSBsaXN0IG9mIGRhc2gtY2FzZWQgYXR0cmlidXRlcyBiYXNlZCBvbiBhIGZsYXR0ZW5pbmcgb2YgYWxsIHByb3BlcnRpZXNcbiAgICAgICAqIGRlY2xhcmVkIGluIGBzdGF0aWMgZ2V0IHByb3BlcnRpZXMoKWAgZm9yIHRoaXMgZWxlbWVudCBhbmQgYW55XG4gICAgICAgKiBzdXBlcmNsYXNzZXMuXG4gICAgICAgKlxuICAgICAgICogQHJldHVybiB7QXJyYXl9IE9ic2VydmVkIGF0dHJpYnV0ZSBsaXN0XG4gICAgICAgKi9cbiAgICAgIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgICAgICBpZiAoIXRoaXMuaGFzT3duUHJvcGVydHkoSlNDb21waWxlcl9yZW5hbWVQcm9wZXJ0eSgnX19vYnNlcnZlZEF0dHJpYnV0ZXMnLCB0aGlzKSkpIHtcbiAgICAgICAgICBsZXQgbGlzdCA9IFtdO1xuICAgICAgICAgIGxldCBwcm9wZXJ0aWVzID0gcHJvcGVydGllc0ZvckNsYXNzKHRoaXMpO1xuICAgICAgICAgIGZvciAobGV0IHByb3AgaW4gcHJvcGVydGllcykge1xuICAgICAgICAgICAgbGlzdC5wdXNoKFBvbHltZXIuQ2FzZU1hcC5jYW1lbFRvRGFzaENhc2UocHJvcCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9fb2JzZXJ2ZWRBdHRyaWJ1dGVzID0gbGlzdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fX29ic2VydmVkQXR0cmlidXRlcztcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDYWxsZWQgYXV0b21hdGljYWxseSB3aGVuIHRoZSBmaXJzdCBlbGVtZW50IGluc3RhbmNlIGlzIGNyZWF0ZWQgdG9cbiAgICAgICAqIGVuc3VyZSB0aGF0IGNsYXNzIGZpbmFsaXphdGlvbiB3b3JrIGhhcyBiZWVuIGNvbXBsZXRlZC5cbiAgICAgICAqIE1heSBiZSBjYWxsZWQgYnkgdXNlcnMgdG8gZWFnZXJseSBwZXJmb3JtIGNsYXNzIGZpbmFsaXphdGlvbiB3b3JrXG4gICAgICAgKiBwcmlvciB0byB0aGUgY3JlYXRpb24gb2YgdGhlIGZpcnN0IGVsZW1lbnQgaW5zdGFuY2UuXG4gICAgICAgKlxuICAgICAgICogQ2xhc3MgZmluYWxpemF0aW9uIHdvcmsgZ2VuZXJhbGx5IGluY2x1ZGVzIG1ldGEtcHJvZ3JhbW1pbmcgc3VjaCBhc1xuICAgICAgICogY3JlYXRpbmcgcHJvcGVydHkgYWNjZXNzb3JzIGFuZCBhbnkgcHJvcGVydHkgZWZmZWN0IG1ldGFkYXRhIG5lZWRlZCBmb3JcbiAgICAgICAqIHRoZSBmZWF0dXJlcyB1c2VkLlxuICAgICAgICpcbiAgICAgICAqIEBwdWJsaWNcbiAgICAgICAqL1xuICAgICAgc3RhdGljIGZpbmFsaXplKCkge1xuICAgICAgICBpZiAoIWhhc0NsYXNzRmluYWxpemVkKHRoaXMpKSB7XG4gICAgICAgICAgZmluYWxpemVDbGFzc0FuZFN1cGVyKHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUmV0dXJucyB0aGUgdGVtcGxhdGUgdGhhdCB3aWxsIGJlIHN0YW1wZWQgaW50byB0aGlzIGVsZW1lbnQncyBzaGFkb3cgcm9vdC5cbiAgICAgICAqXG4gICAgICAgKiBJZiBhIGBzdGF0aWMgZ2V0IGlzKClgIGdldHRlciBpcyBkZWZpbmVkLCB0aGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvblxuICAgICAgICogd2lsbCByZXR1cm4gdGhlIGZpcnN0IGA8dGVtcGxhdGU+YCBpbiBhIGBkb20tbW9kdWxlYCB3aG9zZSBgaWRgXG4gICAgICAgKiBtYXRjaGVzIHRoaXMgZWxlbWVudCdzIGBpc2AuXG4gICAgICAgKlxuICAgICAgICogVXNlcnMgbWF5IG92ZXJyaWRlIHRoaXMgZ2V0dGVyIHRvIHJldHVybiBhbiBhcmJpdHJhcnkgdGVtcGxhdGVcbiAgICAgICAqIChpbiB3aGljaCBjYXNlIHRoZSBgaXNgIGdldHRlciBpcyB1bm5lY2Vzc2FyeSkuIFRoZSB0ZW1wbGF0ZSByZXR1cm5lZFxuICAgICAgICogbWF5IGJlIGVpdGhlciBhbiBgSFRNTFRlbXBsYXRlRWxlbWVudGAgb3IgYSBzdHJpbmcgdGhhdCB3aWxsIGJlXG4gICAgICAgKiBhdXRvbWF0aWNhbGx5IHBhcnNlZCBpbnRvIGEgdGVtcGxhdGUuXG4gICAgICAgKlxuICAgICAgICogTm90ZSB0aGF0IHdoZW4gc3ViY2xhc3NpbmcsIGlmIHRoZSBzdXBlciBjbGFzcyBvdmVycm9kZSB0aGUgZGVmYXVsdFxuICAgICAgICogaW1wbGVtZW50YXRpb24gYW5kIHRoZSBzdWJjbGFzcyB3b3VsZCBsaWtlIHRvIHByb3ZpZGUgYW4gYWx0ZXJuYXRlXG4gICAgICAgKiB0ZW1wbGF0ZSB2aWEgYSBgZG9tLW1vZHVsZWAsIGl0IHNob3VsZCBvdmVycmlkZSB0aGlzIGdldHRlciBhbmRcbiAgICAgICAqIHJldHVybiBgUG9seW1lci5Eb21Nb2R1bGUuaW1wb3J0KHRoaXMuaXMsICd0ZW1wbGF0ZScpYC5cbiAgICAgICAqXG4gICAgICAgKiBJZiBhIHN1YmNsYXNzIHdvdWxkIGxpa2UgdG8gbW9kaWZ5IHRoZSBzdXBlciBjbGFzcyB0ZW1wbGF0ZSwgaXQgc2hvdWxkXG4gICAgICAgKiBjbG9uZSBpdCByYXRoZXIgdGhhbiBtb2RpZnkgaXQgaW4gcGxhY2UuICBJZiB0aGUgZ2V0dGVyIGRvZXMgZXhwZW5zaXZlXG4gICAgICAgKiB3b3JrIHN1Y2ggYXMgY2xvbmluZy9tb2RpZnlpbmcgYSB0ZW1wbGF0ZSwgaXQgc2hvdWxkIG1lbW9pemUgdGhlXG4gICAgICAgKiB0ZW1wbGF0ZSBmb3IgbWF4aW11bSBwZXJmb3JtYW5jZTpcbiAgICAgICAqXG4gICAgICAgKiAgIGxldCBtZW1vaXplZFRlbXBsYXRlO1xuICAgICAgICogICBjbGFzcyBNeVN1YkNsYXNzIGV4dGVuZHMgTXlTdXBlckNsYXNzIHtcbiAgICAgICAqICAgICBzdGF0aWMgZ2V0IHRlbXBsYXRlKCkge1xuICAgICAgICogICAgICAgaWYgKCFtZW1vaXplZFRlbXBsYXRlKSB7XG4gICAgICAgKiAgICAgICAgIG1lbW9pemVkVGVtcGxhdGUgPSBzdXBlci50ZW1wbGF0ZS5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgICAgKiAgICAgICAgIGxldCBzdWJDb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgKiAgICAgICAgIHN1YkNvbnRlbnQudGV4dENvbnRlbnQgPSAnVGhpcyBjYW1lIGZyb20gTXlTdWJDbGFzcyc7XG4gICAgICAgKiAgICAgICAgIG1lbW9pemVkVGVtcGxhdGUuY29udGVudC5hcHBlbmRDaGlsZChzdWJDb250ZW50KTtcbiAgICAgICAqICAgICAgIH1cbiAgICAgICAqICAgICAgIHJldHVybiBtZW1vaXplZFRlbXBsYXRlO1xuICAgICAgICogICAgIH1cbiAgICAgICAqICAgfVxuICAgICAgICpcbiAgICAgICAqIEByZXR1cm4ge0hUTUxUZW1wbGF0ZUVsZW1lbnR8c3RyaW5nfSBUZW1wbGF0ZSB0byBiZSBzdGFtcGVkXG4gICAgICAgKi9cbiAgICAgIHN0YXRpYyBnZXQgdGVtcGxhdGUoKSB7XG4gICAgICAgIGlmICghdGhpcy5oYXNPd25Qcm9wZXJ0eShKU0NvbXBpbGVyX3JlbmFtZVByb3BlcnR5KCdfdGVtcGxhdGUnLCB0aGlzKSkpIHtcbiAgICAgICAgICB0aGlzLl90ZW1wbGF0ZSA9IFBvbHltZXIuRG9tTW9kdWxlICYmIFBvbHltZXIuRG9tTW9kdWxlLmltcG9ydChcbiAgICAgICAgICAgIC8qKiBAdHlwZSBQb2x5bWVyRWxlbWVudENvbnN0cnVjdG9yKi8gKHRoaXMpLmlzLCAndGVtcGxhdGUnKSB8fFxuICAgICAgICAgICAgLy8gbm90ZTogaW1wbGVtZW50ZWQgc28gYSBzdWJjbGFzcyBjYW4gcmV0cmlldmUgdGhlIHN1cGVyXG4gICAgICAgICAgICAvLyB0ZW1wbGF0ZTsgY2FsbCB0aGUgc3VwZXIgaW1wbCB0aGlzIHdheSBzbyB0aGF0IGB0aGlzYCBwb2ludHNcbiAgICAgICAgICAgIC8vIHRvIHRoZSBzdXBlcmNsYXNzLlxuICAgICAgICAgICAgT2JqZWN0LmdldFByb3RvdHlwZU9mKC8qKiBAdHlwZSBQb2x5bWVyRWxlbWVudENvbnN0cnVjdG9yKi8gKHRoaXMpLnByb3RvdHlwZSkuY29uc3RydWN0b3IudGVtcGxhdGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3RlbXBsYXRlO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFBhdGggbWF0Y2hpbmcgdGhlIHVybCBmcm9tIHdoaWNoIHRoZSBlbGVtZW50IHdhcyBpbXBvcnRlZC5cbiAgICAgICAqIFRoaXMgcGF0aCBpcyB1c2VkIHRvIHJlc29sdmUgdXJsJ3MgaW4gdGVtcGxhdGUgc3R5bGUgY3NzVGV4dC5cbiAgICAgICAqIFRoZSBgaW1wb3J0UGF0aGAgcHJvcGVydHkgaXMgYWxzbyBzZXQgb24gZWxlbWVudCBpbnN0YW5jZXMgYW5kIGNhbiBiZVxuICAgICAgICogdXNlZCB0byBjcmVhdGUgYmluZGluZ3MgcmVsYXRpdmUgdG8gdGhlIGltcG9ydCBwYXRoLlxuICAgICAgICogRGVmYXVsdHMgdG8gdGhlIHBhdGggbWF0Y2hpbmcgdGhlIHVybCBjb250YWluaW5nIGEgYGRvbS1tb2R1bGVgIGVsZW1lbnRcbiAgICAgICAqIG1hdGNoaW5nIHRoaXMgZWxlbWVudCdzIHN0YXRpYyBgaXNgIHByb3BlcnR5LlxuICAgICAgICogTm90ZSwgdGhpcyBwYXRoIHNob3VsZCBjb250YWluIGEgdHJhaWxpbmcgYC9gLlxuICAgICAgICpcbiAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGltcG9ydCBwYXRoIGZvciB0aGlzIGVsZW1lbnQgY2xhc3NcbiAgICAgICAqL1xuICAgICAgc3RhdGljIGdldCBpbXBvcnRQYXRoKCkge1xuICAgICAgICBpZiAoIXRoaXMuaGFzT3duUHJvcGVydHkoSlNDb21waWxlcl9yZW5hbWVQcm9wZXJ0eSgnX2ltcG9ydFBhdGgnLCB0aGlzKSkpIHtcbiAgICAgICAgICAgIGNvbnN0IG1vZHVsZSA9IFBvbHltZXIuRG9tTW9kdWxlICYmIFBvbHltZXIuRG9tTW9kdWxlLmltcG9ydCgvKiogQHR5cGUgUG9seW1lckVsZW1lbnRDb25zdHJ1Y3RvciAqLyAodGhpcykuaXMpO1xuICAgICAgICAgICAgdGhpcy5faW1wb3J0UGF0aCA9IG1vZHVsZSA/IG1vZHVsZS5hc3NldHBhdGggOiAnJyB8fFxuICAgICAgICAgICAgT2JqZWN0LmdldFByb3RvdHlwZU9mKC8qKiBAdHlwZSBQb2x5bWVyRWxlbWVudENvbnN0cnVjdG9yKi8gKHRoaXMpLnByb3RvdHlwZSkuY29uc3RydWN0b3IuaW1wb3J0UGF0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5faW1wb3J0UGF0aDtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBPdmVycmlkZXMgdGhlIGRlZmF1bHQgYFBvbHltZXIuUHJvcGVydHlBY2Nlc3NvcnNgIHRvIGVuc3VyZSBjbGFzc1xuICAgICAgICogbWV0YXByb2dyYW1taW5nIHJlbGF0ZWQgdG8gcHJvcGVydHkgYWNjZXNzb3JzIGFuZCBlZmZlY3RzIGhhc1xuICAgICAgICogY29tcGxldGVkIChjYWxscyBgZmluYWxpemVgKS5cbiAgICAgICAqXG4gICAgICAgKiBJdCBhbHNvIGluaXRpYWxpemVzIGFueSBwcm9wZXJ0eSBkZWZhdWx0cyBwcm92aWRlZCB2aWEgYHZhbHVlYCBpblxuICAgICAgICogYHByb3BlcnRpZXNgIG1ldGFkYXRhLlxuICAgICAgICpcbiAgICAgICAqIEBvdmVycmlkZVxuICAgICAgICogQHN1cHByZXNzIHtpbnZhbGlkQ2FzdHN9XG4gICAgICAgKi9cbiAgICAgIF9pbml0aWFsaXplUHJvcGVydGllcygpIHtcbiAgICAgICAgUG9seW1lci50ZWxlbWV0cnkuaW5zdGFuY2VDb3VudCsrO1xuICAgICAgICB0aGlzLmNvbnN0cnVjdG9yLmZpbmFsaXplKCk7XG4gICAgICAgIGNvbnN0IGltcG9ydFBhdGggPSB0aGlzLmNvbnN0cnVjdG9yLmltcG9ydFBhdGg7XG4gICAgICAgIC8vIG5vdGU6IGZpbmFsaXplIHRlbXBsYXRlIHdoZW4gd2UgaGF2ZSBhY2Nlc3MgdG8gYGxvY2FsTmFtZWAgdG9cbiAgICAgICAgLy8gYXZvaWQgZGVwZW5kZW5jZSBvbiBgaXNgIGZvciBwb2x5ZmlsbGluZyBzdHlsaW5nLlxuICAgICAgICBpZiAodGhpcy5fdGVtcGxhdGUgJiYgIXRoaXMuX3RlbXBsYXRlLl9fcG9seW1lckZpbmFsaXplZCkge1xuICAgICAgICAgIHRoaXMuX3RlbXBsYXRlLl9fcG9seW1lckZpbmFsaXplZCA9IHRydWU7XG4gICAgICAgICAgY29uc3QgYmFzZVVSSSA9XG4gICAgICAgICAgICBpbXBvcnRQYXRoID8gUG9seW1lci5SZXNvbHZlVXJsLnJlc29sdmVVcmwoaW1wb3J0UGF0aCkgOiAnJztcbiAgICAgICAgICBmaW5hbGl6ZVRlbXBsYXRlKC8qKiBAdHlwZSB7IVBvbHltZXJFbGVtZW50fSAqLyh0aGlzLl9fcHJvdG9fXyksIHRoaXMuX3RlbXBsYXRlLCBiYXNlVVJJLFxuICAgICAgICAgICAgLyoqQHR5cGUgeyFIVE1MRWxlbWVudH0qLyh0aGlzKS5sb2NhbE5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyLl9pbml0aWFsaXplUHJvcGVydGllcygpO1xuICAgICAgICAvLyBzZXQgcGF0aCBkZWZhdWx0c1xuICAgICAgICB0aGlzLnJvb3RQYXRoID0gUG9seW1lci5yb290UGF0aDtcbiAgICAgICAgdGhpcy5pbXBvcnRQYXRoID0gaW1wb3J0UGF0aDtcbiAgICAgICAgLy8gYXBwbHkgcHJvcGVydHkgZGVmYXVsdHMuLi5cbiAgICAgICAgbGV0IHAkID0gcHJvcGVydHlEZWZhdWx0c0ZvckNsYXNzKHRoaXMuY29uc3RydWN0b3IpO1xuICAgICAgICBpZiAoIXAkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IHAgaW4gcCQpIHtcbiAgICAgICAgICBsZXQgaW5mbyA9IHAkW3BdO1xuICAgICAgICAgIC8vIERvbid0IHNldCBkZWZhdWx0IHZhbHVlIGlmIHRoZXJlIGlzIGFscmVhZHkgYW4gb3duIHByb3BlcnR5LCB3aGljaFxuICAgICAgICAgIC8vIGhhcHBlbnMgd2hlbiBhIGBwcm9wZXJ0aWVzYCBwcm9wZXJ0eSB3aXRoIGRlZmF1bHQgYnV0IG5vIGVmZmVjdHMgaGFkXG4gICAgICAgICAgLy8gYSBwcm9wZXJ0eSBzZXQgKGUuZy4gYm91bmQpIGJ5IGl0cyBob3N0IGJlZm9yZSB1cGdyYWRlXG4gICAgICAgICAgaWYgKCF0aGlzLmhhc093blByb3BlcnR5KHApKSB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSB0eXBlb2YgaW5mby52YWx1ZSA9PSAnZnVuY3Rpb24nID9cbiAgICAgICAgICAgICAgaW5mby52YWx1ZS5jYWxsKHRoaXMpIDpcbiAgICAgICAgICAgICAgaW5mby52YWx1ZTtcbiAgICAgICAgICAgIC8vIFNldCB2aWEgYF9zZXRQcm9wZXJ0eWAgaWYgdGhlcmUgaXMgYW4gYWNjZXNzb3IsIHRvIGVuYWJsZVxuICAgICAgICAgICAgLy8gaW5pdGlhbGl6aW5nIHJlYWRPbmx5IHByb3BlcnR5IGRlZmF1bHRzXG4gICAgICAgICAgICBpZiAodGhpcy5faGFzQWNjZXNzb3IocCkpIHtcbiAgICAgICAgICAgICAgdGhpcy5fc2V0UGVuZGluZ1Byb3BlcnR5KHAsIHZhbHVlLCB0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXNbcF0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBQcm92aWRlcyBhIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gb2YgdGhlIHN0YW5kYXJkIEN1c3RvbSBFbGVtZW50c1xuICAgICAgICogYGNvbm5lY3RlZENhbGxiYWNrYC5cbiAgICAgICAqXG4gICAgICAgKiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBlbmFibGVzIHRoZSBwcm9wZXJ0eSBlZmZlY3RzIHN5c3RlbSBhbmRcbiAgICAgICAqIGZsdXNoZXMgYW55IHBlbmRpbmcgcHJvcGVydGllcywgYW5kIHVwZGF0ZXMgc2hpbW1lZCBDU1MgcHJvcGVydGllc1xuICAgICAgICogd2hlbiB1c2luZyB0aGUgU2hhZHlDU1Mgc2NvcGluZy9jdXN0b20gcHJvcGVydGllcyBwb2x5ZmlsbC5cbiAgICAgICAqXG4gICAgICAgKiBAc3VwcHJlc3Mge2ludmFsaWRDYXN0c31cbiAgICAgICAqL1xuICAgICAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgICAgIGlmICh3aW5kb3cuU2hhZHlDU1MgJiYgdGhpcy5fdGVtcGxhdGUpIHtcbiAgICAgICAgICB3aW5kb3cuU2hhZHlDU1Muc3R5bGVFbGVtZW50KC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqLyh0aGlzKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZW5hYmxlUHJvcGVydGllcygpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFByb3ZpZGVzIGEgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgc3RhbmRhcmQgQ3VzdG9tIEVsZW1lbnRzXG4gICAgICAgKiBgZGlzY29ubmVjdGVkQ2FsbGJhY2tgLlxuICAgICAgICovXG4gICAgICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHt9XG5cbiAgICAgIC8qKlxuICAgICAgICogU3RhbXBzIHRoZSBlbGVtZW50IHRlbXBsYXRlLlxuICAgICAgICpcbiAgICAgICAqIEBvdmVycmlkZVxuICAgICAgICovXG4gICAgICByZWFkeSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3RlbXBsYXRlKSB7XG4gICAgICAgICAgdGhpcy5yb290ID0gdGhpcy5fc3RhbXBUZW1wbGF0ZSh0aGlzLl90ZW1wbGF0ZSk7XG4gICAgICAgICAgdGhpcy4kID0gdGhpcy5yb290LiQ7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIucmVhZHkoKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBJbXBsZW1lbnRzIGBQcm9wZXJ0eUVmZmVjdHNgJ3MgYF9yZWFkeUNsaWVudHNgIGNhbGwuIEF0dGFjaGVzXG4gICAgICAgKiBlbGVtZW50IGRvbSBieSBjYWxsaW5nIGBfYXR0YWNoRG9tYCB3aXRoIHRoZSBkb20gc3RhbXBlZCBmcm9tIHRoZVxuICAgICAgICogZWxlbWVudCdzIHRlbXBsYXRlIHZpYSBgX3N0YW1wVGVtcGxhdGVgLiBOb3RlIHRoYXQgdGhpcyBhbGxvd3NcbiAgICAgICAqIGNsaWVudCBkb20gdG8gYmUgYXR0YWNoZWQgdG8gdGhlIGVsZW1lbnQgcHJpb3IgdG8gYW55IG9ic2VydmVyc1xuICAgICAgICogcnVubmluZy5cbiAgICAgICAqXG4gICAgICAgKiBAb3ZlcnJpZGVcbiAgICAgICAqL1xuICAgICAgX3JlYWR5Q2xpZW50cygpIHtcbiAgICAgICAgaWYgKHRoaXMuX3RlbXBsYXRlKSB7XG4gICAgICAgICAgdGhpcy5yb290ID0gdGhpcy5fYXR0YWNoRG9tKHRoaXMucm9vdCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlIHN1cGVyLl9yZWFkeUNsaWVudHMgaGVyZSBzZXRzIHRoZSBjbGllbnRzIGluaXRpYWxpemVkIGZsYWcuXG4gICAgICAgIC8vIFdlIG11c3Qgd2FpdCB0byBkbyB0aGlzIHVudGlsIGFmdGVyIGNsaWVudCBkb20gaXMgY3JlYXRlZC9hdHRhY2hlZFxuICAgICAgICAvLyBzbyB0aGF0IHRoaXMgZmxhZyBjYW4gYmUgY2hlY2tlZCB0byBwcmV2ZW50IG5vdGlmaWNhdGlvbnMgZmlyZWRcbiAgICAgICAgLy8gZHVyaW5nIHRoaXMgcHJvY2VzcyBmcm9tIGJlaW5nIGhhbmRsZWQgYmVmb3JlIGNsaWVudHMgYXJlIHJlYWR5LlxuICAgICAgICBzdXBlci5fcmVhZHlDbGllbnRzKCk7XG4gICAgICB9XG5cblxuICAgICAgLyoqXG4gICAgICAgKiBBdHRhY2hlcyBhbiBlbGVtZW50J3Mgc3RhbXBlZCBkb20gdG8gaXRzZWxmLiBCeSBkZWZhdWx0LFxuICAgICAgICogdGhpcyBtZXRob2QgY3JlYXRlcyBhIGBzaGFkb3dSb290YCBhbmQgYWRkcyB0aGUgZG9tIHRvIGl0LlxuICAgICAgICogSG93ZXZlciwgdGhpcyBtZXRob2QgbWF5IGJlIG92ZXJyaWRkZW4gdG8gYWxsb3cgYW4gZWxlbWVudFxuICAgICAgICogdG8gcHV0IGl0cyBkb20gaW4gYW5vdGhlciBsb2NhdGlvbi5cbiAgICAgICAqXG4gICAgICAgKiBAdGhyb3dzIHtFcnJvcn1cbiAgICAgICAqIEBzdXBwcmVzcyB7bWlzc2luZ1JldHVybn1cbiAgICAgICAqIEBwYXJhbSB7Tm9kZUxpc3R9IGRvbSB0byBhdHRhY2ggdG8gdGhlIGVsZW1lbnQuXG4gICAgICAgKiBAcmV0dXJuIHtOb2RlfSBub2RlIHRvIHdoaWNoIHRoZSBkb20gaGFzIGJlZW4gYXR0YWNoZWQuXG4gICAgICAgKi9cbiAgICAgIF9hdHRhY2hEb20oZG9tKSB7XG4gICAgICAgIGlmICh0aGlzLmF0dGFjaFNoYWRvdykge1xuICAgICAgICAgIGlmIChkb20pIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5zaGFkb3dSb290KSB7XG4gICAgICAgICAgICAgIHRoaXMuYXR0YWNoU2hhZG93KHttb2RlOiAnb3Blbid9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2hhZG93Um9vdC5hcHBlbmRDaGlsZChkb20pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2hhZG93Um9vdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTaGFkb3dET00gbm90IGF2YWlsYWJsZS4gJyArXG4gICAgICAgICAgICAvLyBUT0RPKHNvcnZlbGwpOiBtb3ZlIHRvIGNvbXBpbGUtdGltZSBjb25kaXRpb25hbCB3aGVuIHN1cHBvcnRlZFxuICAgICAgICAgICdQb2x5bWVyLkVsZW1lbnQgY2FuIGNyZWF0ZSBkb20gYXMgY2hpbGRyZW4gaW5zdGVhZCBvZiBpbiAnICtcbiAgICAgICAgICAnU2hhZG93RE9NIGJ5IHNldHRpbmcgYHRoaXMucm9vdCA9IHRoaXM7XFxgIGJlZm9yZSBcXGByZWFkeVxcYC4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFByb3ZpZGVzIGEgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgc3RhbmRhcmQgQ3VzdG9tIEVsZW1lbnRzXG4gICAgICAgKiBgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrYC5cbiAgICAgICAqXG4gICAgICAgKiBCeSBkZWZhdWx0LCBhdHRyaWJ1dGVzIGRlY2xhcmVkIGluIGBwcm9wZXJ0aWVzYCBtZXRhZGF0YSBhcmVcbiAgICAgICAqIGRlc2VyaWFsaXplZCB1c2luZyB0aGVpciBgdHlwZWAgaW5mb3JtYXRpb24gdG8gcHJvcGVydGllcyBvZiB0aGVcbiAgICAgICAqIHNhbWUgbmFtZS4gIFwiRGFzaC1jYXNlZFwiIGF0dHJpYnV0ZXMgYXJlIGRlc2VyaWFsemVkIHRvIFwiY2FtZWxDYXNlXCJcbiAgICAgICAqIHByb3BlcnRpZXMuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgTmFtZSBvZiBhdHRyaWJ1dGUuXG4gICAgICAgKiBAcGFyYW0gez9zdHJpbmd9IG9sZCBPbGQgdmFsdWUgb2YgYXR0cmlidXRlLlxuICAgICAgICogQHBhcmFtIHs/c3RyaW5nfSB2YWx1ZSBDdXJyZW50IHZhbHVlIG9mIGF0dHJpYnV0ZS5cbiAgICAgICAqIEBvdmVycmlkZVxuICAgICAgICovXG4gICAgICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgb2xkLCB2YWx1ZSkge1xuICAgICAgICBpZiAob2xkICE9PSB2YWx1ZSkge1xuICAgICAgICAgIGxldCBwcm9wZXJ0eSA9IGNhc2VNYXAuZGFzaFRvQ2FtZWxDYXNlKG5hbWUpO1xuICAgICAgICAgIGxldCB0eXBlID0gcHJvcGVydGllc0ZvckNsYXNzKHRoaXMuY29uc3RydWN0b3IpW3Byb3BlcnR5XS50eXBlO1xuICAgICAgICAgIGlmICghdGhpcy5faGFzUmVhZE9ubHlFZmZlY3QocHJvcGVydHkpKSB7XG4gICAgICAgICAgICB0aGlzLl9hdHRyaWJ1dGVUb1Byb3BlcnR5KG5hbWUsIHZhbHVlLCB0eXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBXaGVuIHVzaW5nIHRoZSBTaGFkeUNTUyBzY29waW5nIGFuZCBjdXN0b20gcHJvcGVydHkgc2hpbSwgY2F1c2VzIGFsbFxuICAgICAgICogc2hpbW1lZCBzdHlsZXMgaW4gdGhpcyBlbGVtZW50IChhbmQgaXRzIHN1YnRyZWUpIHRvIGJlIHVwZGF0ZWRcbiAgICAgICAqIGJhc2VkIG9uIGN1cnJlbnQgY3VzdG9tIHByb3BlcnR5IHZhbHVlcy5cbiAgICAgICAqXG4gICAgICAgKiBUaGUgb3B0aW9uYWwgcGFyYW1ldGVyIG92ZXJyaWRlcyBpbmxpbmUgY3VzdG9tIHByb3BlcnR5IHN0eWxlcyB3aXRoIGFuXG4gICAgICAgKiBvYmplY3Qgb2YgcHJvcGVydGllcyB3aGVyZSB0aGUga2V5cyBhcmUgQ1NTIHByb3BlcnRpZXMsIGFuZCB0aGUgdmFsdWVzXG4gICAgICAgKiBhcmUgc3RyaW5ncy5cbiAgICAgICAqXG4gICAgICAgKiBFeGFtcGxlOiBgdGhpcy51cGRhdGVTdHlsZXMoeyctLWNvbG9yJzogJ2JsdWUnfSlgXG4gICAgICAgKlxuICAgICAgICogVGhlc2UgcHJvcGVydGllcyBhcmUgcmV0YWluZWQgdW5sZXNzIGEgdmFsdWUgb2YgYG51bGxgIGlzIHNldC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge09iamVjdD19IHByb3BlcnRpZXMgQmFnIG9mIGN1c3RvbSBwcm9wZXJ0eSBrZXkvdmFsdWVzIHRvXG4gICAgICAgKiAgIGFwcGx5IHRvIHRoaXMgZWxlbWVudC5cbiAgICAgICAqIEBzdXBwcmVzcyB7aW52YWxpZENhc3RzfVxuICAgICAgICovXG4gICAgICB1cGRhdGVTdHlsZXMocHJvcGVydGllcykge1xuICAgICAgICBpZiAod2luZG93LlNoYWR5Q1NTKSB7XG4gICAgICAgICAgd2luZG93LlNoYWR5Q1NTLnN0eWxlU3VidHJlZSgvKiogQHR5cGUgeyFIVE1MRWxlbWVudH0gKi8odGhpcyksIHByb3BlcnRpZXMpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUmV3cml0ZXMgYSBnaXZlbiBVUkwgcmVsYXRpdmUgdG8gYSBiYXNlIFVSTC4gVGhlIGJhc2UgVVJMIGRlZmF1bHRzIHRvXG4gICAgICAgKiB0aGUgb3JpZ2luYWwgbG9jYXRpb24gb2YgdGhlIGRvY3VtZW50IGNvbnRhaW5pbmcgdGhlIGBkb20tbW9kdWxlYCBmb3JcbiAgICAgICAqIHRoaXMgZWxlbWVudC4gVGhpcyBtZXRob2Qgd2lsbCByZXR1cm4gdGhlIHNhbWUgVVJMIGJlZm9yZSBhbmQgYWZ0ZXJcbiAgICAgICAqIGJ1bmRsaW5nLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVVJMIHRvIHJlc29sdmUuXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZz19IGJhc2UgT3B0aW9uYWwgYmFzZSBVUkwgdG8gcmVzb2x2ZSBhZ2FpbnN0LCBkZWZhdWx0c1xuICAgICAgICogdG8gdGhlIGVsZW1lbnQncyBgaW1wb3J0UGF0aGBcbiAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gUmV3cml0dGVuIFVSTCByZWxhdGl2ZSB0byBiYXNlXG4gICAgICAgKi9cbiAgICAgIHJlc29sdmVVcmwodXJsLCBiYXNlKSB7XG4gICAgICAgIGlmICghYmFzZSAmJiB0aGlzLmltcG9ydFBhdGgpIHtcbiAgICAgICAgICBiYXNlID0gUG9seW1lci5SZXNvbHZlVXJsLnJlc29sdmVVcmwodGhpcy5pbXBvcnRQYXRoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUG9seW1lci5SZXNvbHZlVXJsLnJlc29sdmVVcmwodXJsLCBiYXNlKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBPdmVycmlkZXMgYFByb3BlcnR5QWNjZXNzb3JzYCB0byBhZGQgbWFwIG9mIGR5bmFtaWMgZnVuY3Rpb25zIG9uXG4gICAgICAgKiB0ZW1wbGF0ZSBpbmZvLCBmb3IgY29uc3VtcHRpb24gYnkgYFByb3BlcnR5RWZmZWN0c2AgdGVtcGxhdGUgYmluZGluZ1xuICAgICAgICogY29kZS4gVGhpcyBtYXAgZGV0ZXJtaW5lcyB3aGljaCBtZXRob2QgdGVtcGxhdGVzIHNob3VsZCBoYXZlIGFjY2Vzc29yc1xuICAgICAgICogY3JlYXRlZCBmb3IgdGhlbS5cbiAgICAgICAqXG4gICAgICAgKiBAb3ZlcnJpZGVcbiAgICAgICAqIEBzdXBwcmVzcyB7bWlzc2luZ1Byb3BlcnRpZXN9IEludGVyZmFjZXMgaW4gY2xvc3VyZSBkbyBub3QgaW5oZXJpdCBzdGF0aWNzLCBidXQgY2xhc3NlcyBkb1xuICAgICAgICovXG4gICAgICBzdGF0aWMgX3BhcnNlVGVtcGxhdGVDb250ZW50KHRlbXBsYXRlLCB0ZW1wbGF0ZUluZm8sIG5vZGVJbmZvKSB7XG4gICAgICAgIHRlbXBsYXRlSW5mby5keW5hbWljRm5zID0gdGVtcGxhdGVJbmZvLmR5bmFtaWNGbnMgfHwgcHJvcGVydGllc0ZvckNsYXNzKHRoaXMpO1xuICAgICAgICByZXR1cm4gc3VwZXIuX3BhcnNlVGVtcGxhdGVDb250ZW50KHRlbXBsYXRlLCB0ZW1wbGF0ZUluZm8sIG5vZGVJbmZvKTtcbiAgICAgIH1cblxuICAgIH1cblxuICAgIHJldHVybiBQb2x5bWVyRWxlbWVudDtcbiAgfSk7XG5cbiAgLyoqXG4gICAqIFByb3ZpZGVzIGJhc2ljIHRyYWNraW5nIG9mIGVsZW1lbnQgZGVmaW5pdGlvbnMgKHJlZ2lzdHJhdGlvbnMpIGFuZFxuICAgKiBpbnN0YW5jZSBjb3VudHMuXG4gICAqXG4gICAqIEBuYW1lc3BhY2VcbiAgICogQHN1bW1hcnkgUHJvdmlkZXMgYmFzaWMgdHJhY2tpbmcgb2YgZWxlbWVudCBkZWZpbml0aW9ucyAocmVnaXN0cmF0aW9ucykgYW5kXG4gICAqIGluc3RhbmNlIGNvdW50cy5cbiAgICovXG4gIFBvbHltZXIudGVsZW1ldHJ5ID0ge1xuICAgIC8qKlxuICAgICAqIFRvdGFsIG51bWJlciBvZiBQb2x5bWVyIGVsZW1lbnQgaW5zdGFuY2VzIGNyZWF0ZWQuXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICBpbnN0YW5jZUNvdW50OiAwLFxuICAgIC8qKlxuICAgICAqIEFycmF5IG9mIFBvbHltZXIgZWxlbWVudCBjbGFzc2VzIHRoYXQgaGF2ZSBiZWVuIGZpbmFsaXplZC5cbiAgICAgKiBAdHlwZSB7QXJyYXk8UG9seW1lci5FbGVtZW50Pn1cbiAgICAgKi9cbiAgICByZWdpc3RyYXRpb25zOiBbXSxcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyFQb2x5bWVyRWxlbWVudENvbnN0cnVjdG9yfSBwcm90b3R5cGUgRWxlbWVudCBwcm90b3R5cGUgdG8gbG9nXG4gICAgICogQHRoaXMge3RoaXN9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVnTG9nOiBmdW5jdGlvbihwcm90b3R5cGUpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdbJyArIHByb3RvdHlwZS5pcyArICddOiByZWdpc3RlcmVkJylcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBhIGNsYXNzIHByb3RvdHlwZSBmb3IgdGVsZW1ldHJ5IHB1cnBvc2VzLlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHByb3RvdHlwZSBFbGVtZW50IHByb3RvdHlwZSB0byByZWdpc3RlclxuICAgICAqIEB0aGlzIHt0aGlzfVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICByZWdpc3RlcjogZnVuY3Rpb24ocHJvdG90eXBlKSB7XG4gICAgICB0aGlzLnJlZ2lzdHJhdGlvbnMucHVzaChwcm90b3R5cGUpO1xuICAgICAgUG9seW1lci5sb2cgJiYgdGhpcy5fcmVnTG9nKHByb3RvdHlwZSk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBMb2dzIGFsbCBlbGVtZW50cyByZWdpc3RlcmVkIHdpdGggYW4gYGlzYCB0byB0aGUgY29uc29sZS5cbiAgICAgKiBAcHVibGljXG4gICAgICogQHRoaXMge3RoaXN9XG4gICAgICovXG4gICAgZHVtcFJlZ2lzdHJhdGlvbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5yZWdpc3RyYXRpb25zLmZvckVhY2godGhpcy5fcmVnTG9nKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFdoZW4gdXNpbmcgdGhlIFNoYWR5Q1NTIHNjb3BpbmcgYW5kIGN1c3RvbSBwcm9wZXJ0eSBzaGltLCBjYXVzZXMgYWxsXG4gICAqIHNoaW1tZWQgYHN0eWxlc2AgKHZpYSBgY3VzdG9tLXN0eWxlYCkgaW4gdGhlIGRvY3VtZW50IChhbmQgaXRzIHN1YnRyZWUpXG4gICAqIHRvIGJlIHVwZGF0ZWQgYmFzZWQgb24gY3VycmVudCBjdXN0b20gcHJvcGVydHkgdmFsdWVzLlxuICAgKlxuICAgKiBUaGUgb3B0aW9uYWwgcGFyYW1ldGVyIG92ZXJyaWRlcyBpbmxpbmUgY3VzdG9tIHByb3BlcnR5IHN0eWxlcyB3aXRoIGFuXG4gICAqIG9iamVjdCBvZiBwcm9wZXJ0aWVzIHdoZXJlIHRoZSBrZXlzIGFyZSBDU1MgcHJvcGVydGllcywgYW5kIHRoZSB2YWx1ZXNcbiAgICogYXJlIHN0cmluZ3MuXG4gICAqXG4gICAqIEV4YW1wbGU6IGBQb2x5bWVyLnVwZGF0ZVN0eWxlcyh7Jy0tY29sb3InOiAnYmx1ZSd9KWBcbiAgICpcbiAgICogVGhlc2UgcHJvcGVydGllcyBhcmUgcmV0YWluZWQgdW5sZXNzIGEgdmFsdWUgb2YgYG51bGxgIGlzIHNldC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3Q9fSBwcm9wcyBCYWcgb2YgY3VzdG9tIHByb3BlcnR5IGtleS92YWx1ZXMgdG9cbiAgICogICBhcHBseSB0byB0aGUgZG9jdW1lbnQuXG4gICAqL1xuICBQb2x5bWVyLnVwZGF0ZVN0eWxlcyA9IGZ1bmN0aW9uKHByb3BzKSB7XG4gICAgaWYgKHdpbmRvdy5TaGFkeUNTUykge1xuICAgICAgd2luZG93LlNoYWR5Q1NTLnN0eWxlRG9jdW1lbnQocHJvcHMpO1xuICAgIH1cbiAgfTtcblxufSkoKTtcbjwvc2NyaXB0PlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi9taXhpbnMvZWxlbWVudC1taXhpbi5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuXG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vdXRpbHMvYm9vdC5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vdXRpbHMvcmVzb2x2ZS11cmwuaHRtbFwiPlxuXG48c2NyaXB0PlxuLyoqIEBzdXBwcmVzcyB7ZGVwcmVjYXRlZH0gKi9cbihmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8qKlxuICAgKiBMZWdhY3kgc2V0dGluZ3MuXG4gICAqIEBuYW1lc3BhY2VcbiAgICogQG1lbWJlcm9mIFBvbHltZXJcbiAgICovXG4gIGNvbnN0IHNldHRpbmdzID0gUG9seW1lci5TZXR0aW5ncyB8fCB7fTtcbiAgc2V0dGluZ3MudXNlU2hhZG93ID0gISh3aW5kb3cuU2hhZHlET00pO1xuICBzZXR0aW5ncy51c2VOYXRpdmVDU1NQcm9wZXJ0aWVzID1cbiAgICBCb29sZWFuKCF3aW5kb3cuU2hhZHlDU1MgfHwgd2luZG93LlNoYWR5Q1NTLm5hdGl2ZUNzcyk7XG4gIHNldHRpbmdzLnVzZU5hdGl2ZUN1c3RvbUVsZW1lbnRzID1cbiAgICAhKHdpbmRvdy5jdXN0b21FbGVtZW50cy5wb2x5ZmlsbFdyYXBGbHVzaENhbGxiYWNrKTtcblxuICAvKipcbiAgICogU2V0cyB0aGUgZ2xvYmFsLCBsZWdhY3kgc2V0dGluZ3MuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkXG4gICAqIEBtZW1iZXJvZiBQb2x5bWVyXG4gICAqL1xuICBQb2x5bWVyLlNldHRpbmdzID0gc2V0dGluZ3M7XG5cbiAgLyoqXG4gICAqIEdsb2JhbGx5IHNldHRhYmxlIHByb3BlcnR5IHRoYXQgaXMgYXV0b21hdGljYWxseSBhc3NpZ25lZCB0b1xuICAgKiBgUG9seW1lci5FbGVtZW50TWl4aW5gIGluc3RhbmNlcywgdXNlZnVsIGZvciBiaW5kaW5nIGluIHRlbXBsYXRlcyB0b1xuICAgKiBtYWtlIFVSTCdzIHJlbGF0aXZlIHRvIGFuIGFwcGxpY2F0aW9uJ3Mgcm9vdC4gIERlZmF1bHRzIHRvIHRoZSBtYWluXG4gICAqIGRvY3VtZW50IFVSTCwgYnV0IGNhbiBiZSBvdmVycmlkZGVuIGJ5IHVzZXJzLiAgSXQgbWF5IGJlIHVzZWZ1bCB0byBzZXRcbiAgICogYFBvbHltZXIucm9vdFBhdGhgIHRvIHByb3ZpZGUgYSBzdGFibGUgYXBwbGljYXRpb24gbW91bnQgcGF0aCB3aGVuXG4gICAqIHVzaW5nIGNsaWVudCBzaWRlIHJvdXRpbmcuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBQb2x5bWVyXG4gICAqL1xuICBsZXQgcm9vdFBhdGggPSBQb2x5bWVyLnJvb3RQYXRoIHx8XG4gICAgUG9seW1lci5SZXNvbHZlVXJsLnBhdGhGcm9tVXJsKGRvY3VtZW50LmJhc2VVUkkgfHwgd2luZG93LmxvY2F0aW9uLmhyZWYpO1xuXG4gIFBvbHltZXIucm9vdFBhdGggPSByb290UGF0aDtcblxuICAvKipcbiAgICogU2V0cyB0aGUgZ2xvYmFsIHJvb3RQYXRoIHByb3BlcnR5IHVzZWQgYnkgYFBvbHltZXIuRWxlbWVudE1peGluYCBhbmRcbiAgICogYXZhaWxhYmxlIHZpYSBgUG9seW1lci5yb290UGF0aGAuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBQb2x5bWVyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFRoZSBuZXcgcm9vdCBwYXRoXG4gICAqL1xuICBQb2x5bWVyLnNldFJvb3RQYXRoID0gZnVuY3Rpb24ocGF0aCkge1xuICAgIFBvbHltZXIucm9vdFBhdGggPSBwYXRoO1xuICB9XG59KSgpO1xuPC9zY3JpcHQ+XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi91dGlscy9zZXR0aW5ncy5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cInJlc29sdmUtdXJsLmh0bWxcIj5cbjxzY3JpcHQ+XG4oZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBjb25zdCBNT0RVTEVfU1RZTEVfTElOS19TRUxFQ1RPUiA9ICdsaW5rW3JlbD1pbXBvcnRdW3R5cGV+PWNzc10nO1xuICBjb25zdCBJTkNMVURFX0FUVFIgPSAnaW5jbHVkZSc7XG5cbiAgZnVuY3Rpb24gaW1wb3J0TW9kdWxlKG1vZHVsZUlkKSB7XG4gICAgaWYgKCFQb2x5bWVyLkRvbU1vZHVsZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBQb2x5bWVyLkRvbU1vZHVsZS5pbXBvcnQobW9kdWxlSWQpO1xuICB9XG5cbiAgLyoqIEB0eXBlZGVmIHt7YXNzZXRwYXRoOiBzdHJpbmd9fSAqL1xuICBsZXQgdGVtcGxhdGVXaXRoQXNzZXRQYXRoOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cbiAgLyoqXG4gICAqIE1vZHVsZSB3aXRoIHV0aWxpdGllcyBmb3IgY29sbGVjdGlvbiBDU1MgdGV4dCBmcm9tIGA8dGVtcGxhdGVzPmAsIGV4dGVybmFsXG4gICAqIHN0eWxlc2hlZXRzLCBhbmQgYGRvbS1tb2R1bGVgcy5cbiAgICpcbiAgICogQG5hbWVzcGFjZVxuICAgKiBAbWVtYmVyb2YgUG9seW1lclxuICAgKiBAc3VtbWFyeSBNb2R1bGUgd2l0aCB1dGlsaXRpZXMgZm9yIGNvbGxlY3Rpb24gQ1NTIHRleHQgZnJvbSB2YXJpb3VzIHNvdXJjZXMuXG4gICAqL1xuICBjb25zdCBTdHlsZUdhdGhlciA9IHtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgQ1NTIHRleHQgb2Ygc3R5bGVzIGluIGEgc3BhY2Utc2VwYXJhdGVkIGxpc3Qgb2YgYGRvbS1tb2R1bGVgcy5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBQb2x5bWVyLlN0eWxlR2F0aGVyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1vZHVsZUlkcyBMaXN0IG9mIGRvbS1tb2R1bGUgaWQncyB3aXRoaW4gd2hpY2ggdG9cbiAgICAgKiBzZWFyY2ggZm9yIGNzcy5cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IENvbmNhdGVuYXRlZCBDU1MgY29udGVudCBmcm9tIHNwZWNpZmllZCBgZG9tLW1vZHVsZWBzXG4gICAgICogQHRoaXMge1N0eWxlR2F0aGVyfVxuICAgICAqL1xuICAgIGNzc0Zyb21Nb2R1bGVzKG1vZHVsZUlkcykge1xuICAgICAgbGV0IG1vZHVsZXMgPSBtb2R1bGVJZHMudHJpbSgpLnNwbGl0KCcgJyk7XG4gICAgICBsZXQgY3NzVGV4dCA9ICcnO1xuICAgICAgZm9yIChsZXQgaT0wOyBpIDwgbW9kdWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjc3NUZXh0ICs9IHRoaXMuY3NzRnJvbU1vZHVsZShtb2R1bGVzW2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjc3NUZXh0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIENTUyB0ZXh0IG9mIHN0eWxlcyBpbiBhIGdpdmVuIGBkb20tbW9kdWxlYC4gIENTUyBpbiBhIGBkb20tbW9kdWxlYFxuICAgICAqIGNhbiBjb21lIGVpdGhlciBmcm9tIGA8c3R5bGU+YHMgd2l0aGluIHRoZSBmaXJzdCBgPHRlbXBsYXRlPmAsIG9yIGVsc2VcbiAgICAgKiBmcm9tIG9uZSBvciBtb3JlIGA8bGluayByZWw9XCJpbXBvcnRcIiB0eXBlPVwiY3NzXCI+YCBsaW5rcyBvdXRzaWRlIHRoZVxuICAgICAqIHRlbXBsYXRlLlxuICAgICAqXG4gICAgICogQW55IGA8c3R5bGVzPmAgcHJvY2Vzc2VkIGFyZSByZW1vdmVkIGZyb20gdGhlaXIgb3JpZ2luYWwgbG9jYXRpb24uXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgUG9seW1lci5TdHlsZUdhdGhlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtb2R1bGVJZCBkb20tbW9kdWxlIGlkIHRvIGdhdGhlciBzdHlsZXMgZnJvbVxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gQ29uY2F0ZW5hdGVkIENTUyBjb250ZW50IGZyb20gc3BlY2lmaWVkIGBkb20tbW9kdWxlYFxuICAgICAqIEB0aGlzIHtTdHlsZUdhdGhlcn1cbiAgICAgKi9cbiAgICBjc3NGcm9tTW9kdWxlKG1vZHVsZUlkKSB7XG4gICAgICBsZXQgbSA9IGltcG9ydE1vZHVsZShtb2R1bGVJZCk7XG4gICAgICBpZiAobSAmJiBtLl9jc3NUZXh0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IGNzc1RleHQgPSAnJztcbiAgICAgICAgLy8gaW5jbHVkZSBjc3MgZnJvbSB0aGUgZmlyc3QgdGVtcGxhdGUgaW4gdGhlIG1vZHVsZVxuICAgICAgICBsZXQgdCA9IG0ucXVlcnlTZWxlY3RvcigndGVtcGxhdGUnKTtcbiAgICAgICAgaWYgKHQpIHtcbiAgICAgICAgICBjc3NUZXh0ICs9IHRoaXMuY3NzRnJvbVRlbXBsYXRlKHQsIC8qKiBAdHlwZSB7dGVtcGxhdGVXaXRoQXNzZXRQYXRoIH0qLyhtKS5hc3NldHBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIG1vZHVsZSBpbXBvcnRzOiA8bGluayByZWw9XCJpbXBvcnRcIiB0eXBlPVwiY3NzXCI+XG4gICAgICAgIGNzc1RleHQgKz0gdGhpcy5jc3NGcm9tTW9kdWxlSW1wb3J0cyhtb2R1bGVJZCk7XG4gICAgICAgIG0uX2Nzc1RleHQgPSBjc3NUZXh0IHx8IG51bGw7XG4gICAgICB9XG4gICAgICBpZiAoIW0pIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdDb3VsZCBub3QgZmluZCBzdHlsZSBkYXRhIGluIG1vZHVsZSBuYW1lZCcsIG1vZHVsZUlkKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtICYmIG0uX2Nzc1RleHQgfHwgJyc7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgQ1NTIHRleHQgb2YgYDxzdHlsZXM+YCB3aXRoaW4gYSBnaXZlbiB0ZW1wbGF0ZS5cbiAgICAgKlxuICAgICAqIEFueSBgPHN0eWxlcz5gIHByb2Nlc3NlZCBhcmUgcmVtb3ZlZCBmcm9tIHRoZWlyIG9yaWdpbmFsIGxvY2F0aW9uLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIFBvbHltZXIuU3R5bGVHYXRoZXJcbiAgICAgKiBAcGFyYW0ge0hUTUxUZW1wbGF0ZUVsZW1lbnR9IHRlbXBsYXRlIFRlbXBsYXRlIHRvIGdhdGhlciBzdHlsZXMgZnJvbVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlVVJJIEJhc2UgVVJJIHRvIHJlc29sdmUgdGhlIFVSTCBhZ2FpbnN0XG4gICAgICogQHJldHVybiB7c3RyaW5nfSBDb25jYXRlbmF0ZWQgQ1NTIGNvbnRlbnQgZnJvbSBzcGVjaWZpZWQgdGVtcGxhdGVcbiAgICAgKiBAdGhpcyB7U3R5bGVHYXRoZXJ9XG4gICAgICovXG4gICAgY3NzRnJvbVRlbXBsYXRlKHRlbXBsYXRlLCBiYXNlVVJJKSB7XG4gICAgICBsZXQgY3NzVGV4dCA9ICcnO1xuICAgICAgLy8gaWYgZWxlbWVudCBpcyBhIHRlbXBsYXRlLCBnZXQgY29udGVudCBmcm9tIGl0cyAuY29udGVudFxuICAgICAgbGV0IGUkID0gdGVtcGxhdGUuY29udGVudC5xdWVyeVNlbGVjdG9yQWxsKCdzdHlsZScpO1xuICAgICAgZm9yIChsZXQgaT0wOyBpIDwgZSQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGUgPSBlJFtpXTtcbiAgICAgICAgLy8gc3VwcG9ydCBzdHlsZSBzaGFyaW5nIGJ5IGFsbG93aW5nIHN0eWxlcyB0byBcImluY2x1ZGVcIlxuICAgICAgICAvLyBvdGhlciBkb20tbW9kdWxlcyB0aGF0IGNvbnRhaW4gc3R5bGluZ1xuICAgICAgICBsZXQgaW5jbHVkZSA9IGUuZ2V0QXR0cmlidXRlKElOQ0xVREVfQVRUUik7XG4gICAgICAgIGlmIChpbmNsdWRlKSB7XG4gICAgICAgICAgY3NzVGV4dCArPSB0aGlzLmNzc0Zyb21Nb2R1bGVzKGluY2x1ZGUpO1xuICAgICAgICB9XG4gICAgICAgIGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlKTtcbiAgICAgICAgY3NzVGV4dCArPSBiYXNlVVJJID9cbiAgICAgICAgICBQb2x5bWVyLlJlc29sdmVVcmwucmVzb2x2ZUNzcyhlLnRleHRDb250ZW50LCBiYXNlVVJJKSA6IGUudGV4dENvbnRlbnQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gY3NzVGV4dDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBDU1MgdGV4dCBmcm9tIHN0eWxzaGVldHMgbG9hZGVkIHZpYSBgPGxpbmsgcmVsPVwiaW1wb3J0XCIgdHlwZT1cImNzc1wiPmBcbiAgICAgKiBsaW5rcyB3aXRoaW4gdGhlIHNwZWNpZmllZCBgZG9tLW1vZHVsZWAuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgUG9seW1lci5TdHlsZUdhdGhlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtb2R1bGVJZCBJZCBvZiBgZG9tLW1vZHVsZWAgdG8gZ2F0aGVyIENTUyBmcm9tXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBDb25jYXRlbmF0ZWQgQ1NTIGNvbnRlbnQgZnJvbSBsaW5rcyBpbiBzcGVjaWZpZWQgYGRvbS1tb2R1bGVgXG4gICAgICogQHRoaXMge1N0eWxlR2F0aGVyfVxuICAgICAqL1xuICAgIGNzc0Zyb21Nb2R1bGVJbXBvcnRzKG1vZHVsZUlkKSB7XG4gICAgICBsZXQgY3NzVGV4dCA9ICcnO1xuICAgICAgbGV0IG0gPSBpbXBvcnRNb2R1bGUobW9kdWxlSWQpO1xuICAgICAgaWYgKCFtKSB7XG4gICAgICAgIHJldHVybiBjc3NUZXh0O1xuICAgICAgfVxuICAgICAgbGV0IHAkID0gbS5xdWVyeVNlbGVjdG9yQWxsKE1PRFVMRV9TVFlMRV9MSU5LX1NFTEVDVE9SKTtcbiAgICAgIGZvciAobGV0IGk9MDsgaSA8IHAkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBwID0gcCRbaV07XG4gICAgICAgIGlmIChwLmltcG9ydCkge1xuICAgICAgICAgIGxldCBpbXBvcnREb2MgPSBwLmltcG9ydDtcbiAgICAgICAgICAvLyBOT1RFOiBwb2x5ZmlsbCBhZmZvcmRhbmNlLlxuICAgICAgICAgIC8vIHVuZGVyIHRoZSBIVE1MSW1wb3J0cyBwb2x5ZmlsbCwgdGhlcmUgd2lsbCBiZSBubyAnYm9keScsXG4gICAgICAgICAgLy8gYnV0IHRoZSBpbXBvcnQgcHNldWRvLWRvYyBjYW4gYmUgdXNlZCBkaXJlY3RseS5cbiAgICAgICAgICBsZXQgY29udGFpbmVyID0gaW1wb3J0RG9jLmJvZHkgPyBpbXBvcnREb2MuYm9keSA6IGltcG9ydERvYztcbiAgICAgICAgICBjc3NUZXh0ICs9XG4gICAgICAgICAgICBQb2x5bWVyLlJlc29sdmVVcmwucmVzb2x2ZUNzcyhjb250YWluZXIudGV4dENvbnRlbnQsXG4gICAgICAgICAgICAgIGltcG9ydERvYy5iYXNlVVJJKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGNzc1RleHQ7XG4gICAgfVxuICB9O1xuXG4gIFBvbHltZXIuU3R5bGVHYXRoZXIgPSBTdHlsZUdhdGhlcjtcbn0pKCk7XG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvdXRpbHMvc3R5bGUtZ2F0aGVyLmh0bWwiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi8uLi8uLi9zaGFkeWNzcy9hcHBseS1zaGltLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi9taXhpbnMvZWxlbWVudC1taXhpbi5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vbWl4aW5zL2dlc3R1cmUtZXZlbnQtbGlzdGVuZXJzLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi91dGlscy9taXhpbi5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vdXRpbHMvaW1wb3J0LWhyZWYuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3V0aWxzL3JlbmRlci1zdGF0dXMuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3V0aWxzL3VucmVzb2x2ZWQuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cInBvbHltZXIuZG9tLmh0bWxcIj5cblxuPHNjcmlwdD5cbihmdW5jdGlvbigpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgbGV0IHN0eWxlSW50ZXJmYWNlID0gd2luZG93LlNoYWR5Q1NTO1xuXG4gIC8qKlxuICAgKiBFbGVtZW50IGNsYXNzIG1peGluIHRoYXQgcHJvdmlkZXMgUG9seW1lcidzIFwibGVnYWN5XCIgQVBJIGludGVuZGVkIHRvIGJlXG4gICAqIGJhY2t3YXJkLWNvbXBhdGlibGUgdG8gdGhlIGdyZWF0ZXN0IGV4dGVudCBwb3NzaWJsZSB3aXRoIHRoZSBBUElcbiAgICogZm91bmQgb24gdGhlIFBvbHltZXIgMS54IGBQb2x5bWVyLkJhc2VgIHByb3RvdHlwZSBhcHBsaWVkIHRvIGFsbCBlbGVtZW50c1xuICAgKiBkZWZpbmVkIHVzaW5nIHRoZSBgUG9seW1lcih7Li4ufSlgIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAbWl4aW5GdW5jdGlvblxuICAgKiBAcG9seW1lclxuICAgKiBAYXBwbGllc01peGluIFBvbHltZXIuRWxlbWVudE1peGluXG4gICAqIEBhcHBsaWVzTWl4aW4gUG9seW1lci5HZXN0dXJlRXZlbnRMaXN0ZW5lcnNcbiAgICogQHByb3BlcnR5IGlzQXR0YWNoZWQge2Jvb2xlYW59IFNldCB0byBgdHJ1ZWAgaW4gdGhpcyBlbGVtZW50J3NcbiAgICogICBgY29ubmVjdGVkQ2FsbGJhY2tgIGFuZCBgZmFsc2VgIGluIGBkaXNjb25uZWN0ZWRDYWxsYmFja2BcbiAgICogQG1lbWJlcm9mIFBvbHltZXJcbiAgICogQHN1bW1hcnkgRWxlbWVudCBjbGFzcyBtaXhpbiB0aGF0IHByb3ZpZGVzIFBvbHltZXIncyBcImxlZ2FjeVwiIEFQSVxuICAgKi9cbiAgUG9seW1lci5MZWdhY3lFbGVtZW50TWl4aW4gPSBQb2x5bWVyLmRlZHVwaW5nTWl4aW4oKGJhc2UpID0+IHtcblxuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBleHRlbmRzIHtiYXNlfVxuICAgICAqIEBpbXBsZW1lbnRzIHtQb2x5bWVyX0VsZW1lbnRNaXhpbn1cbiAgICAgKiBAaW1wbGVtZW50cyB7UG9seW1lcl9HZXN0dXJlRXZlbnRMaXN0ZW5lcnN9XG4gICAgICovXG4gICAgY29uc3QgbGVnYWN5RWxlbWVudEJhc2UgPSBQb2x5bWVyLkdlc3R1cmVFdmVudExpc3RlbmVycyhQb2x5bWVyLkVsZW1lbnRNaXhpbihiYXNlKSk7XG5cbiAgICAvKipcbiAgICAgKiBNYXAgb2Ygc2ltcGxlIG5hbWVzIHRvIHRvdWNoIGFjdGlvbiBuYW1lc1xuICAgICAqIEBkaWN0XG4gICAgICovXG4gICAgY29uc3QgRElSRUNUSU9OX01BUCA9IHtcbiAgICAgICd4JzogJ3Bhbi14JyxcbiAgICAgICd5JzogJ3Bhbi15JyxcbiAgICAgICdub25lJzogJ25vbmUnLFxuICAgICAgJ2FsbCc6ICdhdXRvJ1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcG9seW1lclxuICAgICAqIEBtaXhpbkNsYXNzXG4gICAgICogQGV4dGVuZHMge2xlZ2FjeUVsZW1lbnRCYXNlfVxuICAgICAqIEBpbXBsZW1lbnRzIHtQb2x5bWVyX0xlZ2FjeUVsZW1lbnRNaXhpbn1cbiAgICAgKiBAdW5yZXN0cmljdGVkXG4gICAgICovXG4gICAgY2xhc3MgTGVnYWN5RWxlbWVudCBleHRlbmRzIGxlZ2FjeUVsZW1lbnRCYXNlIHtcblxuICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMucm9vdCA9IHRoaXM7XG4gICAgICAgIHRoaXMuY3JlYXRlZCgpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIExlZ2FjeSBjYWxsYmFjayBjYWxsZWQgZHVyaW5nIHRoZSBgY29uc3RydWN0b3JgLCBmb3Igb3ZlcnJpZGluZ1xuICAgICAgICogYnkgdGhlIHVzZXIuXG4gICAgICAgKi9cbiAgICAgIGNyZWF0ZWQoKSB7fVxuXG4gICAgICAvKipcbiAgICAgICAqIFByb3ZpZGVzIGFuIGltcGxlbWVudGF0aW9uIG9mIGBjb25uZWN0ZWRDYWxsYmFja2BcbiAgICAgICAqIHdoaWNoIGFkZHMgUG9seW1lciBsZWdhY3kgQVBJJ3MgYGF0dGFjaGVkYCBtZXRob2QuXG4gICAgICAgKiBAb3ZlcnJpZGVcbiAgICAgICAqL1xuICAgICAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgICAgIHN1cGVyLmNvbm5lY3RlZENhbGxiYWNrKCk7XG4gICAgICAgIHRoaXMuaXNBdHRhY2hlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuYXR0YWNoZWQoKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBMZWdhY3kgY2FsbGJhY2sgY2FsbGVkIGR1cmluZyBgY29ubmVjdGVkQ2FsbGJhY2tgLCBmb3Igb3ZlcnJpZGluZ1xuICAgICAgICogYnkgdGhlIHVzZXIuXG4gICAgICAgKi9cbiAgICAgIGF0dGFjaGVkKCkge31cblxuICAgICAgLyoqXG4gICAgICAgKiBQcm92aWRlcyBhbiBpbXBsZW1lbnRhdGlvbiBvZiBgZGlzY29ubmVjdGVkQ2FsbGJhY2tgXG4gICAgICAgKiB3aGljaCBhZGRzIFBvbHltZXIgbGVnYWN5IEFQSSdzIGBkZXRhY2hlZGAgbWV0aG9kLlxuICAgICAgICogQG92ZXJyaWRlXG4gICAgICAgKi9cbiAgICAgIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgICAgICBzdXBlci5kaXNjb25uZWN0ZWRDYWxsYmFjaygpO1xuICAgICAgICB0aGlzLmlzQXR0YWNoZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kZXRhY2hlZCgpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIExlZ2FjeSBjYWxsYmFjayBjYWxsZWQgZHVyaW5nIGBkaXNjb25uZWN0ZWRDYWxsYmFja2AsIGZvciBvdmVycmlkaW5nXG4gICAgICAgKiBieSB0aGUgdXNlci5cbiAgICAgICAqL1xuICAgICAgZGV0YWNoZWQoKSB7fVxuXG4gICAgICAvKipcbiAgICAgICAqIFByb3ZpZGVzIGFuIG92ZXJyaWRlIGltcGxlbWVudGF0aW9uIG9mIGBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2tgXG4gICAgICAgKiB3aGljaCBhZGRzIHRoZSBQb2x5bWVyIGxlZ2FjeSBBUEkncyBgYXR0cmlidXRlQ2hhbmdlZGAgbWV0aG9kLlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgTmFtZSBvZiBhdHRyaWJ1dGUuXG4gICAgICAgKiBAcGFyYW0gez9zdHJpbmd9IG9sZCBPbGQgdmFsdWUgb2YgYXR0cmlidXRlLlxuICAgICAgICogQHBhcmFtIHs/c3RyaW5nfSB2YWx1ZSBDdXJyZW50IHZhbHVlIG9mIGF0dHJpYnV0ZS5cbiAgICAgICAqIEBvdmVycmlkZVxuICAgICAgICovXG4gICAgICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgb2xkLCB2YWx1ZSkge1xuICAgICAgICBpZiAob2xkICE9PSB2YWx1ZSkge1xuICAgICAgICAgIHN1cGVyLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBvbGQsIHZhbHVlKTtcbiAgICAgICAgICB0aGlzLmF0dHJpYnV0ZUNoYW5nZWQobmFtZSwgb2xkLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBMZWdhY3kgY2FsbGJhY2sgY2FsbGVkIGR1cmluZyBgYXR0cmlidXRlQ2hhbmdlZENoYWxsYmFja2AsIGZvciBvdmVycmlkaW5nXG4gICAgICAgKiBieSB0aGUgdXNlci5cbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE5hbWUgb2YgYXR0cmlidXRlLlxuICAgICAgICogQHBhcmFtIHs/c3RyaW5nfSBvbGQgT2xkIHZhbHVlIG9mIGF0dHJpYnV0ZS5cbiAgICAgICAqIEBwYXJhbSB7P3N0cmluZ30gdmFsdWUgQ3VycmVudCB2YWx1ZSBvZiBhdHRyaWJ1dGUuXG4gICAgICAgKi9cbiAgICAgIGF0dHJpYnV0ZUNoYW5nZWQobmFtZSwgb2xkLCB2YWx1ZSkge30gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuXG4gICAgICAvKipcbiAgICAgICAqIE92ZXJyaWRlcyB0aGUgZGVmYXVsdCBgUG9seW1lci5Qcm9wZXJ0eUVmZmVjdHNgIGltcGxlbWVudGF0aW9uIHRvXG4gICAgICAgKiBhZGQgc3VwcG9ydCBmb3IgY2xhc3MgaW5pdGlhbGl6YXRpb24gdmlhIHRoZSBgX3JlZ2lzdGVyZWRgIGNhbGxiYWNrLlxuICAgICAgICogVGhpcyBpcyBjYWxsZWQgb25seSB3aGVuIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiB0aGUgZWxlbWVudCBpcyBjcmVhdGVkLlxuICAgICAgICpcbiAgICAgICAqIEBvdmVycmlkZVxuICAgICAgICovXG4gICAgICBfaW5pdGlhbGl6ZVByb3BlcnRpZXMoKSB7XG4gICAgICAgIGxldCBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKTtcbiAgICAgICAgaWYgKCFwcm90by5oYXNPd25Qcm9wZXJ0eSgnX19oYXNSZWdpc3RlckZpbmlzaGVkJykpIHtcbiAgICAgICAgICBwcm90by5fX2hhc1JlZ2lzdGVyRmluaXNoZWQgPSB0cnVlO1xuICAgICAgICAgIHRoaXMuX3JlZ2lzdGVyZWQoKTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlci5faW5pdGlhbGl6ZVByb3BlcnRpZXMoKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDYWxsZWQgYXV0b21hdGljYWxseSB3aGVuIGFuIGVsZW1lbnQgaXMgaW5pdGlhbGl6aW5nLlxuICAgICAgICogVXNlcnMgbWF5IG92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIHBlcmZvcm0gY2xhc3MgcmVnaXN0cmF0aW9uIHRpbWVcbiAgICAgICAqIHdvcmsuIFRoZSBpbXBsZW1lbnRhdGlvbiBzaG91bGQgZW5zdXJlIHRoZSB3b3JrIGlzIHBlcmZvcm1lZFxuICAgICAgICogb25seSBvbmNlIGZvciB0aGUgY2xhc3MuXG4gICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgKi9cbiAgICAgIF9yZWdpc3RlcmVkKCkge31cblxuICAgICAgLyoqXG4gICAgICAgKiBPdmVycmlkZXMgdGhlIGRlZmF1bHQgYFBvbHltZXIuUHJvcGVydHlFZmZlY3RzYCBpbXBsZW1lbnRhdGlvbiB0b1xuICAgICAgICogYWRkIHN1cHBvcnQgZm9yIGluc3RhbGxpbmcgYGhvc3RBdHRyaWJ1dGVzYCBhbmQgYGxpc3RlbmVyc2AuXG4gICAgICAgKlxuICAgICAgICogQG92ZXJyaWRlXG4gICAgICAgKi9cbiAgICAgIHJlYWR5KCkge1xuICAgICAgICB0aGlzLl9lbnN1cmVBdHRyaWJ1dGVzKCk7XG4gICAgICAgIHRoaXMuX2FwcGx5TGlzdGVuZXJzKCk7XG4gICAgICAgIHN1cGVyLnJlYWR5KCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogRW5zdXJlcyBhbiBlbGVtZW50IGhhcyByZXF1aXJlZCBhdHRyaWJ1dGVzLiBDYWxsZWQgd2hlbiB0aGUgZWxlbWVudFxuICAgICAgICogaXMgYmVpbmcgcmVhZGllZCB2aWEgYHJlYWR5YC4gVXNlcnMgc2hvdWxkIG92ZXJyaWRlIHRvIHNldCB0aGVcbiAgICAgICAqIGVsZW1lbnQncyByZXF1aXJlZCBhdHRyaWJ1dGVzLiBUaGUgaW1wbGVtZW50YXRpb24gc2hvdWxkIGJlIHN1cmVcbiAgICAgICAqIHRvIGNoZWNrIGFuZCBub3Qgb3ZlcnJpZGUgZXhpc3RpbmcgYXR0cmlidXRlcyBhZGRlZCBieVxuICAgICAgICogdGhlIHVzZXIgb2YgdGhlIGVsZW1lbnQuIFR5cGljYWxseSwgc2V0dGluZyBhdHRyaWJ1dGVzIHNob3VsZCBiZSBsZWZ0XG4gICAgICAgKiB0byB0aGUgZWxlbWVudCB1c2VyIGFuZCBub3QgZG9uZSBoZXJlOyByZWFzb25hYmxlIGV4Y2VwdGlvbnMgaW5jbHVkZVxuICAgICAgICogc2V0dGluZyBhcmlhIHJvbGVzIGFuZCBmb2N1c2FiaWxpdHkuXG4gICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgKi9cbiAgICAgIF9lbnN1cmVBdHRyaWJ1dGVzKCkge31cblxuICAgICAgLyoqXG4gICAgICAgKiBBZGRzIGVsZW1lbnQgZXZlbnQgbGlzdGVuZXJzLiBDYWxsZWQgd2hlbiB0aGUgZWxlbWVudFxuICAgICAgICogaXMgYmVpbmcgcmVhZGllZCB2aWEgYHJlYWR5YC4gVXNlcnMgc2hvdWxkIG92ZXJyaWRlIHRvXG4gICAgICAgKiBhZGQgYW55IHJlcXVpcmVkIGVsZW1lbnQgZXZlbnQgbGlzdGVuZXJzLlxuICAgICAgICogSW4gcGVyZm9ybWFuY2UgY3JpdGljYWwgZWxlbWVudHMsIHRoZSB3b3JrIGRvbmUgaGVyZSBzaG91bGQgYmUga2VwdFxuICAgICAgICogdG8gYSBtaW5pbXVtIHNpbmNlIGl0IGlzIGRvbmUgYmVmb3JlIHRoZSBlbGVtZW50IGlzIHJlbmRlcmVkLiBJblxuICAgICAgICogdGhlc2UgZWxlbWVudHMsIGNvbnNpZGVyIGFkZGluZyBsaXN0ZW5lcnMgYXN5Y2hyb25vdXNseSBzbyBhcyBub3QgdG9cbiAgICAgICAqIGJsb2NrIHJlbmRlci5cbiAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAqL1xuICAgICAgX2FwcGx5TGlzdGVuZXJzKCkge31cblxuICAgICAgLyoqXG4gICAgICAgKiBDb252ZXJ0cyBhIHR5cGVkIEphdmFTY3JpcHQgdmFsdWUgdG8gYSBzdHJpbmcuXG4gICAgICAgKlxuICAgICAgICogTm90ZSB0aGlzIG1ldGhvZCBpcyBwcm92aWRlZCBhcyBiYWNrd2FyZC1jb21wYXRpYmxlIGxlZ2FjeSBBUElcbiAgICAgICAqIG9ubHkuICBJdCBpcyBub3QgZGlyZWN0bHkgY2FsbGVkIGJ5IGFueSBQb2x5bWVyIGZlYXR1cmVzLiBUbyBjdXN0b21pemVcbiAgICAgICAqIGhvdyBwcm9wZXJ0aWVzIGFyZSBzZXJpYWxpemVkIHRvIGF0dHJpYnV0ZXMgZm9yIGF0dHJpYnV0ZSBiaW5kaW5ncyBhbmRcbiAgICAgICAqIGByZWZsZWN0VG9BdHRyaWJ1dGU6IHRydWVgIHByb3BlcnRpZXMgYXMgd2VsbCBhcyB0aGlzIG1ldGhvZCwgb3ZlcnJpZGVcbiAgICAgICAqIHRoZSBgX3NlcmlhbGl6ZVZhbHVlYCBtZXRob2QgcHJvdmlkZWQgYnkgYFBvbHltZXIuUHJvcGVydHlBY2Nlc3NvcnNgLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgdG8gZGVzZXJpYWxpemVcbiAgICAgICAqIEByZXR1cm4ge3N0cmluZyB8IHVuZGVmaW5lZH0gU2VyaWFsaXplZCB2YWx1ZVxuICAgICAgICovXG4gICAgICBzZXJpYWxpemUodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NlcmlhbGl6ZVZhbHVlKHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDb252ZXJ0cyBhIHN0cmluZyB0byBhIHR5cGVkIEphdmFTY3JpcHQgdmFsdWUuXG4gICAgICAgKlxuICAgICAgICogTm90ZSB0aGlzIG1ldGhvZCBpcyBwcm92aWRlZCBhcyBiYWNrd2FyZC1jb21wYXRpYmxlIGxlZ2FjeSBBUElcbiAgICAgICAqIG9ubHkuICBJdCBpcyBub3QgZGlyZWN0bHkgY2FsbGVkIGJ5IGFueSBQb2x5bWVyIGZlYXR1cmVzLiAgVG8gY3VzdG9taXplXG4gICAgICAgKiBob3cgYXR0cmlidXRlcyBhcmUgZGVzZXJpYWxpemVkIHRvIHByb3BlcnRpZXMgZm9yIGluXG4gICAgICAgKiBgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrYCwgb3ZlcnJpZGUgYF9kZXNlcmlhbGl6ZVZhbHVlYCBtZXRob2RcbiAgICAgICAqIHByb3ZpZGVkIGJ5IGBQb2x5bWVyLlByb3BlcnR5QWNjZXNzb3JzYC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgU3RyaW5nIHRvIGRlc2VyaWFsaXplXG4gICAgICAgKiBAcGFyYW0geyp9IHR5cGUgVHlwZSB0byBkZXNlcmlhbGl6ZSB0aGUgc3RyaW5nIHRvXG4gICAgICAgKiBAcmV0dXJuIHsqfSBSZXR1cm5zIHRoZSBkZXNlcmlhbGl6ZWQgdmFsdWUgaW4gdGhlIGB0eXBlYCBnaXZlbi5cbiAgICAgICAqL1xuICAgICAgZGVzZXJpYWxpemUodmFsdWUsIHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Rlc2VyaWFsaXplVmFsdWUodmFsdWUsIHR5cGUpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFNlcmlhbGl6ZXMgYSBwcm9wZXJ0eSB0byBpdHMgYXNzb2NpYXRlZCBhdHRyaWJ1dGUuXG4gICAgICAgKlxuICAgICAgICogTm90ZSB0aGlzIG1ldGhvZCBpcyBwcm92aWRlZCBhcyBiYWNrd2FyZC1jb21wYXRpYmxlIGxlZ2FjeSBBUElcbiAgICAgICAqIG9ubHkuICBJdCBpcyBub3QgZGlyZWN0bHkgY2FsbGVkIGJ5IGFueSBQb2x5bWVyIGZlYXR1cmVzLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSBuYW1lIHRvIHJlZmxlY3QuXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZz19IGF0dHJpYnV0ZSBBdHRyaWJ1dGUgbmFtZSB0byByZWZsZWN0LlxuICAgICAgICogQHBhcmFtIHsqPX0gdmFsdWUgUHJvcGVydHkgdmFsdWUgdG8gcmVmZWN0LlxuICAgICAgICovXG4gICAgICByZWZsZWN0UHJvcGVydHlUb0F0dHJpYnV0ZShwcm9wZXJ0eSwgYXR0cmlidXRlLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLl9wcm9wZXJ0eVRvQXR0cmlidXRlKHByb3BlcnR5LCBhdHRyaWJ1dGUsIHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBTZXRzIGEgdHlwZWQgdmFsdWUgdG8gYW4gSFRNTCBhdHRyaWJ1dGUgb24gYSBub2RlLlxuICAgICAgICpcbiAgICAgICAqIE5vdGUgdGhpcyBtZXRob2QgaXMgcHJvdmlkZWQgYXMgYmFja3dhcmQtY29tcGF0aWJsZSBsZWdhY3kgQVBJXG4gICAgICAgKiBvbmx5LiAgSXQgaXMgbm90IGRpcmVjdGx5IGNhbGxlZCBieSBhbnkgUG9seW1lciBmZWF0dXJlcy5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIHNlcmlhbGl6ZS5cbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGUgQXR0cmlidXRlIG5hbWUgdG8gc2VyaWFsaXplIHRvLlxuICAgICAgICogQHBhcmFtIHtFbGVtZW50fSBub2RlIEVsZW1lbnQgdG8gc2V0IGF0dHJpYnV0ZSB0by5cbiAgICAgICAqL1xuICAgICAgc2VyaWFsaXplVmFsdWVUb0F0dHJpYnV0ZSh2YWx1ZSwgYXR0cmlidXRlLCBub2RlKSB7XG4gICAgICAgIHRoaXMuX3ZhbHVlVG9Ob2RlQXR0cmlidXRlKC8qKiBAdHlwZSB7RWxlbWVudH0gKi8gKG5vZGUgfHwgdGhpcyksIHZhbHVlLCBhdHRyaWJ1dGUpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENvcGllcyBvd24gcHJvcGVydGllcyAoaW5jbHVkaW5nIGFjY2Vzc29yIGRlc2NyaXB0b3JzKSBmcm9tIGEgc291cmNlXG4gICAgICAgKiBvYmplY3QgdG8gYSB0YXJnZXQgb2JqZWN0LlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm90b3R5cGUgVGFyZ2V0IG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgdG8uXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gYXBpIFNvdXJjZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb20uXG4gICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHByb3RvdHlwZSBvYmplY3QgdGhhdCB3YXMgcGFzc2VkIGFzIGZpcnN0IGFyZ3VtZW50LlxuICAgICAgICovXG4gICAgICBleHRlbmQocHJvdG90eXBlLCBhcGkpIHtcbiAgICAgICAgaWYgKCEocHJvdG90eXBlICYmIGFwaSkpIHtcbiAgICAgICAgICByZXR1cm4gcHJvdG90eXBlIHx8IGFwaTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbiQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhhcGkpO1xuICAgICAgICBmb3IgKGxldCBpPTAsIG47IChpPG4kLmxlbmd0aCkgJiYgKG49biRbaV0pOyBpKyspIHtcbiAgICAgICAgICBsZXQgcGQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGFwaSwgbik7XG4gICAgICAgICAgaWYgKHBkKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG90eXBlLCBuLCBwZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcm90b3R5cGU7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ29waWVzIHByb3BzIGZyb20gYSBzb3VyY2Ugb2JqZWN0IHRvIGEgdGFyZ2V0IG9iamVjdC5cbiAgICAgICAqXG4gICAgICAgKiBOb3RlLCB0aGlzIG1ldGhvZCB1c2VzIGEgc2ltcGxlIGBmb3IuLi5pbmAgc3RyYXRlZ3kgZm9yIGVudW1lcmF0aW5nXG4gICAgICAgKiBwcm9wZXJ0aWVzLiAgVG8gZW5zdXJlIG9ubHkgYG93blByb3BlcnRpZXNgIGFyZSBjb3BpZWQgZnJvbSBzb3VyY2VcbiAgICAgICAqIHRvIHRhcmdldCBhbmQgdGhhdCBhY2Nlc3NvciBpbXBsZW1lbnRhdGlvbnMgYXJlIGNvcGllZCwgdXNlIGBleHRlbmRgLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgVGFyZ2V0IG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgdG8uXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFNvdXJjZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb20uXG4gICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRhcmdldCBvYmplY3QgdGhhdCB3YXMgcGFzc2VkIGFzIGZpcnN0IGFyZ3VtZW50LlxuICAgICAgICovXG4gICAgICBtaXhpbih0YXJnZXQsIHNvdXJjZSkge1xuICAgICAgICBmb3IgKGxldCBpIGluIHNvdXJjZSkge1xuICAgICAgICAgIHRhcmdldFtpXSA9IHNvdXJjZVtpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFNldHMgdGhlIHByb3RvdHlwZSBvZiBhbiBvYmplY3QuXG4gICAgICAgKlxuICAgICAgICogTm90ZSB0aGlzIG1ldGhvZCBpcyBwcm92aWRlZCBhcyBiYWNrd2FyZC1jb21wYXRpYmxlIGxlZ2FjeSBBUElcbiAgICAgICAqIG9ubHkuICBJdCBpcyBub3QgZGlyZWN0bHkgY2FsbGVkIGJ5IGFueSBQb2x5bWVyIGZlYXR1cmVzLlxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IG9uIHdoaWNoIHRvIHNldCB0aGUgcHJvdG90eXBlLlxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IHByb3RvdHlwZSBUaGUgcHJvdG90eXBlIHRoYXQgd2lsbCBiZSBzZXQgb24gdGhlIGdpdmVuXG4gICAgICAgKiBgb2JqZWN0YC5cbiAgICAgICAqIEByZXR1cm4ge09iamVjdH0gUmV0dXJucyB0aGUgZ2l2ZW4gYG9iamVjdGAgd2l0aCBpdHMgcHJvdG90eXBlIHNldFxuICAgICAgICogdG8gdGhlIGdpdmVuIGBwcm90b3R5cGVgIG9iamVjdC5cbiAgICAgICAqL1xuICAgICAgY2hhaW5PYmplY3Qob2JqZWN0LCBwcm90b3R5cGUpIHtcbiAgICAgICAgaWYgKG9iamVjdCAmJiBwcm90b3R5cGUgJiYgb2JqZWN0ICE9PSBwcm90b3R5cGUpIHtcbiAgICAgICAgICBvYmplY3QuX19wcm90b19fID0gcHJvdG90eXBlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICB9XG5cbiAgICAgIC8qICoqKiogQmVnaW4gVGVtcGxhdGUgKioqKiAqL1xuXG4gICAgICAvKipcbiAgICAgICAqIENhbGxzIGBpbXBvcnROb2RlYCBvbiB0aGUgYGNvbnRlbnRgIG9mIHRoZSBgdGVtcGxhdGVgIHNwZWNpZmllZCBhbmRcbiAgICAgICAqIHJldHVybnMgYSBkb2N1bWVudCBmcmFnbWVudCBjb250YWluaW5nIHRoZSBpbXBvcnRlZCBjb250ZW50LlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7SFRNTFRlbXBsYXRlRWxlbWVudH0gdGVtcGxhdGUgSFRNTCB0ZW1wbGF0ZSBlbGVtZW50IHRvIGluc3RhbmNlLlxuICAgICAgICogQHJldHVybiB7RG9jdW1lbnRGcmFnbWVudH0gRG9jdW1lbnQgZnJhZ21lbnQgY29udGFpbmluZyB0aGUgaW1wb3J0ZWRcbiAgICAgICAqICAgdGVtcGxhdGUgY29udGVudC5cbiAgICAgICovXG4gICAgICBpbnN0YW5jZVRlbXBsYXRlKHRlbXBsYXRlKSB7XG4gICAgICAgIGxldCBjb250ZW50ID0gdGhpcy5jb25zdHJ1Y3Rvci5fY29udGVudEZvclRlbXBsYXRlKHRlbXBsYXRlKTtcbiAgICAgICAgbGV0IGRvbSA9IC8qKiBAdHlwZSB7RG9jdW1lbnRGcmFnbWVudH0gKi9cbiAgICAgICAgICAoZG9jdW1lbnQuaW1wb3J0Tm9kZShjb250ZW50LCB0cnVlKSk7XG4gICAgICAgIHJldHVybiBkb207XG4gICAgICB9XG5cbiAgICAgIC8qICoqKiogQmVnaW4gRXZlbnRzICoqKiogKi9cblxuXG5cbiAgICAgIC8qKlxuICAgICAgICogRGlzcGF0Y2hlcyBhIGN1c3RvbSBldmVudCB3aXRoIGFuIG9wdGlvbmFsIGRldGFpbCB2YWx1ZS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBOYW1lIG9mIGV2ZW50IHR5cGUuXG4gICAgICAgKiBAcGFyYW0geyo9fSBkZXRhaWwgRGV0YWlsIHZhbHVlIGNvbnRhaW5pbmcgZXZlbnQtc3BlY2lmaWNcbiAgICAgICAqICAgcGF5bG9hZC5cbiAgICAgICAqIEBwYXJhbSB7eyBidWJibGVzOiAoYm9vbGVhbnx1bmRlZmluZWQpLCBjYW5jZWxhYmxlOiAoYm9vbGVhbnx1bmRlZmluZWQpLCBjb21wb3NlZDogKGJvb2xlYW58dW5kZWZpbmVkKSB9PX1cbiAgICAgICAqICBvcHRpb25zIE9iamVjdCBzcGVjaWZ5aW5nIG9wdGlvbnMuICBUaGVzZSBtYXkgaW5jbHVkZTpcbiAgICAgICAqICBgYnViYmxlc2AgKGJvb2xlYW4sIGRlZmF1bHRzIHRvIGB0cnVlYCksXG4gICAgICAgKiAgYGNhbmNlbGFibGVgIChib29sZWFuLCBkZWZhdWx0cyB0byBmYWxzZSksIGFuZFxuICAgICAgICogIGBub2RlYCBvbiB3aGljaCB0byBmaXJlIHRoZSBldmVudCAoSFRNTEVsZW1lbnQsIGRlZmF1bHRzIHRvIGB0aGlzYCkuXG4gICAgICAgKiBAcmV0dXJuIHtFdmVudH0gVGhlIG5ldyBldmVudCB0aGF0IHdhcyBmaXJlZC5cbiAgICAgICAqL1xuICAgICAgZmlyZSh0eXBlLCBkZXRhaWwsIG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIGRldGFpbCA9IChkZXRhaWwgPT09IG51bGwgfHwgZGV0YWlsID09PSB1bmRlZmluZWQpID8ge30gOiBkZXRhaWw7XG4gICAgICAgIGxldCBldmVudCA9IG5ldyBFdmVudCh0eXBlLCB7XG4gICAgICAgICAgYnViYmxlczogb3B0aW9ucy5idWJibGVzID09PSB1bmRlZmluZWQgPyB0cnVlIDogb3B0aW9ucy5idWJibGVzLFxuICAgICAgICAgIGNhbmNlbGFibGU6IEJvb2xlYW4ob3B0aW9ucy5jYW5jZWxhYmxlKSxcbiAgICAgICAgICBjb21wb3NlZDogb3B0aW9ucy5jb21wb3NlZCA9PT0gdW5kZWZpbmVkID8gdHJ1ZTogb3B0aW9ucy5jb21wb3NlZFxuICAgICAgICB9KTtcbiAgICAgICAgZXZlbnQuZGV0YWlsID0gZGV0YWlsO1xuICAgICAgICBsZXQgbm9kZSA9IG9wdGlvbnMubm9kZSB8fCB0aGlzO1xuICAgICAgICBub2RlLmRpc3BhdGNoRXZlbnQoZXZlbnQpXG4gICAgICAgIHJldHVybiBldmVudDtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDb252ZW5pZW5jZSBtZXRob2QgdG8gYWRkIGFuIGV2ZW50IGxpc3RlbmVyIG9uIGEgZ2l2ZW4gZWxlbWVudCxcbiAgICAgICAqIGxhdGUgYm91bmQgdG8gYSBuYW1lZCBtZXRob2Qgb24gdGhpcyBlbGVtZW50LlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZSBFbGVtZW50IHRvIGFkZCBldmVudCBsaXN0ZW5lciB0by5cbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgTmFtZSBvZiBldmVudCB0byBsaXN0ZW4gZm9yLlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZE5hbWUgTmFtZSBvZiBoYW5kbGVyIG1ldGhvZCBvbiBgdGhpc2AgdG8gY2FsbC5cbiAgICAgICAqL1xuICAgICAgbGlzdGVuKG5vZGUsIGV2ZW50TmFtZSwgbWV0aG9kTmFtZSkge1xuICAgICAgICBub2RlID0gLyoqIEB0eXBlIHtFbGVtZW50fSAqLyAobm9kZSB8fCB0aGlzKTtcbiAgICAgICAgbGV0IGhibCA9IHRoaXMuX19ib3VuZExpc3RlbmVycyB8fFxuICAgICAgICAgICh0aGlzLl9fYm91bmRMaXN0ZW5lcnMgPSBuZXcgV2Vha01hcCgpKTtcbiAgICAgICAgbGV0IGJsID0gaGJsLmdldChub2RlKTtcbiAgICAgICAgaWYgKCFibCkge1xuICAgICAgICAgIGJsID0ge307XG4gICAgICAgICAgaGJsLnNldChub2RlLCBibCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGtleSA9IGV2ZW50TmFtZSArIG1ldGhvZE5hbWU7XG4gICAgICAgIGlmICghYmxba2V5XSkge1xuICAgICAgICAgIGJsW2tleV0gPSB0aGlzLl9hZGRNZXRob2RFdmVudExpc3RlbmVyVG9Ob2RlKFxuICAgICAgICAgICAgbm9kZSwgZXZlbnROYW1lLCBtZXRob2ROYW1lLCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENvbnZlbmllbmNlIG1ldGhvZCB0byByZW1vdmUgYW4gZXZlbnQgbGlzdGVuZXIgZnJvbSBhIGdpdmVuIGVsZW1lbnQsXG4gICAgICAgKiBsYXRlIGJvdW5kIHRvIGEgbmFtZWQgbWV0aG9kIG9uIHRoaXMgZWxlbWVudC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgRWxlbWVudCB0byByZW1vdmUgZXZlbnQgbGlzdGVuZXIgZnJvbS5cbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgTmFtZSBvZiBldmVudCB0byBzdG9wIGxpc3RlbmluZyB0by5cbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2ROYW1lIE5hbWUgb2YgaGFuZGxlciBtZXRob2Qgb24gYHRoaXNgIHRvIG5vdCBjYWxsXG4gICAgICAgYW55bW9yZS5cbiAgICAgICAqL1xuICAgICAgdW5saXN0ZW4obm9kZSwgZXZlbnROYW1lLCBtZXRob2ROYW1lKSB7XG4gICAgICAgIG5vZGUgPSAvKiogQHR5cGUge0VsZW1lbnR9ICovIChub2RlIHx8IHRoaXMpO1xuICAgICAgICBsZXQgYmwgPSB0aGlzLl9fYm91bmRMaXN0ZW5lcnMgJiYgdGhpcy5fX2JvdW5kTGlzdGVuZXJzLmdldChub2RlKTtcbiAgICAgICAgbGV0IGtleSA9IGV2ZW50TmFtZSArIG1ldGhvZE5hbWU7XG4gICAgICAgIGxldCBoYW5kbGVyID0gYmwgJiYgYmxba2V5XTtcbiAgICAgICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgICB0aGlzLl9yZW1vdmVFdmVudExpc3RlbmVyRnJvbU5vZGUobm9kZSwgZXZlbnROYW1lLCBoYW5kbGVyKTtcbiAgICAgICAgICBibFtrZXldID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIE92ZXJyaWRlIHNjcm9sbGluZyBiZWhhdmlvciB0byBhbGwgZGlyZWN0aW9uLCBvbmUgZGlyZWN0aW9uLCBvciBub25lLlxuICAgICAgICpcbiAgICAgICAqIFZhbGlkIHNjcm9sbCBkaXJlY3Rpb25zOlxuICAgICAgICogICAtICdhbGwnOiBzY3JvbGwgaW4gYW55IGRpcmVjdGlvblxuICAgICAgICogICAtICd4Jzogc2Nyb2xsIG9ubHkgaW4gdGhlICd4JyBkaXJlY3Rpb25cbiAgICAgICAqICAgLSAneSc6IHNjcm9sbCBvbmx5IGluIHRoZSAneScgZGlyZWN0aW9uXG4gICAgICAgKiAgIC0gJ25vbmUnOiBkaXNhYmxlIHNjcm9sbGluZyBmb3IgdGhpcyBub2RlXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmc9fSBkaXJlY3Rpb24gRGlyZWN0aW9uIHRvIGFsbG93IHNjcm9sbGluZ1xuICAgICAgICogRGVmYXVsdHMgdG8gYGFsbGAuXG4gICAgICAgKiBAcGFyYW0ge0VsZW1lbnQ9fSBub2RlIEVsZW1lbnQgdG8gYXBwbHkgc2Nyb2xsIGRpcmVjdGlvbiBzZXR0aW5nLlxuICAgICAgICogRGVmYXVsdHMgdG8gYHRoaXNgLlxuICAgICAgICovXG4gICAgICBzZXRTY3JvbGxEaXJlY3Rpb24oZGlyZWN0aW9uLCBub2RlKSB7XG4gICAgICAgIFBvbHltZXIuR2VzdHVyZXMuc2V0VG91Y2hBY3Rpb24oLyoqIEB0eXBlIHtFbGVtZW50fSAqLyAobm9kZSB8fCB0aGlzKSwgRElSRUNUSU9OX01BUFtkaXJlY3Rpb25dIHx8ICdhdXRvJyk7XG4gICAgICB9XG4gICAgICAvKiAqKioqIEVuZCBFdmVudHMgKioqKiAqL1xuXG4gICAgICAvKipcbiAgICAgICAqIENvbnZlbmllbmNlIG1ldGhvZCB0byBydW4gYHF1ZXJ5U2VsZWN0b3JgIG9uIHRoaXMgbG9jYWwgRE9NIHNjb3BlLlxuICAgICAgICpcbiAgICAgICAqIFRoaXMgZnVuY3Rpb24gY2FsbHMgYFBvbHltZXIuZG9tKHRoaXMucm9vdCkucXVlcnlTZWxlY3RvcihzbGN0cilgLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzbGN0ciBTZWxlY3RvciB0byBydW4gb24gdGhpcyBsb2NhbCBET00gc2NvcGVcbiAgICAgICAqIEByZXR1cm4ge0VsZW1lbnR9IEVsZW1lbnQgZm91bmQgYnkgdGhlIHNlbGVjdG9yLCBvciBudWxsIGlmIG5vdCBmb3VuZC5cbiAgICAgICAqL1xuICAgICAgJCQoc2xjdHIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdC5xdWVyeVNlbGVjdG9yKHNsY3RyKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZXR1cm4gdGhlIGVsZW1lbnQgd2hvc2UgbG9jYWwgZG9tIHdpdGhpbiB3aGljaCB0aGlzIGVsZW1lbnRcbiAgICAgICAqIGlzIGNvbnRhaW5lZC4gVGhpcyBpcyBhIHNob3J0aGFuZCBmb3JcbiAgICAgICAqIGB0aGlzLmdldFJvb3ROb2RlKCkuaG9zdGAuXG4gICAgICAgKiBAdGhpcyB7RWxlbWVudH1cbiAgICAgICAqL1xuICAgICAgZ2V0IGRvbUhvc3QoKSB7XG4gICAgICAgIGxldCByb290ID0gdGhpcy5nZXRSb290Tm9kZSgpO1xuICAgICAgICByZXR1cm4gKHJvb3QgaW5zdGFuY2VvZiBEb2N1bWVudEZyYWdtZW50KSA/IC8qKiBAdHlwZSB7U2hhZG93Um9vdH0gKi8gKHJvb3QpLmhvc3QgOiByb290O1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEZvcmNlIHRoaXMgZWxlbWVudCB0byBkaXN0cmlidXRlIGl0cyBjaGlsZHJlbiB0byBpdHMgbG9jYWwgZG9tLlxuICAgICAgICogVGhpcyBzaG91bGQgbm90IGJlIG5lY2Vzc2FyeSBhcyBvZiBQb2x5bWVyIDIuMC4yIGFuZCBpcyBwcm92aWRlZCBvbmx5XG4gICAgICAgKiBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG4gICAgICAgKi9cbiAgICAgIGRpc3RyaWJ1dGVDb250ZW50KCkge1xuICAgICAgICBpZiAod2luZG93LlNoYWR5RE9NICYmIHRoaXMuc2hhZG93Um9vdCkge1xuICAgICAgICAgIFNoYWR5RE9NLmZsdXNoKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBub2RlcyB0aGF0IGFyZSB0aGUgZWZmZWN0aXZlIGNoaWxkTm9kZXMuIFRoZSBlZmZlY3RpdmVcbiAgICAgICAqIGNoaWxkTm9kZXMgbGlzdCBpcyB0aGUgc2FtZSBhcyB0aGUgZWxlbWVudCdzIGNoaWxkTm9kZXMgZXhjZXB0IHRoYXRcbiAgICAgICAqIGFueSBgPGNvbnRlbnQ+YCBlbGVtZW50cyBhcmUgcmVwbGFjZWQgd2l0aCB0aGUgbGlzdCBvZiBub2RlcyBkaXN0cmlidXRlZFxuICAgICAgICogdG8gdGhlIGA8Y29udGVudD5gLCB0aGUgcmVzdWx0IG9mIGl0cyBgZ2V0RGlzdHJpYnV0ZWROb2Rlc2AgbWV0aG9kLlxuICAgICAgICogQHRoaXMge0VsZW1lbnR9XG4gICAgICAgKiBAcmV0dXJuIHtBcnJheTxOb2RlPn0gTGlzdCBvZiBlZmZjdGl2ZSBjaGlsZCBub2Rlcy5cbiAgICAgICAqL1xuICAgICAgZ2V0RWZmZWN0aXZlQ2hpbGROb2RlcygpIHtcbiAgICAgICAgcmV0dXJuIC8qKiBAdHlwZSB7UG9seW1lci5Eb21BcGl9ICovIChQb2x5bWVyLmRvbSh0aGlzKSkuZ2V0RWZmZWN0aXZlQ2hpbGROb2RlcygpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJldHVybnMgYSBsaXN0IG9mIG5vZGVzIGRpc3RyaWJ1dGVkIHdpdGhpbiB0aGlzIGVsZW1lbnQgdGhhdCBtYXRjaFxuICAgICAgICogYHNlbGVjdG9yYC4gVGhlc2UgY2FuIGJlIGRvbSBjaGlsZHJlbiBvciBlbGVtZW50cyBkaXN0cmlidXRlZCB0b1xuICAgICAgICogY2hpbGRyZW4gdGhhdCBhcmUgaW5zZXJ0aW9uIHBvaW50cy5cbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzZWxlY3RvciBTZWxlY3RvciB0byBydW4uXG4gICAgICAgKiBAdGhpcyB7RWxlbWVudH1cbiAgICAgICAqIEByZXR1cm4ge0FycmF5PE5vZGU+fSBMaXN0IG9mIGRpc3RyaWJ1dGVkIGVsZW1lbnRzIHRoYXQgbWF0Y2ggc2VsZWN0b3IuXG4gICAgICAgKi9cbiAgICAgIHF1ZXJ5RGlzdHJpYnV0ZWRFbGVtZW50cyhzZWxlY3Rvcikge1xuICAgICAgICByZXR1cm4gLyoqIEB0eXBlIHtQb2x5bWVyLkRvbUFwaX0gKi8gKFBvbHltZXIuZG9tKHRoaXMpKS5xdWVyeURpc3RyaWJ1dGVkRWxlbWVudHMoc2VsZWN0b3IpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJldHVybnMgYSBsaXN0IG9mIGVsZW1lbnRzIHRoYXQgYXJlIHRoZSBlZmZlY3RpdmUgY2hpbGRyZW4uIFRoZSBlZmZlY3RpdmVcbiAgICAgICAqIGNoaWxkcmVuIGxpc3QgaXMgdGhlIHNhbWUgYXMgdGhlIGVsZW1lbnQncyBjaGlsZHJlbiBleGNlcHQgdGhhdFxuICAgICAgICogYW55IGA8Y29udGVudD5gIGVsZW1lbnRzIGFyZSByZXBsYWNlZCB3aXRoIHRoZSBsaXN0IG9mIGVsZW1lbnRzXG4gICAgICAgKiBkaXN0cmlidXRlZCB0byB0aGUgYDxjb250ZW50PmAuXG4gICAgICAgKlxuICAgICAgICogQHJldHVybiB7QXJyYXk8Tm9kZT59IExpc3Qgb2YgZWZmY3RpdmUgY2hpbGRyZW4uXG4gICAgICAgKi9cbiAgICAgIGdldEVmZmVjdGl2ZUNoaWxkcmVuKCkge1xuICAgICAgICBsZXQgbGlzdCA9IHRoaXMuZ2V0RWZmZWN0aXZlQ2hpbGROb2RlcygpO1xuICAgICAgICByZXR1cm4gbGlzdC5maWx0ZXIoZnVuY3Rpb24oLyoqIEB0eXBlIHtOb2RlfSAqLyBuKSB7XG4gICAgICAgICAgcmV0dXJuIChuLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJldHVybnMgYSBzdHJpbmcgb2YgdGV4dCBjb250ZW50IHRoYXQgaXMgdGhlIGNvbmNhdGVuYXRpb24gb2YgdGhlXG4gICAgICAgKiB0ZXh0IGNvbnRlbnQncyBvZiB0aGUgZWxlbWVudCdzIGVmZmVjdGl2ZSBjaGlsZE5vZGVzICh0aGUgZWxlbWVudHNcbiAgICAgICAqIHJldHVybmVkIGJ5IDxhIGhyZWY9XCIjZ2V0RWZmZWN0aXZlQ2hpbGROb2Rlcz5nZXRFZmZlY3RpdmVDaGlsZE5vZGVzPC9hPi5cbiAgICAgICAqXG4gICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IExpc3Qgb2YgZWZmY3RpdmUgY2hpbGRyZW4uXG4gICAgICAgKi9cbiAgICAgIGdldEVmZmVjdGl2ZVRleHRDb250ZW50KCkge1xuICAgICAgICBsZXQgY24gPSB0aGlzLmdldEVmZmVjdGl2ZUNoaWxkTm9kZXMoKTtcbiAgICAgICAgbGV0IHRjID0gW107XG4gICAgICAgIGZvciAobGV0IGk9MCwgYzsgKGMgPSBjbltpXSk7IGkrKykge1xuICAgICAgICAgIGlmIChjLm5vZGVUeXBlICE9PSBOb2RlLkNPTU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgdGMucHVzaChjLnRleHRDb250ZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRjLmpvaW4oJycpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJldHVybnMgdGhlIGZpcnN0IGVmZmVjdGl2ZSBjaGlsZE5vZGUgd2l0aGluIHRoaXMgZWxlbWVudCB0aGF0XG4gICAgICAgKiBtYXRjaCBgc2VsZWN0b3JgLiBUaGVzZSBjYW4gYmUgZG9tIGNoaWxkIG5vZGVzIG9yIGVsZW1lbnRzIGRpc3RyaWJ1dGVkXG4gICAgICAgKiB0byBjaGlsZHJlbiB0aGF0IGFyZSBpbnNlcnRpb24gcG9pbnRzLlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yIFNlbGVjdG9yIHRvIHJ1bi5cbiAgICAgICAqIEByZXR1cm4ge09iamVjdDxOb2RlPn0gRmlyc3QgZWZmZWN0aXZlIGNoaWxkIG5vZGUgdGhhdCBtYXRjaGVzIHNlbGVjdG9yLlxuICAgICAgICovXG4gICAgICBxdWVyeUVmZmVjdGl2ZUNoaWxkcmVuKHNlbGVjdG9yKSB7XG4gICAgICAgIGxldCBlJCA9IHRoaXMucXVlcnlEaXN0cmlidXRlZEVsZW1lbnRzKHNlbGVjdG9yKTtcbiAgICAgICAgcmV0dXJuIGUkICYmIGUkWzBdO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJldHVybnMgYSBsaXN0IG9mIGVmZmVjdGl2ZSBjaGlsZE5vZGVzIHdpdGhpbiB0aGlzIGVsZW1lbnQgdGhhdFxuICAgICAgICogbWF0Y2ggYHNlbGVjdG9yYC4gVGhlc2UgY2FuIGJlIGRvbSBjaGlsZCBub2RlcyBvciBlbGVtZW50cyBkaXN0cmlidXRlZFxuICAgICAgICogdG8gY2hpbGRyZW4gdGhhdCBhcmUgaW5zZXJ0aW9uIHBvaW50cy5cbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzZWxlY3RvciBTZWxlY3RvciB0byBydW4uXG4gICAgICAgKiBAcmV0dXJuIHtBcnJheTxOb2RlPn0gTGlzdCBvZiBlZmZlY3RpdmUgY2hpbGQgbm9kZXMgdGhhdCBtYXRjaCBzZWxlY3Rvci5cbiAgICAgICAqL1xuICAgICAgcXVlcnlBbGxFZmZlY3RpdmVDaGlsZHJlbihzZWxlY3Rvcikge1xuICAgICAgICByZXR1cm4gdGhpcy5xdWVyeURpc3RyaWJ1dGVkRWxlbWVudHMoc2VsZWN0b3IpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJldHVybnMgYSBsaXN0IG9mIG5vZGVzIGRpc3RyaWJ1dGVkIHRvIHRoaXMgZWxlbWVudCdzIGA8c2xvdD5gLlxuICAgICAgICpcbiAgICAgICAqIElmIHRoaXMgZWxlbWVudCBjb250YWlucyBtb3JlIHRoYW4gb25lIGA8c2xvdD5gIGluIGl0cyBsb2NhbCBET00sXG4gICAgICAgKiBhbiBvcHRpb25hbCBzZWxlY3RvciBtYXkgYmUgcGFzc2VkIHRvIGNob29zZSB0aGUgZGVzaXJlZCBjb250ZW50LlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nPX0gc2xjdHIgQ1NTIHNlbGVjdG9yIHRvIGNob29zZSB0aGUgZGVzaXJlZFxuICAgICAgICogICBgPHNsb3Q+YC4gIERlZmF1bHRzIHRvIGBjb250ZW50YC5cbiAgICAgICAqIEByZXR1cm4ge0FycmF5PE5vZGU+fSBMaXN0IG9mIGRpc3RyaWJ1dGVkIG5vZGVzIGZvciB0aGUgYDxzbG90PmAuXG4gICAgICAgKi9cbiAgICAgIGdldENvbnRlbnRDaGlsZE5vZGVzKHNsY3RyKSB7XG4gICAgICAgIGxldCBjb250ZW50ID0gdGhpcy5yb290LnF1ZXJ5U2VsZWN0b3Ioc2xjdHIgfHwgJ3Nsb3QnKTtcbiAgICAgICAgcmV0dXJuIGNvbnRlbnQgPyAvKiogQHR5cGUge1BvbHltZXIuRG9tQXBpfSAqLyhQb2x5bWVyLmRvbShjb250ZW50KSkuZ2V0RGlzdHJpYnV0ZWROb2RlcygpIDogW107XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUmV0dXJucyBhIGxpc3Qgb2YgZWxlbWVudCBjaGlsZHJlbiBkaXN0cmlidXRlZCB0byB0aGlzIGVsZW1lbnQnc1xuICAgICAgICogYDxzbG90PmAuXG4gICAgICAgKlxuICAgICAgICogSWYgdGhpcyBlbGVtZW50IGNvbnRhaW5zIG1vcmUgdGhhbiBvbmUgYDxzbG90PmAgaW4gaXRzXG4gICAgICAgKiBsb2NhbCBET00sIGFuIG9wdGlvbmFsIHNlbGVjdG9yIG1heSBiZSBwYXNzZWQgdG8gY2hvb3NlIHRoZSBkZXNpcmVkXG4gICAgICAgKiBjb250ZW50LiAgVGhpcyBtZXRob2QgZGlmZmVycyBmcm9tIGBnZXRDb250ZW50Q2hpbGROb2Rlc2AgaW4gdGhhdCBvbmx5XG4gICAgICAgKiBlbGVtZW50cyBhcmUgcmV0dXJuZWQuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmc9fSBzbGN0ciBDU1Mgc2VsZWN0b3IgdG8gY2hvb3NlIHRoZSBkZXNpcmVkXG4gICAgICAgKiAgIGA8Y29udGVudD5gLiAgRGVmYXVsdHMgdG8gYGNvbnRlbnRgLlxuICAgICAgICogQHJldHVybiB7QXJyYXk8SFRNTEVsZW1lbnQ+fSBMaXN0IG9mIGRpc3RyaWJ1dGVkIG5vZGVzIGZvciB0aGVcbiAgICAgICAqICAgYDxzbG90PmAuXG4gICAgICAgKiBAc3VwcHJlc3Mge2ludmFsaWRDYXN0c31cbiAgICAgICAqL1xuICAgICAgZ2V0Q29udGVudENoaWxkcmVuKHNsY3RyKSB7XG4gICAgICAgIHJldHVybiAvKiogQHR5cGUge0FycmF5PEhUTUxFbGVtZW50Pn0gKi8odGhpcy5nZXRDb250ZW50Q2hpbGROb2RlcyhzbGN0cikuZmlsdGVyKGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgICByZXR1cm4gKG4ubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKTtcbiAgICAgICAgfSkpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENoZWNrcyB3aGV0aGVyIGFuIGVsZW1lbnQgaXMgaW4gdGhpcyBlbGVtZW50J3MgbGlnaHQgRE9NIHRyZWUuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHs/Tm9kZX0gbm9kZSBUaGUgZWxlbWVudCB0byBiZSBjaGVja2VkLlxuICAgICAgICogQHRoaXMge0VsZW1lbnR9XG4gICAgICAgKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIG5vZGUgaXMgaW4gdGhpcyBlbGVtZW50J3MgbGlnaHQgRE9NIHRyZWUuXG4gICAgICAgKi9cbiAgICAgIGlzTGlnaHREZXNjZW5kYW50KG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMgIT09IG5vZGUgJiYgdGhpcy5jb250YWlucyhub2RlKSAmJlxuICAgICAgICAgICAgdGhpcy5nZXRSb290Tm9kZSgpID09PSBub2RlLmdldFJvb3ROb2RlKCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ2hlY2tzIHdoZXRoZXIgYW4gZWxlbWVudCBpcyBpbiB0aGlzIGVsZW1lbnQncyBsb2NhbCBET00gdHJlZS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge0VsZW1lbnQ9fSBub2RlIFRoZSBlbGVtZW50IHRvIGJlIGNoZWNrZWQuXG4gICAgICAgKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIG5vZGUgaXMgaW4gdGhpcyBlbGVtZW50J3MgbG9jYWwgRE9NIHRyZWUuXG4gICAgICAgKi9cbiAgICAgIGlzTG9jYWxEZXNjZW5kYW50KG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdCA9PT0gbm9kZS5nZXRSb290Tm9kZSgpO1xuICAgICAgfVxuXG4gICAgICAvLyBOT1RFOiBzaG91bGQgbm93IGJlIGhhbmRsZWQgYnkgU2hhZHlDc3MgbGlicmFyeS5cbiAgICAgIHNjb3BlU3VidHJlZShjb250YWluZXIsIHNob3VsZE9ic2VydmUpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJldHVybnMgdGhlIGNvbXB1dGVkIHN0eWxlIHZhbHVlIGZvciB0aGUgZ2l2ZW4gcHJvcGVydHkuXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgVGhlIGNzcyBwcm9wZXJ0eSBuYW1lLlxuICAgICAgICogQHJldHVybiB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb21wdXRlZCBjc3MgcHJvcGVydHkgdmFsdWUgZm9yIHRoZSBnaXZlblxuICAgICAgICogYHByb3BlcnR5YC5cbiAgICAgICAqL1xuICAgICAgZ2V0Q29tcHV0ZWRTdHlsZVZhbHVlKHByb3BlcnR5KSB7XG4gICAgICAgIHJldHVybiBzdHlsZUludGVyZmFjZS5nZXRDb21wdXRlZFN0eWxlVmFsdWUodGhpcywgcHJvcGVydHkpO1xuICAgICAgfVxuXG4gICAgICAvLyBkZWJvdW5jZVxuXG4gICAgICAvKipcbiAgICAgICAqIENhbGwgYGRlYm91bmNlYCB0byBjb2xsYXBzZSBtdWx0aXBsZSByZXF1ZXN0cyBmb3IgYSBuYW1lZCB0YXNrIGludG9cbiAgICAgICAqIG9uZSBpbnZvY2F0aW9uIHdoaWNoIGlzIG1hZGUgYWZ0ZXIgdGhlIHdhaXQgdGltZSBoYXMgZWxhcHNlZCB3aXRoXG4gICAgICAgKiBubyBuZXcgcmVxdWVzdC4gIElmIG5vIHdhaXQgdGltZSBpcyBnaXZlbiwgdGhlIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkXG4gICAgICAgKiBhdCBtaWNyb3Rhc2sgdGltaW5nIChndWFyYW50ZWVkIGJlZm9yZSBwYWludCkuXG4gICAgICAgKlxuICAgICAgICogICAgIGRlYm91bmNlZENsaWNrQWN0aW9uKGUpIHtcbiAgICAgICAqICAgICAgIC8vIHdpbGwgbm90IGNhbGwgYHByb2Nlc3NDbGlja2AgbW9yZSB0aGFuIG9uY2UgcGVyIDEwMG1zXG4gICAgICAgKiAgICAgICB0aGlzLmRlYm91bmNlKCdjbGljaycsIGZ1bmN0aW9uKCkge1xuICAgICAgICogICAgICAgIHRoaXMucHJvY2Vzc0NsaWNrKCk7XG4gICAgICAgKiAgICAgICB9IDEwMCk7XG4gICAgICAgKiAgICAgfVxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBqb2JOYW1lIFN0cmluZyB0byBpbmRlbnRpZnkgdGhlIGRlYm91bmNlIGpvYi5cbiAgICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oKX0gY2FsbGJhY2sgRnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgKHdpdGggYHRoaXNgXG4gICAgICAgKiAgIGNvbnRleHQpIHdoZW4gdGhlIHdhaXQgdGltZSBlbGFwc2VzLlxuICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHdhaXQgT3B0aW9uYWwgd2FpdCB0aW1lIGluIG1pbGxpc2Vjb25kcyAobXMpIGFmdGVyIHRoZVxuICAgICAgICogICBsYXN0IHNpZ25hbCB0aGF0IG11c3QgZWxhcHNlIGJlZm9yZSBpbnZva2luZyBgY2FsbGJhY2tgXG4gICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFJldHVybnMgYSBkZWJvdW5jZXIgb2JqZWN0IG9uIHdoaWNoIGV4aXN0cyB0aGVcbiAgICAgICAqIGZvbGxvd2luZyBtZXRob2RzOiBgaXNBY3RpdmUoKWAgcmV0dXJucyB0cnVlIGlmIHRoZSBkZWJvdW5jZXIgaXNcbiAgICAgICAqIGFjdGl2ZTsgYGNhbmNlbCgpYCBjYW5jZWxzIHRoZSBkZWJvdW5jZXIgaWYgaXQgaXMgYWN0aXZlO1xuICAgICAgICogYGZsdXNoKClgIGltbWVkaWF0ZWx5IGludm9rZXMgdGhlIGRlYm91bmNlZCBjYWxsYmFjayBpZiB0aGUgZGVib3VuY2VyXG4gICAgICAgKiBpcyBhY3RpdmUuXG4gICAgICAgKi9cbiAgICAgIGRlYm91bmNlKGpvYk5hbWUsIGNhbGxiYWNrLCB3YWl0KSB7XG4gICAgICAgIHRoaXMuX2RlYm91bmNlcnMgPSB0aGlzLl9kZWJvdW5jZXJzIHx8IHt9O1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVib3VuY2Vyc1tqb2JOYW1lXSA9IFBvbHltZXIuRGVib3VuY2VyLmRlYm91bmNlKFxuICAgICAgICAgICAgICB0aGlzLl9kZWJvdW5jZXJzW2pvYk5hbWVdXG4gICAgICAgICAgICAsIHdhaXQgPiAwID8gUG9seW1lci5Bc3luYy50aW1lT3V0LmFmdGVyKHdhaXQpIDogUG9seW1lci5Bc3luYy5taWNyb1Rhc2tcbiAgICAgICAgICAgICwgY2FsbGJhY2suYmluZCh0aGlzKSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUmV0dXJucyB3aGV0aGVyIGEgbmFtZWQgZGVib3VuY2VyIGlzIGFjdGl2ZS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gam9iTmFtZSBUaGUgbmFtZSBvZiB0aGUgZGVib3VuY2VyIHN0YXJ0ZWQgd2l0aCBgZGVib3VuY2VgXG4gICAgICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBkZWJvdW5jZXIgaXMgYWN0aXZlIChoYXMgbm90IHlldCBmaXJlZCkuXG4gICAgICAgKi9cbiAgICAgIGlzRGVib3VuY2VyQWN0aXZlKGpvYk5hbWUpIHtcbiAgICAgICAgdGhpcy5fZGVib3VuY2VycyA9IHRoaXMuX2RlYm91bmNlcnMgfHwge307XG4gICAgICAgIGxldCBkZWJvdW5jZXIgPSB0aGlzLl9kZWJvdW5jZXJzW2pvYk5hbWVdO1xuICAgICAgICByZXR1cm4gISEoZGVib3VuY2VyICYmIGRlYm91bmNlci5pc0FjdGl2ZSgpKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBJbW1lZGlhdGVseSBjYWxscyB0aGUgZGVib3VuY2VyIGBjYWxsYmFja2AgYW5kIGluYWN0aXZhdGVzIGl0LlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBqb2JOYW1lIFRoZSBuYW1lIG9mIHRoZSBkZWJvdW5jZXIgc3RhcnRlZCB3aXRoIGBkZWJvdW5jZWBcbiAgICAgICAqL1xuICAgICAgZmx1c2hEZWJvdW5jZXIoam9iTmFtZSkge1xuICAgICAgICB0aGlzLl9kZWJvdW5jZXJzID0gdGhpcy5fZGVib3VuY2VycyB8fCB7fTtcbiAgICAgICAgbGV0IGRlYm91bmNlciA9IHRoaXMuX2RlYm91bmNlcnNbam9iTmFtZV07XG4gICAgICAgIGlmIChkZWJvdW5jZXIpIHtcbiAgICAgICAgICBkZWJvdW5jZXIuZmx1c2goKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENhbmNlbHMgYW4gYWN0aXZlIGRlYm91bmNlci4gIFRoZSBgY2FsbGJhY2tgIHdpbGwgbm90IGJlIGNhbGxlZC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gam9iTmFtZSBUaGUgbmFtZSBvZiB0aGUgZGVib3VuY2VyIHN0YXJ0ZWQgd2l0aCBgZGVib3VuY2VgXG4gICAgICAgKi9cbiAgICAgIGNhbmNlbERlYm91bmNlcihqb2JOYW1lKSB7XG4gICAgICAgIHRoaXMuX2RlYm91bmNlcnMgPSB0aGlzLl9kZWJvdW5jZXJzIHx8IHt9XG4gICAgICAgIGxldCBkZWJvdW5jZXIgPSB0aGlzLl9kZWJvdW5jZXJzW2pvYk5hbWVdO1xuICAgICAgICBpZiAoZGVib3VuY2VyKSB7XG4gICAgICAgICAgZGVib3VuY2VyLmNhbmNlbCgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUnVucyBhIGNhbGxiYWNrIGZ1bmN0aW9uIGFzeW5jcm9ub3VzbHkuXG4gICAgICAgKlxuICAgICAgICogQnkgZGVmYXVsdCAoaWYgbm8gd2FpdFRpbWUgaXMgc3BlY2lmaWVkKSwgYXN5bmMgY2FsbGJhY2tzIGFyZSBydW4gYXRcbiAgICAgICAqIG1pY3JvdGFzayB0aW1pbmcsIHdoaWNoIHdpbGwgb2NjdXIgYmVmb3JlIHBhaW50LlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBjYWxsYmFjayBmdW5jdGlvbiB0byBydW4sIGJvdW5kIHRvIGB0aGlzYC5cbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gd2FpdFRpbWUgVGltZSB0byB3YWl0IGJlZm9yZSBjYWxsaW5nIHRoZVxuICAgICAgICogICBgY2FsbGJhY2tgLiAgSWYgdW5zcGVjaWZpZWQgb3IgMCwgdGhlIGNhbGxiYWNrIHdpbGwgYmUgcnVuIGF0IG1pY3JvdGFza1xuICAgICAgICogICB0aW1pbmcgKGJlZm9yZSBwYWludCkuXG4gICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IEhhbmRsZSB0aGF0IG1heSBiZSB1c2VkIHRvIGNhbmNlbCB0aGUgYXN5bmMgam9iLlxuICAgICAgICovXG4gICAgICBhc3luYyhjYWxsYmFjaywgd2FpdFRpbWUpIHtcbiAgICAgICAgcmV0dXJuIHdhaXRUaW1lID4gMCA/IFBvbHltZXIuQXN5bmMudGltZU91dC5ydW4oY2FsbGJhY2suYmluZCh0aGlzKSwgd2FpdFRpbWUpIDpcbiAgICAgICAgICAgIH5Qb2x5bWVyLkFzeW5jLm1pY3JvVGFzay5ydW4oY2FsbGJhY2suYmluZCh0aGlzKSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ2FuY2VscyBhbiBhc3luYyBvcGVyYXRpb24gc3RhcnRlZCB3aXRoIGBhc3luY2AuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGhhbmRsZSBIYW5kbGUgcmV0dXJuZWQgZnJvbSBvcmlnaW5hbCBgYXN5bmNgIGNhbGwgdG9cbiAgICAgICAqICAgY2FuY2VsLlxuICAgICAgICovXG4gICAgICBjYW5jZWxBc3luYyhoYW5kbGUpIHtcbiAgICAgICAgaGFuZGxlIDwgMCA/IFBvbHltZXIuQXN5bmMubWljcm9UYXNrLmNhbmNlbCh+aGFuZGxlKSA6XG4gICAgICAgICAgICBQb2x5bWVyLkFzeW5jLnRpbWVPdXQuY2FuY2VsKGhhbmRsZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIG90aGVyXG5cbiAgICAgIC8qKlxuICAgICAgICogQ29udmVuaWVuY2UgbWV0aG9kIGZvciBjcmVhdGluZyBhbiBlbGVtZW50IGFuZCBjb25maWd1cmluZyBpdC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGFnIEhUTUwgZWxlbWVudCB0YWcgdG8gY3JlYXRlLlxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzIE9iamVjdCBvZiBwcm9wZXJ0aWVzIHRvIGNvbmZpZ3VyZSBvbiB0aGVcbiAgICAgICAqICAgIGluc3RhbmNlLlxuICAgICAgICogQHJldHVybiB7RWxlbWVudH0gTmV3bHkgY3JlYXRlZCBhbmQgY29uZmlndXJlZCBlbGVtZW50LlxuICAgICAgICovXG4gICAgICBjcmVhdGUodGFnLCBwcm9wcykge1xuICAgICAgICBsZXQgZWx0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgICBpZiAocHJvcHMpIHtcbiAgICAgICAgICBpZiAoZWx0LnNldFByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIGVsdC5zZXRQcm9wZXJ0aWVzKHByb3BzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yIChsZXQgbiBpbiBwcm9wcykge1xuICAgICAgICAgICAgICBlbHRbbl0gPSBwcm9wc1tuXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVsdDtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDb252ZW5pZW5jZSBtZXRob2QgZm9yIGltcG9ydGluZyBhbiBIVE1MIGRvY3VtZW50IGltcGVyYXRpdmVseS5cbiAgICAgICAqXG4gICAgICAgKiBUaGlzIG1ldGhvZCBjcmVhdGVzIGEgbmV3IGA8bGluayByZWw9XCJpbXBvcnRcIj5gIGVsZW1lbnQgd2l0aFxuICAgICAgICogdGhlIHByb3ZpZGVkIFVSTCBhbmQgYXBwZW5kcyBpdCB0byB0aGUgZG9jdW1lbnQgdG8gc3RhcnQgbG9hZGluZy5cbiAgICAgICAqIEluIHRoZSBgb25sb2FkYCBjYWxsYmFjaywgdGhlIGBpbXBvcnRgIHByb3BlcnR5IG9mIHRoZSBgbGlua2BcbiAgICAgICAqIGVsZW1lbnQgd2lsbCBjb250YWluIHRoZSBpbXBvcnRlZCBkb2N1bWVudCBjb250ZW50cy5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gaHJlZiBVUkwgdG8gZG9jdW1lbnQgdG8gbG9hZC5cbiAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG9ubG9hZCBDYWxsYmFjayB0byBub3RpZnkgd2hlbiBhbiBpbXBvcnQgc3VjY2Vzc2Z1bGx5XG4gICAgICAgKiAgIGxvYWRlZC5cbiAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG9uZXJyb3IgQ2FsbGJhY2sgdG8gbm90aWZ5IHdoZW4gYW4gaW1wb3J0XG4gICAgICAgKiAgIHVuc3VjY2Vzc2Z1bGx5IGxvYWRlZC5cbiAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0QXN5bmMgVHJ1ZSBpZiB0aGUgaW1wb3J0IHNob3VsZCBiZSBsb2FkZWQgYGFzeW5jYC5cbiAgICAgICAqICAgRGVmYXVsdHMgdG8gYGZhbHNlYC5cbiAgICAgICAqIEByZXR1cm4ge0hUTUxMaW5rRWxlbWVudH0gVGhlIGxpbmsgZWxlbWVudCBmb3IgdGhlIFVSTCB0byBiZSBsb2FkZWQuXG4gICAgICAgKi9cbiAgICAgIGltcG9ydEhyZWYoaHJlZiwgb25sb2FkLCBvbmVycm9yLCBvcHRBc3luYykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICAgIGxldCBsb2FkRm4gPSBvbmxvYWQgPyBvbmxvYWQuYmluZCh0aGlzKSA6IG51bGw7XG4gICAgICAgIGxldCBlcnJvckZuID0gb25lcnJvciA/IG9uZXJyb3IuYmluZCh0aGlzKSA6IG51bGw7XG4gICAgICAgIHJldHVybiBQb2x5bWVyLmltcG9ydEhyZWYoaHJlZiwgbG9hZEZuLCBlcnJvckZuLCBvcHRBc3luYyk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUG9seWZpbGwgZm9yIEVsZW1lbnQucHJvdG90eXBlLm1hdGNoZXMsIHdoaWNoIGlzIHNvbWV0aW1lcyBzdGlsbFxuICAgICAgICogcHJlZml4ZWQuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yIFNlbGVjdG9yIHRvIHRlc3QuXG4gICAgICAgKiBAcGFyYW0ge0VsZW1lbnQ9fSBub2RlIEVsZW1lbnQgdG8gdGVzdCB0aGUgc2VsZWN0b3IgYWdhaW5zdC5cbiAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIGVsZW1lbnQgbWF0Y2hlcyB0aGUgc2VsZWN0b3IuXG4gICAgICAgKi9cbiAgICAgIGVsZW1lbnRNYXRjaGVzKHNlbGVjdG9yLCBub2RlKSB7XG4gICAgICAgIHJldHVybiBQb2x5bWVyLmRvbS5tYXRjaGVzU2VsZWN0b3IoLyoqIEB0eXBlIHshRWxlbWVudH0gKi8gKG5vZGUgfHwgdGhpcyksIHNlbGVjdG9yKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBUb2dnbGVzIGFuIEhUTUwgYXR0cmlidXRlIG9uIG9yIG9mZi5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBIVE1MIGF0dHJpYnV0ZSBuYW1lXG4gICAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBib29sIEJvb2xlYW4gdG8gZm9yY2UgdGhlIGF0dHJpYnV0ZSBvbiBvciBvZmYuXG4gICAgICAgKiAgICBXaGVuIHVuc3BlY2lmaWVkLCB0aGUgc3RhdGUgb2YgdGhlIGF0dHJpYnV0ZSB3aWxsIGJlIHJldmVyc2VkLlxuICAgICAgICogQHBhcmFtIHtFbGVtZW50PX0gbm9kZSBOb2RlIHRvIHRhcmdldC4gIERlZmF1bHRzIHRvIGB0aGlzYC5cbiAgICAgICAqL1xuICAgICAgdG9nZ2xlQXR0cmlidXRlKG5hbWUsIGJvb2wsIG5vZGUpIHtcbiAgICAgICAgbm9kZSA9IC8qKiBAdHlwZSB7RWxlbWVudH0gKi8gKG5vZGUgfHwgdGhpcyk7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICBib29sID0gIW5vZGUuaGFzQXR0cmlidXRlKG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChib29sKSB7XG4gICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUobmFtZSwgJycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgICAgICB9XG4gICAgICB9XG5cblxuICAgICAgLyoqXG4gICAgICAgKiBUb2dnbGVzIGEgQ1NTIGNsYXNzIG9uIG9yIG9mZi5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBDU1MgY2xhc3MgbmFtZVxuICAgICAgICogQHBhcmFtIHtib29sZWFuPX0gYm9vbCBCb29sZWFuIHRvIGZvcmNlIHRoZSBjbGFzcyBvbiBvciBvZmYuXG4gICAgICAgKiAgICBXaGVuIHVuc3BlY2lmaWVkLCB0aGUgc3RhdGUgb2YgdGhlIGNsYXNzIHdpbGwgYmUgcmV2ZXJzZWQuXG4gICAgICAgKiBAcGFyYW0ge0VsZW1lbnQ9fSBub2RlIE5vZGUgdG8gdGFyZ2V0LiAgRGVmYXVsdHMgdG8gYHRoaXNgLlxuICAgICAgICovXG4gICAgICB0b2dnbGVDbGFzcyhuYW1lLCBib29sLCBub2RlKSB7XG4gICAgICAgIG5vZGUgPSAvKiogQHR5cGUge0VsZW1lbnR9ICovIChub2RlIHx8IHRoaXMpO1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgYm9vbCA9ICFub2RlLmNsYXNzTGlzdC5jb250YWlucyhuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYm9vbCkge1xuICAgICAgICAgIG5vZGUuY2xhc3NMaXN0LmFkZChuYW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub2RlLmNsYXNzTGlzdC5yZW1vdmUobmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDcm9zcy1wbGF0Zm9ybSBoZWxwZXIgZm9yIHNldHRpbmcgYW4gZWxlbWVudCdzIENTUyBgdHJhbnNmb3JtYCBwcm9wZXJ0eS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHJhbnNmb3JtVGV4dCBUcmFuc2Zvcm0gc2V0dGluZy5cbiAgICAgICAqIEBwYXJhbSB7RWxlbWVudD19IG5vZGUgRWxlbWVudCB0byBhcHBseSB0aGUgdHJhbnNmb3JtIHRvLlxuICAgICAgICogRGVmYXVsdHMgdG8gYHRoaXNgXG4gICAgICAgKi9cbiAgICAgIHRyYW5zZm9ybSh0cmFuc2Zvcm1UZXh0LCBub2RlKSB7XG4gICAgICAgIG5vZGUgPSAvKiogQHR5cGUge0VsZW1lbnR9ICovIChub2RlIHx8IHRoaXMpO1xuICAgICAgICBub2RlLnN0eWxlLndlYmtpdFRyYW5zZm9ybSA9IHRyYW5zZm9ybVRleHQ7XG4gICAgICAgIG5vZGUuc3R5bGUudHJhbnNmb3JtID0gdHJhbnNmb3JtVGV4dDtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDcm9zcy1wbGF0Zm9ybSBoZWxwZXIgZm9yIHNldHRpbmcgYW4gZWxlbWVudCdzIENTUyBgdHJhbnNsYXRlM2RgXG4gICAgICAgKiBwcm9wZXJ0eS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0geCBYIG9mZnNldC5cbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IFkgb2Zmc2V0LlxuICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHogWiBvZmZzZXQuXG4gICAgICAgKiBAcGFyYW0ge0VsZW1lbnQ9fSBub2RlIEVsZW1lbnQgdG8gYXBwbHkgdGhlIHRyYW5zZm9ybSB0by5cbiAgICAgICAqIERlZmF1bHRzIHRvIGB0aGlzYC5cbiAgICAgICAqL1xuICAgICAgdHJhbnNsYXRlM2QoeCwgeSwgeiwgbm9kZSkge1xuICAgICAgICBub2RlID0gLyoqIEB0eXBlIHtFbGVtZW50fSAqLyAobm9kZSB8fCB0aGlzKTtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0oJ3RyYW5zbGF0ZTNkKCcgKyB4ICsgJywnICsgeSArICcsJyArIHogKyAnKScsIG5vZGUpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJlbW92ZXMgYW4gaXRlbSBmcm9tIGFuIGFycmF5LCBpZiBpdCBleGlzdHMuXG4gICAgICAgKlxuICAgICAgICogSWYgdGhlIGFycmF5IGlzIHNwZWNpZmllZCBieSBwYXRoLCBhIGNoYW5nZSBub3RpZmljYXRpb24gaXNcbiAgICAgICAqIGdlbmVyYXRlZCwgc28gdGhhdCBvYnNlcnZlcnMsIGRhdGEgYmluZGluZ3MgYW5kIGNvbXB1dGVkXG4gICAgICAgKiBwcm9wZXJ0aWVzIHdhdGNoaW5nIHRoYXQgcGF0aCBjYW4gdXBkYXRlLlxuICAgICAgICpcbiAgICAgICAqIElmIHRoZSBhcnJheSBpcyBwYXNzZWQgZGlyZWN0bHksICoqbm8gY2hhbmdlXG4gICAgICAgKiBub3RpZmljYXRpb24gaXMgZ2VuZXJhdGVkKiouXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmcgfCAhQXJyYXk8bnVtYmVyfHN0cmluZz59IGFycmF5T3JQYXRoIFBhdGggdG8gYXJyYXkgZnJvbSB3aGljaCB0byByZW1vdmUgdGhlIGl0ZW1cbiAgICAgICAqICAgKG9yIHRoZSBhcnJheSBpdHNlbGYpLlxuICAgICAgICogQHBhcmFtIHsqfSBpdGVtIEl0ZW0gdG8gcmVtb3ZlLlxuICAgICAgICogQHJldHVybiB7QXJyYXl9IEFycmF5IGNvbnRhaW5pbmcgaXRlbSByZW1vdmVkLlxuICAgICAgICovXG4gICAgICBhcnJheURlbGV0ZShhcnJheU9yUGF0aCwgaXRlbSkge1xuICAgICAgICBsZXQgaW5kZXg7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFycmF5T3JQYXRoKSkge1xuICAgICAgICAgIGluZGV4ID0gYXJyYXlPclBhdGguaW5kZXhPZihpdGVtKTtcbiAgICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGFycmF5T3JQYXRoLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxldCBhcnIgPSBQb2x5bWVyLlBhdGguZ2V0KHRoaXMsIGFycmF5T3JQYXRoKTtcbiAgICAgICAgICBpbmRleCA9IGFyci5pbmRleE9mKGl0ZW0pO1xuICAgICAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zcGxpY2UoYXJyYXlPclBhdGgsIGluZGV4LCAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIC8vIGxvZ2dpbmdcblxuICAgICAgLyoqXG4gICAgICAgKiBGYWNhZGVzIGBjb25zb2xlLmxvZ2AvYHdhcm5gL2BlcnJvcmAgYXMgb3ZlcnJpZGUgcG9pbnQuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGxldmVsIE9uZSBvZiAnbG9nJywgJ3dhcm4nLCAnZXJyb3InXG4gICAgICAgKiBAcGFyYW0ge0FycmF5fSBhcmdzIEFycmF5IG9mIHN0cmluZ3Mgb3Igb2JqZWN0cyB0byBsb2dcbiAgICAgICAqL1xuICAgICAgX2xvZ2dlcihsZXZlbCwgYXJncykge1xuICAgICAgICAvLyBhY2NlcHQgWydmb28nLCAnYmFyJ10gYW5kIFtbJ2ZvbycsICdiYXInXV1cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJncykgJiYgYXJncy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICBhcmdzID0gYXJnc1swXTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2gobGV2ZWwpIHtcbiAgICAgICAgICBjYXNlICdsb2cnOlxuICAgICAgICAgIGNhc2UgJ3dhcm4nOlxuICAgICAgICAgIGNhc2UgJ2Vycm9yJzpcbiAgICAgICAgICAgIGNvbnNvbGVbbGV2ZWxdKC4uLmFyZ3MpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogRmFjYWRlcyBgY29uc29sZS5sb2dgIGFzIGFuIG92ZXJyaWRlIHBvaW50LlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7Li4uKn0gYXJncyBBcnJheSBvZiBzdHJpbmdzIG9yIG9iamVjdHMgdG8gbG9nXG4gICAgICAgKi9cbiAgICAgIF9sb2coLi4uYXJncykge1xuICAgICAgICB0aGlzLl9sb2dnZXIoJ2xvZycsIGFyZ3MpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEZhY2FkZXMgYGNvbnNvbGUud2FybmAgYXMgYW4gb3ZlcnJpZGUgcG9pbnQuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHsuLi4qfSBhcmdzIEFycmF5IG9mIHN0cmluZ3Mgb3Igb2JqZWN0cyB0byBsb2dcbiAgICAgICAqL1xuICAgICAgX3dhcm4oLi4uYXJncykge1xuICAgICAgICB0aGlzLl9sb2dnZXIoJ3dhcm4nLCBhcmdzKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBGYWNhZGVzIGBjb25zb2xlLmVycm9yYCBhcyBhbiBvdmVycmlkZSBwb2ludC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0gey4uLip9IGFyZ3MgQXJyYXkgb2Ygc3RyaW5ncyBvciBvYmplY3RzIHRvIGxvZ1xuICAgICAgICovXG4gICAgICBfZXJyb3IoLi4uYXJncykge1xuICAgICAgICB0aGlzLl9sb2dnZXIoJ2Vycm9yJywgYXJncylcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBGb3JtYXRzIGEgbWVzc2FnZSB1c2luZyB0aGUgZWxlbWVudCB0eXBlIGFuIGEgbWV0aG9kIG5hbWUuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZE5hbWUgTWV0aG9kIG5hbWUgdG8gYXNzb2NpYXRlIHdpdGggbWVzc2FnZVxuICAgICAgICogQHBhcmFtIHsuLi4qfSBhcmdzIEFycmF5IG9mIHN0cmluZ3Mgb3Igb2JqZWN0cyB0byBsb2dcbiAgICAgICAqIEByZXR1cm4ge0FycmF5fSBBcnJheSB3aXRoIGZvcm1hdHRpbmcgaW5mb3JtYXRpb24gZm9yIGBjb25zb2xlYFxuICAgICAgICogICBsb2dnaW5nLlxuICAgICAgICovXG4gICAgICBfbG9nZihtZXRob2ROYW1lLCAuLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiBbJ1slczo6JXNdJywgdGhpcy5pcywgbWV0aG9kTmFtZSwgLi4uYXJnc107XG4gICAgICB9XG5cbiAgICB9XG5cbiAgICBMZWdhY3lFbGVtZW50LnByb3RvdHlwZS5pcyA9ICcnO1xuXG4gICAgcmV0dXJuIExlZ2FjeUVsZW1lbnQ7XG5cbiAgfSk7XG5cbn0pKCk7XG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvbGVnYWN5L2xlZ2FjeS1lbGVtZW50LW1peGluLmh0bWwiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vdXRpbHMvYm9vdC5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vdXRpbHMvbWl4aW4uaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3V0aWxzL2dlc3R1cmVzLmh0bWxcIj5cblxuPHNjcmlwdD5cbihmdW5jdGlvbigpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgLyoqXG4gICAqIEBjb25zdCB7UG9seW1lci5HZXN0dXJlc31cbiAgICovXG4gIGNvbnN0IGdlc3R1cmVzID0gUG9seW1lci5HZXN0dXJlcztcblxuICAvKipcbiAgICogRWxlbWVudCBjbGFzcyBtaXhpbiB0aGF0IHByb3ZpZGVzIEFQSSBmb3IgYWRkaW5nIFBvbHltZXIncyBjcm9zcy1wbGF0Zm9ybVxuICAgKiBnZXN0dXJlIGV2ZW50cyB0byBub2Rlcy5cbiAgICpcbiAgICogVGhlIEFQSSBpcyBkZXNpZ25lZCB0byBiZSBjb21wYXRpYmxlIHdpdGggb3ZlcnJpZGUgcG9pbnRzIGltcGxlbWVudGVkXG4gICAqIGluIGBQb2x5bWVyLlRlbXBsYXRlU3RhbXBgIHN1Y2ggdGhhdCBkZWNsYXJhdGl2ZSBldmVudCBsaXN0ZW5lcnMgaW5cbiAgICogdGVtcGxhdGVzIHdpbGwgc3VwcG9ydCBnZXN0dXJlIGV2ZW50cyB3aGVuIHRoaXMgbWl4aW4gaXMgYXBwbGllZCBhbG9uZyB3aXRoXG4gICAqIGBQb2x5bWVyLlRlbXBsYXRlU3RhbXBgLlxuICAgKlxuICAgKiBAbWl4aW5GdW5jdGlvblxuICAgKiBAcG9seW1lclxuICAgKiBAbWVtYmVyb2YgUG9seW1lclxuICAgKiBAc3VtbWFyeSBFbGVtZW50IGNsYXNzIG1peGluIHRoYXQgcHJvdmlkZXMgQVBJIGZvciBhZGRpbmcgUG9seW1lcidzIGNyb3NzLXBsYXRmb3JtXG4gICAqIGdlc3R1cmUgZXZlbnRzIHRvIG5vZGVzXG4gICAqL1xuICBQb2x5bWVyLkdlc3R1cmVFdmVudExpc3RlbmVycyA9IFBvbHltZXIuZGVkdXBpbmdNaXhpbihzdXBlckNsYXNzID0+IHtcblxuICAgIC8qKlxuICAgICAqIEBwb2x5bWVyXG4gICAgICogQG1peGluQ2xhc3NcbiAgICAgKiBAaW1wbGVtZW50cyB7UG9seW1lcl9HZXN0dXJlRXZlbnRMaXN0ZW5lcnN9XG4gICAgICovXG4gICAgY2xhc3MgR2VzdHVyZUV2ZW50TGlzdGVuZXJzIGV4dGVuZHMgc3VwZXJDbGFzcyB7XG5cbiAgICAgIF9hZGRFdmVudExpc3RlbmVyVG9Ob2RlKG5vZGUsIGV2ZW50TmFtZSwgaGFuZGxlcikge1xuICAgICAgICBpZiAoIWdlc3R1cmVzLmFkZExpc3RlbmVyKG5vZGUsIGV2ZW50TmFtZSwgaGFuZGxlcikpIHtcbiAgICAgICAgICBzdXBlci5fYWRkRXZlbnRMaXN0ZW5lclRvTm9kZShub2RlLCBldmVudE5hbWUsIGhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIF9yZW1vdmVFdmVudExpc3RlbmVyRnJvbU5vZGUobm9kZSwgZXZlbnROYW1lLCBoYW5kbGVyKSB7XG4gICAgICAgIGlmICghZ2VzdHVyZXMucmVtb3ZlTGlzdGVuZXIobm9kZSwgZXZlbnROYW1lLCBoYW5kbGVyKSkge1xuICAgICAgICAgIHN1cGVyLl9yZW1vdmVFdmVudExpc3RlbmVyRnJvbU5vZGUobm9kZSwgZXZlbnROYW1lLCBoYW5kbGVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgfVxuXG4gICAgcmV0dXJuIEdlc3R1cmVFdmVudExpc3RlbmVycztcblxuICB9KTtcblxufSkoKTtcbjwvc2NyaXB0PlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi9taXhpbnMvZ2VzdHVyZS1ldmVudC1saXN0ZW5lcnMuaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCJib290Lmh0bWxcIj5cbjxzY3JpcHQ+XG4oZnVuY3Rpb24oKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIGZ1bmN0aW9uIG5ld1NwbGljZShpbmRleCwgcmVtb3ZlZCwgYWRkZWRDb3VudCkge1xuICAgIHJldHVybiB7XG4gICAgICBpbmRleDogaW5kZXgsXG4gICAgICByZW1vdmVkOiByZW1vdmVkLFxuICAgICAgYWRkZWRDb3VudDogYWRkZWRDb3VudFxuICAgIH07XG4gIH1cblxuICBjb25zdCBFRElUX0xFQVZFID0gMDtcbiAgY29uc3QgRURJVF9VUERBVEUgPSAxO1xuICBjb25zdCBFRElUX0FERCA9IDI7XG4gIGNvbnN0IEVESVRfREVMRVRFID0gMztcblxuICAvLyBOb3RlOiBUaGlzIGZ1bmN0aW9uIGlzICpiYXNlZCogb24gdGhlIGNvbXB1dGF0aW9uIG9mIHRoZSBMZXZlbnNodGVpblxuICAvLyBcImVkaXRcIiBkaXN0YW5jZS4gVGhlIG9uZSBjaGFuZ2UgaXMgdGhhdCBcInVwZGF0ZXNcIiBhcmUgdHJlYXRlZCBhcyB0d29cbiAgLy8gZWRpdHMgLSBub3Qgb25lLiBXaXRoIEFycmF5IHNwbGljZXMsIGFuIHVwZGF0ZSBpcyByZWFsbHkgYSBkZWxldGVcbiAgLy8gZm9sbG93ZWQgYnkgYW4gYWRkLiBCeSByZXRhaW5pbmcgdGhpcywgd2Ugb3B0aW1pemUgZm9yIFwia2VlcGluZ1wiIHRoZVxuICAvLyBtYXhpbXVtIGFycmF5IGl0ZW1zIGluIHRoZSBvcmlnaW5hbCBhcnJheS4gRm9yIGV4YW1wbGU6XG4gIC8vXG4gIC8vICAgJ3h4eHgxMjMnIC0+ICcxMjN5eXl5J1xuICAvL1xuICAvLyBXaXRoIDEtZWRpdCB1cGRhdGVzLCB0aGUgc2hvcnRlc3QgcGF0aCB3b3VsZCBiZSBqdXN0IHRvIHVwZGF0ZSBhbGwgc2V2ZW5cbiAgLy8gY2hhcmFjdGVycy4gV2l0aCAyLWVkaXQgdXBkYXRlcywgd2UgZGVsZXRlIDQsIGxlYXZlIDMsIGFuZCBhZGQgNC4gVGhpc1xuICAvLyBsZWF2ZXMgdGhlIHN1YnN0cmluZyAnMTIzJyBpbnRhY3QuXG4gIGZ1bmN0aW9uIGNhbGNFZGl0RGlzdGFuY2VzKGN1cnJlbnQsIGN1cnJlbnRTdGFydCwgY3VycmVudEVuZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9sZCwgb2xkU3RhcnQsIG9sZEVuZCkge1xuICAgIC8vIFwiRGVsZXRpb25cIiBjb2x1bW5zXG4gICAgbGV0IHJvd0NvdW50ID0gb2xkRW5kIC0gb2xkU3RhcnQgKyAxO1xuICAgIGxldCBjb2x1bW5Db3VudCA9IGN1cnJlbnRFbmQgLSBjdXJyZW50U3RhcnQgKyAxO1xuICAgIGxldCBkaXN0YW5jZXMgPSBuZXcgQXJyYXkocm93Q291bnQpO1xuXG4gICAgLy8gXCJBZGRpdGlvblwiIHJvd3MuIEluaXRpYWxpemUgbnVsbCBjb2x1bW4uXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3dDb3VudDsgaSsrKSB7XG4gICAgICBkaXN0YW5jZXNbaV0gPSBuZXcgQXJyYXkoY29sdW1uQ291bnQpO1xuICAgICAgZGlzdGFuY2VzW2ldWzBdID0gaTtcbiAgICB9XG5cbiAgICAvLyBJbml0aWFsaXplIG51bGwgcm93XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBjb2x1bW5Db3VudDsgaisrKVxuICAgICAgZGlzdGFuY2VzWzBdW2pdID0gajtcblxuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgcm93Q291bnQ7IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IDE7IGogPCBjb2x1bW5Db3VudDsgaisrKSB7XG4gICAgICAgIGlmIChlcXVhbHMoY3VycmVudFtjdXJyZW50U3RhcnQgKyBqIC0gMV0sIG9sZFtvbGRTdGFydCArIGkgLSAxXSkpXG4gICAgICAgICAgZGlzdGFuY2VzW2ldW2pdID0gZGlzdGFuY2VzW2kgLSAxXVtqIC0gMV07XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGxldCBub3J0aCA9IGRpc3RhbmNlc1tpIC0gMV1bal0gKyAxO1xuICAgICAgICAgIGxldCB3ZXN0ID0gZGlzdGFuY2VzW2ldW2ogLSAxXSArIDE7XG4gICAgICAgICAgZGlzdGFuY2VzW2ldW2pdID0gbm9ydGggPCB3ZXN0ID8gbm9ydGggOiB3ZXN0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGRpc3RhbmNlcztcbiAgfVxuXG4gIC8vIFRoaXMgc3RhcnRzIGF0IHRoZSBmaW5hbCB3ZWlnaHQsIGFuZCB3YWxrcyBcImJhY2t3YXJkXCIgYnkgZmluZGluZ1xuICAvLyB0aGUgbWluaW11bSBwcmV2aW91cyB3ZWlnaHQgcmVjdXJzaXZlbHkgdW50aWwgdGhlIG9yaWdpbiBvZiB0aGUgd2VpZ2h0XG4gIC8vIG1hdHJpeC5cbiAgZnVuY3Rpb24gc3BsaWNlT3BlcmF0aW9uc0Zyb21FZGl0RGlzdGFuY2VzKGRpc3RhbmNlcykge1xuICAgIGxldCBpID0gZGlzdGFuY2VzLmxlbmd0aCAtIDE7XG4gICAgbGV0IGogPSBkaXN0YW5jZXNbMF0ubGVuZ3RoIC0gMTtcbiAgICBsZXQgY3VycmVudCA9IGRpc3RhbmNlc1tpXVtqXTtcbiAgICBsZXQgZWRpdHMgPSBbXTtcbiAgICB3aGlsZSAoaSA+IDAgfHwgaiA+IDApIHtcbiAgICAgIGlmIChpID09IDApIHtcbiAgICAgICAgZWRpdHMucHVzaChFRElUX0FERCk7XG4gICAgICAgIGotLTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoaiA9PSAwKSB7XG4gICAgICAgIGVkaXRzLnB1c2goRURJVF9ERUxFVEUpO1xuICAgICAgICBpLS07XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgbGV0IG5vcnRoV2VzdCA9IGRpc3RhbmNlc1tpIC0gMV1baiAtIDFdO1xuICAgICAgbGV0IHdlc3QgPSBkaXN0YW5jZXNbaSAtIDFdW2pdO1xuICAgICAgbGV0IG5vcnRoID0gZGlzdGFuY2VzW2ldW2ogLSAxXTtcblxuICAgICAgbGV0IG1pbjtcbiAgICAgIGlmICh3ZXN0IDwgbm9ydGgpXG4gICAgICAgIG1pbiA9IHdlc3QgPCBub3J0aFdlc3QgPyB3ZXN0IDogbm9ydGhXZXN0O1xuICAgICAgZWxzZVxuICAgICAgICBtaW4gPSBub3J0aCA8IG5vcnRoV2VzdCA/IG5vcnRoIDogbm9ydGhXZXN0O1xuXG4gICAgICBpZiAobWluID09IG5vcnRoV2VzdCkge1xuICAgICAgICBpZiAobm9ydGhXZXN0ID09IGN1cnJlbnQpIHtcbiAgICAgICAgICBlZGl0cy5wdXNoKEVESVRfTEVBVkUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVkaXRzLnB1c2goRURJVF9VUERBVEUpO1xuICAgICAgICAgIGN1cnJlbnQgPSBub3J0aFdlc3Q7XG4gICAgICAgIH1cbiAgICAgICAgaS0tO1xuICAgICAgICBqLS07XG4gICAgICB9IGVsc2UgaWYgKG1pbiA9PSB3ZXN0KSB7XG4gICAgICAgIGVkaXRzLnB1c2goRURJVF9ERUxFVEUpO1xuICAgICAgICBpLS07XG4gICAgICAgIGN1cnJlbnQgPSB3ZXN0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWRpdHMucHVzaChFRElUX0FERCk7XG4gICAgICAgIGotLTtcbiAgICAgICAgY3VycmVudCA9IG5vcnRoO1xuICAgICAgfVxuICAgIH1cblxuICAgIGVkaXRzLnJldmVyc2UoKTtcbiAgICByZXR1cm4gZWRpdHM7XG4gIH1cblxuICAvKipcbiAgICogU3BsaWNlIFByb2plY3Rpb24gZnVuY3Rpb25zOlxuICAgKlxuICAgKiBBIHNwbGljZSBtYXAgaXMgYSByZXByZXNlbnRhdGlvbiBvZiBob3cgYSBwcmV2aW91cyBhcnJheSBvZiBpdGVtc1xuICAgKiB3YXMgdHJhbnNmb3JtZWQgaW50byBhIG5ldyBhcnJheSBvZiBpdGVtcy4gQ29uY2VwdHVhbGx5IGl0IGlzIGEgbGlzdCBvZlxuICAgKiB0dXBsZXMgb2ZcbiAgICpcbiAgICogICA8aW5kZXgsIHJlbW92ZWQsIGFkZGVkQ291bnQ+XG4gICAqXG4gICAqIHdoaWNoIGFyZSBrZXB0IGluIGFzY2VuZGluZyBpbmRleCBvcmRlciBvZi4gVGhlIHR1cGxlIHJlcHJlc2VudHMgdGhhdCBhdFxuICAgKiB0aGUgfGluZGV4fCwgfHJlbW92ZWR8IHNlcXVlbmNlIG9mIGl0ZW1zIHdlcmUgcmVtb3ZlZCwgYW5kIGNvdW50aW5nIGZvcndhcmRcbiAgICogZnJvbSB8aW5kZXh8LCB8YWRkZWRDb3VudHwgaXRlbXMgd2VyZSBhZGRlZC5cbiAgICovXG5cbiAgLyoqXG4gICAqIExhY2tpbmcgaW5kaXZpZHVhbCBzcGxpY2UgbXV0YXRpb24gaW5mb3JtYXRpb24sIHRoZSBtaW5pbWFsIHNldCBvZlxuICAgKiBzcGxpY2VzIGNhbiBiZSBzeW50aGVzaXplZCBnaXZlbiB0aGUgcHJldmlvdXMgc3RhdGUgYW5kIGZpbmFsIHN0YXRlIG9mIGFuXG4gICAqIGFycmF5LiBUaGUgYmFzaWMgYXBwcm9hY2ggaXMgdG8gY2FsY3VsYXRlIHRoZSBlZGl0IGRpc3RhbmNlIG1hdHJpeCBhbmRcbiAgICogY2hvb3NlIHRoZSBzaG9ydGVzdCBwYXRoIHRocm91Z2ggaXQuXG4gICAqXG4gICAqIENvbXBsZXhpdHk6IE8obCAqIHApXG4gICAqICAgbDogVGhlIGxlbmd0aCBvZiB0aGUgY3VycmVudCBhcnJheVxuICAgKiAgIHA6IFRoZSBsZW5ndGggb2YgdGhlIG9sZCBhcnJheVxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBjdXJyZW50IFRoZSBjdXJyZW50IFwiY2hhbmdlZFwiIGFycmF5IGZvciB3aGljaCB0b1xuICAgKiBjYWxjdWxhdGUgc3BsaWNlcy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGN1cnJlbnRTdGFydCBTdGFydGluZyBpbmRleCBpbiB0aGUgYGN1cnJlbnRgIGFycmF5IGZvclxuICAgKiB3aGljaCBzcGxpY2VzIGFyZSBjYWxjdWxhdGVkLlxuICAgKiBAcGFyYW0ge251bWJlcn0gY3VycmVudEVuZCBFbmRpbmcgaW5kZXggaW4gdGhlIGBjdXJyZW50YCBhcnJheSBmb3JcbiAgICogd2hpY2ggc3BsaWNlcyBhcmUgY2FsY3VsYXRlZC5cbiAgICogQHBhcmFtIHtBcnJheX0gb2xkIFRoZSBvcmlnaW5hbCBcInVuY2hhbmdlZFwiIGFycmF5IHRvIGNvbXBhcmUgYGN1cnJlbnRgXG4gICAqIGFnYWluc3QgdG8gZGV0ZXJtaW5lIHNwbGljZXMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvbGRTdGFydCBTdGFydGluZyBpbmRleCBpbiB0aGUgYG9sZGAgYXJyYXkgZm9yXG4gICAqIHdoaWNoIHNwbGljZXMgYXJlIGNhbGN1bGF0ZWQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvbGRFbmQgRW5kaW5nIGluZGV4IGluIHRoZSBgb2xkYCBhcnJheSBmb3JcbiAgICogd2hpY2ggc3BsaWNlcyBhcmUgY2FsY3VsYXRlZC5cbiAgICogQHJldHVybiB7QXJyYXl9IFJldHVybnMgYW4gYXJyYXkgb2Ygc3BsaWNlIHJlY29yZCBvYmplY3RzLiBFYWNoIG9mIHRoZXNlXG4gICAqIGNvbnRhaW5zOiBgaW5kZXhgIHRoZSBsb2NhdGlvbiB3aGVyZSB0aGUgc3BsaWNlIG9jY3VycmVkOyBgcmVtb3ZlZGBcbiAgICogdGhlIGFycmF5IG9mIHJlbW92ZWQgaXRlbXMgZnJvbSB0aGlzIGxvY2F0aW9uOyBgYWRkZWRDb3VudGAgdGhlIG51bWJlclxuICAgKiBvZiBpdGVtcyBhZGRlZCBhdCB0aGlzIGxvY2F0aW9uLlxuICAgKi9cbiAgZnVuY3Rpb24gY2FsY1NwbGljZXMoY3VycmVudCwgY3VycmVudFN0YXJ0LCBjdXJyZW50RW5kLFxuICAgICAgICAgICAgICAgICAgICAgICAgb2xkLCBvbGRTdGFydCwgb2xkRW5kKSB7XG4gICAgbGV0IHByZWZpeENvdW50ID0gMDtcbiAgICBsZXQgc3VmZml4Q291bnQgPSAwO1xuICAgIGxldCBzcGxpY2U7XG5cbiAgICBsZXQgbWluTGVuZ3RoID0gTWF0aC5taW4oY3VycmVudEVuZCAtIGN1cnJlbnRTdGFydCwgb2xkRW5kIC0gb2xkU3RhcnQpO1xuICAgIGlmIChjdXJyZW50U3RhcnQgPT0gMCAmJiBvbGRTdGFydCA9PSAwKVxuICAgICAgcHJlZml4Q291bnQgPSBzaGFyZWRQcmVmaXgoY3VycmVudCwgb2xkLCBtaW5MZW5ndGgpO1xuXG4gICAgaWYgKGN1cnJlbnRFbmQgPT0gY3VycmVudC5sZW5ndGggJiYgb2xkRW5kID09IG9sZC5sZW5ndGgpXG4gICAgICBzdWZmaXhDb3VudCA9IHNoYXJlZFN1ZmZpeChjdXJyZW50LCBvbGQsIG1pbkxlbmd0aCAtIHByZWZpeENvdW50KTtcblxuICAgIGN1cnJlbnRTdGFydCArPSBwcmVmaXhDb3VudDtcbiAgICBvbGRTdGFydCArPSBwcmVmaXhDb3VudDtcbiAgICBjdXJyZW50RW5kIC09IHN1ZmZpeENvdW50O1xuICAgIG9sZEVuZCAtPSBzdWZmaXhDb3VudDtcblxuICAgIGlmIChjdXJyZW50RW5kIC0gY3VycmVudFN0YXJ0ID09IDAgJiYgb2xkRW5kIC0gb2xkU3RhcnQgPT0gMClcbiAgICAgIHJldHVybiBbXTtcblxuICAgIGlmIChjdXJyZW50U3RhcnQgPT0gY3VycmVudEVuZCkge1xuICAgICAgc3BsaWNlID0gbmV3U3BsaWNlKGN1cnJlbnRTdGFydCwgW10sIDApO1xuICAgICAgd2hpbGUgKG9sZFN0YXJ0IDwgb2xkRW5kKVxuICAgICAgICBzcGxpY2UucmVtb3ZlZC5wdXNoKG9sZFtvbGRTdGFydCsrXSk7XG5cbiAgICAgIHJldHVybiBbIHNwbGljZSBdO1xuICAgIH0gZWxzZSBpZiAob2xkU3RhcnQgPT0gb2xkRW5kKVxuICAgICAgcmV0dXJuIFsgbmV3U3BsaWNlKGN1cnJlbnRTdGFydCwgW10sIGN1cnJlbnRFbmQgLSBjdXJyZW50U3RhcnQpIF07XG5cbiAgICBsZXQgb3BzID0gc3BsaWNlT3BlcmF0aW9uc0Zyb21FZGl0RGlzdGFuY2VzKFxuICAgICAgICBjYWxjRWRpdERpc3RhbmNlcyhjdXJyZW50LCBjdXJyZW50U3RhcnQsIGN1cnJlbnRFbmQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2xkLCBvbGRTdGFydCwgb2xkRW5kKSk7XG5cbiAgICBzcGxpY2UgPSB1bmRlZmluZWQ7XG4gICAgbGV0IHNwbGljZXMgPSBbXTtcbiAgICBsZXQgaW5kZXggPSBjdXJyZW50U3RhcnQ7XG4gICAgbGV0IG9sZEluZGV4ID0gb2xkU3RhcnQ7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHN3aXRjaChvcHNbaV0pIHtcbiAgICAgICAgY2FzZSBFRElUX0xFQVZFOlxuICAgICAgICAgIGlmIChzcGxpY2UpIHtcbiAgICAgICAgICAgIHNwbGljZXMucHVzaChzcGxpY2UpO1xuICAgICAgICAgICAgc3BsaWNlID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgICAgb2xkSW5kZXgrKztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBFRElUX1VQREFURTpcbiAgICAgICAgICBpZiAoIXNwbGljZSlcbiAgICAgICAgICAgIHNwbGljZSA9IG5ld1NwbGljZShpbmRleCwgW10sIDApO1xuXG4gICAgICAgICAgc3BsaWNlLmFkZGVkQ291bnQrKztcbiAgICAgICAgICBpbmRleCsrO1xuXG4gICAgICAgICAgc3BsaWNlLnJlbW92ZWQucHVzaChvbGRbb2xkSW5kZXhdKTtcbiAgICAgICAgICBvbGRJbmRleCsrO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEVESVRfQUREOlxuICAgICAgICAgIGlmICghc3BsaWNlKVxuICAgICAgICAgICAgc3BsaWNlID0gbmV3U3BsaWNlKGluZGV4LCBbXSwgMCk7XG5cbiAgICAgICAgICBzcGxpY2UuYWRkZWRDb3VudCsrO1xuICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgRURJVF9ERUxFVEU6XG4gICAgICAgICAgaWYgKCFzcGxpY2UpXG4gICAgICAgICAgICBzcGxpY2UgPSBuZXdTcGxpY2UoaW5kZXgsIFtdLCAwKTtcblxuICAgICAgICAgIHNwbGljZS5yZW1vdmVkLnB1c2gob2xkW29sZEluZGV4XSk7XG4gICAgICAgICAgb2xkSW5kZXgrKztcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc3BsaWNlKSB7XG4gICAgICBzcGxpY2VzLnB1c2goc3BsaWNlKTtcbiAgICB9XG4gICAgcmV0dXJuIHNwbGljZXM7XG4gIH1cblxuICBmdW5jdGlvbiBzaGFyZWRQcmVmaXgoY3VycmVudCwgb2xkLCBzZWFyY2hMZW5ndGgpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlYXJjaExlbmd0aDsgaSsrKVxuICAgICAgaWYgKCFlcXVhbHMoY3VycmVudFtpXSwgb2xkW2ldKSlcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgcmV0dXJuIHNlYXJjaExlbmd0aDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNoYXJlZFN1ZmZpeChjdXJyZW50LCBvbGQsIHNlYXJjaExlbmd0aCkge1xuICAgIGxldCBpbmRleDEgPSBjdXJyZW50Lmxlbmd0aDtcbiAgICBsZXQgaW5kZXgyID0gb2xkLmxlbmd0aDtcbiAgICBsZXQgY291bnQgPSAwO1xuICAgIHdoaWxlIChjb3VudCA8IHNlYXJjaExlbmd0aCAmJiBlcXVhbHMoY3VycmVudFstLWluZGV4MV0sIG9sZFstLWluZGV4Ml0pKVxuICAgICAgY291bnQrKztcblxuICAgIHJldHVybiBjb3VudDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbGN1bGF0ZVNwbGljZXMoY3VycmVudCwgcHJldmlvdXMpIHtcbiAgICByZXR1cm4gY2FsY1NwbGljZXMoY3VycmVudCwgMCwgY3VycmVudC5sZW5ndGgsIHByZXZpb3VzLCAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZpb3VzLmxlbmd0aCk7XG4gIH1cblxuICBmdW5jdGlvbiBlcXVhbHMoY3VycmVudFZhbHVlLCBwcmV2aW91c1ZhbHVlKSB7XG4gICAgcmV0dXJuIGN1cnJlbnRWYWx1ZSA9PT0gcHJldmlvdXNWYWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbmFtZXNwYWNlXG4gICAqIEBtZW1iZXJvZiBQb2x5bWVyXG4gICAqIEBzdW1tYXJ5IE1vZHVsZSB0aGF0IHByb3ZpZGVzIHV0aWxpdGllcyBmb3IgZGlmZmluZyBhcnJheXMuXG4gICAqL1xuICBQb2x5bWVyLkFycmF5U3BsaWNlID0ge1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gYXJyYXkgb2Ygc3BsaWNlIHJlY29yZHMgaW5kaWNhdGluZyB0aGUgbWluaW11bSBlZGl0cyByZXF1aXJlZFxuICAgICAqIHRvIHRyYW5zZm9ybSB0aGUgYHByZXZpb3VzYCBhcnJheSBpbnRvIHRoZSBgY3VycmVudGAgYXJyYXkuXG4gICAgICpcbiAgICAgKiBTcGxpY2UgcmVjb3JkcyBhcmUgb3JkZXJlZCBieSBpbmRleCBhbmQgY29udGFpbiB0aGUgZm9sbG93aW5nIGZpZWxkczpcbiAgICAgKiAtIGBpbmRleGA6IGluZGV4IHdoZXJlIGVkaXQgc3RhcnRlZFxuICAgICAqIC0gYHJlbW92ZWRgOiBhcnJheSBvZiByZW1vdmVkIGl0ZW1zIGZyb20gdGhpcyBpbmRleFxuICAgICAqIC0gYGFkZGVkQ291bnRgOiBudW1iZXIgb2YgaXRlbXMgYWRkZWQgYXQgdGhpcyBpbmRleFxuICAgICAqXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBiYXNlZCBvbiB0aGUgTGV2ZW5zaHRlaW4gXCJtaW5pbXVtIGVkaXQgZGlzdGFuY2VcIlxuICAgICAqIGFsZ29yaXRobS4gTm90ZSB0aGF0IHVwZGF0ZXMgYXJlIHRyZWF0ZWQgYXMgcmVtb3ZhbCBmb2xsb3dlZCBieSBhZGRpdGlvbi5cbiAgICAgKlxuICAgICAqIFRoZSB3b3JzdC1jYXNlIHRpbWUgY29tcGxleGl0eSBvZiB0aGlzIGFsZ29yaXRobSBpcyBgTyhsICogcClgXG4gICAgICogICBsOiBUaGUgbGVuZ3RoIG9mIHRoZSBjdXJyZW50IGFycmF5XG4gICAgICogICBwOiBUaGUgbGVuZ3RoIG9mIHRoZSBwcmV2aW91cyBhcnJheVxuICAgICAqXG4gICAgICogSG93ZXZlciwgdGhlIHdvcnN0LWNhc2UgY29tcGxleGl0eSBpcyByZWR1Y2VkIGJ5IGFuIGBPKG4pYCBvcHRpbWl6YXRpb25cbiAgICAgKiB0byBkZXRlY3QgYW55IHNoYXJlZCBwcmVmaXggJiBzdWZmaXggYmV0d2VlbiB0aGUgdHdvIGFycmF5cyBhbmQgb25seVxuICAgICAqIHBlcmZvcm0gdGhlIG1vcmUgZXhwZW5zaXZlIG1pbmltdW0gZWRpdCBkaXN0YW5jZSBjYWxjdWxhdGlvbiBvdmVyIHRoZVxuICAgICAqIG5vbi1zaGFyZWQgcG9ydGlvbnMgb2YgdGhlIGFycmF5cy5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBQb2x5bWVyLkFycmF5U3BsaWNlXG4gICAgICogQHBhcmFtIHtBcnJheX0gY3VycmVudCBUaGUgXCJjaGFuZ2VkXCIgYXJyYXkgZm9yIHdoaWNoIHNwbGljZXMgd2lsbCBiZVxuICAgICAqIGNhbGN1bGF0ZWQuXG4gICAgICogQHBhcmFtIHtBcnJheX0gcHJldmlvdXMgVGhlIFwidW5jaGFuZ2VkXCIgb3JpZ2luYWwgYXJyYXkgdG8gY29tcGFyZVxuICAgICAqIGBjdXJyZW50YCBhZ2FpbnN0IHRvIGRldGVybWluZSB0aGUgc3BsaWNlcy5cbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gUmV0dXJucyBhbiBhcnJheSBvZiBzcGxpY2UgcmVjb3JkIG9iamVjdHMuIEVhY2ggb2YgdGhlc2VcbiAgICAgKiBjb250YWluczogYGluZGV4YCB0aGUgbG9jYXRpb24gd2hlcmUgdGhlIHNwbGljZSBvY2N1cnJlZDsgYHJlbW92ZWRgXG4gICAgICogdGhlIGFycmF5IG9mIHJlbW92ZWQgaXRlbXMgZnJvbSB0aGlzIGxvY2F0aW9uOyBgYWRkZWRDb3VudGAgdGhlIG51bWJlclxuICAgICAqIG9mIGl0ZW1zIGFkZGVkIGF0IHRoaXMgbG9jYXRpb24uXG4gICAgICovXG4gICAgY2FsY3VsYXRlU3BsaWNlc1xuICB9XG5cbn0pKCk7XG48L3NjcmlwdD5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL3BvbHltZXIvbGliL3V0aWxzL2FycmF5LXNwbGljZS5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNiBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuXG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vYXBwLXNjcm9sbC1lZmZlY3RzLWJlaGF2aW9yLmh0bWxcIj5cblxuPHNjcmlwdD5cbiAgLyoqXG4gICAqIFdoaWxlIHNjcm9sbGluZyBkb3duLCBmYWRlIGluIHRoZSByZWFyIGJhY2tncm91bmQgbGF5ZXIgYW5kIGZhZGUgb3V0IHRoZSBmcm9udCBiYWNrZ3JvdW5kXG4gICAqIGxheWVyIChvcGFjaXR5IGludGVycG9sYXRlZCBiYXNlZCBvbiBzY3JvbGwgcG9zaXRpb24pLlxuICAgKi9cbiAgUG9seW1lci5BcHBMYXlvdXQucmVnaXN0ZXJFZmZlY3QoJ2JsZW5kLWJhY2tncm91bmQnLCB7XG4gICAgLyoqIEB0aGlzIFBvbHltZXIuQXBwTGF5b3V0LkVsZW1lbnRXaXRoQmFja2dyb3VuZCAqL1xuICAgIHNldFVwOiBmdW5jdGlvbiBzZXRVcCgpIHtcbiAgICAgIHZhciBmeCA9IHt9O1xuICAgICAgZnguYmFja2dyb3VuZEZyb250TGF5ZXIgPSB0aGlzLl9nZXRET01SZWYoJ2JhY2tncm91bmRGcm9udExheWVyJyk7XG4gICAgICBmeC5iYWNrZ3JvdW5kUmVhckxheWVyID0gdGhpcy5fZ2V0RE9NUmVmKCdiYWNrZ3JvdW5kUmVhckxheWVyJyk7XG4gICAgICBmeC5iYWNrZ3JvdW5kRnJvbnRMYXllci5zdHlsZS53aWxsQ2hhbmdlID0gJ29wYWNpdHknO1xuICAgICAgZnguYmFja2dyb3VuZEZyb250TGF5ZXIuc3R5bGUudHJhbnNmb3JtID0gJ3RyYW5zbGF0ZVooMCknO1xuICAgICAgZnguYmFja2dyb3VuZFJlYXJMYXllci5zdHlsZS53aWxsQ2hhbmdlID0gJ29wYWNpdHknO1xuICAgICAgZnguYmFja2dyb3VuZFJlYXJMYXllci5zdHlsZS50cmFuc2Zvcm0gPSAndHJhbnNsYXRlWigwKSc7XG4gICAgICBmeC5iYWNrZ3JvdW5kUmVhckxheWVyLnN0eWxlLm9wYWNpdHkgPSAwO1xuICAgICAgdGhpcy5fZnhCbGVuZEJhY2tncm91bmQgPSBmeDtcbiAgICB9LFxuICAgIC8qKiBAdGhpcyBQb2x5bWVyLkFwcExheW91dC5FbGVtZW50V2l0aEJhY2tncm91bmQgKi9cbiAgICBydW46IGZ1bmN0aW9uIHJ1bihwLCB5KSB7XG4gICAgICB2YXIgZnggPSB0aGlzLl9meEJsZW5kQmFja2dyb3VuZDtcbiAgICAgIGZ4LmJhY2tncm91bmRGcm9udExheWVyLnN0eWxlLm9wYWNpdHkgPSAxIC0gcDtcbiAgICAgIGZ4LmJhY2tncm91bmRSZWFyTGF5ZXIuc3R5bGUub3BhY2l0eSA9IHA7XG4gICAgfSxcbiAgICAvKiogQHRoaXMgUG9seW1lci5BcHBMYXlvdXQuRWxlbWVudFdpdGhCYWNrZ3JvdW5kICovXG4gICAgdGVhckRvd246IGZ1bmN0aW9uIHRlYXJEb3duKCkge1xuICAgICAgZGVsZXRlIHRoaXMuX2Z4QmxlbmRCYWNrZ3JvdW5kO1xuICAgIH1cbiAgfSk7XG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvYXBwLWxheW91dC9hcHAtc2Nyb2xsLWVmZmVjdHMvZWZmZWN0cy9ibGVuZC1iYWNrZ3JvdW5kLmh0bWwiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi9hcHAtc2Nyb2xsLWVmZmVjdHMtYmVoYXZpb3IuaHRtbFwiPlxuXG48c2NyaXB0PlxuICAvKipcbiAgICogVG9nZ2xlcyB0aGUgc2hhZG93IHByb3BlcnR5IGluIGFwcC1oZWFkZXIgd2hlbiBjb250ZW50IGlzIHNjcm9sbGVkIHRvIGNyZWF0ZSBhIHNlbnNlIG9mIGRlcHRoXG4gICAqIGJldHdlZW4gdGhlIGVsZW1lbnQgYW5kIHRoZSBjb250ZW50IHVuZGVybmVhdGguXG4gICAqL1xuICBQb2x5bWVyLkFwcExheW91dC5yZWdpc3RlckVmZmVjdCgnd2F0ZXJmYWxsJywge1xuICAgIC8qKlxuICAgICAqICBAdGhpcyBQb2x5bWVyLkFwcExheW91dC5FbGVtZW50V2l0aEJhY2tncm91bmRcbiAgICAgKi9cbiAgICBydW46IGZ1bmN0aW9uIHJ1bigpIHtcbiAgICAgIHRoaXMuc2hhZG93ID0gdGhpcy5pc09uU2NyZWVuKCkgJiYgdGhpcy5pc0NvbnRlbnRCZWxvdygpO1xuICAgIH1cbiAgfSk7XG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvYXBwLWxheW91dC9hcHAtc2Nyb2xsLWVmZmVjdHMvZWZmZWN0cy93YXRlcmZhbGwuaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTYgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cblxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL2FwcC1zY3JvbGwtZWZmZWN0cy1iZWhhdmlvci5odG1sXCI+XG5cbjxzY3JpcHQ+XG4gIChmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBpbnRlcnBvbGF0ZShwcm9ncmVzcywgcG9pbnRzLCBmbiwgY3R4KSB7XG4gICAgICBmbi5hcHBseShjdHgsIHBvaW50cy5tYXAoZnVuY3Rpb24ocG9pbnQpIHtcbiAgICAgICAgcmV0dXJuIHBvaW50WzBdICsgKHBvaW50WzFdIC0gcG9pbnRbMF0pICogcHJvZ3Jlc3M7XG4gICAgICB9KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtIHRoZSBmb250IHNpemUgb2YgYSBkZXNpZ25hdGVkIHRpdGxlIGVsZW1lbnQgYmV0d2VlbiB0d28gdmFsdWVzIGJhc2VkIG9uIHRoZSBzY3JvbGxcbiAgICAgKiBwb3NpdGlvbi5cbiAgICAgKi9cbiAgICBQb2x5bWVyLkFwcExheW91dC5yZWdpc3RlckVmZmVjdCgncmVzaXplLXRpdGxlJywge1xuICAgICAgLyoqIEB0aGlzIFBvbHltZXIuQXBwTGF5b3V0LkVsZW1lbnRXaXRoQmFja2dyb3VuZCAqL1xuICAgICAgc2V0VXA6IGZ1bmN0aW9uIHNldFVwKCkge1xuICAgICAgICB2YXIgdGl0bGUgPSB0aGlzLl9nZXRET01SZWYoJ21haW5UaXRsZScpO1xuICAgICAgICB2YXIgY29uZGVuc2VkVGl0bGUgPSB0aGlzLl9nZXRET01SZWYoJ2NvbmRlbnNlZFRpdGxlJyk7XG5cbiAgICAgICAgaWYgKCFjb25kZW5zZWRUaXRsZSkge1xuICAgICAgICAgIGNvbnNvbGUud2FybignU2Nyb2xsIGVmZmVjdCBgcmVzaXplLXRpdGxlYDogdW5kZWZpbmVkIGBjb25kZW5zZWQtdGl0bGVgJyk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGl0bGUpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ1Njcm9sbCBlZmZlY3QgYHJlc2l6ZS10aXRsZWA6IHVuZGVmaW5lZCBgbWFpbi10aXRsZWAnKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBjb25kZW5zZWRUaXRsZS5zdHlsZS53aWxsQ2hhbmdlID0gJ29wYWNpdHknO1xuICAgICAgICBjb25kZW5zZWRUaXRsZS5zdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSAndHJhbnNsYXRlWigwKSc7XG4gICAgICAgIGNvbmRlbnNlZFRpdGxlLnN0eWxlLnRyYW5zZm9ybSA9ICd0cmFuc2xhdGVaKDApJztcbiAgICAgICAgY29uZGVuc2VkVGl0bGUuc3R5bGUud2Via2l0VHJhbnNmb3JtT3JpZ2luID0gJ2xlZnQgdG9wJztcbiAgICAgICAgY29uZGVuc2VkVGl0bGUuc3R5bGUudHJhbnNmb3JtT3JpZ2luID0gJ2xlZnQgdG9wJztcblxuICAgICAgICB0aXRsZS5zdHlsZS53aWxsQ2hhbmdlID0gJ29wYWNpdHknO1xuICAgICAgICB0aXRsZS5zdHlsZS53ZWJraXRUcmFuc2Zvcm1PcmlnaW4gPSAnbGVmdCB0b3AnO1xuICAgICAgICB0aXRsZS5zdHlsZS50cmFuc2Zvcm1PcmlnaW4gPSAnbGVmdCB0b3AnO1xuICAgICAgICB0aXRsZS5zdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSAndHJhbnNsYXRlWigwKSc7XG4gICAgICAgIHRpdGxlLnN0eWxlLnRyYW5zZm9ybSA9ICd0cmFuc2xhdGVaKDApJztcblxuICAgICAgICB2YXIgdGl0bGVDbGllbnRSZWN0ID0gdGl0bGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHZhciBjb25kZW5zZWRUaXRsZUNsaWVudFJlY3QgPSBjb25kZW5zZWRUaXRsZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgdmFyIGZ4ID0ge307XG5cbiAgICAgICAgZnguc2NhbGUgPSBwYXJzZUludCh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShjb25kZW5zZWRUaXRsZSlbJ2ZvbnQtc2l6ZSddLCAxMCkgL1xuICAgICAgICAgICAgcGFyc2VJbnQod2luZG93LmdldENvbXB1dGVkU3R5bGUodGl0bGUpWydmb250LXNpemUnXSwgMTApO1xuICAgICAgICBmeC50aXRsZURYID0gdGl0bGVDbGllbnRSZWN0LmxlZnQgLSBjb25kZW5zZWRUaXRsZUNsaWVudFJlY3QubGVmdDtcbiAgICAgICAgZngudGl0bGVEWSA9IHRpdGxlQ2xpZW50UmVjdC50b3AgLSBjb25kZW5zZWRUaXRsZUNsaWVudFJlY3QudG9wO1xuICAgICAgICBmeC5jb25kZW5zZWRUaXRsZSA9IGNvbmRlbnNlZFRpdGxlO1xuICAgICAgICBmeC50aXRsZSA9IHRpdGxlO1xuXG4gICAgICAgIHRoaXMuX2Z4UmVzaXplVGl0bGUgPSBmeDtcbiAgICAgIH0sXG4gICAgICAvKiogQHRoaXMgUG9seW1lckVsZW1lbnQgKi9cbiAgICAgIHJ1bjogZnVuY3Rpb24gcnVuKHAsIHkpIHtcbiAgICAgICAgdmFyIGZ4ID0gdGhpcy5fZnhSZXNpemVUaXRsZTtcbiAgICAgICAgaWYgKCF0aGlzLmNvbmRlbnNlcykge1xuICAgICAgICAgIHkgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwID49IDEpIHtcbiAgICAgICAgICBmeC50aXRsZS5zdHlsZS5vcGFjaXR5ID0gMDtcbiAgICAgICAgICBmeC5jb25kZW5zZWRUaXRsZS5zdHlsZS5vcGFjaXR5ID0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmeC50aXRsZS5zdHlsZS5vcGFjaXR5ID0gMTtcbiAgICAgICAgICBmeC5jb25kZW5zZWRUaXRsZS5zdHlsZS5vcGFjaXR5ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpbnRlcnBvbGF0ZShNYXRoLm1pbigxLCBwKSwgWyBbMSwgZnguc2NhbGVdLCBbMCwgLWZ4LnRpdGxlRFhdLCBbeSwgeS1meC50aXRsZURZXSBdLFxuICAgICAgICAgIGZ1bmN0aW9uKHNjYWxlLCB0cmFuc2xhdGVYLCB0cmFuc2xhdGVZKSB7XG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybSgndHJhbnNsYXRlKCcgKyB0cmFuc2xhdGVYICsgJ3B4LCAnICsgdHJhbnNsYXRlWSArICdweCkgJyArXG4gICAgICAgICAgICAgICAgJ3NjYWxlM2QoJyArIHNjYWxlICsgJywgJyArIHNjYWxlICsgJywgMSknLCBmeC50aXRsZSk7XG4gICAgICAgICAgfSwgdGhpcyk7XG4gICAgICB9LFxuICAgICAgLyoqIEB0aGlzIFBvbHltZXIuQXBwTGF5b3V0LkVsZW1lbnRXaXRoQmFja2dyb3VuZCAqL1xuICAgICAgdGVhckRvd246IGZ1bmN0aW9uIHRlYXJEb3duKCkge1xuICAgICAgICBkZWxldGUgdGhpcy5fZnhSZXNpemVUaXRsZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSkoKTtcbjwvc2NyaXB0PlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9hcHAtbGF5b3V0L2FwcC1zY3JvbGwtZWZmZWN0cy9lZmZlY3RzL3Jlc2l6ZS10aXRsZS5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNiBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuXG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vYXBwLXNjcm9sbC1lZmZlY3RzLWJlaGF2aW9yLmh0bWxcIj5cblxuPHNjcmlwdD5cbiAgLyoqXG4gICAqIFZlcnRpY2FsbHkgdHJhbnNsYXRlIHRoZSBiYWNrZ3JvdW5kIGJhc2VkIG9uIGEgZmFjdG9yIG9mIHRoZSBzY3JvbGwgcG9zaXRpb24uXG4gICAqL1xuICBQb2x5bWVyLkFwcExheW91dC5yZWdpc3RlckVmZmVjdCgncGFyYWxsYXgtYmFja2dyb3VuZCcsIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3tzY2FsYXI6IHN0cmluZ319IGNvbmZpZ1xuICAgICAqIEB0aGlzIFBvbHltZXIuQXBwTGF5b3V0LkVsZW1lbnRXaXRoQmFja2dyb3VuZFxuICAgICAqL1xuICAgIHNldFVwOiBmdW5jdGlvbiBzZXRVcChjb25maWcpIHtcbiAgICAgIHZhciBmeCA9IHt9O1xuICAgICAgdmFyIHNjYWxhciA9IHBhcnNlRmxvYXQoY29uZmlnLnNjYWxhcik7XG4gICAgICBmeC5iYWNrZ3JvdW5kID0gdGhpcy5fZ2V0RE9NUmVmKCdiYWNrZ3JvdW5kJyk7XG4gICAgICBmeC5iYWNrZ3JvdW5kRnJvbnRMYXllciA9IHRoaXMuX2dldERPTVJlZignYmFja2dyb3VuZEZyb250TGF5ZXInKTtcbiAgICAgIGZ4LmJhY2tncm91bmRSZWFyTGF5ZXIgPSB0aGlzLl9nZXRET01SZWYoJ2JhY2tncm91bmRSZWFyTGF5ZXInKTtcbiAgICAgIGZ4LmRlbHRhQmcgPSBmeC5iYWNrZ3JvdW5kRnJvbnRMYXllci5vZmZzZXRIZWlnaHQgLSBmeC5iYWNrZ3JvdW5kLm9mZnNldEhlaWdodDtcbiAgICAgIGlmIChmeC5kZWx0YUJnID09PSAwKSB7XG4gICAgICAgIGlmIChpc05hTihzY2FsYXIpKSB7XG4gICAgICAgICAgc2NhbGFyID0gMC44O1xuICAgICAgICB9XG4gICAgICAgIGZ4LmRlbHRhQmcgPSB0aGlzLl9kSGVpZ2h0ICogc2NhbGFyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzTmFOKHNjYWxhcikpIHtcbiAgICAgICAgICBzY2FsYXIgPSAxO1xuICAgICAgICB9XG4gICAgICAgIGZ4LmRlbHRhQmcgPSBmeC5kZWx0YUJnICogc2NhbGFyO1xuICAgICAgfVxuICAgICAgdGhpcy5fZnhQYXJhbGxheEJhY2tncm91bmQgPSBmeDtcbiAgICB9LFxuICAgIC8qKiBAdGhpcyBQb2x5bWVyLkFwcExheW91dC5FbGVtZW50V2l0aEJhY2tncm91bmQgKi9cbiAgICBydW46IGZ1bmN0aW9uIHJ1bihwLCB5KSB7XG4gICAgICB2YXIgZnggPSB0aGlzLl9meFBhcmFsbGF4QmFja2dyb3VuZDtcbiAgICAgIHRoaXMudHJhbnNmb3JtKCd0cmFuc2xhdGUzZCgwcHgsICcgKyAoZnguZGVsdGFCZyAqIE1hdGgubWluKDEsIHApKSArICdweCwgMHB4KScsIGZ4LmJhY2tncm91bmRGcm9udExheWVyKTtcbiAgICAgIGlmIChmeC5iYWNrZ3JvdW5kUmVhckxheWVyKSB7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtKCd0cmFuc2xhdGUzZCgwcHgsICcgKyAoZnguZGVsdGFCZyAqIE1hdGgubWluKDEsIHApKSArICdweCwgMHB4KScsIGZ4LmJhY2tncm91bmRSZWFyTGF5ZXIpO1xuICAgICAgfVxuICAgIH0sXG4gICAgLyoqIEB0aGlzIFBvbHltZXIuQXBwTGF5b3V0LkVsZW1lbnRXaXRoQmFja2dyb3VuZCAqL1xuICAgIHRlYXJEb3duOiBmdW5jdGlvbiB0ZWFyRG93bigpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLl9meFBhcmFsbGF4QmFja2dyb3VuZDtcbiAgICB9XG4gIH0pO1xuPC9zY3JpcHQ+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL2FwcC1sYXlvdXQvYXBwLXNjcm9sbC1lZmZlY3RzL2VmZmVjdHMvcGFyYWxsYXgtYmFja2dyb3VuZC5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNSBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuXG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vcG9seW1lci9wb2x5bWVyLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCJpcm9uLXNlbGVjdGlvbi5odG1sXCI+XG5cbjxzY3JpcHQ+XG4gIC8qKlxuICAgKiBAcG9seW1lckJlaGF2aW9yIFBvbHltZXIuSXJvblNlbGVjdGFibGVCZWhhdmlvclxuICAgKi9cbiAgUG9seW1lci5Jcm9uU2VsZWN0YWJsZUJlaGF2aW9yID0ge1xuXG4gICAgICAvKipcbiAgICAgICAqIEZpcmVkIHdoZW4gaXJvbi1zZWxlY3RvciBpcyBhY3RpdmF0ZWQgKHNlbGVjdGVkIG9yIGRlc2VsZWN0ZWQpLlxuICAgICAgICogSXQgaXMgZmlyZWQgYmVmb3JlIHRoZSBzZWxlY3RlZCBpdGVtcyBhcmUgY2hhbmdlZC5cbiAgICAgICAqIENhbmNlbCB0aGUgZXZlbnQgdG8gYWJvcnQgc2VsZWN0aW9uLlxuICAgICAgICpcbiAgICAgICAqIEBldmVudCBpcm9uLWFjdGl2YXRlXG4gICAgICAgKi9cblxuICAgICAgLyoqXG4gICAgICAgKiBGaXJlZCB3aGVuIGFuIGl0ZW0gaXMgc2VsZWN0ZWRcbiAgICAgICAqXG4gICAgICAgKiBAZXZlbnQgaXJvbi1zZWxlY3RcbiAgICAgICAqL1xuXG4gICAgICAvKipcbiAgICAgICAqIEZpcmVkIHdoZW4gYW4gaXRlbSBpcyBkZXNlbGVjdGVkXG4gICAgICAgKlxuICAgICAgICogQGV2ZW50IGlyb24tZGVzZWxlY3RcbiAgICAgICAqL1xuXG4gICAgICAvKipcbiAgICAgICAqIEZpcmVkIHdoZW4gdGhlIGxpc3Qgb2Ygc2VsZWN0YWJsZSBpdGVtcyBjaGFuZ2VzIChlLmcuLCBpdGVtcyBhcmVcbiAgICAgICAqIGFkZGVkIG9yIHJlbW92ZWQpLiBUaGUgZGV0YWlsIG9mIHRoZSBldmVudCBpcyBhIG11dGF0aW9uIHJlY29yZCB0aGF0XG4gICAgICAgKiBkZXNjcmliZXMgd2hhdCBjaGFuZ2VkLlxuICAgICAgICpcbiAgICAgICAqIEBldmVudCBpcm9uLWl0ZW1zLWNoYW5nZWRcbiAgICAgICAqL1xuXG4gICAgcHJvcGVydGllczoge1xuXG4gICAgICAvKipcbiAgICAgICAqIElmIHlvdSB3YW50IHRvIHVzZSBhbiBhdHRyaWJ1dGUgdmFsdWUgb3IgcHJvcGVydHkgb2YgYW4gZWxlbWVudCBmb3JcbiAgICAgICAqIGBzZWxlY3RlZGAgaW5zdGVhZCBvZiB0aGUgaW5kZXgsIHNldCB0aGlzIHRvIHRoZSBuYW1lIG9mIHRoZSBhdHRyaWJ1dGVcbiAgICAgICAqIG9yIHByb3BlcnR5LiBIeXBoZW5hdGVkIHZhbHVlcyBhcmUgY29udmVydGVkIHRvIGNhbWVsIGNhc2Ugd2hlbiB1c2VkIHRvXG4gICAgICAgKiBsb29rIHVwIHRoZSBwcm9wZXJ0eSBvZiBhIHNlbGVjdGFibGUgZWxlbWVudC4gQ2FtZWwgY2FzZWQgdmFsdWVzIGFyZVxuICAgICAgICogKm5vdCogY29udmVydGVkIHRvIGh5cGhlbmF0ZWQgdmFsdWVzIGZvciBhdHRyaWJ1dGUgbG9va3VwLiBJdCdzXG4gICAgICAgKiByZWNvbW1lbmRlZCB0aGF0IHlvdSBwcm92aWRlIHRoZSBoeXBoZW5hdGVkIGZvcm0gb2YgdGhlIG5hbWUgc28gdGhhdFxuICAgICAgICogc2VsZWN0aW9uIHdvcmtzIGluIGJvdGggY2FzZXMuIChVc2UgYGF0dHItb3ItcHJvcGVydHktbmFtZWAgaW5zdGVhZCBvZlxuICAgICAgICogYGF0dHJPclByb3BlcnR5TmFtZWAuKVxuICAgICAgICovXG4gICAgICBhdHRyRm9yU2VsZWN0ZWQ6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICB2YWx1ZTogbnVsbFxuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIHNlbGVjdGVkIGVsZW1lbnQuIFRoZSBkZWZhdWx0IGlzIHRvIHVzZSB0aGUgaW5kZXggb2YgdGhlIGl0ZW0uXG4gICAgICAgKiBAdHlwZSB7c3RyaW5nfG51bWJlcn1cbiAgICAgICAqL1xuICAgICAgc2VsZWN0ZWQ6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICBub3RpZnk6IHRydWVcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogUmV0dXJucyB0aGUgY3VycmVudGx5IHNlbGVjdGVkIGl0ZW0uXG4gICAgICAgKlxuICAgICAgICogQHR5cGUgez9PYmplY3R9XG4gICAgICAgKi9cbiAgICAgIHNlbGVjdGVkSXRlbToge1xuICAgICAgICB0eXBlOiBPYmplY3QsXG4gICAgICAgIHJlYWRPbmx5OiB0cnVlLFxuICAgICAgICBub3RpZnk6IHRydWVcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogVGhlIGV2ZW50IHRoYXQgZmlyZXMgZnJvbSBpdGVtcyB3aGVuIHRoZXkgYXJlIHNlbGVjdGVkLiBTZWxlY3RhYmxlXG4gICAgICAgKiB3aWxsIGxpc3RlbiBmb3IgdGhpcyBldmVudCBmcm9tIGl0ZW1zIGFuZCB1cGRhdGUgdGhlIHNlbGVjdGlvbiBzdGF0ZS5cbiAgICAgICAqIFNldCB0byBlbXB0eSBzdHJpbmcgdG8gbGlzdGVuIHRvIG5vIGV2ZW50cy5cbiAgICAgICAqL1xuICAgICAgYWN0aXZhdGVFdmVudDoge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIHZhbHVlOiAndGFwJyxcbiAgICAgICAgb2JzZXJ2ZXI6ICdfYWN0aXZhdGVFdmVudENoYW5nZWQnXG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFRoaXMgaXMgYSBDU1Mgc2VsZWN0b3Igc3RyaW5nLiAgSWYgdGhpcyBpcyBzZXQsIG9ubHkgaXRlbXMgdGhhdCBtYXRjaCB0aGUgQ1NTIHNlbGVjdG9yXG4gICAgICAgKiBhcmUgc2VsZWN0YWJsZS5cbiAgICAgICAqL1xuICAgICAgc2VsZWN0YWJsZTogU3RyaW5nLFxuXG4gICAgICAvKipcbiAgICAgICAqIFRoZSBjbGFzcyB0byBzZXQgb24gZWxlbWVudHMgd2hlbiBzZWxlY3RlZC5cbiAgICAgICAqL1xuICAgICAgc2VsZWN0ZWRDbGFzczoge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIHZhbHVlOiAnaXJvbi1zZWxlY3RlZCdcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogVGhlIGF0dHJpYnV0ZSB0byBzZXQgb24gZWxlbWVudHMgd2hlbiBzZWxlY3RlZC5cbiAgICAgICAqL1xuICAgICAgc2VsZWN0ZWRBdHRyaWJ1dGU6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICB2YWx1ZTogbnVsbFxuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBEZWZhdWx0IGZhbGxiYWNrIGlmIHRoZSBzZWxlY3Rpb24gYmFzZWQgb24gc2VsZWN0ZWQgd2l0aCBgYXR0ckZvclNlbGVjdGVkYFxuICAgICAgICogaXMgbm90IGZvdW5kLlxuICAgICAgICovXG4gICAgICBmYWxsYmFja1NlbGVjdGlvbjoge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIHZhbHVlOiBudWxsXG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFRoZSBsaXN0IG9mIGl0ZW1zIGZyb20gd2hpY2ggYSBzZWxlY3Rpb24gY2FuIGJlIG1hZGUuXG4gICAgICAgKi9cbiAgICAgIGl0ZW1zOiB7XG4gICAgICAgIHR5cGU6IEFycmF5LFxuICAgICAgICByZWFkT25seTogdHJ1ZSxcbiAgICAgICAgbm90aWZ5OiB0cnVlLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFRoZSBzZXQgb2YgZXhjbHVkZWQgZWxlbWVudHMgd2hlcmUgdGhlIGtleSBpcyB0aGUgYGxvY2FsTmFtZWBcbiAgICAgICAqIG9mIHRoZSBlbGVtZW50IHRoYXQgd2lsbCBiZSBpZ25vcmVkIGZyb20gdGhlIGl0ZW0gbGlzdC5cbiAgICAgICAqXG4gICAgICAgKiBAZGVmYXVsdCB7dGVtcGxhdGU6IDF9XG4gICAgICAgKi9cbiAgICAgIF9leGNsdWRlZExvY2FsTmFtZXM6IHtcbiAgICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICd0ZW1wbGF0ZSc6IDEsXG4gICAgICAgICAgICAnZG9tLWJpbmQnOiAxLFxuICAgICAgICAgICAgJ2RvbS1pZic6IDEsXG4gICAgICAgICAgICAnZG9tLXJlcGVhdCc6IDEsXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBvYnNlcnZlcnM6IFtcbiAgICAgICdfdXBkYXRlQXR0ckZvclNlbGVjdGVkKGF0dHJGb3JTZWxlY3RlZCknLFxuICAgICAgJ191cGRhdGVTZWxlY3RlZChzZWxlY3RlZCknLFxuICAgICAgJ19jaGVja0ZhbGxiYWNrKGZhbGxiYWNrU2VsZWN0aW9uKSdcbiAgICBdLFxuXG4gICAgY3JlYXRlZDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9iaW5kRmlsdGVySXRlbSA9IHRoaXMuX2ZpbHRlckl0ZW0uYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX3NlbGVjdGlvbiA9IG5ldyBQb2x5bWVyLklyb25TZWxlY3Rpb24odGhpcy5fYXBwbHlTZWxlY3Rpb24uYmluZCh0aGlzKSk7XG4gICAgfSxcblxuICAgIGF0dGFjaGVkOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX29ic2VydmVyID0gdGhpcy5fb2JzZXJ2ZUl0ZW1zKHRoaXMpO1xuICAgICAgdGhpcy5fYWRkTGlzdGVuZXIodGhpcy5hY3RpdmF0ZUV2ZW50KTtcbiAgICB9LFxuXG4gICAgZGV0YWNoZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuX29ic2VydmVyKSB7XG4gICAgICAgIFBvbHltZXIuZG9tKHRoaXMpLnVub2JzZXJ2ZU5vZGVzKHRoaXMuX29ic2VydmVyKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3JlbW92ZUxpc3RlbmVyKHRoaXMuYWN0aXZhdGVFdmVudCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBnaXZlbiBpdGVtLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBpbmRleE9mXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGl0ZW1cbiAgICAgKiBAcmV0dXJucyBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgaXRlbVxuICAgICAqL1xuICAgIGluZGV4T2Y6IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgIHJldHVybiB0aGlzLml0ZW1zLmluZGV4T2YoaXRlbSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNlbGVjdHMgdGhlIGdpdmVuIHZhbHVlLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBzZWxlY3RcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IHZhbHVlIHRoZSB2YWx1ZSB0byBzZWxlY3QuXG4gICAgICovXG4gICAgc2VsZWN0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgdGhpcy5zZWxlY3RlZCA9IHZhbHVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZWxlY3RzIHRoZSBwcmV2aW91cyBpdGVtLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBzZWxlY3RQcmV2aW91c1xuICAgICAqL1xuICAgIHNlbGVjdFByZXZpb3VzOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBsZW5ndGggPSB0aGlzLml0ZW1zLmxlbmd0aDtcbiAgICAgIHZhciBpbmRleCA9IChOdW1iZXIodGhpcy5fdmFsdWVUb0luZGV4KHRoaXMuc2VsZWN0ZWQpKSAtIDEgKyBsZW5ndGgpICUgbGVuZ3RoO1xuICAgICAgdGhpcy5zZWxlY3RlZCA9IHRoaXMuX2luZGV4VG9WYWx1ZShpbmRleCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNlbGVjdHMgdGhlIG5leHQgaXRlbS5cbiAgICAgKlxuICAgICAqIEBtZXRob2Qgc2VsZWN0TmV4dFxuICAgICAqL1xuICAgIHNlbGVjdE5leHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGluZGV4ID0gKE51bWJlcih0aGlzLl92YWx1ZVRvSW5kZXgodGhpcy5zZWxlY3RlZCkpICsgMSkgJSB0aGlzLml0ZW1zLmxlbmd0aDtcbiAgICAgIHRoaXMuc2VsZWN0ZWQgPSB0aGlzLl9pbmRleFRvVmFsdWUoaW5kZXgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZWxlY3RzIHRoZSBpdGVtIGF0IHRoZSBnaXZlbiBpbmRleC5cbiAgICAgKlxuICAgICAqIEBtZXRob2Qgc2VsZWN0SW5kZXhcbiAgICAgKi9cbiAgICBzZWxlY3RJbmRleDogZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgIHRoaXMuc2VsZWN0KHRoaXMuX2luZGV4VG9WYWx1ZShpbmRleCkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGb3JjZSBhIHN5bmNocm9ub3VzIHVwZGF0ZSBvZiB0aGUgYGl0ZW1zYCBwcm9wZXJ0eS5cbiAgICAgKlxuICAgICAqIE5PVEU6IENvbnNpZGVyIGxpc3RlbmluZyBmb3IgdGhlIGBpcm9uLWl0ZW1zLWNoYW5nZWRgIGV2ZW50IHRvIHJlc3BvbmQgdG9cbiAgICAgKiB1cGRhdGVzIHRvIHRoZSBzZXQgb2Ygc2VsZWN0YWJsZSBpdGVtcyBhZnRlciB1cGRhdGVzIHRvIHRoZSBET00gbGlzdCBhbmRcbiAgICAgKiBzZWxlY3Rpb24gc3RhdGUgaGF2ZSBiZWVuIG1hZGUuXG4gICAgICpcbiAgICAgKiBXQVJOSU5HOiBJZiB5b3UgYXJlIHVzaW5nIHRoaXMgbWV0aG9kLCB5b3Ugc2hvdWxkIHByb2JhYmx5IGNvbnNpZGVyIGFuXG4gICAgICogYWx0ZXJuYXRlIGFwcHJvYWNoLiBTeW5jaHJvbm91c2x5IHF1ZXJ5aW5nIGZvciBpdGVtcyBpcyBwb3RlbnRpYWxseVxuICAgICAqIHNsb3cgZm9yIG1hbnkgdXNlIGNhc2VzLiBUaGUgYGl0ZW1zYCBwcm9wZXJ0eSB3aWxsIHVwZGF0ZSBhc3luY2hyb25vdXNseVxuICAgICAqIG9uIGl0cyBvd24gdG8gcmVmbGVjdCBzZWxlY3RhYmxlIGl0ZW1zIGluIHRoZSBET00uXG4gICAgICovXG4gICAgZm9yY2VTeW5jaHJvbm91c0l0ZW1VcGRhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuX29ic2VydmVyICYmIHR5cGVvZiB0aGlzLl9vYnNlcnZlci5mbHVzaCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIC8vIE5PVEUoYmlja25lbGxyKTogYFBvbHltZXIuZG9tLmZsdXNoYCBhYm92ZSBpcyBubyBsb25nZXIgc3VmZmljaWVudCB0b1xuICAgICAgICAvLyB0cmlnZ2VyIGBvYnNlcnZlTm9kZXNgIGNhbGxiYWNrcy4gUG9seW1lciAyLnggcmV0dXJucyBhbiBvYmplY3QgZnJvbVxuICAgICAgICAvLyBgb2JzZXJ2ZU5vZGVzYCB3aXRoIGEgYGZsdXNoYCB0aGF0IHN5bmNocm9ub3VzbHkgZ2l2ZXMgdGhlIGNhbGxiYWNrXG4gICAgICAgIC8vIGFueSBwZW5kaW5nIE11dGF0aW9uUmVjb3JkcyAocmV0cmlldmVkIHdpdGggYHRha2VSZWNvcmRzYCkuIEFueSBjYXNlXG4gICAgICAgIC8vIHdoZXJlIFNoYWR5RE9NIGZsdXNoZXMgd2VyZSBleHBlY3RlZCB0byBzeW5jaHJvbm91c2x5IHRyaWdnZXIgaXRlbVxuICAgICAgICAvLyB1cGRhdGVzIHdpbGwgbm93IHJlcXVpcmUgY2FsbGluZyBgZm9yY2VTeW5jaHJvbm91c0l0ZW1VcGRhdGVgLlxuICAgICAgICB0aGlzLl9vYnNlcnZlci5mbHVzaCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlSXRlbXMoKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gVU5VU0VELCBGT1IgQVBJIENPTVBBVElCSUxJVFlcbiAgICBnZXQgX3Nob3VsZFVwZGF0ZVNlbGVjdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnNlbGVjdGVkICE9IG51bGw7XG4gICAgfSxcblxuICAgIF9jaGVja0ZhbGxiYWNrOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZVNlbGVjdGVkKCk7XG4gICAgfSxcblxuICAgIF9hZGRMaXN0ZW5lcjogZnVuY3Rpb24oZXZlbnROYW1lKSB7XG4gICAgICB0aGlzLmxpc3Rlbih0aGlzLCBldmVudE5hbWUsICdfYWN0aXZhdGVIYW5kbGVyJyk7XG4gICAgfSxcblxuICAgIF9yZW1vdmVMaXN0ZW5lcjogZnVuY3Rpb24oZXZlbnROYW1lKSB7XG4gICAgICB0aGlzLnVubGlzdGVuKHRoaXMsIGV2ZW50TmFtZSwgJ19hY3RpdmF0ZUhhbmRsZXInKTtcbiAgICB9LFxuXG4gICAgX2FjdGl2YXRlRXZlbnRDaGFuZ2VkOiBmdW5jdGlvbihldmVudE5hbWUsIG9sZCkge1xuICAgICAgdGhpcy5fcmVtb3ZlTGlzdGVuZXIob2xkKTtcbiAgICAgIHRoaXMuX2FkZExpc3RlbmVyKGV2ZW50TmFtZSk7XG4gICAgfSxcblxuICAgIF91cGRhdGVJdGVtczogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbm9kZXMgPSBQb2x5bWVyLmRvbSh0aGlzKS5xdWVyeURpc3RyaWJ1dGVkRWxlbWVudHModGhpcy5zZWxlY3RhYmxlIHx8ICcqJyk7XG4gICAgICBub2RlcyA9IEFycmF5LnByb3RvdHlwZS5maWx0ZXIuY2FsbChub2RlcywgdGhpcy5fYmluZEZpbHRlckl0ZW0pO1xuICAgICAgdGhpcy5fc2V0SXRlbXMobm9kZXMpO1xuICAgIH0sXG5cbiAgICBfdXBkYXRlQXR0ckZvclNlbGVjdGVkOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLnNlbGVjdGVkSXRlbSkge1xuICAgICAgICB0aGlzLnNlbGVjdGVkID0gdGhpcy5fdmFsdWVGb3JJdGVtKHRoaXMuc2VsZWN0ZWRJdGVtKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgX3VwZGF0ZVNlbGVjdGVkOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX3NlbGVjdFNlbGVjdGVkKHRoaXMuc2VsZWN0ZWQpO1xuICAgIH0sXG5cbiAgICBfc2VsZWN0U2VsZWN0ZWQ6IGZ1bmN0aW9uKHNlbGVjdGVkKSB7XG4gICAgICBpZiAoIXRoaXMuaXRlbXMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgaXRlbSA9IHRoaXMuX3ZhbHVlVG9JdGVtKHRoaXMuc2VsZWN0ZWQpO1xuICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgdGhpcy5fc2VsZWN0aW9uLnNlbGVjdChpdGVtKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3NlbGVjdGlvbi5jbGVhcigpO1xuICAgICAgfVxuICAgICAgLy8gQ2hlY2sgZm9yIGl0ZW1zLCBzaW5jZSB0aGlzIGFycmF5IGlzIHBvcHVsYXRlZCBvbmx5IHdoZW4gYXR0YWNoZWRcbiAgICAgIC8vIFNpbmNlIE51bWJlcigwKSBpcyBmYWxzeSwgZXhwbGljaXRseSBjaGVjayBmb3IgdW5kZWZpbmVkXG4gICAgICBpZiAodGhpcy5mYWxsYmFja1NlbGVjdGlvbiAmJiB0aGlzLml0ZW1zLmxlbmd0aCAmJiAodGhpcy5fc2VsZWN0aW9uLmdldCgpID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWQgPSB0aGlzLmZhbGxiYWNrU2VsZWN0aW9uO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBfZmlsdGVySXRlbTogZnVuY3Rpb24obm9kZSkge1xuICAgICAgcmV0dXJuICF0aGlzLl9leGNsdWRlZExvY2FsTmFtZXNbbm9kZS5sb2NhbE5hbWVdO1xuICAgIH0sXG5cbiAgICBfdmFsdWVUb0l0ZW06IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gKHZhbHVlID09IG51bGwpID8gbnVsbCA6IHRoaXMuaXRlbXNbdGhpcy5fdmFsdWVUb0luZGV4KHZhbHVlKV07XG4gICAgfSxcblxuICAgIF92YWx1ZVRvSW5kZXg6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICBpZiAodGhpcy5hdHRyRm9yU2VsZWN0ZWQpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGl0ZW07IGl0ZW0gPSB0aGlzLml0ZW1zW2ldOyBpKyspIHtcbiAgICAgICAgICBpZiAodGhpcy5fdmFsdWVGb3JJdGVtKGl0ZW0pID09IHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBOdW1iZXIodmFsdWUpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBfaW5kZXhUb1ZhbHVlOiBmdW5jdGlvbihpbmRleCkge1xuICAgICAgaWYgKHRoaXMuYXR0ckZvclNlbGVjdGVkKSB7XG4gICAgICAgIHZhciBpdGVtID0gdGhpcy5pdGVtc1tpbmRleF07XG4gICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlRm9ySXRlbShpdGVtKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBfdmFsdWVGb3JJdGVtOiBmdW5jdGlvbihpdGVtKSB7XG4gICAgICBpZiAoIWl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciBwcm9wVmFsdWUgPSBpdGVtW1BvbHltZXIuQ2FzZU1hcC5kYXNoVG9DYW1lbENhc2UodGhpcy5hdHRyRm9yU2VsZWN0ZWQpXTtcbiAgICAgIHJldHVybiBwcm9wVmFsdWUgIT0gdW5kZWZpbmVkID8gcHJvcFZhbHVlIDogaXRlbS5nZXRBdHRyaWJ1dGUodGhpcy5hdHRyRm9yU2VsZWN0ZWQpO1xuICAgIH0sXG5cbiAgICBfYXBwbHlTZWxlY3Rpb246IGZ1bmN0aW9uKGl0ZW0sIGlzU2VsZWN0ZWQpIHtcbiAgICAgIGlmICh0aGlzLnNlbGVjdGVkQ2xhc3MpIHtcbiAgICAgICAgdGhpcy50b2dnbGVDbGFzcyh0aGlzLnNlbGVjdGVkQ2xhc3MsIGlzU2VsZWN0ZWQsIGl0ZW0pO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuc2VsZWN0ZWRBdHRyaWJ1dGUpIHtcbiAgICAgICAgdGhpcy50b2dnbGVBdHRyaWJ1dGUodGhpcy5zZWxlY3RlZEF0dHJpYnV0ZSwgaXNTZWxlY3RlZCwgaXRlbSk7XG4gICAgICB9XG4gICAgICB0aGlzLl9zZWxlY3Rpb25DaGFuZ2UoKTtcbiAgICAgIHRoaXMuZmlyZSgnaXJvbi0nICsgKGlzU2VsZWN0ZWQgPyAnc2VsZWN0JyA6ICdkZXNlbGVjdCcpLCB7aXRlbTogaXRlbX0pO1xuICAgIH0sXG5cbiAgICBfc2VsZWN0aW9uQ2hhbmdlOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX3NldFNlbGVjdGVkSXRlbSh0aGlzLl9zZWxlY3Rpb24uZ2V0KCkpO1xuICAgIH0sXG5cbiAgICAvLyBvYnNlcnZlIGl0ZW1zIGNoYW5nZSB1bmRlciB0aGUgZ2l2ZW4gbm9kZS5cbiAgICBfb2JzZXJ2ZUl0ZW1zOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICByZXR1cm4gUG9seW1lci5kb20obm9kZSkub2JzZXJ2ZU5vZGVzKGZ1bmN0aW9uKG11dGF0aW9uKSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUl0ZW1zKCk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVNlbGVjdGVkKCk7XG5cbiAgICAgICAgLy8gTGV0IG90aGVyIGludGVyZXN0ZWQgcGFydGllcyBrbm93IGFib3V0IHRoZSBjaGFuZ2Ugc28gdGhhdFxuICAgICAgICAvLyB3ZSBkb24ndCBoYXZlIHRvIHJlY3JlYXRlIG11dGF0aW9uIG9ic2VydmVycyBldmVyeXdoZXJlLlxuICAgICAgICB0aGlzLmZpcmUoJ2lyb24taXRlbXMtY2hhbmdlZCcsIG11dGF0aW9uLCB7XG4gICAgICAgICAgYnViYmxlczogZmFsc2UsXG4gICAgICAgICAgY2FuY2VsYWJsZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgX2FjdGl2YXRlSGFuZGxlcjogZnVuY3Rpb24oZSkge1xuICAgICAgdmFyIHQgPSBlLnRhcmdldDtcbiAgICAgIHZhciBpdGVtcyA9IHRoaXMuaXRlbXM7XG4gICAgICB3aGlsZSAodCAmJiB0ICE9IHRoaXMpIHtcbiAgICAgICAgdmFyIGkgPSBpdGVtcy5pbmRleE9mKHQpO1xuICAgICAgICBpZiAoaSA+PSAwKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5faW5kZXhUb1ZhbHVlKGkpO1xuICAgICAgICAgIHRoaXMuX2l0ZW1BY3RpdmF0ZSh2YWx1ZSwgdCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHQgPSB0LnBhcmVudE5vZGU7XG4gICAgICB9XG4gICAgfSxcblxuICAgIF9pdGVtQWN0aXZhdGU6IGZ1bmN0aW9uKHZhbHVlLCBpdGVtKSB7XG4gICAgICBpZiAoIXRoaXMuZmlyZSgnaXJvbi1hY3RpdmF0ZScsXG4gICAgICAgICAge3NlbGVjdGVkOiB2YWx1ZSwgaXRlbTogaXRlbX0sIHtjYW5jZWxhYmxlOiB0cnVlfSkuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICB0aGlzLnNlbGVjdCh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gIH07XG5cbjwvc2NyaXB0PlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9pcm9uLXNlbGVjdG9yL2lyb24tc2VsZWN0YWJsZS5odG1sIiwiXG5yZXF1aXJlKCcuLi9wb2x5bWVyL3BvbHltZXIuaHRtbCcpO1xuXG5yZXF1aXJlKCcuL2NvbG9yLmh0bWwnKTtcblxuY29uc3QgUmVnaXN0ZXJIdG1sVGVtcGxhdGUgPSByZXF1aXJlKCdwb2x5bWVyLXdlYnBhY2stbG9hZGVyL3JlZ2lzdGVyLWh0bWwtdGVtcGxhdGUnKTtcblxuUmVnaXN0ZXJIdG1sVGVtcGxhdGUudG9Cb2R5KFwiPGN1c3RvbS1zdHlsZT4gPHN0eWxlIGlzPWN1c3RvbS1zdHlsZT5odG1sey0tcHJpbWFyeS10ZXh0LWNvbG9yOnZhcigtLWxpZ2h0LXRoZW1lLXRleHQtY29sb3IpOy0tcHJpbWFyeS1iYWNrZ3JvdW5kLWNvbG9yOnZhcigtLWxpZ2h0LXRoZW1lLWJhY2tncm91bmQtY29sb3IpOy0tc2Vjb25kYXJ5LXRleHQtY29sb3I6dmFyKC0tbGlnaHQtdGhlbWUtc2Vjb25kYXJ5LWNvbG9yKTstLWRpc2FibGVkLXRleHQtY29sb3I6dmFyKC0tbGlnaHQtdGhlbWUtZGlzYWJsZWQtY29sb3IpOy0tZGl2aWRlci1jb2xvcjp2YXIoLS1saWdodC10aGVtZS1kaXZpZGVyLWNvbG9yKTstLWVycm9yLWNvbG9yOnZhcigtLXBhcGVyLWRlZXAtb3JhbmdlLWE3MDApOy0tcHJpbWFyeS1jb2xvcjp2YXIoLS1wYXBlci1pbmRpZ28tNTAwKTstLWxpZ2h0LXByaW1hcnktY29sb3I6dmFyKC0tcGFwZXItaW5kaWdvLTEwMCk7LS1kYXJrLXByaW1hcnktY29sb3I6dmFyKC0tcGFwZXItaW5kaWdvLTcwMCk7LS1hY2NlbnQtY29sb3I6dmFyKC0tcGFwZXItcGluay1hMjAwKTstLWxpZ2h0LWFjY2VudC1jb2xvcjp2YXIoLS1wYXBlci1waW5rLWExMDApOy0tZGFyay1hY2NlbnQtY29sb3I6dmFyKC0tcGFwZXItcGluay1hNDAwKTstLWxpZ2h0LXRoZW1lLWJhY2tncm91bmQtY29sb3I6I2ZmZmZmZjstLWxpZ2h0LXRoZW1lLWJhc2UtY29sb3I6IzAwMDAwMDstLWxpZ2h0LXRoZW1lLXRleHQtY29sb3I6dmFyKC0tcGFwZXItZ3JleS05MDApOy0tbGlnaHQtdGhlbWUtc2Vjb25kYXJ5LWNvbG9yOiM3MzczNzM7LS1saWdodC10aGVtZS1kaXNhYmxlZC1jb2xvcjojOWI5YjliOy0tbGlnaHQtdGhlbWUtZGl2aWRlci1jb2xvcjojZGJkYmRiOy0tZGFyay10aGVtZS1iYWNrZ3JvdW5kLWNvbG9yOnZhcigtLXBhcGVyLWdyZXktOTAwKTstLWRhcmstdGhlbWUtYmFzZS1jb2xvcjojZmZmZmZmOy0tZGFyay10aGVtZS10ZXh0LWNvbG9yOiNmZmZmZmY7LS1kYXJrLXRoZW1lLXNlY29uZGFyeS1jb2xvcjojYmNiY2JjOy0tZGFyay10aGVtZS1kaXNhYmxlZC1jb2xvcjojNjQ2NDY0Oy0tZGFyay10aGVtZS1kaXZpZGVyLWNvbG9yOiMzYzNjM2M7LS10ZXh0LXByaW1hcnktY29sb3I6dmFyKC0tZGFyay10aGVtZS10ZXh0LWNvbG9yKTstLWRlZmF1bHQtcHJpbWFyeS1jb2xvcjp2YXIoLS1wcmltYXJ5LWNvbG9yKX08L3N0eWxlPiA8L2N1c3RvbS1zdHlsZT5cIik7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL3BhcGVyLXN0eWxlcy9kZWZhdWx0LXRoZW1lLmh0bWwiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE1IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi9wb2x5bWVyL3BvbHltZXIuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL2lyb24taWNvbi9pcm9uLWljb24uaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3BhcGVyLWJlaGF2aW9ycy9wYXBlci1pbmt5LWZvY3VzLWJlaGF2aW9yLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi9wYXBlci1zdHlsZXMvZGVmYXVsdC10aGVtZS5odG1sXCI+XG5cbjwhLS1cbk1hdGVyaWFsIGRlc2lnbjogW0ljb24gdG9nZ2xlc10oaHR0cHM6Ly93d3cuZ29vZ2xlLmNvbS9kZXNpZ24vc3BlYy9jb21wb25lbnRzL2J1dHRvbnMuaHRtbCNidXR0b25zLXRvZ2dsZS1idXR0b25zKVxuXG5gcGFwZXItaWNvbi1idXR0b25gIGlzIGEgYnV0dG9uIHdpdGggYW4gaW1hZ2UgcGxhY2VkIGF0IHRoZSBjZW50ZXIuIFdoZW4gdGhlIHVzZXIgdG91Y2hlc1xudGhlIGJ1dHRvbiwgYSByaXBwbGUgZWZmZWN0IGVtYW5hdGVzIGZyb20gdGhlIGNlbnRlciBvZiB0aGUgYnV0dG9uLlxuXG5gcGFwZXItaWNvbi1idXR0b25gIGRvZXMgbm90IGluY2x1ZGUgYSBkZWZhdWx0IGljb24gc2V0LiBUbyB1c2UgaWNvbnMgZnJvbSB0aGUgZGVmYXVsdFxuc2V0LCBpbmNsdWRlIGBQb2x5bWVyRWxlbWVudHMvaXJvbi1pY29ucy9pcm9uLWljb25zLmh0bWxgLCBhbmQgdXNlIHRoZSBgaWNvbmAgYXR0cmlidXRlIHRvIHNwZWNpZnkgd2hpY2ggaWNvblxuZnJvbSB0aGUgaWNvbiBzZXQgdG8gdXNlLlxuXG4gICAgPHBhcGVyLWljb24tYnV0dG9uIGljb249XCJtZW51XCI+PC9wYXBlci1pY29uLWJ1dHRvbj5cblxuU2VlIFtgaXJvbi1pY29uc2V0YF0oaXJvbi1pY29uc2V0KSBmb3IgbW9yZSBpbmZvcm1hdGlvbiBhYm91dFxuaG93IHRvIHVzZSBhIGN1c3RvbSBpY29uIHNldC5cblxuRXhhbXBsZTpcblxuICAgIDxsaW5rIGhyZWY9XCJwYXRoL3RvL2lyb24taWNvbnMvaXJvbi1pY29ucy5odG1sXCIgcmVsPVwiaW1wb3J0XCI+XG5cbiAgICA8cGFwZXItaWNvbi1idXR0b24gaWNvbj1cImZhdm9yaXRlXCI+PC9wYXBlci1pY29uLWJ1dHRvbj5cbiAgICA8cGFwZXItaWNvbi1idXR0b24gc3JjPVwic3Rhci5wbmdcIj48L3BhcGVyLWljb24tYnV0dG9uPlxuXG5UbyB1c2UgYHBhcGVyLWljb24tYnV0dG9uYCBhcyBhIGxpbmssIHdyYXAgaXQgaW4gYW4gYW5jaG9yIHRhZy4gU2luY2UgYHBhcGVyLWljb24tYnV0dG9uYFxud2lsbCBhbHJlYWR5IHJlY2VpdmUgZm9jdXMsIHlvdSBtYXkgd2FudCB0byBwcmV2ZW50IHRoZSBhbmNob3IgdGFnIGZyb20gcmVjZWl2aW5nIGZvY3VzXG5hcyB3ZWxsIGJ5IHNldHRpbmcgaXRzIHRhYmluZGV4IHRvIC0xLlxuXG4gICAgPGEgaHJlZj1cImh0dHBzOi8vd3d3LnBvbHltZXItcHJvamVjdC5vcmdcIiB0YWJpbmRleD1cIi0xXCI+XG4gICAgICA8cGFwZXItaWNvbi1idXR0b24gaWNvbj1cInBvbHltZXJcIj48L3BhcGVyLWljb24tYnV0dG9uPlxuICAgIDwvYT5cblxuIyMjIFN0eWxpbmdcblxuU3R5bGUgdGhlIGJ1dHRvbiB3aXRoIENTUyBhcyB5b3Ugd291bGQgYSBub3JtYWwgRE9NIGVsZW1lbnQuIElmIHlvdSBhcmUgdXNpbmcgdGhlIGljb25zXG5wcm92aWRlZCBieSBgaXJvbi1pY29uc2AsIHRoZXkgd2lsbCBpbmhlcml0IHRoZSBmb3JlZ3JvdW5kIGNvbG9yIG9mIHRoZSBidXR0b24uXG5cbiAgICAvKiBtYWtlIGEgcmVkIFwiZmF2b3JpdGVcIiBidXR0b24gKi9cbiAgICA8cGFwZXItaWNvbi1idXR0b24gaWNvbj1cImZhdm9yaXRlXCIgc3R5bGU9XCJjb2xvcjogcmVkO1wiPjwvcGFwZXItaWNvbi1idXR0b24+XG5cbkJ5IGRlZmF1bHQsIHRoZSByaXBwbGUgaXMgdGhlIHNhbWUgY29sb3IgYXMgdGhlIGZvcmVncm91bmQgYXQgMjUlIG9wYWNpdHkuIFlvdSBtYXlcbmN1c3RvbWl6ZSB0aGUgY29sb3IgdXNpbmcgdGhlIGAtLXBhcGVyLWljb24tYnV0dG9uLWluay1jb2xvcmAgY3VzdG9tIHByb3BlcnR5LlxuXG5UaGUgZm9sbG93aW5nIGN1c3RvbSBwcm9wZXJ0aWVzIGFuZCBtaXhpbnMgYXJlIGF2YWlsYWJsZSBmb3Igc3R5bGluZzpcblxuQ3VzdG9tIHByb3BlcnR5IHwgRGVzY3JpcHRpb24gfCBEZWZhdWx0XG4tLS0tLS0tLS0tLS0tLS0tfC0tLS0tLS0tLS0tLS18LS0tLS0tLS0tLVxuYC0tcGFwZXItaWNvbi1idXR0b24tZGlzYWJsZWQtdGV4dGAgfCBUaGUgY29sb3Igb2YgdGhlIGRpc2FibGVkIGJ1dHRvbiB8IGAtLWRpc2FibGVkLXRleHQtY29sb3JgXG5gLS1wYXBlci1pY29uLWJ1dHRvbi1pbmstY29sb3JgIHwgU2VsZWN0ZWQvZm9jdXMgcmlwcGxlIGNvbG9yIHwgYC0tcHJpbWFyeS10ZXh0LWNvbG9yYFxuYC0tcGFwZXItaWNvbi1idXR0b25gIHwgTWl4aW4gZm9yIGEgYnV0dG9uIHwgYHt9YFxuYC0tcGFwZXItaWNvbi1idXR0b24tZGlzYWJsZWRgIHwgTWl4aW4gZm9yIGEgZGlzYWJsZWQgYnV0dG9uIHwgYHt9YFxuYC0tcGFwZXItaWNvbi1idXR0b24taG92ZXJgIHwgTWl4aW4gZm9yIGJ1dHRvbiBvbiBob3ZlciB8IGB7fWBcblxuQGdyb3VwIFBhcGVyIEVsZW1lbnRzXG5AZWxlbWVudCBwYXBlci1pY29uLWJ1dHRvblxuQGRlbW8gZGVtby9pbmRleC5odG1sXG4tLT5cblxuPGRvbS1tb2R1bGUgaWQ9XCJwYXBlci1pY29uLWJ1dHRvblwiPlxuICA8dGVtcGxhdGUgc3RyaXAtd2hpdGVzcGFjZT5cbiAgICA8c3R5bGU+XG4gICAgICA6aG9zdCB7XG4gICAgICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICBwYWRkaW5nOiA4cHg7XG4gICAgICAgIG91dGxpbmU6IG5vbmU7XG4gICAgICAgIC13ZWJraXQtdXNlci1zZWxlY3Q6IG5vbmU7XG4gICAgICAgIC1tb3otdXNlci1zZWxlY3Q6IG5vbmU7XG4gICAgICAgIC1tcy11c2VyLXNlbGVjdDogbm9uZTtcbiAgICAgICAgdXNlci1zZWxlY3Q6IG5vbmU7XG4gICAgICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICAgICAgei1pbmRleDogMDtcbiAgICAgICAgbGluZS1oZWlnaHQ6IDE7XG5cbiAgICAgICAgd2lkdGg6IDQwcHg7XG4gICAgICAgIGhlaWdodDogNDBweDtcblxuICAgICAgICAvKiBOT1RFOiBCb3RoIHZhbHVlcyBhcmUgbmVlZGVkLCBzaW5jZSBzb21lIHBob25lcyByZXF1aXJlIHRoZSB2YWx1ZSB0byBiZSBgdHJhbnNwYXJlbnRgLiAqL1xuICAgICAgICAtd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3I6IHJnYmEoMCwgMCwgMCwgMCk7XG4gICAgICAgIC13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvcjogdHJhbnNwYXJlbnQ7XG5cbiAgICAgICAgLyogQmVjYXVzZSBvZiBwb2x5bWVyLzI1NTgsIHRoaXMgc3R5bGUgaGFzIGxvd2VyIHNwZWNpZmljaXR5IHRoYW4gKiAqL1xuICAgICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94ICFpbXBvcnRhbnQ7XG5cbiAgICAgICAgQGFwcGx5IC0tcGFwZXItaWNvbi1idXR0b247XG4gICAgICB9XG5cbiAgICAgIDpob3N0ICNpbmsge1xuICAgICAgICBjb2xvcjogdmFyKC0tcGFwZXItaWNvbi1idXR0b24taW5rLWNvbG9yLCB2YXIoLS1wcmltYXJ5LXRleHQtY29sb3IpKTtcbiAgICAgICAgb3BhY2l0eTogMC42O1xuICAgICAgfVxuXG4gICAgICA6aG9zdChbZGlzYWJsZWRdKSB7XG4gICAgICAgIGNvbG9yOiB2YXIoLS1wYXBlci1pY29uLWJ1dHRvbi1kaXNhYmxlZC10ZXh0LCB2YXIoLS1kaXNhYmxlZC10ZXh0LWNvbG9yKSk7XG4gICAgICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xuICAgICAgICBjdXJzb3I6IGF1dG87XG5cbiAgICAgICAgQGFwcGx5IC0tcGFwZXItaWNvbi1idXR0b24tZGlzYWJsZWQ7XG4gICAgICB9XG5cbiAgICAgIDpob3N0KFtoaWRkZW5dKSB7XG4gICAgICAgIGRpc3BsYXk6IG5vbmUgIWltcG9ydGFudDtcbiAgICAgIH1cblxuICAgICAgOmhvc3QoOmhvdmVyKSB7XG4gICAgICAgIEBhcHBseSAtLXBhcGVyLWljb24tYnV0dG9uLWhvdmVyO1xuICAgICAgfVxuXG4gICAgICBpcm9uLWljb24ge1xuICAgICAgICAtLWlyb24taWNvbi13aWR0aDogMTAwJTtcbiAgICAgICAgLS1pcm9uLWljb24taGVpZ2h0OiAxMDAlO1xuICAgICAgfVxuICAgIDwvc3R5bGU+XG5cbiAgICA8aXJvbi1pY29uIGlkPVwiaWNvblwiIHNyYz1cIltbc3JjXV1cIiBpY29uPVwiW1tpY29uXV1cIiBhbHQkPVwiW1thbHRdXVwiPjwvaXJvbi1pY29uPlxuICA8L3RlbXBsYXRlPlxuXG4gIDxzY3JpcHQ+XG4gICAgUG9seW1lcih7XG4gICAgICBpczogJ3BhcGVyLWljb24tYnV0dG9uJyxcblxuICAgICAgaG9zdEF0dHJpYnV0ZXM6IHtcbiAgICAgICAgcm9sZTogJ2J1dHRvbicsXG4gICAgICAgIHRhYmluZGV4OiAnMCdcbiAgICAgIH0sXG5cbiAgICAgIGJlaGF2aW9yczogW1xuICAgICAgICBQb2x5bWVyLlBhcGVySW5reUZvY3VzQmVoYXZpb3JcbiAgICAgIF0sXG5cbiAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBVUkwgb2YgYW4gaW1hZ2UgZm9yIHRoZSBpY29uLiBJZiB0aGUgc3JjIHByb3BlcnR5IGlzIHNwZWNpZmllZCxcbiAgICAgICAgICogdGhlIGljb24gcHJvcGVydHkgc2hvdWxkIG5vdCBiZS5cbiAgICAgICAgICovXG4gICAgICAgIHNyYzoge1xuICAgICAgICAgIHR5cGU6IFN0cmluZ1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgdGhlIGljb24gbmFtZSBvciBpbmRleCBpbiB0aGUgc2V0IG9mIGljb25zIGF2YWlsYWJsZSBpblxuICAgICAgICAgKiB0aGUgaWNvbidzIGljb24gc2V0LiBJZiB0aGUgaWNvbiBwcm9wZXJ0eSBpcyBzcGVjaWZpZWQsXG4gICAgICAgICAqIHRoZSBzcmMgcHJvcGVydHkgc2hvdWxkIG5vdCBiZS5cbiAgICAgICAgICovXG4gICAgICAgIGljb246IHtcbiAgICAgICAgICB0eXBlOiBTdHJpbmdcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmaWVzIHRoZSBhbHRlcm5hdGUgdGV4dCBmb3IgdGhlIGJ1dHRvbiwgZm9yIGFjY2Vzc2liaWxpdHkuXG4gICAgICAgICAqL1xuICAgICAgICBhbHQ6IHtcbiAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgb2JzZXJ2ZXI6IFwiX2FsdENoYW5nZWRcIlxuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBfYWx0Q2hhbmdlZDogZnVuY3Rpb24obmV3VmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHZhciBsYWJlbCA9IHRoaXMuZ2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsJyk7XG5cbiAgICAgICAgLy8gRG9uJ3Qgc3RvbXAgb3ZlciBhIHVzZXItc2V0IGFyaWEtbGFiZWwuXG4gICAgICAgIGlmICghbGFiZWwgfHwgb2xkVmFsdWUgPT0gbGFiZWwpIHtcbiAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcsIG5ld1ZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICA8L3NjcmlwdD5cbjwvZG9tLW1vZHVsZT5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvcGFwZXItaWNvbi1idXR0b24vcGFwZXItaWNvbi1idXR0b24uaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTUgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cblxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3BvbHltZXIvcG9seW1lci5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vaXJvbi1tZXRhL2lyb24tbWV0YS5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vaXJvbi1mbGV4LWxheW91dC9pcm9uLWZsZXgtbGF5b3V0Lmh0bWxcIj5cblxuPCEtLVxuXG5UaGUgYGlyb24taWNvbmAgZWxlbWVudCBkaXNwbGF5cyBhbiBpY29uLiBCeSBkZWZhdWx0IGFuIGljb24gcmVuZGVycyBhcyBhIDI0cHggc3F1YXJlLlxuXG5FeGFtcGxlIHVzaW5nIHNyYzpcblxuICAgIDxpcm9uLWljb24gc3JjPVwic3Rhci5wbmdcIj48L2lyb24taWNvbj5cblxuRXhhbXBsZSBzZXR0aW5nIHNpemUgdG8gMzJweCB4IDMycHg6XG5cbiAgICA8aXJvbi1pY29uIGNsYXNzPVwiYmlnXCIgc3JjPVwiYmlnX3N0YXIucG5nXCI+PC9pcm9uLWljb24+XG5cbiAgICA8c3R5bGUgaXM9XCJjdXN0b20tc3R5bGVcIj5cbiAgICAgIC5iaWcge1xuICAgICAgICAtLWlyb24taWNvbi1oZWlnaHQ6IDMycHg7XG4gICAgICAgIC0taXJvbi1pY29uLXdpZHRoOiAzMnB4O1xuICAgICAgfVxuICAgIDwvc3R5bGU+XG5cblRoZSBpcm9uIGVsZW1lbnRzIGluY2x1ZGUgc2V2ZXJhbCBzZXRzIG9mIGljb25zLlxuVG8gdXNlIHRoZSBkZWZhdWx0IHNldCBvZiBpY29ucywgaW1wb3J0IGBpcm9uLWljb25zLmh0bWxgIGFuZCB1c2UgdGhlIGBpY29uYCBhdHRyaWJ1dGUgdG8gc3BlY2lmeSBhbiBpY29uOlxuXG4gICAgPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi9jb21wb25lbnRzL2lyb24taWNvbnMvaXJvbi1pY29ucy5odG1sXCI+XG5cbiAgICA8aXJvbi1pY29uIGljb249XCJtZW51XCI+PC9pcm9uLWljb24+XG5cblRvIHVzZSBhIGRpZmZlcmVudCBidWlsdC1pbiBzZXQgb2YgaWNvbnMsIGltcG9ydCB0aGUgc3BlY2lmaWMgYGlyb24taWNvbnMvPGljb25zZXQ+LWljb25zLmh0bWxgLCBhbmRcbnNwZWNpZnkgdGhlIGljb24gYXMgYDxpY29uc2V0Pjo8aWNvbj5gLiBGb3IgZXhhbXBsZSwgdG8gdXNlIGEgY29tbXVuaWNhdGlvbiBpY29uLCB5b3Ugd291bGRcbnVzZTpcblxuICAgIDxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIvY29tcG9uZW50cy9pcm9uLWljb25zL2NvbW11bmljYXRpb24taWNvbnMuaHRtbFwiPlxuXG4gICAgPGlyb24taWNvbiBpY29uPVwiY29tbXVuaWNhdGlvbjplbWFpbFwiPjwvaXJvbi1pY29uPlxuXG5Zb3UgY2FuIGFsc28gY3JlYXRlIGN1c3RvbSBpY29uIHNldHMgb2YgYml0bWFwIG9yIFNWRyBpY29ucy5cblxuRXhhbXBsZSBvZiB1c2luZyBhbiBpY29uIG5hbWVkIGBjaGVycnlgIGZyb20gYSBjdXN0b20gaWNvbnNldCB3aXRoIHRoZSBJRCBgZnJ1aXRgOlxuXG4gICAgPGlyb24taWNvbiBpY29uPVwiZnJ1aXQ6Y2hlcnJ5XCI+PC9pcm9uLWljb24+XG5cblNlZSBbaXJvbi1pY29uc2V0XShpcm9uLWljb25zZXQpIGFuZCBbaXJvbi1pY29uc2V0LXN2Z10oaXJvbi1pY29uc2V0LXN2ZykgZm9yIG1vcmUgaW5mb3JtYXRpb24gYWJvdXRcbmhvdyB0byBjcmVhdGUgYSBjdXN0b20gaWNvbnNldC5cblxuU2VlIHRoZSBbaXJvbi1pY29ucyBkZW1vXShpcm9uLWljb25zP3ZpZXc9ZGVtbzpkZW1vL2luZGV4Lmh0bWwpIHRvIHNlZSB0aGUgaWNvbnMgYXZhaWxhYmxlXG5pbiB0aGUgdmFyaW91cyBpY29uc2V0cy5cblxuVG8gbG9hZCBhIHN1YnNldCBvZiBpY29ucyBmcm9tIG9uZSBvZiB0aGUgZGVmYXVsdCBgaXJvbi1pY29uc2Agc2V0cywgeW91IGNhblxudXNlIHRoZSBbcG9seS1pY29uXShodHRwczovL3BvbHktaWNvbi5hcHBzcG90LmNvbS8pIHRvb2wuIEl0IGFsbG93cyB5b3VcbnRvIHNlbGVjdCBpbmRpdmlkdWFsIGljb25zLCBhbmQgY3JlYXRlcyBhbiBpY29uc2V0IGZyb20gdGhlbSB0aGF0IHlvdSBjYW5cbnVzZSBkaXJlY3RseSBpbiB5b3VyIGVsZW1lbnRzLlxuXG4jIyMgU3R5bGluZ1xuXG5UaGUgZm9sbG93aW5nIGN1c3RvbSBwcm9wZXJ0aWVzIGFyZSBhdmFpbGFibGUgZm9yIHN0eWxpbmc6XG5cbkN1c3RvbSBwcm9wZXJ0eSB8IERlc2NyaXB0aW9uIHwgRGVmYXVsdFxuLS0tLS0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tfC0tLS0tLS0tLS1cbmAtLWlyb24taWNvbmAgfCBNaXhpbiBhcHBsaWVkIHRvIHRoZSBpY29uIHwge31cbmAtLWlyb24taWNvbi13aWR0aGAgfCBXaWR0aCBvZiB0aGUgaWNvbiB8IGAyNHB4YFxuYC0taXJvbi1pY29uLWhlaWdodGAgfCBIZWlnaHQgb2YgdGhlIGljb24gfCBgMjRweGBcbmAtLWlyb24taWNvbi1maWxsLWNvbG9yYCB8IEZpbGwgY29sb3Igb2YgdGhlIHN2ZyBpY29uIHwgYGN1cnJlbnRjb2xvcmBcbmAtLWlyb24taWNvbi1zdHJva2UtY29sb3JgIHwgU3Ryb2tlIGNvbG9yIG9mIHRoZSBzdmcgaWNvbiB8IG5vbmVcblxuQGdyb3VwIElyb24gRWxlbWVudHNcbkBlbGVtZW50IGlyb24taWNvblxuQGRlbW8gZGVtby9pbmRleC5odG1sXG5AaGVybyBoZXJvLnN2Z1xuQGhvbWVwYWdlIHBvbHltZXIuZ2l0aHViLmlvXG4tLT5cblxuPGRvbS1tb2R1bGUgaWQ9XCJpcm9uLWljb25cIj5cbiAgPHRlbXBsYXRlPlxuICAgIDxzdHlsZT5cbiAgICAgIDpob3N0IHtcbiAgICAgICAgQGFwcGx5IC0tbGF5b3V0LWlubGluZTtcbiAgICAgICAgQGFwcGx5IC0tbGF5b3V0LWNlbnRlci1jZW50ZXI7XG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcblxuICAgICAgICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xuXG4gICAgICAgIGZpbGw6IHZhcigtLWlyb24taWNvbi1maWxsLWNvbG9yLCBjdXJyZW50Y29sb3IpO1xuICAgICAgICBzdHJva2U6IHZhcigtLWlyb24taWNvbi1zdHJva2UtY29sb3IsIG5vbmUpO1xuXG4gICAgICAgIHdpZHRoOiB2YXIoLS1pcm9uLWljb24td2lkdGgsIDI0cHgpO1xuICAgICAgICBoZWlnaHQ6IHZhcigtLWlyb24taWNvbi1oZWlnaHQsIDI0cHgpO1xuICAgICAgICBAYXBwbHkgLS1pcm9uLWljb247XG4gICAgICB9XG5cbiAgICAgIDpob3N0KFtoaWRkZW5dKSB7XG4gICAgICAgIGRpc3BsYXk6IG5vbmU7XG4gICAgICB9XG4gICAgPC9zdHlsZT5cbiAgPC90ZW1wbGF0ZT5cblxuICA8c2NyaXB0PlxuXG4gICAgUG9seW1lcih7XG5cbiAgICAgIGlzOiAnaXJvbi1pY29uJyxcblxuICAgICAgcHJvcGVydGllczoge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbmFtZSBvZiB0aGUgaWNvbiB0byB1c2UuIFRoZSBuYW1lIHNob3VsZCBiZSBvZiB0aGUgZm9ybTpcbiAgICAgICAgICogYGljb25zZXRfbmFtZTppY29uX25hbWVgLlxuICAgICAgICAgKi9cbiAgICAgICAgaWNvbjoge1xuICAgICAgICAgIHR5cGU6IFN0cmluZ1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbmFtZSBvZiB0aGUgdGhlbWUgdG8gdXNlZCwgaWYgb25lIGlzIHNwZWNpZmllZCBieSB0aGVcbiAgICAgICAgICogaWNvbnNldC5cbiAgICAgICAgICovXG4gICAgICAgIHRoZW1lOiB7XG4gICAgICAgICAgdHlwZTogU3RyaW5nXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHVzaW5nIGlyb24taWNvbiB3aXRob3V0IGFuIGljb25zZXQsIHlvdSBjYW4gc2V0IHRoZSBzcmMgdG8gYmVcbiAgICAgICAgICogdGhlIFVSTCBvZiBhbiBpbmRpdmlkdWFsIGljb24gaW1hZ2UgZmlsZS4gTm90ZSB0aGF0IHRoaXMgd2lsbCB0YWtlXG4gICAgICAgICAqIHByZWNlZGVuY2Ugb3ZlciBhIGdpdmVuIGljb24gYXR0cmlidXRlLlxuICAgICAgICAgKi9cbiAgICAgICAgc3JjOiB7XG4gICAgICAgICAgdHlwZTogU3RyaW5nXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHshUG9seW1lci5Jcm9uTWV0YX1cbiAgICAgICAgICovXG4gICAgICAgIF9tZXRhOiB7XG4gICAgICAgICAgdmFsdWU6IFBvbHltZXIuQmFzZS5jcmVhdGUoJ2lyb24tbWV0YScsIHt0eXBlOiAnaWNvbnNldCd9KVxuICAgICAgICB9XG5cbiAgICAgIH0sXG5cbiAgICAgIG9ic2VydmVyczogW1xuICAgICAgICAnX3VwZGF0ZUljb24oX21ldGEsIGlzQXR0YWNoZWQpJyxcbiAgICAgICAgJ191cGRhdGVJY29uKHRoZW1lLCBpc0F0dGFjaGVkKScsXG4gICAgICAgICdfc3JjQ2hhbmdlZChzcmMsIGlzQXR0YWNoZWQpJyxcbiAgICAgICAgJ19pY29uQ2hhbmdlZChpY29uLCBpc0F0dGFjaGVkKSdcbiAgICAgIF0sXG5cbiAgICAgIF9ERUZBVUxUX0lDT05TRVQ6ICdpY29ucycsXG5cbiAgICAgIF9pY29uQ2hhbmdlZDogZnVuY3Rpb24oaWNvbikge1xuICAgICAgICB2YXIgcGFydHMgPSAoaWNvbiB8fCAnJykuc3BsaXQoJzonKTtcbiAgICAgICAgdGhpcy5faWNvbk5hbWUgPSBwYXJ0cy5wb3AoKTtcbiAgICAgICAgdGhpcy5faWNvbnNldE5hbWUgPSBwYXJ0cy5wb3AoKSB8fCB0aGlzLl9ERUZBVUxUX0lDT05TRVQ7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUljb24oKTtcbiAgICAgIH0sXG5cbiAgICAgIF9zcmNDaGFuZ2VkOiBmdW5jdGlvbihzcmMpIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlSWNvbigpO1xuICAgICAgfSxcblxuICAgICAgX3VzZXNJY29uc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaWNvbiB8fCAhdGhpcy5zcmM7XG4gICAgICB9LFxuXG4gICAgICAvKiogQHN1cHByZXNzIHt2aXNpYmlsaXR5fSAqL1xuICAgICAgX3VwZGF0ZUljb246IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fdXNlc0ljb25zZXQoKSkge1xuICAgICAgICAgIGlmICh0aGlzLl9pbWcgJiYgdGhpcy5faW1nLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIFBvbHltZXIuZG9tKHRoaXMucm9vdCkucmVtb3ZlQ2hpbGQodGhpcy5faW1nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRoaXMuX2ljb25OYW1lID09PSBcIlwiKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5faWNvbnNldCkge1xuICAgICAgICAgICAgICB0aGlzLl9pY29uc2V0LnJlbW92ZUljb24odGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9pY29uc2V0TmFtZSAmJiB0aGlzLl9tZXRhKSB7XG4gICAgICAgICAgICB0aGlzLl9pY29uc2V0ID0gLyoqIEB0eXBlIHs/UG9seW1lci5JY29uc2V0fSAqLyAoXG4gICAgICAgICAgICAgIHRoaXMuX21ldGEuYnlLZXkodGhpcy5faWNvbnNldE5hbWUpKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9pY29uc2V0KSB7XG4gICAgICAgICAgICAgIHRoaXMuX2ljb25zZXQuYXBwbHlJY29uKHRoaXMsIHRoaXMuX2ljb25OYW1lLCB0aGlzLnRoZW1lKTtcbiAgICAgICAgICAgICAgdGhpcy51bmxpc3Rlbih3aW5kb3csICdpcm9uLWljb25zZXQtYWRkZWQnLCAnX3VwZGF0ZUljb24nKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMubGlzdGVuKHdpbmRvdywgJ2lyb24taWNvbnNldC1hZGRlZCcsICdfdXBkYXRlSWNvbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodGhpcy5faWNvbnNldCkge1xuICAgICAgICAgICAgdGhpcy5faWNvbnNldC5yZW1vdmVJY29uKHRoaXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXRoaXMuX2ltZykge1xuICAgICAgICAgICAgdGhpcy5faW1nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XG4gICAgICAgICAgICB0aGlzLl9pbWcuc3R5bGUud2lkdGggPSAnMTAwJSc7XG4gICAgICAgICAgICB0aGlzLl9pbWcuc3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xuICAgICAgICAgICAgdGhpcy5faW1nLmRyYWdnYWJsZSA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9pbWcuc3JjID0gdGhpcy5zcmM7XG4gICAgICAgICAgUG9seW1lci5kb20odGhpcy5yb290KS5hcHBlbmRDaGlsZCh0aGlzLl9pbWcpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICB9KTtcblxuICA8L3NjcmlwdD5cblxuPC9kb20tbW9kdWxlPlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9pcm9uLWljb24vaXJvbi1pY29uLmh0bWwiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE1IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi9wb2x5bWVyL3BvbHltZXIuaHRtbFwiPlxuXG48c2NyaXB0PlxuXG4gIC8qKlxuICAgKiBAZGVtbyBkZW1vL2luZGV4Lmh0bWxcbiAgICogQHBvbHltZXJCZWhhdmlvclxuICAgKi9cbiAgUG9seW1lci5Jcm9uQ29udHJvbFN0YXRlID0ge1xuXG4gICAgcHJvcGVydGllczoge1xuXG4gICAgICAvKipcbiAgICAgICAqIElmIHRydWUsIHRoZSBlbGVtZW50IGN1cnJlbnRseSBoYXMgZm9jdXMuXG4gICAgICAgKi9cbiAgICAgIGZvY3VzZWQ6IHtcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgdmFsdWU6IGZhbHNlLFxuICAgICAgICBub3RpZnk6IHRydWUsXG4gICAgICAgIHJlYWRPbmx5OiB0cnVlLFxuICAgICAgICByZWZsZWN0VG9BdHRyaWJ1dGU6IHRydWVcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogSWYgdHJ1ZSwgdGhlIHVzZXIgY2Fubm90IGludGVyYWN0IHdpdGggdGhpcyBlbGVtZW50LlxuICAgICAgICovXG4gICAgICBkaXNhYmxlZDoge1xuICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICB2YWx1ZTogZmFsc2UsXG4gICAgICAgIG5vdGlmeTogdHJ1ZSxcbiAgICAgICAgb2JzZXJ2ZXI6ICdfZGlzYWJsZWRDaGFuZ2VkJyxcbiAgICAgICAgcmVmbGVjdFRvQXR0cmlidXRlOiB0cnVlXG4gICAgICB9LFxuXG4gICAgICBfb2xkVGFiSW5kZXg6IHtcbiAgICAgICAgdHlwZTogTnVtYmVyXG4gICAgICB9LFxuXG4gICAgICBfYm91bmRGb2N1c0JsdXJIYW5kbGVyOiB7XG4gICAgICAgIHR5cGU6IEZ1bmN0aW9uLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2ZvY3VzQmx1ckhhbmRsZXIuYmluZCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgX19oYW5kbGVFdmVudFJldGFyZ2V0aW5nOiB7XG4gICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gIXRoaXMuc2hhZG93Um9vdCAmJiAhUG9seW1lci5FbGVtZW50O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIG9ic2VydmVyczogW1xuICAgICAgJ19jaGFuZ2VkQ29udHJvbFN0YXRlKGZvY3VzZWQsIGRpc2FibGVkKSdcbiAgICBdLFxuXG4gICAgcmVhZHk6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdmb2N1cycsIHRoaXMuX2JvdW5kRm9jdXNCbHVySGFuZGxlciwgdHJ1ZSk7XG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCB0aGlzLl9ib3VuZEZvY3VzQmx1ckhhbmRsZXIsIHRydWUpO1xuICAgIH0sXG5cbiAgICBfZm9jdXNCbHVySGFuZGxlcjogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIC8vIEluIFBvbHltZXIgMi4wLCB0aGUgbGlicmFyeSB0YWtlcyBjYXJlIG9mIHJldGFyZ2V0aW5nIGV2ZW50cy5cbiAgICAgIGlmIChQb2x5bWVyLkVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5fc2V0Rm9jdXNlZChldmVudC50eXBlID09PSAnZm9jdXMnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBOT1RFKGNkYXRhKTogIGlmIHdlIGFyZSBpbiBTaGFkb3dET00gbGFuZCwgYGV2ZW50LnRhcmdldGAgd2lsbFxuICAgICAgLy8gZXZlbnR1YWxseSBiZWNvbWUgYHRoaXNgIGR1ZSB0byByZXRhcmdldGluZzsgaWYgd2UgYXJlIG5vdCBpblxuICAgICAgLy8gU2hhZG93RE9NIGxhbmQsIGBldmVudC50YXJnZXRgIHdpbGwgZXZlbnR1YWxseSBiZWNvbWUgYHRoaXNgIGR1ZVxuICAgICAgLy8gdG8gdGhlIHNlY29uZCBjb25kaXRpb25hbCB3aGljaCBmaXJlcyBhIHN5bnRoZXRpYyBldmVudCAodGhhdCBpcyBhbHNvXG4gICAgICAvLyBoYW5kbGVkKS4gSW4gZWl0aGVyIGNhc2UsIHdlIGNhbiBkaXNyZWdhcmQgYGV2ZW50LnBhdGhgLlxuICAgICAgaWYgKGV2ZW50LnRhcmdldCA9PT0gdGhpcykge1xuICAgICAgICB0aGlzLl9zZXRGb2N1c2VkKGV2ZW50LnR5cGUgPT09ICdmb2N1cycpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl9faGFuZGxlRXZlbnRSZXRhcmdldGluZykge1xuICAgICAgICB2YXIgdGFyZ2V0ID0gLyoqIEB0eXBlIHtOb2RlfSAqLyhQb2x5bWVyLmRvbShldmVudCkubG9jYWxUYXJnZXQpO1xuICAgICAgICBpZiAoIXRoaXMuaXNMaWdodERlc2NlbmRhbnQodGFyZ2V0KSkge1xuICAgICAgICAgIHRoaXMuZmlyZShldmVudC50eXBlLCB7c291cmNlRXZlbnQ6IGV2ZW50fSwge1xuICAgICAgICAgICAgbm9kZTogdGhpcyxcbiAgICAgICAgICAgIGJ1YmJsZXM6IGV2ZW50LmJ1YmJsZXMsXG4gICAgICAgICAgICBjYW5jZWxhYmxlOiBldmVudC5jYW5jZWxhYmxlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgX2Rpc2FibGVkQ2hhbmdlZDogZnVuY3Rpb24oZGlzYWJsZWQsIG9sZCkge1xuICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2FyaWEtZGlzYWJsZWQnLCBkaXNhYmxlZCA/ICd0cnVlJyA6ICdmYWxzZScpO1xuICAgICAgdGhpcy5zdHlsZS5wb2ludGVyRXZlbnRzID0gZGlzYWJsZWQgPyAnbm9uZScgOiAnJztcbiAgICAgIGlmIChkaXNhYmxlZCkge1xuICAgICAgICB0aGlzLl9vbGRUYWJJbmRleCA9IHRoaXMudGFiSW5kZXg7XG4gICAgICAgIHRoaXMuX3NldEZvY3VzZWQoZmFsc2UpO1xuICAgICAgICB0aGlzLnRhYkluZGV4ID0gLTE7XG4gICAgICAgIHRoaXMuYmx1cigpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl9vbGRUYWJJbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMudGFiSW5kZXggPSB0aGlzLl9vbGRUYWJJbmRleDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgX2NoYW5nZWRDb250cm9sU3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gX2NvbnRyb2xTdGF0ZUNoYW5nZWQgaXMgYWJzdHJhY3QsIGZvbGxvdy1vbiBiZWhhdmlvcnMgbWF5IGltcGxlbWVudCBpdFxuICAgICAgaWYgKHRoaXMuX2NvbnRyb2xTdGF0ZUNoYW5nZWQpIHtcbiAgICAgICAgdGhpcy5fY29udHJvbFN0YXRlQ2hhbmdlZCgpO1xuICAgICAgfVxuICAgIH1cblxuICB9O1xuXG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvaXJvbi1iZWhhdmlvcnMvaXJvbi1jb250cm9sLXN0YXRlLmh0bWwiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE0IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi9wb2x5bWVyL3BvbHltZXIuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL2lyb24tYTExeS1rZXlzLWJlaGF2aW9yL2lyb24tYTExeS1rZXlzLWJlaGF2aW9yLmh0bWxcIj5cblxuPCEtLVxuTWF0ZXJpYWwgZGVzaWduOiBbU3VyZmFjZSByZWFjdGlvbl0oaHR0cHM6Ly93d3cuZ29vZ2xlLmNvbS9kZXNpZ24vc3BlYy9hbmltYXRpb24vcmVzcG9uc2l2ZS1pbnRlcmFjdGlvbi5odG1sI3Jlc3BvbnNpdmUtaW50ZXJhY3Rpb24tc3VyZmFjZS1yZWFjdGlvbilcblxuYHBhcGVyLXJpcHBsZWAgcHJvdmlkZXMgYSB2aXN1YWwgZWZmZWN0IHRoYXQgb3RoZXIgcGFwZXIgZWxlbWVudHMgY2FuXG51c2UgdG8gc2ltdWxhdGUgYSByaXBwbGluZyBlZmZlY3QgZW1hbmF0aW5nIGZyb20gdGhlIHBvaW50IG9mIGNvbnRhY3QuICBUaGVcbmVmZmVjdCBjYW4gYmUgdmlzdWFsaXplZCBhcyBhIGNvbmNlbnRyaWMgY2lyY2xlIHdpdGggbW90aW9uLlxuXG5FeGFtcGxlOlxuXG4gICAgPGRpdiBzdHlsZT1cInBvc2l0aW9uOnJlbGF0aXZlXCI+XG4gICAgICA8cGFwZXItcmlwcGxlPjwvcGFwZXItcmlwcGxlPlxuICAgIDwvZGl2PlxuXG5Ob3RlLCBpdCdzIGltcG9ydGFudCB0aGF0IHRoZSBwYXJlbnQgY29udGFpbmVyIG9mIHRoZSByaXBwbGUgYmUgcmVsYXRpdmUgcG9zaXRpb24sIG90aGVyd2lzZVxudGhlIHJpcHBsZSB3aWxsIGVtYW5hdGUgb3V0c2lkZSBvZiB0aGUgZGVzaXJlZCBjb250YWluZXIuXG5cbmBwYXBlci1yaXBwbGVgIGxpc3RlbnMgdG8gXCJtb3VzZWRvd25cIiBhbmQgXCJtb3VzZXVwXCIgZXZlbnRzIHNvIGl0IHdvdWxkIGRpc3BsYXkgcmlwcGxlXG5lZmZlY3Qgd2hlbiB0b3VjaGVzIG9uIGl0LiAgWW91IGNhbiBhbHNvIGRlZmVhdCB0aGUgZGVmYXVsdCBiZWhhdmlvciBhbmRcbm1hbnVhbGx5IHJvdXRlIHRoZSBkb3duIGFuZCB1cCBhY3Rpb25zIHRvIHRoZSByaXBwbGUgZWxlbWVudC4gIE5vdGUgdGhhdCBpdCBpc1xuaW1wb3J0YW50IGlmIHlvdSBjYWxsIGBkb3duQWN0aW9uKClgIHlvdSB3aWxsIGhhdmUgdG8gbWFrZSBzdXJlIHRvIGNhbGxcbmB1cEFjdGlvbigpYCBzbyB0aGF0IGBwYXBlci1yaXBwbGVgIHdvdWxkIGVuZCB0aGUgYW5pbWF0aW9uIGxvb3AuXG5cbkV4YW1wbGU6XG5cbiAgICA8cGFwZXItcmlwcGxlIGlkPVwicmlwcGxlXCIgc3R5bGU9XCJwb2ludGVyLWV2ZW50czogbm9uZTtcIj48L3BhcGVyLXJpcHBsZT5cbiAgICAuLi5cbiAgICBkb3duQWN0aW9uOiBmdW5jdGlvbihlKSB7XG4gICAgICB0aGlzLiQucmlwcGxlLmRvd25BY3Rpb24oZS5kZXRhaWwpO1xuICAgIH0sXG4gICAgdXBBY3Rpb246IGZ1bmN0aW9uKGUpIHtcbiAgICAgIHRoaXMuJC5yaXBwbGUudXBBY3Rpb24oKTtcbiAgICB9XG5cblN0eWxpbmcgcmlwcGxlIGVmZmVjdDpcblxuICBVc2UgQ1NTIGNvbG9yIHByb3BlcnR5IHRvIHN0eWxlIHRoZSByaXBwbGU6XG5cbiAgICBwYXBlci1yaXBwbGUge1xuICAgICAgY29sb3I6ICM0Mjg1ZjQ7XG4gICAgfVxuXG4gIE5vdGUgdGhhdCBDU1MgY29sb3IgcHJvcGVydHkgaXMgaW5oZXJpdGVkIHNvIGl0IGlzIG5vdCByZXF1aXJlZCB0byBzZXQgaXQgb25cbiAgdGhlIGBwYXBlci1yaXBwbGVgIGVsZW1lbnQgZGlyZWN0bHkuXG5cbkJ5IGRlZmF1bHQsIHRoZSByaXBwbGUgaXMgY2VudGVyZWQgb24gdGhlIHBvaW50IG9mIGNvbnRhY3QuICBBcHBseSB0aGUgYHJlY2VudGVyc2BcbmF0dHJpYnV0ZSB0byBoYXZlIHRoZSByaXBwbGUgZ3JvdyB0b3dhcmQgdGhlIGNlbnRlciBvZiBpdHMgY29udGFpbmVyLlxuXG4gICAgPHBhcGVyLXJpcHBsZSByZWNlbnRlcnM+PC9wYXBlci1yaXBwbGU+XG5cbllvdSBjYW4gYWxzbyAgY2VudGVyIHRoZSByaXBwbGUgaW5zaWRlIGl0cyBjb250YWluZXIgZnJvbSB0aGUgc3RhcnQuXG5cbiAgICA8cGFwZXItcmlwcGxlIGNlbnRlcj48L3BhcGVyLXJpcHBsZT5cblxuQXBwbHkgYGNpcmNsZWAgY2xhc3MgdG8gbWFrZSB0aGUgcmlwcGxpbmcgZWZmZWN0IHdpdGhpbiBhIGNpcmNsZS5cblxuICAgIDxwYXBlci1yaXBwbGUgY2xhc3M9XCJjaXJjbGVcIj48L3BhcGVyLXJpcHBsZT5cblxuQGdyb3VwIFBhcGVyIEVsZW1lbnRzXG5AZWxlbWVudCBwYXBlci1yaXBwbGVcbkBoZXJvIGhlcm8uc3ZnXG5AZGVtbyBkZW1vL2luZGV4Lmh0bWxcbi0tPlxuXG48ZG9tLW1vZHVsZSBpZD1cInBhcGVyLXJpcHBsZVwiPlxuXG4gIDx0ZW1wbGF0ZT5cbiAgICA8c3R5bGU+XG4gICAgICA6aG9zdCB7XG4gICAgICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IGluaGVyaXQ7XG4gICAgICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgICAgIHRvcDogMDtcbiAgICAgICAgbGVmdDogMDtcbiAgICAgICAgcmlnaHQ6IDA7XG4gICAgICAgIGJvdHRvbTogMDtcblxuICAgICAgICAvKiBTZWUgUG9seW1lckVsZW1lbnRzL3BhcGVyLWJlaGF2aW9ycy9pc3N1ZXMvMzQuIE9uIG5vbi1DaHJvbWUgYnJvd3NlcnMsXG4gICAgICAgICAqIGNyZWF0aW5nIGEgbm9kZSAod2l0aCBhIHBvc2l0aW9uOmFic29sdXRlKSBpbiB0aGUgbWlkZGxlIG9mIGFuIGV2ZW50XG4gICAgICAgICAqIGhhbmRsZXIgXCJpbnRlcnJ1cHRzXCIgdGhhdCBldmVudCBoYW5kbGVyICh3aGljaCBoYXBwZW5zIHdoZW4gdGhlXG4gICAgICAgICAqIHJpcHBsZSBpcyBjcmVhdGVkIG9uIGRlbWFuZCkgKi9cbiAgICAgICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG4gICAgICB9XG5cbiAgICAgIDpob3N0KFthbmltYXRpbmddKSB7XG4gICAgICAgIC8qIFRoaXMgcmVzb2x2ZXMgYSByZW5kZXJpbmcgaXNzdWUgaW4gQ2hyb21lIChhcyBvZiA0MCkgd2hlcmUgdGhlXG4gICAgICAgICAgIHJpcHBsZSBpcyBub3QgcHJvcGVybHkgY2xpcHBlZCBieSBpdHMgcGFyZW50ICh3aGljaCBtYXkgaGF2ZVxuICAgICAgICAgICByb3VuZGVkIGNvcm5lcnMpLiBTZWU6IGh0dHA6Ly9qc2Jpbi5jb20vdGVtZXhhLzRcblxuICAgICAgICAgICBOb3RlOiBXZSBvbmx5IGFwcGx5IHRoaXMgc3R5bGUgY29uZGl0aW9uYWxseS4gT3RoZXJ3aXNlLCB0aGUgYnJvd3NlclxuICAgICAgICAgICB3aWxsIGNyZWF0ZSBhIG5ldyBjb21wb3NpdGluZyBsYXllciBmb3IgZXZlcnkgcmlwcGxlIGVsZW1lbnQgb24gdGhlXG4gICAgICAgICAgIHBhZ2UsIGFuZCB0aGF0IHdvdWxkIGJlIGJhZC4gKi9cbiAgICAgICAgLXdlYmtpdC10cmFuc2Zvcm06IHRyYW5zbGF0ZSgwLCAwKTtcbiAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgwLCAwLCAwKTtcbiAgICAgIH1cblxuICAgICAgI2JhY2tncm91bmQsXG4gICAgICAjd2F2ZXMsXG4gICAgICAud2F2ZS1jb250YWluZXIsXG4gICAgICAud2F2ZSB7XG4gICAgICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIHRvcDogMDtcbiAgICAgICAgbGVmdDogMDtcbiAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgIGhlaWdodDogMTAwJTtcbiAgICAgIH1cblxuICAgICAgI2JhY2tncm91bmQsXG4gICAgICAud2F2ZSB7XG4gICAgICAgIG9wYWNpdHk6IDA7XG4gICAgICB9XG5cbiAgICAgICN3YXZlcyxcbiAgICAgIC53YXZlIHtcbiAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICAgIH1cblxuICAgICAgLndhdmUtY29udGFpbmVyLFxuICAgICAgLndhdmUge1xuICAgICAgICBib3JkZXItcmFkaXVzOiA1MCU7XG4gICAgICB9XG5cbiAgICAgIDpob3N0KC5jaXJjbGUpICNiYWNrZ3JvdW5kLFxuICAgICAgOmhvc3QoLmNpcmNsZSkgI3dhdmVzIHtcbiAgICAgICAgYm9yZGVyLXJhZGl1czogNTAlO1xuICAgICAgfVxuXG4gICAgICA6aG9zdCguY2lyY2xlKSAud2F2ZS1jb250YWluZXIge1xuICAgICAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgICAgfVxuICAgIDwvc3R5bGU+XG5cbiAgICA8ZGl2IGlkPVwiYmFja2dyb3VuZFwiPjwvZGl2PlxuICAgIDxkaXYgaWQ9XCJ3YXZlc1wiPjwvZGl2PlxuICA8L3RlbXBsYXRlPlxuPC9kb20tbW9kdWxlPlxuPHNjcmlwdD5cbiAgKGZ1bmN0aW9uKCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBVdGlsaXR5ID0ge1xuICAgICAgZGlzdGFuY2U6IGZ1bmN0aW9uKHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgICAgIHZhciB4RGVsdGEgPSAoeDEgLSB4Mik7XG4gICAgICAgIHZhciB5RGVsdGEgPSAoeTEgLSB5Mik7XG5cbiAgICAgICAgcmV0dXJuIE1hdGguc3FydCh4RGVsdGEgKiB4RGVsdGEgKyB5RGVsdGEgKiB5RGVsdGEpO1xuICAgICAgfSxcblxuICAgICAgbm93OiB3aW5kb3cucGVyZm9ybWFuY2UgJiYgd2luZG93LnBlcmZvcm1hbmNlLm5vdyA/XG4gICAgICAgICAgd2luZG93LnBlcmZvcm1hbmNlLm5vdy5iaW5kKHdpbmRvdy5wZXJmb3JtYW5jZSkgOiBEYXRlLm5vd1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gRWxlbWVudE1ldHJpY3MoZWxlbWVudCkge1xuICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgIHRoaXMud2lkdGggPSB0aGlzLmJvdW5kaW5nUmVjdC53aWR0aDtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5ib3VuZGluZ1JlY3QuaGVpZ2h0O1xuXG4gICAgICB0aGlzLnNpemUgPSBNYXRoLm1heCh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgfVxuXG4gICAgRWxlbWVudE1ldHJpY3MucHJvdG90eXBlID0ge1xuICAgICAgZ2V0IGJvdW5kaW5nUmVjdCAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB9LFxuXG4gICAgICBmdXJ0aGVzdENvcm5lckRpc3RhbmNlRnJvbTogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICB2YXIgdG9wTGVmdCA9IFV0aWxpdHkuZGlzdGFuY2UoeCwgeSwgMCwgMCk7XG4gICAgICAgIHZhciB0b3BSaWdodCA9IFV0aWxpdHkuZGlzdGFuY2UoeCwgeSwgdGhpcy53aWR0aCwgMCk7XG4gICAgICAgIHZhciBib3R0b21MZWZ0ID0gVXRpbGl0eS5kaXN0YW5jZSh4LCB5LCAwLCB0aGlzLmhlaWdodCk7XG4gICAgICAgIHZhciBib3R0b21SaWdodCA9IFV0aWxpdHkuZGlzdGFuY2UoeCwgeSwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuXG4gICAgICAgIHJldHVybiBNYXRoLm1heCh0b3BMZWZ0LCB0b3BSaWdodCwgYm90dG9tTGVmdCwgYm90dG9tUmlnaHQpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gUmlwcGxlKGVsZW1lbnQpIHtcbiAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICB0aGlzLmNvbG9yID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkuY29sb3I7XG5cbiAgICAgIHRoaXMud2F2ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgdGhpcy53YXZlQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICB0aGlzLndhdmUuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gdGhpcy5jb2xvcjtcbiAgICAgIHRoaXMud2F2ZS5jbGFzc0xpc3QuYWRkKCd3YXZlJyk7XG4gICAgICB0aGlzLndhdmVDb250YWluZXIuY2xhc3NMaXN0LmFkZCgnd2F2ZS1jb250YWluZXInKTtcbiAgICAgIFBvbHltZXIuZG9tKHRoaXMud2F2ZUNvbnRhaW5lcikuYXBwZW5kQ2hpbGQodGhpcy53YXZlKTtcblxuICAgICAgdGhpcy5yZXNldEludGVyYWN0aW9uU3RhdGUoKTtcbiAgICB9XG5cbiAgICBSaXBwbGUuTUFYX1JBRElVUyA9IDMwMDtcblxuICAgIFJpcHBsZS5wcm90b3R5cGUgPSB7XG4gICAgICBnZXQgcmVjZW50ZXJzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50LnJlY2VudGVycztcbiAgICAgIH0sXG5cbiAgICAgIGdldCBjZW50ZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnQuY2VudGVyO1xuICAgICAgfSxcblxuICAgICAgZ2V0IG1vdXNlRG93bkVsYXBzZWQoKSB7XG4gICAgICAgIHZhciBlbGFwc2VkO1xuXG4gICAgICAgIGlmICghdGhpcy5tb3VzZURvd25TdGFydCkge1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgZWxhcHNlZCA9IFV0aWxpdHkubm93KCkgLSB0aGlzLm1vdXNlRG93blN0YXJ0O1xuXG4gICAgICAgIGlmICh0aGlzLm1vdXNlVXBTdGFydCkge1xuICAgICAgICAgIGVsYXBzZWQgLT0gdGhpcy5tb3VzZVVwRWxhcHNlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBlbGFwc2VkO1xuICAgICAgfSxcblxuICAgICAgZ2V0IG1vdXNlVXBFbGFwc2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb3VzZVVwU3RhcnQgP1xuICAgICAgICAgIFV0aWxpdHkubm93ICgpIC0gdGhpcy5tb3VzZVVwU3RhcnQgOiAwO1xuICAgICAgfSxcblxuICAgICAgZ2V0IG1vdXNlRG93bkVsYXBzZWRTZWNvbmRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb3VzZURvd25FbGFwc2VkIC8gMTAwMDtcbiAgICAgIH0sXG5cbiAgICAgIGdldCBtb3VzZVVwRWxhcHNlZFNlY29uZHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vdXNlVXBFbGFwc2VkIC8gMTAwMDtcbiAgICAgIH0sXG5cbiAgICAgIGdldCBtb3VzZUludGVyYWN0aW9uU2Vjb25kcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW91c2VEb3duRWxhcHNlZFNlY29uZHMgKyB0aGlzLm1vdXNlVXBFbGFwc2VkU2Vjb25kcztcbiAgICAgIH0sXG5cbiAgICAgIGdldCBpbml0aWFsT3BhY2l0eSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudC5pbml0aWFsT3BhY2l0eTtcbiAgICAgIH0sXG5cbiAgICAgIGdldCBvcGFjaXR5RGVjYXlWZWxvY2l0eSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudC5vcGFjaXR5RGVjYXlWZWxvY2l0eTtcbiAgICAgIH0sXG5cbiAgICAgIGdldCByYWRpdXMoKSB7XG4gICAgICAgIHZhciB3aWR0aDIgPSB0aGlzLmNvbnRhaW5lck1ldHJpY3Mud2lkdGggKiB0aGlzLmNvbnRhaW5lck1ldHJpY3Mud2lkdGg7XG4gICAgICAgIHZhciBoZWlnaHQyID0gdGhpcy5jb250YWluZXJNZXRyaWNzLmhlaWdodCAqIHRoaXMuY29udGFpbmVyTWV0cmljcy5oZWlnaHQ7XG4gICAgICAgIHZhciB3YXZlUmFkaXVzID0gTWF0aC5taW4oXG4gICAgICAgICAgTWF0aC5zcXJ0KHdpZHRoMiArIGhlaWdodDIpLFxuICAgICAgICAgIFJpcHBsZS5NQVhfUkFESVVTXG4gICAgICAgICkgKiAxLjEgKyA1O1xuXG4gICAgICAgIHZhciBkdXJhdGlvbiA9IDEuMSAtIDAuMiAqICh3YXZlUmFkaXVzIC8gUmlwcGxlLk1BWF9SQURJVVMpO1xuICAgICAgICB2YXIgdGltZU5vdyA9IHRoaXMubW91c2VJbnRlcmFjdGlvblNlY29uZHMgLyBkdXJhdGlvbjtcbiAgICAgICAgdmFyIHNpemUgPSB3YXZlUmFkaXVzICogKDEgLSBNYXRoLnBvdyg4MCwgLXRpbWVOb3cpKTtcblxuICAgICAgICByZXR1cm4gTWF0aC5hYnMoc2l6ZSk7XG4gICAgICB9LFxuXG4gICAgICBnZXQgb3BhY2l0eSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLm1vdXNlVXBTdGFydCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmluaXRpYWxPcGFjaXR5O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KFxuICAgICAgICAgIDAsXG4gICAgICAgICAgdGhpcy5pbml0aWFsT3BhY2l0eSAtIHRoaXMubW91c2VVcEVsYXBzZWRTZWNvbmRzICogdGhpcy5vcGFjaXR5RGVjYXlWZWxvY2l0eVxuICAgICAgICApO1xuICAgICAgfSxcblxuICAgICAgZ2V0IG91dGVyT3BhY2l0eSgpIHtcbiAgICAgICAgLy8gTGluZWFyIGluY3JlYXNlIGluIGJhY2tncm91bmQgb3BhY2l0eSwgY2FwcGVkIGF0IHRoZSBvcGFjaXR5XG4gICAgICAgIC8vIG9mIHRoZSB3YXZlZnJvbnQgKHdhdmVPcGFjaXR5KS5cbiAgICAgICAgdmFyIG91dGVyT3BhY2l0eSA9IHRoaXMubW91c2VVcEVsYXBzZWRTZWNvbmRzICogMC4zO1xuICAgICAgICB2YXIgd2F2ZU9wYWNpdHkgPSB0aGlzLm9wYWNpdHk7XG5cbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KFxuICAgICAgICAgIDAsXG4gICAgICAgICAgTWF0aC5taW4ob3V0ZXJPcGFjaXR5LCB3YXZlT3BhY2l0eSlcbiAgICAgICAgKTtcbiAgICAgIH0sXG5cbiAgICAgIGdldCBpc09wYWNpdHlGdWxseURlY2F5ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wYWNpdHkgPCAwLjAxICYmXG4gICAgICAgICAgdGhpcy5yYWRpdXMgPj0gTWF0aC5taW4odGhpcy5tYXhSYWRpdXMsIFJpcHBsZS5NQVhfUkFESVVTKTtcbiAgICAgIH0sXG5cbiAgICAgIGdldCBpc1Jlc3RpbmdBdE1heFJhZGl1cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3BhY2l0eSA+PSB0aGlzLmluaXRpYWxPcGFjaXR5ICYmXG4gICAgICAgICAgdGhpcy5yYWRpdXMgPj0gTWF0aC5taW4odGhpcy5tYXhSYWRpdXMsIFJpcHBsZS5NQVhfUkFESVVTKTtcbiAgICAgIH0sXG5cbiAgICAgIGdldCBpc0FuaW1hdGlvbkNvbXBsZXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb3VzZVVwU3RhcnQgP1xuICAgICAgICAgIHRoaXMuaXNPcGFjaXR5RnVsbHlEZWNheWVkIDogdGhpcy5pc1Jlc3RpbmdBdE1heFJhZGl1cztcbiAgICAgIH0sXG5cbiAgICAgIGdldCB0cmFuc2xhdGlvbkZyYWN0aW9uKCkge1xuICAgICAgICByZXR1cm4gTWF0aC5taW4oXG4gICAgICAgICAgMSxcbiAgICAgICAgICB0aGlzLnJhZGl1cyAvIHRoaXMuY29udGFpbmVyTWV0cmljcy5zaXplICogMiAvIE1hdGguc3FydCgyKVxuICAgICAgICApO1xuICAgICAgfSxcblxuICAgICAgZ2V0IHhOb3coKSB7XG4gICAgICAgIGlmICh0aGlzLnhFbmQpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy54U3RhcnQgKyB0aGlzLnRyYW5zbGF0aW9uRnJhY3Rpb24gKiAodGhpcy54RW5kIC0gdGhpcy54U3RhcnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMueFN0YXJ0O1xuICAgICAgfSxcblxuICAgICAgZ2V0IHlOb3coKSB7XG4gICAgICAgIGlmICh0aGlzLnlFbmQpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy55U3RhcnQgKyB0aGlzLnRyYW5zbGF0aW9uRnJhY3Rpb24gKiAodGhpcy55RW5kIC0gdGhpcy55U3RhcnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMueVN0YXJ0O1xuICAgICAgfSxcblxuICAgICAgZ2V0IGlzTW91c2VEb3duKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb3VzZURvd25TdGFydCAmJiAhdGhpcy5tb3VzZVVwU3RhcnQ7XG4gICAgICB9LFxuXG4gICAgICByZXNldEludGVyYWN0aW9uU3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLm1heFJhZGl1cyA9IDA7XG4gICAgICAgIHRoaXMubW91c2VEb3duU3RhcnQgPSAwO1xuICAgICAgICB0aGlzLm1vdXNlVXBTdGFydCA9IDA7XG5cbiAgICAgICAgdGhpcy54U3RhcnQgPSAwO1xuICAgICAgICB0aGlzLnlTdGFydCA9IDA7XG4gICAgICAgIHRoaXMueEVuZCA9IDA7XG4gICAgICAgIHRoaXMueUVuZCA9IDA7XG4gICAgICAgIHRoaXMuc2xpZGVEaXN0YW5jZSA9IDA7XG5cbiAgICAgICAgdGhpcy5jb250YWluZXJNZXRyaWNzID0gbmV3IEVsZW1lbnRNZXRyaWNzKHRoaXMuZWxlbWVudCk7XG4gICAgICB9LFxuXG4gICAgICBkcmF3OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNjYWxlO1xuICAgICAgICB2YXIgdHJhbnNsYXRlU3RyaW5nO1xuICAgICAgICB2YXIgZHg7XG4gICAgICAgIHZhciBkeTtcblxuICAgICAgICB0aGlzLndhdmUuc3R5bGUub3BhY2l0eSA9IHRoaXMub3BhY2l0eTtcblxuICAgICAgICBzY2FsZSA9IHRoaXMucmFkaXVzIC8gKHRoaXMuY29udGFpbmVyTWV0cmljcy5zaXplIC8gMik7XG4gICAgICAgIGR4ID0gdGhpcy54Tm93IC0gKHRoaXMuY29udGFpbmVyTWV0cmljcy53aWR0aCAvIDIpO1xuICAgICAgICBkeSA9IHRoaXMueU5vdyAtICh0aGlzLmNvbnRhaW5lck1ldHJpY3MuaGVpZ2h0IC8gMik7XG5cblxuICAgICAgICAvLyAyZCB0cmFuc2Zvcm0gZm9yIHNhZmFyaSBiZWNhdXNlIG9mIGJvcmRlci1yYWRpdXMgYW5kIG92ZXJmbG93OmhpZGRlbiBjbGlwcGluZyBidWcuXG4gICAgICAgIC8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD05ODUzOFxuICAgICAgICB0aGlzLndhdmVDb250YWluZXIuc3R5bGUud2Via2l0VHJhbnNmb3JtID0gJ3RyYW5zbGF0ZSgnICsgZHggKyAncHgsICcgKyBkeSArICdweCknO1xuICAgICAgICB0aGlzLndhdmVDb250YWluZXIuc3R5bGUudHJhbnNmb3JtID0gJ3RyYW5zbGF0ZTNkKCcgKyBkeCArICdweCwgJyArIGR5ICsgJ3B4LCAwKSc7XG4gICAgICAgIHRoaXMud2F2ZS5zdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSAnc2NhbGUoJyArIHNjYWxlICsgJywnICsgc2NhbGUgKyAnKSc7XG4gICAgICAgIHRoaXMud2F2ZS5zdHlsZS50cmFuc2Zvcm0gPSAnc2NhbGUzZCgnICsgc2NhbGUgKyAnLCcgKyBzY2FsZSArICcsMSknO1xuICAgICAgfSxcblxuICAgICAgLyoqIEBwYXJhbSB7RXZlbnQ9fSBldmVudCAqL1xuICAgICAgZG93bkFjdGlvbjogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgdmFyIHhDZW50ZXIgPSB0aGlzLmNvbnRhaW5lck1ldHJpY3Mud2lkdGggLyAyO1xuICAgICAgICB2YXIgeUNlbnRlciA9IHRoaXMuY29udGFpbmVyTWV0cmljcy5oZWlnaHQgLyAyO1xuXG4gICAgICAgIHRoaXMucmVzZXRJbnRlcmFjdGlvblN0YXRlKCk7XG4gICAgICAgIHRoaXMubW91c2VEb3duU3RhcnQgPSBVdGlsaXR5Lm5vdygpO1xuXG4gICAgICAgIGlmICh0aGlzLmNlbnRlcikge1xuICAgICAgICAgIHRoaXMueFN0YXJ0ID0geENlbnRlcjtcbiAgICAgICAgICB0aGlzLnlTdGFydCA9IHlDZW50ZXI7XG4gICAgICAgICAgdGhpcy5zbGlkZURpc3RhbmNlID0gVXRpbGl0eS5kaXN0YW5jZShcbiAgICAgICAgICAgIHRoaXMueFN0YXJ0LCB0aGlzLnlTdGFydCwgdGhpcy54RW5kLCB0aGlzLnlFbmRcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMueFN0YXJ0ID0gZXZlbnQgP1xuICAgICAgICAgICAgICBldmVudC5kZXRhaWwueCAtIHRoaXMuY29udGFpbmVyTWV0cmljcy5ib3VuZGluZ1JlY3QubGVmdCA6XG4gICAgICAgICAgICAgIHRoaXMuY29udGFpbmVyTWV0cmljcy53aWR0aCAvIDI7XG4gICAgICAgICAgdGhpcy55U3RhcnQgPSBldmVudCA/XG4gICAgICAgICAgICAgIGV2ZW50LmRldGFpbC55IC0gdGhpcy5jb250YWluZXJNZXRyaWNzLmJvdW5kaW5nUmVjdC50b3AgOlxuICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lck1ldHJpY3MuaGVpZ2h0IC8gMjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnJlY2VudGVycykge1xuICAgICAgICAgIHRoaXMueEVuZCA9IHhDZW50ZXI7XG4gICAgICAgICAgdGhpcy55RW5kID0geUNlbnRlcjtcbiAgICAgICAgICB0aGlzLnNsaWRlRGlzdGFuY2UgPSBVdGlsaXR5LmRpc3RhbmNlKFxuICAgICAgICAgICAgdGhpcy54U3RhcnQsIHRoaXMueVN0YXJ0LCB0aGlzLnhFbmQsIHRoaXMueUVuZFxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm1heFJhZGl1cyA9IHRoaXMuY29udGFpbmVyTWV0cmljcy5mdXJ0aGVzdENvcm5lckRpc3RhbmNlRnJvbShcbiAgICAgICAgICB0aGlzLnhTdGFydCxcbiAgICAgICAgICB0aGlzLnlTdGFydFxuICAgICAgICApO1xuXG4gICAgICAgIHRoaXMud2F2ZUNvbnRhaW5lci5zdHlsZS50b3AgPVxuICAgICAgICAgICh0aGlzLmNvbnRhaW5lck1ldHJpY3MuaGVpZ2h0IC0gdGhpcy5jb250YWluZXJNZXRyaWNzLnNpemUpIC8gMiArICdweCc7XG4gICAgICAgIHRoaXMud2F2ZUNvbnRhaW5lci5zdHlsZS5sZWZ0ID1cbiAgICAgICAgICAodGhpcy5jb250YWluZXJNZXRyaWNzLndpZHRoIC0gdGhpcy5jb250YWluZXJNZXRyaWNzLnNpemUpIC8gMiArICdweCc7XG5cbiAgICAgICAgdGhpcy53YXZlQ29udGFpbmVyLnN0eWxlLndpZHRoID0gdGhpcy5jb250YWluZXJNZXRyaWNzLnNpemUgKyAncHgnO1xuICAgICAgICB0aGlzLndhdmVDb250YWluZXIuc3R5bGUuaGVpZ2h0ID0gdGhpcy5jb250YWluZXJNZXRyaWNzLnNpemUgKyAncHgnO1xuICAgICAgfSxcblxuICAgICAgLyoqIEBwYXJhbSB7RXZlbnQ9fSBldmVudCAqL1xuICAgICAgdXBBY3Rpb246IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIGlmICghdGhpcy5pc01vdXNlRG93bikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubW91c2VVcFN0YXJ0ID0gVXRpbGl0eS5ub3coKTtcbiAgICAgIH0sXG5cbiAgICAgIHJlbW92ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIFBvbHltZXIuZG9tKHRoaXMud2F2ZUNvbnRhaW5lci5wYXJlbnROb2RlKS5yZW1vdmVDaGlsZChcbiAgICAgICAgICB0aGlzLndhdmVDb250YWluZXJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgUG9seW1lcih7XG4gICAgICBpczogJ3BhcGVyLXJpcHBsZScsXG5cbiAgICAgIGJlaGF2aW9yczogW1xuICAgICAgICBQb2x5bWVyLklyb25BMTF5S2V5c0JlaGF2aW9yXG4gICAgICBdLFxuXG4gICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgaW5pdGlhbCBvcGFjaXR5IHNldCBvbiB0aGUgd2F2ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQGF0dHJpYnV0ZSBpbml0aWFsT3BhY2l0eVxuICAgICAgICAgKiBAdHlwZSBudW1iZXJcbiAgICAgICAgICogQGRlZmF1bHQgMC4yNVxuICAgICAgICAgKi9cbiAgICAgICAgaW5pdGlhbE9wYWNpdHk6IHtcbiAgICAgICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICAgICAgdmFsdWU6IDAuMjVcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSG93IGZhc3QgKG9wYWNpdHkgcGVyIHNlY29uZCkgdGhlIHdhdmUgZmFkZXMgb3V0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAYXR0cmlidXRlIG9wYWNpdHlEZWNheVZlbG9jaXR5XG4gICAgICAgICAqIEB0eXBlIG51bWJlclxuICAgICAgICAgKiBAZGVmYXVsdCAwLjhcbiAgICAgICAgICovXG4gICAgICAgIG9wYWNpdHlEZWNheVZlbG9jaXR5OiB7XG4gICAgICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgICAgIHZhbHVlOiAwLjhcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgdHJ1ZSwgcmlwcGxlcyB3aWxsIGV4aGliaXQgYSBncmF2aXRhdGlvbmFsIHB1bGwgdG93YXJkc1xuICAgICAgICAgKiB0aGUgY2VudGVyIG9mIHRoZWlyIGNvbnRhaW5lciBhcyB0aGV5IGZhZGUgYXdheS5cbiAgICAgICAgICpcbiAgICAgICAgICogQGF0dHJpYnV0ZSByZWNlbnRlcnNcbiAgICAgICAgICogQHR5cGUgYm9vbGVhblxuICAgICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgcmVjZW50ZXJzOiB7XG4gICAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgdHJ1ZSwgcmlwcGxlcyB3aWxsIGNlbnRlciBpbnNpZGUgaXRzIGNvbnRhaW5lclxuICAgICAgICAgKlxuICAgICAgICAgKiBAYXR0cmlidXRlIHJlY2VudGVyc1xuICAgICAgICAgKiBAdHlwZSBib29sZWFuXG4gICAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBjZW50ZXI6IHtcbiAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGxpc3Qgb2YgdGhlIHZpc3VhbCByaXBwbGVzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAYXR0cmlidXRlIHJpcHBsZXNcbiAgICAgICAgICogQHR5cGUgQXJyYXlcbiAgICAgICAgICogQGRlZmF1bHQgW11cbiAgICAgICAgICovXG4gICAgICAgIHJpcHBsZXM6IHtcbiAgICAgICAgICB0eXBlOiBBcnJheSxcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcnVlIHdoZW4gdGhlcmUgYXJlIHZpc2libGUgcmlwcGxlcyBhbmltYXRpbmcgd2l0aGluIHRoZVxuICAgICAgICAgKiBlbGVtZW50LlxuICAgICAgICAgKi9cbiAgICAgICAgYW5pbWF0aW5nOiB7XG4gICAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgICByZWFkT25seTogdHJ1ZSxcbiAgICAgICAgICByZWZsZWN0VG9BdHRyaWJ1dGU6IHRydWUsXG4gICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHRydWUsIHRoZSByaXBwbGUgd2lsbCByZW1haW4gaW4gdGhlIFwiZG93blwiIHN0YXRlIHVudGlsIGBob2xkRG93bmBcbiAgICAgICAgICogaXMgc2V0IHRvIGZhbHNlIGFnYWluLlxuICAgICAgICAgKi9cbiAgICAgICAgaG9sZERvd246IHtcbiAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgIHZhbHVlOiBmYWxzZSxcbiAgICAgICAgICBvYnNlcnZlcjogJ19ob2xkRG93bkNoYW5nZWQnXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHRydWUsIHRoZSByaXBwbGUgd2lsbCBub3QgZ2VuZXJhdGUgYSByaXBwbGUgZWZmZWN0XG4gICAgICAgICAqIHZpYSBwb2ludGVyIGludGVyYWN0aW9uLlxuICAgICAgICAgKiBDYWxsaW5nIHJpcHBsZSdzIGltcGVyYXRpdmUgYXBpIGxpa2UgYHNpbXVsYXRlZFJpcHBsZWAgd2lsbFxuICAgICAgICAgKiBzdGlsbCBnZW5lcmF0ZSB0aGUgcmlwcGxlIGVmZmVjdC5cbiAgICAgICAgICovXG4gICAgICAgIG5vaW5rOiB7XG4gICAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgfSxcblxuICAgICAgICBfYW5pbWF0aW5nOiB7XG4gICAgICAgICAgdHlwZTogQm9vbGVhblxuICAgICAgICB9LFxuXG4gICAgICAgIF9ib3VuZEFuaW1hdGU6IHtcbiAgICAgICAgICB0eXBlOiBGdW5jdGlvbixcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hbmltYXRlLmJpbmQodGhpcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBnZXQgdGFyZ2V0ICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMua2V5RXZlbnRUYXJnZXQ7XG4gICAgICB9LFxuXG4gICAgICBrZXlCaW5kaW5nczoge1xuICAgICAgICAnZW50ZXI6a2V5ZG93bic6ICdfb25FbnRlcktleWRvd24nLFxuICAgICAgICAnc3BhY2U6a2V5ZG93bic6ICdfb25TcGFjZUtleWRvd24nLFxuICAgICAgICAnc3BhY2U6a2V5dXAnOiAnX29uU3BhY2VLZXl1cCdcbiAgICAgIH0sXG5cbiAgICAgIGF0dGFjaGVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gU2V0IHVwIGExMXlLZXlzQmVoYXZpb3IgdG8gbGlzdGVuIHRvIGtleSBldmVudHMgb24gdGhlIHRhcmdldCxcbiAgICAgICAgLy8gc28gdGhhdCBzcGFjZSBhbmQgZW50ZXIgYWN0aXZhdGUgdGhlIHJpcHBsZSBldmVuIGlmIHRoZSB0YXJnZXQgZG9lc24ndFxuICAgICAgICAvLyBoYW5kbGUga2V5IGV2ZW50cy4gVGhlIGtleSBoYW5kbGVycyBkZWFsIHdpdGggYG5vaW5rYCB0aGVtc2VsdmVzLlxuICAgICAgICBpZiAodGhpcy5wYXJlbnROb2RlLm5vZGVUeXBlID09IDExKSB7IC8vIERPQ1VNRU5UX0ZSQUdNRU5UX05PREVcbiAgICAgICAgICB0aGlzLmtleUV2ZW50VGFyZ2V0ID0gUG9seW1lci5kb20odGhpcykuZ2V0T3duZXJSb290KCkuaG9zdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmtleUV2ZW50VGFyZ2V0ID0gdGhpcy5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBrZXlFdmVudFRhcmdldCA9IC8qKiBAdHlwZSB7IUV2ZW50VGFyZ2V0fSAqLyAodGhpcy5rZXlFdmVudFRhcmdldCk7XG4gICAgICAgIHRoaXMubGlzdGVuKGtleUV2ZW50VGFyZ2V0LCAndXAnLCAndWlVcEFjdGlvbicpO1xuICAgICAgICB0aGlzLmxpc3RlbihrZXlFdmVudFRhcmdldCwgJ2Rvd24nLCAndWlEb3duQWN0aW9uJyk7XG4gICAgICB9LFxuXG4gICAgICBkZXRhY2hlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMudW5saXN0ZW4odGhpcy5rZXlFdmVudFRhcmdldCwgJ3VwJywgJ3VpVXBBY3Rpb24nKTtcbiAgICAgICAgdGhpcy51bmxpc3Rlbih0aGlzLmtleUV2ZW50VGFyZ2V0LCAnZG93bicsICd1aURvd25BY3Rpb24nKTtcbiAgICAgICAgdGhpcy5rZXlFdmVudFRhcmdldCA9IG51bGw7XG4gICAgICB9LFxuXG4gICAgICBnZXQgc2hvdWxkS2VlcEFuaW1hdGluZyAoKSB7XG4gICAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCB0aGlzLnJpcHBsZXMubGVuZ3RoOyArK2luZGV4KSB7XG4gICAgICAgICAgaWYgKCF0aGlzLnJpcHBsZXNbaW5kZXhdLmlzQW5pbWF0aW9uQ29tcGxldGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0sXG5cbiAgICAgIHNpbXVsYXRlZFJpcHBsZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZG93bkFjdGlvbihudWxsKTtcblxuICAgICAgICAvLyBQbGVhc2Ugc2VlIHBvbHltZXIvcG9seW1lciMxMzA1XG4gICAgICAgIHRoaXMuYXN5bmMoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdGhpcy51cEFjdGlvbigpO1xuICAgICAgICB9LCAxKTtcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogUHJvdm9rZXMgYSByaXBwbGUgZG93biBlZmZlY3QgdmlhIGEgVUkgZXZlbnQsXG4gICAgICAgKiByZXNwZWN0aW5nIHRoZSBgbm9pbmtgIHByb3BlcnR5LlxuICAgICAgICogQHBhcmFtIHtFdmVudD19IGV2ZW50XG4gICAgICAgKi9cbiAgICAgIHVpRG93bkFjdGlvbjogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLm5vaW5rKSB7XG4gICAgICAgICAgdGhpcy5kb3duQWN0aW9uKGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBQcm92b2tlcyBhIHJpcHBsZSBkb3duIGVmZmVjdCB2aWEgYSBVSSBldmVudCxcbiAgICAgICAqICpub3QqIHJlc3BlY3RpbmcgdGhlIGBub2lua2AgcHJvcGVydHkuXG4gICAgICAgKiBAcGFyYW0ge0V2ZW50PX0gZXZlbnRcbiAgICAgICAqL1xuICAgICAgZG93bkFjdGlvbjogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuaG9sZERvd24gJiYgdGhpcy5yaXBwbGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmlwcGxlID0gdGhpcy5hZGRSaXBwbGUoKTtcblxuICAgICAgICByaXBwbGUuZG93bkFjdGlvbihldmVudCk7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9hbmltYXRpbmcpIHtcbiAgICAgICAgICB0aGlzLl9hbmltYXRpbmcgPSB0cnVlO1xuICAgICAgICAgIHRoaXMuYW5pbWF0ZSgpO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFByb3Zva2VzIGEgcmlwcGxlIHVwIGVmZmVjdCB2aWEgYSBVSSBldmVudCxcbiAgICAgICAqIHJlc3BlY3RpbmcgdGhlIGBub2lua2AgcHJvcGVydHkuXG4gICAgICAgKiBAcGFyYW0ge0V2ZW50PX0gZXZlbnRcbiAgICAgICAqL1xuICAgICAgdWlVcEFjdGlvbjogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLm5vaW5rKSB7XG4gICAgICAgICAgdGhpcy51cEFjdGlvbihldmVudCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogUHJvdm9rZXMgYSByaXBwbGUgdXAgZWZmZWN0IHZpYSBhIFVJIGV2ZW50LFxuICAgICAgICogKm5vdCogcmVzcGVjdGluZyB0aGUgYG5vaW5rYCBwcm9wZXJ0eS5cbiAgICAgICAqIEBwYXJhbSB7RXZlbnQ9fSBldmVudFxuICAgICAgICovXG4gICAgICB1cEFjdGlvbjogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuaG9sZERvd24pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnJpcHBsZXMuZm9yRWFjaChmdW5jdGlvbihyaXBwbGUpIHtcbiAgICAgICAgICByaXBwbGUudXBBY3Rpb24oZXZlbnQpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLl9hbmltYXRpbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLmFuaW1hdGUoKTtcbiAgICAgIH0sXG5cbiAgICAgIG9uQW5pbWF0aW9uQ29tcGxldGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9hbmltYXRpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy4kLmJhY2tncm91bmQuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gbnVsbDtcbiAgICAgICAgdGhpcy5maXJlKCd0cmFuc2l0aW9uZW5kJyk7XG4gICAgICB9LFxuXG4gICAgICBhZGRSaXBwbGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmlwcGxlID0gbmV3IFJpcHBsZSh0aGlzKTtcblxuICAgICAgICBQb2x5bWVyLmRvbSh0aGlzLiQud2F2ZXMpLmFwcGVuZENoaWxkKHJpcHBsZS53YXZlQ29udGFpbmVyKTtcbiAgICAgICAgdGhpcy4kLmJhY2tncm91bmQuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gcmlwcGxlLmNvbG9yO1xuICAgICAgICB0aGlzLnJpcHBsZXMucHVzaChyaXBwbGUpO1xuXG4gICAgICAgIHRoaXMuX3NldEFuaW1hdGluZyh0cnVlKTtcblxuICAgICAgICByZXR1cm4gcmlwcGxlO1xuICAgICAgfSxcblxuICAgICAgcmVtb3ZlUmlwcGxlOiBmdW5jdGlvbihyaXBwbGUpIHtcbiAgICAgICAgdmFyIHJpcHBsZUluZGV4ID0gdGhpcy5yaXBwbGVzLmluZGV4T2YocmlwcGxlKTtcblxuICAgICAgICBpZiAocmlwcGxlSW5kZXggPCAwKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5yaXBwbGVzLnNwbGljZShyaXBwbGVJbmRleCwgMSk7XG5cbiAgICAgICAgcmlwcGxlLnJlbW92ZSgpO1xuXG4gICAgICAgIGlmICghdGhpcy5yaXBwbGVzLmxlbmd0aCkge1xuICAgICAgICAgIHRoaXMuX3NldEFuaW1hdGluZyhmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogVGhpcyBjb25mbGljdHMgd2l0aCBFbGVtZW50I2FudGltYXRlKCkuXG4gICAgICAgKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRWxlbWVudC9hbmltYXRlXG4gICAgICAgKiBAc3VwcHJlc3Mge2NoZWNrVHlwZXN9XG4gICAgICAgKi9cbiAgICAgIGFuaW1hdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2FuaW1hdGluZykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW5kZXg7XG4gICAgICAgIHZhciByaXBwbGU7XG5cbiAgICAgICAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5yaXBwbGVzLmxlbmd0aDsgKytpbmRleCkge1xuICAgICAgICAgIHJpcHBsZSA9IHRoaXMucmlwcGxlc1tpbmRleF07XG5cbiAgICAgICAgICByaXBwbGUuZHJhdygpO1xuXG4gICAgICAgICAgdGhpcy4kLmJhY2tncm91bmQuc3R5bGUub3BhY2l0eSA9IHJpcHBsZS5vdXRlck9wYWNpdHk7XG5cbiAgICAgICAgICBpZiAocmlwcGxlLmlzT3BhY2l0eUZ1bGx5RGVjYXllZCAmJiAhcmlwcGxlLmlzUmVzdGluZ0F0TWF4UmFkaXVzKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZVJpcHBsZShyaXBwbGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5zaG91bGRLZWVwQW5pbWF0aW5nICYmIHRoaXMucmlwcGxlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLm9uQW5pbWF0aW9uQ29tcGxldGUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuX2JvdW5kQW5pbWF0ZSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIF9vbkVudGVyS2V5ZG93bjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMudWlEb3duQWN0aW9uKCk7XG4gICAgICAgIHRoaXMuYXN5bmModGhpcy51aVVwQWN0aW9uLCAxKTtcbiAgICAgIH0sXG5cbiAgICAgIF9vblNwYWNlS2V5ZG93bjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMudWlEb3duQWN0aW9uKCk7XG4gICAgICB9LFxuXG4gICAgICBfb25TcGFjZUtleXVwOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy51aVVwQWN0aW9uKCk7XG4gICAgICB9LFxuXG4gICAgICAvLyBub3RlOiBob2xkRG93biBkb2VzIG5vdCByZXNwZWN0IG5vaW5rIHNpbmNlIGl0IGNhbiBiZSBhIGZvY3VzIGJhc2VkXG4gICAgICAvLyBlZmZlY3QuXG4gICAgICBfaG9sZERvd25DaGFuZ2VkOiBmdW5jdGlvbihuZXdWYWwsIG9sZFZhbCkge1xuICAgICAgICBpZiAob2xkVmFsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5ld1ZhbCkge1xuICAgICAgICAgIHRoaXMuZG93bkFjdGlvbigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMudXBBY3Rpb24oKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgIEZpcmVkIHdoZW4gdGhlIGFuaW1hdGlvbiBmaW5pc2hlcy5cbiAgICAgIFRoaXMgaXMgdXNlZnVsIGlmIHlvdSB3YW50IHRvIHdhaXQgdW50aWxcbiAgICAgIHRoZSByaXBwbGUgYW5pbWF0aW9uIGZpbmlzaGVzIHRvIHBlcmZvcm0gc29tZSBhY3Rpb24uXG5cbiAgICAgIEBldmVudCB0cmFuc2l0aW9uZW5kXG4gICAgICBAcGFyYW0ge3tub2RlOiBPYmplY3R9fSBkZXRhaWwgQ29udGFpbnMgdGhlIGFuaW1hdGVkIG5vZGUuXG4gICAgICAqL1xuICAgIH0pO1xuICB9KSgpO1xuPC9zY3JpcHQ+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL3BhcGVyLXJpcHBsZS9wYXBlci1yaXBwbGUuaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTUgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cblxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3BvbHltZXIvcG9seW1lci5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vaXJvbi1tZXRhL2lyb24tbWV0YS5odG1sXCI+XG5cbjxzY3JpcHQ+XG4gIC8qKlxuICAgKiBUaGUgYGlyb24taWNvbnNldC1zdmdgIGVsZW1lbnQgYWxsb3dzIHVzZXJzIHRvIGRlZmluZSB0aGVpciBvd24gaWNvbiBzZXRzXG4gICAqIHRoYXQgY29udGFpbiBzdmcgaWNvbnMuIFRoZSBzdmcgaWNvbiBlbGVtZW50cyBzaG91bGQgYmUgY2hpbGRyZW4gb2YgdGhlXG4gICAqIGBpcm9uLWljb25zZXQtc3ZnYCBlbGVtZW50LiBNdWx0aXBsZSBpY29ucyBzaG91bGQgYmUgZ2l2ZW4gZGlzdGluY3QgaWQncy5cbiAgICpcbiAgICogVXNpbmcgc3ZnIGVsZW1lbnRzIHRvIGNyZWF0ZSBpY29ucyBoYXMgYSBmZXcgYWR2YW50YWdlcyBvdmVyIHRyYWRpdGlvbmFsXG4gICAqIGJpdG1hcCBncmFwaGljcyBsaWtlIGpwZyBvciBwbmcuIEljb25zIHRoYXQgdXNlIHN2ZyBhcmUgdmVjdG9yIGJhc2VkIHNvXG4gICAqIHRoZXkgYXJlIHJlc29sdXRpb24gaW5kZXBlbmRlbnQgYW5kIHNob3VsZCBsb29rIGdvb2Qgb24gYW55IGRldmljZS4gVGhleVxuICAgKiBhcmUgc3R5bGFibGUgdmlhIGNzcy4gSWNvbnMgY2FuIGJlIHRoZW1lZCwgY29sb3JpemVkLCBhbmQgZXZlbiBhbmltYXRlZC5cbiAgICpcbiAgICogRXhhbXBsZTpcbiAgICpcbiAgICogICAgIDxpcm9uLWljb25zZXQtc3ZnIG5hbWU9XCJteS1zdmctaWNvbnNcIiBzaXplPVwiMjRcIj5cbiAgICogICAgICAgPHN2Zz5cbiAgICogICAgICAgICA8ZGVmcz5cbiAgICogICAgICAgICAgIDxnIGlkPVwic2hhcGVcIj5cbiAgICogICAgICAgICAgICAgPHJlY3QgeD1cIjEyXCIgeT1cIjBcIiB3aWR0aD1cIjEyXCIgaGVpZ2h0PVwiMjRcIiAvPlxuICAgKiAgICAgICAgICAgICA8Y2lyY2xlIGN4PVwiMTJcIiBjeT1cIjEyXCIgcj1cIjEyXCIgLz5cbiAgICogICAgICAgICAgIDwvZz5cbiAgICogICAgICAgICA8L2RlZnM+XG4gICAqICAgICAgIDwvc3ZnPlxuICAgKiAgICAgPC9pcm9uLWljb25zZXQtc3ZnPlxuICAgKlxuICAgKiBUaGlzIHdpbGwgYXV0b21hdGljYWxseSByZWdpc3RlciB0aGUgaWNvbiBzZXQgXCJteS1zdmctaWNvbnNcIiB0byB0aGUgaWNvbnNldFxuICAgKiBkYXRhYmFzZS4gIFRvIHVzZSB0aGVzZSBpY29ucyBmcm9tIHdpdGhpbiBhbm90aGVyIGVsZW1lbnQsIG1ha2UgYVxuICAgKiBgaXJvbi1pY29uc2V0YCBlbGVtZW50IGFuZCBjYWxsIHRoZSBgYnlJZGAgbWV0aG9kXG4gICAqIHRvIHJldHJpZXZlIGEgZ2l2ZW4gaWNvbnNldC4gVG8gYXBwbHkgYSBwYXJ0aWN1bGFyIGljb24gaW5zaWRlIGFuXG4gICAqIGVsZW1lbnQgdXNlIHRoZSBgYXBwbHlJY29uYCBtZXRob2QuIEZvciBleGFtcGxlOlxuICAgKlxuICAgKiAgICAgaWNvbnNldC5hcHBseUljb24oaWNvbk5vZGUsICdjYXInKTtcbiAgICpcbiAgICogQGVsZW1lbnQgaXJvbi1pY29uc2V0LXN2Z1xuICAgKiBAZGVtbyBkZW1vL2luZGV4Lmh0bWxcbiAgICogQGltcGxlbWVudHMge1BvbHltZXIuSWNvbnNldH1cbiAgICovXG4gIFBvbHltZXIoe1xuICAgIGlzOiAnaXJvbi1pY29uc2V0LXN2ZycsXG5cbiAgICBwcm9wZXJ0aWVzOiB7XG5cbiAgICAgIC8qKlxuICAgICAgICogVGhlIG5hbWUgb2YgdGhlIGljb25zZXQuXG4gICAgICAgKi9cbiAgICAgIG5hbWU6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICBvYnNlcnZlcjogJ19uYW1lQ2hhbmdlZCdcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogVGhlIHNpemUgb2YgYW4gaW5kaXZpZHVhbCBpY29uLiBOb3RlIHRoYXQgaWNvbnMgbXVzdCBiZSBzcXVhcmUuXG4gICAgICAgKi9cbiAgICAgIHNpemU6IHtcbiAgICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgICB2YWx1ZTogMjRcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogU2V0IHRvIHRydWUgdG8gZW5hYmxlIG1pcnJvcmluZyBvZiBpY29ucyB3aGVyZSBzcGVjaWZpZWQgd2hlbiB0aGV5IGFyZVxuICAgICAgICogc3RhbXBlZC4gSWNvbnMgdGhhdCBzaG91bGQgYmUgbWlycm9yZWQgc2hvdWxkIGJlIGRlY29yYXRlZCB3aXRoIGFcbiAgICAgICAqIGBtaXJyb3ItaW4tcnRsYCBhdHRyaWJ1dGUuXG4gICAgICAgKlxuICAgICAgICogTk9URTogRm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMsIGRpcmVjdGlvbiB3aWxsIGJlIHJlc29sdmVkIG9uY2UgcGVyXG4gICAgICAgKiBkb2N1bWVudCBwZXIgaWNvbnNldCwgc28gbW92aW5nIGljb25zIGluIGFuZCBvdXQgb2YgUlRMIHN1YnRyZWVzIHdpbGxcbiAgICAgICAqIG5vdCBjYXVzZSB0aGVpciBtaXJyb3JlZCBzdGF0ZSB0byBjaGFuZ2UuXG4gICAgICAgKi9cbiAgICAgIHJ0bE1pcnJvcmluZzoge1xuICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogU2V0IHRvIHRydWUgdG8gbWVhc3VyZSBSVEwgYmFzZWQgb24gdGhlIGRpciBhdHRyaWJ1dGUgb24gdGhlIGJvZHkgb3JcbiAgICAgICAqIGh0bWwgZWxlbWVudHMgKG1lYXN1cmVkIG9uIGRvY3VtZW50LmJvZHkgb3IgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50IGFzXG4gICAgICAgKiBhdmFpbGFibGUpLlxuICAgICAgICovXG4gICAgICB1c2VHbG9iYWxSdGxBdHRyaWJ1dGU6IHtcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICB9XG4gICAgfSxcblxuICAgIGNyZWF0ZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fbWV0YSA9IG5ldyBQb2x5bWVyLklyb25NZXRhKHt0eXBlOiAnaWNvbnNldCcsIGtleTogbnVsbCwgdmFsdWU6IG51bGx9KTtcbiAgICB9LFxuXG4gICAgYXR0YWNoZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYW4gYXJyYXkgb2YgYWxsIGljb24gbmFtZXMgaW4gdGhpcyBpY29uc2V0LlxuICAgICAqXG4gICAgICogQHJldHVybiB7IUFycmF5fSBBcnJheSBvZiBpY29uIG5hbWVzLlxuICAgICAqL1xuICAgIGdldEljb25OYW1lczogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9pY29ucyA9IHRoaXMuX2NyZWF0ZUljb25NYXAoKTtcbiAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLl9pY29ucykubWFwKGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmFtZSArICc6JyArIG47XG4gICAgICB9LCB0aGlzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQXBwbGllcyBhbiBpY29uIHRvIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogQW4gc3ZnIGljb24gaXMgcHJlcGVuZGVkIHRvIHRoZSBlbGVtZW50J3Mgc2hhZG93Um9vdCBpZiBpdCBleGlzdHMsXG4gICAgICogb3RoZXJ3aXNlIHRvIHRoZSBlbGVtZW50IGl0c2VsZi5cbiAgICAgKlxuICAgICAqIElmIFJUTCBtaXJyb3JpbmcgaXMgZW5hYmxlZCwgYW5kIHRoZSBpY29uIGlzIG1hcmtlZCB0byBiZSBtaXJyb3JlZCBpblxuICAgICAqIFJUTCwgdGhlIGVsZW1lbnQgd2lsbCBiZSB0ZXN0ZWQgKG9uY2UgYW5kIG9ubHkgb25jZSBldmVyIGZvciBlYWNoXG4gICAgICogaWNvbnNldCkgdG8gZGV0ZXJtaW5lIHRoZSBkaXJlY3Rpb24gb2YgdGhlIHN1YnRyZWUgdGhlIGVsZW1lbnQgaXMgaW4uXG4gICAgICogVGhpcyBkaXJlY3Rpb24gd2lsbCBhcHBseSB0byBhbGwgZnV0dXJlIGljb24gYXBwbGljYXRpb25zLCBhbHRob3VnaCBvbmx5XG4gICAgICogaWNvbnMgbWFya2VkIHRvIGJlIG1pcnJvcmVkIHdpbGwgYmUgYWZmZWN0ZWQuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGFwcGx5SWNvblxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRvIHdoaWNoIHRoZSBpY29uIGlzIGFwcGxpZWQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGljb25OYW1lIE5hbWUgb2YgdGhlIGljb24gdG8gYXBwbHkuXG4gICAgICogQHJldHVybiB7P0VsZW1lbnR9IFRoZSBzdmcgZWxlbWVudCB3aGljaCByZW5kZXJzIHRoZSBpY29uLlxuICAgICAqL1xuICAgIGFwcGx5SWNvbjogZnVuY3Rpb24oZWxlbWVudCwgaWNvbk5hbWUpIHtcbiAgICAgIC8vIFJlbW92ZSBvbGQgc3ZnIGVsZW1lbnRcbiAgICAgIHRoaXMucmVtb3ZlSWNvbihlbGVtZW50KTtcbiAgICAgIC8vIGluc3RhbGwgbmV3IHN2ZyBlbGVtZW50XG4gICAgICB2YXIgc3ZnID0gdGhpcy5fY2xvbmVJY29uKGljb25OYW1lLFxuICAgICAgICAgIHRoaXMucnRsTWlycm9yaW5nICYmIHRoaXMuX3RhcmdldElzUlRMKGVsZW1lbnQpKTtcbiAgICAgIGlmIChzdmcpIHtcbiAgICAgICAgLy8gaW5zZXJ0IHN2ZyBlbGVtZW50IGludG8gc2hhZG93IHJvb3QsIGlmIGl0IGV4aXN0c1xuICAgICAgICB2YXIgcGRlID0gUG9seW1lci5kb20oZWxlbWVudC5yb290IHx8IGVsZW1lbnQpO1xuICAgICAgICBwZGUuaW5zZXJ0QmVmb3JlKHN2ZywgcGRlLmNoaWxkTm9kZXNbMF0pO1xuICAgICAgICByZXR1cm4gZWxlbWVudC5fc3ZnSWNvbiA9IHN2ZztcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYW4gaWNvbiBmcm9tIHRoZSBnaXZlbiBlbGVtZW50IGJ5IHVuZG9pbmcgdGhlIGNoYW5nZXMgZWZmZWN0ZWRcbiAgICAgKiBieSBgYXBwbHlJY29uYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCBUaGUgZWxlbWVudCBmcm9tIHdoaWNoIHRoZSBpY29uIGlzIHJlbW92ZWQuXG4gICAgICovXG4gICAgcmVtb3ZlSWNvbjogZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgLy8gUmVtb3ZlIG9sZCBzdmcgZWxlbWVudFxuICAgICAgaWYgKGVsZW1lbnQuX3N2Z0ljb24pIHtcbiAgICAgICAgUG9seW1lci5kb20oZWxlbWVudC5yb290IHx8IGVsZW1lbnQpLnJlbW92ZUNoaWxkKGVsZW1lbnQuX3N2Z0ljb24pO1xuICAgICAgICBlbGVtZW50Ll9zdmdJY29uID0gbnVsbDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWVhc3VyZXMgYW5kIG1lbW9pemVzIHRoZSBkaXJlY3Rpb24gb2YgdGhlIGVsZW1lbnQuIE5vdGUgdGhhdCB0aGlzXG4gICAgICogbWVhc3VyZW1lbnQgaXMgb25seSBkb25lIG9uY2UgYW5kIHRoZSByZXN1bHQgaXMgbWVtb2l6ZWQgZm9yIGZ1dHVyZVxuICAgICAqIGludm9jYXRpb25zLlxuICAgICAqL1xuICAgIF90YXJnZXRJc1JUTDogZnVuY3Rpb24odGFyZ2V0KSB7XG4gICAgICBpZiAodGhpcy5fX3RhcmdldElzUlRMID09IG51bGwpIHtcbiAgICAgICAgaWYgKHRoaXMudXNlR2xvYmFsUnRsQXR0cmlidXRlKSB7XG4gICAgICAgICAgdmFyIGdsb2JhbEVsZW1lbnQgPVxuICAgICAgICAgICAgICAoZG9jdW1lbnQuYm9keSAmJiBkb2N1bWVudC5ib2R5Lmhhc0F0dHJpYnV0ZSgnZGlyJykpXG4gICAgICAgICAgICAgICAgICA/IGRvY3VtZW50LmJvZHlcbiAgICAgICAgICAgICAgICAgIDogZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXG4gICAgICAgICAgdGhpcy5fX3RhcmdldElzUlRMID0gZ2xvYmFsRWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RpcicpID09PSAncnRsJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodGFyZ2V0ICYmIHRhcmdldC5ub2RlVHlwZSAhPT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgICAgIHRhcmdldCA9IHRhcmdldC5ob3N0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuX190YXJnZXRJc1JUTCA9IHRhcmdldCAmJlxuICAgICAgICAgICAgICB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0YXJnZXQpWydkaXJlY3Rpb24nXSA9PT0gJ3J0bCc7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuX190YXJnZXRJc1JUTDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBXaGVuIG5hbWUgaXMgY2hhbmdlZCwgcmVnaXN0ZXIgaWNvbnNldCBtZXRhZGF0YVxuICAgICAqXG4gICAgICovXG4gICAgX25hbWVDaGFuZ2VkOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX21ldGEudmFsdWUgPSBudWxsO1xuICAgICAgdGhpcy5fbWV0YS5rZXkgPSB0aGlzLm5hbWU7XG4gICAgICB0aGlzLl9tZXRhLnZhbHVlID0gdGhpcztcblxuICAgICAgdGhpcy5hc3luYyhmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5maXJlKCdpcm9uLWljb25zZXQtYWRkZWQnLCB0aGlzLCB7bm9kZTogd2luZG93fSk7XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbWFwIG9mIGNoaWxkIFNWRyBlbGVtZW50cyBieSBpZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4geyFPYmplY3R9IE1hcCBvZiBpZCdzIHRvIFNWRyBlbGVtZW50cy5cbiAgICAgKi9cbiAgICBfY3JlYXRlSWNvbk1hcDogZnVuY3Rpb24oKSB7XG4gICAgICAvLyBPYmplY3RzIGNoYWluZWQgdG8gT2JqZWN0LnByb3RvdHlwZSAoYHt9YCkgaGF2ZSBtZW1iZXJzLiBTcGVjaWZpY2FsbHksXG4gICAgICAvLyBvbiBGRiB0aGVyZSBpcyBhIGB3YXRjaGAgbWV0aG9kIHRoYXQgY29uZnVzZXMgdGhlIGljb24gbWFwLCBzbyB3ZVxuICAgICAgLy8gbmVlZCB0byB1c2UgYSBudWxsLWJhc2VkIG9iamVjdCBoZXJlLlxuICAgICAgdmFyIGljb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIFBvbHltZXIuZG9tKHRoaXMpLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tpZF0nKVxuICAgICAgICAuZm9yRWFjaChmdW5jdGlvbihpY29uKSB7XG4gICAgICAgICAgaWNvbnNbaWNvbi5pZF0gPSBpY29uO1xuICAgICAgICB9KTtcbiAgICAgIHJldHVybiBpY29ucztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUHJvZHVjZSBpbnN0YWxsYWJsZSBjbG9uZSBvZiB0aGUgU1ZHIGVsZW1lbnQgbWF0Y2hpbmcgYGlkYCBpbiB0aGlzXG4gICAgICogaWNvbnNldCwgb3IgYHVuZGVmaW5lZGAgaWYgdGhlcmUgaXMgbm8gbWF0Y2hpbmcgZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0VsZW1lbnR9IFJldHVybnMgYW4gaW5zdGFsbGFibGUgY2xvbmUgb2YgdGhlIFNWRyBlbGVtZW50XG4gICAgICogbWF0Y2hpbmcgYGlkYC5cbiAgICAgKi9cbiAgICBfY2xvbmVJY29uOiBmdW5jdGlvbihpZCwgbWlycm9yQWxsb3dlZCkge1xuICAgICAgLy8gY3JlYXRlIHRoZSBpY29uIG1hcCBvbi1kZW1hbmQsIHNpbmNlIHRoZSBpY29uc2V0IGl0c2VsZiBoYXMgbm8gZGlzY3JldGVcbiAgICAgIC8vIHNpZ25hbCB0byBrbm93IHdoZW4gaXQncyBjaGlsZHJlbiBhcmUgZnVsbHkgcGFyc2VkXG4gICAgICB0aGlzLl9pY29ucyA9IHRoaXMuX2ljb25zIHx8IHRoaXMuX2NyZWF0ZUljb25NYXAoKTtcbiAgICAgIHJldHVybiB0aGlzLl9wcmVwYXJlU3ZnQ2xvbmUodGhpcy5faWNvbnNbaWRdLCB0aGlzLnNpemUsIG1pcnJvckFsbG93ZWQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IHNvdXJjZVN2Z1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzaXplXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBtaXJyb3JBbGxvd2VkXG4gICAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICAgKi9cbiAgICBfcHJlcGFyZVN2Z0Nsb25lOiBmdW5jdGlvbihzb3VyY2VTdmcsIHNpemUsIG1pcnJvckFsbG93ZWQpIHtcbiAgICAgIGlmIChzb3VyY2VTdmcpIHtcbiAgICAgICAgdmFyIGNvbnRlbnQgPSBzb3VyY2VTdmcuY2xvbmVOb2RlKHRydWUpLFxuICAgICAgICAgICAgc3ZnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsICdzdmcnKSxcbiAgICAgICAgICAgIHZpZXdCb3ggPSBjb250ZW50LmdldEF0dHJpYnV0ZSgndmlld0JveCcpIHx8ICcwIDAgJyArIHNpemUgKyAnICcgKyBzaXplLFxuICAgICAgICAgICAgY3NzVGV4dCA9ICdwb2ludGVyLWV2ZW50czogbm9uZTsgZGlzcGxheTogYmxvY2s7IHdpZHRoOiAxMDAlOyBoZWlnaHQ6IDEwMCU7JztcblxuICAgICAgICBpZiAobWlycm9yQWxsb3dlZCAmJiBjb250ZW50Lmhhc0F0dHJpYnV0ZSgnbWlycm9yLWluLXJ0bCcpKSB7XG4gICAgICAgICAgY3NzVGV4dCArPSAnLXdlYmtpdC10cmFuc2Zvcm06c2NhbGUoLTEsMSk7dHJhbnNmb3JtOnNjYWxlKC0xLDEpOyc7XG4gICAgICAgIH1cblxuICAgICAgICBzdmcuc2V0QXR0cmlidXRlKCd2aWV3Qm94Jywgdmlld0JveCk7XG4gICAgICAgIHN2Zy5zZXRBdHRyaWJ1dGUoJ3ByZXNlcnZlQXNwZWN0UmF0aW8nLCAneE1pZFlNaWQgbWVldCcpO1xuICAgICAgICBzdmcuc2V0QXR0cmlidXRlKCdmb2N1c2FibGUnLCAnZmFsc2UnKTtcbiAgICAgICAgLy8gVE9ETyhkZnJlZWRtKTogYHBvaW50ZXItZXZlbnRzOiBub25lYCB3b3JrcyBhcm91bmQgaHR0cHM6Ly9jcmJ1Zy5jb20vMzcwMTM2XG4gICAgICAgIC8vIFRPRE8oc2ptaWxlcyk6IGlubGluZSBzdHlsZSBtYXkgbm90IGJlIGlkZWFsLCBidXQgYXZvaWRzIHJlcXVpcmluZyBhIHNoYWRvdy1yb290XG4gICAgICAgIHN2Zy5zdHlsZS5jc3NUZXh0ID0gY3NzVGV4dDtcbiAgICAgICAgc3ZnLmFwcGVuZENoaWxkKGNvbnRlbnQpLnJlbW92ZUF0dHJpYnV0ZSgnaWQnKTtcbiAgICAgICAgcmV0dXJuIHN2ZztcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICB9KTtcblxuPC9zY3JpcHQ+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL2lyb24taWNvbnNldC1zdmcvaXJvbi1pY29uc2V0LXN2Zy5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNiBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuXG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vcG9seW1lci9wb2x5bWVyLmh0bWxcIj5cblxuPHNjcmlwdD5cblxuICAvKipcbiAgICogYFBvbHltZXIuSXJvblNjcm9sbFRhcmdldEJlaGF2aW9yYCBhbGxvd3MgYW4gZWxlbWVudCB0byByZXNwb25kIHRvIHNjcm9sbCBldmVudHMgZnJvbSBhXG4gICAqIGRlc2lnbmF0ZWQgc2Nyb2xsIHRhcmdldC5cbiAgICpcbiAgICogRWxlbWVudHMgdGhhdCBjb25zdW1lIHRoaXMgYmVoYXZpb3IgY2FuIG92ZXJyaWRlIHRoZSBgX3Njcm9sbEhhbmRsZXJgXG4gICAqIG1ldGhvZCB0byBhZGQgbG9naWMgb24gdGhlIHNjcm9sbCBldmVudC5cbiAgICpcbiAgICogQGRlbW8gZGVtby9zY3JvbGxpbmctcmVnaW9uLmh0bWwgU2Nyb2xsaW5nIFJlZ2lvblxuICAgKiBAZGVtbyBkZW1vL2RvY3VtZW50Lmh0bWwgRG9jdW1lbnQgRWxlbWVudFxuICAgKiBAcG9seW1lckJlaGF2aW9yXG4gICAqL1xuICBQb2x5bWVyLklyb25TY3JvbGxUYXJnZXRCZWhhdmlvciA9IHtcblxuICAgIHByb3BlcnRpZXM6IHtcblxuICAgICAgLyoqXG4gICAgICAgKiBTcGVjaWZpZXMgdGhlIGVsZW1lbnQgdGhhdCB3aWxsIGhhbmRsZSB0aGUgc2Nyb2xsIGV2ZW50XG4gICAgICAgKiBvbiB0aGUgYmVoYWxmIG9mIHRoZSBjdXJyZW50IGVsZW1lbnQuIFRoaXMgaXMgdHlwaWNhbGx5IGEgcmVmZXJlbmNlIHRvIGFuIGVsZW1lbnQsXG4gICAgICAgKiBidXQgdGhlcmUgYXJlIGEgZmV3IG1vcmUgcG9zaWJpbGl0aWVzOlxuICAgICAgICpcbiAgICAgICAqICMjIyBFbGVtZW50cyBpZFxuICAgICAgICpcbiAgICAgICAqYGBgaHRtbFxuICAgICAgICogPGRpdiBpZD1cInNjcm9sbGFibGUtZWxlbWVudFwiIHN0eWxlPVwib3ZlcmZsb3c6IGF1dG87XCI+XG4gICAgICAgKiAgPHgtZWxlbWVudCBzY3JvbGwtdGFyZ2V0PVwic2Nyb2xsYWJsZS1lbGVtZW50XCI+XG4gICAgICAgKiAgICA8IS0tIENvbnRlbnQtLT5cbiAgICAgICAqICA8L3gtZWxlbWVudD5cbiAgICAgICAqIDwvZGl2PlxuICAgICAgICpgYGBcbiAgICAgICAqIEluIHRoaXMgY2FzZSwgdGhlIGBzY3JvbGxUYXJnZXRgIHdpbGwgcG9pbnQgdG8gdGhlIG91dGVyIGRpdiBlbGVtZW50LlxuICAgICAgICpcbiAgICAgICAqICMjIyBEb2N1bWVudCBzY3JvbGxpbmdcbiAgICAgICAqXG4gICAgICAgKiBGb3IgZG9jdW1lbnQgc2Nyb2xsaW5nLCB5b3UgY2FuIHVzZSB0aGUgcmVzZXJ2ZWQgd29yZCBgZG9jdW1lbnRgOlxuICAgICAgICpcbiAgICAgICAqYGBgaHRtbFxuICAgICAgICogPHgtZWxlbWVudCBzY3JvbGwtdGFyZ2V0PVwiZG9jdW1lbnRcIj5cbiAgICAgICAqICAgPCEtLSBDb250ZW50IC0tPlxuICAgICAgICogPC94LWVsZW1lbnQ+XG4gICAgICAgKmBgYFxuICAgICAgICpcbiAgICAgICAqICMjIyBFbGVtZW50cyByZWZlcmVuY2VcbiAgICAgICAqXG4gICAgICAgKmBgYGpzXG4gICAgICAgKiBhcHBIZWFkZXIuc2Nyb2xsVGFyZ2V0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3Njcm9sbGFibGUtZWxlbWVudCcpO1xuICAgICAgICpgYGBcbiAgICAgICAqXG4gICAgICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAgICAgKiBAZGVmYXVsdCBkb2N1bWVudFxuICAgICAgICovXG4gICAgICBzY3JvbGxUYXJnZXQ6IHtcbiAgICAgICAgdHlwZTogSFRNTEVsZW1lbnQsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fZGVmYXVsdFNjcm9sbFRhcmdldDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBvYnNlcnZlcnM6IFtcbiAgICAgICdfc2Nyb2xsVGFyZ2V0Q2hhbmdlZChzY3JvbGxUYXJnZXQsIGlzQXR0YWNoZWQpJ1xuICAgIF0sXG5cbiAgICAvKipcbiAgICAgKiBUcnVlIGlmIHRoZSBldmVudCBsaXN0ZW5lciBzaG91bGQgYmUgaW5zdGFsbGVkLlxuICAgICAqL1xuICAgIF9zaG91bGRIYXZlTGlzdGVuZXI6IHRydWUsXG5cbiAgICBfc2Nyb2xsVGFyZ2V0Q2hhbmdlZDogZnVuY3Rpb24oc2Nyb2xsVGFyZ2V0LCBpc0F0dGFjaGVkKSB7XG4gICAgICB2YXIgZXZlbnRUYXJnZXQ7XG5cbiAgICAgIGlmICh0aGlzLl9vbGRTY3JvbGxUYXJnZXQpIHtcbiAgICAgICAgdGhpcy5fdG9nZ2xlU2Nyb2xsTGlzdGVuZXIoZmFsc2UsIHRoaXMuX29sZFNjcm9sbFRhcmdldCk7XG4gICAgICAgIHRoaXMuX29sZFNjcm9sbFRhcmdldCA9IG51bGw7XG4gICAgICB9XG4gICAgICBpZiAoIWlzQXR0YWNoZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gU3VwcG9ydCBlbGVtZW50IGlkIHJlZmVyZW5jZXNcbiAgICAgIGlmIChzY3JvbGxUYXJnZXQgPT09ICdkb2N1bWVudCcpIHtcblxuICAgICAgICB0aGlzLnNjcm9sbFRhcmdldCA9IHRoaXMuX2RvYztcblxuICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygc2Nyb2xsVGFyZ2V0ID09PSAnc3RyaW5nJykge1xuXG4gICAgICAgIHZhciBkb21Ib3N0ID0gdGhpcy5kb21Ib3N0O1xuXG4gICAgICAgIHRoaXMuc2Nyb2xsVGFyZ2V0ID0gZG9tSG9zdCAmJiBkb21Ib3N0LiQgPyBkb21Ib3N0LiRbc2Nyb2xsVGFyZ2V0XSA6XG4gICAgICAgICAgICBQb2x5bWVyLmRvbSh0aGlzLm93bmVyRG9jdW1lbnQpLnF1ZXJ5U2VsZWN0b3IoJyMnICsgc2Nyb2xsVGFyZ2V0KTtcblxuICAgICAgfSBlbHNlIGlmICh0aGlzLl9pc1ZhbGlkU2Nyb2xsVGFyZ2V0KCkpIHtcblxuICAgICAgICB0aGlzLl9vbGRTY3JvbGxUYXJnZXQgPSBzY3JvbGxUYXJnZXQ7XG4gICAgICAgIHRoaXMuX3RvZ2dsZVNjcm9sbExpc3RlbmVyKHRoaXMuX3Nob3VsZEhhdmVMaXN0ZW5lciwgc2Nyb2xsVGFyZ2V0KTtcblxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSdW5zIG9uIGV2ZXJ5IHNjcm9sbCBldmVudC4gQ29uc3VtZXIgb2YgdGhpcyBiZWhhdmlvciBtYXkgb3ZlcnJpZGUgdGhpcyBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX3Njcm9sbEhhbmRsZXI6IGZ1bmN0aW9uIHNjcm9sbEhhbmRsZXIoKSB7fSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBkZWZhdWx0IHNjcm9sbCB0YXJnZXQuIENvbnN1bWVycyBvZiB0aGlzIGJlaGF2aW9yIG1heSB3YW50IHRvIGN1c3RvbWl6ZVxuICAgICAqIHRoZSBkZWZhdWx0IHNjcm9sbCB0YXJnZXQuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7RWxlbWVudH1cbiAgICAgKi9cbiAgICBnZXQgX2RlZmF1bHRTY3JvbGxUYXJnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZG9jO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTaG9ydGN1dCBmb3IgdGhlIGRvY3VtZW50IGVsZW1lbnRcbiAgICAgKlxuICAgICAqIEB0eXBlIHtFbGVtZW50fVxuICAgICAqL1xuICAgIGdldCBfZG9jKCkge1xuICAgICAgcmV0dXJuIHRoaXMub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG51bWJlciBvZiBwaXhlbHMgdGhhdCB0aGUgY29udGVudCBvZiBhbiBlbGVtZW50IGlzIHNjcm9sbGVkIHVwd2FyZC5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IF9zY3JvbGxUb3AoKSB7XG4gICAgICBpZiAodGhpcy5faXNWYWxpZFNjcm9sbFRhcmdldCgpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjcm9sbFRhcmdldCA9PT0gdGhpcy5fZG9jID8gd2luZG93LnBhZ2VZT2Zmc2V0IDogdGhpcy5zY3JvbGxUYXJnZXQuc2Nyb2xsVG9wO1xuICAgICAgfVxuICAgICAgcmV0dXJuIDA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG51bWJlciBvZiBwaXhlbHMgdGhhdCB0aGUgY29udGVudCBvZiBhbiBlbGVtZW50IGlzIHNjcm9sbGVkIHRvIHRoZSBsZWZ0LlxuICAgICAqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgX3Njcm9sbExlZnQoKSB7XG4gICAgICBpZiAodGhpcy5faXNWYWxpZFNjcm9sbFRhcmdldCgpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjcm9sbFRhcmdldCA9PT0gdGhpcy5fZG9jID8gd2luZG93LnBhZ2VYT2Zmc2V0IDogdGhpcy5zY3JvbGxUYXJnZXQuc2Nyb2xsTGVmdDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBudW1iZXIgb2YgcGl4ZWxzIHRoYXQgdGhlIGNvbnRlbnQgb2YgYW4gZWxlbWVudCBpcyBzY3JvbGxlZCB1cHdhcmQuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHNldCBfc2Nyb2xsVG9wKHRvcCkge1xuICAgICAgaWYgKHRoaXMuc2Nyb2xsVGFyZ2V0ID09PSB0aGlzLl9kb2MpIHtcbiAgICAgICAgd2luZG93LnNjcm9sbFRvKHdpbmRvdy5wYWdlWE9mZnNldCwgdG9wKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5faXNWYWxpZFNjcm9sbFRhcmdldCgpKSB7XG4gICAgICAgIHRoaXMuc2Nyb2xsVGFyZ2V0LnNjcm9sbFRvcCA9IHRvcDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgbnVtYmVyIG9mIHBpeGVscyB0aGF0IHRoZSBjb250ZW50IG9mIGFuIGVsZW1lbnQgaXMgc2Nyb2xsZWQgdG8gdGhlIGxlZnQuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHNldCBfc2Nyb2xsTGVmdChsZWZ0KSB7XG4gICAgICBpZiAodGhpcy5zY3JvbGxUYXJnZXQgPT09IHRoaXMuX2RvYykge1xuICAgICAgICB3aW5kb3cuc2Nyb2xsVG8obGVmdCwgd2luZG93LnBhZ2VZT2Zmc2V0KTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5faXNWYWxpZFNjcm9sbFRhcmdldCgpKSB7XG4gICAgICAgIHRoaXMuc2Nyb2xsVGFyZ2V0LnNjcm9sbExlZnQgPSBsZWZ0O1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTY3JvbGxzIHRoZSBjb250ZW50IHRvIGEgcGFydGljdWxhciBwbGFjZS5cbiAgICAgKlxuICAgICAqIEBtZXRob2Qgc2Nyb2xsXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxlZnQgVGhlIGxlZnQgcG9zaXRpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdG9wIFRoZSB0b3AgcG9zaXRpb25cbiAgICAgKi9cbiAgICBzY3JvbGw6IGZ1bmN0aW9uKGxlZnQsIHRvcCkge1xuICAgICAgIGlmICh0aGlzLnNjcm9sbFRhcmdldCA9PT0gdGhpcy5fZG9jKSB7XG4gICAgICAgIHdpbmRvdy5zY3JvbGxUbyhsZWZ0LCB0b3ApO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl9pc1ZhbGlkU2Nyb2xsVGFyZ2V0KCkpIHtcbiAgICAgICAgdGhpcy5zY3JvbGxUYXJnZXQuc2Nyb2xsTGVmdCA9IGxlZnQ7XG4gICAgICAgIHRoaXMuc2Nyb2xsVGFyZ2V0LnNjcm9sbFRvcCA9IHRvcDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgd2lkdGggb2YgdGhlIHNjcm9sbCB0YXJnZXQuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldCBfc2Nyb2xsVGFyZ2V0V2lkdGgoKSB7XG4gICAgICBpZiAodGhpcy5faXNWYWxpZFNjcm9sbFRhcmdldCgpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjcm9sbFRhcmdldCA9PT0gdGhpcy5fZG9jID8gd2luZG93LmlubmVyV2lkdGggOiB0aGlzLnNjcm9sbFRhcmdldC5vZmZzZXRXaWR0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBoZWlnaHQgb2YgdGhlIHNjcm9sbCB0YXJnZXQuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldCBfc2Nyb2xsVGFyZ2V0SGVpZ2h0KCkge1xuICAgICAgaWYgKHRoaXMuX2lzVmFsaWRTY3JvbGxUYXJnZXQoKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zY3JvbGxUYXJnZXQgPT09IHRoaXMuX2RvYyA/IHdpbmRvdy5pbm5lckhlaWdodCA6IHRoaXMuc2Nyb2xsVGFyZ2V0Lm9mZnNldEhlaWdodDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHNjcm9sbCB0YXJnZXQgaXMgYSB2YWxpZCBIVE1MRWxlbWVudC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgX2lzVmFsaWRTY3JvbGxUYXJnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2Nyb2xsVGFyZ2V0IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQ7XG4gICAgfSxcblxuICAgIF90b2dnbGVTY3JvbGxMaXN0ZW5lcjogZnVuY3Rpb24oeWVzLCBzY3JvbGxUYXJnZXQpIHtcbiAgICAgIHZhciBldmVudFRhcmdldCA9IHNjcm9sbFRhcmdldCA9PT0gdGhpcy5fZG9jID8gd2luZG93IDogc2Nyb2xsVGFyZ2V0O1xuICAgICAgaWYgKHllcykge1xuICAgICAgICBpZiAoIXRoaXMuX2JvdW5kU2Nyb2xsSGFuZGxlcikge1xuICAgICAgICAgIHRoaXMuX2JvdW5kU2Nyb2xsSGFuZGxlciA9IHRoaXMuX3Njcm9sbEhhbmRsZXIuYmluZCh0aGlzKTtcbiAgICAgICAgICBldmVudFRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLl9ib3VuZFNjcm9sbEhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5fYm91bmRTY3JvbGxIYW5kbGVyKSB7XG4gICAgICAgICAgZXZlbnRUYXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy5fYm91bmRTY3JvbGxIYW5kbGVyKTtcbiAgICAgICAgICB0aGlzLl9ib3VuZFNjcm9sbEhhbmRsZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIHNjcm9sbCBldmVudCBsaXN0ZW5lci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0geWVzIFRydWUgdG8gYWRkIHRoZSBldmVudCwgRmFsc2UgdG8gcmVtb3ZlIGl0LlxuICAgICAqL1xuICAgIHRvZ2dsZVNjcm9sbExpc3RlbmVyOiBmdW5jdGlvbih5ZXMpIHtcbiAgICAgIHRoaXMuX3Nob3VsZEhhdmVMaXN0ZW5lciA9IHllcztcbiAgICAgIHRoaXMuX3RvZ2dsZVNjcm9sbExpc3RlbmVyKHllcywgdGhpcy5zY3JvbGxUYXJnZXQpO1xuICAgIH1cblxuICB9O1xuXG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvaXJvbi1zY3JvbGwtdGFyZ2V0LWJlaGF2aW9yL2lyb24tc2Nyb2xsLXRhcmdldC1iZWhhdmlvci5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNSBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuXG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vcG9seW1lci9wb2x5bWVyLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi9pcm9uLWExMXkta2V5cy1iZWhhdmlvci9pcm9uLWExMXkta2V5cy1iZWhhdmlvci5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiaXJvbi1jb250cm9sLXN0YXRlLmh0bWxcIj5cblxuPHNjcmlwdD5cblxuICAvKipcbiAgICogQGRlbW8gZGVtby9pbmRleC5odG1sXG4gICAqIEBwb2x5bWVyQmVoYXZpb3IgUG9seW1lci5Jcm9uQnV0dG9uU3RhdGVcbiAgICovXG4gIFBvbHltZXIuSXJvbkJ1dHRvblN0YXRlSW1wbCA9IHtcblxuICAgIHByb3BlcnRpZXM6IHtcblxuICAgICAgLyoqXG4gICAgICAgKiBJZiB0cnVlLCB0aGUgdXNlciBpcyBjdXJyZW50bHkgaG9sZGluZyBkb3duIHRoZSBidXR0b24uXG4gICAgICAgKi9cbiAgICAgIHByZXNzZWQ6IHtcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgcmVhZE9ubHk6IHRydWUsXG4gICAgICAgIHZhbHVlOiBmYWxzZSxcbiAgICAgICAgcmVmbGVjdFRvQXR0cmlidXRlOiB0cnVlLFxuICAgICAgICBvYnNlcnZlcjogJ19wcmVzc2VkQ2hhbmdlZCdcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogSWYgdHJ1ZSwgdGhlIGJ1dHRvbiB0b2dnbGVzIHRoZSBhY3RpdmUgc3RhdGUgd2l0aCBlYWNoIHRhcCBvciBwcmVzc1xuICAgICAgICogb2YgdGhlIHNwYWNlYmFyLlxuICAgICAgICovXG4gICAgICB0b2dnbGVzOiB7XG4gICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgIHZhbHVlOiBmYWxzZSxcbiAgICAgICAgcmVmbGVjdFRvQXR0cmlidXRlOiB0cnVlXG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIElmIHRydWUsIHRoZSBidXR0b24gaXMgYSB0b2dnbGUgYW5kIGlzIGN1cnJlbnRseSBpbiB0aGUgYWN0aXZlIHN0YXRlLlxuICAgICAgICovXG4gICAgICBhY3RpdmU6IHtcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgdmFsdWU6IGZhbHNlLFxuICAgICAgICBub3RpZnk6IHRydWUsXG4gICAgICAgIHJlZmxlY3RUb0F0dHJpYnV0ZTogdHJ1ZVxuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBUcnVlIGlmIHRoZSBlbGVtZW50IGlzIGN1cnJlbnRseSBiZWluZyBwcmVzc2VkIGJ5IGEgXCJwb2ludGVyLFwiIHdoaWNoXG4gICAgICAgKiBpcyBsb29zZWx5IGRlZmluZWQgYXMgbW91c2Ugb3IgdG91Y2ggaW5wdXQgKGJ1dCBzcGVjaWZpY2FsbHkgZXhjbHVkaW5nXG4gICAgICAgKiBrZXlib2FyZCBpbnB1dCkuXG4gICAgICAgKi9cbiAgICAgIHBvaW50ZXJEb3duOiB7XG4gICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgIHJlYWRPbmx5OiB0cnVlLFxuICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogVHJ1ZSBpZiB0aGUgaW5wdXQgZGV2aWNlIHRoYXQgY2F1c2VkIHRoZSBlbGVtZW50IHRvIHJlY2VpdmUgZm9jdXNcbiAgICAgICAqIHdhcyBhIGtleWJvYXJkLlxuICAgICAgICovXG4gICAgICByZWNlaXZlZEZvY3VzRnJvbUtleWJvYXJkOiB7XG4gICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgIHJlYWRPbmx5OiB0cnVlXG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFRoZSBhcmlhIGF0dHJpYnV0ZSB0byBiZSBzZXQgaWYgdGhlIGJ1dHRvbiBpcyBhIHRvZ2dsZSBhbmQgaW4gdGhlXG4gICAgICAgKiBhY3RpdmUgc3RhdGUuXG4gICAgICAgKi9cbiAgICAgIGFyaWFBY3RpdmVBdHRyaWJ1dGU6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICB2YWx1ZTogJ2FyaWEtcHJlc3NlZCcsXG4gICAgICAgIG9ic2VydmVyOiAnX2FyaWFBY3RpdmVBdHRyaWJ1dGVDaGFuZ2VkJ1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBsaXN0ZW5lcnM6IHtcbiAgICAgIGRvd246ICdfZG93bkhhbmRsZXInLFxuICAgICAgdXA6ICdfdXBIYW5kbGVyJyxcbiAgICAgIHRhcDogJ190YXBIYW5kbGVyJ1xuICAgIH0sXG5cbiAgICBvYnNlcnZlcnM6IFtcbiAgICAgICdfZm9jdXNDaGFuZ2VkKGZvY3VzZWQpJyxcbiAgICAgICdfYWN0aXZlQ2hhbmdlZChhY3RpdmUsIGFyaWFBY3RpdmVBdHRyaWJ1dGUpJ1xuICAgIF0sXG5cbiAgICBrZXlCaW5kaW5nczoge1xuICAgICAgJ2VudGVyOmtleWRvd24nOiAnX2FzeW5jQ2xpY2snLFxuICAgICAgJ3NwYWNlOmtleWRvd24nOiAnX3NwYWNlS2V5RG93bkhhbmRsZXInLFxuICAgICAgJ3NwYWNlOmtleXVwJzogJ19zcGFjZUtleVVwSGFuZGxlcicsXG4gICAgfSxcblxuICAgIF9tb3VzZUV2ZW50UmU6IC9ebW91c2UvLFxuXG4gICAgX3RhcEhhbmRsZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMudG9nZ2xlcykge1xuICAgICAgIC8vIGEgdGFwIGlzIG5lZWRlZCB0byB0b2dnbGUgdGhlIGFjdGl2ZSBzdGF0ZVxuICAgICAgICB0aGlzLl91c2VyQWN0aXZhdGUoIXRoaXMuYWN0aXZlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSxcblxuICAgIF9mb2N1c0NoYW5nZWQ6IGZ1bmN0aW9uKGZvY3VzZWQpIHtcbiAgICAgIHRoaXMuX2RldGVjdEtleWJvYXJkRm9jdXMoZm9jdXNlZCk7XG5cbiAgICAgIGlmICghZm9jdXNlZCkge1xuICAgICAgICB0aGlzLl9zZXRQcmVzc2VkKGZhbHNlKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgX2RldGVjdEtleWJvYXJkRm9jdXM6IGZ1bmN0aW9uKGZvY3VzZWQpIHtcbiAgICAgIHRoaXMuX3NldFJlY2VpdmVkRm9jdXNGcm9tS2V5Ym9hcmQoIXRoaXMucG9pbnRlckRvd24gJiYgZm9jdXNlZCk7XG4gICAgfSxcblxuICAgIC8vIHRvIGVtdWxhdGUgbmF0aXZlIGNoZWNrYm94LCAoZGUtKWFjdGl2YXRpb25zIGZyb20gYSB1c2VyIGludGVyYWN0aW9uIGZpcmVcbiAgICAvLyAnY2hhbmdlJyBldmVudHNcbiAgICBfdXNlckFjdGl2YXRlOiBmdW5jdGlvbihhY3RpdmUpIHtcbiAgICAgIGlmICh0aGlzLmFjdGl2ZSAhPT0gYWN0aXZlKSB7XG4gICAgICAgIHRoaXMuYWN0aXZlID0gYWN0aXZlO1xuICAgICAgICB0aGlzLmZpcmUoJ2NoYW5nZScpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBfZG93bkhhbmRsZXI6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICB0aGlzLl9zZXRQb2ludGVyRG93bih0cnVlKTtcbiAgICAgIHRoaXMuX3NldFByZXNzZWQodHJ1ZSk7XG4gICAgICB0aGlzLl9zZXRSZWNlaXZlZEZvY3VzRnJvbUtleWJvYXJkKGZhbHNlKTtcbiAgICB9LFxuXG4gICAgX3VwSGFuZGxlcjogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9zZXRQb2ludGVyRG93bihmYWxzZSk7XG4gICAgICB0aGlzLl9zZXRQcmVzc2VkKGZhbHNlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshS2V5Ym9hcmRFdmVudH0gZXZlbnQgLlxuICAgICAqL1xuICAgIF9zcGFjZUtleURvd25IYW5kbGVyOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgdmFyIGtleWJvYXJkRXZlbnQgPSBldmVudC5kZXRhaWwua2V5Ym9hcmRFdmVudDtcbiAgICAgIHZhciB0YXJnZXQgPSBQb2x5bWVyLmRvbShrZXlib2FyZEV2ZW50KS5sb2NhbFRhcmdldDtcblxuICAgICAgLy8gSWdub3JlIHRoZSBldmVudCBpZiB0aGlzIGlzIGNvbWluZyBmcm9tIGEgZm9jdXNlZCBsaWdodCBjaGlsZCwgc2luY2UgdGhhdFxuICAgICAgLy8gZWxlbWVudCB3aWxsIGRlYWwgd2l0aCBpdC5cbiAgICAgIGlmICh0aGlzLmlzTGlnaHREZXNjZW5kYW50KC8qKiBAdHlwZSB7Tm9kZX0gKi8odGFyZ2V0KSkpXG4gICAgICAgIHJldHVybjtcblxuICAgICAga2V5Ym9hcmRFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAga2V5Ym9hcmRFdmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgIHRoaXMuX3NldFByZXNzZWQodHJ1ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IUtleWJvYXJkRXZlbnR9IGV2ZW50IC5cbiAgICAgKi9cbiAgICBfc3BhY2VLZXlVcEhhbmRsZXI6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICB2YXIga2V5Ym9hcmRFdmVudCA9IGV2ZW50LmRldGFpbC5rZXlib2FyZEV2ZW50O1xuICAgICAgdmFyIHRhcmdldCA9IFBvbHltZXIuZG9tKGtleWJvYXJkRXZlbnQpLmxvY2FsVGFyZ2V0O1xuXG4gICAgICAvLyBJZ25vcmUgdGhlIGV2ZW50IGlmIHRoaXMgaXMgY29taW5nIGZyb20gYSBmb2N1c2VkIGxpZ2h0IGNoaWxkLCBzaW5jZSB0aGF0XG4gICAgICAvLyBlbGVtZW50IHdpbGwgZGVhbCB3aXRoIGl0LlxuICAgICAgaWYgKHRoaXMuaXNMaWdodERlc2NlbmRhbnQoLyoqIEB0eXBlIHtOb2RlfSAqLyh0YXJnZXQpKSlcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICBpZiAodGhpcy5wcmVzc2VkKSB7XG4gICAgICAgIHRoaXMuX2FzeW5jQ2xpY2soKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3NldFByZXNzZWQoZmFsc2UpO1xuICAgIH0sXG5cbiAgICAvLyB0cmlnZ2VyIGNsaWNrIGFzeW5jaHJvbm91c2x5LCB0aGUgYXN5bmNocm9ueSBpcyB1c2VmdWwgdG8gYWxsb3cgb25lXG4gICAgLy8gZXZlbnQgaGFuZGxlciB0byB1bndpbmQgYmVmb3JlIHRyaWdnZXJpbmcgYW5vdGhlciBldmVudFxuICAgIF9hc3luY0NsaWNrOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuYXN5bmMoZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuY2xpY2soKTtcbiAgICAgIH0sIDEpO1xuICAgIH0sXG5cbiAgICAvLyBhbnkgb2YgdGhlc2UgY2hhbmdlcyBhcmUgY29uc2lkZXJlZCBhIGNoYW5nZSB0byBidXR0b24gc3RhdGVcblxuICAgIF9wcmVzc2VkQ2hhbmdlZDogZnVuY3Rpb24ocHJlc3NlZCkge1xuICAgICAgdGhpcy5fY2hhbmdlZEJ1dHRvblN0YXRlKCk7XG4gICAgfSxcblxuICAgIF9hcmlhQWN0aXZlQXR0cmlidXRlQ2hhbmdlZDogZnVuY3Rpb24odmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICBpZiAob2xkVmFsdWUgJiYgb2xkVmFsdWUgIT0gdmFsdWUgJiYgdGhpcy5oYXNBdHRyaWJ1dGUob2xkVmFsdWUpKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlKG9sZFZhbHVlKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgX2FjdGl2ZUNoYW5nZWQ6IGZ1bmN0aW9uKGFjdGl2ZSwgYXJpYUFjdGl2ZUF0dHJpYnV0ZSkge1xuICAgICAgaWYgKHRoaXMudG9nZ2xlcykge1xuICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSh0aGlzLmFyaWFBY3RpdmVBdHRyaWJ1dGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZSA/ICd0cnVlJyA6ICdmYWxzZScpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGUodGhpcy5hcmlhQWN0aXZlQXR0cmlidXRlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2NoYW5nZWRCdXR0b25TdGF0ZSgpO1xuICAgIH0sXG5cbiAgICBfY29udHJvbFN0YXRlQ2hhbmdlZDogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5kaXNhYmxlZCkge1xuICAgICAgICB0aGlzLl9zZXRQcmVzc2VkKGZhbHNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2NoYW5nZWRCdXR0b25TdGF0ZSgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBwcm92aWRlIGhvb2sgZm9yIGZvbGxvdy1vbiBiZWhhdmlvcnMgdG8gcmVhY3QgdG8gYnV0dG9uLXN0YXRlXG5cbiAgICBfY2hhbmdlZEJ1dHRvblN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLl9idXR0b25TdGF0ZUNoYW5nZWQpIHtcbiAgICAgICAgdGhpcy5fYnV0dG9uU3RhdGVDaGFuZ2VkKCk7IC8vIGFic3RyYWN0XG4gICAgICB9XG4gICAgfVxuXG4gIH07XG5cbiAgLyoqIEBwb2x5bWVyQmVoYXZpb3IgKi9cbiAgUG9seW1lci5Jcm9uQnV0dG9uU3RhdGUgPSBbXG4gICAgUG9seW1lci5Jcm9uQTExeUtleXNCZWhhdmlvcixcbiAgICBQb2x5bWVyLklyb25CdXR0b25TdGF0ZUltcGxcbiAgXTtcblxuPC9zY3JpcHQ+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL2lyb24tYmVoYXZpb3JzL2lyb24tYnV0dG9uLXN0YXRlLmh0bWwiLCJcbnJlcXVpcmUoJy4uL3BvbHltZXIvcG9seW1lci5odG1sJyk7XG5cbmNvbnN0IFJlZ2lzdGVySHRtbFRlbXBsYXRlID0gcmVxdWlyZSgncG9seW1lci13ZWJwYWNrLWxvYWRlci9yZWdpc3Rlci1odG1sLXRlbXBsYXRlJyk7XG5cblJlZ2lzdGVySHRtbFRlbXBsYXRlLnRvQm9keShcIjxjdXN0b20tc3R5bGU+IDxzdHlsZSBpcz1jdXN0b20tc3R5bGU+aHRtbHstLWdvb2dsZS1yZWQtMTAwOiNmNGM3YzM7LS1nb29nbGUtcmVkLTMwMDojZTY3YzczOy0tZ29vZ2xlLXJlZC01MDA6I2RiNDQzNzstLWdvb2dsZS1yZWQtNzAwOiNjNTM5Mjk7LS1nb29nbGUtYmx1ZS0xMDA6I2M2ZGFmYzstLWdvb2dsZS1ibHVlLTMwMDojN2JhYWY3Oy0tZ29vZ2xlLWJsdWUtNTAwOiM0Mjg1ZjQ7LS1nb29nbGUtYmx1ZS03MDA6IzMzNjdkNjstLWdvb2dsZS1ncmVlbi0xMDA6I2I3ZTFjZDstLWdvb2dsZS1ncmVlbi0zMDA6IzU3YmI4YTstLWdvb2dsZS1ncmVlbi01MDA6IzBmOWQ1ODstLWdvb2dsZS1ncmVlbi03MDA6IzBiODA0MzstLWdvb2dsZS15ZWxsb3ctMTAwOiNmY2U4YjI7LS1nb29nbGUteWVsbG93LTMwMDojZjdjYjRkOy0tZ29vZ2xlLXllbGxvdy01MDA6I2Y0YjQwMDstLWdvb2dsZS15ZWxsb3ctNzAwOiNmMDkzMDA7LS1nb29nbGUtZ3JleS0xMDA6I2Y1ZjVmNTstLWdvb2dsZS1ncmV5LTMwMDojZTBlMGUwOy0tZ29vZ2xlLWdyZXktNTAwOiM5ZTllOWU7LS1nb29nbGUtZ3JleS03MDA6IzYxNjE2MTstLXBhcGVyLXJlZC01MDojZmZlYmVlOy0tcGFwZXItcmVkLTEwMDojZmZjZGQyOy0tcGFwZXItcmVkLTIwMDojZWY5YTlhOy0tcGFwZXItcmVkLTMwMDojZTU3MzczOy0tcGFwZXItcmVkLTQwMDojZWY1MzUwOy0tcGFwZXItcmVkLTUwMDojZjQ0MzM2Oy0tcGFwZXItcmVkLTYwMDojZTUzOTM1Oy0tcGFwZXItcmVkLTcwMDojZDMyZjJmOy0tcGFwZXItcmVkLTgwMDojYzYyODI4Oy0tcGFwZXItcmVkLTkwMDojYjcxYzFjOy0tcGFwZXItcmVkLWExMDA6I2ZmOGE4MDstLXBhcGVyLXJlZC1hMjAwOiNmZjUyNTI7LS1wYXBlci1yZWQtYTQwMDojZmYxNzQ0Oy0tcGFwZXItcmVkLWE3MDA6I2Q1MDAwMDstLXBhcGVyLXBpbmstNTA6I2ZjZTRlYzstLXBhcGVyLXBpbmstMTAwOiNmOGJiZDA7LS1wYXBlci1waW5rLTIwMDojZjQ4ZmIxOy0tcGFwZXItcGluay0zMDA6I2YwNjI5MjstLXBhcGVyLXBpbmstNDAwOiNlYzQwN2E7LS1wYXBlci1waW5rLTUwMDojZTkxZTYzOy0tcGFwZXItcGluay02MDA6I2Q4MWI2MDstLXBhcGVyLXBpbmstNzAwOiNjMjE4NWI7LS1wYXBlci1waW5rLTgwMDojYWQxNDU3Oy0tcGFwZXItcGluay05MDA6Izg4MGU0ZjstLXBhcGVyLXBpbmstYTEwMDojZmY4MGFiOy0tcGFwZXItcGluay1hMjAwOiNmZjQwODE7LS1wYXBlci1waW5rLWE0MDA6I2Y1MDA1NzstLXBhcGVyLXBpbmstYTcwMDojYzUxMTYyOy0tcGFwZXItcHVycGxlLTUwOiNmM2U1ZjU7LS1wYXBlci1wdXJwbGUtMTAwOiNlMWJlZTc7LS1wYXBlci1wdXJwbGUtMjAwOiNjZTkzZDg7LS1wYXBlci1wdXJwbGUtMzAwOiNiYTY4Yzg7LS1wYXBlci1wdXJwbGUtNDAwOiNhYjQ3YmM7LS1wYXBlci1wdXJwbGUtNTAwOiM5YzI3YjA7LS1wYXBlci1wdXJwbGUtNjAwOiM4ZTI0YWE7LS1wYXBlci1wdXJwbGUtNzAwOiM3YjFmYTI7LS1wYXBlci1wdXJwbGUtODAwOiM2YTFiOWE7LS1wYXBlci1wdXJwbGUtOTAwOiM0YTE0OGM7LS1wYXBlci1wdXJwbGUtYTEwMDojZWE4MGZjOy0tcGFwZXItcHVycGxlLWEyMDA6I2UwNDBmYjstLXBhcGVyLXB1cnBsZS1hNDAwOiNkNTAwZjk7LS1wYXBlci1wdXJwbGUtYTcwMDojYWEwMGZmOy0tcGFwZXItZGVlcC1wdXJwbGUtNTA6I2VkZTdmNjstLXBhcGVyLWRlZXAtcHVycGxlLTEwMDojZDFjNGU5Oy0tcGFwZXItZGVlcC1wdXJwbGUtMjAwOiNiMzlkZGI7LS1wYXBlci1kZWVwLXB1cnBsZS0zMDA6Izk1NzVjZDstLXBhcGVyLWRlZXAtcHVycGxlLTQwMDojN2U1N2MyOy0tcGFwZXItZGVlcC1wdXJwbGUtNTAwOiM2NzNhYjc7LS1wYXBlci1kZWVwLXB1cnBsZS02MDA6IzVlMzViMTstLXBhcGVyLWRlZXAtcHVycGxlLTcwMDojNTEyZGE4Oy0tcGFwZXItZGVlcC1wdXJwbGUtODAwOiM0NTI3YTA7LS1wYXBlci1kZWVwLXB1cnBsZS05MDA6IzMxMWI5MjstLXBhcGVyLWRlZXAtcHVycGxlLWExMDA6I2IzODhmZjstLXBhcGVyLWRlZXAtcHVycGxlLWEyMDA6IzdjNGRmZjstLXBhcGVyLWRlZXAtcHVycGxlLWE0MDA6IzY1MWZmZjstLXBhcGVyLWRlZXAtcHVycGxlLWE3MDA6IzYyMDBlYTstLXBhcGVyLWluZGlnby01MDojZThlYWY2Oy0tcGFwZXItaW5kaWdvLTEwMDojYzVjYWU5Oy0tcGFwZXItaW5kaWdvLTIwMDojOWZhOGRhOy0tcGFwZXItaW5kaWdvLTMwMDojNzk4NmNiOy0tcGFwZXItaW5kaWdvLTQwMDojNWM2YmMwOy0tcGFwZXItaW5kaWdvLTUwMDojM2Y1MWI1Oy0tcGFwZXItaW5kaWdvLTYwMDojMzk0OWFiOy0tcGFwZXItaW5kaWdvLTcwMDojMzAzZjlmOy0tcGFwZXItaW5kaWdvLTgwMDojMjgzNTkzOy0tcGFwZXItaW5kaWdvLTkwMDojMWEyMzdlOy0tcGFwZXItaW5kaWdvLWExMDA6IzhjOWVmZjstLXBhcGVyLWluZGlnby1hMjAwOiM1MzZkZmU7LS1wYXBlci1pbmRpZ28tYTQwMDojM2Q1YWZlOy0tcGFwZXItaW5kaWdvLWE3MDA6IzMwNGZmZTstLXBhcGVyLWJsdWUtNTA6I2UzZjJmZDstLXBhcGVyLWJsdWUtMTAwOiNiYmRlZmI7LS1wYXBlci1ibHVlLTIwMDojOTBjYWY5Oy0tcGFwZXItYmx1ZS0zMDA6IzY0YjVmNjstLXBhcGVyLWJsdWUtNDAwOiM0MmE1ZjU7LS1wYXBlci1ibHVlLTUwMDojMjE5NmYzOy0tcGFwZXItYmx1ZS02MDA6IzFlODhlNTstLXBhcGVyLWJsdWUtNzAwOiMxOTc2ZDI7LS1wYXBlci1ibHVlLTgwMDojMTU2NWMwOy0tcGFwZXItYmx1ZS05MDA6IzBkNDdhMTstLXBhcGVyLWJsdWUtYTEwMDojODJiMWZmOy0tcGFwZXItYmx1ZS1hMjAwOiM0NDhhZmY7LS1wYXBlci1ibHVlLWE0MDA6IzI5NzlmZjstLXBhcGVyLWJsdWUtYTcwMDojMjk2MmZmOy0tcGFwZXItbGlnaHQtYmx1ZS01MDojZTFmNWZlOy0tcGFwZXItbGlnaHQtYmx1ZS0xMDA6I2IzZTVmYzstLXBhcGVyLWxpZ2h0LWJsdWUtMjAwOiM4MWQ0ZmE7LS1wYXBlci1saWdodC1ibHVlLTMwMDojNGZjM2Y3Oy0tcGFwZXItbGlnaHQtYmx1ZS00MDA6IzI5YjZmNjstLXBhcGVyLWxpZ2h0LWJsdWUtNTAwOiMwM2E5ZjQ7LS1wYXBlci1saWdodC1ibHVlLTYwMDojMDM5YmU1Oy0tcGFwZXItbGlnaHQtYmx1ZS03MDA6IzAyODhkMTstLXBhcGVyLWxpZ2h0LWJsdWUtODAwOiMwMjc3YmQ7LS1wYXBlci1saWdodC1ibHVlLTkwMDojMDE1NzliOy0tcGFwZXItbGlnaHQtYmx1ZS1hMTAwOiM4MGQ4ZmY7LS1wYXBlci1saWdodC1ibHVlLWEyMDA6IzQwYzRmZjstLXBhcGVyLWxpZ2h0LWJsdWUtYTQwMDojMDBiMGZmOy0tcGFwZXItbGlnaHQtYmx1ZS1hNzAwOiMwMDkxZWE7LS1wYXBlci1jeWFuLTUwOiNlMGY3ZmE7LS1wYXBlci1jeWFuLTEwMDojYjJlYmYyOy0tcGFwZXItY3lhbi0yMDA6IzgwZGVlYTstLXBhcGVyLWN5YW4tMzAwOiM0ZGQwZTE7LS1wYXBlci1jeWFuLTQwMDojMjZjNmRhOy0tcGFwZXItY3lhbi01MDA6IzAwYmNkNDstLXBhcGVyLWN5YW4tNjAwOiMwMGFjYzE7LS1wYXBlci1jeWFuLTcwMDojMDA5N2E3Oy0tcGFwZXItY3lhbi04MDA6IzAwODM4ZjstLXBhcGVyLWN5YW4tOTAwOiMwMDYwNjQ7LS1wYXBlci1jeWFuLWExMDA6Izg0ZmZmZjstLXBhcGVyLWN5YW4tYTIwMDojMThmZmZmOy0tcGFwZXItY3lhbi1hNDAwOiMwMGU1ZmY7LS1wYXBlci1jeWFuLWE3MDA6IzAwYjhkNDstLXBhcGVyLXRlYWwtNTA6I2UwZjJmMTstLXBhcGVyLXRlYWwtMTAwOiNiMmRmZGI7LS1wYXBlci10ZWFsLTIwMDojODBjYmM0Oy0tcGFwZXItdGVhbC0zMDA6IzRkYjZhYzstLXBhcGVyLXRlYWwtNDAwOiMyNmE2OWE7LS1wYXBlci10ZWFsLTUwMDojMDA5Njg4Oy0tcGFwZXItdGVhbC02MDA6IzAwODk3YjstLXBhcGVyLXRlYWwtNzAwOiMwMDc5NmI7LS1wYXBlci10ZWFsLTgwMDojMDA2OTVjOy0tcGFwZXItdGVhbC05MDA6IzAwNGQ0MDstLXBhcGVyLXRlYWwtYTEwMDojYTdmZmViOy0tcGFwZXItdGVhbC1hMjAwOiM2NGZmZGE7LS1wYXBlci10ZWFsLWE0MDA6IzFkZTliNjstLXBhcGVyLXRlYWwtYTcwMDojMDBiZmE1Oy0tcGFwZXItZ3JlZW4tNTA6I2U4ZjVlOTstLXBhcGVyLWdyZWVuLTEwMDojYzhlNmM5Oy0tcGFwZXItZ3JlZW4tMjAwOiNhNWQ2YTc7LS1wYXBlci1ncmVlbi0zMDA6IzgxYzc4NDstLXBhcGVyLWdyZWVuLTQwMDojNjZiYjZhOy0tcGFwZXItZ3JlZW4tNTAwOiM0Y2FmNTA7LS1wYXBlci1ncmVlbi02MDA6IzQzYTA0NzstLXBhcGVyLWdyZWVuLTcwMDojMzg4ZTNjOy0tcGFwZXItZ3JlZW4tODAwOiMyZTdkMzI7LS1wYXBlci1ncmVlbi05MDA6IzFiNWUyMDstLXBhcGVyLWdyZWVuLWExMDA6I2I5ZjZjYTstLXBhcGVyLWdyZWVuLWEyMDA6IzY5ZjBhZTstLXBhcGVyLWdyZWVuLWE0MDA6IzAwZTY3NjstLXBhcGVyLWdyZWVuLWE3MDA6IzAwYzg1MzstLXBhcGVyLWxpZ2h0LWdyZWVuLTUwOiNmMWY4ZTk7LS1wYXBlci1saWdodC1ncmVlbi0xMDA6I2RjZWRjODstLXBhcGVyLWxpZ2h0LWdyZWVuLTIwMDojYzVlMWE1Oy0tcGFwZXItbGlnaHQtZ3JlZW4tMzAwOiNhZWQ1ODE7LS1wYXBlci1saWdodC1ncmVlbi00MDA6IzljY2M2NTstLXBhcGVyLWxpZ2h0LWdyZWVuLTUwMDojOGJjMzRhOy0tcGFwZXItbGlnaHQtZ3JlZW4tNjAwOiM3Y2IzNDI7LS1wYXBlci1saWdodC1ncmVlbi03MDA6IzY4OWYzODstLXBhcGVyLWxpZ2h0LWdyZWVuLTgwMDojNTU4YjJmOy0tcGFwZXItbGlnaHQtZ3JlZW4tOTAwOiMzMzY5MWU7LS1wYXBlci1saWdodC1ncmVlbi1hMTAwOiNjY2ZmOTA7LS1wYXBlci1saWdodC1ncmVlbi1hMjAwOiNiMmZmNTk7LS1wYXBlci1saWdodC1ncmVlbi1hNDAwOiM3NmZmMDM7LS1wYXBlci1saWdodC1ncmVlbi1hNzAwOiM2NGRkMTc7LS1wYXBlci1saW1lLTUwOiNmOWZiZTc7LS1wYXBlci1saW1lLTEwMDojZjBmNGMzOy0tcGFwZXItbGltZS0yMDA6I2U2ZWU5YzstLXBhcGVyLWxpbWUtMzAwOiNkY2U3NzU7LS1wYXBlci1saW1lLTQwMDojZDRlMTU3Oy0tcGFwZXItbGltZS01MDA6I2NkZGMzOTstLXBhcGVyLWxpbWUtNjAwOiNjMGNhMzM7LS1wYXBlci1saW1lLTcwMDojYWZiNDJiOy0tcGFwZXItbGltZS04MDA6IzllOWQyNDstLXBhcGVyLWxpbWUtOTAwOiM4Mjc3MTc7LS1wYXBlci1saW1lLWExMDA6I2Y0ZmY4MTstLXBhcGVyLWxpbWUtYTIwMDojZWVmZjQxOy0tcGFwZXItbGltZS1hNDAwOiNjNmZmMDA7LS1wYXBlci1saW1lLWE3MDA6I2FlZWEwMDstLXBhcGVyLXllbGxvdy01MDojZmZmZGU3Oy0tcGFwZXIteWVsbG93LTEwMDojZmZmOWM0Oy0tcGFwZXIteWVsbG93LTIwMDojZmZmNTlkOy0tcGFwZXIteWVsbG93LTMwMDojZmZmMTc2Oy0tcGFwZXIteWVsbG93LTQwMDojZmZlZTU4Oy0tcGFwZXIteWVsbG93LTUwMDojZmZlYjNiOy0tcGFwZXIteWVsbG93LTYwMDojZmRkODM1Oy0tcGFwZXIteWVsbG93LTcwMDojZmJjMDJkOy0tcGFwZXIteWVsbG93LTgwMDojZjlhODI1Oy0tcGFwZXIteWVsbG93LTkwMDojZjU3ZjE3Oy0tcGFwZXIteWVsbG93LWExMDA6I2ZmZmY4ZDstLXBhcGVyLXllbGxvdy1hMjAwOiNmZmZmMDA7LS1wYXBlci15ZWxsb3ctYTQwMDojZmZlYTAwOy0tcGFwZXIteWVsbG93LWE3MDA6I2ZmZDYwMDstLXBhcGVyLWFtYmVyLTUwOiNmZmY4ZTE7LS1wYXBlci1hbWJlci0xMDA6I2ZmZWNiMzstLXBhcGVyLWFtYmVyLTIwMDojZmZlMDgyOy0tcGFwZXItYW1iZXItMzAwOiNmZmQ1NGY7LS1wYXBlci1hbWJlci00MDA6I2ZmY2EyODstLXBhcGVyLWFtYmVyLTUwMDojZmZjMTA3Oy0tcGFwZXItYW1iZXItNjAwOiNmZmIzMDA7LS1wYXBlci1hbWJlci03MDA6I2ZmYTAwMDstLXBhcGVyLWFtYmVyLTgwMDojZmY4ZjAwOy0tcGFwZXItYW1iZXItOTAwOiNmZjZmMDA7LS1wYXBlci1hbWJlci1hMTAwOiNmZmU1N2Y7LS1wYXBlci1hbWJlci1hMjAwOiNmZmQ3NDA7LS1wYXBlci1hbWJlci1hNDAwOiNmZmM0MDA7LS1wYXBlci1hbWJlci1hNzAwOiNmZmFiMDA7LS1wYXBlci1vcmFuZ2UtNTA6I2ZmZjNlMDstLXBhcGVyLW9yYW5nZS0xMDA6I2ZmZTBiMjstLXBhcGVyLW9yYW5nZS0yMDA6I2ZmY2M4MDstLXBhcGVyLW9yYW5nZS0zMDA6I2ZmYjc0ZDstLXBhcGVyLW9yYW5nZS00MDA6I2ZmYTcyNjstLXBhcGVyLW9yYW5nZS01MDA6I2ZmOTgwMDstLXBhcGVyLW9yYW5nZS02MDA6I2ZiOGMwMDstLXBhcGVyLW9yYW5nZS03MDA6I2Y1N2MwMDstLXBhcGVyLW9yYW5nZS04MDA6I2VmNmMwMDstLXBhcGVyLW9yYW5nZS05MDA6I2U2NTEwMDstLXBhcGVyLW9yYW5nZS1hMTAwOiNmZmQxODA7LS1wYXBlci1vcmFuZ2UtYTIwMDojZmZhYjQwOy0tcGFwZXItb3JhbmdlLWE0MDA6I2ZmOTEwMDstLXBhcGVyLW9yYW5nZS1hNzAwOiNmZjY1MDA7LS1wYXBlci1kZWVwLW9yYW5nZS01MDojZmJlOWU3Oy0tcGFwZXItZGVlcC1vcmFuZ2UtMTAwOiNmZmNjYmM7LS1wYXBlci1kZWVwLW9yYW5nZS0yMDA6I2ZmYWI5MTstLXBhcGVyLWRlZXAtb3JhbmdlLTMwMDojZmY4YTY1Oy0tcGFwZXItZGVlcC1vcmFuZ2UtNDAwOiNmZjcwNDM7LS1wYXBlci1kZWVwLW9yYW5nZS01MDA6I2ZmNTcyMjstLXBhcGVyLWRlZXAtb3JhbmdlLTYwMDojZjQ1MTFlOy0tcGFwZXItZGVlcC1vcmFuZ2UtNzAwOiNlNjRhMTk7LS1wYXBlci1kZWVwLW9yYW5nZS04MDA6I2Q4NDMxNTstLXBhcGVyLWRlZXAtb3JhbmdlLTkwMDojYmYzNjBjOy0tcGFwZXItZGVlcC1vcmFuZ2UtYTEwMDojZmY5ZTgwOy0tcGFwZXItZGVlcC1vcmFuZ2UtYTIwMDojZmY2ZTQwOy0tcGFwZXItZGVlcC1vcmFuZ2UtYTQwMDojZmYzZDAwOy0tcGFwZXItZGVlcC1vcmFuZ2UtYTcwMDojZGQyYzAwOy0tcGFwZXItYnJvd24tNTA6I2VmZWJlOTstLXBhcGVyLWJyb3duLTEwMDojZDdjY2M4Oy0tcGFwZXItYnJvd24tMjAwOiNiY2FhYTQ7LS1wYXBlci1icm93bi0zMDA6I2ExODg3ZjstLXBhcGVyLWJyb3duLTQwMDojOGQ2ZTYzOy0tcGFwZXItYnJvd24tNTAwOiM3OTU1NDg7LS1wYXBlci1icm93bi02MDA6IzZkNGM0MTstLXBhcGVyLWJyb3duLTcwMDojNWQ0MDM3Oy0tcGFwZXItYnJvd24tODAwOiM0ZTM0MmU7LS1wYXBlci1icm93bi05MDA6IzNlMjcyMzstLXBhcGVyLWdyZXktNTA6I2ZhZmFmYTstLXBhcGVyLWdyZXktMTAwOiNmNWY1ZjU7LS1wYXBlci1ncmV5LTIwMDojZWVlZWVlOy0tcGFwZXItZ3JleS0zMDA6I2UwZTBlMDstLXBhcGVyLWdyZXktNDAwOiNiZGJkYmQ7LS1wYXBlci1ncmV5LTUwMDojOWU5ZTllOy0tcGFwZXItZ3JleS02MDA6Izc1NzU3NTstLXBhcGVyLWdyZXktNzAwOiM2MTYxNjE7LS1wYXBlci1ncmV5LTgwMDojNDI0MjQyOy0tcGFwZXItZ3JleS05MDA6IzIxMjEyMTstLXBhcGVyLWJsdWUtZ3JleS01MDojZWNlZmYxOy0tcGFwZXItYmx1ZS1ncmV5LTEwMDojY2ZkOGRjOy0tcGFwZXItYmx1ZS1ncmV5LTIwMDojYjBiZWM1Oy0tcGFwZXItYmx1ZS1ncmV5LTMwMDojOTBhNGFlOy0tcGFwZXItYmx1ZS1ncmV5LTQwMDojNzg5MDljOy0tcGFwZXItYmx1ZS1ncmV5LTUwMDojNjA3ZDhiOy0tcGFwZXItYmx1ZS1ncmV5LTYwMDojNTQ2ZTdhOy0tcGFwZXItYmx1ZS1ncmV5LTcwMDojNDU1YTY0Oy0tcGFwZXItYmx1ZS1ncmV5LTgwMDojMzc0NzRmOy0tcGFwZXItYmx1ZS1ncmV5LTkwMDojMjYzMjM4Oy0tZGFyay1kaXZpZGVyLW9wYWNpdHk6MC4xMjstLWRhcmstZGlzYWJsZWQtb3BhY2l0eTowLjM4Oy0tZGFyay1zZWNvbmRhcnktb3BhY2l0eTowLjU0Oy0tZGFyay1wcmltYXJ5LW9wYWNpdHk6MC44NzstLWxpZ2h0LWRpdmlkZXItb3BhY2l0eTowLjEyOy0tbGlnaHQtZGlzYWJsZWQtb3BhY2l0eTowLjM7LS1saWdodC1zZWNvbmRhcnktb3BhY2l0eTowLjc7LS1saWdodC1wcmltYXJ5LW9wYWNpdHk6MS4wfTwvc3R5bGU+IDwvY3VzdG9tLXN0eWxlPlwiKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvcGFwZXItc3R5bGVzL2NvbG9yLmh0bWwiLCI8IS0tXHJcbkBsaWNlbnNlXHJcbkNvcHlyaWdodCAoYykgMjAxNiBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcclxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcclxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XHJcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXHJcbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XHJcbi0tPlxyXG5cclxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9wb2x5bWVyLWVsZW1lbnQuaHRtbFwiPlxyXG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vYm93ZXJfY29tcG9uZW50cy9hcHAtbGF5b3V0L2FwcC1kcmF3ZXIvYXBwLWRyYXdlci5odG1sXCI+XHJcbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi9ib3dlcl9jb21wb25lbnRzL2FwcC1sYXlvdXQvYXBwLWRyYXdlci1sYXlvdXQvYXBwLWRyYXdlci1sYXlvdXQuaHRtbFwiPlxyXG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vYm93ZXJfY29tcG9uZW50cy9hcHAtbGF5b3V0L2FwcC1oZWFkZXIvYXBwLWhlYWRlci5odG1sXCI+XHJcbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi9ib3dlcl9jb21wb25lbnRzL2FwcC1sYXlvdXQvYXBwLWhlYWRlci1sYXlvdXQvYXBwLWhlYWRlci1sYXlvdXQuaHRtbFwiPlxyXG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vYm93ZXJfY29tcG9uZW50cy9hcHAtbGF5b3V0L2FwcC1zY3JvbGwtZWZmZWN0cy9hcHAtc2Nyb2xsLWVmZmVjdHMuaHRtbFwiPlxyXG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vYm93ZXJfY29tcG9uZW50cy9hcHAtbGF5b3V0L2FwcC10b29sYmFyL2FwcC10b29sYmFyLmh0bWxcIj5cclxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL2Jvd2VyX2NvbXBvbmVudHMvYXBwLXJvdXRlL2FwcC1sb2NhdGlvbi5odG1sXCI+XHJcbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi9ib3dlcl9jb21wb25lbnRzL2FwcC1yb3V0ZS9hcHAtcm91dGUuaHRtbFwiPlxyXG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vYm93ZXJfY29tcG9uZW50cy9pcm9uLXBhZ2VzL2lyb24tcGFnZXMuaHRtbFwiPlxyXG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vYm93ZXJfY29tcG9uZW50cy9pcm9uLXNlbGVjdG9yL2lyb24tc2VsZWN0b3IuaHRtbFwiPlxyXG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vYm93ZXJfY29tcG9uZW50cy9wYXBlci1pY29uLWJ1dHRvbi9wYXBlci1pY29uLWJ1dHRvbi5odG1sXCI+XHJcbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCJteS1pY29ucy5odG1sXCI+XHJcblxyXG48ZG9tLW1vZHVsZSBpZD1cIm15LWFwcFwiPlxyXG4gIDx0ZW1wbGF0ZT5cclxuICAgIDxzdHlsZT5cclxuICAgICAgIDpob3N0IHtcclxuICAgICAgICAtLWFwcC1wcmltYXJ5LWNvbG9yOiAjM0QyODE0O1xyXG4gICAgICAgIC0tYXBwLXNlY29uZGFyeS1jb2xvcjogI0ZGM0MzQztcclxuXHJcbiAgICAgICAgZGlzcGxheTogYmxvY2s7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGFwcC1kcmF3ZXItbGF5b3V0Om5vdChbbmFycm93XSkgW2RyYXdlci10b2dnbGVdIHtcclxuICAgICAgICBkaXNwbGF5OiBub25lO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBhcHAtaGVhZGVyIHtcclxuICAgICAgICBjb2xvcjogI2ZmZjtcclxuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1hcHAtcHJpbWFyeS1jb2xvcik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGFwcC1oZWFkZXIgcGFwZXItaWNvbi1idXR0b24ge1xyXG4gICAgICAgIC0tcGFwZXItaWNvbi1idXR0b24taW5rLWNvbG9yOiB3aGl0ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLmRyYXdlci1saXN0IHtcclxuICAgICAgICBtYXJnaW46IDAgMjBweDtcclxuICAgICAgfVxyXG5cclxuICAgICAgLmRyYXdlci1saXN0IGEge1xyXG4gICAgICAgIGRpc3BsYXk6IGJsb2NrO1xyXG4gICAgICAgIHBhZGRpbmc6IDAgMTZweDtcclxuICAgICAgICB0ZXh0LWRlY29yYXRpb246IG5vbmU7XHJcbiAgICAgICAgY29sb3I6IHZhcigtLWFwcC1zZWNvbmRhcnktY29sb3IpO1xyXG4gICAgICAgIGxpbmUtaGVpZ2h0OiA0MHB4O1xyXG4gICAgICB9XHJcblxyXG4gICAgICAuZHJhd2VyLWxpc3QgYS5pcm9uLXNlbGVjdGVkIHtcclxuICAgICAgICBjb2xvcjogYmxhY2s7XHJcbiAgICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XHJcbiAgICAgIH1cclxuICAgIDwvc3R5bGU+XHJcblxyXG4gICAgPGFwcC1sb2NhdGlvbiByb3V0ZT1cInt7cm91dGV9fVwiIHVybC1zcGFjZS1yZWdleD1cIl5bW3Jvb3RQYXRoXV1cIj48L2FwcC1sb2NhdGlvbj5cclxuICAgIDxhcHAtcm91dGUgcm91dGU9XCJ7e3JvdXRlfX1cIiBwYXR0ZXJuPVwiW1tyb290UGF0aF1dOnBhZ2VcIiBkYXRhPVwie3tyb3V0ZURhdGF9fVwiIHRhaWw9XCJ7e3N1YnJvdXRlfX1cIj48L2FwcC1yb3V0ZT5cclxuXHJcbiAgICA8YXBwLWRyYXdlci1sYXlvdXQgZnVsbGJsZWVkPlxyXG4gICAgICA8IS0tIERyYXdlciBjb250ZW50IC0tPlxyXG4gICAgICA8YXBwLWRyYXdlciBpZD1cImRyYXdlclwiIHNsb3Q9XCJkcmF3ZXJcIj5cclxuICAgICAgICA8YXBwLXRvb2xiYXI+U3BpZWxlPC9hcHAtdG9vbGJhcj5cclxuICAgICAgICA8aXJvbi1zZWxlY3RvciBzZWxlY3RlZD1cIltbcGFnZV1dXCIgYXR0ci1mb3Itc2VsZWN0ZWQ9XCJuYW1lXCIgY2xhc3M9XCJkcmF3ZXItbGlzdFwiIHJvbGU9XCJuYXZpZ2F0aW9uXCI+XHJcbiAgICAgICAgICA8YSBuYW1lPVwidmlldzFcIiBocmVmJD1cIltbcm9vdFBhdGhdXXZpZXcxXCI+U3BpZWxlPC9hPlxyXG4gICAgICAgICAgPGEgbmFtZT1cInZpZXcyXCIgaHJlZiQ9XCJbW3Jvb3RQYXRoXV12aWV3MVwiPk5ld3M8L2E+XHJcbiAgICAgICAgICA8YSBuYW1lPVwidmlldzJcIiBocmVmJD1cIltbcm9vdFBhdGhdXXZpZXcyXCI+VmVybGFnZTwvYT5cclxuICAgICAgICAgIDxhIG5hbWU9XCJ2aWV3M1wiIGhyZWYkPVwiW1tyb290UGF0aF1ddmlldzNcIj5BdXRvcmVuPC9hPlxyXG4gICAgICAgICAgPGEgbmFtZT1cInZpZXczXCIgaHJlZiQ9XCJbW3Jvb3RQYXRoXV12aWV3M1wiPkRlc2lnbmVyPC9hPlxyXG4gICAgICAgICAgPGEgbmFtZT1cInZpZXczXCIgaHJlZiQ9XCJbW3Jvb3RQYXRoXV12aWV3M1wiPlJlemVuc2VuaW9uZW48L2E+XHJcbiAgICAgICAgICA8YSBuYW1lPVwidmlldzNcIiBocmVmJD1cIltbcm9vdFBhdGhdXXZpZXczXCI+UHJlaXNlPC9hPlxyXG4gICAgICAgICAgPGhyPlxyXG4gICAgICAgICAgPGEgbmFtZT1cInZpZXczXCIgaHJlZiQ9XCJbW3Jvb3RQYXRoXV12aWV3M1wiPlNhbW1sdW5nPC9hPlxyXG4gICAgICAgICAgPGEgbmFtZT1cInZpZXczXCIgaHJlZiQ9XCJbW3Jvb3RQYXRoXV12aWV3M1wiPlNldHRpbmdzPC9hPlxyXG4gICAgICAgIDwvaXJvbi1zZWxlY3Rvcj5cclxuICAgICAgPC9hcHAtZHJhd2VyPlxyXG5cclxuICAgICAgPCEtLSBNYWluIGNvbnRlbnQgLS0+XHJcbiAgICAgIDxhcHAtaGVhZGVyLWxheW91dCBoYXMtc2Nyb2xsaW5nLXJlZ2lvbj5cclxuXHJcbiAgICAgICAgPGFwcC1oZWFkZXIgc2xvdD1cImhlYWRlclwiIGNvbmRlbnNlcyByZXZlYWxzIGVmZmVjdHM9XCJ3YXRlcmZhbGxcIj5cclxuICAgICAgICAgIDxhcHAtdG9vbGJhcj5cclxuICAgICAgICAgICAgPHBhcGVyLWljb24tYnV0dG9uIGljb249XCJteS1pY29uczptZW51XCIgZHJhd2VyLXRvZ2dsZT48L3BhcGVyLWljb24tYnV0dG9uPlxyXG4gICAgICAgICAgICA8ZGl2IG1haW4tdGl0bGU+THVkaW5nLm9yZzwvZGl2PlxyXG4gICAgICAgICAgPC9hcHAtdG9vbGJhcj5cclxuICAgICAgICA8L2FwcC1oZWFkZXI+XHJcblxyXG4gICAgICAgIDxpcm9uLXBhZ2VzIHNlbGVjdGVkPVwiW1twYWdlXV1cIiBhdHRyLWZvci1zZWxlY3RlZD1cIm5hbWVcIiBmYWxsYmFjay1zZWxlY3Rpb249XCJ2aWV3NDA0XCIgcm9sZT1cIm1haW5cIj5cclxuICAgICAgICAgIDxteS12aWV3MSBuYW1lPVwidmlldzFcIj48L215LXZpZXcxPlxyXG4gICAgICAgICAgPG15LXZpZXcyIG5hbWU9XCJ2aWV3MlwiPjwvbXktdmlldzI+XHJcbiAgICAgICAgICA8bXktdmlldzMgbmFtZT1cInZpZXczXCI+PC9teS12aWV3Mz5cclxuICAgICAgICAgIDxteS12aWV3NDA0IG5hbWU9XCJ2aWV3NDA0XCI+PC9teS12aWV3NDA0PlxyXG4gICAgICAgIDwvaXJvbi1wYWdlcz5cclxuICAgICAgPC9hcHAtaGVhZGVyLWxheW91dD5cclxuICAgIDwvYXBwLWRyYXdlci1sYXlvdXQ+XHJcbiAgPC90ZW1wbGF0ZT5cclxuXHJcbiAgPHNjcmlwdD5cclxuXHJcbiAgICBjbGFzcyBNeUFwcCBleHRlbmRzIFBvbHltZXIuRWxlbWVudCB7XHJcblxyXG4gICAgICBzdGF0aWMgZ2V0IGlzKCkgeyByZXR1cm4gJ215LWFwcCc7IH1cclxuXHJcbiAgICAgIHN0YXRpYyBnZXQgcHJvcGVydGllcygpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgcGFnZToge1xyXG4gICAgICAgICAgICB0eXBlOiBTdHJpbmcsXHJcbiAgICAgICAgICAgIHJlZmxlY3RUb0F0dHJpYnV0ZTogdHJ1ZSxcclxuICAgICAgICAgICAgb2JzZXJ2ZXI6ICdfcGFnZUNoYW5nZWQnLFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIHJvdXRlRGF0YTogT2JqZWN0LFxyXG4gICAgICAgICAgc3Vicm91dGU6IFN0cmluZyxcclxuICAgICAgICAgIHJvb3RQYXRoOiB7XHJcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcclxuICAgICAgICAgICAgdmFsdWU6ICcvJ1xyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIGxhenlQYWdlczoge1xyXG4gICAgICAgICAgICB0eXBlOiBPYmplY3QsXHJcbiAgICAgICAgICAgIHZhbHVlOiB7XHJcbiAgICAgICAgICAgICAgdmlldzE6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGltcG9ydCgvKiB3ZWJwYWNrQ2h1bmtOYW1lOiBcIm15LXZpZXcxXCIgKi8gJy4vbXktdmlldzEuaHRtbCcpO1xyXG4gICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgdmlldzI6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGltcG9ydCgvKiB3ZWJwYWNrQ2h1bmtOYW1lOiBcIm15LXZpZXcyXCIgKi8gJy4vbXktdmlldzIuaHRtbCcpO1xyXG4gICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgdmlldzM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGltcG9ydCgvKiB3ZWJwYWNrQ2h1bmtOYW1lOiBcIm15LXZpZXczXCIgKi8gJy4vbXktdmlldzMuaHRtbCcpO1xyXG4gICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgdmlldzQwNDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgaW1wb3J0KC8qIHdlYnBhY2tDaHVua05hbWU6IFwibXktdmlldzQwNFwiICovICcuL215LXZpZXc0MDQuaHRtbCcpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHN0YXRpYyBnZXQgb2JzZXJ2ZXJzKCkge1xyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAnX3JvdXRlUGFnZUNoYW5nZWQocm91dGVEYXRhLnBhZ2UpJyxcclxuICAgICAgICBdO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBfcm91dGVQYWdlQ2hhbmdlZChwYWdlKSB7XHJcbiAgICAgICAgLy8gUG9seW1lciAyLjAgd2lsbCBjYWxsIHdpdGggYHVuZGVmaW5lZGAgb24gaW5pdGlhbGl6YXRpb24uXHJcbiAgICAgICAgLy8gSWdub3JlIHVudGlsIHdlIGFyZSBwcm9wZXJseSBjYWxsZWQgd2l0aCBhIHN0cmluZy5cclxuICAgICAgICBpZiAocGFnZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBJZiBubyBwYWdlIHdhcyBmb3VuZCBpbiB0aGUgcm91dGUgZGF0YSwgcGFnZSB3aWxsIGJlIGFuIGVtcHR5IHN0cmluZy5cclxuICAgICAgICAvLyBEZWF1bHQgdG8gJ3ZpZXcxJyBpbiB0aGF0IGNhc2UuXHJcbiAgICAgICAgdGhpcy5wYWdlID0gcGFnZSB8fCAndmlldzEnO1xyXG5cclxuICAgICAgICAvLyBDbG9zZSBhIG5vbi1wZXJzaXN0ZW50IGRyYXdlciB3aGVuIHRoZSBwYWdlICYgcm91dGUgYXJlIGNoYW5nZWQuXHJcbiAgICAgICAgaWYgKCF0aGlzLiQuZHJhd2VyLnBlcnNpc3RlbnQpIHtcclxuICAgICAgICAgIHRoaXMuJC5kcmF3ZXIuY2xvc2UoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIF9wYWdlQ2hhbmdlZChwYWdlKSB7XHJcbiAgICAgICAgaWYgKHRoaXMubGF6eVBhZ2VzW3BhZ2VdKSB7XHJcbiAgICAgICAgICB0aGlzLmxhenlQYWdlc1twYWdlXSgpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB0aGlzLl9zaG93UGFnZTQwNCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgX3Nob3dQYWdlNDA0KCkge1xyXG4gICAgICAgIHRoaXMucGFnZSA9ICd2aWV3NDA0JztcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHdpbmRvdy5jdXN0b21FbGVtZW50cy5kZWZpbmUoTXlBcHAuaXMsIE15QXBwKTtcclxuICA8L3NjcmlwdD5cclxuPC9kb20tbW9kdWxlPlxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9teS1hcHAuaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi91dGlscy9ib290Lmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi91dGlscy9yZXNvbHZlLXVybC5odG1sXCI+XG48c2NyaXB0PlxuKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgbGV0IG1vZHVsZXMgPSB7fTtcbiAgbGV0IGxjTW9kdWxlcyA9IHt9O1xuICBmdW5jdGlvbiBmaW5kTW9kdWxlKGlkKSB7XG4gICAgcmV0dXJuIG1vZHVsZXNbaWRdIHx8IGxjTW9kdWxlc1tpZC50b0xvd2VyQ2FzZSgpXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHN0eWxlT3V0c2lkZVRlbXBsYXRlQ2hlY2soaW5zdCkge1xuICAgIGlmIChpbnN0LnF1ZXJ5U2VsZWN0b3IoJ3N0eWxlJykpIHtcbiAgICAgIGNvbnNvbGUud2FybignZG9tLW1vZHVsZSAlcyBoYXMgc3R5bGUgb3V0c2lkZSB0ZW1wbGF0ZScsIGluc3QuaWQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYGRvbS1tb2R1bGVgIGVsZW1lbnQgcmVnaXN0ZXJzIHRoZSBkb20gaXQgY29udGFpbnMgdG8gdGhlIG5hbWUgZ2l2ZW5cbiAgICogYnkgdGhlIG1vZHVsZSdzIGlkIGF0dHJpYnV0ZS4gSXQgcHJvdmlkZXMgYSB1bmlmaWVkIGRhdGFiYXNlIG9mIGRvbVxuICAgKiBhY2Nlc3NpYmxlIHZpYSBpdHMgc3RhdGljIGBpbXBvcnRgIEFQSS5cbiAgICpcbiAgICogQSBrZXkgdXNlIGNhc2Ugb2YgYGRvbS1tb2R1bGVgIGlzIGZvciBwcm92aWRpbmcgY3VzdG9tIGVsZW1lbnQgYDx0ZW1wbGF0ZT5gc1xuICAgKiB2aWEgSFRNTCBpbXBvcnRzIHRoYXQgYXJlIHBhcnNlZCBieSB0aGUgbmF0aXZlIEhUTUwgcGFyc2VyLCB0aGF0IGNhbiBiZVxuICAgKiByZWxvY2F0ZWQgZHVyaW5nIGEgYnVuZGxpbmcgcGFzcyBhbmQgc3RpbGwgbG9va2VkIHVwIGJ5IGBpZGAuXG4gICAqXG4gICAqIEV4YW1wbGU6XG4gICAqXG4gICAqICAgICA8ZG9tLW1vZHVsZSBpZD1cImZvb1wiPlxuICAgKiAgICAgICA8aW1nIHNyYz1cInN0dWZmLnBuZ1wiPlxuICAgKiAgICAgPC9kb20tbW9kdWxlPlxuICAgKlxuICAgKiBUaGVuIGluIGNvZGUgaW4gc29tZSBvdGhlciBsb2NhdGlvbiB0aGF0IGNhbm5vdCBhY2Nlc3MgdGhlIGRvbS1tb2R1bGUgYWJvdmVcbiAgICpcbiAgICogICAgIGxldCBpbWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkb20tbW9kdWxlJykuaW1wb3J0KCdmb28nLCAnaW1nJyk7XG4gICAqXG4gICAqIEBjdXN0b21FbGVtZW50XG4gICAqIEBleHRlbmRzIEhUTUxFbGVtZW50XG4gICAqIEBtZW1iZXJvZiBQb2x5bWVyXG4gICAqIEBzdW1tYXJ5IEN1c3RvbSBlbGVtZW50IHRoYXQgcHJvdmlkZXMgYSByZWdpc3RyeSBvZiByZWxvY2F0YWJsZSBET00gY29udGVudFxuICAgKiAgIGJ5IGBpZGAgdGhhdCBpcyBhZ25vc3RpYyB0byBidW5kbGluZy5cbiAgICogQHVucmVzdHJpY3RlZFxuICAgKi9cbiAgY2xhc3MgRG9tTW9kdWxlIGV4dGVuZHMgSFRNTEVsZW1lbnQge1xuXG4gICAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7IHJldHVybiBbJ2lkJ10gfVxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSBlbGVtZW50IHNwZWNpZmllZCBieSB0aGUgY3NzIGBzZWxlY3RvcmAgaW4gdGhlIG1vZHVsZVxuICAgICAqIHJlZ2lzdGVyZWQgYnkgYGlkYC4gRm9yIGV4YW1wbGUsIHRoaXMuaW1wb3J0KCdmb28nLCAnaW1nJyk7XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkIFRoZSBpZCBvZiB0aGUgZG9tLW1vZHVsZSBpbiB3aGljaCB0byBzZWFyY2guXG4gICAgICogQHBhcmFtIHtzdHJpbmc9fSBzZWxlY3RvciBUaGUgY3NzIHNlbGVjdG9yIGJ5IHdoaWNoIHRvIGZpbmQgdGhlIGVsZW1lbnQuXG4gICAgICogQHJldHVybiB7RWxlbWVudH0gUmV0dXJucyB0aGUgZWxlbWVudCB3aGljaCBtYXRjaGVzIGBzZWxlY3RvcmAgaW4gdGhlXG4gICAgICogbW9kdWxlIHJlZ2lzdGVyZWQgYXQgdGhlIHNwZWNpZmllZCBgaWRgLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbXBvcnQoaWQsIHNlbGVjdG9yKSB7XG4gICAgICBpZiAoaWQpIHtcbiAgICAgICAgbGV0IG0gPSBmaW5kTW9kdWxlKGlkKTtcbiAgICAgICAgaWYgKG0gJiYgc2VsZWN0b3IpIHtcbiAgICAgICAgICByZXR1cm4gbS5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBvbGQsIHZhbHVlKSB7XG4gICAgICBpZiAob2xkICE9PSB2YWx1ZSkge1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGFic29sdXRlIFVSTCBvZiB0aGUgb3JpZ2luYWwgbG9jYXRpb24gb2YgdGhpcyBgZG9tLW1vZHVsZWAuXG4gICAgICpcbiAgICAgKiBUaGlzIHZhbHVlIHdpbGwgZGlmZmVyIGZyb20gdGhpcyBlbGVtZW50J3MgYG93bmVyRG9jdW1lbnRgIGluIHRoZVxuICAgICAqIGZvbGxvd2luZyB3YXlzOlxuICAgICAqIC0gVGFrZXMgaW50byBhY2NvdW50IGFueSBgYXNzZXRwYXRoYCBhdHRyaWJ1dGUgYWRkZWQgZHVyaW5nIGJ1bmRsaW5nXG4gICAgICogICB0byBpbmRpY2F0ZSB0aGUgb3JpZ2luYWwgbG9jYXRpb24gcmVsYXRpdmUgdG8gdGhlIGJ1bmRsZWQgbG9jYXRpb25cbiAgICAgKiAtIFVzZXMgdGhlIEhUTUxJbXBvcnRzIHBvbHlmaWxsJ3MgYGltcG9ydEZvckVsZW1lbnRgIEFQSSB0byBlbnN1cmVcbiAgICAgKiAgIHRoZSBwYXRoIGlzIHJlbGF0aXZlIHRvIHRoZSBpbXBvcnQgZG9jdW1lbnQncyBsb2NhdGlvbiBzaW5jZVxuICAgICAqICAgYG93bmVyRG9jdW1lbnRgIGlzIG5vdCBjdXJyZW50bHkgcG9seWZpbGxlZFxuICAgICAqL1xuICAgIGdldCBhc3NldHBhdGgoKSB7XG4gICAgICAvLyBEb24ndCBvdmVycmlkZSBleGlzdGluZyBhc3NldHBhdGguXG4gICAgICBpZiAoIXRoaXMuX19hc3NldHBhdGgpIHtcbiAgICAgICAgLy8gbm90ZTogYXNzZXRwYXRoIHNldCB2aWEgYW4gYXR0cmlidXRlIG11c3QgYmUgcmVsYXRpdmUgdG8gdGhpc1xuICAgICAgICAvLyBlbGVtZW50J3MgbG9jYXRpb247IGFjY29tb2RhdGUgcG9seWZpbGxlZCBIVE1MSW1wb3J0c1xuICAgICAgICBjb25zdCBvd25lciA9IHdpbmRvdy5IVE1MSW1wb3J0cyAmJiBIVE1MSW1wb3J0cy5pbXBvcnRGb3JFbGVtZW50ID9cbiAgICAgICAgICBIVE1MSW1wb3J0cy5pbXBvcnRGb3JFbGVtZW50KHRoaXMpIHx8IGRvY3VtZW50IDogdGhpcy5vd25lckRvY3VtZW50O1xuICAgICAgICBjb25zdCB1cmwgPSBQb2x5bWVyLlJlc29sdmVVcmwucmVzb2x2ZVVybChcbiAgICAgICAgICB0aGlzLmdldEF0dHJpYnV0ZSgnYXNzZXRwYXRoJykgfHwgJycsIG93bmVyLmJhc2VVUkkpO1xuICAgICAgICB0aGlzLl9fYXNzZXRwYXRoID0gUG9seW1lci5SZXNvbHZlVXJsLnBhdGhGcm9tVXJsKHVybCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fX2Fzc2V0cGF0aDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgdGhlIGRvbS1tb2R1bGUgYXQgYSBnaXZlbiBpZC4gVGhpcyBtZXRob2Qgc2hvdWxkIG9ubHkgYmUgY2FsbGVkXG4gICAgICogd2hlbiBhIGRvbS1tb2R1bGUgaXMgaW1wZXJhdGl2ZWx5IGNyZWF0ZWQuIEZvclxuICAgICAqIGV4YW1wbGUsIGBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkb20tbW9kdWxlJykucmVnaXN0ZXIoJ2ZvbycpYC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZz19IGlkIFRoZSBpZCBhdCB3aGljaCB0byByZWdpc3RlciB0aGUgZG9tLW1vZHVsZS5cbiAgICAgKi9cbiAgICByZWdpc3RlcihpZCkge1xuICAgICAgaWQgPSBpZCB8fCB0aGlzLmlkO1xuICAgICAgaWYgKGlkKSB7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgLy8gc3RvcmUgaWQgc2VwYXJhdGUgZnJvbSBsb3dlcmNhc2VkIGlkIHNvIHRoYXRcbiAgICAgICAgLy8gaW4gYWxsIGNhc2VzIG1peGVkQ2FzZSBpZCB3aWxsIHN0b3JlZCBkaXN0aW5jdGx5XG4gICAgICAgIC8vIGFuZCBsb3dlcmNhc2UgdmVyc2lvbiBpcyBhIGZhbGxiYWNrXG4gICAgICAgIG1vZHVsZXNbaWRdID0gdGhpcztcbiAgICAgICAgbGNNb2R1bGVzW2lkLnRvTG93ZXJDYXNlKCldID0gdGhpcztcbiAgICAgICAgc3R5bGVPdXRzaWRlVGVtcGxhdGVDaGVjayh0aGlzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBEb21Nb2R1bGUucHJvdG90eXBlWydtb2R1bGVzJ10gPSBtb2R1bGVzO1xuXG4gIGN1c3RvbUVsZW1lbnRzLmRlZmluZSgnZG9tLW1vZHVsZScsIERvbU1vZHVsZSk7XG5cbiAgLy8gZXhwb3J0XG4gIFBvbHltZXIuRG9tTW9kdWxlID0gRG9tTW9kdWxlO1xuXG59KSgpO1xuPC9zY3JpcHQ+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL3BvbHltZXIvbGliL2VsZW1lbnRzL2RvbS1tb2R1bGUuaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cblxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cImJvb3QuaHRtbFwiPlxuXG48c2NyaXB0PlxuKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLyoqXG4gICAqIE1vZHVsZSB3aXRoIHV0aWxpdGllcyBmb3IgbWFuaXB1bGF0aW5nIHN0cnVjdHVyZWQgZGF0YSBwYXRoIHN0cmluZ3MuXG4gICAqXG4gICAqIEBuYW1lc3BhY2VcbiAgICogQG1lbWJlcm9mIFBvbHltZXJcbiAgICogQHN1bW1hcnkgTW9kdWxlIHdpdGggdXRpbGl0aWVzIGZvciBtYW5pcHVsYXRpbmcgc3RydWN0dXJlZCBkYXRhIHBhdGggc3RyaW5ncy5cbiAgICovXG4gIGNvbnN0IFBhdGggPSB7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHN0cmluZyBpcyBhIHN0cnVjdHVyZWQgZGF0YSBwYXRoIChoYXMgZG90cykuXG4gICAgICpcbiAgICAgKiBFeGFtcGxlOlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogUG9seW1lci5QYXRoLmlzUGF0aCgnZm9vLmJhci5iYXonKSAvLyB0cnVlXG4gICAgICogUG9seW1lci5QYXRoLmlzUGF0aCgnZm9vJykgICAgICAgICAvLyBmYWxzZVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIFBvbHltZXIuUGF0aFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFBhdGggc3RyaW5nXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgc3RyaW5nIGNvbnRhaW5lZCBvbmUgb3IgbW9yZSBkb3RzXG4gICAgICovXG4gICAgaXNQYXRoOiBmdW5jdGlvbihwYXRoKSB7XG4gICAgICByZXR1cm4gcGF0aC5pbmRleE9mKCcuJykgPj0gMDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcm9vdCBwcm9wZXJ0eSBuYW1lIGZvciB0aGUgZ2l2ZW4gcGF0aC5cbiAgICAgKlxuICAgICAqIEV4YW1wbGU6XG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiBQb2x5bWVyLlBhdGgucm9vdCgnZm9vLmJhci5iYXonKSAvLyAnZm9vJ1xuICAgICAqIFBvbHltZXIuUGF0aC5yb290KCdmb28nKSAgICAgICAgIC8vICdmb28nXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgUG9seW1lci5QYXRoXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggUGF0aCBzdHJpbmdcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFJvb3QgcHJvcGVydHkgbmFtZVxuICAgICAqL1xuICAgIHJvb3Q6IGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgIGxldCBkb3RJbmRleCA9IHBhdGguaW5kZXhPZignLicpO1xuICAgICAgaWYgKGRvdEluZGV4ID09PSAtMSkge1xuICAgICAgICByZXR1cm4gcGF0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXRoLnNsaWNlKDAsIGRvdEluZGV4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2l2ZW4gYGJhc2VgIGlzIGBmb28uYmFyYCwgYGZvb2AgaXMgYW4gYW5jZXN0b3IsIGBmb28uYmFyYCBpcyBub3RcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHBhdGggaXMgYW4gYW5jZXN0b3Igb2YgdGhlIGJhc2UgcGF0aC5cbiAgICAgKlxuICAgICAqIEV4YW1wbGU6XG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiBQb2x5bWVyLlBhdGguaXNBbmNlc3RvcignZm9vLmJhcicsICdmb28nKSAgICAgICAgIC8vIHRydWVcbiAgICAgKiBQb2x5bWVyLlBhdGguaXNBbmNlc3RvcignZm9vLmJhcicsICdmb28uYmFyJykgICAgIC8vIGZhbHNlXG4gICAgICogUG9seW1lci5QYXRoLmlzQW5jZXN0b3IoJ2Zvby5iYXInLCAnZm9vLmJhci5iYXonKSAvLyBmYWxzZVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIFBvbHltZXIuUGF0aFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlIFBhdGggc3RyaW5nIHRvIHRlc3QgYWdhaW5zdC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBQYXRoIHN0cmluZyB0byB0ZXN0LlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYHBhdGhgIGlzIGFuIGFuY2VzdG9yIG9mIGBiYXNlYC5cbiAgICAgKi9cbiAgICBpc0FuY2VzdG9yOiBmdW5jdGlvbihiYXNlLCBwYXRoKSB7XG4gICAgICAvLyAgICAgYmFzZS5zdGFydHNXaXRoKHBhdGggKyAnLicpO1xuICAgICAgcmV0dXJuIGJhc2UuaW5kZXhPZihwYXRoICsgJy4nKSA9PT0gMDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2l2ZW4gYGJhc2VgIGlzIGBmb28uYmFyYCwgYGZvby5iYXIuYmF6YCBpcyBhbiBkZXNjZW5kYW50XG4gICAgICpcbiAgICAgKiBFeGFtcGxlOlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogUG9seW1lci5QYXRoLmlzRGVzY2VuZGFudCgnZm9vLmJhcicsICdmb28uYmFyLmJheicpIC8vIHRydWVcbiAgICAgKiBQb2x5bWVyLlBhdGguaXNEZXNjZW5kYW50KCdmb28uYmFyJywgJ2Zvby5iYXInKSAgICAgLy8gZmFsc2VcbiAgICAgKiBQb2x5bWVyLlBhdGguaXNEZXNjZW5kYW50KCdmb28uYmFyJywgJ2ZvbycpICAgICAgICAgLy8gZmFsc2VcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBQb2x5bWVyLlBhdGhcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYmFzZSBQYXRoIHN0cmluZyB0byB0ZXN0IGFnYWluc3QuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggUGF0aCBzdHJpbmcgdG8gdGVzdC5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGBwYXRoYCBpcyBhIGRlc2NlbmRhbnQgb2YgYGJhc2VgLlxuICAgICAqL1xuICAgIGlzRGVzY2VuZGFudDogZnVuY3Rpb24oYmFzZSwgcGF0aCkge1xuICAgICAgLy8gICAgIHBhdGguc3RhcnRzV2l0aChiYXNlICsgJy4nKTtcbiAgICAgIHJldHVybiBwYXRoLmluZGV4T2YoYmFzZSArICcuJykgPT09IDA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlcGxhY2VzIGEgcHJldmlvdXMgYmFzZSBwYXRoIHdpdGggYSBuZXcgYmFzZSBwYXRoLCBwcmVzZXJ2aW5nIHRoZVxuICAgICAqIHJlbWFpbmRlciBvZiB0aGUgcGF0aC5cbiAgICAgKlxuICAgICAqIFVzZXIgbXVzdCBlbnN1cmUgYHBhdGhgIGhhcyBhIHByZWZpeCBvZiBgYmFzZWAuXG4gICAgICpcbiAgICAgKiBFeGFtcGxlOlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogUG9seW1lci5QYXRoLnRyYW5zbGF0ZSgnZm9vLmJhcicsICd6b3QnICdmb28uYmFyLmJheicpIC8vICd6b3QuYmF6J1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIFBvbHltZXIuUGF0aFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlIEN1cnJlbnQgYmFzZSBzdHJpbmcgdG8gcmVtb3ZlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5ld0Jhc2UgTmV3IGJhc2Ugc3RyaW5nIHRvIHJlcGxhY2Ugd2l0aFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFBhdGggdG8gdHJhbnNsYXRlXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBUcmFuc2xhdGVkIHN0cmluZ1xuICAgICAqL1xuICAgIHRyYW5zbGF0ZTogZnVuY3Rpb24oYmFzZSwgbmV3QmFzZSwgcGF0aCkge1xuICAgICAgcmV0dXJuIG5ld0Jhc2UgKyBwYXRoLnNsaWNlKGJhc2UubGVuZ3RoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGJhc2UgUGF0aCBzdHJpbmcgdG8gdGVzdCBhZ2FpbnN0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggUGF0aCBzdHJpbmcgdG8gdGVzdFxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYHBhdGhgIGlzIGVxdWFsIHRvIGBiYXNlYFxuICAgICAqIEB0aGlzIHtQYXRofVxuICAgICAqL1xuICAgIG1hdGNoZXM6IGZ1bmN0aW9uKGJhc2UsIHBhdGgpIHtcbiAgICAgIHJldHVybiAoYmFzZSA9PT0gcGF0aCkgfHxcbiAgICAgICAgICAgICB0aGlzLmlzQW5jZXN0b3IoYmFzZSwgcGF0aCkgfHxcbiAgICAgICAgICAgICB0aGlzLmlzRGVzY2VuZGFudChiYXNlLCBwYXRoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYXJyYXktYmFzZWQgcGF0aHMgdG8gZmxhdHRlbmVkIHBhdGguICBTdHJpbmctYmFzZWQgcGF0aHNcbiAgICAgKiBhcmUgcmV0dXJuZWQgYXMtaXMuXG4gICAgICpcbiAgICAgKiBFeGFtcGxlOlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogUG9seW1lci5QYXRoLm5vcm1hbGl6ZShbJ2Zvby5iYXInLCAwLCAnYmF6J10pICAvLyAnZm9vLmJhci4wLmJheidcbiAgICAgKiBQb2x5bWVyLlBhdGgubm9ybWFsaXplKCdmb28uYmFyLjAuYmF6JykgICAgICAgIC8vICdmb28uYmFyLjAuYmF6J1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIFBvbHltZXIuUGF0aFxuICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgIUFycmF5PHN0cmluZ3xudW1iZXI+fSBwYXRoIElucHV0IHBhdGhcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IEZsYXR0ZW5lZCBwYXRoXG4gICAgICovXG4gICAgbm9ybWFsaXplOiBmdW5jdGlvbihwYXRoKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXRoKSkge1xuICAgICAgICBsZXQgcGFydHMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBsZXQgYXJncyA9IHBhdGhbaV0udG9TdHJpbmcoKS5zcGxpdCgnLicpO1xuICAgICAgICAgIGZvciAobGV0IGo9MDsgajxhcmdzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKGFyZ3Nbal0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFydHMuam9pbignLicpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNwbGl0cyBhIHBhdGggaW50byBhbiBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy4gQWNjZXB0cyBlaXRoZXIgYXJyYXlzXG4gICAgICogb2YgcGF0aCBwYXJ0cyBvciBzdHJpbmdzLlxuICAgICAqXG4gICAgICogRXhhbXBsZTpcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIFBvbHltZXIuUGF0aC5zcGxpdChbJ2Zvby5iYXInLCAwLCAnYmF6J10pICAvLyBbJ2ZvbycsICdiYXInLCAnMCcsICdiYXonXVxuICAgICAqIFBvbHltZXIuUGF0aC5zcGxpdCgnZm9vLmJhci4wLmJheicpICAgICAgICAvLyBbJ2ZvbycsICdiYXInLCAnMCcsICdiYXonXVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIFBvbHltZXIuUGF0aFxuICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgIUFycmF5PHN0cmluZ3xudW1iZXI+fSBwYXRoIElucHV0IHBhdGhcbiAgICAgKiBAcmV0dXJuIHshQXJyYXk8c3RyaW5nPn0gQXJyYXkgb2YgcGF0aCBwYXJ0c1xuICAgICAqIEB0aGlzIHtQYXRofVxuICAgICAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlc31cbiAgICAgKi9cbiAgICBzcGxpdDogZnVuY3Rpb24ocGF0aCkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGF0aCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9ybWFsaXplKHBhdGgpLnNwbGl0KCcuJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGF0aC50b1N0cmluZygpLnNwbGl0KCcuJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlYWRzIGEgdmFsdWUgZnJvbSBhIHBhdGguICBJZiBhbnkgc3ViLXByb3BlcnR5IGluIHRoZSBwYXRoIGlzIGB1bmRlZmluZWRgLFxuICAgICAqIHRoaXMgbWV0aG9kIHJldHVybnMgYHVuZGVmaW5lZGAgKHdpbGwgbmV2ZXIgdGhyb3cuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgUG9seW1lci5QYXRoXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJvb3QgT2JqZWN0IGZyb20gd2hpY2ggdG8gZGVyZWZlcmVuY2UgcGF0aCBmcm9tXG4gICAgICogQHBhcmFtIHtzdHJpbmcgfCAhQXJyYXk8c3RyaW5nfG51bWJlcj59IHBhdGggUGF0aCB0byByZWFkXG4gICAgICogQHBhcmFtIHtPYmplY3Q9fSBpbmZvIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCB0byBgaW5mb2AsIHRoZSBub3JtYWxpemVkXG4gICAgICogIChmbGF0dGVuZWQpIHBhdGggd2lsbCBiZSBzZXQgdG8gYGluZm8ucGF0aGAuXG4gICAgICogQHJldHVybiB7Kn0gVmFsdWUgYXQgcGF0aCwgb3IgYHVuZGVmaW5lZGAgaWYgdGhlIHBhdGggY291bGQgbm90IGJlXG4gICAgICogIGZ1bGx5IGRlcmVmZXJlbmNlZC5cbiAgICAgKiBAdGhpcyB7UGF0aH1cbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uKHJvb3QsIHBhdGgsIGluZm8pIHtcbiAgICAgIGxldCBwcm9wID0gcm9vdDtcbiAgICAgIGxldCBwYXJ0cyA9IHRoaXMuc3BsaXQocGF0aCk7XG4gICAgICAvLyBMb29wIG92ZXIgcGF0aCBwYXJ0c1swLi5uLTFdIGFuZCBkZXJlZmVyZW5jZVxuICAgICAgZm9yIChsZXQgaT0wOyBpPHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICghcHJvcCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcGFydCA9IHBhcnRzW2ldO1xuICAgICAgICBwcm9wID0gcHJvcFtwYXJ0XTtcbiAgICAgIH1cbiAgICAgIGlmIChpbmZvKSB7XG4gICAgICAgIGluZm8ucGF0aCA9IHBhcnRzLmpvaW4oJy4nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwcm9wO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgdmFsdWUgdG8gYSBwYXRoLiAgSWYgYW55IHN1Yi1wcm9wZXJ0eSBpbiB0aGUgcGF0aCBpcyBgdW5kZWZpbmVkYCxcbiAgICAgKiB0aGlzIG1ldGhvZCB3aWxsIG5vLW9wLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIFBvbHltZXIuUGF0aFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByb290IE9iamVjdCBmcm9tIHdoaWNoIHRvIGRlcmVmZXJlbmNlIHBhdGggZnJvbVxuICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgIUFycmF5PHN0cmluZ3xudW1iZXI+fSBwYXRoIFBhdGggdG8gc2V0XG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byBzZXQgdG8gcGF0aFxuICAgICAqIEByZXR1cm4ge3N0cmluZyB8IHVuZGVmaW5lZH0gVGhlIG5vcm1hbGl6ZWQgdmVyc2lvbiBvZiB0aGUgaW5wdXQgcGF0aFxuICAgICAqIEB0aGlzIHtQYXRofVxuICAgICAqL1xuICAgIHNldDogZnVuY3Rpb24ocm9vdCwgcGF0aCwgdmFsdWUpIHtcbiAgICAgIGxldCBwcm9wID0gcm9vdDtcbiAgICAgIGxldCBwYXJ0cyA9IHRoaXMuc3BsaXQocGF0aCk7XG4gICAgICBsZXQgbGFzdCA9IHBhcnRzW3BhcnRzLmxlbmd0aC0xXTtcbiAgICAgIGlmIChwYXJ0cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIC8vIExvb3Agb3ZlciBwYXRoIHBhcnRzWzAuLm4tMl0gYW5kIGRlcmVmZXJlbmNlXG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxwYXJ0cy5sZW5ndGgtMTsgaSsrKSB7XG4gICAgICAgICAgbGV0IHBhcnQgPSBwYXJ0c1tpXTtcbiAgICAgICAgICBwcm9wID0gcHJvcFtwYXJ0XTtcbiAgICAgICAgICBpZiAoIXByb3ApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2V0IHZhbHVlIHRvIG9iamVjdCBhdCBlbmQgb2YgcGF0aFxuICAgICAgICBwcm9wW2xhc3RdID0gdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBTaW1wbGUgcHJvcGVydHkgc2V0XG4gICAgICAgIHByb3BbcGF0aF0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJ0cy5qb2luKCcuJyk7XG4gICAgfVxuXG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gc3RyaW5nIGlzIGEgc3RydWN0dXJlZCBkYXRhIHBhdGggKGhhcyBkb3RzKS5cbiAgICpcbiAgICogVGhpcyBmdW5jdGlvbiBpcyBkZXByZWNhdGVkLiAgVXNlIGBQb2x5bWVyLlBhdGguaXNQYXRoYCBpbnN0ZWFkLlxuICAgKlxuICAgKiBFeGFtcGxlOlxuICAgKlxuICAgKiBgYGBcbiAgICogUG9seW1lci5QYXRoLmlzRGVlcCgnZm9vLmJhci5iYXonKSAvLyB0cnVlXG4gICAqIFBvbHltZXIuUGF0aC5pc0RlZXAoJ2ZvbycpICAgICAgICAgLy8gZmFsc2VcbiAgICogYGBgXG4gICAqXG4gICAqIEBkZXByZWNhdGVkXG4gICAqIEBtZW1iZXJvZiBQb2x5bWVyLlBhdGhcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggUGF0aCBzdHJpbmdcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgc3RyaW5nIGNvbnRhaW5lZCBvbmUgb3IgbW9yZSBkb3RzXG4gICAqL1xuICBQYXRoLmlzRGVlcCA9IFBhdGguaXNQYXRoO1xuXG4gIFBvbHltZXIuUGF0aCA9IFBhdGg7XG5cbn0pKCk7XG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvdXRpbHMvcGF0aC5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuXG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vdXRpbHMvYm9vdC5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vdXRpbHMvbWl4aW4uaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3V0aWxzL2Nhc2UtbWFwLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi91dGlscy9hc3luYy5odG1sXCI+XG5cbjxzY3JpcHQ+XG4oZnVuY3Rpb24oKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIGxldCBjYXNlTWFwID0gUG9seW1lci5DYXNlTWFwO1xuXG4gIGxldCBtaWNyb3Rhc2sgPSBQb2x5bWVyLkFzeW5jLm1pY3JvVGFzaztcblxuICAvLyBTYXZlIG1hcCBvZiBuYXRpdmUgcHJvcGVydGllczsgdGhpcyBmb3JtcyBhIGJsYWNrbGlzdCBvciBwcm9wZXJ0aWVzXG4gIC8vIHRoYXQgd29uJ3QgaGF2ZSB0aGVpciB2YWx1ZXMgXCJzYXZlZFwiIGJ5IGBzYXZlQWNjZXNzb3JWYWx1ZWAsIHNpbmNlXG4gIC8vIHJlYWRpbmcgZnJvbSBhbiBIVE1MRWxlbWVudCBhY2Nlc3NvciBmcm9tIHRoZSBjb250ZXh0IG9mIGEgcHJvdG90eXBlIHRocm93c1xuICBjb25zdCBuYXRpdmVQcm9wZXJ0aWVzID0ge307XG4gIGxldCBwcm90byA9IEhUTUxFbGVtZW50LnByb3RvdHlwZTtcbiAgd2hpbGUgKHByb3RvKSB7XG4gICAgbGV0IHByb3BzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocHJvdG8pO1xuICAgIGZvciAobGV0IGk9MDsgaTxwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgbmF0aXZlUHJvcGVydGllc1twcm9wc1tpXV0gPSB0cnVlO1xuICAgIH1cbiAgICBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihwcm90byk7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCB0byBzYXZlIHRoZSB2YWx1ZSBvZiBhIHByb3BlcnR5IHRoYXQgd2lsbCBiZSBvdmVycmlkZGVuIHdpdGhcbiAgICogYW4gYWNjZXNzb3IuIElmIHRoZSBgbW9kZWxgIGlzIGEgcHJvdG90eXBlLCB0aGUgdmFsdWVzIHdpbGwgYmUgc2F2ZWRcbiAgICogaW4gYF9fZGF0YVByb3RvYCwgYW5kIGl0J3MgdXAgdG8gdGhlIHVzZXIgKG9yIGRvd25zdHJlYW0gbWl4aW4pIHRvXG4gICAqIGRlY2lkZSBob3cvd2hlbiB0byBzZXQgdGhlc2UgdmFsdWVzIGJhY2sgaW50byB0aGUgYWNjZXNzb3JzLlxuICAgKiBJZiBgbW9kZWxgIGlzIGFscmVhZHkgYW4gaW5zdGFuY2UgKGl0IGhhcyBhIGBfX2RhdGFgIHByb3BlcnR5KSwgdGhlblxuICAgKiB0aGUgdmFsdWUgd2lsbCBiZSBzZXQgYXMgYSBwZW5kaW5nIHByb3BlcnR5LCBtZWFuaW5nIHRoZSB1c2VyIHNob3VsZFxuICAgKiBjYWxsIGBfaW52YWxpZGF0ZVByb3BlcnRpZXNgIG9yIGBfZmx1c2hQcm9wZXJ0aWVzYCB0byB0YWtlIGVmZmVjdFxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gbW9kZWwgUHJvdG90eXBlIG9yIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBOYW1lIG9mIHByb3BlcnR5XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBzYXZlQWNjZXNzb3JWYWx1ZShtb2RlbCwgcHJvcGVydHkpIHtcbiAgICAvLyBEb24ndCByZWFkL3N0b3JlIHZhbHVlIGZvciBhbnkgbmF0aXZlIHByb3BlcnRpZXMgc2luY2UgdGhleSBjb3VsZCB0aHJvd1xuICAgIGlmICghbmF0aXZlUHJvcGVydGllc1twcm9wZXJ0eV0pIHtcbiAgICAgIGxldCB2YWx1ZSA9IG1vZGVsW3Byb3BlcnR5XTtcbiAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChtb2RlbC5fX2RhdGEpIHtcbiAgICAgICAgICAvLyBBZGRpbmcgYWNjZXNzb3IgdG8gaW5zdGFuY2U7IHVwZGF0ZSB0aGUgcHJvcGVydHlcbiAgICAgICAgICAvLyBJdCBpcyB0aGUgdXNlcidzIHJlc3BvbnNpYmlsaXR5IHRvIGNhbGwgX2ZsdXNoUHJvcGVydGllc1xuICAgICAgICAgIG1vZGVsLl9zZXRQZW5kaW5nUHJvcGVydHkocHJvcGVydHksIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBBZGRpbmcgYWNjZXNzb3IgdG8gcHJvdG87IHNhdmUgcHJvdG8ncyB2YWx1ZSBmb3IgaW5zdGFuY2UtdGltZSB1c2VcbiAgICAgICAgICBpZiAoIW1vZGVsLl9fZGF0YVByb3RvKSB7XG4gICAgICAgICAgICBtb2RlbC5fX2RhdGFQcm90byA9IHt9O1xuICAgICAgICAgIH0gZWxzZSBpZiAoIW1vZGVsLmhhc093blByb3BlcnR5KEpTQ29tcGlsZXJfcmVuYW1lUHJvcGVydHkoJ19fZGF0YVByb3RvJywgbW9kZWwpKSkge1xuICAgICAgICAgICAgbW9kZWwuX19kYXRhUHJvdG8gPSBPYmplY3QuY3JlYXRlKG1vZGVsLl9fZGF0YVByb3RvKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbW9kZWwuX19kYXRhUHJvdG9bcHJvcGVydHldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRWxlbWVudCBjbGFzcyBtaXhpbiB0aGF0IHByb3ZpZGVzIGJhc2ljIG1ldGEtcHJvZ3JhbW1pbmcgZm9yIGNyZWF0aW5nIG9uZVxuICAgKiBvciBtb3JlIHByb3BlcnR5IGFjY2Vzc29ycyAoZ2V0dGVyL3NldHRlciBwYWlyKSB0aGF0IGVucXVldWUgYW4gYXN5bmNcbiAgICogKGJhdGNoZWQpIGBfcHJvcGVydGllc0NoYW5nZWRgIGNhbGxiYWNrLlxuICAgKlxuICAgKiBGb3IgYmFzaWMgdXNhZ2Ugb2YgdGhpcyBtaXhpbiwgc2ltcGx5IGRlY2xhcmUgYXR0cmlidXRlcyB0byBvYnNlcnZlIHZpYVxuICAgKiB0aGUgc3RhbmRhcmQgYHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKClgLCBpbXBsZW1lbnQgYF9wcm9wZXJ0aWVzQ2hhbmdlZGBcbiAgICogb24gdGhlIGNsYXNzLCBhbmQgdGhlbiBjYWxsIGBNeUNsYXNzLmNyZWF0ZVByb3BlcnRpZXNGb3JBdHRyaWJ1dGVzKClgIG9uY2VcbiAgICogb24gdGhlIGNsYXNzIHRvIGdlbmVyYXRlIHByb3BlcnR5IGFjY2Vzc29ycyBmb3IgZWFjaCBvYnNlcnZlZCBhdHRyaWJ1dGVcbiAgICogcHJpb3IgdG8gaW5zdGFuY2luZy4gIExhc3QsIGNhbGwgYHRoaXMuX2ZsdXNoUHJvcGVydGllcygpYCBvbmNlIHRvIGVuYWJsZVxuICAgKiB0aGUgYWNjZXNzb3JzLlxuICAgKlxuICAgKiBBbnkgYG9ic2VydmVkQXR0cmlidXRlc2Agd2lsbCBhdXRvbWF0aWNhbGx5IGJlXG4gICAqIGRlc2VyaWFsaXplZCB2aWEgYGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFja2AgYW5kIHNldCB0byB0aGUgYXNzb2NpYXRlZFxuICAgKiBwcm9wZXJ0eSB1c2luZyBgZGFzaC1jYXNlYC10by1gY2FtZWxDYXNlYCBjb252ZW50aW9uLlxuICAgKlxuICAgKiBAbWl4aW5GdW5jdGlvblxuICAgKiBAcG9seW1lclxuICAgKiBAbWVtYmVyb2YgUG9seW1lclxuICAgKiBAc3VtbWFyeSBFbGVtZW50IGNsYXNzIG1peGluIGZvciByZWFjdGluZyB0byBwcm9wZXJ0eSBjaGFuZ2VzIGZyb21cbiAgICogICBnZW5lcmF0ZWQgcHJvcGVydHkgYWNjZXNzb3JzLlxuICAgKi9cbiAgUG9seW1lci5Qcm9wZXJ0eUFjY2Vzc29ycyA9IFBvbHltZXIuZGVkdXBpbmdNaXhpbihzdXBlckNsYXNzID0+IHtcblxuICAgIC8qKlxuICAgICAqIEBwb2x5bWVyXG4gICAgICogQG1peGluQ2xhc3NcbiAgICAgKiBAaW1wbGVtZW50cyB7UG9seW1lcl9Qcm9wZXJ0eUFjY2Vzc29yc31cbiAgICAgKiBAZXh0ZW5kcyBIVE1MRWxlbWVudFxuICAgICAqIEB1bnJlc3RyaWN0ZWRcbiAgICAgKi9cbiAgICBjbGFzcyBQcm9wZXJ0eUFjY2Vzc29ycyBleHRlbmRzIHN1cGVyQ2xhc3Mge1xuXG4gICAgICAvKipcbiAgICAgICAqIEdlbmVyYXRlcyBwcm9wZXJ0eSBhY2Nlc3NvcnMgZm9yIGFsbCBhdHRyaWJ1dGVzIGluIHRoZSBzdGFuZGFyZFxuICAgICAgICogc3RhdGljIGBvYnNlcnZlZEF0dHJpYnV0ZXNgIGFycmF5LlxuICAgICAgICpcbiAgICAgICAqIEF0dHJpYnV0ZSBuYW1lcyBhcmUgbWFwcGVkIHRvIHByb3BlcnR5IG5hbWVzIHVzaW5nIHRoZSBgZGFzaC1jYXNlYCB0b1xuICAgICAgICogYGNhbWVsQ2FzZWAgY29udmVudGlvblxuICAgICAgICpcbiAgICAgICAqL1xuICAgICAgc3RhdGljIGNyZWF0ZVByb3BlcnRpZXNGb3JBdHRyaWJ1dGVzKCkge1xuICAgICAgICBsZXQgYSQgPSB0aGlzLm9ic2VydmVkQXR0cmlidXRlcztcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpIDwgYSQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB0aGlzLnByb3RvdHlwZS5fY3JlYXRlUHJvcGVydHlBY2Nlc3NvcihjYXNlTWFwLmRhc2hUb0NhbWVsQ2FzZShhJFtpXSkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICAvKiogQHR5cGUge2Jvb2xlYW59ICovXG4gICAgICAgIHRoaXMuX19zZXJpYWxpemluZztcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMuX19kYXRhQ291bnRlcjtcbiAgICAgICAgLyoqIEB0eXBlIHtib29sZWFufSAqL1xuICAgICAgICB0aGlzLl9fZGF0YUVuYWJsZWQ7XG4gICAgICAgIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cbiAgICAgICAgdGhpcy5fX2RhdGFSZWFkeTtcbiAgICAgICAgLyoqIEB0eXBlIHtib29sZWFufSAqL1xuICAgICAgICB0aGlzLl9fZGF0YUludmFsaWQ7XG4gICAgICAgIC8qKiBAdHlwZSB7IU9iamVjdH0gKi9cbiAgICAgICAgdGhpcy5fX2RhdGE7XG4gICAgICAgIC8qKiBAdHlwZSB7T2JqZWN0fSAqL1xuICAgICAgICB0aGlzLl9fZGF0YVBlbmRpbmc7XG4gICAgICAgIC8qKiBAdHlwZSB7T2JqZWN0fSAqL1xuICAgICAgICB0aGlzLl9fZGF0YU9sZDtcbiAgICAgICAgLyoqIEB0eXBlIHtPYmplY3R9ICovXG4gICAgICAgIHRoaXMuX19kYXRhUHJvdG87XG4gICAgICAgIC8qKiBAdHlwZSB7T2JqZWN0fSAqL1xuICAgICAgICB0aGlzLl9fZGF0YUhhc0FjY2Vzc29yO1xuICAgICAgICAvKiogQHR5cGUge09iamVjdH0gKi9cbiAgICAgICAgdGhpcy5fX2RhdGFJbnN0YW5jZVByb3BzO1xuICAgICAgICB0aGlzLl9pbml0aWFsaXplUHJvcGVydGllcygpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEltcGxlbWVudHMgbmF0aXZlIEN1c3RvbSBFbGVtZW50cyBgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrYCB0b1xuICAgICAgICogc2V0IGFuIGF0dHJpYnV0ZSB2YWx1ZSB0byBhIHByb3BlcnR5IHZpYSBgX2F0dHJpYnV0ZVRvUHJvcGVydHlgLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE5hbWUgb2YgYXR0cmlidXRlIHRoYXQgY2hhbmdlZFxuICAgICAgICogQHBhcmFtIHs/c3RyaW5nfSBvbGQgT2xkIGF0dHJpYnV0ZSB2YWx1ZVxuICAgICAgICogQHBhcmFtIHs/c3RyaW5nfSB2YWx1ZSBOZXcgYXR0cmlidXRlIHZhbHVlXG4gICAgICAgKi9cbiAgICAgIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBvbGQsIHZhbHVlKSB7XG4gICAgICAgIGlmIChvbGQgIT09IHZhbHVlKSB7XG4gICAgICAgICAgdGhpcy5fYXR0cmlidXRlVG9Qcm9wZXJ0eShuYW1lLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBJbml0aWFsaXplcyB0aGUgbG9jYWwgc3RvcmFnZSBmb3IgcHJvcGVydHkgYWNjZXNzb3JzLlxuICAgICAgICpcbiAgICAgICAqIFByb3ZpZGVkIGFzIGFuIG92ZXJyaWRlIHBvaW50IGZvciBwZXJmb3JtaW5nIGFueSBzZXR1cCB3b3JrIHByaW9yXG4gICAgICAgKiB0byBpbml0aWFsaXppbmcgdGhlIHByb3BlcnR5IGFjY2Vzc29yIHN5c3RlbS5cbiAgICAgICAqXG4gICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgKi9cbiAgICAgIF9pbml0aWFsaXplUHJvcGVydGllcygpIHtcbiAgICAgICAgdGhpcy5fX3NlcmlhbGl6aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX19kYXRhQ291bnRlciA9IDA7XG4gICAgICAgIHRoaXMuX19kYXRhRW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9fZGF0YVJlYWR5ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX19kYXRhSW52YWxpZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9fZGF0YSA9IHt9O1xuICAgICAgICB0aGlzLl9fZGF0YVBlbmRpbmcgPSBudWxsO1xuICAgICAgICB0aGlzLl9fZGF0YU9sZCA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLl9fZGF0YVByb3RvKSB7XG4gICAgICAgICAgdGhpcy5faW5pdGlhbGl6ZVByb3RvUHJvcGVydGllcyh0aGlzLl9fZGF0YVByb3RvKTtcbiAgICAgICAgICB0aGlzLl9fZGF0YVByb3RvID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBDYXB0dXJlIGluc3RhbmNlIHByb3BlcnRpZXM7IHRoZXNlIHdpbGwgYmUgc2V0IGludG8gYWNjZXNzb3JzXG4gICAgICAgIC8vIGR1cmluZyBmaXJzdCBmbHVzaC4gRG9uJ3Qgc2V0IHRoZW0gaGVyZSwgc2luY2Ugd2Ugd2FudFxuICAgICAgICAvLyB0aGVzZSB0byBvdmVyd3JpdGUgZGVmYXVsdHMvY29uc3RydWN0b3IgYXNzaWdubWVudHNcbiAgICAgICAgZm9yIChsZXQgcCBpbiB0aGlzLl9fZGF0YUhhc0FjY2Vzc29yKSB7XG4gICAgICAgICAgaWYgKHRoaXMuaGFzT3duUHJvcGVydHkocCkpIHtcbiAgICAgICAgICAgIHRoaXMuX19kYXRhSW5zdGFuY2VQcm9wcyA9IHRoaXMuX19kYXRhSW5zdGFuY2VQcm9wcyB8fCB7fTtcbiAgICAgICAgICAgIHRoaXMuX19kYXRhSW5zdGFuY2VQcm9wc1twXSA9IHRoaXNbcF07XG4gICAgICAgICAgICBkZWxldGUgdGhpc1twXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDYWxsZWQgYXQgaW5zdGFuY2UgdGltZSB3aXRoIGJhZyBvZiBwcm9wZXJ0aWVzIHRoYXQgd2VyZSBvdmVyd3JpdHRlblxuICAgICAgICogYnkgYWNjZXNzb3JzIG9uIHRoZSBwcm90b3R5cGUgd2hlbiBhY2Nlc3NvcnMgd2VyZSBjcmVhdGVkLlxuICAgICAgICpcbiAgICAgICAqIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIHNldHMgdGhlc2UgcHJvcGVydGllcyBiYWNrIGludG8gdGhlXG4gICAgICAgKiBzZXR0ZXIgYXQgaW5zdGFuY2UgdGltZS4gIFRoaXMgbWV0aG9kIGlzIHByb3ZpZGVkIGFzIGFuIG92ZXJyaWRlXG4gICAgICAgKiBwb2ludCBmb3IgY3VzdG9taXppbmcgb3IgcHJvdmlkaW5nIG1vcmUgZWZmaWNpZW50IGluaXRpYWxpemF0aW9uLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBCYWcgb2YgcHJvcGVydHkgdmFsdWVzIHRoYXQgd2VyZSBvdmVyd3JpdHRlblxuICAgICAgICogICB3aGVuIGNyZWF0aW5nIHByb3BlcnR5IGFjY2Vzc29ycy5cbiAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAqL1xuICAgICAgX2luaXRpYWxpemVQcm90b1Byb3BlcnRpZXMocHJvcHMpIHtcbiAgICAgICAgZm9yIChsZXQgcCBpbiBwcm9wcykge1xuICAgICAgICAgIHRoaXMuX3NldFByb3BlcnR5KHAsIHByb3BzW3BdKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENhbGxlZCBhdCByZWFkeSB0aW1lIHdpdGggYmFnIG9mIGluc3RhbmNlIHByb3BlcnRpZXMgdGhhdCBvdmVyd3JvdGVcbiAgICAgICAqIGFjY2Vzc29ycyB3aGVuIHRoZSBlbGVtZW50IHVwZ3JhZGVkLlxuICAgICAgICpcbiAgICAgICAqIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIHNldHMgdGhlc2UgcHJvcGVydGllcyBiYWNrIGludG8gdGhlXG4gICAgICAgKiBzZXR0ZXIgYXQgcmVhZHkgdGltZS4gIFRoaXMgbWV0aG9kIGlzIHByb3ZpZGVkIGFzIGFuIG92ZXJyaWRlXG4gICAgICAgKiBwb2ludCBmb3IgY3VzdG9taXppbmcgb3IgcHJvdmlkaW5nIG1vcmUgZWZmaWNpZW50IGluaXRpYWxpemF0aW9uLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBCYWcgb2YgcHJvcGVydHkgdmFsdWVzIHRoYXQgd2VyZSBvdmVyd3JpdHRlblxuICAgICAgICogICB3aGVuIGNyZWF0aW5nIHByb3BlcnR5IGFjY2Vzc29ycy5cbiAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAqL1xuICAgICAgX2luaXRpYWxpemVJbnN0YW5jZVByb3BlcnRpZXMocHJvcHMpIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBwcm9wcyk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogRW5zdXJlcyB0aGUgZWxlbWVudCBoYXMgdGhlIGdpdmVuIGF0dHJpYnV0ZS4gSWYgaXQgZG9lcyBub3QsXG4gICAgICAgKiBhc3NpZ25zIHRoZSBnaXZlbiB2YWx1ZSB0byB0aGUgYXR0cmlidXRlLlxuICAgICAgICpcbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlIE5hbWUgb2YgYXR0cmlidXRlIHRvIGVuc3VyZSBpcyBzZXQuXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgb2YgdGhlIGF0dHJpYnV0ZS5cbiAgICAgICAqL1xuICAgICAgX2Vuc3VyZUF0dHJpYnV0ZShhdHRyaWJ1dGUsIHZhbHVlKSB7XG4gICAgICAgIGlmICghdGhpcy5oYXNBdHRyaWJ1dGUoYXR0cmlidXRlKSkge1xuICAgICAgICAgIHRoaXMuX3ZhbHVlVG9Ob2RlQXR0cmlidXRlKHRoaXMsIHZhbHVlLCBhdHRyaWJ1dGUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogRGVzZXJpYWxpemVzIGFuIGF0dHJpYnV0ZSB0byBpdHMgYXNzb2NpYXRlZCBwcm9wZXJ0eS5cbiAgICAgICAqXG4gICAgICAgKiBUaGlzIG1ldGhvZCBjYWxscyB0aGUgYF9kZXNlcmlhbGl6ZVZhbHVlYCBtZXRob2QgdG8gY29udmVydCB0aGUgc3RyaW5nIHRvXG4gICAgICAgKiBhIHR5cGVkIHZhbHVlLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGUgTmFtZSBvZiBhdHRyaWJ1dGUgdG8gZGVzZXJpYWxpemUuXG4gICAgICAgKiBAcGFyYW0gez9zdHJpbmd9IHZhbHVlIG9mIHRoZSBhdHRyaWJ1dGUuXG4gICAgICAgKiBAcGFyYW0geyo9fSB0eXBlIHR5cGUgdG8gZGVzZXJpYWxpemUgdG8uXG4gICAgICAgKi9cbiAgICAgIF9hdHRyaWJ1dGVUb1Byb3BlcnR5KGF0dHJpYnV0ZSwgdmFsdWUsIHR5cGUpIHtcbiAgICAgICAgLy8gRG9uJ3QgZGVzZXJpYWxpemUgYmFjayB0byBwcm9wZXJ0eSBpZiBjdXJyZW50bHkgcmVmbGVjdGluZ1xuICAgICAgICBpZiAoIXRoaXMuX19zZXJpYWxpemluZykge1xuICAgICAgICAgIGxldCBwcm9wZXJ0eSA9IGNhc2VNYXAuZGFzaFRvQ2FtZWxDYXNlKGF0dHJpYnV0ZSk7XG4gICAgICAgICAgdGhpc1twcm9wZXJ0eV0gPSB0aGlzLl9kZXNlcmlhbGl6ZVZhbHVlKHZhbHVlLCB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFNlcmlhbGl6ZXMgYSBwcm9wZXJ0eSB0byBpdHMgYXNzb2NpYXRlZCBhdHRyaWJ1dGUuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IG5hbWUgdG8gcmVmbGVjdC5cbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nPX0gYXR0cmlidXRlIEF0dHJpYnV0ZSBuYW1lIHRvIHJlZmxlY3QuXG4gICAgICAgKiBAcGFyYW0geyo9fSB2YWx1ZSBQcm9wZXJ0eSB2YWx1ZSB0byByZWZlY3QuXG4gICAgICAgKi9cbiAgICAgIF9wcm9wZXJ0eVRvQXR0cmlidXRlKHByb3BlcnR5LCBhdHRyaWJ1dGUsIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX19zZXJpYWxpemluZyA9IHRydWU7XG4gICAgICAgIHZhbHVlID0gKGFyZ3VtZW50cy5sZW5ndGggPCAzKSA/IHRoaXNbcHJvcGVydHldIDogdmFsdWU7XG4gICAgICAgIHRoaXMuX3ZhbHVlVG9Ob2RlQXR0cmlidXRlKHRoaXMsIHZhbHVlLFxuICAgICAgICAgIGF0dHJpYnV0ZSB8fCBjYXNlTWFwLmNhbWVsVG9EYXNoQ2FzZShwcm9wZXJ0eSkpO1xuICAgICAgICB0aGlzLl9fc2VyaWFsaXppbmcgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBTZXRzIGEgdHlwZWQgdmFsdWUgdG8gYW4gSFRNTCBhdHRyaWJ1dGUgb24gYSBub2RlLlxuICAgICAgICpcbiAgICAgICAqIFRoaXMgbWV0aG9kIGNhbGxzIHRoZSBgX3NlcmlhbGl6ZVZhbHVlYCBtZXRob2QgdG8gY29udmVydCB0aGUgdHlwZWRcbiAgICAgICAqIHZhbHVlIHRvIGEgc3RyaW5nLiAgSWYgdGhlIGBfc2VyaWFsaXplVmFsdWVgIG1ldGhvZCByZXR1cm5zIGB1bmRlZmluZWRgLFxuICAgICAgICogdGhlIGF0dHJpYnV0ZSB3aWxsIGJlIHJlbW92ZWQgKHRoaXMgaXMgdGhlIGRlZmF1bHQgZm9yIGJvb2xlYW5cbiAgICAgICAqIHR5cGUgYGZhbHNlYCkuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtFbGVtZW50fSBub2RlIEVsZW1lbnQgdG8gc2V0IGF0dHJpYnV0ZSB0by5cbiAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgdG8gc2VyaWFsaXplLlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGF0dHJpYnV0ZSBBdHRyaWJ1dGUgbmFtZSB0byBzZXJpYWxpemUgdG8uXG4gICAgICAgKi9cbiAgICAgIF92YWx1ZVRvTm9kZUF0dHJpYnV0ZShub2RlLCB2YWx1ZSwgYXR0cmlidXRlKSB7XG4gICAgICAgIGxldCBzdHIgPSB0aGlzLl9zZXJpYWxpemVWYWx1ZSh2YWx1ZSk7XG4gICAgICAgIGlmIChzdHIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKGF0dHJpYnV0ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoYXR0cmlidXRlLCBzdHIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ29udmVydHMgYSB0eXBlZCBKYXZhU2NyaXB0IHZhbHVlIHRvIGEgc3RyaW5nLlxuICAgICAgICpcbiAgICAgICAqIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCBieSBQb2x5bWVyIHdoZW4gc2V0dGluZyBKUyBwcm9wZXJ0eSB2YWx1ZXMgdG9cbiAgICAgICAqIEhUTUwgYXR0cmlidXRlcy4gIFVzZXJzIG1heSBvdmVycmlkZSB0aGlzIG1ldGhvZCBvbiBQb2x5bWVyIGVsZW1lbnRcbiAgICAgICAqIHByb3RvdHlwZXMgdG8gcHJvdmlkZSBzZXJpYWxpemF0aW9uIGZvciBjdXN0b20gdHlwZXMuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBQcm9wZXJ0eSB2YWx1ZSB0byBzZXJpYWxpemUuXG4gICAgICAgKiBAcmV0dXJuIHtzdHJpbmcgfCB1bmRlZmluZWR9IFN0cmluZyBzZXJpYWxpemVkIGZyb20gdGhlIHByb3ZpZGVkIHByb3BlcnR5IHZhbHVlLlxuICAgICAgICovXG4gICAgICBfc2VyaWFsaXplVmFsdWUodmFsdWUpIHtcbiAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tZmFsbHRocm91Z2ggKi9cbiAgICAgICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSA/ICcnIDogdW5kZWZpbmVkO1xuXG4gICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCh4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlICE9IG51bGwgPyB2YWx1ZS50b1N0cmluZygpIDogdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ29udmVydHMgYSBzdHJpbmcgdG8gYSB0eXBlZCBKYXZhU2NyaXB0IHZhbHVlLlxuICAgICAgICpcbiAgICAgICAqIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCBieSBQb2x5bWVyIHdoZW4gcmVhZGluZyBIVE1MIGF0dHJpYnV0ZSB2YWx1ZXMgdG9cbiAgICAgICAqIEpTIHByb3BlcnRpZXMuICBVc2VycyBtYXkgb3ZlcnJpZGUgdGhpcyBtZXRob2Qgb24gUG9seW1lciBlbGVtZW50XG4gICAgICAgKiBwcm90b3R5cGVzIHRvIHByb3ZpZGUgZGVzZXJpYWxpemF0aW9uIGZvciBjdXN0b20gYHR5cGVgcy4gIE5vdGUsXG4gICAgICAgKiB0aGUgYHR5cGVgIGFyZ3VtZW50IGlzIHRoZSB2YWx1ZSBvZiB0aGUgYHR5cGVgIGZpZWxkIHByb3ZpZGVkIGluIHRoZVxuICAgICAgICogYHByb3BlcnRpZXNgIGNvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBhIGdpdmVuIHByb3BlcnR5LCBhbmQgaXNcbiAgICAgICAqIGJ5IGNvbnZlbnRpb24gdGhlIGNvbnN0cnVjdG9yIGZvciB0aGUgdHlwZSB0byBkZXNlcmlhbGl6ZS5cbiAgICAgICAqXG4gICAgICAgKiBOb3RlOiBUaGUgcmV0dXJuIHZhbHVlIG9mIGB1bmRlZmluZWRgIGlzIHVzZWQgYXMgYSBzZW50aW5lbCB2YWx1ZSB0b1xuICAgICAgICogaW5kaWNhdGUgdGhlIGF0dHJpYnV0ZSBzaG91bGQgYmUgcmVtb3ZlZC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0gez9zdHJpbmd9IHZhbHVlIEF0dHJpYnV0ZSB2YWx1ZSB0byBkZXNlcmlhbGl6ZS5cbiAgICAgICAqIEBwYXJhbSB7Kj19IHR5cGUgVHlwZSB0byBkZXNlcmlhbGl6ZSB0aGUgc3RyaW5nIHRvLlxuICAgICAgICogQHJldHVybiB7Kn0gVHlwZWQgdmFsdWUgZGVzZXJpYWxpemVkIGZyb20gdGhlIHByb3ZpZGVkIHN0cmluZy5cbiAgICAgICAqL1xuICAgICAgX2Rlc2VyaWFsaXplVmFsdWUodmFsdWUsIHR5cGUpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHsqfVxuICAgICAgICAgKi9cbiAgICAgICAgbGV0IG91dFZhbHVlO1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICBjYXNlIE51bWJlcjpcbiAgICAgICAgICAgIG91dFZhbHVlID0gTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBCb29sZWFuOlxuICAgICAgICAgICAgb3V0VmFsdWUgPSAodmFsdWUgIT09IG51bGwpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIE9iamVjdDpcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIG91dFZhbHVlID0gSlNPTi5wYXJzZSgvKiogQHR5cGUgc3RyaW5nICovKHZhbHVlKSk7XG4gICAgICAgICAgICB9IGNhdGNoKHgpIHtcbiAgICAgICAgICAgICAgLy8gYWxsb3cgbm9uLUpTT04gbGl0ZXJhbHMgbGlrZSBTdHJpbmdzIGFuZCBOdW1iZXJzXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgQXJyYXk6XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBvdXRWYWx1ZSA9IEpTT04ucGFyc2UoLyoqIEB0eXBlIHN0cmluZyAqLyh2YWx1ZSkpO1xuICAgICAgICAgICAgfSBjYXRjaCh4KSB7XG4gICAgICAgICAgICAgIG91dFZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBQb2x5bWVyOjpBdHRyaWJ1dGVzOiBjb3VsZG4ndCBkZWNvZGUgQXJyYXkgYXMgSlNPTjogJHt2YWx1ZX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBEYXRlOlxuICAgICAgICAgICAgb3V0VmFsdWUgPSBuZXcgRGF0ZSh2YWx1ZSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgU3RyaW5nOlxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBvdXRWYWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb3V0VmFsdWU7XG4gICAgICB9XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLWZhbGx0aHJvdWdoICovXG5cbiAgICAgIC8qKlxuICAgICAgICogQ3JlYXRlcyBhIHNldHRlci9nZXR0ZXIgcGFpciBmb3IgdGhlIG5hbWVkIHByb3BlcnR5IHdpdGggaXRzIG93blxuICAgICAgICogbG9jYWwgc3RvcmFnZS4gIFRoZSBnZXR0ZXIgcmV0dXJucyB0aGUgdmFsdWUgaW4gdGhlIGxvY2FsIHN0b3JhZ2UsXG4gICAgICAgKiBhbmQgdGhlIHNldHRlciBjYWxscyBgX3NldFByb3BlcnR5YCwgd2hpY2ggdXBkYXRlcyB0aGUgbG9jYWwgc3RvcmFnZVxuICAgICAgICogZm9yIHRoZSBwcm9wZXJ0eSBhbmQgZW5xdWV1ZXMgYSBgX3Byb3BlcnRpZXNDaGFuZ2VkYCBjYWxsYmFjay5cbiAgICAgICAqXG4gICAgICAgKiBUaGlzIG1ldGhvZCBtYXkgYmUgY2FsbGVkIG9uIGEgcHJvdG90eXBlIG9yIGFuIGluc3RhbmNlLiAgQ2FsbGluZ1xuICAgICAgICogdGhpcyBtZXRob2QgbWF5IG92ZXJ3cml0ZSBhIHByb3BlcnR5IHZhbHVlIHRoYXQgYWxyZWFkeSBleGlzdHMgb25cbiAgICAgICAqIHRoZSBwcm90b3R5cGUvaW5zdGFuY2UgYnkgY3JlYXRpbmcgdGhlIGFjY2Vzc29yLiAgV2hlbiBjYWxsaW5nIG9uXG4gICAgICAgKiBhIHByb3RvdHlwZSwgYW55IG92ZXJ3cml0dGVuIHZhbHVlcyBhcmUgc2F2ZWQgaW4gYF9fZGF0YVByb3RvYCxcbiAgICAgICAqIGFuZCBpdCBpcyB1cCB0byB0aGUgc3ViY2xhc3NlciB0byBkZWNpZGUgaG93L3doZW4gdG8gc2V0IHRob3NlXG4gICAgICAgKiBwcm9wZXJ0aWVzIGJhY2sgaW50byB0aGUgYWNjZXNzb3IuICBXaGVuIGNhbGxpbmcgb24gYW4gaW5zdGFuY2UsXG4gICAgICAgKiB0aGUgb3ZlcndyaXR0ZW4gdmFsdWUgaXMgc2V0IHZpYSBgX3NldFBlbmRpbmdQcm9wZXJ0eWAsIGFuZCB0aGVcbiAgICAgICAqIHVzZXIgc2hvdWxkIGNhbGwgYF9pbnZhbGlkYXRlUHJvcGVydGllc2Agb3IgYF9mbHVzaFByb3BlcnRpZXNgXG4gICAgICAgKiBmb3IgdGhlIHZhbHVlcyB0byB0YWtlIGVmZmVjdC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgTmFtZSBvZiB0aGUgcHJvcGVydHlcbiAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IHJlYWRPbmx5IFdoZW4gdHJ1ZSwgbm8gc2V0dGVyIGlzIGNyZWF0ZWQ7IHRoZVxuICAgICAgICogICBwcm90ZWN0ZWQgYF9zZXRQcm9wZXJ0eWAgZnVuY3Rpb24gbXVzdCBiZSB1c2VkIHRvIHNldCB0aGUgcHJvcGVydHlcbiAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAqL1xuICAgICAgX2NyZWF0ZVByb3BlcnR5QWNjZXNzb3IocHJvcGVydHksIHJlYWRPbmx5KSB7XG4gICAgICAgIGlmICghdGhpcy5oYXNPd25Qcm9wZXJ0eSgnX19kYXRhSGFzQWNjZXNzb3InKSkge1xuICAgICAgICAgIHRoaXMuX19kYXRhSGFzQWNjZXNzb3IgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLl9fZGF0YUhhc0FjY2Vzc29yKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX19kYXRhSGFzQWNjZXNzb3JbcHJvcGVydHldKSB7XG4gICAgICAgICAgdGhpcy5fX2RhdGFIYXNBY2Nlc3Nvcltwcm9wZXJ0eV0gPSB0cnVlO1xuICAgICAgICAgIHNhdmVBY2Nlc3NvclZhbHVlKHRoaXMsIHByb3BlcnR5KTtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgcHJvcGVydHksIHtcbiAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIHZhbGlkLWpzZG9jICovXG4gICAgICAgICAgICAvKiogQHRoaXMge1Byb3BlcnR5QWNjZXNzb3JzfSAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX19kYXRhW3Byb3BlcnR5XTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvKiogQHRoaXMge1Byb3BlcnR5QWNjZXNzb3JzfSAqL1xuICAgICAgICAgICAgc2V0OiByZWFkT25seSA/IGZ1bmN0aW9uKCkge30gOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICB0aGlzLl9zZXRQcm9wZXJ0eShwcm9wZXJ0eSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogZXNsaW50LWVuYWJsZSAqL1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgbGlicmFyeSBjcmVhdGVkIGFuIGFjY2Vzc29yIGZvciB0aGUgZ2l2ZW4gcHJvcGVydHkuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IG5hbWVcbiAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYW4gYWNjZXNzb3Igd2FzIGNyZWF0ZWRcbiAgICAgICAqL1xuICAgICAgX2hhc0FjY2Vzc29yKHByb3BlcnR5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fZGF0YUhhc0FjY2Vzc29yICYmIHRoaXMuX19kYXRhSGFzQWNjZXNzb3JbcHJvcGVydHldO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFVwZGF0ZXMgdGhlIGxvY2FsIHN0b3JhZ2UgZm9yIGEgcHJvcGVydHkgKHZpYSBgX3NldFBlbmRpbmdQcm9wZXJ0eWApXG4gICAgICAgKiBhbmQgZW5xdWV1ZXMgYSBgX3Byb2VwcnRpZXNDaGFuZ2VkYCBjYWxsYmFjay5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgTmFtZSBvZiB0aGUgcHJvcGVydHlcbiAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgdG8gc2V0XG4gICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgKi9cbiAgICAgIF9zZXRQcm9wZXJ0eShwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuX3NldFBlbmRpbmdQcm9wZXJ0eShwcm9wZXJ0eSwgdmFsdWUpKSB7XG4gICAgICAgICAgdGhpcy5faW52YWxpZGF0ZVByb3BlcnRpZXMoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFVwZGF0ZXMgdGhlIGxvY2FsIHN0b3JhZ2UgZm9yIGEgcHJvcGVydHksIHJlY29yZHMgdGhlIHByZXZpb3VzIHZhbHVlLFxuICAgICAgICogYW5kIGFkZHMgaXQgdG8gdGhlIHNldCBvZiBcInBlbmRpbmcgY2hhbmdlc1wiIHRoYXQgd2lsbCBiZSBwYXNzZWQgdG8gdGhlXG4gICAgICAgKiBgX3Byb3BlcnRpZXNDaGFuZ2VkYCBjYWxsYmFjay4gIFRoaXMgbWV0aG9kIGRvZXMgbm90IGVucXVldWUgdGhlXG4gICAgICAgKiBgX3Byb3BlcnRpZXNDaGFuZ2VkYCBjYWxsYmFjay5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgTmFtZSBvZiB0aGUgcHJvcGVydHlcbiAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgdG8gc2V0XG4gICAgICAgKiBAcmV0dXJuIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgdGhlIHByb3BlcnR5IGNoYW5nZWRcbiAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAqL1xuICAgICAgX3NldFBlbmRpbmdQcm9wZXJ0eShwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgICAgICAgbGV0IG9sZCA9IHRoaXMuX19kYXRhW3Byb3BlcnR5XTtcbiAgICAgICAgbGV0IGNoYW5nZWQgPSB0aGlzLl9zaG91bGRQcm9wZXJ0eUNoYW5nZShwcm9wZXJ0eSwgdmFsdWUsIG9sZClcbiAgICAgICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgICAgICBpZiAoIXRoaXMuX19kYXRhUGVuZGluZykge1xuICAgICAgICAgICAgdGhpcy5fX2RhdGFQZW5kaW5nID0ge307XG4gICAgICAgICAgICB0aGlzLl9fZGF0YU9sZCA9IHt9O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBFbnN1cmUgb2xkIGlzIGNhcHR1cmVkIGZyb20gdGhlIGxhc3QgdHVyblxuICAgICAgICAgIGlmICh0aGlzLl9fZGF0YU9sZCAmJiAhKHByb3BlcnR5IGluIHRoaXMuX19kYXRhT2xkKSkge1xuICAgICAgICAgICAgdGhpcy5fX2RhdGFPbGRbcHJvcGVydHldID0gb2xkO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9fZGF0YVtwcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICAgICAgICB0aGlzLl9fZGF0YVBlbmRpbmdbcHJvcGVydHldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNoYW5nZWQ7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBzcGVjaWZpZWQgcHJvcGVydHkgaGFzIGEgcGVuZGluZyBjaGFuZ2UuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3AgUHJvcGVydHkgbmFtZVxuICAgICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBwcm9wZXJ0eSBoYXMgYSBwZW5kaW5nIGNoYW5nZVxuICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICovXG4gICAgICBfaXNQcm9wZXJ0eVBlbmRpbmcocHJvcCkge1xuICAgICAgICByZXR1cm4gQm9vbGVhbih0aGlzLl9fZGF0YVBlbmRpbmcgJiYgKHByb3AgaW4gdGhpcy5fX2RhdGFQZW5kaW5nKSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogTWFya3MgdGhlIHByb3BlcnRpZXMgYXMgaW52YWxpZCwgYW5kIGVucXVldWVzIGFuIGFzeW5jXG4gICAgICAgKiBgX3Byb3BlcnRpZXNDaGFuZ2VkYCBjYWxsYmFjay5cbiAgICAgICAqXG4gICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgKi9cbiAgICAgIF9pbnZhbGlkYXRlUHJvcGVydGllcygpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9fZGF0YUludmFsaWQgJiYgdGhpcy5fX2RhdGFSZWFkeSkge1xuICAgICAgICAgIHRoaXMuX19kYXRhSW52YWxpZCA9IHRydWU7XG4gICAgICAgICAgbWljcm90YXNrLnJ1bigoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5fX2RhdGFJbnZhbGlkKSB7XG4gICAgICAgICAgICAgIHRoaXMuX19kYXRhSW52YWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgICB0aGlzLl9mbHVzaFByb3BlcnRpZXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENhbGwgdG8gZW5hYmxlIHByb3BlcnR5IGFjY2Vzc29yIHByb2Nlc3NpbmcuIEJlZm9yZSB0aGlzIG1ldGhvZCBpc1xuICAgICAgICogY2FsbGVkIGFjY2Vzc29yIHZhbHVlcyB3aWxsIGJlIHNldCBidXQgc2lkZSBlZmZlY3RzIGFyZVxuICAgICAgICogcXVldWVkLiBXaGVuIGNhbGxlZCwgYW55IHBlbmRpbmcgc2lkZSBlZmZlY3RzIG9jY3VyIGltbWVkaWF0ZWx5LlxuICAgICAgICogRm9yIGVsZW1lbnRzLCBnZW5lcmFsbHkgYGNvbm5lY3RlZENhbGxiYWNrYCBpcyBhIG5vcm1hbCBzcG90IHRvIGRvIHNvLlxuICAgICAgICogSXQgaXMgc2FmZSB0byBjYWxsIHRoaXMgbWV0aG9kIG11bHRpcGxlIHRpbWVzIGFzIGl0IG9ubHkgdHVybnMgb25cbiAgICAgICAqIHByb3BlcnR5IGFjY2Vzc29ycyBvbmNlLlxuICAgICAgICovXG4gICAgICBfZW5hYmxlUHJvcGVydGllcygpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9fZGF0YUVuYWJsZWQpIHtcbiAgICAgICAgICB0aGlzLl9fZGF0YUVuYWJsZWQgPSB0cnVlO1xuICAgICAgICAgIGlmICh0aGlzLl9fZGF0YUluc3RhbmNlUHJvcHMpIHtcbiAgICAgICAgICAgIHRoaXMuX2luaXRpYWxpemVJbnN0YW5jZVByb3BlcnRpZXModGhpcy5fX2RhdGFJbnN0YW5jZVByb3BzKTtcbiAgICAgICAgICAgIHRoaXMuX19kYXRhSW5zdGFuY2VQcm9wcyA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMucmVhZHkoKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ2FsbHMgdGhlIGBfcHJvcGVydGllc0NoYW5nZWRgIGNhbGxiYWNrIHdpdGggdGhlIGN1cnJlbnQgc2V0IG9mXG4gICAgICAgKiBwZW5kaW5nIGNoYW5nZXMgKGFuZCBvbGQgdmFsdWVzIHJlY29yZGVkIHdoZW4gcGVuZGluZyBjaGFuZ2VzIHdlcmVcbiAgICAgICAqIHNldCksIGFuZCByZXNldHMgdGhlIHBlbmRpbmcgc2V0IG9mIGNoYW5nZXMuIEdlbmVyYWxseSwgdGhpcyBtZXRob2RcbiAgICAgICAqIHNob3VsZCBub3QgYmUgY2FsbGVkIGluIHVzZXIgY29kZS5cbiAgICAgICAqXG4gICAgICAgKlxuICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICovXG4gICAgICBfZmx1c2hQcm9wZXJ0aWVzKCkge1xuICAgICAgICBpZiAodGhpcy5fX2RhdGFQZW5kaW5nICYmIHRoaXMuX19kYXRhT2xkKSB7XG4gICAgICAgICAgbGV0IGNoYW5nZWRQcm9wcyA9IHRoaXMuX19kYXRhUGVuZGluZztcbiAgICAgICAgICB0aGlzLl9fZGF0YVBlbmRpbmcgPSBudWxsO1xuICAgICAgICAgIHRoaXMuX19kYXRhQ291bnRlcisrO1xuICAgICAgICAgIHRoaXMuX3Byb3BlcnRpZXNDaGFuZ2VkKHRoaXMuX19kYXRhLCBjaGFuZ2VkUHJvcHMsIHRoaXMuX19kYXRhT2xkKTtcbiAgICAgICAgICB0aGlzLl9fZGF0YUNvdW50ZXItLTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIExpZmVjeWNsZSBjYWxsYmFjayBjYWxsZWQgdGhlIGZpcnN0IHRpbWUgcHJvcGVydGllcyBhcmUgYmVpbmcgZmx1c2hlZC5cbiAgICAgICAqIFByaW9yIHRvIGByZWFkeWAsIGFsbCBwcm9wZXJ0eSBzZXRzIHRocm91Z2ggYWNjZXNzb3JzIGFyZSBxdWV1ZWQgYW5kXG4gICAgICAgKiB0aGVpciBlZmZlY3RzIGFyZSBmbHVzaGVkIGFmdGVyIHRoaXMgbWV0aG9kIHJldHVybnMuXG4gICAgICAgKlxuICAgICAgICogVXNlcnMgbWF5IG92ZXJyaWRlIHRoaXMgZnVuY3Rpb24gdG8gaW1wbGVtZW50IGJlaGF2aW9yIHRoYXQgaXNcbiAgICAgICAqIGRlcGVuZGVudCBvbiB0aGUgZWxlbWVudCBoYXZpbmcgaXRzIHByb3BlcnRpZXMgaW5pdGlhbGl6ZWQsIGUuZy5cbiAgICAgICAqIGZyb20gZGVmYXVsdHMgKGluaXRpYWxpemVkIGZyb20gYGNvbnN0cnVjdG9yYCwgYF9pbml0aWFsaXplUHJvcGVydGllc2ApLFxuICAgICAgICogYGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFja2AsIG9yIHZhbHVlcyBwcm9wYWdhdGVkIGZyb20gaG9zdCBlLmcuIHZpYVxuICAgICAgICogYmluZGluZ3MuICBgc3VwZXIucmVhZHkoKWAgbXVzdCBiZSBjYWxsZWQgdG8gZW5zdXJlIHRoZSBkYXRhIHN5c3RlbVxuICAgICAgICogYmVjb21lcyBlbmFibGVkLlxuICAgICAgICpcbiAgICAgICAqIEBwdWJsaWNcbiAgICAgICAqL1xuICAgICAgcmVhZHkoKSB7XG4gICAgICAgIHRoaXMuX19kYXRhUmVhZHkgPSB0cnVlO1xuICAgICAgICAvLyBSdW4gbm9ybWFsIGZsdXNoXG4gICAgICAgIHRoaXMuX2ZsdXNoUHJvcGVydGllcygpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENhbGxiYWNrIGNhbGxlZCB3aGVuIGFueSBwcm9wZXJ0aWVzIHdpdGggYWNjZXNzb3JzIGNyZWF0ZWQgdmlhXG4gICAgICAgKiBgX2NyZWF0ZVByb3BlcnR5QWNjZXNzb3JgIGhhdmUgYmVlbiBzZXQuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHshT2JqZWN0fSBjdXJyZW50UHJvcHMgQmFnIG9mIGFsbCBjdXJyZW50IGFjY2Vzc29yIHZhbHVlc1xuICAgICAgICogQHBhcmFtIHshT2JqZWN0fSBjaGFuZ2VkUHJvcHMgQmFnIG9mIHByb3BlcnRpZXMgY2hhbmdlZCBzaW5jZSB0aGUgbGFzdFxuICAgICAgICogICBjYWxsIHRvIGBfcHJvcGVydGllc0NoYW5nZWRgXG4gICAgICAgKiBAcGFyYW0geyFPYmplY3R9IG9sZFByb3BzIEJhZyBvZiBwcmV2aW91cyB2YWx1ZXMgZm9yIGVhY2ggcHJvcGVydHlcbiAgICAgICAqICAgaW4gYGNoYW5nZWRQcm9wc2BcbiAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAqL1xuICAgICAgX3Byb3BlcnRpZXNDaGFuZ2VkKGN1cnJlbnRQcm9wcywgY2hhbmdlZFByb3BzLCBvbGRQcm9wcykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogTWV0aG9kIGNhbGxlZCB0byBkZXRlcm1pbmUgd2hldGhlciBhIHByb3BlcnR5IHZhbHVlIHNob3VsZCBiZVxuICAgICAgICogY29uc2lkZXJlZCBhcyBhIGNoYW5nZSBhbmQgY2F1c2UgdGhlIGBfcHJvcGVydGllc0NoYW5nZWRgIGNhbGxiYWNrXG4gICAgICAgKiB0byBiZSBlbnF1ZXVlZC5cbiAgICAgICAqXG4gICAgICAgKiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiByZXR1cm5zIGB0cnVlYCBmb3IgcHJpbWl0aXZlIHR5cGVzIGlmIGFcbiAgICAgICAqIHN0cmljdCBlcXVhbGl0eSBjaGVjayBmYWlscywgYW5kIHJldHVybnMgYHRydWVgIGZvciBhbGwgT2JqZWN0L0FycmF5cy5cbiAgICAgICAqIFRoZSBtZXRob2QgYWx3YXlzIHJldHVybnMgZmFsc2UgZm9yIGBOYU5gLlxuICAgICAgICpcbiAgICAgICAqIE92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIGUuZy4gcHJvdmlkZSBzdHJpY3RlciBjaGVja2luZyBmb3JcbiAgICAgICAqIE9iamVjdHMvQXJyYXlzIHdoZW4gdXNpbmcgaW1tdXRhYmxlIHBhdHRlcm5zLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSBuYW1lXG4gICAgICAgKiBAcGFyYW0geyp9IHZhbHVlIE5ldyBwcm9wZXJ0eSB2YWx1ZVxuICAgICAgICogQHBhcmFtIHsqfSBvbGQgUHJldmlvdXMgcHJvcGVydHkgdmFsdWVcbiAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIHByb3BlcnR5IHNob3VsZCBiZSBjb25zaWRlcmVkIGEgY2hhbmdlXG4gICAgICAgKiAgIGFuZCBlbnF1ZXVlIGEgYF9wcm9lcHJ0aWVzQ2hhbmdlZGAgY2FsbGJhY2tcbiAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAqL1xuICAgICAgX3Nob3VsZFByb3BlcnR5Q2hhbmdlKHByb3BlcnR5LCB2YWx1ZSwgb2xkKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgLy8gU3RyaWN0IGVxdWFsaXR5IGNoZWNrXG4gICAgICAgICAgKG9sZCAhPT0gdmFsdWUgJiZcbiAgICAgICAgICAgLy8gVGhpcyBlbnN1cmVzIChvbGQ9PU5hTiwgdmFsdWU9PU5hTikgYWx3YXlzIHJldHVybnMgZmFsc2VcbiAgICAgICAgICAgKG9sZCA9PT0gb2xkIHx8IHZhbHVlID09PSB2YWx1ZSkpXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICB9XG5cbiAgICByZXR1cm4gUHJvcGVydHlBY2Nlc3NvcnM7XG5cbiAgfSk7XG5cbn0pKCk7XG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvbWl4aW5zL3Byb3BlcnR5LWFjY2Vzc29ycy5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuXG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vdXRpbHMvYm9vdC5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vdXRpbHMvbWl4aW4uaHRtbFwiPlxuXG48c2NyaXB0PlxuKGZ1bmN0aW9uKCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICAvLyAxLnggYmFja3dhcmRzLWNvbXBhdGlibGUgYXV0by13cmFwcGVyIGZvciB0ZW1wbGF0ZSB0eXBlIGV4dGVuc2lvbnNcbiAgLy8gVGhpcyBpcyBhIGNsZWFyIGxheWVyaW5nIHZpb2xhdGlvbiBhbmQgZ2l2ZXMgZmF2b3JlZC1uYXRpb24gc3RhdHVzIHRvXG4gIC8vIGRvbS1pZiBhbmQgZG9tLXJlcGVhdCB0ZW1wbGF0ZXMuICBUaGlzIGlzIGEgY29uY2VpdCB3ZSdyZSBjaG9vc2luZyB0byBrZWVwXG4gIC8vIGEuKSB0byBlYXNlIDEueCBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eSBkdWUgdG8gbG9zcyBvZiBgaXNgLCBhbmRcbiAgLy8gYi4pIHRvIG1haW50YWluIGlmL3JlcGVhdCBjYXBhYmlsaXR5IGluIHBhcnNlci1jb25zdHJhaW5lZCBlbGVtZW50c1xuICAvLyAgICAgKGUuZy4gdGFibGUsIHNlbGVjdCkgaW4gbGlldSBvZiBuYXRpdmUgQ0UgdHlwZSBleHRlbnNpb25zIHdpdGhvdXRcbiAgLy8gICAgIG1hc3NpdmUgbmV3IGludmVudGlvbiBpbiB0aGlzIHNwYWNlIChlLmcuIGRpcmVjdGl2ZSBzeXN0ZW0pXG4gIGNvbnN0IHRlbXBsYXRlRXh0ZW5zaW9ucyA9IHtcbiAgICAnZG9tLWlmJzogdHJ1ZSxcbiAgICAnZG9tLXJlcGVhdCc6IHRydWVcbiAgfTtcbiAgZnVuY3Rpb24gd3JhcFRlbXBsYXRlRXh0ZW5zaW9uKG5vZGUpIHtcbiAgICBsZXQgaXMgPSBub2RlLmdldEF0dHJpYnV0ZSgnaXMnKTtcbiAgICBpZiAoaXMgJiYgdGVtcGxhdGVFeHRlbnNpb25zW2lzXSkge1xuICAgICAgbGV0IHQgPSBub2RlO1xuICAgICAgdC5yZW1vdmVBdHRyaWJ1dGUoJ2lzJyk7XG4gICAgICBub2RlID0gdC5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoaXMpO1xuICAgICAgdC5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChub2RlLCB0KTtcbiAgICAgIG5vZGUuYXBwZW5kQ2hpbGQodCk7XG4gICAgICB3aGlsZSh0LmF0dHJpYnV0ZXMubGVuZ3RoKSB7XG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKHQuYXR0cmlidXRlc1swXS5uYW1lLCB0LmF0dHJpYnV0ZXNbMF0udmFsdWUpO1xuICAgICAgICB0LnJlbW92ZUF0dHJpYnV0ZSh0LmF0dHJpYnV0ZXNbMF0ubmFtZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgZnVuY3Rpb24gZmluZFRlbXBsYXRlTm9kZShyb290LCBub2RlSW5mbykge1xuICAgIC8vIHJlY3Vyc2l2ZWx5IGFzY2VuZCB0cmVlIHVudGlsIHdlIGhpdCByb290XG4gICAgbGV0IHBhcmVudCA9IG5vZGVJbmZvLnBhcmVudEluZm8gJiYgZmluZFRlbXBsYXRlTm9kZShyb290LCBub2RlSW5mby5wYXJlbnRJbmZvKTtcbiAgICAvLyB1bndpbmQgdGhlIHN0YWNrLCByZXR1cm5pbmcgdGhlIGluZGV4ZWQgbm9kZSBhdCBlYWNoIGxldmVsXG4gICAgaWYgKHBhcmVudCkge1xuICAgICAgLy8gbm90ZTogbWFyZ2luYWxseSBmYXN0ZXIgdGhhbiBpbmRleGluZyB2aWEgY2hpbGROb2Rlc1xuICAgICAgLy8gKGh0dHA6Ly9qc3BlcmYuY29tL2NoaWxkbm9kZXMtbG9va3VwKVxuICAgICAgZm9yIChsZXQgbj1wYXJlbnQuZmlyc3RDaGlsZCwgaT0wOyBuOyBuPW4ubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgaWYgKG5vZGVJbmZvLnBhcmVudEluZGV4ID09PSBpKyspIHtcbiAgICAgICAgICByZXR1cm4gbjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcm9vdDtcbiAgICB9XG4gIH1cblxuICAvLyBjb25zdHJ1Y3QgYCRgIG1hcCAoZnJvbSBpZCBhbm5vdGF0aW9ucylcbiAgZnVuY3Rpb24gYXBwbHlJZFRvTWFwKGluc3QsIG1hcCwgbm9kZSwgbm9kZUluZm8pIHtcbiAgICBpZiAobm9kZUluZm8uaWQpIHtcbiAgICAgIG1hcFtub2RlSW5mby5pZF0gPSBub2RlO1xuICAgIH1cbiAgfVxuXG4gIC8vIGluc3RhbGwgZXZlbnQgbGlzdGVuZXJzIChmcm9tIGV2ZW50IGFubm90YXRpb25zKVxuICBmdW5jdGlvbiBhcHBseUV2ZW50TGlzdGVuZXIoaW5zdCwgbm9kZSwgbm9kZUluZm8pIHtcbiAgICBpZiAobm9kZUluZm8uZXZlbnRzICYmIG5vZGVJbmZvLmV2ZW50cy5sZW5ndGgpIHtcbiAgICAgIGZvciAobGV0IGo9MCwgZSQ9bm9kZUluZm8uZXZlbnRzLCBlOyAoajxlJC5sZW5ndGgpICYmIChlPWUkW2pdKTsgaisrKSB7XG4gICAgICAgIGluc3QuX2FkZE1ldGhvZEV2ZW50TGlzdGVuZXJUb05vZGUobm9kZSwgZS5uYW1lLCBlLnZhbHVlLCBpbnN0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBwdXNoIGNvbmZpZ3VyYXRpb24gcmVmZXJlbmNlcyBhdCBjb25maWd1cmUgdGltZVxuICBmdW5jdGlvbiBhcHBseVRlbXBsYXRlQ29udGVudChpbnN0LCBub2RlLCBub2RlSW5mbykge1xuICAgIGlmIChub2RlSW5mby50ZW1wbGF0ZUluZm8pIHtcbiAgICAgIG5vZGUuX3RlbXBsYXRlSW5mbyA9IG5vZGVJbmZvLnRlbXBsYXRlSW5mbztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVOb2RlRXZlbnRIYW5kbGVyKGNvbnRleHQsIGV2ZW50TmFtZSwgbWV0aG9kTmFtZSkge1xuICAgIC8vIEluc3RhbmNlcyBjYW4gb3B0aW9uYWxseSBoYXZlIGEgX21ldGhvZEhvc3Qgd2hpY2ggYWxsb3dzIHJlZGlyZWN0aW5nIHdoZXJlXG4gICAgLy8gdG8gZmluZCBtZXRob2RzLiBDdXJyZW50bHkgdXNlZCBieSBgdGVtcGxhdGl6ZWAuXG4gICAgY29udGV4dCA9IGNvbnRleHQuX21ldGhvZEhvc3QgfHwgY29udGV4dDtcbiAgICBsZXQgaGFuZGxlciA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgIGlmIChjb250ZXh0W21ldGhvZE5hbWVdKSB7XG4gICAgICAgIGNvbnRleHRbbWV0aG9kTmFtZV0oZSwgZS5kZXRhaWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdsaXN0ZW5lciBtZXRob2QgYCcgKyBtZXRob2ROYW1lICsgJ2Agbm90IGRlZmluZWQnKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBoYW5kbGVyO1xuICB9XG5cbiAgLyoqXG4gICAqIEVsZW1lbnQgbWl4aW4gdGhhdCBwcm92aWRlcyBiYXNpYyB0ZW1wbGF0ZSBwYXJzaW5nIGFuZCBzdGFtcGluZywgaW5jbHVkaW5nXG4gICAqIHRoZSBmb2xsb3dpbmcgdGVtcGxhdGUtcmVsYXRlZCBmZWF0dXJlcyBmb3Igc3RhbXBlZCB0ZW1wbGF0ZXM6XG4gICAqXG4gICAqIC0gRGVjbGFyYXRpdmUgZXZlbnQgbGlzdGVuZXJzIChgb24tZXZlbnRuYW1lPVwibGlzdGVuZXJcImApXG4gICAqIC0gTWFwIG9mIG5vZGUgaWQncyB0byBzdGFtcGVkIG5vZGUgaW5zdGFuY2VzIChgdGhpcy4kLmlkYClcbiAgICogLSBOZXN0ZWQgdGVtcGxhdGUgY29udGVudCBjYWNoaW5nL3JlbW92YWwgYW5kIHJlLWluc3RhbGxhdGlvbiAocGVyZm9ybWFuY2VcbiAgICogICBvcHRpbWl6YXRpb24pXG4gICAqXG4gICAqIEBtaXhpbkZ1bmN0aW9uXG4gICAqIEBwb2x5bWVyXG4gICAqIEBtZW1iZXJvZiBQb2x5bWVyXG4gICAqIEBzdW1tYXJ5IEVsZW1lbnQgY2xhc3MgbWl4aW4gdGhhdCBwcm92aWRlcyBiYXNpYyB0ZW1wbGF0ZSBwYXJzaW5nIGFuZCBzdGFtcGluZ1xuICAgKi9cbiAgUG9seW1lci5UZW1wbGF0ZVN0YW1wID0gUG9seW1lci5kZWR1cGluZ01peGluKHN1cGVyQ2xhc3MgPT4ge1xuXG4gICAgLyoqXG4gICAgICogQHBvbHltZXJcbiAgICAgKiBAbWl4aW5DbGFzc1xuICAgICAqIEBpbXBsZW1lbnRzIHtQb2x5bWVyX1RlbXBsYXRlU3RhbXB9XG4gICAgICovXG4gICAgY2xhc3MgVGVtcGxhdGVTdGFtcCBleHRlbmRzIHN1cGVyQ2xhc3Mge1xuXG4gICAgICAvKipcbiAgICAgICAqIFNjYW5zIGEgdGVtcGxhdGUgdG8gcHJvZHVjZSB0ZW1wbGF0ZSBtZXRhZGF0YS5cbiAgICAgICAqXG4gICAgICAgKiBUZW1wbGF0ZS1zcGVjaWZpYyBtZXRhZGF0YSBhcmUgc3RvcmVkIGluIHRoZSBvYmplY3QgcmV0dXJuZWQsIGFuZCBub2RlLVxuICAgICAgICogc3BlY2lmaWMgbWV0YWRhdGEgYXJlIHN0b3JlZCBpbiBvYmplY3RzIGluIGl0cyBmbGF0dGVuZWQgYG5vZGVJbmZvTGlzdGBcbiAgICAgICAqIGFycmF5LiAgT25seSBub2RlcyBpbiB0aGUgdGVtcGxhdGUgdGhhdCB3ZXJlIHBhcnNlZCBhcyBub2RlcyBvZlxuICAgICAgICogaW50ZXJlc3QgY29udGFpbiBhbiBvYmplY3QgaW4gYG5vZGVJbmZvTGlzdGAuICBFYWNoIGBub2RlSW5mb2Agb2JqZWN0XG4gICAgICAgKiBjb250YWlucyBhbiBgaW5kZXhgIChgY2hpbGROb2Rlc2AgaW5kZXggaW4gcGFyZW50KSBhbmQgb3B0aW9uYWxseVxuICAgICAgICogYHBhcmVudGAsIHdoaWNoIHBvaW50cyB0byBub2RlIGluZm8gb2YgaXRzIHBhcmVudCAoaW5jbHVkaW5nIGl0cyBpbmRleCkuXG4gICAgICAgKlxuICAgICAgICogVGhlIHRlbXBsYXRlIG1ldGFkYXRhIG9iamVjdCByZXR1cm5lZCBmcm9tIHRoaXMgbWV0aG9kIGhhcyB0aGUgZm9sbG93aW5nXG4gICAgICAgKiBzdHJ1Y3R1cmUgKG1hbnkgZmllbGRzIG9wdGlvbmFsKTpcbiAgICAgICAqXG4gICAgICAgKiBgYGBqc1xuICAgICAgICogICB7XG4gICAgICAgKiAgICAgLy8gRmxhdHRlbmVkIGxpc3Qgb2Ygbm9kZSBtZXRhZGF0YSAoZm9yIG5vZGVzIHRoYXQgZ2VuZXJhdGVkIG1ldGFkYXRhKVxuICAgICAgICogICAgIG5vZGVJbmZvTGlzdDogW1xuICAgICAgICogICAgICAge1xuICAgICAgICogICAgICAgICAvLyBgaWRgIGF0dHJpYnV0ZSBmb3IgYW55IG5vZGVzIHdpdGggaWQncyBmb3IgZ2VuZXJhdGluZyBgJGAgbWFwXG4gICAgICAgKiAgICAgICAgIGlkOiB7c3RyaW5nfSxcbiAgICAgICAqICAgICAgICAgLy8gYG9uLWV2ZW50PVwiaGFuZGxlclwiYCBtZXRhZGF0YVxuICAgICAgICogICAgICAgICBldmVudHM6IFtcbiAgICAgICAqICAgICAgICAgICB7XG4gICAgICAgKiAgICAgICAgICAgICBuYW1lOiB7c3RyaW5nfSwgICAvLyBldmVudCBuYW1lXG4gICAgICAgKiAgICAgICAgICAgICB2YWx1ZToge3N0cmluZ30sICAvLyBoYW5kbGVyIG1ldGhvZCBuYW1lXG4gICAgICAgKiAgICAgICAgICAgfSwgLi4uXG4gICAgICAgKiAgICAgICAgIF0sXG4gICAgICAgKiAgICAgICAgIC8vIE5vdGVzIHdoZW4gdGhlIHRlbXBsYXRlIGNvbnRhaW5lZCBhIGA8c2xvdD5gIGZvciBzaGFkeSBET01cbiAgICAgICAqICAgICAgICAgLy8gb3B0aW1pemF0aW9uIHB1cnBvc2VzXG4gICAgICAgKiAgICAgICAgIGhhc0luc2VydGlvblBvaW50OiB7Ym9vbGVhbn0sXG4gICAgICAgKiAgICAgICAgIC8vIEZvciBuZXN0ZWQgYDx0ZW1wbGF0ZT5gYCBub2RlcywgbmVzdGVkIHRlbXBsYXRlIG1ldGFkYXRhXG4gICAgICAgKiAgICAgICAgIHRlbXBsYXRlSW5mbzoge29iamVjdH0sIC8vIG5lc3RlZCB0ZW1wbGF0ZSBtZXRhZGF0YVxuICAgICAgICogICAgICAgICAvLyBNZXRhZGF0YSB0byBhbGxvdyBlZmZpY2llbnQgcmV0cmlldmFsIG9mIGluc3RhbmNlZCBub2RlXG4gICAgICAgKiAgICAgICAgIC8vIGNvcnJlc3BvbmRpbmcgdG8gdGhpcyBtZXRhZGF0YVxuICAgICAgICogICAgICAgICBwYXJlbnRJbmZvOiB7bnVtYmVyfSwgICAvLyByZWZlcmVuY2UgdG8gcGFyZW50IG5vZGVJbmZvPlxuICAgICAgICogICAgICAgICBwYXJlbnRJbmRleDoge251bWJlcn0sICAvLyBpbmRleCBpbiBwYXJlbnQncyBgY2hpbGROb2Rlc2AgY29sbGVjdGlvblxuICAgICAgICogICAgICAgICBpbmZvSW5kZXg6IHtudW1iZXJ9LCAgICAvLyBpbmRleCBvZiB0aGlzIGBub2RlSW5mb2AgaW4gYHRlbXBsYXRlSW5mby5ub2RlSW5mb0xpc3RgXG4gICAgICAgKiAgICAgICB9LFxuICAgICAgICogICAgICAgLi4uXG4gICAgICAgKiAgICAgXSxcbiAgICAgICAqICAgICAvLyBXaGVuIHRydWUsIHRoZSB0ZW1wbGF0ZSBoYWQgdGhlIGBzdHJpcC13aGl0ZXNwYWNlYCBhdHRyaWJ1dGVcbiAgICAgICAqICAgICAvLyBvciB3YXMgbmVzdGVkIGluIGEgdGVtcGxhdGUgd2l0aCB0aGF0IHNldHRpbmdcbiAgICAgICAqICAgICBzdHJpcFdoaXRlc3BhY2U6IHtib29sZWFufSxcbiAgICAgICAqICAgICAvLyBGb3IgbmVzdGVkIHRlbXBsYXRlcywgbmVzdGVkIHRlbXBsYXRlIGNvbnRlbnQgaXMgbW92ZWQgaW50b1xuICAgICAgICogICAgIC8vIGEgZG9jdW1lbnQgZnJhZ21lbnQgc3RvcmVkIGhlcmU7IHRoaXMgaXMgYW4gb3B0aW1pemF0aW9uIHRvXG4gICAgICAgKiAgICAgLy8gYXZvaWQgdGhlIGNvc3Qgb2YgbmVzdGVkIHRlbXBsYXRlIGNsb25pbmdcbiAgICAgICAqICAgICBjb250ZW50OiB7RG9jdW1lbnRGcmFnbWVudH1cbiAgICAgICAqICAgfVxuICAgICAgICogYGBgXG4gICAgICAgKlxuICAgICAgICogVGhpcyBtZXRob2Qga2lja3Mgb2ZmIGEgcmVjdXJzaXZlIHRyZWV3YWxrIGFzIGZvbGxvd3M6XG4gICAgICAgKlxuICAgICAgICogYGBgXG4gICAgICAgKiAgICBfcGFyc2VUZW1wbGF0ZSA8LS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICogICAgICBfcGFyc2VUZW1wbGF0ZUNvbnRlbnQgICAgICAgICAgICAgIHxcbiAgICAgICAqICAgICAgICBfcGFyc2VUZW1wbGF0ZU5vZGUgIDwtLS0tLS0tLS0tLS18LS0rXG4gICAgICAgKiAgICAgICAgICBfcGFyc2VUZW1wbGF0ZU5lc3RlZFRlbXBsYXRlIC0tKyAgfFxuICAgICAgICogICAgICAgICAgX3BhcnNlVGVtcGxhdGVDaGlsZE5vZGVzIC0tLS0tLS0tLStcbiAgICAgICAqICAgICAgICAgIF9wYXJzZVRlbXBsYXRlTm9kZUF0dHJpYnV0ZXNcbiAgICAgICAqICAgICAgICAgICAgX3BhcnNlVGVtcGxhdGVOb2RlQXR0cmlidXRlXG4gICAgICAgKlxuICAgICAgICogYGBgXG4gICAgICAgKlxuICAgICAgICogVGhlc2UgbWV0aG9kcyBtYXkgYmUgb3ZlcnJpZGRlbiB0byBhZGQgY3VzdG9tIG1ldGFkYXRhIGFib3V0IHRlbXBsYXRlc1xuICAgICAgICogdG8gZWl0aGVyIGB0ZW1wbGF0ZUluZm9gIG9yIGBub2RlSW5mb2AuXG4gICAgICAgKlxuICAgICAgICogTm90ZSB0aGF0IHRoaXMgbWV0aG9kIG1heSBiZSBkZXN0cnVjdGl2ZSB0byB0aGUgdGVtcGxhdGUsIGluIHRoYXRcbiAgICAgICAqIGUuZy4gZXZlbnQgYW5ub3RhdGlvbnMgbWF5IGJlIHJlbW92ZWQgYWZ0ZXIgYmVpbmcgbm90ZWQgaW4gdGhlXG4gICAgICAgKiB0ZW1wbGF0ZSBtZXRhZGF0YS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0geyFIVE1MVGVtcGxhdGVFbGVtZW50fSB0ZW1wbGF0ZSBUZW1wbGF0ZSB0byBwYXJzZVxuICAgICAgICogQHBhcmFtIHtUZW1wbGF0ZUluZm89fSBvdXRlclRlbXBsYXRlSW5mbyBUZW1wbGF0ZSBtZXRhZGF0YSBmcm9tIHRoZSBvdXRlclxuICAgICAgICogICB0ZW1wbGF0ZSwgZm9yIHBhcnNpbmcgbmVzdGVkIHRlbXBsYXRlc1xuICAgICAgICogQHJldHVybiB7IVRlbXBsYXRlSW5mb30gUGFyc2VkIHRlbXBsYXRlIG1ldGFkYXRhXG4gICAgICAgKi9cbiAgICAgIHN0YXRpYyBfcGFyc2VUZW1wbGF0ZSh0ZW1wbGF0ZSwgb3V0ZXJUZW1wbGF0ZUluZm8pIHtcbiAgICAgICAgLy8gc2luY2UgYSB0ZW1wbGF0ZSBtYXkgYmUgcmUtdXNlZCwgbWVtby1pemUgbWV0YWRhdGFcbiAgICAgICAgaWYgKCF0ZW1wbGF0ZS5fdGVtcGxhdGVJbmZvKSB7XG4gICAgICAgICAgbGV0IHRlbXBsYXRlSW5mbyA9IHRlbXBsYXRlLl90ZW1wbGF0ZUluZm8gPSB7fTtcbiAgICAgICAgICB0ZW1wbGF0ZUluZm8ubm9kZUluZm9MaXN0ID0gW107XG4gICAgICAgICAgdGVtcGxhdGVJbmZvLnN0cmlwV2hpdGVTcGFjZSA9XG4gICAgICAgICAgICAob3V0ZXJUZW1wbGF0ZUluZm8gJiYgb3V0ZXJUZW1wbGF0ZUluZm8uc3RyaXBXaGl0ZVNwYWNlKSB8fFxuICAgICAgICAgICAgdGVtcGxhdGUuaGFzQXR0cmlidXRlKCdzdHJpcC13aGl0ZXNwYWNlJyk7XG4gICAgICAgICAgdGhpcy5fcGFyc2VUZW1wbGF0ZUNvbnRlbnQodGVtcGxhdGUsIHRlbXBsYXRlSW5mbywge3BhcmVudDogbnVsbH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ZW1wbGF0ZS5fdGVtcGxhdGVJbmZvO1xuICAgICAgfVxuXG4gICAgICBzdGF0aWMgX3BhcnNlVGVtcGxhdGVDb250ZW50KHRlbXBsYXRlLCB0ZW1wbGF0ZUluZm8sIG5vZGVJbmZvKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJzZVRlbXBsYXRlTm9kZSh0ZW1wbGF0ZS5jb250ZW50LCB0ZW1wbGF0ZUluZm8sIG5vZGVJbmZvKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBQYXJzZXMgdGVtcGxhdGUgbm9kZSBhbmQgYWRkcyB0ZW1wbGF0ZSBhbmQgbm9kZSBtZXRhZGF0YSBiYXNlZCBvblxuICAgICAgICogdGhlIGN1cnJlbnQgbm9kZSwgYW5kIGl0cyBgY2hpbGROb2Rlc2AgYW5kIGBhdHRyaWJ1dGVzYC5cbiAgICAgICAqXG4gICAgICAgKiBUaGlzIG1ldGhvZCBtYXkgYmUgb3ZlcnJpZGRlbiB0byBhZGQgY3VzdG9tIG5vZGUgb3IgdGVtcGxhdGUgc3BlY2lmaWNcbiAgICAgICAqIG1ldGFkYXRhIGJhc2VkIG9uIHRoaXMgbm9kZS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgTm9kZSB0byBwYXJzZVxuICAgICAgICogQHBhcmFtIHshVGVtcGxhdGVJbmZvfSB0ZW1wbGF0ZUluZm8gVGVtcGxhdGUgbWV0YWRhdGEgZm9yIGN1cnJlbnQgdGVtcGxhdGVcbiAgICAgICAqIEBwYXJhbSB7IU5vZGVJbmZvfSBub2RlSW5mbyBOb2RlIG1ldGFkYXRhIGZvciBjdXJyZW50IHRlbXBsYXRlLlxuICAgICAgICogQHJldHVybiB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSB2aXNpdGVkIG5vZGUgYWRkZWQgbm9kZS1zcGVjaWZpY1xuICAgICAgICogICBtZXRhZGF0YSB0byBgbm9kZUluZm9gXG4gICAgICAgKi9cbiAgICAgIHN0YXRpYyBfcGFyc2VUZW1wbGF0ZU5vZGUobm9kZSwgdGVtcGxhdGVJbmZvLCBub2RlSW5mbykge1xuICAgICAgICBsZXQgbm90ZWQ7XG4gICAgICAgIGxldCBlbGVtZW50ID0gLyoqIEB0eXBlIEVsZW1lbnQgKi8obm9kZSk7XG4gICAgICAgIGlmIChlbGVtZW50LmxvY2FsTmFtZSA9PSAndGVtcGxhdGUnICYmICFlbGVtZW50Lmhhc0F0dHJpYnV0ZSgncHJlc2VydmUtY29udGVudCcpKSB7XG4gICAgICAgICAgbm90ZWQgPSB0aGlzLl9wYXJzZVRlbXBsYXRlTmVzdGVkVGVtcGxhdGUoZWxlbWVudCwgdGVtcGxhdGVJbmZvLCBub2RlSW5mbykgfHwgbm90ZWQ7XG4gICAgICAgIH0gZWxzZSBpZiAoZWxlbWVudC5sb2NhbE5hbWUgPT09ICdzbG90Jykge1xuICAgICAgICAgIC8vIEZvciBTaGFkeURvbSBvcHRpbWl6YXRpb24sIGluZGljYXRpbmcgdGhlcmUgaXMgYW4gaW5zZXJ0aW9uIHBvaW50XG4gICAgICAgICAgdGVtcGxhdGVJbmZvLmhhc0luc2VydGlvblBvaW50ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZWxlbWVudC5maXJzdENoaWxkKSB7XG4gICAgICAgICAgbm90ZWQgPSB0aGlzLl9wYXJzZVRlbXBsYXRlQ2hpbGROb2RlcyhlbGVtZW50LCB0ZW1wbGF0ZUluZm8sIG5vZGVJbmZvKSB8fCBub3RlZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZWxlbWVudC5oYXNBdHRyaWJ1dGVzICYmIGVsZW1lbnQuaGFzQXR0cmlidXRlcygpKSB7XG4gICAgICAgICAgbm90ZWQgPSB0aGlzLl9wYXJzZVRlbXBsYXRlTm9kZUF0dHJpYnV0ZXMoZWxlbWVudCwgdGVtcGxhdGVJbmZvLCBub2RlSW5mbykgfHwgbm90ZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vdGVkO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFBhcnNlcyB0ZW1wbGF0ZSBjaGlsZCBub2RlcyBmb3IgdGhlIGdpdmVuIHJvb3Qgbm9kZS5cbiAgICAgICAqXG4gICAgICAgKiBUaGlzIG1ldGhvZCBhbHNvIHdyYXBzIHdoaXRlbGlzdGVkIGxlZ2FjeSB0ZW1wbGF0ZSBleHRlbnNpb25zXG4gICAgICAgKiAoYGlzPVwiZG9tLWlmXCJgIGFuZCBgaXM9XCJkb20tcmVwZWF0XCJgKSB3aXRoIHRoZWlyIGVxdWl2YWxlbnQgZWxlbWVudFxuICAgICAgICogd3JhcHBlcnMsIGNvbGxhcHNlcyB0ZXh0IG5vZGVzLCBhbmQgc3RyaXBzIHdoaXRlc3BhY2UgZnJvbSB0aGUgdGVtcGxhdGVcbiAgICAgICAqIGlmIHRoZSBgdGVtcGxhdGVJbmZvLnN0cmlwV2hpdGVzcGFjZWAgc2V0dGluZyB3YXMgcHJvdmlkZWQuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtOb2RlfSByb290IFJvb3Qgbm9kZSB3aG9zZSBgY2hpbGROb2Rlc2Agd2lsbCBiZSBwYXJzZWRcbiAgICAgICAqIEBwYXJhbSB7IVRlbXBsYXRlSW5mb30gdGVtcGxhdGVJbmZvIFRlbXBsYXRlIG1ldGFkYXRhIGZvciBjdXJyZW50IHRlbXBsYXRlXG4gICAgICAgKiBAcGFyYW0geyFOb2RlSW5mb30gbm9kZUluZm8gTm9kZSBtZXRhZGF0YSBmb3IgY3VycmVudCB0ZW1wbGF0ZS5cbiAgICAgICAqL1xuICAgICAgc3RhdGljIF9wYXJzZVRlbXBsYXRlQ2hpbGROb2Rlcyhyb290LCB0ZW1wbGF0ZUluZm8sIG5vZGVJbmZvKSB7XG4gICAgICAgIGZvciAobGV0IG5vZGU9cm9vdC5maXJzdENoaWxkLCBwYXJlbnRJbmRleD0wLCBuZXh0OyBub2RlOyBub2RlPW5leHQpIHtcbiAgICAgICAgICAvLyBXcmFwIHRlbXBsYXRlc1xuICAgICAgICAgIGlmIChub2RlLmxvY2FsTmFtZSA9PSAndGVtcGxhdGUnKSB7XG4gICAgICAgICAgICBub2RlID0gd3JhcFRlbXBsYXRlRXh0ZW5zaW9uKG5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBjb2xsYXBzZSBhZGphY2VudCB0ZXh0Tm9kZXM6IGZpeGVzIGFuIElFIGlzc3VlIHRoYXQgY2FuIGNhdXNlXG4gICAgICAgICAgLy8gdGV4dCBub2RlcyB0byBiZSBpbmV4cGxpY2FibHkgc3BsaXQgPShcbiAgICAgICAgICAvLyBub3RlIHRoYXQgcm9vdC5ub3JtYWxpemUoKSBzaG91bGQgd29yayBidXQgZG9lcyBub3Qgc28gd2UgZG8gdGhpc1xuICAgICAgICAgIC8vIG1hbnVhbGx5LlxuICAgICAgICAgIG5leHQgPSBub2RlLm5leHRTaWJsaW5nO1xuICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSkge1xuICAgICAgICAgICAgbGV0IC8qKiBOb2RlICovIG4gPSBuZXh0O1xuICAgICAgICAgICAgd2hpbGUgKG4gJiYgKG4ubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFKSkge1xuICAgICAgICAgICAgICBub2RlLnRleHRDb250ZW50ICs9IG4udGV4dENvbnRlbnQ7XG4gICAgICAgICAgICAgIG5leHQgPSBuLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICByb290LnJlbW92ZUNoaWxkKG4pO1xuICAgICAgICAgICAgICBuID0gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIG9wdGlvbmFsbHkgc3RyaXAgd2hpdGVzcGFjZVxuICAgICAgICAgICAgaWYgKHRlbXBsYXRlSW5mby5zdHJpcFdoaXRlU3BhY2UgJiYgIW5vZGUudGV4dENvbnRlbnQudHJpbSgpKSB7XG4gICAgICAgICAgICAgIHJvb3QucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgY2hpbGRJbmZvID0geyBwYXJlbnRJbmRleCwgcGFyZW50SW5mbzogbm9kZUluZm8gfTtcbiAgICAgICAgICBpZiAodGhpcy5fcGFyc2VUZW1wbGF0ZU5vZGUobm9kZSwgdGVtcGxhdGVJbmZvLCBjaGlsZEluZm8pKSB7XG4gICAgICAgICAgICBjaGlsZEluZm8uaW5mb0luZGV4ID0gdGVtcGxhdGVJbmZvLm5vZGVJbmZvTGlzdC5wdXNoKC8qKiBAdHlwZSB7IU5vZGVJbmZvfSAqLyhjaGlsZEluZm8pKSAtIDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIEluY3JlbWVudCBpZiBub3QgcmVtb3ZlZFxuICAgICAgICAgIGlmIChub2RlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIHBhcmVudEluZGV4Kys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUGFyc2VzIHRlbXBsYXRlIGNvbnRlbnQgZm9yIHRoZSBnaXZlbiBuZXN0ZWQgYDx0ZW1wbGF0ZT5gLlxuICAgICAgICpcbiAgICAgICAqIE5lc3RlZCB0ZW1wbGF0ZSBpbmZvIGlzIHN0b3JlZCBhcyBgdGVtcGxhdGVJbmZvYCBpbiB0aGUgY3VycmVudCBub2RlJ3NcbiAgICAgICAqIGBub2RlSW5mb2AuIGB0ZW1wbGF0ZS5jb250ZW50YCBpcyByZW1vdmVkIGFuZCBzdG9yZWQgaW4gYHRlbXBsYXRlSW5mb2AuXG4gICAgICAgKiBJdCB3aWxsIHRoZW4gYmUgdGhlIHJlc3BvbnNpYmlsaXR5IG9mIHRoZSBob3N0IHRvIHNldCBpdCBiYWNrIHRvIHRoZVxuICAgICAgICogdGVtcGxhdGUgYW5kIGZvciB1c2VycyBzdGFtcGluZyBuZXN0ZWQgdGVtcGxhdGVzIHRvIHVzZSB0aGVcbiAgICAgICAqIGBfY29udGVudEZvclRlbXBsYXRlYCBtZXRob2QgdG8gcmV0cmlldmUgdGhlIGNvbnRlbnQgZm9yIHRoaXMgdGVtcGxhdGVcbiAgICAgICAqIChhbiBvcHRpbWl6YXRpb24gdG8gYXZvaWQgdGhlIGNvc3Qgb2YgY2xvbmluZyBuZXN0ZWQgdGVtcGxhdGUgY29udGVudCkuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtIVE1MVGVtcGxhdGVFbGVtZW50fSBub2RlIE5vZGUgdG8gcGFyc2UgKGEgPHRlbXBsYXRlPilcbiAgICAgICAqIEBwYXJhbSB7VGVtcGxhdGVJbmZvfSBvdXRlclRlbXBsYXRlSW5mbyBUZW1wbGF0ZSBtZXRhZGF0YSBmb3IgY3VycmVudCB0ZW1wbGF0ZVxuICAgICAgICogICB0aGF0IGluY2x1ZGVzIHRoZSB0ZW1wbGF0ZSBgbm9kZWBcbiAgICAgICAqIEBwYXJhbSB7IU5vZGVJbmZvfSBub2RlSW5mbyBOb2RlIG1ldGFkYXRhIGZvciBjdXJyZW50IHRlbXBsYXRlLlxuICAgICAgICogQHJldHVybiB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSB2aXNpdGVkIG5vZGUgYWRkZWQgbm9kZS1zcGVjaWZpY1xuICAgICAgICogICBtZXRhZGF0YSB0byBgbm9kZUluZm9gXG4gICAgICAgKi9cbiAgICAgIHN0YXRpYyBfcGFyc2VUZW1wbGF0ZU5lc3RlZFRlbXBsYXRlKG5vZGUsIG91dGVyVGVtcGxhdGVJbmZvLCBub2RlSW5mbykge1xuICAgICAgICBsZXQgdGVtcGxhdGVJbmZvID0gdGhpcy5fcGFyc2VUZW1wbGF0ZShub2RlLCBvdXRlclRlbXBsYXRlSW5mbyk7XG4gICAgICAgIGxldCBjb250ZW50ID0gdGVtcGxhdGVJbmZvLmNvbnRlbnQgPVxuICAgICAgICAgIG5vZGUuY29udGVudC5vd25lckRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICAgICAgY29udGVudC5hcHBlbmRDaGlsZChub2RlLmNvbnRlbnQpO1xuICAgICAgICBub2RlSW5mby50ZW1wbGF0ZUluZm8gPSB0ZW1wbGF0ZUluZm87XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFBhcnNlcyB0ZW1wbGF0ZSBub2RlIGF0dHJpYnV0ZXMgYW5kIGFkZHMgbm9kZSBtZXRhZGF0YSB0byBgbm9kZUluZm9gXG4gICAgICAgKiBmb3Igbm9kZXMgb2YgaW50ZXJlc3QuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtFbGVtZW50fSBub2RlIE5vZGUgdG8gcGFyc2VcbiAgICAgICAqIEBwYXJhbSB7VGVtcGxhdGVJbmZvfSB0ZW1wbGF0ZUluZm8gVGVtcGxhdGUgbWV0YWRhdGEgZm9yIGN1cnJlbnQgdGVtcGxhdGVcbiAgICAgICAqIEBwYXJhbSB7Tm9kZUluZm99IG5vZGVJbmZvIE5vZGUgbWV0YWRhdGEgZm9yIGN1cnJlbnQgdGVtcGxhdGUuXG4gICAgICAgKiBAcmV0dXJuIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIHZpc2l0ZWQgbm9kZSBhZGRlZCBub2RlLXNwZWNpZmljXG4gICAgICAgKiAgIG1ldGFkYXRhIHRvIGBub2RlSW5mb2BcbiAgICAgICAqL1xuICAgICAgc3RhdGljIF9wYXJzZVRlbXBsYXRlTm9kZUF0dHJpYnV0ZXMobm9kZSwgdGVtcGxhdGVJbmZvLCBub2RlSW5mbykge1xuICAgICAgICAvLyBNYWtlIGNvcHkgb2Ygb3JpZ2luYWwgYXR0cmlidXRlIGxpc3QsIHNpbmNlIHRoZSBvcmRlciBtYXkgY2hhbmdlXG4gICAgICAgIC8vIGFzIGF0dHJpYnV0ZXMgYXJlIGFkZGVkIGFuZCByZW1vdmVkXG4gICAgICAgIGxldCBub3RlZCA9IGZhbHNlO1xuICAgICAgICBsZXQgYXR0cnMgPSBBcnJheS5mcm9tKG5vZGUuYXR0cmlidXRlcyk7XG4gICAgICAgIGZvciAobGV0IGk9YXR0cnMubGVuZ3RoLTEsIGE7IChhPWF0dHJzW2ldKTsgaS0tKSB7XG4gICAgICAgICAgbm90ZWQgPSB0aGlzLl9wYXJzZVRlbXBsYXRlTm9kZUF0dHJpYnV0ZShub2RlLCB0ZW1wbGF0ZUluZm8sIG5vZGVJbmZvLCBhLm5hbWUsIGEudmFsdWUpIHx8IG5vdGVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub3RlZDtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBQYXJzZXMgYSBzaW5nbGUgdGVtcGxhdGUgbm9kZSBhdHRyaWJ1dGUgYW5kIGFkZHMgbm9kZSBtZXRhZGF0YSB0b1xuICAgICAgICogYG5vZGVJbmZvYCBmb3IgYXR0cmlidXRlcyBvZiBpbnRlcmVzdC5cbiAgICAgICAqXG4gICAgICAgKiBUaGlzIGltcGxlbWVudGF0aW9uIGFkZHMgbWV0YWRhdGEgZm9yIGBvbi1ldmVudD1cImhhbmRsZXJcImAgYXR0cmlidXRlc1xuICAgICAgICogYW5kIGBpZGAgYXR0cmlidXRlcy5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgTm9kZSB0byBwYXJzZVxuICAgICAgICogQHBhcmFtIHshVGVtcGxhdGVJbmZvfSB0ZW1wbGF0ZUluZm8gVGVtcGxhdGUgbWV0YWRhdGEgZm9yIGN1cnJlbnQgdGVtcGxhdGVcbiAgICAgICAqIEBwYXJhbSB7IU5vZGVJbmZvfSBub2RlSW5mbyBOb2RlIG1ldGFkYXRhIGZvciBjdXJyZW50IHRlbXBsYXRlLlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgQXR0cmlidXRlIG5hbWVcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSBBdHRyaWJ1dGUgdmFsdWVcbiAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgdmlzaXRlZCBub2RlIGFkZGVkIG5vZGUtc3BlY2lmaWNcbiAgICAgICAqICAgbWV0YWRhdGEgdG8gYG5vZGVJbmZvYFxuICAgICAgICovXG4gICAgICBzdGF0aWMgX3BhcnNlVGVtcGxhdGVOb2RlQXR0cmlidXRlKG5vZGUsIHRlbXBsYXRlSW5mbywgbm9kZUluZm8sIG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIC8vIGV2ZW50cyAob24tKilcbiAgICAgICAgaWYgKG5hbWUuc2xpY2UoMCwgMykgPT09ICdvbi0nKSB7XG4gICAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgICAgICAgbm9kZUluZm8uZXZlbnRzID0gbm9kZUluZm8uZXZlbnRzIHx8IFtdO1xuICAgICAgICAgIG5vZGVJbmZvLmV2ZW50cy5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6IG5hbWUuc2xpY2UoMyksXG4gICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIHN0YXRpYyBpZFxuICAgICAgICBlbHNlIGlmIChuYW1lID09PSAnaWQnKSB7XG4gICAgICAgICAgbm9kZUluZm8uaWQgPSB2YWx1ZTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUmV0dXJucyB0aGUgYGNvbnRlbnRgIGRvY3VtZW50IGZyYWdtZW50IGZvciBhIGdpdmVuIHRlbXBsYXRlLlxuICAgICAgICpcbiAgICAgICAqIEZvciBuZXN0ZWQgdGVtcGxhdGVzLCBQb2x5bWVyIHBlcmZvcm1zIGFuIG9wdGltaXphdGlvbiB0byBjYWNoZSBuZXN0ZWRcbiAgICAgICAqIHRlbXBsYXRlIGNvbnRlbnQgdG8gYXZvaWQgdGhlIGNvc3Qgb2YgY2xvbmluZyBkZWVwbHkgbmVzdGVkIHRlbXBsYXRlcy5cbiAgICAgICAqIFRoaXMgbWV0aG9kIHJldHJpZXZlcyB0aGUgY2FjaGVkIGNvbnRlbnQgZm9yIGEgZ2l2ZW4gdGVtcGxhdGUuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtIVE1MVGVtcGxhdGVFbGVtZW50fSB0ZW1wbGF0ZSBUZW1wbGF0ZSB0byByZXRyaWV2ZSBgY29udGVudGAgZm9yXG4gICAgICAgKiBAcmV0dXJuIHtEb2N1bWVudEZyYWdtZW50fSBDb250ZW50IGZyYWdtZW50XG4gICAgICAgKi9cbiAgICAgIHN0YXRpYyBfY29udGVudEZvclRlbXBsYXRlKHRlbXBsYXRlKSB7XG4gICAgICAgIGxldCB0ZW1wbGF0ZUluZm8gPSAvKiogQHR5cGUge0hUTUxUZW1wbGF0ZUVsZW1lbnRXaXRoSW5mb30gKi8gKHRlbXBsYXRlKS5fdGVtcGxhdGVJbmZvO1xuICAgICAgICByZXR1cm4gKHRlbXBsYXRlSW5mbyAmJiB0ZW1wbGF0ZUluZm8uY29udGVudCkgfHwgdGVtcGxhdGUuY29udGVudDtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDbG9uZXMgdGhlIHByb3ZpZGVkIHRlbXBsYXRlIGNvbnRlbnQgYW5kIHJldHVybnMgYSBkb2N1bWVudCBmcmFnbWVudFxuICAgICAgICogY29udGFpbmluZyB0aGUgY2xvbmVkIGRvbS5cbiAgICAgICAqXG4gICAgICAgKiBUaGUgdGVtcGxhdGUgaXMgcGFyc2VkIChvbmNlIGFuZCBtZW1vaXplZCkgdXNpbmcgdGhpcyBsaWJyYXJ5J3NcbiAgICAgICAqIHRlbXBsYXRlIHBhcnNpbmcgZmVhdHVyZXMsIGFuZCBwcm92aWRlcyB0aGUgZm9sbG93aW5nIHZhbHVlLWFkZGVkXG4gICAgICAgKiBmZWF0dXJlczpcbiAgICAgICAqICogQWRkcyBkZWNsYXJhdGl2ZSBldmVudCBsaXN0ZW5lcnMgZm9yIGBvbi1ldmVudD1cImhhbmRsZXJcImAgYXR0cmlidXRlc1xuICAgICAgICogKiBHZW5lcmF0ZXMgYW4gXCJpZCBtYXBcIiBmb3IgYWxsIG5vZGVzIHdpdGggaWQncyB1bmRlciBgJGAgb24gcmV0dXJuZWRcbiAgICAgICAqICAgZG9jdW1lbnQgZnJhZ21lbnRcbiAgICAgICAqICogUGFzc2VzIHRlbXBsYXRlIGluZm8gaW5jbHVkaW5nIGBjb250ZW50YCBiYWNrIHRvIHRlbXBsYXRlcyBhc1xuICAgICAgICogICBgX3RlbXBsYXRlSW5mb2AgKGEgcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uIHRvIGF2b2lkIGRlZXAgdGVtcGxhdGVcbiAgICAgICAqICAgY2xvbmluZylcbiAgICAgICAqXG4gICAgICAgKiBOb3RlIHRoYXQgdGhlIG1lbW9pemVkIHRlbXBsYXRlIHBhcnNpbmcgcHJvY2VzcyBpcyBkZXN0cnVjdGl2ZSB0byB0aGVcbiAgICAgICAqIHRlbXBsYXRlOiBhdHRyaWJ1dGVzIGZvciBiaW5kaW5ncyBhbmQgZGVjbGFyYXRpdmUgZXZlbnQgbGlzdGVuZXJzIGFyZVxuICAgICAgICogcmVtb3ZlZCBhZnRlciBiZWluZyBub3RlZCBpbiBub3RlcywgYW5kIGFueSBuZXN0ZWQgYDx0ZW1wbGF0ZT4uY29udGVudGBcbiAgICAgICAqIGlzIHJlbW92ZWQgYW5kIHN0b3JlZCBpbiBub3RlcyBhcyB3ZWxsLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7IUhUTUxUZW1wbGF0ZUVsZW1lbnR9IHRlbXBsYXRlIFRlbXBsYXRlIHRvIHN0YW1wXG4gICAgICAgKiBAcmV0dXJuIHshU3RhbXBlZFRlbXBsYXRlfSBDbG9uZWQgdGVtcGxhdGUgY29udGVudFxuICAgICAgICovXG4gICAgICBfc3RhbXBUZW1wbGF0ZSh0ZW1wbGF0ZSkge1xuICAgICAgICAvLyBQb2x5ZmlsbCBzdXBwb3J0OiBib290c3RyYXAgdGhlIHRlbXBsYXRlIGlmIGl0IGhhcyBub3QgYWxyZWFkeSBiZWVuXG4gICAgICAgIGlmICh0ZW1wbGF0ZSAmJiAhdGVtcGxhdGUuY29udGVudCAmJlxuICAgICAgICAgICAgd2luZG93LkhUTUxUZW1wbGF0ZUVsZW1lbnQgJiYgSFRNTFRlbXBsYXRlRWxlbWVudC5kZWNvcmF0ZSkge1xuICAgICAgICAgIEhUTUxUZW1wbGF0ZUVsZW1lbnQuZGVjb3JhdGUodGVtcGxhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0ZW1wbGF0ZUluZm8gPSB0aGlzLmNvbnN0cnVjdG9yLl9wYXJzZVRlbXBsYXRlKHRlbXBsYXRlKTtcbiAgICAgICAgbGV0IG5vZGVJbmZvID0gdGVtcGxhdGVJbmZvLm5vZGVJbmZvTGlzdDtcbiAgICAgICAgbGV0IGNvbnRlbnQgPSB0ZW1wbGF0ZUluZm8uY29udGVudCB8fCB0ZW1wbGF0ZS5jb250ZW50O1xuICAgICAgICBsZXQgZG9tID0gLyoqIEB0eXBlIERvY3VtZW50RnJhZ21lbnQgKi8gKGRvY3VtZW50LmltcG9ydE5vZGUoY29udGVudCwgdHJ1ZSkpO1xuICAgICAgICAvLyBOT1RFOiBTaGFkeURvbSBvcHRpbWl6YXRpb24gaW5kaWNhdGluZyB0aGVyZSBpcyBhbiBpbnNlcnRpb24gcG9pbnRcbiAgICAgICAgZG9tLl9fbm9JbnNlcnRpb25Qb2ludCA9ICF0ZW1wbGF0ZUluZm8uaGFzSW5zZXJ0aW9uUG9pbnQ7XG4gICAgICAgIGxldCBub2RlcyA9IGRvbS5ub2RlTGlzdCA9IG5ldyBBcnJheShub2RlSW5mby5sZW5ndGgpO1xuICAgICAgICBkb20uJCA9IHt9O1xuICAgICAgICBmb3IgKGxldCBpPTAsIGw9bm9kZUluZm8ubGVuZ3RoLCBpbmZvOyAoaTxsKSAmJiAoaW5mbz1ub2RlSW5mb1tpXSk7IGkrKykge1xuICAgICAgICAgIGxldCBub2RlID0gbm9kZXNbaV0gPSBmaW5kVGVtcGxhdGVOb2RlKGRvbSwgaW5mbyk7XG4gICAgICAgICAgYXBwbHlJZFRvTWFwKHRoaXMsIGRvbS4kLCBub2RlLCBpbmZvKTtcbiAgICAgICAgICBhcHBseVRlbXBsYXRlQ29udGVudCh0aGlzLCBub2RlLCBpbmZvKTtcbiAgICAgICAgICBhcHBseUV2ZW50TGlzdGVuZXIodGhpcywgbm9kZSwgaW5mbyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC8qKiBAdHlwZSB7IVN0YW1wZWRUZW1wbGF0ZX0gKi8oZG9tKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBBZGRzIGFuIGV2ZW50IGxpc3RlbmVyIGJ5IG1ldGhvZCBuYW1lIGZvciB0aGUgZXZlbnQgcHJvdmlkZWQuXG4gICAgICAgKlxuICAgICAgICogVGhpcyBtZXRob2QgZ2VuZXJhdGVzIGEgaGFuZGxlciBmdW5jdGlvbiB0aGF0IGxvb2tzIHVwIHRoZSBtZXRob2RcbiAgICAgICAqIG5hbWUgYXQgaGFuZGxpbmcgdGltZS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgTm9kZSB0byBhZGQgbGlzdGVuZXIgb25cbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgTmFtZSBvZiBldmVudFxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZE5hbWUgTmFtZSBvZiBtZXRob2RcbiAgICAgICAqIEBwYXJhbSB7Kj19IGNvbnRleHQgQ29udGV4dCB0aGUgbWV0aG9kIHdpbGwgYmUgY2FsbGVkIG9uIChkZWZhdWx0c1xuICAgICAgICogICB0byBgbm9kZWApXG4gICAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gR2VuZXJhdGVkIGhhbmRsZXIgZnVuY3Rpb25cbiAgICAgICAqL1xuICAgICAgX2FkZE1ldGhvZEV2ZW50TGlzdGVuZXJUb05vZGUobm9kZSwgZXZlbnROYW1lLCBtZXRob2ROYW1lLCBjb250ZXh0KSB7XG4gICAgICAgIGNvbnRleHQgPSBjb250ZXh0IHx8IG5vZGU7XG4gICAgICAgIGxldCBoYW5kbGVyID0gY3JlYXRlTm9kZUV2ZW50SGFuZGxlcihjb250ZXh0LCBldmVudE5hbWUsIG1ldGhvZE5hbWUpO1xuICAgICAgICB0aGlzLl9hZGRFdmVudExpc3RlbmVyVG9Ob2RlKG5vZGUsIGV2ZW50TmFtZSwgaGFuZGxlcik7XG4gICAgICAgIHJldHVybiBoYW5kbGVyO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIE92ZXJyaWRlIHBvaW50IGZvciBhZGRpbmcgY3VzdG9tIG9yIHNpbXVsYXRlZCBldmVudCBoYW5kbGluZy5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgTm9kZSB0byBhZGQgZXZlbnQgbGlzdGVuZXIgdG9cbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgTmFtZSBvZiBldmVudFxuICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciBMaXN0ZW5lciBmdW5jdGlvbiB0byBhZGRcbiAgICAgICAqL1xuICAgICAgX2FkZEV2ZW50TGlzdGVuZXJUb05vZGUobm9kZSwgZXZlbnROYW1lLCBoYW5kbGVyKSB7XG4gICAgICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGhhbmRsZXIpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIE92ZXJyaWRlIHBvaW50IGZvciBhZGRpbmcgY3VzdG9tIG9yIHNpbXVsYXRlZCBldmVudCBoYW5kbGluZy5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgTm9kZSB0byByZW1vdmUgZXZlbnQgbGlzdGVuZXIgZnJvbVxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBOYW1lIG9mIGV2ZW50XG4gICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIExpc3RlbmVyIGZ1bmN0aW9uIHRvIHJlbW92ZVxuICAgICAgICovXG4gICAgICBfcmVtb3ZlRXZlbnRMaXN0ZW5lckZyb21Ob2RlKG5vZGUsIGV2ZW50TmFtZSwgaGFuZGxlcikge1xuICAgICAgICBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBoYW5kbGVyKTtcbiAgICAgIH1cblxuICAgIH1cblxuICAgIHJldHVybiBUZW1wbGF0ZVN0YW1wO1xuXG4gIH0pO1xuXG59KSgpO1xuPC9zY3JpcHQ+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL3BvbHltZXIvbGliL21peGlucy90ZW1wbGF0ZS1zdGFtcC5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNSBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuXG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vLi4vcG9seW1lci9wb2x5bWVyLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi8uLi9pcm9uLWZsZXgtbGF5b3V0L2lyb24tZmxleC1sYXlvdXQuaHRtbFwiPlxuXG48IS0tXG5hcHAtZHJhd2VyIGlzIGEgbmF2aWdhdGlvbiBkcmF3ZXIgdGhhdCBjYW4gc2xpZGUgaW4gZnJvbSB0aGUgbGVmdCBvciByaWdodC5cblxuRXhhbXBsZTpcblxuQWxpZ24gdGhlIGRyYXdlciBhdCB0aGUgc3RhcnQsIHdoaWNoIGlzIGxlZnQgaW4gTFRSIGxheW91dHMgKGRlZmF1bHQpOlxuXG5gYGBodG1sXG48YXBwLWRyYXdlciBvcGVuZWQ+PC9hcHAtZHJhd2VyPlxuYGBgXG5cbkFsaWduIHRoZSBkcmF3ZXIgYXQgdGhlIGVuZDpcblxuYGBgaHRtbFxuPGFwcC1kcmF3ZXIgYWxpZ249XCJlbmRcIiBvcGVuZWQ+PC9hcHAtZHJhd2VyPlxuYGBgXG5cblRvIG1ha2UgdGhlIGNvbnRlbnRzIG9mIHRoZSBkcmF3ZXIgc2Nyb2xsYWJsZSwgY3JlYXRlIGEgd3JhcHBlciBmb3IgdGhlIHNjcm9sbFxuY29udGVudCwgYW5kIGFwcGx5IGhlaWdodCBhbmQgb3ZlcmZsb3cgc3R5bGVzIHRvIGl0LlxuXG5gYGBodG1sXG48YXBwLWRyYXdlcj5cbiAgPGRpdiBzdHlsZT1cImhlaWdodDogMTAwJTsgb3ZlcmZsb3c6IGF1dG87XCI+PC9kaXY+XG48L2FwcC1kcmF3ZXI+XG5gYGBcblxuIyMjIFN0eWxpbmdcblxuQ3VzdG9tIHByb3BlcnR5ICAgICAgICAgICAgICAgICAgfCBEZXNjcmlwdGlvbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IERlZmF1bHRcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfC0tLS0tLS0tLS0tLS0tLS0tLS0tXG5gLS1hcHAtZHJhd2VyLXdpZHRoYCAgICAgICAgICAgICB8IFdpZHRoIG9mIHRoZSBkcmF3ZXIgICAgICAgICAgICAgICAgICAgIHwgMjU2cHhcbmAtLWFwcC1kcmF3ZXItY29udGVudC1jb250YWluZXJgIHwgTWl4aW4gZm9yIHRoZSBkcmF3ZXIgY29udGVudCBjb250YWluZXIgfCB7fVxuYC0tYXBwLWRyYXdlci1zY3JpbS1iYWNrZ3JvdW5kYCAgfCBCYWNrZ3JvdW5kIGZvciB0aGUgc2NyaW0gICAgICAgICAgICAgICB8IHJnYmEoMCwgMCwgMCwgMC41KVxuXG4qKk5PVEU6KiogSWYgeW91IHVzZSA8YXBwLWRyYXdlcj4gd2l0aCA8YXBwLWRyYXdlci1sYXlvdXQ+IGFuZCBzcGVjaWZ5IGEgdmFsdWUgZm9yXG5gLS1hcHAtZHJhd2VyLXdpZHRoYCwgdGhhdCB2YWx1ZSBtdXN0IGJlIGFjY2Vzc2libGUgYnkgYm90aCBlbGVtZW50cy4gVGhpcyBjYW4gYmUgZG9uZSBieVxuZGVmaW5pbmcgdGhlIHZhbHVlIG9uIHRoZSBgOmhvc3RgIHRoYXQgY29udGFpbnMgPGFwcC1kcmF3ZXItbGF5b3V0PiAob3IgYGh0bWxgIGlmIG91dHNpZGVcbmEgc2hhZG93IHJvb3QpOlxuXG5gYGBjc3Ncbjpob3N0IHtcbiAgLS1hcHAtZHJhd2VyLXdpZHRoOiAzMDBweDtcbn1cbmBgYFxuXG5AZ3JvdXAgQXBwIEVsZW1lbnRzXG5AZWxlbWVudCBhcHAtZHJhd2VyXG5AZGVtbyBhcHAtZHJhd2VyL2RlbW8vbGVmdC1kcmF3ZXIuaHRtbCBTaW1wbGUgTGVmdCBEcmF3ZXJcbkBkZW1vIGFwcC1kcmF3ZXIvZGVtby9yaWdodC1kcmF3ZXIuaHRtbCBSaWdodCBEcmF3ZXIgd2l0aCBJY29uc1xuLS0+XG5cbjxkb20tbW9kdWxlIGlkPVwiYXBwLWRyYXdlclwiPlxuICA8dGVtcGxhdGU+XG4gICAgPHN0eWxlPlxuICAgICAgOmhvc3Qge1xuICAgICAgICBwb3NpdGlvbjogZml4ZWQ7XG4gICAgICAgIHRvcDogLTEyMHB4O1xuICAgICAgICByaWdodDogMDtcbiAgICAgICAgYm90dG9tOiAtMTIwcHg7XG4gICAgICAgIGxlZnQ6IDA7XG5cbiAgICAgICAgdmlzaWJpbGl0eTogaGlkZGVuO1xuXG4gICAgICAgIHRyYW5zaXRpb24tcHJvcGVydHk6IHZpc2liaWxpdHk7XG4gICAgICB9XG5cbiAgICAgIDpob3N0KFtvcGVuZWRdKSB7XG4gICAgICAgIHZpc2liaWxpdHk6IHZpc2libGU7XG4gICAgICB9XG5cbiAgICAgIDpob3N0KFtwZXJzaXN0ZW50XSkge1xuICAgICAgICB3aWR0aDogdmFyKC0tYXBwLWRyYXdlci13aWR0aCwgMjU2cHgpO1xuICAgICAgfVxuXG4gICAgICA6aG9zdChbcGVyc2lzdGVudF1bcG9zaXRpb249bGVmdF0pIHtcbiAgICAgICAgcmlnaHQ6IGF1dG87XG4gICAgICB9XG5cbiAgICAgIDpob3N0KFtwZXJzaXN0ZW50XVtwb3NpdGlvbj1yaWdodF0pIHtcbiAgICAgICAgbGVmdDogYXV0bztcbiAgICAgIH1cblxuICAgICAgI2NvbnRlbnRDb250YWluZXIge1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIHRvcDogMDtcbiAgICAgICAgYm90dG9tOiAwO1xuICAgICAgICBsZWZ0OiAwO1xuXG4gICAgICAgIHdpZHRoOiB2YXIoLS1hcHAtZHJhd2VyLXdpZHRoLCAyNTZweCk7XG4gICAgICAgIHBhZGRpbmc6IDEyMHB4IDA7XG5cbiAgICAgICAgdHJhbnNpdGlvbi1wcm9wZXJ0eTogLXdlYmtpdC10cmFuc2Zvcm07XG4gICAgICAgIHRyYW5zaXRpb24tcHJvcGVydHk6IHRyYW5zZm9ybTtcbiAgICAgICAgLXdlYmtpdC10cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKC0xMDAlLCAwLCAwKTtcbiAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgtMTAwJSwgMCwgMCk7XG5cbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogI0ZGRjtcblxuICAgICAgICBAYXBwbHkgLS1hcHAtZHJhd2VyLWNvbnRlbnQtY29udGFpbmVyO1xuICAgICAgfVxuXG4gICAgICAjY29udGVudENvbnRhaW5lcltwZXJzaXN0ZW50XSB7XG4gICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgfVxuXG4gICAgICAjY29udGVudENvbnRhaW5lcltwb3NpdGlvbj1yaWdodF0ge1xuICAgICAgICByaWdodDogMDtcbiAgICAgICAgbGVmdDogYXV0bztcblxuICAgICAgICAtd2Via2l0LXRyYW5zZm9ybTogdHJhbnNsYXRlM2QoMTAwJSwgMCwgMCk7XG4gICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoMTAwJSwgMCwgMCk7XG4gICAgICB9XG5cbiAgICAgICNjb250ZW50Q29udGFpbmVyW3N3aXBlLW9wZW5dOjphZnRlciB7XG4gICAgICAgIHBvc2l0aW9uOiBmaXhlZDtcbiAgICAgICAgdG9wOiAwO1xuICAgICAgICBib3R0b206IDA7XG4gICAgICAgIGxlZnQ6IDEwMCU7XG5cbiAgICAgICAgdmlzaWJpbGl0eTogdmlzaWJsZTtcblxuICAgICAgICB3aWR0aDogMjBweDtcblxuICAgICAgICBjb250ZW50OiAnJztcbiAgICAgIH1cblxuICAgICAgI2NvbnRlbnRDb250YWluZXJbc3dpcGUtb3Blbl1bcG9zaXRpb249cmlnaHRdOjphZnRlciB7XG4gICAgICAgIHJpZ2h0OiAxMDAlO1xuICAgICAgICBsZWZ0OiBhdXRvO1xuICAgICAgfVxuXG4gICAgICAjY29udGVudENvbnRhaW5lcltvcGVuZWRdIHtcbiAgICAgICAgLXdlYmtpdC10cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKDAsIDAsIDApO1xuICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKDAsIDAsIDApO1xuICAgICAgfVxuXG4gICAgICAjc2NyaW0ge1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIHRvcDogMDtcbiAgICAgICAgcmlnaHQ6IDA7XG4gICAgICAgIGJvdHRvbTogMDtcbiAgICAgICAgbGVmdDogMDtcblxuICAgICAgICB0cmFuc2l0aW9uLXByb3BlcnR5OiBvcGFjaXR5O1xuICAgICAgICAtd2Via2l0LXRyYW5zZm9ybTogdHJhbnNsYXRlWigwKTtcbiAgICAgICAgdHJhbnNmb3JtOiAgdHJhbnNsYXRlWigwKTtcblxuICAgICAgICBvcGFjaXR5OiAwO1xuICAgICAgICBiYWNrZ3JvdW5kOiB2YXIoLS1hcHAtZHJhd2VyLXNjcmltLWJhY2tncm91bmQsIHJnYmEoMCwgMCwgMCwgMC41KSk7XG4gICAgICB9XG5cbiAgICAgICNzY3JpbS52aXNpYmxlIHtcbiAgICAgICAgb3BhY2l0eTogMTtcbiAgICAgIH1cblxuICAgICAgOmhvc3QoW25vLXRyYW5zaXRpb25dKSAjY29udGVudENvbnRhaW5lciB7XG4gICAgICAgIHRyYW5zaXRpb24tcHJvcGVydHk6IG5vbmU7XG4gICAgICB9XG4gICAgPC9zdHlsZT5cblxuICAgIDxkaXYgaWQ9XCJzY3JpbVwiIG9uLWNsaWNrPVwiY2xvc2VcIj48L2Rpdj5cblxuICAgIDwhLS0gSEFDSyhrZWFudWxlZSk6IEJpbmQgYXR0cmlidXRlcyBoZXJlIChpbiBhZGRpdGlvbiB0byA6aG9zdCkgZm9yIHN0eWxpbmcgdG8gd29ya2Fyb3VuZCBTYWZhcmlcbiAgICBidWcuIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xNzA3NjIgLS0+XG4gICAgPGRpdiBpZD1cImNvbnRlbnRDb250YWluZXJcIiBvcGVuZWQkPVwiW1tvcGVuZWRdXVwiIHBlcnNpc3RlbnQkPVwiW1twZXJzaXN0ZW50XV1cIlxuICAgICAgICBwb3NpdGlvbiQ9XCJbW3Bvc2l0aW9uXV1cIiBzd2lwZS1vcGVuJD1cIltbc3dpcGVPcGVuXV1cIj5cbiAgICAgIDxzbG90Pjwvc2xvdD5cbiAgICA8L2Rpdj5cbiAgPC90ZW1wbGF0ZT5cblxuICA8c2NyaXB0PlxuXG4gICAgUG9seW1lcih7XG4gICAgICBpczogJ2FwcC1kcmF3ZXInLFxuXG4gICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgb3BlbmVkIHN0YXRlIG9mIHRoZSBkcmF3ZXIuXG4gICAgICAgICAqL1xuICAgICAgICBvcGVuZWQ6IHtcbiAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgIHZhbHVlOiBmYWxzZSxcbiAgICAgICAgICBub3RpZnk6IHRydWUsXG4gICAgICAgICAgcmVmbGVjdFRvQXR0cmlidXRlOiB0cnVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBkcmF3ZXIgZG9lcyBub3QgaGF2ZSBhIHNjcmltIGFuZCBjYW5ub3QgYmUgc3dpcGVkIGNsb3NlLlxuICAgICAgICAgKi9cbiAgICAgICAgcGVyc2lzdGVudDoge1xuICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgICAgdmFsdWU6IGZhbHNlLFxuICAgICAgICAgIHJlZmxlY3RUb0F0dHJpYnV0ZTogdHJ1ZVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdHJhbnNpdGlvbiBkdXJhdGlvbiBvZiB0aGUgZHJhd2VyIGluIG1pbGxpc2Vjb25kcy5cbiAgICAgICAgICovXG4gICAgICAgIHRyYW5zaXRpb25EdXJhdGlvbjoge1xuICAgICAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgICAgICB2YWx1ZTogMjAwXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBhbGlnbm1lbnQgb2YgdGhlIGRyYXdlciBvbiB0aGUgc2NyZWVuICgnbGVmdCcsICdyaWdodCcsICdzdGFydCcgb3IgJ2VuZCcpLlxuICAgICAgICAgKiAnc3RhcnQnIGNvbXB1dGVzIHRvIGxlZnQgYW5kICdlbmQnIHRvIHJpZ2h0IGluIExUUiBsYXlvdXQgYW5kIHZpY2UgdmVyc2EgaW4gUlRMXG4gICAgICAgICAqIGxheW91dC5cbiAgICAgICAgICovXG4gICAgICAgIGFsaWduOiB7XG4gICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgIHZhbHVlOiAnbGVmdCdcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGNvbXB1dGVkLCByZWFkLW9ubHkgcG9zaXRpb24gb2YgdGhlIGRyYXdlciBvbiB0aGUgc2NyZWVuICgnbGVmdCcgb3IgJ3JpZ2h0JykuXG4gICAgICAgICAqL1xuICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICByZWFkT25seTogdHJ1ZSxcbiAgICAgICAgICByZWZsZWN0VG9BdHRyaWJ1dGU6IHRydWVcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGFuIGFyZWEgYXQgdGhlIGVkZ2Ugb2YgdGhlIHNjcmVlbiB0byBzd2lwZSBvcGVuIHRoZSBkcmF3ZXIuXG4gICAgICAgICAqL1xuICAgICAgICBzd2lwZU9wZW46IHtcbiAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgIHZhbHVlOiBmYWxzZSxcbiAgICAgICAgICByZWZsZWN0VG9BdHRyaWJ1dGU6IHRydWVcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVHJhcCBrZXlib2FyZCBmb2N1cyB3aGVuIHRoZSBkcmF3ZXIgaXMgb3BlbmVkIGFuZCBub3QgcGVyc2lzdGVudC5cbiAgICAgICAgICovXG4gICAgICAgIG5vRm9jdXNUcmFwOiB7XG4gICAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGlzYWJsZXMgc3dpcGluZyBvbiB0aGUgZHJhd2VyLlxuICAgICAgICAgKi9cbiAgICAgICAgZGlzYWJsZVN3aXBlOiB7XG4gICAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgb2JzZXJ2ZXJzOiBbXG4gICAgICAgICdyZXNldExheW91dChwb3NpdGlvbiwgaXNBdHRhY2hlZCknLFxuICAgICAgICAnX3Jlc2V0UG9zaXRpb24oYWxpZ24sIGlzQXR0YWNoZWQpJyxcbiAgICAgICAgJ19zdHlsZVRyYW5zaXRpb25EdXJhdGlvbih0cmFuc2l0aW9uRHVyYXRpb24pJyxcbiAgICAgICAgJ19vcGVuZWRQZXJzaXN0ZW50Q2hhbmdlZChvcGVuZWQsIHBlcnNpc3RlbnQpJ1xuICAgICAgXSxcblxuICAgICAgX3RyYW5zbGF0ZU9mZnNldDogMCxcblxuICAgICAgX3RyYWNrRGV0YWlsczogbnVsbCxcblxuICAgICAgX2RyYXdlclN0YXRlOiAwLFxuXG4gICAgICBfYm91bmRFc2NLZXlkb3duSGFuZGxlcjogbnVsbCxcblxuICAgICAgX2ZpcnN0VGFiU3RvcDogbnVsbCxcblxuICAgICAgX2xhc3RUYWJTdG9wOiBudWxsLFxuXG4gICAgICBhdHRhY2hlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIFBvbHltZXIuUmVuZGVyU3RhdHVzLmFmdGVyTmV4dFJlbmRlcih0aGlzLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICB0aGlzLl9ib3VuZEVzY0tleWRvd25IYW5kbGVyID0gdGhpcy5fZXNjS2V5ZG93bkhhbmRsZXIuYmluZCh0aGlzKTtcbiAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLl90YWJLZXlkb3duSGFuZGxlci5iaW5kKHRoaXMpKVxuXG4gICAgICAgICAgLy8gT25seSBsaXN0ZW4gZm9yIGhvcml6b250YWwgdHJhY2sgc28geW91IGNhbiB2ZXJ0aWNhbGx5IHNjcm9sbCBpbnNpZGUgdGhlIGRyYXdlci5cbiAgICAgICAgICB0aGlzLmxpc3Rlbih0aGlzLCAndHJhY2snLCAnX3RyYWNrJyk7XG4gICAgICAgICAgdGhpcy5zZXRTY3JvbGxEaXJlY3Rpb24oJ3knKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5maXJlKCdhcHAtcmVzZXQtbGF5b3V0Jyk7XG4gICAgICB9LFxuXG4gICAgICBkZXRhY2hlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLl9ib3VuZEVzY0tleWRvd25IYW5kbGVyKTtcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogT3BlbnMgdGhlIGRyYXdlci5cbiAgICAgICAqL1xuICAgICAgb3BlbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMub3BlbmVkID0gdHJ1ZTtcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogQ2xvc2VzIHRoZSBkcmF3ZXIuXG4gICAgICAgKi9cbiAgICAgIGNsb3NlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5vcGVuZWQgPSBmYWxzZTtcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogVG9nZ2xlcyB0aGUgZHJhd2VyIG9wZW4gYW5kIGNsb3NlLlxuICAgICAgICovXG4gICAgICB0b2dnbGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLm9wZW5lZCA9ICF0aGlzLm9wZW5lZDtcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogR2V0cyB0aGUgd2lkdGggb2YgdGhlIGRyYXdlci5cbiAgICAgICAqXG4gICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSB3aWR0aCBvZiB0aGUgZHJhd2VyIGluIHBpeGVscy5cbiAgICAgICAqL1xuICAgICAgZ2V0V2lkdGg6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2F2ZWRXaWR0aCB8fCB0aGlzLiQuY29udGVudENvbnRhaW5lci5vZmZzZXRXaWR0aDtcbiAgICAgIH0sXG5cbiAgICAgIF9pc1JUTDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzKS5kaXJlY3Rpb24gPT09ICdydGwnO1xuICAgICAgfSxcblxuICAgICAgX3Jlc2V0UG9zaXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMuYWxpZ24pIHtcbiAgICAgICAgICBjYXNlICdzdGFydCc6XG4gICAgICAgICAgICB0aGlzLl9zZXRQb3NpdGlvbih0aGlzLl9pc1JUTCgpID8gJ3JpZ2h0JyA6ICdsZWZ0Jyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgY2FzZSAnZW5kJzpcbiAgICAgICAgICAgIHRoaXMuX3NldFBvc2l0aW9uKHRoaXMuX2lzUlRMKCkgPyAnbGVmdCcgOiAncmlnaHQnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zZXRQb3NpdGlvbih0aGlzLmFsaWduKTtcbiAgICAgIH0sXG5cbiAgICAgIF9lc2NLZXlkb3duSGFuZGxlcjogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgdmFyIEVTQ19LRVlDT0RFID0gMjc7XG4gICAgICAgIGlmIChldmVudC5rZXlDb2RlID09PSBFU0NfS0VZQ09ERSkge1xuICAgICAgICAgIC8vIFByZXZlbnQgYW55IHNpZGUgZWZmZWN0cyBpZiBhcHAtZHJhd2VyIGNsb3Nlcy5cbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgX3RyYWNrOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICBpZiAodGhpcy5wZXJzaXN0ZW50IHx8IHRoaXMuZGlzYWJsZVN3aXBlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGlzYWJsZSB1c2VyIHNlbGVjdGlvbiBvbiBkZXNrdG9wLlxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIHN3aXRjaCAoZXZlbnQuZGV0YWlsLnN0YXRlKSB7XG4gICAgICAgICAgY2FzZSAnc3RhcnQnOlxuICAgICAgICAgICAgdGhpcy5fdHJhY2tTdGFydChldmVudCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICd0cmFjayc6XG4gICAgICAgICAgICB0aGlzLl90cmFja01vdmUoZXZlbnQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnZW5kJzpcbiAgICAgICAgICAgIHRoaXMuX3RyYWNrRW5kKGV2ZW50KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBfdHJhY2tTdGFydDogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgdGhpcy5fZHJhd2VyU3RhdGUgPSB0aGlzLl9EUkFXRVJfU1RBVEUuVFJBQ0tJTkc7XG5cbiAgICAgICAgdmFyIHJlY3QgPSB0aGlzLiQuY29udGVudENvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgdGhpcy5fc2F2ZWRXaWR0aCA9IHJlY3Qud2lkdGg7XG4gICAgICAgIGlmICh0aGlzLnBvc2l0aW9uID09PSAnbGVmdCcpIHtcbiAgICAgICAgICB0aGlzLl90cmFuc2xhdGVPZmZzZXQgPSByZWN0LmxlZnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fdHJhbnNsYXRlT2Zmc2V0ID0gcmVjdC5yaWdodCAtIHdpbmRvdy5pbm5lcldpZHRoO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fdHJhY2tEZXRhaWxzID0gW107XG5cbiAgICAgICAgLy8gRGlzYWJsZSB0cmFuc2l0aW9ucyBzaW5jZSBzdHlsZSBhdHRyaWJ1dGVzIHdpbGwgcmVmbGVjdCB1c2VyIHRyYWNrIGV2ZW50cy5cbiAgICAgICAgdGhpcy5fc3R5bGVUcmFuc2l0aW9uRHVyYXRpb24oMCk7XG4gICAgICAgIHRoaXMuc3R5bGUudmlzaWJpbGl0eSA9ICd2aXNpYmxlJztcbiAgICAgIH0sXG5cbiAgICAgIF90cmFja01vdmU6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuX3RyYW5zbGF0ZURyYXdlcihldmVudC5kZXRhaWwuZHggKyB0aGlzLl90cmFuc2xhdGVPZmZzZXQpO1xuXG4gICAgICAgIC8vIFVzZSBEYXRlLm5vdygpIHNpbmNlIGV2ZW50LnRpbWVTdGFtcCBpcyBpbmNvbnNpc3RlbnQgYWNyb3NzIGJyb3dzZXJzIChlLmcuIG1vc3RcbiAgICAgICAgLy8gYnJvd3NlcnMgdXNlIG1pbGxpc2Vjb25kcyBidXQgRkYgNDQgdXNlcyBtaWNyb3NlY29uZHMpLlxuICAgICAgICB0aGlzLl90cmFja0RldGFpbHMucHVzaCh7XG4gICAgICAgICAgZHg6IGV2ZW50LmRldGFpbC5keCxcbiAgICAgICAgICB0aW1lU3RhbXA6IERhdGUubm93KClcbiAgICAgICAgfSk7XG4gICAgICB9LFxuXG4gICAgICBfdHJhY2tFbmQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIHZhciB4ID0gZXZlbnQuZGV0YWlsLmR4ICsgdGhpcy5fdHJhbnNsYXRlT2Zmc2V0O1xuICAgICAgICB2YXIgZHJhd2VyV2lkdGggPSB0aGlzLmdldFdpZHRoKCk7XG4gICAgICAgIHZhciBpc1Bvc2l0aW9uTGVmdCA9IHRoaXMucG9zaXRpb24gPT09ICdsZWZ0JztcbiAgICAgICAgdmFyIGlzSW5FbmRTdGF0ZSA9IGlzUG9zaXRpb25MZWZ0ID8gKHggPj0gMCB8fCB4IDw9IC1kcmF3ZXJXaWR0aCkgOlxuICAgICAgICAgICh4IDw9IDAgfHwgeCA+PSBkcmF3ZXJXaWR0aCk7XG5cbiAgICAgICAgaWYgKCFpc0luRW5kU3RhdGUpIHtcbiAgICAgICAgICAvLyBObyBsb25nZXIgbmVlZCB0aGUgdHJhY2sgZXZlbnRzIGFmdGVyIHRoaXMgbWV0aG9kIHJldHVybnMgLSBhbGxvdyB0aGVtIHRvIGJlIEdDJ2QuXG4gICAgICAgICAgdmFyIHRyYWNrRGV0YWlscyA9IHRoaXMuX3RyYWNrRGV0YWlscztcbiAgICAgICAgICB0aGlzLl90cmFja0RldGFpbHMgPSBudWxsO1xuXG4gICAgICAgICAgdGhpcy5fZmxpbmdEcmF3ZXIoZXZlbnQsIHRyYWNrRGV0YWlscyk7XG4gICAgICAgICAgaWYgKHRoaXMuX2RyYXdlclN0YXRlID09PSB0aGlzLl9EUkFXRVJfU1RBVEUuRkxJTkdJTkcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGUgZHJhd2VyIGlzIG5vdCBmbGluZ2luZywgdG9nZ2xlIHRoZSBvcGVuZWQgc3RhdGUgYmFzZWQgb24gdGhlIHBvc2l0aW9uIG9mXG4gICAgICAgIC8vIHRoZSBkcmF3ZXIuXG4gICAgICAgIHZhciBoYWxmV2lkdGggPSBkcmF3ZXJXaWR0aCAvIDI7XG4gICAgICAgIGlmIChldmVudC5kZXRhaWwuZHggPCAtaGFsZldpZHRoKSB7XG4gICAgICAgICAgdGhpcy5vcGVuZWQgPSB0aGlzLnBvc2l0aW9uID09PSAncmlnaHQnO1xuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50LmRldGFpbC5keCA+IGhhbGZXaWR0aCkge1xuICAgICAgICAgIHRoaXMub3BlbmVkID0gdGhpcy5wb3NpdGlvbiA9PT0gJ2xlZnQnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzSW5FbmRTdGF0ZSkge1xuICAgICAgICAgIHRoaXMuZGVib3VuY2UoJ19yZXNldERyYXdlclN0YXRlJywgdGhpcy5fcmVzZXREcmF3ZXJTdGF0ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5kZWJvdW5jZSgnX3Jlc2V0RHJhd2VyU3RhdGUnLCB0aGlzLl9yZXNldERyYXdlclN0YXRlLCB0aGlzLnRyYW5zaXRpb25EdXJhdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9zdHlsZVRyYW5zaXRpb25EdXJhdGlvbih0aGlzLnRyYW5zaXRpb25EdXJhdGlvbik7XG4gICAgICAgIHRoaXMuX3Jlc2V0RHJhd2VyVHJhbnNsYXRlKCk7XG4gICAgICAgIHRoaXMuc3R5bGUudmlzaWJpbGl0eSA9ICcnO1xuICAgICAgfSxcblxuICAgICAgX2NhbGN1bGF0ZVZlbG9jaXR5OiBmdW5jdGlvbihldmVudCwgdHJhY2tEZXRhaWxzKSB7XG4gICAgICAgIC8vIEZpbmQgdGhlIG9sZGVzdCB0cmFjayBldmVudCB0aGF0IGlzIHdpdGhpbiAxMDBtcyB1c2luZyBiaW5hcnkgc2VhcmNoLlxuICAgICAgICB2YXIgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdmFyIHRpbWVMb3dlckJvdW5kID0gbm93IC0gMTAwO1xuICAgICAgICB2YXIgdHJhY2tEZXRhaWw7XG4gICAgICAgIHZhciBtaW4gPSAwO1xuICAgICAgICB2YXIgbWF4ID0gdHJhY2tEZXRhaWxzLmxlbmd0aCAtIDE7XG5cbiAgICAgICAgd2hpbGUgKG1pbiA8PSBtYXgpIHtcbiAgICAgICAgICAvLyBGbG9vciBvZiBhdmVyYWdlIG9mIG1pbiBhbmQgbWF4LlxuICAgICAgICAgIHZhciBtaWQgPSAobWluICsgbWF4KSA+PiAxO1xuICAgICAgICAgIHZhciBkID0gdHJhY2tEZXRhaWxzW21pZF07XG4gICAgICAgICAgaWYgKGQudGltZVN0YW1wID49IHRpbWVMb3dlckJvdW5kKSB7XG4gICAgICAgICAgICB0cmFja0RldGFpbCA9IGQ7XG4gICAgICAgICAgICBtYXggPSBtaWQgLSAxO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtaW4gPSBtaWQgKyAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0cmFja0RldGFpbCkge1xuICAgICAgICAgIHZhciBkeCA9IGV2ZW50LmRldGFpbC5keCAtIHRyYWNrRGV0YWlsLmR4O1xuICAgICAgICAgIHZhciBkdCA9IChub3cgLSB0cmFja0RldGFpbC50aW1lU3RhbXApIHx8IDE7XG4gICAgICAgICAgcmV0dXJuIGR4IC8gZHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9LFxuXG4gICAgICBfZmxpbmdEcmF3ZXI6IGZ1bmN0aW9uKGV2ZW50LCB0cmFja0RldGFpbHMpIHtcbiAgICAgICAgdmFyIHZlbG9jaXR5ID0gdGhpcy5fY2FsY3VsYXRlVmVsb2NpdHkoZXZlbnQsIHRyYWNrRGV0YWlscyk7XG5cbiAgICAgICAgLy8gRG8gbm90IGZsaW5nIGlmIHZlbG9jaXR5IGlzIG5vdCBhYm92ZSBhIHRocmVzaG9sZC5cbiAgICAgICAgaWYgKE1hdGguYWJzKHZlbG9jaXR5KSA8IHRoaXMuX01JTl9GTElOR19USFJFU0hPTEQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9kcmF3ZXJTdGF0ZSA9IHRoaXMuX0RSQVdFUl9TVEFURS5GTElOR0lORztcblxuICAgICAgICB2YXIgeCA9IGV2ZW50LmRldGFpbC5keCArIHRoaXMuX3RyYW5zbGF0ZU9mZnNldDtcbiAgICAgICAgdmFyIGRyYXdlcldpZHRoID0gdGhpcy5nZXRXaWR0aCgpO1xuICAgICAgICB2YXIgaXNQb3NpdGlvbkxlZnQgPSB0aGlzLnBvc2l0aW9uID09PSAnbGVmdCc7XG4gICAgICAgIHZhciBpc1ZlbG9jaXR5UG9zaXRpdmUgPSB2ZWxvY2l0eSA+IDA7XG4gICAgICAgIHZhciBpc0Nsb3NpbmdMZWZ0ID0gIWlzVmVsb2NpdHlQb3NpdGl2ZSAmJiBpc1Bvc2l0aW9uTGVmdDtcbiAgICAgICAgdmFyIGlzQ2xvc2luZ1JpZ2h0ID0gaXNWZWxvY2l0eVBvc2l0aXZlICYmICFpc1Bvc2l0aW9uTGVmdDtcbiAgICAgICAgdmFyIGR4O1xuICAgICAgICBpZiAoaXNDbG9zaW5nTGVmdCkge1xuICAgICAgICAgIGR4ID0gLSh4ICsgZHJhd2VyV2lkdGgpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzQ2xvc2luZ1JpZ2h0KSB7XG4gICAgICAgICAgZHggPSAoZHJhd2VyV2lkdGggLSB4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkeCA9IC14O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRW5mb3JjZSBhIG1pbmltdW0gdHJhbnNpdGlvbiB2ZWxvY2l0eSB0byBtYWtlIHRoZSBkcmF3ZXIgZmVlbCBzbmFwcHkuXG4gICAgICAgIGlmIChpc1ZlbG9jaXR5UG9zaXRpdmUpIHtcbiAgICAgICAgICB2ZWxvY2l0eSA9IE1hdGgubWF4KHZlbG9jaXR5LCB0aGlzLl9NSU5fVFJBTlNJVElPTl9WRUxPQ0lUWSk7XG4gICAgICAgICAgdGhpcy5vcGVuZWQgPSB0aGlzLnBvc2l0aW9uID09PSAnbGVmdCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmVsb2NpdHkgPSBNYXRoLm1pbih2ZWxvY2l0eSwgLXRoaXMuX01JTl9UUkFOU0lUSU9OX1ZFTE9DSVRZKTtcbiAgICAgICAgICB0aGlzLm9wZW5lZCA9IHRoaXMucG9zaXRpb24gPT09ICdyaWdodCc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIGFtb3VudCBvZiB0aW1lIG5lZWRlZCB0byBmaW5pc2ggdGhlIHRyYW5zaXRpb24gYmFzZWQgb24gdGhlXG4gICAgICAgIC8vIGluaXRpYWwgc2xvcGUgb2YgdGhlIHRpbWluZyBmdW5jdGlvbi5cbiAgICAgICAgdmFyIHQgPSB0aGlzLl9GTElOR19JTklUSUFMX1NMT1BFICogZHggLyB2ZWxvY2l0eVxuICAgICAgICB0aGlzLl9zdHlsZVRyYW5zaXRpb25EdXJhdGlvbih0KTtcbiAgICAgICAgdGhpcy5fc3R5bGVUcmFuc2l0aW9uVGltaW5nRnVuY3Rpb24odGhpcy5fRkxJTkdfVElNSU5HX0ZVTkNUSU9OKTtcblxuICAgICAgICB0aGlzLl9yZXNldERyYXdlclRyYW5zbGF0ZSgpO1xuICAgICAgICB0aGlzLmRlYm91bmNlKCdfcmVzZXREcmF3ZXJTdGF0ZScsIHRoaXMuX3Jlc2V0RHJhd2VyU3RhdGUsIHQpO1xuICAgICAgfSxcblxuICAgICAgX3N0eWxlVHJhbnNpdGlvbkR1cmF0aW9uOiBmdW5jdGlvbihkdXJhdGlvbikge1xuICAgICAgICB0aGlzLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9IGR1cmF0aW9uICsgJ21zJztcbiAgICAgICAgdGhpcy4kLmNvbnRlbnRDb250YWluZXIuc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID0gZHVyYXRpb24gKyAnbXMnO1xuICAgICAgICB0aGlzLiQuc2NyaW0uc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID0gZHVyYXRpb24gKyAnbXMnO1xuICAgICAgfSxcblxuICAgICAgX3N0eWxlVHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uOiBmdW5jdGlvbih0aW1pbmdGdW5jdGlvbikge1xuICAgICAgICB0aGlzLiQuY29udGVudENvbnRhaW5lci5zdHlsZS50cmFuc2l0aW9uVGltaW5nRnVuY3Rpb24gPSB0aW1pbmdGdW5jdGlvbjtcbiAgICAgICAgdGhpcy4kLnNjcmltLnN0eWxlLnRyYW5zaXRpb25UaW1pbmdGdW5jdGlvbiA9IHRpbWluZ0Z1bmN0aW9uO1xuICAgICAgfSxcblxuICAgICAgX3RyYW5zbGF0ZURyYXdlcjogZnVuY3Rpb24oeCkge1xuICAgICAgICB2YXIgZHJhd2VyV2lkdGggPSB0aGlzLmdldFdpZHRoKCk7XG5cbiAgICAgICAgaWYgKHRoaXMucG9zaXRpb24gPT09ICdsZWZ0Jykge1xuICAgICAgICAgIHggPSBNYXRoLm1heCgtZHJhd2VyV2lkdGgsIE1hdGgubWluKHgsIDApKTtcbiAgICAgICAgICB0aGlzLiQuc2NyaW0uc3R5bGUub3BhY2l0eSA9IDEgKyB4IC8gZHJhd2VyV2lkdGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgeCA9IE1hdGgubWF4KDAsIE1hdGgubWluKHgsIGRyYXdlcldpZHRoKSk7XG4gICAgICAgICAgdGhpcy4kLnNjcmltLnN0eWxlLm9wYWNpdHkgPSAxIC0geCAvIGRyYXdlcldpZHRoO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy50cmFuc2xhdGUzZCh4ICsgJ3B4JywgJzAnLCAnMCcsIHRoaXMuJC5jb250ZW50Q29udGFpbmVyKTtcbiAgICAgIH0sXG5cbiAgICAgIF9yZXNldERyYXdlclRyYW5zbGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuJC5zY3JpbS5zdHlsZS5vcGFjaXR5ID0gJyc7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtKCcnLCB0aGlzLiQuY29udGVudENvbnRhaW5lcik7XG4gICAgICB9LFxuXG4gICAgICBfcmVzZXREcmF3ZXJTdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBvbGRTdGF0ZSA9IHRoaXMuX2RyYXdlclN0YXRlO1xuXG4gICAgICAgIC8vIElmIHRoZSBkcmF3ZXIgd2FzIGZsaW5naW5nLCB3ZSBuZWVkIHRvIHJlc2V0IHRoZSBzdHlsZSBhdHRyaWJ1dGVzLlxuICAgICAgICBpZiAob2xkU3RhdGUgPT09IHRoaXMuX0RSQVdFUl9TVEFURS5GTElOR0lORykge1xuICAgICAgICAgIHRoaXMuX3N0eWxlVHJhbnNpdGlvbkR1cmF0aW9uKHRoaXMudHJhbnNpdGlvbkR1cmF0aW9uKTtcbiAgICAgICAgICB0aGlzLl9zdHlsZVRyYW5zaXRpb25UaW1pbmdGdW5jdGlvbignJyk7XG4gICAgICAgICAgdGhpcy5zdHlsZS52aXNpYmlsaXR5ID0gJyc7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9zYXZlZFdpZHRoID0gbnVsbDtcblxuICAgICAgICBpZiAodGhpcy5vcGVuZWQpIHtcbiAgICAgICAgICB0aGlzLl9kcmF3ZXJTdGF0ZSA9IHRoaXMucGVyc2lzdGVudCA/XG4gICAgICAgICAgICB0aGlzLl9EUkFXRVJfU1RBVEUuT1BFTkVEX1BFUlNJU1RFTlQgOiB0aGlzLl9EUkFXRVJfU1RBVEUuT1BFTkVEO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX2RyYXdlclN0YXRlID0gdGhpcy5fRFJBV0VSX1NUQVRFLkNMT1NFRDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvbGRTdGF0ZSAhPT0gdGhpcy5fZHJhd2VyU3RhdGUpIHtcbiAgICAgICAgICBpZiAodGhpcy5fZHJhd2VyU3RhdGUgPT09IHRoaXMuX0RSQVdFUl9TVEFURS5PUEVORUQpIHtcbiAgICAgICAgICAgIHRoaXMuX3NldEtleWJvYXJkRm9jdXNUcmFwKCk7XG4gICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5fYm91bmRFc2NLZXlkb3duSGFuZGxlcik7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LnN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLl9ib3VuZEVzY0tleWRvd25IYW5kbGVyKTtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuc3R5bGUub3ZlcmZsb3cgPSAnJztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBEb24ndCBmaXJlIHRoZSBldmVudCBvbiBpbml0aWFsIGxvYWQuXG4gICAgICAgICAgaWYgKG9sZFN0YXRlICE9PSB0aGlzLl9EUkFXRVJfU1RBVEUuSU5JVCkge1xuICAgICAgICAgICAgdGhpcy5maXJlKCdhcHAtZHJhd2VyLXRyYW5zaXRpb25lZCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBSZXNldHMgdGhlIGxheW91dC5cbiAgICAgICAqXG4gICAgICAgKiBAbWV0aG9kIHJlc2V0TGF5b3V0XG4gICAgICAgKi9cbiAgICAgIHJlc2V0TGF5b3V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5maXJlKCdhcHAtcmVzZXQtbGF5b3V0Jyk7XG4gICAgICB9LFxuXG4gICAgICBfc2V0S2V5Ym9hcmRGb2N1c1RyYXA6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5ub0ZvY3VzVHJhcCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE5PVEU6IFVubGVzcyB3ZSB1c2UgL2RlZXAvICh3aGljaCB3ZSBzaG91bGRuJ3Qgc2luY2UgaXQncyBkZXByZWNhdGVkKSwgdGhpcyB3aWxsXG4gICAgICAgIC8vIG5vdCBzZWxlY3QgZm9jdXNhYmxlIGVsZW1lbnRzIGluc2lkZSBzaGFkb3cgcm9vdHMuXG4gICAgICAgIHZhciBmb2N1c2FibGVFbGVtZW50c1NlbGVjdG9yID0gW1xuICAgICAgICAgICAgJ2FbaHJlZl06bm90KFt0YWJpbmRleD1cIi0xXCJdKScsXG4gICAgICAgICAgICAnYXJlYVtocmVmXTpub3QoW3RhYmluZGV4PVwiLTFcIl0pJyxcbiAgICAgICAgICAgICdpbnB1dDpub3QoW2Rpc2FibGVkXSk6bm90KFt0YWJpbmRleD1cIi0xXCJdKScsXG4gICAgICAgICAgICAnc2VsZWN0Om5vdChbZGlzYWJsZWRdKTpub3QoW3RhYmluZGV4PVwiLTFcIl0pJyxcbiAgICAgICAgICAgICd0ZXh0YXJlYTpub3QoW2Rpc2FibGVkXSk6bm90KFt0YWJpbmRleD1cIi0xXCJdKScsXG4gICAgICAgICAgICAnYnV0dG9uOm5vdChbZGlzYWJsZWRdKTpub3QoW3RhYmluZGV4PVwiLTFcIl0pJyxcbiAgICAgICAgICAgICdpZnJhbWU6bm90KFt0YWJpbmRleD1cIi0xXCJdKScsXG4gICAgICAgICAgICAnW3RhYmluZGV4XTpub3QoW3RhYmluZGV4PVwiLTFcIl0pJyxcbiAgICAgICAgICAgICdbY29udGVudEVkaXRhYmxlPXRydWVdOm5vdChbdGFiaW5kZXg9XCItMVwiXSknXG4gICAgICAgICAgXS5qb2luKCcsJyk7XG4gICAgICAgIHZhciBmb2N1c2FibGVFbGVtZW50cyA9IFBvbHltZXIuZG9tKHRoaXMpLnF1ZXJ5U2VsZWN0b3JBbGwoZm9jdXNhYmxlRWxlbWVudHNTZWxlY3Rvcik7XG5cbiAgICAgICAgaWYgKGZvY3VzYWJsZUVsZW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB0aGlzLl9maXJzdFRhYlN0b3AgPSBmb2N1c2FibGVFbGVtZW50c1swXTtcbiAgICAgICAgICB0aGlzLl9sYXN0VGFiU3RvcCA9IGZvY3VzYWJsZUVsZW1lbnRzW2ZvY3VzYWJsZUVsZW1lbnRzLmxlbmd0aCAtIDFdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFJlc2V0IHNhdmVkIHRhYiBzdG9wcyB3aGVuIHRoZXJlIGFyZSBubyBmb2N1c2FibGUgZWxlbWVudHMgaW4gdGhlIGRyYXdlci5cbiAgICAgICAgICB0aGlzLl9maXJzdFRhYlN0b3AgPSBudWxsO1xuICAgICAgICAgIHRoaXMuX2xhc3RUYWJTdG9wID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZvY3VzIG9uIGFwcC1kcmF3ZXIgaWYgaXQgaGFzIG5vbi16ZXJvIHRhYmluZGV4LiBPdGhlcndpc2UsIGZvY3VzIHRoZSBmaXJzdCBmb2N1c2FibGVcbiAgICAgICAgLy8gZWxlbWVudCBpbiB0aGUgZHJhd2VyLCBpZiBpdCBleGlzdHMuIFVzZSB0aGUgdGFiaW5kZXggYXR0cmlidXRlIHNpbmNlIHRoZSB0aGlzLnRhYkluZGV4XG4gICAgICAgIC8vIHByb3BlcnR5IGluIElFL0VkZ2UgcmV0dXJucyAwIChpbnN0ZWFkIG9mIC0xKSB3aGVuIHRoZSBhdHRyaWJ1dGUgaXMgbm90IHNldC5cbiAgICAgICAgdmFyIHRhYmluZGV4ID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3RhYmluZGV4Jyk7XG4gICAgICAgIGlmICh0YWJpbmRleCAmJiBwYXJzZUludCh0YWJpbmRleCwgMTApID4gLTEpIHtcbiAgICAgICAgICB0aGlzLmZvY3VzKCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fZmlyc3RUYWJTdG9wKSB7XG4gICAgICAgICAgdGhpcy5fZmlyc3RUYWJTdG9wLmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIF90YWJLZXlkb3duSGFuZGxlcjogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMubm9Gb2N1c1RyYXApIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgVEFCX0tFWUNPREUgPSA5O1xuICAgICAgICBpZiAodGhpcy5fZHJhd2VyU3RhdGUgPT09IHRoaXMuX0RSQVdFUl9TVEFURS5PUEVORUQgJiYgZXZlbnQua2V5Q29kZSA9PT0gVEFCX0tFWUNPREUpIHtcbiAgICAgICAgICBpZiAoZXZlbnQuc2hpZnRLZXkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9maXJzdFRhYlN0b3AgJiYgUG9seW1lci5kb20oZXZlbnQpLmxvY2FsVGFyZ2V0ID09PSB0aGlzLl9maXJzdFRhYlN0b3ApIHtcbiAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgdGhpcy5fbGFzdFRhYlN0b3AuZm9jdXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2xhc3RUYWJTdG9wICYmIFBvbHltZXIuZG9tKGV2ZW50KS5sb2NhbFRhcmdldCA9PT0gdGhpcy5fbGFzdFRhYlN0b3ApIHtcbiAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgdGhpcy5fZmlyc3RUYWJTdG9wLmZvY3VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBfb3BlbmVkUGVyc2lzdGVudENoYW5nZWQ6IGZ1bmN0aW9uKG9wZW5lZCwgcGVyc2lzdGVudCkge1xuICAgICAgICB0aGlzLnRvZ2dsZUNsYXNzKCd2aXNpYmxlJywgb3BlbmVkICYmICFwZXJzaXN0ZW50LCB0aGlzLiQuc2NyaW0pO1xuXG4gICAgICAgIC8vIFVzZSBhIGRlYm91bmNlIHRpbWVyIGluc3RlYWQgb2YgdHJhbnNpdGlvbmVuZCBzaW5jZSB0cmFuc2l0aW9uZW5kIHdvbid0IGZpcmUgd2hlblxuICAgICAgICAvLyBhcHAtZHJhd2VyIGlzIGRpc3BsYXk6IG5vbmUuXG4gICAgICAgIHRoaXMuZGVib3VuY2UoJ19yZXNldERyYXdlclN0YXRlJywgdGhpcy5fcmVzZXREcmF3ZXJTdGF0ZSwgdGhpcy50cmFuc2l0aW9uRHVyYXRpb24pO1xuICAgICAgfSxcblxuICAgICAgX01JTl9GTElOR19USFJFU0hPTEQ6IDAuMixcblxuICAgICAgX01JTl9UUkFOU0lUSU9OX1ZFTE9DSVRZOiAxLjIsXG5cbiAgICAgIF9GTElOR19USU1JTkdfRlVOQ1RJT046ICdjdWJpYy1iZXppZXIoMC42NjcsIDEsIDAuNjY3LCAxKScsXG5cbiAgICAgIF9GTElOR19JTklUSUFMX1NMT1BFOiAxLjUsXG5cbiAgICAgIF9EUkFXRVJfU1RBVEU6IHtcbiAgICAgICAgSU5JVDogMCxcbiAgICAgICAgT1BFTkVEOiAxLFxuICAgICAgICBPUEVORURfUEVSU0lTVEVOVDogMixcbiAgICAgICAgQ0xPU0VEOiAzLFxuICAgICAgICBUUkFDS0lORzogNCxcbiAgICAgICAgRkxJTkdJTkc6IDVcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBGaXJlZCB3aGVuIHRoZSBsYXlvdXQgb2YgYXBwLWRyYXdlciBoYXMgY2hhbmdlZC5cbiAgICAgICAqXG4gICAgICAgKiBAZXZlbnQgYXBwLXJlc2V0LWxheW91dFxuICAgICAgICovXG5cbiAgICAgIC8qKlxuICAgICAgICogRmlyZWQgd2hlbiBhcHAtZHJhd2VyIGhhcyBmaW5pc2hlZCB0cmFuc2l0aW9uaW5nLlxuICAgICAgICpcbiAgICAgICAqIEBldmVudCBhcHAtZHJhd2VyLXRyYW5zaXRpb25lZFxuICAgICAgICovXG4gICAgfSk7XG4gIDwvc2NyaXB0PlxuPC9kb20tbW9kdWxlPlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9hcHAtbGF5b3V0L2FwcC1kcmF3ZXIvYXBwLWRyYXdlci5odG1sIiwiXG5yZXF1aXJlKCcuL2FwcGx5LXNoaW0ubWluLmpzJyk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL3NoYWR5Y3NzL2FwcGx5LXNoaW0uaHRtbCIsIihmdW5jdGlvbigpey8qXG5cbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiovXG4ndXNlIHN0cmljdCc7dmFyIGs9e307ZnVuY3Rpb24gbigpe3RoaXMuZW5kPXRoaXMuc3RhcnQ9MDt0aGlzLnJ1bGVzPXRoaXMucGFyZW50PXRoaXMucHJldmlvdXM9bnVsbDt0aGlzLmNzc1RleHQ9dGhpcy5wYXJzZWRDc3NUZXh0PVwiXCI7dGhpcy5hdFJ1bGU9ITE7dGhpcy50eXBlPTA7dGhpcy5wYXJzZWRTZWxlY3Rvcj10aGlzLnNlbGVjdG9yPXRoaXMua2V5ZnJhbWVzTmFtZT1cIlwifVxuZnVuY3Rpb24gcChhKXthPWEucmVwbGFjZShhYSxcIlwiKS5yZXBsYWNlKGJhLFwiXCIpO3ZhciBiPXEsYz1hLGQ9bmV3IG47ZC5zdGFydD0wO2QuZW5kPWMubGVuZ3RoO2Zvcih2YXIgZT1kLGY9MCxoPWMubGVuZ3RoO2Y8aDtmKyspaWYoXCJ7XCI9PT1jW2ZdKXtlLnJ1bGVzfHwoZS5ydWxlcz1bXSk7dmFyIGc9ZSxtPWcucnVsZXNbZy5ydWxlcy5sZW5ndGgtMV18fG51bGw7ZT1uZXcgbjtlLnN0YXJ0PWYrMTtlLnBhcmVudD1nO2UucHJldmlvdXM9bTtnLnJ1bGVzLnB1c2goZSl9ZWxzZVwifVwiPT09Y1tmXSYmKGUuZW5kPWYrMSxlPWUucGFyZW50fHxkKTtyZXR1cm4gYihkLGEpfVxuZnVuY3Rpb24gcShhLGIpe3ZhciBjPWIuc3Vic3RyaW5nKGEuc3RhcnQsYS5lbmQtMSk7YS5wYXJzZWRDc3NUZXh0PWEuY3NzVGV4dD1jLnRyaW0oKTthLnBhcmVudCYmKGM9Yi5zdWJzdHJpbmcoYS5wcmV2aW91cz9hLnByZXZpb3VzLmVuZDphLnBhcmVudC5zdGFydCxhLnN0YXJ0LTEpLGM9Y2EoYyksYz1jLnJlcGxhY2UocixcIiBcIiksYz1jLnN1YnN0cmluZyhjLmxhc3RJbmRleE9mKFwiO1wiKSsxKSxjPWEucGFyc2VkU2VsZWN0b3I9YS5zZWxlY3Rvcj1jLnRyaW0oKSxhLmF0UnVsZT0wPT09Yy5pbmRleE9mKFwiQFwiKSxhLmF0UnVsZT8wPT09Yy5pbmRleE9mKFwiQG1lZGlhXCIpP2EudHlwZT10OmMubWF0Y2goZGEpJiYoYS50eXBlPXUsYS5rZXlmcmFtZXNOYW1lPWEuc2VsZWN0b3Iuc3BsaXQocikucG9wKCkpOmEudHlwZT0wPT09Yy5pbmRleE9mKFwiLS1cIik/djp4KTtpZihjPWEucnVsZXMpZm9yKHZhciBkPTAsZT1jLmxlbmd0aCxmO2Q8ZSYmKGY9Y1tkXSk7ZCsrKXEoZixiKTtyZXR1cm4gYX1cbmZ1bmN0aW9uIGNhKGEpe3JldHVybiBhLnJlcGxhY2UoL1xcXFwoWzAtOWEtZl17MSw2fSlcXHMvZ2ksZnVuY3Rpb24oYSxjKXthPWM7Zm9yKGM9Ni1hLmxlbmd0aDtjLS07KWE9XCIwXCIrYTtyZXR1cm5cIlxcXFxcIithfSl9XG5mdW5jdGlvbiB5KGEsYixjKXtjPXZvaWQgMD09PWM/XCJcIjpjO3ZhciBkPVwiXCI7aWYoYS5jc3NUZXh0fHxhLnJ1bGVzKXt2YXIgZT1hLnJ1bGVzLGY7aWYoZj1lKWY9ZVswXSxmPSEoZiYmZi5zZWxlY3RvciYmMD09PWYuc2VsZWN0b3IuaW5kZXhPZihcIi0tXCIpKTtpZihmKXtmPTA7Zm9yKHZhciBoPWUubGVuZ3RoLGc7ZjxoJiYoZz1lW2ZdKTtmKyspZD15KGcsYixkKX1lbHNlIGI/Yj1hLmNzc1RleHQ6KGI9YS5jc3NUZXh0LGI9Yi5yZXBsYWNlKGVhLFwiXCIpLnJlcGxhY2UoZmEsXCJcIiksYj1iLnJlcGxhY2UoaGEsXCJcIikucmVwbGFjZShpYSxcIlwiKSksKGQ9Yi50cmltKCkpJiYoZD1cIiAgXCIrZCtcIlxcblwiKX1kJiYoYS5zZWxlY3RvciYmKGMrPWEuc2VsZWN0b3IrXCIge1xcblwiKSxjKz1kLGEuc2VsZWN0b3ImJihjKz1cIn1cXG5cXG5cIikpO3JldHVybiBjfVxudmFyIHg9MSx1PTcsdD00LHY9MUUzLGFhPS9cXC9cXCpbXipdKlxcKisoW14vKl1bXipdKlxcKispKlxcLy9naW0sYmE9L0BpbXBvcnRbXjtdKjsvZ2ltLGVhPS8oPzpeW147XFwtXFxzfV0rKT8tLVteO3t9XSo/Oltee307XSo/KD86WztcXG5dfCQpL2dpbSxmYT0vKD86XlteO1xcLVxcc31dKyk/LS1bXjt7fV0qPzpbXnt9O10qP3tbXn1dKj99KD86WztcXG5dfCQpPy9naW0saGE9L0BhcHBseVxccypcXCg/W14pO10qXFwpP1xccyooPzpbO1xcbl18JCk/L2dpbSxpYT0vW147Ol0qPzpbXjtdKj92YXJcXChbXjtdKlxcKSg/Ols7XFxuXXwkKT8vZ2ltLGRhPS9eQFteXFxzXSprZXlmcmFtZXMvLHI9L1xccysvZzt2YXIgamE9UHJvbWlzZS5yZXNvbHZlKCk7ZnVuY3Rpb24ga2EoYSl7aWYoYT1rW2FdKWEuX2FwcGx5U2hpbUN1cnJlbnRWZXJzaW9uPWEuX2FwcGx5U2hpbUN1cnJlbnRWZXJzaW9ufHwwLGEuX2FwcGx5U2hpbVZhbGlkYXRpbmdWZXJzaW9uPWEuX2FwcGx5U2hpbVZhbGlkYXRpbmdWZXJzaW9ufHwwLGEuX2FwcGx5U2hpbU5leHRWZXJzaW9uPShhLl9hcHBseVNoaW1OZXh0VmVyc2lvbnx8MCkrMX1mdW5jdGlvbiB6KGEpe3JldHVybiBhLl9hcHBseVNoaW1DdXJyZW50VmVyc2lvbj09PWEuX2FwcGx5U2hpbU5leHRWZXJzaW9ufWZ1bmN0aW9uIGxhKGEpe2EuX2FwcGx5U2hpbVZhbGlkYXRpbmdWZXJzaW9uPWEuX2FwcGx5U2hpbU5leHRWZXJzaW9uO2EuYXx8KGEuYT0hMCxqYS50aGVuKGZ1bmN0aW9uKCl7YS5fYXBwbHlTaGltQ3VycmVudFZlcnNpb249YS5fYXBwbHlTaGltTmV4dFZlcnNpb247YS5hPSExfSkpfTt2YXIgQT0hKHdpbmRvdy5TaGFkeURPTSYmd2luZG93LlNoYWR5RE9NLmluVXNlKSxCO2Z1bmN0aW9uIEMoYSl7Qj1hJiZhLnNoaW1jc3Nwcm9wZXJ0aWVzPyExOkF8fCEobmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvQXBwbGVXZWJLaXRcXC82MDF8RWRnZVxcLzE1Lyl8fCF3aW5kb3cuQ1NTfHwhQ1NTLnN1cHBvcnRzfHwhQ1NTLnN1cHBvcnRzKFwiYm94LXNoYWRvd1wiLFwiMCAwIDAgdmFyKC0tZm9vKVwiKSl9d2luZG93LlNoYWR5Q1NTJiZ2b2lkIDAhPT13aW5kb3cuU2hhZHlDU1MubmF0aXZlQ3NzP0I9d2luZG93LlNoYWR5Q1NTLm5hdGl2ZUNzczp3aW5kb3cuU2hhZHlDU1M/KEMod2luZG93LlNoYWR5Q1NTKSx3aW5kb3cuU2hhZHlDU1M9dm9pZCAwKTpDKHdpbmRvdy5XZWJDb21wb25lbnRzJiZ3aW5kb3cuV2ViQ29tcG9uZW50cy5mbGFncyk7dmFyIEU9Qjt2YXIgRj0vKD86XnxbO1xcc3tdXFxzKikoLS1bXFx3LV0qPylcXHMqOlxccyooPzooKD86Jyg/OlxcXFwnfC4pKj8nfFwiKD86XFxcXFwifC4pKj9cInxcXChbXildKj9cXCl8W159O3tdKSspfFxceyhbXn1dKilcXH0oPzooPz1bO1xcc31dKXwkKSkvZ2ksRz0vKD86XnxcXFcrKUBhcHBseVxccypcXCg/KFteKTtcXG5dKilcXCk/L2dpLG1hPS9AbWVkaWFcXHMoLiopLztmdW5jdGlvbiBIKGEpe2lmKCFhKXJldHVyblwiXCI7XCJzdHJpbmdcIj09PXR5cGVvZiBhJiYoYT1wKGEpKTtyZXR1cm4geShhLEUpfWZ1bmN0aW9uIEkoYSl7IWEuX19jc3NSdWxlcyYmYS50ZXh0Q29udGVudCYmKGEuX19jc3NSdWxlcz1wKGEudGV4dENvbnRlbnQpKTtyZXR1cm4gYS5fX2Nzc1J1bGVzfHxudWxsfWZ1bmN0aW9uIEooYSxiLGMsZCl7aWYoYSl7dmFyIGU9ITEsZj1hLnR5cGU7aWYoZCYmZj09PXQpe3ZhciBoPWEuc2VsZWN0b3IubWF0Y2gobWEpO2gmJih3aW5kb3cubWF0Y2hNZWRpYShoWzFdKS5tYXRjaGVzfHwoZT0hMCkpfWY9PT14P2IoYSk6YyYmZj09PXU/YyhhKTpmPT09diYmKGU9ITApO2lmKChhPWEucnVsZXMpJiYhZSl7ZT0wO2Y9YS5sZW5ndGg7Zm9yKHZhciBnO2U8ZiYmKGc9YVtlXSk7ZSsrKUooZyxiLGMsZCl9fX1cbmZ1bmN0aW9uIEsoYSxiKXt2YXIgYz1hLmluZGV4T2YoXCJ2YXIoXCIpO2lmKC0xPT09YylyZXR1cm4gYihhLFwiXCIsXCJcIixcIlwiKTthOnt2YXIgZD0wO3ZhciBlPWMrMztmb3IodmFyIGY9YS5sZW5ndGg7ZTxmO2UrKylpZihcIihcIj09PWFbZV0pZCsrO2Vsc2UgaWYoXCIpXCI9PT1hW2VdJiYwPT09LS1kKWJyZWFrIGE7ZT0tMX1kPWEuc3Vic3RyaW5nKGMrNCxlKTtjPWEuc3Vic3RyaW5nKDAsYyk7YT1LKGEuc3Vic3RyaW5nKGUrMSksYik7ZT1kLmluZGV4T2YoXCIsXCIpO3JldHVybi0xPT09ZT9iKGMsZC50cmltKCksXCJcIixhKTpiKGMsZC5zdWJzdHJpbmcoMCxlKS50cmltKCksZC5zdWJzdHJpbmcoZSsxKS50cmltKCksYSl9O3ZhciBuYT0vO1xccyovbSxvYT0vXlxccyooaW5pdGlhbCl8KGluaGVyaXQpXFxzKiQvO2Z1bmN0aW9uIEwoKXt0aGlzLmE9e319TC5wcm90b3R5cGUuc2V0PWZ1bmN0aW9uKGEsYil7YT1hLnRyaW0oKTt0aGlzLmFbYV09e2g6YixpOnt9fX07TC5wcm90b3R5cGUuZ2V0PWZ1bmN0aW9uKGEpe2E9YS50cmltKCk7cmV0dXJuIHRoaXMuYVthXXx8bnVsbH07dmFyIE09bnVsbDtmdW5jdGlvbiBOKCl7dGhpcy5iPXRoaXMuYz1udWxsO3RoaXMuYT1uZXcgTH1OLnByb3RvdHlwZS5vPWZ1bmN0aW9uKGEpe2E9Ry50ZXN0KGEpfHxGLnRlc3QoYSk7Ry5sYXN0SW5kZXg9MDtGLmxhc3RJbmRleD0wO3JldHVybiBhfTtOLnByb3RvdHlwZS5tPWZ1bmN0aW9uKGEsYil7YT1hLmNvbnRlbnQucXVlcnlTZWxlY3RvcihcInN0eWxlXCIpO3ZhciBjPW51bGw7YSYmKGM9dGhpcy5qKGEsYikpO3JldHVybiBjfTtcbk4ucHJvdG90eXBlLmo9ZnVuY3Rpb24oYSxiKXtiPXZvaWQgMD09PWI/XCJcIjpiO3ZhciBjPUkoYSk7dGhpcy5sKGMsYik7YS50ZXh0Q29udGVudD1IKGMpO3JldHVybiBjfTtOLnByb3RvdHlwZS5mPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMsYz1JKGEpO0ooYyxmdW5jdGlvbihhKXtcIjpyb290XCI9PT1hLnNlbGVjdG9yJiYoYS5zZWxlY3Rvcj1cImh0bWxcIik7Yi5nKGEpfSk7YS50ZXh0Q29udGVudD1IKGMpO3JldHVybiBjfTtOLnByb3RvdHlwZS5sPWZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpczt0aGlzLmM9YjtKKGEsZnVuY3Rpb24oYSl7Yy5nKGEpfSk7dGhpcy5jPW51bGx9O04ucHJvdG90eXBlLmc9ZnVuY3Rpb24oYSl7YS5jc3NUZXh0PXBhKHRoaXMsYS5wYXJzZWRDc3NUZXh0KTtcIjpyb290XCI9PT1hLnNlbGVjdG9yJiYoYS5zZWxlY3Rvcj1cIjpob3N0ID4gKlwiKX07XG5mdW5jdGlvbiBwYShhLGIpe2I9Yi5yZXBsYWNlKEYsZnVuY3Rpb24oYixkLGUsZil7cmV0dXJuIHFhKGEsYixkLGUsZil9KTtyZXR1cm4gTyhhLGIpfWZ1bmN0aW9uIE8oYSxiKXtmb3IodmFyIGM7Yz1HLmV4ZWMoYik7KXt2YXIgZD1jWzBdLGU9Y1sxXTtjPWMuaW5kZXg7dmFyIGY9Yi5zbGljZSgwLGMrZC5pbmRleE9mKFwiQGFwcGx5XCIpKTtiPWIuc2xpY2UoYytkLmxlbmd0aCk7dmFyIGg9UChhLGYpO2Q9dm9pZCAwO3ZhciBnPWE7ZT1lLnJlcGxhY2UobmEsXCJcIik7dmFyIG09W107dmFyIGw9Zy5hLmdldChlKTtsfHwoZy5hLnNldChlLHt9KSxsPWcuYS5nZXQoZSkpO2lmKGwpZm9yKGQgaW4gZy5jJiYobC5pW2cuY109ITApLGwuaClnPWgmJmhbZF0sbD1bZCxcIjogdmFyKFwiLGUsXCJfLV9cIixkXSxnJiZsLnB1c2goXCIsXCIsZyksbC5wdXNoKFwiKVwiKSxtLnB1c2gobC5qb2luKFwiXCIpKTtkPW0uam9pbihcIjsgXCIpO2I9XCJcIitmK2QrYjtHLmxhc3RJbmRleD1jK2QubGVuZ3RofXJldHVybiBifVxuZnVuY3Rpb24gUChhLGIpe2I9Yi5zcGxpdChcIjtcIik7Zm9yKHZhciBjLGQsZT17fSxmPTAsaDtmPGIubGVuZ3RoO2YrKylpZihjPWJbZl0paWYoaD1jLnNwbGl0KFwiOlwiKSwxPGgubGVuZ3RoKXtjPWhbMF0udHJpbSgpO3ZhciBnPWE7ZD1jO2g9aC5zbGljZSgxKS5qb2luKFwiOlwiKTt2YXIgbT1vYS5leGVjKGgpO20mJihtWzFdPyhnLmJ8fChnLmI9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIm1ldGFcIiksZy5iLnNldEF0dHJpYnV0ZShcImFwcGx5LXNoaW0tbWVhc3VyZVwiLFwiXCIpLGcuYi5zdHlsZS5hbGw9XCJpbml0aWFsXCIsZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChnLmIpKSxkPXdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGcuYikuZ2V0UHJvcGVydHlWYWx1ZShkKSk6ZD1cImFwcGx5LXNoaW0taW5oZXJpdFwiLGg9ZCk7ZD1oO2VbY109ZH1yZXR1cm4gZX1mdW5jdGlvbiByYShhLGIpe2lmKE0pZm9yKHZhciBjIGluIGIuaSljIT09YS5jJiZNKGMpfVxuZnVuY3Rpb24gcWEoYSxiLGMsZCxlKXtkJiZLKGQsZnVuY3Rpb24oYixjKXtjJiZhLmEuZ2V0KGMpJiYoZT1cIkBhcHBseSBcIitjK1wiO1wiKX0pO2lmKCFlKXJldHVybiBiO3ZhciBmPU8oYSxlKSxoPWIuc2xpY2UoMCxiLmluZGV4T2YoXCItLVwiKSksZz1mPVAoYSxmKSxtPWEuYS5nZXQoYyksbD1tJiZtLmg7bD9nPU9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShsKSxmKTphLmEuc2V0KGMsZyk7dmFyIFg9W10sdyxZPSExO2Zvcih3IGluIGcpe3ZhciBEPWZbd107dm9pZCAwPT09RCYmKEQ9XCJpbml0aWFsXCIpOyFsfHx3IGluIGx8fChZPSEwKTtYLnB1c2goXCJcIitjK1wiXy1fXCIrdytcIjogXCIrRCl9WSYmcmEoYSxtKTttJiYobS5oPWcpO2QmJihoPWIrXCI7XCIraCk7cmV0dXJuXCJcIitoK1guam9pbihcIjsgXCIpK1wiO1wifU4ucHJvdG90eXBlLmRldGVjdE1peGluPU4ucHJvdG90eXBlLm87Ti5wcm90b3R5cGUudHJhbnNmb3JtU3R5bGU9Ti5wcm90b3R5cGUuajtcbk4ucHJvdG90eXBlLnRyYW5zZm9ybUN1c3RvbVN0eWxlPU4ucHJvdG90eXBlLmY7Ti5wcm90b3R5cGUudHJhbnNmb3JtUnVsZXM9Ti5wcm90b3R5cGUubDtOLnByb3RvdHlwZS50cmFuc2Zvcm1SdWxlPU4ucHJvdG90eXBlLmc7Ti5wcm90b3R5cGUudHJhbnNmb3JtVGVtcGxhdGU9Ti5wcm90b3R5cGUubTtOLnByb3RvdHlwZS5fc2VwYXJhdG9yPVwiXy1fXCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KE4ucHJvdG90eXBlLFwiaW52YWxpZENhbGxiYWNrXCIse2dldDpmdW5jdGlvbigpe3JldHVybiBNfSxzZXQ6ZnVuY3Rpb24oYSl7TT1hfX0pO3ZhciBRPW51bGwsUj13aW5kb3cuSFRNTEltcG9ydHMmJndpbmRvdy5IVE1MSW1wb3J0cy53aGVuUmVhZHl8fG51bGwsUztmdW5jdGlvbiBzYShhKXtyZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKXtSP1IoYSk6KFF8fChRPW5ldyBQcm9taXNlKGZ1bmN0aW9uKGEpe1M9YX0pLFwiY29tcGxldGVcIj09PWRvY3VtZW50LnJlYWR5U3RhdGU/UygpOmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJyZWFkeXN0YXRlY2hhbmdlXCIsZnVuY3Rpb24oKXtcImNvbXBsZXRlXCI9PT1kb2N1bWVudC5yZWFkeVN0YXRlJiZTKCl9KSksUS50aGVuKGZ1bmN0aW9uKCl7YSYmYSgpfSkpfSl9O3ZhciBUPW5ldyBOO2Z1bmN0aW9uIFUoKXt2YXIgYT10aGlzO3RoaXMuYT1udWxsO3NhKGZ1bmN0aW9uKCl7VihhKX0pO1QuaW52YWxpZENhbGxiYWNrPWthfWZ1bmN0aW9uIFYoYSl7YS5hfHwoYS5hPXdpbmRvdy5TaGFkeUNTUy5DdXN0b21TdHlsZUludGVyZmFjZSxhLmEmJihhLmEudHJhbnNmb3JtQ2FsbGJhY2s9ZnVuY3Rpb24oYSl7VC5mKGEpfSxhLmEudmFsaWRhdGVDYWxsYmFjaz1mdW5jdGlvbigpe3JlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbigpe2EuYS5lbnF1ZXVlZCYmVyhhKX0pfSkpfVUucHJvdG90eXBlLnByZXBhcmVUZW1wbGF0ZT1mdW5jdGlvbihhLGIpe1YodGhpcyk7a1tiXT1hO2I9VC5tKGEsYik7YS5fc3R5bGVBc3Q9Yn07XG5mdW5jdGlvbiBXKGEpe1YoYSk7aWYoYS5hKXt2YXIgYj1hLmEucHJvY2Vzc1N0eWxlcygpO2lmKGEuYS5lbnF1ZXVlZCl7Zm9yKHZhciBjPTA7YzxiLmxlbmd0aDtjKyspe3ZhciBkPWEuYS5nZXRTdHlsZUZvckN1c3RvbVN0eWxlKGJbY10pO2QmJlQuZihkKX1hLmEuZW5xdWV1ZWQ9ITF9fX1VLnByb3RvdHlwZS5zdHlsZVN1YnRyZWU9ZnVuY3Rpb24oYSxiKXtWKHRoaXMpO2lmKGIpZm9yKHZhciBjIGluIGIpbnVsbD09PWM/YS5zdHlsZS5yZW1vdmVQcm9wZXJ0eShjKTphLnN0eWxlLnNldFByb3BlcnR5KGMsYltjXSk7aWYoYS5zaGFkb3dSb290KWZvcih0aGlzLnN0eWxlRWxlbWVudChhKSxhPWEuc2hhZG93Um9vdC5jaGlsZHJlbnx8YS5zaGFkb3dSb290LmNoaWxkTm9kZXMsYj0wO2I8YS5sZW5ndGg7YisrKXRoaXMuc3R5bGVTdWJ0cmVlKGFbYl0pO2Vsc2UgZm9yKGE9YS5jaGlsZHJlbnx8YS5jaGlsZE5vZGVzLGI9MDtiPGEubGVuZ3RoO2IrKyl0aGlzLnN0eWxlU3VidHJlZShhW2JdKX07XG5VLnByb3RvdHlwZS5zdHlsZUVsZW1lbnQ9ZnVuY3Rpb24oYSl7Vih0aGlzKTt2YXIgYj1hLmxvY2FsTmFtZSxjO2I/LTE8Yi5pbmRleE9mKFwiLVwiKT9jPWI6Yz1hLmdldEF0dHJpYnV0ZSYmYS5nZXRBdHRyaWJ1dGUoXCJpc1wiKXx8XCJcIjpjPWEuaXM7aWYoKGI9a1tjXSkmJiF6KGIpKXtpZih6KGIpfHxiLl9hcHBseVNoaW1WYWxpZGF0aW5nVmVyc2lvbiE9PWIuX2FwcGx5U2hpbU5leHRWZXJzaW9uKXRoaXMucHJlcGFyZVRlbXBsYXRlKGIsYyksbGEoYik7aWYoYT1hLnNoYWRvd1Jvb3QpaWYoYT1hLnF1ZXJ5U2VsZWN0b3IoXCJzdHlsZVwiKSlhLl9fY3NzUnVsZXM9Yi5fc3R5bGVBc3QsYS50ZXh0Q29udGVudD1IKGIuX3N0eWxlQXN0KX19O1UucHJvdG90eXBlLnN0eWxlRG9jdW1lbnQ9ZnVuY3Rpb24oYSl7Vih0aGlzKTt0aGlzLnN0eWxlU3VidHJlZShkb2N1bWVudC5ib2R5LGEpfTtcbmlmKCF3aW5kb3cuU2hhZHlDU1N8fCF3aW5kb3cuU2hhZHlDU1MuU2NvcGluZ1NoaW0pe3ZhciBaPW5ldyBVLHRhPXdpbmRvdy5TaGFkeUNTUyYmd2luZG93LlNoYWR5Q1NTLkN1c3RvbVN0eWxlSW50ZXJmYWNlO3dpbmRvdy5TaGFkeUNTUz17cHJlcGFyZVRlbXBsYXRlOmZ1bmN0aW9uKGEsYil7VyhaKTtaLnByZXBhcmVUZW1wbGF0ZShhLGIpfSxzdHlsZVN1YnRyZWU6ZnVuY3Rpb24oYSxiKXtXKFopO1ouc3R5bGVTdWJ0cmVlKGEsYil9LHN0eWxlRWxlbWVudDpmdW5jdGlvbihhKXtXKFopO1ouc3R5bGVFbGVtZW50KGEpfSxzdHlsZURvY3VtZW50OmZ1bmN0aW9uKGEpe1coWik7Wi5zdHlsZURvY3VtZW50KGEpfSxnZXRDb21wdXRlZFN0eWxlVmFsdWU6ZnVuY3Rpb24oYSxiKXtyZXR1cm4oYT13aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShhKS5nZXRQcm9wZXJ0eVZhbHVlKGIpKT9hLnRyaW0oKTpcIlwifSxuYXRpdmVDc3M6RSxuYXRpdmVTaGFkb3c6QX07dGEmJih3aW5kb3cuU2hhZHlDU1MuQ3VzdG9tU3R5bGVJbnRlcmZhY2U9XG50YSl9d2luZG93LlNoYWR5Q1NTLkFwcGx5U2hpbT1UO30pLmNhbGwodGhpcyk7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFwcGx5LXNoaW0ubWluLmpzLm1hcFxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9zaGFkeWNzcy9hcHBseS1zaGltLm1pbi5qcyIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCJib290Lmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCJhc3luYy5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiZGVib3VuY2UuaHRtbFwiPlxuXG48c2NyaXB0PlxuKGZ1bmN0aW9uKCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICAvLyBkZXRlY3QgbmF0aXZlIHRvdWNoIGFjdGlvbiBzdXBwb3J0XG4gIGxldCBIQVNfTkFUSVZFX1RBID0gdHlwZW9mIGRvY3VtZW50LmhlYWQuc3R5bGUudG91Y2hBY3Rpb24gPT09ICdzdHJpbmcnO1xuICBsZXQgR0VTVFVSRV9LRVkgPSAnX19wb2x5bWVyR2VzdHVyZXMnO1xuICBsZXQgSEFORExFRF9PQkogPSAnX19wb2x5bWVyR2VzdHVyZXNIYW5kbGVkJztcbiAgbGV0IFRPVUNIX0FDVElPTiA9ICdfX3BvbHltZXJHZXN0dXJlc1RvdWNoQWN0aW9uJztcbiAgLy8gcmFkaXVzIGZvciB0YXAgYW5kIHRyYWNrXG4gIGxldCBUQVBfRElTVEFOQ0UgPSAyNTtcbiAgbGV0IFRSQUNLX0RJU1RBTkNFID0gNTtcbiAgLy8gbnVtYmVyIG9mIGxhc3QgTiB0cmFjayBwb3NpdGlvbnMgdG8ga2VlcFxuICBsZXQgVFJBQ0tfTEVOR1RIID0gMjtcblxuICAvLyBEaXNhYmxpbmcgXCJtb3VzZVwiIGhhbmRsZXJzIGZvciAyNTAwbXMgaXMgZW5vdWdoXG4gIGxldCBNT1VTRV9USU1FT1VUID0gMjUwMDtcbiAgbGV0IE1PVVNFX0VWRU5UUyA9IFsnbW91c2Vkb3duJywgJ21vdXNlbW92ZScsICdtb3VzZXVwJywgJ2NsaWNrJ107XG4gIC8vIGFuIGFycmF5IG9mIGJpdG1hc2sgdmFsdWVzIGZvciBtYXBwaW5nIE1vdXNlRXZlbnQud2hpY2ggdG8gTW91c2VFdmVudC5idXR0b25zXG4gIGxldCBNT1VTRV9XSElDSF9UT19CVVRUT05TID0gWzAsIDEsIDQsIDJdO1xuICBsZXQgTU9VU0VfSEFTX0JVVFRPTlMgPSAoZnVuY3Rpb24oKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBuZXcgTW91c2VFdmVudCgndGVzdCcsIHtidXR0b25zOiAxfSkuYnV0dG9ucyA9PT0gMTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9KSgpO1xuXG4gIC8qIGVzbGludCBuby1lbXB0eTogW1wiZXJyb3JcIiwgeyBcImFsbG93RW1wdHlDYXRjaFwiOiB0cnVlIH1dICovXG4gIC8vIGNoZWNrIGZvciBwYXNzaXZlIGV2ZW50IGxpc3RlbmVyc1xuICBsZXQgU1VQUE9SVFNfUEFTU0lWRSA9IGZhbHNlO1xuICAoZnVuY3Rpb24oKSB7XG4gICAgdHJ5IHtcbiAgICAgIGxldCBvcHRzID0gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAncGFzc2l2ZScsIHtnZXQ6IGZ1bmN0aW9uKCkge1NVUFBPUlRTX1BBU1NJVkUgPSB0cnVlO319KVxuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Rlc3QnLCBudWxsLCBvcHRzKTtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCd0ZXN0JywgbnVsbCwgb3B0cyk7XG4gICAgfSBjYXRjaChlKSB7fVxuICB9KSgpO1xuXG4gIC8vIENoZWNrIGZvciB0b3VjaC1vbmx5IGRldmljZXNcbiAgbGV0IElTX1RPVUNIX09OTFkgPSBuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9pUCg/OltvYV1kfGhvbmUpfEFuZHJvaWQvKTtcblxuICBsZXQgR2VzdHVyZVJlY29nbml6ZXIgPSBmdW5jdGlvbigpe307IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgR2VzdHVyZVJlY29nbml6ZXIucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oKXt9O1xuICAvKiogQHR5cGUge2Z1bmN0aW9uKE1vdXNlRXZlbnQpIHwgdW5kZWZpbmVkfSAqL1xuICBHZXN0dXJlUmVjb2duaXplci5wcm90b3R5cGUubW91c2Vkb3duO1xuICAvKiogQHR5cGUgeyhmdW5jdGlvbihNb3VzZUV2ZW50KSB8IHVuZGVmaW5lZCl9ICovXG4gIEdlc3R1cmVSZWNvZ25pemVyLnByb3RvdHlwZS5tb3VzZW1vdmU7XG4gIC8qKiBAdHlwZSB7KGZ1bmN0aW9uKE1vdXNlRXZlbnQpIHwgdW5kZWZpbmVkKX0gKi9cbiAgR2VzdHVyZVJlY29nbml6ZXIucHJvdG90eXBlLm1vdXNldXA7XG4gIC8qKiBAdHlwZSB7KGZ1bmN0aW9uKFRvdWNoRXZlbnQpIHwgdW5kZWZpbmVkKX0gKi9cbiAgR2VzdHVyZVJlY29nbml6ZXIucHJvdG90eXBlLnRvdWNoc3RhcnQ7XG4gIC8qKiBAdHlwZSB7KGZ1bmN0aW9uKFRvdWNoRXZlbnQpIHwgdW5kZWZpbmVkKX0gKi9cbiAgR2VzdHVyZVJlY29nbml6ZXIucHJvdG90eXBlLnRvdWNobW92ZTtcbiAgLyoqIEB0eXBlIHsoZnVuY3Rpb24oVG91Y2hFdmVudCkgfCB1bmRlZmluZWQpfSAqL1xuICBHZXN0dXJlUmVjb2duaXplci5wcm90b3R5cGUudG91Y2hlbmQ7XG4gIC8qKiBAdHlwZSB7KGZ1bmN0aW9uKE1vdXNlRXZlbnQpIHwgdW5kZWZpbmVkKX0gKi9cbiAgR2VzdHVyZVJlY29nbml6ZXIucHJvdG90eXBlLmNsaWNrO1xuXG4gIC8vIHRvdWNoIHdpbGwgbWFrZSBzeW50aGV0aWMgbW91c2UgZXZlbnRzXG4gIC8vIGBwcmV2ZW50RGVmYXVsdGAgb24gdG91Y2hlbmQgd2lsbCBjYW5jZWwgdGhlbSxcbiAgLy8gYnV0IHRoaXMgYnJlYWtzIGA8aW5wdXQ+YCBmb2N1cyBhbmQgbGluayBjbGlja3NcbiAgLy8gZGlzYWJsZSBtb3VzZSBoYW5kbGVycyBmb3IgTU9VU0VfVElNRU9VVCBtcyBhZnRlclxuICAvLyBhIHRvdWNoZW5kIHRvIGlnbm9yZSBzeW50aGV0aWMgbW91c2UgZXZlbnRzXG4gIGxldCBtb3VzZUNhbmNlbGxlciA9IGZ1bmN0aW9uKG1vdXNlRXZlbnQpIHtcbiAgICAvLyBDaGVjayBmb3Igc291cmNlQ2FwYWJpbGl0aWVzLCB1c2VkIHRvIGRpc3Rpbmd1aXNoIHN5bnRoZXRpYyBldmVudHNcbiAgICAvLyBpZiBtb3VzZUV2ZW50IGRpZCBub3QgY29tZSBmcm9tIGEgZGV2aWNlIHRoYXQgZmlyZXMgdG91Y2ggZXZlbnRzLFxuICAgIC8vIGl0IHdhcyBtYWRlIGJ5IGEgcmVhbCBtb3VzZSBhbmQgc2hvdWxkIGJlIGNvdW50ZWRcbiAgICAvLyBodHRwOi8vd2ljZy5naXRodWIuaW8vSW5wdXREZXZpY2VDYXBhYmlsaXRpZXMvI2RvbS1pbnB1dGRldmljZWNhcGFiaWxpdGllcy1maXJlc3RvdWNoZXZlbnRzXG4gICAgbGV0IHNjID0gbW91c2VFdmVudC5zb3VyY2VDYXBhYmlsaXRpZXM7XG4gICAgaWYgKHNjICYmICFzYy5maXJlc1RvdWNoRXZlbnRzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIHNraXAgc3ludGhldGljIG1vdXNlIGV2ZW50c1xuICAgIG1vdXNlRXZlbnRbSEFORExFRF9PQkpdID0ge3NraXA6IHRydWV9O1xuICAgIC8vIGRpc2FibGUgXCJnaG9zdCBjbGlja3NcIlxuICAgIGlmIChtb3VzZUV2ZW50LnR5cGUgPT09ICdjbGljaycpIHtcbiAgICAgIGxldCBwYXRoID0gbW91c2VFdmVudC5jb21wb3NlZFBhdGggJiYgbW91c2VFdmVudC5jb21wb3NlZFBhdGgoKTtcbiAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChwYXRoW2ldID09PSBQT0lOVEVSU1RBVEUubW91c2UudGFyZ2V0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBtb3VzZUV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBtb3VzZUV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtib29sZWFuPX0gc2V0dXAgVHJ1ZSB0byBhZGQsIGZhbHNlIHRvIHJlbW92ZS5cbiAgICovXG4gIGZ1bmN0aW9uIHNldHVwVGVhcmRvd25Nb3VzZUNhbmNlbGxlcihzZXR1cCkge1xuICAgIGxldCBldmVudHMgPSBJU19UT1VDSF9PTkxZID8gWydjbGljayddIDogTU9VU0VfRVZFTlRTO1xuICAgIGZvciAobGV0IGkgPSAwLCBlbjsgaSA8IGV2ZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgZW4gPSBldmVudHNbaV07XG4gICAgICBpZiAoc2V0dXApIHtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihlbiwgbW91c2VDYW5jZWxsZXIsIHRydWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihlbiwgbW91c2VDYW5jZWxsZXIsIHRydWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlnbm9yZU1vdXNlKGUpIHtcbiAgICBpZiAoIVBPSU5URVJTVEFURS5tb3VzZS5tb3VzZUlnbm9yZUpvYikge1xuICAgICAgc2V0dXBUZWFyZG93bk1vdXNlQ2FuY2VsbGVyKHRydWUpO1xuICAgIH1cbiAgICBsZXQgdW5zZXQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHNldHVwVGVhcmRvd25Nb3VzZUNhbmNlbGxlcigpO1xuICAgICAgUE9JTlRFUlNUQVRFLm1vdXNlLnRhcmdldCA9IG51bGw7XG4gICAgICBQT0lOVEVSU1RBVEUubW91c2UubW91c2VJZ25vcmVKb2IgPSBudWxsO1xuICAgIH07XG4gICAgUE9JTlRFUlNUQVRFLm1vdXNlLnRhcmdldCA9IGUuY29tcG9zZWRQYXRoKClbMF07XG4gICAgUE9JTlRFUlNUQVRFLm1vdXNlLm1vdXNlSWdub3JlSm9iID0gUG9seW1lci5EZWJvdW5jZXIuZGVib3VuY2UoXG4gICAgICAgICAgUE9JTlRFUlNUQVRFLm1vdXNlLm1vdXNlSWdub3JlSm9iXG4gICAgICAgICwgUG9seW1lci5Bc3luYy50aW1lT3V0LmFmdGVyKE1PVVNFX1RJTUVPVVQpXG4gICAgICAgICwgdW5zZXQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZXYgZXZlbnQgdG8gdGVzdCBmb3IgbGVmdCBtb3VzZSBidXR0b24gZG93blxuICAgKiBAcmV0dXJuIHtib29sZWFufSBoYXMgbGVmdCBtb3VzZSBidXR0b24gZG93blxuICAgKi9cbiAgZnVuY3Rpb24gaGFzTGVmdE1vdXNlQnV0dG9uKGV2KSB7XG4gICAgbGV0IHR5cGUgPSBldi50eXBlO1xuICAgIC8vIGV4aXQgZWFybHkgaWYgdGhlIGV2ZW50IGlzIG5vdCBhIG1vdXNlIGV2ZW50XG4gICAgaWYgKE1PVVNFX0VWRU5UUy5pbmRleE9mKHR5cGUpID09PSAtMSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBldi5idXR0b24gaXMgbm90IHJlbGlhYmxlIGZvciBtb3VzZW1vdmUgKDAgaXMgb3ZlcmxvYWRlZCBhcyBib3RoIGxlZnQgYnV0dG9uIGFuZCBubyBidXR0b25zKVxuICAgIC8vIGluc3RlYWQgd2UgdXNlIGV2LmJ1dHRvbnMgKGJpdG1hc2sgb2YgYnV0dG9ucykgb3IgZmFsbCBiYWNrIHRvIGV2LndoaWNoIChkZXByZWNhdGVkLCAwIGZvciBubyBidXR0b25zLCAxIGZvciBsZWZ0IGJ1dHRvbilcbiAgICBpZiAodHlwZSA9PT0gJ21vdXNlbW92ZScpIHtcbiAgICAgIC8vIGFsbG93IHVuZGVmaW5lZCBmb3IgdGVzdGluZyBldmVudHNcbiAgICAgIGxldCBidXR0b25zID0gZXYuYnV0dG9ucyA9PT0gdW5kZWZpbmVkID8gMSA6IGV2LmJ1dHRvbnM7XG4gICAgICBpZiAoKGV2IGluc3RhbmNlb2Ygd2luZG93Lk1vdXNlRXZlbnQpICYmICFNT1VTRV9IQVNfQlVUVE9OUykge1xuICAgICAgICBidXR0b25zID0gTU9VU0VfV0hJQ0hfVE9fQlVUVE9OU1tldi53aGljaF0gfHwgMDtcbiAgICAgIH1cbiAgICAgIC8vIGJ1dHRvbnMgaXMgYSBiaXRtYXNrLCBjaGVjayB0aGF0IHRoZSBsZWZ0IGJ1dHRvbiBiaXQgaXMgc2V0ICgxKVxuICAgICAgcmV0dXJuIEJvb2xlYW4oYnV0dG9ucyAmIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBhbGxvdyB1bmRlZmluZWQgZm9yIHRlc3RpbmcgZXZlbnRzXG4gICAgICBsZXQgYnV0dG9uID0gZXYuYnV0dG9uID09PSB1bmRlZmluZWQgPyAwIDogZXYuYnV0dG9uO1xuICAgICAgLy8gZXYuYnV0dG9uIGlzIDAgaW4gbW91c2Vkb3duL21vdXNldXAvY2xpY2sgZm9yIGxlZnQgYnV0dG9uIGFjdGl2YXRpb25cbiAgICAgIHJldHVybiBidXR0b24gPT09IDA7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNTeW50aGV0aWNDbGljayhldikge1xuICAgIGlmIChldi50eXBlID09PSAnY2xpY2snKSB7XG4gICAgICAvLyBldi5kZXRhaWwgaXMgMCBmb3IgSFRNTEVsZW1lbnQuY2xpY2sgaW4gbW9zdCBicm93c2Vyc1xuICAgICAgaWYgKGV2LmRldGFpbCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIC8vIGluIHRoZSB3b3JzdCBjYXNlLCBjaGVjayB0aGF0IHRoZSB4L3kgcG9zaXRpb24gb2YgdGhlIGNsaWNrIGlzIHdpdGhpblxuICAgICAgLy8gdGhlIGJvdW5kaW5nIGJveCBvZiB0aGUgdGFyZ2V0IG9mIHRoZSBldmVudFxuICAgICAgLy8gVGhhbmtzIElFIDEwID46KFxuICAgICAgbGV0IHQgPSBHZXN0dXJlcy5fZmluZE9yaWdpbmFsVGFyZ2V0KGV2KTtcbiAgICAgIC8vIG1ha2Ugc3VyZSB0aGUgdGFyZ2V0IG9mIHRoZSBldmVudCBpcyBhbiBlbGVtZW50IHNvIHdlIGNhbiB1c2UgZ2V0Qm91bmRpbmdDbGllbnRSZWN0LFxuICAgICAgLy8gaWYgbm90LCBqdXN0IGFzc3VtZSBpdCBpcyBhIHN5bnRoZXRpYyBjbGlja1xuICAgICAgaWYgKCF0Lm5vZGVUeXBlIHx8IC8qKiBAdHlwZSB7RWxlbWVudH0gKi8odCkubm9kZVR5cGUgIT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgbGV0IGJjciA9IC8qKiBAdHlwZSB7RWxlbWVudH0gKi8odCkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAvLyB1c2UgcGFnZSB4L3kgdG8gYWNjb3VudCBmb3Igc2Nyb2xsaW5nXG4gICAgICBsZXQgeCA9IGV2LnBhZ2VYLCB5ID0gZXYucGFnZVk7XG4gICAgICAvLyBldiBpcyBhIHN5bnRoZXRpYyBjbGljayBpZiB0aGUgcG9zaXRpb24gaXMgb3V0c2lkZSB0aGUgYm91bmRpbmcgYm94IG9mIHRoZSB0YXJnZXRcbiAgICAgIHJldHVybiAhKCh4ID49IGJjci5sZWZ0ICYmIHggPD0gYmNyLnJpZ2h0KSAmJiAoeSA+PSBiY3IudG9wICYmIHkgPD0gYmNyLmJvdHRvbSkpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBsZXQgUE9JTlRFUlNUQVRFID0ge1xuICAgIG1vdXNlOiB7XG4gICAgICB0YXJnZXQ6IG51bGwsXG4gICAgICBtb3VzZUlnbm9yZUpvYjogbnVsbFxuICAgIH0sXG4gICAgdG91Y2g6IHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwLFxuICAgICAgaWQ6IC0xLFxuICAgICAgc2Nyb2xsRGVjaWRlZDogZmFsc2VcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gZmlyc3RUb3VjaEFjdGlvbihldikge1xuICAgIGxldCB0YSA9ICdhdXRvJztcbiAgICBsZXQgcGF0aCA9IGV2LmNvbXBvc2VkUGF0aCAmJiBldi5jb21wb3NlZFBhdGgoKTtcbiAgICBpZiAocGF0aCkge1xuICAgICAgZm9yIChsZXQgaSA9IDAsIG47IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG4gPSBwYXRoW2ldO1xuICAgICAgICBpZiAobltUT1VDSF9BQ1RJT05dKSB7XG4gICAgICAgICAgdGEgPSBuW1RPVUNIX0FDVElPTl07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRhO1xuICB9XG5cbiAgZnVuY3Rpb24gdHJhY2tEb2N1bWVudChzdGF0ZU9iaiwgbW92ZWZuLCB1cGZuKSB7XG4gICAgc3RhdGVPYmoubW92ZWZuID0gbW92ZWZuO1xuICAgIHN0YXRlT2JqLnVwZm4gPSB1cGZuO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG1vdmVmbik7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHVwZm4pO1xuICB9XG5cbiAgZnVuY3Rpb24gdW50cmFja0RvY3VtZW50KHN0YXRlT2JqKSB7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgc3RhdGVPYmoubW92ZWZuKTtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgc3RhdGVPYmoudXBmbik7XG4gICAgc3RhdGVPYmoubW92ZWZuID0gbnVsbDtcbiAgICBzdGF0ZU9iai51cGZuID0gbnVsbDtcbiAgfVxuXG4gIC8vIHVzZSBhIGRvY3VtZW50LXdpZGUgdG91Y2hlbmQgbGlzdGVuZXIgdG8gc3RhcnQgdGhlIGdob3N0LWNsaWNrIHByZXZlbnRpb24gbWVjaGFuaXNtXG4gIC8vIFVzZSBwYXNzaXZlIGV2ZW50IGxpc3RlbmVycywgaWYgc3VwcG9ydGVkLCB0byBub3QgYWZmZWN0IHNjcm9sbGluZyBwZXJmb3JtYW5jZVxuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIGlnbm9yZU1vdXNlLCBTVVBQT1JUU19QQVNTSVZFID8ge3Bhc3NpdmU6IHRydWV9IDogZmFsc2UpO1xuXG4gIC8qKlxuICAgKiBNb2R1bGUgZm9yIGFkZGluZyBsaXN0ZW5lcnMgdG8gYSBub2RlIGZvciB0aGUgZm9sbG93aW5nIG5vcm1hbGl6ZWRcbiAgICogY3Jvc3MtcGxhdGZvcm0gXCJnZXN0dXJlXCIgZXZlbnRzOlxuICAgKiAtIGBkb3duYCAtIG1vdXNlIG9yIHRvdWNoIHdlbnQgZG93blxuICAgKiAtIGB1cGAgLSBtb3VzZSBvciB0b3VjaCB3ZW50IHVwXG4gICAqIC0gYHRhcGAgLSBtb3VzZSBjbGljayBvciBmaW5nZXIgdGFwXG4gICAqIC0gYHRyYWNrYCAtIG1vdXNlIGRyYWcgb3IgdG91Y2ggbW92ZVxuICAgKlxuICAgKiBAbmFtZXNwYWNlXG4gICAqIEBtZW1iZXJvZiBQb2x5bWVyXG4gICAqIEBzdW1tYXJ5IE1vZHVsZSBmb3IgYWRkaW5nIGNyb3NzLXBsYXRmb3JtIGdlc3R1cmUgZXZlbnQgbGlzdGVuZXJzLlxuICAgKi9cbiAgY29uc3QgR2VzdHVyZXMgPSB7XG4gICAgZ2VzdHVyZXM6IHt9LFxuICAgIHJlY29nbml6ZXJzOiBbXSxcblxuICAgIC8qKlxuICAgICAqIEZpbmRzIHRoZSBlbGVtZW50IHJlbmRlcmVkIG9uIHRoZSBzY3JlZW4gYXQgdGhlIHByb3ZpZGVkIGNvb3JkaW5hdGVzLlxuICAgICAqXG4gICAgICogU2ltaWxhciB0byBgZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludGAsIGJ1dCBwaWVyY2VzIHRocm91Z2hcbiAgICAgKiBzaGFkb3cgcm9vdHMuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgUG9seW1lci5HZXN0dXJlc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IEhvcml6b250YWwgcGl4ZWwgY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IFZlcnRpY2FsIHBpeGVsIGNvb3JkaW5hdGVcbiAgICAgKiBAcmV0dXJuIHtFbGVtZW50fSBSZXR1cm5zIHRoZSBkZWVwZXN0IHNoYWRvd1Jvb3QgaW5jbHVzaXZlIGVsZW1lbnRcbiAgICAgKiBmb3VuZCBhdCB0aGUgc2NyZWVuIHBvc2l0aW9uIGdpdmVuLlxuICAgICAqL1xuICAgIGRlZXBUYXJnZXRGaW5kOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICBsZXQgbm9kZSA9IGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQoeCwgeSk7XG4gICAgICBsZXQgbmV4dCA9IG5vZGU7XG4gICAgICAvLyB0aGlzIGNvZGUgcGF0aCBpcyBvbmx5IHRha2VuIHdoZW4gbmF0aXZlIFNoYWRvd0RPTSBpcyB1c2VkXG4gICAgICAvLyBpZiB0aGVyZSBpcyBhIHNoYWRvd3Jvb3QsIGl0IG1heSBoYXZlIGEgbm9kZSBhdCB4L3lcbiAgICAgIC8vIGlmIHRoZXJlIGlzIG5vdCBhIHNoYWRvd3Jvb3QsIGV4aXQgdGhlIGxvb3BcbiAgICAgIHdoaWxlIChuZXh0ICYmIG5leHQuc2hhZG93Um9vdCAmJiAhd2luZG93LlNoYWR5RE9NKSB7XG4gICAgICAgIC8vIGlmIHRoZXJlIGlzIGEgbm9kZSBhdCB4L3kgaW4gdGhlIHNoYWRvd3Jvb3QsIGxvb2sgZGVlcGVyXG4gICAgICAgIGxldCBvbGROZXh0ID0gbmV4dDtcbiAgICAgICAgbmV4dCA9IG5leHQuc2hhZG93Um9vdC5lbGVtZW50RnJvbVBvaW50KHgsIHkpO1xuICAgICAgICAvLyBvbiBTYWZhcmksIGVsZW1lbnRGcm9tUG9pbnQgbWF5IHJldHVybiB0aGUgc2hhZG93Um9vdCBob3N0XG4gICAgICAgIGlmIChvbGROZXh0ID09PSBuZXh0KSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5leHQpIHtcbiAgICAgICAgICBub2RlID0gbmV4dDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBhIGNoZWFwZXIgY2hlY2sgdGhhbiBldi5jb21wb3NlZFBhdGgoKVswXTtcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gZXYgRXZlbnQuXG4gICAgICogQHJldHVybiB7RXZlbnRUYXJnZXR9IFJldHVybnMgdGhlIGV2ZW50IHRhcmdldC5cbiAgICAgKi9cbiAgICBfZmluZE9yaWdpbmFsVGFyZ2V0OiBmdW5jdGlvbihldikge1xuICAgICAgLy8gc2hhZG93ZG9tXG4gICAgICBpZiAoZXYuY29tcG9zZWRQYXRoKSB7XG4gICAgICAgIHJldHVybiAvKiogQHR5cGUge0V2ZW50VGFyZ2V0fSAqLyhldi5jb21wb3NlZFBhdGgoKVswXSk7XG4gICAgICB9XG4gICAgICAvLyBzaGFkeWRvbVxuICAgICAgcmV0dXJuIGV2LnRhcmdldDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBldiBFdmVudC5cbiAgICAgKi9cbiAgICBfaGFuZGxlTmF0aXZlOiBmdW5jdGlvbihldikge1xuICAgICAgbGV0IGhhbmRsZWQ7XG4gICAgICBsZXQgdHlwZSA9IGV2LnR5cGU7XG4gICAgICBsZXQgbm9kZSA9IGV2LmN1cnJlbnRUYXJnZXQ7XG4gICAgICBsZXQgZ29iaiA9IG5vZGVbR0VTVFVSRV9LRVldO1xuICAgICAgaWYgKCFnb2JqKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxldCBncyA9IGdvYmpbdHlwZV07XG4gICAgICBpZiAoIWdzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghZXZbSEFORExFRF9PQkpdKSB7XG4gICAgICAgIGV2W0hBTkRMRURfT0JKXSA9IHt9O1xuICAgICAgICBpZiAodHlwZS5zbGljZSgwLCA1KSA9PT0gJ3RvdWNoJykge1xuICAgICAgICAgIGV2ID0gLyoqIEB0eXBlIHtUb3VjaEV2ZW50fSAqLyhldik7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1hc3NpZ25cbiAgICAgICAgICBsZXQgdCA9IGV2LmNoYW5nZWRUb3VjaGVzWzBdO1xuICAgICAgICAgIGlmICh0eXBlID09PSAndG91Y2hzdGFydCcpIHtcbiAgICAgICAgICAgIC8vIG9ubHkgaGFuZGxlIHRoZSBmaXJzdCBmaW5nZXJcbiAgICAgICAgICAgIGlmIChldi50b3VjaGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICBQT0lOVEVSU1RBVEUudG91Y2guaWQgPSB0LmlkZW50aWZpZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChQT0lOVEVSU1RBVEUudG91Y2guaWQgIT09IHQuaWRlbnRpZmllcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIUhBU19OQVRJVkVfVEEpIHtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSAndG91Y2hzdGFydCcgfHwgdHlwZSA9PT0gJ3RvdWNobW92ZScpIHtcbiAgICAgICAgICAgICAgR2VzdHVyZXMuX2hhbmRsZVRvdWNoQWN0aW9uKGV2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGhhbmRsZWQgPSBldltIQU5ETEVEX09CSl07XG4gICAgICAvLyB1c2VkIHRvIGlnbm9yZSBzeW50aGV0aWMgbW91c2UgZXZlbnRzXG4gICAgICBpZiAoaGFuZGxlZC5za2lwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxldCByZWNvZ25pemVycyA9IEdlc3R1cmVzLnJlY29nbml6ZXJzO1xuICAgICAgLy8gcmVzZXQgcmVjb2duaXplciBzdGF0ZVxuICAgICAgZm9yIChsZXQgaSA9IDAsIHI7IGkgPCByZWNvZ25pemVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICByID0gcmVjb2duaXplcnNbaV07XG4gICAgICAgIGlmIChnc1tyLm5hbWVdICYmICFoYW5kbGVkW3IubmFtZV0pIHtcbiAgICAgICAgICBpZiAoci5mbG93ICYmIHIuZmxvdy5zdGFydC5pbmRleE9mKGV2LnR5cGUpID4gLTEgJiYgci5yZXNldCkge1xuICAgICAgICAgICAgci5yZXNldCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gZW5mb3JjZSBnZXN0dXJlIHJlY29nbml6ZXIgb3JkZXJcbiAgICAgIGZvciAobGV0IGkgPSAwLCByOyBpIDwgcmVjb2duaXplcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgciA9IHJlY29nbml6ZXJzW2ldO1xuICAgICAgICBpZiAoZ3Nbci5uYW1lXSAmJiAhaGFuZGxlZFtyLm5hbWVdKSB7XG4gICAgICAgICAgaGFuZGxlZFtyLm5hbWVdID0gdHJ1ZTtcbiAgICAgICAgICByW3R5cGVdKGV2KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7VG91Y2hFdmVudH0gZXYgRXZlbnQuXG4gICAgICovXG4gICAgX2hhbmRsZVRvdWNoQWN0aW9uOiBmdW5jdGlvbihldikge1xuICAgICAgbGV0IHQgPSBldi5jaGFuZ2VkVG91Y2hlc1swXTtcbiAgICAgIGxldCB0eXBlID0gZXYudHlwZTtcbiAgICAgIGlmICh0eXBlID09PSAndG91Y2hzdGFydCcpIHtcbiAgICAgICAgUE9JTlRFUlNUQVRFLnRvdWNoLnggPSB0LmNsaWVudFg7XG4gICAgICAgIFBPSU5URVJTVEFURS50b3VjaC55ID0gdC5jbGllbnRZO1xuICAgICAgICBQT0lOVEVSU1RBVEUudG91Y2guc2Nyb2xsRGVjaWRlZCA9IGZhbHNlO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAndG91Y2htb3ZlJykge1xuICAgICAgICBpZiAoUE9JTlRFUlNUQVRFLnRvdWNoLnNjcm9sbERlY2lkZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgUE9JTlRFUlNUQVRFLnRvdWNoLnNjcm9sbERlY2lkZWQgPSB0cnVlO1xuICAgICAgICBsZXQgdGEgPSBmaXJzdFRvdWNoQWN0aW9uKGV2KTtcbiAgICAgICAgbGV0IHByZXZlbnQgPSBmYWxzZTtcbiAgICAgICAgbGV0IGR4ID0gTWF0aC5hYnMoUE9JTlRFUlNUQVRFLnRvdWNoLnggLSB0LmNsaWVudFgpO1xuICAgICAgICBsZXQgZHkgPSBNYXRoLmFicyhQT0lOVEVSU1RBVEUudG91Y2gueSAtIHQuY2xpZW50WSk7XG4gICAgICAgIGlmICghZXYuY2FuY2VsYWJsZSkge1xuICAgICAgICAgIC8vIHNjcm9sbGluZyBpcyBoYXBwZW5pbmdcbiAgICAgICAgfSBlbHNlIGlmICh0YSA9PT0gJ25vbmUnKSB7XG4gICAgICAgICAgcHJldmVudCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAodGEgPT09ICdwYW4teCcpIHtcbiAgICAgICAgICBwcmV2ZW50ID0gZHkgPiBkeDtcbiAgICAgICAgfSBlbHNlIGlmICh0YSA9PT0gJ3Bhbi15Jykge1xuICAgICAgICAgIHByZXZlbnQgPSBkeCA+IGR5O1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcmV2ZW50KSB7XG4gICAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBHZXN0dXJlcy5wcmV2ZW50KCd0cmFjaycpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZHMgYW4gZXZlbnQgbGlzdGVuZXIgdG8gYSBub2RlIGZvciB0aGUgZ2l2ZW4gZ2VzdHVyZSB0eXBlLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIFBvbHltZXIuR2VzdHVyZXNcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgTm9kZSB0byBhZGQgbGlzdGVuZXIgb25cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZUeXBlIEdlc3R1cmUgdHlwZTogYGRvd25gLCBgdXBgLCBgdHJhY2tgLCBvciBgdGFwYFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIgRXZlbnQgbGlzdGVuZXIgZnVuY3Rpb24gdG8gY2FsbFxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiBhIGdlc3R1cmUgZXZlbnQgbGlzdGVuZXIgd2FzIGFkZGVkLlxuICAgICAqIEB0aGlzIHtHZXN0dXJlc31cbiAgICAgKi9cbiAgICBhZGRMaXN0ZW5lcjogZnVuY3Rpb24obm9kZSwgZXZUeXBlLCBoYW5kbGVyKSB7XG4gICAgICBpZiAodGhpcy5nZXN0dXJlc1tldlR5cGVdKSB7XG4gICAgICAgIHRoaXMuX2FkZChub2RlLCBldlR5cGUsIGhhbmRsZXIpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbiBldmVudCBsaXN0ZW5lciBmcm9tIGEgbm9kZSBmb3IgdGhlIGdpdmVuIGdlc3R1cmUgdHlwZS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBQb2x5bWVyLkdlc3R1cmVzXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlIE5vZGUgdG8gcmVtb3ZlIGxpc3RlbmVyIGZyb21cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZUeXBlIEdlc3R1cmUgdHlwZTogYGRvd25gLCBgdXBgLCBgdHJhY2tgLCBvciBgdGFwYFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIgRXZlbnQgbGlzdGVuZXIgZnVuY3Rpb24gcHJldmlvdXNseSBwYXNzZWQgdG9cbiAgICAgKiAgYGFkZExpc3RlbmVyYC5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgYSBnZXN0dXJlIGV2ZW50IGxpc3RlbmVyIHdhcyByZW1vdmVkLlxuICAgICAqIEB0aGlzIHtHZXN0dXJlc31cbiAgICAgKi9cbiAgICByZW1vdmVMaXN0ZW5lcjogZnVuY3Rpb24obm9kZSwgZXZUeXBlLCBoYW5kbGVyKSB7XG4gICAgICBpZiAodGhpcy5nZXN0dXJlc1tldlR5cGVdKSB7XG4gICAgICAgIHRoaXMuX3JlbW92ZShub2RlLCBldlR5cGUsIGhhbmRsZXIpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogYXV0b21hdGUgdGhlIGV2ZW50IGxpc3RlbmVycyBmb3IgdGhlIG5hdGl2ZSBldmVudHNcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gbm9kZSBOb2RlIG9uIHdoaWNoIHRvIGFkZCB0aGUgZXZlbnQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2VHlwZSBFdmVudCB0eXBlIHRvIGFkZC5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKEV2ZW50Pyl9IGhhbmRsZXIgRXZlbnQgaGFuZGxlciBmdW5jdGlvbi5cbiAgICAgKiBAdGhpcyB7R2VzdHVyZXN9XG4gICAgICovXG4gICAgX2FkZDogZnVuY3Rpb24obm9kZSwgZXZUeXBlLCBoYW5kbGVyKSB7XG4gICAgICBsZXQgcmVjb2duaXplciA9IHRoaXMuZ2VzdHVyZXNbZXZUeXBlXTtcbiAgICAgIGxldCBkZXBzID0gcmVjb2duaXplci5kZXBzO1xuICAgICAgbGV0IG5hbWUgPSByZWNvZ25pemVyLm5hbWU7XG4gICAgICBsZXQgZ29iaiA9IG5vZGVbR0VTVFVSRV9LRVldO1xuICAgICAgaWYgKCFnb2JqKSB7XG4gICAgICAgIG5vZGVbR0VTVFVSRV9LRVldID0gZ29iaiA9IHt9O1xuICAgICAgfVxuICAgICAgZm9yIChsZXQgaSA9IDAsIGRlcCwgZ2Q7IGkgPCBkZXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGRlcCA9IGRlcHNbaV07XG4gICAgICAgIC8vIGRvbid0IGFkZCBtb3VzZSBoYW5kbGVycyBvbiBpT1MgYmVjYXVzZSB0aGV5IGNhdXNlIGdyYXkgc2VsZWN0aW9uIG92ZXJsYXlzXG4gICAgICAgIGlmIChJU19UT1VDSF9PTkxZICYmIE1PVVNFX0VWRU5UUy5pbmRleE9mKGRlcCkgPiAtMSAmJiBkZXAgIT09ICdjbGljaycpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBnZCA9IGdvYmpbZGVwXTtcbiAgICAgICAgaWYgKCFnZCkge1xuICAgICAgICAgIGdvYmpbZGVwXSA9IGdkID0ge19jb3VudDogMH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdkLl9jb3VudCA9PT0gMCkge1xuICAgICAgICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihkZXAsIHRoaXMuX2hhbmRsZU5hdGl2ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZ2RbbmFtZV0gPSAoZ2RbbmFtZV0gfHwgMCkgKyAxO1xuICAgICAgICBnZC5fY291bnQgPSAoZ2QuX2NvdW50IHx8IDApICsgMTtcbiAgICAgIH1cbiAgICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihldlR5cGUsIGhhbmRsZXIpO1xuICAgICAgaWYgKHJlY29nbml6ZXIudG91Y2hBY3Rpb24pIHtcbiAgICAgICAgdGhpcy5zZXRUb3VjaEFjdGlvbihub2RlLCByZWNvZ25pemVyLnRvdWNoQWN0aW9uKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogYXV0b21hdGUgZXZlbnQgbGlzdGVuZXIgcmVtb3ZhbCBmb3IgbmF0aXZlIGV2ZW50c1xuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBub2RlIE5vZGUgb24gd2hpY2ggdG8gcmVtb3ZlIHRoZSBldmVudC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZUeXBlIEV2ZW50IHR5cGUgdG8gcmVtb3ZlLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oRXZlbnQ/KX0gaGFuZGxlciBFdmVudCBoYW5kbGVyIGZ1bmN0aW9uLlxuICAgICAqIEB0aGlzIHtHZXN0dXJlc31cbiAgICAgKi9cbiAgICBfcmVtb3ZlOiBmdW5jdGlvbihub2RlLCBldlR5cGUsIGhhbmRsZXIpIHtcbiAgICAgIGxldCByZWNvZ25pemVyID0gdGhpcy5nZXN0dXJlc1tldlR5cGVdO1xuICAgICAgbGV0IGRlcHMgPSByZWNvZ25pemVyLmRlcHM7XG4gICAgICBsZXQgbmFtZSA9IHJlY29nbml6ZXIubmFtZTtcbiAgICAgIGxldCBnb2JqID0gbm9kZVtHRVNUVVJFX0tFWV07XG4gICAgICBpZiAoZ29iaikge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgZGVwLCBnZDsgaSA8IGRlcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBkZXAgPSBkZXBzW2ldO1xuICAgICAgICAgIGdkID0gZ29ialtkZXBdO1xuICAgICAgICAgIGlmIChnZCAmJiBnZFtuYW1lXSkge1xuICAgICAgICAgICAgZ2RbbmFtZV0gPSAoZ2RbbmFtZV0gfHwgMSkgLSAxO1xuICAgICAgICAgICAgZ2QuX2NvdW50ID0gKGdkLl9jb3VudCB8fCAxKSAtIDE7XG4gICAgICAgICAgICBpZiAoZ2QuX2NvdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihkZXAsIHRoaXMuX2hhbmRsZU5hdGl2ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZUeXBlLCBoYW5kbGVyKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIGEgbmV3IGdlc3R1cmUgZXZlbnQgcmVjb2duaXplciBmb3IgYWRkaW5nIG5ldyBjdXN0b21cbiAgICAgKiBnZXN0dXJlIGV2ZW50IHR5cGVzLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIFBvbHltZXIuR2VzdHVyZXNcbiAgICAgKiBAcGFyYW0ge0dlc3R1cmVSZWNvZ25pemVyfSByZWNvZyBHZXN0dXJlIHJlY29nbml6ZXIgZGVzY3JpcHRvclxuICAgICAqIEB0aGlzIHtHZXN0dXJlc31cbiAgICAgKi9cbiAgICByZWdpc3RlcjogZnVuY3Rpb24ocmVjb2cpIHtcbiAgICAgIHRoaXMucmVjb2duaXplcnMucHVzaChyZWNvZyk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlY29nLmVtaXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuZ2VzdHVyZXNbcmVjb2cuZW1pdHNbaV1dID0gcmVjb2c7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2TmFtZSBFdmVudCBuYW1lLlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gUmV0dXJucyB0aGUgZ2VzdHVyZSBmb3IgdGhlIGdpdmVuIGV2ZW50IG5hbWUuXG4gICAgICogQHRoaXMge0dlc3R1cmVzfVxuICAgICAqL1xuICAgIF9maW5kUmVjb2duaXplckJ5RXZlbnQ6IGZ1bmN0aW9uKGV2TmFtZSkge1xuICAgICAgZm9yIChsZXQgaSA9IDAsIHI7IGkgPCB0aGlzLnJlY29nbml6ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHIgPSB0aGlzLnJlY29nbml6ZXJzW2ldO1xuICAgICAgICBmb3IgKGxldCBqID0gMCwgbjsgaiA8IHIuZW1pdHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBuID0gci5lbWl0c1tqXTtcbiAgICAgICAgICBpZiAobiA9PT0gZXZOYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHNjcm9sbGluZyBkaXJlY3Rpb24gb24gbm9kZS5cbiAgICAgKlxuICAgICAqIFRoaXMgdmFsdWUgaXMgY2hlY2tlZCBvbiBmaXJzdCBtb3ZlLCB0aHVzIGl0IHNob3VsZCBiZSBjYWxsZWQgcHJpb3IgdG9cbiAgICAgKiBhZGRpbmcgZXZlbnQgbGlzdGVuZXJzLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIFBvbHltZXIuR2VzdHVyZXNcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgTm9kZSB0byBzZXQgdG91Y2ggYWN0aW9uIHNldHRpbmcgb25cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgVG91Y2ggYWN0aW9uIHZhbHVlXG4gICAgICovXG4gICAgc2V0VG91Y2hBY3Rpb246IGZ1bmN0aW9uKG5vZGUsIHZhbHVlKSB7XG4gICAgICBpZiAoSEFTX05BVElWRV9UQSkge1xuICAgICAgICBub2RlLnN0eWxlLnRvdWNoQWN0aW9uID0gdmFsdWU7XG4gICAgICB9XG4gICAgICBub2RlW1RPVUNIX0FDVElPTl0gPSB2YWx1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGlzcGF0Y2hlcyBhbiBldmVudCBvbiB0aGUgYHRhcmdldGAgZWxlbWVudCBvZiBgdHlwZWAgd2l0aCB0aGUgZ2l2ZW5cbiAgICAgKiBgZGV0YWlsYC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IHRhcmdldCBUaGUgZWxlbWVudCBvbiB3aGljaCB0byBmaXJlIGFuIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIFRoZSB0eXBlIG9mIGV2ZW50IHRvIGZpcmUuXG4gICAgICogQHBhcmFtIHtPYmplY3Q9fSBkZXRhaWwgVGhlIGRldGFpbCBvYmplY3QgdG8gcG9wdWxhdGUgb24gdGhlIGV2ZW50LlxuICAgICAqL1xuICAgIF9maXJlOiBmdW5jdGlvbih0YXJnZXQsIHR5cGUsIGRldGFpbCkge1xuICAgICAgbGV0IGV2ID0gbmV3IEV2ZW50KHR5cGUsIHsgYnViYmxlczogdHJ1ZSwgY2FuY2VsYWJsZTogdHJ1ZSwgY29tcG9zZWQ6IHRydWUgfSk7XG4gICAgICBldi5kZXRhaWwgPSBkZXRhaWw7XG4gICAgICB0YXJnZXQuZGlzcGF0Y2hFdmVudChldik7XG4gICAgICAvLyBmb3J3YXJkIGBwcmV2ZW50RGVmYXVsdGAgaW4gYSBjbGVhbiB3YXlcbiAgICAgIGlmIChldi5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgIGxldCBwcmV2ZW50ZXIgPSBkZXRhaWwucHJldmVudGVyIHx8IGRldGFpbC5zb3VyY2VFdmVudDtcbiAgICAgICAgaWYgKHByZXZlbnRlciAmJiBwcmV2ZW50ZXIucHJldmVudERlZmF1bHQpIHtcbiAgICAgICAgICBwcmV2ZW50ZXIucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQcmV2ZW50cyB0aGUgZGlzcGF0Y2ggYW5kIGRlZmF1bHQgYWN0aW9uIG9mIHRoZSBnaXZlbiBldmVudCBuYW1lLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIFBvbHltZXIuR2VzdHVyZXNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZOYW1lIEV2ZW50IG5hbWUuXG4gICAgICogQHRoaXMge0dlc3R1cmVzfVxuICAgICAqL1xuICAgIHByZXZlbnQ6IGZ1bmN0aW9uKGV2TmFtZSkge1xuICAgICAgbGV0IHJlY29nbml6ZXIgPSB0aGlzLl9maW5kUmVjb2duaXplckJ5RXZlbnQoZXZOYW1lKTtcbiAgICAgIGlmIChyZWNvZ25pemVyLmluZm8pIHtcbiAgICAgICAgcmVjb2duaXplci5pbmZvLnByZXZlbnQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXNldCB0aGUgMjUwMG1zIHRpbWVvdXQgb24gcHJvY2Vzc2luZyBtb3VzZSBpbnB1dCBhZnRlciBkZXRlY3RpbmcgdG91Y2ggaW5wdXQuXG4gICAgICpcbiAgICAgKiBUb3VjaCBpbnB1dHMgY3JlYXRlIHN5bnRoZXNpemVkIG1vdXNlIGlucHV0cyBhbnl3aGVyZSBmcm9tIDAgdG8gMjAwMG1zIGFmdGVyIHRoZSB0b3VjaC5cbiAgICAgKiBUaGlzIG1ldGhvZCBzaG91bGQgb25seSBiZSBjYWxsZWQgZHVyaW5nIHRlc3Rpbmcgd2l0aCBzaW11bGF0ZWQgdG91Y2ggaW5wdXRzLlxuICAgICAqIENhbGxpbmcgdGhpcyBtZXRob2QgaW4gcHJvZHVjdGlvbiBtYXkgY2F1c2UgZHVwbGljYXRlIHRhcHMgb3Igb3RoZXIgR2VzdHVyZXMuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgUG9seW1lci5HZXN0dXJlc1xuICAgICAqL1xuICAgIHJlc2V0TW91c2VDYW5jZWxsZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKFBPSU5URVJTVEFURS5tb3VzZS5tb3VzZUlnbm9yZUpvYikge1xuICAgICAgICBQT0lOVEVSU1RBVEUubW91c2UubW91c2VJZ25vcmVKb2IuZmx1c2goKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyogZXNsaW50LWRpc2FibGUgdmFsaWQtanNkb2MgKi9cblxuICBHZXN0dXJlcy5yZWdpc3Rlcih7XG4gICAgbmFtZTogJ2Rvd251cCcsXG4gICAgZGVwczogWydtb3VzZWRvd24nLCAndG91Y2hzdGFydCcsICd0b3VjaGVuZCddLFxuICAgIGZsb3c6IHtcbiAgICAgIHN0YXJ0OiBbJ21vdXNlZG93bicsICd0b3VjaHN0YXJ0J10sXG4gICAgICBlbmQ6IFsnbW91c2V1cCcsICd0b3VjaGVuZCddXG4gICAgfSxcbiAgICBlbWl0czogWydkb3duJywgJ3VwJ10sXG5cbiAgICBpbmZvOiB7XG4gICAgICBtb3ZlZm46IG51bGwsXG4gICAgICB1cGZuOiBudWxsXG4gICAgfSxcblxuICAgIC8qKiBAdGhpcyB7R2VzdHVyZVJlY29nbml6ZXJ9ICovXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdW50cmFja0RvY3VtZW50KHRoaXMuaW5mbyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEB0aGlzIHtHZXN0dXJlUmVjb2duaXplcn1cbiAgICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGVcbiAgICAgKi9cbiAgICBtb3VzZWRvd246IGZ1bmN0aW9uKGUpIHtcbiAgICAgIGlmICghaGFzTGVmdE1vdXNlQnV0dG9uKGUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxldCB0ID0gR2VzdHVyZXMuX2ZpbmRPcmlnaW5hbFRhcmdldChlKTtcbiAgICAgIGxldCBzZWxmID0gdGhpcztcbiAgICAgIGxldCBtb3ZlZm4gPSBmdW5jdGlvbiBtb3ZlZm4oZSkge1xuICAgICAgICBpZiAoIWhhc0xlZnRNb3VzZUJ1dHRvbihlKSkge1xuICAgICAgICAgIHNlbGYuX2ZpcmUoJ3VwJywgdCwgZSk7XG4gICAgICAgICAgdW50cmFja0RvY3VtZW50KHNlbGYuaW5mbyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBsZXQgdXBmbiA9IGZ1bmN0aW9uIHVwZm4oZSkge1xuICAgICAgICBpZiAoaGFzTGVmdE1vdXNlQnV0dG9uKGUpKSB7XG4gICAgICAgICAgc2VsZi5fZmlyZSgndXAnLCB0LCBlKTtcbiAgICAgICAgfVxuICAgICAgICB1bnRyYWNrRG9jdW1lbnQoc2VsZi5pbmZvKTtcbiAgICAgIH07XG4gICAgICB0cmFja0RvY3VtZW50KHRoaXMuaW5mbywgbW92ZWZuLCB1cGZuKTtcbiAgICAgIHRoaXMuX2ZpcmUoJ2Rvd24nLCB0LCBlKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEB0aGlzIHtHZXN0dXJlUmVjb2duaXplcn1cbiAgICAgKiBAcGFyYW0ge1RvdWNoRXZlbnR9IGVcbiAgICAgKi9cbiAgICB0b3VjaHN0YXJ0OiBmdW5jdGlvbihlKSB7XG4gICAgICB0aGlzLl9maXJlKCdkb3duJywgR2VzdHVyZXMuX2ZpbmRPcmlnaW5hbFRhcmdldChlKSwgZS5jaGFuZ2VkVG91Y2hlc1swXSwgZSk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBAdGhpcyB7R2VzdHVyZVJlY29nbml6ZXJ9XG4gICAgICogQHBhcmFtIHtUb3VjaEV2ZW50fSBlXG4gICAgICovXG4gICAgdG91Y2hlbmQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgIHRoaXMuX2ZpcmUoJ3VwJywgR2VzdHVyZXMuX2ZpbmRPcmlnaW5hbFRhcmdldChlKSwgZS5jaGFuZ2VkVG91Y2hlc1swXSwgZSk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICAgICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IHRhcmdldFxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJldmVudGVyXG4gICAgICovXG4gICAgX2ZpcmU6IGZ1bmN0aW9uKHR5cGUsIHRhcmdldCwgZXZlbnQsIHByZXZlbnRlcikge1xuICAgICAgR2VzdHVyZXMuX2ZpcmUodGFyZ2V0LCB0eXBlLCB7XG4gICAgICAgIHg6IGV2ZW50LmNsaWVudFgsXG4gICAgICAgIHk6IGV2ZW50LmNsaWVudFksXG4gICAgICAgIHNvdXJjZUV2ZW50OiBldmVudCxcbiAgICAgICAgcHJldmVudGVyOiBwcmV2ZW50ZXIsXG4gICAgICAgIHByZXZlbnQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICByZXR1cm4gR2VzdHVyZXMucHJldmVudChlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcblxuICBHZXN0dXJlcy5yZWdpc3Rlcih7XG4gICAgbmFtZTogJ3RyYWNrJyxcbiAgICB0b3VjaEFjdGlvbjogJ25vbmUnLFxuICAgIGRlcHM6IFsnbW91c2Vkb3duJywgJ3RvdWNoc3RhcnQnLCAndG91Y2htb3ZlJywgJ3RvdWNoZW5kJ10sXG4gICAgZmxvdzoge1xuICAgICAgc3RhcnQ6IFsnbW91c2Vkb3duJywgJ3RvdWNoc3RhcnQnXSxcbiAgICAgIGVuZDogWydtb3VzZXVwJywgJ3RvdWNoZW5kJ11cbiAgICB9LFxuICAgIGVtaXRzOiBbJ3RyYWNrJ10sXG5cbiAgICBpbmZvOiB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMCxcbiAgICAgIHN0YXRlOiAnc3RhcnQnLFxuICAgICAgc3RhcnRlZDogZmFsc2UsXG4gICAgICBtb3ZlczogW10sXG4gICAgICAvKiogQHRoaXMge0dlc3R1cmVSZWNvZ25pemVyfSAqL1xuICAgICAgYWRkTW92ZTogZnVuY3Rpb24obW92ZSkge1xuICAgICAgICBpZiAodGhpcy5tb3Zlcy5sZW5ndGggPiBUUkFDS19MRU5HVEgpIHtcbiAgICAgICAgICB0aGlzLm1vdmVzLnNoaWZ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tb3Zlcy5wdXNoKG1vdmUpO1xuICAgICAgfSxcbiAgICAgIG1vdmVmbjogbnVsbCxcbiAgICAgIHVwZm46IG51bGwsXG4gICAgICBwcmV2ZW50OiBmYWxzZVxuICAgIH0sXG5cbiAgICAvKiogQHRoaXMge0dlc3R1cmVSZWNvZ25pemVyfSAqL1xuICAgIHJlc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuaW5mby5zdGF0ZSA9ICdzdGFydCc7XG4gICAgICB0aGlzLmluZm8uc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5pbmZvLm1vdmVzID0gW107XG4gICAgICB0aGlzLmluZm8ueCA9IDA7XG4gICAgICB0aGlzLmluZm8ueSA9IDA7XG4gICAgICB0aGlzLmluZm8ucHJldmVudCA9IGZhbHNlO1xuICAgICAgdW50cmFja0RvY3VtZW50KHRoaXMuaW5mbyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEB0aGlzIHtHZXN0dXJlUmVjb2duaXplcn1cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBoYXNNb3ZlZEVub3VnaDogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgaWYgKHRoaXMuaW5mby5wcmV2ZW50KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmluZm8uc3RhcnRlZCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGxldCBkeCA9IE1hdGguYWJzKHRoaXMuaW5mby54IC0geCk7XG4gICAgICBsZXQgZHkgPSBNYXRoLmFicyh0aGlzLmluZm8ueSAtIHkpO1xuICAgICAgcmV0dXJuIChkeCA+PSBUUkFDS19ESVNUQU5DRSB8fCBkeSA+PSBUUkFDS19ESVNUQU5DRSk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBAdGhpcyB7R2VzdHVyZVJlY29nbml6ZXJ9XG4gICAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBlXG4gICAgICovXG4gICAgbW91c2Vkb3duOiBmdW5jdGlvbihlKSB7XG4gICAgICBpZiAoIWhhc0xlZnRNb3VzZUJ1dHRvbihlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsZXQgdCA9IEdlc3R1cmVzLl9maW5kT3JpZ2luYWxUYXJnZXQoZSk7XG4gICAgICBsZXQgc2VsZiA9IHRoaXM7XG4gICAgICBsZXQgbW92ZWZuID0gZnVuY3Rpb24gbW92ZWZuKGUpIHtcbiAgICAgICAgbGV0IHggPSBlLmNsaWVudFgsIHkgPSBlLmNsaWVudFk7XG4gICAgICAgIGlmIChzZWxmLmhhc01vdmVkRW5vdWdoKHgsIHkpKSB7XG4gICAgICAgICAgLy8gZmlyc3QgbW92ZSBpcyAnc3RhcnQnLCBzdWJzZXF1ZW50IG1vdmVzIGFyZSAnbW92ZScsIG1vdXNldXAgaXMgJ2VuZCdcbiAgICAgICAgICBzZWxmLmluZm8uc3RhdGUgPSBzZWxmLmluZm8uc3RhcnRlZCA/IChlLnR5cGUgPT09ICdtb3VzZXVwJyA/ICdlbmQnIDogJ3RyYWNrJykgOiAnc3RhcnQnO1xuICAgICAgICAgIGlmIChzZWxmLmluZm8uc3RhdGUgPT09ICdzdGFydCcpIHtcbiAgICAgICAgICAgIC8vIGlmIGFuZCBvbmx5IGlmIHRyYWNraW5nLCBhbHdheXMgcHJldmVudCB0YXBcbiAgICAgICAgICAgIEdlc3R1cmVzLnByZXZlbnQoJ3RhcCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzZWxmLmluZm8uYWRkTW92ZSh7eDogeCwgeTogeX0pO1xuICAgICAgICAgIGlmICghaGFzTGVmdE1vdXNlQnV0dG9uKGUpKSB7XG4gICAgICAgICAgICAvLyBhbHdheXMgX2ZpcmUgXCJlbmRcIlxuICAgICAgICAgICAgc2VsZi5pbmZvLnN0YXRlID0gJ2VuZCc7XG4gICAgICAgICAgICB1bnRyYWNrRG9jdW1lbnQoc2VsZi5pbmZvKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2VsZi5fZmlyZSh0LCBlKTtcbiAgICAgICAgICBzZWxmLmluZm8uc3RhcnRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBsZXQgdXBmbiA9IGZ1bmN0aW9uIHVwZm4oZSkge1xuICAgICAgICBpZiAoc2VsZi5pbmZvLnN0YXJ0ZWQpIHtcbiAgICAgICAgICBtb3ZlZm4oZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZW1vdmUgdGhlIHRlbXBvcmFyeSBsaXN0ZW5lcnNcbiAgICAgICAgdW50cmFja0RvY3VtZW50KHNlbGYuaW5mbyk7XG4gICAgICB9O1xuICAgICAgLy8gYWRkIHRlbXBvcmFyeSBkb2N1bWVudCBsaXN0ZW5lcnMgYXMgbW91c2UgcmV0YXJnZXRzXG4gICAgICB0cmFja0RvY3VtZW50KHRoaXMuaW5mbywgbW92ZWZuLCB1cGZuKTtcbiAgICAgIHRoaXMuaW5mby54ID0gZS5jbGllbnRYO1xuICAgICAgdGhpcy5pbmZvLnkgPSBlLmNsaWVudFk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBAdGhpcyB7R2VzdHVyZVJlY29nbml6ZXJ9XG4gICAgICogQHBhcmFtIHtUb3VjaEV2ZW50fSBlXG4gICAgICovXG4gICAgdG91Y2hzdGFydDogZnVuY3Rpb24oZSkge1xuICAgICAgbGV0IGN0ID0gZS5jaGFuZ2VkVG91Y2hlc1swXTtcbiAgICAgIHRoaXMuaW5mby54ID0gY3QuY2xpZW50WDtcbiAgICAgIHRoaXMuaW5mby55ID0gY3QuY2xpZW50WTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEB0aGlzIHtHZXN0dXJlUmVjb2duaXplcn1cbiAgICAgKiBAcGFyYW0ge1RvdWNoRXZlbnR9IGVcbiAgICAgKi9cbiAgICB0b3VjaG1vdmU6IGZ1bmN0aW9uKGUpIHtcbiAgICAgIGxldCB0ID0gR2VzdHVyZXMuX2ZpbmRPcmlnaW5hbFRhcmdldChlKTtcbiAgICAgIGxldCBjdCA9IGUuY2hhbmdlZFRvdWNoZXNbMF07XG4gICAgICBsZXQgeCA9IGN0LmNsaWVudFgsIHkgPSBjdC5jbGllbnRZO1xuICAgICAgaWYgKHRoaXMuaGFzTW92ZWRFbm91Z2goeCwgeSkpIHtcbiAgICAgICAgaWYgKHRoaXMuaW5mby5zdGF0ZSA9PT0gJ3N0YXJ0Jykge1xuICAgICAgICAgIC8vIGlmIGFuZCBvbmx5IGlmIHRyYWNraW5nLCBhbHdheXMgcHJldmVudCB0YXBcbiAgICAgICAgICBHZXN0dXJlcy5wcmV2ZW50KCd0YXAnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluZm8uYWRkTW92ZSh7eDogeCwgeTogeX0pO1xuICAgICAgICB0aGlzLl9maXJlKHQsIGN0KTtcbiAgICAgICAgdGhpcy5pbmZvLnN0YXRlID0gJ3RyYWNrJztcbiAgICAgICAgdGhpcy5pbmZvLnN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogQHRoaXMge0dlc3R1cmVSZWNvZ25pemVyfVxuICAgICAqIEBwYXJhbSB7VG91Y2hFdmVudH0gZVxuICAgICAqL1xuICAgIHRvdWNoZW5kOiBmdW5jdGlvbihlKSB7XG4gICAgICBsZXQgdCA9IEdlc3R1cmVzLl9maW5kT3JpZ2luYWxUYXJnZXQoZSk7XG4gICAgICBsZXQgY3QgPSBlLmNoYW5nZWRUb3VjaGVzWzBdO1xuICAgICAgLy8gb25seSB0cmFja2VuZCBpZiB0cmFjayB3YXMgc3RhcnRlZCBhbmQgbm90IGFib3J0ZWRcbiAgICAgIGlmICh0aGlzLmluZm8uc3RhcnRlZCkge1xuICAgICAgICAvLyByZXNldCBzdGFydGVkIHN0YXRlIG9uIHVwXG4gICAgICAgIHRoaXMuaW5mby5zdGF0ZSA9ICdlbmQnO1xuICAgICAgICB0aGlzLmluZm8uYWRkTW92ZSh7eDogY3QuY2xpZW50WCwgeTogY3QuY2xpZW50WX0pO1xuICAgICAgICB0aGlzLl9maXJlKHQsIGN0LCBlKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHRoaXMge0dlc3R1cmVSZWNvZ25pemVyfVxuICAgICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IHRhcmdldFxuICAgICAqIEBwYXJhbSB7VG91Y2h9IHRvdWNoXG4gICAgICovXG4gICAgX2ZpcmU6IGZ1bmN0aW9uKHRhcmdldCwgdG91Y2gpIHtcbiAgICAgIGxldCBzZWNvbmRsYXN0ID0gdGhpcy5pbmZvLm1vdmVzW3RoaXMuaW5mby5tb3Zlcy5sZW5ndGggLSAyXTtcbiAgICAgIGxldCBsYXN0bW92ZSA9IHRoaXMuaW5mby5tb3Zlc1t0aGlzLmluZm8ubW92ZXMubGVuZ3RoIC0gMV07XG4gICAgICBsZXQgZHggPSBsYXN0bW92ZS54IC0gdGhpcy5pbmZvLng7XG4gICAgICBsZXQgZHkgPSBsYXN0bW92ZS55IC0gdGhpcy5pbmZvLnk7XG4gICAgICBsZXQgZGR4LCBkZHkgPSAwO1xuICAgICAgaWYgKHNlY29uZGxhc3QpIHtcbiAgICAgICAgZGR4ID0gbGFzdG1vdmUueCAtIHNlY29uZGxhc3QueDtcbiAgICAgICAgZGR5ID0gbGFzdG1vdmUueSAtIHNlY29uZGxhc3QueTtcbiAgICAgIH1cbiAgICAgIEdlc3R1cmVzLl9maXJlKHRhcmdldCwgJ3RyYWNrJywge1xuICAgICAgICBzdGF0ZTogdGhpcy5pbmZvLnN0YXRlLFxuICAgICAgICB4OiB0b3VjaC5jbGllbnRYLFxuICAgICAgICB5OiB0b3VjaC5jbGllbnRZLFxuICAgICAgICBkeDogZHgsXG4gICAgICAgIGR5OiBkeSxcbiAgICAgICAgZGR4OiBkZHgsXG4gICAgICAgIGRkeTogZGR5LFxuICAgICAgICBzb3VyY2VFdmVudDogdG91Y2gsXG4gICAgICAgIGhvdmVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gR2VzdHVyZXMuZGVlcFRhcmdldEZpbmQodG91Y2guY2xpZW50WCwgdG91Y2guY2xpZW50WSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICB9KTtcblxuICBHZXN0dXJlcy5yZWdpc3Rlcih7XG4gICAgbmFtZTogJ3RhcCcsXG4gICAgZGVwczogWydtb3VzZWRvd24nLCAnY2xpY2snLCAndG91Y2hzdGFydCcsICd0b3VjaGVuZCddLFxuICAgIGZsb3c6IHtcbiAgICAgIHN0YXJ0OiBbJ21vdXNlZG93bicsICd0b3VjaHN0YXJ0J10sXG4gICAgICBlbmQ6IFsnY2xpY2snLCAndG91Y2hlbmQnXVxuICAgIH0sXG4gICAgZW1pdHM6IFsndGFwJ10sXG4gICAgaW5mbzoge1xuICAgICAgeDogTmFOLFxuICAgICAgeTogTmFOLFxuICAgICAgcHJldmVudDogZmFsc2VcbiAgICB9LFxuICAgIC8qKiBAdGhpcyB7R2VzdHVyZVJlY29nbml6ZXJ9ICovXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5pbmZvLnggPSBOYU47XG4gICAgICB0aGlzLmluZm8ueSA9IE5hTjtcbiAgICAgIHRoaXMuaW5mby5wcmV2ZW50ID0gZmFsc2U7XG4gICAgfSxcbiAgICAvKiogQHRoaXMge0dlc3R1cmVSZWNvZ25pemVyfSAqL1xuICAgIHNhdmU6IGZ1bmN0aW9uKGUpIHtcbiAgICAgIHRoaXMuaW5mby54ID0gZS5jbGllbnRYO1xuICAgICAgdGhpcy5pbmZvLnkgPSBlLmNsaWVudFk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBAdGhpcyB7R2VzdHVyZVJlY29nbml6ZXJ9XG4gICAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBlXG4gICAgICovXG4gICAgbW91c2Vkb3duOiBmdW5jdGlvbihlKSB7XG4gICAgICBpZiAoaGFzTGVmdE1vdXNlQnV0dG9uKGUpKSB7XG4gICAgICAgIHRoaXMuc2F2ZShlKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEB0aGlzIHtHZXN0dXJlUmVjb2duaXplcn1cbiAgICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGVcbiAgICAgKi9cbiAgICBjbGljazogZnVuY3Rpb24oZSkge1xuICAgICAgaWYgKGhhc0xlZnRNb3VzZUJ1dHRvbihlKSkge1xuICAgICAgICB0aGlzLmZvcndhcmQoZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBAdGhpcyB7R2VzdHVyZVJlY29nbml6ZXJ9XG4gICAgICogQHBhcmFtIHtUb3VjaEV2ZW50fSBlXG4gICAgICovXG4gICAgdG91Y2hzdGFydDogZnVuY3Rpb24oZSkge1xuICAgICAgdGhpcy5zYXZlKGUuY2hhbmdlZFRvdWNoZXNbMF0sIGUpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQHRoaXMge0dlc3R1cmVSZWNvZ25pemVyfVxuICAgICAqIEBwYXJhbSB7VG91Y2hFdmVudH0gZVxuICAgICAqL1xuICAgIHRvdWNoZW5kOiBmdW5jdGlvbihlKSB7XG4gICAgICB0aGlzLmZvcndhcmQoZS5jaGFuZ2VkVG91Y2hlc1swXSwgZSk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBAdGhpcyB7R2VzdHVyZVJlY29nbml6ZXJ9XG4gICAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZXZlbnRlclxuICAgICAqL1xuICAgIGZvcndhcmQ6IGZ1bmN0aW9uKGUsIHByZXZlbnRlcikge1xuICAgICAgbGV0IGR4ID0gTWF0aC5hYnMoZS5jbGllbnRYIC0gdGhpcy5pbmZvLngpO1xuICAgICAgbGV0IGR5ID0gTWF0aC5hYnMoZS5jbGllbnRZIC0gdGhpcy5pbmZvLnkpO1xuICAgICAgbGV0IHQgPSBHZXN0dXJlcy5fZmluZE9yaWdpbmFsVGFyZ2V0KGUpO1xuICAgICAgLy8gZHgsZHkgY2FuIGJlIE5hTiBpZiBgY2xpY2tgIGhhcyBiZWVuIHNpbXVsYXRlZCBhbmQgdGhlcmUgd2FzIG5vIGBkb3duYCBmb3IgYHN0YXJ0YFxuICAgICAgaWYgKGlzTmFOKGR4KSB8fCBpc05hTihkeSkgfHwgKGR4IDw9IFRBUF9ESVNUQU5DRSAmJiBkeSA8PSBUQVBfRElTVEFOQ0UpIHx8IGlzU3ludGhldGljQ2xpY2soZSkpIHtcbiAgICAgICAgLy8gcHJldmVudCB0YXBzIGZyb20gYmVpbmcgZ2VuZXJhdGVkIGlmIGFuIGV2ZW50IGhhcyBjYW5jZWxlZCB0aGVtXG4gICAgICAgIGlmICghdGhpcy5pbmZvLnByZXZlbnQpIHtcbiAgICAgICAgICBHZXN0dXJlcy5fZmlyZSh0LCAndGFwJywge1xuICAgICAgICAgICAgeDogZS5jbGllbnRYLFxuICAgICAgICAgICAgeTogZS5jbGllbnRZLFxuICAgICAgICAgICAgc291cmNlRXZlbnQ6IGUsXG4gICAgICAgICAgICBwcmV2ZW50ZXI6IHByZXZlbnRlclxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICAvKiBlc2xpbnQtZW5hYmxlIHZhbGlkLWpzZG9jICovXG5cbiAgLyoqIEBkZXByZWNhdGVkICovXG4gIEdlc3R1cmVzLmZpbmRPcmlnaW5hbFRhcmdldCA9IEdlc3R1cmVzLl9maW5kT3JpZ2luYWxUYXJnZXQ7XG5cbiAgLyoqIEBkZXByZWNhdGVkICovXG4gIEdlc3R1cmVzLmFkZCA9IEdlc3R1cmVzLmFkZExpc3RlbmVyO1xuXG4gIC8qKiBAZGVwcmVjYXRlZCAqL1xuICBHZXN0dXJlcy5yZW1vdmUgPSBHZXN0dXJlcy5yZW1vdmVMaXN0ZW5lcjtcblxuICBQb2x5bWVyLkdlc3R1cmVzID0gR2VzdHVyZXM7XG5cbn0pKCk7XG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvdXRpbHMvZ2VzdHVyZXMuaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cblxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cImJvb3QuaHRtbFwiPlxuXG48c2NyaXB0PlxuXG4oZnVuY3Rpb24oKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIHJ1biBhIGNhbGxiYWNrIHdoZW4gSFRNTEltcG9ydHMgYXJlIHJlYWR5IG9yIGltbWVkaWF0ZWx5IGlmXG4gIC8vIHRoaXMgYXBpIGlzIG5vdCBhdmFpbGFibGUuXG4gIGZ1bmN0aW9uIHdoZW5JbXBvcnRzUmVhZHkoY2IpIHtcbiAgICBpZiAod2luZG93LkhUTUxJbXBvcnRzKSB7XG4gICAgICBIVE1MSW1wb3J0cy53aGVuUmVhZHkoY2IpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYigpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZW5pZW5jZSBtZXRob2QgZm9yIGltcG9ydGluZyBhbiBIVE1MIGRvY3VtZW50IGltcGVyYXRpdmVseS5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgY3JlYXRlcyBhIG5ldyBgPGxpbmsgcmVsPVwiaW1wb3J0XCI+YCBlbGVtZW50IHdpdGhcbiAgICogdGhlIHByb3ZpZGVkIFVSTCBhbmQgYXBwZW5kcyBpdCB0byB0aGUgZG9jdW1lbnQgdG8gc3RhcnQgbG9hZGluZy5cbiAgICogSW4gdGhlIGBvbmxvYWRgIGNhbGxiYWNrLCB0aGUgYGltcG9ydGAgcHJvcGVydHkgb2YgdGhlIGBsaW5rYFxuICAgKiBlbGVtZW50IHdpbGwgY29udGFpbiB0aGUgaW1wb3J0ZWQgZG9jdW1lbnQgY29udGVudHMuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBQb2x5bWVyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBocmVmIFVSTCB0byBkb2N1bWVudCB0byBsb2FkLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uPX0gb25sb2FkIENhbGxiYWNrIHRvIG5vdGlmeSB3aGVuIGFuIGltcG9ydCBzdWNjZXNzZnVsbHlcbiAgICogICBsb2FkZWQuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBvbmVycm9yIENhbGxiYWNrIHRvIG5vdGlmeSB3aGVuIGFuIGltcG9ydFxuICAgKiAgIHVuc3VjY2Vzc2Z1bGx5IGxvYWRlZC5cbiAgICogQHBhcmFtIHtib29sZWFuPX0gb3B0QXN5bmMgVHJ1ZSBpZiB0aGUgaW1wb3J0IHNob3VsZCBiZSBsb2FkZWQgYGFzeW5jYC5cbiAgICogICBEZWZhdWx0cyB0byBgZmFsc2VgLlxuICAgKiBAcmV0dXJuIHtIVE1MTGlua0VsZW1lbnR9IFRoZSBsaW5rIGVsZW1lbnQgZm9yIHRoZSBVUkwgdG8gYmUgbG9hZGVkLlxuICAgKi9cbiAgUG9seW1lci5pbXBvcnRIcmVmID0gZnVuY3Rpb24oaHJlZiwgb25sb2FkLCBvbmVycm9yLCBvcHRBc3luYykge1xuICAgIGxldCBsaW5rID0gLyoqIEB0eXBlIHtIVE1MTGlua0VsZW1lbnR9ICovXG4gICAgICAoZG9jdW1lbnQuaGVhZC5xdWVyeVNlbGVjdG9yKCdsaW5rW2hyZWY9XCInICsgaHJlZiArICdcIl1baW1wb3J0LWhyZWZdJykpO1xuICAgIGlmICghbGluaykge1xuICAgICAgbGluayA9IC8qKiBAdHlwZSB7SFRNTExpbmtFbGVtZW50fSAqLyAoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGluaycpKTtcbiAgICAgIGxpbmsucmVsID0gJ2ltcG9ydCc7XG4gICAgICBsaW5rLmhyZWYgPSBocmVmO1xuICAgICAgbGluay5zZXRBdHRyaWJ1dGUoJ2ltcG9ydC1ocmVmJywgJycpO1xuICAgIH1cbiAgICAvLyBhbHdheXMgZW5zdXJlIGxpbmsgaGFzIGBhc3luY2AgYXR0cmlidXRlIGlmIHVzZXIgc3BlY2lmaWVkIG9uZSxcbiAgICAvLyBldmVuIGlmIGl0IHdhcyBwcmV2aW91c2x5IG5vdCBhc3luYy4gVGhpcyBpcyBjb25zaWRlcmVkIGxlc3MgY29uZnVzaW5nLlxuICAgIGlmIChvcHRBc3luYykge1xuICAgICAgbGluay5zZXRBdHRyaWJ1dGUoJ2FzeW5jJywgJycpO1xuICAgIH1cbiAgICAvLyBOT1RFOiB0aGUgbGluayBtYXkgbm93IGJlIGluIDMgc3RhdGVzOiAoMSkgcGVuZGluZyBpbnNlcnRpb24sXG4gICAgLy8gKDIpIGluZmxpZ2h0LCAoMykgYWxyZWFkeSBsYW9kZWQuIEluIGVhY2ggY2FzZSwgd2UgbmVlZCB0byBhZGRcbiAgICAvLyBldmVudCBsaXN0ZW5lcnMgdG8gcHJvY2VzcyBjYWxsYmFja3MuXG4gICAgbGV0IGNsZWFudXAgPSBmdW5jdGlvbigpIHtcbiAgICAgIGxpbmsucmVtb3ZlRXZlbnRMaXN0ZW5lcignbG9hZCcsIGxvYWRMaXN0ZW5lcik7XG4gICAgICBsaW5rLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgZXJyb3JMaXN0ZW5lcik7XG4gICAgfVxuICAgIGxldCBsb2FkTGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgY2xlYW51cCgpO1xuICAgICAgLy8gSW4gY2FzZSBvZiBhIHN1Y2Nlc3NmdWwgbG9hZCwgY2FjaGUgdGhlIGxvYWQgZXZlbnQgb24gdGhlIGxpbmsgc29cbiAgICAgIC8vIHRoYXQgaXQgY2FuIGJlIHVzZWQgdG8gc2hvcnQtY2lyY3VpdCB0aGlzIG1ldGhvZCBpbiB0aGUgZnV0dXJlIHdoZW5cbiAgICAgIC8vIGl0IGlzIGNhbGxlZCB3aXRoIHRoZSBzYW1lIGhyZWYgcGFyYW0uXG4gICAgICBsaW5rLl9fZHluYW1pY0ltcG9ydExvYWRlZCA9IHRydWU7XG4gICAgICBpZiAob25sb2FkKSB7XG4gICAgICAgIHdoZW5JbXBvcnRzUmVhZHkoKCkgPT4ge1xuICAgICAgICAgIG9ubG9hZChldmVudCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gICAgbGV0IGVycm9yTGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgY2xlYW51cCgpO1xuICAgICAgLy8gSW4gY2FzZSBvZiBhbiBlcnJvciwgcmVtb3ZlIHRoZSBsaW5rIGZyb20gdGhlIGRvY3VtZW50IHNvIHRoYXQgaXRcbiAgICAgIC8vIHdpbGwgYmUgYXV0b21hdGljYWxseSBjcmVhdGVkIGFnYWluIHRoZSBuZXh0IHRpbWUgYGltcG9ydEhyZWZgIGlzXG4gICAgICAvLyBjYWxsZWQuXG4gICAgICBpZiAobGluay5wYXJlbnROb2RlKSB7XG4gICAgICAgIGxpbmsucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChsaW5rKTtcbiAgICAgIH1cbiAgICAgIGlmIChvbmVycm9yKSB7XG4gICAgICAgIHdoZW5JbXBvcnRzUmVhZHkoKCkgPT4ge1xuICAgICAgICAgIG9uZXJyb3IoZXZlbnQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGxpbmsuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIGxvYWRMaXN0ZW5lcik7XG4gICAgbGluay5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGVycm9yTGlzdGVuZXIpO1xuICAgIGlmIChsaW5rLnBhcmVudE5vZGUgPT0gbnVsbCkge1xuICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChsaW5rKTtcbiAgICAvLyBpZiB0aGUgbGluayBhbHJlYWR5IGxvYWRlZCwgZGlzcGF0Y2ggYSBmYWtlIGxvYWQgZXZlbnRcbiAgICAvLyBzbyB0aGF0IGxpc3RlbmVycyBhcmUgY2FsbGVkIGFuZCBnZXQgYSBwcm9wZXIgZXZlbnQgYXJndW1lbnQuXG4gICAgfSBlbHNlIGlmIChsaW5rLl9fZHluYW1pY0ltcG9ydExvYWRlZCkge1xuICAgICAgbGluay5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnbG9hZCcpKTtcbiAgICB9XG4gICAgcmV0dXJuIGxpbms7XG4gIH07XG5cbn0pKCk7XG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvdXRpbHMvaW1wb3J0LWhyZWYuaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCJib290Lmh0bWxcIj5cblxuPHNjcmlwdD5cbihmdW5jdGlvbigpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgbGV0IHNjaGVkdWxlZCA9IGZhbHNlO1xuICBsZXQgYmVmb3JlUmVuZGVyUXVldWUgPSBbXTtcbiAgbGV0IGFmdGVyUmVuZGVyUXVldWUgPSBbXTtcblxuICBmdW5jdGlvbiBzY2hlZHVsZSgpIHtcbiAgICBzY2hlZHVsZWQgPSB0cnVlO1xuICAgIC8vIGJlZm9yZSBuZXh0IHJlbmRlclxuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbigpIHtcbiAgICAgIHNjaGVkdWxlZCA9IGZhbHNlO1xuICAgICAgZmx1c2hRdWV1ZShiZWZvcmVSZW5kZXJRdWV1ZSk7XG4gICAgICAvLyBhZnRlciB0aGUgcmVuZGVyXG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICBydW5RdWV1ZShhZnRlclJlbmRlclF1ZXVlKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZmx1c2hRdWV1ZShxdWV1ZSkge1xuICAgIHdoaWxlIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgIGNhbGxNZXRob2QocXVldWUuc2hpZnQoKSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcnVuUXVldWUocXVldWUpIHtcbiAgICBmb3IgKGxldCBpPTAsIGw9cXVldWUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBjYWxsTWV0aG9kKHF1ZXVlLnNoaWZ0KCkpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbGxNZXRob2QoaW5mbykge1xuICAgIGNvbnN0IGNvbnRleHQgPSBpbmZvWzBdO1xuICAgIGNvbnN0IGNhbGxiYWNrID0gaW5mb1sxXTtcbiAgICBjb25zdCBhcmdzID0gaW5mb1syXTtcbiAgICB0cnkge1xuICAgICAgY2FsbGJhY2suYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgfSBjYXRjaChlKSB7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZmx1c2goKSB7XG4gICAgd2hpbGUgKGJlZm9yZVJlbmRlclF1ZXVlLmxlbmd0aCB8fCBhZnRlclJlbmRlclF1ZXVlLmxlbmd0aCkge1xuICAgICAgZmx1c2hRdWV1ZShiZWZvcmVSZW5kZXJRdWV1ZSk7XG4gICAgICBmbHVzaFF1ZXVlKGFmdGVyUmVuZGVyUXVldWUpO1xuICAgIH1cbiAgICBzY2hlZHVsZWQgPSBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNb2R1bGUgZm9yIHNjaGVkdWxpbmcgZmx1c2hhYmxlIHByZS1yZW5kZXIgYW5kIHBvc3QtcmVuZGVyIHRhc2tzLlxuICAgKlxuICAgKiBAbmFtZXNwYWNlXG4gICAqIEBtZW1iZXJvZiBQb2x5bWVyXG4gICAqIEBzdW1tYXJ5IE1vZHVsZSBmb3Igc2NoZWR1bGluZyBmbHVzaGFibGUgcHJlLXJlbmRlciBhbmQgcG9zdC1yZW5kZXIgdGFza3MuXG4gICAqL1xuICBQb2x5bWVyLlJlbmRlclN0YXR1cyA9IHtcblxuICAgIC8qKlxuICAgICAqIEVucXVldWVzIGEgY2FsbGJhY2sgd2hpY2ggd2lsbCBiZSBydW4gYmVmb3JlIHRoZSBuZXh0IHJlbmRlciwgYXRcbiAgICAgKiBgcmVxdWVzdEFuaW1hdGlvbkZyYW1lYCB0aW1pbmcuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyB1c2VmdWwgZm9yIGVucXVldWluZyB3b3JrIHRoYXQgcmVxdWlyZXMgRE9NIG1lYXN1cmVtZW50LFxuICAgICAqIHNpbmNlIG1lYXN1cmVtZW50IG1heSBub3QgYmUgcmVsaWFibGUgaW4gY3VzdG9tIGVsZW1lbnQgY2FsbGJhY2tzIGJlZm9yZVxuICAgICAqIHRoZSBmaXJzdCByZW5kZXIsIGFzIHdlbGwgYXMgZm9yIGJhdGNoaW5nIG1lYXN1cmVtZW50IHRhc2tzIGluIGdlbmVyYWwuXG4gICAgICpcbiAgICAgKiBUYXNrcyBpbiB0aGlzIHF1ZXVlIG1heSBiZSBmbHVzaGVkIGJ5IGNhbGxpbmcgYFBvbHltZXIuUmVuZGVyU3RhdHVzLmZsdXNoKClgLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIFBvbHltZXIuUmVuZGVyU3RhdHVzXG4gICAgICogQHBhcmFtIHsqfSBjb250ZXh0IENvbnRleHQgb2JqZWN0IHRoZSBjYWxsYmFjayBmdW5jdGlvbiB3aWxsIGJlIGJvdW5kIHRvXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbigpfSBjYWxsYmFjayBDYWxsYmFjayBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgQW4gYXJyYXkgb2YgYXJndW1lbnRzIHRvIGNhbGwgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHdpdGhcbiAgICAgKi9cbiAgICBiZWZvcmVOZXh0UmVuZGVyOiBmdW5jdGlvbihjb250ZXh0LCBjYWxsYmFjaywgYXJncykge1xuICAgICAgaWYgKCFzY2hlZHVsZWQpIHtcbiAgICAgICAgc2NoZWR1bGUoKTtcbiAgICAgIH1cbiAgICAgIGJlZm9yZVJlbmRlclF1ZXVlLnB1c2goW2NvbnRleHQsIGNhbGxiYWNrLCBhcmdzXSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEVucXVldWVzIGEgY2FsbGJhY2sgd2hpY2ggd2lsbCBiZSBydW4gYWZ0ZXIgdGhlIG5leHQgcmVuZGVyLCBlcXVpdmFsZW50XG4gICAgICogdG8gb25lIHRhc2sgKGBzZXRUaW1lb3V0YCkgYWZ0ZXIgdGhlIG5leHQgYHJlcXVlc3RBbmltYXRpb25GcmFtZWAuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyB1c2VmdWwgZm9yIHR1bmluZyB0aGUgZmlyc3QtcmVuZGVyIHBlcmZvcm1hbmNlIG9mIGFuXG4gICAgICogZWxlbWVudCBvciBhcHBsaWNhdGlvbiBieSBkZWZlcnJpbmcgbm9uLWNyaXRpY2FsIHdvcmsgdW50aWwgYWZ0ZXIgdGhlXG4gICAgICogZmlyc3QgcGFpbnQuICBUeXBpY2FsIG5vbi1yZW5kZXItY3JpdGljYWwgd29yayBtYXkgaW5jbHVkZSBhZGRpbmcgVUlcbiAgICAgKiBldmVudCBsaXN0ZW5lcnMgYW5kIGFyaWEgYXR0cmlidXRlcy5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBQb2x5bWVyLlJlbmRlclN0YXR1c1xuICAgICAqIEBwYXJhbSB7Kn0gY29udGV4dCBDb250ZXh0IG9iamVjdCB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gd2lsbCBiZSBib3VuZCB0b1xuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oKX0gY2FsbGJhY2sgQ2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcmdzIEFuIGFycmF5IG9mIGFyZ3VtZW50cyB0byBjYWxsIHRoZSBjYWxsYmFjayBmdW5jdGlvbiB3aXRoXG4gICAgICovXG4gICAgYWZ0ZXJOZXh0UmVuZGVyOiBmdW5jdGlvbihjb250ZXh0LCBjYWxsYmFjaywgYXJncykge1xuICAgICAgaWYgKCFzY2hlZHVsZWQpIHtcbiAgICAgICAgc2NoZWR1bGUoKTtcbiAgICAgIH1cbiAgICAgIGFmdGVyUmVuZGVyUXVldWUucHVzaChbY29udGV4dCwgY2FsbGJhY2ssIGFyZ3NdKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmx1c2hlcyBhbGwgYGJlZm9yZU5leHRSZW5kZXJgIHRhc2tzLCBmb2xsb3dlZCBieSBhbGwgYGFmdGVyTmV4dFJlbmRlcmBcbiAgICAgKiB0YXNrcy5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBQb2x5bWVyLlJlbmRlclN0YXR1c1xuICAgICAqL1xuICAgIGZsdXNoOiBmbHVzaFxuXG4gIH07XG5cbn0pKCk7XG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvdXRpbHMvcmVuZGVyLXN0YXR1cy5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuPHNjcmlwdD5cbihmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIHVucmVzb2x2ZWRcblxuICBmdW5jdGlvbiByZXNvbHZlKCkge1xuICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQXR0cmlidXRlKCd1bnJlc29sdmVkJyk7XG4gIH1cblxuICBpZiAod2luZG93LldlYkNvbXBvbmVudHMpIHtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignV2ViQ29tcG9uZW50c1JlYWR5JywgcmVzb2x2ZSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdpbnRlcmFjdGl2ZScgfHwgZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gJ2NvbXBsZXRlJykge1xuICAgICAgcmVzb2x2ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIHJlc29sdmUpO1xuICAgIH1cbiAgfVxuXG59KSgpO1xuPC9zY3JpcHQ+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL3BvbHltZXIvbGliL3V0aWxzL3VucmVzb2x2ZWQuaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi91dGlscy9ib290Lmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi91dGlscy9zZXR0aW5ncy5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vdXRpbHMvZmxhdHRlbmVkLW5vZGVzLW9ic2VydmVyLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi91dGlscy9mbHVzaC5odG1sXCI+XG48c2NyaXB0PlxuKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgY29uc3QgcCA9IEVsZW1lbnQucHJvdG90eXBlO1xuICAvKipcbiAgICogQGNvbnN0IHtmdW5jdGlvbih0aGlzOkVsZW1lbnQsIHN0cmluZyk6IGJvb2xlYW59XG4gICAqL1xuICBjb25zdCBub3JtYWxpemVkTWF0Y2hlc1NlbGVjdG9yID0gcC5tYXRjaGVzIHx8IHAubWF0Y2hlc1NlbGVjdG9yIHx8XG4gICAgcC5tb3pNYXRjaGVzU2VsZWN0b3IgfHwgcC5tc01hdGNoZXNTZWxlY3RvciB8fFxuICAgIHAub01hdGNoZXNTZWxlY3RvciB8fCBwLndlYmtpdE1hdGNoZXNTZWxlY3RvcjtcblxuICAvKipcbiAgICogQ3Jvc3MtcGxhdGZvcm0gYGVsZW1lbnQubWF0Y2hlc2Agc2hpbS5cbiAgICpcbiAgICogQGZ1bmN0aW9uIG1hdGNoZXNTZWxlY3RvclxuICAgKiBAbWVtYmVyb2YgUG9seW1lci5kb21cbiAgICogQHBhcmFtIHshRWxlbWVudH0gbm9kZSBOb2RlIHRvIGNoZWNrIHNlbGVjdG9yIGFnYWluc3RcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yIFNlbGVjdG9yIHRvIG1hdGNoXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgbm9kZSBtYXRjaGVkIHNlbGVjdG9yXG4gICAqL1xuICBjb25zdCBtYXRjaGVzU2VsZWN0b3IgPSBmdW5jdGlvbihub2RlLCBzZWxlY3Rvcikge1xuICAgIHJldHVybiBub3JtYWxpemVkTWF0Y2hlc1NlbGVjdG9yLmNhbGwobm9kZSwgc2VsZWN0b3IpO1xuICB9XG5cbiAgLyoqXG4gICAqIE5vZGUgQVBJIHdyYXBwZXIgY2xhc3MgcmV0dXJuZWQgZnJvbSBgUG9seW1lci5kb20uKHRhcmdldClgIHdoZW5cbiAgICogYHRhcmdldGAgaXMgYSBgTm9kZWAuXG4gICAqL1xuICBjbGFzcyBEb21BcGkge1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlIE5vZGUgZm9yIHdoaWNoIHRvIGNyZWF0ZSBhIFBvbHltZXIuZG9tIGhlbHBlciBvYmplY3QuXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iobm9kZSkge1xuICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGluc3RhbmNlIG9mIGBQb2x5bWVyLkZsYXR0ZW5lZE5vZGVzT2JzZXJ2ZXJgIHRoYXRcbiAgICAgKiBsaXN0ZW5zIGZvciBub2RlIGNoYW5nZXMgb24gdGhpcyBlbGVtZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIHdoZW4gZGlyZWN0IG9yIGRpc3RyaWJ1dGVkIGNoaWxkcmVuXG4gICAgICogICBvZiB0aGlzIGVsZW1lbnQgY2hhbmdlc1xuICAgICAqIEByZXR1cm4ge1BvbHltZXIuRmxhdHRlbmVkTm9kZXNPYnNlcnZlcn0gT2JzZXJ2ZXIgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBvYnNlcnZlTm9kZXMoY2FsbGJhY2spIHtcbiAgICAgIHJldHVybiBuZXcgUG9seW1lci5GbGF0dGVuZWROb2Rlc09ic2VydmVyKHRoaXMubm9kZSwgY2FsbGJhY2spO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERpc2Nvbm5lY3RzIGFuIG9ic2VydmVyIHByZXZpb3VzbHkgY3JlYXRlZCB2aWEgYG9ic2VydmVOb2Rlc2BcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UG9seW1lci5GbGF0dGVuZWROb2Rlc09ic2VydmVyfSBvYnNlcnZlckhhbmRsZSBPYnNlcnZlciBpbnN0YW5jZVxuICAgICAqICAgdG8gZGlzY29ubmVjdC5cbiAgICAgKi9cbiAgICB1bm9ic2VydmVOb2RlcyhvYnNlcnZlckhhbmRsZSkge1xuICAgICAgb2JzZXJ2ZXJIYW5kbGUuZGlzY29ubmVjdCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByb3ZpZGVkIGFzIGEgYmFja3dhcmRzLWNvbXBhdGlibGUgQVBJIG9ubHkuICBUaGlzIG1ldGhvZCBkb2VzIG5vdGhpbmcuXG4gICAgICovXG4gICAgbm90aWZ5T2JzZXJ2ZXIoKSB7fVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBwcm92aWRlZCBub2RlIGlzIGNvbnRhaW5lZCB3aXRoIHRoaXMgZWxlbWVudCdzXG4gICAgICogbGlnaHQtRE9NIGNoaWxkcmVuIG9yIHNoYWRvdyByb290LCBpbmNsdWRpbmcgYW55IG5lc3RlZCBzaGFkb3cgcm9vdHNcbiAgICAgKiBvZiBjaGlsZHJlbiB0aGVyZWluLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlIE5vZGUgdG8gdGVzdFxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gYG5vZGVgIGlzIGNvbnRhaW5lZCB3aXRoaW5cbiAgICAgKiAgIHRoaXMgZWxlbWVudCdzIGxpZ2h0IG9yIHNoYWRvdyBET00uXG4gICAgICovXG4gICAgZGVlcENvbnRhaW5zKG5vZGUpIHtcbiAgICAgIGlmICh0aGlzLm5vZGUuY29udGFpbnMobm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBsZXQgbiA9IG5vZGU7XG4gICAgICBsZXQgZG9jID0gbm9kZS5vd25lckRvY3VtZW50O1xuICAgICAgLy8gd2FsayBmcm9tIG5vZGUgdG8gYHRoaXNgIG9yIGBkb2N1bWVudGBcbiAgICAgIHdoaWxlIChuICYmIG4gIT09IGRvYyAmJiBuICE9PSB0aGlzLm5vZGUpIHtcbiAgICAgICAgLy8gdXNlIGxvZ2ljYWwgcGFyZW50bm9kZSwgb3IgbmF0aXZlIFNoYWRvd1Jvb3QgaG9zdFxuICAgICAgICBuID0gbi5wYXJlbnROb2RlIHx8IG4uaG9zdDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuID09PSB0aGlzLm5vZGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcm9vdCBub2RlIG9mIHRoaXMgbm9kZS4gIEVxdWl2YWxlbnQgdG8gYGdldFJvb2ROb2RlKClgLlxuICAgICAqXG4gICAgICogQHJldHVybiB7Tm9kZX0gVG9wIG1vc3QgZWxlbWVudCBpbiB0aGUgZG9tIHRyZWUgaW4gd2hpY2ggdGhlIG5vZGVcbiAgICAgKiBleGlzdHMuIElmIHRoZSBub2RlIGlzIGNvbm5lY3RlZCB0byBhIGRvY3VtZW50IHRoaXMgaXMgZWl0aGVyIGFcbiAgICAgKiBzaGFkb3dSb290IG9yIHRoZSBkb2N1bWVudDsgb3RoZXJ3aXNlLCBpdCBtYXkgYmUgdGhlIG5vZGVcbiAgICAgKiBpdHNlbGYgb3IgYSBub2RlIG9yIGRvY3VtZW50IGZyYWdtZW50IGNvbnRhaW5pbmcgaXQuXG4gICAgICovXG4gICAgZ2V0T3duZXJSb290KCkge1xuICAgICAgcmV0dXJuIHRoaXMubm9kZS5nZXRSb290Tm9kZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZvciBzbG90IGVsZW1lbnRzLCByZXR1cm5zIHRoZSBub2RlcyBhc3NpZ25lZCB0byB0aGUgc2xvdDsgb3RoZXJ3aXNlXG4gICAgICogYW4gZW1wdHkgYXJyYXkuIEl0IGlzIGVxdWl2YWxlbnQgdG8gYDxzbG90Pi5hZGRpZ25lZE5vZGVzKHtmbGF0dGVuOnRydWV9KWAuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtBcnJheTxOb2RlPn0gQXJyYXkgb2YgYXNzaWduZWQgbm9kZXNcbiAgICAgKi9cbiAgICBnZXREaXN0cmlidXRlZE5vZGVzKCkge1xuICAgICAgcmV0dXJuICh0aGlzLm5vZGUubG9jYWxOYW1lID09PSAnc2xvdCcpID9cbiAgICAgICAgdGhpcy5ub2RlLmFzc2lnbmVkTm9kZXMoe2ZsYXR0ZW46IHRydWV9KSA6XG4gICAgICAgIFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gYXJyYXkgb2YgYWxsIHNsb3RzIHRoaXMgZWxlbWVudCB3YXMgZGlzdHJpYnV0ZWQgdG8uXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtBcnJheTxIVE1MU2xvdEVsZW1lbnQ+fSBEZXNjcmlwdGlvblxuICAgICAqL1xuICAgIGdldERlc3RpbmF0aW9uSW5zZXJ0aW9uUG9pbnRzKCkge1xuICAgICAgbGV0IGlwJCA9IFtdO1xuICAgICAgbGV0IG4gPSB0aGlzLm5vZGUuYXNzaWduZWRTbG90O1xuICAgICAgd2hpbGUgKG4pIHtcbiAgICAgICAgaXAkLnB1c2gobik7XG4gICAgICAgIG4gPSBuLmFzc2lnbmVkU2xvdDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpcCQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbHMgYGltcG9ydE5vZGVgIG9uIHRoZSBgb3duZXJEb2N1bWVudGAgZm9yIHRoaXMgbm9kZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBOb2RlIHRvIGltcG9ydFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZGVlcCBUcnVlIGlmIHRoZSBub2RlIHNob3VsZCBiZSBjbG9uZWQgZGVlcGx5IGR1cmluZ1xuICAgICAqICAgaW1wb3J0XG4gICAgICogQHJldHVybiB7Tm9kZX0gQ2xvbmUgb2YgZ2l2ZW4gbm9kZSBpbXBvcnRlZCB0byB0aGlzIG93bmVyIGRvY3VtZW50XG4gICAgICovXG4gICAgaW1wb3J0Tm9kZShub2RlLCBkZWVwKSB7XG4gICAgICBsZXQgZG9jID0gdGhpcy5ub2RlIGluc3RhbmNlb2YgRG9jdW1lbnQgPyB0aGlzLm5vZGUgOlxuICAgICAgICB0aGlzLm5vZGUub3duZXJEb2N1bWVudDtcbiAgICAgIHJldHVybiBkb2MuaW1wb3J0Tm9kZShub2RlLCBkZWVwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gUmV0dXJucyBhIGZsYXR0ZW5lZCBsaXN0IG9mIGFsbCBjaGlsZCBub2RlcyBhbmQgbm9kZXMgYXNzaWduZWRcbiAgICAgKiB0byBjaGlsZCBzbG90cy5cbiAgICAgKi9cbiAgICBnZXRFZmZlY3RpdmVDaGlsZE5vZGVzKCkge1xuICAgICAgcmV0dXJuIFBvbHltZXIuRmxhdHRlbmVkTm9kZXNPYnNlcnZlci5nZXRGbGF0dGVuZWROb2Rlcyh0aGlzLm5vZGUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBmaWx0ZXJlZCBsaXN0IG9mIGZsYXR0ZW5lZCBjaGlsZCBlbGVtZW50cyBmb3IgdGhpcyBlbGVtZW50IGJhc2VkXG4gICAgICogb24gdGhlIGdpdmVuIHNlbGVjdG9yLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yIFNlbGVjdG9yIHRvIGZpbHRlciBub2RlcyBhZ2FpbnN0XG4gICAgICogQHJldHVybiB7QXJyYXk8SFRNTEVsZW1lbnQ+fSBMaXN0IG9mIGZsYXR0ZW5lZCBjaGlsZCBlbGVtZW50c1xuICAgICAqL1xuICAgIHF1ZXJ5RGlzdHJpYnV0ZWRFbGVtZW50cyhzZWxlY3Rvcikge1xuICAgICAgbGV0IGMkID0gdGhpcy5nZXRFZmZlY3RpdmVDaGlsZE5vZGVzKCk7XG4gICAgICBsZXQgbGlzdCA9IFtdO1xuICAgICAgZm9yIChsZXQgaT0wLCBsPWMkLmxlbmd0aCwgYzsgKGk8bCkgJiYgKGM9YyRbaV0pOyBpKyspIHtcbiAgICAgICAgaWYgKChjLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSkgJiZcbiAgICAgICAgICAgIG1hdGNoZXNTZWxlY3RvcihjLCBzZWxlY3RvcikpIHtcbiAgICAgICAgICBsaXN0LnB1c2goYyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBsaXN0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZvciBzaGFkb3cgcm9vdHMsIHJldHVybnMgdGhlIGN1cnJlbnRseSBmb2N1c2VkIGVsZW1lbnQgd2l0aGluIHRoaXNcbiAgICAgKiBzaGFkb3cgcm9vdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge05vZGV8dW5kZWZpbmVkfSBDdXJyZW50bHkgZm9jdXNlZCBlbGVtZW50XG4gICAgICovXG4gICAgZ2V0IGFjdGl2ZUVsZW1lbnQoKSB7XG4gICAgICBsZXQgbm9kZSA9IHRoaXMubm9kZTtcbiAgICAgIHJldHVybiBub2RlLl9hY3RpdmVFbGVtZW50ICE9PSB1bmRlZmluZWQgPyBub2RlLl9hY3RpdmVFbGVtZW50IDogbm9kZS5hY3RpdmVFbGVtZW50O1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcndhcmRNZXRob2RzKHByb3RvLCBtZXRob2RzKSB7XG4gICAgZm9yIChsZXQgaT0wOyBpIDwgbWV0aG9kcy5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IG1ldGhvZCA9IG1ldGhvZHNbaV07XG4gICAgICBwcm90b1ttZXRob2RdID0gLyoqIEB0aGlzIHtEb21BcGl9ICovIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ub2RlW21ldGhvZF0uYXBwbHkodGhpcy5ub2RlLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcndhcmRSZWFkT25seVByb3BlcnRpZXMocHJvdG8sIHByb3BlcnRpZXMpIHtcbiAgICBmb3IgKGxldCBpPTA7IGkgPCBwcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgbmFtZSA9IHByb3BlcnRpZXNbaV07XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG8sIG5hbWUsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gLyoqIEB0eXBlIHtEb21BcGl9ICovICh0aGlzKS5ub2RlW25hbWVdO1xuICAgICAgICB9LFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcndhcmRQcm9wZXJ0aWVzKHByb3RvLCBwcm9wZXJ0aWVzKSB7XG4gICAgZm9yIChsZXQgaT0wOyBpIDwgcHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IG5hbWUgPSBwcm9wZXJ0aWVzW2ldO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvLCBuYW1lLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIC8qKiBAdHlwZSB7RG9tQXBpfSAqLyAodGhpcykubm9kZVtuYW1lXTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgIC8qKiBAdHlwZSB7RG9tQXBpfSAqLyAodGhpcykubm9kZVtuYW1lXSA9IHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGZvcndhcmRNZXRob2RzKERvbUFwaS5wcm90b3R5cGUsIFtcbiAgICAnY2xvbmVOb2RlJywgJ2FwcGVuZENoaWxkJywgJ2luc2VydEJlZm9yZScsICdyZW1vdmVDaGlsZCcsXG4gICAgJ3JlcGxhY2VDaGlsZCcsICdzZXRBdHRyaWJ1dGUnLCAncmVtb3ZlQXR0cmlidXRlJyxcbiAgICAncXVlcnlTZWxlY3RvcicsICdxdWVyeVNlbGVjdG9yQWxsJ1xuICBdKTtcblxuICBmb3J3YXJkUmVhZE9ubHlQcm9wZXJ0aWVzKERvbUFwaS5wcm90b3R5cGUsIFtcbiAgICAncGFyZW50Tm9kZScsICdmaXJzdENoaWxkJywgJ2xhc3RDaGlsZCcsXG4gICAgJ25leHRTaWJsaW5nJywgJ3ByZXZpb3VzU2libGluZycsICdmaXJzdEVsZW1lbnRDaGlsZCcsXG4gICAgJ2xhc3RFbGVtZW50Q2hpbGQnLCAnbmV4dEVsZW1lbnRTaWJsaW5nJywgJ3ByZXZpb3VzRWxlbWVudFNpYmxpbmcnLFxuICAgICdjaGlsZE5vZGVzJywgJ2NoaWxkcmVuJywgJ2NsYXNzTGlzdCdcbiAgXSk7XG5cbiAgZm9yd2FyZFByb3BlcnRpZXMoRG9tQXBpLnByb3RvdHlwZSwgW1xuICAgICd0ZXh0Q29udGVudCcsICdpbm5lckhUTUwnXG4gIF0pO1xuXG5cbiAgLyoqXG4gICAqIEV2ZW50IEFQSSB3cmFwcGVyIGNsYXNzIHJldHVybmVkIGZyb20gYFBvbHltZXIuZG9tLih0YXJnZXQpYCB3aGVuXG4gICAqIGB0YXJnZXRgIGlzIGFuIGBFdmVudGAuXG4gICAqL1xuICBjbGFzcyBFdmVudEFwaSB7XG4gICAgY29uc3RydWN0b3IoZXZlbnQpIHtcbiAgICAgIHRoaXMuZXZlbnQgPSBldmVudDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBmaXJzdCBub2RlIG9uIHRoZSBgY29tcG9zZWRQYXRoYCBvZiB0aGlzIGV2ZW50LlxuICAgICAqXG4gICAgICogQHJldHVybiB7Tm9kZX0gVGhlIG5vZGUgdGhpcyBldmVudCB3YXMgZGlzcGF0Y2hlZCB0b1xuICAgICAqL1xuICAgIGdldCByb290VGFyZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuZXZlbnQuY29tcG9zZWRQYXRoKClbMF07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbG9jYWwgKHJlLXRhcmdldGVkKSB0YXJnZXQgZm9yIHRoaXMgZXZlbnQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtOb2RlfSBUaGUgbG9jYWwgKHJlLXRhcmdldGVkKSB0YXJnZXQgZm9yIHRoaXMgZXZlbnQuXG4gICAgICovXG4gICAgZ2V0IGxvY2FsVGFyZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuZXZlbnQudGFyZ2V0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGBjb21wb3NlZFBhdGhgIGZvciB0aGlzIGV2ZW50LlxuICAgICAqL1xuICAgIGdldCBwYXRoKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZXZlbnQuY29tcG9zZWRQYXRoKCk7XG4gICAgfVxuICB9XG5cbiAgUG9seW1lci5Eb21BcGkgPSBEb21BcGk7XG5cbiAgLyoqXG4gICAqIExlZ2FjeSBET00gYW5kIEV2ZW50IG1hbmlwdWxhdGlvbiBBUEkgd3JhcHBlciBmYWN0b3J5IHVzZWQgdG8gYWJzdHJhY3RcbiAgICogZGlmZmVyZW5jZXMgYmV0d2VlbiBuYXRpdmUgU2hhZG93IERPTSBhbmQgXCJTaGFkeSBET01cIiB3aGVuIHBvbHlmaWxsaW5nIG9uXG4gICAqIG9sZGVyIGJyb3dzZXJzLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgaW4gUG9seW1lciAyLnggdXNlIG9mIGBQb2x5bWVyLmRvbWAgaXMgbm8gbG9uZ2VyIHJlcXVpcmVkIGFuZFxuICAgKiBpbiB0aGUgbWFqb3JpdHkgb2YgY2FzZXMgc2ltcGx5IGZhY2FkZXMgZGlyZWN0bHkgdG8gdGhlIHN0YW5kYXJkIG5hdGl2ZVxuICAgKiBBUEkuXG4gICAqXG4gICAqIEBuYW1lc3BhY2VcbiAgICogQHN1bW1hcnkgTGVnYWN5IERPTSBhbmQgRXZlbnQgbWFuaXB1bGF0aW9uIEFQSSB3cmFwcGVyIGZhY3RvcnkgdXNlZCB0b1xuICAgKiBhYnN0cmFjdCBkaWZmZXJlbmNlcyBiZXR3ZWVuIG5hdGl2ZSBTaGFkb3cgRE9NIGFuZCBcIlNoYWR5IERPTS5cIlxuICAgKiBAbWVtYmVyb2YgUG9seW1lclxuICAgKiBAcGFyYW0geyFOb2RlfEV2ZW50fSBvYmogTm9kZSBvciBldmVudCB0byBvcGVyYXRlIG9uXG4gICAqIEByZXR1cm4ge0RvbUFwaXxFdmVudEFwaX0gV3JhcHBlciBwcm92aWRpbmcgZWl0aGVyIG5vZGUgQVBJIG9yIGV2ZW50IEFQSVxuICAgKi9cbiAgUG9seW1lci5kb20gPSBmdW5jdGlvbihvYmopIHtcbiAgICBvYmogPSBvYmogfHwgZG9jdW1lbnQ7XG4gICAgaWYgKCFvYmouX19kb21BcGkpIHtcbiAgICAgIGxldCBoZWxwZXI7XG4gICAgICBpZiAob2JqIGluc3RhbmNlb2YgRXZlbnQpIHtcbiAgICAgICAgaGVscGVyID0gbmV3IEV2ZW50QXBpKG9iaik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoZWxwZXIgPSBuZXcgRG9tQXBpKG9iaik7XG4gICAgICB9XG4gICAgICBvYmouX19kb21BcGkgPSBoZWxwZXI7XG4gICAgfVxuICAgIHJldHVybiBvYmouX19kb21BcGk7XG4gIH07XG5cbiAgUG9seW1lci5kb20ubWF0Y2hlc1NlbGVjdG9yID0gbWF0Y2hlc1NlbGVjdG9yO1xuXG4gIC8qKlxuICAgKiBGb3JjZXMgc2V2ZXJhbCBjbGFzc2VzIG9mIGFzeW5jaHJvbm91c2x5IHF1ZXVlZCB0YXNrcyB0byBmbHVzaDpcbiAgICogLSBEZWJvdW5jZXJzIGFkZGVkIHZpYSBgUG9seW1lci5lbnF1ZXVlRGVib3VuY2VyYFxuICAgKiAtIFNoYWR5RE9NIGRpc3RyaWJ1dGlvblxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBmYWNhZGVzIHRvIGBQb2x5bWVyLmZsdXNoYC5cbiAgICpcbiAgICogQG1lbWJlcm9mIFBvbHltZXIuZG9tXG4gICAqL1xuICBQb2x5bWVyLmRvbS5mbHVzaCA9IFBvbHltZXIuZmx1c2g7XG5cbiAgLyoqXG4gICAqIEFkZHMgYSBgUG9seW1lci5EZWJvdW5jZXJgIHRvIGEgbGlzdCBvZiBnbG9iYWxseSBmbHVzaGFibGUgdGFza3MuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGZhY2FkZXMgdG8gYFBvbHltZXIuZW5xdWV1ZURlYm91bmNlcmAuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBQb2x5bWVyLmRvbVxuICAgKiBAcGFyYW0ge1BvbHltZXIuRGVib3VuY2VyfSBkZWJvdW5jZXIgRGVib3VuY2VyIHRvIGVucXVldWVcbiAgICovXG4gIFBvbHltZXIuZG9tLmFkZERlYm91bmNlciA9IFBvbHltZXIuZW5xdWV1ZURlYm91bmNlcjtcbn0pKCk7XG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvbGVnYWN5L3BvbHltZXIuZG9tLmh0bWwiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vdXRpbHMvYm9vdC5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vdXRpbHMvYXJyYXktc3BsaWNlLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi91dGlscy9hc3luYy5odG1sXCI+XG48c2NyaXB0PlxuKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBgbm9kZWAgaXMgYSBzbG90IGVsZW1lbnRcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gbm9kZSBOb2RlIHRvIHRlc3QuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gYG5vZGVgIGlzIGEgc2xvdFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gaXNTbG90KG5vZGUpIHtcbiAgICByZXR1cm4gKG5vZGUubG9jYWxOYW1lID09PSAnc2xvdCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIENsYXNzIHRoYXQgbGlzdGVucyBmb3IgY2hhbmdlcyAoYWRkaXRpb25zIG9yIHJlbW92YWxzKSB0b1xuICAgKiBcImZsYXR0ZW5lZCBub2Rlc1wiIG9uIGEgZ2l2ZW4gYG5vZGVgLiBUaGUgbGlzdCBvZiBmbGF0dGVuZWQgbm9kZXMgY29uc2lzdHNcbiAgICogb2YgYSBub2RlJ3MgY2hpbGRyZW4gYW5kLCBmb3IgYW55IGNoaWxkcmVuIHRoYXQgYXJlIGA8c2xvdD5gIGVsZW1lbnRzLFxuICAgKiB0aGUgZXhwYW5kZWQgZmxhdHRlbmVkIGxpc3Qgb2YgYGFzc2lnbmVkTm9kZXNgLlxuICAgKiBGb3IgZXhhbXBsZSwgaWYgdGhlIG9ic2VydmVkIG5vZGUgaGFzIGNoaWxkcmVuIGA8YT48L2E+PHNsb3Q+PC9zbG90PjxiPjwvYj5gXG4gICAqIGFuZCB0aGUgYDxzbG90PmAgaGFzIG9uZSBgPGRpdj5gIGFzc2lnbmVkIHRvIGl0LCB0aGVuIHRoZSBmbGF0dGVuZWRcbiAgICogbm9kZXMgbGlzdCBpcyBgPGE+PC9hPjxkaXY+PC9kaXY+PGI+PC9iPmAuIElmIHRoZSBgPHNsb3Q+YCBoYXMgb3RoZXJcbiAgICogYDxzbG90PmAgZWxlbWVudHMgYXNzaWduZWQgdG8gaXQsIHRoZXNlIGFyZSBmbGF0dGVuZWQgYXMgd2VsbC5cbiAgICpcbiAgICogVGhlIHByb3ZpZGVkIGBjYWxsYmFja2AgaXMgY2FsbGVkIHdoZW5ldmVyIGFueSBjaGFuZ2UgdG8gdGhpcyBsaXN0XG4gICAqIG9mIGZsYXR0ZW5lZCBub2RlcyBvY2N1cnMsIHdoZXJlIGFuIGFkZGl0aW9uIG9yIHJlbW92YWwgb2YgYSBub2RlIGlzXG4gICAqIGNvbnNpZGVyZWQgYSBjaGFuZ2UuIFRoZSBgY2FsbGJhY2tgIGlzIGNhbGxlZCB3aXRoIG9uZSBhcmd1bWVudCwgYW4gb2JqZWN0XG4gICAqIGNvbnRhaW5pbmcgYW4gYXJyYXkgb2YgYW55IGBhZGRlZE5vZGVzYCBhbmQgYHJlbW92ZWROb2Rlc2AuXG4gICAqXG4gICAqIE5vdGU6IHRoZSBjYWxsYmFjayBpcyBjYWxsZWQgYXN5bmNocm9ub3VzIHRvIGFueSBjaGFuZ2VzXG4gICAqIGF0IGEgbWljcm90YXNrIGNoZWNrcG9pbnQuIFRoaXMgaXMgYmVjYXVzZSBvYnNlcnZhdGlvbiBpcyBwZXJmb3JtZWQgdXNpbmdcbiAgICogYE11dGF0aW9uT2JzZXJ2ZXJgIGFuZCB0aGUgYDxzbG90PmAgZWxlbWVudCdzIGBzbG90Y2hhbmdlYCBldmVudCB3aGljaFxuICAgKiBhcmUgYXN5bmNocm9ub3VzLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgUG9seW1lclxuICAgKiBAc3VtbWFyeSBDbGFzcyB0aGF0IGxpc3RlbnMgZm9yIGNoYW5nZXMgKGFkZGl0aW9ucyBvciByZW1vdmFscykgdG9cbiAgICogXCJmbGF0dGVuZWQgbm9kZXNcIiBvbiBhIGdpdmVuIGBub2RlYC5cbiAgICovXG4gIGNsYXNzIEZsYXR0ZW5lZE5vZGVzT2JzZXJ2ZXIge1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbGlzdCBvZiBmbGF0dGVuZWQgbm9kZXMgZm9yIHRoZSBnaXZlbiBgbm9kZWAuXG4gICAgICogVGhpcyBsaXN0IGNvbnNpc3RzIG9mIGEgbm9kZSdzIGNoaWxkcmVuIGFuZCwgZm9yIGFueSBjaGlsZHJlblxuICAgICAqIHRoYXQgYXJlIGA8c2xvdD5gIGVsZW1lbnRzLCB0aGUgZXhwYW5kZWQgZmxhdHRlbmVkIGxpc3Qgb2YgYGFzc2lnbmVkTm9kZXNgLlxuICAgICAqIEZvciBleGFtcGxlLCBpZiB0aGUgb2JzZXJ2ZWQgbm9kZSBoYXMgY2hpbGRyZW4gYDxhPjwvYT48c2xvdD48L3Nsb3Q+PGI+PC9iPmBcbiAgICAgKiBhbmQgdGhlIGA8c2xvdD5gIGhhcyBvbmUgYDxkaXY+YCBhc3NpZ25lZCB0byBpdCwgdGhlbiB0aGUgZmxhdHRlbmVkXG4gICAgICogbm9kZXMgbGlzdCBpcyBgPGE+PC9hPjxkaXY+PC9kaXY+PGI+PC9iPmAuIElmIHRoZSBgPHNsb3Q+YCBoYXMgb3RoZXJcbiAgICAgKiBgPHNsb3Q+YCBlbGVtZW50cyBhc3NpZ25lZCB0byBpdCwgdGhlc2UgYXJlIGZsYXR0ZW5lZCBhcyB3ZWxsLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudHxIVE1MU2xvdEVsZW1lbnR9IG5vZGUgVGhlIG5vZGUgZm9yIHdoaWNoIHRvIHJldHVybiB0aGUgbGlzdCBvZiBmbGF0dGVuZWQgbm9kZXMuXG4gICAgICogQHJldHVybiB7QXJyYXl9IFRoZSBsaXN0IG9mIGZsYXR0ZW5lZCBub2RlcyBmb3IgdGhlIGdpdmVuIGBub2RlYC5cbiAgICAqL1xuICAgIHN0YXRpYyBnZXRGbGF0dGVuZWROb2Rlcyhub2RlKSB7XG4gICAgICBpZiAoaXNTbG90KG5vZGUpKSB7XG4gICAgICAgIHJldHVybiAvKiogQHR5cGUge0hUTUxTbG90RWxlbWVudH0gKi8gKG5vZGUpLmFzc2lnbmVkTm9kZXMoe2ZsYXR0ZW46IHRydWV9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKG5vZGUuY2hpbGROb2RlcykubWFwKG5vZGUgPT4ge1xuICAgICAgICAgIGlmIChpc1Nsb3Qobm9kZSkpIHtcbiAgICAgICAgICAgIHJldHVybiAvKiogQHR5cGUge0hUTUxTbG90RWxlbWVudH0gKi8gKG5vZGUpLmFzc2lnbmVkTm9kZXMoe2ZsYXR0ZW46IHRydWV9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFtub2RlXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pLnJlZHVjZSgoYSwgYikgPT4gYS5jb25jYXQoYiksIFtdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge05vZGV9IHRhcmdldCBOb2RlIG9uIHdoaWNoIHRvIGxpc3RlbiBmb3IgY2hhbmdlcy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBGdW5jdGlvbiBjYWxsZWQgd2hlbiB0aGVyZSBhcmUgYWRkaXRpb25zXG4gICAgICogb3IgcmVtb3ZhbHMgZnJvbSB0aGUgdGFyZ2V0J3MgbGlzdCBvZiBmbGF0dGVuZWQgbm9kZXMuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXQsIGNhbGxiYWNrKSB7XG4gICAgICAvKiogQHR5cGUge011dGF0aW9uT2JzZXJ2ZXJ9ICovXG4gICAgICB0aGlzLl9zaGFkeUNoaWxkcmVuT2JzZXJ2ZXIgPSBudWxsO1xuICAgICAgLyoqIEB0eXBlIHtNdXRhdGlvbk9ic2VydmVyfSAqL1xuICAgICAgdGhpcy5fbmF0aXZlQ2hpbGRyZW5PYnNlcnZlciA9IG51bGw7XG4gICAgICB0aGlzLl9jb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuX3RhcmdldCA9IHRhcmdldDtcbiAgICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgIHRoaXMuX2VmZmVjdGl2ZU5vZGVzID0gW107XG4gICAgICB0aGlzLl9vYnNlcnZlciA9IG51bGw7XG4gICAgICB0aGlzLl9zY2hlZHVsZWQgPSBmYWxzZTtcbiAgICAgIC8qKiBAdHlwZSB7ZnVuY3Rpb24oKX0gKi9cbiAgICAgIHRoaXMuX2JvdW5kU2NoZWR1bGUgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMuX3NjaGVkdWxlKCk7XG4gICAgICB9XG4gICAgICB0aGlzLmNvbm5lY3QoKTtcbiAgICAgIHRoaXMuX3NjaGVkdWxlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWN0aXZhdGVzIGFuIG9ic2VydmVyLiBUaGlzIG1ldGhvZCBpcyBhdXRvbWF0aWNhbGx5IGNhbGxlZCB3aGVuXG4gICAgICogYSBgRmxhdHRlbmVkTm9kZXNPYnNlcnZlcmAgaXMgY3JlYXRlZC4gSXQgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIHRvXG4gICAgICogcmUtYWN0aXZhdGUgYW4gb2JzZXJ2ZXIgdGhhdCBoYXMgYmVlbiBkZWFjdGl2YXRlZCB2aWEgdGhlIGBkaXNjb25uZWN0YCBtZXRob2QuXG4gICAgICovXG4gICAgY29ubmVjdCgpIHtcbiAgICAgIGlmIChpc1Nsb3QodGhpcy5fdGFyZ2V0KSkge1xuICAgICAgICB0aGlzLl9saXN0ZW5TbG90cyhbdGhpcy5fdGFyZ2V0XSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9saXN0ZW5TbG90cyh0aGlzLl90YXJnZXQuY2hpbGRyZW4pO1xuICAgICAgICBpZiAod2luZG93LlNoYWR5RE9NKSB7XG4gICAgICAgICAgdGhpcy5fc2hhZHlDaGlsZHJlbk9ic2VydmVyID1cbiAgICAgICAgICAgIFNoYWR5RE9NLm9ic2VydmVDaGlsZHJlbih0aGlzLl90YXJnZXQsIChtdXRhdGlvbnMpID0+IHtcbiAgICAgICAgICAgICAgdGhpcy5fcHJvY2Vzc011dGF0aW9ucyhtdXRhdGlvbnMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fbmF0aXZlQ2hpbGRyZW5PYnNlcnZlciA9XG4gICAgICAgICAgICBuZXcgTXV0YXRpb25PYnNlcnZlcigobXV0YXRpb25zKSA9PiB7XG4gICAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3NNdXRhdGlvbnMobXV0YXRpb25zKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIHRoaXMuX25hdGl2ZUNoaWxkcmVuT2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLl90YXJnZXQsIHtjaGlsZExpc3Q6IHRydWV9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5fY29ubmVjdGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWFjdGl2YXRlcyB0aGUgZmxhdHRlbmVkIG5vZGVzIG9ic2VydmVyLiBBZnRlciBjYWxsaW5nIHRoaXMgbWV0aG9kXG4gICAgICogdGhlIG9ic2VydmVyIGNhbGxiYWNrIHdpbGwgbm90IGJlIGNhbGxlZCB3aGVuIGNoYW5nZXMgdG8gZmxhdHRlbmVkIG5vZGVzXG4gICAgICogb2NjdXIuIFRoZSBgY29ubmVjdGAgbWV0aG9kIG1heSBiZSBzdWJzZXF1ZW50bHkgY2FsbGVkIHRvIHJlYWN0aXZhdGVcbiAgICAgKiB0aGUgb2JzZXJ2ZXIuXG4gICAgICovXG4gICAgZGlzY29ubmVjdCgpIHtcbiAgICAgIGlmIChpc1Nsb3QodGhpcy5fdGFyZ2V0KSkge1xuICAgICAgICB0aGlzLl91bmxpc3RlblNsb3RzKFt0aGlzLl90YXJnZXRdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3VubGlzdGVuU2xvdHModGhpcy5fdGFyZ2V0LmNoaWxkcmVuKTtcbiAgICAgICAgaWYgKHdpbmRvdy5TaGFkeURPTSAmJiB0aGlzLl9zaGFkeUNoaWxkcmVuT2JzZXJ2ZXIpIHtcbiAgICAgICAgICBTaGFkeURPTS51bm9ic2VydmVDaGlsZHJlbih0aGlzLl9zaGFkeUNoaWxkcmVuT2JzZXJ2ZXIpO1xuICAgICAgICAgIHRoaXMuX3NoYWR5Q2hpbGRyZW5PYnNlcnZlciA9IG51bGw7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fbmF0aXZlQ2hpbGRyZW5PYnNlcnZlcikge1xuICAgICAgICAgIHRoaXMuX25hdGl2ZUNoaWxkcmVuT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICAgIHRoaXMuX25hdGl2ZUNoaWxkcmVuT2JzZXJ2ZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLl9jb25uZWN0ZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBfc2NoZWR1bGUoKSB7XG4gICAgICBpZiAoIXRoaXMuX3NjaGVkdWxlZCkge1xuICAgICAgICB0aGlzLl9zY2hlZHVsZWQgPSB0cnVlO1xuICAgICAgICBQb2x5bWVyLkFzeW5jLm1pY3JvVGFzay5ydW4oKCkgPT4gdGhpcy5mbHVzaCgpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfcHJvY2Vzc011dGF0aW9ucyhtdXRhdGlvbnMpIHtcbiAgICAgIHRoaXMuX3Byb2Nlc3NTbG90TXV0YXRpb25zKG11dGF0aW9ucyk7XG4gICAgICB0aGlzLmZsdXNoKCk7XG4gICAgfVxuXG4gICAgX3Byb2Nlc3NTbG90TXV0YXRpb25zKG11dGF0aW9ucykge1xuICAgICAgaWYgKG11dGF0aW9ucykge1xuICAgICAgICBmb3IgKGxldCBpPTA7IGkgPCBtdXRhdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBsZXQgbXV0YXRpb24gPSBtdXRhdGlvbnNbaV07XG4gICAgICAgICAgaWYgKG11dGF0aW9uLmFkZGVkTm9kZXMpIHtcbiAgICAgICAgICAgIHRoaXMuX2xpc3RlblNsb3RzKG11dGF0aW9uLmFkZGVkTm9kZXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobXV0YXRpb24ucmVtb3ZlZE5vZGVzKSB7XG4gICAgICAgICAgICB0aGlzLl91bmxpc3RlblNsb3RzKG11dGF0aW9uLnJlbW92ZWROb2Rlcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmx1c2hlcyB0aGUgb2JzZXJ2ZXIgY2F1c2luZyBhbnkgcGVuZGluZyBjaGFuZ2VzIHRvIGJlIGltbWVkaWF0ZWx5XG4gICAgICogZGVsaXZlcmVkIHRoZSBvYnNlcnZlciBjYWxsYmFjay4gQnkgZGVmYXVsdCB0aGVzZSBjaGFuZ2VzIGFyZSBkZWxpdmVyZWRcbiAgICAgKiBhc3luY2hyb25vdXNseSBhdCB0aGUgbmV4dCBtaWNyb3Rhc2sgY2hlY2twb2ludC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiBhbnkgcGVuZGluZyBjaGFuZ2VzIGNhdXNlZCB0aGUgb2JzZXJ2ZXJcbiAgICAgKiBjYWxsYmFjayB0byBydW4uXG4gICAgICovXG4gICAgZmx1c2goKSB7XG4gICAgICBpZiAoIXRoaXMuX2Nvbm5lY3RlZCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAod2luZG93LlNoYWR5RE9NKSB7XG4gICAgICAgIFNoYWR5RE9NLmZsdXNoKCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fbmF0aXZlQ2hpbGRyZW5PYnNlcnZlcikge1xuICAgICAgICB0aGlzLl9wcm9jZXNzU2xvdE11dGF0aW9ucyh0aGlzLl9uYXRpdmVDaGlsZHJlbk9ic2VydmVyLnRha2VSZWNvcmRzKCkpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl9zaGFkeUNoaWxkcmVuT2JzZXJ2ZXIpIHtcbiAgICAgICAgdGhpcy5fcHJvY2Vzc1Nsb3RNdXRhdGlvbnModGhpcy5fc2hhZHlDaGlsZHJlbk9ic2VydmVyLnRha2VSZWNvcmRzKCkpO1xuICAgICAgfVxuICAgICAgdGhpcy5fc2NoZWR1bGVkID0gZmFsc2U7XG4gICAgICBsZXQgaW5mbyA9IHtcbiAgICAgICAgdGFyZ2V0OiB0aGlzLl90YXJnZXQsXG4gICAgICAgIGFkZGVkTm9kZXM6IFtdLFxuICAgICAgICByZW1vdmVkTm9kZXM6IFtdXG4gICAgICB9O1xuICAgICAgbGV0IG5ld05vZGVzID0gdGhpcy5jb25zdHJ1Y3Rvci5nZXRGbGF0dGVuZWROb2Rlcyh0aGlzLl90YXJnZXQpO1xuICAgICAgbGV0IHNwbGljZXMgPSBQb2x5bWVyLkFycmF5U3BsaWNlLmNhbGN1bGF0ZVNwbGljZXMobmV3Tm9kZXMsXG4gICAgICAgIHRoaXMuX2VmZmVjdGl2ZU5vZGVzKTtcbiAgICAgIC8vIHByb2Nlc3MgcmVtb3ZhbHNcbiAgICAgIGZvciAobGV0IGk9MCwgczsgKGk8c3BsaWNlcy5sZW5ndGgpICYmIChzPXNwbGljZXNbaV0pOyBpKyspIHtcbiAgICAgICAgZm9yIChsZXQgaj0wLCBuOyAoaiA8IHMucmVtb3ZlZC5sZW5ndGgpICYmIChuPXMucmVtb3ZlZFtqXSk7IGorKykge1xuICAgICAgICAgIGluZm8ucmVtb3ZlZE5vZGVzLnB1c2gobik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIHByb2Nlc3MgYWRkc1xuICAgICAgZm9yIChsZXQgaT0wLCBzOyAoaTxzcGxpY2VzLmxlbmd0aCkgJiYgKHM9c3BsaWNlc1tpXSk7IGkrKykge1xuICAgICAgICBmb3IgKGxldCBqPXMuaW5kZXg7IGogPCBzLmluZGV4ICsgcy5hZGRlZENvdW50OyBqKyspIHtcbiAgICAgICAgICBpbmZvLmFkZGVkTm9kZXMucHVzaChuZXdOb2Rlc1tqXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIHVwZGF0ZSBjYWNoZVxuICAgICAgdGhpcy5fZWZmZWN0aXZlTm9kZXMgPSBuZXdOb2RlcztcbiAgICAgIGxldCBkaWRGbHVzaCA9IGZhbHNlO1xuICAgICAgaWYgKGluZm8uYWRkZWROb2Rlcy5sZW5ndGggfHwgaW5mby5yZW1vdmVkTm9kZXMubGVuZ3RoKSB7XG4gICAgICAgIGRpZEZsdXNoID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jYWxsYmFjay5jYWxsKHRoaXMuX3RhcmdldCwgaW5mbyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGlkRmx1c2g7XG4gICAgfVxuXG4gICAgX2xpc3RlblNsb3RzKG5vZGVMaXN0KSB7XG4gICAgICBmb3IgKGxldCBpPTA7IGkgPCBub2RlTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgbiA9IG5vZGVMaXN0W2ldO1xuICAgICAgICBpZiAoaXNTbG90KG4pKSB7XG4gICAgICAgICAgbi5hZGRFdmVudExpc3RlbmVyKCdzbG90Y2hhbmdlJywgdGhpcy5fYm91bmRTY2hlZHVsZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBfdW5saXN0ZW5TbG90cyhub2RlTGlzdCkge1xuICAgICAgZm9yIChsZXQgaT0wOyBpIDwgbm9kZUxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IG4gPSBub2RlTGlzdFtpXTtcbiAgICAgICAgaWYgKGlzU2xvdChuKSkge1xuICAgICAgICAgIG4ucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2xvdGNoYW5nZScsIHRoaXMuX2JvdW5kU2NoZWR1bGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gIH1cblxuICBQb2x5bWVyLkZsYXR0ZW5lZE5vZGVzT2JzZXJ2ZXIgPSBGbGF0dGVuZWROb2Rlc09ic2VydmVyO1xuXG59KSgpO1xuPC9zY3JpcHQ+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL3BvbHltZXIvbGliL3V0aWxzL2ZsYXR0ZW5lZC1ub2Rlcy1vYnNlcnZlci5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuXG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiY2xhc3MuaHRtbFwiPlxuXG48c2NyaXB0PlxuXG4gIChmdW5jdGlvbigpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICAvKipcbiAgICAgKiBMZWdhY3kgY2xhc3MgZmFjdG9yeSBhbmQgcmVnaXN0cmF0aW9uIGhlbHBlciBmb3IgZGVmaW5pbmcgUG9seW1lclxuICAgICAqIGVsZW1lbnRzLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgaXMgZXF1aXZhbGVudCB0b1xuICAgICAqIGBjdXN0b21FbGVtZW50cy5kZWZpbmUoaW5mby5pcywgUG9seW1lci5DbGFzcyhpbmZvKSk7YFxuICAgICAqXG4gICAgICogU2VlIGBQb2x5bWVyLkNsYXNzYCBmb3IgZGV0YWlscyBvbiB2YWxpZCBsZWdhY3kgbWV0YWRhdGEgZm9ybWF0IGZvciBgaW5mb2AuXG4gICAgICpcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKiBAZnVuY3Rpb24gUG9seW1lclxuICAgICAqIEBwYXJhbSB7IVBvbHltZXJJbml0fSBpbmZvIE9iamVjdCBjb250YWluaW5nIFBvbHltZXIgbWV0YWRhdGEgYW5kIGZ1bmN0aW9uc1xuICAgICAqICAgdG8gYmVjb21lIGNsYXNzIG1ldGhvZHMuXG4gICAgICogQHJldHVybiB7IUhUTUxFbGVtZW50fSBHZW5lcmF0ZWQgY2xhc3NcbiAgICAgKiBAc3VwcHJlc3Mge2R1cGxpY2F0ZSwgaW52YWxpZENhc3RzLCBjaGVja1R5cGVzfVxuICAgICAqL1xuICAgIHdpbmRvdy5Qb2x5bWVyLl9wb2x5bWVyRm4gPSBmdW5jdGlvbihpbmZvKSB7XG4gICAgICAvLyBpZiBpbnB1dCBpcyBhIGBjbGFzc2AgKGFrYSBhIGZ1bmN0aW9uIHdpdGggYSBwcm90b3R5cGUpLCB1c2UgdGhlIHByb3RvdHlwZVxuICAgICAgLy8gcmVtZW1iZXIgdGhhdCB0aGUgYGNvbnN0cnVjdG9yYCB3aWxsIG5ldmVyIGJlIGNhbGxlZFxuICAgICAgbGV0IGtsYXNzO1xuICAgICAgaWYgKHR5cGVvZiBpbmZvID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGtsYXNzID0gaW5mbztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGtsYXNzID0gUG9seW1lci5DbGFzcyhpbmZvKTtcbiAgICAgIH1cbiAgICAgIGN1c3RvbUVsZW1lbnRzLmRlZmluZShrbGFzcy5pcywgLyoqIEB0eXBlIHshSFRNTEVsZW1lbnR9ICovKGtsYXNzKSk7XG4gICAgICByZXR1cm4ga2xhc3M7XG4gICAgfTtcblxuICB9KSgpO1xuXG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvbGVnYWN5L3BvbHltZXItZm4uaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCJsZWdhY3ktZWxlbWVudC1taXhpbi5odG1sXCI+XG48c2NyaXB0PlxuXG4gIChmdW5jdGlvbigpIHtcblxuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGxldCBtZXRhUHJvcHMgPSB7XG4gICAgICBhdHRhY2hlZDogdHJ1ZSxcbiAgICAgIGRldGFjaGVkOiB0cnVlLFxuICAgICAgcmVhZHk6IHRydWUsXG4gICAgICBjcmVhdGVkOiB0cnVlLFxuICAgICAgYmVmb3JlUmVnaXN0ZXI6IHRydWUsXG4gICAgICByZWdpc3RlcmVkOiB0cnVlLFxuICAgICAgYXR0cmlidXRlQ2hhbmdlZDogdHJ1ZSxcbiAgICAgIC8vIG1ldGEgb2JqZWN0c1xuICAgICAgYmVoYXZpb3JzOiB0cnVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXBwbGllcyBhIFwibGVnYWN5XCIgYmVoYXZpb3Igb3IgYXJyYXkgb2YgYmVoYXZpb3JzIHRvIHRoZSBwcm92aWRlZCBjbGFzcy5cbiAgICAgKlxuICAgICAqIE5vdGU6IHRoaXMgbWV0aG9kIHdpbGwgYXV0b21hdGljYWxseSBhbHNvIGFwcGx5IHRoZSBgUG9seW1lci5MZWdhY3lFbGVtZW50TWl4aW5gXG4gICAgICogdG8gZW5zdXJlIHRoYXQgYW55IGxlZ2FjeSBiZWhhdmlvcnMgY2FuIHJlbHkgb24gbGVnYWN5IFBvbHltZXIgQVBJIG9uXG4gICAgICogdGhlIHVuZGVybHlpbmcgZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IShPYmplY3R8QXJyYXkpfSBiZWhhdmlvcnMgQmVoYXZpb3Igb2JqZWN0IG9yIGFycmF5IG9mIGJlaGF2aW9ycy5cbiAgICAgKiBAcGFyYW0geyFIVE1MRWxlbWVudHxmdW5jdGlvbihuZXc6SFRNTEVsZW1lbnQpfSBrbGFzcyBFbGVtZW50IGNsYXNzLlxuICAgICAqIEByZXR1cm4ge2Z1bmN0aW9uKG5ldzpIVE1MRWxlbWVudCl9IFJldHVybnMgYSBuZXcgRWxlbWVudCBjbGFzcyBleHRlbmRlZCBieSB0aGVcbiAgICAgKiBwYXNzZWQgaW4gYGJlaGF2aW9yc2AgYW5kIGFsc28gYnkgYFBvbHltZXIuTGVnYWN5RWxlbWVudE1peGluYC5cbiAgICAgKiBAbWVtYmVyb2YgUG9seW1lclxuICAgICAqIEBzdXBwcmVzcyB7aW52YWxpZENhc3RzLCBjaGVja1R5cGVzfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1peGluQmVoYXZpb3JzKGJlaGF2aW9ycywga2xhc3MpIHtcbiAgICAgIGlmICghYmVoYXZpb3JzKSB7XG4gICAgICAgIHJldHVybiAvKiogQHR5cGUge0hUTUxFbGVtZW50fSAqLyhrbGFzcyk7XG4gICAgICB9XG4gICAgICAvLyBOT1RFOiBlbnN1cmUgdGhlIGJhaGV2aW9yIGlzIGV4dGVuZGluZyBhIGNsYXNzIHdpdGhcbiAgICAgIC8vIGxlZ2FjeSBlbGVtZW50IGFwaS4gVGhpcyBpcyBuZWNlc3Nhcnkgc2luY2UgYmVoYXZpb3JzIGV4cGVjdCB0byBiZSBhYmxlXG4gICAgICAvLyB0byBhY2Nlc3MgMS54IGxlZ2FjeSBhcGkuXG4gICAgICBrbGFzcyA9IFBvbHltZXIuTGVnYWN5RWxlbWVudE1peGluKGtsYXNzKTtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShiZWhhdmlvcnMpKSB7XG4gICAgICAgIGJlaGF2aW9ycyA9IFtiZWhhdmlvcnNdO1xuICAgICAgfVxuICAgICAgbGV0IHN1cGVyQmVoYXZpb3JzID0ga2xhc3MucHJvdG90eXBlLmJlaGF2aW9ycztcbiAgICAgIC8vIGdldCBmbGF0dGVuZWQsIGRlZHVwZWQgbGlzdCBvZiBiZWhhdmlvcnMgKm5vdCogYWxyZWFkeSBvbiBzdXBlciBjbGFzc1xuICAgICAgYmVoYXZpb3JzID0gZmxhdHRlbkJlaGF2aW9ycyhiZWhhdmlvcnMsIG51bGwsIHN1cGVyQmVoYXZpb3JzKTtcbiAgICAgIC8vIG1peGluIG5ldyBiZWhhdmlvcnNcbiAgICAgIGtsYXNzID0gX21peGluQmVoYXZpb3JzKGJlaGF2aW9ycywga2xhc3MpO1xuICAgICAgaWYgKHN1cGVyQmVoYXZpb3JzKSB7XG4gICAgICAgIGJlaGF2aW9ycyA9IHN1cGVyQmVoYXZpb3JzLmNvbmNhdChiZWhhdmlvcnMpO1xuICAgICAgfVxuICAgICAgLy8gU2V0IGJlaGF2aW9ycyBvbiBwcm90b3R5cGUgZm9yIEJDLi4uXG4gICAgICBrbGFzcy5wcm90b3R5cGUuYmVoYXZpb3JzID0gYmVoYXZpb3JzO1xuICAgICAgcmV0dXJuIGtsYXNzO1xuICAgIH1cblxuICAgIC8vIE5PVEU6XG4gICAgLy8gMS54XG4gICAgLy8gQmVoYXZpb3JzIHdlcmUgbWl4ZWQgaW4gKmluIHJldmVyc2Ugb3JkZXIqIGFuZCBkZS1kdXBlZCBvbiB0aGUgZmx5LlxuICAgIC8vIFRoZSBydWxlIHdhcyB0aGF0IGJlaGF2aW9yIHByb3BlcnRpZXMgd2VyZSBjb3BpZWQgb250byB0aGUgZWxlbWVudFxuICAgIC8vIHByb3RvdHlwZSBpZiBhbmQgb25seSBpZiB0aGUgcHJvcGVydHkgZGlkIG5vdCBhbHJlYWR5IGV4aXN0LlxuICAgIC8vIEdpdmVuOiBQb2x5bWVyeyBiZWhhdmlvcnM6IFtBLCBCLCBDLCBBLCBCXX0sIHByb3BlcnR5IGNvcHkgb3JkZXIgd2FzOlxuICAgIC8vICgxKSwgQiwgKDIpLCBBLCAoMykgQy4gVGhpcyBtZWFucyBwcm90b3R5cGUgcHJvcGVydGllcyB3aW4gb3ZlclxuICAgIC8vIEIgcHJvcGVydGllcyB3aW4gb3ZlciBBIHdpbiBvdmVyIEMuIFRoaXMgbWlycm9ycyB3aGF0IHdvdWxkIGhhcHBlblxuICAgIC8vIHdpdGggaW5oZXJpdGFuY2UgaWYgZWxlbWVudCBleHRlbmRlZCBCIGV4dGVuZGVkIEEgZXh0ZW5kZWQgQy5cbiAgICAvL1xuICAgIC8vIEFnYWluIGdpdmVuLCBQb2x5bWVyeyBiZWhhdmlvcnM6IFtBLCBCLCBDLCBBLCBCXX0sIHRoZSByZXN1bHRpbmdcbiAgICAvLyBgYmVoYXZpb3JzYCBhcnJheSB3YXMgW0MsIEEsIEJdLlxuICAgIC8vIEJlaGF2aW9yIGxpZmVjeWNsZSBtZXRob2RzIHdlcmUgY2FsbGVkIGluIGJlaGF2aW9yIGFycmF5IG9yZGVyXG4gICAgLy8gZm9sbG93ZWQgYnkgdGhlIGVsZW1lbnQsIGUuZy4gKDEpIEMuY3JlYXRlZCwgKDIpIEEuY3JlYXRlZCxcbiAgICAvLyAoMykgQi5jcmVhdGVkLCAoNCkgZWxlbWVudC5jcmVhdGVkLiBUaGVyZSB3YXMgbm8gc3VwcG9ydCBmb3JcbiAgICAvLyBzdXBlciwgYW5kIFwic3VwZXItYmVoYXZpb3JcIiBtZXRob2RzIHdlcmUgY2FsbGFibGUgb25seSBieSBuYW1lKS5cbiAgICAvL1xuICAgIC8vIDIueFxuICAgIC8vIEJlaGF2aW9ycyBhcmUgbWFkZSBpbnRvIHByb3BlciBtaXhpbnMgd2hpY2ggbGl2ZSBpbiB0aGVcbiAgICAvLyBlbGVtZW50J3MgcHJvdG90eXBlIGNoYWluLiBCZWhhdmlvcnMgYXJlIHBsYWNlZCBpbiB0aGUgZWxlbWVudCBwcm90b3R5cGVcbiAgICAvLyBlbGRlc3QgdG8geW91bmdlc3QgYW5kIGRlLWR1cGVkIHlvdW5nZXN0IHRvIG9sZGVzdDpcbiAgICAvLyBTbywgZmlyc3QgW0EsIEIsIEMsIEEsIEJdIGJlY29tZXMgW0MsIEEsIEJdIHRoZW4sXG4gICAgLy8gdGhlIGVsZW1lbnQgcHJvdG90eXBlIGJlY29tZXMgKG9sZGVzdCkgKDEpIFBvbHltZXIuRWxlbWVudCwgKDIpIGNsYXNzKEMpLFxuICAgIC8vICgzKSBjbGFzcyhBKSwgKDQpIGNsYXNzKEIpLCAoNSkgY2xhc3MoUG9seW1lcih7Li4ufSkpLlxuICAgIC8vIFJlc3VsdDpcbiAgICAvLyBUaGlzIG1lYW5zIGVsZW1lbnQgcHJvcGVydGllcyB3aW4gb3ZlciBCIHByb3BlcnRpZXMgd2luIG92ZXIgQSB3aW5cbiAgICAvLyBvdmVyIEMuIChzYW1lIGFzIDEueClcbiAgICAvLyBJZiBsaWZlY3ljbGUgaXMgY2FsbGVkIChzdXBlciB0aGVuIG1lKSwgb3JkZXIgaXNcbiAgICAvLyAoMSkgQy5jcmVhdGVkLCAoMikgQS5jcmVhdGVkLCAoMykgQi5jcmVhdGVkLCAoNCkgZWxlbWVudC5jcmVhdGVkXG4gICAgLy8gKGFnYWluIHNhbWUgYXMgMS54KVxuICAgIGZ1bmN0aW9uIF9taXhpbkJlaGF2aW9ycyhiZWhhdmlvcnMsIGtsYXNzKSB7XG4gICAgICBmb3IgKGxldCBpPTA7IGk8YmVoYXZpb3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBiID0gYmVoYXZpb3JzW2ldO1xuICAgICAgICBpZiAoYikge1xuICAgICAgICAgIGtsYXNzID0gQXJyYXkuaXNBcnJheShiKSA/IF9taXhpbkJlaGF2aW9ycyhiLCBrbGFzcykgOlxuICAgICAgICAgICAgR2VuZXJhdGVDbGFzc0Zyb21JbmZvKGIsIGtsYXNzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGtsYXNzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGJlaGF2aW9ycyBMaXN0IG9mIGJlaGF2aW9ycyB0byBmbGF0dGVuLlxuICAgICAqIEBwYXJhbSB7QXJyYXk9fSBsaXN0IFRhcmdldCBsaXN0IHRvIGZsYXR0ZW4gYmVoYXZpb3JzIGludG8uXG4gICAgICogQHBhcmFtIHtBcnJheT19IGV4Y2x1ZGUgTGlzdCBvZiBiZWhhdmlvcnMgdG8gZXhjbHVkZSBmcm9tIHRoZSBsaXN0LlxuICAgICAqIEByZXR1cm4geyFBcnJheX0gUmV0dXJucyB0aGUgbGlzdCBvZiBmbGF0dGVuZWQgYmVoYXZpb3JzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZsYXR0ZW5CZWhhdmlvcnMoYmVoYXZpb3JzLCBsaXN0LCBleGNsdWRlKSB7XG4gICAgICBsaXN0ID0gbGlzdCB8fCBbXTtcbiAgICAgIGZvciAobGV0IGk9YmVoYXZpb3JzLmxlbmd0aC0xOyBpID49IDA7IGktLSkge1xuICAgICAgICBsZXQgYiA9IGJlaGF2aW9yc1tpXTtcbiAgICAgICAgaWYgKGIpIHtcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShiKSkge1xuICAgICAgICAgICAgZmxhdHRlbkJlaGF2aW9ycyhiLCBsaXN0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gZGVkdXBcbiAgICAgICAgICAgIGlmIChsaXN0LmluZGV4T2YoYikgPCAwICYmICghZXhjbHVkZSB8fCBleGNsdWRlLmluZGV4T2YoYikgPCAwKSkge1xuICAgICAgICAgICAgICBsaXN0LnVuc2hpZnQoYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUud2FybignYmVoYXZpb3IgaXMgbnVsbCwgY2hlY2sgZm9yIG1pc3Npbmcgb3IgNDA0IGltcG9ydCcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbGlzdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyFQb2x5bWVySW5pdH0gaW5mbyBQb2x5bWVyIGluZm8gb2JqZWN0XG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihuZXc6SFRNTEVsZW1lbnQpfSBCYXNlIGJhc2UgY2xhc3MgdG8gZXh0ZW5kIHdpdGggaW5mbyBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtmdW5jdGlvbihuZXc6SFRNTEVsZW1lbnQpfSBHZW5lcmF0ZWQgY2xhc3NcbiAgICAgKiBAc3VwcHJlc3Mge2NoZWNrVHlwZXN9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBHZW5lcmF0ZUNsYXNzRnJvbUluZm8oaW5mbywgQmFzZSkge1xuXG4gICAgICBjbGFzcyBQb2x5bWVyR2VuZXJhdGVkIGV4dGVuZHMgQmFzZSB7XG5cbiAgICAgICAgc3RhdGljIGdldCBwcm9wZXJ0aWVzKCkge1xuICAgICAgICAgIHJldHVybiBpbmZvLnByb3BlcnRpZXM7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0aWMgZ2V0IG9ic2VydmVycygpIHtcbiAgICAgICAgICByZXR1cm4gaW5mby5vYnNlcnZlcnM7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7SFRNTFRlbXBsYXRlRWxlbWVudH0gdGVtcGxhdGUgZm9yIHRoaXMgY2xhc3NcbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBnZXQgdGVtcGxhdGUoKSB7XG4gICAgICAgICAgLy8gZ2V0IHRlbXBsYXRlIGZpcnN0IGZyb20gYW55IGltcGVyYXRpdmUgc2V0IGluIGBpbmZvLl90ZW1wbGF0ZWBcbiAgICAgICAgICByZXR1cm4gaW5mby5fdGVtcGxhdGUgfHxcbiAgICAgICAgICAgIC8vIG5leHQgbG9vayBpbiBkb20tbW9kdWxlIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGVsZW1lbnQncyBpcy5cbiAgICAgICAgICAgIFBvbHltZXIuRG9tTW9kdWxlICYmIFBvbHltZXIuRG9tTW9kdWxlLmltcG9ydCh0aGlzLmlzLCAndGVtcGxhdGUnKSB8fFxuICAgICAgICAgICAgLy8gbmV4dCBsb29rIGZvciBzdXBlcmNsYXNzIHRlbXBsYXRlIChub3RlOiB1c2Ugc3VwZXJjbGFzcyBzeW1ib2xcbiAgICAgICAgICAgIC8vIHRvIGVuc3VyZSBjb3JyZWN0IGB0aGlzLmlzYClcbiAgICAgICAgICAgIEJhc2UudGVtcGxhdGUgfHxcbiAgICAgICAgICAgIC8vIGZpbmFsbHkgZmFsbCBiYWNrIHRvIGBfdGVtcGxhdGVgIGluIGVsZW1lbnQncyBwcm90b3lwZS5cbiAgICAgICAgICAgIHRoaXMucHJvdG90eXBlLl90ZW1wbGF0ZSB8fFxuICAgICAgICAgICAgbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNyZWF0ZWQoKSB7XG4gICAgICAgICAgc3VwZXIuY3JlYXRlZCgpO1xuICAgICAgICAgIGlmIChpbmZvLmNyZWF0ZWQpIHtcbiAgICAgICAgICAgIGluZm8uY3JlYXRlZC5jYWxsKHRoaXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIF9yZWdpc3RlcmVkKCkge1xuICAgICAgICAgIHN1cGVyLl9yZWdpc3RlcmVkKCk7XG4gICAgICAgICAgLyogTk9URTogYGJlZm9yZVJlZ2lzdGVyYCBpcyBjYWxsZWQgaGVyZSBmb3IgYmMsIGJ1dCB0aGUgYmVoYXZpb3JcbiAgICAgICAgICAgaXMgZGlmZmVyZW50IHRoYW4gaW4gMS54LiBJbiAxLjAsIHRoZSBtZXRob2Qgd2FzIGNhbGxlZCAqYWZ0ZXIqXG4gICAgICAgICAgIG1peGluZyBwcm90b3R5cGVzIHRvZ2V0aGVyIGJ1dCAqYmVmb3JlKiBwcm9jZXNzaW5nIG9mIG1ldGEtb2JqZWN0cy5cbiAgICAgICAgICAgSG93ZXZlciwgZHluYW1pYyBlZmZlY3RzIGNhbiBzdGlsbCBiZSBzZXQgaGVyZSBhbmQgY2FuIGJlIGRvbmUgZWl0aGVyXG4gICAgICAgICAgIGluIGBiZWZvcmVSZWdpc3RlcmAgb3IgYHJlZ2lzdGVyZWRgLiBJdCBpcyBubyBsb25nZXIgcG9zc2libGUgdG8gc2V0XG4gICAgICAgICAgIGBpc2AgaW4gYGJlZm9yZVJlZ2lzdGVyYCBhcyB5b3UgY291bGQgaW4gMS54LlxuICAgICAgICAgICovXG4gICAgICAgICAgaWYgKGluZm8uYmVmb3JlUmVnaXN0ZXIpIHtcbiAgICAgICAgICAgIGluZm8uYmVmb3JlUmVnaXN0ZXIuY2FsbChPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaW5mby5yZWdpc3RlcmVkKSB7XG4gICAgICAgICAgICBpbmZvLnJlZ2lzdGVyZWQuY2FsbChPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIF9hcHBseUxpc3RlbmVycygpIHtcbiAgICAgICAgICBzdXBlci5fYXBwbHlMaXN0ZW5lcnMoKTtcbiAgICAgICAgICBpZiAoaW5mby5saXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGwgaW4gaW5mby5saXN0ZW5lcnMpIHtcbiAgICAgICAgICAgICAgdGhpcy5fYWRkTWV0aG9kRXZlbnRMaXN0ZW5lclRvTm9kZSh0aGlzLCBsLCBpbmZvLmxpc3RlbmVyc1tsXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gbm90ZTogZXhjZXB0aW9uIHRvIFwic3VwZXIgdGhlbiBtZVwiIHJ1bGU7XG4gICAgICAgIC8vIGRvIHdvcmsgYmVmb3JlIGNhbGxpbmcgc3VwZXIgc28gdGhhdCBzdXBlciBhdHRyaWJ1dGVzXG4gICAgICAgIC8vIG9ubHkgYXBwbHkgaWYgbm90IGFscmVhZHkgc2V0LlxuICAgICAgICBfZW5zdXJlQXR0cmlidXRlcygpIHtcbiAgICAgICAgICBpZiAoaW5mby5ob3N0QXR0cmlidXRlcykge1xuICAgICAgICAgICAgZm9yIChsZXQgYSBpbiBpbmZvLmhvc3RBdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2Vuc3VyZUF0dHJpYnV0ZShhLCBpbmZvLmhvc3RBdHRyaWJ1dGVzW2FdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgc3VwZXIuX2Vuc3VyZUF0dHJpYnV0ZXMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlYWR5KCkge1xuICAgICAgICAgIHN1cGVyLnJlYWR5KCk7XG4gICAgICAgICAgaWYgKGluZm8ucmVhZHkpIHtcbiAgICAgICAgICAgIGluZm8ucmVhZHkuY2FsbCh0aGlzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBhdHRhY2hlZCgpIHtcbiAgICAgICAgICBzdXBlci5hdHRhY2hlZCgpO1xuICAgICAgICAgIGlmIChpbmZvLmF0dGFjaGVkKSB7XG4gICAgICAgICAgICBpbmZvLmF0dGFjaGVkLmNhbGwodGhpcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZGV0YWNoZWQoKSB7XG4gICAgICAgICAgc3VwZXIuZGV0YWNoZWQoKTtcbiAgICAgICAgICBpZiAoaW5mby5kZXRhY2hlZCkge1xuICAgICAgICAgICAgaW5mby5kZXRhY2hlZC5jYWxsKHRoaXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGF0dHJpYnV0ZUNoYW5nZWQobmFtZSwgb2xkLCB2YWx1ZSkge1xuICAgICAgICAgIHN1cGVyLmF0dHJpYnV0ZUNoYW5nZWQobmFtZSwgb2xkLCB2YWx1ZSk7XG4gICAgICAgICAgaWYgKGluZm8uYXR0cmlidXRlQ2hhbmdlZCkge1xuICAgICAgICAgICAgaW5mby5hdHRyaWJ1dGVDaGFuZ2VkLmNhbGwodGhpcywgbmFtZSwgb2xkLCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgUG9seW1lckdlbmVyYXRlZC5nZW5lcmF0ZWRGcm9tID0gaW5mb1xuXG4gICAgICBmb3IgKGxldCBwIGluIGluZm8pIHtcbiAgICAgICAgLy8gTk9URTogY2Fubm90IGNvcHkgYG1ldGFQcm9wc2AgbWV0aG9kcyBvbnRvIHByb3RvdHlwZSBhdCBsZWFzdCBiZWNhdXNlXG4gICAgICAgIC8vIGBzdXBlci5yZWFkeWAgbXVzdCBiZSBjYWxsZWQgYW5kIGlzIG5vdCBpbmNsdWRlZCBpbiB0aGUgdXNlciBmbi5cbiAgICAgICAgaWYgKCEocCBpbiBtZXRhUHJvcHMpKSB7XG4gICAgICAgICAgbGV0IHBkID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihpbmZvLCBwKTtcbiAgICAgICAgICBpZiAocGQpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQb2x5bWVyR2VuZXJhdGVkLnByb3RvdHlwZSwgcCwgcGQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gUG9seW1lckdlbmVyYXRlZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYSBjbGFzcyB0aGF0IGV4dGVuZHMgYFBvbHltZXIuTGVnYWN5RWxlbWVudGAgYmFzZWQgb24gdGhlXG4gICAgICogcHJvdmlkZWQgaW5mbyBvYmplY3QuICBNZXRhZGF0YSBvYmplY3RzIG9uIHRoZSBgaW5mb2Agb2JqZWN0XG4gICAgICogKGBwcm9wZXJ0aWVzYCwgYG9ic2VydmVyc2AsIGBsaXN0ZW5lcnNgLCBgYmVoYXZpb3JzYCwgYGlzYCkgYXJlIHVzZWRcbiAgICAgKiBmb3IgUG9seW1lcidzIG1ldGEtcHJvZ3JhbW1pbmcgc3lzdGVtcywgYW5kIGFueSBmdW5jdGlvbnMgYXJlIGNvcGllZFxuICAgICAqIHRvIHRoZSBnZW5lcmF0ZWQgY2xhc3MuXG4gICAgICpcbiAgICAgKiBWYWxpZCBcIm1ldGFkYXRhXCIgdmFsdWVzIGFyZSBhcyBmb2xsb3dzOlxuICAgICAqXG4gICAgICogYGlzYDogU3RyaW5nIHByb3ZpZGluZyB0aGUgdGFnIG5hbWUgdG8gcmVnaXN0ZXIgdGhlIGVsZW1lbnQgdW5kZXIuIEluXG4gICAgICogYWRkaXRpb24sIGlmIGEgYGRvbS1tb2R1bGVgIHdpdGggdGhlIHNhbWUgaWQgZXhpc3RzLCB0aGUgZmlyc3QgdGVtcGxhdGVcbiAgICAgKiBpbiB0aGF0IGBkb20tbW9kdWxlYCB3aWxsIGJlIHN0YW1wZWQgaW50byB0aGUgc2hhZG93IHJvb3Qgb2YgdGhpcyBlbGVtZW50LFxuICAgICAqIHdpdGggc3VwcG9ydCBmb3IgZGVjbGFyYXRpdmUgZXZlbnQgbGlzdGVuZXJzIChgb24tLi4uYCksIFBvbHltZXIgZGF0YVxuICAgICAqIGJpbmRpbmdzIChgW1suLi5dXWAgYW5kIGB7ey4uLn19YCksIGFuZCBpZC1iYXNlZCBub2RlIGZpbmRpbmcgaW50b1xuICAgICAqIGB0aGlzLiRgLlxuICAgICAqXG4gICAgICogYHByb3BlcnRpZXNgOiBPYmplY3QgZGVzY3JpYmluZyBwcm9wZXJ0eS1yZWxhdGVkIG1ldGFkYXRhIHVzZWQgYnkgUG9seW1lclxuICAgICAqIGZlYXR1cmVzIChrZXk6IHByb3BlcnR5IG5hbWVzLCB2YWx1ZTogb2JqZWN0IGNvbnRhaW5pbmcgcHJvcGVydHkgbWV0YWRhdGEpLlxuICAgICAqIFZhbGlkIGtleXMgaW4gcGVyLXByb3BlcnR5IG1ldGFkYXRhIGluY2x1ZGU6XG4gICAgICogLSBgdHlwZWAgKFN0cmluZ3xOdW1iZXJ8T2JqZWN0fEFycmF5fC4uLik6IFVzZWQgYnlcbiAgICAgKiAgIGBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2tgIHRvIGRldGVybWluZSBob3cgc3RyaW5nLWJhc2VkIGF0dHJpYnV0ZXNcbiAgICAgKiAgIGFyZSBkZXNlcmlhbGl6ZWQgdG8gSmF2YVNjcmlwdCBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICogLSBgbm90aWZ5YCAoYm9vbGVhbik6IENhdXNlcyBhIGNoYW5nZSBpbiB0aGUgcHJvcGVydHkgdG8gZmlyZSBhXG4gICAgICogICBub24tYnViYmxpbmcgZXZlbnQgY2FsbGVkIGA8cHJvcGVydHk+LWNoYW5nZWRgLiBFbGVtZW50cyB0aGF0IGhhdmVcbiAgICAgKiAgIGVuYWJsZWQgdHdvLXdheSBiaW5kaW5nIHRvIHRoZSBwcm9wZXJ0eSB1c2UgdGhpcyBldmVudCB0byBvYnNlcnZlIGNoYW5nZXMuXG4gICAgICogLSBgcmVhZE9ubHlgIChib29sZWFuKTogQ3JlYXRlcyBhIGdldHRlciBmb3IgdGhlIHByb3BlcnR5LCBidXQgbm8gc2V0dGVyLlxuICAgICAqICAgVG8gc2V0IGEgcmVhZC1vbmx5IHByb3BlcnR5LCB1c2UgdGhlIHByaXZhdGUgc2V0dGVyIG1ldGhvZFxuICAgICAqICAgYF9zZXRQcm9wZXJ0eShwcm9wZXJ0eSwgdmFsdWUpYC5cbiAgICAgKiAtIGBvYnNlcnZlcmAgKHN0cmluZyk6IE9ic2VydmVyIG1ldGhvZCBuYW1lIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2hlblxuICAgICAqICAgdGhlIHByb3BlcnR5IGNoYW5nZXMuIFRoZSBhcmd1bWVudHMgb2YgdGhlIG1ldGhvZCBhcmVcbiAgICAgKiAgIGAodmFsdWUsIHByZXZpb3VzVmFsdWUpYC5cbiAgICAgKiAtIGBjb21wdXRlZGAgKHN0cmluZyk6IFN0cmluZyBkZXNjcmliaW5nIG1ldGhvZCBhbmQgZGVwZW5kZW50IHByb3BlcnRpZXNcbiAgICAgKiAgIGZvciBjb21wdXRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgcHJvcGVydHkgKGUuZy4gYCdjb21wdXRlRm9vKGJhciwgem90KSdgKS5cbiAgICAgKiAgIENvbXB1dGVkIHByb3BlcnRpZXMgYXJlIHJlYWQtb25seSBieSBkZWZhdWx0IGFuZCBjYW4gb25seSBiZSBjaGFuZ2VkXG4gICAgICogICB2aWEgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgY29tcHV0aW5nIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIGBvYnNlcnZlcnNgOiBBcnJheSBvZiBzdHJpbmdzIGRlc2NyaWJpbmcgbXVsdGktcHJvcGVydHkgb2JzZXJ2ZXIgbWV0aG9kc1xuICAgICAqICBhbmQgdGhlaXIgZGVwZW5kZW50IHByb3BlcnRpZXMgKGUuZy4gYCdvYnNlcnZlQUJDKGEsIGIsIGMpJ2ApLlxuICAgICAqXG4gICAgICogYGxpc3RlbmVyc2A6IE9iamVjdCBkZXNjcmliaW5nIGV2ZW50IGxpc3RlbmVycyB0byBiZSBhZGRlZCB0byBlYWNoXG4gICAgICogIGluc3RhbmNlIG9mIHRoaXMgZWxlbWVudCAoa2V5OiBldmVudCBuYW1lLCB2YWx1ZTogbWV0aG9kIG5hbWUpLlxuICAgICAqXG4gICAgICogYGJlaGF2aW9yc2A6IEFycmF5IG9mIGFkZGl0aW9uYWwgYGluZm9gIG9iamVjdHMgY29udGFpbmluZyBtZXRhZGF0YVxuICAgICAqIGFuZCBjYWxsYmFja3MgaW4gdGhlIHNhbWUgZm9ybWF0IGFzIHRoZSBgaW5mb2Agb2JqZWN0IGhlcmUgd2hpY2ggYXJlXG4gICAgICogbWVyZ2VkIGludG8gdGhpcyBlbGVtZW50LlxuICAgICAqXG4gICAgICogYGhvc3RBdHRyaWJ1dGVzYDogT2JqZWN0IGxpc3RpbmcgYXR0cmlidXRlcyB0byBiZSBhcHBsaWVkIHRvIHRoZSBob3N0XG4gICAgICogIG9uY2UgY3JlYXRlZCAoa2V5OiBhdHRyaWJ1dGUgbmFtZSwgdmFsdWU6IGF0dHJpYnV0ZSB2YWx1ZSkuICBWYWx1ZXNcbiAgICAgKiAgYXJlIHNlcmlhbGl6ZWQgYmFzZWQgb24gdGhlIHR5cGUgb2YgdGhlIHZhbHVlLiAgSG9zdCBhdHRyaWJ1dGVzIHNob3VsZFxuICAgICAqICBnZW5lcmFsbHkgYmUgbGltaXRlZCB0byBhdHRyaWJ1dGVzIHN1Y2ggYXMgYHRhYkluZGV4YCBhbmQgYGFyaWEtLi4uYC5cbiAgICAgKiAgQXR0cmlidXRlcyBpbiBgaG9zdEF0dHJpYnV0ZXNgIGFyZSBvbmx5IGFwcGxpZWQgaWYgYSB1c2VyLXN1cHBsaWVkXG4gICAgICogIGF0dHJpYnV0ZSBpcyBub3QgYWxyZWFkeSBwcmVzZW50IChhdHRyaWJ1dGVzIGluIG1hcmt1cCBvdmVycmlkZVxuICAgICAqICBgaG9zdEF0dHJpYnV0ZXNgKS5cbiAgICAgKlxuICAgICAqIEluIGFkZGl0aW9uLCB0aGUgZm9sbG93aW5nIFBvbHltZXItc3BlY2lmaWMgY2FsbGJhY2tzIG1heSBiZSBwcm92aWRlZDpcbiAgICAgKiAtIGByZWdpc3RlcmVkYDogY2FsbGVkIGFmdGVyIGZpcnN0IGluc3RhbmNlIG9mIHRoaXMgZWxlbWVudCxcbiAgICAgKiAtIGBjcmVhdGVkYDogY2FsbGVkIGR1cmluZyBgY29uc3RydWN0b3JgXG4gICAgICogLSBgYXR0YWNoZWRgOiBjYWxsZWQgZHVyaW5nIGBjb25uZWN0ZWRDYWxsYmFja2BcbiAgICAgKiAtIGBkZXRhY2hlZGA6IGNhbGxlZCBkdXJpbmcgYGRpc2Nvbm5lY3RlZENhbGxiYWNrYFxuICAgICAqIC0gYHJlYWR5YDogY2FsbGVkIGJlZm9yZSBmaXJzdCBgYXR0YWNoZWRgLCBhZnRlciBhbGwgcHJvcGVydGllcyBvZlxuICAgICAqICAgdGhpcyBlbGVtZW50IGhhdmUgYmVlbiBwcm9wYWdhdGVkIHRvIGl0cyB0ZW1wbGF0ZSBhbmQgYWxsIG9ic2VydmVyc1xuICAgICAqICAgaGF2ZSBydW5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IVBvbHltZXJJbml0fSBpbmZvIE9iamVjdCBjb250YWluaW5nIFBvbHltZXIgbWV0YWRhdGEgYW5kIGZ1bmN0aW9uc1xuICAgICAqICAgdG8gYmVjb21lIGNsYXNzIG1ldGhvZHMuXG4gICAgICogQHJldHVybiB7ZnVuY3Rpb24obmV3OkhUTUxFbGVtZW50KX0gR2VuZXJhdGVkIGNsYXNzXG4gICAgICogQG1lbWJlcm9mIFBvbHltZXJcbiAgICAgKi9cbiAgICBQb2x5bWVyLkNsYXNzID0gZnVuY3Rpb24oaW5mbykge1xuICAgICAgaWYgKCFpbmZvKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignUG9seW1lci5DbGFzcyByZXF1aXJlcyBgaW5mb2AgYXJndW1lbnQnKTtcbiAgICAgIH1cbiAgICAgIGxldCBrbGFzcyA9IEdlbmVyYXRlQ2xhc3NGcm9tSW5mbyhpbmZvLCBpbmZvLmJlaGF2aW9ycyA/XG4gICAgICAgIC8vIG5vdGU6IG1peGluQmVoYXZpb3JzIGVuc3VyZXMgYExlZ2FjeUVsZW1lbnRNaXhpbmAuXG4gICAgICAgIG1peGluQmVoYXZpb3JzKGluZm8uYmVoYXZpb3JzLCBIVE1MRWxlbWVudCkgOlxuICAgICAgICBQb2x5bWVyLkxlZ2FjeUVsZW1lbnRNaXhpbihIVE1MRWxlbWVudCkpO1xuICAgICAgLy8gZGVjb3JhdGUga2xhc3Mgd2l0aCByZWdpc3RyYXRpb24gaW5mb1xuICAgICAga2xhc3MuaXMgPSBpbmZvLmlzO1xuICAgICAgcmV0dXJuIGtsYXNzO1xuICAgIH1cblxuICAgIFBvbHltZXIubWl4aW5CZWhhdmlvcnMgPSBtaXhpbkJlaGF2aW9ycztcblxuICB9KSgpO1xuXG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvbGVnYWN5L2NsYXNzLmh0bWwiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi91dGlscy90ZW1wbGF0aXplLmh0bWxcIj5cblxuPHNjcmlwdD5cbiAgKGZ1bmN0aW9uKCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGxldCBUZW1wbGF0ZUluc3RhbmNlQmFzZSA9IFBvbHltZXIuVGVtcGxhdGVJbnN0YW5jZUJhc2U7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHt7XG4gICAgICogICBfdGVtcGxhdGl6ZXJUZW1wbGF0ZTogSFRNTFRlbXBsYXRlRWxlbWVudCxcbiAgICAgKiAgIF9wYXJlbnRNb2RlbDogYm9vbGVhbixcbiAgICAgKiAgIF9pbnN0YW5jZVByb3BzOiBPYmplY3QsXG4gICAgICogICBfZm9yd2FyZEhvc3RQcm9wVjI6IEZ1bmN0aW9uLFxuICAgICAqICAgX25vdGlmeUluc3RhbmNlUHJvcFYyOiBGdW5jdGlvbixcbiAgICAgKiAgIGN0b3I6IFRlbXBsYXRlSW5zdGFuY2VCYXNlXG4gICAgICogfX1cbiAgICAgKi9cbiAgICBsZXQgVGVtcGxhdGl6ZXJVc2VyOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbiAgICAvKipcbiAgICAgKiBUaGUgYFBvbHltZXIuVGVtcGxhdGl6ZXJgIGJlaGF2aW9yIGFkZHMgbWV0aG9kcyB0byBnZW5lcmF0ZSBpbnN0YW5jZXMgb2ZcbiAgICAgKiB0ZW1wbGF0ZXMgdGhhdCBhcmUgZWFjaCBtYW5hZ2VkIGJ5IGFuIGFub255bW91cyBgUG9seW1lci5Qcm9wZXJ0eUVmZmVjdHNgXG4gICAgICogaW5zdGFuY2Ugd2hlcmUgZGF0YS1iaW5kaW5ncyBpbiB0aGUgc3RhbXBlZCB0ZW1wbGF0ZSBjb250ZW50IGFyZSBib3VuZCB0b1xuICAgICAqIGFjY2Vzc29ycyBvbiBpdHNlbGYuXG4gICAgICpcbiAgICAgKiBUaGlzIGJlaGF2aW9yIGlzIHByb3ZpZGVkIGluIFBvbHltZXIgMi54IGFzIGEgaHlicmlkLWVsZW1lbnQgY29udmVuaWVuY2VcbiAgICAgKiBvbmx5LiAgRm9yIG5vbi1oeWJyaWQgdXNhZ2UsIHRoZSBgUG9seW1lci5UZW1wbGF0aXplYCBsaWJyYXJ5XG4gICAgICogc2hvdWxkIGJlIHVzZWQgaW5zdGVhZC5cbiAgICAgKlxuICAgICAqIEV4YW1wbGU6XG4gICAgICpcbiAgICAgKiAgICAgLy8gR2V0IGEgdGVtcGxhdGUgZnJvbSBzb21ld2hlcmUsIGUuZy4gbGlnaHQgRE9NXG4gICAgICogICAgIGxldCB0ZW1wbGF0ZSA9IHRoaXMucXVlcnlTZWxlY3RvcigndGVtcGxhdGUnKTtcbiAgICAgKiAgICAgLy8gUHJlcGFyZSB0aGUgdGVtcGxhdGVcbiAgICAgKiAgICAgdGhpcy50ZW1wbGF0aXplKHRlbXBsYXRlKTtcbiAgICAgKiAgICAgLy8gSW5zdGFuY2UgdGhlIHRlbXBsYXRlIHdpdGggYW4gaW5pdGlhbCBkYXRhIG1vZGVsXG4gICAgICogICAgIGxldCBpbnN0YW5jZSA9IHRoaXMuc3RhbXAoe215UHJvcDogJ2luaXRpYWwnfSk7XG4gICAgICogICAgIC8vIEluc2VydCB0aGUgaW5zdGFuY2UncyBET00gc29tZXdoZXJlLCBlLmcuIGxpZ2h0IERPTVxuICAgICAqICAgICBQb2x5bWVyLmRvbSh0aGlzKS5hcHBlbmRDaGlsZChpbnN0YW5jZS5yb290KTtcbiAgICAgKiAgICAgLy8gQ2hhbmdpbmcgYSBwcm9wZXJ0eSBvbiB0aGUgaW5zdGFuY2Ugd2lsbCBwcm9wYWdhdGUgdG8gYmluZGluZ3NcbiAgICAgKiAgICAgLy8gaW4gdGhlIHRlbXBsYXRlXG4gICAgICogICAgIGluc3RhbmNlLm15UHJvcCA9ICduZXcgdmFsdWUnO1xuICAgICAqXG4gICAgICogVXNlcnMgb2YgYFRlbXBsYXRpemVyYCBtYXkgbmVlZCB0byBpbXBsZW1lbnQgdGhlIGZvbGxvd2luZyBhYnN0cmFjdFxuICAgICAqIEFQSSdzIHRvIGRldGVybWluZSBob3cgcHJvcGVydGllcyBhbmQgcGF0aHMgZnJvbSB0aGUgaG9zdCBzaG91bGQgYmVcbiAgICAgKiBmb3J3YXJkZWQgaW50byB0byBpbnN0YW5jZXM6XG4gICAgICpcbiAgICAgKiAgICAgX2ZvcndhcmRIb3N0UHJvcFYyOiBmdW5jdGlvbihwcm9wLCB2YWx1ZSlcbiAgICAgKlxuICAgICAqIExpa2V3aXNlLCB1c2VycyBtYXkgaW1wbGVtZW50IHRoZXNlIGFkZGl0aW9uYWwgYWJzdHJhY3QgQVBJJ3MgdG8gZGV0ZXJtaW5lXG4gICAgICogaG93IGluc3RhbmNlLXNwZWNpZmljIHByb3BlcnRpZXMgdGhhdCBjaGFuZ2Ugb24gdGhlIGluc3RhbmNlIHNob3VsZCBiZVxuICAgICAqIGZvcndhcmRlZCBvdXQgdG8gdGhlIGhvc3QsIGlmIG5lY2Vzc2FyeS5cbiAgICAgKlxuICAgICAqICAgICBfbm90aWZ5SW5zdGFuY2VQcm9wVjI6IGZ1bmN0aW9uKGluc3QsIHByb3AsIHZhbHVlKVxuICAgICAqXG4gICAgICogSW4gb3JkZXIgdG8gZGV0ZXJtaW5lIHdoaWNoIHByb3BlcnRpZXMgYXJlIGluc3RhbmNlLXNwZWNpZmljIGFuZCByZXF1aXJlXG4gICAgICogY3VzdG9tIG5vdGlmaWNhdGlvbiB2aWEgYF9ub3RpZnlJbnN0YW5jZVByb3BgLCBkZWZpbmUgYW4gYF9pbnN0YW5jZVByb3BzYFxuICAgICAqIG9iamVjdCBjb250YWluaW5nIGtleXMgZm9yIGVhY2ggaW5zdGFuY2UgcHJvcCwgZm9yIGV4YW1wbGU6XG4gICAgICpcbiAgICAgKiAgICAgX2luc3RhbmNlUHJvcHM6IHtcbiAgICAgKiAgICAgICBpdGVtOiB0cnVlLFxuICAgICAqICAgICAgIGluZGV4OiB0cnVlXG4gICAgICogICAgIH1cbiAgICAgKlxuICAgICAqIEFueSBwcm9wZXJ0aWVzIHVzZWQgaW4gdGhlIHRlbXBsYXRlIHRoYXQgYXJlIG5vdCBkZWZpbmVkIGluIF9pbnN0YW5jZVByb3BcbiAgICAgKiB3aWxsIGJlIGZvcndhcmRlZCBvdXQgdG8gdGhlIFRlbXBsYXRpemUgYG93bmVyYCBhdXRvbWF0aWNhbGx5LlxuICAgICAqXG4gICAgICogVXNlcnMgbWF5IGFsc28gaW1wbGVtZW50IHRoZSBmb2xsb3dpbmcgYWJzdHJhY3QgZnVuY3Rpb24gdG8gc2hvdyBvclxuICAgICAqIGhpZGUgYW55IERPTSBnZW5lcmF0ZWQgdXNpbmcgYHN0YW1wYDpcbiAgICAgKlxuICAgICAqICAgICBfc2hvd0hpZGVDaGlsZHJlbjogZnVuY3Rpb24oc2hvdWxkSGlkZSlcbiAgICAgKlxuICAgICAqIE5vdGUgdGhhdCBzb21lIGNhbGxiYWNrcyBhcmUgc3VmZml4ZWQgd2l0aCBgVjJgIGluIHRoZSBQb2x5bWVyIDIueCBiZWhhdmlvclxuICAgICAqIGFzIHRoZSBpbXBsZW1lbnRhdGlvbnMgd2lsbCBuZWVkIHRvIGRpZmZlciBmcm9tIHRoZSBjYWxsYmFja3MgcmVxdWlyZWRcbiAgICAgKiBieSB0aGUgMS54IFRlbXBsYXRpemVyIEFQSSBkdWUgdG8gY2hhbmdlcyBpbiB0aGUgYFRlbXBsYXRlSW5zdGFuY2VgIEFQSVxuICAgICAqIGJldHdlZW4gdmVyc2lvbnMgMS54IGFuZCAyLnguXG4gICAgICpcbiAgICAgKiBAcG9seW1lckJlaGF2aW9yXG4gICAgICogQG1lbWJlcm9mIFBvbHltZXJcbiAgICAgKi9cbiAgICBsZXQgVGVtcGxhdGl6ZXIgPSB7XG5cbiAgICAgIC8qKlxuICAgICAgICogR2VuZXJhdGVzIGFuIGFub255bW91cyBgVGVtcGxhdGVJbnN0YW5jZWAgY2xhc3MgKHN0b3JlZCBhcyBgdGhpcy5jdG9yYClcbiAgICAgICAqIGZvciB0aGUgcHJvdmlkZWQgdGVtcGxhdGUuICBUaGlzIG1ldGhvZCBzaG91bGQgYmUgY2FsbGVkIG9uY2UgcGVyXG4gICAgICAgKiB0ZW1wbGF0ZSB0byBwcmVwYXJlIGFuIGVsZW1lbnQgZm9yIHN0YW1waW5nIHRoZSB0ZW1wbGF0ZSwgZm9sbG93ZWRcbiAgICAgICAqIGJ5IGBzdGFtcGAgdG8gY3JlYXRlIG5ldyBpbnN0YW5jZXMgb2YgdGhlIHRlbXBsYXRlLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7SFRNTFRlbXBsYXRlRWxlbWVudH0gdGVtcGxhdGUgVGVtcGxhdGUgdG8gcHJlcGFyZVxuICAgICAgICogQHBhcmFtIHtib29sZWFuPX0gbXV0YWJsZURhdGEgV2hlbiBgdHJ1ZWAsIHRoZSBnZW5lcmF0ZWQgY2xhc3Mgd2lsbCBza2lwXG4gICAgICAgKiAgIHN0cmljdCBkaXJ0eS1jaGVja2luZyBmb3Igb2JqZWN0cyBhbmQgYXJyYXlzIChhbHdheXMgY29uc2lkZXIgdGhlbSB0b1xuICAgICAgICogICBiZSBcImRpcnR5XCIpLiBEZWZhdWx0cyB0byBmYWxzZS5cbiAgICAgICAqIEB0aGlzIHtUZW1wbGF0aXplclVzZXJ9XG4gICAgICAgKi9cbiAgICAgIHRlbXBsYXRpemUodGVtcGxhdGUsIG11dGFibGVEYXRhKSB7XG4gICAgICAgIHRoaXMuX3RlbXBsYXRpemVyVGVtcGxhdGUgPSB0ZW1wbGF0ZTtcbiAgICAgICAgdGhpcy5jdG9yID0gUG9seW1lci5UZW1wbGF0aXplLnRlbXBsYXRpemUodGVtcGxhdGUsIHRoaXMsIHtcbiAgICAgICAgICBtdXRhYmxlRGF0YTogQm9vbGVhbihtdXRhYmxlRGF0YSksXG4gICAgICAgICAgcGFyZW50TW9kZWw6IHRoaXMuX3BhcmVudE1vZGVsLFxuICAgICAgICAgIGluc3RhbmNlUHJvcHM6IHRoaXMuX2luc3RhbmNlUHJvcHMsXG4gICAgICAgICAgZm9yd2FyZEhvc3RQcm9wOiB0aGlzLl9mb3J3YXJkSG9zdFByb3BWMixcbiAgICAgICAgICBub3RpZnlJbnN0YW5jZVByb3A6IHRoaXMuX25vdGlmeUluc3RhbmNlUHJvcFYyXG4gICAgICAgIH0pO1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIHRoZSB0ZW1wbGF0ZSBwcmVwYXJlZCBieSBgdGVtcGxhdGl6ZWAuICBUaGUgb2JqZWN0XG4gICAgICAgKiByZXR1cm5lZCBpcyBhbiBpbnN0YW5jZSBvZiB0aGUgYW5vbnltb3VzIGNsYXNzIGdlbmVyYXRlZCBieSBgdGVtcGxhdGl6ZWBcbiAgICAgICAqIHdob3NlIGByb290YCBwcm9wZXJ0eSBpcyBhIGRvY3VtZW50IGZyYWdtZW50IGNvbnRhaW5pbmcgbmV3bHkgY2xvbmVkXG4gICAgICAgKiB0ZW1wbGF0ZSBjb250ZW50LCBhbmQgd2hpY2ggaGFzIHByb3BlcnR5IGFjY2Vzc29ycyBjb3JyZXNwb25kaW5nIHRvXG4gICAgICAgKiBwcm9wZXJ0aWVzIHJlZmVyZW5jZWQgaW4gdGVtcGxhdGUgYmluZGluZ3MuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtPYmplY3Q9fSBtb2RlbCBPYmplY3QgY29udGFpbmluZyBpbml0aWFsIHByb3BlcnR5IHZhbHVlcyB0b1xuICAgICAgICogICBwb3B1bGF0ZSBpbnRvIHRoZSB0ZW1wbGF0ZSBiaW5kaW5ncy5cbiAgICAgICAqIEByZXR1cm4ge1RlbXBsYXRlSW5zdGFuY2VCYXNlfSBSZXR1cm5zIHRoZSBjcmVhdGVkIGluc3RhbmNlIG9mXG4gICAgICAgKiB0aGUgdGVtcGxhdGUgcHJlcGFyZWQgYnkgYHRlbXBsYXRpemVgLlxuICAgICAgICogQHRoaXMge1RlbXBsYXRpemVyVXNlcn1cbiAgICAgICAqL1xuICAgICAgc3RhbXAobW9kZWwpIHtcbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzLmN0b3IobW9kZWwpO1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBSZXR1cm5zIHRoZSB0ZW1wbGF0ZSBcIm1vZGVsXCIgKGBUZW1wbGF0ZUluc3RhbmNlYCkgYXNzb2NpYXRlZCB3aXRoXG4gICAgICAgKiBhIGdpdmVuIGVsZW1lbnQsIHdoaWNoIHNlcnZlcyBhcyB0aGUgYmluZGluZyBzY29wZSBmb3IgdGhlIHRlbXBsYXRlXG4gICAgICAgKiBpbnN0YW5jZSB0aGUgZWxlbWVudCBpcyBjb250YWluZWQgaW4uICBBIHRlbXBsYXRlIG1vZGVsIHNob3VsZCBiZSB1c2VkXG4gICAgICAgKiB0byBtYW5pcHVsYXRlIGRhdGEgYXNzb2NpYXRlZCB3aXRoIHRoaXMgdGVtcGxhdGUgaW5zdGFuY2UuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgRWxlbWVudCBmb3Igd2hpY2ggdG8gcmV0dXJuIGEgdGVtcGxhdGUgbW9kZWwuXG4gICAgICAgKiBAcmV0dXJuIHtUZW1wbGF0ZUluc3RhbmNlQmFzZX0gTW9kZWwgcmVwcmVzZW50aW5nIHRoZSBiaW5kaW5nIHNjb3BlIGZvclxuICAgICAgICogICB0aGUgZWxlbWVudC5cbiAgICAgICAqIEB0aGlzIHtUZW1wbGF0aXplclVzZXJ9XG4gICAgICAgKi9cbiAgICAgIG1vZGVsRm9yRWxlbWVudChlbCkge1xuICAgICAgICByZXR1cm4gUG9seW1lci5UZW1wbGF0aXplLm1vZGVsRm9yRWxlbWVudCh0aGlzLl90ZW1wbGF0aXplclRlbXBsYXRlLCBlbCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIFBvbHltZXIuVGVtcGxhdGl6ZXIgPSBUZW1wbGF0aXplcjtcblxuICB9KSgpO1xuPC9zY3JpcHQ+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL3BvbHltZXIvbGliL2xlZ2FjeS90ZW1wbGF0aXplci1iZWhhdmlvci5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuXG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vdXRpbHMvYm9vdC5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vbWl4aW5zL3Byb3BlcnR5LWVmZmVjdHMuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL21peGlucy9tdXRhYmxlLWRhdGEuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL21peGlucy9nZXN0dXJlLWV2ZW50LWxpc3RlbmVycy5odG1sXCI+XG5cbjxzY3JpcHQ+XG5cbiAgKGZ1bmN0aW9uKCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBleHRlbmRzIHtIVE1MRWxlbWVudH1cbiAgICAgKiBAaW1wbGVtZW50cyB7UG9seW1lcl9Qcm9wZXJ0eUVmZmVjdHN9XG4gICAgICogQGltcGxlbWVudHMge1BvbHltZXJfT3B0aW9uYWxNdXRhYmxlRGF0YX1cbiAgICAgKiBAaW1wbGVtZW50cyB7UG9seW1lcl9HZXN0dXJlRXZlbnRMaXN0ZW5lcnN9XG4gICAgICovXG4gICAgY29uc3QgZG9tQmluZEJhc2UgPVxuICAgICAgUG9seW1lci5HZXN0dXJlRXZlbnRMaXN0ZW5lcnMoXG4gICAgICAgIFBvbHltZXIuT3B0aW9uYWxNdXRhYmxlRGF0YShcbiAgICAgICAgICBQb2x5bWVyLlByb3BlcnR5RWZmZWN0cyhIVE1MRWxlbWVudCkpKTtcblxuICAgIC8qKlxuICAgICAqIEN1c3RvbSBlbGVtZW50IHRvIGFsbG93IHVzaW5nIFBvbHltZXIncyB0ZW1wbGF0ZSBmZWF0dXJlcyAoZGF0YSBiaW5kaW5nLFxuICAgICAqIGRlY2xhcmF0aXZlIGV2ZW50IGxpc3RlbmVycywgZXRjLikgaW4gdGhlIG1haW4gZG9jdW1lbnQgd2l0aG91dCBkZWZpbmluZ1xuICAgICAqIGEgbmV3IGN1c3RvbSBlbGVtZW50LlxuICAgICAqXG4gICAgICogYDx0ZW1wbGF0ZT5gIHRhZ3MgdXRpbGl6aW5nIGJpbmRpbmdzIG1heSBiZSB3cmFwcGVkIHdpdGggdGhlIGA8ZG9tLWJpbmQ+YFxuICAgICAqIGVsZW1lbnQsIHdoaWNoIHdpbGwgaW1tZWRpYXRlbHkgc3RhbXAgdGhlIHdyYXBwZWQgdGVtcGxhdGUgaW50byB0aGUgbWFpblxuICAgICAqIGRvY3VtZW50IGFuZCBiaW5kIGVsZW1lbnRzIHRvIHRoZSBgZG9tLWJpbmRgIGVsZW1lbnQgaXRzZWxmIGFzIHRoZVxuICAgICAqIGJpbmRpbmcgc2NvcGUuXG4gICAgICpcbiAgICAgKiBAcG9seW1lclxuICAgICAqIEBjdXN0b21FbGVtZW50XG4gICAgICogQGFwcGxpZXNNaXhpbiBQb2x5bWVyLlByb3BlcnR5RWZmZWN0c1xuICAgICAqIEBhcHBsaWVzTWl4aW4gUG9seW1lci5PcHRpb25hbE11dGFibGVEYXRhXG4gICAgICogQGFwcGxpZXNNaXhpbiBQb2x5bWVyLkdlc3R1cmVFdmVudExpc3RlbmVyc1xuICAgICAqIEBleHRlbmRzIHtkb21CaW5kQmFzZX1cbiAgICAgKiBAbWVtYmVyb2YgUG9seW1lclxuICAgICAqIEBzdW1tYXJ5IEN1c3RvbSBlbGVtZW50IHRvIGFsbG93IHVzaW5nIFBvbHltZXIncyB0ZW1wbGF0ZSBmZWF0dXJlcyAoZGF0YVxuICAgICAqICAgYmluZGluZywgZGVjbGFyYXRpdmUgZXZlbnQgbGlzdGVuZXJzLCBldGMuKSBpbiB0aGUgbWFpbiBkb2N1bWVudC5cbiAgICAgKi9cbiAgICBjbGFzcyBEb21CaW5kIGV4dGVuZHMgZG9tQmluZEJhc2Uge1xuXG4gICAgICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHsgcmV0dXJuIFsnbXV0YWJsZS1kYXRhJ10gfVxuXG4gICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5yb290ID0gbnVsbDtcbiAgICAgICAgdGhpcy4kID0gbnVsbDtcbiAgICAgICAgdGhpcy5fX2NoaWxkcmVuID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgLy8gYXNzdW1lcyBvbmx5IG9uZSBvYnNlcnZlZCBhdHRyaWJ1dGVcbiAgICAgIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjaygpIHtcbiAgICAgICAgdGhpcy5tdXRhYmxlRGF0YSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgICAgICB0aGlzLnJlbmRlcigpO1xuICAgICAgfVxuXG4gICAgICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgICAgdGhpcy5fX3JlbW92ZUNoaWxkcmVuKCk7XG4gICAgICB9XG5cbiAgICAgIF9faW5zZXJ0Q2hpbGRyZW4oKSB7XG4gICAgICAgIHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpcy5yb290LCB0aGlzKTtcbiAgICAgIH1cblxuICAgICAgX19yZW1vdmVDaGlsZHJlbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX19jaGlsZHJlbikge1xuICAgICAgICAgIGZvciAobGV0IGk9MDsgaTx0aGlzLl9fY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMucm9vdC5hcHBlbmRDaGlsZCh0aGlzLl9fY2hpbGRyZW5baV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEZvcmNlcyB0aGUgZWxlbWVudCB0byByZW5kZXIgaXRzIGNvbnRlbnQuIFRoaXMgaXMgdHlwaWNhbGx5IG9ubHlcbiAgICAgICAqIG5lY2Vzc2FyeSB0byBjYWxsIGlmIEhUTUxJbXBvcnRzIHdpdGggdGhlIGFzeW5jIGF0dHJpYnV0ZSBhcmUgdXNlZC5cbiAgICAgICAqL1xuICAgICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgdGVtcGxhdGU7XG4gICAgICAgIGlmICghdGhpcy5fX2NoaWxkcmVuKSB7XG4gICAgICAgICAgdGVtcGxhdGUgPSAvKiogQHR5cGUge0hUTUxUZW1wbGF0ZUVsZW1lbnR9ICovKHRlbXBsYXRlIHx8IHRoaXMucXVlcnlTZWxlY3RvcigndGVtcGxhdGUnKSk7XG4gICAgICAgICAgaWYgKCF0ZW1wbGF0ZSkge1xuICAgICAgICAgICAgLy8gV2FpdCB1bnRpbCBjaGlsZExpc3QgY2hhbmdlcyBhbmQgdGVtcGxhdGUgc2hvdWxkIGJlIHRoZXJlIGJ5IHRoZW5cbiAgICAgICAgICAgIGxldCBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKCgpID0+IHtcbiAgICAgICAgICAgICAgdGVtcGxhdGUgPSAvKiogQHR5cGUge0hUTUxUZW1wbGF0ZUVsZW1lbnR9ICovKHRoaXMucXVlcnlTZWxlY3RvcigndGVtcGxhdGUnKSk7XG4gICAgICAgICAgICAgIGlmICh0ZW1wbGF0ZSkge1xuICAgICAgICAgICAgICAgIG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcigpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZG9tLWJpbmQgcmVxdWlyZXMgYSA8dGVtcGxhdGU+IGNoaWxkJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICBvYnNlcnZlci5vYnNlcnZlKHRoaXMsIHtjaGlsZExpc3Q6IHRydWV9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5yb290ID0gdGhpcy5fc3RhbXBUZW1wbGF0ZSh0ZW1wbGF0ZSk7XG4gICAgICAgICAgdGhpcy4kID0gdGhpcy5yb290LiQ7XG4gICAgICAgICAgdGhpcy5fX2NoaWxkcmVuID0gW107XG4gICAgICAgICAgZm9yIChsZXQgbj10aGlzLnJvb3QuZmlyc3RDaGlsZDsgbjsgbj1uLm5leHRTaWJsaW5nKSB7XG4gICAgICAgICAgICB0aGlzLl9fY2hpbGRyZW5bdGhpcy5fX2NoaWxkcmVuLmxlbmd0aF0gPSBuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9lbmFibGVQcm9wZXJ0aWVzKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fX2luc2VydENoaWxkcmVuKCk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ2RvbS1jaGFuZ2UnLCB7XG4gICAgICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgICAgICBjb21wb3NlZDogdHJ1ZVxuICAgICAgICB9KSk7XG4gICAgICB9XG5cbiAgICB9XG5cbiAgICBjdXN0b21FbGVtZW50cy5kZWZpbmUoJ2RvbS1iaW5kJywgRG9tQmluZCk7XG5cbiAgfSkoKTtcblxuPC9zY3JpcHQ+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL3BvbHltZXIvbGliL2VsZW1lbnRzL2RvbS1iaW5kLmh0bWwiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi8uLi9wb2x5bWVyLWVsZW1lbnQuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3V0aWxzL3RlbXBsYXRpemUuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3V0aWxzL2RlYm91bmNlLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi91dGlscy9mbHVzaC5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vbWl4aW5zL211dGFibGUtZGF0YS5odG1sXCI+XG5cbjxzY3JpcHQ+XG4oZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBsZXQgVGVtcGxhdGVJbnN0YW5jZUJhc2UgPSBQb2x5bWVyLlRlbXBsYXRlSW5zdGFuY2VCYXNlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAaW1wbGVtZW50cyB7UG9seW1lcl9PcHRpb25hbE11dGFibGVEYXRhfVxuICAgKiBAZXh0ZW5kcyB7UG9seW1lci5FbGVtZW50fVxuICAgKi9cbiAgY29uc3QgZG9tUmVwZWF0QmFzZSA9IFBvbHltZXIuT3B0aW9uYWxNdXRhYmxlRGF0YShQb2x5bWVyLkVsZW1lbnQpO1xuXG4gIC8qKlxuICAgKiBUaGUgYDxkb20tcmVwZWF0PmAgZWxlbWVudCB3aWxsIGF1dG9tYXRpY2FsbHkgc3RhbXAgYW5kIGJpbmRzIG9uZSBpbnN0YW5jZVxuICAgKiBvZiB0ZW1wbGF0ZSBjb250ZW50IHRvIGVhY2ggb2JqZWN0IGluIGEgdXNlci1wcm92aWRlZCBhcnJheS5cbiAgICogYGRvbS1yZXBlYXRgIGFjY2VwdHMgYW4gYGl0ZW1zYCBwcm9wZXJ0eSwgYW5kIG9uZSBpbnN0YW5jZSBvZiB0aGUgdGVtcGxhdGVcbiAgICogaXMgc3RhbXBlZCBmb3IgZWFjaCBpdGVtIGludG8gdGhlIERPTSBhdCB0aGUgbG9jYXRpb24gb2YgdGhlIGBkb20tcmVwZWF0YFxuICAgKiBlbGVtZW50LiAgVGhlIGBpdGVtYCBwcm9wZXJ0eSB3aWxsIGJlIHNldCBvbiBlYWNoIGluc3RhbmNlJ3MgYmluZGluZ1xuICAgKiBzY29wZSwgdGh1cyB0ZW1wbGF0ZXMgc2hvdWxkIGJpbmQgdG8gc3ViLXByb3BlcnRpZXMgb2YgYGl0ZW1gLlxuICAgKlxuICAgKiBFeGFtcGxlOlxuICAgKlxuICAgKiBgYGBodG1sXG4gICAqIDxkb20tbW9kdWxlIGlkPVwiZW1wbG95ZWUtbGlzdFwiPlxuICAgKlxuICAgKiAgIDx0ZW1wbGF0ZT5cbiAgICpcbiAgICogICAgIDxkaXY+IEVtcGxveWVlIGxpc3Q6IDwvZGl2PlxuICAgKiAgICAgPHRlbXBsYXRlIGlzPVwiZG9tLXJlcGVhdFwiIGl0ZW1zPVwie3tlbXBsb3llZXN9fVwiPlxuICAgKiAgICAgICAgIDxkaXY+Rmlyc3QgbmFtZTogPHNwYW4+e3tpdGVtLmZpcnN0fX08L3NwYW4+PC9kaXY+XG4gICAqICAgICAgICAgPGRpdj5MYXN0IG5hbWU6IDxzcGFuPnt7aXRlbS5sYXN0fX08L3NwYW4+PC9kaXY+XG4gICAqICAgICA8L3RlbXBsYXRlPlxuICAgKlxuICAgKiAgIDwvdGVtcGxhdGU+XG4gICAqXG4gICAqICAgPHNjcmlwdD5cbiAgICogICAgIFBvbHltZXIoe1xuICAgKiAgICAgICBpczogJ2VtcGxveWVlLWxpc3QnLFxuICAgKiAgICAgICByZWFkeTogZnVuY3Rpb24oKSB7XG4gICAqICAgICAgICAgdGhpcy5lbXBsb3llZXMgPSBbXG4gICAqICAgICAgICAgICAgIHtmaXJzdDogJ0JvYicsIGxhc3Q6ICdTbWl0aCd9LFxuICAgKiAgICAgICAgICAgICB7Zmlyc3Q6ICdTYWxseScsIGxhc3Q6ICdKb2huc29uJ30sXG4gICAqICAgICAgICAgICAgIC4uLlxuICAgKiAgICAgICAgIF07XG4gICAqICAgICAgIH1cbiAgICogICAgIH0pO1xuICAgKiAgIDwgL3NjcmlwdD5cbiAgICpcbiAgICogPC9kb20tbW9kdWxlPlxuICAgKiBgYGBcbiAgICpcbiAgICogTm90aWZpY2F0aW9ucyBmb3IgY2hhbmdlcyB0byBpdGVtcyBzdWItcHJvcGVydGllcyB3aWxsIGJlIGZvcndhcmRlZCB0byB0ZW1wbGF0ZVxuICAgKiBpbnN0YW5jZXMsIHdoaWNoIHdpbGwgdXBkYXRlIHZpYSB0aGUgbm9ybWFsIHN0cnVjdHVyZWQgZGF0YSBub3RpZmljYXRpb24gc3lzdGVtLlxuICAgKlxuICAgKiBNdXRhdGlvbnMgdG8gdGhlIGBpdGVtc2AgYXJyYXkgaXRzZWxmIHNob3VsZCBiZSBtYWRlIHVzaW5nIHRoZSBBcnJheVxuICAgKiBtdXRhdGlvbiBBUEkncyBvbiBgUG9seW1lci5CYXNlYCAoYHB1c2hgLCBgcG9wYCwgYHNwbGljZWAsIGBzaGlmdGAsXG4gICAqIGB1bnNoaWZ0YCksIGFuZCB0ZW1wbGF0ZSBpbnN0YW5jZXMgd2lsbCBiZSBrZXB0IGluIHN5bmMgd2l0aCB0aGUgZGF0YSBpbiB0aGVcbiAgICogYXJyYXkuXG4gICAqXG4gICAqIEV2ZW50cyBjYXVnaHQgYnkgZXZlbnQgaGFuZGxlcnMgd2l0aGluIHRoZSBgZG9tLXJlcGVhdGAgdGVtcGxhdGUgd2lsbCBiZVxuICAgKiBkZWNvcmF0ZWQgd2l0aCBhIGBtb2RlbGAgcHJvcGVydHksIHdoaWNoIHJlcHJlc2VudHMgdGhlIGJpbmRpbmcgc2NvcGUgZm9yXG4gICAqIGVhY2ggdGVtcGxhdGUgaW5zdGFuY2UuICBUaGUgbW9kZWwgaXMgYW4gaW5zdGFuY2Ugb2YgUG9seW1lci5CYXNlLCBhbmQgc2hvdWxkXG4gICAqIGJlIHVzZWQgdG8gbWFuaXB1bGF0ZSBkYXRhIG9uIHRoZSBpbnN0YW5jZSwgZm9yIGV4YW1wbGVcbiAgICogYGV2ZW50Lm1vZGVsLnNldCgnaXRlbS5jaGVja2VkJywgdHJ1ZSk7YC5cbiAgICpcbiAgICogQWx0ZXJuYXRpdmVseSwgdGhlIG1vZGVsIGZvciBhIHRlbXBsYXRlIGluc3RhbmNlIGZvciBhbiBlbGVtZW50IHN0YW1wZWQgYnlcbiAgICogYSBgZG9tLXJlcGVhdGAgY2FuIGJlIG9idGFpbmVkIHVzaW5nIHRoZSBgbW9kZWxGb3JFbGVtZW50YCBBUEkgb24gdGhlXG4gICAqIGBkb20tcmVwZWF0YCB0aGF0IHN0YW1wZWQgaXQsIGZvciBleGFtcGxlXG4gICAqIGB0aGlzLiQuZG9tUmVwZWF0Lm1vZGVsRm9yRWxlbWVudChldmVudC50YXJnZXQpLnNldCgnaXRlbS5jaGVja2VkJywgdHJ1ZSk7YC5cbiAgICogVGhpcyBtYXkgYmUgdXNlZnVsIGZvciBtYW5pcHVsYXRpbmcgaW5zdGFuY2UgZGF0YSBvZiBldmVudCB0YXJnZXRzIG9idGFpbmVkXG4gICAqIGJ5IGV2ZW50IGhhbmRsZXJzIG9uIHBhcmVudHMgb2YgdGhlIGBkb20tcmVwZWF0YCAoZXZlbnQgZGVsZWdhdGlvbikuXG4gICAqXG4gICAqIEEgdmlldy1zcGVjaWZpYyBmaWx0ZXIvc29ydCBtYXkgYmUgYXBwbGllZCB0byBlYWNoIGBkb20tcmVwZWF0YCBieSBzdXBwbHlpbmcgYVxuICAgKiBgZmlsdGVyYCBhbmQvb3IgYHNvcnRgIHByb3BlcnR5LiAgVGhpcyBtYXkgYmUgYSBzdHJpbmcgdGhhdCBuYW1lcyBhIGZ1bmN0aW9uIG9uXG4gICAqIHRoZSBob3N0LCBvciBhIGZ1bmN0aW9uIG1heSBiZSBhc3NpZ25lZCB0byB0aGUgcHJvcGVydHkgZGlyZWN0bHkuICBUaGUgZnVuY3Rpb25zXG4gICAqIHNob3VsZCBpbXBsZW1lbnRlZCBmb2xsb3dpbmcgdGhlIHN0YW5kYXJkIGBBcnJheWAgZmlsdGVyL3NvcnQgQVBJLlxuICAgKlxuICAgKiBJbiBvcmRlciB0byByZS1ydW4gdGhlIGZpbHRlciBvciBzb3J0IGZ1bmN0aW9ucyBiYXNlZCBvbiBjaGFuZ2VzIHRvIHN1Yi1maWVsZHNcbiAgICogb2YgYGl0ZW1zYCwgdGhlIGBvYnNlcnZlYCBwcm9wZXJ0eSBtYXkgYmUgc2V0IGFzIGEgc3BhY2Utc2VwYXJhdGVkIGxpc3Qgb2ZcbiAgICogYGl0ZW1gIHN1Yi1maWVsZHMgdGhhdCBzaG91bGQgY2F1c2UgYSByZS1maWx0ZXIvc29ydCB3aGVuIG1vZGlmaWVkLiAgSWZcbiAgICogdGhlIGZpbHRlciBvciBzb3J0IGZ1bmN0aW9uIGRlcGVuZHMgb24gcHJvcGVydGllcyBub3QgY29udGFpbmVkIGluIGBpdGVtc2AsXG4gICAqIHRoZSB1c2VyIHNob3VsZCBvYnNlcnZlIGNoYW5nZXMgdG8gdGhvc2UgcHJvcGVydGllcyBhbmQgY2FsbCBgcmVuZGVyYCB0byB1cGRhdGVcbiAgICogdGhlIHZpZXcgYmFzZWQgb24gdGhlIGRlcGVuZGVuY3kgY2hhbmdlLlxuICAgKlxuICAgKiBGb3IgZXhhbXBsZSwgZm9yIGFuIGBkb20tcmVwZWF0YCB3aXRoIGEgZmlsdGVyIG9mIHRoZSBmb2xsb3dpbmc6XG4gICAqXG4gICAqIGBgYGpzXG4gICAqIGlzRW5naW5lZXI6IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICogICAgIHJldHVybiBpdGVtLnR5cGUgPT0gJ2VuZ2luZWVyJyB8fCBpdGVtLm1hbmFnZXIudHlwZSA9PSAnZW5naW5lZXInO1xuICAgKiB9XG4gICAqIGBgYFxuICAgKlxuICAgKiBUaGVuIHRoZSBgb2JzZXJ2ZWAgcHJvcGVydHkgc2hvdWxkIGJlIGNvbmZpZ3VyZWQgYXMgZm9sbG93czpcbiAgICpcbiAgICogYGBgaHRtbFxuICAgKiA8dGVtcGxhdGUgaXM9XCJkb20tcmVwZWF0XCIgaXRlbXM9XCJ7e2VtcGxveWVlc319XCJcbiAgICogICAgICAgICAgIGZpbHRlcj1cImlzRW5naW5lZXJcIiBvYnNlcnZlPVwidHlwZSBtYW5hZ2VyLnR5cGVcIj5cbiAgICogYGBgXG4gICAqXG4gICAqIEBjdXN0b21FbGVtZW50XG4gICAqIEBwb2x5bWVyXG4gICAqIEBtZW1iZXJvZiBQb2x5bWVyXG4gICAqIEBleHRlbmRzIHtkb21SZXBlYXRCYXNlfVxuICAgKiBAYXBwbGllc01peGluIFBvbHltZXIuT3B0aW9uYWxNdXRhYmxlRGF0YVxuICAgKiBAc3VtbWFyeSBDdXN0b20gZWxlbWVudCBmb3Igc3RhbXBpbmcgaW5zdGFuY2Ugb2YgYSB0ZW1wbGF0ZSBib3VuZCB0b1xuICAgKiAgIGl0ZW1zIGluIGFuIGFycmF5LlxuICAgKi9cbiAgY2xhc3MgRG9tUmVwZWF0IGV4dGVuZHMgZG9tUmVwZWF0QmFzZSB7XG5cbiAgICAvLyBOb3QgbmVlZGVkIHRvIGZpbmQgdGVtcGxhdGU7IGNhbiBiZSByZW1vdmVkIG9uY2UgdGhlIGFuYWx5emVyXG4gICAgLy8gY2FuIGZpbmQgdGhlIHRhZyBuYW1lIGZyb20gY3VzdG9tRWxlbWVudHMuZGVmaW5lIGNhbGxcbiAgICBzdGF0aWMgZ2V0IGlzKCkgeyByZXR1cm4gJ2RvbS1yZXBlYXQnOyB9XG5cbiAgICBzdGF0aWMgZ2V0IHRlbXBsYXRlKCkgeyByZXR1cm4gbnVsbDsgfVxuXG4gICAgc3RhdGljIGdldCBwcm9wZXJ0aWVzKCkge1xuXG4gICAgICAvKipcbiAgICAgICAqIEZpcmVkIHdoZW5ldmVyIERPTSBpcyBhZGRlZCBvciByZW1vdmVkIGJ5IHRoaXMgdGVtcGxhdGUgKGJ5XG4gICAgICAgKiBkZWZhdWx0LCByZW5kZXJpbmcgb2NjdXJzIGxhemlseSkuICBUbyBmb3JjZSBpbW1lZGlhdGUgcmVuZGVyaW5nLCBjYWxsXG4gICAgICAgKiBgcmVuZGVyYC5cbiAgICAgICAqXG4gICAgICAgKiBAZXZlbnQgZG9tLWNoYW5nZVxuICAgICAgICovXG4gICAgICByZXR1cm4ge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbiBhcnJheSBjb250YWluaW5nIGl0ZW1zIGRldGVybWluaW5nIGhvdyBtYW55IGluc3RhbmNlcyBvZiB0aGUgdGVtcGxhdGVcbiAgICAgICAgICogdG8gc3RhbXAgYW5kIHRoYXQgdGhhdCBlYWNoIHRlbXBsYXRlIGluc3RhbmNlIHNob3VsZCBiaW5kIHRvLlxuICAgICAgICAgKi9cbiAgICAgICAgaXRlbXM6IHtcbiAgICAgICAgICB0eXBlOiBBcnJheVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbmFtZSBvZiB0aGUgdmFyaWFibGUgdG8gYWRkIHRvIHRoZSBiaW5kaW5nIHNjb3BlIGZvciB0aGUgYXJyYXlcbiAgICAgICAgICogZWxlbWVudCBhc3NvY2lhdGVkIHdpdGggYSBnaXZlbiB0ZW1wbGF0ZSBpbnN0YW5jZS5cbiAgICAgICAgICovXG4gICAgICAgIGFzOiB7XG4gICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgIHZhbHVlOiAnaXRlbSdcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG5hbWUgb2YgdGhlIHZhcmlhYmxlIHRvIGFkZCB0byB0aGUgYmluZGluZyBzY29wZSB3aXRoIHRoZSBpbmRleFxuICAgICAgICAgKiBvZiB0aGUgaW5zdGFuY2UgaW4gdGhlIHNvcnRlZCBhbmQgZmlsdGVyZWQgbGlzdCBvZiByZW5kZXJlZCBpdGVtcy5cbiAgICAgICAgICogTm90ZSwgZm9yIHRoZSBpbmRleCBpbiB0aGUgYHRoaXMuaXRlbXNgIGFycmF5LCB1c2UgdGhlIHZhbHVlIG9mIHRoZVxuICAgICAgICAgKiBgaXRlbXNJbmRleEFzYCBwcm9wZXJ0eS5cbiAgICAgICAgICovXG4gICAgICAgIGluZGV4QXM6IHtcbiAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgdmFsdWU6ICdpbmRleCdcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG5hbWUgb2YgdGhlIHZhcmlhYmxlIHRvIGFkZCB0byB0aGUgYmluZGluZyBzY29wZSB3aXRoIHRoZSBpbmRleFxuICAgICAgICAgKiBvZiB0aGUgaW5zdGFuY2UgaW4gdGhlIGB0aGlzLml0ZW1zYCBhcnJheS4gTm90ZSwgZm9yIHRoZSBpbmRleCBvZlxuICAgICAgICAgKiB0aGlzIGluc3RhbmNlIGluIHRoZSBzb3J0ZWQgYW5kIGZpbHRlcmVkIGxpc3Qgb2YgcmVuZGVyZWQgaXRlbXMsXG4gICAgICAgICAqIHVzZSB0aGUgdmFsdWUgb2YgdGhlIGBpbmRleEFzYCBwcm9wZXJ0eS5cbiAgICAgICAgICovXG4gICAgICAgIGl0ZW1zSW5kZXhBczoge1xuICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICB2YWx1ZTogJ2l0ZW1zSW5kZXgnXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgZnVuY3Rpb24gdGhhdCBzaG91bGQgZGV0ZXJtaW5lIHRoZSBzb3J0IG9yZGVyIG9mIHRoZSBpdGVtcy4gIFRoaXNcbiAgICAgICAgICogcHJvcGVydHkgc2hvdWxkIGVpdGhlciBiZSBwcm92aWRlZCBhcyBhIHN0cmluZywgaW5kaWNhdGluZyBhIG1ldGhvZFxuICAgICAgICAgKiBuYW1lIG9uIHRoZSBlbGVtZW50J3MgaG9zdCwgb3IgZWxzZSBiZSBhbiBhY3R1YWwgZnVuY3Rpb24uICBUaGVcbiAgICAgICAgICogZnVuY3Rpb24gc2hvdWxkIG1hdGNoIHRoZSBzb3J0IGZ1bmN0aW9uIHBhc3NlZCB0byBgQXJyYXkuc29ydGAuXG4gICAgICAgICAqIFVzaW5nIGEgc29ydCBmdW5jdGlvbiBoYXMgbm8gZWZmZWN0IG9uIHRoZSB1bmRlcmx5aW5nIGBpdGVtc2AgYXJyYXkuXG4gICAgICAgICAqL1xuICAgICAgICBzb3J0OiB7XG4gICAgICAgICAgdHlwZTogRnVuY3Rpb24sXG4gICAgICAgICAgb2JzZXJ2ZXI6ICdfX3NvcnRDaGFuZ2VkJ1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQgdG8gZmlsdGVyIGl0ZW1zIG91dCBvZiB0aGUgdmlldy4gIFRoaXNcbiAgICAgICAgICogcHJvcGVydHkgc2hvdWxkIGVpdGhlciBiZSBwcm92aWRlZCBhcyBhIHN0cmluZywgaW5kaWNhdGluZyBhIG1ldGhvZFxuICAgICAgICAgKiBuYW1lIG9uIHRoZSBlbGVtZW50J3MgaG9zdCwgb3IgZWxzZSBiZSBhbiBhY3R1YWwgZnVuY3Rpb24uICBUaGVcbiAgICAgICAgICogZnVuY3Rpb24gc2hvdWxkIG1hdGNoIHRoZSBzb3J0IGZ1bmN0aW9uIHBhc3NlZCB0byBgQXJyYXkuZmlsdGVyYC5cbiAgICAgICAgICogVXNpbmcgYSBmaWx0ZXIgZnVuY3Rpb24gaGFzIG5vIGVmZmVjdCBvbiB0aGUgdW5kZXJseWluZyBgaXRlbXNgIGFycmF5LlxuICAgICAgICAgKi9cbiAgICAgICAgZmlsdGVyOiB7XG4gICAgICAgICAgdHlwZTogRnVuY3Rpb24sXG4gICAgICAgICAgb2JzZXJ2ZXI6ICdfX2ZpbHRlckNoYW5nZWQnXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZW4gdXNpbmcgYSBgZmlsdGVyYCBvciBgc29ydGAgZnVuY3Rpb24sIHRoZSBgb2JzZXJ2ZWAgcHJvcGVydHlcbiAgICAgICAgICogc2hvdWxkIGJlIHNldCB0byBhIHNwYWNlLXNlcGFyYXRlZCBsaXN0IG9mIHRoZSBuYW1lcyBvZiBpdGVtXG4gICAgICAgICAqIHN1Yi1maWVsZHMgdGhhdCBzaG91bGQgdHJpZ2dlciBhIHJlLXNvcnQgb3IgcmUtZmlsdGVyIHdoZW4gY2hhbmdlZC5cbiAgICAgICAgICogVGhlc2Ugc2hvdWxkIGdlbmVyYWxseSBiZSBmaWVsZHMgb2YgYGl0ZW1gIHRoYXQgdGhlIHNvcnQgb3IgZmlsdGVyXG4gICAgICAgICAqIGZ1bmN0aW9uIGRlcGVuZHMgb24uXG4gICAgICAgICAqL1xuICAgICAgICBvYnNlcnZlOiB7XG4gICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgIG9ic2VydmVyOiAnX19vYnNlcnZlQ2hhbmdlZCdcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogV2hlbiB1c2luZyBhIGBmaWx0ZXJgIG9yIGBzb3J0YCBmdW5jdGlvbiwgdGhlIGBkZWxheWAgcHJvcGVydHlcbiAgICAgICAgICogZGV0ZXJtaW5lcyBhIGRlYm91bmNlIHRpbWUgYWZ0ZXIgYSBjaGFuZ2UgdG8gb2JzZXJ2ZWQgaXRlbVxuICAgICAgICAgKiBwcm9wZXJ0aWVzIHRoYXQgbXVzdCBwYXNzIGJlZm9yZSB0aGUgZmlsdGVyIG9yIHNvcnQgaXMgcmUtcnVuLlxuICAgICAgICAgKiBUaGlzIGlzIHVzZWZ1bCBpbiByYXRlLWxpbWl0aW5nIHNodWZmaW5nIG9mIHRoZSB2aWV3IHdoZW5cbiAgICAgICAgICogaXRlbSBjaGFuZ2VzIG1heSBiZSBmcmVxdWVudC5cbiAgICAgICAgICovXG4gICAgICAgIGRlbGF5OiBOdW1iZXIsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvdW50IG9mIGN1cnJlbnRseSByZW5kZXJlZCBpdGVtcyBhZnRlciBgZmlsdGVyYCAoaWYgYW55KSBoYXMgYmVlbiBhcHBsaWVkLlxuICAgICAgICAgKiBJZiBcImNodW5raW5nIG1vZGVcIiBpcyBlbmFibGVkLCBgcmVuZGVyZWRJdGVtQ291bnRgIGlzIHVwZGF0ZWQgZWFjaCB0aW1lIGFcbiAgICAgICAgICogc2V0IG9mIHRlbXBsYXRlIGluc3RhbmNlcyBpcyByZW5kZXJlZC5cbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIHJlbmRlcmVkSXRlbUNvdW50OiB7XG4gICAgICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgICAgIG5vdGlmeTogdHJ1ZSxcbiAgICAgICAgICByZWFkT25seTogdHJ1ZVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWZpbmVzIGFuIGluaXRpYWwgY291bnQgb2YgdGVtcGxhdGUgaW5zdGFuY2VzIHRvIHJlbmRlciBhZnRlciBzZXR0aW5nXG4gICAgICAgICAqIHRoZSBgaXRlbXNgIGFycmF5LCBiZWZvcmUgdGhlIG5leHQgcGFpbnQsIGFuZCBwdXRzIHRoZSBgZG9tLXJlcGVhdGBcbiAgICAgICAgICogaW50byBcImNodW5raW5nIG1vZGVcIi4gIFRoZSByZW1haW5pbmcgaXRlbXMgd2lsbCBiZSBjcmVhdGVkIGFuZCByZW5kZXJlZFxuICAgICAgICAgKiBpbmNyZW1lbnRhbGx5IGF0IGVhY2ggYW5pbWF0aW9uIGZyYW1lIHRoZXJvZiB1bnRpbCBhbGwgaW5zdGFuY2VzIGhhdmVcbiAgICAgICAgICogYmVlbiByZW5kZXJlZC5cbiAgICAgICAgICovXG4gICAgICAgIGluaXRpYWxDb3VudDoge1xuICAgICAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgICAgICBvYnNlcnZlcjogJ19faW5pdGlhbGl6ZUNodW5raW5nJ1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGVuIGBpbml0aWFsQ291bnRgIGlzIHVzZWQsIHRoaXMgcHJvcGVydHkgZGVmaW5lcyBhIGZyYW1lIHJhdGUgdG9cbiAgICAgICAgICogdGFyZ2V0IGJ5IHRocm90dGxpbmcgdGhlIG51bWJlciBvZiBpbnN0YW5jZXMgcmVuZGVyZWQgZWFjaCBmcmFtZSB0b1xuICAgICAgICAgKiBub3QgZXhjZWVkIHRoZSBidWRnZXQgZm9yIHRoZSB0YXJnZXQgZnJhbWUgcmF0ZS4gIFNldHRpbmcgdGhpcyB0byBhXG4gICAgICAgICAqIGhpZ2hlciBudW1iZXIgd2lsbCBhbGxvdyBsb3dlciBsYXRlbmN5IGFuZCBoaWdoZXIgdGhyb3VnaHB1dCBmb3JcbiAgICAgICAgICogdGhpbmdzIGxpa2UgZXZlbnQgaGFuZGxlcnMsIGJ1dCB3aWxsIHJlc3VsdCBpbiBhIGxvbmdlciB0aW1lIGZvciB0aGVcbiAgICAgICAgICogcmVtYWluaW5nIGl0ZW1zIHRvIGNvbXBsZXRlIHJlbmRlcmluZy5cbiAgICAgICAgICovXG4gICAgICAgIHRhcmdldEZyYW1lcmF0ZToge1xuICAgICAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgICAgICB2YWx1ZTogMjBcbiAgICAgICAgfSxcblxuICAgICAgICBfdGFyZ2V0RnJhbWVUaW1lOiB7XG4gICAgICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgICAgIGNvbXB1dGVkOiAnX19jb21wdXRlRnJhbWVUaW1lKHRhcmdldEZyYW1lcmF0ZSknXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgfVxuXG4gICAgc3RhdGljIGdldCBvYnNlcnZlcnMoKSB7XG4gICAgICByZXR1cm4gWyAnX19pdGVtc0NoYW5nZWQoaXRlbXMuKiknIF1cbiAgICB9XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgIHN1cGVyKCk7XG4gICAgICB0aGlzLl9faW5zdGFuY2VzID0gW107XG4gICAgICB0aGlzLl9fbGltaXQgPSBJbmZpbml0eTtcbiAgICAgIHRoaXMuX19wb29sID0gW107XG4gICAgICB0aGlzLl9fcmVuZGVyRGVib3VuY2VyID0gbnVsbDtcbiAgICAgIHRoaXMuX19pdGVtc0lkeFRvSW5zdElkeCA9IHt9O1xuICAgICAgdGhpcy5fX2NodW5rQ291bnQgPSBudWxsO1xuICAgICAgdGhpcy5fX2xhc3RDaHVua1RpbWUgPSBudWxsO1xuICAgICAgdGhpcy5fX3NvcnRGbiA9IG51bGw7XG4gICAgICB0aGlzLl9fZmlsdGVyRm4gPSBudWxsO1xuICAgICAgdGhpcy5fX29ic2VydmVQYXRocyA9IG51bGw7XG4gICAgICB0aGlzLl9fY3RvciA9IG51bGw7XG4gICAgICB0aGlzLl9faXNEZXRhY2hlZCA9IHRydWU7XG4gICAgICB0aGlzLnRlbXBsYXRlID0gbnVsbDtcbiAgICB9XG5cbiAgICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgIHN1cGVyLmRpc2Nvbm5lY3RlZENhbGxiYWNrKCk7XG4gICAgICB0aGlzLl9faXNEZXRhY2hlZCA9IHRydWU7XG4gICAgICBmb3IgKGxldCBpPTA7IGk8dGhpcy5fX2luc3RhbmNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLl9fZGV0YWNoSW5zdGFuY2UoaSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgICBzdXBlci5jb25uZWN0ZWRDYWxsYmFjaygpO1xuICAgICAgLy8gb25seSBwZXJmb3JtIGF0dGFjaG1lbnQgaWYgdGhlIGVsZW1lbnQgd2FzIHByZXZpb3VzbHkgZGV0YWNoZWQuXG4gICAgICBpZiAodGhpcy5fX2lzRGV0YWNoZWQpIHtcbiAgICAgICAgdGhpcy5fX2lzRGV0YWNoZWQgPSBmYWxzZTtcbiAgICAgICAgbGV0IHBhcmVudCA9IHRoaXMucGFyZW50Tm9kZTtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPHRoaXMuX19pbnN0YW5jZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB0aGlzLl9fYXR0YWNoSW5zdGFuY2UoaSwgcGFyZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIF9fZW5zdXJlVGVtcGxhdGl6ZWQoKSB7XG4gICAgICAvLyBUZW1wbGF0aXppbmcgKGdlbmVyYXRpbmcgdGhlIGluc3RhbmNlIGNvbnN0cnVjdG9yKSBuZWVkcyB0byB3YWl0XG4gICAgICAvLyB1bnRpbCByZWFkeSwgc2luY2Ugd29uJ3QgaGF2ZSBpdHMgdGVtcGxhdGUgY29udGVudCBoYW5kZWQgYmFjayB0b1xuICAgICAgLy8gaXQgdW50aWwgdGhlblxuICAgICAgaWYgKCF0aGlzLl9fY3Rvcikge1xuICAgICAgICBsZXQgdGVtcGxhdGUgPSB0aGlzLnRlbXBsYXRlID0gdGhpcy5xdWVyeVNlbGVjdG9yKCd0ZW1wbGF0ZScpO1xuICAgICAgICBpZiAoIXRlbXBsYXRlKSB7XG4gICAgICAgICAgLy8gLy8gV2FpdCB1bnRpbCBjaGlsZExpc3QgY2hhbmdlcyBhbmQgdGVtcGxhdGUgc2hvdWxkIGJlIHRoZXJlIGJ5IHRoZW5cbiAgICAgICAgICBsZXQgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcigoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5xdWVyeVNlbGVjdG9yKCd0ZW1wbGF0ZScpKSB7XG4gICAgICAgICAgICAgIG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgICAgdGhpcy5fX3JlbmRlcigpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkb20tcmVwZWF0IHJlcXVpcmVzIGEgPHRlbXBsYXRlPiBjaGlsZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgICAgb2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLCB7Y2hpbGRMaXN0OiB0cnVlfSk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRlbXBsYXRlIGluc3RhbmNlIHByb3BzIHRoYXQgc2hvdWxkIGJlIGV4Y2x1ZGVkIGZyb20gZm9yd2FyZGluZ1xuICAgICAgICBsZXQgaW5zdGFuY2VQcm9wcyA9IHt9O1xuICAgICAgICBpbnN0YW5jZVByb3BzW3RoaXMuYXNdID0gdHJ1ZTtcbiAgICAgICAgaW5zdGFuY2VQcm9wc1t0aGlzLmluZGV4QXNdID0gdHJ1ZTtcbiAgICAgICAgaW5zdGFuY2VQcm9wc1t0aGlzLml0ZW1zSW5kZXhBc10gPSB0cnVlO1xuICAgICAgICB0aGlzLl9fY3RvciA9IFBvbHltZXIuVGVtcGxhdGl6ZS50ZW1wbGF0aXplKHRlbXBsYXRlLCB0aGlzLCB7XG4gICAgICAgICAgbXV0YWJsZURhdGE6IHRoaXMubXV0YWJsZURhdGEsXG4gICAgICAgICAgcGFyZW50TW9kZWw6IHRydWUsXG4gICAgICAgICAgaW5zdGFuY2VQcm9wczogaW5zdGFuY2VQcm9wcyxcbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBAdGhpcyB7dGhpc31cbiAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcCBQcm9wZXJ0eSB0byBzZXRcbiAgICAgICAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIHNldCBwcm9wZXJ0eSB0b1xuICAgICAgICAgICAqL1xuICAgICAgICAgIGZvcndhcmRIb3N0UHJvcDogZnVuY3Rpb24ocHJvcCwgdmFsdWUpIHtcbiAgICAgICAgICAgIGxldCBpJCA9IHRoaXMuX19pbnN0YW5jZXM7XG4gICAgICAgICAgICBmb3IgKGxldCBpPTAsIGluc3Q7IChpPGkkLmxlbmd0aCkgJiYgKGluc3Q9aSRbaV0pOyBpKyspIHtcbiAgICAgICAgICAgICAgaW5zdC5mb3J3YXJkSG9zdFByb3AocHJvcCwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogQHRoaXMge3RoaXN9XG4gICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGluc3QgSW5zdGFuY2UgdG8gbm90aWZ5XG4gICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3AgUHJvcGVydHkgdG8gbm90aWZ5XG4gICAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byBub3RpZnlcbiAgICAgICAgICAgKi9cbiAgICAgICAgICBub3RpZnlJbnN0YW5jZVByb3A6IGZ1bmN0aW9uKGluc3QsIHByb3AsIHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoUG9seW1lci5QYXRoLm1hdGNoZXModGhpcy5hcywgcHJvcCkpIHtcbiAgICAgICAgICAgICAgbGV0IGlkeCA9IGluc3RbdGhpcy5pdGVtc0luZGV4QXNdO1xuICAgICAgICAgICAgICBpZiAocHJvcCA9PSB0aGlzLmFzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pdGVtc1tpZHhdID0gdmFsdWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbGV0IHBhdGggPSBQb2x5bWVyLlBhdGgudHJhbnNsYXRlKHRoaXMuYXMsICdpdGVtcy4nICsgaWR4LCBwcm9wKTtcbiAgICAgICAgICAgICAgdGhpcy5ub3RpZnlQYXRoKHBhdGgsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgX19nZXRNZXRob2RIb3N0KCkge1xuICAgICAgLy8gVGVjaG5pY2FsbHkgdGhpcyBzaG91bGQgYmUgdGhlIG93bmVyIG9mIHRoZSBvdXRlcm1vc3QgdGVtcGxhdGUuXG4gICAgICAvLyBJbiBzaGFkb3cgZG9tLCB0aGlzIGlzIGFsd2F5cyBnZXRSb290Tm9kZSgpLmhvc3QsIGJ1dCB3ZSBjYW5cbiAgICAgIC8vIGFwcHJveGltYXRlIHRoaXMgdmlhIGNvb3BlcmF0aW9uIHdpdGggb3VyIGRhdGFIb3N0IGFsd2F5cyBzZXR0aW5nXG4gICAgICAvLyBgX21ldGhvZEhvc3RgIGFzIGxvbmcgYXMgdGhlcmUgd2VyZSBiaW5kaW5ncyAob3IgaWQncykgb24gdGhpc1xuICAgICAgLy8gaW5zdGFuY2UgY2F1c2luZyBpdCB0byBnZXQgYSBkYXRhSG9zdC5cbiAgICAgIHJldHVybiB0aGlzLl9fZGF0YUhvc3QuX21ldGhvZEhvc3QgfHwgdGhpcy5fX2RhdGFIb3N0O1xuICAgIH1cblxuICAgIF9fc29ydENoYW5nZWQoc29ydCkge1xuICAgICAgbGV0IG1ldGhvZEhvc3QgPSB0aGlzLl9fZ2V0TWV0aG9kSG9zdCgpO1xuICAgICAgdGhpcy5fX3NvcnRGbiA9IHNvcnQgJiYgKHR5cGVvZiBzb3J0ID09ICdmdW5jdGlvbicgPyBzb3J0IDpcbiAgICAgICAgZnVuY3Rpb24oKSB7IHJldHVybiBtZXRob2RIb3N0W3NvcnRdLmFwcGx5KG1ldGhvZEhvc3QsIGFyZ3VtZW50cyk7IH0pO1xuICAgICAgaWYgKHRoaXMuaXRlbXMpIHtcbiAgICAgICAgdGhpcy5fX2RlYm91bmNlUmVuZGVyKHRoaXMuX19yZW5kZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIF9fZmlsdGVyQ2hhbmdlZChmaWx0ZXIpIHtcbiAgICAgIGxldCBtZXRob2RIb3N0ID0gdGhpcy5fX2dldE1ldGhvZEhvc3QoKTtcbiAgICAgIHRoaXMuX19maWx0ZXJGbiA9IGZpbHRlciAmJiAodHlwZW9mIGZpbHRlciA9PSAnZnVuY3Rpb24nID8gZmlsdGVyIDpcbiAgICAgICAgZnVuY3Rpb24oKSB7IHJldHVybiBtZXRob2RIb3N0W2ZpbHRlcl0uYXBwbHkobWV0aG9kSG9zdCwgYXJndW1lbnRzKTsgfSk7XG4gICAgICBpZiAodGhpcy5pdGVtcykge1xuICAgICAgICB0aGlzLl9fZGVib3VuY2VSZW5kZXIodGhpcy5fX3JlbmRlcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgX19jb21wdXRlRnJhbWVUaW1lKHJhdGUpIHtcbiAgICAgIHJldHVybiBNYXRoLmNlaWwoMTAwMC9yYXRlKTtcbiAgICB9XG5cbiAgICBfX2luaXRpYWxpemVDaHVua2luZygpIHtcbiAgICAgIGlmICh0aGlzLmluaXRpYWxDb3VudCkge1xuICAgICAgICB0aGlzLl9fbGltaXQgPSB0aGlzLmluaXRpYWxDb3VudDtcbiAgICAgICAgdGhpcy5fX2NodW5rQ291bnQgPSB0aGlzLmluaXRpYWxDb3VudDtcbiAgICAgICAgdGhpcy5fX2xhc3RDaHVua1RpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfX3RyeVJlbmRlckNodW5rKCkge1xuICAgICAgLy8gRGVib3VuY2VkIHNvIHRoYXQgbXVsdGlwbGUgY2FsbHMgdGhyb3VnaCBgX3JlbmRlcmAgYmV0d2VlbiBhbmltYXRpb25cbiAgICAgIC8vIGZyYW1lcyBvbmx5IHF1ZXVlIG9uZSBuZXcgckFGIChlLmcuIGFycmF5IG11dGF0aW9uICYgY2h1bmtlZCByZW5kZXIpXG4gICAgICBpZiAodGhpcy5pdGVtcyAmJiB0aGlzLl9fbGltaXQgPCB0aGlzLml0ZW1zLmxlbmd0aCkge1xuICAgICAgICB0aGlzLl9fZGVib3VuY2VSZW5kZXIodGhpcy5fX3JlcXVlc3RSZW5kZXJDaHVuayk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgX19yZXF1ZXN0UmVuZGVyQ2h1bmsoKSB7XG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCk9PnRoaXMuX19yZW5kZXJDaHVuaygpKTtcbiAgICB9XG5cbiAgICBfX3JlbmRlckNodW5rKCkge1xuICAgICAgLy8gU2ltcGxlIGF1dG8gY2h1bmtTaXplIHRocm90dGxpbmcgYWxnb3JpdGhtIGJhc2VkIG9uIGZlZWRiYWNrIGxvb3A6XG4gICAgICAvLyBtZWFzdXJlIGFjdHVhbCB0aW1lIGJldHdlZW4gZnJhbWVzIGFuZCBzY2FsZSBjaHVuayBjb3VudCBieSByYXRpb1xuICAgICAgLy8gb2YgdGFyZ2V0L2FjdHVhbCBmcmFtZSB0aW1lXG4gICAgICBsZXQgY3VyckNodW5rVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgbGV0IHJhdGlvID0gdGhpcy5fdGFyZ2V0RnJhbWVUaW1lIC8gKGN1cnJDaHVua1RpbWUgLSB0aGlzLl9fbGFzdENodW5rVGltZSk7XG4gICAgICB0aGlzLl9fY2h1bmtDb3VudCA9IE1hdGgucm91bmQodGhpcy5fX2NodW5rQ291bnQgKiByYXRpbykgfHwgMTtcbiAgICAgIHRoaXMuX19saW1pdCArPSB0aGlzLl9fY2h1bmtDb3VudDtcbiAgICAgIHRoaXMuX19sYXN0Q2h1bmtUaW1lID0gY3VyckNodW5rVGltZTtcbiAgICAgIHRoaXMuX19kZWJvdW5jZVJlbmRlcih0aGlzLl9fcmVuZGVyKTtcbiAgICB9XG5cbiAgICBfX29ic2VydmVDaGFuZ2VkKCkge1xuICAgICAgdGhpcy5fX29ic2VydmVQYXRocyA9IHRoaXMub2JzZXJ2ZSAmJlxuICAgICAgICB0aGlzLm9ic2VydmUucmVwbGFjZSgnLionLCAnLicpLnNwbGl0KCcgJyk7XG4gICAgfVxuXG4gICAgX19pdGVtc0NoYW5nZWQoY2hhbmdlKSB7XG4gICAgICBpZiAodGhpcy5pdGVtcyAmJiAhQXJyYXkuaXNBcnJheSh0aGlzLml0ZW1zKSkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ2RvbS1yZXBlYXQgZXhwZWN0ZWQgYXJyYXkgZm9yIGBpdGVtc2AsIGZvdW5kJywgdGhpcy5pdGVtcyk7XG4gICAgICB9XG4gICAgICAvLyBJZiBwYXRoIHdhcyB0byBhbiBpdGVtIChlLmcuICdpdGVtcy4zJyBvciAnaXRlbXMuMy5mb28nKSwgZm9yd2FyZCB0aGVcbiAgICAgIC8vIHBhdGggdG8gdGhhdCBpbnN0YW5jZSBzeW5jaHJvbm91c2x5IChyZXR1bnMgZmFsc2UgZm9yIG5vbi1pdGVtIHBhdGhzKVxuICAgICAgaWYgKCF0aGlzLl9faGFuZGxlSXRlbVBhdGgoY2hhbmdlLnBhdGgsIGNoYW5nZS52YWx1ZSkpIHtcbiAgICAgICAgLy8gT3RoZXJ3aXNlLCB0aGUgYXJyYXkgd2FzIHJlc2V0ICgnaXRlbXMnKSBvciBzcGxpY2VkICgnaXRlbXMuc3BsaWNlcycpLFxuICAgICAgICAvLyBzbyBxdWV1ZSBhIGZ1bGwgcmVmcmVzaFxuICAgICAgICB0aGlzLl9faW5pdGlhbGl6ZUNodW5raW5nKCk7XG4gICAgICAgIHRoaXMuX19kZWJvdW5jZVJlbmRlcih0aGlzLl9fcmVuZGVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfX2hhbmRsZU9ic2VydmVkUGF0aHMocGF0aCkge1xuICAgICAgaWYgKHRoaXMuX19vYnNlcnZlUGF0aHMpIHtcbiAgICAgICAgcGF0aCA9IHBhdGguc3Vic3RyaW5nKHBhdGguaW5kZXhPZignLicpICsgMSk7XG4gICAgICAgIGxldCBwYXRocyA9IHRoaXMuX19vYnNlcnZlUGF0aHM7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxwYXRocy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChwYXRoLmluZGV4T2YocGF0aHNbaV0pID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLl9fZGVib3VuY2VSZW5kZXIodGhpcy5fX3JlbmRlciwgdGhpcy5kZWxheSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKHRoaXM6RG9tUmVwZWF0KX0gZm4gRnVuY3Rpb24gdG8gZGVib3VuY2UuXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBkZWxheSBEZWxheSBpbiBtcyB0byBkZWJvdW5jZSBieS5cbiAgICAgKi9cbiAgICBfX2RlYm91bmNlUmVuZGVyKGZuLCBkZWxheSA9IDApIHtcbiAgICAgIHRoaXMuX19yZW5kZXJEZWJvdW5jZXIgPSBQb2x5bWVyLkRlYm91bmNlci5kZWJvdW5jZShcbiAgICAgICAgICAgIHRoaXMuX19yZW5kZXJEZWJvdW5jZXJcbiAgICAgICAgICAsIGRlbGF5ID4gMCA/IFBvbHltZXIuQXN5bmMudGltZU91dC5hZnRlcihkZWxheSkgOiBQb2x5bWVyLkFzeW5jLm1pY3JvVGFza1xuICAgICAgICAgICwgZm4uYmluZCh0aGlzKSk7XG4gICAgICBQb2x5bWVyLmVucXVldWVEZWJvdW5jZXIodGhpcy5fX3JlbmRlckRlYm91bmNlcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRm9yY2VzIHRoZSBlbGVtZW50IHRvIHJlbmRlciBpdHMgY29udGVudC4gTm9ybWFsbHkgcmVuZGVyaW5nIGlzXG4gICAgICogYXN5bmNocm9ub3VzIHRvIGEgcHJvdm9raW5nIGNoYW5nZS4gVGhpcyBpcyBkb25lIGZvciBlZmZpY2llbmN5IHNvXG4gICAgICogdGhhdCBtdWx0aXBsZSBjaGFuZ2VzIHRyaWdnZXIgb25seSBhIHNpbmdsZSByZW5kZXIuIFRoZSByZW5kZXIgbWV0aG9kXG4gICAgICogc2hvdWxkIGJlIGNhbGxlZCBpZiwgZm9yIGV4YW1wbGUsIHRlbXBsYXRlIHJlbmRlcmluZyBpcyByZXF1aXJlZCB0b1xuICAgICAqIHZhbGlkYXRlIGFwcGxpY2F0aW9uIHN0YXRlLlxuICAgICAqL1xuICAgIHJlbmRlcigpIHtcbiAgICAgIC8vIFF1ZXVlIHRoaXMgcmVwZWF0ZXIsIHRoZW4gZmx1c2ggYWxsIGluIG9yZGVyXG4gICAgICB0aGlzLl9fZGVib3VuY2VSZW5kZXIodGhpcy5fX3JlbmRlcik7XG4gICAgICBQb2x5bWVyLmZsdXNoKCk7XG4gICAgfVxuXG4gICAgX19yZW5kZXIoKSB7XG4gICAgICBpZiAoIXRoaXMuX19lbnN1cmVUZW1wbGF0aXplZCgpKSB7XG4gICAgICAgIC8vIE5vIHRlbXBsYXRlIGZvdW5kIHlldFxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl9fYXBwbHlGdWxsUmVmcmVzaCgpO1xuICAgICAgLy8gUmVzZXQgdGhlIHBvb2xcbiAgICAgIC8vIFRPRE8oa3NjaGFhZik6IFJldXNlIHBvb2wgYWNyb3NzIHR1cm5zIGFuZCBuZXN0ZWQgdGVtcGxhdGVzXG4gICAgICAvLyBOb3cgdGhhdCBvYmplY3RzL2FycmF5cyBhcmUgcmUtZXZhbHVhdGVkIHdoZW4gc2V0LCB3ZSBjYW4gc2FmZWx5XG4gICAgICAvLyByZXVzZSBwb29sZWQgaW5zdGFuY2VzIGFjcm9zcyB0dXJucywgaG93ZXZlciB3ZSBzdGlsbCBuZWVkIHRvIGRlY2lkZVxuICAgICAgLy8gc2VtYW50aWNzIHJlZ2FyZGluZyBob3cgbG9uZyB0byBob2xkLCBob3cgbWFueSB0byBob2xkLCBldGMuXG4gICAgICB0aGlzLl9fcG9vbC5sZW5ndGggPSAwO1xuICAgICAgLy8gU2V0IHJlbmRlcmVkIGl0ZW0gY291bnRcbiAgICAgIHRoaXMuX3NldFJlbmRlcmVkSXRlbUNvdW50KHRoaXMuX19pbnN0YW5jZXMubGVuZ3RoKTtcbiAgICAgIC8vIE5vdGlmeSB1c2Vyc1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnZG9tLWNoYW5nZScsIHtcbiAgICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgICAgY29tcG9zZWQ6IHRydWVcbiAgICAgIH0pKTtcbiAgICAgIC8vIENoZWNrIHRvIHNlZSBpZiB3ZSBuZWVkIHRvIHJlbmRlciBtb3JlIGl0ZW1zXG4gICAgICB0aGlzLl9fdHJ5UmVuZGVyQ2h1bmsoKTtcbiAgICB9XG5cbiAgICBfX2FwcGx5RnVsbFJlZnJlc2goKSB7XG4gICAgICBsZXQgaXRlbXMgPSB0aGlzLml0ZW1zIHx8IFtdO1xuICAgICAgbGV0IGlzbnRJZHhUb0l0ZW1zSWR4ID0gbmV3IEFycmF5KGl0ZW1zLmxlbmd0aCk7XG4gICAgICBmb3IgKGxldCBpPTA7IGk8aXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaXNudElkeFRvSXRlbXNJZHhbaV0gPSBpO1xuICAgICAgfVxuICAgICAgLy8gQXBwbHkgdXNlciBmaWx0ZXJcbiAgICAgIGlmICh0aGlzLl9fZmlsdGVyRm4pIHtcbiAgICAgICAgaXNudElkeFRvSXRlbXNJZHggPSBpc250SWR4VG9JdGVtc0lkeC5maWx0ZXIoKGksIGlkeCwgYXJyYXkpID0+XG4gICAgICAgICAgdGhpcy5fX2ZpbHRlckZuKGl0ZW1zW2ldLCBpZHgsIGFycmF5KSk7XG4gICAgICB9XG4gICAgICAvLyBBcHBseSB1c2VyIHNvcnRcbiAgICAgIGlmICh0aGlzLl9fc29ydEZuKSB7XG4gICAgICAgIGlzbnRJZHhUb0l0ZW1zSWR4LnNvcnQoKGEsIGIpID0+IHRoaXMuX19zb3J0Rm4oaXRlbXNbYV0sIGl0ZW1zW2JdKSk7XG4gICAgICB9XG4gICAgICAvLyBpdGVtcy0+aW5zdCBtYXAga2VwdCBmb3IgaXRlbSBwYXRoIGZvcndhcmRpbmdcbiAgICAgIGNvbnN0IGl0ZW1zSWR4VG9JbnN0SWR4ID0gdGhpcy5fX2l0ZW1zSWR4VG9JbnN0SWR4ID0ge307XG4gICAgICBsZXQgaW5zdElkeCA9IDA7XG4gICAgICAvLyBHZW5lcmF0ZSBpbnN0YW5jZXMgYW5kIGFzc2lnbiBpdGVtc1xuICAgICAgY29uc3QgbGltaXQgPSBNYXRoLm1pbihpc250SWR4VG9JdGVtc0lkeC5sZW5ndGgsIHRoaXMuX19saW1pdCk7XG4gICAgICBmb3IgKDsgaW5zdElkeDxsaW1pdDsgaW5zdElkeCsrKSB7XG4gICAgICAgIGxldCBpbnN0ID0gdGhpcy5fX2luc3RhbmNlc1tpbnN0SWR4XTtcbiAgICAgICAgbGV0IGl0ZW1JZHggPSBpc250SWR4VG9JdGVtc0lkeFtpbnN0SWR4XTtcbiAgICAgICAgbGV0IGl0ZW0gPSBpdGVtc1tpdGVtSWR4XTtcbiAgICAgICAgaXRlbXNJZHhUb0luc3RJZHhbaXRlbUlkeF0gPSBpbnN0SWR4O1xuICAgICAgICBpZiAoaW5zdCAmJiBpbnN0SWR4IDwgdGhpcy5fX2xpbWl0KSB7XG4gICAgICAgICAgaW5zdC5fc2V0UGVuZGluZ1Byb3BlcnR5KHRoaXMuYXMsIGl0ZW0pO1xuICAgICAgICAgIGluc3QuX3NldFBlbmRpbmdQcm9wZXJ0eSh0aGlzLmluZGV4QXMsIGluc3RJZHgpO1xuICAgICAgICAgIGluc3QuX3NldFBlbmRpbmdQcm9wZXJ0eSh0aGlzLml0ZW1zSW5kZXhBcywgaXRlbUlkeCk7XG4gICAgICAgICAgaW5zdC5fZmx1c2hQcm9wZXJ0aWVzKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fX2luc2VydEluc3RhbmNlKGl0ZW0sIGluc3RJZHgsIGl0ZW1JZHgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBSZW1vdmUgYW55IGV4dHJhIGluc3RhbmNlcyBmcm9tIHByZXZpb3VzIHN0YXRlXG4gICAgICBmb3IgKGxldCBpPXRoaXMuX19pbnN0YW5jZXMubGVuZ3RoLTE7IGk+PWluc3RJZHg7IGktLSkge1xuICAgICAgICB0aGlzLl9fZGV0YWNoQW5kUmVtb3ZlSW5zdGFuY2UoaSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgX19kZXRhY2hJbnN0YW5jZShpZHgpIHtcbiAgICAgIGxldCBpbnN0ID0gdGhpcy5fX2luc3RhbmNlc1tpZHhdO1xuICAgICAgZm9yIChsZXQgaT0wOyBpPGluc3QuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGVsID0gaW5zdC5jaGlsZHJlbltpXTtcbiAgICAgICAgaW5zdC5yb290LmFwcGVuZENoaWxkKGVsKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpbnN0O1xuICAgIH1cblxuICAgIF9fYXR0YWNoSW5zdGFuY2UoaWR4LCBwYXJlbnQpIHtcbiAgICAgIGxldCBpbnN0ID0gdGhpcy5fX2luc3RhbmNlc1tpZHhdO1xuICAgICAgcGFyZW50Lmluc2VydEJlZm9yZShpbnN0LnJvb3QsIHRoaXMpO1xuICAgIH1cblxuICAgIF9fZGV0YWNoQW5kUmVtb3ZlSW5zdGFuY2UoaWR4KSB7XG4gICAgICBsZXQgaW5zdCA9IHRoaXMuX19kZXRhY2hJbnN0YW5jZShpZHgpO1xuICAgICAgaWYgKGluc3QpIHtcbiAgICAgICAgdGhpcy5fX3Bvb2wucHVzaChpbnN0KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX19pbnN0YW5jZXMuc3BsaWNlKGlkeCwgMSk7XG4gICAgfVxuXG4gICAgX19zdGFtcEluc3RhbmNlKGl0ZW0sIGluc3RJZHgsIGl0ZW1JZHgpIHtcbiAgICAgIGxldCBtb2RlbCA9IHt9O1xuICAgICAgbW9kZWxbdGhpcy5hc10gPSBpdGVtO1xuICAgICAgbW9kZWxbdGhpcy5pbmRleEFzXSA9IGluc3RJZHg7XG4gICAgICBtb2RlbFt0aGlzLml0ZW1zSW5kZXhBc10gPSBpdGVtSWR4O1xuICAgICAgcmV0dXJuIG5ldyB0aGlzLl9fY3Rvcihtb2RlbCk7XG4gICAgfVxuXG4gICAgX19pbnNlcnRJbnN0YW5jZShpdGVtLCBpbnN0SWR4LCBpdGVtSWR4KSB7XG4gICAgICBsZXQgaW5zdCA9IHRoaXMuX19wb29sLnBvcCgpO1xuICAgICAgaWYgKGluc3QpIHtcbiAgICAgICAgLy8gVE9ETyhrc2NoYWFmKTogSWYgdGhlIHBvb2wgaXMgc2hhcmVkIGFjcm9zcyB0dXJucywgaG9zdFByb3BzXG4gICAgICAgIC8vIG5lZWQgdG8gYmUgcmUtc2V0IHRvIHJldXNlZCBpbnN0YW5jZXMgaW4gYWRkaXRpb24gdG8gaXRlbVxuICAgICAgICBpbnN0Ll9zZXRQZW5kaW5nUHJvcGVydHkodGhpcy5hcywgaXRlbSk7XG4gICAgICAgIGluc3QuX3NldFBlbmRpbmdQcm9wZXJ0eSh0aGlzLmluZGV4QXMsIGluc3RJZHgpO1xuICAgICAgICBpbnN0Ll9zZXRQZW5kaW5nUHJvcGVydHkodGhpcy5pdGVtc0luZGV4QXMsIGl0ZW1JZHgpO1xuICAgICAgICBpbnN0Ll9mbHVzaFByb3BlcnRpZXMoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluc3QgPSB0aGlzLl9fc3RhbXBJbnN0YW5jZShpdGVtLCBpbnN0SWR4LCBpdGVtSWR4KTtcbiAgICAgIH1cbiAgICAgIGxldCBiZWZvcmVSb3cgPSB0aGlzLl9faW5zdGFuY2VzW2luc3RJZHggKyAxXTtcbiAgICAgIGxldCBiZWZvcmVOb2RlID0gYmVmb3JlUm93ID8gYmVmb3JlUm93LmNoaWxkcmVuWzBdIDogdGhpcztcbiAgICAgIHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoaW5zdC5yb290LCBiZWZvcmVOb2RlKTtcbiAgICAgIHRoaXMuX19pbnN0YW5jZXNbaW5zdElkeF0gPSBpbnN0O1xuICAgICAgcmV0dXJuIGluc3Q7XG4gICAgfVxuXG4gICAgLy8gSW1wbGVtZW50cyBleHRlbnNpb24gcG9pbnQgZnJvbSBUZW1wbGF0aXplIG1peGluXG4gICAgX3Nob3dIaWRlQ2hpbGRyZW4oaGlkZGVuKSB7XG4gICAgICBmb3IgKGxldCBpPTA7IGk8dGhpcy5fX2luc3RhbmNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLl9faW5zdGFuY2VzW2ldLl9zaG93SGlkZUNoaWxkcmVuKGhpZGRlbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ2FsbGVkIGFzIGEgc2lkZSBlZmZlY3Qgb2YgYSBob3N0IGl0ZW1zLjxrZXk+LjxwYXRoPiBwYXRoIGNoYW5nZSxcbiAgICAvLyByZXNwb25zaWJsZSBmb3Igbm90aWZ5aW5nIGl0ZW0uPHBhdGg+IGNoYW5nZXMgdG8gaW5zdCBmb3Iga2V5XG4gICAgX19oYW5kbGVJdGVtUGF0aChwYXRoLCB2YWx1ZSkge1xuICAgICAgbGV0IGl0ZW1zUGF0aCA9IHBhdGguc2xpY2UoNik7IC8vICdpdGVtcy4nLmxlbmd0aCA9PSA2XG4gICAgICBsZXQgZG90ID0gaXRlbXNQYXRoLmluZGV4T2YoJy4nKTtcbiAgICAgIGxldCBpdGVtc0lkeCA9IGRvdCA8IDAgPyBpdGVtc1BhdGggOiBpdGVtc1BhdGguc3Vic3RyaW5nKDAsIGRvdCk7XG4gICAgICAvLyBJZiBwYXRoIHdhcyBpbmRleCBpbnRvIGFycmF5Li4uXG4gICAgICBpZiAoaXRlbXNJZHggPT0gcGFyc2VJbnQoaXRlbXNJZHgsIDEwKSkge1xuICAgICAgICBsZXQgaXRlbVN1YlBhdGggPSBkb3QgPCAwID8gJycgOiBpdGVtc1BhdGguc3Vic3RyaW5nKGRvdCsxKTtcbiAgICAgICAgLy8gSWYgdGhlIHBhdGggaXMgb2JzZXJ2ZWQsIGl0IHdpbGwgdHJpZ2dlciBhIGZ1bGwgcmVmcmVzaFxuICAgICAgICB0aGlzLl9faGFuZGxlT2JzZXJ2ZWRQYXRocyhpdGVtU3ViUGF0aCk7XG4gICAgICAgIC8vIE5vdGUsIGV2ZW4gaWYgYSBydWxsIHJlZnJlc2ggaXMgdHJpZ2dlcmVkLCBhbHdheXMgZG8gdGhlIHBhdGhcbiAgICAgICAgLy8gbm90aWZpY2F0aW9uIGJlY2F1c2UgdW5sZXNzIG11dGFibGVEYXRhIGlzIHVzZWQgZm9yIGRvbS1yZXBlYXRcbiAgICAgICAgLy8gYW5kIGFsbCBlbGVtZW50cyBpbiB0aGUgaW5zdGFuY2Ugc3VidHJlZSwgYSBmdWxsIHJlZnJlc2ggbWF5XG4gICAgICAgIC8vIG5vdCB0cmlnZ2VyIHRoZSBwcm9wZXIgdXBkYXRlLlxuICAgICAgICBsZXQgaW5zdElkeCA9IHRoaXMuX19pdGVtc0lkeFRvSW5zdElkeFtpdGVtc0lkeF07XG4gICAgICAgIGxldCBpbnN0ID0gdGhpcy5fX2luc3RhbmNlc1tpbnN0SWR4XTtcbiAgICAgICAgaWYgKGluc3QpIHtcbiAgICAgICAgICBsZXQgaXRlbVBhdGggPSB0aGlzLmFzICsgKGl0ZW1TdWJQYXRoID8gJy4nICsgaXRlbVN1YlBhdGggOiAnJyk7XG4gICAgICAgICAgLy8gVGhpcyBpcyBlZmZlY3RpdmVseSBgbm90aWZ5UGF0aGAsIGJ1dCBhdm9pZHMgc29tZSBvZiB0aGUgb3ZlcmhlYWRcbiAgICAgICAgICAvLyBvZiB0aGUgcHVibGljIEFQSVxuICAgICAgICAgIGluc3QuX3NldFBlbmRpbmdQcm9wZXJ0eU9yUGF0aChpdGVtUGF0aCwgdmFsdWUsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICBpbnN0Ll9mbHVzaFByb3BlcnRpZXMoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBpdGVtIGFzc29jaWF0ZWQgd2l0aCBhIGdpdmVuIGVsZW1lbnQgc3RhbXBlZCBieVxuICAgICAqIHRoaXMgYGRvbS1yZXBlYXRgLlxuICAgICAqXG4gICAgICogTm90ZSwgdG8gbW9kaWZ5IHN1Yi1wcm9wZXJ0aWVzIG9mIHRoZSBpdGVtLFxuICAgICAqIGBtb2RlbEZvckVsZW1lbnQoZWwpLnNldCgnaXRlbS48c3ViLXByb3A+JywgdmFsdWUpYFxuICAgICAqIHNob3VsZCBiZSB1c2VkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgRWxlbWVudCBmb3Igd2hpY2ggdG8gcmV0dXJuIHRoZSBpdGVtLlxuICAgICAqIEByZXR1cm4geyp9IEl0ZW0gYXNzb2NpYXRlZCB3aXRoIHRoZSBlbGVtZW50LlxuICAgICAqL1xuICAgIGl0ZW1Gb3JFbGVtZW50KGVsKSB7XG4gICAgICBsZXQgaW5zdGFuY2UgPSB0aGlzLm1vZGVsRm9yRWxlbWVudChlbCk7XG4gICAgICByZXR1cm4gaW5zdGFuY2UgJiYgaW5zdGFuY2VbdGhpcy5hc107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgaW5zdCBpbmRleCBmb3IgYSBnaXZlbiBlbGVtZW50IHN0YW1wZWQgYnkgdGhpcyBgZG9tLXJlcGVhdGAuXG4gICAgICogSWYgYHNvcnRgIGlzIHByb3ZpZGVkLCB0aGUgaW5kZXggd2lsbCByZWZsZWN0IHRoZSBzb3J0ZWQgb3JkZXIgKHJhdGhlclxuICAgICAqIHRoYW4gdGhlIG9yaWdpbmFsIGFycmF5IG9yZGVyKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIEVsZW1lbnQgZm9yIHdoaWNoIHRvIHJldHVybiB0aGUgaW5kZXguXG4gICAgICogQHJldHVybiB7Kn0gUm93IGluZGV4IGFzc29jaWF0ZWQgd2l0aCB0aGUgZWxlbWVudCAobm90ZSB0aGlzIG1heVxuICAgICAqICAgbm90IGNvcnJlc3BvbmQgdG8gdGhlIGFycmF5IGluZGV4IGlmIGEgdXNlciBgc29ydGAgaXMgYXBwbGllZCkuXG4gICAgICovXG4gICAgaW5kZXhGb3JFbGVtZW50KGVsKSB7XG4gICAgICBsZXQgaW5zdGFuY2UgPSB0aGlzLm1vZGVsRm9yRWxlbWVudChlbCk7XG4gICAgICByZXR1cm4gaW5zdGFuY2UgJiYgaW5zdGFuY2VbdGhpcy5pbmRleEFzXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB0ZW1wbGF0ZSBcIm1vZGVsXCIgYXNzb2NpYXRlZCB3aXRoIGEgZ2l2ZW4gZWxlbWVudCwgd2hpY2hcbiAgICAgKiBzZXJ2ZXMgYXMgdGhlIGJpbmRpbmcgc2NvcGUgZm9yIHRoZSB0ZW1wbGF0ZSBpbnN0YW5jZSB0aGUgZWxlbWVudCBpc1xuICAgICAqIGNvbnRhaW5lZCBpbi4gQSB0ZW1wbGF0ZSBtb2RlbCBpcyBhbiBpbnN0YW5jZSBvZiBgUG9seW1lci5CYXNlYCwgYW5kXG4gICAgICogc2hvdWxkIGJlIHVzZWQgdG8gbWFuaXB1bGF0ZSBkYXRhIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHRlbXBsYXRlIGluc3RhbmNlLlxuICAgICAqXG4gICAgICogRXhhbXBsZTpcbiAgICAgKlxuICAgICAqICAgbGV0IG1vZGVsID0gbW9kZWxGb3JFbGVtZW50KGVsKTtcbiAgICAgKiAgIGlmIChtb2RlbC5pbmRleCA8IDEwKSB7XG4gICAgICogICAgIG1vZGVsLnNldCgnaXRlbS5jaGVja2VkJywgdHJ1ZSk7XG4gICAgICogICB9XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCBFbGVtZW50IGZvciB3aGljaCB0byByZXR1cm4gYSB0ZW1wbGF0ZSBtb2RlbC5cbiAgICAgKiBAcmV0dXJuIHtUZW1wbGF0ZUluc3RhbmNlQmFzZX0gTW9kZWwgcmVwcmVzZW50aW5nIHRoZSBiaW5kaW5nIHNjb3BlIGZvclxuICAgICAqICAgdGhlIGVsZW1lbnQuXG4gICAgICovXG4gICAgbW9kZWxGb3JFbGVtZW50KGVsKSB7XG4gICAgICByZXR1cm4gUG9seW1lci5UZW1wbGF0aXplLm1vZGVsRm9yRWxlbWVudCh0aGlzLnRlbXBsYXRlLCBlbCk7XG4gICAgfVxuXG4gIH1cblxuICBjdXN0b21FbGVtZW50cy5kZWZpbmUoRG9tUmVwZWF0LmlzLCBEb21SZXBlYXQpO1xuXG4gIFBvbHltZXIuRG9tUmVwZWF0ID0gRG9tUmVwZWF0O1xuXG59KSgpO1xuXG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvZWxlbWVudHMvZG9tLXJlcGVhdC5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuXG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vLi4vcG9seW1lci1lbGVtZW50Lmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi91dGlscy90ZW1wbGF0aXplLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi91dGlscy9kZWJvdW5jZS5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vdXRpbHMvZmx1c2guaHRtbFwiPlxuXG48c2NyaXB0PlxuXG4oZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvKipcbiAgICogVGhlIGA8ZG9tLWlmPmAgZWxlbWVudCB3aWxsIHN0YW1wIGEgbGlnaHQtZG9tIGA8dGVtcGxhdGU+YCBjaGlsZCB3aGVuXG4gICAqIHRoZSBgaWZgIHByb3BlcnR5IGJlY29tZXMgdHJ1dGh5LCBhbmQgdGhlIHRlbXBsYXRlIGNhbiB1c2UgUG9seW1lclxuICAgKiBkYXRhLWJpbmRpbmcgYW5kIGRlY2xhcmF0aXZlIGV2ZW50IGZlYXR1cmVzIHdoZW4gdXNlZCBpbiB0aGUgY29udGV4dCBvZlxuICAgKiBhIFBvbHltZXIgZWxlbWVudCdzIHRlbXBsYXRlLlxuICAgKlxuICAgKiBXaGVuIGBpZmAgYmVjb21lcyBmYWxzZXksIHRoZSBzdGFtcGVkIGNvbnRlbnQgaXMgaGlkZGVuIGJ1dCBub3RcbiAgICogcmVtb3ZlZCBmcm9tIGRvbS4gV2hlbiBgaWZgIHN1YnNlcXVlbnRseSBiZWNvbWVzIHRydXRoeSBhZ2FpbiwgdGhlIGNvbnRlbnRcbiAgICogaXMgc2ltcGx5IHJlLXNob3duLiBUaGlzIGFwcHJvYWNoIGlzIHVzZWQgZHVlIHRvIGl0cyBmYXZvcmFibGUgcGVyZm9ybWFuY2VcbiAgICogY2hhcmFjdGVyaXN0aWNzOiB0aGUgZXhwZW5zZSBvZiBjcmVhdGluZyB0ZW1wbGF0ZSBjb250ZW50IGlzIHBhaWQgb25seVxuICAgKiBvbmNlIGFuZCBsYXppbHkuXG4gICAqXG4gICAqIFNldCB0aGUgYHJlc3RhbXBgIHByb3BlcnR5IHRvIHRydWUgdG8gZm9yY2UgdGhlIHN0YW1wZWQgY29udGVudCB0byBiZVxuICAgKiBjcmVhdGVkIC8gZGVzdHJveWVkIHdoZW4gdGhlIGBpZmAgY29uZGl0aW9uIGNoYW5nZXMuXG4gICAqXG4gICAqIEBjdXN0b21FbGVtZW50XG4gICAqIEBwb2x5bWVyXG4gICAqIEBleHRlbmRzIFBvbHltZXIuRWxlbWVudFxuICAgKiBAbWVtYmVyb2YgUG9seW1lclxuICAgKiBAc3VtbWFyeSBDdXN0b20gZWxlbWVudCB0aGF0IGNvbmRpdGlvbmFsbHkgc3RhbXBzIGFuZCBoaWRlcyBvciByZW1vdmVzXG4gICAqICAgdGVtcGxhdGUgY29udGVudCBiYXNlZCBvbiBhIGJvb2xlYW4gZmxhZy5cbiAgICovXG4gIGNsYXNzIERvbUlmIGV4dGVuZHMgUG9seW1lci5FbGVtZW50IHtcblxuICAgIC8vIE5vdCBuZWVkZWQgdG8gZmluZCB0ZW1wbGF0ZTsgY2FuIGJlIHJlbW92ZWQgb25jZSB0aGUgYW5hbHl6ZXJcbiAgICAvLyBjYW4gZmluZCB0aGUgdGFnIG5hbWUgZnJvbSBjdXN0b21FbGVtZW50cy5kZWZpbmUgY2FsbFxuICAgIHN0YXRpYyBnZXQgaXMoKSB7IHJldHVybiAnZG9tLWlmJzsgfVxuXG4gICAgc3RhdGljIGdldCB0ZW1wbGF0ZSgpIHsgcmV0dXJuIG51bGw7IH1cblxuICAgIHN0YXRpYyBnZXQgcHJvcGVydGllcygpIHtcblxuICAgICAgcmV0dXJuIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZWQgd2hlbmV2ZXIgRE9NIGlzIGFkZGVkIG9yIHJlbW92ZWQvaGlkZGVuIGJ5IHRoaXMgdGVtcGxhdGUgKGJ5XG4gICAgICAgICAqIGRlZmF1bHQsIHJlbmRlcmluZyBvY2N1cnMgbGF6aWx5KS4gIFRvIGZvcmNlIGltbWVkaWF0ZSByZW5kZXJpbmcsIGNhbGxcbiAgICAgICAgICogYHJlbmRlcmAuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBldmVudCBkb20tY2hhbmdlXG4gICAgICAgICAqL1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoaXMgdGVtcGxhdGUgc2hvdWxkIHN0YW1wLlxuICAgICAgICAgKi9cbiAgICAgICAgaWY6IHtcbiAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgIG9ic2VydmVyOiAnX19kZWJvdW5jZVJlbmRlcidcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogV2hlbiB0cnVlLCBlbGVtZW50cyB3aWxsIGJlIHJlbW92ZWQgZnJvbSBET00gYW5kIGRpc2NhcmRlZCB3aGVuIGBpZmBcbiAgICAgICAgICogYmVjb21lcyBmYWxzZSBhbmQgcmUtY3JlYXRlZCBhbmQgYWRkZWQgYmFjayB0byB0aGUgRE9NIHdoZW4gYGlmYFxuICAgICAgICAgKiBiZWNvbWVzIHRydWUuICBCeSBkZWZhdWx0LCBzdGFtcGVkIGVsZW1lbnRzIHdpbGwgYmUgaGlkZGVuIGJ1dCBsZWZ0XG4gICAgICAgICAqIGluIHRoZSBET00gd2hlbiBgaWZgIGJlY29tZXMgZmFsc2UsIHdoaWNoIGlzIGdlbmVyYWxseSByZXN1bHRzXG4gICAgICAgICAqIGluIGJldHRlciBwZXJmb3JtYW5jZS5cbiAgICAgICAgICovXG4gICAgICAgIHJlc3RhbXA6IHtcbiAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgIG9ic2VydmVyOiAnX19kZWJvdW5jZVJlbmRlcidcbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgIHN1cGVyKCk7XG4gICAgICB0aGlzLl9fcmVuZGVyRGVib3VuY2VyID0gbnVsbDtcbiAgICAgIHRoaXMuX19pbnZhbGlkUHJvcHMgPSBudWxsO1xuICAgICAgdGhpcy5fX2luc3RhbmNlID0gbnVsbDtcbiAgICAgIHRoaXMuX2xhc3RJZiA9IGZhbHNlO1xuICAgICAgdGhpcy5fX2N0b3IgPSBudWxsO1xuICAgIH1cblxuICAgIF9fZGVib3VuY2VSZW5kZXIoKSB7XG4gICAgICAvLyBSZW5kZXIgaXMgYXN5bmMgZm9yIDIgcmVhc29uczpcbiAgICAgIC8vIDEuIFRvIGVsaW1pbmF0ZSBkb20gY3JlYXRpb24gdHJhc2hpbmcgaWYgdXNlciBjb2RlIHRocmFzaGVzIGBpZmAgaW4gdGhlXG4gICAgICAvLyAgICBzYW1lIHR1cm4uIFRoaXMgd2FzIG1vcmUgY29tbW9uIGluIDEueCB3aGVyZSBhIGNvbXBvdW5kIGNvbXB1dGVkXG4gICAgICAvLyAgICBwcm9wZXJ0eSBjb3VsZCByZXN1bHQgaW4gdGhlIHJlc3VsdCBjaGFuZ2luZyBtdWx0aXBsZSB0aW1lcywgYnV0IGlzXG4gICAgICAvLyAgICBtaXRpZ2F0ZWQgdG8gYSBsYXJnZSBleHRlbnQgYnkgYmF0Y2hlZCBwcm9wZXJ0eSBwcm9jZXNzaW5nIGluIDIueC5cbiAgICAgIC8vIDIuIFRvIGF2b2lkIGRvdWJsZSBvYmplY3QgcHJvcGFnYXRpb24gd2hlbiBhIGJhZyBpbmNsdWRpbmcgdmFsdWVzIGJvdW5kXG4gICAgICAvLyAgICB0byB0aGUgYGlmYCBwcm9wZXJ0eSBhcyB3ZWxsIGFzIG9uZSBvciBtb3JlIGhvc3RQcm9wcyBjb3VsZCBlbnF1ZXVlXG4gICAgICAvLyAgICB0aGUgPGRvbS1pZj4gdG8gZmx1c2ggYmVmb3JlIHRoZSA8dGVtcGxhdGU+J3MgaG9zdCBwcm9wZXJ0eVxuICAgICAgLy8gICAgZm9yd2FyZGluZy4gSW4gdGhhdCBzY2VuYXJpbyBjcmVhdGluZyBhbiBpbnN0YW5jZSB3b3VsZCByZXN1bHQgaW5cbiAgICAgIC8vICAgIHRoZSBob3N0IHByb3BzIGJlaW5nIHNldCBvbmNlLCBhbmQgdGhlbiB0aGUgZW5xdWV1ZWQgY2hhbmdlcyBvbiB0aGVcbiAgICAgIC8vICAgIHRlbXBsYXRlIHdvdWxkIHNldCBwcm9wZXJ0aWVzIGEgc2Vjb25kIHRpbWUsIHBvdGVudGlhbGx5IGNhdXNpbmcgYW5cbiAgICAgIC8vICAgIG9iamVjdCB0byBiZSBzZXQgdG8gYW4gaW5zdGFuY2UgbW9yZSB0aGFuIG9uY2UuICBDcmVhdGluZyB0aGVcbiAgICAgIC8vICAgIGluc3RhbmNlIGFzeW5jIGZyb20gZmx1c2hpbmcgZGF0YSBlbnN1cmVzIHRoaXMgZG9lc24ndCBoYXBwZW4uIElmXG4gICAgICAvLyAgICB3ZSB3YW50ZWQgYSBzeW5jIG9wdGlvbiBpbiB0aGUgZnV0dXJlLCBzaW1wbHkgaGF2aW5nIDxkb20taWY+IGZsdXNoXG4gICAgICAvLyAgICAob3IgY2xlYXIpIGl0cyB0ZW1wbGF0ZSdzIHBlbmRpbmcgaG9zdCBwcm9wZXJ0aWVzIGJlZm9yZSBjcmVhdGluZ1xuICAgICAgLy8gICAgdGhlIGluc3RhbmNlIHdvdWxkIGFsc28gYXZvaWQgdGhlIHByb2JsZW0uXG4gICAgICB0aGlzLl9fcmVuZGVyRGVib3VuY2VyID0gUG9seW1lci5EZWJvdW5jZXIuZGVib3VuY2UoXG4gICAgICAgICAgICB0aGlzLl9fcmVuZGVyRGVib3VuY2VyXG4gICAgICAgICAgLCBQb2x5bWVyLkFzeW5jLm1pY3JvVGFza1xuICAgICAgICAgICwgKCkgPT4gdGhpcy5fX3JlbmRlcigpKTtcbiAgICAgIFBvbHltZXIuZW5xdWV1ZURlYm91bmNlcih0aGlzLl9fcmVuZGVyRGVib3VuY2VyKTtcbiAgICB9XG5cbiAgICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgIHN1cGVyLmRpc2Nvbm5lY3RlZENhbGxiYWNrKCk7XG4gICAgICBpZiAoIXRoaXMucGFyZW50Tm9kZSB8fFxuICAgICAgICAgICh0aGlzLnBhcmVudE5vZGUubm9kZVR5cGUgPT0gTm9kZS5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFICYmXG4gICAgICAgICAgICF0aGlzLnBhcmVudE5vZGUuaG9zdCkpIHtcbiAgICAgICAgdGhpcy5fX3RlYXJkb3duSW5zdGFuY2UoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgIHN1cGVyLmNvbm5lY3RlZENhbGxiYWNrKCk7XG4gICAgICBpZiAodGhpcy5pZikge1xuICAgICAgICB0aGlzLl9fZGVib3VuY2VSZW5kZXIoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGb3JjZXMgdGhlIGVsZW1lbnQgdG8gcmVuZGVyIGl0cyBjb250ZW50LiBOb3JtYWxseSByZW5kZXJpbmcgaXNcbiAgICAgKiBhc3luY2hyb25vdXMgdG8gYSBwcm92b2tpbmcgY2hhbmdlLiBUaGlzIGlzIGRvbmUgZm9yIGVmZmljaWVuY3kgc29cbiAgICAgKiB0aGF0IG11bHRpcGxlIGNoYW5nZXMgdHJpZ2dlciBvbmx5IGEgc2luZ2xlIHJlbmRlci4gVGhlIHJlbmRlciBtZXRob2RcbiAgICAgKiBzaG91bGQgYmUgY2FsbGVkIGlmLCBmb3IgZXhhbXBsZSwgdGVtcGxhdGUgcmVuZGVyaW5nIGlzIHJlcXVpcmVkIHRvXG4gICAgICogdmFsaWRhdGUgYXBwbGljYXRpb24gc3RhdGUuXG4gICAgICovXG4gICAgcmVuZGVyKCkge1xuICAgICAgUG9seW1lci5mbHVzaCgpO1xuICAgIH1cblxuICAgIF9fcmVuZGVyKCkge1xuICAgICAgaWYgKHRoaXMuaWYpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9fZW5zdXJlSW5zdGFuY2UoKSkge1xuICAgICAgICAgIC8vIE5vIHRlbXBsYXRlIGZvdW5kIHlldFxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zaG93SGlkZUNoaWxkcmVuKCk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMucmVzdGFtcCkge1xuICAgICAgICB0aGlzLl9fdGVhcmRvd25JbnN0YW5jZSgpO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLnJlc3RhbXAgJiYgdGhpcy5fX2luc3RhbmNlKSB7XG4gICAgICAgIHRoaXMuX3Nob3dIaWRlQ2hpbGRyZW4oKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmlmICE9IHRoaXMuX2xhc3RJZikge1xuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KCdkb20tY2hhbmdlJywge1xuICAgICAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICAgICAgY29tcG9zZWQ6IHRydWVcbiAgICAgICAgfSkpO1xuICAgICAgICB0aGlzLl9sYXN0SWYgPSB0aGlzLmlmO1xuICAgICAgfVxuICAgIH1cblxuICAgIF9fZW5zdXJlSW5zdGFuY2UoKSB7XG4gICAgICBsZXQgcGFyZW50Tm9kZSA9IHRoaXMucGFyZW50Tm9kZTtcbiAgICAgIC8vIEd1YXJkIGFnYWluc3QgZWxlbWVudCBiZWluZyBkZXRhY2hlZCB3aGlsZSByZW5kZXIgd2FzIHF1ZXVlZFxuICAgICAgaWYgKHBhcmVudE5vZGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9fY3Rvcikge1xuICAgICAgICAgIGxldCB0ZW1wbGF0ZSA9IHRoaXMucXVlcnlTZWxlY3RvcigndGVtcGxhdGUnKTtcbiAgICAgICAgICBpZiAoIXRlbXBsYXRlKSB7XG4gICAgICAgICAgICAvLyBXYWl0IHVudGlsIGNoaWxkTGlzdCBjaGFuZ2VzIGFuZCB0ZW1wbGF0ZSBzaG91bGQgYmUgdGhlcmUgYnkgdGhlblxuICAgICAgICAgICAgbGV0IG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoKCkgPT4ge1xuICAgICAgICAgICAgICBpZiAodGhpcy5xdWVyeVNlbGVjdG9yKCd0ZW1wbGF0ZScpKSB7XG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX19yZW5kZXIoKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RvbS1pZiByZXF1aXJlcyBhIDx0ZW1wbGF0ZT4gY2hpbGQnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIG9ic2VydmVyLm9ic2VydmUodGhpcywge2NoaWxkTGlzdDogdHJ1ZX0pO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9fY3RvciA9IFBvbHltZXIuVGVtcGxhdGl6ZS50ZW1wbGF0aXplKHRlbXBsYXRlLCB0aGlzLCB7XG4gICAgICAgICAgICAvLyBkb20taWYgdGVtcGxhdGl6ZXIgaW5zdGFuY2VzIHJlcXVpcmUgYG11dGFibGU6IHRydWVgLCBhc1xuICAgICAgICAgICAgLy8gYF9fc3luY0hvc3RQcm9wZXJ0aWVzYCByZWxpZXMgb24gdGhhdCBiZWhhdmlvciB0byBzeW5jIG9iamVjdHNcbiAgICAgICAgICAgIG11dGFibGVEYXRhOiB0cnVlLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcCBQcm9wZXJ0eSB0byBmb3J3YXJkXG4gICAgICAgICAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIG9mIHByb3BlcnR5XG4gICAgICAgICAgICAgKiBAdGhpcyB7dGhpc31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZm9yd2FyZEhvc3RQcm9wOiBmdW5jdGlvbihwcm9wLCB2YWx1ZSkge1xuICAgICAgICAgICAgICBpZiAodGhpcy5fX2luc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaWYpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX19pbnN0YW5jZS5mb3J3YXJkSG9zdFByb3AocHJvcCwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIGFuIGluc3RhbmNlIGJ1dCBhcmUgc3F1ZWxjaGluZyBob3N0IHByb3BlcnR5XG4gICAgICAgICAgICAgICAgICAvLyBmb3J3YXJkaW5nIGR1ZSB0byBpZiBiZWluZyBmYWxzZSwgbm90ZSB0aGUgaW52YWxpZGF0ZWRcbiAgICAgICAgICAgICAgICAgIC8vIHByb3BlcnRpZXMgc28gYF9fc3luY0hvc3RQcm9wZXJ0aWVzYCBjYW4gc3luYyB0aGVtIHRoZSBuZXh0XG4gICAgICAgICAgICAgICAgICAvLyB0aW1lIGBpZmAgYmVjb21lcyB0cnVlXG4gICAgICAgICAgICAgICAgICB0aGlzLl9faW52YWxpZFByb3BzID0gdGhpcy5fX2ludmFsaWRQcm9wcyB8fCBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgICAgICAgICAgdGhpcy5fX2ludmFsaWRQcm9wc1tQb2x5bWVyLlBhdGgucm9vdChwcm9wKV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5fX2luc3RhbmNlKSB7XG4gICAgICAgICAgdGhpcy5fX2luc3RhbmNlID0gbmV3IHRoaXMuX19jdG9yKCk7XG4gICAgICAgICAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpcy5fX2luc3RhbmNlLnJvb3QsIHRoaXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX19zeW5jSG9zdFByb3BlcnRpZXMoKTtcbiAgICAgICAgICBsZXQgYyQgPSB0aGlzLl9faW5zdGFuY2UuY2hpbGRyZW47XG4gICAgICAgICAgaWYgKGMkICYmIGMkLmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gRGV0ZWN0IGNhc2Ugd2hlcmUgZG9tLWlmIHdhcyByZS1hdHRhY2hlZCBpbiBuZXcgcG9zaXRpb25cbiAgICAgICAgICAgIGxldCBsYXN0Q2hpbGQgPSB0aGlzLnByZXZpb3VzU2libGluZztcbiAgICAgICAgICAgIGlmIChsYXN0Q2hpbGQgIT09IGMkW2MkLmxlbmd0aC0xXSkge1xuICAgICAgICAgICAgICBmb3IgKGxldCBpPTAsIG47IChpPGMkLmxlbmd0aCkgJiYgKG49YyRbaV0pOyBpKyspIHtcbiAgICAgICAgICAgICAgICBwYXJlbnROb2RlLmluc2VydEJlZm9yZShuLCB0aGlzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgX19zeW5jSG9zdFByb3BlcnRpZXMoKSB7XG4gICAgICBsZXQgcHJvcHMgPSB0aGlzLl9faW52YWxpZFByb3BzO1xuICAgICAgaWYgKHByb3BzKSB7XG4gICAgICAgIGZvciAobGV0IHByb3AgaW4gcHJvcHMpIHtcbiAgICAgICAgICB0aGlzLl9faW5zdGFuY2UuX3NldFBlbmRpbmdQcm9wZXJ0eShwcm9wLCB0aGlzLl9fZGF0YUhvc3RbcHJvcF0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX19pbnZhbGlkUHJvcHMgPSBudWxsO1xuICAgICAgICB0aGlzLl9faW5zdGFuY2UuX2ZsdXNoUHJvcGVydGllcygpO1xuICAgICAgfVxuICAgIH1cblxuICAgIF9fdGVhcmRvd25JbnN0YW5jZSgpIHtcbiAgICAgIGlmICh0aGlzLl9faW5zdGFuY2UpIHtcbiAgICAgICAgbGV0IGMkID0gdGhpcy5fX2luc3RhbmNlLmNoaWxkcmVuO1xuICAgICAgICBpZiAoYyQgJiYgYyQubGVuZ3RoKSB7XG4gICAgICAgICAgLy8gdXNlIGZpcnN0IGNoaWxkIHBhcmVudCwgZm9yIGNhc2Ugd2hlbiBkb20taWYgbWF5IGhhdmUgYmVlbiBkZXRhY2hlZFxuICAgICAgICAgIGxldCBwYXJlbnQgPSBjJFswXS5wYXJlbnROb2RlO1xuICAgICAgICAgIGZvciAobGV0IGk9MCwgbjsgKGk8YyQubGVuZ3RoKSAmJiAobj1jJFtpXSk7IGkrKykge1xuICAgICAgICAgICAgcGFyZW50LnJlbW92ZUNoaWxkKG4pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9faW5zdGFuY2UgPSBudWxsO1xuICAgICAgICB0aGlzLl9faW52YWxpZFByb3BzID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfc2hvd0hpZGVDaGlsZHJlbigpIHtcbiAgICAgIGxldCBoaWRkZW4gPSB0aGlzLl9faGlkZVRlbXBsYXRlQ2hpbGRyZW5fXyB8fCAhdGhpcy5pZjtcbiAgICAgIGlmICh0aGlzLl9faW5zdGFuY2UpIHtcbiAgICAgICAgdGhpcy5fX2luc3RhbmNlLl9zaG93SGlkZUNoaWxkcmVuKGhpZGRlbik7XG4gICAgICB9XG4gICAgfVxuXG4gIH1cblxuICBjdXN0b21FbGVtZW50cy5kZWZpbmUoRG9tSWYuaXMsIERvbUlmKTtcblxuICBQb2x5bWVyLkRvbUlmID0gRG9tSWY7XG5cbn0pKCk7XG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvZWxlbWVudHMvZG9tLWlmLmh0bWwiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi8uLi9wb2x5bWVyLWVsZW1lbnQuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3V0aWxzL21peGluLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi91dGlscy9hcnJheS1zcGxpY2UuaHRtbFwiPlxuXG48c2NyaXB0PlxuKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLyoqXG4gICAqIEVsZW1lbnQgbWl4aW4gZm9yIHJlY29yZGluZyBkeW5hbWljIGFzc29jaWF0aW9ucyBiZXR3ZWVuIGl0ZW0gcGF0aHMgaW4gYVxuICAgKiBtYXN0ZXIgYGl0ZW1zYCBhcnJheSBhbmQgYSBgc2VsZWN0ZWRgIGFycmF5IHN1Y2ggdGhhdCBwYXRoIGNoYW5nZXMgdG8gdGhlXG4gICAqIG1hc3RlciBhcnJheSAoYXQgdGhlIGhvc3QpIGVsZW1lbnQgb3IgZWxzZXdoZXJlIHZpYSBkYXRhLWJpbmRpbmcpIGFyZVxuICAgKiBjb3JyZWN0bHkgcHJvcGFnYXRlZCB0byBpdGVtcyBpbiB0aGUgc2VsZWN0ZWQgYXJyYXkgYW5kIHZpY2UtdmVyc2EuXG4gICAqXG4gICAqIFRoZSBgaXRlbXNgIHByb3BlcnR5IGFjY2VwdHMgYW4gYXJyYXkgb2YgdXNlciBkYXRhLCBhbmQgdmlhIHRoZVxuICAgKiBgc2VsZWN0KGl0ZW0pYCBhbmQgYGRlc2VsZWN0KGl0ZW0pYCBBUEksIHVwZGF0ZXMgdGhlIGBzZWxlY3RlZGAgcHJvcGVydHlcbiAgICogd2hpY2ggbWF5IGJlIGJvdW5kIHRvIG90aGVyIHBhcnRzIG9mIHRoZSBhcHBsaWNhdGlvbiwgYW5kIGFueSBjaGFuZ2VzIHRvXG4gICAqIHN1Yi1maWVsZHMgb2YgYHNlbGVjdGVkYCBpdGVtKHMpIHdpbGwgYmUga2VwdCBpbiBzeW5jIHdpdGggaXRlbXMgaW4gdGhlXG4gICAqIGBpdGVtc2AgYXJyYXkuICBXaGVuIGBtdWx0aWAgaXMgZmFsc2UsIGBzZWxlY3RlZGAgaXMgYSBwcm9wZXJ0eVxuICAgKiByZXByZXNlbnRpbmcgdGhlIGxhc3Qgc2VsZWN0ZWQgaXRlbS4gIFdoZW4gYG11bHRpYCBpcyB0cnVlLCBgc2VsZWN0ZWRgXG4gICAqIGlzIGFuIGFycmF5IG9mIG11bHRpcGx5IHNlbGVjdGVkIGl0ZW1zLlxuICAgKlxuICAgKiBAcG9seW1lclxuICAgKiBAbWl4aW5GdW5jdGlvblxuICAgKiBAYXBwbGllc01peGluIFBvbHltZXIuRWxlbWVudE1peGluXG4gICAqIEBtZW1iZXJvZiBQb2x5bWVyXG4gICAqIEBzdW1tYXJ5IEVsZW1lbnQgbWl4aW4gZm9yIHJlY29yZGluZyBkeW5hbWljIGFzc29jaWF0aW9ucyBiZXR3ZWVuIGl0ZW0gcGF0aHMgaW4gYVxuICAgKiBtYXN0ZXIgYGl0ZW1zYCBhcnJheSBhbmQgYSBgc2VsZWN0ZWRgIGFycmF5XG4gICAqL1xuICBsZXQgQXJyYXlTZWxlY3Rvck1peGluID0gUG9seW1lci5kZWR1cGluZ01peGluKHN1cGVyQ2xhc3MgPT4ge1xuXG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQGV4dGVuZHMge3N1cGVyQ2xhc3N9XG4gICAgICogQGltcGxlbWVudHMge1BvbHltZXJfRWxlbWVudE1peGlufVxuICAgICAqL1xuICAgIGxldCBlbGVtZW50QmFzZSA9IFBvbHltZXIuRWxlbWVudE1peGluKHN1cGVyQ2xhc3MpO1xuXG4gICAgLyoqXG4gICAgICogQHBvbHltZXJcbiAgICAgKiBAbWl4aW5DbGFzc1xuICAgICAqIEBpbXBsZW1lbnRzIHtQb2x5bWVyX0FycmF5U2VsZWN0b3JNaXhpbn1cbiAgICAgKiBAdW5yZXN0cmljdGVkXG4gICAgICovXG4gICAgY2xhc3MgQXJyYXlTZWxlY3Rvck1peGluIGV4dGVuZHMgZWxlbWVudEJhc2Uge1xuXG4gICAgICBzdGF0aWMgZ2V0IHByb3BlcnRpZXMoKSB7XG5cbiAgICAgICAgcmV0dXJuIHtcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIEFuIGFycmF5IGNvbnRhaW5pbmcgaXRlbXMgZnJvbSB3aGljaCBzZWxlY3Rpb24gd2lsbCBiZSBtYWRlLlxuICAgICAgICAgICAqL1xuICAgICAgICAgIGl0ZW1zOiB7XG4gICAgICAgICAgICB0eXBlOiBBcnJheSxcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogV2hlbiBgdHJ1ZWAsIG11bHRpcGxlIGl0ZW1zIG1heSBiZSBzZWxlY3RlZCBhdCBvbmNlIChpbiB0aGlzIGNhc2UsXG4gICAgICAgICAgICogYHNlbGVjdGVkYCBpcyBhbiBhcnJheSBvZiBjdXJyZW50bHkgc2VsZWN0ZWQgaXRlbXMpLiAgV2hlbiBgZmFsc2VgLFxuICAgICAgICAgICAqIG9ubHkgb25lIGl0ZW0gbWF5IGJlIHNlbGVjdGVkIGF0IGEgdGltZS5cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBtdWx0aToge1xuICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgICAgIHZhbHVlOiBmYWxzZSxcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogV2hlbiBgbXVsdGlgIGlzIHRydWUsIHRoaXMgaXMgYW4gYXJyYXkgdGhhdCBjb250YWlucyBhbnkgc2VsZWN0ZWQuXG4gICAgICAgICAgICogV2hlbiBgbXVsdGlgIGlzIGZhbHNlLCB0aGlzIGlzIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgaXRlbSwgb3IgYG51bGxgXG4gICAgICAgICAgICogaWYgbm8gaXRlbSBpcyBzZWxlY3RlZC5cbiAgICAgICAgICAgKiBAdHlwZSB7PyhPYmplY3R8QXJyYXk8IU9iamVjdD4pfVxuICAgICAgICAgICAqL1xuICAgICAgICAgIHNlbGVjdGVkOiB7XG4gICAgICAgICAgICB0eXBlOiBPYmplY3QsXG4gICAgICAgICAgICBub3RpZnk6IHRydWVcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogV2hlbiBgbXVsdGlgIGlzIGZhbHNlLCB0aGlzIGlzIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgaXRlbSwgb3IgYG51bGxgXG4gICAgICAgICAgICogaWYgbm8gaXRlbSBpcyBzZWxlY3RlZC5cbiAgICAgICAgICAgKiBAdHlwZSB7P09iamVjdH1cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBzZWxlY3RlZEl0ZW06IHtcbiAgICAgICAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgICAgICAgIG5vdGlmeTogdHJ1ZVxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBXaGVuIGB0cnVlYCwgY2FsbGluZyBgc2VsZWN0YCBvbiBhbiBpdGVtIHRoYXQgaXMgYWxyZWFkeSBzZWxlY3RlZFxuICAgICAgICAgICAqIHdpbGwgZGVzZWxlY3QgdGhlIGl0ZW0uXG4gICAgICAgICAgICovXG4gICAgICAgICAgdG9nZ2xlOiB7XG4gICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc3RhdGljIGdldCBvYnNlcnZlcnMoKSB7XG4gICAgICAgIHJldHVybiBbJ19fdXBkYXRlU2VsZWN0aW9uKG11bHRpLCBpdGVtcy4qKSddXG4gICAgICB9XG5cbiAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl9fbGFzdEl0ZW1zID0gbnVsbDtcbiAgICAgICAgdGhpcy5fX2xhc3RNdWx0aSA9IG51bGw7XG4gICAgICAgIHRoaXMuX19zZWxlY3RlZE1hcCA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIF9fdXBkYXRlU2VsZWN0aW9uKG11bHRpLCBpdGVtc0luZm8pIHtcbiAgICAgICAgbGV0IHBhdGggPSBpdGVtc0luZm8ucGF0aDtcbiAgICAgICAgaWYgKHBhdGggPT0gJ2l0ZW1zJykge1xuICAgICAgICAgIC8vIENhc2UgMSAtIGl0ZW1zIGFycmF5IGNoYW5nZWQsIHNvIGRpZmYgYWdhaW5zdCBwcmV2aW91cyBhcnJheSBhbmRcbiAgICAgICAgICAvLyBkZXNlbGVjdCBhbnkgcmVtb3ZlZCBpdGVtcyBhbmQgYWRqdXN0IHNlbGVjdGVkIGluZGljZXNcbiAgICAgICAgICBsZXQgbmV3SXRlbXMgPSBpdGVtc0luZm8uYmFzZSB8fCBbXTtcbiAgICAgICAgICBsZXQgbGFzdEl0ZW1zID0gdGhpcy5fX2xhc3RJdGVtcztcbiAgICAgICAgICBsZXQgbGFzdE11bHRpID0gdGhpcy5fX2xhc3RNdWx0aTtcbiAgICAgICAgICBpZiAobXVsdGkgIT09IGxhc3RNdWx0aSkge1xuICAgICAgICAgICAgdGhpcy5jbGVhclNlbGVjdGlvbigpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobGFzdEl0ZW1zKSB7XG4gICAgICAgICAgICBsZXQgc3BsaWNlcyA9IFBvbHltZXIuQXJyYXlTcGxpY2UuY2FsY3VsYXRlU3BsaWNlcyhuZXdJdGVtcywgbGFzdEl0ZW1zKTtcbiAgICAgICAgICAgIHRoaXMuX19hcHBseVNwbGljZXMoc3BsaWNlcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX19sYXN0SXRlbXMgPSBuZXdJdGVtcztcbiAgICAgICAgICB0aGlzLl9fbGFzdE11bHRpID0gbXVsdGk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXRlbXNJbmZvLnBhdGggPT0gJ2l0ZW1zLnNwbGljZXMnKSB7XG4gICAgICAgICAgLy8gQ2FzZSAyIC0gZ290IHNwZWNpZmljIHNwbGljZSBpbmZvcm1hdGlvbiBkZXNjcmliaW5nIHRoZSBhcnJheSBtdXRhdGlvbjpcbiAgICAgICAgICAvLyBkZXNlbGVjdCBhbnkgcmVtb3ZlZCBpdGVtcyBhbmQgYWRqdXN0IHNlbGVjdGVkIGluZGljZXNcbiAgICAgICAgICB0aGlzLl9fYXBwbHlTcGxpY2VzKGl0ZW1zSW5mby52YWx1ZS5pbmRleFNwbGljZXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIENhc2UgMyAtIGFuIGFycmF5IGVsZW1lbnQgd2FzIGNoYW5nZWQsIHNvIGRlc2VsZWN0IHRoZSBwcmV2aW91c1xuICAgICAgICAgIC8vIGl0ZW0gZm9yIHRoYXQgaW5kZXggaWYgaXQgd2FzIHByZXZpb3VzbHkgc2VsZWN0ZWRcbiAgICAgICAgICBsZXQgcGFydCA9IHBhdGguc2xpY2UoJ2l0ZW1zLicubGVuZ3RoKTtcbiAgICAgICAgICBsZXQgaWR4ID0gcGFyc2VJbnQocGFydCwgMTApO1xuICAgICAgICAgIGlmICgocGFydC5pbmRleE9mKCcuJykgPCAwKSAmJiBwYXJ0ID09IGlkeCkge1xuICAgICAgICAgICAgdGhpcy5fX2Rlc2VsZWN0Q2hhbmdlZElkeChpZHgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBfX2FwcGx5U3BsaWNlcyhzcGxpY2VzKSB7XG4gICAgICAgIGxldCBzZWxlY3RlZCA9IHRoaXMuX19zZWxlY3RlZE1hcDtcbiAgICAgICAgLy8gQWRqdXN0IHNlbGVjdGVkIGluZGljZXMgYW5kIG1hcmsgcmVtb3ZhbHNcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPHNwbGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBsZXQgcyA9IHNwbGljZXNbaV07XG4gICAgICAgICAgc2VsZWN0ZWQuZm9yRWFjaCgoaWR4LCBpdGVtKSA9PiB7XG4gICAgICAgICAgICBpZiAoaWR4IDwgcy5pbmRleCkge1xuICAgICAgICAgICAgICAvLyBubyBjaGFuZ2VcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaWR4ID49IHMuaW5kZXggKyBzLnJlbW92ZWQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIC8vIGFkanVzdCBpbmRleFxuICAgICAgICAgICAgICBzZWxlY3RlZC5zZXQoaXRlbSwgaWR4ICsgcy5hZGRlZENvdW50IC0gcy5yZW1vdmVkLmxlbmd0aCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyByZW1vdmUgaW5kZXhcbiAgICAgICAgICAgICAgc2VsZWN0ZWQuc2V0KGl0ZW0sIC0xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBmb3IgKGxldCBqPTA7IGo8cy5hZGRlZENvdW50OyBqKyspIHtcbiAgICAgICAgICAgIGxldCBpZHggPSBzLmluZGV4ICsgajtcbiAgICAgICAgICAgIGlmIChzZWxlY3RlZC5oYXModGhpcy5pdGVtc1tpZHhdKSkge1xuICAgICAgICAgICAgICBzZWxlY3RlZC5zZXQodGhpcy5pdGVtc1tpZHhdLCBpZHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBVcGRhdGUgbGlua2VkIHBhdGhzXG4gICAgICAgIHRoaXMuX191cGRhdGVMaW5rcygpO1xuICAgICAgICAvLyBSZW1vdmUgc2VsZWN0ZWQgaXRlbXMgdGhhdCB3ZXJlIHJlbW92ZWQgZnJvbSB0aGUgaXRlbXMgYXJyYXlcbiAgICAgICAgbGV0IHNpZHggPSAwO1xuICAgICAgICBzZWxlY3RlZC5mb3JFYWNoKChpZHgsIGl0ZW0pID0+IHtcbiAgICAgICAgICBpZiAoaWR4IDwgMCkge1xuICAgICAgICAgICAgaWYgKHRoaXMubXVsdGkpIHtcbiAgICAgICAgICAgICAgdGhpcy5zcGxpY2UoJ3NlbGVjdGVkJywgc2lkeCwgMSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkID0gdGhpcy5zZWxlY3RlZEl0ZW0gPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZWN0ZWQuZGVsZXRlKGl0ZW0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzaWR4Kys7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgX191cGRhdGVMaW5rcygpIHtcbiAgICAgICAgdGhpcy5fX2RhdGFMaW5rZWRQYXRocyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5tdWx0aSkge1xuICAgICAgICAgIGxldCBzaWR4ID0gMDtcbiAgICAgICAgICB0aGlzLl9fc2VsZWN0ZWRNYXAuZm9yRWFjaChpZHggPT4ge1xuICAgICAgICAgICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICAgICAgICAgIHRoaXMubGlua1BhdGhzKCdpdGVtcy4nICsgaWR4LCAnc2VsZWN0ZWQuJyArIHNpZHgrKyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fX3NlbGVjdGVkTWFwLmZvckVhY2goaWR4ID0+IHtcbiAgICAgICAgICAgIHRoaXMubGlua1BhdGhzKCdzZWxlY3RlZCcsICdpdGVtcy4nICsgaWR4KTtcbiAgICAgICAgICAgIHRoaXMubGlua1BhdGhzKCdzZWxlY3RlZEl0ZW0nLCAnaXRlbXMuJyArIGlkeCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDbGVhcnMgdGhlIHNlbGVjdGlvbiBzdGF0ZS5cbiAgICAgICAqXG4gICAgICAgKi9cbiAgICAgIGNsZWFyU2VsZWN0aW9uKCkge1xuICAgICAgICAvLyBVbmJpbmQgcHJldmlvdXMgc2VsZWN0aW9uXG4gICAgICAgIHRoaXMuX19kYXRhTGlua2VkUGF0aHMgPSB7fTtcbiAgICAgICAgLy8gVGhlIHNlbGVjdGVkIG1hcCBzdG9yZXMgMyBwaWVjZXMgb2YgaW5mb3JtYXRpb246XG4gICAgICAgIC8vIGtleTogaXRlbXMgYXJyYXkgb2JqZWN0XG4gICAgICAgIC8vIHZhbHVlOiBpdGVtcyBhcnJheSBpbmRleFxuICAgICAgICAvLyBvcmRlcjogc2VsZWN0ZWQgYXJyYXkgaW5kZXhcbiAgICAgICAgdGhpcy5fX3NlbGVjdGVkTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICAvLyBJbml0aWFsaXplIHNlbGVjdGlvblxuICAgICAgICB0aGlzLnNlbGVjdGVkID0gdGhpcy5tdWx0aSA/IFtdIDogbnVsbFxuICAgICAgICB0aGlzLnNlbGVjdGVkSXRlbSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBpdGVtIGlzIGN1cnJlbnRseSBzZWxlY3RlZC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0geyp9IGl0ZW0gSXRlbSBmcm9tIGBpdGVtc2AgYXJyYXkgdG8gdGVzdFxuICAgICAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgaXRlbSBpcyBzZWxlY3RlZFxuICAgICAgICovXG4gICAgICBpc1NlbGVjdGVkKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19zZWxlY3RlZE1hcC5oYXMoaXRlbSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBpdGVtIGlzIGN1cnJlbnRseSBzZWxlY3RlZC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0gaWR4IEluZGV4IGZyb20gYGl0ZW1zYCBhcnJheSB0byB0ZXN0XG4gICAgICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBpdGVtIGlzIHNlbGVjdGVkXG4gICAgICAgKi9cbiAgICAgIGlzSW5kZXhTZWxlY3RlZChpZHgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNTZWxlY3RlZCh0aGlzLml0ZW1zW2lkeF0pO1xuICAgICAgfVxuXG4gICAgICBfX2Rlc2VsZWN0Q2hhbmdlZElkeChpZHgpIHtcbiAgICAgICAgbGV0IHNpZHggPSB0aGlzLl9fc2VsZWN0ZWRJbmRleEZvckl0ZW1JbmRleChpZHgpO1xuICAgICAgICBpZiAoc2lkeCA+PSAwKSB7XG4gICAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAgIHRoaXMuX19zZWxlY3RlZE1hcC5mb3JFYWNoKChpZHgsIGl0ZW0pID0+IHtcbiAgICAgICAgICAgIGlmIChzaWR4ID09IGkrKykge1xuICAgICAgICAgICAgICB0aGlzLmRlc2VsZWN0KGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIF9fc2VsZWN0ZWRJbmRleEZvckl0ZW1JbmRleChpZHgpIHtcbiAgICAgICAgbGV0IHNlbGVjdGVkID0gdGhpcy5fX2RhdGFMaW5rZWRQYXRoc1snaXRlbXMuJyArIGlkeF07XG4gICAgICAgIGlmIChzZWxlY3RlZCkge1xuICAgICAgICAgIHJldHVybiBwYXJzZUludChzZWxlY3RlZC5zbGljZSgnc2VsZWN0ZWQuJy5sZW5ndGgpLCAxMCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBEZXNlbGVjdHMgdGhlIGdpdmVuIGl0ZW0gaWYgaXQgaXMgYWxyZWFkeSBzZWxlY3RlZC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0geyp9IGl0ZW0gSXRlbSBmcm9tIGBpdGVtc2AgYXJyYXkgdG8gZGVzZWxlY3RcbiAgICAgICAqL1xuICAgICAgZGVzZWxlY3QoaXRlbSkge1xuICAgICAgICBsZXQgaWR4ID0gdGhpcy5fX3NlbGVjdGVkTWFwLmdldChpdGVtKTtcbiAgICAgICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICAgICAgdGhpcy5fX3NlbGVjdGVkTWFwLmRlbGV0ZShpdGVtKTtcbiAgICAgICAgICBsZXQgc2lkeDtcbiAgICAgICAgICBpZiAodGhpcy5tdWx0aSkge1xuICAgICAgICAgICAgc2lkeCA9IHRoaXMuX19zZWxlY3RlZEluZGV4Rm9ySXRlbUluZGV4KGlkeCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX191cGRhdGVMaW5rcygpO1xuICAgICAgICAgIGlmICh0aGlzLm11bHRpKSB7XG4gICAgICAgICAgICB0aGlzLnNwbGljZSgnc2VsZWN0ZWQnLCBzaWR4LCAxKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZCA9IHRoaXMuc2VsZWN0ZWRJdGVtID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBEZXNlbGVjdHMgdGhlIGdpdmVuIGluZGV4IGlmIGl0IGlzIGFscmVhZHkgc2VsZWN0ZWQuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGlkeCBJbmRleCBmcm9tIGBpdGVtc2AgYXJyYXkgdG8gZGVzZWxlY3RcbiAgICAgICAqL1xuICAgICAgZGVzZWxlY3RJbmRleChpZHgpIHtcbiAgICAgICAgdGhpcy5kZXNlbGVjdCh0aGlzLml0ZW1zW2lkeF0pO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFNlbGVjdHMgdGhlIGdpdmVuIGl0ZW0uICBXaGVuIGB0b2dnbGVgIGlzIHRydWUsIHRoaXMgd2lsbCBhdXRvbWF0aWNhbGx5XG4gICAgICAgKiBkZXNlbGVjdCB0aGUgaXRlbSBpZiBhbHJlYWR5IHNlbGVjdGVkLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7Kn0gaXRlbSBJdGVtIGZyb20gYGl0ZW1zYCBhcnJheSB0byBzZWxlY3RcbiAgICAgICAqL1xuICAgICAgc2VsZWN0KGl0ZW0pIHtcbiAgICAgICAgdGhpcy5zZWxlY3RJbmRleCh0aGlzLml0ZW1zLmluZGV4T2YoaXRlbSkpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFNlbGVjdHMgdGhlIGdpdmVuIGluZGV4LiAgV2hlbiBgdG9nZ2xlYCBpcyB0cnVlLCB0aGlzIHdpbGwgYXV0b21hdGljYWxseVxuICAgICAgICogZGVzZWxlY3QgdGhlIGl0ZW0gaWYgYWxyZWFkeSBzZWxlY3RlZC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0gaWR4IEluZGV4IGZyb20gYGl0ZW1zYCBhcnJheSB0byBzZWxlY3RcbiAgICAgICAqL1xuICAgICAgc2VsZWN0SW5kZXgoaWR4KSB7XG4gICAgICAgIGxldCBpdGVtID0gdGhpcy5pdGVtc1tpZHhdO1xuICAgICAgICBpZiAoIXRoaXMuaXNTZWxlY3RlZChpdGVtKSkge1xuICAgICAgICAgIGlmICghdGhpcy5tdWx0aSkge1xuICAgICAgICAgICAgdGhpcy5fX3NlbGVjdGVkTWFwLmNsZWFyKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX19zZWxlY3RlZE1hcC5zZXQoaXRlbSwgaWR4KTtcbiAgICAgICAgICB0aGlzLl9fdXBkYXRlTGlua3MoKTtcbiAgICAgICAgICBpZiAodGhpcy5tdWx0aSkge1xuICAgICAgICAgICAgdGhpcy5wdXNoKCdzZWxlY3RlZCcsIGl0ZW0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkID0gdGhpcy5zZWxlY3RlZEl0ZW0gPSBpdGVtO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnRvZ2dsZSkge1xuICAgICAgICAgIHRoaXMuZGVzZWxlY3RJbmRleChpZHgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICB9XG5cbiAgICByZXR1cm4gQXJyYXlTZWxlY3Rvck1peGluO1xuXG4gIH0pO1xuXG4gIC8vIGV4cG9ydCBtaXhpblxuICBQb2x5bWVyLkFycmF5U2VsZWN0b3JNaXhpbiA9IEFycmF5U2VsZWN0b3JNaXhpbjtcblxuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBleHRlbmRzIHtQb2x5bWVyLkVsZW1lbnR9XG4gICAqIEBpbXBsZW1lbnRzIHtQb2x5bWVyX0FycmF5U2VsZWN0b3JNaXhpbn1cbiAgICovXG4gIGxldCBiYXNlQXJyYXlTZWxlY3RvciA9IEFycmF5U2VsZWN0b3JNaXhpbihQb2x5bWVyLkVsZW1lbnQpO1xuXG4gIC8qKlxuICAgKiBFbGVtZW50IGltcGxlbWVudGluZyB0aGUgYFBvbHltZXIuQXJyYXlTZWxlY3RvcmAgbWl4aW4sIHdoaWNoIHJlY29yZHNcbiAgICogZHluYW1pYyBhc3NvY2lhdGlvbnMgYmV0d2VlbiBpdGVtIHBhdGhzIGluIGEgbWFzdGVyIGBpdGVtc2AgYXJyYXkgYW5kIGFcbiAgICogYHNlbGVjdGVkYCBhcnJheSBzdWNoIHRoYXQgcGF0aCBjaGFuZ2VzIHRvIHRoZSBtYXN0ZXIgYXJyYXkgKGF0IHRoZSBob3N0KVxuICAgKiBlbGVtZW50IG9yIGVsc2V3aGVyZSB2aWEgZGF0YS1iaW5kaW5nKSBhcmUgY29ycmVjdGx5IHByb3BhZ2F0ZWQgdG8gaXRlbXNcbiAgICogaW4gdGhlIHNlbGVjdGVkIGFycmF5IGFuZCB2aWNlLXZlcnNhLlxuICAgKlxuICAgKiBUaGUgYGl0ZW1zYCBwcm9wZXJ0eSBhY2NlcHRzIGFuIGFycmF5IG9mIHVzZXIgZGF0YSwgYW5kIHZpYSB0aGVcbiAgICogYHNlbGVjdChpdGVtKWAgYW5kIGBkZXNlbGVjdChpdGVtKWAgQVBJLCB1cGRhdGVzIHRoZSBgc2VsZWN0ZWRgIHByb3BlcnR5XG4gICAqIHdoaWNoIG1heSBiZSBib3VuZCB0byBvdGhlciBwYXJ0cyBvZiB0aGUgYXBwbGljYXRpb24sIGFuZCBhbnkgY2hhbmdlcyB0b1xuICAgKiBzdWItZmllbGRzIG9mIGBzZWxlY3RlZGAgaXRlbShzKSB3aWxsIGJlIGtlcHQgaW4gc3luYyB3aXRoIGl0ZW1zIGluIHRoZVxuICAgKiBgaXRlbXNgIGFycmF5LiAgV2hlbiBgbXVsdGlgIGlzIGZhbHNlLCBgc2VsZWN0ZWRgIGlzIGEgcHJvcGVydHlcbiAgICogcmVwcmVzZW50aW5nIHRoZSBsYXN0IHNlbGVjdGVkIGl0ZW0uICBXaGVuIGBtdWx0aWAgaXMgdHJ1ZSwgYHNlbGVjdGVkYFxuICAgKiBpcyBhbiBhcnJheSBvZiBtdWx0aXBseSBzZWxlY3RlZCBpdGVtcy5cbiAgICpcbiAgICogRXhhbXBsZTpcbiAgICpcbiAgICogYGBgaHRtbFxuICAgKiA8ZG9tLW1vZHVsZSBpZD1cImVtcGxveWVlLWxpc3RcIj5cbiAgICpcbiAgICogICA8dGVtcGxhdGU+XG4gICAqXG4gICAqICAgICA8ZGl2PiBFbXBsb3llZSBsaXN0OiA8L2Rpdj5cbiAgICogICAgIDx0ZW1wbGF0ZSBpcz1cImRvbS1yZXBlYXRcIiBpZD1cImVtcGxveWVlTGlzdFwiIGl0ZW1zPVwie3tlbXBsb3llZXN9fVwiPlxuICAgKiAgICAgICAgIDxkaXY+Rmlyc3QgbmFtZTogPHNwYW4+e3tpdGVtLmZpcnN0fX08L3NwYW4+PC9kaXY+XG4gICAqICAgICAgICAgPGRpdj5MYXN0IG5hbWU6IDxzcGFuPnt7aXRlbS5sYXN0fX08L3NwYW4+PC9kaXY+XG4gICAqICAgICAgICAgPGJ1dHRvbiBvbi1jbGljaz1cInRvZ2dsZVNlbGVjdGlvblwiPlNlbGVjdDwvYnV0dG9uPlxuICAgKiAgICAgPC90ZW1wbGF0ZT5cbiAgICpcbiAgICogICAgIDxhcnJheS1zZWxlY3RvciBpZD1cInNlbGVjdG9yXCIgaXRlbXM9XCJ7e2VtcGxveWVlc319XCIgc2VsZWN0ZWQ9XCJ7e3NlbGVjdGVkfX1cIiBtdWx0aSB0b2dnbGU+PC9hcnJheS1zZWxlY3Rvcj5cbiAgICpcbiAgICogICAgIDxkaXY+IFNlbGVjdGVkIGVtcGxveWVlczogPC9kaXY+XG4gICAqICAgICA8dGVtcGxhdGUgaXM9XCJkb20tcmVwZWF0XCIgaXRlbXM9XCJ7e3NlbGVjdGVkfX1cIj5cbiAgICogICAgICAgICA8ZGl2PkZpcnN0IG5hbWU6IDxzcGFuPnt7aXRlbS5maXJzdH19PC9zcGFuPjwvZGl2PlxuICAgKiAgICAgICAgIDxkaXY+TGFzdCBuYW1lOiA8c3Bhbj57e2l0ZW0ubGFzdH19PC9zcGFuPjwvZGl2PlxuICAgKiAgICAgPC90ZW1wbGF0ZT5cbiAgICpcbiAgICogICA8L3RlbXBsYXRlPlxuICAgKlxuICAgKiA8L2RvbS1tb2R1bGU+XG4gICAqIGBgYFxuICAgKlxuICAgKiBgYGBqc1xuICAgKiBQb2x5bWVyKHtcbiAgICogICBpczogJ2VtcGxveWVlLWxpc3QnLFxuICAgKiAgIHJlYWR5KCkge1xuICAgKiAgICAgdGhpcy5lbXBsb3llZXMgPSBbXG4gICAqICAgICAgICAge2ZpcnN0OiAnQm9iJywgbGFzdDogJ1NtaXRoJ30sXG4gICAqICAgICAgICAge2ZpcnN0OiAnU2FsbHknLCBsYXN0OiAnSm9obnNvbid9LFxuICAgKiAgICAgICAgIC4uLlxuICAgKiAgICAgXTtcbiAgICogICB9LFxuICAgKiAgIHRvZ2dsZVNlbGVjdGlvbihlKSB7XG4gICAqICAgICBsZXQgaXRlbSA9IHRoaXMuJC5lbXBsb3llZUxpc3QuaXRlbUZvckVsZW1lbnQoZS50YXJnZXQpO1xuICAgKiAgICAgdGhpcy4kLnNlbGVjdG9yLnNlbGVjdChpdGVtKTtcbiAgICogICB9XG4gICAqIH0pO1xuICAgKiBgYGBcbiAgICpcbiAgICogQHBvbHltZXJcbiAgICogQGN1c3RvbUVsZW1lbnRcbiAgICogQGV4dGVuZHMge2Jhc2VBcnJheVNlbGVjdG9yfVxuICAgKiBAYXBwbGllc01peGluIFBvbHltZXIuQXJyYXlTZWxlY3Rvck1peGluXG4gICAqIEBtZW1iZXJvZiBQb2x5bWVyXG4gICAqIEBzdW1tYXJ5IEN1c3RvbSBlbGVtZW50IHRoYXQgbGlua3MgcGF0aHMgYmV0d2VlbiBhbiBpbnB1dCBgaXRlbXNgIGFycmF5IGFuZFxuICAgKiAgIGFuIG91dHB1dCBgc2VsZWN0ZWRgIGl0ZW0gb3IgYXJyYXkgYmFzZWQgb24gY2FsbHMgdG8gaXRzIHNlbGVjdGlvbiBBUEkuXG4gICAqL1xuICBjbGFzcyBBcnJheVNlbGVjdG9yIGV4dGVuZHMgYmFzZUFycmF5U2VsZWN0b3Ige1xuICAgIC8vIE5vdCBuZWVkZWQgdG8gZmluZCB0ZW1wbGF0ZTsgY2FuIGJlIHJlbW92ZWQgb25jZSB0aGUgYW5hbHl6ZXJcbiAgICAvLyBjYW4gZmluZCB0aGUgdGFnIG5hbWUgZnJvbSBjdXN0b21FbGVtZW50cy5kZWZpbmUgY2FsbFxuICAgIHN0YXRpYyBnZXQgaXMoKSB7IHJldHVybiAnYXJyYXktc2VsZWN0b3InIH1cbiAgfVxuICBjdXN0b21FbGVtZW50cy5kZWZpbmUoQXJyYXlTZWxlY3Rvci5pcywgQXJyYXlTZWxlY3Rvcik7XG4gIFBvbHltZXIuQXJyYXlTZWxlY3RvciA9IEFycmF5U2VsZWN0b3I7XG5cbn0pKCk7XG5cbjwvc2NyaXB0PlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi9lbGVtZW50cy9hcnJheS1zZWxlY3Rvci5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uLy4uLy4uL3NoYWR5Y3NzL2N1c3RvbS1zdHlsZS1pbnRlcmZhY2UuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3V0aWxzL3N0eWxlLWdhdGhlci5odG1sXCI+XG48c2NyaXB0PlxuKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgY29uc3QgYXR0ciA9ICdpbmNsdWRlJztcblxuICBjb25zdCBDdXN0b21TdHlsZUludGVyZmFjZSA9IHdpbmRvdy5TaGFkeUNTUy5DdXN0b21TdHlsZUludGVyZmFjZTtcblxuICAvKipcbiAgICogQ3VzdG9tIGVsZW1lbnQgZm9yIGRlZmluaW5nIHN0eWxlcyBpbiB0aGUgbWFpbiBkb2N1bWVudCB0aGF0IGNhbiB0YWtlXG4gICAqIGFkdmFudGFnZSBvZiBzZXZlcmFsIHNwZWNpYWwgZmVhdHVyZXMgb2YgUG9seW1lcidzIHN0eWxpbmcgc3lzdGVtOlxuICAgKlxuICAgKiAtIERvY3VtZW50IHN0eWxlcyBkZWZpbmVkIGluIGEgY3VzdG9tLXN0eWxlIGFyZSBzaGltbWVkIHRvIGVuc3VyZSB0aGV5XG4gICAqICAgZG8gbm90IGxlYWsgaW50byBsb2NhbCBET00gd2hlbiBydW5uaW5nIG9uIGJyb3dzZXJzIHdpdGhvdXQgbmF0aXZlXG4gICAqICAgU2hhZG93IERPTS5cbiAgICogLSBDdXN0b20gcHJvcGVydGllcyB1c2VkIGJ5IFBvbHltZXIncyBzaGltIGZvciBjcm9zcy1zY29wZSBzdHlsaW5nIG1heVxuICAgKiAgIGJlIGRlZmluZWQgaW4gYW4gY3VzdG9tLXN0eWxlLiBVc2UgdGhlIDpyb290IHNlbGVjdG9yIHRvIGRlZmluZSBjdXN0b21cbiAgICogICBwcm9wZXJ0aWVzIHRoYXQgYXBwbHkgdG8gYWxsIGN1c3RvbSBlbGVtZW50cy5cbiAgICpcbiAgICogVG8gdXNlLCBzaW1wbHkgd3JhcCBhbiBpbmxpbmUgYDxzdHlsZT5gIHRhZyBpbiB0aGUgbWFpbiBkb2N1bWVudCB3aG9zZVxuICAgKiBDU1MgdXNlcyB0aGVzZSBmZWF0dXJlcyB3aXRoIGEgYDxjdXN0b20tc3R5bGU+YCBlbGVtZW50LlxuICAgKlxuICAgKiBAY3VzdG9tRWxlbWVudFxuICAgKiBAZXh0ZW5kcyBIVE1MRWxlbWVudFxuICAgKiBAbWVtYmVyb2YgUG9seW1lclxuICAgKiBAc3VtbWFyeSBDdXN0b20gZWxlbWVudCBmb3IgZGVmaW5pbmcgc3R5bGVzIGluIHRoZSBtYWluIGRvY3VtZW50IHRoYXQgY2FuXG4gICAqICAgdGFrZSBhZHZhbnRhZ2Ugb2YgUG9seW1lcidzIHN0eWxlIHNjb3BpbmcgYW5kIGN1c3RvbSBwcm9wZXJ0aWVzIHNoaW1zLlxuICAgKi9cbiAgY2xhc3MgQ3VzdG9tU3R5bGUgZXh0ZW5kcyBIVE1MRWxlbWVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICBzdXBlcigpO1xuICAgICAgdGhpcy5fc3R5bGUgPSBudWxsO1xuICAgICAgQ3VzdG9tU3R5bGVJbnRlcmZhY2UuYWRkQ3VzdG9tU3R5bGUodGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGxpZ2h0LURPTSBgPHN0eWxlPmAgY2hpbGQgdGhpcyBlbGVtZW50IHdyYXBzLiAgVXBvbiBmaXJzdFxuICAgICAqIGNhbGwgYW55IHN0eWxlIG1vZHVsZXMgcmVmZXJlbmNlZCB2aWEgdGhlIGBpbmNsdWRlYCBhdHRyaWJ1dGUgd2lsbCBiZVxuICAgICAqIGNvbmNhdGVuYXRlZCB0byB0aGlzIGVsZW1lbnQncyBgPHN0eWxlPmAuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtIVE1MU3R5bGVFbGVtZW50fSBUaGlzIGVsZW1lbnQncyBsaWdodC1ET00gYDxzdHlsZT5gXG4gICAgICovXG4gICAgZ2V0U3R5bGUoKSB7XG4gICAgICBpZiAodGhpcy5fc3R5bGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0eWxlO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3R5bGUgPSAvKiogQHR5cGUge0hUTUxTdHlsZUVsZW1lbnR9ICovKHRoaXMucXVlcnlTZWxlY3Rvcignc3R5bGUnKSk7XG4gICAgICBpZiAoIXN0eWxlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgdGhpcy5fc3R5bGUgPSBzdHlsZTtcbiAgICAgIGNvbnN0IGluY2x1ZGUgPSBzdHlsZS5nZXRBdHRyaWJ1dGUoYXR0cik7XG4gICAgICBpZiAoaW5jbHVkZSkge1xuICAgICAgICBzdHlsZS5yZW1vdmVBdHRyaWJ1dGUoYXR0cik7XG4gICAgICAgIHN0eWxlLnRleHRDb250ZW50ID0gUG9seW1lci5TdHlsZUdhdGhlci5jc3NGcm9tTW9kdWxlcyhpbmNsdWRlKSArIHN0eWxlLnRleHRDb250ZW50O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX3N0eWxlO1xuICAgIH1cbiAgfVxuXG4gIHdpbmRvdy5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ2N1c3RvbS1zdHlsZScsIEN1c3RvbVN0eWxlKTtcbiAgUG9seW1lci5DdXN0b21TdHlsZSA9IEN1c3RvbVN0eWxlO1xufSkoKTtcbjwvc2NyaXB0PlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi9lbGVtZW50cy9jdXN0b20tc3R5bGUuaHRtbCIsIlxucmVxdWlyZSgnLi9jdXN0b20tc3R5bGUtaW50ZXJmYWNlLm1pbi5qcycpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9zaGFkeWNzcy9jdXN0b20tc3R5bGUtaW50ZXJmYWNlLmh0bWwiLCIoZnVuY3Rpb24oKXsvKlxuXG5Db3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4qL1xuJ3VzZSBzdHJpY3QnO3ZhciBjPSEod2luZG93LlNoYWR5RE9NJiZ3aW5kb3cuU2hhZHlET00uaW5Vc2UpLGY7ZnVuY3Rpb24gZyhhKXtmPWEmJmEuc2hpbWNzc3Byb3BlcnRpZXM/ITE6Y3x8IShuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9BcHBsZVdlYktpdFxcLzYwMXxFZGdlXFwvMTUvKXx8IXdpbmRvdy5DU1N8fCFDU1Muc3VwcG9ydHN8fCFDU1Muc3VwcG9ydHMoXCJib3gtc2hhZG93XCIsXCIwIDAgMCB2YXIoLS1mb28pXCIpKX13aW5kb3cuU2hhZHlDU1MmJnZvaWQgMCE9PXdpbmRvdy5TaGFkeUNTUy5uYXRpdmVDc3M/Zj13aW5kb3cuU2hhZHlDU1MubmF0aXZlQ3NzOndpbmRvdy5TaGFkeUNTUz8oZyh3aW5kb3cuU2hhZHlDU1MpLHdpbmRvdy5TaGFkeUNTUz12b2lkIDApOmcod2luZG93LldlYkNvbXBvbmVudHMmJndpbmRvdy5XZWJDb21wb25lbnRzLmZsYWdzKTt2YXIgaD1mO2Z1bmN0aW9uIGsoYSxiKXtmb3IodmFyIGQgaW4gYiludWxsPT09ZD9hLnN0eWxlLnJlbW92ZVByb3BlcnR5KGQpOmEuc3R5bGUuc2V0UHJvcGVydHkoZCxiW2RdKX07dmFyIGw9bnVsbCxtPXdpbmRvdy5IVE1MSW1wb3J0cyYmd2luZG93LkhUTUxJbXBvcnRzLndoZW5SZWFkeXx8bnVsbCxuO2Z1bmN0aW9uIHAoKXt2YXIgYT1xO3JlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbigpe20/bShhKToobHx8KGw9bmV3IFByb21pc2UoZnVuY3Rpb24oYSl7bj1hfSksXCJjb21wbGV0ZVwiPT09ZG9jdW1lbnQucmVhZHlTdGF0ZT9uKCk6ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInJlYWR5c3RhdGVjaGFuZ2VcIixmdW5jdGlvbigpe1wiY29tcGxldGVcIj09PWRvY3VtZW50LnJlYWR5U3RhdGUmJm4oKX0pKSxsLnRoZW4oZnVuY3Rpb24oKXthJiZhKCl9KSl9KX07dmFyIHI9bnVsbCxxPW51bGw7ZnVuY3Rpb24gdCgpe3RoaXMuY3VzdG9tU3R5bGVzPVtdO3RoaXMuZW5xdWV1ZWQ9ITF9ZnVuY3Rpb24gdShhKXshYS5lbnF1ZXVlZCYmcSYmKGEuZW5xdWV1ZWQ9ITAscCgpKX10LnByb3RvdHlwZS5jPWZ1bmN0aW9uKGEpe2EuX19zZWVuQnlTaGFkeUNTU3x8KGEuX19zZWVuQnlTaGFkeUNTUz0hMCx0aGlzLmN1c3RvbVN0eWxlcy5wdXNoKGEpLHUodGhpcykpfTt0LnByb3RvdHlwZS5iPWZ1bmN0aW9uKGEpe2lmKGEuX19zaGFkeUNTU0NhY2hlZFN0eWxlKXJldHVybiBhLl9fc2hhZHlDU1NDYWNoZWRTdHlsZTt2YXIgYjthLmdldFN0eWxlP2I9YS5nZXRTdHlsZSgpOmI9YTtyZXR1cm4gYn07XG50LnByb3RvdHlwZS5hPWZ1bmN0aW9uKCl7Zm9yKHZhciBhPXRoaXMuY3VzdG9tU3R5bGVzLGI9MDtiPGEubGVuZ3RoO2IrKyl7dmFyIGQ9YVtiXTtpZighZC5fX3NoYWR5Q1NTQ2FjaGVkU3R5bGUpe3ZhciBlPXRoaXMuYihkKTtlJiYoZT1lLl9fYXBwbGllZEVsZW1lbnR8fGUsciYmcihlKSxkLl9fc2hhZHlDU1NDYWNoZWRTdHlsZT1lKX19cmV0dXJuIGF9O3QucHJvdG90eXBlLmFkZEN1c3RvbVN0eWxlPXQucHJvdG90eXBlLmM7dC5wcm90b3R5cGUuZ2V0U3R5bGVGb3JDdXN0b21TdHlsZT10LnByb3RvdHlwZS5iO3QucHJvdG90eXBlLnByb2Nlc3NTdHlsZXM9dC5wcm90b3R5cGUuYTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHQucHJvdG90eXBlLHt0cmFuc2Zvcm1DYWxsYmFjazp7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHJ9LHNldDpmdW5jdGlvbihhKXtyPWF9fSx2YWxpZGF0ZUNhbGxiYWNrOntnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gcX0sc2V0OmZ1bmN0aW9uKGEpe3ZhciBiPSExO3F8fChiPSEwKTtxPWE7YiYmdSh0aGlzKX19fSk7dmFyIHY9bmV3IHQ7d2luZG93LlNoYWR5Q1NTfHwod2luZG93LlNoYWR5Q1NTPXtwcmVwYXJlVGVtcGxhdGU6ZnVuY3Rpb24oKXt9LHN0eWxlU3VidHJlZTpmdW5jdGlvbihhLGIpe3YuYSgpO2soYSxiKX0sc3R5bGVFbGVtZW50OmZ1bmN0aW9uKCl7di5hKCl9LHN0eWxlRG9jdW1lbnQ6ZnVuY3Rpb24oYSl7di5hKCk7ayhkb2N1bWVudC5ib2R5LGEpfSxnZXRDb21wdXRlZFN0eWxlVmFsdWU6ZnVuY3Rpb24oYSxiKXtyZXR1cm4oYT13aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShhKS5nZXRQcm9wZXJ0eVZhbHVlKGIpKT9hLnRyaW0oKTpcIlwifSxuYXRpdmVDc3M6aCxuYXRpdmVTaGFkb3c6Y30pO3dpbmRvdy5TaGFkeUNTUy5DdXN0b21TdHlsZUludGVyZmFjZT12O30pLmNhbGwodGhpcyk7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWN1c3RvbS1zdHlsZS1pbnRlcmZhY2UubWluLmpzLm1hcFxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9zaGFkeWNzcy9jdXN0b20tc3R5bGUtaW50ZXJmYWNlLm1pbi5qcyIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cblxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL21peGlucy9tdXRhYmxlLWRhdGEuaHRtbFwiPlxuXG48c2NyaXB0PlxuKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgbGV0IG11dGFibGVQcm9wZXJ0eUNoYW5nZTtcbiAgKFxuICAgIC8qKiBAc3VwcHJlc3Mge21pc3NpbmdQcm9wZXJ0aWVzfSAqL1xuICAgIGZ1bmN0aW9uKCkge1xuICAgIG11dGFibGVQcm9wZXJ0eUNoYW5nZSA9IFBvbHltZXIuTXV0YWJsZURhdGEuX211dGFibGVQcm9wZXJ0eUNoYW5nZTtcbiAgfSkoKTtcblxuICAvKipcbiAgICogTGVnYWN5IGVsZW1lbnQgYmVoYXZpb3IgdG8gc2tpcCBzdHJpY3QgZGlydHktY2hlY2tpbmcgZm9yIG9iamVjdHMgYW5kIGFycmF5cyxcbiAgICogKGFsd2F5cyBjb25zaWRlciB0aGVtIHRvIGJlIFwiZGlydHlcIikgZm9yIHVzZSBvbiBsZWdhY3kgQVBJIFBvbHltZXIgZWxlbWVudHMuXG4gICAqXG4gICAqIEJ5IGRlZmF1bHQsIGBQb2x5bWVyLlByb3BlcnR5RWZmZWN0c2AgcGVyZm9ybXMgc3RyaWN0IGRpcnR5IGNoZWNraW5nIG9uXG4gICAqIG9iamVjdHMsIHdoaWNoIG1lYW5zIHRoYXQgYW55IGRlZXAgbW9kaWZpY2F0aW9ucyB0byBhbiBvYmplY3Qgb3IgYXJyYXkgd2lsbFxuICAgKiBub3QgYmUgcHJvcGFnYXRlZCB1bmxlc3MgXCJpbW11dGFibGVcIiBkYXRhIHBhdHRlcm5zIGFyZSB1c2VkIChpLmUuIGFsbCBvYmplY3RcbiAgICogcmVmZXJlbmNlcyBmcm9tIHRoZSByb290IHRvIHRoZSBtdXRhdGlvbiB3ZXJlIGNoYW5nZWQpLlxuICAgKlxuICAgKiBQb2x5bWVyIGFsc28gcHJvdmlkZXMgYSBwcm9wcmlldGFyeSBkYXRhIG11dGF0aW9uIGFuZCBwYXRoIG5vdGlmaWNhdGlvbiBBUElcbiAgICogKGUuZy4gYG5vdGlmeVBhdGhgLCBgc2V0YCwgYW5kIGFycmF5IG11dGF0aW9uIEFQSSdzKSB0aGF0IGFsbG93IGVmZmljaWVudFxuICAgKiBtdXRhdGlvbiBhbmQgbm90aWZpY2F0aW9uIG9mIGRlZXAgY2hhbmdlcyBpbiBhbiBvYmplY3QgZ3JhcGggdG8gYWxsIGVsZW1lbnRzXG4gICAqIGJvdW5kIHRvIHRoZSBzYW1lIG9iamVjdCBncmFwaC5cbiAgICpcbiAgICogSW4gY2FzZXMgd2hlcmUgbmVpdGhlciBpbW11dGFibGUgcGF0dGVybnMgbm9yIHRoZSBkYXRhIG11dGF0aW9uIEFQSSBjYW4gYmVcbiAgICogdXNlZCwgYXBwbHlpbmcgdGhpcyBtaXhpbiB3aWxsIGNhdXNlIFBvbHltZXIgdG8gc2tpcCBkaXJ0eSBjaGVja2luZyBmb3JcbiAgICogb2JqZWN0cyBhbmQgYXJyYXlzIChhbHdheXMgY29uc2lkZXIgdGhlbSB0byBiZSBcImRpcnR5XCIpLiAgVGhpcyBhbGxvd3MgYVxuICAgKiB1c2VyIHRvIG1ha2UgYSBkZWVwIG1vZGlmaWNhdGlvbiB0byBhIGJvdW5kIG9iamVjdCBncmFwaCwgYW5kIHRoZW4gZWl0aGVyXG4gICAqIHNpbXBseSByZS1zZXQgdGhlIG9iamVjdCAoZS5nLiBgdGhpcy5pdGVtcyA9IHRoaXMuaXRlbXNgKSBvciBjYWxsIGBub3RpZnlQYXRoYFxuICAgKiAoZS5nLiBgdGhpcy5ub3RpZnlQYXRoKCdpdGVtcycpYCkgdG8gdXBkYXRlIHRoZSB0cmVlLiAgTm90ZSB0aGF0IGFsbFxuICAgKiBlbGVtZW50cyB0aGF0IHdpc2ggdG8gYmUgdXBkYXRlZCBiYXNlZCBvbiBkZWVwIG11dGF0aW9ucyBtdXN0IGFwcGx5IHRoaXNcbiAgICogbWl4aW4gb3Igb3RoZXJ3aXNlIHNraXAgc3RyaWN0IGRpcnR5IGNoZWNraW5nIGZvciBvYmplY3RzL2FycmF5cy5cbiAgICpcbiAgICogSW4gb3JkZXIgdG8gbWFrZSB0aGUgZGlydHkgY2hlY2sgc3RyYXRlZ3kgY29uZmlndXJhYmxlLCBzZWVcbiAgICogYFBvbHltZXIuT3B0aW9uYWxNdXRhYmxlRGF0YUJlaGF2aW9yYC5cbiAgICpcbiAgICogTm90ZSwgdGhlIHBlcmZvcm1hbmNlIGNoYXJhY3RlcmlzdGljcyBvZiBwcm9wYWdhdGluZyBsYXJnZSBvYmplY3QgZ3JhcGhzXG4gICAqIHdpbGwgYmUgd29yc2UgYXMgb3Bwb3NlZCB0byB1c2luZyBzdHJpY3QgZGlydHkgY2hlY2tpbmcgd2l0aCBpbW11dGFibGVcbiAgICogcGF0dGVybnMgb3IgUG9seW1lcidzIHBhdGggbm90aWZpY2F0aW9uIEFQSS5cbiAgICpcbiAgICogQHBvbHltZXJCZWhhdmlvclxuICAgKiBAbWVtYmVyb2YgUG9seW1lclxuICAgKiBAc3VtbWFyeSBCZWhhdmlvciB0byBza2lwIHN0cmljdCBkaXJ0eS1jaGVja2luZyBmb3Igb2JqZWN0cyBhbmRcbiAgICogICBhcnJheXNcbiAgICovXG4gIFBvbHltZXIuTXV0YWJsZURhdGFCZWhhdmlvciA9IHtcblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlcyBgUG9seW1lci5Qcm9wZXJ0eUVmZmVjdHNgIHRvIHByb3ZpZGUgb3B0aW9uIGZvciBza2lwcGluZ1xuICAgICAqIHN0cmljdCBlcXVhbGl0eSBjaGVja2luZyBmb3IgT2JqZWN0cyBhbmQgQXJyYXlzLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgcHVsbHMgdGhlIHZhbHVlIHRvIGRpcnR5IGNoZWNrIGFnYWluc3QgZnJvbSB0aGUgYF9fZGF0YVRlbXBgXG4gICAgICogY2FjaGUgKHJhdGhlciB0aGFuIHRoZSBub3JtYWwgYF9fZGF0YWAgY2FjaGUpIGZvciBPYmplY3RzLiAgU2luY2UgdGhlIHRlbXBcbiAgICAgKiBjYWNoZSBpcyBjbGVhcmVkIGF0IHRoZSBlbmQgb2YgYSB0dXJuLCB0aGlzIGltcGxlbWVudGF0aW9uIGFsbG93c1xuICAgICAqIHNpZGUtZWZmZWN0cyBvZiBkZWVwIG9iamVjdCBjaGFuZ2VzIHRvIGJlIHByb2Nlc3NlZCBieSByZS1zZXR0aW5nIHRoZVxuICAgICAqIHNhbWUgb2JqZWN0ICh1c2luZyB0aGUgdGVtcCBjYWNoZSBhcyBhbiBpbi10dXJuIGJhY2tzdG9wIHRvIHByZXZlbnRcbiAgICAgKiBjeWNsZXMgZHVlIHRvIDItd2F5IG5vdGlmaWNhdGlvbikuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgbmFtZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgTmV3IHByb3BlcnR5IHZhbHVlXG4gICAgICogQHBhcmFtIHsqfSBvbGQgUHJldmlvdXMgcHJvcGVydHkgdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBwcm9wZXJ0eSBzaG91bGQgYmUgY29uc2lkZXJlZCBhIGNoYW5nZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfc2hvdWxkUHJvcGVydHlDaGFuZ2UocHJvcGVydHksIHZhbHVlLCBvbGQpIHtcbiAgICAgIHJldHVybiBtdXRhYmxlUHJvcGVydHlDaGFuZ2UodGhpcywgcHJvcGVydHksIHZhbHVlLCBvbGQsIHRydWUpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogTGVnYWN5IGVsZW1lbnQgYmVoYXZpb3IgdG8gYWRkIHRoZSBvcHRpb25hbCBhYmlsaXR5IHRvIHNraXAgc3RyaWN0XG4gICAqIGRpcnR5LWNoZWNraW5nIGZvciBvYmplY3RzIGFuZCBhcnJheXMgKGFsd2F5cyBjb25zaWRlciB0aGVtIHRvIGJlXG4gICAqIFwiZGlydHlcIikgYnkgc2V0dGluZyBhIGBtdXRhYmxlLWRhdGFgIGF0dHJpYnV0ZSBvbiBhbiBlbGVtZW50IGluc3RhbmNlLlxuICAgKlxuICAgKiBCeSBkZWZhdWx0LCBgUG9seW1lci5Qcm9wZXJ0eUVmZmVjdHNgIHBlcmZvcm1zIHN0cmljdCBkaXJ0eSBjaGVja2luZyBvblxuICAgKiBvYmplY3RzLCB3aGljaCBtZWFucyB0aGF0IGFueSBkZWVwIG1vZGlmaWNhdGlvbnMgdG8gYW4gb2JqZWN0IG9yIGFycmF5IHdpbGxcbiAgICogbm90IGJlIHByb3BhZ2F0ZWQgdW5sZXNzIFwiaW1tdXRhYmxlXCIgZGF0YSBwYXR0ZXJucyBhcmUgdXNlZCAoaS5lLiBhbGwgb2JqZWN0XG4gICAqIHJlZmVyZW5jZXMgZnJvbSB0aGUgcm9vdCB0byB0aGUgbXV0YXRpb24gd2VyZSBjaGFuZ2VkKS5cbiAgICpcbiAgICogUG9seW1lciBhbHNvIHByb3ZpZGVzIGEgcHJvcHJpZXRhcnkgZGF0YSBtdXRhdGlvbiBhbmQgcGF0aCBub3RpZmljYXRpb24gQVBJXG4gICAqIChlLmcuIGBub3RpZnlQYXRoYCwgYHNldGAsIGFuZCBhcnJheSBtdXRhdGlvbiBBUEkncykgdGhhdCBhbGxvdyBlZmZpY2llbnRcbiAgICogbXV0YXRpb24gYW5kIG5vdGlmaWNhdGlvbiBvZiBkZWVwIGNoYW5nZXMgaW4gYW4gb2JqZWN0IGdyYXBoIHRvIGFsbCBlbGVtZW50c1xuICAgKiBib3VuZCB0byB0aGUgc2FtZSBvYmplY3QgZ3JhcGguXG4gICAqXG4gICAqIEluIGNhc2VzIHdoZXJlIG5laXRoZXIgaW1tdXRhYmxlIHBhdHRlcm5zIG5vciB0aGUgZGF0YSBtdXRhdGlvbiBBUEkgY2FuIGJlXG4gICAqIHVzZWQsIGFwcGx5aW5nIHRoaXMgbWl4aW4gd2lsbCBhbGxvdyBQb2x5bWVyIHRvIHNraXAgZGlydHkgY2hlY2tpbmcgZm9yXG4gICAqIG9iamVjdHMgYW5kIGFycmF5cyAoYWx3YXlzIGNvbnNpZGVyIHRoZW0gdG8gYmUgXCJkaXJ0eVwiKS4gIFRoaXMgYWxsb3dzIGFcbiAgICogdXNlciB0byBtYWtlIGEgZGVlcCBtb2RpZmljYXRpb24gdG8gYSBib3VuZCBvYmplY3QgZ3JhcGgsIGFuZCB0aGVuIGVpdGhlclxuICAgKiBzaW1wbHkgcmUtc2V0IHRoZSBvYmplY3QgKGUuZy4gYHRoaXMuaXRlbXMgPSB0aGlzLml0ZW1zYCkgb3IgY2FsbCBgbm90aWZ5UGF0aGBcbiAgICogKGUuZy4gYHRoaXMubm90aWZ5UGF0aCgnaXRlbXMnKWApIHRvIHVwZGF0ZSB0aGUgdHJlZS4gIE5vdGUgdGhhdCBhbGxcbiAgICogZWxlbWVudHMgdGhhdCB3aXNoIHRvIGJlIHVwZGF0ZWQgYmFzZWQgb24gZGVlcCBtdXRhdGlvbnMgbXVzdCBhcHBseSB0aGlzXG4gICAqIG1peGluIG9yIG90aGVyd2lzZSBza2lwIHN0cmljdCBkaXJ0eSBjaGVja2luZyBmb3Igb2JqZWN0cy9hcnJheXMuXG4gICAqXG4gICAqIFdoaWxlIHRoaXMgYmVoYXZpb3IgYWRkcyB0aGUgYWJpbGl0eSB0byBmb3JnbyBPYmplY3QvQXJyYXkgZGlydHkgY2hlY2tpbmcsXG4gICAqIHRoZSBgbXV0YWJsZURhdGFgIGZsYWcgZGVmYXVsdHMgdG8gZmFsc2UgYW5kIG11c3QgYmUgc2V0IG9uIHRoZSBpbnN0YW5jZS5cbiAgICpcbiAgICogTm90ZSwgdGhlIHBlcmZvcm1hbmNlIGNoYXJhY3RlcmlzdGljcyBvZiBwcm9wYWdhdGluZyBsYXJnZSBvYmplY3QgZ3JhcGhzXG4gICAqIHdpbGwgYmUgd29yc2UgYnkgcmVseWluZyBvbiBgbXV0YWJsZURhdGE6IHRydWVgIGFzIG9wcG9zZWQgdG8gdXNpbmdcbiAgICogc3RyaWN0IGRpcnR5IGNoZWNraW5nIHdpdGggaW1tdXRhYmxlIHBhdHRlcm5zIG9yIFBvbHltZXIncyBwYXRoIG5vdGlmaWNhdGlvblxuICAgKiBBUEkuXG4gICAqXG4gICAqIEBwb2x5bWVyQmVoYXZpb3JcbiAgICogQG1lbWJlcm9mIFBvbHltZXJcbiAgICogQHN1bW1hcnkgQmVoYXZpb3IgdG8gb3B0aW9uYWxseSBza2lwIHN0cmljdCBkaXJ0eS1jaGVja2luZyBmb3Igb2JqZWN0cyBhbmRcbiAgICogICBhcnJheXNcbiAgICovXG4gIFBvbHltZXIuT3B0aW9uYWxNdXRhYmxlRGF0YUJlaGF2aW9yID0ge1xuXG4gICAgcHJvcGVydGllczoge1xuICAgICAgLyoqXG4gICAgICAgKiBJbnN0YW5jZS1sZXZlbCBmbGFnIGZvciBjb25maWd1cmluZyB0aGUgZGlydHktY2hlY2tpbmcgc3RyYXRlZ3lcbiAgICAgICAqIGZvciB0aGlzIGVsZW1lbnQuICBXaGVuIHRydWUsIE9iamVjdHMgYW5kIEFycmF5cyB3aWxsIHNraXAgZGlydHlcbiAgICAgICAqIGNoZWNraW5nLCBvdGhlcndpc2Ugc3RyaWN0IGVxdWFsaXR5IGNoZWNraW5nIHdpbGwgYmUgdXNlZC5cbiAgICAgICAqL1xuICAgICAgbXV0YWJsZURhdGE6IEJvb2xlYW5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGVzIGBQb2x5bWVyLlByb3BlcnR5RWZmZWN0c2AgdG8gc2tpcCBzdHJpY3QgZXF1YWxpdHkgY2hlY2tpbmdcbiAgICAgKiBmb3IgT2JqZWN0cyBhbmQgQXJyYXlzLlxuICAgICAqXG4gICAgICogUHVsbHMgdGhlIHZhbHVlIHRvIGRpcnR5IGNoZWNrIGFnYWluc3QgZnJvbSB0aGUgYF9fZGF0YVRlbXBgIGNhY2hlXG4gICAgICogKHJhdGhlciB0aGFuIHRoZSBub3JtYWwgYF9fZGF0YWAgY2FjaGUpIGZvciBPYmplY3RzLiAgU2luY2UgdGhlIHRlbXBcbiAgICAgKiBjYWNoZSBpcyBjbGVhcmVkIGF0IHRoZSBlbmQgb2YgYSB0dXJuLCB0aGlzIGltcGxlbWVudGF0aW9uIGFsbG93c1xuICAgICAqIHNpZGUtZWZmZWN0cyBvZiBkZWVwIG9iamVjdCBjaGFuZ2VzIHRvIGJlIHByb2Nlc3NlZCBieSByZS1zZXR0aW5nIHRoZVxuICAgICAqIHNhbWUgb2JqZWN0ICh1c2luZyB0aGUgdGVtcCBjYWNoZSBhcyBhbiBpbi10dXJuIGJhY2tzdG9wIHRvIHByZXZlbnRcbiAgICAgKiBjeWNsZXMgZHVlIHRvIDItd2F5IG5vdGlmaWNhdGlvbikuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgbmFtZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgTmV3IHByb3BlcnR5IHZhbHVlXG4gICAgICogQHBhcmFtIHsqfSBvbGQgUHJldmlvdXMgcHJvcGVydHkgdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBwcm9wZXJ0eSBzaG91bGQgYmUgY29uc2lkZXJlZCBhIGNoYW5nZVxuICAgICAqIEB0aGlzIHt0aGlzfVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfc2hvdWxkUHJvcGVydHlDaGFuZ2UocHJvcGVydHksIHZhbHVlLCBvbGQpIHtcbiAgICAgIHJldHVybiBtdXRhYmxlUHJvcGVydHlDaGFuZ2UodGhpcywgcHJvcGVydHksIHZhbHVlLCBvbGQsIHRoaXMubXV0YWJsZURhdGEpO1xuICAgIH1cbiAgfTtcblxufSkoKTtcblxuPC9zY3JpcHQ+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL3BvbHltZXIvbGliL2xlZ2FjeS9tdXRhYmxlLWRhdGEtYmVoYXZpb3IuaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTUgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cblxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uLy4uL3BvbHltZXIvcG9seW1lci5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vLi4vaXJvbi1tZWRpYS1xdWVyeS9pcm9uLW1lZGlhLXF1ZXJ5Lmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi9hcHAtbGF5b3V0LWJlaGF2aW9yL2FwcC1sYXlvdXQtYmVoYXZpb3IuaHRtbFwiPlxuXG48IS0tXG5hcHAtZHJhd2VyLWxheW91dCBpcyBhIHdyYXBwZXIgZWxlbWVudCB0aGF0IHBvc2l0aW9ucyBhbiBhcHAtZHJhd2VyIGFuZCBvdGhlciBjb250ZW50LiBXaGVuXG50aGUgdmlld3BvcnQgd2lkdGggaXMgc21hbGxlciB0aGFuIGByZXNwb25zaXZlV2lkdGhgLCB0aGlzIGVsZW1lbnQgY2hhbmdlcyB0byBuYXJyb3cgbGF5b3V0LlxuSW4gbmFycm93IGxheW91dCwgdGhlIGRyYXdlciB3aWxsIGJlIHN0YWNrZWQgb24gdG9wIG9mIHRoZSBtYWluIGNvbnRlbnQuIFRoZSBkcmF3ZXIgd2lsbCBzbGlkZVxuaW4vb3V0IHRvIGhpZGUvcmV2ZWFsIHRoZSBtYWluIGNvbnRlbnQuXG5cbkJ5IGRlZmF1bHQgdGhlIGRyYXdlciBpcyBhbGlnbmVkIHRvIHRoZSBzdGFydCwgd2hpY2ggaXMgbGVmdCBpbiBMVFIgbGF5b3V0czpcblxuYGBgaHRtbFxuPGFwcC1kcmF3ZXItbGF5b3V0PlxuICA8YXBwLWRyYXdlciBzbG90PVwiZHJhd2VyXCI+XG4gICAgZHJhd2VyIGNvbnRlbnRcbiAgPC9hcHAtZHJhd2VyPlxuICA8ZGl2PlxuICAgIG1haW4gY29udGVudFxuICA8L2Rpdj5cbjwvYXBwLWRyYXdlci1sYXlvdXQ+XG5gYGBcblxuQWxpZ24gdGhlIGRyYXdlciBhdCB0aGUgZW5kOlxuXG5gYGBodG1sXG48YXBwLWRyYXdlci1sYXlvdXQ+XG4gIDxhcHAtZHJhd2VyIHNsb3Q9XCJkcmF3ZXJcIiBhbGlnbj1cImVuZFwiPlxuICAgICBkcmF3ZXIgY29udGVudFxuICA8L2FwcC1kcmF3ZXI+XG4gIDxkaXY+XG4gICAgbWFpbiBjb250ZW50XG4gIDwvZGl2PlxuPC9hcHAtZHJhd2VyLWxheW91dD5cbmBgYFxuXG5XaXRoIGFuIGFwcC1oZWFkZXItbGF5b3V0OlxuXG5gYGBodG1sXG48YXBwLWRyYXdlci1sYXlvdXQ+XG4gIDxhcHAtZHJhd2VyIHNsb3Q9XCJkcmF3ZXJcIj5cbiAgICBkcmF3ZXItY29udGVudFxuICA8L2FwcC1kcmF3ZXI+XG4gIDxhcHAtaGVhZGVyLWxheW91dD5cbiAgICA8YXBwLWhlYWRlciBzbG90PVwiaGVhZGVyXCI+XG4gICAgICA8YXBwLXRvb2xiYXI+XG4gICAgICAgIDxkaXYgbWFpbi10aXRsZT5BcHAgbmFtZTwvZGl2PlxuICAgICAgPC9hcHAtdG9vbGJhcj5cbiAgICA8L2FwcC1oZWFkZXI+XG5cbiAgICBtYWluIGNvbnRlbnRcblxuICA8L2FwcC1oZWFkZXItbGF5b3V0PlxuPC9hcHAtZHJhd2VyLWxheW91dD5cbmBgYFxuXG5BZGQgdGhlIGBkcmF3ZXItdG9nZ2xlYCBhdHRyaWJ1dGUgdG8gZWxlbWVudHMgaW5zaWRlIGBhcHAtZHJhd2VyLWxheW91dGAgdGhhdCB0b2dnbGUgdGhlIGRyYXdlciBvbiBjbGljayBldmVudHM6XG5cbmBgYGh0bWxcbjxhcHAtZHJhd2VyLWxheW91dD5cbiAgPGFwcC1kcmF3ZXIgc2xvdD1cImRyYXdlclwiPlxuICAgIGRyYXdlci1jb250ZW50XG4gIDwvYXBwLWRyYXdlcj5cbiAgPGFwcC1oZWFkZXItbGF5b3V0PlxuICAgIDxhcHAtaGVhZGVyIHNsb3Q9XCJoZWFkZXJcIj5cbiAgICAgIDxhcHAtdG9vbGJhcj5cbiAgICAgICAgPHBhcGVyLWljb24tYnV0dG9uIGljb249XCJtZW51XCIgZHJhd2VyLXRvZ2dsZT48L3BhcGVyLWljb24tYnV0dG9uPlxuICAgICAgICA8ZGl2IG1haW4tdGl0bGU+QXBwIG5hbWU8L2Rpdj5cbiAgICAgIDwvYXBwLXRvb2xiYXI+XG4gICAgPC9hcHAtaGVhZGVyPlxuXG4gICAgbWFpbiBjb250ZW50XG5cbiAgPC9hcHAtaGVhZGVyLWxheW91dD5cbjwvYXBwLWRyYXdlci1sYXlvdXQ+XG5gYGBcblxuKipOT1RFOioqIFdpdGggYXBwLWxheW91dCAyLjAsIHRoZSBgZHJhd2VyLXRvZ2dsZWAgZWxlbWVudCB3aWxsIG5vdCBiZSBhdXRvbWF0aWNhbGx5IGhpZGRlblxud2hlbiBhcHAtZHJhd2VyLWxheW91dCBpcyBub3QgaW4gbmFycm93IGxheW91dC4gVG8gYWRkIHRoaXMsIGFkZCB0aGUgZm9sbG93aW5nIENTUyBydWxlIHdoZXJlXG5hcHAtZHJhd2VyLWxheW91dCBpcyB1c2VkOlxuXG5gYGBjc3NcbmFwcC1kcmF3ZXItbGF5b3V0Om5vdChbbmFycm93XSkgW2RyYXdlci10b2dnbGVdIHtcbiAgZGlzcGxheTogbm9uZTtcbn1cbmBgYFxuXG5BZGQgdGhlIGBmdWxsYmxlZWRgIGF0dHJpYnV0ZSB0byBhcHAtZHJhd2VyLWxheW91dCB0byBtYWtlIGl0IGZpdCB0aGUgc2l6ZSBvZiBpdHMgY29udGFpbmVyOlxuXG5gYGBodG1sXG48YXBwLWRyYXdlci1sYXlvdXQgZnVsbGJsZWVkPlxuICA8YXBwLWRyYXdlciBzbG90PVwiZHJhd2VyXCI+XG4gICAgIGRyYXdlciBjb250ZW50XG4gIDwvYXBwLWRyYXdlcj5cbiAgPGRpdj5cbiAgICBtYWluIGNvbnRlbnRcbiAgPC9kaXY+XG48L2FwcC1kcmF3ZXItbGF5b3V0PlxuYGBgXG5cbiMjIyBTdHlsaW5nXG5cbkN1c3RvbSBwcm9wZXJ0eSAgICAgICAgICAgICAgICAgICAgICAgICAgfCBEZXNjcmlwdGlvbiAgICAgICAgICAgICAgICAgICAgICAgICAgfCBEZWZhdWx0XG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXwtLS0tLS0tLS1cbmAtLWFwcC1kcmF3ZXItd2lkdGhgICAgICAgICAgICAgICAgICAgICAgfCBXaWR0aCBvZiB0aGUgZHJhd2VyICAgICAgICAgICAgICAgICAgfCAyNTZweFxuYC0tYXBwLWRyYXdlci1sYXlvdXQtY29udGVudC10cmFuc2l0aW9uYCB8IFRyYW5zaXRpb24gZm9yIHRoZSBjb250ZW50IGNvbnRhaW5lciB8IG5vbmVcblxuKipOT1RFOioqIElmIHlvdSB1c2UgPGFwcC1kcmF3ZXI+IHdpdGggPGFwcC1kcmF3ZXItbGF5b3V0PiBhbmQgc3BlY2lmeSBhIHZhbHVlIGZvclxuYC0tYXBwLWRyYXdlci13aWR0aGAsIHRoYXQgdmFsdWUgbXVzdCBiZSBhY2Nlc3NpYmxlIGJ5IGJvdGggZWxlbWVudHMuIFRoaXMgY2FuIGJlIGRvbmUgYnlcbmRlZmluaW5nIHRoZSB2YWx1ZSBvbiB0aGUgYDpob3N0YCB0aGF0IGNvbnRhaW5zIDxhcHAtZHJhd2VyLWxheW91dD4gKG9yIGBodG1sYCBpZiBvdXRzaWRlXG5hIHNoYWRvdyByb290KTpcblxuYGBgY3NzXG46aG9zdCB7XG4gIC0tYXBwLWRyYXdlci13aWR0aDogMzAwcHg7XG59XG5gYGBcblxuQGdyb3VwIEFwcCBFbGVtZW50c1xuQGVsZW1lbnQgYXBwLWRyYXdlci1sYXlvdXRcbkBkZW1vIGFwcC1kcmF3ZXItbGF5b3V0L2RlbW8vaW5kZXguaHRtbFxuLS0+XG5cbjxkb20tbW9kdWxlIGlkPVwiYXBwLWRyYXdlci1sYXlvdXRcIj5cbiAgPHRlbXBsYXRlPlxuICAgIDxzdHlsZT5cbiAgICAgIDpob3N0IHtcbiAgICAgICAgZGlzcGxheTogYmxvY2s7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGb3JjZSBhcHAtZHJhd2VyLWxheW91dCB0byBoYXZlIGl0cyBvd24gc3RhY2tpbmcgY29udGV4dCBzbyB0aGF0IGl0cyBwYXJlbnQgY2FuXG4gICAgICAgICAqIGNvbnRyb2wgdGhlIHN0YWNraW5nIG9mIGl0IHJlbGF0aXZlIHRvIG90aGVyIGVsZW1lbnRzLlxuICAgICAgICAgKi9cbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICB6LWluZGV4OiAwO1xuICAgICAgfVxuXG4gICAgICA6aG9zdCA6OnNsb3R0ZWQoW3Nsb3Q9ZHJhd2VyXSkge1xuICAgICAgICB6LWluZGV4OiAxO1xuICAgICAgfVxuXG4gICAgICA6aG9zdChbZnVsbGJsZWVkXSkge1xuICAgICAgICBAYXBwbHkgLS1sYXlvdXQtZml0O1xuICAgICAgfVxuXG4gICAgICAjY29udGVudENvbnRhaW5lciB7XG4gICAgICAgIC8qIENyZWF0ZSBhIHN0YWNraW5nIGNvbnRleHQgaGVyZSBzbyB0aGF0IGFsbCBjaGlsZHJlbiBhcHBlYXIgYmVsb3cgdGhlIGhlYWRlci4gKi9cbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICB6LWluZGV4OiAwO1xuICAgICAgICBoZWlnaHQ6IDEwMCU7XG4gICAgICAgIHRyYW5zaXRpb246IHZhcigtLWFwcC1kcmF3ZXItbGF5b3V0LWNvbnRlbnQtdHJhbnNpdGlvbiwgbm9uZSk7XG4gICAgICB9XG5cbiAgICAgICNjb250ZW50Q29udGFpbmVyW2RyYXdlci1wb3NpdGlvbj1sZWZ0XSB7XG4gICAgICAgIG1hcmdpbi1sZWZ0OiB2YXIoLS1hcHAtZHJhd2VyLXdpZHRoLCAyNTZweCk7XG4gICAgICB9XG5cbiAgICAgICNjb250ZW50Q29udGFpbmVyW2RyYXdlci1wb3NpdGlvbj1yaWdodF0ge1xuICAgICAgICBtYXJnaW4tcmlnaHQ6IHZhcigtLWFwcC1kcmF3ZXItd2lkdGgsIDI1NnB4KTtcbiAgICAgIH1cbiAgICA8L3N0eWxlPlxuXG4gICAgPHNsb3QgaWQ9XCJkcmF3ZXJTbG90XCIgbmFtZT1cImRyYXdlclwiPjwvc2xvdD5cblxuICAgIDxkaXYgaWQ9XCJjb250ZW50Q29udGFpbmVyXCIgZHJhd2VyLXBvc2l0aW9uJD1cIltbX2RyYXdlclBvc2l0aW9uXV1cIj5cbiAgICAgIDxzbG90Pjwvc2xvdD5cbiAgICA8L2Rpdj5cblxuICAgIDxpcm9uLW1lZGlhLXF1ZXJ5XG4gICAgICAgIHF1ZXJ5PVwiW1tfY29tcHV0ZU1lZGlhUXVlcnkoZm9yY2VOYXJyb3csIHJlc3BvbnNpdmVXaWR0aCldXVwiXG4gICAgICAgIG9uLXF1ZXJ5LW1hdGNoZXMtY2hhbmdlZD1cIl9vblF1ZXJ5TWF0Y2hlc0NoYW5nZWRcIj48L2lyb24tbWVkaWEtcXVlcnk+XG4gIDwvdGVtcGxhdGU+XG5cbiAgPHNjcmlwdD5cbiAgICBQb2x5bWVyKHtcbiAgICAgIGlzOiAnYXBwLWRyYXdlci1sYXlvdXQnLFxuXG4gICAgICBiZWhhdmlvcnM6IFtcbiAgICAgICAgUG9seW1lci5BcHBMYXlvdXRCZWhhdmlvclxuICAgICAgXSxcblxuICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgdHJ1ZSwgaWdub3JlIGByZXNwb25zaXZlV2lkdGhgIHNldHRpbmcgYW5kIGZvcmNlIHRoZSBuYXJyb3cgbGF5b3V0LlxuICAgICAgICAgKi9cbiAgICAgICAgZm9yY2VOYXJyb3c6IHtcbiAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0aGUgdmlld3BvcnQncyB3aWR0aCBpcyBzbWFsbGVyIHRoYW4gdGhpcyB2YWx1ZSwgdGhlIHBhbmVsIHdpbGwgY2hhbmdlIHRvIG5hcnJvd1xuICAgICAgICAgKiBsYXlvdXQuIEluIHRoZSBtb2RlIHRoZSBkcmF3ZXIgd2lsbCBiZSBjbG9zZWQuXG4gICAgICAgICAqL1xuICAgICAgICByZXNwb25zaXZlV2lkdGg6IHtcbiAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgdmFsdWU6ICc2NDBweCdcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0cnVlIGlmIGl0IGlzIGluIG5hcnJvdyBsYXlvdXQuIFRoaXMgaXMgdXNlZnVsIGlmIHlvdSBuZWVkIHRvIHNob3cvaGlkZVxuICAgICAgICAgKiBlbGVtZW50cyBiYXNlZCBvbiB0aGUgbGF5b3V0LlxuICAgICAgICAgKi9cbiAgICAgICAgbmFycm93OiB7XG4gICAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgICByZWZsZWN0VG9BdHRyaWJ1dGU6IHRydWUsXG4gICAgICAgICAgcmVhZE9ubHk6IHRydWUsXG4gICAgICAgICAgbm90aWZ5OiB0cnVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHRydWUsIHRoZSBkcmF3ZXIgd2lsbCBpbml0aWFsbHkgYmUgb3BlbmVkIHdoZW4gaW4gbmFycm93IGxheW91dCBtb2RlLlxuICAgICAgICAgKi9cbiAgICAgICAgb3BlbmVkV2hlbk5hcnJvdzoge1xuICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgIH0sXG5cbiAgICAgICAgX2RyYXdlclBvc2l0aW9uOiB7XG4gICAgICAgICAgdHlwZTogU3RyaW5nXG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIGxpc3RlbmVyczoge1xuICAgICAgICAnY2xpY2snOiAnX2NsaWNrSGFuZGxlcidcbiAgICAgIH0sXG5cbiAgICAgIG9ic2VydmVyczogW1xuICAgICAgICAnX25hcnJvd0NoYW5nZWQobmFycm93KSdcbiAgICAgIF0sXG5cbiAgICAgIC8qKlxuICAgICAgICogQSByZWZlcmVuY2UgdG8gdGhlIGFwcC1kcmF3ZXIgZWxlbWVudC5cbiAgICAgICAqXG4gICAgICAgKiBAcHJvcGVydHkgZHJhd2VyXG4gICAgICAgKi9cbiAgICAgIGdldCBkcmF3ZXIoKSB7XG4gICAgICAgIHJldHVybiBQb2x5bWVyLmRvbSh0aGlzLiQuZHJhd2VyU2xvdCkuZ2V0RGlzdHJpYnV0ZWROb2RlcygpWzBdO1xuICAgICAgfSxcblxuICAgICAgYXR0YWNoZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBEaXNhYmxlIGRyYXdlciB0cmFuc2l0aW9ucyB1bnRpbCBhZnRlciBhcHAtZHJhd2VyLWxheW91dCBzZXRzIHRoZSBpbml0aWFsIG9wZW5lZCBzdGF0ZS5cbiAgICAgICAgdmFyIGRyYXdlciA9IHRoaXMuZHJhd2VyO1xuICAgICAgICBpZiAoZHJhd2VyKSB7XG4gICAgICAgICAgZHJhd2VyLnNldEF0dHJpYnV0ZSgnbm8tdHJhbnNpdGlvbicsICcnKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgX2NsaWNrSGFuZGxlcjogZnVuY3Rpb24oZSkge1xuICAgICAgICB2YXIgdGFyZ2V0ID0gUG9seW1lci5kb20oZSkubG9jYWxUYXJnZXQ7XG4gICAgICAgIGlmICh0YXJnZXQgJiYgdGFyZ2V0Lmhhc0F0dHJpYnV0ZSgnZHJhd2VyLXRvZ2dsZScpKSB7XG4gICAgICAgICAgdmFyIGRyYXdlciA9IHRoaXMuZHJhd2VyO1xuICAgICAgICAgIGlmIChkcmF3ZXIgJiYgIWRyYXdlci5wZXJzaXN0ZW50KSB7XG4gICAgICAgICAgICBkcmF3ZXIudG9nZ2xlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBfdXBkYXRlTGF5b3V0U3RhdGVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGRyYXdlciA9IHRoaXMuZHJhd2VyO1xuICAgICAgICBpZiAoIXRoaXMuaXNBdHRhY2hlZCB8fCAhZHJhd2VyKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZHJhd2VyUG9zaXRpb24gPSB0aGlzLm5hcnJvdyA/IG51bGwgOiBkcmF3ZXIucG9zaXRpb247XG4gICAgICAgIGlmICh0aGlzLl9kcmF3ZXJOZWVkc1Jlc2V0KSB7XG4gICAgICAgICAgaWYgKHRoaXMubmFycm93KSB7XG4gICAgICAgICAgICBkcmF3ZXIub3BlbmVkID0gdGhpcy5vcGVuZWRXaGVuTmFycm93O1xuICAgICAgICAgICAgZHJhd2VyLnBlcnNpc3RlbnQgPSBmYWxzZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZHJhd2VyLm9wZW5lZCA9IGRyYXdlci5wZXJzaXN0ZW50ID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGRyYXdlci5oYXNBdHRyaWJ1dGUoJ25vLXRyYW5zaXRpb24nKSkge1xuICAgICAgICAgICAgLy8gRW5hYmxlIGRyYXdlciB0cmFuc2l0aW9ucyBhZnRlciBhcHAtZHJhd2VyLWxheW91dCBzZXRzIHRoZSBpbml0aWFsIG9wZW5lZCBzdGF0ZS5cbiAgICAgICAgICAgIFBvbHltZXIuUmVuZGVyU3RhdHVzLmFmdGVyTmV4dFJlbmRlcih0aGlzLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgZHJhd2VyLnJlbW92ZUF0dHJpYnV0ZSgnbm8tdHJhbnNpdGlvbicpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX2RyYXdlck5lZWRzUmVzZXQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgX25hcnJvd0NoYW5nZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9kcmF3ZXJOZWVkc1Jlc2V0ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5yZXNldExheW91dCgpO1xuICAgICAgfSxcblxuICAgICAgX29uUXVlcnlNYXRjaGVzQ2hhbmdlZDogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgdGhpcy5fc2V0TmFycm93KGV2ZW50LmRldGFpbC52YWx1ZSk7XG4gICAgICB9LFxuXG4gICAgICBfY29tcHV0ZU1lZGlhUXVlcnk6IGZ1bmN0aW9uKGZvcmNlTmFycm93LCByZXNwb25zaXZlV2lkdGgpIHtcbiAgICAgICAgcmV0dXJuIGZvcmNlTmFycm93ID8gJyhtaW4td2lkdGg6IDBweCknIDogJyhtYXgtd2lkdGg6ICcgKyByZXNwb25zaXZlV2lkdGggKyAnKSc7XG4gICAgICB9XG4gICAgfSk7XG4gIDwvc2NyaXB0PlxuPC9kb20tbW9kdWxlPlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9hcHAtbGF5b3V0L2FwcC1kcmF3ZXItbGF5b3V0L2FwcC1kcmF3ZXItbGF5b3V0Lmh0bWwiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE1IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi9wb2x5bWVyL3BvbHltZXIuaHRtbFwiPlxuXG48IS0tXG5gaXJvbi1tZWRpYS1xdWVyeWAgY2FuIGJlIHVzZWQgdG8gZGF0YSBiaW5kIHRvIGEgQ1NTIG1lZGlhIHF1ZXJ5LlxuVGhlIGBxdWVyeWAgcHJvcGVydHkgaXMgYSBiYXJlIENTUyBtZWRpYSBxdWVyeS5cblRoZSBgcXVlcnktbWF0Y2hlc2AgcHJvcGVydHkgaXMgYSBib29sZWFuIHJlcHJlc2VudGluZyB3aGV0aGVyIHRoZSBwYWdlIG1hdGNoZXMgdGhhdCBtZWRpYSBxdWVyeS5cblxuRXhhbXBsZTpcblxuICAgIDxpcm9uLW1lZGlhLXF1ZXJ5IHF1ZXJ5PVwiKG1pbi13aWR0aDogNjAwcHgpXCIgcXVlcnktbWF0Y2hlcz1cInt7cXVlcnlNYXRjaGVzfX1cIj48L2lyb24tbWVkaWEtcXVlcnk+XG5cbkBncm91cCBJcm9uIEVsZW1lbnRzXG5AZGVtbyBkZW1vL2luZGV4Lmh0bWxcbkBoZXJvIGhlcm8uc3ZnXG5AZWxlbWVudCBpcm9uLW1lZGlhLXF1ZXJ5XG4tLT5cblxuPHNjcmlwdD5cblxuICBQb2x5bWVyKHtcblxuICAgIGlzOiAnaXJvbi1tZWRpYS1xdWVyeScsXG5cbiAgICBwcm9wZXJ0aWVzOiB7XG5cbiAgICAgIC8qKlxuICAgICAgICogVGhlIEJvb2xlYW4gcmV0dXJuIHZhbHVlIG9mIHRoZSBtZWRpYSBxdWVyeS5cbiAgICAgICAqL1xuICAgICAgcXVlcnlNYXRjaGVzOiB7XG4gICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgIHZhbHVlOiBmYWxzZSxcbiAgICAgICAgcmVhZE9ubHk6IHRydWUsXG4gICAgICAgIG5vdGlmeTogdHJ1ZVxuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBUaGUgQ1NTIG1lZGlhIHF1ZXJ5IHRvIGV2YWx1YXRlLlxuICAgICAgICovXG4gICAgICBxdWVyeToge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIG9ic2VydmVyOiAncXVlcnlDaGFuZ2VkJ1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBJZiB0cnVlLCB0aGUgcXVlcnkgYXR0cmlidXRlIGlzIGFzc3VtZWQgdG8gYmUgYSBjb21wbGV0ZSBtZWRpYSBxdWVyeVxuICAgICAgICogc3RyaW5nIHJhdGhlciB0aGFuIGEgc2luZ2xlIG1lZGlhIGZlYXR1cmUuXG4gICAgICAgKi9cbiAgICAgIGZ1bGw6IHtcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIEB0eXBlIHtmdW5jdGlvbihNZWRpYVF1ZXJ5TGlzdCl9XG4gICAgICAgKi9cbiAgICAgIF9ib3VuZE1RSGFuZGxlcjoge1xuICAgICAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucXVlcnlIYW5kbGVyLmJpbmQodGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogQHR5cGUge01lZGlhUXVlcnlMaXN0fVxuICAgICAgICovXG4gICAgICBfbXE6IHtcbiAgICAgICAgdmFsdWU6IG51bGxcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgYXR0YWNoZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgdGhpcy5xdWVyeUNoYW5nZWQoKTtcbiAgICB9LFxuXG4gICAgZGV0YWNoZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fcmVtb3ZlKCk7XG4gICAgfSxcblxuICAgIF9hZGQ6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuX21xKSB7XG4gICAgICAgIHRoaXMuX21xLmFkZExpc3RlbmVyKHRoaXMuX2JvdW5kTVFIYW5kbGVyKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgX3JlbW92ZTogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5fbXEpIHtcbiAgICAgICAgdGhpcy5fbXEucmVtb3ZlTGlzdGVuZXIodGhpcy5fYm91bmRNUUhhbmRsZXIpO1xuICAgICAgfVxuICAgICAgdGhpcy5fbXEgPSBudWxsO1xuICAgIH0sXG5cbiAgICBxdWVyeUNoYW5nZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fcmVtb3ZlKCk7XG4gICAgICB2YXIgcXVlcnkgPSB0aGlzLnF1ZXJ5O1xuICAgICAgaWYgKCFxdWVyeSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuZnVsbCAmJiBxdWVyeVswXSAhPT0gJygnKSB7XG4gICAgICAgIHF1ZXJ5ID0gJygnICsgcXVlcnkgKyAnKSc7XG4gICAgICB9XG4gICAgICB0aGlzLl9tcSA9IHdpbmRvdy5tYXRjaE1lZGlhKHF1ZXJ5KTtcbiAgICAgIHRoaXMuX2FkZCgpO1xuICAgICAgdGhpcy5xdWVyeUhhbmRsZXIodGhpcy5fbXEpO1xuICAgIH0sXG5cbiAgICBxdWVyeUhhbmRsZXI6IGZ1bmN0aW9uKG1xKSB7XG4gICAgICB0aGlzLl9zZXRRdWVyeU1hdGNoZXMobXEubWF0Y2hlcyk7XG4gICAgfVxuXG4gIH0pO1xuXG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvaXJvbi1tZWRpYS1xdWVyeS9pcm9uLW1lZGlhLXF1ZXJ5Lmh0bWwiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE1IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi8uLi9wb2x5bWVyL3BvbHltZXIuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uLy4uL2lyb24tZmxleC1sYXlvdXQvaXJvbi1mbGV4LWxheW91dC5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vYXBwLXNjcm9sbC1lZmZlY3RzL2FwcC1zY3JvbGwtZWZmZWN0cy1iZWhhdmlvci5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vYXBwLWxheW91dC1iZWhhdmlvci9hcHAtbGF5b3V0LWJlaGF2aW9yLmh0bWxcIj5cblxuPCEtLVxuYXBwLWhlYWRlciBpcyBjb250YWluZXIgZWxlbWVudCBmb3IgYXBwLXRvb2xiYXJzIGF0IHRoZSB0b3Agb2YgdGhlIHNjcmVlbiB0aGF0IGNhbiBoYXZlIHNjcm9sbFxuZWZmZWN0cy4gQnkgZGVmYXVsdCwgYW4gYXBwLWhlYWRlciBtb3ZlcyBhd2F5IGZyb20gdGhlIHZpZXdwb3J0IHdoZW4gc2Nyb2xsaW5nIGRvd24gYW5kXG5pZiB1c2luZyBgcmV2ZWFsc2AsIHRoZSBoZWFkZXIgc2xpZGVzIGJhY2sgd2hlbiBzY3JvbGxpbmcgYmFjayB1cC4gRm9yIGV4YW1wbGU6XG5cbmBgYGh0bWxcbjxhcHAtaGVhZGVyIHJldmVhbHM+XG4gIDxhcHAtdG9vbGJhcj5cbiAgICA8ZGl2IG1haW4tdGl0bGU+QXBwIG5hbWU8L2Rpdj5cbiAgPC9hcHAtdG9vbGJhcj5cbjwvYXBwLWhlYWRlcj5cbmBgYFxuXG5hcHAtaGVhZGVyIGNhbiBhbHNvIGNvbmRlbnNlIHdoZW4gc2Nyb2xsaW5nIGRvd24uIFRvIGFjaGlldmUgdGhpcyBiZWhhdmlvciwgdGhlIGhlYWRlclxubXVzdCBoYXZlIGEgbGFyZ2VyIGhlaWdodCB0aGFuIHRoZSBgc3RpY2t5YCBlbGVtZW50IGluIHRoZSBsaWdodCBET00uIEZvciBleGFtcGxlOlxuXG5gYGBodG1sXG48YXBwLWhlYWRlciBzdHlsZT1cImhlaWdodDogOTZweDtcIiBjb25kZW5zZXMgZml4ZWQ+XG4gIDxhcHAtdG9vbGJhciBzdHlsZT1cImhlaWdodDogNjRweDtcIj5cbiAgICA8ZGl2IG1haW4tdGl0bGU+QXBwIG5hbWU8L2Rpdj5cbiAgPC9hcHAtdG9vbGJhcj5cbjwvYXBwLWhlYWRlcj5cbmBgYFxuXG5JbiB0aGlzIGNhc2UgdGhlIGhlYWRlciBpcyBpbml0aWFsbHkgYDk2cHhgIHRhbGwsIGFuZCBpdCBzaHJpbmtzIHRvIGA2NHB4YCB3aGVuIHNjcm9sbGluZyBkb3duLlxuVGhhdCBpcyB3aGF0IGlzIG1lYW50IGJ5IFwiY29uZGVuc2luZ1wiLlxuXG4jIyMgU3RpY2t5IGVsZW1lbnRcblxuVGhlIGVsZW1lbnQgdGhhdCBpcyBwb3NpdGlvbmVkIGZpeGVkIHRvIHRvcCBvZiB0aGUgaGVhZGVyJ3MgYHNjcm9sbFRhcmdldGAgd2hlbiBhIHRocmVzaG9sZFxuaXMgcmVhY2hlZCwgc2ltaWxhciB0byBgcG9zaXRpb246IHN0aWNreWAgaW4gQ1NTLiBUaGlzIGVsZW1lbnQgKiptdXN0KiogYmUgYW4gaW1tZWRpYXRlXG5jaGlsZCBvZiBhcHAtaGVhZGVyLiBCeSBkZWZhdWx0LCB0aGUgYHN0aWNreWAgZWxlbWVudCBpcyB0aGUgZmlyc3QgYGFwcC10b29sYmFyIHRoYXRcbmlzIGFuIGltbWVkaWF0ZSBjaGlsZCBvZiBhcHAtaGVhZGVyLlxuXG5gYGBodG1sXG48YXBwLWhlYWRlciBjb25kZW5zZXM+XG4gIDxhcHAtdG9vbGJhcj4gU3RpY2t5IGVsZW1lbnQgPC9hcHAtdG9vbGJhcj5cbjwvYXBwLWhlYWRlcj5cbmBgYFxuXG4jIyMjIEN1c3RvbWl6aW5nIHRoZSBzdGlja3kgZWxlbWVudFxuXG5gYGBodG1sXG48YXBwLWhlYWRlciBjb25kZW5zZXM+XG4gIDxhcHAtdG9vbGJhcj48L2FwcC10b29sYmFyPlxuICA8YXBwLXRvb2xiYXIgc3RpY2t5PiBTdGlja3kgZWxlbWVudCA8L2FwcC10b29sYmFyPlxuPC9hcHAtaGVhZGVyPlxuYGBgXG5cbiMjIyBTY3JvbGwgdGFyZ2V0XG5cblRoZSBhcHAtaGVhZGVyJ3MgYHNjcm9sbFRhcmdldGAgcHJvcGVydHkgYWxsb3dzIHRvIGN1c3RvbWl6ZSB0aGUgc2Nyb2xsYWJsZSBlbGVtZW50IHRvIHdoaWNoXG50aGUgaGVhZGVyIHJlc3BvbmRzIHdoZW4gdGhlIHVzZXIgc2Nyb2xscy4gQnkgZGVmYXVsdCwgYXBwLWhlYWRlciB1c2VzIHRoZSBkb2N1bWVudCBhc1xudGhlIHNjcm9sbCB0YXJnZXQsIGJ1dCB5b3UgY2FuIGN1c3RvbWl6ZSB0aGlzIHByb3BlcnR5IGJ5IHNldHRpbmcgdGhlIGlkIG9mIHRoZSBlbGVtZW50LCBlLmcuXG5cbmBgYGh0bWxcbjxkaXYgaWQ9XCJzY3JvbGxpbmdSZWdpb25cIiBzdHlsZT1cIm92ZXJmbG93LXk6IGF1dG87XCI+XG4gIDxhcHAtaGVhZGVyIHNjcm9sbC10YXJnZXQ9XCJzY3JvbGxpbmdSZWdpb25cIj5cbiAgPC9hcHAtaGVhZGVyPlxuPC9kaXY+XG5gYGBcblxuSW4gdGhpcyBjYXNlLCB0aGUgYHNjcm9sbFRhcmdldGAgcHJvcGVydHkgcG9pbnRzIHRvIHRoZSBvdXRlciBkaXYgZWxlbWVudC4gQWx0ZXJuYXRpdmVseSxcbnlvdSBjYW4gc2V0IHRoaXMgcHJvcGVydHkgcHJvZ3JhbW1hdGljYWxseTpcblxuYGBganNcbmFwcEhlYWRlci5zY3JvbGxUYXJnZXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI3Njcm9sbGluZ1JlZ2lvblwiKTtcbmBgYFxuXG4jIyBCYWNrZ3JvdW5kc1xuYXBwLWhlYWRlciBoYXMgdHdvIGJhY2tncm91bmQgbGF5ZXJzIHRoYXQgY2FuIGJlIHVzZWQgZm9yIHN0eWxpbmcgd2hlbiB0aGUgaGVhZGVyIGlzIGNvbmRlbnNlZFxub3Igd2hlbiB0aGUgc2Nyb2xsYWJsZSBlbGVtZW50IGlzIHNjcm9sbGVkIHRvIHRoZSB0b3AuXG5cbiMjIFNjcm9sbCBlZmZlY3RzXG5cblNjcm9sbCBlZmZlY3RzIGFyZSBfb3B0aW9uYWxfIHZpc3VhbCBlZmZlY3RzIGFwcGxpZWQgaW4gYXBwLWhlYWRlciBiYXNlZCBvbiBzY3JvbGwgcG9zaXRpb24uIEZvciBleGFtcGxlLFxuVGhlIFtNYXRlcmlhbCBEZXNpZ24gc2Nyb2xsaW5nIHRlY2huaXF1ZXNdKGh0dHBzOi8vd3d3Lmdvb2dsZS5jb20vZGVzaWduL3NwZWMvcGF0dGVybnMvc2Nyb2xsaW5nLXRlY2huaXF1ZXMuaHRtbClcbnJlY29tbWVuZHMgZWZmZWN0cyB0aGF0IGNhbiBiZSBpbnN0YWxsZWQgdmlhIHRoZSBgZWZmZWN0c2AgcHJvcGVydHkuIGUuZy5cblxuYGBgaHRtbFxuPGFwcC1oZWFkZXIgZWZmZWN0cz1cIndhdGVyZmFsbFwiPlxuICA8YXBwLXRvb2xiYXI+QXBwIG5hbWU8L2FwcC10b29sYmFyPlxuPC9hcHAtaGVhZGVyPlxuYGBgXG5cbiMjIyMgSW1wb3J0aW5nIHRoZSBlZmZlY3RzXG5cblRvIHVzZSB0aGUgc2Nyb2xsIGVmZmVjdHMsIHlvdSBtdXN0IGV4cGxpY2l0bHkgaW1wb3J0IHRoZW0gaW4gYWRkaXRpb24gdG8gYGFwcC1oZWFkZXJgOlxuXG5gYGBodG1sXG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiL2Jvd2VyX2NvbXBvbmVudHMvYXBwLWxheW91dC9hcHAtc2Nyb2xsLWVmZmVjdHMvYXBwLXNjcm9sbC1lZmZlY3RzLmh0bWxcIj5cbmBgYFxuXG4jIyMjIExpc3Qgb2YgZWZmZWN0c1xuXG4qICoqYmxlbmQtYmFja2dyb3VuZCoqXG5GYWRlcyBpbi9vdXQgdHdvIGJhY2tncm91bmQgZWxlbWVudHMgYnkgYXBwbHlpbmcgQ1NTIG9wYWNpdHkgYmFzZWQgb24gc2Nyb2xsIHBvc2l0aW9uLlxuWW91IGNhbiB1c2UgdGhpcyBlZmZlY3QgdG8gc21vb3RobHkgY2hhbmdlIHRoZSBiYWNrZ3JvdW5kIGNvbG9yIG9yIGltYWdlIG9mIHRoZSBoZWFkZXIuXG5Gb3IgZXhhbXBsZSwgdXNpbmcgdGhlIG1peGluIGAtLWFwcC1oZWFkZXItYmFja2dyb3VuZC1yZWFyLWxheWVyYCBsZXRzIHlvdSBhc3NpZ24gYSBkaWZmZXJlbnRcbmJhY2tncm91bmQgd2hlbiB0aGUgaGVhZGVyIGlzIGNvbmRlbnNlZDpcblxuYGBgY3NzXG5hcHAtaGVhZGVyIHtcbiAgYmFja2dyb3VuZC1jb2xvcjogcmVkO1xuICAtLWFwcC1oZWFkZXItYmFja2dyb3VuZC1yZWFyLWxheWVyOiB7XG4gICAgLyogVGhlIGhlYWRlciBpcyBibHVlIHdoZW4gY29uZGVuc2VkICovXG4gICAgYmFja2dyb3VuZC1jb2xvcjogYmx1ZTtcbiAgfTtcbn1cbmBgYFxuXG4qICoqZmFkZS1iYWNrZ3JvdW5kKipcblVwb24gc2Nyb2xsaW5nIHBhc3QgYSB0aHJlc2hvbGQsIHRoaXMgZWZmZWN0IHdpbGwgdHJpZ2dlciBhbiBvcGFjaXR5IHRyYW5zaXRpb24gdG9cbmZhZGUgaW4vb3V0IHRoZSBiYWNrZ3JvdW5kcy4gQ29tcGFyZWQgdG8gdGhlIGBibGVuZC1iYWNrZ3JvdW5kYCBlZmZlY3QsXG50aGlzIGVmZmVjdCBkb2Vzbid0IGludGVycG9sYXRlIHRoZSBvcGFjaXR5IGJhc2VkIG9uIHNjcm9sbCBwb3NpdGlvbi5cblxuXG4qICoqcGFyYWxsYXgtYmFja2dyb3VuZCoqXG5BIHNpbXBsZSBwYXJhbGxheCBlZmZlY3QgdGhhdCB2ZXJ0aWNhbGx5IHRyYW5zbGF0ZXMgdGhlIGJhY2tncm91bmRzIGJhc2VkIG9uIGEgZnJhY3Rpb25cbm9mIHRoZSBzY3JvbGwgcG9zaXRpb24uIEZvciBleGFtcGxlOlxuXG5gYGBjc3NcbmFwcC1oZWFkZXIge1xuICAtLWFwcC1oZWFkZXItYmFja2dyb3VuZC1mcm9udC1sYXllcjoge1xuICAgIGJhY2tncm91bmQtaW1hZ2U6IHVybCguLi4pO1xuICB9O1xufVxuYGBgXG5gYGBodG1sXG48YXBwLWhlYWRlciBzdHlsZT1cImhlaWdodDogMzAwcHg7XCIgZWZmZWN0cz1cInBhcmFsbGF4LWJhY2tncm91bmRcIj5cbiAgPGFwcC10b29sYmFyPkFwcCBuYW1lPC9hcHAtdG9vbGJhcj5cbjwvYXBwLWhlYWRlcj5cbmBgYFxuXG5UaGUgZnJhY3Rpb24gZGV0ZXJtaW5lcyBob3cgZmFyIHRoZSBiYWNrZ3JvdW5kIG1vdmVzIHJlbGF0aXZlIHRvIHRoZSBzY3JvbGwgcG9zaXRpb24uXG5UaGlzIHZhbHVlIGNhbiBiZSBhc3NpZ25lZCB2aWEgdGhlIGBzY2FsYXJgIGNvbmZpZyB2YWx1ZSBhbmQgaXQgaXMgdHlwaWNhbGx5IGEgdmFsdWVcbmJldHdlZW4gMCBhbmQgMSBpbmNsdXNpdmUuIElmIGBzY2FsYXI9MGAsIHRoZSBiYWNrZ3JvdW5kIGRvZXNuJ3QgbW92ZSBhd2F5IGZyb20gdGhlIGhlYWRlci5cblxuKiAqKnJlc2l6ZS10aXRsZSoqXG5Qcm9ncmVzc2l2ZWx5IGludGVycG9sYXRlcyB0aGUgc2l6ZSBvZiB0aGUgdGl0bGUgZnJvbSB0aGUgZWxlbWVudCB3aXRoIHRoZSBgbWFpbi10aXRsZWAgYXR0cmlidXRlXG50byB0aGUgZWxlbWVudCB3aXRoIHRoZSBgY29uZGVuc2VkLXRpdGxlYCBhdHRyaWJ1dGUgYXMgdGhlIGhlYWRlciBjb25kZW5zZXMuIEZvciBleGFtcGxlOlxuXG5gYGBodG1sXG48YXBwLWhlYWRlciBjb25kZW5zZXMgcmV2ZWFscyBlZmZlY3RzPVwicmVzaXplLXRpdGxlXCI+XG4gIDxhcHAtdG9vbGJhcj5cbiAgICAgIDxoNCBjb25kZW5zZWQtdGl0bGU+QXBwIG5hbWU8L2g0PlxuICA8L2FwcC10b29sYmFyPlxuICA8YXBwLXRvb2xiYXI+XG4gICAgICA8aDEgbWFpbi10aXRsZT5BcHAgbmFtZTwvaDE+XG4gIDwvYXBwLXRvb2xiYXI+XG48L2FwcC1oZWFkZXI+XG5gYGBcblxuKiAqKnJlc2l6ZS1zbmFwcGVkLXRpdGxlKipcblVwb24gc2Nyb2xsaW5nIHBhc3QgYSB0aHJlc2hvbGQsIHRoaXMgZWZmZWN0IGZhZGVzIGluL291dCB0aGUgdGl0bGVzIHVzaW5nIG9wYWNpdHkgdHJhbnNpdGlvbnMuXG5TaW1pbGFybHkgdG8gYHJlc2l6ZS10aXRsZWAsIHRoZSBgbWFpbi10aXRsZWAgYW5kIGBjb25kZW5zZWQtdGl0bGVgIGVsZW1lbnRzIG11c3QgYmUgcGxhY2VkIGluIHRoZVxubGlnaHQgRE9NLlxuXG4qICoqd2F0ZXJmYWxsKipcblRvZ2dsZXMgdGhlIHNoYWRvdyBwcm9wZXJ0eSBpbiBhcHAtaGVhZGVyIHRvIGNyZWF0ZSBhIHNlbnNlIG9mIGRlcHRoIChhcyByZWNvbW1lbmRlZCBpbiB0aGVcbk1EIHNwZWMpIGJldHdlZW4gdGhlIGhlYWRlciBhbmQgdGhlIHVuZGVybmVhdGggY29udGVudC4gWW91IGNhbiBjaGFuZ2UgdGhlIHNoYWRvdyBieVxuY3VzdG9taXppbmcgdGhlIGAtLWFwcC1oZWFkZXItc2hhZG93YCBtaXhpbi4gRm9yIGV4YW1wbGU6XG5cbmBgYGNzc1xuYXBwLWhlYWRlciB7XG4gIC0tYXBwLWhlYWRlci1zaGFkb3c6IHtcbiAgICBib3gtc2hhZG93OiBpbnNldCAwcHggNXB4IDJweCAtM3B4IHJnYmEoMCwgMCwgMCwgMC4yKTtcbiAgfTtcbn1cbmBgYFxuXG5gYGBodG1sXG48YXBwLWhlYWRlciBjb25kZW5zZXMgcmV2ZWFscyBlZmZlY3RzPVwid2F0ZXJmYWxsXCI+XG4gIDxhcHAtdG9vbGJhcj5cbiAgICAgIDxoMSBtYWluLXRpdGxlPkFwcCBuYW1lPC9oMT5cbiAgPC9hcHAtdG9vbGJhcj5cbjwvYXBwLWhlYWRlcj5cbmBgYFxuXG4qICoqbWF0ZXJpYWwqKlxuSW5zdGFsbHMgdGhlIHdhdGVyZmFsbCwgcmVzaXplLXRpdGxlLCBibGVuZC1iYWNrZ3JvdW5kIGFuZCBwYXJhbGxheC1iYWNrZ3JvdW5kIGVmZmVjdHMuXG5cbiMjIyBDb250ZW50IGF0dHJpYnV0ZXNcblxuQXR0cmlidXRlIHwgRGVzY3JpcHRpb24gICAgICAgICB8IERlZmF1bHRcbi0tLS0tLS0tLS18LS0tLS0tLS0tLS0tLS0tLS0tLS0tfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmBzdGlja3lgIHwgRWxlbWVudCB0aGF0IHJlbWFpbnMgYXQgdGhlIHRvcCB3aGVuIHRoZSBoZWFkZXIgY29uZGVuc2VzLiB8IFRoZSBmaXJzdCBhcHAtdG9vbGJhciBpbiB0aGUgbGlnaHQgRE9NLlxuXG5cbiMjIFN0eWxpbmdcblxuTWl4aW4gfCBEZXNjcmlwdGlvbiB8IERlZmF1bHRcbi0tLS0tLXwtLS0tLS0tLS0tLS0tfC0tLS0tLS0tLS1cbmAtLWFwcC1oZWFkZXItYmFja2dyb3VuZC1mcm9udC1sYXllcmAgfCBBcHBsaWVzIHRvIHRoZSBmcm9udCBsYXllciBvZiB0aGUgYmFja2dyb3VuZC4gfCB7fVxuYC0tYXBwLWhlYWRlci1iYWNrZ3JvdW5kLXJlYXItbGF5ZXJgIHwgQXBwbGllcyB0byB0aGUgcmVhciBsYXllciBvZiB0aGUgYmFja2dyb3VuZC4gfCB7fVxuYC0tYXBwLWhlYWRlci1zaGFkb3dgIHwgQXBwbGllcyB0byB0aGUgc2hhZG93LiB8IHt9XG5cbkBncm91cCBBcHAgRWxlbWVudHNcbkBlbGVtZW50IGFwcC1oZWFkZXJcbkBkZW1vIGFwcC1oZWFkZXIvZGVtby9ibGVuZC1iYWNrZ3JvdW5kLTEuaHRtbCBCbGVuZCBCYWNrZ3JvdW5kIEltYWdlXG5AZGVtbyBhcHAtaGVhZGVyL2RlbW8vYmxlbmQtYmFja2dyb3VuZC0yLmh0bWwgQmxlbmQgMiBCYWNrZ3JvdW5kIEltYWdlc1xuQGRlbW8gYXBwLWhlYWRlci9kZW1vL2JsZW5kLWJhY2tncm91bmQtMy5odG1sIEJsZW5kIEJhY2tncm91bmQgQ29sb3JzXG5AZGVtbyBhcHAtaGVhZGVyL2RlbW8vY29udGFjdHMuaHRtbCBDb250YWN0cyBEZW1vXG5AZGVtbyBhcHAtaGVhZGVyL2RlbW8vZ2l2ZS5odG1sIFJlc2l6ZSBTbmFwcGVkIFRpdGxlIERlbW9cbkBkZW1vIGFwcC1oZWFkZXIvZGVtby9tdXNpYy5odG1sIFJldmVhbHMgRGVtb1xuQGRlbW8gYXBwLWhlYWRlci9kZW1vL25vLWVmZmVjdHMuaHRtbCBDb25kZW5zZXMgYW5kIFJldmVhbHMgRGVtb1xuQGRlbW8gYXBwLWhlYWRlci9kZW1vL25vdGVzLmh0bWwgRml4ZWQgd2l0aCBEeW5hbWljIFNoYWRvdyBEZW1vXG5AZGVtbyBhcHAtaGVhZGVyL2RlbW8vY3VzdG9tLXN0aWNreS1lbGVtZW50LTEuaHRtbCBDdXN0b20gU3RpY2t5IEVsZW1lbnQgRGVtbyAxXG5AZGVtbyBhcHAtaGVhZGVyL2RlbW8vY3VzdG9tLXN0aWNreS1lbGVtZW50LTIuaHRtbCBDdXN0b20gU3RpY2t5IEVsZW1lbnQgRGVtbyAyXG5cbi0tPlxuXG48ZG9tLW1vZHVsZSBpZD1cImFwcC1oZWFkZXJcIj5cbiAgPHRlbXBsYXRlPlxuICAgIDxzdHlsZT5cbiAgICAgIDpob3N0IHtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgICAgdHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb246IGxpbmVhcjtcbiAgICAgICAgdHJhbnNpdGlvbi1wcm9wZXJ0eTogLXdlYmtpdC10cmFuc2Zvcm07XG4gICAgICAgIHRyYW5zaXRpb24tcHJvcGVydHk6IHRyYW5zZm9ybTtcbiAgICAgIH1cblxuICAgICAgOmhvc3Q6OmJlZm9yZSB7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgcmlnaHQ6IDBweDtcbiAgICAgICAgYm90dG9tOiAtNXB4O1xuICAgICAgICBsZWZ0OiAwcHg7XG4gICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICBoZWlnaHQ6IDVweDtcbiAgICAgICAgY29udGVudDogXCJcIjtcbiAgICAgICAgdHJhbnNpdGlvbjogb3BhY2l0eSAwLjRzO1xuICAgICAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcbiAgICAgICAgb3BhY2l0eTogMDtcbiAgICAgICAgYm94LXNoYWRvdzogaW5zZXQgMHB4IDVweCA2cHggLTNweCByZ2JhKDAsIDAsIDAsIDAuNCk7XG4gICAgICAgIHdpbGwtY2hhbmdlOiBvcGFjaXR5O1xuICAgICAgICBAYXBwbHkgLS1hcHAtaGVhZGVyLXNoYWRvdztcbiAgICAgIH1cblxuICAgICAgOmhvc3QoW3NoYWRvd10pOjpiZWZvcmUge1xuICAgICAgICBvcGFjaXR5OiAxO1xuICAgICAgfVxuXG4gICAgICAjYmFja2dyb3VuZCB7XG4gICAgICAgIEBhcHBseSAtLWxheW91dC1maXQ7XG4gICAgICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgICB9XG5cbiAgICAgICNiYWNrZ3JvdW5kRnJvbnRMYXllcixcbiAgICAgICNiYWNrZ3JvdW5kUmVhckxheWVyIHtcbiAgICAgICAgQGFwcGx5IC0tbGF5b3V0LWZpdDtcbiAgICAgICAgaGVpZ2h0OiAxMDAlO1xuICAgICAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcbiAgICAgICAgYmFja2dyb3VuZC1zaXplOiBjb3ZlcjtcbiAgICAgIH1cblxuICAgICAgI2JhY2tncm91bmRGcm9udExheWVyIHtcbiAgICAgICAgQGFwcGx5IC0tYXBwLWhlYWRlci1iYWNrZ3JvdW5kLWZyb250LWxheWVyO1xuICAgICAgfVxuXG4gICAgICAjYmFja2dyb3VuZFJlYXJMYXllciB7XG4gICAgICAgIG9wYWNpdHk6IDA7XG4gICAgICAgIEBhcHBseSAtLWFwcC1oZWFkZXItYmFja2dyb3VuZC1yZWFyLWxheWVyO1xuICAgICAgfVxuXG4gICAgICAjY29udGVudENvbnRhaW5lciB7XG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgIGhlaWdodDogMTAwJTtcbiAgICAgIH1cblxuICAgICAgOmhvc3QoW2Rpc2FibGVkXSksXG4gICAgICA6aG9zdChbZGlzYWJsZWRdKTo6YWZ0ZXIsXG4gICAgICA6aG9zdChbZGlzYWJsZWRdKSAjYmFja2dyb3VuZEZyb250TGF5ZXIsXG4gICAgICA6aG9zdChbZGlzYWJsZWRdKSAjYmFja2dyb3VuZFJlYXJMYXllcixcbiAgICAgIC8qIFNpbGVudCBzY3JvbGxpbmcgc2hvdWxkIG5vdCBydW4gQ1NTIHRyYW5zaXRpb25zICovXG4gICAgICA6aG9zdChbc2lsZW50LXNjcm9sbF0pLFxuICAgICAgOmhvc3QoW3NpbGVudC1zY3JvbGxdKTo6YWZ0ZXIsXG4gICAgICA6aG9zdChbc2lsZW50LXNjcm9sbF0pICNiYWNrZ3JvdW5kRnJvbnRMYXllcixcbiAgICAgIDpob3N0KFtzaWxlbnQtc2Nyb2xsXSkgI2JhY2tncm91bmRSZWFyTGF5ZXIge1xuICAgICAgICB0cmFuc2l0aW9uOiBub25lICFpbXBvcnRhbnQ7XG4gICAgICB9XG5cbiAgICAgIDpob3N0KFtkaXNhYmxlZF0pIDo6c2xvdHRlZChhcHAtdG9vbGJhcjpmaXJzdC1vZi10eXBlKSxcbiAgICAgIDpob3N0KFtkaXNhYmxlZF0pIDo6c2xvdHRlZChbc3RpY2t5XSksXG4gICAgICAvKiBTaWxlbnQgc2Nyb2xsaW5nIHNob3VsZCBub3QgcnVuIENTUyB0cmFuc2l0aW9ucyAqL1xuICAgICAgOmhvc3QoW3NpbGVudC1zY3JvbGxdKSA6OnNsb3R0ZWQoYXBwLXRvb2xiYXI6Zmlyc3Qtb2YtdHlwZSksXG4gICAgICA6aG9zdChbc2lsZW50LXNjcm9sbF0pIDo6c2xvdHRlZChbc3RpY2t5XSkge1xuICAgICAgICB0cmFuc2l0aW9uOiBub25lICFpbXBvcnRhbnQ7XG4gICAgICB9XG5cbiAgICA8L3N0eWxlPlxuICAgIDxkaXYgaWQ9XCJjb250ZW50Q29udGFpbmVyXCI+XG4gICAgICA8c2xvdCBpZD1cInNsb3RcIj48L3Nsb3Q+XG4gICAgPC9kaXY+XG4gIDwvdGVtcGxhdGU+XG5cbiAgPHNjcmlwdD5cbiAgICBQb2x5bWVyKHtcbiAgICAgIGlzOiAnYXBwLWhlYWRlcicsXG5cbiAgICAgIGJlaGF2aW9yczogW1xuICAgICAgICBQb2x5bWVyLkFwcFNjcm9sbEVmZmVjdHNCZWhhdmlvcixcbiAgICAgICAgUG9seW1lci5BcHBMYXlvdXRCZWhhdmlvclxuICAgICAgXSxcblxuICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgdHJ1ZSwgdGhlIGhlYWRlciB3aWxsIGF1dG9tYXRpY2FsbHkgY29sbGFwc2Ugd2hlbiBzY3JvbGxpbmcgZG93bi5cbiAgICAgICAgICogVGhhdCBpcywgdGhlIGBzdGlja3lgIGVsZW1lbnQgcmVtYWlucyB2aXNpYmxlIHdoZW4gdGhlIGhlYWRlciBpcyBmdWxseSBjb25kZW5zZWRcbiAgICAgICAgICogd2hlcmVhcyB0aGUgcmVzdCBvZiB0aGUgZWxlbWVudHMgd2lsbCBjb2xsYXBzZSBiZWxvdyBgc3RpY2t5YCBlbGVtZW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBCeSBkZWZhdWx0LCB0aGUgYHN0aWNreWAgZWxlbWVudCBpcyB0aGUgZmlyc3QgdG9vbGJhciBpbiB0aGUgbGlnaHQgRE9NOlxuICAgICAgICAgKlxuICAgICAgICAgKmBgYGh0bWxcbiAgICAgICAgICogPGFwcC1oZWFkZXIgY29uZGVuc2VzPlxuICAgICAgICAgKiAgIDxhcHAtdG9vbGJhcj5UaGlzIHRvb2xiYXIgcmVtYWlucyBvbiB0b3A8L2FwcC10b29sYmFyPlxuICAgICAgICAgKiAgIDxhcHAtdG9vbGJhcj48L2FwcC10b29sYmFyPlxuICAgICAgICAgKiAgIDxhcHAtdG9vbGJhcj48L2FwcC10b29sYmFyPlxuICAgICAgICAgKiA8L2FwcC1oZWFkZXI+XG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKlxuICAgICAgICAgKiBBZGRpdGlvbmFsbHksIHlvdSBjYW4gc3BlY2lmeSB3aGljaCB0b29sYmFyIG9yIGVsZW1lbnQgcmVtYWlucyB2aXNpYmxlIGluIGNvbmRlbnNlZCBtb2RlXG4gICAgICAgICAqIGJ5IGFkZGluZyB0aGUgYHN0aWNreWAgYXR0cmlidXRlIHRvIHRoYXQgZWxlbWVudC4gRm9yIGV4YW1wbGU6IGlmIHdlIHdhbnQgdGhlIGxhc3RcbiAgICAgICAgICogdG9vbGJhciB0byByZW1haW4gdmlzaWJsZSwgd2UgY2FuIGFkZCB0aGUgYHN0aWNreWAgYXR0cmlidXRlIHRvIGl0LlxuICAgICAgICAgKlxuICAgICAgICAgKmBgYGh0bWxcbiAgICAgICAgICogPGFwcC1oZWFkZXIgY29uZGVuc2VzPlxuICAgICAgICAgKiAgIDxhcHAtdG9vbGJhcj48L2FwcC10b29sYmFyPlxuICAgICAgICAgKiAgIDxhcHAtdG9vbGJhcj48L2FwcC10b29sYmFyPlxuICAgICAgICAgKiAgIDxhcHAtdG9vbGJhciBzdGlja3k+VGhpcyB0b29sYmFyIHJlbWFpbnMgb24gdG9wPC9hcHAtdG9vbGJhcj5cbiAgICAgICAgICogPC9hcHAtaGVhZGVyPlxuICAgICAgICAgKiBgYGBcbiAgICAgICAgICpcbiAgICAgICAgICogTm90ZSB0aGUgYHN0aWNreWAgZWxlbWVudCBtdXN0IGJlIGEgZGlyZWN0IGNoaWxkIG9mIGBhcHAtaGVhZGVyYC5cbiAgICAgICAgICovXG4gICAgICAgIGNvbmRlbnNlczoge1xuICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1hbnRhaW5zIHRoZSBoZWFkZXIgZml4ZWQgYXQgdGhlIHRvcCBzbyBpdCBuZXZlciBtb3ZlcyBhd2F5LlxuICAgICAgICAgKi9cbiAgICAgICAgZml4ZWQ6IHtcbiAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTbGlkZXMgYmFjayB0aGUgaGVhZGVyIHdoZW4gc2Nyb2xsaW5nIGJhY2sgdXAuXG4gICAgICAgICAqL1xuICAgICAgICByZXZlYWxzOiB7XG4gICAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGlzcGxheXMgYSBzaGFkb3cgYmVsb3cgdGhlIGhlYWRlci5cbiAgICAgICAgICovXG4gICAgICAgIHNoYWRvdzoge1xuICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgICAgcmVmbGVjdFRvQXR0cmlidXRlOiB0cnVlLFxuICAgICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBvYnNlcnZlcnM6IFtcbiAgICAgICAgJ19jb25maWdDaGFuZ2VkKGlzQXR0YWNoZWQsIGNvbmRlbnNlcywgZml4ZWQpJ1xuICAgICAgXSxcblxuICAgICAgLyoqXG4gICAgICAgKiBBIGNhY2hlZCBvZmZzZXRIZWlnaHQgb2YgdGhlIGN1cnJlbnQgZWxlbWVudC5cbiAgICAgICAqXG4gICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICovXG4gICAgICBfaGVpZ2h0OiAwLFxuXG4gICAgICAvKipcbiAgICAgICAqIFRoZSBkaXN0YW5jZSBpbiBwaXhlbHMgdGhlIGhlYWRlciB3aWxsIGJlIHRyYW5zbGF0ZWQgdG8gd2hlbiBzY3JvbGxpbmcuXG4gICAgICAgKlxuICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAqL1xuICAgICAgX2RIZWlnaHQ6IDAsXG5cbiAgICAgIC8qKlxuICAgICAgICogVGhlIG9mZnNldFRvcCBvZiBgX3N0aWNreUVsYFxuICAgICAgICpcbiAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgKi9cbiAgICAgIF9zdGlja3lFbFRvcDogMCxcblxuICAgICAgLyoqXG4gICAgICAgKiBBIHJlZmVyZW5jZSB0byB0aGUgZWxlbWVudCB0aGF0IHJlbWFpbnMgdmlzaWJsZSB3aGVuIHRoZSBoZWFkZXIgY29uZGVuc2VzLlxuICAgICAgICpcbiAgICAgICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICAgICAqL1xuICAgICAgX3N0aWNreUVsUmVmOiBudWxsLFxuXG4gICAgICAvKipcbiAgICAgICAqIFRoZSBoZWFkZXIncyB0b3AgdmFsdWUgdXNlZCBmb3IgdGhlIGB0cmFuc2Zvcm1ZYFxuICAgICAgICpcbiAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgKi9cbiAgICAgIF90b3A6IDAsXG5cbiAgICAgIC8qKlxuICAgICAgICogVGhlIGN1cnJlbnQgc2Nyb2xsIHByb2dyZXNzLlxuICAgICAgICpcbiAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgKi9cbiAgICAgIF9wcm9ncmVzczogMCxcblxuICAgICAgX3dhc1Njcm9sbGluZ0Rvd246IGZhbHNlLFxuICAgICAgX2luaXRTY3JvbGxUb3A6IDAsXG4gICAgICBfaW5pdFRpbWVzdGFtcDogMCxcbiAgICAgIF9sYXN0VGltZXN0YW1wOiAwLFxuICAgICAgX2xhc3RTY3JvbGxUb3A6IDAsXG5cbiAgICAgIC8qKlxuICAgICAgICogVGhlIGRpc3RhbmNlIHRoZSBoZWFkZXIgaXMgYWxsb3dlZCB0byBtb3ZlIGF3YXkuXG4gICAgICAgKlxuICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAqL1xuICAgICAgZ2V0IF9tYXhIZWFkZXJUb3AoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpeGVkID8gdGhpcy5fZEhlaWdodCA6IHRoaXMuX2hlaWdodCArIDU7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFJldHVybnMgYSByZWZlcmVuY2UgdG8gdGhlIHN0aWNreSBlbGVtZW50LlxuICAgICAgICpcbiAgICAgICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fT9cbiAgICAgICAqL1xuICAgICAgZ2V0IF9zdGlja3lFbCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3N0aWNreUVsUmVmKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3N0aWNreUVsUmVmO1xuICAgICAgICB9XG4gICAgICAgIHZhciBub2RlcyA9IFBvbHltZXIuZG9tKHRoaXMuJC5zbG90KS5nZXREaXN0cmlidXRlZE5vZGVzKCk7XG4gICAgICAgIC8vIEdldCB0aGUgZWxlbWVudCB3aXRoIHRoZSBzdGlja3kgYXR0cmlidXRlIG9uIGl0IG9yIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBsaWdodCBET00uXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBub2RlOyBub2RlID0gbm9kZXNbaV07IGkrKykge1xuICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgaWYgKG5vZGUuaGFzQXR0cmlidXRlKCdzdGlja3knKSkge1xuICAgICAgICAgICAgICB0aGlzLl9zdGlja3lFbFJlZiA9IG5vZGU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghdGhpcy5fc3RpY2t5RWxSZWYpIHtcbiAgICAgICAgICAgICAgdGhpcy5fc3RpY2t5RWxSZWYgPSBub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fc3RpY2t5RWxSZWY7XG4gICAgICB9LFxuXG4gICAgICBfY29uZmlnQ2hhbmdlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMucmVzZXRMYXlvdXQoKTtcbiAgICAgICAgdGhpcy5fbm90aWZ5TGF5b3V0Q2hhbmdlZCgpO1xuICAgICAgfSxcblxuICAgICAgX3VwZGF0ZUxheW91dFN0YXRlczogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLm9mZnNldFdpZHRoID09PSAwICYmIHRoaXMub2Zmc2V0SGVpZ2h0ID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzY3JvbGxUb3AgPSB0aGlzLl9jbGFtcGVkU2Nyb2xsVG9wO1xuICAgICAgICB2YXIgZmlyc3RTZXR1cCA9IHRoaXMuX2hlaWdodCA9PT0gMCB8fCBzY3JvbGxUb3AgPT09IDA7XG4gICAgICAgIHZhciBjdXJyZW50RGlzYWJsZWQgPSB0aGlzLmRpc2FibGVkO1xuICAgICAgICB0aGlzLl9oZWlnaHQgPSB0aGlzLm9mZnNldEhlaWdodDtcbiAgICAgICAgdGhpcy5fc3RpY2t5RWxSZWYgPSBudWxsO1xuICAgICAgICB0aGlzLmRpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgLy8gcHJlcGFyZSBmb3IgbWVhc3VyZW1lbnRcbiAgICAgICAgaWYgICghZmlyc3RTZXR1cCkge1xuICAgICAgICAgIHRoaXMuX3VwZGF0ZVNjcm9sbFN0YXRlKDAsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9tYXlNb3ZlKCkpIHtcbiAgICAgICAgICB0aGlzLl9kSGVpZ2h0ID0gdGhpcy5fc3RpY2t5RWwgPyB0aGlzLl9oZWlnaHQgLSB0aGlzLl9zdGlja3lFbC5vZmZzZXRIZWlnaHQgOiAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX2RIZWlnaHQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3N0aWNreUVsVG9wID0gdGhpcy5fc3RpY2t5RWwgPyB0aGlzLl9zdGlja3lFbC5vZmZzZXRUb3AgOiAwO1xuICAgICAgICB0aGlzLl9zZXRVcEVmZmVjdCgpO1xuICAgICAgICBpZiAoZmlyc3RTZXR1cCkge1xuICAgICAgICAgIHRoaXMuX3VwZGF0ZVNjcm9sbFN0YXRlKHNjcm9sbFRvcCwgdHJ1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fdXBkYXRlU2Nyb2xsU3RhdGUodGhpcy5fbGFzdFNjcm9sbFRvcCwgdHJ1ZSk7XG4gICAgICAgICAgdGhpcy5fbGF5b3V0SWZEaXJ0eSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlc3RvcmUgbm8gdHJhbnNpdGlvblxuICAgICAgICB0aGlzLmRpc2FibGVkID0gY3VycmVudERpc2FibGVkO1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBVcGRhdGVzIHRoZSBzY3JvbGwgc3RhdGUuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHNjcm9sbFRvcFxuICAgICAgICogQHBhcmFtIHtib29sZWFuPX0gZm9yY2VVcGRhdGUgKGRlZmF1bHQ6IGZhbHNlKVxuICAgICAgICovXG4gICAgICBfdXBkYXRlU2Nyb2xsU3RhdGU6IGZ1bmN0aW9uKHNjcm9sbFRvcCwgZm9yY2VVcGRhdGUpIHtcbiAgICAgICAgaWYgKHRoaXMuX2hlaWdodCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJvZ3Jlc3MgPSAwO1xuICAgICAgICB2YXIgdG9wID0gMDtcbiAgICAgICAgdmFyIGxhc3RUb3AgPSB0aGlzLl90b3A7XG4gICAgICAgIHZhciBsYXN0U2Nyb2xsVG9wID0gdGhpcy5fbGFzdFNjcm9sbFRvcDtcbiAgICAgICAgdmFyIG1heEhlYWRlclRvcCA9IHRoaXMuX21heEhlYWRlclRvcDtcbiAgICAgICAgdmFyIGRTY3JvbGxUb3AgPSBzY3JvbGxUb3AgLSB0aGlzLl9sYXN0U2Nyb2xsVG9wO1xuICAgICAgICB2YXIgYWJzRFNjcm9sbFRvcCA9IE1hdGguYWJzKGRTY3JvbGxUb3ApO1xuICAgICAgICB2YXIgaXNTY3JvbGxpbmdEb3duID0gc2Nyb2xsVG9wID4gdGhpcy5fbGFzdFNjcm9sbFRvcDtcbiAgICAgICAgdmFyIG5vdyA9IHBlcmZvcm1hbmNlLm5vdygpO1xuXG4gICAgICAgIGlmICh0aGlzLl9tYXlNb3ZlKCkpIHtcbiAgICAgICAgICB0b3AgPSB0aGlzLl9jbGFtcCh0aGlzLnJldmVhbHMgPyBsYXN0VG9wICsgZFNjcm9sbFRvcCA6IHNjcm9sbFRvcCwgMCwgbWF4SGVhZGVyVG9wKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2Nyb2xsVG9wID49IHRoaXMuX2RIZWlnaHQpIHtcbiAgICAgICAgICB0b3AgPSB0aGlzLmNvbmRlbnNlcyAmJiAhdGhpcy5maXhlZCA/IE1hdGgubWF4KHRoaXMuX2RIZWlnaHQsIHRvcCkgOiB0b3A7XG4gICAgICAgICAgdGhpcy5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPSAnMG1zJztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5yZXZlYWxzICYmICF0aGlzLmRpc2FibGVkICYmIGFic0RTY3JvbGxUb3AgPCAxMDApIHtcbiAgICAgICAgICAvLyBzZXQgdGhlIGluaXRpYWwgc2Nyb2xsIHBvc2l0aW9uXG4gICAgICAgICAgaWYgKG5vdyAtIHRoaXMuX2luaXRUaW1lc3RhbXAgPiAzMDAgfHwgdGhpcy5fd2FzU2Nyb2xsaW5nRG93biAhPT0gaXNTY3JvbGxpbmdEb3duKSB7XG4gICAgICAgICAgICB0aGlzLl9pbml0U2Nyb2xsVG9wID0gc2Nyb2xsVG9wO1xuICAgICAgICAgICAgdGhpcy5faW5pdFRpbWVzdGFtcCA9IG5vdztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNjcm9sbFRvcCA+PSBtYXhIZWFkZXJUb3ApIHtcbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIHRoZSBoZWFkZXIgaXMgYWxsb3dlZCB0byBzbmFwXG4gICAgICAgICAgICBpZiAoTWF0aC5hYnModGhpcy5faW5pdFNjcm9sbFRvcCAtIHNjcm9sbFRvcCkgPiAzMCB8fCBhYnNEU2Nyb2xsVG9wID4gMTApIHtcbiAgICAgICAgICAgICAgaWYgKGlzU2Nyb2xsaW5nRG93biAmJiBzY3JvbGxUb3AgPj0gbWF4SGVhZGVyVG9wKSB7XG4gICAgICAgICAgICAgICAgdG9wID0gbWF4SGVhZGVyVG9wO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFpc1Njcm9sbGluZ0Rvd24gJiYgc2Nyb2xsVG9wID49IHRoaXMuX2RIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICB0b3AgPSB0aGlzLmNvbmRlbnNlcyAmJiAhdGhpcy5maXhlZCA/IHRoaXMuX2RIZWlnaHQgOiAwO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhciBzY3JvbGxWZWxvY2l0eSA9IGRTY3JvbGxUb3AgLyAobm93IC0gdGhpcy5fbGFzdFRpbWVzdGFtcCk7XG4gICAgICAgICAgICAgIHRoaXMuc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID0gdGhpcy5fY2xhbXAoKHRvcCAtIGxhc3RUb3ApIC8gc2Nyb2xsVmVsb2NpdHksIDAsIDMwMCkgKyAnbXMnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdG9wID0gdGhpcy5fdG9wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fZEhlaWdodCA9PT0gMCkge1xuICAgICAgICAgIHByb2dyZXNzID0gc2Nyb2xsVG9wID4gMCA/IDEgOiAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByb2dyZXNzID0gdG9wIC8gdGhpcy5fZEhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWZvcmNlVXBkYXRlKSB7XG4gICAgICAgICAgdGhpcy5fbGFzdFNjcm9sbFRvcCA9IHNjcm9sbFRvcDtcbiAgICAgICAgICB0aGlzLl90b3AgPSB0b3A7XG4gICAgICAgICAgdGhpcy5fd2FzU2Nyb2xsaW5nRG93biA9IGlzU2Nyb2xsaW5nRG93bjtcbiAgICAgICAgICB0aGlzLl9sYXN0VGltZXN0YW1wID0gbm93O1xuICAgICAgICB9XG4gICAgICAgIGlmIChmb3JjZVVwZGF0ZSB8fCBwcm9ncmVzcyAhPT0gdGhpcy5fcHJvZ3Jlc3MgfHwgbGFzdFRvcCAhPT0gdG9wIHx8IHNjcm9sbFRvcCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMuX3Byb2dyZXNzID0gcHJvZ3Jlc3M7XG4gICAgICAgICAgdGhpcy5fcnVuRWZmZWN0cyhwcm9ncmVzcywgdG9wKTtcbiAgICAgICAgICB0aGlzLl90cmFuc2Zvcm1IZWFkZXIodG9wKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGN1cnJlbnQgaGVhZGVyIGlzIGFsbG93ZWQgdG8gbW92ZSBhcyB0aGUgdXNlciBzY3JvbGxzLlxuICAgICAgICpcbiAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICAgKi9cbiAgICAgIF9tYXlNb3ZlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZGVuc2VzIHx8ICF0aGlzLmZpeGVkO1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGN1cnJlbnQgaGVhZGVyIHdpbGwgY29uZGVuc2UgYmFzZWQgb24gdGhlIHNpemUgb2YgdGhlIGhlYWRlclxuICAgICAgICogYW5kIHRoZSBgY29uc2Vuc2VzYCBwcm9wZXJ0eS5cbiAgICAgICAqXG4gICAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAgICovXG4gICAgICB3aWxsQ29uZGVuc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZEhlaWdodCA+IDAgJiYgdGhpcy5jb25kZW5zZXM7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgY3VycmVudCBlbGVtZW50IGlzIG9uIHRoZSBzY3JlZW4uXG4gICAgICAgKiBUaGF0IGlzLCB2aXNpYmxlIGluIHRoZSBjdXJyZW50IHZpZXdwb3J0LlxuICAgICAgICpcbiAgICAgICAqIEBtZXRob2QgaXNPblNjcmVlblxuICAgICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgICAqL1xuICAgICAgaXNPblNjcmVlbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oZWlnaHQgIT09IDAgJiYgdGhpcy5fdG9wIDwgdGhpcy5faGVpZ2h0O1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlcmUncyBjb250ZW50IGJlbG93IHRoZSBjdXJyZW50IGVsZW1lbnQuXG4gICAgICAgKlxuICAgICAgICogQG1ldGhvZCBpc0NvbnRlbnRCZWxvd1xuICAgICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgICAqL1xuICAgICAgaXNDb250ZW50QmVsb3c6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdG9wID09PSAwID8gdGhpcy5fY2xhbXBlZFNjcm9sbFRvcCA+IDAgOlxuICAgICAgICAgICAgdGhpcy5fY2xhbXBlZFNjcm9sbFRvcCAtIHRoaXMuX21heEhlYWRlclRvcCA+PSAwO1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBUcmFuc2Zvcm1zIHRoZSBoZWFkZXIuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgICAqL1xuICAgICAgX3RyYW5zZm9ybUhlYWRlcjogZnVuY3Rpb24oeSkge1xuICAgICAgICB0aGlzLnRyYW5zbGF0ZTNkKDAsICgteSkgKyAncHgnLCAwKTtcbiAgICAgICAgaWYgKHRoaXMuX3N0aWNreUVsKSB7XG4gICAgICAgICAgdGhpcy50cmFuc2xhdGUzZCgwLCB0aGlzLmNvbmRlbnNlcyAmJiB5ID49IHRoaXMuX3N0aWNreUVsVG9wID9cbiAgICAgICAgICAgICAgKE1hdGgubWluKHksIHRoaXMuX2RIZWlnaHQpIC0gdGhpcy5fc3RpY2t5RWxUb3ApICsgJ3B4JyA6IDAsICAwLCB0aGlzLl9zdGlja3lFbCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIF9jbGFtcDogZnVuY3Rpb24odiwgbWluLCBtYXgpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubWluKG1heCwgTWF0aC5tYXgobWluLCB2KSk7XG4gICAgICB9LFxuXG4gICAgICBfZW5zdXJlQmdDb250YWluZXJzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9iZ0NvbnRhaW5lcikge1xuICAgICAgICAgIHRoaXMuX2JnQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgdGhpcy5fYmdDb250YWluZXIuaWQgPSAnYmFja2dyb3VuZCc7XG4gICAgICAgICAgdGhpcy5fYmdSZWFyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgdGhpcy5fYmdSZWFyLmlkID0gJ2JhY2tncm91bmRSZWFyTGF5ZXInO1xuICAgICAgICAgIHRoaXMuX2JnQ29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuX2JnUmVhcik7XG4gICAgICAgICAgdGhpcy5fYmdGcm9udCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgIHRoaXMuX2JnRnJvbnQuaWQgPSAnYmFja2dyb3VuZEZyb250TGF5ZXInO1xuICAgICAgICAgIHRoaXMuX2JnQ29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuX2JnRnJvbnQpO1xuICAgICAgICAgIFBvbHltZXIuZG9tKHRoaXMucm9vdCkuaW5zZXJ0QmVmb3JlKHRoaXMuX2JnQ29udGFpbmVyLCB0aGlzLiQuY29udGVudENvbnRhaW5lcik7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIF9nZXRET01SZWY6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgIHN3aXRjaCAoaWQpIHtcbiAgICAgICAgICBjYXNlICdiYWNrZ3JvdW5kRnJvbnRMYXllcic6XG4gICAgICAgICAgICB0aGlzLl9lbnN1cmVCZ0NvbnRhaW5lcnMoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9iZ0Zyb250O1xuICAgICAgICAgIGNhc2UgJ2JhY2tncm91bmRSZWFyTGF5ZXInOlxuICAgICAgICAgICAgdGhpcy5fZW5zdXJlQmdDb250YWluZXJzKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYmdSZWFyO1xuICAgICAgICAgIGNhc2UgJ2JhY2tncm91bmQnOlxuICAgICAgICAgICAgdGhpcy5fZW5zdXJlQmdDb250YWluZXJzKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYmdDb250YWluZXI7XG4gICAgICAgICAgY2FzZSAnbWFpblRpdGxlJzpcbiAgICAgICAgICAgIHJldHVybiBQb2x5bWVyLmRvbSh0aGlzKS5xdWVyeVNlbGVjdG9yKCdbbWFpbi10aXRsZV0nKTtcbiAgICAgICAgICBjYXNlICdjb25kZW5zZWRUaXRsZSc6XG4gICAgICAgICAgICByZXR1cm4gUG9seW1lci5kb20odGhpcykucXVlcnlTZWxlY3RvcignW2NvbmRlbnNlZC10aXRsZV0nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogUmV0dXJucyBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgcHJvZ3Jlc3MgdmFsdWUgb2YgdGhlIHNjcm9sbCBlZmZlY3RzXG4gICAgICAgKiBhbmQgdGhlIHRvcCBwb3NpdGlvbiBvZiB0aGUgaGVhZGVyLlxuICAgICAgICpcbiAgICAgICAqIEBtZXRob2QgZ2V0U2Nyb2xsU3RhdGVcbiAgICAgICAqIEByZXR1cm4ge09iamVjdH1cbiAgICAgICAqL1xuICAgICAgZ2V0U2Nyb2xsU3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4geyBwcm9ncmVzczogdGhpcy5fcHJvZ3Jlc3MsIHRvcDogdGhpcy5fdG9wIH07XG4gICAgICB9XG4gICAgfSk7XG4gIDwvc2NyaXB0PlxuPC9kb20tbW9kdWxlPlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9hcHAtbGF5b3V0L2FwcC1oZWFkZXIvYXBwLWhlYWRlci5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNiBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuXG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vLi4vcG9seW1lci9wb2x5bWVyLmh0bWxcIj5cblxuPHNjcmlwdD5cbiAgUG9seW1lci5BcHBMYXlvdXQgPSBQb2x5bWVyLkFwcExheW91dCB8fCB7fTtcblxuICBQb2x5bWVyLkFwcExheW91dC5fc2Nyb2xsRWZmZWN0cyA9IFBvbHltZXIuQXBwTGF5b3V0Ll9zY3JvbGxFZmZlY3RzIHx8IHt9O1xuXG4gIFBvbHltZXIuQXBwTGF5b3V0LnNjcm9sbFRpbWluZ0Z1bmN0aW9uID0gZnVuY3Rpb24gZWFzZU91dFF1YWQodCwgYiwgYywgZCkge1xuICAgIHQgLz0gZDtcbiAgICByZXR1cm4gLWMgKiB0Kih0LTIpICsgYjtcbiAgfTtcblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGEgc2Nyb2xsIGVmZmVjdCB0byBiZSB1c2VkIGluIGVsZW1lbnRzIHRoYXQgaW1wbGVtZW50IHRoZVxuICAgKiBgUG9seW1lci5BcHBTY3JvbGxFZmZlY3RzQmVoYXZpb3JgIGJlaGF2aW9yLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZWZmZWN0TmFtZSBUaGUgZWZmZWN0IG5hbWUuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlZmZlY3REZWYgVGhlIGVmZmVjdCBkZWZpbml0aW9uLlxuICAgKi9cbiAgUG9seW1lci5BcHBMYXlvdXQucmVnaXN0ZXJFZmZlY3QgPSBmdW5jdGlvbiByZWdpc3RlckVmZmVjdChlZmZlY3ROYW1lLCBlZmZlY3REZWYpIHtcbiAgICBpZiAoUG9seW1lci5BcHBMYXlvdXQuX3Njcm9sbEVmZmVjdHNbZWZmZWN0TmFtZV0gIT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdlZmZlY3QgYCcrIGVmZmVjdE5hbWUgKyAnYCBpcyBhbHJlYWR5IHJlZ2lzdGVyZWQuJyk7XG4gICAgfVxuICAgIFBvbHltZXIuQXBwTGF5b3V0Ll9zY3JvbGxFZmZlY3RzW2VmZmVjdE5hbWVdID0gZWZmZWN0RGVmO1xuICB9O1xuXG5cbiAgUG9seW1lci5BcHBMYXlvdXQucXVlcnlBbGxSb290ID0gZnVuY3Rpb24oc2VsZWN0b3IsIHJvb3QpIHtcbiAgICB2YXIgcXVldWUgPSBbcm9vdF07XG4gICAgdmFyIG1hdGNoZXMgPSBbXTtcblxuICAgIHdoaWxlIChxdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICB2YXIgbm9kZSA9IHF1ZXVlLnNoaWZ0KCk7XG4gICAgICBtYXRjaGVzLnB1c2guYXBwbHkobWF0Y2hlcywgbm9kZS5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKSk7XG4gICAgICBmb3IgKGkgPSAwOyBub2RlLmNoaWxkcmVuW2ldOyBpKyspIHtcbiAgICAgICAgaWYgKG5vZGUuY2hpbGRyZW5baV0uc2hhZG93Um9vdCkge1xuICAgICAgICAgIHF1ZXVlLnB1c2gobm9kZS5jaGlsZHJlbltpXS5zaGFkb3dSb290KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWF0Y2hlcztcbiAgfTtcblxuICAvKipcbiAgICogU2Nyb2xscyB0byBhIHBhcnRpY3VsYXIgc2V0IG9mIGNvb3JkaW5hdGVzIGluIGEgc2Nyb2xsIHRhcmdldC5cbiAgICogSWYgdGhlIHNjcm9sbCB0YXJnZXQgaXMgbm90IGRlZmluZWQsIHRoZW4gaXQgd291bGQgdXNlIHRoZSBtYWluIGRvY3VtZW50IGFzIHRoZSB0YXJnZXQuXG4gICAqXG4gICAqIFRvIHNjcm9sbCBpbiBhIHNtb290aCBmYXNoaW9uLCB5b3UgY2FuIHNldCB0aGUgb3B0aW9uIGBiZWhhdmlvcjogJ3Ntb290aCdgLiBlLmcuXG4gICAqXG4gICAqIGBgYGpzXG4gICAqIFBvbHltZXIuQXBwTGF5b3V0LnNjcm9sbCh7dG9wOiAwLCBiZWhhdmlvcjogJ3Ntb290aCd9KTtcbiAgICogYGBgXG4gICAqXG4gICAqIFRvIHNjcm9sbCBpbiBhIHNpbGVudCBtb2RlLCB3aXRob3V0IG5vdGlmeWluZyBzY3JvbGwgY2hhbmdlcyB0byBhbnkgYXBwLWxheW91dCBlbGVtZW50cyxcbiAgICogeW91IGNhbiBzZXQgdGhlIG9wdGlvbiBgYmVoYXZpb3I6ICdzaWxlbnQnYC4gVGhpcyBpcyBwYXJ0aWN1bGFybHkgdXNlZnVsIHdlIHlvdSBhcmUgdXNpbmdcbiAgICogYGFwcC1oZWFkZXJgIGFuZCB5b3UgZGVzaXJlIHRvIHNjcm9sbCB0byB0aGUgdG9wIG9mIGEgc2Nyb2xsaW5nIHJlZ2lvbiB3aXRob3V0IHJ1bm5pbmdcbiAgICogc2Nyb2xsIGVmZmVjdHMuIGUuZy5cbiAgICpcbiAgICogYGBganNcbiAgICogUG9seW1lci5BcHBMYXlvdXQuc2Nyb2xsKHt0b3A6IDAsIGJlaGF2aW9yOiAnc2lsZW50J30pO1xuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMge3RvcDogTnVtYmVyLCBsZWZ0OiBOdW1iZXIsIGJlaGF2aW9yOiBTdHJpbmcoc21vb3RoIHwgc2lsZW50KX1cbiAgICovXG4gIFBvbHltZXIuQXBwTGF5b3V0LnNjcm9sbCA9IGZ1bmN0aW9uIHNjcm9sbChvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICB2YXIgZG9jRWwgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgdmFyIHRhcmdldCA9IG9wdGlvbnMudGFyZ2V0IHx8IGRvY0VsO1xuICAgIHZhciBoYXNOYXRpdmVTY3JvbGxCZWhhdmlvciA9ICdzY3JvbGxCZWhhdmlvcicgaW4gdGFyZ2V0LnN0eWxlICYmIHRhcmdldC5zY3JvbGw7XG4gICAgdmFyIHNjcm9sbENsYXNzTmFtZSA9ICdhcHAtbGF5b3V0LXNpbGVudC1zY3JvbGwnO1xuICAgIHZhciBzY3JvbGxUb3AgPSBvcHRpb25zLnRvcCB8fCAwO1xuICAgIHZhciBzY3JvbGxMZWZ0ID0gb3B0aW9ucy5sZWZ0IHx8IDA7XG4gICAgdmFyIHNjcm9sbFRvID0gdGFyZ2V0ID09PSBkb2NFbCA/IHdpbmRvdy5zY3JvbGxUbyA6XG4gICAgICBmdW5jdGlvbiBzY3JvbGxUbyhzY3JvbGxMZWZ0LCBzY3JvbGxUb3ApIHtcbiAgICAgICAgdGFyZ2V0LnNjcm9sbExlZnQgPSBzY3JvbGxMZWZ0O1xuICAgICAgICB0YXJnZXQuc2Nyb2xsVG9wID0gc2Nyb2xsVG9wO1xuICAgICAgfTtcblxuICAgIGlmIChvcHRpb25zLmJlaGF2aW9yID09PSAnc21vb3RoJykge1xuXG4gICAgICBpZiAoaGFzTmF0aXZlU2Nyb2xsQmVoYXZpb3IpIHtcblxuICAgICAgICB0YXJnZXQuc2Nyb2xsKG9wdGlvbnMpO1xuXG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIHZhciB0aW1pbmdGbiA9IFBvbHltZXIuQXBwTGF5b3V0LnNjcm9sbFRpbWluZ0Z1bmN0aW9uO1xuICAgICAgICB2YXIgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdmFyIGN1cnJlbnRTY3JvbGxUb3AgPSB0YXJnZXQgPT09IGRvY0VsID8gd2luZG93LnBhZ2VZT2Zmc2V0IDogdGFyZ2V0LnNjcm9sbFRvcDtcbiAgICAgICAgdmFyIGN1cnJlbnRTY3JvbGxMZWZ0ID0gdGFyZ2V0ID09PSBkb2NFbCA/IHdpbmRvdy5wYWdlWE9mZnNldCA6IHRhcmdldC5zY3JvbGxMZWZ0O1xuICAgICAgICB2YXIgZGVsdGFTY3JvbGxUb3AgPSBzY3JvbGxUb3AgLSBjdXJyZW50U2Nyb2xsVG9wO1xuICAgICAgICB2YXIgZGVsdGFTY3JvbGxMZWZ0ID0gc2Nyb2xsTGVmdCAtIGN1cnJlbnRTY3JvbGxMZWZ0O1xuICAgICAgICB2YXIgZHVyYXRpb24gPSAzMDA7XG4gICAgICAgIHZhciB1cGRhdGVGcmFtZSA9IChmdW5jdGlvbiB1cGRhdGVGcmFtZSgpIHtcbiAgICAgICAgICB2YXIgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICB2YXIgZWxhcHNlZFRpbWUgPSBub3cgLSBzdGFydFRpbWU7XG5cbiAgICAgICAgICBpZiAoZWxhcHNlZFRpbWUgPCBkdXJhdGlvbikge1xuICAgICAgICAgICAgc2Nyb2xsVG8odGltaW5nRm4oZWxhcHNlZFRpbWUsIGN1cnJlbnRTY3JvbGxMZWZ0LCBkZWx0YVNjcm9sbExlZnQsIGR1cmF0aW9uKSxcbiAgICAgICAgICAgICAgICB0aW1pbmdGbihlbGFwc2VkVGltZSwgY3VycmVudFNjcm9sbFRvcCwgZGVsdGFTY3JvbGxUb3AsIGR1cmF0aW9uKSk7XG4gICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodXBkYXRlRnJhbWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzY3JvbGxUbyhzY3JvbGxMZWZ0LCBzY3JvbGxUb3ApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkuYmluZCh0aGlzKTtcblxuICAgICAgICB1cGRhdGVGcmFtZSgpO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIGlmIChvcHRpb25zLmJlaGF2aW9yID09PSAnc2lsZW50Jykge1xuICAgICAgdmFyIGhlYWRlcnMgPSBQb2x5bWVyLkFwcExheW91dC5xdWVyeUFsbFJvb3QoJ2FwcC1oZWFkZXInLCBkb2N1bWVudC5ib2R5KTtcblxuICAgICAgaGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uKGhlYWRlcikge1xuICAgICAgICBoZWFkZXIuc2V0QXR0cmlidXRlKCdzaWxlbnQtc2Nyb2xsJywgJycpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIEJyb3dzZXJzIGtlZXAgdGhlIHNjcm9sbCBtb21lbnR1bSBldmVuIGlmIHRoZSBib3R0b20gb2YgdGhlIHNjcm9sbGluZyBjb250ZW50XG4gICAgICAvLyB3YXMgcmVhY2hlZC4gVGhpcyBtZWFucyB0aGF0IGNhbGxpbmcgc2Nyb2xsKHt0b3A6IDAsIGJlaGF2aW9yOiAnc2lsZW50J30pIHdoZW5cbiAgICAgIC8vIHRoZSBtb21lbnR1bSBpcyBzdGlsbCBnb2luZyB3aWxsIHJlc3VsdCBpbiBtb3JlIHNjcm9sbCBldmVudHMgYW5kIHRodXMgc2Nyb2xsIGVmZmVjdHMuXG4gICAgICAvLyBUaGlzIHNlZW1zIHRvIG9ubHkgYXBwbHkgd2hlbiB1c2luZyBkb2N1bWVudCBzY3JvbGxpbmcuXG4gICAgICAvLyBUaGVyZWZvcmUsIHdoZW4gc2hvdWxkIHdlIHJlbW92ZSB0aGUgY2xhc3MgZnJvbSB0aGUgZG9jdW1lbnQgZWxlbWVudD9cblxuICAgICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKFBvbHltZXIuQXBwTGF5b3V0Ll9zY3JvbGxUaW1lcik7XG5cbiAgICAgIFBvbHltZXIuQXBwTGF5b3V0Ll9zY3JvbGxUaW1lciA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKSB7XG4gICAgICAgIGhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbihoZWFkZXIpIHtcbiAgICAgICAgICBoZWFkZXIucmVtb3ZlQXR0cmlidXRlKCdzaWxlbnQtc2Nyb2xsJyk7XG4gICAgICAgIH0pO1xuICAgICAgICBQb2x5bWVyLkFwcExheW91dC5fc2Nyb2xsVGltZXIgPSBudWxsO1xuICAgICAgfSk7XG5cbiAgICAgIHNjcm9sbFRvKHNjcm9sbExlZnQsIHNjcm9sbFRvcCk7XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICBzY3JvbGxUbyhzY3JvbGxMZWZ0LCBzY3JvbGxUb3ApO1xuXG4gICAgfVxuICB9O1xuXG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvYXBwLWxheW91dC9oZWxwZXJzL2hlbHBlcnMuaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTUgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cblxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uLy4uL3BvbHltZXIvcG9seW1lci5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vLi4vaXJvbi1mbGV4LWxheW91dC9pcm9uLWZsZXgtbGF5b3V0Lmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi9hcHAtbGF5b3V0LWJlaGF2aW9yL2FwcC1sYXlvdXQtYmVoYXZpb3IuaHRtbFwiPlxuXG48IS0tXG5hcHAtaGVhZGVyLWxheW91dCBpcyBhIHdyYXBwZXIgZWxlbWVudCB0aGF0IHBvc2l0aW9ucyBhbiBhcHAtaGVhZGVyIGFuZCBvdGhlciBjb250ZW50LiBUaGlzXG5lbGVtZW50IHVzZXMgdGhlIGRvY3VtZW50IHNjcm9sbCBieSBkZWZhdWx0LCBidXQgaXQgY2FuIGFsc28gZGVmaW5lIGl0cyBvd24gc2Nyb2xsaW5nIHJlZ2lvbi5cblxuVXNpbmcgdGhlIGRvY3VtZW50IHNjcm9sbDpcblxuYGBgaHRtbFxuPGFwcC1oZWFkZXItbGF5b3V0PlxuICA8YXBwLWhlYWRlciBzbG90PVwiaGVhZGVyXCIgZml4ZWQgY29uZGVuc2VzIGVmZmVjdHM9XCJ3YXRlcmZhbGxcIj5cbiAgICA8YXBwLXRvb2xiYXI+XG4gICAgICA8ZGl2IG1haW4tdGl0bGU+QXBwIG5hbWU8L2Rpdj5cbiAgICA8L2FwcC10b29sYmFyPlxuICA8L2FwcC1oZWFkZXI+XG4gIDxkaXY+XG4gICAgbWFpbiBjb250ZW50XG4gIDwvZGl2PlxuPC9hcHAtaGVhZGVyLWxheW91dD5cbmBgYFxuXG5Vc2luZyBhbiBvd24gc2Nyb2xsaW5nIHJlZ2lvbjpcblxuYGBgaHRtbFxuPGFwcC1oZWFkZXItbGF5b3V0IGhhcy1zY3JvbGxpbmctcmVnaW9uIHN0eWxlPVwid2lkdGg6IDMwMHB4OyBoZWlnaHQ6IDQwMHB4O1wiPlxuICA8YXBwLWhlYWRlciBzbG90PVwiaGVhZGVyXCIgZml4ZWQgY29uZGVuc2VzIGVmZmVjdHM9XCJ3YXRlcmZhbGxcIj5cbiAgICA8YXBwLXRvb2xiYXI+XG4gICAgICA8ZGl2IG1haW4tdGl0bGU+QXBwIG5hbWU8L2Rpdj5cbiAgICA8L2FwcC10b29sYmFyPlxuICA8L2FwcC1oZWFkZXI+XG4gIDxkaXY+XG4gICAgbWFpbiBjb250ZW50XG4gIDwvZGl2PlxuPC9hcHAtaGVhZGVyLWxheW91dD5cbmBgYFxuXG5BZGQgdGhlIGBmdWxsYmxlZWRgIGF0dHJpYnV0ZSB0byBhcHAtaGVhZGVyLWxheW91dCB0byBtYWtlIGl0IGZpdCB0aGUgc2l6ZSBvZiBpdHMgY29udGFpbmVyOlxuXG5gYGBodG1sXG48YXBwLWhlYWRlci1sYXlvdXQgZnVsbGJsZWVkPlxuIC4uLlxuPC9hcHAtaGVhZGVyLWxheW91dD5cbmBgYFxuXG5AZ3JvdXAgQXBwIEVsZW1lbnRzXG5AZWxlbWVudCBhcHAtaGVhZGVyLWxheW91dFxuQGRlbW8gYXBwLWhlYWRlci1sYXlvdXQvZGVtby9zaW1wbGUuaHRtbCBTaW1wbGUgRGVtb1xuQGRlbW8gYXBwLWhlYWRlci1sYXlvdXQvZGVtby9zY3JvbGxpbmctcmVnaW9uLmh0bWwgU2Nyb2xsaW5nIFJlZ2lvblxuQGRlbW8gYXBwLWhlYWRlci1sYXlvdXQvZGVtby9tdXNpYy5odG1sIE11c2ljIERlbW9cbkBkZW1vIGFwcC1oZWFkZXItbGF5b3V0L2RlbW8vZm9vdGVyLmh0bWwgRm9vdGVyIERlbW9cbi0tPlxuXG48ZG9tLW1vZHVsZSBpZD1cImFwcC1oZWFkZXItbGF5b3V0XCI+XG4gIDx0ZW1wbGF0ZT5cbiAgICA8c3R5bGU+XG4gICAgICA6aG9zdCB7XG4gICAgICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgICAgICAvKipcbiAgICAgICAgICogRm9yY2UgYXBwLWhlYWRlci1sYXlvdXQgdG8gaGF2ZSBpdHMgb3duIHN0YWNraW5nIGNvbnRleHQgc28gdGhhdCBpdHMgcGFyZW50IGNhblxuICAgICAgICAgKiBjb250cm9sIHRoZSBzdGFja2luZyBvZiBpdCByZWxhdGl2ZSB0byBvdGhlciBlbGVtZW50cyAoZS5nLiBhcHAtZHJhd2VyLWxheW91dCkuXG4gICAgICAgICAqIFRoaXMgY291bGQgYmUgZG9uZSB1c2luZyBgaXNvbGF0aW9uOiBpc29sYXRlYCwgYnV0IHRoYXQncyBub3Qgd2VsbCBzdXBwb3J0ZWRcbiAgICAgICAgICogYWNyb3NzIGJyb3dzZXJzLlxuICAgICAgICAgKi9cbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICB6LWluZGV4OiAwO1xuICAgICAgfVxuXG4gICAgICAjd3JhcHBlciA6OnNsb3R0ZWQoW3Nsb3Q9aGVhZGVyXSkge1xuICAgICAgICBAYXBwbHkgLS1sYXlvdXQtZml4ZWQtdG9wO1xuICAgICAgICB6LWluZGV4OiAxO1xuICAgICAgfVxuXG4gICAgICAjd3JhcHBlci5pbml0aWFsaXppbmcgOjpzbG90dGVkKFtzbG90PWhlYWRlcl0pIHtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgfVxuXG4gICAgICA6aG9zdChbaGFzLXNjcm9sbGluZy1yZWdpb25dKSB7XG4gICAgICAgIGhlaWdodDogMTAwJTtcbiAgICAgIH1cblxuICAgICAgOmhvc3QoW2hhcy1zY3JvbGxpbmctcmVnaW9uXSkgI3dyYXBwZXIgOjpzbG90dGVkKFtzbG90PWhlYWRlcl0pIHtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgfVxuXG4gICAgICA6aG9zdChbaGFzLXNjcm9sbGluZy1yZWdpb25dKSAjd3JhcHBlci5pbml0aWFsaXppbmcgOjpzbG90dGVkKFtzbG90PWhlYWRlcl0pIHtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgfVxuXG4gICAgICA6aG9zdChbaGFzLXNjcm9sbGluZy1yZWdpb25dKSAjd3JhcHBlciAjY29udGVudENvbnRhaW5lciB7XG4gICAgICAgIEBhcHBseSAtLWxheW91dC1maXQ7XG4gICAgICAgIG92ZXJmbG93LXk6IGF1dG87XG4gICAgICAgIC13ZWJraXQtb3ZlcmZsb3ctc2Nyb2xsaW5nOiB0b3VjaDtcbiAgICAgIH1cblxuICAgICAgOmhvc3QoW2hhcy1zY3JvbGxpbmctcmVnaW9uXSkgI3dyYXBwZXIuaW5pdGlhbGl6aW5nICNjb250ZW50Q29udGFpbmVyIHtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgfVxuXG4gICAgICA6aG9zdChbZnVsbGJsZWVkXSkge1xuICAgICAgICBAYXBwbHkgLS1sYXlvdXQtdmVydGljYWw7XG4gICAgICAgIEBhcHBseSAtLWxheW91dC1maXQ7XG4gICAgICB9XG5cbiAgICAgIDpob3N0KFtmdWxsYmxlZWRdKSAjd3JhcHBlcixcbiAgICAgIDpob3N0KFtmdWxsYmxlZWRdKSAjd3JhcHBlciAjY29udGVudENvbnRhaW5lciB7XG4gICAgICAgIEBhcHBseSAtLWxheW91dC12ZXJ0aWNhbDtcbiAgICAgICAgQGFwcGx5IC0tbGF5b3V0LWZsZXg7XG4gICAgICB9XG5cbiAgICAgICNjb250ZW50Q29udGFpbmVyIHtcbiAgICAgICAgLyogQ3JlYXRlIGEgc3RhY2tpbmcgY29udGV4dCBoZXJlIHNvIHRoYXQgYWxsIGNoaWxkcmVuIGFwcGVhciBiZWxvdyB0aGUgaGVhZGVyLiAqL1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgIHotaW5kZXg6IDA7XG4gICAgICB9XG5cbiAgICA8L3N0eWxlPlxuXG4gICAgPGRpdiBpZD1cIndyYXBwZXJcIiBjbGFzcz1cImluaXRpYWxpemluZ1wiPlxuICAgICAgPHNsb3QgaWQ9XCJoZWFkZXJTbG90XCIgbmFtZT1cImhlYWRlclwiPjwvc2xvdD5cblxuICAgICAgPGRpdiBpZD1cImNvbnRlbnRDb250YWluZXJcIj5cbiAgICAgICAgPHNsb3Q+PC9zbG90PlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG5cbiAgPC90ZW1wbGF0ZT5cblxuICA8c2NyaXB0PlxuICAgIFBvbHltZXIoe1xuICAgICAgaXM6ICdhcHAtaGVhZGVyLWxheW91dCcsXG5cbiAgICAgIGJlaGF2aW9yczogW1xuICAgICAgICBQb2x5bWVyLkFwcExheW91dEJlaGF2aW9yXG4gICAgICBdLFxuXG4gICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0cnVlLCB0aGUgY3VycmVudCBlbGVtZW50IHdpbGwgaGF2ZSBpdHMgb3duIHNjcm9sbGluZyByZWdpb24uXG4gICAgICAgICAqIE90aGVyd2lzZSwgaXQgd2lsbCB1c2UgdGhlIGRvY3VtZW50IHNjcm9sbCB0byBjb250cm9sIHRoZSBoZWFkZXIuXG4gICAgICAgICAqL1xuICAgICAgICBoYXNTY3JvbGxpbmdSZWdpb246IHtcbiAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgIHZhbHVlOiBmYWxzZSxcbiAgICAgICAgICByZWZsZWN0VG9BdHRyaWJ1dGU6IHRydWVcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgb2JzZXJ2ZXJzOiBbXG4gICAgICAgICdyZXNldExheW91dChpc0F0dGFjaGVkLCBoYXNTY3JvbGxpbmdSZWdpb24pJ1xuICAgICAgXSxcblxuICAgICAgLyoqXG4gICAgICAgKiBBIHJlZmVyZW5jZSB0byB0aGUgYXBwLWhlYWRlciBlbGVtZW50LlxuICAgICAgICpcbiAgICAgICAqIEBwcm9wZXJ0eSBoZWFkZXJcbiAgICAgICAqL1xuICAgICAgZ2V0IGhlYWRlcigpIHtcbiAgICAgICAgcmV0dXJuIFBvbHltZXIuZG9tKHRoaXMuJC5oZWFkZXJTbG90KS5nZXREaXN0cmlidXRlZE5vZGVzKClbMF07XG4gICAgICB9LFxuXG4gICAgICBfdXBkYXRlTGF5b3V0U3RhdGVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGhlYWRlciA9IHRoaXMuaGVhZGVyO1xuICAgICAgICBpZiAoIXRoaXMuaXNBdHRhY2hlZCB8fCAhaGVhZGVyKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlbW92ZSB0aGUgaW5pdGlhbGl6aW5nIGNsYXNzLCB3aGljaCBzdGF0aWNseSBwb3NpdGlvbnMgdGhlIGhlYWRlciBhbmQgdGhlIGNvbnRlbnRcbiAgICAgICAgLy8gdW50aWwgdGhlIGhlaWdodCBvZiB0aGUgaGVhZGVyIGNhbiBiZSByZWFkLlxuICAgICAgICB0aGlzLiQud3JhcHBlci5jbGFzc0xpc3QucmVtb3ZlKCdpbml0aWFsaXppbmcnKTtcbiAgICAgICAgLy8gVXBkYXRlIHNjcm9sbCB0YXJnZXQuXG4gICAgICAgIGhlYWRlci5zY3JvbGxUYXJnZXQgPSB0aGlzLmhhc1Njcm9sbGluZ1JlZ2lvbiA/XG4gICAgICAgICAgICB0aGlzLiQuY29udGVudENvbnRhaW5lciA6IHRoaXMub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIC8vIEdldCBoZWFkZXIgaGVpZ2h0IGhlcmUgc28gdGhhdCBzdHlsZSByZWFkcyBhcmUgYmF0Y2hlZCB0b2dldGhlciBiZWZvcmUgc3R5bGUgd3JpdGVzXG4gICAgICAgIC8vIChpLmUuIGdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIGJlbG93KS5cbiAgICAgICAgdmFyIGhlYWRlckhlaWdodCA9IGhlYWRlci5vZmZzZXRIZWlnaHQ7XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgaGVhZGVyIHBvc2l0aW9uLlxuICAgICAgICBpZiAoIXRoaXMuaGFzU2Nyb2xsaW5nUmVnaW9uKSB7XG4gICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHJlY3QgPSB0aGlzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgdmFyIHJpZ2h0T2Zmc2V0ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoIC0gcmVjdC5yaWdodDtcbiAgICAgICAgICAgIGhlYWRlci5zdHlsZS5sZWZ0ID0gcmVjdC5sZWZ0ICsgJ3B4JztcbiAgICAgICAgICAgIGhlYWRlci5zdHlsZS5yaWdodCA9IHJpZ2h0T2Zmc2V0ICsgJ3B4JztcbiAgICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGhlYWRlci5zdHlsZS5sZWZ0ID0gJyc7XG4gICAgICAgICAgaGVhZGVyLnN0eWxlLnJpZ2h0ID0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXBkYXRlIHRoZSBjb250ZW50IGNvbnRhaW5lciBwb3NpdGlvbi5cbiAgICAgICAgdmFyIGNvbnRhaW5lclN0eWxlID0gdGhpcy4kLmNvbnRlbnRDb250YWluZXIuc3R5bGU7XG4gICAgICAgIGlmIChoZWFkZXIuZml4ZWQgJiYgIWhlYWRlci5jb25kZW5zZXMgJiYgdGhpcy5oYXNTY3JvbGxpbmdSZWdpb24pIHtcbiAgICAgICAgICAvLyBJZiB0aGUgaGVhZGVyIHNpemUgZG9lcyBub3QgY2hhbmdlIGFuZCB3ZSdyZSB1c2luZyBhIHNjcm9sbGluZyByZWdpb24sIGV4Y2x1ZGVcbiAgICAgICAgICAvLyB0aGUgaGVhZGVyIGFyZWEgZnJvbSB0aGUgc2Nyb2xsaW5nIHJlZ2lvbiBzbyB0aGF0IHRoZSBoZWFkZXIgZG9lc24ndCBvdmVybGFwXG4gICAgICAgICAgLy8gdGhlIHNjcm9sbGJhci5cbiAgICAgICAgICBjb250YWluZXJTdHlsZS5tYXJnaW5Ub3AgPSBoZWFkZXJIZWlnaHQgKyAncHgnO1xuICAgICAgICAgIGNvbnRhaW5lclN0eWxlLnBhZGRpbmdUb3AgPSAnJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb250YWluZXJTdHlsZS5wYWRkaW5nVG9wID0gaGVhZGVySGVpZ2h0ICsgJ3B4JztcbiAgICAgICAgICBjb250YWluZXJTdHlsZS5tYXJnaW5Ub3AgPSAnJztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgfSk7XG4gIDwvc2NyaXB0PlxuPC9kb20tbW9kdWxlPlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9hcHAtbGF5b3V0L2FwcC1oZWFkZXItbGF5b3V0L2FwcC1oZWFkZXItbGF5b3V0Lmh0bWwiLCJcbnJlcXVpcmUoJy4vZWZmZWN0cy9ibGVuZC1iYWNrZ3JvdW5kLmh0bWwnKTtcblxucmVxdWlyZSgnLi9lZmZlY3RzL2ZhZGUtYmFja2dyb3VuZC5odG1sJyk7XG5cbnJlcXVpcmUoJy4vZWZmZWN0cy9tYXRlcmlhbC5odG1sJyk7XG5cbnJlcXVpcmUoJy4vZWZmZWN0cy9wYXJhbGxheC1iYWNrZ3JvdW5kLmh0bWwnKTtcblxucmVxdWlyZSgnLi9lZmZlY3RzL3Jlc2l6ZS1zbmFwcGVkLXRpdGxlLmh0bWwnKTtcblxucmVxdWlyZSgnLi9lZmZlY3RzL3Jlc2l6ZS10aXRsZS5odG1sJyk7XG5cbnJlcXVpcmUoJy4vZWZmZWN0cy93YXRlcmZhbGwuaHRtbCcpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9hcHAtbGF5b3V0L2FwcC1zY3JvbGwtZWZmZWN0cy9hcHAtc2Nyb2xsLWVmZmVjdHMuaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTYgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cblxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL2FwcC1zY3JvbGwtZWZmZWN0cy1iZWhhdmlvci5odG1sXCI+XG5cbjxzY3JpcHQ+XG4gIC8qKlxuICAgKiBVcG9uIHNjcm9sbGluZyBwYXN0IGEgdGhyZXNob2xkLCBmYWRlIGluIHRoZSByZWFyIGJhY2tncm91bmQgbGF5ZXIgYW5kIGZhZGUgb3V0IHRoZSBmcm9udFxuICAgKiBiYWNrZ3JvdW5kIGxheWVyIChvcGFjaXR5IENTUyB0cmFuc2l0aW9uZWQgb3ZlciB0aW1lKS5cbiAgICpcbiAgICpcbiAgICovXG4gIFBvbHltZXIuQXBwTGF5b3V0LnJlZ2lzdGVyRWZmZWN0KCdmYWRlLWJhY2tncm91bmQnLCB7XG4gICAgLyoqIEB0aGlzIFBvbHltZXIuQXBwTGF5b3V0LkVsZW1lbnRXaXRoQmFja2dyb3VuZCAqL1xuICAgIHNldFVwOiBmdW5jdGlvbiBzZXRVcChjb25maWcpIHtcbiAgICAgIHZhciBmeCA9IHt9O1xuICAgICAgdmFyIGR1cmF0aW9uID0gY29uZmlnLmR1cmF0aW9uIHx8ICcwLjVzJztcbiAgICAgIGZ4LmJhY2tncm91bmRGcm9udExheWVyID0gdGhpcy5fZ2V0RE9NUmVmKCdiYWNrZ3JvdW5kRnJvbnRMYXllcicpO1xuICAgICAgZnguYmFja2dyb3VuZFJlYXJMYXllciA9IHRoaXMuX2dldERPTVJlZignYmFja2dyb3VuZFJlYXJMYXllcicpO1xuICAgICAgZnguYmFja2dyb3VuZEZyb250TGF5ZXIuc3R5bGUud2lsbENoYW5nZSA9ICdvcGFjaXR5JztcbiAgICAgIGZ4LmJhY2tncm91bmRGcm9udExheWVyLnN0eWxlLndlYmtpdFRyYW5zZm9ybSA9ICd0cmFuc2xhdGVaKDApJztcbiAgICAgIGZ4LmJhY2tncm91bmRGcm9udExheWVyLnN0eWxlLnRyYW5zaXRpb25Qcm9wZXJ0eSA9ICdvcGFjaXR5JztcbiAgICAgIGZ4LmJhY2tncm91bmRGcm9udExheWVyLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9IGR1cmF0aW9uO1xuICAgICAgZnguYmFja2dyb3VuZFJlYXJMYXllci5zdHlsZS53aWxsQ2hhbmdlID0gJ29wYWNpdHknO1xuICAgICAgZnguYmFja2dyb3VuZFJlYXJMYXllci5zdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSAndHJhbnNsYXRlWigwKSc7XG4gICAgICBmeC5iYWNrZ3JvdW5kUmVhckxheWVyLnN0eWxlLnRyYW5zaXRpb25Qcm9wZXJ0eSA9ICdvcGFjaXR5JztcbiAgICAgIGZ4LmJhY2tncm91bmRSZWFyTGF5ZXIuc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID0gZHVyYXRpb247XG4gICAgICB0aGlzLl9meEZhZGVCYWNrZ3JvdW5kID0gZng7XG4gICAgfSxcbiAgICAvKiogQHRoaXMgUG9seW1lci5BcHBMYXlvdXQuRWxlbWVudFdpdGhCYWNrZ3JvdW5kICovXG4gICAgcnVuOiBmdW5jdGlvbiBydW4ocCwgeSkge1xuICAgICAgdmFyIGZ4ID0gdGhpcy5fZnhGYWRlQmFja2dyb3VuZDtcbiAgICAgIGlmIChwID49IDEpIHtcbiAgICAgICAgZnguYmFja2dyb3VuZEZyb250TGF5ZXIuc3R5bGUub3BhY2l0eSA9IDA7XG4gICAgICAgIGZ4LmJhY2tncm91bmRSZWFyTGF5ZXIuc3R5bGUub3BhY2l0eSA9IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmeC5iYWNrZ3JvdW5kRnJvbnRMYXllci5zdHlsZS5vcGFjaXR5ID0gMTtcbiAgICAgICAgZnguYmFja2dyb3VuZFJlYXJMYXllci5zdHlsZS5vcGFjaXR5ID0gMDtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8qKiBAdGhpcyBQb2x5bWVyLkFwcExheW91dC5FbGVtZW50V2l0aEJhY2tncm91bmQgKi9cbiAgICB0ZWFyRG93bjogZnVuY3Rpb24gdGVhckRvd24oKSB7XG4gICAgICBkZWxldGUgdGhpcy5fZnhGYWRlQmFja2dyb3VuZDtcbiAgICB9XG4gIH0pO1xuPC9zY3JpcHQ+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL2FwcC1sYXlvdXQvYXBwLXNjcm9sbC1lZmZlY3RzL2VmZmVjdHMvZmFkZS1iYWNrZ3JvdW5kLmh0bWwiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi9hcHAtc2Nyb2xsLWVmZmVjdHMtYmVoYXZpb3IuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIndhdGVyZmFsbC5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwicmVzaXplLXRpdGxlLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCJibGVuZC1iYWNrZ3JvdW5kLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCJwYXJhbGxheC1iYWNrZ3JvdW5kLmh0bWxcIj5cblxuPHNjcmlwdD5cbiAgLyoqXG4gICAqIFNob3J0aGFuZCBmb3IgdGhlIHdhdGVyZmFsbCwgcmVzaXplLXRpdGxlLCBibGVuZC1iYWNrZ3JvdW5kLCBhbmQgcGFyYWxsYXgtYmFja2dyb3VuZCBlZmZlY3RzLlxuICAgKi9cbiAgUG9seW1lci5BcHBMYXlvdXQucmVnaXN0ZXJFZmZlY3QoJ21hdGVyaWFsJywge1xuICAgIC8qKlxuICAgICAqIEB0aGlzIFBvbHltZXIuQXBwTGF5b3V0LkVsZW1lbnRXaXRoQmFja2dyb3VuZFxuICAgICAqL1xuICAgIHNldFVwOiBmdW5jdGlvbiBzZXRVcCgpIHtcbiAgICAgIHRoaXMuZWZmZWN0cyA9ICd3YXRlcmZhbGwgcmVzaXplLXRpdGxlIGJsZW5kLWJhY2tncm91bmQgcGFyYWxsYXgtYmFja2dyb3VuZCc7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9KTtcbjwvc2NyaXB0PlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9hcHAtbGF5b3V0L2FwcC1zY3JvbGwtZWZmZWN0cy9lZmZlY3RzL21hdGVyaWFsLmh0bWwiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi9hcHAtc2Nyb2xsLWVmZmVjdHMtYmVoYXZpb3IuaHRtbFwiPlxuXG48c2NyaXB0PlxuICAvKipcbiAgICogVXBvbiBzY3JvbGxpbmcgcGFzdCBhIHRocmVzaG9sZCwgQ1NTIHRyYW5zaXRpb24gdGhlIGZvbnQgc2l6ZSBvZiBhIGRlc2lnbmF0ZWQgdGl0bGUgZWxlbWVudFxuICAgKiBiZXR3ZWVuIHR3byB2YWx1ZXMuXG4gICAqL1xuICBQb2x5bWVyLkFwcExheW91dC5yZWdpc3RlckVmZmVjdCgncmVzaXplLXNuYXBwZWQtdGl0bGUnLCB7XG4gICAgLyoqXG4gICAgICogQHRoaXMgUG9seW1lci5BcHBMYXlvdXQuRWxlbWVudFdpdGhCYWNrZ3JvdW5kXG4gICAgICovXG4gICAgc2V0VXA6IGZ1bmN0aW9uIHNldFVwKGNvbmZpZykge1xuICAgICAgdmFyIHRpdGxlID0gdGhpcy5fZ2V0RE9NUmVmKCdtYWluVGl0bGUnKTtcbiAgICAgIHZhciBjb25kZW5zZWRUaXRsZSA9IHRoaXMuX2dldERPTVJlZignY29uZGVuc2VkVGl0bGUnKTtcbiAgICAgIHZhciBkdXJhdGlvbiA9IGNvbmZpZy5kdXJhdGlvbiB8fCAnMC4ycyc7XG4gICAgICB2YXIgZnggPSB7fTtcblxuICAgICAgaWYgKCFjb25kZW5zZWRUaXRsZSkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1Njcm9sbCBlZmZlY3QgYHJlc2l6ZS1zbmFwcGVkLXRpdGxlYDogdW5kZWZpbmVkIGBjb25kZW5zZWQtdGl0bGVgJyk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICghdGl0bGUpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdTY3JvbGwgZWZmZWN0IGByZXNpemUtc25hcHBlZC10aXRsZWA6IHVuZGVmaW5lZCBgbWFpbi10aXRsZWAnKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB0aXRsZS5zdHlsZS50cmFuc2l0aW9uUHJvcGVydHkgPSAnb3BhY2l0eSc7XG4gICAgICB0aXRsZS5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPSBkdXJhdGlvbjtcbiAgICAgIGNvbmRlbnNlZFRpdGxlLnN0eWxlLnRyYW5zaXRpb25Qcm9wZXJ0eSA9ICdvcGFjaXR5JztcbiAgICAgIGNvbmRlbnNlZFRpdGxlLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9IGR1cmF0aW9uO1xuICAgICAgZnguY29uZGVuc2VkVGl0bGUgPSBjb25kZW5zZWRUaXRsZTtcbiAgICAgIGZ4LnRpdGxlID0gdGl0bGU7XG4gICAgICB0aGlzLl9meFJlc2l6ZVNuYXBwZWRUaXRsZSA9IGZ4O1xuICAgIH0sXG4gICAgLyoqIEB0aGlzIFBvbHltZXIuQXBwTGF5b3V0LkVsZW1lbnRXaXRoQmFja2dyb3VuZCAqL1xuICAgIHJ1bjogZnVuY3Rpb24gcnVuKHAsIHkpIHtcbiAgICAgIHZhciBmeCA9IHRoaXMuX2Z4UmVzaXplU25hcHBlZFRpdGxlO1xuICAgICAgaWYgKHAgPiAwKSB7XG4gICAgICAgIGZ4LnRpdGxlLnN0eWxlLm9wYWNpdHkgPSAwO1xuICAgICAgICBmeC5jb25kZW5zZWRUaXRsZS5zdHlsZS5vcGFjaXR5ID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZ4LnRpdGxlLnN0eWxlLm9wYWNpdHkgPSAxO1xuICAgICAgICBmeC5jb25kZW5zZWRUaXRsZS5zdHlsZS5vcGFjaXR5ID0gMDtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8qKiBAdGhpcyBQb2x5bWVyLkFwcExheW91dC5FbGVtZW50V2l0aEJhY2tncm91bmQgKi9cbiAgICB0ZWFyRG93bjogZnVuY3Rpb24gdGVhckRvd24oKSB7XG4gICAgICB2YXIgZnggPSB0aGlzLl9meFJlc2l6ZVNuYXBwZWRUaXRsZTtcbiAgICAgIGZ4LnRpdGxlLnN0eWxlLnRyYW5zaXRpb24gPSAnJztcbiAgICAgIGZ4LmNvbmRlbnNlZFRpdGxlLnN0eWxlLnRyYW5zaXRpb24gPSAnJztcbiAgICAgIGRlbGV0ZSB0aGlzLl9meFJlc2l6ZVNuYXBwZWRUaXRsZTtcbiAgICB9XG4gIH0pO1xuPC9zY3JpcHQ+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL2FwcC1sYXlvdXQvYXBwLXNjcm9sbC1lZmZlY3RzL2VmZmVjdHMvcmVzaXplLXNuYXBwZWQtdGl0bGUuaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTUgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cblxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uLy4uL3BvbHltZXIvcG9seW1lci5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vLi4vaXJvbi1mbGV4LWxheW91dC9pcm9uLWZsZXgtbGF5b3V0Lmh0bWxcIj5cblxuPCEtLVxuYXBwLXRvb2xiYXIgaXMgYSBob3Jpem9udGFsIHRvb2xiYXIgY29udGFpbmluZyBpdGVtcyB0aGF0IGNhbiBiZSB1c2VkIGZvclxubGFiZWwsIG5hdmlnYXRpb24sIHNlYXJjaCBhbmQgYWN0aW9ucy5cblxuIyMjIEV4YW1wbGVcblxuQWRkIGEgdGl0bGUgdG8gdGhlIHRvb2xiYXIuXG5cbmBgYGh0bWxcbjxhcHAtdG9vbGJhcj5cbiAgPGRpdiBtYWluLXRpdGxlPkFwcCBuYW1lPC9kaXY+XG48L2FwcC10b29sYmFyPlxuYGBgXG5cbkFkZCBhIGJ1dHRvbiB0byB0aGUgbGVmdCBhbmQgcmlnaHQgc2lkZSBvZiB0aGUgdG9vbGJhci5cblxuYGBgaHRtbFxuPGFwcC10b29sYmFyPlxuICA8cGFwZXItaWNvbi1idXR0b24gaWNvbj1cIm1lbnVcIj48L3BhcGVyLWljb24tYnV0dG9uPlxuICA8ZGl2IG1haW4tdGl0bGU+QXBwIG5hbWU8L2Rpdj5cbiAgPHBhcGVyLWljb24tYnV0dG9uIGljb249XCJzZWFyY2hcIj48L3BhcGVyLWljb24tYnV0dG9uPlxuPC9hcHAtdG9vbGJhcj5cbmBgYFxuXG5Zb3UgY2FuIHVzZSB0aGUgYXR0cmlidXRlcyBgdG9wLWl0ZW1gIG9yIGBib3R0b20taXRlbWAgdG8gY29tcGxldGVseSBmaXQgYW4gZWxlbWVudFxudG8gdGhlIHRvcCBvciBib3R0b20gb2YgdGhlIHRvb2xiYXIgcmVzcGVjdGl2ZWx5LlxuXG4jIyMgQ29udGVudCBhdHRyaWJ1dGVzXG5cbkF0dHJpYnV0ZSAgICAgICAgICAgIHwgRGVzY3JpcHRpb25cbi0tLS0tLS0tLS0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmBtYWluLXRpdGxlYCAgICAgICAgIHwgVGhlIG1haW4gdGl0bGUgZWxlbWVudC5cbmBjb25kZW5zZWQtdGl0bGVgICAgIHwgVGhlIHRpdGxlIGVsZW1lbnQgaWYgdXNlZCBpbnNpZGUgYSBjb25kZW5zZWQgYXBwLWhlYWRlci5cbmBzcGFjZXJgICAgICAgICAgICAgIHwgQWRkcyBhIGxlZnQgbWFyZ2luIG9mIGA2NHB4YC5cbmBib3R0b20taXRlbWAgICAgICAgIHwgU3RpY2tzIHRoZSBlbGVtZW50IHRvIHRoZSBib3R0b20gb2YgdGhlIHRvb2xiYXIuXG5gdG9wLWl0ZW1gICAgICAgICAgICB8IFN0aWNrcyB0aGUgZWxlbWVudCB0byB0aGUgdG9wIG9mIHRoZSB0b29sYmFyLlxuXG4jIyMgU3R5bGluZ1xuXG5DdXN0b20gcHJvcGVydHkgICAgICAgICAgICAgIHwgRGVzY3JpcHRpb24gICAgICAgICAgICAgICAgICB8IERlZmF1bHRcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuYC0tYXBwLXRvb2xiYXItZm9udC1zaXplYCAgICB8IFRvb2xiYXIgZm9udCBzaXplICAgICAgICAgICAgfCAyMHB4XG5cbkBncm91cCBBcHAgRWxlbWVudHNcbkBlbGVtZW50IGFwcC10b29sYmFyXG5AZGVtbyBhcHAtdG9vbGJhci9kZW1vL2luZGV4Lmh0bWxcbi0tPlxuXG48ZG9tLW1vZHVsZSBpZD1cImFwcC10b29sYmFyXCI+XG4gIDx0ZW1wbGF0ZT5cbiAgICA8c3R5bGU+XG5cbiAgICAgIDpob3N0IHtcbiAgICAgICAgQGFwcGx5IC0tbGF5b3V0LWhvcml6b250YWw7XG4gICAgICAgIEBhcHBseSAtLWxheW91dC1jZW50ZXI7XG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgaGVpZ2h0OiA2NHB4O1xuICAgICAgICBwYWRkaW5nOiAwIDE2cHg7XG4gICAgICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xuICAgICAgICBmb250LXNpemU6IHZhcigtLWFwcC10b29sYmFyLWZvbnQtc2l6ZSwgMjBweCk7XG4gICAgICB9XG5cbiAgICAgIDpob3N0IDo6c2xvdHRlZCgqKSB7XG4gICAgICAgIHBvaW50ZXItZXZlbnRzOiBhdXRvO1xuICAgICAgfVxuXG4gICAgICA6aG9zdCA6OnNsb3R0ZWQocGFwZXItaWNvbi1idXR0b24pIHtcbiAgICAgICAgLyogcGFwZXItaWNvbi1idXR0b24vaXNzdWVzLzMzICovXG4gICAgICAgIGZvbnQtc2l6ZTogMDtcbiAgICAgIH1cblxuICAgICAgOmhvc3QgOjpzbG90dGVkKFttYWluLXRpdGxlXSksXG4gICAgICA6aG9zdCA6OnNsb3R0ZWQoW2NvbmRlbnNlZC10aXRsZV0pIHtcbiAgICAgICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG4gICAgICAgIEBhcHBseSAtLWxheW91dC1mbGV4O1xuICAgICAgfVxuXG4gICAgICA6aG9zdCA6OnNsb3R0ZWQoW2JvdHRvbS1pdGVtXSkge1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIHJpZ2h0OiAwO1xuICAgICAgICBib3R0b206IDA7XG4gICAgICAgIGxlZnQ6IDA7XG4gICAgICB9XG5cbiAgICAgIDpob3N0IDo6c2xvdHRlZChbdG9wLWl0ZW1dKSB7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgdG9wOiAwO1xuICAgICAgICByaWdodDogMDtcbiAgICAgICAgbGVmdDogMDtcbiAgICAgIH1cblxuICAgICAgOmhvc3QgOjpzbG90dGVkKFtzcGFjZXJdKSB7XG4gICAgICAgIG1hcmdpbi1sZWZ0OiA2NHB4O1xuICAgICAgfVxuICAgIDwvc3R5bGU+XG5cbiAgICA8c2xvdD48L3Nsb3Q+XG5cbiAgPC90ZW1wbGF0ZT5cblxuICA8c2NyaXB0PlxuICAgIFBvbHltZXIoe1xuICAgICAgaXM6ICdhcHAtdG9vbGJhcidcbiAgICB9KTtcbiAgPC9zY3JpcHQ+XG48L2RvbS1tb2R1bGU+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL2FwcC1sYXlvdXQvYXBwLXRvb2xiYXIvYXBwLXRvb2xiYXIuaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTYgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi9wb2x5bWVyL3BvbHltZXIuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL2lyb24tbG9jYXRpb24vaXJvbi1sb2NhdGlvbi5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vaXJvbi1sb2NhdGlvbi9pcm9uLXF1ZXJ5LXBhcmFtcy5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiYXBwLXJvdXRlLWNvbnZlcnRlci1iZWhhdmlvci5odG1sXCI+XG5cbjwhLS1cbmBhcHAtbG9jYXRpb25gIGlzIGFuIGVsZW1lbnQgdGhhdCBwcm92aWRlcyBzeW5jaHJvbml6YXRpb24gYmV0d2VlbiB0aGVcbmJyb3dzZXIgbG9jYXRpb24gYmFyIGFuZCB0aGUgc3RhdGUgb2YgYW4gYXBwLiBXaGVuIGNyZWF0ZWQsIGBhcHAtbG9jYXRpb25gXG5lbGVtZW50cyB3aWxsIGF1dG9tYXRpY2FsbHkgd2F0Y2ggdGhlIGdsb2JhbCBsb2NhdGlvbiBmb3IgY2hhbmdlcy4gQXMgY2hhbmdlc1xub2NjdXIsIGBhcHAtbG9jYXRpb25gIHByb2R1Y2VzIGFuZCB1cGRhdGVzIGFuIG9iamVjdCBjYWxsZWQgYHJvdXRlYC4gVGhpc1xuYHJvdXRlYCBvYmplY3QgaXMgc3VpdGFibGUgZm9yIHBhc3NpbmcgaW50byBhIGBhcHAtcm91dGVgLCBhbmQgb3RoZXIgc2ltaWxhclxuZWxlbWVudHMuXG5cbkFuIGV4YW1wbGUgb2YgdGhlIHB1YmxpYyBBUEkgb2YgYSByb3V0ZSBvYmplY3QgdGhhdCBkZXNjcmliZXMgdGhlIFVSTFxuYGh0dHBzOi8vZWxlbWVudHMucG9seW1lci1wcm9qZWN0Lm9yZy9lbGVtZW50cy9hcHAtbG9jYXRpb25gOlxuXG4gICAge1xuICAgICAgcHJlZml4OiAnJyxcbiAgICAgIHBhdGg6ICcvZWxlbWVudHMvYXBwLWxvY2F0aW9uJ1xuICAgIH1cblxuRXhhbXBsZSBVc2FnZTpcblxuICAgIDxhcHAtbG9jYXRpb24gcm91dGU9XCJ7e3JvdXRlfX1cIj48L2FwcC1sb2NhdGlvbj5cbiAgICA8YXBwLXJvdXRlIHJvdXRlPVwie3tyb3V0ZX19XCIgcGF0dGVybj1cIi86cGFnZVwiIGRhdGE9XCJ7e2RhdGF9fVwiPjwvYXBwLXJvdXRlPlxuXG5BcyB5b3UgY2FuIHNlZSBhYm92ZSwgdGhlIGBhcHAtbG9jYXRpb25gIGVsZW1lbnQgcHJvZHVjZXMgYSBgcm91dGVgIGFuZCB0aGF0XG5wcm9wZXJ0eSBpcyB0aGVuIGJvdW5kIGludG8gdGhlIGBhcHAtcm91dGVgIGVsZW1lbnQuIFRoZSBiaW5kaW5ncyBhcmUgdHdvLVxuZGlyZWN0aW9uYWwsIHNvIHdoZW4gY2hhbmdlcyB0byB0aGUgYHJvdXRlYCBvYmplY3Qgb2NjdXIgd2l0aGluIGBhcHAtcm91dGVgLFxudGhleSBhdXRvbWF0aWNhbGx5IHJlZmxlY3QgYmFjayB0byB0aGUgZ2xvYmFsIGxvY2F0aW9uLlxuXG4jIyMgSGFzaGVzIHZzIFBhdGhzXG5cbkJ5IGRlZmF1bHQgYGFwcC1sb2NhdGlvbmAgcm91dGVzIHVzaW5nIHRoZSBwYXRobmFtZSBwb3J0aW9uIG9mIHRoZSBVUkwuIFRoaXMgaGFzXG5icm9hZCBicm93c2VyIHN1cHBvcnQgYnV0IGl0IGRvZXMgcmVxdWlyZSBjb29wZXJhdGlvbiBvZiB0aGUgYmFja2VuZCBzZXJ2ZXIuIEFuXG5gYXBwLWxvY2F0aW9uYCBjYW4gYmUgY29uZmlndXJlZCB0byB1c2UgdGhlIGhhc2ggcGFydCBvZiBhIFVSTCBpbnN0ZWFkIHVzaW5nXG50aGUgYHVzZS1oYXNoLWFzLXBhdGhgIGF0dHJpYnV0ZSwgbGlrZSBzbzpcblxuICAgIDxhcHAtbG9jYXRpb24gcm91dGU9XCJ7e3JvdXRlfX1cIiB1c2UtaGFzaC1hcy1wYXRoPjwvYXBwLWxvY2F0aW9uPlxuXG4jIyMgSW50ZWdyYXRpbmcgd2l0aCBvdGhlciByb3V0aW5nIGNvZGVcblxuVGhlcmUgaXMgbm8gc3RhbmRhcmQgZXZlbnQgdGhhdCBpcyBmaXJlZCB3aGVuIHdpbmRvdy5sb2NhdGlvbiBpcyBtb2RpZmllZC5cbmBhcHAtbG9jYXRpb25gIGZpcmVzIGEgYGxvY2F0aW9uLWNoYW5nZWRgIGV2ZW50IG9uIGB3aW5kb3dgIHdoZW4gaXQgdXBkYXRlcyB0aGVcbmxvY2F0aW9uLiBJdCBhbHNvIGxpc3RlbnMgZm9yIHRoYXQgc2FtZSBldmVudCwgYW5kIHJlLXJlYWRzIHRoZSBVUkwgd2hlbiBpdCdzXG5maXJlZC4gVGhpcyBtYWtlcyBpdCB2ZXJ5IGVhc3kgdG8gaW50ZXJvcCB3aXRoIG90aGVyIHJvdXRpbmcgY29kZS5cblxuU28gZm9yIGV4YW1wbGUgaWYgeW91IHdhbnQgdG8gbmF2aWdhdGUgdG8gYC9uZXdfcGF0aGAgaW1wZXJhdGl2ZWx5IHlvdSBjb3VsZFxuY2FsbCBgd2luZG93LmxvY2F0aW9uLnB1c2hTdGF0ZWAgb3IgYHdpbmRvdy5sb2NhdGlvbi5yZXBsYWNlU3RhdGVgIGZvbGxvd2VkIGJ5XG5maXJpbmcgYSBgbG9jYXRpb24tY2hhbmdlZGAgZXZlbnQgb24gYHdpbmRvd2AuIGkuZS5cblxuICAgIHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZSh7fSwgbnVsbCwgJy9uZXdfcGF0aCcpO1xuICAgIHdpbmRvdy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnbG9jYXRpb24tY2hhbmdlZCcpKTtcblxuQGVsZW1lbnQgYXBwLWxvY2F0aW9uXG5AZGVtbyBkZW1vL2luZGV4Lmh0bWxcbi0tPlxuPGRvbS1tb2R1bGUgaWQ9XCJhcHAtbG9jYXRpb25cIj5cbiAgPHRlbXBsYXRlPlxuICAgIDxpcm9uLXF1ZXJ5LXBhcmFtc1xuICAgICAgICBwYXJhbXMtc3RyaW5nPVwie3tfX3F1ZXJ5fX1cIlxuICAgICAgICBwYXJhbXMtb2JqZWN0PVwie3txdWVyeVBhcmFtc319XCI+XG4gICAgPC9pcm9uLXF1ZXJ5LXBhcmFtcz5cbiAgICA8aXJvbi1sb2NhdGlvblxuICAgICAgICBwYXRoPVwie3tfX3BhdGh9fVwiXG4gICAgICAgIHF1ZXJ5PVwie3tfX3F1ZXJ5fX1cIlxuICAgICAgICBoYXNoPVwie3tfX2hhc2h9fVwiXG4gICAgICAgIHVybC1zcGFjZS1yZWdleD17e3VybFNwYWNlUmVnZXh9fT5cbiAgICA8L2lyb24tbG9jYXRpb24+XG4gIDwvdGVtcGxhdGU+XG4gIDxzY3JpcHQ+XG4gICAgKGZ1bmN0aW9uKCkge1xuICAgICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgICBQb2x5bWVyKHtcbiAgICAgICAgaXM6ICdhcHAtbG9jYXRpb24nLFxuXG4gICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBBIG1vZGVsIHJlcHJlc2VudGluZyB0aGUgZGVzZXJpYWxpemVkIHBhdGggdGhyb3VnaCB0aGUgcm91dGUgdHJlZSwgYXNcbiAgICAgICAgICAgKiB3ZWxsIGFzIHRoZSBjdXJyZW50IHF1ZXJ5UGFyYW1zLlxuICAgICAgICAgICAqL1xuICAgICAgICAgIHJvdXRlOiB7XG4gICAgICAgICAgICB0eXBlOiBPYmplY3QsXG4gICAgICAgICAgICBub3RpZnk6IHRydWVcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogSW4gbWFueSBzY2VuYXJpb3MsIGl0IGlzIGNvbnZlbmllbnQgdG8gdHJlYXQgdGhlIGBoYXNoYCBhcyBhIHN0YW5kLWluXG4gICAgICAgICAgICogYWx0ZXJuYXRpdmUgdG8gdGhlIGBwYXRoYC4gRm9yIGV4YW1wbGUsIGlmIGRlcGxveWluZyBhbiBhcHAgdG8gYSBzdGF0aWNcbiAgICAgICAgICAgKiB3ZWIgc2VydmVyIChlLmcuLCBHaXRodWIgUGFnZXMpIC0gd2hlcmUgb25lIGRvZXMgbm90IGhhdmUgY29udHJvbCBvdmVyXG4gICAgICAgICAgICogc2VydmVyLXNpZGUgcm91dGluZyAtIGl0IGlzIHVzdWFsbHkgYSBiZXR0ZXIgZXhwZXJpZW5jZSB0byB1c2UgdGhlIGhhc2hcbiAgICAgICAgICAgKiB0byByZXByZXNlbnQgcGF0aHMgdGhyb3VnaCBvbmUncyBhcHAuXG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiBXaGVuIHRoaXMgcHJvcGVydHkgaXMgc2V0IHRvIHRydWUsIHRoZSBgaGFzaGAgd2lsbCBiZSB1c2VkIGluIHBsYWNlIG9mXG5cbiAgICAgICAgICAgKiB0aGUgYHBhdGhgIGZvciBnZW5lcmF0aW5nIGEgYHJvdXRlYC5cbiAgICAgICAgICAgKi9cbiAgICAgICAgICB1c2VIYXNoQXNQYXRoOiB7XG4gICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgICAgfSxcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIEEgcmVnZXhwIHRoYXQgZGVmaW5lcyB0aGUgc2V0IG9mIFVSTHMgdGhhdCBzaG91bGQgYmUgY29uc2lkZXJlZCBwYXJ0XG4gICAgICAgICAgICogb2YgdGhpcyB3ZWIgYXBwLlxuICAgICAgICAgICAqXG4gICAgICAgICAgICogQ2xpY2tpbmcgb24gYSBsaW5rIHRoYXQgbWF0Y2hlcyB0aGlzIHJlZ2V4IHdvbid0IHJlc3VsdCBpbiBhIGZ1bGwgcGFnZVxuICAgICAgICAgICAqIG5hdmlnYXRpb24sIGJ1dCB3aWxsIGluc3RlYWQganVzdCB1cGRhdGUgdGhlIFVSTCBzdGF0ZSBpbiBwbGFjZS5cbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIFRoaXMgcmVnZXhwIGlzIGdpdmVuIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIG9yaWdpbiBpbiBhbiBhYnNvbHV0ZVxuICAgICAgICAgICAqIFVSTC4gU28gdG8gbWF0Y2gganVzdCBVUkxzIHRoYXQgc3RhcnQgd2l0aCAvc2VhcmNoLyBkbzpcbiAgICAgICAgICAgKiAgICAgdXJsLXNwYWNlLXJlZ2V4PVwiXi9zZWFyY2gvXCJcbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIEB0eXBlIHtzdHJpbmd8UmVnRXhwfVxuICAgICAgICAgICAqL1xuICAgICAgICAgIHVybFNwYWNlUmVnZXg6IHtcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICAgIG5vdGlmeTogdHJ1ZVxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBBIHNldCBvZiBrZXkvdmFsdWUgcGFpcnMgdGhhdCBhcmUgdW5pdmVyc2FsbHkgYWNjZXNzaWJsZSB0byBicmFuY2hlc1xuICAgICAgICAgICAqIG9mIHRoZSByb3V0ZSB0cmVlLlxuICAgICAgICAgICAqL1xuICAgICAgICAgIF9fcXVlcnlQYXJhbXM6IHtcbiAgICAgICAgICAgIHR5cGU6IE9iamVjdFxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBUaGUgcGF0aG5hbWUgY29tcG9uZW50IG9mIHRoZSBjdXJyZW50IFVSTC5cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBfX3BhdGg6IHtcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZ1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBUaGUgcXVlcnkgc3RyaW5nIHBvcnRpb24gb2YgdGhlIGN1cnJlbnQgVVJMLlxuICAgICAgICAgICAqL1xuICAgICAgICAgIF9fcXVlcnk6IHtcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZ1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBUaGUgaGFzaCBwb3J0aW9uIG9mIHRoZSBjdXJyZW50IFVSTC5cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBfX2hhc2g6IHtcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZ1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBUaGUgcm91dGUgcGF0aCwgd2hpY2ggd2lsbCBiZSBlaXRoZXIgdGhlIGhhc2ggb3IgdGhlIHBhdGgsIGRlcGVuZGluZ1xuICAgICAgICAgICAqIG9uIHVzZUhhc2hBc1BhdGguXG4gICAgICAgICAgICovXG4gICAgICAgICAgcGF0aDoge1xuICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgICAgb2JzZXJ2ZXI6ICdfX29uUGF0aENoYW5nZWQnXG4gICAgICAgICAgfSxcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRoZSByZWFkeSBmdW5jdGlvbiBoYXMgYmVlbiBjYWxsZWQuXG4gICAgICAgICAgICovXG4gICAgICAgICAgX2lzUmVhZHk6IHtcbiAgICAgICAgICAgIHR5cGU6IEJvb2xlYW5cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgYmVoYXZpb3JzOiBbUG9seW1lci5BcHBSb3V0ZUNvbnZlcnRlckJlaGF2aW9yXSxcblxuICAgICAgICBvYnNlcnZlcnM6IFtcbiAgICAgICAgICAnX19jb21wdXRlUm91dGVQYXRoKHVzZUhhc2hBc1BhdGgsIF9faGFzaCwgX19wYXRoKSdcbiAgICAgICAgXSxcblxuICAgICAgICByZWFkeTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdGhpcy5faXNSZWFkeSA9IHRydWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX19jb21wdXRlUm91dGVQYXRoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB0aGlzLnBhdGggPSB0aGlzLnVzZUhhc2hBc1BhdGggPyB0aGlzLl9faGFzaCA6IHRoaXMuX19wYXRoO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9fb25QYXRoQ2hhbmdlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKCF0aGlzLl9pc1JlYWR5KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHRoaXMudXNlSGFzaEFzUGF0aCkge1xuICAgICAgICAgICAgdGhpcy5fX2hhc2ggPSB0aGlzLnBhdGg7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX19wYXRoID0gdGhpcy5wYXRoO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSkoKTtcbiAgPC9zY3JpcHQ+XG48L2RvbS1tb2R1bGU+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL2FwcC1yb3V0ZS9hcHAtbG9jYXRpb24uaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTUgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cblxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3BvbHltZXIvcG9seW1lci5odG1sXCI+XG5cbjwhLS1cblxuVGhlIGBpcm9uLWxvY2F0aW9uYCBlbGVtZW50IG1hbmFnZXMgYmluZGluZyB0byBhbmQgZnJvbSB0aGUgY3VycmVudCBVUkwuXG5cbmlyb24tbG9jYXRpb24gaXMgdGhlIGZpcnN0LCBhbmQgbG93ZXN0IGxldmVsIGVsZW1lbnQgaW4gdGhlIFBvbHltZXIgdGVhbSdzXG5yb3V0aW5nIHN5c3RlbS4gVGhpcyBpcyBhIGJldGEgcmVsZWFzZSBvZiBpcm9uLWxvY2F0aW9uIGFzIHdlIGNvbnRpbnVlIHdvcmtcbm9uIGhpZ2hlciBsZXZlbCBlbGVtZW50cywgYW5kIGFzIHN1Y2ggaXJvbi1sb2NhdGlvbiBtYXkgdW5kZXJnbyBicmVha2luZ1xuY2hhbmdlcy5cblxuIyMjIyBQcm9wZXJ0aWVzXG5cbldoZW4gdGhlIFVSTCBpczogYC9zZWFyY2g/cXVlcnk9NTgzI2RldGFpbHNgIGlyb24tbG9jYXRpb24ncyBwcm9wZXJ0aWVzIHdpbGwgYmU6XG5cbiAgLSBwYXRoOiBgJy9zZWFyY2gnYFxuICAtIHF1ZXJ5OiBgJ3F1ZXJ5PTU4MydgXG4gIC0gaGFzaDogYCdkZXRhaWxzJ2BcblxuVGhlc2UgYmluZGluZ3MgYXJlIGJpZGlyZWN0aW9uYWwuIE1vZGlmeWluZyB0aGVtIHdpbGwgaW4gdHVybiBtb2RpZnkgdGhlIFVSTC5cblxuaXJvbi1sb2NhdGlvbiBpcyBvbmx5IGFjdGl2ZSB3aGlsZSBpdCBpcyBhdHRhY2hlZCB0byB0aGUgZG9jdW1lbnQuXG5cbiMjIyMgTGlua3NcblxuV2hpbGUgaXJvbi1sb2NhdGlvbiBpcyBhY3RpdmUgaW4gdGhlIGRvY3VtZW50IGl0IHdpbGwgaW50ZXJjZXB0IGNsaWNrcyBvbiBsaW5rc1xud2l0aGluIHlvdXIgc2l0ZSwgdXBkYXRpbmcgdGhlIFVSTCBwdXNoaW5nIHRoZSB1cGRhdGVkIFVSTCBvdXQgdGhyb3VnaCB0aGVcbmRhdGFiaW5kaW5nIHN5c3RlbS4gaXJvbi1sb2NhdGlvbiBvbmx5IGludGVyY2VwdHMgY2xpY2tzIHdpdGggdGhlIGludGVudCB0b1xub3BlbiBpbiB0aGUgc2FtZSB3aW5kb3csIHNvIG1pZGRsZSBtb3VzZSBjbGlja3MgYW5kIGN0cmwvY21kIGNsaWNrcyB3b3JrIGZpbmUuXG5cbllvdSBjYW4gY3VzdG9taXplIHRoaXMgYmVoYXZpb3Igd2l0aCB0aGUgYHVybFNwYWNlUmVnZXhgLlxuXG4jIyMjIER3ZWxsIFRpbWVcblxuaXJvbi1sb2NhdGlvbiBwcm90ZWN0cyBhZ2FpbnN0IGFjY2lkZW50YWwgaGlzdG9yeSBzcGFtbWluZyBieSBvbmx5IGFkZGluZ1xuZW50cmllcyB0byB0aGUgdXNlcidzIGhpc3RvcnkgaWYgdGhlIFVSTCBzdGF5cyB1bmNoYW5nZWQgZm9yIGBkd2VsbFRpbWVgXG5taWxsaXNlY29uZHMuXG5cbkBkZW1vIGRlbW8vaW5kZXguaHRtbFxuXG4gLS0+XG48c2NyaXB0PlxuICAoZnVuY3Rpb24oKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIHdvcmtpbmdVUkw7XG5cbiAgICB2YXIgdXJsRG9jLCB1cmxCYXNlLCBhbmNob3I7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aFxuICAgICAqIEBwYXJhbSB7c3RyaW5nPX0gYmFzZVxuICAgICAqIEByZXR1cm4geyFVUkx8IUhUTUxBbmNob3JFbGVtZW50fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlc29sdmVVUkwocGF0aCwgYmFzZSkge1xuICAgICAgaWYgKHdvcmtpbmdVUkwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB3b3JraW5nVVJMID0gZmFsc2U7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIHUgPSBuZXcgVVJMKCdiJywgJ2h0dHA6Ly9hJyk7XG4gICAgICAgICAgdS5wYXRobmFtZSA9ICdjJTIwZCc7XG4gICAgICAgICAgd29ya2luZ1VSTCA9ICh1LmhyZWYgPT09ICdodHRwOi8vYS9jJTIwZCcpO1xuICAgICAgICAgIHdvcmtpbmdVUkwgPSB3b3JraW5nVVJMICYmIChuZXcgVVJMKCdodHRwOi8vd3d3Lmdvb2dsZS5jb20vP2ZvbyBiYXInKS5ocmVmID09PSAnaHR0cDovL3d3dy5nb29nbGUuY29tLz9mb28lMjBiYXInKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgIH1cbiAgICAgIGlmICh3b3JraW5nVVJMKSB7XG4gICAgICAgIHJldHVybiBuZXcgVVJMKHBhdGgsIGJhc2UpO1xuICAgICAgfVxuICAgICAgaWYgKCF1cmxEb2MpIHtcbiAgICAgICAgdXJsRG9jID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KCd1cmwnKTtcbiAgICAgICAgdXJsQmFzZSA9IHVybERvYy5jcmVhdGVFbGVtZW50KCdiYXNlJyk7XG4gICAgICAgIHVybERvYy5oZWFkLmFwcGVuZENoaWxkKHVybEJhc2UpO1xuICAgICAgICBhbmNob3IgPSAvKiogQHR5cGUge0hUTUxBbmNob3JFbGVtZW50fSovKHVybERvYy5jcmVhdGVFbGVtZW50KCdhJykpO1xuICAgICAgfVxuICAgICAgdXJsQmFzZS5ocmVmID0gYmFzZTtcbiAgICAgIGFuY2hvci5ocmVmID0gcGF0aC5yZXBsYWNlKC8gL2csICclMjAnKTtcbiAgICAgIHJldHVybiBhbmNob3I7XG4gICAgfVxuXG4gICAgUG9seW1lcih7XG4gICAgICBpczogJ2lyb24tbG9jYXRpb24nLFxuXG4gICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgcGF0aG5hbWUgY29tcG9uZW50IG9mIHRoZSBVUkwuXG4gICAgICAgICAqL1xuICAgICAgICBwYXRoOiB7XG4gICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgIG5vdGlmeTogdHJ1ZSxcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gd2luZG93LmRlY29kZVVSSUNvbXBvbmVudCh3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHF1ZXJ5IHN0cmluZyBwb3J0aW9uIG9mIHRoZSBVUkwuXG4gICAgICAgICAqL1xuICAgICAgICBxdWVyeToge1xuICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICBub3RpZnk6IHRydWUsXG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5sb2NhdGlvbi5zZWFyY2guc2xpY2UoMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgaGFzaCBjb21wb25lbnQgb2YgdGhlIFVSTC5cbiAgICAgICAgICovXG4gICAgICAgIGhhc2g6IHtcbiAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgbm90aWZ5OiB0cnVlLFxuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB3aW5kb3cuZGVjb2RlVVJJQ29tcG9uZW50KHdpbmRvdy5sb2NhdGlvbi5oYXNoLnNsaWNlKDEpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHRoZSB1c2VyIHdhcyBvbiBhIFVSTCBmb3IgbGVzcyB0aGFuIGBkd2VsbFRpbWVgIG1pbGxpc2Vjb25kcywgaXRcbiAgICAgICAgICogd29uJ3QgYmUgYWRkZWQgdG8gdGhlIGJyb3dzZXIncyBoaXN0b3J5LCBidXQgaW5zdGVhZCB3aWxsIGJlIHJlcGxhY2VkXG4gICAgICAgICAqIGJ5IHRoZSBuZXh0IGVudHJ5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIGlzIHRvIHByZXZlbnQgbGFyZ2UgbnVtYmVycyBvZiBlbnRyaWVzIGZyb20gY2xvZ2dpbmcgdXAgdGhlIHVzZXInc1xuICAgICAgICAgKiBicm93c2VyIGhpc3RvcnkuIERpc2FibGUgYnkgc2V0dGluZyB0byBhIG5lZ2F0aXZlIG51bWJlci5cbiAgICAgICAgICovXG4gICAgICAgIGR3ZWxsVGltZToge1xuICAgICAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgICAgICB2YWx1ZTogMjAwMFxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHJlZ2V4cCB0aGF0IGRlZmluZXMgdGhlIHNldCBvZiBVUkxzIHRoYXQgc2hvdWxkIGJlIGNvbnNpZGVyZWQgcGFydFxuICAgICAgICAgKiBvZiB0aGlzIHdlYiBhcHAuXG4gICAgICAgICAqXG4gICAgICAgICAqIENsaWNraW5nIG9uIGEgbGluayB0aGF0IG1hdGNoZXMgdGhpcyByZWdleCB3b24ndCByZXN1bHQgaW4gYSBmdWxsIHBhZ2VcbiAgICAgICAgICogbmF2aWdhdGlvbiwgYnV0IHdpbGwgaW5zdGVhZCBqdXN0IHVwZGF0ZSB0aGUgVVJMIHN0YXRlIGluIHBsYWNlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIHJlZ2V4cCBpcyBnaXZlbiBldmVyeXRoaW5nIGFmdGVyIHRoZSBvcmlnaW4gaW4gYW4gYWJzb2x1dGVcbiAgICAgICAgICogVVJMLiBTbyB0byBtYXRjaCBqdXN0IFVSTHMgdGhhdCBzdGFydCB3aXRoIC9zZWFyY2gvIGRvOlxuICAgICAgICAgKiAgICAgdXJsLXNwYWNlLXJlZ2V4PVwiXi9zZWFyY2gvXCJcbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUge3N0cmluZ3xSZWdFeHB9XG4gICAgICAgICAqL1xuICAgICAgICB1cmxTcGFjZVJlZ2V4OiB7XG4gICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgIHZhbHVlOiAnJ1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiB1cmxTcGFjZVJlZ2V4LCBidXQgY29lcmNlZCBpbnRvIGEgcmVnZXhwLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7UmVnRXhwfVxuICAgICAgICAgKi9cbiAgICAgICAgX3VybFNwYWNlUmVnRXhwOiB7XG4gICAgICAgICAgY29tcHV0ZWQ6ICdfbWFrZVJlZ0V4cCh1cmxTcGFjZVJlZ2V4KSdcbiAgICAgICAgfSxcblxuICAgICAgICBfbGFzdENoYW5nZWRBdDoge1xuICAgICAgICAgIHR5cGU6IE51bWJlclxuICAgICAgICB9LFxuXG4gICAgICAgIF9pbml0aWFsaXplZDoge1xuICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIGhvc3RBdHRyaWJ1dGVzOiB7XG4gICAgICAgIGhpZGRlbjogdHJ1ZVxuICAgICAgfSxcblxuICAgICAgb2JzZXJ2ZXJzOiBbXG4gICAgICAgICdfdXBkYXRlVXJsKHBhdGgsIHF1ZXJ5LCBoYXNoKSdcbiAgICAgIF0sXG5cbiAgICAgIGF0dGFjaGVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5saXN0ZW4od2luZG93LCAnaGFzaGNoYW5nZScsICdfaGFzaENoYW5nZWQnKTtcbiAgICAgICAgdGhpcy5saXN0ZW4od2luZG93LCAnbG9jYXRpb24tY2hhbmdlZCcsICdfdXJsQ2hhbmdlZCcpO1xuICAgICAgICB0aGlzLmxpc3Rlbih3aW5kb3csICdwb3BzdGF0ZScsICdfdXJsQ2hhbmdlZCcpO1xuICAgICAgICB0aGlzLmxpc3RlbigvKiogQHR5cGUgeyFIVE1MQm9keUVsZW1lbnR9ICovKGRvY3VtZW50LmJvZHkpLCAnY2xpY2snLCAnX2dsb2JhbE9uQ2xpY2snKTtcbiAgICAgICAgLy8gR2l2ZSBhIDIwMG1zIGdyYWNlIHBlcmlvZCB0byBtYWtlIGluaXRpYWwgcmVkaXJlY3RzIHdpdGhvdXQgYW55XG4gICAgICAgIC8vIGFkZGl0aW9ucyB0byB0aGUgdXNlcidzIGhpc3RvcnkuXG4gICAgICAgIHRoaXMuX2xhc3RDaGFuZ2VkQXQgPSB3aW5kb3cucGVyZm9ybWFuY2Uubm93KCkgLSAodGhpcy5kd2VsbFRpbWUgLSAyMDApO1xuICAgICAgICB0aGlzLl9pbml0aWFsaXplZCA9IHRydWU7XG5cbiAgICAgICAgdGhpcy5fdXJsQ2hhbmdlZCgpO1xuICAgICAgfSxcblxuICAgICAgZGV0YWNoZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnVubGlzdGVuKHdpbmRvdywgJ2hhc2hjaGFuZ2UnLCAnX2hhc2hDaGFuZ2VkJyk7XG4gICAgICAgIHRoaXMudW5saXN0ZW4od2luZG93LCAnbG9jYXRpb24tY2hhbmdlZCcsICdfdXJsQ2hhbmdlZCcpO1xuICAgICAgICB0aGlzLnVubGlzdGVuKHdpbmRvdywgJ3BvcHN0YXRlJywgJ191cmxDaGFuZ2VkJyk7XG4gICAgICAgIHRoaXMudW5saXN0ZW4oLyoqIEB0eXBlIHshSFRNTEJvZHlFbGVtZW50fSAqLyhkb2N1bWVudC5ib2R5KSwgJ2NsaWNrJywgJ19nbG9iYWxPbkNsaWNrJyk7XG4gICAgICAgIHRoaXMuX2luaXRpYWxpemVkID0gZmFsc2U7XG4gICAgICB9LFxuXG4gICAgICBfaGFzaENoYW5nZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmhhc2ggPSB3aW5kb3cuZGVjb2RlVVJJQ29tcG9uZW50KHdpbmRvdy5sb2NhdGlvbi5oYXNoLnN1YnN0cmluZygxKSk7XG4gICAgICB9LFxuXG4gICAgICBfdXJsQ2hhbmdlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIFdlIHdhbnQgdG8gZXh0cmFjdCBhbGwgaW5mbyBvdXQgb2YgdGhlIHVwZGF0ZWQgVVJMIGJlZm9yZSB3ZVxuICAgICAgICAvLyB0cnkgdG8gd3JpdGUgYW55dGhpbmcgYmFjayBpbnRvIGl0LlxuICAgICAgICAvL1xuICAgICAgICAvLyBpLmUuIHdpdGhvdXQgX2RvbnRVcGRhdGVVcmwgd2UnZCBvdmVyd3JpdGUgdGhlIG5ldyBwYXRoIHdpdGggdGhlIG9sZFxuICAgICAgICAvLyBvbmUgd2hlbiB3ZSBzZXQgdGhpcy5oYXNoLiBMaWtld2lzZSBmb3IgcXVlcnkuXG4gICAgICAgIHRoaXMuX2RvbnRVcGRhdGVVcmwgPSB0cnVlO1xuICAgICAgICB0aGlzLl9oYXNoQ2hhbmdlZCgpO1xuICAgICAgICB0aGlzLnBhdGggPSB3aW5kb3cuZGVjb2RlVVJJQ29tcG9uZW50KHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSk7XG4gICAgICAgIHRoaXMucXVlcnkgPSB3aW5kb3cubG9jYXRpb24uc2VhcmNoLnN1YnN0cmluZygxKTtcbiAgICAgICAgdGhpcy5fZG9udFVwZGF0ZVVybCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl91cGRhdGVVcmwoKTtcbiAgICAgIH0sXG5cbiAgICAgIF9nZXRVcmw6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcGFydGlhbGx5RW5jb2RlZFBhdGggPSB3aW5kb3cuZW5jb2RlVVJJKFxuICAgICAgICAgICAgdGhpcy5wYXRoKS5yZXBsYWNlKC9cXCMvZywgJyUyMycpLnJlcGxhY2UoL1xcPy9nLCAnJTNGJyk7XG4gICAgICAgIHZhciBwYXJ0aWFsbHlFbmNvZGVkUXVlcnkgPSAnJztcbiAgICAgICAgaWYgKHRoaXMucXVlcnkpIHtcbiAgICAgICAgICBwYXJ0aWFsbHlFbmNvZGVkUXVlcnkgPSAnPycgKyB0aGlzLnF1ZXJ5LnJlcGxhY2UoL1xcIy9nLCAnJTIzJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBhcnRpYWxseUVuY29kZWRIYXNoID0gJyc7XG4gICAgICAgIGlmICh0aGlzLmhhc2gpIHtcbiAgICAgICAgICBwYXJ0aWFsbHlFbmNvZGVkSGFzaCA9ICcjJyArIHdpbmRvdy5lbmNvZGVVUkkodGhpcy5oYXNoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgcGFydGlhbGx5RW5jb2RlZFBhdGggKyBwYXJ0aWFsbHlFbmNvZGVkUXVlcnkgKyBwYXJ0aWFsbHlFbmNvZGVkSGFzaCk7XG4gICAgICB9LFxuXG4gICAgICBfdXBkYXRlVXJsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RvbnRVcGRhdGVVcmwgfHwgIXRoaXMuX2luaXRpYWxpemVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMucGF0aCA9PT0gd2luZG93LmRlY29kZVVSSUNvbXBvbmVudCh3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUpICYmXG4gICAgICAgICAgICB0aGlzLnF1ZXJ5ID09PSB3aW5kb3cubG9jYXRpb24uc2VhcmNoLnN1YnN0cmluZygxKSAmJlxuICAgICAgICAgICAgdGhpcy5oYXNoID09PSB3aW5kb3cuZGVjb2RlVVJJQ29tcG9uZW50KFxuICAgICAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5oYXNoLnN1YnN0cmluZygxKSkpIHtcbiAgICAgICAgICAvLyBOb3RoaW5nIHRvIGRvLCB0aGUgY3VycmVudCBVUkwgaXMgYSByZXByZXNlbnRhdGlvbiBvZiBvdXIgcHJvcGVydGllcy5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbmV3VXJsID0gdGhpcy5fZ2V0VXJsKCk7XG4gICAgICAgIC8vIE5lZWQgdG8gdXNlIGEgZnVsbCBVUkwgaW4gY2FzZSB0aGUgY29udGFpbmluZyBwYWdlIGhhcyBhIGJhc2UgVVJJLlxuICAgICAgICB2YXIgZnVsbE5ld1VybCA9IHJlc29sdmVVUkwobmV3VXJsLCB3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wgKyAnLy8nICsgd2luZG93LmxvY2F0aW9uLmhvc3QpLmhyZWY7XG4gICAgICAgIHZhciBub3cgPSB3aW5kb3cucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIHZhciBzaG91bGRSZXBsYWNlID0gdGhpcy5fbGFzdENoYW5nZWRBdCArIHRoaXMuZHdlbGxUaW1lID4gbm93O1xuICAgICAgICB0aGlzLl9sYXN0Q2hhbmdlZEF0ID0gbm93O1xuXG4gICAgICAgIGlmIChzaG91bGRSZXBsYWNlKSB7XG4gICAgICAgICAgd2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlKHt9LCAnJywgZnVsbE5ld1VybCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2luZG93Lmhpc3RvcnkucHVzaFN0YXRlKHt9LCAnJywgZnVsbE5ld1VybCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmZpcmUoJ2xvY2F0aW9uLWNoYW5nZWQnLCB7fSwge25vZGU6IHdpbmRvd30pO1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBBIG5lY2Vzc2FyeSBldmlsIHNvIHRoYXQgbGlua3Mgd29yayBhcyBleHBlY3RlZC4gRG9lcyBpdHMgYmVzdCB0b1xuICAgICAgICogYmFpbCBvdXQgZWFybHkgaWYgcG9zc2libGUuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBldmVudCAuXG4gICAgICAgKi9cbiAgICAgIF9nbG9iYWxPbkNsaWNrOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAvLyBJZiBhbm90aGVyIGV2ZW50IGhhbmRsZXIgaGFzIHN0b3BwZWQgdGhpcyBldmVudCB0aGVuIHRoZXJlJ3Mgbm90aGluZ1xuICAgICAgICAvLyBmb3IgdXMgdG8gZG8uIFRoaXMgY2FuIGhhcHBlbiBlLmcuIHdoZW4gdGhlcmUgYXJlIG11bHRpcGxlXG4gICAgICAgIC8vIGlyb24tbG9jYXRpb24gZWxlbWVudHMgaW4gYSBwYWdlLlxuICAgICAgICBpZiAoZXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBocmVmID0gdGhpcy5fZ2V0U2FtZU9yaWdpbkxpbmtIcmVmKGV2ZW50KTtcblxuICAgICAgICBpZiAoIWhyZWYpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIC8vIElmIHRoZSBuYXZpZ2F0aW9uIGlzIHRvIHRoZSBjdXJyZW50IHBhZ2Ugd2Ugc2hvdWxkbid0IGFkZCBhIGhpc3RvcnlcbiAgICAgICAgLy8gZW50cnkgb3IgZmlyZSBhIGNoYW5nZSBldmVudC5cbiAgICAgICAgaWYgKGhyZWYgPT09IHdpbmRvdy5sb2NhdGlvbi5ocmVmKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgd2luZG93Lmhpc3RvcnkucHVzaFN0YXRlKHt9LCAnJywgaHJlZik7XG4gICAgICAgIHRoaXMuZmlyZSgnbG9jYXRpb24tY2hhbmdlZCcsIHt9LCB7bm9kZTogd2luZG93fSk7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFJldHVybnMgdGhlIGFic29sdXRlIFVSTCBvZiB0aGUgbGluayAoaWYgYW55KSB0aGF0IHRoaXMgY2xpY2sgZXZlbnRcbiAgICAgICAqIGlzIGNsaWNraW5nIG9uLCBpZiB3ZSBjYW4gYW5kIHNob3VsZCBvdmVycmlkZSB0aGUgcmVzdWx0aW5nIGZ1bGxcbiAgICAgICAqIHBhZ2UgbmF2aWdhdGlvbi4gUmV0dXJucyBudWxsIG90aGVyd2lzZS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGV2ZW50IC5cbiAgICAgICAqIEByZXR1cm4ge3N0cmluZz99IC5cbiAgICAgICAqL1xuICAgICAgX2dldFNhbWVPcmlnaW5MaW5rSHJlZjogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgLy8gV2Ugb25seSBjYXJlIGFib3V0IGxlZnQtY2xpY2tzLlxuICAgICAgICBpZiAoZXZlbnQuYnV0dG9uICE9PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBXZSBkb24ndCB3YW50IG1vZGlmaWVkIGNsaWNrcywgd2hlcmUgdGhlIGludGVudCBpcyB0byBvcGVuIHRoZSBwYWdlXG4gICAgICAgIC8vIGluIGEgbmV3IHRhYi5cbiAgICAgICAgaWYgKGV2ZW50Lm1ldGFLZXkgfHwgZXZlbnQuY3RybEtleSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGV2ZW50UGF0aCA9IFBvbHltZXIuZG9tKGV2ZW50KS5wYXRoO1xuICAgICAgICB2YXIgYW5jaG9yID0gbnVsbDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV2ZW50UGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBlbGVtZW50ID0gZXZlbnRQYXRoW2ldO1xuXG4gICAgICAgICAgaWYgKGVsZW1lbnQudGFnTmFtZSA9PT0gJ0EnICYmIGVsZW1lbnQuaHJlZikge1xuICAgICAgICAgICAgYW5jaG9yID0gZWxlbWVudDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHRoZXJlJ3Mgbm8gbGluayB0aGVyZSdzIG5vdGhpbmcgdG8gZG8uXG4gICAgICAgIGlmICghYW5jaG9yKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUYXJnZXQgYmxhbmsgaXMgYSBuZXcgdGFiLCBkb24ndCBpbnRlcmNlcHQuXG4gICAgICAgIGlmIChhbmNob3IudGFyZ2V0ID09PSAnX2JsYW5rJykge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgdGhlIGxpbmsgaXMgZm9yIGFuIGV4aXN0aW5nIHBhcmVudCBmcmFtZSwgZG9uJ3QgaW50ZXJjZXB0LlxuICAgICAgICBpZiAoKGFuY2hvci50YXJnZXQgPT09ICdfdG9wJyB8fFxuICAgICAgICAgICAgYW5jaG9yLnRhcmdldCA9PT0gJ19wYXJlbnQnKSAmJlxuICAgICAgICAgICAgd2luZG93LnRvcCAhPT0gd2luZG93KSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaHJlZiA9IGFuY2hvci5ocmVmO1xuXG4gICAgICAgIC8vIEl0IG9ubHkgbWFrZXMgc2Vuc2UgZm9yIHVzIHRvIGludGVyY2VwdCBzYW1lLW9yaWdpbiBuYXZpZ2F0aW9ucy5cbiAgICAgICAgLy8gcHVzaFN0YXRlL3JlcGxhY2VTdGF0ZSBkb24ndCB3b3JrIHdpdGggY3Jvc3Mtb3JpZ2luIGxpbmtzLlxuICAgICAgICB2YXIgdXJsO1xuXG4gICAgICAgIGlmIChkb2N1bWVudC5iYXNlVVJJICE9IG51bGwpIHtcbiAgICAgICAgICB1cmwgPSByZXNvbHZlVVJMKGhyZWYsIC8qKiBAdHlwZSB7c3RyaW5nfSAqLyhkb2N1bWVudC5iYXNlVVJJKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdXJsID0gcmVzb2x2ZVVSTChocmVmKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBvcmlnaW47XG5cbiAgICAgICAgLy8gSUUgUG9seWZpbGxcbiAgICAgICAgaWYgKHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4pIHtcbiAgICAgICAgICBvcmlnaW4gPSB3aW5kb3cubG9jYXRpb24ub3JpZ2luO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9yaWdpbiA9IHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCArICcvLycgKyB3aW5kb3cubG9jYXRpb24uaG9zdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB1cmxPcmlnaW47XG5cbiAgICAgICAgaWYgKHVybC5vcmlnaW4pIHtcbiAgICAgICAgICB1cmxPcmlnaW4gPSB1cmwub3JpZ2luO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHVybE9yaWdpbiA9IHVybC5wcm90b2NvbCArICcvLycgKyB1cmwuaG9zdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh1cmxPcmlnaW4gIT09IG9yaWdpbikge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5vcm1hbGl6ZWRIcmVmID0gdXJsLnBhdGhuYW1lICsgdXJsLnNlYXJjaCArIHVybC5oYXNoO1xuXG4gICAgICAgIC8vIHBhdGhuYW1lIHNob3VsZCBzdGFydCB3aXRoICcvJywgYnV0IG1heSBub3QgaWYgYG5ldyBVUkxgIGlzIG5vdCBzdXBwb3J0ZWRcbiAgICAgICAgaWYgKG5vcm1hbGl6ZWRIcmVmWzBdICE9PSAnLycpIHtcbiAgICAgICAgICBub3JtYWxpemVkSHJlZiA9ICcvJyArIG5vcm1hbGl6ZWRIcmVmO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgd2UndmUgYmVlbiBjb25maWd1cmVkIG5vdCB0byBoYW5kbGUgdGhpcyB1cmwuLi4gZG9uJ3QgaGFuZGxlIGl0IVxuICAgICAgICBpZiAodGhpcy5fdXJsU3BhY2VSZWdFeHAgJiZcbiAgICAgICAgICAgICF0aGlzLl91cmxTcGFjZVJlZ0V4cC50ZXN0KG5vcm1hbGl6ZWRIcmVmKSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTmVlZCB0byB1c2UgYSBmdWxsIFVSTCBpbiBjYXNlIHRoZSBjb250YWluaW5nIHBhZ2UgaGFzIGEgYmFzZSBVUkkuXG4gICAgICAgIHZhciBmdWxsTm9ybWFsaXplZEhyZWYgPSByZXNvbHZlVVJMKFxuICAgICAgICAgICAgbm9ybWFsaXplZEhyZWYsIHdpbmRvdy5sb2NhdGlvbi5ocmVmKS5ocmVmO1xuICAgICAgICByZXR1cm4gZnVsbE5vcm1hbGl6ZWRIcmVmO1xuICAgICAgfSxcblxuICAgICAgX21ha2VSZWdFeHA6IGZ1bmN0aW9uKHVybFNwYWNlUmVnZXgpIHtcbiAgICAgICAgcmV0dXJuIFJlZ0V4cCh1cmxTcGFjZVJlZ2V4KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSkoKTtcbjwvc2NyaXB0PlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9pcm9uLWxvY2F0aW9uL2lyb24tbG9jYXRpb24uaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTUgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG5cbkBkZW1vIGRlbW8vaXJvbi1xdWVyeS1wYXJhbXMuaHRtbFxuLS0+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vcG9seW1lci9wb2x5bWVyLmh0bWxcIj5cblxuPHNjcmlwdD5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIFBvbHltZXIoe1xuICAgIGlzOiAnaXJvbi1xdWVyeS1wYXJhbXMnLFxuXG4gICAgcHJvcGVydGllczoge1xuICAgICAgcGFyYW1zU3RyaW5nOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgbm90aWZ5OiB0cnVlLFxuICAgICAgICBvYnNlcnZlcjogJ3BhcmFtc1N0cmluZ0NoYW5nZWQnLFxuICAgICAgfSxcblxuICAgICAgcGFyYW1zT2JqZWN0OiB7XG4gICAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgICAgbm90aWZ5OiB0cnVlLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBfZG9udFJlYWN0OiB7XG4gICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBob3N0QXR0cmlidXRlczoge1xuICAgICAgaGlkZGVuOiB0cnVlXG4gICAgfSxcblxuICAgIG9ic2VydmVyczogW1xuICAgICAgJ3BhcmFtc09iamVjdENoYW5nZWQocGFyYW1zT2JqZWN0LiopJ1xuICAgIF0sXG5cbiAgICBwYXJhbXNTdHJpbmdDaGFuZ2VkOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX2RvbnRSZWFjdCA9IHRydWU7XG4gICAgICB0aGlzLnBhcmFtc09iamVjdCA9IHRoaXMuX2RlY29kZVBhcmFtcyh0aGlzLnBhcmFtc1N0cmluZyk7XG4gICAgICB0aGlzLl9kb250UmVhY3QgPSBmYWxzZTtcbiAgICB9LFxuXG4gICAgcGFyYW1zT2JqZWN0Q2hhbmdlZDogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5fZG9udFJlYWN0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMucGFyYW1zU3RyaW5nID0gdGhpcy5fZW5jb2RlUGFyYW1zKHRoaXMucGFyYW1zT2JqZWN0KVxuICAgICAgICAgIC5yZXBsYWNlKC8lM0YvZywgJz8nKS5yZXBsYWNlKC8lMkYvZywgJy8nKS5yZXBsYWNlKC8nL2csICclMjcnKTtcbiAgICB9LFxuXG4gICAgX2VuY29kZVBhcmFtczogZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICB2YXIgZW5jb2RlZFBhcmFtcyA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHBhcmFtc1trZXldO1xuXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gJycpIHtcbiAgICAgICAgICBlbmNvZGVkUGFyYW1zLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KGtleSkpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUpIHtcbiAgICAgICAgICBlbmNvZGVkUGFyYW1zLnB1c2goXG4gICAgICAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChrZXkpICtcbiAgICAgICAgICAgICAgJz0nICtcbiAgICAgICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlLnRvU3RyaW5nKCkpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGVuY29kZWRQYXJhbXMuam9pbignJicpO1xuICAgIH0sXG5cbiAgICBfZGVjb2RlUGFyYW1zOiBmdW5jdGlvbihwYXJhbVN0cmluZykge1xuICAgICAgdmFyIHBhcmFtcyA9IHt9O1xuICAgICAgLy8gV29yayBhcm91bmQgYSBidWcgaW4gZGVjb2RlVVJJQ29tcG9uZW50IHdoZXJlICsgaXMgbm90XG4gICAgICAvLyBjb252ZXJ0ZWQgdG8gc3BhY2VzOlxuICAgICAgcGFyYW1TdHJpbmcgPSAocGFyYW1TdHJpbmcgfHwgJycpLnJlcGxhY2UoL1xcKy9nLCAnJTIwJyk7XG4gICAgICB2YXIgcGFyYW1MaXN0ID0gcGFyYW1TdHJpbmcuc3BsaXQoJyYnKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyYW1MaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwYXJhbSA9IHBhcmFtTGlzdFtpXS5zcGxpdCgnPScpO1xuICAgICAgICBpZiAocGFyYW1bMF0pIHtcbiAgICAgICAgICBwYXJhbXNbZGVjb2RlVVJJQ29tcG9uZW50KHBhcmFtWzBdKV0gPVxuICAgICAgICAgICAgICBkZWNvZGVVUklDb21wb25lbnQocGFyYW1bMV0gfHwgJycpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFyYW1zO1xuICAgIH1cbiAgfSk7XG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvaXJvbi1sb2NhdGlvbi9pcm9uLXF1ZXJ5LXBhcmFtcy5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNiBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuPHNjcmlwdD5cbiAgKGZ1bmN0aW9uKCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIC8qKlxuICAgICAqIFByb3ZpZGVzIGJpZGlyZWN0aW9uYWwgbWFwcGluZyBiZXR3ZWVuIGBwYXRoYCBhbmQgYHF1ZXJ5UGFyYW1zYCBhbmQgYVxuICAgICAqIGFwcC1yb3V0ZSBjb21wYXRpYmxlIGByb3V0ZWAgb2JqZWN0LlxuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZSB0aGUgZG9jcyBmb3IgYGFwcC1yb3V0ZS1jb252ZXJ0ZXJgLlxuICAgICAqXG4gICAgICogQHBvbHltZXJCZWhhdmlvclxuICAgICAqL1xuICAgIFBvbHltZXIuQXBwUm91dGVDb252ZXJ0ZXJCZWhhdmlvciA9IHtcbiAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgbW9kZWwgcmVwcmVzZW50aW5nIHRoZSBkZXNlcmlhbGl6ZWQgcGF0aCB0aHJvdWdoIHRoZSByb3V0ZSB0cmVlLCBhc1xuICAgICAgICAgKiB3ZWxsIGFzIHRoZSBjdXJyZW50IHF1ZXJ5UGFyYW1zLlxuICAgICAgICAgKlxuICAgICAgICAgKiBBIHJvdXRlIG9iamVjdCBpcyB0aGUga2VybmVsIG9mIHRoZSByb3V0aW5nIHN5c3RlbS4gSXQgaXMgaW50ZW5kZWQgdG9cbiAgICAgICAgICogYmUgZmVkIGludG8gY29uc3VtaW5nIGVsZW1lbnRzIHN1Y2ggYXMgYGFwcC1yb3V0ZWAuXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHs/T2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgcm91dGU6IHtcbiAgICAgICAgICB0eXBlOiBPYmplY3QsXG4gICAgICAgICAgbm90aWZ5OiB0cnVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgc2V0IG9mIGtleS92YWx1ZSBwYWlycyB0aGF0IGFyZSB1bml2ZXJzYWxseSBhY2Nlc3NpYmxlIHRvIGJyYW5jaGVzIG9mXG4gICAgICAgICAqIHRoZSByb3V0ZSB0cmVlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7P09iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIHF1ZXJ5UGFyYW1zOiB7XG4gICAgICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgICAgIG5vdGlmeTogdHJ1ZVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgc2VyaWFsaXplZCBwYXRoIHRocm91Z2ggdGhlIHJvdXRlIHRyZWUuIFRoaXMgY29ycmVzcG9uZHMgdG8gdGhlXG4gICAgICAgICAqIGB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWVgIHZhbHVlLCBhbmQgd2lsbCB1cGRhdGUgdG8gcmVmbGVjdCBjaGFuZ2VzXG4gICAgICAgICAqIHRvIHRoYXQgdmFsdWUuXG4gICAgICAgICAqL1xuICAgICAgICBwYXRoOiB7XG4gICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgIG5vdGlmeTogdHJ1ZSxcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgb2JzZXJ2ZXJzOiBbXG4gICAgICAgICdfbG9jYXRpb25DaGFuZ2VkKHBhdGgsIHF1ZXJ5UGFyYW1zKScsXG4gICAgICAgICdfcm91dGVDaGFuZ2VkKHJvdXRlLnByZWZpeCwgcm91dGUucGF0aCknLFxuICAgICAgICAnX3JvdXRlUXVlcnlQYXJhbXNDaGFuZ2VkKHJvdXRlLl9fcXVlcnlQYXJhbXMpJ1xuICAgICAgXSxcblxuICAgICAgY3JlYXRlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMubGlua1BhdGhzKCdyb3V0ZS5fX3F1ZXJ5UGFyYW1zJywgJ3F1ZXJ5UGFyYW1zJyk7XG4gICAgICAgIHRoaXMubGlua1BhdGhzKCdxdWVyeVBhcmFtcycsICdyb3V0ZS5fX3F1ZXJ5UGFyYW1zJyk7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIEhhbmRsZXIgY2FsbGVkIHdoZW4gdGhlIHBhdGggb3IgcXVlcnlQYXJhbXMgY2hhbmdlLlxuICAgICAgICovXG4gICAgICBfbG9jYXRpb25DaGFuZ2VkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMucm91dGUgJiZcbiAgICAgICAgICAgIHRoaXMucm91dGUucGF0aCA9PT0gdGhpcy5wYXRoICYmXG4gICAgICAgICAgICB0aGlzLnF1ZXJ5UGFyYW1zID09PSB0aGlzLnJvdXRlLl9fcXVlcnlQYXJhbXMpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yb3V0ZSA9IHtcbiAgICAgICAgICBwcmVmaXg6ICcnLFxuICAgICAgICAgIHBhdGg6IHRoaXMucGF0aCxcbiAgICAgICAgICBfX3F1ZXJ5UGFyYW1zOiB0aGlzLnF1ZXJ5UGFyYW1zXG4gICAgICAgIH07XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIEhhbmRsZXIgY2FsbGVkIHdoZW4gdGhlIHJvdXRlIHByZWZpeCBhbmQgcm91dGUgcGF0aCBjaGFuZ2UuXG4gICAgICAgKi9cbiAgICAgIF9yb3V0ZUNoYW5nZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMucm91dGUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnBhdGggPSB0aGlzLnJvdXRlLnByZWZpeCArIHRoaXMucm91dGUucGF0aDtcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogSGFuZGxlciBjYWxsZWQgd2hlbiB0aGUgcm91dGUgcXVlcnlQYXJhbXMgY2hhbmdlLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSAge09iamVjdH0gcXVlcnlQYXJhbXMgQSBzZXQgb2Yga2V5L3ZhbHVlIHBhaXJzIHRoYXQgYXJlXG4gICAgICAgKiB1bml2ZXJzYWxseSBhY2Nlc3NpYmxlIHRvIGJyYW5jaGVzIG9mIHRoZSByb3V0ZSB0cmVlLlxuICAgICAgICovXG4gICAgICBfcm91dGVRdWVyeVBhcmFtc0NoYW5nZWQ6IGZ1bmN0aW9uKHF1ZXJ5UGFyYW1zKSB7XG4gICAgICAgIGlmICghdGhpcy5yb3V0ZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnF1ZXJ5UGFyYW1zID0gcXVlcnlQYXJhbXM7XG4gICAgICB9XG4gICAgfTtcbiAgfSkoKTtcbjwvc2NyaXB0PlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9hcHAtcm91dGUvYXBwLXJvdXRlLWNvbnZlcnRlci1iZWhhdmlvci5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNiBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuXG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vcG9seW1lci9wb2x5bWVyLmh0bWxcIj5cblxuPCEtLVxuYGFwcC1yb3V0ZWAgaXMgYW4gZWxlbWVudCB0aGF0IGVuYWJsZXMgZGVjbGFyYXRpdmUsIHNlbGYtZGVzY3JpYmluZyByb3V0aW5nXG5mb3IgYSB3ZWIgYXBwLlxuXG4+ICpuLmIuIGFwcC1yb3V0ZSBpcyBzdGlsbCBpbiBiZXRhLiBXZSBleHBlY3QgaXQgd2lsbCBuZWVkIHNvbWUgY2hhbmdlcy4gV2UncmUgY291bnRpbmcgb24geW91ciBmZWVkYmFjayEqXG5cbkluIGl0cyB0eXBpY2FsIHVzYWdlLCBhIGBhcHAtcm91dGVgIGVsZW1lbnQgY29uc3VtZXMgYW4gb2JqZWN0IHRoYXQgZGVzY3JpYmVzXG5zb21lIHN0YXRlIGFib3V0IHRoZSBjdXJyZW50IHJvdXRlLCB2aWEgdGhlIGByb3V0ZWAgcHJvcGVydHkuIEl0IHRoZW4gcGFyc2VzXG50aGF0IHN0YXRlIHVzaW5nIHRoZSBgcGF0dGVybmAgcHJvcGVydHksIGFuZCBwcm9kdWNlcyB0d28gYXJ0aWZhY3RzOiBzb21lIGBkYXRhYFxucmVsYXRlZCB0byB0aGUgYHJvdXRlYCwgYW5kIGEgYHRhaWxgIHRoYXQgY29udGFpbnMgdGhlIHJlc3Qgb2YgdGhlIGByb3V0ZWAgdGhhdFxuZGlkIG5vdCBtYXRjaC5cblxuSGVyZSBpcyBhIGJhc2ljIGV4YW1wbGUsIHdoZW4gdXNlZCB3aXRoIGBhcHAtbG9jYXRpb25gOlxuXG4gICAgPGFwcC1sb2NhdGlvbiByb3V0ZT1cInt7cm91dGV9fVwiPjwvYXBwLWxvY2F0aW9uPlxuICAgIDxhcHAtcm91dGVcbiAgICAgICAgcm91dGU9XCJ7e3JvdXRlfX1cIlxuICAgICAgICBwYXR0ZXJuPVwiLzpwYWdlXCJcbiAgICAgICAgZGF0YT1cInt7ZGF0YX19XCJcbiAgICAgICAgdGFpbD1cInt7dGFpbH19XCI+XG4gICAgPC9hcHAtcm91dGU+XG5cbkluIHRoZSBhYm92ZSBleGFtcGxlLCB0aGUgYGFwcC1sb2NhdGlvbmAgcHJvZHVjZXMgYSBgcm91dGVgIHZhbHVlLiBUaGVuLCB0aGVcbmByb3V0ZS5wYXRoYCBwcm9wZXJ0eSBpcyBtYXRjaGVkIGJ5IGNvbXBhcmluZyBpdCB0byB0aGUgYHBhdHRlcm5gIHByb3BlcnR5LiBJZlxudGhlIGBwYXR0ZXJuYCBwcm9wZXJ0eSBtYXRjaGVzIGByb3V0ZS5wYXRoYCwgdGhlIGBhcHAtcm91dGVgIHdpbGwgc2V0IG9yIHVwZGF0ZVxuaXRzIGBkYXRhYCBwcm9wZXJ0eSB3aXRoIGFuIG9iamVjdCB3aG9zZSBwcm9wZXJ0aWVzIGNvcnJlc3BvbmQgdG8gdGhlIHBhcmFtZXRlcnNcbmluIGBwYXR0ZXJuYC4gU28sIGluIHRoZSBhYm92ZSBleGFtcGxlLCBpZiBgcm91dGUucGF0aGAgd2FzIGAnL2Fib3V0J2AsIHRoZSB2YWx1ZVxub2YgYGRhdGFgIHdvdWxkIGJlIGB7XCJwYWdlXCI6IFwiYWJvdXRcIn1gLlxuXG5UaGUgYHRhaWxgIHByb3BlcnR5IHJlcHJlc2VudHMgdGhlIHJlbWFpbmluZyBwYXJ0IG9mIHRoZSByb3V0ZSBzdGF0ZSBhZnRlciB0aGVcbmBwYXR0ZXJuYCBoYXMgYmVlbiBhcHBsaWVkIHRvIGEgbWF0Y2hpbmcgYHJvdXRlYC5cblxuSGVyZSBpcyBhbm90aGVyIGV4YW1wbGUsIHdoZXJlIGB0YWlsYCBpcyB1c2VkOlxuXG4gICAgPGFwcC1sb2NhdGlvbiByb3V0ZT1cInt7cm91dGV9fVwiPjwvYXBwLWxvY2F0aW9uPlxuICAgIDxhcHAtcm91dGVcbiAgICAgICAgcm91dGU9XCJ7e3JvdXRlfX1cIlxuICAgICAgICBwYXR0ZXJuPVwiLzpwYWdlXCJcbiAgICAgICAgZGF0YT1cInt7cm91dGVEYXRhfX1cIlxuICAgICAgICB0YWlsPVwie3tzdWJyb3V0ZX19XCI+XG4gICAgPC9hcHAtcm91dGU+XG4gICAgPGFwcC1yb3V0ZVxuICAgICAgICByb3V0ZT1cInt7c3Vicm91dGV9fVwiXG4gICAgICAgIHBhdHRlcm49XCIvOmlkXCJcbiAgICAgICAgZGF0YT1cInt7c3Vicm91dGVEYXRhfX1cIj5cbiAgICA8L2FwcC1yb3V0ZT5cblxuSW4gdGhlIGFib3ZlIGV4YW1wbGUsIHRoZXJlIGFyZSB0d28gYGFwcC1yb3V0ZWAgZWxlbWVudHMuIFRoZSBmaXJzdFxuYGFwcC1yb3V0ZWAgY29uc3VtZXMgYSBgcm91dGVgLiBXaGVuIHRoZSBgcm91dGVgIGlzIG1hdGNoZWQsIHRoZSBmaXJzdFxuYGFwcC1yb3V0ZWAgYWxzbyBwcm9kdWNlcyBgcm91dGVEYXRhYCBmcm9tIGl0cyBgZGF0YWAsIGFuZCBgc3Vicm91dGVgIGZyb21cbml0cyBgdGFpbGAuIFRoZSBzZWNvbmQgYGFwcC1yb3V0ZWAgY29uc3VtZXMgdGhlIGBzdWJyb3V0ZWAsIGFuZCB3aGVuIGl0XG5tYXRjaGVzLCBpdCBwcm9kdWNlcyBhbiBvYmplY3QgY2FsbGVkIGBzdWJyb3V0ZURhdGFgIGZyb20gaXRzIGBkYXRhYC5cblxuU28sIHdoZW4gYHJvdXRlLnBhdGhgIGlzIGAnL2Fib3V0J2AsIHRoZSBgcm91dGVEYXRhYCBvYmplY3Qgd2lsbCBsb29rIGxpa2VcbnRoaXM6IGB7IHBhZ2U6ICdhYm91dCcgfWBcblxuQW5kIGBzdWJyb3V0ZURhdGFgIHdpbGwgYmUgbnVsbC4gSG93ZXZlciwgaWYgYHJvdXRlLnBhdGhgIGNoYW5nZXMgdG9cbmAnL2FydGljbGUvMTIzJ2AsIHRoZSBgcm91dGVEYXRhYCBvYmplY3Qgd2lsbCBsb29rIGxpa2UgdGhpczpcbmB7IHBhZ2U6ICdhcnRpY2xlJyB9YFxuXG5BbmQgdGhlIGBzdWJyb3V0ZURhdGFgIHdpbGwgbG9vayBsaWtlIHRoaXM6IGB7IGlkOiAnMTIzJyB9YFxuXG5gYXBwLXJvdXRlYCBpcyByZXNwb25zaXZlIHRvIGJpLWRpcmVjdGlvbmFsIGNoYW5nZXMgdG8gdGhlIGBkYXRhYCBvYmplY3RzXG50aGV5IHByb2R1Y2UuIFNvLCBpZiBgcm91dGVEYXRhLnBhZ2VgIGNoYW5nZWQgZnJvbSBgJ2FydGljbGUnYCB0byBgJ2Fib3V0J2AsXG50aGUgYGFwcC1yb3V0ZWAgd2lsbCB1cGRhdGUgYHJvdXRlLnBhdGhgLiBUaGlzIGluLXR1cm4gd2lsbCB1cGRhdGUgdGhlXG5gYXBwLWxvY2F0aW9uYCwgYW5kIGNhdXNlIHRoZSBnbG9iYWwgbG9jYXRpb24gYmFyIHRvIGNoYW5nZSBpdHMgdmFsdWUuXG5cbkBlbGVtZW50IGFwcC1yb3V0ZVxuQGRlbW8gZGVtby9pbmRleC5odG1sXG5AZGVtbyBkZW1vL2RhdGEtbG9hZGluZy1kZW1vLmh0bWxcbkBkZW1vIGRlbW8vc2ltcGxlLWRlbW8uaHRtbFxuLS0+XG5cbjxzY3JpcHQ+XG4gIChmdW5jdGlvbigpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBQb2x5bWVyKHtcbiAgICAgIGlzOiAnYXBwLXJvdXRlJyxcblxuICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIFVSTCBjb21wb25lbnQgbWFuYWdlZCBieSB0aGlzIGVsZW1lbnQuXG4gICAgICAgICAqL1xuICAgICAgICByb3V0ZToge1xuICAgICAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgICAgICBub3RpZnk6IHRydWVcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHBhdHRlcm4gb2Ygc2xhc2gtc2VwYXJhdGVkIHNlZ21lbnRzIHRvIG1hdGNoIGByb3V0ZS5wYXRoYCBhZ2FpbnN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgZXhhbXBsZSB0aGUgcGF0dGVybiBcIi9mb29cIiB3aWxsIG1hdGNoIFwiL2Zvb1wiIG9yIFwiL2Zvby9iYXJcIlxuICAgICAgICAgKiBidXQgbm90IFwiL2Zvb2JhclwiLlxuICAgICAgICAgKlxuICAgICAgICAgKiBQYXRoIHNlZ21lbnRzIGxpa2UgYC86bmFtZWRgIGFyZSBtYXBwZWQgdG8gcHJvcGVydGllcyBvbiB0aGUgYGRhdGFgIG9iamVjdC5cbiAgICAgICAgICovXG4gICAgICAgIHBhdHRlcm46IHtcbiAgICAgICAgICB0eXBlOiBTdHJpbmdcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHBhcmFtZXRlcml6ZWQgdmFsdWVzIHRoYXQgYXJlIGV4dHJhY3RlZCBmcm9tIHRoZSByb3V0ZSBhc1xuICAgICAgICAgKiBkZXNjcmliZWQgYnkgYHBhdHRlcm5gLlxuICAgICAgICAgKi9cbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24oKSB7cmV0dXJuIHt9O30sXG4gICAgICAgICAgbm90aWZ5OiB0cnVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHs/T2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgcXVlcnlQYXJhbXM6IHtcbiAgICAgICAgICB0eXBlOiBPYmplY3QsXG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICAgIH0sXG4gICAgICAgICAgbm90aWZ5OiB0cnVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBwYXJ0IG9mIGByb3V0ZS5wYXRoYCBOT1QgY29uc3VtZWQgYnkgYHBhdHRlcm5gLlxuICAgICAgICAgKi9cbiAgICAgICAgdGFpbDoge1xuICAgICAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24oKSB7cmV0dXJuIHtwYXRoOiBudWxsLCBwcmVmaXg6IG51bGwsIF9fcXVlcnlQYXJhbXM6IG51bGx9O30sXG4gICAgICAgICAgbm90aWZ5OiB0cnVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhlIGN1cnJlbnQgcm91dGUgaXMgYWN0aXZlLiBUcnVlIGlmIGByb3V0ZS5wYXRoYCBtYXRjaGVzIHRoZVxuICAgICAgICAgKiBgcGF0dGVybmAsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgICAgICovXG4gICAgICAgIGFjdGl2ZToge1xuICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgICAgbm90aWZ5OiB0cnVlLFxuICAgICAgICAgIHJlYWRPbmx5OiB0cnVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgX3F1ZXJ5UGFyYW1zVXBkYXRpbmc6IHtcbiAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUgez9zdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICBfbWF0Y2hlZDoge1xuICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICB2YWx1ZTogJydcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgb2JzZXJ2ZXJzOiBbXG4gICAgICAgICdfX3RyeVRvTWF0Y2gocm91dGUucGF0aCwgcGF0dGVybiknLFxuICAgICAgICAnX191cGRhdGVQYXRoT25EYXRhQ2hhbmdlKGRhdGEuKiknLFxuICAgICAgICAnX190YWlsUGF0aENoYW5nZWQodGFpbC5wYXRoKScsXG4gICAgICAgICdfX3JvdXRlUXVlcnlQYXJhbXNDaGFuZ2VkKHJvdXRlLl9fcXVlcnlQYXJhbXMpJyxcbiAgICAgICAgJ19fdGFpbFF1ZXJ5UGFyYW1zQ2hhbmdlZCh0YWlsLl9fcXVlcnlQYXJhbXMpJyxcbiAgICAgICAgJ19fcXVlcnlQYXJhbXNDaGFuZ2VkKHF1ZXJ5UGFyYW1zLiopJ1xuICAgICAgXSxcblxuICAgICAgY3JlYXRlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMubGlua1BhdGhzKCdyb3V0ZS5fX3F1ZXJ5UGFyYW1zJywgJ3RhaWwuX19xdWVyeVBhcmFtcycpO1xuICAgICAgICB0aGlzLmxpbmtQYXRocygndGFpbC5fX3F1ZXJ5UGFyYW1zJywgJ3JvdXRlLl9fcXVlcnlQYXJhbXMnKTtcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogRGVhbCB3aXRoIHRoZSBxdWVyeSBwYXJhbXMgb2JqZWN0IGJlaW5nIGFzc2lnbmVkIHRvIHdob2xlc2FsZS5cbiAgICAgICAqL1xuICAgICAgX19yb3V0ZVF1ZXJ5UGFyYW1zQ2hhbmdlZDogZnVuY3Rpb24ocXVlcnlQYXJhbXMpIHtcbiAgICAgICAgaWYgKHF1ZXJ5UGFyYW1zICYmIHRoaXMudGFpbCkge1xuICAgICAgICAgIGlmICh0aGlzLnRhaWwuX19xdWVyeVBhcmFtcyAhPT0gcXVlcnlQYXJhbXMpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0KCd0YWlsLl9fcXVlcnlQYXJhbXMnLCBxdWVyeVBhcmFtcyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCF0aGlzLmFjdGl2ZSB8fCB0aGlzLl9xdWVyeVBhcmFtc1VwZGF0aW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gQ29weSBxdWVyeVBhcmFtcyBhbmQgdHJhY2sgd2hldGhlciB0aGVyZSBhcmUgYW55IGRpZmZlcmVuY2VzIGNvbXBhcmVkXG4gICAgICAgICAgLy8gdG8gdGhlIGV4aXN0aW5nIHF1ZXJ5IHBhcmFtcy5cbiAgICAgICAgICB2YXIgY29weU9mUXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgICB2YXIgYW55dGhpbmdDaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgICAgZm9yICh2YXIga2V5IGluIHF1ZXJ5UGFyYW1zKSB7XG4gICAgICAgICAgICBjb3B5T2ZRdWVyeVBhcmFtc1trZXldID0gcXVlcnlQYXJhbXNba2V5XTtcbiAgICAgICAgICAgIGlmIChhbnl0aGluZ0NoYW5nZWQgfHxcbiAgICAgICAgICAgICAgICAhdGhpcy5xdWVyeVBhcmFtcyB8fFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zW2tleV0gIT09IHRoaXMucXVlcnlQYXJhbXNba2V5XSkge1xuICAgICAgICAgICAgICBhbnl0aGluZ0NoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBOZWVkIHRvIGNoZWNrIHdoZXRoZXIgYW55IGtleXMgd2VyZSBkZWxldGVkXG4gICAgICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMucXVlcnlQYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhbnl0aGluZ0NoYW5nZWQgfHwgIShrZXkgaW4gcXVlcnlQYXJhbXMpKSB7XG4gICAgICAgICAgICAgIGFueXRoaW5nQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghYW55dGhpbmdDaGFuZ2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX3F1ZXJ5UGFyYW1zVXBkYXRpbmcgPSB0cnVlO1xuICAgICAgICAgIHRoaXMuc2V0KCdxdWVyeVBhcmFtcycsIGNvcHlPZlF1ZXJ5UGFyYW1zKTtcbiAgICAgICAgICB0aGlzLl9xdWVyeVBhcmFtc1VwZGF0aW5nID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIF9fdGFpbFF1ZXJ5UGFyYW1zQ2hhbmdlZDogZnVuY3Rpb24ocXVlcnlQYXJhbXMpIHtcbiAgICAgICAgaWYgKHF1ZXJ5UGFyYW1zICYmIHRoaXMucm91dGUgJiYgdGhpcy5yb3V0ZS5fX3F1ZXJ5UGFyYW1zICE9IHF1ZXJ5UGFyYW1zKSB7XG4gICAgICAgICAgdGhpcy5zZXQoJ3JvdXRlLl9fcXVlcnlQYXJhbXMnLCBxdWVyeVBhcmFtcyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIF9fcXVlcnlQYXJhbXNDaGFuZ2VkOiBmdW5jdGlvbihjaGFuZ2VzKSB7XG4gICAgICAgIGlmICghdGhpcy5hY3RpdmUgfHwgdGhpcy5fcXVlcnlQYXJhbXNVcGRhdGluZykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2V0KCdyb3V0ZS5fXycgKyBjaGFuZ2VzLnBhdGgsIGNoYW5nZXMudmFsdWUpO1xuICAgICAgfSxcblxuICAgICAgX19yZXNldFByb3BlcnRpZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9zZXRBY3RpdmUoZmFsc2UpO1xuICAgICAgICB0aGlzLl9tYXRjaGVkID0gbnVsbDtcbiAgICAgIH0sXG5cbiAgICAgIF9fdHJ5VG9NYXRjaDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5yb3V0ZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwYXRoID0gdGhpcy5yb3V0ZS5wYXRoO1xuICAgICAgICB2YXIgcGF0dGVybiA9IHRoaXMucGF0dGVybjtcblxuICAgICAgICBpZiAoIXBhdHRlcm4pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXBhdGgpIHtcbiAgICAgICAgICB0aGlzLl9fcmVzZXRQcm9wZXJ0aWVzKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlbWFpbmluZ1BpZWNlcyA9IHBhdGguc3BsaXQoJy8nKTtcbiAgICAgICAgdmFyIHBhdHRlcm5QaWVjZXMgPSBwYXR0ZXJuLnNwbGl0KCcvJyk7XG5cbiAgICAgICAgdmFyIG1hdGNoZWQgPSBbXTtcbiAgICAgICAgdmFyIG5hbWVkTWF0Y2hlcyA9IHt9O1xuXG4gICAgICAgIGZvciAodmFyIGk9MDsgaSA8IHBhdHRlcm5QaWVjZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgcGF0dGVyblBpZWNlID0gcGF0dGVyblBpZWNlc1tpXTtcbiAgICAgICAgICBpZiAoIXBhdHRlcm5QaWVjZSAmJiBwYXR0ZXJuUGllY2UgIT09ICcnKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHBhdGhQaWVjZSA9IHJlbWFpbmluZ1BpZWNlcy5zaGlmdCgpO1xuXG4gICAgICAgICAgLy8gV2UgZG9uJ3QgbWF0Y2ggdGhpcyBwYXRoLlxuICAgICAgICAgIGlmICghcGF0aFBpZWNlICYmIHBhdGhQaWVjZSAhPT0gJycpIHtcbiAgICAgICAgICAgIHRoaXMuX19yZXNldFByb3BlcnRpZXMoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgbWF0Y2hlZC5wdXNoKHBhdGhQaWVjZSk7XG5cbiAgICAgICAgICBpZiAocGF0dGVyblBpZWNlLmNoYXJBdCgwKSA9PSAnOicpIHtcbiAgICAgICAgICAgIG5hbWVkTWF0Y2hlc1twYXR0ZXJuUGllY2Uuc2xpY2UoMSldID0gcGF0aFBpZWNlO1xuICAgICAgICAgIH0gZWxzZSBpZiAocGF0dGVyblBpZWNlICE9PSBwYXRoUGllY2UpIHtcbiAgICAgICAgICAgIHRoaXMuX19yZXNldFByb3BlcnRpZXMoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9tYXRjaGVkID0gbWF0Y2hlZC5qb2luKCcvJyk7XG5cbiAgICAgICAgLy8gUHJvcGVydGllcyB0aGF0IG11c3QgYmUgdXBkYXRlZCBhdG9taWNhbGx5LlxuICAgICAgICB2YXIgcHJvcGVydHlVcGRhdGVzID0ge307XG5cbiAgICAgICAgLy90aGlzLmFjdGl2ZVxuICAgICAgICBpZiAoIXRoaXMuYWN0aXZlKSB7XG4gICAgICAgICAgcHJvcGVydHlVcGRhdGVzLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0aGlzLnRhaWxcbiAgICAgICAgdmFyIHRhaWxQcmVmaXggPSB0aGlzLnJvdXRlLnByZWZpeCArIHRoaXMuX21hdGNoZWQ7XG4gICAgICAgIHZhciB0YWlsUGF0aCA9IHJlbWFpbmluZ1BpZWNlcy5qb2luKCcvJyk7XG4gICAgICAgIGlmIChyZW1haW5pbmdQaWVjZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHRhaWxQYXRoID0gJy8nICsgdGFpbFBhdGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLnRhaWwgfHxcbiAgICAgICAgICAgIHRoaXMudGFpbC5wcmVmaXggIT09IHRhaWxQcmVmaXggfHxcbiAgICAgICAgICAgIHRoaXMudGFpbC5wYXRoICE9PSB0YWlsUGF0aCkge1xuICAgICAgICAgIHByb3BlcnR5VXBkYXRlcy50YWlsID0ge1xuICAgICAgICAgICAgcHJlZml4OiB0YWlsUHJlZml4LFxuICAgICAgICAgICAgcGF0aDogdGFpbFBhdGgsXG4gICAgICAgICAgICBfX3F1ZXJ5UGFyYW1zOiB0aGlzLnJvdXRlLl9fcXVlcnlQYXJhbXNcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdGhpcy5kYXRhXG4gICAgICAgIHByb3BlcnR5VXBkYXRlcy5kYXRhID0gbmFtZWRNYXRjaGVzO1xuICAgICAgICB0aGlzLl9kYXRhSW5VcmwgPSB7fTtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG5hbWVkTWF0Y2hlcykge1xuICAgICAgICAgIHRoaXMuX2RhdGFJblVybFtrZXldID0gbmFtZWRNYXRjaGVzW2tleV07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5zZXRQcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgaWYgKCF0aGlzLmFjdGl2ZSkge1xuICAgICAgICAgICAgdGhpcy5fc2V0QWN0aXZlKHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBhdG9taWMgdXBkYXRlXG4gICAgICAgICAgdGhpcy5zZXRQcm9wZXJ0aWVzKHByb3BlcnR5VXBkYXRlcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fX3NldE11bHRpKHByb3BlcnR5VXBkYXRlcyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIF9fdGFpbFBhdGhDaGFuZ2VkOiBmdW5jdGlvbihwYXRoKSB7XG4gICAgICAgIGlmICghdGhpcy5hY3RpdmUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRhaWxQYXRoID0gcGF0aDtcbiAgICAgICAgdmFyIG5ld1BhdGggPSB0aGlzLl9tYXRjaGVkO1xuICAgICAgICBpZiAodGFpbFBhdGgpIHtcbiAgICAgICAgICBpZiAodGFpbFBhdGguY2hhckF0KDApICE9PSAnLycpIHtcbiAgICAgICAgICAgIHRhaWxQYXRoID0gJy8nICsgdGFpbFBhdGg7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5ld1BhdGggKz0gdGFpbFBhdGg7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXQoJ3JvdXRlLnBhdGgnLCBuZXdQYXRoKTtcbiAgICAgIH0sXG5cbiAgICAgIF9fdXBkYXRlUGF0aE9uRGF0YUNoYW5nZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5yb3V0ZSB8fCAhdGhpcy5hY3RpdmUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5ld1BhdGggPSB0aGlzLl9fZ2V0TGluayh7fSk7XG4gICAgICAgIHZhciBvbGRQYXRoID0gdGhpcy5fX2dldExpbmsodGhpcy5fZGF0YUluVXJsKTtcbiAgICAgICAgaWYgKG5ld1BhdGggPT09IG9sZFBhdGgpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXQoJ3JvdXRlLnBhdGgnLCBuZXdQYXRoKTtcbiAgICAgIH0sXG5cbiAgICAgIF9fZ2V0TGluazogZnVuY3Rpb24ob3ZlcnJpZGVWYWx1ZXMpIHtcbiAgICAgICAgdmFyIHZhbHVlcyA9IHt0YWlsOiBudWxsfTtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMuZGF0YSkge1xuICAgICAgICAgIHZhbHVlc1trZXldID0gdGhpcy5kYXRhW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIga2V5IGluIG92ZXJyaWRlVmFsdWVzKSB7XG4gICAgICAgICAgdmFsdWVzW2tleV0gPSBvdmVycmlkZVZhbHVlc1trZXldO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwYXR0ZXJuUGllY2VzID0gdGhpcy5wYXR0ZXJuLnNwbGl0KCcvJyk7XG4gICAgICAgIHZhciBpbnRlcnAgPSBwYXR0ZXJuUGllY2VzLm1hcChmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgIGlmICh2YWx1ZVswXSA9PSAnOicpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWVzW3ZhbHVlLnNsaWNlKDEpXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgaWYgKHZhbHVlcy50YWlsICYmIHZhbHVlcy50YWlsLnBhdGgpIHtcbiAgICAgICAgICBpZiAoaW50ZXJwLmxlbmd0aCA+IDAgJiYgdmFsdWVzLnRhaWwucGF0aC5jaGFyQXQoMCkgPT09ICcvJykge1xuICAgICAgICAgICAgaW50ZXJwLnB1c2godmFsdWVzLnRhaWwucGF0aC5zbGljZSgxKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGludGVycC5wdXNoKHZhbHVlcy50YWlsLnBhdGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW50ZXJwLmpvaW4oJy8nKTtcbiAgICAgIH0sXG5cbiAgICAgIF9fc2V0TXVsdGk6IGZ1bmN0aW9uKHNldE9iaikge1xuICAgICAgICAvLyBIQUNLKHJpY3RpYyk6IHNraXJ0aW5nIGFyb3VuZCAxLjAncyBsYWNrIG9mIGEgc2V0TXVsdGkgYnkgcG9raW5nIGF0XG4gICAgICAgIC8vICAgICBpbnRlcm5hbCBkYXRhIHN0cnVjdHVyZXMuIEkgd291bGQgbm90IGFkdmlzZSB0aGF0IHlvdSBjb3B5IHRoaXNcbiAgICAgICAgLy8gICAgIGV4YW1wbGUuXG4gICAgICAgIC8vXG4gICAgICAgIC8vICAgICBJbiB0aGUgZnV0dXJlIHRoaXMgd2lsbCBiZSBhIGZlYXR1cmUgb2YgUG9seW1lciBpdHNlbGYuXG4gICAgICAgIC8vICAgICBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9Qb2x5bWVyL3BvbHltZXIvaXNzdWVzLzM2NDBcbiAgICAgICAgLy9cbiAgICAgICAgLy8gICAgIEhhY2tpbmcgYXJvdW5kIHdpdGggcHJpdmF0ZSBtZXRob2RzIGxpa2UgdGhpcyBpcyBqdWdnbGluZyBmb290Z3VucyxcbiAgICAgICAgLy8gICAgIGFuZCBpcyBsaWtlbHkgdG8gaGF2ZSB1bmV4cGVjdGVkIGFuZCB1bnN1cHBvcnRlZCByb3VnaCBlZGdlcy5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gICAgIEJlIHllIHNvIHdhcm5lZC5cbiAgICAgICAgZm9yICh2YXIgcHJvcGVydHkgaW4gc2V0T2JqKSB7XG4gICAgICAgICAgdGhpcy5fcHJvcGVydHlTZXR0ZXIocHJvcGVydHksIHNldE9ialtwcm9wZXJ0eV0pO1xuICAgICAgICB9XG4gICAgICAgIC8vbm90aWZ5IGluIGEgc3BlY2lmaWMgb3JkZXJcbiAgICAgICAgaWYgKHNldE9iai5kYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLl9wYXRoRWZmZWN0b3IoJ2RhdGEnLCB0aGlzLmRhdGEpO1xuICAgICAgICAgIHRoaXMuX25vdGlmeUNoYW5nZSgnZGF0YScpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZXRPYmouYWN0aXZlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLl9wYXRoRWZmZWN0b3IoJ2FjdGl2ZScsIHRoaXMuYWN0aXZlKTtcbiAgICAgICAgICB0aGlzLl9ub3RpZnlDaGFuZ2UoJ2FjdGl2ZScpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZXRPYmoudGFpbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5fcGF0aEVmZmVjdG9yKCd0YWlsJywgdGhpcy50YWlsKTtcbiAgICAgICAgICB0aGlzLl9ub3RpZnlDaGFuZ2UoJ3RhaWwnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9KSgpO1xuPC9zY3JpcHQ+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL2FwcC1yb3V0ZS9hcHAtcm91dGUuaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTUgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cblxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3BvbHltZXIvcG9seW1lci5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vaXJvbi1yZXNpemFibGUtYmVoYXZpb3IvaXJvbi1yZXNpemFibGUtYmVoYXZpb3IuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL2lyb24tc2VsZWN0b3IvaXJvbi1zZWxlY3RhYmxlLmh0bWxcIj5cblxuPCEtLVxuYGlyb24tcGFnZXNgIGlzIHVzZWQgdG8gc2VsZWN0IG9uZSBvZiBpdHMgY2hpbGRyZW4gdG8gc2hvdy4gT25lIHVzZSBpcyB0byBjeWNsZSB0aHJvdWdoIGEgbGlzdCBvZlxuY2hpbGRyZW4gXCJwYWdlc1wiLlxuXG5FeGFtcGxlOlxuXG4gICAgPGlyb24tcGFnZXMgc2VsZWN0ZWQ9XCIwXCI+XG4gICAgICA8ZGl2Pk9uZTwvZGl2PlxuICAgICAgPGRpdj5Ud288L2Rpdj5cbiAgICAgIDxkaXY+VGhyZWU8L2Rpdj5cbiAgICA8L2lyb24tcGFnZXM+XG5cbiAgICA8c2NyaXB0PlxuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIHZhciBwYWdlcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2lyb24tcGFnZXMnKTtcbiAgICAgICAgcGFnZXMuc2VsZWN0TmV4dCgpO1xuICAgICAgfSk7XG4gICAgPC9zY3JpcHQ+XG5cbkBncm91cCBJcm9uIEVsZW1lbnRzXG5AaGVybyBoZXJvLnN2Z1xuQGRlbW8gZGVtby9pbmRleC5odG1sXG4tLT5cblxuPGRvbS1tb2R1bGUgaWQ9XCJpcm9uLXBhZ2VzXCI+XG5cbiAgPHRlbXBsYXRlPlxuICAgIDxzdHlsZT5cbiAgICAgIDpob3N0IHtcbiAgICAgICAgZGlzcGxheTogYmxvY2s7XG4gICAgICB9XG5cbiAgICAgIDpob3N0ID4gOjpzbG90dGVkKDpub3QoLmlyb24tc2VsZWN0ZWQpKSB7XG4gICAgICAgIGRpc3BsYXk6IG5vbmUgIWltcG9ydGFudDtcbiAgICAgIH1cbiAgICA8L3N0eWxlPlxuXG4gICAgPHNsb3Q+PC9zbG90PlxuICA8L3RlbXBsYXRlPlxuXG4gIDxzY3JpcHQ+XG4gICAgUG9seW1lcih7XG5cbiAgICAgIGlzOiAnaXJvbi1wYWdlcycsXG5cbiAgICAgIGJlaGF2aW9yczogW1xuICAgICAgICBQb2x5bWVyLklyb25SZXNpemFibGVCZWhhdmlvcixcbiAgICAgICAgUG9seW1lci5Jcm9uU2VsZWN0YWJsZUJlaGF2aW9yXG4gICAgICBdLFxuXG4gICAgICBwcm9wZXJ0aWVzOiB7XG5cbiAgICAgICAgLy8gYXMgdGhlIHNlbGVjdGVkIHBhZ2UgaXMgdGhlIG9ubHkgb25lIHZpc2libGUsIGFjdGl2YXRlRXZlbnRcbiAgICAgICAgLy8gaXMgYm90aCBub24tc2Vuc2ljYWwgYW5kIHByb2JsZW1hdGljOyBlLmcuIGluIGNhc2VzIHdoZXJlIGEgdXNlclxuICAgICAgICAvLyBoYW5kbGVyIGF0dGVtcHRzIHRvIGNoYW5nZSB0aGUgcGFnZSBhbmQgdGhlIGFjdGl2YXRlRXZlbnRcbiAgICAgICAgLy8gaGFuZGxlciBpbW1lZGlhdGVseSBjaGFuZ2VzIGl0IGJhY2tcbiAgICAgICAgYWN0aXZhdGVFdmVudDoge1xuICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICB2YWx1ZTogbnVsbFxuICAgICAgICB9XG5cbiAgICAgIH0sXG5cbiAgICAgIG9ic2VydmVyczogW1xuICAgICAgICAnX3NlbGVjdGVkUGFnZUNoYW5nZWQoc2VsZWN0ZWQpJ1xuICAgICAgXSxcblxuICAgICAgX3NlbGVjdGVkUGFnZUNoYW5nZWQ6IGZ1bmN0aW9uKHNlbGVjdGVkLCBvbGQpIHtcbiAgICAgICAgdGhpcy5hc3luYyh0aGlzLm5vdGlmeVJlc2l6ZSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgPC9zY3JpcHQ+XG48L2RvbS1tb2R1bGU+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL2lyb24tcGFnZXMvaXJvbi1wYWdlcy5odG1sIiwiXG48IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE1IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi9wb2x5bWVyL3BvbHltZXIuaHRtbFwiPlxuXG48c2NyaXB0PlxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFGdW5jdGlvbn0gc2VsZWN0Q2FsbGJhY2tcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuICBQb2x5bWVyLklyb25TZWxlY3Rpb24gPSBmdW5jdGlvbihzZWxlY3RDYWxsYmFjaykge1xuICAgIHRoaXMuc2VsZWN0aW9uID0gW107XG4gICAgdGhpcy5zZWxlY3RDYWxsYmFjayA9IHNlbGVjdENhbGxiYWNrO1xuICB9O1xuXG4gIFBvbHltZXIuSXJvblNlbGVjdGlvbi5wcm90b3R5cGUgPSB7XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIHNlbGVjdGVkIGl0ZW0ocykuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGdldFxuICAgICAqIEByZXR1cm5zIFJldHVybnMgdGhlIHNlbGVjdGVkIGl0ZW0ocykuIElmIHRoZSBtdWx0aSBwcm9wZXJ0eSBpcyB0cnVlLFxuICAgICAqIGBnZXRgIHdpbGwgcmV0dXJuIGFuIGFycmF5LCBvdGhlcndpc2UgaXQgd2lsbCByZXR1cm5cbiAgICAgKiB0aGUgc2VsZWN0ZWQgaXRlbSBvciB1bmRlZmluZWQgaWYgdGhlcmUgaXMgbm8gc2VsZWN0aW9uLlxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5tdWx0aSA/IHRoaXMuc2VsZWN0aW9uLnNsaWNlKCkgOiB0aGlzLnNlbGVjdGlvblswXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2xlYXJzIGFsbCB0aGUgc2VsZWN0aW9uIGV4Y2VwdCB0aGUgb25lcyBpbmRpY2F0ZWQuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGNsZWFyXG4gICAgICogQHBhcmFtIHtBcnJheX0gZXhjbHVkZXMgaXRlbXMgdG8gYmUgZXhjbHVkZWQuXG4gICAgICovXG4gICAgY2xlYXI6IGZ1bmN0aW9uKGV4Y2x1ZGVzKSB7XG4gICAgICB0aGlzLnNlbGVjdGlvbi5zbGljZSgpLmZvckVhY2goZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICBpZiAoIWV4Y2x1ZGVzIHx8IGV4Y2x1ZGVzLmluZGV4T2YoaXRlbSkgPCAwKSB7XG4gICAgICAgICAgdGhpcy5zZXRJdGVtU2VsZWN0ZWQoaXRlbSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9LCB0aGlzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIGlmIGEgZ2l2ZW4gaXRlbSBpcyBzZWxlY3RlZC5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgaXNTZWxlY3RlZFxuICAgICAqIEBwYXJhbSB7Kn0gaXRlbSBUaGUgaXRlbSB3aG9zZSBzZWxlY3Rpb24gc3RhdGUgc2hvdWxkIGJlIGNoZWNrZWQuXG4gICAgICogQHJldHVybnMgUmV0dXJucyB0cnVlIGlmIGBpdGVtYCBpcyBzZWxlY3RlZC5cbiAgICAgKi9cbiAgICBpc1NlbGVjdGVkOiBmdW5jdGlvbihpdGVtKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb24uaW5kZXhPZihpdGVtKSA+PSAwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBzZWxlY3Rpb24gc3RhdGUgZm9yIGEgZ2l2ZW4gaXRlbSB0byBlaXRoZXIgc2VsZWN0ZWQgb3IgZGVzZWxlY3RlZC5cbiAgICAgKlxuICAgICAqIEBtZXRob2Qgc2V0SXRlbVNlbGVjdGVkXG4gICAgICogQHBhcmFtIHsqfSBpdGVtIFRoZSBpdGVtIHRvIHNlbGVjdC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzU2VsZWN0ZWQgVHJ1ZSBmb3Igc2VsZWN0ZWQsIGZhbHNlIGZvciBkZXNlbGVjdGVkLlxuICAgICAqL1xuICAgIHNldEl0ZW1TZWxlY3RlZDogZnVuY3Rpb24oaXRlbSwgaXNTZWxlY3RlZCkge1xuICAgICAgaWYgKGl0ZW0gIT0gbnVsbCkge1xuICAgICAgICBpZiAoaXNTZWxlY3RlZCAhPT0gdGhpcy5pc1NlbGVjdGVkKGl0ZW0pKSB7XG4gICAgICAgICAgLy8gcHJvY2VlZCB0byB1cGRhdGUgc2VsZWN0aW9uIG9ubHkgaWYgcmVxdWVzdGVkIHN0YXRlIGRpZmZlcnMgZnJvbSBjdXJyZW50XG4gICAgICAgICAgaWYgKGlzU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uLnB1c2goaXRlbSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBpID0gdGhpcy5zZWxlY3Rpb24uaW5kZXhPZihpdGVtKTtcbiAgICAgICAgICAgIGlmIChpID49IDApIHtcbiAgICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24uc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy5zZWxlY3RDYWxsYmFjaykge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RDYWxsYmFjayhpdGVtLCBpc1NlbGVjdGVkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgc2VsZWN0aW9uIHN0YXRlIGZvciBhIGdpdmVuIGl0ZW0uIElmIHRoZSBgbXVsdGlgIHByb3BlcnR5XG4gICAgICogaXMgdHJ1ZSwgdGhlbiB0aGUgc2VsZWN0ZWQgc3RhdGUgb2YgYGl0ZW1gIHdpbGwgYmUgdG9nZ2xlZDsgb3RoZXJ3aXNlXG4gICAgICogdGhlIGBpdGVtYCB3aWxsIGJlIHNlbGVjdGVkLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBzZWxlY3RcbiAgICAgKiBAcGFyYW0geyp9IGl0ZW0gVGhlIGl0ZW0gdG8gc2VsZWN0LlxuICAgICAqL1xuICAgIHNlbGVjdDogZnVuY3Rpb24oaXRlbSkge1xuICAgICAgaWYgKHRoaXMubXVsdGkpIHtcbiAgICAgICAgdGhpcy50b2dnbGUoaXRlbSk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuZ2V0KCkgIT09IGl0ZW0pIHtcbiAgICAgICAgdGhpcy5zZXRJdGVtU2VsZWN0ZWQodGhpcy5nZXQoKSwgZmFsc2UpO1xuICAgICAgICB0aGlzLnNldEl0ZW1TZWxlY3RlZChpdGVtLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVG9nZ2xlcyB0aGUgc2VsZWN0aW9uIHN0YXRlIGZvciBgaXRlbWAuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHRvZ2dsZVxuICAgICAqIEBwYXJhbSB7Kn0gaXRlbSBUaGUgaXRlbSB0byB0b2dnbGUuXG4gICAgICovXG4gICAgdG9nZ2xlOiBmdW5jdGlvbihpdGVtKSB7XG4gICAgICB0aGlzLnNldEl0ZW1TZWxlY3RlZChpdGVtLCAhdGhpcy5pc1NlbGVjdGVkKGl0ZW0pKTtcbiAgICB9XG5cbiAgfTtcblxuPC9zY3JpcHQ+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL2lyb24tc2VsZWN0b3IvaXJvbi1zZWxlY3Rpb24uaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTUgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cblxuXG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vcG9seW1lci9wb2x5bWVyLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCJpcm9uLW11bHRpLXNlbGVjdGFibGUuaHRtbFwiPlxuXG48c2NyaXB0PlxuICAvKipcbiAgYGlyb24tc2VsZWN0b3JgIGlzIGFuIGVsZW1lbnQgd2hpY2ggY2FuIGJlIHVzZWQgdG8gbWFuYWdlIGEgbGlzdCBvZiBlbGVtZW50c1xuICB0aGF0IGNhbiBiZSBzZWxlY3RlZC4gIFRhcHBpbmcgb24gdGhlIGl0ZW0gd2lsbCBtYWtlIHRoZSBpdGVtIHNlbGVjdGVkLiAgVGhlIGBzZWxlY3RlZGAgaW5kaWNhdGVzXG4gIHdoaWNoIGl0ZW0gaXMgYmVpbmcgc2VsZWN0ZWQuICBUaGUgZGVmYXVsdCBpcyB0byB1c2UgdGhlIGluZGV4IG9mIHRoZSBpdGVtLlxuXG4gIEV4YW1wbGU6XG5cbiAgICAgIDxpcm9uLXNlbGVjdG9yIHNlbGVjdGVkPVwiMFwiPlxuICAgICAgICA8ZGl2Pkl0ZW0gMTwvZGl2PlxuICAgICAgICA8ZGl2Pkl0ZW0gMjwvZGl2PlxuICAgICAgICA8ZGl2Pkl0ZW0gMzwvZGl2PlxuICAgICAgPC9pcm9uLXNlbGVjdG9yPlxuXG4gIElmIHlvdSB3YW50IHRvIHVzZSB0aGUgYXR0cmlidXRlIHZhbHVlIG9mIGFuIGVsZW1lbnQgZm9yIGBzZWxlY3RlZGAgaW5zdGVhZCBvZiB0aGUgaW5kZXgsXG4gIHNldCBgYXR0ckZvclNlbGVjdGVkYCB0byB0aGUgbmFtZSBvZiB0aGUgYXR0cmlidXRlLiAgRm9yIGV4YW1wbGUsIGlmIHlvdSB3YW50IHRvIHNlbGVjdCBpdGVtIGJ5XG4gIGBuYW1lYCwgc2V0IGBhdHRyRm9yU2VsZWN0ZWRgIHRvIGBuYW1lYC5cblxuICBFeGFtcGxlOlxuXG4gICAgICA8aXJvbi1zZWxlY3RvciBhdHRyLWZvci1zZWxlY3RlZD1cIm5hbWVcIiBzZWxlY3RlZD1cImZvb1wiPlxuICAgICAgICA8ZGl2IG5hbWU9XCJmb29cIj5Gb288L2Rpdj5cbiAgICAgICAgPGRpdiBuYW1lPVwiYmFyXCI+QmFyPC9kaXY+XG4gICAgICAgIDxkaXYgbmFtZT1cInpvdFwiPlpvdDwvZGl2PlxuICAgICAgPC9pcm9uLXNlbGVjdG9yPlxuXG4gIFlvdSBjYW4gc3BlY2lmeSBhIGRlZmF1bHQgZmFsbGJhY2sgd2l0aCBgZmFsbGJhY2tTZWxlY3Rpb25gIGluIGNhc2UgdGhlIGBzZWxlY3RlZGAgYXR0cmlidXRlIGRvZXNcbiAgbm90IG1hdGNoIHRoZSBgYXR0ckZvclNlbGVjdGVkYCBhdHRyaWJ1dGUgb2YgYW55IGVsZW1lbnRzLlxuXG4gIEV4YW1wbGU6XG5cbiAgICAgICAgPGlyb24tc2VsZWN0b3IgYXR0ci1mb3Itc2VsZWN0ZWQ9XCJuYW1lXCIgc2VsZWN0ZWQ9XCJub24tZXhpc3RpbmdcIlxuICAgICAgICAgICAgICAgICAgICAgICBmYWxsYmFjay1zZWxlY3Rpb249XCJkZWZhdWx0XCI+XG4gICAgICAgICAgPGRpdiBuYW1lPVwiZm9vXCI+Rm9vPC9kaXY+XG4gICAgICAgICAgPGRpdiBuYW1lPVwiYmFyXCI+QmFyPC9kaXY+XG4gICAgICAgICAgPGRpdiBuYW1lPVwiZGVmYXVsdFwiPkRlZmF1bHQ8L2Rpdj5cbiAgICAgICAgPC9pcm9uLXNlbGVjdG9yPlxuXG4gIE5vdGU6IFdoZW4gdGhlIHNlbGVjdG9yIGlzIG11bHRpLCB0aGUgc2VsZWN0aW9uIHdpbGwgc2V0IHRvIGBmYWxsYmFja1NlbGVjdGlvbmAgaWZmXG4gIHRoZSBudW1iZXIgb2YgbWF0Y2hpbmcgZWxlbWVudHMgaXMgemVyby5cblxuICBgaXJvbi1zZWxlY3RvcmAgaXMgbm90IHN0eWxlZC4gVXNlIHRoZSBgaXJvbi1zZWxlY3RlZGAgQ1NTIGNsYXNzIHRvIHN0eWxlIHRoZSBzZWxlY3RlZCBlbGVtZW50LlxuXG4gIEV4YW1wbGU6XG5cbiAgICAgIDxzdHlsZT5cbiAgICAgICAgLmlyb24tc2VsZWN0ZWQge1xuICAgICAgICAgIGJhY2tncm91bmQ6ICNlZWU7XG4gICAgICAgIH1cbiAgICAgIDwvc3R5bGU+XG5cbiAgICAgIC4uLlxuXG4gICAgICA8aXJvbi1zZWxlY3RvciBzZWxlY3RlZD1cIjBcIj5cbiAgICAgICAgPGRpdj5JdGVtIDE8L2Rpdj5cbiAgICAgICAgPGRpdj5JdGVtIDI8L2Rpdj5cbiAgICAgICAgPGRpdj5JdGVtIDM8L2Rpdj5cbiAgICAgIDwvaXJvbi1zZWxlY3Rvcj5cblxuICBAZGVtbyBkZW1vL2luZGV4Lmh0bWxcbiAgKi9cblxuICBQb2x5bWVyKHtcblxuICAgIGlzOiAnaXJvbi1zZWxlY3RvcicsXG5cbiAgICBiZWhhdmlvcnM6IFtcbiAgICAgIFBvbHltZXIuSXJvbk11bHRpU2VsZWN0YWJsZUJlaGF2aW9yXG4gICAgXVxuXG4gIH0pO1xuXG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvaXJvbi1zZWxlY3Rvci9pcm9uLXNlbGVjdG9yLmh0bWwiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE1IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi9wb2x5bWVyL3BvbHltZXIuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cImlyb24tc2VsZWN0YWJsZS5odG1sXCI+XG5cbjxzY3JpcHQ+XG4gIC8qKlxuICAgKiBAcG9seW1lckJlaGF2aW9yIFBvbHltZXIuSXJvbk11bHRpU2VsZWN0YWJsZUJlaGF2aW9yXG4gICAqL1xuICBQb2x5bWVyLklyb25NdWx0aVNlbGVjdGFibGVCZWhhdmlvckltcGwgPSB7XG4gICAgcHJvcGVydGllczoge1xuXG4gICAgICAvKipcbiAgICAgICAqIElmIHRydWUsIG11bHRpcGxlIHNlbGVjdGlvbnMgYXJlIGFsbG93ZWQuXG4gICAgICAgKi9cbiAgICAgIG11bHRpOiB7XG4gICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgIHZhbHVlOiBmYWxzZSxcbiAgICAgICAgb2JzZXJ2ZXI6ICdtdWx0aUNoYW5nZWQnXG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgc2VsZWN0ZWQgZWxlbWVudHMuIFRoaXMgaXMgdXNlZCBpbnN0ZWFkIG9mIGBzZWxlY3RlZGAgd2hlbiBgbXVsdGlgXG4gICAgICAgKiBpcyB0cnVlLlxuICAgICAgICovXG4gICAgICBzZWxlY3RlZFZhbHVlczoge1xuICAgICAgICB0eXBlOiBBcnJheSxcbiAgICAgICAgbm90aWZ5OiB0cnVlLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFJldHVybnMgYW4gYXJyYXkgb2YgY3VycmVudGx5IHNlbGVjdGVkIGl0ZW1zLlxuICAgICAgICovXG4gICAgICBzZWxlY3RlZEl0ZW1zOiB7XG4gICAgICAgIHR5cGU6IEFycmF5LFxuICAgICAgICByZWFkT25seTogdHJ1ZSxcbiAgICAgICAgbm90aWZ5OiB0cnVlLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgfSxcblxuICAgIG9ic2VydmVyczogW1xuICAgICAgJ191cGRhdGVTZWxlY3RlZChzZWxlY3RlZFZhbHVlcy5zcGxpY2VzKSdcbiAgICBdLFxuXG4gICAgLyoqXG4gICAgICogU2VsZWN0cyB0aGUgZ2l2ZW4gdmFsdWUuIElmIHRoZSBgbXVsdGlgIHByb3BlcnR5IGlzIHRydWUsIHRoZW4gdGhlIHNlbGVjdGVkIHN0YXRlIG9mIHRoZVxuICAgICAqIGB2YWx1ZWAgd2lsbCBiZSB0b2dnbGVkOyBvdGhlcndpc2UgdGhlIGB2YWx1ZWAgd2lsbCBiZSBzZWxlY3RlZC5cbiAgICAgKlxuICAgICAqIEBtZXRob2Qgc2VsZWN0XG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSB2YWx1ZSB0aGUgdmFsdWUgdG8gc2VsZWN0LlxuICAgICAqL1xuICAgIHNlbGVjdDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIGlmICh0aGlzLm11bHRpKSB7XG4gICAgICAgIHRoaXMuX3RvZ2dsZVNlbGVjdGVkKHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWQgPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgbXVsdGlDaGFuZ2VkOiBmdW5jdGlvbihtdWx0aSkge1xuICAgICAgdGhpcy5fc2VsZWN0aW9uLm11bHRpID0gbXVsdGk7XG4gICAgICB0aGlzLl91cGRhdGVTZWxlY3RlZCgpO1xuICAgIH0sXG5cbiAgICAvLyBVTlVTRUQsIEZPUiBBUEkgQ09NUEFUSUJJTElUWVxuICAgIGdldCBfc2hvdWxkVXBkYXRlU2VsZWN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0ZWQgIT0gbnVsbCB8fFxuICAgICAgICAodGhpcy5zZWxlY3RlZFZhbHVlcyAhPSBudWxsICYmIHRoaXMuc2VsZWN0ZWRWYWx1ZXMubGVuZ3RoKTtcbiAgICB9LFxuXG4gICAgX3VwZGF0ZUF0dHJGb3JTZWxlY3RlZDogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXRoaXMubXVsdGkpIHtcbiAgICAgICAgUG9seW1lci5Jcm9uU2VsZWN0YWJsZUJlaGF2aW9yLl91cGRhdGVBdHRyRm9yU2VsZWN0ZWQuYXBwbHkodGhpcyk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuc2VsZWN0ZWRJdGVtcyAmJiB0aGlzLnNlbGVjdGVkSXRlbXMubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLnNlbGVjdGVkVmFsdWVzID0gdGhpcy5zZWxlY3RlZEl0ZW1zLm1hcChmdW5jdGlvbihzZWxlY3RlZEl0ZW0pIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5faW5kZXhUb1ZhbHVlKHRoaXMuaW5kZXhPZihzZWxlY3RlZEl0ZW0pKTtcbiAgICAgICAgfSwgdGhpcykuZmlsdGVyKGZ1bmN0aW9uKHVuZmlsdGVyZWRWYWx1ZSkge1xuICAgICAgICAgIHJldHVybiB1bmZpbHRlcmVkVmFsdWUgIT0gbnVsbDtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIF91cGRhdGVTZWxlY3RlZDogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5tdWx0aSkge1xuICAgICAgICB0aGlzLl9zZWxlY3RNdWx0aSh0aGlzLnNlbGVjdGVkVmFsdWVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3NlbGVjdFNlbGVjdGVkKHRoaXMuc2VsZWN0ZWQpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBfc2VsZWN0TXVsdGk6IGZ1bmN0aW9uKHZhbHVlcykge1xuICAgICAgdmFsdWVzID0gdmFsdWVzIHx8IFtdO1xuXG4gICAgICB2YXIgc2VsZWN0ZWRJdGVtcyA9ICh0aGlzLl92YWx1ZXNUb0l0ZW1zKHZhbHVlcykgfHwgW10pLmZpbHRlcihmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgIHJldHVybiBpdGVtICE9PSBudWxsICYmIGl0ZW0gIT09IHVuZGVmaW5lZDtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBjbGVhciBhbGwgYnV0IHRoZSBjdXJyZW50IHNlbGVjdGVkIGl0ZW1zXG4gICAgICB0aGlzLl9zZWxlY3Rpb24uY2xlYXIoc2VsZWN0ZWRJdGVtcyk7XG5cbiAgICAgIC8vIHNlbGVjdCBvbmx5IHRob3NlIG5vdCBzZWxlY3RlZCB5ZXRcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZWN0ZWRJdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLl9zZWxlY3Rpb24uc2V0SXRlbVNlbGVjdGVkKHNlbGVjdGVkSXRlbXNbaV0sIHRydWUpO1xuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayBmb3IgaXRlbXMsIHNpbmNlIHRoaXMgYXJyYXkgaXMgcG9wdWxhdGVkIG9ubHkgd2hlbiBhdHRhY2hlZFxuICAgICAgaWYgKHRoaXMuZmFsbGJhY2tTZWxlY3Rpb24gJiYgIXRoaXMuX3NlbGVjdGlvbi5nZXQoKS5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGZhbGxiYWNrID0gdGhpcy5fdmFsdWVUb0l0ZW0odGhpcy5mYWxsYmFja1NlbGVjdGlvbik7XG4gICAgICAgIGlmIChmYWxsYmFjaykge1xuICAgICAgICAgIHRoaXMuc2VsZWN0KHRoaXMuZmFsbGJhY2tTZWxlY3Rpb24pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIF9zZWxlY3Rpb25DaGFuZ2U6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHMgPSB0aGlzLl9zZWxlY3Rpb24uZ2V0KCk7XG4gICAgICBpZiAodGhpcy5tdWx0aSkge1xuICAgICAgICB0aGlzLl9zZXRTZWxlY3RlZEl0ZW1zKHMpO1xuICAgICAgICB0aGlzLl9zZXRTZWxlY3RlZEl0ZW0ocy5sZW5ndGggPyBzWzBdIDogbnVsbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocyAhPT0gbnVsbCAmJiBzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLl9zZXRTZWxlY3RlZEl0ZW1zKFtzXSk7XG4gICAgICAgICAgdGhpcy5fc2V0U2VsZWN0ZWRJdGVtKHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX3NldFNlbGVjdGVkSXRlbXMoW10pO1xuICAgICAgICAgIHRoaXMuX3NldFNlbGVjdGVkSXRlbShudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBfdG9nZ2xlU2VsZWN0ZWQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICB2YXIgaSA9IHRoaXMuc2VsZWN0ZWRWYWx1ZXMuaW5kZXhPZih2YWx1ZSk7XG4gICAgICB2YXIgdW5zZWxlY3RlZCA9IGkgPCAwO1xuICAgICAgaWYgKHVuc2VsZWN0ZWQpIHtcbiAgICAgICAgdGhpcy5wdXNoKCdzZWxlY3RlZFZhbHVlcycsdmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zcGxpY2UoJ3NlbGVjdGVkVmFsdWVzJyxpLDEpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBfdmFsdWVzVG9JdGVtczogZnVuY3Rpb24odmFsdWVzKSB7XG4gICAgICByZXR1cm4gKHZhbHVlcyA9PSBudWxsKSA/IG51bGwgOiB2YWx1ZXMubWFwKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92YWx1ZVRvSXRlbSh2YWx1ZSk7XG4gICAgICB9LCB0aGlzKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqIEBwb2x5bWVyQmVoYXZpb3IgKi9cbiAgUG9seW1lci5Jcm9uTXVsdGlTZWxlY3RhYmxlQmVoYXZpb3IgPSBbXG4gICAgUG9seW1lci5Jcm9uU2VsZWN0YWJsZUJlaGF2aW9yLFxuICAgIFBvbHltZXIuSXJvbk11bHRpU2VsZWN0YWJsZUJlaGF2aW9ySW1wbFxuICBdO1xuXG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvaXJvbi1zZWxlY3Rvci9pcm9uLW11bHRpLXNlbGVjdGFibGUuaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTUgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cblxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3BvbHltZXIvcG9seW1lci5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vaXJvbi1iZWhhdmlvcnMvaXJvbi1idXR0b24tc3RhdGUuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cInBhcGVyLXJpcHBsZS1iZWhhdmlvci5odG1sXCI+XG5cbjxzY3JpcHQ+XG4gIC8qKlxuICAgKiBgUG9seW1lci5QYXBlcklua3lGb2N1c0JlaGF2aW9yYCBpbXBsZW1lbnRzIGEgcmlwcGxlIHdoZW4gdGhlIGVsZW1lbnQgaGFzIGtleWJvYXJkIGZvY3VzLlxuICAgKlxuICAgKiBAcG9seW1lckJlaGF2aW9yIFBvbHltZXIuUGFwZXJJbmt5Rm9jdXNCZWhhdmlvclxuICAgKi9cbiAgUG9seW1lci5QYXBlcklua3lGb2N1c0JlaGF2aW9ySW1wbCA9IHtcbiAgICBvYnNlcnZlcnM6IFtcbiAgICAgICdfZm9jdXNlZENoYW5nZWQocmVjZWl2ZWRGb2N1c0Zyb21LZXlib2FyZCknXG4gICAgXSxcblxuICAgIF9mb2N1c2VkQ2hhbmdlZDogZnVuY3Rpb24ocmVjZWl2ZWRGb2N1c0Zyb21LZXlib2FyZCkge1xuICAgICAgaWYgKHJlY2VpdmVkRm9jdXNGcm9tS2V5Ym9hcmQpIHtcbiAgICAgICAgdGhpcy5lbnN1cmVSaXBwbGUoKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmhhc1JpcHBsZSgpKSB7XG4gICAgICAgIHRoaXMuX3JpcHBsZS5ob2xkRG93biA9IHJlY2VpdmVkRm9jdXNGcm9tS2V5Ym9hcmQ7XG4gICAgICB9XG4gICAgfSxcblxuICAgIF9jcmVhdGVSaXBwbGU6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHJpcHBsZSA9IFBvbHltZXIuUGFwZXJSaXBwbGVCZWhhdmlvci5fY3JlYXRlUmlwcGxlKCk7XG4gICAgICByaXBwbGUuaWQgPSAnaW5rJztcbiAgICAgIHJpcHBsZS5zZXRBdHRyaWJ1dGUoJ2NlbnRlcicsICcnKTtcbiAgICAgIHJpcHBsZS5jbGFzc0xpc3QuYWRkKCdjaXJjbGUnKTtcbiAgICAgIHJldHVybiByaXBwbGU7XG4gICAgfVxuICB9O1xuXG4gIC8qKiBAcG9seW1lckJlaGF2aW9yIFBvbHltZXIuUGFwZXJJbmt5Rm9jdXNCZWhhdmlvciAqL1xuICBQb2x5bWVyLlBhcGVySW5reUZvY3VzQmVoYXZpb3IgPSBbXG4gICAgUG9seW1lci5Jcm9uQnV0dG9uU3RhdGUsXG4gICAgUG9seW1lci5Jcm9uQ29udHJvbFN0YXRlLFxuICAgIFBvbHltZXIuUGFwZXJSaXBwbGVCZWhhdmlvcixcbiAgICBQb2x5bWVyLlBhcGVySW5reUZvY3VzQmVoYXZpb3JJbXBsXG4gIF07XG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvcGFwZXItYmVoYXZpb3JzL3BhcGVyLWlua3ktZm9jdXMtYmVoYXZpb3IuaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTUgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cblxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3BvbHltZXIvcG9seW1lci5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vcGFwZXItcmlwcGxlL3BhcGVyLXJpcHBsZS5odG1sXCI+XG5cbjxzY3JpcHQ+XG4gIC8qKlxuICAgKiBgUG9seW1lci5QYXBlclJpcHBsZUJlaGF2aW9yYCBkeW5hbWljYWxseSBpbXBsZW1lbnRzIGEgcmlwcGxlXG4gICAqIHdoZW4gdGhlIGVsZW1lbnQgaGFzIGZvY3VzIHZpYSBwb2ludGVyIG9yIGtleWJvYXJkLlxuICAgKlxuICAgKiBOT1RFOiBUaGlzIGJlaGF2aW9yIGlzIGludGVuZGVkIHRvIGJlIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCBhbmQgYWZ0ZXJcbiAgICogYFBvbHltZXIuSXJvbkJ1dHRvblN0YXRlYCBhbmQgYFBvbHltZXIuSXJvbkNvbnRyb2xTdGF0ZWAuXG4gICAqXG4gICAqIEBwb2x5bWVyQmVoYXZpb3IgUG9seW1lci5QYXBlclJpcHBsZUJlaGF2aW9yXG4gICAqL1xuICBQb2x5bWVyLlBhcGVyUmlwcGxlQmVoYXZpb3IgPSB7XG4gICAgcHJvcGVydGllczoge1xuICAgICAgLyoqXG4gICAgICAgKiBJZiB0cnVlLCB0aGUgZWxlbWVudCB3aWxsIG5vdCBwcm9kdWNlIGEgcmlwcGxlIGVmZmVjdCB3aGVuIGludGVyYWN0ZWRcbiAgICAgICAqIHdpdGggdmlhIHRoZSBwb2ludGVyLlxuICAgICAgICovXG4gICAgICBub2luazoge1xuICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICBvYnNlcnZlcjogJ19ub2lua0NoYW5nZWQnXG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIEB0eXBlIHtFbGVtZW50fHVuZGVmaW5lZH1cbiAgICAgICAqL1xuICAgICAgX3JpcHBsZUNvbnRhaW5lcjoge1xuICAgICAgICB0eXBlOiBPYmplY3QsXG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEVuc3VyZXMgYSBgPHBhcGVyLXJpcHBsZT5gIGVsZW1lbnQgaXMgYXZhaWxhYmxlIHdoZW4gdGhlIGVsZW1lbnQgaXNcbiAgICAgKiBmb2N1c2VkLlxuICAgICAqL1xuICAgIF9idXR0b25TdGF0ZUNoYW5nZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuZm9jdXNlZCkge1xuICAgICAgICB0aGlzLmVuc3VyZVJpcHBsZSgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbiBhZGRpdGlvbiB0byB0aGUgZnVuY3Rpb25hbGl0eSBwcm92aWRlZCBpbiBgSXJvbkJ1dHRvblN0YXRlYCwgZW5zdXJlc1xuICAgICAqIGEgcmlwcGxlIGVmZmVjdCBpcyBjcmVhdGVkIHdoZW4gdGhlIGVsZW1lbnQgaXMgaW4gYSBgcHJlc3NlZGAgc3RhdGUuXG4gICAgICovXG4gICAgX2Rvd25IYW5kbGVyOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgUG9seW1lci5Jcm9uQnV0dG9uU3RhdGVJbXBsLl9kb3duSGFuZGxlci5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICAgIGlmICh0aGlzLnByZXNzZWQpIHtcbiAgICAgICAgdGhpcy5lbnN1cmVSaXBwbGUoZXZlbnQpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBFbnN1cmVzIHRoaXMgZWxlbWVudCBjb250YWlucyBhIHJpcHBsZSBlZmZlY3QuIEZvciBzdGFydHVwIGVmZmljaWVuY3lcbiAgICAgKiB0aGUgcmlwcGxlIGVmZmVjdCBpcyBkeW5hbWljYWxseSBvbiBkZW1hbmQgd2hlbiBuZWVkZWQuXG4gICAgICogQHBhcmFtIHshRXZlbnQ9fSBvcHRUcmlnZ2VyaW5nRXZlbnQgKG9wdGlvbmFsKSBldmVudCB0aGF0IHRyaWdnZXJlZCB0aGVcbiAgICAgKiByaXBwbGUuXG4gICAgICovXG4gICAgZW5zdXJlUmlwcGxlOiBmdW5jdGlvbihvcHRUcmlnZ2VyaW5nRXZlbnQpIHtcbiAgICAgIGlmICghdGhpcy5oYXNSaXBwbGUoKSkge1xuICAgICAgICB0aGlzLl9yaXBwbGUgPSB0aGlzLl9jcmVhdGVSaXBwbGUoKTtcbiAgICAgICAgdGhpcy5fcmlwcGxlLm5vaW5rID0gdGhpcy5ub2luaztcbiAgICAgICAgdmFyIHJpcHBsZUNvbnRhaW5lciA9IHRoaXMuX3JpcHBsZUNvbnRhaW5lciB8fCB0aGlzLnJvb3Q7XG4gICAgICAgIGlmIChyaXBwbGVDb250YWluZXIpIHtcbiAgICAgICAgICBQb2x5bWVyLmRvbShyaXBwbGVDb250YWluZXIpLmFwcGVuZENoaWxkKHRoaXMuX3JpcHBsZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdFRyaWdnZXJpbmdFdmVudCkge1xuICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBldmVudCBoYXBwZW5lZCBpbnNpZGUgb2YgdGhlIHJpcHBsZSBjb250YWluZXJcbiAgICAgICAgICAvLyBGYWxsIGJhY2sgdG8gaG9zdCBpbnN0ZWFkIG9mIHRoZSByb290IGJlY2F1c2UgZGlzdHJpYnV0ZWQgdGV4dFxuICAgICAgICAgIC8vIG5vZGVzIGFyZSBub3QgdmFsaWQgZXZlbnQgdGFyZ2V0c1xuICAgICAgICAgIHZhciBkb21Db250YWluZXIgPSBQb2x5bWVyLmRvbSh0aGlzLl9yaXBwbGVDb250YWluZXIgfHwgdGhpcyk7XG4gICAgICAgICAgdmFyIHRhcmdldCA9IFBvbHltZXIuZG9tKG9wdFRyaWdnZXJpbmdFdmVudCkucm9vdFRhcmdldDtcbiAgICAgICAgICBpZiAoZG9tQ29udGFpbmVyLmRlZXBDb250YWlucyggLyoqIEB0eXBlIHtOb2RlfSAqLyh0YXJnZXQpKSkge1xuICAgICAgICAgICAgdGhpcy5fcmlwcGxlLnVpRG93bkFjdGlvbihvcHRUcmlnZ2VyaW5nRXZlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBgPHBhcGVyLXJpcHBsZT5gIGVsZW1lbnQgdXNlZCBieSB0aGlzIGVsZW1lbnQgdG8gY3JlYXRlXG4gICAgICogcmlwcGxlIGVmZmVjdHMuIFRoZSBlbGVtZW50J3MgcmlwcGxlIGlzIGNyZWF0ZWQgb24gZGVtYW5kLCB3aGVuXG4gICAgICogbmVjZXNzYXJ5LCBhbmQgY2FsbGluZyB0aGlzIG1ldGhvZCB3aWxsIGZvcmNlIHRoZVxuICAgICAqIHJpcHBsZSB0byBiZSBjcmVhdGVkLlxuICAgICAqL1xuICAgIGdldFJpcHBsZTogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmVuc3VyZVJpcHBsZSgpO1xuICAgICAgcmV0dXJuIHRoaXMuX3JpcHBsZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgZWxlbWVudCBjdXJyZW50bHkgY29udGFpbnMgYSByaXBwbGUgZWZmZWN0LlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgaGFzUmlwcGxlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBCb29sZWFuKHRoaXMuX3JpcHBsZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSB0aGUgZWxlbWVudCdzIHJpcHBsZSBlZmZlY3QgdmlhIGNyZWF0aW5nIGEgYDxwYXBlci1yaXBwbGU+YC5cbiAgICAgKiBPdmVycmlkZSB0aGlzIG1ldGhvZCB0byBjdXN0b21pemUgdGhlIHJpcHBsZSBlbGVtZW50LlxuICAgICAqIEByZXR1cm4geyFQYXBlclJpcHBsZUVsZW1lbnR9IFJldHVybnMgYSBgPHBhcGVyLXJpcHBsZT5gIGVsZW1lbnQuXG4gICAgICovXG4gICAgX2NyZWF0ZVJpcHBsZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gLyoqIEB0eXBlIHshUGFwZXJSaXBwbGVFbGVtZW50fSAqLyAoXG4gICAgICAgICAgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncGFwZXItcmlwcGxlJykpO1xuICAgIH0sXG5cbiAgICBfbm9pbmtDaGFuZ2VkOiBmdW5jdGlvbihub2luaykge1xuICAgICAgaWYgKHRoaXMuaGFzUmlwcGxlKCkpIHtcbiAgICAgICAgdGhpcy5fcmlwcGxlLm5vaW5rID0gbm9pbms7XG4gICAgICB9XG4gICAgfVxuICB9O1xuPC9zY3JpcHQ+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL3BhcGVyLWJlaGF2aW9ycy9wYXBlci1yaXBwbGUtYmVoYXZpb3IuaHRtbCIsIlxucmVxdWlyZSgnLi4vYm93ZXJfY29tcG9uZW50cy9pcm9uLWljb25zZXQtc3ZnL2lyb24taWNvbnNldC1zdmcuaHRtbCcpO1xuXG5jb25zdCBSZWdpc3Rlckh0bWxUZW1wbGF0ZSA9IHJlcXVpcmUoJ3BvbHltZXItd2VicGFjay1sb2FkZXIvcmVnaXN0ZXItaHRtbC10ZW1wbGF0ZScpO1xuXG5SZWdpc3Rlckh0bWxUZW1wbGF0ZS50b0JvZHkoXCI8aXJvbi1pY29uc2V0LXN2ZyBuYW1lPW15LWljb25zIHNpemU9MjQ+IDxzdmc+IDxkZWZzPiA8ZyBpZD1hcnJvdy1iYWNrPiA8cGF0aCBkPVxcXCJNMjAgMTFINy44M2w1LjU5LTUuNTlMMTIgNGwtOCA4IDggOCAxLjQxLTEuNDFMNy44MyAxM0gyMHYtMnpcXFwiPjwvcGF0aD4gPC9nPiA8ZyBpZD1tZW51PiA8cGF0aCBkPVxcXCJNMyAxOGgxOHYtMkgzdjJ6bTAtNWgxOHYtMkgzdjJ6bTAtN3YyaDE4VjZIM3pcXFwiPjwvcGF0aD4gPC9nPiA8ZyBpZD1jaGV2cm9uLXJpZ2h0PiA8cGF0aCBkPVxcXCJNMTAgNkw4LjU5IDcuNDEgMTMuMTcgMTJsLTQuNTggNC41OUwxMCAxOGw2LTZ6XFxcIj48L3BhdGg+IDwvZz4gPGcgaWQ9Y2xvc2U+IDxwYXRoIGQ9XFxcIk0xOSA2LjQxTDE3LjU5IDUgMTIgMTAuNTkgNi40MSA1IDUgNi40MSAxMC41OSAxMiA1IDE3LjU5IDYuNDEgMTkgMTIgMTMuNDEgMTcuNTkgMTkgMTkgMTcuNTkgMTMuNDEgMTJ6XFxcIj48L3BhdGg+IDwvZz4gPGcgaWQ9c2VhcmNoPjxwYXRoIGQ9XFxcIk0xNS41IDE0aC0uNzlsLS4yOC0uMjdDMTUuNDEgMTIuNTkgMTYgMTEuMTEgMTYgOS41IDE2IDUuOTEgMTMuMDkgMyA5LjUgM1MzIDUuOTEgMyA5LjUgNS45MSAxNiA5LjUgMTZjMS42MSAwIDMuMDktLjU5IDQuMjMtMS41N2wuMjcuMjh2Ljc5bDUgNC45OUwyMC40OSAxOWwtNC45OS01em0tNiAwQzcuMDEgMTQgNSAxMS45OSA1IDkuNVM3LjAxIDUgOS41IDUgMTQgNy4wMSAxNCA5LjUgMTEuOTkgMTQgOS41IDE0elxcXCI+PC9wYXRoPiA8L2c+IDwvZGVmcz4gPC9zdmc+IDwvaXJvbi1pY29uc2V0LXN2Zz5cIik7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvbXktaWNvbnMuaHRtbCJdLCJzb3VyY2VSb290IjoiIn0=