/******/ (function(modules) { // webpackBootstrap
/******/ 	// install a JSONP callback for chunk loading
/******/ 	var parentJsonpFunction = window["webpackJsonp"];
/******/ 	window["webpackJsonp"] = function webpackJsonpCallback(chunkIds, moreModules, executeModules) {
/******/ 		// add "moreModules" to the modules object,
/******/ 		// then flag all "chunkIds" as loaded and fire callback
/******/ 		var moduleId, chunkId, i = 0, resolves = [], result;
/******/ 		for(;i < chunkIds.length; i++) {
/******/ 			chunkId = chunkIds[i];
/******/ 			if(installedChunks[chunkId]) {
/******/ 				resolves.push(installedChunks[chunkId][0]);
/******/ 			}
/******/ 			installedChunks[chunkId] = 0;
/******/ 		}
/******/ 		for(moduleId in moreModules) {
/******/ 			if(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
/******/ 				modules[moduleId] = moreModules[moduleId];
/******/ 			}
/******/ 		}
/******/ 		if(parentJsonpFunction) parentJsonpFunction(chunkIds, moreModules, executeModules);
/******/ 		while(resolves.length) {
/******/ 			resolves.shift()();
/******/ 		}
/******/
/******/ 	};
/******/
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// objects to store loaded and loading chunks
/******/ 	var installedChunks = {
/******/ 		6: 0
/******/ 	};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/ 	// This file contains only the entry chunk.
/******/ 	// The chunk loading function for additional chunks
/******/ 	__webpack_require__.e = function requireEnsure(chunkId) {
/******/ 		var installedChunkData = installedChunks[chunkId];
/******/ 		if(installedChunkData === 0) {
/******/ 			return new Promise(function(resolve) { resolve(); });
/******/ 		}
/******/
/******/ 		// a Promise means "currently loading".
/******/ 		if(installedChunkData) {
/******/ 			return installedChunkData[2];
/******/ 		}
/******/
/******/ 		// setup Promise in chunk cache
/******/ 		var promise = new Promise(function(resolve, reject) {
/******/ 			installedChunkData = installedChunks[chunkId] = [resolve, reject];
/******/ 		});
/******/ 		installedChunkData[2] = promise;
/******/
/******/ 		// start chunk loading
/******/ 		var head = document.getElementsByTagName('head')[0];
/******/ 		var script = document.createElement('script');
/******/ 		script.type = 'text/javascript';
/******/ 		script.charset = 'utf-8';
/******/ 		script.async = true;
/******/ 		script.timeout = 120000;
/******/
/******/ 		if (__webpack_require__.nc) {
/******/ 			script.setAttribute("nonce", __webpack_require__.nc);
/******/ 		}
/******/ 		script.src = __webpack_require__.p + "" + chunkId + ".bundle.js";
/******/ 		var timeout = setTimeout(onScriptComplete, 120000);
/******/ 		script.onerror = script.onload = onScriptComplete;
/******/ 		function onScriptComplete() {
/******/ 			// avoid mem leaks in IE.
/******/ 			script.onerror = script.onload = null;
/******/ 			clearTimeout(timeout);
/******/ 			var chunk = installedChunks[chunkId];
/******/ 			if(chunk !== 0) {
/******/ 				if(chunk) {
/******/ 					chunk[1](new Error('Loading chunk ' + chunkId + ' failed.'));
/******/ 				}
/******/ 				installedChunks[chunkId] = undefined;
/******/ 			}
/******/ 		};
/******/ 		head.appendChild(script);
/******/
/******/ 		return promise;
/******/ 	};
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "dist/";
/******/
/******/ 	// on error function for async loading
/******/ 	__webpack_require__.oe = function(err) { console.error(err); throw err; };
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 39);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(22);

__webpack_require__(54);

__webpack_require__(56);

__webpack_require__(57);

__webpack_require__(58);

__webpack_require__(59);

__webpack_require__(60);

__webpack_require__(61);

__webpack_require__(64);

// bc
Polymer.Base = Polymer.LegacyElementMixin(HTMLElement).prototype;

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


(function () {
  'use strict';

  var userPolymer = window.Polymer;

  /**
   * @namespace Polymer
   * @summary Polymer is a lightweight library built on top of the web
   *   standards-based Web Components API's, and makes it easy to build your
   *   own custom HTML elements.
   * @param {!PolymerInit} info Prototype for the custom element. It must contain
   *   an `is` property to specify the element name. Other properties populate
   *   the element prototype. The `properties`, `observers`, `hostAttributes`,
   *   and `listeners` properties are processed to create element features.
   * @return {!Object} Returns a custom element class for the given provided
   *   prototype `info` object. The name of the element if given by `info.is`.
   */
  window.Polymer = function (info) {
    return window.Polymer._polymerFn(info);
  };

  // support user settings on the Polymer object
  if (userPolymer) {
    Object.assign(Polymer, userPolymer);
  }

  // To be plugged by legacy implementation if loaded
  /* eslint-disable valid-jsdoc */
  /**
   * @param {!PolymerInit} info Prototype for the custom element. It must contain
   *   an `is` property to specify the element name. Other properties populate
   *   the element prototype. The `properties`, `observers`, `hostAttributes`,
   *   and `listeners` properties are processed to create element features.
   * @return {!Object} Returns a custom element class for the given provided
   *   prototype `info` object. The name of the element if given by `info.is`.
   */
  window.Polymer._polymerFn = function (info) {
    // eslint-disable-line no-unused-vars
    throw new Error('Load polymer.html to use the Polymer() function.');
  };
  /* eslint-enable */

  window.Polymer.version = '2.0.1';

  /* eslint-disable no-unused-vars */
  /*
  When using Closure Compiler, JSCompiler_renameProperty(property, object) is replaced by the munged name for object[property]
  We cannot alias this function, so we have to use a small shim that has the same behavior when not compiling.
  */
  window.JSCompiler_renameProperty = function (prop, obj) {
    return prop;
  };
  /* eslint-enable */
})();

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/* eslint-env browser */

var RegisterHtmlTemplate = function () {
  function RegisterHtmlTemplate() {
    _classCallCheck(this, RegisterHtmlTemplate);
  }

  _createClass(RegisterHtmlTemplate, null, [{
    key: 'register',

    /**
     * Create a `<template>` element to hold `<dom-module>` content.
     * This bit of code will execute in the context of the main document,
     * calling `importNode` on the `<template>`, which in turn triggers
     * the lifecycle of the `<dom-module>` and allows it to insert its
     * content into Polymer's global module map. When a Polymer element
     * boots up it will fetch its template from this module map.
     * https://github.com/Polymer/polymer/blob/master/lib/mixins/element-mixin.html#L501-L538
     * @param {string} val A `<dom-module>` as an HTML string
     */
    value: function register(val) {
      var content = void 0;
      var template = document.createElement('template');
      template.innerHTML = val;
      if (template.content) {
        content = template.content; // eslint-disable-line prefer-destructuring
      } else {
        content = document.createDocumentFragment();
        while (template.firstChild) {
          content.appendChild(template.firstChild);
        }
      }
      document.importNode(content, true);
    }
    /**
     * Content that will be injected into the main document. This is primarily
     * for things like `<iron-iconset>` and `<custom-style>` which do not have
     * templates but rely on HTML Imports ability to apply content to the main
     * document.
     * @param {string} val An HTML string
     */

  }, {
    key: 'toBody',
    value: function toBody(val) {
      var trimmedVal = val.trim();
      if (trimmedVal) {
        var div = document.createElement('div');
        div.innerHTML = trimmedVal;
        if (div.firstChild) {
          if (document.body) {
            document.body.insertBefore(div.firstChild, document.body.firstChild);
          } else {
            document.addEventListener('DOMContentLoaded', function () {
              document.body.insertBefore(div.firstChild, document.body.firstChild);
            });
          }
        }
      }
    }
  }]);

  return RegisterHtmlTemplate;
}();

module.exports = RegisterHtmlTemplate;

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(1);

(function () {

  'use strict';

  // unique global id for deduping mixins.

  var dedupeId = 0;

  /**
   * @constructor
   * @extends {Function}
   */
  function MixinFunction() {}
  /** @type {(WeakMap | undefined)} */
  MixinFunction.prototype.__mixinApplications;
  /** @type {(Object | undefined)} */
  MixinFunction.prototype.__mixinSet;

  /* eslint-disable valid-jsdoc */
  /**
   * Wraps an ES6 class expression mixin such that the mixin is only applied
   * if it has not already been applied its base argument.  Also memoizes mixin
   * applications.
   *
   * @memberof Polymer
   * @template T
   * @param {T} mixin ES6 class expression mixin to wrap
   * @suppress {invalidCasts}
   */
  Polymer.dedupingMixin = function (mixin) {
    var mixinApplications = /** @type {!MixinFunction} */mixin.__mixinApplications;
    if (!mixinApplications) {
      mixinApplications = new WeakMap();
      /** @type {!MixinFunction} */mixin.__mixinApplications = mixinApplications;
    }
    // maintain a unique id for each mixin
    var mixinDedupeId = dedupeId++;
    function dedupingMixin(base) {
      var baseSet = /** @type {!MixinFunction} */base.__mixinSet;
      if (baseSet && baseSet[mixinDedupeId]) {
        return base;
      }
      var map = mixinApplications;
      var extended = map.get(base);
      if (!extended) {
        extended = /** @type {!Function} */mixin(base);
        map.set(base, extended);
      }
      // copy inherited mixin set from the extended class, or the base class
      // NOTE: we avoid use of Set here because some browser (IE11)
      // cannot extend a base Set via the constructor.
      var mixinSet = Object.create( /** @type {!MixinFunction} */extended.__mixinSet || baseSet || null);
      mixinSet[mixinDedupeId] = true;
      /** @type {!MixinFunction} */extended.__mixinSet = mixinSet;
      return extended;
    }

    return dedupingMixin;
  };
  /* eslint-enable valid-jsdoc */
})();

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

__webpack_require__(36);

__webpack_require__(68);

/**
 * `Polymer.AppScrollEffectsBehavior` provides an interface that allows an element to use scrolls effects.
 *
 * ### Importing the app-layout effects
 *
 * app-layout provides a set of scroll effects that can be used by explicitly importing
 * `app-scroll-effects.html`:
 *
 * ```html
 * <link rel="import" href="/bower_components/app-layout/app-scroll-effects/app-scroll-effects.html">
 * ```
 *
 * The scroll effects can also be used by individually importing
 * `app-layout/app-scroll-effects/effects/[effectName].html`. For example:
 *
 * ```html
 *  <link rel="import" href="/bower_components/app-layout/app-scroll-effects/effects/waterfall.html">
 * ```
 *
 * ### Consuming effects
 *
 * Effects can be consumed via the `effects` property. For example:
 *
 * ```html
 * <app-header effects="waterfall"></app-header>
 * ```
 *
 * ### Creating scroll effects
 *
 * You may want to create a custom scroll effect if you need to modify the CSS of an element
 * based on the scroll position.
 *
 * A scroll effect definition is an object with `setUp()`, `tearDown()` and `run()` functions.
 *
 * To register the effect, you can use `Polymer.AppLayout.registerEffect(effectName, effectDef)`
 * For example, let's define an effect that resizes the header's logo:
 *
 * ```js
 * Polymer.AppLayout.registerEffect('resizable-logo', {
 *   setUp: function(config) {
 *     // the effect's config is passed to the setUp.
 *     this._fxResizeLogo = { logo: Polymer.dom(this).querySelector('[logo]') };
 *   },
 *
 *   run: function(progress) {
 *      // the progress of the effect
 *      this.transform('scale3d(' + progress + ', '+ progress +', 1)',  this._fxResizeLogo.logo);
 *   },
 *
 *   tearDown: function() {
 *      // clean up and reset of states
 *      delete this._fxResizeLogo;
 *   }
 * });
 * ```
 * Now, you can consume the effect:
 *
 * ```html
 * <app-header id="appHeader" effects="resizable-logo">
 *   <img logo src="logo.svg">
 * </app-header>
 * ```
 *
 * ### Imperative API
 *
 * ```js
 * var logoEffect = appHeader.createEffect('resizable-logo', effectConfig);
 * // run the effect: logoEffect.run(progress);
 * // tear down the effect: logoEffect.tearDown();
 * ```
 *
 * ### Configuring effects
 *
 * For effects installed via the `effects` property, their configuration can be set
 * via the `effectsConfig` property. For example:
 *
 * ```html
 * <app-header effects="waterfall"
 *   effects-config='{"waterfall": {"startsAt": 0, "endsAt": 0.5}}'>
 * </app-header>
 * ```
 *
 * All effects have a `startsAt` and `endsAt` config property. They specify at what
 * point the effect should start and end. This value goes from 0 to 1 inclusive.
 *
 * @polymerBehavior
 */
Polymer.AppScrollEffectsBehavior = [Polymer.IronScrollTargetBehavior, {

  properties: {

    /**
     * A space-separated list of the effects names that will be triggered when the user scrolls.
     * e.g. `waterfall parallax-background` installs the `waterfall` and `parallax-background`.
     */
    effects: {
      type: String
    },

    /**
     * An object that configurates the effects installed via the `effects` property. e.g.
     * ```js
     *  element.effectsConfig = {
     *   "blend-background": {
     *     "startsAt": 0.5
     *   }
     * };
     * ```
     * Every effect has at least two config properties: `startsAt` and `endsAt`.
     * These properties indicate when the event should start and end respectively
     * and relative to the overall element progress. So for example, if `blend-background`
     * starts at `0.5`, the effect will only start once the current element reaches 0.5
     * of its progress. In this context, the progress is a value in the range of `[0, 1]`
     * that indicates where this element is on the screen relative to the viewport.
     */
    effectsConfig: {
      type: Object,
      value: function value() {
        return {};
      }
    },

    /**
     * Disables CSS transitions and scroll effects on the element.
     */
    disabled: {
      type: Boolean,
      reflectToAttribute: true,
      value: false
    },

    /**
     * Allows to set a `scrollTop` threshold. When greater than 0, `thresholdTriggered`
     * is true only when the scroll target's `scrollTop` has reached this value.
     *
     * For example, if `threshold = 100`, `thresholdTriggered` is true when the `scrollTop`
     * is at least `100`.
     */
    threshold: {
      type: Number,
      value: 0
    },

    /**
     * True if the `scrollTop` threshold (set in `scrollTopThreshold`) has
     * been reached.
     */
    thresholdTriggered: {
      type: Boolean,
      notify: true,
      readOnly: true,
      reflectToAttribute: true
    }
  },

  observers: ['_effectsChanged(effects, effectsConfig, isAttached)'],

  /**
   * Updates the scroll state. This method should be overridden
   * by the consumer of this behavior.
   *
   * @method _updateScrollState
   */
  _updateScrollState: function _updateScrollState() {},

  /**
   * Returns true if the current element is on the screen.
   * That is, visible in the current viewport. This method should be
   * overridden by the consumer of this behavior.
   *
   * @method isOnScreen
   * @return {boolean}
   */
  isOnScreen: function isOnScreen() {
    return false;
  },

  /**
   * Returns true if there's content below the current element. This method
   * should be overridden by the consumer of this behavior.
   *
   * @method isContentBelow
   * @return {boolean}
   */
  isContentBelow: function isContentBelow() {
    return false;
  },

  /**
   * List of effects handlers that will take place during scroll.
   *
   * @type {Array<Function>}
   */
  _effectsRunFn: null,

  /**
   * List of the effects definitions installed via the `effects` property.
   *
   * @type {Array<Object>}
   */
  _effects: null,

  /**
   * The clamped value of `_scrollTop`.
   * @type number
   */
  get _clampedScrollTop() {
    return Math.max(0, this._scrollTop);
  },

  detached: function detached() {
    this._tearDownEffects();
  },

  /**
   * Creates an effect object from an effect's name that can be used to run
   * effects programmatically.
   *
   * @method createEffect
   * @param {string} effectName The effect's name registered via `Polymer.AppLayout.registerEffect`.
   * @param {Object=} effectConfig The effect config object. (Optional)
   * @return {Object} An effect object with the following functions:
   *
   *  * `effect.setUp()`, Sets up the requirements for the effect.
   *       This function is called automatically before the `effect` function returns.
   *  * `effect.run(progress, y)`, Runs the effect given a `progress`.
   *  * `effect.tearDown()`, Cleans up any DOM nodes or element references used by the effect.
   *
   * Example:
   * ```js
   * var parallax = element.createEffect('parallax-background');
   * // runs the effect
   * parallax.run(0.5, 0);
   * ```
   */
  createEffect: function createEffect(effectName, effectConfig) {
    var effectDef = Polymer.AppLayout._scrollEffects[effectName];
    if (!effectDef) {
      throw new ReferenceError(this._getUndefinedMsg(effectName));
    }
    var prop = this._boundEffect(effectDef, effectConfig || {});
    prop.setUp();
    return prop;
  },

  /**
   * Called when `effects` or `effectsConfig` changes.
   */
  _effectsChanged: function _effectsChanged(effects, effectsConfig, isAttached) {
    this._tearDownEffects();

    if (!effects || !isAttached) {
      return;
    }
    effects.split(' ').forEach(function (effectName) {
      var effectDef;
      if (effectName !== '') {
        if (effectDef = Polymer.AppLayout._scrollEffects[effectName]) {
          this._effects.push(this._boundEffect(effectDef, effectsConfig[effectName]));
        } else {
          console.warn(this._getUndefinedMsg(effectName));
        }
      }
    }, this);

    this._setUpEffect();
  },

  /**
   * Forces layout
   */
  _layoutIfDirty: function _layoutIfDirty() {
    return this.offsetWidth;
  },

  /**
   * Returns an effect object bound to the current context.
   *
   * @param {Object} effectDef
   * @param {Object=} effectsConfig The effect config object if the effect accepts config values. (Optional)
   */
  _boundEffect: function _boundEffect(effectDef, effectsConfig) {
    effectsConfig = effectsConfig || {};
    var startsAt = parseFloat(effectsConfig.startsAt || 0);
    var endsAt = parseFloat(effectsConfig.endsAt || 1);
    var deltaS = endsAt - startsAt;
    var noop = function noop() {};
    // fast path if possible
    var runFn = startsAt === 0 && endsAt === 1 ? effectDef.run : function (progress, y) {
      effectDef.run.call(this, Math.max(0, (progress - startsAt) / deltaS), y);
    };
    return {
      setUp: effectDef.setUp ? effectDef.setUp.bind(this, effectsConfig) : noop,
      run: effectDef.run ? runFn.bind(this) : noop,
      tearDown: effectDef.tearDown ? effectDef.tearDown.bind(this) : noop
    };
  },

  /**
   * Sets up the effects.
   */
  _setUpEffect: function _setUpEffect() {
    if (this.isAttached && this._effects) {
      this._effectsRunFn = [];
      this._effects.forEach(function (effectDef) {
        // install the effect only if no error was reported
        if (effectDef.setUp() !== false) {
          this._effectsRunFn.push(effectDef.run);
        }
      }, this);
    }
  },

  /**
   * Tears down the effects.
   */
  _tearDownEffects: function _tearDownEffects() {
    if (this._effects) {
      this._effects.forEach(function (effectDef) {
        effectDef.tearDown();
      });
    }
    this._effectsRunFn = [];
    this._effects = [];
  },

  /**
   * Runs the effects.
   *
   * @param {number} p The progress
   * @param {number} y The top position of the current element relative to the viewport.
   */
  _runEffects: function _runEffects(p, y) {
    if (this._effectsRunFn) {
      this._effectsRunFn.forEach(function (run) {
        run(p, y);
      });
    }
  },

  /**
   * Overrides the `_scrollHandler`.
   */
  _scrollHandler: function _scrollHandler() {
    if (!this.disabled) {
      var scrollTop = this._clampedScrollTop;
      this._updateScrollState(scrollTop);
      if (this.threshold > 0) {
        this._setThresholdTriggered(scrollTop >= this.threshold);
      }
    }
  },

  /**
   * Override this method to return a reference to a node in the local DOM.
   * The node is consumed by a scroll effect.
   *
   * @param {string} id The id for the node.
   */
  _getDOMRef: function _getDOMRef(id) {
    console.warn('_getDOMRef', '`' + id + '` is undefined');
  },

  _getUndefinedMsg: function _getUndefinedMsg(effectName) {
    return 'Scroll effect `' + effectName + '` is undefined. ' + 'Did you forget to import app-layout/app-scroll-effects/effects/' + effectName + '.html ?';
  }

}];

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

var RegisterHtmlTemplate = __webpack_require__(2);

RegisterHtmlTemplate.toBody("<custom-style> <style is=custom-style>html{--layout:{display:-ms-flexbox;display:-webkit-flex;display:flex};--layout-inline:{display:-ms-inline-flexbox;display:-webkit-inline-flex;display:inline-flex};--layout-horizontal:{@apply --layout;-ms-flex-direction:row;-webkit-flex-direction:row;flex-direction:row};--layout-horizontal-reverse:{@apply --layout;-ms-flex-direction:row-reverse;-webkit-flex-direction:row-reverse;flex-direction:row-reverse};--layout-vertical:{@apply --layout;-ms-flex-direction:column;-webkit-flex-direction:column;flex-direction:column};--layout-vertical-reverse:{@apply --layout;-ms-flex-direction:column-reverse;-webkit-flex-direction:column-reverse;flex-direction:column-reverse};--layout-wrap:{-ms-flex-wrap:wrap;-webkit-flex-wrap:wrap;flex-wrap:wrap};--layout-wrap-reverse:{-ms-flex-wrap:wrap-reverse;-webkit-flex-wrap:wrap-reverse;flex-wrap:wrap-reverse};--layout-flex-auto:{-ms-flex:1 1 auto;-webkit-flex:1 1 auto;flex:1 1 auto};--layout-flex-none:{-ms-flex:none;-webkit-flex:none;flex:none};--layout-flex:{-ms-flex:1 1 .000000001px;-webkit-flex:1;flex:1;-webkit-flex-basis:.000000001px;flex-basis:.000000001px};--layout-flex-2:{-ms-flex:2;-webkit-flex:2;flex:2};--layout-flex-3:{-ms-flex:3;-webkit-flex:3;flex:3};--layout-flex-4:{-ms-flex:4;-webkit-flex:4;flex:4};--layout-flex-5:{-ms-flex:5;-webkit-flex:5;flex:5};--layout-flex-6:{-ms-flex:6;-webkit-flex:6;flex:6};--layout-flex-7:{-ms-flex:7;-webkit-flex:7;flex:7};--layout-flex-8:{-ms-flex:8;-webkit-flex:8;flex:8};--layout-flex-9:{-ms-flex:9;-webkit-flex:9;flex:9};--layout-flex-10:{-ms-flex:10;-webkit-flex:10;flex:10};--layout-flex-11:{-ms-flex:11;-webkit-flex:11;flex:11};--layout-flex-12:{-ms-flex:12;-webkit-flex:12;flex:12};--layout-start:{-ms-flex-align:start;-webkit-align-items:flex-start;align-items:flex-start};--layout-center:{-ms-flex-align:center;-webkit-align-items:center;align-items:center};--layout-end:{-ms-flex-align:end;-webkit-align-items:flex-end;align-items:flex-end};--layout-baseline:{-ms-flex-align:baseline;-webkit-align-items:baseline;align-items:baseline};--layout-start-justified:{-ms-flex-pack:start;-webkit-justify-content:flex-start;justify-content:flex-start};--layout-center-justified:{-ms-flex-pack:center;-webkit-justify-content:center;justify-content:center};--layout-end-justified:{-ms-flex-pack:end;-webkit-justify-content:flex-end;justify-content:flex-end};--layout-around-justified:{-ms-flex-pack:distribute;-webkit-justify-content:space-around;justify-content:space-around};--layout-justified:{-ms-flex-pack:justify;-webkit-justify-content:space-between;justify-content:space-between};--layout-center-center:{@apply --layout-center;@apply --layout-center-justified;};--layout-self-start:{-ms-align-self:flex-start;-webkit-align-self:flex-start;align-self:flex-start};--layout-self-center:{-ms-align-self:center;-webkit-align-self:center;align-self:center};--layout-self-end:{-ms-align-self:flex-end;-webkit-align-self:flex-end;align-self:flex-end};--layout-self-stretch:{-ms-align-self:stretch;-webkit-align-self:stretch;align-self:stretch};--layout-self-baseline:{-ms-align-self:baseline;-webkit-align-self:baseline;align-self:baseline};--layout-start-aligned:{-ms-flex-line-pack:start;-ms-align-content:flex-start;-webkit-align-content:flex-start;align-content:flex-start};--layout-end-aligned:{-ms-flex-line-pack:end;-ms-align-content:flex-end;-webkit-align-content:flex-end;align-content:flex-end};--layout-center-aligned:{-ms-flex-line-pack:center;-ms-align-content:center;-webkit-align-content:center;align-content:center};--layout-between-aligned:{-ms-flex-line-pack:justify;-ms-align-content:space-between;-webkit-align-content:space-between;align-content:space-between};--layout-around-aligned:{-ms-flex-line-pack:distribute;-ms-align-content:space-around;-webkit-align-content:space-around;align-content:space-around};--layout-block:{display:block};--layout-invisible:{visibility:hidden!important};--layout-relative:{position:relative};--layout-fit:{position:absolute;top:0;right:0;bottom:0;left:0};--layout-scroll:{-webkit-overflow-scrolling:touch;overflow:auto};--layout-fullbleed:{margin:0;height:100vh};--layout-fixed-top:{position:fixed;top:0;left:0;right:0};--layout-fixed-right:{position:fixed;top:0;right:0;bottom:0};--layout-fixed-bottom:{position:fixed;right:0;bottom:0;left:0};--layout-fixed-left:{position:fixed;top:0;bottom:0;left:0};}</style> </custom-style>");

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(19);

(function () {
  'use strict';

  /**
   * Base class that provides the core API for Polymer's meta-programming
   * features including template stamping, data-binding, attribute deserialization,
   * and property change observation.
   *
   * @customElement
   * @polymer
   * @memberof Polymer
   * @constructor
   * @implements {Polymer_ElementMixin}
   * @extends HTMLElement
   * @appliesMixin Polymer.ElementMixin
   * @summary Custom element base class that provides the core API for Polymer's
   *   key meta-programming features including template stamping, data-binding,
   *   attribute deserialization, and property change observation
   */

  var Element = Polymer.ElementMixin(HTMLElement);
  /**
   * @constructor
   * @implements {Polymer_ElementMixin}
   * @extends {HTMLElement}
   */
  Polymer.Element = Element;
})();

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(1);

(function () {
  'use strict';

  var CSS_URL_RX = /(url\()([^)]*)(\))/g;
  var ABS_URL = /(^\/)|(^#)|(^[\w-\d]*:)/;
  var workingURL = void 0;
  var resolveDoc = void 0;
  /**
   * Resolves the given URL against the provided `baseUri'.
   *
   * @memberof Polymer.ResolveUrl
   * @param {string} url Input URL to resolve
   * @param {?string=} baseURI Base URI to resolve the URL against
   * @return {string} resolved URL
   */
  function resolveUrl(url, baseURI) {
    if (url && ABS_URL.test(url)) {
      return url;
    }
    // Lazy feature detection.
    if (workingURL === undefined) {
      workingURL = false;
      try {
        var u = new URL('b', 'http://a');
        u.pathname = 'c%20d';
        workingURL = u.href === 'http://a/c%20d';
      } catch (e) {
        // silently fail
      }
    }
    if (!baseURI) {
      baseURI = document.baseURI || window.location.href;
    }
    if (workingURL) {
      return new URL(url, baseURI).href;
    }
    // Fallback to creating an anchor into a disconnected document.
    if (!resolveDoc) {
      resolveDoc = document.implementation.createHTMLDocument('temp');
      resolveDoc.base = resolveDoc.createElement('base');
      resolveDoc.head.appendChild(resolveDoc.base);
      resolveDoc.anchor = resolveDoc.createElement('a');
      resolveDoc.body.appendChild(resolveDoc.anchor);
    }
    resolveDoc.base.href = baseURI;
    resolveDoc.anchor.href = url;
    return resolveDoc.anchor.href || url;
  }

  /**
   * Resolves any relative URL's in the given CSS text against the provided
   * `ownerDocument`'s `baseURI`.
   *
   * @memberof Polymer.ResolveUrl
   * @param {string} cssText CSS text to process
   * @param {string} baseURI Base URI to resolve the URL against
   * @return {string} Processed CSS text with resolved URL's
   */
  function resolveCss(cssText, baseURI) {
    return cssText.replace(CSS_URL_RX, function (m, pre, url, post) {
      return pre + '\'' + resolveUrl(url.replace(/["']/g, ''), baseURI) + '\'' + post;
    });
  }

  /**
   * Returns a path from a given `url`. The path includes the trailing
   * `/` from the url.
   *
   * @memberof Polymer.ResolveUrl
   * @param {string} url Input URL to transform
   * @return {string} resolved path
   */
  function pathFromUrl(url) {
    return url.substring(0, url.lastIndexOf('/') + 1);
  }

  /**
   * Module with utilities for resolving relative URL's.
   *
   * @namespace
   * @memberof Polymer
   * @summary Module with utilities for resolving relative URL's.
   */
  Polymer.ResolveUrl = {
    resolveCss: resolveCss,
    resolveUrl: resolveUrl,
    pathFromUrl: pathFromUrl
  };
})();

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(1);

(function () {

  'use strict';

  /** @typedef {{run: function(function(), number=):number, cancel: function(number)}} */

  var AsyncInterface = void 0; // eslint-disable-line no-unused-vars

  // Microtask implemented using Mutation Observer
  var microtaskCurrHandle = 0;
  var microtaskLastHandle = 0;
  var microtaskCallbacks = [];
  var microtaskNodeContent = 0;
  var microtaskNode = document.createTextNode('');
  new window.MutationObserver(microtaskFlush).observe(microtaskNode, { characterData: true });

  function microtaskFlush() {
    var len = microtaskCallbacks.length;
    for (var i = 0; i < len; i++) {
      var cb = microtaskCallbacks[i];
      if (cb) {
        try {
          cb();
        } catch (e) {
          setTimeout(function () {
            throw e;
          });
        }
      }
    }
    microtaskCallbacks.splice(0, len);
    microtaskLastHandle += len;
  }

  /**
   * Module that provides a number of strategies for enqueuing asynchronous
   * tasks.  Each sub-module provides a standard `run(fn)` interface that returns a
   * handle, and a `cancel(handle)` interface for canceling async tasks before
   * they run.
   *
   * @namespace
   * @memberof Polymer
   * @summary Module that provides a number of strategies for enqueuing asynchronous
   * tasks.
   */
  Polymer.Async = {

    /**
     * Async interface wrapper around `setTimeout`.
     *
     * @namespace
     * @memberof Polymer.Async
     * @summary Async interface wrapper around `setTimeout`.
     */
    timeOut: {
      /**
       * Returns a sub-module with the async interface providing the provided
       * delay.
       *
       * @memberof Polymer.Async.timeOut
       * @param {number} delay Time to wait before calling callbacks in ms
       * @return {AsyncInterface} An async timeout interface
       */
      after: function after(delay) {
        return {
          run: function run(fn) {
            return setTimeout(fn, delay);
          },

          cancel: window.clearTimeout.bind(window)
        };
      },

      /**
       * Enqueues a function called in the next task.
       *
       * @memberof Polymer.Async.timeOut
       * @param {Function} fn Callback to run
       * @return {number} Handle used for canceling task
       */
      run: window.setTimeout.bind(window),
      /**
       * Cancels a previously enqueued `timeOut` callback.
       *
       * @memberof Polymer.Async.timeOut
       * @param {number} handle Handle returned from `run` of callback to cancel
       */
      cancel: window.clearTimeout.bind(window)
    },

    /**
     * Async interface wrapper around `requestAnimationFrame`.
     *
     * @namespace
     * @memberof Polymer.Async
     * @summary Async interface wrapper around `requestAnimationFrame`.
     */
    animationFrame: {
      /**
       * Enqueues a function called at `requestAnimationFrame` timing.
       *
       * @memberof Polymer.Async.animationFrame
       * @param {Function} fn Callback to run
       * @return {number} Handle used for canceling task
       */
      run: window.requestAnimationFrame.bind(window),
      /**
       * Cancels a previously enqueued `animationFrame` callback.
       *
       * @memberof Polymer.Async.timeOut
       * @param {number} handle Handle returned from `run` of callback to cancel
       */
      cancel: window.cancelAnimationFrame.bind(window)
    },

    /**
     * Async interface wrapper around `requestIdleCallback`.  Falls back to
     * `setTimeout` on browsers that do not support `requestIdleCallback`.
     *
     * @namespace
     * @memberof Polymer.Async
     * @summary Async interface wrapper around `requestIdleCallback`.
     */
    idlePeriod: {
      /**
       * Enqueues a function called at `requestIdleCallback` timing.
       *
       * @memberof Polymer.Async.idlePeriod
       * @param {function(IdleDeadline)} fn Callback to run
       * @return {number} Handle used for canceling task
       */
      run: function run(fn) {
        return window.requestIdleCallback ? window.requestIdleCallback(fn) : window.setTimeout(fn, 16);
      },

      /**
       * Cancels a previously enqueued `idlePeriod` callback.
       *
       * @memberof Polymer.Async.idlePeriod
       * @param {number} handle Handle returned from `run` of callback to cancel
       */
      cancel: function cancel(handle) {
        window.cancelIdleCallback ? window.cancelIdleCallback(handle) : window.clearTimeout(handle);
      }
    },

    /**
     * Async interface for enqueueing callbacks that run at microtask timing.
     *
     * Note that microtask timing is achieved via a single `MutationObserver`,
     * and thus callbacks enqueued with this API will all run in a single
     * batch, and not interleaved with other microtasks such as promises.
     * Promises are avoided as an implementation choice for the time being
     * due to Safari bugs that cause Promises to lack microtask guarantees.
     *
     * @namespace
     * @memberof Polymer.Async
     * @summary Async interface for enqueueing callbacks that run at microtask
     *   timing.
     */
    microTask: {

      /**
       * Enqueues a function called at microtask timing.
       *
       * @memberof Polymer.Async.microTask
       * @param {Function} callback Callback to run
       * @return {number} Handle used for canceling task
       */
      run: function run(callback) {
        microtaskNode.textContent = microtaskNodeContent++;
        microtaskCallbacks.push(callback);
        return microtaskCurrHandle++;
      },


      /**
       * Cancels a previously enqueued `microTask` callback.
       *
       * @memberof Polymer.Async.microTask
       * @param {number} handle Handle returned from `run` of callback to cancel
       */
      cancel: function cancel(handle) {
        var idx = handle - microtaskLastHandle;
        if (idx >= 0) {
          if (!microtaskCallbacks[idx]) {
            throw new Error('invalid async handle: ' + handle);
          }
          microtaskCallbacks[idx] = null;
        }
      }
    }
  };
})();

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

__webpack_require__(3);

(function () {
  'use strict';

  // Common implementation for mixin & behavior

  function mutablePropertyChange(inst, property, value, old, mutableData) {
    var isObject = void 0;
    if (mutableData) {
      isObject = (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && value !== null;
      // Pull `old` for Objects from temp cache, but treat `null` as a primitive
      if (isObject) {
        old = inst.__dataTemp[property];
      }
    }
    // Strict equality check, but return false for NaN===NaN
    var shouldChange = old !== value && (old === old || value === value);
    // Objects are stored in temporary cache (cleared at end of
    // turn), which is used for dirty-checking
    if (isObject && shouldChange) {
      inst.__dataTemp[property] = value;
    }
    return shouldChange;
  }

  /**
   * Element class mixin to skip strict dirty-checking for objects and arrays
   * (always consider them to be "dirty"), for use on elements utilizing
   * `Polymer.PropertyEffects`
   *
   * By default, `Polymer.PropertyEffects` performs strict dirty checking on
   * objects, which means that any deep modifications to an object or array will
   * not be propagated unless "immutable" data patterns are used (i.e. all object
   * references from the root to the mutation were changed).
   *
   * Polymer also provides a proprietary data mutation and path notification API
   * (e.g. `notifyPath`, `set`, and array mutation API's) that allow efficient
   * mutation and notification of deep changes in an object graph to all elements
   * bound to the same object graph.
   *
   * In cases where neither immutable patterns nor the data mutation API can be
   * used, applying this mixin will cause Polymer to skip dirty checking for
   * objects and arrays (always consider them to be "dirty").  This allows a
   * user to make a deep modification to a bound object graph, and then either
   * simply re-set the object (e.g. `this.items = this.items`) or call `notifyPath`
   * (e.g. `this.notifyPath('items')`) to update the tree.  Note that all
   * elements that wish to be updated based on deep mutations must apply this
   * mixin or otherwise skip strict dirty checking for objects/arrays.
   *
   * In order to make the dirty check strategy configurable, see
   * `Polymer.OptionalMutableData`.
   *
   * Note, the performance characteristics of propagating large object graphs
   * will be worse as opposed to using strict dirty checking with immutable
   * patterns or Polymer's path notification API.
   *
   * @mixinFunction
   * @polymer
   * @memberof Polymer
   * @summary Element class mixin to skip strict dirty-checking for objects
   *   and arrays
   */
  Polymer.MutableData = Polymer.dedupingMixin(function (superClass) {

    /**
     * @polymer
     * @mixinClass
     * @implements {Polymer_MutableData}
     */
    var MutableData = function (_superClass) {
      _inherits(MutableData, _superClass);

      function MutableData() {
        _classCallCheck(this, MutableData);

        return _possibleConstructorReturn(this, (MutableData.__proto__ || Object.getPrototypeOf(MutableData)).apply(this, arguments));
      }

      _createClass(MutableData, [{
        key: '_shouldPropertyChange',

        /**
         * Overrides `Polymer.PropertyEffects` to provide option for skipping
         * strict equality checking for Objects and Arrays.
         *
         * This method pulls the value to dirty check against from the `__dataTemp`
         * cache (rather than the normal `__data` cache) for Objects.  Since the temp
         * cache is cleared at the end of a turn, this implementation allows
         * side-effects of deep object changes to be processed by re-setting the
         * same object (using the temp cache as an in-turn backstop to prevent
         * cycles due to 2-way notification).
         *
         * @param {string} property Property name
         * @param {*} value New property value
         * @param {*} old Previous property value
         * @return {boolean} Whether the property should be considered a change
         * @protected
         */
        value: function _shouldPropertyChange(property, value, old) {
          return mutablePropertyChange(this, property, value, old, true);
        }
      }]);

      return MutableData;
    }(superClass);
    /** @type {boolean} */


    MutableData.prototype.mutableData = false;

    return MutableData;
  });

  /**
   * Element class mixin to add the optional ability to skip strict
   * dirty-checking for objects and arrays (always consider them to be
   * "dirty") by setting a `mutable-data` attribute on an element instance.
   *
   * By default, `Polymer.PropertyEffects` performs strict dirty checking on
   * objects, which means that any deep modifications to an object or array will
   * not be propagated unless "immutable" data patterns are used (i.e. all object
   * references from the root to the mutation were changed).
   *
   * Polymer also provides a proprietary data mutation and path notification API
   * (e.g. `notifyPath`, `set`, and array mutation API's) that allow efficient
   * mutation and notification of deep changes in an object graph to all elements
   * bound to the same object graph.
   *
   * In cases where neither immutable patterns nor the data mutation API can be
   * used, applying this mixin will allow Polymer to skip dirty checking for
   * objects and arrays (always consider them to be "dirty").  This allows a
   * user to make a deep modification to a bound object graph, and then either
   * simply re-set the object (e.g. `this.items = this.items`) or call `notifyPath`
   * (e.g. `this.notifyPath('items')`) to update the tree.  Note that all
   * elements that wish to be updated based on deep mutations must apply this
   * mixin or otherwise skip strict dirty checking for objects/arrays.
   *
   * While this mixin adds the ability to forgo Object/Array dirty checking,
   * the `mutableData` flag defaults to false and must be set on the instance.
   *
   * Note, the performance characteristics of propagating large object graphs
   * will be worse by relying on `mutableData: true` as opposed to using
   * strict dirty checking with immutable patterns or Polymer's path notification
   * API.
   *
   * @mixinFunction
   * @polymer
   * @memberof Polymer
   * @summary Element class mixin to optionally skip strict dirty-checking
   *   for objects and arrays
   */
  Polymer.OptionalMutableData = Polymer.dedupingMixin(function (superClass) {

    /**
     * @mixinClass
     * @polymer
     * @implements {Polymer_OptionalMutableData}
     */
    var OptionalMutableData = function (_superClass2) {
      _inherits(OptionalMutableData, _superClass2);

      function OptionalMutableData() {
        _classCallCheck(this, OptionalMutableData);

        return _possibleConstructorReturn(this, (OptionalMutableData.__proto__ || Object.getPrototypeOf(OptionalMutableData)).apply(this, arguments));
      }

      _createClass(OptionalMutableData, [{
        key: '_shouldPropertyChange',


        /**
         * Overrides `Polymer.PropertyEffects` to provide option for skipping
         * strict equality checking for Objects and Arrays.
         *
         * When `this.mutableData` is true on this instance, this method
         * pulls the value to dirty check against from the `__dataTemp` cache
         * (rather than the normal `__data` cache) for Objects.  Since the temp
         * cache is cleared at the end of a turn, this implementation allows
         * side-effects of deep object changes to be processed by re-setting the
         * same object (using the temp cache as an in-turn backstop to prevent
         * cycles due to 2-way notification).
         *
         * @param {string} property Property name
         * @param {*} value New property value
         * @param {*} old Previous property value
         * @return {boolean} Whether the property should be considered a change
         * @protected
         */
        value: function _shouldPropertyChange(property, value, old) {
          return mutablePropertyChange(this, property, value, old, this.mutableData);
        }
      }], [{
        key: 'properties',
        get: function get() {
          return {
            /**
             * Instance-level flag for configuring the dirty-checking strategy
             * for this element.  When true, Objects and Arrays will skip dirty
             * checking, otherwise strict equality checking will be used.
             */
            mutableData: Boolean
          };
        }
      }]);

      return OptionalMutableData;
    }(superClass);

    return OptionalMutableData;
  });

  // Export for use by legacy behavior
  Polymer.MutableData._mutablePropertyChange = mutablePropertyChange;
})();

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(1);

(function () {
  'use strict';

  var caseMap = {};
  var DASH_TO_CAMEL = /-[a-z]/g;
  var CAMEL_TO_DASH = /([A-Z])/g;

  /**
   * Module with utilities for converting between "dash-case" and "camelCase"
   * identifiers.
   *
   * @namespace
   * @memberof Polymer
   * @summary Module that provides utilities for converting between "dash-case"
   *   and "camelCase".
   */
  var CaseMap = {

    /**
     * Converts "dash-case" identifier (e.g. `foo-bar-baz`) to "camelCase"
     * (e.g. `fooBarBaz`).
     *
     * @memberof Polymer.CaseMap
     * @param {string} dash Dash-case identifier
     * @return {string} Camel-case representation of the identifier
     */
    dashToCamelCase: function dashToCamelCase(dash) {
      return caseMap[dash] || (caseMap[dash] = dash.indexOf('-') < 0 ? dash : dash.replace(DASH_TO_CAMEL, function (m) {
        return m[1].toUpperCase();
      }));
    },


    /**
     * Converts "camelCase" identifier (e.g. `fooBarBaz`) to "dash-case"
     * (e.g. `foo-bar-baz`).
     *
     * @memberof Polymer.CaseMap
     * @param {string} camel Camel-case identifier
     * @return {string} Dash-case representation of the identifier
     */
    camelToDashCase: function camelToDashCase(camel) {
      return caseMap[camel] || (caseMap[camel] = camel.replace(CAMEL_TO_DASH, '-$1').toLowerCase());
    }
  };

  Polymer.CaseMap = CaseMap;
})();

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

__webpack_require__(1);

__webpack_require__(3);

__webpack_require__(42);

__webpack_require__(10);

__webpack_require__(43);

__webpack_require__(44);

(function () {

  'use strict';

  /** @const {Object} */

  var CaseMap = Polymer.CaseMap;

  // Monotonically increasing unique ID used for de-duping effects triggered
  // from multiple properties in the same turn
  var dedupeId = 0;

  /**
   * Property effect types; effects are stored on the prototype using these keys
   * @enum {string}
   */
  var TYPES = {
    COMPUTE: '__computeEffects',
    REFLECT: '__reflectEffects',
    NOTIFY: '__notifyEffects',
    PROPAGATE: '__propagateEffects',
    OBSERVE: '__observeEffects',
    READ_ONLY: '__readOnly'

    /**
     * @typedef {{
     * name: (string | undefined),
     * structured: (boolean | undefined),
     * wildcard: (boolean | undefined)
     * }}
     */
  };var DataTrigger = void 0; //eslint-disable-line no-unused-vars

  /**
   * @typedef {{
   * info: ?,
   * trigger: (!DataTrigger | undefined),
   * fn: (!Function | undefined)
   * }}
   */
  var DataEffect = void 0; //eslint-disable-line no-unused-vars

  var PropertyEffectsType = void 0; //eslint-disable-line no-unused-vars

  /**
   * Ensures that the model has an own-property map of effects for the given type.
   * The model may be a prototype or an instance.
   *
   * Property effects are stored as arrays of effects by property in a map,
   * by named type on the model. e.g.
   *
   *   __computeEffects: {
   *     foo: [ ... ],
   *     bar: [ ... ]
   *   }
   *
   * If the model does not yet have an effect map for the type, one is created
   * and returned.  If it does, but it is not an own property (i.e. the
   * prototype had effects), the the map is deeply cloned and the copy is
   * set on the model and returned, ready for new effects to be added.
   *
   * @param {Object} model Prototype or instance
   * @param {string} type Property effect type
   * @return {Object} The own-property map of effects for the given type
   * @private
   */
  function ensureOwnEffectMap(model, type) {
    var effects = model[type];
    if (!effects) {
      effects = model[type] = {};
    } else if (!model.hasOwnProperty(type)) {
      effects = model[type] = Object.create(model[type]);
      for (var p in effects) {
        var protoFx = effects[p];
        var instFx = effects[p] = Array(protoFx.length);
        for (var i = 0; i < protoFx.length; i++) {
          instFx[i] = protoFx[i];
        }
      }
    }
    return effects;
  }

  // -- effects ----------------------------------------------

  /**
   * Runs all effects of a given type for the given set of property changes
   * on an instance.
   *
   * @param {!PropertyEffectsType} inst The instance with effects to run
   * @param {Object} effects Object map of property-to-Array of effects
   * @param {Object} props Bag of current property changes
   * @param {Object=} oldProps Bag of previous values for changed properties
   * @param {boolean=} hasPaths True with `props` contains one or more paths
   * @param {*=} extraArgs Additional metadata to pass to effect function
   * @return {boolean} True if an effect ran for this property
   * @private
   */
  function runEffects(inst, effects, props, oldProps, hasPaths, extraArgs) {
    if (effects) {
      var ran = false;
      var id = dedupeId++;
      for (var prop in props) {
        if (runEffectsForProperty(inst, effects, id, prop, props, oldProps, hasPaths, extraArgs)) {
          ran = true;
        }
      }
      return ran;
    }
    return false;
  }

  /**
   * Runs a list of effects for a given property.
   *
   * @param {!PropertyEffectsType} inst The instance with effects to run
   * @param {Object} effects Object map of property-to-Array of effects
   * @param {number} dedupeId Counter used for de-duping effects
   * @param {string} prop Name of changed property
   * @param {*} props Changed properties
   * @param {*} oldProps Old properties
   * @param {boolean=} hasPaths True with `props` contains one or more paths
   * @param {*=} extraArgs Additional metadata to pass to effect function
   * @return {boolean} True if an effect ran for this property
   * @private
   */
  function runEffectsForProperty(inst, effects, dedupeId, prop, props, oldProps, hasPaths, extraArgs) {
    var ran = false;
    var rootProperty = hasPaths ? Polymer.Path.root(prop) : prop;
    var fxs = effects[rootProperty];
    if (fxs) {
      for (var i = 0, l = fxs.length, fx; i < l && (fx = fxs[i]); i++) {
        if ((!fx.info || fx.info.lastRun !== dedupeId) && (!hasPaths || pathMatchesTrigger(prop, fx.trigger))) {
          if (fx.info) {
            fx.info.lastRun = dedupeId;
          }
          fx.fn(inst, prop, props, oldProps, fx.info, hasPaths, extraArgs);
          ran = true;
        }
      }
    }
    return ran;
  }

  /**
   * Determines whether a property/path that has changed matches the trigger
   * criteria for an effect.  A trigger is a descriptor with the following
   * structure, which matches the descriptors returned from `parseArg`.
   * e.g. for `foo.bar.*`:
   * ```
   * trigger: {
   *   name: 'a.b',
   *   structured: true,
   *   wildcard: true
   * }
   * ```
   * If no trigger is given, the path is deemed to match.
   *
   * @param {string} path Path or property that changed
   * @param {DataTrigger} trigger Descriptor
   * @return {boolean} Whether the path matched the trigger
   */
  function pathMatchesTrigger(path, trigger) {
    if (trigger) {
      var triggerPath = trigger.name;
      return triggerPath == path || trigger.structured && Polymer.Path.isAncestor(triggerPath, path) || trigger.wildcard && Polymer.Path.isDescendant(triggerPath, path);
    } else {
      return true;
    }
  }

  /**
   * Implements the "observer" effect.
   *
   * Calls the method with `info.methodName` on the instance, passing the
   * new and old values.
   *
   * @param {!PropertyEffectsType} inst The instance the effect will be run on
   * @param {string} property Name of property
   * @param {Object} props Bag of current property changes
   * @param {Object} oldProps Bag of previous values for changed properties
   * @param {?} info Effect metadata
   * @private
   */
  function runObserverEffect(inst, property, props, oldProps, info) {
    var fn = inst[info.methodName];
    var changedProp = info.property;
    if (fn) {
      fn.call(inst, inst.__data[changedProp], oldProps[changedProp]);
    } else if (!info.dynamicFn) {
      console.warn('observer method `' + info.methodName + '` not defined');
    }
  }

  /**
   * Runs "notify" effects for a set of changed properties.
   *
   * This method differs from the generic `runEffects` method in that it
   * will dispatch path notification events in the case that the property
   * changed was a path and the root property for that path didn't have a
   * "notify" effect.  This is to maintain 1.0 behavior that did not require
   * `notify: true` to ensure object sub-property notifications were
   * sent.
   *
   * @param {!PropertyEffectsType} inst The instance with effects to run
   * @param {Object} notifyProps Bag of properties to notify
   * @param {Object} props Bag of current property changes
   * @param {Object} oldProps Bag of previous values for changed properties
   * @param {boolean} hasPaths True with `props` contains one or more paths
   * @private
   */
  function runNotifyEffects(inst, notifyProps, props, oldProps, hasPaths) {
    // Notify
    var fxs = inst[TYPES.NOTIFY];
    var notified = void 0;
    var id = dedupeId++;
    // Try normal notify effects; if none, fall back to try path notification
    for (var prop in notifyProps) {
      if (notifyProps[prop]) {
        if (fxs && runEffectsForProperty(inst, fxs, id, prop, props, oldProps, hasPaths)) {
          notified = true;
        } else if (hasPaths && notifyPath(inst, prop, props)) {
          notified = true;
        }
      }
    }
    // Flush host if we actually notified and host was batching
    // And the host has already initialized clients; this prevents
    // an issue with a host observing data changes before clients are ready.
    var host = void 0;
    if (notified && (host = inst.__dataHost) && host._invalidateProperties) {
      host._invalidateProperties();
    }
  }

  /**
   * Dispatches {property}-changed events with path information in the detail
   * object to indicate a sub-path of the property was changed.
   *
   * @param {!PropertyEffectsType} inst The element from which to fire the event
   * @param {string} path The path that was changed
   * @param {Object} props Bag of current property changes
   * @return {boolean} Returns true if the path was notified
   * @private
   */
  function notifyPath(inst, path, props) {
    var rootProperty = Polymer.Path.root(path);
    if (rootProperty !== path) {
      var eventName = Polymer.CaseMap.camelToDashCase(rootProperty) + '-changed';
      dispatchNotifyEvent(inst, eventName, props[path], path);
      return true;
    }
    return false;
  }

  /**
   * Dispatches {property}-changed events to indicate a property (or path)
   * changed.
   *
   * @param {!PropertyEffectsType} inst The element from which to fire the event
   * @param {string} eventName The name of the event to send ('{property}-changed')
   * @param {*} value The value of the changed property
   * @param {string | null | undefined} path If a sub-path of this property changed, the path
   *   that changed (optional).
   * @private
   * @suppress {invalidCasts}
   */
  function dispatchNotifyEvent(inst, eventName, value, path) {
    var detail = {
      value: value,
      queueProperty: true
    };
    if (path) {
      detail.path = path;
    }
    /** @type {!HTMLElement} */inst.dispatchEvent(new CustomEvent(eventName, { detail: detail }));
  }

  /**
   * Implements the "notify" effect.
   *
   * Dispatches a non-bubbling event named `info.eventName` on the instance
   * with a detail object containing the new `value`.
   *
   * @param {!PropertyEffectsType} inst The instance the effect will be run on
   * @param {string} property Name of property
   * @param {Object} props Bag of current property changes
   * @param {Object} oldProps Bag of previous values for changed properties
   * @param {?} info Effect metadata
   * @param {boolean} hasPaths True with `props` contains one or more paths
   * @private
   */
  function runNotifyEffect(inst, property, props, oldProps, info, hasPaths) {
    var rootProperty = hasPaths ? Polymer.Path.root(property) : property;
    var path = rootProperty != property ? property : null;
    var value = path ? Polymer.Path.get(inst, path) : inst.__data[property];
    if (path && value === undefined) {
      value = props[property]; // specifically for .splices
    }
    dispatchNotifyEvent(inst, info.eventName, value, path);
  }

  /**
   * Handler function for 2-way notification events. Receives context
   * information captured in the `addNotifyListener` closure from the
   * `__notifyListeners` metadata.
   *
   * Sets the value of the notified property to the host property or path.  If
   * the event contained path information, translate that path to the host
   * scope's name for that path first.
   *
   * @param {CustomEvent} event Notification event (e.g. '<property>-changed')
   * @param {!PropertyEffectsType} inst Host element instance handling the notification event
   * @param {string} fromProp Child element property that was bound
   * @param {string} toPath Host property/path that was bound
   * @param {boolean} negate Whether the binding was negated
   * @private
   */
  function handleNotification(event, inst, fromProp, toPath, negate) {
    var value = void 0;
    var detail = /** @type {Object} */event.detail;
    var fromPath = detail && detail.path;
    if (fromPath) {
      toPath = Polymer.Path.translate(fromProp, toPath, fromPath);
      value = detail && detail.value;
    } else {
      value = event.target[fromProp];
    }
    value = negate ? !value : value;
    if (!inst[TYPES.READ_ONLY] || !inst[TYPES.READ_ONLY][toPath]) {
      if (inst._setPendingPropertyOrPath(toPath, value, true, Boolean(fromPath)) && (!detail || !detail.queueProperty)) {
        inst._invalidateProperties();
      }
    }
  }

  /**
   * Implements the "reflect" effect.
   *
   * Sets the attribute named `info.attrName` to the given property value.
   *
   * @param {!PropertyEffectsType} inst The instance the effect will be run on
   * @param {string} property Name of property
   * @param {Object} props Bag of current property changes
   * @param {Object} oldProps Bag of previous values for changed properties
   * @param {?} info Effect metadata
   * @private
   */
  function runReflectEffect(inst, property, props, oldProps, info) {
    var value = inst.__data[property];
    if (Polymer.sanitizeDOMValue) {
      value = Polymer.sanitizeDOMValue(value, info.attrName, 'attribute', /** @type {Node} */inst);
    }
    inst._propertyToAttribute(property, info.attrName, value);
  }

  /**
   * Runs "computed" effects for a set of changed properties.
   *
   * This method differs from the generic `runEffects` method in that it
   * continues to run computed effects based on the output of each pass until
   * there are no more newly computed properties.  This ensures that all
   * properties that will be computed by the initial set of changes are
   * computed before other effects (binding propagation, observers, and notify)
   * run.
   *
   * @param {!PropertyEffectsType} inst The instance the effect will be run on
   * @param {!Object} changedProps Bag of changed properties
   * @param {!Object} oldProps Bag of previous values for changed properties
   * @param {boolean} hasPaths True with `props` contains one or more paths
   * @private
   */
  function runComputedEffects(inst, changedProps, oldProps, hasPaths) {
    var computeEffects = inst[TYPES.COMPUTE];
    if (computeEffects) {
      var inputProps = changedProps;
      while (runEffects(inst, computeEffects, inputProps, oldProps, hasPaths)) {
        Object.assign(oldProps, inst.__dataOld);
        Object.assign(changedProps, inst.__dataPending);
        inputProps = inst.__dataPending;
        inst.__dataPending = null;
      }
    }
  }

  /**
   * Implements the "computed property" effect by running the method with the
   * values of the arguments specified in the `info` object and setting the
   * return value to the computed property specified.
   *
   * @param {!PropertyEffectsType} inst The instance the effect will be run on
   * @param {string} property Name of property
   * @param {Object} props Bag of current property changes
   * @param {Object} oldProps Bag of previous values for changed properties
   * @param {?} info Effect metadata
   * @private
   */
  function runComputedEffect(inst, property, props, oldProps, info) {
    var result = runMethodEffect(inst, property, props, oldProps, info);
    var computedProp = info.methodInfo;
    if (inst.__dataHasAccessor && inst.__dataHasAccessor[computedProp]) {
      inst._setPendingProperty(computedProp, result, true);
    } else {
      inst[computedProp] = result;
    }
  }

  /**
   * Computes path changes based on path links set up using the `linkPaths`
   * API.
   *
   * @param {!PropertyEffectsType} inst The instance whose props are changing
   * @param {string | !Array<(string|number)>} path Path that has changed
   * @param {*} value Value of changed path
   * @private
   */
  function computeLinkedPaths(inst, path, value) {
    var links = inst.__dataLinkedPaths;
    if (links) {
      var link = void 0;
      for (var a in links) {
        var b = links[a];
        if (Polymer.Path.isDescendant(a, path)) {
          link = Polymer.Path.translate(a, b, path);
          inst._setPendingPropertyOrPath(link, value, true, true);
        } else if (Polymer.Path.isDescendant(b, path)) {
          link = Polymer.Path.translate(b, a, path);
          inst._setPendingPropertyOrPath(link, value, true, true);
        }
      }
    }
  }

  // -- bindings ----------------------------------------------

  /**
   * Adds binding metadata to the current `nodeInfo`, and binding effects
   * for all part dependencies to `templateInfo`.
   *
   * @param {Function} constructor Class that `_parseTemplate` is currently
   *   running on
   * @param {TemplateInfo} templateInfo Template metadata for current template
   * @param {NodeInfo} nodeInfo Node metadata for current template node
   * @param {string} kind Binding kind, either 'property', 'attribute', or 'text'
   * @param {string} target Target property name
   * @param {!Array<!BindingPart>} parts Array of binding part metadata
   * @param {string=} literal Literal text surrounding binding parts (specified
   *   only for 'property' bindings, since these must be initialized as part
   *   of boot-up)
   * @private
   */
  function addBinding(constructor, templateInfo, nodeInfo, kind, target, parts, literal) {
    // Create binding metadata and add to nodeInfo
    nodeInfo.bindings = nodeInfo.bindings || [];
    var /** Binding */binding = { kind: kind, target: target, parts: parts, literal: literal, isCompound: parts.length !== 1 };
    nodeInfo.bindings.push(binding);
    // Add listener info to binding metadata
    if (shouldAddListener(binding)) {
      var _binding$parts$ = binding.parts[0],
          event = _binding$parts$.event,
          negate = _binding$parts$.negate;

      binding.listenerEvent = event || CaseMap.camelToDashCase(target) + '-changed';
      binding.listenerNegate = negate;
    }
    // Add "propagate" property effects to templateInfo
    var index = templateInfo.nodeInfoList.length;
    for (var i = 0; i < binding.parts.length; i++) {
      var part = binding.parts[i];
      part.compoundIndex = i;
      addEffectForBindingPart(constructor, templateInfo, binding, part, index);
    }
  }

  /**
   * Adds property effects to the given `templateInfo` for the given binding
   * part.
   *
   * @param {Function} constructor Class that `_parseTemplate` is currently
   *   running on
   * @param {TemplateInfo} templateInfo Template metadata for current template
   * @param {!Binding} binding Binding metadata
   * @param {!BindingPart} part Binding part metadata
   * @param {number} index Index into `nodeInfoList` for this node
   */
  function addEffectForBindingPart(constructor, templateInfo, binding, part, index) {
    if (!part.literal) {
      if (binding.kind === 'attribute' && binding.target[0] === '-') {
        console.warn('Cannot set attribute ' + binding.target + ' because "-" is not a valid attribute starting character');
      } else {
        var dependencies = part.dependencies;
        var info = { index: index, binding: binding, part: part, evaluator: constructor };
        for (var j = 0; j < dependencies.length; j++) {
          var trigger = dependencies[j];
          if (typeof trigger == 'string') {
            trigger = parseArg(trigger);
            trigger.wildcard = true;
          }
          constructor._addTemplatePropertyEffect(templateInfo, trigger.rootProperty, {
            fn: runBindingEffect,
            info: info, trigger: trigger
          });
        }
      }
    }
  }

  /**
   * Implements the "binding" (property/path binding) effect.
   *
   * Note that binding syntax is overridable via `_parseBindings` and
   * `_evaluateBinding`.  This method will call `_evaluateBinding` for any
   * non-literal parts returned from `_parseBindings`.  However,
   * there is no support for _path_ bindings via custom binding parts,
   * as this is specific to Polymer's path binding syntax.
   *
   * @param {!PropertyEffectsType} inst The instance the effect will be run on
   * @param {string} path Name of property
   * @param {Object} props Bag of current property changes
   * @param {Object} oldProps Bag of previous values for changed properties
   * @param {?} info Effect metadata
   * @param {boolean} hasPaths True with `props` contains one or more paths
   * @param {Array} nodeList List of nodes associated with `nodeInfoList` template
   *   metadata
   * @private
   */
  function runBindingEffect(inst, path, props, oldProps, info, hasPaths, nodeList) {
    var node = nodeList[info.index];
    var binding = info.binding;
    var part = info.part;
    // Subpath notification: transform path and set to client
    // e.g.: foo="{{obj.sub}}", path: 'obj.sub.prop', set 'foo.prop'=obj.sub.prop
    if (hasPaths && part.source && path.length > part.source.length && binding.kind == 'property' && !binding.isCompound && node.__dataHasAccessor && node.__dataHasAccessor[binding.target]) {
      var value = props[path];
      path = Polymer.Path.translate(part.source, binding.target, path);
      if (node._setPendingPropertyOrPath(path, value, false, true)) {
        inst._enqueueClient(node);
      }
    } else {
      var _value = info.evaluator._evaluateBinding(inst, part, path, props, oldProps, hasPaths);
      // Propagate value to child
      applyBindingValue(inst, node, binding, part, _value);
    }
  }

  /**
   * Sets the value for an "binding" (binding) effect to a node,
   * either as a property or attribute.
   *
   * @param {!PropertyEffectsType} inst The instance owning the binding effect
   * @param {Node} node Target node for binding
   * @param {!Binding} binding Binding metadata
   * @param {!BindingPart} part Binding part metadata
   * @param {*} value Value to set
   * @private
   */
  function applyBindingValue(inst, node, binding, part, value) {
    value = computeBindingValue(node, value, binding, part);
    if (Polymer.sanitizeDOMValue) {
      value = Polymer.sanitizeDOMValue(value, binding.target, binding.kind, node);
    }
    if (binding.kind == 'attribute') {
      // Attribute binding
      inst._valueToNodeAttribute( /** @type {Element} */node, value, binding.target);
    } else {
      // Property binding
      var prop = binding.target;
      if (node.__dataHasAccessor && node.__dataHasAccessor[prop]) {
        if (!node[TYPES.READ_ONLY] || !node[TYPES.READ_ONLY][prop]) {
          if (node._setPendingProperty(prop, value)) {
            inst._enqueueClient(node);
          }
        }
      } else {
        inst._setUnmanagedPropertyToNode(node, prop, value);
      }
    }
  }

  /**
   * Transforms an "binding" effect value based on compound & negation
   * effect metadata, as well as handling for special-case properties
   *
   * @param {Node} node Node the value will be set to
   * @param {*} value Value to set
   * @param {!Binding} binding Binding metadata
   * @param {!BindingPart} part Binding part metadata
   * @return {*} Transformed value to set
   * @private
   */
  function computeBindingValue(node, value, binding, part) {
    if (binding.isCompound) {
      var storage = node.__dataCompoundStorage[binding.target];
      storage[part.compoundIndex] = value;
      value = storage.join('');
    }
    if (binding.kind !== 'attribute') {
      // Some browsers serialize `undefined` to `"undefined"`
      if (binding.target === 'textContent' || node.localName == 'input' && binding.target == 'value') {
        value = value == undefined ? '' : value;
      }
    }
    return value;
  }

  /**
   * Returns true if a binding's metadata meets all the requirements to allow
   * 2-way binding, and therefore a `<property>-changed` event listener should be
   * added:
   * - used curly braces
   * - is a property (not attribute) binding
   * - is not a textContent binding
   * - is not compound
   *
   * @param {!Binding} binding Binding metadata
   * @return {boolean} True if 2-way listener should be added
   * @private
   */
  function shouldAddListener(binding) {
    return Boolean(binding.target) && binding.kind != 'attribute' && binding.kind != 'text' && !binding.isCompound && binding.parts[0].mode === '{';
  }

  /**
   * Setup compound binding storage structures, notify listeners, and dataHost
   * references onto the bound nodeList.
   *
   * @param {!PropertyEffectsType} inst Instance that bas been previously bound
   * @param {TemplateInfo} templateInfo Template metadata
   * @private
   */
  function setupBindings(inst, templateInfo) {
    // Setup compound storage, dataHost, and notify listeners
    var nodeList = templateInfo.nodeList,
        nodeInfoList = templateInfo.nodeInfoList;

    if (nodeInfoList.length) {
      for (var i = 0; i < nodeInfoList.length; i++) {
        var info = nodeInfoList[i];
        var node = nodeList[i];
        var bindings = info.bindings;
        if (bindings) {
          for (var _i = 0; _i < bindings.length; _i++) {
            var binding = bindings[_i];
            setupCompoundStorage(node, binding);
            addNotifyListener(node, inst, binding);
          }
        }
        node.__dataHost = inst;
      }
    }
  }

  /**
   * Initializes `__dataCompoundStorage` local storage on a bound node with
   * initial literal data for compound bindings, and sets the joined
   * literal parts to the bound property.
   *
   * When changes to compound parts occur, they are first set into the compound
   * storage array for that property, and then the array is joined to result in
   * the final value set to the property/attribute.
   *
   * @param {Node} node Bound node to initialize
   * @param {Binding} binding Binding metadata
   * @private
   */
  function setupCompoundStorage(node, binding) {
    if (binding.isCompound) {
      // Create compound storage map
      var storage = node.__dataCompoundStorage || (node.__dataCompoundStorage = {});
      var parts = binding.parts;
      // Copy literals from parts into storage for this binding
      var literals = new Array(parts.length);
      for (var j = 0; j < parts.length; j++) {
        literals[j] = parts[j].literal;
      }
      var target = binding.target;
      storage[target] = literals;
      // Configure properties with their literal parts
      if (binding.literal && binding.kind == 'property') {
        node[target] = binding.literal;
      }
    }
  }

  /**
   * Adds a 2-way binding notification event listener to the node specified
   *
   * @param {Object} node Child element to add listener to
   * @param {!PropertyEffectsType} inst Host element instance to handle notification event
   * @param {Binding} binding Binding metadata
   * @private
   */
  function addNotifyListener(node, inst, binding) {
    if (binding.listenerEvent) {
      var part = binding.parts[0];
      node.addEventListener(binding.listenerEvent, function (e) {
        handleNotification(e, inst, binding.target, part.source, part.negate);
      });
    }
  }

  // -- for method-based effects (complexObserver & computed) --------------

  /**
   * Adds property effects for each argument in the method signature (and
   * optionally, for the method name if `dynamic` is true) that calls the
   * provided effect function.
   *
   * @param {Element | Object} model Prototype or instance
   * @param {!MethodSignature} sig Method signature metadata
   * @param {string} type Type of property effect to add
   * @param {Function} effectFn Function to run when arguments change
   * @param {*=} methodInfo Effect-specific information to be included in
   *   method effect metadata
   * @param {boolean|Object=} dynamicFn Boolean or object map indicating whether
   *   method names should be included as a dependency to the effect. Note,
   *   defaults to true if the signature is static (sig.static is true).
   * @private
   */
  function createMethodEffect(model, sig, type, effectFn, methodInfo, dynamicFn) {
    dynamicFn = sig.static || dynamicFn && ((typeof dynamicFn === 'undefined' ? 'undefined' : _typeof(dynamicFn)) !== 'object' || dynamicFn[sig.methodName]);
    var info = {
      methodName: sig.methodName,
      args: sig.args,
      methodInfo: methodInfo,
      dynamicFn: dynamicFn
    };
    for (var i = 0, arg; i < sig.args.length && (arg = sig.args[i]); i++) {
      if (!arg.literal) {
        model._addPropertyEffect(arg.rootProperty, type, {
          fn: effectFn, info: info, trigger: arg
        });
      }
    }
    if (dynamicFn) {
      model._addPropertyEffect(sig.methodName, type, {
        fn: effectFn, info: info
      });
    }
  }

  /**
   * Calls a method with arguments marshaled from properties on the instance
   * based on the method signature contained in the effect metadata.
   *
   * Multi-property observers, computed properties, and inline computing
   * functions call this function to invoke the method, then use the return
   * value accordingly.
   *
   * @param {!PropertyEffectsType} inst The instance the effect will be run on
   * @param {string} property Name of property
   * @param {Object} props Bag of current property changes
   * @param {Object} oldProps Bag of previous values for changed properties
   * @param {?} info Effect metadata
   * @return {*} Returns the return value from the method invocation
   * @private
   */
  function runMethodEffect(inst, property, props, oldProps, info) {
    // Instances can optionally have a _methodHost which allows redirecting where
    // to find methods. Currently used by `templatize`.
    var context = inst._methodHost || inst;
    var fn = context[info.methodName];
    if (fn) {
      var args = marshalArgs(inst.__data, info.args, property, props);
      return fn.apply(context, args);
    } else if (!info.dynamicFn) {
      console.warn('method `' + info.methodName + '` not defined');
    }
  }

  var emptyArray = [];

  // Regular expressions used for binding
  var IDENT = '(?:' + '[a-zA-Z_$][\\w.:$\\-*]*' + ')';
  var NUMBER = '(?:' + '[-+]?[0-9]*\\.?[0-9]+(?:[eE][-+]?[0-9]+)?' + ')';
  var SQUOTE_STRING = '(?:' + '\'(?:[^\'\\\\]|\\\\.)*\'' + ')';
  var DQUOTE_STRING = '(?:' + '"(?:[^"\\\\]|\\\\.)*"' + ')';
  var STRING = '(?:' + SQUOTE_STRING + '|' + DQUOTE_STRING + ')';
  var ARGUMENT = '(?:(' + IDENT + '|' + NUMBER + '|' + STRING + ')\\s*' + ')';
  var ARGUMENTS = '(?:' + ARGUMENT + '(?:,\\s*' + ARGUMENT + ')*' + ')';
  var ARGUMENT_LIST = '(?:' + '\\(\\s*' + '(?:' + ARGUMENTS + '?' + ')' + '\\)\\s*' + ')';
  var BINDING = '(' + IDENT + '\\s*' + ARGUMENT_LIST + '?' + ')'; // Group 3
  var OPEN_BRACKET = '(\\[\\[|{{)' + '\\s*';
  var CLOSE_BRACKET = '(?:]]|}})';
  var NEGATE = '(?:(!)\\s*)?'; // Group 2
  var EXPRESSION = OPEN_BRACKET + NEGATE + BINDING + CLOSE_BRACKET;
  var bindingRegex = new RegExp(EXPRESSION, "g");

  /**
   * Create a string from binding parts of all the literal parts
   *
   * @param {!Array<BindingPart>} parts All parts to stringify
   * @return {string} String made from the literal parts
   */
  function literalFromParts(parts) {
    var s = '';
    for (var i = 0; i < parts.length; i++) {
      var literal = parts[i].literal;
      s += literal || '';
    }
    return s;
  }

  /**
   * Parses an expression string for a method signature, and returns a metadata
   * describing the method in terms of `methodName`, `static` (whether all the
   * arguments are literals), and an array of `args`
   *
   * @param {string} expression The expression to parse
   * @return {?MethodSignature} The method metadata object if a method expression was
   *   found, otherwise `undefined`
   * @private
   */
  function parseMethod(expression) {
    // tries to match valid javascript property names
    var m = expression.match(/([^\s]+?)\(([\s\S]*)\)/);
    if (m) {
      var methodName = m[1];
      var sig = { methodName: methodName, static: true, args: emptyArray };
      if (m[2].trim()) {
        // replace escaped commas with comma entity, split on un-escaped commas
        var args = m[2].replace(/\\,/g, '&comma;').split(',');
        return parseArgs(args, sig);
      } else {
        return sig;
      }
    }
    return null;
  }

  /**
   * Parses an array of arguments and sets the `args` property of the supplied
   * signature metadata object. Sets the `static` property to false if any
   * argument is a non-literal.
   *
   * @param {!Array<string>} argList Array of argument names
   * @param {!MethodSignature} sig Method signature metadata object
   * @return {!MethodSignature} The updated signature metadata object
   * @private
   */
  function parseArgs(argList, sig) {
    sig.args = argList.map(function (rawArg) {
      var arg = parseArg(rawArg);
      if (!arg.literal) {
        sig.static = false;
      }
      return arg;
    }, this);
    return sig;
  }

  /**
   * Parses an individual argument, and returns an argument metadata object
   * with the following fields:
   *
   *   {
   *     value: 'prop',        // property/path or literal value
   *     literal: false,       // whether argument is a literal
   *     structured: false,    // whether the property is a path
   *     rootProperty: 'prop', // the root property of the path
   *     wildcard: false       // whether the argument was a wildcard '.*' path
   *   }
   *
   * @param {string} rawArg The string value of the argument
   * @return {!MethodArg} Argument metadata object
   * @private
   */
  function parseArg(rawArg) {
    // clean up whitespace
    var arg = rawArg.trim()
    // replace comma entity with comma
    .replace(/&comma;/g, ',')
    // repair extra escape sequences; note only commas strictly need
    // escaping, but we allow any other char to be escaped since its
    // likely users will do this
    .replace(/\\(.)/g, '\$1');
    // basic argument descriptor
    var a = {
      name: arg,
      value: '',
      literal: false
    };
    // detect literal value (must be String or Number)
    var fc = arg[0];
    if (fc === '-') {
      fc = arg[1];
    }
    if (fc >= '0' && fc <= '9') {
      fc = '#';
    }
    switch (fc) {
      case "'":
      case '"':
        a.value = arg.slice(1, -1);
        a.literal = true;
        break;
      case '#':
        a.value = Number(arg);
        a.literal = true;
        break;
    }
    // if not literal, look for structured path
    if (!a.literal) {
      a.rootProperty = Polymer.Path.root(arg);
      // detect structured path (has dots)
      a.structured = Polymer.Path.isPath(arg);
      if (a.structured) {
        a.wildcard = arg.slice(-2) == '.*';
        if (a.wildcard) {
          a.name = arg.slice(0, -2);
        }
      }
    }
    return a;
  }

  /**
   * Gather the argument values for a method specified in the provided array
   * of argument metadata.
   *
   * The `path` and `value` arguments are used to fill in wildcard descriptor
   * when the method is being called as a result of a path notification.
   *
   * @param {Object} data Instance data storage object to read properties from
   * @param {!Array<!MethodArg>} args Array of argument metadata
   * @param {string} path Property/path name that triggered the method effect
   * @param {Object} props Bag of current property changes
   * @return {Array<*>} Array of argument values
   * @private
   */
  function marshalArgs(data, args, path, props) {
    var values = [];
    for (var i = 0, l = args.length; i < l; i++) {
      var arg = args[i];
      var name = arg.name;
      var v = void 0;
      if (arg.literal) {
        v = arg.value;
      } else {
        if (arg.structured) {
          v = Polymer.Path.get(data, name);
          // when data is not stored e.g. `splices`
          if (v === undefined) {
            v = props[name];
          }
        } else {
          v = data[name];
        }
      }
      if (arg.wildcard) {
        // Only send the actual path changed info if the change that
        // caused the observer to run matched the wildcard
        var baseChanged = name.indexOf(path + '.') === 0;
        var matches = path.indexOf(name) === 0 && !baseChanged;
        values[i] = {
          path: matches ? path : name,
          value: matches ? props[path] : v,
          base: v
        };
      } else {
        values[i] = v;
      }
    }
    return values;
  }

  // data api

  /**
   * Sends array splice notifications (`.splices` and `.length`)
   *
   * Note: this implementation only accepts normalized paths
   *
   * @param {!PropertyEffectsType} inst Instance to send notifications to
   * @param {Array} array The array the mutations occurred on
   * @param {string} path The path to the array that was mutated
   * @param {Array} splices Array of splice records
   * @private
   */
  function _notifySplices(inst, array, path, splices) {
    var splicesPath = path + '.splices';
    inst.notifyPath(splicesPath, { indexSplices: splices });
    inst.notifyPath(path + '.length', array.length);
    // Null here to allow potentially large splice records to be GC'ed.
    inst.__data[splicesPath] = { indexSplices: null };
  }

  /**
   * Creates a splice record and sends an array splice notification for
   * the described mutation
   *
   * Note: this implementation only accepts normalized paths
   *
   * @param {!PropertyEffectsType} inst Instance to send notifications to
   * @param {Array} array The array the mutations occurred on
   * @param {string} path The path to the array that was mutated
   * @param {number} index Index at which the array mutation occurred
   * @param {number} addedCount Number of added items
   * @param {Array} removed Array of removed items
   * @private
   */
  function notifySplice(inst, array, path, index, addedCount, removed) {
    _notifySplices(inst, array, path, [{
      index: index,
      addedCount: addedCount,
      removed: removed,
      object: array,
      type: 'splice'
    }]);
  }

  /**
   * Returns an upper-cased version of the string.
   *
   * @param {string} name String to uppercase
   * @return {string} Uppercased string
   * @private
   */
  function upper(name) {
    return name[0].toUpperCase() + name.substring(1);
  }

  /**
   * Element class mixin that provides meta-programming for Polymer's template
   * binding and data observation (collectively, "property effects") system.
   *
   * This mixin uses provides the following key static methods for adding
   * property effects to an element class:
   * - `addPropertyEffect`
   * - `createPropertyObserver`
   * - `createMethodObserver`
   * - `createNotifyingProperty`
   * - `createReadOnlyProperty`
   * - `createReflectedProperty`
   * - `createComputedProperty`
   * - `bindTemplate`
   *
   * Each method creates one or more property accessors, along with metadata
   * used by this mixin's implementation of `_propertiesChanged` to perform
   * the property effects.
   *
   * Underscored versions of the above methods also exist on the element
   * prototype for adding property effects on instances at runtime.
   *
   * Note that this mixin overrides several `PropertyAccessors` methods, in
   * many cases to maintain guarantees provided by the Polymer 1.x features;
   * notably it changes property accessors to be synchronous by default
   * whereas the default when using `PropertyAccessors` standalone is to be
   * async by default.
   *
   * @mixinFunction
   * @polymer
   * @appliesMixin Polymer.TemplateStamp
   * @appliesMixin Polymer.PropertyAccessors
   * @memberof Polymer
   * @summary Element class mixin that provides meta-programming for Polymer's
   * template binding and data observation system.
   */
  Polymer.PropertyEffects = Polymer.dedupingMixin(function (superClass) {

    /**
     * @constructor
     * @extends {superClass}
     * @implements {Polymer_PropertyAccessors}
     * @implements {Polymer_TemplateStamp}
     * @unrestricted
     */
    var propertyEffectsBase = Polymer.TemplateStamp(Polymer.PropertyAccessors(superClass));

    /**
     * @polymer
     * @mixinClass
     * @implements {Polymer_PropertyEffects}
     * @extends {propertyEffectsBase}
     * @unrestricted
     */

    var PropertyEffects = function (_propertyEffectsBase) {
      _inherits(PropertyEffects, _propertyEffectsBase);

      function PropertyEffects() {
        _classCallCheck(this, PropertyEffects);

        /** @type {boolean} */
        var _this = _possibleConstructorReturn(this, (PropertyEffects.__proto__ || Object.getPrototypeOf(PropertyEffects)).call(this));

        _this.__dataClientsReady;
        /** @type {Array} */
        _this.__dataPendingClients;
        /** @type {Object} */
        _this.__dataToNotify;
        /** @type {Object} */
        _this.__dataLinkedPaths;
        /** @type {boolean} */
        _this.__dataHasPaths;
        /** @type {Object} */
        _this.__dataCompoundStorage;
        /** @type {Polymer_PropertyEffects} */
        _this.__dataHost;
        /** @type {!Object} */
        _this.__dataTemp;
        /** @type {boolean} */
        _this.__dataClientsInitialized;
        /** @type {!Object} */
        _this.__data;
        /** @type {!Object} */
        _this.__dataPending;
        /** @type {!Object} */
        _this.__dataOld;
        /** @type {Object} */
        _this.__computeEffects;
        /** @type {Object} */
        _this.__reflectEffects;
        /** @type {Object} */
        _this.__notifyEffects;
        /** @type {Object} */
        _this.__propagateEffects;
        /** @type {Object} */
        _this.__observeEffects;
        /** @type {Object} */
        _this.__readOnly;
        /** @type {number} */
        _this.__dataCounter;
        /** @type {!TemplateInfo} */
        _this.__templateInfo;
        return _this;
      }

      _createClass(PropertyEffects, [{
        key: '_initializeProperties',
        value: function _initializeProperties() {
          _get(PropertyEffects.prototype.__proto__ || Object.getPrototypeOf(PropertyEffects.prototype), '_initializeProperties', this).call(this);
          hostStack.registerHost(this);
          this.__dataClientsReady = false;
          this.__dataPendingClients = null;
          this.__dataToNotify = null;
          this.__dataLinkedPaths = null;
          this.__dataHasPaths = false;
          // May be set on instance prior to upgrade
          this.__dataCompoundStorage = this.__dataCompoundStorage || null;
          this.__dataHost = this.__dataHost || null;
          this.__dataTemp = {};
          this.__dataClientsInitialized = false;
        }

        /**
         * Overrides `Polymer.PropertyAccessors` implementation to provide a
         * more efficient implementation of initializing properties from
         * the prototype on the instance.
         *
         * @override
         * @param {Object} props Properties to initialize on the prototype
         */

      }, {
        key: '_initializeProtoProperties',
        value: function _initializeProtoProperties(props) {
          this.__data = Object.create(props);
          this.__dataPending = Object.create(props);
          this.__dataOld = {};
        }

        /**
         * Overrides `Polymer.PropertyAccessors` implementation to avoid setting
         * `_setProperty`'s `shouldNotify: true`.
         *
         * @override
         * @param {Object} props Properties to initialize on the instance
         */

      }, {
        key: '_initializeInstanceProperties',
        value: function _initializeInstanceProperties(props) {
          var readOnly = this[TYPES.READ_ONLY];
          for (var prop in props) {
            if (!readOnly || !readOnly[prop]) {
              this.__dataPending = this.__dataPending || {};
              this.__dataOld = this.__dataOld || {};
              this.__data[prop] = this.__dataPending[prop] = props[prop];
            }
          }
        }

        // Prototype setup ----------------------------------------

        /**
         * Equivalent to static `addPropertyEffect` API but can be called on
         * an instance to add effects at runtime.  See that method for
         * full API docs.
         *
         * @param {string} property Property that should trigger the effect
         * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES
         * @param {Object=} effect Effect metadata object
         * @protected
         */

      }, {
        key: '_addPropertyEffect',
        value: function _addPropertyEffect(property, type, effect) {
          this._createPropertyAccessor(property, type == TYPES.READ_ONLY);
          // effects are accumulated into arrays per property based on type
          var effects = ensureOwnEffectMap(this, type)[property];
          if (!effects) {
            effects = this[type][property] = [];
          }
          effects.push(effect);
        }

        /**
         * Removes the given property effect.
         *
         * @param {string} property Property the effect was associated with
         * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES
         * @param {Object=} effect Effect metadata object to remove
         */

      }, {
        key: '_removePropertyEffect',
        value: function _removePropertyEffect(property, type, effect) {
          var effects = ensureOwnEffectMap(this, type)[property];
          var idx = effects.indexOf(effect);
          if (idx >= 0) {
            effects.splice(idx, 1);
          }
        }

        /**
         * Returns whether the current prototype/instance has a property effect
         * of a certain type.
         *
         * @param {string} property Property name
         * @param {string=} type Effect type, from this.PROPERTY_EFFECT_TYPES
         * @return {boolean} True if the prototype/instance has an effect of this type
         * @protected
         */

      }, {
        key: '_hasPropertyEffect',
        value: function _hasPropertyEffect(property, type) {
          var effects = this[type];
          return Boolean(effects && effects[property]);
        }

        /**
         * Returns whether the current prototype/instance has a "read only"
         * accessor for the given property.
         *
         * @param {string} property Property name
         * @return {boolean} True if the prototype/instance has an effect of this type
         * @protected
         */

      }, {
        key: '_hasReadOnlyEffect',
        value: function _hasReadOnlyEffect(property) {
          return this._hasPropertyEffect(property, TYPES.READ_ONLY);
        }

        /**
         * Returns whether the current prototype/instance has a "notify"
         * property effect for the given property.
         *
         * @param {string} property Property name
         * @return {boolean} True if the prototype/instance has an effect of this type
         * @protected
         */

      }, {
        key: '_hasNotifyEffect',
        value: function _hasNotifyEffect(property) {
          return this._hasPropertyEffect(property, TYPES.NOTIFY);
        }

        /**
         * Returns whether the current prototype/instance has a "reflect to attribute"
         * property effect for the given property.
         *
         * @param {string} property Property name
         * @return {boolean} True if the prototype/instance has an effect of this type
         * @protected
         */

      }, {
        key: '_hasReflectEffect',
        value: function _hasReflectEffect(property) {
          return this._hasPropertyEffect(property, TYPES.REFLECT);
        }

        /**
         * Returns whether the current prototype/instance has a "computed"
         * property effect for the given property.
         *
         * @param {string} property Property name
         * @return {boolean} True if the prototype/instance has an effect of this type
         * @protected
         */

      }, {
        key: '_hasComputedEffect',
        value: function _hasComputedEffect(property) {
          return this._hasPropertyEffect(property, TYPES.COMPUTE);
        }

        // Runtime ----------------------------------------

        /**
         * Sets a pending property or path.  If the root property of the path in
         * question had no accessor, the path is set, otherwise it is enqueued
         * via `_setPendingProperty`.
         *
         * This function isolates relatively expensive functionality necessary
         * for the public API (`set`, `setProperties`, `notifyPath`, and property
         * change listeners via {{...}} bindings), such that it is only done
         * when paths enter the system, and not at every propagation step.  It
         * also sets a `__dataHasPaths` flag on the instance which is used to
         * fast-path slower path-matching code in the property effects host paths.
         *
         * `path` can be a path string or array of path parts as accepted by the
         * public API.
         *
         * @param {string | !Array<number|string>} path Path to set
         * @param {*} value Value to set
         * @param {boolean=} shouldNotify Set to true if this change should
         *  cause a property notification event dispatch
         * @param {boolean=} isPathNotification If the path being set is a path
         *   notification of an already changed value, as opposed to a request
         *   to set and notify the change.  In the latter `false` case, a dirty
         *   check is performed and then the value is set to the path before
         *   enqueuing the pending property change.
         * @return {boolean} Returns true if the property/path was enqueued in
         *   the pending changes bag.
         * @protected
         */

      }, {
        key: '_setPendingPropertyOrPath',
        value: function _setPendingPropertyOrPath(path, value, shouldNotify, isPathNotification) {
          if (isPathNotification || Polymer.Path.root(Array.isArray(path) ? path[0] : path) !== path) {
            // Dirty check changes being set to a path against the actual object,
            // since this is the entry point for paths into the system; from here
            // the only dirty checks are against the `__dataTemp` cache to prevent
            // duplicate work in the same turn only. Note, if this was a notification
            // of a change already set to a path (isPathNotification: true),
            // we always let the change through and skip the `set` since it was
            // already dirty checked at the point of entry and the underlying
            // object has already been updated
            if (!isPathNotification) {
              var old = Polymer.Path.get(this, path);
              path = /** @type {string} */Polymer.Path.set(this, path, value);
              // Use property-accessor's simpler dirty check
              if (!path || !_get(PropertyEffects.prototype.__proto__ || Object.getPrototypeOf(PropertyEffects.prototype), '_shouldPropertyChange', this).call(this, path, value, old)) {
                return false;
              }
            }
            this.__dataHasPaths = true;
            if (this._setPendingProperty( /**@type{string}*/path, value, shouldNotify)) {
              computeLinkedPaths(this, path, value);
              return true;
            }
          } else {
            if (this.__dataHasAccessor && this.__dataHasAccessor[path]) {
              return this._setPendingProperty( /**@type{string}*/path, value, shouldNotify);
            } else {
              this[path] = value;
            }
          }
          return false;
        }

        /**
         * Applies a value to a non-Polymer element/node's property.
         *
         * The implementation makes a best-effort at binding interop:
         * Some native element properties have side-effects when
         * re-setting the same value (e.g. setting `<input>.value` resets the
         * cursor position), so we do a dirty-check before setting the value.
         * However, for better interop with non-Polymer custom elements that
         * accept objects, we explicitly re-set object changes coming from the
         * Polymer world (which may include deep object changes without the
         * top reference changing), erring on the side of providing more
         * information.
         *
         * Users may override this method to provide alternate approaches.
         *
         * @param {Node} node The node to set a property on
         * @param {string} prop The property to set
         * @param {*} value The value to set
         * @protected
         */

      }, {
        key: '_setUnmanagedPropertyToNode',
        value: function _setUnmanagedPropertyToNode(node, prop, value) {
          // It is a judgment call that resetting primitives is
          // "bad" and resettings objects is also "good"; alternatively we could
          // implement a whitelist of tag & property values that should never
          // be reset (e.g. <input>.value && <select>.value)
          if (value !== node[prop] || (typeof value === 'undefined' ? 'undefined' : _typeof(value)) == 'object') {
            node[prop] = value;
          }
        }

        /**
         * Overrides the `PropertyAccessors` implementation to introduce special
         * dirty check logic depending on the property & value being set:
         *
         * 1. Any value set to a path (e.g. 'obj.prop': 42 or 'obj.prop': {...})
         *    Stored in `__dataTemp`, dirty checked against `__dataTemp`
         * 2. Object set to simple property (e.g. 'prop': {...})
         *    Stored in `__dataTemp` and `__data`, dirty checked against
         *    `__dataTemp` by default implementation of `_shouldPropertyChange`
         * 3. Primitive value set to simple property (e.g. 'prop': 42)
         *    Stored in `__data`, dirty checked against `__data`
         *
         * The dirty-check is important to prevent cycles due to two-way
         * notification, but paths and objects are only dirty checked against any
         * previous value set during this turn via a "temporary cache" that is
         * cleared when the last `_propertiesChaged` exits. This is so:
         * a. any cached array paths (e.g. 'array.3.prop') may be invalidated
         *    due to array mutations like shift/unshift/splice; this is fine
         *    since path changes are dirty-checked at user entry points like `set`
         * b. dirty-checking for objects only lasts one turn to allow the user
         *    to mutate the object in-place and re-set it with the same identity
         *    and have all sub-properties re-propagated in a subsequent turn.
         *
         * The temp cache is not necessarily sufficient to prevent invalid array
         * paths, since a splice can happen during the same turn (with pathological
         * user code); we could introduce a "fixup" for temporarily cached array
         * paths if needed: https://github.com/Polymer/polymer/issues/4227
         *
         * @param {string} property Name of the property
         * @param {*} value Value to set
         * @param {boolean=} shouldNotify True if property should fire notification
         *   event (applies only for `notify: true` properties)
         * @return {boolean} Returns true if the property changed
         * @override
         */

      }, {
        key: '_setPendingProperty',
        value: function _setPendingProperty(property, value, shouldNotify) {
          var isPath = this.__dataHasPaths && Polymer.Path.isPath(property);
          var prevProps = isPath ? this.__dataTemp : this.__data;
          if (this._shouldPropertyChange(property, value, prevProps[property])) {
            if (!this.__dataPending) {
              this.__dataPending = {};
              this.__dataOld = {};
            }
            // Ensure old is captured from the last turn
            if (!(property in this.__dataOld)) {
              this.__dataOld[property] = this.__data[property];
            }
            // Paths are stored in temporary cache (cleared at end of turn),
            // which is used for dirty-checking, all others stored in __data
            if (isPath) {
              this.__dataTemp[property] = value;
            } else {
              this.__data[property] = value;
            }
            // All changes go into pending property bag, passed to _propertiesChanged
            this.__dataPending[property] = value;
            // Track properties that should notify separately
            if (isPath || this[TYPES.NOTIFY] && this[TYPES.NOTIFY][property]) {
              this.__dataToNotify = this.__dataToNotify || {};
              this.__dataToNotify[property] = shouldNotify;
            }
            return true;
          }
          return false;
        }

        /**
         * Overrides base implementation to ensure all accessors set `shouldNotify`
         * to true, for per-property notification tracking.
         *
         * @override
         */

      }, {
        key: '_setProperty',
        value: function _setProperty(property, value) {
          if (this._setPendingProperty(property, value, true)) {
            this._invalidateProperties();
          }
        }

        /**
         * Overrides `PropertyAccessor`'s default async queuing of
         * `_propertiesChanged`: if `__dataReady` is false (has not yet been
         * manually flushed), the function no-ops; otherwise flushes
         * `_propertiesChanged` synchronously.
         *
         * @override
         */

      }, {
        key: '_invalidateProperties',
        value: function _invalidateProperties() {
          if (this.__dataReady) {
            this._flushProperties();
          }
        }

        /**
         * Enqueues the given client on a list of pending clients, whose
         * pending property changes can later be flushed via a call to
         * `_flushClients`.
         *
         * @param {Object} client PropertyEffects client to enqueue
         * @protected
         */

      }, {
        key: '_enqueueClient',
        value: function _enqueueClient(client) {
          this.__dataPendingClients = this.__dataPendingClients || [];
          if (client !== this) {
            this.__dataPendingClients.push(client);
          }
        }

        /**
         * Flushes any clients previously enqueued via `_enqueueClient`, causing
         * their `_flushProperties` method to run.
         *
         * @protected
         */

      }, {
        key: '_flushClients',
        value: function _flushClients() {
          if (!this.__dataClientsReady) {
            this.__dataClientsReady = true;
            this._readyClients();
            // Override point where accessors are turned on; importantly,
            // this is after clients have fully readied, providing a guarantee
            // that any property effects occur only after all clients are ready.
            this.__dataReady = true;
          } else {
            this.__enableOrFlushClients();
          }
        }

        // NOTE: We ensure clients either enable or flush as appropriate. This
        // handles two corner cases:
        // (1) clients flush properly when connected/enabled before the host
        // enables; e.g.
        //   (a) Templatize stamps with no properties and does not flush and
        //   (b) the instance is inserted into dom and
        //   (c) then the instance flushes.
        // (2) clients enable properly when not connected/enabled when the host
        // flushes; e.g.
        //   (a) a template is runtime stamped and not yet connected/enabled
        //   (b) a host sets a property, causing stamped dom to flush
        //   (c) the stamped dom enables.

      }, {
        key: '__enableOrFlushClients',
        value: function __enableOrFlushClients() {
          var clients = this.__dataPendingClients;
          if (clients) {
            this.__dataPendingClients = null;
            for (var i = 0; i < clients.length; i++) {
              var client = clients[i];
              if (!client.__dataEnabled) {
                client._enableProperties();
              } else if (client.__dataPending) {
                client._flushProperties();
              }
            }
          }
        }

        /**
         * Perform any initial setup on client dom. Called before the first
         * `_flushProperties` call on client dom and before any element
         * observers are called.
         *
         * @protected
         */

      }, {
        key: '_readyClients',
        value: function _readyClients() {
          this.__enableOrFlushClients();
        }

        /**
         * Sets a bag of property changes to this instance, and
         * synchronously processes all effects of the properties as a batch.
         *
         * Property names must be simple properties, not paths.  Batched
         * path propagation is not supported.
         *
         * @param {Object} props Bag of one or more key-value pairs whose key is
         *   a property and value is the new value to set for that property.
         * @param {boolean=} setReadOnly When true, any private values set in
         *   `props` will be set. By default, `setProperties` will not set
         *   `readOnly: true` root properties.
         * @public
         */

      }, {
        key: 'setProperties',
        value: function setProperties(props, setReadOnly) {
          for (var path in props) {
            if (setReadOnly || !this[TYPES.READ_ONLY] || !this[TYPES.READ_ONLY][path]) {
              //TODO(kschaaf): explicitly disallow paths in setProperty?
              // wildcard observers currently only pass the first changed path
              // in the `info` object, and you could do some odd things batching
              // paths, e.g. {'foo.bar': {...}, 'foo': null}
              this._setPendingPropertyOrPath(path, props[path], true);
            }
          }
          this._invalidateProperties();
        }

        /**
         * Overrides `PropertyAccessors` so that property accessor
         * side effects are not enabled until after client dom is fully ready.
         * Also calls `_flushClients` callback to ensure client dom is enabled
         * that was not enabled as a result of flushing properties.
         *
         * @override
         */

      }, {
        key: 'ready',
        value: function ready() {
          // It is important that `super.ready()` is not called here as it
          // immediately turns on accessors. Instead, we wait until `readyClients`
          // to enable accessors to provide a guarantee that clients are ready
          // before processing any accessors side effects.
          this._flushProperties();
          // If no data was pending, `_flushProperties` will not `flushClients`
          // so ensure this is done.
          if (!this.__dataClientsReady) {
            this._flushClients();
          }
          // Before ready, client notifications do not trigger _flushProperties.
          // Therefore a flush is necessary here if data has been set.
          if (this.__dataPending) {
            this._flushProperties();
          }
        }

        /**
         * Implements `PropertyAccessors`'s properties changed callback.
         *
         * Runs each class of effects for the batch of changed properties in
         * a specific order (compute, propagate, reflect, observe, notify).
         *
         * @override
         */

      }, {
        key: '_propertiesChanged',
        value: function _propertiesChanged(currentProps, changedProps, oldProps) {
          // ----------------------------
          // let c = Object.getOwnPropertyNames(changedProps || {});
          // window.debug && console.group(this.localName + '#' + this.id + ': ' + c);
          // if (window.debug) { debugger; }
          // ----------------------------
          var hasPaths = this.__dataHasPaths;
          this.__dataHasPaths = false;
          // Compute properties
          runComputedEffects(this, changedProps, oldProps, hasPaths);
          // Clear notify properties prior to possible reentry (propagate, observe),
          // but after computing effects have a chance to add to them
          var notifyProps = this.__dataToNotify;
          this.__dataToNotify = null;
          // Propagate properties to clients
          this._propagatePropertyChanges(changedProps, oldProps, hasPaths);
          // Flush clients
          this._flushClients();
          // Reflect properties
          runEffects(this, this[TYPES.REFLECT], changedProps, oldProps, hasPaths);
          // Observe properties
          runEffects(this, this[TYPES.OBSERVE], changedProps, oldProps, hasPaths);
          // Notify properties to host
          if (notifyProps) {
            runNotifyEffects(this, notifyProps, changedProps, oldProps, hasPaths);
          }
          // Clear temporary cache at end of turn
          if (this.__dataCounter == 1) {
            this.__dataTemp = {};
          }
          // ----------------------------
          // window.debug && console.groupEnd(this.localName + '#' + this.id + ': ' + c);
          // ----------------------------
        }

        /**
         * Called to propagate any property changes to stamped template nodes
         * managed by this element.
         *
         * @param {Object} changedProps Bag of changed properties
         * @param {Object} oldProps Bag of previous values for changed properties
         * @param {boolean} hasPaths True with `props` contains one or more paths
         * @protected
         */

      }, {
        key: '_propagatePropertyChanges',
        value: function _propagatePropertyChanges(changedProps, oldProps, hasPaths) {
          if (this[TYPES.PROPAGATE]) {
            runEffects(this, this[TYPES.PROPAGATE], changedProps, oldProps, hasPaths);
          }
          var templateInfo = this.__templateInfo;
          while (templateInfo) {
            runEffects(this, templateInfo.propertyEffects, changedProps, oldProps, hasPaths, templateInfo.nodeList);
            templateInfo = templateInfo.nextTemplateInfo;
          }
        }

        /**
         * Aliases one data path as another, such that path notifications from one
         * are routed to the other.
         *
         * @param {string | !Array<string|number>} to Target path to link.
         * @param {string | !Array<string|number>} from Source path to link.
         * @public
         */

      }, {
        key: 'linkPaths',
        value: function linkPaths(to, from) {
          to = Polymer.Path.normalize(to);
          from = Polymer.Path.normalize(from);
          this.__dataLinkedPaths = this.__dataLinkedPaths || {};
          this.__dataLinkedPaths[to] = from;
        }

        /**
         * Removes a data path alias previously established with `_linkPaths`.
         *
         * Note, the path to unlink should be the target (`to`) used when
         * linking the paths.
         *
         * @param {string | !Array<string|number>} path Target path to unlink.
         * @public
         */

      }, {
        key: 'unlinkPaths',
        value: function unlinkPaths(path) {
          path = Polymer.Path.normalize(path);
          if (this.__dataLinkedPaths) {
            delete this.__dataLinkedPaths[path];
          }
        }

        /**
         * Notify that an array has changed.
         *
         * Example:
         *
         *     this.items = [ {name: 'Jim'}, {name: 'Todd'}, {name: 'Bill'} ];
         *     ...
         *     this.items.splice(1, 1, {name: 'Sam'});
         *     this.items.push({name: 'Bob'});
         *     this.notifySplices('items', [
         *       { index: 1, removed: [{name: 'Todd'}], addedCount: 1, obect: this.items, type: 'splice' },
         *       { index: 3, removed: [], addedCount: 1, object: this.items, type: 'splice'}
         *     ]);
         *
         * @param {string} path Path that should be notified.
         * @param {Array} splices Array of splice records indicating ordered
         *   changes that occurred to the array. Each record should have the
         *   following fields:
         *    * index: index at which the change occurred
         *    * removed: array of items that were removed from this index
         *    * addedCount: number of new items added at this index
         *    * object: a reference to the array in question
         *    * type: the string literal 'splice'
         *
         *   Note that splice records _must_ be normalized such that they are
         *   reported in index order (raw results from `Object.observe` are not
         *   ordered and must be normalized/merged before notifying).
         * @public
        */

      }, {
        key: 'notifySplices',
        value: function notifySplices(path, splices) {
          var info = { path: '' };
          var array = /** @type {Array} */Polymer.Path.get(this, path, info);
          _notifySplices(this, array, info.path, splices);
        }

        /**
         * Convenience method for reading a value from a path.
         *
         * Note, if any part in the path is undefined, this method returns
         * `undefined` (this method does not throw when dereferencing undefined
         * paths).
         *
         * @param {(string|!Array<(string|number)>)} path Path to the value
         *   to read.  The path may be specified as a string (e.g. `foo.bar.baz`)
         *   or an array of path parts (e.g. `['foo.bar', 'baz']`).  Note that
         *   bracketed expressions are not supported; string-based path parts
         *   *must* be separated by dots.  Note that when dereferencing array
         *   indices, the index may be used as a dotted part directly
         *   (e.g. `users.12.name` or `['users', 12, 'name']`).
         * @param {Object=} root Root object from which the path is evaluated.
         * @return {*} Value at the path, or `undefined` if any part of the path
         *   is undefined.
         * @public
         */

      }, {
        key: 'get',
        value: function get(path, root) {
          return Polymer.Path.get(root || this, path);
        }

        /**
         * Convenience method for setting a value to a path and notifying any
         * elements bound to the same path.
         *
         * Note, if any part in the path except for the last is undefined,
         * this method does nothing (this method does not throw when
         * dereferencing undefined paths).
         *
         * @param {(string|!Array<(string|number)>)} path Path to the value
         *   to write.  The path may be specified as a string (e.g. `'foo.bar.baz'`)
         *   or an array of path parts (e.g. `['foo.bar', 'baz']`).  Note that
         *   bracketed expressions are not supported; string-based path parts
         *   *must* be separated by dots.  Note that when dereferencing array
         *   indices, the index may be used as a dotted part directly
         *   (e.g. `'users.12.name'` or `['users', 12, 'name']`).
         * @param {*} value Value to set at the specified path.
         * @param {Object=} root Root object from which the path is evaluated.
         *   When specified, no notification will occur.
         * @public
        */

      }, {
        key: 'set',
        value: function set(path, value, root) {
          if (root) {
            Polymer.Path.set(root, path, value);
          } else {
            if (!this[TYPES.READ_ONLY] || !this[TYPES.READ_ONLY][/** @type {string} */path]) {
              if (this._setPendingPropertyOrPath(path, value, true)) {
                this._invalidateProperties();
              }
            }
          }
        }

        /**
         * Adds items onto the end of the array at the path specified.
         *
         * The arguments after `path` and return value match that of
         * `Array.prototype.push`.
         *
         * This method notifies other paths to the same array that a
         * splice occurred to the array.
         *
         * @param {string} path Path to array.
         * @param {...*} items Items to push onto array
         * @return {number} New length of the array.
         * @public
         */

      }, {
        key: 'push',
        value: function push(path) {
          var info = { path: '' };
          var array = /** @type {Array}*/Polymer.Path.get(this, path, info);
          var len = array.length;

          for (var _len = arguments.length, items = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            items[_key - 1] = arguments[_key];
          }

          var ret = array.push.apply(array, items);
          if (items.length) {
            notifySplice(this, array, info.path, len, items.length, []);
          }
          return ret;
        }

        /**
         * Removes an item from the end of array at the path specified.
         *
         * The arguments after `path` and return value match that of
         * `Array.prototype.pop`.
         *
         * This method notifies other paths to the same array that a
         * splice occurred to the array.
         *
         * @param {string} path Path to array.
         * @return {*} Item that was removed.
         * @public
         */

      }, {
        key: 'pop',
        value: function pop(path) {
          var info = { path: '' };
          var array = /** @type {Array} */Polymer.Path.get(this, path, info);
          var hadLength = Boolean(array.length);
          var ret = array.pop();
          if (hadLength) {
            notifySplice(this, array, info.path, array.length, 0, [ret]);
          }
          return ret;
        }

        /**
         * Starting from the start index specified, removes 0 or more items
         * from the array and inserts 0 or more new items in their place.
         *
         * The arguments after `path` and return value match that of
         * `Array.prototype.splice`.
         *
         * This method notifies other paths to the same array that a
         * splice occurred to the array.
         *
         * @param {string} path Path to array.
         * @param {number} start Index from which to start removing/inserting.
         * @param {number} deleteCount Number of items to remove.
         * @param {...*} items Items to insert into array.
         * @return {Array} Array of removed items.
         * @public
         */

      }, {
        key: 'splice',
        value: function splice(path, start, deleteCount) {
          var info = { path: '' };
          var array = /** @type {Array} */Polymer.Path.get(this, path, info);
          // Normalize fancy native splice handling of crazy start values
          if (start < 0) {
            start = array.length - Math.floor(-start);
          } else {
            start = Math.floor(start);
          }
          if (!start) {
            start = 0;
          }

          for (var _len2 = arguments.length, items = Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {
            items[_key2 - 3] = arguments[_key2];
          }

          var ret = array.splice.apply(array, [start, deleteCount].concat(items));
          if (items.length || ret.length) {
            notifySplice(this, array, info.path, start, items.length, ret);
          }
          return ret;
        }

        /**
         * Removes an item from the beginning of array at the path specified.
         *
         * The arguments after `path` and return value match that of
         * `Array.prototype.pop`.
         *
         * This method notifies other paths to the same array that a
         * splice occurred to the array.
         *
         * @param {string} path Path to array.
         * @return {*} Item that was removed.
         * @public
         */

      }, {
        key: 'shift',
        value: function shift(path) {
          var info = { path: '' };
          var array = /** @type {Array} */Polymer.Path.get(this, path, info);
          var hadLength = Boolean(array.length);
          var ret = array.shift();
          if (hadLength) {
            notifySplice(this, array, info.path, 0, 0, [ret]);
          }
          return ret;
        }

        /**
         * Adds items onto the beginning of the array at the path specified.
         *
         * The arguments after `path` and return value match that of
         * `Array.prototype.push`.
         *
         * This method notifies other paths to the same array that a
         * splice occurred to the array.
         *
         * @param {string} path Path to array.
         * @param {...*} items Items to insert info array
         * @return {number} New length of the array.
         * @public
         */

      }, {
        key: 'unshift',
        value: function unshift(path) {
          var info = { path: '' };
          var array = /** @type {Array} */Polymer.Path.get(this, path, info);

          for (var _len3 = arguments.length, items = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
            items[_key3 - 1] = arguments[_key3];
          }

          var ret = array.unshift.apply(array, items);
          if (items.length) {
            notifySplice(this, array, info.path, 0, items.length, []);
          }
          return ret;
        }

        /**
         * Notify that a path has changed.
         *
         * Example:
         *
         *     this.item.user.name = 'Bob';
         *     this.notifyPath('item.user.name');
         *
         * @param {string} path Path that should be notified.
         * @param {*=} value Value at the path (optional).
         * @public
        */

      }, {
        key: 'notifyPath',
        value: function notifyPath(path, value) {
          /** @type {string} */
          var propPath = void 0;
          if (arguments.length == 1) {
            // Get value if not supplied
            var info = { path: '' };
            value = Polymer.Path.get(this, path, info);
            propPath = info.path;
          } else if (Array.isArray(path)) {
            // Normalize path if needed
            propPath = Polymer.Path.normalize(path);
          } else {
            propPath = /** @type{string} */path;
          }
          if (this._setPendingPropertyOrPath(propPath, value, true, true)) {
            this._invalidateProperties();
          }
        }

        /**
         * Equivalent to static `createReadOnlyProperty` API but can be called on
         * an instance to add effects at runtime.  See that method for
         * full API docs.
         *
         * @param {string} property Property name
         * @param {boolean=} protectedSetter Creates a custom protected setter
         *   when `true`.
         * @protected
         */

      }, {
        key: '_createReadOnlyProperty',
        value: function _createReadOnlyProperty(property, protectedSetter) {
          this._addPropertyEffect(property, TYPES.READ_ONLY);
          if (protectedSetter) {
            this['_set' + upper(property)] = /** @this {PropertyEffects} */function (value) {
              this._setProperty(property, value);
            };
          }
        }

        /**
         * Equivalent to static `createPropertyObserver` API but can be called on
         * an instance to add effects at runtime.  See that method for
         * full API docs.
         *
         * @param {string} property Property name
         * @param {string} methodName Name of observer method to call
         * @param {boolean=} dynamicFn Whether the method name should be included as
         *   a dependency to the effect.
         * @protected
         */

      }, {
        key: '_createPropertyObserver',
        value: function _createPropertyObserver(property, methodName, dynamicFn) {
          var info = { property: property, methodName: methodName, dynamicFn: Boolean(dynamicFn) };
          this._addPropertyEffect(property, TYPES.OBSERVE, {
            fn: runObserverEffect, info: info, trigger: { name: property }
          });
          if (dynamicFn) {
            this._addPropertyEffect(methodName, TYPES.OBSERVE, {
              fn: runObserverEffect, info: info, trigger: { name: methodName }
            });
          }
        }

        /**
         * Equivalent to static `createMethodObserver` API but can be called on
         * an instance to add effects at runtime.  See that method for
         * full API docs.
         *
         * @param {string} expression Method expression
         * @param {boolean|Object=} dynamicFn Boolean or object map indicating
         *   whether method names should be included as a dependency to the effect.
         * @protected
         */

      }, {
        key: '_createMethodObserver',
        value: function _createMethodObserver(expression, dynamicFn) {
          var sig = parseMethod(expression);
          if (!sig) {
            throw new Error("Malformed observer expression '" + expression + "'");
          }
          createMethodEffect(this, sig, TYPES.OBSERVE, runMethodEffect, null, dynamicFn);
        }

        /**
         * Equivalent to static `createNotifyingProperty` API but can be called on
         * an instance to add effects at runtime.  See that method for
         * full API docs.
         *
         * @param {string} property Property name
         * @protected
         */

      }, {
        key: '_createNotifyingProperty',
        value: function _createNotifyingProperty(property) {
          this._addPropertyEffect(property, TYPES.NOTIFY, {
            fn: runNotifyEffect,
            info: {
              eventName: CaseMap.camelToDashCase(property) + '-changed',
              property: property
            }
          });
        }

        /**
         * Equivalent to static `createReflectedProperty` API but can be called on
         * an instance to add effects at runtime.  See that method for
         * full API docs.
         *
         * @param {string} property Property name
         * @protected
         */

      }, {
        key: '_createReflectedProperty',
        value: function _createReflectedProperty(property) {
          var attr = CaseMap.camelToDashCase(property);
          if (attr[0] === '-') {
            console.warn('Property ' + property + ' cannot be reflected to attribute ' + attr + ' because "-" is not a valid starting attribute name. Use a lowercase first letter for the property thisead.');
          } else {
            this._addPropertyEffect(property, TYPES.REFLECT, {
              fn: runReflectEffect,
              info: {
                attrName: attr
              }
            });
          }
        }

        /**
         * Equivalent to static `createComputedProperty` API but can be called on
         * an instance to add effects at runtime.  See that method for
         * full API docs.
         *
         * @param {string} property Name of computed property to set
         * @param {string} expression Method expression
         * @param {boolean|Object=} dynamicFn Boolean or object map indicating
         *   whether method names should be included as a dependency to the effect.
         * @protected
         */

      }, {
        key: '_createComputedProperty',
        value: function _createComputedProperty(property, expression, dynamicFn) {
          var sig = parseMethod(expression);
          if (!sig) {
            throw new Error("Malformed computed expression '" + expression + "'");
          }
          createMethodEffect(this, sig, TYPES.COMPUTE, runComputedEffect, property, dynamicFn);
        }

        // -- static class methods ------------

        /**
         * Ensures an accessor exists for the specified property, and adds
         * to a list of "property effects" that will run when the accessor for
         * the specified property is set.  Effects are grouped by "type", which
         * roughly corresponds to a phase in effect processing.  The effect
         * metadata should be in the following form:
         *
         *   {
         *     fn: effectFunction, // Reference to function to call to perform effect
         *     info: { ... }       // Effect metadata passed to function
         *     trigger: {          // Optional triggering metadata; if not provided
         *       name: string      // the property is treated as a wildcard
         *       structured: boolean
         *       wildcard: boolean
         *     }
         *   }
         *
         * Effects are called from `_propertiesChanged` in the following order by
         * type:
         *
         * 1. COMPUTE
         * 2. PROPAGATE
         * 3. REFLECT
         * 4. OBSERVE
         * 5. NOTIFY
         *
         * Effect functions are called with the following signature:
         *
         *   effectFunction(inst, path, props, oldProps, info, hasPaths)
         *
         * @param {string} property Property that should trigger the effect
         * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES
         * @param {Object=} effect Effect metadata object
         * @protected
         */

      }, {
        key: '_bindTemplate',


        // -- binding ----------------------------------------------

        /**
         * Equivalent to static `bindTemplate` API but can be called on
         * an instance to add effects at runtime.  See that method for
         * full API docs.
         *
         * This method may be called on the prototype (for prototypical template
         * binding, to avoid creating accessors every instance) once per prototype,
         * and will be called with `runtimeBinding: true` by `_stampTemplate` to
         * create and link an instance of the template metadata associated with a
         * particular stamping.
         *
         * @param {HTMLTemplateElement} template Template containing binding
         *   bindings
         * @param {boolean=} instanceBinding When false (default), performs
         *   "prototypical" binding of the template and overwrites any previously
         *   bound template for the class. When true (as passed from
         *   `_stampTemplate`), the template info is instanced and linked into
         *   the list of bound templates.
         * @return {!TemplateInfo} Template metadata object; for `runtimeBinding`,
         *   this is an instance of the prototypical template info
         * @protected
         */
        value: function _bindTemplate(template, instanceBinding) {
          var templateInfo = this.constructor._parseTemplate(template);
          var wasPreBound = this.__templateInfo == templateInfo;
          // Optimization: since this is called twice for proto-bound templates,
          // don't attempt to recreate accessors if this template was pre-bound
          if (!wasPreBound) {
            for (var prop in templateInfo.propertyEffects) {
              this._createPropertyAccessor(prop);
            }
          }
          if (instanceBinding) {
            // For instance-time binding, create instance of template metadata
            // and link into list of templates if necessary
            templateInfo = /** @type {!TemplateInfo} */Object.create(templateInfo);
            templateInfo.wasPreBound = wasPreBound;
            if (!wasPreBound && this.__templateInfo) {
              var last = this.__templateInfoLast || this.__templateInfo;
              this.__templateInfoLast = last.nextTemplateInfo = templateInfo;
              templateInfo.previousTemplateInfo = last;
              return templateInfo;
            }
          }
          return this.__templateInfo = templateInfo;
        }

        /**
         * Adds a property effect to the given template metadata, which is run
         * at the "propagate" stage of `_propertiesChanged` when the template
         * has been bound to the element via `_bindTemplate`.
         *
         * The `effect` object should match the format in `_addPropertyEffect`.
         *
         * @param {Object} templateInfo Template metadata to add effect to
         * @param {string} prop Property that should trigger the effect
         * @param {Object=} effect Effect metadata object
         * @protected
         */

      }, {
        key: '_stampTemplate',


        /**
         * Stamps the provided template and performs instance-time setup for
         * Polymer template features, including data bindings, declarative event
         * listeners, and the `this.$` map of `id`'s to nodes.  A document fragment
         * is returned containing the stamped DOM, ready for insertion into the
         * DOM.
         *
         * This method may be called more than once; however note that due to
         * `shadycss` polyfill limitations, only styles from templates prepared
         * using `ShadyCSS.prepareTemplate` will be correctly polyfilled (scoped
         * to the shadow root and support CSS custom properties), and note that
         * `ShadyCSS.prepareTemplate` may only be called once per element. As such,
         * any styles required by in runtime-stamped templates must be included
         * in the main element template.
         *
         * @param {!HTMLTemplateElement} template Template to stamp
         * @return {!StampedTemplate} Cloned template content
         * @override
         * @protected
         */
        value: function _stampTemplate(template) {
          // Ensures that created dom is `_enqueueClient`'d to this element so
          // that it can be flushed on next call to `_flushProperties`
          hostStack.beginHosting(this);
          var dom = _get(PropertyEffects.prototype.__proto__ || Object.getPrototypeOf(PropertyEffects.prototype), '_stampTemplate', this).call(this, template);
          hostStack.endHosting(this);
          var templateInfo = /** @type {!TemplateInfo} */this._bindTemplate(template, true);
          // Add template-instance-specific data to instanced templateInfo
          templateInfo.nodeList = dom.nodeList;
          // Capture child nodes to allow unstamping of non-prototypical templates
          if (!templateInfo.wasPreBound) {
            var nodes = templateInfo.childNodes = [];
            for (var n = dom.firstChild; n; n = n.nextSibling) {
              nodes.push(n);
            }
          }
          dom.templateInfo = templateInfo;
          // Setup compound storage, 2-way listeners, and dataHost for bindings
          setupBindings(this, templateInfo);
          // Flush properties into template nodes if already booted
          if (this.__dataReady) {
            runEffects(this, templateInfo.propertyEffects, this.__data, null, false, templateInfo.nodeList);
          }
          return dom;
        }

        /**
         * Removes and unbinds the nodes previously contained in the provided
         * DocumentFragment returned from `_stampTemplate`.
         *
         * @param {!StampedTemplate} dom DocumentFragment previously returned
         *   from `_stampTemplate` associated with the nodes to be removed
         * @protected
         */

      }, {
        key: '_removeBoundDom',
        value: function _removeBoundDom(dom) {
          // Unlink template info
          var templateInfo = dom.templateInfo;
          if (templateInfo.previousTemplateInfo) {
            templateInfo.previousTemplateInfo.nextTemplateInfo = templateInfo.nextTemplateInfo;
          }
          if (templateInfo.nextTemplateInfo) {
            templateInfo.nextTemplateInfo.previousTemplateInfo = templateInfo.previousTemplateInfo;
          }
          if (this.__templateInfoLast == templateInfo) {
            this.__templateInfoLast = templateInfo.previousTemplateInfo;
          }
          templateInfo.previousTemplateInfo = templateInfo.nextTemplateInfo = null;
          // Remove stamped nodes
          var nodes = templateInfo.childNodes;
          for (var i = 0; i < nodes.length; i++) {
            var node = nodes[i];
            node.parentNode.removeChild(node);
          }
        }

        /**
         * Overrides default `TemplateStamp` implementation to add support for
         * parsing bindings from `TextNode`'s' `textContent`.  A `bindings`
         * array is added to `nodeInfo` and populated with binding metadata
         * with information capturing the binding target, and a `parts` array
         * with one or more metadata objects capturing the source(s) of the
         * binding.
         *
         * @override
         * @param {Node} node Node to parse
         * @param {TemplateInfo} templateInfo Template metadata for current template
         * @param {NodeInfo} nodeInfo Node metadata for current template node
         * @return {boolean} `true` if the visited node added node-specific
         *   metadata to `nodeInfo`
         * @protected
         * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
         */

      }, {
        key: 'PROPERTY_EFFECT_TYPES',
        get: function get() {
          return TYPES;
        }
      }], [{
        key: 'addPropertyEffect',
        value: function addPropertyEffect(property, type, effect) {
          this.prototype._addPropertyEffect(property, type, effect);
        }

        /**
         * Creates a single-property observer for the given property.
         *
         * @param {string} property Property name
         * @param {string} methodName Name of observer method to call
         * @param {boolean=} dynamicFn Whether the method name should be included as
         *   a dependency to the effect.
         * @protected
         */

      }, {
        key: 'createPropertyObserver',
        value: function createPropertyObserver(property, methodName, dynamicFn) {
          this.prototype._createPropertyObserver(property, methodName, dynamicFn);
        }

        /**
         * Creates a multi-property "method observer" based on the provided
         * expression, which should be a string in the form of a normal Javascript
         * function signature: `'methodName(arg1, [..., argn])'`.  Each argument
         * should correspond to a property or path in the context of this
         * prototype (or instance), or may be a literal string or number.
         *
         * @param {string} expression Method expression
         * @param {boolean|Object=} dynamicFn Boolean or object map indicating
         *   whether method names should be included as a dependency to the effect.
         * @protected
         */

      }, {
        key: 'createMethodObserver',
        value: function createMethodObserver(expression, dynamicFn) {
          this.prototype._createMethodObserver(expression, dynamicFn);
        }

        /**
         * Causes the setter for the given property to dispatch `<property>-changed`
         * events to notify of changes to the property.
         *
         * @param {string} property Property name
         * @protected
         */

      }, {
        key: 'createNotifyingProperty',
        value: function createNotifyingProperty(property) {
          this.prototype._createNotifyingProperty(property);
        }

        /**
         * Creates a read-only accessor for the given property.
         *
         * To set the property, use the protected `_setProperty` API.
         * To create a custom protected setter (e.g. `_setMyProp()` for
         * property `myProp`), pass `true` for `protectedSetter`.
         *
         * Note, if the property will have other property effects, this method
         * should be called first, before adding other effects.
         *
         * @param {string} property Property name
         * @param {boolean=} protectedSetter Creates a custom protected setter
         *   when `true`.
         * @protected
         */

      }, {
        key: 'createReadOnlyProperty',
        value: function createReadOnlyProperty(property, protectedSetter) {
          this.prototype._createReadOnlyProperty(property, protectedSetter);
        }

        /**
         * Causes the setter for the given property to reflect the property value
         * to a (dash-cased) attribute of the same name.
         *
         * @param {string} property Property name
         * @protected
         */

      }, {
        key: 'createReflectedProperty',
        value: function createReflectedProperty(property) {
          this.prototype._createReflectedProperty(property);
        }

        /**
         * Creates a computed property whose value is set to the result of the
         * method described by the given `expression` each time one or more
         * arguments to the method changes.  The expression should be a string
         * in the form of a normal Javascript function signature:
         * `'methodName(arg1, [..., argn])'`
         *
         * @param {string} property Name of computed property to set
         * @param {string} expression Method expression
         * @param {boolean|Object=} dynamicFn Boolean or object map indicating whether
         *   method names should be included as a dependency to the effect.
         * @protected
         */

      }, {
        key: 'createComputedProperty',
        value: function createComputedProperty(property, expression, dynamicFn) {
          this.prototype._createComputedProperty(property, expression, dynamicFn);
        }

        /**
         * Parses the provided template to ensure binding effects are created
         * for them, and then ensures property accessors are created for any
         * dependent properties in the template.  Binding effects for bound
         * templates are stored in a linked list on the instance so that
         * templates can be efficiently stamped and unstamped.
         *
         * @param {HTMLTemplateElement} template Template containing binding
         *   bindings
         * @return {Object} Template metadata object
         * @protected
         */

      }, {
        key: 'bindTemplate',
        value: function bindTemplate(template) {
          return this.prototype._bindTemplate(template);
        }
      }, {
        key: '_addTemplatePropertyEffect',
        value: function _addTemplatePropertyEffect(templateInfo, prop, effect) {
          var hostProps = templateInfo.hostProps = templateInfo.hostProps || {};
          hostProps[prop] = true;
          var effects = templateInfo.propertyEffects = templateInfo.propertyEffects || {};
          var propEffects = effects[prop] = effects[prop] || [];
          propEffects.push(effect);
        }
      }, {
        key: '_parseTemplateNode',
        value: function _parseTemplateNode(node, templateInfo, nodeInfo) {
          var noted = _get(PropertyEffects.__proto__ || Object.getPrototypeOf(PropertyEffects), '_parseTemplateNode', this).call(this, node, templateInfo, nodeInfo);
          if (node.nodeType === Node.TEXT_NODE) {
            var parts = this._parseBindings(node.textContent, templateInfo);
            if (parts) {
              // Initialize the textContent with any literal parts
              // NOTE: default to a space here so the textNode remains; some browsers
              // (IE) evacipate an empty textNode following cloneNode/importNode.
              node.textContent = literalFromParts(parts) || ' ';
              addBinding(this, templateInfo, nodeInfo, 'text', 'textContent', parts);
              noted = true;
            }
          }
          return noted;
        }

        /**
         * Overrides default `TemplateStamp` implementation to add support for
         * parsing bindings from attributes.  A `bindings`
         * array is added to `nodeInfo` and populated with binding metadata
         * with information capturing the binding target, and a `parts` array
         * with one or more metadata objects capturing the source(s) of the
         * binding.
         *
         * @override
         * @param {Element} node Node to parse
         * @param {TemplateInfo} templateInfo Template metadata for current template
         * @param {NodeInfo} nodeInfo Node metadata for current template node
         * @return {boolean} `true` if the visited node added node-specific
         *   metadata to `nodeInfo`
         * @protected
         * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
         */

      }, {
        key: '_parseTemplateNodeAttribute',
        value: function _parseTemplateNodeAttribute(node, templateInfo, nodeInfo, name, value) {
          var parts = this._parseBindings(value, templateInfo);
          if (parts) {
            // Attribute or property
            var origName = name;
            var kind = 'property';
            if (name[name.length - 1] == '$') {
              name = name.slice(0, -1);
              kind = 'attribute';
            }
            // Initialize attribute bindings with any literal parts
            var literal = literalFromParts(parts);
            if (literal && kind == 'attribute') {
              node.setAttribute(name, literal);
            }
            // Clear attribute before removing, since IE won't allow removing
            // `value` attribute if it previously had a value (can't
            // unconditionally set '' before removing since attributes with `$`
            // can't be set using setAttribute)
            if (node.localName === 'input' && origName === 'value') {
              node.setAttribute(origName, '');
            }
            // Remove annotation
            node.removeAttribute(origName);
            // Case hackery: attributes are lower-case, but bind targets
            // (properties) are case sensitive. Gambit is to map dash-case to
            // camel-case: `foo-bar` becomes `fooBar`.
            // Attribute bindings are excepted.
            if (kind === 'property') {
              name = Polymer.CaseMap.dashToCamelCase(name);
            }
            addBinding(this, templateInfo, nodeInfo, kind, name, parts, literal);
            return true;
          } else {
            return _get(PropertyEffects.__proto__ || Object.getPrototypeOf(PropertyEffects), '_parseTemplateNodeAttribute', this).call(this, node, templateInfo, nodeInfo, name, value);
          }
        }

        /**
         * Overrides default `TemplateStamp` implementation to add support for
         * binding the properties that a nested template depends on to the template
         * as `_host_<property>`.
         *
         * @override
         * @param {Node} node Node to parse
         * @param {TemplateInfo} templateInfo Template metadata for current template
         * @param {NodeInfo} nodeInfo Node metadata for current template node
         * @return {boolean} `true` if the visited node added node-specific
         *   metadata to `nodeInfo`
         * @protected
         * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
         */

      }, {
        key: '_parseTemplateNestedTemplate',
        value: function _parseTemplateNestedTemplate(node, templateInfo, nodeInfo) {
          var noted = _get(PropertyEffects.__proto__ || Object.getPrototypeOf(PropertyEffects), '_parseTemplateNestedTemplate', this).call(this, node, templateInfo, nodeInfo);
          // Merge host props into outer template and add bindings
          var hostProps = nodeInfo.templateInfo.hostProps;
          var mode = '{';
          for (var source in hostProps) {
            var parts = [{ mode: mode, source: source, dependencies: [source] }];
            addBinding(this, templateInfo, nodeInfo, 'property', '_host_' + source, parts);
          }
          return noted;
        }

        /**
         * Called to parse text in a template (either attribute values or
         * textContent) into binding metadata.
         *
         * Any overrides of this method should return an array of binding part
         * metadata  representing one or more bindings found in the provided text
         * and any "literal" text in between.  Any non-literal parts will be passed
         * to `_evaluateBinding` when any dependencies change.  The only required
         * fields of each "part" in the returned array are as follows:
         *
         * - `dependencies` - Array containing trigger metadata for each property
         *   that should trigger the binding to update
         * - `literal` - String containing text if the part represents a literal;
         *   in this case no `dependencies` are needed
         *
         * Additional metadata for use by `_evaluateBinding` may be provided in
         * each part object as needed.
         *
         * The default implementation handles the following types of bindings
         * (one or more may be intermixed with literal strings):
         * - Property binding: `[[prop]]`
         * - Path binding: `[[object.prop]]`
         * - Negated property or path bindings: `[[!prop]]` or `[[!object.prop]]`
         * - Two-way property or path bindings (supports negation):
         *   `{{prop}}`, `{{object.prop}}`, `{{!prop}}` or `{{!object.prop}}`
         * - Inline computed method (supports negation):
         *   `[[compute(a, 'literal', b)]]`, `[[!compute(a, 'literal', b)]]`
         *
         * @param {string} text Text to parse from attribute or textContent
         * @param {Object} templateInfo Current template metadata
         * @return {Array<!BindingPart>} Array of binding part metadata
         * @protected
         */

      }, {
        key: '_parseBindings',
        value: function _parseBindings(text, templateInfo) {
          var parts = [];
          var lastIndex = 0;
          var m = void 0;
          // Example: "literal1{{prop}}literal2[[!compute(foo,bar)]]final"
          // Regex matches:
          //        Iteration 1:  Iteration 2:
          // m[1]: '{{'          '[['
          // m[2]: ''            '!'
          // m[3]: 'prop'        'compute(foo,bar)'
          while ((m = bindingRegex.exec(text)) !== null) {
            // Add literal part
            if (m.index > lastIndex) {
              parts.push({ literal: text.slice(lastIndex, m.index) });
            }
            // Add binding part
            var mode = m[1][0];
            var negate = Boolean(m[2]);
            var source = m[3].trim();
            var customEvent = false,
                notifyEvent = '',
                colon = -1;
            if (mode == '{' && (colon = source.indexOf('::')) > 0) {
              notifyEvent = source.substring(colon + 2);
              source = source.substring(0, colon);
              customEvent = true;
            }
            var signature = parseMethod(source);
            var dependencies = [];
            if (signature) {
              // Inline computed function
              var args = signature.args,
                  methodName = signature.methodName;

              for (var i = 0; i < args.length; i++) {
                var arg = args[i];
                if (!arg.literal) {
                  dependencies.push(arg);
                }
              }
              var dynamicFns = templateInfo.dynamicFns;
              if (dynamicFns && dynamicFns[methodName] || signature.static) {
                dependencies.push(methodName);
                signature.dynamicFn = true;
              }
            } else {
              // Property or path
              dependencies.push(source);
            }
            parts.push({
              source: source, mode: mode, negate: negate, customEvent: customEvent, signature: signature, dependencies: dependencies,
              event: notifyEvent
            });
            lastIndex = bindingRegex.lastIndex;
          }
          // Add a final literal part
          if (lastIndex && lastIndex < text.length) {
            var literal = text.substring(lastIndex);
            if (literal) {
              parts.push({
                literal: literal
              });
            }
          }
          if (parts.length) {
            return parts;
          } else {
            return null;
          }
        }

        /**
         * Called to evaluate a previously parsed binding part based on a set of
         * one or more changed dependencies.
         *
         * @param {this} inst Element that should be used as scope for
         *   binding dependencies
         * @param {BindingPart} part Binding part metadata
         * @param {string} path Property/path that triggered this effect
         * @param {Object} props Bag of current property changes
         * @param {Object} oldProps Bag of previous values for changed properties
         * @param {boolean} hasPaths True with `props` contains one or more paths
         * @return {*} Value the binding part evaluated to
         * @protected
         */

      }, {
        key: '_evaluateBinding',
        value: function _evaluateBinding(inst, part, path, props, oldProps, hasPaths) {
          var value = void 0;
          if (part.signature) {
            value = runMethodEffect(inst, path, props, oldProps, part.signature);
          } else if (path != part.source) {
            value = Polymer.Path.get(inst, part.source);
          } else {
            if (hasPaths && Polymer.Path.isPath(path)) {
              value = Polymer.Path.get(inst, path);
            } else {
              value = inst.__data[path];
            }
          }
          if (part.negate) {
            value = !value;
          }
          return value;
        }
      }]);

      return PropertyEffects;
    }(propertyEffectsBase);

    // make a typing for closure :P


    PropertyEffectsType = PropertyEffects;

    return PropertyEffects;
  });

  /**
   * Helper api for enqueing client dom created by a host element.
   *
   * By default elements are flushed via `_flushProperties` when
   * `connectedCallback` is called. Elements attach their client dom to
   * themselves at `ready` time which results from this first flush.
   * This provides an ordering guarantee that the client dom an element
   * creates is flushed before the element itself (i.e. client `ready`
   * fires before host `ready`).
   *
   * However, if `_flushProperties` is called *before* an element is connected,
   * as for example `Templatize` does, this ordering guarantee cannot be
   * satisfied because no elements are connected. (Note: Bound elements that
   * receive data do become enqueued clients and are properly ordered but
   * unbound elements are not.)
   *
   * To maintain the desired "client before host" ordering guarantee for this
   * case we rely on the "host stack. Client nodes registers themselves with
   * the creating host element when created. This ensures that all client dom
   * is readied in the proper order, maintaining the desired guarantee.
   *
   * @private
   */
  var hostStack = {

    stack: [],

    /**
     * @param {*} inst Instance to add to hostStack
     * @this {hostStack}
     */
    registerHost: function registerHost(inst) {
      if (this.stack.length) {
        var host = this.stack[this.stack.length - 1];
        host._enqueueClient(inst);
      }
    },


    /**
     * @param {*} inst Instance to begin hosting
     * @this {hostStack}
     */
    beginHosting: function beginHosting(inst) {
      this.stack.push(inst);
    },


    /**
     * @param {*} inst Instance to end hosting
     * @this {hostStack}
     */
    endHosting: function endHosting(inst) {
      var stackLen = this.stack.length;
      if (stackLen && this.stack[stackLen - 1] == inst) {
        this.stack.pop();
      }
    }
  };
})();

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

__webpack_require__(1);

__webpack_require__(3);

__webpack_require__(8);

(function () {
  'use strict';

  /** @typedef {{run: function(function(), number=):number, cancel: function(number)}} */

  var AsyncModule = void 0; // eslint-disable-line no-unused-vars

  /**
   * @summary Collapse multiple callbacks into one invocation after a timer.
   * @memberof Polymer
   */

  var Debouncer = function () {
    function Debouncer() {
      _classCallCheck(this, Debouncer);

      this._asyncModule = null;
      this._callback = null;
      this._timer = null;
    }
    /**
     * Sets the scheduler; that is, a module with the Async interface,
     * a callback and optional arguments to be passed to the run function
     * from the async module.
     *
     * @param {!AsyncModule} asyncModule Object with Async interface.
     * @param {function()} callback Callback to run.
     */


    _createClass(Debouncer, [{
      key: 'setConfig',
      value: function setConfig(asyncModule, callback) {
        var _this = this;

        this._asyncModule = asyncModule;
        this._callback = callback;
        this._timer = this._asyncModule.run(function () {
          _this._timer = null;
          _this._callback();
        });
      }
      /**
       * Cancels an active debouncer and returns a reference to itself.
       */

    }, {
      key: 'cancel',
      value: function cancel() {
        if (this.isActive()) {
          this._asyncModule.cancel(this._timer);
          this._timer = null;
        }
      }
      /**
       * Flushes an active debouncer and returns a reference to itself.
       */

    }, {
      key: 'flush',
      value: function flush() {
        if (this.isActive()) {
          this.cancel();
          this._callback();
        }
      }
      /**
       * Returns true if the debouncer is active.
       *
       * @return {boolean} True if active.
       */

    }, {
      key: 'isActive',
      value: function isActive() {
        return this._timer != null;
      }
      /**
       * Creates a debouncer if no debouncer is passed as a parameter
       * or it cancels an active debouncer otherwise. The following
       * example shows how a debouncer can be called multiple times within a
       * microtask and "debounced" such that the provided callback function is
       * called once. Add this method to a custom element:
       *
       * _debounceWork() {
       *   this._debounceJob = Polymer.Debouncer.debounce(this._debounceJob,
       *       Polymer.Async.microTask, () => {
       *     this._doWork();
       *   });
       * }
       *
       * If the `_debounceWork` method is called multiple times within the same
       * microtask, the `_doWork` function will be called only once at the next
       * microtask checkpoint.
       *
       * Note: In testing it is often convenient to avoid asynchrony. To accomplish
       * this with a debouncer, you can use `Polymer.enqueueDebouncer` and
       * `Polymer.flush`. For example, extend the above example by adding
       * `Polymer.enqueueDebouncer(this._debounceJob)` at the end of the
       * `_debounceWork` method. Then in a test, call `Polymer.flush` to ensure
       * the debouncer has completed.
       *
       * @param {Debouncer?} debouncer Debouncer object.
       * @param {!AsyncModule} asyncModule Object with Async interface
       * @param {function()} callback Callback to run.
       * @return {!Debouncer} Returns a debouncer object.
       */

    }], [{
      key: 'debounce',
      value: function debounce(debouncer, asyncModule, callback) {
        if (debouncer instanceof Debouncer) {
          debouncer.cancel();
        } else {
          debouncer = new Debouncer();
        }
        debouncer.setConfig(asyncModule, callback);
        return debouncer;
      }
    }]);

    return Debouncer;
  }();

  Polymer.Debouncer = Debouncer;
})();

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(1);

(function () {
  'use strict';

  var debouncerQueue = [];

  /**
   * Adds a `Polymer.Debouncer` to a list of globally flushable tasks.
   *
   * @memberof Polymer
   * @param {Polymer.Debouncer} debouncer Debouncer to enqueue
   */
  Polymer.enqueueDebouncer = function (debouncer) {
    debouncerQueue.push(debouncer);
  };

  function flushDebouncers() {
    var didFlush = Boolean(debouncerQueue.length);
    while (debouncerQueue.length) {
      try {
        debouncerQueue.shift().flush();
      } catch (e) {
        setTimeout(function () {
          throw e;
        });
      }
    }
    return didFlush;
  }

  /**
   * Forces several classes of asynchronously queued tasks to flush:
   * - Debouncers added via `enqueueDebouncer`
   * - ShadyDOM distribution
   *
   * @memberof Polymer
   */
  Polymer.flush = function () {
    var shadyDOM = void 0,
        debouncers = void 0;
    do {
      shadyDOM = window.ShadyDOM && ShadyDOM.flush();
      if (window.ShadyCSS && window.ShadyCSS.ScopingShim) {
        window.ShadyCSS.ScopingShim.flush();
      }
      debouncers = flushDebouncers();
    } while (shadyDOM || debouncers);
  };
})();

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

__webpack_require__(1);

__webpack_require__(11);

__webpack_require__(9);

(function () {
  'use strict';

  // Base class for HTMLTemplateElement extension that has property effects
  // machinery for propagating host properties to children. This is an ES5
  // class only because Babel (incorrectly) requires super() in the class
  // constructor even though no `this` is used and it returns an instance.

  var newInstance = null;
  /**
   * @constructor
   * @extends {HTMLTemplateElement}
   */
  function HTMLTemplateElementExtension() {
    return newInstance;
  }
  HTMLTemplateElementExtension.prototype = Object.create(HTMLTemplateElement.prototype, {
    constructor: {
      value: HTMLTemplateElementExtension,
      writable: true
    }
  });
  /**
   * @constructor
   * @implements {Polymer_PropertyEffects}
   * @extends {HTMLTemplateElementExtension}
   */
  var DataTemplate = Polymer.PropertyEffects(HTMLTemplateElementExtension);
  /**
   * @constructor
   * @implements {Polymer_MutableData}
   * @extends {DataTemplate}
   */
  var MutableDataTemplate = Polymer.MutableData(DataTemplate);

  // Applies a DataTemplate subclass to a <template> instance
  function upgradeTemplate(template, constructor) {
    newInstance = template;
    Object.setPrototypeOf(template, constructor.prototype);
    new constructor();
    newInstance = null;
  }

  // Base class for TemplateInstance's
  /**
   * @constructor
   * @implements {Polymer_PropertyEffects}
   */
  var base = Polymer.PropertyEffects(function () {
    function _class() {
      _classCallCheck(this, _class);
    }

    return _class;
  }());

  /**
   * @polymer
   * @customElement
   * @appliesMixin Polymer.PropertyEffects
   * @unrestricted
   */

  var TemplateInstanceBase = function (_base) {
    _inherits(TemplateInstanceBase, _base);

    function TemplateInstanceBase(props) {
      _classCallCheck(this, TemplateInstanceBase);

      var _this = _possibleConstructorReturn(this, (TemplateInstanceBase.__proto__ || Object.getPrototypeOf(TemplateInstanceBase)).call(this));

      _this._configureProperties(props);
      _this.root = _this._stampTemplate(_this.__dataHost);
      // Save list of stamped children
      var children = _this.children = [];
      for (var n = _this.root.firstChild; n; n = n.nextSibling) {
        children.push(n);
        n.__templatizeInstance = _this;
      }
      if (_this.__templatizeOwner.__hideTemplateChildren__) {
        _this._showHideChildren(true);
      }
      // Flush props only when props are passed if instance props exist
      // or when there isn't instance props.
      var options = _this.__templatizeOptions;
      if (props && options.instanceProps || !options.instanceProps) {
        _this._enableProperties();
      }
      return _this;
    }
    /**
     * Configure the given `props` by calling `_setPendingProperty`. Also
     * sets any properties stored in `__hostProps`.
     * @private
     * @param {Object} props Object of property name-value pairs to set.
     */


    _createClass(TemplateInstanceBase, [{
      key: '_configureProperties',
      value: function _configureProperties(props) {
        var options = this.__templatizeOptions;
        if (props) {
          for (var iprop in options.instanceProps) {
            if (iprop in props) {
              this._setPendingProperty(iprop, props[iprop]);
            }
          }
        }
        for (var hprop in this.__hostProps) {
          this._setPendingProperty(hprop, this.__dataHost['_host_' + hprop]);
        }
      }
      /**
       * Forwards a host property to this instance.  This method should be
       * called on instances from the `options.forwardHostProp` callback
       * to propagate changes of host properties to each instance.
       *
       * Note this method enqueues the change, which are flushed as a batch.
       *
       * @param {string} prop Property or path name
       * @param {*} value Value of the property to forward
       */

    }, {
      key: 'forwardHostProp',
      value: function forwardHostProp(prop, value) {
        if (this._setPendingPropertyOrPath(prop, value, false, true)) {
          this.__dataHost._enqueueClient(this);
        }
      }
      /**
       * @override
       */

    }, {
      key: '_addEventListenerToNode',
      value: function _addEventListenerToNode(node, eventName, handler) {
        var _this2 = this;

        if (this._methodHost && this.__templatizeOptions.parentModel) {
          // If this instance should be considered a parent model, decorate
          // events this template instance as `model`
          this._methodHost._addEventListenerToNode(node, eventName, function (e) {
            e.model = _this2;
            handler(e);
          });
        } else {
          // Otherwise delegate to the template's host (which could be)
          // another template instance
          var templateHost = this.__dataHost.__dataHost;
          if (templateHost) {
            templateHost._addEventListenerToNode(node, eventName, handler);
          }
        }
      }
      /**
       * Shows or hides the template instance top level child elements. For
       * text nodes, `textContent` is removed while "hidden" and replaced when
       * "shown."
       * @param {boolean} hide Set to true to hide the children;
       * set to false to show them.
       * @protected
       */

    }, {
      key: '_showHideChildren',
      value: function _showHideChildren(hide) {
        var c = this.children;
        for (var i = 0; i < c.length; i++) {
          var n = c[i];
          // Ignore non-changes
          if (Boolean(hide) != Boolean(n.__hideTemplateChildren__)) {
            if (n.nodeType === Node.TEXT_NODE) {
              if (hide) {
                n.__polymerTextContent__ = n.textContent;
                n.textContent = '';
              } else {
                n.textContent = n.__polymerTextContent__;
              }
            } else if (n.style) {
              if (hide) {
                n.__polymerDisplay__ = n.style.display;
                n.style.display = 'none';
              } else {
                n.style.display = n.__polymerDisplay__;
              }
            }
          }
          n.__hideTemplateChildren__ = hide;
          if (n._showHideChildren) {
            n._showHideChildren(hide);
          }
        }
      }
      /**
       * Overrides default property-effects implementation to intercept
       * textContent bindings while children are "hidden" and cache in
       * private storage for later retrieval.
       *
       * @override
       */

    }, {
      key: '_setUnmanagedPropertyToNode',
      value: function _setUnmanagedPropertyToNode(node, prop, value) {
        if (node.__hideTemplateChildren__ && node.nodeType == Node.TEXT_NODE && prop == 'textContent') {
          node.__polymerTextContent__ = value;
        } else {
          _get(TemplateInstanceBase.prototype.__proto__ || Object.getPrototypeOf(TemplateInstanceBase.prototype), '_setUnmanagedPropertyToNode', this).call(this, node, prop, value);
        }
      }
      /**
       * Find the parent model of this template instance.  The parent model
       * is either another templatize instance that had option `parentModel: true`,
       * or else the host element.
       *
       * @return {Polymer_PropertyEffects} The parent model of this instance
       */

    }, {
      key: 'parentModel',
      get: function get() {
        var model = this.__parentModel;
        if (!model) {
          var options = void 0;
          model = this;
          do {
            // A template instance's `__dataHost` is a <template>
            // `model.__dataHost.__dataHost` is the template's host
            model = model.__dataHost.__dataHost;
          } while ((options = model.__templatizeOptions) && !options.parentModel);
          this.__parentModel = model;
        }
        return model;
      }
    }]);

    return TemplateInstanceBase;
  }(base);

  /** @type {!DataTemplate} */


  TemplateInstanceBase.prototype.__dataHost;
  /** @type {!TemplatizeOptions} */
  TemplateInstanceBase.prototype.__templatizeOptions;
  /** @type {!Polymer_PropertyEffects} */
  TemplateInstanceBase.prototype._methodHost;
  /** @type {!Object} */
  TemplateInstanceBase.prototype.__templatizeOwner;
  /** @type {!Object} */
  TemplateInstanceBase.prototype.__hostProps;

  /**
   * @constructor
   * @extends {TemplateInstanceBase}
   * @implements {Polymer_MutableData}
   */
  var MutableTemplateInstanceBase = Polymer.MutableData(TemplateInstanceBase);

  function findMethodHost(template) {
    // Technically this should be the owner of the outermost template.
    // In shadow dom, this is always getRootNode().host, but we can
    // approximate this via cooperation with our dataHost always setting
    // `_methodHost` as long as there were bindings (or id's) on this
    // instance causing it to get a dataHost.
    var templateHost = template.__dataHost;
    return templateHost && templateHost._methodHost || templateHost;
  }

  /* eslint-disable valid-jsdoc */
  /**
   * @suppress {missingProperties} class.prototype is not defined for some reason
   */
  function createTemplatizerClass(template, templateInfo, options) {
    // Anonymous class created by the templatize
    var base = options.mutableData ? MutableTemplateInstanceBase : TemplateInstanceBase;
    /**
     * @constructor
     * @extends {base}
     */
    var klass = function (_base2) {
      _inherits(klass, _base2);

      function klass() {
        _classCallCheck(this, klass);

        return _possibleConstructorReturn(this, (klass.__proto__ || Object.getPrototypeOf(klass)).apply(this, arguments));
      }

      return klass;
    }(base);
    klass.prototype.__templatizeOptions = options;
    klass.prototype._bindTemplate(template);
    addNotifyEffects(klass, template, templateInfo, options);
    return klass;
  }

  /**
   * @suppress {missingProperties} class.prototype is not defined for some reason
   */
  function addPropagateEffects(template, templateInfo, options) {
    var userForwardHostProp = options.forwardHostProp;
    if (userForwardHostProp) {
      // Provide data API and property effects on memoized template class
      var klass = templateInfo.templatizeTemplateClass;
      if (!klass) {
        var _base3 = options.mutableData ? MutableDataTemplate : DataTemplate;
        klass = templateInfo.templatizeTemplateClass = function (_base4) {
          _inherits(TemplatizedTemplate, _base4);

          function TemplatizedTemplate() {
            _classCallCheck(this, TemplatizedTemplate);

            return _possibleConstructorReturn(this, (TemplatizedTemplate.__proto__ || Object.getPrototypeOf(TemplatizedTemplate)).apply(this, arguments));
          }

          return TemplatizedTemplate;
        }(_base3);
        // Add template - >instances effects
        // and host <- template effects
        var hostProps = templateInfo.hostProps;
        for (var prop in hostProps) {
          klass.prototype._addPropertyEffect('_host_' + prop, klass.prototype.PROPERTY_EFFECT_TYPES.PROPAGATE, { fn: createForwardHostPropEffect(prop, userForwardHostProp) });
          klass.prototype._createNotifyingProperty('_host_' + prop);
        }
      }
      upgradeTemplate(template, klass);
      // Mix any pre-bound data into __data; no need to flush this to
      // instances since they pull from the template at instance-time
      if (template.__dataProto) {
        // Note, generally `__dataProto` could be chained, but it's guaranteed
        // to not be since this is a vanilla template we just added effects to
        Object.assign(template.__data, template.__dataProto);
      }
      // Clear any pending data for performance
      template.__dataTemp = {};
      template.__dataPending = null;
      template.__dataOld = null;
      template._enableProperties();
    }
  }
  /* eslint-enable valid-jsdoc */

  function createForwardHostPropEffect(hostProp, userForwardHostProp) {
    return function forwardHostProp(template, prop, props) {
      userForwardHostProp.call(template.__templatizeOwner, prop.substring('_host_'.length), props[prop]);
    };
  }

  function addNotifyEffects(klass, template, templateInfo, options) {
    var hostProps = templateInfo.hostProps || {};
    for (var iprop in options.instanceProps) {
      delete hostProps[iprop];
      var userNotifyInstanceProp = options.notifyInstanceProp;
      if (userNotifyInstanceProp) {
        klass.prototype._addPropertyEffect(iprop, klass.prototype.PROPERTY_EFFECT_TYPES.NOTIFY, { fn: createNotifyInstancePropEffect(iprop, userNotifyInstanceProp) });
      }
    }
    if (options.forwardHostProp && template.__dataHost) {
      for (var hprop in hostProps) {
        klass.prototype._addPropertyEffect(hprop, klass.prototype.PROPERTY_EFFECT_TYPES.NOTIFY, { fn: createNotifyHostPropEffect() });
      }
    }
  }

  function createNotifyInstancePropEffect(instProp, userNotifyInstanceProp) {
    return function notifyInstanceProp(inst, prop, props) {
      userNotifyInstanceProp.call(inst.__templatizeOwner, inst, prop, props[prop]);
    };
  }

  function createNotifyHostPropEffect() {
    return function notifyHostProp(inst, prop, props) {
      inst.__dataHost._setPendingPropertyOrPath('_host_' + prop, props[prop], true, true);
    };
  }

  /**
   * Module for preparing and stamping instances of templates that utilize
   * Polymer's data-binding and declarative event listener features.
   *
   * Example:
   *
   *     // Get a template from somewhere, e.g. light DOM
   *     let template = this.querySelector('template');
   *     // Prepare the template
   *     let TemplateClass = Polymer.Templatize.templatize(template);
   *     // Instance the template with an initial data model
   *     let instance = new TemplateClass({myProp: 'initial'});
   *     // Insert the instance's DOM somewhere, e.g. element's shadow DOM
   *     this.shadowRoot.appendChild(instance.root);
   *     // Changing a property on the instance will propagate to bindings
   *     // in the template
   *     instance.myProp = 'new value';
   *
   * The `options` dictionary passed to `templatize` allows for customizing
   * features of the generated template class, including how outer-scope host
   * properties should be forwarded into template instances, how any instance
   * properties added into the template's scope should be notified out to
   * the host, and whether the instance should be decorated as a "parent model"
   * of any event handlers.
   *
   *     // Customze property forwarding and event model decoration
   *     let TemplateClass = Polymer.Templatize.templatize(template, this, {
   *       parentModel: true,
   *       instanceProps: {...},
   *       forwardHostProp(property, value) {...},
   *       notifyInstanceProp(instance, property, value) {...},
   *     });
   *
   *
   * @namespace
   * @memberof Polymer
   * @summary Module for preparing and stamping instances of templates
   *   utilizing Polymer templating features.
   */

  var Templatize = {

    /**
     * Returns an anonymous `Polymer.PropertyEffects` class bound to the
     * `<template>` provided.  Instancing the class will result in the
     * template being stamped into document fragment stored as the instance's
     * `root` property, after which it can be appended to the DOM.
     *
     * Templates may utilize all Polymer data-binding features as well as
     * declarative event listeners.  Event listeners and inline computing
     * functions in the template will be called on the host of the template.
     *
     * The constructor returned takes a single argument dictionary of initial
     * property values to propagate into template bindings.  Additionally
     * host properties can be forwarded in, and instance properties can be
     * notified out by providing optional callbacks in the `options` dictionary.
     *
     * Valid configuration in `options` are as follows:
     *
     * - `forwardHostProp(property, value)`: Called when a property referenced
     *   in the template changed on the template's host. As this library does
     *   not retain references to templates instanced by the user, it is the
     *   templatize owner's responsibility to forward host property changes into
     *   user-stamped instances.  The `instance.forwardHostProp(property, value)`
     *    method on the generated class should be called to forward host
     *   properties into the template to prevent unnecessary property-changed
     *   notifications. Any properties referenced in the template that are not
     *   defined in `instanceProps` will be notified up to the template's host
     *   automatically.
     * - `instanceProps`: Dictionary of property names that will be added
     *   to the instance by the templatize owner.  These properties shadow any
     *   host properties, and changes within the template to these properties
     *   will result in `notifyInstanceProp` being called.
     * - `mutableData`: When `true`, the generated class will skip strict
     *   dirty-checking for objects and arrays (always consider them to be
     *   "dirty").
     * - `notifyInstanceProp(instance, property, value)`: Called when
     *   an instance property changes.  Users may choose to call `notifyPath`
     *   on e.g. the owner to notify the change.
     * - `parentModel`: When `true`, events handled by declarative event listeners
     *   (`on-event="handler"`) will be decorated with a `model` property pointing
     *   to the template instance that stamped it.  It will also be returned
     *   from `instance.parentModel` in cases where template instance nesting
     *   causes an inner model to shadow an outer model.
     *
     * Note that the class returned from `templatize` is generated only once
     * for a given `<template>` using `options` from the first call for that
     * template, and the cached class is returned for all subsequent calls to
     * `templatize` for that template.  As such, `options` callbacks should not
     * close over owner-specific properties since only the first `options` is
     * used; rather, callbacks are called bound to the `owner`, and so context
     * needed from the callbacks (such as references to `instances` stamped)
     * should be stored on the `owner` such that they can be retrieved via `this`.
     *
     * @memberof Polymer.Templatize
     * @param {!HTMLTemplateElement} template Template to templatize
     * @param {!Polymer_PropertyEffects} owner Owner of the template instances;
     *   any optional callbacks will be bound to this owner.
     * @param {Object=} options Options dictionary (see summary for details)
     * @return {function(new:TemplateInstanceBase)} Generated class bound to the template
     *   provided
     * @suppress {invalidCasts}
     */
    templatize: function templatize(template, owner, options) {
      options = /** @type {!TemplatizeOptions} */options || {};
      if (template.__templatizeOwner) {
        throw new Error('A <template> can only be templatized once');
      }
      template.__templatizeOwner = owner;
      var templateInfo = owner.constructor._parseTemplate(template);
      // Get memoized base class for the prototypical template, which
      // includes property effects for binding template & forwarding
      var baseClass = templateInfo.templatizeInstanceClass;
      if (!baseClass) {
        baseClass = createTemplatizerClass(template, templateInfo, options);
        templateInfo.templatizeInstanceClass = baseClass;
      }
      // Host property forwarding must be installed onto template instance
      addPropagateEffects(template, templateInfo, options);
      // Subclass base class and add reference for this specific template
      var klass = function (_baseClass) {
        _inherits(TemplateInstance, _baseClass);

        function TemplateInstance() {
          _classCallCheck(this, TemplateInstance);

          return _possibleConstructorReturn(this, (TemplateInstance.__proto__ || Object.getPrototypeOf(TemplateInstance)).apply(this, arguments));
        }

        return TemplateInstance;
      }(baseClass);
      klass.prototype._methodHost = findMethodHost(template);
      klass.prototype.__dataHost = template;
      klass.prototype.__templatizeOwner = owner;
      klass.prototype.__hostProps = templateInfo.hostProps;
      return (/** @type {function(new:TemplateInstanceBase)} */klass
      );
    },


    /**
     * Returns the template "model" associated with a given element, which
     * serves as the binding scope for the template instance the element is
     * contained in. A template model is an instance of
     * `TemplateInstanceBase`, and should be used to manipulate data
     * associated with this template instance.
     *
     * Example:
     *
     *   let model = modelForElement(el);
     *   if (model.index < 10) {
     *     model.set('item.checked', true);
     *   }
     *
     * @memberof Polymer.Templatize
     * @param {HTMLTemplateElement} template The model will be returned for
     *   elements stamped from this template
     * @param {Node} node Node for which to return a template model.
     * @return {TemplateInstanceBase} Template instance representing the
     *   binding scope for the element
     */
    modelForElement: function modelForElement(template, node) {
      var model = void 0;
      while (node) {
        // An element with a __templatizeInstance marks the top boundary
        // of a scope; walk up until we find one, and then ensure that
        // its __dataHost matches `this`, meaning this dom-repeat stamped it
        if (model = node.__templatizeInstance) {
          // Found an element stamped by another template; keep walking up
          // from its __dataHost
          if (model.__dataHost != template) {
            node = model.__dataHost;
          } else {
            return model;
          }
        } else {
          // Still in a template scope, keep going up until
          // a __templatizeInstance is found
          node = node.parentNode;
        }
      }
      return null;
    }
  };

  Polymer.Templatize = Templatize;
  Polymer.TemplateInstanceBase = TemplateInstanceBase;
})();

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

__webpack_require__(17);

/**
 * @polymerBehavior Polymer.AppLayoutBehavior
 **/
Polymer.AppLayoutBehavior = [Polymer.IronResizableBehavior, {

  listeners: {
    'app-reset-layout': '_appResetLayoutHandler',
    'iron-resize': 'resetLayout'
  },

  attached: function attached() {
    this.fire('app-reset-layout');
  },

  _appResetLayoutHandler: function _appResetLayoutHandler(e) {
    if (Polymer.dom(e).path[0] === this) {
      return;
    }
    this.resetLayout();
    e.stopPropagation();
  },

  _updateLayoutStates: function _updateLayoutStates() {
    console.error('unimplemented');
  },

  /**
   * Resets the layout. If you changed the size of this element via CSS
   * you can notify the changes by either firing the `iron-resize` event
   * or calling `resetLayout` directly.
   *
   * @method resetLayout
   */
  resetLayout: function resetLayout() {
    // Polymer v2.x
    var self = this;
    var cb = this._updateLayoutStates.bind(this);
    if (Polymer.Async && Polymer.Async.animationFrame) {
      this._layoutDebouncer = Polymer.Debouncer.debounce(this._layoutDebouncer, Polymer.Async.animationFrame, cb);
      Polymer.enqueueDebouncer(this._layoutDebouncer);
    }
    // Polymer v1.x
    else {
        this.debounce('resetLayout', cb);
      }
    this._notifyDescendantResize();
  },

  _notifyLayoutChanged: function _notifyLayoutChanged() {
    var self = this;
    // TODO: the event `app-reset-layout` can be fired synchronously
    // as long as `_updateLayoutStates` waits for all the microtasks after rAF.
    // E.g. requestAnimationFrame(setTimeOut())
    requestAnimationFrame(function () {
      self.fire('app-reset-layout');
    });
  },

  _notifyDescendantResize: function _notifyDescendantResize() {
    if (!this.isAttached) {
      return;
    }
    this._interestedResizables.forEach(function (resizable) {
      if (this.resizerShouldNotify(resizable)) {
        this._notifyDescendant(resizable);
      }
    }, this);
  }
}];

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

(function () {
  'use strict';

  /**
   * Chrome uses an older version of DOM Level 3 Keyboard Events
   *
   * Most keys are labeled as text, but some are Unicode codepoints.
   * Values taken from: http://www.w3.org/TR/2007/WD-DOM-Level-3-Events-20071221/keyset.html#KeySet-Set
   */

  var KEY_IDENTIFIER = {
    'U+0008': 'backspace',
    'U+0009': 'tab',
    'U+001B': 'esc',
    'U+0020': 'space',
    'U+007F': 'del'
  };

  /**
   * Special table for KeyboardEvent.keyCode.
   * KeyboardEvent.keyIdentifier is better, and KeyBoardEvent.key is even better
   * than that.
   *
   * Values from: https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent.keyCode#Value_of_keyCode
   */
  var KEY_CODE = {
    8: 'backspace',
    9: 'tab',
    13: 'enter',
    27: 'esc',
    33: 'pageup',
    34: 'pagedown',
    35: 'end',
    36: 'home',
    32: 'space',
    37: 'left',
    38: 'up',
    39: 'right',
    40: 'down',
    46: 'del',
    106: '*'
  };

  /**
   * MODIFIER_KEYS maps the short name for modifier keys used in a key
   * combo string to the property name that references those same keys
   * in a KeyboardEvent instance.
   */
  var MODIFIER_KEYS = {
    'shift': 'shiftKey',
    'ctrl': 'ctrlKey',
    'alt': 'altKey',
    'meta': 'metaKey'
  };

  /**
   * KeyboardEvent.key is mostly represented by printable character made by
   * the keyboard, with unprintable keys labeled nicely.
   *
   * However, on OS X, Alt+char can make a Unicode character that follows an
   * Apple-specific mapping. In this case, we fall back to .keyCode.
   */
  var KEY_CHAR = /[a-z0-9*]/;

  /**
   * Matches a keyIdentifier string.
   */
  var IDENT_CHAR = /U\+/;

  /**
   * Matches arrow keys in Gecko 27.0+
   */
  var ARROW_KEY = /^arrow/;

  /**
   * Matches space keys everywhere (notably including IE10's exceptional name
   * `spacebar`).
   */
  var SPACE_KEY = /^space(bar)?/;

  /**
   * Matches ESC key.
   *
   * Value from: http://w3c.github.io/uievents-key/#key-Escape
   */
  var ESC_KEY = /^escape$/;

  /**
   * Transforms the key.
   * @param {string} key The KeyBoardEvent.key
   * @param {Boolean} [noSpecialChars] Limits the transformation to
   * alpha-numeric characters.
   */
  function transformKey(key, noSpecialChars) {
    var validKey = '';
    if (key) {
      var lKey = key.toLowerCase();
      if (lKey === ' ' || SPACE_KEY.test(lKey)) {
        validKey = 'space';
      } else if (ESC_KEY.test(lKey)) {
        validKey = 'esc';
      } else if (lKey.length == 1) {
        if (!noSpecialChars || KEY_CHAR.test(lKey)) {
          validKey = lKey;
        }
      } else if (ARROW_KEY.test(lKey)) {
        validKey = lKey.replace('arrow', '');
      } else if (lKey == 'multiply') {
        // numpad '*' can map to Multiply on IE/Windows
        validKey = '*';
      } else {
        validKey = lKey;
      }
    }
    return validKey;
  }

  function transformKeyIdentifier(keyIdent) {
    var validKey = '';
    if (keyIdent) {
      if (keyIdent in KEY_IDENTIFIER) {
        validKey = KEY_IDENTIFIER[keyIdent];
      } else if (IDENT_CHAR.test(keyIdent)) {
        keyIdent = parseInt(keyIdent.replace('U+', '0x'), 16);
        validKey = String.fromCharCode(keyIdent).toLowerCase();
      } else {
        validKey = keyIdent.toLowerCase();
      }
    }
    return validKey;
  }

  function transformKeyCode(keyCode) {
    var validKey = '';
    if (Number(keyCode)) {
      if (keyCode >= 65 && keyCode <= 90) {
        // ascii a-z
        // lowercase is 32 offset from uppercase
        validKey = String.fromCharCode(32 + keyCode);
      } else if (keyCode >= 112 && keyCode <= 123) {
        // function keys f1-f12
        validKey = 'f' + (keyCode - 112 + 1);
      } else if (keyCode >= 48 && keyCode <= 57) {
        // top 0-9 keys
        validKey = String(keyCode - 48);
      } else if (keyCode >= 96 && keyCode <= 105) {
        // num pad 0-9
        validKey = String(keyCode - 96);
      } else {
        validKey = KEY_CODE[keyCode];
      }
    }
    return validKey;
  }

  /**
    * Calculates the normalized key for a KeyboardEvent.
    * @param {KeyboardEvent} keyEvent
    * @param {Boolean} [noSpecialChars] Set to true to limit keyEvent.key
    * transformation to alpha-numeric chars. This is useful with key
    * combinations like shift + 2, which on FF for MacOS produces
    * keyEvent.key = @
    * To get 2 returned, set noSpecialChars = true
    * To get @ returned, set noSpecialChars = false
   */
  function normalizedKeyForEvent(keyEvent, noSpecialChars) {
    // Fall back from .key, to .detail.key for artifical keyboard events,
    // and then to deprecated .keyIdentifier and .keyCode.
    if (keyEvent.key) {
      return transformKey(keyEvent.key, noSpecialChars);
    }
    if (keyEvent.detail && keyEvent.detail.key) {
      return transformKey(keyEvent.detail.key, noSpecialChars);
    }
    return transformKeyIdentifier(keyEvent.keyIdentifier) || transformKeyCode(keyEvent.keyCode) || '';
  }

  function keyComboMatchesEvent(keyCombo, event) {
    // For combos with modifiers we support only alpha-numeric keys
    var keyEvent = normalizedKeyForEvent(event, keyCombo.hasModifiers);
    return keyEvent === keyCombo.key && (!keyCombo.hasModifiers || !!event.shiftKey === !!keyCombo.shiftKey && !!event.ctrlKey === !!keyCombo.ctrlKey && !!event.altKey === !!keyCombo.altKey && !!event.metaKey === !!keyCombo.metaKey);
  }

  function parseKeyComboString(keyComboString) {
    if (keyComboString.length === 1) {
      return {
        combo: keyComboString,
        key: keyComboString,
        event: 'keydown'
      };
    }
    return keyComboString.split('+').reduce(function (parsedKeyCombo, keyComboPart) {
      var eventParts = keyComboPart.split(':');
      var keyName = eventParts[0];
      var event = eventParts[1];

      if (keyName in MODIFIER_KEYS) {
        parsedKeyCombo[MODIFIER_KEYS[keyName]] = true;
        parsedKeyCombo.hasModifiers = true;
      } else {
        parsedKeyCombo.key = keyName;
        parsedKeyCombo.event = event || 'keydown';
      }

      return parsedKeyCombo;
    }, {
      combo: keyComboString.split(':').shift()
    });
  }

  function parseEventString(eventString) {
    return eventString.trim().split(' ').map(function (keyComboString) {
      return parseKeyComboString(keyComboString);
    });
  }

  /**
   * `Polymer.IronA11yKeysBehavior` provides a normalized interface for processing
   * keyboard commands that pertain to [WAI-ARIA best practices](http://www.w3.org/TR/wai-aria-practices/#kbd_general_binding).
   * The element takes care of browser differences with respect to Keyboard events
   * and uses an expressive syntax to filter key presses.
   *
   * Use the `keyBindings` prototype property to express what combination of keys
   * will trigger the callback. A key binding has the format
   * `"KEY+MODIFIER:EVENT": "callback"` (`"KEY": "callback"` or
   * `"KEY:EVENT": "callback"` are valid as well). Some examples:
   *
   *      keyBindings: {
   *        'space': '_onKeydown', // same as 'space:keydown'
   *        'shift+tab': '_onKeydown',
   *        'enter:keypress': '_onKeypress',
   *        'esc:keyup': '_onKeyup'
   *      }
   *
   * The callback will receive with an event containing the following information in `event.detail`:
   *
   *      _onKeydown: function(event) {
   *        console.log(event.detail.combo); // KEY+MODIFIER, e.g. "shift+tab"
   *        console.log(event.detail.key); // KEY only, e.g. "tab"
   *        console.log(event.detail.event); // EVENT, e.g. "keydown"
   *        console.log(event.detail.keyboardEvent); // the original KeyboardEvent
   *      }
   *
   * Use the `keyEventTarget` attribute to set up event handlers on a specific
   * node.
   *
   * See the [demo source code](https://github.com/PolymerElements/iron-a11y-keys-behavior/blob/master/demo/x-key-aware.html)
   * for an example.
   *
   * @demo demo/index.html
   * @polymerBehavior
   */
  Polymer.IronA11yKeysBehavior = {
    properties: {
      /**
       * The EventTarget that will be firing relevant KeyboardEvents. Set it to
       * `null` to disable the listeners.
       * @type {?EventTarget}
       */
      keyEventTarget: {
        type: Object,
        value: function value() {
          return this;
        }
      },

      /**
       * If true, this property will cause the implementing element to
       * automatically stop propagation on any handled KeyboardEvents.
       */
      stopKeyboardEventPropagation: {
        type: Boolean,
        value: false
      },

      _boundKeyHandlers: {
        type: Array,
        value: function value() {
          return [];
        }
      },

      // We use this due to a limitation in IE10 where instances will have
      // own properties of everything on the "prototype".
      _imperativeKeyBindings: {
        type: Object,
        value: function value() {
          return {};
        }
      }
    },

    observers: ['_resetKeyEventListeners(keyEventTarget, _boundKeyHandlers)'],

    /**
     * To be used to express what combination of keys  will trigger the relative
     * callback. e.g. `keyBindings: { 'esc': '_onEscPressed'}`
     * @type {!Object}
     */
    keyBindings: {},

    registered: function registered() {
      this._prepKeyBindings();
    },

    attached: function attached() {
      this._listenKeyEventListeners();
    },

    detached: function detached() {
      this._unlistenKeyEventListeners();
    },

    /**
     * Can be used to imperatively add a key binding to the implementing
     * element. This is the imperative equivalent of declaring a keybinding
     * in the `keyBindings` prototype property.
     *
     * @param {string} eventString
     * @param {string} handlerName
     */
    addOwnKeyBinding: function addOwnKeyBinding(eventString, handlerName) {
      this._imperativeKeyBindings[eventString] = handlerName;
      this._prepKeyBindings();
      this._resetKeyEventListeners();
    },

    /**
     * When called, will remove all imperatively-added key bindings.
     */
    removeOwnKeyBindings: function removeOwnKeyBindings() {
      this._imperativeKeyBindings = {};
      this._prepKeyBindings();
      this._resetKeyEventListeners();
    },

    /**
     * Returns true if a keyboard event matches `eventString`.
     *
     * @param {KeyboardEvent} event
     * @param {string} eventString
     * @return {boolean}
     */
    keyboardEventMatchesKeys: function keyboardEventMatchesKeys(event, eventString) {
      var keyCombos = parseEventString(eventString);
      for (var i = 0; i < keyCombos.length; ++i) {
        if (keyComboMatchesEvent(keyCombos[i], event)) {
          return true;
        }
      }
      return false;
    },

    _collectKeyBindings: function _collectKeyBindings() {
      var keyBindings = this.behaviors.map(function (behavior) {
        return behavior.keyBindings;
      });

      if (keyBindings.indexOf(this.keyBindings) === -1) {
        keyBindings.push(this.keyBindings);
      }

      return keyBindings;
    },

    _prepKeyBindings: function _prepKeyBindings() {
      this._keyBindings = {};

      this._collectKeyBindings().forEach(function (keyBindings) {
        for (var eventString in keyBindings) {
          this._addKeyBinding(eventString, keyBindings[eventString]);
        }
      }, this);

      for (var eventString in this._imperativeKeyBindings) {
        this._addKeyBinding(eventString, this._imperativeKeyBindings[eventString]);
      }

      // Give precedence to combos with modifiers to be checked first.
      for (var eventName in this._keyBindings) {
        this._keyBindings[eventName].sort(function (kb1, kb2) {
          var b1 = kb1[0].hasModifiers;
          var b2 = kb2[0].hasModifiers;
          return b1 === b2 ? 0 : b1 ? -1 : 1;
        });
      }
    },

    _addKeyBinding: function _addKeyBinding(eventString, handlerName) {
      parseEventString(eventString).forEach(function (keyCombo) {
        this._keyBindings[keyCombo.event] = this._keyBindings[keyCombo.event] || [];

        this._keyBindings[keyCombo.event].push([keyCombo, handlerName]);
      }, this);
    },

    _resetKeyEventListeners: function _resetKeyEventListeners() {
      this._unlistenKeyEventListeners();

      if (this.isAttached) {
        this._listenKeyEventListeners();
      }
    },

    _listenKeyEventListeners: function _listenKeyEventListeners() {
      if (!this.keyEventTarget) {
        return;
      }
      Object.keys(this._keyBindings).forEach(function (eventName) {
        var keyBindings = this._keyBindings[eventName];
        var boundKeyHandler = this._onKeyBindingEvent.bind(this, keyBindings);

        this._boundKeyHandlers.push([this.keyEventTarget, eventName, boundKeyHandler]);

        this.keyEventTarget.addEventListener(eventName, boundKeyHandler);
      }, this);
    },

    _unlistenKeyEventListeners: function _unlistenKeyEventListeners() {
      var keyHandlerTuple;
      var keyEventTarget;
      var eventName;
      var boundKeyHandler;

      while (this._boundKeyHandlers.length) {
        // My kingdom for block-scope binding and destructuring assignment..
        keyHandlerTuple = this._boundKeyHandlers.pop();
        keyEventTarget = keyHandlerTuple[0];
        eventName = keyHandlerTuple[1];
        boundKeyHandler = keyHandlerTuple[2];

        keyEventTarget.removeEventListener(eventName, boundKeyHandler);
      }
    },

    _onKeyBindingEvent: function _onKeyBindingEvent(keyBindings, event) {
      if (this.stopKeyboardEventPropagation) {
        event.stopPropagation();
      }

      // if event has been already prevented, don't do anything
      if (event.defaultPrevented) {
        return;
      }

      for (var i = 0; i < keyBindings.length; i++) {
        var keyCombo = keyBindings[i][0];
        var handlerName = keyBindings[i][1];
        if (keyComboMatchesEvent(keyCombo, event)) {
          this._triggerKeyHandler(keyCombo, handlerName, event);
          // exit the loop if eventDefault was prevented
          if (event.defaultPrevented) {
            return;
          }
        }
      }
    },

    _triggerKeyHandler: function _triggerKeyHandler(keyCombo, handlerName, keyboardEvent) {
      var detail = Object.create(keyCombo);
      detail.keyboardEvent = keyboardEvent;
      var event = new CustomEvent(keyCombo.event, {
        detail: detail,
        cancelable: true
      });
      this[handlerName].call(this, event);
      if (event.defaultPrevented) {
        keyboardEvent.preventDefault();
      }
    }
  };
})();

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

/**
 * `IronResizableBehavior` is a behavior that can be used in Polymer elements to
 * coordinate the flow of resize events between "resizers" (elements that control the
 * size or hidden state of their children) and "resizables" (elements that need to be
 * notified when they are resized or un-hidden by their parents in order to take
 * action on their new measurements).
 *
 * Elements that perform measurement should add the `IronResizableBehavior` behavior to
 * their element definition and listen for the `iron-resize` event on themselves.
 * This event will be fired when they become showing after having been hidden,
 * when they are resized explicitly by another resizable, or when the window has been
 * resized.
 *
 * Note, the `iron-resize` event is non-bubbling.
 *
 * @polymerBehavior Polymer.IronResizableBehavior
 * @demo demo/index.html
 **/
Polymer.IronResizableBehavior = {
  properties: {
    /**
     * The closest ancestor element that implements `IronResizableBehavior`.
     */
    _parentResizable: {
      type: Object,
      observer: '_parentResizableChanged'
    },

    /**
     * True if this element is currently notifying its descendant elements of
     * resize.
     */
    _notifyingDescendant: {
      type: Boolean,
      value: false
    }
  },

  listeners: {
    'iron-request-resize-notifications': '_onIronRequestResizeNotifications'
  },

  created: function created() {
    // We don't really need property effects on these, and also we want them
    // to be created before the `_parentResizable` observer fires:
    this._interestedResizables = [];
    this._boundNotifyResize = this.notifyResize.bind(this);
  },

  attached: function attached() {
    this._requestResizeNotifications();
  },

  detached: function detached() {
    if (this._parentResizable) {
      this._parentResizable.stopResizeNotificationsFor(this);
    } else {
      window.removeEventListener('resize', this._boundNotifyResize);
    }

    this._parentResizable = null;
  },

  /**
   * Can be called to manually notify a resizable and its descendant
   * resizables of a resize change.
   */
  notifyResize: function notifyResize() {
    if (!this.isAttached) {
      return;
    }

    this._interestedResizables.forEach(function (resizable) {
      if (this.resizerShouldNotify(resizable)) {
        this._notifyDescendant(resizable);
      }
    }, this);

    this._fireResize();
  },

  /**
   * Used to assign the closest resizable ancestor to this resizable
   * if the ancestor detects a request for notifications.
   */
  assignParentResizable: function assignParentResizable(parentResizable) {
    this._parentResizable = parentResizable;
  },

  /**
   * Used to remove a resizable descendant from the list of descendants
   * that should be notified of a resize change.
   */
  stopResizeNotificationsFor: function stopResizeNotificationsFor(target) {
    var index = this._interestedResizables.indexOf(target);

    if (index > -1) {
      this._interestedResizables.splice(index, 1);
      this.unlisten(target, 'iron-resize', '_onDescendantIronResize');
    }
  },

  /**
   * This method can be overridden to filter nested elements that should or
   * should not be notified by the current element. Return true if an element
   * should be notified, or false if it should not be notified.
   *
   * @param {HTMLElement} element A candidate descendant element that
   * implements `IronResizableBehavior`.
   * @return {boolean} True if the `element` should be notified of resize.
   */
  resizerShouldNotify: function resizerShouldNotify(element) {
    return true;
  },

  _onDescendantIronResize: function _onDescendantIronResize(event) {
    if (this._notifyingDescendant) {
      event.stopPropagation();
      return;
    }

    // NOTE(cdata): In ShadowDOM, event retargeting makes echoing of the
    // otherwise non-bubbling event "just work." We do it manually here for
    // the case where Polymer is not using shadow roots for whatever reason:
    if (!Polymer.Settings.useShadow) {
      this._fireResize();
    }
  },

  _fireResize: function _fireResize() {
    this.fire('iron-resize', null, {
      node: this,
      bubbles: false
    });
  },

  _onIronRequestResizeNotifications: function _onIronRequestResizeNotifications(event) {
    var target = /** @type {!EventTarget} */Polymer.dom(event).rootTarget;
    if (target === this) {
      return;
    }

    if (this._interestedResizables.indexOf(target) === -1) {
      this._interestedResizables.push(target);
      this.listen(target, 'iron-resize', '_onDescendantIronResize');
    }

    target.assignParentResizable(this);
    this._notifyDescendant(target);

    event.stopPropagation();
  },

  _parentResizableChanged: function _parentResizableChanged(parentResizable) {
    if (parentResizable) {
      window.removeEventListener('resize', this._boundNotifyResize);
    }
  },

  _notifyDescendant: function _notifyDescendant(descendant) {
    // NOTE(cdata): In IE10, attached is fired on children first, so it's
    // important not to notify them if the parent is not attached yet (or
    // else they will get redundantly notified when the parent attaches).
    if (!this.isAttached) {
      return;
    }

    this._notifyingDescendant = true;
    descendant.notifyResize();
    this._notifyingDescendant = false;
  },

  _requestResizeNotifications: function _requestResizeNotifications() {
    if (!this.isAttached) return;

    // NOTE(valdrin) In CustomElements v1 with native HTMLImports, the order
    // of imports affects the order of `attached` callbacks (see webcomponents/custom-elements#15).
    // This might cause a child to notify parents too early (as the parent
    // still has to be upgraded), resulting in a parent not able to keep track
    // of the `_interestedResizables`. To solve this, we wait for the document
    // to be done loading before firing the event.
    if (document.readyState === 'loading') {
      var _requestResizeNotifications = this._requestResizeNotifications.bind(this);
      document.addEventListener('readystatechange', function readystatechanged() {
        document.removeEventListener('readystatechange', readystatechanged);
        _requestResizeNotifications();
      });
    } else {
      this.fire('iron-request-resize-notifications', null, {
        node: this,
        bubbles: true,
        cancelable: true
      });

      if (!this._parentResizable) {
        window.addEventListener('resize', this._boundNotifyResize);
        this.notifyResize();
      }
    }
  }
};

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

(function () {

  /**
   * @constructor
   * @param {{type: (string|null), key: (string|null), value: *}} options
   */
  function IronMeta(options) {
    this.type = options && options.type || 'default';
    this.key = options && options.key;
    if ('value' in options) {
      this.value = options.value;
    }
  }

  IronMeta.types = {};

  IronMeta.prototype = {
    get value() {
      var type = this.type;
      var key = this.key;

      if (type && key) {
        return IronMeta.types[type] && IronMeta.types[type][key];
      }
    },

    set value(value) {
      var type = this.type;
      var key = this.key;

      if (type && key) {
        type = IronMeta.types[type] = IronMeta.types[type] || {};
        if (value == null) {
          delete type[key];
        } else {
          type[key] = value;
        }
      }
    },

    get list() {
      var type = this.type;

      if (type) {
        return Object.keys(IronMeta.types[this.type]).map(function (key) {
          return metaDatas[this.type][key];
        }, this);
      }
    },

    byKey: function byKey(key) {
      this.key = key;
      return this.value;
    }
  };

  Polymer.IronMeta = IronMeta;

  var metaDatas = Polymer.IronMeta.types;

  Polymer({

    is: 'iron-meta',

    properties: {

      /**
       * The type of meta-data.  All meta-data of the same type is stored
       * together.
       * @type {string}
       */
      type: {
        type: String,
        value: 'default'
      },

      /**
       * The key used to store `value` under the `type` namespace.
       * @type {?string}
       */
      key: {
        type: String
      },

      /**
       * The meta-data to store or retrieve.
       * @type {*}
       */
      value: {
        type: String,
        notify: true
      },

      /**
       * If true, `value` is set to the iron-meta instance itself.
       */
      self: {
        type: Boolean,
        observer: '_selfChanged'
      },

      __meta: {
        type: Boolean,
        computed: '__computeMeta(type, key, value)'
      }
    },

    hostAttributes: {
      hidden: true
    },

    __computeMeta: function __computeMeta(type, key, value) {
      var meta = new Polymer.IronMeta({
        type: type,
        key: key
      });

      if (value !== undefined && value !== meta.value) {
        meta.value = value;
      } else if (this.value !== meta.value) {
        this.value = meta.value;
      }

      return meta;
    },

    get list() {
      return this.__meta && this.__meta.list;
    },

    _selfChanged: function _selfChanged(self) {
      if (self) {
        this.value = this;
      }
    },

    /**
     * Retrieves meta data value by key.
     *
     * @method byKey
     * @param {string} key The key of the meta-data to be returned.
     * @return {*}
     */
    byKey: function byKey(key) {
      return new Polymer.IronMeta({
        type: this.type,
        key: key
      }).value;
    }
  });
})();

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

__webpack_require__(1);

__webpack_require__(20);

__webpack_require__(3);

__webpack_require__(10);

__webpack_require__(21);

__webpack_require__(7);

__webpack_require__(41);

__webpack_require__(11);

(function () {
  'use strict';

  /**
   * Element class mixin that provides the core API for Polymer's meta-programming
   * features including template stamping, data-binding, attribute deserialization,
   * and property change observation.
   *
   * Subclassers may provide the following static getters to return metadata
   * used to configure Polymer's features for the class:
   *
   * - `static get is()`: When the template is provided via a `dom-module`,
   *   users should return the `dom-module` id from a static `is` getter.  If
   *   no template is needed or the template is provided directly via the
   *   `template` getter, there is no need to define `is` for the element.
   *
   * - `static get template()`: Users may provide the template directly (as
   *   opposed to via `dom-module`) by implementing a static `template` getter.
   *   The getter may return an `HTMLTemplateElement` or a string, which will
   *   automatically be parsed into a template.
   *
   * - `static get properties()`: Should return an object describing
   *   property-related metadata used by Polymer features (key: property name
   *   value: object containing property metadata). Valid keys in per-property
   *   metadata include:
   *   - `type` (String|Number|Object|Array|...): Used by
   *     `attributeChangedCallback` to determine how string-based attributes
   *     are deserialized to JavaScript property values.
   *   - `notify` (boolean): Causes a change in the property to fire a
   *     non-bubbling event called `<property>-changed`. Elements that have
   *     enabled two-way binding to the property use this event to observe changes.
   *   - `readOnly` (boolean): Creates a getter for the property, but no setter.
   *     To set a read-only property, use the private setter method
   *     `_setProperty(property, value)`.
   *   - `observer` (string): Observer method name that will be called when
   *     the property changes. The arguments of the method are
   *     `(value, previousValue)`.
   *   - `computed` (string): String describing method and dependent properties
   *     for computing the value of this property (e.g. `'computeFoo(bar, zot)'`).
   *     Computed properties are read-only by default and can only be changed
   *     via the return value of the computing method.
   *
   * - `static get observers()`: Array of strings describing multi-property
   *   observer methods and their dependent properties (e.g.
   *   `'observeABC(a, b, c)'`).
   *
   * The base class provides default implementations for the following standard
   * custom element lifecycle callbacks; users may override these, but should
   * call the super method to ensure
   * - `constructor`: Run when the element is created or upgraded
   * - `connectedCallback`: Run each time the element is connected to the
   *   document
   * - `disconnectedCallback`: Run each time the element is disconnected from
   *   the document
   * - `attributeChangedCallback`: Run each time an attribute in
   *   `observedAttributes` is set or removed (note: this element's default
   *   `observedAttributes` implementation will automatically return an array
   *   of dash-cased attributes based on `properties`)
   *
   * @mixinFunction
   * @polymer
   * @appliesMixin Polymer.PropertyEffects
   * @memberof Polymer
   * @property rootPath {string} Set to the value of `Polymer.rootPath`,
   *   which defaults to the main document path
   * @property importPath {string} Set to the value of the class's static
   *   `importPath` property, which defaults to the path of this element's
   *   `dom-module` (when `is` is used), but can be overridden for other
   *   import strategies.
   * @summary Element class mixin that provides the core API for Polymer's
   * meta-programming features.
   */

  Polymer.ElementMixin = Polymer.dedupingMixin(function (base) {

    /**
     * @constructor
     * @extends {base}
     * @implements {Polymer_PropertyEffects}
     */
    var polymerElementBase = Polymer.PropertyEffects(base);

    var caseMap = Polymer.CaseMap;

    /**
     * Returns the `properties` object specifically on `klass`. Use for:
     * (1) super chain mixes togther to make `propertiesForClass` which is
     * then used to make `observedAttributes`.
     * (2) properties effects and observers are created from it at `finalize` time.
     *
     * @param {HTMLElement} klass Element class
     * @return {Object} Object containing own properties for this class
     * @private
     */
    function ownPropertiesForClass(klass) {
      if (!klass.hasOwnProperty(JSCompiler_renameProperty('__ownProperties', klass))) {
        klass.__ownProperties = klass.hasOwnProperty(JSCompiler_renameProperty('properties', klass)) ?
        /** @type PolymerElementConstructor */klass.properties : {};
      }
      return klass.__ownProperties;
    }

    /**
     * Returns the `observers` array specifically on `klass`. Use for
     * setting up observers.
     *
     * @param {HTMLElement} klass Element class
     * @return {Array} Array containing own observers for this class
     * @private
     */
    function ownObserversForClass(klass) {
      if (!klass.hasOwnProperty(JSCompiler_renameProperty('__ownObservers', klass))) {
        klass.__ownObservers = klass.hasOwnProperty(JSCompiler_renameProperty('observers', klass)) ?
        /** @type PolymerElementConstructor */klass.observers : [];
      }
      return klass.__ownObservers;
    }

    /**
     * Mixes `props` into `flattenedProps` but upgrades shorthand type
     * syntax to { type: Type}.
     *
     * @param {Object} flattenedProps Bag to collect flattened properties into
     * @param {Object} props Bag of properties to add to `flattenedProps`
     * @return {Object} The input `flattenedProps` bag
     * @private
     */
    function flattenProperties(flattenedProps, props) {
      for (var p in props) {
        var o = props[p];
        if (typeof o == 'function') {
          o = { type: o };
        }
        flattenedProps[p] = o;
      }
      return flattenedProps;
    }

    /**
     * Returns a flattened list of properties mixed together from the chain of all
     * constructor's `config.properties`. This list is used to create
     * (1) observedAttributes,
     * (2) class property default values
     *
     * @param {PolymerElementConstructor} klass Element class
     * @return {PolymerElementProperties} Flattened properties for this class
     * @suppress {missingProperties} class.prototype is not a property for some reason?
     * @private
     */
    function propertiesForClass(klass) {
      if (!klass.hasOwnProperty(JSCompiler_renameProperty('__classProperties', klass))) {
        klass.__classProperties = flattenProperties({}, ownPropertiesForClass(klass));
        var superCtor = Object.getPrototypeOf(klass.prototype).constructor;
        if (superCtor.prototype instanceof PolymerElement) {
          klass.__classProperties = Object.assign(Object.create(propertiesForClass( /** @type PolymerElementConstructor */superCtor)), klass.__classProperties);
        }
      }
      return klass.__classProperties;
    }

    /**
     * Returns a list of properties with default values.
     * This list is created as an optimization since it is a subset of
     * the list returned from `propertiesForClass`.
     * This list is used in `_initializeProperties` to set property defaults.
     *
     * @param {PolymerElementConstructor} klass Element class
     * @return {PolymerElementProperties} Flattened properties for this class
     *   that have default values
     * @private
     */
    function propertyDefaultsForClass(klass) {
      if (!klass.hasOwnProperty(JSCompiler_renameProperty('__classPropertyDefaults', klass))) {
        klass.__classPropertyDefaults = null;
        var props = propertiesForClass(klass);
        for (var p in props) {
          var info = props[p];
          if ('value' in info) {
            klass.__classPropertyDefaults = klass.__classPropertyDefaults || {};
            klass.__classPropertyDefaults[p] = info;
          }
        }
      }
      return klass.__classPropertyDefaults;
    }

    /**
     * Returns true if a `klass` has finalized. Called in `ElementClass.finalize()`
     * @param {PolymerElementConstructor} klass Element class
     * @return {boolean} True if all metaprogramming for this class has been
     *   completed
     * @private
     */
    function hasClassFinalized(klass) {
      return klass.hasOwnProperty(JSCompiler_renameProperty('__finalized', klass));
    }

    /**
     * Called by `ElementClass.finalize()`. Ensures this `klass` and
     * *all superclasses* are finalized by traversing the prototype chain
     * and calling `klass.finalize()`.
     *
     * @param {PolymerElementConstructor} klass Element class
     * @private
     */
    function finalizeClassAndSuper(klass) {
      var proto = /** @type PolymerElementConstructor */klass.prototype;
      var superCtor = Object.getPrototypeOf(proto).constructor;
      if (superCtor.prototype instanceof PolymerElement) {
        superCtor.finalize();
      }
      finalizeClass(klass);
    }

    /**
     * Configures a `klass` based on a staic `klass.config` object and
     * a `template`. This includes creating accessors and effects
     * for properties in `config` and the `template` as well as preparing the
     * `template` for stamping.
     *
     * @param {PolymerElementConstructor} klass Element class
     * @private
     */
    function finalizeClass(klass) {
      klass.__finalized = true;
      var proto = /** @type PolymerElementConstructor */klass.prototype;
      if (klass.hasOwnProperty(JSCompiler_renameProperty('is', klass)) && klass.is) {
        Polymer.telemetry.register(proto);
      }
      var props = ownPropertiesForClass(klass);
      if (props) {
        finalizeProperties(proto, props);
      }
      var observers = ownObserversForClass(klass);
      if (observers) {
        finalizeObservers(proto, observers, props);
      }
      // note: create "working" template that is finalized at instance time
      var template = /** @type PolymerElementConstructor */klass.template;
      if (template) {
        if (typeof template === 'string') {
          var t = document.createElement('template');
          t.innerHTML = template;
          template = t;
        } else {
          template = template.cloneNode(true);
        }
        proto._template = template;
      }
    }

    /**
     * Configures a `proto` based on a `properties` object.
     * Leverages `PropertyEffects` to create property accessors and effects
     * supporting, observers, reflecting to attributes, change notification,
     * computed properties, and read only properties.
     * @param {PolymerElement} proto Element class prototype to add accessors
     *    and effects to
     * @param {Object} properties Flattened bag of property descriptors for
     *    this class
     * @private
     */
    function finalizeProperties(proto, properties) {
      for (var p in properties) {
        createPropertyFromConfig(proto, p, properties[p], properties);
      }
    }

    /**
     * Configures a `proto` based on a `observers` array.
     * Leverages `PropertyEffects` to create observers.
     * @param {PolymerElement} proto Element class prototype to add accessors
     *   and effects to
     * @param {Object} observers Flattened array of observer descriptors for
     *   this class
     * @param {Object} dynamicFns Object containing keys for any properties
     *   that are functions and should trigger the effect when the function
     *   reference is changed
     * @private
     */
    function finalizeObservers(proto, observers, dynamicFns) {
      for (var i = 0; i < observers.length; i++) {
        proto._createMethodObserver(observers[i], dynamicFns);
      }
    }

    /**
     * Creates effects for a property.
     *
     * Note, once a property has been set to
     * `readOnly`, `computed`, `reflectToAttribute`, or `notify`
     * these values may not be changed. For example, a subclass cannot
     * alter these settings. However, additional `observers` may be added
     * by subclasses.
     *
     * The info object should may contain property metadata as follows:
     *
     * * `type`: {function} type to which an attribute matching the property
     * is deserialized. Note the property is camel-cased from a dash-cased
     * attribute. For example, 'foo-bar' attribute is dersialized to a
     * property named 'fooBar'.
     *
     * * `readOnly`: {boolean} creates a readOnly property and
     * makes a private setter for the private of the form '_setFoo' for a
     * property 'foo',
     *
     * * `computed`: {string} creates a computed property. A computed property
     * also automatically is set to `readOnly: true`. The value is calculated
     * by running a method and arguments parsed from the given string. For
     * example 'compute(foo)' will compute a given property when the
     * 'foo' property changes by executing the 'compute' method. This method
     * must return the computed value.
     *
     * * `reflectToAttriute`: {boolean} If true, the property value is reflected
     * to an attribute of the same name. Note, the attribute is dash-cased
     * so a property named 'fooBar' is reflected as 'foo-bar'.
     *
     * * `notify`: {boolean} sends a non-bubbling notification event when
     * the property changes. For example, a property named 'foo' sends an
     * event named 'foo-changed' with `event.detail` set to the value of
     * the property.
     *
     * * observer: {string} name of a method that runs when the property
     * changes. The arguments of the method are (value, previousValue).
     *
     * Note: Users may want control over modifying property
     * effects via subclassing. For example, a user might want to make a
     * reflectToAttribute property not do so in a subclass. We've chosen to
     * disable this because it leads to additional complication.
     * For example, a readOnly effect generates a special setter. If a subclass
     * disables the effect, the setter would fail unexpectedly.
     * Based on feedback, we may want to try to make effects more malleable
     * and/or provide an advanced api for manipulating them.
     * Also consider adding warnings when an effect cannot be changed.
     *
     * @param {PolymerElement} proto Element class prototype to add accessors
     *   and effects to
     * @param {string} name Name of the property.
     * @param {Object} info Info object from which to create property effects.
     * Supported keys:
     * @param {Object} allProps Flattened map of all properties defined in this
     *   element (including inherited properties)
     * @private
     */
    function createPropertyFromConfig(proto, name, info, allProps) {
      // computed forces readOnly...
      if (info.computed) {
        info.readOnly = true;
      }
      // Note, since all computed properties are readOnly, this prevents
      // adding additional computed property effects (which leads to a confusing
      // setup where multiple triggers for setting a property)
      // While we do have `hasComputedEffect` this is set on the property's
      // dependencies rather than itself.
      if (info.computed && !proto._hasReadOnlyEffect(name)) {
        proto._createComputedProperty(name, info.computed, allProps);
      }
      if (info.readOnly && !proto._hasReadOnlyEffect(name)) {
        proto._createReadOnlyProperty(name, !info.computed);
      }
      if (info.reflectToAttribute && !proto._hasReflectEffect(name)) {
        proto._createReflectedProperty(name);
      }
      if (info.notify && !proto._hasNotifyEffect(name)) {
        proto._createNotifyingProperty(name);
      }
      // always add observer
      if (info.observer) {
        proto._createPropertyObserver(name, info.observer, allProps[info.observer]);
      }
    }

    /**
     * Configures an element `proto` to function with a given `template`.
     * The element name `is` and extends `ext` must be specified for ShadyCSS
     * style scoping.
     *
     * @param {PolymerElement} proto Element class prototype to add accessors
     *   and effects to
     * @param {!HTMLTemplateElement} template Template to process and bind
     * @param {string} baseURI URL against which to resolve urls in
     *   style element cssText
     * @param {string} is Tag name (or type extension name) for this element
     * @param {string=} ext For type extensions, the tag name that was extended
     * @private
     */
    function finalizeTemplate(proto, template, baseURI, is, ext) {
      // support `include="module-name"`
      var cssText = Polymer.StyleGather.cssFromTemplate(template, baseURI) + Polymer.StyleGather.cssFromModuleImports(is);
      if (cssText) {
        var style = document.createElement('style');
        style.textContent = cssText;
        template.content.insertBefore(style, template.content.firstChild);
      }
      if (window.ShadyCSS) {
        window.ShadyCSS.prepareTemplate(template, is, ext);
      }
      proto._bindTemplate(template);
    }

    /**
     * @polymer
     * @mixinClass
     * @unrestricted
     * @implements {Polymer_ElementMixin}
     */

    var PolymerElement = function (_polymerElementBase) {
      _inherits(PolymerElement, _polymerElementBase);

      function PolymerElement() {
        _classCallCheck(this, PolymerElement);

        return _possibleConstructorReturn(this, (PolymerElement.__proto__ || Object.getPrototypeOf(PolymerElement)).apply(this, arguments));
      }

      _createClass(PolymerElement, [{
        key: '_initializeProperties',


        /**
         * Overrides the default `Polymer.PropertyAccessors` to ensure class
         * metaprogramming related to property accessors and effects has
         * completed (calls `finalize`).
         *
         * It also initializes any property defaults provided via `value` in
         * `properties` metadata.
         *
         * @override
         * @suppress {invalidCasts}
         */
        value: function _initializeProperties() {
          Polymer.telemetry.instanceCount++;
          this.constructor.finalize();
          var importPath = this.constructor.importPath;
          // note: finalize template when we have access to `localName` to
          // avoid dependence on `is` for polyfilling styling.
          if (this._template && !this._template.__polymerFinalized) {
            this._template.__polymerFinalized = true;
            var baseURI = importPath ? Polymer.ResolveUrl.resolveUrl(importPath) : '';
            finalizeTemplate( /** @type {!PolymerElement} */this.__proto__, this._template, baseURI,
            /**@type {!HTMLElement}*/this.localName);
          }
          _get(PolymerElement.prototype.__proto__ || Object.getPrototypeOf(PolymerElement.prototype), '_initializeProperties', this).call(this);
          // set path defaults
          this.rootPath = Polymer.rootPath;
          this.importPath = importPath;
          // apply property defaults...
          var p$ = propertyDefaultsForClass(this.constructor);
          if (!p$) {
            return;
          }
          for (var p in p$) {
            var info = p$[p];
            // Don't set default value if there is already an own property, which
            // happens when a `properties` property with default but no effects had
            // a property set (e.g. bound) by its host before upgrade
            if (!this.hasOwnProperty(p)) {
              var value = typeof info.value == 'function' ? info.value.call(this) : info.value;
              // Set via `_setProperty` if there is an accessor, to enable
              // initializing readOnly property defaults
              if (this._hasAccessor(p)) {
                this._setPendingProperty(p, value, true);
              } else {
                this[p] = value;
              }
            }
          }
        }

        /**
         * Provides a default implementation of the standard Custom Elements
         * `connectedCallback`.
         *
         * The default implementation enables the property effects system and
         * flushes any pending properties, and updates shimmed CSS properties
         * when using the ShadyCSS scoping/custom properties polyfill.
         *
         * @suppress {invalidCasts}
         */

      }, {
        key: 'connectedCallback',
        value: function connectedCallback() {
          if (window.ShadyCSS && this._template) {
            window.ShadyCSS.styleElement( /** @type {!HTMLElement} */this);
          }
          this._enableProperties();
        }

        /**
         * Provides a default implementation of the standard Custom Elements
         * `disconnectedCallback`.
         */

      }, {
        key: 'disconnectedCallback',
        value: function disconnectedCallback() {}

        /**
         * Stamps the element template.
         *
         * @override
         */

      }, {
        key: 'ready',
        value: function ready() {
          if (this._template) {
            this.root = this._stampTemplate(this._template);
            this.$ = this.root.$;
          }
          _get(PolymerElement.prototype.__proto__ || Object.getPrototypeOf(PolymerElement.prototype), 'ready', this).call(this);
        }

        /**
         * Implements `PropertyEffects`'s `_readyClients` call. Attaches
         * element dom by calling `_attachDom` with the dom stamped from the
         * element's template via `_stampTemplate`. Note that this allows
         * client dom to be attached to the element prior to any observers
         * running.
         *
         * @override
         */

      }, {
        key: '_readyClients',
        value: function _readyClients() {
          if (this._template) {
            this.root = this._attachDom(this.root);
          }
          // The super._readyClients here sets the clients initialized flag.
          // We must wait to do this until after client dom is created/attached
          // so that this flag can be checked to prevent notifications fired
          // during this process from being handled before clients are ready.
          _get(PolymerElement.prototype.__proto__ || Object.getPrototypeOf(PolymerElement.prototype), '_readyClients', this).call(this);
        }

        /**
         * Attaches an element's stamped dom to itself. By default,
         * this method creates a `shadowRoot` and adds the dom to it.
         * However, this method may be overridden to allow an element
         * to put its dom in another location.
         *
         * @throws {Error}
         * @suppress {missingReturn}
         * @param {NodeList} dom to attach to the element.
         * @return {Node} node to which the dom has been attached.
         */

      }, {
        key: '_attachDom',
        value: function _attachDom(dom) {
          if (this.attachShadow) {
            if (dom) {
              if (!this.shadowRoot) {
                this.attachShadow({ mode: 'open' });
              }
              this.shadowRoot.appendChild(dom);
              return this.shadowRoot;
            }
            return null;
          } else {
            throw new Error('ShadowDOM not available. ' +
            // TODO(sorvell): move to compile-time conditional when supported
            'Polymer.Element can create dom as children instead of in ' + 'ShadowDOM by setting `this.root = this;\` before \`ready\`.');
          }
        }

        /**
         * Provides a default implementation of the standard Custom Elements
         * `attributeChangedCallback`.
         *
         * By default, attributes declared in `properties` metadata are
         * deserialized using their `type` information to properties of the
         * same name.  "Dash-cased" attributes are deserialzed to "camelCase"
         * properties.
         *
         * @param {string} name Name of attribute.
         * @param {?string} old Old value of attribute.
         * @param {?string} value Current value of attribute.
         * @override
         */

      }, {
        key: 'attributeChangedCallback',
        value: function attributeChangedCallback(name, old, value) {
          if (old !== value) {
            var property = caseMap.dashToCamelCase(name);
            var type = propertiesForClass(this.constructor)[property].type;
            if (!this._hasReadOnlyEffect(property)) {
              this._attributeToProperty(name, value, type);
            }
          }
        }

        /**
         * When using the ShadyCSS scoping and custom property shim, causes all
         * shimmed styles in this element (and its subtree) to be updated
         * based on current custom property values.
         *
         * The optional parameter overrides inline custom property styles with an
         * object of properties where the keys are CSS properties, and the values
         * are strings.
         *
         * Example: `this.updateStyles({'--color': 'blue'})`
         *
         * These properties are retained unless a value of `null` is set.
         *
         * @param {Object=} properties Bag of custom property key/values to
         *   apply to this element.
         * @suppress {invalidCasts}
         */

      }, {
        key: 'updateStyles',
        value: function updateStyles(properties) {
          if (window.ShadyCSS) {
            window.ShadyCSS.styleSubtree( /** @type {!HTMLElement} */this, properties);
          }
        }

        /**
         * Rewrites a given URL relative to a base URL. The base URL defaults to
         * the original location of the document containing the `dom-module` for
         * this element. This method will return the same URL before and after
         * bundling.
         *
         * @param {string} url URL to resolve.
         * @param {string=} base Optional base URL to resolve against, defaults
         * to the element's `importPath`
         * @return {string} Rewritten URL relative to base
         */

      }, {
        key: 'resolveUrl',
        value: function resolveUrl(url, base) {
          if (!base && this.importPath) {
            base = Polymer.ResolveUrl.resolveUrl(this.importPath);
          }
          return Polymer.ResolveUrl.resolveUrl(url, base);
        }

        /**
         * Overrides `PropertyAccessors` to add map of dynamic functions on
         * template info, for consumption by `PropertyEffects` template binding
         * code. This map determines which method templates should have accessors
         * created for them.
         *
         * @override
         * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
         */

      }], [{
        key: 'finalize',


        /**
         * Called automatically when the first element instance is created to
         * ensure that class finalization work has been completed.
         * May be called by users to eagerly perform class finalization work
         * prior to the creation of the first element instance.
         *
         * Class finalization work generally includes meta-programming such as
         * creating property accessors and any property effect metadata needed for
         * the features used.
         *
         * @public
         */
        value: function finalize() {
          if (!hasClassFinalized(this)) {
            finalizeClassAndSuper(this);
          }
        }

        /**
         * Returns the template that will be stamped into this element's shadow root.
         *
         * If a `static get is()` getter is defined, the default implementation
         * will return the first `<template>` in a `dom-module` whose `id`
         * matches this element's `is`.
         *
         * Users may override this getter to return an arbitrary template
         * (in which case the `is` getter is unnecessary). The template returned
         * may be either an `HTMLTemplateElement` or a string that will be
         * automatically parsed into a template.
         *
         * Note that when subclassing, if the super class overrode the default
         * implementation and the subclass would like to provide an alternate
         * template via a `dom-module`, it should override this getter and
         * return `Polymer.DomModule.import(this.is, 'template')`.
         *
         * If a subclass would like to modify the super class template, it should
         * clone it rather than modify it in place.  If the getter does expensive
         * work such as cloning/modifying a template, it should memoize the
         * template for maximum performance:
         *
         *   let memoizedTemplate;
         *   class MySubClass extends MySuperClass {
         *     static get template() {
         *       if (!memoizedTemplate) {
         *         memoizedTemplate = super.template.cloneNode(true);
         *         let subContent = document.createElement('div');
         *         subContent.textContent = 'This came from MySubClass';
         *         memoizedTemplate.content.appendChild(subContent);
         *       }
         *       return memoizedTemplate;
         *     }
         *   }
         *
         * @return {HTMLTemplateElement|string} Template to be stamped
         */

      }, {
        key: '_parseTemplateContent',
        value: function _parseTemplateContent(template, templateInfo, nodeInfo) {
          templateInfo.dynamicFns = templateInfo.dynamicFns || propertiesForClass(this);
          return _get(PolymerElement.__proto__ || Object.getPrototypeOf(PolymerElement), '_parseTemplateContent', this).call(this, template, templateInfo, nodeInfo);
        }
      }, {
        key: 'observedAttributes',


        /**
         * Standard Custom Elements V1 API.  The default implementation returns
         * a list of dash-cased attributes based on a flattening of all properties
         * declared in `static get properties()` for this element and any
         * superclasses.
         *
         * @return {Array} Observed attribute list
         */
        get: function get() {
          if (!this.hasOwnProperty(JSCompiler_renameProperty('__observedAttributes', this))) {
            var list = [];
            var properties = propertiesForClass(this);
            for (var prop in properties) {
              list.push(Polymer.CaseMap.camelToDashCase(prop));
            }
            this.__observedAttributes = list;
          }
          return this.__observedAttributes;
        }
      }, {
        key: 'template',
        get: function get() {
          if (!this.hasOwnProperty(JSCompiler_renameProperty('_template', this))) {
            this._template = Polymer.DomModule && Polymer.DomModule.import(
            /** @type PolymerElementConstructor*/this.is, 'template') ||
            // note: implemented so a subclass can retrieve the super
            // template; call the super impl this way so that `this` points
            // to the superclass.
            Object.getPrototypeOf( /** @type PolymerElementConstructor*/this.prototype).constructor.template;
          }
          return this._template;
        }

        /**
         * Path matching the url from which the element was imported.
         * This path is used to resolve url's in template style cssText.
         * The `importPath` property is also set on element instances and can be
         * used to create bindings relative to the import path.
         * Defaults to the path matching the url containing a `dom-module` element
         * matching this element's static `is` property.
         * Note, this path should contain a trailing `/`.
         *
         * @return {string} The import path for this element class
         */

      }, {
        key: 'importPath',
        get: function get() {
          if (!this.hasOwnProperty(JSCompiler_renameProperty('_importPath', this))) {
            var module = Polymer.DomModule && Polymer.DomModule.import( /** @type PolymerElementConstructor */this.is);
            this._importPath = module ? module.assetpath : '' || Object.getPrototypeOf( /** @type PolymerElementConstructor*/this.prototype).constructor.importPath;
          }
          return this._importPath;
        }
      }]);

      return PolymerElement;
    }(polymerElementBase);

    return PolymerElement;
  });

  /**
   * Provides basic tracking of element definitions (registrations) and
   * instance counts.
   *
   * @namespace
   * @summary Provides basic tracking of element definitions (registrations) and
   * instance counts.
   */
  Polymer.telemetry = {
    /**
     * Total number of Polymer element instances created.
     * @type {number}
     */
    instanceCount: 0,
    /**
     * Array of Polymer element classes that have been finalized.
     * @type {Array<Polymer.Element>}
     */
    registrations: [],
    /**
     * @param {!PolymerElementConstructor} prototype Element prototype to log
     * @this {this}
     * @private
     */
    _regLog: function _regLog(prototype) {
      console.log('[' + prototype.is + ']: registered');
    },
    /**
     * Registers a class prototype for telemetry purposes.
     * @param {HTMLElement} prototype Element prototype to register
     * @this {this}
     * @protected
     */
    register: function register(prototype) {
      this.registrations.push(prototype);
      Polymer.log && this._regLog(prototype);
    },
    /**
     * Logs all elements registered with an `is` to the console.
     * @public
     * @this {this}
     */
    dumpRegistrations: function dumpRegistrations() {
      this.registrations.forEach(this._regLog);
    }
  };

  /**
   * When using the ShadyCSS scoping and custom property shim, causes all
   * shimmed `styles` (via `custom-style`) in the document (and its subtree)
   * to be updated based on current custom property values.
   *
   * The optional parameter overrides inline custom property styles with an
   * object of properties where the keys are CSS properties, and the values
   * are strings.
   *
   * Example: `Polymer.updateStyles({'--color': 'blue'})`
   *
   * These properties are retained unless a value of `null` is set.
   *
   * @param {Object=} props Bag of custom property key/values to
   *   apply to the document.
   */
  Polymer.updateStyles = function (props) {
    if (window.ShadyCSS) {
      window.ShadyCSS.styleDocument(props);
    }
  };
})();

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(1);

__webpack_require__(7);

/** @suppress {deprecated} */
(function () {
  'use strict';

  /**
   * Legacy settings.
   * @namespace
   * @memberof Polymer
   */

  var settings = Polymer.Settings || {};
  settings.useShadow = !window.ShadyDOM;
  settings.useNativeCSSProperties = Boolean(!window.ShadyCSS || window.ShadyCSS.nativeCss);
  settings.useNativeCustomElements = !window.customElements.polyfillWrapFlushCallback;

  /**
   * Sets the global, legacy settings.
   *
   * @deprecated
   * @memberof Polymer
   */
  Polymer.Settings = settings;

  /**
   * Globally settable property that is automatically assigned to
   * `Polymer.ElementMixin` instances, useful for binding in templates to
   * make URL's relative to an application's root.  Defaults to the main
   * document URL, but can be overridden by users.  It may be useful to set
   * `Polymer.rootPath` to provide a stable application mount path when
   * using client side routing.
   *
   * @memberof Polymer
   */
  var rootPath = Polymer.rootPath || Polymer.ResolveUrl.pathFromUrl(document.baseURI || window.location.href);

  Polymer.rootPath = rootPath;

  /**
   * Sets the global rootPath property used by `Polymer.ElementMixin` and
   * available via `Polymer.rootPath`.
   *
   * @memberof Polymer
   * @param {string} path The new root path
   */
  Polymer.setRootPath = function (path) {
    Polymer.rootPath = path;
  };
})();

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(7);

(function () {
  'use strict';

  var MODULE_STYLE_LINK_SELECTOR = 'link[rel=import][type~=css]';
  var INCLUDE_ATTR = 'include';

  function importModule(moduleId) {
    if (!Polymer.DomModule) {
      return null;
    }
    return Polymer.DomModule.import(moduleId);
  }

  /** @typedef {{assetpath: string}} */
  var templateWithAssetPath = void 0; // eslint-disable-line no-unused-vars

  /**
   * Module with utilities for collection CSS text from `<templates>`, external
   * stylesheets, and `dom-module`s.
   *
   * @namespace
   * @memberof Polymer
   * @summary Module with utilities for collection CSS text from various sources.
   */
  var StyleGather = {

    /**
     * Returns CSS text of styles in a space-separated list of `dom-module`s.
     *
     * @memberof Polymer.StyleGather
     * @param {string} moduleIds List of dom-module id's within which to
     * search for css.
     * @return {string} Concatenated CSS content from specified `dom-module`s
     * @this {StyleGather}
     */
    cssFromModules: function cssFromModules(moduleIds) {
      var modules = moduleIds.trim().split(' ');
      var cssText = '';
      for (var i = 0; i < modules.length; i++) {
        cssText += this.cssFromModule(modules[i]);
      }
      return cssText;
    },


    /**
     * Returns CSS text of styles in a given `dom-module`.  CSS in a `dom-module`
     * can come either from `<style>`s within the first `<template>`, or else
     * from one or more `<link rel="import" type="css">` links outside the
     * template.
     *
     * Any `<styles>` processed are removed from their original location.
     *
     * @memberof Polymer.StyleGather
     * @param {string} moduleId dom-module id to gather styles from
     * @return {string} Concatenated CSS content from specified `dom-module`
     * @this {StyleGather}
     */
    cssFromModule: function cssFromModule(moduleId) {
      var m = importModule(moduleId);
      if (m && m._cssText === undefined) {
        var cssText = '';
        // include css from the first template in the module
        var t = m.querySelector('template');
        if (t) {
          cssText += this.cssFromTemplate(t, /** @type {templateWithAssetPath }*/m.assetpath);
        }
        // module imports: <link rel="import" type="css">
        cssText += this.cssFromModuleImports(moduleId);
        m._cssText = cssText || null;
      }
      if (!m) {
        console.warn('Could not find style data in module named', moduleId);
      }
      return m && m._cssText || '';
    },


    /**
     * Returns CSS text of `<styles>` within a given template.
     *
     * Any `<styles>` processed are removed from their original location.
     *
     * @memberof Polymer.StyleGather
     * @param {HTMLTemplateElement} template Template to gather styles from
     * @param {string} baseURI Base URI to resolve the URL against
     * @return {string} Concatenated CSS content from specified template
     * @this {StyleGather}
     */
    cssFromTemplate: function cssFromTemplate(template, baseURI) {
      var cssText = '';
      // if element is a template, get content from its .content
      var e$ = template.content.querySelectorAll('style');
      for (var i = 0; i < e$.length; i++) {
        var e = e$[i];
        // support style sharing by allowing styles to "include"
        // other dom-modules that contain styling
        var include = e.getAttribute(INCLUDE_ATTR);
        if (include) {
          cssText += this.cssFromModules(include);
        }
        e.parentNode.removeChild(e);
        cssText += baseURI ? Polymer.ResolveUrl.resolveCss(e.textContent, baseURI) : e.textContent;
      }
      return cssText;
    },


    /**
     * Returns CSS text from stylsheets loaded via `<link rel="import" type="css">`
     * links within the specified `dom-module`.
     *
     * @memberof Polymer.StyleGather
     * @param {string} moduleId Id of `dom-module` to gather CSS from
     * @return {string} Concatenated CSS content from links in specified `dom-module`
     * @this {StyleGather}
     */
    cssFromModuleImports: function cssFromModuleImports(moduleId) {
      var cssText = '';
      var m = importModule(moduleId);
      if (!m) {
        return cssText;
      }
      var p$ = m.querySelectorAll(MODULE_STYLE_LINK_SELECTOR);
      for (var i = 0; i < p$.length; i++) {
        var p = p$[i];
        if (p.import) {
          var importDoc = p.import;
          // NOTE: polyfill affordance.
          // under the HTMLImports polyfill, there will be no 'body',
          // but the import pseudo-doc can be used directly.
          var container = importDoc.body ? importDoc.body : importDoc;
          cssText += Polymer.ResolveUrl.resolveCss(container.textContent, importDoc.baseURI);
        }
      }
      return cssText;
    }
  };

  Polymer.StyleGather = StyleGather;
})();

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

__webpack_require__(46);

__webpack_require__(19);

__webpack_require__(23);

__webpack_require__(3);

__webpack_require__(49);

__webpack_require__(50);

__webpack_require__(51);

__webpack_require__(52);

(function () {

  'use strict';

  var styleInterface = window.ShadyCSS;

  /**
   * Element class mixin that provides Polymer's "legacy" API intended to be
   * backward-compatible to the greatest extent possible with the API
   * found on the Polymer 1.x `Polymer.Base` prototype applied to all elements
   * defined using the `Polymer({...})` function.
   *
   * @mixinFunction
   * @polymer
   * @appliesMixin Polymer.ElementMixin
   * @appliesMixin Polymer.GestureEventListeners
   * @property isAttached {boolean} Set to `true` in this element's
   *   `connectedCallback` and `false` in `disconnectedCallback`
   * @memberof Polymer
   * @summary Element class mixin that provides Polymer's "legacy" API
   */
  Polymer.LegacyElementMixin = Polymer.dedupingMixin(function (base) {

    /**
     * @constructor
     * @extends {base}
     * @implements {Polymer_ElementMixin}
     * @implements {Polymer_GestureEventListeners}
     */
    var legacyElementBase = Polymer.GestureEventListeners(Polymer.ElementMixin(base));

    /**
     * Map of simple names to touch action names
     * @dict
     */
    var DIRECTION_MAP = {
      'x': 'pan-x',
      'y': 'pan-y',
      'none': 'none',
      'all': 'auto'
    };

    /**
     * @polymer
     * @mixinClass
     * @extends {legacyElementBase}
     * @implements {Polymer_LegacyElementMixin}
     * @unrestricted
     */

    var LegacyElement = function (_legacyElementBase) {
      _inherits(LegacyElement, _legacyElementBase);

      function LegacyElement() {
        _classCallCheck(this, LegacyElement);

        var _this = _possibleConstructorReturn(this, (LegacyElement.__proto__ || Object.getPrototypeOf(LegacyElement)).call(this));

        _this.root = _this;
        _this.created();
        return _this;
      }

      /**
       * Legacy callback called during the `constructor`, for overriding
       * by the user.
       */


      _createClass(LegacyElement, [{
        key: 'created',
        value: function created() {}

        /**
         * Provides an implementation of `connectedCallback`
         * which adds Polymer legacy API's `attached` method.
         * @override
         */

      }, {
        key: 'connectedCallback',
        value: function connectedCallback() {
          _get(LegacyElement.prototype.__proto__ || Object.getPrototypeOf(LegacyElement.prototype), 'connectedCallback', this).call(this);
          this.isAttached = true;
          this.attached();
        }

        /**
         * Legacy callback called during `connectedCallback`, for overriding
         * by the user.
         */

      }, {
        key: 'attached',
        value: function attached() {}

        /**
         * Provides an implementation of `disconnectedCallback`
         * which adds Polymer legacy API's `detached` method.
         * @override
         */

      }, {
        key: 'disconnectedCallback',
        value: function disconnectedCallback() {
          _get(LegacyElement.prototype.__proto__ || Object.getPrototypeOf(LegacyElement.prototype), 'disconnectedCallback', this).call(this);
          this.isAttached = false;
          this.detached();
        }

        /**
         * Legacy callback called during `disconnectedCallback`, for overriding
         * by the user.
         */

      }, {
        key: 'detached',
        value: function detached() {}

        /**
         * Provides an override implementation of `attributeChangedCallback`
         * which adds the Polymer legacy API's `attributeChanged` method.
         * @param {string} name Name of attribute.
         * @param {?string} old Old value of attribute.
         * @param {?string} value Current value of attribute.
         * @override
         */

      }, {
        key: 'attributeChangedCallback',
        value: function attributeChangedCallback(name, old, value) {
          if (old !== value) {
            _get(LegacyElement.prototype.__proto__ || Object.getPrototypeOf(LegacyElement.prototype), 'attributeChangedCallback', this).call(this, name, old, value);
            this.attributeChanged(name, old, value);
          }
        }

        /**
         * Legacy callback called during `attributeChangedChallback`, for overriding
         * by the user.
         * @param {string} name Name of attribute.
         * @param {?string} old Old value of attribute.
         * @param {?string} value Current value of attribute.
         */

      }, {
        key: 'attributeChanged',
        value: function attributeChanged(name, old, value) {} // eslint-disable-line no-unused-vars

        /**
         * Overrides the default `Polymer.PropertyEffects` implementation to
         * add support for class initialization via the `_registered` callback.
         * This is called only when the first instance of the element is created.
         *
         * @override
         */

      }, {
        key: '_initializeProperties',
        value: function _initializeProperties() {
          var proto = Object.getPrototypeOf(this);
          if (!proto.hasOwnProperty('__hasRegisterFinished')) {
            proto.__hasRegisterFinished = true;
            this._registered();
          }
          _get(LegacyElement.prototype.__proto__ || Object.getPrototypeOf(LegacyElement.prototype), '_initializeProperties', this).call(this);
        }

        /**
         * Called automatically when an element is initializing.
         * Users may override this method to perform class registration time
         * work. The implementation should ensure the work is performed
         * only once for the class.
         * @protected
         */

      }, {
        key: '_registered',
        value: function _registered() {}

        /**
         * Overrides the default `Polymer.PropertyEffects` implementation to
         * add support for installing `hostAttributes` and `listeners`.
         *
         * @override
         */

      }, {
        key: 'ready',
        value: function ready() {
          this._ensureAttributes();
          this._applyListeners();
          _get(LegacyElement.prototype.__proto__ || Object.getPrototypeOf(LegacyElement.prototype), 'ready', this).call(this);
        }

        /**
         * Ensures an element has required attributes. Called when the element
         * is being readied via `ready`. Users should override to set the
         * element's required attributes. The implementation should be sure
         * to check and not override existing attributes added by
         * the user of the element. Typically, setting attributes should be left
         * to the element user and not done here; reasonable exceptions include
         * setting aria roles and focusability.
         * @protected
         */

      }, {
        key: '_ensureAttributes',
        value: function _ensureAttributes() {}

        /**
         * Adds element event listeners. Called when the element
         * is being readied via `ready`. Users should override to
         * add any required element event listeners.
         * In performance critical elements, the work done here should be kept
         * to a minimum since it is done before the element is rendered. In
         * these elements, consider adding listeners asychronously so as not to
         * block render.
         * @protected
         */

      }, {
        key: '_applyListeners',
        value: function _applyListeners() {}

        /**
         * Converts a typed JavaScript value to a string.
         *
         * Note this method is provided as backward-compatible legacy API
         * only.  It is not directly called by any Polymer features. To customize
         * how properties are serialized to attributes for attribute bindings and
         * `reflectToAttribute: true` properties as well as this method, override
         * the `_serializeValue` method provided by `Polymer.PropertyAccessors`.
         *
         * @param {*} value Value to deserialize
         * @return {string | undefined} Serialized value
         */

      }, {
        key: 'serialize',
        value: function serialize(value) {
          return this._serializeValue(value);
        }

        /**
         * Converts a string to a typed JavaScript value.
         *
         * Note this method is provided as backward-compatible legacy API
         * only.  It is not directly called by any Polymer features.  To customize
         * how attributes are deserialized to properties for in
         * `attributeChangedCallback`, override `_deserializeValue` method
         * provided by `Polymer.PropertyAccessors`.
         *
         * @param {string} value String to deserialize
         * @param {*} type Type to deserialize the string to
         * @return {*} Returns the deserialized value in the `type` given.
         */

      }, {
        key: 'deserialize',
        value: function deserialize(value, type) {
          return this._deserializeValue(value, type);
        }

        /**
         * Serializes a property to its associated attribute.
         *
         * Note this method is provided as backward-compatible legacy API
         * only.  It is not directly called by any Polymer features.
         *
         * @param {string} property Property name to reflect.
         * @param {string=} attribute Attribute name to reflect.
         * @param {*=} value Property value to refect.
         */

      }, {
        key: 'reflectPropertyToAttribute',
        value: function reflectPropertyToAttribute(property, attribute, value) {
          this._propertyToAttribute(property, attribute, value);
        }

        /**
         * Sets a typed value to an HTML attribute on a node.
         *
         * Note this method is provided as backward-compatible legacy API
         * only.  It is not directly called by any Polymer features.
         *
         * @param {*} value Value to serialize.
         * @param {string} attribute Attribute name to serialize to.
         * @param {Element} node Element to set attribute to.
         */

      }, {
        key: 'serializeValueToAttribute',
        value: function serializeValueToAttribute(value, attribute, node) {
          this._valueToNodeAttribute( /** @type {Element} */node || this, value, attribute);
        }

        /**
         * Copies own properties (including accessor descriptors) from a source
         * object to a target object.
         *
         * @param {Object} prototype Target object to copy properties to.
         * @param {Object} api Source object to copy properties from.
         * @return {Object} prototype object that was passed as first argument.
         */

      }, {
        key: 'extend',
        value: function extend(prototype, api) {
          if (!(prototype && api)) {
            return prototype || api;
          }
          var n$ = Object.getOwnPropertyNames(api);
          for (var i = 0, n; i < n$.length && (n = n$[i]); i++) {
            var pd = Object.getOwnPropertyDescriptor(api, n);
            if (pd) {
              Object.defineProperty(prototype, n, pd);
            }
          }
          return prototype;
        }

        /**
         * Copies props from a source object to a target object.
         *
         * Note, this method uses a simple `for...in` strategy for enumerating
         * properties.  To ensure only `ownProperties` are copied from source
         * to target and that accessor implementations are copied, use `extend`.
         *
         * @param {Object} target Target object to copy properties to.
         * @param {Object} source Source object to copy properties from.
         * @return {Object} Target object that was passed as first argument.
         */

      }, {
        key: 'mixin',
        value: function mixin(target, source) {
          for (var i in source) {
            target[i] = source[i];
          }
          return target;
        }

        /**
         * Sets the prototype of an object.
         *
         * Note this method is provided as backward-compatible legacy API
         * only.  It is not directly called by any Polymer features.
         * @param {Object} object The object on which to set the prototype.
         * @param {Object} prototype The prototype that will be set on the given
         * `object`.
         * @return {Object} Returns the given `object` with its prototype set
         * to the given `prototype` object.
         */

      }, {
        key: 'chainObject',
        value: function chainObject(object, prototype) {
          if (object && prototype && object !== prototype) {
            object.__proto__ = prototype;
          }
          return object;
        }

        /* **** Begin Template **** */

        /**
         * Calls `importNode` on the `content` of the `template` specified and
         * returns a document fragment containing the imported content.
         *
         * @param {HTMLTemplateElement} template HTML template element to instance.
         * @return {DocumentFragment} Document fragment containing the imported
         *   template content.
        */

      }, {
        key: 'instanceTemplate',
        value: function instanceTemplate(template) {
          var content = this.constructor._contentForTemplate(template);
          var dom = /** @type {DocumentFragment} */
          document.importNode(content, true);
          return dom;
        }

        /* **** Begin Events **** */

        /**
         * Dispatches a custom event with an optional detail value.
         *
         * @param {string} type Name of event type.
         * @param {*=} detail Detail value containing event-specific
         *   payload.
         * @param {{ bubbles: (boolean|undefined), cancelable: (boolean|undefined), composed: (boolean|undefined) }=}
         *  options Object specifying options.  These may include:
         *  `bubbles` (boolean, defaults to `true`),
         *  `cancelable` (boolean, defaults to false), and
         *  `node` on which to fire the event (HTMLElement, defaults to `this`).
         * @return {Event} The new event that was fired.
         */

      }, {
        key: 'fire',
        value: function fire(type, detail, options) {
          options = options || {};
          detail = detail === null || detail === undefined ? {} : detail;
          var event = new Event(type, {
            bubbles: options.bubbles === undefined ? true : options.bubbles,
            cancelable: Boolean(options.cancelable),
            composed: options.composed === undefined ? true : options.composed
          });
          event.detail = detail;
          var node = options.node || this;
          node.dispatchEvent(event);
          return event;
        }

        /**
         * Convenience method to add an event listener on a given element,
         * late bound to a named method on this element.
         *
         * @param {Element} node Element to add event listener to.
         * @param {string} eventName Name of event to listen for.
         * @param {string} methodName Name of handler method on `this` to call.
         */

      }, {
        key: 'listen',
        value: function listen(node, eventName, methodName) {
          node = /** @type {Element} */node || this;
          var hbl = this.__boundListeners || (this.__boundListeners = new WeakMap());
          var bl = hbl.get(node);
          if (!bl) {
            bl = {};
            hbl.set(node, bl);
          }
          var key = eventName + methodName;
          if (!bl[key]) {
            bl[key] = this._addMethodEventListenerToNode(node, eventName, methodName, this);
          }
        }

        /**
         * Convenience method to remove an event listener from a given element,
         * late bound to a named method on this element.
         *
         * @param {Element} node Element to remove event listener from.
         * @param {string} eventName Name of event to stop listening to.
         * @param {string} methodName Name of handler method on `this` to not call
         anymore.
         */

      }, {
        key: 'unlisten',
        value: function unlisten(node, eventName, methodName) {
          node = /** @type {Element} */node || this;
          var bl = this.__boundListeners && this.__boundListeners.get(node);
          var key = eventName + methodName;
          var handler = bl && bl[key];
          if (handler) {
            this._removeEventListenerFromNode(node, eventName, handler);
            bl[key] = null;
          }
        }

        /**
         * Override scrolling behavior to all direction, one direction, or none.
         *
         * Valid scroll directions:
         *   - 'all': scroll in any direction
         *   - 'x': scroll only in the 'x' direction
         *   - 'y': scroll only in the 'y' direction
         *   - 'none': disable scrolling for this node
         *
         * @param {string=} direction Direction to allow scrolling
         * Defaults to `all`.
         * @param {Element=} node Element to apply scroll direction setting.
         * Defaults to `this`.
         */

      }, {
        key: 'setScrollDirection',
        value: function setScrollDirection(direction, node) {
          Polymer.Gestures.setTouchAction( /** @type {Element} */node || this, DIRECTION_MAP[direction] || 'auto');
        }
        /* **** End Events **** */

        /**
         * Convenience method to run `querySelector` on this local DOM scope.
         *
         * This function calls `Polymer.dom(this.root).querySelector(slctr)`.
         *
         * @param {string} slctr Selector to run on this local DOM scope
         * @return {Element} Element found by the selector, or null if not found.
         */

      }, {
        key: '$$',
        value: function $$(slctr) {
          return this.root.querySelector(slctr);
        }

        /**
         * Return the element whose local dom within which this element
         * is contained. This is a shorthand for
         * `this.getRootNode().host`.
         * @this {Element}
         */

      }, {
        key: 'distributeContent',


        /**
         * Force this element to distribute its children to its local dom.
         * This should not be necessary as of Polymer 2.0.2 and is provided only
         * for backwards compatibility.
         */
        value: function distributeContent() {
          if (window.ShadyDOM && this.shadowRoot) {
            ShadyDOM.flush();
          }
        }

        /**
         * Returns a list of nodes that are the effective childNodes. The effective
         * childNodes list is the same as the element's childNodes except that
         * any `<content>` elements are replaced with the list of nodes distributed
         * to the `<content>`, the result of its `getDistributedNodes` method.
         * @this {Element}
         * @return {Array<Node>} List of effctive child nodes.
         */

      }, {
        key: 'getEffectiveChildNodes',
        value: function getEffectiveChildNodes() {
          return (/** @type {Polymer.DomApi} */Polymer.dom(this).getEffectiveChildNodes()
          );
        }

        /**
         * Returns a list of nodes distributed within this element that match
         * `selector`. These can be dom children or elements distributed to
         * children that are insertion points.
         * @param {string} selector Selector to run.
         * @this {Element}
         * @return {Array<Node>} List of distributed elements that match selector.
         */

      }, {
        key: 'queryDistributedElements',
        value: function queryDistributedElements(selector) {
          return (/** @type {Polymer.DomApi} */Polymer.dom(this).queryDistributedElements(selector)
          );
        }

        /**
         * Returns a list of elements that are the effective children. The effective
         * children list is the same as the element's children except that
         * any `<content>` elements are replaced with the list of elements
         * distributed to the `<content>`.
         *
         * @return {Array<Node>} List of effctive children.
         */

      }, {
        key: 'getEffectiveChildren',
        value: function getEffectiveChildren() {
          var list = this.getEffectiveChildNodes();
          return list.filter(function ( /** @type {Node} */n) {
            return n.nodeType === Node.ELEMENT_NODE;
          });
        }

        /**
         * Returns a string of text content that is the concatenation of the
         * text content's of the element's effective childNodes (the elements
         * returned by <a href="#getEffectiveChildNodes>getEffectiveChildNodes</a>.
         *
         * @return {string} List of effctive children.
         */

      }, {
        key: 'getEffectiveTextContent',
        value: function getEffectiveTextContent() {
          var cn = this.getEffectiveChildNodes();
          var tc = [];
          for (var i = 0, c; c = cn[i]; i++) {
            if (c.nodeType !== Node.COMMENT_NODE) {
              tc.push(c.textContent);
            }
          }
          return tc.join('');
        }

        /**
         * Returns the first effective childNode within this element that
         * match `selector`. These can be dom child nodes or elements distributed
         * to children that are insertion points.
         * @param {string} selector Selector to run.
         * @return {Object<Node>} First effective child node that matches selector.
         */

      }, {
        key: 'queryEffectiveChildren',
        value: function queryEffectiveChildren(selector) {
          var e$ = this.queryDistributedElements(selector);
          return e$ && e$[0];
        }

        /**
         * Returns a list of effective childNodes within this element that
         * match `selector`. These can be dom child nodes or elements distributed
         * to children that are insertion points.
         * @param {string} selector Selector to run.
         * @return {Array<Node>} List of effective child nodes that match selector.
         */

      }, {
        key: 'queryAllEffectiveChildren',
        value: function queryAllEffectiveChildren(selector) {
          return this.queryDistributedElements(selector);
        }

        /**
         * Returns a list of nodes distributed to this element's `<slot>`.
         *
         * If this element contains more than one `<slot>` in its local DOM,
         * an optional selector may be passed to choose the desired content.
         *
         * @param {string=} slctr CSS selector to choose the desired
         *   `<slot>`.  Defaults to `content`.
         * @return {Array<Node>} List of distributed nodes for the `<slot>`.
         */

      }, {
        key: 'getContentChildNodes',
        value: function getContentChildNodes(slctr) {
          var content = this.root.querySelector(slctr || 'slot');
          return content ? /** @type {Polymer.DomApi} */Polymer.dom(content).getDistributedNodes() : [];
        }

        /**
         * Returns a list of element children distributed to this element's
         * `<slot>`.
         *
         * If this element contains more than one `<slot>` in its
         * local DOM, an optional selector may be passed to choose the desired
         * content.  This method differs from `getContentChildNodes` in that only
         * elements are returned.
         *
         * @param {string=} slctr CSS selector to choose the desired
         *   `<content>`.  Defaults to `content`.
         * @return {Array<HTMLElement>} List of distributed nodes for the
         *   `<slot>`.
         * @suppress {invalidCasts}
         */

      }, {
        key: 'getContentChildren',
        value: function getContentChildren(slctr) {
          return (/** @type {Array<HTMLElement>} */this.getContentChildNodes(slctr).filter(function (n) {
              return n.nodeType === Node.ELEMENT_NODE;
            })
          );
        }

        /**
         * Checks whether an element is in this element's light DOM tree.
         *
         * @param {?Node} node The element to be checked.
         * @this {Element}
         * @return {boolean} true if node is in this element's light DOM tree.
         */

      }, {
        key: 'isLightDescendant',
        value: function isLightDescendant(node) {
          return this !== node && this.contains(node) && this.getRootNode() === node.getRootNode();
        }

        /**
         * Checks whether an element is in this element's local DOM tree.
         *
         * @param {Element=} node The element to be checked.
         * @return {boolean} true if node is in this element's local DOM tree.
         */

      }, {
        key: 'isLocalDescendant',
        value: function isLocalDescendant(node) {
          return this.root === node.getRootNode();
        }

        // NOTE: should now be handled by ShadyCss library.

      }, {
        key: 'scopeSubtree',
        value: function scopeSubtree(container, shouldObserve) {} // eslint-disable-line no-unused-vars


        /**
         * Returns the computed style value for the given property.
         * @param {string} property The css property name.
         * @return {string} Returns the computed css property value for the given
         * `property`.
         */

      }, {
        key: 'getComputedStyleValue',
        value: function getComputedStyleValue(property) {
          return styleInterface.getComputedStyleValue(this, property);
        }

        // debounce

        /**
         * Call `debounce` to collapse multiple requests for a named task into
         * one invocation which is made after the wait time has elapsed with
         * no new request.  If no wait time is given, the callback will be called
         * at microtask timing (guaranteed before paint).
         *
         *     debouncedClickAction(e) {
         *       // will not call `processClick` more than once per 100ms
         *       this.debounce('click', function() {
         *        this.processClick();
         *       } 100);
         *     }
         *
         * @param {string} jobName String to indentify the debounce job.
         * @param {function()} callback Function that is called (with `this`
         *   context) when the wait time elapses.
         * @param {number} wait Optional wait time in milliseconds (ms) after the
         *   last signal that must elapse before invoking `callback`
         * @return {Object} Returns a debouncer object on which exists the
         * following methods: `isActive()` returns true if the debouncer is
         * active; `cancel()` cancels the debouncer if it is active;
         * `flush()` immediately invokes the debounced callback if the debouncer
         * is active.
         */

      }, {
        key: 'debounce',
        value: function debounce(jobName, callback, wait) {
          this._debouncers = this._debouncers || {};
          return this._debouncers[jobName] = Polymer.Debouncer.debounce(this._debouncers[jobName], wait > 0 ? Polymer.Async.timeOut.after(wait) : Polymer.Async.microTask, callback.bind(this));
        }

        /**
         * Returns whether a named debouncer is active.
         *
         * @param {string} jobName The name of the debouncer started with `debounce`
         * @return {boolean} Whether the debouncer is active (has not yet fired).
         */

      }, {
        key: 'isDebouncerActive',
        value: function isDebouncerActive(jobName) {
          this._debouncers = this._debouncers || {};
          var debouncer = this._debouncers[jobName];
          return !!(debouncer && debouncer.isActive());
        }

        /**
         * Immediately calls the debouncer `callback` and inactivates it.
         *
         * @param {string} jobName The name of the debouncer started with `debounce`
         */

      }, {
        key: 'flushDebouncer',
        value: function flushDebouncer(jobName) {
          this._debouncers = this._debouncers || {};
          var debouncer = this._debouncers[jobName];
          if (debouncer) {
            debouncer.flush();
          }
        }

        /**
         * Cancels an active debouncer.  The `callback` will not be called.
         *
         * @param {string} jobName The name of the debouncer started with `debounce`
         */

      }, {
        key: 'cancelDebouncer',
        value: function cancelDebouncer(jobName) {
          this._debouncers = this._debouncers || {};
          var debouncer = this._debouncers[jobName];
          if (debouncer) {
            debouncer.cancel();
          }
        }

        /**
         * Runs a callback function asyncronously.
         *
         * By default (if no waitTime is specified), async callbacks are run at
         * microtask timing, which will occur before paint.
         *
         * @param {Function} callback The callback function to run, bound to `this`.
         * @param {number=} waitTime Time to wait before calling the
         *   `callback`.  If unspecified or 0, the callback will be run at microtask
         *   timing (before paint).
         * @return {number} Handle that may be used to cancel the async job.
         */

      }, {
        key: 'async',
        value: function async(callback, waitTime) {
          return waitTime > 0 ? Polymer.Async.timeOut.run(callback.bind(this), waitTime) : ~Polymer.Async.microTask.run(callback.bind(this));
        }

        /**
         * Cancels an async operation started with `async`.
         *
         * @param {number} handle Handle returned from original `async` call to
         *   cancel.
         */

      }, {
        key: 'cancelAsync',
        value: function cancelAsync(handle) {
          handle < 0 ? Polymer.Async.microTask.cancel(~handle) : Polymer.Async.timeOut.cancel(handle);
        }

        // other

        /**
         * Convenience method for creating an element and configuring it.
         *
         * @param {string} tag HTML element tag to create.
         * @param {Object} props Object of properties to configure on the
         *    instance.
         * @return {Element} Newly created and configured element.
         */

      }, {
        key: 'create',
        value: function create(tag, props) {
          var elt = document.createElement(tag);
          if (props) {
            if (elt.setProperties) {
              elt.setProperties(props);
            } else {
              for (var n in props) {
                elt[n] = props[n];
              }
            }
          }
          return elt;
        }

        /**
         * Convenience method for importing an HTML document imperatively.
         *
         * This method creates a new `<link rel="import">` element with
         * the provided URL and appends it to the document to start loading.
         * In the `onload` callback, the `import` property of the `link`
         * element will contain the imported document contents.
         *
         * @param {string} href URL to document to load.
         * @param {Function} onload Callback to notify when an import successfully
         *   loaded.
         * @param {Function} onerror Callback to notify when an import
         *   unsuccessfully loaded.
         * @param {boolean} optAsync True if the import should be loaded `async`.
         *   Defaults to `false`.
         * @return {HTMLLinkElement} The link element for the URL to be loaded.
         */

      }, {
        key: 'importHref',
        value: function importHref(href, onload, onerror, optAsync) {
          // eslint-disable-line no-unused-vars
          var loadFn = onload ? onload.bind(this) : null;
          var errorFn = onerror ? onerror.bind(this) : null;
          return Polymer.importHref(href, loadFn, errorFn, optAsync);
        }

        /**
         * Polyfill for Element.prototype.matches, which is sometimes still
         * prefixed.
         *
         * @param {string} selector Selector to test.
         * @param {Element=} node Element to test the selector against.
         * @return {boolean} Whether the element matches the selector.
         */

      }, {
        key: 'elementMatches',
        value: function elementMatches(selector, node) {
          return Polymer.dom.matchesSelector( /** @type {!Element} */node || this, selector);
        }

        /**
         * Toggles an HTML attribute on or off.
         *
         * @param {string} name HTML attribute name
         * @param {boolean=} bool Boolean to force the attribute on or off.
         *    When unspecified, the state of the attribute will be reversed.
         * @param {Element=} node Node to target.  Defaults to `this`.
         */

      }, {
        key: 'toggleAttribute',
        value: function toggleAttribute(name, bool, node) {
          node = /** @type {Element} */node || this;
          if (arguments.length == 1) {
            bool = !node.hasAttribute(name);
          }
          if (bool) {
            node.setAttribute(name, '');
          } else {
            node.removeAttribute(name);
          }
        }

        /**
         * Toggles a CSS class on or off.
         *
         * @param {string} name CSS class name
         * @param {boolean=} bool Boolean to force the class on or off.
         *    When unspecified, the state of the class will be reversed.
         * @param {Element=} node Node to target.  Defaults to `this`.
         */

      }, {
        key: 'toggleClass',
        value: function toggleClass(name, bool, node) {
          node = /** @type {Element} */node || this;
          if (arguments.length == 1) {
            bool = !node.classList.contains(name);
          }
          if (bool) {
            node.classList.add(name);
          } else {
            node.classList.remove(name);
          }
        }

        /**
         * Cross-platform helper for setting an element's CSS `transform` property.
         *
         * @param {string} transformText Transform setting.
         * @param {Element=} node Element to apply the transform to.
         * Defaults to `this`
         */

      }, {
        key: 'transform',
        value: function transform(transformText, node) {
          node = /** @type {Element} */node || this;
          node.style.webkitTransform = transformText;
          node.style.transform = transformText;
        }

        /**
         * Cross-platform helper for setting an element's CSS `translate3d`
         * property.
         *
         * @param {number} x X offset.
         * @param {number} y Y offset.
         * @param {number} z Z offset.
         * @param {Element=} node Element to apply the transform to.
         * Defaults to `this`.
         */

      }, {
        key: 'translate3d',
        value: function translate3d(x, y, z, node) {
          node = /** @type {Element} */node || this;
          this.transform('translate3d(' + x + ',' + y + ',' + z + ')', node);
        }

        /**
         * Removes an item from an array, if it exists.
         *
         * If the array is specified by path, a change notification is
         * generated, so that observers, data bindings and computed
         * properties watching that path can update.
         *
         * If the array is passed directly, **no change
         * notification is generated**.
         *
         * @param {string | !Array<number|string>} arrayOrPath Path to array from which to remove the item
         *   (or the array itself).
         * @param {*} item Item to remove.
         * @return {Array} Array containing item removed.
         */

      }, {
        key: 'arrayDelete',
        value: function arrayDelete(arrayOrPath, item) {
          var index = void 0;
          if (Array.isArray(arrayOrPath)) {
            index = arrayOrPath.indexOf(item);
            if (index >= 0) {
              return arrayOrPath.splice(index, 1);
            }
          } else {
            var arr = Polymer.Path.get(this, arrayOrPath);
            index = arr.indexOf(item);
            if (index >= 0) {
              return this.splice(arrayOrPath, index, 1);
            }
          }
          return null;
        }

        // logging

        /**
         * Facades `console.log`/`warn`/`error` as override point.
         *
         * @param {string} level One of 'log', 'warn', 'error'
         * @param {Array} args Array of strings or objects to log
         */

      }, {
        key: '_logger',
        value: function _logger(level, args) {
          var _console;

          // accept ['foo', 'bar'] and [['foo', 'bar']]
          if (Array.isArray(args) && args.length === 1) {
            args = args[0];
          }
          switch (level) {
            case 'log':
            case 'warn':
            case 'error':
              (_console = console)[level].apply(_console, _toConsumableArray(args));
          }
        }

        /**
         * Facades `console.log` as an override point.
         *
         * @param {...*} args Array of strings or objects to log
         */

      }, {
        key: '_log',
        value: function _log() {
          for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          this._logger('log', args);
        }

        /**
         * Facades `console.warn` as an override point.
         *
         * @param {...*} args Array of strings or objects to log
         */

      }, {
        key: '_warn',
        value: function _warn() {
          for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }

          this._logger('warn', args);
        }

        /**
         * Facades `console.error` as an override point.
         *
         * @param {...*} args Array of strings or objects to log
         */

      }, {
        key: '_error',
        value: function _error() {
          for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
            args[_key3] = arguments[_key3];
          }

          this._logger('error', args);
        }

        /**
         * Formats a message using the element type an a method name.
         *
         * @param {string} methodName Method name to associate with message
         * @param {...*} args Array of strings or objects to log
         * @return {Array} Array with formatting information for `console`
         *   logging.
         */

      }, {
        key: '_logf',
        value: function _logf(methodName) {
          for (var _len4 = arguments.length, args = Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
            args[_key4 - 1] = arguments[_key4];
          }

          return ['[%s::%s]', this.is, methodName].concat(args);
        }
      }, {
        key: 'domHost',
        get: function get() {
          var root = this.getRootNode();
          return root instanceof DocumentFragment ? /** @type {ShadowRoot} */root.host : root;
        }
      }]);

      return LegacyElement;
    }(legacyElementBase);

    LegacyElement.prototype.is = '';

    return LegacyElement;
  });
})();

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

__webpack_require__(1);

__webpack_require__(3);

__webpack_require__(48);

(function () {

  'use strict';

  /**
   * @const {Polymer.Gestures}
   */

  var gestures = Polymer.Gestures;

  /**
   * Element class mixin that provides API for adding Polymer's cross-platform
   * gesture events to nodes.
   *
   * The API is designed to be compatible with override points implemented
   * in `Polymer.TemplateStamp` such that declarative event listeners in
   * templates will support gesture events when this mixin is applied along with
   * `Polymer.TemplateStamp`.
   *
   * @mixinFunction
   * @polymer
   * @memberof Polymer
   * @summary Element class mixin that provides API for adding Polymer's cross-platform
   * gesture events to nodes
   */
  Polymer.GestureEventListeners = Polymer.dedupingMixin(function (superClass) {

    /**
     * @polymer
     * @mixinClass
     * @implements {Polymer_GestureEventListeners}
     */
    var GestureEventListeners = function (_superClass) {
      _inherits(GestureEventListeners, _superClass);

      function GestureEventListeners() {
        _classCallCheck(this, GestureEventListeners);

        return _possibleConstructorReturn(this, (GestureEventListeners.__proto__ || Object.getPrototypeOf(GestureEventListeners)).apply(this, arguments));
      }

      _createClass(GestureEventListeners, [{
        key: '_addEventListenerToNode',
        value: function _addEventListenerToNode(node, eventName, handler) {
          if (!gestures.addListener(node, eventName, handler)) {
            _get(GestureEventListeners.prototype.__proto__ || Object.getPrototypeOf(GestureEventListeners.prototype), '_addEventListenerToNode', this).call(this, node, eventName, handler);
          }
        }
      }, {
        key: '_removeEventListenerFromNode',
        value: function _removeEventListenerFromNode(node, eventName, handler) {
          if (!gestures.removeListener(node, eventName, handler)) {
            _get(GestureEventListeners.prototype.__proto__ || Object.getPrototypeOf(GestureEventListeners.prototype), '_removeEventListenerFromNode', this).call(this, node, eventName, handler);
          }
        }
      }]);

      return GestureEventListeners;
    }(superClass);

    return GestureEventListeners;
  });
})();

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(1);

(function () {

  'use strict';

  function newSplice(index, removed, addedCount) {
    return {
      index: index,
      removed: removed,
      addedCount: addedCount
    };
  }

  var EDIT_LEAVE = 0;
  var EDIT_UPDATE = 1;
  var EDIT_ADD = 2;
  var EDIT_DELETE = 3;

  // Note: This function is *based* on the computation of the Levenshtein
  // "edit" distance. The one change is that "updates" are treated as two
  // edits - not one. With Array splices, an update is really a delete
  // followed by an add. By retaining this, we optimize for "keeping" the
  // maximum array items in the original array. For example:
  //
  //   'xxxx123' -> '123yyyy'
  //
  // With 1-edit updates, the shortest path would be just to update all seven
  // characters. With 2-edit updates, we delete 4, leave 3, and add 4. This
  // leaves the substring '123' intact.
  function calcEditDistances(current, currentStart, currentEnd, old, oldStart, oldEnd) {
    // "Deletion" columns
    var rowCount = oldEnd - oldStart + 1;
    var columnCount = currentEnd - currentStart + 1;
    var distances = new Array(rowCount);

    // "Addition" rows. Initialize null column.
    for (var i = 0; i < rowCount; i++) {
      distances[i] = new Array(columnCount);
      distances[i][0] = i;
    }

    // Initialize null row
    for (var j = 0; j < columnCount; j++) {
      distances[0][j] = j;
    }for (var _i = 1; _i < rowCount; _i++) {
      for (var _j = 1; _j < columnCount; _j++) {
        if (equals(current[currentStart + _j - 1], old[oldStart + _i - 1])) distances[_i][_j] = distances[_i - 1][_j - 1];else {
          var north = distances[_i - 1][_j] + 1;
          var west = distances[_i][_j - 1] + 1;
          distances[_i][_j] = north < west ? north : west;
        }
      }
    }

    return distances;
  }

  // This starts at the final weight, and walks "backward" by finding
  // the minimum previous weight recursively until the origin of the weight
  // matrix.
  function spliceOperationsFromEditDistances(distances) {
    var i = distances.length - 1;
    var j = distances[0].length - 1;
    var current = distances[i][j];
    var edits = [];
    while (i > 0 || j > 0) {
      if (i == 0) {
        edits.push(EDIT_ADD);
        j--;
        continue;
      }
      if (j == 0) {
        edits.push(EDIT_DELETE);
        i--;
        continue;
      }
      var northWest = distances[i - 1][j - 1];
      var west = distances[i - 1][j];
      var north = distances[i][j - 1];

      var min = void 0;
      if (west < north) min = west < northWest ? west : northWest;else min = north < northWest ? north : northWest;

      if (min == northWest) {
        if (northWest == current) {
          edits.push(EDIT_LEAVE);
        } else {
          edits.push(EDIT_UPDATE);
          current = northWest;
        }
        i--;
        j--;
      } else if (min == west) {
        edits.push(EDIT_DELETE);
        i--;
        current = west;
      } else {
        edits.push(EDIT_ADD);
        j--;
        current = north;
      }
    }

    edits.reverse();
    return edits;
  }

  /**
   * Splice Projection functions:
   *
   * A splice map is a representation of how a previous array of items
   * was transformed into a new array of items. Conceptually it is a list of
   * tuples of
   *
   *   <index, removed, addedCount>
   *
   * which are kept in ascending index order of. The tuple represents that at
   * the |index|, |removed| sequence of items were removed, and counting forward
   * from |index|, |addedCount| items were added.
   */

  /**
   * Lacking individual splice mutation information, the minimal set of
   * splices can be synthesized given the previous state and final state of an
   * array. The basic approach is to calculate the edit distance matrix and
   * choose the shortest path through it.
   *
   * Complexity: O(l * p)
   *   l: The length of the current array
   *   p: The length of the old array
   *
   * @param {Array} current The current "changed" array for which to
   * calculate splices.
   * @param {number} currentStart Starting index in the `current` array for
   * which splices are calculated.
   * @param {number} currentEnd Ending index in the `current` array for
   * which splices are calculated.
   * @param {Array} old The original "unchanged" array to compare `current`
   * against to determine splices.
   * @param {number} oldStart Starting index in the `old` array for
   * which splices are calculated.
   * @param {number} oldEnd Ending index in the `old` array for
   * which splices are calculated.
   * @return {Array} Returns an array of splice record objects. Each of these
   * contains: `index` the location where the splice occurred; `removed`
   * the array of removed items from this location; `addedCount` the number
   * of items added at this location.
   */
  function calcSplices(current, currentStart, currentEnd, old, oldStart, oldEnd) {
    var prefixCount = 0;
    var suffixCount = 0;
    var splice = void 0;

    var minLength = Math.min(currentEnd - currentStart, oldEnd - oldStart);
    if (currentStart == 0 && oldStart == 0) prefixCount = sharedPrefix(current, old, minLength);

    if (currentEnd == current.length && oldEnd == old.length) suffixCount = sharedSuffix(current, old, minLength - prefixCount);

    currentStart += prefixCount;
    oldStart += prefixCount;
    currentEnd -= suffixCount;
    oldEnd -= suffixCount;

    if (currentEnd - currentStart == 0 && oldEnd - oldStart == 0) return [];

    if (currentStart == currentEnd) {
      splice = newSplice(currentStart, [], 0);
      while (oldStart < oldEnd) {
        splice.removed.push(old[oldStart++]);
      }return [splice];
    } else if (oldStart == oldEnd) return [newSplice(currentStart, [], currentEnd - currentStart)];

    var ops = spliceOperationsFromEditDistances(calcEditDistances(current, currentStart, currentEnd, old, oldStart, oldEnd));

    splice = undefined;
    var splices = [];
    var index = currentStart;
    var oldIndex = oldStart;
    for (var i = 0; i < ops.length; i++) {
      switch (ops[i]) {
        case EDIT_LEAVE:
          if (splice) {
            splices.push(splice);
            splice = undefined;
          }

          index++;
          oldIndex++;
          break;
        case EDIT_UPDATE:
          if (!splice) splice = newSplice(index, [], 0);

          splice.addedCount++;
          index++;

          splice.removed.push(old[oldIndex]);
          oldIndex++;
          break;
        case EDIT_ADD:
          if (!splice) splice = newSplice(index, [], 0);

          splice.addedCount++;
          index++;
          break;
        case EDIT_DELETE:
          if (!splice) splice = newSplice(index, [], 0);

          splice.removed.push(old[oldIndex]);
          oldIndex++;
          break;
      }
    }

    if (splice) {
      splices.push(splice);
    }
    return splices;
  }

  function sharedPrefix(current, old, searchLength) {
    for (var i = 0; i < searchLength; i++) {
      if (!equals(current[i], old[i])) return i;
    }return searchLength;
  }

  function sharedSuffix(current, old, searchLength) {
    var index1 = current.length;
    var index2 = old.length;
    var count = 0;
    while (count < searchLength && equals(current[--index1], old[--index2])) {
      count++;
    }return count;
  }

  function calculateSplices(current, previous) {
    return calcSplices(current, 0, current.length, previous, 0, previous.length);
  }

  function equals(currentValue, previousValue) {
    return currentValue === previousValue;
  }

  /**
   * @namespace
   * @memberof Polymer
   * @summary Module that provides utilities for diffing arrays.
   */
  Polymer.ArraySplice = {
    /**
     * Returns an array of splice records indicating the minimum edits required
     * to transform the `previous` array into the `current` array.
     *
     * Splice records are ordered by index and contain the following fields:
     * - `index`: index where edit started
     * - `removed`: array of removed items from this index
     * - `addedCount`: number of items added at this index
     *
     * This function is based on the Levenshtein "minimum edit distance"
     * algorithm. Note that updates are treated as removal followed by addition.
     *
     * The worst-case time complexity of this algorithm is `O(l * p)`
     *   l: The length of the current array
     *   p: The length of the previous array
     *
     * However, the worst-case complexity is reduced by an `O(n)` optimization
     * to detect any shared prefix & suffix between the two arrays and only
     * perform the more expensive minimum edit distance calculation over the
     * non-shared portions of the arrays.
     *
     * @memberof Polymer.ArraySplice
     * @param {Array} current The "changed" array for which splices will be
     * calculated.
     * @param {Array} previous The "unchanged" original array to compare
     * `current` against to determine the splices.
     * @return {Array} Returns an array of splice record objects. Each of these
     * contains: `index` the location where the splice occurred; `removed`
     * the array of removed items from this location; `addedCount` the number
     * of items added at this location.
     */
    calculateSplices: calculateSplices
  };
})();

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(4);

/**
 * While scrolling down, fade in the rear background layer and fade out the front background
 * layer (opacity interpolated based on scroll position).
 */
Polymer.AppLayout.registerEffect('blend-background', {
  /** @this Polymer.AppLayout.ElementWithBackground */
  setUp: function setUp() {
    var fx = {};
    fx.backgroundFrontLayer = this._getDOMRef('backgroundFrontLayer');
    fx.backgroundRearLayer = this._getDOMRef('backgroundRearLayer');
    fx.backgroundFrontLayer.style.willChange = 'opacity';
    fx.backgroundFrontLayer.style.transform = 'translateZ(0)';
    fx.backgroundRearLayer.style.willChange = 'opacity';
    fx.backgroundRearLayer.style.transform = 'translateZ(0)';
    fx.backgroundRearLayer.style.opacity = 0;
    this._fxBlendBackground = fx;
  },
  /** @this Polymer.AppLayout.ElementWithBackground */
  run: function run(p, y) {
    var fx = this._fxBlendBackground;
    fx.backgroundFrontLayer.style.opacity = 1 - p;
    fx.backgroundRearLayer.style.opacity = p;
  },
  /** @this Polymer.AppLayout.ElementWithBackground */
  tearDown: function tearDown() {
    delete this._fxBlendBackground;
  }
});

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(4);

/**
 * Toggles the shadow property in app-header when content is scrolled to create a sense of depth
 * between the element and the content underneath.
 */
Polymer.AppLayout.registerEffect('waterfall', {
  /**
   *  @this Polymer.AppLayout.ElementWithBackground
   */
  run: function run() {
    this.shadow = this.isOnScreen() && this.isContentBelow();
  }
});

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(4);

(function () {
  function interpolate(progress, points, fn, ctx) {
    fn.apply(ctx, points.map(function (point) {
      return point[0] + (point[1] - point[0]) * progress;
    }));
  }

  /**
   * Transform the font size of a designated title element between two values based on the scroll
   * position.
   */
  Polymer.AppLayout.registerEffect('resize-title', {
    /** @this Polymer.AppLayout.ElementWithBackground */
    setUp: function setUp() {
      var title = this._getDOMRef('mainTitle');
      var condensedTitle = this._getDOMRef('condensedTitle');

      if (!condensedTitle) {
        console.warn('Scroll effect `resize-title`: undefined `condensed-title`');
        return false;
      }
      if (!title) {
        console.warn('Scroll effect `resize-title`: undefined `main-title`');
        return false;
      }

      condensedTitle.style.willChange = 'opacity';
      condensedTitle.style.webkitTransform = 'translateZ(0)';
      condensedTitle.style.transform = 'translateZ(0)';
      condensedTitle.style.webkitTransformOrigin = 'left top';
      condensedTitle.style.transformOrigin = 'left top';

      title.style.willChange = 'opacity';
      title.style.webkitTransformOrigin = 'left top';
      title.style.transformOrigin = 'left top';
      title.style.webkitTransform = 'translateZ(0)';
      title.style.transform = 'translateZ(0)';

      var titleClientRect = title.getBoundingClientRect();
      var condensedTitleClientRect = condensedTitle.getBoundingClientRect();
      var fx = {};

      fx.scale = parseInt(window.getComputedStyle(condensedTitle)['font-size'], 10) / parseInt(window.getComputedStyle(title)['font-size'], 10);
      fx.titleDX = titleClientRect.left - condensedTitleClientRect.left;
      fx.titleDY = titleClientRect.top - condensedTitleClientRect.top;
      fx.condensedTitle = condensedTitle;
      fx.title = title;

      this._fxResizeTitle = fx;
    },
    /** @this PolymerElement */
    run: function run(p, y) {
      var fx = this._fxResizeTitle;
      if (!this.condenses) {
        y = 0;
      }
      if (p >= 1) {
        fx.title.style.opacity = 0;
        fx.condensedTitle.style.opacity = 1;
      } else {
        fx.title.style.opacity = 1;
        fx.condensedTitle.style.opacity = 0;
      }
      interpolate(Math.min(1, p), [[1, fx.scale], [0, -fx.titleDX], [y, y - fx.titleDY]], function (scale, translateX, translateY) {
        this.transform('translate(' + translateX + 'px, ' + translateY + 'px) ' + 'scale3d(' + scale + ', ' + scale + ', 1)', fx.title);
      }, this);
    },
    /** @this Polymer.AppLayout.ElementWithBackground */
    tearDown: function tearDown() {
      delete this._fxResizeTitle;
    }
  });
})();

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(4);

/**
 * Vertically translate the background based on a factor of the scroll position.
 */
Polymer.AppLayout.registerEffect('parallax-background', {
  /**
   * @param {{scalar: string}} config
   * @this Polymer.AppLayout.ElementWithBackground
   */
  setUp: function setUp(config) {
    var fx = {};
    var scalar = parseFloat(config.scalar);
    fx.background = this._getDOMRef('background');
    fx.backgroundFrontLayer = this._getDOMRef('backgroundFrontLayer');
    fx.backgroundRearLayer = this._getDOMRef('backgroundRearLayer');
    fx.deltaBg = fx.backgroundFrontLayer.offsetHeight - fx.background.offsetHeight;
    if (fx.deltaBg === 0) {
      if (isNaN(scalar)) {
        scalar = 0.8;
      }
      fx.deltaBg = this._dHeight * scalar;
    } else {
      if (isNaN(scalar)) {
        scalar = 1;
      }
      fx.deltaBg = fx.deltaBg * scalar;
    }
    this._fxParallaxBackground = fx;
  },
  /** @this Polymer.AppLayout.ElementWithBackground */
  run: function run(p, y) {
    var fx = this._fxParallaxBackground;
    this.transform('translate3d(0px, ' + fx.deltaBg * Math.min(1, p) + 'px, 0px)', fx.backgroundFrontLayer);
    if (fx.backgroundRearLayer) {
      this.transform('translate3d(0px, ' + fx.deltaBg * Math.min(1, p) + 'px, 0px)', fx.backgroundRearLayer);
    }
  },
  /** @this Polymer.AppLayout.ElementWithBackground */
  tearDown: function tearDown() {
    delete this._fxParallaxBackground;
  }
});

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

__webpack_require__(81);

/**
 * @polymerBehavior Polymer.IronSelectableBehavior
 */
Polymer.IronSelectableBehavior = {

  /**
   * Fired when iron-selector is activated (selected or deselected).
   * It is fired before the selected items are changed.
   * Cancel the event to abort selection.
   *
   * @event iron-activate
   */

  /**
   * Fired when an item is selected
   *
   * @event iron-select
   */

  /**
   * Fired when an item is deselected
   *
   * @event iron-deselect
   */

  /**
   * Fired when the list of selectable items changes (e.g., items are
   * added or removed). The detail of the event is a mutation record that
   * describes what changed.
   *
   * @event iron-items-changed
   */

  properties: {

    /**
     * If you want to use an attribute value or property of an element for
     * `selected` instead of the index, set this to the name of the attribute
     * or property. Hyphenated values are converted to camel case when used to
     * look up the property of a selectable element. Camel cased values are
     * *not* converted to hyphenated values for attribute lookup. It's
     * recommended that you provide the hyphenated form of the name so that
     * selection works in both cases. (Use `attr-or-property-name` instead of
     * `attrOrPropertyName`.)
     */
    attrForSelected: {
      type: String,
      value: null
    },

    /**
     * Gets or sets the selected element. The default is to use the index of the item.
     * @type {string|number}
     */
    selected: {
      type: String,
      notify: true
    },

    /**
     * Returns the currently selected item.
     *
     * @type {?Object}
     */
    selectedItem: {
      type: Object,
      readOnly: true,
      notify: true
    },

    /**
     * The event that fires from items when they are selected. Selectable
     * will listen for this event from items and update the selection state.
     * Set to empty string to listen to no events.
     */
    activateEvent: {
      type: String,
      value: 'tap',
      observer: '_activateEventChanged'
    },

    /**
     * This is a CSS selector string.  If this is set, only items that match the CSS selector
     * are selectable.
     */
    selectable: String,

    /**
     * The class to set on elements when selected.
     */
    selectedClass: {
      type: String,
      value: 'iron-selected'
    },

    /**
     * The attribute to set on elements when selected.
     */
    selectedAttribute: {
      type: String,
      value: null
    },

    /**
     * Default fallback if the selection based on selected with `attrForSelected`
     * is not found.
     */
    fallbackSelection: {
      type: String,
      value: null
    },

    /**
     * The list of items from which a selection can be made.
     */
    items: {
      type: Array,
      readOnly: true,
      notify: true,
      value: function value() {
        return [];
      }
    },

    /**
     * The set of excluded elements where the key is the `localName`
     * of the element that will be ignored from the item list.
     *
     * @default {template: 1}
     */
    _excludedLocalNames: {
      type: Object,
      value: function value() {
        return {
          'template': 1,
          'dom-bind': 1,
          'dom-if': 1,
          'dom-repeat': 1
        };
      }
    }
  },

  observers: ['_updateAttrForSelected(attrForSelected)', '_updateSelected(selected)', '_checkFallback(fallbackSelection)'],

  created: function created() {
    this._bindFilterItem = this._filterItem.bind(this);
    this._selection = new Polymer.IronSelection(this._applySelection.bind(this));
  },

  attached: function attached() {
    this._observer = this._observeItems(this);
    this._addListener(this.activateEvent);
  },

  detached: function detached() {
    if (this._observer) {
      Polymer.dom(this).unobserveNodes(this._observer);
    }
    this._removeListener(this.activateEvent);
  },

  /**
   * Returns the index of the given item.
   *
   * @method indexOf
   * @param {Object} item
   * @returns Returns the index of the item
   */
  indexOf: function indexOf(item) {
    return this.items.indexOf(item);
  },

  /**
   * Selects the given value.
   *
   * @method select
   * @param {string|number} value the value to select.
   */
  select: function select(value) {
    this.selected = value;
  },

  /**
   * Selects the previous item.
   *
   * @method selectPrevious
   */
  selectPrevious: function selectPrevious() {
    var length = this.items.length;
    var index = (Number(this._valueToIndex(this.selected)) - 1 + length) % length;
    this.selected = this._indexToValue(index);
  },

  /**
   * Selects the next item.
   *
   * @method selectNext
   */
  selectNext: function selectNext() {
    var index = (Number(this._valueToIndex(this.selected)) + 1) % this.items.length;
    this.selected = this._indexToValue(index);
  },

  /**
   * Selects the item at the given index.
   *
   * @method selectIndex
   */
  selectIndex: function selectIndex(index) {
    this.select(this._indexToValue(index));
  },

  /**
   * Force a synchronous update of the `items` property.
   *
   * NOTE: Consider listening for the `iron-items-changed` event to respond to
   * updates to the set of selectable items after updates to the DOM list and
   * selection state have been made.
   *
   * WARNING: If you are using this method, you should probably consider an
   * alternate approach. Synchronously querying for items is potentially
   * slow for many use cases. The `items` property will update asynchronously
   * on its own to reflect selectable items in the DOM.
   */
  forceSynchronousItemUpdate: function forceSynchronousItemUpdate() {
    if (this._observer && typeof this._observer.flush === "function") {
      // NOTE(bicknellr): `Polymer.dom.flush` above is no longer sufficient to
      // trigger `observeNodes` callbacks. Polymer 2.x returns an object from
      // `observeNodes` with a `flush` that synchronously gives the callback
      // any pending MutationRecords (retrieved with `takeRecords`). Any case
      // where ShadyDOM flushes were expected to synchronously trigger item
      // updates will now require calling `forceSynchronousItemUpdate`.
      this._observer.flush();
    } else {
      this._updateItems();
    }
  },

  // UNUSED, FOR API COMPATIBILITY
  get _shouldUpdateSelection() {
    return this.selected != null;
  },

  _checkFallback: function _checkFallback() {
    this._updateSelected();
  },

  _addListener: function _addListener(eventName) {
    this.listen(this, eventName, '_activateHandler');
  },

  _removeListener: function _removeListener(eventName) {
    this.unlisten(this, eventName, '_activateHandler');
  },

  _activateEventChanged: function _activateEventChanged(eventName, old) {
    this._removeListener(old);
    this._addListener(eventName);
  },

  _updateItems: function _updateItems() {
    var nodes = Polymer.dom(this).queryDistributedElements(this.selectable || '*');
    nodes = Array.prototype.filter.call(nodes, this._bindFilterItem);
    this._setItems(nodes);
  },

  _updateAttrForSelected: function _updateAttrForSelected() {
    if (this.selectedItem) {
      this.selected = this._valueForItem(this.selectedItem);
    }
  },

  _updateSelected: function _updateSelected() {
    this._selectSelected(this.selected);
  },

  _selectSelected: function _selectSelected(selected) {
    if (!this.items) {
      return;
    }

    var item = this._valueToItem(this.selected);
    if (item) {
      this._selection.select(item);
    } else {
      this._selection.clear();
    }
    // Check for items, since this array is populated only when attached
    // Since Number(0) is falsy, explicitly check for undefined
    if (this.fallbackSelection && this.items.length && this._selection.get() === undefined) {
      this.selected = this.fallbackSelection;
    }
  },

  _filterItem: function _filterItem(node) {
    return !this._excludedLocalNames[node.localName];
  },

  _valueToItem: function _valueToItem(value) {
    return value == null ? null : this.items[this._valueToIndex(value)];
  },

  _valueToIndex: function _valueToIndex(value) {
    if (this.attrForSelected) {
      for (var i = 0, item; item = this.items[i]; i++) {
        if (this._valueForItem(item) == value) {
          return i;
        }
      }
    } else {
      return Number(value);
    }
  },

  _indexToValue: function _indexToValue(index) {
    if (this.attrForSelected) {
      var item = this.items[index];
      if (item) {
        return this._valueForItem(item);
      }
    } else {
      return index;
    }
  },

  _valueForItem: function _valueForItem(item) {
    if (!item) {
      return null;
    }

    var propValue = item[Polymer.CaseMap.dashToCamelCase(this.attrForSelected)];
    return propValue != undefined ? propValue : item.getAttribute(this.attrForSelected);
  },

  _applySelection: function _applySelection(item, isSelected) {
    if (this.selectedClass) {
      this.toggleClass(this.selectedClass, isSelected, item);
    }
    if (this.selectedAttribute) {
      this.toggleAttribute(this.selectedAttribute, isSelected, item);
    }
    this._selectionChange();
    this.fire('iron-' + (isSelected ? 'select' : 'deselect'), { item: item });
  },

  _selectionChange: function _selectionChange() {
    this._setSelectedItem(this._selection.get());
  },

  // observe items change under the given node.
  _observeItems: function _observeItems(node) {
    return Polymer.dom(node).observeNodes(function (mutation) {
      this._updateItems();
      this._updateSelected();

      // Let other interested parties know about the change so that
      // we don't have to recreate mutation observers everywhere.
      this.fire('iron-items-changed', mutation, {
        bubbles: false,
        cancelable: false
      });
    });
  },

  _activateHandler: function _activateHandler(e) {
    var t = e.target;
    var items = this.items;
    while (t && t != this) {
      var i = items.indexOf(t);
      if (i >= 0) {
        var value = this._indexToValue(i);
        this._itemActivate(value, t);
        return;
      }
      t = t.parentNode;
    }
  },

  _itemActivate: function _itemActivate(value, item) {
    if (!this.fire('iron-activate', { selected: value, item: item }, { cancelable: true }).defaultPrevented) {
      this.select(value);
    }
  }

};

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

__webpack_require__(38);

var RegisterHtmlTemplate = __webpack_require__(2);

RegisterHtmlTemplate.toBody("<custom-style> <style is=custom-style>html{--primary-text-color:var(--light-theme-text-color);--primary-background-color:var(--light-theme-background-color);--secondary-text-color:var(--light-theme-secondary-color);--disabled-text-color:var(--light-theme-disabled-color);--divider-color:var(--light-theme-divider-color);--error-color:var(--paper-deep-orange-a700);--primary-color:var(--paper-indigo-500);--light-primary-color:var(--paper-indigo-100);--dark-primary-color:var(--paper-indigo-700);--accent-color:var(--paper-pink-a200);--light-accent-color:var(--paper-pink-a100);--dark-accent-color:var(--paper-pink-a400);--light-theme-background-color:#ffffff;--light-theme-base-color:#000000;--light-theme-text-color:var(--paper-grey-900);--light-theme-secondary-color:#737373;--light-theme-disabled-color:#9b9b9b;--light-theme-divider-color:#dbdbdb;--dark-theme-background-color:var(--paper-grey-900);--dark-theme-base-color:#ffffff;--dark-theme-text-color:#ffffff;--dark-theme-secondary-color:#bcbcbc;--dark-theme-disabled-color:#646464;--dark-theme-divider-color:#3c3c3c;--text-primary-color:var(--dark-theme-text-color);--default-primary-color:var(--primary-color)}</style> </custom-style>");

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

__webpack_require__(18);

__webpack_require__(5);

var RegisterHtmlTemplate = __webpack_require__(2);

RegisterHtmlTemplate.register("<dom-module id=iron-icon> <template> <style>:host{@apply --layout-inline;@apply --layout-center-center;position:relative;vertical-align:middle;fill:var(--iron-icon-fill-color,currentcolor);stroke:var(--iron-icon-stroke-color,none);width:var(--iron-icon-width,24px);height:var(--iron-icon-height,24px);@apply --iron-icon;}:host([hidden]){display:none}</style> </template> </dom-module>");

Polymer({

  is: 'iron-icon',

  properties: {

    /**
     * The name of the icon to use. The name should be of the form:
     * `iconset_name:icon_name`.
     */
    icon: {
      type: String
    },

    /**
     * The name of the theme to used, if one is specified by the
     * iconset.
     */
    theme: {
      type: String
    },

    /**
     * If using iron-icon without an iconset, you can set the src to be
     * the URL of an individual icon image file. Note that this will take
     * precedence over a given icon attribute.
     */
    src: {
      type: String
    },

    /**
     * @type {!Polymer.IronMeta}
     */
    _meta: {
      value: Polymer.Base.create('iron-meta', { type: 'iconset' })
    }

  },

  observers: ['_updateIcon(_meta, isAttached)', '_updateIcon(theme, isAttached)', '_srcChanged(src, isAttached)', '_iconChanged(icon, isAttached)'],

  _DEFAULT_ICONSET: 'icons',

  _iconChanged: function _iconChanged(icon) {
    var parts = (icon || '').split(':');
    this._iconName = parts.pop();
    this._iconsetName = parts.pop() || this._DEFAULT_ICONSET;
    this._updateIcon();
  },

  _srcChanged: function _srcChanged(src) {
    this._updateIcon();
  },

  _usesIconset: function _usesIconset() {
    return this.icon || !this.src;
  },

  /** @suppress {visibility} */
  _updateIcon: function _updateIcon() {
    if (this._usesIconset()) {
      if (this._img && this._img.parentNode) {
        Polymer.dom(this.root).removeChild(this._img);
      }
      if (this._iconName === "") {
        if (this._iconset) {
          this._iconset.removeIcon(this);
        }
      } else if (this._iconsetName && this._meta) {
        this._iconset = /** @type {?Polymer.Iconset} */this._meta.byKey(this._iconsetName);
        if (this._iconset) {
          this._iconset.applyIcon(this, this._iconName, this.theme);
          this.unlisten(window, 'iron-iconset-added', '_updateIcon');
        } else {
          this.listen(window, 'iron-iconset-added', '_updateIcon');
        }
      }
    } else {
      if (this._iconset) {
        this._iconset.removeIcon(this);
      }
      if (!this._img) {
        this._img = document.createElement('img');
        this._img.style.width = '100%';
        this._img.style.height = '100%';
        this._img.draggable = false;
      }
      this._img.src = this.src;
      Polymer.dom(this.root).appendChild(this._img);
    }
  }

});

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

__webpack_require__(18);

/**
 * The `iron-iconset-svg` element allows users to define their own icon sets
 * that contain svg icons. The svg icon elements should be children of the
 * `iron-iconset-svg` element. Multiple icons should be given distinct id's.
 *
 * Using svg elements to create icons has a few advantages over traditional
 * bitmap graphics like jpg or png. Icons that use svg are vector based so
 * they are resolution independent and should look good on any device. They
 * are stylable via css. Icons can be themed, colorized, and even animated.
 *
 * Example:
 *
 *     <iron-iconset-svg name="my-svg-icons" size="24">
 *       <svg>
 *         <defs>
 *           <g id="shape">
 *             <rect x="12" y="0" width="12" height="24" />
 *             <circle cx="12" cy="12" r="12" />
 *           </g>
 *         </defs>
 *       </svg>
 *     </iron-iconset-svg>
 *
 * This will automatically register the icon set "my-svg-icons" to the iconset
 * database.  To use these icons from within another element, make a
 * `iron-iconset` element and call the `byId` method
 * to retrieve a given iconset. To apply a particular icon inside an
 * element use the `applyIcon` method. For example:
 *
 *     iconset.applyIcon(iconNode, 'car');
 *
 * @element iron-iconset-svg
 * @demo demo/index.html
 * @implements {Polymer.Iconset}
 */
Polymer({
  is: 'iron-iconset-svg',

  properties: {

    /**
     * The name of the iconset.
     */
    name: {
      type: String,
      observer: '_nameChanged'
    },

    /**
     * The size of an individual icon. Note that icons must be square.
     */
    size: {
      type: Number,
      value: 24
    },

    /**
     * Set to true to enable mirroring of icons where specified when they are
     * stamped. Icons that should be mirrored should be decorated with a
     * `mirror-in-rtl` attribute.
     *
     * NOTE: For performance reasons, direction will be resolved once per
     * document per iconset, so moving icons in and out of RTL subtrees will
     * not cause their mirrored state to change.
     */
    rtlMirroring: {
      type: Boolean,
      value: false
    },

    /**
     * Set to true to measure RTL based on the dir attribute on the body or
     * html elements (measured on document.body or document.documentElement as
     * available).
     */
    useGlobalRtlAttribute: {
      type: Boolean,
      value: false
    }
  },

  created: function created() {
    this._meta = new Polymer.IronMeta({ type: 'iconset', key: null, value: null });
  },

  attached: function attached() {
    this.style.display = 'none';
  },

  /**
   * Construct an array of all icon names in this iconset.
   *
   * @return {!Array} Array of icon names.
   */
  getIconNames: function getIconNames() {
    this._icons = this._createIconMap();
    return Object.keys(this._icons).map(function (n) {
      return this.name + ':' + n;
    }, this);
  },

  /**
   * Applies an icon to the given element.
   *
   * An svg icon is prepended to the element's shadowRoot if it exists,
   * otherwise to the element itself.
   *
   * If RTL mirroring is enabled, and the icon is marked to be mirrored in
   * RTL, the element will be tested (once and only once ever for each
   * iconset) to determine the direction of the subtree the element is in.
   * This direction will apply to all future icon applications, although only
   * icons marked to be mirrored will be affected.
   *
   * @method applyIcon
   * @param {Element} element Element to which the icon is applied.
   * @param {string} iconName Name of the icon to apply.
   * @return {?Element} The svg element which renders the icon.
   */
  applyIcon: function applyIcon(element, iconName) {
    // Remove old svg element
    this.removeIcon(element);
    // install new svg element
    var svg = this._cloneIcon(iconName, this.rtlMirroring && this._targetIsRTL(element));
    if (svg) {
      // insert svg element into shadow root, if it exists
      var pde = Polymer.dom(element.root || element);
      pde.insertBefore(svg, pde.childNodes[0]);
      return element._svgIcon = svg;
    }
    return null;
  },

  /**
   * Remove an icon from the given element by undoing the changes effected
   * by `applyIcon`.
   *
   * @param {Element} element The element from which the icon is removed.
   */
  removeIcon: function removeIcon(element) {
    // Remove old svg element
    if (element._svgIcon) {
      Polymer.dom(element.root || element).removeChild(element._svgIcon);
      element._svgIcon = null;
    }
  },

  /**
   * Measures and memoizes the direction of the element. Note that this
   * measurement is only done once and the result is memoized for future
   * invocations.
   */
  _targetIsRTL: function _targetIsRTL(target) {
    if (this.__targetIsRTL == null) {
      if (this.useGlobalRtlAttribute) {
        var globalElement = document.body && document.body.hasAttribute('dir') ? document.body : document.documentElement;

        this.__targetIsRTL = globalElement.getAttribute('dir') === 'rtl';
      } else {
        if (target && target.nodeType !== Node.ELEMENT_NODE) {
          target = target.host;
        }

        this.__targetIsRTL = target && window.getComputedStyle(target)['direction'] === 'rtl';
      }
    }

    return this.__targetIsRTL;
  },

  /**
   *
   * When name is changed, register iconset metadata
   *
   */
  _nameChanged: function _nameChanged() {
    this._meta.value = null;
    this._meta.key = this.name;
    this._meta.value = this;

    this.async(function () {
      this.fire('iron-iconset-added', this, { node: window });
    });
  },

  /**
   * Create a map of child SVG elements by id.
   *
   * @return {!Object} Map of id's to SVG elements.
   */
  _createIconMap: function _createIconMap() {
    // Objects chained to Object.prototype (`{}`) have members. Specifically,
    // on FF there is a `watch` method that confuses the icon map, so we
    // need to use a null-based object here.
    var icons = Object.create(null);
    Polymer.dom(this).querySelectorAll('[id]').forEach(function (icon) {
      icons[icon.id] = icon;
    });
    return icons;
  },

  /**
   * Produce installable clone of the SVG element matching `id` in this
   * iconset, or `undefined` if there is no matching element.
   *
   * @return {Element} Returns an installable clone of the SVG element
   * matching `id`.
   */
  _cloneIcon: function _cloneIcon(id, mirrorAllowed) {
    // create the icon map on-demand, since the iconset itself has no discrete
    // signal to know when it's children are fully parsed
    this._icons = this._icons || this._createIconMap();
    return this._prepareSvgClone(this._icons[id], this.size, mirrorAllowed);
  },

  /**
   * @param {Element} sourceSvg
   * @param {number} size
   * @param {Boolean} mirrorAllowed
   * @return {Element}
   */
  _prepareSvgClone: function _prepareSvgClone(sourceSvg, size, mirrorAllowed) {
    if (sourceSvg) {
      var content = sourceSvg.cloneNode(true),
          svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg'),
          viewBox = content.getAttribute('viewBox') || '0 0 ' + size + ' ' + size,
          cssText = 'pointer-events: none; display: block; width: 100%; height: 100%;';

      if (mirrorAllowed && content.hasAttribute('mirror-in-rtl')) {
        cssText += '-webkit-transform:scale(-1,1);transform:scale(-1,1);';
      }

      svg.setAttribute('viewBox', viewBox);
      svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');
      svg.setAttribute('focusable', 'false');
      // TODO(dfreedm): `pointer-events: none` works around https://crbug.com/370136
      // TODO(sjmiles): inline style may not be ideal, but avoids requiring a shadow-root
      svg.style.cssText = cssText;
      svg.appendChild(content).removeAttribute('id');
      return svg;
    }
    return null;
  }

});

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

__webpack_require__(31);

__webpack_require__(84);

__webpack_require__(30);

var RegisterHtmlTemplate = __webpack_require__(2);

RegisterHtmlTemplate.register("<dom-module id=paper-icon-button> <template strip-whitespace=\"\"> <style>:host{display:inline-block;position:relative;padding:8px;outline:0;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;z-index:0;line-height:1;width:40px;height:40px;-webkit-tap-highlight-color:transparent;-webkit-tap-highlight-color:transparent;box-sizing:border-box!important;@apply --paper-icon-button;}:host #ink{color:var(--paper-icon-button-ink-color,var(--primary-text-color));opacity:.6}:host([disabled]){color:var(--paper-icon-button-disabled-text,var(--disabled-text-color));pointer-events:none;cursor:auto;@apply --paper-icon-button-disabled;}:host([hidden]){display:none!important}:host(:hover){@apply --paper-icon-button-hover;}iron-icon{--iron-icon-width:100%;--iron-icon-height:100%}</style> <iron-icon id=icon src=[[src]] icon=[[icon]] alt$=[[alt]]></iron-icon> </template> </dom-module>");

Polymer({
  is: 'paper-icon-button',

  hostAttributes: {
    role: 'button',
    tabindex: '0'
  },

  behaviors: [Polymer.PaperInkyFocusBehavior],

  properties: {
    /**
     * The URL of an image for the icon. If the src property is specified,
     * the icon property should not be.
     */
    src: {
      type: String
    },

    /**
     * Specifies the icon name or index in the set of icons available in
     * the icon's icon set. If the icon property is specified,
     * the src property should not be.
     */
    icon: {
      type: String
    },

    /**
     * Specifies the alternate text for the button, for accessibility.
     */
    alt: {
      type: String,
      observer: "_altChanged"
    }
  },

  _altChanged: function _altChanged(newValue, oldValue) {
    var label = this.getAttribute('aria-label');

    // Don't stomp over a user-set aria-label.
    if (!label || oldValue == label) {
      this.setAttribute('aria-label', newValue);
    }
  }
});

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

/**
 * @demo demo/index.html
 * @polymerBehavior
 */
Polymer.IronControlState = {

  properties: {

    /**
     * If true, the element currently has focus.
     */
    focused: {
      type: Boolean,
      value: false,
      notify: true,
      readOnly: true,
      reflectToAttribute: true
    },

    /**
     * If true, the user cannot interact with this element.
     */
    disabled: {
      type: Boolean,
      value: false,
      notify: true,
      observer: '_disabledChanged',
      reflectToAttribute: true
    },

    _oldTabIndex: {
      type: Number
    },

    _boundFocusBlurHandler: {
      type: Function,
      value: function value() {
        return this._focusBlurHandler.bind(this);
      }
    },

    __handleEventRetargeting: {
      type: Boolean,
      value: function value() {
        return !this.shadowRoot && !Polymer.Element;
      }
    }
  },

  observers: ['_changedControlState(focused, disabled)'],

  ready: function ready() {
    this.addEventListener('focus', this._boundFocusBlurHandler, true);
    this.addEventListener('blur', this._boundFocusBlurHandler, true);
  },

  _focusBlurHandler: function _focusBlurHandler(event) {
    // In Polymer 2.0, the library takes care of retargeting events.
    if (Polymer.Element) {
      this._setFocused(event.type === 'focus');
      return;
    }

    // NOTE(cdata):  if we are in ShadowDOM land, `event.target` will
    // eventually become `this` due to retargeting; if we are not in
    // ShadowDOM land, `event.target` will eventually become `this` due
    // to the second conditional which fires a synthetic event (that is also
    // handled). In either case, we can disregard `event.path`.
    if (event.target === this) {
      this._setFocused(event.type === 'focus');
    } else if (this.__handleEventRetargeting) {
      var target = /** @type {Node} */Polymer.dom(event).localTarget;
      if (!this.isLightDescendant(target)) {
        this.fire(event.type, { sourceEvent: event }, {
          node: this,
          bubbles: event.bubbles,
          cancelable: event.cancelable
        });
      }
    }
  },

  _disabledChanged: function _disabledChanged(disabled, old) {
    this.setAttribute('aria-disabled', disabled ? 'true' : 'false');
    this.style.pointerEvents = disabled ? 'none' : '';
    if (disabled) {
      this._oldTabIndex = this.tabIndex;
      this._setFocused(false);
      this.tabIndex = -1;
      this.blur();
    } else if (this._oldTabIndex !== undefined) {
      this.tabIndex = this._oldTabIndex;
    }
  },

  _changedControlState: function _changedControlState() {
    // _controlStateChanged is abstract, follow-on behaviors may implement it
    if (this._controlStateChanged) {
      this._controlStateChanged();
    }
  }

};

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

__webpack_require__(16);

var RegisterHtmlTemplate = __webpack_require__(2);

RegisterHtmlTemplate.register("<dom-module id=paper-ripple> <template> <style>:host{display:block;position:absolute;border-radius:inherit;overflow:hidden;top:0;left:0;right:0;bottom:0;pointer-events:none}:host([animating]){-webkit-transform:translate(0,0);transform:translate3d(0,0,0)}#background,#waves,.wave,.wave-container{pointer-events:none;position:absolute;top:0;left:0;width:100%;height:100%}#background,.wave{opacity:0}#waves,.wave{overflow:hidden}.wave,.wave-container{border-radius:50%}:host(.circle) #background,:host(.circle) #waves{border-radius:50%}:host(.circle) .wave-container{overflow:hidden}</style> <div id=background></div> <div id=waves></div> </template> </dom-module>");

(function () {
  'use strict';

  var Utility = {
    distance: function distance(x1, y1, x2, y2) {
      var xDelta = x1 - x2;
      var yDelta = y1 - y2;

      return Math.sqrt(xDelta * xDelta + yDelta * yDelta);
    },

    now: window.performance && window.performance.now ? window.performance.now.bind(window.performance) : Date.now
  };

  /**
   * @param {HTMLElement} element
   * @constructor
   */
  function ElementMetrics(element) {
    this.element = element;
    this.width = this.boundingRect.width;
    this.height = this.boundingRect.height;

    this.size = Math.max(this.width, this.height);
  }

  ElementMetrics.prototype = {
    get boundingRect() {
      return this.element.getBoundingClientRect();
    },

    furthestCornerDistanceFrom: function furthestCornerDistanceFrom(x, y) {
      var topLeft = Utility.distance(x, y, 0, 0);
      var topRight = Utility.distance(x, y, this.width, 0);
      var bottomLeft = Utility.distance(x, y, 0, this.height);
      var bottomRight = Utility.distance(x, y, this.width, this.height);

      return Math.max(topLeft, topRight, bottomLeft, bottomRight);
    }
  };

  /**
   * @param {HTMLElement} element
   * @constructor
   */
  function Ripple(element) {
    this.element = element;
    this.color = window.getComputedStyle(element).color;

    this.wave = document.createElement('div');
    this.waveContainer = document.createElement('div');
    this.wave.style.backgroundColor = this.color;
    this.wave.classList.add('wave');
    this.waveContainer.classList.add('wave-container');
    Polymer.dom(this.waveContainer).appendChild(this.wave);

    this.resetInteractionState();
  }

  Ripple.MAX_RADIUS = 300;

  Ripple.prototype = {
    get recenters() {
      return this.element.recenters;
    },

    get center() {
      return this.element.center;
    },

    get mouseDownElapsed() {
      var elapsed;

      if (!this.mouseDownStart) {
        return 0;
      }

      elapsed = Utility.now() - this.mouseDownStart;

      if (this.mouseUpStart) {
        elapsed -= this.mouseUpElapsed;
      }

      return elapsed;
    },

    get mouseUpElapsed() {
      return this.mouseUpStart ? Utility.now() - this.mouseUpStart : 0;
    },

    get mouseDownElapsedSeconds() {
      return this.mouseDownElapsed / 1000;
    },

    get mouseUpElapsedSeconds() {
      return this.mouseUpElapsed / 1000;
    },

    get mouseInteractionSeconds() {
      return this.mouseDownElapsedSeconds + this.mouseUpElapsedSeconds;
    },

    get initialOpacity() {
      return this.element.initialOpacity;
    },

    get opacityDecayVelocity() {
      return this.element.opacityDecayVelocity;
    },

    get radius() {
      var width2 = this.containerMetrics.width * this.containerMetrics.width;
      var height2 = this.containerMetrics.height * this.containerMetrics.height;
      var waveRadius = Math.min(Math.sqrt(width2 + height2), Ripple.MAX_RADIUS) * 1.1 + 5;

      var duration = 1.1 - 0.2 * (waveRadius / Ripple.MAX_RADIUS);
      var timeNow = this.mouseInteractionSeconds / duration;
      var size = waveRadius * (1 - Math.pow(80, -timeNow));

      return Math.abs(size);
    },

    get opacity() {
      if (!this.mouseUpStart) {
        return this.initialOpacity;
      }

      return Math.max(0, this.initialOpacity - this.mouseUpElapsedSeconds * this.opacityDecayVelocity);
    },

    get outerOpacity() {
      // Linear increase in background opacity, capped at the opacity
      // of the wavefront (waveOpacity).
      var outerOpacity = this.mouseUpElapsedSeconds * 0.3;
      var waveOpacity = this.opacity;

      return Math.max(0, Math.min(outerOpacity, waveOpacity));
    },

    get isOpacityFullyDecayed() {
      return this.opacity < 0.01 && this.radius >= Math.min(this.maxRadius, Ripple.MAX_RADIUS);
    },

    get isRestingAtMaxRadius() {
      return this.opacity >= this.initialOpacity && this.radius >= Math.min(this.maxRadius, Ripple.MAX_RADIUS);
    },

    get isAnimationComplete() {
      return this.mouseUpStart ? this.isOpacityFullyDecayed : this.isRestingAtMaxRadius;
    },

    get translationFraction() {
      return Math.min(1, this.radius / this.containerMetrics.size * 2 / Math.sqrt(2));
    },

    get xNow() {
      if (this.xEnd) {
        return this.xStart + this.translationFraction * (this.xEnd - this.xStart);
      }

      return this.xStart;
    },

    get yNow() {
      if (this.yEnd) {
        return this.yStart + this.translationFraction * (this.yEnd - this.yStart);
      }

      return this.yStart;
    },

    get isMouseDown() {
      return this.mouseDownStart && !this.mouseUpStart;
    },

    resetInteractionState: function resetInteractionState() {
      this.maxRadius = 0;
      this.mouseDownStart = 0;
      this.mouseUpStart = 0;

      this.xStart = 0;
      this.yStart = 0;
      this.xEnd = 0;
      this.yEnd = 0;
      this.slideDistance = 0;

      this.containerMetrics = new ElementMetrics(this.element);
    },

    draw: function draw() {
      var scale;
      var translateString;
      var dx;
      var dy;

      this.wave.style.opacity = this.opacity;

      scale = this.radius / (this.containerMetrics.size / 2);
      dx = this.xNow - this.containerMetrics.width / 2;
      dy = this.yNow - this.containerMetrics.height / 2;

      // 2d transform for safari because of border-radius and overflow:hidden clipping bug.
      // https://bugs.webkit.org/show_bug.cgi?id=98538
      this.waveContainer.style.webkitTransform = 'translate(' + dx + 'px, ' + dy + 'px)';
      this.waveContainer.style.transform = 'translate3d(' + dx + 'px, ' + dy + 'px, 0)';
      this.wave.style.webkitTransform = 'scale(' + scale + ',' + scale + ')';
      this.wave.style.transform = 'scale3d(' + scale + ',' + scale + ',1)';
    },

    /** @param {Event=} event */
    downAction: function downAction(event) {
      var xCenter = this.containerMetrics.width / 2;
      var yCenter = this.containerMetrics.height / 2;

      this.resetInteractionState();
      this.mouseDownStart = Utility.now();

      if (this.center) {
        this.xStart = xCenter;
        this.yStart = yCenter;
        this.slideDistance = Utility.distance(this.xStart, this.yStart, this.xEnd, this.yEnd);
      } else {
        this.xStart = event ? event.detail.x - this.containerMetrics.boundingRect.left : this.containerMetrics.width / 2;
        this.yStart = event ? event.detail.y - this.containerMetrics.boundingRect.top : this.containerMetrics.height / 2;
      }

      if (this.recenters) {
        this.xEnd = xCenter;
        this.yEnd = yCenter;
        this.slideDistance = Utility.distance(this.xStart, this.yStart, this.xEnd, this.yEnd);
      }

      this.maxRadius = this.containerMetrics.furthestCornerDistanceFrom(this.xStart, this.yStart);

      this.waveContainer.style.top = (this.containerMetrics.height - this.containerMetrics.size) / 2 + 'px';
      this.waveContainer.style.left = (this.containerMetrics.width - this.containerMetrics.size) / 2 + 'px';

      this.waveContainer.style.width = this.containerMetrics.size + 'px';
      this.waveContainer.style.height = this.containerMetrics.size + 'px';
    },

    /** @param {Event=} event */
    upAction: function upAction(event) {
      if (!this.isMouseDown) {
        return;
      }

      this.mouseUpStart = Utility.now();
    },

    remove: function remove() {
      Polymer.dom(this.waveContainer.parentNode).removeChild(this.waveContainer);
    }
  };

  Polymer({
    is: 'paper-ripple',

    behaviors: [Polymer.IronA11yKeysBehavior],

    properties: {
      /**
       * The initial opacity set on the wave.
       *
       * @attribute initialOpacity
       * @type number
       * @default 0.25
       */
      initialOpacity: {
        type: Number,
        value: 0.25
      },

      /**
       * How fast (opacity per second) the wave fades out.
       *
       * @attribute opacityDecayVelocity
       * @type number
       * @default 0.8
       */
      opacityDecayVelocity: {
        type: Number,
        value: 0.8
      },

      /**
       * If true, ripples will exhibit a gravitational pull towards
       * the center of their container as they fade away.
       *
       * @attribute recenters
       * @type boolean
       * @default false
       */
      recenters: {
        type: Boolean,
        value: false
      },

      /**
       * If true, ripples will center inside its container
       *
       * @attribute recenters
       * @type boolean
       * @default false
       */
      center: {
        type: Boolean,
        value: false
      },

      /**
       * A list of the visual ripples.
       *
       * @attribute ripples
       * @type Array
       * @default []
       */
      ripples: {
        type: Array,
        value: function value() {
          return [];
        }
      },

      /**
       * True when there are visible ripples animating within the
       * element.
       */
      animating: {
        type: Boolean,
        readOnly: true,
        reflectToAttribute: true,
        value: false
      },

      /**
       * If true, the ripple will remain in the "down" state until `holdDown`
       * is set to false again.
       */
      holdDown: {
        type: Boolean,
        value: false,
        observer: '_holdDownChanged'
      },

      /**
       * If true, the ripple will not generate a ripple effect
       * via pointer interaction.
       * Calling ripple's imperative api like `simulatedRipple` will
       * still generate the ripple effect.
       */
      noink: {
        type: Boolean,
        value: false
      },

      _animating: {
        type: Boolean
      },

      _boundAnimate: {
        type: Function,
        value: function value() {
          return this.animate.bind(this);
        }
      }
    },

    get target() {
      return this.keyEventTarget;
    },

    keyBindings: {
      'enter:keydown': '_onEnterKeydown',
      'space:keydown': '_onSpaceKeydown',
      'space:keyup': '_onSpaceKeyup'
    },

    attached: function attached() {
      // Set up a11yKeysBehavior to listen to key events on the target,
      // so that space and enter activate the ripple even if the target doesn't
      // handle key events. The key handlers deal with `noink` themselves.
      if (this.parentNode.nodeType == 11) {
        // DOCUMENT_FRAGMENT_NODE
        this.keyEventTarget = Polymer.dom(this).getOwnerRoot().host;
      } else {
        this.keyEventTarget = this.parentNode;
      }
      var keyEventTarget = /** @type {!EventTarget} */this.keyEventTarget;
      this.listen(keyEventTarget, 'up', 'uiUpAction');
      this.listen(keyEventTarget, 'down', 'uiDownAction');
    },

    detached: function detached() {
      this.unlisten(this.keyEventTarget, 'up', 'uiUpAction');
      this.unlisten(this.keyEventTarget, 'down', 'uiDownAction');
      this.keyEventTarget = null;
    },

    get shouldKeepAnimating() {
      for (var index = 0; index < this.ripples.length; ++index) {
        if (!this.ripples[index].isAnimationComplete) {
          return true;
        }
      }

      return false;
    },

    simulatedRipple: function simulatedRipple() {
      this.downAction(null);

      // Please see polymer/polymer#1305
      this.async(function () {
        this.upAction();
      }, 1);
    },

    /**
     * Provokes a ripple down effect via a UI event,
     * respecting the `noink` property.
     * @param {Event=} event
     */
    uiDownAction: function uiDownAction(event) {
      if (!this.noink) {
        this.downAction(event);
      }
    },

    /**
     * Provokes a ripple down effect via a UI event,
     * *not* respecting the `noink` property.
     * @param {Event=} event
     */
    downAction: function downAction(event) {
      if (this.holdDown && this.ripples.length > 0) {
        return;
      }

      var ripple = this.addRipple();

      ripple.downAction(event);

      if (!this._animating) {
        this._animating = true;
        this.animate();
      }
    },

    /**
     * Provokes a ripple up effect via a UI event,
     * respecting the `noink` property.
     * @param {Event=} event
     */
    uiUpAction: function uiUpAction(event) {
      if (!this.noink) {
        this.upAction(event);
      }
    },

    /**
     * Provokes a ripple up effect via a UI event,
     * *not* respecting the `noink` property.
     * @param {Event=} event
     */
    upAction: function upAction(event) {
      if (this.holdDown) {
        return;
      }

      this.ripples.forEach(function (ripple) {
        ripple.upAction(event);
      });

      this._animating = true;
      this.animate();
    },

    onAnimationComplete: function onAnimationComplete() {
      this._animating = false;
      this.$.background.style.backgroundColor = null;
      this.fire('transitionend');
    },

    addRipple: function addRipple() {
      var ripple = new Ripple(this);

      Polymer.dom(this.$.waves).appendChild(ripple.waveContainer);
      this.$.background.style.backgroundColor = ripple.color;
      this.ripples.push(ripple);

      this._setAnimating(true);

      return ripple;
    },

    removeRipple: function removeRipple(ripple) {
      var rippleIndex = this.ripples.indexOf(ripple);

      if (rippleIndex < 0) {
        return;
      }

      this.ripples.splice(rippleIndex, 1);

      ripple.remove();

      if (!this.ripples.length) {
        this._setAnimating(false);
      }
    },

    /**
     * This conflicts with Element#antimate().
     * https://developer.mozilla.org/en-US/docs/Web/API/Element/animate
     * @suppress {checkTypes}
     */
    animate: function animate() {
      if (!this._animating) {
        return;
      }
      var index;
      var ripple;

      for (index = 0; index < this.ripples.length; ++index) {
        ripple = this.ripples[index];

        ripple.draw();

        this.$.background.style.opacity = ripple.outerOpacity;

        if (ripple.isOpacityFullyDecayed && !ripple.isRestingAtMaxRadius) {
          this.removeRipple(ripple);
        }
      }

      if (!this.shouldKeepAnimating && this.ripples.length === 0) {
        this.onAnimationComplete();
      } else {
        window.requestAnimationFrame(this._boundAnimate);
      }
    },

    _onEnterKeydown: function _onEnterKeydown() {
      this.uiDownAction();
      this.async(this.uiUpAction, 1);
    },

    _onSpaceKeydown: function _onSpaceKeydown() {
      this.uiDownAction();
    },

    _onSpaceKeyup: function _onSpaceKeyup() {
      this.uiUpAction();
    },

    // note: holdDown does not respect noink since it can be a focus based
    // effect.
    _holdDownChanged: function _holdDownChanged(newVal, oldVal) {
      if (oldVal === undefined) {
        return;
      }
      if (newVal) {
        this.downAction();
      } else {
        this.upAction();
      }
    }

    /**
    Fired when the animation finishes.
    This is useful if you want to wait until
    the ripple animation finishes to perform some action.
     @event transitionend
    @param {{node: Object}} detail Contains the animated node.
    */
  });
})();

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

/**
 * `Polymer.IronScrollTargetBehavior` allows an element to respond to scroll events from a
 * designated scroll target.
 *
 * Elements that consume this behavior can override the `_scrollHandler`
 * method to add logic on the scroll event.
 *
 * @demo demo/scrolling-region.html Scrolling Region
 * @demo demo/document.html Document Element
 * @polymerBehavior
 */
Polymer.IronScrollTargetBehavior = {

  properties: {

    /**
     * Specifies the element that will handle the scroll event
     * on the behalf of the current element. This is typically a reference to an element,
     * but there are a few more posibilities:
     *
     * ### Elements id
     *
     *```html
     * <div id="scrollable-element" style="overflow: auto;">
     *  <x-element scroll-target="scrollable-element">
     *    <!-- Content-->
     *  </x-element>
     * </div>
     *```
     * In this case, the `scrollTarget` will point to the outer div element.
     *
     * ### Document scrolling
     *
     * For document scrolling, you can use the reserved word `document`:
     *
     *```html
     * <x-element scroll-target="document">
     *   <!-- Content -->
     * </x-element>
     *```
     *
     * ### Elements reference
     *
     *```js
     * appHeader.scrollTarget = document.querySelector('#scrollable-element');
     *```
     *
     * @type {HTMLElement}
     * @default document
     */
    scrollTarget: {
      type: HTMLElement,
      value: function value() {
        return this._defaultScrollTarget;
      }
    }
  },

  observers: ['_scrollTargetChanged(scrollTarget, isAttached)'],

  /**
   * True if the event listener should be installed.
   */
  _shouldHaveListener: true,

  _scrollTargetChanged: function _scrollTargetChanged(scrollTarget, isAttached) {
    var eventTarget;

    if (this._oldScrollTarget) {
      this._toggleScrollListener(false, this._oldScrollTarget);
      this._oldScrollTarget = null;
    }
    if (!isAttached) {
      return;
    }
    // Support element id references
    if (scrollTarget === 'document') {

      this.scrollTarget = this._doc;
    } else if (typeof scrollTarget === 'string') {

      var domHost = this.domHost;

      this.scrollTarget = domHost && domHost.$ ? domHost.$[scrollTarget] : Polymer.dom(this.ownerDocument).querySelector('#' + scrollTarget);
    } else if (this._isValidScrollTarget()) {

      this._oldScrollTarget = scrollTarget;
      this._toggleScrollListener(this._shouldHaveListener, scrollTarget);
    }
  },

  /**
   * Runs on every scroll event. Consumer of this behavior may override this method.
   *
   * @protected
   */
  _scrollHandler: function scrollHandler() {},

  /**
   * The default scroll target. Consumers of this behavior may want to customize
   * the default scroll target.
   *
   * @type {Element}
   */
  get _defaultScrollTarget() {
    return this._doc;
  },

  /**
   * Shortcut for the document element
   *
   * @type {Element}
   */
  get _doc() {
    return this.ownerDocument.documentElement;
  },

  /**
   * Gets the number of pixels that the content of an element is scrolled upward.
   *
   * @type {number}
   */
  get _scrollTop() {
    if (this._isValidScrollTarget()) {
      return this.scrollTarget === this._doc ? window.pageYOffset : this.scrollTarget.scrollTop;
    }
    return 0;
  },

  /**
   * Gets the number of pixels that the content of an element is scrolled to the left.
   *
   * @type {number}
   */
  get _scrollLeft() {
    if (this._isValidScrollTarget()) {
      return this.scrollTarget === this._doc ? window.pageXOffset : this.scrollTarget.scrollLeft;
    }
    return 0;
  },

  /**
   * Sets the number of pixels that the content of an element is scrolled upward.
   *
   * @type {number}
   */
  set _scrollTop(top) {
    if (this.scrollTarget === this._doc) {
      window.scrollTo(window.pageXOffset, top);
    } else if (this._isValidScrollTarget()) {
      this.scrollTarget.scrollTop = top;
    }
  },

  /**
   * Sets the number of pixels that the content of an element is scrolled to the left.
   *
   * @type {number}
   */
  set _scrollLeft(left) {
    if (this.scrollTarget === this._doc) {
      window.scrollTo(left, window.pageYOffset);
    } else if (this._isValidScrollTarget()) {
      this.scrollTarget.scrollLeft = left;
    }
  },

  /**
   * Scrolls the content to a particular place.
   *
   * @method scroll
   * @param {number} left The left position
   * @param {number} top The top position
   */
  scroll: function scroll(left, top) {
    if (this.scrollTarget === this._doc) {
      window.scrollTo(left, top);
    } else if (this._isValidScrollTarget()) {
      this.scrollTarget.scrollLeft = left;
      this.scrollTarget.scrollTop = top;
    }
  },

  /**
   * Gets the width of the scroll target.
   *
   * @type {number}
   */
  get _scrollTargetWidth() {
    if (this._isValidScrollTarget()) {
      return this.scrollTarget === this._doc ? window.innerWidth : this.scrollTarget.offsetWidth;
    }
    return 0;
  },

  /**
   * Gets the height of the scroll target.
   *
   * @type {number}
   */
  get _scrollTargetHeight() {
    if (this._isValidScrollTarget()) {
      return this.scrollTarget === this._doc ? window.innerHeight : this.scrollTarget.offsetHeight;
    }
    return 0;
  },

  /**
   * Returns true if the scroll target is a valid HTMLElement.
   *
   * @return {boolean}
   */
  _isValidScrollTarget: function _isValidScrollTarget() {
    return this.scrollTarget instanceof HTMLElement;
  },

  _toggleScrollListener: function _toggleScrollListener(yes, scrollTarget) {
    var eventTarget = scrollTarget === this._doc ? window : scrollTarget;
    if (yes) {
      if (!this._boundScrollHandler) {
        this._boundScrollHandler = this._scrollHandler.bind(this);
        eventTarget.addEventListener('scroll', this._boundScrollHandler);
      }
    } else {
      if (this._boundScrollHandler) {
        eventTarget.removeEventListener('scroll', this._boundScrollHandler);
        this._boundScrollHandler = null;
      }
    }
  },

  /**
   * Enables or disables the scroll event listener.
   *
   * @param {boolean} yes True to add the event, False to remove it.
   */
  toggleScrollListener: function toggleScrollListener(yes) {
    this._shouldHaveListener = yes;
    this._toggleScrollListener(yes, this.scrollTarget);
  }

};

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

__webpack_require__(16);

__webpack_require__(34);

/**
 * @demo demo/index.html
 * @polymerBehavior Polymer.IronButtonState
 */
Polymer.IronButtonStateImpl = {

  properties: {

    /**
     * If true, the user is currently holding down the button.
     */
    pressed: {
      type: Boolean,
      readOnly: true,
      value: false,
      reflectToAttribute: true,
      observer: '_pressedChanged'
    },

    /**
     * If true, the button toggles the active state with each tap or press
     * of the spacebar.
     */
    toggles: {
      type: Boolean,
      value: false,
      reflectToAttribute: true
    },

    /**
     * If true, the button is a toggle and is currently in the active state.
     */
    active: {
      type: Boolean,
      value: false,
      notify: true,
      reflectToAttribute: true
    },

    /**
     * True if the element is currently being pressed by a "pointer," which
     * is loosely defined as mouse or touch input (but specifically excluding
     * keyboard input).
     */
    pointerDown: {
      type: Boolean,
      readOnly: true,
      value: false
    },

    /**
     * True if the input device that caused the element to receive focus
     * was a keyboard.
     */
    receivedFocusFromKeyboard: {
      type: Boolean,
      readOnly: true
    },

    /**
     * The aria attribute to be set if the button is a toggle and in the
     * active state.
     */
    ariaActiveAttribute: {
      type: String,
      value: 'aria-pressed',
      observer: '_ariaActiveAttributeChanged'
    }
  },

  listeners: {
    down: '_downHandler',
    up: '_upHandler',
    tap: '_tapHandler'
  },

  observers: ['_focusChanged(focused)', '_activeChanged(active, ariaActiveAttribute)'],

  keyBindings: {
    'enter:keydown': '_asyncClick',
    'space:keydown': '_spaceKeyDownHandler',
    'space:keyup': '_spaceKeyUpHandler'
  },

  _mouseEventRe: /^mouse/,

  _tapHandler: function _tapHandler() {
    if (this.toggles) {
      // a tap is needed to toggle the active state
      this._userActivate(!this.active);
    } else {
      this.active = false;
    }
  },

  _focusChanged: function _focusChanged(focused) {
    this._detectKeyboardFocus(focused);

    if (!focused) {
      this._setPressed(false);
    }
  },

  _detectKeyboardFocus: function _detectKeyboardFocus(focused) {
    this._setReceivedFocusFromKeyboard(!this.pointerDown && focused);
  },

  // to emulate native checkbox, (de-)activations from a user interaction fire
  // 'change' events
  _userActivate: function _userActivate(active) {
    if (this.active !== active) {
      this.active = active;
      this.fire('change');
    }
  },

  _downHandler: function _downHandler(event) {
    this._setPointerDown(true);
    this._setPressed(true);
    this._setReceivedFocusFromKeyboard(false);
  },

  _upHandler: function _upHandler() {
    this._setPointerDown(false);
    this._setPressed(false);
  },

  /**
   * @param {!KeyboardEvent} event .
   */
  _spaceKeyDownHandler: function _spaceKeyDownHandler(event) {
    var keyboardEvent = event.detail.keyboardEvent;
    var target = Polymer.dom(keyboardEvent).localTarget;

    // Ignore the event if this is coming from a focused light child, since that
    // element will deal with it.
    if (this.isLightDescendant( /** @type {Node} */target)) return;

    keyboardEvent.preventDefault();
    keyboardEvent.stopImmediatePropagation();
    this._setPressed(true);
  },

  /**
   * @param {!KeyboardEvent} event .
   */
  _spaceKeyUpHandler: function _spaceKeyUpHandler(event) {
    var keyboardEvent = event.detail.keyboardEvent;
    var target = Polymer.dom(keyboardEvent).localTarget;

    // Ignore the event if this is coming from a focused light child, since that
    // element will deal with it.
    if (this.isLightDescendant( /** @type {Node} */target)) return;

    if (this.pressed) {
      this._asyncClick();
    }
    this._setPressed(false);
  },

  // trigger click asynchronously, the asynchrony is useful to allow one
  // event handler to unwind before triggering another event
  _asyncClick: function _asyncClick() {
    this.async(function () {
      this.click();
    }, 1);
  },

  // any of these changes are considered a change to button state

  _pressedChanged: function _pressedChanged(pressed) {
    this._changedButtonState();
  },

  _ariaActiveAttributeChanged: function _ariaActiveAttributeChanged(value, oldValue) {
    if (oldValue && oldValue != value && this.hasAttribute(oldValue)) {
      this.removeAttribute(oldValue);
    }
  },

  _activeChanged: function _activeChanged(active, ariaActiveAttribute) {
    if (this.toggles) {
      this.setAttribute(this.ariaActiveAttribute, active ? 'true' : 'false');
    } else {
      this.removeAttribute(this.ariaActiveAttribute);
    }
    this._changedButtonState();
  },

  _controlStateChanged: function _controlStateChanged() {
    if (this.disabled) {
      this._setPressed(false);
    } else {
      this._changedButtonState();
    }
  },

  // provide hook for follow-on behaviors to react to button-state

  _changedButtonState: function _changedButtonState() {
    if (this._buttonStateChanged) {
      this._buttonStateChanged(); // abstract
    }
  }

};

/** @polymerBehavior */
Polymer.IronButtonState = [Polymer.IronA11yKeysBehavior, Polymer.IronButtonStateImpl];

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

var RegisterHtmlTemplate = __webpack_require__(2);

RegisterHtmlTemplate.toBody("<custom-style> <style is=custom-style>html{--google-red-100:#f4c7c3;--google-red-300:#e67c73;--google-red-500:#db4437;--google-red-700:#c53929;--google-blue-100:#c6dafc;--google-blue-300:#7baaf7;--google-blue-500:#4285f4;--google-blue-700:#3367d6;--google-green-100:#b7e1cd;--google-green-300:#57bb8a;--google-green-500:#0f9d58;--google-green-700:#0b8043;--google-yellow-100:#fce8b2;--google-yellow-300:#f7cb4d;--google-yellow-500:#f4b400;--google-yellow-700:#f09300;--google-grey-100:#f5f5f5;--google-grey-300:#e0e0e0;--google-grey-500:#9e9e9e;--google-grey-700:#616161;--paper-red-50:#ffebee;--paper-red-100:#ffcdd2;--paper-red-200:#ef9a9a;--paper-red-300:#e57373;--paper-red-400:#ef5350;--paper-red-500:#f44336;--paper-red-600:#e53935;--paper-red-700:#d32f2f;--paper-red-800:#c62828;--paper-red-900:#b71c1c;--paper-red-a100:#ff8a80;--paper-red-a200:#ff5252;--paper-red-a400:#ff1744;--paper-red-a700:#d50000;--paper-pink-50:#fce4ec;--paper-pink-100:#f8bbd0;--paper-pink-200:#f48fb1;--paper-pink-300:#f06292;--paper-pink-400:#ec407a;--paper-pink-500:#e91e63;--paper-pink-600:#d81b60;--paper-pink-700:#c2185b;--paper-pink-800:#ad1457;--paper-pink-900:#880e4f;--paper-pink-a100:#ff80ab;--paper-pink-a200:#ff4081;--paper-pink-a400:#f50057;--paper-pink-a700:#c51162;--paper-purple-50:#f3e5f5;--paper-purple-100:#e1bee7;--paper-purple-200:#ce93d8;--paper-purple-300:#ba68c8;--paper-purple-400:#ab47bc;--paper-purple-500:#9c27b0;--paper-purple-600:#8e24aa;--paper-purple-700:#7b1fa2;--paper-purple-800:#6a1b9a;--paper-purple-900:#4a148c;--paper-purple-a100:#ea80fc;--paper-purple-a200:#e040fb;--paper-purple-a400:#d500f9;--paper-purple-a700:#aa00ff;--paper-deep-purple-50:#ede7f6;--paper-deep-purple-100:#d1c4e9;--paper-deep-purple-200:#b39ddb;--paper-deep-purple-300:#9575cd;--paper-deep-purple-400:#7e57c2;--paper-deep-purple-500:#673ab7;--paper-deep-purple-600:#5e35b1;--paper-deep-purple-700:#512da8;--paper-deep-purple-800:#4527a0;--paper-deep-purple-900:#311b92;--paper-deep-purple-a100:#b388ff;--paper-deep-purple-a200:#7c4dff;--paper-deep-purple-a400:#651fff;--paper-deep-purple-a700:#6200ea;--paper-indigo-50:#e8eaf6;--paper-indigo-100:#c5cae9;--paper-indigo-200:#9fa8da;--paper-indigo-300:#7986cb;--paper-indigo-400:#5c6bc0;--paper-indigo-500:#3f51b5;--paper-indigo-600:#3949ab;--paper-indigo-700:#303f9f;--paper-indigo-800:#283593;--paper-indigo-900:#1a237e;--paper-indigo-a100:#8c9eff;--paper-indigo-a200:#536dfe;--paper-indigo-a400:#3d5afe;--paper-indigo-a700:#304ffe;--paper-blue-50:#e3f2fd;--paper-blue-100:#bbdefb;--paper-blue-200:#90caf9;--paper-blue-300:#64b5f6;--paper-blue-400:#42a5f5;--paper-blue-500:#2196f3;--paper-blue-600:#1e88e5;--paper-blue-700:#1976d2;--paper-blue-800:#1565c0;--paper-blue-900:#0d47a1;--paper-blue-a100:#82b1ff;--paper-blue-a200:#448aff;--paper-blue-a400:#2979ff;--paper-blue-a700:#2962ff;--paper-light-blue-50:#e1f5fe;--paper-light-blue-100:#b3e5fc;--paper-light-blue-200:#81d4fa;--paper-light-blue-300:#4fc3f7;--paper-light-blue-400:#29b6f6;--paper-light-blue-500:#03a9f4;--paper-light-blue-600:#039be5;--paper-light-blue-700:#0288d1;--paper-light-blue-800:#0277bd;--paper-light-blue-900:#01579b;--paper-light-blue-a100:#80d8ff;--paper-light-blue-a200:#40c4ff;--paper-light-blue-a400:#00b0ff;--paper-light-blue-a700:#0091ea;--paper-cyan-50:#e0f7fa;--paper-cyan-100:#b2ebf2;--paper-cyan-200:#80deea;--paper-cyan-300:#4dd0e1;--paper-cyan-400:#26c6da;--paper-cyan-500:#00bcd4;--paper-cyan-600:#00acc1;--paper-cyan-700:#0097a7;--paper-cyan-800:#00838f;--paper-cyan-900:#006064;--paper-cyan-a100:#84ffff;--paper-cyan-a200:#18ffff;--paper-cyan-a400:#00e5ff;--paper-cyan-a700:#00b8d4;--paper-teal-50:#e0f2f1;--paper-teal-100:#b2dfdb;--paper-teal-200:#80cbc4;--paper-teal-300:#4db6ac;--paper-teal-400:#26a69a;--paper-teal-500:#009688;--paper-teal-600:#00897b;--paper-teal-700:#00796b;--paper-teal-800:#00695c;--paper-teal-900:#004d40;--paper-teal-a100:#a7ffeb;--paper-teal-a200:#64ffda;--paper-teal-a400:#1de9b6;--paper-teal-a700:#00bfa5;--paper-green-50:#e8f5e9;--paper-green-100:#c8e6c9;--paper-green-200:#a5d6a7;--paper-green-300:#81c784;--paper-green-400:#66bb6a;--paper-green-500:#4caf50;--paper-green-600:#43a047;--paper-green-700:#388e3c;--paper-green-800:#2e7d32;--paper-green-900:#1b5e20;--paper-green-a100:#b9f6ca;--paper-green-a200:#69f0ae;--paper-green-a400:#00e676;--paper-green-a700:#00c853;--paper-light-green-50:#f1f8e9;--paper-light-green-100:#dcedc8;--paper-light-green-200:#c5e1a5;--paper-light-green-300:#aed581;--paper-light-green-400:#9ccc65;--paper-light-green-500:#8bc34a;--paper-light-green-600:#7cb342;--paper-light-green-700:#689f38;--paper-light-green-800:#558b2f;--paper-light-green-900:#33691e;--paper-light-green-a100:#ccff90;--paper-light-green-a200:#b2ff59;--paper-light-green-a400:#76ff03;--paper-light-green-a700:#64dd17;--paper-lime-50:#f9fbe7;--paper-lime-100:#f0f4c3;--paper-lime-200:#e6ee9c;--paper-lime-300:#dce775;--paper-lime-400:#d4e157;--paper-lime-500:#cddc39;--paper-lime-600:#c0ca33;--paper-lime-700:#afb42b;--paper-lime-800:#9e9d24;--paper-lime-900:#827717;--paper-lime-a100:#f4ff81;--paper-lime-a200:#eeff41;--paper-lime-a400:#c6ff00;--paper-lime-a700:#aeea00;--paper-yellow-50:#fffde7;--paper-yellow-100:#fff9c4;--paper-yellow-200:#fff59d;--paper-yellow-300:#fff176;--paper-yellow-400:#ffee58;--paper-yellow-500:#ffeb3b;--paper-yellow-600:#fdd835;--paper-yellow-700:#fbc02d;--paper-yellow-800:#f9a825;--paper-yellow-900:#f57f17;--paper-yellow-a100:#ffff8d;--paper-yellow-a200:#ffff00;--paper-yellow-a400:#ffea00;--paper-yellow-a700:#ffd600;--paper-amber-50:#fff8e1;--paper-amber-100:#ffecb3;--paper-amber-200:#ffe082;--paper-amber-300:#ffd54f;--paper-amber-400:#ffca28;--paper-amber-500:#ffc107;--paper-amber-600:#ffb300;--paper-amber-700:#ffa000;--paper-amber-800:#ff8f00;--paper-amber-900:#ff6f00;--paper-amber-a100:#ffe57f;--paper-amber-a200:#ffd740;--paper-amber-a400:#ffc400;--paper-amber-a700:#ffab00;--paper-orange-50:#fff3e0;--paper-orange-100:#ffe0b2;--paper-orange-200:#ffcc80;--paper-orange-300:#ffb74d;--paper-orange-400:#ffa726;--paper-orange-500:#ff9800;--paper-orange-600:#fb8c00;--paper-orange-700:#f57c00;--paper-orange-800:#ef6c00;--paper-orange-900:#e65100;--paper-orange-a100:#ffd180;--paper-orange-a200:#ffab40;--paper-orange-a400:#ff9100;--paper-orange-a700:#ff6500;--paper-deep-orange-50:#fbe9e7;--paper-deep-orange-100:#ffccbc;--paper-deep-orange-200:#ffab91;--paper-deep-orange-300:#ff8a65;--paper-deep-orange-400:#ff7043;--paper-deep-orange-500:#ff5722;--paper-deep-orange-600:#f4511e;--paper-deep-orange-700:#e64a19;--paper-deep-orange-800:#d84315;--paper-deep-orange-900:#bf360c;--paper-deep-orange-a100:#ff9e80;--paper-deep-orange-a200:#ff6e40;--paper-deep-orange-a400:#ff3d00;--paper-deep-orange-a700:#dd2c00;--paper-brown-50:#efebe9;--paper-brown-100:#d7ccc8;--paper-brown-200:#bcaaa4;--paper-brown-300:#a1887f;--paper-brown-400:#8d6e63;--paper-brown-500:#795548;--paper-brown-600:#6d4c41;--paper-brown-700:#5d4037;--paper-brown-800:#4e342e;--paper-brown-900:#3e2723;--paper-grey-50:#fafafa;--paper-grey-100:#f5f5f5;--paper-grey-200:#eeeeee;--paper-grey-300:#e0e0e0;--paper-grey-400:#bdbdbd;--paper-grey-500:#9e9e9e;--paper-grey-600:#757575;--paper-grey-700:#616161;--paper-grey-800:#424242;--paper-grey-900:#212121;--paper-blue-grey-50:#eceff1;--paper-blue-grey-100:#cfd8dc;--paper-blue-grey-200:#b0bec5;--paper-blue-grey-300:#90a4ae;--paper-blue-grey-400:#78909c;--paper-blue-grey-500:#607d8b;--paper-blue-grey-600:#546e7a;--paper-blue-grey-700:#455a64;--paper-blue-grey-800:#37474f;--paper-blue-grey-900:#263238;--dark-divider-opacity:0.12;--dark-disabled-opacity:0.38;--dark-secondary-opacity:0.54;--dark-primary-opacity:0.87;--light-divider-opacity:0.12;--light-disabled-opacity:0.3;--light-secondary-opacity:0.7;--light-primary-opacity:1.0}</style> </custom-style>");

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(40);


/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

__webpack_require__(6);

__webpack_require__(45);

__webpack_require__(65);

__webpack_require__(67);

__webpack_require__(69);

__webpack_require__(70);

__webpack_require__(74);

__webpack_require__(75);

__webpack_require__(79);

__webpack_require__(80);

__webpack_require__(82);

__webpack_require__(33);

__webpack_require__(86);

var RegisterHtmlTemplate = __webpack_require__(2);

RegisterHtmlTemplate.register("<dom-module id=my-app> <template> <style>:host{--app-primary-color:#3D2814;--app-secondary-color:#FF3C3C;display:block}app-drawer-layout:not([narrow]) [drawer-toggle]{display:none}app-header{color:#fff;background-color:var(--app-primary-color)}app-header paper-icon-button{--paper-icon-button-ink-color:white}.drawer-list{margin:0 20px}.drawer-list a{display:block;padding:0 16px;text-decoration:none;color:var(--app-secondary-color);line-height:40px}.drawer-list a.iron-selected{color:#000;font-weight:700}</style> <app-location route={{route}} url-space-regex=^[[rootPath]]></app-location> <app-route route={{route}} pattern=[[rootPath]]:page data={{routeData}} tail={{subroute}}></app-route> <app-drawer-layout fullbleed=\"\"> <app-drawer id=drawer slot=drawer> <app-toolbar>Spiele</app-toolbar> <iron-selector selected=[[page]] attr-for-selected=name class=drawer-list role=navigation> <a name=view2 href$=[[rootPath]]view2>News</a> <a name=games href$=[[rootPath]]games>Spiele</a> <a name=authors href$=[[rootPath]]authors>Autoren</a> <a name=publishers href$=[[rootPath]]publishers>Verlage</a> <a name=designers href$=[[rootPath]]designers>Designer</a> <a name=reviews href$=[[rootPath]]reviews>Rezensenionen</a> <a name=view3 href$=[[rootPath]]view3>Preise</a> <hr> <a name=view3 href$=[[rootPath]]view3>Sammlung</a> <a name=view3 href$=[[rootPath]]view3>Settings</a> </iron-selector> </app-drawer> <app-header-layout has-scrolling-region=\"\"> <app-header slot=header condenses=\"\" reveals=\"\" effects=waterfall> <app-toolbar> <paper-icon-button icon=my-icons:menu drawer-toggle=\"\"></paper-icon-button> <div main-title=\"\">Luding.org</div> </app-toolbar> </app-header> <iron-pages selected=[[page]] attr-for-selected=name fallback-selection=view404 role=main> <games-list name=games></games-list> <my-view2 name=view2></my-view2> <authors-list name=authors></authors-list> <publishers-list name=publishers></publishers-list> <my-view3 name=view3></my-view3> <my-view404 name=view404></my-view404> </iron-pages> </app-header-layout> </app-drawer-layout> </template> </dom-module>");

var MyApp = function (_Polymer$Element) {
  _inherits(MyApp, _Polymer$Element);

  _createClass(MyApp, null, [{
    key: 'is',
    get: function get() {
      return 'my-app';
    }
  }, {
    key: 'properties',
    get: function get() {
      return {
        page: {
          type: String,
          reflectToAttribute: true,
          observer: '_pageChanged'
        },
        routeData: Object,
        subroute: String,
        rootPath: {
          type: String,
          value: '/'
        },
        lazyPages: {
          type: Object,
          value: {
            view2: function view2() {
              __webpack_require__.e/* import() */(4).then(__webpack_require__.bind(null, 87));
            },
            games: function games() {
              __webpack_require__.e/* import() */(0).then(__webpack_require__.bind(null, 88));
            },
            authors: function authors() {
              __webpack_require__.e/* import() */(2).then(__webpack_require__.bind(null, 89));
            },
            publishers: function publishers() {
              __webpack_require__.e/* import() */(1).then(__webpack_require__.bind(null, 90));
            },
            view3: function view3() {
              __webpack_require__.e/* import() */(3).then(__webpack_require__.bind(null, 91));
            },
            view404: function view404() {
              __webpack_require__.e/* import() */(5).then(__webpack_require__.bind(null, 92));
            }
          }
        }
      };
    }
  }, {
    key: 'observers',
    get: function get() {
      return ['_routePageChanged(routeData.page)'];
    }
  }]);

  function MyApp() {
    _classCallCheck(this, MyApp);

    return _possibleConstructorReturn(this, (MyApp.__proto__ || Object.getPrototypeOf(MyApp)).call(this));
  }

  _createClass(MyApp, [{
    key: '_routePageChanged',
    value: function _routePageChanged(page) {
      // Polymer 2.0 will call with `undefined` on initialization.
      // Ignore until we are properly called with a string.
      if (page === undefined) {
        return;
      }

      // If no page was found in the route data, page will be an empty string.
      // Deault to 'view1' in that case.
      this.page = page || 'view1';

      // Close a non-persistent drawer when the page & route are changed.
      if (!this.$.drawer.persistent) {
        this.$.drawer.close();
      }
    }
  }, {
    key: '_pageChanged',
    value: function _pageChanged(page) {
      if (this.lazyPages[page]) {
        this.lazyPages[page]();
      } else {
        this._showPage404();
      }
    }
  }, {
    key: '_showPage404',
    value: function _showPage404() {
      this.page = 'view404';
    }
  }]);

  return MyApp;
}(Polymer.Element);

window.customElements.define(MyApp.is, MyApp);

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

__webpack_require__(1);

__webpack_require__(7);

(function () {
  'use strict';

  var modules = {};
  var lcModules = {};
  function findModule(id) {
    return modules[id] || lcModules[id.toLowerCase()];
  }

  function styleOutsideTemplateCheck(inst) {
    if (inst.querySelector('style')) {
      console.warn('dom-module %s has style outside template', inst.id);
    }
  }

  /**
   * The `dom-module` element registers the dom it contains to the name given
   * by the module's id attribute. It provides a unified database of dom
   * accessible via its static `import` API.
   *
   * A key use case of `dom-module` is for providing custom element `<template>`s
   * via HTML imports that are parsed by the native HTML parser, that can be
   * relocated during a bundling pass and still looked up by `id`.
   *
   * Example:
   *
   *     <dom-module id="foo">
   *       <img src="stuff.png">
   *     </dom-module>
   *
   * Then in code in some other location that cannot access the dom-module above
   *
   *     let img = document.createElement('dom-module').import('foo', 'img');
   *
   * @customElement
   * @extends HTMLElement
   * @memberof Polymer
   * @summary Custom element that provides a registry of relocatable DOM content
   *   by `id` that is agnostic to bundling.
   * @unrestricted
   */

  var DomModule = function (_HTMLElement) {
    _inherits(DomModule, _HTMLElement);

    function DomModule() {
      _classCallCheck(this, DomModule);

      return _possibleConstructorReturn(this, (DomModule.__proto__ || Object.getPrototypeOf(DomModule)).apply(this, arguments));
    }

    _createClass(DomModule, [{
      key: 'attributeChangedCallback',
      value: function attributeChangedCallback(name, old, value) {
        if (old !== value) {
          this.register();
        }
      }

      /**
       * The absolute URL of the original location of this `dom-module`.
       *
       * This value will differ from this element's `ownerDocument` in the
       * following ways:
       * - Takes into account any `assetpath` attribute added during bundling
       *   to indicate the original location relative to the bundled location
       * - Uses the HTMLImports polyfill's `importForElement` API to ensure
       *   the path is relative to the import document's location since
       *   `ownerDocument` is not currently polyfilled
       */

    }, {
      key: 'register',


      /**
       * Registers the dom-module at a given id. This method should only be called
       * when a dom-module is imperatively created. For
       * example, `document.createElement('dom-module').register('foo')`.
       * @param {string=} id The id at which to register the dom-module.
       */
      value: function register(id) {
        id = id || this.id;
        if (id) {
          this.id = id;
          // store id separate from lowercased id so that
          // in all cases mixedCase id will stored distinctly
          // and lowercase version is a fallback
          modules[id] = this;
          lcModules[id.toLowerCase()] = this;
          styleOutsideTemplateCheck(this);
        }
      }
    }, {
      key: 'assetpath',
      get: function get() {
        // Don't override existing assetpath.
        if (!this.__assetpath) {
          // note: assetpath set via an attribute must be relative to this
          // element's location; accomodate polyfilled HTMLImports
          var owner = window.HTMLImports && HTMLImports.importForElement ? HTMLImports.importForElement(this) || document : this.ownerDocument;
          var url = Polymer.ResolveUrl.resolveUrl(this.getAttribute('assetpath') || '', owner.baseURI);
          this.__assetpath = Polymer.ResolveUrl.pathFromUrl(url);
        }
        return this.__assetpath;
      }
    }], [{
      key: 'import',


      /**
       * Retrieves the element specified by the css `selector` in the module
       * registered by `id`. For example, this.import('foo', 'img');
       * @param {string} id The id of the dom-module in which to search.
       * @param {string=} selector The css selector by which to find the element.
       * @return {Element} Returns the element which matches `selector` in the
       * module registered at the specified `id`.
       */
      value: function _import(id, selector) {
        if (id) {
          var m = findModule(id);
          if (m && selector) {
            return m.querySelector(selector);
          }
          return m;
        }
        return null;
      }
    }, {
      key: 'observedAttributes',
      get: function get() {
        return ['id'];
      }
    }]);

    return DomModule;
  }(HTMLElement);

  DomModule.prototype['modules'] = modules;

  customElements.define('dom-module', DomModule);

  // export
  Polymer.DomModule = DomModule;
})();

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(1);

(function () {
  'use strict';

  /**
   * Module with utilities for manipulating structured data path strings.
   *
   * @namespace
   * @memberof Polymer
   * @summary Module with utilities for manipulating structured data path strings.
   */

  var Path = {

    /**
     * Returns true if the given string is a structured data path (has dots).
     *
     * Example:
     *
     * ```
     * Polymer.Path.isPath('foo.bar.baz') // true
     * Polymer.Path.isPath('foo')         // false
     * ```
     *
     * @memberof Polymer.Path
     * @param {string} path Path string
     * @return {boolean} True if the string contained one or more dots
     */
    isPath: function isPath(path) {
      return path.indexOf('.') >= 0;
    },

    /**
     * Returns the root property name for the given path.
     *
     * Example:
     *
     * ```
     * Polymer.Path.root('foo.bar.baz') // 'foo'
     * Polymer.Path.root('foo')         // 'foo'
     * ```
     *
     * @memberof Polymer.Path
     * @param {string} path Path string
     * @return {string} Root property name
     */
    root: function root(path) {
      var dotIndex = path.indexOf('.');
      if (dotIndex === -1) {
        return path;
      }
      return path.slice(0, dotIndex);
    },

    /**
     * Given `base` is `foo.bar`, `foo` is an ancestor, `foo.bar` is not
     * Returns true if the given path is an ancestor of the base path.
     *
     * Example:
     *
     * ```
     * Polymer.Path.isAncestor('foo.bar', 'foo')         // true
     * Polymer.Path.isAncestor('foo.bar', 'foo.bar')     // false
     * Polymer.Path.isAncestor('foo.bar', 'foo.bar.baz') // false
     * ```
     *
     * @memberof Polymer.Path
     * @param {string} base Path string to test against.
     * @param {string} path Path string to test.
     * @return {boolean} True if `path` is an ancestor of `base`.
     */
    isAncestor: function isAncestor(base, path) {
      //     base.startsWith(path + '.');
      return base.indexOf(path + '.') === 0;
    },

    /**
     * Given `base` is `foo.bar`, `foo.bar.baz` is an descendant
     *
     * Example:
     *
     * ```
     * Polymer.Path.isDescendant('foo.bar', 'foo.bar.baz') // true
     * Polymer.Path.isDescendant('foo.bar', 'foo.bar')     // false
     * Polymer.Path.isDescendant('foo.bar', 'foo')         // false
     * ```
     *
     * @memberof Polymer.Path
     * @param {string} base Path string to test against.
     * @param {string} path Path string to test.
     * @return {boolean} True if `path` is a descendant of `base`.
     */
    isDescendant: function isDescendant(base, path) {
      //     path.startsWith(base + '.');
      return path.indexOf(base + '.') === 0;
    },

    /**
     * Replaces a previous base path with a new base path, preserving the
     * remainder of the path.
     *
     * User must ensure `path` has a prefix of `base`.
     *
     * Example:
     *
     * ```
     * Polymer.Path.translate('foo.bar', 'zot' 'foo.bar.baz') // 'zot.baz'
     * ```
     *
     * @memberof Polymer.Path
     * @param {string} base Current base string to remove
     * @param {string} newBase New base string to replace with
     * @param {string} path Path to translate
     * @return {string} Translated string
     */
    translate: function translate(base, newBase, path) {
      return newBase + path.slice(base.length);
    },

    /**
     * @param {string} base Path string to test against
     * @param {string} path Path string to test
     * @return {boolean} True if `path` is equal to `base`
     * @this {Path}
     */
    matches: function matches(base, path) {
      return base === path || this.isAncestor(base, path) || this.isDescendant(base, path);
    },

    /**
     * Converts array-based paths to flattened path.  String-based paths
     * are returned as-is.
     *
     * Example:
     *
     * ```
     * Polymer.Path.normalize(['foo.bar', 0, 'baz'])  // 'foo.bar.0.baz'
     * Polymer.Path.normalize('foo.bar.0.baz')        // 'foo.bar.0.baz'
     * ```
     *
     * @memberof Polymer.Path
     * @param {string | !Array<string|number>} path Input path
     * @return {string} Flattened path
     */
    normalize: function normalize(path) {
      if (Array.isArray(path)) {
        var parts = [];
        for (var i = 0; i < path.length; i++) {
          var args = path[i].toString().split('.');
          for (var j = 0; j < args.length; j++) {
            parts.push(args[j]);
          }
        }
        return parts.join('.');
      } else {
        return path;
      }
    },

    /**
     * Splits a path into an array of property names. Accepts either arrays
     * of path parts or strings.
     *
     * Example:
     *
     * ```
     * Polymer.Path.split(['foo.bar', 0, 'baz'])  // ['foo', 'bar', '0', 'baz']
     * Polymer.Path.split('foo.bar.0.baz')        // ['foo', 'bar', '0', 'baz']
     * ```
     *
     * @memberof Polymer.Path
     * @param {string | !Array<string|number>} path Input path
     * @return {!Array<string>} Array of path parts
     * @this {Path}
     * @suppress {checkTypes}
     */
    split: function split(path) {
      if (Array.isArray(path)) {
        return this.normalize(path).split('.');
      }
      return path.toString().split('.');
    },

    /**
     * Reads a value from a path.  If any sub-property in the path is `undefined`,
     * this method returns `undefined` (will never throw.
     *
     * @memberof Polymer.Path
     * @param {Object} root Object from which to dereference path from
     * @param {string | !Array<string|number>} path Path to read
     * @param {Object=} info If an object is provided to `info`, the normalized
     *  (flattened) path will be set to `info.path`.
     * @return {*} Value at path, or `undefined` if the path could not be
     *  fully dereferenced.
     * @this {Path}
     */
    get: function get(root, path, info) {
      var prop = root;
      var parts = this.split(path);
      // Loop over path parts[0..n-1] and dereference
      for (var i = 0; i < parts.length; i++) {
        if (!prop) {
          return;
        }
        var part = parts[i];
        prop = prop[part];
      }
      if (info) {
        info.path = parts.join('.');
      }
      return prop;
    },

    /**
     * Sets a value to a path.  If any sub-property in the path is `undefined`,
     * this method will no-op.
     *
     * @memberof Polymer.Path
     * @param {Object} root Object from which to dereference path from
     * @param {string | !Array<string|number>} path Path to set
     * @param {*} value Value to set to path
     * @return {string | undefined} The normalized version of the input path
     * @this {Path}
     */
    set: function set(root, path, value) {
      var prop = root;
      var parts = this.split(path);
      var last = parts[parts.length - 1];
      if (parts.length > 1) {
        // Loop over path parts[0..n-2] and dereference
        for (var i = 0; i < parts.length - 1; i++) {
          var part = parts[i];
          prop = prop[part];
          if (!prop) {
            return;
          }
        }
        // Set value to object at end of path
        prop[last] = value;
      } else {
        // Simple property set
        prop[path] = value;
      }
      return parts.join('.');
    }

  };

  /**
   * Returns true if the given string is a structured data path (has dots).
   *
   * This function is deprecated.  Use `Polymer.Path.isPath` instead.
   *
   * Example:
   *
   * ```
   * Polymer.Path.isDeep('foo.bar.baz') // true
   * Polymer.Path.isDeep('foo')         // false
   * ```
   *
   * @deprecated
   * @memberof Polymer.Path
   * @param {string} path Path string
   * @return {boolean} True if the string contained one or more dots
   */
  Path.isDeep = Path.isPath;

  Polymer.Path = Path;
})();

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

__webpack_require__(1);

__webpack_require__(3);

__webpack_require__(10);

__webpack_require__(8);

(function () {

  'use strict';

  var caseMap = Polymer.CaseMap;

  var microtask = Polymer.Async.microTask;

  // Save map of native properties; this forms a blacklist or properties
  // that won't have their values "saved" by `saveAccessorValue`, since
  // reading from an HTMLElement accessor from the context of a prototype throws
  var nativeProperties = {};
  var proto = HTMLElement.prototype;
  while (proto) {
    var props = Object.getOwnPropertyNames(proto);
    for (var i = 0; i < props.length; i++) {
      nativeProperties[props[i]] = true;
    }
    proto = Object.getPrototypeOf(proto);
  }

  /**
   * Used to save the value of a property that will be overridden with
   * an accessor. If the `model` is a prototype, the values will be saved
   * in `__dataProto`, and it's up to the user (or downstream mixin) to
   * decide how/when to set these values back into the accessors.
   * If `model` is already an instance (it has a `__data` property), then
   * the value will be set as a pending property, meaning the user should
   * call `_invalidateProperties` or `_flushProperties` to take effect
   *
   * @param {Object} model Prototype or instance
   * @param {string} property Name of property
   * @private
   */
  function saveAccessorValue(model, property) {
    // Don't read/store value for any native properties since they could throw
    if (!nativeProperties[property]) {
      var value = model[property];
      if (value !== undefined) {
        if (model.__data) {
          // Adding accessor to instance; update the property
          // It is the user's responsibility to call _flushProperties
          model._setPendingProperty(property, value);
        } else {
          // Adding accessor to proto; save proto's value for instance-time use
          if (!model.__dataProto) {
            model.__dataProto = {};
          } else if (!model.hasOwnProperty(JSCompiler_renameProperty('__dataProto', model))) {
            model.__dataProto = Object.create(model.__dataProto);
          }
          model.__dataProto[property] = value;
        }
      }
    }
  }

  /**
   * Element class mixin that provides basic meta-programming for creating one
   * or more property accessors (getter/setter pair) that enqueue an async
   * (batched) `_propertiesChanged` callback.
   *
   * For basic usage of this mixin, simply declare attributes to observe via
   * the standard `static get observedAttributes()`, implement `_propertiesChanged`
   * on the class, and then call `MyClass.createPropertiesForAttributes()` once
   * on the class to generate property accessors for each observed attribute
   * prior to instancing.  Last, call `this._flushProperties()` once to enable
   * the accessors.
   *
   * Any `observedAttributes` will automatically be
   * deserialized via `attributeChangedCallback` and set to the associated
   * property using `dash-case`-to-`camelCase` convention.
   *
   * @mixinFunction
   * @polymer
   * @memberof Polymer
   * @summary Element class mixin for reacting to property changes from
   *   generated property accessors.
   */
  Polymer.PropertyAccessors = Polymer.dedupingMixin(function (superClass) {

    /**
     * @polymer
     * @mixinClass
     * @implements {Polymer_PropertyAccessors}
     * @extends HTMLElement
     * @unrestricted
     */
    var PropertyAccessors = function (_superClass) {
      _inherits(PropertyAccessors, _superClass);

      _createClass(PropertyAccessors, null, [{
        key: 'createPropertiesForAttributes',


        /**
         * Generates property accessors for all attributes in the standard
         * static `observedAttributes` array.
         *
         * Attribute names are mapped to property names using the `dash-case` to
         * `camelCase` convention
         *
         */
        value: function createPropertiesForAttributes() {
          var a$ = this.observedAttributes;
          for (var _i = 0; _i < a$.length; _i++) {
            this.prototype._createPropertyAccessor(caseMap.dashToCamelCase(a$[_i]));
          }
        }
      }]);

      function PropertyAccessors() {
        _classCallCheck(this, PropertyAccessors);

        /** @type {boolean} */
        var _this = _possibleConstructorReturn(this, (PropertyAccessors.__proto__ || Object.getPrototypeOf(PropertyAccessors)).call(this));

        _this.__serializing;
        /** @type {number} */
        _this.__dataCounter;
        /** @type {boolean} */
        _this.__dataEnabled;
        /** @type {boolean} */
        _this.__dataReady;
        /** @type {boolean} */
        _this.__dataInvalid;
        /** @type {!Object} */
        _this.__data;
        /** @type {Object} */
        _this.__dataPending;
        /** @type {Object} */
        _this.__dataOld;
        /** @type {Object} */
        _this.__dataProto;
        /** @type {Object} */
        _this.__dataHasAccessor;
        /** @type {Object} */
        _this.__dataInstanceProps;
        _this._initializeProperties();
        return _this;
      }

      /**
       * Implements native Custom Elements `attributeChangedCallback` to
       * set an attribute value to a property via `_attributeToProperty`.
       *
       * @param {string} name Name of attribute that changed
       * @param {?string} old Old attribute value
       * @param {?string} value New attribute value
       */


      _createClass(PropertyAccessors, [{
        key: 'attributeChangedCallback',
        value: function attributeChangedCallback(name, old, value) {
          if (old !== value) {
            this._attributeToProperty(name, value);
          }
        }

        /**
         * Initializes the local storage for property accessors.
         *
         * Provided as an override point for performing any setup work prior
         * to initializing the property accessor system.
         *
         * @protected
         */

      }, {
        key: '_initializeProperties',
        value: function _initializeProperties() {
          this.__serializing = false;
          this.__dataCounter = 0;
          this.__dataEnabled = false;
          this.__dataReady = false;
          this.__dataInvalid = false;
          this.__data = {};
          this.__dataPending = null;
          this.__dataOld = null;
          if (this.__dataProto) {
            this._initializeProtoProperties(this.__dataProto);
            this.__dataProto = null;
          }
          // Capture instance properties; these will be set into accessors
          // during first flush. Don't set them here, since we want
          // these to overwrite defaults/constructor assignments
          for (var p in this.__dataHasAccessor) {
            if (this.hasOwnProperty(p)) {
              this.__dataInstanceProps = this.__dataInstanceProps || {};
              this.__dataInstanceProps[p] = this[p];
              delete this[p];
            }
          }
        }

        /**
         * Called at instance time with bag of properties that were overwritten
         * by accessors on the prototype when accessors were created.
         *
         * The default implementation sets these properties back into the
         * setter at instance time.  This method is provided as an override
         * point for customizing or providing more efficient initialization.
         *
         * @param {Object} props Bag of property values that were overwritten
         *   when creating property accessors.
         * @protected
         */

      }, {
        key: '_initializeProtoProperties',
        value: function _initializeProtoProperties(props) {
          for (var p in props) {
            this._setProperty(p, props[p]);
          }
        }

        /**
         * Called at ready time with bag of instance properties that overwrote
         * accessors when the element upgraded.
         *
         * The default implementation sets these properties back into the
         * setter at ready time.  This method is provided as an override
         * point for customizing or providing more efficient initialization.
         *
         * @param {Object} props Bag of property values that were overwritten
         *   when creating property accessors.
         * @protected
         */

      }, {
        key: '_initializeInstanceProperties',
        value: function _initializeInstanceProperties(props) {
          Object.assign(this, props);
        }

        /**
         * Ensures the element has the given attribute. If it does not,
         * assigns the given value to the attribute.
         *
         *
         * @param {string} attribute Name of attribute to ensure is set.
         * @param {string} value of the attribute.
         */

      }, {
        key: '_ensureAttribute',
        value: function _ensureAttribute(attribute, value) {
          if (!this.hasAttribute(attribute)) {
            this._valueToNodeAttribute(this, value, attribute);
          }
        }

        /**
         * Deserializes an attribute to its associated property.
         *
         * This method calls the `_deserializeValue` method to convert the string to
         * a typed value.
         *
         * @param {string} attribute Name of attribute to deserialize.
         * @param {?string} value of the attribute.
         * @param {*=} type type to deserialize to.
         */

      }, {
        key: '_attributeToProperty',
        value: function _attributeToProperty(attribute, value, type) {
          // Don't deserialize back to property if currently reflecting
          if (!this.__serializing) {
            var property = caseMap.dashToCamelCase(attribute);
            this[property] = this._deserializeValue(value, type);
          }
        }

        /**
         * Serializes a property to its associated attribute.
         *
         * @param {string} property Property name to reflect.
         * @param {string=} attribute Attribute name to reflect.
         * @param {*=} value Property value to refect.
         */

      }, {
        key: '_propertyToAttribute',
        value: function _propertyToAttribute(property, attribute, value) {
          this.__serializing = true;
          value = arguments.length < 3 ? this[property] : value;
          this._valueToNodeAttribute(this, value, attribute || caseMap.camelToDashCase(property));
          this.__serializing = false;
        }

        /**
         * Sets a typed value to an HTML attribute on a node.
         *
         * This method calls the `_serializeValue` method to convert the typed
         * value to a string.  If the `_serializeValue` method returns `undefined`,
         * the attribute will be removed (this is the default for boolean
         * type `false`).
         *
         * @param {Element} node Element to set attribute to.
         * @param {*} value Value to serialize.
         * @param {string} attribute Attribute name to serialize to.
         */

      }, {
        key: '_valueToNodeAttribute',
        value: function _valueToNodeAttribute(node, value, attribute) {
          var str = this._serializeValue(value);
          if (str === undefined) {
            node.removeAttribute(attribute);
          } else {
            node.setAttribute(attribute, str);
          }
        }

        /**
         * Converts a typed JavaScript value to a string.
         *
         * This method is called by Polymer when setting JS property values to
         * HTML attributes.  Users may override this method on Polymer element
         * prototypes to provide serialization for custom types.
         *
         * @param {*} value Property value to serialize.
         * @return {string | undefined} String serialized from the provided property value.
         */

      }, {
        key: '_serializeValue',
        value: function _serializeValue(value) {
          /* eslint-disable no-fallthrough */
          switch (typeof value === 'undefined' ? 'undefined' : _typeof(value)) {
            case 'boolean':
              return value ? '' : undefined;

            case 'object':
              if (value instanceof Date) {
                return value.toString();
              } else if (value) {
                try {
                  return JSON.stringify(value);
                } catch (x) {
                  return '';
                }
              }

            default:
              return value != null ? value.toString() : undefined;
          }
        }

        /**
         * Converts a string to a typed JavaScript value.
         *
         * This method is called by Polymer when reading HTML attribute values to
         * JS properties.  Users may override this method on Polymer element
         * prototypes to provide deserialization for custom `type`s.  Note,
         * the `type` argument is the value of the `type` field provided in the
         * `properties` configuration object for a given property, and is
         * by convention the constructor for the type to deserialize.
         *
         * Note: The return value of `undefined` is used as a sentinel value to
         * indicate the attribute should be removed.
         *
         * @param {?string} value Attribute value to deserialize.
         * @param {*=} type Type to deserialize the string to.
         * @return {*} Typed value deserialized from the provided string.
         */

      }, {
        key: '_deserializeValue',
        value: function _deserializeValue(value, type) {
          /**
           * @type {*}
           */
          var outValue = void 0;
          switch (type) {
            case Number:
              outValue = Number(value);
              break;

            case Boolean:
              outValue = value !== null;
              break;

            case Object:
              try {
                outValue = JSON.parse( /** @type string */value);
              } catch (x) {
                // allow non-JSON literals like Strings and Numbers
              }
              break;

            case Array:
              try {
                outValue = JSON.parse( /** @type string */value);
              } catch (x) {
                outValue = null;
                console.warn('Polymer::Attributes: couldn\'t decode Array as JSON: ' + value);
              }
              break;

            case Date:
              outValue = new Date(value);
              break;

            case String:
            default:
              outValue = value;
              break;
          }

          return outValue;
        }
        /* eslint-enable no-fallthrough */

        /**
         * Creates a setter/getter pair for the named property with its own
         * local storage.  The getter returns the value in the local storage,
         * and the setter calls `_setProperty`, which updates the local storage
         * for the property and enqueues a `_propertiesChanged` callback.
         *
         * This method may be called on a prototype or an instance.  Calling
         * this method may overwrite a property value that already exists on
         * the prototype/instance by creating the accessor.  When calling on
         * a prototype, any overwritten values are saved in `__dataProto`,
         * and it is up to the subclasser to decide how/when to set those
         * properties back into the accessor.  When calling on an instance,
         * the overwritten value is set via `_setPendingProperty`, and the
         * user should call `_invalidateProperties` or `_flushProperties`
         * for the values to take effect.
         *
         * @param {string} property Name of the property
         * @param {boolean=} readOnly When true, no setter is created; the
         *   protected `_setProperty` function must be used to set the property
         * @protected
         */

      }, {
        key: '_createPropertyAccessor',
        value: function _createPropertyAccessor(property, readOnly) {
          if (!this.hasOwnProperty('__dataHasAccessor')) {
            this.__dataHasAccessor = Object.assign({}, this.__dataHasAccessor);
          }
          if (!this.__dataHasAccessor[property]) {
            this.__dataHasAccessor[property] = true;
            saveAccessorValue(this, property);
            Object.defineProperty(this, property, {
              /* eslint-disable valid-jsdoc */
              /** @this {PropertyAccessors} */
              get: function get() {
                return this.__data[property];
              },
              /** @this {PropertyAccessors} */
              set: readOnly ? function () {} : function (value) {
                this._setProperty(property, value);
              }
              /* eslint-enable */
            });
          }
        }

        /**
         * Returns true if this library created an accessor for the given property.
         *
         * @param {string} property Property name
         * @return {boolean} True if an accessor was created
         */

      }, {
        key: '_hasAccessor',
        value: function _hasAccessor(property) {
          return this.__dataHasAccessor && this.__dataHasAccessor[property];
        }

        /**
         * Updates the local storage for a property (via `_setPendingProperty`)
         * and enqueues a `_proeprtiesChanged` callback.
         *
         * @param {string} property Name of the property
         * @param {*} value Value to set
         * @protected
         */

      }, {
        key: '_setProperty',
        value: function _setProperty(property, value) {
          if (this._setPendingProperty(property, value)) {
            this._invalidateProperties();
          }
        }

        /**
         * Updates the local storage for a property, records the previous value,
         * and adds it to the set of "pending changes" that will be passed to the
         * `_propertiesChanged` callback.  This method does not enqueue the
         * `_propertiesChanged` callback.
         *
         * @param {string} property Name of the property
         * @param {*} value Value to set
         * @return {boolean} Returns true if the property changed
         * @protected
         */

      }, {
        key: '_setPendingProperty',
        value: function _setPendingProperty(property, value) {
          var old = this.__data[property];
          var changed = this._shouldPropertyChange(property, value, old);
          if (changed) {
            if (!this.__dataPending) {
              this.__dataPending = {};
              this.__dataOld = {};
            }
            // Ensure old is captured from the last turn
            if (this.__dataOld && !(property in this.__dataOld)) {
              this.__dataOld[property] = old;
            }
            this.__data[property] = value;
            this.__dataPending[property] = value;
          }
          return changed;
        }

        /**
         * Returns true if the specified property has a pending change.
         *
         * @param {string} prop Property name
         * @return {boolean} True if property has a pending change
         * @protected
         */

      }, {
        key: '_isPropertyPending',
        value: function _isPropertyPending(prop) {
          return Boolean(this.__dataPending && prop in this.__dataPending);
        }

        /**
         * Marks the properties as invalid, and enqueues an async
         * `_propertiesChanged` callback.
         *
         * @protected
         */

      }, {
        key: '_invalidateProperties',
        value: function _invalidateProperties() {
          var _this2 = this;

          if (!this.__dataInvalid && this.__dataReady) {
            this.__dataInvalid = true;
            microtask.run(function () {
              if (_this2.__dataInvalid) {
                _this2.__dataInvalid = false;
                _this2._flushProperties();
              }
            });
          }
        }

        /**
         * Call to enable property accessor processing. Before this method is
         * called accessor values will be set but side effects are
         * queued. When called, any pending side effects occur immediately.
         * For elements, generally `connectedCallback` is a normal spot to do so.
         * It is safe to call this method multiple times as it only turns on
         * property accessors once.
         */

      }, {
        key: '_enableProperties',
        value: function _enableProperties() {
          if (!this.__dataEnabled) {
            this.__dataEnabled = true;
            if (this.__dataInstanceProps) {
              this._initializeInstanceProperties(this.__dataInstanceProps);
              this.__dataInstanceProps = null;
            }
            this.ready();
          }
        }

        /**
         * Calls the `_propertiesChanged` callback with the current set of
         * pending changes (and old values recorded when pending changes were
         * set), and resets the pending set of changes. Generally, this method
         * should not be called in user code.
         *
         *
         * @protected
         */

      }, {
        key: '_flushProperties',
        value: function _flushProperties() {
          if (this.__dataPending && this.__dataOld) {
            var changedProps = this.__dataPending;
            this.__dataPending = null;
            this.__dataCounter++;
            this._propertiesChanged(this.__data, changedProps, this.__dataOld);
            this.__dataCounter--;
          }
        }

        /**
         * Lifecycle callback called the first time properties are being flushed.
         * Prior to `ready`, all property sets through accessors are queued and
         * their effects are flushed after this method returns.
         *
         * Users may override this function to implement behavior that is
         * dependent on the element having its properties initialized, e.g.
         * from defaults (initialized from `constructor`, `_initializeProperties`),
         * `attributeChangedCallback`, or values propagated from host e.g. via
         * bindings.  `super.ready()` must be called to ensure the data system
         * becomes enabled.
         *
         * @public
         */

      }, {
        key: 'ready',
        value: function ready() {
          this.__dataReady = true;
          // Run normal flush
          this._flushProperties();
        }

        /**
         * Callback called when any properties with accessors created via
         * `_createPropertyAccessor` have been set.
         *
         * @param {!Object} currentProps Bag of all current accessor values
         * @param {!Object} changedProps Bag of properties changed since the last
         *   call to `_propertiesChanged`
         * @param {!Object} oldProps Bag of previous values for each property
         *   in `changedProps`
         * @protected
         */

      }, {
        key: '_propertiesChanged',
        value: function _propertiesChanged(currentProps, changedProps, oldProps) {} // eslint-disable-line no-unused-vars


        /**
         * Method called to determine whether a property value should be
         * considered as a change and cause the `_propertiesChanged` callback
         * to be enqueued.
         *
         * The default implementation returns `true` for primitive types if a
         * strict equality check fails, and returns `true` for all Object/Arrays.
         * The method always returns false for `NaN`.
         *
         * Override this method to e.g. provide stricter checking for
         * Objects/Arrays when using immutable patterns.
         *
         * @param {string} property Property name
         * @param {*} value New property value
         * @param {*} old Previous property value
         * @return {boolean} Whether the property should be considered a change
         *   and enqueue a `_proeprtiesChanged` callback
         * @protected
         */

      }, {
        key: '_shouldPropertyChange',
        value: function _shouldPropertyChange(property, value, old) {
          return (
            // Strict equality check
            old !== value && (
            // This ensures (old==NaN, value==NaN) always returns false
            old === old || value === value)
          );
        }
      }]);

      return PropertyAccessors;
    }(superClass);

    return PropertyAccessors;
  });
})();

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

__webpack_require__(1);

__webpack_require__(3);

(function () {

  'use strict';

  // 1.x backwards-compatible auto-wrapper for template type extensions
  // This is a clear layering violation and gives favored-nation status to
  // dom-if and dom-repeat templates.  This is a conceit we're choosing to keep
  // a.) to ease 1.x backwards-compatibility due to loss of `is`, and
  // b.) to maintain if/repeat capability in parser-constrained elements
  //     (e.g. table, select) in lieu of native CE type extensions without
  //     massive new invention in this space (e.g. directive system)

  var templateExtensions = {
    'dom-if': true,
    'dom-repeat': true
  };
  function wrapTemplateExtension(node) {
    var is = node.getAttribute('is');
    if (is && templateExtensions[is]) {
      var t = node;
      t.removeAttribute('is');
      node = t.ownerDocument.createElement(is);
      t.parentNode.replaceChild(node, t);
      node.appendChild(t);
      while (t.attributes.length) {
        node.setAttribute(t.attributes[0].name, t.attributes[0].value);
        t.removeAttribute(t.attributes[0].name);
      }
    }
    return node;
  }

  function findTemplateNode(root, nodeInfo) {
    // recursively ascend tree until we hit root
    var parent = nodeInfo.parentInfo && findTemplateNode(root, nodeInfo.parentInfo);
    // unwind the stack, returning the indexed node at each level
    if (parent) {
      // note: marginally faster than indexing via childNodes
      // (http://jsperf.com/childnodes-lookup)
      for (var n = parent.firstChild, i = 0; n; n = n.nextSibling) {
        if (nodeInfo.parentIndex === i++) {
          return n;
        }
      }
    } else {
      return root;
    }
  }

  // construct `$` map (from id annotations)
  function applyIdToMap(inst, map, node, nodeInfo) {
    if (nodeInfo.id) {
      map[nodeInfo.id] = node;
    }
  }

  // install event listeners (from event annotations)
  function applyEventListener(inst, node, nodeInfo) {
    if (nodeInfo.events && nodeInfo.events.length) {
      for (var j = 0, e$ = nodeInfo.events, e; j < e$.length && (e = e$[j]); j++) {
        inst._addMethodEventListenerToNode(node, e.name, e.value, inst);
      }
    }
  }

  // push configuration references at configure time
  function applyTemplateContent(inst, node, nodeInfo) {
    if (nodeInfo.templateInfo) {
      node._templateInfo = nodeInfo.templateInfo;
    }
  }

  function createNodeEventHandler(context, eventName, methodName) {
    // Instances can optionally have a _methodHost which allows redirecting where
    // to find methods. Currently used by `templatize`.
    context = context._methodHost || context;
    var handler = function handler(e) {
      if (context[methodName]) {
        context[methodName](e, e.detail);
      } else {
        console.warn('listener method `' + methodName + '` not defined');
      }
    };
    return handler;
  }

  /**
   * Element mixin that provides basic template parsing and stamping, including
   * the following template-related features for stamped templates:
   *
   * - Declarative event listeners (`on-eventname="listener"`)
   * - Map of node id's to stamped node instances (`this.$.id`)
   * - Nested template content caching/removal and re-installation (performance
   *   optimization)
   *
   * @mixinFunction
   * @polymer
   * @memberof Polymer
   * @summary Element class mixin that provides basic template parsing and stamping
   */
  Polymer.TemplateStamp = Polymer.dedupingMixin(function (superClass) {

    /**
     * @polymer
     * @mixinClass
     * @implements {Polymer_TemplateStamp}
     */
    var TemplateStamp = function (_superClass) {
      _inherits(TemplateStamp, _superClass);

      function TemplateStamp() {
        _classCallCheck(this, TemplateStamp);

        return _possibleConstructorReturn(this, (TemplateStamp.__proto__ || Object.getPrototypeOf(TemplateStamp)).apply(this, arguments));
      }

      _createClass(TemplateStamp, [{
        key: '_stampTemplate',


        /**
         * Clones the provided template content and returns a document fragment
         * containing the cloned dom.
         *
         * The template is parsed (once and memoized) using this library's
         * template parsing features, and provides the following value-added
         * features:
         * * Adds declarative event listeners for `on-event="handler"` attributes
         * * Generates an "id map" for all nodes with id's under `$` on returned
         *   document fragment
         * * Passes template info including `content` back to templates as
         *   `_templateInfo` (a performance optimization to avoid deep template
         *   cloning)
         *
         * Note that the memoized template parsing process is destructive to the
         * template: attributes for bindings and declarative event listeners are
         * removed after being noted in notes, and any nested `<template>.content`
         * is removed and stored in notes as well.
         *
         * @param {!HTMLTemplateElement} template Template to stamp
         * @return {!StampedTemplate} Cloned template content
         */
        value: function _stampTemplate(template) {
          // Polyfill support: bootstrap the template if it has not already been
          if (template && !template.content && window.HTMLTemplateElement && HTMLTemplateElement.decorate) {
            HTMLTemplateElement.decorate(template);
          }
          var templateInfo = this.constructor._parseTemplate(template);
          var nodeInfo = templateInfo.nodeInfoList;
          var content = templateInfo.content || template.content;
          var dom = /** @type DocumentFragment */document.importNode(content, true);
          // NOTE: ShadyDom optimization indicating there is an insertion point
          dom.__noInsertionPoint = !templateInfo.hasInsertionPoint;
          var nodes = dom.nodeList = new Array(nodeInfo.length);
          dom.$ = {};
          for (var i = 0, l = nodeInfo.length, info; i < l && (info = nodeInfo[i]); i++) {
            var node = nodes[i] = findTemplateNode(dom, info);
            applyIdToMap(this, dom.$, node, info);
            applyTemplateContent(this, node, info);
            applyEventListener(this, node, info);
          }
          return (/** @type {!StampedTemplate} */dom
          );
        }

        /**
         * Adds an event listener by method name for the event provided.
         *
         * This method generates a handler function that looks up the method
         * name at handling time.
         *
         * @param {Node} node Node to add listener on
         * @param {string} eventName Name of event
         * @param {string} methodName Name of method
         * @param {*=} context Context the method will be called on (defaults
         *   to `node`)
         * @return {Function} Generated handler function
         */

      }, {
        key: '_addMethodEventListenerToNode',
        value: function _addMethodEventListenerToNode(node, eventName, methodName, context) {
          context = context || node;
          var handler = createNodeEventHandler(context, eventName, methodName);
          this._addEventListenerToNode(node, eventName, handler);
          return handler;
        }

        /**
         * Override point for adding custom or simulated event handling.
         *
         * @param {Node} node Node to add event listener to
         * @param {string} eventName Name of event
         * @param {Function} handler Listener function to add
         */

      }, {
        key: '_addEventListenerToNode',
        value: function _addEventListenerToNode(node, eventName, handler) {
          node.addEventListener(eventName, handler);
        }

        /**
         * Override point for adding custom or simulated event handling.
         *
         * @param {Node} node Node to remove event listener from
         * @param {string} eventName Name of event
         * @param {Function} handler Listener function to remove
         */

      }, {
        key: '_removeEventListenerFromNode',
        value: function _removeEventListenerFromNode(node, eventName, handler) {
          node.removeEventListener(eventName, handler);
        }
      }], [{
        key: '_parseTemplate',


        /**
         * Scans a template to produce template metadata.
         *
         * Template-specific metadata are stored in the object returned, and node-
         * specific metadata are stored in objects in its flattened `nodeInfoList`
         * array.  Only nodes in the template that were parsed as nodes of
         * interest contain an object in `nodeInfoList`.  Each `nodeInfo` object
         * contains an `index` (`childNodes` index in parent) and optionally
         * `parent`, which points to node info of its parent (including its index).
         *
         * The template metadata object returned from this method has the following
         * structure (many fields optional):
         *
         * ```js
         *   {
         *     // Flattened list of node metadata (for nodes that generated metadata)
         *     nodeInfoList: [
         *       {
         *         // `id` attribute for any nodes with id's for generating `$` map
         *         id: {string},
         *         // `on-event="handler"` metadata
         *         events: [
         *           {
         *             name: {string},   // event name
         *             value: {string},  // handler method name
         *           }, ...
         *         ],
         *         // Notes when the template contained a `<slot>` for shady DOM
         *         // optimization purposes
         *         hasInsertionPoint: {boolean},
         *         // For nested `<template>`` nodes, nested template metadata
         *         templateInfo: {object}, // nested template metadata
         *         // Metadata to allow efficient retrieval of instanced node
         *         // corresponding to this metadata
         *         parentInfo: {number},   // reference to parent nodeInfo>
         *         parentIndex: {number},  // index in parent's `childNodes` collection
         *         infoIndex: {number},    // index of this `nodeInfo` in `templateInfo.nodeInfoList`
         *       },
         *       ...
         *     ],
         *     // When true, the template had the `strip-whitespace` attribute
         *     // or was nested in a template with that setting
         *     stripWhitespace: {boolean},
         *     // For nested templates, nested template content is moved into
         *     // a document fragment stored here; this is an optimization to
         *     // avoid the cost of nested template cloning
         *     content: {DocumentFragment}
         *   }
         * ```
         *
         * This method kicks off a recursive treewalk as follows:
         *
         * ```
         *    _parseTemplate <---------------------+
         *      _parseTemplateContent              |
         *        _parseTemplateNode  <------------|--+
         *          _parseTemplateNestedTemplate --+  |
         *          _parseTemplateChildNodes ---------+
         *          _parseTemplateNodeAttributes
         *            _parseTemplateNodeAttribute
         *
         * ```
         *
         * These methods may be overridden to add custom metadata about templates
         * to either `templateInfo` or `nodeInfo`.
         *
         * Note that this method may be destructive to the template, in that
         * e.g. event annotations may be removed after being noted in the
         * template metadata.
         *
         * @param {!HTMLTemplateElement} template Template to parse
         * @param {TemplateInfo=} outerTemplateInfo Template metadata from the outer
         *   template, for parsing nested templates
         * @return {!TemplateInfo} Parsed template metadata
         */
        value: function _parseTemplate(template, outerTemplateInfo) {
          // since a template may be re-used, memo-ize metadata
          if (!template._templateInfo) {
            var templateInfo = template._templateInfo = {};
            templateInfo.nodeInfoList = [];
            templateInfo.stripWhiteSpace = outerTemplateInfo && outerTemplateInfo.stripWhiteSpace || template.hasAttribute('strip-whitespace');
            this._parseTemplateContent(template, templateInfo, { parent: null });
          }
          return template._templateInfo;
        }
      }, {
        key: '_parseTemplateContent',
        value: function _parseTemplateContent(template, templateInfo, nodeInfo) {
          return this._parseTemplateNode(template.content, templateInfo, nodeInfo);
        }

        /**
         * Parses template node and adds template and node metadata based on
         * the current node, and its `childNodes` and `attributes`.
         *
         * This method may be overridden to add custom node or template specific
         * metadata based on this node.
         *
         * @param {Node} node Node to parse
         * @param {!TemplateInfo} templateInfo Template metadata for current template
         * @param {!NodeInfo} nodeInfo Node metadata for current template.
         * @return {boolean} `true` if the visited node added node-specific
         *   metadata to `nodeInfo`
         */

      }, {
        key: '_parseTemplateNode',
        value: function _parseTemplateNode(node, templateInfo, nodeInfo) {
          var noted = void 0;
          var element = /** @type Element */node;
          if (element.localName == 'template' && !element.hasAttribute('preserve-content')) {
            noted = this._parseTemplateNestedTemplate(element, templateInfo, nodeInfo) || noted;
          } else if (element.localName === 'slot') {
            // For ShadyDom optimization, indicating there is an insertion point
            templateInfo.hasInsertionPoint = true;
          }
          if (element.firstChild) {
            noted = this._parseTemplateChildNodes(element, templateInfo, nodeInfo) || noted;
          }
          if (element.hasAttributes && element.hasAttributes()) {
            noted = this._parseTemplateNodeAttributes(element, templateInfo, nodeInfo) || noted;
          }
          return noted;
        }

        /**
         * Parses template child nodes for the given root node.
         *
         * This method also wraps whitelisted legacy template extensions
         * (`is="dom-if"` and `is="dom-repeat"`) with their equivalent element
         * wrappers, collapses text nodes, and strips whitespace from the template
         * if the `templateInfo.stripWhitespace` setting was provided.
         *
         * @param {Node} root Root node whose `childNodes` will be parsed
         * @param {!TemplateInfo} templateInfo Template metadata for current template
         * @param {!NodeInfo} nodeInfo Node metadata for current template.
         */

      }, {
        key: '_parseTemplateChildNodes',
        value: function _parseTemplateChildNodes(root, templateInfo, nodeInfo) {
          for (var node = root.firstChild, parentIndex = 0, next; node; node = next) {
            // Wrap templates
            if (node.localName == 'template') {
              node = wrapTemplateExtension(node);
            }
            // collapse adjacent textNodes: fixes an IE issue that can cause
            // text nodes to be inexplicably split =(
            // note that root.normalize() should work but does not so we do this
            // manually.
            next = node.nextSibling;
            if (node.nodeType === Node.TEXT_NODE) {
              var /** Node */n = next;
              while (n && n.nodeType === Node.TEXT_NODE) {
                node.textContent += n.textContent;
                next = n.nextSibling;
                root.removeChild(n);
                n = next;
              }
              // optionally strip whitespace
              if (templateInfo.stripWhiteSpace && !node.textContent.trim()) {
                root.removeChild(node);
                continue;
              }
            }
            var childInfo = { parentIndex: parentIndex, parentInfo: nodeInfo };
            if (this._parseTemplateNode(node, templateInfo, childInfo)) {
              childInfo.infoIndex = templateInfo.nodeInfoList.push( /** @type {!NodeInfo} */childInfo) - 1;
            }
            // Increment if not removed
            if (node.parentNode) {
              parentIndex++;
            }
          }
        }

        /**
         * Parses template content for the given nested `<template>`.
         *
         * Nested template info is stored as `templateInfo` in the current node's
         * `nodeInfo`. `template.content` is removed and stored in `templateInfo`.
         * It will then be the responsibility of the host to set it back to the
         * template and for users stamping nested templates to use the
         * `_contentForTemplate` method to retrieve the content for this template
         * (an optimization to avoid the cost of cloning nested template content).
         *
         * @param {HTMLTemplateElement} node Node to parse (a <template>)
         * @param {TemplateInfo} outerTemplateInfo Template metadata for current template
         *   that includes the template `node`
         * @param {!NodeInfo} nodeInfo Node metadata for current template.
         * @return {boolean} `true` if the visited node added node-specific
         *   metadata to `nodeInfo`
         */

      }, {
        key: '_parseTemplateNestedTemplate',
        value: function _parseTemplateNestedTemplate(node, outerTemplateInfo, nodeInfo) {
          var templateInfo = this._parseTemplate(node, outerTemplateInfo);
          var content = templateInfo.content = node.content.ownerDocument.createDocumentFragment();
          content.appendChild(node.content);
          nodeInfo.templateInfo = templateInfo;
          return true;
        }

        /**
         * Parses template node attributes and adds node metadata to `nodeInfo`
         * for nodes of interest.
         *
         * @param {Element} node Node to parse
         * @param {TemplateInfo} templateInfo Template metadata for current template
         * @param {NodeInfo} nodeInfo Node metadata for current template.
         * @return {boolean} `true` if the visited node added node-specific
         *   metadata to `nodeInfo`
         */

      }, {
        key: '_parseTemplateNodeAttributes',
        value: function _parseTemplateNodeAttributes(node, templateInfo, nodeInfo) {
          // Make copy of original attribute list, since the order may change
          // as attributes are added and removed
          var noted = false;
          var attrs = Array.from(node.attributes);
          for (var i = attrs.length - 1, a; a = attrs[i]; i--) {
            noted = this._parseTemplateNodeAttribute(node, templateInfo, nodeInfo, a.name, a.value) || noted;
          }
          return noted;
        }

        /**
         * Parses a single template node attribute and adds node metadata to
         * `nodeInfo` for attributes of interest.
         *
         * This implementation adds metadata for `on-event="handler"` attributes
         * and `id` attributes.
         *
         * @param {Element} node Node to parse
         * @param {!TemplateInfo} templateInfo Template metadata for current template
         * @param {!NodeInfo} nodeInfo Node metadata for current template.
         * @param {string} name Attribute name
         * @param {string} value Attribute value
         * @return {boolean} `true` if the visited node added node-specific
         *   metadata to `nodeInfo`
         */

      }, {
        key: '_parseTemplateNodeAttribute',
        value: function _parseTemplateNodeAttribute(node, templateInfo, nodeInfo, name, value) {
          // events (on-*)
          if (name.slice(0, 3) === 'on-') {
            node.removeAttribute(name);
            nodeInfo.events = nodeInfo.events || [];
            nodeInfo.events.push({
              name: name.slice(3),
              value: value
            });
            return true;
          }
          // static id
          else if (name === 'id') {
              nodeInfo.id = value;
              return true;
            }
          return false;
        }

        /**
         * Returns the `content` document fragment for a given template.
         *
         * For nested templates, Polymer performs an optimization to cache nested
         * template content to avoid the cost of cloning deeply nested templates.
         * This method retrieves the cached content for a given template.
         *
         * @param {HTMLTemplateElement} template Template to retrieve `content` for
         * @return {DocumentFragment} Content fragment
         */

      }, {
        key: '_contentForTemplate',
        value: function _contentForTemplate(template) {
          var templateInfo = /** @type {HTMLTemplateElementWithInfo} */template._templateInfo;
          return templateInfo && templateInfo.content || template.content;
        }
      }]);

      return TemplateStamp;
    }(superClass);

    return TemplateStamp;
  });
})();

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

__webpack_require__(5);

var RegisterHtmlTemplate = __webpack_require__(2);

RegisterHtmlTemplate.register("<dom-module id=app-drawer> <template> <style>:host{position:fixed;top:-120px;right:0;bottom:-120px;left:0;visibility:hidden;transition-property:visibility}:host([opened]){visibility:visible}:host([persistent]){width:var(--app-drawer-width,256px)}:host([persistent][position=left]){right:auto}:host([persistent][position=right]){left:auto}#contentContainer{position:absolute;top:0;bottom:0;left:0;width:var(--app-drawer-width,256px);padding:120px 0;transition-property:-webkit-transform;transition-property:transform;-webkit-transform:translate3d(-100%,0,0);transform:translate3d(-100%,0,0);background-color:#fff;@apply --app-drawer-content-container;}#contentContainer[persistent]{width:100%}#contentContainer[position=right]{right:0;left:auto;-webkit-transform:translate3d(100%,0,0);transform:translate3d(100%,0,0)}#contentContainer[swipe-open]::after{position:fixed;top:0;bottom:0;left:100%;visibility:visible;width:20px;content:''}#contentContainer[swipe-open][position=right]::after{right:100%;left:auto}#contentContainer[opened]{-webkit-transform:translate3d(0,0,0);transform:translate3d(0,0,0)}#scrim{position:absolute;top:0;right:0;bottom:0;left:0;transition-property:opacity;-webkit-transform:translateZ(0);transform:translateZ(0);opacity:0;background:var(--app-drawer-scrim-background,rgba(0,0,0,.5))}#scrim.visible{opacity:1}:host([no-transition]) #contentContainer{transition-property:none}</style> <div id=scrim on-click=close></div> <div id=contentContainer opened$=[[opened]] persistent$=[[persistent]] position$=[[position]] swipe-open$=[[swipeOpen]]> <slot></slot> </div> </template> </dom-module>");

Polymer({
  is: 'app-drawer',

  properties: {
    /**
     * The opened state of the drawer.
     */
    opened: {
      type: Boolean,
      value: false,
      notify: true,
      reflectToAttribute: true
    },

    /**
     * The drawer does not have a scrim and cannot be swiped close.
     */
    persistent: {
      type: Boolean,
      value: false,
      reflectToAttribute: true
    },

    /**
     * The transition duration of the drawer in milliseconds.
     */
    transitionDuration: {
      type: Number,
      value: 200
    },

    /**
     * The alignment of the drawer on the screen ('left', 'right', 'start' or 'end').
     * 'start' computes to left and 'end' to right in LTR layout and vice versa in RTL
     * layout.
     */
    align: {
      type: String,
      value: 'left'
    },

    /**
     * The computed, read-only position of the drawer on the screen ('left' or 'right').
     */
    position: {
      type: String,
      readOnly: true,
      reflectToAttribute: true
    },

    /**
     * Create an area at the edge of the screen to swipe open the drawer.
     */
    swipeOpen: {
      type: Boolean,
      value: false,
      reflectToAttribute: true
    },

    /**
     * Trap keyboard focus when the drawer is opened and not persistent.
     */
    noFocusTrap: {
      type: Boolean,
      value: false
    },

    /**
     * Disables swiping on the drawer.
     */
    disableSwipe: {
      type: Boolean,
      value: false
    }
  },

  observers: ['resetLayout(position, isAttached)', '_resetPosition(align, isAttached)', '_styleTransitionDuration(transitionDuration)', '_openedPersistentChanged(opened, persistent)'],

  _translateOffset: 0,

  _trackDetails: null,

  _drawerState: 0,

  _boundEscKeydownHandler: null,

  _firstTabStop: null,

  _lastTabStop: null,

  attached: function attached() {
    Polymer.RenderStatus.afterNextRender(this, function () {
      this._boundEscKeydownHandler = this._escKeydownHandler.bind(this);
      this.addEventListener('keydown', this._tabKeydownHandler.bind(this));

      // Only listen for horizontal track so you can vertically scroll inside the drawer.
      this.listen(this, 'track', '_track');
      this.setScrollDirection('y');
    });

    this.fire('app-reset-layout');
  },

  detached: function detached() {
    document.removeEventListener('keydown', this._boundEscKeydownHandler);
  },

  /**
   * Opens the drawer.
   */
  open: function open() {
    this.opened = true;
  },

  /**
   * Closes the drawer.
   */
  close: function close() {
    this.opened = false;
  },

  /**
   * Toggles the drawer open and close.
   */
  toggle: function toggle() {
    this.opened = !this.opened;
  },

  /**
   * Gets the width of the drawer.
   *
   * @return {number} The width of the drawer in pixels.
   */
  getWidth: function getWidth() {
    return this._savedWidth || this.$.contentContainer.offsetWidth;
  },

  _isRTL: function _isRTL() {
    return window.getComputedStyle(this).direction === 'rtl';
  },

  _resetPosition: function _resetPosition() {
    switch (this.align) {
      case 'start':
        this._setPosition(this._isRTL() ? 'right' : 'left');
        return;
      case 'end':
        this._setPosition(this._isRTL() ? 'left' : 'right');
        return;
    }
    this._setPosition(this.align);
  },

  _escKeydownHandler: function _escKeydownHandler(event) {
    var ESC_KEYCODE = 27;
    if (event.keyCode === ESC_KEYCODE) {
      // Prevent any side effects if app-drawer closes.
      event.preventDefault();
      this.close();
    }
  },

  _track: function _track(event) {
    if (this.persistent || this.disableSwipe) {
      return;
    }

    // Disable user selection on desktop.
    event.preventDefault();

    switch (event.detail.state) {
      case 'start':
        this._trackStart(event);
        break;
      case 'track':
        this._trackMove(event);
        break;
      case 'end':
        this._trackEnd(event);
        break;
    }
  },

  _trackStart: function _trackStart(event) {
    this._drawerState = this._DRAWER_STATE.TRACKING;

    var rect = this.$.contentContainer.getBoundingClientRect();
    this._savedWidth = rect.width;
    if (this.position === 'left') {
      this._translateOffset = rect.left;
    } else {
      this._translateOffset = rect.right - window.innerWidth;
    }

    this._trackDetails = [];

    // Disable transitions since style attributes will reflect user track events.
    this._styleTransitionDuration(0);
    this.style.visibility = 'visible';
  },

  _trackMove: function _trackMove(event) {
    this._translateDrawer(event.detail.dx + this._translateOffset);

    // Use Date.now() since event.timeStamp is inconsistent across browsers (e.g. most
    // browsers use milliseconds but FF 44 uses microseconds).
    this._trackDetails.push({
      dx: event.detail.dx,
      timeStamp: Date.now()
    });
  },

  _trackEnd: function _trackEnd(event) {
    var x = event.detail.dx + this._translateOffset;
    var drawerWidth = this.getWidth();
    var isPositionLeft = this.position === 'left';
    var isInEndState = isPositionLeft ? x >= 0 || x <= -drawerWidth : x <= 0 || x >= drawerWidth;

    if (!isInEndState) {
      // No longer need the track events after this method returns - allow them to be GC'd.
      var trackDetails = this._trackDetails;
      this._trackDetails = null;

      this._flingDrawer(event, trackDetails);
      if (this._drawerState === this._DRAWER_STATE.FLINGING) {
        return;
      }
    }

    // If the drawer is not flinging, toggle the opened state based on the position of
    // the drawer.
    var halfWidth = drawerWidth / 2;
    if (event.detail.dx < -halfWidth) {
      this.opened = this.position === 'right';
    } else if (event.detail.dx > halfWidth) {
      this.opened = this.position === 'left';
    }

    if (isInEndState) {
      this.debounce('_resetDrawerState', this._resetDrawerState);
    } else {
      this.debounce('_resetDrawerState', this._resetDrawerState, this.transitionDuration);
    }

    this._styleTransitionDuration(this.transitionDuration);
    this._resetDrawerTranslate();
    this.style.visibility = '';
  },

  _calculateVelocity: function _calculateVelocity(event, trackDetails) {
    // Find the oldest track event that is within 100ms using binary search.
    var now = Date.now();
    var timeLowerBound = now - 100;
    var trackDetail;
    var min = 0;
    var max = trackDetails.length - 1;

    while (min <= max) {
      // Floor of average of min and max.
      var mid = min + max >> 1;
      var d = trackDetails[mid];
      if (d.timeStamp >= timeLowerBound) {
        trackDetail = d;
        max = mid - 1;
      } else {
        min = mid + 1;
      }
    }

    if (trackDetail) {
      var dx = event.detail.dx - trackDetail.dx;
      var dt = now - trackDetail.timeStamp || 1;
      return dx / dt;
    }
    return 0;
  },

  _flingDrawer: function _flingDrawer(event, trackDetails) {
    var velocity = this._calculateVelocity(event, trackDetails);

    // Do not fling if velocity is not above a threshold.
    if (Math.abs(velocity) < this._MIN_FLING_THRESHOLD) {
      return;
    }

    this._drawerState = this._DRAWER_STATE.FLINGING;

    var x = event.detail.dx + this._translateOffset;
    var drawerWidth = this.getWidth();
    var isPositionLeft = this.position === 'left';
    var isVelocityPositive = velocity > 0;
    var isClosingLeft = !isVelocityPositive && isPositionLeft;
    var isClosingRight = isVelocityPositive && !isPositionLeft;
    var dx;
    if (isClosingLeft) {
      dx = -(x + drawerWidth);
    } else if (isClosingRight) {
      dx = drawerWidth - x;
    } else {
      dx = -x;
    }

    // Enforce a minimum transition velocity to make the drawer feel snappy.
    if (isVelocityPositive) {
      velocity = Math.max(velocity, this._MIN_TRANSITION_VELOCITY);
      this.opened = this.position === 'left';
    } else {
      velocity = Math.min(velocity, -this._MIN_TRANSITION_VELOCITY);
      this.opened = this.position === 'right';
    }

    // Calculate the amount of time needed to finish the transition based on the
    // initial slope of the timing function.
    var t = this._FLING_INITIAL_SLOPE * dx / velocity;
    this._styleTransitionDuration(t);
    this._styleTransitionTimingFunction(this._FLING_TIMING_FUNCTION);

    this._resetDrawerTranslate();
    this.debounce('_resetDrawerState', this._resetDrawerState, t);
  },

  _styleTransitionDuration: function _styleTransitionDuration(duration) {
    this.style.transitionDuration = duration + 'ms';
    this.$.contentContainer.style.transitionDuration = duration + 'ms';
    this.$.scrim.style.transitionDuration = duration + 'ms';
  },

  _styleTransitionTimingFunction: function _styleTransitionTimingFunction(timingFunction) {
    this.$.contentContainer.style.transitionTimingFunction = timingFunction;
    this.$.scrim.style.transitionTimingFunction = timingFunction;
  },

  _translateDrawer: function _translateDrawer(x) {
    var drawerWidth = this.getWidth();

    if (this.position === 'left') {
      x = Math.max(-drawerWidth, Math.min(x, 0));
      this.$.scrim.style.opacity = 1 + x / drawerWidth;
    } else {
      x = Math.max(0, Math.min(x, drawerWidth));
      this.$.scrim.style.opacity = 1 - x / drawerWidth;
    }

    this.translate3d(x + 'px', '0', '0', this.$.contentContainer);
  },

  _resetDrawerTranslate: function _resetDrawerTranslate() {
    this.$.scrim.style.opacity = '';
    this.transform('', this.$.contentContainer);
  },

  _resetDrawerState: function _resetDrawerState() {
    var oldState = this._drawerState;

    // If the drawer was flinging, we need to reset the style attributes.
    if (oldState === this._DRAWER_STATE.FLINGING) {
      this._styleTransitionDuration(this.transitionDuration);
      this._styleTransitionTimingFunction('');
      this.style.visibility = '';
    }

    this._savedWidth = null;

    if (this.opened) {
      this._drawerState = this.persistent ? this._DRAWER_STATE.OPENED_PERSISTENT : this._DRAWER_STATE.OPENED;
    } else {
      this._drawerState = this._DRAWER_STATE.CLOSED;
    }

    if (oldState !== this._drawerState) {
      if (this._drawerState === this._DRAWER_STATE.OPENED) {
        this._setKeyboardFocusTrap();
        document.addEventListener('keydown', this._boundEscKeydownHandler);
        document.body.style.overflow = 'hidden';
      } else {
        document.removeEventListener('keydown', this._boundEscKeydownHandler);
        document.body.style.overflow = '';
      }

      // Don't fire the event on initial load.
      if (oldState !== this._DRAWER_STATE.INIT) {
        this.fire('app-drawer-transitioned');
      }
    }
  },

  /**
   * Resets the layout.
   *
   * @method resetLayout
   */
  resetLayout: function resetLayout() {
    this.fire('app-reset-layout');
  },

  _setKeyboardFocusTrap: function _setKeyboardFocusTrap() {
    if (this.noFocusTrap) {
      return;
    }

    // NOTE: Unless we use /deep/ (which we shouldn't since it's deprecated), this will
    // not select focusable elements inside shadow roots.
    var focusableElementsSelector = ['a[href]:not([tabindex="-1"])', 'area[href]:not([tabindex="-1"])', 'input:not([disabled]):not([tabindex="-1"])', 'select:not([disabled]):not([tabindex="-1"])', 'textarea:not([disabled]):not([tabindex="-1"])', 'button:not([disabled]):not([tabindex="-1"])', 'iframe:not([tabindex="-1"])', '[tabindex]:not([tabindex="-1"])', '[contentEditable=true]:not([tabindex="-1"])'].join(',');
    var focusableElements = Polymer.dom(this).querySelectorAll(focusableElementsSelector);

    if (focusableElements.length > 0) {
      this._firstTabStop = focusableElements[0];
      this._lastTabStop = focusableElements[focusableElements.length - 1];
    } else {
      // Reset saved tab stops when there are no focusable elements in the drawer.
      this._firstTabStop = null;
      this._lastTabStop = null;
    }

    // Focus on app-drawer if it has non-zero tabindex. Otherwise, focus the first focusable
    // element in the drawer, if it exists. Use the tabindex attribute since the this.tabIndex
    // property in IE/Edge returns 0 (instead of -1) when the attribute is not set.
    var tabindex = this.getAttribute('tabindex');
    if (tabindex && parseInt(tabindex, 10) > -1) {
      this.focus();
    } else if (this._firstTabStop) {
      this._firstTabStop.focus();
    }
  },

  _tabKeydownHandler: function _tabKeydownHandler(event) {
    if (this.noFocusTrap) {
      return;
    }

    var TAB_KEYCODE = 9;
    if (this._drawerState === this._DRAWER_STATE.OPENED && event.keyCode === TAB_KEYCODE) {
      if (event.shiftKey) {
        if (this._firstTabStop && Polymer.dom(event).localTarget === this._firstTabStop) {
          event.preventDefault();
          this._lastTabStop.focus();
        }
      } else {
        if (this._lastTabStop && Polymer.dom(event).localTarget === this._lastTabStop) {
          event.preventDefault();
          this._firstTabStop.focus();
        }
      }
    }
  },

  _openedPersistentChanged: function _openedPersistentChanged(opened, persistent) {
    this.toggleClass('visible', opened && !persistent, this.$.scrim);

    // Use a debounce timer instead of transitionend since transitionend won't fire when
    // app-drawer is display: none.
    this.debounce('_resetDrawerState', this._resetDrawerState, this.transitionDuration);
  },

  _MIN_FLING_THRESHOLD: 0.2,

  _MIN_TRANSITION_VELOCITY: 1.2,

  _FLING_TIMING_FUNCTION: 'cubic-bezier(0.667, 1, 0.667, 1)',

  _FLING_INITIAL_SLOPE: 1.5,

  _DRAWER_STATE: {
    INIT: 0,
    OPENED: 1,
    OPENED_PERSISTENT: 2,
    CLOSED: 3,
    TRACKING: 4,
    FLINGING: 5

    /**
     * Fired when the layout of app-drawer has changed.
     *
     * @event app-reset-layout
     */

    /**
     * Fired when app-drawer has finished transitioning.
     *
     * @event app-drawer-transitioned
     */
  } });

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(47);

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


(function () {
  /*
  Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
  This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
  The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
  The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
  Code distributed by Google as part of the polymer project is also
  subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
  */
  'use strict';
  var k = {};function n() {
    this.end = this.start = 0;this.rules = this.parent = this.previous = null;this.cssText = this.parsedCssText = "";this.atRule = !1;this.type = 0;this.parsedSelector = this.selector = this.keyframesName = "";
  }
  function p(a) {
    a = a.replace(aa, "").replace(ba, "");var b = q,
        c = a,
        d = new n();d.start = 0;d.end = c.length;for (var e = d, f = 0, h = c.length; f < h; f++) {
      if ("{" === c[f]) {
        e.rules || (e.rules = []);var g = e,
            m = g.rules[g.rules.length - 1] || null;e = new n();e.start = f + 1;e.parent = g;e.previous = m;g.rules.push(e);
      } else "}" === c[f] && (e.end = f + 1, e = e.parent || d);
    }return b(d, a);
  }
  function q(a, b) {
    var c = b.substring(a.start, a.end - 1);a.parsedCssText = a.cssText = c.trim();a.parent && (c = b.substring(a.previous ? a.previous.end : a.parent.start, a.start - 1), c = ca(c), c = c.replace(r, " "), c = c.substring(c.lastIndexOf(";") + 1), c = a.parsedSelector = a.selector = c.trim(), a.atRule = 0 === c.indexOf("@"), a.atRule ? 0 === c.indexOf("@media") ? a.type = t : c.match(da) && (a.type = u, a.keyframesName = a.selector.split(r).pop()) : a.type = 0 === c.indexOf("--") ? v : x);if (c = a.rules) for (var d = 0, e = c.length, f; d < e && (f = c[d]); d++) {
      q(f, b);
    }return a;
  }
  function ca(a) {
    return a.replace(/\\([0-9a-f]{1,6})\s/gi, function (a, c) {
      a = c;for (c = 6 - a.length; c--;) {
        a = "0" + a;
      }return "\\" + a;
    });
  }
  function y(a, b, c) {
    c = void 0 === c ? "" : c;var d = "";if (a.cssText || a.rules) {
      var e = a.rules,
          f;if (f = e) f = e[0], f = !(f && f.selector && 0 === f.selector.indexOf("--"));if (f) {
        f = 0;for (var h = e.length, g; f < h && (g = e[f]); f++) {
          d = y(g, b, d);
        }
      } else b ? b = a.cssText : (b = a.cssText, b = b.replace(ea, "").replace(fa, ""), b = b.replace(ha, "").replace(ia, "")), (d = b.trim()) && (d = "  " + d + "\n");
    }d && (a.selector && (c += a.selector + " {\n"), c += d, a.selector && (c += "}\n\n"));return c;
  }
  var x = 1,
      u = 7,
      t = 4,
      v = 1E3,
      aa = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//gim,
      ba = /@import[^;]*;/gim,
      ea = /(?:^[^;\-\s}]+)?--[^;{}]*?:[^{};]*?(?:[;\n]|$)/gim,
      fa = /(?:^[^;\-\s}]+)?--[^;{}]*?:[^{};]*?{[^}]*?}(?:[;\n]|$)?/gim,
      ha = /@apply\s*\(?[^);]*\)?\s*(?:[;\n]|$)?/gim,
      ia = /[^;:]*?:[^;]*?var\([^;]*\)(?:[;\n]|$)?/gim,
      da = /^@[^\s]*keyframes/,
      r = /\s+/g;var ja = Promise.resolve();function ka(a) {
    if (a = k[a]) a._applyShimCurrentVersion = a._applyShimCurrentVersion || 0, a._applyShimValidatingVersion = a._applyShimValidatingVersion || 0, a._applyShimNextVersion = (a._applyShimNextVersion || 0) + 1;
  }function z(a) {
    return a._applyShimCurrentVersion === a._applyShimNextVersion;
  }function la(a) {
    a._applyShimValidatingVersion = a._applyShimNextVersion;a.a || (a.a = !0, ja.then(function () {
      a._applyShimCurrentVersion = a._applyShimNextVersion;a.a = !1;
    }));
  };var A = !(window.ShadyDOM && window.ShadyDOM.inUse),
      B;function C(a) {
    B = a && a.shimcssproperties ? !1 : A || !(navigator.userAgent.match(/AppleWebKit\/601|Edge\/15/) || !window.CSS || !CSS.supports || !CSS.supports("box-shadow", "0 0 0 var(--foo)"));
  }window.ShadyCSS && void 0 !== window.ShadyCSS.nativeCss ? B = window.ShadyCSS.nativeCss : window.ShadyCSS ? (C(window.ShadyCSS), window.ShadyCSS = void 0) : C(window.WebComponents && window.WebComponents.flags);var E = B;var F = /(?:^|[;\s{]\s*)(--[\w-]*?)\s*:\s*(?:((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};{])+)|\{([^}]*)\}(?:(?=[;\s}])|$))/gi,
      G = /(?:^|\W+)@apply\s*\(?([^);\n]*)\)?/gi,
      ma = /@media\s(.*)/;function H(a) {
    if (!a) return "";"string" === typeof a && (a = p(a));return y(a, E);
  }function I(a) {
    !a.__cssRules && a.textContent && (a.__cssRules = p(a.textContent));return a.__cssRules || null;
  }function J(a, b, c, d) {
    if (a) {
      var e = !1,
          f = a.type;if (d && f === t) {
        var h = a.selector.match(ma);h && (window.matchMedia(h[1]).matches || (e = !0));
      }f === x ? b(a) : c && f === u ? c(a) : f === v && (e = !0);if ((a = a.rules) && !e) {
        e = 0;f = a.length;for (var g; e < f && (g = a[e]); e++) {
          J(g, b, c, d);
        }
      }
    }
  }
  function K(a, b) {
    var c = a.indexOf("var(");if (-1 === c) return b(a, "", "", "");a: {
      var d = 0;var e = c + 3;for (var f = a.length; e < f; e++) {
        if ("(" === a[e]) d++;else if (")" === a[e] && 0 === --d) break a;
      }e = -1;
    }d = a.substring(c + 4, e);c = a.substring(0, c);a = K(a.substring(e + 1), b);e = d.indexOf(",");return -1 === e ? b(c, d.trim(), "", a) : b(c, d.substring(0, e).trim(), d.substring(e + 1).trim(), a);
  };var na = /;\s*/m,
      oa = /^\s*(initial)|(inherit)\s*$/;function L() {
    this.a = {};
  }L.prototype.set = function (a, b) {
    a = a.trim();this.a[a] = { h: b, i: {} };
  };L.prototype.get = function (a) {
    a = a.trim();return this.a[a] || null;
  };var M = null;function N() {
    this.b = this.c = null;this.a = new L();
  }N.prototype.o = function (a) {
    a = G.test(a) || F.test(a);G.lastIndex = 0;F.lastIndex = 0;return a;
  };N.prototype.m = function (a, b) {
    a = a.content.querySelector("style");var c = null;a && (c = this.j(a, b));return c;
  };
  N.prototype.j = function (a, b) {
    b = void 0 === b ? "" : b;var c = I(a);this.l(c, b);a.textContent = H(c);return c;
  };N.prototype.f = function (a) {
    var b = this,
        c = I(a);J(c, function (a) {
      ":root" === a.selector && (a.selector = "html");b.g(a);
    });a.textContent = H(c);return c;
  };N.prototype.l = function (a, b) {
    var c = this;this.c = b;J(a, function (a) {
      c.g(a);
    });this.c = null;
  };N.prototype.g = function (a) {
    a.cssText = pa(this, a.parsedCssText);":root" === a.selector && (a.selector = ":host > *");
  };
  function pa(a, b) {
    b = b.replace(F, function (b, d, e, f) {
      return qa(a, b, d, e, f);
    });return O(a, b);
  }function O(a, b) {
    for (var c; c = G.exec(b);) {
      var d = c[0],
          e = c[1];c = c.index;var f = b.slice(0, c + d.indexOf("@apply"));b = b.slice(c + d.length);var h = P(a, f);d = void 0;var g = a;e = e.replace(na, "");var m = [];var l = g.a.get(e);l || (g.a.set(e, {}), l = g.a.get(e));if (l) for (d in g.c && (l.i[g.c] = !0), l.h) {
        g = h && h[d], l = [d, ": var(", e, "_-_", d], g && l.push(",", g), l.push(")"), m.push(l.join(""));
      }d = m.join("; ");b = "" + f + d + b;G.lastIndex = c + d.length;
    }return b;
  }
  function P(a, b) {
    b = b.split(";");for (var c, d, e = {}, f = 0, h; f < b.length; f++) {
      if (c = b[f]) if (h = c.split(":"), 1 < h.length) {
        c = h[0].trim();var g = a;d = c;h = h.slice(1).join(":");var m = oa.exec(h);m && (m[1] ? (g.b || (g.b = document.createElement("meta"), g.b.setAttribute("apply-shim-measure", ""), g.b.style.all = "initial", document.head.appendChild(g.b)), d = window.getComputedStyle(g.b).getPropertyValue(d)) : d = "apply-shim-inherit", h = d);d = h;e[c] = d;
      }
    }return e;
  }function ra(a, b) {
    if (M) for (var c in b.i) {
      c !== a.c && M(c);
    }
  }
  function qa(a, b, c, d, e) {
    d && K(d, function (b, c) {
      c && a.a.get(c) && (e = "@apply " + c + ";");
    });if (!e) return b;var f = O(a, e),
        h = b.slice(0, b.indexOf("--")),
        g = f = P(a, f),
        m = a.a.get(c),
        l = m && m.h;l ? g = Object.assign(Object.create(l), f) : a.a.set(c, g);var X = [],
        w,
        Y = !1;for (w in g) {
      var D = f[w];void 0 === D && (D = "initial");!l || w in l || (Y = !0);X.push("" + c + "_-_" + w + ": " + D);
    }Y && ra(a, m);m && (m.h = g);d && (h = b + ";" + h);return "" + h + X.join("; ") + ";";
  }N.prototype.detectMixin = N.prototype.o;N.prototype.transformStyle = N.prototype.j;
  N.prototype.transformCustomStyle = N.prototype.f;N.prototype.transformRules = N.prototype.l;N.prototype.transformRule = N.prototype.g;N.prototype.transformTemplate = N.prototype.m;N.prototype._separator = "_-_";Object.defineProperty(N.prototype, "invalidCallback", { get: function get() {
      return M;
    }, set: function set(a) {
      M = a;
    } });var Q = null,
      R = window.HTMLImports && window.HTMLImports.whenReady || null,
      S;function sa(a) {
    requestAnimationFrame(function () {
      R ? R(a) : (Q || (Q = new Promise(function (a) {
        S = a;
      }), "complete" === document.readyState ? S() : document.addEventListener("readystatechange", function () {
        "complete" === document.readyState && S();
      })), Q.then(function () {
        a && a();
      }));
    });
  };var T = new N();function U() {
    var a = this;this.a = null;sa(function () {
      V(a);
    });T.invalidCallback = ka;
  }function V(a) {
    a.a || (a.a = window.ShadyCSS.CustomStyleInterface, a.a && (a.a.transformCallback = function (a) {
      T.f(a);
    }, a.a.validateCallback = function () {
      requestAnimationFrame(function () {
        a.a.enqueued && W(a);
      });
    }));
  }U.prototype.prepareTemplate = function (a, b) {
    V(this);k[b] = a;b = T.m(a, b);a._styleAst = b;
  };
  function W(a) {
    V(a);if (a.a) {
      var b = a.a.processStyles();if (a.a.enqueued) {
        for (var c = 0; c < b.length; c++) {
          var d = a.a.getStyleForCustomStyle(b[c]);d && T.f(d);
        }a.a.enqueued = !1;
      }
    }
  }U.prototype.styleSubtree = function (a, b) {
    V(this);if (b) for (var c in b) {
      null === c ? a.style.removeProperty(c) : a.style.setProperty(c, b[c]);
    }if (a.shadowRoot) for (this.styleElement(a), a = a.shadowRoot.children || a.shadowRoot.childNodes, b = 0; b < a.length; b++) {
      this.styleSubtree(a[b]);
    } else for (a = a.children || a.childNodes, b = 0; b < a.length; b++) {
      this.styleSubtree(a[b]);
    }
  };
  U.prototype.styleElement = function (a) {
    V(this);var b = a.localName,
        c;b ? -1 < b.indexOf("-") ? c = b : c = a.getAttribute && a.getAttribute("is") || "" : c = a.is;if ((b = k[c]) && !z(b)) {
      if (z(b) || b._applyShimValidatingVersion !== b._applyShimNextVersion) this.prepareTemplate(b, c), la(b);if (a = a.shadowRoot) if (a = a.querySelector("style")) a.__cssRules = b._styleAst, a.textContent = H(b._styleAst);
    }
  };U.prototype.styleDocument = function (a) {
    V(this);this.styleSubtree(document.body, a);
  };
  if (!window.ShadyCSS || !window.ShadyCSS.ScopingShim) {
    var Z = new U(),
        ta = window.ShadyCSS && window.ShadyCSS.CustomStyleInterface;window.ShadyCSS = { prepareTemplate: function prepareTemplate(a, b) {
        W(Z);Z.prepareTemplate(a, b);
      }, styleSubtree: function styleSubtree(a, b) {
        W(Z);Z.styleSubtree(a, b);
      }, styleElement: function styleElement(a) {
        W(Z);Z.styleElement(a);
      }, styleDocument: function styleDocument(a) {
        W(Z);Z.styleDocument(a);
      }, getComputedStyleValue: function getComputedStyleValue(a, b) {
        return (a = window.getComputedStyle(a).getPropertyValue(b)) ? a.trim() : "";
      }, nativeCss: E, nativeShadow: A };ta && (window.ShadyCSS.CustomStyleInterface = ta);
  }window.ShadyCSS.ApplyShim = T;
}).call(undefined);

//# sourceMappingURL=apply-shim.min.js.map

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(1);

__webpack_require__(8);

__webpack_require__(12);

(function () {

  'use strict';

  // detect native touch action support

  var HAS_NATIVE_TA = typeof document.head.style.touchAction === 'string';
  var GESTURE_KEY = '__polymerGestures';
  var HANDLED_OBJ = '__polymerGesturesHandled';
  var TOUCH_ACTION = '__polymerGesturesTouchAction';
  // radius for tap and track
  var TAP_DISTANCE = 25;
  var TRACK_DISTANCE = 5;
  // number of last N track positions to keep
  var TRACK_LENGTH = 2;

  // Disabling "mouse" handlers for 2500ms is enough
  var MOUSE_TIMEOUT = 2500;
  var MOUSE_EVENTS = ['mousedown', 'mousemove', 'mouseup', 'click'];
  // an array of bitmask values for mapping MouseEvent.which to MouseEvent.buttons
  var MOUSE_WHICH_TO_BUTTONS = [0, 1, 4, 2];
  var MOUSE_HAS_BUTTONS = function () {
    try {
      return new MouseEvent('test', { buttons: 1 }).buttons === 1;
    } catch (e) {
      return false;
    }
  }();

  /* eslint no-empty: ["error", { "allowEmptyCatch": true }] */
  // check for passive event listeners
  var SUPPORTS_PASSIVE = false;
  (function () {
    try {
      var opts = Object.defineProperty({}, 'passive', { get: function get() {
          SUPPORTS_PASSIVE = true;
        } });
      window.addEventListener('test', null, opts);
      window.removeEventListener('test', null, opts);
    } catch (e) {}
  })();

  // Check for touch-only devices
  var IS_TOUCH_ONLY = navigator.userAgent.match(/iP(?:[oa]d|hone)|Android/);

  var GestureRecognizer = function GestureRecognizer() {}; // eslint-disable-line no-unused-vars
  GestureRecognizer.prototype.reset = function () {};
  /** @type {function(MouseEvent) | undefined} */
  GestureRecognizer.prototype.mousedown;
  /** @type {(function(MouseEvent) | undefined)} */
  GestureRecognizer.prototype.mousemove;
  /** @type {(function(MouseEvent) | undefined)} */
  GestureRecognizer.prototype.mouseup;
  /** @type {(function(TouchEvent) | undefined)} */
  GestureRecognizer.prototype.touchstart;
  /** @type {(function(TouchEvent) | undefined)} */
  GestureRecognizer.prototype.touchmove;
  /** @type {(function(TouchEvent) | undefined)} */
  GestureRecognizer.prototype.touchend;
  /** @type {(function(MouseEvent) | undefined)} */
  GestureRecognizer.prototype.click;

  // touch will make synthetic mouse events
  // `preventDefault` on touchend will cancel them,
  // but this breaks `<input>` focus and link clicks
  // disable mouse handlers for MOUSE_TIMEOUT ms after
  // a touchend to ignore synthetic mouse events
  var mouseCanceller = function mouseCanceller(mouseEvent) {
    // Check for sourceCapabilities, used to distinguish synthetic events
    // if mouseEvent did not come from a device that fires touch events,
    // it was made by a real mouse and should be counted
    // http://wicg.github.io/InputDeviceCapabilities/#dom-inputdevicecapabilities-firestouchevents
    var sc = mouseEvent.sourceCapabilities;
    if (sc && !sc.firesTouchEvents) {
      return;
    }
    // skip synthetic mouse events
    mouseEvent[HANDLED_OBJ] = { skip: true };
    // disable "ghost clicks"
    if (mouseEvent.type === 'click') {
      var path = mouseEvent.composedPath && mouseEvent.composedPath();
      if (path) {
        for (var i = 0; i < path.length; i++) {
          if (path[i] === POINTERSTATE.mouse.target) {
            return;
          }
        }
      }
      mouseEvent.preventDefault();
      mouseEvent.stopPropagation();
    }
  };

  /**
   * @param {boolean=} setup True to add, false to remove.
   */
  function setupTeardownMouseCanceller(setup) {
    var events = IS_TOUCH_ONLY ? ['click'] : MOUSE_EVENTS;
    for (var i = 0, en; i < events.length; i++) {
      en = events[i];
      if (setup) {
        document.addEventListener(en, mouseCanceller, true);
      } else {
        document.removeEventListener(en, mouseCanceller, true);
      }
    }
  }

  function ignoreMouse(e) {
    if (!POINTERSTATE.mouse.mouseIgnoreJob) {
      setupTeardownMouseCanceller(true);
    }
    var unset = function unset() {
      setupTeardownMouseCanceller();
      POINTERSTATE.mouse.target = null;
      POINTERSTATE.mouse.mouseIgnoreJob = null;
    };
    POINTERSTATE.mouse.target = e.composedPath()[0];
    POINTERSTATE.mouse.mouseIgnoreJob = Polymer.Debouncer.debounce(POINTERSTATE.mouse.mouseIgnoreJob, Polymer.Async.timeOut.after(MOUSE_TIMEOUT), unset);
  }

  /**
   * @param {MouseEvent} ev event to test for left mouse button down
   * @return {boolean} has left mouse button down
   */
  function hasLeftMouseButton(ev) {
    var type = ev.type;
    // exit early if the event is not a mouse event
    if (MOUSE_EVENTS.indexOf(type) === -1) {
      return false;
    }
    // ev.button is not reliable for mousemove (0 is overloaded as both left button and no buttons)
    // instead we use ev.buttons (bitmask of buttons) or fall back to ev.which (deprecated, 0 for no buttons, 1 for left button)
    if (type === 'mousemove') {
      // allow undefined for testing events
      var buttons = ev.buttons === undefined ? 1 : ev.buttons;
      if (ev instanceof window.MouseEvent && !MOUSE_HAS_BUTTONS) {
        buttons = MOUSE_WHICH_TO_BUTTONS[ev.which] || 0;
      }
      // buttons is a bitmask, check that the left button bit is set (1)
      return Boolean(buttons & 1);
    } else {
      // allow undefined for testing events
      var button = ev.button === undefined ? 0 : ev.button;
      // ev.button is 0 in mousedown/mouseup/click for left button activation
      return button === 0;
    }
  }

  function isSyntheticClick(ev) {
    if (ev.type === 'click') {
      // ev.detail is 0 for HTMLElement.click in most browsers
      if (ev.detail === 0) {
        return true;
      }
      // in the worst case, check that the x/y position of the click is within
      // the bounding box of the target of the event
      // Thanks IE 10 >:(
      var t = Gestures._findOriginalTarget(ev);
      // make sure the target of the event is an element so we can use getBoundingClientRect,
      // if not, just assume it is a synthetic click
      if (!t.nodeType || /** @type {Element} */t.nodeType !== Node.ELEMENT_NODE) {
        return true;
      }
      var bcr = /** @type {Element} */t.getBoundingClientRect();
      // use page x/y to account for scrolling
      var x = ev.pageX,
          y = ev.pageY;
      // ev is a synthetic click if the position is outside the bounding box of the target
      return !(x >= bcr.left && x <= bcr.right && y >= bcr.top && y <= bcr.bottom);
    }
    return false;
  }

  var POINTERSTATE = {
    mouse: {
      target: null,
      mouseIgnoreJob: null
    },
    touch: {
      x: 0,
      y: 0,
      id: -1,
      scrollDecided: false
    }
  };

  function firstTouchAction(ev) {
    var ta = 'auto';
    var path = ev.composedPath && ev.composedPath();
    if (path) {
      for (var i = 0, n; i < path.length; i++) {
        n = path[i];
        if (n[TOUCH_ACTION]) {
          ta = n[TOUCH_ACTION];
          break;
        }
      }
    }
    return ta;
  }

  function trackDocument(stateObj, movefn, upfn) {
    stateObj.movefn = movefn;
    stateObj.upfn = upfn;
    document.addEventListener('mousemove', movefn);
    document.addEventListener('mouseup', upfn);
  }

  function untrackDocument(stateObj) {
    document.removeEventListener('mousemove', stateObj.movefn);
    document.removeEventListener('mouseup', stateObj.upfn);
    stateObj.movefn = null;
    stateObj.upfn = null;
  }

  // use a document-wide touchend listener to start the ghost-click prevention mechanism
  // Use passive event listeners, if supported, to not affect scrolling performance
  document.addEventListener('touchend', ignoreMouse, SUPPORTS_PASSIVE ? { passive: true } : false);

  /**
   * Module for adding listeners to a node for the following normalized
   * cross-platform "gesture" events:
   * - `down` - mouse or touch went down
   * - `up` - mouse or touch went up
   * - `tap` - mouse click or finger tap
   * - `track` - mouse drag or touch move
   *
   * @namespace
   * @memberof Polymer
   * @summary Module for adding cross-platform gesture event listeners.
   */
  var Gestures = {
    gestures: {},
    recognizers: [],

    /**
     * Finds the element rendered on the screen at the provided coordinates.
     *
     * Similar to `document.elementFromPoint`, but pierces through
     * shadow roots.
     *
     * @memberof Polymer.Gestures
     * @param {number} x Horizontal pixel coordinate
     * @param {number} y Vertical pixel coordinate
     * @return {Element} Returns the deepest shadowRoot inclusive element
     * found at the screen position given.
     */
    deepTargetFind: function deepTargetFind(x, y) {
      var node = document.elementFromPoint(x, y);
      var next = node;
      // this code path is only taken when native ShadowDOM is used
      // if there is a shadowroot, it may have a node at x/y
      // if there is not a shadowroot, exit the loop
      while (next && next.shadowRoot && !window.ShadyDOM) {
        // if there is a node at x/y in the shadowroot, look deeper
        var oldNext = next;
        next = next.shadowRoot.elementFromPoint(x, y);
        // on Safari, elementFromPoint may return the shadowRoot host
        if (oldNext === next) {
          break;
        }
        if (next) {
          node = next;
        }
      }
      return node;
    },
    /**
     * a cheaper check than ev.composedPath()[0];
     *
     * @private
     * @param {Event} ev Event.
     * @return {EventTarget} Returns the event target.
     */
    _findOriginalTarget: function _findOriginalTarget(ev) {
      // shadowdom
      if (ev.composedPath) {
        return (/** @type {EventTarget} */ev.composedPath()[0]
        );
      }
      // shadydom
      return ev.target;
    },

    /**
     * @private
     * @param {Event} ev Event.
     */
    _handleNative: function _handleNative(ev) {
      var handled = void 0;
      var type = ev.type;
      var node = ev.currentTarget;
      var gobj = node[GESTURE_KEY];
      if (!gobj) {
        return;
      }
      var gs = gobj[type];
      if (!gs) {
        return;
      }
      if (!ev[HANDLED_OBJ]) {
        ev[HANDLED_OBJ] = {};
        if (type.slice(0, 5) === 'touch') {
          ev = /** @type {TouchEvent} */ev; // eslint-disable-line no-self-assign
          var t = ev.changedTouches[0];
          if (type === 'touchstart') {
            // only handle the first finger
            if (ev.touches.length === 1) {
              POINTERSTATE.touch.id = t.identifier;
            }
          }
          if (POINTERSTATE.touch.id !== t.identifier) {
            return;
          }
          if (!HAS_NATIVE_TA) {
            if (type === 'touchstart' || type === 'touchmove') {
              Gestures._handleTouchAction(ev);
            }
          }
        }
      }
      handled = ev[HANDLED_OBJ];
      // used to ignore synthetic mouse events
      if (handled.skip) {
        return;
      }
      var recognizers = Gestures.recognizers;
      // reset recognizer state
      for (var i = 0, r; i < recognizers.length; i++) {
        r = recognizers[i];
        if (gs[r.name] && !handled[r.name]) {
          if (r.flow && r.flow.start.indexOf(ev.type) > -1 && r.reset) {
            r.reset();
          }
        }
      }
      // enforce gesture recognizer order
      for (var _i = 0, _r; _i < recognizers.length; _i++) {
        _r = recognizers[_i];
        if (gs[_r.name] && !handled[_r.name]) {
          handled[_r.name] = true;
          _r[type](ev);
        }
      }
    },

    /**
     * @private
     * @param {TouchEvent} ev Event.
     */
    _handleTouchAction: function _handleTouchAction(ev) {
      var t = ev.changedTouches[0];
      var type = ev.type;
      if (type === 'touchstart') {
        POINTERSTATE.touch.x = t.clientX;
        POINTERSTATE.touch.y = t.clientY;
        POINTERSTATE.touch.scrollDecided = false;
      } else if (type === 'touchmove') {
        if (POINTERSTATE.touch.scrollDecided) {
          return;
        }
        POINTERSTATE.touch.scrollDecided = true;
        var ta = firstTouchAction(ev);
        var prevent = false;
        var dx = Math.abs(POINTERSTATE.touch.x - t.clientX);
        var dy = Math.abs(POINTERSTATE.touch.y - t.clientY);
        if (!ev.cancelable) {
          // scrolling is happening
        } else if (ta === 'none') {
          prevent = true;
        } else if (ta === 'pan-x') {
          prevent = dy > dx;
        } else if (ta === 'pan-y') {
          prevent = dx > dy;
        }
        if (prevent) {
          ev.preventDefault();
        } else {
          Gestures.prevent('track');
        }
      }
    },

    /**
     * Adds an event listener to a node for the given gesture type.
     *
     * @memberof Polymer.Gestures
     * @param {Node} node Node to add listener on
     * @param {string} evType Gesture type: `down`, `up`, `track`, or `tap`
     * @param {Function} handler Event listener function to call
     * @return {boolean} Returns true if a gesture event listener was added.
     * @this {Gestures}
     */
    addListener: function addListener(node, evType, handler) {
      if (this.gestures[evType]) {
        this._add(node, evType, handler);
        return true;
      }
      return false;
    },

    /**
     * Removes an event listener from a node for the given gesture type.
     *
     * @memberof Polymer.Gestures
     * @param {Node} node Node to remove listener from
     * @param {string} evType Gesture type: `down`, `up`, `track`, or `tap`
     * @param {Function} handler Event listener function previously passed to
     *  `addListener`.
     * @return {boolean} Returns true if a gesture event listener was removed.
     * @this {Gestures}
     */
    removeListener: function removeListener(node, evType, handler) {
      if (this.gestures[evType]) {
        this._remove(node, evType, handler);
        return true;
      }
      return false;
    },

    /**
     * automate the event listeners for the native events
     *
     * @private
     * @param {HTMLElement} node Node on which to add the event.
     * @param {string} evType Event type to add.
     * @param {function(Event?)} handler Event handler function.
     * @this {Gestures}
     */
    _add: function _add(node, evType, handler) {
      var recognizer = this.gestures[evType];
      var deps = recognizer.deps;
      var name = recognizer.name;
      var gobj = node[GESTURE_KEY];
      if (!gobj) {
        node[GESTURE_KEY] = gobj = {};
      }
      for (var i = 0, dep, gd; i < deps.length; i++) {
        dep = deps[i];
        // don't add mouse handlers on iOS because they cause gray selection overlays
        if (IS_TOUCH_ONLY && MOUSE_EVENTS.indexOf(dep) > -1 && dep !== 'click') {
          continue;
        }
        gd = gobj[dep];
        if (!gd) {
          gobj[dep] = gd = { _count: 0 };
        }
        if (gd._count === 0) {
          node.addEventListener(dep, this._handleNative);
        }
        gd[name] = (gd[name] || 0) + 1;
        gd._count = (gd._count || 0) + 1;
      }
      node.addEventListener(evType, handler);
      if (recognizer.touchAction) {
        this.setTouchAction(node, recognizer.touchAction);
      }
    },

    /**
     * automate event listener removal for native events
     *
     * @private
     * @param {HTMLElement} node Node on which to remove the event.
     * @param {string} evType Event type to remove.
     * @param {function(Event?)} handler Event handler function.
     * @this {Gestures}
     */
    _remove: function _remove(node, evType, handler) {
      var recognizer = this.gestures[evType];
      var deps = recognizer.deps;
      var name = recognizer.name;
      var gobj = node[GESTURE_KEY];
      if (gobj) {
        for (var i = 0, dep, gd; i < deps.length; i++) {
          dep = deps[i];
          gd = gobj[dep];
          if (gd && gd[name]) {
            gd[name] = (gd[name] || 1) - 1;
            gd._count = (gd._count || 1) - 1;
            if (gd._count === 0) {
              node.removeEventListener(dep, this._handleNative);
            }
          }
        }
      }
      node.removeEventListener(evType, handler);
    },

    /**
     * Registers a new gesture event recognizer for adding new custom
     * gesture event types.
     *
     * @memberof Polymer.Gestures
     * @param {GestureRecognizer} recog Gesture recognizer descriptor
     * @this {Gestures}
     */
    register: function register(recog) {
      this.recognizers.push(recog);
      for (var i = 0; i < recog.emits.length; i++) {
        this.gestures[recog.emits[i]] = recog;
      }
    },

    /**
     * @private
     * @param {string} evName Event name.
     * @return {Object} Returns the gesture for the given event name.
     * @this {Gestures}
     */
    _findRecognizerByEvent: function _findRecognizerByEvent(evName) {
      for (var i = 0, r; i < this.recognizers.length; i++) {
        r = this.recognizers[i];
        for (var j = 0, n; j < r.emits.length; j++) {
          n = r.emits[j];
          if (n === evName) {
            return r;
          }
        }
      }
      return null;
    },

    /**
     * Sets scrolling direction on node.
     *
     * This value is checked on first move, thus it should be called prior to
     * adding event listeners.
     *
     * @memberof Polymer.Gestures
     * @param {Element} node Node to set touch action setting on
     * @param {string} value Touch action value
     */
    setTouchAction: function setTouchAction(node, value) {
      if (HAS_NATIVE_TA) {
        node.style.touchAction = value;
      }
      node[TOUCH_ACTION] = value;
    },

    /**
     * Dispatches an event on the `target` element of `type` with the given
     * `detail`.
     * @private
     * @param {EventTarget} target The element on which to fire an event.
     * @param {string} type The type of event to fire.
     * @param {Object=} detail The detail object to populate on the event.
     */
    _fire: function _fire(target, type, detail) {
      var ev = new Event(type, { bubbles: true, cancelable: true, composed: true });
      ev.detail = detail;
      target.dispatchEvent(ev);
      // forward `preventDefault` in a clean way
      if (ev.defaultPrevented) {
        var preventer = detail.preventer || detail.sourceEvent;
        if (preventer && preventer.preventDefault) {
          preventer.preventDefault();
        }
      }
    },

    /**
     * Prevents the dispatch and default action of the given event name.
     *
     * @memberof Polymer.Gestures
     * @param {string} evName Event name.
     * @this {Gestures}
     */
    prevent: function prevent(evName) {
      var recognizer = this._findRecognizerByEvent(evName);
      if (recognizer.info) {
        recognizer.info.prevent = true;
      }
    },

    /**
     * Reset the 2500ms timeout on processing mouse input after detecting touch input.
     *
     * Touch inputs create synthesized mouse inputs anywhere from 0 to 2000ms after the touch.
     * This method should only be called during testing with simulated touch inputs.
     * Calling this method in production may cause duplicate taps or other Gestures.
     *
     * @memberof Polymer.Gestures
     */
    resetMouseCanceller: function resetMouseCanceller() {
      if (POINTERSTATE.mouse.mouseIgnoreJob) {
        POINTERSTATE.mouse.mouseIgnoreJob.flush();
      }
    }
  };

  /* eslint-disable valid-jsdoc */

  Gestures.register({
    name: 'downup',
    deps: ['mousedown', 'touchstart', 'touchend'],
    flow: {
      start: ['mousedown', 'touchstart'],
      end: ['mouseup', 'touchend']
    },
    emits: ['down', 'up'],

    info: {
      movefn: null,
      upfn: null
    },

    /** @this {GestureRecognizer} */
    reset: function reset() {
      untrackDocument(this.info);
    },

    /**
     * @this {GestureRecognizer}
     * @param {MouseEvent} e
     */
    mousedown: function mousedown(e) {
      if (!hasLeftMouseButton(e)) {
        return;
      }
      var t = Gestures._findOriginalTarget(e);
      var self = this;
      var movefn = function movefn(e) {
        if (!hasLeftMouseButton(e)) {
          self._fire('up', t, e);
          untrackDocument(self.info);
        }
      };
      var upfn = function upfn(e) {
        if (hasLeftMouseButton(e)) {
          self._fire('up', t, e);
        }
        untrackDocument(self.info);
      };
      trackDocument(this.info, movefn, upfn);
      this._fire('down', t, e);
    },
    /**
     * @this {GestureRecognizer}
     * @param {TouchEvent} e
     */
    touchstart: function touchstart(e) {
      this._fire('down', Gestures._findOriginalTarget(e), e.changedTouches[0], e);
    },
    /**
     * @this {GestureRecognizer}
     * @param {TouchEvent} e
     */
    touchend: function touchend(e) {
      this._fire('up', Gestures._findOriginalTarget(e), e.changedTouches[0], e);
    },
    /**
     * @param {string} type
     * @param {EventTarget} target
     * @param {Event} event
     * @param {Function} preventer
     */
    _fire: function _fire(type, target, event, preventer) {
      Gestures._fire(target, type, {
        x: event.clientX,
        y: event.clientY,
        sourceEvent: event,
        preventer: preventer,
        prevent: function prevent(e) {
          return Gestures.prevent(e);
        }
      });
    }
  });

  Gestures.register({
    name: 'track',
    touchAction: 'none',
    deps: ['mousedown', 'touchstart', 'touchmove', 'touchend'],
    flow: {
      start: ['mousedown', 'touchstart'],
      end: ['mouseup', 'touchend']
    },
    emits: ['track'],

    info: {
      x: 0,
      y: 0,
      state: 'start',
      started: false,
      moves: [],
      /** @this {GestureRecognizer} */
      addMove: function addMove(move) {
        if (this.moves.length > TRACK_LENGTH) {
          this.moves.shift();
        }
        this.moves.push(move);
      },
      movefn: null,
      upfn: null,
      prevent: false
    },

    /** @this {GestureRecognizer} */
    reset: function reset() {
      this.info.state = 'start';
      this.info.started = false;
      this.info.moves = [];
      this.info.x = 0;
      this.info.y = 0;
      this.info.prevent = false;
      untrackDocument(this.info);
    },

    /**
     * @this {GestureRecognizer}
     * @param {number} x
     * @param {number} y
     * @return {boolean}
     */
    hasMovedEnough: function hasMovedEnough(x, y) {
      if (this.info.prevent) {
        return false;
      }
      if (this.info.started) {
        return true;
      }
      var dx = Math.abs(this.info.x - x);
      var dy = Math.abs(this.info.y - y);
      return dx >= TRACK_DISTANCE || dy >= TRACK_DISTANCE;
    },
    /**
     * @this {GestureRecognizer}
     * @param {MouseEvent} e
     */
    mousedown: function mousedown(e) {
      if (!hasLeftMouseButton(e)) {
        return;
      }
      var t = Gestures._findOriginalTarget(e);
      var self = this;
      var movefn = function movefn(e) {
        var x = e.clientX,
            y = e.clientY;
        if (self.hasMovedEnough(x, y)) {
          // first move is 'start', subsequent moves are 'move', mouseup is 'end'
          self.info.state = self.info.started ? e.type === 'mouseup' ? 'end' : 'track' : 'start';
          if (self.info.state === 'start') {
            // if and only if tracking, always prevent tap
            Gestures.prevent('tap');
          }
          self.info.addMove({ x: x, y: y });
          if (!hasLeftMouseButton(e)) {
            // always _fire "end"
            self.info.state = 'end';
            untrackDocument(self.info);
          }
          self._fire(t, e);
          self.info.started = true;
        }
      };
      var upfn = function upfn(e) {
        if (self.info.started) {
          movefn(e);
        }

        // remove the temporary listeners
        untrackDocument(self.info);
      };
      // add temporary document listeners as mouse retargets
      trackDocument(this.info, movefn, upfn);
      this.info.x = e.clientX;
      this.info.y = e.clientY;
    },
    /**
     * @this {GestureRecognizer}
     * @param {TouchEvent} e
     */
    touchstart: function touchstart(e) {
      var ct = e.changedTouches[0];
      this.info.x = ct.clientX;
      this.info.y = ct.clientY;
    },
    /**
     * @this {GestureRecognizer}
     * @param {TouchEvent} e
     */
    touchmove: function touchmove(e) {
      var t = Gestures._findOriginalTarget(e);
      var ct = e.changedTouches[0];
      var x = ct.clientX,
          y = ct.clientY;
      if (this.hasMovedEnough(x, y)) {
        if (this.info.state === 'start') {
          // if and only if tracking, always prevent tap
          Gestures.prevent('tap');
        }
        this.info.addMove({ x: x, y: y });
        this._fire(t, ct);
        this.info.state = 'track';
        this.info.started = true;
      }
    },
    /**
     * @this {GestureRecognizer}
     * @param {TouchEvent} e
     */
    touchend: function touchend(e) {
      var t = Gestures._findOriginalTarget(e);
      var ct = e.changedTouches[0];
      // only trackend if track was started and not aborted
      if (this.info.started) {
        // reset started state on up
        this.info.state = 'end';
        this.info.addMove({ x: ct.clientX, y: ct.clientY });
        this._fire(t, ct, e);
      }
    },

    /**
     * @this {GestureRecognizer}
     * @param {EventTarget} target
     * @param {Touch} touch
     */
    _fire: function _fire(target, touch) {
      var secondlast = this.info.moves[this.info.moves.length - 2];
      var lastmove = this.info.moves[this.info.moves.length - 1];
      var dx = lastmove.x - this.info.x;
      var dy = lastmove.y - this.info.y;
      var ddx = void 0,
          ddy = 0;
      if (secondlast) {
        ddx = lastmove.x - secondlast.x;
        ddy = lastmove.y - secondlast.y;
      }
      Gestures._fire(target, 'track', {
        state: this.info.state,
        x: touch.clientX,
        y: touch.clientY,
        dx: dx,
        dy: dy,
        ddx: ddx,
        ddy: ddy,
        sourceEvent: touch,
        hover: function hover() {
          return Gestures.deepTargetFind(touch.clientX, touch.clientY);
        }
      });
    }

  });

  Gestures.register({
    name: 'tap',
    deps: ['mousedown', 'click', 'touchstart', 'touchend'],
    flow: {
      start: ['mousedown', 'touchstart'],
      end: ['click', 'touchend']
    },
    emits: ['tap'],
    info: {
      x: NaN,
      y: NaN,
      prevent: false
    },
    /** @this {GestureRecognizer} */
    reset: function reset() {
      this.info.x = NaN;
      this.info.y = NaN;
      this.info.prevent = false;
    },
    /** @this {GestureRecognizer} */
    save: function save(e) {
      this.info.x = e.clientX;
      this.info.y = e.clientY;
    },
    /**
     * @this {GestureRecognizer}
     * @param {MouseEvent} e
     */
    mousedown: function mousedown(e) {
      if (hasLeftMouseButton(e)) {
        this.save(e);
      }
    },
    /**
     * @this {GestureRecognizer}
     * @param {MouseEvent} e
     */
    click: function click(e) {
      if (hasLeftMouseButton(e)) {
        this.forward(e);
      }
    },
    /**
     * @this {GestureRecognizer}
     * @param {TouchEvent} e
     */
    touchstart: function touchstart(e) {
      this.save(e.changedTouches[0], e);
    },
    /**
     * @this {GestureRecognizer}
     * @param {TouchEvent} e
     */
    touchend: function touchend(e) {
      this.forward(e.changedTouches[0], e);
    },
    /**
     * @this {GestureRecognizer}
     * @param {Event} e
     * @param {Function} preventer
     */
    forward: function forward(e, preventer) {
      var dx = Math.abs(e.clientX - this.info.x);
      var dy = Math.abs(e.clientY - this.info.y);
      var t = Gestures._findOriginalTarget(e);
      // dx,dy can be NaN if `click` has been simulated and there was no `down` for `start`
      if (isNaN(dx) || isNaN(dy) || dx <= TAP_DISTANCE && dy <= TAP_DISTANCE || isSyntheticClick(e)) {
        // prevent taps from being generated if an event has canceled them
        if (!this.info.prevent) {
          Gestures._fire(t, 'tap', {
            x: e.clientX,
            y: e.clientY,
            sourceEvent: e,
            preventer: preventer
          });
        }
      }
    }
  });

  /* eslint-enable valid-jsdoc */

  /** @deprecated */
  Gestures.findOriginalTarget = Gestures._findOriginalTarget;

  /** @deprecated */
  Gestures.add = Gestures.addListener;

  /** @deprecated */
  Gestures.remove = Gestures.removeListener;

  Polymer.Gestures = Gestures;
})();

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(1);

(function () {

  'use strict';

  // run a callback when HTMLImports are ready or immediately if
  // this api is not available.

  function whenImportsReady(cb) {
    if (window.HTMLImports) {
      HTMLImports.whenReady(cb);
    } else {
      cb();
    }
  }

  /**
   * Convenience method for importing an HTML document imperatively.
   *
   * This method creates a new `<link rel="import">` element with
   * the provided URL and appends it to the document to start loading.
   * In the `onload` callback, the `import` property of the `link`
   * element will contain the imported document contents.
   *
   * @memberof Polymer
   * @param {string} href URL to document to load.
   * @param {Function=} onload Callback to notify when an import successfully
   *   loaded.
   * @param {Function=} onerror Callback to notify when an import
   *   unsuccessfully loaded.
   * @param {boolean=} optAsync True if the import should be loaded `async`.
   *   Defaults to `false`.
   * @return {HTMLLinkElement} The link element for the URL to be loaded.
   */
  Polymer.importHref = function (href, onload, onerror, optAsync) {
    var link = /** @type {HTMLLinkElement} */
    document.head.querySelector('link[href="' + href + '"][import-href]');
    if (!link) {
      link = /** @type {HTMLLinkElement} */document.createElement('link');
      link.rel = 'import';
      link.href = href;
      link.setAttribute('import-href', '');
    }
    // always ensure link has `async` attribute if user specified one,
    // even if it was previously not async. This is considered less confusing.
    if (optAsync) {
      link.setAttribute('async', '');
    }
    // NOTE: the link may now be in 3 states: (1) pending insertion,
    // (2) inflight, (3) already laoded. In each case, we need to add
    // event listeners to process callbacks.
    var cleanup = function cleanup() {
      link.removeEventListener('load', loadListener);
      link.removeEventListener('error', errorListener);
    };
    var loadListener = function loadListener(event) {
      cleanup();
      // In case of a successful load, cache the load event on the link so
      // that it can be used to short-circuit this method in the future when
      // it is called with the same href param.
      link.__dynamicImportLoaded = true;
      if (onload) {
        whenImportsReady(function () {
          onload(event);
        });
      }
    };
    var errorListener = function errorListener(event) {
      cleanup();
      // In case of an error, remove the link from the document so that it
      // will be automatically created again the next time `importHref` is
      // called.
      if (link.parentNode) {
        link.parentNode.removeChild(link);
      }
      if (onerror) {
        whenImportsReady(function () {
          onerror(event);
        });
      }
    };
    link.addEventListener('load', loadListener);
    link.addEventListener('error', errorListener);
    if (link.parentNode == null) {
      document.head.appendChild(link);
      // if the link already loaded, dispatch a fake load event
      // so that listeners are called and get a proper event argument.
    } else if (link.__dynamicImportLoaded) {
      link.dispatchEvent(new Event('load'));
    }
    return link;
  };
})();

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(1);

(function () {

  'use strict';

  var scheduled = false;
  var beforeRenderQueue = [];
  var afterRenderQueue = [];

  function schedule() {
    scheduled = true;
    // before next render
    requestAnimationFrame(function () {
      scheduled = false;
      flushQueue(beforeRenderQueue);
      // after the render
      setTimeout(function () {
        runQueue(afterRenderQueue);
      });
    });
  }

  function flushQueue(queue) {
    while (queue.length) {
      callMethod(queue.shift());
    }
  }

  function runQueue(queue) {
    for (var i = 0, l = queue.length; i < l; i++) {
      callMethod(queue.shift());
    }
  }

  function callMethod(info) {
    var context = info[0];
    var callback = info[1];
    var args = info[2];
    try {
      callback.apply(context, args);
    } catch (e) {
      setTimeout(function () {
        throw e;
      });
    }
  }

  function flush() {
    while (beforeRenderQueue.length || afterRenderQueue.length) {
      flushQueue(beforeRenderQueue);
      flushQueue(afterRenderQueue);
    }
    scheduled = false;
  }

  /**
   * Module for scheduling flushable pre-render and post-render tasks.
   *
   * @namespace
   * @memberof Polymer
   * @summary Module for scheduling flushable pre-render and post-render tasks.
   */
  Polymer.RenderStatus = {

    /**
     * Enqueues a callback which will be run before the next render, at
     * `requestAnimationFrame` timing.
     *
     * This method is useful for enqueuing work that requires DOM measurement,
     * since measurement may not be reliable in custom element callbacks before
     * the first render, as well as for batching measurement tasks in general.
     *
     * Tasks in this queue may be flushed by calling `Polymer.RenderStatus.flush()`.
     *
     * @memberof Polymer.RenderStatus
     * @param {*} context Context object the callback function will be bound to
     * @param {function()} callback Callback function
     * @param {Array} args An array of arguments to call the callback function with
     */
    beforeNextRender: function beforeNextRender(context, callback, args) {
      if (!scheduled) {
        schedule();
      }
      beforeRenderQueue.push([context, callback, args]);
    },

    /**
     * Enqueues a callback which will be run after the next render, equivalent
     * to one task (`setTimeout`) after the next `requestAnimationFrame`.
     *
     * This method is useful for tuning the first-render performance of an
     * element or application by deferring non-critical work until after the
     * first paint.  Typical non-render-critical work may include adding UI
     * event listeners and aria attributes.
     *
     * @memberof Polymer.RenderStatus
     * @param {*} context Context object the callback function will be bound to
     * @param {function()} callback Callback function
     * @param {Array} args An array of arguments to call the callback function with
     */
    afterNextRender: function afterNextRender(context, callback, args) {
      if (!scheduled) {
        schedule();
      }
      afterRenderQueue.push([context, callback, args]);
    },

    /**
     * Flushes all `beforeNextRender` tasks, followed by all `afterNextRender`
     * tasks.
     *
     * @memberof Polymer.RenderStatus
     */
    flush: flush

  };
})();

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


(function () {
  'use strict';

  // unresolved

  function resolve() {
    document.body.removeAttribute('unresolved');
  }

  if (window.WebComponents) {
    window.addEventListener('WebComponentsReady', resolve);
  } else {
    if (document.readyState === 'interactive' || document.readyState === 'complete') {
      resolve();
    } else {
      window.addEventListener('DOMContentLoaded', resolve);
    }
  }
})();

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

__webpack_require__(1);

__webpack_require__(20);

__webpack_require__(53);

__webpack_require__(13);

(function () {
  'use strict';

  var p = Element.prototype;
  /**
   * @const {function(this:Element, string): boolean}
   */
  var normalizedMatchesSelector = p.matches || p.matchesSelector || p.mozMatchesSelector || p.msMatchesSelector || p.oMatchesSelector || p.webkitMatchesSelector;

  /**
   * Cross-platform `element.matches` shim.
   *
   * @function matchesSelector
   * @memberof Polymer.dom
   * @param {!Element} node Node to check selector against
   * @param {string} selector Selector to match
   * @return {boolean} True if node matched selector
   */
  var matchesSelector = function matchesSelector(node, selector) {
    return normalizedMatchesSelector.call(node, selector);
  };

  /**
   * Node API wrapper class returned from `Polymer.dom.(target)` when
   * `target` is a `Node`.
   */

  var DomApi = function () {

    /**
     * @param {Node} node Node for which to create a Polymer.dom helper object.
     */
    function DomApi(node) {
      _classCallCheck(this, DomApi);

      this.node = node;
    }

    /**
     * Returns an instance of `Polymer.FlattenedNodesObserver` that
     * listens for node changes on this element.
     *
     * @param {Function} callback Called when direct or distributed children
     *   of this element changes
     * @return {Polymer.FlattenedNodesObserver} Observer instance
     */


    _createClass(DomApi, [{
      key: 'observeNodes',
      value: function observeNodes(callback) {
        return new Polymer.FlattenedNodesObserver(this.node, callback);
      }

      /**
       * Disconnects an observer previously created via `observeNodes`
       *
       * @param {Polymer.FlattenedNodesObserver} observerHandle Observer instance
       *   to disconnect.
       */

    }, {
      key: 'unobserveNodes',
      value: function unobserveNodes(observerHandle) {
        observerHandle.disconnect();
      }

      /**
       * Provided as a backwards-compatible API only.  This method does nothing.
       */

    }, {
      key: 'notifyObserver',
      value: function notifyObserver() {}

      /**
       * Returns true if the provided node is contained with this element's
       * light-DOM children or shadow root, including any nested shadow roots
       * of children therein.
       *
       * @param {Node} node Node to test
       * @return {boolean} Returns true if the given `node` is contained within
       *   this element's light or shadow DOM.
       */

    }, {
      key: 'deepContains',
      value: function deepContains(node) {
        if (this.node.contains(node)) {
          return true;
        }
        var n = node;
        var doc = node.ownerDocument;
        // walk from node to `this` or `document`
        while (n && n !== doc && n !== this.node) {
          // use logical parentnode, or native ShadowRoot host
          n = n.parentNode || n.host;
        }
        return n === this.node;
      }

      /**
       * Returns the root node of this node.  Equivalent to `getRoodNode()`.
       *
       * @return {Node} Top most element in the dom tree in which the node
       * exists. If the node is connected to a document this is either a
       * shadowRoot or the document; otherwise, it may be the node
       * itself or a node or document fragment containing it.
       */

    }, {
      key: 'getOwnerRoot',
      value: function getOwnerRoot() {
        return this.node.getRootNode();
      }

      /**
       * For slot elements, returns the nodes assigned to the slot; otherwise
       * an empty array. It is equivalent to `<slot>.addignedNodes({flatten:true})`.
       *
       * @return {Array<Node>} Array of assigned nodes
       */

    }, {
      key: 'getDistributedNodes',
      value: function getDistributedNodes() {
        return this.node.localName === 'slot' ? this.node.assignedNodes({ flatten: true }) : [];
      }

      /**
       * Returns an array of all slots this element was distributed to.
       *
       * @return {Array<HTMLSlotElement>} Description
       */

    }, {
      key: 'getDestinationInsertionPoints',
      value: function getDestinationInsertionPoints() {
        var ip$ = [];
        var n = this.node.assignedSlot;
        while (n) {
          ip$.push(n);
          n = n.assignedSlot;
        }
        return ip$;
      }

      /**
       * Calls `importNode` on the `ownerDocument` for this node.
       *
       * @param {Node} node Node to import
       * @param {boolean} deep True if the node should be cloned deeply during
       *   import
       * @return {Node} Clone of given node imported to this owner document
       */

    }, {
      key: 'importNode',
      value: function importNode(node, deep) {
        var doc = this.node instanceof Document ? this.node : this.node.ownerDocument;
        return doc.importNode(node, deep);
      }

      /**
       * @return {Array} Returns a flattened list of all child nodes and nodes assigned
       * to child slots.
       */

    }, {
      key: 'getEffectiveChildNodes',
      value: function getEffectiveChildNodes() {
        return Polymer.FlattenedNodesObserver.getFlattenedNodes(this.node);
      }

      /**
       * Returns a filtered list of flattened child elements for this element based
       * on the given selector.
       *
       * @param {string} selector Selector to filter nodes against
       * @return {Array<HTMLElement>} List of flattened child elements
       */

    }, {
      key: 'queryDistributedElements',
      value: function queryDistributedElements(selector) {
        var c$ = this.getEffectiveChildNodes();
        var list = [];
        for (var i = 0, l = c$.length, c; i < l && (c = c$[i]); i++) {
          if (c.nodeType === Node.ELEMENT_NODE && matchesSelector(c, selector)) {
            list.push(c);
          }
        }
        return list;
      }

      /**
       * For shadow roots, returns the currently focused element within this
       * shadow root.
       *
       * @return {Node|undefined} Currently focused element
       */

    }, {
      key: 'activeElement',
      get: function get() {
        var node = this.node;
        return node._activeElement !== undefined ? node._activeElement : node.activeElement;
      }
    }]);

    return DomApi;
  }();

  function forwardMethods(proto, methods) {
    var _loop = function _loop(i) {
      var method = methods[i];
      proto[method] = /** @this {DomApi} */function () {
        return this.node[method].apply(this.node, arguments);
      };
    };

    for (var i = 0; i < methods.length; i++) {
      _loop(i);
    }
  }

  function forwardReadOnlyProperties(proto, properties) {
    var _loop2 = function _loop2(i) {
      var name = properties[i];
      Object.defineProperty(proto, name, {
        get: function get() {
          return (/** @type {DomApi} */this.node[name]
          );
        },
        configurable: true
      });
    };

    for (var i = 0; i < properties.length; i++) {
      _loop2(i);
    }
  }

  function forwardProperties(proto, properties) {
    var _loop3 = function _loop3(i) {
      var name = properties[i];
      Object.defineProperty(proto, name, {
        get: function get() {
          return (/** @type {DomApi} */this.node[name]
          );
        },
        set: function set(value) {
          /** @type {DomApi} */this.node[name] = value;
        },
        configurable: true
      });
    };

    for (var i = 0; i < properties.length; i++) {
      _loop3(i);
    }
  }

  forwardMethods(DomApi.prototype, ['cloneNode', 'appendChild', 'insertBefore', 'removeChild', 'replaceChild', 'setAttribute', 'removeAttribute', 'querySelector', 'querySelectorAll']);

  forwardReadOnlyProperties(DomApi.prototype, ['parentNode', 'firstChild', 'lastChild', 'nextSibling', 'previousSibling', 'firstElementChild', 'lastElementChild', 'nextElementSibling', 'previousElementSibling', 'childNodes', 'children', 'classList']);

  forwardProperties(DomApi.prototype, ['textContent', 'innerHTML']);

  /**
   * Event API wrapper class returned from `Polymer.dom.(target)` when
   * `target` is an `Event`.
   */

  var EventApi = function () {
    function EventApi(event) {
      _classCallCheck(this, EventApi);

      this.event = event;
    }

    /**
     * Returns the first node on the `composedPath` of this event.
     *
     * @return {Node} The node this event was dispatched to
     */


    _createClass(EventApi, [{
      key: 'rootTarget',
      get: function get() {
        return this.event.composedPath()[0];
      }

      /**
       * Returns the local (re-targeted) target for this event.
       *
       * @return {Node} The local (re-targeted) target for this event.
       */

    }, {
      key: 'localTarget',
      get: function get() {
        return this.event.target;
      }

      /**
       * Returns the `composedPath` for this event.
       */

    }, {
      key: 'path',
      get: function get() {
        return this.event.composedPath();
      }
    }]);

    return EventApi;
  }();

  Polymer.DomApi = DomApi;

  /**
   * Legacy DOM and Event manipulation API wrapper factory used to abstract
   * differences between native Shadow DOM and "Shady DOM" when polyfilling on
   * older browsers.
   *
   * Note that in Polymer 2.x use of `Polymer.dom` is no longer required and
   * in the majority of cases simply facades directly to the standard native
   * API.
   *
   * @namespace
   * @summary Legacy DOM and Event manipulation API wrapper factory used to
   * abstract differences between native Shadow DOM and "Shady DOM."
   * @memberof Polymer
   * @param {!Node|Event} obj Node or event to operate on
   * @return {DomApi|EventApi} Wrapper providing either node API or event API
   */
  Polymer.dom = function (obj) {
    obj = obj || document;
    if (!obj.__domApi) {
      var helper = void 0;
      if (obj instanceof Event) {
        helper = new EventApi(obj);
      } else {
        helper = new DomApi(obj);
      }
      obj.__domApi = helper;
    }
    return obj.__domApi;
  };

  Polymer.dom.matchesSelector = matchesSelector;

  /**
   * Forces several classes of asynchronously queued tasks to flush:
   * - Debouncers added via `Polymer.enqueueDebouncer`
   * - ShadyDOM distribution
   *
   * This method facades to `Polymer.flush`.
   *
   * @memberof Polymer.dom
   */
  Polymer.dom.flush = Polymer.flush;

  /**
   * Adds a `Polymer.Debouncer` to a list of globally flushable tasks.
   *
   * This method facades to `Polymer.enqueueDebouncer`.
   *
   * @memberof Polymer.dom
   * @param {Polymer.Debouncer} debouncer Debouncer to enqueue
   */
  Polymer.dom.addDebouncer = Polymer.enqueueDebouncer;
})();

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

__webpack_require__(1);

__webpack_require__(24);

__webpack_require__(8);

(function () {
  'use strict';

  /**
   * Returns true if `node` is a slot element
   * @param {HTMLElement} node Node to test.
   * @return {boolean} Returns true if the given `node` is a slot
   * @private
   */

  function isSlot(node) {
    return node.localName === 'slot';
  }

  /**
   * Class that listens for changes (additions or removals) to
   * "flattened nodes" on a given `node`. The list of flattened nodes consists
   * of a node's children and, for any children that are `<slot>` elements,
   * the expanded flattened list of `assignedNodes`.
   * For example, if the observed node has children `<a></a><slot></slot><b></b>`
   * and the `<slot>` has one `<div>` assigned to it, then the flattened
   * nodes list is `<a></a><div></div><b></b>`. If the `<slot>` has other
   * `<slot>` elements assigned to it, these are flattened as well.
   *
   * The provided `callback` is called whenever any change to this list
   * of flattened nodes occurs, where an addition or removal of a node is
   * considered a change. The `callback` is called with one argument, an object
   * containing an array of any `addedNodes` and `removedNodes`.
   *
   * Note: the callback is called asynchronous to any changes
   * at a microtask checkpoint. This is because observation is performed using
   * `MutationObserver` and the `<slot>` element's `slotchange` event which
   * are asynchronous.
   *
   * @memberof Polymer
   * @summary Class that listens for changes (additions or removals) to
   * "flattened nodes" on a given `node`.
   */

  var FlattenedNodesObserver = function () {
    _createClass(FlattenedNodesObserver, null, [{
      key: 'getFlattenedNodes',


      /**
       * Returns the list of flattened nodes for the given `node`.
       * This list consists of a node's children and, for any children
       * that are `<slot>` elements, the expanded flattened list of `assignedNodes`.
       * For example, if the observed node has children `<a></a><slot></slot><b></b>`
       * and the `<slot>` has one `<div>` assigned to it, then the flattened
       * nodes list is `<a></a><div></div><b></b>`. If the `<slot>` has other
       * `<slot>` elements assigned to it, these are flattened as well.
       *
       * @param {HTMLElement|HTMLSlotElement} node The node for which to return the list of flattened nodes.
       * @return {Array} The list of flattened nodes for the given `node`.
      */
      value: function getFlattenedNodes(node) {
        if (isSlot(node)) {
          return (/** @type {HTMLSlotElement} */node.assignedNodes({ flatten: true })
          );
        } else {
          return Array.from(node.childNodes).map(function (node) {
            if (isSlot(node)) {
              return (/** @type {HTMLSlotElement} */node.assignedNodes({ flatten: true })
              );
            } else {
              return [node];
            }
          }).reduce(function (a, b) {
            return a.concat(b);
          }, []);
        }
      }

      /**
       * @param {Node} target Node on which to listen for changes.
       * @param {Function} callback Function called when there are additions
       * or removals from the target's list of flattened nodes.
      */

    }]);

    function FlattenedNodesObserver(target, callback) {
      var _this = this;

      _classCallCheck(this, FlattenedNodesObserver);

      /** @type {MutationObserver} */
      this._shadyChildrenObserver = null;
      /** @type {MutationObserver} */
      this._nativeChildrenObserver = null;
      this._connected = false;
      this._target = target;
      this.callback = callback;
      this._effectiveNodes = [];
      this._observer = null;
      this._scheduled = false;
      /** @type {function()} */
      this._boundSchedule = function () {
        _this._schedule();
      };
      this.connect();
      this._schedule();
    }

    /**
     * Activates an observer. This method is automatically called when
     * a `FlattenedNodesObserver` is created. It should only be called to
     * re-activate an observer that has been deactivated via the `disconnect` method.
     */


    _createClass(FlattenedNodesObserver, [{
      key: 'connect',
      value: function connect() {
        var _this2 = this;

        if (isSlot(this._target)) {
          this._listenSlots([this._target]);
        } else {
          this._listenSlots(this._target.children);
          if (window.ShadyDOM) {
            this._shadyChildrenObserver = ShadyDOM.observeChildren(this._target, function (mutations) {
              _this2._processMutations(mutations);
            });
          } else {
            this._nativeChildrenObserver = new MutationObserver(function (mutations) {
              _this2._processMutations(mutations);
            });
            this._nativeChildrenObserver.observe(this._target, { childList: true });
          }
        }
        this._connected = true;
      }

      /**
       * Deactivates the flattened nodes observer. After calling this method
       * the observer callback will not be called when changes to flattened nodes
       * occur. The `connect` method may be subsequently called to reactivate
       * the observer.
       */

    }, {
      key: 'disconnect',
      value: function disconnect() {
        if (isSlot(this._target)) {
          this._unlistenSlots([this._target]);
        } else {
          this._unlistenSlots(this._target.children);
          if (window.ShadyDOM && this._shadyChildrenObserver) {
            ShadyDOM.unobserveChildren(this._shadyChildrenObserver);
            this._shadyChildrenObserver = null;
          } else if (this._nativeChildrenObserver) {
            this._nativeChildrenObserver.disconnect();
            this._nativeChildrenObserver = null;
          }
        }
        this._connected = false;
      }
    }, {
      key: '_schedule',
      value: function _schedule() {
        var _this3 = this;

        if (!this._scheduled) {
          this._scheduled = true;
          Polymer.Async.microTask.run(function () {
            return _this3.flush();
          });
        }
      }
    }, {
      key: '_processMutations',
      value: function _processMutations(mutations) {
        this._processSlotMutations(mutations);
        this.flush();
      }
    }, {
      key: '_processSlotMutations',
      value: function _processSlotMutations(mutations) {
        if (mutations) {
          for (var i = 0; i < mutations.length; i++) {
            var mutation = mutations[i];
            if (mutation.addedNodes) {
              this._listenSlots(mutation.addedNodes);
            }
            if (mutation.removedNodes) {
              this._unlistenSlots(mutation.removedNodes);
            }
          }
        }
      }

      /**
       * Flushes the observer causing any pending changes to be immediately
       * delivered the observer callback. By default these changes are delivered
       * asynchronously at the next microtask checkpoint.
       *
       * @return {boolean} Returns true if any pending changes caused the observer
       * callback to run.
       */

    }, {
      key: 'flush',
      value: function flush() {
        if (!this._connected) {
          return false;
        }
        if (window.ShadyDOM) {
          ShadyDOM.flush();
        }
        if (this._nativeChildrenObserver) {
          this._processSlotMutations(this._nativeChildrenObserver.takeRecords());
        } else if (this._shadyChildrenObserver) {
          this._processSlotMutations(this._shadyChildrenObserver.takeRecords());
        }
        this._scheduled = false;
        var info = {
          target: this._target,
          addedNodes: [],
          removedNodes: []
        };
        var newNodes = this.constructor.getFlattenedNodes(this._target);
        var splices = Polymer.ArraySplice.calculateSplices(newNodes, this._effectiveNodes);
        // process removals
        for (var i = 0, s; i < splices.length && (s = splices[i]); i++) {
          for (var j = 0, n; j < s.removed.length && (n = s.removed[j]); j++) {
            info.removedNodes.push(n);
          }
        }
        // process adds
        for (var _i = 0, _s; _i < splices.length && (_s = splices[_i]); _i++) {
          for (var _j = _s.index; _j < _s.index + _s.addedCount; _j++) {
            info.addedNodes.push(newNodes[_j]);
          }
        }
        // update cache
        this._effectiveNodes = newNodes;
        var didFlush = false;
        if (info.addedNodes.length || info.removedNodes.length) {
          didFlush = true;
          this.callback.call(this._target, info);
        }
        return didFlush;
      }
    }, {
      key: '_listenSlots',
      value: function _listenSlots(nodeList) {
        for (var i = 0; i < nodeList.length; i++) {
          var n = nodeList[i];
          if (isSlot(n)) {
            n.addEventListener('slotchange', this._boundSchedule);
          }
        }
      }
    }, {
      key: '_unlistenSlots',
      value: function _unlistenSlots(nodeList) {
        for (var i = 0; i < nodeList.length; i++) {
          var n = nodeList[i];
          if (isSlot(n)) {
            n.removeEventListener('slotchange', this._boundSchedule);
          }
        }
      }
    }]);

    return FlattenedNodesObserver;
  }();

  Polymer.FlattenedNodesObserver = FlattenedNodesObserver;
})();

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(55);

(function () {
  'use strict';

  /**
   * Legacy class factory and registration helper for defining Polymer
   * elements.
   *
   * This method is equivalent to
   * `customElements.define(info.is, Polymer.Class(info));`
   *
   * See `Polymer.Class` for details on valid legacy metadata format for `info`.
   *
   * @override
   * @function Polymer
   * @param {!PolymerInit} info Object containing Polymer metadata and functions
   *   to become class methods.
   * @return {!HTMLElement} Generated class
   * @suppress {duplicate, invalidCasts, checkTypes}
   */

  window.Polymer._polymerFn = function (info) {
    // if input is a `class` (aka a function with a prototype), use the prototype
    // remember that the `constructor` will never be called
    var klass = void 0;
    if (typeof info === 'function') {
      klass = info;
    } else {
      klass = Polymer.Class(info);
    }
    customElements.define(klass.is, /** @type {!HTMLElement} */klass);
    return klass;
  };
})();

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

__webpack_require__(22);

(function () {

  'use strict';

  var metaProps = {
    attached: true,
    detached: true,
    ready: true,
    created: true,
    beforeRegister: true,
    registered: true,
    attributeChanged: true,
    // meta objects
    behaviors: true

    /**
     * Applies a "legacy" behavior or array of behaviors to the provided class.
     *
     * Note: this method will automatically also apply the `Polymer.LegacyElementMixin`
     * to ensure that any legacy behaviors can rely on legacy Polymer API on
     * the underlying element.
     *
     * @param {!(Object|Array)} behaviors Behavior object or array of behaviors.
     * @param {!HTMLElement|function(new:HTMLElement)} klass Element class.
     * @return {function(new:HTMLElement)} Returns a new Element class extended by the
     * passed in `behaviors` and also by `Polymer.LegacyElementMixin`.
     * @memberof Polymer
     * @suppress {invalidCasts, checkTypes}
     */
  };function mixinBehaviors(behaviors, klass) {
    if (!behaviors) {
      return (/** @type {HTMLElement} */klass
      );
    }
    // NOTE: ensure the bahevior is extending a class with
    // legacy element api. This is necessary since behaviors expect to be able
    // to access 1.x legacy api.
    klass = Polymer.LegacyElementMixin(klass);
    if (!Array.isArray(behaviors)) {
      behaviors = [behaviors];
    }
    var superBehaviors = klass.prototype.behaviors;
    // get flattened, deduped list of behaviors *not* already on super class
    behaviors = flattenBehaviors(behaviors, null, superBehaviors);
    // mixin new behaviors
    klass = _mixinBehaviors(behaviors, klass);
    if (superBehaviors) {
      behaviors = superBehaviors.concat(behaviors);
    }
    // Set behaviors on prototype for BC...
    klass.prototype.behaviors = behaviors;
    return klass;
  }

  // NOTE:
  // 1.x
  // Behaviors were mixed in *in reverse order* and de-duped on the fly.
  // The rule was that behavior properties were copied onto the element
  // prototype if and only if the property did not already exist.
  // Given: Polymer{ behaviors: [A, B, C, A, B]}, property copy order was:
  // (1), B, (2), A, (3) C. This means prototype properties win over
  // B properties win over A win over C. This mirrors what would happen
  // with inheritance if element extended B extended A extended C.
  //
  // Again given, Polymer{ behaviors: [A, B, C, A, B]}, the resulting
  // `behaviors` array was [C, A, B].
  // Behavior lifecycle methods were called in behavior array order
  // followed by the element, e.g. (1) C.created, (2) A.created,
  // (3) B.created, (4) element.created. There was no support for
  // super, and "super-behavior" methods were callable only by name).
  //
  // 2.x
  // Behaviors are made into proper mixins which live in the
  // element's prototype chain. Behaviors are placed in the element prototype
  // eldest to youngest and de-duped youngest to oldest:
  // So, first [A, B, C, A, B] becomes [C, A, B] then,
  // the element prototype becomes (oldest) (1) Polymer.Element, (2) class(C),
  // (3) class(A), (4) class(B), (5) class(Polymer({...})).
  // Result:
  // This means element properties win over B properties win over A win
  // over C. (same as 1.x)
  // If lifecycle is called (super then me), order is
  // (1) C.created, (2) A.created, (3) B.created, (4) element.created
  // (again same as 1.x)
  function _mixinBehaviors(behaviors, klass) {
    for (var i = 0; i < behaviors.length; i++) {
      var b = behaviors[i];
      if (b) {
        klass = Array.isArray(b) ? _mixinBehaviors(b, klass) : GenerateClassFromInfo(b, klass);
      }
    }
    return klass;
  }

  /**
   * @param {Array} behaviors List of behaviors to flatten.
   * @param {Array=} list Target list to flatten behaviors into.
   * @param {Array=} exclude List of behaviors to exclude from the list.
   * @return {!Array} Returns the list of flattened behaviors.
   */
  function flattenBehaviors(behaviors, list, exclude) {
    list = list || [];
    for (var i = behaviors.length - 1; i >= 0; i--) {
      var b = behaviors[i];
      if (b) {
        if (Array.isArray(b)) {
          flattenBehaviors(b, list);
        } else {
          // dedup
          if (list.indexOf(b) < 0 && (!exclude || exclude.indexOf(b) < 0)) {
            list.unshift(b);
          }
        }
      } else {
        console.warn('behavior is null, check for missing or 404 import');
      }
    }
    return list;
  }

  /**
   * @param {!PolymerInit} info Polymer info object
   * @param {function(new:HTMLElement)} Base base class to extend with info object
   * @return {function(new:HTMLElement)} Generated class
   * @suppress {checkTypes}
   * @private
   */
  function GenerateClassFromInfo(info, Base) {
    var PolymerGenerated = function (_Base) {
      _inherits(PolymerGenerated, _Base);

      function PolymerGenerated() {
        _classCallCheck(this, PolymerGenerated);

        return _possibleConstructorReturn(this, (PolymerGenerated.__proto__ || Object.getPrototypeOf(PolymerGenerated)).apply(this, arguments));
      }

      _createClass(PolymerGenerated, [{
        key: 'created',
        value: function created() {
          _get(PolymerGenerated.prototype.__proto__ || Object.getPrototypeOf(PolymerGenerated.prototype), 'created', this).call(this);
          if (info.created) {
            info.created.call(this);
          }
        }
      }, {
        key: '_registered',
        value: function _registered() {
          _get(PolymerGenerated.prototype.__proto__ || Object.getPrototypeOf(PolymerGenerated.prototype), '_registered', this).call(this);
          /* NOTE: `beforeRegister` is called here for bc, but the behavior
           is different than in 1.x. In 1.0, the method was called *after*
           mixing prototypes together but *before* processing of meta-objects.
           However, dynamic effects can still be set here and can be done either
           in `beforeRegister` or `registered`. It is no longer possible to set
           `is` in `beforeRegister` as you could in 1.x.
          */
          if (info.beforeRegister) {
            info.beforeRegister.call(Object.getPrototypeOf(this));
          }
          if (info.registered) {
            info.registered.call(Object.getPrototypeOf(this));
          }
        }
      }, {
        key: '_applyListeners',
        value: function _applyListeners() {
          _get(PolymerGenerated.prototype.__proto__ || Object.getPrototypeOf(PolymerGenerated.prototype), '_applyListeners', this).call(this);
          if (info.listeners) {
            for (var l in info.listeners) {
              this._addMethodEventListenerToNode(this, l, info.listeners[l]);
            }
          }
        }

        // note: exception to "super then me" rule;
        // do work before calling super so that super attributes
        // only apply if not already set.

      }, {
        key: '_ensureAttributes',
        value: function _ensureAttributes() {
          if (info.hostAttributes) {
            for (var a in info.hostAttributes) {
              this._ensureAttribute(a, info.hostAttributes[a]);
            }
          }
          _get(PolymerGenerated.prototype.__proto__ || Object.getPrototypeOf(PolymerGenerated.prototype), '_ensureAttributes', this).call(this);
        }
      }, {
        key: 'ready',
        value: function ready() {
          _get(PolymerGenerated.prototype.__proto__ || Object.getPrototypeOf(PolymerGenerated.prototype), 'ready', this).call(this);
          if (info.ready) {
            info.ready.call(this);
          }
        }
      }, {
        key: 'attached',
        value: function attached() {
          _get(PolymerGenerated.prototype.__proto__ || Object.getPrototypeOf(PolymerGenerated.prototype), 'attached', this).call(this);
          if (info.attached) {
            info.attached.call(this);
          }
        }
      }, {
        key: 'detached',
        value: function detached() {
          _get(PolymerGenerated.prototype.__proto__ || Object.getPrototypeOf(PolymerGenerated.prototype), 'detached', this).call(this);
          if (info.detached) {
            info.detached.call(this);
          }
        }
      }, {
        key: 'attributeChanged',
        value: function attributeChanged(name, old, value) {
          _get(PolymerGenerated.prototype.__proto__ || Object.getPrototypeOf(PolymerGenerated.prototype), 'attributeChanged', this).call(this, name, old, value);
          if (info.attributeChanged) {
            info.attributeChanged.call(this, name, old, value);
          }
        }
      }], [{
        key: 'properties',
        get: function get() {
          return info.properties;
        }
      }, {
        key: 'observers',
        get: function get() {
          return info.observers;
        }

        /**
         * @return {HTMLTemplateElement} template for this class
         */

      }, {
        key: 'template',
        get: function get() {
          // get template first from any imperative set in `info._template`
          return info._template ||
          // next look in dom-module associated with this element's is.
          Polymer.DomModule && Polymer.DomModule.import(this.is, 'template') ||
          // next look for superclass template (note: use superclass symbol
          // to ensure correct `this.is`)
          Base.template ||
          // finally fall back to `_template` in element's protoype.
          this.prototype._template || null;
        }
      }]);

      return PolymerGenerated;
    }(Base);

    PolymerGenerated.generatedFrom = info;

    for (var p in info) {
      // NOTE: cannot copy `metaProps` methods onto prototype at least because
      // `super.ready` must be called and is not included in the user fn.
      if (!(p in metaProps)) {
        var pd = Object.getOwnPropertyDescriptor(info, p);
        if (pd) {
          Object.defineProperty(PolymerGenerated.prototype, p, pd);
        }
      }
    }

    return PolymerGenerated;
  }

  /**
   * Generates a class that extends `Polymer.LegacyElement` based on the
   * provided info object.  Metadata objects on the `info` object
   * (`properties`, `observers`, `listeners`, `behaviors`, `is`) are used
   * for Polymer's meta-programming systems, and any functions are copied
   * to the generated class.
   *
   * Valid "metadata" values are as follows:
   *
   * `is`: String providing the tag name to register the element under. In
   * addition, if a `dom-module` with the same id exists, the first template
   * in that `dom-module` will be stamped into the shadow root of this element,
   * with support for declarative event listeners (`on-...`), Polymer data
   * bindings (`[[...]]` and `{{...}}`), and id-based node finding into
   * `this.$`.
   *
   * `properties`: Object describing property-related metadata used by Polymer
   * features (key: property names, value: object containing property metadata).
   * Valid keys in per-property metadata include:
   * - `type` (String|Number|Object|Array|...): Used by
   *   `attributeChangedCallback` to determine how string-based attributes
   *   are deserialized to JavaScript property values.
   * - `notify` (boolean): Causes a change in the property to fire a
   *   non-bubbling event called `<property>-changed`. Elements that have
   *   enabled two-way binding to the property use this event to observe changes.
   * - `readOnly` (boolean): Creates a getter for the property, but no setter.
   *   To set a read-only property, use the private setter method
   *   `_setProperty(property, value)`.
   * - `observer` (string): Observer method name that will be called when
   *   the property changes. The arguments of the method are
   *   `(value, previousValue)`.
   * - `computed` (string): String describing method and dependent properties
   *   for computing the value of this property (e.g. `'computeFoo(bar, zot)'`).
   *   Computed properties are read-only by default and can only be changed
   *   via the return value of the computing method.
   *
   * `observers`: Array of strings describing multi-property observer methods
   *  and their dependent properties (e.g. `'observeABC(a, b, c)'`).
   *
   * `listeners`: Object describing event listeners to be added to each
   *  instance of this element (key: event name, value: method name).
   *
   * `behaviors`: Array of additional `info` objects containing metadata
   * and callbacks in the same format as the `info` object here which are
   * merged into this element.
   *
   * `hostAttributes`: Object listing attributes to be applied to the host
   *  once created (key: attribute name, value: attribute value).  Values
   *  are serialized based on the type of the value.  Host attributes should
   *  generally be limited to attributes such as `tabIndex` and `aria-...`.
   *  Attributes in `hostAttributes` are only applied if a user-supplied
   *  attribute is not already present (attributes in markup override
   *  `hostAttributes`).
   *
   * In addition, the following Polymer-specific callbacks may be provided:
   * - `registered`: called after first instance of this element,
   * - `created`: called during `constructor`
   * - `attached`: called during `connectedCallback`
   * - `detached`: called during `disconnectedCallback`
   * - `ready`: called before first `attached`, after all properties of
   *   this element have been propagated to its template and all observers
   *   have run
   *
   * @param {!PolymerInit} info Object containing Polymer metadata and functions
   *   to become class methods.
   * @return {function(new:HTMLElement)} Generated class
   * @memberof Polymer
   */
  Polymer.Class = function (info) {
    if (!info) {
      console.warn('Polymer.Class requires `info` argument');
    }
    var klass = GenerateClassFromInfo(info, info.behaviors ?
    // note: mixinBehaviors ensures `LegacyElementMixin`.
    mixinBehaviors(info.behaviors, HTMLElement) : Polymer.LegacyElementMixin(HTMLElement));
    // decorate klass with registration info
    klass.is = info.is;
    return klass;
  };

  Polymer.mixinBehaviors = mixinBehaviors;
})();

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(14);

(function () {
  'use strict';

  var TemplateInstanceBase = Polymer.TemplateInstanceBase; // eslint-disable-line

  /**
   * @typedef {{
   *   _templatizerTemplate: HTMLTemplateElement,
   *   _parentModel: boolean,
   *   _instanceProps: Object,
   *   _forwardHostPropV2: Function,
   *   _notifyInstancePropV2: Function,
   *   ctor: TemplateInstanceBase
   * }}
   */
  var TemplatizerUser = void 0; // eslint-disable-line

  /**
   * The `Polymer.Templatizer` behavior adds methods to generate instances of
   * templates that are each managed by an anonymous `Polymer.PropertyEffects`
   * instance where data-bindings in the stamped template content are bound to
   * accessors on itself.
   *
   * This behavior is provided in Polymer 2.x as a hybrid-element convenience
   * only.  For non-hybrid usage, the `Polymer.Templatize` library
   * should be used instead.
   *
   * Example:
   *
   *     // Get a template from somewhere, e.g. light DOM
   *     let template = this.querySelector('template');
   *     // Prepare the template
   *     this.templatize(template);
   *     // Instance the template with an initial data model
   *     let instance = this.stamp({myProp: 'initial'});
   *     // Insert the instance's DOM somewhere, e.g. light DOM
   *     Polymer.dom(this).appendChild(instance.root);
   *     // Changing a property on the instance will propagate to bindings
   *     // in the template
   *     instance.myProp = 'new value';
   *
   * Users of `Templatizer` may need to implement the following abstract
   * API's to determine how properties and paths from the host should be
   * forwarded into to instances:
   *
   *     _forwardHostPropV2: function(prop, value)
   *
   * Likewise, users may implement these additional abstract API's to determine
   * how instance-specific properties that change on the instance should be
   * forwarded out to the host, if necessary.
   *
   *     _notifyInstancePropV2: function(inst, prop, value)
   *
   * In order to determine which properties are instance-specific and require
   * custom notification via `_notifyInstanceProp`, define an `_instanceProps`
   * object containing keys for each instance prop, for example:
   *
   *     _instanceProps: {
   *       item: true,
   *       index: true
   *     }
   *
   * Any properties used in the template that are not defined in _instanceProp
   * will be forwarded out to the Templatize `owner` automatically.
   *
   * Users may also implement the following abstract function to show or
   * hide any DOM generated using `stamp`:
   *
   *     _showHideChildren: function(shouldHide)
   *
   * Note that some callbacks are suffixed with `V2` in the Polymer 2.x behavior
   * as the implementations will need to differ from the callbacks required
   * by the 1.x Templatizer API due to changes in the `TemplateInstance` API
   * between versions 1.x and 2.x.
   *
   * @polymerBehavior
   * @memberof Polymer
   */
  var Templatizer = {

    /**
     * Generates an anonymous `TemplateInstance` class (stored as `this.ctor`)
     * for the provided template.  This method should be called once per
     * template to prepare an element for stamping the template, followed
     * by `stamp` to create new instances of the template.
     *
     * @param {HTMLTemplateElement} template Template to prepare
     * @param {boolean=} mutableData When `true`, the generated class will skip
     *   strict dirty-checking for objects and arrays (always consider them to
     *   be "dirty"). Defaults to false.
     * @this {TemplatizerUser}
     */
    templatize: function templatize(template, mutableData) {
      this._templatizerTemplate = template;
      this.ctor = Polymer.Templatize.templatize(template, this, {
        mutableData: Boolean(mutableData),
        parentModel: this._parentModel,
        instanceProps: this._instanceProps,
        forwardHostProp: this._forwardHostPropV2,
        notifyInstanceProp: this._notifyInstancePropV2
      });
    },


    /**
     * Creates an instance of the template prepared by `templatize`.  The object
     * returned is an instance of the anonymous class generated by `templatize`
     * whose `root` property is a document fragment containing newly cloned
     * template content, and which has property accessors corresponding to
     * properties referenced in template bindings.
     *
     * @param {Object=} model Object containing initial property values to
     *   populate into the template bindings.
     * @return {TemplateInstanceBase} Returns the created instance of
     * the template prepared by `templatize`.
     * @this {TemplatizerUser}
     */
    stamp: function stamp(model) {
      return new this.ctor(model);
    },


    /**
     * Returns the template "model" (`TemplateInstance`) associated with
     * a given element, which serves as the binding scope for the template
     * instance the element is contained in.  A template model should be used
     * to manipulate data associated with this template instance.
     *
     * @param {HTMLElement} el Element for which to return a template model.
     * @return {TemplateInstanceBase} Model representing the binding scope for
     *   the element.
     * @this {TemplatizerUser}
     */
    modelForElement: function modelForElement(el) {
      return Polymer.Templatize.modelForElement(this._templatizerTemplate, el);
    }
  };

  Polymer.Templatizer = Templatizer;
})();

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

__webpack_require__(1);

__webpack_require__(11);

__webpack_require__(9);

__webpack_require__(23);

(function () {
  'use strict';

  /**
   * @constructor
   * @extends {HTMLElement}
   * @implements {Polymer_PropertyEffects}
   * @implements {Polymer_OptionalMutableData}
   * @implements {Polymer_GestureEventListeners}
   */

  var domBindBase = Polymer.GestureEventListeners(Polymer.OptionalMutableData(Polymer.PropertyEffects(HTMLElement)));

  /**
   * Custom element to allow using Polymer's template features (data binding,
   * declarative event listeners, etc.) in the main document without defining
   * a new custom element.
   *
   * `<template>` tags utilizing bindings may be wrapped with the `<dom-bind>`
   * element, which will immediately stamp the wrapped template into the main
   * document and bind elements to the `dom-bind` element itself as the
   * binding scope.
   *
   * @polymer
   * @customElement
   * @appliesMixin Polymer.PropertyEffects
   * @appliesMixin Polymer.OptionalMutableData
   * @appliesMixin Polymer.GestureEventListeners
   * @extends {domBindBase}
   * @memberof Polymer
   * @summary Custom element to allow using Polymer's template features (data
   *   binding, declarative event listeners, etc.) in the main document.
   */

  var DomBind = function (_domBindBase) {
    _inherits(DomBind, _domBindBase);

    _createClass(DomBind, null, [{
      key: 'observedAttributes',
      get: function get() {
        return ['mutable-data'];
      }
    }]);

    function DomBind() {
      _classCallCheck(this, DomBind);

      var _this = _possibleConstructorReturn(this, (DomBind.__proto__ || Object.getPrototypeOf(DomBind)).call(this));

      _this.root = null;
      _this.$ = null;
      _this.__children = null;
      return _this;
    }

    // assumes only one observed attribute


    _createClass(DomBind, [{
      key: 'attributeChangedCallback',
      value: function attributeChangedCallback() {
        this.mutableData = true;
      }
    }, {
      key: 'connectedCallback',
      value: function connectedCallback() {
        this.render();
      }
    }, {
      key: 'disconnectedCallback',
      value: function disconnectedCallback() {
        this.__removeChildren();
      }
    }, {
      key: '__insertChildren',
      value: function __insertChildren() {
        this.parentNode.insertBefore(this.root, this);
      }
    }, {
      key: '__removeChildren',
      value: function __removeChildren() {
        if (this.__children) {
          for (var i = 0; i < this.__children.length; i++) {
            this.root.appendChild(this.__children[i]);
          }
        }
      }

      /**
       * Forces the element to render its content. This is typically only
       * necessary to call if HTMLImports with the async attribute are used.
       */

    }, {
      key: 'render',
      value: function render() {
        var _this2 = this;

        var template = void 0;
        if (!this.__children) {
          template = /** @type {HTMLTemplateElement} */template || this.querySelector('template');
          if (!template) {
            // Wait until childList changes and template should be there by then
            var observer = new MutationObserver(function () {
              template = /** @type {HTMLTemplateElement} */_this2.querySelector('template');
              if (template) {
                observer.disconnect();
                _this2.render();
              } else {
                throw new Error('dom-bind requires a <template> child');
              }
            });
            observer.observe(this, { childList: true });
            return;
          }
          this.root = this._stampTemplate(template);
          this.$ = this.root.$;
          this.__children = [];
          for (var n = this.root.firstChild; n; n = n.nextSibling) {
            this.__children[this.__children.length] = n;
          }
          this._enableProperties();
        }
        this.__insertChildren();
        this.dispatchEvent(new CustomEvent('dom-change', {
          bubbles: true,
          composed: true
        }));
      }
    }]);

    return DomBind;
  }(domBindBase);

  customElements.define('dom-bind', DomBind);
})();

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

__webpack_require__(6);

__webpack_require__(14);

__webpack_require__(12);

__webpack_require__(13);

__webpack_require__(9);

(function () {
  'use strict';

  var TemplateInstanceBase = Polymer.TemplateInstanceBase; // eslint-disable-line

  /**
   * @constructor
   * @implements {Polymer_OptionalMutableData}
   * @extends {Polymer.Element}
   */
  var domRepeatBase = Polymer.OptionalMutableData(Polymer.Element);

  /**
   * The `<dom-repeat>` element will automatically stamp and binds one instance
   * of template content to each object in a user-provided array.
   * `dom-repeat` accepts an `items` property, and one instance of the template
   * is stamped for each item into the DOM at the location of the `dom-repeat`
   * element.  The `item` property will be set on each instance's binding
   * scope, thus templates should bind to sub-properties of `item`.
   *
   * Example:
   *
   * ```html
   * <dom-module id="employee-list">
   *
   *   <template>
   *
   *     <div> Employee list: </div>
   *     <template is="dom-repeat" items="{{employees}}">
   *         <div>First name: <span>{{item.first}}</span></div>
   *         <div>Last name: <span>{{item.last}}</span></div>
   *     </template>
   *
   *   </template>
   *
   *   <script>
   *     Polymer({
   *       is: 'employee-list',
   *       ready: function() {
   *         this.employees = [
   *             {first: 'Bob', last: 'Smith'},
   *             {first: 'Sally', last: 'Johnson'},
   *             ...
   *         ];
   *       }
   *     });
   *   < /script>
   *
   * </dom-module>
   * ```
   *
   * Notifications for changes to items sub-properties will be forwarded to template
   * instances, which will update via the normal structured data notification system.
   *
   * Mutations to the `items` array itself should be made using the Array
   * mutation API's on `Polymer.Base` (`push`, `pop`, `splice`, `shift`,
   * `unshift`), and template instances will be kept in sync with the data in the
   * array.
   *
   * Events caught by event handlers within the `dom-repeat` template will be
   * decorated with a `model` property, which represents the binding scope for
   * each template instance.  The model is an instance of Polymer.Base, and should
   * be used to manipulate data on the instance, for example
   * `event.model.set('item.checked', true);`.
   *
   * Alternatively, the model for a template instance for an element stamped by
   * a `dom-repeat` can be obtained using the `modelForElement` API on the
   * `dom-repeat` that stamped it, for example
   * `this.$.domRepeat.modelForElement(event.target).set('item.checked', true);`.
   * This may be useful for manipulating instance data of event targets obtained
   * by event handlers on parents of the `dom-repeat` (event delegation).
   *
   * A view-specific filter/sort may be applied to each `dom-repeat` by supplying a
   * `filter` and/or `sort` property.  This may be a string that names a function on
   * the host, or a function may be assigned to the property directly.  The functions
   * should implemented following the standard `Array` filter/sort API.
   *
   * In order to re-run the filter or sort functions based on changes to sub-fields
   * of `items`, the `observe` property may be set as a space-separated list of
   * `item` sub-fields that should cause a re-filter/sort when modified.  If
   * the filter or sort function depends on properties not contained in `items`,
   * the user should observe changes to those properties and call `render` to update
   * the view based on the dependency change.
   *
   * For example, for an `dom-repeat` with a filter of the following:
   *
   * ```js
   * isEngineer: function(item) {
   *     return item.type == 'engineer' || item.manager.type == 'engineer';
   * }
   * ```
   *
   * Then the `observe` property should be configured as follows:
   *
   * ```html
   * <template is="dom-repeat" items="{{employees}}"
   *           filter="isEngineer" observe="type manager.type">
   * ```
   *
   * @customElement
   * @polymer
   * @memberof Polymer
   * @extends {domRepeatBase}
   * @appliesMixin Polymer.OptionalMutableData
   * @summary Custom element for stamping instance of a template bound to
   *   items in an array.
   */

  var DomRepeat = function (_domRepeatBase) {
    _inherits(DomRepeat, _domRepeatBase);

    _createClass(DomRepeat, null, [{
      key: 'is',


      // Not needed to find template; can be removed once the analyzer
      // can find the tag name from customElements.define call
      get: function get() {
        return 'dom-repeat';
      }
    }, {
      key: 'template',
      get: function get() {
        return null;
      }
    }, {
      key: 'properties',
      get: function get() {

        /**
         * Fired whenever DOM is added or removed by this template (by
         * default, rendering occurs lazily).  To force immediate rendering, call
         * `render`.
         *
         * @event dom-change
         */
        return {

          /**
           * An array containing items determining how many instances of the template
           * to stamp and that that each template instance should bind to.
           */
          items: {
            type: Array
          },

          /**
           * The name of the variable to add to the binding scope for the array
           * element associated with a given template instance.
           */
          as: {
            type: String,
            value: 'item'
          },

          /**
           * The name of the variable to add to the binding scope with the index
           * of the instance in the sorted and filtered list of rendered items.
           * Note, for the index in the `this.items` array, use the value of the
           * `itemsIndexAs` property.
           */
          indexAs: {
            type: String,
            value: 'index'
          },

          /**
           * The name of the variable to add to the binding scope with the index
           * of the instance in the `this.items` array. Note, for the index of
           * this instance in the sorted and filtered list of rendered items,
           * use the value of the `indexAs` property.
           */
          itemsIndexAs: {
            type: String,
            value: 'itemsIndex'
          },

          /**
           * A function that should determine the sort order of the items.  This
           * property should either be provided as a string, indicating a method
           * name on the element's host, or else be an actual function.  The
           * function should match the sort function passed to `Array.sort`.
           * Using a sort function has no effect on the underlying `items` array.
           */
          sort: {
            type: Function,
            observer: '__sortChanged'
          },

          /**
           * A function that can be used to filter items out of the view.  This
           * property should either be provided as a string, indicating a method
           * name on the element's host, or else be an actual function.  The
           * function should match the sort function passed to `Array.filter`.
           * Using a filter function has no effect on the underlying `items` array.
           */
          filter: {
            type: Function,
            observer: '__filterChanged'
          },

          /**
           * When using a `filter` or `sort` function, the `observe` property
           * should be set to a space-separated list of the names of item
           * sub-fields that should trigger a re-sort or re-filter when changed.
           * These should generally be fields of `item` that the sort or filter
           * function depends on.
           */
          observe: {
            type: String,
            observer: '__observeChanged'
          },

          /**
           * When using a `filter` or `sort` function, the `delay` property
           * determines a debounce time after a change to observed item
           * properties that must pass before the filter or sort is re-run.
           * This is useful in rate-limiting shuffing of the view when
           * item changes may be frequent.
           */
          delay: Number,

          /**
           * Count of currently rendered items after `filter` (if any) has been applied.
           * If "chunking mode" is enabled, `renderedItemCount` is updated each time a
           * set of template instances is rendered.
           *
           */
          renderedItemCount: {
            type: Number,
            notify: true,
            readOnly: true
          },

          /**
           * Defines an initial count of template instances to render after setting
           * the `items` array, before the next paint, and puts the `dom-repeat`
           * into "chunking mode".  The remaining items will be created and rendered
           * incrementally at each animation frame therof until all instances have
           * been rendered.
           */
          initialCount: {
            type: Number,
            observer: '__initializeChunking'
          },

          /**
           * When `initialCount` is used, this property defines a frame rate to
           * target by throttling the number of instances rendered each frame to
           * not exceed the budget for the target frame rate.  Setting this to a
           * higher number will allow lower latency and higher throughput for
           * things like event handlers, but will result in a longer time for the
           * remaining items to complete rendering.
           */
          targetFramerate: {
            type: Number,
            value: 20
          },

          _targetFrameTime: {
            type: Number,
            computed: '__computeFrameTime(targetFramerate)'
          }

        };
      }
    }, {
      key: 'observers',
      get: function get() {
        return ['__itemsChanged(items.*)'];
      }
    }]);

    function DomRepeat() {
      _classCallCheck(this, DomRepeat);

      var _this = _possibleConstructorReturn(this, (DomRepeat.__proto__ || Object.getPrototypeOf(DomRepeat)).call(this));

      _this.__instances = [];
      _this.__limit = Infinity;
      _this.__pool = [];
      _this.__renderDebouncer = null;
      _this.__itemsIdxToInstIdx = {};
      _this.__chunkCount = null;
      _this.__lastChunkTime = null;
      _this.__sortFn = null;
      _this.__filterFn = null;
      _this.__observePaths = null;
      _this.__ctor = null;
      _this.__isDetached = true;
      _this.template = null;
      return _this;
    }

    _createClass(DomRepeat, [{
      key: 'disconnectedCallback',
      value: function disconnectedCallback() {
        _get(DomRepeat.prototype.__proto__ || Object.getPrototypeOf(DomRepeat.prototype), 'disconnectedCallback', this).call(this);
        this.__isDetached = true;
        for (var i = 0; i < this.__instances.length; i++) {
          this.__detachInstance(i);
        }
      }
    }, {
      key: 'connectedCallback',
      value: function connectedCallback() {
        _get(DomRepeat.prototype.__proto__ || Object.getPrototypeOf(DomRepeat.prototype), 'connectedCallback', this).call(this);
        // only perform attachment if the element was previously detached.
        if (this.__isDetached) {
          this.__isDetached = false;
          var parent = this.parentNode;
          for (var i = 0; i < this.__instances.length; i++) {
            this.__attachInstance(i, parent);
          }
        }
      }
    }, {
      key: '__ensureTemplatized',
      value: function __ensureTemplatized() {
        var _this2 = this;

        // Templatizing (generating the instance constructor) needs to wait
        // until ready, since won't have its template content handed back to
        // it until then
        if (!this.__ctor) {
          var template = this.template = this.querySelector('template');
          if (!template) {
            // // Wait until childList changes and template should be there by then
            var observer = new MutationObserver(function () {
              if (_this2.querySelector('template')) {
                observer.disconnect();
                _this2.__render();
              } else {
                throw new Error('dom-repeat requires a <template> child');
              }
            });
            observer.observe(this, { childList: true });
            return false;
          }
          // Template instance props that should be excluded from forwarding
          var instanceProps = {};
          instanceProps[this.as] = true;
          instanceProps[this.indexAs] = true;
          instanceProps[this.itemsIndexAs] = true;
          this.__ctor = Polymer.Templatize.templatize(template, this, {
            mutableData: this.mutableData,
            parentModel: true,
            instanceProps: instanceProps,
            /**
             * @this {this}
             * @param {string} prop Property to set
             * @param {*} value Value to set property to
             */
            forwardHostProp: function forwardHostProp(prop, value) {
              var i$ = this.__instances;
              for (var i = 0, inst; i < i$.length && (inst = i$[i]); i++) {
                inst.forwardHostProp(prop, value);
              }
            },
            /**
             * @this {this}
             * @param {Object} inst Instance to notify
             * @param {string} prop Property to notify
             * @param {*} value Value to notify
             */
            notifyInstanceProp: function notifyInstanceProp(inst, prop, value) {
              if (Polymer.Path.matches(this.as, prop)) {
                var idx = inst[this.itemsIndexAs];
                if (prop == this.as) {
                  this.items[idx] = value;
                }
                var path = Polymer.Path.translate(this.as, 'items.' + idx, prop);
                this.notifyPath(path, value);
              }
            }
          });
        }
        return true;
      }
    }, {
      key: '__getMethodHost',
      value: function __getMethodHost() {
        // Technically this should be the owner of the outermost template.
        // In shadow dom, this is always getRootNode().host, but we can
        // approximate this via cooperation with our dataHost always setting
        // `_methodHost` as long as there were bindings (or id's) on this
        // instance causing it to get a dataHost.
        return this.__dataHost._methodHost || this.__dataHost;
      }
    }, {
      key: '__sortChanged',
      value: function __sortChanged(sort) {
        var methodHost = this.__getMethodHost();
        this.__sortFn = sort && (typeof sort == 'function' ? sort : function () {
          return methodHost[sort].apply(methodHost, arguments);
        });
        if (this.items) {
          this.__debounceRender(this.__render);
        }
      }
    }, {
      key: '__filterChanged',
      value: function __filterChanged(filter) {
        var methodHost = this.__getMethodHost();
        this.__filterFn = filter && (typeof filter == 'function' ? filter : function () {
          return methodHost[filter].apply(methodHost, arguments);
        });
        if (this.items) {
          this.__debounceRender(this.__render);
        }
      }
    }, {
      key: '__computeFrameTime',
      value: function __computeFrameTime(rate) {
        return Math.ceil(1000 / rate);
      }
    }, {
      key: '__initializeChunking',
      value: function __initializeChunking() {
        if (this.initialCount) {
          this.__limit = this.initialCount;
          this.__chunkCount = this.initialCount;
          this.__lastChunkTime = performance.now();
        }
      }
    }, {
      key: '__tryRenderChunk',
      value: function __tryRenderChunk() {
        // Debounced so that multiple calls through `_render` between animation
        // frames only queue one new rAF (e.g. array mutation & chunked render)
        if (this.items && this.__limit < this.items.length) {
          this.__debounceRender(this.__requestRenderChunk);
        }
      }
    }, {
      key: '__requestRenderChunk',
      value: function __requestRenderChunk() {
        var _this3 = this;

        requestAnimationFrame(function () {
          return _this3.__renderChunk();
        });
      }
    }, {
      key: '__renderChunk',
      value: function __renderChunk() {
        // Simple auto chunkSize throttling algorithm based on feedback loop:
        // measure actual time between frames and scale chunk count by ratio
        // of target/actual frame time
        var currChunkTime = performance.now();
        var ratio = this._targetFrameTime / (currChunkTime - this.__lastChunkTime);
        this.__chunkCount = Math.round(this.__chunkCount * ratio) || 1;
        this.__limit += this.__chunkCount;
        this.__lastChunkTime = currChunkTime;
        this.__debounceRender(this.__render);
      }
    }, {
      key: '__observeChanged',
      value: function __observeChanged() {
        this.__observePaths = this.observe && this.observe.replace('.*', '.').split(' ');
      }
    }, {
      key: '__itemsChanged',
      value: function __itemsChanged(change) {
        if (this.items && !Array.isArray(this.items)) {
          console.warn('dom-repeat expected array for `items`, found', this.items);
        }
        // If path was to an item (e.g. 'items.3' or 'items.3.foo'), forward the
        // path to that instance synchronously (retuns false for non-item paths)
        if (!this.__handleItemPath(change.path, change.value)) {
          // Otherwise, the array was reset ('items') or spliced ('items.splices'),
          // so queue a full refresh
          this.__initializeChunking();
          this.__debounceRender(this.__render);
        }
      }
    }, {
      key: '__handleObservedPaths',
      value: function __handleObservedPaths(path) {
        if (this.__observePaths) {
          path = path.substring(path.indexOf('.') + 1);
          var paths = this.__observePaths;
          for (var i = 0; i < paths.length; i++) {
            if (path.indexOf(paths[i]) === 0) {
              this.__debounceRender(this.__render, this.delay);
              return true;
            }
          }
        }
      }

      /**
       * @param {function(this:DomRepeat)} fn Function to debounce.
       * @param {number=} delay Delay in ms to debounce by.
       */

    }, {
      key: '__debounceRender',
      value: function __debounceRender(fn) {
        var delay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

        this.__renderDebouncer = Polymer.Debouncer.debounce(this.__renderDebouncer, delay > 0 ? Polymer.Async.timeOut.after(delay) : Polymer.Async.microTask, fn.bind(this));
        Polymer.enqueueDebouncer(this.__renderDebouncer);
      }

      /**
       * Forces the element to render its content. Normally rendering is
       * asynchronous to a provoking change. This is done for efficiency so
       * that multiple changes trigger only a single render. The render method
       * should be called if, for example, template rendering is required to
       * validate application state.
       */

    }, {
      key: 'render',
      value: function render() {
        // Queue this repeater, then flush all in order
        this.__debounceRender(this.__render);
        Polymer.flush();
      }
    }, {
      key: '__render',
      value: function __render() {
        if (!this.__ensureTemplatized()) {
          // No template found yet
          return;
        }
        this.__applyFullRefresh();
        // Reset the pool
        // TODO(kschaaf): Reuse pool across turns and nested templates
        // Now that objects/arrays are re-evaluated when set, we can safely
        // reuse pooled instances across turns, however we still need to decide
        // semantics regarding how long to hold, how many to hold, etc.
        this.__pool.length = 0;
        // Set rendered item count
        this._setRenderedItemCount(this.__instances.length);
        // Notify users
        this.dispatchEvent(new CustomEvent('dom-change', {
          bubbles: true,
          composed: true
        }));
        // Check to see if we need to render more items
        this.__tryRenderChunk();
      }
    }, {
      key: '__applyFullRefresh',
      value: function __applyFullRefresh() {
        var _this4 = this;

        var items = this.items || [];
        var isntIdxToItemsIdx = new Array(items.length);
        for (var i = 0; i < items.length; i++) {
          isntIdxToItemsIdx[i] = i;
        }
        // Apply user filter
        if (this.__filterFn) {
          isntIdxToItemsIdx = isntIdxToItemsIdx.filter(function (i, idx, array) {
            return _this4.__filterFn(items[i], idx, array);
          });
        }
        // Apply user sort
        if (this.__sortFn) {
          isntIdxToItemsIdx.sort(function (a, b) {
            return _this4.__sortFn(items[a], items[b]);
          });
        }
        // items->inst map kept for item path forwarding
        var itemsIdxToInstIdx = this.__itemsIdxToInstIdx = {};
        var instIdx = 0;
        // Generate instances and assign items
        var limit = Math.min(isntIdxToItemsIdx.length, this.__limit);
        for (; instIdx < limit; instIdx++) {
          var inst = this.__instances[instIdx];
          var itemIdx = isntIdxToItemsIdx[instIdx];
          var item = items[itemIdx];
          itemsIdxToInstIdx[itemIdx] = instIdx;
          if (inst && instIdx < this.__limit) {
            inst._setPendingProperty(this.as, item);
            inst._setPendingProperty(this.indexAs, instIdx);
            inst._setPendingProperty(this.itemsIndexAs, itemIdx);
            inst._flushProperties();
          } else {
            this.__insertInstance(item, instIdx, itemIdx);
          }
        }
        // Remove any extra instances from previous state
        for (var _i = this.__instances.length - 1; _i >= instIdx; _i--) {
          this.__detachAndRemoveInstance(_i);
        }
      }
    }, {
      key: '__detachInstance',
      value: function __detachInstance(idx) {
        var inst = this.__instances[idx];
        for (var i = 0; i < inst.children.length; i++) {
          var el = inst.children[i];
          inst.root.appendChild(el);
        }
        return inst;
      }
    }, {
      key: '__attachInstance',
      value: function __attachInstance(idx, parent) {
        var inst = this.__instances[idx];
        parent.insertBefore(inst.root, this);
      }
    }, {
      key: '__detachAndRemoveInstance',
      value: function __detachAndRemoveInstance(idx) {
        var inst = this.__detachInstance(idx);
        if (inst) {
          this.__pool.push(inst);
        }
        this.__instances.splice(idx, 1);
      }
    }, {
      key: '__stampInstance',
      value: function __stampInstance(item, instIdx, itemIdx) {
        var model = {};
        model[this.as] = item;
        model[this.indexAs] = instIdx;
        model[this.itemsIndexAs] = itemIdx;
        return new this.__ctor(model);
      }
    }, {
      key: '__insertInstance',
      value: function __insertInstance(item, instIdx, itemIdx) {
        var inst = this.__pool.pop();
        if (inst) {
          // TODO(kschaaf): If the pool is shared across turns, hostProps
          // need to be re-set to reused instances in addition to item
          inst._setPendingProperty(this.as, item);
          inst._setPendingProperty(this.indexAs, instIdx);
          inst._setPendingProperty(this.itemsIndexAs, itemIdx);
          inst._flushProperties();
        } else {
          inst = this.__stampInstance(item, instIdx, itemIdx);
        }
        var beforeRow = this.__instances[instIdx + 1];
        var beforeNode = beforeRow ? beforeRow.children[0] : this;
        this.parentNode.insertBefore(inst.root, beforeNode);
        this.__instances[instIdx] = inst;
        return inst;
      }

      // Implements extension point from Templatize mixin

    }, {
      key: '_showHideChildren',
      value: function _showHideChildren(hidden) {
        for (var i = 0; i < this.__instances.length; i++) {
          this.__instances[i]._showHideChildren(hidden);
        }
      }

      // Called as a side effect of a host items.<key>.<path> path change,
      // responsible for notifying item.<path> changes to inst for key

    }, {
      key: '__handleItemPath',
      value: function __handleItemPath(path, value) {
        var itemsPath = path.slice(6); // 'items.'.length == 6
        var dot = itemsPath.indexOf('.');
        var itemsIdx = dot < 0 ? itemsPath : itemsPath.substring(0, dot);
        // If path was index into array...
        if (itemsIdx == parseInt(itemsIdx, 10)) {
          var itemSubPath = dot < 0 ? '' : itemsPath.substring(dot + 1);
          // If the path is observed, it will trigger a full refresh
          this.__handleObservedPaths(itemSubPath);
          // Note, even if a rull refresh is triggered, always do the path
          // notification because unless mutableData is used for dom-repeat
          // and all elements in the instance subtree, a full refresh may
          // not trigger the proper update.
          var instIdx = this.__itemsIdxToInstIdx[itemsIdx];
          var inst = this.__instances[instIdx];
          if (inst) {
            var itemPath = this.as + (itemSubPath ? '.' + itemSubPath : '');
            // This is effectively `notifyPath`, but avoids some of the overhead
            // of the public API
            inst._setPendingPropertyOrPath(itemPath, value, false, true);
            inst._flushProperties();
          }
          return true;
        }
      }

      /**
       * Returns the item associated with a given element stamped by
       * this `dom-repeat`.
       *
       * Note, to modify sub-properties of the item,
       * `modelForElement(el).set('item.<sub-prop>', value)`
       * should be used.
       *
       * @param {HTMLElement} el Element for which to return the item.
       * @return {*} Item associated with the element.
       */

    }, {
      key: 'itemForElement',
      value: function itemForElement(el) {
        var instance = this.modelForElement(el);
        return instance && instance[this.as];
      }

      /**
       * Returns the inst index for a given element stamped by this `dom-repeat`.
       * If `sort` is provided, the index will reflect the sorted order (rather
       * than the original array order).
       *
       * @param {HTMLElement} el Element for which to return the index.
       * @return {*} Row index associated with the element (note this may
       *   not correspond to the array index if a user `sort` is applied).
       */

    }, {
      key: 'indexForElement',
      value: function indexForElement(el) {
        var instance = this.modelForElement(el);
        return instance && instance[this.indexAs];
      }

      /**
       * Returns the template "model" associated with a given element, which
       * serves as the binding scope for the template instance the element is
       * contained in. A template model is an instance of `Polymer.Base`, and
       * should be used to manipulate data associated with this template instance.
       *
       * Example:
       *
       *   let model = modelForElement(el);
       *   if (model.index < 10) {
       *     model.set('item.checked', true);
       *   }
       *
       * @param {HTMLElement} el Element for which to return a template model.
       * @return {TemplateInstanceBase} Model representing the binding scope for
       *   the element.
       */

    }, {
      key: 'modelForElement',
      value: function modelForElement(el) {
        return Polymer.Templatize.modelForElement(this.template, el);
      }
    }]);

    return DomRepeat;
  }(domRepeatBase);

  customElements.define(DomRepeat.is, DomRepeat);

  Polymer.DomRepeat = DomRepeat;
})();

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

__webpack_require__(6);

__webpack_require__(14);

__webpack_require__(12);

__webpack_require__(13);

(function () {
  'use strict';

  /**
   * The `<dom-if>` element will stamp a light-dom `<template>` child when
   * the `if` property becomes truthy, and the template can use Polymer
   * data-binding and declarative event features when used in the context of
   * a Polymer element's template.
   *
   * When `if` becomes falsey, the stamped content is hidden but not
   * removed from dom. When `if` subsequently becomes truthy again, the content
   * is simply re-shown. This approach is used due to its favorable performance
   * characteristics: the expense of creating template content is paid only
   * once and lazily.
   *
   * Set the `restamp` property to true to force the stamped content to be
   * created / destroyed when the `if` condition changes.
   *
   * @customElement
   * @polymer
   * @extends Polymer.Element
   * @memberof Polymer
   * @summary Custom element that conditionally stamps and hides or removes
   *   template content based on a boolean flag.
   */

  var DomIf = function (_Polymer$Element) {
    _inherits(DomIf, _Polymer$Element);

    _createClass(DomIf, null, [{
      key: 'is',


      // Not needed to find template; can be removed once the analyzer
      // can find the tag name from customElements.define call
      get: function get() {
        return 'dom-if';
      }
    }, {
      key: 'template',
      get: function get() {
        return null;
      }
    }, {
      key: 'properties',
      get: function get() {

        return {

          /**
           * Fired whenever DOM is added or removed/hidden by this template (by
           * default, rendering occurs lazily).  To force immediate rendering, call
           * `render`.
           *
           * @event dom-change
           */

          /**
           * A boolean indicating whether this template should stamp.
           */
          if: {
            type: Boolean,
            observer: '__debounceRender'
          },

          /**
           * When true, elements will be removed from DOM and discarded when `if`
           * becomes false and re-created and added back to the DOM when `if`
           * becomes true.  By default, stamped elements will be hidden but left
           * in the DOM when `if` becomes false, which is generally results
           * in better performance.
           */
          restamp: {
            type: Boolean,
            observer: '__debounceRender'
          }

        };
      }
    }]);

    function DomIf() {
      _classCallCheck(this, DomIf);

      var _this = _possibleConstructorReturn(this, (DomIf.__proto__ || Object.getPrototypeOf(DomIf)).call(this));

      _this.__renderDebouncer = null;
      _this.__invalidProps = null;
      _this.__instance = null;
      _this._lastIf = false;
      _this.__ctor = null;
      return _this;
    }

    _createClass(DomIf, [{
      key: '__debounceRender',
      value: function __debounceRender() {
        var _this2 = this;

        // Render is async for 2 reasons:
        // 1. To eliminate dom creation trashing if user code thrashes `if` in the
        //    same turn. This was more common in 1.x where a compound computed
        //    property could result in the result changing multiple times, but is
        //    mitigated to a large extent by batched property processing in 2.x.
        // 2. To avoid double object propagation when a bag including values bound
        //    to the `if` property as well as one or more hostProps could enqueue
        //    the <dom-if> to flush before the <template>'s host property
        //    forwarding. In that scenario creating an instance would result in
        //    the host props being set once, and then the enqueued changes on the
        //    template would set properties a second time, potentially causing an
        //    object to be set to an instance more than once.  Creating the
        //    instance async from flushing data ensures this doesn't happen. If
        //    we wanted a sync option in the future, simply having <dom-if> flush
        //    (or clear) its template's pending host properties before creating
        //    the instance would also avoid the problem.
        this.__renderDebouncer = Polymer.Debouncer.debounce(this.__renderDebouncer, Polymer.Async.microTask, function () {
          return _this2.__render();
        });
        Polymer.enqueueDebouncer(this.__renderDebouncer);
      }
    }, {
      key: 'disconnectedCallback',
      value: function disconnectedCallback() {
        _get(DomIf.prototype.__proto__ || Object.getPrototypeOf(DomIf.prototype), 'disconnectedCallback', this).call(this);
        if (!this.parentNode || this.parentNode.nodeType == Node.DOCUMENT_FRAGMENT_NODE && !this.parentNode.host) {
          this.__teardownInstance();
        }
      }
    }, {
      key: 'connectedCallback',
      value: function connectedCallback() {
        _get(DomIf.prototype.__proto__ || Object.getPrototypeOf(DomIf.prototype), 'connectedCallback', this).call(this);
        if (this.if) {
          this.__debounceRender();
        }
      }

      /**
       * Forces the element to render its content. Normally rendering is
       * asynchronous to a provoking change. This is done for efficiency so
       * that multiple changes trigger only a single render. The render method
       * should be called if, for example, template rendering is required to
       * validate application state.
       */

    }, {
      key: 'render',
      value: function render() {
        Polymer.flush();
      }
    }, {
      key: '__render',
      value: function __render() {
        if (this.if) {
          if (!this.__ensureInstance()) {
            // No template found yet
            return;
          }
          this._showHideChildren();
        } else if (this.restamp) {
          this.__teardownInstance();
        }
        if (!this.restamp && this.__instance) {
          this._showHideChildren();
        }
        if (this.if != this._lastIf) {
          this.dispatchEvent(new CustomEvent('dom-change', {
            bubbles: true,
            composed: true
          }));
          this._lastIf = this.if;
        }
      }
    }, {
      key: '__ensureInstance',
      value: function __ensureInstance() {
        var _this3 = this;

        var parentNode = this.parentNode;
        // Guard against element being detached while render was queued
        if (parentNode) {
          if (!this.__ctor) {
            var template = this.querySelector('template');
            if (!template) {
              // Wait until childList changes and template should be there by then
              var observer = new MutationObserver(function () {
                if (_this3.querySelector('template')) {
                  observer.disconnect();
                  _this3.__render();
                } else {
                  throw new Error('dom-if requires a <template> child');
                }
              });
              observer.observe(this, { childList: true });
              return false;
            }
            this.__ctor = Polymer.Templatize.templatize(template, this, {
              // dom-if templatizer instances require `mutable: true`, as
              // `__syncHostProperties` relies on that behavior to sync objects
              mutableData: true,
              /**
               * @param {string} prop Property to forward
               * @param {*} value Value of property
               * @this {this}
               */
              forwardHostProp: function forwardHostProp(prop, value) {
                if (this.__instance) {
                  if (this.if) {
                    this.__instance.forwardHostProp(prop, value);
                  } else {
                    // If we have an instance but are squelching host property
                    // forwarding due to if being false, note the invalidated
                    // properties so `__syncHostProperties` can sync them the next
                    // time `if` becomes true
                    this.__invalidProps = this.__invalidProps || Object.create(null);
                    this.__invalidProps[Polymer.Path.root(prop)] = true;
                  }
                }
              }
            });
          }
          if (!this.__instance) {
            this.__instance = new this.__ctor();
            parentNode.insertBefore(this.__instance.root, this);
          } else {
            this.__syncHostProperties();
            var c$ = this.__instance.children;
            if (c$ && c$.length) {
              // Detect case where dom-if was re-attached in new position
              var lastChild = this.previousSibling;
              if (lastChild !== c$[c$.length - 1]) {
                for (var i = 0, n; i < c$.length && (n = c$[i]); i++) {
                  parentNode.insertBefore(n, this);
                }
              }
            }
          }
        }
        return true;
      }
    }, {
      key: '__syncHostProperties',
      value: function __syncHostProperties() {
        var props = this.__invalidProps;
        if (props) {
          for (var prop in props) {
            this.__instance._setPendingProperty(prop, this.__dataHost[prop]);
          }
          this.__invalidProps = null;
          this.__instance._flushProperties();
        }
      }
    }, {
      key: '__teardownInstance',
      value: function __teardownInstance() {
        if (this.__instance) {
          var c$ = this.__instance.children;
          if (c$ && c$.length) {
            // use first child parent, for case when dom-if may have been detached
            var parent = c$[0].parentNode;
            for (var i = 0, n; i < c$.length && (n = c$[i]); i++) {
              parent.removeChild(n);
            }
          }
          this.__instance = null;
          this.__invalidProps = null;
        }
      }
    }, {
      key: '_showHideChildren',
      value: function _showHideChildren() {
        var hidden = this.__hideTemplateChildren__ || !this.if;
        if (this.__instance) {
          this.__instance._showHideChildren(hidden);
        }
      }
    }]);

    return DomIf;
  }(Polymer.Element);

  customElements.define(DomIf.is, DomIf);

  Polymer.DomIf = DomIf;
})();

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

__webpack_require__(6);

__webpack_require__(3);

__webpack_require__(24);

(function () {
  'use strict';

  /**
   * Element mixin for recording dynamic associations between item paths in a
   * master `items` array and a `selected` array such that path changes to the
   * master array (at the host) element or elsewhere via data-binding) are
   * correctly propagated to items in the selected array and vice-versa.
   *
   * The `items` property accepts an array of user data, and via the
   * `select(item)` and `deselect(item)` API, updates the `selected` property
   * which may be bound to other parts of the application, and any changes to
   * sub-fields of `selected` item(s) will be kept in sync with items in the
   * `items` array.  When `multi` is false, `selected` is a property
   * representing the last selected item.  When `multi` is true, `selected`
   * is an array of multiply selected items.
   *
   * @polymer
   * @mixinFunction
   * @appliesMixin Polymer.ElementMixin
   * @memberof Polymer
   * @summary Element mixin for recording dynamic associations between item paths in a
   * master `items` array and a `selected` array
   */

  var ArraySelectorMixin = Polymer.dedupingMixin(function (superClass) {

    /**
     * @constructor
     * @extends {superClass}
     * @implements {Polymer_ElementMixin}
     */
    var elementBase = Polymer.ElementMixin(superClass);

    /**
     * @polymer
     * @mixinClass
     * @implements {Polymer_ArraySelectorMixin}
     * @unrestricted
     */

    var ArraySelectorMixin = function (_elementBase) {
      _inherits(ArraySelectorMixin, _elementBase);

      _createClass(ArraySelectorMixin, null, [{
        key: 'properties',
        get: function get() {

          return {

            /**
             * An array containing items from which selection will be made.
             */
            items: {
              type: Array
            },

            /**
             * When `true`, multiple items may be selected at once (in this case,
             * `selected` is an array of currently selected items).  When `false`,
             * only one item may be selected at a time.
             */
            multi: {
              type: Boolean,
              value: false
            },

            /**
             * When `multi` is true, this is an array that contains any selected.
             * When `multi` is false, this is the currently selected item, or `null`
             * if no item is selected.
             * @type {?(Object|Array<!Object>)}
             */
            selected: {
              type: Object,
              notify: true
            },

            /**
             * When `multi` is false, this is the currently selected item, or `null`
             * if no item is selected.
             * @type {?Object}
             */
            selectedItem: {
              type: Object,
              notify: true
            },

            /**
             * When `true`, calling `select` on an item that is already selected
             * will deselect the item.
             */
            toggle: {
              type: Boolean,
              value: false
            }

          };
        }
      }, {
        key: 'observers',
        get: function get() {
          return ['__updateSelection(multi, items.*)'];
        }
      }]);

      function ArraySelectorMixin() {
        _classCallCheck(this, ArraySelectorMixin);

        var _this = _possibleConstructorReturn(this, (ArraySelectorMixin.__proto__ || Object.getPrototypeOf(ArraySelectorMixin)).call(this));

        _this.__lastItems = null;
        _this.__lastMulti = null;
        _this.__selectedMap = null;
        return _this;
      }

      _createClass(ArraySelectorMixin, [{
        key: '__updateSelection',
        value: function __updateSelection(multi, itemsInfo) {
          var path = itemsInfo.path;
          if (path == 'items') {
            // Case 1 - items array changed, so diff against previous array and
            // deselect any removed items and adjust selected indices
            var newItems = itemsInfo.base || [];
            var lastItems = this.__lastItems;
            var lastMulti = this.__lastMulti;
            if (multi !== lastMulti) {
              this.clearSelection();
            }
            if (lastItems) {
              var splices = Polymer.ArraySplice.calculateSplices(newItems, lastItems);
              this.__applySplices(splices);
            }
            this.__lastItems = newItems;
            this.__lastMulti = multi;
          } else if (itemsInfo.path == 'items.splices') {
            // Case 2 - got specific splice information describing the array mutation:
            // deselect any removed items and adjust selected indices
            this.__applySplices(itemsInfo.value.indexSplices);
          } else {
            // Case 3 - an array element was changed, so deselect the previous
            // item for that index if it was previously selected
            var part = path.slice('items.'.length);
            var idx = parseInt(part, 10);
            if (part.indexOf('.') < 0 && part == idx) {
              this.__deselectChangedIdx(idx);
            }
          }
        }
      }, {
        key: '__applySplices',
        value: function __applySplices(splices) {
          var _this2 = this;

          var selected = this.__selectedMap;
          // Adjust selected indices and mark removals

          var _loop = function _loop(i) {
            var s = splices[i];
            selected.forEach(function (idx, item) {
              if (idx < s.index) {
                // no change
              } else if (idx >= s.index + s.removed.length) {
                // adjust index
                selected.set(item, idx + s.addedCount - s.removed.length);
              } else {
                // remove index
                selected.set(item, -1);
              }
            });
            for (var j = 0; j < s.addedCount; j++) {
              var idx = s.index + j;
              if (selected.has(_this2.items[idx])) {
                selected.set(_this2.items[idx], idx);
              }
            }
          };

          for (var i = 0; i < splices.length; i++) {
            _loop(i);
          }
          // Update linked paths
          this.__updateLinks();
          // Remove selected items that were removed from the items array
          var sidx = 0;
          selected.forEach(function (idx, item) {
            if (idx < 0) {
              if (_this2.multi) {
                _this2.splice('selected', sidx, 1);
              } else {
                _this2.selected = _this2.selectedItem = null;
              }
              selected.delete(item);
            } else {
              sidx++;
            }
          });
        }
      }, {
        key: '__updateLinks',
        value: function __updateLinks() {
          var _this3 = this;

          this.__dataLinkedPaths = {};
          if (this.multi) {
            var sidx = 0;
            this.__selectedMap.forEach(function (idx) {
              if (idx >= 0) {
                _this3.linkPaths('items.' + idx, 'selected.' + sidx++);
              }
            });
          } else {
            this.__selectedMap.forEach(function (idx) {
              _this3.linkPaths('selected', 'items.' + idx);
              _this3.linkPaths('selectedItem', 'items.' + idx);
            });
          }
        }

        /**
         * Clears the selection state.
         *
         */

      }, {
        key: 'clearSelection',
        value: function clearSelection() {
          // Unbind previous selection
          this.__dataLinkedPaths = {};
          // The selected map stores 3 pieces of information:
          // key: items array object
          // value: items array index
          // order: selected array index
          this.__selectedMap = new Map();
          // Initialize selection
          this.selected = this.multi ? [] : null;
          this.selectedItem = null;
        }

        /**
         * Returns whether the item is currently selected.
         *
         * @param {*} item Item from `items` array to test
         * @return {boolean} Whether the item is selected
         */

      }, {
        key: 'isSelected',
        value: function isSelected(item) {
          return this.__selectedMap.has(item);
        }

        /**
         * Returns whether the item is currently selected.
         *
         * @param {number} idx Index from `items` array to test
         * @return {boolean} Whether the item is selected
         */

      }, {
        key: 'isIndexSelected',
        value: function isIndexSelected(idx) {
          return this.isSelected(this.items[idx]);
        }
      }, {
        key: '__deselectChangedIdx',
        value: function __deselectChangedIdx(idx) {
          var _this4 = this;

          var sidx = this.__selectedIndexForItemIndex(idx);
          if (sidx >= 0) {
            var i = 0;
            this.__selectedMap.forEach(function (idx, item) {
              if (sidx == i++) {
                _this4.deselect(item);
              }
            });
          }
        }
      }, {
        key: '__selectedIndexForItemIndex',
        value: function __selectedIndexForItemIndex(idx) {
          var selected = this.__dataLinkedPaths['items.' + idx];
          if (selected) {
            return parseInt(selected.slice('selected.'.length), 10);
          }
        }

        /**
         * Deselects the given item if it is already selected.
         *
         * @param {*} item Item from `items` array to deselect
         */

      }, {
        key: 'deselect',
        value: function deselect(item) {
          var idx = this.__selectedMap.get(item);
          if (idx >= 0) {
            this.__selectedMap.delete(item);
            var sidx = void 0;
            if (this.multi) {
              sidx = this.__selectedIndexForItemIndex(idx);
            }
            this.__updateLinks();
            if (this.multi) {
              this.splice('selected', sidx, 1);
            } else {
              this.selected = this.selectedItem = null;
            }
          }
        }

        /**
         * Deselects the given index if it is already selected.
         *
         * @param {number} idx Index from `items` array to deselect
         */

      }, {
        key: 'deselectIndex',
        value: function deselectIndex(idx) {
          this.deselect(this.items[idx]);
        }

        /**
         * Selects the given item.  When `toggle` is true, this will automatically
         * deselect the item if already selected.
         *
         * @param {*} item Item from `items` array to select
         */

      }, {
        key: 'select',
        value: function select(item) {
          this.selectIndex(this.items.indexOf(item));
        }

        /**
         * Selects the given index.  When `toggle` is true, this will automatically
         * deselect the item if already selected.
         *
         * @param {number} idx Index from `items` array to select
         */

      }, {
        key: 'selectIndex',
        value: function selectIndex(idx) {
          var item = this.items[idx];
          if (!this.isSelected(item)) {
            if (!this.multi) {
              this.__selectedMap.clear();
            }
            this.__selectedMap.set(item, idx);
            this.__updateLinks();
            if (this.multi) {
              this.push('selected', item);
            } else {
              this.selected = this.selectedItem = item;
            }
          } else if (this.toggle) {
            this.deselectIndex(idx);
          }
        }
      }]);

      return ArraySelectorMixin;
    }(elementBase);

    return ArraySelectorMixin;
  });

  // export mixin
  Polymer.ArraySelectorMixin = ArraySelectorMixin;

  /**
   * @constructor
   * @extends {Polymer.Element}
   * @implements {Polymer_ArraySelectorMixin}
   */
  var baseArraySelector = ArraySelectorMixin(Polymer.Element);

  /**
   * Element implementing the `Polymer.ArraySelector` mixin, which records
   * dynamic associations between item paths in a master `items` array and a
   * `selected` array such that path changes to the master array (at the host)
   * element or elsewhere via data-binding) are correctly propagated to items
   * in the selected array and vice-versa.
   *
   * The `items` property accepts an array of user data, and via the
   * `select(item)` and `deselect(item)` API, updates the `selected` property
   * which may be bound to other parts of the application, and any changes to
   * sub-fields of `selected` item(s) will be kept in sync with items in the
   * `items` array.  When `multi` is false, `selected` is a property
   * representing the last selected item.  When `multi` is true, `selected`
   * is an array of multiply selected items.
   *
   * Example:
   *
   * ```html
   * <dom-module id="employee-list">
   *
   *   <template>
   *
   *     <div> Employee list: </div>
   *     <template is="dom-repeat" id="employeeList" items="{{employees}}">
   *         <div>First name: <span>{{item.first}}</span></div>
   *         <div>Last name: <span>{{item.last}}</span></div>
   *         <button on-click="toggleSelection">Select</button>
   *     </template>
   *
   *     <array-selector id="selector" items="{{employees}}" selected="{{selected}}" multi toggle></array-selector>
   *
   *     <div> Selected employees: </div>
   *     <template is="dom-repeat" items="{{selected}}">
   *         <div>First name: <span>{{item.first}}</span></div>
   *         <div>Last name: <span>{{item.last}}</span></div>
   *     </template>
   *
   *   </template>
   *
   * </dom-module>
   * ```
   *
   * ```js
   * Polymer({
   *   is: 'employee-list',
   *   ready() {
   *     this.employees = [
   *         {first: 'Bob', last: 'Smith'},
   *         {first: 'Sally', last: 'Johnson'},
   *         ...
   *     ];
   *   },
   *   toggleSelection(e) {
   *     let item = this.$.employeeList.itemForElement(e.target);
   *     this.$.selector.select(item);
   *   }
   * });
   * ```
   *
   * @polymer
   * @customElement
   * @extends {baseArraySelector}
   * @appliesMixin Polymer.ArraySelectorMixin
   * @memberof Polymer
   * @summary Custom element that links paths between an input `items` array and
   *   an output `selected` item or array based on calls to its selection API.
   */

  var ArraySelector = function (_baseArraySelector) {
    _inherits(ArraySelector, _baseArraySelector);

    function ArraySelector() {
      _classCallCheck(this, ArraySelector);

      return _possibleConstructorReturn(this, (ArraySelector.__proto__ || Object.getPrototypeOf(ArraySelector)).apply(this, arguments));
    }

    _createClass(ArraySelector, null, [{
      key: 'is',

      // Not needed to find template; can be removed once the analyzer
      // can find the tag name from customElements.define call
      get: function get() {
        return 'array-selector';
      }
    }]);

    return ArraySelector;
  }(baseArraySelector);

  customElements.define(ArraySelector.is, ArraySelector);
  Polymer.ArraySelector = ArraySelector;
})();

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

__webpack_require__(62);

__webpack_require__(21);

(function () {
  'use strict';

  var attr = 'include';

  var CustomStyleInterface = window.ShadyCSS.CustomStyleInterface;

  /**
   * Custom element for defining styles in the main document that can take
   * advantage of several special features of Polymer's styling system:
   *
   * - Document styles defined in a custom-style are shimmed to ensure they
   *   do not leak into local DOM when running on browsers without native
   *   Shadow DOM.
   * - Custom properties used by Polymer's shim for cross-scope styling may
   *   be defined in an custom-style. Use the :root selector to define custom
   *   properties that apply to all custom elements.
   *
   * To use, simply wrap an inline `<style>` tag in the main document whose
   * CSS uses these features with a `<custom-style>` element.
   *
   * @customElement
   * @extends HTMLElement
   * @memberof Polymer
   * @summary Custom element for defining styles in the main document that can
   *   take advantage of Polymer's style scoping and custom properties shims.
   */

  var CustomStyle = function (_HTMLElement) {
    _inherits(CustomStyle, _HTMLElement);

    function CustomStyle() {
      _classCallCheck(this, CustomStyle);

      var _this = _possibleConstructorReturn(this, (CustomStyle.__proto__ || Object.getPrototypeOf(CustomStyle)).call(this));

      _this._style = null;
      CustomStyleInterface.addCustomStyle(_this);
      return _this;
    }
    /**
     * Returns the light-DOM `<style>` child this element wraps.  Upon first
     * call any style modules referenced via the `include` attribute will be
     * concatenated to this element's `<style>`.
     *
     * @return {HTMLStyleElement} This element's light-DOM `<style>`
     */


    _createClass(CustomStyle, [{
      key: 'getStyle',
      value: function getStyle() {
        if (this._style) {
          return this._style;
        }
        var style = /** @type {HTMLStyleElement} */this.querySelector('style');
        if (!style) {
          return null;
        }
        this._style = style;
        var include = style.getAttribute(attr);
        if (include) {
          style.removeAttribute(attr);
          style.textContent = Polymer.StyleGather.cssFromModules(include) + style.textContent;
        }
        return this._style;
      }
    }]);

    return CustomStyle;
  }(HTMLElement);

  window.customElements.define('custom-style', CustomStyle);
  Polymer.CustomStyle = CustomStyle;
})();

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(63);

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


(function () {
  /*
  Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
  This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
  The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
  The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
  Code distributed by Google as part of the polymer project is also
  subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
  */
  'use strict';
  var c = !(window.ShadyDOM && window.ShadyDOM.inUse),
      f;function g(a) {
    f = a && a.shimcssproperties ? !1 : c || !(navigator.userAgent.match(/AppleWebKit\/601|Edge\/15/) || !window.CSS || !CSS.supports || !CSS.supports("box-shadow", "0 0 0 var(--foo)"));
  }window.ShadyCSS && void 0 !== window.ShadyCSS.nativeCss ? f = window.ShadyCSS.nativeCss : window.ShadyCSS ? (g(window.ShadyCSS), window.ShadyCSS = void 0) : g(window.WebComponents && window.WebComponents.flags);var h = f;function k(a, b) {
    for (var d in b) {
      null === d ? a.style.removeProperty(d) : a.style.setProperty(d, b[d]);
    }
  };var l = null,
      m = window.HTMLImports && window.HTMLImports.whenReady || null,
      n;function p() {
    var a = q;requestAnimationFrame(function () {
      m ? m(a) : (l || (l = new Promise(function (a) {
        n = a;
      }), "complete" === document.readyState ? n() : document.addEventListener("readystatechange", function () {
        "complete" === document.readyState && n();
      })), l.then(function () {
        a && a();
      }));
    });
  };var r = null,
      q = null;function t() {
    this.customStyles = [];this.enqueued = !1;
  }function u(a) {
    !a.enqueued && q && (a.enqueued = !0, p());
  }t.prototype.c = function (a) {
    a.__seenByShadyCSS || (a.__seenByShadyCSS = !0, this.customStyles.push(a), u(this));
  };t.prototype.b = function (a) {
    if (a.__shadyCSSCachedStyle) return a.__shadyCSSCachedStyle;var b;a.getStyle ? b = a.getStyle() : b = a;return b;
  };
  t.prototype.a = function () {
    for (var a = this.customStyles, b = 0; b < a.length; b++) {
      var d = a[b];if (!d.__shadyCSSCachedStyle) {
        var e = this.b(d);e && (e = e.__appliedElement || e, r && r(e), d.__shadyCSSCachedStyle = e);
      }
    }return a;
  };t.prototype.addCustomStyle = t.prototype.c;t.prototype.getStyleForCustomStyle = t.prototype.b;t.prototype.processStyles = t.prototype.a;
  Object.defineProperties(t.prototype, { transformCallback: { get: function get() {
        return r;
      }, set: function set(a) {
        r = a;
      } }, validateCallback: { get: function get() {
        return q;
      }, set: function set(a) {
        var b = !1;q || (b = !0);q = a;b && u(this);
      } } });var v = new t();window.ShadyCSS || (window.ShadyCSS = { prepareTemplate: function prepareTemplate() {}, styleSubtree: function styleSubtree(a, b) {
      v.a();k(a, b);
    }, styleElement: function styleElement() {
      v.a();
    }, styleDocument: function styleDocument(a) {
      v.a();k(document.body, a);
    }, getComputedStyleValue: function getComputedStyleValue(a, b) {
      return (a = window.getComputedStyle(a).getPropertyValue(b)) ? a.trim() : "";
    }, nativeCss: h, nativeShadow: c });window.ShadyCSS.CustomStyleInterface = v;
}).call(undefined);

//# sourceMappingURL=custom-style-interface.min.js.map

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(9);

(function () {
  'use strict';

  var mutablePropertyChange = void 0;
  (
  /** @suppress {missingProperties} */
  function () {
    mutablePropertyChange = Polymer.MutableData._mutablePropertyChange;
  })();

  /**
   * Legacy element behavior to skip strict dirty-checking for objects and arrays,
   * (always consider them to be "dirty") for use on legacy API Polymer elements.
   *
   * By default, `Polymer.PropertyEffects` performs strict dirty checking on
   * objects, which means that any deep modifications to an object or array will
   * not be propagated unless "immutable" data patterns are used (i.e. all object
   * references from the root to the mutation were changed).
   *
   * Polymer also provides a proprietary data mutation and path notification API
   * (e.g. `notifyPath`, `set`, and array mutation API's) that allow efficient
   * mutation and notification of deep changes in an object graph to all elements
   * bound to the same object graph.
   *
   * In cases where neither immutable patterns nor the data mutation API can be
   * used, applying this mixin will cause Polymer to skip dirty checking for
   * objects and arrays (always consider them to be "dirty").  This allows a
   * user to make a deep modification to a bound object graph, and then either
   * simply re-set the object (e.g. `this.items = this.items`) or call `notifyPath`
   * (e.g. `this.notifyPath('items')`) to update the tree.  Note that all
   * elements that wish to be updated based on deep mutations must apply this
   * mixin or otherwise skip strict dirty checking for objects/arrays.
   *
   * In order to make the dirty check strategy configurable, see
   * `Polymer.OptionalMutableDataBehavior`.
   *
   * Note, the performance characteristics of propagating large object graphs
   * will be worse as opposed to using strict dirty checking with immutable
   * patterns or Polymer's path notification API.
   *
   * @polymerBehavior
   * @memberof Polymer
   * @summary Behavior to skip strict dirty-checking for objects and
   *   arrays
   */
  Polymer.MutableDataBehavior = {

    /**
     * Overrides `Polymer.PropertyEffects` to provide option for skipping
     * strict equality checking for Objects and Arrays.
     *
     * This method pulls the value to dirty check against from the `__dataTemp`
     * cache (rather than the normal `__data` cache) for Objects.  Since the temp
     * cache is cleared at the end of a turn, this implementation allows
     * side-effects of deep object changes to be processed by re-setting the
     * same object (using the temp cache as an in-turn backstop to prevent
     * cycles due to 2-way notification).
     *
     * @param {string} property Property name
     * @param {*} value New property value
     * @param {*} old Previous property value
     * @return {boolean} Whether the property should be considered a change
     * @protected
     */
    _shouldPropertyChange: function _shouldPropertyChange(property, value, old) {
      return mutablePropertyChange(this, property, value, old, true);
    }
  };

  /**
   * Legacy element behavior to add the optional ability to skip strict
   * dirty-checking for objects and arrays (always consider them to be
   * "dirty") by setting a `mutable-data` attribute on an element instance.
   *
   * By default, `Polymer.PropertyEffects` performs strict dirty checking on
   * objects, which means that any deep modifications to an object or array will
   * not be propagated unless "immutable" data patterns are used (i.e. all object
   * references from the root to the mutation were changed).
   *
   * Polymer also provides a proprietary data mutation and path notification API
   * (e.g. `notifyPath`, `set`, and array mutation API's) that allow efficient
   * mutation and notification of deep changes in an object graph to all elements
   * bound to the same object graph.
   *
   * In cases where neither immutable patterns nor the data mutation API can be
   * used, applying this mixin will allow Polymer to skip dirty checking for
   * objects and arrays (always consider them to be "dirty").  This allows a
   * user to make a deep modification to a bound object graph, and then either
   * simply re-set the object (e.g. `this.items = this.items`) or call `notifyPath`
   * (e.g. `this.notifyPath('items')`) to update the tree.  Note that all
   * elements that wish to be updated based on deep mutations must apply this
   * mixin or otherwise skip strict dirty checking for objects/arrays.
   *
   * While this behavior adds the ability to forgo Object/Array dirty checking,
   * the `mutableData` flag defaults to false and must be set on the instance.
   *
   * Note, the performance characteristics of propagating large object graphs
   * will be worse by relying on `mutableData: true` as opposed to using
   * strict dirty checking with immutable patterns or Polymer's path notification
   * API.
   *
   * @polymerBehavior
   * @memberof Polymer
   * @summary Behavior to optionally skip strict dirty-checking for objects and
   *   arrays
   */
  Polymer.OptionalMutableDataBehavior = {

    properties: {
      /**
       * Instance-level flag for configuring the dirty-checking strategy
       * for this element.  When true, Objects and Arrays will skip dirty
       * checking, otherwise strict equality checking will be used.
       */
      mutableData: Boolean
    },

    /**
     * Overrides `Polymer.PropertyEffects` to skip strict equality checking
     * for Objects and Arrays.
     *
     * Pulls the value to dirty check against from the `__dataTemp` cache
     * (rather than the normal `__data` cache) for Objects.  Since the temp
     * cache is cleared at the end of a turn, this implementation allows
     * side-effects of deep object changes to be processed by re-setting the
     * same object (using the temp cache as an in-turn backstop to prevent
     * cycles due to 2-way notification).
     *
     * @param {string} property Property name
     * @param {*} value New property value
     * @param {*} old Previous property value
     * @return {boolean} Whether the property should be considered a change
     * @this {this}
     * @protected
     */
    _shouldPropertyChange: function _shouldPropertyChange(property, value, old) {
      return mutablePropertyChange(this, property, value, old, this.mutableData);
    }
  };
})();

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

__webpack_require__(66);

__webpack_require__(15);

var RegisterHtmlTemplate = __webpack_require__(2);

RegisterHtmlTemplate.register("<dom-module id=app-drawer-layout> <template> <style>:host{display:block;position:relative;z-index:0}:host ::slotted([slot=drawer]){z-index:1}:host([fullbleed]){@apply --layout-fit;}#contentContainer{position:relative;z-index:0;height:100%;transition:var(--app-drawer-layout-content-transition,none)}#contentContainer[drawer-position=left]{margin-left:var(--app-drawer-width,256px)}#contentContainer[drawer-position=right]{margin-right:var(--app-drawer-width,256px)}</style> <slot id=drawerSlot name=drawer></slot> <div id=contentContainer drawer-position$=[[_drawerPosition]]> <slot></slot> </div> <iron-media-query query=\"[[_computeMediaQuery(forceNarrow, responsiveWidth)]]\" on-query-matches-changed=_onQueryMatchesChanged></iron-media-query> </template> </dom-module>");

Polymer({
  is: 'app-drawer-layout',

  behaviors: [Polymer.AppLayoutBehavior],

  properties: {
    /**
     * If true, ignore `responsiveWidth` setting and force the narrow layout.
     */
    forceNarrow: {
      type: Boolean,
      value: false
    },

    /**
     * If the viewport's width is smaller than this value, the panel will change to narrow
     * layout. In the mode the drawer will be closed.
     */
    responsiveWidth: {
      type: String,
      value: '640px'
    },

    /**
     * Returns true if it is in narrow layout. This is useful if you need to show/hide
     * elements based on the layout.
     */
    narrow: {
      type: Boolean,
      reflectToAttribute: true,
      readOnly: true,
      notify: true
    },

    /**
     * If true, the drawer will initially be opened when in narrow layout mode.
     */
    openedWhenNarrow: {
      type: Boolean,
      value: false
    },

    _drawerPosition: {
      type: String
    }
  },

  listeners: {
    'click': '_clickHandler'
  },

  observers: ['_narrowChanged(narrow)'],

  /**
   * A reference to the app-drawer element.
   *
   * @property drawer
   */
  get drawer() {
    return Polymer.dom(this.$.drawerSlot).getDistributedNodes()[0];
  },

  attached: function attached() {
    // Disable drawer transitions until after app-drawer-layout sets the initial opened state.
    var drawer = this.drawer;
    if (drawer) {
      drawer.setAttribute('no-transition', '');
    }
  },

  _clickHandler: function _clickHandler(e) {
    var target = Polymer.dom(e).localTarget;
    if (target && target.hasAttribute('drawer-toggle')) {
      var drawer = this.drawer;
      if (drawer && !drawer.persistent) {
        drawer.toggle();
      }
    }
  },

  _updateLayoutStates: function _updateLayoutStates() {
    var drawer = this.drawer;
    if (!this.isAttached || !drawer) {
      return;
    }

    this._drawerPosition = this.narrow ? null : drawer.position;
    if (this._drawerNeedsReset) {
      if (this.narrow) {
        drawer.opened = this.openedWhenNarrow;
        drawer.persistent = false;
      } else {
        drawer.opened = drawer.persistent = true;
      }
      if (drawer.hasAttribute('no-transition')) {
        // Enable drawer transitions after app-drawer-layout sets the initial opened state.
        Polymer.RenderStatus.afterNextRender(this, function () {
          drawer.removeAttribute('no-transition');
        });
      }
      this._drawerNeedsReset = false;
    }
  },

  _narrowChanged: function _narrowChanged() {
    this._drawerNeedsReset = true;
    this.resetLayout();
  },

  _onQueryMatchesChanged: function _onQueryMatchesChanged(event) {
    this._setNarrow(event.detail.value);
  },

  _computeMediaQuery: function _computeMediaQuery(forceNarrow, responsiveWidth) {
    return forceNarrow ? '(min-width: 0px)' : '(max-width: ' + responsiveWidth + ')';
  }
});

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

Polymer({

  is: 'iron-media-query',

  properties: {

    /**
     * The Boolean return value of the media query.
     */
    queryMatches: {
      type: Boolean,
      value: false,
      readOnly: true,
      notify: true
    },

    /**
     * The CSS media query to evaluate.
     */
    query: {
      type: String,
      observer: 'queryChanged'
    },

    /**
     * If true, the query attribute is assumed to be a complete media query
     * string rather than a single media feature.
     */
    full: {
      type: Boolean,
      value: false
    },

    /**
     * @type {function(MediaQueryList)}
     */
    _boundMQHandler: {
      value: function value() {
        return this.queryHandler.bind(this);
      }
    },

    /**
     * @type {MediaQueryList}
     */
    _mq: {
      value: null
    }
  },

  attached: function attached() {
    this.style.display = 'none';
    this.queryChanged();
  },

  detached: function detached() {
    this._remove();
  },

  _add: function _add() {
    if (this._mq) {
      this._mq.addListener(this._boundMQHandler);
    }
  },

  _remove: function _remove() {
    if (this._mq) {
      this._mq.removeListener(this._boundMQHandler);
    }
    this._mq = null;
  },

  queryChanged: function queryChanged() {
    this._remove();
    var query = this.query;
    if (!query) {
      return;
    }
    if (!this.full && query[0] !== '(') {
      query = '(' + query + ')';
    }
    this._mq = window.matchMedia(query);
    this._add();
    this.queryHandler(this._mq);
  },

  queryHandler: function queryHandler(mq) {
    this._setQueryMatches(mq.matches);
  }

});

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

__webpack_require__(5);

__webpack_require__(4);

__webpack_require__(15);

var RegisterHtmlTemplate = __webpack_require__(2);

RegisterHtmlTemplate.register("<dom-module id=app-header> <template> <style>:host{position:relative;display:block;transition-timing-function:linear;transition-property:-webkit-transform;transition-property:transform}:host::before{position:absolute;right:0;bottom:-5px;left:0;width:100%;height:5px;content:\"\";transition:opacity .4s;pointer-events:none;opacity:0;box-shadow:inset 0 5px 6px -3px rgba(0,0,0,.4);will-change:opacity;@apply --app-header-shadow;}:host([shadow])::before{opacity:1}#background{@apply --layout-fit;overflow:hidden}#backgroundFrontLayer,#backgroundRearLayer{@apply --layout-fit;height:100%;pointer-events:none;background-size:cover}#backgroundFrontLayer{@apply --app-header-background-front-layer;}#backgroundRearLayer{opacity:0;@apply --app-header-background-rear-layer;}#contentContainer{position:relative;width:100%;height:100%}:host([disabled]),:host([disabled]) #backgroundFrontLayer,:host([disabled]) #backgroundRearLayer,:host([disabled])::after,:host([silent-scroll]),:host([silent-scroll]) #backgroundFrontLayer,:host([silent-scroll]) #backgroundRearLayer,:host([silent-scroll])::after{transition:none!important}:host([disabled]) ::slotted([sticky]),:host([disabled]) ::slotted(app-toolbar:first-of-type),:host([silent-scroll]) ::slotted([sticky]),:host([silent-scroll]) ::slotted(app-toolbar:first-of-type){transition:none!important}</style> <div id=contentContainer> <slot id=slot></slot> </div> </template> </dom-module>");

Polymer({
  is: 'app-header',

  behaviors: [Polymer.AppScrollEffectsBehavior, Polymer.AppLayoutBehavior],

  properties: {
    /**
     * If true, the header will automatically collapse when scrolling down.
     * That is, the `sticky` element remains visible when the header is fully condensed
     * whereas the rest of the elements will collapse below `sticky` element.
     *
     * By default, the `sticky` element is the first toolbar in the light DOM:
     *
     *```html
     * <app-header condenses>
     *   <app-toolbar>This toolbar remains on top</app-toolbar>
     *   <app-toolbar></app-toolbar>
     *   <app-toolbar></app-toolbar>
     * </app-header>
     * ```
     *
     * Additionally, you can specify which toolbar or element remains visible in condensed mode
     * by adding the `sticky` attribute to that element. For example: if we want the last
     * toolbar to remain visible, we can add the `sticky` attribute to it.
     *
     *```html
     * <app-header condenses>
     *   <app-toolbar></app-toolbar>
     *   <app-toolbar></app-toolbar>
     *   <app-toolbar sticky>This toolbar remains on top</app-toolbar>
     * </app-header>
     * ```
     *
     * Note the `sticky` element must be a direct child of `app-header`.
     */
    condenses: {
      type: Boolean,
      value: false
    },

    /**
     * Mantains the header fixed at the top so it never moves away.
     */
    fixed: {
      type: Boolean,
      value: false
    },

    /**
     * Slides back the header when scrolling back up.
     */
    reveals: {
      type: Boolean,
      value: false
    },

    /**
     * Displays a shadow below the header.
     */
    shadow: {
      type: Boolean,
      reflectToAttribute: true,
      value: false
    }
  },

  observers: ['_configChanged(isAttached, condenses, fixed)'],

  /**
   * A cached offsetHeight of the current element.
   *
   * @type {number}
   */
  _height: 0,

  /**
   * The distance in pixels the header will be translated to when scrolling.
   *
   * @type {number}
   */
  _dHeight: 0,

  /**
   * The offsetTop of `_stickyEl`
   *
   * @type {number}
   */
  _stickyElTop: 0,

  /**
   * A reference to the element that remains visible when the header condenses.
   *
   * @type {HTMLElement}
   */
  _stickyElRef: null,

  /**
   * The header's top value used for the `transformY`
   *
   * @type {number}
   */
  _top: 0,

  /**
   * The current scroll progress.
   *
   * @type {number}
   */
  _progress: 0,

  _wasScrollingDown: false,
  _initScrollTop: 0,
  _initTimestamp: 0,
  _lastTimestamp: 0,
  _lastScrollTop: 0,

  /**
   * The distance the header is allowed to move away.
   *
   * @type {number}
   */
  get _maxHeaderTop() {
    return this.fixed ? this._dHeight : this._height + 5;
  },

  /**
   * Returns a reference to the sticky element.
   *
   * @return {HTMLElement}?
   */
  get _stickyEl() {
    if (this._stickyElRef) {
      return this._stickyElRef;
    }
    var nodes = Polymer.dom(this.$.slot).getDistributedNodes();
    // Get the element with the sticky attribute on it or the first element in the light DOM.
    for (var i = 0, node; node = nodes[i]; i++) {
      if (node.nodeType === Node.ELEMENT_NODE) {
        if (node.hasAttribute('sticky')) {
          this._stickyElRef = node;
          break;
        } else if (!this._stickyElRef) {
          this._stickyElRef = node;
        }
      }
    }
    return this._stickyElRef;
  },

  _configChanged: function _configChanged() {
    this.resetLayout();
    this._notifyLayoutChanged();
  },

  _updateLayoutStates: function _updateLayoutStates() {
    if (this.offsetWidth === 0 && this.offsetHeight === 0) {
      return;
    }
    var scrollTop = this._clampedScrollTop;
    var firstSetup = this._height === 0 || scrollTop === 0;
    var currentDisabled = this.disabled;
    this._height = this.offsetHeight;
    this._stickyElRef = null;
    this.disabled = true;
    // prepare for measurement
    if (!firstSetup) {
      this._updateScrollState(0, true);
    }
    if (this._mayMove()) {
      this._dHeight = this._stickyEl ? this._height - this._stickyEl.offsetHeight : 0;
    } else {
      this._dHeight = 0;
    }
    this._stickyElTop = this._stickyEl ? this._stickyEl.offsetTop : 0;
    this._setUpEffect();
    if (firstSetup) {
      this._updateScrollState(scrollTop, true);
    } else {
      this._updateScrollState(this._lastScrollTop, true);
      this._layoutIfDirty();
    }
    // restore no transition
    this.disabled = currentDisabled;
  },

  /**
   * Updates the scroll state.
   *
   * @param {number} scrollTop
   * @param {boolean=} forceUpdate (default: false)
   */
  _updateScrollState: function _updateScrollState(scrollTop, forceUpdate) {
    if (this._height === 0) {
      return;
    }
    var progress = 0;
    var top = 0;
    var lastTop = this._top;
    var lastScrollTop = this._lastScrollTop;
    var maxHeaderTop = this._maxHeaderTop;
    var dScrollTop = scrollTop - this._lastScrollTop;
    var absDScrollTop = Math.abs(dScrollTop);
    var isScrollingDown = scrollTop > this._lastScrollTop;
    var now = performance.now();

    if (this._mayMove()) {
      top = this._clamp(this.reveals ? lastTop + dScrollTop : scrollTop, 0, maxHeaderTop);
    }
    if (scrollTop >= this._dHeight) {
      top = this.condenses && !this.fixed ? Math.max(this._dHeight, top) : top;
      this.style.transitionDuration = '0ms';
    }
    if (this.reveals && !this.disabled && absDScrollTop < 100) {
      // set the initial scroll position
      if (now - this._initTimestamp > 300 || this._wasScrollingDown !== isScrollingDown) {
        this._initScrollTop = scrollTop;
        this._initTimestamp = now;
      }
      if (scrollTop >= maxHeaderTop) {
        // check if the header is allowed to snap
        if (Math.abs(this._initScrollTop - scrollTop) > 30 || absDScrollTop > 10) {
          if (isScrollingDown && scrollTop >= maxHeaderTop) {
            top = maxHeaderTop;
          } else if (!isScrollingDown && scrollTop >= this._dHeight) {
            top = this.condenses && !this.fixed ? this._dHeight : 0;
          }
          var scrollVelocity = dScrollTop / (now - this._lastTimestamp);
          this.style.transitionDuration = this._clamp((top - lastTop) / scrollVelocity, 0, 300) + 'ms';
        } else {
          top = this._top;
        }
      }
    }
    if (this._dHeight === 0) {
      progress = scrollTop > 0 ? 1 : 0;
    } else {
      progress = top / this._dHeight;
    }
    if (!forceUpdate) {
      this._lastScrollTop = scrollTop;
      this._top = top;
      this._wasScrollingDown = isScrollingDown;
      this._lastTimestamp = now;
    }
    if (forceUpdate || progress !== this._progress || lastTop !== top || scrollTop === 0) {
      this._progress = progress;
      this._runEffects(progress, top);
      this._transformHeader(top);
    }
  },

  /**
   * Returns true if the current header is allowed to move as the user scrolls.
   *
   * @return {boolean}
   */
  _mayMove: function _mayMove() {
    return this.condenses || !this.fixed;
  },

  /**
   * Returns true if the current header will condense based on the size of the header
   * and the `consenses` property.
   *
   * @return {boolean}
   */
  willCondense: function willCondense() {
    return this._dHeight > 0 && this.condenses;
  },

  /**
   * Returns true if the current element is on the screen.
   * That is, visible in the current viewport.
   *
   * @method isOnScreen
   * @return {boolean}
   */
  isOnScreen: function isOnScreen() {
    return this._height !== 0 && this._top < this._height;
  },

  /**
   * Returns true if there's content below the current element.
   *
   * @method isContentBelow
   * @return {boolean}
   */
  isContentBelow: function isContentBelow() {
    return this._top === 0 ? this._clampedScrollTop > 0 : this._clampedScrollTop - this._maxHeaderTop >= 0;
  },

  /**
   * Transforms the header.
   *
   * @param {number} y
   */
  _transformHeader: function _transformHeader(y) {
    this.translate3d(0, -y + 'px', 0);
    if (this._stickyEl) {
      this.translate3d(0, this.condenses && y >= this._stickyElTop ? Math.min(y, this._dHeight) - this._stickyElTop + 'px' : 0, 0, this._stickyEl);
    }
  },

  _clamp: function _clamp(v, min, max) {
    return Math.min(max, Math.max(min, v));
  },

  _ensureBgContainers: function _ensureBgContainers() {
    if (!this._bgContainer) {
      this._bgContainer = document.createElement('div');
      this._bgContainer.id = 'background';
      this._bgRear = document.createElement('div');
      this._bgRear.id = 'backgroundRearLayer';
      this._bgContainer.appendChild(this._bgRear);
      this._bgFront = document.createElement('div');
      this._bgFront.id = 'backgroundFrontLayer';
      this._bgContainer.appendChild(this._bgFront);
      Polymer.dom(this.root).insertBefore(this._bgContainer, this.$.contentContainer);
    }
  },

  _getDOMRef: function _getDOMRef(id) {
    switch (id) {
      case 'backgroundFrontLayer':
        this._ensureBgContainers();
        return this._bgFront;
      case 'backgroundRearLayer':
        this._ensureBgContainers();
        return this._bgRear;
      case 'background':
        this._ensureBgContainers();
        return this._bgContainer;
      case 'mainTitle':
        return Polymer.dom(this).querySelector('[main-title]');
      case 'condensedTitle':
        return Polymer.dom(this).querySelector('[condensed-title]');
    }
    return null;
  },

  /**
   * Returns an object containing the progress value of the scroll effects
   * and the top position of the header.
   *
   * @method getScrollState
   * @return {Object}
   */
  getScrollState: function getScrollState() {
    return { progress: this._progress, top: this._top };
  }
});

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

Polymer.AppLayout = Polymer.AppLayout || {};

Polymer.AppLayout._scrollEffects = Polymer.AppLayout._scrollEffects || {};

Polymer.AppLayout.scrollTimingFunction = function easeOutQuad(t, b, c, d) {
  t /= d;
  return -c * t * (t - 2) + b;
};

/**
 * Registers a scroll effect to be used in elements that implement the
 * `Polymer.AppScrollEffectsBehavior` behavior.
 *
 * @param {string} effectName The effect name.
 * @param {Object} effectDef The effect definition.
 */
Polymer.AppLayout.registerEffect = function registerEffect(effectName, effectDef) {
  if (Polymer.AppLayout._scrollEffects[effectName] != null) {
    throw new Error('effect `' + effectName + '` is already registered.');
  }
  Polymer.AppLayout._scrollEffects[effectName] = effectDef;
};

Polymer.AppLayout.queryAllRoot = function (selector, root) {
  var queue = [root];
  var matches = [];

  while (queue.length > 0) {
    var node = queue.shift();
    matches.push.apply(matches, node.querySelectorAll(selector));
    for (i = 0; node.children[i]; i++) {
      if (node.children[i].shadowRoot) {
        queue.push(node.children[i].shadowRoot);
      }
    }
  }
  return matches;
};

/**
 * Scrolls to a particular set of coordinates in a scroll target.
 * If the scroll target is not defined, then it would use the main document as the target.
 *
 * To scroll in a smooth fashion, you can set the option `behavior: 'smooth'`. e.g.
 *
 * ```js
 * Polymer.AppLayout.scroll({top: 0, behavior: 'smooth'});
 * ```
 *
 * To scroll in a silent mode, without notifying scroll changes to any app-layout elements,
 * you can set the option `behavior: 'silent'`. This is particularly useful we you are using
 * `app-header` and you desire to scroll to the top of a scrolling region without running
 * scroll effects. e.g.
 *
 * ```js
 * Polymer.AppLayout.scroll({top: 0, behavior: 'silent'});
 * ```
 *
 * @param {Object} options {top: Number, left: Number, behavior: String(smooth | silent)}
 */
Polymer.AppLayout.scroll = function scroll(options) {
  options = options || {};

  var docEl = document.documentElement;
  var target = options.target || docEl;
  var hasNativeScrollBehavior = 'scrollBehavior' in target.style && target.scroll;
  var scrollClassName = 'app-layout-silent-scroll';
  var scrollTop = options.top || 0;
  var scrollLeft = options.left || 0;
  var scrollTo = target === docEl ? window.scrollTo : function scrollTo(scrollLeft, scrollTop) {
    target.scrollLeft = scrollLeft;
    target.scrollTop = scrollTop;
  };

  if (options.behavior === 'smooth') {

    if (hasNativeScrollBehavior) {

      target.scroll(options);
    } else {

      var timingFn = Polymer.AppLayout.scrollTimingFunction;
      var startTime = Date.now();
      var currentScrollTop = target === docEl ? window.pageYOffset : target.scrollTop;
      var currentScrollLeft = target === docEl ? window.pageXOffset : target.scrollLeft;
      var deltaScrollTop = scrollTop - currentScrollTop;
      var deltaScrollLeft = scrollLeft - currentScrollLeft;
      var duration = 300;
      var updateFrame = function updateFrame() {
        var now = Date.now();
        var elapsedTime = now - startTime;

        if (elapsedTime < duration) {
          scrollTo(timingFn(elapsedTime, currentScrollLeft, deltaScrollLeft, duration), timingFn(elapsedTime, currentScrollTop, deltaScrollTop, duration));
          requestAnimationFrame(updateFrame);
        } else {
          scrollTo(scrollLeft, scrollTop);
        }
      }.bind(this);

      updateFrame();
    }
  } else if (options.behavior === 'silent') {
    var headers = Polymer.AppLayout.queryAllRoot('app-header', document.body);

    headers.forEach(function (header) {
      header.setAttribute('silent-scroll', '');
    });

    // Browsers keep the scroll momentum even if the bottom of the scrolling content
    // was reached. This means that calling scroll({top: 0, behavior: 'silent'}) when
    // the momentum is still going will result in more scroll events and thus scroll effects.
    // This seems to only apply when using document scrolling.
    // Therefore, when should we remove the class from the document element?

    window.cancelAnimationFrame(Polymer.AppLayout._scrollTimer);

    Polymer.AppLayout._scrollTimer = window.requestAnimationFrame(function () {
      headers.forEach(function (header) {
        header.removeAttribute('silent-scroll');
      });
      Polymer.AppLayout._scrollTimer = null;
    });

    scrollTo(scrollLeft, scrollTop);
  } else {

    scrollTo(scrollLeft, scrollTop);
  }
};

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

__webpack_require__(5);

__webpack_require__(15);

var RegisterHtmlTemplate = __webpack_require__(2);

RegisterHtmlTemplate.register("<dom-module id=app-header-layout> <template> <style>:host{display:block;position:relative;z-index:0}#wrapper ::slotted([slot=header]){@apply --layout-fixed-top;z-index:1}#wrapper.initializing ::slotted([slot=header]){position:relative}:host([has-scrolling-region]){height:100%}:host([has-scrolling-region]) #wrapper ::slotted([slot=header]){position:absolute}:host([has-scrolling-region]) #wrapper.initializing ::slotted([slot=header]){position:relative}:host([has-scrolling-region]) #wrapper #contentContainer{@apply --layout-fit;overflow-y:auto;-webkit-overflow-scrolling:touch}:host([has-scrolling-region]) #wrapper.initializing #contentContainer{position:relative}:host([fullbleed]){@apply --layout-vertical;@apply --layout-fit;}:host([fullbleed]) #wrapper,:host([fullbleed]) #wrapper #contentContainer{@apply --layout-vertical;@apply --layout-flex;}#contentContainer{position:relative;z-index:0}</style> <div id=wrapper class=initializing> <slot id=headerSlot name=header></slot> <div id=contentContainer> <slot></slot> </div> </div> </template> </dom-module>");

Polymer({
  is: 'app-header-layout',

  behaviors: [Polymer.AppLayoutBehavior],

  properties: {
    /**
     * If true, the current element will have its own scrolling region.
     * Otherwise, it will use the document scroll to control the header.
     */
    hasScrollingRegion: {
      type: Boolean,
      value: false,
      reflectToAttribute: true
    }
  },

  observers: ['resetLayout(isAttached, hasScrollingRegion)'],

  /**
   * A reference to the app-header element.
   *
   * @property header
   */
  get header() {
    return Polymer.dom(this.$.headerSlot).getDistributedNodes()[0];
  },

  _updateLayoutStates: function _updateLayoutStates() {
    var header = this.header;
    if (!this.isAttached || !header) {
      return;
    }
    // Remove the initializing class, which staticly positions the header and the content
    // until the height of the header can be read.
    this.$.wrapper.classList.remove('initializing');
    // Update scroll target.
    header.scrollTarget = this.hasScrollingRegion ? this.$.contentContainer : this.ownerDocument.documentElement;
    // Get header height here so that style reads are batched together before style writes
    // (i.e. getBoundingClientRect() below).
    var headerHeight = header.offsetHeight;
    // Update the header position.
    if (!this.hasScrollingRegion) {
      requestAnimationFrame(function () {
        var rect = this.getBoundingClientRect();
        var rightOffset = document.documentElement.clientWidth - rect.right;
        header.style.left = rect.left + 'px';
        header.style.right = rightOffset + 'px';
      }.bind(this));
    } else {
      header.style.left = '';
      header.style.right = '';
    }
    // Update the content container position.
    var containerStyle = this.$.contentContainer.style;
    if (header.fixed && !header.condenses && this.hasScrollingRegion) {
      // If the header size does not change and we're using a scrolling region, exclude
      // the header area from the scrolling region so that the header doesn't overlap
      // the scrollbar.
      containerStyle.marginTop = headerHeight + 'px';
      containerStyle.paddingTop = '';
    } else {
      containerStyle.paddingTop = headerHeight + 'px';
      containerStyle.marginTop = '';
    }
  }

});

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(25);

__webpack_require__(71);

__webpack_require__(72);

__webpack_require__(28);

__webpack_require__(73);

__webpack_require__(27);

__webpack_require__(26);

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(4);

/**
 * Upon scrolling past a threshold, fade in the rear background layer and fade out the front
 * background layer (opacity CSS transitioned over time).
 *
 *
 */
Polymer.AppLayout.registerEffect('fade-background', {
  /** @this Polymer.AppLayout.ElementWithBackground */
  setUp: function setUp(config) {
    var fx = {};
    var duration = config.duration || '0.5s';
    fx.backgroundFrontLayer = this._getDOMRef('backgroundFrontLayer');
    fx.backgroundRearLayer = this._getDOMRef('backgroundRearLayer');
    fx.backgroundFrontLayer.style.willChange = 'opacity';
    fx.backgroundFrontLayer.style.webkitTransform = 'translateZ(0)';
    fx.backgroundFrontLayer.style.transitionProperty = 'opacity';
    fx.backgroundFrontLayer.style.transitionDuration = duration;
    fx.backgroundRearLayer.style.willChange = 'opacity';
    fx.backgroundRearLayer.style.webkitTransform = 'translateZ(0)';
    fx.backgroundRearLayer.style.transitionProperty = 'opacity';
    fx.backgroundRearLayer.style.transitionDuration = duration;
    this._fxFadeBackground = fx;
  },
  /** @this Polymer.AppLayout.ElementWithBackground */
  run: function run(p, y) {
    var fx = this._fxFadeBackground;
    if (p >= 1) {
      fx.backgroundFrontLayer.style.opacity = 0;
      fx.backgroundRearLayer.style.opacity = 1;
    } else {
      fx.backgroundFrontLayer.style.opacity = 1;
      fx.backgroundRearLayer.style.opacity = 0;
    }
  },
  /** @this Polymer.AppLayout.ElementWithBackground */
  tearDown: function tearDown() {
    delete this._fxFadeBackground;
  }
});

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(4);

__webpack_require__(26);

__webpack_require__(27);

__webpack_require__(25);

__webpack_require__(28);

/**
 * Shorthand for the waterfall, resize-title, blend-background, and parallax-background effects.
 */
Polymer.AppLayout.registerEffect('material', {
  /**
   * @this Polymer.AppLayout.ElementWithBackground
   */
  setUp: function setUp() {
    this.effects = 'waterfall resize-title blend-background parallax-background';
    return false;
  }
});

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(4);

/**
 * Upon scrolling past a threshold, CSS transition the font size of a designated title element
 * between two values.
 */
Polymer.AppLayout.registerEffect('resize-snapped-title', {
  /**
   * @this Polymer.AppLayout.ElementWithBackground
   */
  setUp: function setUp(config) {
    var title = this._getDOMRef('mainTitle');
    var condensedTitle = this._getDOMRef('condensedTitle');
    var duration = config.duration || '0.2s';
    var fx = {};

    if (!condensedTitle) {
      console.warn('Scroll effect `resize-snapped-title`: undefined `condensed-title`');
      return false;
    }
    if (!title) {
      console.warn('Scroll effect `resize-snapped-title`: undefined `main-title`');
      return false;
    }

    title.style.transitionProperty = 'opacity';
    title.style.transitionDuration = duration;
    condensedTitle.style.transitionProperty = 'opacity';
    condensedTitle.style.transitionDuration = duration;
    fx.condensedTitle = condensedTitle;
    fx.title = title;
    this._fxResizeSnappedTitle = fx;
  },
  /** @this Polymer.AppLayout.ElementWithBackground */
  run: function run(p, y) {
    var fx = this._fxResizeSnappedTitle;
    if (p > 0) {
      fx.title.style.opacity = 0;
      fx.condensedTitle.style.opacity = 1;
    } else {
      fx.title.style.opacity = 1;
      fx.condensedTitle.style.opacity = 0;
    }
  },
  /** @this Polymer.AppLayout.ElementWithBackground */
  tearDown: function tearDown() {
    var fx = this._fxResizeSnappedTitle;
    fx.title.style.transition = '';
    fx.condensedTitle.style.transition = '';
    delete this._fxResizeSnappedTitle;
  }
});

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

__webpack_require__(5);

var RegisterHtmlTemplate = __webpack_require__(2);

RegisterHtmlTemplate.register("<dom-module id=app-toolbar> <template> <style>:host{@apply --layout-horizontal;@apply --layout-center;position:relative;height:64px;padding:0 16px;pointer-events:none;font-size:var(--app-toolbar-font-size,20px)}:host ::slotted(*){pointer-events:auto}:host ::slotted(paper-icon-button){font-size:0}:host ::slotted([condensed-title]),:host ::slotted([main-title]){pointer-events:none;@apply --layout-flex;}:host ::slotted([bottom-item]){position:absolute;right:0;bottom:0;left:0}:host ::slotted([top-item]){position:absolute;top:0;right:0;left:0}:host ::slotted([spacer]){margin-left:64px}</style> <slot></slot> </template> </dom-module>");

Polymer({
  is: 'app-toolbar'
});

/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

__webpack_require__(76);

__webpack_require__(77);

__webpack_require__(78);

var RegisterHtmlTemplate = __webpack_require__(2);

RegisterHtmlTemplate.register("<dom-module id=app-location> <template> <iron-query-params params-string={{__query}} params-object={{queryParams}}> </iron-query-params> <iron-location path={{__path}} query={{__query}} hash={{__hash}} url-space-regex={{urlSpaceRegex}}> </iron-location> </template> </dom-module>");

(function () {
  'use strict';

  Polymer({
    is: 'app-location',

    properties: {
      /**
       * A model representing the deserialized path through the route tree, as
       * well as the current queryParams.
       */
      route: {
        type: Object,
        notify: true
      },

      /**
       * In many scenarios, it is convenient to treat the `hash` as a stand-in
       * alternative to the `path`. For example, if deploying an app to a static
       * web server (e.g., Github Pages) - where one does not have control over
       * server-side routing - it is usually a better experience to use the hash
       * to represent paths through one's app.
       *
       * When this property is set to true, the `hash` will be used in place of
        * the `path` for generating a `route`.
       */
      useHashAsPath: {
        type: Boolean,
        value: false
      },

      /**
       * A regexp that defines the set of URLs that should be considered part
       * of this web app.
       *
       * Clicking on a link that matches this regex won't result in a full page
       * navigation, but will instead just update the URL state in place.
       *
       * This regexp is given everything after the origin in an absolute
       * URL. So to match just URLs that start with /search/ do:
       *     url-space-regex="^/search/"
       *
       * @type {string|RegExp}
       */
      urlSpaceRegex: {
        type: String,
        notify: true
      },

      /**
       * A set of key/value pairs that are universally accessible to branches
       * of the route tree.
       */
      __queryParams: {
        type: Object
      },

      /**
       * The pathname component of the current URL.
       */
      __path: {
        type: String
      },

      /**
       * The query string portion of the current URL.
       */
      __query: {
        type: String
      },

      /**
       * The hash portion of the current URL.
       */
      __hash: {
        type: String
      },

      /**
       * The route path, which will be either the hash or the path, depending
       * on useHashAsPath.
       */
      path: {
        type: String,
        observer: '__onPathChanged'
      },

      /**
       * Whether or not the ready function has been called.
       */
      _isReady: {
        type: Boolean
      }
    },

    behaviors: [Polymer.AppRouteConverterBehavior],

    observers: ['__computeRoutePath(useHashAsPath, __hash, __path)'],

    ready: function ready() {
      this._isReady = true;
    },

    __computeRoutePath: function __computeRoutePath() {
      this.path = this.useHashAsPath ? this.__hash : this.__path;
    },

    __onPathChanged: function __onPathChanged() {
      if (!this._isReady) {
        return;
      }

      if (this.useHashAsPath) {
        this.__hash = this.path;
      } else {
        this.__path = this.path;
      }
    }
  });
})();

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

(function () {
  'use strict';

  var workingURL;

  var urlDoc, urlBase, anchor;

  /**
   * @param {string} path
   * @param {string=} base
   * @return {!URL|!HTMLAnchorElement}
   */
  function resolveURL(path, base) {
    if (workingURL === undefined) {
      workingURL = false;
      try {
        var u = new URL('b', 'http://a');
        u.pathname = 'c%20d';
        workingURL = u.href === 'http://a/c%20d';
        workingURL = workingURL && new URL('http://www.google.com/?foo bar').href === 'http://www.google.com/?foo%20bar';
      } catch (e) {}
    }
    if (workingURL) {
      return new URL(path, base);
    }
    if (!urlDoc) {
      urlDoc = document.implementation.createHTMLDocument('url');
      urlBase = urlDoc.createElement('base');
      urlDoc.head.appendChild(urlBase);
      anchor = /** @type {HTMLAnchorElement}*/urlDoc.createElement('a');
    }
    urlBase.href = base;
    anchor.href = path.replace(/ /g, '%20');
    return anchor;
  }

  Polymer({
    is: 'iron-location',

    properties: {
      /**
       * The pathname component of the URL.
       */
      path: {
        type: String,
        notify: true,
        value: function value() {
          return window.decodeURIComponent(window.location.pathname);
        }
      },

      /**
       * The query string portion of the URL.
       */
      query: {
        type: String,
        notify: true,
        value: function value() {
          return window.location.search.slice(1);
        }
      },

      /**
       * The hash component of the URL.
       */
      hash: {
        type: String,
        notify: true,
        value: function value() {
          return window.decodeURIComponent(window.location.hash.slice(1));
        }
      },

      /**
       * If the user was on a URL for less than `dwellTime` milliseconds, it
       * won't be added to the browser's history, but instead will be replaced
       * by the next entry.
       *
       * This is to prevent large numbers of entries from clogging up the user's
       * browser history. Disable by setting to a negative number.
       */
      dwellTime: {
        type: Number,
        value: 2000
      },

      /**
       * A regexp that defines the set of URLs that should be considered part
       * of this web app.
       *
       * Clicking on a link that matches this regex won't result in a full page
       * navigation, but will instead just update the URL state in place.
       *
       * This regexp is given everything after the origin in an absolute
       * URL. So to match just URLs that start with /search/ do:
       *     url-space-regex="^/search/"
       *
       * @type {string|RegExp}
       */
      urlSpaceRegex: {
        type: String,
        value: ''
      },

      /**
       * urlSpaceRegex, but coerced into a regexp.
       *
       * @type {RegExp}
       */
      _urlSpaceRegExp: {
        computed: '_makeRegExp(urlSpaceRegex)'
      },

      _lastChangedAt: {
        type: Number
      },

      _initialized: {
        type: Boolean,
        value: false
      }
    },

    hostAttributes: {
      hidden: true
    },

    observers: ['_updateUrl(path, query, hash)'],

    attached: function attached() {
      this.listen(window, 'hashchange', '_hashChanged');
      this.listen(window, 'location-changed', '_urlChanged');
      this.listen(window, 'popstate', '_urlChanged');
      this.listen( /** @type {!HTMLBodyElement} */document.body, 'click', '_globalOnClick');
      // Give a 200ms grace period to make initial redirects without any
      // additions to the user's history.
      this._lastChangedAt = window.performance.now() - (this.dwellTime - 200);
      this._initialized = true;

      this._urlChanged();
    },

    detached: function detached() {
      this.unlisten(window, 'hashchange', '_hashChanged');
      this.unlisten(window, 'location-changed', '_urlChanged');
      this.unlisten(window, 'popstate', '_urlChanged');
      this.unlisten( /** @type {!HTMLBodyElement} */document.body, 'click', '_globalOnClick');
      this._initialized = false;
    },

    _hashChanged: function _hashChanged() {
      this.hash = window.decodeURIComponent(window.location.hash.substring(1));
    },

    _urlChanged: function _urlChanged() {
      // We want to extract all info out of the updated URL before we
      // try to write anything back into it.
      //
      // i.e. without _dontUpdateUrl we'd overwrite the new path with the old
      // one when we set this.hash. Likewise for query.
      this._dontUpdateUrl = true;
      this._hashChanged();
      this.path = window.decodeURIComponent(window.location.pathname);
      this.query = window.location.search.substring(1);
      this._dontUpdateUrl = false;
      this._updateUrl();
    },

    _getUrl: function _getUrl() {
      var partiallyEncodedPath = window.encodeURI(this.path).replace(/\#/g, '%23').replace(/\?/g, '%3F');
      var partiallyEncodedQuery = '';
      if (this.query) {
        partiallyEncodedQuery = '?' + this.query.replace(/\#/g, '%23');
      }
      var partiallyEncodedHash = '';
      if (this.hash) {
        partiallyEncodedHash = '#' + window.encodeURI(this.hash);
      }
      return partiallyEncodedPath + partiallyEncodedQuery + partiallyEncodedHash;
    },

    _updateUrl: function _updateUrl() {
      if (this._dontUpdateUrl || !this._initialized) {
        return;
      }

      if (this.path === window.decodeURIComponent(window.location.pathname) && this.query === window.location.search.substring(1) && this.hash === window.decodeURIComponent(window.location.hash.substring(1))) {
        // Nothing to do, the current URL is a representation of our properties.
        return;
      }

      var newUrl = this._getUrl();
      // Need to use a full URL in case the containing page has a base URI.
      var fullNewUrl = resolveURL(newUrl, window.location.protocol + '//' + window.location.host).href;
      var now = window.performance.now();
      var shouldReplace = this._lastChangedAt + this.dwellTime > now;
      this._lastChangedAt = now;

      if (shouldReplace) {
        window.history.replaceState({}, '', fullNewUrl);
      } else {
        window.history.pushState({}, '', fullNewUrl);
      }

      this.fire('location-changed', {}, { node: window });
    },

    /**
     * A necessary evil so that links work as expected. Does its best to
     * bail out early if possible.
     *
     * @param {MouseEvent} event .
     */
    _globalOnClick: function _globalOnClick(event) {
      // If another event handler has stopped this event then there's nothing
      // for us to do. This can happen e.g. when there are multiple
      // iron-location elements in a page.
      if (event.defaultPrevented) {
        return;
      }

      var href = this._getSameOriginLinkHref(event);

      if (!href) {
        return;
      }

      event.preventDefault();

      // If the navigation is to the current page we shouldn't add a history
      // entry or fire a change event.
      if (href === window.location.href) {
        return;
      }

      window.history.pushState({}, '', href);
      this.fire('location-changed', {}, { node: window });
    },

    /**
     * Returns the absolute URL of the link (if any) that this click event
     * is clicking on, if we can and should override the resulting full
     * page navigation. Returns null otherwise.
     *
     * @param {MouseEvent} event .
     * @return {string?} .
     */
    _getSameOriginLinkHref: function _getSameOriginLinkHref(event) {
      // We only care about left-clicks.
      if (event.button !== 0) {
        return null;
      }

      // We don't want modified clicks, where the intent is to open the page
      // in a new tab.
      if (event.metaKey || event.ctrlKey) {
        return null;
      }

      var eventPath = Polymer.dom(event).path;
      var anchor = null;

      for (var i = 0; i < eventPath.length; i++) {
        var element = eventPath[i];

        if (element.tagName === 'A' && element.href) {
          anchor = element;
          break;
        }
      }

      // If there's no link there's nothing to do.
      if (!anchor) {
        return null;
      }

      // Target blank is a new tab, don't intercept.
      if (anchor.target === '_blank') {
        return null;
      }

      // If the link is for an existing parent frame, don't intercept.
      if ((anchor.target === '_top' || anchor.target === '_parent') && window.top !== window) {
        return null;
      }

      var href = anchor.href;

      // It only makes sense for us to intercept same-origin navigations.
      // pushState/replaceState don't work with cross-origin links.
      var url;

      if (document.baseURI != null) {
        url = resolveURL(href, /** @type {string} */document.baseURI);
      } else {
        url = resolveURL(href);
      }

      var origin;

      // IE Polyfill
      if (window.location.origin) {
        origin = window.location.origin;
      } else {
        origin = window.location.protocol + '//' + window.location.host;
      }

      var urlOrigin;

      if (url.origin) {
        urlOrigin = url.origin;
      } else {
        urlOrigin = url.protocol + '//' + url.host;
      }

      if (urlOrigin !== origin) {
        return null;
      }

      var normalizedHref = url.pathname + url.search + url.hash;

      // pathname should start with '/', but may not if `new URL` is not supported
      if (normalizedHref[0] !== '/') {
        normalizedHref = '/' + normalizedHref;
      }

      // If we've been configured not to handle this url... don't handle it!
      if (this._urlSpaceRegExp && !this._urlSpaceRegExp.test(normalizedHref)) {
        return null;
      }

      // Need to use a full URL in case the containing page has a base URI.
      var fullNormalizedHref = resolveURL(normalizedHref, window.location.href).href;
      return fullNormalizedHref;
    },

    _makeRegExp: function _makeRegExp(urlSpaceRegex) {
      return RegExp(urlSpaceRegex);
    }
  });
})();

/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

'use strict';

Polymer({
  is: 'iron-query-params',

  properties: {
    paramsString: {
      type: String,
      notify: true,
      observer: 'paramsStringChanged'
    },

    paramsObject: {
      type: Object,
      notify: true,
      value: function value() {
        return {};
      }
    },

    _dontReact: {
      type: Boolean,
      value: false
    }
  },

  hostAttributes: {
    hidden: true
  },

  observers: ['paramsObjectChanged(paramsObject.*)'],

  paramsStringChanged: function paramsStringChanged() {
    this._dontReact = true;
    this.paramsObject = this._decodeParams(this.paramsString);
    this._dontReact = false;
  },

  paramsObjectChanged: function paramsObjectChanged() {
    if (this._dontReact) {
      return;
    }
    this.paramsString = this._encodeParams(this.paramsObject).replace(/%3F/g, '?').replace(/%2F/g, '/').replace(/'/g, '%27');
  },

  _encodeParams: function _encodeParams(params) {
    var encodedParams = [];

    for (var key in params) {
      var value = params[key];

      if (value === '') {
        encodedParams.push(encodeURIComponent(key));
      } else if (value) {
        encodedParams.push(encodeURIComponent(key) + '=' + encodeURIComponent(value.toString()));
      }
    }
    return encodedParams.join('&');
  },

  _decodeParams: function _decodeParams(paramString) {
    var params = {};
    // Work around a bug in decodeURIComponent where + is not
    // converted to spaces:
    paramString = (paramString || '').replace(/\+/g, '%20');
    var paramList = paramString.split('&');
    for (var i = 0; i < paramList.length; i++) {
      var param = paramList[i].split('=');
      if (param[0]) {
        params[decodeURIComponent(param[0])] = decodeURIComponent(param[1] || '');
      }
    }
    return params;
  }
});

/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


(function () {
  'use strict';

  /**
   * Provides bidirectional mapping between `path` and `queryParams` and a
   * app-route compatible `route` object.
   *
   * For more information, see the docs for `app-route-converter`.
   *
   * @polymerBehavior
   */

  Polymer.AppRouteConverterBehavior = {
    properties: {
      /**
       * A model representing the deserialized path through the route tree, as
       * well as the current queryParams.
       *
       * A route object is the kernel of the routing system. It is intended to
       * be fed into consuming elements such as `app-route`.
       *
       * @type {?Object}
       */
      route: {
        type: Object,
        notify: true
      },

      /**
       * A set of key/value pairs that are universally accessible to branches of
       * the route tree.
       *
       * @type {?Object}
       */
      queryParams: {
        type: Object,
        notify: true
      },

      /**
       * The serialized path through the route tree. This corresponds to the
       * `window.location.pathname` value, and will update to reflect changes
       * to that value.
       */
      path: {
        type: String,
        notify: true
      }
    },

    observers: ['_locationChanged(path, queryParams)', '_routeChanged(route.prefix, route.path)', '_routeQueryParamsChanged(route.__queryParams)'],

    created: function created() {
      this.linkPaths('route.__queryParams', 'queryParams');
      this.linkPaths('queryParams', 'route.__queryParams');
    },

    /**
     * Handler called when the path or queryParams change.
     */
    _locationChanged: function _locationChanged() {
      if (this.route && this.route.path === this.path && this.queryParams === this.route.__queryParams) {
        return;
      }
      this.route = {
        prefix: '',
        path: this.path,
        __queryParams: this.queryParams
      };
    },

    /**
     * Handler called when the route prefix and route path change.
     */
    _routeChanged: function _routeChanged() {
      if (!this.route) {
        return;
      }

      this.path = this.route.prefix + this.route.path;
    },

    /**
     * Handler called when the route queryParams change.
     *
     * @param  {Object} queryParams A set of key/value pairs that are
     * universally accessible to branches of the route tree.
     */
    _routeQueryParamsChanged: function _routeQueryParamsChanged(queryParams) {
      if (!this.route) {
        return;
      }
      this.queryParams = queryParams;
    }
  };
})();

/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

(function () {
  'use strict';

  Polymer({
    is: 'app-route',

    properties: {
      /**
       * The URL component managed by this element.
       */
      route: {
        type: Object,
        notify: true
      },

      /**
       * The pattern of slash-separated segments to match `route.path` against.
       *
       * For example the pattern "/foo" will match "/foo" or "/foo/bar"
       * but not "/foobar".
       *
       * Path segments like `/:named` are mapped to properties on the `data` object.
       */
      pattern: {
        type: String
      },

      /**
       * The parameterized values that are extracted from the route as
       * described by `pattern`.
       */
      data: {
        type: Object,
        value: function value() {
          return {};
        },
        notify: true
      },

      /**
       * @type {?Object}
       */
      queryParams: {
        type: Object,
        value: function value() {
          return {};
        },
        notify: true
      },

      /**
       * The part of `route.path` NOT consumed by `pattern`.
       */
      tail: {
        type: Object,
        value: function value() {
          return { path: null, prefix: null, __queryParams: null };
        },
        notify: true
      },

      /**
       * Whether the current route is active. True if `route.path` matches the
       * `pattern`, false otherwise.
       */
      active: {
        type: Boolean,
        notify: true,
        readOnly: true
      },

      _queryParamsUpdating: {
        type: Boolean,
        value: false
      },
      /**
       * @type {?string}
       */
      _matched: {
        type: String,
        value: ''
      }
    },

    observers: ['__tryToMatch(route.path, pattern)', '__updatePathOnDataChange(data.*)', '__tailPathChanged(tail.path)', '__routeQueryParamsChanged(route.__queryParams)', '__tailQueryParamsChanged(tail.__queryParams)', '__queryParamsChanged(queryParams.*)'],

    created: function created() {
      this.linkPaths('route.__queryParams', 'tail.__queryParams');
      this.linkPaths('tail.__queryParams', 'route.__queryParams');
    },

    /**
     * Deal with the query params object being assigned to wholesale.
     */
    __routeQueryParamsChanged: function __routeQueryParamsChanged(queryParams) {
      if (queryParams && this.tail) {
        if (this.tail.__queryParams !== queryParams) {
          this.set('tail.__queryParams', queryParams);
        }

        if (!this.active || this._queryParamsUpdating) {
          return;
        }

        // Copy queryParams and track whether there are any differences compared
        // to the existing query params.
        var copyOfQueryParams = {};
        var anythingChanged = false;
        for (var key in queryParams) {
          copyOfQueryParams[key] = queryParams[key];
          if (anythingChanged || !this.queryParams || queryParams[key] !== this.queryParams[key]) {
            anythingChanged = true;
          }
        }
        // Need to check whether any keys were deleted
        for (var key in this.queryParams) {
          if (anythingChanged || !(key in queryParams)) {
            anythingChanged = true;
            break;
          }
        }

        if (!anythingChanged) {
          return;
        }
        this._queryParamsUpdating = true;
        this.set('queryParams', copyOfQueryParams);
        this._queryParamsUpdating = false;
      }
    },

    __tailQueryParamsChanged: function __tailQueryParamsChanged(queryParams) {
      if (queryParams && this.route && this.route.__queryParams != queryParams) {
        this.set('route.__queryParams', queryParams);
      }
    },

    __queryParamsChanged: function __queryParamsChanged(changes) {
      if (!this.active || this._queryParamsUpdating) {
        return;
      }

      this.set('route.__' + changes.path, changes.value);
    },

    __resetProperties: function __resetProperties() {
      this._setActive(false);
      this._matched = null;
    },

    __tryToMatch: function __tryToMatch() {
      if (!this.route) {
        return;
      }

      var path = this.route.path;
      var pattern = this.pattern;

      if (!pattern) {
        return;
      }

      if (!path) {
        this.__resetProperties();
        return;
      }

      var remainingPieces = path.split('/');
      var patternPieces = pattern.split('/');

      var matched = [];
      var namedMatches = {};

      for (var i = 0; i < patternPieces.length; i++) {
        var patternPiece = patternPieces[i];
        if (!patternPiece && patternPiece !== '') {
          break;
        }
        var pathPiece = remainingPieces.shift();

        // We don't match this path.
        if (!pathPiece && pathPiece !== '') {
          this.__resetProperties();
          return;
        }
        matched.push(pathPiece);

        if (patternPiece.charAt(0) == ':') {
          namedMatches[patternPiece.slice(1)] = pathPiece;
        } else if (patternPiece !== pathPiece) {
          this.__resetProperties();
          return;
        }
      }

      this._matched = matched.join('/');

      // Properties that must be updated atomically.
      var propertyUpdates = {};

      //this.active
      if (!this.active) {
        propertyUpdates.active = true;
      }

      // this.tail
      var tailPrefix = this.route.prefix + this._matched;
      var tailPath = remainingPieces.join('/');
      if (remainingPieces.length > 0) {
        tailPath = '/' + tailPath;
      }
      if (!this.tail || this.tail.prefix !== tailPrefix || this.tail.path !== tailPath) {
        propertyUpdates.tail = {
          prefix: tailPrefix,
          path: tailPath,
          __queryParams: this.route.__queryParams
        };
      }

      // this.data
      propertyUpdates.data = namedMatches;
      this._dataInUrl = {};
      for (var key in namedMatches) {
        this._dataInUrl[key] = namedMatches[key];
      }

      if (this.setProperties) {
        if (!this.active) {
          this._setActive(true);
        }
        // atomic update
        this.setProperties(propertyUpdates);
      } else {
        this.__setMulti(propertyUpdates);
      }
    },

    __tailPathChanged: function __tailPathChanged(path) {
      if (!this.active) {
        return;
      }
      var tailPath = path;
      var newPath = this._matched;
      if (tailPath) {
        if (tailPath.charAt(0) !== '/') {
          tailPath = '/' + tailPath;
        }
        newPath += tailPath;
      }
      this.set('route.path', newPath);
    },

    __updatePathOnDataChange: function __updatePathOnDataChange() {
      if (!this.route || !this.active) {
        return;
      }
      var newPath = this.__getLink({});
      var oldPath = this.__getLink(this._dataInUrl);
      if (newPath === oldPath) {
        return;
      }
      this.set('route.path', newPath);
    },

    __getLink: function __getLink(overrideValues) {
      var values = { tail: null };
      for (var key in this.data) {
        values[key] = this.data[key];
      }
      for (var key in overrideValues) {
        values[key] = overrideValues[key];
      }
      var patternPieces = this.pattern.split('/');
      var interp = patternPieces.map(function (value) {
        if (value[0] == ':') {
          value = values[value.slice(1)];
        }
        return value;
      }, this);
      if (values.tail && values.tail.path) {
        if (interp.length > 0 && values.tail.path.charAt(0) === '/') {
          interp.push(values.tail.path.slice(1));
        } else {
          interp.push(values.tail.path);
        }
      }
      return interp.join('/');
    },

    __setMulti: function __setMulti(setObj) {
      // HACK(rictic): skirting around 1.0's lack of a setMulti by poking at
      //     internal data structures. I would not advise that you copy this
      //     example.
      //
      //     In the future this will be a feature of Polymer itself.
      //     See: https://github.com/Polymer/polymer/issues/3640
      //
      //     Hacking around with private methods like this is juggling footguns,
      //     and is likely to have unexpected and unsupported rough edges.
      //
      //     Be ye so warned.
      for (var property in setObj) {
        this._propertySetter(property, setObj[property]);
      }
      //notify in a specific order
      if (setObj.data !== undefined) {
        this._pathEffector('data', this.data);
        this._notifyChange('data');
      }
      if (setObj.active !== undefined) {
        this._pathEffector('active', this.active);
        this._notifyChange('active');
      }
      if (setObj.tail !== undefined) {
        this._pathEffector('tail', this.tail);
        this._notifyChange('tail');
      }
    }
  });
})();

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

__webpack_require__(17);

__webpack_require__(29);

var RegisterHtmlTemplate = __webpack_require__(2);

RegisterHtmlTemplate.register("<dom-module id=iron-pages> <template> <style>:host{display:block}:host>::slotted(:not(.iron-selected)){display:none!important}</style> <slot></slot> </template> </dom-module>");

Polymer({

  is: 'iron-pages',

  behaviors: [Polymer.IronResizableBehavior, Polymer.IronSelectableBehavior],

  properties: {

    // as the selected page is the only one visible, activateEvent
    // is both non-sensical and problematic; e.g. in cases where a user
    // handler attempts to change the page and the activateEvent
    // handler immediately changes it back
    activateEvent: {
      type: String,
      value: null
    }

  },

  observers: ['_selectedPageChanged(selected)'],

  _selectedPageChanged: function _selectedPageChanged(selected, old) {
    this.async(this.notifyResize);
  }
});

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

/**
 * @param {!Function} selectCallback
 * @constructor
 */
Polymer.IronSelection = function (selectCallback) {
  this.selection = [];
  this.selectCallback = selectCallback;
};

Polymer.IronSelection.prototype = {

  /**
   * Retrieves the selected item(s).
   *
   * @method get
   * @returns Returns the selected item(s). If the multi property is true,
   * `get` will return an array, otherwise it will return
   * the selected item or undefined if there is no selection.
   */
  get: function get() {
    return this.multi ? this.selection.slice() : this.selection[0];
  },

  /**
   * Clears all the selection except the ones indicated.
   *
   * @method clear
   * @param {Array} excludes items to be excluded.
   */
  clear: function clear(excludes) {
    this.selection.slice().forEach(function (item) {
      if (!excludes || excludes.indexOf(item) < 0) {
        this.setItemSelected(item, false);
      }
    }, this);
  },

  /**
   * Indicates if a given item is selected.
   *
   * @method isSelected
   * @param {*} item The item whose selection state should be checked.
   * @returns Returns true if `item` is selected.
   */
  isSelected: function isSelected(item) {
    return this.selection.indexOf(item) >= 0;
  },

  /**
   * Sets the selection state for a given item to either selected or deselected.
   *
   * @method setItemSelected
   * @param {*} item The item to select.
   * @param {boolean} isSelected True for selected, false for deselected.
   */
  setItemSelected: function setItemSelected(item, isSelected) {
    if (item != null) {
      if (isSelected !== this.isSelected(item)) {
        // proceed to update selection only if requested state differs from current
        if (isSelected) {
          this.selection.push(item);
        } else {
          var i = this.selection.indexOf(item);
          if (i >= 0) {
            this.selection.splice(i, 1);
          }
        }
        if (this.selectCallback) {
          this.selectCallback(item, isSelected);
        }
      }
    }
  },

  /**
   * Sets the selection state for a given item. If the `multi` property
   * is true, then the selected state of `item` will be toggled; otherwise
   * the `item` will be selected.
   *
   * @method select
   * @param {*} item The item to select.
   */
  select: function select(item) {
    if (this.multi) {
      this.toggle(item);
    } else if (this.get() !== item) {
      this.setItemSelected(this.get(), false);
      this.setItemSelected(item, true);
    }
  },

  /**
   * Toggles the selection state for `item`.
   *
   * @method toggle
   * @param {*} item The item to toggle.
   */
  toggle: function toggle(item) {
    this.setItemSelected(item, !this.isSelected(item));
  }

};

/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

__webpack_require__(83);

/**
`iron-selector` is an element which can be used to manage a list of elements
that can be selected.  Tapping on the item will make the item selected.  The `selected` indicates
which item is being selected.  The default is to use the index of the item.
 Example:
     <iron-selector selected="0">
      <div>Item 1</div>
      <div>Item 2</div>
      <div>Item 3</div>
    </iron-selector>
 If you want to use the attribute value of an element for `selected` instead of the index,
set `attrForSelected` to the name of the attribute.  For example, if you want to select item by
`name`, set `attrForSelected` to `name`.
 Example:
     <iron-selector attr-for-selected="name" selected="foo">
      <div name="foo">Foo</div>
      <div name="bar">Bar</div>
      <div name="zot">Zot</div>
    </iron-selector>
 You can specify a default fallback with `fallbackSelection` in case the `selected` attribute does
not match the `attrForSelected` attribute of any elements.
 Example:
       <iron-selector attr-for-selected="name" selected="non-existing"
                     fallback-selection="default">
        <div name="foo">Foo</div>
        <div name="bar">Bar</div>
        <div name="default">Default</div>
      </iron-selector>
 Note: When the selector is multi, the selection will set to `fallbackSelection` iff
the number of matching elements is zero.
 `iron-selector` is not styled. Use the `iron-selected` CSS class to style the selected element.
 Example:
     <style>
      .iron-selected {
        background: #eee;
      }
    </style>
     ...
     <iron-selector selected="0">
      <div>Item 1</div>
      <div>Item 2</div>
      <div>Item 3</div>
    </iron-selector>
 @demo demo/index.html
*/

Polymer({

  is: 'iron-selector',

  behaviors: [Polymer.IronMultiSelectableBehavior]

});

/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

__webpack_require__(29);

/**
 * @polymerBehavior Polymer.IronMultiSelectableBehavior
 */
Polymer.IronMultiSelectableBehaviorImpl = {
  properties: {

    /**
     * If true, multiple selections are allowed.
     */
    multi: {
      type: Boolean,
      value: false,
      observer: 'multiChanged'
    },

    /**
     * Gets or sets the selected elements. This is used instead of `selected` when `multi`
     * is true.
     */
    selectedValues: {
      type: Array,
      notify: true,
      value: function value() {
        return [];
      }
    },

    /**
     * Returns an array of currently selected items.
     */
    selectedItems: {
      type: Array,
      readOnly: true,
      notify: true,
      value: function value() {
        return [];
      }
    }

  },

  observers: ['_updateSelected(selectedValues.splices)'],

  /**
   * Selects the given value. If the `multi` property is true, then the selected state of the
   * `value` will be toggled; otherwise the `value` will be selected.
   *
   * @method select
   * @param {string|number} value the value to select.
   */
  select: function select(value) {
    if (this.multi) {
      this._toggleSelected(value);
    } else {
      this.selected = value;
    }
  },

  multiChanged: function multiChanged(multi) {
    this._selection.multi = multi;
    this._updateSelected();
  },

  // UNUSED, FOR API COMPATIBILITY
  get _shouldUpdateSelection() {
    return this.selected != null || this.selectedValues != null && this.selectedValues.length;
  },

  _updateAttrForSelected: function _updateAttrForSelected() {
    if (!this.multi) {
      Polymer.IronSelectableBehavior._updateAttrForSelected.apply(this);
    } else if (this.selectedItems && this.selectedItems.length > 0) {
      this.selectedValues = this.selectedItems.map(function (selectedItem) {
        return this._indexToValue(this.indexOf(selectedItem));
      }, this).filter(function (unfilteredValue) {
        return unfilteredValue != null;
      }, this);
    }
  },

  _updateSelected: function _updateSelected() {
    if (this.multi) {
      this._selectMulti(this.selectedValues);
    } else {
      this._selectSelected(this.selected);
    }
  },

  _selectMulti: function _selectMulti(values) {
    values = values || [];

    var selectedItems = (this._valuesToItems(values) || []).filter(function (item) {
      return item !== null && item !== undefined;
    });

    // clear all but the current selected items
    this._selection.clear(selectedItems);

    // select only those not selected yet
    for (var i = 0; i < selectedItems.length; i++) {
      this._selection.setItemSelected(selectedItems[i], true);
    }

    // Check for items, since this array is populated only when attached
    if (this.fallbackSelection && !this._selection.get().length) {
      var fallback = this._valueToItem(this.fallbackSelection);
      if (fallback) {
        this.select(this.fallbackSelection);
      }
    }
  },

  _selectionChange: function _selectionChange() {
    var s = this._selection.get();
    if (this.multi) {
      this._setSelectedItems(s);
      this._setSelectedItem(s.length ? s[0] : null);
    } else {
      if (s !== null && s !== undefined) {
        this._setSelectedItems([s]);
        this._setSelectedItem(s);
      } else {
        this._setSelectedItems([]);
        this._setSelectedItem(null);
      }
    }
  },

  _toggleSelected: function _toggleSelected(value) {
    var i = this.selectedValues.indexOf(value);
    var unselected = i < 0;
    if (unselected) {
      this.push('selectedValues', value);
    } else {
      this.splice('selectedValues', i, 1);
    }
  },

  _valuesToItems: function _valuesToItems(values) {
    return values == null ? null : values.map(function (value) {
      return this._valueToItem(value);
    }, this);
  }
};

/** @polymerBehavior */
Polymer.IronMultiSelectableBehavior = [Polymer.IronSelectableBehavior, Polymer.IronMultiSelectableBehaviorImpl];

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

__webpack_require__(37);

__webpack_require__(85);

/**
 * `Polymer.PaperInkyFocusBehavior` implements a ripple when the element has keyboard focus.
 *
 * @polymerBehavior Polymer.PaperInkyFocusBehavior
 */
Polymer.PaperInkyFocusBehaviorImpl = {
  observers: ['_focusedChanged(receivedFocusFromKeyboard)'],

  _focusedChanged: function _focusedChanged(receivedFocusFromKeyboard) {
    if (receivedFocusFromKeyboard) {
      this.ensureRipple();
    }
    if (this.hasRipple()) {
      this._ripple.holdDown = receivedFocusFromKeyboard;
    }
  },

  _createRipple: function _createRipple() {
    var ripple = Polymer.PaperRippleBehavior._createRipple();
    ripple.id = 'ink';
    ripple.setAttribute('center', '');
    ripple.classList.add('circle');
    return ripple;
  }
};

/** @polymerBehavior Polymer.PaperInkyFocusBehavior */
Polymer.PaperInkyFocusBehavior = [Polymer.IronButtonState, Polymer.IronControlState, Polymer.PaperRippleBehavior, Polymer.PaperInkyFocusBehaviorImpl];

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

__webpack_require__(35);

/**
 * `Polymer.PaperRippleBehavior` dynamically implements a ripple
 * when the element has focus via pointer or keyboard.
 *
 * NOTE: This behavior is intended to be used in conjunction with and after
 * `Polymer.IronButtonState` and `Polymer.IronControlState`.
 *
 * @polymerBehavior Polymer.PaperRippleBehavior
 */
Polymer.PaperRippleBehavior = {
  properties: {
    /**
     * If true, the element will not produce a ripple effect when interacted
     * with via the pointer.
     */
    noink: {
      type: Boolean,
      observer: '_noinkChanged'
    },

    /**
     * @type {Element|undefined}
     */
    _rippleContainer: {
      type: Object
    }
  },

  /**
   * Ensures a `<paper-ripple>` element is available when the element is
   * focused.
   */
  _buttonStateChanged: function _buttonStateChanged() {
    if (this.focused) {
      this.ensureRipple();
    }
  },

  /**
   * In addition to the functionality provided in `IronButtonState`, ensures
   * a ripple effect is created when the element is in a `pressed` state.
   */
  _downHandler: function _downHandler(event) {
    Polymer.IronButtonStateImpl._downHandler.call(this, event);
    if (this.pressed) {
      this.ensureRipple(event);
    }
  },

  /**
   * Ensures this element contains a ripple effect. For startup efficiency
   * the ripple effect is dynamically on demand when needed.
   * @param {!Event=} optTriggeringEvent (optional) event that triggered the
   * ripple.
   */
  ensureRipple: function ensureRipple(optTriggeringEvent) {
    if (!this.hasRipple()) {
      this._ripple = this._createRipple();
      this._ripple.noink = this.noink;
      var rippleContainer = this._rippleContainer || this.root;
      if (rippleContainer) {
        Polymer.dom(rippleContainer).appendChild(this._ripple);
      }
      if (optTriggeringEvent) {
        // Check if the event happened inside of the ripple container
        // Fall back to host instead of the root because distributed text
        // nodes are not valid event targets
        var domContainer = Polymer.dom(this._rippleContainer || this);
        var target = Polymer.dom(optTriggeringEvent).rootTarget;
        if (domContainer.deepContains( /** @type {Node} */target)) {
          this._ripple.uiDownAction(optTriggeringEvent);
        }
      }
    }
  },

  /**
   * Returns the `<paper-ripple>` element used by this element to create
   * ripple effects. The element's ripple is created on demand, when
   * necessary, and calling this method will force the
   * ripple to be created.
   */
  getRipple: function getRipple() {
    this.ensureRipple();
    return this._ripple;
  },

  /**
   * Returns true if this element currently contains a ripple effect.
   * @return {boolean}
   */
  hasRipple: function hasRipple() {
    return Boolean(this._ripple);
  },

  /**
   * Create the element's ripple effect via creating a `<paper-ripple>`.
   * Override this method to customize the ripple element.
   * @return {!PaperRippleElement} Returns a `<paper-ripple>` element.
   */
  _createRipple: function _createRipple() {
    return (/** @type {!PaperRippleElement} */document.createElement('paper-ripple')
    );
  },

  _noinkChanged: function _noinkChanged(noink) {
    if (this.hasRipple()) {
      this._ripple.noink = noink;
    }
  }
};

/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(32);

var RegisterHtmlTemplate = __webpack_require__(2);

RegisterHtmlTemplate.toBody("<iron-iconset-svg name=my-icons size=24> <svg> <defs> <g id=arrow-back> <path d=\"M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z\"></path> </g> <g id=menu> <path d=\"M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z\"></path> </g> <g id=chevron-right> <path d=\"M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z\"></path> </g> <g id=close> <path d=\"M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z\"></path> </g> <g id=search><path d=\"M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z\"></path> </g> </defs> </svg> </iron-iconset-svg>");

/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgZDVhOGRmNTEwYmQ0ZTE3ZWI2N2UiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL3BvbHltZXIuaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL3BvbHltZXIvbGliL3V0aWxzL2Jvb3QuaHRtbCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcG9seW1lci13ZWJwYWNrLWxvYWRlci9yZWdpc3Rlci1odG1sLXRlbXBsYXRlLmpzIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvdXRpbHMvbWl4aW4uaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL2FwcC1sYXlvdXQvYXBwLXNjcm9sbC1lZmZlY3RzL2FwcC1zY3JvbGwtZWZmZWN0cy1iZWhhdmlvci5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvaXJvbi1mbGV4LWxheW91dC9pcm9uLWZsZXgtbGF5b3V0Lmh0bWwiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL3BvbHltZXItZWxlbWVudC5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvdXRpbHMvcmVzb2x2ZS11cmwuaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL3BvbHltZXIvbGliL3V0aWxzL2FzeW5jLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi9taXhpbnMvbXV0YWJsZS1kYXRhLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi91dGlscy9jYXNlLW1hcC5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvbWl4aW5zL3Byb3BlcnR5LWVmZmVjdHMuaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL3BvbHltZXIvbGliL3V0aWxzL2RlYm91bmNlLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi91dGlscy9mbHVzaC5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvdXRpbHMvdGVtcGxhdGl6ZS5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvYXBwLWxheW91dC9hcHAtbGF5b3V0LWJlaGF2aW9yL2FwcC1sYXlvdXQtYmVoYXZpb3IuaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL2lyb24tYTExeS1rZXlzLWJlaGF2aW9yL2lyb24tYTExeS1rZXlzLWJlaGF2aW9yLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9pcm9uLXJlc2l6YWJsZS1iZWhhdmlvci9pcm9uLXJlc2l6YWJsZS1iZWhhdmlvci5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvaXJvbi1tZXRhL2lyb24tbWV0YS5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvbWl4aW5zL2VsZW1lbnQtbWl4aW4uaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL3BvbHltZXIvbGliL3V0aWxzL3NldHRpbmdzLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi91dGlscy9zdHlsZS1nYXRoZXIuaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL3BvbHltZXIvbGliL2xlZ2FjeS9sZWdhY3ktZWxlbWVudC1taXhpbi5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvbWl4aW5zL2dlc3R1cmUtZXZlbnQtbGlzdGVuZXJzLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi91dGlscy9hcnJheS1zcGxpY2UuaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL2FwcC1sYXlvdXQvYXBwLXNjcm9sbC1lZmZlY3RzL2VmZmVjdHMvYmxlbmQtYmFja2dyb3VuZC5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvYXBwLWxheW91dC9hcHAtc2Nyb2xsLWVmZmVjdHMvZWZmZWN0cy93YXRlcmZhbGwuaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL2FwcC1sYXlvdXQvYXBwLXNjcm9sbC1lZmZlY3RzL2VmZmVjdHMvcmVzaXplLXRpdGxlLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9hcHAtbGF5b3V0L2FwcC1zY3JvbGwtZWZmZWN0cy9lZmZlY3RzL3BhcmFsbGF4LWJhY2tncm91bmQuaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL2lyb24tc2VsZWN0b3IvaXJvbi1zZWxlY3RhYmxlLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9wYXBlci1zdHlsZXMvZGVmYXVsdC10aGVtZS5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvaXJvbi1pY29uL2lyb24taWNvbi5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvaXJvbi1pY29uc2V0LXN2Zy9pcm9uLWljb25zZXQtc3ZnLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9wYXBlci1pY29uLWJ1dHRvbi9wYXBlci1pY29uLWJ1dHRvbi5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvaXJvbi1iZWhhdmlvcnMvaXJvbi1jb250cm9sLXN0YXRlLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9wYXBlci1yaXBwbGUvcGFwZXItcmlwcGxlLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9pcm9uLXNjcm9sbC10YXJnZXQtYmVoYXZpb3IvaXJvbi1zY3JvbGwtdGFyZ2V0LWJlaGF2aW9yLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9pcm9uLWJlaGF2aW9ycy9pcm9uLWJ1dHRvbi1zdGF0ZS5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvcGFwZXItc3R5bGVzL2NvbG9yLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vc3JjL215LWFwcC5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvZWxlbWVudHMvZG9tLW1vZHVsZS5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvdXRpbHMvcGF0aC5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvbWl4aW5zL3Byb3BlcnR5LWFjY2Vzc29ycy5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvbWl4aW5zL3RlbXBsYXRlLXN0YW1wLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9hcHAtbGF5b3V0L2FwcC1kcmF3ZXIvYXBwLWRyYXdlci5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvc2hhZHljc3MvYXBwbHktc2hpbS5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvc2hhZHljc3MvYXBwbHktc2hpbS5taW4uanMiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi91dGlscy9nZXN0dXJlcy5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvdXRpbHMvaW1wb3J0LWhyZWYuaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL3BvbHltZXIvbGliL3V0aWxzL3JlbmRlci1zdGF0dXMuaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL3BvbHltZXIvbGliL3V0aWxzL3VucmVzb2x2ZWQuaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL3BvbHltZXIvbGliL2xlZ2FjeS9wb2x5bWVyLmRvbS5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvdXRpbHMvZmxhdHRlbmVkLW5vZGVzLW9ic2VydmVyLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi9sZWdhY3kvcG9seW1lci1mbi5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvbGVnYWN5L2NsYXNzLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi9sZWdhY3kvdGVtcGxhdGl6ZXItYmVoYXZpb3IuaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL3BvbHltZXIvbGliL2VsZW1lbnRzL2RvbS1iaW5kLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi9lbGVtZW50cy9kb20tcmVwZWF0Lmh0bWwiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi9lbGVtZW50cy9kb20taWYuaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL3BvbHltZXIvbGliL2VsZW1lbnRzL2FycmF5LXNlbGVjdG9yLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi9lbGVtZW50cy9jdXN0b20tc3R5bGUuaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL3NoYWR5Y3NzL2N1c3RvbS1zdHlsZS1pbnRlcmZhY2UuaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL3NoYWR5Y3NzL2N1c3RvbS1zdHlsZS1pbnRlcmZhY2UubWluLmpzIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvbGVnYWN5L211dGFibGUtZGF0YS1iZWhhdmlvci5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvYXBwLWxheW91dC9hcHAtZHJhd2VyLWxheW91dC9hcHAtZHJhd2VyLWxheW91dC5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvaXJvbi1tZWRpYS1xdWVyeS9pcm9uLW1lZGlhLXF1ZXJ5Lmh0bWwiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9hcHAtbGF5b3V0L2FwcC1oZWFkZXIvYXBwLWhlYWRlci5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvYXBwLWxheW91dC9oZWxwZXJzL2hlbHBlcnMuaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL2FwcC1sYXlvdXQvYXBwLWhlYWRlci1sYXlvdXQvYXBwLWhlYWRlci1sYXlvdXQuaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL2FwcC1sYXlvdXQvYXBwLXNjcm9sbC1lZmZlY3RzL2FwcC1zY3JvbGwtZWZmZWN0cy5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvYXBwLWxheW91dC9hcHAtc2Nyb2xsLWVmZmVjdHMvZWZmZWN0cy9mYWRlLWJhY2tncm91bmQuaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL2FwcC1sYXlvdXQvYXBwLXNjcm9sbC1lZmZlY3RzL2VmZmVjdHMvbWF0ZXJpYWwuaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL2FwcC1sYXlvdXQvYXBwLXNjcm9sbC1lZmZlY3RzL2VmZmVjdHMvcmVzaXplLXNuYXBwZWQtdGl0bGUuaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL2FwcC1sYXlvdXQvYXBwLXRvb2xiYXIvYXBwLXRvb2xiYXIuaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL2FwcC1yb3V0ZS9hcHAtbG9jYXRpb24uaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL2lyb24tbG9jYXRpb24vaXJvbi1sb2NhdGlvbi5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvaXJvbi1sb2NhdGlvbi9pcm9uLXF1ZXJ5LXBhcmFtcy5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvYXBwLXJvdXRlL2FwcC1yb3V0ZS1jb252ZXJ0ZXItYmVoYXZpb3IuaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL2FwcC1yb3V0ZS9hcHAtcm91dGUuaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL2lyb24tcGFnZXMvaXJvbi1wYWdlcy5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvaXJvbi1zZWxlY3Rvci9pcm9uLXNlbGVjdGlvbi5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvaXJvbi1zZWxlY3Rvci9pcm9uLXNlbGVjdG9yLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9pcm9uLXNlbGVjdG9yL2lyb24tbXVsdGktc2VsZWN0YWJsZS5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvcGFwZXItYmVoYXZpb3JzL3BhcGVyLWlua3ktZm9jdXMtYmVoYXZpb3IuaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL3BhcGVyLWJlaGF2aW9ycy9wYXBlci1yaXBwbGUtYmVoYXZpb3IuaHRtbCIsIndlYnBhY2s6Ly8vLi9zcmMvbXktaWNvbnMuaHRtbCJdLCJuYW1lcyI6WyJSZWdpc3Rlckh0bWxUZW1wbGF0ZSIsInZhbCIsImNvbnRlbnQiLCJ0ZW1wbGF0ZSIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImlubmVySFRNTCIsImNyZWF0ZURvY3VtZW50RnJhZ21lbnQiLCJmaXJzdENoaWxkIiwiYXBwZW5kQ2hpbGQiLCJpbXBvcnROb2RlIiwidHJpbW1lZFZhbCIsInRyaW0iLCJkaXYiLCJib2R5IiwiaW5zZXJ0QmVmb3JlIiwiYWRkRXZlbnRMaXN0ZW5lciIsIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIiwidG9Cb2R5IiwiayIsIm4iLCJlbmQiLCJzdGFydCIsInJ1bGVzIiwicGFyZW50IiwicHJldmlvdXMiLCJjc3NUZXh0IiwicGFyc2VkQ3NzVGV4dCIsImF0UnVsZSIsInR5cGUiLCJwYXJzZWRTZWxlY3RvciIsInNlbGVjdG9yIiwia2V5ZnJhbWVzTmFtZSIsInAiLCJhIiwicmVwbGFjZSIsImFhIiwiYmEiLCJiIiwicSIsImMiLCJkIiwibGVuZ3RoIiwiZSIsImYiLCJoIiwiZyIsIm0iLCJwdXNoIiwic3Vic3RyaW5nIiwiY2EiLCJyIiwibGFzdEluZGV4T2YiLCJpbmRleE9mIiwidCIsIm1hdGNoIiwiZGEiLCJ1Iiwic3BsaXQiLCJwb3AiLCJ2IiwieCIsInkiLCJlYSIsImZhIiwiaGEiLCJpYSIsImphIiwiUHJvbWlzZSIsInJlc29sdmUiLCJrYSIsIl9hcHBseVNoaW1DdXJyZW50VmVyc2lvbiIsIl9hcHBseVNoaW1WYWxpZGF0aW5nVmVyc2lvbiIsIl9hcHBseVNoaW1OZXh0VmVyc2lvbiIsInoiLCJsYSIsInRoZW4iLCJBIiwid2luZG93IiwiU2hhZHlET00iLCJpblVzZSIsIkIiLCJDIiwic2hpbWNzc3Byb3BlcnRpZXMiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJDU1MiLCJzdXBwb3J0cyIsIlNoYWR5Q1NTIiwibmF0aXZlQ3NzIiwiV2ViQ29tcG9uZW50cyIsImZsYWdzIiwiRSIsIkYiLCJHIiwibWEiLCJIIiwiSSIsIl9fY3NzUnVsZXMiLCJ0ZXh0Q29udGVudCIsIkoiLCJtYXRjaE1lZGlhIiwibWF0Y2hlcyIsIksiLCJuYSIsIm9hIiwiTCIsInByb3RvdHlwZSIsInNldCIsImkiLCJnZXQiLCJNIiwiTiIsIm8iLCJ0ZXN0IiwibGFzdEluZGV4IiwicXVlcnlTZWxlY3RvciIsImoiLCJsIiwicGEiLCJxYSIsIk8iLCJleGVjIiwiaW5kZXgiLCJzbGljZSIsIlAiLCJqb2luIiwic2V0QXR0cmlidXRlIiwic3R5bGUiLCJhbGwiLCJoZWFkIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImdldFByb3BlcnR5VmFsdWUiLCJyYSIsIk9iamVjdCIsImFzc2lnbiIsImNyZWF0ZSIsIlgiLCJ3IiwiWSIsIkQiLCJkZXRlY3RNaXhpbiIsInRyYW5zZm9ybVN0eWxlIiwidHJhbnNmb3JtQ3VzdG9tU3R5bGUiLCJ0cmFuc2Zvcm1SdWxlcyIsInRyYW5zZm9ybVJ1bGUiLCJ0cmFuc2Zvcm1UZW1wbGF0ZSIsIl9zZXBhcmF0b3IiLCJkZWZpbmVQcm9wZXJ0eSIsIlEiLCJSIiwiSFRNTEltcG9ydHMiLCJ3aGVuUmVhZHkiLCJTIiwic2EiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJyZWFkeVN0YXRlIiwiVCIsIlUiLCJWIiwiaW52YWxpZENhbGxiYWNrIiwiQ3VzdG9tU3R5bGVJbnRlcmZhY2UiLCJ0cmFuc2Zvcm1DYWxsYmFjayIsInZhbGlkYXRlQ2FsbGJhY2siLCJlbnF1ZXVlZCIsIlciLCJwcmVwYXJlVGVtcGxhdGUiLCJfc3R5bGVBc3QiLCJwcm9jZXNzU3R5bGVzIiwiZ2V0U3R5bGVGb3JDdXN0b21TdHlsZSIsInN0eWxlU3VidHJlZSIsInJlbW92ZVByb3BlcnR5Iiwic2V0UHJvcGVydHkiLCJzaGFkb3dSb290Iiwic3R5bGVFbGVtZW50IiwiY2hpbGRyZW4iLCJjaGlsZE5vZGVzIiwibG9jYWxOYW1lIiwiZ2V0QXR0cmlidXRlIiwiaXMiLCJzdHlsZURvY3VtZW50IiwiU2NvcGluZ1NoaW0iLCJaIiwidGEiLCJnZXRDb21wdXRlZFN0eWxlVmFsdWUiLCJuYXRpdmVTaGFkb3ciLCJBcHBseVNoaW0iLCJjYWxsIiwiY3VzdG9tU3R5bGVzIiwiX19zZWVuQnlTaGFkeUNTUyIsIl9fc2hhZHlDU1NDYWNoZWRTdHlsZSIsImdldFN0eWxlIiwiX19hcHBsaWVkRWxlbWVudCIsImFkZEN1c3RvbVN0eWxlIiwiZGVmaW5lUHJvcGVydGllcyJdLCJtYXBwaW5ncyI6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QUN0QmhDLG1CQUFBQSxDQUFRLEVBQVI7O0FBRUEsSUFBTW5CLHVCQUF1QixtQkFBQW1CLENBQVEsQ0FBUixDQUE3Qjs7QUFFQW5CLHFCQUFxQm9CLE1BQXJCLENBQTRCLCt3QkFBNUIsRSIsImZpbGUiOiJtYWluLmJ1bmRsZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIGluc3RhbGwgYSBKU09OUCBjYWxsYmFjayBmb3IgY2h1bmsgbG9hZGluZ1xuIFx0dmFyIHBhcmVudEpzb25wRnVuY3Rpb24gPSB3aW5kb3dbXCJ3ZWJwYWNrSnNvbnBcIl07XG4gXHR3aW5kb3dbXCJ3ZWJwYWNrSnNvbnBcIl0gPSBmdW5jdGlvbiB3ZWJwYWNrSnNvbnBDYWxsYmFjayhjaHVua0lkcywgbW9yZU1vZHVsZXMsIGV4ZWN1dGVNb2R1bGVzKSB7XG4gXHRcdC8vIGFkZCBcIm1vcmVNb2R1bGVzXCIgdG8gdGhlIG1vZHVsZXMgb2JqZWN0LFxuIFx0XHQvLyB0aGVuIGZsYWcgYWxsIFwiY2h1bmtJZHNcIiBhcyBsb2FkZWQgYW5kIGZpcmUgY2FsbGJhY2tcbiBcdFx0dmFyIG1vZHVsZUlkLCBjaHVua0lkLCBpID0gMCwgcmVzb2x2ZXMgPSBbXSwgcmVzdWx0O1xuIFx0XHRmb3IoO2kgPCBjaHVua0lkcy5sZW5ndGg7IGkrKykge1xuIFx0XHRcdGNodW5rSWQgPSBjaHVua0lkc1tpXTtcbiBcdFx0XHRpZihpbnN0YWxsZWRDaHVua3NbY2h1bmtJZF0pIHtcbiBcdFx0XHRcdHJlc29sdmVzLnB1c2goaW5zdGFsbGVkQ2h1bmtzW2NodW5rSWRdWzBdKTtcbiBcdFx0XHR9XG4gXHRcdFx0aW5zdGFsbGVkQ2h1bmtzW2NodW5rSWRdID0gMDtcbiBcdFx0fVxuIFx0XHRmb3IobW9kdWxlSWQgaW4gbW9yZU1vZHVsZXMpIHtcbiBcdFx0XHRpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9yZU1vZHVsZXMsIG1vZHVsZUlkKSkge1xuIFx0XHRcdFx0bW9kdWxlc1ttb2R1bGVJZF0gPSBtb3JlTW9kdWxlc1ttb2R1bGVJZF07XG4gXHRcdFx0fVxuIFx0XHR9XG4gXHRcdGlmKHBhcmVudEpzb25wRnVuY3Rpb24pIHBhcmVudEpzb25wRnVuY3Rpb24oY2h1bmtJZHMsIG1vcmVNb2R1bGVzLCBleGVjdXRlTW9kdWxlcyk7XG4gXHRcdHdoaWxlKHJlc29sdmVzLmxlbmd0aCkge1xuIFx0XHRcdHJlc29sdmVzLnNoaWZ0KCkoKTtcbiBcdFx0fVxuXG4gXHR9O1xuXG4gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBvYmplY3RzIHRvIHN0b3JlIGxvYWRlZCBhbmQgbG9hZGluZyBjaHVua3NcbiBcdHZhciBpbnN0YWxsZWRDaHVua3MgPSB7XG4gXHRcdDY6IDBcbiBcdH07XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuIFx0Ly8gVGhpcyBmaWxlIGNvbnRhaW5zIG9ubHkgdGhlIGVudHJ5IGNodW5rLlxuIFx0Ly8gVGhlIGNodW5rIGxvYWRpbmcgZnVuY3Rpb24gZm9yIGFkZGl0aW9uYWwgY2h1bmtzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmUgPSBmdW5jdGlvbiByZXF1aXJlRW5zdXJlKGNodW5rSWQpIHtcbiBcdFx0dmFyIGluc3RhbGxlZENodW5rRGF0YSA9IGluc3RhbGxlZENodW5rc1tjaHVua0lkXTtcbiBcdFx0aWYoaW5zdGFsbGVkQ2h1bmtEYXRhID09PSAwKSB7XG4gXHRcdFx0cmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpIHsgcmVzb2x2ZSgpOyB9KTtcbiBcdFx0fVxuXG4gXHRcdC8vIGEgUHJvbWlzZSBtZWFucyBcImN1cnJlbnRseSBsb2FkaW5nXCIuXG4gXHRcdGlmKGluc3RhbGxlZENodW5rRGF0YSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRDaHVua0RhdGFbMl07XG4gXHRcdH1cblxuIFx0XHQvLyBzZXR1cCBQcm9taXNlIGluIGNodW5rIGNhY2hlXG4gXHRcdHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gXHRcdFx0aW5zdGFsbGVkQ2h1bmtEYXRhID0gaW5zdGFsbGVkQ2h1bmtzW2NodW5rSWRdID0gW3Jlc29sdmUsIHJlamVjdF07XG4gXHRcdH0pO1xuIFx0XHRpbnN0YWxsZWRDaHVua0RhdGFbMl0gPSBwcm9taXNlO1xuXG4gXHRcdC8vIHN0YXJ0IGNodW5rIGxvYWRpbmdcbiBcdFx0dmFyIGhlYWQgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdO1xuIFx0XHR2YXIgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gXHRcdHNjcmlwdC50eXBlID0gJ3RleHQvamF2YXNjcmlwdCc7XG4gXHRcdHNjcmlwdC5jaGFyc2V0ID0gJ3V0Zi04JztcbiBcdFx0c2NyaXB0LmFzeW5jID0gdHJ1ZTtcbiBcdFx0c2NyaXB0LnRpbWVvdXQgPSAxMjAwMDA7XG5cbiBcdFx0aWYgKF9fd2VicGFja19yZXF1aXJlX18ubmMpIHtcbiBcdFx0XHRzY3JpcHQuc2V0QXR0cmlidXRlKFwibm9uY2VcIiwgX193ZWJwYWNrX3JlcXVpcmVfXy5uYyk7XG4gXHRcdH1cbiBcdFx0c2NyaXB0LnNyYyA9IF9fd2VicGFja19yZXF1aXJlX18ucCArIFwiXCIgKyBjaHVua0lkICsgXCIuYnVuZGxlLmpzXCI7XG4gXHRcdHZhciB0aW1lb3V0ID0gc2V0VGltZW91dChvblNjcmlwdENvbXBsZXRlLCAxMjAwMDApO1xuIFx0XHRzY3JpcHQub25lcnJvciA9IHNjcmlwdC5vbmxvYWQgPSBvblNjcmlwdENvbXBsZXRlO1xuIFx0XHRmdW5jdGlvbiBvblNjcmlwdENvbXBsZXRlKCkge1xuIFx0XHRcdC8vIGF2b2lkIG1lbSBsZWFrcyBpbiBJRS5cbiBcdFx0XHRzY3JpcHQub25lcnJvciA9IHNjcmlwdC5vbmxvYWQgPSBudWxsO1xuIFx0XHRcdGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiBcdFx0XHR2YXIgY2h1bmsgPSBpbnN0YWxsZWRDaHVua3NbY2h1bmtJZF07XG4gXHRcdFx0aWYoY2h1bmsgIT09IDApIHtcbiBcdFx0XHRcdGlmKGNodW5rKSB7XG4gXHRcdFx0XHRcdGNodW5rWzFdKG5ldyBFcnJvcignTG9hZGluZyBjaHVuayAnICsgY2h1bmtJZCArICcgZmFpbGVkLicpKTtcbiBcdFx0XHRcdH1cbiBcdFx0XHRcdGluc3RhbGxlZENodW5rc1tjaHVua0lkXSA9IHVuZGVmaW5lZDtcbiBcdFx0XHR9XG4gXHRcdH07XG4gXHRcdGhlYWQuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcblxuIFx0XHRyZXR1cm4gcHJvbWlzZTtcbiBcdH07XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4gXHRcdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbiBcdFx0XHRcdGdldDogZ2V0dGVyXG4gXHRcdFx0fSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiZGlzdC9cIjtcblxuIFx0Ly8gb24gZXJyb3IgZnVuY3Rpb24gZm9yIGFzeW5jIGxvYWRpbmdcbiBcdF9fd2VicGFja19yZXF1aXJlX18ub2UgPSBmdW5jdGlvbihlcnIpIHsgY29uc29sZS5lcnJvcihlcnIpOyB0aHJvdyBlcnI7IH07XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gMzkpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2svYm9vdHN0cmFwIGQ1YThkZjUxMGJkNGUxN2ViNjdlIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cImxpYi9sZWdhY3kvbGVnYWN5LWVsZW1lbnQtbWl4aW4uaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cImxpYi9sZWdhY3kvcG9seW1lci1mbi5odG1sXCI+XG48IS0tIHRlbXBsYXRlIGVsZW1lbnRzIC0tPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cImxpYi9sZWdhY3kvdGVtcGxhdGl6ZXItYmVoYXZpb3IuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cImxpYi9lbGVtZW50cy9kb20tYmluZC5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwibGliL2VsZW1lbnRzL2RvbS1yZXBlYXQuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cImxpYi9lbGVtZW50cy9kb20taWYuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cImxpYi9lbGVtZW50cy9hcnJheS1zZWxlY3Rvci5odG1sXCI+XG48IS0tIGN1c3RvbS1zdHlsZSAtLT5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCJsaWIvZWxlbWVudHMvY3VzdG9tLXN0eWxlLmh0bWxcIj5cbjwhLS0gYmMgYmVoYXZpb3JzIC0tPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cImxpYi9sZWdhY3kvbXV0YWJsZS1kYXRhLWJlaGF2aW9yLmh0bWxcIj5cbjxzY3JpcHQ+XG4gIC8vIGJjXG4gIFBvbHltZXIuQmFzZSA9IFBvbHltZXIuTGVnYWN5RWxlbWVudE1peGluKEhUTUxFbGVtZW50KS5wcm90b3R5cGU7XG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9wb2x5bWVyLmh0bWwiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG48c2NyaXB0PlxuKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgY29uc3QgdXNlclBvbHltZXIgPSB3aW5kb3cuUG9seW1lcjtcblxuICAvKipcbiAgICogQG5hbWVzcGFjZSBQb2x5bWVyXG4gICAqIEBzdW1tYXJ5IFBvbHltZXIgaXMgYSBsaWdodHdlaWdodCBsaWJyYXJ5IGJ1aWx0IG9uIHRvcCBvZiB0aGUgd2ViXG4gICAqICAgc3RhbmRhcmRzLWJhc2VkIFdlYiBDb21wb25lbnRzIEFQSSdzLCBhbmQgbWFrZXMgaXQgZWFzeSB0byBidWlsZCB5b3VyXG4gICAqICAgb3duIGN1c3RvbSBIVE1MIGVsZW1lbnRzLlxuICAgKiBAcGFyYW0geyFQb2x5bWVySW5pdH0gaW5mbyBQcm90b3R5cGUgZm9yIHRoZSBjdXN0b20gZWxlbWVudC4gSXQgbXVzdCBjb250YWluXG4gICAqICAgYW4gYGlzYCBwcm9wZXJ0eSB0byBzcGVjaWZ5IHRoZSBlbGVtZW50IG5hbWUuIE90aGVyIHByb3BlcnRpZXMgcG9wdWxhdGVcbiAgICogICB0aGUgZWxlbWVudCBwcm90b3R5cGUuIFRoZSBgcHJvcGVydGllc2AsIGBvYnNlcnZlcnNgLCBgaG9zdEF0dHJpYnV0ZXNgLFxuICAgKiAgIGFuZCBgbGlzdGVuZXJzYCBwcm9wZXJ0aWVzIGFyZSBwcm9jZXNzZWQgdG8gY3JlYXRlIGVsZW1lbnQgZmVhdHVyZXMuXG4gICAqIEByZXR1cm4geyFPYmplY3R9IFJldHVybnMgYSBjdXN0b20gZWxlbWVudCBjbGFzcyBmb3IgdGhlIGdpdmVuIHByb3ZpZGVkXG4gICAqICAgcHJvdG90eXBlIGBpbmZvYCBvYmplY3QuIFRoZSBuYW1lIG9mIHRoZSBlbGVtZW50IGlmIGdpdmVuIGJ5IGBpbmZvLmlzYC5cbiAgICovXG4gIHdpbmRvdy5Qb2x5bWVyID0gZnVuY3Rpb24oaW5mbykge1xuICAgIHJldHVybiB3aW5kb3cuUG9seW1lci5fcG9seW1lckZuKGluZm8pO1xuICB9XG5cbiAgLy8gc3VwcG9ydCB1c2VyIHNldHRpbmdzIG9uIHRoZSBQb2x5bWVyIG9iamVjdFxuICBpZiAodXNlclBvbHltZXIpIHtcbiAgICBPYmplY3QuYXNzaWduKFBvbHltZXIsIHVzZXJQb2x5bWVyKTtcbiAgfVxuXG4gIC8vIFRvIGJlIHBsdWdnZWQgYnkgbGVnYWN5IGltcGxlbWVudGF0aW9uIGlmIGxvYWRlZFxuICAvKiBlc2xpbnQtZGlzYWJsZSB2YWxpZC1qc2RvYyAqL1xuICAvKipcbiAgICogQHBhcmFtIHshUG9seW1lckluaXR9IGluZm8gUHJvdG90eXBlIGZvciB0aGUgY3VzdG9tIGVsZW1lbnQuIEl0IG11c3QgY29udGFpblxuICAgKiAgIGFuIGBpc2AgcHJvcGVydHkgdG8gc3BlY2lmeSB0aGUgZWxlbWVudCBuYW1lLiBPdGhlciBwcm9wZXJ0aWVzIHBvcHVsYXRlXG4gICAqICAgdGhlIGVsZW1lbnQgcHJvdG90eXBlLiBUaGUgYHByb3BlcnRpZXNgLCBgb2JzZXJ2ZXJzYCwgYGhvc3RBdHRyaWJ1dGVzYCxcbiAgICogICBhbmQgYGxpc3RlbmVyc2AgcHJvcGVydGllcyBhcmUgcHJvY2Vzc2VkIHRvIGNyZWF0ZSBlbGVtZW50IGZlYXR1cmVzLlxuICAgKiBAcmV0dXJuIHshT2JqZWN0fSBSZXR1cm5zIGEgY3VzdG9tIGVsZW1lbnQgY2xhc3MgZm9yIHRoZSBnaXZlbiBwcm92aWRlZFxuICAgKiAgIHByb3RvdHlwZSBgaW5mb2Agb2JqZWN0LiBUaGUgbmFtZSBvZiB0aGUgZWxlbWVudCBpZiBnaXZlbiBieSBgaW5mby5pc2AuXG4gICAqL1xuICB3aW5kb3cuUG9seW1lci5fcG9seW1lckZuID0gZnVuY3Rpb24oaW5mbykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgdGhyb3cgbmV3IEVycm9yKCdMb2FkIHBvbHltZXIuaHRtbCB0byB1c2UgdGhlIFBvbHltZXIoKSBmdW5jdGlvbi4nKTtcbiAgfVxuICAvKiBlc2xpbnQtZW5hYmxlICovXG5cbiAgd2luZG93LlBvbHltZXIudmVyc2lvbiA9ICcyLjAuMSc7XG5cbiAgLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbiAgLypcbiAgV2hlbiB1c2luZyBDbG9zdXJlIENvbXBpbGVyLCBKU0NvbXBpbGVyX3JlbmFtZVByb3BlcnR5KHByb3BlcnR5LCBvYmplY3QpIGlzIHJlcGxhY2VkIGJ5IHRoZSBtdW5nZWQgbmFtZSBmb3Igb2JqZWN0W3Byb3BlcnR5XVxuICBXZSBjYW5ub3QgYWxpYXMgdGhpcyBmdW5jdGlvbiwgc28gd2UgaGF2ZSB0byB1c2UgYSBzbWFsbCBzaGltIHRoYXQgaGFzIHRoZSBzYW1lIGJlaGF2aW9yIHdoZW4gbm90IGNvbXBpbGluZy5cbiAgKi9cbiAgd2luZG93LkpTQ29tcGlsZXJfcmVuYW1lUHJvcGVydHkgPSBmdW5jdGlvbihwcm9wLCBvYmopIHtcbiAgICByZXR1cm4gcHJvcDtcbiAgfVxuICAvKiBlc2xpbnQtZW5hYmxlICovXG5cbn0pKCk7XG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvdXRpbHMvYm9vdC5odG1sIiwiLyogZXNsaW50LWVudiBicm93c2VyICovXG5cbmNsYXNzIFJlZ2lzdGVySHRtbFRlbXBsYXRlIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIGA8dGVtcGxhdGU+YCBlbGVtZW50IHRvIGhvbGQgYDxkb20tbW9kdWxlPmAgY29udGVudC5cbiAgICogVGhpcyBiaXQgb2YgY29kZSB3aWxsIGV4ZWN1dGUgaW4gdGhlIGNvbnRleHQgb2YgdGhlIG1haW4gZG9jdW1lbnQsXG4gICAqIGNhbGxpbmcgYGltcG9ydE5vZGVgIG9uIHRoZSBgPHRlbXBsYXRlPmAsIHdoaWNoIGluIHR1cm4gdHJpZ2dlcnNcbiAgICogdGhlIGxpZmVjeWNsZSBvZiB0aGUgYDxkb20tbW9kdWxlPmAgYW5kIGFsbG93cyBpdCB0byBpbnNlcnQgaXRzXG4gICAqIGNvbnRlbnQgaW50byBQb2x5bWVyJ3MgZ2xvYmFsIG1vZHVsZSBtYXAuIFdoZW4gYSBQb2x5bWVyIGVsZW1lbnRcbiAgICogYm9vdHMgdXAgaXQgd2lsbCBmZXRjaCBpdHMgdGVtcGxhdGUgZnJvbSB0aGlzIG1vZHVsZSBtYXAuXG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9Qb2x5bWVyL3BvbHltZXIvYmxvYi9tYXN0ZXIvbGliL21peGlucy9lbGVtZW50LW1peGluLmh0bWwjTDUwMS1MNTM4XG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWwgQSBgPGRvbS1tb2R1bGU+YCBhcyBhbiBIVE1MIHN0cmluZ1xuICAgKi9cbiAgc3RhdGljIHJlZ2lzdGVyKHZhbCkge1xuICAgIGxldCBjb250ZW50O1xuICAgIGNvbnN0IHRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKTtcbiAgICB0ZW1wbGF0ZS5pbm5lckhUTUwgPSB2YWw7XG4gICAgaWYgKHRlbXBsYXRlLmNvbnRlbnQpIHtcbiAgICAgIGNvbnRlbnQgPSB0ZW1wbGF0ZS5jb250ZW50OyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHByZWZlci1kZXN0cnVjdHVyaW5nXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRlbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgICB3aGlsZSAodGVtcGxhdGUuZmlyc3RDaGlsZCkge1xuICAgICAgICBjb250ZW50LmFwcGVuZENoaWxkKHRlbXBsYXRlLmZpcnN0Q2hpbGQpO1xuICAgICAgfVxuICAgIH1cbiAgICBkb2N1bWVudC5pbXBvcnROb2RlKGNvbnRlbnQsIHRydWUpO1xuICB9XG4gIC8qKlxuICAgKiBDb250ZW50IHRoYXQgd2lsbCBiZSBpbmplY3RlZCBpbnRvIHRoZSBtYWluIGRvY3VtZW50LiBUaGlzIGlzIHByaW1hcmlseVxuICAgKiBmb3IgdGhpbmdzIGxpa2UgYDxpcm9uLWljb25zZXQ+YCBhbmQgYDxjdXN0b20tc3R5bGU+YCB3aGljaCBkbyBub3QgaGF2ZVxuICAgKiB0ZW1wbGF0ZXMgYnV0IHJlbHkgb24gSFRNTCBJbXBvcnRzIGFiaWxpdHkgdG8gYXBwbHkgY29udGVudCB0byB0aGUgbWFpblxuICAgKiBkb2N1bWVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbCBBbiBIVE1MIHN0cmluZ1xuICAgKi9cbiAgc3RhdGljIHRvQm9keSh2YWwpIHtcbiAgICBjb25zdCB0cmltbWVkVmFsID0gdmFsLnRyaW0oKTtcbiAgICBpZiAodHJpbW1lZFZhbCkge1xuICAgICAgY29uc3QgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBkaXYuaW5uZXJIVE1MID0gdHJpbW1lZFZhbDtcbiAgICAgIGlmIChkaXYuZmlyc3RDaGlsZCkge1xuICAgICAgICBpZiAoZG9jdW1lbnQuYm9keSkge1xuICAgICAgICAgIGRvY3VtZW50LmJvZHkuaW5zZXJ0QmVmb3JlKGRpdi5maXJzdENoaWxkLCBkb2N1bWVudC5ib2R5LmZpcnN0Q2hpbGQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCAoKSA9PiB7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5Lmluc2VydEJlZm9yZShkaXYuZmlyc3RDaGlsZCwgZG9jdW1lbnQuYm9keS5maXJzdENoaWxkKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlZ2lzdGVySHRtbFRlbXBsYXRlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3BvbHltZXItd2VicGFjay1sb2FkZXIvcmVnaXN0ZXItaHRtbC10ZW1wbGF0ZS5qcyIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cblxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cImJvb3QuaHRtbFwiPlxuXG48c2NyaXB0PlxuXG4oZnVuY3Rpb24oKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIHVuaXF1ZSBnbG9iYWwgaWQgZm9yIGRlZHVwaW5nIG1peGlucy5cbiAgbGV0IGRlZHVwZUlkID0gMDtcblxuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBleHRlbmRzIHtGdW5jdGlvbn1cbiAgICovXG4gIGZ1bmN0aW9uIE1peGluRnVuY3Rpb24oKXt9XG4gIC8qKiBAdHlwZSB7KFdlYWtNYXAgfCB1bmRlZmluZWQpfSAqL1xuICBNaXhpbkZ1bmN0aW9uLnByb3RvdHlwZS5fX21peGluQXBwbGljYXRpb25zO1xuICAvKiogQHR5cGUgeyhPYmplY3QgfCB1bmRlZmluZWQpfSAqL1xuICBNaXhpbkZ1bmN0aW9uLnByb3RvdHlwZS5fX21peGluU2V0O1xuXG4gIC8qIGVzbGludC1kaXNhYmxlIHZhbGlkLWpzZG9jICovXG4gIC8qKlxuICAgKiBXcmFwcyBhbiBFUzYgY2xhc3MgZXhwcmVzc2lvbiBtaXhpbiBzdWNoIHRoYXQgdGhlIG1peGluIGlzIG9ubHkgYXBwbGllZFxuICAgKiBpZiBpdCBoYXMgbm90IGFscmVhZHkgYmVlbiBhcHBsaWVkIGl0cyBiYXNlIGFyZ3VtZW50LiAgQWxzbyBtZW1vaXplcyBtaXhpblxuICAgKiBhcHBsaWNhdGlvbnMuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBQb2x5bWVyXG4gICAqIEB0ZW1wbGF0ZSBUXG4gICAqIEBwYXJhbSB7VH0gbWl4aW4gRVM2IGNsYXNzIGV4cHJlc3Npb24gbWl4aW4gdG8gd3JhcFxuICAgKiBAc3VwcHJlc3Mge2ludmFsaWRDYXN0c31cbiAgICovXG4gIFBvbHltZXIuZGVkdXBpbmdNaXhpbiA9IGZ1bmN0aW9uKG1peGluKSB7XG4gICAgbGV0IG1peGluQXBwbGljYXRpb25zID0gLyoqIEB0eXBlIHshTWl4aW5GdW5jdGlvbn0gKi8obWl4aW4pLl9fbWl4aW5BcHBsaWNhdGlvbnM7XG4gICAgaWYgKCFtaXhpbkFwcGxpY2F0aW9ucykge1xuICAgICAgbWl4aW5BcHBsaWNhdGlvbnMgPSBuZXcgV2Vha01hcCgpO1xuICAgICAgLyoqIEB0eXBlIHshTWl4aW5GdW5jdGlvbn0gKi8obWl4aW4pLl9fbWl4aW5BcHBsaWNhdGlvbnMgPSBtaXhpbkFwcGxpY2F0aW9ucztcbiAgICB9XG4gICAgLy8gbWFpbnRhaW4gYSB1bmlxdWUgaWQgZm9yIGVhY2ggbWl4aW5cbiAgICBsZXQgbWl4aW5EZWR1cGVJZCA9IGRlZHVwZUlkKys7XG4gICAgZnVuY3Rpb24gZGVkdXBpbmdNaXhpbihiYXNlKSB7XG4gICAgICBsZXQgYmFzZVNldCA9IC8qKiBAdHlwZSB7IU1peGluRnVuY3Rpb259ICovKGJhc2UpLl9fbWl4aW5TZXQ7XG4gICAgICBpZiAoYmFzZVNldCAmJiBiYXNlU2V0W21peGluRGVkdXBlSWRdKSB7XG4gICAgICAgIHJldHVybiBiYXNlO1xuICAgICAgfVxuICAgICAgbGV0IG1hcCA9IG1peGluQXBwbGljYXRpb25zO1xuICAgICAgbGV0IGV4dGVuZGVkID0gbWFwLmdldChiYXNlKTtcbiAgICAgIGlmICghZXh0ZW5kZWQpIHtcbiAgICAgICAgZXh0ZW5kZWQgPSAvKiogQHR5cGUgeyFGdW5jdGlvbn0gKi8obWl4aW4pKGJhc2UpO1xuICAgICAgICBtYXAuc2V0KGJhc2UsIGV4dGVuZGVkKTtcbiAgICAgIH1cbiAgICAgIC8vIGNvcHkgaW5oZXJpdGVkIG1peGluIHNldCBmcm9tIHRoZSBleHRlbmRlZCBjbGFzcywgb3IgdGhlIGJhc2UgY2xhc3NcbiAgICAgIC8vIE5PVEU6IHdlIGF2b2lkIHVzZSBvZiBTZXQgaGVyZSBiZWNhdXNlIHNvbWUgYnJvd3NlciAoSUUxMSlcbiAgICAgIC8vIGNhbm5vdCBleHRlbmQgYSBiYXNlIFNldCB2aWEgdGhlIGNvbnN0cnVjdG9yLlxuICAgICAgbGV0IG1peGluU2V0ID0gT2JqZWN0LmNyZWF0ZSgvKiogQHR5cGUgeyFNaXhpbkZ1bmN0aW9ufSAqLyhleHRlbmRlZCkuX19taXhpblNldCB8fCBiYXNlU2V0IHx8IG51bGwpO1xuICAgICAgbWl4aW5TZXRbbWl4aW5EZWR1cGVJZF0gPSB0cnVlO1xuICAgICAgLyoqIEB0eXBlIHshTWl4aW5GdW5jdGlvbn0gKi8oZXh0ZW5kZWQpLl9fbWl4aW5TZXQgPSBtaXhpblNldDtcbiAgICAgIHJldHVybiBleHRlbmRlZDtcbiAgICB9XG5cbiAgICByZXR1cm4gZGVkdXBpbmdNaXhpbjtcbiAgfTtcbiAgLyogZXNsaW50LWVuYWJsZSB2YWxpZC1qc2RvYyAqL1xuXG59KSgpO1xuXG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvdXRpbHMvbWl4aW4uaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTYgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cblxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uLy4uL3BvbHltZXIvcG9seW1lci5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vLi4vaXJvbi1zY3JvbGwtdGFyZ2V0LWJlaGF2aW9yL2lyb24tc2Nyb2xsLXRhcmdldC1iZWhhdmlvci5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vaGVscGVycy9oZWxwZXJzLmh0bWxcIj5cblxuPHNjcmlwdD5cbiAgLyoqXG4gICAqIGBQb2x5bWVyLkFwcFNjcm9sbEVmZmVjdHNCZWhhdmlvcmAgcHJvdmlkZXMgYW4gaW50ZXJmYWNlIHRoYXQgYWxsb3dzIGFuIGVsZW1lbnQgdG8gdXNlIHNjcm9sbHMgZWZmZWN0cy5cbiAgICpcbiAgICogIyMjIEltcG9ydGluZyB0aGUgYXBwLWxheW91dCBlZmZlY3RzXG4gICAqXG4gICAqIGFwcC1sYXlvdXQgcHJvdmlkZXMgYSBzZXQgb2Ygc2Nyb2xsIGVmZmVjdHMgdGhhdCBjYW4gYmUgdXNlZCBieSBleHBsaWNpdGx5IGltcG9ydGluZ1xuICAgKiBgYXBwLXNjcm9sbC1lZmZlY3RzLmh0bWxgOlxuICAgKlxuICAgKiBgYGBodG1sXG4gICAqIDxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIvYm93ZXJfY29tcG9uZW50cy9hcHAtbGF5b3V0L2FwcC1zY3JvbGwtZWZmZWN0cy9hcHAtc2Nyb2xsLWVmZmVjdHMuaHRtbFwiPlxuICAgKiBgYGBcbiAgICpcbiAgICogVGhlIHNjcm9sbCBlZmZlY3RzIGNhbiBhbHNvIGJlIHVzZWQgYnkgaW5kaXZpZHVhbGx5IGltcG9ydGluZ1xuICAgKiBgYXBwLWxheW91dC9hcHAtc2Nyb2xsLWVmZmVjdHMvZWZmZWN0cy9bZWZmZWN0TmFtZV0uaHRtbGAuIEZvciBleGFtcGxlOlxuICAgKlxuICAgKiBgYGBodG1sXG4gICAqICA8bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiL2Jvd2VyX2NvbXBvbmVudHMvYXBwLWxheW91dC9hcHAtc2Nyb2xsLWVmZmVjdHMvZWZmZWN0cy93YXRlcmZhbGwuaHRtbFwiPlxuICAgKiBgYGBcbiAgICpcbiAgICogIyMjIENvbnN1bWluZyBlZmZlY3RzXG4gICAqXG4gICAqIEVmZmVjdHMgY2FuIGJlIGNvbnN1bWVkIHZpYSB0aGUgYGVmZmVjdHNgIHByb3BlcnR5LiBGb3IgZXhhbXBsZTpcbiAgICpcbiAgICogYGBgaHRtbFxuICAgKiA8YXBwLWhlYWRlciBlZmZlY3RzPVwid2F0ZXJmYWxsXCI+PC9hcHAtaGVhZGVyPlxuICAgKiBgYGBcbiAgICpcbiAgICogIyMjIENyZWF0aW5nIHNjcm9sbCBlZmZlY3RzXG4gICAqXG4gICAqIFlvdSBtYXkgd2FudCB0byBjcmVhdGUgYSBjdXN0b20gc2Nyb2xsIGVmZmVjdCBpZiB5b3UgbmVlZCB0byBtb2RpZnkgdGhlIENTUyBvZiBhbiBlbGVtZW50XG4gICAqIGJhc2VkIG9uIHRoZSBzY3JvbGwgcG9zaXRpb24uXG4gICAqXG4gICAqIEEgc2Nyb2xsIGVmZmVjdCBkZWZpbml0aW9uIGlzIGFuIG9iamVjdCB3aXRoIGBzZXRVcCgpYCwgYHRlYXJEb3duKClgIGFuZCBgcnVuKClgIGZ1bmN0aW9ucy5cbiAgICpcbiAgICogVG8gcmVnaXN0ZXIgdGhlIGVmZmVjdCwgeW91IGNhbiB1c2UgYFBvbHltZXIuQXBwTGF5b3V0LnJlZ2lzdGVyRWZmZWN0KGVmZmVjdE5hbWUsIGVmZmVjdERlZilgXG4gICAqIEZvciBleGFtcGxlLCBsZXQncyBkZWZpbmUgYW4gZWZmZWN0IHRoYXQgcmVzaXplcyB0aGUgaGVhZGVyJ3MgbG9nbzpcbiAgICpcbiAgICogYGBganNcbiAgICogUG9seW1lci5BcHBMYXlvdXQucmVnaXN0ZXJFZmZlY3QoJ3Jlc2l6YWJsZS1sb2dvJywge1xuICAgKiAgIHNldFVwOiBmdW5jdGlvbihjb25maWcpIHtcbiAgICogICAgIC8vIHRoZSBlZmZlY3QncyBjb25maWcgaXMgcGFzc2VkIHRvIHRoZSBzZXRVcC5cbiAgICogICAgIHRoaXMuX2Z4UmVzaXplTG9nbyA9IHsgbG9nbzogUG9seW1lci5kb20odGhpcykucXVlcnlTZWxlY3RvcignW2xvZ29dJykgfTtcbiAgICogICB9LFxuICAgKlxuICAgKiAgIHJ1bjogZnVuY3Rpb24ocHJvZ3Jlc3MpIHtcbiAgICogICAgICAvLyB0aGUgcHJvZ3Jlc3Mgb2YgdGhlIGVmZmVjdFxuICAgKiAgICAgIHRoaXMudHJhbnNmb3JtKCdzY2FsZTNkKCcgKyBwcm9ncmVzcyArICcsICcrIHByb2dyZXNzICsnLCAxKScsICB0aGlzLl9meFJlc2l6ZUxvZ28ubG9nbyk7XG4gICAqICAgfSxcbiAgICpcbiAgICogICB0ZWFyRG93bjogZnVuY3Rpb24oKSB7XG4gICAqICAgICAgLy8gY2xlYW4gdXAgYW5kIHJlc2V0IG9mIHN0YXRlc1xuICAgKiAgICAgIGRlbGV0ZSB0aGlzLl9meFJlc2l6ZUxvZ287XG4gICAqICAgfVxuICAgKiB9KTtcbiAgICogYGBgXG4gICAqIE5vdywgeW91IGNhbiBjb25zdW1lIHRoZSBlZmZlY3Q6XG4gICAqXG4gICAqIGBgYGh0bWxcbiAgICogPGFwcC1oZWFkZXIgaWQ9XCJhcHBIZWFkZXJcIiBlZmZlY3RzPVwicmVzaXphYmxlLWxvZ29cIj5cbiAgICogICA8aW1nIGxvZ28gc3JjPVwibG9nby5zdmdcIj5cbiAgICogPC9hcHAtaGVhZGVyPlxuICAgKiBgYGBcbiAgICpcbiAgICogIyMjIEltcGVyYXRpdmUgQVBJXG4gICAqXG4gICAqIGBgYGpzXG4gICAqIHZhciBsb2dvRWZmZWN0ID0gYXBwSGVhZGVyLmNyZWF0ZUVmZmVjdCgncmVzaXphYmxlLWxvZ28nLCBlZmZlY3RDb25maWcpO1xuICAgKiAvLyBydW4gdGhlIGVmZmVjdDogbG9nb0VmZmVjdC5ydW4ocHJvZ3Jlc3MpO1xuICAgKiAvLyB0ZWFyIGRvd24gdGhlIGVmZmVjdDogbG9nb0VmZmVjdC50ZWFyRG93bigpO1xuICAgKiBgYGBcbiAgICpcbiAgICogIyMjIENvbmZpZ3VyaW5nIGVmZmVjdHNcbiAgICpcbiAgICogRm9yIGVmZmVjdHMgaW5zdGFsbGVkIHZpYSB0aGUgYGVmZmVjdHNgIHByb3BlcnR5LCB0aGVpciBjb25maWd1cmF0aW9uIGNhbiBiZSBzZXRcbiAgICogdmlhIHRoZSBgZWZmZWN0c0NvbmZpZ2AgcHJvcGVydHkuIEZvciBleGFtcGxlOlxuICAgKlxuICAgKiBgYGBodG1sXG4gICAqIDxhcHAtaGVhZGVyIGVmZmVjdHM9XCJ3YXRlcmZhbGxcIlxuICAgKiAgIGVmZmVjdHMtY29uZmlnPSd7XCJ3YXRlcmZhbGxcIjoge1wic3RhcnRzQXRcIjogMCwgXCJlbmRzQXRcIjogMC41fX0nPlxuICAgKiA8L2FwcC1oZWFkZXI+XG4gICAqIGBgYFxuICAgKlxuICAgKiBBbGwgZWZmZWN0cyBoYXZlIGEgYHN0YXJ0c0F0YCBhbmQgYGVuZHNBdGAgY29uZmlnIHByb3BlcnR5LiBUaGV5IHNwZWNpZnkgYXQgd2hhdFxuICAgKiBwb2ludCB0aGUgZWZmZWN0IHNob3VsZCBzdGFydCBhbmQgZW5kLiBUaGlzIHZhbHVlIGdvZXMgZnJvbSAwIHRvIDEgaW5jbHVzaXZlLlxuICAgKlxuICAgKiBAcG9seW1lckJlaGF2aW9yXG4gICAqL1xuICBQb2x5bWVyLkFwcFNjcm9sbEVmZmVjdHNCZWhhdmlvciA9IFtcbiAgICBQb2x5bWVyLklyb25TY3JvbGxUYXJnZXRCZWhhdmlvcixcbiAgIHtcblxuICAgIHByb3BlcnRpZXM6IHtcblxuICAgICAgLyoqXG4gICAgICAgKiBBIHNwYWNlLXNlcGFyYXRlZCBsaXN0IG9mIHRoZSBlZmZlY3RzIG5hbWVzIHRoYXQgd2lsbCBiZSB0cmlnZ2VyZWQgd2hlbiB0aGUgdXNlciBzY3JvbGxzLlxuICAgICAgICogZS5nLiBgd2F0ZXJmYWxsIHBhcmFsbGF4LWJhY2tncm91bmRgIGluc3RhbGxzIHRoZSBgd2F0ZXJmYWxsYCBhbmQgYHBhcmFsbGF4LWJhY2tncm91bmRgLlxuICAgICAgICovXG4gICAgICBlZmZlY3RzOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZ1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBBbiBvYmplY3QgdGhhdCBjb25maWd1cmF0ZXMgdGhlIGVmZmVjdHMgaW5zdGFsbGVkIHZpYSB0aGUgYGVmZmVjdHNgIHByb3BlcnR5LiBlLmcuXG4gICAgICAgKiBgYGBqc1xuICAgICAgICogIGVsZW1lbnQuZWZmZWN0c0NvbmZpZyA9IHtcbiAgICAgICAqICAgXCJibGVuZC1iYWNrZ3JvdW5kXCI6IHtcbiAgICAgICAqICAgICBcInN0YXJ0c0F0XCI6IDAuNVxuICAgICAgICogICB9XG4gICAgICAgKiB9O1xuICAgICAgICogYGBgXG4gICAgICAgKiBFdmVyeSBlZmZlY3QgaGFzIGF0IGxlYXN0IHR3byBjb25maWcgcHJvcGVydGllczogYHN0YXJ0c0F0YCBhbmQgYGVuZHNBdGAuXG4gICAgICAgKiBUaGVzZSBwcm9wZXJ0aWVzIGluZGljYXRlIHdoZW4gdGhlIGV2ZW50IHNob3VsZCBzdGFydCBhbmQgZW5kIHJlc3BlY3RpdmVseVxuICAgICAgICogYW5kIHJlbGF0aXZlIHRvIHRoZSBvdmVyYWxsIGVsZW1lbnQgcHJvZ3Jlc3MuIFNvIGZvciBleGFtcGxlLCBpZiBgYmxlbmQtYmFja2dyb3VuZGBcbiAgICAgICAqIHN0YXJ0cyBhdCBgMC41YCwgdGhlIGVmZmVjdCB3aWxsIG9ubHkgc3RhcnQgb25jZSB0aGUgY3VycmVudCBlbGVtZW50IHJlYWNoZXMgMC41XG4gICAgICAgKiBvZiBpdHMgcHJvZ3Jlc3MuIEluIHRoaXMgY29udGV4dCwgdGhlIHByb2dyZXNzIGlzIGEgdmFsdWUgaW4gdGhlIHJhbmdlIG9mIGBbMCwgMV1gXG4gICAgICAgKiB0aGF0IGluZGljYXRlcyB3aGVyZSB0aGlzIGVsZW1lbnQgaXMgb24gdGhlIHNjcmVlbiByZWxhdGl2ZSB0byB0aGUgdmlld3BvcnQuXG4gICAgICAgKi9cbiAgICAgIGVmZmVjdHNDb25maWc6IHtcbiAgICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIERpc2FibGVzIENTUyB0cmFuc2l0aW9ucyBhbmQgc2Nyb2xsIGVmZmVjdHMgb24gdGhlIGVsZW1lbnQuXG4gICAgICAgKi9cbiAgICAgIGRpc2FibGVkOiB7XG4gICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgIHJlZmxlY3RUb0F0dHJpYnV0ZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIEFsbG93cyB0byBzZXQgYSBgc2Nyb2xsVG9wYCB0aHJlc2hvbGQuIFdoZW4gZ3JlYXRlciB0aGFuIDAsIGB0aHJlc2hvbGRUcmlnZ2VyZWRgXG4gICAgICAgKiBpcyB0cnVlIG9ubHkgd2hlbiB0aGUgc2Nyb2xsIHRhcmdldCdzIGBzY3JvbGxUb3BgIGhhcyByZWFjaGVkIHRoaXMgdmFsdWUuXG4gICAgICAgKlxuICAgICAgICogRm9yIGV4YW1wbGUsIGlmIGB0aHJlc2hvbGQgPSAxMDBgLCBgdGhyZXNob2xkVHJpZ2dlcmVkYCBpcyB0cnVlIHdoZW4gdGhlIGBzY3JvbGxUb3BgXG4gICAgICAgKiBpcyBhdCBsZWFzdCBgMTAwYC5cbiAgICAgICAqL1xuICAgICAgdGhyZXNob2xkOiB7XG4gICAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgICAgdmFsdWU6IDBcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogVHJ1ZSBpZiB0aGUgYHNjcm9sbFRvcGAgdGhyZXNob2xkIChzZXQgaW4gYHNjcm9sbFRvcFRocmVzaG9sZGApIGhhc1xuICAgICAgICogYmVlbiByZWFjaGVkLlxuICAgICAgICovXG4gICAgICB0aHJlc2hvbGRUcmlnZ2VyZWQ6IHtcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgbm90aWZ5OiB0cnVlLFxuICAgICAgICByZWFkT25seTogdHJ1ZSxcbiAgICAgICAgcmVmbGVjdFRvQXR0cmlidXRlOiB0cnVlXG4gICAgICB9XG4gICAgfSxcblxuICAgIG9ic2VydmVyczogW1xuICAgICAgJ19lZmZlY3RzQ2hhbmdlZChlZmZlY3RzLCBlZmZlY3RzQ29uZmlnLCBpc0F0dGFjaGVkKSdcbiAgICBdLFxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgc2Nyb2xsIHN0YXRlLiBUaGlzIG1ldGhvZCBzaG91bGQgYmUgb3ZlcnJpZGRlblxuICAgICAqIGJ5IHRoZSBjb25zdW1lciBvZiB0aGlzIGJlaGF2aW9yLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBfdXBkYXRlU2Nyb2xsU3RhdGVcbiAgICAgKi9cbiAgICBfdXBkYXRlU2Nyb2xsU3RhdGU6IGZ1bmN0aW9uKCkge30sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGN1cnJlbnQgZWxlbWVudCBpcyBvbiB0aGUgc2NyZWVuLlxuICAgICAqIFRoYXQgaXMsIHZpc2libGUgaW4gdGhlIGN1cnJlbnQgdmlld3BvcnQuIFRoaXMgbWV0aG9kIHNob3VsZCBiZVxuICAgICAqIG92ZXJyaWRkZW4gYnkgdGhlIGNvbnN1bWVyIG9mIHRoaXMgYmVoYXZpb3IuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGlzT25TY3JlZW5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuICAgIGlzT25TY3JlZW46IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlcmUncyBjb250ZW50IGJlbG93IHRoZSBjdXJyZW50IGVsZW1lbnQuIFRoaXMgbWV0aG9kXG4gICAgICogc2hvdWxkIGJlIG92ZXJyaWRkZW4gYnkgdGhlIGNvbnN1bWVyIG9mIHRoaXMgYmVoYXZpb3IuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGlzQ29udGVudEJlbG93XG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc0NvbnRlbnRCZWxvdzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIExpc3Qgb2YgZWZmZWN0cyBoYW5kbGVycyB0aGF0IHdpbGwgdGFrZSBwbGFjZSBkdXJpbmcgc2Nyb2xsLlxuICAgICAqXG4gICAgICogQHR5cGUge0FycmF5PEZ1bmN0aW9uPn1cbiAgICAgKi9cbiAgICBfZWZmZWN0c1J1bkZuOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogTGlzdCBvZiB0aGUgZWZmZWN0cyBkZWZpbml0aW9ucyBpbnN0YWxsZWQgdmlhIHRoZSBgZWZmZWN0c2AgcHJvcGVydHkuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7QXJyYXk8T2JqZWN0Pn1cbiAgICAgKi9cbiAgICBfZWZmZWN0czogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIFRoZSBjbGFtcGVkIHZhbHVlIG9mIGBfc2Nyb2xsVG9wYC5cbiAgICAgKiBAdHlwZSBudW1iZXJcbiAgICAgKi9cbiAgICBnZXQgX2NsYW1wZWRTY3JvbGxUb3AoKSB7XG4gICAgICByZXR1cm4gTWF0aC5tYXgoMCwgdGhpcy5fc2Nyb2xsVG9wKTtcbiAgICB9LFxuXG4gICAgZGV0YWNoZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fdGVhckRvd25FZmZlY3RzKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gZWZmZWN0IG9iamVjdCBmcm9tIGFuIGVmZmVjdCdzIG5hbWUgdGhhdCBjYW4gYmUgdXNlZCB0byBydW5cbiAgICAgKiBlZmZlY3RzIHByb2dyYW1tYXRpY2FsbHkuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGNyZWF0ZUVmZmVjdFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBlZmZlY3ROYW1lIFRoZSBlZmZlY3QncyBuYW1lIHJlZ2lzdGVyZWQgdmlhIGBQb2x5bWVyLkFwcExheW91dC5yZWdpc3RlckVmZmVjdGAuXG4gICAgICogQHBhcmFtIHtPYmplY3Q9fSBlZmZlY3RDb25maWcgVGhlIGVmZmVjdCBjb25maWcgb2JqZWN0LiAoT3B0aW9uYWwpXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBBbiBlZmZlY3Qgb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBmdW5jdGlvbnM6XG4gICAgICpcbiAgICAgKiAgKiBgZWZmZWN0LnNldFVwKClgLCBTZXRzIHVwIHRoZSByZXF1aXJlbWVudHMgZm9yIHRoZSBlZmZlY3QuXG4gICAgICogICAgICAgVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgYXV0b21hdGljYWxseSBiZWZvcmUgdGhlIGBlZmZlY3RgIGZ1bmN0aW9uIHJldHVybnMuXG4gICAgICogICogYGVmZmVjdC5ydW4ocHJvZ3Jlc3MsIHkpYCwgUnVucyB0aGUgZWZmZWN0IGdpdmVuIGEgYHByb2dyZXNzYC5cbiAgICAgKiAgKiBgZWZmZWN0LnRlYXJEb3duKClgLCBDbGVhbnMgdXAgYW55IERPTSBub2RlcyBvciBlbGVtZW50IHJlZmVyZW5jZXMgdXNlZCBieSB0aGUgZWZmZWN0LlxuICAgICAqXG4gICAgICogRXhhbXBsZTpcbiAgICAgKiBgYGBqc1xuICAgICAqIHZhciBwYXJhbGxheCA9IGVsZW1lbnQuY3JlYXRlRWZmZWN0KCdwYXJhbGxheC1iYWNrZ3JvdW5kJyk7XG4gICAgICogLy8gcnVucyB0aGUgZWZmZWN0XG4gICAgICogcGFyYWxsYXgucnVuKDAuNSwgMCk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgY3JlYXRlRWZmZWN0OiBmdW5jdGlvbihlZmZlY3ROYW1lLCBlZmZlY3RDb25maWcpIHtcbiAgICAgIHZhciBlZmZlY3REZWYgPSBQb2x5bWVyLkFwcExheW91dC5fc2Nyb2xsRWZmZWN0c1tlZmZlY3ROYW1lXTtcbiAgICAgIGlmICghZWZmZWN0RGVmKSB7XG4gICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcih0aGlzLl9nZXRVbmRlZmluZWRNc2coZWZmZWN0TmFtZSkpO1xuICAgICAgfVxuICAgICAgdmFyIHByb3AgPSB0aGlzLl9ib3VuZEVmZmVjdChlZmZlY3REZWYsIGVmZmVjdENvbmZpZyB8fCB7fSk7XG4gICAgICBwcm9wLnNldFVwKCk7XG4gICAgICByZXR1cm4gcHJvcDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gYGVmZmVjdHNgIG9yIGBlZmZlY3RzQ29uZmlnYCBjaGFuZ2VzLlxuICAgICAqL1xuICAgIF9lZmZlY3RzQ2hhbmdlZDogZnVuY3Rpb24oZWZmZWN0cywgZWZmZWN0c0NvbmZpZywgaXNBdHRhY2hlZCkge1xuICAgICAgdGhpcy5fdGVhckRvd25FZmZlY3RzKCk7XG5cbiAgICAgIGlmICghZWZmZWN0cyB8fCAhaXNBdHRhY2hlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBlZmZlY3RzLnNwbGl0KCcgJykuZm9yRWFjaChmdW5jdGlvbihlZmZlY3ROYW1lKSB7XG4gICAgICAgIHZhciBlZmZlY3REZWY7XG4gICAgICAgIGlmIChlZmZlY3ROYW1lICE9PSAnJykge1xuICAgICAgICAgIGlmICgoZWZmZWN0RGVmID0gUG9seW1lci5BcHBMYXlvdXQuX3Njcm9sbEVmZmVjdHNbZWZmZWN0TmFtZV0pKSB7XG4gICAgICAgICAgICB0aGlzLl9lZmZlY3RzLnB1c2godGhpcy5fYm91bmRFZmZlY3QoZWZmZWN0RGVmLCBlZmZlY3RzQ29uZmlnW2VmZmVjdE5hbWVdKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2Fybih0aGlzLl9nZXRVbmRlZmluZWRNc2coZWZmZWN0TmFtZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgdGhpcyk7XG5cbiAgICAgIHRoaXMuX3NldFVwRWZmZWN0KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZvcmNlcyBsYXlvdXRcbiAgICAgKi9cbiAgICBfbGF5b3V0SWZEaXJ0eTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5vZmZzZXRXaWR0aDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBlZmZlY3Qgb2JqZWN0IGJvdW5kIHRvIHRoZSBjdXJyZW50IGNvbnRleHQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZWZmZWN0RGVmXG4gICAgICogQHBhcmFtIHtPYmplY3Q9fSBlZmZlY3RzQ29uZmlnIFRoZSBlZmZlY3QgY29uZmlnIG9iamVjdCBpZiB0aGUgZWZmZWN0IGFjY2VwdHMgY29uZmlnIHZhbHVlcy4gKE9wdGlvbmFsKVxuICAgICAqL1xuICAgIF9ib3VuZEVmZmVjdDogZnVuY3Rpb24oZWZmZWN0RGVmLCBlZmZlY3RzQ29uZmlnKSB7XG4gICAgICBlZmZlY3RzQ29uZmlnID0gZWZmZWN0c0NvbmZpZyB8fCB7fTtcbiAgICAgIHZhciBzdGFydHNBdCA9IHBhcnNlRmxvYXQoZWZmZWN0c0NvbmZpZy5zdGFydHNBdCB8fCAwKTtcbiAgICAgIHZhciBlbmRzQXQgPSBwYXJzZUZsb2F0KGVmZmVjdHNDb25maWcuZW5kc0F0IHx8IDEpO1xuICAgICAgdmFyIGRlbHRhUyA9IGVuZHNBdCAtIHN0YXJ0c0F0O1xuICAgICAgdmFyIG5vb3AgPSBmdW5jdGlvbigpIHt9O1xuICAgICAgLy8gZmFzdCBwYXRoIGlmIHBvc3NpYmxlXG4gICAgICB2YXIgcnVuRm4gPSAoc3RhcnRzQXQgPT09IDAgJiYgZW5kc0F0ID09PSAxKSA/IGVmZmVjdERlZi5ydW4gOlxuICAgICAgICBmdW5jdGlvbihwcm9ncmVzcywgeSkge1xuICAgICAgICAgIGVmZmVjdERlZi5ydW4uY2FsbCh0aGlzLFxuICAgICAgICAgICAgICBNYXRoLm1heCgwLCAocHJvZ3Jlc3MgLSBzdGFydHNBdCkgLyBkZWx0YVMpLCB5KTtcbiAgICAgICAgfTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNldFVwOiBlZmZlY3REZWYuc2V0VXAgPyBlZmZlY3REZWYuc2V0VXAuYmluZCh0aGlzLCBlZmZlY3RzQ29uZmlnKSA6IG5vb3AsXG4gICAgICAgIHJ1bjogZWZmZWN0RGVmLnJ1biA/IHJ1bkZuLmJpbmQodGhpcykgOiBub29wLFxuICAgICAgICB0ZWFyRG93bjogZWZmZWN0RGVmLnRlYXJEb3duID8gZWZmZWN0RGVmLnRlYXJEb3duLmJpbmQodGhpcykgOiBub29wXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHVwIHRoZSBlZmZlY3RzLlxuICAgICAqL1xuICAgIF9zZXRVcEVmZmVjdDogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5pc0F0dGFjaGVkICYmIHRoaXMuX2VmZmVjdHMpIHtcbiAgICAgICAgdGhpcy5fZWZmZWN0c1J1bkZuID0gW107XG4gICAgICAgIHRoaXMuX2VmZmVjdHMuZm9yRWFjaChmdW5jdGlvbihlZmZlY3REZWYpIHtcbiAgICAgICAgICAvLyBpbnN0YWxsIHRoZSBlZmZlY3Qgb25seSBpZiBubyBlcnJvciB3YXMgcmVwb3J0ZWRcbiAgICAgICAgICBpZiAoZWZmZWN0RGVmLnNldFVwKCkgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0aGlzLl9lZmZlY3RzUnVuRm4ucHVzaChlZmZlY3REZWYucnVuKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUZWFycyBkb3duIHRoZSBlZmZlY3RzLlxuICAgICAqL1xuICAgIF90ZWFyRG93bkVmZmVjdHM6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuX2VmZmVjdHMpIHtcbiAgICAgICAgdGhpcy5fZWZmZWN0cy5mb3JFYWNoKGZ1bmN0aW9uKGVmZmVjdERlZikge1xuICAgICAgICAgIGVmZmVjdERlZi50ZWFyRG93bigpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2VmZmVjdHNSdW5GbiA9IFtdO1xuICAgICAgdGhpcy5fZWZmZWN0cyA9IFtdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSdW5zIHRoZSBlZmZlY3RzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHAgVGhlIHByb2dyZXNzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgVGhlIHRvcCBwb3NpdGlvbiBvZiB0aGUgY3VycmVudCBlbGVtZW50IHJlbGF0aXZlIHRvIHRoZSB2aWV3cG9ydC5cbiAgICAgKi9cbiAgICBfcnVuRWZmZWN0czogZnVuY3Rpb24ocCwgeSkge1xuICAgICAgaWYgKHRoaXMuX2VmZmVjdHNSdW5Gbikge1xuICAgICAgICB0aGlzLl9lZmZlY3RzUnVuRm4uZm9yRWFjaChmdW5jdGlvbihydW4pIHtcbiAgICAgICAgICBydW4ocCwgeSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZXMgdGhlIGBfc2Nyb2xsSGFuZGxlcmAuXG4gICAgICovXG4gICAgX3Njcm9sbEhhbmRsZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLmRpc2FibGVkKSB7XG4gICAgICAgIHZhciBzY3JvbGxUb3AgPSB0aGlzLl9jbGFtcGVkU2Nyb2xsVG9wO1xuICAgICAgICB0aGlzLl91cGRhdGVTY3JvbGxTdGF0ZShzY3JvbGxUb3ApO1xuICAgICAgICBpZiAodGhpcy50aHJlc2hvbGQgPiAwKSB7XG4gICAgICAgICAgdGhpcy5fc2V0VGhyZXNob2xkVHJpZ2dlcmVkKHNjcm9sbFRvcCA+PSB0aGlzLnRocmVzaG9sZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gcmV0dXJuIGEgcmVmZXJlbmNlIHRvIGEgbm9kZSBpbiB0aGUgbG9jYWwgRE9NLlxuICAgICAqIFRoZSBub2RlIGlzIGNvbnN1bWVkIGJ5IGEgc2Nyb2xsIGVmZmVjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBUaGUgaWQgZm9yIHRoZSBub2RlLlxuICAgICAqL1xuICAgIF9nZXRET01SZWY6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ19nZXRET01SZWYnLCAnYCcrIGlkICsnYCBpcyB1bmRlZmluZWQnKTtcbiAgICB9LFxuXG4gICAgX2dldFVuZGVmaW5lZE1zZzogZnVuY3Rpb24oZWZmZWN0TmFtZSkge1xuICAgICAgcmV0dXJuICdTY3JvbGwgZWZmZWN0IGAnICsgZWZmZWN0TmFtZSArICdgIGlzIHVuZGVmaW5lZC4gJyArXG4gICAgICAgICAgJ0RpZCB5b3UgZm9yZ2V0IHRvIGltcG9ydCBhcHAtbGF5b3V0L2FwcC1zY3JvbGwtZWZmZWN0cy9lZmZlY3RzLycgKyBlZmZlY3ROYW1lICsgJy5odG1sID8nO1xuICAgIH1cblxuICB9XTtcblxuPC9zY3JpcHQ+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL2FwcC1sYXlvdXQvYXBwLXNjcm9sbC1lZmZlY3RzL2FwcC1zY3JvbGwtZWZmZWN0cy1iZWhhdmlvci5odG1sIiwiXG5yZXF1aXJlKCcuLi9wb2x5bWVyL3BvbHltZXIuaHRtbCcpO1xuXG5jb25zdCBSZWdpc3Rlckh0bWxUZW1wbGF0ZSA9IHJlcXVpcmUoJ3BvbHltZXItd2VicGFjay1sb2FkZXIvcmVnaXN0ZXItaHRtbC10ZW1wbGF0ZScpO1xuXG5SZWdpc3Rlckh0bWxUZW1wbGF0ZS50b0JvZHkoXCI8Y3VzdG9tLXN0eWxlPiA8c3R5bGUgaXM9Y3VzdG9tLXN0eWxlPmh0bWx7LS1sYXlvdXQ6e2Rpc3BsYXk6LW1zLWZsZXhib3g7ZGlzcGxheTotd2Via2l0LWZsZXg7ZGlzcGxheTpmbGV4fTstLWxheW91dC1pbmxpbmU6e2Rpc3BsYXk6LW1zLWlubGluZS1mbGV4Ym94O2Rpc3BsYXk6LXdlYmtpdC1pbmxpbmUtZmxleDtkaXNwbGF5OmlubGluZS1mbGV4fTstLWxheW91dC1ob3Jpem9udGFsOntAYXBwbHkgLS1sYXlvdXQ7LW1zLWZsZXgtZGlyZWN0aW9uOnJvdzstd2Via2l0LWZsZXgtZGlyZWN0aW9uOnJvdztmbGV4LWRpcmVjdGlvbjpyb3d9Oy0tbGF5b3V0LWhvcml6b250YWwtcmV2ZXJzZTp7QGFwcGx5IC0tbGF5b3V0Oy1tcy1mbGV4LWRpcmVjdGlvbjpyb3ctcmV2ZXJzZTstd2Via2l0LWZsZXgtZGlyZWN0aW9uOnJvdy1yZXZlcnNlO2ZsZXgtZGlyZWN0aW9uOnJvdy1yZXZlcnNlfTstLWxheW91dC12ZXJ0aWNhbDp7QGFwcGx5IC0tbGF5b3V0Oy1tcy1mbGV4LWRpcmVjdGlvbjpjb2x1bW47LXdlYmtpdC1mbGV4LWRpcmVjdGlvbjpjb2x1bW47ZmxleC1kaXJlY3Rpb246Y29sdW1ufTstLWxheW91dC12ZXJ0aWNhbC1yZXZlcnNlOntAYXBwbHkgLS1sYXlvdXQ7LW1zLWZsZXgtZGlyZWN0aW9uOmNvbHVtbi1yZXZlcnNlOy13ZWJraXQtZmxleC1kaXJlY3Rpb246Y29sdW1uLXJldmVyc2U7ZmxleC1kaXJlY3Rpb246Y29sdW1uLXJldmVyc2V9Oy0tbGF5b3V0LXdyYXA6ey1tcy1mbGV4LXdyYXA6d3JhcDstd2Via2l0LWZsZXgtd3JhcDp3cmFwO2ZsZXgtd3JhcDp3cmFwfTstLWxheW91dC13cmFwLXJldmVyc2U6ey1tcy1mbGV4LXdyYXA6d3JhcC1yZXZlcnNlOy13ZWJraXQtZmxleC13cmFwOndyYXAtcmV2ZXJzZTtmbGV4LXdyYXA6d3JhcC1yZXZlcnNlfTstLWxheW91dC1mbGV4LWF1dG86ey1tcy1mbGV4OjEgMSBhdXRvOy13ZWJraXQtZmxleDoxIDEgYXV0bztmbGV4OjEgMSBhdXRvfTstLWxheW91dC1mbGV4LW5vbmU6ey1tcy1mbGV4Om5vbmU7LXdlYmtpdC1mbGV4Om5vbmU7ZmxleDpub25lfTstLWxheW91dC1mbGV4OnstbXMtZmxleDoxIDEgLjAwMDAwMDAwMXB4Oy13ZWJraXQtZmxleDoxO2ZsZXg6MTstd2Via2l0LWZsZXgtYmFzaXM6LjAwMDAwMDAwMXB4O2ZsZXgtYmFzaXM6LjAwMDAwMDAwMXB4fTstLWxheW91dC1mbGV4LTI6ey1tcy1mbGV4OjI7LXdlYmtpdC1mbGV4OjI7ZmxleDoyfTstLWxheW91dC1mbGV4LTM6ey1tcy1mbGV4OjM7LXdlYmtpdC1mbGV4OjM7ZmxleDozfTstLWxheW91dC1mbGV4LTQ6ey1tcy1mbGV4OjQ7LXdlYmtpdC1mbGV4OjQ7ZmxleDo0fTstLWxheW91dC1mbGV4LTU6ey1tcy1mbGV4OjU7LXdlYmtpdC1mbGV4OjU7ZmxleDo1fTstLWxheW91dC1mbGV4LTY6ey1tcy1mbGV4OjY7LXdlYmtpdC1mbGV4OjY7ZmxleDo2fTstLWxheW91dC1mbGV4LTc6ey1tcy1mbGV4Ojc7LXdlYmtpdC1mbGV4Ojc7ZmxleDo3fTstLWxheW91dC1mbGV4LTg6ey1tcy1mbGV4Ojg7LXdlYmtpdC1mbGV4Ojg7ZmxleDo4fTstLWxheW91dC1mbGV4LTk6ey1tcy1mbGV4Ojk7LXdlYmtpdC1mbGV4Ojk7ZmxleDo5fTstLWxheW91dC1mbGV4LTEwOnstbXMtZmxleDoxMDstd2Via2l0LWZsZXg6MTA7ZmxleDoxMH07LS1sYXlvdXQtZmxleC0xMTp7LW1zLWZsZXg6MTE7LXdlYmtpdC1mbGV4OjExO2ZsZXg6MTF9Oy0tbGF5b3V0LWZsZXgtMTI6ey1tcy1mbGV4OjEyOy13ZWJraXQtZmxleDoxMjtmbGV4OjEyfTstLWxheW91dC1zdGFydDp7LW1zLWZsZXgtYWxpZ246c3RhcnQ7LXdlYmtpdC1hbGlnbi1pdGVtczpmbGV4LXN0YXJ0O2FsaWduLWl0ZW1zOmZsZXgtc3RhcnR9Oy0tbGF5b3V0LWNlbnRlcjp7LW1zLWZsZXgtYWxpZ246Y2VudGVyOy13ZWJraXQtYWxpZ24taXRlbXM6Y2VudGVyO2FsaWduLWl0ZW1zOmNlbnRlcn07LS1sYXlvdXQtZW5kOnstbXMtZmxleC1hbGlnbjplbmQ7LXdlYmtpdC1hbGlnbi1pdGVtczpmbGV4LWVuZDthbGlnbi1pdGVtczpmbGV4LWVuZH07LS1sYXlvdXQtYmFzZWxpbmU6ey1tcy1mbGV4LWFsaWduOmJhc2VsaW5lOy13ZWJraXQtYWxpZ24taXRlbXM6YmFzZWxpbmU7YWxpZ24taXRlbXM6YmFzZWxpbmV9Oy0tbGF5b3V0LXN0YXJ0LWp1c3RpZmllZDp7LW1zLWZsZXgtcGFjazpzdGFydDstd2Via2l0LWp1c3RpZnktY29udGVudDpmbGV4LXN0YXJ0O2p1c3RpZnktY29udGVudDpmbGV4LXN0YXJ0fTstLWxheW91dC1jZW50ZXItanVzdGlmaWVkOnstbXMtZmxleC1wYWNrOmNlbnRlcjstd2Via2l0LWp1c3RpZnktY29udGVudDpjZW50ZXI7anVzdGlmeS1jb250ZW50OmNlbnRlcn07LS1sYXlvdXQtZW5kLWp1c3RpZmllZDp7LW1zLWZsZXgtcGFjazplbmQ7LXdlYmtpdC1qdXN0aWZ5LWNvbnRlbnQ6ZmxleC1lbmQ7anVzdGlmeS1jb250ZW50OmZsZXgtZW5kfTstLWxheW91dC1hcm91bmQtanVzdGlmaWVkOnstbXMtZmxleC1wYWNrOmRpc3RyaWJ1dGU7LXdlYmtpdC1qdXN0aWZ5LWNvbnRlbnQ6c3BhY2UtYXJvdW5kO2p1c3RpZnktY29udGVudDpzcGFjZS1hcm91bmR9Oy0tbGF5b3V0LWp1c3RpZmllZDp7LW1zLWZsZXgtcGFjazpqdXN0aWZ5Oy13ZWJraXQtanVzdGlmeS1jb250ZW50OnNwYWNlLWJldHdlZW47anVzdGlmeS1jb250ZW50OnNwYWNlLWJldHdlZW59Oy0tbGF5b3V0LWNlbnRlci1jZW50ZXI6e0BhcHBseSAtLWxheW91dC1jZW50ZXI7QGFwcGx5IC0tbGF5b3V0LWNlbnRlci1qdXN0aWZpZWQ7fTstLWxheW91dC1zZWxmLXN0YXJ0OnstbXMtYWxpZ24tc2VsZjpmbGV4LXN0YXJ0Oy13ZWJraXQtYWxpZ24tc2VsZjpmbGV4LXN0YXJ0O2FsaWduLXNlbGY6ZmxleC1zdGFydH07LS1sYXlvdXQtc2VsZi1jZW50ZXI6ey1tcy1hbGlnbi1zZWxmOmNlbnRlcjstd2Via2l0LWFsaWduLXNlbGY6Y2VudGVyO2FsaWduLXNlbGY6Y2VudGVyfTstLWxheW91dC1zZWxmLWVuZDp7LW1zLWFsaWduLXNlbGY6ZmxleC1lbmQ7LXdlYmtpdC1hbGlnbi1zZWxmOmZsZXgtZW5kO2FsaWduLXNlbGY6ZmxleC1lbmR9Oy0tbGF5b3V0LXNlbGYtc3RyZXRjaDp7LW1zLWFsaWduLXNlbGY6c3RyZXRjaDstd2Via2l0LWFsaWduLXNlbGY6c3RyZXRjaDthbGlnbi1zZWxmOnN0cmV0Y2h9Oy0tbGF5b3V0LXNlbGYtYmFzZWxpbmU6ey1tcy1hbGlnbi1zZWxmOmJhc2VsaW5lOy13ZWJraXQtYWxpZ24tc2VsZjpiYXNlbGluZTthbGlnbi1zZWxmOmJhc2VsaW5lfTstLWxheW91dC1zdGFydC1hbGlnbmVkOnstbXMtZmxleC1saW5lLXBhY2s6c3RhcnQ7LW1zLWFsaWduLWNvbnRlbnQ6ZmxleC1zdGFydDstd2Via2l0LWFsaWduLWNvbnRlbnQ6ZmxleC1zdGFydDthbGlnbi1jb250ZW50OmZsZXgtc3RhcnR9Oy0tbGF5b3V0LWVuZC1hbGlnbmVkOnstbXMtZmxleC1saW5lLXBhY2s6ZW5kOy1tcy1hbGlnbi1jb250ZW50OmZsZXgtZW5kOy13ZWJraXQtYWxpZ24tY29udGVudDpmbGV4LWVuZDthbGlnbi1jb250ZW50OmZsZXgtZW5kfTstLWxheW91dC1jZW50ZXItYWxpZ25lZDp7LW1zLWZsZXgtbGluZS1wYWNrOmNlbnRlcjstbXMtYWxpZ24tY29udGVudDpjZW50ZXI7LXdlYmtpdC1hbGlnbi1jb250ZW50OmNlbnRlcjthbGlnbi1jb250ZW50OmNlbnRlcn07LS1sYXlvdXQtYmV0d2Vlbi1hbGlnbmVkOnstbXMtZmxleC1saW5lLXBhY2s6anVzdGlmeTstbXMtYWxpZ24tY29udGVudDpzcGFjZS1iZXR3ZWVuOy13ZWJraXQtYWxpZ24tY29udGVudDpzcGFjZS1iZXR3ZWVuO2FsaWduLWNvbnRlbnQ6c3BhY2UtYmV0d2Vlbn07LS1sYXlvdXQtYXJvdW5kLWFsaWduZWQ6ey1tcy1mbGV4LWxpbmUtcGFjazpkaXN0cmlidXRlOy1tcy1hbGlnbi1jb250ZW50OnNwYWNlLWFyb3VuZDstd2Via2l0LWFsaWduLWNvbnRlbnQ6c3BhY2UtYXJvdW5kO2FsaWduLWNvbnRlbnQ6c3BhY2UtYXJvdW5kfTstLWxheW91dC1ibG9jazp7ZGlzcGxheTpibG9ja307LS1sYXlvdXQtaW52aXNpYmxlOnt2aXNpYmlsaXR5OmhpZGRlbiFpbXBvcnRhbnR9Oy0tbGF5b3V0LXJlbGF0aXZlOntwb3NpdGlvbjpyZWxhdGl2ZX07LS1sYXlvdXQtZml0Ontwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MDtyaWdodDowO2JvdHRvbTowO2xlZnQ6MH07LS1sYXlvdXQtc2Nyb2xsOnstd2Via2l0LW92ZXJmbG93LXNjcm9sbGluZzp0b3VjaDtvdmVyZmxvdzphdXRvfTstLWxheW91dC1mdWxsYmxlZWQ6e21hcmdpbjowO2hlaWdodDoxMDB2aH07LS1sYXlvdXQtZml4ZWQtdG9wOntwb3NpdGlvbjpmaXhlZDt0b3A6MDtsZWZ0OjA7cmlnaHQ6MH07LS1sYXlvdXQtZml4ZWQtcmlnaHQ6e3Bvc2l0aW9uOmZpeGVkO3RvcDowO3JpZ2h0OjA7Ym90dG9tOjB9Oy0tbGF5b3V0LWZpeGVkLWJvdHRvbTp7cG9zaXRpb246Zml4ZWQ7cmlnaHQ6MDtib3R0b206MDtsZWZ0OjB9Oy0tbGF5b3V0LWZpeGVkLWxlZnQ6e3Bvc2l0aW9uOmZpeGVkO3RvcDowO2JvdHRvbTowO2xlZnQ6MH07fTwvc3R5bGU+IDwvY3VzdG9tLXN0eWxlPlwiKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvaXJvbi1mbGV4LWxheW91dC9pcm9uLWZsZXgtbGF5b3V0Lmh0bWwiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwibGliL21peGlucy9lbGVtZW50LW1peGluLmh0bWxcIj5cbjxzY3JpcHQ+XG4oZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvKipcbiAgICogQmFzZSBjbGFzcyB0aGF0IHByb3ZpZGVzIHRoZSBjb3JlIEFQSSBmb3IgUG9seW1lcidzIG1ldGEtcHJvZ3JhbW1pbmdcbiAgICogZmVhdHVyZXMgaW5jbHVkaW5nIHRlbXBsYXRlIHN0YW1waW5nLCBkYXRhLWJpbmRpbmcsIGF0dHJpYnV0ZSBkZXNlcmlhbGl6YXRpb24sXG4gICAqIGFuZCBwcm9wZXJ0eSBjaGFuZ2Ugb2JzZXJ2YXRpb24uXG4gICAqXG4gICAqIEBjdXN0b21FbGVtZW50XG4gICAqIEBwb2x5bWVyXG4gICAqIEBtZW1iZXJvZiBQb2x5bWVyXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAaW1wbGVtZW50cyB7UG9seW1lcl9FbGVtZW50TWl4aW59XG4gICAqIEBleHRlbmRzIEhUTUxFbGVtZW50XG4gICAqIEBhcHBsaWVzTWl4aW4gUG9seW1lci5FbGVtZW50TWl4aW5cbiAgICogQHN1bW1hcnkgQ3VzdG9tIGVsZW1lbnQgYmFzZSBjbGFzcyB0aGF0IHByb3ZpZGVzIHRoZSBjb3JlIEFQSSBmb3IgUG9seW1lcidzXG4gICAqICAga2V5IG1ldGEtcHJvZ3JhbW1pbmcgZmVhdHVyZXMgaW5jbHVkaW5nIHRlbXBsYXRlIHN0YW1waW5nLCBkYXRhLWJpbmRpbmcsXG4gICAqICAgYXR0cmlidXRlIGRlc2VyaWFsaXphdGlvbiwgYW5kIHByb3BlcnR5IGNoYW5nZSBvYnNlcnZhdGlvblxuICAgKi9cbiAgY29uc3QgRWxlbWVudCA9IFBvbHltZXIuRWxlbWVudE1peGluKEhUTUxFbGVtZW50KTtcbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAaW1wbGVtZW50cyB7UG9seW1lcl9FbGVtZW50TWl4aW59XG4gICAqIEBleHRlbmRzIHtIVE1MRWxlbWVudH1cbiAgICovXG4gIFBvbHltZXIuRWxlbWVudCA9IEVsZW1lbnQ7XG59KSgpO1xuPC9zY3JpcHQ+XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL3BvbHltZXItZWxlbWVudC5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cImJvb3QuaHRtbFwiPlxuXG48c2NyaXB0PlxuXG4gIChmdW5jdGlvbigpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBsZXQgQ1NTX1VSTF9SWCA9IC8odXJsXFwoKShbXildKikoXFwpKS9nO1xuICAgIGxldCBBQlNfVVJMID0gLyheXFwvKXwoXiMpfCheW1xcdy1cXGRdKjopLztcbiAgICBsZXQgd29ya2luZ1VSTDtcbiAgICBsZXQgcmVzb2x2ZURvYztcbiAgICAvKipcbiAgICAgKiBSZXNvbHZlcyB0aGUgZ2l2ZW4gVVJMIGFnYWluc3QgdGhlIHByb3ZpZGVkIGBiYXNlVXJpJy5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBQb2x5bWVyLlJlc29sdmVVcmxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsIElucHV0IFVSTCB0byByZXNvbHZlXG4gICAgICogQHBhcmFtIHs/c3RyaW5nPX0gYmFzZVVSSSBCYXNlIFVSSSB0byByZXNvbHZlIHRoZSBVUkwgYWdhaW5zdFxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gcmVzb2x2ZWQgVVJMXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVzb2x2ZVVybCh1cmwsIGJhc2VVUkkpIHtcbiAgICAgIGlmICh1cmwgJiYgQUJTX1VSTC50ZXN0KHVybCkpIHtcbiAgICAgICAgcmV0dXJuIHVybDtcbiAgICAgIH1cbiAgICAgIC8vIExhenkgZmVhdHVyZSBkZXRlY3Rpb24uXG4gICAgICBpZiAod29ya2luZ1VSTCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHdvcmtpbmdVUkwgPSBmYWxzZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCB1ID0gbmV3IFVSTCgnYicsICdodHRwOi8vYScpO1xuICAgICAgICAgIHUucGF0aG5hbWUgPSAnYyUyMGQnO1xuICAgICAgICAgIHdvcmtpbmdVUkwgPSAodS5ocmVmID09PSAnaHR0cDovL2EvYyUyMGQnKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIC8vIHNpbGVudGx5IGZhaWxcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFiYXNlVVJJKSB7XG4gICAgICAgIGJhc2VVUkkgPSBkb2N1bWVudC5iYXNlVVJJIHx8IHdpbmRvdy5sb2NhdGlvbi5ocmVmO1xuICAgICAgfVxuICAgICAgaWYgKHdvcmtpbmdVUkwpIHtcbiAgICAgICAgcmV0dXJuIChuZXcgVVJMKHVybCwgYmFzZVVSSSkpLmhyZWY7XG4gICAgICB9XG4gICAgICAvLyBGYWxsYmFjayB0byBjcmVhdGluZyBhbiBhbmNob3IgaW50byBhIGRpc2Nvbm5lY3RlZCBkb2N1bWVudC5cbiAgICAgIGlmICghcmVzb2x2ZURvYykge1xuICAgICAgICByZXNvbHZlRG9jID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KCd0ZW1wJyk7XG4gICAgICAgIHJlc29sdmVEb2MuYmFzZSA9IHJlc29sdmVEb2MuY3JlYXRlRWxlbWVudCgnYmFzZScpO1xuICAgICAgICByZXNvbHZlRG9jLmhlYWQuYXBwZW5kQ2hpbGQocmVzb2x2ZURvYy5iYXNlKTtcbiAgICAgICAgcmVzb2x2ZURvYy5hbmNob3IgPSByZXNvbHZlRG9jLmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgICAgICAgcmVzb2x2ZURvYy5ib2R5LmFwcGVuZENoaWxkKHJlc29sdmVEb2MuYW5jaG9yKTtcbiAgICAgIH1cbiAgICAgIHJlc29sdmVEb2MuYmFzZS5ocmVmID0gYmFzZVVSSTtcbiAgICAgIHJlc29sdmVEb2MuYW5jaG9yLmhyZWYgPSB1cmw7XG4gICAgICByZXR1cm4gcmVzb2x2ZURvYy5hbmNob3IuaHJlZiB8fCB1cmw7XG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXNvbHZlcyBhbnkgcmVsYXRpdmUgVVJMJ3MgaW4gdGhlIGdpdmVuIENTUyB0ZXh0IGFnYWluc3QgdGhlIHByb3ZpZGVkXG4gICAgICogYG93bmVyRG9jdW1lbnRgJ3MgYGJhc2VVUklgLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIFBvbHltZXIuUmVzb2x2ZVVybFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjc3NUZXh0IENTUyB0ZXh0IHRvIHByb2Nlc3NcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYmFzZVVSSSBCYXNlIFVSSSB0byByZXNvbHZlIHRoZSBVUkwgYWdhaW5zdFxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gUHJvY2Vzc2VkIENTUyB0ZXh0IHdpdGggcmVzb2x2ZWQgVVJMJ3NcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXNvbHZlQ3NzKGNzc1RleHQsIGJhc2VVUkkpIHtcbiAgICAgIHJldHVybiBjc3NUZXh0LnJlcGxhY2UoQ1NTX1VSTF9SWCwgZnVuY3Rpb24obSwgcHJlLCB1cmwsIHBvc3QpIHtcbiAgICAgICAgcmV0dXJuIHByZSArICdcXCcnICtcbiAgICAgICAgICByZXNvbHZlVXJsKHVybC5yZXBsYWNlKC9bXCInXS9nLCAnJyksIGJhc2VVUkkpICtcbiAgICAgICAgICAnXFwnJyArIHBvc3Q7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgcGF0aCBmcm9tIGEgZ2l2ZW4gYHVybGAuIFRoZSBwYXRoIGluY2x1ZGVzIHRoZSB0cmFpbGluZ1xuICAgICAqIGAvYCBmcm9tIHRoZSB1cmwuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgUG9seW1lci5SZXNvbHZlVXJsXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVybCBJbnB1dCBVUkwgdG8gdHJhbnNmb3JtXG4gICAgICogQHJldHVybiB7c3RyaW5nfSByZXNvbHZlZCBwYXRoXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGF0aEZyb21VcmwodXJsKSB7XG4gICAgICByZXR1cm4gdXJsLnN1YnN0cmluZygwLCB1cmwubGFzdEluZGV4T2YoJy8nKSArIDEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1vZHVsZSB3aXRoIHV0aWxpdGllcyBmb3IgcmVzb2x2aW5nIHJlbGF0aXZlIFVSTCdzLlxuICAgICAqXG4gICAgICogQG5hbWVzcGFjZVxuICAgICAqIEBtZW1iZXJvZiBQb2x5bWVyXG4gICAgICogQHN1bW1hcnkgTW9kdWxlIHdpdGggdXRpbGl0aWVzIGZvciByZXNvbHZpbmcgcmVsYXRpdmUgVVJMJ3MuXG4gICAgICovXG4gICAgUG9seW1lci5SZXNvbHZlVXJsID0ge1xuICAgICAgcmVzb2x2ZUNzczogcmVzb2x2ZUNzcyxcbiAgICAgIHJlc29sdmVVcmw6IHJlc29sdmVVcmwsXG4gICAgICBwYXRoRnJvbVVybDogcGF0aEZyb21VcmxcbiAgICB9O1xuXG4gIH0pKCk7XG5cbjwvc2NyaXB0PlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi91dGlscy9yZXNvbHZlLXVybC5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cImJvb3QuaHRtbFwiPlxuXG48c2NyaXB0PlxuKGZ1bmN0aW9uKCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICAvKiogQHR5cGVkZWYge3tydW46IGZ1bmN0aW9uKGZ1bmN0aW9uKCksIG51bWJlcj0pOm51bWJlciwgY2FuY2VsOiBmdW5jdGlvbihudW1iZXIpfX0gKi9cbiAgbGV0IEFzeW5jSW50ZXJmYWNlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cbiAgLy8gTWljcm90YXNrIGltcGxlbWVudGVkIHVzaW5nIE11dGF0aW9uIE9ic2VydmVyXG4gIGxldCBtaWNyb3Rhc2tDdXJySGFuZGxlID0gMDtcbiAgbGV0IG1pY3JvdGFza0xhc3RIYW5kbGUgPSAwO1xuICBsZXQgbWljcm90YXNrQ2FsbGJhY2tzID0gW107XG4gIGxldCBtaWNyb3Rhc2tOb2RlQ29udGVudCA9IDA7XG4gIGxldCBtaWNyb3Rhc2tOb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycpO1xuICBuZXcgd2luZG93Lk11dGF0aW9uT2JzZXJ2ZXIobWljcm90YXNrRmx1c2gpLm9ic2VydmUobWljcm90YXNrTm9kZSwge2NoYXJhY3RlckRhdGE6IHRydWV9KTtcblxuICBmdW5jdGlvbiBtaWNyb3Rhc2tGbHVzaCgpIHtcbiAgICBjb25zdCBsZW4gPSBtaWNyb3Rhc2tDYWxsYmFja3MubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGxldCBjYiA9IG1pY3JvdGFza0NhbGxiYWNrc1tpXTtcbiAgICAgIGlmIChjYikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNiKCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHsgdGhyb3cgZSB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBtaWNyb3Rhc2tDYWxsYmFja3Muc3BsaWNlKDAsIGxlbik7XG4gICAgbWljcm90YXNrTGFzdEhhbmRsZSArPSBsZW47XG4gIH1cblxuICAvKipcbiAgICogTW9kdWxlIHRoYXQgcHJvdmlkZXMgYSBudW1iZXIgb2Ygc3RyYXRlZ2llcyBmb3IgZW5xdWV1aW5nIGFzeW5jaHJvbm91c1xuICAgKiB0YXNrcy4gIEVhY2ggc3ViLW1vZHVsZSBwcm92aWRlcyBhIHN0YW5kYXJkIGBydW4oZm4pYCBpbnRlcmZhY2UgdGhhdCByZXR1cm5zIGFcbiAgICogaGFuZGxlLCBhbmQgYSBgY2FuY2VsKGhhbmRsZSlgIGludGVyZmFjZSBmb3IgY2FuY2VsaW5nIGFzeW5jIHRhc2tzIGJlZm9yZVxuICAgKiB0aGV5IHJ1bi5cbiAgICpcbiAgICogQG5hbWVzcGFjZVxuICAgKiBAbWVtYmVyb2YgUG9seW1lclxuICAgKiBAc3VtbWFyeSBNb2R1bGUgdGhhdCBwcm92aWRlcyBhIG51bWJlciBvZiBzdHJhdGVnaWVzIGZvciBlbnF1ZXVpbmcgYXN5bmNocm9ub3VzXG4gICAqIHRhc2tzLlxuICAgKi9cbiAgUG9seW1lci5Bc3luYyA9IHtcblxuICAgIC8qKlxuICAgICAqIEFzeW5jIGludGVyZmFjZSB3cmFwcGVyIGFyb3VuZCBgc2V0VGltZW91dGAuXG4gICAgICpcbiAgICAgKiBAbmFtZXNwYWNlXG4gICAgICogQG1lbWJlcm9mIFBvbHltZXIuQXN5bmNcbiAgICAgKiBAc3VtbWFyeSBBc3luYyBpbnRlcmZhY2Ugd3JhcHBlciBhcm91bmQgYHNldFRpbWVvdXRgLlxuICAgICAqL1xuICAgIHRpbWVPdXQ6IHtcbiAgICAgIC8qKlxuICAgICAgICogUmV0dXJucyBhIHN1Yi1tb2R1bGUgd2l0aCB0aGUgYXN5bmMgaW50ZXJmYWNlIHByb3ZpZGluZyB0aGUgcHJvdmlkZWRcbiAgICAgICAqIGRlbGF5LlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJvZiBQb2x5bWVyLkFzeW5jLnRpbWVPdXRcbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkZWxheSBUaW1lIHRvIHdhaXQgYmVmb3JlIGNhbGxpbmcgY2FsbGJhY2tzIGluIG1zXG4gICAgICAgKiBAcmV0dXJuIHtBc3luY0ludGVyZmFjZX0gQW4gYXN5bmMgdGltZW91dCBpbnRlcmZhY2VcbiAgICAgICAqL1xuICAgICAgYWZ0ZXIoZGVsYXkpIHtcbiAgICAgICAgcmV0dXJuICB7XG4gICAgICAgICAgcnVuKGZuKSB7IHJldHVybiBzZXRUaW1lb3V0KGZuLCBkZWxheSkgfSxcbiAgICAgICAgICBjYW5jZWw6IHdpbmRvdy5jbGVhclRpbWVvdXQuYmluZCh3aW5kb3cpXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvKipcbiAgICAgICAqIEVucXVldWVzIGEgZnVuY3Rpb24gY2FsbGVkIGluIHRoZSBuZXh0IHRhc2suXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlcm9mIFBvbHltZXIuQXN5bmMudGltZU91dFxuICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gQ2FsbGJhY2sgdG8gcnVuXG4gICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IEhhbmRsZSB1c2VkIGZvciBjYW5jZWxpbmcgdGFza1xuICAgICAgICovXG4gICAgICBydW46IHdpbmRvdy5zZXRUaW1lb3V0LmJpbmQod2luZG93KSxcbiAgICAgIC8qKlxuICAgICAgICogQ2FuY2VscyBhIHByZXZpb3VzbHkgZW5xdWV1ZWQgYHRpbWVPdXRgIGNhbGxiYWNrLlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJvZiBQb2x5bWVyLkFzeW5jLnRpbWVPdXRcbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoYW5kbGUgSGFuZGxlIHJldHVybmVkIGZyb20gYHJ1bmAgb2YgY2FsbGJhY2sgdG8gY2FuY2VsXG4gICAgICAgKi9cbiAgICAgIGNhbmNlbDogd2luZG93LmNsZWFyVGltZW91dC5iaW5kKHdpbmRvdylcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQXN5bmMgaW50ZXJmYWNlIHdyYXBwZXIgYXJvdW5kIGByZXF1ZXN0QW5pbWF0aW9uRnJhbWVgLlxuICAgICAqXG4gICAgICogQG5hbWVzcGFjZVxuICAgICAqIEBtZW1iZXJvZiBQb2x5bWVyLkFzeW5jXG4gICAgICogQHN1bW1hcnkgQXN5bmMgaW50ZXJmYWNlIHdyYXBwZXIgYXJvdW5kIGByZXF1ZXN0QW5pbWF0aW9uRnJhbWVgLlxuICAgICAqL1xuICAgIGFuaW1hdGlvbkZyYW1lOiB7XG4gICAgICAvKipcbiAgICAgICAqIEVucXVldWVzIGEgZnVuY3Rpb24gY2FsbGVkIGF0IGByZXF1ZXN0QW5pbWF0aW9uRnJhbWVgIHRpbWluZy5cbiAgICAgICAqXG4gICAgICAgKiBAbWVtYmVyb2YgUG9seW1lci5Bc3luYy5hbmltYXRpb25GcmFtZVxuICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gQ2FsbGJhY2sgdG8gcnVuXG4gICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IEhhbmRsZSB1c2VkIGZvciBjYW5jZWxpbmcgdGFza1xuICAgICAgICovXG4gICAgICBydW46IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUuYmluZCh3aW5kb3cpLFxuICAgICAgLyoqXG4gICAgICAgKiBDYW5jZWxzIGEgcHJldmlvdXNseSBlbnF1ZXVlZCBgYW5pbWF0aW9uRnJhbWVgIGNhbGxiYWNrLlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJvZiBQb2x5bWVyLkFzeW5jLnRpbWVPdXRcbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoYW5kbGUgSGFuZGxlIHJldHVybmVkIGZyb20gYHJ1bmAgb2YgY2FsbGJhY2sgdG8gY2FuY2VsXG4gICAgICAgKi9cbiAgICAgIGNhbmNlbDogd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lLmJpbmQod2luZG93KVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBc3luYyBpbnRlcmZhY2Ugd3JhcHBlciBhcm91bmQgYHJlcXVlc3RJZGxlQ2FsbGJhY2tgLiAgRmFsbHMgYmFjayB0b1xuICAgICAqIGBzZXRUaW1lb3V0YCBvbiBicm93c2VycyB0aGF0IGRvIG5vdCBzdXBwb3J0IGByZXF1ZXN0SWRsZUNhbGxiYWNrYC5cbiAgICAgKlxuICAgICAqIEBuYW1lc3BhY2VcbiAgICAgKiBAbWVtYmVyb2YgUG9seW1lci5Bc3luY1xuICAgICAqIEBzdW1tYXJ5IEFzeW5jIGludGVyZmFjZSB3cmFwcGVyIGFyb3VuZCBgcmVxdWVzdElkbGVDYWxsYmFja2AuXG4gICAgICovXG4gICAgaWRsZVBlcmlvZDoge1xuICAgICAgLyoqXG4gICAgICAgKiBFbnF1ZXVlcyBhIGZ1bmN0aW9uIGNhbGxlZCBhdCBgcmVxdWVzdElkbGVDYWxsYmFja2AgdGltaW5nLlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJvZiBQb2x5bWVyLkFzeW5jLmlkbGVQZXJpb2RcbiAgICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oSWRsZURlYWRsaW5lKX0gZm4gQ2FsbGJhY2sgdG8gcnVuXG4gICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IEhhbmRsZSB1c2VkIGZvciBjYW5jZWxpbmcgdGFza1xuICAgICAgICovXG4gICAgICBydW4oZm4pIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5yZXF1ZXN0SWRsZUNhbGxiYWNrID9cbiAgICAgICAgICB3aW5kb3cucmVxdWVzdElkbGVDYWxsYmFjayhmbikgOlxuICAgICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KGZuLCAxNik7XG4gICAgICB9LFxuICAgICAgLyoqXG4gICAgICAgKiBDYW5jZWxzIGEgcHJldmlvdXNseSBlbnF1ZXVlZCBgaWRsZVBlcmlvZGAgY2FsbGJhY2suXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlcm9mIFBvbHltZXIuQXN5bmMuaWRsZVBlcmlvZFxuICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGhhbmRsZSBIYW5kbGUgcmV0dXJuZWQgZnJvbSBgcnVuYCBvZiBjYWxsYmFjayB0byBjYW5jZWxcbiAgICAgICAqL1xuICAgICAgY2FuY2VsKGhhbmRsZSkge1xuICAgICAgICB3aW5kb3cuY2FuY2VsSWRsZUNhbGxiYWNrID9cbiAgICAgICAgICB3aW5kb3cuY2FuY2VsSWRsZUNhbGxiYWNrKGhhbmRsZSkgOlxuICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQoaGFuZGxlKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQXN5bmMgaW50ZXJmYWNlIGZvciBlbnF1ZXVlaW5nIGNhbGxiYWNrcyB0aGF0IHJ1biBhdCBtaWNyb3Rhc2sgdGltaW5nLlxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IG1pY3JvdGFzayB0aW1pbmcgaXMgYWNoaWV2ZWQgdmlhIGEgc2luZ2xlIGBNdXRhdGlvbk9ic2VydmVyYCxcbiAgICAgKiBhbmQgdGh1cyBjYWxsYmFja3MgZW5xdWV1ZWQgd2l0aCB0aGlzIEFQSSB3aWxsIGFsbCBydW4gaW4gYSBzaW5nbGVcbiAgICAgKiBiYXRjaCwgYW5kIG5vdCBpbnRlcmxlYXZlZCB3aXRoIG90aGVyIG1pY3JvdGFza3Mgc3VjaCBhcyBwcm9taXNlcy5cbiAgICAgKiBQcm9taXNlcyBhcmUgYXZvaWRlZCBhcyBhbiBpbXBsZW1lbnRhdGlvbiBjaG9pY2UgZm9yIHRoZSB0aW1lIGJlaW5nXG4gICAgICogZHVlIHRvIFNhZmFyaSBidWdzIHRoYXQgY2F1c2UgUHJvbWlzZXMgdG8gbGFjayBtaWNyb3Rhc2sgZ3VhcmFudGVlcy5cbiAgICAgKlxuICAgICAqIEBuYW1lc3BhY2VcbiAgICAgKiBAbWVtYmVyb2YgUG9seW1lci5Bc3luY1xuICAgICAqIEBzdW1tYXJ5IEFzeW5jIGludGVyZmFjZSBmb3IgZW5xdWV1ZWluZyBjYWxsYmFja3MgdGhhdCBydW4gYXQgbWljcm90YXNrXG4gICAgICogICB0aW1pbmcuXG4gICAgICovXG4gICAgbWljcm9UYXNrOiB7XG5cbiAgICAgIC8qKlxuICAgICAgICogRW5xdWV1ZXMgYSBmdW5jdGlvbiBjYWxsZWQgYXQgbWljcm90YXNrIHRpbWluZy5cbiAgICAgICAqXG4gICAgICAgKiBAbWVtYmVyb2YgUG9seW1lci5Bc3luYy5taWNyb1Rhc2tcbiAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIHRvIHJ1blxuICAgICAgICogQHJldHVybiB7bnVtYmVyfSBIYW5kbGUgdXNlZCBmb3IgY2FuY2VsaW5nIHRhc2tcbiAgICAgICAqL1xuICAgICAgcnVuKGNhbGxiYWNrKSB7XG4gICAgICAgIG1pY3JvdGFza05vZGUudGV4dENvbnRlbnQgPSBtaWNyb3Rhc2tOb2RlQ29udGVudCsrO1xuICAgICAgICBtaWNyb3Rhc2tDYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgICAgIHJldHVybiBtaWNyb3Rhc2tDdXJySGFuZGxlKys7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIENhbmNlbHMgYSBwcmV2aW91c2x5IGVucXVldWVkIGBtaWNyb1Rhc2tgIGNhbGxiYWNrLlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJvZiBQb2x5bWVyLkFzeW5jLm1pY3JvVGFza1xuICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGhhbmRsZSBIYW5kbGUgcmV0dXJuZWQgZnJvbSBgcnVuYCBvZiBjYWxsYmFjayB0byBjYW5jZWxcbiAgICAgICAqL1xuICAgICAgY2FuY2VsKGhhbmRsZSkge1xuICAgICAgICBjb25zdCBpZHggPSBoYW5kbGUgLSBtaWNyb3Rhc2tMYXN0SGFuZGxlO1xuICAgICAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgICAgICBpZiAoIW1pY3JvdGFza0NhbGxiYWNrc1tpZHhdKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYXN5bmMgaGFuZGxlOiAnICsgaGFuZGxlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbWljcm90YXNrQ2FsbGJhY2tzW2lkeF0gPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICB9XG4gIH07XG5cbn0pKCk7XG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvdXRpbHMvYXN5bmMuaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cblxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3V0aWxzL21peGluLmh0bWxcIj5cblxuPHNjcmlwdD5cbihmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIENvbW1vbiBpbXBsZW1lbnRhdGlvbiBmb3IgbWl4aW4gJiBiZWhhdmlvclxuICBmdW5jdGlvbiBtdXRhYmxlUHJvcGVydHlDaGFuZ2UoaW5zdCwgcHJvcGVydHksIHZhbHVlLCBvbGQsIG11dGFibGVEYXRhKSB7XG4gICAgbGV0IGlzT2JqZWN0O1xuICAgIGlmIChtdXRhYmxlRGF0YSkge1xuICAgICAgaXNPYmplY3QgPSAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCk7XG4gICAgICAvLyBQdWxsIGBvbGRgIGZvciBPYmplY3RzIGZyb20gdGVtcCBjYWNoZSwgYnV0IHRyZWF0IGBudWxsYCBhcyBhIHByaW1pdGl2ZVxuICAgICAgaWYgKGlzT2JqZWN0KSB7XG4gICAgICAgIG9sZCA9IGluc3QuX19kYXRhVGVtcFtwcm9wZXJ0eV07XG4gICAgICB9XG4gICAgfVxuICAgIC8vIFN0cmljdCBlcXVhbGl0eSBjaGVjaywgYnV0IHJldHVybiBmYWxzZSBmb3IgTmFOPT09TmFOXG4gICAgbGV0IHNob3VsZENoYW5nZSA9IChvbGQgIT09IHZhbHVlICYmIChvbGQgPT09IG9sZCB8fCB2YWx1ZSA9PT0gdmFsdWUpKTtcbiAgICAvLyBPYmplY3RzIGFyZSBzdG9yZWQgaW4gdGVtcG9yYXJ5IGNhY2hlIChjbGVhcmVkIGF0IGVuZCBvZlxuICAgIC8vIHR1cm4pLCB3aGljaCBpcyB1c2VkIGZvciBkaXJ0eS1jaGVja2luZ1xuICAgIGlmIChpc09iamVjdCAmJiBzaG91bGRDaGFuZ2UpIHtcbiAgICAgIGluc3QuX19kYXRhVGVtcFtwcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHNob3VsZENoYW5nZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbGVtZW50IGNsYXNzIG1peGluIHRvIHNraXAgc3RyaWN0IGRpcnR5LWNoZWNraW5nIGZvciBvYmplY3RzIGFuZCBhcnJheXNcbiAgICogKGFsd2F5cyBjb25zaWRlciB0aGVtIHRvIGJlIFwiZGlydHlcIiksIGZvciB1c2Ugb24gZWxlbWVudHMgdXRpbGl6aW5nXG4gICAqIGBQb2x5bWVyLlByb3BlcnR5RWZmZWN0c2BcbiAgICpcbiAgICogQnkgZGVmYXVsdCwgYFBvbHltZXIuUHJvcGVydHlFZmZlY3RzYCBwZXJmb3JtcyBzdHJpY3QgZGlydHkgY2hlY2tpbmcgb25cbiAgICogb2JqZWN0cywgd2hpY2ggbWVhbnMgdGhhdCBhbnkgZGVlcCBtb2RpZmljYXRpb25zIHRvIGFuIG9iamVjdCBvciBhcnJheSB3aWxsXG4gICAqIG5vdCBiZSBwcm9wYWdhdGVkIHVubGVzcyBcImltbXV0YWJsZVwiIGRhdGEgcGF0dGVybnMgYXJlIHVzZWQgKGkuZS4gYWxsIG9iamVjdFxuICAgKiByZWZlcmVuY2VzIGZyb20gdGhlIHJvb3QgdG8gdGhlIG11dGF0aW9uIHdlcmUgY2hhbmdlZCkuXG4gICAqXG4gICAqIFBvbHltZXIgYWxzbyBwcm92aWRlcyBhIHByb3ByaWV0YXJ5IGRhdGEgbXV0YXRpb24gYW5kIHBhdGggbm90aWZpY2F0aW9uIEFQSVxuICAgKiAoZS5nLiBgbm90aWZ5UGF0aGAsIGBzZXRgLCBhbmQgYXJyYXkgbXV0YXRpb24gQVBJJ3MpIHRoYXQgYWxsb3cgZWZmaWNpZW50XG4gICAqIG11dGF0aW9uIGFuZCBub3RpZmljYXRpb24gb2YgZGVlcCBjaGFuZ2VzIGluIGFuIG9iamVjdCBncmFwaCB0byBhbGwgZWxlbWVudHNcbiAgICogYm91bmQgdG8gdGhlIHNhbWUgb2JqZWN0IGdyYXBoLlxuICAgKlxuICAgKiBJbiBjYXNlcyB3aGVyZSBuZWl0aGVyIGltbXV0YWJsZSBwYXR0ZXJucyBub3IgdGhlIGRhdGEgbXV0YXRpb24gQVBJIGNhbiBiZVxuICAgKiB1c2VkLCBhcHBseWluZyB0aGlzIG1peGluIHdpbGwgY2F1c2UgUG9seW1lciB0byBza2lwIGRpcnR5IGNoZWNraW5nIGZvclxuICAgKiBvYmplY3RzIGFuZCBhcnJheXMgKGFsd2F5cyBjb25zaWRlciB0aGVtIHRvIGJlIFwiZGlydHlcIikuICBUaGlzIGFsbG93cyBhXG4gICAqIHVzZXIgdG8gbWFrZSBhIGRlZXAgbW9kaWZpY2F0aW9uIHRvIGEgYm91bmQgb2JqZWN0IGdyYXBoLCBhbmQgdGhlbiBlaXRoZXJcbiAgICogc2ltcGx5IHJlLXNldCB0aGUgb2JqZWN0IChlLmcuIGB0aGlzLml0ZW1zID0gdGhpcy5pdGVtc2ApIG9yIGNhbGwgYG5vdGlmeVBhdGhgXG4gICAqIChlLmcuIGB0aGlzLm5vdGlmeVBhdGgoJ2l0ZW1zJylgKSB0byB1cGRhdGUgdGhlIHRyZWUuICBOb3RlIHRoYXQgYWxsXG4gICAqIGVsZW1lbnRzIHRoYXQgd2lzaCB0byBiZSB1cGRhdGVkIGJhc2VkIG9uIGRlZXAgbXV0YXRpb25zIG11c3QgYXBwbHkgdGhpc1xuICAgKiBtaXhpbiBvciBvdGhlcndpc2Ugc2tpcCBzdHJpY3QgZGlydHkgY2hlY2tpbmcgZm9yIG9iamVjdHMvYXJyYXlzLlxuICAgKlxuICAgKiBJbiBvcmRlciB0byBtYWtlIHRoZSBkaXJ0eSBjaGVjayBzdHJhdGVneSBjb25maWd1cmFibGUsIHNlZVxuICAgKiBgUG9seW1lci5PcHRpb25hbE11dGFibGVEYXRhYC5cbiAgICpcbiAgICogTm90ZSwgdGhlIHBlcmZvcm1hbmNlIGNoYXJhY3RlcmlzdGljcyBvZiBwcm9wYWdhdGluZyBsYXJnZSBvYmplY3QgZ3JhcGhzXG4gICAqIHdpbGwgYmUgd29yc2UgYXMgb3Bwb3NlZCB0byB1c2luZyBzdHJpY3QgZGlydHkgY2hlY2tpbmcgd2l0aCBpbW11dGFibGVcbiAgICogcGF0dGVybnMgb3IgUG9seW1lcidzIHBhdGggbm90aWZpY2F0aW9uIEFQSS5cbiAgICpcbiAgICogQG1peGluRnVuY3Rpb25cbiAgICogQHBvbHltZXJcbiAgICogQG1lbWJlcm9mIFBvbHltZXJcbiAgICogQHN1bW1hcnkgRWxlbWVudCBjbGFzcyBtaXhpbiB0byBza2lwIHN0cmljdCBkaXJ0eS1jaGVja2luZyBmb3Igb2JqZWN0c1xuICAgKiAgIGFuZCBhcnJheXNcbiAgICovXG4gIFBvbHltZXIuTXV0YWJsZURhdGEgPSBQb2x5bWVyLmRlZHVwaW5nTWl4aW4oc3VwZXJDbGFzcyA9PiB7XG5cbiAgICAvKipcbiAgICAgKiBAcG9seW1lclxuICAgICAqIEBtaXhpbkNsYXNzXG4gICAgICogQGltcGxlbWVudHMge1BvbHltZXJfTXV0YWJsZURhdGF9XG4gICAgICovXG4gICAgY2xhc3MgTXV0YWJsZURhdGEgZXh0ZW5kcyBzdXBlckNsYXNzIHtcbiAgICAgIC8qKlxuICAgICAgICogT3ZlcnJpZGVzIGBQb2x5bWVyLlByb3BlcnR5RWZmZWN0c2AgdG8gcHJvdmlkZSBvcHRpb24gZm9yIHNraXBwaW5nXG4gICAgICAgKiBzdHJpY3QgZXF1YWxpdHkgY2hlY2tpbmcgZm9yIE9iamVjdHMgYW5kIEFycmF5cy5cbiAgICAgICAqXG4gICAgICAgKiBUaGlzIG1ldGhvZCBwdWxscyB0aGUgdmFsdWUgdG8gZGlydHkgY2hlY2sgYWdhaW5zdCBmcm9tIHRoZSBgX19kYXRhVGVtcGBcbiAgICAgICAqIGNhY2hlIChyYXRoZXIgdGhhbiB0aGUgbm9ybWFsIGBfX2RhdGFgIGNhY2hlKSBmb3IgT2JqZWN0cy4gIFNpbmNlIHRoZSB0ZW1wXG4gICAgICAgKiBjYWNoZSBpcyBjbGVhcmVkIGF0IHRoZSBlbmQgb2YgYSB0dXJuLCB0aGlzIGltcGxlbWVudGF0aW9uIGFsbG93c1xuICAgICAgICogc2lkZS1lZmZlY3RzIG9mIGRlZXAgb2JqZWN0IGNoYW5nZXMgdG8gYmUgcHJvY2Vzc2VkIGJ5IHJlLXNldHRpbmcgdGhlXG4gICAgICAgKiBzYW1lIG9iamVjdCAodXNpbmcgdGhlIHRlbXAgY2FjaGUgYXMgYW4gaW4tdHVybiBiYWNrc3RvcCB0byBwcmV2ZW50XG4gICAgICAgKiBjeWNsZXMgZHVlIHRvIDItd2F5IG5vdGlmaWNhdGlvbikuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IG5hbWVcbiAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgTmV3IHByb3BlcnR5IHZhbHVlXG4gICAgICAgKiBAcGFyYW0geyp9IG9sZCBQcmV2aW91cyBwcm9wZXJ0eSB2YWx1ZVxuICAgICAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgcHJvcGVydHkgc2hvdWxkIGJlIGNvbnNpZGVyZWQgYSBjaGFuZ2VcbiAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAqL1xuICAgICAgX3Nob3VsZFByb3BlcnR5Q2hhbmdlKHByb3BlcnR5LCB2YWx1ZSwgb2xkKSB7XG4gICAgICAgIHJldHVybiBtdXRhYmxlUHJvcGVydHlDaGFuZ2UodGhpcywgcHJvcGVydHksIHZhbHVlLCBvbGQsIHRydWUpO1xuICAgICAgfVxuXG4gICAgfVxuICAgIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cbiAgICBNdXRhYmxlRGF0YS5wcm90b3R5cGUubXV0YWJsZURhdGEgPSBmYWxzZTtcblxuICAgIHJldHVybiBNdXRhYmxlRGF0YTtcblxuICB9KTtcblxuXG4gIC8qKlxuICAgKiBFbGVtZW50IGNsYXNzIG1peGluIHRvIGFkZCB0aGUgb3B0aW9uYWwgYWJpbGl0eSB0byBza2lwIHN0cmljdFxuICAgKiBkaXJ0eS1jaGVja2luZyBmb3Igb2JqZWN0cyBhbmQgYXJyYXlzIChhbHdheXMgY29uc2lkZXIgdGhlbSB0byBiZVxuICAgKiBcImRpcnR5XCIpIGJ5IHNldHRpbmcgYSBgbXV0YWJsZS1kYXRhYCBhdHRyaWJ1dGUgb24gYW4gZWxlbWVudCBpbnN0YW5jZS5cbiAgICpcbiAgICogQnkgZGVmYXVsdCwgYFBvbHltZXIuUHJvcGVydHlFZmZlY3RzYCBwZXJmb3JtcyBzdHJpY3QgZGlydHkgY2hlY2tpbmcgb25cbiAgICogb2JqZWN0cywgd2hpY2ggbWVhbnMgdGhhdCBhbnkgZGVlcCBtb2RpZmljYXRpb25zIHRvIGFuIG9iamVjdCBvciBhcnJheSB3aWxsXG4gICAqIG5vdCBiZSBwcm9wYWdhdGVkIHVubGVzcyBcImltbXV0YWJsZVwiIGRhdGEgcGF0dGVybnMgYXJlIHVzZWQgKGkuZS4gYWxsIG9iamVjdFxuICAgKiByZWZlcmVuY2VzIGZyb20gdGhlIHJvb3QgdG8gdGhlIG11dGF0aW9uIHdlcmUgY2hhbmdlZCkuXG4gICAqXG4gICAqIFBvbHltZXIgYWxzbyBwcm92aWRlcyBhIHByb3ByaWV0YXJ5IGRhdGEgbXV0YXRpb24gYW5kIHBhdGggbm90aWZpY2F0aW9uIEFQSVxuICAgKiAoZS5nLiBgbm90aWZ5UGF0aGAsIGBzZXRgLCBhbmQgYXJyYXkgbXV0YXRpb24gQVBJJ3MpIHRoYXQgYWxsb3cgZWZmaWNpZW50XG4gICAqIG11dGF0aW9uIGFuZCBub3RpZmljYXRpb24gb2YgZGVlcCBjaGFuZ2VzIGluIGFuIG9iamVjdCBncmFwaCB0byBhbGwgZWxlbWVudHNcbiAgICogYm91bmQgdG8gdGhlIHNhbWUgb2JqZWN0IGdyYXBoLlxuICAgKlxuICAgKiBJbiBjYXNlcyB3aGVyZSBuZWl0aGVyIGltbXV0YWJsZSBwYXR0ZXJucyBub3IgdGhlIGRhdGEgbXV0YXRpb24gQVBJIGNhbiBiZVxuICAgKiB1c2VkLCBhcHBseWluZyB0aGlzIG1peGluIHdpbGwgYWxsb3cgUG9seW1lciB0byBza2lwIGRpcnR5IGNoZWNraW5nIGZvclxuICAgKiBvYmplY3RzIGFuZCBhcnJheXMgKGFsd2F5cyBjb25zaWRlciB0aGVtIHRvIGJlIFwiZGlydHlcIikuICBUaGlzIGFsbG93cyBhXG4gICAqIHVzZXIgdG8gbWFrZSBhIGRlZXAgbW9kaWZpY2F0aW9uIHRvIGEgYm91bmQgb2JqZWN0IGdyYXBoLCBhbmQgdGhlbiBlaXRoZXJcbiAgICogc2ltcGx5IHJlLXNldCB0aGUgb2JqZWN0IChlLmcuIGB0aGlzLml0ZW1zID0gdGhpcy5pdGVtc2ApIG9yIGNhbGwgYG5vdGlmeVBhdGhgXG4gICAqIChlLmcuIGB0aGlzLm5vdGlmeVBhdGgoJ2l0ZW1zJylgKSB0byB1cGRhdGUgdGhlIHRyZWUuICBOb3RlIHRoYXQgYWxsXG4gICAqIGVsZW1lbnRzIHRoYXQgd2lzaCB0byBiZSB1cGRhdGVkIGJhc2VkIG9uIGRlZXAgbXV0YXRpb25zIG11c3QgYXBwbHkgdGhpc1xuICAgKiBtaXhpbiBvciBvdGhlcndpc2Ugc2tpcCBzdHJpY3QgZGlydHkgY2hlY2tpbmcgZm9yIG9iamVjdHMvYXJyYXlzLlxuICAgKlxuICAgKiBXaGlsZSB0aGlzIG1peGluIGFkZHMgdGhlIGFiaWxpdHkgdG8gZm9yZ28gT2JqZWN0L0FycmF5IGRpcnR5IGNoZWNraW5nLFxuICAgKiB0aGUgYG11dGFibGVEYXRhYCBmbGFnIGRlZmF1bHRzIHRvIGZhbHNlIGFuZCBtdXN0IGJlIHNldCBvbiB0aGUgaW5zdGFuY2UuXG4gICAqXG4gICAqIE5vdGUsIHRoZSBwZXJmb3JtYW5jZSBjaGFyYWN0ZXJpc3RpY3Mgb2YgcHJvcGFnYXRpbmcgbGFyZ2Ugb2JqZWN0IGdyYXBoc1xuICAgKiB3aWxsIGJlIHdvcnNlIGJ5IHJlbHlpbmcgb24gYG11dGFibGVEYXRhOiB0cnVlYCBhcyBvcHBvc2VkIHRvIHVzaW5nXG4gICAqIHN0cmljdCBkaXJ0eSBjaGVja2luZyB3aXRoIGltbXV0YWJsZSBwYXR0ZXJucyBvciBQb2x5bWVyJ3MgcGF0aCBub3RpZmljYXRpb25cbiAgICogQVBJLlxuICAgKlxuICAgKiBAbWl4aW5GdW5jdGlvblxuICAgKiBAcG9seW1lclxuICAgKiBAbWVtYmVyb2YgUG9seW1lclxuICAgKiBAc3VtbWFyeSBFbGVtZW50IGNsYXNzIG1peGluIHRvIG9wdGlvbmFsbHkgc2tpcCBzdHJpY3QgZGlydHktY2hlY2tpbmdcbiAgICogICBmb3Igb2JqZWN0cyBhbmQgYXJyYXlzXG4gICAqL1xuICBQb2x5bWVyLk9wdGlvbmFsTXV0YWJsZURhdGEgPSBQb2x5bWVyLmRlZHVwaW5nTWl4aW4oc3VwZXJDbGFzcyA9PiB7XG5cbiAgICAvKipcbiAgICAgKiBAbWl4aW5DbGFzc1xuICAgICAqIEBwb2x5bWVyXG4gICAgICogQGltcGxlbWVudHMge1BvbHltZXJfT3B0aW9uYWxNdXRhYmxlRGF0YX1cbiAgICAgKi9cbiAgICBjbGFzcyBPcHRpb25hbE11dGFibGVEYXRhIGV4dGVuZHMgc3VwZXJDbGFzcyB7XG5cbiAgICAgIHN0YXRpYyBnZXQgcHJvcGVydGllcygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBJbnN0YW5jZS1sZXZlbCBmbGFnIGZvciBjb25maWd1cmluZyB0aGUgZGlydHktY2hlY2tpbmcgc3RyYXRlZ3lcbiAgICAgICAgICAgKiBmb3IgdGhpcyBlbGVtZW50LiAgV2hlbiB0cnVlLCBPYmplY3RzIGFuZCBBcnJheXMgd2lsbCBza2lwIGRpcnR5XG4gICAgICAgICAgICogY2hlY2tpbmcsIG90aGVyd2lzZSBzdHJpY3QgZXF1YWxpdHkgY2hlY2tpbmcgd2lsbCBiZSB1c2VkLlxuICAgICAgICAgICAqL1xuICAgICAgICAgIG11dGFibGVEYXRhOiBCb29sZWFuXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogT3ZlcnJpZGVzIGBQb2x5bWVyLlByb3BlcnR5RWZmZWN0c2AgdG8gcHJvdmlkZSBvcHRpb24gZm9yIHNraXBwaW5nXG4gICAgICAgKiBzdHJpY3QgZXF1YWxpdHkgY2hlY2tpbmcgZm9yIE9iamVjdHMgYW5kIEFycmF5cy5cbiAgICAgICAqXG4gICAgICAgKiBXaGVuIGB0aGlzLm11dGFibGVEYXRhYCBpcyB0cnVlIG9uIHRoaXMgaW5zdGFuY2UsIHRoaXMgbWV0aG9kXG4gICAgICAgKiBwdWxscyB0aGUgdmFsdWUgdG8gZGlydHkgY2hlY2sgYWdhaW5zdCBmcm9tIHRoZSBgX19kYXRhVGVtcGAgY2FjaGVcbiAgICAgICAqIChyYXRoZXIgdGhhbiB0aGUgbm9ybWFsIGBfX2RhdGFgIGNhY2hlKSBmb3IgT2JqZWN0cy4gIFNpbmNlIHRoZSB0ZW1wXG4gICAgICAgKiBjYWNoZSBpcyBjbGVhcmVkIGF0IHRoZSBlbmQgb2YgYSB0dXJuLCB0aGlzIGltcGxlbWVudGF0aW9uIGFsbG93c1xuICAgICAgICogc2lkZS1lZmZlY3RzIG9mIGRlZXAgb2JqZWN0IGNoYW5nZXMgdG8gYmUgcHJvY2Vzc2VkIGJ5IHJlLXNldHRpbmcgdGhlXG4gICAgICAgKiBzYW1lIG9iamVjdCAodXNpbmcgdGhlIHRlbXAgY2FjaGUgYXMgYW4gaW4tdHVybiBiYWNrc3RvcCB0byBwcmV2ZW50XG4gICAgICAgKiBjeWNsZXMgZHVlIHRvIDItd2F5IG5vdGlmaWNhdGlvbikuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IG5hbWVcbiAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgTmV3IHByb3BlcnR5IHZhbHVlXG4gICAgICAgKiBAcGFyYW0geyp9IG9sZCBQcmV2aW91cyBwcm9wZXJ0eSB2YWx1ZVxuICAgICAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgcHJvcGVydHkgc2hvdWxkIGJlIGNvbnNpZGVyZWQgYSBjaGFuZ2VcbiAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAqL1xuICAgICAgX3Nob3VsZFByb3BlcnR5Q2hhbmdlKHByb3BlcnR5LCB2YWx1ZSwgb2xkKSB7XG4gICAgICAgIHJldHVybiBtdXRhYmxlUHJvcGVydHlDaGFuZ2UodGhpcywgcHJvcGVydHksIHZhbHVlLCBvbGQsIHRoaXMubXV0YWJsZURhdGEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBPcHRpb25hbE11dGFibGVEYXRhO1xuXG4gIH0pO1xuXG4gIC8vIEV4cG9ydCBmb3IgdXNlIGJ5IGxlZ2FjeSBiZWhhdmlvclxuICBQb2x5bWVyLk11dGFibGVEYXRhLl9tdXRhYmxlUHJvcGVydHlDaGFuZ2UgPSBtdXRhYmxlUHJvcGVydHlDaGFuZ2U7XG5cbn0pKCk7XG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvbWl4aW5zL211dGFibGUtZGF0YS5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cImJvb3QuaHRtbFwiPlxuPHNjcmlwdD5cbihmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIGNvbnN0IGNhc2VNYXAgPSB7fTtcbiAgY29uc3QgREFTSF9UT19DQU1FTCA9IC8tW2Etel0vZztcbiAgY29uc3QgQ0FNRUxfVE9fREFTSCA9IC8oW0EtWl0pL2c7XG5cbiAgLyoqXG4gICAqIE1vZHVsZSB3aXRoIHV0aWxpdGllcyBmb3IgY29udmVydGluZyBiZXR3ZWVuIFwiZGFzaC1jYXNlXCIgYW5kIFwiY2FtZWxDYXNlXCJcbiAgICogaWRlbnRpZmllcnMuXG4gICAqXG4gICAqIEBuYW1lc3BhY2VcbiAgICogQG1lbWJlcm9mIFBvbHltZXJcbiAgICogQHN1bW1hcnkgTW9kdWxlIHRoYXQgcHJvdmlkZXMgdXRpbGl0aWVzIGZvciBjb252ZXJ0aW5nIGJldHdlZW4gXCJkYXNoLWNhc2VcIlxuICAgKiAgIGFuZCBcImNhbWVsQ2FzZVwiLlxuICAgKi9cbiAgY29uc3QgQ2FzZU1hcCA9IHtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIFwiZGFzaC1jYXNlXCIgaWRlbnRpZmllciAoZS5nLiBgZm9vLWJhci1iYXpgKSB0byBcImNhbWVsQ2FzZVwiXG4gICAgICogKGUuZy4gYGZvb0JhckJhemApLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIFBvbHltZXIuQ2FzZU1hcFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkYXNoIERhc2gtY2FzZSBpZGVudGlmaWVyXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBDYW1lbC1jYXNlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBpZGVudGlmaWVyXG4gICAgICovXG4gICAgZGFzaFRvQ2FtZWxDYXNlKGRhc2gpIHtcbiAgICAgIHJldHVybiBjYXNlTWFwW2Rhc2hdIHx8IChcbiAgICAgICAgY2FzZU1hcFtkYXNoXSA9IGRhc2guaW5kZXhPZignLScpIDwgMCA/IGRhc2ggOiBkYXNoLnJlcGxhY2UoREFTSF9UT19DQU1FTCxcbiAgICAgICAgICAobSkgPT4gbVsxXS50b1VwcGVyQ2FzZSgpXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIFwiY2FtZWxDYXNlXCIgaWRlbnRpZmllciAoZS5nLiBgZm9vQmFyQmF6YCkgdG8gXCJkYXNoLWNhc2VcIlxuICAgICAqIChlLmcuIGBmb28tYmFyLWJhemApLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIFBvbHltZXIuQ2FzZU1hcFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjYW1lbCBDYW1lbC1jYXNlIGlkZW50aWZpZXJcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IERhc2gtY2FzZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgaWRlbnRpZmllclxuICAgICAqL1xuICAgIGNhbWVsVG9EYXNoQ2FzZShjYW1lbCkge1xuICAgICAgcmV0dXJuIGNhc2VNYXBbY2FtZWxdIHx8IChcbiAgICAgICAgY2FzZU1hcFtjYW1lbF0gPSBjYW1lbC5yZXBsYWNlKENBTUVMX1RPX0RBU0gsICctJDEnKS50b0xvd2VyQ2FzZSgpXG4gICAgICApO1xuICAgIH1cblxuICB9O1xuXG4gIFBvbHltZXIuQ2FzZU1hcCA9IENhc2VNYXA7XG59KSgpO1xuPC9zY3JpcHQ+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL3BvbHltZXIvbGliL3V0aWxzL2Nhc2UtbWFwLmh0bWwiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG5cblxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3V0aWxzL2Jvb3QuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3V0aWxzL21peGluLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi91dGlscy9wYXRoLmh0bWxcIj5cbjwhLS0gZm9yIG5vdGlmeSwgcmVmbGVjdCAtLT5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi91dGlscy9jYXNlLW1hcC5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwicHJvcGVydHktYWNjZXNzb3JzLmh0bWxcIj5cbjwhLS0gZm9yIGFubm90YXRlZCBlZmZlY3RzIC0tPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cInRlbXBsYXRlLXN0YW1wLmh0bWxcIj5cblxuXG48c2NyaXB0PlxuKGZ1bmN0aW9uKCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICAvKiogQGNvbnN0IHtPYmplY3R9ICovXG4gIGNvbnN0IENhc2VNYXAgPSBQb2x5bWVyLkNhc2VNYXA7XG5cbiAgLy8gTW9ub3RvbmljYWxseSBpbmNyZWFzaW5nIHVuaXF1ZSBJRCB1c2VkIGZvciBkZS1kdXBpbmcgZWZmZWN0cyB0cmlnZ2VyZWRcbiAgLy8gZnJvbSBtdWx0aXBsZSBwcm9wZXJ0aWVzIGluIHRoZSBzYW1lIHR1cm5cbiAgbGV0IGRlZHVwZUlkID0gMDtcblxuICAvKipcbiAgICogUHJvcGVydHkgZWZmZWN0IHR5cGVzOyBlZmZlY3RzIGFyZSBzdG9yZWQgb24gdGhlIHByb3RvdHlwZSB1c2luZyB0aGVzZSBrZXlzXG4gICAqIEBlbnVtIHtzdHJpbmd9XG4gICAqL1xuICBjb25zdCBUWVBFUyA9IHtcbiAgICBDT01QVVRFOiAnX19jb21wdXRlRWZmZWN0cycsXG4gICAgUkVGTEVDVDogJ19fcmVmbGVjdEVmZmVjdHMnLFxuICAgIE5PVElGWTogJ19fbm90aWZ5RWZmZWN0cycsXG4gICAgUFJPUEFHQVRFOiAnX19wcm9wYWdhdGVFZmZlY3RzJyxcbiAgICBPQlNFUlZFOiAnX19vYnNlcnZlRWZmZWN0cycsXG4gICAgUkVBRF9PTkxZOiAnX19yZWFkT25seSdcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZWRlZiB7e1xuICAgKiBuYW1lOiAoc3RyaW5nIHwgdW5kZWZpbmVkKSxcbiAgICogc3RydWN0dXJlZDogKGJvb2xlYW4gfCB1bmRlZmluZWQpLFxuICAgKiB3aWxkY2FyZDogKGJvb2xlYW4gfCB1bmRlZmluZWQpXG4gICAqIH19XG4gICAqL1xuICBsZXQgRGF0YVRyaWdnZXI7IC8vZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuXG4gIC8qKlxuICAgKiBAdHlwZWRlZiB7e1xuICAgKiBpbmZvOiA/LFxuICAgKiB0cmlnZ2VyOiAoIURhdGFUcmlnZ2VyIHwgdW5kZWZpbmVkKSxcbiAgICogZm46ICghRnVuY3Rpb24gfCB1bmRlZmluZWQpXG4gICAqIH19XG4gICAqL1xuICBsZXQgRGF0YUVmZmVjdDsgLy9lc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cbiAgbGV0IFByb3BlcnR5RWZmZWN0c1R5cGU7IC8vZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuXG4gIC8qKlxuICAgKiBFbnN1cmVzIHRoYXQgdGhlIG1vZGVsIGhhcyBhbiBvd24tcHJvcGVydHkgbWFwIG9mIGVmZmVjdHMgZm9yIHRoZSBnaXZlbiB0eXBlLlxuICAgKiBUaGUgbW9kZWwgbWF5IGJlIGEgcHJvdG90eXBlIG9yIGFuIGluc3RhbmNlLlxuICAgKlxuICAgKiBQcm9wZXJ0eSBlZmZlY3RzIGFyZSBzdG9yZWQgYXMgYXJyYXlzIG9mIGVmZmVjdHMgYnkgcHJvcGVydHkgaW4gYSBtYXAsXG4gICAqIGJ5IG5hbWVkIHR5cGUgb24gdGhlIG1vZGVsLiBlLmcuXG4gICAqXG4gICAqICAgX19jb21wdXRlRWZmZWN0czoge1xuICAgKiAgICAgZm9vOiBbIC4uLiBdLFxuICAgKiAgICAgYmFyOiBbIC4uLiBdXG4gICAqICAgfVxuICAgKlxuICAgKiBJZiB0aGUgbW9kZWwgZG9lcyBub3QgeWV0IGhhdmUgYW4gZWZmZWN0IG1hcCBmb3IgdGhlIHR5cGUsIG9uZSBpcyBjcmVhdGVkXG4gICAqIGFuZCByZXR1cm5lZC4gIElmIGl0IGRvZXMsIGJ1dCBpdCBpcyBub3QgYW4gb3duIHByb3BlcnR5IChpLmUuIHRoZVxuICAgKiBwcm90b3R5cGUgaGFkIGVmZmVjdHMpLCB0aGUgdGhlIG1hcCBpcyBkZWVwbHkgY2xvbmVkIGFuZCB0aGUgY29weSBpc1xuICAgKiBzZXQgb24gdGhlIG1vZGVsIGFuZCByZXR1cm5lZCwgcmVhZHkgZm9yIG5ldyBlZmZlY3RzIHRvIGJlIGFkZGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gbW9kZWwgUHJvdG90eXBlIG9yIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIFByb3BlcnR5IGVmZmVjdCB0eXBlXG4gICAqIEByZXR1cm4ge09iamVjdH0gVGhlIG93bi1wcm9wZXJ0eSBtYXAgb2YgZWZmZWN0cyBmb3IgdGhlIGdpdmVuIHR5cGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIGVuc3VyZU93bkVmZmVjdE1hcChtb2RlbCwgdHlwZSkge1xuICAgIGxldCBlZmZlY3RzID0gbW9kZWxbdHlwZV07XG4gICAgaWYgKCFlZmZlY3RzKSB7XG4gICAgICBlZmZlY3RzID0gbW9kZWxbdHlwZV0gPSB7fTtcbiAgICB9IGVsc2UgaWYgKCFtb2RlbC5oYXNPd25Qcm9wZXJ0eSh0eXBlKSkge1xuICAgICAgZWZmZWN0cyA9IG1vZGVsW3R5cGVdID0gT2JqZWN0LmNyZWF0ZShtb2RlbFt0eXBlXSk7XG4gICAgICBmb3IgKGxldCBwIGluIGVmZmVjdHMpIHtcbiAgICAgICAgbGV0IHByb3RvRnggPSBlZmZlY3RzW3BdO1xuICAgICAgICBsZXQgaW5zdEZ4ID0gZWZmZWN0c1twXSA9IEFycmF5KHByb3RvRngubGVuZ3RoKTtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPHByb3RvRngubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpbnN0RnhbaV0gPSBwcm90b0Z4W2ldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlZmZlY3RzO1xuICB9XG5cbiAgLy8gLS0gZWZmZWN0cyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLyoqXG4gICAqIFJ1bnMgYWxsIGVmZmVjdHMgb2YgYSBnaXZlbiB0eXBlIGZvciB0aGUgZ2l2ZW4gc2V0IG9mIHByb3BlcnR5IGNoYW5nZXNcbiAgICogb24gYW4gaW5zdGFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7IVByb3BlcnR5RWZmZWN0c1R5cGV9IGluc3QgVGhlIGluc3RhbmNlIHdpdGggZWZmZWN0cyB0byBydW5cbiAgICogQHBhcmFtIHtPYmplY3R9IGVmZmVjdHMgT2JqZWN0IG1hcCBvZiBwcm9wZXJ0eS10by1BcnJheSBvZiBlZmZlY3RzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBCYWcgb2YgY3VycmVudCBwcm9wZXJ0eSBjaGFuZ2VzXG4gICAqIEBwYXJhbSB7T2JqZWN0PX0gb2xkUHJvcHMgQmFnIG9mIHByZXZpb3VzIHZhbHVlcyBmb3IgY2hhbmdlZCBwcm9wZXJ0aWVzXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IGhhc1BhdGhzIFRydWUgd2l0aCBgcHJvcHNgIGNvbnRhaW5zIG9uZSBvciBtb3JlIHBhdGhzXG4gICAqIEBwYXJhbSB7Kj19IGV4dHJhQXJncyBBZGRpdGlvbmFsIG1ldGFkYXRhIHRvIHBhc3MgdG8gZWZmZWN0IGZ1bmN0aW9uXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYW4gZWZmZWN0IHJhbiBmb3IgdGhpcyBwcm9wZXJ0eVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gcnVuRWZmZWN0cyhpbnN0LCBlZmZlY3RzLCBwcm9wcywgb2xkUHJvcHMsIGhhc1BhdGhzLCBleHRyYUFyZ3MpIHtcbiAgICBpZiAoZWZmZWN0cykge1xuICAgICAgbGV0IHJhbiA9IGZhbHNlO1xuICAgICAgbGV0IGlkID0gZGVkdXBlSWQrKztcbiAgICAgIGZvciAobGV0IHByb3AgaW4gcHJvcHMpIHtcbiAgICAgICAgaWYgKHJ1bkVmZmVjdHNGb3JQcm9wZXJ0eShpbnN0LCBlZmZlY3RzLCBpZCwgcHJvcCwgcHJvcHMsIG9sZFByb3BzLCBoYXNQYXRocywgZXh0cmFBcmdzKSkge1xuICAgICAgICAgIHJhbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByYW47XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSdW5zIGEgbGlzdCBvZiBlZmZlY3RzIGZvciBhIGdpdmVuIHByb3BlcnR5LlxuICAgKlxuICAgKiBAcGFyYW0geyFQcm9wZXJ0eUVmZmVjdHNUeXBlfSBpbnN0IFRoZSBpbnN0YW5jZSB3aXRoIGVmZmVjdHMgdG8gcnVuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlZmZlY3RzIE9iamVjdCBtYXAgb2YgcHJvcGVydHktdG8tQXJyYXkgb2YgZWZmZWN0c1xuICAgKiBAcGFyYW0ge251bWJlcn0gZGVkdXBlSWQgQ291bnRlciB1c2VkIGZvciBkZS1kdXBpbmcgZWZmZWN0c1xuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcCBOYW1lIG9mIGNoYW5nZWQgcHJvcGVydHlcbiAgICogQHBhcmFtIHsqfSBwcm9wcyBDaGFuZ2VkIHByb3BlcnRpZXNcbiAgICogQHBhcmFtIHsqfSBvbGRQcm9wcyBPbGQgcHJvcGVydGllc1xuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBoYXNQYXRocyBUcnVlIHdpdGggYHByb3BzYCBjb250YWlucyBvbmUgb3IgbW9yZSBwYXRoc1xuICAgKiBAcGFyYW0geyo9fSBleHRyYUFyZ3MgQWRkaXRpb25hbCBtZXRhZGF0YSB0byBwYXNzIHRvIGVmZmVjdCBmdW5jdGlvblxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGFuIGVmZmVjdCByYW4gZm9yIHRoaXMgcHJvcGVydHlcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIHJ1bkVmZmVjdHNGb3JQcm9wZXJ0eShpbnN0LCBlZmZlY3RzLCBkZWR1cGVJZCwgcHJvcCwgcHJvcHMsIG9sZFByb3BzLCBoYXNQYXRocywgZXh0cmFBcmdzKSB7XG4gICAgbGV0IHJhbiA9IGZhbHNlO1xuICAgIGxldCByb290UHJvcGVydHkgPSBoYXNQYXRocyA/IFBvbHltZXIuUGF0aC5yb290KHByb3ApIDogcHJvcDtcbiAgICBsZXQgZnhzID0gZWZmZWN0c1tyb290UHJvcGVydHldO1xuICAgIGlmIChmeHMpIHtcbiAgICAgIGZvciAobGV0IGk9MCwgbD1meHMubGVuZ3RoLCBmeDsgKGk8bCkgJiYgKGZ4PWZ4c1tpXSk7IGkrKykge1xuICAgICAgICBpZiAoKCFmeC5pbmZvIHx8IGZ4LmluZm8ubGFzdFJ1biAhPT0gZGVkdXBlSWQpICYmXG4gICAgICAgICAgICAoIWhhc1BhdGhzIHx8IHBhdGhNYXRjaGVzVHJpZ2dlcihwcm9wLCBmeC50cmlnZ2VyKSkpIHtcbiAgICAgICAgICBpZiAoZnguaW5mbykge1xuICAgICAgICAgICAgZnguaW5mby5sYXN0UnVuID0gZGVkdXBlSWQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ4LmZuKGluc3QsIHByb3AsIHByb3BzLCBvbGRQcm9wcywgZnguaW5mbywgaGFzUGF0aHMsIGV4dHJhQXJncyk7XG4gICAgICAgICAgcmFuID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmFuO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZXMgd2hldGhlciBhIHByb3BlcnR5L3BhdGggdGhhdCBoYXMgY2hhbmdlZCBtYXRjaGVzIHRoZSB0cmlnZ2VyXG4gICAqIGNyaXRlcmlhIGZvciBhbiBlZmZlY3QuICBBIHRyaWdnZXIgaXMgYSBkZXNjcmlwdG9yIHdpdGggdGhlIGZvbGxvd2luZ1xuICAgKiBzdHJ1Y3R1cmUsIHdoaWNoIG1hdGNoZXMgdGhlIGRlc2NyaXB0b3JzIHJldHVybmVkIGZyb20gYHBhcnNlQXJnYC5cbiAgICogZS5nLiBmb3IgYGZvby5iYXIuKmA6XG4gICAqIGBgYFxuICAgKiB0cmlnZ2VyOiB7XG4gICAqICAgbmFtZTogJ2EuYicsXG4gICAqICAgc3RydWN0dXJlZDogdHJ1ZSxcbiAgICogICB3aWxkY2FyZDogdHJ1ZVxuICAgKiB9XG4gICAqIGBgYFxuICAgKiBJZiBubyB0cmlnZ2VyIGlzIGdpdmVuLCB0aGUgcGF0aCBpcyBkZWVtZWQgdG8gbWF0Y2guXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFBhdGggb3IgcHJvcGVydHkgdGhhdCBjaGFuZ2VkXG4gICAqIEBwYXJhbSB7RGF0YVRyaWdnZXJ9IHRyaWdnZXIgRGVzY3JpcHRvclxuICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBwYXRoIG1hdGNoZWQgdGhlIHRyaWdnZXJcbiAgICovXG4gIGZ1bmN0aW9uIHBhdGhNYXRjaGVzVHJpZ2dlcihwYXRoLCB0cmlnZ2VyKSB7XG4gICAgaWYgKHRyaWdnZXIpIHtcbiAgICAgIGxldCB0cmlnZ2VyUGF0aCA9IHRyaWdnZXIubmFtZTtcbiAgICAgIHJldHVybiAodHJpZ2dlclBhdGggPT0gcGF0aCkgfHxcbiAgICAgICAgKHRyaWdnZXIuc3RydWN0dXJlZCAmJiBQb2x5bWVyLlBhdGguaXNBbmNlc3Rvcih0cmlnZ2VyUGF0aCwgcGF0aCkpIHx8XG4gICAgICAgICh0cmlnZ2VyLndpbGRjYXJkICYmIFBvbHltZXIuUGF0aC5pc0Rlc2NlbmRhbnQodHJpZ2dlclBhdGgsIHBhdGgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEltcGxlbWVudHMgdGhlIFwib2JzZXJ2ZXJcIiBlZmZlY3QuXG4gICAqXG4gICAqIENhbGxzIHRoZSBtZXRob2Qgd2l0aCBgaW5mby5tZXRob2ROYW1lYCBvbiB0aGUgaW5zdGFuY2UsIHBhc3NpbmcgdGhlXG4gICAqIG5ldyBhbmQgb2xkIHZhbHVlcy5cbiAgICpcbiAgICogQHBhcmFtIHshUHJvcGVydHlFZmZlY3RzVHlwZX0gaW5zdCBUaGUgaW5zdGFuY2UgdGhlIGVmZmVjdCB3aWxsIGJlIHJ1biBvblxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgTmFtZSBvZiBwcm9wZXJ0eVxuICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgQmFnIG9mIGN1cnJlbnQgcHJvcGVydHkgY2hhbmdlc1xuICAgKiBAcGFyYW0ge09iamVjdH0gb2xkUHJvcHMgQmFnIG9mIHByZXZpb3VzIHZhbHVlcyBmb3IgY2hhbmdlZCBwcm9wZXJ0aWVzXG4gICAqIEBwYXJhbSB7P30gaW5mbyBFZmZlY3QgbWV0YWRhdGFcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIHJ1bk9ic2VydmVyRWZmZWN0KGluc3QsIHByb3BlcnR5LCBwcm9wcywgb2xkUHJvcHMsIGluZm8pIHtcbiAgICBsZXQgZm4gPSBpbnN0W2luZm8ubWV0aG9kTmFtZV07XG4gICAgbGV0IGNoYW5nZWRQcm9wID0gaW5mby5wcm9wZXJ0eTtcbiAgICBpZiAoZm4pIHtcbiAgICAgIGZuLmNhbGwoaW5zdCwgaW5zdC5fX2RhdGFbY2hhbmdlZFByb3BdLCBvbGRQcm9wc1tjaGFuZ2VkUHJvcF0pO1xuICAgIH0gZWxzZSBpZiAoIWluZm8uZHluYW1pY0ZuKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ29ic2VydmVyIG1ldGhvZCBgJyArIGluZm8ubWV0aG9kTmFtZSArICdgIG5vdCBkZWZpbmVkJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJ1bnMgXCJub3RpZnlcIiBlZmZlY3RzIGZvciBhIHNldCBvZiBjaGFuZ2VkIHByb3BlcnRpZXMuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGRpZmZlcnMgZnJvbSB0aGUgZ2VuZXJpYyBgcnVuRWZmZWN0c2AgbWV0aG9kIGluIHRoYXQgaXRcbiAgICogd2lsbCBkaXNwYXRjaCBwYXRoIG5vdGlmaWNhdGlvbiBldmVudHMgaW4gdGhlIGNhc2UgdGhhdCB0aGUgcHJvcGVydHlcbiAgICogY2hhbmdlZCB3YXMgYSBwYXRoIGFuZCB0aGUgcm9vdCBwcm9wZXJ0eSBmb3IgdGhhdCBwYXRoIGRpZG4ndCBoYXZlIGFcbiAgICogXCJub3RpZnlcIiBlZmZlY3QuICBUaGlzIGlzIHRvIG1haW50YWluIDEuMCBiZWhhdmlvciB0aGF0IGRpZCBub3QgcmVxdWlyZVxuICAgKiBgbm90aWZ5OiB0cnVlYCB0byBlbnN1cmUgb2JqZWN0IHN1Yi1wcm9wZXJ0eSBub3RpZmljYXRpb25zIHdlcmVcbiAgICogc2VudC5cbiAgICpcbiAgICogQHBhcmFtIHshUHJvcGVydHlFZmZlY3RzVHlwZX0gaW5zdCBUaGUgaW5zdGFuY2Ugd2l0aCBlZmZlY3RzIHRvIHJ1blxuICAgKiBAcGFyYW0ge09iamVjdH0gbm90aWZ5UHJvcHMgQmFnIG9mIHByb3BlcnRpZXMgdG8gbm90aWZ5XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBCYWcgb2YgY3VycmVudCBwcm9wZXJ0eSBjaGFuZ2VzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvbGRQcm9wcyBCYWcgb2YgcHJldmlvdXMgdmFsdWVzIGZvciBjaGFuZ2VkIHByb3BlcnRpZXNcbiAgICogQHBhcmFtIHtib29sZWFufSBoYXNQYXRocyBUcnVlIHdpdGggYHByb3BzYCBjb250YWlucyBvbmUgb3IgbW9yZSBwYXRoc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gcnVuTm90aWZ5RWZmZWN0cyhpbnN0LCBub3RpZnlQcm9wcywgcHJvcHMsIG9sZFByb3BzLCBoYXNQYXRocykge1xuICAgIC8vIE5vdGlmeVxuICAgIGxldCBmeHMgPSBpbnN0W1RZUEVTLk5PVElGWV07XG4gICAgbGV0IG5vdGlmaWVkO1xuICAgIGxldCBpZCA9IGRlZHVwZUlkKys7XG4gICAgLy8gVHJ5IG5vcm1hbCBub3RpZnkgZWZmZWN0czsgaWYgbm9uZSwgZmFsbCBiYWNrIHRvIHRyeSBwYXRoIG5vdGlmaWNhdGlvblxuICAgIGZvciAobGV0IHByb3AgaW4gbm90aWZ5UHJvcHMpIHtcbiAgICAgIGlmIChub3RpZnlQcm9wc1twcm9wXSkge1xuICAgICAgICBpZiAoZnhzICYmIHJ1bkVmZmVjdHNGb3JQcm9wZXJ0eShpbnN0LCBmeHMsIGlkLCBwcm9wLCBwcm9wcywgb2xkUHJvcHMsIGhhc1BhdGhzKSkge1xuICAgICAgICAgIG5vdGlmaWVkID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChoYXNQYXRocyAmJiBub3RpZnlQYXRoKGluc3QsIHByb3AsIHByb3BzKSkge1xuICAgICAgICAgIG5vdGlmaWVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBGbHVzaCBob3N0IGlmIHdlIGFjdHVhbGx5IG5vdGlmaWVkIGFuZCBob3N0IHdhcyBiYXRjaGluZ1xuICAgIC8vIEFuZCB0aGUgaG9zdCBoYXMgYWxyZWFkeSBpbml0aWFsaXplZCBjbGllbnRzOyB0aGlzIHByZXZlbnRzXG4gICAgLy8gYW4gaXNzdWUgd2l0aCBhIGhvc3Qgb2JzZXJ2aW5nIGRhdGEgY2hhbmdlcyBiZWZvcmUgY2xpZW50cyBhcmUgcmVhZHkuXG4gICAgbGV0IGhvc3Q7XG4gICAgaWYgKG5vdGlmaWVkICYmIChob3N0ID0gaW5zdC5fX2RhdGFIb3N0KSAmJiBob3N0Ll9pbnZhbGlkYXRlUHJvcGVydGllcykge1xuICAgICAgaG9zdC5faW52YWxpZGF0ZVByb3BlcnRpZXMoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGlzcGF0Y2hlcyB7cHJvcGVydHl9LWNoYW5nZWQgZXZlbnRzIHdpdGggcGF0aCBpbmZvcm1hdGlvbiBpbiB0aGUgZGV0YWlsXG4gICAqIG9iamVjdCB0byBpbmRpY2F0ZSBhIHN1Yi1wYXRoIG9mIHRoZSBwcm9wZXJ0eSB3YXMgY2hhbmdlZC5cbiAgICpcbiAgICogQHBhcmFtIHshUHJvcGVydHlFZmZlY3RzVHlwZX0gaW5zdCBUaGUgZWxlbWVudCBmcm9tIHdoaWNoIHRvIGZpcmUgdGhlIGV2ZW50XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRoYXQgd2FzIGNoYW5nZWRcbiAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzIEJhZyBvZiBjdXJyZW50IHByb3BlcnR5IGNoYW5nZXNcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZSBwYXRoIHdhcyBub3RpZmllZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gbm90aWZ5UGF0aChpbnN0LCBwYXRoLCBwcm9wcykge1xuICAgIGxldCByb290UHJvcGVydHkgPSBQb2x5bWVyLlBhdGgucm9vdChwYXRoKTtcbiAgICBpZiAocm9vdFByb3BlcnR5ICE9PSBwYXRoKSB7XG4gICAgICBsZXQgZXZlbnROYW1lID0gUG9seW1lci5DYXNlTWFwLmNhbWVsVG9EYXNoQ2FzZShyb290UHJvcGVydHkpICsgJy1jaGFuZ2VkJztcbiAgICAgIGRpc3BhdGNoTm90aWZ5RXZlbnQoaW5zdCwgZXZlbnROYW1lLCBwcm9wc1twYXRoXSwgcGF0aCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIERpc3BhdGNoZXMge3Byb3BlcnR5fS1jaGFuZ2VkIGV2ZW50cyB0byBpbmRpY2F0ZSBhIHByb3BlcnR5IChvciBwYXRoKVxuICAgKiBjaGFuZ2VkLlxuICAgKlxuICAgKiBAcGFyYW0geyFQcm9wZXJ0eUVmZmVjdHNUeXBlfSBpbnN0IFRoZSBlbGVtZW50IGZyb20gd2hpY2ggdG8gZmlyZSB0aGUgZXZlbnRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gc2VuZCAoJ3twcm9wZXJ0eX0tY2hhbmdlZCcpXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIG9mIHRoZSBjaGFuZ2VkIHByb3BlcnR5XG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZH0gcGF0aCBJZiBhIHN1Yi1wYXRoIG9mIHRoaXMgcHJvcGVydHkgY2hhbmdlZCwgdGhlIHBhdGhcbiAgICogICB0aGF0IGNoYW5nZWQgKG9wdGlvbmFsKS5cbiAgICogQHByaXZhdGVcbiAgICogQHN1cHByZXNzIHtpbnZhbGlkQ2FzdHN9XG4gICAqL1xuICBmdW5jdGlvbiBkaXNwYXRjaE5vdGlmeUV2ZW50KGluc3QsIGV2ZW50TmFtZSwgdmFsdWUsIHBhdGgpIHtcbiAgICBsZXQgZGV0YWlsID0ge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgcXVldWVQcm9wZXJ0eTogdHJ1ZVxuICAgIH07XG4gICAgaWYgKHBhdGgpIHtcbiAgICAgIGRldGFpbC5wYXRoID0gcGF0aDtcbiAgICB9XG4gICAgLyoqIEB0eXBlIHshSFRNTEVsZW1lbnR9ICovKGluc3QpLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KGV2ZW50TmFtZSwgeyBkZXRhaWwgfSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEltcGxlbWVudHMgdGhlIFwibm90aWZ5XCIgZWZmZWN0LlxuICAgKlxuICAgKiBEaXNwYXRjaGVzIGEgbm9uLWJ1YmJsaW5nIGV2ZW50IG5hbWVkIGBpbmZvLmV2ZW50TmFtZWAgb24gdGhlIGluc3RhbmNlXG4gICAqIHdpdGggYSBkZXRhaWwgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG5ldyBgdmFsdWVgLlxuICAgKlxuICAgKiBAcGFyYW0geyFQcm9wZXJ0eUVmZmVjdHNUeXBlfSBpbnN0IFRoZSBpbnN0YW5jZSB0aGUgZWZmZWN0IHdpbGwgYmUgcnVuIG9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBOYW1lIG9mIHByb3BlcnR5XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBCYWcgb2YgY3VycmVudCBwcm9wZXJ0eSBjaGFuZ2VzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvbGRQcm9wcyBCYWcgb2YgcHJldmlvdXMgdmFsdWVzIGZvciBjaGFuZ2VkIHByb3BlcnRpZXNcbiAgICogQHBhcmFtIHs/fSBpbmZvIEVmZmVjdCBtZXRhZGF0YVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhhc1BhdGhzIFRydWUgd2l0aCBgcHJvcHNgIGNvbnRhaW5zIG9uZSBvciBtb3JlIHBhdGhzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBydW5Ob3RpZnlFZmZlY3QoaW5zdCwgcHJvcGVydHksIHByb3BzLCBvbGRQcm9wcywgaW5mbywgaGFzUGF0aHMpIHtcbiAgICBsZXQgcm9vdFByb3BlcnR5ID0gaGFzUGF0aHMgPyBQb2x5bWVyLlBhdGgucm9vdChwcm9wZXJ0eSkgOiBwcm9wZXJ0eTtcbiAgICBsZXQgcGF0aCA9IHJvb3RQcm9wZXJ0eSAhPSBwcm9wZXJ0eSA/IHByb3BlcnR5IDogbnVsbDtcbiAgICBsZXQgdmFsdWUgPSBwYXRoID8gUG9seW1lci5QYXRoLmdldChpbnN0LCBwYXRoKSA6IGluc3QuX19kYXRhW3Byb3BlcnR5XTtcbiAgICBpZiAocGF0aCAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YWx1ZSA9IHByb3BzW3Byb3BlcnR5XTsgIC8vIHNwZWNpZmljYWxseSBmb3IgLnNwbGljZXNcbiAgICB9XG4gICAgZGlzcGF0Y2hOb3RpZnlFdmVudChpbnN0LCBpbmZvLmV2ZW50TmFtZSwgdmFsdWUsIHBhdGgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXIgZnVuY3Rpb24gZm9yIDItd2F5IG5vdGlmaWNhdGlvbiBldmVudHMuIFJlY2VpdmVzIGNvbnRleHRcbiAgICogaW5mb3JtYXRpb24gY2FwdHVyZWQgaW4gdGhlIGBhZGROb3RpZnlMaXN0ZW5lcmAgY2xvc3VyZSBmcm9tIHRoZVxuICAgKiBgX19ub3RpZnlMaXN0ZW5lcnNgIG1ldGFkYXRhLlxuICAgKlxuICAgKiBTZXRzIHRoZSB2YWx1ZSBvZiB0aGUgbm90aWZpZWQgcHJvcGVydHkgdG8gdGhlIGhvc3QgcHJvcGVydHkgb3IgcGF0aC4gIElmXG4gICAqIHRoZSBldmVudCBjb250YWluZWQgcGF0aCBpbmZvcm1hdGlvbiwgdHJhbnNsYXRlIHRoYXQgcGF0aCB0byB0aGUgaG9zdFxuICAgKiBzY29wZSdzIG5hbWUgZm9yIHRoYXQgcGF0aCBmaXJzdC5cbiAgICpcbiAgICogQHBhcmFtIHtDdXN0b21FdmVudH0gZXZlbnQgTm90aWZpY2F0aW9uIGV2ZW50IChlLmcuICc8cHJvcGVydHk+LWNoYW5nZWQnKVxuICAgKiBAcGFyYW0geyFQcm9wZXJ0eUVmZmVjdHNUeXBlfSBpbnN0IEhvc3QgZWxlbWVudCBpbnN0YW5jZSBoYW5kbGluZyB0aGUgbm90aWZpY2F0aW9uIGV2ZW50XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmcm9tUHJvcCBDaGlsZCBlbGVtZW50IHByb3BlcnR5IHRoYXQgd2FzIGJvdW5kXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b1BhdGggSG9zdCBwcm9wZXJ0eS9wYXRoIHRoYXQgd2FzIGJvdW5kXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gbmVnYXRlIFdoZXRoZXIgdGhlIGJpbmRpbmcgd2FzIG5lZ2F0ZWRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIGhhbmRsZU5vdGlmaWNhdGlvbihldmVudCwgaW5zdCwgZnJvbVByb3AsIHRvUGF0aCwgbmVnYXRlKSB7XG4gICAgbGV0IHZhbHVlO1xuICAgIGxldCBkZXRhaWwgPSAvKiogQHR5cGUge09iamVjdH0gKi8oZXZlbnQuZGV0YWlsKTtcbiAgICBsZXQgZnJvbVBhdGggPSBkZXRhaWwgJiYgZGV0YWlsLnBhdGg7XG4gICAgaWYgKGZyb21QYXRoKSB7XG4gICAgICB0b1BhdGggPSBQb2x5bWVyLlBhdGgudHJhbnNsYXRlKGZyb21Qcm9wLCB0b1BhdGgsIGZyb21QYXRoKTtcbiAgICAgIHZhbHVlID0gZGV0YWlsICYmIGRldGFpbC52YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgPSBldmVudC50YXJnZXRbZnJvbVByb3BdO1xuICAgIH1cbiAgICB2YWx1ZSA9IG5lZ2F0ZSA/ICF2YWx1ZSA6IHZhbHVlO1xuICAgIGlmICghaW5zdFtUWVBFUy5SRUFEX09OTFldIHx8ICFpbnN0W1RZUEVTLlJFQURfT05MWV1bdG9QYXRoXSkge1xuICAgICAgaWYgKGluc3QuX3NldFBlbmRpbmdQcm9wZXJ0eU9yUGF0aCh0b1BhdGgsIHZhbHVlLCB0cnVlLCBCb29sZWFuKGZyb21QYXRoKSlcbiAgICAgICAgJiYgKCFkZXRhaWwgfHwgIWRldGFpbC5xdWV1ZVByb3BlcnR5KSkge1xuICAgICAgICBpbnN0Ll9pbnZhbGlkYXRlUHJvcGVydGllcygpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbXBsZW1lbnRzIHRoZSBcInJlZmxlY3RcIiBlZmZlY3QuXG4gICAqXG4gICAqIFNldHMgdGhlIGF0dHJpYnV0ZSBuYW1lZCBgaW5mby5hdHRyTmFtZWAgdG8gdGhlIGdpdmVuIHByb3BlcnR5IHZhbHVlLlxuICAgKlxuICAgKiBAcGFyYW0geyFQcm9wZXJ0eUVmZmVjdHNUeXBlfSBpbnN0IFRoZSBpbnN0YW5jZSB0aGUgZWZmZWN0IHdpbGwgYmUgcnVuIG9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBOYW1lIG9mIHByb3BlcnR5XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBCYWcgb2YgY3VycmVudCBwcm9wZXJ0eSBjaGFuZ2VzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvbGRQcm9wcyBCYWcgb2YgcHJldmlvdXMgdmFsdWVzIGZvciBjaGFuZ2VkIHByb3BlcnRpZXNcbiAgICogQHBhcmFtIHs/fSBpbmZvIEVmZmVjdCBtZXRhZGF0YVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gcnVuUmVmbGVjdEVmZmVjdChpbnN0LCBwcm9wZXJ0eSwgcHJvcHMsIG9sZFByb3BzLCBpbmZvKSB7XG4gICAgbGV0IHZhbHVlID0gaW5zdC5fX2RhdGFbcHJvcGVydHldO1xuICAgIGlmIChQb2x5bWVyLnNhbml0aXplRE9NVmFsdWUpIHtcbiAgICAgIHZhbHVlID0gUG9seW1lci5zYW5pdGl6ZURPTVZhbHVlKHZhbHVlLCBpbmZvLmF0dHJOYW1lLCAnYXR0cmlidXRlJywgLyoqIEB0eXBlIHtOb2RlfSAqLyhpbnN0KSk7XG4gICAgfVxuICAgIGluc3QuX3Byb3BlcnR5VG9BdHRyaWJ1dGUocHJvcGVydHksIGluZm8uYXR0ck5hbWUsIHZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSdW5zIFwiY29tcHV0ZWRcIiBlZmZlY3RzIGZvciBhIHNldCBvZiBjaGFuZ2VkIHByb3BlcnRpZXMuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGRpZmZlcnMgZnJvbSB0aGUgZ2VuZXJpYyBgcnVuRWZmZWN0c2AgbWV0aG9kIGluIHRoYXQgaXRcbiAgICogY29udGludWVzIHRvIHJ1biBjb21wdXRlZCBlZmZlY3RzIGJhc2VkIG9uIHRoZSBvdXRwdXQgb2YgZWFjaCBwYXNzIHVudGlsXG4gICAqIHRoZXJlIGFyZSBubyBtb3JlIG5ld2x5IGNvbXB1dGVkIHByb3BlcnRpZXMuICBUaGlzIGVuc3VyZXMgdGhhdCBhbGxcbiAgICogcHJvcGVydGllcyB0aGF0IHdpbGwgYmUgY29tcHV0ZWQgYnkgdGhlIGluaXRpYWwgc2V0IG9mIGNoYW5nZXMgYXJlXG4gICAqIGNvbXB1dGVkIGJlZm9yZSBvdGhlciBlZmZlY3RzIChiaW5kaW5nIHByb3BhZ2F0aW9uLCBvYnNlcnZlcnMsIGFuZCBub3RpZnkpXG4gICAqIHJ1bi5cbiAgICpcbiAgICogQHBhcmFtIHshUHJvcGVydHlFZmZlY3RzVHlwZX0gaW5zdCBUaGUgaW5zdGFuY2UgdGhlIGVmZmVjdCB3aWxsIGJlIHJ1biBvblxuICAgKiBAcGFyYW0geyFPYmplY3R9IGNoYW5nZWRQcm9wcyBCYWcgb2YgY2hhbmdlZCBwcm9wZXJ0aWVzXG4gICAqIEBwYXJhbSB7IU9iamVjdH0gb2xkUHJvcHMgQmFnIG9mIHByZXZpb3VzIHZhbHVlcyBmb3IgY2hhbmdlZCBwcm9wZXJ0aWVzXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaGFzUGF0aHMgVHJ1ZSB3aXRoIGBwcm9wc2AgY29udGFpbnMgb25lIG9yIG1vcmUgcGF0aHNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIHJ1bkNvbXB1dGVkRWZmZWN0cyhpbnN0LCBjaGFuZ2VkUHJvcHMsIG9sZFByb3BzLCBoYXNQYXRocykge1xuICAgIGxldCBjb21wdXRlRWZmZWN0cyA9IGluc3RbVFlQRVMuQ09NUFVURV07XG4gICAgaWYgKGNvbXB1dGVFZmZlY3RzKSB7XG4gICAgICBsZXQgaW5wdXRQcm9wcyA9IGNoYW5nZWRQcm9wcztcbiAgICAgIHdoaWxlIChydW5FZmZlY3RzKGluc3QsIGNvbXB1dGVFZmZlY3RzLCBpbnB1dFByb3BzLCBvbGRQcm9wcywgaGFzUGF0aHMpKSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24ob2xkUHJvcHMsIGluc3QuX19kYXRhT2xkKTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihjaGFuZ2VkUHJvcHMsIGluc3QuX19kYXRhUGVuZGluZyk7XG4gICAgICAgIGlucHV0UHJvcHMgPSBpbnN0Ll9fZGF0YVBlbmRpbmc7XG4gICAgICAgIGluc3QuX19kYXRhUGVuZGluZyA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEltcGxlbWVudHMgdGhlIFwiY29tcHV0ZWQgcHJvcGVydHlcIiBlZmZlY3QgYnkgcnVubmluZyB0aGUgbWV0aG9kIHdpdGggdGhlXG4gICAqIHZhbHVlcyBvZiB0aGUgYXJndW1lbnRzIHNwZWNpZmllZCBpbiB0aGUgYGluZm9gIG9iamVjdCBhbmQgc2V0dGluZyB0aGVcbiAgICogcmV0dXJuIHZhbHVlIHRvIHRoZSBjb21wdXRlZCBwcm9wZXJ0eSBzcGVjaWZpZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7IVByb3BlcnR5RWZmZWN0c1R5cGV9IGluc3QgVGhlIGluc3RhbmNlIHRoZSBlZmZlY3Qgd2lsbCBiZSBydW4gb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IE5hbWUgb2YgcHJvcGVydHlcbiAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzIEJhZyBvZiBjdXJyZW50IHByb3BlcnR5IGNoYW5nZXNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9sZFByb3BzIEJhZyBvZiBwcmV2aW91cyB2YWx1ZXMgZm9yIGNoYW5nZWQgcHJvcGVydGllc1xuICAgKiBAcGFyYW0gez99IGluZm8gRWZmZWN0IG1ldGFkYXRhXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBydW5Db21wdXRlZEVmZmVjdChpbnN0LCBwcm9wZXJ0eSwgcHJvcHMsIG9sZFByb3BzLCBpbmZvKSB7XG4gICAgbGV0IHJlc3VsdCA9IHJ1bk1ldGhvZEVmZmVjdChpbnN0LCBwcm9wZXJ0eSwgcHJvcHMsIG9sZFByb3BzLCBpbmZvKTtcbiAgICBsZXQgY29tcHV0ZWRQcm9wID0gaW5mby5tZXRob2RJbmZvO1xuICAgIGlmIChpbnN0Ll9fZGF0YUhhc0FjY2Vzc29yICYmIGluc3QuX19kYXRhSGFzQWNjZXNzb3JbY29tcHV0ZWRQcm9wXSkge1xuICAgICAgaW5zdC5fc2V0UGVuZGluZ1Byb3BlcnR5KGNvbXB1dGVkUHJvcCwgcmVzdWx0LCB0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5zdFtjb21wdXRlZFByb3BdID0gcmVzdWx0O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wdXRlcyBwYXRoIGNoYW5nZXMgYmFzZWQgb24gcGF0aCBsaW5rcyBzZXQgdXAgdXNpbmcgdGhlIGBsaW5rUGF0aHNgXG4gICAqIEFQSS5cbiAgICpcbiAgICogQHBhcmFtIHshUHJvcGVydHlFZmZlY3RzVHlwZX0gaW5zdCBUaGUgaW5zdGFuY2Ugd2hvc2UgcHJvcHMgYXJlIGNoYW5naW5nXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgIUFycmF5PChzdHJpbmd8bnVtYmVyKT59IHBhdGggUGF0aCB0aGF0IGhhcyBjaGFuZ2VkXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgb2YgY2hhbmdlZCBwYXRoXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBjb21wdXRlTGlua2VkUGF0aHMoaW5zdCwgcGF0aCwgdmFsdWUpIHtcbiAgICBsZXQgbGlua3MgPSBpbnN0Ll9fZGF0YUxpbmtlZFBhdGhzO1xuICAgIGlmIChsaW5rcykge1xuICAgICAgbGV0IGxpbms7XG4gICAgICBmb3IgKGxldCBhIGluIGxpbmtzKSB7XG4gICAgICAgIGxldCBiID0gbGlua3NbYV07XG4gICAgICAgIGlmIChQb2x5bWVyLlBhdGguaXNEZXNjZW5kYW50KGEsIHBhdGgpKSB7XG4gICAgICAgICAgbGluayA9IFBvbHltZXIuUGF0aC50cmFuc2xhdGUoYSwgYiwgcGF0aCk7XG4gICAgICAgICAgaW5zdC5fc2V0UGVuZGluZ1Byb3BlcnR5T3JQYXRoKGxpbmssIHZhbHVlLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgfSBlbHNlIGlmIChQb2x5bWVyLlBhdGguaXNEZXNjZW5kYW50KGIsIHBhdGgpKSB7XG4gICAgICAgICAgbGluayA9IFBvbHltZXIuUGF0aC50cmFuc2xhdGUoYiwgYSwgcGF0aCk7XG4gICAgICAgICAgaW5zdC5fc2V0UGVuZGluZ1Byb3BlcnR5T3JQYXRoKGxpbmssIHZhbHVlLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIC0tIGJpbmRpbmdzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvKipcbiAgICogQWRkcyBiaW5kaW5nIG1ldGFkYXRhIHRvIHRoZSBjdXJyZW50IGBub2RlSW5mb2AsIGFuZCBiaW5kaW5nIGVmZmVjdHNcbiAgICogZm9yIGFsbCBwYXJ0IGRlcGVuZGVuY2llcyB0byBgdGVtcGxhdGVJbmZvYC5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY29uc3RydWN0b3IgQ2xhc3MgdGhhdCBgX3BhcnNlVGVtcGxhdGVgIGlzIGN1cnJlbnRseVxuICAgKiAgIHJ1bm5pbmcgb25cbiAgICogQHBhcmFtIHtUZW1wbGF0ZUluZm99IHRlbXBsYXRlSW5mbyBUZW1wbGF0ZSBtZXRhZGF0YSBmb3IgY3VycmVudCB0ZW1wbGF0ZVxuICAgKiBAcGFyYW0ge05vZGVJbmZvfSBub2RlSW5mbyBOb2RlIG1ldGFkYXRhIGZvciBjdXJyZW50IHRlbXBsYXRlIG5vZGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtpbmQgQmluZGluZyBraW5kLCBlaXRoZXIgJ3Byb3BlcnR5JywgJ2F0dHJpYnV0ZScsIG9yICd0ZXh0J1xuICAgKiBAcGFyYW0ge3N0cmluZ30gdGFyZ2V0IFRhcmdldCBwcm9wZXJ0eSBuYW1lXG4gICAqIEBwYXJhbSB7IUFycmF5PCFCaW5kaW5nUGFydD59IHBhcnRzIEFycmF5IG9mIGJpbmRpbmcgcGFydCBtZXRhZGF0YVxuICAgKiBAcGFyYW0ge3N0cmluZz19IGxpdGVyYWwgTGl0ZXJhbCB0ZXh0IHN1cnJvdW5kaW5nIGJpbmRpbmcgcGFydHMgKHNwZWNpZmllZFxuICAgKiAgIG9ubHkgZm9yICdwcm9wZXJ0eScgYmluZGluZ3MsIHNpbmNlIHRoZXNlIG11c3QgYmUgaW5pdGlhbGl6ZWQgYXMgcGFydFxuICAgKiAgIG9mIGJvb3QtdXApXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBhZGRCaW5kaW5nKGNvbnN0cnVjdG9yLCB0ZW1wbGF0ZUluZm8sIG5vZGVJbmZvLCBraW5kLCB0YXJnZXQsIHBhcnRzLCBsaXRlcmFsKSB7XG4gICAgLy8gQ3JlYXRlIGJpbmRpbmcgbWV0YWRhdGEgYW5kIGFkZCB0byBub2RlSW5mb1xuICAgIG5vZGVJbmZvLmJpbmRpbmdzID0gbm9kZUluZm8uYmluZGluZ3MgfHwgW107XG4gICAgbGV0IC8qKiBCaW5kaW5nICovIGJpbmRpbmcgPSB7IGtpbmQsIHRhcmdldCwgcGFydHMsIGxpdGVyYWwsIGlzQ29tcG91bmQ6IChwYXJ0cy5sZW5ndGggIT09IDEpIH07XG4gICAgbm9kZUluZm8uYmluZGluZ3MucHVzaChiaW5kaW5nKTtcbiAgICAvLyBBZGQgbGlzdGVuZXIgaW5mbyB0byBiaW5kaW5nIG1ldGFkYXRhXG4gICAgaWYgKHNob3VsZEFkZExpc3RlbmVyKGJpbmRpbmcpKSB7XG4gICAgICBsZXQge2V2ZW50LCBuZWdhdGV9ID0gYmluZGluZy5wYXJ0c1swXTtcbiAgICAgIGJpbmRpbmcubGlzdGVuZXJFdmVudCA9IGV2ZW50IHx8IChDYXNlTWFwLmNhbWVsVG9EYXNoQ2FzZSh0YXJnZXQpICsgJy1jaGFuZ2VkJyk7XG4gICAgICBiaW5kaW5nLmxpc3RlbmVyTmVnYXRlID0gbmVnYXRlO1xuICAgIH1cbiAgICAvLyBBZGQgXCJwcm9wYWdhdGVcIiBwcm9wZXJ0eSBlZmZlY3RzIHRvIHRlbXBsYXRlSW5mb1xuICAgIGxldCBpbmRleCA9IHRlbXBsYXRlSW5mby5ub2RlSW5mb0xpc3QubGVuZ3RoO1xuICAgIGZvciAobGV0IGk9MDsgaTxiaW5kaW5nLnBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgcGFydCA9IGJpbmRpbmcucGFydHNbaV07XG4gICAgICBwYXJ0LmNvbXBvdW5kSW5kZXggPSBpO1xuICAgICAgYWRkRWZmZWN0Rm9yQmluZGluZ1BhcnQoY29uc3RydWN0b3IsIHRlbXBsYXRlSW5mbywgYmluZGluZywgcGFydCwgaW5kZXgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIHByb3BlcnR5IGVmZmVjdHMgdG8gdGhlIGdpdmVuIGB0ZW1wbGF0ZUluZm9gIGZvciB0aGUgZ2l2ZW4gYmluZGluZ1xuICAgKiBwYXJ0LlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb25zdHJ1Y3RvciBDbGFzcyB0aGF0IGBfcGFyc2VUZW1wbGF0ZWAgaXMgY3VycmVudGx5XG4gICAqICAgcnVubmluZyBvblxuICAgKiBAcGFyYW0ge1RlbXBsYXRlSW5mb30gdGVtcGxhdGVJbmZvIFRlbXBsYXRlIG1ldGFkYXRhIGZvciBjdXJyZW50IHRlbXBsYXRlXG4gICAqIEBwYXJhbSB7IUJpbmRpbmd9IGJpbmRpbmcgQmluZGluZyBtZXRhZGF0YVxuICAgKiBAcGFyYW0geyFCaW5kaW5nUGFydH0gcGFydCBCaW5kaW5nIHBhcnQgbWV0YWRhdGFcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IEluZGV4IGludG8gYG5vZGVJbmZvTGlzdGAgZm9yIHRoaXMgbm9kZVxuICAgKi9cbiAgZnVuY3Rpb24gYWRkRWZmZWN0Rm9yQmluZGluZ1BhcnQoY29uc3RydWN0b3IsIHRlbXBsYXRlSW5mbywgYmluZGluZywgcGFydCwgaW5kZXgpIHtcbiAgICBpZiAoIXBhcnQubGl0ZXJhbCkge1xuICAgICAgaWYgKGJpbmRpbmcua2luZCA9PT0gJ2F0dHJpYnV0ZScgJiYgYmluZGluZy50YXJnZXRbMF0gPT09ICctJykge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0Nhbm5vdCBzZXQgYXR0cmlidXRlICcgKyBiaW5kaW5nLnRhcmdldCArXG4gICAgICAgICAgJyBiZWNhdXNlIFwiLVwiIGlzIG5vdCBhIHZhbGlkIGF0dHJpYnV0ZSBzdGFydGluZyBjaGFyYWN0ZXInKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBkZXBlbmRlbmNpZXMgPSBwYXJ0LmRlcGVuZGVuY2llcztcbiAgICAgICAgbGV0IGluZm8gPSB7IGluZGV4LCBiaW5kaW5nLCBwYXJ0LCBldmFsdWF0b3I6IGNvbnN0cnVjdG9yIH07XG4gICAgICAgIGZvciAobGV0IGo9MDsgajxkZXBlbmRlbmNpZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBsZXQgdHJpZ2dlciA9IGRlcGVuZGVuY2llc1tqXTtcbiAgICAgICAgICBpZiAodHlwZW9mIHRyaWdnZXIgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRyaWdnZXIgPSBwYXJzZUFyZyh0cmlnZ2VyKTtcbiAgICAgICAgICAgIHRyaWdnZXIud2lsZGNhcmQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdHJ1Y3Rvci5fYWRkVGVtcGxhdGVQcm9wZXJ0eUVmZmVjdCh0ZW1wbGF0ZUluZm8sIHRyaWdnZXIucm9vdFByb3BlcnR5LCB7XG4gICAgICAgICAgICBmbjogcnVuQmluZGluZ0VmZmVjdCxcbiAgICAgICAgICAgIGluZm8sIHRyaWdnZXJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbXBsZW1lbnRzIHRoZSBcImJpbmRpbmdcIiAocHJvcGVydHkvcGF0aCBiaW5kaW5nKSBlZmZlY3QuXG4gICAqXG4gICAqIE5vdGUgdGhhdCBiaW5kaW5nIHN5bnRheCBpcyBvdmVycmlkYWJsZSB2aWEgYF9wYXJzZUJpbmRpbmdzYCBhbmRcbiAgICogYF9ldmFsdWF0ZUJpbmRpbmdgLiAgVGhpcyBtZXRob2Qgd2lsbCBjYWxsIGBfZXZhbHVhdGVCaW5kaW5nYCBmb3IgYW55XG4gICAqIG5vbi1saXRlcmFsIHBhcnRzIHJldHVybmVkIGZyb20gYF9wYXJzZUJpbmRpbmdzYC4gIEhvd2V2ZXIsXG4gICAqIHRoZXJlIGlzIG5vIHN1cHBvcnQgZm9yIF9wYXRoXyBiaW5kaW5ncyB2aWEgY3VzdG9tIGJpbmRpbmcgcGFydHMsXG4gICAqIGFzIHRoaXMgaXMgc3BlY2lmaWMgdG8gUG9seW1lcidzIHBhdGggYmluZGluZyBzeW50YXguXG4gICAqXG4gICAqIEBwYXJhbSB7IVByb3BlcnR5RWZmZWN0c1R5cGV9IGluc3QgVGhlIGluc3RhbmNlIHRoZSBlZmZlY3Qgd2lsbCBiZSBydW4gb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggTmFtZSBvZiBwcm9wZXJ0eVxuICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgQmFnIG9mIGN1cnJlbnQgcHJvcGVydHkgY2hhbmdlc1xuICAgKiBAcGFyYW0ge09iamVjdH0gb2xkUHJvcHMgQmFnIG9mIHByZXZpb3VzIHZhbHVlcyBmb3IgY2hhbmdlZCBwcm9wZXJ0aWVzXG4gICAqIEBwYXJhbSB7P30gaW5mbyBFZmZlY3QgbWV0YWRhdGFcbiAgICogQHBhcmFtIHtib29sZWFufSBoYXNQYXRocyBUcnVlIHdpdGggYHByb3BzYCBjb250YWlucyBvbmUgb3IgbW9yZSBwYXRoc1xuICAgKiBAcGFyYW0ge0FycmF5fSBub2RlTGlzdCBMaXN0IG9mIG5vZGVzIGFzc29jaWF0ZWQgd2l0aCBgbm9kZUluZm9MaXN0YCB0ZW1wbGF0ZVxuICAgKiAgIG1ldGFkYXRhXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBydW5CaW5kaW5nRWZmZWN0KGluc3QsIHBhdGgsIHByb3BzLCBvbGRQcm9wcywgaW5mbywgaGFzUGF0aHMsIG5vZGVMaXN0KSB7XG4gICAgbGV0IG5vZGUgPSBub2RlTGlzdFtpbmZvLmluZGV4XTtcbiAgICBsZXQgYmluZGluZyA9IGluZm8uYmluZGluZztcbiAgICBsZXQgcGFydCA9IGluZm8ucGFydDtcbiAgICAvLyBTdWJwYXRoIG5vdGlmaWNhdGlvbjogdHJhbnNmb3JtIHBhdGggYW5kIHNldCB0byBjbGllbnRcbiAgICAvLyBlLmcuOiBmb289XCJ7e29iai5zdWJ9fVwiLCBwYXRoOiAnb2JqLnN1Yi5wcm9wJywgc2V0ICdmb28ucHJvcCc9b2JqLnN1Yi5wcm9wXG4gICAgaWYgKGhhc1BhdGhzICYmIHBhcnQuc291cmNlICYmIChwYXRoLmxlbmd0aCA+IHBhcnQuc291cmNlLmxlbmd0aCkgJiZcbiAgICAgICAgKGJpbmRpbmcua2luZCA9PSAncHJvcGVydHknKSAmJiAhYmluZGluZy5pc0NvbXBvdW5kICYmXG4gICAgICAgIG5vZGUuX19kYXRhSGFzQWNjZXNzb3IgJiYgbm9kZS5fX2RhdGFIYXNBY2Nlc3NvcltiaW5kaW5nLnRhcmdldF0pIHtcbiAgICAgIGxldCB2YWx1ZSA9IHByb3BzW3BhdGhdO1xuICAgICAgcGF0aCA9IFBvbHltZXIuUGF0aC50cmFuc2xhdGUocGFydC5zb3VyY2UsIGJpbmRpbmcudGFyZ2V0LCBwYXRoKTtcbiAgICAgIGlmIChub2RlLl9zZXRQZW5kaW5nUHJvcGVydHlPclBhdGgocGF0aCwgdmFsdWUsIGZhbHNlLCB0cnVlKSkge1xuICAgICAgICBpbnN0Ll9lbnF1ZXVlQ2xpZW50KG5vZGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgdmFsdWUgPSBpbmZvLmV2YWx1YXRvci5fZXZhbHVhdGVCaW5kaW5nKGluc3QsIHBhcnQsIHBhdGgsIHByb3BzLCBvbGRQcm9wcywgaGFzUGF0aHMpO1xuICAgICAgLy8gUHJvcGFnYXRlIHZhbHVlIHRvIGNoaWxkXG4gICAgICBhcHBseUJpbmRpbmdWYWx1ZShpbnN0LCBub2RlLCBiaW5kaW5nLCBwYXJ0LCB2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHZhbHVlIGZvciBhbiBcImJpbmRpbmdcIiAoYmluZGluZykgZWZmZWN0IHRvIGEgbm9kZSxcbiAgICogZWl0aGVyIGFzIGEgcHJvcGVydHkgb3IgYXR0cmlidXRlLlxuICAgKlxuICAgKiBAcGFyYW0geyFQcm9wZXJ0eUVmZmVjdHNUeXBlfSBpbnN0IFRoZSBpbnN0YW5jZSBvd25pbmcgdGhlIGJpbmRpbmcgZWZmZWN0XG4gICAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBUYXJnZXQgbm9kZSBmb3IgYmluZGluZ1xuICAgKiBAcGFyYW0geyFCaW5kaW5nfSBiaW5kaW5nIEJpbmRpbmcgbWV0YWRhdGFcbiAgICogQHBhcmFtIHshQmluZGluZ1BhcnR9IHBhcnQgQmluZGluZyBwYXJ0IG1ldGFkYXRhXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgdG8gc2V0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBhcHBseUJpbmRpbmdWYWx1ZShpbnN0LCBub2RlLCBiaW5kaW5nLCBwYXJ0LCB2YWx1ZSkge1xuICAgIHZhbHVlID0gY29tcHV0ZUJpbmRpbmdWYWx1ZShub2RlLCB2YWx1ZSwgYmluZGluZywgcGFydCk7XG4gICAgaWYgKFBvbHltZXIuc2FuaXRpemVET01WYWx1ZSkge1xuICAgICAgdmFsdWUgPSBQb2x5bWVyLnNhbml0aXplRE9NVmFsdWUodmFsdWUsIGJpbmRpbmcudGFyZ2V0LCBiaW5kaW5nLmtpbmQsIG5vZGUpO1xuICAgIH1cbiAgICBpZiAoYmluZGluZy5raW5kID09ICdhdHRyaWJ1dGUnKSB7XG4gICAgICAvLyBBdHRyaWJ1dGUgYmluZGluZ1xuICAgICAgaW5zdC5fdmFsdWVUb05vZGVBdHRyaWJ1dGUoLyoqIEB0eXBlIHtFbGVtZW50fSAqLyhub2RlKSwgdmFsdWUsIGJpbmRpbmcudGFyZ2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUHJvcGVydHkgYmluZGluZ1xuICAgICAgbGV0IHByb3AgPSBiaW5kaW5nLnRhcmdldDtcbiAgICAgIGlmIChub2RlLl9fZGF0YUhhc0FjY2Vzc29yICYmIG5vZGUuX19kYXRhSGFzQWNjZXNzb3JbcHJvcF0pIHtcbiAgICAgICAgaWYgKCFub2RlW1RZUEVTLlJFQURfT05MWV0gfHwgIW5vZGVbVFlQRVMuUkVBRF9PTkxZXVtwcm9wXSkge1xuICAgICAgICAgIGlmIChub2RlLl9zZXRQZW5kaW5nUHJvcGVydHkocHJvcCwgdmFsdWUpKSB7XG4gICAgICAgICAgICBpbnN0Ll9lbnF1ZXVlQ2xpZW50KG5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlICB7XG4gICAgICAgIGluc3QuX3NldFVubWFuYWdlZFByb3BlcnR5VG9Ob2RlKG5vZGUsIHByb3AsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVHJhbnNmb3JtcyBhbiBcImJpbmRpbmdcIiBlZmZlY3QgdmFsdWUgYmFzZWQgb24gY29tcG91bmQgJiBuZWdhdGlvblxuICAgKiBlZmZlY3QgbWV0YWRhdGEsIGFzIHdlbGwgYXMgaGFuZGxpbmcgZm9yIHNwZWNpYWwtY2FzZSBwcm9wZXJ0aWVzXG4gICAqXG4gICAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBOb2RlIHRoZSB2YWx1ZSB3aWxsIGJlIHNldCB0b1xuICAgKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIHNldFxuICAgKiBAcGFyYW0geyFCaW5kaW5nfSBiaW5kaW5nIEJpbmRpbmcgbWV0YWRhdGFcbiAgICogQHBhcmFtIHshQmluZGluZ1BhcnR9IHBhcnQgQmluZGluZyBwYXJ0IG1ldGFkYXRhXG4gICAqIEByZXR1cm4geyp9IFRyYW5zZm9ybWVkIHZhbHVlIHRvIHNldFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gY29tcHV0ZUJpbmRpbmdWYWx1ZShub2RlLCB2YWx1ZSwgYmluZGluZywgcGFydCkge1xuICAgIGlmIChiaW5kaW5nLmlzQ29tcG91bmQpIHtcbiAgICAgIGxldCBzdG9yYWdlID0gbm9kZS5fX2RhdGFDb21wb3VuZFN0b3JhZ2VbYmluZGluZy50YXJnZXRdO1xuICAgICAgc3RvcmFnZVtwYXJ0LmNvbXBvdW5kSW5kZXhdID0gdmFsdWU7XG4gICAgICB2YWx1ZSA9IHN0b3JhZ2Uuam9pbignJyk7XG4gICAgfVxuICAgIGlmIChiaW5kaW5nLmtpbmQgIT09ICdhdHRyaWJ1dGUnKSB7XG4gICAgICAvLyBTb21lIGJyb3dzZXJzIHNlcmlhbGl6ZSBgdW5kZWZpbmVkYCB0byBgXCJ1bmRlZmluZWRcImBcbiAgICAgIGlmIChiaW5kaW5nLnRhcmdldCA9PT0gJ3RleHRDb250ZW50JyB8fFxuICAgICAgICAgIChub2RlLmxvY2FsTmFtZSA9PSAnaW5wdXQnICYmIGJpbmRpbmcudGFyZ2V0ID09ICd2YWx1ZScpKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUgPT0gdW5kZWZpbmVkID8gJycgOiB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBhIGJpbmRpbmcncyBtZXRhZGF0YSBtZWV0cyBhbGwgdGhlIHJlcXVpcmVtZW50cyB0byBhbGxvd1xuICAgKiAyLXdheSBiaW5kaW5nLCBhbmQgdGhlcmVmb3JlIGEgYDxwcm9wZXJ0eT4tY2hhbmdlZGAgZXZlbnQgbGlzdGVuZXIgc2hvdWxkIGJlXG4gICAqIGFkZGVkOlxuICAgKiAtIHVzZWQgY3VybHkgYnJhY2VzXG4gICAqIC0gaXMgYSBwcm9wZXJ0eSAobm90IGF0dHJpYnV0ZSkgYmluZGluZ1xuICAgKiAtIGlzIG5vdCBhIHRleHRDb250ZW50IGJpbmRpbmdcbiAgICogLSBpcyBub3QgY29tcG91bmRcbiAgICpcbiAgICogQHBhcmFtIHshQmluZGluZ30gYmluZGluZyBCaW5kaW5nIG1ldGFkYXRhXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgMi13YXkgbGlzdGVuZXIgc2hvdWxkIGJlIGFkZGVkXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBzaG91bGRBZGRMaXN0ZW5lcihiaW5kaW5nKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4oYmluZGluZy50YXJnZXQpICYmXG4gICAgICAgICAgIGJpbmRpbmcua2luZCAhPSAnYXR0cmlidXRlJyAmJlxuICAgICAgICAgICBiaW5kaW5nLmtpbmQgIT0gJ3RleHQnICYmXG4gICAgICAgICAgICFiaW5kaW5nLmlzQ29tcG91bmQgJiZcbiAgICAgICAgICAgYmluZGluZy5wYXJ0c1swXS5tb2RlID09PSAneyc7XG4gIH1cblxuICAvKipcbiAgICogU2V0dXAgY29tcG91bmQgYmluZGluZyBzdG9yYWdlIHN0cnVjdHVyZXMsIG5vdGlmeSBsaXN0ZW5lcnMsIGFuZCBkYXRhSG9zdFxuICAgKiByZWZlcmVuY2VzIG9udG8gdGhlIGJvdW5kIG5vZGVMaXN0LlxuICAgKlxuICAgKiBAcGFyYW0geyFQcm9wZXJ0eUVmZmVjdHNUeXBlfSBpbnN0IEluc3RhbmNlIHRoYXQgYmFzIGJlZW4gcHJldmlvdXNseSBib3VuZFxuICAgKiBAcGFyYW0ge1RlbXBsYXRlSW5mb30gdGVtcGxhdGVJbmZvIFRlbXBsYXRlIG1ldGFkYXRhXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBzZXR1cEJpbmRpbmdzKGluc3QsIHRlbXBsYXRlSW5mbykge1xuICAgIC8vIFNldHVwIGNvbXBvdW5kIHN0b3JhZ2UsIGRhdGFIb3N0LCBhbmQgbm90aWZ5IGxpc3RlbmVyc1xuICAgIGxldCB7bm9kZUxpc3QsIG5vZGVJbmZvTGlzdH0gPSB0ZW1wbGF0ZUluZm87XG4gICAgaWYgKG5vZGVJbmZvTGlzdC5sZW5ndGgpIHtcbiAgICAgIGZvciAobGV0IGk9MDsgaSA8IG5vZGVJbmZvTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgaW5mbyA9IG5vZGVJbmZvTGlzdFtpXTtcbiAgICAgICAgbGV0IG5vZGUgPSBub2RlTGlzdFtpXTtcbiAgICAgICAgbGV0IGJpbmRpbmdzID0gaW5mby5iaW5kaW5ncztcbiAgICAgICAgaWYgKGJpbmRpbmdzKSB7XG4gICAgICAgICAgZm9yIChsZXQgaT0wOyBpPGJpbmRpbmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgYmluZGluZyA9IGJpbmRpbmdzW2ldO1xuICAgICAgICAgICAgc2V0dXBDb21wb3VuZFN0b3JhZ2Uobm9kZSwgYmluZGluZyk7XG4gICAgICAgICAgICBhZGROb3RpZnlMaXN0ZW5lcihub2RlLCBpbnN0LCBiaW5kaW5nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS5fX2RhdGFIb3N0ID0gaW5zdDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgYF9fZGF0YUNvbXBvdW5kU3RvcmFnZWAgbG9jYWwgc3RvcmFnZSBvbiBhIGJvdW5kIG5vZGUgd2l0aFxuICAgKiBpbml0aWFsIGxpdGVyYWwgZGF0YSBmb3IgY29tcG91bmQgYmluZGluZ3MsIGFuZCBzZXRzIHRoZSBqb2luZWRcbiAgICogbGl0ZXJhbCBwYXJ0cyB0byB0aGUgYm91bmQgcHJvcGVydHkuXG4gICAqXG4gICAqIFdoZW4gY2hhbmdlcyB0byBjb21wb3VuZCBwYXJ0cyBvY2N1ciwgdGhleSBhcmUgZmlyc3Qgc2V0IGludG8gdGhlIGNvbXBvdW5kXG4gICAqIHN0b3JhZ2UgYXJyYXkgZm9yIHRoYXQgcHJvcGVydHksIGFuZCB0aGVuIHRoZSBhcnJheSBpcyBqb2luZWQgdG8gcmVzdWx0IGluXG4gICAqIHRoZSBmaW5hbCB2YWx1ZSBzZXQgdG8gdGhlIHByb3BlcnR5L2F0dHJpYnV0ZS5cbiAgICpcbiAgICogQHBhcmFtIHtOb2RlfSBub2RlIEJvdW5kIG5vZGUgdG8gaW5pdGlhbGl6ZVxuICAgKiBAcGFyYW0ge0JpbmRpbmd9IGJpbmRpbmcgQmluZGluZyBtZXRhZGF0YVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gc2V0dXBDb21wb3VuZFN0b3JhZ2Uobm9kZSwgYmluZGluZykge1xuICAgIGlmIChiaW5kaW5nLmlzQ29tcG91bmQpIHtcbiAgICAgIC8vIENyZWF0ZSBjb21wb3VuZCBzdG9yYWdlIG1hcFxuICAgICAgbGV0IHN0b3JhZ2UgPSBub2RlLl9fZGF0YUNvbXBvdW5kU3RvcmFnZSB8fFxuICAgICAgICAobm9kZS5fX2RhdGFDb21wb3VuZFN0b3JhZ2UgPSB7fSk7XG4gICAgICBsZXQgcGFydHMgPSBiaW5kaW5nLnBhcnRzO1xuICAgICAgLy8gQ29weSBsaXRlcmFscyBmcm9tIHBhcnRzIGludG8gc3RvcmFnZSBmb3IgdGhpcyBiaW5kaW5nXG4gICAgICBsZXQgbGl0ZXJhbHMgPSBuZXcgQXJyYXkocGFydHMubGVuZ3RoKTtcbiAgICAgIGZvciAobGV0IGo9MDsgajxwYXJ0cy5sZW5ndGg7IGorKykge1xuICAgICAgICBsaXRlcmFsc1tqXSA9IHBhcnRzW2pdLmxpdGVyYWw7XG4gICAgICB9XG4gICAgICBsZXQgdGFyZ2V0ID0gYmluZGluZy50YXJnZXQ7XG4gICAgICBzdG9yYWdlW3RhcmdldF0gPSBsaXRlcmFscztcbiAgICAgIC8vIENvbmZpZ3VyZSBwcm9wZXJ0aWVzIHdpdGggdGhlaXIgbGl0ZXJhbCBwYXJ0c1xuICAgICAgaWYgKGJpbmRpbmcubGl0ZXJhbCAmJiBiaW5kaW5nLmtpbmQgPT0gJ3Byb3BlcnR5Jykge1xuICAgICAgICBub2RlW3RhcmdldF0gPSBiaW5kaW5nLmxpdGVyYWw7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYSAyLXdheSBiaW5kaW5nIG5vdGlmaWNhdGlvbiBldmVudCBsaXN0ZW5lciB0byB0aGUgbm9kZSBzcGVjaWZpZWRcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG5vZGUgQ2hpbGQgZWxlbWVudCB0byBhZGQgbGlzdGVuZXIgdG9cbiAgICogQHBhcmFtIHshUHJvcGVydHlFZmZlY3RzVHlwZX0gaW5zdCBIb3N0IGVsZW1lbnQgaW5zdGFuY2UgdG8gaGFuZGxlIG5vdGlmaWNhdGlvbiBldmVudFxuICAgKiBAcGFyYW0ge0JpbmRpbmd9IGJpbmRpbmcgQmluZGluZyBtZXRhZGF0YVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gYWRkTm90aWZ5TGlzdGVuZXIobm9kZSwgaW5zdCwgYmluZGluZykge1xuICAgIGlmIChiaW5kaW5nLmxpc3RlbmVyRXZlbnQpIHtcbiAgICAgIGxldCBwYXJ0ID0gYmluZGluZy5wYXJ0c1swXTtcbiAgICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihiaW5kaW5nLmxpc3RlbmVyRXZlbnQsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaGFuZGxlTm90aWZpY2F0aW9uKGUsIGluc3QsIGJpbmRpbmcudGFyZ2V0LCBwYXJ0LnNvdXJjZSwgcGFydC5uZWdhdGUpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLy8gLS0gZm9yIG1ldGhvZC1iYXNlZCBlZmZlY3RzIChjb21wbGV4T2JzZXJ2ZXIgJiBjb21wdXRlZCkgLS0tLS0tLS0tLS0tLS1cblxuICAvKipcbiAgICogQWRkcyBwcm9wZXJ0eSBlZmZlY3RzIGZvciBlYWNoIGFyZ3VtZW50IGluIHRoZSBtZXRob2Qgc2lnbmF0dXJlIChhbmRcbiAgICogb3B0aW9uYWxseSwgZm9yIHRoZSBtZXRob2QgbmFtZSBpZiBgZHluYW1pY2AgaXMgdHJ1ZSkgdGhhdCBjYWxscyB0aGVcbiAgICogcHJvdmlkZWQgZWZmZWN0IGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge0VsZW1lbnQgfCBPYmplY3R9IG1vZGVsIFByb3RvdHlwZSBvciBpbnN0YW5jZVxuICAgKiBAcGFyYW0geyFNZXRob2RTaWduYXR1cmV9IHNpZyBNZXRob2Qgc2lnbmF0dXJlIG1ldGFkYXRhXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIFR5cGUgb2YgcHJvcGVydHkgZWZmZWN0IHRvIGFkZFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlZmZlY3RGbiBGdW5jdGlvbiB0byBydW4gd2hlbiBhcmd1bWVudHMgY2hhbmdlXG4gICAqIEBwYXJhbSB7Kj19IG1ldGhvZEluZm8gRWZmZWN0LXNwZWNpZmljIGluZm9ybWF0aW9uIHRvIGJlIGluY2x1ZGVkIGluXG4gICAqICAgbWV0aG9kIGVmZmVjdCBtZXRhZGF0YVxuICAgKiBAcGFyYW0ge2Jvb2xlYW58T2JqZWN0PX0gZHluYW1pY0ZuIEJvb2xlYW4gb3Igb2JqZWN0IG1hcCBpbmRpY2F0aW5nIHdoZXRoZXJcbiAgICogICBtZXRob2QgbmFtZXMgc2hvdWxkIGJlIGluY2x1ZGVkIGFzIGEgZGVwZW5kZW5jeSB0byB0aGUgZWZmZWN0LiBOb3RlLFxuICAgKiAgIGRlZmF1bHRzIHRvIHRydWUgaWYgdGhlIHNpZ25hdHVyZSBpcyBzdGF0aWMgKHNpZy5zdGF0aWMgaXMgdHJ1ZSkuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBjcmVhdGVNZXRob2RFZmZlY3QobW9kZWwsIHNpZywgdHlwZSwgZWZmZWN0Rm4sIG1ldGhvZEluZm8sIGR5bmFtaWNGbikge1xuICAgIGR5bmFtaWNGbiA9IHNpZy5zdGF0aWMgfHwgKGR5bmFtaWNGbiAmJlxuICAgICAgKHR5cGVvZiBkeW5hbWljRm4gIT09ICdvYmplY3QnIHx8IGR5bmFtaWNGbltzaWcubWV0aG9kTmFtZV0pKTtcbiAgICBsZXQgaW5mbyA9IHtcbiAgICAgIG1ldGhvZE5hbWU6IHNpZy5tZXRob2ROYW1lLFxuICAgICAgYXJnczogc2lnLmFyZ3MsXG4gICAgICBtZXRob2RJbmZvLFxuICAgICAgZHluYW1pY0ZuXG4gICAgfTtcbiAgICBmb3IgKGxldCBpPTAsIGFyZzsgKGk8c2lnLmFyZ3MubGVuZ3RoKSAmJiAoYXJnPXNpZy5hcmdzW2ldKTsgaSsrKSB7XG4gICAgICBpZiAoIWFyZy5saXRlcmFsKSB7XG4gICAgICAgIG1vZGVsLl9hZGRQcm9wZXJ0eUVmZmVjdChhcmcucm9vdFByb3BlcnR5LCB0eXBlLCB7XG4gICAgICAgICAgZm46IGVmZmVjdEZuLCBpbmZvOiBpbmZvLCB0cmlnZ2VyOiBhcmdcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChkeW5hbWljRm4pIHtcbiAgICAgIG1vZGVsLl9hZGRQcm9wZXJ0eUVmZmVjdChzaWcubWV0aG9kTmFtZSwgdHlwZSwge1xuICAgICAgICBmbjogZWZmZWN0Rm4sIGluZm86IGluZm9cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxscyBhIG1ldGhvZCB3aXRoIGFyZ3VtZW50cyBtYXJzaGFsZWQgZnJvbSBwcm9wZXJ0aWVzIG9uIHRoZSBpbnN0YW5jZVxuICAgKiBiYXNlZCBvbiB0aGUgbWV0aG9kIHNpZ25hdHVyZSBjb250YWluZWQgaW4gdGhlIGVmZmVjdCBtZXRhZGF0YS5cbiAgICpcbiAgICogTXVsdGktcHJvcGVydHkgb2JzZXJ2ZXJzLCBjb21wdXRlZCBwcm9wZXJ0aWVzLCBhbmQgaW5saW5lIGNvbXB1dGluZ1xuICAgKiBmdW5jdGlvbnMgY2FsbCB0aGlzIGZ1bmN0aW9uIHRvIGludm9rZSB0aGUgbWV0aG9kLCB0aGVuIHVzZSB0aGUgcmV0dXJuXG4gICAqIHZhbHVlIGFjY29yZGluZ2x5LlxuICAgKlxuICAgKiBAcGFyYW0geyFQcm9wZXJ0eUVmZmVjdHNUeXBlfSBpbnN0IFRoZSBpbnN0YW5jZSB0aGUgZWZmZWN0IHdpbGwgYmUgcnVuIG9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBOYW1lIG9mIHByb3BlcnR5XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBCYWcgb2YgY3VycmVudCBwcm9wZXJ0eSBjaGFuZ2VzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvbGRQcm9wcyBCYWcgb2YgcHJldmlvdXMgdmFsdWVzIGZvciBjaGFuZ2VkIHByb3BlcnRpZXNcbiAgICogQHBhcmFtIHs/fSBpbmZvIEVmZmVjdCBtZXRhZGF0YVxuICAgKiBAcmV0dXJuIHsqfSBSZXR1cm5zIHRoZSByZXR1cm4gdmFsdWUgZnJvbSB0aGUgbWV0aG9kIGludm9jYXRpb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIHJ1bk1ldGhvZEVmZmVjdChpbnN0LCBwcm9wZXJ0eSwgcHJvcHMsIG9sZFByb3BzLCBpbmZvKSB7XG4gICAgLy8gSW5zdGFuY2VzIGNhbiBvcHRpb25hbGx5IGhhdmUgYSBfbWV0aG9kSG9zdCB3aGljaCBhbGxvd3MgcmVkaXJlY3Rpbmcgd2hlcmVcbiAgICAvLyB0byBmaW5kIG1ldGhvZHMuIEN1cnJlbnRseSB1c2VkIGJ5IGB0ZW1wbGF0aXplYC5cbiAgICBsZXQgY29udGV4dCA9IGluc3QuX21ldGhvZEhvc3QgfHwgaW5zdDtcbiAgICBsZXQgZm4gPSBjb250ZXh0W2luZm8ubWV0aG9kTmFtZV07XG4gICAgaWYgKGZuKSB7XG4gICAgICBsZXQgYXJncyA9IG1hcnNoYWxBcmdzKGluc3QuX19kYXRhLCBpbmZvLmFyZ3MsIHByb3BlcnR5LCBwcm9wcyk7XG4gICAgICByZXR1cm4gZm4uYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgfSBlbHNlIGlmICghaW5mby5keW5hbWljRm4pIHtcbiAgICAgIGNvbnNvbGUud2FybignbWV0aG9kIGAnICsgaW5mby5tZXRob2ROYW1lICsgJ2Agbm90IGRlZmluZWQnKTtcbiAgICB9XG4gIH1cblxuICBjb25zdCBlbXB0eUFycmF5ID0gW107XG5cbiAgLy8gUmVndWxhciBleHByZXNzaW9ucyB1c2VkIGZvciBiaW5kaW5nXG4gIGNvbnN0IElERU5UICA9ICcoPzonICsgJ1thLXpBLVpfJF1bXFxcXHcuOiRcXFxcLSpdKicgKyAnKSc7XG4gIGNvbnN0IE5VTUJFUiA9ICcoPzonICsgJ1stK10/WzAtOV0qXFxcXC4/WzAtOV0rKD86W2VFXVstK10/WzAtOV0rKT8nICsgJyknO1xuICBjb25zdCBTUVVPVEVfU1RSSU5HID0gJyg/OicgKyAnXFwnKD86W15cXCdcXFxcXFxcXF18XFxcXFxcXFwuKSpcXCcnICsgJyknO1xuICBjb25zdCBEUVVPVEVfU1RSSU5HID0gJyg/OicgKyAnXCIoPzpbXlwiXFxcXFxcXFxdfFxcXFxcXFxcLikqXCInICsgJyknO1xuICBjb25zdCBTVFJJTkcgPSAnKD86JyArIFNRVU9URV9TVFJJTkcgKyAnfCcgKyBEUVVPVEVfU1RSSU5HICsgJyknO1xuICBjb25zdCBBUkdVTUVOVCA9ICcoPzooJyArIElERU5UICsgJ3wnICsgTlVNQkVSICsgJ3wnICsgIFNUUklORyArICcpXFxcXHMqJyArICcpJztcbiAgY29uc3QgQVJHVU1FTlRTID0gJyg/OicgKyBBUkdVTUVOVCArICcoPzosXFxcXHMqJyArIEFSR1VNRU5UICsgJykqJyArICcpJztcbiAgY29uc3QgQVJHVU1FTlRfTElTVCA9ICcoPzonICsgJ1xcXFwoXFxcXHMqJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcoPzonICsgQVJHVU1FTlRTICsgJz8nICsgJyknICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdcXFxcKVxcXFxzKicgKyAnKSc7XG4gIGNvbnN0IEJJTkRJTkcgPSAnKCcgKyBJREVOVCArICdcXFxccyonICsgQVJHVU1FTlRfTElTVCArICc/JyArICcpJzsgLy8gR3JvdXAgM1xuICBjb25zdCBPUEVOX0JSQUNLRVQgPSAnKFxcXFxbXFxcXFt8e3spJyArICdcXFxccyonO1xuICBjb25zdCBDTE9TRV9CUkFDS0VUID0gJyg/Ol1dfH19KSc7XG4gIGNvbnN0IE5FR0FURSA9ICcoPzooISlcXFxccyopPyc7IC8vIEdyb3VwIDJcbiAgY29uc3QgRVhQUkVTU0lPTiA9IE9QRU5fQlJBQ0tFVCArIE5FR0FURSArIEJJTkRJTkcgKyBDTE9TRV9CUkFDS0VUO1xuICBjb25zdCBiaW5kaW5nUmVnZXggPSBuZXcgUmVnRXhwKEVYUFJFU1NJT04sIFwiZ1wiKTtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgc3RyaW5nIGZyb20gYmluZGluZyBwYXJ0cyBvZiBhbGwgdGhlIGxpdGVyYWwgcGFydHNcbiAgICpcbiAgICogQHBhcmFtIHshQXJyYXk8QmluZGluZ1BhcnQ+fSBwYXJ0cyBBbGwgcGFydHMgdG8gc3RyaW5naWZ5XG4gICAqIEByZXR1cm4ge3N0cmluZ30gU3RyaW5nIG1hZGUgZnJvbSB0aGUgbGl0ZXJhbCBwYXJ0c1xuICAgKi9cbiAgZnVuY3Rpb24gbGl0ZXJhbEZyb21QYXJ0cyhwYXJ0cykge1xuICAgIGxldCBzID0gJyc7XG4gICAgZm9yIChsZXQgaT0wOyBpPHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgbGl0ZXJhbCA9IHBhcnRzW2ldLmxpdGVyYWw7XG4gICAgICBzICs9IGxpdGVyYWwgfHwgJyc7XG4gICAgfVxuICAgIHJldHVybiBzO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlcyBhbiBleHByZXNzaW9uIHN0cmluZyBmb3IgYSBtZXRob2Qgc2lnbmF0dXJlLCBhbmQgcmV0dXJucyBhIG1ldGFkYXRhXG4gICAqIGRlc2NyaWJpbmcgdGhlIG1ldGhvZCBpbiB0ZXJtcyBvZiBgbWV0aG9kTmFtZWAsIGBzdGF0aWNgICh3aGV0aGVyIGFsbCB0aGVcbiAgICogYXJndW1lbnRzIGFyZSBsaXRlcmFscyksIGFuZCBhbiBhcnJheSBvZiBgYXJnc2BcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV4cHJlc3Npb24gVGhlIGV4cHJlc3Npb24gdG8gcGFyc2VcbiAgICogQHJldHVybiB7P01ldGhvZFNpZ25hdHVyZX0gVGhlIG1ldGhvZCBtZXRhZGF0YSBvYmplY3QgaWYgYSBtZXRob2QgZXhwcmVzc2lvbiB3YXNcbiAgICogICBmb3VuZCwgb3RoZXJ3aXNlIGB1bmRlZmluZWRgXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBwYXJzZU1ldGhvZChleHByZXNzaW9uKSB7XG4gICAgLy8gdHJpZXMgdG8gbWF0Y2ggdmFsaWQgamF2YXNjcmlwdCBwcm9wZXJ0eSBuYW1lc1xuICAgIGxldCBtID0gZXhwcmVzc2lvbi5tYXRjaCgvKFteXFxzXSs/KVxcKChbXFxzXFxTXSopXFwpLyk7XG4gICAgaWYgKG0pIHtcbiAgICAgIGxldCBtZXRob2ROYW1lID0gbVsxXTtcbiAgICAgIGxldCBzaWcgPSB7IG1ldGhvZE5hbWUsIHN0YXRpYzogdHJ1ZSwgYXJnczogZW1wdHlBcnJheSB9O1xuICAgICAgaWYgKG1bMl0udHJpbSgpKSB7XG4gICAgICAgIC8vIHJlcGxhY2UgZXNjYXBlZCBjb21tYXMgd2l0aCBjb21tYSBlbnRpdHksIHNwbGl0IG9uIHVuLWVzY2FwZWQgY29tbWFzXG4gICAgICAgIGxldCBhcmdzID0gbVsyXS5yZXBsYWNlKC9cXFxcLC9nLCAnJmNvbW1hOycpLnNwbGl0KCcsJyk7XG4gICAgICAgIHJldHVybiBwYXJzZUFyZ3MoYXJncywgc2lnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBzaWc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlcyBhbiBhcnJheSBvZiBhcmd1bWVudHMgYW5kIHNldHMgdGhlIGBhcmdzYCBwcm9wZXJ0eSBvZiB0aGUgc3VwcGxpZWRcbiAgICogc2lnbmF0dXJlIG1ldGFkYXRhIG9iamVjdC4gU2V0cyB0aGUgYHN0YXRpY2AgcHJvcGVydHkgdG8gZmFsc2UgaWYgYW55XG4gICAqIGFyZ3VtZW50IGlzIGEgbm9uLWxpdGVyYWwuXG4gICAqXG4gICAqIEBwYXJhbSB7IUFycmF5PHN0cmluZz59IGFyZ0xpc3QgQXJyYXkgb2YgYXJndW1lbnQgbmFtZXNcbiAgICogQHBhcmFtIHshTWV0aG9kU2lnbmF0dXJlfSBzaWcgTWV0aG9kIHNpZ25hdHVyZSBtZXRhZGF0YSBvYmplY3RcbiAgICogQHJldHVybiB7IU1ldGhvZFNpZ25hdHVyZX0gVGhlIHVwZGF0ZWQgc2lnbmF0dXJlIG1ldGFkYXRhIG9iamVjdFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gcGFyc2VBcmdzKGFyZ0xpc3QsIHNpZykge1xuICAgIHNpZy5hcmdzID0gYXJnTGlzdC5tYXAoZnVuY3Rpb24ocmF3QXJnKSB7XG4gICAgICBsZXQgYXJnID0gcGFyc2VBcmcocmF3QXJnKTtcbiAgICAgIGlmICghYXJnLmxpdGVyYWwpIHtcbiAgICAgICAgc2lnLnN0YXRpYyA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFyZztcbiAgICB9LCB0aGlzKTtcbiAgICByZXR1cm4gc2lnO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlcyBhbiBpbmRpdmlkdWFsIGFyZ3VtZW50LCBhbmQgcmV0dXJucyBhbiBhcmd1bWVudCBtZXRhZGF0YSBvYmplY3RcbiAgICogd2l0aCB0aGUgZm9sbG93aW5nIGZpZWxkczpcbiAgICpcbiAgICogICB7XG4gICAqICAgICB2YWx1ZTogJ3Byb3AnLCAgICAgICAgLy8gcHJvcGVydHkvcGF0aCBvciBsaXRlcmFsIHZhbHVlXG4gICAqICAgICBsaXRlcmFsOiBmYWxzZSwgICAgICAgLy8gd2hldGhlciBhcmd1bWVudCBpcyBhIGxpdGVyYWxcbiAgICogICAgIHN0cnVjdHVyZWQ6IGZhbHNlLCAgICAvLyB3aGV0aGVyIHRoZSBwcm9wZXJ0eSBpcyBhIHBhdGhcbiAgICogICAgIHJvb3RQcm9wZXJ0eTogJ3Byb3AnLCAvLyB0aGUgcm9vdCBwcm9wZXJ0eSBvZiB0aGUgcGF0aFxuICAgKiAgICAgd2lsZGNhcmQ6IGZhbHNlICAgICAgIC8vIHdoZXRoZXIgdGhlIGFyZ3VtZW50IHdhcyBhIHdpbGRjYXJkICcuKicgcGF0aFxuICAgKiAgIH1cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJhd0FyZyBUaGUgc3RyaW5nIHZhbHVlIG9mIHRoZSBhcmd1bWVudFxuICAgKiBAcmV0dXJuIHshTWV0aG9kQXJnfSBBcmd1bWVudCBtZXRhZGF0YSBvYmplY3RcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIHBhcnNlQXJnKHJhd0FyZykge1xuICAgIC8vIGNsZWFuIHVwIHdoaXRlc3BhY2VcbiAgICBsZXQgYXJnID0gcmF3QXJnLnRyaW0oKVxuICAgICAgLy8gcmVwbGFjZSBjb21tYSBlbnRpdHkgd2l0aCBjb21tYVxuICAgICAgLnJlcGxhY2UoLyZjb21tYTsvZywgJywnKVxuICAgICAgLy8gcmVwYWlyIGV4dHJhIGVzY2FwZSBzZXF1ZW5jZXM7IG5vdGUgb25seSBjb21tYXMgc3RyaWN0bHkgbmVlZFxuICAgICAgLy8gZXNjYXBpbmcsIGJ1dCB3ZSBhbGxvdyBhbnkgb3RoZXIgY2hhciB0byBiZSBlc2NhcGVkIHNpbmNlIGl0c1xuICAgICAgLy8gbGlrZWx5IHVzZXJzIHdpbGwgZG8gdGhpc1xuICAgICAgLnJlcGxhY2UoL1xcXFwoLikvZywgJ1xcJDEnKVxuICAgICAgO1xuICAgIC8vIGJhc2ljIGFyZ3VtZW50IGRlc2NyaXB0b3JcbiAgICBsZXQgYSA9IHtcbiAgICAgIG5hbWU6IGFyZyxcbiAgICAgIHZhbHVlOiAnJyxcbiAgICAgIGxpdGVyYWw6IGZhbHNlXG4gICAgfTtcbiAgICAvLyBkZXRlY3QgbGl0ZXJhbCB2YWx1ZSAobXVzdCBiZSBTdHJpbmcgb3IgTnVtYmVyKVxuICAgIGxldCBmYyA9IGFyZ1swXTtcbiAgICBpZiAoZmMgPT09ICctJykge1xuICAgICAgZmMgPSBhcmdbMV07XG4gICAgfVxuICAgIGlmIChmYyA+PSAnMCcgJiYgZmMgPD0gJzknKSB7XG4gICAgICBmYyA9ICcjJztcbiAgICB9XG4gICAgc3dpdGNoKGZjKSB7XG4gICAgICBjYXNlIFwiJ1wiOlxuICAgICAgY2FzZSAnXCInOlxuICAgICAgICBhLnZhbHVlID0gYXJnLnNsaWNlKDEsIC0xKTtcbiAgICAgICAgYS5saXRlcmFsID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICcjJzpcbiAgICAgICAgYS52YWx1ZSA9IE51bWJlcihhcmcpO1xuICAgICAgICBhLmxpdGVyYWwgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgLy8gaWYgbm90IGxpdGVyYWwsIGxvb2sgZm9yIHN0cnVjdHVyZWQgcGF0aFxuICAgIGlmICghYS5saXRlcmFsKSB7XG4gICAgICBhLnJvb3RQcm9wZXJ0eSA9IFBvbHltZXIuUGF0aC5yb290KGFyZyk7XG4gICAgICAvLyBkZXRlY3Qgc3RydWN0dXJlZCBwYXRoIChoYXMgZG90cylcbiAgICAgIGEuc3RydWN0dXJlZCA9IFBvbHltZXIuUGF0aC5pc1BhdGgoYXJnKTtcbiAgICAgIGlmIChhLnN0cnVjdHVyZWQpIHtcbiAgICAgICAgYS53aWxkY2FyZCA9IChhcmcuc2xpY2UoLTIpID09ICcuKicpO1xuICAgICAgICBpZiAoYS53aWxkY2FyZCkge1xuICAgICAgICAgIGEubmFtZSA9IGFyZy5zbGljZSgwLCAtMik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGE7XG4gIH1cblxuICAvKipcbiAgICogR2F0aGVyIHRoZSBhcmd1bWVudCB2YWx1ZXMgZm9yIGEgbWV0aG9kIHNwZWNpZmllZCBpbiB0aGUgcHJvdmlkZWQgYXJyYXlcbiAgICogb2YgYXJndW1lbnQgbWV0YWRhdGEuXG4gICAqXG4gICAqIFRoZSBgcGF0aGAgYW5kIGB2YWx1ZWAgYXJndW1lbnRzIGFyZSB1c2VkIHRvIGZpbGwgaW4gd2lsZGNhcmQgZGVzY3JpcHRvclxuICAgKiB3aGVuIHRoZSBtZXRob2QgaXMgYmVpbmcgY2FsbGVkIGFzIGEgcmVzdWx0IG9mIGEgcGF0aCBub3RpZmljYXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIEluc3RhbmNlIGRhdGEgc3RvcmFnZSBvYmplY3QgdG8gcmVhZCBwcm9wZXJ0aWVzIGZyb21cbiAgICogQHBhcmFtIHshQXJyYXk8IU1ldGhvZEFyZz59IGFyZ3MgQXJyYXkgb2YgYXJndW1lbnQgbWV0YWRhdGFcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggUHJvcGVydHkvcGF0aCBuYW1lIHRoYXQgdHJpZ2dlcmVkIHRoZSBtZXRob2QgZWZmZWN0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBCYWcgb2YgY3VycmVudCBwcm9wZXJ0eSBjaGFuZ2VzXG4gICAqIEByZXR1cm4ge0FycmF5PCo+fSBBcnJheSBvZiBhcmd1bWVudCB2YWx1ZXNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIG1hcnNoYWxBcmdzKGRhdGEsIGFyZ3MsIHBhdGgsIHByb3BzKSB7XG4gICAgbGV0IHZhbHVlcyA9IFtdO1xuICAgIGZvciAobGV0IGk9MCwgbD1hcmdzLmxlbmd0aDsgaTxsOyBpKyspIHtcbiAgICAgIGxldCBhcmcgPSBhcmdzW2ldO1xuICAgICAgbGV0IG5hbWUgPSBhcmcubmFtZTtcbiAgICAgIGxldCB2O1xuICAgICAgaWYgKGFyZy5saXRlcmFsKSB7XG4gICAgICAgIHYgPSBhcmcudmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoYXJnLnN0cnVjdHVyZWQpIHtcbiAgICAgICAgICB2ID0gUG9seW1lci5QYXRoLmdldChkYXRhLCBuYW1lKTtcbiAgICAgICAgICAvLyB3aGVuIGRhdGEgaXMgbm90IHN0b3JlZCBlLmcuIGBzcGxpY2VzYFxuICAgICAgICAgIGlmICh2ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHYgPSBwcm9wc1tuYW1lXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdiA9IGRhdGFbbmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChhcmcud2lsZGNhcmQpIHtcbiAgICAgICAgLy8gT25seSBzZW5kIHRoZSBhY3R1YWwgcGF0aCBjaGFuZ2VkIGluZm8gaWYgdGhlIGNoYW5nZSB0aGF0XG4gICAgICAgIC8vIGNhdXNlZCB0aGUgb2JzZXJ2ZXIgdG8gcnVuIG1hdGNoZWQgdGhlIHdpbGRjYXJkXG4gICAgICAgIGxldCBiYXNlQ2hhbmdlZCA9IChuYW1lLmluZGV4T2YocGF0aCArICcuJykgPT09IDApO1xuICAgICAgICBsZXQgbWF0Y2hlcyA9IChwYXRoLmluZGV4T2YobmFtZSkgPT09IDAgJiYgIWJhc2VDaGFuZ2VkKTtcbiAgICAgICAgdmFsdWVzW2ldID0ge1xuICAgICAgICAgIHBhdGg6IG1hdGNoZXMgPyBwYXRoIDogbmFtZSxcbiAgICAgICAgICB2YWx1ZTogbWF0Y2hlcyA/IHByb3BzW3BhdGhdIDogdixcbiAgICAgICAgICBiYXNlOiB2XG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZXNbaV0gPSB2O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWVzO1xuICB9XG5cbiAgLy8gZGF0YSBhcGlcblxuICAvKipcbiAgICogU2VuZHMgYXJyYXkgc3BsaWNlIG5vdGlmaWNhdGlvbnMgKGAuc3BsaWNlc2AgYW5kIGAubGVuZ3RoYClcbiAgICpcbiAgICogTm90ZTogdGhpcyBpbXBsZW1lbnRhdGlvbiBvbmx5IGFjY2VwdHMgbm9ybWFsaXplZCBwYXRoc1xuICAgKlxuICAgKiBAcGFyYW0geyFQcm9wZXJ0eUVmZmVjdHNUeXBlfSBpbnN0IEluc3RhbmNlIHRvIHNlbmQgbm90aWZpY2F0aW9ucyB0b1xuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdGhlIG11dGF0aW9ucyBvY2N1cnJlZCBvblxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBUaGUgcGF0aCB0byB0aGUgYXJyYXkgdGhhdCB3YXMgbXV0YXRlZFxuICAgKiBAcGFyYW0ge0FycmF5fSBzcGxpY2VzIEFycmF5IG9mIHNwbGljZSByZWNvcmRzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBub3RpZnlTcGxpY2VzKGluc3QsIGFycmF5LCBwYXRoLCBzcGxpY2VzKSB7XG4gICAgbGV0IHNwbGljZXNQYXRoID0gcGF0aCArICcuc3BsaWNlcyc7XG4gICAgaW5zdC5ub3RpZnlQYXRoKHNwbGljZXNQYXRoLCB7IGluZGV4U3BsaWNlczogc3BsaWNlcyB9KTtcbiAgICBpbnN0Lm5vdGlmeVBhdGgocGF0aCArICcubGVuZ3RoJywgYXJyYXkubGVuZ3RoKTtcbiAgICAvLyBOdWxsIGhlcmUgdG8gYWxsb3cgcG90ZW50aWFsbHkgbGFyZ2Ugc3BsaWNlIHJlY29yZHMgdG8gYmUgR0MnZWQuXG4gICAgaW5zdC5fX2RhdGFbc3BsaWNlc1BhdGhdID0ge2luZGV4U3BsaWNlczogbnVsbH07XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIHNwbGljZSByZWNvcmQgYW5kIHNlbmRzIGFuIGFycmF5IHNwbGljZSBub3RpZmljYXRpb24gZm9yXG4gICAqIHRoZSBkZXNjcmliZWQgbXV0YXRpb25cbiAgICpcbiAgICogTm90ZTogdGhpcyBpbXBsZW1lbnRhdGlvbiBvbmx5IGFjY2VwdHMgbm9ybWFsaXplZCBwYXRoc1xuICAgKlxuICAgKiBAcGFyYW0geyFQcm9wZXJ0eUVmZmVjdHNUeXBlfSBpbnN0IEluc3RhbmNlIHRvIHNlbmQgbm90aWZpY2F0aW9ucyB0b1xuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdGhlIG11dGF0aW9ucyBvY2N1cnJlZCBvblxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBUaGUgcGF0aCB0byB0aGUgYXJyYXkgdGhhdCB3YXMgbXV0YXRlZFxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSW5kZXggYXQgd2hpY2ggdGhlIGFycmF5IG11dGF0aW9uIG9jY3VycmVkXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBhZGRlZENvdW50IE51bWJlciBvZiBhZGRlZCBpdGVtc1xuICAgKiBAcGFyYW0ge0FycmF5fSByZW1vdmVkIEFycmF5IG9mIHJlbW92ZWQgaXRlbXNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIG5vdGlmeVNwbGljZShpbnN0LCBhcnJheSwgcGF0aCwgaW5kZXgsIGFkZGVkQ291bnQsIHJlbW92ZWQpIHtcbiAgICBub3RpZnlTcGxpY2VzKGluc3QsIGFycmF5LCBwYXRoLCBbe1xuICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgYWRkZWRDb3VudDogYWRkZWRDb3VudCxcbiAgICAgIHJlbW92ZWQ6IHJlbW92ZWQsXG4gICAgICBvYmplY3Q6IGFycmF5LFxuICAgICAgdHlwZTogJ3NwbGljZSdcbiAgICB9XSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiB1cHBlci1jYXNlZCB2ZXJzaW9uIG9mIHRoZSBzdHJpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFN0cmluZyB0byB1cHBlcmNhc2VcbiAgICogQHJldHVybiB7c3RyaW5nfSBVcHBlcmNhc2VkIHN0cmluZ1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gdXBwZXIobmFtZSkge1xuICAgIHJldHVybiBuYW1lWzBdLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnN1YnN0cmluZygxKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbGVtZW50IGNsYXNzIG1peGluIHRoYXQgcHJvdmlkZXMgbWV0YS1wcm9ncmFtbWluZyBmb3IgUG9seW1lcidzIHRlbXBsYXRlXG4gICAqIGJpbmRpbmcgYW5kIGRhdGEgb2JzZXJ2YXRpb24gKGNvbGxlY3RpdmVseSwgXCJwcm9wZXJ0eSBlZmZlY3RzXCIpIHN5c3RlbS5cbiAgICpcbiAgICogVGhpcyBtaXhpbiB1c2VzIHByb3ZpZGVzIHRoZSBmb2xsb3dpbmcga2V5IHN0YXRpYyBtZXRob2RzIGZvciBhZGRpbmdcbiAgICogcHJvcGVydHkgZWZmZWN0cyB0byBhbiBlbGVtZW50IGNsYXNzOlxuICAgKiAtIGBhZGRQcm9wZXJ0eUVmZmVjdGBcbiAgICogLSBgY3JlYXRlUHJvcGVydHlPYnNlcnZlcmBcbiAgICogLSBgY3JlYXRlTWV0aG9kT2JzZXJ2ZXJgXG4gICAqIC0gYGNyZWF0ZU5vdGlmeWluZ1Byb3BlcnR5YFxuICAgKiAtIGBjcmVhdGVSZWFkT25seVByb3BlcnR5YFxuICAgKiAtIGBjcmVhdGVSZWZsZWN0ZWRQcm9wZXJ0eWBcbiAgICogLSBgY3JlYXRlQ29tcHV0ZWRQcm9wZXJ0eWBcbiAgICogLSBgYmluZFRlbXBsYXRlYFxuICAgKlxuICAgKiBFYWNoIG1ldGhvZCBjcmVhdGVzIG9uZSBvciBtb3JlIHByb3BlcnR5IGFjY2Vzc29ycywgYWxvbmcgd2l0aCBtZXRhZGF0YVxuICAgKiB1c2VkIGJ5IHRoaXMgbWl4aW4ncyBpbXBsZW1lbnRhdGlvbiBvZiBgX3Byb3BlcnRpZXNDaGFuZ2VkYCB0byBwZXJmb3JtXG4gICAqIHRoZSBwcm9wZXJ0eSBlZmZlY3RzLlxuICAgKlxuICAgKiBVbmRlcnNjb3JlZCB2ZXJzaW9ucyBvZiB0aGUgYWJvdmUgbWV0aG9kcyBhbHNvIGV4aXN0IG9uIHRoZSBlbGVtZW50XG4gICAqIHByb3RvdHlwZSBmb3IgYWRkaW5nIHByb3BlcnR5IGVmZmVjdHMgb24gaW5zdGFuY2VzIGF0IHJ1bnRpbWUuXG4gICAqXG4gICAqIE5vdGUgdGhhdCB0aGlzIG1peGluIG92ZXJyaWRlcyBzZXZlcmFsIGBQcm9wZXJ0eUFjY2Vzc29yc2AgbWV0aG9kcywgaW5cbiAgICogbWFueSBjYXNlcyB0byBtYWludGFpbiBndWFyYW50ZWVzIHByb3ZpZGVkIGJ5IHRoZSBQb2x5bWVyIDEueCBmZWF0dXJlcztcbiAgICogbm90YWJseSBpdCBjaGFuZ2VzIHByb3BlcnR5IGFjY2Vzc29ycyB0byBiZSBzeW5jaHJvbm91cyBieSBkZWZhdWx0XG4gICAqIHdoZXJlYXMgdGhlIGRlZmF1bHQgd2hlbiB1c2luZyBgUHJvcGVydHlBY2Nlc3NvcnNgIHN0YW5kYWxvbmUgaXMgdG8gYmVcbiAgICogYXN5bmMgYnkgZGVmYXVsdC5cbiAgICpcbiAgICogQG1peGluRnVuY3Rpb25cbiAgICogQHBvbHltZXJcbiAgICogQGFwcGxpZXNNaXhpbiBQb2x5bWVyLlRlbXBsYXRlU3RhbXBcbiAgICogQGFwcGxpZXNNaXhpbiBQb2x5bWVyLlByb3BlcnR5QWNjZXNzb3JzXG4gICAqIEBtZW1iZXJvZiBQb2x5bWVyXG4gICAqIEBzdW1tYXJ5IEVsZW1lbnQgY2xhc3MgbWl4aW4gdGhhdCBwcm92aWRlcyBtZXRhLXByb2dyYW1taW5nIGZvciBQb2x5bWVyJ3NcbiAgICogdGVtcGxhdGUgYmluZGluZyBhbmQgZGF0YSBvYnNlcnZhdGlvbiBzeXN0ZW0uXG4gICAqL1xuICBQb2x5bWVyLlByb3BlcnR5RWZmZWN0cyA9IFBvbHltZXIuZGVkdXBpbmdNaXhpbihzdXBlckNsYXNzID0+IHtcblxuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBleHRlbmRzIHtzdXBlckNsYXNzfVxuICAgICAqIEBpbXBsZW1lbnRzIHtQb2x5bWVyX1Byb3BlcnR5QWNjZXNzb3JzfVxuICAgICAqIEBpbXBsZW1lbnRzIHtQb2x5bWVyX1RlbXBsYXRlU3RhbXB9XG4gICAgICogQHVucmVzdHJpY3RlZFxuICAgICAqL1xuICAgIGNvbnN0IHByb3BlcnR5RWZmZWN0c0Jhc2UgPSBQb2x5bWVyLlRlbXBsYXRlU3RhbXAoUG9seW1lci5Qcm9wZXJ0eUFjY2Vzc29ycyhzdXBlckNsYXNzKSk7XG5cbiAgICAvKipcbiAgICAgKiBAcG9seW1lclxuICAgICAqIEBtaXhpbkNsYXNzXG4gICAgICogQGltcGxlbWVudHMge1BvbHltZXJfUHJvcGVydHlFZmZlY3RzfVxuICAgICAqIEBleHRlbmRzIHtwcm9wZXJ0eUVmZmVjdHNCYXNlfVxuICAgICAqIEB1bnJlc3RyaWN0ZWRcbiAgICAgKi9cbiAgICBjbGFzcyBQcm9wZXJ0eUVmZmVjdHMgZXh0ZW5kcyBwcm9wZXJ0eUVmZmVjdHNCYXNlIHtcblxuICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cbiAgICAgICAgdGhpcy5fX2RhdGFDbGllbnRzUmVhZHk7XG4gICAgICAgIC8qKiBAdHlwZSB7QXJyYXl9ICovXG4gICAgICAgIHRoaXMuX19kYXRhUGVuZGluZ0NsaWVudHM7XG4gICAgICAgIC8qKiBAdHlwZSB7T2JqZWN0fSAqL1xuICAgICAgICB0aGlzLl9fZGF0YVRvTm90aWZ5O1xuICAgICAgICAvKiogQHR5cGUge09iamVjdH0gKi9cbiAgICAgICAgdGhpcy5fX2RhdGFMaW5rZWRQYXRocztcbiAgICAgICAgLyoqIEB0eXBlIHtib29sZWFufSAqL1xuICAgICAgICB0aGlzLl9fZGF0YUhhc1BhdGhzO1xuICAgICAgICAvKiogQHR5cGUge09iamVjdH0gKi9cbiAgICAgICAgdGhpcy5fX2RhdGFDb21wb3VuZFN0b3JhZ2U7XG4gICAgICAgIC8qKiBAdHlwZSB7UG9seW1lcl9Qcm9wZXJ0eUVmZmVjdHN9ICovXG4gICAgICAgIHRoaXMuX19kYXRhSG9zdDtcbiAgICAgICAgLyoqIEB0eXBlIHshT2JqZWN0fSAqL1xuICAgICAgICB0aGlzLl9fZGF0YVRlbXA7XG4gICAgICAgIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cbiAgICAgICAgdGhpcy5fX2RhdGFDbGllbnRzSW5pdGlhbGl6ZWQ7XG4gICAgICAgIC8qKiBAdHlwZSB7IU9iamVjdH0gKi9cbiAgICAgICAgdGhpcy5fX2RhdGE7XG4gICAgICAgIC8qKiBAdHlwZSB7IU9iamVjdH0gKi9cbiAgICAgICAgdGhpcy5fX2RhdGFQZW5kaW5nO1xuICAgICAgICAvKiogQHR5cGUgeyFPYmplY3R9ICovXG4gICAgICAgIHRoaXMuX19kYXRhT2xkO1xuICAgICAgICAvKiogQHR5cGUge09iamVjdH0gKi9cbiAgICAgICAgdGhpcy5fX2NvbXB1dGVFZmZlY3RzO1xuICAgICAgICAvKiogQHR5cGUge09iamVjdH0gKi9cbiAgICAgICAgdGhpcy5fX3JlZmxlY3RFZmZlY3RzO1xuICAgICAgICAvKiogQHR5cGUge09iamVjdH0gKi9cbiAgICAgICAgdGhpcy5fX25vdGlmeUVmZmVjdHM7XG4gICAgICAgIC8qKiBAdHlwZSB7T2JqZWN0fSAqL1xuICAgICAgICB0aGlzLl9fcHJvcGFnYXRlRWZmZWN0cztcbiAgICAgICAgLyoqIEB0eXBlIHtPYmplY3R9ICovXG4gICAgICAgIHRoaXMuX19vYnNlcnZlRWZmZWN0cztcbiAgICAgICAgLyoqIEB0eXBlIHtPYmplY3R9ICovXG4gICAgICAgIHRoaXMuX19yZWFkT25seTtcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMuX19kYXRhQ291bnRlcjtcbiAgICAgICAgLyoqIEB0eXBlIHshVGVtcGxhdGVJbmZvfSAqL1xuICAgICAgICB0aGlzLl9fdGVtcGxhdGVJbmZvO1xuICAgICAgfVxuXG4gICAgICBnZXQgUFJPUEVSVFlfRUZGRUNUX1RZUEVTKCkge1xuICAgICAgICByZXR1cm4gVFlQRVM7XG4gICAgICB9XG5cbiAgICAgIF9pbml0aWFsaXplUHJvcGVydGllcygpIHtcbiAgICAgICAgc3VwZXIuX2luaXRpYWxpemVQcm9wZXJ0aWVzKCk7XG4gICAgICAgIGhvc3RTdGFjay5yZWdpc3Rlckhvc3QodGhpcyk7XG4gICAgICAgIHRoaXMuX19kYXRhQ2xpZW50c1JlYWR5ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX19kYXRhUGVuZGluZ0NsaWVudHMgPSBudWxsO1xuICAgICAgICB0aGlzLl9fZGF0YVRvTm90aWZ5ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fX2RhdGFMaW5rZWRQYXRocyA9IG51bGw7XG4gICAgICAgIHRoaXMuX19kYXRhSGFzUGF0aHMgPSBmYWxzZTtcbiAgICAgICAgLy8gTWF5IGJlIHNldCBvbiBpbnN0YW5jZSBwcmlvciB0byB1cGdyYWRlXG4gICAgICAgIHRoaXMuX19kYXRhQ29tcG91bmRTdG9yYWdlID0gdGhpcy5fX2RhdGFDb21wb3VuZFN0b3JhZ2UgfHwgbnVsbDtcbiAgICAgICAgdGhpcy5fX2RhdGFIb3N0ID0gdGhpcy5fX2RhdGFIb3N0IHx8IG51bGw7XG4gICAgICAgIHRoaXMuX19kYXRhVGVtcCA9IHt9O1xuICAgICAgICB0aGlzLl9fZGF0YUNsaWVudHNJbml0aWFsaXplZCA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIE92ZXJyaWRlcyBgUG9seW1lci5Qcm9wZXJ0eUFjY2Vzc29yc2AgaW1wbGVtZW50YXRpb24gdG8gcHJvdmlkZSBhXG4gICAgICAgKiBtb3JlIGVmZmljaWVudCBpbXBsZW1lbnRhdGlvbiBvZiBpbml0aWFsaXppbmcgcHJvcGVydGllcyBmcm9tXG4gICAgICAgKiB0aGUgcHJvdG90eXBlIG9uIHRoZSBpbnN0YW5jZS5cbiAgICAgICAqXG4gICAgICAgKiBAb3ZlcnJpZGVcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBQcm9wZXJ0aWVzIHRvIGluaXRpYWxpemUgb24gdGhlIHByb3RvdHlwZVxuICAgICAgICovXG4gICAgICBfaW5pdGlhbGl6ZVByb3RvUHJvcGVydGllcyhwcm9wcykge1xuICAgICAgICB0aGlzLl9fZGF0YSA9IE9iamVjdC5jcmVhdGUocHJvcHMpO1xuICAgICAgICB0aGlzLl9fZGF0YVBlbmRpbmcgPSBPYmplY3QuY3JlYXRlKHByb3BzKTtcbiAgICAgICAgdGhpcy5fX2RhdGFPbGQgPSB7fTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBPdmVycmlkZXMgYFBvbHltZXIuUHJvcGVydHlBY2Nlc3NvcnNgIGltcGxlbWVudGF0aW9uIHRvIGF2b2lkIHNldHRpbmdcbiAgICAgICAqIGBfc2V0UHJvcGVydHlgJ3MgYHNob3VsZE5vdGlmeTogdHJ1ZWAuXG4gICAgICAgKlxuICAgICAgICogQG92ZXJyaWRlXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgUHJvcGVydGllcyB0byBpbml0aWFsaXplIG9uIHRoZSBpbnN0YW5jZVxuICAgICAgICovXG4gICAgICBfaW5pdGlhbGl6ZUluc3RhbmNlUHJvcGVydGllcyhwcm9wcykge1xuICAgICAgICBsZXQgcmVhZE9ubHkgPSB0aGlzW1RZUEVTLlJFQURfT05MWV07XG4gICAgICAgIGZvciAobGV0IHByb3AgaW4gcHJvcHMpIHtcbiAgICAgICAgICBpZiAoIXJlYWRPbmx5IHx8ICFyZWFkT25seVtwcm9wXSkge1xuICAgICAgICAgICAgdGhpcy5fX2RhdGFQZW5kaW5nID0gdGhpcy5fX2RhdGFQZW5kaW5nIHx8IHt9O1xuICAgICAgICAgICAgdGhpcy5fX2RhdGFPbGQgPSB0aGlzLl9fZGF0YU9sZCB8fCB7fTtcbiAgICAgICAgICAgIHRoaXMuX19kYXRhW3Byb3BdID0gdGhpcy5fX2RhdGFQZW5kaW5nW3Byb3BdID0gcHJvcHNbcHJvcF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFByb3RvdHlwZSBzZXR1cCAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgIC8qKlxuICAgICAgICogRXF1aXZhbGVudCB0byBzdGF0aWMgYGFkZFByb3BlcnR5RWZmZWN0YCBBUEkgYnV0IGNhbiBiZSBjYWxsZWQgb25cbiAgICAgICAqIGFuIGluc3RhbmNlIHRvIGFkZCBlZmZlY3RzIGF0IHJ1bnRpbWUuICBTZWUgdGhhdCBtZXRob2QgZm9yXG4gICAgICAgKiBmdWxsIEFQSSBkb2NzLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSB0aGF0IHNob3VsZCB0cmlnZ2VyIHRoZSBlZmZlY3RcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIEVmZmVjdCB0eXBlLCBmcm9tIHRoaXMuUFJPUEVSVFlfRUZGRUNUX1RZUEVTXG4gICAgICAgKiBAcGFyYW0ge09iamVjdD19IGVmZmVjdCBFZmZlY3QgbWV0YWRhdGEgb2JqZWN0XG4gICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgKi9cbiAgICAgIF9hZGRQcm9wZXJ0eUVmZmVjdChwcm9wZXJ0eSwgdHlwZSwgZWZmZWN0KSB7XG4gICAgICAgIHRoaXMuX2NyZWF0ZVByb3BlcnR5QWNjZXNzb3IocHJvcGVydHksIHR5cGUgPT0gVFlQRVMuUkVBRF9PTkxZKTtcbiAgICAgICAgLy8gZWZmZWN0cyBhcmUgYWNjdW11bGF0ZWQgaW50byBhcnJheXMgcGVyIHByb3BlcnR5IGJhc2VkIG9uIHR5cGVcbiAgICAgICAgbGV0IGVmZmVjdHMgPSBlbnN1cmVPd25FZmZlY3RNYXAodGhpcywgdHlwZSlbcHJvcGVydHldO1xuICAgICAgICBpZiAoIWVmZmVjdHMpIHtcbiAgICAgICAgICBlZmZlY3RzID0gdGhpc1t0eXBlXVtwcm9wZXJ0eV0gPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBlZmZlY3RzLnB1c2goZWZmZWN0KTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZW1vdmVzIHRoZSBnaXZlbiBwcm9wZXJ0eSBlZmZlY3QuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IHRoZSBlZmZlY3Qgd2FzIGFzc29jaWF0ZWQgd2l0aFxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgRWZmZWN0IHR5cGUsIGZyb20gdGhpcy5QUk9QRVJUWV9FRkZFQ1RfVFlQRVNcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0PX0gZWZmZWN0IEVmZmVjdCBtZXRhZGF0YSBvYmplY3QgdG8gcmVtb3ZlXG4gICAgICAgKi9cbiAgICAgIF9yZW1vdmVQcm9wZXJ0eUVmZmVjdChwcm9wZXJ0eSwgdHlwZSwgZWZmZWN0KSB7XG4gICAgICAgIGxldCBlZmZlY3RzID0gZW5zdXJlT3duRWZmZWN0TWFwKHRoaXMsIHR5cGUpW3Byb3BlcnR5XTtcbiAgICAgICAgbGV0IGlkeCA9IGVmZmVjdHMuaW5kZXhPZihlZmZlY3QpO1xuICAgICAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgICAgICBlZmZlY3RzLnNwbGljZShpZHgsIDEpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBjdXJyZW50IHByb3RvdHlwZS9pbnN0YW5jZSBoYXMgYSBwcm9wZXJ0eSBlZmZlY3RcbiAgICAgICAqIG9mIGEgY2VydGFpbiB0eXBlLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSBuYW1lXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZz19IHR5cGUgRWZmZWN0IHR5cGUsIGZyb20gdGhpcy5QUk9QRVJUWV9FRkZFQ1RfVFlQRVNcbiAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIHByb3RvdHlwZS9pbnN0YW5jZSBoYXMgYW4gZWZmZWN0IG9mIHRoaXMgdHlwZVxuICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICovXG4gICAgICBfaGFzUHJvcGVydHlFZmZlY3QocHJvcGVydHksIHR5cGUpIHtcbiAgICAgICAgbGV0IGVmZmVjdHMgPSB0aGlzW3R5cGVdO1xuICAgICAgICByZXR1cm4gQm9vbGVhbihlZmZlY3RzICYmIGVmZmVjdHNbcHJvcGVydHldKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGN1cnJlbnQgcHJvdG90eXBlL2luc3RhbmNlIGhhcyBhIFwicmVhZCBvbmx5XCJcbiAgICAgICAqIGFjY2Vzc29yIGZvciB0aGUgZ2l2ZW4gcHJvcGVydHkuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IG5hbWVcbiAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIHByb3RvdHlwZS9pbnN0YW5jZSBoYXMgYW4gZWZmZWN0IG9mIHRoaXMgdHlwZVxuICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICovXG4gICAgICBfaGFzUmVhZE9ubHlFZmZlY3QocHJvcGVydHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hhc1Byb3BlcnR5RWZmZWN0KHByb3BlcnR5LCBUWVBFUy5SRUFEX09OTFkpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgY3VycmVudCBwcm90b3R5cGUvaW5zdGFuY2UgaGFzIGEgXCJub3RpZnlcIlxuICAgICAgICogcHJvcGVydHkgZWZmZWN0IGZvciB0aGUgZ2l2ZW4gcHJvcGVydHkuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IG5hbWVcbiAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIHByb3RvdHlwZS9pbnN0YW5jZSBoYXMgYW4gZWZmZWN0IG9mIHRoaXMgdHlwZVxuICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICovXG4gICAgICBfaGFzTm90aWZ5RWZmZWN0KHByb3BlcnR5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oYXNQcm9wZXJ0eUVmZmVjdChwcm9wZXJ0eSwgVFlQRVMuTk9USUZZKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGN1cnJlbnQgcHJvdG90eXBlL2luc3RhbmNlIGhhcyBhIFwicmVmbGVjdCB0byBhdHRyaWJ1dGVcIlxuICAgICAgICogcHJvcGVydHkgZWZmZWN0IGZvciB0aGUgZ2l2ZW4gcHJvcGVydHkuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IG5hbWVcbiAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIHByb3RvdHlwZS9pbnN0YW5jZSBoYXMgYW4gZWZmZWN0IG9mIHRoaXMgdHlwZVxuICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICovXG4gICAgICBfaGFzUmVmbGVjdEVmZmVjdChwcm9wZXJ0eSkge1xuICAgICAgICByZXR1cm4gdGhpcy5faGFzUHJvcGVydHlFZmZlY3QocHJvcGVydHksIFRZUEVTLlJFRkxFQ1QpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgY3VycmVudCBwcm90b3R5cGUvaW5zdGFuY2UgaGFzIGEgXCJjb21wdXRlZFwiXG4gICAgICAgKiBwcm9wZXJ0eSBlZmZlY3QgZm9yIHRoZSBnaXZlbiBwcm9wZXJ0eS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgbmFtZVxuICAgICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgcHJvdG90eXBlL2luc3RhbmNlIGhhcyBhbiBlZmZlY3Qgb2YgdGhpcyB0eXBlXG4gICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgKi9cbiAgICAgIF9oYXNDb21wdXRlZEVmZmVjdChwcm9wZXJ0eSkge1xuICAgICAgICByZXR1cm4gdGhpcy5faGFzUHJvcGVydHlFZmZlY3QocHJvcGVydHksIFRZUEVTLkNPTVBVVEUpO1xuICAgICAgfVxuXG4gICAgICAvLyBSdW50aW1lIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgLyoqXG4gICAgICAgKiBTZXRzIGEgcGVuZGluZyBwcm9wZXJ0eSBvciBwYXRoLiAgSWYgdGhlIHJvb3QgcHJvcGVydHkgb2YgdGhlIHBhdGggaW5cbiAgICAgICAqIHF1ZXN0aW9uIGhhZCBubyBhY2Nlc3NvciwgdGhlIHBhdGggaXMgc2V0LCBvdGhlcndpc2UgaXQgaXMgZW5xdWV1ZWRcbiAgICAgICAqIHZpYSBgX3NldFBlbmRpbmdQcm9wZXJ0eWAuXG4gICAgICAgKlxuICAgICAgICogVGhpcyBmdW5jdGlvbiBpc29sYXRlcyByZWxhdGl2ZWx5IGV4cGVuc2l2ZSBmdW5jdGlvbmFsaXR5IG5lY2Vzc2FyeVxuICAgICAgICogZm9yIHRoZSBwdWJsaWMgQVBJIChgc2V0YCwgYHNldFByb3BlcnRpZXNgLCBgbm90aWZ5UGF0aGAsIGFuZCBwcm9wZXJ0eVxuICAgICAgICogY2hhbmdlIGxpc3RlbmVycyB2aWEge3suLi59fSBiaW5kaW5ncyksIHN1Y2ggdGhhdCBpdCBpcyBvbmx5IGRvbmVcbiAgICAgICAqIHdoZW4gcGF0aHMgZW50ZXIgdGhlIHN5c3RlbSwgYW5kIG5vdCBhdCBldmVyeSBwcm9wYWdhdGlvbiBzdGVwLiAgSXRcbiAgICAgICAqIGFsc28gc2V0cyBhIGBfX2RhdGFIYXNQYXRoc2AgZmxhZyBvbiB0aGUgaW5zdGFuY2Ugd2hpY2ggaXMgdXNlZCB0b1xuICAgICAgICogZmFzdC1wYXRoIHNsb3dlciBwYXRoLW1hdGNoaW5nIGNvZGUgaW4gdGhlIHByb3BlcnR5IGVmZmVjdHMgaG9zdCBwYXRocy5cbiAgICAgICAqXG4gICAgICAgKiBgcGF0aGAgY2FuIGJlIGEgcGF0aCBzdHJpbmcgb3IgYXJyYXkgb2YgcGF0aCBwYXJ0cyBhcyBhY2NlcHRlZCBieSB0aGVcbiAgICAgICAqIHB1YmxpYyBBUEkuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmcgfCAhQXJyYXk8bnVtYmVyfHN0cmluZz59IHBhdGggUGF0aCB0byBzZXRcbiAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgdG8gc2V0XG4gICAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBzaG91bGROb3RpZnkgU2V0IHRvIHRydWUgaWYgdGhpcyBjaGFuZ2Ugc2hvdWxkXG4gICAgICAgKiAgY2F1c2UgYSBwcm9wZXJ0eSBub3RpZmljYXRpb24gZXZlbnQgZGlzcGF0Y2hcbiAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IGlzUGF0aE5vdGlmaWNhdGlvbiBJZiB0aGUgcGF0aCBiZWluZyBzZXQgaXMgYSBwYXRoXG4gICAgICAgKiAgIG5vdGlmaWNhdGlvbiBvZiBhbiBhbHJlYWR5IGNoYW5nZWQgdmFsdWUsIGFzIG9wcG9zZWQgdG8gYSByZXF1ZXN0XG4gICAgICAgKiAgIHRvIHNldCBhbmQgbm90aWZ5IHRoZSBjaGFuZ2UuICBJbiB0aGUgbGF0dGVyIGBmYWxzZWAgY2FzZSwgYSBkaXJ0eVxuICAgICAgICogICBjaGVjayBpcyBwZXJmb3JtZWQgYW5kIHRoZW4gdGhlIHZhbHVlIGlzIHNldCB0byB0aGUgcGF0aCBiZWZvcmVcbiAgICAgICAqICAgZW5xdWV1aW5nIHRoZSBwZW5kaW5nIHByb3BlcnR5IGNoYW5nZS5cbiAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGUgcHJvcGVydHkvcGF0aCB3YXMgZW5xdWV1ZWQgaW5cbiAgICAgICAqICAgdGhlIHBlbmRpbmcgY2hhbmdlcyBiYWcuXG4gICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgKi9cbiAgICAgIF9zZXRQZW5kaW5nUHJvcGVydHlPclBhdGgocGF0aCwgdmFsdWUsIHNob3VsZE5vdGlmeSwgaXNQYXRoTm90aWZpY2F0aW9uKSB7XG4gICAgICAgIGlmIChpc1BhdGhOb3RpZmljYXRpb24gfHxcbiAgICAgICAgICAgIFBvbHltZXIuUGF0aC5yb290KEFycmF5LmlzQXJyYXkocGF0aCkgPyBwYXRoWzBdIDogcGF0aCkgIT09IHBhdGgpIHtcbiAgICAgICAgICAvLyBEaXJ0eSBjaGVjayBjaGFuZ2VzIGJlaW5nIHNldCB0byBhIHBhdGggYWdhaW5zdCB0aGUgYWN0dWFsIG9iamVjdCxcbiAgICAgICAgICAvLyBzaW5jZSB0aGlzIGlzIHRoZSBlbnRyeSBwb2ludCBmb3IgcGF0aHMgaW50byB0aGUgc3lzdGVtOyBmcm9tIGhlcmVcbiAgICAgICAgICAvLyB0aGUgb25seSBkaXJ0eSBjaGVja3MgYXJlIGFnYWluc3QgdGhlIGBfX2RhdGFUZW1wYCBjYWNoZSB0byBwcmV2ZW50XG4gICAgICAgICAgLy8gZHVwbGljYXRlIHdvcmsgaW4gdGhlIHNhbWUgdHVybiBvbmx5LiBOb3RlLCBpZiB0aGlzIHdhcyBhIG5vdGlmaWNhdGlvblxuICAgICAgICAgIC8vIG9mIGEgY2hhbmdlIGFscmVhZHkgc2V0IHRvIGEgcGF0aCAoaXNQYXRoTm90aWZpY2F0aW9uOiB0cnVlKSxcbiAgICAgICAgICAvLyB3ZSBhbHdheXMgbGV0IHRoZSBjaGFuZ2UgdGhyb3VnaCBhbmQgc2tpcCB0aGUgYHNldGAgc2luY2UgaXQgd2FzXG4gICAgICAgICAgLy8gYWxyZWFkeSBkaXJ0eSBjaGVja2VkIGF0IHRoZSBwb2ludCBvZiBlbnRyeSBhbmQgdGhlIHVuZGVybHlpbmdcbiAgICAgICAgICAvLyBvYmplY3QgaGFzIGFscmVhZHkgYmVlbiB1cGRhdGVkXG4gICAgICAgICAgaWYgKCFpc1BhdGhOb3RpZmljYXRpb24pIHtcbiAgICAgICAgICAgIGxldCBvbGQgPSBQb2x5bWVyLlBhdGguZ2V0KHRoaXMsIHBhdGgpO1xuICAgICAgICAgICAgcGF0aCA9IC8qKiBAdHlwZSB7c3RyaW5nfSAqLyAoUG9seW1lci5QYXRoLnNldCh0aGlzLCBwYXRoLCB2YWx1ZSkpO1xuICAgICAgICAgICAgLy8gVXNlIHByb3BlcnR5LWFjY2Vzc29yJ3Mgc2ltcGxlciBkaXJ0eSBjaGVja1xuICAgICAgICAgICAgaWYgKCFwYXRoIHx8ICFzdXBlci5fc2hvdWxkUHJvcGVydHlDaGFuZ2UocGF0aCwgdmFsdWUsIG9sZCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9fZGF0YUhhc1BhdGhzID0gdHJ1ZTtcbiAgICAgICAgICBpZiAodGhpcy5fc2V0UGVuZGluZ1Byb3BlcnR5KC8qKkB0eXBle3N0cmluZ30qLyhwYXRoKSwgdmFsdWUsIHNob3VsZE5vdGlmeSkpIHtcbiAgICAgICAgICAgIGNvbXB1dGVMaW5rZWRQYXRocyh0aGlzLCBwYXRoLCB2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHRoaXMuX19kYXRhSGFzQWNjZXNzb3IgJiYgdGhpcy5fX2RhdGFIYXNBY2Nlc3NvcltwYXRoXSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NldFBlbmRpbmdQcm9wZXJ0eSgvKipAdHlwZXtzdHJpbmd9Ki8ocGF0aCksIHZhbHVlLCBzaG91bGROb3RpZnkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzW3BhdGhdID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBBcHBsaWVzIGEgdmFsdWUgdG8gYSBub24tUG9seW1lciBlbGVtZW50L25vZGUncyBwcm9wZXJ0eS5cbiAgICAgICAqXG4gICAgICAgKiBUaGUgaW1wbGVtZW50YXRpb24gbWFrZXMgYSBiZXN0LWVmZm9ydCBhdCBiaW5kaW5nIGludGVyb3A6XG4gICAgICAgKiBTb21lIG5hdGl2ZSBlbGVtZW50IHByb3BlcnRpZXMgaGF2ZSBzaWRlLWVmZmVjdHMgd2hlblxuICAgICAgICogcmUtc2V0dGluZyB0aGUgc2FtZSB2YWx1ZSAoZS5nLiBzZXR0aW5nIGA8aW5wdXQ+LnZhbHVlYCByZXNldHMgdGhlXG4gICAgICAgKiBjdXJzb3IgcG9zaXRpb24pLCBzbyB3ZSBkbyBhIGRpcnR5LWNoZWNrIGJlZm9yZSBzZXR0aW5nIHRoZSB2YWx1ZS5cbiAgICAgICAqIEhvd2V2ZXIsIGZvciBiZXR0ZXIgaW50ZXJvcCB3aXRoIG5vbi1Qb2x5bWVyIGN1c3RvbSBlbGVtZW50cyB0aGF0XG4gICAgICAgKiBhY2NlcHQgb2JqZWN0cywgd2UgZXhwbGljaXRseSByZS1zZXQgb2JqZWN0IGNoYW5nZXMgY29taW5nIGZyb20gdGhlXG4gICAgICAgKiBQb2x5bWVyIHdvcmxkICh3aGljaCBtYXkgaW5jbHVkZSBkZWVwIG9iamVjdCBjaGFuZ2VzIHdpdGhvdXQgdGhlXG4gICAgICAgKiB0b3AgcmVmZXJlbmNlIGNoYW5naW5nKSwgZXJyaW5nIG9uIHRoZSBzaWRlIG9mIHByb3ZpZGluZyBtb3JlXG4gICAgICAgKiBpbmZvcm1hdGlvbi5cbiAgICAgICAqXG4gICAgICAgKiBVc2VycyBtYXkgb3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gcHJvdmlkZSBhbHRlcm5hdGUgYXBwcm9hY2hlcy5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgVGhlIG5vZGUgdG8gc2V0IGEgcHJvcGVydHkgb25cbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wIFRoZSBwcm9wZXJ0eSB0byBzZXRcbiAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldFxuICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICovXG4gICAgICBfc2V0VW5tYW5hZ2VkUHJvcGVydHlUb05vZGUobm9kZSwgcHJvcCwgdmFsdWUpIHtcbiAgICAgICAgLy8gSXQgaXMgYSBqdWRnbWVudCBjYWxsIHRoYXQgcmVzZXR0aW5nIHByaW1pdGl2ZXMgaXNcbiAgICAgICAgLy8gXCJiYWRcIiBhbmQgcmVzZXR0aW5ncyBvYmplY3RzIGlzIGFsc28gXCJnb29kXCI7IGFsdGVybmF0aXZlbHkgd2UgY291bGRcbiAgICAgICAgLy8gaW1wbGVtZW50IGEgd2hpdGVsaXN0IG9mIHRhZyAmIHByb3BlcnR5IHZhbHVlcyB0aGF0IHNob3VsZCBuZXZlclxuICAgICAgICAvLyBiZSByZXNldCAoZS5nLiA8aW5wdXQ+LnZhbHVlICYmIDxzZWxlY3Q+LnZhbHVlKVxuICAgICAgICBpZiAodmFsdWUgIT09IG5vZGVbcHJvcF0gfHwgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnKSB7XG4gICAgICAgICAgbm9kZVtwcm9wXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogT3ZlcnJpZGVzIHRoZSBgUHJvcGVydHlBY2Nlc3NvcnNgIGltcGxlbWVudGF0aW9uIHRvIGludHJvZHVjZSBzcGVjaWFsXG4gICAgICAgKiBkaXJ0eSBjaGVjayBsb2dpYyBkZXBlbmRpbmcgb24gdGhlIHByb3BlcnR5ICYgdmFsdWUgYmVpbmcgc2V0OlxuICAgICAgICpcbiAgICAgICAqIDEuIEFueSB2YWx1ZSBzZXQgdG8gYSBwYXRoIChlLmcuICdvYmoucHJvcCc6IDQyIG9yICdvYmoucHJvcCc6IHsuLi59KVxuICAgICAgICogICAgU3RvcmVkIGluIGBfX2RhdGFUZW1wYCwgZGlydHkgY2hlY2tlZCBhZ2FpbnN0IGBfX2RhdGFUZW1wYFxuICAgICAgICogMi4gT2JqZWN0IHNldCB0byBzaW1wbGUgcHJvcGVydHkgKGUuZy4gJ3Byb3AnOiB7Li4ufSlcbiAgICAgICAqICAgIFN0b3JlZCBpbiBgX19kYXRhVGVtcGAgYW5kIGBfX2RhdGFgLCBkaXJ0eSBjaGVja2VkIGFnYWluc3RcbiAgICAgICAqICAgIGBfX2RhdGFUZW1wYCBieSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIG9mIGBfc2hvdWxkUHJvcGVydHlDaGFuZ2VgXG4gICAgICAgKiAzLiBQcmltaXRpdmUgdmFsdWUgc2V0IHRvIHNpbXBsZSBwcm9wZXJ0eSAoZS5nLiAncHJvcCc6IDQyKVxuICAgICAgICogICAgU3RvcmVkIGluIGBfX2RhdGFgLCBkaXJ0eSBjaGVja2VkIGFnYWluc3QgYF9fZGF0YWBcbiAgICAgICAqXG4gICAgICAgKiBUaGUgZGlydHktY2hlY2sgaXMgaW1wb3J0YW50IHRvIHByZXZlbnQgY3ljbGVzIGR1ZSB0byB0d28td2F5XG4gICAgICAgKiBub3RpZmljYXRpb24sIGJ1dCBwYXRocyBhbmQgb2JqZWN0cyBhcmUgb25seSBkaXJ0eSBjaGVja2VkIGFnYWluc3QgYW55XG4gICAgICAgKiBwcmV2aW91cyB2YWx1ZSBzZXQgZHVyaW5nIHRoaXMgdHVybiB2aWEgYSBcInRlbXBvcmFyeSBjYWNoZVwiIHRoYXQgaXNcbiAgICAgICAqIGNsZWFyZWQgd2hlbiB0aGUgbGFzdCBgX3Byb3BlcnRpZXNDaGFnZWRgIGV4aXRzLiBUaGlzIGlzIHNvOlxuICAgICAgICogYS4gYW55IGNhY2hlZCBhcnJheSBwYXRocyAoZS5nLiAnYXJyYXkuMy5wcm9wJykgbWF5IGJlIGludmFsaWRhdGVkXG4gICAgICAgKiAgICBkdWUgdG8gYXJyYXkgbXV0YXRpb25zIGxpa2Ugc2hpZnQvdW5zaGlmdC9zcGxpY2U7IHRoaXMgaXMgZmluZVxuICAgICAgICogICAgc2luY2UgcGF0aCBjaGFuZ2VzIGFyZSBkaXJ0eS1jaGVja2VkIGF0IHVzZXIgZW50cnkgcG9pbnRzIGxpa2UgYHNldGBcbiAgICAgICAqIGIuIGRpcnR5LWNoZWNraW5nIGZvciBvYmplY3RzIG9ubHkgbGFzdHMgb25lIHR1cm4gdG8gYWxsb3cgdGhlIHVzZXJcbiAgICAgICAqICAgIHRvIG11dGF0ZSB0aGUgb2JqZWN0IGluLXBsYWNlIGFuZCByZS1zZXQgaXQgd2l0aCB0aGUgc2FtZSBpZGVudGl0eVxuICAgICAgICogICAgYW5kIGhhdmUgYWxsIHN1Yi1wcm9wZXJ0aWVzIHJlLXByb3BhZ2F0ZWQgaW4gYSBzdWJzZXF1ZW50IHR1cm4uXG4gICAgICAgKlxuICAgICAgICogVGhlIHRlbXAgY2FjaGUgaXMgbm90IG5lY2Vzc2FyaWx5IHN1ZmZpY2llbnQgdG8gcHJldmVudCBpbnZhbGlkIGFycmF5XG4gICAgICAgKiBwYXRocywgc2luY2UgYSBzcGxpY2UgY2FuIGhhcHBlbiBkdXJpbmcgdGhlIHNhbWUgdHVybiAod2l0aCBwYXRob2xvZ2ljYWxcbiAgICAgICAqIHVzZXIgY29kZSk7IHdlIGNvdWxkIGludHJvZHVjZSBhIFwiZml4dXBcIiBmb3IgdGVtcG9yYXJpbHkgY2FjaGVkIGFycmF5XG4gICAgICAgKiBwYXRocyBpZiBuZWVkZWQ6IGh0dHBzOi8vZ2l0aHViLmNvbS9Qb2x5bWVyL3BvbHltZXIvaXNzdWVzLzQyMjdcbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgTmFtZSBvZiB0aGUgcHJvcGVydHlcbiAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgdG8gc2V0XG4gICAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBzaG91bGROb3RpZnkgVHJ1ZSBpZiBwcm9wZXJ0eSBzaG91bGQgZmlyZSBub3RpZmljYXRpb25cbiAgICAgICAqICAgZXZlbnQgKGFwcGxpZXMgb25seSBmb3IgYG5vdGlmeTogdHJ1ZWAgcHJvcGVydGllcylcbiAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGUgcHJvcGVydHkgY2hhbmdlZFxuICAgICAgICogQG92ZXJyaWRlXG4gICAgICAgKi9cbiAgICAgIF9zZXRQZW5kaW5nUHJvcGVydHkocHJvcGVydHksIHZhbHVlLCBzaG91bGROb3RpZnkpIHtcbiAgICAgICAgbGV0IGlzUGF0aCA9IHRoaXMuX19kYXRhSGFzUGF0aHMgJiYgUG9seW1lci5QYXRoLmlzUGF0aChwcm9wZXJ0eSk7XG4gICAgICAgIGxldCBwcmV2UHJvcHMgPSBpc1BhdGggPyB0aGlzLl9fZGF0YVRlbXAgOiB0aGlzLl9fZGF0YTtcbiAgICAgICAgaWYgKHRoaXMuX3Nob3VsZFByb3BlcnR5Q2hhbmdlKHByb3BlcnR5LCB2YWx1ZSwgcHJldlByb3BzW3Byb3BlcnR5XSkpIHtcbiAgICAgICAgICBpZiAoIXRoaXMuX19kYXRhUGVuZGluZykge1xuICAgICAgICAgICAgdGhpcy5fX2RhdGFQZW5kaW5nID0ge307XG4gICAgICAgICAgICB0aGlzLl9fZGF0YU9sZCA9IHt9O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBFbnN1cmUgb2xkIGlzIGNhcHR1cmVkIGZyb20gdGhlIGxhc3QgdHVyblxuICAgICAgICAgIGlmICghKHByb3BlcnR5IGluIHRoaXMuX19kYXRhT2xkKSkge1xuICAgICAgICAgICAgdGhpcy5fX2RhdGFPbGRbcHJvcGVydHldID0gdGhpcy5fX2RhdGFbcHJvcGVydHldO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBQYXRocyBhcmUgc3RvcmVkIGluIHRlbXBvcmFyeSBjYWNoZSAoY2xlYXJlZCBhdCBlbmQgb2YgdHVybiksXG4gICAgICAgICAgLy8gd2hpY2ggaXMgdXNlZCBmb3IgZGlydHktY2hlY2tpbmcsIGFsbCBvdGhlcnMgc3RvcmVkIGluIF9fZGF0YVxuICAgICAgICAgIGlmIChpc1BhdGgpIHtcbiAgICAgICAgICAgIHRoaXMuX19kYXRhVGVtcFtwcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fX2RhdGFbcHJvcGVydHldID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIEFsbCBjaGFuZ2VzIGdvIGludG8gcGVuZGluZyBwcm9wZXJ0eSBiYWcsIHBhc3NlZCB0byBfcHJvcGVydGllc0NoYW5nZWRcbiAgICAgICAgICB0aGlzLl9fZGF0YVBlbmRpbmdbcHJvcGVydHldID0gdmFsdWU7XG4gICAgICAgICAgLy8gVHJhY2sgcHJvcGVydGllcyB0aGF0IHNob3VsZCBub3RpZnkgc2VwYXJhdGVseVxuICAgICAgICAgIGlmIChpc1BhdGggfHwgKHRoaXNbVFlQRVMuTk9USUZZXSAmJiB0aGlzW1RZUEVTLk5PVElGWV1bcHJvcGVydHldKSkge1xuICAgICAgICAgICAgdGhpcy5fX2RhdGFUb05vdGlmeSA9IHRoaXMuX19kYXRhVG9Ob3RpZnkgfHwge307XG4gICAgICAgICAgICB0aGlzLl9fZGF0YVRvTm90aWZ5W3Byb3BlcnR5XSA9IHNob3VsZE5vdGlmeTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIE92ZXJyaWRlcyBiYXNlIGltcGxlbWVudGF0aW9uIHRvIGVuc3VyZSBhbGwgYWNjZXNzb3JzIHNldCBgc2hvdWxkTm90aWZ5YFxuICAgICAgICogdG8gdHJ1ZSwgZm9yIHBlci1wcm9wZXJ0eSBub3RpZmljYXRpb24gdHJhY2tpbmcuXG4gICAgICAgKlxuICAgICAgICogQG92ZXJyaWRlXG4gICAgICAgKi9cbiAgICAgIF9zZXRQcm9wZXJ0eShwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuX3NldFBlbmRpbmdQcm9wZXJ0eShwcm9wZXJ0eSwgdmFsdWUsIHRydWUpKSB7XG4gICAgICAgICAgdGhpcy5faW52YWxpZGF0ZVByb3BlcnRpZXMoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIE92ZXJyaWRlcyBgUHJvcGVydHlBY2Nlc3NvcmAncyBkZWZhdWx0IGFzeW5jIHF1ZXVpbmcgb2ZcbiAgICAgICAqIGBfcHJvcGVydGllc0NoYW5nZWRgOiBpZiBgX19kYXRhUmVhZHlgIGlzIGZhbHNlIChoYXMgbm90IHlldCBiZWVuXG4gICAgICAgKiBtYW51YWxseSBmbHVzaGVkKSwgdGhlIGZ1bmN0aW9uIG5vLW9wczsgb3RoZXJ3aXNlIGZsdXNoZXNcbiAgICAgICAqIGBfcHJvcGVydGllc0NoYW5nZWRgIHN5bmNocm9ub3VzbHkuXG4gICAgICAgKlxuICAgICAgICogQG92ZXJyaWRlXG4gICAgICAgKi9cbiAgICAgIF9pbnZhbGlkYXRlUHJvcGVydGllcygpIHtcbiAgICAgICAgaWYgKHRoaXMuX19kYXRhUmVhZHkpIHtcbiAgICAgICAgICB0aGlzLl9mbHVzaFByb3BlcnRpZXMoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEVucXVldWVzIHRoZSBnaXZlbiBjbGllbnQgb24gYSBsaXN0IG9mIHBlbmRpbmcgY2xpZW50cywgd2hvc2VcbiAgICAgICAqIHBlbmRpbmcgcHJvcGVydHkgY2hhbmdlcyBjYW4gbGF0ZXIgYmUgZmx1c2hlZCB2aWEgYSBjYWxsIHRvXG4gICAgICAgKiBgX2ZsdXNoQ2xpZW50c2AuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNsaWVudCBQcm9wZXJ0eUVmZmVjdHMgY2xpZW50IHRvIGVucXVldWVcbiAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAqL1xuICAgICAgX2VucXVldWVDbGllbnQoY2xpZW50KSB7XG4gICAgICAgIHRoaXMuX19kYXRhUGVuZGluZ0NsaWVudHMgPSB0aGlzLl9fZGF0YVBlbmRpbmdDbGllbnRzIHx8IFtdO1xuICAgICAgICBpZiAoY2xpZW50ICE9PSB0aGlzKSB7XG4gICAgICAgICAgdGhpcy5fX2RhdGFQZW5kaW5nQ2xpZW50cy5wdXNoKGNsaWVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBGbHVzaGVzIGFueSBjbGllbnRzIHByZXZpb3VzbHkgZW5xdWV1ZWQgdmlhIGBfZW5xdWV1ZUNsaWVudGAsIGNhdXNpbmdcbiAgICAgICAqIHRoZWlyIGBfZmx1c2hQcm9wZXJ0aWVzYCBtZXRob2QgdG8gcnVuLlxuICAgICAgICpcbiAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAqL1xuICAgICAgX2ZsdXNoQ2xpZW50cygpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9fZGF0YUNsaWVudHNSZWFkeSkge1xuICAgICAgICAgIHRoaXMuX19kYXRhQ2xpZW50c1JlYWR5ID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLl9yZWFkeUNsaWVudHMoKTtcbiAgICAgICAgICAvLyBPdmVycmlkZSBwb2ludCB3aGVyZSBhY2Nlc3NvcnMgYXJlIHR1cm5lZCBvbjsgaW1wb3J0YW50bHksXG4gICAgICAgICAgLy8gdGhpcyBpcyBhZnRlciBjbGllbnRzIGhhdmUgZnVsbHkgcmVhZGllZCwgcHJvdmlkaW5nIGEgZ3VhcmFudGVlXG4gICAgICAgICAgLy8gdGhhdCBhbnkgcHJvcGVydHkgZWZmZWN0cyBvY2N1ciBvbmx5IGFmdGVyIGFsbCBjbGllbnRzIGFyZSByZWFkeS5cbiAgICAgICAgICB0aGlzLl9fZGF0YVJlYWR5ID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9fZW5hYmxlT3JGbHVzaENsaWVudHMoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBOT1RFOiBXZSBlbnN1cmUgY2xpZW50cyBlaXRoZXIgZW5hYmxlIG9yIGZsdXNoIGFzIGFwcHJvcHJpYXRlLiBUaGlzXG4gICAgICAvLyBoYW5kbGVzIHR3byBjb3JuZXIgY2FzZXM6XG4gICAgICAvLyAoMSkgY2xpZW50cyBmbHVzaCBwcm9wZXJseSB3aGVuIGNvbm5lY3RlZC9lbmFibGVkIGJlZm9yZSB0aGUgaG9zdFxuICAgICAgLy8gZW5hYmxlczsgZS5nLlxuICAgICAgLy8gICAoYSkgVGVtcGxhdGl6ZSBzdGFtcHMgd2l0aCBubyBwcm9wZXJ0aWVzIGFuZCBkb2VzIG5vdCBmbHVzaCBhbmRcbiAgICAgIC8vICAgKGIpIHRoZSBpbnN0YW5jZSBpcyBpbnNlcnRlZCBpbnRvIGRvbSBhbmRcbiAgICAgIC8vICAgKGMpIHRoZW4gdGhlIGluc3RhbmNlIGZsdXNoZXMuXG4gICAgICAvLyAoMikgY2xpZW50cyBlbmFibGUgcHJvcGVybHkgd2hlbiBub3QgY29ubmVjdGVkL2VuYWJsZWQgd2hlbiB0aGUgaG9zdFxuICAgICAgLy8gZmx1c2hlczsgZS5nLlxuICAgICAgLy8gICAoYSkgYSB0ZW1wbGF0ZSBpcyBydW50aW1lIHN0YW1wZWQgYW5kIG5vdCB5ZXQgY29ubmVjdGVkL2VuYWJsZWRcbiAgICAgIC8vICAgKGIpIGEgaG9zdCBzZXRzIGEgcHJvcGVydHksIGNhdXNpbmcgc3RhbXBlZCBkb20gdG8gZmx1c2hcbiAgICAgIC8vICAgKGMpIHRoZSBzdGFtcGVkIGRvbSBlbmFibGVzLlxuICAgICAgX19lbmFibGVPckZsdXNoQ2xpZW50cygpIHtcbiAgICAgICAgbGV0IGNsaWVudHMgPSB0aGlzLl9fZGF0YVBlbmRpbmdDbGllbnRzO1xuICAgICAgICBpZiAoY2xpZW50cykge1xuICAgICAgICAgIHRoaXMuX19kYXRhUGVuZGluZ0NsaWVudHMgPSBudWxsO1xuICAgICAgICAgIGZvciAobGV0IGk9MDsgaSA8IGNsaWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjbGllbnQgPSBjbGllbnRzW2ldO1xuICAgICAgICAgICAgaWYgKCFjbGllbnQuX19kYXRhRW5hYmxlZCkge1xuICAgICAgICAgICAgICBjbGllbnQuX2VuYWJsZVByb3BlcnRpZXMoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2xpZW50Ll9fZGF0YVBlbmRpbmcpIHtcbiAgICAgICAgICAgICAgY2xpZW50Ll9mbHVzaFByb3BlcnRpZXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBQZXJmb3JtIGFueSBpbml0aWFsIHNldHVwIG9uIGNsaWVudCBkb20uIENhbGxlZCBiZWZvcmUgdGhlIGZpcnN0XG4gICAgICAgKiBgX2ZsdXNoUHJvcGVydGllc2AgY2FsbCBvbiBjbGllbnQgZG9tIGFuZCBiZWZvcmUgYW55IGVsZW1lbnRcbiAgICAgICAqIG9ic2VydmVycyBhcmUgY2FsbGVkLlxuICAgICAgICpcbiAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAqL1xuICAgICAgX3JlYWR5Q2xpZW50cygpIHtcbiAgICAgICAgdGhpcy5fX2VuYWJsZU9yRmx1c2hDbGllbnRzKCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogU2V0cyBhIGJhZyBvZiBwcm9wZXJ0eSBjaGFuZ2VzIHRvIHRoaXMgaW5zdGFuY2UsIGFuZFxuICAgICAgICogc3luY2hyb25vdXNseSBwcm9jZXNzZXMgYWxsIGVmZmVjdHMgb2YgdGhlIHByb3BlcnRpZXMgYXMgYSBiYXRjaC5cbiAgICAgICAqXG4gICAgICAgKiBQcm9wZXJ0eSBuYW1lcyBtdXN0IGJlIHNpbXBsZSBwcm9wZXJ0aWVzLCBub3QgcGF0aHMuICBCYXRjaGVkXG4gICAgICAgKiBwYXRoIHByb3BhZ2F0aW9uIGlzIG5vdCBzdXBwb3J0ZWQuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzIEJhZyBvZiBvbmUgb3IgbW9yZSBrZXktdmFsdWUgcGFpcnMgd2hvc2Uga2V5IGlzXG4gICAgICAgKiAgIGEgcHJvcGVydHkgYW5kIHZhbHVlIGlzIHRoZSBuZXcgdmFsdWUgdG8gc2V0IGZvciB0aGF0IHByb3BlcnR5LlxuICAgICAgICogQHBhcmFtIHtib29sZWFuPX0gc2V0UmVhZE9ubHkgV2hlbiB0cnVlLCBhbnkgcHJpdmF0ZSB2YWx1ZXMgc2V0IGluXG4gICAgICAgKiAgIGBwcm9wc2Agd2lsbCBiZSBzZXQuIEJ5IGRlZmF1bHQsIGBzZXRQcm9wZXJ0aWVzYCB3aWxsIG5vdCBzZXRcbiAgICAgICAqICAgYHJlYWRPbmx5OiB0cnVlYCByb290IHByb3BlcnRpZXMuXG4gICAgICAgKiBAcHVibGljXG4gICAgICAgKi9cbiAgICAgIHNldFByb3BlcnRpZXMocHJvcHMsIHNldFJlYWRPbmx5KSB7XG4gICAgICAgIGZvciAobGV0IHBhdGggaW4gcHJvcHMpIHtcbiAgICAgICAgICBpZiAoc2V0UmVhZE9ubHkgfHwgIXRoaXNbVFlQRVMuUkVBRF9PTkxZXSB8fCAhdGhpc1tUWVBFUy5SRUFEX09OTFldW3BhdGhdKSB7XG4gICAgICAgICAgICAvL1RPRE8oa3NjaGFhZik6IGV4cGxpY2l0bHkgZGlzYWxsb3cgcGF0aHMgaW4gc2V0UHJvcGVydHk/XG4gICAgICAgICAgICAvLyB3aWxkY2FyZCBvYnNlcnZlcnMgY3VycmVudGx5IG9ubHkgcGFzcyB0aGUgZmlyc3QgY2hhbmdlZCBwYXRoXG4gICAgICAgICAgICAvLyBpbiB0aGUgYGluZm9gIG9iamVjdCwgYW5kIHlvdSBjb3VsZCBkbyBzb21lIG9kZCB0aGluZ3MgYmF0Y2hpbmdcbiAgICAgICAgICAgIC8vIHBhdGhzLCBlLmcuIHsnZm9vLmJhcic6IHsuLi59LCAnZm9vJzogbnVsbH1cbiAgICAgICAgICAgIHRoaXMuX3NldFBlbmRpbmdQcm9wZXJ0eU9yUGF0aChwYXRoLCBwcm9wc1twYXRoXSwgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2ludmFsaWRhdGVQcm9wZXJ0aWVzKCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogT3ZlcnJpZGVzIGBQcm9wZXJ0eUFjY2Vzc29yc2Agc28gdGhhdCBwcm9wZXJ0eSBhY2Nlc3NvclxuICAgICAgICogc2lkZSBlZmZlY3RzIGFyZSBub3QgZW5hYmxlZCB1bnRpbCBhZnRlciBjbGllbnQgZG9tIGlzIGZ1bGx5IHJlYWR5LlxuICAgICAgICogQWxzbyBjYWxscyBgX2ZsdXNoQ2xpZW50c2AgY2FsbGJhY2sgdG8gZW5zdXJlIGNsaWVudCBkb20gaXMgZW5hYmxlZFxuICAgICAgICogdGhhdCB3YXMgbm90IGVuYWJsZWQgYXMgYSByZXN1bHQgb2YgZmx1c2hpbmcgcHJvcGVydGllcy5cbiAgICAgICAqXG4gICAgICAgKiBAb3ZlcnJpZGVcbiAgICAgICAqL1xuICAgICAgcmVhZHkoKSB7XG4gICAgICAgIC8vIEl0IGlzIGltcG9ydGFudCB0aGF0IGBzdXBlci5yZWFkeSgpYCBpcyBub3QgY2FsbGVkIGhlcmUgYXMgaXRcbiAgICAgICAgLy8gaW1tZWRpYXRlbHkgdHVybnMgb24gYWNjZXNzb3JzLiBJbnN0ZWFkLCB3ZSB3YWl0IHVudGlsIGByZWFkeUNsaWVudHNgXG4gICAgICAgIC8vIHRvIGVuYWJsZSBhY2Nlc3NvcnMgdG8gcHJvdmlkZSBhIGd1YXJhbnRlZSB0aGF0IGNsaWVudHMgYXJlIHJlYWR5XG4gICAgICAgIC8vIGJlZm9yZSBwcm9jZXNzaW5nIGFueSBhY2Nlc3NvcnMgc2lkZSBlZmZlY3RzLlxuICAgICAgICB0aGlzLl9mbHVzaFByb3BlcnRpZXMoKTtcbiAgICAgICAgLy8gSWYgbm8gZGF0YSB3YXMgcGVuZGluZywgYF9mbHVzaFByb3BlcnRpZXNgIHdpbGwgbm90IGBmbHVzaENsaWVudHNgXG4gICAgICAgIC8vIHNvIGVuc3VyZSB0aGlzIGlzIGRvbmUuXG4gICAgICAgIGlmICghdGhpcy5fX2RhdGFDbGllbnRzUmVhZHkpIHtcbiAgICAgICAgICB0aGlzLl9mbHVzaENsaWVudHMoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBCZWZvcmUgcmVhZHksIGNsaWVudCBub3RpZmljYXRpb25zIGRvIG5vdCB0cmlnZ2VyIF9mbHVzaFByb3BlcnRpZXMuXG4gICAgICAgIC8vIFRoZXJlZm9yZSBhIGZsdXNoIGlzIG5lY2Vzc2FyeSBoZXJlIGlmIGRhdGEgaGFzIGJlZW4gc2V0LlxuICAgICAgICBpZiAodGhpcy5fX2RhdGFQZW5kaW5nKSB7XG4gICAgICAgICAgdGhpcy5fZmx1c2hQcm9wZXJ0aWVzKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBJbXBsZW1lbnRzIGBQcm9wZXJ0eUFjY2Vzc29yc2AncyBwcm9wZXJ0aWVzIGNoYW5nZWQgY2FsbGJhY2suXG4gICAgICAgKlxuICAgICAgICogUnVucyBlYWNoIGNsYXNzIG9mIGVmZmVjdHMgZm9yIHRoZSBiYXRjaCBvZiBjaGFuZ2VkIHByb3BlcnRpZXMgaW5cbiAgICAgICAqIGEgc3BlY2lmaWMgb3JkZXIgKGNvbXB1dGUsIHByb3BhZ2F0ZSwgcmVmbGVjdCwgb2JzZXJ2ZSwgbm90aWZ5KS5cbiAgICAgICAqXG4gICAgICAgKiBAb3ZlcnJpZGVcbiAgICAgICAqL1xuICAgICAgX3Byb3BlcnRpZXNDaGFuZ2VkKGN1cnJlbnRQcm9wcywgY2hhbmdlZFByb3BzLCBvbGRQcm9wcykge1xuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIGxldCBjID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoY2hhbmdlZFByb3BzIHx8IHt9KTtcbiAgICAgICAgLy8gd2luZG93LmRlYnVnICYmIGNvbnNvbGUuZ3JvdXAodGhpcy5sb2NhbE5hbWUgKyAnIycgKyB0aGlzLmlkICsgJzogJyArIGMpO1xuICAgICAgICAvLyBpZiAod2luZG93LmRlYnVnKSB7IGRlYnVnZ2VyOyB9XG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgbGV0IGhhc1BhdGhzID0gdGhpcy5fX2RhdGFIYXNQYXRocztcbiAgICAgICAgdGhpcy5fX2RhdGFIYXNQYXRocyA9IGZhbHNlO1xuICAgICAgICAvLyBDb21wdXRlIHByb3BlcnRpZXNcbiAgICAgICAgcnVuQ29tcHV0ZWRFZmZlY3RzKHRoaXMsIGNoYW5nZWRQcm9wcywgb2xkUHJvcHMsIGhhc1BhdGhzKTtcbiAgICAgICAgLy8gQ2xlYXIgbm90aWZ5IHByb3BlcnRpZXMgcHJpb3IgdG8gcG9zc2libGUgcmVlbnRyeSAocHJvcGFnYXRlLCBvYnNlcnZlKSxcbiAgICAgICAgLy8gYnV0IGFmdGVyIGNvbXB1dGluZyBlZmZlY3RzIGhhdmUgYSBjaGFuY2UgdG8gYWRkIHRvIHRoZW1cbiAgICAgICAgbGV0IG5vdGlmeVByb3BzID0gdGhpcy5fX2RhdGFUb05vdGlmeTtcbiAgICAgICAgdGhpcy5fX2RhdGFUb05vdGlmeSA9IG51bGw7XG4gICAgICAgIC8vIFByb3BhZ2F0ZSBwcm9wZXJ0aWVzIHRvIGNsaWVudHNcbiAgICAgICAgdGhpcy5fcHJvcGFnYXRlUHJvcGVydHlDaGFuZ2VzKGNoYW5nZWRQcm9wcywgb2xkUHJvcHMsIGhhc1BhdGhzKTtcbiAgICAgICAgLy8gRmx1c2ggY2xpZW50c1xuICAgICAgICB0aGlzLl9mbHVzaENsaWVudHMoKTtcbiAgICAgICAgLy8gUmVmbGVjdCBwcm9wZXJ0aWVzXG4gICAgICAgIHJ1bkVmZmVjdHModGhpcywgdGhpc1tUWVBFUy5SRUZMRUNUXSwgY2hhbmdlZFByb3BzLCBvbGRQcm9wcywgaGFzUGF0aHMpO1xuICAgICAgICAvLyBPYnNlcnZlIHByb3BlcnRpZXNcbiAgICAgICAgcnVuRWZmZWN0cyh0aGlzLCB0aGlzW1RZUEVTLk9CU0VSVkVdLCBjaGFuZ2VkUHJvcHMsIG9sZFByb3BzLCBoYXNQYXRocyk7XG4gICAgICAgIC8vIE5vdGlmeSBwcm9wZXJ0aWVzIHRvIGhvc3RcbiAgICAgICAgaWYgKG5vdGlmeVByb3BzKSB7XG4gICAgICAgICAgcnVuTm90aWZ5RWZmZWN0cyh0aGlzLCBub3RpZnlQcm9wcywgY2hhbmdlZFByb3BzLCBvbGRQcm9wcywgaGFzUGF0aHMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENsZWFyIHRlbXBvcmFyeSBjYWNoZSBhdCBlbmQgb2YgdHVyblxuICAgICAgICBpZiAodGhpcy5fX2RhdGFDb3VudGVyID09IDEpIHtcbiAgICAgICAgICB0aGlzLl9fZGF0YVRlbXAgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIHdpbmRvdy5kZWJ1ZyAmJiBjb25zb2xlLmdyb3VwRW5kKHRoaXMubG9jYWxOYW1lICsgJyMnICsgdGhpcy5pZCArICc6ICcgKyBjKTtcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENhbGxlZCB0byBwcm9wYWdhdGUgYW55IHByb3BlcnR5IGNoYW5nZXMgdG8gc3RhbXBlZCB0ZW1wbGF0ZSBub2Rlc1xuICAgICAgICogbWFuYWdlZCBieSB0aGlzIGVsZW1lbnQuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNoYW5nZWRQcm9wcyBCYWcgb2YgY2hhbmdlZCBwcm9wZXJ0aWVzXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gb2xkUHJvcHMgQmFnIG9mIHByZXZpb3VzIHZhbHVlcyBmb3IgY2hhbmdlZCBwcm9wZXJ0aWVzXG4gICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhhc1BhdGhzIFRydWUgd2l0aCBgcHJvcHNgIGNvbnRhaW5zIG9uZSBvciBtb3JlIHBhdGhzXG4gICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgKi9cbiAgICAgIF9wcm9wYWdhdGVQcm9wZXJ0eUNoYW5nZXMoY2hhbmdlZFByb3BzLCBvbGRQcm9wcywgaGFzUGF0aHMpIHtcbiAgICAgICAgaWYgKHRoaXNbVFlQRVMuUFJPUEFHQVRFXSkge1xuICAgICAgICAgIHJ1bkVmZmVjdHModGhpcywgdGhpc1tUWVBFUy5QUk9QQUdBVEVdLCBjaGFuZ2VkUHJvcHMsIG9sZFByb3BzLCBoYXNQYXRocyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRlbXBsYXRlSW5mbyA9IHRoaXMuX190ZW1wbGF0ZUluZm87XG4gICAgICAgIHdoaWxlICh0ZW1wbGF0ZUluZm8pIHtcbiAgICAgICAgICBydW5FZmZlY3RzKHRoaXMsIHRlbXBsYXRlSW5mby5wcm9wZXJ0eUVmZmVjdHMsIGNoYW5nZWRQcm9wcywgb2xkUHJvcHMsXG4gICAgICAgICAgICBoYXNQYXRocywgdGVtcGxhdGVJbmZvLm5vZGVMaXN0KTtcbiAgICAgICAgICB0ZW1wbGF0ZUluZm8gPSB0ZW1wbGF0ZUluZm8ubmV4dFRlbXBsYXRlSW5mbztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEFsaWFzZXMgb25lIGRhdGEgcGF0aCBhcyBhbm90aGVyLCBzdWNoIHRoYXQgcGF0aCBub3RpZmljYXRpb25zIGZyb20gb25lXG4gICAgICAgKiBhcmUgcm91dGVkIHRvIHRoZSBvdGhlci5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZyB8ICFBcnJheTxzdHJpbmd8bnVtYmVyPn0gdG8gVGFyZ2V0IHBhdGggdG8gbGluay5cbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgIUFycmF5PHN0cmluZ3xudW1iZXI+fSBmcm9tIFNvdXJjZSBwYXRoIHRvIGxpbmsuXG4gICAgICAgKiBAcHVibGljXG4gICAgICAgKi9cbiAgICAgIGxpbmtQYXRocyh0bywgZnJvbSkge1xuICAgICAgICB0byA9IFBvbHltZXIuUGF0aC5ub3JtYWxpemUodG8pO1xuICAgICAgICBmcm9tID0gUG9seW1lci5QYXRoLm5vcm1hbGl6ZShmcm9tKTtcbiAgICAgICAgdGhpcy5fX2RhdGFMaW5rZWRQYXRocyA9IHRoaXMuX19kYXRhTGlua2VkUGF0aHMgfHwge307XG4gICAgICAgIHRoaXMuX19kYXRhTGlua2VkUGF0aHNbdG9dID0gZnJvbTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZW1vdmVzIGEgZGF0YSBwYXRoIGFsaWFzIHByZXZpb3VzbHkgZXN0YWJsaXNoZWQgd2l0aCBgX2xpbmtQYXRoc2AuXG4gICAgICAgKlxuICAgICAgICogTm90ZSwgdGhlIHBhdGggdG8gdW5saW5rIHNob3VsZCBiZSB0aGUgdGFyZ2V0IChgdG9gKSB1c2VkIHdoZW5cbiAgICAgICAqIGxpbmtpbmcgdGhlIHBhdGhzLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgIUFycmF5PHN0cmluZ3xudW1iZXI+fSBwYXRoIFRhcmdldCBwYXRoIHRvIHVubGluay5cbiAgICAgICAqIEBwdWJsaWNcbiAgICAgICAqL1xuICAgICAgdW5saW5rUGF0aHMocGF0aCkge1xuICAgICAgICBwYXRoID0gUG9seW1lci5QYXRoLm5vcm1hbGl6ZShwYXRoKTtcbiAgICAgICAgaWYgKHRoaXMuX19kYXRhTGlua2VkUGF0aHMpIHtcbiAgICAgICAgICBkZWxldGUgdGhpcy5fX2RhdGFMaW5rZWRQYXRoc1twYXRoXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIE5vdGlmeSB0aGF0IGFuIGFycmF5IGhhcyBjaGFuZ2VkLlxuICAgICAgICpcbiAgICAgICAqIEV4YW1wbGU6XG4gICAgICAgKlxuICAgICAgICogICAgIHRoaXMuaXRlbXMgPSBbIHtuYW1lOiAnSmltJ30sIHtuYW1lOiAnVG9kZCd9LCB7bmFtZTogJ0JpbGwnfSBdO1xuICAgICAgICogICAgIC4uLlxuICAgICAgICogICAgIHRoaXMuaXRlbXMuc3BsaWNlKDEsIDEsIHtuYW1lOiAnU2FtJ30pO1xuICAgICAgICogICAgIHRoaXMuaXRlbXMucHVzaCh7bmFtZTogJ0JvYid9KTtcbiAgICAgICAqICAgICB0aGlzLm5vdGlmeVNwbGljZXMoJ2l0ZW1zJywgW1xuICAgICAgICogICAgICAgeyBpbmRleDogMSwgcmVtb3ZlZDogW3tuYW1lOiAnVG9kZCd9XSwgYWRkZWRDb3VudDogMSwgb2JlY3Q6IHRoaXMuaXRlbXMsIHR5cGU6ICdzcGxpY2UnIH0sXG4gICAgICAgKiAgICAgICB7IGluZGV4OiAzLCByZW1vdmVkOiBbXSwgYWRkZWRDb3VudDogMSwgb2JqZWN0OiB0aGlzLml0ZW1zLCB0eXBlOiAnc3BsaWNlJ31cbiAgICAgICAqICAgICBdKTtcbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBQYXRoIHRoYXQgc2hvdWxkIGJlIG5vdGlmaWVkLlxuICAgICAgICogQHBhcmFtIHtBcnJheX0gc3BsaWNlcyBBcnJheSBvZiBzcGxpY2UgcmVjb3JkcyBpbmRpY2F0aW5nIG9yZGVyZWRcbiAgICAgICAqICAgY2hhbmdlcyB0aGF0IG9jY3VycmVkIHRvIHRoZSBhcnJheS4gRWFjaCByZWNvcmQgc2hvdWxkIGhhdmUgdGhlXG4gICAgICAgKiAgIGZvbGxvd2luZyBmaWVsZHM6XG4gICAgICAgKiAgICAqIGluZGV4OiBpbmRleCBhdCB3aGljaCB0aGUgY2hhbmdlIG9jY3VycmVkXG4gICAgICAgKiAgICAqIHJlbW92ZWQ6IGFycmF5IG9mIGl0ZW1zIHRoYXQgd2VyZSByZW1vdmVkIGZyb20gdGhpcyBpbmRleFxuICAgICAgICogICAgKiBhZGRlZENvdW50OiBudW1iZXIgb2YgbmV3IGl0ZW1zIGFkZGVkIGF0IHRoaXMgaW5kZXhcbiAgICAgICAqICAgICogb2JqZWN0OiBhIHJlZmVyZW5jZSB0byB0aGUgYXJyYXkgaW4gcXVlc3Rpb25cbiAgICAgICAqICAgICogdHlwZTogdGhlIHN0cmluZyBsaXRlcmFsICdzcGxpY2UnXG4gICAgICAgKlxuICAgICAgICogICBOb3RlIHRoYXQgc3BsaWNlIHJlY29yZHMgX211c3RfIGJlIG5vcm1hbGl6ZWQgc3VjaCB0aGF0IHRoZXkgYXJlXG4gICAgICAgKiAgIHJlcG9ydGVkIGluIGluZGV4IG9yZGVyIChyYXcgcmVzdWx0cyBmcm9tIGBPYmplY3Qub2JzZXJ2ZWAgYXJlIG5vdFxuICAgICAgICogICBvcmRlcmVkIGFuZCBtdXN0IGJlIG5vcm1hbGl6ZWQvbWVyZ2VkIGJlZm9yZSBub3RpZnlpbmcpLlxuICAgICAgICogQHB1YmxpY1xuICAgICAgKi9cbiAgICAgIG5vdGlmeVNwbGljZXMocGF0aCwgc3BsaWNlcykge1xuICAgICAgICBsZXQgaW5mbyA9IHtwYXRoOiAnJ307XG4gICAgICAgIGxldCBhcnJheSA9IC8qKiBAdHlwZSB7QXJyYXl9ICovKFBvbHltZXIuUGF0aC5nZXQodGhpcywgcGF0aCwgaW5mbykpO1xuICAgICAgICBub3RpZnlTcGxpY2VzKHRoaXMsIGFycmF5LCBpbmZvLnBhdGgsIHNwbGljZXMpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENvbnZlbmllbmNlIG1ldGhvZCBmb3IgcmVhZGluZyBhIHZhbHVlIGZyb20gYSBwYXRoLlxuICAgICAgICpcbiAgICAgICAqIE5vdGUsIGlmIGFueSBwYXJ0IGluIHRoZSBwYXRoIGlzIHVuZGVmaW5lZCwgdGhpcyBtZXRob2QgcmV0dXJuc1xuICAgICAgICogYHVuZGVmaW5lZGAgKHRoaXMgbWV0aG9kIGRvZXMgbm90IHRocm93IHdoZW4gZGVyZWZlcmVuY2luZyB1bmRlZmluZWRcbiAgICAgICAqIHBhdGhzKS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0geyhzdHJpbmd8IUFycmF5PChzdHJpbmd8bnVtYmVyKT4pfSBwYXRoIFBhdGggdG8gdGhlIHZhbHVlXG4gICAgICAgKiAgIHRvIHJlYWQuICBUaGUgcGF0aCBtYXkgYmUgc3BlY2lmaWVkIGFzIGEgc3RyaW5nIChlLmcuIGBmb28uYmFyLmJhemApXG4gICAgICAgKiAgIG9yIGFuIGFycmF5IG9mIHBhdGggcGFydHMgKGUuZy4gYFsnZm9vLmJhcicsICdiYXonXWApLiAgTm90ZSB0aGF0XG4gICAgICAgKiAgIGJyYWNrZXRlZCBleHByZXNzaW9ucyBhcmUgbm90IHN1cHBvcnRlZDsgc3RyaW5nLWJhc2VkIHBhdGggcGFydHNcbiAgICAgICAqICAgKm11c3QqIGJlIHNlcGFyYXRlZCBieSBkb3RzLiAgTm90ZSB0aGF0IHdoZW4gZGVyZWZlcmVuY2luZyBhcnJheVxuICAgICAgICogICBpbmRpY2VzLCB0aGUgaW5kZXggbWF5IGJlIHVzZWQgYXMgYSBkb3R0ZWQgcGFydCBkaXJlY3RseVxuICAgICAgICogICAoZS5nLiBgdXNlcnMuMTIubmFtZWAgb3IgYFsndXNlcnMnLCAxMiwgJ25hbWUnXWApLlxuICAgICAgICogQHBhcmFtIHtPYmplY3Q9fSByb290IFJvb3Qgb2JqZWN0IGZyb20gd2hpY2ggdGhlIHBhdGggaXMgZXZhbHVhdGVkLlxuICAgICAgICogQHJldHVybiB7Kn0gVmFsdWUgYXQgdGhlIHBhdGgsIG9yIGB1bmRlZmluZWRgIGlmIGFueSBwYXJ0IG9mIHRoZSBwYXRoXG4gICAgICAgKiAgIGlzIHVuZGVmaW5lZC5cbiAgICAgICAqIEBwdWJsaWNcbiAgICAgICAqL1xuICAgICAgZ2V0KHBhdGgsIHJvb3QpIHtcbiAgICAgICAgcmV0dXJuIFBvbHltZXIuUGF0aC5nZXQocm9vdCB8fCB0aGlzLCBwYXRoKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDb252ZW5pZW5jZSBtZXRob2QgZm9yIHNldHRpbmcgYSB2YWx1ZSB0byBhIHBhdGggYW5kIG5vdGlmeWluZyBhbnlcbiAgICAgICAqIGVsZW1lbnRzIGJvdW5kIHRvIHRoZSBzYW1lIHBhdGguXG4gICAgICAgKlxuICAgICAgICogTm90ZSwgaWYgYW55IHBhcnQgaW4gdGhlIHBhdGggZXhjZXB0IGZvciB0aGUgbGFzdCBpcyB1bmRlZmluZWQsXG4gICAgICAgKiB0aGlzIG1ldGhvZCBkb2VzIG5vdGhpbmcgKHRoaXMgbWV0aG9kIGRvZXMgbm90IHRocm93IHdoZW5cbiAgICAgICAqIGRlcmVmZXJlbmNpbmcgdW5kZWZpbmVkIHBhdGhzKS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0geyhzdHJpbmd8IUFycmF5PChzdHJpbmd8bnVtYmVyKT4pfSBwYXRoIFBhdGggdG8gdGhlIHZhbHVlXG4gICAgICAgKiAgIHRvIHdyaXRlLiAgVGhlIHBhdGggbWF5IGJlIHNwZWNpZmllZCBhcyBhIHN0cmluZyAoZS5nLiBgJ2Zvby5iYXIuYmF6J2ApXG4gICAgICAgKiAgIG9yIGFuIGFycmF5IG9mIHBhdGggcGFydHMgKGUuZy4gYFsnZm9vLmJhcicsICdiYXonXWApLiAgTm90ZSB0aGF0XG4gICAgICAgKiAgIGJyYWNrZXRlZCBleHByZXNzaW9ucyBhcmUgbm90IHN1cHBvcnRlZDsgc3RyaW5nLWJhc2VkIHBhdGggcGFydHNcbiAgICAgICAqICAgKm11c3QqIGJlIHNlcGFyYXRlZCBieSBkb3RzLiAgTm90ZSB0aGF0IHdoZW4gZGVyZWZlcmVuY2luZyBhcnJheVxuICAgICAgICogICBpbmRpY2VzLCB0aGUgaW5kZXggbWF5IGJlIHVzZWQgYXMgYSBkb3R0ZWQgcGFydCBkaXJlY3RseVxuICAgICAgICogICAoZS5nLiBgJ3VzZXJzLjEyLm5hbWUnYCBvciBgWyd1c2VycycsIDEyLCAnbmFtZSddYCkuXG4gICAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIHNldCBhdCB0aGUgc3BlY2lmaWVkIHBhdGguXG4gICAgICAgKiBAcGFyYW0ge09iamVjdD19IHJvb3QgUm9vdCBvYmplY3QgZnJvbSB3aGljaCB0aGUgcGF0aCBpcyBldmFsdWF0ZWQuXG4gICAgICAgKiAgIFdoZW4gc3BlY2lmaWVkLCBubyBub3RpZmljYXRpb24gd2lsbCBvY2N1ci5cbiAgICAgICAqIEBwdWJsaWNcbiAgICAgICovXG4gICAgICBzZXQocGF0aCwgdmFsdWUsIHJvb3QpIHtcbiAgICAgICAgaWYgKHJvb3QpIHtcbiAgICAgICAgICBQb2x5bWVyLlBhdGguc2V0KHJvb3QsIHBhdGgsIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoIXRoaXNbVFlQRVMuUkVBRF9PTkxZXSB8fCAhdGhpc1tUWVBFUy5SRUFEX09OTFldWy8qKiBAdHlwZSB7c3RyaW5nfSAqLyhwYXRoKV0pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9zZXRQZW5kaW5nUHJvcGVydHlPclBhdGgocGF0aCwgdmFsdWUsIHRydWUpKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2ludmFsaWRhdGVQcm9wZXJ0aWVzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQWRkcyBpdGVtcyBvbnRvIHRoZSBlbmQgb2YgdGhlIGFycmF5IGF0IHRoZSBwYXRoIHNwZWNpZmllZC5cbiAgICAgICAqXG4gICAgICAgKiBUaGUgYXJndW1lbnRzIGFmdGVyIGBwYXRoYCBhbmQgcmV0dXJuIHZhbHVlIG1hdGNoIHRoYXQgb2ZcbiAgICAgICAqIGBBcnJheS5wcm90b3R5cGUucHVzaGAuXG4gICAgICAgKlxuICAgICAgICogVGhpcyBtZXRob2Qgbm90aWZpZXMgb3RoZXIgcGF0aHMgdG8gdGhlIHNhbWUgYXJyYXkgdGhhdCBhXG4gICAgICAgKiBzcGxpY2Ugb2NjdXJyZWQgdG8gdGhlIGFycmF5LlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFBhdGggdG8gYXJyYXkuXG4gICAgICAgKiBAcGFyYW0gey4uLip9IGl0ZW1zIEl0ZW1zIHRvIHB1c2ggb250byBhcnJheVxuICAgICAgICogQHJldHVybiB7bnVtYmVyfSBOZXcgbGVuZ3RoIG9mIHRoZSBhcnJheS5cbiAgICAgICAqIEBwdWJsaWNcbiAgICAgICAqL1xuICAgICAgcHVzaChwYXRoLCAuLi5pdGVtcykge1xuICAgICAgICBsZXQgaW5mbyA9IHtwYXRoOiAnJ307XG4gICAgICAgIGxldCBhcnJheSA9IC8qKiBAdHlwZSB7QXJyYXl9Ki8oUG9seW1lci5QYXRoLmdldCh0aGlzLCBwYXRoLCBpbmZvKSk7XG4gICAgICAgIGxldCBsZW4gPSBhcnJheS5sZW5ndGg7XG4gICAgICAgIGxldCByZXQgPSBhcnJheS5wdXNoKC4uLml0ZW1zKTtcbiAgICAgICAgaWYgKGl0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgIG5vdGlmeVNwbGljZSh0aGlzLCBhcnJheSwgaW5mby5wYXRoLCBsZW4sIGl0ZW1zLmxlbmd0aCwgW10pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUmVtb3ZlcyBhbiBpdGVtIGZyb20gdGhlIGVuZCBvZiBhcnJheSBhdCB0aGUgcGF0aCBzcGVjaWZpZWQuXG4gICAgICAgKlxuICAgICAgICogVGhlIGFyZ3VtZW50cyBhZnRlciBgcGF0aGAgYW5kIHJldHVybiB2YWx1ZSBtYXRjaCB0aGF0IG9mXG4gICAgICAgKiBgQXJyYXkucHJvdG90eXBlLnBvcGAuXG4gICAgICAgKlxuICAgICAgICogVGhpcyBtZXRob2Qgbm90aWZpZXMgb3RoZXIgcGF0aHMgdG8gdGhlIHNhbWUgYXJyYXkgdGhhdCBhXG4gICAgICAgKiBzcGxpY2Ugb2NjdXJyZWQgdG8gdGhlIGFycmF5LlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFBhdGggdG8gYXJyYXkuXG4gICAgICAgKiBAcmV0dXJuIHsqfSBJdGVtIHRoYXQgd2FzIHJlbW92ZWQuXG4gICAgICAgKiBAcHVibGljXG4gICAgICAgKi9cbiAgICAgIHBvcChwYXRoKSB7XG4gICAgICAgIGxldCBpbmZvID0ge3BhdGg6ICcnfTtcbiAgICAgICAgbGV0IGFycmF5ID0gLyoqIEB0eXBlIHtBcnJheX0gKi8oUG9seW1lci5QYXRoLmdldCh0aGlzLCBwYXRoLCBpbmZvKSk7XG4gICAgICAgIGxldCBoYWRMZW5ndGggPSBCb29sZWFuKGFycmF5Lmxlbmd0aCk7XG4gICAgICAgIGxldCByZXQgPSBhcnJheS5wb3AoKTtcbiAgICAgICAgaWYgKGhhZExlbmd0aCkge1xuICAgICAgICAgIG5vdGlmeVNwbGljZSh0aGlzLCBhcnJheSwgaW5mby5wYXRoLCBhcnJheS5sZW5ndGgsIDAsIFtyZXRdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFN0YXJ0aW5nIGZyb20gdGhlIHN0YXJ0IGluZGV4IHNwZWNpZmllZCwgcmVtb3ZlcyAwIG9yIG1vcmUgaXRlbXNcbiAgICAgICAqIGZyb20gdGhlIGFycmF5IGFuZCBpbnNlcnRzIDAgb3IgbW9yZSBuZXcgaXRlbXMgaW4gdGhlaXIgcGxhY2UuXG4gICAgICAgKlxuICAgICAgICogVGhlIGFyZ3VtZW50cyBhZnRlciBgcGF0aGAgYW5kIHJldHVybiB2YWx1ZSBtYXRjaCB0aGF0IG9mXG4gICAgICAgKiBgQXJyYXkucHJvdG90eXBlLnNwbGljZWAuXG4gICAgICAgKlxuICAgICAgICogVGhpcyBtZXRob2Qgbm90aWZpZXMgb3RoZXIgcGF0aHMgdG8gdGhlIHNhbWUgYXJyYXkgdGhhdCBhXG4gICAgICAgKiBzcGxpY2Ugb2NjdXJyZWQgdG8gdGhlIGFycmF5LlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFBhdGggdG8gYXJyYXkuXG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgSW5kZXggZnJvbSB3aGljaCB0byBzdGFydCByZW1vdmluZy9pbnNlcnRpbmcuXG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0gZGVsZXRlQ291bnQgTnVtYmVyIG9mIGl0ZW1zIHRvIHJlbW92ZS5cbiAgICAgICAqIEBwYXJhbSB7Li4uKn0gaXRlbXMgSXRlbXMgdG8gaW5zZXJ0IGludG8gYXJyYXkuXG4gICAgICAgKiBAcmV0dXJuIHtBcnJheX0gQXJyYXkgb2YgcmVtb3ZlZCBpdGVtcy5cbiAgICAgICAqIEBwdWJsaWNcbiAgICAgICAqL1xuICAgICAgc3BsaWNlKHBhdGgsIHN0YXJ0LCBkZWxldGVDb3VudCwgLi4uaXRlbXMpIHtcbiAgICAgICAgbGV0IGluZm8gPSB7cGF0aCA6ICcnfTtcbiAgICAgICAgbGV0IGFycmF5ID0gLyoqIEB0eXBlIHtBcnJheX0gKi8oUG9seW1lci5QYXRoLmdldCh0aGlzLCBwYXRoLCBpbmZvKSk7XG4gICAgICAgIC8vIE5vcm1hbGl6ZSBmYW5jeSBuYXRpdmUgc3BsaWNlIGhhbmRsaW5nIG9mIGNyYXp5IHN0YXJ0IHZhbHVlc1xuICAgICAgICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgICAgICAgc3RhcnQgPSBhcnJheS5sZW5ndGggLSBNYXRoLmZsb29yKC1zdGFydCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RhcnQgPSBNYXRoLmZsb29yKHN0YXJ0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXN0YXJ0KSB7XG4gICAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXQgPSBhcnJheS5zcGxpY2Uoc3RhcnQsIGRlbGV0ZUNvdW50LCAuLi5pdGVtcyk7XG4gICAgICAgIGlmIChpdGVtcy5sZW5ndGggfHwgcmV0Lmxlbmd0aCkge1xuICAgICAgICAgIG5vdGlmeVNwbGljZSh0aGlzLCBhcnJheSwgaW5mby5wYXRoLCBzdGFydCwgaXRlbXMubGVuZ3RoLCByZXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUmVtb3ZlcyBhbiBpdGVtIGZyb20gdGhlIGJlZ2lubmluZyBvZiBhcnJheSBhdCB0aGUgcGF0aCBzcGVjaWZpZWQuXG4gICAgICAgKlxuICAgICAgICogVGhlIGFyZ3VtZW50cyBhZnRlciBgcGF0aGAgYW5kIHJldHVybiB2YWx1ZSBtYXRjaCB0aGF0IG9mXG4gICAgICAgKiBgQXJyYXkucHJvdG90eXBlLnBvcGAuXG4gICAgICAgKlxuICAgICAgICogVGhpcyBtZXRob2Qgbm90aWZpZXMgb3RoZXIgcGF0aHMgdG8gdGhlIHNhbWUgYXJyYXkgdGhhdCBhXG4gICAgICAgKiBzcGxpY2Ugb2NjdXJyZWQgdG8gdGhlIGFycmF5LlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFBhdGggdG8gYXJyYXkuXG4gICAgICAgKiBAcmV0dXJuIHsqfSBJdGVtIHRoYXQgd2FzIHJlbW92ZWQuXG4gICAgICAgKiBAcHVibGljXG4gICAgICAgKi9cbiAgICAgIHNoaWZ0KHBhdGgpIHtcbiAgICAgICAgbGV0IGluZm8gPSB7cGF0aDogJyd9O1xuICAgICAgICBsZXQgYXJyYXkgPSAvKiogQHR5cGUge0FycmF5fSAqLyhQb2x5bWVyLlBhdGguZ2V0KHRoaXMsIHBhdGgsIGluZm8pKTtcbiAgICAgICAgbGV0IGhhZExlbmd0aCA9IEJvb2xlYW4oYXJyYXkubGVuZ3RoKTtcbiAgICAgICAgbGV0IHJldCA9IGFycmF5LnNoaWZ0KCk7XG4gICAgICAgIGlmIChoYWRMZW5ndGgpIHtcbiAgICAgICAgICBub3RpZnlTcGxpY2UodGhpcywgYXJyYXksIGluZm8ucGF0aCwgMCwgMCwgW3JldF0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQWRkcyBpdGVtcyBvbnRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGFycmF5IGF0IHRoZSBwYXRoIHNwZWNpZmllZC5cbiAgICAgICAqXG4gICAgICAgKiBUaGUgYXJndW1lbnRzIGFmdGVyIGBwYXRoYCBhbmQgcmV0dXJuIHZhbHVlIG1hdGNoIHRoYXQgb2ZcbiAgICAgICAqIGBBcnJheS5wcm90b3R5cGUucHVzaGAuXG4gICAgICAgKlxuICAgICAgICogVGhpcyBtZXRob2Qgbm90aWZpZXMgb3RoZXIgcGF0aHMgdG8gdGhlIHNhbWUgYXJyYXkgdGhhdCBhXG4gICAgICAgKiBzcGxpY2Ugb2NjdXJyZWQgdG8gdGhlIGFycmF5LlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFBhdGggdG8gYXJyYXkuXG4gICAgICAgKiBAcGFyYW0gey4uLip9IGl0ZW1zIEl0ZW1zIHRvIGluc2VydCBpbmZvIGFycmF5XG4gICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IE5ldyBsZW5ndGggb2YgdGhlIGFycmF5LlxuICAgICAgICogQHB1YmxpY1xuICAgICAgICovXG4gICAgICB1bnNoaWZ0KHBhdGgsIC4uLml0ZW1zKSB7XG4gICAgICAgIGxldCBpbmZvID0ge3BhdGg6ICcnfTtcbiAgICAgICAgbGV0IGFycmF5ID0gLyoqIEB0eXBlIHtBcnJheX0gKi8oUG9seW1lci5QYXRoLmdldCh0aGlzLCBwYXRoLCBpbmZvKSk7XG4gICAgICAgIGxldCByZXQgPSBhcnJheS51bnNoaWZ0KC4uLml0ZW1zKTtcbiAgICAgICAgaWYgKGl0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgIG5vdGlmeVNwbGljZSh0aGlzLCBhcnJheSwgaW5mby5wYXRoLCAwLCBpdGVtcy5sZW5ndGgsIFtdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIE5vdGlmeSB0aGF0IGEgcGF0aCBoYXMgY2hhbmdlZC5cbiAgICAgICAqXG4gICAgICAgKiBFeGFtcGxlOlxuICAgICAgICpcbiAgICAgICAqICAgICB0aGlzLml0ZW0udXNlci5uYW1lID0gJ0JvYic7XG4gICAgICAgKiAgICAgdGhpcy5ub3RpZnlQYXRoKCdpdGVtLnVzZXIubmFtZScpO1xuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFBhdGggdGhhdCBzaG91bGQgYmUgbm90aWZpZWQuXG4gICAgICAgKiBAcGFyYW0geyo9fSB2YWx1ZSBWYWx1ZSBhdCB0aGUgcGF0aCAob3B0aW9uYWwpLlxuICAgICAgICogQHB1YmxpY1xuICAgICAgKi9cbiAgICAgIG5vdGlmeVBhdGgocGF0aCwgdmFsdWUpIHtcbiAgICAgICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgICAgIGxldCBwcm9wUGF0aDtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMSkge1xuICAgICAgICAgIC8vIEdldCB2YWx1ZSBpZiBub3Qgc3VwcGxpZWRcbiAgICAgICAgICBsZXQgaW5mbyA9IHtwYXRoOiAnJ307XG4gICAgICAgICAgdmFsdWUgPSBQb2x5bWVyLlBhdGguZ2V0KHRoaXMsIHBhdGgsIGluZm8pO1xuICAgICAgICAgIHByb3BQYXRoID0gaW5mby5wYXRoO1xuICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocGF0aCkpIHtcbiAgICAgICAgICAvLyBOb3JtYWxpemUgcGF0aCBpZiBuZWVkZWRcbiAgICAgICAgICBwcm9wUGF0aCA9IFBvbHltZXIuUGF0aC5ub3JtYWxpemUocGF0aCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJvcFBhdGggPSAvKiogQHR5cGV7c3RyaW5nfSAqLyhwYXRoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fc2V0UGVuZGluZ1Byb3BlcnR5T3JQYXRoKHByb3BQYXRoLCB2YWx1ZSwgdHJ1ZSwgdHJ1ZSkpIHtcbiAgICAgICAgICB0aGlzLl9pbnZhbGlkYXRlUHJvcGVydGllcygpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogRXF1aXZhbGVudCB0byBzdGF0aWMgYGNyZWF0ZVJlYWRPbmx5UHJvcGVydHlgIEFQSSBidXQgY2FuIGJlIGNhbGxlZCBvblxuICAgICAgICogYW4gaW5zdGFuY2UgdG8gYWRkIGVmZmVjdHMgYXQgcnVudGltZS4gIFNlZSB0aGF0IG1ldGhvZCBmb3JcbiAgICAgICAqIGZ1bGwgQVBJIGRvY3MuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IG5hbWVcbiAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IHByb3RlY3RlZFNldHRlciBDcmVhdGVzIGEgY3VzdG9tIHByb3RlY3RlZCBzZXR0ZXJcbiAgICAgICAqICAgd2hlbiBgdHJ1ZWAuXG4gICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgKi9cbiAgICAgIF9jcmVhdGVSZWFkT25seVByb3BlcnR5KHByb3BlcnR5LCBwcm90ZWN0ZWRTZXR0ZXIpIHtcbiAgICAgICAgdGhpcy5fYWRkUHJvcGVydHlFZmZlY3QocHJvcGVydHksIFRZUEVTLlJFQURfT05MWSk7XG4gICAgICAgIGlmIChwcm90ZWN0ZWRTZXR0ZXIpIHtcbiAgICAgICAgICB0aGlzWydfc2V0JyArIHVwcGVyKHByb3BlcnR5KV0gPSAvKiogQHRoaXMge1Byb3BlcnR5RWZmZWN0c30gKi9mdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fc2V0UHJvcGVydHkocHJvcGVydHksIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBFcXVpdmFsZW50IHRvIHN0YXRpYyBgY3JlYXRlUHJvcGVydHlPYnNlcnZlcmAgQVBJIGJ1dCBjYW4gYmUgY2FsbGVkIG9uXG4gICAgICAgKiBhbiBpbnN0YW5jZSB0byBhZGQgZWZmZWN0cyBhdCBydW50aW1lLiAgU2VlIHRoYXQgbWV0aG9kIGZvclxuICAgICAgICogZnVsbCBBUEkgZG9jcy5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgbmFtZVxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZE5hbWUgTmFtZSBvZiBvYnNlcnZlciBtZXRob2QgdG8gY2FsbFxuICAgICAgICogQHBhcmFtIHtib29sZWFuPX0gZHluYW1pY0ZuIFdoZXRoZXIgdGhlIG1ldGhvZCBuYW1lIHNob3VsZCBiZSBpbmNsdWRlZCBhc1xuICAgICAgICogICBhIGRlcGVuZGVuY3kgdG8gdGhlIGVmZmVjdC5cbiAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAqL1xuICAgICAgX2NyZWF0ZVByb3BlcnR5T2JzZXJ2ZXIocHJvcGVydHksIG1ldGhvZE5hbWUsIGR5bmFtaWNGbikge1xuICAgICAgICBsZXQgaW5mbyA9IHsgcHJvcGVydHksIG1ldGhvZE5hbWUsIGR5bmFtaWNGbjogQm9vbGVhbihkeW5hbWljRm4pIH07XG4gICAgICAgIHRoaXMuX2FkZFByb3BlcnR5RWZmZWN0KHByb3BlcnR5LCBUWVBFUy5PQlNFUlZFLCB7XG4gICAgICAgICAgZm46IHJ1bk9ic2VydmVyRWZmZWN0LCBpbmZvLCB0cmlnZ2VyOiB7bmFtZTogcHJvcGVydHl9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZHluYW1pY0ZuKSB7XG4gICAgICAgICAgdGhpcy5fYWRkUHJvcGVydHlFZmZlY3QobWV0aG9kTmFtZSwgVFlQRVMuT0JTRVJWRSwge1xuICAgICAgICAgICAgZm46IHJ1bk9ic2VydmVyRWZmZWN0LCBpbmZvLCB0cmlnZ2VyOiB7bmFtZTogbWV0aG9kTmFtZX1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEVxdWl2YWxlbnQgdG8gc3RhdGljIGBjcmVhdGVNZXRob2RPYnNlcnZlcmAgQVBJIGJ1dCBjYW4gYmUgY2FsbGVkIG9uXG4gICAgICAgKiBhbiBpbnN0YW5jZSB0byBhZGQgZWZmZWN0cyBhdCBydW50aW1lLiAgU2VlIHRoYXQgbWV0aG9kIGZvclxuICAgICAgICogZnVsbCBBUEkgZG9jcy5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXhwcmVzc2lvbiBNZXRob2QgZXhwcmVzc2lvblxuICAgICAgICogQHBhcmFtIHtib29sZWFufE9iamVjdD19IGR5bmFtaWNGbiBCb29sZWFuIG9yIG9iamVjdCBtYXAgaW5kaWNhdGluZ1xuICAgICAgICogICB3aGV0aGVyIG1ldGhvZCBuYW1lcyBzaG91bGQgYmUgaW5jbHVkZWQgYXMgYSBkZXBlbmRlbmN5IHRvIHRoZSBlZmZlY3QuXG4gICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgKi9cbiAgICAgIF9jcmVhdGVNZXRob2RPYnNlcnZlcihleHByZXNzaW9uLCBkeW5hbWljRm4pIHtcbiAgICAgICAgbGV0IHNpZyA9IHBhcnNlTWV0aG9kKGV4cHJlc3Npb24pO1xuICAgICAgICBpZiAoIXNpZykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1hbGZvcm1lZCBvYnNlcnZlciBleHByZXNzaW9uICdcIiArIGV4cHJlc3Npb24gKyBcIidcIik7XG4gICAgICAgIH1cbiAgICAgICAgY3JlYXRlTWV0aG9kRWZmZWN0KHRoaXMsIHNpZywgVFlQRVMuT0JTRVJWRSwgcnVuTWV0aG9kRWZmZWN0LCBudWxsLCBkeW5hbWljRm4pO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEVxdWl2YWxlbnQgdG8gc3RhdGljIGBjcmVhdGVOb3RpZnlpbmdQcm9wZXJ0eWAgQVBJIGJ1dCBjYW4gYmUgY2FsbGVkIG9uXG4gICAgICAgKiBhbiBpbnN0YW5jZSB0byBhZGQgZWZmZWN0cyBhdCBydW50aW1lLiAgU2VlIHRoYXQgbWV0aG9kIGZvclxuICAgICAgICogZnVsbCBBUEkgZG9jcy5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgbmFtZVxuICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICovXG4gICAgICBfY3JlYXRlTm90aWZ5aW5nUHJvcGVydHkocHJvcGVydHkpIHtcbiAgICAgICAgdGhpcy5fYWRkUHJvcGVydHlFZmZlY3QocHJvcGVydHksIFRZUEVTLk5PVElGWSwge1xuICAgICAgICAgIGZuOiBydW5Ob3RpZnlFZmZlY3QsXG4gICAgICAgICAgaW5mbzoge1xuICAgICAgICAgICAgZXZlbnROYW1lOiBDYXNlTWFwLmNhbWVsVG9EYXNoQ2FzZShwcm9wZXJ0eSkgKyAnLWNoYW5nZWQnLFxuICAgICAgICAgICAgcHJvcGVydHk6IHByb3BlcnR5XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBFcXVpdmFsZW50IHRvIHN0YXRpYyBgY3JlYXRlUmVmbGVjdGVkUHJvcGVydHlgIEFQSSBidXQgY2FuIGJlIGNhbGxlZCBvblxuICAgICAgICogYW4gaW5zdGFuY2UgdG8gYWRkIGVmZmVjdHMgYXQgcnVudGltZS4gIFNlZSB0aGF0IG1ldGhvZCBmb3JcbiAgICAgICAqIGZ1bGwgQVBJIGRvY3MuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IG5hbWVcbiAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAqL1xuICAgICAgX2NyZWF0ZVJlZmxlY3RlZFByb3BlcnR5KHByb3BlcnR5KSB7XG4gICAgICAgIGxldCBhdHRyID0gQ2FzZU1hcC5jYW1lbFRvRGFzaENhc2UocHJvcGVydHkpO1xuICAgICAgICBpZiAoYXR0clswXSA9PT0gJy0nKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKCdQcm9wZXJ0eSAnICsgcHJvcGVydHkgKyAnIGNhbm5vdCBiZSByZWZsZWN0ZWQgdG8gYXR0cmlidXRlICcgK1xuICAgICAgICAgICAgYXR0ciArICcgYmVjYXVzZSBcIi1cIiBpcyBub3QgYSB2YWxpZCBzdGFydGluZyBhdHRyaWJ1dGUgbmFtZS4gVXNlIGEgbG93ZXJjYXNlIGZpcnN0IGxldHRlciBmb3IgdGhlIHByb3BlcnR5IHRoaXNlYWQuJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fYWRkUHJvcGVydHlFZmZlY3QocHJvcGVydHksIFRZUEVTLlJFRkxFQ1QsIHtcbiAgICAgICAgICAgIGZuOiBydW5SZWZsZWN0RWZmZWN0LFxuICAgICAgICAgICAgaW5mbzoge1xuICAgICAgICAgICAgICBhdHRyTmFtZTogYXR0clxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogRXF1aXZhbGVudCB0byBzdGF0aWMgYGNyZWF0ZUNvbXB1dGVkUHJvcGVydHlgIEFQSSBidXQgY2FuIGJlIGNhbGxlZCBvblxuICAgICAgICogYW4gaW5zdGFuY2UgdG8gYWRkIGVmZmVjdHMgYXQgcnVudGltZS4gIFNlZSB0aGF0IG1ldGhvZCBmb3JcbiAgICAgICAqIGZ1bGwgQVBJIGRvY3MuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IE5hbWUgb2YgY29tcHV0ZWQgcHJvcGVydHkgdG8gc2V0XG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXhwcmVzc2lvbiBNZXRob2QgZXhwcmVzc2lvblxuICAgICAgICogQHBhcmFtIHtib29sZWFufE9iamVjdD19IGR5bmFtaWNGbiBCb29sZWFuIG9yIG9iamVjdCBtYXAgaW5kaWNhdGluZ1xuICAgICAgICogICB3aGV0aGVyIG1ldGhvZCBuYW1lcyBzaG91bGQgYmUgaW5jbHVkZWQgYXMgYSBkZXBlbmRlbmN5IHRvIHRoZSBlZmZlY3QuXG4gICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgKi9cbiAgICAgIF9jcmVhdGVDb21wdXRlZFByb3BlcnR5KHByb3BlcnR5LCBleHByZXNzaW9uLCBkeW5hbWljRm4pIHtcbiAgICAgICAgbGV0IHNpZyA9IHBhcnNlTWV0aG9kKGV4cHJlc3Npb24pO1xuICAgICAgICBpZiAoIXNpZykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1hbGZvcm1lZCBjb21wdXRlZCBleHByZXNzaW9uICdcIiArIGV4cHJlc3Npb24gKyBcIidcIik7XG4gICAgICAgIH1cbiAgICAgICAgY3JlYXRlTWV0aG9kRWZmZWN0KHRoaXMsIHNpZywgVFlQRVMuQ09NUFVURSwgcnVuQ29tcHV0ZWRFZmZlY3QsIHByb3BlcnR5LCBkeW5hbWljRm4pO1xuICAgICAgfVxuXG4gICAgICAvLyAtLSBzdGF0aWMgY2xhc3MgbWV0aG9kcyAtLS0tLS0tLS0tLS1cblxuICAgICAgLyoqXG4gICAgICAgKiBFbnN1cmVzIGFuIGFjY2Vzc29yIGV4aXN0cyBmb3IgdGhlIHNwZWNpZmllZCBwcm9wZXJ0eSwgYW5kIGFkZHNcbiAgICAgICAqIHRvIGEgbGlzdCBvZiBcInByb3BlcnR5IGVmZmVjdHNcIiB0aGF0IHdpbGwgcnVuIHdoZW4gdGhlIGFjY2Vzc29yIGZvclxuICAgICAgICogdGhlIHNwZWNpZmllZCBwcm9wZXJ0eSBpcyBzZXQuICBFZmZlY3RzIGFyZSBncm91cGVkIGJ5IFwidHlwZVwiLCB3aGljaFxuICAgICAgICogcm91Z2hseSBjb3JyZXNwb25kcyB0byBhIHBoYXNlIGluIGVmZmVjdCBwcm9jZXNzaW5nLiAgVGhlIGVmZmVjdFxuICAgICAgICogbWV0YWRhdGEgc2hvdWxkIGJlIGluIHRoZSBmb2xsb3dpbmcgZm9ybTpcbiAgICAgICAqXG4gICAgICAgKiAgIHtcbiAgICAgICAqICAgICBmbjogZWZmZWN0RnVuY3Rpb24sIC8vIFJlZmVyZW5jZSB0byBmdW5jdGlvbiB0byBjYWxsIHRvIHBlcmZvcm0gZWZmZWN0XG4gICAgICAgKiAgICAgaW5mbzogeyAuLi4gfSAgICAgICAvLyBFZmZlY3QgbWV0YWRhdGEgcGFzc2VkIHRvIGZ1bmN0aW9uXG4gICAgICAgKiAgICAgdHJpZ2dlcjogeyAgICAgICAgICAvLyBPcHRpb25hbCB0cmlnZ2VyaW5nIG1ldGFkYXRhOyBpZiBub3QgcHJvdmlkZWRcbiAgICAgICAqICAgICAgIG5hbWU6IHN0cmluZyAgICAgIC8vIHRoZSBwcm9wZXJ0eSBpcyB0cmVhdGVkIGFzIGEgd2lsZGNhcmRcbiAgICAgICAqICAgICAgIHN0cnVjdHVyZWQ6IGJvb2xlYW5cbiAgICAgICAqICAgICAgIHdpbGRjYXJkOiBib29sZWFuXG4gICAgICAgKiAgICAgfVxuICAgICAgICogICB9XG4gICAgICAgKlxuICAgICAgICogRWZmZWN0cyBhcmUgY2FsbGVkIGZyb20gYF9wcm9wZXJ0aWVzQ2hhbmdlZGAgaW4gdGhlIGZvbGxvd2luZyBvcmRlciBieVxuICAgICAgICogdHlwZTpcbiAgICAgICAqXG4gICAgICAgKiAxLiBDT01QVVRFXG4gICAgICAgKiAyLiBQUk9QQUdBVEVcbiAgICAgICAqIDMuIFJFRkxFQ1RcbiAgICAgICAqIDQuIE9CU0VSVkVcbiAgICAgICAqIDUuIE5PVElGWVxuICAgICAgICpcbiAgICAgICAqIEVmZmVjdCBmdW5jdGlvbnMgYXJlIGNhbGxlZCB3aXRoIHRoZSBmb2xsb3dpbmcgc2lnbmF0dXJlOlxuICAgICAgICpcbiAgICAgICAqICAgZWZmZWN0RnVuY3Rpb24oaW5zdCwgcGF0aCwgcHJvcHMsIG9sZFByb3BzLCBpbmZvLCBoYXNQYXRocylcbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgdGhhdCBzaG91bGQgdHJpZ2dlciB0aGUgZWZmZWN0XG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBFZmZlY3QgdHlwZSwgZnJvbSB0aGlzLlBST1BFUlRZX0VGRkVDVF9UWVBFU1xuICAgICAgICogQHBhcmFtIHtPYmplY3Q9fSBlZmZlY3QgRWZmZWN0IG1ldGFkYXRhIG9iamVjdFxuICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICovXG4gICAgICBzdGF0aWMgYWRkUHJvcGVydHlFZmZlY3QocHJvcGVydHksIHR5cGUsIGVmZmVjdCkge1xuICAgICAgICB0aGlzLnByb3RvdHlwZS5fYWRkUHJvcGVydHlFZmZlY3QocHJvcGVydHksIHR5cGUsIGVmZmVjdCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ3JlYXRlcyBhIHNpbmdsZS1wcm9wZXJ0eSBvYnNlcnZlciBmb3IgdGhlIGdpdmVuIHByb3BlcnR5LlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSBuYW1lXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kTmFtZSBOYW1lIG9mIG9ic2VydmVyIG1ldGhvZCB0byBjYWxsXG4gICAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBkeW5hbWljRm4gV2hldGhlciB0aGUgbWV0aG9kIG5hbWUgc2hvdWxkIGJlIGluY2x1ZGVkIGFzXG4gICAgICAgKiAgIGEgZGVwZW5kZW5jeSB0byB0aGUgZWZmZWN0LlxuICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICovXG4gICAgICBzdGF0aWMgY3JlYXRlUHJvcGVydHlPYnNlcnZlcihwcm9wZXJ0eSwgbWV0aG9kTmFtZSwgZHluYW1pY0ZuKSB7XG4gICAgICAgIHRoaXMucHJvdG90eXBlLl9jcmVhdGVQcm9wZXJ0eU9ic2VydmVyKHByb3BlcnR5LCBtZXRob2ROYW1lLCBkeW5hbWljRm4pO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENyZWF0ZXMgYSBtdWx0aS1wcm9wZXJ0eSBcIm1ldGhvZCBvYnNlcnZlclwiIGJhc2VkIG9uIHRoZSBwcm92aWRlZFxuICAgICAgICogZXhwcmVzc2lvbiwgd2hpY2ggc2hvdWxkIGJlIGEgc3RyaW5nIGluIHRoZSBmb3JtIG9mIGEgbm9ybWFsIEphdmFzY3JpcHRcbiAgICAgICAqIGZ1bmN0aW9uIHNpZ25hdHVyZTogYCdtZXRob2ROYW1lKGFyZzEsIFsuLi4sIGFyZ25dKSdgLiAgRWFjaCBhcmd1bWVudFxuICAgICAgICogc2hvdWxkIGNvcnJlc3BvbmQgdG8gYSBwcm9wZXJ0eSBvciBwYXRoIGluIHRoZSBjb250ZXh0IG9mIHRoaXNcbiAgICAgICAqIHByb3RvdHlwZSAob3IgaW5zdGFuY2UpLCBvciBtYXkgYmUgYSBsaXRlcmFsIHN0cmluZyBvciBudW1iZXIuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGV4cHJlc3Npb24gTWV0aG9kIGV4cHJlc3Npb25cbiAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbnxPYmplY3Q9fSBkeW5hbWljRm4gQm9vbGVhbiBvciBvYmplY3QgbWFwIGluZGljYXRpbmdcbiAgICAgICAqICAgd2hldGhlciBtZXRob2QgbmFtZXMgc2hvdWxkIGJlIGluY2x1ZGVkIGFzIGEgZGVwZW5kZW5jeSB0byB0aGUgZWZmZWN0LlxuICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICovXG4gICAgICBzdGF0aWMgY3JlYXRlTWV0aG9kT2JzZXJ2ZXIoZXhwcmVzc2lvbiwgZHluYW1pY0ZuKSB7XG4gICAgICAgIHRoaXMucHJvdG90eXBlLl9jcmVhdGVNZXRob2RPYnNlcnZlcihleHByZXNzaW9uLCBkeW5hbWljRm4pO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENhdXNlcyB0aGUgc2V0dGVyIGZvciB0aGUgZ2l2ZW4gcHJvcGVydHkgdG8gZGlzcGF0Y2ggYDxwcm9wZXJ0eT4tY2hhbmdlZGBcbiAgICAgICAqIGV2ZW50cyB0byBub3RpZnkgb2YgY2hhbmdlcyB0byB0aGUgcHJvcGVydHkuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IG5hbWVcbiAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAqL1xuICAgICAgc3RhdGljIGNyZWF0ZU5vdGlmeWluZ1Byb3BlcnR5KHByb3BlcnR5KSB7XG4gICAgICAgIHRoaXMucHJvdG90eXBlLl9jcmVhdGVOb3RpZnlpbmdQcm9wZXJ0eShwcm9wZXJ0eSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ3JlYXRlcyBhIHJlYWQtb25seSBhY2Nlc3NvciBmb3IgdGhlIGdpdmVuIHByb3BlcnR5LlxuICAgICAgICpcbiAgICAgICAqIFRvIHNldCB0aGUgcHJvcGVydHksIHVzZSB0aGUgcHJvdGVjdGVkIGBfc2V0UHJvcGVydHlgIEFQSS5cbiAgICAgICAqIFRvIGNyZWF0ZSBhIGN1c3RvbSBwcm90ZWN0ZWQgc2V0dGVyIChlLmcuIGBfc2V0TXlQcm9wKClgIGZvclxuICAgICAgICogcHJvcGVydHkgYG15UHJvcGApLCBwYXNzIGB0cnVlYCBmb3IgYHByb3RlY3RlZFNldHRlcmAuXG4gICAgICAgKlxuICAgICAgICogTm90ZSwgaWYgdGhlIHByb3BlcnR5IHdpbGwgaGF2ZSBvdGhlciBwcm9wZXJ0eSBlZmZlY3RzLCB0aGlzIG1ldGhvZFxuICAgICAgICogc2hvdWxkIGJlIGNhbGxlZCBmaXJzdCwgYmVmb3JlIGFkZGluZyBvdGhlciBlZmZlY3RzLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSBuYW1lXG4gICAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBwcm90ZWN0ZWRTZXR0ZXIgQ3JlYXRlcyBhIGN1c3RvbSBwcm90ZWN0ZWQgc2V0dGVyXG4gICAgICAgKiAgIHdoZW4gYHRydWVgLlxuICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICovXG4gICAgICBzdGF0aWMgY3JlYXRlUmVhZE9ubHlQcm9wZXJ0eShwcm9wZXJ0eSwgcHJvdGVjdGVkU2V0dGVyKSB7XG4gICAgICAgIHRoaXMucHJvdG90eXBlLl9jcmVhdGVSZWFkT25seVByb3BlcnR5KHByb3BlcnR5LCBwcm90ZWN0ZWRTZXR0ZXIpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENhdXNlcyB0aGUgc2V0dGVyIGZvciB0aGUgZ2l2ZW4gcHJvcGVydHkgdG8gcmVmbGVjdCB0aGUgcHJvcGVydHkgdmFsdWVcbiAgICAgICAqIHRvIGEgKGRhc2gtY2FzZWQpIGF0dHJpYnV0ZSBvZiB0aGUgc2FtZSBuYW1lLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSBuYW1lXG4gICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgKi9cbiAgICAgIHN0YXRpYyBjcmVhdGVSZWZsZWN0ZWRQcm9wZXJ0eShwcm9wZXJ0eSkge1xuICAgICAgICB0aGlzLnByb3RvdHlwZS5fY3JlYXRlUmVmbGVjdGVkUHJvcGVydHkocHJvcGVydHkpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENyZWF0ZXMgYSBjb21wdXRlZCBwcm9wZXJ0eSB3aG9zZSB2YWx1ZSBpcyBzZXQgdG8gdGhlIHJlc3VsdCBvZiB0aGVcbiAgICAgICAqIG1ldGhvZCBkZXNjcmliZWQgYnkgdGhlIGdpdmVuIGBleHByZXNzaW9uYCBlYWNoIHRpbWUgb25lIG9yIG1vcmVcbiAgICAgICAqIGFyZ3VtZW50cyB0byB0aGUgbWV0aG9kIGNoYW5nZXMuICBUaGUgZXhwcmVzc2lvbiBzaG91bGQgYmUgYSBzdHJpbmdcbiAgICAgICAqIGluIHRoZSBmb3JtIG9mIGEgbm9ybWFsIEphdmFzY3JpcHQgZnVuY3Rpb24gc2lnbmF0dXJlOlxuICAgICAgICogYCdtZXRob2ROYW1lKGFyZzEsIFsuLi4sIGFyZ25dKSdgXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IE5hbWUgb2YgY29tcHV0ZWQgcHJvcGVydHkgdG8gc2V0XG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXhwcmVzc2lvbiBNZXRob2QgZXhwcmVzc2lvblxuICAgICAgICogQHBhcmFtIHtib29sZWFufE9iamVjdD19IGR5bmFtaWNGbiBCb29sZWFuIG9yIG9iamVjdCBtYXAgaW5kaWNhdGluZyB3aGV0aGVyXG4gICAgICAgKiAgIG1ldGhvZCBuYW1lcyBzaG91bGQgYmUgaW5jbHVkZWQgYXMgYSBkZXBlbmRlbmN5IHRvIHRoZSBlZmZlY3QuXG4gICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgKi9cbiAgICAgIHN0YXRpYyBjcmVhdGVDb21wdXRlZFByb3BlcnR5KHByb3BlcnR5LCBleHByZXNzaW9uLCBkeW5hbWljRm4pIHtcbiAgICAgICAgdGhpcy5wcm90b3R5cGUuX2NyZWF0ZUNvbXB1dGVkUHJvcGVydHkocHJvcGVydHksIGV4cHJlc3Npb24sIGR5bmFtaWNGbik7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUGFyc2VzIHRoZSBwcm92aWRlZCB0ZW1wbGF0ZSB0byBlbnN1cmUgYmluZGluZyBlZmZlY3RzIGFyZSBjcmVhdGVkXG4gICAgICAgKiBmb3IgdGhlbSwgYW5kIHRoZW4gZW5zdXJlcyBwcm9wZXJ0eSBhY2Nlc3NvcnMgYXJlIGNyZWF0ZWQgZm9yIGFueVxuICAgICAgICogZGVwZW5kZW50IHByb3BlcnRpZXMgaW4gdGhlIHRlbXBsYXRlLiAgQmluZGluZyBlZmZlY3RzIGZvciBib3VuZFxuICAgICAgICogdGVtcGxhdGVzIGFyZSBzdG9yZWQgaW4gYSBsaW5rZWQgbGlzdCBvbiB0aGUgaW5zdGFuY2Ugc28gdGhhdFxuICAgICAgICogdGVtcGxhdGVzIGNhbiBiZSBlZmZpY2llbnRseSBzdGFtcGVkIGFuZCB1bnN0YW1wZWQuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtIVE1MVGVtcGxhdGVFbGVtZW50fSB0ZW1wbGF0ZSBUZW1wbGF0ZSBjb250YWluaW5nIGJpbmRpbmdcbiAgICAgICAqICAgYmluZGluZ3NcbiAgICAgICAqIEByZXR1cm4ge09iamVjdH0gVGVtcGxhdGUgbWV0YWRhdGEgb2JqZWN0XG4gICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgKi9cbiAgICAgIHN0YXRpYyBiaW5kVGVtcGxhdGUodGVtcGxhdGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvdG90eXBlLl9iaW5kVGVtcGxhdGUodGVtcGxhdGUpO1xuICAgICAgfVxuXG4gICAgICAvLyAtLSBiaW5kaW5nIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgLyoqXG4gICAgICAgKiBFcXVpdmFsZW50IHRvIHN0YXRpYyBgYmluZFRlbXBsYXRlYCBBUEkgYnV0IGNhbiBiZSBjYWxsZWQgb25cbiAgICAgICAqIGFuIGluc3RhbmNlIHRvIGFkZCBlZmZlY3RzIGF0IHJ1bnRpbWUuICBTZWUgdGhhdCBtZXRob2QgZm9yXG4gICAgICAgKiBmdWxsIEFQSSBkb2NzLlxuICAgICAgICpcbiAgICAgICAqIFRoaXMgbWV0aG9kIG1heSBiZSBjYWxsZWQgb24gdGhlIHByb3RvdHlwZSAoZm9yIHByb3RvdHlwaWNhbCB0ZW1wbGF0ZVxuICAgICAgICogYmluZGluZywgdG8gYXZvaWQgY3JlYXRpbmcgYWNjZXNzb3JzIGV2ZXJ5IGluc3RhbmNlKSBvbmNlIHBlciBwcm90b3R5cGUsXG4gICAgICAgKiBhbmQgd2lsbCBiZSBjYWxsZWQgd2l0aCBgcnVudGltZUJpbmRpbmc6IHRydWVgIGJ5IGBfc3RhbXBUZW1wbGF0ZWAgdG9cbiAgICAgICAqIGNyZWF0ZSBhbmQgbGluayBhbiBpbnN0YW5jZSBvZiB0aGUgdGVtcGxhdGUgbWV0YWRhdGEgYXNzb2NpYXRlZCB3aXRoIGFcbiAgICAgICAqIHBhcnRpY3VsYXIgc3RhbXBpbmcuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtIVE1MVGVtcGxhdGVFbGVtZW50fSB0ZW1wbGF0ZSBUZW1wbGF0ZSBjb250YWluaW5nIGJpbmRpbmdcbiAgICAgICAqICAgYmluZGluZ3NcbiAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IGluc3RhbmNlQmluZGluZyBXaGVuIGZhbHNlIChkZWZhdWx0KSwgcGVyZm9ybXNcbiAgICAgICAqICAgXCJwcm90b3R5cGljYWxcIiBiaW5kaW5nIG9mIHRoZSB0ZW1wbGF0ZSBhbmQgb3ZlcndyaXRlcyBhbnkgcHJldmlvdXNseVxuICAgICAgICogICBib3VuZCB0ZW1wbGF0ZSBmb3IgdGhlIGNsYXNzLiBXaGVuIHRydWUgKGFzIHBhc3NlZCBmcm9tXG4gICAgICAgKiAgIGBfc3RhbXBUZW1wbGF0ZWApLCB0aGUgdGVtcGxhdGUgaW5mbyBpcyBpbnN0YW5jZWQgYW5kIGxpbmtlZCBpbnRvXG4gICAgICAgKiAgIHRoZSBsaXN0IG9mIGJvdW5kIHRlbXBsYXRlcy5cbiAgICAgICAqIEByZXR1cm4geyFUZW1wbGF0ZUluZm99IFRlbXBsYXRlIG1ldGFkYXRhIG9iamVjdDsgZm9yIGBydW50aW1lQmluZGluZ2AsXG4gICAgICAgKiAgIHRoaXMgaXMgYW4gaW5zdGFuY2Ugb2YgdGhlIHByb3RvdHlwaWNhbCB0ZW1wbGF0ZSBpbmZvXG4gICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgKi9cbiAgICAgIF9iaW5kVGVtcGxhdGUodGVtcGxhdGUsIGluc3RhbmNlQmluZGluZykge1xuICAgICAgICBsZXQgdGVtcGxhdGVJbmZvID0gdGhpcy5jb25zdHJ1Y3Rvci5fcGFyc2VUZW1wbGF0ZSh0ZW1wbGF0ZSk7XG4gICAgICAgIGxldCB3YXNQcmVCb3VuZCA9IHRoaXMuX190ZW1wbGF0ZUluZm8gPT0gdGVtcGxhdGVJbmZvO1xuICAgICAgICAvLyBPcHRpbWl6YXRpb246IHNpbmNlIHRoaXMgaXMgY2FsbGVkIHR3aWNlIGZvciBwcm90by1ib3VuZCB0ZW1wbGF0ZXMsXG4gICAgICAgIC8vIGRvbid0IGF0dGVtcHQgdG8gcmVjcmVhdGUgYWNjZXNzb3JzIGlmIHRoaXMgdGVtcGxhdGUgd2FzIHByZS1ib3VuZFxuICAgICAgICBpZiAoIXdhc1ByZUJvdW5kKSB7XG4gICAgICAgICAgZm9yIChsZXQgcHJvcCBpbiB0ZW1wbGF0ZUluZm8ucHJvcGVydHlFZmZlY3RzKSB7XG4gICAgICAgICAgICB0aGlzLl9jcmVhdGVQcm9wZXJ0eUFjY2Vzc29yKHByb3ApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5zdGFuY2VCaW5kaW5nKSB7XG4gICAgICAgICAgLy8gRm9yIGluc3RhbmNlLXRpbWUgYmluZGluZywgY3JlYXRlIGluc3RhbmNlIG9mIHRlbXBsYXRlIG1ldGFkYXRhXG4gICAgICAgICAgLy8gYW5kIGxpbmsgaW50byBsaXN0IG9mIHRlbXBsYXRlcyBpZiBuZWNlc3NhcnlcbiAgICAgICAgICB0ZW1wbGF0ZUluZm8gPSAvKiogQHR5cGUgeyFUZW1wbGF0ZUluZm99ICovKE9iamVjdC5jcmVhdGUodGVtcGxhdGVJbmZvKSk7XG4gICAgICAgICAgdGVtcGxhdGVJbmZvLndhc1ByZUJvdW5kID0gd2FzUHJlQm91bmQ7XG4gICAgICAgICAgaWYgKCF3YXNQcmVCb3VuZCAmJiB0aGlzLl9fdGVtcGxhdGVJbmZvKSB7XG4gICAgICAgICAgICBsZXQgbGFzdCA9IHRoaXMuX190ZW1wbGF0ZUluZm9MYXN0IHx8IHRoaXMuX190ZW1wbGF0ZUluZm87XG4gICAgICAgICAgICB0aGlzLl9fdGVtcGxhdGVJbmZvTGFzdCA9IGxhc3QubmV4dFRlbXBsYXRlSW5mbyA9IHRlbXBsYXRlSW5mbztcbiAgICAgICAgICAgIHRlbXBsYXRlSW5mby5wcmV2aW91c1RlbXBsYXRlSW5mbyA9IGxhc3Q7XG4gICAgICAgICAgICByZXR1cm4gdGVtcGxhdGVJbmZvO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fX3RlbXBsYXRlSW5mbyA9IHRlbXBsYXRlSW5mbztcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBBZGRzIGEgcHJvcGVydHkgZWZmZWN0IHRvIHRoZSBnaXZlbiB0ZW1wbGF0ZSBtZXRhZGF0YSwgd2hpY2ggaXMgcnVuXG4gICAgICAgKiBhdCB0aGUgXCJwcm9wYWdhdGVcIiBzdGFnZSBvZiBgX3Byb3BlcnRpZXNDaGFuZ2VkYCB3aGVuIHRoZSB0ZW1wbGF0ZVxuICAgICAgICogaGFzIGJlZW4gYm91bmQgdG8gdGhlIGVsZW1lbnQgdmlhIGBfYmluZFRlbXBsYXRlYC5cbiAgICAgICAqXG4gICAgICAgKiBUaGUgYGVmZmVjdGAgb2JqZWN0IHNob3VsZCBtYXRjaCB0aGUgZm9ybWF0IGluIGBfYWRkUHJvcGVydHlFZmZlY3RgLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0ZW1wbGF0ZUluZm8gVGVtcGxhdGUgbWV0YWRhdGEgdG8gYWRkIGVmZmVjdCB0b1xuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3AgUHJvcGVydHkgdGhhdCBzaG91bGQgdHJpZ2dlciB0aGUgZWZmZWN0XG4gICAgICAgKiBAcGFyYW0ge09iamVjdD19IGVmZmVjdCBFZmZlY3QgbWV0YWRhdGEgb2JqZWN0XG4gICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgKi9cbiAgICAgIHN0YXRpYyBfYWRkVGVtcGxhdGVQcm9wZXJ0eUVmZmVjdCh0ZW1wbGF0ZUluZm8sIHByb3AsIGVmZmVjdCkge1xuICAgICAgICBsZXQgaG9zdFByb3BzID0gdGVtcGxhdGVJbmZvLmhvc3RQcm9wcyA9IHRlbXBsYXRlSW5mby5ob3N0UHJvcHMgfHwge307XG4gICAgICAgIGhvc3RQcm9wc1twcm9wXSA9IHRydWU7XG4gICAgICAgIGxldCBlZmZlY3RzID0gdGVtcGxhdGVJbmZvLnByb3BlcnR5RWZmZWN0cyA9IHRlbXBsYXRlSW5mby5wcm9wZXJ0eUVmZmVjdHMgfHwge307XG4gICAgICAgIGxldCBwcm9wRWZmZWN0cyA9IGVmZmVjdHNbcHJvcF0gPSBlZmZlY3RzW3Byb3BdIHx8IFtdO1xuICAgICAgICBwcm9wRWZmZWN0cy5wdXNoKGVmZmVjdCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogU3RhbXBzIHRoZSBwcm92aWRlZCB0ZW1wbGF0ZSBhbmQgcGVyZm9ybXMgaW5zdGFuY2UtdGltZSBzZXR1cCBmb3JcbiAgICAgICAqIFBvbHltZXIgdGVtcGxhdGUgZmVhdHVyZXMsIGluY2x1ZGluZyBkYXRhIGJpbmRpbmdzLCBkZWNsYXJhdGl2ZSBldmVudFxuICAgICAgICogbGlzdGVuZXJzLCBhbmQgdGhlIGB0aGlzLiRgIG1hcCBvZiBgaWRgJ3MgdG8gbm9kZXMuICBBIGRvY3VtZW50IGZyYWdtZW50XG4gICAgICAgKiBpcyByZXR1cm5lZCBjb250YWluaW5nIHRoZSBzdGFtcGVkIERPTSwgcmVhZHkgZm9yIGluc2VydGlvbiBpbnRvIHRoZVxuICAgICAgICogRE9NLlxuICAgICAgICpcbiAgICAgICAqIFRoaXMgbWV0aG9kIG1heSBiZSBjYWxsZWQgbW9yZSB0aGFuIG9uY2U7IGhvd2V2ZXIgbm90ZSB0aGF0IGR1ZSB0b1xuICAgICAgICogYHNoYWR5Y3NzYCBwb2x5ZmlsbCBsaW1pdGF0aW9ucywgb25seSBzdHlsZXMgZnJvbSB0ZW1wbGF0ZXMgcHJlcGFyZWRcbiAgICAgICAqIHVzaW5nIGBTaGFkeUNTUy5wcmVwYXJlVGVtcGxhdGVgIHdpbGwgYmUgY29ycmVjdGx5IHBvbHlmaWxsZWQgKHNjb3BlZFxuICAgICAgICogdG8gdGhlIHNoYWRvdyByb290IGFuZCBzdXBwb3J0IENTUyBjdXN0b20gcHJvcGVydGllcyksIGFuZCBub3RlIHRoYXRcbiAgICAgICAqIGBTaGFkeUNTUy5wcmVwYXJlVGVtcGxhdGVgIG1heSBvbmx5IGJlIGNhbGxlZCBvbmNlIHBlciBlbGVtZW50LiBBcyBzdWNoLFxuICAgICAgICogYW55IHN0eWxlcyByZXF1aXJlZCBieSBpbiBydW50aW1lLXN0YW1wZWQgdGVtcGxhdGVzIG11c3QgYmUgaW5jbHVkZWRcbiAgICAgICAqIGluIHRoZSBtYWluIGVsZW1lbnQgdGVtcGxhdGUuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHshSFRNTFRlbXBsYXRlRWxlbWVudH0gdGVtcGxhdGUgVGVtcGxhdGUgdG8gc3RhbXBcbiAgICAgICAqIEByZXR1cm4geyFTdGFtcGVkVGVtcGxhdGV9IENsb25lZCB0ZW1wbGF0ZSBjb250ZW50XG4gICAgICAgKiBAb3ZlcnJpZGVcbiAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAqL1xuICAgICAgX3N0YW1wVGVtcGxhdGUodGVtcGxhdGUpIHtcbiAgICAgICAgLy8gRW5zdXJlcyB0aGF0IGNyZWF0ZWQgZG9tIGlzIGBfZW5xdWV1ZUNsaWVudGAnZCB0byB0aGlzIGVsZW1lbnQgc29cbiAgICAgICAgLy8gdGhhdCBpdCBjYW4gYmUgZmx1c2hlZCBvbiBuZXh0IGNhbGwgdG8gYF9mbHVzaFByb3BlcnRpZXNgXG4gICAgICAgIGhvc3RTdGFjay5iZWdpbkhvc3RpbmcodGhpcyk7XG4gICAgICAgIGxldCBkb20gPSBzdXBlci5fc3RhbXBUZW1wbGF0ZSh0ZW1wbGF0ZSk7XG4gICAgICAgIGhvc3RTdGFjay5lbmRIb3N0aW5nKHRoaXMpO1xuICAgICAgICBsZXQgdGVtcGxhdGVJbmZvID0gLyoqIEB0eXBlIHshVGVtcGxhdGVJbmZvfSAqLyh0aGlzLl9iaW5kVGVtcGxhdGUodGVtcGxhdGUsIHRydWUpKTtcbiAgICAgICAgLy8gQWRkIHRlbXBsYXRlLWluc3RhbmNlLXNwZWNpZmljIGRhdGEgdG8gaW5zdGFuY2VkIHRlbXBsYXRlSW5mb1xuICAgICAgICB0ZW1wbGF0ZUluZm8ubm9kZUxpc3QgPSBkb20ubm9kZUxpc3Q7XG4gICAgICAgIC8vIENhcHR1cmUgY2hpbGQgbm9kZXMgdG8gYWxsb3cgdW5zdGFtcGluZyBvZiBub24tcHJvdG90eXBpY2FsIHRlbXBsYXRlc1xuICAgICAgICBpZiAoIXRlbXBsYXRlSW5mby53YXNQcmVCb3VuZCkge1xuICAgICAgICAgIGxldCBub2RlcyA9IHRlbXBsYXRlSW5mby5jaGlsZE5vZGVzID0gW107XG4gICAgICAgICAgZm9yIChsZXQgbj1kb20uZmlyc3RDaGlsZDsgbjsgbj1uLm5leHRTaWJsaW5nKSB7XG4gICAgICAgICAgICBub2Rlcy5wdXNoKG4pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkb20udGVtcGxhdGVJbmZvID0gdGVtcGxhdGVJbmZvO1xuICAgICAgICAvLyBTZXR1cCBjb21wb3VuZCBzdG9yYWdlLCAyLXdheSBsaXN0ZW5lcnMsIGFuZCBkYXRhSG9zdCBmb3IgYmluZGluZ3NcbiAgICAgICAgc2V0dXBCaW5kaW5ncyh0aGlzLCB0ZW1wbGF0ZUluZm8pO1xuICAgICAgICAvLyBGbHVzaCBwcm9wZXJ0aWVzIGludG8gdGVtcGxhdGUgbm9kZXMgaWYgYWxyZWFkeSBib290ZWRcbiAgICAgICAgaWYgKHRoaXMuX19kYXRhUmVhZHkpIHtcbiAgICAgICAgICBydW5FZmZlY3RzKHRoaXMsIHRlbXBsYXRlSW5mby5wcm9wZXJ0eUVmZmVjdHMsIHRoaXMuX19kYXRhLCBudWxsLFxuICAgICAgICAgICAgZmFsc2UsIHRlbXBsYXRlSW5mby5ub2RlTGlzdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRvbTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZW1vdmVzIGFuZCB1bmJpbmRzIHRoZSBub2RlcyBwcmV2aW91c2x5IGNvbnRhaW5lZCBpbiB0aGUgcHJvdmlkZWRcbiAgICAgICAqIERvY3VtZW50RnJhZ21lbnQgcmV0dXJuZWQgZnJvbSBgX3N0YW1wVGVtcGxhdGVgLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7IVN0YW1wZWRUZW1wbGF0ZX0gZG9tIERvY3VtZW50RnJhZ21lbnQgcHJldmlvdXNseSByZXR1cm5lZFxuICAgICAgICogICBmcm9tIGBfc3RhbXBUZW1wbGF0ZWAgYXNzb2NpYXRlZCB3aXRoIHRoZSBub2RlcyB0byBiZSByZW1vdmVkXG4gICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgKi9cbiAgICAgIF9yZW1vdmVCb3VuZERvbShkb20pIHtcbiAgICAgICAgLy8gVW5saW5rIHRlbXBsYXRlIGluZm9cbiAgICAgICAgbGV0IHRlbXBsYXRlSW5mbyA9IGRvbS50ZW1wbGF0ZUluZm87XG4gICAgICAgIGlmICh0ZW1wbGF0ZUluZm8ucHJldmlvdXNUZW1wbGF0ZUluZm8pIHtcbiAgICAgICAgICB0ZW1wbGF0ZUluZm8ucHJldmlvdXNUZW1wbGF0ZUluZm8ubmV4dFRlbXBsYXRlSW5mbyA9XG4gICAgICAgICAgICB0ZW1wbGF0ZUluZm8ubmV4dFRlbXBsYXRlSW5mbztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGVtcGxhdGVJbmZvLm5leHRUZW1wbGF0ZUluZm8pIHtcbiAgICAgICAgICB0ZW1wbGF0ZUluZm8ubmV4dFRlbXBsYXRlSW5mby5wcmV2aW91c1RlbXBsYXRlSW5mbyA9XG4gICAgICAgICAgICB0ZW1wbGF0ZUluZm8ucHJldmlvdXNUZW1wbGF0ZUluZm87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX190ZW1wbGF0ZUluZm9MYXN0ID09IHRlbXBsYXRlSW5mbykge1xuICAgICAgICAgIHRoaXMuX190ZW1wbGF0ZUluZm9MYXN0ID0gdGVtcGxhdGVJbmZvLnByZXZpb3VzVGVtcGxhdGVJbmZvO1xuICAgICAgICB9XG4gICAgICAgIHRlbXBsYXRlSW5mby5wcmV2aW91c1RlbXBsYXRlSW5mbyA9IHRlbXBsYXRlSW5mby5uZXh0VGVtcGxhdGVJbmZvID0gbnVsbDtcbiAgICAgICAgLy8gUmVtb3ZlIHN0YW1wZWQgbm9kZXNcbiAgICAgICAgbGV0IG5vZGVzID0gdGVtcGxhdGVJbmZvLmNoaWxkTm9kZXM7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGxldCBub2RlID0gbm9kZXNbaV07XG4gICAgICAgICAgbm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogT3ZlcnJpZGVzIGRlZmF1bHQgYFRlbXBsYXRlU3RhbXBgIGltcGxlbWVudGF0aW9uIHRvIGFkZCBzdXBwb3J0IGZvclxuICAgICAgICogcGFyc2luZyBiaW5kaW5ncyBmcm9tIGBUZXh0Tm9kZWAncycgYHRleHRDb250ZW50YC4gIEEgYGJpbmRpbmdzYFxuICAgICAgICogYXJyYXkgaXMgYWRkZWQgdG8gYG5vZGVJbmZvYCBhbmQgcG9wdWxhdGVkIHdpdGggYmluZGluZyBtZXRhZGF0YVxuICAgICAgICogd2l0aCBpbmZvcm1hdGlvbiBjYXB0dXJpbmcgdGhlIGJpbmRpbmcgdGFyZ2V0LCBhbmQgYSBgcGFydHNgIGFycmF5XG4gICAgICAgKiB3aXRoIG9uZSBvciBtb3JlIG1ldGFkYXRhIG9iamVjdHMgY2FwdHVyaW5nIHRoZSBzb3VyY2Uocykgb2YgdGhlXG4gICAgICAgKiBiaW5kaW5nLlxuICAgICAgICpcbiAgICAgICAqIEBvdmVycmlkZVxuICAgICAgICogQHBhcmFtIHtOb2RlfSBub2RlIE5vZGUgdG8gcGFyc2VcbiAgICAgICAqIEBwYXJhbSB7VGVtcGxhdGVJbmZvfSB0ZW1wbGF0ZUluZm8gVGVtcGxhdGUgbWV0YWRhdGEgZm9yIGN1cnJlbnQgdGVtcGxhdGVcbiAgICAgICAqIEBwYXJhbSB7Tm9kZUluZm99IG5vZGVJbmZvIE5vZGUgbWV0YWRhdGEgZm9yIGN1cnJlbnQgdGVtcGxhdGUgbm9kZVxuICAgICAgICogQHJldHVybiB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSB2aXNpdGVkIG5vZGUgYWRkZWQgbm9kZS1zcGVjaWZpY1xuICAgICAgICogICBtZXRhZGF0YSB0byBgbm9kZUluZm9gXG4gICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgKiBAc3VwcHJlc3Mge21pc3NpbmdQcm9wZXJ0aWVzfSBJbnRlcmZhY2VzIGluIGNsb3N1cmUgZG8gbm90IGluaGVyaXQgc3RhdGljcywgYnV0IGNsYXNzZXMgZG9cbiAgICAgICAqL1xuICAgICAgc3RhdGljIF9wYXJzZVRlbXBsYXRlTm9kZShub2RlLCB0ZW1wbGF0ZUluZm8sIG5vZGVJbmZvKSB7XG4gICAgICAgIGxldCBub3RlZCA9IHN1cGVyLl9wYXJzZVRlbXBsYXRlTm9kZShub2RlLCB0ZW1wbGF0ZUluZm8sIG5vZGVJbmZvKTtcbiAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFKSB7XG4gICAgICAgICAgbGV0IHBhcnRzID0gdGhpcy5fcGFyc2VCaW5kaW5ncyhub2RlLnRleHRDb250ZW50LCB0ZW1wbGF0ZUluZm8pO1xuICAgICAgICAgIGlmIChwYXJ0cykge1xuICAgICAgICAgICAgLy8gSW5pdGlhbGl6ZSB0aGUgdGV4dENvbnRlbnQgd2l0aCBhbnkgbGl0ZXJhbCBwYXJ0c1xuICAgICAgICAgICAgLy8gTk9URTogZGVmYXVsdCB0byBhIHNwYWNlIGhlcmUgc28gdGhlIHRleHROb2RlIHJlbWFpbnM7IHNvbWUgYnJvd3NlcnNcbiAgICAgICAgICAgIC8vIChJRSkgZXZhY2lwYXRlIGFuIGVtcHR5IHRleHROb2RlIGZvbGxvd2luZyBjbG9uZU5vZGUvaW1wb3J0Tm9kZS5cbiAgICAgICAgICAgIG5vZGUudGV4dENvbnRlbnQgPSBsaXRlcmFsRnJvbVBhcnRzKHBhcnRzKSB8fCAnICc7XG4gICAgICAgICAgICBhZGRCaW5kaW5nKHRoaXMsIHRlbXBsYXRlSW5mbywgbm9kZUluZm8sICd0ZXh0JywgJ3RleHRDb250ZW50JywgcGFydHMpO1xuICAgICAgICAgICAgbm90ZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm90ZWQ7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogT3ZlcnJpZGVzIGRlZmF1bHQgYFRlbXBsYXRlU3RhbXBgIGltcGxlbWVudGF0aW9uIHRvIGFkZCBzdXBwb3J0IGZvclxuICAgICAgICogcGFyc2luZyBiaW5kaW5ncyBmcm9tIGF0dHJpYnV0ZXMuICBBIGBiaW5kaW5nc2BcbiAgICAgICAqIGFycmF5IGlzIGFkZGVkIHRvIGBub2RlSW5mb2AgYW5kIHBvcHVsYXRlZCB3aXRoIGJpbmRpbmcgbWV0YWRhdGFcbiAgICAgICAqIHdpdGggaW5mb3JtYXRpb24gY2FwdHVyaW5nIHRoZSBiaW5kaW5nIHRhcmdldCwgYW5kIGEgYHBhcnRzYCBhcnJheVxuICAgICAgICogd2l0aCBvbmUgb3IgbW9yZSBtZXRhZGF0YSBvYmplY3RzIGNhcHR1cmluZyB0aGUgc291cmNlKHMpIG9mIHRoZVxuICAgICAgICogYmluZGluZy5cbiAgICAgICAqXG4gICAgICAgKiBAb3ZlcnJpZGVcbiAgICAgICAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZSBOb2RlIHRvIHBhcnNlXG4gICAgICAgKiBAcGFyYW0ge1RlbXBsYXRlSW5mb30gdGVtcGxhdGVJbmZvIFRlbXBsYXRlIG1ldGFkYXRhIGZvciBjdXJyZW50IHRlbXBsYXRlXG4gICAgICAgKiBAcGFyYW0ge05vZGVJbmZvfSBub2RlSW5mbyBOb2RlIG1ldGFkYXRhIGZvciBjdXJyZW50IHRlbXBsYXRlIG5vZGVcbiAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgdmlzaXRlZCBub2RlIGFkZGVkIG5vZGUtc3BlY2lmaWNcbiAgICAgICAqICAgbWV0YWRhdGEgdG8gYG5vZGVJbmZvYFxuICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICogQHN1cHByZXNzIHttaXNzaW5nUHJvcGVydGllc30gSW50ZXJmYWNlcyBpbiBjbG9zdXJlIGRvIG5vdCBpbmhlcml0IHN0YXRpY3MsIGJ1dCBjbGFzc2VzIGRvXG4gICAgICAgKi9cbiAgICAgIHN0YXRpYyBfcGFyc2VUZW1wbGF0ZU5vZGVBdHRyaWJ1dGUobm9kZSwgdGVtcGxhdGVJbmZvLCBub2RlSW5mbywgbmFtZSwgdmFsdWUpIHtcbiAgICAgICAgbGV0IHBhcnRzID0gdGhpcy5fcGFyc2VCaW5kaW5ncyh2YWx1ZSwgdGVtcGxhdGVJbmZvKTtcbiAgICAgICAgaWYgKHBhcnRzKSB7XG4gICAgICAgICAgLy8gQXR0cmlidXRlIG9yIHByb3BlcnR5XG4gICAgICAgICAgbGV0IG9yaWdOYW1lID0gbmFtZTtcbiAgICAgICAgICBsZXQga2luZCA9ICdwcm9wZXJ0eSc7XG4gICAgICAgICAgaWYgKG5hbWVbbmFtZS5sZW5ndGgtMV0gPT0gJyQnKSB7XG4gICAgICAgICAgICBuYW1lID0gbmFtZS5zbGljZSgwLCAtMSk7XG4gICAgICAgICAgICBraW5kID0gJ2F0dHJpYnV0ZSc7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIEluaXRpYWxpemUgYXR0cmlidXRlIGJpbmRpbmdzIHdpdGggYW55IGxpdGVyYWwgcGFydHNcbiAgICAgICAgICBsZXQgbGl0ZXJhbCA9IGxpdGVyYWxGcm9tUGFydHMocGFydHMpO1xuICAgICAgICAgIGlmIChsaXRlcmFsICYmIGtpbmQgPT0gJ2F0dHJpYnV0ZScpIHtcbiAgICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKG5hbWUsIGxpdGVyYWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBDbGVhciBhdHRyaWJ1dGUgYmVmb3JlIHJlbW92aW5nLCBzaW5jZSBJRSB3b24ndCBhbGxvdyByZW1vdmluZ1xuICAgICAgICAgIC8vIGB2YWx1ZWAgYXR0cmlidXRlIGlmIGl0IHByZXZpb3VzbHkgaGFkIGEgdmFsdWUgKGNhbid0XG4gICAgICAgICAgLy8gdW5jb25kaXRpb25hbGx5IHNldCAnJyBiZWZvcmUgcmVtb3Zpbmcgc2luY2UgYXR0cmlidXRlcyB3aXRoIGAkYFxuICAgICAgICAgIC8vIGNhbid0IGJlIHNldCB1c2luZyBzZXRBdHRyaWJ1dGUpXG4gICAgICAgICAgaWYgKG5vZGUubG9jYWxOYW1lID09PSAnaW5wdXQnICYmIG9yaWdOYW1lID09PSAndmFsdWUnKSB7XG4gICAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShvcmlnTmFtZSwgJycpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBSZW1vdmUgYW5ub3RhdGlvblxuICAgICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKG9yaWdOYW1lKTtcbiAgICAgICAgICAvLyBDYXNlIGhhY2tlcnk6IGF0dHJpYnV0ZXMgYXJlIGxvd2VyLWNhc2UsIGJ1dCBiaW5kIHRhcmdldHNcbiAgICAgICAgICAvLyAocHJvcGVydGllcykgYXJlIGNhc2Ugc2Vuc2l0aXZlLiBHYW1iaXQgaXMgdG8gbWFwIGRhc2gtY2FzZSB0b1xuICAgICAgICAgIC8vIGNhbWVsLWNhc2U6IGBmb28tYmFyYCBiZWNvbWVzIGBmb29CYXJgLlxuICAgICAgICAgIC8vIEF0dHJpYnV0ZSBiaW5kaW5ncyBhcmUgZXhjZXB0ZWQuXG4gICAgICAgICAgaWYgKGtpbmQgPT09ICdwcm9wZXJ0eScpIHtcbiAgICAgICAgICAgIG5hbWUgPSBQb2x5bWVyLkNhc2VNYXAuZGFzaFRvQ2FtZWxDYXNlKG5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhZGRCaW5kaW5nKHRoaXMsIHRlbXBsYXRlSW5mbywgbm9kZUluZm8sIGtpbmQsIG5hbWUsIHBhcnRzLCBsaXRlcmFsKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gc3VwZXIuX3BhcnNlVGVtcGxhdGVOb2RlQXR0cmlidXRlKG5vZGUsIHRlbXBsYXRlSW5mbywgbm9kZUluZm8sIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIE92ZXJyaWRlcyBkZWZhdWx0IGBUZW1wbGF0ZVN0YW1wYCBpbXBsZW1lbnRhdGlvbiB0byBhZGQgc3VwcG9ydCBmb3JcbiAgICAgICAqIGJpbmRpbmcgdGhlIHByb3BlcnRpZXMgdGhhdCBhIG5lc3RlZCB0ZW1wbGF0ZSBkZXBlbmRzIG9uIHRvIHRoZSB0ZW1wbGF0ZVxuICAgICAgICogYXMgYF9ob3N0Xzxwcm9wZXJ0eT5gLlxuICAgICAgICpcbiAgICAgICAqIEBvdmVycmlkZVxuICAgICAgICogQHBhcmFtIHtOb2RlfSBub2RlIE5vZGUgdG8gcGFyc2VcbiAgICAgICAqIEBwYXJhbSB7VGVtcGxhdGVJbmZvfSB0ZW1wbGF0ZUluZm8gVGVtcGxhdGUgbWV0YWRhdGEgZm9yIGN1cnJlbnQgdGVtcGxhdGVcbiAgICAgICAqIEBwYXJhbSB7Tm9kZUluZm99IG5vZGVJbmZvIE5vZGUgbWV0YWRhdGEgZm9yIGN1cnJlbnQgdGVtcGxhdGUgbm9kZVxuICAgICAgICogQHJldHVybiB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSB2aXNpdGVkIG5vZGUgYWRkZWQgbm9kZS1zcGVjaWZpY1xuICAgICAgICogICBtZXRhZGF0YSB0byBgbm9kZUluZm9gXG4gICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgKiBAc3VwcHJlc3Mge21pc3NpbmdQcm9wZXJ0aWVzfSBJbnRlcmZhY2VzIGluIGNsb3N1cmUgZG8gbm90IGluaGVyaXQgc3RhdGljcywgYnV0IGNsYXNzZXMgZG9cbiAgICAgICAqL1xuICAgICAgc3RhdGljIF9wYXJzZVRlbXBsYXRlTmVzdGVkVGVtcGxhdGUobm9kZSwgdGVtcGxhdGVJbmZvLCBub2RlSW5mbykge1xuICAgICAgICBsZXQgbm90ZWQgPSBzdXBlci5fcGFyc2VUZW1wbGF0ZU5lc3RlZFRlbXBsYXRlKG5vZGUsIHRlbXBsYXRlSW5mbywgbm9kZUluZm8pO1xuICAgICAgICAvLyBNZXJnZSBob3N0IHByb3BzIGludG8gb3V0ZXIgdGVtcGxhdGUgYW5kIGFkZCBiaW5kaW5nc1xuICAgICAgICBsZXQgaG9zdFByb3BzID0gbm9kZUluZm8udGVtcGxhdGVJbmZvLmhvc3RQcm9wcztcbiAgICAgICAgbGV0IG1vZGUgPSAneyc7XG4gICAgICAgIGZvciAobGV0IHNvdXJjZSBpbiBob3N0UHJvcHMpIHtcbiAgICAgICAgICBsZXQgcGFydHMgPSBbeyBtb2RlLCBzb3VyY2UsIGRlcGVuZGVuY2llczogW3NvdXJjZV0gfV07XG4gICAgICAgICAgYWRkQmluZGluZyh0aGlzLCB0ZW1wbGF0ZUluZm8sIG5vZGVJbmZvLCAncHJvcGVydHknLCAnX2hvc3RfJyArIHNvdXJjZSwgcGFydHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub3RlZDtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDYWxsZWQgdG8gcGFyc2UgdGV4dCBpbiBhIHRlbXBsYXRlIChlaXRoZXIgYXR0cmlidXRlIHZhbHVlcyBvclxuICAgICAgICogdGV4dENvbnRlbnQpIGludG8gYmluZGluZyBtZXRhZGF0YS5cbiAgICAgICAqXG4gICAgICAgKiBBbnkgb3ZlcnJpZGVzIG9mIHRoaXMgbWV0aG9kIHNob3VsZCByZXR1cm4gYW4gYXJyYXkgb2YgYmluZGluZyBwYXJ0XG4gICAgICAgKiBtZXRhZGF0YSAgcmVwcmVzZW50aW5nIG9uZSBvciBtb3JlIGJpbmRpbmdzIGZvdW5kIGluIHRoZSBwcm92aWRlZCB0ZXh0XG4gICAgICAgKiBhbmQgYW55IFwibGl0ZXJhbFwiIHRleHQgaW4gYmV0d2Vlbi4gIEFueSBub24tbGl0ZXJhbCBwYXJ0cyB3aWxsIGJlIHBhc3NlZFxuICAgICAgICogdG8gYF9ldmFsdWF0ZUJpbmRpbmdgIHdoZW4gYW55IGRlcGVuZGVuY2llcyBjaGFuZ2UuICBUaGUgb25seSByZXF1aXJlZFxuICAgICAgICogZmllbGRzIG9mIGVhY2ggXCJwYXJ0XCIgaW4gdGhlIHJldHVybmVkIGFycmF5IGFyZSBhcyBmb2xsb3dzOlxuICAgICAgICpcbiAgICAgICAqIC0gYGRlcGVuZGVuY2llc2AgLSBBcnJheSBjb250YWluaW5nIHRyaWdnZXIgbWV0YWRhdGEgZm9yIGVhY2ggcHJvcGVydHlcbiAgICAgICAqICAgdGhhdCBzaG91bGQgdHJpZ2dlciB0aGUgYmluZGluZyB0byB1cGRhdGVcbiAgICAgICAqIC0gYGxpdGVyYWxgIC0gU3RyaW5nIGNvbnRhaW5pbmcgdGV4dCBpZiB0aGUgcGFydCByZXByZXNlbnRzIGEgbGl0ZXJhbDtcbiAgICAgICAqICAgaW4gdGhpcyBjYXNlIG5vIGBkZXBlbmRlbmNpZXNgIGFyZSBuZWVkZWRcbiAgICAgICAqXG4gICAgICAgKiBBZGRpdGlvbmFsIG1ldGFkYXRhIGZvciB1c2UgYnkgYF9ldmFsdWF0ZUJpbmRpbmdgIG1heSBiZSBwcm92aWRlZCBpblxuICAgICAgICogZWFjaCBwYXJ0IG9iamVjdCBhcyBuZWVkZWQuXG4gICAgICAgKlxuICAgICAgICogVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gaGFuZGxlcyB0aGUgZm9sbG93aW5nIHR5cGVzIG9mIGJpbmRpbmdzXG4gICAgICAgKiAob25lIG9yIG1vcmUgbWF5IGJlIGludGVybWl4ZWQgd2l0aCBsaXRlcmFsIHN0cmluZ3MpOlxuICAgICAgICogLSBQcm9wZXJ0eSBiaW5kaW5nOiBgW1twcm9wXV1gXG4gICAgICAgKiAtIFBhdGggYmluZGluZzogYFtbb2JqZWN0LnByb3BdXWBcbiAgICAgICAqIC0gTmVnYXRlZCBwcm9wZXJ0eSBvciBwYXRoIGJpbmRpbmdzOiBgW1shcHJvcF1dYCBvciBgW1shb2JqZWN0LnByb3BdXWBcbiAgICAgICAqIC0gVHdvLXdheSBwcm9wZXJ0eSBvciBwYXRoIGJpbmRpbmdzIChzdXBwb3J0cyBuZWdhdGlvbik6XG4gICAgICAgKiAgIGB7e3Byb3B9fWAsIGB7e29iamVjdC5wcm9wfX1gLCBge3shcHJvcH19YCBvciBge3shb2JqZWN0LnByb3B9fWBcbiAgICAgICAqIC0gSW5saW5lIGNvbXB1dGVkIG1ldGhvZCAoc3VwcG9ydHMgbmVnYXRpb24pOlxuICAgICAgICogICBgW1tjb21wdXRlKGEsICdsaXRlcmFsJywgYildXWAsIGBbWyFjb21wdXRlKGEsICdsaXRlcmFsJywgYildXWBcbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBUZXh0IHRvIHBhcnNlIGZyb20gYXR0cmlidXRlIG9yIHRleHRDb250ZW50XG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gdGVtcGxhdGVJbmZvIEN1cnJlbnQgdGVtcGxhdGUgbWV0YWRhdGFcbiAgICAgICAqIEByZXR1cm4ge0FycmF5PCFCaW5kaW5nUGFydD59IEFycmF5IG9mIGJpbmRpbmcgcGFydCBtZXRhZGF0YVxuICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICovXG4gICAgICBzdGF0aWMgX3BhcnNlQmluZGluZ3ModGV4dCwgdGVtcGxhdGVJbmZvKSB7XG4gICAgICAgIGxldCBwYXJ0cyA9IFtdO1xuICAgICAgICBsZXQgbGFzdEluZGV4ID0gMDtcbiAgICAgICAgbGV0IG07XG4gICAgICAgIC8vIEV4YW1wbGU6IFwibGl0ZXJhbDF7e3Byb3B9fWxpdGVyYWwyW1shY29tcHV0ZShmb28sYmFyKV1dZmluYWxcIlxuICAgICAgICAvLyBSZWdleCBtYXRjaGVzOlxuICAgICAgICAvLyAgICAgICAgSXRlcmF0aW9uIDE6ICBJdGVyYXRpb24gMjpcbiAgICAgICAgLy8gbVsxXTogJ3t7JyAgICAgICAgICAnW1snXG4gICAgICAgIC8vIG1bMl06ICcnICAgICAgICAgICAgJyEnXG4gICAgICAgIC8vIG1bM106ICdwcm9wJyAgICAgICAgJ2NvbXB1dGUoZm9vLGJhciknXG4gICAgICAgIHdoaWxlICgobSA9IGJpbmRpbmdSZWdleC5leGVjKHRleHQpKSAhPT0gbnVsbCkge1xuICAgICAgICAgIC8vIEFkZCBsaXRlcmFsIHBhcnRcbiAgICAgICAgICBpZiAobS5pbmRleCA+IGxhc3RJbmRleCkge1xuICAgICAgICAgICAgcGFydHMucHVzaCh7bGl0ZXJhbDogdGV4dC5zbGljZShsYXN0SW5kZXgsIG0uaW5kZXgpfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIEFkZCBiaW5kaW5nIHBhcnRcbiAgICAgICAgICBsZXQgbW9kZSA9IG1bMV1bMF07XG4gICAgICAgICAgbGV0IG5lZ2F0ZSA9IEJvb2xlYW4obVsyXSk7XG4gICAgICAgICAgbGV0IHNvdXJjZSA9IG1bM10udHJpbSgpO1xuICAgICAgICAgIGxldCBjdXN0b21FdmVudCA9IGZhbHNlLCBub3RpZnlFdmVudCA9ICcnLCBjb2xvbiA9IC0xO1xuICAgICAgICAgIGlmIChtb2RlID09ICd7JyAmJiAoY29sb24gPSBzb3VyY2UuaW5kZXhPZignOjonKSkgPiAwKSB7XG4gICAgICAgICAgICBub3RpZnlFdmVudCA9IHNvdXJjZS5zdWJzdHJpbmcoY29sb24gKyAyKTtcbiAgICAgICAgICAgIHNvdXJjZSA9IHNvdXJjZS5zdWJzdHJpbmcoMCwgY29sb24pO1xuICAgICAgICAgICAgY3VzdG9tRXZlbnQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgc2lnbmF0dXJlID0gcGFyc2VNZXRob2Qoc291cmNlKTtcbiAgICAgICAgICBsZXQgZGVwZW5kZW5jaWVzID0gW107XG4gICAgICAgICAgaWYgKHNpZ25hdHVyZSkge1xuICAgICAgICAgICAgLy8gSW5saW5lIGNvbXB1dGVkIGZ1bmN0aW9uXG4gICAgICAgICAgICBsZXQge2FyZ3MsIG1ldGhvZE5hbWV9ID0gc2lnbmF0dXJlO1xuICAgICAgICAgICAgZm9yIChsZXQgaT0wOyBpPGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgbGV0IGFyZyA9IGFyZ3NbaV07XG4gICAgICAgICAgICAgIGlmICghYXJnLmxpdGVyYWwpIHtcbiAgICAgICAgICAgICAgICBkZXBlbmRlbmNpZXMucHVzaChhcmcpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZHluYW1pY0ZucyA9IHRlbXBsYXRlSW5mby5keW5hbWljRm5zO1xuICAgICAgICAgICAgaWYgKGR5bmFtaWNGbnMgJiYgZHluYW1pY0Zuc1ttZXRob2ROYW1lXSB8fCBzaWduYXR1cmUuc3RhdGljKSB7XG4gICAgICAgICAgICAgIGRlcGVuZGVuY2llcy5wdXNoKG1ldGhvZE5hbWUpO1xuICAgICAgICAgICAgICBzaWduYXR1cmUuZHluYW1pY0ZuID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gUHJvcGVydHkgb3IgcGF0aFxuICAgICAgICAgICAgZGVwZW5kZW5jaWVzLnB1c2goc291cmNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcGFydHMucHVzaCh7XG4gICAgICAgICAgICBzb3VyY2UsIG1vZGUsIG5lZ2F0ZSwgY3VzdG9tRXZlbnQsIHNpZ25hdHVyZSwgZGVwZW5kZW5jaWVzLFxuICAgICAgICAgICAgZXZlbnQ6IG5vdGlmeUV2ZW50XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgbGFzdEluZGV4ID0gYmluZGluZ1JlZ2V4Lmxhc3RJbmRleDtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgYSBmaW5hbCBsaXRlcmFsIHBhcnRcbiAgICAgICAgaWYgKGxhc3RJbmRleCAmJiBsYXN0SW5kZXggPCB0ZXh0Lmxlbmd0aCkge1xuICAgICAgICAgIGxldCBsaXRlcmFsID0gdGV4dC5zdWJzdHJpbmcobGFzdEluZGV4KTtcbiAgICAgICAgICBpZiAobGl0ZXJhbCkge1xuICAgICAgICAgICAgcGFydHMucHVzaCh7XG4gICAgICAgICAgICAgIGxpdGVyYWw6IGxpdGVyYWxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydHMubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIHBhcnRzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ2FsbGVkIHRvIGV2YWx1YXRlIGEgcHJldmlvdXNseSBwYXJzZWQgYmluZGluZyBwYXJ0IGJhc2VkIG9uIGEgc2V0IG9mXG4gICAgICAgKiBvbmUgb3IgbW9yZSBjaGFuZ2VkIGRlcGVuZGVuY2llcy5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3RoaXN9IGluc3QgRWxlbWVudCB0aGF0IHNob3VsZCBiZSB1c2VkIGFzIHNjb3BlIGZvclxuICAgICAgICogICBiaW5kaW5nIGRlcGVuZGVuY2llc1xuICAgICAgICogQHBhcmFtIHtCaW5kaW5nUGFydH0gcGFydCBCaW5kaW5nIHBhcnQgbWV0YWRhdGFcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFByb3BlcnR5L3BhdGggdGhhdCB0cmlnZ2VyZWQgdGhpcyBlZmZlY3RcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBCYWcgb2YgY3VycmVudCBwcm9wZXJ0eSBjaGFuZ2VzXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gb2xkUHJvcHMgQmFnIG9mIHByZXZpb3VzIHZhbHVlcyBmb3IgY2hhbmdlZCBwcm9wZXJ0aWVzXG4gICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhhc1BhdGhzIFRydWUgd2l0aCBgcHJvcHNgIGNvbnRhaW5zIG9uZSBvciBtb3JlIHBhdGhzXG4gICAgICAgKiBAcmV0dXJuIHsqfSBWYWx1ZSB0aGUgYmluZGluZyBwYXJ0IGV2YWx1YXRlZCB0b1xuICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICovXG4gICAgICBzdGF0aWMgX2V2YWx1YXRlQmluZGluZyhpbnN0LCBwYXJ0LCBwYXRoLCBwcm9wcywgb2xkUHJvcHMsIGhhc1BhdGhzKSB7XG4gICAgICAgIGxldCB2YWx1ZTtcbiAgICAgICAgaWYgKHBhcnQuc2lnbmF0dXJlKSB7XG4gICAgICAgICAgdmFsdWUgPSBydW5NZXRob2RFZmZlY3QoaW5zdCwgcGF0aCwgcHJvcHMsIG9sZFByb3BzLCBwYXJ0LnNpZ25hdHVyZSk7XG4gICAgICAgIH0gZWxzZSBpZiAocGF0aCAhPSBwYXJ0LnNvdXJjZSkge1xuICAgICAgICAgIHZhbHVlID0gUG9seW1lci5QYXRoLmdldChpbnN0LCBwYXJ0LnNvdXJjZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGhhc1BhdGhzICYmIFBvbHltZXIuUGF0aC5pc1BhdGgocGF0aCkpIHtcbiAgICAgICAgICAgIHZhbHVlID0gUG9seW1lci5QYXRoLmdldChpbnN0LCBwYXRoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsdWUgPSBpbnN0Ll9fZGF0YVtwYXRoXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnQubmVnYXRlKSB7XG4gICAgICAgICAgdmFsdWUgPSAhdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuXG4gICAgfVxuXG4gICAgLy8gbWFrZSBhIHR5cGluZyBmb3IgY2xvc3VyZSA6UFxuICAgIFByb3BlcnR5RWZmZWN0c1R5cGUgPSBQcm9wZXJ0eUVmZmVjdHM7XG5cbiAgICByZXR1cm4gUHJvcGVydHlFZmZlY3RzO1xuICB9KTtcblxuICAvKipcbiAgICogSGVscGVyIGFwaSBmb3IgZW5xdWVpbmcgY2xpZW50IGRvbSBjcmVhdGVkIGJ5IGEgaG9zdCBlbGVtZW50LlxuICAgKlxuICAgKiBCeSBkZWZhdWx0IGVsZW1lbnRzIGFyZSBmbHVzaGVkIHZpYSBgX2ZsdXNoUHJvcGVydGllc2Agd2hlblxuICAgKiBgY29ubmVjdGVkQ2FsbGJhY2tgIGlzIGNhbGxlZC4gRWxlbWVudHMgYXR0YWNoIHRoZWlyIGNsaWVudCBkb20gdG9cbiAgICogdGhlbXNlbHZlcyBhdCBgcmVhZHlgIHRpbWUgd2hpY2ggcmVzdWx0cyBmcm9tIHRoaXMgZmlyc3QgZmx1c2guXG4gICAqIFRoaXMgcHJvdmlkZXMgYW4gb3JkZXJpbmcgZ3VhcmFudGVlIHRoYXQgdGhlIGNsaWVudCBkb20gYW4gZWxlbWVudFxuICAgKiBjcmVhdGVzIGlzIGZsdXNoZWQgYmVmb3JlIHRoZSBlbGVtZW50IGl0c2VsZiAoaS5lLiBjbGllbnQgYHJlYWR5YFxuICAgKiBmaXJlcyBiZWZvcmUgaG9zdCBgcmVhZHlgKS5cbiAgICpcbiAgICogSG93ZXZlciwgaWYgYF9mbHVzaFByb3BlcnRpZXNgIGlzIGNhbGxlZCAqYmVmb3JlKiBhbiBlbGVtZW50IGlzIGNvbm5lY3RlZCxcbiAgICogYXMgZm9yIGV4YW1wbGUgYFRlbXBsYXRpemVgIGRvZXMsIHRoaXMgb3JkZXJpbmcgZ3VhcmFudGVlIGNhbm5vdCBiZVxuICAgKiBzYXRpc2ZpZWQgYmVjYXVzZSBubyBlbGVtZW50cyBhcmUgY29ubmVjdGVkLiAoTm90ZTogQm91bmQgZWxlbWVudHMgdGhhdFxuICAgKiByZWNlaXZlIGRhdGEgZG8gYmVjb21lIGVucXVldWVkIGNsaWVudHMgYW5kIGFyZSBwcm9wZXJseSBvcmRlcmVkIGJ1dFxuICAgKiB1bmJvdW5kIGVsZW1lbnRzIGFyZSBub3QuKVxuICAgKlxuICAgKiBUbyBtYWludGFpbiB0aGUgZGVzaXJlZCBcImNsaWVudCBiZWZvcmUgaG9zdFwiIG9yZGVyaW5nIGd1YXJhbnRlZSBmb3IgdGhpc1xuICAgKiBjYXNlIHdlIHJlbHkgb24gdGhlIFwiaG9zdCBzdGFjay4gQ2xpZW50IG5vZGVzIHJlZ2lzdGVycyB0aGVtc2VsdmVzIHdpdGhcbiAgICogdGhlIGNyZWF0aW5nIGhvc3QgZWxlbWVudCB3aGVuIGNyZWF0ZWQuIFRoaXMgZW5zdXJlcyB0aGF0IGFsbCBjbGllbnQgZG9tXG4gICAqIGlzIHJlYWRpZWQgaW4gdGhlIHByb3BlciBvcmRlciwgbWFpbnRhaW5pbmcgdGhlIGRlc2lyZWQgZ3VhcmFudGVlLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgbGV0IGhvc3RTdGFjayA9IHtcblxuICAgIHN0YWNrOiBbXSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Kn0gaW5zdCBJbnN0YW5jZSB0byBhZGQgdG8gaG9zdFN0YWNrXG4gICAgICogQHRoaXMge2hvc3RTdGFja31cbiAgICAgKi9cbiAgICByZWdpc3Rlckhvc3QoaW5zdCkge1xuICAgICAgaWYgKHRoaXMuc3RhY2subGVuZ3RoKSB7XG4gICAgICAgIGxldCBob3N0ID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aC0xXTtcbiAgICAgICAgaG9zdC5fZW5xdWV1ZUNsaWVudChpbnN0KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHsqfSBpbnN0IEluc3RhbmNlIHRvIGJlZ2luIGhvc3RpbmdcbiAgICAgKiBAdGhpcyB7aG9zdFN0YWNrfVxuICAgICAqL1xuICAgIGJlZ2luSG9zdGluZyhpbnN0KSB7XG4gICAgICB0aGlzLnN0YWNrLnB1c2goaW5zdCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Kn0gaW5zdCBJbnN0YW5jZSB0byBlbmQgaG9zdGluZ1xuICAgICAqIEB0aGlzIHtob3N0U3RhY2t9XG4gICAgICovXG4gICAgZW5kSG9zdGluZyhpbnN0KSB7XG4gICAgICBsZXQgc3RhY2tMZW4gPSB0aGlzLnN0YWNrLmxlbmd0aDtcbiAgICAgIGlmIChzdGFja0xlbiAmJiB0aGlzLnN0YWNrW3N0YWNrTGVuLTFdID09IGluc3QpIHtcbiAgICAgICAgdGhpcy5zdGFjay5wb3AoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgfVxuXG59KSgpO1xuPC9zY3JpcHQ+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL3BvbHltZXIvbGliL21peGlucy9wcm9wZXJ0eS1lZmZlY3RzLmh0bWwiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiYm9vdC5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwibWl4aW4uaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cImFzeW5jLmh0bWxcIj5cblxuPHNjcmlwdD5cbihmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8qKiBAdHlwZWRlZiB7e3J1bjogZnVuY3Rpb24oZnVuY3Rpb24oKSwgbnVtYmVyPSk6bnVtYmVyLCBjYW5jZWw6IGZ1bmN0aW9uKG51bWJlcil9fSAqL1xuICBsZXQgQXN5bmNNb2R1bGU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblxuICAvKipcbiAgICogQHN1bW1hcnkgQ29sbGFwc2UgbXVsdGlwbGUgY2FsbGJhY2tzIGludG8gb25lIGludm9jYXRpb24gYWZ0ZXIgYSB0aW1lci5cbiAgICogQG1lbWJlcm9mIFBvbHltZXJcbiAgICovXG4gIGNsYXNzIERlYm91bmNlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICB0aGlzLl9hc3luY01vZHVsZSA9IG51bGw7XG4gICAgICB0aGlzLl9jYWxsYmFjayA9IG51bGw7XG4gICAgICB0aGlzLl90aW1lciA9IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHNjaGVkdWxlcjsgdGhhdCBpcywgYSBtb2R1bGUgd2l0aCB0aGUgQXN5bmMgaW50ZXJmYWNlLFxuICAgICAqIGEgY2FsbGJhY2sgYW5kIG9wdGlvbmFsIGFyZ3VtZW50cyB0byBiZSBwYXNzZWQgdG8gdGhlIHJ1biBmdW5jdGlvblxuICAgICAqIGZyb20gdGhlIGFzeW5jIG1vZHVsZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IUFzeW5jTW9kdWxlfSBhc3luY01vZHVsZSBPYmplY3Qgd2l0aCBBc3luYyBpbnRlcmZhY2UuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbigpfSBjYWxsYmFjayBDYWxsYmFjayB0byBydW4uXG4gICAgICovXG4gICAgc2V0Q29uZmlnKGFzeW5jTW9kdWxlLCBjYWxsYmFjaykge1xuICAgICAgdGhpcy5fYXN5bmNNb2R1bGUgPSBhc3luY01vZHVsZTtcbiAgICAgIHRoaXMuX2NhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICB0aGlzLl90aW1lciA9IHRoaXMuX2FzeW5jTW9kdWxlLnJ1bigoKSA9PiB7XG4gICAgICAgIHRoaXMuX3RpbWVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5fY2FsbGJhY2soKVxuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbmNlbHMgYW4gYWN0aXZlIGRlYm91bmNlciBhbmQgcmV0dXJucyBhIHJlZmVyZW5jZSB0byBpdHNlbGYuXG4gICAgICovXG4gICAgY2FuY2VsKCkge1xuICAgICAgaWYgKHRoaXMuaXNBY3RpdmUoKSkge1xuICAgICAgICB0aGlzLl9hc3luY01vZHVsZS5jYW5jZWwodGhpcy5fdGltZXIpO1xuICAgICAgICB0aGlzLl90aW1lciA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZsdXNoZXMgYW4gYWN0aXZlIGRlYm91bmNlciBhbmQgcmV0dXJucyBhIHJlZmVyZW5jZSB0byBpdHNlbGYuXG4gICAgICovXG4gICAgZmx1c2goKSB7XG4gICAgICBpZiAodGhpcy5pc0FjdGl2ZSgpKSB7XG4gICAgICAgIHRoaXMuY2FuY2VsKCk7XG4gICAgICAgIHRoaXMuX2NhbGxiYWNrKCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZGVib3VuY2VyIGlzIGFjdGl2ZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYWN0aXZlLlxuICAgICAqL1xuICAgIGlzQWN0aXZlKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3RpbWVyICE9IG51bGw7XG4gICAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIGRlYm91bmNlciBpZiBubyBkZWJvdW5jZXIgaXMgcGFzc2VkIGFzIGEgcGFyYW1ldGVyXG4gICAqIG9yIGl0IGNhbmNlbHMgYW4gYWN0aXZlIGRlYm91bmNlciBvdGhlcndpc2UuIFRoZSBmb2xsb3dpbmdcbiAgICogZXhhbXBsZSBzaG93cyBob3cgYSBkZWJvdW5jZXIgY2FuIGJlIGNhbGxlZCBtdWx0aXBsZSB0aW1lcyB3aXRoaW4gYVxuICAgKiBtaWNyb3Rhc2sgYW5kIFwiZGVib3VuY2VkXCIgc3VjaCB0aGF0IHRoZSBwcm92aWRlZCBjYWxsYmFjayBmdW5jdGlvbiBpc1xuICAgKiBjYWxsZWQgb25jZS4gQWRkIHRoaXMgbWV0aG9kIHRvIGEgY3VzdG9tIGVsZW1lbnQ6XG4gICAqXG4gICAqIF9kZWJvdW5jZVdvcmsoKSB7XG4gICAqICAgdGhpcy5fZGVib3VuY2VKb2IgPSBQb2x5bWVyLkRlYm91bmNlci5kZWJvdW5jZSh0aGlzLl9kZWJvdW5jZUpvYixcbiAgICogICAgICAgUG9seW1lci5Bc3luYy5taWNyb1Rhc2ssICgpID0+IHtcbiAgICogICAgIHRoaXMuX2RvV29yaygpO1xuICAgKiAgIH0pO1xuICAgKiB9XG4gICAqXG4gICAqIElmIHRoZSBgX2RlYm91bmNlV29ya2AgbWV0aG9kIGlzIGNhbGxlZCBtdWx0aXBsZSB0aW1lcyB3aXRoaW4gdGhlIHNhbWVcbiAgICogbWljcm90YXNrLCB0aGUgYF9kb1dvcmtgIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIG9ubHkgb25jZSBhdCB0aGUgbmV4dFxuICAgKiBtaWNyb3Rhc2sgY2hlY2twb2ludC5cbiAgICpcbiAgICogTm90ZTogSW4gdGVzdGluZyBpdCBpcyBvZnRlbiBjb252ZW5pZW50IHRvIGF2b2lkIGFzeW5jaHJvbnkuIFRvIGFjY29tcGxpc2hcbiAgICogdGhpcyB3aXRoIGEgZGVib3VuY2VyLCB5b3UgY2FuIHVzZSBgUG9seW1lci5lbnF1ZXVlRGVib3VuY2VyYCBhbmRcbiAgICogYFBvbHltZXIuZmx1c2hgLiBGb3IgZXhhbXBsZSwgZXh0ZW5kIHRoZSBhYm92ZSBleGFtcGxlIGJ5IGFkZGluZ1xuICAgKiBgUG9seW1lci5lbnF1ZXVlRGVib3VuY2VyKHRoaXMuX2RlYm91bmNlSm9iKWAgYXQgdGhlIGVuZCBvZiB0aGVcbiAgICogYF9kZWJvdW5jZVdvcmtgIG1ldGhvZC4gVGhlbiBpbiBhIHRlc3QsIGNhbGwgYFBvbHltZXIuZmx1c2hgIHRvIGVuc3VyZVxuICAgKiB0aGUgZGVib3VuY2VyIGhhcyBjb21wbGV0ZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7RGVib3VuY2VyP30gZGVib3VuY2VyIERlYm91bmNlciBvYmplY3QuXG4gICAqIEBwYXJhbSB7IUFzeW5jTW9kdWxlfSBhc3luY01vZHVsZSBPYmplY3Qgd2l0aCBBc3luYyBpbnRlcmZhY2VcbiAgICogQHBhcmFtIHtmdW5jdGlvbigpfSBjYWxsYmFjayBDYWxsYmFjayB0byBydW4uXG4gICAqIEByZXR1cm4geyFEZWJvdW5jZXJ9IFJldHVybnMgYSBkZWJvdW5jZXIgb2JqZWN0LlxuICAgKi9cbiAgICBzdGF0aWMgZGVib3VuY2UoZGVib3VuY2VyLCBhc3luY01vZHVsZSwgY2FsbGJhY2spIHtcbiAgICAgIGlmIChkZWJvdW5jZXIgaW5zdGFuY2VvZiBEZWJvdW5jZXIpIHtcbiAgICAgICAgZGVib3VuY2VyLmNhbmNlbCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVib3VuY2VyID0gbmV3IERlYm91bmNlcigpO1xuICAgICAgfVxuICAgICAgZGVib3VuY2VyLnNldENvbmZpZyhhc3luY01vZHVsZSwgY2FsbGJhY2spO1xuICAgICAgcmV0dXJuIGRlYm91bmNlcjtcbiAgICB9XG4gIH1cblxuICBQb2x5bWVyLkRlYm91bmNlciA9IERlYm91bmNlcjtcbn0pKCk7XG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvdXRpbHMvZGVib3VuY2UuaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCJib290Lmh0bWxcIj5cbjxzY3JpcHQ+XG4oZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBsZXQgZGVib3VuY2VyUXVldWUgPSBbXTtcblxuICAvKipcbiAgICogQWRkcyBhIGBQb2x5bWVyLkRlYm91bmNlcmAgdG8gYSBsaXN0IG9mIGdsb2JhbGx5IGZsdXNoYWJsZSB0YXNrcy5cbiAgICpcbiAgICogQG1lbWJlcm9mIFBvbHltZXJcbiAgICogQHBhcmFtIHtQb2x5bWVyLkRlYm91bmNlcn0gZGVib3VuY2VyIERlYm91bmNlciB0byBlbnF1ZXVlXG4gICAqL1xuICBQb2x5bWVyLmVucXVldWVEZWJvdW5jZXIgPSBmdW5jdGlvbihkZWJvdW5jZXIpIHtcbiAgICBkZWJvdW5jZXJRdWV1ZS5wdXNoKGRlYm91bmNlcik7XG4gIH1cblxuICBmdW5jdGlvbiBmbHVzaERlYm91bmNlcnMoKSB7XG4gICAgY29uc3QgZGlkRmx1c2ggPSBCb29sZWFuKGRlYm91bmNlclF1ZXVlLmxlbmd0aCk7XG4gICAgd2hpbGUgKGRlYm91bmNlclF1ZXVlLmxlbmd0aCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZGVib3VuY2VyUXVldWUuc2hpZnQoKS5mbHVzaCgpO1xuICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGlkRmx1c2g7XG4gIH1cblxuICAvKipcbiAgICogRm9yY2VzIHNldmVyYWwgY2xhc3NlcyBvZiBhc3luY2hyb25vdXNseSBxdWV1ZWQgdGFza3MgdG8gZmx1c2g6XG4gICAqIC0gRGVib3VuY2VycyBhZGRlZCB2aWEgYGVucXVldWVEZWJvdW5jZXJgXG4gICAqIC0gU2hhZHlET00gZGlzdHJpYnV0aW9uXG4gICAqXG4gICAqIEBtZW1iZXJvZiBQb2x5bWVyXG4gICAqL1xuICBQb2x5bWVyLmZsdXNoID0gZnVuY3Rpb24oKSB7XG4gICAgbGV0IHNoYWR5RE9NLCBkZWJvdW5jZXJzO1xuICAgIGRvIHtcbiAgICAgIHNoYWR5RE9NID0gd2luZG93LlNoYWR5RE9NICYmIFNoYWR5RE9NLmZsdXNoKCk7XG4gICAgICBpZiAod2luZG93LlNoYWR5Q1NTICYmIHdpbmRvdy5TaGFkeUNTUy5TY29waW5nU2hpbSkge1xuICAgICAgICB3aW5kb3cuU2hhZHlDU1MuU2NvcGluZ1NoaW0uZmx1c2goKTtcbiAgICAgIH1cbiAgICAgIGRlYm91bmNlcnMgPSBmbHVzaERlYm91bmNlcnMoKTtcbiAgICB9IHdoaWxlIChzaGFkeURPTSB8fCBkZWJvdW5jZXJzKTtcbiAgfVxuXG59KSgpO1xuPC9zY3JpcHQ+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL3BvbHltZXIvbGliL3V0aWxzL2ZsdXNoLmh0bWwiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCJib290Lmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi9taXhpbnMvcHJvcGVydHktZWZmZWN0cy5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vbWl4aW5zL211dGFibGUtZGF0YS5odG1sXCI+XG5cbjxzY3JpcHQ+XG4gIChmdW5jdGlvbigpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICAvLyBCYXNlIGNsYXNzIGZvciBIVE1MVGVtcGxhdGVFbGVtZW50IGV4dGVuc2lvbiB0aGF0IGhhcyBwcm9wZXJ0eSBlZmZlY3RzXG4gICAgLy8gbWFjaGluZXJ5IGZvciBwcm9wYWdhdGluZyBob3N0IHByb3BlcnRpZXMgdG8gY2hpbGRyZW4uIFRoaXMgaXMgYW4gRVM1XG4gICAgLy8gY2xhc3Mgb25seSBiZWNhdXNlIEJhYmVsIChpbmNvcnJlY3RseSkgcmVxdWlyZXMgc3VwZXIoKSBpbiB0aGUgY2xhc3NcbiAgICAvLyBjb25zdHJ1Y3RvciBldmVuIHRob3VnaCBubyBgdGhpc2AgaXMgdXNlZCBhbmQgaXQgcmV0dXJucyBhbiBpbnN0YW5jZS5cbiAgICBsZXQgbmV3SW5zdGFuY2UgPSBudWxsO1xuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBleHRlbmRzIHtIVE1MVGVtcGxhdGVFbGVtZW50fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEhUTUxUZW1wbGF0ZUVsZW1lbnRFeHRlbnNpb24oKSB7IHJldHVybiBuZXdJbnN0YW5jZTsgfVxuICAgIEhUTUxUZW1wbGF0ZUVsZW1lbnRFeHRlbnNpb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShIVE1MVGVtcGxhdGVFbGVtZW50LnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IEhUTUxUZW1wbGF0ZUVsZW1lbnRFeHRlbnNpb24sXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQGltcGxlbWVudHMge1BvbHltZXJfUHJvcGVydHlFZmZlY3RzfVxuICAgICAqIEBleHRlbmRzIHtIVE1MVGVtcGxhdGVFbGVtZW50RXh0ZW5zaW9ufVxuICAgICAqL1xuICAgIGNvbnN0IERhdGFUZW1wbGF0ZSA9IFBvbHltZXIuUHJvcGVydHlFZmZlY3RzKEhUTUxUZW1wbGF0ZUVsZW1lbnRFeHRlbnNpb24pO1xuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBpbXBsZW1lbnRzIHtQb2x5bWVyX011dGFibGVEYXRhfVxuICAgICAqIEBleHRlbmRzIHtEYXRhVGVtcGxhdGV9XG4gICAgICovXG4gICAgY29uc3QgTXV0YWJsZURhdGFUZW1wbGF0ZSA9IFBvbHltZXIuTXV0YWJsZURhdGEoRGF0YVRlbXBsYXRlKTtcblxuICAgIC8vIEFwcGxpZXMgYSBEYXRhVGVtcGxhdGUgc3ViY2xhc3MgdG8gYSA8dGVtcGxhdGU+IGluc3RhbmNlXG4gICAgZnVuY3Rpb24gdXBncmFkZVRlbXBsYXRlKHRlbXBsYXRlLCBjb25zdHJ1Y3Rvcikge1xuICAgICAgbmV3SW5zdGFuY2UgPSB0ZW1wbGF0ZTtcbiAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0ZW1wbGF0ZSwgY29uc3RydWN0b3IucHJvdG90eXBlKTtcbiAgICAgIG5ldyBjb25zdHJ1Y3RvcigpO1xuICAgICAgbmV3SW5zdGFuY2UgPSBudWxsO1xuICAgIH1cblxuICAgIC8vIEJhc2UgY2xhc3MgZm9yIFRlbXBsYXRlSW5zdGFuY2Unc1xuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBpbXBsZW1lbnRzIHtQb2x5bWVyX1Byb3BlcnR5RWZmZWN0c31cbiAgICAgKi9cbiAgICBjb25zdCBiYXNlID0gUG9seW1lci5Qcm9wZXJ0eUVmZmVjdHMoY2xhc3Mge30pO1xuXG4gICAgLyoqXG4gICAgICogQHBvbHltZXJcbiAgICAgKiBAY3VzdG9tRWxlbWVudFxuICAgICAqIEBhcHBsaWVzTWl4aW4gUG9seW1lci5Qcm9wZXJ0eUVmZmVjdHNcbiAgICAgKiBAdW5yZXN0cmljdGVkXG4gICAgICovXG4gICAgY2xhc3MgVGVtcGxhdGVJbnN0YW5jZUJhc2UgZXh0ZW5kcyBiYXNlIHtcbiAgICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX2NvbmZpZ3VyZVByb3BlcnRpZXMocHJvcHMpO1xuICAgICAgICB0aGlzLnJvb3QgPSB0aGlzLl9zdGFtcFRlbXBsYXRlKHRoaXMuX19kYXRhSG9zdCk7XG4gICAgICAgIC8vIFNhdmUgbGlzdCBvZiBzdGFtcGVkIGNoaWxkcmVuXG4gICAgICAgIGxldCBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgZm9yIChsZXQgbiA9IHRoaXMucm9vdC5maXJzdENoaWxkOyBuOyBuPW4ubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICBjaGlsZHJlbi5wdXNoKG4pO1xuICAgICAgICAgIG4uX190ZW1wbGF0aXplSW5zdGFuY2UgPSB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9fdGVtcGxhdGl6ZU93bmVyLl9faGlkZVRlbXBsYXRlQ2hpbGRyZW5fXykge1xuICAgICAgICAgIHRoaXMuX3Nob3dIaWRlQ2hpbGRyZW4odHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmx1c2ggcHJvcHMgb25seSB3aGVuIHByb3BzIGFyZSBwYXNzZWQgaWYgaW5zdGFuY2UgcHJvcHMgZXhpc3RcbiAgICAgICAgLy8gb3Igd2hlbiB0aGVyZSBpc24ndCBpbnN0YW5jZSBwcm9wcy5cbiAgICAgICAgbGV0IG9wdGlvbnMgPSB0aGlzLl9fdGVtcGxhdGl6ZU9wdGlvbnM7XG4gICAgICAgIGlmICgocHJvcHMgJiYgb3B0aW9ucy5pbnN0YW5jZVByb3BzKSB8fCAhb3B0aW9ucy5pbnN0YW5jZVByb3BzKSB7XG4gICAgICAgICAgdGhpcy5fZW5hYmxlUHJvcGVydGllcygpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIENvbmZpZ3VyZSB0aGUgZ2l2ZW4gYHByb3BzYCBieSBjYWxsaW5nIGBfc2V0UGVuZGluZ1Byb3BlcnR5YC4gQWxzb1xuICAgICAgICogc2V0cyBhbnkgcHJvcGVydGllcyBzdG9yZWQgaW4gYF9faG9zdFByb3BzYC5cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgT2JqZWN0IG9mIHByb3BlcnR5IG5hbWUtdmFsdWUgcGFpcnMgdG8gc2V0LlxuICAgICAgICovXG4gICAgICBfY29uZmlndXJlUHJvcGVydGllcyhwcm9wcykge1xuICAgICAgICBsZXQgb3B0aW9ucyA9IHRoaXMuX190ZW1wbGF0aXplT3B0aW9ucztcbiAgICAgICAgaWYgKHByb3BzKSB7XG4gICAgICAgICAgZm9yIChsZXQgaXByb3AgaW4gb3B0aW9ucy5pbnN0YW5jZVByb3BzKSB7XG4gICAgICAgICAgICBpZiAoaXByb3AgaW4gcHJvcHMpIHtcbiAgICAgICAgICAgICAgdGhpcy5fc2V0UGVuZGluZ1Byb3BlcnR5KGlwcm9wLCBwcm9wc1tpcHJvcF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBocHJvcCBpbiB0aGlzLl9faG9zdFByb3BzKSB7XG4gICAgICAgICAgdGhpcy5fc2V0UGVuZGluZ1Byb3BlcnR5KGhwcm9wLCB0aGlzLl9fZGF0YUhvc3RbJ19ob3N0XycgKyBocHJvcF0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIEZvcndhcmRzIGEgaG9zdCBwcm9wZXJ0eSB0byB0aGlzIGluc3RhbmNlLiAgVGhpcyBtZXRob2Qgc2hvdWxkIGJlXG4gICAgICAgKiBjYWxsZWQgb24gaW5zdGFuY2VzIGZyb20gdGhlIGBvcHRpb25zLmZvcndhcmRIb3N0UHJvcGAgY2FsbGJhY2tcbiAgICAgICAqIHRvIHByb3BhZ2F0ZSBjaGFuZ2VzIG9mIGhvc3QgcHJvcGVydGllcyB0byBlYWNoIGluc3RhbmNlLlxuICAgICAgICpcbiAgICAgICAqIE5vdGUgdGhpcyBtZXRob2QgZW5xdWV1ZXMgdGhlIGNoYW5nZSwgd2hpY2ggYXJlIGZsdXNoZWQgYXMgYSBiYXRjaC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcCBQcm9wZXJ0eSBvciBwYXRoIG5hbWVcbiAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgb2YgdGhlIHByb3BlcnR5IHRvIGZvcndhcmRcbiAgICAgICAqL1xuICAgICAgZm9yd2FyZEhvc3RQcm9wKHByb3AsIHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLl9zZXRQZW5kaW5nUHJvcGVydHlPclBhdGgocHJvcCwgdmFsdWUsIGZhbHNlLCB0cnVlKSkge1xuICAgICAgICAgIHRoaXMuX19kYXRhSG9zdC5fZW5xdWV1ZUNsaWVudCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBAb3ZlcnJpZGVcbiAgICAgICAqL1xuICAgICAgX2FkZEV2ZW50TGlzdGVuZXJUb05vZGUobm9kZSwgZXZlbnROYW1lLCBoYW5kbGVyKSB7XG4gICAgICAgIGlmICh0aGlzLl9tZXRob2RIb3N0ICYmIHRoaXMuX190ZW1wbGF0aXplT3B0aW9ucy5wYXJlbnRNb2RlbCkge1xuICAgICAgICAgIC8vIElmIHRoaXMgaW5zdGFuY2Ugc2hvdWxkIGJlIGNvbnNpZGVyZWQgYSBwYXJlbnQgbW9kZWwsIGRlY29yYXRlXG4gICAgICAgICAgLy8gZXZlbnRzIHRoaXMgdGVtcGxhdGUgaW5zdGFuY2UgYXMgYG1vZGVsYFxuICAgICAgICAgIHRoaXMuX21ldGhvZEhvc3QuX2FkZEV2ZW50TGlzdGVuZXJUb05vZGUobm9kZSwgZXZlbnROYW1lLCAoZSkgPT4ge1xuICAgICAgICAgICAgZS5tb2RlbCA9IHRoaXM7XG4gICAgICAgICAgICBoYW5kbGVyKGUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE90aGVyd2lzZSBkZWxlZ2F0ZSB0byB0aGUgdGVtcGxhdGUncyBob3N0ICh3aGljaCBjb3VsZCBiZSlcbiAgICAgICAgICAvLyBhbm90aGVyIHRlbXBsYXRlIGluc3RhbmNlXG4gICAgICAgICAgbGV0IHRlbXBsYXRlSG9zdCA9IHRoaXMuX19kYXRhSG9zdC5fX2RhdGFIb3N0O1xuICAgICAgICAgIGlmICh0ZW1wbGF0ZUhvc3QpIHtcbiAgICAgICAgICAgIHRlbXBsYXRlSG9zdC5fYWRkRXZlbnRMaXN0ZW5lclRvTm9kZShub2RlLCBldmVudE5hbWUsIGhhbmRsZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBTaG93cyBvciBoaWRlcyB0aGUgdGVtcGxhdGUgaW5zdGFuY2UgdG9wIGxldmVsIGNoaWxkIGVsZW1lbnRzLiBGb3JcbiAgICAgICAqIHRleHQgbm9kZXMsIGB0ZXh0Q29udGVudGAgaXMgcmVtb3ZlZCB3aGlsZSBcImhpZGRlblwiIGFuZCByZXBsYWNlZCB3aGVuXG4gICAgICAgKiBcInNob3duLlwiXG4gICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhpZGUgU2V0IHRvIHRydWUgdG8gaGlkZSB0aGUgY2hpbGRyZW47XG4gICAgICAgKiBzZXQgdG8gZmFsc2UgdG8gc2hvdyB0aGVtLlxuICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICovXG4gICAgICBfc2hvd0hpZGVDaGlsZHJlbihoaWRlKSB7XG4gICAgICAgIGxldCBjID0gdGhpcy5jaGlsZHJlbjtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPGMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBsZXQgbiA9IGNbaV07XG4gICAgICAgICAgLy8gSWdub3JlIG5vbi1jaGFuZ2VzXG4gICAgICAgICAgaWYgKEJvb2xlYW4oaGlkZSkgIT0gQm9vbGVhbihuLl9faGlkZVRlbXBsYXRlQ2hpbGRyZW5fXykpIHtcbiAgICAgICAgICAgIGlmIChuLm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSkge1xuICAgICAgICAgICAgICBpZiAoaGlkZSkge1xuICAgICAgICAgICAgICAgIG4uX19wb2x5bWVyVGV4dENvbnRlbnRfXyA9IG4udGV4dENvbnRlbnQ7XG4gICAgICAgICAgICAgICAgbi50ZXh0Q29udGVudCA9ICcnO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG4udGV4dENvbnRlbnQgPSBuLl9fcG9seW1lclRleHRDb250ZW50X187XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAobi5zdHlsZSkge1xuICAgICAgICAgICAgICBpZiAoaGlkZSkge1xuICAgICAgICAgICAgICAgIG4uX19wb2x5bWVyRGlzcGxheV9fID0gbi5zdHlsZS5kaXNwbGF5O1xuICAgICAgICAgICAgICAgIG4uc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBuLnN0eWxlLmRpc3BsYXkgPSBuLl9fcG9seW1lckRpc3BsYXlfXztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBuLl9faGlkZVRlbXBsYXRlQ2hpbGRyZW5fXyA9IGhpZGU7XG4gICAgICAgICAgaWYgKG4uX3Nob3dIaWRlQ2hpbGRyZW4pIHtcbiAgICAgICAgICAgIG4uX3Nob3dIaWRlQ2hpbGRyZW4oaGlkZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIE92ZXJyaWRlcyBkZWZhdWx0IHByb3BlcnR5LWVmZmVjdHMgaW1wbGVtZW50YXRpb24gdG8gaW50ZXJjZXB0XG4gICAgICAgKiB0ZXh0Q29udGVudCBiaW5kaW5ncyB3aGlsZSBjaGlsZHJlbiBhcmUgXCJoaWRkZW5cIiBhbmQgY2FjaGUgaW5cbiAgICAgICAqIHByaXZhdGUgc3RvcmFnZSBmb3IgbGF0ZXIgcmV0cmlldmFsLlxuICAgICAgICpcbiAgICAgICAqIEBvdmVycmlkZVxuICAgICAgICovXG4gICAgICBfc2V0VW5tYW5hZ2VkUHJvcGVydHlUb05vZGUobm9kZSwgcHJvcCwgdmFsdWUpIHtcbiAgICAgICAgaWYgKG5vZGUuX19oaWRlVGVtcGxhdGVDaGlsZHJlbl9fICYmXG4gICAgICAgICAgICBub2RlLm5vZGVUeXBlID09IE5vZGUuVEVYVF9OT0RFICYmIHByb3AgPT0gJ3RleHRDb250ZW50Jykge1xuICAgICAgICAgIG5vZGUuX19wb2x5bWVyVGV4dENvbnRlbnRfXyA9IHZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN1cGVyLl9zZXRVbm1hbmFnZWRQcm9wZXJ0eVRvTm9kZShub2RlLCBwcm9wLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogRmluZCB0aGUgcGFyZW50IG1vZGVsIG9mIHRoaXMgdGVtcGxhdGUgaW5zdGFuY2UuICBUaGUgcGFyZW50IG1vZGVsXG4gICAgICAgKiBpcyBlaXRoZXIgYW5vdGhlciB0ZW1wbGF0aXplIGluc3RhbmNlIHRoYXQgaGFkIG9wdGlvbiBgcGFyZW50TW9kZWw6IHRydWVgLFxuICAgICAgICogb3IgZWxzZSB0aGUgaG9zdCBlbGVtZW50LlxuICAgICAgICpcbiAgICAgICAqIEByZXR1cm4ge1BvbHltZXJfUHJvcGVydHlFZmZlY3RzfSBUaGUgcGFyZW50IG1vZGVsIG9mIHRoaXMgaW5zdGFuY2VcbiAgICAgICAqL1xuICAgICAgZ2V0IHBhcmVudE1vZGVsKCkge1xuICAgICAgICBsZXQgbW9kZWwgPSB0aGlzLl9fcGFyZW50TW9kZWw7XG4gICAgICAgIGlmICghbW9kZWwpIHtcbiAgICAgICAgICBsZXQgb3B0aW9ucztcbiAgICAgICAgICBtb2RlbCA9IHRoaXNcbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAvLyBBIHRlbXBsYXRlIGluc3RhbmNlJ3MgYF9fZGF0YUhvc3RgIGlzIGEgPHRlbXBsYXRlPlxuICAgICAgICAgICAgLy8gYG1vZGVsLl9fZGF0YUhvc3QuX19kYXRhSG9zdGAgaXMgdGhlIHRlbXBsYXRlJ3MgaG9zdFxuICAgICAgICAgICAgbW9kZWwgPSBtb2RlbC5fX2RhdGFIb3N0Ll9fZGF0YUhvc3Q7XG4gICAgICAgICAgfSB3aGlsZSAoKG9wdGlvbnMgPSBtb2RlbC5fX3RlbXBsYXRpemVPcHRpb25zKSAmJiAhb3B0aW9ucy5wYXJlbnRNb2RlbClcbiAgICAgICAgICB0aGlzLl9fcGFyZW50TW9kZWwgPSBtb2RlbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbW9kZWw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqIEB0eXBlIHshRGF0YVRlbXBsYXRlfSAqL1xuICAgIFRlbXBsYXRlSW5zdGFuY2VCYXNlLnByb3RvdHlwZS5fX2RhdGFIb3N0O1xuICAgIC8qKiBAdHlwZSB7IVRlbXBsYXRpemVPcHRpb25zfSAqL1xuICAgIFRlbXBsYXRlSW5zdGFuY2VCYXNlLnByb3RvdHlwZS5fX3RlbXBsYXRpemVPcHRpb25zO1xuICAgIC8qKiBAdHlwZSB7IVBvbHltZXJfUHJvcGVydHlFZmZlY3RzfSAqL1xuICAgIFRlbXBsYXRlSW5zdGFuY2VCYXNlLnByb3RvdHlwZS5fbWV0aG9kSG9zdDtcbiAgICAvKiogQHR5cGUgeyFPYmplY3R9ICovXG4gICAgVGVtcGxhdGVJbnN0YW5jZUJhc2UucHJvdG90eXBlLl9fdGVtcGxhdGl6ZU93bmVyO1xuICAgIC8qKiBAdHlwZSB7IU9iamVjdH0gKi9cbiAgICBUZW1wbGF0ZUluc3RhbmNlQmFzZS5wcm90b3R5cGUuX19ob3N0UHJvcHM7XG5cbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAZXh0ZW5kcyB7VGVtcGxhdGVJbnN0YW5jZUJhc2V9XG4gICAgICogQGltcGxlbWVudHMge1BvbHltZXJfTXV0YWJsZURhdGF9XG4gICAgICovXG4gICAgY29uc3QgTXV0YWJsZVRlbXBsYXRlSW5zdGFuY2VCYXNlID0gUG9seW1lci5NdXRhYmxlRGF0YShUZW1wbGF0ZUluc3RhbmNlQmFzZSk7XG5cbiAgICBmdW5jdGlvbiBmaW5kTWV0aG9kSG9zdCh0ZW1wbGF0ZSkge1xuICAgICAgLy8gVGVjaG5pY2FsbHkgdGhpcyBzaG91bGQgYmUgdGhlIG93bmVyIG9mIHRoZSBvdXRlcm1vc3QgdGVtcGxhdGUuXG4gICAgICAvLyBJbiBzaGFkb3cgZG9tLCB0aGlzIGlzIGFsd2F5cyBnZXRSb290Tm9kZSgpLmhvc3QsIGJ1dCB3ZSBjYW5cbiAgICAgIC8vIGFwcHJveGltYXRlIHRoaXMgdmlhIGNvb3BlcmF0aW9uIHdpdGggb3VyIGRhdGFIb3N0IGFsd2F5cyBzZXR0aW5nXG4gICAgICAvLyBgX21ldGhvZEhvc3RgIGFzIGxvbmcgYXMgdGhlcmUgd2VyZSBiaW5kaW5ncyAob3IgaWQncykgb24gdGhpc1xuICAgICAgLy8gaW5zdGFuY2UgY2F1c2luZyBpdCB0byBnZXQgYSBkYXRhSG9zdC5cbiAgICAgIGxldCB0ZW1wbGF0ZUhvc3QgPSB0ZW1wbGF0ZS5fX2RhdGFIb3N0O1xuICAgICAgcmV0dXJuIHRlbXBsYXRlSG9zdCAmJiB0ZW1wbGF0ZUhvc3QuX21ldGhvZEhvc3QgfHwgdGVtcGxhdGVIb3N0O1xuICAgIH1cblxuICAgIC8qIGVzbGludC1kaXNhYmxlIHZhbGlkLWpzZG9jICovXG4gICAgLyoqXG4gICAgICogQHN1cHByZXNzIHttaXNzaW5nUHJvcGVydGllc30gY2xhc3MucHJvdG90eXBlIGlzIG5vdCBkZWZpbmVkIGZvciBzb21lIHJlYXNvblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVRlbXBsYXRpemVyQ2xhc3ModGVtcGxhdGUsIHRlbXBsYXRlSW5mbywgb3B0aW9ucykge1xuICAgICAgLy8gQW5vbnltb3VzIGNsYXNzIGNyZWF0ZWQgYnkgdGhlIHRlbXBsYXRpemVcbiAgICAgIGxldCBiYXNlID0gb3B0aW9ucy5tdXRhYmxlRGF0YSA/XG4gICAgICAgIE11dGFibGVUZW1wbGF0ZUluc3RhbmNlQmFzZSA6IFRlbXBsYXRlSW5zdGFuY2VCYXNlO1xuICAgICAgLyoqXG4gICAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgICAqIEBleHRlbmRzIHtiYXNlfVxuICAgICAgICovXG4gICAgICBsZXQga2xhc3MgPSBjbGFzcyBleHRlbmRzIGJhc2UgeyB9XG4gICAgICBrbGFzcy5wcm90b3R5cGUuX190ZW1wbGF0aXplT3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICBrbGFzcy5wcm90b3R5cGUuX2JpbmRUZW1wbGF0ZSh0ZW1wbGF0ZSk7XG4gICAgICBhZGROb3RpZnlFZmZlY3RzKGtsYXNzLCB0ZW1wbGF0ZSwgdGVtcGxhdGVJbmZvLCBvcHRpb25zKTtcbiAgICAgIHJldHVybiBrbGFzcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAc3VwcHJlc3Mge21pc3NpbmdQcm9wZXJ0aWVzfSBjbGFzcy5wcm90b3R5cGUgaXMgbm90IGRlZmluZWQgZm9yIHNvbWUgcmVhc29uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYWRkUHJvcGFnYXRlRWZmZWN0cyh0ZW1wbGF0ZSwgdGVtcGxhdGVJbmZvLCBvcHRpb25zKSB7XG4gICAgICBsZXQgdXNlckZvcndhcmRIb3N0UHJvcCA9IG9wdGlvbnMuZm9yd2FyZEhvc3RQcm9wO1xuICAgICAgaWYgKHVzZXJGb3J3YXJkSG9zdFByb3ApIHtcbiAgICAgICAgLy8gUHJvdmlkZSBkYXRhIEFQSSBhbmQgcHJvcGVydHkgZWZmZWN0cyBvbiBtZW1vaXplZCB0ZW1wbGF0ZSBjbGFzc1xuICAgICAgICBsZXQga2xhc3MgPSB0ZW1wbGF0ZUluZm8udGVtcGxhdGl6ZVRlbXBsYXRlQ2xhc3M7XG4gICAgICAgIGlmICgha2xhc3MpIHtcbiAgICAgICAgICBsZXQgYmFzZSA9IG9wdGlvbnMubXV0YWJsZURhdGEgPyBNdXRhYmxlRGF0YVRlbXBsYXRlIDogRGF0YVRlbXBsYXRlO1xuICAgICAgICAgIGtsYXNzID0gdGVtcGxhdGVJbmZvLnRlbXBsYXRpemVUZW1wbGF0ZUNsYXNzID1cbiAgICAgICAgICAgIGNsYXNzIFRlbXBsYXRpemVkVGVtcGxhdGUgZXh0ZW5kcyBiYXNlIHt9XG4gICAgICAgICAgLy8gQWRkIHRlbXBsYXRlIC0gPmluc3RhbmNlcyBlZmZlY3RzXG4gICAgICAgICAgLy8gYW5kIGhvc3QgPC0gdGVtcGxhdGUgZWZmZWN0c1xuICAgICAgICAgIGxldCBob3N0UHJvcHMgPSB0ZW1wbGF0ZUluZm8uaG9zdFByb3BzO1xuICAgICAgICAgIGZvciAobGV0IHByb3AgaW4gaG9zdFByb3BzKSB7XG4gICAgICAgICAgICBrbGFzcy5wcm90b3R5cGUuX2FkZFByb3BlcnR5RWZmZWN0KCdfaG9zdF8nICsgcHJvcCxcbiAgICAgICAgICAgICAga2xhc3MucHJvdG90eXBlLlBST1BFUlRZX0VGRkVDVF9UWVBFUy5QUk9QQUdBVEUsXG4gICAgICAgICAgICAgIHtmbjogY3JlYXRlRm9yd2FyZEhvc3RQcm9wRWZmZWN0KHByb3AsIHVzZXJGb3J3YXJkSG9zdFByb3ApfSk7XG4gICAgICAgICAgICBrbGFzcy5wcm90b3R5cGUuX2NyZWF0ZU5vdGlmeWluZ1Byb3BlcnR5KCdfaG9zdF8nICsgcHJvcCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHVwZ3JhZGVUZW1wbGF0ZSh0ZW1wbGF0ZSwga2xhc3MpO1xuICAgICAgICAvLyBNaXggYW55IHByZS1ib3VuZCBkYXRhIGludG8gX19kYXRhOyBubyBuZWVkIHRvIGZsdXNoIHRoaXMgdG9cbiAgICAgICAgLy8gaW5zdGFuY2VzIHNpbmNlIHRoZXkgcHVsbCBmcm9tIHRoZSB0ZW1wbGF0ZSBhdCBpbnN0YW5jZS10aW1lXG4gICAgICAgIGlmICh0ZW1wbGF0ZS5fX2RhdGFQcm90bykge1xuICAgICAgICAgIC8vIE5vdGUsIGdlbmVyYWxseSBgX19kYXRhUHJvdG9gIGNvdWxkIGJlIGNoYWluZWQsIGJ1dCBpdCdzIGd1YXJhbnRlZWRcbiAgICAgICAgICAvLyB0byBub3QgYmUgc2luY2UgdGhpcyBpcyBhIHZhbmlsbGEgdGVtcGxhdGUgd2UganVzdCBhZGRlZCBlZmZlY3RzIHRvXG4gICAgICAgICAgT2JqZWN0LmFzc2lnbih0ZW1wbGF0ZS5fX2RhdGEsIHRlbXBsYXRlLl9fZGF0YVByb3RvKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDbGVhciBhbnkgcGVuZGluZyBkYXRhIGZvciBwZXJmb3JtYW5jZVxuICAgICAgICB0ZW1wbGF0ZS5fX2RhdGFUZW1wID0ge307XG4gICAgICAgIHRlbXBsYXRlLl9fZGF0YVBlbmRpbmcgPSBudWxsO1xuICAgICAgICB0ZW1wbGF0ZS5fX2RhdGFPbGQgPSBudWxsO1xuICAgICAgICB0ZW1wbGF0ZS5fZW5hYmxlUHJvcGVydGllcygpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKiBlc2xpbnQtZW5hYmxlIHZhbGlkLWpzZG9jICovXG5cbiAgICBmdW5jdGlvbiBjcmVhdGVGb3J3YXJkSG9zdFByb3BFZmZlY3QoaG9zdFByb3AsIHVzZXJGb3J3YXJkSG9zdFByb3ApIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiBmb3J3YXJkSG9zdFByb3AodGVtcGxhdGUsIHByb3AsIHByb3BzKSB7XG4gICAgICAgIHVzZXJGb3J3YXJkSG9zdFByb3AuY2FsbCh0ZW1wbGF0ZS5fX3RlbXBsYXRpemVPd25lcixcbiAgICAgICAgICBwcm9wLnN1YnN0cmluZygnX2hvc3RfJy5sZW5ndGgpLCBwcm9wc1twcm9wXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkTm90aWZ5RWZmZWN0cyhrbGFzcywgdGVtcGxhdGUsIHRlbXBsYXRlSW5mbywgb3B0aW9ucykge1xuICAgICAgbGV0IGhvc3RQcm9wcyA9IHRlbXBsYXRlSW5mby5ob3N0UHJvcHMgfHwge307XG4gICAgICBmb3IgKGxldCBpcHJvcCBpbiBvcHRpb25zLmluc3RhbmNlUHJvcHMpIHtcbiAgICAgICAgZGVsZXRlIGhvc3RQcm9wc1tpcHJvcF07XG4gICAgICAgIGxldCB1c2VyTm90aWZ5SW5zdGFuY2VQcm9wID0gb3B0aW9ucy5ub3RpZnlJbnN0YW5jZVByb3A7XG4gICAgICAgIGlmICh1c2VyTm90aWZ5SW5zdGFuY2VQcm9wKSB7XG4gICAgICAgICAga2xhc3MucHJvdG90eXBlLl9hZGRQcm9wZXJ0eUVmZmVjdChpcHJvcCxcbiAgICAgICAgICAgIGtsYXNzLnByb3RvdHlwZS5QUk9QRVJUWV9FRkZFQ1RfVFlQRVMuTk9USUZZLFxuICAgICAgICAgICAge2ZuOiBjcmVhdGVOb3RpZnlJbnN0YW5jZVByb3BFZmZlY3QoaXByb3AsIHVzZXJOb3RpZnlJbnN0YW5jZVByb3ApfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLmZvcndhcmRIb3N0UHJvcCAmJiB0ZW1wbGF0ZS5fX2RhdGFIb3N0KSB7XG4gICAgICAgIGZvciAobGV0IGhwcm9wIGluIGhvc3RQcm9wcykge1xuICAgICAgICAgIGtsYXNzLnByb3RvdHlwZS5fYWRkUHJvcGVydHlFZmZlY3QoaHByb3AsXG4gICAgICAgICAgICBrbGFzcy5wcm90b3R5cGUuUFJPUEVSVFlfRUZGRUNUX1RZUEVTLk5PVElGWSxcbiAgICAgICAgICAgIHtmbjogY3JlYXRlTm90aWZ5SG9zdFByb3BFZmZlY3QoKX0pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVOb3RpZnlJbnN0YW5jZVByb3BFZmZlY3QoaW5zdFByb3AsIHVzZXJOb3RpZnlJbnN0YW5jZVByb3ApIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiBub3RpZnlJbnN0YW5jZVByb3AoaW5zdCwgcHJvcCwgcHJvcHMpIHtcbiAgICAgICAgdXNlck5vdGlmeUluc3RhbmNlUHJvcC5jYWxsKGluc3QuX190ZW1wbGF0aXplT3duZXIsXG4gICAgICAgICAgaW5zdCwgcHJvcCwgcHJvcHNbcHJvcF0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZU5vdGlmeUhvc3RQcm9wRWZmZWN0KCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIG5vdGlmeUhvc3RQcm9wKGluc3QsIHByb3AsIHByb3BzKSB7XG4gICAgICAgIGluc3QuX19kYXRhSG9zdC5fc2V0UGVuZGluZ1Byb3BlcnR5T3JQYXRoKCdfaG9zdF8nICsgcHJvcCwgcHJvcHNbcHJvcF0sIHRydWUsIHRydWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1vZHVsZSBmb3IgcHJlcGFyaW5nIGFuZCBzdGFtcGluZyBpbnN0YW5jZXMgb2YgdGVtcGxhdGVzIHRoYXQgdXRpbGl6ZVxuICAgICAqIFBvbHltZXIncyBkYXRhLWJpbmRpbmcgYW5kIGRlY2xhcmF0aXZlIGV2ZW50IGxpc3RlbmVyIGZlYXR1cmVzLlxuICAgICAqXG4gICAgICogRXhhbXBsZTpcbiAgICAgKlxuICAgICAqICAgICAvLyBHZXQgYSB0ZW1wbGF0ZSBmcm9tIHNvbWV3aGVyZSwgZS5nLiBsaWdodCBET01cbiAgICAgKiAgICAgbGV0IHRlbXBsYXRlID0gdGhpcy5xdWVyeVNlbGVjdG9yKCd0ZW1wbGF0ZScpO1xuICAgICAqICAgICAvLyBQcmVwYXJlIHRoZSB0ZW1wbGF0ZVxuICAgICAqICAgICBsZXQgVGVtcGxhdGVDbGFzcyA9IFBvbHltZXIuVGVtcGxhdGl6ZS50ZW1wbGF0aXplKHRlbXBsYXRlKTtcbiAgICAgKiAgICAgLy8gSW5zdGFuY2UgdGhlIHRlbXBsYXRlIHdpdGggYW4gaW5pdGlhbCBkYXRhIG1vZGVsXG4gICAgICogICAgIGxldCBpbnN0YW5jZSA9IG5ldyBUZW1wbGF0ZUNsYXNzKHtteVByb3A6ICdpbml0aWFsJ30pO1xuICAgICAqICAgICAvLyBJbnNlcnQgdGhlIGluc3RhbmNlJ3MgRE9NIHNvbWV3aGVyZSwgZS5nLiBlbGVtZW50J3Mgc2hhZG93IERPTVxuICAgICAqICAgICB0aGlzLnNoYWRvd1Jvb3QuYXBwZW5kQ2hpbGQoaW5zdGFuY2Uucm9vdCk7XG4gICAgICogICAgIC8vIENoYW5naW5nIGEgcHJvcGVydHkgb24gdGhlIGluc3RhbmNlIHdpbGwgcHJvcGFnYXRlIHRvIGJpbmRpbmdzXG4gICAgICogICAgIC8vIGluIHRoZSB0ZW1wbGF0ZVxuICAgICAqICAgICBpbnN0YW5jZS5teVByb3AgPSAnbmV3IHZhbHVlJztcbiAgICAgKlxuICAgICAqIFRoZSBgb3B0aW9uc2AgZGljdGlvbmFyeSBwYXNzZWQgdG8gYHRlbXBsYXRpemVgIGFsbG93cyBmb3IgY3VzdG9taXppbmdcbiAgICAgKiBmZWF0dXJlcyBvZiB0aGUgZ2VuZXJhdGVkIHRlbXBsYXRlIGNsYXNzLCBpbmNsdWRpbmcgaG93IG91dGVyLXNjb3BlIGhvc3RcbiAgICAgKiBwcm9wZXJ0aWVzIHNob3VsZCBiZSBmb3J3YXJkZWQgaW50byB0ZW1wbGF0ZSBpbnN0YW5jZXMsIGhvdyBhbnkgaW5zdGFuY2VcbiAgICAgKiBwcm9wZXJ0aWVzIGFkZGVkIGludG8gdGhlIHRlbXBsYXRlJ3Mgc2NvcGUgc2hvdWxkIGJlIG5vdGlmaWVkIG91dCB0b1xuICAgICAqIHRoZSBob3N0LCBhbmQgd2hldGhlciB0aGUgaW5zdGFuY2Ugc2hvdWxkIGJlIGRlY29yYXRlZCBhcyBhIFwicGFyZW50IG1vZGVsXCJcbiAgICAgKiBvZiBhbnkgZXZlbnQgaGFuZGxlcnMuXG4gICAgICpcbiAgICAgKiAgICAgLy8gQ3VzdG9temUgcHJvcGVydHkgZm9yd2FyZGluZyBhbmQgZXZlbnQgbW9kZWwgZGVjb3JhdGlvblxuICAgICAqICAgICBsZXQgVGVtcGxhdGVDbGFzcyA9IFBvbHltZXIuVGVtcGxhdGl6ZS50ZW1wbGF0aXplKHRlbXBsYXRlLCB0aGlzLCB7XG4gICAgICogICAgICAgcGFyZW50TW9kZWw6IHRydWUsXG4gICAgICogICAgICAgaW5zdGFuY2VQcm9wczogey4uLn0sXG4gICAgICogICAgICAgZm9yd2FyZEhvc3RQcm9wKHByb3BlcnR5LCB2YWx1ZSkgey4uLn0sXG4gICAgICogICAgICAgbm90aWZ5SW5zdGFuY2VQcm9wKGluc3RhbmNlLCBwcm9wZXJ0eSwgdmFsdWUpIHsuLi59LFxuICAgICAqICAgICB9KTtcbiAgICAgKlxuICAgICAqXG4gICAgICogQG5hbWVzcGFjZVxuICAgICAqIEBtZW1iZXJvZiBQb2x5bWVyXG4gICAgICogQHN1bW1hcnkgTW9kdWxlIGZvciBwcmVwYXJpbmcgYW5kIHN0YW1waW5nIGluc3RhbmNlcyBvZiB0ZW1wbGF0ZXNcbiAgICAgKiAgIHV0aWxpemluZyBQb2x5bWVyIHRlbXBsYXRpbmcgZmVhdHVyZXMuXG4gICAgICovXG5cbiAgICBjb25zdCBUZW1wbGF0aXplID0ge1xuXG4gICAgICAvKipcbiAgICAgICAqIFJldHVybnMgYW4gYW5vbnltb3VzIGBQb2x5bWVyLlByb3BlcnR5RWZmZWN0c2AgY2xhc3MgYm91bmQgdG8gdGhlXG4gICAgICAgKiBgPHRlbXBsYXRlPmAgcHJvdmlkZWQuICBJbnN0YW5jaW5nIHRoZSBjbGFzcyB3aWxsIHJlc3VsdCBpbiB0aGVcbiAgICAgICAqIHRlbXBsYXRlIGJlaW5nIHN0YW1wZWQgaW50byBkb2N1bWVudCBmcmFnbWVudCBzdG9yZWQgYXMgdGhlIGluc3RhbmNlJ3NcbiAgICAgICAqIGByb290YCBwcm9wZXJ0eSwgYWZ0ZXIgd2hpY2ggaXQgY2FuIGJlIGFwcGVuZGVkIHRvIHRoZSBET00uXG4gICAgICAgKlxuICAgICAgICogVGVtcGxhdGVzIG1heSB1dGlsaXplIGFsbCBQb2x5bWVyIGRhdGEtYmluZGluZyBmZWF0dXJlcyBhcyB3ZWxsIGFzXG4gICAgICAgKiBkZWNsYXJhdGl2ZSBldmVudCBsaXN0ZW5lcnMuICBFdmVudCBsaXN0ZW5lcnMgYW5kIGlubGluZSBjb21wdXRpbmdcbiAgICAgICAqIGZ1bmN0aW9ucyBpbiB0aGUgdGVtcGxhdGUgd2lsbCBiZSBjYWxsZWQgb24gdGhlIGhvc3Qgb2YgdGhlIHRlbXBsYXRlLlxuICAgICAgICpcbiAgICAgICAqIFRoZSBjb25zdHJ1Y3RvciByZXR1cm5lZCB0YWtlcyBhIHNpbmdsZSBhcmd1bWVudCBkaWN0aW9uYXJ5IG9mIGluaXRpYWxcbiAgICAgICAqIHByb3BlcnR5IHZhbHVlcyB0byBwcm9wYWdhdGUgaW50byB0ZW1wbGF0ZSBiaW5kaW5ncy4gIEFkZGl0aW9uYWxseVxuICAgICAgICogaG9zdCBwcm9wZXJ0aWVzIGNhbiBiZSBmb3J3YXJkZWQgaW4sIGFuZCBpbnN0YW5jZSBwcm9wZXJ0aWVzIGNhbiBiZVxuICAgICAgICogbm90aWZpZWQgb3V0IGJ5IHByb3ZpZGluZyBvcHRpb25hbCBjYWxsYmFja3MgaW4gdGhlIGBvcHRpb25zYCBkaWN0aW9uYXJ5LlxuICAgICAgICpcbiAgICAgICAqIFZhbGlkIGNvbmZpZ3VyYXRpb24gaW4gYG9wdGlvbnNgIGFyZSBhcyBmb2xsb3dzOlxuICAgICAgICpcbiAgICAgICAqIC0gYGZvcndhcmRIb3N0UHJvcChwcm9wZXJ0eSwgdmFsdWUpYDogQ2FsbGVkIHdoZW4gYSBwcm9wZXJ0eSByZWZlcmVuY2VkXG4gICAgICAgKiAgIGluIHRoZSB0ZW1wbGF0ZSBjaGFuZ2VkIG9uIHRoZSB0ZW1wbGF0ZSdzIGhvc3QuIEFzIHRoaXMgbGlicmFyeSBkb2VzXG4gICAgICAgKiAgIG5vdCByZXRhaW4gcmVmZXJlbmNlcyB0byB0ZW1wbGF0ZXMgaW5zdGFuY2VkIGJ5IHRoZSB1c2VyLCBpdCBpcyB0aGVcbiAgICAgICAqICAgdGVtcGxhdGl6ZSBvd25lcidzIHJlc3BvbnNpYmlsaXR5IHRvIGZvcndhcmQgaG9zdCBwcm9wZXJ0eSBjaGFuZ2VzIGludG9cbiAgICAgICAqICAgdXNlci1zdGFtcGVkIGluc3RhbmNlcy4gIFRoZSBgaW5zdGFuY2UuZm9yd2FyZEhvc3RQcm9wKHByb3BlcnR5LCB2YWx1ZSlgXG4gICAgICAgKiAgICBtZXRob2Qgb24gdGhlIGdlbmVyYXRlZCBjbGFzcyBzaG91bGQgYmUgY2FsbGVkIHRvIGZvcndhcmQgaG9zdFxuICAgICAgICogICBwcm9wZXJ0aWVzIGludG8gdGhlIHRlbXBsYXRlIHRvIHByZXZlbnQgdW5uZWNlc3NhcnkgcHJvcGVydHktY2hhbmdlZFxuICAgICAgICogICBub3RpZmljYXRpb25zLiBBbnkgcHJvcGVydGllcyByZWZlcmVuY2VkIGluIHRoZSB0ZW1wbGF0ZSB0aGF0IGFyZSBub3RcbiAgICAgICAqICAgZGVmaW5lZCBpbiBgaW5zdGFuY2VQcm9wc2Agd2lsbCBiZSBub3RpZmllZCB1cCB0byB0aGUgdGVtcGxhdGUncyBob3N0XG4gICAgICAgKiAgIGF1dG9tYXRpY2FsbHkuXG4gICAgICAgKiAtIGBpbnN0YW5jZVByb3BzYDogRGljdGlvbmFyeSBvZiBwcm9wZXJ0eSBuYW1lcyB0aGF0IHdpbGwgYmUgYWRkZWRcbiAgICAgICAqICAgdG8gdGhlIGluc3RhbmNlIGJ5IHRoZSB0ZW1wbGF0aXplIG93bmVyLiAgVGhlc2UgcHJvcGVydGllcyBzaGFkb3cgYW55XG4gICAgICAgKiAgIGhvc3QgcHJvcGVydGllcywgYW5kIGNoYW5nZXMgd2l0aGluIHRoZSB0ZW1wbGF0ZSB0byB0aGVzZSBwcm9wZXJ0aWVzXG4gICAgICAgKiAgIHdpbGwgcmVzdWx0IGluIGBub3RpZnlJbnN0YW5jZVByb3BgIGJlaW5nIGNhbGxlZC5cbiAgICAgICAqIC0gYG11dGFibGVEYXRhYDogV2hlbiBgdHJ1ZWAsIHRoZSBnZW5lcmF0ZWQgY2xhc3Mgd2lsbCBza2lwIHN0cmljdFxuICAgICAgICogICBkaXJ0eS1jaGVja2luZyBmb3Igb2JqZWN0cyBhbmQgYXJyYXlzIChhbHdheXMgY29uc2lkZXIgdGhlbSB0byBiZVxuICAgICAgICogICBcImRpcnR5XCIpLlxuICAgICAgICogLSBgbm90aWZ5SW5zdGFuY2VQcm9wKGluc3RhbmNlLCBwcm9wZXJ0eSwgdmFsdWUpYDogQ2FsbGVkIHdoZW5cbiAgICAgICAqICAgYW4gaW5zdGFuY2UgcHJvcGVydHkgY2hhbmdlcy4gIFVzZXJzIG1heSBjaG9vc2UgdG8gY2FsbCBgbm90aWZ5UGF0aGBcbiAgICAgICAqICAgb24gZS5nLiB0aGUgb3duZXIgdG8gbm90aWZ5IHRoZSBjaGFuZ2UuXG4gICAgICAgKiAtIGBwYXJlbnRNb2RlbGA6IFdoZW4gYHRydWVgLCBldmVudHMgaGFuZGxlZCBieSBkZWNsYXJhdGl2ZSBldmVudCBsaXN0ZW5lcnNcbiAgICAgICAqICAgKGBvbi1ldmVudD1cImhhbmRsZXJcImApIHdpbGwgYmUgZGVjb3JhdGVkIHdpdGggYSBgbW9kZWxgIHByb3BlcnR5IHBvaW50aW5nXG4gICAgICAgKiAgIHRvIHRoZSB0ZW1wbGF0ZSBpbnN0YW5jZSB0aGF0IHN0YW1wZWQgaXQuICBJdCB3aWxsIGFsc28gYmUgcmV0dXJuZWRcbiAgICAgICAqICAgZnJvbSBgaW5zdGFuY2UucGFyZW50TW9kZWxgIGluIGNhc2VzIHdoZXJlIHRlbXBsYXRlIGluc3RhbmNlIG5lc3RpbmdcbiAgICAgICAqICAgY2F1c2VzIGFuIGlubmVyIG1vZGVsIHRvIHNoYWRvdyBhbiBvdXRlciBtb2RlbC5cbiAgICAgICAqXG4gICAgICAgKiBOb3RlIHRoYXQgdGhlIGNsYXNzIHJldHVybmVkIGZyb20gYHRlbXBsYXRpemVgIGlzIGdlbmVyYXRlZCBvbmx5IG9uY2VcbiAgICAgICAqIGZvciBhIGdpdmVuIGA8dGVtcGxhdGU+YCB1c2luZyBgb3B0aW9uc2AgZnJvbSB0aGUgZmlyc3QgY2FsbCBmb3IgdGhhdFxuICAgICAgICogdGVtcGxhdGUsIGFuZCB0aGUgY2FjaGVkIGNsYXNzIGlzIHJldHVybmVkIGZvciBhbGwgc3Vic2VxdWVudCBjYWxscyB0b1xuICAgICAgICogYHRlbXBsYXRpemVgIGZvciB0aGF0IHRlbXBsYXRlLiAgQXMgc3VjaCwgYG9wdGlvbnNgIGNhbGxiYWNrcyBzaG91bGQgbm90XG4gICAgICAgKiBjbG9zZSBvdmVyIG93bmVyLXNwZWNpZmljIHByb3BlcnRpZXMgc2luY2Ugb25seSB0aGUgZmlyc3QgYG9wdGlvbnNgIGlzXG4gICAgICAgKiB1c2VkOyByYXRoZXIsIGNhbGxiYWNrcyBhcmUgY2FsbGVkIGJvdW5kIHRvIHRoZSBgb3duZXJgLCBhbmQgc28gY29udGV4dFxuICAgICAgICogbmVlZGVkIGZyb20gdGhlIGNhbGxiYWNrcyAoc3VjaCBhcyByZWZlcmVuY2VzIHRvIGBpbnN0YW5jZXNgIHN0YW1wZWQpXG4gICAgICAgKiBzaG91bGQgYmUgc3RvcmVkIG9uIHRoZSBgb3duZXJgIHN1Y2ggdGhhdCB0aGV5IGNhbiBiZSByZXRyaWV2ZWQgdmlhIGB0aGlzYC5cbiAgICAgICAqXG4gICAgICAgKiBAbWVtYmVyb2YgUG9seW1lci5UZW1wbGF0aXplXG4gICAgICAgKiBAcGFyYW0geyFIVE1MVGVtcGxhdGVFbGVtZW50fSB0ZW1wbGF0ZSBUZW1wbGF0ZSB0byB0ZW1wbGF0aXplXG4gICAgICAgKiBAcGFyYW0geyFQb2x5bWVyX1Byb3BlcnR5RWZmZWN0c30gb3duZXIgT3duZXIgb2YgdGhlIHRlbXBsYXRlIGluc3RhbmNlcztcbiAgICAgICAqICAgYW55IG9wdGlvbmFsIGNhbGxiYWNrcyB3aWxsIGJlIGJvdW5kIHRvIHRoaXMgb3duZXIuXG4gICAgICAgKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnMgT3B0aW9ucyBkaWN0aW9uYXJ5IChzZWUgc3VtbWFyeSBmb3IgZGV0YWlscylcbiAgICAgICAqIEByZXR1cm4ge2Z1bmN0aW9uKG5ldzpUZW1wbGF0ZUluc3RhbmNlQmFzZSl9IEdlbmVyYXRlZCBjbGFzcyBib3VuZCB0byB0aGUgdGVtcGxhdGVcbiAgICAgICAqICAgcHJvdmlkZWRcbiAgICAgICAqIEBzdXBwcmVzcyB7aW52YWxpZENhc3RzfVxuICAgICAgICovXG4gICAgICB0ZW1wbGF0aXplKHRlbXBsYXRlLCBvd25lciwgb3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gLyoqIEB0eXBlIHshVGVtcGxhdGl6ZU9wdGlvbnN9ICovKG9wdGlvbnMgfHwge30pO1xuICAgICAgICBpZiAodGVtcGxhdGUuX190ZW1wbGF0aXplT3duZXIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0EgPHRlbXBsYXRlPiBjYW4gb25seSBiZSB0ZW1wbGF0aXplZCBvbmNlJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGVtcGxhdGUuX190ZW1wbGF0aXplT3duZXIgPSBvd25lcjtcbiAgICAgICAgbGV0IHRlbXBsYXRlSW5mbyA9IG93bmVyLmNvbnN0cnVjdG9yLl9wYXJzZVRlbXBsYXRlKHRlbXBsYXRlKTtcbiAgICAgICAgLy8gR2V0IG1lbW9pemVkIGJhc2UgY2xhc3MgZm9yIHRoZSBwcm90b3R5cGljYWwgdGVtcGxhdGUsIHdoaWNoXG4gICAgICAgIC8vIGluY2x1ZGVzIHByb3BlcnR5IGVmZmVjdHMgZm9yIGJpbmRpbmcgdGVtcGxhdGUgJiBmb3J3YXJkaW5nXG4gICAgICAgIGxldCBiYXNlQ2xhc3MgPSB0ZW1wbGF0ZUluZm8udGVtcGxhdGl6ZUluc3RhbmNlQ2xhc3M7XG4gICAgICAgIGlmICghYmFzZUNsYXNzKSB7XG4gICAgICAgICAgYmFzZUNsYXNzID0gY3JlYXRlVGVtcGxhdGl6ZXJDbGFzcyh0ZW1wbGF0ZSwgdGVtcGxhdGVJbmZvLCBvcHRpb25zKTtcbiAgICAgICAgICB0ZW1wbGF0ZUluZm8udGVtcGxhdGl6ZUluc3RhbmNlQ2xhc3MgPSBiYXNlQ2xhc3M7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSG9zdCBwcm9wZXJ0eSBmb3J3YXJkaW5nIG11c3QgYmUgaW5zdGFsbGVkIG9udG8gdGVtcGxhdGUgaW5zdGFuY2VcbiAgICAgICAgYWRkUHJvcGFnYXRlRWZmZWN0cyh0ZW1wbGF0ZSwgdGVtcGxhdGVJbmZvLCBvcHRpb25zKTtcbiAgICAgICAgLy8gU3ViY2xhc3MgYmFzZSBjbGFzcyBhbmQgYWRkIHJlZmVyZW5jZSBmb3IgdGhpcyBzcGVjaWZpYyB0ZW1wbGF0ZVxuICAgICAgICBsZXQga2xhc3MgPSBjbGFzcyBUZW1wbGF0ZUluc3RhbmNlIGV4dGVuZHMgYmFzZUNsYXNzIHt9O1xuICAgICAgICBrbGFzcy5wcm90b3R5cGUuX21ldGhvZEhvc3QgPSBmaW5kTWV0aG9kSG9zdCh0ZW1wbGF0ZSk7XG4gICAgICAgIGtsYXNzLnByb3RvdHlwZS5fX2RhdGFIb3N0ID0gdGVtcGxhdGU7XG4gICAgICAgIGtsYXNzLnByb3RvdHlwZS5fX3RlbXBsYXRpemVPd25lciA9IG93bmVyO1xuICAgICAgICBrbGFzcy5wcm90b3R5cGUuX19ob3N0UHJvcHMgPSB0ZW1wbGF0ZUluZm8uaG9zdFByb3BzO1xuICAgICAgICByZXR1cm4gLyoqIEB0eXBlIHtmdW5jdGlvbihuZXc6VGVtcGxhdGVJbnN0YW5jZUJhc2UpfSAqLyhrbGFzcyk7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFJldHVybnMgdGhlIHRlbXBsYXRlIFwibW9kZWxcIiBhc3NvY2lhdGVkIHdpdGggYSBnaXZlbiBlbGVtZW50LCB3aGljaFxuICAgICAgICogc2VydmVzIGFzIHRoZSBiaW5kaW5nIHNjb3BlIGZvciB0aGUgdGVtcGxhdGUgaW5zdGFuY2UgdGhlIGVsZW1lbnQgaXNcbiAgICAgICAqIGNvbnRhaW5lZCBpbi4gQSB0ZW1wbGF0ZSBtb2RlbCBpcyBhbiBpbnN0YW5jZSBvZlxuICAgICAgICogYFRlbXBsYXRlSW5zdGFuY2VCYXNlYCwgYW5kIHNob3VsZCBiZSB1c2VkIHRvIG1hbmlwdWxhdGUgZGF0YVxuICAgICAgICogYXNzb2NpYXRlZCB3aXRoIHRoaXMgdGVtcGxhdGUgaW5zdGFuY2UuXG4gICAgICAgKlxuICAgICAgICogRXhhbXBsZTpcbiAgICAgICAqXG4gICAgICAgKiAgIGxldCBtb2RlbCA9IG1vZGVsRm9yRWxlbWVudChlbCk7XG4gICAgICAgKiAgIGlmIChtb2RlbC5pbmRleCA8IDEwKSB7XG4gICAgICAgKiAgICAgbW9kZWwuc2V0KCdpdGVtLmNoZWNrZWQnLCB0cnVlKTtcbiAgICAgICAqICAgfVxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJvZiBQb2x5bWVyLlRlbXBsYXRpemVcbiAgICAgICAqIEBwYXJhbSB7SFRNTFRlbXBsYXRlRWxlbWVudH0gdGVtcGxhdGUgVGhlIG1vZGVsIHdpbGwgYmUgcmV0dXJuZWQgZm9yXG4gICAgICAgKiAgIGVsZW1lbnRzIHN0YW1wZWQgZnJvbSB0aGlzIHRlbXBsYXRlXG4gICAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgTm9kZSBmb3Igd2hpY2ggdG8gcmV0dXJuIGEgdGVtcGxhdGUgbW9kZWwuXG4gICAgICAgKiBAcmV0dXJuIHtUZW1wbGF0ZUluc3RhbmNlQmFzZX0gVGVtcGxhdGUgaW5zdGFuY2UgcmVwcmVzZW50aW5nIHRoZVxuICAgICAgICogICBiaW5kaW5nIHNjb3BlIGZvciB0aGUgZWxlbWVudFxuICAgICAgICovXG4gICAgICBtb2RlbEZvckVsZW1lbnQodGVtcGxhdGUsIG5vZGUpIHtcbiAgICAgICAgbGV0IG1vZGVsO1xuICAgICAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICAgIC8vIEFuIGVsZW1lbnQgd2l0aCBhIF9fdGVtcGxhdGl6ZUluc3RhbmNlIG1hcmtzIHRoZSB0b3AgYm91bmRhcnlcbiAgICAgICAgICAvLyBvZiBhIHNjb3BlOyB3YWxrIHVwIHVudGlsIHdlIGZpbmQgb25lLCBhbmQgdGhlbiBlbnN1cmUgdGhhdFxuICAgICAgICAgIC8vIGl0cyBfX2RhdGFIb3N0IG1hdGNoZXMgYHRoaXNgLCBtZWFuaW5nIHRoaXMgZG9tLXJlcGVhdCBzdGFtcGVkIGl0XG4gICAgICAgICAgaWYgKChtb2RlbCA9IG5vZGUuX190ZW1wbGF0aXplSW5zdGFuY2UpKSB7XG4gICAgICAgICAgICAvLyBGb3VuZCBhbiBlbGVtZW50IHN0YW1wZWQgYnkgYW5vdGhlciB0ZW1wbGF0ZTsga2VlcCB3YWxraW5nIHVwXG4gICAgICAgICAgICAvLyBmcm9tIGl0cyBfX2RhdGFIb3N0XG4gICAgICAgICAgICBpZiAobW9kZWwuX19kYXRhSG9zdCAhPSB0ZW1wbGF0ZSkge1xuICAgICAgICAgICAgICBub2RlID0gbW9kZWwuX19kYXRhSG9zdDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBtb2RlbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gU3RpbGwgaW4gYSB0ZW1wbGF0ZSBzY29wZSwga2VlcCBnb2luZyB1cCB1bnRpbFxuICAgICAgICAgICAgLy8gYSBfX3RlbXBsYXRpemVJbnN0YW5jZSBpcyBmb3VuZFxuICAgICAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgUG9seW1lci5UZW1wbGF0aXplID0gVGVtcGxhdGl6ZTtcbiAgICBQb2x5bWVyLlRlbXBsYXRlSW5zdGFuY2VCYXNlID0gVGVtcGxhdGVJbnN0YW5jZUJhc2U7XG5cbiAgfSkoKTtcblxuPC9zY3JpcHQ+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL3BvbHltZXIvbGliL3V0aWxzL3RlbXBsYXRpemUuaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTYgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cblxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uLy4uL3BvbHltZXIvcG9seW1lci5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vLi4vaXJvbi1yZXNpemFibGUtYmVoYXZpb3IvaXJvbi1yZXNpemFibGUtYmVoYXZpb3IuaHRtbFwiPlxuXG48c2NyaXB0PlxuXG4gIC8qKlxuICAgKiBAcG9seW1lckJlaGF2aW9yIFBvbHltZXIuQXBwTGF5b3V0QmVoYXZpb3JcbiAgICoqL1xuICBQb2x5bWVyLkFwcExheW91dEJlaGF2aW9yID0gW1xuICAgIFBvbHltZXIuSXJvblJlc2l6YWJsZUJlaGF2aW9yLCB7XG5cbiAgICBsaXN0ZW5lcnM6IHtcbiAgICAgICdhcHAtcmVzZXQtbGF5b3V0JzogJ19hcHBSZXNldExheW91dEhhbmRsZXInLFxuICAgICAgJ2lyb24tcmVzaXplJzogJ3Jlc2V0TGF5b3V0J1xuICAgIH0sXG5cbiAgICBhdHRhY2hlZDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmZpcmUoJ2FwcC1yZXNldC1sYXlvdXQnKTtcbiAgICB9LFxuXG4gICAgX2FwcFJlc2V0TGF5b3V0SGFuZGxlcjogZnVuY3Rpb24oZSkge1xuICAgICAgaWYgKFBvbHltZXIuZG9tKGUpLnBhdGhbMF0gPT09IHRoaXMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5yZXNldExheW91dCgpO1xuICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9LFxuXG4gICAgX3VwZGF0ZUxheW91dFN0YXRlczogZnVuY3Rpb24oKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCd1bmltcGxlbWVudGVkJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlc2V0cyB0aGUgbGF5b3V0LiBJZiB5b3UgY2hhbmdlZCB0aGUgc2l6ZSBvZiB0aGlzIGVsZW1lbnQgdmlhIENTU1xuICAgICAqIHlvdSBjYW4gbm90aWZ5IHRoZSBjaGFuZ2VzIGJ5IGVpdGhlciBmaXJpbmcgdGhlIGBpcm9uLXJlc2l6ZWAgZXZlbnRcbiAgICAgKiBvciBjYWxsaW5nIGByZXNldExheW91dGAgZGlyZWN0bHkuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHJlc2V0TGF5b3V0XG4gICAgICovXG4gICAgcmVzZXRMYXlvdXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gUG9seW1lciB2Mi54XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgY2IgPSB0aGlzLl91cGRhdGVMYXlvdXRTdGF0ZXMuYmluZCh0aGlzKTtcbiAgICAgIGlmIChQb2x5bWVyLkFzeW5jICYmIFBvbHltZXIuQXN5bmMuYW5pbWF0aW9uRnJhbWUpIHtcbiAgICAgICAgdGhpcy5fbGF5b3V0RGVib3VuY2VyID0gUG9seW1lci5EZWJvdW5jZXIuZGVib3VuY2UoXG4gICAgICAgICAgICB0aGlzLl9sYXlvdXREZWJvdW5jZXIsXG4gICAgICAgICAgICBQb2x5bWVyLkFzeW5jLmFuaW1hdGlvbkZyYW1lLFxuICAgICAgICAgICAgY2IpO1xuICAgICAgICBQb2x5bWVyLmVucXVldWVEZWJvdW5jZXIodGhpcy5fbGF5b3V0RGVib3VuY2VyKTtcbiAgICAgIH1cbiAgICAgIC8vIFBvbHltZXIgdjEueFxuICAgICAgZWxzZSB7XG4gICAgICAgIHRoaXMuZGVib3VuY2UoJ3Jlc2V0TGF5b3V0JywgY2IpO1xuICAgICAgfVxuICAgICAgdGhpcy5fbm90aWZ5RGVzY2VuZGFudFJlc2l6ZSgpO1xuICAgIH0sXG5cbiAgICBfbm90aWZ5TGF5b3V0Q2hhbmdlZDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAvLyBUT0RPOiB0aGUgZXZlbnQgYGFwcC1yZXNldC1sYXlvdXRgIGNhbiBiZSBmaXJlZCBzeW5jaHJvbm91c2x5XG4gICAgICAvLyBhcyBsb25nIGFzIGBfdXBkYXRlTGF5b3V0U3RhdGVzYCB3YWl0cyBmb3IgYWxsIHRoZSBtaWNyb3Rhc2tzIGFmdGVyIHJBRi5cbiAgICAgIC8vIEUuZy4gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHNldFRpbWVPdXQoKSlcbiAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbigpIHtcbiAgICAgICAgc2VsZi5maXJlKCdhcHAtcmVzZXQtbGF5b3V0Jyk7XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgX25vdGlmeURlc2NlbmRhbnRSZXNpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLmlzQXR0YWNoZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5faW50ZXJlc3RlZFJlc2l6YWJsZXMuZm9yRWFjaChmdW5jdGlvbihyZXNpemFibGUpIHtcbiAgICAgICAgaWYgKHRoaXMucmVzaXplclNob3VsZE5vdGlmeShyZXNpemFibGUpKSB7XG4gICAgICAgICAgdGhpcy5fbm90aWZ5RGVzY2VuZGFudChyZXNpemFibGUpO1xuICAgICAgICB9XG4gICAgICB9LCB0aGlzKTtcbiAgICB9XG4gIH1dO1xuXG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvYXBwLWxheW91dC9hcHAtbGF5b3V0LWJlaGF2aW9yL2FwcC1sYXlvdXQtYmVoYXZpb3IuaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTUgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cblxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3BvbHltZXIvcG9seW1lci5odG1sXCI+XG5cbjxzY3JpcHQ+XG4gIChmdW5jdGlvbigpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICAvKipcbiAgICAgKiBDaHJvbWUgdXNlcyBhbiBvbGRlciB2ZXJzaW9uIG9mIERPTSBMZXZlbCAzIEtleWJvYXJkIEV2ZW50c1xuICAgICAqXG4gICAgICogTW9zdCBrZXlzIGFyZSBsYWJlbGVkIGFzIHRleHQsIGJ1dCBzb21lIGFyZSBVbmljb2RlIGNvZGVwb2ludHMuXG4gICAgICogVmFsdWVzIHRha2VuIGZyb206IGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMDcvV0QtRE9NLUxldmVsLTMtRXZlbnRzLTIwMDcxMjIxL2tleXNldC5odG1sI0tleVNldC1TZXRcbiAgICAgKi9cbiAgICB2YXIgS0VZX0lERU5USUZJRVIgPSB7XG4gICAgICAnVSswMDA4JzogJ2JhY2tzcGFjZScsXG4gICAgICAnVSswMDA5JzogJ3RhYicsXG4gICAgICAnVSswMDFCJzogJ2VzYycsXG4gICAgICAnVSswMDIwJzogJ3NwYWNlJyxcbiAgICAgICdVKzAwN0YnOiAnZGVsJ1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTcGVjaWFsIHRhYmxlIGZvciBLZXlib2FyZEV2ZW50LmtleUNvZGUuXG4gICAgICogS2V5Ym9hcmRFdmVudC5rZXlJZGVudGlmaWVyIGlzIGJldHRlciwgYW5kIEtleUJvYXJkRXZlbnQua2V5IGlzIGV2ZW4gYmV0dGVyXG4gICAgICogdGhhbiB0aGF0LlxuICAgICAqXG4gICAgICogVmFsdWVzIGZyb206IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9LZXlib2FyZEV2ZW50LmtleUNvZGUjVmFsdWVfb2Zfa2V5Q29kZVxuICAgICAqL1xuICAgIHZhciBLRVlfQ09ERSA9IHtcbiAgICAgIDg6ICdiYWNrc3BhY2UnLFxuICAgICAgOTogJ3RhYicsXG4gICAgICAxMzogJ2VudGVyJyxcbiAgICAgIDI3OiAnZXNjJyxcbiAgICAgIDMzOiAncGFnZXVwJyxcbiAgICAgIDM0OiAncGFnZWRvd24nLFxuICAgICAgMzU6ICdlbmQnLFxuICAgICAgMzY6ICdob21lJyxcbiAgICAgIDMyOiAnc3BhY2UnLFxuICAgICAgMzc6ICdsZWZ0JyxcbiAgICAgIDM4OiAndXAnLFxuICAgICAgMzk6ICdyaWdodCcsXG4gICAgICA0MDogJ2Rvd24nLFxuICAgICAgNDY6ICdkZWwnLFxuICAgICAgMTA2OiAnKidcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogTU9ESUZJRVJfS0VZUyBtYXBzIHRoZSBzaG9ydCBuYW1lIGZvciBtb2RpZmllciBrZXlzIHVzZWQgaW4gYSBrZXlcbiAgICAgKiBjb21ibyBzdHJpbmcgdG8gdGhlIHByb3BlcnR5IG5hbWUgdGhhdCByZWZlcmVuY2VzIHRob3NlIHNhbWUga2V5c1xuICAgICAqIGluIGEgS2V5Ym9hcmRFdmVudCBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICB2YXIgTU9ESUZJRVJfS0VZUyA9IHtcbiAgICAgICdzaGlmdCc6ICdzaGlmdEtleScsXG4gICAgICAnY3RybCc6ICdjdHJsS2V5JyxcbiAgICAgICdhbHQnOiAnYWx0S2V5JyxcbiAgICAgICdtZXRhJzogJ21ldGFLZXknXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEtleWJvYXJkRXZlbnQua2V5IGlzIG1vc3RseSByZXByZXNlbnRlZCBieSBwcmludGFibGUgY2hhcmFjdGVyIG1hZGUgYnlcbiAgICAgKiB0aGUga2V5Ym9hcmQsIHdpdGggdW5wcmludGFibGUga2V5cyBsYWJlbGVkIG5pY2VseS5cbiAgICAgKlxuICAgICAqIEhvd2V2ZXIsIG9uIE9TIFgsIEFsdCtjaGFyIGNhbiBtYWtlIGEgVW5pY29kZSBjaGFyYWN0ZXIgdGhhdCBmb2xsb3dzIGFuXG4gICAgICogQXBwbGUtc3BlY2lmaWMgbWFwcGluZy4gSW4gdGhpcyBjYXNlLCB3ZSBmYWxsIGJhY2sgdG8gLmtleUNvZGUuXG4gICAgICovXG4gICAgdmFyIEtFWV9DSEFSID0gL1thLXowLTkqXS87XG5cbiAgICAvKipcbiAgICAgKiBNYXRjaGVzIGEga2V5SWRlbnRpZmllciBzdHJpbmcuXG4gICAgICovXG4gICAgdmFyIElERU5UX0NIQVIgPSAvVVxcKy87XG5cbiAgICAvKipcbiAgICAgKiBNYXRjaGVzIGFycm93IGtleXMgaW4gR2Vja28gMjcuMCtcbiAgICAgKi9cbiAgICB2YXIgQVJST1dfS0VZID0gL15hcnJvdy87XG5cbiAgICAvKipcbiAgICAgKiBNYXRjaGVzIHNwYWNlIGtleXMgZXZlcnl3aGVyZSAobm90YWJseSBpbmNsdWRpbmcgSUUxMCdzIGV4Y2VwdGlvbmFsIG5hbWVcbiAgICAgKiBgc3BhY2ViYXJgKS5cbiAgICAgKi9cbiAgICB2YXIgU1BBQ0VfS0VZID0gL15zcGFjZShiYXIpPy87XG5cbiAgICAvKipcbiAgICAgKiBNYXRjaGVzIEVTQyBrZXkuXG4gICAgICpcbiAgICAgKiBWYWx1ZSBmcm9tOiBodHRwOi8vdzNjLmdpdGh1Yi5pby91aWV2ZW50cy1rZXkvI2tleS1Fc2NhcGVcbiAgICAgKi9cbiAgICB2YXIgRVNDX0tFWSA9IC9eZXNjYXBlJC87XG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm1zIHRoZSBrZXkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgS2V5Qm9hcmRFdmVudC5rZXlcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtub1NwZWNpYWxDaGFyc10gTGltaXRzIHRoZSB0cmFuc2Zvcm1hdGlvbiB0b1xuICAgICAqIGFscGhhLW51bWVyaWMgY2hhcmFjdGVycy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cmFuc2Zvcm1LZXkoa2V5LCBub1NwZWNpYWxDaGFycykge1xuICAgICAgdmFyIHZhbGlkS2V5ID0gJyc7XG4gICAgICBpZiAoa2V5KSB7XG4gICAgICAgIHZhciBsS2V5ID0ga2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChsS2V5ID09PSAnICcgfHwgU1BBQ0VfS0VZLnRlc3QobEtleSkpIHtcbiAgICAgICAgICB2YWxpZEtleSA9ICdzcGFjZSc7XG4gICAgICAgIH0gZWxzZSBpZiAoRVNDX0tFWS50ZXN0KGxLZXkpKSB7XG4gICAgICAgICAgdmFsaWRLZXkgPSAnZXNjJztcbiAgICAgICAgfSBlbHNlIGlmIChsS2V5Lmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgaWYgKCFub1NwZWNpYWxDaGFycyB8fCBLRVlfQ0hBUi50ZXN0KGxLZXkpKSB7XG4gICAgICAgICAgICB2YWxpZEtleSA9IGxLZXk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKEFSUk9XX0tFWS50ZXN0KGxLZXkpKSB7XG4gICAgICAgICAgdmFsaWRLZXkgPSBsS2V5LnJlcGxhY2UoJ2Fycm93JywgJycpO1xuICAgICAgICB9IGVsc2UgaWYgKGxLZXkgPT0gJ211bHRpcGx5Jykge1xuICAgICAgICAgIC8vIG51bXBhZCAnKicgY2FuIG1hcCB0byBNdWx0aXBseSBvbiBJRS9XaW5kb3dzXG4gICAgICAgICAgdmFsaWRLZXkgPSAnKic7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsaWRLZXkgPSBsS2V5O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsaWRLZXk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdHJhbnNmb3JtS2V5SWRlbnRpZmllcihrZXlJZGVudCkge1xuICAgICAgdmFyIHZhbGlkS2V5ID0gJyc7XG4gICAgICBpZiAoa2V5SWRlbnQpIHtcbiAgICAgICAgaWYgKGtleUlkZW50IGluIEtFWV9JREVOVElGSUVSKSB7XG4gICAgICAgICAgdmFsaWRLZXkgPSBLRVlfSURFTlRJRklFUltrZXlJZGVudF07XG4gICAgICAgIH0gZWxzZSBpZiAoSURFTlRfQ0hBUi50ZXN0KGtleUlkZW50KSkge1xuICAgICAgICAgIGtleUlkZW50ID0gcGFyc2VJbnQoa2V5SWRlbnQucmVwbGFjZSgnVSsnLCAnMHgnKSwgMTYpO1xuICAgICAgICAgIHZhbGlkS2V5ID0gU3RyaW5nLmZyb21DaGFyQ29kZShrZXlJZGVudCkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWxpZEtleSA9IGtleUlkZW50LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWxpZEtleTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0cmFuc2Zvcm1LZXlDb2RlKGtleUNvZGUpIHtcbiAgICAgIHZhciB2YWxpZEtleSA9ICcnO1xuICAgICAgaWYgKE51bWJlcihrZXlDb2RlKSkge1xuICAgICAgICBpZiAoa2V5Q29kZSA+PSA2NSAmJiBrZXlDb2RlIDw9IDkwKSB7XG4gICAgICAgICAgLy8gYXNjaWkgYS16XG4gICAgICAgICAgLy8gbG93ZXJjYXNlIGlzIDMyIG9mZnNldCBmcm9tIHVwcGVyY2FzZVxuICAgICAgICAgIHZhbGlkS2V5ID0gU3RyaW5nLmZyb21DaGFyQ29kZSgzMiArIGtleUNvZGUpO1xuICAgICAgICB9IGVsc2UgaWYgKGtleUNvZGUgPj0gMTEyICYmIGtleUNvZGUgPD0gMTIzKSB7XG4gICAgICAgICAgLy8gZnVuY3Rpb24ga2V5cyBmMS1mMTJcbiAgICAgICAgICB2YWxpZEtleSA9ICdmJyArIChrZXlDb2RlIC0gMTEyICsgMSk7XG4gICAgICAgIH0gZWxzZSBpZiAoa2V5Q29kZSA+PSA0OCAmJiBrZXlDb2RlIDw9IDU3KSB7XG4gICAgICAgICAgLy8gdG9wIDAtOSBrZXlzXG4gICAgICAgICAgdmFsaWRLZXkgPSBTdHJpbmcoa2V5Q29kZSAtIDQ4KTtcbiAgICAgICAgfSBlbHNlIGlmIChrZXlDb2RlID49IDk2ICYmIGtleUNvZGUgPD0gMTA1KSB7XG4gICAgICAgICAgLy8gbnVtIHBhZCAwLTlcbiAgICAgICAgICB2YWxpZEtleSA9IFN0cmluZyhrZXlDb2RlIC0gOTYpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbGlkS2V5ID0gS0VZX0NPREVba2V5Q29kZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWxpZEtleTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgICogQ2FsY3VsYXRlcyB0aGUgbm9ybWFsaXplZCBrZXkgZm9yIGEgS2V5Ym9hcmRFdmVudC5cbiAgICAgICogQHBhcmFtIHtLZXlib2FyZEV2ZW50fSBrZXlFdmVudFxuICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtub1NwZWNpYWxDaGFyc10gU2V0IHRvIHRydWUgdG8gbGltaXQga2V5RXZlbnQua2V5XG4gICAgICAqIHRyYW5zZm9ybWF0aW9uIHRvIGFscGhhLW51bWVyaWMgY2hhcnMuIFRoaXMgaXMgdXNlZnVsIHdpdGgga2V5XG4gICAgICAqIGNvbWJpbmF0aW9ucyBsaWtlIHNoaWZ0ICsgMiwgd2hpY2ggb24gRkYgZm9yIE1hY09TIHByb2R1Y2VzXG4gICAgICAqIGtleUV2ZW50LmtleSA9IEBcbiAgICAgICogVG8gZ2V0IDIgcmV0dXJuZWQsIHNldCBub1NwZWNpYWxDaGFycyA9IHRydWVcbiAgICAgICogVG8gZ2V0IEAgcmV0dXJuZWQsIHNldCBub1NwZWNpYWxDaGFycyA9IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplZEtleUZvckV2ZW50KGtleUV2ZW50LCBub1NwZWNpYWxDaGFycykge1xuICAgICAgLy8gRmFsbCBiYWNrIGZyb20gLmtleSwgdG8gLmRldGFpbC5rZXkgZm9yIGFydGlmaWNhbCBrZXlib2FyZCBldmVudHMsXG4gICAgICAvLyBhbmQgdGhlbiB0byBkZXByZWNhdGVkIC5rZXlJZGVudGlmaWVyIGFuZCAua2V5Q29kZS5cbiAgICAgIGlmIChrZXlFdmVudC5rZXkpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybUtleShrZXlFdmVudC5rZXksIG5vU3BlY2lhbENoYXJzKTtcbiAgICAgIH1cbiAgICAgIGlmIChrZXlFdmVudC5kZXRhaWwgJiYga2V5RXZlbnQuZGV0YWlsLmtleSkge1xuICAgICAgICByZXR1cm4gdHJhbnNmb3JtS2V5KGtleUV2ZW50LmRldGFpbC5rZXksIG5vU3BlY2lhbENoYXJzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cmFuc2Zvcm1LZXlJZGVudGlmaWVyKGtleUV2ZW50LmtleUlkZW50aWZpZXIpIHx8XG4gICAgICAgIHRyYW5zZm9ybUtleUNvZGUoa2V5RXZlbnQua2V5Q29kZSkgfHwgJyc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24ga2V5Q29tYm9NYXRjaGVzRXZlbnQoa2V5Q29tYm8sIGV2ZW50KSB7XG4gICAgICAvLyBGb3IgY29tYm9zIHdpdGggbW9kaWZpZXJzIHdlIHN1cHBvcnQgb25seSBhbHBoYS1udW1lcmljIGtleXNcbiAgICAgIHZhciBrZXlFdmVudCA9IG5vcm1hbGl6ZWRLZXlGb3JFdmVudChldmVudCwga2V5Q29tYm8uaGFzTW9kaWZpZXJzKTtcbiAgICAgIHJldHVybiBrZXlFdmVudCA9PT0ga2V5Q29tYm8ua2V5ICYmXG4gICAgICAgICgha2V5Q29tYm8uaGFzTW9kaWZpZXJzIHx8IChcbiAgICAgICAgICAhIWV2ZW50LnNoaWZ0S2V5ID09PSAhIWtleUNvbWJvLnNoaWZ0S2V5ICYmXG4gICAgICAgICAgISFldmVudC5jdHJsS2V5ID09PSAhIWtleUNvbWJvLmN0cmxLZXkgJiZcbiAgICAgICAgICAhIWV2ZW50LmFsdEtleSA9PT0gISFrZXlDb21iby5hbHRLZXkgJiZcbiAgICAgICAgICAhIWV2ZW50Lm1ldGFLZXkgPT09ICEha2V5Q29tYm8ubWV0YUtleSlcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUtleUNvbWJvU3RyaW5nKGtleUNvbWJvU3RyaW5nKSB7XG4gICAgICBpZiAoa2V5Q29tYm9TdHJpbmcubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY29tYm86IGtleUNvbWJvU3RyaW5nLFxuICAgICAgICAgIGtleToga2V5Q29tYm9TdHJpbmcsXG4gICAgICAgICAgZXZlbnQ6ICdrZXlkb3duJ1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGtleUNvbWJvU3RyaW5nLnNwbGl0KCcrJykucmVkdWNlKGZ1bmN0aW9uKHBhcnNlZEtleUNvbWJvLCBrZXlDb21ib1BhcnQpIHtcbiAgICAgICAgdmFyIGV2ZW50UGFydHMgPSBrZXlDb21ib1BhcnQuc3BsaXQoJzonKTtcbiAgICAgICAgdmFyIGtleU5hbWUgPSBldmVudFBhcnRzWzBdO1xuICAgICAgICB2YXIgZXZlbnQgPSBldmVudFBhcnRzWzFdO1xuXG4gICAgICAgIGlmIChrZXlOYW1lIGluIE1PRElGSUVSX0tFWVMpIHtcbiAgICAgICAgICBwYXJzZWRLZXlDb21ib1tNT0RJRklFUl9LRVlTW2tleU5hbWVdXSA9IHRydWU7XG4gICAgICAgICAgcGFyc2VkS2V5Q29tYm8uaGFzTW9kaWZpZXJzID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXJzZWRLZXlDb21iby5rZXkgPSBrZXlOYW1lO1xuICAgICAgICAgIHBhcnNlZEtleUNvbWJvLmV2ZW50ID0gZXZlbnQgfHwgJ2tleWRvd24nO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhcnNlZEtleUNvbWJvO1xuICAgICAgfSwge1xuICAgICAgICBjb21ibzoga2V5Q29tYm9TdHJpbmcuc3BsaXQoJzonKS5zaGlmdCgpXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUV2ZW50U3RyaW5nKGV2ZW50U3RyaW5nKSB7XG4gICAgICByZXR1cm4gZXZlbnRTdHJpbmcudHJpbSgpLnNwbGl0KCcgJykubWFwKGZ1bmN0aW9uKGtleUNvbWJvU3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUtleUNvbWJvU3RyaW5nKGtleUNvbWJvU3RyaW5nKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGBQb2x5bWVyLklyb25BMTF5S2V5c0JlaGF2aW9yYCBwcm92aWRlcyBhIG5vcm1hbGl6ZWQgaW50ZXJmYWNlIGZvciBwcm9jZXNzaW5nXG4gICAgICoga2V5Ym9hcmQgY29tbWFuZHMgdGhhdCBwZXJ0YWluIHRvIFtXQUktQVJJQSBiZXN0IHByYWN0aWNlc10oaHR0cDovL3d3dy53My5vcmcvVFIvd2FpLWFyaWEtcHJhY3RpY2VzLyNrYmRfZ2VuZXJhbF9iaW5kaW5nKS5cbiAgICAgKiBUaGUgZWxlbWVudCB0YWtlcyBjYXJlIG9mIGJyb3dzZXIgZGlmZmVyZW5jZXMgd2l0aCByZXNwZWN0IHRvIEtleWJvYXJkIGV2ZW50c1xuICAgICAqIGFuZCB1c2VzIGFuIGV4cHJlc3NpdmUgc3ludGF4IHRvIGZpbHRlciBrZXkgcHJlc3Nlcy5cbiAgICAgKlxuICAgICAqIFVzZSB0aGUgYGtleUJpbmRpbmdzYCBwcm90b3R5cGUgcHJvcGVydHkgdG8gZXhwcmVzcyB3aGF0IGNvbWJpbmF0aW9uIG9mIGtleXNcbiAgICAgKiB3aWxsIHRyaWdnZXIgdGhlIGNhbGxiYWNrLiBBIGtleSBiaW5kaW5nIGhhcyB0aGUgZm9ybWF0XG4gICAgICogYFwiS0VZK01PRElGSUVSOkVWRU5UXCI6IFwiY2FsbGJhY2tcImAgKGBcIktFWVwiOiBcImNhbGxiYWNrXCJgIG9yXG4gICAgICogYFwiS0VZOkVWRU5UXCI6IFwiY2FsbGJhY2tcImAgYXJlIHZhbGlkIGFzIHdlbGwpLiBTb21lIGV4YW1wbGVzOlxuICAgICAqXG4gICAgICogICAgICBrZXlCaW5kaW5nczoge1xuICAgICAqICAgICAgICAnc3BhY2UnOiAnX29uS2V5ZG93bicsIC8vIHNhbWUgYXMgJ3NwYWNlOmtleWRvd24nXG4gICAgICogICAgICAgICdzaGlmdCt0YWInOiAnX29uS2V5ZG93bicsXG4gICAgICogICAgICAgICdlbnRlcjprZXlwcmVzcyc6ICdfb25LZXlwcmVzcycsXG4gICAgICogICAgICAgICdlc2M6a2V5dXAnOiAnX29uS2V5dXAnXG4gICAgICogICAgICB9XG4gICAgICpcbiAgICAgKiBUaGUgY2FsbGJhY2sgd2lsbCByZWNlaXZlIHdpdGggYW4gZXZlbnQgY29udGFpbmluZyB0aGUgZm9sbG93aW5nIGluZm9ybWF0aW9uIGluIGBldmVudC5kZXRhaWxgOlxuICAgICAqXG4gICAgICogICAgICBfb25LZXlkb3duOiBmdW5jdGlvbihldmVudCkge1xuICAgICAqICAgICAgICBjb25zb2xlLmxvZyhldmVudC5kZXRhaWwuY29tYm8pOyAvLyBLRVkrTU9ESUZJRVIsIGUuZy4gXCJzaGlmdCt0YWJcIlxuICAgICAqICAgICAgICBjb25zb2xlLmxvZyhldmVudC5kZXRhaWwua2V5KTsgLy8gS0VZIG9ubHksIGUuZy4gXCJ0YWJcIlxuICAgICAqICAgICAgICBjb25zb2xlLmxvZyhldmVudC5kZXRhaWwuZXZlbnQpOyAvLyBFVkVOVCwgZS5nLiBcImtleWRvd25cIlxuICAgICAqICAgICAgICBjb25zb2xlLmxvZyhldmVudC5kZXRhaWwua2V5Ym9hcmRFdmVudCk7IC8vIHRoZSBvcmlnaW5hbCBLZXlib2FyZEV2ZW50XG4gICAgICogICAgICB9XG4gICAgICpcbiAgICAgKiBVc2UgdGhlIGBrZXlFdmVudFRhcmdldGAgYXR0cmlidXRlIHRvIHNldCB1cCBldmVudCBoYW5kbGVycyBvbiBhIHNwZWNpZmljXG4gICAgICogbm9kZS5cbiAgICAgKlxuICAgICAqIFNlZSB0aGUgW2RlbW8gc291cmNlIGNvZGVdKGh0dHBzOi8vZ2l0aHViLmNvbS9Qb2x5bWVyRWxlbWVudHMvaXJvbi1hMTF5LWtleXMtYmVoYXZpb3IvYmxvYi9tYXN0ZXIvZGVtby94LWtleS1hd2FyZS5odG1sKVxuICAgICAqIGZvciBhbiBleGFtcGxlLlxuICAgICAqXG4gICAgICogQGRlbW8gZGVtby9pbmRleC5odG1sXG4gICAgICogQHBvbHltZXJCZWhhdmlvclxuICAgICAqL1xuICAgIFBvbHltZXIuSXJvbkExMXlLZXlzQmVoYXZpb3IgPSB7XG4gICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgRXZlbnRUYXJnZXQgdGhhdCB3aWxsIGJlIGZpcmluZyByZWxldmFudCBLZXlib2FyZEV2ZW50cy4gU2V0IGl0IHRvXG4gICAgICAgICAqIGBudWxsYCB0byBkaXNhYmxlIHRoZSBsaXN0ZW5lcnMuXG4gICAgICAgICAqIEB0eXBlIHs/RXZlbnRUYXJnZXR9XG4gICAgICAgICAqL1xuICAgICAgICBrZXlFdmVudFRhcmdldDoge1xuICAgICAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHRydWUsIHRoaXMgcHJvcGVydHkgd2lsbCBjYXVzZSB0aGUgaW1wbGVtZW50aW5nIGVsZW1lbnQgdG9cbiAgICAgICAgICogYXV0b21hdGljYWxseSBzdG9wIHByb3BhZ2F0aW9uIG9uIGFueSBoYW5kbGVkIEtleWJvYXJkRXZlbnRzLlxuICAgICAgICAgKi9cbiAgICAgICAgc3RvcEtleWJvYXJkRXZlbnRQcm9wYWdhdGlvbjoge1xuICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgIH0sXG5cbiAgICAgICAgX2JvdW5kS2V5SGFuZGxlcnM6IHtcbiAgICAgICAgICB0eXBlOiBBcnJheSxcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIFdlIHVzZSB0aGlzIGR1ZSB0byBhIGxpbWl0YXRpb24gaW4gSUUxMCB3aGVyZSBpbnN0YW5jZXMgd2lsbCBoYXZlXG4gICAgICAgIC8vIG93biBwcm9wZXJ0aWVzIG9mIGV2ZXJ5dGhpbmcgb24gdGhlIFwicHJvdG90eXBlXCIuXG4gICAgICAgIF9pbXBlcmF0aXZlS2V5QmluZGluZ3M6IHtcbiAgICAgICAgICB0eXBlOiBPYmplY3QsXG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgb2JzZXJ2ZXJzOiBbXG4gICAgICAgICdfcmVzZXRLZXlFdmVudExpc3RlbmVycyhrZXlFdmVudFRhcmdldCwgX2JvdW5kS2V5SGFuZGxlcnMpJ1xuICAgICAgXSxcblxuXG4gICAgICAvKipcbiAgICAgICAqIFRvIGJlIHVzZWQgdG8gZXhwcmVzcyB3aGF0IGNvbWJpbmF0aW9uIG9mIGtleXMgIHdpbGwgdHJpZ2dlciB0aGUgcmVsYXRpdmVcbiAgICAgICAqIGNhbGxiYWNrLiBlLmcuIGBrZXlCaW5kaW5nczogeyAnZXNjJzogJ19vbkVzY1ByZXNzZWQnfWBcbiAgICAgICAqIEB0eXBlIHshT2JqZWN0fVxuICAgICAgICovXG4gICAgICBrZXlCaW5kaW5nczoge30sXG5cbiAgICAgIHJlZ2lzdGVyZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9wcmVwS2V5QmluZGluZ3MoKTtcbiAgICAgIH0sXG5cbiAgICAgIGF0dGFjaGVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fbGlzdGVuS2V5RXZlbnRMaXN0ZW5lcnMoKTtcbiAgICAgIH0sXG5cbiAgICAgIGRldGFjaGVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fdW5saXN0ZW5LZXlFdmVudExpc3RlbmVycygpO1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBDYW4gYmUgdXNlZCB0byBpbXBlcmF0aXZlbHkgYWRkIGEga2V5IGJpbmRpbmcgdG8gdGhlIGltcGxlbWVudGluZ1xuICAgICAgICogZWxlbWVudC4gVGhpcyBpcyB0aGUgaW1wZXJhdGl2ZSBlcXVpdmFsZW50IG9mIGRlY2xhcmluZyBhIGtleWJpbmRpbmdcbiAgICAgICAqIGluIHRoZSBga2V5QmluZGluZ3NgIHByb3RvdHlwZSBwcm9wZXJ0eS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRTdHJpbmdcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBoYW5kbGVyTmFtZVxuICAgICAgICovXG4gICAgICBhZGRPd25LZXlCaW5kaW5nOiBmdW5jdGlvbihldmVudFN0cmluZywgaGFuZGxlck5hbWUpIHtcbiAgICAgICAgdGhpcy5faW1wZXJhdGl2ZUtleUJpbmRpbmdzW2V2ZW50U3RyaW5nXSA9IGhhbmRsZXJOYW1lO1xuICAgICAgICB0aGlzLl9wcmVwS2V5QmluZGluZ3MoKTtcbiAgICAgICAgdGhpcy5fcmVzZXRLZXlFdmVudExpc3RlbmVycygpO1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBXaGVuIGNhbGxlZCwgd2lsbCByZW1vdmUgYWxsIGltcGVyYXRpdmVseS1hZGRlZCBrZXkgYmluZGluZ3MuXG4gICAgICAgKi9cbiAgICAgIHJlbW92ZU93bktleUJpbmRpbmdzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5faW1wZXJhdGl2ZUtleUJpbmRpbmdzID0ge307XG4gICAgICAgIHRoaXMuX3ByZXBLZXlCaW5kaW5ncygpO1xuICAgICAgICB0aGlzLl9yZXNldEtleUV2ZW50TGlzdGVuZXJzKCk7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFJldHVybnMgdHJ1ZSBpZiBhIGtleWJvYXJkIGV2ZW50IG1hdGNoZXMgYGV2ZW50U3RyaW5nYC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge0tleWJvYXJkRXZlbnR9IGV2ZW50XG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRTdHJpbmdcbiAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICAgKi9cbiAgICAgIGtleWJvYXJkRXZlbnRNYXRjaGVzS2V5czogZnVuY3Rpb24oZXZlbnQsIGV2ZW50U3RyaW5nKSB7XG4gICAgICAgIHZhciBrZXlDb21ib3MgPSBwYXJzZUV2ZW50U3RyaW5nKGV2ZW50U3RyaW5nKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlDb21ib3MubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBpZiAoa2V5Q29tYm9NYXRjaGVzRXZlbnQoa2V5Q29tYm9zW2ldLCBldmVudCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9LFxuXG4gICAgICBfY29sbGVjdEtleUJpbmRpbmdzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGtleUJpbmRpbmdzID0gdGhpcy5iZWhhdmlvcnMubWFwKGZ1bmN0aW9uKGJlaGF2aW9yKSB7XG4gICAgICAgICAgcmV0dXJuIGJlaGF2aW9yLmtleUJpbmRpbmdzO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoa2V5QmluZGluZ3MuaW5kZXhPZih0aGlzLmtleUJpbmRpbmdzKSA9PT0gLTEpIHtcbiAgICAgICAgICBrZXlCaW5kaW5ncy5wdXNoKHRoaXMua2V5QmluZGluZ3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGtleUJpbmRpbmdzO1xuICAgICAgfSxcblxuICAgICAgX3ByZXBLZXlCaW5kaW5nczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX2tleUJpbmRpbmdzID0ge307XG5cbiAgICAgICAgdGhpcy5fY29sbGVjdEtleUJpbmRpbmdzKCkuZm9yRWFjaChmdW5jdGlvbihrZXlCaW5kaW5ncykge1xuICAgICAgICAgIGZvciAodmFyIGV2ZW50U3RyaW5nIGluIGtleUJpbmRpbmdzKSB7XG4gICAgICAgICAgICB0aGlzLl9hZGRLZXlCaW5kaW5nKGV2ZW50U3RyaW5nLCBrZXlCaW5kaW5nc1tldmVudFN0cmluZ10pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgZm9yICh2YXIgZXZlbnRTdHJpbmcgaW4gdGhpcy5faW1wZXJhdGl2ZUtleUJpbmRpbmdzKSB7XG4gICAgICAgICAgdGhpcy5fYWRkS2V5QmluZGluZyhldmVudFN0cmluZywgdGhpcy5faW1wZXJhdGl2ZUtleUJpbmRpbmdzW2V2ZW50U3RyaW5nXSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBHaXZlIHByZWNlZGVuY2UgdG8gY29tYm9zIHdpdGggbW9kaWZpZXJzIHRvIGJlIGNoZWNrZWQgZmlyc3QuXG4gICAgICAgIGZvciAodmFyIGV2ZW50TmFtZSBpbiB0aGlzLl9rZXlCaW5kaW5ncykge1xuICAgICAgICAgIHRoaXMuX2tleUJpbmRpbmdzW2V2ZW50TmFtZV0uc29ydChmdW5jdGlvbiAoa2IxLCBrYjIpIHtcbiAgICAgICAgICAgIHZhciBiMSA9IGtiMVswXS5oYXNNb2RpZmllcnM7XG4gICAgICAgICAgICB2YXIgYjIgPSBrYjJbMF0uaGFzTW9kaWZpZXJzO1xuICAgICAgICAgICAgcmV0dXJuIChiMSA9PT0gYjIpID8gMCA6IGIxID8gLTEgOiAxO1xuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIF9hZGRLZXlCaW5kaW5nOiBmdW5jdGlvbihldmVudFN0cmluZywgaGFuZGxlck5hbWUpIHtcbiAgICAgICAgcGFyc2VFdmVudFN0cmluZyhldmVudFN0cmluZykuZm9yRWFjaChmdW5jdGlvbihrZXlDb21ibykge1xuICAgICAgICAgIHRoaXMuX2tleUJpbmRpbmdzW2tleUNvbWJvLmV2ZW50XSA9XG4gICAgICAgICAgICB0aGlzLl9rZXlCaW5kaW5nc1trZXlDb21iby5ldmVudF0gfHwgW107XG5cbiAgICAgICAgICB0aGlzLl9rZXlCaW5kaW5nc1trZXlDb21iby5ldmVudF0ucHVzaChbXG4gICAgICAgICAgICBrZXlDb21ibyxcbiAgICAgICAgICAgIGhhbmRsZXJOYW1lXG4gICAgICAgICAgXSk7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgfSxcblxuICAgICAgX3Jlc2V0S2V5RXZlbnRMaXN0ZW5lcnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl91bmxpc3RlbktleUV2ZW50TGlzdGVuZXJzKCk7XG5cbiAgICAgICAgaWYgKHRoaXMuaXNBdHRhY2hlZCkge1xuICAgICAgICAgIHRoaXMuX2xpc3RlbktleUV2ZW50TGlzdGVuZXJzKCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIF9saXN0ZW5LZXlFdmVudExpc3RlbmVyczogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5rZXlFdmVudFRhcmdldCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3Qua2V5cyh0aGlzLl9rZXlCaW5kaW5ncykuZm9yRWFjaChmdW5jdGlvbihldmVudE5hbWUpIHtcbiAgICAgICAgICB2YXIga2V5QmluZGluZ3MgPSB0aGlzLl9rZXlCaW5kaW5nc1tldmVudE5hbWVdO1xuICAgICAgICAgIHZhciBib3VuZEtleUhhbmRsZXIgPSB0aGlzLl9vbktleUJpbmRpbmdFdmVudC5iaW5kKHRoaXMsIGtleUJpbmRpbmdzKTtcblxuICAgICAgICAgIHRoaXMuX2JvdW5kS2V5SGFuZGxlcnMucHVzaChbdGhpcy5rZXlFdmVudFRhcmdldCwgZXZlbnROYW1lLCBib3VuZEtleUhhbmRsZXJdKTtcblxuICAgICAgICAgIHRoaXMua2V5RXZlbnRUYXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGJvdW5kS2V5SGFuZGxlcik7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgfSxcblxuICAgICAgX3VubGlzdGVuS2V5RXZlbnRMaXN0ZW5lcnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIga2V5SGFuZGxlclR1cGxlO1xuICAgICAgICB2YXIga2V5RXZlbnRUYXJnZXQ7XG4gICAgICAgIHZhciBldmVudE5hbWU7XG4gICAgICAgIHZhciBib3VuZEtleUhhbmRsZXI7XG5cbiAgICAgICAgd2hpbGUgKHRoaXMuX2JvdW5kS2V5SGFuZGxlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgLy8gTXkga2luZ2RvbSBmb3IgYmxvY2stc2NvcGUgYmluZGluZyBhbmQgZGVzdHJ1Y3R1cmluZyBhc3NpZ25tZW50Li5cbiAgICAgICAgICBrZXlIYW5kbGVyVHVwbGUgPSB0aGlzLl9ib3VuZEtleUhhbmRsZXJzLnBvcCgpO1xuICAgICAgICAgIGtleUV2ZW50VGFyZ2V0ID0ga2V5SGFuZGxlclR1cGxlWzBdO1xuICAgICAgICAgIGV2ZW50TmFtZSA9IGtleUhhbmRsZXJUdXBsZVsxXTtcbiAgICAgICAgICBib3VuZEtleUhhbmRsZXIgPSBrZXlIYW5kbGVyVHVwbGVbMl07XG5cbiAgICAgICAgICBrZXlFdmVudFRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgYm91bmRLZXlIYW5kbGVyKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgX29uS2V5QmluZGluZ0V2ZW50OiBmdW5jdGlvbihrZXlCaW5kaW5ncywgZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RvcEtleWJvYXJkRXZlbnRQcm9wYWdhdGlvbikge1xuICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgZXZlbnQgaGFzIGJlZW4gYWxyZWFkeSBwcmV2ZW50ZWQsIGRvbid0IGRvIGFueXRoaW5nXG4gICAgICAgIGlmIChldmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlCaW5kaW5ncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBrZXlDb21ibyA9IGtleUJpbmRpbmdzW2ldWzBdO1xuICAgICAgICAgIHZhciBoYW5kbGVyTmFtZSA9IGtleUJpbmRpbmdzW2ldWzFdO1xuICAgICAgICAgIGlmIChrZXlDb21ib01hdGNoZXNFdmVudChrZXlDb21ibywgZXZlbnQpKSB7XG4gICAgICAgICAgICB0aGlzLl90cmlnZ2VyS2V5SGFuZGxlcihrZXlDb21ibywgaGFuZGxlck5hbWUsIGV2ZW50KTtcbiAgICAgICAgICAgIC8vIGV4aXQgdGhlIGxvb3AgaWYgZXZlbnREZWZhdWx0IHdhcyBwcmV2ZW50ZWRcbiAgICAgICAgICAgIGlmIChldmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIF90cmlnZ2VyS2V5SGFuZGxlcjogZnVuY3Rpb24oa2V5Q29tYm8sIGhhbmRsZXJOYW1lLCBrZXlib2FyZEV2ZW50KSB7XG4gICAgICAgIHZhciBkZXRhaWwgPSBPYmplY3QuY3JlYXRlKGtleUNvbWJvKTtcbiAgICAgICAgZGV0YWlsLmtleWJvYXJkRXZlbnQgPSBrZXlib2FyZEV2ZW50O1xuICAgICAgICB2YXIgZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoa2V5Q29tYm8uZXZlbnQsIHtcbiAgICAgICAgICBkZXRhaWw6IGRldGFpbCxcbiAgICAgICAgICBjYW5jZWxhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzW2hhbmRsZXJOYW1lXS5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICAgICAgaWYgKGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgICBrZXlib2FyZEV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9KSgpO1xuPC9zY3JpcHQ+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL2lyb24tYTExeS1rZXlzLWJlaGF2aW9yL2lyb24tYTExeS1rZXlzLWJlaGF2aW9yLmh0bWwiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE1IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi9wb2x5bWVyL3BvbHltZXIuaHRtbFwiPlxuXG48c2NyaXB0PlxuICAvKipcbiAgICogYElyb25SZXNpemFibGVCZWhhdmlvcmAgaXMgYSBiZWhhdmlvciB0aGF0IGNhbiBiZSB1c2VkIGluIFBvbHltZXIgZWxlbWVudHMgdG9cbiAgICogY29vcmRpbmF0ZSB0aGUgZmxvdyBvZiByZXNpemUgZXZlbnRzIGJldHdlZW4gXCJyZXNpemVyc1wiIChlbGVtZW50cyB0aGF0IGNvbnRyb2wgdGhlXG4gICAqIHNpemUgb3IgaGlkZGVuIHN0YXRlIG9mIHRoZWlyIGNoaWxkcmVuKSBhbmQgXCJyZXNpemFibGVzXCIgKGVsZW1lbnRzIHRoYXQgbmVlZCB0byBiZVxuICAgKiBub3RpZmllZCB3aGVuIHRoZXkgYXJlIHJlc2l6ZWQgb3IgdW4taGlkZGVuIGJ5IHRoZWlyIHBhcmVudHMgaW4gb3JkZXIgdG8gdGFrZVxuICAgKiBhY3Rpb24gb24gdGhlaXIgbmV3IG1lYXN1cmVtZW50cykuXG4gICAqXG4gICAqIEVsZW1lbnRzIHRoYXQgcGVyZm9ybSBtZWFzdXJlbWVudCBzaG91bGQgYWRkIHRoZSBgSXJvblJlc2l6YWJsZUJlaGF2aW9yYCBiZWhhdmlvciB0b1xuICAgKiB0aGVpciBlbGVtZW50IGRlZmluaXRpb24gYW5kIGxpc3RlbiBmb3IgdGhlIGBpcm9uLXJlc2l6ZWAgZXZlbnQgb24gdGhlbXNlbHZlcy5cbiAgICogVGhpcyBldmVudCB3aWxsIGJlIGZpcmVkIHdoZW4gdGhleSBiZWNvbWUgc2hvd2luZyBhZnRlciBoYXZpbmcgYmVlbiBoaWRkZW4sXG4gICAqIHdoZW4gdGhleSBhcmUgcmVzaXplZCBleHBsaWNpdGx5IGJ5IGFub3RoZXIgcmVzaXphYmxlLCBvciB3aGVuIHRoZSB3aW5kb3cgaGFzIGJlZW5cbiAgICogcmVzaXplZC5cbiAgICpcbiAgICogTm90ZSwgdGhlIGBpcm9uLXJlc2l6ZWAgZXZlbnQgaXMgbm9uLWJ1YmJsaW5nLlxuICAgKlxuICAgKiBAcG9seW1lckJlaGF2aW9yIFBvbHltZXIuSXJvblJlc2l6YWJsZUJlaGF2aW9yXG4gICAqIEBkZW1vIGRlbW8vaW5kZXguaHRtbFxuICAgKiovXG4gIFBvbHltZXIuSXJvblJlc2l6YWJsZUJlaGF2aW9yID0ge1xuICAgIHByb3BlcnRpZXM6IHtcbiAgICAgIC8qKlxuICAgICAgICogVGhlIGNsb3Nlc3QgYW5jZXN0b3IgZWxlbWVudCB0aGF0IGltcGxlbWVudHMgYElyb25SZXNpemFibGVCZWhhdmlvcmAuXG4gICAgICAgKi9cbiAgICAgIF9wYXJlbnRSZXNpemFibGU6IHtcbiAgICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgICBvYnNlcnZlcjogJ19wYXJlbnRSZXNpemFibGVDaGFuZ2VkJ1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBUcnVlIGlmIHRoaXMgZWxlbWVudCBpcyBjdXJyZW50bHkgbm90aWZ5aW5nIGl0cyBkZXNjZW5kYW50IGVsZW1lbnRzIG9mXG4gICAgICAgKiByZXNpemUuXG4gICAgICAgKi9cbiAgICAgIF9ub3RpZnlpbmdEZXNjZW5kYW50OiB7XG4gICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBsaXN0ZW5lcnM6IHtcbiAgICAgICdpcm9uLXJlcXVlc3QtcmVzaXplLW5vdGlmaWNhdGlvbnMnOiAnX29uSXJvblJlcXVlc3RSZXNpemVOb3RpZmljYXRpb25zJ1xuICAgIH0sXG5cbiAgICBjcmVhdGVkOiBmdW5jdGlvbigpIHtcbiAgICAgIC8vIFdlIGRvbid0IHJlYWxseSBuZWVkIHByb3BlcnR5IGVmZmVjdHMgb24gdGhlc2UsIGFuZCBhbHNvIHdlIHdhbnQgdGhlbVxuICAgICAgLy8gdG8gYmUgY3JlYXRlZCBiZWZvcmUgdGhlIGBfcGFyZW50UmVzaXphYmxlYCBvYnNlcnZlciBmaXJlczpcbiAgICAgIHRoaXMuX2ludGVyZXN0ZWRSZXNpemFibGVzID0gW107XG4gICAgICB0aGlzLl9ib3VuZE5vdGlmeVJlc2l6ZSA9IHRoaXMubm90aWZ5UmVzaXplLmJpbmQodGhpcyk7XG4gICAgfSxcblxuICAgIGF0dGFjaGVkOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX3JlcXVlc3RSZXNpemVOb3RpZmljYXRpb25zKCk7XG4gICAgfSxcblxuICAgIGRldGFjaGVkOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLl9wYXJlbnRSZXNpemFibGUpIHtcbiAgICAgICAgdGhpcy5fcGFyZW50UmVzaXphYmxlLnN0b3BSZXNpemVOb3RpZmljYXRpb25zRm9yKHRoaXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuX2JvdW5kTm90aWZ5UmVzaXplKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fcGFyZW50UmVzaXphYmxlID0gbnVsbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FuIGJlIGNhbGxlZCB0byBtYW51YWxseSBub3RpZnkgYSByZXNpemFibGUgYW5kIGl0cyBkZXNjZW5kYW50XG4gICAgICogcmVzaXphYmxlcyBvZiBhIHJlc2l6ZSBjaGFuZ2UuXG4gICAgICovXG4gICAgbm90aWZ5UmVzaXplOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5pc0F0dGFjaGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5faW50ZXJlc3RlZFJlc2l6YWJsZXMuZm9yRWFjaChmdW5jdGlvbihyZXNpemFibGUpIHtcbiAgICAgICAgaWYgKHRoaXMucmVzaXplclNob3VsZE5vdGlmeShyZXNpemFibGUpKSB7XG4gICAgICAgICAgdGhpcy5fbm90aWZ5RGVzY2VuZGFudChyZXNpemFibGUpO1xuICAgICAgICB9XG4gICAgICB9LCB0aGlzKTtcblxuICAgICAgdGhpcy5fZmlyZVJlc2l6ZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIGFzc2lnbiB0aGUgY2xvc2VzdCByZXNpemFibGUgYW5jZXN0b3IgdG8gdGhpcyByZXNpemFibGVcbiAgICAgKiBpZiB0aGUgYW5jZXN0b3IgZGV0ZWN0cyBhIHJlcXVlc3QgZm9yIG5vdGlmaWNhdGlvbnMuXG4gICAgICovXG4gICAgYXNzaWduUGFyZW50UmVzaXphYmxlOiBmdW5jdGlvbihwYXJlbnRSZXNpemFibGUpIHtcbiAgICAgIHRoaXMuX3BhcmVudFJlc2l6YWJsZSA9IHBhcmVudFJlc2l6YWJsZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVXNlZCB0byByZW1vdmUgYSByZXNpemFibGUgZGVzY2VuZGFudCBmcm9tIHRoZSBsaXN0IG9mIGRlc2NlbmRhbnRzXG4gICAgICogdGhhdCBzaG91bGQgYmUgbm90aWZpZWQgb2YgYSByZXNpemUgY2hhbmdlLlxuICAgICAqL1xuICAgIHN0b3BSZXNpemVOb3RpZmljYXRpb25zRm9yOiBmdW5jdGlvbih0YXJnZXQpIHtcbiAgICAgIHZhciBpbmRleCA9IHRoaXMuX2ludGVyZXN0ZWRSZXNpemFibGVzLmluZGV4T2YodGFyZ2V0KTtcblxuICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgdGhpcy5faW50ZXJlc3RlZFJlc2l6YWJsZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgdGhpcy51bmxpc3Rlbih0YXJnZXQsICdpcm9uLXJlc2l6ZScsICdfb25EZXNjZW5kYW50SXJvblJlc2l6ZScpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBjYW4gYmUgb3ZlcnJpZGRlbiB0byBmaWx0ZXIgbmVzdGVkIGVsZW1lbnRzIHRoYXQgc2hvdWxkIG9yXG4gICAgICogc2hvdWxkIG5vdCBiZSBub3RpZmllZCBieSB0aGUgY3VycmVudCBlbGVtZW50LiBSZXR1cm4gdHJ1ZSBpZiBhbiBlbGVtZW50XG4gICAgICogc2hvdWxkIGJlIG5vdGlmaWVkLCBvciBmYWxzZSBpZiBpdCBzaG91bGQgbm90IGJlIG5vdGlmaWVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCBBIGNhbmRpZGF0ZSBkZXNjZW5kYW50IGVsZW1lbnQgdGhhdFxuICAgICAqIGltcGxlbWVudHMgYElyb25SZXNpemFibGVCZWhhdmlvcmAuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgYGVsZW1lbnRgIHNob3VsZCBiZSBub3RpZmllZCBvZiByZXNpemUuXG4gICAgICovXG4gICAgcmVzaXplclNob3VsZE5vdGlmeTogZnVuY3Rpb24oZWxlbWVudCkgeyByZXR1cm4gdHJ1ZTsgfSxcblxuICAgIF9vbkRlc2NlbmRhbnRJcm9uUmVzaXplOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgaWYgKHRoaXMuX25vdGlmeWluZ0Rlc2NlbmRhbnQpIHtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gTk9URShjZGF0YSk6IEluIFNoYWRvd0RPTSwgZXZlbnQgcmV0YXJnZXRpbmcgbWFrZXMgZWNob2luZyBvZiB0aGVcbiAgICAgIC8vIG90aGVyd2lzZSBub24tYnViYmxpbmcgZXZlbnQgXCJqdXN0IHdvcmsuXCIgV2UgZG8gaXQgbWFudWFsbHkgaGVyZSBmb3JcbiAgICAgIC8vIHRoZSBjYXNlIHdoZXJlIFBvbHltZXIgaXMgbm90IHVzaW5nIHNoYWRvdyByb290cyBmb3Igd2hhdGV2ZXIgcmVhc29uOlxuICAgICAgaWYgKCFQb2x5bWVyLlNldHRpbmdzLnVzZVNoYWRvdykge1xuICAgICAgICB0aGlzLl9maXJlUmVzaXplKCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIF9maXJlUmVzaXplOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZmlyZSgnaXJvbi1yZXNpemUnLCBudWxsLCB7XG4gICAgICAgIG5vZGU6IHRoaXMsXG4gICAgICAgIGJ1YmJsZXM6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgX29uSXJvblJlcXVlc3RSZXNpemVOb3RpZmljYXRpb25zOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgdmFyIHRhcmdldCA9IC8qKiBAdHlwZSB7IUV2ZW50VGFyZ2V0fSAqLyAoUG9seW1lci5kb20oZXZlbnQpLnJvb3RUYXJnZXQpO1xuICAgICAgaWYgKHRhcmdldCA9PT0gdGhpcykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9pbnRlcmVzdGVkUmVzaXphYmxlcy5pbmRleE9mKHRhcmdldCkgPT09IC0xKSB7XG4gICAgICAgIHRoaXMuX2ludGVyZXN0ZWRSZXNpemFibGVzLnB1c2godGFyZ2V0KTtcbiAgICAgICAgdGhpcy5saXN0ZW4odGFyZ2V0LCAnaXJvbi1yZXNpemUnLCAnX29uRGVzY2VuZGFudElyb25SZXNpemUnKTtcbiAgICAgIH1cblxuICAgICAgdGFyZ2V0LmFzc2lnblBhcmVudFJlc2l6YWJsZSh0aGlzKTtcbiAgICAgIHRoaXMuX25vdGlmeURlc2NlbmRhbnQodGFyZ2V0KTtcblxuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfSxcblxuICAgIF9wYXJlbnRSZXNpemFibGVDaGFuZ2VkOiBmdW5jdGlvbihwYXJlbnRSZXNpemFibGUpIHtcbiAgICAgIGlmIChwYXJlbnRSZXNpemFibGUpIHtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuX2JvdW5kTm90aWZ5UmVzaXplKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgX25vdGlmeURlc2NlbmRhbnQ6IGZ1bmN0aW9uKGRlc2NlbmRhbnQpIHtcbiAgICAgIC8vIE5PVEUoY2RhdGEpOiBJbiBJRTEwLCBhdHRhY2hlZCBpcyBmaXJlZCBvbiBjaGlsZHJlbiBmaXJzdCwgc28gaXQnc1xuICAgICAgLy8gaW1wb3J0YW50IG5vdCB0byBub3RpZnkgdGhlbSBpZiB0aGUgcGFyZW50IGlzIG5vdCBhdHRhY2hlZCB5ZXQgKG9yXG4gICAgICAvLyBlbHNlIHRoZXkgd2lsbCBnZXQgcmVkdW5kYW50bHkgbm90aWZpZWQgd2hlbiB0aGUgcGFyZW50IGF0dGFjaGVzKS5cbiAgICAgIGlmICghdGhpcy5pc0F0dGFjaGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fbm90aWZ5aW5nRGVzY2VuZGFudCA9IHRydWU7XG4gICAgICBkZXNjZW5kYW50Lm5vdGlmeVJlc2l6ZSgpO1xuICAgICAgdGhpcy5fbm90aWZ5aW5nRGVzY2VuZGFudCA9IGZhbHNlO1xuICAgIH0sXG4gICAgXG4gICAgX3JlcXVlc3RSZXNpemVOb3RpZmljYXRpb25zOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5pc0F0dGFjaGVkKVxuICAgICAgICByZXR1cm47XG4gICAgICBcbiAgICAgIC8vIE5PVEUodmFsZHJpbikgSW4gQ3VzdG9tRWxlbWVudHMgdjEgd2l0aCBuYXRpdmUgSFRNTEltcG9ydHMsIHRoZSBvcmRlclxuICAgICAgLy8gb2YgaW1wb3J0cyBhZmZlY3RzIHRoZSBvcmRlciBvZiBgYXR0YWNoZWRgIGNhbGxiYWNrcyAoc2VlIHdlYmNvbXBvbmVudHMvY3VzdG9tLWVsZW1lbnRzIzE1KS5cbiAgICAgIC8vIFRoaXMgbWlnaHQgY2F1c2UgYSBjaGlsZCB0byBub3RpZnkgcGFyZW50cyB0b28gZWFybHkgKGFzIHRoZSBwYXJlbnRcbiAgICAgIC8vIHN0aWxsIGhhcyB0byBiZSB1cGdyYWRlZCksIHJlc3VsdGluZyBpbiBhIHBhcmVudCBub3QgYWJsZSB0byBrZWVwIHRyYWNrXG4gICAgICAvLyBvZiB0aGUgYF9pbnRlcmVzdGVkUmVzaXphYmxlc2AuIFRvIHNvbHZlIHRoaXMsIHdlIHdhaXQgZm9yIHRoZSBkb2N1bWVudFxuICAgICAgLy8gdG8gYmUgZG9uZSBsb2FkaW5nIGJlZm9yZSBmaXJpbmcgdGhlIGV2ZW50LlxuICAgICAgaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdsb2FkaW5nJykge1xuICAgICAgICB2YXIgX3JlcXVlc3RSZXNpemVOb3RpZmljYXRpb25zID0gdGhpcy5fcmVxdWVzdFJlc2l6ZU5vdGlmaWNhdGlvbnMuYmluZCh0aGlzKTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncmVhZHlzdGF0ZWNoYW5nZScsIGZ1bmN0aW9uIHJlYWR5c3RhdGVjaGFuZ2VkKCkge1xuICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3JlYWR5c3RhdGVjaGFuZ2UnLCByZWFkeXN0YXRlY2hhbmdlZCk7XG4gICAgICAgICAgX3JlcXVlc3RSZXNpemVOb3RpZmljYXRpb25zKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5maXJlKCdpcm9uLXJlcXVlc3QtcmVzaXplLW5vdGlmaWNhdGlvbnMnLCBudWxsLCB7XG4gICAgICAgICAgbm9kZTogdGhpcyxcbiAgICAgICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgICAgIGNhbmNlbGFibGU6IHRydWVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9wYXJlbnRSZXNpemFibGUpIHtcbiAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5fYm91bmROb3RpZnlSZXNpemUpO1xuICAgICAgICAgIHRoaXMubm90aWZ5UmVzaXplKCk7XG4gICAgICAgIH0gXG4gICAgICB9XG4gICAgfVxuICB9O1xuPC9zY3JpcHQ+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL2lyb24tcmVzaXphYmxlLWJlaGF2aW9yL2lyb24tcmVzaXphYmxlLWJlaGF2aW9yLmh0bWwiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE1IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi9wb2x5bWVyL3BvbHltZXIuaHRtbFwiPlxuXG48IS0tXG5gaXJvbi1tZXRhYCBpcyBhIGdlbmVyaWMgZWxlbWVudCB5b3UgY2FuIHVzZSBmb3Igc2hhcmluZyBpbmZvcm1hdGlvbiBhY3Jvc3MgdGhlIERPTSB0cmVlLlxuSXQgdXNlcyBbbW9ub3N0YXRlIHBhdHRlcm5dKGh0dHA6Ly9jMi5jb20vY2dpL3dpa2k/TW9ub3N0YXRlUGF0dGVybikgc3VjaCB0aGF0IGFueVxuaW5zdGFuY2Ugb2YgaXJvbi1tZXRhIGhhcyBhY2Nlc3MgdG8gdGhlIHNoYXJlZFxuaW5mb3JtYXRpb24uIFlvdSBjYW4gdXNlIGBpcm9uLW1ldGFgIHRvIHNoYXJlIHdoYXRldmVyIHlvdSB3YW50IChvciBjcmVhdGUgYW4gZXh0ZW5zaW9uXG5bbGlrZSB4LW1ldGFdIGZvciBlbmhhbmNlbWVudHMpLlxuXG5UaGUgYGlyb24tbWV0YWAgaW5zdGFuY2VzIGNvbnRhaW5pbmcgeW91ciBhY3R1YWwgZGF0YSBjYW4gYmUgbG9hZGVkIGluIGFuIGltcG9ydCxcbm9yIGNvbnN0cnVjdGVkIGluIGFueSB3YXkgeW91IHNlZSBmaXQuIFRoZSBvbmx5IHJlcXVpcmVtZW50IGlzIHRoYXQgeW91IGNyZWF0ZSB0aGVtXG5iZWZvcmUgeW91IHRyeSB0byBhY2Nlc3MgdGhlbS5cblxuRXhhbXBsZXM6XG5cbklmIEkgY3JlYXRlIGFuIGluc3RhbmNlIGxpa2UgdGhpczpcblxuICAgIDxpcm9uLW1ldGEga2V5PVwiaW5mb1wiIHZhbHVlPVwiZm9vL2JhclwiPjwvaXJvbi1tZXRhPlxuXG5Ob3RlIHRoYXQgdmFsdWU9XCJmb28vYmFyXCIgaXMgdGhlIG1ldGFkYXRhIEkndmUgZGVmaW5lZC4gSSBjb3VsZCBkZWZpbmUgbW9yZVxuYXR0cmlidXRlcyBvciB1c2UgY2hpbGQgbm9kZXMgdG8gZGVmaW5lIGFkZGl0aW9uYWwgbWV0YWRhdGEuXG5cbk5vdyBJIGNhbiBhY2Nlc3MgdGhhdCBlbGVtZW50IChhbmQgaXQncyBtZXRhZGF0YSkgZnJvbSBhbnkgaXJvbi1tZXRhIGluc3RhbmNlXG52aWEgdGhlIGJ5S2V5IG1ldGhvZCwgZS5nLlxuXG4gICAgbWV0YS5ieUtleSgnaW5mbycpO1xuXG5QdXJlIGltcGVyYXRpdmUgZm9ybSB3b3VsZCBiZSBsaWtlOlxuXG4gICAgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaXJvbi1tZXRhJykuYnlLZXkoJ2luZm8nKTtcblxuT3IsIGluIGEgUG9seW1lciBlbGVtZW50LCB5b3UgY2FuIGluY2x1ZGUgYSBtZXRhIGluIHlvdXIgdGVtcGxhdGU6XG5cbiAgICA8aXJvbi1tZXRhIGlkPVwibWV0YVwiPjwvaXJvbi1tZXRhPlxuICAgIC4uLlxuICAgIHRoaXMuJC5tZXRhLmJ5S2V5KCdpbmZvJyk7XG5cbkBncm91cCBJcm9uIEVsZW1lbnRzXG5AZGVtbyBkZW1vL2luZGV4Lmh0bWxcbkBoZXJvIGhlcm8uc3ZnXG5AZWxlbWVudCBpcm9uLW1ldGFcbi0tPlxuXG48c2NyaXB0PlxuXG4gIChmdW5jdGlvbigpIHtcblxuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7e3R5cGU6IChzdHJpbmd8bnVsbCksIGtleTogKHN0cmluZ3xudWxsKSwgdmFsdWU6ICp9fSBvcHRpb25zXG4gICAgICovXG4gICAgZnVuY3Rpb24gSXJvbk1ldGEob3B0aW9ucykge1xuICAgICAgdGhpcy50eXBlID0gKG9wdGlvbnMgJiYgb3B0aW9ucy50eXBlKSB8fCAnZGVmYXVsdCc7XG4gICAgICB0aGlzLmtleSA9IG9wdGlvbnMgJiYgb3B0aW9ucy5rZXk7XG4gICAgICBpZiAoJ3ZhbHVlJyBpbiBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSBvcHRpb25zLnZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIElyb25NZXRhLnR5cGVzID0ge307XG5cbiAgICBJcm9uTWV0YS5wcm90b3R5cGUgPSB7XG4gICAgICBnZXQgdmFsdWUoKSB7XG4gICAgICAgIHZhciB0eXBlID0gdGhpcy50eXBlO1xuICAgICAgICB2YXIga2V5ID0gdGhpcy5rZXk7XG5cbiAgICAgICAgaWYgKHR5cGUgJiYga2V5KSB7XG4gICAgICAgICAgcmV0dXJuIElyb25NZXRhLnR5cGVzW3R5cGVdICYmIElyb25NZXRhLnR5cGVzW3R5cGVdW2tleV07XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIHNldCB2YWx1ZSh2YWx1ZSkge1xuICAgICAgICB2YXIgdHlwZSA9IHRoaXMudHlwZTtcbiAgICAgICAgdmFyIGtleSA9IHRoaXMua2V5O1xuXG4gICAgICAgIGlmICh0eXBlICYmIGtleSkge1xuICAgICAgICAgIHR5cGUgPSBJcm9uTWV0YS50eXBlc1t0eXBlXSA9IElyb25NZXRhLnR5cGVzW3R5cGVdIHx8IHt9O1xuICAgICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBkZWxldGUgdHlwZVtrZXldO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0eXBlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIGdldCBsaXN0KCkge1xuICAgICAgICB2YXIgdHlwZSA9IHRoaXMudHlwZTtcblxuICAgICAgICBpZiAodHlwZSkge1xuICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhJcm9uTWV0YS50eXBlc1t0aGlzLnR5cGVdKS5tYXAoZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gbWV0YURhdGFzW3RoaXMudHlwZV1ba2V5XTtcbiAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgYnlLZXk6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgICB9XG4gICAgfTtcblxuICAgIFBvbHltZXIuSXJvbk1ldGEgPSBJcm9uTWV0YTtcblxuICAgIHZhciBtZXRhRGF0YXMgPSBQb2x5bWVyLklyb25NZXRhLnR5cGVzO1xuXG4gICAgUG9seW1lcih7XG5cbiAgICAgIGlzOiAnaXJvbi1tZXRhJyxcblxuICAgICAgcHJvcGVydGllczoge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdHlwZSBvZiBtZXRhLWRhdGEuICBBbGwgbWV0YS1kYXRhIG9mIHRoZSBzYW1lIHR5cGUgaXMgc3RvcmVkXG4gICAgICAgICAqIHRvZ2V0aGVyLlxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdHlwZToge1xuICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICB2YWx1ZTogJ2RlZmF1bHQnLFxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUga2V5IHVzZWQgdG8gc3RvcmUgYHZhbHVlYCB1bmRlciB0aGUgYHR5cGVgIG5hbWVzcGFjZS5cbiAgICAgICAgICogQHR5cGUgez9zdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICBrZXk6IHtcbiAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBtZXRhLWRhdGEgdG8gc3RvcmUgb3IgcmV0cmlldmUuXG4gICAgICAgICAqIEB0eXBlIHsqfVxuICAgICAgICAgKi9cbiAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgbm90aWZ5OiB0cnVlLFxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0cnVlLCBgdmFsdWVgIGlzIHNldCB0byB0aGUgaXJvbi1tZXRhIGluc3RhbmNlIGl0c2VsZi5cbiAgICAgICAgICovXG4gICAgICAgICBzZWxmOiB7XG4gICAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgICBvYnNlcnZlcjogJ19zZWxmQ2hhbmdlZCdcbiAgICAgICAgfSxcblxuICAgICAgICBfX21ldGE6IHtcbiAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgIGNvbXB1dGVkOiAnX19jb21wdXRlTWV0YSh0eXBlLCBrZXksIHZhbHVlKSdcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgaG9zdEF0dHJpYnV0ZXM6IHtcbiAgICAgICAgaGlkZGVuOiB0cnVlXG4gICAgICB9LFxuXG4gICAgICBfX2NvbXB1dGVNZXRhOiBmdW5jdGlvbih0eXBlLCBrZXksIHZhbHVlKSB7XG4gICAgICAgIHZhciBtZXRhID0gbmV3IFBvbHltZXIuSXJvbk1ldGEoe1xuICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAga2V5OiBrZXlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG1ldGEudmFsdWUpIHtcbiAgICAgICAgICBtZXRhLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy52YWx1ZSAhPT0gbWV0YS52YWx1ZSkge1xuICAgICAgICAgIHRoaXMudmFsdWUgPSBtZXRhLnZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1ldGE7XG4gICAgICB9LFxuXG4gICAgICBnZXQgbGlzdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19tZXRhICYmIHRoaXMuX19tZXRhLmxpc3Q7XG4gICAgICB9LFxuXG4gICAgICBfc2VsZkNoYW5nZWQ6IGZ1bmN0aW9uKHNlbGYpIHtcbiAgICAgICAgaWYgKHNlbGYpIHtcbiAgICAgICAgICB0aGlzLnZhbHVlID0gdGhpcztcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBSZXRyaWV2ZXMgbWV0YSBkYXRhIHZhbHVlIGJ5IGtleS5cbiAgICAgICAqXG4gICAgICAgKiBAbWV0aG9kIGJ5S2V5XG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGEtZGF0YSB0byBiZSByZXR1cm5lZC5cbiAgICAgICAqIEByZXR1cm4geyp9XG4gICAgICAgKi9cbiAgICAgIGJ5S2V5OiBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2x5bWVyLklyb25NZXRhKHtcbiAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgICAga2V5OiBrZXlcbiAgICAgICAgfSkudmFsdWU7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pKCk7XG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvaXJvbi1tZXRhL2lyb24tbWV0YS5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuXG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vdXRpbHMvYm9vdC5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vdXRpbHMvc2V0dGluZ3MuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3V0aWxzL21peGluLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi91dGlscy9jYXNlLW1hcC5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vdXRpbHMvc3R5bGUtZ2F0aGVyLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi91dGlscy9yZXNvbHZlLXVybC5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vZWxlbWVudHMvZG9tLW1vZHVsZS5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwicHJvcGVydHktZWZmZWN0cy5odG1sXCI+XG5cbjxzY3JpcHQ+XG4oZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvKipcbiAgICogRWxlbWVudCBjbGFzcyBtaXhpbiB0aGF0IHByb3ZpZGVzIHRoZSBjb3JlIEFQSSBmb3IgUG9seW1lcidzIG1ldGEtcHJvZ3JhbW1pbmdcbiAgICogZmVhdHVyZXMgaW5jbHVkaW5nIHRlbXBsYXRlIHN0YW1waW5nLCBkYXRhLWJpbmRpbmcsIGF0dHJpYnV0ZSBkZXNlcmlhbGl6YXRpb24sXG4gICAqIGFuZCBwcm9wZXJ0eSBjaGFuZ2Ugb2JzZXJ2YXRpb24uXG4gICAqXG4gICAqIFN1YmNsYXNzZXJzIG1heSBwcm92aWRlIHRoZSBmb2xsb3dpbmcgc3RhdGljIGdldHRlcnMgdG8gcmV0dXJuIG1ldGFkYXRhXG4gICAqIHVzZWQgdG8gY29uZmlndXJlIFBvbHltZXIncyBmZWF0dXJlcyBmb3IgdGhlIGNsYXNzOlxuICAgKlxuICAgKiAtIGBzdGF0aWMgZ2V0IGlzKClgOiBXaGVuIHRoZSB0ZW1wbGF0ZSBpcyBwcm92aWRlZCB2aWEgYSBgZG9tLW1vZHVsZWAsXG4gICAqICAgdXNlcnMgc2hvdWxkIHJldHVybiB0aGUgYGRvbS1tb2R1bGVgIGlkIGZyb20gYSBzdGF0aWMgYGlzYCBnZXR0ZXIuICBJZlxuICAgKiAgIG5vIHRlbXBsYXRlIGlzIG5lZWRlZCBvciB0aGUgdGVtcGxhdGUgaXMgcHJvdmlkZWQgZGlyZWN0bHkgdmlhIHRoZVxuICAgKiAgIGB0ZW1wbGF0ZWAgZ2V0dGVyLCB0aGVyZSBpcyBubyBuZWVkIHRvIGRlZmluZSBgaXNgIGZvciB0aGUgZWxlbWVudC5cbiAgICpcbiAgICogLSBgc3RhdGljIGdldCB0ZW1wbGF0ZSgpYDogVXNlcnMgbWF5IHByb3ZpZGUgdGhlIHRlbXBsYXRlIGRpcmVjdGx5IChhc1xuICAgKiAgIG9wcG9zZWQgdG8gdmlhIGBkb20tbW9kdWxlYCkgYnkgaW1wbGVtZW50aW5nIGEgc3RhdGljIGB0ZW1wbGF0ZWAgZ2V0dGVyLlxuICAgKiAgIFRoZSBnZXR0ZXIgbWF5IHJldHVybiBhbiBgSFRNTFRlbXBsYXRlRWxlbWVudGAgb3IgYSBzdHJpbmcsIHdoaWNoIHdpbGxcbiAgICogICBhdXRvbWF0aWNhbGx5IGJlIHBhcnNlZCBpbnRvIGEgdGVtcGxhdGUuXG4gICAqXG4gICAqIC0gYHN0YXRpYyBnZXQgcHJvcGVydGllcygpYDogU2hvdWxkIHJldHVybiBhbiBvYmplY3QgZGVzY3JpYmluZ1xuICAgKiAgIHByb3BlcnR5LXJlbGF0ZWQgbWV0YWRhdGEgdXNlZCBieSBQb2x5bWVyIGZlYXR1cmVzIChrZXk6IHByb3BlcnR5IG5hbWVcbiAgICogICB2YWx1ZTogb2JqZWN0IGNvbnRhaW5pbmcgcHJvcGVydHkgbWV0YWRhdGEpLiBWYWxpZCBrZXlzIGluIHBlci1wcm9wZXJ0eVxuICAgKiAgIG1ldGFkYXRhIGluY2x1ZGU6XG4gICAqICAgLSBgdHlwZWAgKFN0cmluZ3xOdW1iZXJ8T2JqZWN0fEFycmF5fC4uLik6IFVzZWQgYnlcbiAgICogICAgIGBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2tgIHRvIGRldGVybWluZSBob3cgc3RyaW5nLWJhc2VkIGF0dHJpYnV0ZXNcbiAgICogICAgIGFyZSBkZXNlcmlhbGl6ZWQgdG8gSmF2YVNjcmlwdCBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAqICAgLSBgbm90aWZ5YCAoYm9vbGVhbik6IENhdXNlcyBhIGNoYW5nZSBpbiB0aGUgcHJvcGVydHkgdG8gZmlyZSBhXG4gICAqICAgICBub24tYnViYmxpbmcgZXZlbnQgY2FsbGVkIGA8cHJvcGVydHk+LWNoYW5nZWRgLiBFbGVtZW50cyB0aGF0IGhhdmVcbiAgICogICAgIGVuYWJsZWQgdHdvLXdheSBiaW5kaW5nIHRvIHRoZSBwcm9wZXJ0eSB1c2UgdGhpcyBldmVudCB0byBvYnNlcnZlIGNoYW5nZXMuXG4gICAqICAgLSBgcmVhZE9ubHlgIChib29sZWFuKTogQ3JlYXRlcyBhIGdldHRlciBmb3IgdGhlIHByb3BlcnR5LCBidXQgbm8gc2V0dGVyLlxuICAgKiAgICAgVG8gc2V0IGEgcmVhZC1vbmx5IHByb3BlcnR5LCB1c2UgdGhlIHByaXZhdGUgc2V0dGVyIG1ldGhvZFxuICAgKiAgICAgYF9zZXRQcm9wZXJ0eShwcm9wZXJ0eSwgdmFsdWUpYC5cbiAgICogICAtIGBvYnNlcnZlcmAgKHN0cmluZyk6IE9ic2VydmVyIG1ldGhvZCBuYW1lIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2hlblxuICAgKiAgICAgdGhlIHByb3BlcnR5IGNoYW5nZXMuIFRoZSBhcmd1bWVudHMgb2YgdGhlIG1ldGhvZCBhcmVcbiAgICogICAgIGAodmFsdWUsIHByZXZpb3VzVmFsdWUpYC5cbiAgICogICAtIGBjb21wdXRlZGAgKHN0cmluZyk6IFN0cmluZyBkZXNjcmliaW5nIG1ldGhvZCBhbmQgZGVwZW5kZW50IHByb3BlcnRpZXNcbiAgICogICAgIGZvciBjb21wdXRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgcHJvcGVydHkgKGUuZy4gYCdjb21wdXRlRm9vKGJhciwgem90KSdgKS5cbiAgICogICAgIENvbXB1dGVkIHByb3BlcnRpZXMgYXJlIHJlYWQtb25seSBieSBkZWZhdWx0IGFuZCBjYW4gb25seSBiZSBjaGFuZ2VkXG4gICAqICAgICB2aWEgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgY29tcHV0aW5nIG1ldGhvZC5cbiAgICpcbiAgICogLSBgc3RhdGljIGdldCBvYnNlcnZlcnMoKWA6IEFycmF5IG9mIHN0cmluZ3MgZGVzY3JpYmluZyBtdWx0aS1wcm9wZXJ0eVxuICAgKiAgIG9ic2VydmVyIG1ldGhvZHMgYW5kIHRoZWlyIGRlcGVuZGVudCBwcm9wZXJ0aWVzIChlLmcuXG4gICAqICAgYCdvYnNlcnZlQUJDKGEsIGIsIGMpJ2ApLlxuICAgKlxuICAgKiBUaGUgYmFzZSBjbGFzcyBwcm92aWRlcyBkZWZhdWx0IGltcGxlbWVudGF0aW9ucyBmb3IgdGhlIGZvbGxvd2luZyBzdGFuZGFyZFxuICAgKiBjdXN0b20gZWxlbWVudCBsaWZlY3ljbGUgY2FsbGJhY2tzOyB1c2VycyBtYXkgb3ZlcnJpZGUgdGhlc2UsIGJ1dCBzaG91bGRcbiAgICogY2FsbCB0aGUgc3VwZXIgbWV0aG9kIHRvIGVuc3VyZVxuICAgKiAtIGBjb25zdHJ1Y3RvcmA6IFJ1biB3aGVuIHRoZSBlbGVtZW50IGlzIGNyZWF0ZWQgb3IgdXBncmFkZWRcbiAgICogLSBgY29ubmVjdGVkQ2FsbGJhY2tgOiBSdW4gZWFjaCB0aW1lIHRoZSBlbGVtZW50IGlzIGNvbm5lY3RlZCB0byB0aGVcbiAgICogICBkb2N1bWVudFxuICAgKiAtIGBkaXNjb25uZWN0ZWRDYWxsYmFja2A6IFJ1biBlYWNoIHRpbWUgdGhlIGVsZW1lbnQgaXMgZGlzY29ubmVjdGVkIGZyb21cbiAgICogICB0aGUgZG9jdW1lbnRcbiAgICogLSBgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrYDogUnVuIGVhY2ggdGltZSBhbiBhdHRyaWJ1dGUgaW5cbiAgICogICBgb2JzZXJ2ZWRBdHRyaWJ1dGVzYCBpcyBzZXQgb3IgcmVtb3ZlZCAobm90ZTogdGhpcyBlbGVtZW50J3MgZGVmYXVsdFxuICAgKiAgIGBvYnNlcnZlZEF0dHJpYnV0ZXNgIGltcGxlbWVudGF0aW9uIHdpbGwgYXV0b21hdGljYWxseSByZXR1cm4gYW4gYXJyYXlcbiAgICogICBvZiBkYXNoLWNhc2VkIGF0dHJpYnV0ZXMgYmFzZWQgb24gYHByb3BlcnRpZXNgKVxuICAgKlxuICAgKiBAbWl4aW5GdW5jdGlvblxuICAgKiBAcG9seW1lclxuICAgKiBAYXBwbGllc01peGluIFBvbHltZXIuUHJvcGVydHlFZmZlY3RzXG4gICAqIEBtZW1iZXJvZiBQb2x5bWVyXG4gICAqIEBwcm9wZXJ0eSByb290UGF0aCB7c3RyaW5nfSBTZXQgdG8gdGhlIHZhbHVlIG9mIGBQb2x5bWVyLnJvb3RQYXRoYCxcbiAgICogICB3aGljaCBkZWZhdWx0cyB0byB0aGUgbWFpbiBkb2N1bWVudCBwYXRoXG4gICAqIEBwcm9wZXJ0eSBpbXBvcnRQYXRoIHtzdHJpbmd9IFNldCB0byB0aGUgdmFsdWUgb2YgdGhlIGNsYXNzJ3Mgc3RhdGljXG4gICAqICAgYGltcG9ydFBhdGhgIHByb3BlcnR5LCB3aGljaCBkZWZhdWx0cyB0byB0aGUgcGF0aCBvZiB0aGlzIGVsZW1lbnQnc1xuICAgKiAgIGBkb20tbW9kdWxlYCAod2hlbiBgaXNgIGlzIHVzZWQpLCBidXQgY2FuIGJlIG92ZXJyaWRkZW4gZm9yIG90aGVyXG4gICAqICAgaW1wb3J0IHN0cmF0ZWdpZXMuXG4gICAqIEBzdW1tYXJ5IEVsZW1lbnQgY2xhc3MgbWl4aW4gdGhhdCBwcm92aWRlcyB0aGUgY29yZSBBUEkgZm9yIFBvbHltZXInc1xuICAgKiBtZXRhLXByb2dyYW1taW5nIGZlYXR1cmVzLlxuICAgKi9cbiAgUG9seW1lci5FbGVtZW50TWl4aW4gPSBQb2x5bWVyLmRlZHVwaW5nTWl4aW4oYmFzZSA9PiB7XG5cbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAZXh0ZW5kcyB7YmFzZX1cbiAgICAgKiBAaW1wbGVtZW50cyB7UG9seW1lcl9Qcm9wZXJ0eUVmZmVjdHN9XG4gICAgICovXG4gICAgY29uc3QgcG9seW1lckVsZW1lbnRCYXNlID0gUG9seW1lci5Qcm9wZXJ0eUVmZmVjdHMoYmFzZSk7XG5cbiAgICBsZXQgY2FzZU1hcCA9IFBvbHltZXIuQ2FzZU1hcDtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGBwcm9wZXJ0aWVzYCBvYmplY3Qgc3BlY2lmaWNhbGx5IG9uIGBrbGFzc2AuIFVzZSBmb3I6XG4gICAgICogKDEpIHN1cGVyIGNoYWluIG1peGVzIHRvZ3RoZXIgdG8gbWFrZSBgcHJvcGVydGllc0ZvckNsYXNzYCB3aGljaCBpc1xuICAgICAqIHRoZW4gdXNlZCB0byBtYWtlIGBvYnNlcnZlZEF0dHJpYnV0ZXNgLlxuICAgICAqICgyKSBwcm9wZXJ0aWVzIGVmZmVjdHMgYW5kIG9ic2VydmVycyBhcmUgY3JlYXRlZCBmcm9tIGl0IGF0IGBmaW5hbGl6ZWAgdGltZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGtsYXNzIEVsZW1lbnQgY2xhc3NcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdCBjb250YWluaW5nIG93biBwcm9wZXJ0aWVzIGZvciB0aGlzIGNsYXNzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvd25Qcm9wZXJ0aWVzRm9yQ2xhc3Moa2xhc3MpIHtcbiAgICAgIGlmICgha2xhc3MuaGFzT3duUHJvcGVydHkoXG4gICAgICAgIEpTQ29tcGlsZXJfcmVuYW1lUHJvcGVydHkoJ19fb3duUHJvcGVydGllcycsIGtsYXNzKSkpIHtcbiAgICAgICAga2xhc3MuX19vd25Qcm9wZXJ0aWVzID1cbiAgICAgICAgICBrbGFzcy5oYXNPd25Qcm9wZXJ0eShKU0NvbXBpbGVyX3JlbmFtZVByb3BlcnR5KCdwcm9wZXJ0aWVzJywga2xhc3MpKSA/XG4gICAgICAgICAgLyoqIEB0eXBlIFBvbHltZXJFbGVtZW50Q29uc3RydWN0b3IgKi8gKGtsYXNzKS5wcm9wZXJ0aWVzIDoge307XG4gICAgICB9XG4gICAgICByZXR1cm4ga2xhc3MuX19vd25Qcm9wZXJ0aWVzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGBvYnNlcnZlcnNgIGFycmF5IHNwZWNpZmljYWxseSBvbiBga2xhc3NgLiBVc2UgZm9yXG4gICAgICogc2V0dGluZyB1cCBvYnNlcnZlcnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBrbGFzcyBFbGVtZW50IGNsYXNzXG4gICAgICogQHJldHVybiB7QXJyYXl9IEFycmF5IGNvbnRhaW5pbmcgb3duIG9ic2VydmVycyBmb3IgdGhpcyBjbGFzc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZnVuY3Rpb24gb3duT2JzZXJ2ZXJzRm9yQ2xhc3Moa2xhc3MpIHtcbiAgICAgIGlmICgha2xhc3MuaGFzT3duUHJvcGVydHkoXG4gICAgICAgIEpTQ29tcGlsZXJfcmVuYW1lUHJvcGVydHkoJ19fb3duT2JzZXJ2ZXJzJywga2xhc3MpKSkge1xuICAgICAgICBrbGFzcy5fX293bk9ic2VydmVycyA9XG4gICAgICAgICAga2xhc3MuaGFzT3duUHJvcGVydHkoSlNDb21waWxlcl9yZW5hbWVQcm9wZXJ0eSgnb2JzZXJ2ZXJzJywga2xhc3MpKSA/XG4gICAgICAgICAgLyoqIEB0eXBlIFBvbHltZXJFbGVtZW50Q29uc3RydWN0b3IgKi8gKGtsYXNzKS5vYnNlcnZlcnMgOiBbXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBrbGFzcy5fX293bk9ic2VydmVycztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNaXhlcyBgcHJvcHNgIGludG8gYGZsYXR0ZW5lZFByb3BzYCBidXQgdXBncmFkZXMgc2hvcnRoYW5kIHR5cGVcbiAgICAgKiBzeW50YXggdG8geyB0eXBlOiBUeXBlfS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBmbGF0dGVuZWRQcm9wcyBCYWcgdG8gY29sbGVjdCBmbGF0dGVuZWQgcHJvcGVydGllcyBpbnRvXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzIEJhZyBvZiBwcm9wZXJ0aWVzIHRvIGFkZCB0byBgZmxhdHRlbmVkUHJvcHNgXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgaW5wdXQgYGZsYXR0ZW5lZFByb3BzYCBiYWdcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZsYXR0ZW5Qcm9wZXJ0aWVzKGZsYXR0ZW5lZFByb3BzLCBwcm9wcykge1xuICAgICAgZm9yIChsZXQgcCBpbiBwcm9wcykge1xuICAgICAgICBsZXQgbyA9IHByb3BzW3BdO1xuICAgICAgICBpZiAodHlwZW9mIG8gPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIG8gPSB7IHR5cGU6IG8gfTtcbiAgICAgICAgfVxuICAgICAgICBmbGF0dGVuZWRQcm9wc1twXSA9IG87XG4gICAgICB9XG4gICAgICByZXR1cm4gZmxhdHRlbmVkUHJvcHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGZsYXR0ZW5lZCBsaXN0IG9mIHByb3BlcnRpZXMgbWl4ZWQgdG9nZXRoZXIgZnJvbSB0aGUgY2hhaW4gb2YgYWxsXG4gICAgICogY29uc3RydWN0b3IncyBgY29uZmlnLnByb3BlcnRpZXNgLiBUaGlzIGxpc3QgaXMgdXNlZCB0byBjcmVhdGVcbiAgICAgKiAoMSkgb2JzZXJ2ZWRBdHRyaWJ1dGVzLFxuICAgICAqICgyKSBjbGFzcyBwcm9wZXJ0eSBkZWZhdWx0IHZhbHVlc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtQb2x5bWVyRWxlbWVudENvbnN0cnVjdG9yfSBrbGFzcyBFbGVtZW50IGNsYXNzXG4gICAgICogQHJldHVybiB7UG9seW1lckVsZW1lbnRQcm9wZXJ0aWVzfSBGbGF0dGVuZWQgcHJvcGVydGllcyBmb3IgdGhpcyBjbGFzc1xuICAgICAqIEBzdXBwcmVzcyB7bWlzc2luZ1Byb3BlcnRpZXN9IGNsYXNzLnByb3RvdHlwZSBpcyBub3QgYSBwcm9wZXJ0eSBmb3Igc29tZSByZWFzb24/XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwcm9wZXJ0aWVzRm9yQ2xhc3Moa2xhc3MpIHtcbiAgICAgIGlmICgha2xhc3MuaGFzT3duUHJvcGVydHkoXG4gICAgICAgIEpTQ29tcGlsZXJfcmVuYW1lUHJvcGVydHkoJ19fY2xhc3NQcm9wZXJ0aWVzJywga2xhc3MpKSkge1xuICAgICAgICBrbGFzcy5fX2NsYXNzUHJvcGVydGllcyA9XG4gICAgICAgIGZsYXR0ZW5Qcm9wZXJ0aWVzKHt9LCBvd25Qcm9wZXJ0aWVzRm9yQ2xhc3Moa2xhc3MpKTtcbiAgICAgICAgbGV0IHN1cGVyQ3RvciA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihrbGFzcy5wcm90b3R5cGUpLmNvbnN0cnVjdG9yO1xuICAgICAgICBpZiAoc3VwZXJDdG9yLnByb3RvdHlwZSBpbnN0YW5jZW9mIFBvbHltZXJFbGVtZW50KSB7XG4gICAgICAgICAga2xhc3MuX19jbGFzc1Byb3BlcnRpZXMgPSBPYmplY3QuYXNzaWduKFxuICAgICAgICAgICAgT2JqZWN0LmNyZWF0ZShwcm9wZXJ0aWVzRm9yQ2xhc3MoLyoqIEB0eXBlIFBvbHltZXJFbGVtZW50Q29uc3RydWN0b3IgKi8oc3VwZXJDdG9yKSkpLFxuICAgICAgICAgICAga2xhc3MuX19jbGFzc1Byb3BlcnRpZXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4ga2xhc3MuX19jbGFzc1Byb3BlcnRpZXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGxpc3Qgb2YgcHJvcGVydGllcyB3aXRoIGRlZmF1bHQgdmFsdWVzLlxuICAgICAqIFRoaXMgbGlzdCBpcyBjcmVhdGVkIGFzIGFuIG9wdGltaXphdGlvbiBzaW5jZSBpdCBpcyBhIHN1YnNldCBvZlxuICAgICAqIHRoZSBsaXN0IHJldHVybmVkIGZyb20gYHByb3BlcnRpZXNGb3JDbGFzc2AuXG4gICAgICogVGhpcyBsaXN0IGlzIHVzZWQgaW4gYF9pbml0aWFsaXplUHJvcGVydGllc2AgdG8gc2V0IHByb3BlcnR5IGRlZmF1bHRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQb2x5bWVyRWxlbWVudENvbnN0cnVjdG9yfSBrbGFzcyBFbGVtZW50IGNsYXNzXG4gICAgICogQHJldHVybiB7UG9seW1lckVsZW1lbnRQcm9wZXJ0aWVzfSBGbGF0dGVuZWQgcHJvcGVydGllcyBmb3IgdGhpcyBjbGFzc1xuICAgICAqICAgdGhhdCBoYXZlIGRlZmF1bHQgdmFsdWVzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwcm9wZXJ0eURlZmF1bHRzRm9yQ2xhc3Moa2xhc3MpIHtcbiAgICAgIGlmICgha2xhc3MuaGFzT3duUHJvcGVydHkoXG4gICAgICAgIEpTQ29tcGlsZXJfcmVuYW1lUHJvcGVydHkoJ19fY2xhc3NQcm9wZXJ0eURlZmF1bHRzJywga2xhc3MpKSkge1xuICAgICAgICBrbGFzcy5fX2NsYXNzUHJvcGVydHlEZWZhdWx0cyA9IG51bGw7XG4gICAgICAgIGxldCBwcm9wcyA9IHByb3BlcnRpZXNGb3JDbGFzcyhrbGFzcyk7XG4gICAgICAgIGZvciAobGV0IHAgaW4gcHJvcHMpIHtcbiAgICAgICAgICBsZXQgaW5mbyA9IHByb3BzW3BdO1xuICAgICAgICAgIGlmICgndmFsdWUnIGluIGluZm8pIHtcbiAgICAgICAgICAgIGtsYXNzLl9fY2xhc3NQcm9wZXJ0eURlZmF1bHRzID0ga2xhc3MuX19jbGFzc1Byb3BlcnR5RGVmYXVsdHMgfHwge307XG4gICAgICAgICAgICBrbGFzcy5fX2NsYXNzUHJvcGVydHlEZWZhdWx0c1twXSA9IGluZm87XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4ga2xhc3MuX19jbGFzc1Byb3BlcnR5RGVmYXVsdHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIGEgYGtsYXNzYCBoYXMgZmluYWxpemVkLiBDYWxsZWQgaW4gYEVsZW1lbnRDbGFzcy5maW5hbGl6ZSgpYFxuICAgICAqIEBwYXJhbSB7UG9seW1lckVsZW1lbnRDb25zdHJ1Y3Rvcn0ga2xhc3MgRWxlbWVudCBjbGFzc1xuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYWxsIG1ldGFwcm9ncmFtbWluZyBmb3IgdGhpcyBjbGFzcyBoYXMgYmVlblxuICAgICAqICAgY29tcGxldGVkXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBoYXNDbGFzc0ZpbmFsaXplZChrbGFzcykge1xuICAgICAgcmV0dXJuIGtsYXNzLmhhc093blByb3BlcnR5KEpTQ29tcGlsZXJfcmVuYW1lUHJvcGVydHkoJ19fZmluYWxpemVkJywga2xhc3MpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgYnkgYEVsZW1lbnRDbGFzcy5maW5hbGl6ZSgpYC4gRW5zdXJlcyB0aGlzIGBrbGFzc2AgYW5kXG4gICAgICogKmFsbCBzdXBlcmNsYXNzZXMqIGFyZSBmaW5hbGl6ZWQgYnkgdHJhdmVyc2luZyB0aGUgcHJvdG90eXBlIGNoYWluXG4gICAgICogYW5kIGNhbGxpbmcgYGtsYXNzLmZpbmFsaXplKClgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQb2x5bWVyRWxlbWVudENvbnN0cnVjdG9yfSBrbGFzcyBFbGVtZW50IGNsYXNzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5hbGl6ZUNsYXNzQW5kU3VwZXIoa2xhc3MpIHtcbiAgICAgIGxldCBwcm90byA9IC8qKiBAdHlwZSBQb2x5bWVyRWxlbWVudENvbnN0cnVjdG9yICovIChrbGFzcykucHJvdG90eXBlO1xuICAgICAgbGV0IHN1cGVyQ3RvciA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihwcm90bykuY29uc3RydWN0b3I7XG4gICAgICBpZiAoc3VwZXJDdG9yLnByb3RvdHlwZSBpbnN0YW5jZW9mIFBvbHltZXJFbGVtZW50KSB7XG4gICAgICAgIHN1cGVyQ3Rvci5maW5hbGl6ZSgpO1xuICAgICAgfVxuICAgICAgZmluYWxpemVDbGFzcyhrbGFzcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29uZmlndXJlcyBhIGBrbGFzc2AgYmFzZWQgb24gYSBzdGFpYyBga2xhc3MuY29uZmlnYCBvYmplY3QgYW5kXG4gICAgICogYSBgdGVtcGxhdGVgLiBUaGlzIGluY2x1ZGVzIGNyZWF0aW5nIGFjY2Vzc29ycyBhbmQgZWZmZWN0c1xuICAgICAqIGZvciBwcm9wZXJ0aWVzIGluIGBjb25maWdgIGFuZCB0aGUgYHRlbXBsYXRlYCBhcyB3ZWxsIGFzIHByZXBhcmluZyB0aGVcbiAgICAgKiBgdGVtcGxhdGVgIGZvciBzdGFtcGluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UG9seW1lckVsZW1lbnRDb25zdHJ1Y3Rvcn0ga2xhc3MgRWxlbWVudCBjbGFzc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmluYWxpemVDbGFzcyhrbGFzcykge1xuICAgICAga2xhc3MuX19maW5hbGl6ZWQgPSB0cnVlO1xuICAgICAgbGV0IHByb3RvID0gLyoqIEB0eXBlIFBvbHltZXJFbGVtZW50Q29uc3RydWN0b3IgKi8gKGtsYXNzKS5wcm90b3R5cGU7XG4gICAgICBpZiAoa2xhc3MuaGFzT3duUHJvcGVydHkoXG4gICAgICAgIEpTQ29tcGlsZXJfcmVuYW1lUHJvcGVydHkoJ2lzJywga2xhc3MpKSAmJiBrbGFzcy5pcykge1xuICAgICAgICBQb2x5bWVyLnRlbGVtZXRyeS5yZWdpc3Rlcihwcm90byk7XG4gICAgICB9XG4gICAgICBsZXQgcHJvcHMgPSBvd25Qcm9wZXJ0aWVzRm9yQ2xhc3Moa2xhc3MpO1xuICAgICAgaWYgKHByb3BzKSB7XG4gICAgICAgIGZpbmFsaXplUHJvcGVydGllcyhwcm90bywgcHJvcHMpO1xuICAgICAgfVxuICAgICAgbGV0IG9ic2VydmVycyA9IG93bk9ic2VydmVyc0ZvckNsYXNzKGtsYXNzKTtcbiAgICAgIGlmIChvYnNlcnZlcnMpIHtcbiAgICAgICAgZmluYWxpemVPYnNlcnZlcnMocHJvdG8sIG9ic2VydmVycywgcHJvcHMpO1xuICAgICAgfVxuICAgICAgLy8gbm90ZTogY3JlYXRlIFwid29ya2luZ1wiIHRlbXBsYXRlIHRoYXQgaXMgZmluYWxpemVkIGF0IGluc3RhbmNlIHRpbWVcbiAgICAgIGxldCB0ZW1wbGF0ZSA9IC8qKiBAdHlwZSBQb2x5bWVyRWxlbWVudENvbnN0cnVjdG9yICovIChrbGFzcykudGVtcGxhdGU7XG4gICAgICBpZiAodGVtcGxhdGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0ZW1wbGF0ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBsZXQgdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJyk7XG4gICAgICAgICAgdC5pbm5lckhUTUwgPSB0ZW1wbGF0ZTtcbiAgICAgICAgICB0ZW1wbGF0ZSA9IHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGVtcGxhdGUgPSB0ZW1wbGF0ZS5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcHJvdG8uX3RlbXBsYXRlID0gdGVtcGxhdGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29uZmlndXJlcyBhIGBwcm90b2AgYmFzZWQgb24gYSBgcHJvcGVydGllc2Agb2JqZWN0LlxuICAgICAqIExldmVyYWdlcyBgUHJvcGVydHlFZmZlY3RzYCB0byBjcmVhdGUgcHJvcGVydHkgYWNjZXNzb3JzIGFuZCBlZmZlY3RzXG4gICAgICogc3VwcG9ydGluZywgb2JzZXJ2ZXJzLCByZWZsZWN0aW5nIHRvIGF0dHJpYnV0ZXMsIGNoYW5nZSBub3RpZmljYXRpb24sXG4gICAgICogY29tcHV0ZWQgcHJvcGVydGllcywgYW5kIHJlYWQgb25seSBwcm9wZXJ0aWVzLlxuICAgICAqIEBwYXJhbSB7UG9seW1lckVsZW1lbnR9IHByb3RvIEVsZW1lbnQgY2xhc3MgcHJvdG90eXBlIHRvIGFkZCBhY2Nlc3NvcnNcbiAgICAgKiAgICBhbmQgZWZmZWN0cyB0b1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wZXJ0aWVzIEZsYXR0ZW5lZCBiYWcgb2YgcHJvcGVydHkgZGVzY3JpcHRvcnMgZm9yXG4gICAgICogICAgdGhpcyBjbGFzc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmluYWxpemVQcm9wZXJ0aWVzKHByb3RvLCBwcm9wZXJ0aWVzKSB7XG4gICAgICBmb3IgKGxldCBwIGluIHByb3BlcnRpZXMpIHtcbiAgICAgICAgY3JlYXRlUHJvcGVydHlGcm9tQ29uZmlnKHByb3RvLCBwLCBwcm9wZXJ0aWVzW3BdLCBwcm9wZXJ0aWVzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb25maWd1cmVzIGEgYHByb3RvYCBiYXNlZCBvbiBhIGBvYnNlcnZlcnNgIGFycmF5LlxuICAgICAqIExldmVyYWdlcyBgUHJvcGVydHlFZmZlY3RzYCB0byBjcmVhdGUgb2JzZXJ2ZXJzLlxuICAgICAqIEBwYXJhbSB7UG9seW1lckVsZW1lbnR9IHByb3RvIEVsZW1lbnQgY2xhc3MgcHJvdG90eXBlIHRvIGFkZCBhY2Nlc3NvcnNcbiAgICAgKiAgIGFuZCBlZmZlY3RzIHRvXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9ic2VydmVycyBGbGF0dGVuZWQgYXJyYXkgb2Ygb2JzZXJ2ZXIgZGVzY3JpcHRvcnMgZm9yXG4gICAgICogICB0aGlzIGNsYXNzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGR5bmFtaWNGbnMgT2JqZWN0IGNvbnRhaW5pbmcga2V5cyBmb3IgYW55IHByb3BlcnRpZXNcbiAgICAgKiAgIHRoYXQgYXJlIGZ1bmN0aW9ucyBhbmQgc2hvdWxkIHRyaWdnZXIgdGhlIGVmZmVjdCB3aGVuIHRoZSBmdW5jdGlvblxuICAgICAqICAgcmVmZXJlbmNlIGlzIGNoYW5nZWRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbmFsaXplT2JzZXJ2ZXJzKHByb3RvLCBvYnNlcnZlcnMsIGR5bmFtaWNGbnMpIHtcbiAgICAgIGZvciAobGV0IGk9MDsgaSA8IG9ic2VydmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBwcm90by5fY3JlYXRlTWV0aG9kT2JzZXJ2ZXIob2JzZXJ2ZXJzW2ldLCBkeW5hbWljRm5zKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGVmZmVjdHMgZm9yIGEgcHJvcGVydHkuXG4gICAgICpcbiAgICAgKiBOb3RlLCBvbmNlIGEgcHJvcGVydHkgaGFzIGJlZW4gc2V0IHRvXG4gICAgICogYHJlYWRPbmx5YCwgYGNvbXB1dGVkYCwgYHJlZmxlY3RUb0F0dHJpYnV0ZWAsIG9yIGBub3RpZnlgXG4gICAgICogdGhlc2UgdmFsdWVzIG1heSBub3QgYmUgY2hhbmdlZC4gRm9yIGV4YW1wbGUsIGEgc3ViY2xhc3MgY2Fubm90XG4gICAgICogYWx0ZXIgdGhlc2Ugc2V0dGluZ3MuIEhvd2V2ZXIsIGFkZGl0aW9uYWwgYG9ic2VydmVyc2AgbWF5IGJlIGFkZGVkXG4gICAgICogYnkgc3ViY2xhc3Nlcy5cbiAgICAgKlxuICAgICAqIFRoZSBpbmZvIG9iamVjdCBzaG91bGQgbWF5IGNvbnRhaW4gcHJvcGVydHkgbWV0YWRhdGEgYXMgZm9sbG93czpcbiAgICAgKlxuICAgICAqICogYHR5cGVgOiB7ZnVuY3Rpb259IHR5cGUgdG8gd2hpY2ggYW4gYXR0cmlidXRlIG1hdGNoaW5nIHRoZSBwcm9wZXJ0eVxuICAgICAqIGlzIGRlc2VyaWFsaXplZC4gTm90ZSB0aGUgcHJvcGVydHkgaXMgY2FtZWwtY2FzZWQgZnJvbSBhIGRhc2gtY2FzZWRcbiAgICAgKiBhdHRyaWJ1dGUuIEZvciBleGFtcGxlLCAnZm9vLWJhcicgYXR0cmlidXRlIGlzIGRlcnNpYWxpemVkIHRvIGFcbiAgICAgKiBwcm9wZXJ0eSBuYW1lZCAnZm9vQmFyJy5cbiAgICAgKlxuICAgICAqICogYHJlYWRPbmx5YDoge2Jvb2xlYW59IGNyZWF0ZXMgYSByZWFkT25seSBwcm9wZXJ0eSBhbmRcbiAgICAgKiBtYWtlcyBhIHByaXZhdGUgc2V0dGVyIGZvciB0aGUgcHJpdmF0ZSBvZiB0aGUgZm9ybSAnX3NldEZvbycgZm9yIGFcbiAgICAgKiBwcm9wZXJ0eSAnZm9vJyxcbiAgICAgKlxuICAgICAqICogYGNvbXB1dGVkYDoge3N0cmluZ30gY3JlYXRlcyBhIGNvbXB1dGVkIHByb3BlcnR5LiBBIGNvbXB1dGVkIHByb3BlcnR5XG4gICAgICogYWxzbyBhdXRvbWF0aWNhbGx5IGlzIHNldCB0byBgcmVhZE9ubHk6IHRydWVgLiBUaGUgdmFsdWUgaXMgY2FsY3VsYXRlZFxuICAgICAqIGJ5IHJ1bm5pbmcgYSBtZXRob2QgYW5kIGFyZ3VtZW50cyBwYXJzZWQgZnJvbSB0aGUgZ2l2ZW4gc3RyaW5nLiBGb3JcbiAgICAgKiBleGFtcGxlICdjb21wdXRlKGZvbyknIHdpbGwgY29tcHV0ZSBhIGdpdmVuIHByb3BlcnR5IHdoZW4gdGhlXG4gICAgICogJ2ZvbycgcHJvcGVydHkgY2hhbmdlcyBieSBleGVjdXRpbmcgdGhlICdjb21wdXRlJyBtZXRob2QuIFRoaXMgbWV0aG9kXG4gICAgICogbXVzdCByZXR1cm4gdGhlIGNvbXB1dGVkIHZhbHVlLlxuICAgICAqXG4gICAgICogKiBgcmVmbGVjdFRvQXR0cml1dGVgOiB7Ym9vbGVhbn0gSWYgdHJ1ZSwgdGhlIHByb3BlcnR5IHZhbHVlIGlzIHJlZmxlY3RlZFxuICAgICAqIHRvIGFuIGF0dHJpYnV0ZSBvZiB0aGUgc2FtZSBuYW1lLiBOb3RlLCB0aGUgYXR0cmlidXRlIGlzIGRhc2gtY2FzZWRcbiAgICAgKiBzbyBhIHByb3BlcnR5IG5hbWVkICdmb29CYXInIGlzIHJlZmxlY3RlZCBhcyAnZm9vLWJhcicuXG4gICAgICpcbiAgICAgKiAqIGBub3RpZnlgOiB7Ym9vbGVhbn0gc2VuZHMgYSBub24tYnViYmxpbmcgbm90aWZpY2F0aW9uIGV2ZW50IHdoZW5cbiAgICAgKiB0aGUgcHJvcGVydHkgY2hhbmdlcy4gRm9yIGV4YW1wbGUsIGEgcHJvcGVydHkgbmFtZWQgJ2Zvbycgc2VuZHMgYW5cbiAgICAgKiBldmVudCBuYW1lZCAnZm9vLWNoYW5nZWQnIHdpdGggYGV2ZW50LmRldGFpbGAgc2V0IHRvIHRoZSB2YWx1ZSBvZlxuICAgICAqIHRoZSBwcm9wZXJ0eS5cbiAgICAgKlxuICAgICAqICogb2JzZXJ2ZXI6IHtzdHJpbmd9IG5hbWUgb2YgYSBtZXRob2QgdGhhdCBydW5zIHdoZW4gdGhlIHByb3BlcnR5XG4gICAgICogY2hhbmdlcy4gVGhlIGFyZ3VtZW50cyBvZiB0aGUgbWV0aG9kIGFyZSAodmFsdWUsIHByZXZpb3VzVmFsdWUpLlxuICAgICAqXG4gICAgICogTm90ZTogVXNlcnMgbWF5IHdhbnQgY29udHJvbCBvdmVyIG1vZGlmeWluZyBwcm9wZXJ0eVxuICAgICAqIGVmZmVjdHMgdmlhIHN1YmNsYXNzaW5nLiBGb3IgZXhhbXBsZSwgYSB1c2VyIG1pZ2h0IHdhbnQgdG8gbWFrZSBhXG4gICAgICogcmVmbGVjdFRvQXR0cmlidXRlIHByb3BlcnR5IG5vdCBkbyBzbyBpbiBhIHN1YmNsYXNzLiBXZSd2ZSBjaG9zZW4gdG9cbiAgICAgKiBkaXNhYmxlIHRoaXMgYmVjYXVzZSBpdCBsZWFkcyB0byBhZGRpdGlvbmFsIGNvbXBsaWNhdGlvbi5cbiAgICAgKiBGb3IgZXhhbXBsZSwgYSByZWFkT25seSBlZmZlY3QgZ2VuZXJhdGVzIGEgc3BlY2lhbCBzZXR0ZXIuIElmIGEgc3ViY2xhc3NcbiAgICAgKiBkaXNhYmxlcyB0aGUgZWZmZWN0LCB0aGUgc2V0dGVyIHdvdWxkIGZhaWwgdW5leHBlY3RlZGx5LlxuICAgICAqIEJhc2VkIG9uIGZlZWRiYWNrLCB3ZSBtYXkgd2FudCB0byB0cnkgdG8gbWFrZSBlZmZlY3RzIG1vcmUgbWFsbGVhYmxlXG4gICAgICogYW5kL29yIHByb3ZpZGUgYW4gYWR2YW5jZWQgYXBpIGZvciBtYW5pcHVsYXRpbmcgdGhlbS5cbiAgICAgKiBBbHNvIGNvbnNpZGVyIGFkZGluZyB3YXJuaW5ncyB3aGVuIGFuIGVmZmVjdCBjYW5ub3QgYmUgY2hhbmdlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UG9seW1lckVsZW1lbnR9IHByb3RvIEVsZW1lbnQgY2xhc3MgcHJvdG90eXBlIHRvIGFkZCBhY2Nlc3NvcnNcbiAgICAgKiAgIGFuZCBlZmZlY3RzIHRvXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgTmFtZSBvZiB0aGUgcHJvcGVydHkuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGluZm8gSW5mbyBvYmplY3QgZnJvbSB3aGljaCB0byBjcmVhdGUgcHJvcGVydHkgZWZmZWN0cy5cbiAgICAgKiBTdXBwb3J0ZWQga2V5czpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYWxsUHJvcHMgRmxhdHRlbmVkIG1hcCBvZiBhbGwgcHJvcGVydGllcyBkZWZpbmVkIGluIHRoaXNcbiAgICAgKiAgIGVsZW1lbnQgKGluY2x1ZGluZyBpbmhlcml0ZWQgcHJvcGVydGllcylcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVByb3BlcnR5RnJvbUNvbmZpZyhwcm90bywgbmFtZSwgaW5mbywgYWxsUHJvcHMpIHtcbiAgICAgIC8vIGNvbXB1dGVkIGZvcmNlcyByZWFkT25seS4uLlxuICAgICAgaWYgKGluZm8uY29tcHV0ZWQpIHtcbiAgICAgICAgaW5mby5yZWFkT25seSA9IHRydWU7XG4gICAgICB9XG4gICAgICAvLyBOb3RlLCBzaW5jZSBhbGwgY29tcHV0ZWQgcHJvcGVydGllcyBhcmUgcmVhZE9ubHksIHRoaXMgcHJldmVudHNcbiAgICAgIC8vIGFkZGluZyBhZGRpdGlvbmFsIGNvbXB1dGVkIHByb3BlcnR5IGVmZmVjdHMgKHdoaWNoIGxlYWRzIHRvIGEgY29uZnVzaW5nXG4gICAgICAvLyBzZXR1cCB3aGVyZSBtdWx0aXBsZSB0cmlnZ2VycyBmb3Igc2V0dGluZyBhIHByb3BlcnR5KVxuICAgICAgLy8gV2hpbGUgd2UgZG8gaGF2ZSBgaGFzQ29tcHV0ZWRFZmZlY3RgIHRoaXMgaXMgc2V0IG9uIHRoZSBwcm9wZXJ0eSdzXG4gICAgICAvLyBkZXBlbmRlbmNpZXMgcmF0aGVyIHRoYW4gaXRzZWxmLlxuICAgICAgaWYgKGluZm8uY29tcHV0ZWQgICYmICFwcm90by5faGFzUmVhZE9ubHlFZmZlY3QobmFtZSkpIHtcbiAgICAgICAgcHJvdG8uX2NyZWF0ZUNvbXB1dGVkUHJvcGVydHkobmFtZSwgaW5mby5jb21wdXRlZCwgYWxsUHJvcHMpO1xuICAgICAgfVxuICAgICAgaWYgKGluZm8ucmVhZE9ubHkgJiYgIXByb3RvLl9oYXNSZWFkT25seUVmZmVjdChuYW1lKSkge1xuICAgICAgICBwcm90by5fY3JlYXRlUmVhZE9ubHlQcm9wZXJ0eShuYW1lLCAhaW5mby5jb21wdXRlZCk7XG4gICAgICB9XG4gICAgICBpZiAoaW5mby5yZWZsZWN0VG9BdHRyaWJ1dGUgJiYgIXByb3RvLl9oYXNSZWZsZWN0RWZmZWN0KG5hbWUpKSB7XG4gICAgICAgIHByb3RvLl9jcmVhdGVSZWZsZWN0ZWRQcm9wZXJ0eShuYW1lKTtcbiAgICAgIH1cbiAgICAgIGlmIChpbmZvLm5vdGlmeSAmJiAhcHJvdG8uX2hhc05vdGlmeUVmZmVjdChuYW1lKSkge1xuICAgICAgICBwcm90by5fY3JlYXRlTm90aWZ5aW5nUHJvcGVydHkobmFtZSk7XG4gICAgICB9XG4gICAgICAvLyBhbHdheXMgYWRkIG9ic2VydmVyXG4gICAgICBpZiAoaW5mby5vYnNlcnZlcikge1xuICAgICAgICBwcm90by5fY3JlYXRlUHJvcGVydHlPYnNlcnZlcihuYW1lLCBpbmZvLm9ic2VydmVyLCBhbGxQcm9wc1tpbmZvLm9ic2VydmVyXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29uZmlndXJlcyBhbiBlbGVtZW50IGBwcm90b2AgdG8gZnVuY3Rpb24gd2l0aCBhIGdpdmVuIGB0ZW1wbGF0ZWAuXG4gICAgICogVGhlIGVsZW1lbnQgbmFtZSBgaXNgIGFuZCBleHRlbmRzIGBleHRgIG11c3QgYmUgc3BlY2lmaWVkIGZvciBTaGFkeUNTU1xuICAgICAqIHN0eWxlIHNjb3BpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BvbHltZXJFbGVtZW50fSBwcm90byBFbGVtZW50IGNsYXNzIHByb3RvdHlwZSB0byBhZGQgYWNjZXNzb3JzXG4gICAgICogICBhbmQgZWZmZWN0cyB0b1xuICAgICAqIEBwYXJhbSB7IUhUTUxUZW1wbGF0ZUVsZW1lbnR9IHRlbXBsYXRlIFRlbXBsYXRlIHRvIHByb2Nlc3MgYW5kIGJpbmRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYmFzZVVSSSBVUkwgYWdhaW5zdCB3aGljaCB0byByZXNvbHZlIHVybHMgaW5cbiAgICAgKiAgIHN0eWxlIGVsZW1lbnQgY3NzVGV4dFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpcyBUYWcgbmFtZSAob3IgdHlwZSBleHRlbnNpb24gbmFtZSkgZm9yIHRoaXMgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7c3RyaW5nPX0gZXh0IEZvciB0eXBlIGV4dGVuc2lvbnMsIHRoZSB0YWcgbmFtZSB0aGF0IHdhcyBleHRlbmRlZFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmluYWxpemVUZW1wbGF0ZShwcm90bywgdGVtcGxhdGUsIGJhc2VVUkksIGlzLCBleHQpIHtcbiAgICAgIC8vIHN1cHBvcnQgYGluY2x1ZGU9XCJtb2R1bGUtbmFtZVwiYFxuICAgICAgbGV0IGNzc1RleHQgPVxuICAgICAgICBQb2x5bWVyLlN0eWxlR2F0aGVyLmNzc0Zyb21UZW1wbGF0ZSh0ZW1wbGF0ZSwgYmFzZVVSSSkgK1xuICAgICAgICBQb2x5bWVyLlN0eWxlR2F0aGVyLmNzc0Zyb21Nb2R1bGVJbXBvcnRzKGlzKTtcbiAgICAgIGlmIChjc3NUZXh0KSB7XG4gICAgICAgIGxldCBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgICAgIHN0eWxlLnRleHRDb250ZW50ID0gY3NzVGV4dDtcbiAgICAgICAgdGVtcGxhdGUuY29udGVudC5pbnNlcnRCZWZvcmUoc3R5bGUsIHRlbXBsYXRlLmNvbnRlbnQuZmlyc3RDaGlsZCk7XG4gICAgICB9XG4gICAgICBpZiAod2luZG93LlNoYWR5Q1NTKSB7XG4gICAgICAgIHdpbmRvdy5TaGFkeUNTUy5wcmVwYXJlVGVtcGxhdGUodGVtcGxhdGUsIGlzLCBleHQpO1xuICAgICAgfVxuICAgICAgcHJvdG8uX2JpbmRUZW1wbGF0ZSh0ZW1wbGF0ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBvbHltZXJcbiAgICAgKiBAbWl4aW5DbGFzc1xuICAgICAqIEB1bnJlc3RyaWN0ZWRcbiAgICAgKiBAaW1wbGVtZW50cyB7UG9seW1lcl9FbGVtZW50TWl4aW59XG4gICAgICovXG4gICAgY2xhc3MgUG9seW1lckVsZW1lbnQgZXh0ZW5kcyBwb2x5bWVyRWxlbWVudEJhc2Uge1xuXG4gICAgICAvKipcbiAgICAgICAqIFN0YW5kYXJkIEN1c3RvbSBFbGVtZW50cyBWMSBBUEkuICBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiByZXR1cm5zXG4gICAgICAgKiBhIGxpc3Qgb2YgZGFzaC1jYXNlZCBhdHRyaWJ1dGVzIGJhc2VkIG9uIGEgZmxhdHRlbmluZyBvZiBhbGwgcHJvcGVydGllc1xuICAgICAgICogZGVjbGFyZWQgaW4gYHN0YXRpYyBnZXQgcHJvcGVydGllcygpYCBmb3IgdGhpcyBlbGVtZW50IGFuZCBhbnlcbiAgICAgICAqIHN1cGVyY2xhc3Nlcy5cbiAgICAgICAqXG4gICAgICAgKiBAcmV0dXJuIHtBcnJheX0gT2JzZXJ2ZWQgYXR0cmlidXRlIGxpc3RcbiAgICAgICAqL1xuICAgICAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgICAgIGlmICghdGhpcy5oYXNPd25Qcm9wZXJ0eShKU0NvbXBpbGVyX3JlbmFtZVByb3BlcnR5KCdfX29ic2VydmVkQXR0cmlidXRlcycsIHRoaXMpKSkge1xuICAgICAgICAgIGxldCBsaXN0ID0gW107XG4gICAgICAgICAgbGV0IHByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzRm9yQ2xhc3ModGhpcyk7XG4gICAgICAgICAgZm9yIChsZXQgcHJvcCBpbiBwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICBsaXN0LnB1c2goUG9seW1lci5DYXNlTWFwLmNhbWVsVG9EYXNoQ2FzZShwcm9wKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX19vYnNlcnZlZEF0dHJpYnV0ZXMgPSBsaXN0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9fb2JzZXJ2ZWRBdHRyaWJ1dGVzO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENhbGxlZCBhdXRvbWF0aWNhbGx5IHdoZW4gdGhlIGZpcnN0IGVsZW1lbnQgaW5zdGFuY2UgaXMgY3JlYXRlZCB0b1xuICAgICAgICogZW5zdXJlIHRoYXQgY2xhc3MgZmluYWxpemF0aW9uIHdvcmsgaGFzIGJlZW4gY29tcGxldGVkLlxuICAgICAgICogTWF5IGJlIGNhbGxlZCBieSB1c2VycyB0byBlYWdlcmx5IHBlcmZvcm0gY2xhc3MgZmluYWxpemF0aW9uIHdvcmtcbiAgICAgICAqIHByaW9yIHRvIHRoZSBjcmVhdGlvbiBvZiB0aGUgZmlyc3QgZWxlbWVudCBpbnN0YW5jZS5cbiAgICAgICAqXG4gICAgICAgKiBDbGFzcyBmaW5hbGl6YXRpb24gd29yayBnZW5lcmFsbHkgaW5jbHVkZXMgbWV0YS1wcm9ncmFtbWluZyBzdWNoIGFzXG4gICAgICAgKiBjcmVhdGluZyBwcm9wZXJ0eSBhY2Nlc3NvcnMgYW5kIGFueSBwcm9wZXJ0eSBlZmZlY3QgbWV0YWRhdGEgbmVlZGVkIGZvclxuICAgICAgICogdGhlIGZlYXR1cmVzIHVzZWQuXG4gICAgICAgKlxuICAgICAgICogQHB1YmxpY1xuICAgICAgICovXG4gICAgICBzdGF0aWMgZmluYWxpemUoKSB7XG4gICAgICAgIGlmICghaGFzQ2xhc3NGaW5hbGl6ZWQodGhpcykpIHtcbiAgICAgICAgICBmaW5hbGl6ZUNsYXNzQW5kU3VwZXIodGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZXR1cm5zIHRoZSB0ZW1wbGF0ZSB0aGF0IHdpbGwgYmUgc3RhbXBlZCBpbnRvIHRoaXMgZWxlbWVudCdzIHNoYWRvdyByb290LlxuICAgICAgICpcbiAgICAgICAqIElmIGEgYHN0YXRpYyBnZXQgaXMoKWAgZ2V0dGVyIGlzIGRlZmluZWQsIHRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uXG4gICAgICAgKiB3aWxsIHJldHVybiB0aGUgZmlyc3QgYDx0ZW1wbGF0ZT5gIGluIGEgYGRvbS1tb2R1bGVgIHdob3NlIGBpZGBcbiAgICAgICAqIG1hdGNoZXMgdGhpcyBlbGVtZW50J3MgYGlzYC5cbiAgICAgICAqXG4gICAgICAgKiBVc2VycyBtYXkgb3ZlcnJpZGUgdGhpcyBnZXR0ZXIgdG8gcmV0dXJuIGFuIGFyYml0cmFyeSB0ZW1wbGF0ZVxuICAgICAgICogKGluIHdoaWNoIGNhc2UgdGhlIGBpc2AgZ2V0dGVyIGlzIHVubmVjZXNzYXJ5KS4gVGhlIHRlbXBsYXRlIHJldHVybmVkXG4gICAgICAgKiBtYXkgYmUgZWl0aGVyIGFuIGBIVE1MVGVtcGxhdGVFbGVtZW50YCBvciBhIHN0cmluZyB0aGF0IHdpbGwgYmVcbiAgICAgICAqIGF1dG9tYXRpY2FsbHkgcGFyc2VkIGludG8gYSB0ZW1wbGF0ZS5cbiAgICAgICAqXG4gICAgICAgKiBOb3RlIHRoYXQgd2hlbiBzdWJjbGFzc2luZywgaWYgdGhlIHN1cGVyIGNsYXNzIG92ZXJyb2RlIHRoZSBkZWZhdWx0XG4gICAgICAgKiBpbXBsZW1lbnRhdGlvbiBhbmQgdGhlIHN1YmNsYXNzIHdvdWxkIGxpa2UgdG8gcHJvdmlkZSBhbiBhbHRlcm5hdGVcbiAgICAgICAqIHRlbXBsYXRlIHZpYSBhIGBkb20tbW9kdWxlYCwgaXQgc2hvdWxkIG92ZXJyaWRlIHRoaXMgZ2V0dGVyIGFuZFxuICAgICAgICogcmV0dXJuIGBQb2x5bWVyLkRvbU1vZHVsZS5pbXBvcnQodGhpcy5pcywgJ3RlbXBsYXRlJylgLlxuICAgICAgICpcbiAgICAgICAqIElmIGEgc3ViY2xhc3Mgd291bGQgbGlrZSB0byBtb2RpZnkgdGhlIHN1cGVyIGNsYXNzIHRlbXBsYXRlLCBpdCBzaG91bGRcbiAgICAgICAqIGNsb25lIGl0IHJhdGhlciB0aGFuIG1vZGlmeSBpdCBpbiBwbGFjZS4gIElmIHRoZSBnZXR0ZXIgZG9lcyBleHBlbnNpdmVcbiAgICAgICAqIHdvcmsgc3VjaCBhcyBjbG9uaW5nL21vZGlmeWluZyBhIHRlbXBsYXRlLCBpdCBzaG91bGQgbWVtb2l6ZSB0aGVcbiAgICAgICAqIHRlbXBsYXRlIGZvciBtYXhpbXVtIHBlcmZvcm1hbmNlOlxuICAgICAgICpcbiAgICAgICAqICAgbGV0IG1lbW9pemVkVGVtcGxhdGU7XG4gICAgICAgKiAgIGNsYXNzIE15U3ViQ2xhc3MgZXh0ZW5kcyBNeVN1cGVyQ2xhc3Mge1xuICAgICAgICogICAgIHN0YXRpYyBnZXQgdGVtcGxhdGUoKSB7XG4gICAgICAgKiAgICAgICBpZiAoIW1lbW9pemVkVGVtcGxhdGUpIHtcbiAgICAgICAqICAgICAgICAgbWVtb2l6ZWRUZW1wbGF0ZSA9IHN1cGVyLnRlbXBsYXRlLmNsb25lTm9kZSh0cnVlKTtcbiAgICAgICAqICAgICAgICAgbGV0IHN1YkNvbnRlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAqICAgICAgICAgc3ViQ29udGVudC50ZXh0Q29udGVudCA9ICdUaGlzIGNhbWUgZnJvbSBNeVN1YkNsYXNzJztcbiAgICAgICAqICAgICAgICAgbWVtb2l6ZWRUZW1wbGF0ZS5jb250ZW50LmFwcGVuZENoaWxkKHN1YkNvbnRlbnQpO1xuICAgICAgICogICAgICAgfVxuICAgICAgICogICAgICAgcmV0dXJuIG1lbW9pemVkVGVtcGxhdGU7XG4gICAgICAgKiAgICAgfVxuICAgICAgICogICB9XG4gICAgICAgKlxuICAgICAgICogQHJldHVybiB7SFRNTFRlbXBsYXRlRWxlbWVudHxzdHJpbmd9IFRlbXBsYXRlIHRvIGJlIHN0YW1wZWRcbiAgICAgICAqL1xuICAgICAgc3RhdGljIGdldCB0ZW1wbGF0ZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhc093blByb3BlcnR5KEpTQ29tcGlsZXJfcmVuYW1lUHJvcGVydHkoJ190ZW1wbGF0ZScsIHRoaXMpKSkge1xuICAgICAgICAgIHRoaXMuX3RlbXBsYXRlID0gUG9seW1lci5Eb21Nb2R1bGUgJiYgUG9seW1lci5Eb21Nb2R1bGUuaW1wb3J0KFxuICAgICAgICAgICAgLyoqIEB0eXBlIFBvbHltZXJFbGVtZW50Q29uc3RydWN0b3IqLyAodGhpcykuaXMsICd0ZW1wbGF0ZScpIHx8XG4gICAgICAgICAgICAvLyBub3RlOiBpbXBsZW1lbnRlZCBzbyBhIHN1YmNsYXNzIGNhbiByZXRyaWV2ZSB0aGUgc3VwZXJcbiAgICAgICAgICAgIC8vIHRlbXBsYXRlOyBjYWxsIHRoZSBzdXBlciBpbXBsIHRoaXMgd2F5IHNvIHRoYXQgYHRoaXNgIHBvaW50c1xuICAgICAgICAgICAgLy8gdG8gdGhlIHN1cGVyY2xhc3MuXG4gICAgICAgICAgICBPYmplY3QuZ2V0UHJvdG90eXBlT2YoLyoqIEB0eXBlIFBvbHltZXJFbGVtZW50Q29uc3RydWN0b3IqLyAodGhpcykucHJvdG90eXBlKS5jb25zdHJ1Y3Rvci50ZW1wbGF0ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fdGVtcGxhdGU7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUGF0aCBtYXRjaGluZyB0aGUgdXJsIGZyb20gd2hpY2ggdGhlIGVsZW1lbnQgd2FzIGltcG9ydGVkLlxuICAgICAgICogVGhpcyBwYXRoIGlzIHVzZWQgdG8gcmVzb2x2ZSB1cmwncyBpbiB0ZW1wbGF0ZSBzdHlsZSBjc3NUZXh0LlxuICAgICAgICogVGhlIGBpbXBvcnRQYXRoYCBwcm9wZXJ0eSBpcyBhbHNvIHNldCBvbiBlbGVtZW50IGluc3RhbmNlcyBhbmQgY2FuIGJlXG4gICAgICAgKiB1c2VkIHRvIGNyZWF0ZSBiaW5kaW5ncyByZWxhdGl2ZSB0byB0aGUgaW1wb3J0IHBhdGguXG4gICAgICAgKiBEZWZhdWx0cyB0byB0aGUgcGF0aCBtYXRjaGluZyB0aGUgdXJsIGNvbnRhaW5pbmcgYSBgZG9tLW1vZHVsZWAgZWxlbWVudFxuICAgICAgICogbWF0Y2hpbmcgdGhpcyBlbGVtZW50J3Mgc3RhdGljIGBpc2AgcHJvcGVydHkuXG4gICAgICAgKiBOb3RlLCB0aGlzIHBhdGggc2hvdWxkIGNvbnRhaW4gYSB0cmFpbGluZyBgL2AuXG4gICAgICAgKlxuICAgICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgaW1wb3J0IHBhdGggZm9yIHRoaXMgZWxlbWVudCBjbGFzc1xuICAgICAgICovXG4gICAgICBzdGF0aWMgZ2V0IGltcG9ydFBhdGgoKSB7XG4gICAgICAgIGlmICghdGhpcy5oYXNPd25Qcm9wZXJ0eShKU0NvbXBpbGVyX3JlbmFtZVByb3BlcnR5KCdfaW1wb3J0UGF0aCcsIHRoaXMpKSkge1xuICAgICAgICAgICAgY29uc3QgbW9kdWxlID0gUG9seW1lci5Eb21Nb2R1bGUgJiYgUG9seW1lci5Eb21Nb2R1bGUuaW1wb3J0KC8qKiBAdHlwZSBQb2x5bWVyRWxlbWVudENvbnN0cnVjdG9yICovICh0aGlzKS5pcyk7XG4gICAgICAgICAgICB0aGlzLl9pbXBvcnRQYXRoID0gbW9kdWxlID8gbW9kdWxlLmFzc2V0cGF0aCA6ICcnIHx8XG4gICAgICAgICAgICBPYmplY3QuZ2V0UHJvdG90eXBlT2YoLyoqIEB0eXBlIFBvbHltZXJFbGVtZW50Q29uc3RydWN0b3IqLyAodGhpcykucHJvdG90eXBlKS5jb25zdHJ1Y3Rvci5pbXBvcnRQYXRoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9pbXBvcnRQYXRoO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIE92ZXJyaWRlcyB0aGUgZGVmYXVsdCBgUG9seW1lci5Qcm9wZXJ0eUFjY2Vzc29yc2AgdG8gZW5zdXJlIGNsYXNzXG4gICAgICAgKiBtZXRhcHJvZ3JhbW1pbmcgcmVsYXRlZCB0byBwcm9wZXJ0eSBhY2Nlc3NvcnMgYW5kIGVmZmVjdHMgaGFzXG4gICAgICAgKiBjb21wbGV0ZWQgKGNhbGxzIGBmaW5hbGl6ZWApLlxuICAgICAgICpcbiAgICAgICAqIEl0IGFsc28gaW5pdGlhbGl6ZXMgYW55IHByb3BlcnR5IGRlZmF1bHRzIHByb3ZpZGVkIHZpYSBgdmFsdWVgIGluXG4gICAgICAgKiBgcHJvcGVydGllc2AgbWV0YWRhdGEuXG4gICAgICAgKlxuICAgICAgICogQG92ZXJyaWRlXG4gICAgICAgKiBAc3VwcHJlc3Mge2ludmFsaWRDYXN0c31cbiAgICAgICAqL1xuICAgICAgX2luaXRpYWxpemVQcm9wZXJ0aWVzKCkge1xuICAgICAgICBQb2x5bWVyLnRlbGVtZXRyeS5pbnN0YW5jZUNvdW50Kys7XG4gICAgICAgIHRoaXMuY29uc3RydWN0b3IuZmluYWxpemUoKTtcbiAgICAgICAgY29uc3QgaW1wb3J0UGF0aCA9IHRoaXMuY29uc3RydWN0b3IuaW1wb3J0UGF0aDtcbiAgICAgICAgLy8gbm90ZTogZmluYWxpemUgdGVtcGxhdGUgd2hlbiB3ZSBoYXZlIGFjY2VzcyB0byBgbG9jYWxOYW1lYCB0b1xuICAgICAgICAvLyBhdm9pZCBkZXBlbmRlbmNlIG9uIGBpc2AgZm9yIHBvbHlmaWxsaW5nIHN0eWxpbmcuXG4gICAgICAgIGlmICh0aGlzLl90ZW1wbGF0ZSAmJiAhdGhpcy5fdGVtcGxhdGUuX19wb2x5bWVyRmluYWxpemVkKSB7XG4gICAgICAgICAgdGhpcy5fdGVtcGxhdGUuX19wb2x5bWVyRmluYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgICBjb25zdCBiYXNlVVJJID1cbiAgICAgICAgICAgIGltcG9ydFBhdGggPyBQb2x5bWVyLlJlc29sdmVVcmwucmVzb2x2ZVVybChpbXBvcnRQYXRoKSA6ICcnO1xuICAgICAgICAgIGZpbmFsaXplVGVtcGxhdGUoLyoqIEB0eXBlIHshUG9seW1lckVsZW1lbnR9ICovKHRoaXMuX19wcm90b19fKSwgdGhpcy5fdGVtcGxhdGUsIGJhc2VVUkksXG4gICAgICAgICAgICAvKipAdHlwZSB7IUhUTUxFbGVtZW50fSovKHRoaXMpLmxvY2FsTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIuX2luaXRpYWxpemVQcm9wZXJ0aWVzKCk7XG4gICAgICAgIC8vIHNldCBwYXRoIGRlZmF1bHRzXG4gICAgICAgIHRoaXMucm9vdFBhdGggPSBQb2x5bWVyLnJvb3RQYXRoO1xuICAgICAgICB0aGlzLmltcG9ydFBhdGggPSBpbXBvcnRQYXRoO1xuICAgICAgICAvLyBhcHBseSBwcm9wZXJ0eSBkZWZhdWx0cy4uLlxuICAgICAgICBsZXQgcCQgPSBwcm9wZXJ0eURlZmF1bHRzRm9yQ2xhc3ModGhpcy5jb25zdHJ1Y3Rvcik7XG4gICAgICAgIGlmICghcCQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgcCBpbiBwJCkge1xuICAgICAgICAgIGxldCBpbmZvID0gcCRbcF07XG4gICAgICAgICAgLy8gRG9uJ3Qgc2V0IGRlZmF1bHQgdmFsdWUgaWYgdGhlcmUgaXMgYWxyZWFkeSBhbiBvd24gcHJvcGVydHksIHdoaWNoXG4gICAgICAgICAgLy8gaGFwcGVucyB3aGVuIGEgYHByb3BlcnRpZXNgIHByb3BlcnR5IHdpdGggZGVmYXVsdCBidXQgbm8gZWZmZWN0cyBoYWRcbiAgICAgICAgICAvLyBhIHByb3BlcnR5IHNldCAoZS5nLiBib3VuZCkgYnkgaXRzIGhvc3QgYmVmb3JlIHVwZ3JhZGVcbiAgICAgICAgICBpZiAoIXRoaXMuaGFzT3duUHJvcGVydHkocCkpIHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IHR5cGVvZiBpbmZvLnZhbHVlID09ICdmdW5jdGlvbicgP1xuICAgICAgICAgICAgICBpbmZvLnZhbHVlLmNhbGwodGhpcykgOlxuICAgICAgICAgICAgICBpbmZvLnZhbHVlO1xuICAgICAgICAgICAgLy8gU2V0IHZpYSBgX3NldFByb3BlcnR5YCBpZiB0aGVyZSBpcyBhbiBhY2Nlc3NvciwgdG8gZW5hYmxlXG4gICAgICAgICAgICAvLyBpbml0aWFsaXppbmcgcmVhZE9ubHkgcHJvcGVydHkgZGVmYXVsdHNcbiAgICAgICAgICAgIGlmICh0aGlzLl9oYXNBY2Nlc3NvcihwKSkge1xuICAgICAgICAgICAgICB0aGlzLl9zZXRQZW5kaW5nUHJvcGVydHkocCwgdmFsdWUsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpc1twXSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFByb3ZpZGVzIGEgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgc3RhbmRhcmQgQ3VzdG9tIEVsZW1lbnRzXG4gICAgICAgKiBgY29ubmVjdGVkQ2FsbGJhY2tgLlxuICAgICAgICpcbiAgICAgICAqIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIGVuYWJsZXMgdGhlIHByb3BlcnR5IGVmZmVjdHMgc3lzdGVtIGFuZFxuICAgICAgICogZmx1c2hlcyBhbnkgcGVuZGluZyBwcm9wZXJ0aWVzLCBhbmQgdXBkYXRlcyBzaGltbWVkIENTUyBwcm9wZXJ0aWVzXG4gICAgICAgKiB3aGVuIHVzaW5nIHRoZSBTaGFkeUNTUyBzY29waW5nL2N1c3RvbSBwcm9wZXJ0aWVzIHBvbHlmaWxsLlxuICAgICAgICpcbiAgICAgICAqIEBzdXBwcmVzcyB7aW52YWxpZENhc3RzfVxuICAgICAgICovXG4gICAgICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgICAgaWYgKHdpbmRvdy5TaGFkeUNTUyAmJiB0aGlzLl90ZW1wbGF0ZSkge1xuICAgICAgICAgIHdpbmRvdy5TaGFkeUNTUy5zdHlsZUVsZW1lbnQoLyoqIEB0eXBlIHshSFRNTEVsZW1lbnR9ICovKHRoaXMpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9lbmFibGVQcm9wZXJ0aWVzKCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUHJvdmlkZXMgYSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIG9mIHRoZSBzdGFuZGFyZCBDdXN0b20gRWxlbWVudHNcbiAgICAgICAqIGBkaXNjb25uZWN0ZWRDYWxsYmFja2AuXG4gICAgICAgKi9cbiAgICAgIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge31cblxuICAgICAgLyoqXG4gICAgICAgKiBTdGFtcHMgdGhlIGVsZW1lbnQgdGVtcGxhdGUuXG4gICAgICAgKlxuICAgICAgICogQG92ZXJyaWRlXG4gICAgICAgKi9cbiAgICAgIHJlYWR5KCkge1xuICAgICAgICBpZiAodGhpcy5fdGVtcGxhdGUpIHtcbiAgICAgICAgICB0aGlzLnJvb3QgPSB0aGlzLl9zdGFtcFRlbXBsYXRlKHRoaXMuX3RlbXBsYXRlKTtcbiAgICAgICAgICB0aGlzLiQgPSB0aGlzLnJvb3QuJDtcbiAgICAgICAgfVxuICAgICAgICBzdXBlci5yZWFkeSgpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEltcGxlbWVudHMgYFByb3BlcnR5RWZmZWN0c2AncyBgX3JlYWR5Q2xpZW50c2AgY2FsbC4gQXR0YWNoZXNcbiAgICAgICAqIGVsZW1lbnQgZG9tIGJ5IGNhbGxpbmcgYF9hdHRhY2hEb21gIHdpdGggdGhlIGRvbSBzdGFtcGVkIGZyb20gdGhlXG4gICAgICAgKiBlbGVtZW50J3MgdGVtcGxhdGUgdmlhIGBfc3RhbXBUZW1wbGF0ZWAuIE5vdGUgdGhhdCB0aGlzIGFsbG93c1xuICAgICAgICogY2xpZW50IGRvbSB0byBiZSBhdHRhY2hlZCB0byB0aGUgZWxlbWVudCBwcmlvciB0byBhbnkgb2JzZXJ2ZXJzXG4gICAgICAgKiBydW5uaW5nLlxuICAgICAgICpcbiAgICAgICAqIEBvdmVycmlkZVxuICAgICAgICovXG4gICAgICBfcmVhZHlDbGllbnRzKCkge1xuICAgICAgICBpZiAodGhpcy5fdGVtcGxhdGUpIHtcbiAgICAgICAgICB0aGlzLnJvb3QgPSB0aGlzLl9hdHRhY2hEb20odGhpcy5yb290KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGUgc3VwZXIuX3JlYWR5Q2xpZW50cyBoZXJlIHNldHMgdGhlIGNsaWVudHMgaW5pdGlhbGl6ZWQgZmxhZy5cbiAgICAgICAgLy8gV2UgbXVzdCB3YWl0IHRvIGRvIHRoaXMgdW50aWwgYWZ0ZXIgY2xpZW50IGRvbSBpcyBjcmVhdGVkL2F0dGFjaGVkXG4gICAgICAgIC8vIHNvIHRoYXQgdGhpcyBmbGFnIGNhbiBiZSBjaGVja2VkIHRvIHByZXZlbnQgbm90aWZpY2F0aW9ucyBmaXJlZFxuICAgICAgICAvLyBkdXJpbmcgdGhpcyBwcm9jZXNzIGZyb20gYmVpbmcgaGFuZGxlZCBiZWZvcmUgY2xpZW50cyBhcmUgcmVhZHkuXG4gICAgICAgIHN1cGVyLl9yZWFkeUNsaWVudHMoKTtcbiAgICAgIH1cblxuXG4gICAgICAvKipcbiAgICAgICAqIEF0dGFjaGVzIGFuIGVsZW1lbnQncyBzdGFtcGVkIGRvbSB0byBpdHNlbGYuIEJ5IGRlZmF1bHQsXG4gICAgICAgKiB0aGlzIG1ldGhvZCBjcmVhdGVzIGEgYHNoYWRvd1Jvb3RgIGFuZCBhZGRzIHRoZSBkb20gdG8gaXQuXG4gICAgICAgKiBIb3dldmVyLCB0aGlzIG1ldGhvZCBtYXkgYmUgb3ZlcnJpZGRlbiB0byBhbGxvdyBhbiBlbGVtZW50XG4gICAgICAgKiB0byBwdXQgaXRzIGRvbSBpbiBhbm90aGVyIGxvY2F0aW9uLlxuICAgICAgICpcbiAgICAgICAqIEB0aHJvd3Mge0Vycm9yfVxuICAgICAgICogQHN1cHByZXNzIHttaXNzaW5nUmV0dXJufVxuICAgICAgICogQHBhcmFtIHtOb2RlTGlzdH0gZG9tIHRvIGF0dGFjaCB0byB0aGUgZWxlbWVudC5cbiAgICAgICAqIEByZXR1cm4ge05vZGV9IG5vZGUgdG8gd2hpY2ggdGhlIGRvbSBoYXMgYmVlbiBhdHRhY2hlZC5cbiAgICAgICAqL1xuICAgICAgX2F0dGFjaERvbShkb20pIHtcbiAgICAgICAgaWYgKHRoaXMuYXR0YWNoU2hhZG93KSB7XG4gICAgICAgICAgaWYgKGRvbSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnNoYWRvd1Jvb3QpIHtcbiAgICAgICAgICAgICAgdGhpcy5hdHRhY2hTaGFkb3coe21vZGU6ICdvcGVuJ30pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zaGFkb3dSb290LmFwcGVuZENoaWxkKGRvbSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zaGFkb3dSb290O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NoYWRvd0RPTSBub3QgYXZhaWxhYmxlLiAnICtcbiAgICAgICAgICAgIC8vIFRPRE8oc29ydmVsbCk6IG1vdmUgdG8gY29tcGlsZS10aW1lIGNvbmRpdGlvbmFsIHdoZW4gc3VwcG9ydGVkXG4gICAgICAgICAgJ1BvbHltZXIuRWxlbWVudCBjYW4gY3JlYXRlIGRvbSBhcyBjaGlsZHJlbiBpbnN0ZWFkIG9mIGluICcgK1xuICAgICAgICAgICdTaGFkb3dET00gYnkgc2V0dGluZyBgdGhpcy5yb290ID0gdGhpcztcXGAgYmVmb3JlIFxcYHJlYWR5XFxgLicpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUHJvdmlkZXMgYSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIG9mIHRoZSBzdGFuZGFyZCBDdXN0b20gRWxlbWVudHNcbiAgICAgICAqIGBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2tgLlxuICAgICAgICpcbiAgICAgICAqIEJ5IGRlZmF1bHQsIGF0dHJpYnV0ZXMgZGVjbGFyZWQgaW4gYHByb3BlcnRpZXNgIG1ldGFkYXRhIGFyZVxuICAgICAgICogZGVzZXJpYWxpemVkIHVzaW5nIHRoZWlyIGB0eXBlYCBpbmZvcm1hdGlvbiB0byBwcm9wZXJ0aWVzIG9mIHRoZVxuICAgICAgICogc2FtZSBuYW1lLiAgXCJEYXNoLWNhc2VkXCIgYXR0cmlidXRlcyBhcmUgZGVzZXJpYWx6ZWQgdG8gXCJjYW1lbENhc2VcIlxuICAgICAgICogcHJvcGVydGllcy5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBOYW1lIG9mIGF0dHJpYnV0ZS5cbiAgICAgICAqIEBwYXJhbSB7P3N0cmluZ30gb2xkIE9sZCB2YWx1ZSBvZiBhdHRyaWJ1dGUuXG4gICAgICAgKiBAcGFyYW0gez9zdHJpbmd9IHZhbHVlIEN1cnJlbnQgdmFsdWUgb2YgYXR0cmlidXRlLlxuICAgICAgICogQG92ZXJyaWRlXG4gICAgICAgKi9cbiAgICAgIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBvbGQsIHZhbHVlKSB7XG4gICAgICAgIGlmIChvbGQgIT09IHZhbHVlKSB7XG4gICAgICAgICAgbGV0IHByb3BlcnR5ID0gY2FzZU1hcC5kYXNoVG9DYW1lbENhc2UobmFtZSk7XG4gICAgICAgICAgbGV0IHR5cGUgPSBwcm9wZXJ0aWVzRm9yQ2xhc3ModGhpcy5jb25zdHJ1Y3RvcilbcHJvcGVydHldLnR5cGU7XG4gICAgICAgICAgaWYgKCF0aGlzLl9oYXNSZWFkT25seUVmZmVjdChwcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgIHRoaXMuX2F0dHJpYnV0ZVRvUHJvcGVydHkobmFtZSwgdmFsdWUsIHR5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFdoZW4gdXNpbmcgdGhlIFNoYWR5Q1NTIHNjb3BpbmcgYW5kIGN1c3RvbSBwcm9wZXJ0eSBzaGltLCBjYXVzZXMgYWxsXG4gICAgICAgKiBzaGltbWVkIHN0eWxlcyBpbiB0aGlzIGVsZW1lbnQgKGFuZCBpdHMgc3VidHJlZSkgdG8gYmUgdXBkYXRlZFxuICAgICAgICogYmFzZWQgb24gY3VycmVudCBjdXN0b20gcHJvcGVydHkgdmFsdWVzLlxuICAgICAgICpcbiAgICAgICAqIFRoZSBvcHRpb25hbCBwYXJhbWV0ZXIgb3ZlcnJpZGVzIGlubGluZSBjdXN0b20gcHJvcGVydHkgc3R5bGVzIHdpdGggYW5cbiAgICAgICAqIG9iamVjdCBvZiBwcm9wZXJ0aWVzIHdoZXJlIHRoZSBrZXlzIGFyZSBDU1MgcHJvcGVydGllcywgYW5kIHRoZSB2YWx1ZXNcbiAgICAgICAqIGFyZSBzdHJpbmdzLlxuICAgICAgICpcbiAgICAgICAqIEV4YW1wbGU6IGB0aGlzLnVwZGF0ZVN0eWxlcyh7Jy0tY29sb3InOiAnYmx1ZSd9KWBcbiAgICAgICAqXG4gICAgICAgKiBUaGVzZSBwcm9wZXJ0aWVzIGFyZSByZXRhaW5lZCB1bmxlc3MgYSB2YWx1ZSBvZiBgbnVsbGAgaXMgc2V0LlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0PX0gcHJvcGVydGllcyBCYWcgb2YgY3VzdG9tIHByb3BlcnR5IGtleS92YWx1ZXMgdG9cbiAgICAgICAqICAgYXBwbHkgdG8gdGhpcyBlbGVtZW50LlxuICAgICAgICogQHN1cHByZXNzIHtpbnZhbGlkQ2FzdHN9XG4gICAgICAgKi9cbiAgICAgIHVwZGF0ZVN0eWxlcyhwcm9wZXJ0aWVzKSB7XG4gICAgICAgIGlmICh3aW5kb3cuU2hhZHlDU1MpIHtcbiAgICAgICAgICB3aW5kb3cuU2hhZHlDU1Muc3R5bGVTdWJ0cmVlKC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqLyh0aGlzKSwgcHJvcGVydGllcyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZXdyaXRlcyBhIGdpdmVuIFVSTCByZWxhdGl2ZSB0byBhIGJhc2UgVVJMLiBUaGUgYmFzZSBVUkwgZGVmYXVsdHMgdG9cbiAgICAgICAqIHRoZSBvcmlnaW5hbCBsb2NhdGlvbiBvZiB0aGUgZG9jdW1lbnQgY29udGFpbmluZyB0aGUgYGRvbS1tb2R1bGVgIGZvclxuICAgICAgICogdGhpcyBlbGVtZW50LiBUaGlzIG1ldGhvZCB3aWxsIHJldHVybiB0aGUgc2FtZSBVUkwgYmVmb3JlIGFuZCBhZnRlclxuICAgICAgICogYnVuZGxpbmcuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHVybCBVUkwgdG8gcmVzb2x2ZS5cbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nPX0gYmFzZSBPcHRpb25hbCBiYXNlIFVSTCB0byByZXNvbHZlIGFnYWluc3QsIGRlZmF1bHRzXG4gICAgICAgKiB0byB0aGUgZWxlbWVudCdzIGBpbXBvcnRQYXRoYFxuICAgICAgICogQHJldHVybiB7c3RyaW5nfSBSZXdyaXR0ZW4gVVJMIHJlbGF0aXZlIHRvIGJhc2VcbiAgICAgICAqL1xuICAgICAgcmVzb2x2ZVVybCh1cmwsIGJhc2UpIHtcbiAgICAgICAgaWYgKCFiYXNlICYmIHRoaXMuaW1wb3J0UGF0aCkge1xuICAgICAgICAgIGJhc2UgPSBQb2x5bWVyLlJlc29sdmVVcmwucmVzb2x2ZVVybCh0aGlzLmltcG9ydFBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQb2x5bWVyLlJlc29sdmVVcmwucmVzb2x2ZVVybCh1cmwsIGJhc2UpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIE92ZXJyaWRlcyBgUHJvcGVydHlBY2Nlc3NvcnNgIHRvIGFkZCBtYXAgb2YgZHluYW1pYyBmdW5jdGlvbnMgb25cbiAgICAgICAqIHRlbXBsYXRlIGluZm8sIGZvciBjb25zdW1wdGlvbiBieSBgUHJvcGVydHlFZmZlY3RzYCB0ZW1wbGF0ZSBiaW5kaW5nXG4gICAgICAgKiBjb2RlLiBUaGlzIG1hcCBkZXRlcm1pbmVzIHdoaWNoIG1ldGhvZCB0ZW1wbGF0ZXMgc2hvdWxkIGhhdmUgYWNjZXNzb3JzXG4gICAgICAgKiBjcmVhdGVkIGZvciB0aGVtLlxuICAgICAgICpcbiAgICAgICAqIEBvdmVycmlkZVxuICAgICAgICogQHN1cHByZXNzIHttaXNzaW5nUHJvcGVydGllc30gSW50ZXJmYWNlcyBpbiBjbG9zdXJlIGRvIG5vdCBpbmhlcml0IHN0YXRpY3MsIGJ1dCBjbGFzc2VzIGRvXG4gICAgICAgKi9cbiAgICAgIHN0YXRpYyBfcGFyc2VUZW1wbGF0ZUNvbnRlbnQodGVtcGxhdGUsIHRlbXBsYXRlSW5mbywgbm9kZUluZm8pIHtcbiAgICAgICAgdGVtcGxhdGVJbmZvLmR5bmFtaWNGbnMgPSB0ZW1wbGF0ZUluZm8uZHluYW1pY0ZucyB8fCBwcm9wZXJ0aWVzRm9yQ2xhc3ModGhpcyk7XG4gICAgICAgIHJldHVybiBzdXBlci5fcGFyc2VUZW1wbGF0ZUNvbnRlbnQodGVtcGxhdGUsIHRlbXBsYXRlSW5mbywgbm9kZUluZm8pO1xuICAgICAgfVxuXG4gICAgfVxuXG4gICAgcmV0dXJuIFBvbHltZXJFbGVtZW50O1xuICB9KTtcblxuICAvKipcbiAgICogUHJvdmlkZXMgYmFzaWMgdHJhY2tpbmcgb2YgZWxlbWVudCBkZWZpbml0aW9ucyAocmVnaXN0cmF0aW9ucykgYW5kXG4gICAqIGluc3RhbmNlIGNvdW50cy5cbiAgICpcbiAgICogQG5hbWVzcGFjZVxuICAgKiBAc3VtbWFyeSBQcm92aWRlcyBiYXNpYyB0cmFja2luZyBvZiBlbGVtZW50IGRlZmluaXRpb25zIChyZWdpc3RyYXRpb25zKSBhbmRcbiAgICogaW5zdGFuY2UgY291bnRzLlxuICAgKi9cbiAgUG9seW1lci50ZWxlbWV0cnkgPSB7XG4gICAgLyoqXG4gICAgICogVG90YWwgbnVtYmVyIG9mIFBvbHltZXIgZWxlbWVudCBpbnN0YW5jZXMgY3JlYXRlZC5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIGluc3RhbmNlQ291bnQ6IDAsXG4gICAgLyoqXG4gICAgICogQXJyYXkgb2YgUG9seW1lciBlbGVtZW50IGNsYXNzZXMgdGhhdCBoYXZlIGJlZW4gZmluYWxpemVkLlxuICAgICAqIEB0eXBlIHtBcnJheTxQb2x5bWVyLkVsZW1lbnQ+fVxuICAgICAqL1xuICAgIHJlZ2lzdHJhdGlvbnM6IFtdLFxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IVBvbHltZXJFbGVtZW50Q29uc3RydWN0b3J9IHByb3RvdHlwZSBFbGVtZW50IHByb3RvdHlwZSB0byBsb2dcbiAgICAgKiBAdGhpcyB7dGhpc31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZWdMb2c6IGZ1bmN0aW9uKHByb3RvdHlwZSkge1xuICAgICAgY29uc29sZS5sb2coJ1snICsgcHJvdG90eXBlLmlzICsgJ106IHJlZ2lzdGVyZWQnKVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIGEgY2xhc3MgcHJvdG90eXBlIGZvciB0ZWxlbWV0cnkgcHVycG9zZXMuXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcHJvdG90eXBlIEVsZW1lbnQgcHJvdG90eXBlIHRvIHJlZ2lzdGVyXG4gICAgICogQHRoaXMge3RoaXN9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHJlZ2lzdGVyOiBmdW5jdGlvbihwcm90b3R5cGUpIHtcbiAgICAgIHRoaXMucmVnaXN0cmF0aW9ucy5wdXNoKHByb3RvdHlwZSk7XG4gICAgICBQb2x5bWVyLmxvZyAmJiB0aGlzLl9yZWdMb2cocHJvdG90eXBlKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIExvZ3MgYWxsIGVsZW1lbnRzIHJlZ2lzdGVyZWQgd2l0aCBhbiBgaXNgIHRvIHRoZSBjb25zb2xlLlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAdGhpcyB7dGhpc31cbiAgICAgKi9cbiAgICBkdW1wUmVnaXN0cmF0aW9uczogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnJlZ2lzdHJhdGlvbnMuZm9yRWFjaCh0aGlzLl9yZWdMb2cpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogV2hlbiB1c2luZyB0aGUgU2hhZHlDU1Mgc2NvcGluZyBhbmQgY3VzdG9tIHByb3BlcnR5IHNoaW0sIGNhdXNlcyBhbGxcbiAgICogc2hpbW1lZCBgc3R5bGVzYCAodmlhIGBjdXN0b20tc3R5bGVgKSBpbiB0aGUgZG9jdW1lbnQgKGFuZCBpdHMgc3VidHJlZSlcbiAgICogdG8gYmUgdXBkYXRlZCBiYXNlZCBvbiBjdXJyZW50IGN1c3RvbSBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAqXG4gICAqIFRoZSBvcHRpb25hbCBwYXJhbWV0ZXIgb3ZlcnJpZGVzIGlubGluZSBjdXN0b20gcHJvcGVydHkgc3R5bGVzIHdpdGggYW5cbiAgICogb2JqZWN0IG9mIHByb3BlcnRpZXMgd2hlcmUgdGhlIGtleXMgYXJlIENTUyBwcm9wZXJ0aWVzLCBhbmQgdGhlIHZhbHVlc1xuICAgKiBhcmUgc3RyaW5ncy5cbiAgICpcbiAgICogRXhhbXBsZTogYFBvbHltZXIudXBkYXRlU3R5bGVzKHsnLS1jb2xvcic6ICdibHVlJ30pYFxuICAgKlxuICAgKiBUaGVzZSBwcm9wZXJ0aWVzIGFyZSByZXRhaW5lZCB1bmxlc3MgYSB2YWx1ZSBvZiBgbnVsbGAgaXMgc2V0LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdD19IHByb3BzIEJhZyBvZiBjdXN0b20gcHJvcGVydHkga2V5L3ZhbHVlcyB0b1xuICAgKiAgIGFwcGx5IHRvIHRoZSBkb2N1bWVudC5cbiAgICovXG4gIFBvbHltZXIudXBkYXRlU3R5bGVzID0gZnVuY3Rpb24ocHJvcHMpIHtcbiAgICBpZiAod2luZG93LlNoYWR5Q1NTKSB7XG4gICAgICB3aW5kb3cuU2hhZHlDU1Muc3R5bGVEb2N1bWVudChwcm9wcyk7XG4gICAgfVxuICB9O1xuXG59KSgpO1xuPC9zY3JpcHQ+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL3BvbHltZXIvbGliL21peGlucy9lbGVtZW50LW1peGluLmh0bWwiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi91dGlscy9ib290Lmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi91dGlscy9yZXNvbHZlLXVybC5odG1sXCI+XG5cbjxzY3JpcHQ+XG4vKiogQHN1cHByZXNzIHtkZXByZWNhdGVkfSAqL1xuKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLyoqXG4gICAqIExlZ2FjeSBzZXR0aW5ncy5cbiAgICogQG5hbWVzcGFjZVxuICAgKiBAbWVtYmVyb2YgUG9seW1lclxuICAgKi9cbiAgY29uc3Qgc2V0dGluZ3MgPSBQb2x5bWVyLlNldHRpbmdzIHx8IHt9O1xuICBzZXR0aW5ncy51c2VTaGFkb3cgPSAhKHdpbmRvdy5TaGFkeURPTSk7XG4gIHNldHRpbmdzLnVzZU5hdGl2ZUNTU1Byb3BlcnRpZXMgPVxuICAgIEJvb2xlYW4oIXdpbmRvdy5TaGFkeUNTUyB8fCB3aW5kb3cuU2hhZHlDU1MubmF0aXZlQ3NzKTtcbiAgc2V0dGluZ3MudXNlTmF0aXZlQ3VzdG9tRWxlbWVudHMgPVxuICAgICEod2luZG93LmN1c3RvbUVsZW1lbnRzLnBvbHlmaWxsV3JhcEZsdXNoQ2FsbGJhY2spO1xuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBnbG9iYWwsIGxlZ2FjeSBzZXR0aW5ncy5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWRcbiAgICogQG1lbWJlcm9mIFBvbHltZXJcbiAgICovXG4gIFBvbHltZXIuU2V0dGluZ3MgPSBzZXR0aW5ncztcblxuICAvKipcbiAgICogR2xvYmFsbHkgc2V0dGFibGUgcHJvcGVydHkgdGhhdCBpcyBhdXRvbWF0aWNhbGx5IGFzc2lnbmVkIHRvXG4gICAqIGBQb2x5bWVyLkVsZW1lbnRNaXhpbmAgaW5zdGFuY2VzLCB1c2VmdWwgZm9yIGJpbmRpbmcgaW4gdGVtcGxhdGVzIHRvXG4gICAqIG1ha2UgVVJMJ3MgcmVsYXRpdmUgdG8gYW4gYXBwbGljYXRpb24ncyByb290LiAgRGVmYXVsdHMgdG8gdGhlIG1haW5cbiAgICogZG9jdW1lbnQgVVJMLCBidXQgY2FuIGJlIG92ZXJyaWRkZW4gYnkgdXNlcnMuICBJdCBtYXkgYmUgdXNlZnVsIHRvIHNldFxuICAgKiBgUG9seW1lci5yb290UGF0aGAgdG8gcHJvdmlkZSBhIHN0YWJsZSBhcHBsaWNhdGlvbiBtb3VudCBwYXRoIHdoZW5cbiAgICogdXNpbmcgY2xpZW50IHNpZGUgcm91dGluZy5cbiAgICpcbiAgICogQG1lbWJlcm9mIFBvbHltZXJcbiAgICovXG4gIGxldCByb290UGF0aCA9IFBvbHltZXIucm9vdFBhdGggfHxcbiAgICBQb2x5bWVyLlJlc29sdmVVcmwucGF0aEZyb21VcmwoZG9jdW1lbnQuYmFzZVVSSSB8fCB3aW5kb3cubG9jYXRpb24uaHJlZik7XG5cbiAgUG9seW1lci5yb290UGF0aCA9IHJvb3RQYXRoO1xuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBnbG9iYWwgcm9vdFBhdGggcHJvcGVydHkgdXNlZCBieSBgUG9seW1lci5FbGVtZW50TWl4aW5gIGFuZFxuICAgKiBhdmFpbGFibGUgdmlhIGBQb2x5bWVyLnJvb3RQYXRoYC5cbiAgICpcbiAgICogQG1lbWJlcm9mIFBvbHltZXJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggVGhlIG5ldyByb290IHBhdGhcbiAgICovXG4gIFBvbHltZXIuc2V0Um9vdFBhdGggPSBmdW5jdGlvbihwYXRoKSB7XG4gICAgUG9seW1lci5yb290UGF0aCA9IHBhdGg7XG4gIH1cbn0pKCk7XG48L3NjcmlwdD5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL3BvbHltZXIvbGliL3V0aWxzL3NldHRpbmdzLmh0bWwiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwicmVzb2x2ZS11cmwuaHRtbFwiPlxuPHNjcmlwdD5cbihmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIGNvbnN0IE1PRFVMRV9TVFlMRV9MSU5LX1NFTEVDVE9SID0gJ2xpbmtbcmVsPWltcG9ydF1bdHlwZX49Y3NzXSc7XG4gIGNvbnN0IElOQ0xVREVfQVRUUiA9ICdpbmNsdWRlJztcblxuICBmdW5jdGlvbiBpbXBvcnRNb2R1bGUobW9kdWxlSWQpIHtcbiAgICBpZiAoIVBvbHltZXIuRG9tTW9kdWxlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIFBvbHltZXIuRG9tTW9kdWxlLmltcG9ydChtb2R1bGVJZCk7XG4gIH1cblxuICAvKiogQHR5cGVkZWYge3thc3NldHBhdGg6IHN0cmluZ319ICovXG4gIGxldCB0ZW1wbGF0ZVdpdGhBc3NldFBhdGg7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblxuICAvKipcbiAgICogTW9kdWxlIHdpdGggdXRpbGl0aWVzIGZvciBjb2xsZWN0aW9uIENTUyB0ZXh0IGZyb20gYDx0ZW1wbGF0ZXM+YCwgZXh0ZXJuYWxcbiAgICogc3R5bGVzaGVldHMsIGFuZCBgZG9tLW1vZHVsZWBzLlxuICAgKlxuICAgKiBAbmFtZXNwYWNlXG4gICAqIEBtZW1iZXJvZiBQb2x5bWVyXG4gICAqIEBzdW1tYXJ5IE1vZHVsZSB3aXRoIHV0aWxpdGllcyBmb3IgY29sbGVjdGlvbiBDU1MgdGV4dCBmcm9tIHZhcmlvdXMgc291cmNlcy5cbiAgICovXG4gIGNvbnN0IFN0eWxlR2F0aGVyID0ge1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBDU1MgdGV4dCBvZiBzdHlsZXMgaW4gYSBzcGFjZS1zZXBhcmF0ZWQgbGlzdCBvZiBgZG9tLW1vZHVsZWBzLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIFBvbHltZXIuU3R5bGVHYXRoZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbW9kdWxlSWRzIExpc3Qgb2YgZG9tLW1vZHVsZSBpZCdzIHdpdGhpbiB3aGljaCB0b1xuICAgICAqIHNlYXJjaCBmb3IgY3NzLlxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gQ29uY2F0ZW5hdGVkIENTUyBjb250ZW50IGZyb20gc3BlY2lmaWVkIGBkb20tbW9kdWxlYHNcbiAgICAgKiBAdGhpcyB7U3R5bGVHYXRoZXJ9XG4gICAgICovXG4gICAgY3NzRnJvbU1vZHVsZXMobW9kdWxlSWRzKSB7XG4gICAgICBsZXQgbW9kdWxlcyA9IG1vZHVsZUlkcy50cmltKCkuc3BsaXQoJyAnKTtcbiAgICAgIGxldCBjc3NUZXh0ID0gJyc7XG4gICAgICBmb3IgKGxldCBpPTA7IGkgPCBtb2R1bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNzc1RleHQgKz0gdGhpcy5jc3NGcm9tTW9kdWxlKG1vZHVsZXNbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNzc1RleHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgQ1NTIHRleHQgb2Ygc3R5bGVzIGluIGEgZ2l2ZW4gYGRvbS1tb2R1bGVgLiAgQ1NTIGluIGEgYGRvbS1tb2R1bGVgXG4gICAgICogY2FuIGNvbWUgZWl0aGVyIGZyb20gYDxzdHlsZT5gcyB3aXRoaW4gdGhlIGZpcnN0IGA8dGVtcGxhdGU+YCwgb3IgZWxzZVxuICAgICAqIGZyb20gb25lIG9yIG1vcmUgYDxsaW5rIHJlbD1cImltcG9ydFwiIHR5cGU9XCJjc3NcIj5gIGxpbmtzIG91dHNpZGUgdGhlXG4gICAgICogdGVtcGxhdGUuXG4gICAgICpcbiAgICAgKiBBbnkgYDxzdHlsZXM+YCBwcm9jZXNzZWQgYXJlIHJlbW92ZWQgZnJvbSB0aGVpciBvcmlnaW5hbCBsb2NhdGlvbi5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBQb2x5bWVyLlN0eWxlR2F0aGVyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1vZHVsZUlkIGRvbS1tb2R1bGUgaWQgdG8gZ2F0aGVyIHN0eWxlcyBmcm9tXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBDb25jYXRlbmF0ZWQgQ1NTIGNvbnRlbnQgZnJvbSBzcGVjaWZpZWQgYGRvbS1tb2R1bGVgXG4gICAgICogQHRoaXMge1N0eWxlR2F0aGVyfVxuICAgICAqL1xuICAgIGNzc0Zyb21Nb2R1bGUobW9kdWxlSWQpIHtcbiAgICAgIGxldCBtID0gaW1wb3J0TW9kdWxlKG1vZHVsZUlkKTtcbiAgICAgIGlmIChtICYmIG0uX2Nzc1RleHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgY3NzVGV4dCA9ICcnO1xuICAgICAgICAvLyBpbmNsdWRlIGNzcyBmcm9tIHRoZSBmaXJzdCB0ZW1wbGF0ZSBpbiB0aGUgbW9kdWxlXG4gICAgICAgIGxldCB0ID0gbS5xdWVyeVNlbGVjdG9yKCd0ZW1wbGF0ZScpO1xuICAgICAgICBpZiAodCkge1xuICAgICAgICAgIGNzc1RleHQgKz0gdGhpcy5jc3NGcm9tVGVtcGxhdGUodCwgLyoqIEB0eXBlIHt0ZW1wbGF0ZVdpdGhBc3NldFBhdGggfSovKG0pLmFzc2V0cGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbW9kdWxlIGltcG9ydHM6IDxsaW5rIHJlbD1cImltcG9ydFwiIHR5cGU9XCJjc3NcIj5cbiAgICAgICAgY3NzVGV4dCArPSB0aGlzLmNzc0Zyb21Nb2R1bGVJbXBvcnRzKG1vZHVsZUlkKTtcbiAgICAgICAgbS5fY3NzVGV4dCA9IGNzc1RleHQgfHwgbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmICghbSkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0NvdWxkIG5vdCBmaW5kIHN0eWxlIGRhdGEgaW4gbW9kdWxlIG5hbWVkJywgbW9kdWxlSWQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG0gJiYgbS5fY3NzVGV4dCB8fCAnJztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBDU1MgdGV4dCBvZiBgPHN0eWxlcz5gIHdpdGhpbiBhIGdpdmVuIHRlbXBsYXRlLlxuICAgICAqXG4gICAgICogQW55IGA8c3R5bGVzPmAgcHJvY2Vzc2VkIGFyZSByZW1vdmVkIGZyb20gdGhlaXIgb3JpZ2luYWwgbG9jYXRpb24uXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgUG9seW1lci5TdHlsZUdhdGhlclxuICAgICAqIEBwYXJhbSB7SFRNTFRlbXBsYXRlRWxlbWVudH0gdGVtcGxhdGUgVGVtcGxhdGUgdG8gZ2F0aGVyIHN0eWxlcyBmcm9tXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGJhc2VVUkkgQmFzZSBVUkkgdG8gcmVzb2x2ZSB0aGUgVVJMIGFnYWluc3RcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IENvbmNhdGVuYXRlZCBDU1MgY29udGVudCBmcm9tIHNwZWNpZmllZCB0ZW1wbGF0ZVxuICAgICAqIEB0aGlzIHtTdHlsZUdhdGhlcn1cbiAgICAgKi9cbiAgICBjc3NGcm9tVGVtcGxhdGUodGVtcGxhdGUsIGJhc2VVUkkpIHtcbiAgICAgIGxldCBjc3NUZXh0ID0gJyc7XG4gICAgICAvLyBpZiBlbGVtZW50IGlzIGEgdGVtcGxhdGUsIGdldCBjb250ZW50IGZyb20gaXRzIC5jb250ZW50XG4gICAgICBsZXQgZSQgPSB0ZW1wbGF0ZS5jb250ZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ3N0eWxlJyk7XG4gICAgICBmb3IgKGxldCBpPTA7IGkgPCBlJC5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgZSA9IGUkW2ldO1xuICAgICAgICAvLyBzdXBwb3J0IHN0eWxlIHNoYXJpbmcgYnkgYWxsb3dpbmcgc3R5bGVzIHRvIFwiaW5jbHVkZVwiXG4gICAgICAgIC8vIG90aGVyIGRvbS1tb2R1bGVzIHRoYXQgY29udGFpbiBzdHlsaW5nXG4gICAgICAgIGxldCBpbmNsdWRlID0gZS5nZXRBdHRyaWJ1dGUoSU5DTFVERV9BVFRSKTtcbiAgICAgICAgaWYgKGluY2x1ZGUpIHtcbiAgICAgICAgICBjc3NUZXh0ICs9IHRoaXMuY3NzRnJvbU1vZHVsZXMoaW5jbHVkZSk7XG4gICAgICAgIH1cbiAgICAgICAgZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGUpO1xuICAgICAgICBjc3NUZXh0ICs9IGJhc2VVUkkgP1xuICAgICAgICAgIFBvbHltZXIuUmVzb2x2ZVVybC5yZXNvbHZlQ3NzKGUudGV4dENvbnRlbnQsIGJhc2VVUkkpIDogZS50ZXh0Q29udGVudDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjc3NUZXh0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIENTUyB0ZXh0IGZyb20gc3R5bHNoZWV0cyBsb2FkZWQgdmlhIGA8bGluayByZWw9XCJpbXBvcnRcIiB0eXBlPVwiY3NzXCI+YFxuICAgICAqIGxpbmtzIHdpdGhpbiB0aGUgc3BlY2lmaWVkIGBkb20tbW9kdWxlYC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBQb2x5bWVyLlN0eWxlR2F0aGVyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1vZHVsZUlkIElkIG9mIGBkb20tbW9kdWxlYCB0byBnYXRoZXIgQ1NTIGZyb21cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IENvbmNhdGVuYXRlZCBDU1MgY29udGVudCBmcm9tIGxpbmtzIGluIHNwZWNpZmllZCBgZG9tLW1vZHVsZWBcbiAgICAgKiBAdGhpcyB7U3R5bGVHYXRoZXJ9XG4gICAgICovXG4gICAgY3NzRnJvbU1vZHVsZUltcG9ydHMobW9kdWxlSWQpIHtcbiAgICAgIGxldCBjc3NUZXh0ID0gJyc7XG4gICAgICBsZXQgbSA9IGltcG9ydE1vZHVsZShtb2R1bGVJZCk7XG4gICAgICBpZiAoIW0pIHtcbiAgICAgICAgcmV0dXJuIGNzc1RleHQ7XG4gICAgICB9XG4gICAgICBsZXQgcCQgPSBtLnF1ZXJ5U2VsZWN0b3JBbGwoTU9EVUxFX1NUWUxFX0xJTktfU0VMRUNUT1IpO1xuICAgICAgZm9yIChsZXQgaT0wOyBpIDwgcCQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IHAgPSBwJFtpXTtcbiAgICAgICAgaWYgKHAuaW1wb3J0KSB7XG4gICAgICAgICAgbGV0IGltcG9ydERvYyA9IHAuaW1wb3J0O1xuICAgICAgICAgIC8vIE5PVEU6IHBvbHlmaWxsIGFmZm9yZGFuY2UuXG4gICAgICAgICAgLy8gdW5kZXIgdGhlIEhUTUxJbXBvcnRzIHBvbHlmaWxsLCB0aGVyZSB3aWxsIGJlIG5vICdib2R5JyxcbiAgICAgICAgICAvLyBidXQgdGhlIGltcG9ydCBwc2V1ZG8tZG9jIGNhbiBiZSB1c2VkIGRpcmVjdGx5LlxuICAgICAgICAgIGxldCBjb250YWluZXIgPSBpbXBvcnREb2MuYm9keSA/IGltcG9ydERvYy5ib2R5IDogaW1wb3J0RG9jO1xuICAgICAgICAgIGNzc1RleHQgKz1cbiAgICAgICAgICAgIFBvbHltZXIuUmVzb2x2ZVVybC5yZXNvbHZlQ3NzKGNvbnRhaW5lci50ZXh0Q29udGVudCxcbiAgICAgICAgICAgICAgaW1wb3J0RG9jLmJhc2VVUkkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gY3NzVGV4dDtcbiAgICB9XG4gIH07XG5cbiAgUG9seW1lci5TdHlsZUdhdGhlciA9IFN0eWxlR2F0aGVyO1xufSkoKTtcbjwvc2NyaXB0PlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi91dGlscy9zdHlsZS1nYXRoZXIuaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cblxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uLy4uLy4uL3NoYWR5Y3NzL2FwcGx5LXNoaW0uaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL21peGlucy9lbGVtZW50LW1peGluLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi9taXhpbnMvZ2VzdHVyZS1ldmVudC1saXN0ZW5lcnMuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3V0aWxzL21peGluLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi91dGlscy9pbXBvcnQtaHJlZi5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vdXRpbHMvcmVuZGVyLXN0YXR1cy5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vdXRpbHMvdW5yZXNvbHZlZC5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwicG9seW1lci5kb20uaHRtbFwiPlxuXG48c2NyaXB0PlxuKGZ1bmN0aW9uKCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICBsZXQgc3R5bGVJbnRlcmZhY2UgPSB3aW5kb3cuU2hhZHlDU1M7XG5cbiAgLyoqXG4gICAqIEVsZW1lbnQgY2xhc3MgbWl4aW4gdGhhdCBwcm92aWRlcyBQb2x5bWVyJ3MgXCJsZWdhY3lcIiBBUEkgaW50ZW5kZWQgdG8gYmVcbiAgICogYmFja3dhcmQtY29tcGF0aWJsZSB0byB0aGUgZ3JlYXRlc3QgZXh0ZW50IHBvc3NpYmxlIHdpdGggdGhlIEFQSVxuICAgKiBmb3VuZCBvbiB0aGUgUG9seW1lciAxLnggYFBvbHltZXIuQmFzZWAgcHJvdG90eXBlIGFwcGxpZWQgdG8gYWxsIGVsZW1lbnRzXG4gICAqIGRlZmluZWQgdXNpbmcgdGhlIGBQb2x5bWVyKHsuLi59KWAgZnVuY3Rpb24uXG4gICAqXG4gICAqIEBtaXhpbkZ1bmN0aW9uXG4gICAqIEBwb2x5bWVyXG4gICAqIEBhcHBsaWVzTWl4aW4gUG9seW1lci5FbGVtZW50TWl4aW5cbiAgICogQGFwcGxpZXNNaXhpbiBQb2x5bWVyLkdlc3R1cmVFdmVudExpc3RlbmVyc1xuICAgKiBAcHJvcGVydHkgaXNBdHRhY2hlZCB7Ym9vbGVhbn0gU2V0IHRvIGB0cnVlYCBpbiB0aGlzIGVsZW1lbnQnc1xuICAgKiAgIGBjb25uZWN0ZWRDYWxsYmFja2AgYW5kIGBmYWxzZWAgaW4gYGRpc2Nvbm5lY3RlZENhbGxiYWNrYFxuICAgKiBAbWVtYmVyb2YgUG9seW1lclxuICAgKiBAc3VtbWFyeSBFbGVtZW50IGNsYXNzIG1peGluIHRoYXQgcHJvdmlkZXMgUG9seW1lcidzIFwibGVnYWN5XCIgQVBJXG4gICAqL1xuICBQb2x5bWVyLkxlZ2FjeUVsZW1lbnRNaXhpbiA9IFBvbHltZXIuZGVkdXBpbmdNaXhpbigoYmFzZSkgPT4ge1xuXG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQGV4dGVuZHMge2Jhc2V9XG4gICAgICogQGltcGxlbWVudHMge1BvbHltZXJfRWxlbWVudE1peGlufVxuICAgICAqIEBpbXBsZW1lbnRzIHtQb2x5bWVyX0dlc3R1cmVFdmVudExpc3RlbmVyc31cbiAgICAgKi9cbiAgICBjb25zdCBsZWdhY3lFbGVtZW50QmFzZSA9IFBvbHltZXIuR2VzdHVyZUV2ZW50TGlzdGVuZXJzKFBvbHltZXIuRWxlbWVudE1peGluKGJhc2UpKTtcblxuICAgIC8qKlxuICAgICAqIE1hcCBvZiBzaW1wbGUgbmFtZXMgdG8gdG91Y2ggYWN0aW9uIG5hbWVzXG4gICAgICogQGRpY3RcbiAgICAgKi9cbiAgICBjb25zdCBESVJFQ1RJT05fTUFQID0ge1xuICAgICAgJ3gnOiAncGFuLXgnLFxuICAgICAgJ3knOiAncGFuLXknLFxuICAgICAgJ25vbmUnOiAnbm9uZScsXG4gICAgICAnYWxsJzogJ2F1dG8nXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBwb2x5bWVyXG4gICAgICogQG1peGluQ2xhc3NcbiAgICAgKiBAZXh0ZW5kcyB7bGVnYWN5RWxlbWVudEJhc2V9XG4gICAgICogQGltcGxlbWVudHMge1BvbHltZXJfTGVnYWN5RWxlbWVudE1peGlufVxuICAgICAqIEB1bnJlc3RyaWN0ZWRcbiAgICAgKi9cbiAgICBjbGFzcyBMZWdhY3lFbGVtZW50IGV4dGVuZHMgbGVnYWN5RWxlbWVudEJhc2Uge1xuXG4gICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5yb290ID0gdGhpcztcbiAgICAgICAgdGhpcy5jcmVhdGVkKCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogTGVnYWN5IGNhbGxiYWNrIGNhbGxlZCBkdXJpbmcgdGhlIGBjb25zdHJ1Y3RvcmAsIGZvciBvdmVycmlkaW5nXG4gICAgICAgKiBieSB0aGUgdXNlci5cbiAgICAgICAqL1xuICAgICAgY3JlYXRlZCgpIHt9XG5cbiAgICAgIC8qKlxuICAgICAgICogUHJvdmlkZXMgYW4gaW1wbGVtZW50YXRpb24gb2YgYGNvbm5lY3RlZENhbGxiYWNrYFxuICAgICAgICogd2hpY2ggYWRkcyBQb2x5bWVyIGxlZ2FjeSBBUEkncyBgYXR0YWNoZWRgIG1ldGhvZC5cbiAgICAgICAqIEBvdmVycmlkZVxuICAgICAgICovXG4gICAgICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgICAgc3VwZXIuY29ubmVjdGVkQ2FsbGJhY2soKTtcbiAgICAgICAgdGhpcy5pc0F0dGFjaGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5hdHRhY2hlZCgpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIExlZ2FjeSBjYWxsYmFjayBjYWxsZWQgZHVyaW5nIGBjb25uZWN0ZWRDYWxsYmFja2AsIGZvciBvdmVycmlkaW5nXG4gICAgICAgKiBieSB0aGUgdXNlci5cbiAgICAgICAqL1xuICAgICAgYXR0YWNoZWQoKSB7fVxuXG4gICAgICAvKipcbiAgICAgICAqIFByb3ZpZGVzIGFuIGltcGxlbWVudGF0aW9uIG9mIGBkaXNjb25uZWN0ZWRDYWxsYmFja2BcbiAgICAgICAqIHdoaWNoIGFkZHMgUG9seW1lciBsZWdhY3kgQVBJJ3MgYGRldGFjaGVkYCBtZXRob2QuXG4gICAgICAgKiBAb3ZlcnJpZGVcbiAgICAgICAqL1xuICAgICAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgICAgIHN1cGVyLmRpc2Nvbm5lY3RlZENhbGxiYWNrKCk7XG4gICAgICAgIHRoaXMuaXNBdHRhY2hlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRldGFjaGVkKCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogTGVnYWN5IGNhbGxiYWNrIGNhbGxlZCBkdXJpbmcgYGRpc2Nvbm5lY3RlZENhbGxiYWNrYCwgZm9yIG92ZXJyaWRpbmdcbiAgICAgICAqIGJ5IHRoZSB1c2VyLlxuICAgICAgICovXG4gICAgICBkZXRhY2hlZCgpIHt9XG5cbiAgICAgIC8qKlxuICAgICAgICogUHJvdmlkZXMgYW4gb3ZlcnJpZGUgaW1wbGVtZW50YXRpb24gb2YgYGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFja2BcbiAgICAgICAqIHdoaWNoIGFkZHMgdGhlIFBvbHltZXIgbGVnYWN5IEFQSSdzIGBhdHRyaWJ1dGVDaGFuZ2VkYCBtZXRob2QuXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBOYW1lIG9mIGF0dHJpYnV0ZS5cbiAgICAgICAqIEBwYXJhbSB7P3N0cmluZ30gb2xkIE9sZCB2YWx1ZSBvZiBhdHRyaWJ1dGUuXG4gICAgICAgKiBAcGFyYW0gez9zdHJpbmd9IHZhbHVlIEN1cnJlbnQgdmFsdWUgb2YgYXR0cmlidXRlLlxuICAgICAgICogQG92ZXJyaWRlXG4gICAgICAgKi9cbiAgICAgIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBvbGQsIHZhbHVlKSB7XG4gICAgICAgIGlmIChvbGQgIT09IHZhbHVlKSB7XG4gICAgICAgICAgc3VwZXIuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIG9sZCwgdmFsdWUpO1xuICAgICAgICAgIHRoaXMuYXR0cmlidXRlQ2hhbmdlZChuYW1lLCBvbGQsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIExlZ2FjeSBjYWxsYmFjayBjYWxsZWQgZHVyaW5nIGBhdHRyaWJ1dGVDaGFuZ2VkQ2hhbGxiYWNrYCwgZm9yIG92ZXJyaWRpbmdcbiAgICAgICAqIGJ5IHRoZSB1c2VyLlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgTmFtZSBvZiBhdHRyaWJ1dGUuXG4gICAgICAgKiBAcGFyYW0gez9zdHJpbmd9IG9sZCBPbGQgdmFsdWUgb2YgYXR0cmlidXRlLlxuICAgICAgICogQHBhcmFtIHs/c3RyaW5nfSB2YWx1ZSBDdXJyZW50IHZhbHVlIG9mIGF0dHJpYnV0ZS5cbiAgICAgICAqL1xuICAgICAgYXR0cmlidXRlQ2hhbmdlZChuYW1lLCBvbGQsIHZhbHVlKSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cbiAgICAgIC8qKlxuICAgICAgICogT3ZlcnJpZGVzIHRoZSBkZWZhdWx0IGBQb2x5bWVyLlByb3BlcnR5RWZmZWN0c2AgaW1wbGVtZW50YXRpb24gdG9cbiAgICAgICAqIGFkZCBzdXBwb3J0IGZvciBjbGFzcyBpbml0aWFsaXphdGlvbiB2aWEgdGhlIGBfcmVnaXN0ZXJlZGAgY2FsbGJhY2suXG4gICAgICAgKiBUaGlzIGlzIGNhbGxlZCBvbmx5IHdoZW4gdGhlIGZpcnN0IGluc3RhbmNlIG9mIHRoZSBlbGVtZW50IGlzIGNyZWF0ZWQuXG4gICAgICAgKlxuICAgICAgICogQG92ZXJyaWRlXG4gICAgICAgKi9cbiAgICAgIF9pbml0aWFsaXplUHJvcGVydGllcygpIHtcbiAgICAgICAgbGV0IHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpO1xuICAgICAgICBpZiAoIXByb3RvLmhhc093blByb3BlcnR5KCdfX2hhc1JlZ2lzdGVyRmluaXNoZWQnKSkge1xuICAgICAgICAgIHByb3RvLl9faGFzUmVnaXN0ZXJGaW5pc2hlZCA9IHRydWU7XG4gICAgICAgICAgdGhpcy5fcmVnaXN0ZXJlZCgpO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyLl9pbml0aWFsaXplUHJvcGVydGllcygpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENhbGxlZCBhdXRvbWF0aWNhbGx5IHdoZW4gYW4gZWxlbWVudCBpcyBpbml0aWFsaXppbmcuXG4gICAgICAgKiBVc2VycyBtYXkgb3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gcGVyZm9ybSBjbGFzcyByZWdpc3RyYXRpb24gdGltZVxuICAgICAgICogd29yay4gVGhlIGltcGxlbWVudGF0aW9uIHNob3VsZCBlbnN1cmUgdGhlIHdvcmsgaXMgcGVyZm9ybWVkXG4gICAgICAgKiBvbmx5IG9uY2UgZm9yIHRoZSBjbGFzcy5cbiAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAqL1xuICAgICAgX3JlZ2lzdGVyZWQoKSB7fVxuXG4gICAgICAvKipcbiAgICAgICAqIE92ZXJyaWRlcyB0aGUgZGVmYXVsdCBgUG9seW1lci5Qcm9wZXJ0eUVmZmVjdHNgIGltcGxlbWVudGF0aW9uIHRvXG4gICAgICAgKiBhZGQgc3VwcG9ydCBmb3IgaW5zdGFsbGluZyBgaG9zdEF0dHJpYnV0ZXNgIGFuZCBgbGlzdGVuZXJzYC5cbiAgICAgICAqXG4gICAgICAgKiBAb3ZlcnJpZGVcbiAgICAgICAqL1xuICAgICAgcmVhZHkoKSB7XG4gICAgICAgIHRoaXMuX2Vuc3VyZUF0dHJpYnV0ZXMoKTtcbiAgICAgICAgdGhpcy5fYXBwbHlMaXN0ZW5lcnMoKTtcbiAgICAgICAgc3VwZXIucmVhZHkoKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBFbnN1cmVzIGFuIGVsZW1lbnQgaGFzIHJlcXVpcmVkIGF0dHJpYnV0ZXMuIENhbGxlZCB3aGVuIHRoZSBlbGVtZW50XG4gICAgICAgKiBpcyBiZWluZyByZWFkaWVkIHZpYSBgcmVhZHlgLiBVc2VycyBzaG91bGQgb3ZlcnJpZGUgdG8gc2V0IHRoZVxuICAgICAgICogZWxlbWVudCdzIHJlcXVpcmVkIGF0dHJpYnV0ZXMuIFRoZSBpbXBsZW1lbnRhdGlvbiBzaG91bGQgYmUgc3VyZVxuICAgICAgICogdG8gY2hlY2sgYW5kIG5vdCBvdmVycmlkZSBleGlzdGluZyBhdHRyaWJ1dGVzIGFkZGVkIGJ5XG4gICAgICAgKiB0aGUgdXNlciBvZiB0aGUgZWxlbWVudC4gVHlwaWNhbGx5LCBzZXR0aW5nIGF0dHJpYnV0ZXMgc2hvdWxkIGJlIGxlZnRcbiAgICAgICAqIHRvIHRoZSBlbGVtZW50IHVzZXIgYW5kIG5vdCBkb25lIGhlcmU7IHJlYXNvbmFibGUgZXhjZXB0aW9ucyBpbmNsdWRlXG4gICAgICAgKiBzZXR0aW5nIGFyaWEgcm9sZXMgYW5kIGZvY3VzYWJpbGl0eS5cbiAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAqL1xuICAgICAgX2Vuc3VyZUF0dHJpYnV0ZXMoKSB7fVxuXG4gICAgICAvKipcbiAgICAgICAqIEFkZHMgZWxlbWVudCBldmVudCBsaXN0ZW5lcnMuIENhbGxlZCB3aGVuIHRoZSBlbGVtZW50XG4gICAgICAgKiBpcyBiZWluZyByZWFkaWVkIHZpYSBgcmVhZHlgLiBVc2VycyBzaG91bGQgb3ZlcnJpZGUgdG9cbiAgICAgICAqIGFkZCBhbnkgcmVxdWlyZWQgZWxlbWVudCBldmVudCBsaXN0ZW5lcnMuXG4gICAgICAgKiBJbiBwZXJmb3JtYW5jZSBjcml0aWNhbCBlbGVtZW50cywgdGhlIHdvcmsgZG9uZSBoZXJlIHNob3VsZCBiZSBrZXB0XG4gICAgICAgKiB0byBhIG1pbmltdW0gc2luY2UgaXQgaXMgZG9uZSBiZWZvcmUgdGhlIGVsZW1lbnQgaXMgcmVuZGVyZWQuIEluXG4gICAgICAgKiB0aGVzZSBlbGVtZW50cywgY29uc2lkZXIgYWRkaW5nIGxpc3RlbmVycyBhc3ljaHJvbm91c2x5IHNvIGFzIG5vdCB0b1xuICAgICAgICogYmxvY2sgcmVuZGVyLlxuICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICovXG4gICAgICBfYXBwbHlMaXN0ZW5lcnMoKSB7fVxuXG4gICAgICAvKipcbiAgICAgICAqIENvbnZlcnRzIGEgdHlwZWQgSmF2YVNjcmlwdCB2YWx1ZSB0byBhIHN0cmluZy5cbiAgICAgICAqXG4gICAgICAgKiBOb3RlIHRoaXMgbWV0aG9kIGlzIHByb3ZpZGVkIGFzIGJhY2t3YXJkLWNvbXBhdGlibGUgbGVnYWN5IEFQSVxuICAgICAgICogb25seS4gIEl0IGlzIG5vdCBkaXJlY3RseSBjYWxsZWQgYnkgYW55IFBvbHltZXIgZmVhdHVyZXMuIFRvIGN1c3RvbWl6ZVxuICAgICAgICogaG93IHByb3BlcnRpZXMgYXJlIHNlcmlhbGl6ZWQgdG8gYXR0cmlidXRlcyBmb3IgYXR0cmlidXRlIGJpbmRpbmdzIGFuZFxuICAgICAgICogYHJlZmxlY3RUb0F0dHJpYnV0ZTogdHJ1ZWAgcHJvcGVydGllcyBhcyB3ZWxsIGFzIHRoaXMgbWV0aG9kLCBvdmVycmlkZVxuICAgICAgICogdGhlIGBfc2VyaWFsaXplVmFsdWVgIG1ldGhvZCBwcm92aWRlZCBieSBgUG9seW1lci5Qcm9wZXJ0eUFjY2Vzc29yc2AuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byBkZXNlcmlhbGl6ZVxuICAgICAgICogQHJldHVybiB7c3RyaW5nIHwgdW5kZWZpbmVkfSBTZXJpYWxpemVkIHZhbHVlXG4gICAgICAgKi9cbiAgICAgIHNlcmlhbGl6ZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2VyaWFsaXplVmFsdWUodmFsdWUpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENvbnZlcnRzIGEgc3RyaW5nIHRvIGEgdHlwZWQgSmF2YVNjcmlwdCB2YWx1ZS5cbiAgICAgICAqXG4gICAgICAgKiBOb3RlIHRoaXMgbWV0aG9kIGlzIHByb3ZpZGVkIGFzIGJhY2t3YXJkLWNvbXBhdGlibGUgbGVnYWN5IEFQSVxuICAgICAgICogb25seS4gIEl0IGlzIG5vdCBkaXJlY3RseSBjYWxsZWQgYnkgYW55IFBvbHltZXIgZmVhdHVyZXMuICBUbyBjdXN0b21pemVcbiAgICAgICAqIGhvdyBhdHRyaWJ1dGVzIGFyZSBkZXNlcmlhbGl6ZWQgdG8gcHJvcGVydGllcyBmb3IgaW5cbiAgICAgICAqIGBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2tgLCBvdmVycmlkZSBgX2Rlc2VyaWFsaXplVmFsdWVgIG1ldGhvZFxuICAgICAgICogcHJvdmlkZWQgYnkgYFBvbHltZXIuUHJvcGVydHlBY2Nlc3NvcnNgLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSBTdHJpbmcgdG8gZGVzZXJpYWxpemVcbiAgICAgICAqIEBwYXJhbSB7Kn0gdHlwZSBUeXBlIHRvIGRlc2VyaWFsaXplIHRoZSBzdHJpbmcgdG9cbiAgICAgICAqIEByZXR1cm4geyp9IFJldHVybnMgdGhlIGRlc2VyaWFsaXplZCB2YWx1ZSBpbiB0aGUgYHR5cGVgIGdpdmVuLlxuICAgICAgICovXG4gICAgICBkZXNlcmlhbGl6ZSh2YWx1ZSwgdHlwZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVzZXJpYWxpemVWYWx1ZSh2YWx1ZSwgdHlwZSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogU2VyaWFsaXplcyBhIHByb3BlcnR5IHRvIGl0cyBhc3NvY2lhdGVkIGF0dHJpYnV0ZS5cbiAgICAgICAqXG4gICAgICAgKiBOb3RlIHRoaXMgbWV0aG9kIGlzIHByb3ZpZGVkIGFzIGJhY2t3YXJkLWNvbXBhdGlibGUgbGVnYWN5IEFQSVxuICAgICAgICogb25seS4gIEl0IGlzIG5vdCBkaXJlY3RseSBjYWxsZWQgYnkgYW55IFBvbHltZXIgZmVhdHVyZXMuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IG5hbWUgdG8gcmVmbGVjdC5cbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nPX0gYXR0cmlidXRlIEF0dHJpYnV0ZSBuYW1lIHRvIHJlZmxlY3QuXG4gICAgICAgKiBAcGFyYW0geyo9fSB2YWx1ZSBQcm9wZXJ0eSB2YWx1ZSB0byByZWZlY3QuXG4gICAgICAgKi9cbiAgICAgIHJlZmxlY3RQcm9wZXJ0eVRvQXR0cmlidXRlKHByb3BlcnR5LCBhdHRyaWJ1dGUsIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3Byb3BlcnR5VG9BdHRyaWJ1dGUocHJvcGVydHksIGF0dHJpYnV0ZSwgdmFsdWUpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFNldHMgYSB0eXBlZCB2YWx1ZSB0byBhbiBIVE1MIGF0dHJpYnV0ZSBvbiBhIG5vZGUuXG4gICAgICAgKlxuICAgICAgICogTm90ZSB0aGlzIG1ldGhvZCBpcyBwcm92aWRlZCBhcyBiYWNrd2FyZC1jb21wYXRpYmxlIGxlZ2FjeSBBUElcbiAgICAgICAqIG9ubHkuICBJdCBpcyBub3QgZGlyZWN0bHkgY2FsbGVkIGJ5IGFueSBQb2x5bWVyIGZlYXR1cmVzLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgdG8gc2VyaWFsaXplLlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGF0dHJpYnV0ZSBBdHRyaWJ1dGUgbmFtZSB0byBzZXJpYWxpemUgdG8uXG4gICAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgRWxlbWVudCB0byBzZXQgYXR0cmlidXRlIHRvLlxuICAgICAgICovXG4gICAgICBzZXJpYWxpemVWYWx1ZVRvQXR0cmlidXRlKHZhbHVlLCBhdHRyaWJ1dGUsIG5vZGUpIHtcbiAgICAgICAgdGhpcy5fdmFsdWVUb05vZGVBdHRyaWJ1dGUoLyoqIEB0eXBlIHtFbGVtZW50fSAqLyAobm9kZSB8fCB0aGlzKSwgdmFsdWUsIGF0dHJpYnV0ZSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ29waWVzIG93biBwcm9wZXJ0aWVzIChpbmNsdWRpbmcgYWNjZXNzb3IgZGVzY3JpcHRvcnMpIGZyb20gYSBzb3VyY2VcbiAgICAgICAqIG9iamVjdCB0byBhIHRhcmdldCBvYmplY3QuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IHByb3RvdHlwZSBUYXJnZXQgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyB0by5cbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhcGkgU291cmNlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgZnJvbS5cbiAgICAgICAqIEByZXR1cm4ge09iamVjdH0gcHJvdG90eXBlIG9iamVjdCB0aGF0IHdhcyBwYXNzZWQgYXMgZmlyc3QgYXJndW1lbnQuXG4gICAgICAgKi9cbiAgICAgIGV4dGVuZChwcm90b3R5cGUsIGFwaSkge1xuICAgICAgICBpZiAoIShwcm90b3R5cGUgJiYgYXBpKSkge1xuICAgICAgICAgIHJldHVybiBwcm90b3R5cGUgfHwgYXBpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBuJCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGFwaSk7XG4gICAgICAgIGZvciAobGV0IGk9MCwgbjsgKGk8biQubGVuZ3RoKSAmJiAobj1uJFtpXSk7IGkrKykge1xuICAgICAgICAgIGxldCBwZCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYXBpLCBuKTtcbiAgICAgICAgICBpZiAocGQpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90b3R5cGUsIG4sIHBkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb3RvdHlwZTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDb3BpZXMgcHJvcHMgZnJvbSBhIHNvdXJjZSBvYmplY3QgdG8gYSB0YXJnZXQgb2JqZWN0LlxuICAgICAgICpcbiAgICAgICAqIE5vdGUsIHRoaXMgbWV0aG9kIHVzZXMgYSBzaW1wbGUgYGZvci4uLmluYCBzdHJhdGVneSBmb3IgZW51bWVyYXRpbmdcbiAgICAgICAqIHByb3BlcnRpZXMuICBUbyBlbnN1cmUgb25seSBgb3duUHJvcGVydGllc2AgYXJlIGNvcGllZCBmcm9tIHNvdXJjZVxuICAgICAgICogdG8gdGFyZ2V0IGFuZCB0aGF0IGFjY2Vzc29yIGltcGxlbWVudGF0aW9ucyBhcmUgY29waWVkLCB1c2UgYGV4dGVuZGAuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBUYXJnZXQgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyB0by5cbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgU291cmNlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgZnJvbS5cbiAgICAgICAqIEByZXR1cm4ge09iamVjdH0gVGFyZ2V0IG9iamVjdCB0aGF0IHdhcyBwYXNzZWQgYXMgZmlyc3QgYXJndW1lbnQuXG4gICAgICAgKi9cbiAgICAgIG1peGluKHRhcmdldCwgc291cmNlKSB7XG4gICAgICAgIGZvciAobGV0IGkgaW4gc291cmNlKSB7XG4gICAgICAgICAgdGFyZ2V0W2ldID0gc291cmNlW2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogU2V0cyB0aGUgcHJvdG90eXBlIG9mIGFuIG9iamVjdC5cbiAgICAgICAqXG4gICAgICAgKiBOb3RlIHRoaXMgbWV0aG9kIGlzIHByb3ZpZGVkIGFzIGJhY2t3YXJkLWNvbXBhdGlibGUgbGVnYWN5IEFQSVxuICAgICAgICogb25seS4gIEl0IGlzIG5vdCBkaXJlY3RseSBjYWxsZWQgYnkgYW55IFBvbHltZXIgZmVhdHVyZXMuXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3Qgb24gd2hpY2ggdG8gc2V0IHRoZSBwcm90b3R5cGUuXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvdG90eXBlIFRoZSBwcm90b3R5cGUgdGhhdCB3aWxsIGJlIHNldCBvbiB0aGUgZ2l2ZW5cbiAgICAgICAqIGBvYmplY3RgLlxuICAgICAgICogQHJldHVybiB7T2JqZWN0fSBSZXR1cm5zIHRoZSBnaXZlbiBgb2JqZWN0YCB3aXRoIGl0cyBwcm90b3R5cGUgc2V0XG4gICAgICAgKiB0byB0aGUgZ2l2ZW4gYHByb3RvdHlwZWAgb2JqZWN0LlxuICAgICAgICovXG4gICAgICBjaGFpbk9iamVjdChvYmplY3QsIHByb3RvdHlwZSkge1xuICAgICAgICBpZiAob2JqZWN0ICYmIHByb3RvdHlwZSAmJiBvYmplY3QgIT09IHByb3RvdHlwZSkge1xuICAgICAgICAgIG9iamVjdC5fX3Byb3RvX18gPSBwcm90b3R5cGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgIH1cblxuICAgICAgLyogKioqKiBCZWdpbiBUZW1wbGF0ZSAqKioqICovXG5cbiAgICAgIC8qKlxuICAgICAgICogQ2FsbHMgYGltcG9ydE5vZGVgIG9uIHRoZSBgY29udGVudGAgb2YgdGhlIGB0ZW1wbGF0ZWAgc3BlY2lmaWVkIGFuZFxuICAgICAgICogcmV0dXJucyBhIGRvY3VtZW50IGZyYWdtZW50IGNvbnRhaW5pbmcgdGhlIGltcG9ydGVkIGNvbnRlbnQuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtIVE1MVGVtcGxhdGVFbGVtZW50fSB0ZW1wbGF0ZSBIVE1MIHRlbXBsYXRlIGVsZW1lbnQgdG8gaW5zdGFuY2UuXG4gICAgICAgKiBAcmV0dXJuIHtEb2N1bWVudEZyYWdtZW50fSBEb2N1bWVudCBmcmFnbWVudCBjb250YWluaW5nIHRoZSBpbXBvcnRlZFxuICAgICAgICogICB0ZW1wbGF0ZSBjb250ZW50LlxuICAgICAgKi9cbiAgICAgIGluc3RhbmNlVGVtcGxhdGUodGVtcGxhdGUpIHtcbiAgICAgICAgbGV0IGNvbnRlbnQgPSB0aGlzLmNvbnN0cnVjdG9yLl9jb250ZW50Rm9yVGVtcGxhdGUodGVtcGxhdGUpO1xuICAgICAgICBsZXQgZG9tID0gLyoqIEB0eXBlIHtEb2N1bWVudEZyYWdtZW50fSAqL1xuICAgICAgICAgIChkb2N1bWVudC5pbXBvcnROb2RlKGNvbnRlbnQsIHRydWUpKTtcbiAgICAgICAgcmV0dXJuIGRvbTtcbiAgICAgIH1cblxuICAgICAgLyogKioqKiBCZWdpbiBFdmVudHMgKioqKiAqL1xuXG5cblxuICAgICAgLyoqXG4gICAgICAgKiBEaXNwYXRjaGVzIGEgY3VzdG9tIGV2ZW50IHdpdGggYW4gb3B0aW9uYWwgZGV0YWlsIHZhbHVlLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIE5hbWUgb2YgZXZlbnQgdHlwZS5cbiAgICAgICAqIEBwYXJhbSB7Kj19IGRldGFpbCBEZXRhaWwgdmFsdWUgY29udGFpbmluZyBldmVudC1zcGVjaWZpY1xuICAgICAgICogICBwYXlsb2FkLlxuICAgICAgICogQHBhcmFtIHt7IGJ1YmJsZXM6IChib29sZWFufHVuZGVmaW5lZCksIGNhbmNlbGFibGU6IChib29sZWFufHVuZGVmaW5lZCksIGNvbXBvc2VkOiAoYm9vbGVhbnx1bmRlZmluZWQpIH09fVxuICAgICAgICogIG9wdGlvbnMgT2JqZWN0IHNwZWNpZnlpbmcgb3B0aW9ucy4gIFRoZXNlIG1heSBpbmNsdWRlOlxuICAgICAgICogIGBidWJibGVzYCAoYm9vbGVhbiwgZGVmYXVsdHMgdG8gYHRydWVgKSxcbiAgICAgICAqICBgY2FuY2VsYWJsZWAgKGJvb2xlYW4sIGRlZmF1bHRzIHRvIGZhbHNlKSwgYW5kXG4gICAgICAgKiAgYG5vZGVgIG9uIHdoaWNoIHRvIGZpcmUgdGhlIGV2ZW50IChIVE1MRWxlbWVudCwgZGVmYXVsdHMgdG8gYHRoaXNgKS5cbiAgICAgICAqIEByZXR1cm4ge0V2ZW50fSBUaGUgbmV3IGV2ZW50IHRoYXQgd2FzIGZpcmVkLlxuICAgICAgICovXG4gICAgICBmaXJlKHR5cGUsIGRldGFpbCwgb3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgZGV0YWlsID0gKGRldGFpbCA9PT0gbnVsbCB8fCBkZXRhaWwgPT09IHVuZGVmaW5lZCkgPyB7fSA6IGRldGFpbDtcbiAgICAgICAgbGV0IGV2ZW50ID0gbmV3IEV2ZW50KHR5cGUsIHtcbiAgICAgICAgICBidWJibGVzOiBvcHRpb25zLmJ1YmJsZXMgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBvcHRpb25zLmJ1YmJsZXMsXG4gICAgICAgICAgY2FuY2VsYWJsZTogQm9vbGVhbihvcHRpb25zLmNhbmNlbGFibGUpLFxuICAgICAgICAgIGNvbXBvc2VkOiBvcHRpb25zLmNvbXBvc2VkID09PSB1bmRlZmluZWQgPyB0cnVlOiBvcHRpb25zLmNvbXBvc2VkXG4gICAgICAgIH0pO1xuICAgICAgICBldmVudC5kZXRhaWwgPSBkZXRhaWw7XG4gICAgICAgIGxldCBub2RlID0gb3B0aW9ucy5ub2RlIHx8IHRoaXM7XG4gICAgICAgIG5vZGUuZGlzcGF0Y2hFdmVudChldmVudClcbiAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENvbnZlbmllbmNlIG1ldGhvZCB0byBhZGQgYW4gZXZlbnQgbGlzdGVuZXIgb24gYSBnaXZlbiBlbGVtZW50LFxuICAgICAgICogbGF0ZSBib3VuZCB0byBhIG5hbWVkIG1ldGhvZCBvbiB0aGlzIGVsZW1lbnQuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtFbGVtZW50fSBub2RlIEVsZW1lbnQgdG8gYWRkIGV2ZW50IGxpc3RlbmVyIHRvLlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBOYW1lIG9mIGV2ZW50IHRvIGxpc3RlbiBmb3IuXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kTmFtZSBOYW1lIG9mIGhhbmRsZXIgbWV0aG9kIG9uIGB0aGlzYCB0byBjYWxsLlxuICAgICAgICovXG4gICAgICBsaXN0ZW4obm9kZSwgZXZlbnROYW1lLCBtZXRob2ROYW1lKSB7XG4gICAgICAgIG5vZGUgPSAvKiogQHR5cGUge0VsZW1lbnR9ICovIChub2RlIHx8IHRoaXMpO1xuICAgICAgICBsZXQgaGJsID0gdGhpcy5fX2JvdW5kTGlzdGVuZXJzIHx8XG4gICAgICAgICAgKHRoaXMuX19ib3VuZExpc3RlbmVycyA9IG5ldyBXZWFrTWFwKCkpO1xuICAgICAgICBsZXQgYmwgPSBoYmwuZ2V0KG5vZGUpO1xuICAgICAgICBpZiAoIWJsKSB7XG4gICAgICAgICAgYmwgPSB7fTtcbiAgICAgICAgICBoYmwuc2V0KG5vZGUsIGJsKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQga2V5ID0gZXZlbnROYW1lICsgbWV0aG9kTmFtZTtcbiAgICAgICAgaWYgKCFibFtrZXldKSB7XG4gICAgICAgICAgYmxba2V5XSA9IHRoaXMuX2FkZE1ldGhvZEV2ZW50TGlzdGVuZXJUb05vZGUoXG4gICAgICAgICAgICBub2RlLCBldmVudE5hbWUsIG1ldGhvZE5hbWUsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ29udmVuaWVuY2UgbWV0aG9kIHRvIHJlbW92ZSBhbiBldmVudCBsaXN0ZW5lciBmcm9tIGEgZ2l2ZW4gZWxlbWVudCxcbiAgICAgICAqIGxhdGUgYm91bmQgdG8gYSBuYW1lZCBtZXRob2Qgb24gdGhpcyBlbGVtZW50LlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZSBFbGVtZW50IHRvIHJlbW92ZSBldmVudCBsaXN0ZW5lciBmcm9tLlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBOYW1lIG9mIGV2ZW50IHRvIHN0b3AgbGlzdGVuaW5nIHRvLlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZE5hbWUgTmFtZSBvZiBoYW5kbGVyIG1ldGhvZCBvbiBgdGhpc2AgdG8gbm90IGNhbGxcbiAgICAgICBhbnltb3JlLlxuICAgICAgICovXG4gICAgICB1bmxpc3Rlbihub2RlLCBldmVudE5hbWUsIG1ldGhvZE5hbWUpIHtcbiAgICAgICAgbm9kZSA9IC8qKiBAdHlwZSB7RWxlbWVudH0gKi8gKG5vZGUgfHwgdGhpcyk7XG4gICAgICAgIGxldCBibCA9IHRoaXMuX19ib3VuZExpc3RlbmVycyAmJiB0aGlzLl9fYm91bmRMaXN0ZW5lcnMuZ2V0KG5vZGUpO1xuICAgICAgICBsZXQga2V5ID0gZXZlbnROYW1lICsgbWV0aG9kTmFtZTtcbiAgICAgICAgbGV0IGhhbmRsZXIgPSBibCAmJiBibFtrZXldO1xuICAgICAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICAgIHRoaXMuX3JlbW92ZUV2ZW50TGlzdGVuZXJGcm9tTm9kZShub2RlLCBldmVudE5hbWUsIGhhbmRsZXIpO1xuICAgICAgICAgIGJsW2tleV0gPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogT3ZlcnJpZGUgc2Nyb2xsaW5nIGJlaGF2aW9yIHRvIGFsbCBkaXJlY3Rpb24sIG9uZSBkaXJlY3Rpb24sIG9yIG5vbmUuXG4gICAgICAgKlxuICAgICAgICogVmFsaWQgc2Nyb2xsIGRpcmVjdGlvbnM6XG4gICAgICAgKiAgIC0gJ2FsbCc6IHNjcm9sbCBpbiBhbnkgZGlyZWN0aW9uXG4gICAgICAgKiAgIC0gJ3gnOiBzY3JvbGwgb25seSBpbiB0aGUgJ3gnIGRpcmVjdGlvblxuICAgICAgICogICAtICd5Jzogc2Nyb2xsIG9ubHkgaW4gdGhlICd5JyBkaXJlY3Rpb25cbiAgICAgICAqICAgLSAnbm9uZSc6IGRpc2FibGUgc2Nyb2xsaW5nIGZvciB0aGlzIG5vZGVcbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZz19IGRpcmVjdGlvbiBEaXJlY3Rpb24gdG8gYWxsb3cgc2Nyb2xsaW5nXG4gICAgICAgKiBEZWZhdWx0cyB0byBgYWxsYC5cbiAgICAgICAqIEBwYXJhbSB7RWxlbWVudD19IG5vZGUgRWxlbWVudCB0byBhcHBseSBzY3JvbGwgZGlyZWN0aW9uIHNldHRpbmcuXG4gICAgICAgKiBEZWZhdWx0cyB0byBgdGhpc2AuXG4gICAgICAgKi9cbiAgICAgIHNldFNjcm9sbERpcmVjdGlvbihkaXJlY3Rpb24sIG5vZGUpIHtcbiAgICAgICAgUG9seW1lci5HZXN0dXJlcy5zZXRUb3VjaEFjdGlvbigvKiogQHR5cGUge0VsZW1lbnR9ICovIChub2RlIHx8IHRoaXMpLCBESVJFQ1RJT05fTUFQW2RpcmVjdGlvbl0gfHwgJ2F1dG8nKTtcbiAgICAgIH1cbiAgICAgIC8qICoqKiogRW5kIEV2ZW50cyAqKioqICovXG5cbiAgICAgIC8qKlxuICAgICAgICogQ29udmVuaWVuY2UgbWV0aG9kIHRvIHJ1biBgcXVlcnlTZWxlY3RvcmAgb24gdGhpcyBsb2NhbCBET00gc2NvcGUuXG4gICAgICAgKlxuICAgICAgICogVGhpcyBmdW5jdGlvbiBjYWxscyBgUG9seW1lci5kb20odGhpcy5yb290KS5xdWVyeVNlbGVjdG9yKHNsY3RyKWAuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHNsY3RyIFNlbGVjdG9yIHRvIHJ1biBvbiB0aGlzIGxvY2FsIERPTSBzY29wZVxuICAgICAgICogQHJldHVybiB7RWxlbWVudH0gRWxlbWVudCBmb3VuZCBieSB0aGUgc2VsZWN0b3IsIG9yIG51bGwgaWYgbm90IGZvdW5kLlxuICAgICAgICovXG4gICAgICAkJChzbGN0cikge1xuICAgICAgICByZXR1cm4gdGhpcy5yb290LnF1ZXJ5U2VsZWN0b3Ioc2xjdHIpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJldHVybiB0aGUgZWxlbWVudCB3aG9zZSBsb2NhbCBkb20gd2l0aGluIHdoaWNoIHRoaXMgZWxlbWVudFxuICAgICAgICogaXMgY29udGFpbmVkLiBUaGlzIGlzIGEgc2hvcnRoYW5kIGZvclxuICAgICAgICogYHRoaXMuZ2V0Um9vdE5vZGUoKS5ob3N0YC5cbiAgICAgICAqIEB0aGlzIHtFbGVtZW50fVxuICAgICAgICovXG4gICAgICBnZXQgZG9tSG9zdCgpIHtcbiAgICAgICAgbGV0IHJvb3QgPSB0aGlzLmdldFJvb3ROb2RlKCk7XG4gICAgICAgIHJldHVybiAocm9vdCBpbnN0YW5jZW9mIERvY3VtZW50RnJhZ21lbnQpID8gLyoqIEB0eXBlIHtTaGFkb3dSb290fSAqLyAocm9vdCkuaG9zdCA6IHJvb3Q7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogRm9yY2UgdGhpcyBlbGVtZW50IHRvIGRpc3RyaWJ1dGUgaXRzIGNoaWxkcmVuIHRvIGl0cyBsb2NhbCBkb20uXG4gICAgICAgKiBUaGlzIHNob3VsZCBub3QgYmUgbmVjZXNzYXJ5IGFzIG9mIFBvbHltZXIgMi4wLjIgYW5kIGlzIHByb3ZpZGVkIG9ubHlcbiAgICAgICAqIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cbiAgICAgICAqL1xuICAgICAgZGlzdHJpYnV0ZUNvbnRlbnQoKSB7XG4gICAgICAgIGlmICh3aW5kb3cuU2hhZHlET00gJiYgdGhpcy5zaGFkb3dSb290KSB7XG4gICAgICAgICAgU2hhZHlET00uZmx1c2goKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJldHVybnMgYSBsaXN0IG9mIG5vZGVzIHRoYXQgYXJlIHRoZSBlZmZlY3RpdmUgY2hpbGROb2Rlcy4gVGhlIGVmZmVjdGl2ZVxuICAgICAgICogY2hpbGROb2RlcyBsaXN0IGlzIHRoZSBzYW1lIGFzIHRoZSBlbGVtZW50J3MgY2hpbGROb2RlcyBleGNlcHQgdGhhdFxuICAgICAgICogYW55IGA8Y29udGVudD5gIGVsZW1lbnRzIGFyZSByZXBsYWNlZCB3aXRoIHRoZSBsaXN0IG9mIG5vZGVzIGRpc3RyaWJ1dGVkXG4gICAgICAgKiB0byB0aGUgYDxjb250ZW50PmAsIHRoZSByZXN1bHQgb2YgaXRzIGBnZXREaXN0cmlidXRlZE5vZGVzYCBtZXRob2QuXG4gICAgICAgKiBAdGhpcyB7RWxlbWVudH1cbiAgICAgICAqIEByZXR1cm4ge0FycmF5PE5vZGU+fSBMaXN0IG9mIGVmZmN0aXZlIGNoaWxkIG5vZGVzLlxuICAgICAgICovXG4gICAgICBnZXRFZmZlY3RpdmVDaGlsZE5vZGVzKCkge1xuICAgICAgICByZXR1cm4gLyoqIEB0eXBlIHtQb2x5bWVyLkRvbUFwaX0gKi8gKFBvbHltZXIuZG9tKHRoaXMpKS5nZXRFZmZlY3RpdmVDaGlsZE5vZGVzKCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUmV0dXJucyBhIGxpc3Qgb2Ygbm9kZXMgZGlzdHJpYnV0ZWQgd2l0aGluIHRoaXMgZWxlbWVudCB0aGF0IG1hdGNoXG4gICAgICAgKiBgc2VsZWN0b3JgLiBUaGVzZSBjYW4gYmUgZG9tIGNoaWxkcmVuIG9yIGVsZW1lbnRzIGRpc3RyaWJ1dGVkIHRvXG4gICAgICAgKiBjaGlsZHJlbiB0aGF0IGFyZSBpbnNlcnRpb24gcG9pbnRzLlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yIFNlbGVjdG9yIHRvIHJ1bi5cbiAgICAgICAqIEB0aGlzIHtFbGVtZW50fVxuICAgICAgICogQHJldHVybiB7QXJyYXk8Tm9kZT59IExpc3Qgb2YgZGlzdHJpYnV0ZWQgZWxlbWVudHMgdGhhdCBtYXRjaCBzZWxlY3Rvci5cbiAgICAgICAqL1xuICAgICAgcXVlcnlEaXN0cmlidXRlZEVsZW1lbnRzKHNlbGVjdG9yKSB7XG4gICAgICAgIHJldHVybiAvKiogQHR5cGUge1BvbHltZXIuRG9tQXBpfSAqLyAoUG9seW1lci5kb20odGhpcykpLnF1ZXJ5RGlzdHJpYnV0ZWRFbGVtZW50cyhzZWxlY3Rvcik7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUmV0dXJucyBhIGxpc3Qgb2YgZWxlbWVudHMgdGhhdCBhcmUgdGhlIGVmZmVjdGl2ZSBjaGlsZHJlbi4gVGhlIGVmZmVjdGl2ZVxuICAgICAgICogY2hpbGRyZW4gbGlzdCBpcyB0aGUgc2FtZSBhcyB0aGUgZWxlbWVudCdzIGNoaWxkcmVuIGV4Y2VwdCB0aGF0XG4gICAgICAgKiBhbnkgYDxjb250ZW50PmAgZWxlbWVudHMgYXJlIHJlcGxhY2VkIHdpdGggdGhlIGxpc3Qgb2YgZWxlbWVudHNcbiAgICAgICAqIGRpc3RyaWJ1dGVkIHRvIHRoZSBgPGNvbnRlbnQ+YC5cbiAgICAgICAqXG4gICAgICAgKiBAcmV0dXJuIHtBcnJheTxOb2RlPn0gTGlzdCBvZiBlZmZjdGl2ZSBjaGlsZHJlbi5cbiAgICAgICAqL1xuICAgICAgZ2V0RWZmZWN0aXZlQ2hpbGRyZW4oKSB7XG4gICAgICAgIGxldCBsaXN0ID0gdGhpcy5nZXRFZmZlY3RpdmVDaGlsZE5vZGVzKCk7XG4gICAgICAgIHJldHVybiBsaXN0LmZpbHRlcihmdW5jdGlvbigvKiogQHR5cGUge05vZGV9ICovIG4pIHtcbiAgICAgICAgICByZXR1cm4gKG4ubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUmV0dXJucyBhIHN0cmluZyBvZiB0ZXh0IGNvbnRlbnQgdGhhdCBpcyB0aGUgY29uY2F0ZW5hdGlvbiBvZiB0aGVcbiAgICAgICAqIHRleHQgY29udGVudCdzIG9mIHRoZSBlbGVtZW50J3MgZWZmZWN0aXZlIGNoaWxkTm9kZXMgKHRoZSBlbGVtZW50c1xuICAgICAgICogcmV0dXJuZWQgYnkgPGEgaHJlZj1cIiNnZXRFZmZlY3RpdmVDaGlsZE5vZGVzPmdldEVmZmVjdGl2ZUNoaWxkTm9kZXM8L2E+LlxuICAgICAgICpcbiAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gTGlzdCBvZiBlZmZjdGl2ZSBjaGlsZHJlbi5cbiAgICAgICAqL1xuICAgICAgZ2V0RWZmZWN0aXZlVGV4dENvbnRlbnQoKSB7XG4gICAgICAgIGxldCBjbiA9IHRoaXMuZ2V0RWZmZWN0aXZlQ2hpbGROb2RlcygpO1xuICAgICAgICBsZXQgdGMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaT0wLCBjOyAoYyA9IGNuW2ldKTsgaSsrKSB7XG4gICAgICAgICAgaWYgKGMubm9kZVR5cGUgIT09IE5vZGUuQ09NTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICB0Yy5wdXNoKGMudGV4dENvbnRlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGMuam9pbignJyk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUmV0dXJucyB0aGUgZmlyc3QgZWZmZWN0aXZlIGNoaWxkTm9kZSB3aXRoaW4gdGhpcyBlbGVtZW50IHRoYXRcbiAgICAgICAqIG1hdGNoIGBzZWxlY3RvcmAuIFRoZXNlIGNhbiBiZSBkb20gY2hpbGQgbm9kZXMgb3IgZWxlbWVudHMgZGlzdHJpYnV0ZWRcbiAgICAgICAqIHRvIGNoaWxkcmVuIHRoYXQgYXJlIGluc2VydGlvbiBwb2ludHMuXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3IgU2VsZWN0b3IgdG8gcnVuLlxuICAgICAgICogQHJldHVybiB7T2JqZWN0PE5vZGU+fSBGaXJzdCBlZmZlY3RpdmUgY2hpbGQgbm9kZSB0aGF0IG1hdGNoZXMgc2VsZWN0b3IuXG4gICAgICAgKi9cbiAgICAgIHF1ZXJ5RWZmZWN0aXZlQ2hpbGRyZW4oc2VsZWN0b3IpIHtcbiAgICAgICAgbGV0IGUkID0gdGhpcy5xdWVyeURpc3RyaWJ1dGVkRWxlbWVudHMoc2VsZWN0b3IpO1xuICAgICAgICByZXR1cm4gZSQgJiYgZSRbMF07XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUmV0dXJucyBhIGxpc3Qgb2YgZWZmZWN0aXZlIGNoaWxkTm9kZXMgd2l0aGluIHRoaXMgZWxlbWVudCB0aGF0XG4gICAgICAgKiBtYXRjaCBgc2VsZWN0b3JgLiBUaGVzZSBjYW4gYmUgZG9tIGNoaWxkIG5vZGVzIG9yIGVsZW1lbnRzIGRpc3RyaWJ1dGVkXG4gICAgICAgKiB0byBjaGlsZHJlbiB0aGF0IGFyZSBpbnNlcnRpb24gcG9pbnRzLlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yIFNlbGVjdG9yIHRvIHJ1bi5cbiAgICAgICAqIEByZXR1cm4ge0FycmF5PE5vZGU+fSBMaXN0IG9mIGVmZmVjdGl2ZSBjaGlsZCBub2RlcyB0aGF0IG1hdGNoIHNlbGVjdG9yLlxuICAgICAgICovXG4gICAgICBxdWVyeUFsbEVmZmVjdGl2ZUNoaWxkcmVuKHNlbGVjdG9yKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnF1ZXJ5RGlzdHJpYnV0ZWRFbGVtZW50cyhzZWxlY3Rvcik7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUmV0dXJucyBhIGxpc3Qgb2Ygbm9kZXMgZGlzdHJpYnV0ZWQgdG8gdGhpcyBlbGVtZW50J3MgYDxzbG90PmAuXG4gICAgICAgKlxuICAgICAgICogSWYgdGhpcyBlbGVtZW50IGNvbnRhaW5zIG1vcmUgdGhhbiBvbmUgYDxzbG90PmAgaW4gaXRzIGxvY2FsIERPTSxcbiAgICAgICAqIGFuIG9wdGlvbmFsIHNlbGVjdG9yIG1heSBiZSBwYXNzZWQgdG8gY2hvb3NlIHRoZSBkZXNpcmVkIGNvbnRlbnQuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmc9fSBzbGN0ciBDU1Mgc2VsZWN0b3IgdG8gY2hvb3NlIHRoZSBkZXNpcmVkXG4gICAgICAgKiAgIGA8c2xvdD5gLiAgRGVmYXVsdHMgdG8gYGNvbnRlbnRgLlxuICAgICAgICogQHJldHVybiB7QXJyYXk8Tm9kZT59IExpc3Qgb2YgZGlzdHJpYnV0ZWQgbm9kZXMgZm9yIHRoZSBgPHNsb3Q+YC5cbiAgICAgICAqL1xuICAgICAgZ2V0Q29udGVudENoaWxkTm9kZXMoc2xjdHIpIHtcbiAgICAgICAgbGV0IGNvbnRlbnQgPSB0aGlzLnJvb3QucXVlcnlTZWxlY3RvcihzbGN0ciB8fCAnc2xvdCcpO1xuICAgICAgICByZXR1cm4gY29udGVudCA/IC8qKiBAdHlwZSB7UG9seW1lci5Eb21BcGl9ICovKFBvbHltZXIuZG9tKGNvbnRlbnQpKS5nZXREaXN0cmlidXRlZE5vZGVzKCkgOiBbXTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBlbGVtZW50IGNoaWxkcmVuIGRpc3RyaWJ1dGVkIHRvIHRoaXMgZWxlbWVudCdzXG4gICAgICAgKiBgPHNsb3Q+YC5cbiAgICAgICAqXG4gICAgICAgKiBJZiB0aGlzIGVsZW1lbnQgY29udGFpbnMgbW9yZSB0aGFuIG9uZSBgPHNsb3Q+YCBpbiBpdHNcbiAgICAgICAqIGxvY2FsIERPTSwgYW4gb3B0aW9uYWwgc2VsZWN0b3IgbWF5IGJlIHBhc3NlZCB0byBjaG9vc2UgdGhlIGRlc2lyZWRcbiAgICAgICAqIGNvbnRlbnQuICBUaGlzIG1ldGhvZCBkaWZmZXJzIGZyb20gYGdldENvbnRlbnRDaGlsZE5vZGVzYCBpbiB0aGF0IG9ubHlcbiAgICAgICAqIGVsZW1lbnRzIGFyZSByZXR1cm5lZC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZz19IHNsY3RyIENTUyBzZWxlY3RvciB0byBjaG9vc2UgdGhlIGRlc2lyZWRcbiAgICAgICAqICAgYDxjb250ZW50PmAuICBEZWZhdWx0cyB0byBgY29udGVudGAuXG4gICAgICAgKiBAcmV0dXJuIHtBcnJheTxIVE1MRWxlbWVudD59IExpc3Qgb2YgZGlzdHJpYnV0ZWQgbm9kZXMgZm9yIHRoZVxuICAgICAgICogICBgPHNsb3Q+YC5cbiAgICAgICAqIEBzdXBwcmVzcyB7aW52YWxpZENhc3RzfVxuICAgICAgICovXG4gICAgICBnZXRDb250ZW50Q2hpbGRyZW4oc2xjdHIpIHtcbiAgICAgICAgcmV0dXJuIC8qKiBAdHlwZSB7QXJyYXk8SFRNTEVsZW1lbnQ+fSAqLyh0aGlzLmdldENvbnRlbnRDaGlsZE5vZGVzKHNsY3RyKS5maWx0ZXIoZnVuY3Rpb24obikge1xuICAgICAgICAgIHJldHVybiAobi5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUpO1xuICAgICAgICB9KSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ2hlY2tzIHdoZXRoZXIgYW4gZWxlbWVudCBpcyBpbiB0aGlzIGVsZW1lbnQncyBsaWdodCBET00gdHJlZS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0gez9Ob2RlfSBub2RlIFRoZSBlbGVtZW50IHRvIGJlIGNoZWNrZWQuXG4gICAgICAgKiBAdGhpcyB7RWxlbWVudH1cbiAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgbm9kZSBpcyBpbiB0aGlzIGVsZW1lbnQncyBsaWdodCBET00gdHJlZS5cbiAgICAgICAqL1xuICAgICAgaXNMaWdodERlc2NlbmRhbnQobm9kZSkge1xuICAgICAgICByZXR1cm4gdGhpcyAhPT0gbm9kZSAmJiB0aGlzLmNvbnRhaW5zKG5vZGUpICYmXG4gICAgICAgICAgICB0aGlzLmdldFJvb3ROb2RlKCkgPT09IG5vZGUuZ2V0Um9vdE5vZGUoKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDaGVja3Mgd2hldGhlciBhbiBlbGVtZW50IGlzIGluIHRoaXMgZWxlbWVudCdzIGxvY2FsIERPTSB0cmVlLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7RWxlbWVudD19IG5vZGUgVGhlIGVsZW1lbnQgdG8gYmUgY2hlY2tlZC5cbiAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgbm9kZSBpcyBpbiB0aGlzIGVsZW1lbnQncyBsb2NhbCBET00gdHJlZS5cbiAgICAgICAqL1xuICAgICAgaXNMb2NhbERlc2NlbmRhbnQobm9kZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yb290ID09PSBub2RlLmdldFJvb3ROb2RlKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIE5PVEU6IHNob3VsZCBub3cgYmUgaGFuZGxlZCBieSBTaGFkeUNzcyBsaWJyYXJ5LlxuICAgICAgc2NvcGVTdWJ0cmVlKGNvbnRhaW5lciwgc2hvdWxkT2JzZXJ2ZSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUmV0dXJucyB0aGUgY29tcHV0ZWQgc3R5bGUgdmFsdWUgZm9yIHRoZSBnaXZlbiBwcm9wZXJ0eS5cbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBUaGUgY3NzIHByb3BlcnR5IG5hbWUuXG4gICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbXB1dGVkIGNzcyBwcm9wZXJ0eSB2YWx1ZSBmb3IgdGhlIGdpdmVuXG4gICAgICAgKiBgcHJvcGVydHlgLlxuICAgICAgICovXG4gICAgICBnZXRDb21wdXRlZFN0eWxlVmFsdWUocHJvcGVydHkpIHtcbiAgICAgICAgcmV0dXJuIHN0eWxlSW50ZXJmYWNlLmdldENvbXB1dGVkU3R5bGVWYWx1ZSh0aGlzLCBwcm9wZXJ0eSk7XG4gICAgICB9XG5cbiAgICAgIC8vIGRlYm91bmNlXG5cbiAgICAgIC8qKlxuICAgICAgICogQ2FsbCBgZGVib3VuY2VgIHRvIGNvbGxhcHNlIG11bHRpcGxlIHJlcXVlc3RzIGZvciBhIG5hbWVkIHRhc2sgaW50b1xuICAgICAgICogb25lIGludm9jYXRpb24gd2hpY2ggaXMgbWFkZSBhZnRlciB0aGUgd2FpdCB0aW1lIGhhcyBlbGFwc2VkIHdpdGhcbiAgICAgICAqIG5vIG5ldyByZXF1ZXN0LiAgSWYgbm8gd2FpdCB0aW1lIGlzIGdpdmVuLCB0aGUgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWRcbiAgICAgICAqIGF0IG1pY3JvdGFzayB0aW1pbmcgKGd1YXJhbnRlZWQgYmVmb3JlIHBhaW50KS5cbiAgICAgICAqXG4gICAgICAgKiAgICAgZGVib3VuY2VkQ2xpY2tBY3Rpb24oZSkge1xuICAgICAgICogICAgICAgLy8gd2lsbCBub3QgY2FsbCBgcHJvY2Vzc0NsaWNrYCBtb3JlIHRoYW4gb25jZSBwZXIgMTAwbXNcbiAgICAgICAqICAgICAgIHRoaXMuZGVib3VuY2UoJ2NsaWNrJywgZnVuY3Rpb24oKSB7XG4gICAgICAgKiAgICAgICAgdGhpcy5wcm9jZXNzQ2xpY2soKTtcbiAgICAgICAqICAgICAgIH0gMTAwKTtcbiAgICAgICAqICAgICB9XG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGpvYk5hbWUgU3RyaW5nIHRvIGluZGVudGlmeSB0aGUgZGVib3VuY2Ugam9iLlxuICAgICAgICogQHBhcmFtIHtmdW5jdGlvbigpfSBjYWxsYmFjayBGdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCAod2l0aCBgdGhpc2BcbiAgICAgICAqICAgY29udGV4dCkgd2hlbiB0aGUgd2FpdCB0aW1lIGVsYXBzZXMuXG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0gd2FpdCBPcHRpb25hbCB3YWl0IHRpbWUgaW4gbWlsbGlzZWNvbmRzIChtcykgYWZ0ZXIgdGhlXG4gICAgICAgKiAgIGxhc3Qgc2lnbmFsIHRoYXQgbXVzdCBlbGFwc2UgYmVmb3JlIGludm9raW5nIGBjYWxsYmFja2BcbiAgICAgICAqIEByZXR1cm4ge09iamVjdH0gUmV0dXJucyBhIGRlYm91bmNlciBvYmplY3Qgb24gd2hpY2ggZXhpc3RzIHRoZVxuICAgICAgICogZm9sbG93aW5nIG1ldGhvZHM6IGBpc0FjdGl2ZSgpYCByZXR1cm5zIHRydWUgaWYgdGhlIGRlYm91bmNlciBpc1xuICAgICAgICogYWN0aXZlOyBgY2FuY2VsKClgIGNhbmNlbHMgdGhlIGRlYm91bmNlciBpZiBpdCBpcyBhY3RpdmU7XG4gICAgICAgKiBgZmx1c2goKWAgaW1tZWRpYXRlbHkgaW52b2tlcyB0aGUgZGVib3VuY2VkIGNhbGxiYWNrIGlmIHRoZSBkZWJvdW5jZXJcbiAgICAgICAqIGlzIGFjdGl2ZS5cbiAgICAgICAqL1xuICAgICAgZGVib3VuY2Uoam9iTmFtZSwgY2FsbGJhY2ssIHdhaXQpIHtcbiAgICAgICAgdGhpcy5fZGVib3VuY2VycyA9IHRoaXMuX2RlYm91bmNlcnMgfHwge307XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWJvdW5jZXJzW2pvYk5hbWVdID0gUG9seW1lci5EZWJvdW5jZXIuZGVib3VuY2UoXG4gICAgICAgICAgICAgIHRoaXMuX2RlYm91bmNlcnNbam9iTmFtZV1cbiAgICAgICAgICAgICwgd2FpdCA+IDAgPyBQb2x5bWVyLkFzeW5jLnRpbWVPdXQuYWZ0ZXIod2FpdCkgOiBQb2x5bWVyLkFzeW5jLm1pY3JvVGFza1xuICAgICAgICAgICAgLCBjYWxsYmFjay5iaW5kKHRoaXMpKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZXR1cm5zIHdoZXRoZXIgYSBuYW1lZCBkZWJvdW5jZXIgaXMgYWN0aXZlLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBqb2JOYW1lIFRoZSBuYW1lIG9mIHRoZSBkZWJvdW5jZXIgc3RhcnRlZCB3aXRoIGBkZWJvdW5jZWBcbiAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIGRlYm91bmNlciBpcyBhY3RpdmUgKGhhcyBub3QgeWV0IGZpcmVkKS5cbiAgICAgICAqL1xuICAgICAgaXNEZWJvdW5jZXJBY3RpdmUoam9iTmFtZSkge1xuICAgICAgICB0aGlzLl9kZWJvdW5jZXJzID0gdGhpcy5fZGVib3VuY2VycyB8fCB7fTtcbiAgICAgICAgbGV0IGRlYm91bmNlciA9IHRoaXMuX2RlYm91bmNlcnNbam9iTmFtZV07XG4gICAgICAgIHJldHVybiAhIShkZWJvdW5jZXIgJiYgZGVib3VuY2VyLmlzQWN0aXZlKCkpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEltbWVkaWF0ZWx5IGNhbGxzIHRoZSBkZWJvdW5jZXIgYGNhbGxiYWNrYCBhbmQgaW5hY3RpdmF0ZXMgaXQuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGpvYk5hbWUgVGhlIG5hbWUgb2YgdGhlIGRlYm91bmNlciBzdGFydGVkIHdpdGggYGRlYm91bmNlYFxuICAgICAgICovXG4gICAgICBmbHVzaERlYm91bmNlcihqb2JOYW1lKSB7XG4gICAgICAgIHRoaXMuX2RlYm91bmNlcnMgPSB0aGlzLl9kZWJvdW5jZXJzIHx8IHt9O1xuICAgICAgICBsZXQgZGVib3VuY2VyID0gdGhpcy5fZGVib3VuY2Vyc1tqb2JOYW1lXTtcbiAgICAgICAgaWYgKGRlYm91bmNlcikge1xuICAgICAgICAgIGRlYm91bmNlci5mbHVzaCgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ2FuY2VscyBhbiBhY3RpdmUgZGVib3VuY2VyLiAgVGhlIGBjYWxsYmFja2Agd2lsbCBub3QgYmUgY2FsbGVkLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBqb2JOYW1lIFRoZSBuYW1lIG9mIHRoZSBkZWJvdW5jZXIgc3RhcnRlZCB3aXRoIGBkZWJvdW5jZWBcbiAgICAgICAqL1xuICAgICAgY2FuY2VsRGVib3VuY2VyKGpvYk5hbWUpIHtcbiAgICAgICAgdGhpcy5fZGVib3VuY2VycyA9IHRoaXMuX2RlYm91bmNlcnMgfHwge31cbiAgICAgICAgbGV0IGRlYm91bmNlciA9IHRoaXMuX2RlYm91bmNlcnNbam9iTmFtZV07XG4gICAgICAgIGlmIChkZWJvdW5jZXIpIHtcbiAgICAgICAgICBkZWJvdW5jZXIuY2FuY2VsKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSdW5zIGEgY2FsbGJhY2sgZnVuY3Rpb24gYXN5bmNyb25vdXNseS5cbiAgICAgICAqXG4gICAgICAgKiBCeSBkZWZhdWx0IChpZiBubyB3YWl0VGltZSBpcyBzcGVjaWZpZWQpLCBhc3luYyBjYWxsYmFja3MgYXJlIHJ1biBhdFxuICAgICAgICogbWljcm90YXNrIHRpbWluZywgd2hpY2ggd2lsbCBvY2N1ciBiZWZvcmUgcGFpbnQuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIHJ1biwgYm91bmQgdG8gYHRoaXNgLlxuICAgICAgICogQHBhcmFtIHtudW1iZXI9fSB3YWl0VGltZSBUaW1lIHRvIHdhaXQgYmVmb3JlIGNhbGxpbmcgdGhlXG4gICAgICAgKiAgIGBjYWxsYmFja2AuICBJZiB1bnNwZWNpZmllZCBvciAwLCB0aGUgY2FsbGJhY2sgd2lsbCBiZSBydW4gYXQgbWljcm90YXNrXG4gICAgICAgKiAgIHRpbWluZyAoYmVmb3JlIHBhaW50KS5cbiAgICAgICAqIEByZXR1cm4ge251bWJlcn0gSGFuZGxlIHRoYXQgbWF5IGJlIHVzZWQgdG8gY2FuY2VsIHRoZSBhc3luYyBqb2IuXG4gICAgICAgKi9cbiAgICAgIGFzeW5jKGNhbGxiYWNrLCB3YWl0VGltZSkge1xuICAgICAgICByZXR1cm4gd2FpdFRpbWUgPiAwID8gUG9seW1lci5Bc3luYy50aW1lT3V0LnJ1bihjYWxsYmFjay5iaW5kKHRoaXMpLCB3YWl0VGltZSkgOlxuICAgICAgICAgICAgflBvbHltZXIuQXN5bmMubWljcm9UYXNrLnJ1bihjYWxsYmFjay5iaW5kKHRoaXMpKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDYW5jZWxzIGFuIGFzeW5jIG9wZXJhdGlvbiBzdGFydGVkIHdpdGggYGFzeW5jYC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0gaGFuZGxlIEhhbmRsZSByZXR1cm5lZCBmcm9tIG9yaWdpbmFsIGBhc3luY2AgY2FsbCB0b1xuICAgICAgICogICBjYW5jZWwuXG4gICAgICAgKi9cbiAgICAgIGNhbmNlbEFzeW5jKGhhbmRsZSkge1xuICAgICAgICBoYW5kbGUgPCAwID8gUG9seW1lci5Bc3luYy5taWNyb1Rhc2suY2FuY2VsKH5oYW5kbGUpIDpcbiAgICAgICAgICAgIFBvbHltZXIuQXN5bmMudGltZU91dC5jYW5jZWwoaGFuZGxlKTtcbiAgICAgIH1cblxuICAgICAgLy8gb3RoZXJcblxuICAgICAgLyoqXG4gICAgICAgKiBDb252ZW5pZW5jZSBtZXRob2QgZm9yIGNyZWF0aW5nIGFuIGVsZW1lbnQgYW5kIGNvbmZpZ3VyaW5nIGl0LlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgSFRNTCBlbGVtZW50IHRhZyB0byBjcmVhdGUuXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgT2JqZWN0IG9mIHByb3BlcnRpZXMgdG8gY29uZmlndXJlIG9uIHRoZVxuICAgICAgICogICAgaW5zdGFuY2UuXG4gICAgICAgKiBAcmV0dXJuIHtFbGVtZW50fSBOZXdseSBjcmVhdGVkIGFuZCBjb25maWd1cmVkIGVsZW1lbnQuXG4gICAgICAgKi9cbiAgICAgIGNyZWF0ZSh0YWcsIHByb3BzKSB7XG4gICAgICAgIGxldCBlbHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIGlmIChwcm9wcykge1xuICAgICAgICAgIGlmIChlbHQuc2V0UHJvcGVydGllcykge1xuICAgICAgICAgICAgZWx0LnNldFByb3BlcnRpZXMocHJvcHMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGxldCBuIGluIHByb3BzKSB7XG4gICAgICAgICAgICAgIGVsdFtuXSA9IHByb3BzW25dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZWx0O1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENvbnZlbmllbmNlIG1ldGhvZCBmb3IgaW1wb3J0aW5nIGFuIEhUTUwgZG9jdW1lbnQgaW1wZXJhdGl2ZWx5LlxuICAgICAgICpcbiAgICAgICAqIFRoaXMgbWV0aG9kIGNyZWF0ZXMgYSBuZXcgYDxsaW5rIHJlbD1cImltcG9ydFwiPmAgZWxlbWVudCB3aXRoXG4gICAgICAgKiB0aGUgcHJvdmlkZWQgVVJMIGFuZCBhcHBlbmRzIGl0IHRvIHRoZSBkb2N1bWVudCB0byBzdGFydCBsb2FkaW5nLlxuICAgICAgICogSW4gdGhlIGBvbmxvYWRgIGNhbGxiYWNrLCB0aGUgYGltcG9ydGAgcHJvcGVydHkgb2YgdGhlIGBsaW5rYFxuICAgICAgICogZWxlbWVudCB3aWxsIGNvbnRhaW4gdGhlIGltcG9ydGVkIGRvY3VtZW50IGNvbnRlbnRzLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBocmVmIFVSTCB0byBkb2N1bWVudCB0byBsb2FkLlxuICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gb25sb2FkIENhbGxiYWNrIHRvIG5vdGlmeSB3aGVuIGFuIGltcG9ydCBzdWNjZXNzZnVsbHlcbiAgICAgICAqICAgbG9hZGVkLlxuICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gb25lcnJvciBDYWxsYmFjayB0byBub3RpZnkgd2hlbiBhbiBpbXBvcnRcbiAgICAgICAqICAgdW5zdWNjZXNzZnVsbHkgbG9hZGVkLlxuICAgICAgICogQHBhcmFtIHtib29sZWFufSBvcHRBc3luYyBUcnVlIGlmIHRoZSBpbXBvcnQgc2hvdWxkIGJlIGxvYWRlZCBgYXN5bmNgLlxuICAgICAgICogICBEZWZhdWx0cyB0byBgZmFsc2VgLlxuICAgICAgICogQHJldHVybiB7SFRNTExpbmtFbGVtZW50fSBUaGUgbGluayBlbGVtZW50IGZvciB0aGUgVVJMIHRvIGJlIGxvYWRlZC5cbiAgICAgICAqL1xuICAgICAgaW1wb3J0SHJlZihocmVmLCBvbmxvYWQsIG9uZXJyb3IsIG9wdEFzeW5jKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgICAgbGV0IGxvYWRGbiA9IG9ubG9hZCA/IG9ubG9hZC5iaW5kKHRoaXMpIDogbnVsbDtcbiAgICAgICAgbGV0IGVycm9yRm4gPSBvbmVycm9yID8gb25lcnJvci5iaW5kKHRoaXMpIDogbnVsbDtcbiAgICAgICAgcmV0dXJuIFBvbHltZXIuaW1wb3J0SHJlZihocmVmLCBsb2FkRm4sIGVycm9yRm4sIG9wdEFzeW5jKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBQb2x5ZmlsbCBmb3IgRWxlbWVudC5wcm90b3R5cGUubWF0Y2hlcywgd2hpY2ggaXMgc29tZXRpbWVzIHN0aWxsXG4gICAgICAgKiBwcmVmaXhlZC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3IgU2VsZWN0b3IgdG8gdGVzdC5cbiAgICAgICAqIEBwYXJhbSB7RWxlbWVudD19IG5vZGUgRWxlbWVudCB0byB0ZXN0IHRoZSBzZWxlY3RvciBhZ2FpbnN0LlxuICAgICAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgZWxlbWVudCBtYXRjaGVzIHRoZSBzZWxlY3Rvci5cbiAgICAgICAqL1xuICAgICAgZWxlbWVudE1hdGNoZXMoc2VsZWN0b3IsIG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIFBvbHltZXIuZG9tLm1hdGNoZXNTZWxlY3RvcigvKiogQHR5cGUgeyFFbGVtZW50fSAqLyAobm9kZSB8fCB0aGlzKSwgc2VsZWN0b3IpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFRvZ2dsZXMgYW4gSFRNTCBhdHRyaWJ1dGUgb24gb3Igb2ZmLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIEhUTUwgYXR0cmlidXRlIG5hbWVcbiAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IGJvb2wgQm9vbGVhbiB0byBmb3JjZSB0aGUgYXR0cmlidXRlIG9uIG9yIG9mZi5cbiAgICAgICAqICAgIFdoZW4gdW5zcGVjaWZpZWQsIHRoZSBzdGF0ZSBvZiB0aGUgYXR0cmlidXRlIHdpbGwgYmUgcmV2ZXJzZWQuXG4gICAgICAgKiBAcGFyYW0ge0VsZW1lbnQ9fSBub2RlIE5vZGUgdG8gdGFyZ2V0LiAgRGVmYXVsdHMgdG8gYHRoaXNgLlxuICAgICAgICovXG4gICAgICB0b2dnbGVBdHRyaWJ1dGUobmFtZSwgYm9vbCwgbm9kZSkge1xuICAgICAgICBub2RlID0gLyoqIEB0eXBlIHtFbGVtZW50fSAqLyAobm9kZSB8fCB0aGlzKTtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMSkge1xuICAgICAgICAgIGJvb2wgPSAhbm9kZS5oYXNBdHRyaWJ1dGUobmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJvb2wpIHtcbiAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShuYW1lLCAnJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuXG4gICAgICAvKipcbiAgICAgICAqIFRvZ2dsZXMgYSBDU1MgY2xhc3Mgb24gb3Igb2ZmLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIENTUyBjbGFzcyBuYW1lXG4gICAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBib29sIEJvb2xlYW4gdG8gZm9yY2UgdGhlIGNsYXNzIG9uIG9yIG9mZi5cbiAgICAgICAqICAgIFdoZW4gdW5zcGVjaWZpZWQsIHRoZSBzdGF0ZSBvZiB0aGUgY2xhc3Mgd2lsbCBiZSByZXZlcnNlZC5cbiAgICAgICAqIEBwYXJhbSB7RWxlbWVudD19IG5vZGUgTm9kZSB0byB0YXJnZXQuICBEZWZhdWx0cyB0byBgdGhpc2AuXG4gICAgICAgKi9cbiAgICAgIHRvZ2dsZUNsYXNzKG5hbWUsIGJvb2wsIG5vZGUpIHtcbiAgICAgICAgbm9kZSA9IC8qKiBAdHlwZSB7RWxlbWVudH0gKi8gKG5vZGUgfHwgdGhpcyk7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICBib29sID0gIW5vZGUuY2xhc3NMaXN0LmNvbnRhaW5zKG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChib29sKSB7XG4gICAgICAgICAgbm9kZS5jbGFzc0xpc3QuYWRkKG5hbWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGUuY2xhc3NMaXN0LnJlbW92ZShuYW1lKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENyb3NzLXBsYXRmb3JtIGhlbHBlciBmb3Igc2V0dGluZyBhbiBlbGVtZW50J3MgQ1NTIGB0cmFuc2Zvcm1gIHByb3BlcnR5LlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0cmFuc2Zvcm1UZXh0IFRyYW5zZm9ybSBzZXR0aW5nLlxuICAgICAgICogQHBhcmFtIHtFbGVtZW50PX0gbm9kZSBFbGVtZW50IHRvIGFwcGx5IHRoZSB0cmFuc2Zvcm0gdG8uXG4gICAgICAgKiBEZWZhdWx0cyB0byBgdGhpc2BcbiAgICAgICAqL1xuICAgICAgdHJhbnNmb3JtKHRyYW5zZm9ybVRleHQsIG5vZGUpIHtcbiAgICAgICAgbm9kZSA9IC8qKiBAdHlwZSB7RWxlbWVudH0gKi8gKG5vZGUgfHwgdGhpcyk7XG4gICAgICAgIG5vZGUuc3R5bGUud2Via2l0VHJhbnNmb3JtID0gdHJhbnNmb3JtVGV4dDtcbiAgICAgICAgbm9kZS5zdHlsZS50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1UZXh0O1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENyb3NzLXBsYXRmb3JtIGhlbHBlciBmb3Igc2V0dGluZyBhbiBlbGVtZW50J3MgQ1NTIGB0cmFuc2xhdGUzZGBcbiAgICAgICAqIHByb3BlcnR5LlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IFggb2Zmc2V0LlxuICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHkgWSBvZmZzZXQuXG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0geiBaIG9mZnNldC5cbiAgICAgICAqIEBwYXJhbSB7RWxlbWVudD19IG5vZGUgRWxlbWVudCB0byBhcHBseSB0aGUgdHJhbnNmb3JtIHRvLlxuICAgICAgICogRGVmYXVsdHMgdG8gYHRoaXNgLlxuICAgICAgICovXG4gICAgICB0cmFuc2xhdGUzZCh4LCB5LCB6LCBub2RlKSB7XG4gICAgICAgIG5vZGUgPSAvKiogQHR5cGUge0VsZW1lbnR9ICovIChub2RlIHx8IHRoaXMpO1xuICAgICAgICB0aGlzLnRyYW5zZm9ybSgndHJhbnNsYXRlM2QoJyArIHggKyAnLCcgKyB5ICsgJywnICsgeiArICcpJywgbm9kZSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUmVtb3ZlcyBhbiBpdGVtIGZyb20gYW4gYXJyYXksIGlmIGl0IGV4aXN0cy5cbiAgICAgICAqXG4gICAgICAgKiBJZiB0aGUgYXJyYXkgaXMgc3BlY2lmaWVkIGJ5IHBhdGgsIGEgY2hhbmdlIG5vdGlmaWNhdGlvbiBpc1xuICAgICAgICogZ2VuZXJhdGVkLCBzbyB0aGF0IG9ic2VydmVycywgZGF0YSBiaW5kaW5ncyBhbmQgY29tcHV0ZWRcbiAgICAgICAqIHByb3BlcnRpZXMgd2F0Y2hpbmcgdGhhdCBwYXRoIGNhbiB1cGRhdGUuXG4gICAgICAgKlxuICAgICAgICogSWYgdGhlIGFycmF5IGlzIHBhc3NlZCBkaXJlY3RseSwgKipubyBjaGFuZ2VcbiAgICAgICAqIG5vdGlmaWNhdGlvbiBpcyBnZW5lcmF0ZWQqKi5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZyB8ICFBcnJheTxudW1iZXJ8c3RyaW5nPn0gYXJyYXlPclBhdGggUGF0aCB0byBhcnJheSBmcm9tIHdoaWNoIHRvIHJlbW92ZSB0aGUgaXRlbVxuICAgICAgICogICAob3IgdGhlIGFycmF5IGl0c2VsZikuXG4gICAgICAgKiBAcGFyYW0geyp9IGl0ZW0gSXRlbSB0byByZW1vdmUuXG4gICAgICAgKiBAcmV0dXJuIHtBcnJheX0gQXJyYXkgY29udGFpbmluZyBpdGVtIHJlbW92ZWQuXG4gICAgICAgKi9cbiAgICAgIGFycmF5RGVsZXRlKGFycmF5T3JQYXRoLCBpdGVtKSB7XG4gICAgICAgIGxldCBpbmRleDtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJyYXlPclBhdGgpKSB7XG4gICAgICAgICAgaW5kZXggPSBhcnJheU9yUGF0aC5pbmRleE9mKGl0ZW0pO1xuICAgICAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJyYXlPclBhdGguc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGV0IGFyciA9IFBvbHltZXIuUGF0aC5nZXQodGhpcywgYXJyYXlPclBhdGgpO1xuICAgICAgICAgIGluZGV4ID0gYXJyLmluZGV4T2YoaXRlbSk7XG4gICAgICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNwbGljZShhcnJheU9yUGF0aCwgaW5kZXgsIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgLy8gbG9nZ2luZ1xuXG4gICAgICAvKipcbiAgICAgICAqIEZhY2FkZXMgYGNvbnNvbGUubG9nYC9gd2FybmAvYGVycm9yYCBhcyBvdmVycmlkZSBwb2ludC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbGV2ZWwgT25lIG9mICdsb2cnLCAnd2FybicsICdlcnJvcidcbiAgICAgICAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgQXJyYXkgb2Ygc3RyaW5ncyBvciBvYmplY3RzIHRvIGxvZ1xuICAgICAgICovXG4gICAgICBfbG9nZ2VyKGxldmVsLCBhcmdzKSB7XG4gICAgICAgIC8vIGFjY2VwdCBbJ2ZvbycsICdiYXInXSBhbmQgW1snZm9vJywgJ2JhciddXVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhcmdzKSAmJiBhcmdzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIGFyZ3MgPSBhcmdzWzBdO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaChsZXZlbCkge1xuICAgICAgICAgIGNhc2UgJ2xvZyc6XG4gICAgICAgICAgY2FzZSAnd2Fybic6XG4gICAgICAgICAgY2FzZSAnZXJyb3InOlxuICAgICAgICAgICAgY29uc29sZVtsZXZlbF0oLi4uYXJncyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBGYWNhZGVzIGBjb25zb2xlLmxvZ2AgYXMgYW4gb3ZlcnJpZGUgcG9pbnQuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHsuLi4qfSBhcmdzIEFycmF5IG9mIHN0cmluZ3Mgb3Igb2JqZWN0cyB0byBsb2dcbiAgICAgICAqL1xuICAgICAgX2xvZyguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuX2xvZ2dlcignbG9nJywgYXJncyk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogRmFjYWRlcyBgY29uc29sZS53YXJuYCBhcyBhbiBvdmVycmlkZSBwb2ludC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0gey4uLip9IGFyZ3MgQXJyYXkgb2Ygc3RyaW5ncyBvciBvYmplY3RzIHRvIGxvZ1xuICAgICAgICovXG4gICAgICBfd2FybiguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuX2xvZ2dlcignd2FybicsIGFyZ3MpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEZhY2FkZXMgYGNvbnNvbGUuZXJyb3JgIGFzIGFuIG92ZXJyaWRlIHBvaW50LlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7Li4uKn0gYXJncyBBcnJheSBvZiBzdHJpbmdzIG9yIG9iamVjdHMgdG8gbG9nXG4gICAgICAgKi9cbiAgICAgIF9lcnJvciguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuX2xvZ2dlcignZXJyb3InLCBhcmdzKVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEZvcm1hdHMgYSBtZXNzYWdlIHVzaW5nIHRoZSBlbGVtZW50IHR5cGUgYW4gYSBtZXRob2QgbmFtZS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kTmFtZSBNZXRob2QgbmFtZSB0byBhc3NvY2lhdGUgd2l0aCBtZXNzYWdlXG4gICAgICAgKiBAcGFyYW0gey4uLip9IGFyZ3MgQXJyYXkgb2Ygc3RyaW5ncyBvciBvYmplY3RzIHRvIGxvZ1xuICAgICAgICogQHJldHVybiB7QXJyYXl9IEFycmF5IHdpdGggZm9ybWF0dGluZyBpbmZvcm1hdGlvbiBmb3IgYGNvbnNvbGVgXG4gICAgICAgKiAgIGxvZ2dpbmcuXG4gICAgICAgKi9cbiAgICAgIF9sb2dmKG1ldGhvZE5hbWUsIC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIFsnWyVzOjolc10nLCB0aGlzLmlzLCBtZXRob2ROYW1lLCAuLi5hcmdzXTtcbiAgICAgIH1cblxuICAgIH1cblxuICAgIExlZ2FjeUVsZW1lbnQucHJvdG90eXBlLmlzID0gJyc7XG5cbiAgICByZXR1cm4gTGVnYWN5RWxlbWVudDtcblxuICB9KTtcblxufSkoKTtcbjwvc2NyaXB0PlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi9sZWdhY3kvbGVnYWN5LWVsZW1lbnQtbWl4aW4uaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi91dGlscy9ib290Lmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi91dGlscy9taXhpbi5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vdXRpbHMvZ2VzdHVyZXMuaHRtbFwiPlxuXG48c2NyaXB0PlxuKGZ1bmN0aW9uKCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICAvKipcbiAgICogQGNvbnN0IHtQb2x5bWVyLkdlc3R1cmVzfVxuICAgKi9cbiAgY29uc3QgZ2VzdHVyZXMgPSBQb2x5bWVyLkdlc3R1cmVzO1xuXG4gIC8qKlxuICAgKiBFbGVtZW50IGNsYXNzIG1peGluIHRoYXQgcHJvdmlkZXMgQVBJIGZvciBhZGRpbmcgUG9seW1lcidzIGNyb3NzLXBsYXRmb3JtXG4gICAqIGdlc3R1cmUgZXZlbnRzIHRvIG5vZGVzLlxuICAgKlxuICAgKiBUaGUgQVBJIGlzIGRlc2lnbmVkIHRvIGJlIGNvbXBhdGlibGUgd2l0aCBvdmVycmlkZSBwb2ludHMgaW1wbGVtZW50ZWRcbiAgICogaW4gYFBvbHltZXIuVGVtcGxhdGVTdGFtcGAgc3VjaCB0aGF0IGRlY2xhcmF0aXZlIGV2ZW50IGxpc3RlbmVycyBpblxuICAgKiB0ZW1wbGF0ZXMgd2lsbCBzdXBwb3J0IGdlc3R1cmUgZXZlbnRzIHdoZW4gdGhpcyBtaXhpbiBpcyBhcHBsaWVkIGFsb25nIHdpdGhcbiAgICogYFBvbHltZXIuVGVtcGxhdGVTdGFtcGAuXG4gICAqXG4gICAqIEBtaXhpbkZ1bmN0aW9uXG4gICAqIEBwb2x5bWVyXG4gICAqIEBtZW1iZXJvZiBQb2x5bWVyXG4gICAqIEBzdW1tYXJ5IEVsZW1lbnQgY2xhc3MgbWl4aW4gdGhhdCBwcm92aWRlcyBBUEkgZm9yIGFkZGluZyBQb2x5bWVyJ3MgY3Jvc3MtcGxhdGZvcm1cbiAgICogZ2VzdHVyZSBldmVudHMgdG8gbm9kZXNcbiAgICovXG4gIFBvbHltZXIuR2VzdHVyZUV2ZW50TGlzdGVuZXJzID0gUG9seW1lci5kZWR1cGluZ01peGluKHN1cGVyQ2xhc3MgPT4ge1xuXG4gICAgLyoqXG4gICAgICogQHBvbHltZXJcbiAgICAgKiBAbWl4aW5DbGFzc1xuICAgICAqIEBpbXBsZW1lbnRzIHtQb2x5bWVyX0dlc3R1cmVFdmVudExpc3RlbmVyc31cbiAgICAgKi9cbiAgICBjbGFzcyBHZXN0dXJlRXZlbnRMaXN0ZW5lcnMgZXh0ZW5kcyBzdXBlckNsYXNzIHtcblxuICAgICAgX2FkZEV2ZW50TGlzdGVuZXJUb05vZGUobm9kZSwgZXZlbnROYW1lLCBoYW5kbGVyKSB7XG4gICAgICAgIGlmICghZ2VzdHVyZXMuYWRkTGlzdGVuZXIobm9kZSwgZXZlbnROYW1lLCBoYW5kbGVyKSkge1xuICAgICAgICAgIHN1cGVyLl9hZGRFdmVudExpc3RlbmVyVG9Ob2RlKG5vZGUsIGV2ZW50TmFtZSwgaGFuZGxlcik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgX3JlbW92ZUV2ZW50TGlzdGVuZXJGcm9tTm9kZShub2RlLCBldmVudE5hbWUsIGhhbmRsZXIpIHtcbiAgICAgICAgaWYgKCFnZXN0dXJlcy5yZW1vdmVMaXN0ZW5lcihub2RlLCBldmVudE5hbWUsIGhhbmRsZXIpKSB7XG4gICAgICAgICAgc3VwZXIuX3JlbW92ZUV2ZW50TGlzdGVuZXJGcm9tTm9kZShub2RlLCBldmVudE5hbWUsIGhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICB9XG5cbiAgICByZXR1cm4gR2VzdHVyZUV2ZW50TGlzdGVuZXJzO1xuXG4gIH0pO1xuXG59KSgpO1xuPC9zY3JpcHQ+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL3BvbHltZXIvbGliL21peGlucy9nZXN0dXJlLWV2ZW50LWxpc3RlbmVycy5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cImJvb3QuaHRtbFwiPlxuPHNjcmlwdD5cbihmdW5jdGlvbigpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgZnVuY3Rpb24gbmV3U3BsaWNlKGluZGV4LCByZW1vdmVkLCBhZGRlZENvdW50KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgIHJlbW92ZWQ6IHJlbW92ZWQsXG4gICAgICBhZGRlZENvdW50OiBhZGRlZENvdW50XG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0IEVESVRfTEVBVkUgPSAwO1xuICBjb25zdCBFRElUX1VQREFURSA9IDE7XG4gIGNvbnN0IEVESVRfQUREID0gMjtcbiAgY29uc3QgRURJVF9ERUxFVEUgPSAzO1xuXG4gIC8vIE5vdGU6IFRoaXMgZnVuY3Rpb24gaXMgKmJhc2VkKiBvbiB0aGUgY29tcHV0YXRpb24gb2YgdGhlIExldmVuc2h0ZWluXG4gIC8vIFwiZWRpdFwiIGRpc3RhbmNlLiBUaGUgb25lIGNoYW5nZSBpcyB0aGF0IFwidXBkYXRlc1wiIGFyZSB0cmVhdGVkIGFzIHR3b1xuICAvLyBlZGl0cyAtIG5vdCBvbmUuIFdpdGggQXJyYXkgc3BsaWNlcywgYW4gdXBkYXRlIGlzIHJlYWxseSBhIGRlbGV0ZVxuICAvLyBmb2xsb3dlZCBieSBhbiBhZGQuIEJ5IHJldGFpbmluZyB0aGlzLCB3ZSBvcHRpbWl6ZSBmb3IgXCJrZWVwaW5nXCIgdGhlXG4gIC8vIG1heGltdW0gYXJyYXkgaXRlbXMgaW4gdGhlIG9yaWdpbmFsIGFycmF5LiBGb3IgZXhhbXBsZTpcbiAgLy9cbiAgLy8gICAneHh4eDEyMycgLT4gJzEyM3l5eXknXG4gIC8vXG4gIC8vIFdpdGggMS1lZGl0IHVwZGF0ZXMsIHRoZSBzaG9ydGVzdCBwYXRoIHdvdWxkIGJlIGp1c3QgdG8gdXBkYXRlIGFsbCBzZXZlblxuICAvLyBjaGFyYWN0ZXJzLiBXaXRoIDItZWRpdCB1cGRhdGVzLCB3ZSBkZWxldGUgNCwgbGVhdmUgMywgYW5kIGFkZCA0LiBUaGlzXG4gIC8vIGxlYXZlcyB0aGUgc3Vic3RyaW5nICcxMjMnIGludGFjdC5cbiAgZnVuY3Rpb24gY2FsY0VkaXREaXN0YW5jZXMoY3VycmVudCwgY3VycmVudFN0YXJ0LCBjdXJyZW50RW5kLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2xkLCBvbGRTdGFydCwgb2xkRW5kKSB7XG4gICAgLy8gXCJEZWxldGlvblwiIGNvbHVtbnNcbiAgICBsZXQgcm93Q291bnQgPSBvbGRFbmQgLSBvbGRTdGFydCArIDE7XG4gICAgbGV0IGNvbHVtbkNvdW50ID0gY3VycmVudEVuZCAtIGN1cnJlbnRTdGFydCArIDE7XG4gICAgbGV0IGRpc3RhbmNlcyA9IG5ldyBBcnJheShyb3dDb3VudCk7XG5cbiAgICAvLyBcIkFkZGl0aW9uXCIgcm93cy4gSW5pdGlhbGl6ZSBudWxsIGNvbHVtbi5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJvd0NvdW50OyBpKyspIHtcbiAgICAgIGRpc3RhbmNlc1tpXSA9IG5ldyBBcnJheShjb2x1bW5Db3VudCk7XG4gICAgICBkaXN0YW5jZXNbaV1bMF0gPSBpO1xuICAgIH1cblxuICAgIC8vIEluaXRpYWxpemUgbnVsbCByb3dcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNvbHVtbkNvdW50OyBqKyspXG4gICAgICBkaXN0YW5jZXNbMF1bal0gPSBqO1xuXG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCByb3dDb3VudDsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqID0gMTsgaiA8IGNvbHVtbkNvdW50OyBqKyspIHtcbiAgICAgICAgaWYgKGVxdWFscyhjdXJyZW50W2N1cnJlbnRTdGFydCArIGogLSAxXSwgb2xkW29sZFN0YXJ0ICsgaSAtIDFdKSlcbiAgICAgICAgICBkaXN0YW5jZXNbaV1bal0gPSBkaXN0YW5jZXNbaSAtIDFdW2ogLSAxXTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgbGV0IG5vcnRoID0gZGlzdGFuY2VzW2kgLSAxXVtqXSArIDE7XG4gICAgICAgICAgbGV0IHdlc3QgPSBkaXN0YW5jZXNbaV1baiAtIDFdICsgMTtcbiAgICAgICAgICBkaXN0YW5jZXNbaV1bal0gPSBub3J0aCA8IHdlc3QgPyBub3J0aCA6IHdlc3Q7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZGlzdGFuY2VzO1xuICB9XG5cbiAgLy8gVGhpcyBzdGFydHMgYXQgdGhlIGZpbmFsIHdlaWdodCwgYW5kIHdhbGtzIFwiYmFja3dhcmRcIiBieSBmaW5kaW5nXG4gIC8vIHRoZSBtaW5pbXVtIHByZXZpb3VzIHdlaWdodCByZWN1cnNpdmVseSB1bnRpbCB0aGUgb3JpZ2luIG9mIHRoZSB3ZWlnaHRcbiAgLy8gbWF0cml4LlxuICBmdW5jdGlvbiBzcGxpY2VPcGVyYXRpb25zRnJvbUVkaXREaXN0YW5jZXMoZGlzdGFuY2VzKSB7XG4gICAgbGV0IGkgPSBkaXN0YW5jZXMubGVuZ3RoIC0gMTtcbiAgICBsZXQgaiA9IGRpc3RhbmNlc1swXS5sZW5ndGggLSAxO1xuICAgIGxldCBjdXJyZW50ID0gZGlzdGFuY2VzW2ldW2pdO1xuICAgIGxldCBlZGl0cyA9IFtdO1xuICAgIHdoaWxlIChpID4gMCB8fCBqID4gMCkge1xuICAgICAgaWYgKGkgPT0gMCkge1xuICAgICAgICBlZGl0cy5wdXNoKEVESVRfQUREKTtcbiAgICAgICAgai0tO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChqID09IDApIHtcbiAgICAgICAgZWRpdHMucHVzaChFRElUX0RFTEVURSk7XG4gICAgICAgIGktLTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBsZXQgbm9ydGhXZXN0ID0gZGlzdGFuY2VzW2kgLSAxXVtqIC0gMV07XG4gICAgICBsZXQgd2VzdCA9IGRpc3RhbmNlc1tpIC0gMV1bal07XG4gICAgICBsZXQgbm9ydGggPSBkaXN0YW5jZXNbaV1baiAtIDFdO1xuXG4gICAgICBsZXQgbWluO1xuICAgICAgaWYgKHdlc3QgPCBub3J0aClcbiAgICAgICAgbWluID0gd2VzdCA8IG5vcnRoV2VzdCA/IHdlc3QgOiBub3J0aFdlc3Q7XG4gICAgICBlbHNlXG4gICAgICAgIG1pbiA9IG5vcnRoIDwgbm9ydGhXZXN0ID8gbm9ydGggOiBub3J0aFdlc3Q7XG5cbiAgICAgIGlmIChtaW4gPT0gbm9ydGhXZXN0KSB7XG4gICAgICAgIGlmIChub3J0aFdlc3QgPT0gY3VycmVudCkge1xuICAgICAgICAgIGVkaXRzLnB1c2goRURJVF9MRUFWRSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZWRpdHMucHVzaChFRElUX1VQREFURSk7XG4gICAgICAgICAgY3VycmVudCA9IG5vcnRoV2VzdDtcbiAgICAgICAgfVxuICAgICAgICBpLS07XG4gICAgICAgIGotLTtcbiAgICAgIH0gZWxzZSBpZiAobWluID09IHdlc3QpIHtcbiAgICAgICAgZWRpdHMucHVzaChFRElUX0RFTEVURSk7XG4gICAgICAgIGktLTtcbiAgICAgICAgY3VycmVudCA9IHdlc3Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlZGl0cy5wdXNoKEVESVRfQUREKTtcbiAgICAgICAgai0tO1xuICAgICAgICBjdXJyZW50ID0gbm9ydGg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZWRpdHMucmV2ZXJzZSgpO1xuICAgIHJldHVybiBlZGl0cztcbiAgfVxuXG4gIC8qKlxuICAgKiBTcGxpY2UgUHJvamVjdGlvbiBmdW5jdGlvbnM6XG4gICAqXG4gICAqIEEgc3BsaWNlIG1hcCBpcyBhIHJlcHJlc2VudGF0aW9uIG9mIGhvdyBhIHByZXZpb3VzIGFycmF5IG9mIGl0ZW1zXG4gICAqIHdhcyB0cmFuc2Zvcm1lZCBpbnRvIGEgbmV3IGFycmF5IG9mIGl0ZW1zLiBDb25jZXB0dWFsbHkgaXQgaXMgYSBsaXN0IG9mXG4gICAqIHR1cGxlcyBvZlxuICAgKlxuICAgKiAgIDxpbmRleCwgcmVtb3ZlZCwgYWRkZWRDb3VudD5cbiAgICpcbiAgICogd2hpY2ggYXJlIGtlcHQgaW4gYXNjZW5kaW5nIGluZGV4IG9yZGVyIG9mLiBUaGUgdHVwbGUgcmVwcmVzZW50cyB0aGF0IGF0XG4gICAqIHRoZSB8aW5kZXh8LCB8cmVtb3ZlZHwgc2VxdWVuY2Ugb2YgaXRlbXMgd2VyZSByZW1vdmVkLCBhbmQgY291bnRpbmcgZm9yd2FyZFxuICAgKiBmcm9tIHxpbmRleHwsIHxhZGRlZENvdW50fCBpdGVtcyB3ZXJlIGFkZGVkLlxuICAgKi9cblxuICAvKipcbiAgICogTGFja2luZyBpbmRpdmlkdWFsIHNwbGljZSBtdXRhdGlvbiBpbmZvcm1hdGlvbiwgdGhlIG1pbmltYWwgc2V0IG9mXG4gICAqIHNwbGljZXMgY2FuIGJlIHN5bnRoZXNpemVkIGdpdmVuIHRoZSBwcmV2aW91cyBzdGF0ZSBhbmQgZmluYWwgc3RhdGUgb2YgYW5cbiAgICogYXJyYXkuIFRoZSBiYXNpYyBhcHByb2FjaCBpcyB0byBjYWxjdWxhdGUgdGhlIGVkaXQgZGlzdGFuY2UgbWF0cml4IGFuZFxuICAgKiBjaG9vc2UgdGhlIHNob3J0ZXN0IHBhdGggdGhyb3VnaCBpdC5cbiAgICpcbiAgICogQ29tcGxleGl0eTogTyhsICogcClcbiAgICogICBsOiBUaGUgbGVuZ3RoIG9mIHRoZSBjdXJyZW50IGFycmF5XG4gICAqICAgcDogVGhlIGxlbmd0aCBvZiB0aGUgb2xkIGFycmF5XG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IGN1cnJlbnQgVGhlIGN1cnJlbnQgXCJjaGFuZ2VkXCIgYXJyYXkgZm9yIHdoaWNoIHRvXG4gICAqIGNhbGN1bGF0ZSBzcGxpY2VzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gY3VycmVudFN0YXJ0IFN0YXJ0aW5nIGluZGV4IGluIHRoZSBgY3VycmVudGAgYXJyYXkgZm9yXG4gICAqIHdoaWNoIHNwbGljZXMgYXJlIGNhbGN1bGF0ZWQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjdXJyZW50RW5kIEVuZGluZyBpbmRleCBpbiB0aGUgYGN1cnJlbnRgIGFycmF5IGZvclxuICAgKiB3aGljaCBzcGxpY2VzIGFyZSBjYWxjdWxhdGVkLlxuICAgKiBAcGFyYW0ge0FycmF5fSBvbGQgVGhlIG9yaWdpbmFsIFwidW5jaGFuZ2VkXCIgYXJyYXkgdG8gY29tcGFyZSBgY3VycmVudGBcbiAgICogYWdhaW5zdCB0byBkZXRlcm1pbmUgc3BsaWNlcy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG9sZFN0YXJ0IFN0YXJ0aW5nIGluZGV4IGluIHRoZSBgb2xkYCBhcnJheSBmb3JcbiAgICogd2hpY2ggc3BsaWNlcyBhcmUgY2FsY3VsYXRlZC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG9sZEVuZCBFbmRpbmcgaW5kZXggaW4gdGhlIGBvbGRgIGFycmF5IGZvclxuICAgKiB3aGljaCBzcGxpY2VzIGFyZSBjYWxjdWxhdGVkLlxuICAgKiBAcmV0dXJuIHtBcnJheX0gUmV0dXJucyBhbiBhcnJheSBvZiBzcGxpY2UgcmVjb3JkIG9iamVjdHMuIEVhY2ggb2YgdGhlc2VcbiAgICogY29udGFpbnM6IGBpbmRleGAgdGhlIGxvY2F0aW9uIHdoZXJlIHRoZSBzcGxpY2Ugb2NjdXJyZWQ7IGByZW1vdmVkYFxuICAgKiB0aGUgYXJyYXkgb2YgcmVtb3ZlZCBpdGVtcyBmcm9tIHRoaXMgbG9jYXRpb247IGBhZGRlZENvdW50YCB0aGUgbnVtYmVyXG4gICAqIG9mIGl0ZW1zIGFkZGVkIGF0IHRoaXMgbG9jYXRpb24uXG4gICAqL1xuICBmdW5jdGlvbiBjYWxjU3BsaWNlcyhjdXJyZW50LCBjdXJyZW50U3RhcnQsIGN1cnJlbnRFbmQsXG4gICAgICAgICAgICAgICAgICAgICAgICBvbGQsIG9sZFN0YXJ0LCBvbGRFbmQpIHtcbiAgICBsZXQgcHJlZml4Q291bnQgPSAwO1xuICAgIGxldCBzdWZmaXhDb3VudCA9IDA7XG4gICAgbGV0IHNwbGljZTtcblxuICAgIGxldCBtaW5MZW5ndGggPSBNYXRoLm1pbihjdXJyZW50RW5kIC0gY3VycmVudFN0YXJ0LCBvbGRFbmQgLSBvbGRTdGFydCk7XG4gICAgaWYgKGN1cnJlbnRTdGFydCA9PSAwICYmIG9sZFN0YXJ0ID09IDApXG4gICAgICBwcmVmaXhDb3VudCA9IHNoYXJlZFByZWZpeChjdXJyZW50LCBvbGQsIG1pbkxlbmd0aCk7XG5cbiAgICBpZiAoY3VycmVudEVuZCA9PSBjdXJyZW50Lmxlbmd0aCAmJiBvbGRFbmQgPT0gb2xkLmxlbmd0aClcbiAgICAgIHN1ZmZpeENvdW50ID0gc2hhcmVkU3VmZml4KGN1cnJlbnQsIG9sZCwgbWluTGVuZ3RoIC0gcHJlZml4Q291bnQpO1xuXG4gICAgY3VycmVudFN0YXJ0ICs9IHByZWZpeENvdW50O1xuICAgIG9sZFN0YXJ0ICs9IHByZWZpeENvdW50O1xuICAgIGN1cnJlbnRFbmQgLT0gc3VmZml4Q291bnQ7XG4gICAgb2xkRW5kIC09IHN1ZmZpeENvdW50O1xuXG4gICAgaWYgKGN1cnJlbnRFbmQgLSBjdXJyZW50U3RhcnQgPT0gMCAmJiBvbGRFbmQgLSBvbGRTdGFydCA9PSAwKVxuICAgICAgcmV0dXJuIFtdO1xuXG4gICAgaWYgKGN1cnJlbnRTdGFydCA9PSBjdXJyZW50RW5kKSB7XG4gICAgICBzcGxpY2UgPSBuZXdTcGxpY2UoY3VycmVudFN0YXJ0LCBbXSwgMCk7XG4gICAgICB3aGlsZSAob2xkU3RhcnQgPCBvbGRFbmQpXG4gICAgICAgIHNwbGljZS5yZW1vdmVkLnB1c2gob2xkW29sZFN0YXJ0KytdKTtcblxuICAgICAgcmV0dXJuIFsgc3BsaWNlIF07XG4gICAgfSBlbHNlIGlmIChvbGRTdGFydCA9PSBvbGRFbmQpXG4gICAgICByZXR1cm4gWyBuZXdTcGxpY2UoY3VycmVudFN0YXJ0LCBbXSwgY3VycmVudEVuZCAtIGN1cnJlbnRTdGFydCkgXTtcblxuICAgIGxldCBvcHMgPSBzcGxpY2VPcGVyYXRpb25zRnJvbUVkaXREaXN0YW5jZXMoXG4gICAgICAgIGNhbGNFZGl0RGlzdGFuY2VzKGN1cnJlbnQsIGN1cnJlbnRTdGFydCwgY3VycmVudEVuZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbGQsIG9sZFN0YXJ0LCBvbGRFbmQpKTtcblxuICAgIHNwbGljZSA9IHVuZGVmaW5lZDtcbiAgICBsZXQgc3BsaWNlcyA9IFtdO1xuICAgIGxldCBpbmRleCA9IGN1cnJlbnRTdGFydDtcbiAgICBsZXQgb2xkSW5kZXggPSBvbGRTdGFydDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgc3dpdGNoKG9wc1tpXSkge1xuICAgICAgICBjYXNlIEVESVRfTEVBVkU6XG4gICAgICAgICAgaWYgKHNwbGljZSkge1xuICAgICAgICAgICAgc3BsaWNlcy5wdXNoKHNwbGljZSk7XG4gICAgICAgICAgICBzcGxpY2UgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgICBvbGRJbmRleCsrO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEVESVRfVVBEQVRFOlxuICAgICAgICAgIGlmICghc3BsaWNlKVxuICAgICAgICAgICAgc3BsaWNlID0gbmV3U3BsaWNlKGluZGV4LCBbXSwgMCk7XG5cbiAgICAgICAgICBzcGxpY2UuYWRkZWRDb3VudCsrO1xuICAgICAgICAgIGluZGV4Kys7XG5cbiAgICAgICAgICBzcGxpY2UucmVtb3ZlZC5wdXNoKG9sZFtvbGRJbmRleF0pO1xuICAgICAgICAgIG9sZEluZGV4Kys7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgRURJVF9BREQ6XG4gICAgICAgICAgaWYgKCFzcGxpY2UpXG4gICAgICAgICAgICBzcGxpY2UgPSBuZXdTcGxpY2UoaW5kZXgsIFtdLCAwKTtcblxuICAgICAgICAgIHNwbGljZS5hZGRlZENvdW50Kys7XG4gICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBFRElUX0RFTEVURTpcbiAgICAgICAgICBpZiAoIXNwbGljZSlcbiAgICAgICAgICAgIHNwbGljZSA9IG5ld1NwbGljZShpbmRleCwgW10sIDApO1xuXG4gICAgICAgICAgc3BsaWNlLnJlbW92ZWQucHVzaChvbGRbb2xkSW5kZXhdKTtcbiAgICAgICAgICBvbGRJbmRleCsrO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzcGxpY2UpIHtcbiAgICAgIHNwbGljZXMucHVzaChzcGxpY2UpO1xuICAgIH1cbiAgICByZXR1cm4gc3BsaWNlcztcbiAgfVxuXG4gIGZ1bmN0aW9uIHNoYXJlZFByZWZpeChjdXJyZW50LCBvbGQsIHNlYXJjaExlbmd0aCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VhcmNoTGVuZ3RoOyBpKyspXG4gICAgICBpZiAoIWVxdWFscyhjdXJyZW50W2ldLCBvbGRbaV0pKVxuICAgICAgICByZXR1cm4gaTtcbiAgICByZXR1cm4gc2VhcmNoTGVuZ3RoO1xuICB9XG5cbiAgZnVuY3Rpb24gc2hhcmVkU3VmZml4KGN1cnJlbnQsIG9sZCwgc2VhcmNoTGVuZ3RoKSB7XG4gICAgbGV0IGluZGV4MSA9IGN1cnJlbnQubGVuZ3RoO1xuICAgIGxldCBpbmRleDIgPSBvbGQubGVuZ3RoO1xuICAgIGxldCBjb3VudCA9IDA7XG4gICAgd2hpbGUgKGNvdW50IDwgc2VhcmNoTGVuZ3RoICYmIGVxdWFscyhjdXJyZW50Wy0taW5kZXgxXSwgb2xkWy0taW5kZXgyXSkpXG4gICAgICBjb3VudCsrO1xuXG4gICAgcmV0dXJuIGNvdW50O1xuICB9XG5cbiAgZnVuY3Rpb24gY2FsY3VsYXRlU3BsaWNlcyhjdXJyZW50LCBwcmV2aW91cykge1xuICAgIHJldHVybiBjYWxjU3BsaWNlcyhjdXJyZW50LCAwLCBjdXJyZW50Lmxlbmd0aCwgcHJldmlvdXMsIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldmlvdXMubGVuZ3RoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGVxdWFscyhjdXJyZW50VmFsdWUsIHByZXZpb3VzVmFsdWUpIHtcbiAgICByZXR1cm4gY3VycmVudFZhbHVlID09PSBwcmV2aW91c1ZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBuYW1lc3BhY2VcbiAgICogQG1lbWJlcm9mIFBvbHltZXJcbiAgICogQHN1bW1hcnkgTW9kdWxlIHRoYXQgcHJvdmlkZXMgdXRpbGl0aWVzIGZvciBkaWZmaW5nIGFycmF5cy5cbiAgICovXG4gIFBvbHltZXIuQXJyYXlTcGxpY2UgPSB7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBhcnJheSBvZiBzcGxpY2UgcmVjb3JkcyBpbmRpY2F0aW5nIHRoZSBtaW5pbXVtIGVkaXRzIHJlcXVpcmVkXG4gICAgICogdG8gdHJhbnNmb3JtIHRoZSBgcHJldmlvdXNgIGFycmF5IGludG8gdGhlIGBjdXJyZW50YCBhcnJheS5cbiAgICAgKlxuICAgICAqIFNwbGljZSByZWNvcmRzIGFyZSBvcmRlcmVkIGJ5IGluZGV4IGFuZCBjb250YWluIHRoZSBmb2xsb3dpbmcgZmllbGRzOlxuICAgICAqIC0gYGluZGV4YDogaW5kZXggd2hlcmUgZWRpdCBzdGFydGVkXG4gICAgICogLSBgcmVtb3ZlZGA6IGFycmF5IG9mIHJlbW92ZWQgaXRlbXMgZnJvbSB0aGlzIGluZGV4XG4gICAgICogLSBgYWRkZWRDb3VudGA6IG51bWJlciBvZiBpdGVtcyBhZGRlZCBhdCB0aGlzIGluZGV4XG4gICAgICpcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGJhc2VkIG9uIHRoZSBMZXZlbnNodGVpbiBcIm1pbmltdW0gZWRpdCBkaXN0YW5jZVwiXG4gICAgICogYWxnb3JpdGhtLiBOb3RlIHRoYXQgdXBkYXRlcyBhcmUgdHJlYXRlZCBhcyByZW1vdmFsIGZvbGxvd2VkIGJ5IGFkZGl0aW9uLlxuICAgICAqXG4gICAgICogVGhlIHdvcnN0LWNhc2UgdGltZSBjb21wbGV4aXR5IG9mIHRoaXMgYWxnb3JpdGhtIGlzIGBPKGwgKiBwKWBcbiAgICAgKiAgIGw6IFRoZSBsZW5ndGggb2YgdGhlIGN1cnJlbnQgYXJyYXlcbiAgICAgKiAgIHA6IFRoZSBsZW5ndGggb2YgdGhlIHByZXZpb3VzIGFycmF5XG4gICAgICpcbiAgICAgKiBIb3dldmVyLCB0aGUgd29yc3QtY2FzZSBjb21wbGV4aXR5IGlzIHJlZHVjZWQgYnkgYW4gYE8obilgIG9wdGltaXphdGlvblxuICAgICAqIHRvIGRldGVjdCBhbnkgc2hhcmVkIHByZWZpeCAmIHN1ZmZpeCBiZXR3ZWVuIHRoZSB0d28gYXJyYXlzIGFuZCBvbmx5XG4gICAgICogcGVyZm9ybSB0aGUgbW9yZSBleHBlbnNpdmUgbWluaW11bSBlZGl0IGRpc3RhbmNlIGNhbGN1bGF0aW9uIG92ZXIgdGhlXG4gICAgICogbm9uLXNoYXJlZCBwb3J0aW9ucyBvZiB0aGUgYXJyYXlzLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIFBvbHltZXIuQXJyYXlTcGxpY2VcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBjdXJyZW50IFRoZSBcImNoYW5nZWRcIiBhcnJheSBmb3Igd2hpY2ggc3BsaWNlcyB3aWxsIGJlXG4gICAgICogY2FsY3VsYXRlZC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwcmV2aW91cyBUaGUgXCJ1bmNoYW5nZWRcIiBvcmlnaW5hbCBhcnJheSB0byBjb21wYXJlXG4gICAgICogYGN1cnJlbnRgIGFnYWluc3QgdG8gZGV0ZXJtaW5lIHRoZSBzcGxpY2VzLlxuICAgICAqIEByZXR1cm4ge0FycmF5fSBSZXR1cm5zIGFuIGFycmF5IG9mIHNwbGljZSByZWNvcmQgb2JqZWN0cy4gRWFjaCBvZiB0aGVzZVxuICAgICAqIGNvbnRhaW5zOiBgaW5kZXhgIHRoZSBsb2NhdGlvbiB3aGVyZSB0aGUgc3BsaWNlIG9jY3VycmVkOyBgcmVtb3ZlZGBcbiAgICAgKiB0aGUgYXJyYXkgb2YgcmVtb3ZlZCBpdGVtcyBmcm9tIHRoaXMgbG9jYXRpb247IGBhZGRlZENvdW50YCB0aGUgbnVtYmVyXG4gICAgICogb2YgaXRlbXMgYWRkZWQgYXQgdGhpcyBsb2NhdGlvbi5cbiAgICAgKi9cbiAgICBjYWxjdWxhdGVTcGxpY2VzXG4gIH1cblxufSkoKTtcbjwvc2NyaXB0PlxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvdXRpbHMvYXJyYXktc3BsaWNlLmh0bWwiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi9hcHAtc2Nyb2xsLWVmZmVjdHMtYmVoYXZpb3IuaHRtbFwiPlxuXG48c2NyaXB0PlxuICAvKipcbiAgICogV2hpbGUgc2Nyb2xsaW5nIGRvd24sIGZhZGUgaW4gdGhlIHJlYXIgYmFja2dyb3VuZCBsYXllciBhbmQgZmFkZSBvdXQgdGhlIGZyb250IGJhY2tncm91bmRcbiAgICogbGF5ZXIgKG9wYWNpdHkgaW50ZXJwb2xhdGVkIGJhc2VkIG9uIHNjcm9sbCBwb3NpdGlvbikuXG4gICAqL1xuICBQb2x5bWVyLkFwcExheW91dC5yZWdpc3RlckVmZmVjdCgnYmxlbmQtYmFja2dyb3VuZCcsIHtcbiAgICAvKiogQHRoaXMgUG9seW1lci5BcHBMYXlvdXQuRWxlbWVudFdpdGhCYWNrZ3JvdW5kICovXG4gICAgc2V0VXA6IGZ1bmN0aW9uIHNldFVwKCkge1xuICAgICAgdmFyIGZ4ID0ge307XG4gICAgICBmeC5iYWNrZ3JvdW5kRnJvbnRMYXllciA9IHRoaXMuX2dldERPTVJlZignYmFja2dyb3VuZEZyb250TGF5ZXInKTtcbiAgICAgIGZ4LmJhY2tncm91bmRSZWFyTGF5ZXIgPSB0aGlzLl9nZXRET01SZWYoJ2JhY2tncm91bmRSZWFyTGF5ZXInKTtcbiAgICAgIGZ4LmJhY2tncm91bmRGcm9udExheWVyLnN0eWxlLndpbGxDaGFuZ2UgPSAnb3BhY2l0eSc7XG4gICAgICBmeC5iYWNrZ3JvdW5kRnJvbnRMYXllci5zdHlsZS50cmFuc2Zvcm0gPSAndHJhbnNsYXRlWigwKSc7XG4gICAgICBmeC5iYWNrZ3JvdW5kUmVhckxheWVyLnN0eWxlLndpbGxDaGFuZ2UgPSAnb3BhY2l0eSc7XG4gICAgICBmeC5iYWNrZ3JvdW5kUmVhckxheWVyLnN0eWxlLnRyYW5zZm9ybSA9ICd0cmFuc2xhdGVaKDApJztcbiAgICAgIGZ4LmJhY2tncm91bmRSZWFyTGF5ZXIuc3R5bGUub3BhY2l0eSA9IDA7XG4gICAgICB0aGlzLl9meEJsZW5kQmFja2dyb3VuZCA9IGZ4O1xuICAgIH0sXG4gICAgLyoqIEB0aGlzIFBvbHltZXIuQXBwTGF5b3V0LkVsZW1lbnRXaXRoQmFja2dyb3VuZCAqL1xuICAgIHJ1bjogZnVuY3Rpb24gcnVuKHAsIHkpIHtcbiAgICAgIHZhciBmeCA9IHRoaXMuX2Z4QmxlbmRCYWNrZ3JvdW5kO1xuICAgICAgZnguYmFja2dyb3VuZEZyb250TGF5ZXIuc3R5bGUub3BhY2l0eSA9IDEgLSBwO1xuICAgICAgZnguYmFja2dyb3VuZFJlYXJMYXllci5zdHlsZS5vcGFjaXR5ID0gcDtcbiAgICB9LFxuICAgIC8qKiBAdGhpcyBQb2x5bWVyLkFwcExheW91dC5FbGVtZW50V2l0aEJhY2tncm91bmQgKi9cbiAgICB0ZWFyRG93bjogZnVuY3Rpb24gdGVhckRvd24oKSB7XG4gICAgICBkZWxldGUgdGhpcy5fZnhCbGVuZEJhY2tncm91bmQ7XG4gICAgfVxuICB9KTtcbjwvc2NyaXB0PlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9hcHAtbGF5b3V0L2FwcC1zY3JvbGwtZWZmZWN0cy9lZmZlY3RzL2JsZW5kLWJhY2tncm91bmQuaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTYgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cblxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL2FwcC1zY3JvbGwtZWZmZWN0cy1iZWhhdmlvci5odG1sXCI+XG5cbjxzY3JpcHQ+XG4gIC8qKlxuICAgKiBUb2dnbGVzIHRoZSBzaGFkb3cgcHJvcGVydHkgaW4gYXBwLWhlYWRlciB3aGVuIGNvbnRlbnQgaXMgc2Nyb2xsZWQgdG8gY3JlYXRlIGEgc2Vuc2Ugb2YgZGVwdGhcbiAgICogYmV0d2VlbiB0aGUgZWxlbWVudCBhbmQgdGhlIGNvbnRlbnQgdW5kZXJuZWF0aC5cbiAgICovXG4gIFBvbHltZXIuQXBwTGF5b3V0LnJlZ2lzdGVyRWZmZWN0KCd3YXRlcmZhbGwnLCB7XG4gICAgLyoqXG4gICAgICogIEB0aGlzIFBvbHltZXIuQXBwTGF5b3V0LkVsZW1lbnRXaXRoQmFja2dyb3VuZFxuICAgICAqL1xuICAgIHJ1bjogZnVuY3Rpb24gcnVuKCkge1xuICAgICAgdGhpcy5zaGFkb3cgPSB0aGlzLmlzT25TY3JlZW4oKSAmJiB0aGlzLmlzQ29udGVudEJlbG93KCk7XG4gICAgfVxuICB9KTtcbjwvc2NyaXB0PlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9hcHAtbGF5b3V0L2FwcC1zY3JvbGwtZWZmZWN0cy9lZmZlY3RzL3dhdGVyZmFsbC5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNiBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuXG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vYXBwLXNjcm9sbC1lZmZlY3RzLWJlaGF2aW9yLmh0bWxcIj5cblxuPHNjcmlwdD5cbiAgKGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIGludGVycG9sYXRlKHByb2dyZXNzLCBwb2ludHMsIGZuLCBjdHgpIHtcbiAgICAgIGZuLmFwcGx5KGN0eCwgcG9pbnRzLm1hcChmdW5jdGlvbihwb2ludCkge1xuICAgICAgICByZXR1cm4gcG9pbnRbMF0gKyAocG9pbnRbMV0gLSBwb2ludFswXSkgKiBwcm9ncmVzcztcbiAgICAgIH0pKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm0gdGhlIGZvbnQgc2l6ZSBvZiBhIGRlc2lnbmF0ZWQgdGl0bGUgZWxlbWVudCBiZXR3ZWVuIHR3byB2YWx1ZXMgYmFzZWQgb24gdGhlIHNjcm9sbFxuICAgICAqIHBvc2l0aW9uLlxuICAgICAqL1xuICAgIFBvbHltZXIuQXBwTGF5b3V0LnJlZ2lzdGVyRWZmZWN0KCdyZXNpemUtdGl0bGUnLCB7XG4gICAgICAvKiogQHRoaXMgUG9seW1lci5BcHBMYXlvdXQuRWxlbWVudFdpdGhCYWNrZ3JvdW5kICovXG4gICAgICBzZXRVcDogZnVuY3Rpb24gc2V0VXAoKSB7XG4gICAgICAgIHZhciB0aXRsZSA9IHRoaXMuX2dldERPTVJlZignbWFpblRpdGxlJyk7XG4gICAgICAgIHZhciBjb25kZW5zZWRUaXRsZSA9IHRoaXMuX2dldERPTVJlZignY29uZGVuc2VkVGl0bGUnKTtcblxuICAgICAgICBpZiAoIWNvbmRlbnNlZFRpdGxlKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKCdTY3JvbGwgZWZmZWN0IGByZXNpemUtdGl0bGVgOiB1bmRlZmluZWQgYGNvbmRlbnNlZC10aXRsZWAnKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aXRsZSkge1xuICAgICAgICAgIGNvbnNvbGUud2FybignU2Nyb2xsIGVmZmVjdCBgcmVzaXplLXRpdGxlYDogdW5kZWZpbmVkIGBtYWluLXRpdGxlYCcpO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbmRlbnNlZFRpdGxlLnN0eWxlLndpbGxDaGFuZ2UgPSAnb3BhY2l0eSc7XG4gICAgICAgIGNvbmRlbnNlZFRpdGxlLnN0eWxlLndlYmtpdFRyYW5zZm9ybSA9ICd0cmFuc2xhdGVaKDApJztcbiAgICAgICAgY29uZGVuc2VkVGl0bGUuc3R5bGUudHJhbnNmb3JtID0gJ3RyYW5zbGF0ZVooMCknO1xuICAgICAgICBjb25kZW5zZWRUaXRsZS5zdHlsZS53ZWJraXRUcmFuc2Zvcm1PcmlnaW4gPSAnbGVmdCB0b3AnO1xuICAgICAgICBjb25kZW5zZWRUaXRsZS5zdHlsZS50cmFuc2Zvcm1PcmlnaW4gPSAnbGVmdCB0b3AnO1xuXG4gICAgICAgIHRpdGxlLnN0eWxlLndpbGxDaGFuZ2UgPSAnb3BhY2l0eSc7XG4gICAgICAgIHRpdGxlLnN0eWxlLndlYmtpdFRyYW5zZm9ybU9yaWdpbiA9ICdsZWZ0IHRvcCc7XG4gICAgICAgIHRpdGxlLnN0eWxlLnRyYW5zZm9ybU9yaWdpbiA9ICdsZWZ0IHRvcCc7XG4gICAgICAgIHRpdGxlLnN0eWxlLndlYmtpdFRyYW5zZm9ybSA9ICd0cmFuc2xhdGVaKDApJztcbiAgICAgICAgdGl0bGUuc3R5bGUudHJhbnNmb3JtID0gJ3RyYW5zbGF0ZVooMCknO1xuXG4gICAgICAgIHZhciB0aXRsZUNsaWVudFJlY3QgPSB0aXRsZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgdmFyIGNvbmRlbnNlZFRpdGxlQ2xpZW50UmVjdCA9IGNvbmRlbnNlZFRpdGxlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB2YXIgZnggPSB7fTtcblxuICAgICAgICBmeC5zY2FsZSA9IHBhcnNlSW50KHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGNvbmRlbnNlZFRpdGxlKVsnZm9udC1zaXplJ10sIDEwKSAvXG4gICAgICAgICAgICBwYXJzZUludCh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aXRsZSlbJ2ZvbnQtc2l6ZSddLCAxMCk7XG4gICAgICAgIGZ4LnRpdGxlRFggPSB0aXRsZUNsaWVudFJlY3QubGVmdCAtIGNvbmRlbnNlZFRpdGxlQ2xpZW50UmVjdC5sZWZ0O1xuICAgICAgICBmeC50aXRsZURZID0gdGl0bGVDbGllbnRSZWN0LnRvcCAtIGNvbmRlbnNlZFRpdGxlQ2xpZW50UmVjdC50b3A7XG4gICAgICAgIGZ4LmNvbmRlbnNlZFRpdGxlID0gY29uZGVuc2VkVGl0bGU7XG4gICAgICAgIGZ4LnRpdGxlID0gdGl0bGU7XG5cbiAgICAgICAgdGhpcy5fZnhSZXNpemVUaXRsZSA9IGZ4O1xuICAgICAgfSxcbiAgICAgIC8qKiBAdGhpcyBQb2x5bWVyRWxlbWVudCAqL1xuICAgICAgcnVuOiBmdW5jdGlvbiBydW4ocCwgeSkge1xuICAgICAgICB2YXIgZnggPSB0aGlzLl9meFJlc2l6ZVRpdGxlO1xuICAgICAgICBpZiAoIXRoaXMuY29uZGVuc2VzKSB7XG4gICAgICAgICAgeSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHAgPj0gMSkge1xuICAgICAgICAgIGZ4LnRpdGxlLnN0eWxlLm9wYWNpdHkgPSAwO1xuICAgICAgICAgIGZ4LmNvbmRlbnNlZFRpdGxlLnN0eWxlLm9wYWNpdHkgPSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZ4LnRpdGxlLnN0eWxlLm9wYWNpdHkgPSAxO1xuICAgICAgICAgIGZ4LmNvbmRlbnNlZFRpdGxlLnN0eWxlLm9wYWNpdHkgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGludGVycG9sYXRlKE1hdGgubWluKDEsIHApLCBbIFsxLCBmeC5zY2FsZV0sIFswLCAtZngudGl0bGVEWF0sIFt5LCB5LWZ4LnRpdGxlRFldIF0sXG4gICAgICAgICAgZnVuY3Rpb24oc2NhbGUsIHRyYW5zbGF0ZVgsIHRyYW5zbGF0ZVkpIHtcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtKCd0cmFuc2xhdGUoJyArIHRyYW5zbGF0ZVggKyAncHgsICcgKyB0cmFuc2xhdGVZICsgJ3B4KSAnICtcbiAgICAgICAgICAgICAgICAnc2NhbGUzZCgnICsgc2NhbGUgKyAnLCAnICsgc2NhbGUgKyAnLCAxKScsIGZ4LnRpdGxlKTtcbiAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgIH0sXG4gICAgICAvKiogQHRoaXMgUG9seW1lci5BcHBMYXlvdXQuRWxlbWVudFdpdGhCYWNrZ3JvdW5kICovXG4gICAgICB0ZWFyRG93bjogZnVuY3Rpb24gdGVhckRvd24oKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9meFJlc2l6ZVRpdGxlO1xuICAgICAgfVxuICAgIH0pO1xuICB9KSgpO1xuPC9zY3JpcHQ+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL2FwcC1sYXlvdXQvYXBwLXNjcm9sbC1lZmZlY3RzL2VmZmVjdHMvcmVzaXplLXRpdGxlLmh0bWwiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi9hcHAtc2Nyb2xsLWVmZmVjdHMtYmVoYXZpb3IuaHRtbFwiPlxuXG48c2NyaXB0PlxuICAvKipcbiAgICogVmVydGljYWxseSB0cmFuc2xhdGUgdGhlIGJhY2tncm91bmQgYmFzZWQgb24gYSBmYWN0b3Igb2YgdGhlIHNjcm9sbCBwb3NpdGlvbi5cbiAgICovXG4gIFBvbHltZXIuQXBwTGF5b3V0LnJlZ2lzdGVyRWZmZWN0KCdwYXJhbGxheC1iYWNrZ3JvdW5kJywge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7e3NjYWxhcjogc3RyaW5nfX0gY29uZmlnXG4gICAgICogQHRoaXMgUG9seW1lci5BcHBMYXlvdXQuRWxlbWVudFdpdGhCYWNrZ3JvdW5kXG4gICAgICovXG4gICAgc2V0VXA6IGZ1bmN0aW9uIHNldFVwKGNvbmZpZykge1xuICAgICAgdmFyIGZ4ID0ge307XG4gICAgICB2YXIgc2NhbGFyID0gcGFyc2VGbG9hdChjb25maWcuc2NhbGFyKTtcbiAgICAgIGZ4LmJhY2tncm91bmQgPSB0aGlzLl9nZXRET01SZWYoJ2JhY2tncm91bmQnKTtcbiAgICAgIGZ4LmJhY2tncm91bmRGcm9udExheWVyID0gdGhpcy5fZ2V0RE9NUmVmKCdiYWNrZ3JvdW5kRnJvbnRMYXllcicpO1xuICAgICAgZnguYmFja2dyb3VuZFJlYXJMYXllciA9IHRoaXMuX2dldERPTVJlZignYmFja2dyb3VuZFJlYXJMYXllcicpO1xuICAgICAgZnguZGVsdGFCZyA9IGZ4LmJhY2tncm91bmRGcm9udExheWVyLm9mZnNldEhlaWdodCAtIGZ4LmJhY2tncm91bmQub2Zmc2V0SGVpZ2h0O1xuICAgICAgaWYgKGZ4LmRlbHRhQmcgPT09IDApIHtcbiAgICAgICAgaWYgKGlzTmFOKHNjYWxhcikpIHtcbiAgICAgICAgICBzY2FsYXIgPSAwLjg7XG4gICAgICAgIH1cbiAgICAgICAgZnguZGVsdGFCZyA9IHRoaXMuX2RIZWlnaHQgKiBzY2FsYXI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXNOYU4oc2NhbGFyKSkge1xuICAgICAgICAgIHNjYWxhciA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgZnguZGVsdGFCZyA9IGZ4LmRlbHRhQmcgKiBzY2FsYXI7XG4gICAgICB9XG4gICAgICB0aGlzLl9meFBhcmFsbGF4QmFja2dyb3VuZCA9IGZ4O1xuICAgIH0sXG4gICAgLyoqIEB0aGlzIFBvbHltZXIuQXBwTGF5b3V0LkVsZW1lbnRXaXRoQmFja2dyb3VuZCAqL1xuICAgIHJ1bjogZnVuY3Rpb24gcnVuKHAsIHkpIHtcbiAgICAgIHZhciBmeCA9IHRoaXMuX2Z4UGFyYWxsYXhCYWNrZ3JvdW5kO1xuICAgICAgdGhpcy50cmFuc2Zvcm0oJ3RyYW5zbGF0ZTNkKDBweCwgJyArIChmeC5kZWx0YUJnICogTWF0aC5taW4oMSwgcCkpICsgJ3B4LCAwcHgpJywgZnguYmFja2dyb3VuZEZyb250TGF5ZXIpO1xuICAgICAgaWYgKGZ4LmJhY2tncm91bmRSZWFyTGF5ZXIpIHtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0oJ3RyYW5zbGF0ZTNkKDBweCwgJyArIChmeC5kZWx0YUJnICogTWF0aC5taW4oMSwgcCkpICsgJ3B4LCAwcHgpJywgZnguYmFja2dyb3VuZFJlYXJMYXllcik7XG4gICAgICB9XG4gICAgfSxcbiAgICAvKiogQHRoaXMgUG9seW1lci5BcHBMYXlvdXQuRWxlbWVudFdpdGhCYWNrZ3JvdW5kICovXG4gICAgdGVhckRvd246IGZ1bmN0aW9uIHRlYXJEb3duKCkge1xuICAgICAgZGVsZXRlIHRoaXMuX2Z4UGFyYWxsYXhCYWNrZ3JvdW5kO1xuICAgIH1cbiAgfSk7XG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvYXBwLWxheW91dC9hcHAtc2Nyb2xsLWVmZmVjdHMvZWZmZWN0cy9wYXJhbGxheC1iYWNrZ3JvdW5kLmh0bWwiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE1IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi9wb2x5bWVyL3BvbHltZXIuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cImlyb24tc2VsZWN0aW9uLmh0bWxcIj5cblxuPHNjcmlwdD5cbiAgLyoqXG4gICAqIEBwb2x5bWVyQmVoYXZpb3IgUG9seW1lci5Jcm9uU2VsZWN0YWJsZUJlaGF2aW9yXG4gICAqL1xuICBQb2x5bWVyLklyb25TZWxlY3RhYmxlQmVoYXZpb3IgPSB7XG5cbiAgICAgIC8qKlxuICAgICAgICogRmlyZWQgd2hlbiBpcm9uLXNlbGVjdG9yIGlzIGFjdGl2YXRlZCAoc2VsZWN0ZWQgb3IgZGVzZWxlY3RlZCkuXG4gICAgICAgKiBJdCBpcyBmaXJlZCBiZWZvcmUgdGhlIHNlbGVjdGVkIGl0ZW1zIGFyZSBjaGFuZ2VkLlxuICAgICAgICogQ2FuY2VsIHRoZSBldmVudCB0byBhYm9ydCBzZWxlY3Rpb24uXG4gICAgICAgKlxuICAgICAgICogQGV2ZW50IGlyb24tYWN0aXZhdGVcbiAgICAgICAqL1xuXG4gICAgICAvKipcbiAgICAgICAqIEZpcmVkIHdoZW4gYW4gaXRlbSBpcyBzZWxlY3RlZFxuICAgICAgICpcbiAgICAgICAqIEBldmVudCBpcm9uLXNlbGVjdFxuICAgICAgICovXG5cbiAgICAgIC8qKlxuICAgICAgICogRmlyZWQgd2hlbiBhbiBpdGVtIGlzIGRlc2VsZWN0ZWRcbiAgICAgICAqXG4gICAgICAgKiBAZXZlbnQgaXJvbi1kZXNlbGVjdFxuICAgICAgICovXG5cbiAgICAgIC8qKlxuICAgICAgICogRmlyZWQgd2hlbiB0aGUgbGlzdCBvZiBzZWxlY3RhYmxlIGl0ZW1zIGNoYW5nZXMgKGUuZy4sIGl0ZW1zIGFyZVxuICAgICAgICogYWRkZWQgb3IgcmVtb3ZlZCkuIFRoZSBkZXRhaWwgb2YgdGhlIGV2ZW50IGlzIGEgbXV0YXRpb24gcmVjb3JkIHRoYXRcbiAgICAgICAqIGRlc2NyaWJlcyB3aGF0IGNoYW5nZWQuXG4gICAgICAgKlxuICAgICAgICogQGV2ZW50IGlyb24taXRlbXMtY2hhbmdlZFxuICAgICAgICovXG5cbiAgICBwcm9wZXJ0aWVzOiB7XG5cbiAgICAgIC8qKlxuICAgICAgICogSWYgeW91IHdhbnQgdG8gdXNlIGFuIGF0dHJpYnV0ZSB2YWx1ZSBvciBwcm9wZXJ0eSBvZiBhbiBlbGVtZW50IGZvclxuICAgICAgICogYHNlbGVjdGVkYCBpbnN0ZWFkIG9mIHRoZSBpbmRleCwgc2V0IHRoaXMgdG8gdGhlIG5hbWUgb2YgdGhlIGF0dHJpYnV0ZVxuICAgICAgICogb3IgcHJvcGVydHkuIEh5cGhlbmF0ZWQgdmFsdWVzIGFyZSBjb252ZXJ0ZWQgdG8gY2FtZWwgY2FzZSB3aGVuIHVzZWQgdG9cbiAgICAgICAqIGxvb2sgdXAgdGhlIHByb3BlcnR5IG9mIGEgc2VsZWN0YWJsZSBlbGVtZW50LiBDYW1lbCBjYXNlZCB2YWx1ZXMgYXJlXG4gICAgICAgKiAqbm90KiBjb252ZXJ0ZWQgdG8gaHlwaGVuYXRlZCB2YWx1ZXMgZm9yIGF0dHJpYnV0ZSBsb29rdXAuIEl0J3NcbiAgICAgICAqIHJlY29tbWVuZGVkIHRoYXQgeW91IHByb3ZpZGUgdGhlIGh5cGhlbmF0ZWQgZm9ybSBvZiB0aGUgbmFtZSBzbyB0aGF0XG4gICAgICAgKiBzZWxlY3Rpb24gd29ya3MgaW4gYm90aCBjYXNlcy4gKFVzZSBgYXR0ci1vci1wcm9wZXJ0eS1uYW1lYCBpbnN0ZWFkIG9mXG4gICAgICAgKiBgYXR0ck9yUHJvcGVydHlOYW1lYC4pXG4gICAgICAgKi9cbiAgICAgIGF0dHJGb3JTZWxlY3RlZDoge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIHZhbHVlOiBudWxsXG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgc2VsZWN0ZWQgZWxlbWVudC4gVGhlIGRlZmF1bHQgaXMgdG8gdXNlIHRoZSBpbmRleCBvZiB0aGUgaXRlbS5cbiAgICAgICAqIEB0eXBlIHtzdHJpbmd8bnVtYmVyfVxuICAgICAgICovXG4gICAgICBzZWxlY3RlZDoge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIG5vdGlmeTogdHJ1ZVxuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgaXRlbS5cbiAgICAgICAqXG4gICAgICAgKiBAdHlwZSB7P09iamVjdH1cbiAgICAgICAqL1xuICAgICAgc2VsZWN0ZWRJdGVtOiB7XG4gICAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgICAgcmVhZE9ubHk6IHRydWUsXG4gICAgICAgIG5vdGlmeTogdHJ1ZVxuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBUaGUgZXZlbnQgdGhhdCBmaXJlcyBmcm9tIGl0ZW1zIHdoZW4gdGhleSBhcmUgc2VsZWN0ZWQuIFNlbGVjdGFibGVcbiAgICAgICAqIHdpbGwgbGlzdGVuIGZvciB0aGlzIGV2ZW50IGZyb20gaXRlbXMgYW5kIHVwZGF0ZSB0aGUgc2VsZWN0aW9uIHN0YXRlLlxuICAgICAgICogU2V0IHRvIGVtcHR5IHN0cmluZyB0byBsaXN0ZW4gdG8gbm8gZXZlbnRzLlxuICAgICAgICovXG4gICAgICBhY3RpdmF0ZUV2ZW50OiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgdmFsdWU6ICd0YXAnLFxuICAgICAgICBvYnNlcnZlcjogJ19hY3RpdmF0ZUV2ZW50Q2hhbmdlZCdcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogVGhpcyBpcyBhIENTUyBzZWxlY3RvciBzdHJpbmcuICBJZiB0aGlzIGlzIHNldCwgb25seSBpdGVtcyB0aGF0IG1hdGNoIHRoZSBDU1Mgc2VsZWN0b3JcbiAgICAgICAqIGFyZSBzZWxlY3RhYmxlLlxuICAgICAgICovXG4gICAgICBzZWxlY3RhYmxlOiBTdHJpbmcsXG5cbiAgICAgIC8qKlxuICAgICAgICogVGhlIGNsYXNzIHRvIHNldCBvbiBlbGVtZW50cyB3aGVuIHNlbGVjdGVkLlxuICAgICAgICovXG4gICAgICBzZWxlY3RlZENsYXNzOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgdmFsdWU6ICdpcm9uLXNlbGVjdGVkJ1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBUaGUgYXR0cmlidXRlIHRvIHNldCBvbiBlbGVtZW50cyB3aGVuIHNlbGVjdGVkLlxuICAgICAgICovXG4gICAgICBzZWxlY3RlZEF0dHJpYnV0ZToge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIHZhbHVlOiBudWxsXG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIERlZmF1bHQgZmFsbGJhY2sgaWYgdGhlIHNlbGVjdGlvbiBiYXNlZCBvbiBzZWxlY3RlZCB3aXRoIGBhdHRyRm9yU2VsZWN0ZWRgXG4gICAgICAgKiBpcyBub3QgZm91bmQuXG4gICAgICAgKi9cbiAgICAgIGZhbGxiYWNrU2VsZWN0aW9uOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgdmFsdWU6IG51bGxcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogVGhlIGxpc3Qgb2YgaXRlbXMgZnJvbSB3aGljaCBhIHNlbGVjdGlvbiBjYW4gYmUgbWFkZS5cbiAgICAgICAqL1xuICAgICAgaXRlbXM6IHtcbiAgICAgICAgdHlwZTogQXJyYXksXG4gICAgICAgIHJlYWRPbmx5OiB0cnVlLFxuICAgICAgICBub3RpZnk6IHRydWUsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogVGhlIHNldCBvZiBleGNsdWRlZCBlbGVtZW50cyB3aGVyZSB0aGUga2V5IGlzIHRoZSBgbG9jYWxOYW1lYFxuICAgICAgICogb2YgdGhlIGVsZW1lbnQgdGhhdCB3aWxsIGJlIGlnbm9yZWQgZnJvbSB0aGUgaXRlbSBsaXN0LlxuICAgICAgICpcbiAgICAgICAqIEBkZWZhdWx0IHt0ZW1wbGF0ZTogMX1cbiAgICAgICAqL1xuICAgICAgX2V4Y2x1ZGVkTG9jYWxOYW1lczoge1xuICAgICAgICB0eXBlOiBPYmplY3QsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ3RlbXBsYXRlJzogMSxcbiAgICAgICAgICAgICdkb20tYmluZCc6IDEsXG4gICAgICAgICAgICAnZG9tLWlmJzogMSxcbiAgICAgICAgICAgICdkb20tcmVwZWF0JzogMSxcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIG9ic2VydmVyczogW1xuICAgICAgJ191cGRhdGVBdHRyRm9yU2VsZWN0ZWQoYXR0ckZvclNlbGVjdGVkKScsXG4gICAgICAnX3VwZGF0ZVNlbGVjdGVkKHNlbGVjdGVkKScsXG4gICAgICAnX2NoZWNrRmFsbGJhY2soZmFsbGJhY2tTZWxlY3Rpb24pJ1xuICAgIF0sXG5cbiAgICBjcmVhdGVkOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX2JpbmRGaWx0ZXJJdGVtID0gdGhpcy5fZmlsdGVySXRlbS5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5fc2VsZWN0aW9uID0gbmV3IFBvbHltZXIuSXJvblNlbGVjdGlvbih0aGlzLl9hcHBseVNlbGVjdGlvbi5iaW5kKHRoaXMpKTtcbiAgICB9LFxuXG4gICAgYXR0YWNoZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fb2JzZXJ2ZXIgPSB0aGlzLl9vYnNlcnZlSXRlbXModGhpcyk7XG4gICAgICB0aGlzLl9hZGRMaXN0ZW5lcih0aGlzLmFjdGl2YXRlRXZlbnQpO1xuICAgIH0sXG5cbiAgICBkZXRhY2hlZDogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5fb2JzZXJ2ZXIpIHtcbiAgICAgICAgUG9seW1lci5kb20odGhpcykudW5vYnNlcnZlTm9kZXModGhpcy5fb2JzZXJ2ZXIpO1xuICAgICAgfVxuICAgICAgdGhpcy5fcmVtb3ZlTGlzdGVuZXIodGhpcy5hY3RpdmF0ZUV2ZW50KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGdpdmVuIGl0ZW0uXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGluZGV4T2ZcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaXRlbVxuICAgICAqIEByZXR1cm5zIFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBpdGVtXG4gICAgICovXG4gICAgaW5kZXhPZjogZnVuY3Rpb24oaXRlbSkge1xuICAgICAgcmV0dXJuIHRoaXMuaXRlbXMuaW5kZXhPZihpdGVtKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2VsZWN0cyB0aGUgZ2l2ZW4gdmFsdWUuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHNlbGVjdFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gdmFsdWUgdGhlIHZhbHVlIHRvIHNlbGVjdC5cbiAgICAgKi9cbiAgICBzZWxlY3Q6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICB0aGlzLnNlbGVjdGVkID0gdmFsdWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNlbGVjdHMgdGhlIHByZXZpb3VzIGl0ZW0uXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHNlbGVjdFByZXZpb3VzXG4gICAgICovXG4gICAgc2VsZWN0UHJldmlvdXM6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGxlbmd0aCA9IHRoaXMuaXRlbXMubGVuZ3RoO1xuICAgICAgdmFyIGluZGV4ID0gKE51bWJlcih0aGlzLl92YWx1ZVRvSW5kZXgodGhpcy5zZWxlY3RlZCkpIC0gMSArIGxlbmd0aCkgJSBsZW5ndGg7XG4gICAgICB0aGlzLnNlbGVjdGVkID0gdGhpcy5faW5kZXhUb1ZhbHVlKGluZGV4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2VsZWN0cyB0aGUgbmV4dCBpdGVtLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBzZWxlY3ROZXh0XG4gICAgICovXG4gICAgc2VsZWN0TmV4dDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaW5kZXggPSAoTnVtYmVyKHRoaXMuX3ZhbHVlVG9JbmRleCh0aGlzLnNlbGVjdGVkKSkgKyAxKSAlIHRoaXMuaXRlbXMubGVuZ3RoO1xuICAgICAgdGhpcy5zZWxlY3RlZCA9IHRoaXMuX2luZGV4VG9WYWx1ZShpbmRleCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNlbGVjdHMgdGhlIGl0ZW0gYXQgdGhlIGdpdmVuIGluZGV4LlxuICAgICAqXG4gICAgICogQG1ldGhvZCBzZWxlY3RJbmRleFxuICAgICAqL1xuICAgIHNlbGVjdEluZGV4OiBmdW5jdGlvbihpbmRleCkge1xuICAgICAgdGhpcy5zZWxlY3QodGhpcy5faW5kZXhUb1ZhbHVlKGluZGV4KSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZvcmNlIGEgc3luY2hyb25vdXMgdXBkYXRlIG9mIHRoZSBgaXRlbXNgIHByb3BlcnR5LlxuICAgICAqXG4gICAgICogTk9URTogQ29uc2lkZXIgbGlzdGVuaW5nIGZvciB0aGUgYGlyb24taXRlbXMtY2hhbmdlZGAgZXZlbnQgdG8gcmVzcG9uZCB0b1xuICAgICAqIHVwZGF0ZXMgdG8gdGhlIHNldCBvZiBzZWxlY3RhYmxlIGl0ZW1zIGFmdGVyIHVwZGF0ZXMgdG8gdGhlIERPTSBsaXN0IGFuZFxuICAgICAqIHNlbGVjdGlvbiBzdGF0ZSBoYXZlIGJlZW4gbWFkZS5cbiAgICAgKlxuICAgICAqIFdBUk5JTkc6IElmIHlvdSBhcmUgdXNpbmcgdGhpcyBtZXRob2QsIHlvdSBzaG91bGQgcHJvYmFibHkgY29uc2lkZXIgYW5cbiAgICAgKiBhbHRlcm5hdGUgYXBwcm9hY2guIFN5bmNocm9ub3VzbHkgcXVlcnlpbmcgZm9yIGl0ZW1zIGlzIHBvdGVudGlhbGx5XG4gICAgICogc2xvdyBmb3IgbWFueSB1c2UgY2FzZXMuIFRoZSBgaXRlbXNgIHByb3BlcnR5IHdpbGwgdXBkYXRlIGFzeW5jaHJvbm91c2x5XG4gICAgICogb24gaXRzIG93biB0byByZWZsZWN0IHNlbGVjdGFibGUgaXRlbXMgaW4gdGhlIERPTS5cbiAgICAgKi9cbiAgICBmb3JjZVN5bmNocm9ub3VzSXRlbVVwZGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5fb2JzZXJ2ZXIgJiYgdHlwZW9mIHRoaXMuX29ic2VydmVyLmZsdXNoID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgLy8gTk9URShiaWNrbmVsbHIpOiBgUG9seW1lci5kb20uZmx1c2hgIGFib3ZlIGlzIG5vIGxvbmdlciBzdWZmaWNpZW50IHRvXG4gICAgICAgIC8vIHRyaWdnZXIgYG9ic2VydmVOb2Rlc2AgY2FsbGJhY2tzLiBQb2x5bWVyIDIueCByZXR1cm5zIGFuIG9iamVjdCBmcm9tXG4gICAgICAgIC8vIGBvYnNlcnZlTm9kZXNgIHdpdGggYSBgZmx1c2hgIHRoYXQgc3luY2hyb25vdXNseSBnaXZlcyB0aGUgY2FsbGJhY2tcbiAgICAgICAgLy8gYW55IHBlbmRpbmcgTXV0YXRpb25SZWNvcmRzIChyZXRyaWV2ZWQgd2l0aCBgdGFrZVJlY29yZHNgKS4gQW55IGNhc2VcbiAgICAgICAgLy8gd2hlcmUgU2hhZHlET00gZmx1c2hlcyB3ZXJlIGV4cGVjdGVkIHRvIHN5bmNocm9ub3VzbHkgdHJpZ2dlciBpdGVtXG4gICAgICAgIC8vIHVwZGF0ZXMgd2lsbCBub3cgcmVxdWlyZSBjYWxsaW5nIGBmb3JjZVN5bmNocm9ub3VzSXRlbVVwZGF0ZWAuXG4gICAgICAgIHRoaXMuX29ic2VydmVyLmZsdXNoKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl91cGRhdGVJdGVtcygpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBVTlVTRUQsIEZPUiBBUEkgQ09NUEFUSUJJTElUWVxuICAgIGdldCBfc2hvdWxkVXBkYXRlU2VsZWN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0ZWQgIT0gbnVsbDtcbiAgICB9LFxuXG4gICAgX2NoZWNrRmFsbGJhY2s6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fdXBkYXRlU2VsZWN0ZWQoKTtcbiAgICB9LFxuXG4gICAgX2FkZExpc3RlbmVyOiBmdW5jdGlvbihldmVudE5hbWUpIHtcbiAgICAgIHRoaXMubGlzdGVuKHRoaXMsIGV2ZW50TmFtZSwgJ19hY3RpdmF0ZUhhbmRsZXInKTtcbiAgICB9LFxuXG4gICAgX3JlbW92ZUxpc3RlbmVyOiBmdW5jdGlvbihldmVudE5hbWUpIHtcbiAgICAgIHRoaXMudW5saXN0ZW4odGhpcywgZXZlbnROYW1lLCAnX2FjdGl2YXRlSGFuZGxlcicpO1xuICAgIH0sXG5cbiAgICBfYWN0aXZhdGVFdmVudENoYW5nZWQ6IGZ1bmN0aW9uKGV2ZW50TmFtZSwgb2xkKSB7XG4gICAgICB0aGlzLl9yZW1vdmVMaXN0ZW5lcihvbGQpO1xuICAgICAgdGhpcy5fYWRkTGlzdGVuZXIoZXZlbnROYW1lKTtcbiAgICB9LFxuXG4gICAgX3VwZGF0ZUl0ZW1zOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBub2RlcyA9IFBvbHltZXIuZG9tKHRoaXMpLnF1ZXJ5RGlzdHJpYnV0ZWRFbGVtZW50cyh0aGlzLnNlbGVjdGFibGUgfHwgJyonKTtcbiAgICAgIG5vZGVzID0gQXJyYXkucHJvdG90eXBlLmZpbHRlci5jYWxsKG5vZGVzLCB0aGlzLl9iaW5kRmlsdGVySXRlbSk7XG4gICAgICB0aGlzLl9zZXRJdGVtcyhub2Rlcyk7XG4gICAgfSxcblxuICAgIF91cGRhdGVBdHRyRm9yU2VsZWN0ZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuc2VsZWN0ZWRJdGVtKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWQgPSB0aGlzLl92YWx1ZUZvckl0ZW0odGhpcy5zZWxlY3RlZEl0ZW0pO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBfdXBkYXRlU2VsZWN0ZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fc2VsZWN0U2VsZWN0ZWQodGhpcy5zZWxlY3RlZCk7XG4gICAgfSxcblxuICAgIF9zZWxlY3RTZWxlY3RlZDogZnVuY3Rpb24oc2VsZWN0ZWQpIHtcbiAgICAgIGlmICghdGhpcy5pdGVtcykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBpdGVtID0gdGhpcy5fdmFsdWVUb0l0ZW0odGhpcy5zZWxlY3RlZCk7XG4gICAgICBpZiAoaXRlbSkge1xuICAgICAgICB0aGlzLl9zZWxlY3Rpb24uc2VsZWN0KGl0ZW0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fc2VsZWN0aW9uLmNsZWFyKCk7XG4gICAgICB9XG4gICAgICAvLyBDaGVjayBmb3IgaXRlbXMsIHNpbmNlIHRoaXMgYXJyYXkgaXMgcG9wdWxhdGVkIG9ubHkgd2hlbiBhdHRhY2hlZFxuICAgICAgLy8gU2luY2UgTnVtYmVyKDApIGlzIGZhbHN5LCBleHBsaWNpdGx5IGNoZWNrIGZvciB1bmRlZmluZWRcbiAgICAgIGlmICh0aGlzLmZhbGxiYWNrU2VsZWN0aW9uICYmIHRoaXMuaXRlbXMubGVuZ3RoICYmICh0aGlzLl9zZWxlY3Rpb24uZ2V0KCkgPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgdGhpcy5zZWxlY3RlZCA9IHRoaXMuZmFsbGJhY2tTZWxlY3Rpb247XG4gICAgICB9XG4gICAgfSxcblxuICAgIF9maWx0ZXJJdGVtOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICByZXR1cm4gIXRoaXMuX2V4Y2x1ZGVkTG9jYWxOYW1lc1tub2RlLmxvY2FsTmFtZV07XG4gICAgfSxcblxuICAgIF92YWx1ZVRvSXRlbTogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiAodmFsdWUgPT0gbnVsbCkgPyBudWxsIDogdGhpcy5pdGVtc1t0aGlzLl92YWx1ZVRvSW5kZXgodmFsdWUpXTtcbiAgICB9LFxuXG4gICAgX3ZhbHVlVG9JbmRleDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIGlmICh0aGlzLmF0dHJGb3JTZWxlY3RlZCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgaXRlbTsgaXRlbSA9IHRoaXMuaXRlbXNbaV07IGkrKykge1xuICAgICAgICAgIGlmICh0aGlzLl92YWx1ZUZvckl0ZW0oaXRlbSkgPT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIE51bWJlcih2YWx1ZSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIF9pbmRleFRvVmFsdWU6IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICBpZiAodGhpcy5hdHRyRm9yU2VsZWN0ZWQpIHtcbiAgICAgICAgdmFyIGl0ZW0gPSB0aGlzLml0ZW1zW2luZGV4XTtcbiAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWVGb3JJdGVtKGl0ZW0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICB9XG4gICAgfSxcblxuICAgIF92YWx1ZUZvckl0ZW06IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgIGlmICghaXRlbSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIHByb3BWYWx1ZSA9IGl0ZW1bUG9seW1lci5DYXNlTWFwLmRhc2hUb0NhbWVsQ2FzZSh0aGlzLmF0dHJGb3JTZWxlY3RlZCldO1xuICAgICAgcmV0dXJuIHByb3BWYWx1ZSAhPSB1bmRlZmluZWQgPyBwcm9wVmFsdWUgOiBpdGVtLmdldEF0dHJpYnV0ZSh0aGlzLmF0dHJGb3JTZWxlY3RlZCk7XG4gICAgfSxcblxuICAgIF9hcHBseVNlbGVjdGlvbjogZnVuY3Rpb24oaXRlbSwgaXNTZWxlY3RlZCkge1xuICAgICAgaWYgKHRoaXMuc2VsZWN0ZWRDbGFzcykge1xuICAgICAgICB0aGlzLnRvZ2dsZUNsYXNzKHRoaXMuc2VsZWN0ZWRDbGFzcywgaXNTZWxlY3RlZCwgaXRlbSk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5zZWxlY3RlZEF0dHJpYnV0ZSkge1xuICAgICAgICB0aGlzLnRvZ2dsZUF0dHJpYnV0ZSh0aGlzLnNlbGVjdGVkQXR0cmlidXRlLCBpc1NlbGVjdGVkLCBpdGVtKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3NlbGVjdGlvbkNoYW5nZSgpO1xuICAgICAgdGhpcy5maXJlKCdpcm9uLScgKyAoaXNTZWxlY3RlZCA/ICdzZWxlY3QnIDogJ2Rlc2VsZWN0JyksIHtpdGVtOiBpdGVtfSk7XG4gICAgfSxcblxuICAgIF9zZWxlY3Rpb25DaGFuZ2U6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fc2V0U2VsZWN0ZWRJdGVtKHRoaXMuX3NlbGVjdGlvbi5nZXQoKSk7XG4gICAgfSxcblxuICAgIC8vIG9ic2VydmUgaXRlbXMgY2hhbmdlIHVuZGVyIHRoZSBnaXZlbiBub2RlLlxuICAgIF9vYnNlcnZlSXRlbXM6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHJldHVybiBQb2x5bWVyLmRvbShub2RlKS5vYnNlcnZlTm9kZXMoZnVuY3Rpb24obXV0YXRpb24pIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlSXRlbXMoKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlU2VsZWN0ZWQoKTtcblxuICAgICAgICAvLyBMZXQgb3RoZXIgaW50ZXJlc3RlZCBwYXJ0aWVzIGtub3cgYWJvdXQgdGhlIGNoYW5nZSBzbyB0aGF0XG4gICAgICAgIC8vIHdlIGRvbid0IGhhdmUgdG8gcmVjcmVhdGUgbXV0YXRpb24gb2JzZXJ2ZXJzIGV2ZXJ5d2hlcmUuXG4gICAgICAgIHRoaXMuZmlyZSgnaXJvbi1pdGVtcy1jaGFuZ2VkJywgbXV0YXRpb24sIHtcbiAgICAgICAgICBidWJibGVzOiBmYWxzZSxcbiAgICAgICAgICBjYW5jZWxhYmxlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBfYWN0aXZhdGVIYW5kbGVyOiBmdW5jdGlvbihlKSB7XG4gICAgICB2YXIgdCA9IGUudGFyZ2V0O1xuICAgICAgdmFyIGl0ZW1zID0gdGhpcy5pdGVtcztcbiAgICAgIHdoaWxlICh0ICYmIHQgIT0gdGhpcykge1xuICAgICAgICB2YXIgaSA9IGl0ZW1zLmluZGV4T2YodCk7XG4gICAgICAgIGlmIChpID49IDApIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLl9pbmRleFRvVmFsdWUoaSk7XG4gICAgICAgICAgdGhpcy5faXRlbUFjdGl2YXRlKHZhbHVlLCB0KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdCA9IHQucGFyZW50Tm9kZTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgX2l0ZW1BY3RpdmF0ZTogZnVuY3Rpb24odmFsdWUsIGl0ZW0pIHtcbiAgICAgIGlmICghdGhpcy5maXJlKCdpcm9uLWFjdGl2YXRlJyxcbiAgICAgICAgICB7c2VsZWN0ZWQ6IHZhbHVlLCBpdGVtOiBpdGVtfSwge2NhbmNlbGFibGU6IHRydWV9KS5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0KHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgfTtcblxuPC9zY3JpcHQ+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL2lyb24tc2VsZWN0b3IvaXJvbi1zZWxlY3RhYmxlLmh0bWwiLCJcbnJlcXVpcmUoJy4uL3BvbHltZXIvcG9seW1lci5odG1sJyk7XG5cbnJlcXVpcmUoJy4vY29sb3IuaHRtbCcpO1xuXG5jb25zdCBSZWdpc3Rlckh0bWxUZW1wbGF0ZSA9IHJlcXVpcmUoJ3BvbHltZXItd2VicGFjay1sb2FkZXIvcmVnaXN0ZXItaHRtbC10ZW1wbGF0ZScpO1xuXG5SZWdpc3Rlckh0bWxUZW1wbGF0ZS50b0JvZHkoXCI8Y3VzdG9tLXN0eWxlPiA8c3R5bGUgaXM9Y3VzdG9tLXN0eWxlPmh0bWx7LS1wcmltYXJ5LXRleHQtY29sb3I6dmFyKC0tbGlnaHQtdGhlbWUtdGV4dC1jb2xvcik7LS1wcmltYXJ5LWJhY2tncm91bmQtY29sb3I6dmFyKC0tbGlnaHQtdGhlbWUtYmFja2dyb3VuZC1jb2xvcik7LS1zZWNvbmRhcnktdGV4dC1jb2xvcjp2YXIoLS1saWdodC10aGVtZS1zZWNvbmRhcnktY29sb3IpOy0tZGlzYWJsZWQtdGV4dC1jb2xvcjp2YXIoLS1saWdodC10aGVtZS1kaXNhYmxlZC1jb2xvcik7LS1kaXZpZGVyLWNvbG9yOnZhcigtLWxpZ2h0LXRoZW1lLWRpdmlkZXItY29sb3IpOy0tZXJyb3ItY29sb3I6dmFyKC0tcGFwZXItZGVlcC1vcmFuZ2UtYTcwMCk7LS1wcmltYXJ5LWNvbG9yOnZhcigtLXBhcGVyLWluZGlnby01MDApOy0tbGlnaHQtcHJpbWFyeS1jb2xvcjp2YXIoLS1wYXBlci1pbmRpZ28tMTAwKTstLWRhcmstcHJpbWFyeS1jb2xvcjp2YXIoLS1wYXBlci1pbmRpZ28tNzAwKTstLWFjY2VudC1jb2xvcjp2YXIoLS1wYXBlci1waW5rLWEyMDApOy0tbGlnaHQtYWNjZW50LWNvbG9yOnZhcigtLXBhcGVyLXBpbmstYTEwMCk7LS1kYXJrLWFjY2VudC1jb2xvcjp2YXIoLS1wYXBlci1waW5rLWE0MDApOy0tbGlnaHQtdGhlbWUtYmFja2dyb3VuZC1jb2xvcjojZmZmZmZmOy0tbGlnaHQtdGhlbWUtYmFzZS1jb2xvcjojMDAwMDAwOy0tbGlnaHQtdGhlbWUtdGV4dC1jb2xvcjp2YXIoLS1wYXBlci1ncmV5LTkwMCk7LS1saWdodC10aGVtZS1zZWNvbmRhcnktY29sb3I6IzczNzM3MzstLWxpZ2h0LXRoZW1lLWRpc2FibGVkLWNvbG9yOiM5YjliOWI7LS1saWdodC10aGVtZS1kaXZpZGVyLWNvbG9yOiNkYmRiZGI7LS1kYXJrLXRoZW1lLWJhY2tncm91bmQtY29sb3I6dmFyKC0tcGFwZXItZ3JleS05MDApOy0tZGFyay10aGVtZS1iYXNlLWNvbG9yOiNmZmZmZmY7LS1kYXJrLXRoZW1lLXRleHQtY29sb3I6I2ZmZmZmZjstLWRhcmstdGhlbWUtc2Vjb25kYXJ5LWNvbG9yOiNiY2JjYmM7LS1kYXJrLXRoZW1lLWRpc2FibGVkLWNvbG9yOiM2NDY0NjQ7LS1kYXJrLXRoZW1lLWRpdmlkZXItY29sb3I6IzNjM2MzYzstLXRleHQtcHJpbWFyeS1jb2xvcjp2YXIoLS1kYXJrLXRoZW1lLXRleHQtY29sb3IpOy0tZGVmYXVsdC1wcmltYXJ5LWNvbG9yOnZhcigtLXByaW1hcnktY29sb3IpfTwvc3R5bGU+IDwvY3VzdG9tLXN0eWxlPlwiKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvcGFwZXItc3R5bGVzL2RlZmF1bHQtdGhlbWUuaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTUgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cblxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3BvbHltZXIvcG9seW1lci5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vaXJvbi1tZXRhL2lyb24tbWV0YS5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vaXJvbi1mbGV4LWxheW91dC9pcm9uLWZsZXgtbGF5b3V0Lmh0bWxcIj5cblxuPCEtLVxuXG5UaGUgYGlyb24taWNvbmAgZWxlbWVudCBkaXNwbGF5cyBhbiBpY29uLiBCeSBkZWZhdWx0IGFuIGljb24gcmVuZGVycyBhcyBhIDI0cHggc3F1YXJlLlxuXG5FeGFtcGxlIHVzaW5nIHNyYzpcblxuICAgIDxpcm9uLWljb24gc3JjPVwic3Rhci5wbmdcIj48L2lyb24taWNvbj5cblxuRXhhbXBsZSBzZXR0aW5nIHNpemUgdG8gMzJweCB4IDMycHg6XG5cbiAgICA8aXJvbi1pY29uIGNsYXNzPVwiYmlnXCIgc3JjPVwiYmlnX3N0YXIucG5nXCI+PC9pcm9uLWljb24+XG5cbiAgICA8c3R5bGUgaXM9XCJjdXN0b20tc3R5bGVcIj5cbiAgICAgIC5iaWcge1xuICAgICAgICAtLWlyb24taWNvbi1oZWlnaHQ6IDMycHg7XG4gICAgICAgIC0taXJvbi1pY29uLXdpZHRoOiAzMnB4O1xuICAgICAgfVxuICAgIDwvc3R5bGU+XG5cblRoZSBpcm9uIGVsZW1lbnRzIGluY2x1ZGUgc2V2ZXJhbCBzZXRzIG9mIGljb25zLlxuVG8gdXNlIHRoZSBkZWZhdWx0IHNldCBvZiBpY29ucywgaW1wb3J0IGBpcm9uLWljb25zLmh0bWxgIGFuZCB1c2UgdGhlIGBpY29uYCBhdHRyaWJ1dGUgdG8gc3BlY2lmeSBhbiBpY29uOlxuXG4gICAgPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi9jb21wb25lbnRzL2lyb24taWNvbnMvaXJvbi1pY29ucy5odG1sXCI+XG5cbiAgICA8aXJvbi1pY29uIGljb249XCJtZW51XCI+PC9pcm9uLWljb24+XG5cblRvIHVzZSBhIGRpZmZlcmVudCBidWlsdC1pbiBzZXQgb2YgaWNvbnMsIGltcG9ydCB0aGUgc3BlY2lmaWMgYGlyb24taWNvbnMvPGljb25zZXQ+LWljb25zLmh0bWxgLCBhbmRcbnNwZWNpZnkgdGhlIGljb24gYXMgYDxpY29uc2V0Pjo8aWNvbj5gLiBGb3IgZXhhbXBsZSwgdG8gdXNlIGEgY29tbXVuaWNhdGlvbiBpY29uLCB5b3Ugd291bGRcbnVzZTpcblxuICAgIDxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIvY29tcG9uZW50cy9pcm9uLWljb25zL2NvbW11bmljYXRpb24taWNvbnMuaHRtbFwiPlxuXG4gICAgPGlyb24taWNvbiBpY29uPVwiY29tbXVuaWNhdGlvbjplbWFpbFwiPjwvaXJvbi1pY29uPlxuXG5Zb3UgY2FuIGFsc28gY3JlYXRlIGN1c3RvbSBpY29uIHNldHMgb2YgYml0bWFwIG9yIFNWRyBpY29ucy5cblxuRXhhbXBsZSBvZiB1c2luZyBhbiBpY29uIG5hbWVkIGBjaGVycnlgIGZyb20gYSBjdXN0b20gaWNvbnNldCB3aXRoIHRoZSBJRCBgZnJ1aXRgOlxuXG4gICAgPGlyb24taWNvbiBpY29uPVwiZnJ1aXQ6Y2hlcnJ5XCI+PC9pcm9uLWljb24+XG5cblNlZSBbaXJvbi1pY29uc2V0XShpcm9uLWljb25zZXQpIGFuZCBbaXJvbi1pY29uc2V0LXN2Z10oaXJvbi1pY29uc2V0LXN2ZykgZm9yIG1vcmUgaW5mb3JtYXRpb24gYWJvdXRcbmhvdyB0byBjcmVhdGUgYSBjdXN0b20gaWNvbnNldC5cblxuU2VlIHRoZSBbaXJvbi1pY29ucyBkZW1vXShpcm9uLWljb25zP3ZpZXc9ZGVtbzpkZW1vL2luZGV4Lmh0bWwpIHRvIHNlZSB0aGUgaWNvbnMgYXZhaWxhYmxlXG5pbiB0aGUgdmFyaW91cyBpY29uc2V0cy5cblxuVG8gbG9hZCBhIHN1YnNldCBvZiBpY29ucyBmcm9tIG9uZSBvZiB0aGUgZGVmYXVsdCBgaXJvbi1pY29uc2Agc2V0cywgeW91IGNhblxudXNlIHRoZSBbcG9seS1pY29uXShodHRwczovL3BvbHktaWNvbi5hcHBzcG90LmNvbS8pIHRvb2wuIEl0IGFsbG93cyB5b3VcbnRvIHNlbGVjdCBpbmRpdmlkdWFsIGljb25zLCBhbmQgY3JlYXRlcyBhbiBpY29uc2V0IGZyb20gdGhlbSB0aGF0IHlvdSBjYW5cbnVzZSBkaXJlY3RseSBpbiB5b3VyIGVsZW1lbnRzLlxuXG4jIyMgU3R5bGluZ1xuXG5UaGUgZm9sbG93aW5nIGN1c3RvbSBwcm9wZXJ0aWVzIGFyZSBhdmFpbGFibGUgZm9yIHN0eWxpbmc6XG5cbkN1c3RvbSBwcm9wZXJ0eSB8IERlc2NyaXB0aW9uIHwgRGVmYXVsdFxuLS0tLS0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tfC0tLS0tLS0tLS1cbmAtLWlyb24taWNvbmAgfCBNaXhpbiBhcHBsaWVkIHRvIHRoZSBpY29uIHwge31cbmAtLWlyb24taWNvbi13aWR0aGAgfCBXaWR0aCBvZiB0aGUgaWNvbiB8IGAyNHB4YFxuYC0taXJvbi1pY29uLWhlaWdodGAgfCBIZWlnaHQgb2YgdGhlIGljb24gfCBgMjRweGBcbmAtLWlyb24taWNvbi1maWxsLWNvbG9yYCB8IEZpbGwgY29sb3Igb2YgdGhlIHN2ZyBpY29uIHwgYGN1cnJlbnRjb2xvcmBcbmAtLWlyb24taWNvbi1zdHJva2UtY29sb3JgIHwgU3Ryb2tlIGNvbG9yIG9mIHRoZSBzdmcgaWNvbiB8IG5vbmVcblxuQGdyb3VwIElyb24gRWxlbWVudHNcbkBlbGVtZW50IGlyb24taWNvblxuQGRlbW8gZGVtby9pbmRleC5odG1sXG5AaGVybyBoZXJvLnN2Z1xuQGhvbWVwYWdlIHBvbHltZXIuZ2l0aHViLmlvXG4tLT5cblxuPGRvbS1tb2R1bGUgaWQ9XCJpcm9uLWljb25cIj5cbiAgPHRlbXBsYXRlPlxuICAgIDxzdHlsZT5cbiAgICAgIDpob3N0IHtcbiAgICAgICAgQGFwcGx5IC0tbGF5b3V0LWlubGluZTtcbiAgICAgICAgQGFwcGx5IC0tbGF5b3V0LWNlbnRlci1jZW50ZXI7XG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcblxuICAgICAgICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xuXG4gICAgICAgIGZpbGw6IHZhcigtLWlyb24taWNvbi1maWxsLWNvbG9yLCBjdXJyZW50Y29sb3IpO1xuICAgICAgICBzdHJva2U6IHZhcigtLWlyb24taWNvbi1zdHJva2UtY29sb3IsIG5vbmUpO1xuXG4gICAgICAgIHdpZHRoOiB2YXIoLS1pcm9uLWljb24td2lkdGgsIDI0cHgpO1xuICAgICAgICBoZWlnaHQ6IHZhcigtLWlyb24taWNvbi1oZWlnaHQsIDI0cHgpO1xuICAgICAgICBAYXBwbHkgLS1pcm9uLWljb247XG4gICAgICB9XG5cbiAgICAgIDpob3N0KFtoaWRkZW5dKSB7XG4gICAgICAgIGRpc3BsYXk6IG5vbmU7XG4gICAgICB9XG4gICAgPC9zdHlsZT5cbiAgPC90ZW1wbGF0ZT5cblxuICA8c2NyaXB0PlxuXG4gICAgUG9seW1lcih7XG5cbiAgICAgIGlzOiAnaXJvbi1pY29uJyxcblxuICAgICAgcHJvcGVydGllczoge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbmFtZSBvZiB0aGUgaWNvbiB0byB1c2UuIFRoZSBuYW1lIHNob3VsZCBiZSBvZiB0aGUgZm9ybTpcbiAgICAgICAgICogYGljb25zZXRfbmFtZTppY29uX25hbWVgLlxuICAgICAgICAgKi9cbiAgICAgICAgaWNvbjoge1xuICAgICAgICAgIHR5cGU6IFN0cmluZ1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbmFtZSBvZiB0aGUgdGhlbWUgdG8gdXNlZCwgaWYgb25lIGlzIHNwZWNpZmllZCBieSB0aGVcbiAgICAgICAgICogaWNvbnNldC5cbiAgICAgICAgICovXG4gICAgICAgIHRoZW1lOiB7XG4gICAgICAgICAgdHlwZTogU3RyaW5nXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHVzaW5nIGlyb24taWNvbiB3aXRob3V0IGFuIGljb25zZXQsIHlvdSBjYW4gc2V0IHRoZSBzcmMgdG8gYmVcbiAgICAgICAgICogdGhlIFVSTCBvZiBhbiBpbmRpdmlkdWFsIGljb24gaW1hZ2UgZmlsZS4gTm90ZSB0aGF0IHRoaXMgd2lsbCB0YWtlXG4gICAgICAgICAqIHByZWNlZGVuY2Ugb3ZlciBhIGdpdmVuIGljb24gYXR0cmlidXRlLlxuICAgICAgICAgKi9cbiAgICAgICAgc3JjOiB7XG4gICAgICAgICAgdHlwZTogU3RyaW5nXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHshUG9seW1lci5Jcm9uTWV0YX1cbiAgICAgICAgICovXG4gICAgICAgIF9tZXRhOiB7XG4gICAgICAgICAgdmFsdWU6IFBvbHltZXIuQmFzZS5jcmVhdGUoJ2lyb24tbWV0YScsIHt0eXBlOiAnaWNvbnNldCd9KVxuICAgICAgICB9XG5cbiAgICAgIH0sXG5cbiAgICAgIG9ic2VydmVyczogW1xuICAgICAgICAnX3VwZGF0ZUljb24oX21ldGEsIGlzQXR0YWNoZWQpJyxcbiAgICAgICAgJ191cGRhdGVJY29uKHRoZW1lLCBpc0F0dGFjaGVkKScsXG4gICAgICAgICdfc3JjQ2hhbmdlZChzcmMsIGlzQXR0YWNoZWQpJyxcbiAgICAgICAgJ19pY29uQ2hhbmdlZChpY29uLCBpc0F0dGFjaGVkKSdcbiAgICAgIF0sXG5cbiAgICAgIF9ERUZBVUxUX0lDT05TRVQ6ICdpY29ucycsXG5cbiAgICAgIF9pY29uQ2hhbmdlZDogZnVuY3Rpb24oaWNvbikge1xuICAgICAgICB2YXIgcGFydHMgPSAoaWNvbiB8fCAnJykuc3BsaXQoJzonKTtcbiAgICAgICAgdGhpcy5faWNvbk5hbWUgPSBwYXJ0cy5wb3AoKTtcbiAgICAgICAgdGhpcy5faWNvbnNldE5hbWUgPSBwYXJ0cy5wb3AoKSB8fCB0aGlzLl9ERUZBVUxUX0lDT05TRVQ7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUljb24oKTtcbiAgICAgIH0sXG5cbiAgICAgIF9zcmNDaGFuZ2VkOiBmdW5jdGlvbihzcmMpIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlSWNvbigpO1xuICAgICAgfSxcblxuICAgICAgX3VzZXNJY29uc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaWNvbiB8fCAhdGhpcy5zcmM7XG4gICAgICB9LFxuXG4gICAgICAvKiogQHN1cHByZXNzIHt2aXNpYmlsaXR5fSAqL1xuICAgICAgX3VwZGF0ZUljb246IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fdXNlc0ljb25zZXQoKSkge1xuICAgICAgICAgIGlmICh0aGlzLl9pbWcgJiYgdGhpcy5faW1nLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIFBvbHltZXIuZG9tKHRoaXMucm9vdCkucmVtb3ZlQ2hpbGQodGhpcy5faW1nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRoaXMuX2ljb25OYW1lID09PSBcIlwiKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5faWNvbnNldCkge1xuICAgICAgICAgICAgICB0aGlzLl9pY29uc2V0LnJlbW92ZUljb24odGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9pY29uc2V0TmFtZSAmJiB0aGlzLl9tZXRhKSB7XG4gICAgICAgICAgICB0aGlzLl9pY29uc2V0ID0gLyoqIEB0eXBlIHs/UG9seW1lci5JY29uc2V0fSAqLyAoXG4gICAgICAgICAgICAgIHRoaXMuX21ldGEuYnlLZXkodGhpcy5faWNvbnNldE5hbWUpKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9pY29uc2V0KSB7XG4gICAgICAgICAgICAgIHRoaXMuX2ljb25zZXQuYXBwbHlJY29uKHRoaXMsIHRoaXMuX2ljb25OYW1lLCB0aGlzLnRoZW1lKTtcbiAgICAgICAgICAgICAgdGhpcy51bmxpc3Rlbih3aW5kb3csICdpcm9uLWljb25zZXQtYWRkZWQnLCAnX3VwZGF0ZUljb24nKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMubGlzdGVuKHdpbmRvdywgJ2lyb24taWNvbnNldC1hZGRlZCcsICdfdXBkYXRlSWNvbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodGhpcy5faWNvbnNldCkge1xuICAgICAgICAgICAgdGhpcy5faWNvbnNldC5yZW1vdmVJY29uKHRoaXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXRoaXMuX2ltZykge1xuICAgICAgICAgICAgdGhpcy5faW1nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XG4gICAgICAgICAgICB0aGlzLl9pbWcuc3R5bGUud2lkdGggPSAnMTAwJSc7XG4gICAgICAgICAgICB0aGlzLl9pbWcuc3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xuICAgICAgICAgICAgdGhpcy5faW1nLmRyYWdnYWJsZSA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9pbWcuc3JjID0gdGhpcy5zcmM7XG4gICAgICAgICAgUG9seW1lci5kb20odGhpcy5yb290KS5hcHBlbmRDaGlsZCh0aGlzLl9pbWcpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICB9KTtcblxuICA8L3NjcmlwdD5cblxuPC9kb20tbW9kdWxlPlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9pcm9uLWljb24vaXJvbi1pY29uLmh0bWwiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE1IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi9wb2x5bWVyL3BvbHltZXIuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL2lyb24tbWV0YS9pcm9uLW1ldGEuaHRtbFwiPlxuXG48c2NyaXB0PlxuICAvKipcbiAgICogVGhlIGBpcm9uLWljb25zZXQtc3ZnYCBlbGVtZW50IGFsbG93cyB1c2VycyB0byBkZWZpbmUgdGhlaXIgb3duIGljb24gc2V0c1xuICAgKiB0aGF0IGNvbnRhaW4gc3ZnIGljb25zLiBUaGUgc3ZnIGljb24gZWxlbWVudHMgc2hvdWxkIGJlIGNoaWxkcmVuIG9mIHRoZVxuICAgKiBgaXJvbi1pY29uc2V0LXN2Z2AgZWxlbWVudC4gTXVsdGlwbGUgaWNvbnMgc2hvdWxkIGJlIGdpdmVuIGRpc3RpbmN0IGlkJ3MuXG4gICAqXG4gICAqIFVzaW5nIHN2ZyBlbGVtZW50cyB0byBjcmVhdGUgaWNvbnMgaGFzIGEgZmV3IGFkdmFudGFnZXMgb3ZlciB0cmFkaXRpb25hbFxuICAgKiBiaXRtYXAgZ3JhcGhpY3MgbGlrZSBqcGcgb3IgcG5nLiBJY29ucyB0aGF0IHVzZSBzdmcgYXJlIHZlY3RvciBiYXNlZCBzb1xuICAgKiB0aGV5IGFyZSByZXNvbHV0aW9uIGluZGVwZW5kZW50IGFuZCBzaG91bGQgbG9vayBnb29kIG9uIGFueSBkZXZpY2UuIFRoZXlcbiAgICogYXJlIHN0eWxhYmxlIHZpYSBjc3MuIEljb25zIGNhbiBiZSB0aGVtZWQsIGNvbG9yaXplZCwgYW5kIGV2ZW4gYW5pbWF0ZWQuXG4gICAqXG4gICAqIEV4YW1wbGU6XG4gICAqXG4gICAqICAgICA8aXJvbi1pY29uc2V0LXN2ZyBuYW1lPVwibXktc3ZnLWljb25zXCIgc2l6ZT1cIjI0XCI+XG4gICAqICAgICAgIDxzdmc+XG4gICAqICAgICAgICAgPGRlZnM+XG4gICAqICAgICAgICAgICA8ZyBpZD1cInNoYXBlXCI+XG4gICAqICAgICAgICAgICAgIDxyZWN0IHg9XCIxMlwiIHk9XCIwXCIgd2lkdGg9XCIxMlwiIGhlaWdodD1cIjI0XCIgLz5cbiAgICogICAgICAgICAgICAgPGNpcmNsZSBjeD1cIjEyXCIgY3k9XCIxMlwiIHI9XCIxMlwiIC8+XG4gICAqICAgICAgICAgICA8L2c+XG4gICAqICAgICAgICAgPC9kZWZzPlxuICAgKiAgICAgICA8L3N2Zz5cbiAgICogICAgIDwvaXJvbi1pY29uc2V0LXN2Zz5cbiAgICpcbiAgICogVGhpcyB3aWxsIGF1dG9tYXRpY2FsbHkgcmVnaXN0ZXIgdGhlIGljb24gc2V0IFwibXktc3ZnLWljb25zXCIgdG8gdGhlIGljb25zZXRcbiAgICogZGF0YWJhc2UuICBUbyB1c2UgdGhlc2UgaWNvbnMgZnJvbSB3aXRoaW4gYW5vdGhlciBlbGVtZW50LCBtYWtlIGFcbiAgICogYGlyb24taWNvbnNldGAgZWxlbWVudCBhbmQgY2FsbCB0aGUgYGJ5SWRgIG1ldGhvZFxuICAgKiB0byByZXRyaWV2ZSBhIGdpdmVuIGljb25zZXQuIFRvIGFwcGx5IGEgcGFydGljdWxhciBpY29uIGluc2lkZSBhblxuICAgKiBlbGVtZW50IHVzZSB0aGUgYGFwcGx5SWNvbmAgbWV0aG9kLiBGb3IgZXhhbXBsZTpcbiAgICpcbiAgICogICAgIGljb25zZXQuYXBwbHlJY29uKGljb25Ob2RlLCAnY2FyJyk7XG4gICAqXG4gICAqIEBlbGVtZW50IGlyb24taWNvbnNldC1zdmdcbiAgICogQGRlbW8gZGVtby9pbmRleC5odG1sXG4gICAqIEBpbXBsZW1lbnRzIHtQb2x5bWVyLkljb25zZXR9XG4gICAqL1xuICBQb2x5bWVyKHtcbiAgICBpczogJ2lyb24taWNvbnNldC1zdmcnLFxuXG4gICAgcHJvcGVydGllczoge1xuXG4gICAgICAvKipcbiAgICAgICAqIFRoZSBuYW1lIG9mIHRoZSBpY29uc2V0LlxuICAgICAgICovXG4gICAgICBuYW1lOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgb2JzZXJ2ZXI6ICdfbmFtZUNoYW5nZWQnXG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFRoZSBzaXplIG9mIGFuIGluZGl2aWR1YWwgaWNvbi4gTm90ZSB0aGF0IGljb25zIG11c3QgYmUgc3F1YXJlLlxuICAgICAgICovXG4gICAgICBzaXplOiB7XG4gICAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgICAgdmFsdWU6IDI0XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFNldCB0byB0cnVlIHRvIGVuYWJsZSBtaXJyb3Jpbmcgb2YgaWNvbnMgd2hlcmUgc3BlY2lmaWVkIHdoZW4gdGhleSBhcmVcbiAgICAgICAqIHN0YW1wZWQuIEljb25zIHRoYXQgc2hvdWxkIGJlIG1pcnJvcmVkIHNob3VsZCBiZSBkZWNvcmF0ZWQgd2l0aCBhXG4gICAgICAgKiBgbWlycm9yLWluLXJ0bGAgYXR0cmlidXRlLlxuICAgICAgICpcbiAgICAgICAqIE5PVEU6IEZvciBwZXJmb3JtYW5jZSByZWFzb25zLCBkaXJlY3Rpb24gd2lsbCBiZSByZXNvbHZlZCBvbmNlIHBlclxuICAgICAgICogZG9jdW1lbnQgcGVyIGljb25zZXQsIHNvIG1vdmluZyBpY29ucyBpbiBhbmQgb3V0IG9mIFJUTCBzdWJ0cmVlcyB3aWxsXG4gICAgICAgKiBub3QgY2F1c2UgdGhlaXIgbWlycm9yZWQgc3RhdGUgdG8gY2hhbmdlLlxuICAgICAgICovXG4gICAgICBydGxNaXJyb3Jpbmc6IHtcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFNldCB0byB0cnVlIHRvIG1lYXN1cmUgUlRMIGJhc2VkIG9uIHRoZSBkaXIgYXR0cmlidXRlIG9uIHRoZSBib2R5IG9yXG4gICAgICAgKiBodG1sIGVsZW1lbnRzIChtZWFzdXJlZCBvbiBkb2N1bWVudC5ib2R5IG9yIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCBhc1xuICAgICAgICogYXZhaWxhYmxlKS5cbiAgICAgICAqL1xuICAgICAgdXNlR2xvYmFsUnRsQXR0cmlidXRlOiB7XG4gICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBjcmVhdGVkOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX21ldGEgPSBuZXcgUG9seW1lci5Jcm9uTWV0YSh7dHlwZTogJ2ljb25zZXQnLCBrZXk6IG51bGwsIHZhbHVlOiBudWxsfSk7XG4gICAgfSxcblxuICAgIGF0dGFjaGVkOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGFuIGFycmF5IG9mIGFsbCBpY29uIG5hbWVzIGluIHRoaXMgaWNvbnNldC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4geyFBcnJheX0gQXJyYXkgb2YgaWNvbiBuYW1lcy5cbiAgICAgKi9cbiAgICBnZXRJY29uTmFtZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5faWNvbnMgPSB0aGlzLl9jcmVhdGVJY29uTWFwKCk7XG4gICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5faWNvbnMpLm1hcChmdW5jdGlvbihuKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5hbWUgKyAnOicgKyBuO1xuICAgICAgfSwgdGhpcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgYW4gaWNvbiB0byB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEFuIHN2ZyBpY29uIGlzIHByZXBlbmRlZCB0byB0aGUgZWxlbWVudCdzIHNoYWRvd1Jvb3QgaWYgaXQgZXhpc3RzLFxuICAgICAqIG90aGVyd2lzZSB0byB0aGUgZWxlbWVudCBpdHNlbGYuXG4gICAgICpcbiAgICAgKiBJZiBSVEwgbWlycm9yaW5nIGlzIGVuYWJsZWQsIGFuZCB0aGUgaWNvbiBpcyBtYXJrZWQgdG8gYmUgbWlycm9yZWQgaW5cbiAgICAgKiBSVEwsIHRoZSBlbGVtZW50IHdpbGwgYmUgdGVzdGVkIChvbmNlIGFuZCBvbmx5IG9uY2UgZXZlciBmb3IgZWFjaFxuICAgICAqIGljb25zZXQpIHRvIGRldGVybWluZSB0aGUgZGlyZWN0aW9uIG9mIHRoZSBzdWJ0cmVlIHRoZSBlbGVtZW50IGlzIGluLlxuICAgICAqIFRoaXMgZGlyZWN0aW9uIHdpbGwgYXBwbHkgdG8gYWxsIGZ1dHVyZSBpY29uIGFwcGxpY2F0aW9ucywgYWx0aG91Z2ggb25seVxuICAgICAqIGljb25zIG1hcmtlZCB0byBiZSBtaXJyb3JlZCB3aWxsIGJlIGFmZmVjdGVkLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBhcHBseUljb25cbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0byB3aGljaCB0aGUgaWNvbiBpcyBhcHBsaWVkLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpY29uTmFtZSBOYW1lIG9mIHRoZSBpY29uIHRvIGFwcGx5LlxuICAgICAqIEByZXR1cm4gez9FbGVtZW50fSBUaGUgc3ZnIGVsZW1lbnQgd2hpY2ggcmVuZGVycyB0aGUgaWNvbi5cbiAgICAgKi9cbiAgICBhcHBseUljb246IGZ1bmN0aW9uKGVsZW1lbnQsIGljb25OYW1lKSB7XG4gICAgICAvLyBSZW1vdmUgb2xkIHN2ZyBlbGVtZW50XG4gICAgICB0aGlzLnJlbW92ZUljb24oZWxlbWVudCk7XG4gICAgICAvLyBpbnN0YWxsIG5ldyBzdmcgZWxlbWVudFxuICAgICAgdmFyIHN2ZyA9IHRoaXMuX2Nsb25lSWNvbihpY29uTmFtZSxcbiAgICAgICAgICB0aGlzLnJ0bE1pcnJvcmluZyAmJiB0aGlzLl90YXJnZXRJc1JUTChlbGVtZW50KSk7XG4gICAgICBpZiAoc3ZnKSB7XG4gICAgICAgIC8vIGluc2VydCBzdmcgZWxlbWVudCBpbnRvIHNoYWRvdyByb290LCBpZiBpdCBleGlzdHNcbiAgICAgICAgdmFyIHBkZSA9IFBvbHltZXIuZG9tKGVsZW1lbnQucm9vdCB8fCBlbGVtZW50KTtcbiAgICAgICAgcGRlLmluc2VydEJlZm9yZShzdmcsIHBkZS5jaGlsZE5vZGVzWzBdKTtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQuX3N2Z0ljb24gPSBzdmc7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGFuIGljb24gZnJvbSB0aGUgZ2l2ZW4gZWxlbWVudCBieSB1bmRvaW5nIHRoZSBjaGFuZ2VzIGVmZmVjdGVkXG4gICAgICogYnkgYGFwcGx5SWNvbmAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgVGhlIGVsZW1lbnQgZnJvbSB3aGljaCB0aGUgaWNvbiBpcyByZW1vdmVkLlxuICAgICAqL1xuICAgIHJlbW92ZUljb246IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgIC8vIFJlbW92ZSBvbGQgc3ZnIGVsZW1lbnRcbiAgICAgIGlmIChlbGVtZW50Ll9zdmdJY29uKSB7XG4gICAgICAgIFBvbHltZXIuZG9tKGVsZW1lbnQucm9vdCB8fCBlbGVtZW50KS5yZW1vdmVDaGlsZChlbGVtZW50Ll9zdmdJY29uKTtcbiAgICAgICAgZWxlbWVudC5fc3ZnSWNvbiA9IG51bGw7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1lYXN1cmVzIGFuZCBtZW1vaXplcyB0aGUgZGlyZWN0aW9uIG9mIHRoZSBlbGVtZW50LiBOb3RlIHRoYXQgdGhpc1xuICAgICAqIG1lYXN1cmVtZW50IGlzIG9ubHkgZG9uZSBvbmNlIGFuZCB0aGUgcmVzdWx0IGlzIG1lbW9pemVkIGZvciBmdXR1cmVcbiAgICAgKiBpbnZvY2F0aW9ucy5cbiAgICAgKi9cbiAgICBfdGFyZ2V0SXNSVEw6IGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgaWYgKHRoaXMuX190YXJnZXRJc1JUTCA9PSBudWxsKSB7XG4gICAgICAgIGlmICh0aGlzLnVzZUdsb2JhbFJ0bEF0dHJpYnV0ZSkge1xuICAgICAgICAgIHZhciBnbG9iYWxFbGVtZW50ID1cbiAgICAgICAgICAgICAgKGRvY3VtZW50LmJvZHkgJiYgZG9jdW1lbnQuYm9keS5oYXNBdHRyaWJ1dGUoJ2RpcicpKVxuICAgICAgICAgICAgICAgICAgPyBkb2N1bWVudC5ib2R5XG4gICAgICAgICAgICAgICAgICA6IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblxuICAgICAgICAgIHRoaXMuX190YXJnZXRJc1JUTCA9IGdsb2JhbEVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkaXInKSA9PT0gJ3J0bCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHRhcmdldCAmJiB0YXJnZXQubm9kZVR5cGUgIT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICB0YXJnZXQgPSB0YXJnZXQuaG9zdDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLl9fdGFyZ2V0SXNSVEwgPSB0YXJnZXQgJiZcbiAgICAgICAgICAgICAgd2luZG93LmdldENvbXB1dGVkU3R5bGUodGFyZ2V0KVsnZGlyZWN0aW9uJ10gPT09ICdydGwnO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9fdGFyZ2V0SXNSVEw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogV2hlbiBuYW1lIGlzIGNoYW5nZWQsIHJlZ2lzdGVyIGljb25zZXQgbWV0YWRhdGFcbiAgICAgKlxuICAgICAqL1xuICAgIF9uYW1lQ2hhbmdlZDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9tZXRhLnZhbHVlID0gbnVsbDtcbiAgICAgIHRoaXMuX21ldGEua2V5ID0gdGhpcy5uYW1lO1xuICAgICAgdGhpcy5fbWV0YS52YWx1ZSA9IHRoaXM7XG5cbiAgICAgIHRoaXMuYXN5bmMoZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZmlyZSgnaXJvbi1pY29uc2V0LWFkZGVkJywgdGhpcywge25vZGU6IHdpbmRvd30pO1xuICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG1hcCBvZiBjaGlsZCBTVkcgZWxlbWVudHMgYnkgaWQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHshT2JqZWN0fSBNYXAgb2YgaWQncyB0byBTVkcgZWxlbWVudHMuXG4gICAgICovXG4gICAgX2NyZWF0ZUljb25NYXA6IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gT2JqZWN0cyBjaGFpbmVkIHRvIE9iamVjdC5wcm90b3R5cGUgKGB7fWApIGhhdmUgbWVtYmVycy4gU3BlY2lmaWNhbGx5LFxuICAgICAgLy8gb24gRkYgdGhlcmUgaXMgYSBgd2F0Y2hgIG1ldGhvZCB0aGF0IGNvbmZ1c2VzIHRoZSBpY29uIG1hcCwgc28gd2VcbiAgICAgIC8vIG5lZWQgdG8gdXNlIGEgbnVsbC1iYXNlZCBvYmplY3QgaGVyZS5cbiAgICAgIHZhciBpY29ucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICBQb2x5bWVyLmRvbSh0aGlzKS5xdWVyeVNlbGVjdG9yQWxsKCdbaWRdJylcbiAgICAgICAgLmZvckVhY2goZnVuY3Rpb24oaWNvbikge1xuICAgICAgICAgIGljb25zW2ljb24uaWRdID0gaWNvbjtcbiAgICAgICAgfSk7XG4gICAgICByZXR1cm4gaWNvbnM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFByb2R1Y2UgaW5zdGFsbGFibGUgY2xvbmUgb2YgdGhlIFNWRyBlbGVtZW50IG1hdGNoaW5nIGBpZGAgaW4gdGhpc1xuICAgICAqIGljb25zZXQsIG9yIGB1bmRlZmluZWRgIGlmIHRoZXJlIGlzIG5vIG1hdGNoaW5nIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtFbGVtZW50fSBSZXR1cm5zIGFuIGluc3RhbGxhYmxlIGNsb25lIG9mIHRoZSBTVkcgZWxlbWVudFxuICAgICAqIG1hdGNoaW5nIGBpZGAuXG4gICAgICovXG4gICAgX2Nsb25lSWNvbjogZnVuY3Rpb24oaWQsIG1pcnJvckFsbG93ZWQpIHtcbiAgICAgIC8vIGNyZWF0ZSB0aGUgaWNvbiBtYXAgb24tZGVtYW5kLCBzaW5jZSB0aGUgaWNvbnNldCBpdHNlbGYgaGFzIG5vIGRpc2NyZXRlXG4gICAgICAvLyBzaWduYWwgdG8ga25vdyB3aGVuIGl0J3MgY2hpbGRyZW4gYXJlIGZ1bGx5IHBhcnNlZFxuICAgICAgdGhpcy5faWNvbnMgPSB0aGlzLl9pY29ucyB8fCB0aGlzLl9jcmVhdGVJY29uTWFwKCk7XG4gICAgICByZXR1cm4gdGhpcy5fcHJlcGFyZVN2Z0Nsb25lKHRoaXMuX2ljb25zW2lkXSwgdGhpcy5zaXplLCBtaXJyb3JBbGxvd2VkKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBzb3VyY2VTdmdcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2l6ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gbWlycm9yQWxsb3dlZFxuICAgICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAgICovXG4gICAgX3ByZXBhcmVTdmdDbG9uZTogZnVuY3Rpb24oc291cmNlU3ZnLCBzaXplLCBtaXJyb3JBbGxvd2VkKSB7XG4gICAgICBpZiAoc291cmNlU3ZnKSB7XG4gICAgICAgIHZhciBjb250ZW50ID0gc291cmNlU3ZnLmNsb25lTm9kZSh0cnVlKSxcbiAgICAgICAgICAgIHN2ZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCAnc3ZnJyksXG4gICAgICAgICAgICB2aWV3Qm94ID0gY29udGVudC5nZXRBdHRyaWJ1dGUoJ3ZpZXdCb3gnKSB8fCAnMCAwICcgKyBzaXplICsgJyAnICsgc2l6ZSxcbiAgICAgICAgICAgIGNzc1RleHQgPSAncG9pbnRlci1ldmVudHM6IG5vbmU7IGRpc3BsYXk6IGJsb2NrOyB3aWR0aDogMTAwJTsgaGVpZ2h0OiAxMDAlOyc7XG5cbiAgICAgICAgaWYgKG1pcnJvckFsbG93ZWQgJiYgY29udGVudC5oYXNBdHRyaWJ1dGUoJ21pcnJvci1pbi1ydGwnKSkge1xuICAgICAgICAgIGNzc1RleHQgKz0gJy13ZWJraXQtdHJhbnNmb3JtOnNjYWxlKC0xLDEpO3RyYW5zZm9ybTpzY2FsZSgtMSwxKTsnO1xuICAgICAgICB9XG5cbiAgICAgICAgc3ZnLnNldEF0dHJpYnV0ZSgndmlld0JveCcsIHZpZXdCb3gpO1xuICAgICAgICBzdmcuc2V0QXR0cmlidXRlKCdwcmVzZXJ2ZUFzcGVjdFJhdGlvJywgJ3hNaWRZTWlkIG1lZXQnKTtcbiAgICAgICAgc3ZnLnNldEF0dHJpYnV0ZSgnZm9jdXNhYmxlJywgJ2ZhbHNlJyk7XG4gICAgICAgIC8vIFRPRE8oZGZyZWVkbSk6IGBwb2ludGVyLWV2ZW50czogbm9uZWAgd29ya3MgYXJvdW5kIGh0dHBzOi8vY3JidWcuY29tLzM3MDEzNlxuICAgICAgICAvLyBUT0RPKHNqbWlsZXMpOiBpbmxpbmUgc3R5bGUgbWF5IG5vdCBiZSBpZGVhbCwgYnV0IGF2b2lkcyByZXF1aXJpbmcgYSBzaGFkb3ctcm9vdFxuICAgICAgICBzdmcuc3R5bGUuY3NzVGV4dCA9IGNzc1RleHQ7XG4gICAgICAgIHN2Zy5hcHBlbmRDaGlsZChjb250ZW50KS5yZW1vdmVBdHRyaWJ1dGUoJ2lkJyk7XG4gICAgICAgIHJldHVybiBzdmc7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgfSk7XG5cbjwvc2NyaXB0PlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9pcm9uLWljb25zZXQtc3ZnL2lyb24taWNvbnNldC1zdmcuaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTUgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cblxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3BvbHltZXIvcG9seW1lci5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vaXJvbi1pY29uL2lyb24taWNvbi5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vcGFwZXItYmVoYXZpb3JzL3BhcGVyLWlua3ktZm9jdXMtYmVoYXZpb3IuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3BhcGVyLXN0eWxlcy9kZWZhdWx0LXRoZW1lLmh0bWxcIj5cblxuPCEtLVxuTWF0ZXJpYWwgZGVzaWduOiBbSWNvbiB0b2dnbGVzXShodHRwczovL3d3dy5nb29nbGUuY29tL2Rlc2lnbi9zcGVjL2NvbXBvbmVudHMvYnV0dG9ucy5odG1sI2J1dHRvbnMtdG9nZ2xlLWJ1dHRvbnMpXG5cbmBwYXBlci1pY29uLWJ1dHRvbmAgaXMgYSBidXR0b24gd2l0aCBhbiBpbWFnZSBwbGFjZWQgYXQgdGhlIGNlbnRlci4gV2hlbiB0aGUgdXNlciB0b3VjaGVzXG50aGUgYnV0dG9uLCBhIHJpcHBsZSBlZmZlY3QgZW1hbmF0ZXMgZnJvbSB0aGUgY2VudGVyIG9mIHRoZSBidXR0b24uXG5cbmBwYXBlci1pY29uLWJ1dHRvbmAgZG9lcyBub3QgaW5jbHVkZSBhIGRlZmF1bHQgaWNvbiBzZXQuIFRvIHVzZSBpY29ucyBmcm9tIHRoZSBkZWZhdWx0XG5zZXQsIGluY2x1ZGUgYFBvbHltZXJFbGVtZW50cy9pcm9uLWljb25zL2lyb24taWNvbnMuaHRtbGAsIGFuZCB1c2UgdGhlIGBpY29uYCBhdHRyaWJ1dGUgdG8gc3BlY2lmeSB3aGljaCBpY29uXG5mcm9tIHRoZSBpY29uIHNldCB0byB1c2UuXG5cbiAgICA8cGFwZXItaWNvbi1idXR0b24gaWNvbj1cIm1lbnVcIj48L3BhcGVyLWljb24tYnV0dG9uPlxuXG5TZWUgW2Bpcm9uLWljb25zZXRgXShpcm9uLWljb25zZXQpIGZvciBtb3JlIGluZm9ybWF0aW9uIGFib3V0XG5ob3cgdG8gdXNlIGEgY3VzdG9tIGljb24gc2V0LlxuXG5FeGFtcGxlOlxuXG4gICAgPGxpbmsgaHJlZj1cInBhdGgvdG8vaXJvbi1pY29ucy9pcm9uLWljb25zLmh0bWxcIiByZWw9XCJpbXBvcnRcIj5cblxuICAgIDxwYXBlci1pY29uLWJ1dHRvbiBpY29uPVwiZmF2b3JpdGVcIj48L3BhcGVyLWljb24tYnV0dG9uPlxuICAgIDxwYXBlci1pY29uLWJ1dHRvbiBzcmM9XCJzdGFyLnBuZ1wiPjwvcGFwZXItaWNvbi1idXR0b24+XG5cblRvIHVzZSBgcGFwZXItaWNvbi1idXR0b25gIGFzIGEgbGluaywgd3JhcCBpdCBpbiBhbiBhbmNob3IgdGFnLiBTaW5jZSBgcGFwZXItaWNvbi1idXR0b25gXG53aWxsIGFscmVhZHkgcmVjZWl2ZSBmb2N1cywgeW91IG1heSB3YW50IHRvIHByZXZlbnQgdGhlIGFuY2hvciB0YWcgZnJvbSByZWNlaXZpbmcgZm9jdXNcbmFzIHdlbGwgYnkgc2V0dGluZyBpdHMgdGFiaW5kZXggdG8gLTEuXG5cbiAgICA8YSBocmVmPVwiaHR0cHM6Ly93d3cucG9seW1lci1wcm9qZWN0Lm9yZ1wiIHRhYmluZGV4PVwiLTFcIj5cbiAgICAgIDxwYXBlci1pY29uLWJ1dHRvbiBpY29uPVwicG9seW1lclwiPjwvcGFwZXItaWNvbi1idXR0b24+XG4gICAgPC9hPlxuXG4jIyMgU3R5bGluZ1xuXG5TdHlsZSB0aGUgYnV0dG9uIHdpdGggQ1NTIGFzIHlvdSB3b3VsZCBhIG5vcm1hbCBET00gZWxlbWVudC4gSWYgeW91IGFyZSB1c2luZyB0aGUgaWNvbnNcbnByb3ZpZGVkIGJ5IGBpcm9uLWljb25zYCwgdGhleSB3aWxsIGluaGVyaXQgdGhlIGZvcmVncm91bmQgY29sb3Igb2YgdGhlIGJ1dHRvbi5cblxuICAgIC8qIG1ha2UgYSByZWQgXCJmYXZvcml0ZVwiIGJ1dHRvbiAqL1xuICAgIDxwYXBlci1pY29uLWJ1dHRvbiBpY29uPVwiZmF2b3JpdGVcIiBzdHlsZT1cImNvbG9yOiByZWQ7XCI+PC9wYXBlci1pY29uLWJ1dHRvbj5cblxuQnkgZGVmYXVsdCwgdGhlIHJpcHBsZSBpcyB0aGUgc2FtZSBjb2xvciBhcyB0aGUgZm9yZWdyb3VuZCBhdCAyNSUgb3BhY2l0eS4gWW91IG1heVxuY3VzdG9taXplIHRoZSBjb2xvciB1c2luZyB0aGUgYC0tcGFwZXItaWNvbi1idXR0b24taW5rLWNvbG9yYCBjdXN0b20gcHJvcGVydHkuXG5cblRoZSBmb2xsb3dpbmcgY3VzdG9tIHByb3BlcnRpZXMgYW5kIG1peGlucyBhcmUgYXZhaWxhYmxlIGZvciBzdHlsaW5nOlxuXG5DdXN0b20gcHJvcGVydHkgfCBEZXNjcmlwdGlvbiB8IERlZmF1bHRcbi0tLS0tLS0tLS0tLS0tLS18LS0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tXG5gLS1wYXBlci1pY29uLWJ1dHRvbi1kaXNhYmxlZC10ZXh0YCB8IFRoZSBjb2xvciBvZiB0aGUgZGlzYWJsZWQgYnV0dG9uIHwgYC0tZGlzYWJsZWQtdGV4dC1jb2xvcmBcbmAtLXBhcGVyLWljb24tYnV0dG9uLWluay1jb2xvcmAgfCBTZWxlY3RlZC9mb2N1cyByaXBwbGUgY29sb3IgfCBgLS1wcmltYXJ5LXRleHQtY29sb3JgXG5gLS1wYXBlci1pY29uLWJ1dHRvbmAgfCBNaXhpbiBmb3IgYSBidXR0b24gfCBge31gXG5gLS1wYXBlci1pY29uLWJ1dHRvbi1kaXNhYmxlZGAgfCBNaXhpbiBmb3IgYSBkaXNhYmxlZCBidXR0b24gfCBge31gXG5gLS1wYXBlci1pY29uLWJ1dHRvbi1ob3ZlcmAgfCBNaXhpbiBmb3IgYnV0dG9uIG9uIGhvdmVyIHwgYHt9YFxuXG5AZ3JvdXAgUGFwZXIgRWxlbWVudHNcbkBlbGVtZW50IHBhcGVyLWljb24tYnV0dG9uXG5AZGVtbyBkZW1vL2luZGV4Lmh0bWxcbi0tPlxuXG48ZG9tLW1vZHVsZSBpZD1cInBhcGVyLWljb24tYnV0dG9uXCI+XG4gIDx0ZW1wbGF0ZSBzdHJpcC13aGl0ZXNwYWNlPlxuICAgIDxzdHlsZT5cbiAgICAgIDpob3N0IHtcbiAgICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgIHBhZGRpbmc6IDhweDtcbiAgICAgICAgb3V0bGluZTogbm9uZTtcbiAgICAgICAgLXdlYmtpdC11c2VyLXNlbGVjdDogbm9uZTtcbiAgICAgICAgLW1vei11c2VyLXNlbGVjdDogbm9uZTtcbiAgICAgICAgLW1zLXVzZXItc2VsZWN0OiBub25lO1xuICAgICAgICB1c2VyLXNlbGVjdDogbm9uZTtcbiAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xuICAgICAgICB6LWluZGV4OiAwO1xuICAgICAgICBsaW5lLWhlaWdodDogMTtcblxuICAgICAgICB3aWR0aDogNDBweDtcbiAgICAgICAgaGVpZ2h0OiA0MHB4O1xuXG4gICAgICAgIC8qIE5PVEU6IEJvdGggdmFsdWVzIGFyZSBuZWVkZWQsIHNpbmNlIHNvbWUgcGhvbmVzIHJlcXVpcmUgdGhlIHZhbHVlIHRvIGJlIGB0cmFuc3BhcmVudGAuICovXG4gICAgICAgIC13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvcjogcmdiYSgwLCAwLCAwLCAwKTtcbiAgICAgICAgLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yOiB0cmFuc3BhcmVudDtcblxuICAgICAgICAvKiBCZWNhdXNlIG9mIHBvbHltZXIvMjU1OCwgdGhpcyBzdHlsZSBoYXMgbG93ZXIgc3BlY2lmaWNpdHkgdGhhbiAqICovXG4gICAgICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3ggIWltcG9ydGFudDtcblxuICAgICAgICBAYXBwbHkgLS1wYXBlci1pY29uLWJ1dHRvbjtcbiAgICAgIH1cblxuICAgICAgOmhvc3QgI2luayB7XG4gICAgICAgIGNvbG9yOiB2YXIoLS1wYXBlci1pY29uLWJ1dHRvbi1pbmstY29sb3IsIHZhcigtLXByaW1hcnktdGV4dC1jb2xvcikpO1xuICAgICAgICBvcGFjaXR5OiAwLjY7XG4gICAgICB9XG5cbiAgICAgIDpob3N0KFtkaXNhYmxlZF0pIHtcbiAgICAgICAgY29sb3I6IHZhcigtLXBhcGVyLWljb24tYnV0dG9uLWRpc2FibGVkLXRleHQsIHZhcigtLWRpc2FibGVkLXRleHQtY29sb3IpKTtcbiAgICAgICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG4gICAgICAgIGN1cnNvcjogYXV0bztcblxuICAgICAgICBAYXBwbHkgLS1wYXBlci1pY29uLWJ1dHRvbi1kaXNhYmxlZDtcbiAgICAgIH1cblxuICAgICAgOmhvc3QoW2hpZGRlbl0pIHtcbiAgICAgICAgZGlzcGxheTogbm9uZSAhaW1wb3J0YW50O1xuICAgICAgfVxuXG4gICAgICA6aG9zdCg6aG92ZXIpIHtcbiAgICAgICAgQGFwcGx5IC0tcGFwZXItaWNvbi1idXR0b24taG92ZXI7XG4gICAgICB9XG5cbiAgICAgIGlyb24taWNvbiB7XG4gICAgICAgIC0taXJvbi1pY29uLXdpZHRoOiAxMDAlO1xuICAgICAgICAtLWlyb24taWNvbi1oZWlnaHQ6IDEwMCU7XG4gICAgICB9XG4gICAgPC9zdHlsZT5cblxuICAgIDxpcm9uLWljb24gaWQ9XCJpY29uXCIgc3JjPVwiW1tzcmNdXVwiIGljb249XCJbW2ljb25dXVwiIGFsdCQ9XCJbW2FsdF1dXCI+PC9pcm9uLWljb24+XG4gIDwvdGVtcGxhdGU+XG5cbiAgPHNjcmlwdD5cbiAgICBQb2x5bWVyKHtcbiAgICAgIGlzOiAncGFwZXItaWNvbi1idXR0b24nLFxuXG4gICAgICBob3N0QXR0cmlidXRlczoge1xuICAgICAgICByb2xlOiAnYnV0dG9uJyxcbiAgICAgICAgdGFiaW5kZXg6ICcwJ1xuICAgICAgfSxcblxuICAgICAgYmVoYXZpb3JzOiBbXG4gICAgICAgIFBvbHltZXIuUGFwZXJJbmt5Rm9jdXNCZWhhdmlvclxuICAgICAgXSxcblxuICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIFVSTCBvZiBhbiBpbWFnZSBmb3IgdGhlIGljb24uIElmIHRoZSBzcmMgcHJvcGVydHkgaXMgc3BlY2lmaWVkLFxuICAgICAgICAgKiB0aGUgaWNvbiBwcm9wZXJ0eSBzaG91bGQgbm90IGJlLlxuICAgICAgICAgKi9cbiAgICAgICAgc3JjOiB7XG4gICAgICAgICAgdHlwZTogU3RyaW5nXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB0aGUgaWNvbiBuYW1lIG9yIGluZGV4IGluIHRoZSBzZXQgb2YgaWNvbnMgYXZhaWxhYmxlIGluXG4gICAgICAgICAqIHRoZSBpY29uJ3MgaWNvbiBzZXQuIElmIHRoZSBpY29uIHByb3BlcnR5IGlzIHNwZWNpZmllZCxcbiAgICAgICAgICogdGhlIHNyYyBwcm9wZXJ0eSBzaG91bGQgbm90IGJlLlxuICAgICAgICAgKi9cbiAgICAgICAgaWNvbjoge1xuICAgICAgICAgIHR5cGU6IFN0cmluZ1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgdGhlIGFsdGVybmF0ZSB0ZXh0IGZvciB0aGUgYnV0dG9uLCBmb3IgYWNjZXNzaWJpbGl0eS5cbiAgICAgICAgICovXG4gICAgICAgIGFsdDoge1xuICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICBvYnNlcnZlcjogXCJfYWx0Q2hhbmdlZFwiXG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIF9hbHRDaGFuZ2VkOiBmdW5jdGlvbihuZXdWYWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdmFyIGxhYmVsID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnKTtcblxuICAgICAgICAvLyBEb24ndCBzdG9tcCBvdmVyIGEgdXNlci1zZXQgYXJpYS1sYWJlbC5cbiAgICAgICAgaWYgKCFsYWJlbCB8fCBvbGRWYWx1ZSA9PSBsYWJlbCkge1xuICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsJywgbmV3VmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIDwvc2NyaXB0PlxuPC9kb20tbW9kdWxlPlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9wYXBlci1pY29uLWJ1dHRvbi9wYXBlci1pY29uLWJ1dHRvbi5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNSBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuXG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vcG9seW1lci9wb2x5bWVyLmh0bWxcIj5cblxuPHNjcmlwdD5cblxuICAvKipcbiAgICogQGRlbW8gZGVtby9pbmRleC5odG1sXG4gICAqIEBwb2x5bWVyQmVoYXZpb3JcbiAgICovXG4gIFBvbHltZXIuSXJvbkNvbnRyb2xTdGF0ZSA9IHtcblxuICAgIHByb3BlcnRpZXM6IHtcblxuICAgICAgLyoqXG4gICAgICAgKiBJZiB0cnVlLCB0aGUgZWxlbWVudCBjdXJyZW50bHkgaGFzIGZvY3VzLlxuICAgICAgICovXG4gICAgICBmb2N1c2VkOiB7XG4gICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgIHZhbHVlOiBmYWxzZSxcbiAgICAgICAgbm90aWZ5OiB0cnVlLFxuICAgICAgICByZWFkT25seTogdHJ1ZSxcbiAgICAgICAgcmVmbGVjdFRvQXR0cmlidXRlOiB0cnVlXG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIElmIHRydWUsIHRoZSB1c2VyIGNhbm5vdCBpbnRlcmFjdCB3aXRoIHRoaXMgZWxlbWVudC5cbiAgICAgICAqL1xuICAgICAgZGlzYWJsZWQ6IHtcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgdmFsdWU6IGZhbHNlLFxuICAgICAgICBub3RpZnk6IHRydWUsXG4gICAgICAgIG9ic2VydmVyOiAnX2Rpc2FibGVkQ2hhbmdlZCcsXG4gICAgICAgIHJlZmxlY3RUb0F0dHJpYnV0ZTogdHJ1ZVxuICAgICAgfSxcblxuICAgICAgX29sZFRhYkluZGV4OiB7XG4gICAgICAgIHR5cGU6IE51bWJlclxuICAgICAgfSxcblxuICAgICAgX2JvdW5kRm9jdXNCbHVySGFuZGxlcjoge1xuICAgICAgICB0eXBlOiBGdW5jdGlvbixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9mb2N1c0JsdXJIYW5kbGVyLmJpbmQodGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIF9faGFuZGxlRXZlbnRSZXRhcmdldGluZzoge1xuICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuICF0aGlzLnNoYWRvd1Jvb3QgJiYgIVBvbHltZXIuRWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBvYnNlcnZlcnM6IFtcbiAgICAgICdfY2hhbmdlZENvbnRyb2xTdGF0ZShmb2N1c2VkLCBkaXNhYmxlZCknXG4gICAgXSxcblxuICAgIHJlYWR5OiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXMnLCB0aGlzLl9ib3VuZEZvY3VzQmx1ckhhbmRsZXIsIHRydWUpO1xuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgdGhpcy5fYm91bmRGb2N1c0JsdXJIYW5kbGVyLCB0cnVlKTtcbiAgICB9LFxuXG4gICAgX2ZvY3VzQmx1ckhhbmRsZXI6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAvLyBJbiBQb2x5bWVyIDIuMCwgdGhlIGxpYnJhcnkgdGFrZXMgY2FyZSBvZiByZXRhcmdldGluZyBldmVudHMuXG4gICAgICBpZiAoUG9seW1lci5FbGVtZW50KSB7XG4gICAgICAgIHRoaXMuX3NldEZvY3VzZWQoZXZlbnQudHlwZSA9PT0gJ2ZvY3VzJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gTk9URShjZGF0YSk6ICBpZiB3ZSBhcmUgaW4gU2hhZG93RE9NIGxhbmQsIGBldmVudC50YXJnZXRgIHdpbGxcbiAgICAgIC8vIGV2ZW50dWFsbHkgYmVjb21lIGB0aGlzYCBkdWUgdG8gcmV0YXJnZXRpbmc7IGlmIHdlIGFyZSBub3QgaW5cbiAgICAgIC8vIFNoYWRvd0RPTSBsYW5kLCBgZXZlbnQudGFyZ2V0YCB3aWxsIGV2ZW50dWFsbHkgYmVjb21lIGB0aGlzYCBkdWVcbiAgICAgIC8vIHRvIHRoZSBzZWNvbmQgY29uZGl0aW9uYWwgd2hpY2ggZmlyZXMgYSBzeW50aGV0aWMgZXZlbnQgKHRoYXQgaXMgYWxzb1xuICAgICAgLy8gaGFuZGxlZCkuIEluIGVpdGhlciBjYXNlLCB3ZSBjYW4gZGlzcmVnYXJkIGBldmVudC5wYXRoYC5cbiAgICAgIGlmIChldmVudC50YXJnZXQgPT09IHRoaXMpIHtcbiAgICAgICAgdGhpcy5fc2V0Rm9jdXNlZChldmVudC50eXBlID09PSAnZm9jdXMnKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fX2hhbmRsZUV2ZW50UmV0YXJnZXRpbmcpIHtcbiAgICAgICAgdmFyIHRhcmdldCA9IC8qKiBAdHlwZSB7Tm9kZX0gKi8oUG9seW1lci5kb20oZXZlbnQpLmxvY2FsVGFyZ2V0KTtcbiAgICAgICAgaWYgKCF0aGlzLmlzTGlnaHREZXNjZW5kYW50KHRhcmdldCkpIHtcbiAgICAgICAgICB0aGlzLmZpcmUoZXZlbnQudHlwZSwge3NvdXJjZUV2ZW50OiBldmVudH0sIHtcbiAgICAgICAgICAgIG5vZGU6IHRoaXMsXG4gICAgICAgICAgICBidWJibGVzOiBldmVudC5idWJibGVzLFxuICAgICAgICAgICAgY2FuY2VsYWJsZTogZXZlbnQuY2FuY2VsYWJsZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIF9kaXNhYmxlZENoYW5nZWQ6IGZ1bmN0aW9uKGRpc2FibGVkLCBvbGQpIHtcbiAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdhcmlhLWRpc2FibGVkJywgZGlzYWJsZWQgPyAndHJ1ZScgOiAnZmFsc2UnKTtcbiAgICAgIHRoaXMuc3R5bGUucG9pbnRlckV2ZW50cyA9IGRpc2FibGVkID8gJ25vbmUnIDogJyc7XG4gICAgICBpZiAoZGlzYWJsZWQpIHtcbiAgICAgICAgdGhpcy5fb2xkVGFiSW5kZXggPSB0aGlzLnRhYkluZGV4O1xuICAgICAgICB0aGlzLl9zZXRGb2N1c2VkKGZhbHNlKTtcbiAgICAgICAgdGhpcy50YWJJbmRleCA9IC0xO1xuICAgICAgICB0aGlzLmJsdXIoKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fb2xkVGFiSW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLnRhYkluZGV4ID0gdGhpcy5fb2xkVGFiSW5kZXg7XG4gICAgICB9XG4gICAgfSxcblxuICAgIF9jaGFuZ2VkQ29udHJvbFN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgIC8vIF9jb250cm9sU3RhdGVDaGFuZ2VkIGlzIGFic3RyYWN0LCBmb2xsb3ctb24gYmVoYXZpb3JzIG1heSBpbXBsZW1lbnQgaXRcbiAgICAgIGlmICh0aGlzLl9jb250cm9sU3RhdGVDaGFuZ2VkKSB7XG4gICAgICAgIHRoaXMuX2NvbnRyb2xTdGF0ZUNoYW5nZWQoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgfTtcblxuPC9zY3JpcHQ+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL2lyb24tYmVoYXZpb3JzL2lyb24tY29udHJvbC1zdGF0ZS5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNCBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuXG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vcG9seW1lci9wb2x5bWVyLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi9pcm9uLWExMXkta2V5cy1iZWhhdmlvci9pcm9uLWExMXkta2V5cy1iZWhhdmlvci5odG1sXCI+XG5cbjwhLS1cbk1hdGVyaWFsIGRlc2lnbjogW1N1cmZhY2UgcmVhY3Rpb25dKGh0dHBzOi8vd3d3Lmdvb2dsZS5jb20vZGVzaWduL3NwZWMvYW5pbWF0aW9uL3Jlc3BvbnNpdmUtaW50ZXJhY3Rpb24uaHRtbCNyZXNwb25zaXZlLWludGVyYWN0aW9uLXN1cmZhY2UtcmVhY3Rpb24pXG5cbmBwYXBlci1yaXBwbGVgIHByb3ZpZGVzIGEgdmlzdWFsIGVmZmVjdCB0aGF0IG90aGVyIHBhcGVyIGVsZW1lbnRzIGNhblxudXNlIHRvIHNpbXVsYXRlIGEgcmlwcGxpbmcgZWZmZWN0IGVtYW5hdGluZyBmcm9tIHRoZSBwb2ludCBvZiBjb250YWN0LiAgVGhlXG5lZmZlY3QgY2FuIGJlIHZpc3VhbGl6ZWQgYXMgYSBjb25jZW50cmljIGNpcmNsZSB3aXRoIG1vdGlvbi5cblxuRXhhbXBsZTpcblxuICAgIDxkaXYgc3R5bGU9XCJwb3NpdGlvbjpyZWxhdGl2ZVwiPlxuICAgICAgPHBhcGVyLXJpcHBsZT48L3BhcGVyLXJpcHBsZT5cbiAgICA8L2Rpdj5cblxuTm90ZSwgaXQncyBpbXBvcnRhbnQgdGhhdCB0aGUgcGFyZW50IGNvbnRhaW5lciBvZiB0aGUgcmlwcGxlIGJlIHJlbGF0aXZlIHBvc2l0aW9uLCBvdGhlcndpc2VcbnRoZSByaXBwbGUgd2lsbCBlbWFuYXRlIG91dHNpZGUgb2YgdGhlIGRlc2lyZWQgY29udGFpbmVyLlxuXG5gcGFwZXItcmlwcGxlYCBsaXN0ZW5zIHRvIFwibW91c2Vkb3duXCIgYW5kIFwibW91c2V1cFwiIGV2ZW50cyBzbyBpdCB3b3VsZCBkaXNwbGF5IHJpcHBsZVxuZWZmZWN0IHdoZW4gdG91Y2hlcyBvbiBpdC4gIFlvdSBjYW4gYWxzbyBkZWZlYXQgdGhlIGRlZmF1bHQgYmVoYXZpb3IgYW5kXG5tYW51YWxseSByb3V0ZSB0aGUgZG93biBhbmQgdXAgYWN0aW9ucyB0byB0aGUgcmlwcGxlIGVsZW1lbnQuICBOb3RlIHRoYXQgaXQgaXNcbmltcG9ydGFudCBpZiB5b3UgY2FsbCBgZG93bkFjdGlvbigpYCB5b3Ugd2lsbCBoYXZlIHRvIG1ha2Ugc3VyZSB0byBjYWxsXG5gdXBBY3Rpb24oKWAgc28gdGhhdCBgcGFwZXItcmlwcGxlYCB3b3VsZCBlbmQgdGhlIGFuaW1hdGlvbiBsb29wLlxuXG5FeGFtcGxlOlxuXG4gICAgPHBhcGVyLXJpcHBsZSBpZD1cInJpcHBsZVwiIHN0eWxlPVwicG9pbnRlci1ldmVudHM6IG5vbmU7XCI+PC9wYXBlci1yaXBwbGU+XG4gICAgLi4uXG4gICAgZG93bkFjdGlvbjogZnVuY3Rpb24oZSkge1xuICAgICAgdGhpcy4kLnJpcHBsZS5kb3duQWN0aW9uKGUuZGV0YWlsKTtcbiAgICB9LFxuICAgIHVwQWN0aW9uOiBmdW5jdGlvbihlKSB7XG4gICAgICB0aGlzLiQucmlwcGxlLnVwQWN0aW9uKCk7XG4gICAgfVxuXG5TdHlsaW5nIHJpcHBsZSBlZmZlY3Q6XG5cbiAgVXNlIENTUyBjb2xvciBwcm9wZXJ0eSB0byBzdHlsZSB0aGUgcmlwcGxlOlxuXG4gICAgcGFwZXItcmlwcGxlIHtcbiAgICAgIGNvbG9yOiAjNDI4NWY0O1xuICAgIH1cblxuICBOb3RlIHRoYXQgQ1NTIGNvbG9yIHByb3BlcnR5IGlzIGluaGVyaXRlZCBzbyBpdCBpcyBub3QgcmVxdWlyZWQgdG8gc2V0IGl0IG9uXG4gIHRoZSBgcGFwZXItcmlwcGxlYCBlbGVtZW50IGRpcmVjdGx5LlxuXG5CeSBkZWZhdWx0LCB0aGUgcmlwcGxlIGlzIGNlbnRlcmVkIG9uIHRoZSBwb2ludCBvZiBjb250YWN0LiAgQXBwbHkgdGhlIGByZWNlbnRlcnNgXG5hdHRyaWJ1dGUgdG8gaGF2ZSB0aGUgcmlwcGxlIGdyb3cgdG93YXJkIHRoZSBjZW50ZXIgb2YgaXRzIGNvbnRhaW5lci5cblxuICAgIDxwYXBlci1yaXBwbGUgcmVjZW50ZXJzPjwvcGFwZXItcmlwcGxlPlxuXG5Zb3UgY2FuIGFsc28gIGNlbnRlciB0aGUgcmlwcGxlIGluc2lkZSBpdHMgY29udGFpbmVyIGZyb20gdGhlIHN0YXJ0LlxuXG4gICAgPHBhcGVyLXJpcHBsZSBjZW50ZXI+PC9wYXBlci1yaXBwbGU+XG5cbkFwcGx5IGBjaXJjbGVgIGNsYXNzIHRvIG1ha2UgdGhlIHJpcHBsaW5nIGVmZmVjdCB3aXRoaW4gYSBjaXJjbGUuXG5cbiAgICA8cGFwZXItcmlwcGxlIGNsYXNzPVwiY2lyY2xlXCI+PC9wYXBlci1yaXBwbGU+XG5cbkBncm91cCBQYXBlciBFbGVtZW50c1xuQGVsZW1lbnQgcGFwZXItcmlwcGxlXG5AaGVybyBoZXJvLnN2Z1xuQGRlbW8gZGVtby9pbmRleC5odG1sXG4tLT5cblxuPGRvbS1tb2R1bGUgaWQ9XCJwYXBlci1yaXBwbGVcIj5cblxuICA8dGVtcGxhdGU+XG4gICAgPHN0eWxlPlxuICAgICAgOmhvc3Qge1xuICAgICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICBib3JkZXItcmFkaXVzOiBpbmhlcml0O1xuICAgICAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgICAgICB0b3A6IDA7XG4gICAgICAgIGxlZnQ6IDA7XG4gICAgICAgIHJpZ2h0OiAwO1xuICAgICAgICBib3R0b206IDA7XG5cbiAgICAgICAgLyogU2VlIFBvbHltZXJFbGVtZW50cy9wYXBlci1iZWhhdmlvcnMvaXNzdWVzLzM0LiBPbiBub24tQ2hyb21lIGJyb3dzZXJzLFxuICAgICAgICAgKiBjcmVhdGluZyBhIG5vZGUgKHdpdGggYSBwb3NpdGlvbjphYnNvbHV0ZSkgaW4gdGhlIG1pZGRsZSBvZiBhbiBldmVudFxuICAgICAgICAgKiBoYW5kbGVyIFwiaW50ZXJydXB0c1wiIHRoYXQgZXZlbnQgaGFuZGxlciAod2hpY2ggaGFwcGVucyB3aGVuIHRoZVxuICAgICAgICAgKiByaXBwbGUgaXMgY3JlYXRlZCBvbiBkZW1hbmQpICovXG4gICAgICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xuICAgICAgfVxuXG4gICAgICA6aG9zdChbYW5pbWF0aW5nXSkge1xuICAgICAgICAvKiBUaGlzIHJlc29sdmVzIGEgcmVuZGVyaW5nIGlzc3VlIGluIENocm9tZSAoYXMgb2YgNDApIHdoZXJlIHRoZVxuICAgICAgICAgICByaXBwbGUgaXMgbm90IHByb3Blcmx5IGNsaXBwZWQgYnkgaXRzIHBhcmVudCAod2hpY2ggbWF5IGhhdmVcbiAgICAgICAgICAgcm91bmRlZCBjb3JuZXJzKS4gU2VlOiBodHRwOi8vanNiaW4uY29tL3RlbWV4YS80XG5cbiAgICAgICAgICAgTm90ZTogV2Ugb25seSBhcHBseSB0aGlzIHN0eWxlIGNvbmRpdGlvbmFsbHkuIE90aGVyd2lzZSwgdGhlIGJyb3dzZXJcbiAgICAgICAgICAgd2lsbCBjcmVhdGUgYSBuZXcgY29tcG9zaXRpbmcgbGF5ZXIgZm9yIGV2ZXJ5IHJpcHBsZSBlbGVtZW50IG9uIHRoZVxuICAgICAgICAgICBwYWdlLCBhbmQgdGhhdCB3b3VsZCBiZSBiYWQuICovXG4gICAgICAgIC13ZWJraXQtdHJhbnNmb3JtOiB0cmFuc2xhdGUoMCwgMCk7XG4gICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoMCwgMCwgMCk7XG4gICAgICB9XG5cbiAgICAgICNiYWNrZ3JvdW5kLFxuICAgICAgI3dhdmVzLFxuICAgICAgLndhdmUtY29udGFpbmVyLFxuICAgICAgLndhdmUge1xuICAgICAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICB0b3A6IDA7XG4gICAgICAgIGxlZnQ6IDA7XG4gICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICBoZWlnaHQ6IDEwMCU7XG4gICAgICB9XG5cbiAgICAgICNiYWNrZ3JvdW5kLFxuICAgICAgLndhdmUge1xuICAgICAgICBvcGFjaXR5OiAwO1xuICAgICAgfVxuXG4gICAgICAjd2F2ZXMsXG4gICAgICAud2F2ZSB7XG4gICAgICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgICB9XG5cbiAgICAgIC53YXZlLWNvbnRhaW5lcixcbiAgICAgIC53YXZlIHtcbiAgICAgICAgYm9yZGVyLXJhZGl1czogNTAlO1xuICAgICAgfVxuXG4gICAgICA6aG9zdCguY2lyY2xlKSAjYmFja2dyb3VuZCxcbiAgICAgIDpob3N0KC5jaXJjbGUpICN3YXZlcyB7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDUwJTtcbiAgICAgIH1cblxuICAgICAgOmhvc3QoLmNpcmNsZSkgLndhdmUtY29udGFpbmVyIHtcbiAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICAgIH1cbiAgICA8L3N0eWxlPlxuXG4gICAgPGRpdiBpZD1cImJhY2tncm91bmRcIj48L2Rpdj5cbiAgICA8ZGl2IGlkPVwid2F2ZXNcIj48L2Rpdj5cbiAgPC90ZW1wbGF0ZT5cbjwvZG9tLW1vZHVsZT5cbjxzY3JpcHQ+XG4gIChmdW5jdGlvbigpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgVXRpbGl0eSA9IHtcbiAgICAgIGRpc3RhbmNlOiBmdW5jdGlvbih4MSwgeTEsIHgyLCB5Mikge1xuICAgICAgICB2YXIgeERlbHRhID0gKHgxIC0geDIpO1xuICAgICAgICB2YXIgeURlbHRhID0gKHkxIC0geTIpO1xuXG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQoeERlbHRhICogeERlbHRhICsgeURlbHRhICogeURlbHRhKTtcbiAgICAgIH0sXG5cbiAgICAgIG5vdzogd2luZG93LnBlcmZvcm1hbmNlICYmIHdpbmRvdy5wZXJmb3JtYW5jZS5ub3cgP1xuICAgICAgICAgIHdpbmRvdy5wZXJmb3JtYW5jZS5ub3cuYmluZCh3aW5kb3cucGVyZm9ybWFuY2UpIDogRGF0ZS5ub3dcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEVsZW1lbnRNZXRyaWNzKGVsZW1lbnQpIHtcbiAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICB0aGlzLndpZHRoID0gdGhpcy5ib3VuZGluZ1JlY3Qud2lkdGg7XG4gICAgICB0aGlzLmhlaWdodCA9IHRoaXMuYm91bmRpbmdSZWN0LmhlaWdodDtcblxuICAgICAgdGhpcy5zaXplID0gTWF0aC5tYXgodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgIH1cblxuICAgIEVsZW1lbnRNZXRyaWNzLnByb3RvdHlwZSA9IHtcbiAgICAgIGdldCBib3VuZGluZ1JlY3QgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgfSxcblxuICAgICAgZnVydGhlc3RDb3JuZXJEaXN0YW5jZUZyb206IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgdmFyIHRvcExlZnQgPSBVdGlsaXR5LmRpc3RhbmNlKHgsIHksIDAsIDApO1xuICAgICAgICB2YXIgdG9wUmlnaHQgPSBVdGlsaXR5LmRpc3RhbmNlKHgsIHksIHRoaXMud2lkdGgsIDApO1xuICAgICAgICB2YXIgYm90dG9tTGVmdCA9IFV0aWxpdHkuZGlzdGFuY2UoeCwgeSwgMCwgdGhpcy5oZWlnaHQpO1xuICAgICAgICB2YXIgYm90dG9tUmlnaHQgPSBVdGlsaXR5LmRpc3RhbmNlKHgsIHksIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcblxuICAgICAgICByZXR1cm4gTWF0aC5tYXgodG9wTGVmdCwgdG9wUmlnaHQsIGJvdHRvbUxlZnQsIGJvdHRvbVJpZ2h0KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFJpcHBsZShlbGVtZW50KSB7XG4gICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgdGhpcy5jb2xvciA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLmNvbG9yO1xuXG4gICAgICB0aGlzLndhdmUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHRoaXMud2F2ZUNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgdGhpcy53YXZlLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IHRoaXMuY29sb3I7XG4gICAgICB0aGlzLndhdmUuY2xhc3NMaXN0LmFkZCgnd2F2ZScpO1xuICAgICAgdGhpcy53YXZlQ29udGFpbmVyLmNsYXNzTGlzdC5hZGQoJ3dhdmUtY29udGFpbmVyJyk7XG4gICAgICBQb2x5bWVyLmRvbSh0aGlzLndhdmVDb250YWluZXIpLmFwcGVuZENoaWxkKHRoaXMud2F2ZSk7XG5cbiAgICAgIHRoaXMucmVzZXRJbnRlcmFjdGlvblN0YXRlKCk7XG4gICAgfVxuXG4gICAgUmlwcGxlLk1BWF9SQURJVVMgPSAzMDA7XG5cbiAgICBSaXBwbGUucHJvdG90eXBlID0ge1xuICAgICAgZ2V0IHJlY2VudGVycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudC5yZWNlbnRlcnM7XG4gICAgICB9LFxuXG4gICAgICBnZXQgY2VudGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50LmNlbnRlcjtcbiAgICAgIH0sXG5cbiAgICAgIGdldCBtb3VzZURvd25FbGFwc2VkKCkge1xuICAgICAgICB2YXIgZWxhcHNlZDtcblxuICAgICAgICBpZiAoIXRoaXMubW91c2VEb3duU3RhcnQpIHtcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsYXBzZWQgPSBVdGlsaXR5Lm5vdygpIC0gdGhpcy5tb3VzZURvd25TdGFydDtcblxuICAgICAgICBpZiAodGhpcy5tb3VzZVVwU3RhcnQpIHtcbiAgICAgICAgICBlbGFwc2VkIC09IHRoaXMubW91c2VVcEVsYXBzZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZWxhcHNlZDtcbiAgICAgIH0sXG5cbiAgICAgIGdldCBtb3VzZVVwRWxhcHNlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW91c2VVcFN0YXJ0ID9cbiAgICAgICAgICBVdGlsaXR5Lm5vdyAoKSAtIHRoaXMubW91c2VVcFN0YXJ0IDogMDtcbiAgICAgIH0sXG5cbiAgICAgIGdldCBtb3VzZURvd25FbGFwc2VkU2Vjb25kcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW91c2VEb3duRWxhcHNlZCAvIDEwMDA7XG4gICAgICB9LFxuXG4gICAgICBnZXQgbW91c2VVcEVsYXBzZWRTZWNvbmRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb3VzZVVwRWxhcHNlZCAvIDEwMDA7XG4gICAgICB9LFxuXG4gICAgICBnZXQgbW91c2VJbnRlcmFjdGlvblNlY29uZHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vdXNlRG93bkVsYXBzZWRTZWNvbmRzICsgdGhpcy5tb3VzZVVwRWxhcHNlZFNlY29uZHM7XG4gICAgICB9LFxuXG4gICAgICBnZXQgaW5pdGlhbE9wYWNpdHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnQuaW5pdGlhbE9wYWNpdHk7XG4gICAgICB9LFxuXG4gICAgICBnZXQgb3BhY2l0eURlY2F5VmVsb2NpdHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnQub3BhY2l0eURlY2F5VmVsb2NpdHk7XG4gICAgICB9LFxuXG4gICAgICBnZXQgcmFkaXVzKCkge1xuICAgICAgICB2YXIgd2lkdGgyID0gdGhpcy5jb250YWluZXJNZXRyaWNzLndpZHRoICogdGhpcy5jb250YWluZXJNZXRyaWNzLndpZHRoO1xuICAgICAgICB2YXIgaGVpZ2h0MiA9IHRoaXMuY29udGFpbmVyTWV0cmljcy5oZWlnaHQgKiB0aGlzLmNvbnRhaW5lck1ldHJpY3MuaGVpZ2h0O1xuICAgICAgICB2YXIgd2F2ZVJhZGl1cyA9IE1hdGgubWluKFxuICAgICAgICAgIE1hdGguc3FydCh3aWR0aDIgKyBoZWlnaHQyKSxcbiAgICAgICAgICBSaXBwbGUuTUFYX1JBRElVU1xuICAgICAgICApICogMS4xICsgNTtcblxuICAgICAgICB2YXIgZHVyYXRpb24gPSAxLjEgLSAwLjIgKiAod2F2ZVJhZGl1cyAvIFJpcHBsZS5NQVhfUkFESVVTKTtcbiAgICAgICAgdmFyIHRpbWVOb3cgPSB0aGlzLm1vdXNlSW50ZXJhY3Rpb25TZWNvbmRzIC8gZHVyYXRpb247XG4gICAgICAgIHZhciBzaXplID0gd2F2ZVJhZGl1cyAqICgxIC0gTWF0aC5wb3coODAsIC10aW1lTm93KSk7XG5cbiAgICAgICAgcmV0dXJuIE1hdGguYWJzKHNpemUpO1xuICAgICAgfSxcblxuICAgICAgZ2V0IG9wYWNpdHkoKSB7XG4gICAgICAgIGlmICghdGhpcy5tb3VzZVVwU3RhcnQpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5pbml0aWFsT3BhY2l0eTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBNYXRoLm1heChcbiAgICAgICAgICAwLFxuICAgICAgICAgIHRoaXMuaW5pdGlhbE9wYWNpdHkgLSB0aGlzLm1vdXNlVXBFbGFwc2VkU2Vjb25kcyAqIHRoaXMub3BhY2l0eURlY2F5VmVsb2NpdHlcbiAgICAgICAgKTtcbiAgICAgIH0sXG5cbiAgICAgIGdldCBvdXRlck9wYWNpdHkoKSB7XG4gICAgICAgIC8vIExpbmVhciBpbmNyZWFzZSBpbiBiYWNrZ3JvdW5kIG9wYWNpdHksIGNhcHBlZCBhdCB0aGUgb3BhY2l0eVxuICAgICAgICAvLyBvZiB0aGUgd2F2ZWZyb250ICh3YXZlT3BhY2l0eSkuXG4gICAgICAgIHZhciBvdXRlck9wYWNpdHkgPSB0aGlzLm1vdXNlVXBFbGFwc2VkU2Vjb25kcyAqIDAuMztcbiAgICAgICAgdmFyIHdhdmVPcGFjaXR5ID0gdGhpcy5vcGFjaXR5O1xuXG4gICAgICAgIHJldHVybiBNYXRoLm1heChcbiAgICAgICAgICAwLFxuICAgICAgICAgIE1hdGgubWluKG91dGVyT3BhY2l0eSwgd2F2ZU9wYWNpdHkpXG4gICAgICAgICk7XG4gICAgICB9LFxuXG4gICAgICBnZXQgaXNPcGFjaXR5RnVsbHlEZWNheWVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcGFjaXR5IDwgMC4wMSAmJlxuICAgICAgICAgIHRoaXMucmFkaXVzID49IE1hdGgubWluKHRoaXMubWF4UmFkaXVzLCBSaXBwbGUuTUFYX1JBRElVUyk7XG4gICAgICB9LFxuXG4gICAgICBnZXQgaXNSZXN0aW5nQXRNYXhSYWRpdXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wYWNpdHkgPj0gdGhpcy5pbml0aWFsT3BhY2l0eSAmJlxuICAgICAgICAgIHRoaXMucmFkaXVzID49IE1hdGgubWluKHRoaXMubWF4UmFkaXVzLCBSaXBwbGUuTUFYX1JBRElVUyk7XG4gICAgICB9LFxuXG4gICAgICBnZXQgaXNBbmltYXRpb25Db21wbGV0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW91c2VVcFN0YXJ0ID9cbiAgICAgICAgICB0aGlzLmlzT3BhY2l0eUZ1bGx5RGVjYXllZCA6IHRoaXMuaXNSZXN0aW5nQXRNYXhSYWRpdXM7XG4gICAgICB9LFxuXG4gICAgICBnZXQgdHJhbnNsYXRpb25GcmFjdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubWluKFxuICAgICAgICAgIDEsXG4gICAgICAgICAgdGhpcy5yYWRpdXMgLyB0aGlzLmNvbnRhaW5lck1ldHJpY3Muc2l6ZSAqIDIgLyBNYXRoLnNxcnQoMilcbiAgICAgICAgKTtcbiAgICAgIH0sXG5cbiAgICAgIGdldCB4Tm93KCkge1xuICAgICAgICBpZiAodGhpcy54RW5kKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMueFN0YXJ0ICsgdGhpcy50cmFuc2xhdGlvbkZyYWN0aW9uICogKHRoaXMueEVuZCAtIHRoaXMueFN0YXJ0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLnhTdGFydDtcbiAgICAgIH0sXG5cbiAgICAgIGdldCB5Tm93KCkge1xuICAgICAgICBpZiAodGhpcy55RW5kKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMueVN0YXJ0ICsgdGhpcy50cmFuc2xhdGlvbkZyYWN0aW9uICogKHRoaXMueUVuZCAtIHRoaXMueVN0YXJ0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLnlTdGFydDtcbiAgICAgIH0sXG5cbiAgICAgIGdldCBpc01vdXNlRG93bigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW91c2VEb3duU3RhcnQgJiYgIXRoaXMubW91c2VVcFN0YXJ0O1xuICAgICAgfSxcblxuICAgICAgcmVzZXRJbnRlcmFjdGlvblN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5tYXhSYWRpdXMgPSAwO1xuICAgICAgICB0aGlzLm1vdXNlRG93blN0YXJ0ID0gMDtcbiAgICAgICAgdGhpcy5tb3VzZVVwU3RhcnQgPSAwO1xuXG4gICAgICAgIHRoaXMueFN0YXJ0ID0gMDtcbiAgICAgICAgdGhpcy55U3RhcnQgPSAwO1xuICAgICAgICB0aGlzLnhFbmQgPSAwO1xuICAgICAgICB0aGlzLnlFbmQgPSAwO1xuICAgICAgICB0aGlzLnNsaWRlRGlzdGFuY2UgPSAwO1xuXG4gICAgICAgIHRoaXMuY29udGFpbmVyTWV0cmljcyA9IG5ldyBFbGVtZW50TWV0cmljcyh0aGlzLmVsZW1lbnQpO1xuICAgICAgfSxcblxuICAgICAgZHJhdzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzY2FsZTtcbiAgICAgICAgdmFyIHRyYW5zbGF0ZVN0cmluZztcbiAgICAgICAgdmFyIGR4O1xuICAgICAgICB2YXIgZHk7XG5cbiAgICAgICAgdGhpcy53YXZlLnN0eWxlLm9wYWNpdHkgPSB0aGlzLm9wYWNpdHk7XG5cbiAgICAgICAgc2NhbGUgPSB0aGlzLnJhZGl1cyAvICh0aGlzLmNvbnRhaW5lck1ldHJpY3Muc2l6ZSAvIDIpO1xuICAgICAgICBkeCA9IHRoaXMueE5vdyAtICh0aGlzLmNvbnRhaW5lck1ldHJpY3Mud2lkdGggLyAyKTtcbiAgICAgICAgZHkgPSB0aGlzLnlOb3cgLSAodGhpcy5jb250YWluZXJNZXRyaWNzLmhlaWdodCAvIDIpO1xuXG5cbiAgICAgICAgLy8gMmQgdHJhbnNmb3JtIGZvciBzYWZhcmkgYmVjYXVzZSBvZiBib3JkZXItcmFkaXVzIGFuZCBvdmVyZmxvdzpoaWRkZW4gY2xpcHBpbmcgYnVnLlxuICAgICAgICAvLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9OTg1MzhcbiAgICAgICAgdGhpcy53YXZlQ29udGFpbmVyLnN0eWxlLndlYmtpdFRyYW5zZm9ybSA9ICd0cmFuc2xhdGUoJyArIGR4ICsgJ3B4LCAnICsgZHkgKyAncHgpJztcbiAgICAgICAgdGhpcy53YXZlQ29udGFpbmVyLnN0eWxlLnRyYW5zZm9ybSA9ICd0cmFuc2xhdGUzZCgnICsgZHggKyAncHgsICcgKyBkeSArICdweCwgMCknO1xuICAgICAgICB0aGlzLndhdmUuc3R5bGUud2Via2l0VHJhbnNmb3JtID0gJ3NjYWxlKCcgKyBzY2FsZSArICcsJyArIHNjYWxlICsgJyknO1xuICAgICAgICB0aGlzLndhdmUuc3R5bGUudHJhbnNmb3JtID0gJ3NjYWxlM2QoJyArIHNjYWxlICsgJywnICsgc2NhbGUgKyAnLDEpJztcbiAgICAgIH0sXG5cbiAgICAgIC8qKiBAcGFyYW0ge0V2ZW50PX0gZXZlbnQgKi9cbiAgICAgIGRvd25BY3Rpb246IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIHZhciB4Q2VudGVyID0gdGhpcy5jb250YWluZXJNZXRyaWNzLndpZHRoIC8gMjtcbiAgICAgICAgdmFyIHlDZW50ZXIgPSB0aGlzLmNvbnRhaW5lck1ldHJpY3MuaGVpZ2h0IC8gMjtcblxuICAgICAgICB0aGlzLnJlc2V0SW50ZXJhY3Rpb25TdGF0ZSgpO1xuICAgICAgICB0aGlzLm1vdXNlRG93blN0YXJ0ID0gVXRpbGl0eS5ub3coKTtcblxuICAgICAgICBpZiAodGhpcy5jZW50ZXIpIHtcbiAgICAgICAgICB0aGlzLnhTdGFydCA9IHhDZW50ZXI7XG4gICAgICAgICAgdGhpcy55U3RhcnQgPSB5Q2VudGVyO1xuICAgICAgICAgIHRoaXMuc2xpZGVEaXN0YW5jZSA9IFV0aWxpdHkuZGlzdGFuY2UoXG4gICAgICAgICAgICB0aGlzLnhTdGFydCwgdGhpcy55U3RhcnQsIHRoaXMueEVuZCwgdGhpcy55RW5kXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnhTdGFydCA9IGV2ZW50ID9cbiAgICAgICAgICAgICAgZXZlbnQuZGV0YWlsLnggLSB0aGlzLmNvbnRhaW5lck1ldHJpY3MuYm91bmRpbmdSZWN0LmxlZnQgOlxuICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lck1ldHJpY3Mud2lkdGggLyAyO1xuICAgICAgICAgIHRoaXMueVN0YXJ0ID0gZXZlbnQgP1xuICAgICAgICAgICAgICBldmVudC5kZXRhaWwueSAtIHRoaXMuY29udGFpbmVyTWV0cmljcy5ib3VuZGluZ1JlY3QudG9wIDpcbiAgICAgICAgICAgICAgdGhpcy5jb250YWluZXJNZXRyaWNzLmhlaWdodCAvIDI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5yZWNlbnRlcnMpIHtcbiAgICAgICAgICB0aGlzLnhFbmQgPSB4Q2VudGVyO1xuICAgICAgICAgIHRoaXMueUVuZCA9IHlDZW50ZXI7XG4gICAgICAgICAgdGhpcy5zbGlkZURpc3RhbmNlID0gVXRpbGl0eS5kaXN0YW5jZShcbiAgICAgICAgICAgIHRoaXMueFN0YXJ0LCB0aGlzLnlTdGFydCwgdGhpcy54RW5kLCB0aGlzLnlFbmRcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5tYXhSYWRpdXMgPSB0aGlzLmNvbnRhaW5lck1ldHJpY3MuZnVydGhlc3RDb3JuZXJEaXN0YW5jZUZyb20oXG4gICAgICAgICAgdGhpcy54U3RhcnQsXG4gICAgICAgICAgdGhpcy55U3RhcnRcbiAgICAgICAgKTtcblxuICAgICAgICB0aGlzLndhdmVDb250YWluZXIuc3R5bGUudG9wID1cbiAgICAgICAgICAodGhpcy5jb250YWluZXJNZXRyaWNzLmhlaWdodCAtIHRoaXMuY29udGFpbmVyTWV0cmljcy5zaXplKSAvIDIgKyAncHgnO1xuICAgICAgICB0aGlzLndhdmVDb250YWluZXIuc3R5bGUubGVmdCA9XG4gICAgICAgICAgKHRoaXMuY29udGFpbmVyTWV0cmljcy53aWR0aCAtIHRoaXMuY29udGFpbmVyTWV0cmljcy5zaXplKSAvIDIgKyAncHgnO1xuXG4gICAgICAgIHRoaXMud2F2ZUNvbnRhaW5lci5zdHlsZS53aWR0aCA9IHRoaXMuY29udGFpbmVyTWV0cmljcy5zaXplICsgJ3B4JztcbiAgICAgICAgdGhpcy53YXZlQ29udGFpbmVyLnN0eWxlLmhlaWdodCA9IHRoaXMuY29udGFpbmVyTWV0cmljcy5zaXplICsgJ3B4JztcbiAgICAgIH0sXG5cbiAgICAgIC8qKiBAcGFyYW0ge0V2ZW50PX0gZXZlbnQgKi9cbiAgICAgIHVwQWN0aW9uOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNNb3VzZURvd24pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm1vdXNlVXBTdGFydCA9IFV0aWxpdHkubm93KCk7XG4gICAgICB9LFxuXG4gICAgICByZW1vdmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBQb2x5bWVyLmRvbSh0aGlzLndhdmVDb250YWluZXIucGFyZW50Tm9kZSkucmVtb3ZlQ2hpbGQoXG4gICAgICAgICAgdGhpcy53YXZlQ29udGFpbmVyXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIFBvbHltZXIoe1xuICAgICAgaXM6ICdwYXBlci1yaXBwbGUnLFxuXG4gICAgICBiZWhhdmlvcnM6IFtcbiAgICAgICAgUG9seW1lci5Jcm9uQTExeUtleXNCZWhhdmlvclxuICAgICAgXSxcblxuICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGluaXRpYWwgb3BhY2l0eSBzZXQgb24gdGhlIHdhdmUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBhdHRyaWJ1dGUgaW5pdGlhbE9wYWNpdHlcbiAgICAgICAgICogQHR5cGUgbnVtYmVyXG4gICAgICAgICAqIEBkZWZhdWx0IDAuMjVcbiAgICAgICAgICovXG4gICAgICAgIGluaXRpYWxPcGFjaXR5OiB7XG4gICAgICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgICAgIHZhbHVlOiAwLjI1XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEhvdyBmYXN0IChvcGFjaXR5IHBlciBzZWNvbmQpIHRoZSB3YXZlIGZhZGVzIG91dC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGF0dHJpYnV0ZSBvcGFjaXR5RGVjYXlWZWxvY2l0eVxuICAgICAgICAgKiBAdHlwZSBudW1iZXJcbiAgICAgICAgICogQGRlZmF1bHQgMC44XG4gICAgICAgICAqL1xuICAgICAgICBvcGFjaXR5RGVjYXlWZWxvY2l0eToge1xuICAgICAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgICAgICB2YWx1ZTogMC44XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHRydWUsIHJpcHBsZXMgd2lsbCBleGhpYml0IGEgZ3Jhdml0YXRpb25hbCBwdWxsIHRvd2FyZHNcbiAgICAgICAgICogdGhlIGNlbnRlciBvZiB0aGVpciBjb250YWluZXIgYXMgdGhleSBmYWRlIGF3YXkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBhdHRyaWJ1dGUgcmVjZW50ZXJzXG4gICAgICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIHJlY2VudGVyczoge1xuICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHRydWUsIHJpcHBsZXMgd2lsbCBjZW50ZXIgaW5zaWRlIGl0cyBjb250YWluZXJcbiAgICAgICAgICpcbiAgICAgICAgICogQGF0dHJpYnV0ZSByZWNlbnRlcnNcbiAgICAgICAgICogQHR5cGUgYm9vbGVhblxuICAgICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgY2VudGVyOiB7XG4gICAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQSBsaXN0IG9mIHRoZSB2aXN1YWwgcmlwcGxlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQGF0dHJpYnV0ZSByaXBwbGVzXG4gICAgICAgICAqIEB0eXBlIEFycmF5XG4gICAgICAgICAqIEBkZWZhdWx0IFtdXG4gICAgICAgICAqL1xuICAgICAgICByaXBwbGVzOiB7XG4gICAgICAgICAgdHlwZTogQXJyYXksXG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVHJ1ZSB3aGVuIHRoZXJlIGFyZSB2aXNpYmxlIHJpcHBsZXMgYW5pbWF0aW5nIHdpdGhpbiB0aGVcbiAgICAgICAgICogZWxlbWVudC5cbiAgICAgICAgICovXG4gICAgICAgIGFuaW1hdGluZzoge1xuICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgICAgcmVhZE9ubHk6IHRydWUsXG4gICAgICAgICAgcmVmbGVjdFRvQXR0cmlidXRlOiB0cnVlLFxuICAgICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0cnVlLCB0aGUgcmlwcGxlIHdpbGwgcmVtYWluIGluIHRoZSBcImRvd25cIiBzdGF0ZSB1bnRpbCBgaG9sZERvd25gXG4gICAgICAgICAqIGlzIHNldCB0byBmYWxzZSBhZ2Fpbi5cbiAgICAgICAgICovXG4gICAgICAgIGhvbGREb3duOiB7XG4gICAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgICB2YWx1ZTogZmFsc2UsXG4gICAgICAgICAgb2JzZXJ2ZXI6ICdfaG9sZERvd25DaGFuZ2VkJ1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0cnVlLCB0aGUgcmlwcGxlIHdpbGwgbm90IGdlbmVyYXRlIGEgcmlwcGxlIGVmZmVjdFxuICAgICAgICAgKiB2aWEgcG9pbnRlciBpbnRlcmFjdGlvbi5cbiAgICAgICAgICogQ2FsbGluZyByaXBwbGUncyBpbXBlcmF0aXZlIGFwaSBsaWtlIGBzaW11bGF0ZWRSaXBwbGVgIHdpbGxcbiAgICAgICAgICogc3RpbGwgZ2VuZXJhdGUgdGhlIHJpcHBsZSBlZmZlY3QuXG4gICAgICAgICAqL1xuICAgICAgICBub2luazoge1xuICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgIH0sXG5cbiAgICAgICAgX2FuaW1hdGluZzoge1xuICAgICAgICAgIHR5cGU6IEJvb2xlYW5cbiAgICAgICAgfSxcblxuICAgICAgICBfYm91bmRBbmltYXRlOiB7XG4gICAgICAgICAgdHlwZTogRnVuY3Rpb24sXG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYW5pbWF0ZS5iaW5kKHRoaXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgZ2V0IHRhcmdldCAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmtleUV2ZW50VGFyZ2V0O1xuICAgICAgfSxcblxuICAgICAga2V5QmluZGluZ3M6IHtcbiAgICAgICAgJ2VudGVyOmtleWRvd24nOiAnX29uRW50ZXJLZXlkb3duJyxcbiAgICAgICAgJ3NwYWNlOmtleWRvd24nOiAnX29uU3BhY2VLZXlkb3duJyxcbiAgICAgICAgJ3NwYWNlOmtleXVwJzogJ19vblNwYWNlS2V5dXAnXG4gICAgICB9LFxuXG4gICAgICBhdHRhY2hlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIFNldCB1cCBhMTF5S2V5c0JlaGF2aW9yIHRvIGxpc3RlbiB0byBrZXkgZXZlbnRzIG9uIHRoZSB0YXJnZXQsXG4gICAgICAgIC8vIHNvIHRoYXQgc3BhY2UgYW5kIGVudGVyIGFjdGl2YXRlIHRoZSByaXBwbGUgZXZlbiBpZiB0aGUgdGFyZ2V0IGRvZXNuJ3RcbiAgICAgICAgLy8gaGFuZGxlIGtleSBldmVudHMuIFRoZSBrZXkgaGFuZGxlcnMgZGVhbCB3aXRoIGBub2lua2AgdGhlbXNlbHZlcy5cbiAgICAgICAgaWYgKHRoaXMucGFyZW50Tm9kZS5ub2RlVHlwZSA9PSAxMSkgeyAvLyBET0NVTUVOVF9GUkFHTUVOVF9OT0RFXG4gICAgICAgICAgdGhpcy5rZXlFdmVudFRhcmdldCA9IFBvbHltZXIuZG9tKHRoaXMpLmdldE93bmVyUm9vdCgpLmhvc3Q7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5rZXlFdmVudFRhcmdldCA9IHRoaXMucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIga2V5RXZlbnRUYXJnZXQgPSAvKiogQHR5cGUgeyFFdmVudFRhcmdldH0gKi8gKHRoaXMua2V5RXZlbnRUYXJnZXQpO1xuICAgICAgICB0aGlzLmxpc3RlbihrZXlFdmVudFRhcmdldCwgJ3VwJywgJ3VpVXBBY3Rpb24nKTtcbiAgICAgICAgdGhpcy5saXN0ZW4oa2V5RXZlbnRUYXJnZXQsICdkb3duJywgJ3VpRG93bkFjdGlvbicpO1xuICAgICAgfSxcblxuICAgICAgZGV0YWNoZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnVubGlzdGVuKHRoaXMua2V5RXZlbnRUYXJnZXQsICd1cCcsICd1aVVwQWN0aW9uJyk7XG4gICAgICAgIHRoaXMudW5saXN0ZW4odGhpcy5rZXlFdmVudFRhcmdldCwgJ2Rvd24nLCAndWlEb3duQWN0aW9uJyk7XG4gICAgICAgIHRoaXMua2V5RXZlbnRUYXJnZXQgPSBudWxsO1xuICAgICAgfSxcblxuICAgICAgZ2V0IHNob3VsZEtlZXBBbmltYXRpbmcgKCkge1xuICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5yaXBwbGVzLmxlbmd0aDsgKytpbmRleCkge1xuICAgICAgICAgIGlmICghdGhpcy5yaXBwbGVzW2luZGV4XS5pc0FuaW1hdGlvbkNvbXBsZXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9LFxuXG4gICAgICBzaW11bGF0ZWRSaXBwbGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmRvd25BY3Rpb24obnVsbCk7XG5cbiAgICAgICAgLy8gUGxlYXNlIHNlZSBwb2x5bWVyL3BvbHltZXIjMTMwNVxuICAgICAgICB0aGlzLmFzeW5jKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHRoaXMudXBBY3Rpb24oKTtcbiAgICAgICAgfSwgMSk7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFByb3Zva2VzIGEgcmlwcGxlIGRvd24gZWZmZWN0IHZpYSBhIFVJIGV2ZW50LFxuICAgICAgICogcmVzcGVjdGluZyB0aGUgYG5vaW5rYCBwcm9wZXJ0eS5cbiAgICAgICAqIEBwYXJhbSB7RXZlbnQ9fSBldmVudFxuICAgICAgICovXG4gICAgICB1aURvd25BY3Rpb246IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIGlmICghdGhpcy5ub2luaykge1xuICAgICAgICAgIHRoaXMuZG93bkFjdGlvbihldmVudCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogUHJvdm9rZXMgYSByaXBwbGUgZG93biBlZmZlY3QgdmlhIGEgVUkgZXZlbnQsXG4gICAgICAgKiAqbm90KiByZXNwZWN0aW5nIHRoZSBgbm9pbmtgIHByb3BlcnR5LlxuICAgICAgICogQHBhcmFtIHtFdmVudD19IGV2ZW50XG4gICAgICAgKi9cbiAgICAgIGRvd25BY3Rpb246IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmhvbGREb3duICYmIHRoaXMucmlwcGxlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJpcHBsZSA9IHRoaXMuYWRkUmlwcGxlKCk7XG5cbiAgICAgICAgcmlwcGxlLmRvd25BY3Rpb24oZXZlbnQpO1xuXG4gICAgICAgIGlmICghdGhpcy5fYW5pbWF0aW5nKSB7XG4gICAgICAgICAgdGhpcy5fYW5pbWF0aW5nID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLmFuaW1hdGUoKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBQcm92b2tlcyBhIHJpcHBsZSB1cCBlZmZlY3QgdmlhIGEgVUkgZXZlbnQsXG4gICAgICAgKiByZXNwZWN0aW5nIHRoZSBgbm9pbmtgIHByb3BlcnR5LlxuICAgICAgICogQHBhcmFtIHtFdmVudD19IGV2ZW50XG4gICAgICAgKi9cbiAgICAgIHVpVXBBY3Rpb246IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIGlmICghdGhpcy5ub2luaykge1xuICAgICAgICAgIHRoaXMudXBBY3Rpb24oZXZlbnQpO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFByb3Zva2VzIGEgcmlwcGxlIHVwIGVmZmVjdCB2aWEgYSBVSSBldmVudCxcbiAgICAgICAqICpub3QqIHJlc3BlY3RpbmcgdGhlIGBub2lua2AgcHJvcGVydHkuXG4gICAgICAgKiBAcGFyYW0ge0V2ZW50PX0gZXZlbnRcbiAgICAgICAqL1xuICAgICAgdXBBY3Rpb246IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmhvbGREb3duKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5yaXBwbGVzLmZvckVhY2goZnVuY3Rpb24ocmlwcGxlKSB7XG4gICAgICAgICAgcmlwcGxlLnVwQWN0aW9uKGV2ZW50KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5fYW5pbWF0aW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5hbmltYXRlKCk7XG4gICAgICB9LFxuXG4gICAgICBvbkFuaW1hdGlvbkNvbXBsZXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fYW5pbWF0aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuJC5iYWNrZ3JvdW5kLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IG51bGw7XG4gICAgICAgIHRoaXMuZmlyZSgndHJhbnNpdGlvbmVuZCcpO1xuICAgICAgfSxcblxuICAgICAgYWRkUmlwcGxlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJpcHBsZSA9IG5ldyBSaXBwbGUodGhpcyk7XG5cbiAgICAgICAgUG9seW1lci5kb20odGhpcy4kLndhdmVzKS5hcHBlbmRDaGlsZChyaXBwbGUud2F2ZUNvbnRhaW5lcik7XG4gICAgICAgIHRoaXMuJC5iYWNrZ3JvdW5kLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IHJpcHBsZS5jb2xvcjtcbiAgICAgICAgdGhpcy5yaXBwbGVzLnB1c2gocmlwcGxlKTtcblxuICAgICAgICB0aGlzLl9zZXRBbmltYXRpbmcodHJ1ZSk7XG5cbiAgICAgICAgcmV0dXJuIHJpcHBsZTtcbiAgICAgIH0sXG5cbiAgICAgIHJlbW92ZVJpcHBsZTogZnVuY3Rpb24ocmlwcGxlKSB7XG4gICAgICAgIHZhciByaXBwbGVJbmRleCA9IHRoaXMucmlwcGxlcy5pbmRleE9mKHJpcHBsZSk7XG5cbiAgICAgICAgaWYgKHJpcHBsZUluZGV4IDwgMCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucmlwcGxlcy5zcGxpY2UocmlwcGxlSW5kZXgsIDEpO1xuXG4gICAgICAgIHJpcHBsZS5yZW1vdmUoKTtcblxuICAgICAgICBpZiAoIXRoaXMucmlwcGxlcy5sZW5ndGgpIHtcbiAgICAgICAgICB0aGlzLl9zZXRBbmltYXRpbmcoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFRoaXMgY29uZmxpY3RzIHdpdGggRWxlbWVudCNhbnRpbWF0ZSgpLlxuICAgICAgICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0VsZW1lbnQvYW5pbWF0ZVxuICAgICAgICogQHN1cHByZXNzIHtjaGVja1R5cGVzfVxuICAgICAgICovXG4gICAgICBhbmltYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9hbmltYXRpbmcpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGluZGV4O1xuICAgICAgICB2YXIgcmlwcGxlO1xuXG4gICAgICAgIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IHRoaXMucmlwcGxlcy5sZW5ndGg7ICsraW5kZXgpIHtcbiAgICAgICAgICByaXBwbGUgPSB0aGlzLnJpcHBsZXNbaW5kZXhdO1xuXG4gICAgICAgICAgcmlwcGxlLmRyYXcoKTtcblxuICAgICAgICAgIHRoaXMuJC5iYWNrZ3JvdW5kLnN0eWxlLm9wYWNpdHkgPSByaXBwbGUub3V0ZXJPcGFjaXR5O1xuXG4gICAgICAgICAgaWYgKHJpcHBsZS5pc09wYWNpdHlGdWxseURlY2F5ZWQgJiYgIXJpcHBsZS5pc1Jlc3RpbmdBdE1heFJhZGl1cykge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVSaXBwbGUocmlwcGxlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuc2hvdWxkS2VlcEFuaW1hdGluZyAmJiB0aGlzLnJpcHBsZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5vbkFuaW1hdGlvbkNvbXBsZXRlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLl9ib3VuZEFuaW1hdGUpO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBfb25FbnRlcktleWRvd246IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnVpRG93bkFjdGlvbigpO1xuICAgICAgICB0aGlzLmFzeW5jKHRoaXMudWlVcEFjdGlvbiwgMSk7XG4gICAgICB9LFxuXG4gICAgICBfb25TcGFjZUtleWRvd246IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnVpRG93bkFjdGlvbigpO1xuICAgICAgfSxcblxuICAgICAgX29uU3BhY2VLZXl1cDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMudWlVcEFjdGlvbigpO1xuICAgICAgfSxcblxuICAgICAgLy8gbm90ZTogaG9sZERvd24gZG9lcyBub3QgcmVzcGVjdCBub2luayBzaW5jZSBpdCBjYW4gYmUgYSBmb2N1cyBiYXNlZFxuICAgICAgLy8gZWZmZWN0LlxuICAgICAgX2hvbGREb3duQ2hhbmdlZDogZnVuY3Rpb24obmV3VmFsLCBvbGRWYWwpIHtcbiAgICAgICAgaWYgKG9sZFZhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXdWYWwpIHtcbiAgICAgICAgICB0aGlzLmRvd25BY3Rpb24oKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnVwQWN0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICBGaXJlZCB3aGVuIHRoZSBhbmltYXRpb24gZmluaXNoZXMuXG4gICAgICBUaGlzIGlzIHVzZWZ1bCBpZiB5b3Ugd2FudCB0byB3YWl0IHVudGlsXG4gICAgICB0aGUgcmlwcGxlIGFuaW1hdGlvbiBmaW5pc2hlcyB0byBwZXJmb3JtIHNvbWUgYWN0aW9uLlxuXG4gICAgICBAZXZlbnQgdHJhbnNpdGlvbmVuZFxuICAgICAgQHBhcmFtIHt7bm9kZTogT2JqZWN0fX0gZGV0YWlsIENvbnRhaW5zIHRoZSBhbmltYXRlZCBub2RlLlxuICAgICAgKi9cbiAgICB9KTtcbiAgfSkoKTtcbjwvc2NyaXB0PlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9wYXBlci1yaXBwbGUvcGFwZXItcmlwcGxlLmh0bWwiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi9wb2x5bWVyL3BvbHltZXIuaHRtbFwiPlxuXG48c2NyaXB0PlxuXG4gIC8qKlxuICAgKiBgUG9seW1lci5Jcm9uU2Nyb2xsVGFyZ2V0QmVoYXZpb3JgIGFsbG93cyBhbiBlbGVtZW50IHRvIHJlc3BvbmQgdG8gc2Nyb2xsIGV2ZW50cyBmcm9tIGFcbiAgICogZGVzaWduYXRlZCBzY3JvbGwgdGFyZ2V0LlxuICAgKlxuICAgKiBFbGVtZW50cyB0aGF0IGNvbnN1bWUgdGhpcyBiZWhhdmlvciBjYW4gb3ZlcnJpZGUgdGhlIGBfc2Nyb2xsSGFuZGxlcmBcbiAgICogbWV0aG9kIHRvIGFkZCBsb2dpYyBvbiB0aGUgc2Nyb2xsIGV2ZW50LlxuICAgKlxuICAgKiBAZGVtbyBkZW1vL3Njcm9sbGluZy1yZWdpb24uaHRtbCBTY3JvbGxpbmcgUmVnaW9uXG4gICAqIEBkZW1vIGRlbW8vZG9jdW1lbnQuaHRtbCBEb2N1bWVudCBFbGVtZW50XG4gICAqIEBwb2x5bWVyQmVoYXZpb3JcbiAgICovXG4gIFBvbHltZXIuSXJvblNjcm9sbFRhcmdldEJlaGF2aW9yID0ge1xuXG4gICAgcHJvcGVydGllczoge1xuXG4gICAgICAvKipcbiAgICAgICAqIFNwZWNpZmllcyB0aGUgZWxlbWVudCB0aGF0IHdpbGwgaGFuZGxlIHRoZSBzY3JvbGwgZXZlbnRcbiAgICAgICAqIG9uIHRoZSBiZWhhbGYgb2YgdGhlIGN1cnJlbnQgZWxlbWVudC4gVGhpcyBpcyB0eXBpY2FsbHkgYSByZWZlcmVuY2UgdG8gYW4gZWxlbWVudCxcbiAgICAgICAqIGJ1dCB0aGVyZSBhcmUgYSBmZXcgbW9yZSBwb3NpYmlsaXRpZXM6XG4gICAgICAgKlxuICAgICAgICogIyMjIEVsZW1lbnRzIGlkXG4gICAgICAgKlxuICAgICAgICpgYGBodG1sXG4gICAgICAgKiA8ZGl2IGlkPVwic2Nyb2xsYWJsZS1lbGVtZW50XCIgc3R5bGU9XCJvdmVyZmxvdzogYXV0bztcIj5cbiAgICAgICAqICA8eC1lbGVtZW50IHNjcm9sbC10YXJnZXQ9XCJzY3JvbGxhYmxlLWVsZW1lbnRcIj5cbiAgICAgICAqICAgIDwhLS0gQ29udGVudC0tPlxuICAgICAgICogIDwveC1lbGVtZW50PlxuICAgICAgICogPC9kaXY+XG4gICAgICAgKmBgYFxuICAgICAgICogSW4gdGhpcyBjYXNlLCB0aGUgYHNjcm9sbFRhcmdldGAgd2lsbCBwb2ludCB0byB0aGUgb3V0ZXIgZGl2IGVsZW1lbnQuXG4gICAgICAgKlxuICAgICAgICogIyMjIERvY3VtZW50IHNjcm9sbGluZ1xuICAgICAgICpcbiAgICAgICAqIEZvciBkb2N1bWVudCBzY3JvbGxpbmcsIHlvdSBjYW4gdXNlIHRoZSByZXNlcnZlZCB3b3JkIGBkb2N1bWVudGA6XG4gICAgICAgKlxuICAgICAgICpgYGBodG1sXG4gICAgICAgKiA8eC1lbGVtZW50IHNjcm9sbC10YXJnZXQ9XCJkb2N1bWVudFwiPlxuICAgICAgICogICA8IS0tIENvbnRlbnQgLS0+XG4gICAgICAgKiA8L3gtZWxlbWVudD5cbiAgICAgICAqYGBgXG4gICAgICAgKlxuICAgICAgICogIyMjIEVsZW1lbnRzIHJlZmVyZW5jZVxuICAgICAgICpcbiAgICAgICAqYGBganNcbiAgICAgICAqIGFwcEhlYWRlci5zY3JvbGxUYXJnZXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjc2Nyb2xsYWJsZS1lbGVtZW50Jyk7XG4gICAgICAgKmBgYFxuICAgICAgICpcbiAgICAgICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICAgICAqIEBkZWZhdWx0IGRvY3VtZW50XG4gICAgICAgKi9cbiAgICAgIHNjcm9sbFRhcmdldDoge1xuICAgICAgICB0eXBlOiBIVE1MRWxlbWVudCxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9kZWZhdWx0U2Nyb2xsVGFyZ2V0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIG9ic2VydmVyczogW1xuICAgICAgJ19zY3JvbGxUYXJnZXRDaGFuZ2VkKHNjcm9sbFRhcmdldCwgaXNBdHRhY2hlZCknXG4gICAgXSxcblxuICAgIC8qKlxuICAgICAqIFRydWUgaWYgdGhlIGV2ZW50IGxpc3RlbmVyIHNob3VsZCBiZSBpbnN0YWxsZWQuXG4gICAgICovXG4gICAgX3Nob3VsZEhhdmVMaXN0ZW5lcjogdHJ1ZSxcblxuICAgIF9zY3JvbGxUYXJnZXRDaGFuZ2VkOiBmdW5jdGlvbihzY3JvbGxUYXJnZXQsIGlzQXR0YWNoZWQpIHtcbiAgICAgIHZhciBldmVudFRhcmdldDtcblxuICAgICAgaWYgKHRoaXMuX29sZFNjcm9sbFRhcmdldCkge1xuICAgICAgICB0aGlzLl90b2dnbGVTY3JvbGxMaXN0ZW5lcihmYWxzZSwgdGhpcy5fb2xkU2Nyb2xsVGFyZ2V0KTtcbiAgICAgICAgdGhpcy5fb2xkU2Nyb2xsVGFyZ2V0ID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmICghaXNBdHRhY2hlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBTdXBwb3J0IGVsZW1lbnQgaWQgcmVmZXJlbmNlc1xuICAgICAgaWYgKHNjcm9sbFRhcmdldCA9PT0gJ2RvY3VtZW50Jykge1xuXG4gICAgICAgIHRoaXMuc2Nyb2xsVGFyZ2V0ID0gdGhpcy5fZG9jO1xuXG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBzY3JvbGxUYXJnZXQgPT09ICdzdHJpbmcnKSB7XG5cbiAgICAgICAgdmFyIGRvbUhvc3QgPSB0aGlzLmRvbUhvc3Q7XG5cbiAgICAgICAgdGhpcy5zY3JvbGxUYXJnZXQgPSBkb21Ib3N0ICYmIGRvbUhvc3QuJCA/IGRvbUhvc3QuJFtzY3JvbGxUYXJnZXRdIDpcbiAgICAgICAgICAgIFBvbHltZXIuZG9tKHRoaXMub3duZXJEb2N1bWVudCkucXVlcnlTZWxlY3RvcignIycgKyBzY3JvbGxUYXJnZXQpO1xuXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX2lzVmFsaWRTY3JvbGxUYXJnZXQoKSkge1xuXG4gICAgICAgIHRoaXMuX29sZFNjcm9sbFRhcmdldCA9IHNjcm9sbFRhcmdldDtcbiAgICAgICAgdGhpcy5fdG9nZ2xlU2Nyb2xsTGlzdGVuZXIodGhpcy5fc2hvdWxkSGF2ZUxpc3RlbmVyLCBzY3JvbGxUYXJnZXQpO1xuXG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJ1bnMgb24gZXZlcnkgc2Nyb2xsIGV2ZW50LiBDb25zdW1lciBvZiB0aGlzIGJlaGF2aW9yIG1heSBvdmVycmlkZSB0aGlzIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfc2Nyb2xsSGFuZGxlcjogZnVuY3Rpb24gc2Nyb2xsSGFuZGxlcigpIHt9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIGRlZmF1bHQgc2Nyb2xsIHRhcmdldC4gQ29uc3VtZXJzIG9mIHRoaXMgYmVoYXZpb3IgbWF5IHdhbnQgdG8gY3VzdG9taXplXG4gICAgICogdGhlIGRlZmF1bHQgc2Nyb2xsIHRhcmdldC5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtFbGVtZW50fVxuICAgICAqL1xuICAgIGdldCBfZGVmYXVsdFNjcm9sbFRhcmdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9kb2M7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNob3J0Y3V0IGZvciB0aGUgZG9jdW1lbnQgZWxlbWVudFxuICAgICAqXG4gICAgICogQHR5cGUge0VsZW1lbnR9XG4gICAgICovXG4gICAgZ2V0IF9kb2MoKSB7XG4gICAgICByZXR1cm4gdGhpcy5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbnVtYmVyIG9mIHBpeGVscyB0aGF0IHRoZSBjb250ZW50IG9mIGFuIGVsZW1lbnQgaXMgc2Nyb2xsZWQgdXB3YXJkLlxuICAgICAqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgX3Njcm9sbFRvcCgpIHtcbiAgICAgIGlmICh0aGlzLl9pc1ZhbGlkU2Nyb2xsVGFyZ2V0KCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2Nyb2xsVGFyZ2V0ID09PSB0aGlzLl9kb2MgPyB3aW5kb3cucGFnZVlPZmZzZXQgOiB0aGlzLnNjcm9sbFRhcmdldC5zY3JvbGxUb3A7XG4gICAgICB9XG4gICAgICByZXR1cm4gMDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbnVtYmVyIG9mIHBpeGVscyB0aGF0IHRoZSBjb250ZW50IG9mIGFuIGVsZW1lbnQgaXMgc2Nyb2xsZWQgdG8gdGhlIGxlZnQuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldCBfc2Nyb2xsTGVmdCgpIHtcbiAgICAgIGlmICh0aGlzLl9pc1ZhbGlkU2Nyb2xsVGFyZ2V0KCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2Nyb2xsVGFyZ2V0ID09PSB0aGlzLl9kb2MgPyB3aW5kb3cucGFnZVhPZmZzZXQgOiB0aGlzLnNjcm9sbFRhcmdldC5zY3JvbGxMZWZ0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIDA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIG51bWJlciBvZiBwaXhlbHMgdGhhdCB0aGUgY29udGVudCBvZiBhbiBlbGVtZW50IGlzIHNjcm9sbGVkIHVwd2FyZC5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgc2V0IF9zY3JvbGxUb3AodG9wKSB7XG4gICAgICBpZiAodGhpcy5zY3JvbGxUYXJnZXQgPT09IHRoaXMuX2RvYykge1xuICAgICAgICB3aW5kb3cuc2Nyb2xsVG8od2luZG93LnBhZ2VYT2Zmc2V0LCB0b3ApO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl9pc1ZhbGlkU2Nyb2xsVGFyZ2V0KCkpIHtcbiAgICAgICAgdGhpcy5zY3JvbGxUYXJnZXQuc2Nyb2xsVG9wID0gdG9wO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBudW1iZXIgb2YgcGl4ZWxzIHRoYXQgdGhlIGNvbnRlbnQgb2YgYW4gZWxlbWVudCBpcyBzY3JvbGxlZCB0byB0aGUgbGVmdC5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgc2V0IF9zY3JvbGxMZWZ0KGxlZnQpIHtcbiAgICAgIGlmICh0aGlzLnNjcm9sbFRhcmdldCA9PT0gdGhpcy5fZG9jKSB7XG4gICAgICAgIHdpbmRvdy5zY3JvbGxUbyhsZWZ0LCB3aW5kb3cucGFnZVlPZmZzZXQpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl9pc1ZhbGlkU2Nyb2xsVGFyZ2V0KCkpIHtcbiAgICAgICAgdGhpcy5zY3JvbGxUYXJnZXQuc2Nyb2xsTGVmdCA9IGxlZnQ7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNjcm9sbHMgdGhlIGNvbnRlbnQgdG8gYSBwYXJ0aWN1bGFyIHBsYWNlLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBzY3JvbGxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGVmdCBUaGUgbGVmdCBwb3NpdGlvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0b3AgVGhlIHRvcCBwb3NpdGlvblxuICAgICAqL1xuICAgIHNjcm9sbDogZnVuY3Rpb24obGVmdCwgdG9wKSB7XG4gICAgICAgaWYgKHRoaXMuc2Nyb2xsVGFyZ2V0ID09PSB0aGlzLl9kb2MpIHtcbiAgICAgICAgd2luZG93LnNjcm9sbFRvKGxlZnQsIHRvcCk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX2lzVmFsaWRTY3JvbGxUYXJnZXQoKSkge1xuICAgICAgICB0aGlzLnNjcm9sbFRhcmdldC5zY3JvbGxMZWZ0ID0gbGVmdDtcbiAgICAgICAgdGhpcy5zY3JvbGxUYXJnZXQuc2Nyb2xsVG9wID0gdG9wO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSB3aWR0aCBvZiB0aGUgc2Nyb2xsIHRhcmdldC5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IF9zY3JvbGxUYXJnZXRXaWR0aCgpIHtcbiAgICAgIGlmICh0aGlzLl9pc1ZhbGlkU2Nyb2xsVGFyZ2V0KCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2Nyb2xsVGFyZ2V0ID09PSB0aGlzLl9kb2MgPyB3aW5kb3cuaW5uZXJXaWR0aCA6IHRoaXMuc2Nyb2xsVGFyZ2V0Lm9mZnNldFdpZHRoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIDA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGhlaWdodCBvZiB0aGUgc2Nyb2xsIHRhcmdldC5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IF9zY3JvbGxUYXJnZXRIZWlnaHQoKSB7XG4gICAgICBpZiAodGhpcy5faXNWYWxpZFNjcm9sbFRhcmdldCgpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjcm9sbFRhcmdldCA9PT0gdGhpcy5fZG9jID8gd2luZG93LmlubmVySGVpZ2h0IDogdGhpcy5zY3JvbGxUYXJnZXQub2Zmc2V0SGVpZ2h0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIDA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgc2Nyb2xsIHRhcmdldCBpcyBhIHZhbGlkIEhUTUxFbGVtZW50LlxuICAgICAqXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBfaXNWYWxpZFNjcm9sbFRhcmdldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5zY3JvbGxUYXJnZXQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudDtcbiAgICB9LFxuXG4gICAgX3RvZ2dsZVNjcm9sbExpc3RlbmVyOiBmdW5jdGlvbih5ZXMsIHNjcm9sbFRhcmdldCkge1xuICAgICAgdmFyIGV2ZW50VGFyZ2V0ID0gc2Nyb2xsVGFyZ2V0ID09PSB0aGlzLl9kb2MgPyB3aW5kb3cgOiBzY3JvbGxUYXJnZXQ7XG4gICAgICBpZiAoeWVzKSB7XG4gICAgICAgIGlmICghdGhpcy5fYm91bmRTY3JvbGxIYW5kbGVyKSB7XG4gICAgICAgICAgdGhpcy5fYm91bmRTY3JvbGxIYW5kbGVyID0gdGhpcy5fc2Nyb2xsSGFuZGxlci5iaW5kKHRoaXMpO1xuICAgICAgICAgIGV2ZW50VGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMuX2JvdW5kU2Nyb2xsSGFuZGxlcik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLl9ib3VuZFNjcm9sbEhhbmRsZXIpIHtcbiAgICAgICAgICBldmVudFRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLl9ib3VuZFNjcm9sbEhhbmRsZXIpO1xuICAgICAgICAgIHRoaXMuX2JvdW5kU2Nyb2xsSGFuZGxlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgc2Nyb2xsIGV2ZW50IGxpc3RlbmVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtib29sZWFufSB5ZXMgVHJ1ZSB0byBhZGQgdGhlIGV2ZW50LCBGYWxzZSB0byByZW1vdmUgaXQuXG4gICAgICovXG4gICAgdG9nZ2xlU2Nyb2xsTGlzdGVuZXI6IGZ1bmN0aW9uKHllcykge1xuICAgICAgdGhpcy5fc2hvdWxkSGF2ZUxpc3RlbmVyID0geWVzO1xuICAgICAgdGhpcy5fdG9nZ2xlU2Nyb2xsTGlzdGVuZXIoeWVzLCB0aGlzLnNjcm9sbFRhcmdldCk7XG4gICAgfVxuXG4gIH07XG5cbjwvc2NyaXB0PlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9pcm9uLXNjcm9sbC10YXJnZXQtYmVoYXZpb3IvaXJvbi1zY3JvbGwtdGFyZ2V0LWJlaGF2aW9yLmh0bWwiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE1IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi9wb2x5bWVyL3BvbHltZXIuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL2lyb24tYTExeS1rZXlzLWJlaGF2aW9yL2lyb24tYTExeS1rZXlzLWJlaGF2aW9yLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCJpcm9uLWNvbnRyb2wtc3RhdGUuaHRtbFwiPlxuXG48c2NyaXB0PlxuXG4gIC8qKlxuICAgKiBAZGVtbyBkZW1vL2luZGV4Lmh0bWxcbiAgICogQHBvbHltZXJCZWhhdmlvciBQb2x5bWVyLklyb25CdXR0b25TdGF0ZVxuICAgKi9cbiAgUG9seW1lci5Jcm9uQnV0dG9uU3RhdGVJbXBsID0ge1xuXG4gICAgcHJvcGVydGllczoge1xuXG4gICAgICAvKipcbiAgICAgICAqIElmIHRydWUsIHRoZSB1c2VyIGlzIGN1cnJlbnRseSBob2xkaW5nIGRvd24gdGhlIGJ1dHRvbi5cbiAgICAgICAqL1xuICAgICAgcHJlc3NlZDoge1xuICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICByZWFkT25seTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGZhbHNlLFxuICAgICAgICByZWZsZWN0VG9BdHRyaWJ1dGU6IHRydWUsXG4gICAgICAgIG9ic2VydmVyOiAnX3ByZXNzZWRDaGFuZ2VkJ1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBJZiB0cnVlLCB0aGUgYnV0dG9uIHRvZ2dsZXMgdGhlIGFjdGl2ZSBzdGF0ZSB3aXRoIGVhY2ggdGFwIG9yIHByZXNzXG4gICAgICAgKiBvZiB0aGUgc3BhY2ViYXIuXG4gICAgICAgKi9cbiAgICAgIHRvZ2dsZXM6IHtcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgdmFsdWU6IGZhbHNlLFxuICAgICAgICByZWZsZWN0VG9BdHRyaWJ1dGU6IHRydWVcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogSWYgdHJ1ZSwgdGhlIGJ1dHRvbiBpcyBhIHRvZ2dsZSBhbmQgaXMgY3VycmVudGx5IGluIHRoZSBhY3RpdmUgc3RhdGUuXG4gICAgICAgKi9cbiAgICAgIGFjdGl2ZToge1xuICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICB2YWx1ZTogZmFsc2UsXG4gICAgICAgIG5vdGlmeTogdHJ1ZSxcbiAgICAgICAgcmVmbGVjdFRvQXR0cmlidXRlOiB0cnVlXG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFRydWUgaWYgdGhlIGVsZW1lbnQgaXMgY3VycmVudGx5IGJlaW5nIHByZXNzZWQgYnkgYSBcInBvaW50ZXIsXCIgd2hpY2hcbiAgICAgICAqIGlzIGxvb3NlbHkgZGVmaW5lZCBhcyBtb3VzZSBvciB0b3VjaCBpbnB1dCAoYnV0IHNwZWNpZmljYWxseSBleGNsdWRpbmdcbiAgICAgICAqIGtleWJvYXJkIGlucHV0KS5cbiAgICAgICAqL1xuICAgICAgcG9pbnRlckRvd246IHtcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgcmVhZE9ubHk6IHRydWUsXG4gICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBUcnVlIGlmIHRoZSBpbnB1dCBkZXZpY2UgdGhhdCBjYXVzZWQgdGhlIGVsZW1lbnQgdG8gcmVjZWl2ZSBmb2N1c1xuICAgICAgICogd2FzIGEga2V5Ym9hcmQuXG4gICAgICAgKi9cbiAgICAgIHJlY2VpdmVkRm9jdXNGcm9tS2V5Ym9hcmQ6IHtcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgcmVhZE9ubHk6IHRydWVcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogVGhlIGFyaWEgYXR0cmlidXRlIHRvIGJlIHNldCBpZiB0aGUgYnV0dG9uIGlzIGEgdG9nZ2xlIGFuZCBpbiB0aGVcbiAgICAgICAqIGFjdGl2ZSBzdGF0ZS5cbiAgICAgICAqL1xuICAgICAgYXJpYUFjdGl2ZUF0dHJpYnV0ZToge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIHZhbHVlOiAnYXJpYS1wcmVzc2VkJyxcbiAgICAgICAgb2JzZXJ2ZXI6ICdfYXJpYUFjdGl2ZUF0dHJpYnV0ZUNoYW5nZWQnXG4gICAgICB9XG4gICAgfSxcblxuICAgIGxpc3RlbmVyczoge1xuICAgICAgZG93bjogJ19kb3duSGFuZGxlcicsXG4gICAgICB1cDogJ191cEhhbmRsZXInLFxuICAgICAgdGFwOiAnX3RhcEhhbmRsZXInXG4gICAgfSxcblxuICAgIG9ic2VydmVyczogW1xuICAgICAgJ19mb2N1c0NoYW5nZWQoZm9jdXNlZCknLFxuICAgICAgJ19hY3RpdmVDaGFuZ2VkKGFjdGl2ZSwgYXJpYUFjdGl2ZUF0dHJpYnV0ZSknXG4gICAgXSxcblxuICAgIGtleUJpbmRpbmdzOiB7XG4gICAgICAnZW50ZXI6a2V5ZG93bic6ICdfYXN5bmNDbGljaycsXG4gICAgICAnc3BhY2U6a2V5ZG93bic6ICdfc3BhY2VLZXlEb3duSGFuZGxlcicsXG4gICAgICAnc3BhY2U6a2V5dXAnOiAnX3NwYWNlS2V5VXBIYW5kbGVyJyxcbiAgICB9LFxuXG4gICAgX21vdXNlRXZlbnRSZTogL15tb3VzZS8sXG5cbiAgICBfdGFwSGFuZGxlcjogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy50b2dnbGVzKSB7XG4gICAgICAgLy8gYSB0YXAgaXMgbmVlZGVkIHRvIHRvZ2dsZSB0aGUgYWN0aXZlIHN0YXRlXG4gICAgICAgIHRoaXMuX3VzZXJBY3RpdmF0ZSghdGhpcy5hY3RpdmUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgX2ZvY3VzQ2hhbmdlZDogZnVuY3Rpb24oZm9jdXNlZCkge1xuICAgICAgdGhpcy5fZGV0ZWN0S2V5Ym9hcmRGb2N1cyhmb2N1c2VkKTtcblxuICAgICAgaWYgKCFmb2N1c2VkKSB7XG4gICAgICAgIHRoaXMuX3NldFByZXNzZWQoZmFsc2UpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBfZGV0ZWN0S2V5Ym9hcmRGb2N1czogZnVuY3Rpb24oZm9jdXNlZCkge1xuICAgICAgdGhpcy5fc2V0UmVjZWl2ZWRGb2N1c0Zyb21LZXlib2FyZCghdGhpcy5wb2ludGVyRG93biAmJiBmb2N1c2VkKTtcbiAgICB9LFxuXG4gICAgLy8gdG8gZW11bGF0ZSBuYXRpdmUgY2hlY2tib3gsIChkZS0pYWN0aXZhdGlvbnMgZnJvbSBhIHVzZXIgaW50ZXJhY3Rpb24gZmlyZVxuICAgIC8vICdjaGFuZ2UnIGV2ZW50c1xuICAgIF91c2VyQWN0aXZhdGU6IGZ1bmN0aW9uKGFjdGl2ZSkge1xuICAgICAgaWYgKHRoaXMuYWN0aXZlICE9PSBhY3RpdmUpIHtcbiAgICAgICAgdGhpcy5hY3RpdmUgPSBhY3RpdmU7XG4gICAgICAgIHRoaXMuZmlyZSgnY2hhbmdlJyk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIF9kb3duSGFuZGxlcjogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIHRoaXMuX3NldFBvaW50ZXJEb3duKHRydWUpO1xuICAgICAgdGhpcy5fc2V0UHJlc3NlZCh0cnVlKTtcbiAgICAgIHRoaXMuX3NldFJlY2VpdmVkRm9jdXNGcm9tS2V5Ym9hcmQoZmFsc2UpO1xuICAgIH0sXG5cbiAgICBfdXBIYW5kbGVyOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX3NldFBvaW50ZXJEb3duKGZhbHNlKTtcbiAgICAgIHRoaXMuX3NldFByZXNzZWQoZmFsc2UpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyFLZXlib2FyZEV2ZW50fSBldmVudCAuXG4gICAgICovXG4gICAgX3NwYWNlS2V5RG93bkhhbmRsZXI6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICB2YXIga2V5Ym9hcmRFdmVudCA9IGV2ZW50LmRldGFpbC5rZXlib2FyZEV2ZW50O1xuICAgICAgdmFyIHRhcmdldCA9IFBvbHltZXIuZG9tKGtleWJvYXJkRXZlbnQpLmxvY2FsVGFyZ2V0O1xuXG4gICAgICAvLyBJZ25vcmUgdGhlIGV2ZW50IGlmIHRoaXMgaXMgY29taW5nIGZyb20gYSBmb2N1c2VkIGxpZ2h0IGNoaWxkLCBzaW5jZSB0aGF0XG4gICAgICAvLyBlbGVtZW50IHdpbGwgZGVhbCB3aXRoIGl0LlxuICAgICAgaWYgKHRoaXMuaXNMaWdodERlc2NlbmRhbnQoLyoqIEB0eXBlIHtOb2RlfSAqLyh0YXJnZXQpKSlcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICBrZXlib2FyZEV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBrZXlib2FyZEV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgdGhpcy5fc2V0UHJlc3NlZCh0cnVlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshS2V5Ym9hcmRFdmVudH0gZXZlbnQgLlxuICAgICAqL1xuICAgIF9zcGFjZUtleVVwSGFuZGxlcjogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIHZhciBrZXlib2FyZEV2ZW50ID0gZXZlbnQuZGV0YWlsLmtleWJvYXJkRXZlbnQ7XG4gICAgICB2YXIgdGFyZ2V0ID0gUG9seW1lci5kb20oa2V5Ym9hcmRFdmVudCkubG9jYWxUYXJnZXQ7XG5cbiAgICAgIC8vIElnbm9yZSB0aGUgZXZlbnQgaWYgdGhpcyBpcyBjb21pbmcgZnJvbSBhIGZvY3VzZWQgbGlnaHQgY2hpbGQsIHNpbmNlIHRoYXRcbiAgICAgIC8vIGVsZW1lbnQgd2lsbCBkZWFsIHdpdGggaXQuXG4gICAgICBpZiAodGhpcy5pc0xpZ2h0RGVzY2VuZGFudCgvKiogQHR5cGUge05vZGV9ICovKHRhcmdldCkpKVxuICAgICAgICByZXR1cm47XG5cbiAgICAgIGlmICh0aGlzLnByZXNzZWQpIHtcbiAgICAgICAgdGhpcy5fYXN5bmNDbGljaygpO1xuICAgICAgfVxuICAgICAgdGhpcy5fc2V0UHJlc3NlZChmYWxzZSk7XG4gICAgfSxcblxuICAgIC8vIHRyaWdnZXIgY2xpY2sgYXN5bmNocm9ub3VzbHksIHRoZSBhc3luY2hyb255IGlzIHVzZWZ1bCB0byBhbGxvdyBvbmVcbiAgICAvLyBldmVudCBoYW5kbGVyIHRvIHVud2luZCBiZWZvcmUgdHJpZ2dlcmluZyBhbm90aGVyIGV2ZW50XG4gICAgX2FzeW5jQ2xpY2s6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5hc3luYyhmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5jbGljaygpO1xuICAgICAgfSwgMSk7XG4gICAgfSxcblxuICAgIC8vIGFueSBvZiB0aGVzZSBjaGFuZ2VzIGFyZSBjb25zaWRlcmVkIGEgY2hhbmdlIHRvIGJ1dHRvbiBzdGF0ZVxuXG4gICAgX3ByZXNzZWRDaGFuZ2VkOiBmdW5jdGlvbihwcmVzc2VkKSB7XG4gICAgICB0aGlzLl9jaGFuZ2VkQnV0dG9uU3RhdGUoKTtcbiAgICB9LFxuXG4gICAgX2FyaWFBY3RpdmVBdHRyaWJ1dGVDaGFuZ2VkOiBmdW5jdGlvbih2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgIGlmIChvbGRWYWx1ZSAmJiBvbGRWYWx1ZSAhPSB2YWx1ZSAmJiB0aGlzLmhhc0F0dHJpYnV0ZShvbGRWYWx1ZSkpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGUob2xkVmFsdWUpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBfYWN0aXZlQ2hhbmdlZDogZnVuY3Rpb24oYWN0aXZlLCBhcmlhQWN0aXZlQXR0cmlidXRlKSB7XG4gICAgICBpZiAodGhpcy50b2dnbGVzKSB7XG4gICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKHRoaXMuYXJpYUFjdGl2ZUF0dHJpYnV0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlID8gJ3RydWUnIDogJ2ZhbHNlJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZSh0aGlzLmFyaWFBY3RpdmVBdHRyaWJ1dGUpO1xuICAgICAgfVxuICAgICAgdGhpcy5fY2hhbmdlZEJ1dHRvblN0YXRlKCk7XG4gICAgfSxcblxuICAgIF9jb250cm9sU3RhdGVDaGFuZ2VkOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmRpc2FibGVkKSB7XG4gICAgICAgIHRoaXMuX3NldFByZXNzZWQoZmFsc2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fY2hhbmdlZEJ1dHRvblN0YXRlKCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8vIHByb3ZpZGUgaG9vayBmb3IgZm9sbG93LW9uIGJlaGF2aW9ycyB0byByZWFjdCB0byBidXR0b24tc3RhdGVcblxuICAgIF9jaGFuZ2VkQnV0dG9uU3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuX2J1dHRvblN0YXRlQ2hhbmdlZCkge1xuICAgICAgICB0aGlzLl9idXR0b25TdGF0ZUNoYW5nZWQoKTsgLy8gYWJzdHJhY3RcbiAgICAgIH1cbiAgICB9XG5cbiAgfTtcblxuICAvKiogQHBvbHltZXJCZWhhdmlvciAqL1xuICBQb2x5bWVyLklyb25CdXR0b25TdGF0ZSA9IFtcbiAgICBQb2x5bWVyLklyb25BMTF5S2V5c0JlaGF2aW9yLFxuICAgIFBvbHltZXIuSXJvbkJ1dHRvblN0YXRlSW1wbFxuICBdO1xuXG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvaXJvbi1iZWhhdmlvcnMvaXJvbi1idXR0b24tc3RhdGUuaHRtbCIsIlxucmVxdWlyZSgnLi4vcG9seW1lci9wb2x5bWVyLmh0bWwnKTtcblxuY29uc3QgUmVnaXN0ZXJIdG1sVGVtcGxhdGUgPSByZXF1aXJlKCdwb2x5bWVyLXdlYnBhY2stbG9hZGVyL3JlZ2lzdGVyLWh0bWwtdGVtcGxhdGUnKTtcblxuUmVnaXN0ZXJIdG1sVGVtcGxhdGUudG9Cb2R5KFwiPGN1c3RvbS1zdHlsZT4gPHN0eWxlIGlzPWN1c3RvbS1zdHlsZT5odG1sey0tZ29vZ2xlLXJlZC0xMDA6I2Y0YzdjMzstLWdvb2dsZS1yZWQtMzAwOiNlNjdjNzM7LS1nb29nbGUtcmVkLTUwMDojZGI0NDM3Oy0tZ29vZ2xlLXJlZC03MDA6I2M1MzkyOTstLWdvb2dsZS1ibHVlLTEwMDojYzZkYWZjOy0tZ29vZ2xlLWJsdWUtMzAwOiM3YmFhZjc7LS1nb29nbGUtYmx1ZS01MDA6IzQyODVmNDstLWdvb2dsZS1ibHVlLTcwMDojMzM2N2Q2Oy0tZ29vZ2xlLWdyZWVuLTEwMDojYjdlMWNkOy0tZ29vZ2xlLWdyZWVuLTMwMDojNTdiYjhhOy0tZ29vZ2xlLWdyZWVuLTUwMDojMGY5ZDU4Oy0tZ29vZ2xlLWdyZWVuLTcwMDojMGI4MDQzOy0tZ29vZ2xlLXllbGxvdy0xMDA6I2ZjZThiMjstLWdvb2dsZS15ZWxsb3ctMzAwOiNmN2NiNGQ7LS1nb29nbGUteWVsbG93LTUwMDojZjRiNDAwOy0tZ29vZ2xlLXllbGxvdy03MDA6I2YwOTMwMDstLWdvb2dsZS1ncmV5LTEwMDojZjVmNWY1Oy0tZ29vZ2xlLWdyZXktMzAwOiNlMGUwZTA7LS1nb29nbGUtZ3JleS01MDA6IzllOWU5ZTstLWdvb2dsZS1ncmV5LTcwMDojNjE2MTYxOy0tcGFwZXItcmVkLTUwOiNmZmViZWU7LS1wYXBlci1yZWQtMTAwOiNmZmNkZDI7LS1wYXBlci1yZWQtMjAwOiNlZjlhOWE7LS1wYXBlci1yZWQtMzAwOiNlNTczNzM7LS1wYXBlci1yZWQtNDAwOiNlZjUzNTA7LS1wYXBlci1yZWQtNTAwOiNmNDQzMzY7LS1wYXBlci1yZWQtNjAwOiNlNTM5MzU7LS1wYXBlci1yZWQtNzAwOiNkMzJmMmY7LS1wYXBlci1yZWQtODAwOiNjNjI4Mjg7LS1wYXBlci1yZWQtOTAwOiNiNzFjMWM7LS1wYXBlci1yZWQtYTEwMDojZmY4YTgwOy0tcGFwZXItcmVkLWEyMDA6I2ZmNTI1MjstLXBhcGVyLXJlZC1hNDAwOiNmZjE3NDQ7LS1wYXBlci1yZWQtYTcwMDojZDUwMDAwOy0tcGFwZXItcGluay01MDojZmNlNGVjOy0tcGFwZXItcGluay0xMDA6I2Y4YmJkMDstLXBhcGVyLXBpbmstMjAwOiNmNDhmYjE7LS1wYXBlci1waW5rLTMwMDojZjA2MjkyOy0tcGFwZXItcGluay00MDA6I2VjNDA3YTstLXBhcGVyLXBpbmstNTAwOiNlOTFlNjM7LS1wYXBlci1waW5rLTYwMDojZDgxYjYwOy0tcGFwZXItcGluay03MDA6I2MyMTg1YjstLXBhcGVyLXBpbmstODAwOiNhZDE0NTc7LS1wYXBlci1waW5rLTkwMDojODgwZTRmOy0tcGFwZXItcGluay1hMTAwOiNmZjgwYWI7LS1wYXBlci1waW5rLWEyMDA6I2ZmNDA4MTstLXBhcGVyLXBpbmstYTQwMDojZjUwMDU3Oy0tcGFwZXItcGluay1hNzAwOiNjNTExNjI7LS1wYXBlci1wdXJwbGUtNTA6I2YzZTVmNTstLXBhcGVyLXB1cnBsZS0xMDA6I2UxYmVlNzstLXBhcGVyLXB1cnBsZS0yMDA6I2NlOTNkODstLXBhcGVyLXB1cnBsZS0zMDA6I2JhNjhjODstLXBhcGVyLXB1cnBsZS00MDA6I2FiNDdiYzstLXBhcGVyLXB1cnBsZS01MDA6IzljMjdiMDstLXBhcGVyLXB1cnBsZS02MDA6IzhlMjRhYTstLXBhcGVyLXB1cnBsZS03MDA6IzdiMWZhMjstLXBhcGVyLXB1cnBsZS04MDA6IzZhMWI5YTstLXBhcGVyLXB1cnBsZS05MDA6IzRhMTQ4YzstLXBhcGVyLXB1cnBsZS1hMTAwOiNlYTgwZmM7LS1wYXBlci1wdXJwbGUtYTIwMDojZTA0MGZiOy0tcGFwZXItcHVycGxlLWE0MDA6I2Q1MDBmOTstLXBhcGVyLXB1cnBsZS1hNzAwOiNhYTAwZmY7LS1wYXBlci1kZWVwLXB1cnBsZS01MDojZWRlN2Y2Oy0tcGFwZXItZGVlcC1wdXJwbGUtMTAwOiNkMWM0ZTk7LS1wYXBlci1kZWVwLXB1cnBsZS0yMDA6I2IzOWRkYjstLXBhcGVyLWRlZXAtcHVycGxlLTMwMDojOTU3NWNkOy0tcGFwZXItZGVlcC1wdXJwbGUtNDAwOiM3ZTU3YzI7LS1wYXBlci1kZWVwLXB1cnBsZS01MDA6IzY3M2FiNzstLXBhcGVyLWRlZXAtcHVycGxlLTYwMDojNWUzNWIxOy0tcGFwZXItZGVlcC1wdXJwbGUtNzAwOiM1MTJkYTg7LS1wYXBlci1kZWVwLXB1cnBsZS04MDA6IzQ1MjdhMDstLXBhcGVyLWRlZXAtcHVycGxlLTkwMDojMzExYjkyOy0tcGFwZXItZGVlcC1wdXJwbGUtYTEwMDojYjM4OGZmOy0tcGFwZXItZGVlcC1wdXJwbGUtYTIwMDojN2M0ZGZmOy0tcGFwZXItZGVlcC1wdXJwbGUtYTQwMDojNjUxZmZmOy0tcGFwZXItZGVlcC1wdXJwbGUtYTcwMDojNjIwMGVhOy0tcGFwZXItaW5kaWdvLTUwOiNlOGVhZjY7LS1wYXBlci1pbmRpZ28tMTAwOiNjNWNhZTk7LS1wYXBlci1pbmRpZ28tMjAwOiM5ZmE4ZGE7LS1wYXBlci1pbmRpZ28tMzAwOiM3OTg2Y2I7LS1wYXBlci1pbmRpZ28tNDAwOiM1YzZiYzA7LS1wYXBlci1pbmRpZ28tNTAwOiMzZjUxYjU7LS1wYXBlci1pbmRpZ28tNjAwOiMzOTQ5YWI7LS1wYXBlci1pbmRpZ28tNzAwOiMzMDNmOWY7LS1wYXBlci1pbmRpZ28tODAwOiMyODM1OTM7LS1wYXBlci1pbmRpZ28tOTAwOiMxYTIzN2U7LS1wYXBlci1pbmRpZ28tYTEwMDojOGM5ZWZmOy0tcGFwZXItaW5kaWdvLWEyMDA6IzUzNmRmZTstLXBhcGVyLWluZGlnby1hNDAwOiMzZDVhZmU7LS1wYXBlci1pbmRpZ28tYTcwMDojMzA0ZmZlOy0tcGFwZXItYmx1ZS01MDojZTNmMmZkOy0tcGFwZXItYmx1ZS0xMDA6I2JiZGVmYjstLXBhcGVyLWJsdWUtMjAwOiM5MGNhZjk7LS1wYXBlci1ibHVlLTMwMDojNjRiNWY2Oy0tcGFwZXItYmx1ZS00MDA6IzQyYTVmNTstLXBhcGVyLWJsdWUtNTAwOiMyMTk2ZjM7LS1wYXBlci1ibHVlLTYwMDojMWU4OGU1Oy0tcGFwZXItYmx1ZS03MDA6IzE5NzZkMjstLXBhcGVyLWJsdWUtODAwOiMxNTY1YzA7LS1wYXBlci1ibHVlLTkwMDojMGQ0N2ExOy0tcGFwZXItYmx1ZS1hMTAwOiM4MmIxZmY7LS1wYXBlci1ibHVlLWEyMDA6IzQ0OGFmZjstLXBhcGVyLWJsdWUtYTQwMDojMjk3OWZmOy0tcGFwZXItYmx1ZS1hNzAwOiMyOTYyZmY7LS1wYXBlci1saWdodC1ibHVlLTUwOiNlMWY1ZmU7LS1wYXBlci1saWdodC1ibHVlLTEwMDojYjNlNWZjOy0tcGFwZXItbGlnaHQtYmx1ZS0yMDA6IzgxZDRmYTstLXBhcGVyLWxpZ2h0LWJsdWUtMzAwOiM0ZmMzZjc7LS1wYXBlci1saWdodC1ibHVlLTQwMDojMjliNmY2Oy0tcGFwZXItbGlnaHQtYmx1ZS01MDA6IzAzYTlmNDstLXBhcGVyLWxpZ2h0LWJsdWUtNjAwOiMwMzliZTU7LS1wYXBlci1saWdodC1ibHVlLTcwMDojMDI4OGQxOy0tcGFwZXItbGlnaHQtYmx1ZS04MDA6IzAyNzdiZDstLXBhcGVyLWxpZ2h0LWJsdWUtOTAwOiMwMTU3OWI7LS1wYXBlci1saWdodC1ibHVlLWExMDA6IzgwZDhmZjstLXBhcGVyLWxpZ2h0LWJsdWUtYTIwMDojNDBjNGZmOy0tcGFwZXItbGlnaHQtYmx1ZS1hNDAwOiMwMGIwZmY7LS1wYXBlci1saWdodC1ibHVlLWE3MDA6IzAwOTFlYTstLXBhcGVyLWN5YW4tNTA6I2UwZjdmYTstLXBhcGVyLWN5YW4tMTAwOiNiMmViZjI7LS1wYXBlci1jeWFuLTIwMDojODBkZWVhOy0tcGFwZXItY3lhbi0zMDA6IzRkZDBlMTstLXBhcGVyLWN5YW4tNDAwOiMyNmM2ZGE7LS1wYXBlci1jeWFuLTUwMDojMDBiY2Q0Oy0tcGFwZXItY3lhbi02MDA6IzAwYWNjMTstLXBhcGVyLWN5YW4tNzAwOiMwMDk3YTc7LS1wYXBlci1jeWFuLTgwMDojMDA4MzhmOy0tcGFwZXItY3lhbi05MDA6IzAwNjA2NDstLXBhcGVyLWN5YW4tYTEwMDojODRmZmZmOy0tcGFwZXItY3lhbi1hMjAwOiMxOGZmZmY7LS1wYXBlci1jeWFuLWE0MDA6IzAwZTVmZjstLXBhcGVyLWN5YW4tYTcwMDojMDBiOGQ0Oy0tcGFwZXItdGVhbC01MDojZTBmMmYxOy0tcGFwZXItdGVhbC0xMDA6I2IyZGZkYjstLXBhcGVyLXRlYWwtMjAwOiM4MGNiYzQ7LS1wYXBlci10ZWFsLTMwMDojNGRiNmFjOy0tcGFwZXItdGVhbC00MDA6IzI2YTY5YTstLXBhcGVyLXRlYWwtNTAwOiMwMDk2ODg7LS1wYXBlci10ZWFsLTYwMDojMDA4OTdiOy0tcGFwZXItdGVhbC03MDA6IzAwNzk2YjstLXBhcGVyLXRlYWwtODAwOiMwMDY5NWM7LS1wYXBlci10ZWFsLTkwMDojMDA0ZDQwOy0tcGFwZXItdGVhbC1hMTAwOiNhN2ZmZWI7LS1wYXBlci10ZWFsLWEyMDA6IzY0ZmZkYTstLXBhcGVyLXRlYWwtYTQwMDojMWRlOWI2Oy0tcGFwZXItdGVhbC1hNzAwOiMwMGJmYTU7LS1wYXBlci1ncmVlbi01MDojZThmNWU5Oy0tcGFwZXItZ3JlZW4tMTAwOiNjOGU2Yzk7LS1wYXBlci1ncmVlbi0yMDA6I2E1ZDZhNzstLXBhcGVyLWdyZWVuLTMwMDojODFjNzg0Oy0tcGFwZXItZ3JlZW4tNDAwOiM2NmJiNmE7LS1wYXBlci1ncmVlbi01MDA6IzRjYWY1MDstLXBhcGVyLWdyZWVuLTYwMDojNDNhMDQ3Oy0tcGFwZXItZ3JlZW4tNzAwOiMzODhlM2M7LS1wYXBlci1ncmVlbi04MDA6IzJlN2QzMjstLXBhcGVyLWdyZWVuLTkwMDojMWI1ZTIwOy0tcGFwZXItZ3JlZW4tYTEwMDojYjlmNmNhOy0tcGFwZXItZ3JlZW4tYTIwMDojNjlmMGFlOy0tcGFwZXItZ3JlZW4tYTQwMDojMDBlNjc2Oy0tcGFwZXItZ3JlZW4tYTcwMDojMDBjODUzOy0tcGFwZXItbGlnaHQtZ3JlZW4tNTA6I2YxZjhlOTstLXBhcGVyLWxpZ2h0LWdyZWVuLTEwMDojZGNlZGM4Oy0tcGFwZXItbGlnaHQtZ3JlZW4tMjAwOiNjNWUxYTU7LS1wYXBlci1saWdodC1ncmVlbi0zMDA6I2FlZDU4MTstLXBhcGVyLWxpZ2h0LWdyZWVuLTQwMDojOWNjYzY1Oy0tcGFwZXItbGlnaHQtZ3JlZW4tNTAwOiM4YmMzNGE7LS1wYXBlci1saWdodC1ncmVlbi02MDA6IzdjYjM0MjstLXBhcGVyLWxpZ2h0LWdyZWVuLTcwMDojNjg5ZjM4Oy0tcGFwZXItbGlnaHQtZ3JlZW4tODAwOiM1NThiMmY7LS1wYXBlci1saWdodC1ncmVlbi05MDA6IzMzNjkxZTstLXBhcGVyLWxpZ2h0LWdyZWVuLWExMDA6I2NjZmY5MDstLXBhcGVyLWxpZ2h0LWdyZWVuLWEyMDA6I2IyZmY1OTstLXBhcGVyLWxpZ2h0LWdyZWVuLWE0MDA6Izc2ZmYwMzstLXBhcGVyLWxpZ2h0LWdyZWVuLWE3MDA6IzY0ZGQxNzstLXBhcGVyLWxpbWUtNTA6I2Y5ZmJlNzstLXBhcGVyLWxpbWUtMTAwOiNmMGY0YzM7LS1wYXBlci1saW1lLTIwMDojZTZlZTljOy0tcGFwZXItbGltZS0zMDA6I2RjZTc3NTstLXBhcGVyLWxpbWUtNDAwOiNkNGUxNTc7LS1wYXBlci1saW1lLTUwMDojY2RkYzM5Oy0tcGFwZXItbGltZS02MDA6I2MwY2EzMzstLXBhcGVyLWxpbWUtNzAwOiNhZmI0MmI7LS1wYXBlci1saW1lLTgwMDojOWU5ZDI0Oy0tcGFwZXItbGltZS05MDA6IzgyNzcxNzstLXBhcGVyLWxpbWUtYTEwMDojZjRmZjgxOy0tcGFwZXItbGltZS1hMjAwOiNlZWZmNDE7LS1wYXBlci1saW1lLWE0MDA6I2M2ZmYwMDstLXBhcGVyLWxpbWUtYTcwMDojYWVlYTAwOy0tcGFwZXIteWVsbG93LTUwOiNmZmZkZTc7LS1wYXBlci15ZWxsb3ctMTAwOiNmZmY5YzQ7LS1wYXBlci15ZWxsb3ctMjAwOiNmZmY1OWQ7LS1wYXBlci15ZWxsb3ctMzAwOiNmZmYxNzY7LS1wYXBlci15ZWxsb3ctNDAwOiNmZmVlNTg7LS1wYXBlci15ZWxsb3ctNTAwOiNmZmViM2I7LS1wYXBlci15ZWxsb3ctNjAwOiNmZGQ4MzU7LS1wYXBlci15ZWxsb3ctNzAwOiNmYmMwMmQ7LS1wYXBlci15ZWxsb3ctODAwOiNmOWE4MjU7LS1wYXBlci15ZWxsb3ctOTAwOiNmNTdmMTc7LS1wYXBlci15ZWxsb3ctYTEwMDojZmZmZjhkOy0tcGFwZXIteWVsbG93LWEyMDA6I2ZmZmYwMDstLXBhcGVyLXllbGxvdy1hNDAwOiNmZmVhMDA7LS1wYXBlci15ZWxsb3ctYTcwMDojZmZkNjAwOy0tcGFwZXItYW1iZXItNTA6I2ZmZjhlMTstLXBhcGVyLWFtYmVyLTEwMDojZmZlY2IzOy0tcGFwZXItYW1iZXItMjAwOiNmZmUwODI7LS1wYXBlci1hbWJlci0zMDA6I2ZmZDU0ZjstLXBhcGVyLWFtYmVyLTQwMDojZmZjYTI4Oy0tcGFwZXItYW1iZXItNTAwOiNmZmMxMDc7LS1wYXBlci1hbWJlci02MDA6I2ZmYjMwMDstLXBhcGVyLWFtYmVyLTcwMDojZmZhMDAwOy0tcGFwZXItYW1iZXItODAwOiNmZjhmMDA7LS1wYXBlci1hbWJlci05MDA6I2ZmNmYwMDstLXBhcGVyLWFtYmVyLWExMDA6I2ZmZTU3ZjstLXBhcGVyLWFtYmVyLWEyMDA6I2ZmZDc0MDstLXBhcGVyLWFtYmVyLWE0MDA6I2ZmYzQwMDstLXBhcGVyLWFtYmVyLWE3MDA6I2ZmYWIwMDstLXBhcGVyLW9yYW5nZS01MDojZmZmM2UwOy0tcGFwZXItb3JhbmdlLTEwMDojZmZlMGIyOy0tcGFwZXItb3JhbmdlLTIwMDojZmZjYzgwOy0tcGFwZXItb3JhbmdlLTMwMDojZmZiNzRkOy0tcGFwZXItb3JhbmdlLTQwMDojZmZhNzI2Oy0tcGFwZXItb3JhbmdlLTUwMDojZmY5ODAwOy0tcGFwZXItb3JhbmdlLTYwMDojZmI4YzAwOy0tcGFwZXItb3JhbmdlLTcwMDojZjU3YzAwOy0tcGFwZXItb3JhbmdlLTgwMDojZWY2YzAwOy0tcGFwZXItb3JhbmdlLTkwMDojZTY1MTAwOy0tcGFwZXItb3JhbmdlLWExMDA6I2ZmZDE4MDstLXBhcGVyLW9yYW5nZS1hMjAwOiNmZmFiNDA7LS1wYXBlci1vcmFuZ2UtYTQwMDojZmY5MTAwOy0tcGFwZXItb3JhbmdlLWE3MDA6I2ZmNjUwMDstLXBhcGVyLWRlZXAtb3JhbmdlLTUwOiNmYmU5ZTc7LS1wYXBlci1kZWVwLW9yYW5nZS0xMDA6I2ZmY2NiYzstLXBhcGVyLWRlZXAtb3JhbmdlLTIwMDojZmZhYjkxOy0tcGFwZXItZGVlcC1vcmFuZ2UtMzAwOiNmZjhhNjU7LS1wYXBlci1kZWVwLW9yYW5nZS00MDA6I2ZmNzA0MzstLXBhcGVyLWRlZXAtb3JhbmdlLTUwMDojZmY1NzIyOy0tcGFwZXItZGVlcC1vcmFuZ2UtNjAwOiNmNDUxMWU7LS1wYXBlci1kZWVwLW9yYW5nZS03MDA6I2U2NGExOTstLXBhcGVyLWRlZXAtb3JhbmdlLTgwMDojZDg0MzE1Oy0tcGFwZXItZGVlcC1vcmFuZ2UtOTAwOiNiZjM2MGM7LS1wYXBlci1kZWVwLW9yYW5nZS1hMTAwOiNmZjllODA7LS1wYXBlci1kZWVwLW9yYW5nZS1hMjAwOiNmZjZlNDA7LS1wYXBlci1kZWVwLW9yYW5nZS1hNDAwOiNmZjNkMDA7LS1wYXBlci1kZWVwLW9yYW5nZS1hNzAwOiNkZDJjMDA7LS1wYXBlci1icm93bi01MDojZWZlYmU5Oy0tcGFwZXItYnJvd24tMTAwOiNkN2NjYzg7LS1wYXBlci1icm93bi0yMDA6I2JjYWFhNDstLXBhcGVyLWJyb3duLTMwMDojYTE4ODdmOy0tcGFwZXItYnJvd24tNDAwOiM4ZDZlNjM7LS1wYXBlci1icm93bi01MDA6Izc5NTU0ODstLXBhcGVyLWJyb3duLTYwMDojNmQ0YzQxOy0tcGFwZXItYnJvd24tNzAwOiM1ZDQwMzc7LS1wYXBlci1icm93bi04MDA6IzRlMzQyZTstLXBhcGVyLWJyb3duLTkwMDojM2UyNzIzOy0tcGFwZXItZ3JleS01MDojZmFmYWZhOy0tcGFwZXItZ3JleS0xMDA6I2Y1ZjVmNTstLXBhcGVyLWdyZXktMjAwOiNlZWVlZWU7LS1wYXBlci1ncmV5LTMwMDojZTBlMGUwOy0tcGFwZXItZ3JleS00MDA6I2JkYmRiZDstLXBhcGVyLWdyZXktNTAwOiM5ZTllOWU7LS1wYXBlci1ncmV5LTYwMDojNzU3NTc1Oy0tcGFwZXItZ3JleS03MDA6IzYxNjE2MTstLXBhcGVyLWdyZXktODAwOiM0MjQyNDI7LS1wYXBlci1ncmV5LTkwMDojMjEyMTIxOy0tcGFwZXItYmx1ZS1ncmV5LTUwOiNlY2VmZjE7LS1wYXBlci1ibHVlLWdyZXktMTAwOiNjZmQ4ZGM7LS1wYXBlci1ibHVlLWdyZXktMjAwOiNiMGJlYzU7LS1wYXBlci1ibHVlLWdyZXktMzAwOiM5MGE0YWU7LS1wYXBlci1ibHVlLWdyZXktNDAwOiM3ODkwOWM7LS1wYXBlci1ibHVlLWdyZXktNTAwOiM2MDdkOGI7LS1wYXBlci1ibHVlLWdyZXktNjAwOiM1NDZlN2E7LS1wYXBlci1ibHVlLWdyZXktNzAwOiM0NTVhNjQ7LS1wYXBlci1ibHVlLWdyZXktODAwOiMzNzQ3NGY7LS1wYXBlci1ibHVlLWdyZXktOTAwOiMyNjMyMzg7LS1kYXJrLWRpdmlkZXItb3BhY2l0eTowLjEyOy0tZGFyay1kaXNhYmxlZC1vcGFjaXR5OjAuMzg7LS1kYXJrLXNlY29uZGFyeS1vcGFjaXR5OjAuNTQ7LS1kYXJrLXByaW1hcnktb3BhY2l0eTowLjg3Oy0tbGlnaHQtZGl2aWRlci1vcGFjaXR5OjAuMTI7LS1saWdodC1kaXNhYmxlZC1vcGFjaXR5OjAuMzstLWxpZ2h0LXNlY29uZGFyeS1vcGFjaXR5OjAuNzstLWxpZ2h0LXByaW1hcnktb3BhY2l0eToxLjB9PC9zdHlsZT4gPC9jdXN0b20tc3R5bGU+XCIpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9wYXBlci1zdHlsZXMvY29sb3IuaHRtbCIsIjwhLS1cclxuQGxpY2Vuc2VcclxuQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxyXG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxyXG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcclxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cclxuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcclxuLS0+XHJcblxyXG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL3BvbHltZXItZWxlbWVudC5odG1sXCI+XHJcbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi9ib3dlcl9jb21wb25lbnRzL2FwcC1sYXlvdXQvYXBwLWRyYXdlci9hcHAtZHJhd2VyLmh0bWxcIj5cclxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL2Jvd2VyX2NvbXBvbmVudHMvYXBwLWxheW91dC9hcHAtZHJhd2VyLWxheW91dC9hcHAtZHJhd2VyLWxheW91dC5odG1sXCI+XHJcbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi9ib3dlcl9jb21wb25lbnRzL2FwcC1sYXlvdXQvYXBwLWhlYWRlci9hcHAtaGVhZGVyLmh0bWxcIj5cclxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL2Jvd2VyX2NvbXBvbmVudHMvYXBwLWxheW91dC9hcHAtaGVhZGVyLWxheW91dC9hcHAtaGVhZGVyLWxheW91dC5odG1sXCI+XHJcbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi9ib3dlcl9jb21wb25lbnRzL2FwcC1sYXlvdXQvYXBwLXNjcm9sbC1lZmZlY3RzL2FwcC1zY3JvbGwtZWZmZWN0cy5odG1sXCI+XHJcbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi9ib3dlcl9jb21wb25lbnRzL2FwcC1sYXlvdXQvYXBwLXRvb2xiYXIvYXBwLXRvb2xiYXIuaHRtbFwiPlxyXG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vYm93ZXJfY29tcG9uZW50cy9hcHAtcm91dGUvYXBwLWxvY2F0aW9uLmh0bWxcIj5cclxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL2Jvd2VyX2NvbXBvbmVudHMvYXBwLXJvdXRlL2FwcC1yb3V0ZS5odG1sXCI+XHJcbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi9ib3dlcl9jb21wb25lbnRzL2lyb24tcGFnZXMvaXJvbi1wYWdlcy5odG1sXCI+XHJcbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi9ib3dlcl9jb21wb25lbnRzL2lyb24tc2VsZWN0b3IvaXJvbi1zZWxlY3Rvci5odG1sXCI+XHJcbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi9ib3dlcl9jb21wb25lbnRzL3BhcGVyLWljb24tYnV0dG9uL3BhcGVyLWljb24tYnV0dG9uLmh0bWxcIj5cclxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIm15LWljb25zLmh0bWxcIj5cclxuXHJcbjxkb20tbW9kdWxlIGlkPVwibXktYXBwXCI+XHJcbiAgPHRlbXBsYXRlPlxyXG4gICAgPHN0eWxlPlxyXG4gICAgICAgOmhvc3Qge1xyXG4gICAgICAgIC0tYXBwLXByaW1hcnktY29sb3I6ICMzRDI4MTQ7XHJcbiAgICAgICAgLS1hcHAtc2Vjb25kYXJ5LWNvbG9yOiAjRkYzQzNDO1xyXG5cclxuICAgICAgICBkaXNwbGF5OiBibG9jaztcclxuICAgICAgfVxyXG5cclxuICAgICAgYXBwLWRyYXdlci1sYXlvdXQ6bm90KFtuYXJyb3ddKSBbZHJhd2VyLXRvZ2dsZV0ge1xyXG4gICAgICAgIGRpc3BsYXk6IG5vbmU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGFwcC1oZWFkZXIge1xyXG4gICAgICAgIGNvbG9yOiAjZmZmO1xyXG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWFwcC1wcmltYXJ5LWNvbG9yKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgYXBwLWhlYWRlciBwYXBlci1pY29uLWJ1dHRvbiB7XHJcbiAgICAgICAgLS1wYXBlci1pY29uLWJ1dHRvbi1pbmstY29sb3I6IHdoaXRlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAuZHJhd2VyLWxpc3Qge1xyXG4gICAgICAgIG1hcmdpbjogMCAyMHB4O1xyXG4gICAgICB9XHJcblxyXG4gICAgICAuZHJhd2VyLWxpc3QgYSB7XHJcbiAgICAgICAgZGlzcGxheTogYmxvY2s7XHJcbiAgICAgICAgcGFkZGluZzogMCAxNnB4O1xyXG4gICAgICAgIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcclxuICAgICAgICBjb2xvcjogdmFyKC0tYXBwLXNlY29uZGFyeS1jb2xvcik7XHJcbiAgICAgICAgbGluZS1oZWlnaHQ6IDQwcHg7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC5kcmF3ZXItbGlzdCBhLmlyb24tc2VsZWN0ZWQge1xyXG4gICAgICAgIGNvbG9yOiBibGFjaztcclxuICAgICAgICBmb250LXdlaWdodDogYm9sZDtcclxuICAgICAgfVxyXG4gICAgPC9zdHlsZT5cclxuXHJcbiAgICA8YXBwLWxvY2F0aW9uIHJvdXRlPVwie3tyb3V0ZX19XCIgdXJsLXNwYWNlLXJlZ2V4PVwiXltbcm9vdFBhdGhdXVwiPjwvYXBwLWxvY2F0aW9uPlxyXG4gICAgPGFwcC1yb3V0ZSByb3V0ZT1cInt7cm91dGV9fVwiIHBhdHRlcm49XCJbW3Jvb3RQYXRoXV06cGFnZVwiIGRhdGE9XCJ7e3JvdXRlRGF0YX19XCIgdGFpbD1cInt7c3Vicm91dGV9fVwiPjwvYXBwLXJvdXRlPlxyXG5cclxuICAgIDxhcHAtZHJhd2VyLWxheW91dCBmdWxsYmxlZWQ+XHJcbiAgICAgIDwhLS0gRHJhd2VyIGNvbnRlbnQgLS0+XHJcbiAgICAgIDxhcHAtZHJhd2VyIGlkPVwiZHJhd2VyXCIgc2xvdD1cImRyYXdlclwiPlxyXG4gICAgICAgIDxhcHAtdG9vbGJhcj5TcGllbGU8L2FwcC10b29sYmFyPlxyXG4gICAgICAgIDxpcm9uLXNlbGVjdG9yIHNlbGVjdGVkPVwiW1twYWdlXV1cIiBhdHRyLWZvci1zZWxlY3RlZD1cIm5hbWVcIiBjbGFzcz1cImRyYXdlci1saXN0XCIgcm9sZT1cIm5hdmlnYXRpb25cIj5cclxuICAgICAgICAgIDxhIG5hbWU9XCJ2aWV3MlwiIGhyZWYkPVwiW1tyb290UGF0aF1ddmlldzJcIj5OZXdzPC9hPlxyXG4gICAgICAgICAgPGEgbmFtZT1cImdhbWVzXCIgaHJlZiQ9XCJbW3Jvb3RQYXRoXV1nYW1lc1wiPlNwaWVsZTwvYT5cclxuICAgICAgICAgIDxhIG5hbWU9XCJhdXRob3JzXCIgaHJlZiQ9XCJbW3Jvb3RQYXRoXV1hdXRob3JzXCI+QXV0b3JlbjwvYT5cclxuICAgICAgICAgIDxhIG5hbWU9XCJwdWJsaXNoZXJzXCIgaHJlZiQ9XCJbW3Jvb3RQYXRoXV1wdWJsaXNoZXJzXCI+VmVybGFnZTwvYT5cclxuICAgICAgICAgIDxhIG5hbWU9XCJkZXNpZ25lcnNcIiBocmVmJD1cIltbcm9vdFBhdGhdXWRlc2lnbmVyc1wiPkRlc2lnbmVyPC9hPlxyXG4gICAgICAgICAgPGEgbmFtZT1cInJldmlld3NcIiBocmVmJD1cIltbcm9vdFBhdGhdXXJldmlld3NcIj5SZXplbnNlbmlvbmVuPC9hPlxyXG4gICAgICAgICAgPGEgbmFtZT1cInZpZXczXCIgaHJlZiQ9XCJbW3Jvb3RQYXRoXV12aWV3M1wiPlByZWlzZTwvYT5cclxuICAgICAgICAgIDxocj5cclxuICAgICAgICAgIDxhIG5hbWU9XCJ2aWV3M1wiIGhyZWYkPVwiW1tyb290UGF0aF1ddmlldzNcIj5TYW1tbHVuZzwvYT5cclxuICAgICAgICAgIDxhIG5hbWU9XCJ2aWV3M1wiIGhyZWYkPVwiW1tyb290UGF0aF1ddmlldzNcIj5TZXR0aW5nczwvYT5cclxuICAgICAgICA8L2lyb24tc2VsZWN0b3I+XHJcbiAgICAgIDwvYXBwLWRyYXdlcj5cclxuXHJcbiAgICAgIDwhLS0gTWFpbiBjb250ZW50IC0tPlxyXG4gICAgICA8YXBwLWhlYWRlci1sYXlvdXQgaGFzLXNjcm9sbGluZy1yZWdpb24+XHJcblxyXG4gICAgICAgIDxhcHAtaGVhZGVyIHNsb3Q9XCJoZWFkZXJcIiBjb25kZW5zZXMgcmV2ZWFscyBlZmZlY3RzPVwid2F0ZXJmYWxsXCI+XHJcbiAgICAgICAgICA8YXBwLXRvb2xiYXI+XHJcbiAgICAgICAgICAgIDxwYXBlci1pY29uLWJ1dHRvbiBpY29uPVwibXktaWNvbnM6bWVudVwiIGRyYXdlci10b2dnbGU+PC9wYXBlci1pY29uLWJ1dHRvbj5cclxuICAgICAgICAgICAgPGRpdiBtYWluLXRpdGxlPkx1ZGluZy5vcmc8L2Rpdj5cclxuICAgICAgICAgIDwvYXBwLXRvb2xiYXI+XHJcbiAgICAgICAgPC9hcHAtaGVhZGVyPlxyXG5cclxuICAgICAgICA8aXJvbi1wYWdlcyBzZWxlY3RlZD1cIltbcGFnZV1dXCIgYXR0ci1mb3Itc2VsZWN0ZWQ9XCJuYW1lXCIgZmFsbGJhY2stc2VsZWN0aW9uPVwidmlldzQwNFwiIHJvbGU9XCJtYWluXCI+XHJcbiAgICAgICAgICA8Z2FtZXMtbGlzdCBuYW1lPVwiZ2FtZXNcIj48L2dhbWVzLWxpc3Q+XHJcbiAgICAgICAgICA8bXktdmlldzIgbmFtZT1cInZpZXcyXCI+PC9teS12aWV3Mj5cclxuICAgICAgICAgIDxhdXRob3JzLWxpc3QgbmFtZT1cImF1dGhvcnNcIj48L2F1dGhvcnMtbGlzdD5cclxuICAgICAgICAgIDxwdWJsaXNoZXJzLWxpc3QgbmFtZT1cInB1Ymxpc2hlcnNcIj48L3B1Ymxpc2hlcnMtbGlzdD5cclxuICAgICAgICAgIDxteS12aWV3MyBuYW1lPVwidmlldzNcIj48L215LXZpZXczPlxyXG4gICAgICAgICAgPG15LXZpZXc0MDQgbmFtZT1cInZpZXc0MDRcIj48L215LXZpZXc0MDQ+XHJcbiAgICAgICAgPC9pcm9uLXBhZ2VzPlxyXG4gICAgICA8L2FwcC1oZWFkZXItbGF5b3V0PlxyXG4gICAgPC9hcHAtZHJhd2VyLWxheW91dD5cclxuICA8L3RlbXBsYXRlPlxyXG5cclxuICA8c2NyaXB0PlxyXG5cclxuICAgIGNsYXNzIE15QXBwIGV4dGVuZHMgUG9seW1lci5FbGVtZW50IHtcclxuXHJcbiAgICAgIHN0YXRpYyBnZXQgaXMoKSB7IHJldHVybiAnbXktYXBwJzsgfVxyXG5cclxuICAgICAgc3RhdGljIGdldCBwcm9wZXJ0aWVzKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICBwYWdlOiB7XHJcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcclxuICAgICAgICAgICAgcmVmbGVjdFRvQXR0cmlidXRlOiB0cnVlLFxyXG4gICAgICAgICAgICBvYnNlcnZlcjogJ19wYWdlQ2hhbmdlZCcsXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgcm91dGVEYXRhOiBPYmplY3QsXHJcbiAgICAgICAgICBzdWJyb3V0ZTogU3RyaW5nLFxyXG4gICAgICAgICAgcm9vdFBhdGg6IHtcclxuICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxyXG4gICAgICAgICAgICB2YWx1ZTogJy8nXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgbGF6eVBhZ2VzOiB7XHJcbiAgICAgICAgICAgIHR5cGU6IE9iamVjdCxcclxuICAgICAgICAgICAgdmFsdWU6IHtcclxuICAgICAgICAgICAgICB2aWV3MjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgaW1wb3J0KC8qIHdlYnBhY2tDaHVua05hbWU6IFwibXktdmlldzJcIiAqLyAnLi9teS12aWV3Mi5odG1sJyk7XHJcbiAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICBnYW1lczogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgaW1wb3J0KC8qIHdlYnBhY2tDaHVua05hbWU6IFwiZ2FtZXMtbGlzdFwiICovICcuL2dhbWVzLWxpc3QuaHRtbCcpO1xyXG4gICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgYXV0aG9yczogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgaW1wb3J0KC8qIHdlYnBhY2tDaHVua05hbWU6IFwiYXV0aG9ycy1saXN0XCIgKi8gJy4vYXV0aG9ycy1saXN0Lmh0bWwnKTtcclxuICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgIHB1Ymxpc2hlcnM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGltcG9ydCgvKiB3ZWJwYWNrQ2h1bmtOYW1lOiBcInB1Ymxpc2hlcnMtbGlzdFwiICovICcuL3B1Ymxpc2hlcnMtbGlzdC5odG1sJyk7XHJcbiAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICB2aWV3MzogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgaW1wb3J0KC8qIHdlYnBhY2tDaHVua05hbWU6IFwibXktdmlldzNcIiAqLyAnLi9teS12aWV3My5odG1sJyk7XHJcbiAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICB2aWV3NDA0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBpbXBvcnQoLyogd2VicGFja0NodW5rTmFtZTogXCJteS12aWV3NDA0XCIgKi8gJy4vbXktdmlldzQwNC5odG1sJyk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgfVxyXG5cclxuICAgICAgc3RhdGljIGdldCBvYnNlcnZlcnMoKSB7XHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICdfcm91dGVQYWdlQ2hhbmdlZChyb3V0ZURhdGEucGFnZSknLFxyXG4gICAgICAgIF07XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIF9yb3V0ZVBhZ2VDaGFuZ2VkKHBhZ2UpIHtcclxuICAgICAgICAvLyBQb2x5bWVyIDIuMCB3aWxsIGNhbGwgd2l0aCBgdW5kZWZpbmVkYCBvbiBpbml0aWFsaXphdGlvbi5cclxuICAgICAgICAvLyBJZ25vcmUgdW50aWwgd2UgYXJlIHByb3Blcmx5IGNhbGxlZCB3aXRoIGEgc3RyaW5nLlxyXG4gICAgICAgIGlmIChwYWdlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIElmIG5vIHBhZ2Ugd2FzIGZvdW5kIGluIHRoZSByb3V0ZSBkYXRhLCBwYWdlIHdpbGwgYmUgYW4gZW1wdHkgc3RyaW5nLlxyXG4gICAgICAgIC8vIERlYXVsdCB0byAndmlldzEnIGluIHRoYXQgY2FzZS5cclxuICAgICAgICB0aGlzLnBhZ2UgPSBwYWdlIHx8ICd2aWV3MSc7XHJcblxyXG4gICAgICAgIC8vIENsb3NlIGEgbm9uLXBlcnNpc3RlbnQgZHJhd2VyIHdoZW4gdGhlIHBhZ2UgJiByb3V0ZSBhcmUgY2hhbmdlZC5cclxuICAgICAgICBpZiAoIXRoaXMuJC5kcmF3ZXIucGVyc2lzdGVudCkge1xyXG4gICAgICAgICAgdGhpcy4kLmRyYXdlci5jbG9zZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgX3BhZ2VDaGFuZ2VkKHBhZ2UpIHtcclxuICAgICAgICBpZiAodGhpcy5sYXp5UGFnZXNbcGFnZV0pIHtcclxuICAgICAgICAgIHRoaXMubGF6eVBhZ2VzW3BhZ2VdKCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHRoaXMuX3Nob3dQYWdlNDA0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBfc2hvd1BhZ2U0MDQoKSB7XHJcbiAgICAgICAgdGhpcy5wYWdlID0gJ3ZpZXc0MDQnO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgd2luZG93LmN1c3RvbUVsZW1lbnRzLmRlZmluZShNeUFwcC5pcywgTXlBcHApO1xyXG4gIDwvc2NyaXB0PlxyXG48L2RvbS1tb2R1bGU+XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL215LWFwcC5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3V0aWxzL2Jvb3QuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3V0aWxzL3Jlc29sdmUtdXJsLmh0bWxcIj5cbjxzY3JpcHQ+XG4oZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBsZXQgbW9kdWxlcyA9IHt9O1xuICBsZXQgbGNNb2R1bGVzID0ge307XG4gIGZ1bmN0aW9uIGZpbmRNb2R1bGUoaWQpIHtcbiAgICByZXR1cm4gbW9kdWxlc1tpZF0gfHwgbGNNb2R1bGVzW2lkLnRvTG93ZXJDYXNlKCldO1xuICB9XG5cbiAgZnVuY3Rpb24gc3R5bGVPdXRzaWRlVGVtcGxhdGVDaGVjayhpbnN0KSB7XG4gICAgaWYgKGluc3QucXVlcnlTZWxlY3Rvcignc3R5bGUnKSkge1xuICAgICAgY29uc29sZS53YXJuKCdkb20tbW9kdWxlICVzIGhhcyBzdHlsZSBvdXRzaWRlIHRlbXBsYXRlJywgaW5zdC5pZCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBgZG9tLW1vZHVsZWAgZWxlbWVudCByZWdpc3RlcnMgdGhlIGRvbSBpdCBjb250YWlucyB0byB0aGUgbmFtZSBnaXZlblxuICAgKiBieSB0aGUgbW9kdWxlJ3MgaWQgYXR0cmlidXRlLiBJdCBwcm92aWRlcyBhIHVuaWZpZWQgZGF0YWJhc2Ugb2YgZG9tXG4gICAqIGFjY2Vzc2libGUgdmlhIGl0cyBzdGF0aWMgYGltcG9ydGAgQVBJLlxuICAgKlxuICAgKiBBIGtleSB1c2UgY2FzZSBvZiBgZG9tLW1vZHVsZWAgaXMgZm9yIHByb3ZpZGluZyBjdXN0b20gZWxlbWVudCBgPHRlbXBsYXRlPmBzXG4gICAqIHZpYSBIVE1MIGltcG9ydHMgdGhhdCBhcmUgcGFyc2VkIGJ5IHRoZSBuYXRpdmUgSFRNTCBwYXJzZXIsIHRoYXQgY2FuIGJlXG4gICAqIHJlbG9jYXRlZCBkdXJpbmcgYSBidW5kbGluZyBwYXNzIGFuZCBzdGlsbCBsb29rZWQgdXAgYnkgYGlkYC5cbiAgICpcbiAgICogRXhhbXBsZTpcbiAgICpcbiAgICogICAgIDxkb20tbW9kdWxlIGlkPVwiZm9vXCI+XG4gICAqICAgICAgIDxpbWcgc3JjPVwic3R1ZmYucG5nXCI+XG4gICAqICAgICA8L2RvbS1tb2R1bGU+XG4gICAqXG4gICAqIFRoZW4gaW4gY29kZSBpbiBzb21lIG90aGVyIGxvY2F0aW9uIHRoYXQgY2Fubm90IGFjY2VzcyB0aGUgZG9tLW1vZHVsZSBhYm92ZVxuICAgKlxuICAgKiAgICAgbGV0IGltZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RvbS1tb2R1bGUnKS5pbXBvcnQoJ2ZvbycsICdpbWcnKTtcbiAgICpcbiAgICogQGN1c3RvbUVsZW1lbnRcbiAgICogQGV4dGVuZHMgSFRNTEVsZW1lbnRcbiAgICogQG1lbWJlcm9mIFBvbHltZXJcbiAgICogQHN1bW1hcnkgQ3VzdG9tIGVsZW1lbnQgdGhhdCBwcm92aWRlcyBhIHJlZ2lzdHJ5IG9mIHJlbG9jYXRhYmxlIERPTSBjb250ZW50XG4gICAqICAgYnkgYGlkYCB0aGF0IGlzIGFnbm9zdGljIHRvIGJ1bmRsaW5nLlxuICAgKiBAdW5yZXN0cmljdGVkXG4gICAqL1xuICBjbGFzcyBEb21Nb2R1bGUgZXh0ZW5kcyBIVE1MRWxlbWVudCB7XG5cbiAgICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHsgcmV0dXJuIFsnaWQnXSB9XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIGVsZW1lbnQgc3BlY2lmaWVkIGJ5IHRoZSBjc3MgYHNlbGVjdG9yYCBpbiB0aGUgbW9kdWxlXG4gICAgICogcmVnaXN0ZXJlZCBieSBgaWRgLiBGb3IgZXhhbXBsZSwgdGhpcy5pbXBvcnQoJ2ZvbycsICdpbWcnKTtcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgVGhlIGlkIG9mIHRoZSBkb20tbW9kdWxlIGluIHdoaWNoIHRvIHNlYXJjaC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZz19IHNlbGVjdG9yIFRoZSBjc3Mgc2VsZWN0b3IgYnkgd2hpY2ggdG8gZmluZCB0aGUgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJuIHtFbGVtZW50fSBSZXR1cm5zIHRoZSBlbGVtZW50IHdoaWNoIG1hdGNoZXMgYHNlbGVjdG9yYCBpbiB0aGVcbiAgICAgKiBtb2R1bGUgcmVnaXN0ZXJlZCBhdCB0aGUgc3BlY2lmaWVkIGBpZGAuXG4gICAgICovXG4gICAgc3RhdGljIGltcG9ydChpZCwgc2VsZWN0b3IpIHtcbiAgICAgIGlmIChpZCkge1xuICAgICAgICBsZXQgbSA9IGZpbmRNb2R1bGUoaWQpO1xuICAgICAgICBpZiAobSAmJiBzZWxlY3Rvcikge1xuICAgICAgICAgIHJldHVybiBtLnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIG9sZCwgdmFsdWUpIHtcbiAgICAgIGlmIChvbGQgIT09IHZhbHVlKSB7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYWJzb2x1dGUgVVJMIG9mIHRoZSBvcmlnaW5hbCBsb2NhdGlvbiBvZiB0aGlzIGBkb20tbW9kdWxlYC5cbiAgICAgKlxuICAgICAqIFRoaXMgdmFsdWUgd2lsbCBkaWZmZXIgZnJvbSB0aGlzIGVsZW1lbnQncyBgb3duZXJEb2N1bWVudGAgaW4gdGhlXG4gICAgICogZm9sbG93aW5nIHdheXM6XG4gICAgICogLSBUYWtlcyBpbnRvIGFjY291bnQgYW55IGBhc3NldHBhdGhgIGF0dHJpYnV0ZSBhZGRlZCBkdXJpbmcgYnVuZGxpbmdcbiAgICAgKiAgIHRvIGluZGljYXRlIHRoZSBvcmlnaW5hbCBsb2NhdGlvbiByZWxhdGl2ZSB0byB0aGUgYnVuZGxlZCBsb2NhdGlvblxuICAgICAqIC0gVXNlcyB0aGUgSFRNTEltcG9ydHMgcG9seWZpbGwncyBgaW1wb3J0Rm9yRWxlbWVudGAgQVBJIHRvIGVuc3VyZVxuICAgICAqICAgdGhlIHBhdGggaXMgcmVsYXRpdmUgdG8gdGhlIGltcG9ydCBkb2N1bWVudCdzIGxvY2F0aW9uIHNpbmNlXG4gICAgICogICBgb3duZXJEb2N1bWVudGAgaXMgbm90IGN1cnJlbnRseSBwb2x5ZmlsbGVkXG4gICAgICovXG4gICAgZ2V0IGFzc2V0cGF0aCgpIHtcbiAgICAgIC8vIERvbid0IG92ZXJyaWRlIGV4aXN0aW5nIGFzc2V0cGF0aC5cbiAgICAgIGlmICghdGhpcy5fX2Fzc2V0cGF0aCkge1xuICAgICAgICAvLyBub3RlOiBhc3NldHBhdGggc2V0IHZpYSBhbiBhdHRyaWJ1dGUgbXVzdCBiZSByZWxhdGl2ZSB0byB0aGlzXG4gICAgICAgIC8vIGVsZW1lbnQncyBsb2NhdGlvbjsgYWNjb21vZGF0ZSBwb2x5ZmlsbGVkIEhUTUxJbXBvcnRzXG4gICAgICAgIGNvbnN0IG93bmVyID0gd2luZG93LkhUTUxJbXBvcnRzICYmIEhUTUxJbXBvcnRzLmltcG9ydEZvckVsZW1lbnQgP1xuICAgICAgICAgIEhUTUxJbXBvcnRzLmltcG9ydEZvckVsZW1lbnQodGhpcykgfHwgZG9jdW1lbnQgOiB0aGlzLm93bmVyRG9jdW1lbnQ7XG4gICAgICAgIGNvbnN0IHVybCA9IFBvbHltZXIuUmVzb2x2ZVVybC5yZXNvbHZlVXJsKFxuICAgICAgICAgIHRoaXMuZ2V0QXR0cmlidXRlKCdhc3NldHBhdGgnKSB8fCAnJywgb3duZXIuYmFzZVVSSSk7XG4gICAgICAgIHRoaXMuX19hc3NldHBhdGggPSBQb2x5bWVyLlJlc29sdmVVcmwucGF0aEZyb21VcmwodXJsKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9fYXNzZXRwYXRoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyB0aGUgZG9tLW1vZHVsZSBhdCBhIGdpdmVuIGlkLiBUaGlzIG1ldGhvZCBzaG91bGQgb25seSBiZSBjYWxsZWRcbiAgICAgKiB3aGVuIGEgZG9tLW1vZHVsZSBpcyBpbXBlcmF0aXZlbHkgY3JlYXRlZC4gRm9yXG4gICAgICogZXhhbXBsZSwgYGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RvbS1tb2R1bGUnKS5yZWdpc3RlcignZm9vJylgLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nPX0gaWQgVGhlIGlkIGF0IHdoaWNoIHRvIHJlZ2lzdGVyIHRoZSBkb20tbW9kdWxlLlxuICAgICAqL1xuICAgIHJlZ2lzdGVyKGlkKSB7XG4gICAgICBpZCA9IGlkIHx8IHRoaXMuaWQ7XG4gICAgICBpZiAoaWQpIHtcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICAvLyBzdG9yZSBpZCBzZXBhcmF0ZSBmcm9tIGxvd2VyY2FzZWQgaWQgc28gdGhhdFxuICAgICAgICAvLyBpbiBhbGwgY2FzZXMgbWl4ZWRDYXNlIGlkIHdpbGwgc3RvcmVkIGRpc3RpbmN0bHlcbiAgICAgICAgLy8gYW5kIGxvd2VyY2FzZSB2ZXJzaW9uIGlzIGEgZmFsbGJhY2tcbiAgICAgICAgbW9kdWxlc1tpZF0gPSB0aGlzO1xuICAgICAgICBsY01vZHVsZXNbaWQudG9Mb3dlckNhc2UoKV0gPSB0aGlzO1xuICAgICAgICBzdHlsZU91dHNpZGVUZW1wbGF0ZUNoZWNrKHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIERvbU1vZHVsZS5wcm90b3R5cGVbJ21vZHVsZXMnXSA9IG1vZHVsZXM7XG5cbiAgY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdkb20tbW9kdWxlJywgRG9tTW9kdWxlKTtcblxuICAvLyBleHBvcnRcbiAgUG9seW1lci5Eb21Nb2R1bGUgPSBEb21Nb2R1bGU7XG5cbn0pKCk7XG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvZWxlbWVudHMvZG9tLW1vZHVsZS5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuXG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiYm9vdC5odG1sXCI+XG5cbjxzY3JpcHQ+XG4oZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvKipcbiAgICogTW9kdWxlIHdpdGggdXRpbGl0aWVzIGZvciBtYW5pcHVsYXRpbmcgc3RydWN0dXJlZCBkYXRhIHBhdGggc3RyaW5ncy5cbiAgICpcbiAgICogQG5hbWVzcGFjZVxuICAgKiBAbWVtYmVyb2YgUG9seW1lclxuICAgKiBAc3VtbWFyeSBNb2R1bGUgd2l0aCB1dGlsaXRpZXMgZm9yIG1hbmlwdWxhdGluZyBzdHJ1Y3R1cmVkIGRhdGEgcGF0aCBzdHJpbmdzLlxuICAgKi9cbiAgY29uc3QgUGF0aCA9IHtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gc3RyaW5nIGlzIGEgc3RydWN0dXJlZCBkYXRhIHBhdGggKGhhcyBkb3RzKS5cbiAgICAgKlxuICAgICAqIEV4YW1wbGU6XG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiBQb2x5bWVyLlBhdGguaXNQYXRoKCdmb28uYmFyLmJheicpIC8vIHRydWVcbiAgICAgKiBQb2x5bWVyLlBhdGguaXNQYXRoKCdmb28nKSAgICAgICAgIC8vIGZhbHNlXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgUG9seW1lci5QYXRoXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggUGF0aCBzdHJpbmdcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBzdHJpbmcgY29udGFpbmVkIG9uZSBvciBtb3JlIGRvdHNcbiAgICAgKi9cbiAgICBpc1BhdGg6IGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgIHJldHVybiBwYXRoLmluZGV4T2YoJy4nKSA+PSAwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSByb290IHByb3BlcnR5IG5hbWUgZm9yIHRoZSBnaXZlbiBwYXRoLlxuICAgICAqXG4gICAgICogRXhhbXBsZTpcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIFBvbHltZXIuUGF0aC5yb290KCdmb28uYmFyLmJheicpIC8vICdmb28nXG4gICAgICogUG9seW1lci5QYXRoLnJvb3QoJ2ZvbycpICAgICAgICAgLy8gJ2ZvbydcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBQb2x5bWVyLlBhdGhcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBQYXRoIHN0cmluZ1xuICAgICAqIEByZXR1cm4ge3N0cmluZ30gUm9vdCBwcm9wZXJ0eSBuYW1lXG4gICAgICovXG4gICAgcm9vdDogZnVuY3Rpb24ocGF0aCkge1xuICAgICAgbGV0IGRvdEluZGV4ID0gcGF0aC5pbmRleE9mKCcuJyk7XG4gICAgICBpZiAoZG90SW5kZXggPT09IC0xKSB7XG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhdGguc2xpY2UoMCwgZG90SW5kZXgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHaXZlbiBgYmFzZWAgaXMgYGZvby5iYXJgLCBgZm9vYCBpcyBhbiBhbmNlc3RvciwgYGZvby5iYXJgIGlzIG5vdFxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gcGF0aCBpcyBhbiBhbmNlc3RvciBvZiB0aGUgYmFzZSBwYXRoLlxuICAgICAqXG4gICAgICogRXhhbXBsZTpcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIFBvbHltZXIuUGF0aC5pc0FuY2VzdG9yKCdmb28uYmFyJywgJ2ZvbycpICAgICAgICAgLy8gdHJ1ZVxuICAgICAqIFBvbHltZXIuUGF0aC5pc0FuY2VzdG9yKCdmb28uYmFyJywgJ2Zvby5iYXInKSAgICAgLy8gZmFsc2VcbiAgICAgKiBQb2x5bWVyLlBhdGguaXNBbmNlc3RvcignZm9vLmJhcicsICdmb28uYmFyLmJheicpIC8vIGZhbHNlXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgUG9seW1lci5QYXRoXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGJhc2UgUGF0aCBzdHJpbmcgdG8gdGVzdCBhZ2FpbnN0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFBhdGggc3RyaW5nIHRvIHRlc3QuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBgcGF0aGAgaXMgYW4gYW5jZXN0b3Igb2YgYGJhc2VgLlxuICAgICAqL1xuICAgIGlzQW5jZXN0b3I6IGZ1bmN0aW9uKGJhc2UsIHBhdGgpIHtcbiAgICAgIC8vICAgICBiYXNlLnN0YXJ0c1dpdGgocGF0aCArICcuJyk7XG4gICAgICByZXR1cm4gYmFzZS5pbmRleE9mKHBhdGggKyAnLicpID09PSAwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHaXZlbiBgYmFzZWAgaXMgYGZvby5iYXJgLCBgZm9vLmJhci5iYXpgIGlzIGFuIGRlc2NlbmRhbnRcbiAgICAgKlxuICAgICAqIEV4YW1wbGU6XG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiBQb2x5bWVyLlBhdGguaXNEZXNjZW5kYW50KCdmb28uYmFyJywgJ2Zvby5iYXIuYmF6JykgLy8gdHJ1ZVxuICAgICAqIFBvbHltZXIuUGF0aC5pc0Rlc2NlbmRhbnQoJ2Zvby5iYXInLCAnZm9vLmJhcicpICAgICAvLyBmYWxzZVxuICAgICAqIFBvbHltZXIuUGF0aC5pc0Rlc2NlbmRhbnQoJ2Zvby5iYXInLCAnZm9vJykgICAgICAgICAvLyBmYWxzZVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIFBvbHltZXIuUGF0aFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlIFBhdGggc3RyaW5nIHRvIHRlc3QgYWdhaW5zdC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBQYXRoIHN0cmluZyB0byB0ZXN0LlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYHBhdGhgIGlzIGEgZGVzY2VuZGFudCBvZiBgYmFzZWAuXG4gICAgICovXG4gICAgaXNEZXNjZW5kYW50OiBmdW5jdGlvbihiYXNlLCBwYXRoKSB7XG4gICAgICAvLyAgICAgcGF0aC5zdGFydHNXaXRoKGJhc2UgKyAnLicpO1xuICAgICAgcmV0dXJuIHBhdGguaW5kZXhPZihiYXNlICsgJy4nKSA9PT0gMDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVwbGFjZXMgYSBwcmV2aW91cyBiYXNlIHBhdGggd2l0aCBhIG5ldyBiYXNlIHBhdGgsIHByZXNlcnZpbmcgdGhlXG4gICAgICogcmVtYWluZGVyIG9mIHRoZSBwYXRoLlxuICAgICAqXG4gICAgICogVXNlciBtdXN0IGVuc3VyZSBgcGF0aGAgaGFzIGEgcHJlZml4IG9mIGBiYXNlYC5cbiAgICAgKlxuICAgICAqIEV4YW1wbGU6XG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiBQb2x5bWVyLlBhdGgudHJhbnNsYXRlKCdmb28uYmFyJywgJ3pvdCcgJ2Zvby5iYXIuYmF6JykgLy8gJ3pvdC5iYXonXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgUG9seW1lci5QYXRoXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGJhc2UgQ3VycmVudCBiYXNlIHN0cmluZyB0byByZW1vdmVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV3QmFzZSBOZXcgYmFzZSBzdHJpbmcgdG8gcmVwbGFjZSB3aXRoXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggUGF0aCB0byB0cmFuc2xhdGVcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRyYW5zbGF0ZWQgc3RyaW5nXG4gICAgICovXG4gICAgdHJhbnNsYXRlOiBmdW5jdGlvbihiYXNlLCBuZXdCYXNlLCBwYXRoKSB7XG4gICAgICByZXR1cm4gbmV3QmFzZSArIHBhdGguc2xpY2UoYmFzZS5sZW5ndGgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYmFzZSBQYXRoIHN0cmluZyB0byB0ZXN0IGFnYWluc3RcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBQYXRoIHN0cmluZyB0byB0ZXN0XG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBgcGF0aGAgaXMgZXF1YWwgdG8gYGJhc2VgXG4gICAgICogQHRoaXMge1BhdGh9XG4gICAgICovXG4gICAgbWF0Y2hlczogZnVuY3Rpb24oYmFzZSwgcGF0aCkge1xuICAgICAgcmV0dXJuIChiYXNlID09PSBwYXRoKSB8fFxuICAgICAgICAgICAgIHRoaXMuaXNBbmNlc3RvcihiYXNlLCBwYXRoKSB8fFxuICAgICAgICAgICAgIHRoaXMuaXNEZXNjZW5kYW50KGJhc2UsIHBhdGgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhcnJheS1iYXNlZCBwYXRocyB0byBmbGF0dGVuZWQgcGF0aC4gIFN0cmluZy1iYXNlZCBwYXRoc1xuICAgICAqIGFyZSByZXR1cm5lZCBhcy1pcy5cbiAgICAgKlxuICAgICAqIEV4YW1wbGU6XG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiBQb2x5bWVyLlBhdGgubm9ybWFsaXplKFsnZm9vLmJhcicsIDAsICdiYXonXSkgIC8vICdmb28uYmFyLjAuYmF6J1xuICAgICAqIFBvbHltZXIuUGF0aC5ub3JtYWxpemUoJ2Zvby5iYXIuMC5iYXonKSAgICAgICAgLy8gJ2Zvby5iYXIuMC5iYXonXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgUG9seW1lci5QYXRoXG4gICAgICogQHBhcmFtIHtzdHJpbmcgfCAhQXJyYXk8c3RyaW5nfG51bWJlcj59IHBhdGggSW5wdXQgcGF0aFxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gRmxhdHRlbmVkIHBhdGhcbiAgICAgKi9cbiAgICBub3JtYWxpemU6IGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhdGgpKSB7XG4gICAgICAgIGxldCBwYXJ0cyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8cGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGxldCBhcmdzID0gcGF0aFtpXS50b1N0cmluZygpLnNwbGl0KCcuJyk7XG4gICAgICAgICAgZm9yIChsZXQgaj0wOyBqPGFyZ3MubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIHBhcnRzLnB1c2goYXJnc1tqXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJ0cy5qb2luKCcuJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcGF0aDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU3BsaXRzIGEgcGF0aCBpbnRvIGFuIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLiBBY2NlcHRzIGVpdGhlciBhcnJheXNcbiAgICAgKiBvZiBwYXRoIHBhcnRzIG9yIHN0cmluZ3MuXG4gICAgICpcbiAgICAgKiBFeGFtcGxlOlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogUG9seW1lci5QYXRoLnNwbGl0KFsnZm9vLmJhcicsIDAsICdiYXonXSkgIC8vIFsnZm9vJywgJ2JhcicsICcwJywgJ2JheiddXG4gICAgICogUG9seW1lci5QYXRoLnNwbGl0KCdmb28uYmFyLjAuYmF6JykgICAgICAgIC8vIFsnZm9vJywgJ2JhcicsICcwJywgJ2JheiddXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgUG9seW1lci5QYXRoXG4gICAgICogQHBhcmFtIHtzdHJpbmcgfCAhQXJyYXk8c3RyaW5nfG51bWJlcj59IHBhdGggSW5wdXQgcGF0aFxuICAgICAqIEByZXR1cm4geyFBcnJheTxzdHJpbmc+fSBBcnJheSBvZiBwYXRoIHBhcnRzXG4gICAgICogQHRoaXMge1BhdGh9XG4gICAgICogQHN1cHByZXNzIHtjaGVja1R5cGVzfVxuICAgICAqL1xuICAgIHNwbGl0OiBmdW5jdGlvbihwYXRoKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXRoKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5ub3JtYWxpemUocGF0aCkuc3BsaXQoJy4nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXRoLnRvU3RyaW5nKCkuc3BsaXQoJy4nKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVhZHMgYSB2YWx1ZSBmcm9tIGEgcGF0aC4gIElmIGFueSBzdWItcHJvcGVydHkgaW4gdGhlIHBhdGggaXMgYHVuZGVmaW5lZGAsXG4gICAgICogdGhpcyBtZXRob2QgcmV0dXJucyBgdW5kZWZpbmVkYCAod2lsbCBuZXZlciB0aHJvdy5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBQb2x5bWVyLlBhdGhcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcm9vdCBPYmplY3QgZnJvbSB3aGljaCB0byBkZXJlZmVyZW5jZSBwYXRoIGZyb21cbiAgICAgKiBAcGFyYW0ge3N0cmluZyB8ICFBcnJheTxzdHJpbmd8bnVtYmVyPn0gcGF0aCBQYXRoIHRvIHJlYWRcbiAgICAgKiBAcGFyYW0ge09iamVjdD19IGluZm8gSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIHRvIGBpbmZvYCwgdGhlIG5vcm1hbGl6ZWRcbiAgICAgKiAgKGZsYXR0ZW5lZCkgcGF0aCB3aWxsIGJlIHNldCB0byBgaW5mby5wYXRoYC5cbiAgICAgKiBAcmV0dXJuIHsqfSBWYWx1ZSBhdCBwYXRoLCBvciBgdW5kZWZpbmVkYCBpZiB0aGUgcGF0aCBjb3VsZCBub3QgYmVcbiAgICAgKiAgZnVsbHkgZGVyZWZlcmVuY2VkLlxuICAgICAqIEB0aGlzIHtQYXRofVxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24ocm9vdCwgcGF0aCwgaW5mbykge1xuICAgICAgbGV0IHByb3AgPSByb290O1xuICAgICAgbGV0IHBhcnRzID0gdGhpcy5zcGxpdChwYXRoKTtcbiAgICAgIC8vIExvb3Agb3ZlciBwYXRoIHBhcnRzWzAuLm4tMV0gYW5kIGRlcmVmZXJlbmNlXG4gICAgICBmb3IgKGxldCBpPTA7IGk8cGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCFwcm9wKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwYXJ0ID0gcGFydHNbaV07XG4gICAgICAgIHByb3AgPSBwcm9wW3BhcnRdO1xuICAgICAgfVxuICAgICAgaWYgKGluZm8pIHtcbiAgICAgICAgaW5mby5wYXRoID0gcGFydHMuam9pbignLicpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHByb3A7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgYSB2YWx1ZSB0byBhIHBhdGguICBJZiBhbnkgc3ViLXByb3BlcnR5IGluIHRoZSBwYXRoIGlzIGB1bmRlZmluZWRgLFxuICAgICAqIHRoaXMgbWV0aG9kIHdpbGwgbm8tb3AuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgUG9seW1lci5QYXRoXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJvb3QgT2JqZWN0IGZyb20gd2hpY2ggdG8gZGVyZWZlcmVuY2UgcGF0aCBmcm9tXG4gICAgICogQHBhcmFtIHtzdHJpbmcgfCAhQXJyYXk8c3RyaW5nfG51bWJlcj59IHBhdGggUGF0aCB0byBzZXRcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIHNldCB0byBwYXRoXG4gICAgICogQHJldHVybiB7c3RyaW5nIHwgdW5kZWZpbmVkfSBUaGUgbm9ybWFsaXplZCB2ZXJzaW9uIG9mIHRoZSBpbnB1dCBwYXRoXG4gICAgICogQHRoaXMge1BhdGh9XG4gICAgICovXG4gICAgc2V0OiBmdW5jdGlvbihyb290LCBwYXRoLCB2YWx1ZSkge1xuICAgICAgbGV0IHByb3AgPSByb290O1xuICAgICAgbGV0IHBhcnRzID0gdGhpcy5zcGxpdChwYXRoKTtcbiAgICAgIGxldCBsYXN0ID0gcGFydHNbcGFydHMubGVuZ3RoLTFdO1xuICAgICAgaWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgLy8gTG9vcCBvdmVyIHBhdGggcGFydHNbMC4ubi0yXSBhbmQgZGVyZWZlcmVuY2VcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPHBhcnRzLmxlbmd0aC0xOyBpKyspIHtcbiAgICAgICAgICBsZXQgcGFydCA9IHBhcnRzW2ldO1xuICAgICAgICAgIHByb3AgPSBwcm9wW3BhcnRdO1xuICAgICAgICAgIGlmICghcHJvcCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBTZXQgdmFsdWUgdG8gb2JqZWN0IGF0IGVuZCBvZiBwYXRoXG4gICAgICAgIHByb3BbbGFzdF0gPSB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFNpbXBsZSBwcm9wZXJ0eSBzZXRcbiAgICAgICAgcHJvcFtwYXRoXSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcnRzLmpvaW4oJy4nKTtcbiAgICB9XG5cbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBzdHJpbmcgaXMgYSBzdHJ1Y3R1cmVkIGRhdGEgcGF0aCAoaGFzIGRvdHMpLlxuICAgKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGRlcHJlY2F0ZWQuICBVc2UgYFBvbHltZXIuUGF0aC5pc1BhdGhgIGluc3RlYWQuXG4gICAqXG4gICAqIEV4YW1wbGU6XG4gICAqXG4gICAqIGBgYFxuICAgKiBQb2x5bWVyLlBhdGguaXNEZWVwKCdmb28uYmFyLmJheicpIC8vIHRydWVcbiAgICogUG9seW1lci5QYXRoLmlzRGVlcCgnZm9vJykgICAgICAgICAvLyBmYWxzZVxuICAgKiBgYGBcbiAgICpcbiAgICogQGRlcHJlY2F0ZWRcbiAgICogQG1lbWJlcm9mIFBvbHltZXIuUGF0aFxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBQYXRoIHN0cmluZ1xuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBzdHJpbmcgY29udGFpbmVkIG9uZSBvciBtb3JlIGRvdHNcbiAgICovXG4gIFBhdGguaXNEZWVwID0gUGF0aC5pc1BhdGg7XG5cbiAgUG9seW1lci5QYXRoID0gUGF0aDtcblxufSkoKTtcbjwvc2NyaXB0PlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi91dGlscy9wYXRoLmh0bWwiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi91dGlscy9ib290Lmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi91dGlscy9taXhpbi5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vdXRpbHMvY2FzZS1tYXAuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3V0aWxzL2FzeW5jLmh0bWxcIj5cblxuPHNjcmlwdD5cbihmdW5jdGlvbigpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgbGV0IGNhc2VNYXAgPSBQb2x5bWVyLkNhc2VNYXA7XG5cbiAgbGV0IG1pY3JvdGFzayA9IFBvbHltZXIuQXN5bmMubWljcm9UYXNrO1xuXG4gIC8vIFNhdmUgbWFwIG9mIG5hdGl2ZSBwcm9wZXJ0aWVzOyB0aGlzIGZvcm1zIGEgYmxhY2tsaXN0IG9yIHByb3BlcnRpZXNcbiAgLy8gdGhhdCB3b24ndCBoYXZlIHRoZWlyIHZhbHVlcyBcInNhdmVkXCIgYnkgYHNhdmVBY2Nlc3NvclZhbHVlYCwgc2luY2VcbiAgLy8gcmVhZGluZyBmcm9tIGFuIEhUTUxFbGVtZW50IGFjY2Vzc29yIGZyb20gdGhlIGNvbnRleHQgb2YgYSBwcm90b3R5cGUgdGhyb3dzXG4gIGNvbnN0IG5hdGl2ZVByb3BlcnRpZXMgPSB7fTtcbiAgbGV0IHByb3RvID0gSFRNTEVsZW1lbnQucHJvdG90eXBlO1xuICB3aGlsZSAocHJvdG8pIHtcbiAgICBsZXQgcHJvcHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhwcm90byk7XG4gICAgZm9yIChsZXQgaT0wOyBpPHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBuYXRpdmVQcm9wZXJ0aWVzW3Byb3BzW2ldXSA9IHRydWU7XG4gICAgfVxuICAgIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIHRvIHNhdmUgdGhlIHZhbHVlIG9mIGEgcHJvcGVydHkgdGhhdCB3aWxsIGJlIG92ZXJyaWRkZW4gd2l0aFxuICAgKiBhbiBhY2Nlc3Nvci4gSWYgdGhlIGBtb2RlbGAgaXMgYSBwcm90b3R5cGUsIHRoZSB2YWx1ZXMgd2lsbCBiZSBzYXZlZFxuICAgKiBpbiBgX19kYXRhUHJvdG9gLCBhbmQgaXQncyB1cCB0byB0aGUgdXNlciAob3IgZG93bnN0cmVhbSBtaXhpbikgdG9cbiAgICogZGVjaWRlIGhvdy93aGVuIHRvIHNldCB0aGVzZSB2YWx1ZXMgYmFjayBpbnRvIHRoZSBhY2Nlc3NvcnMuXG4gICAqIElmIGBtb2RlbGAgaXMgYWxyZWFkeSBhbiBpbnN0YW5jZSAoaXQgaGFzIGEgYF9fZGF0YWAgcHJvcGVydHkpLCB0aGVuXG4gICAqIHRoZSB2YWx1ZSB3aWxsIGJlIHNldCBhcyBhIHBlbmRpbmcgcHJvcGVydHksIG1lYW5pbmcgdGhlIHVzZXIgc2hvdWxkXG4gICAqIGNhbGwgYF9pbnZhbGlkYXRlUHJvcGVydGllc2Agb3IgYF9mbHVzaFByb3BlcnRpZXNgIHRvIHRha2UgZWZmZWN0XG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBtb2RlbCBQcm90b3R5cGUgb3IgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IE5hbWUgb2YgcHJvcGVydHlcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIHNhdmVBY2Nlc3NvclZhbHVlKG1vZGVsLCBwcm9wZXJ0eSkge1xuICAgIC8vIERvbid0IHJlYWQvc3RvcmUgdmFsdWUgZm9yIGFueSBuYXRpdmUgcHJvcGVydGllcyBzaW5jZSB0aGV5IGNvdWxkIHRocm93XG4gICAgaWYgKCFuYXRpdmVQcm9wZXJ0aWVzW3Byb3BlcnR5XSkge1xuICAgICAgbGV0IHZhbHVlID0gbW9kZWxbcHJvcGVydHldO1xuICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKG1vZGVsLl9fZGF0YSkge1xuICAgICAgICAgIC8vIEFkZGluZyBhY2Nlc3NvciB0byBpbnN0YW5jZTsgdXBkYXRlIHRoZSBwcm9wZXJ0eVxuICAgICAgICAgIC8vIEl0IGlzIHRoZSB1c2VyJ3MgcmVzcG9uc2liaWxpdHkgdG8gY2FsbCBfZmx1c2hQcm9wZXJ0aWVzXG4gICAgICAgICAgbW9kZWwuX3NldFBlbmRpbmdQcm9wZXJ0eShwcm9wZXJ0eSwgdmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEFkZGluZyBhY2Nlc3NvciB0byBwcm90bzsgc2F2ZSBwcm90bydzIHZhbHVlIGZvciBpbnN0YW5jZS10aW1lIHVzZVxuICAgICAgICAgIGlmICghbW9kZWwuX19kYXRhUHJvdG8pIHtcbiAgICAgICAgICAgIG1vZGVsLl9fZGF0YVByb3RvID0ge307XG4gICAgICAgICAgfSBlbHNlIGlmICghbW9kZWwuaGFzT3duUHJvcGVydHkoSlNDb21waWxlcl9yZW5hbWVQcm9wZXJ0eSgnX19kYXRhUHJvdG8nLCBtb2RlbCkpKSB7XG4gICAgICAgICAgICBtb2RlbC5fX2RhdGFQcm90byA9IE9iamVjdC5jcmVhdGUobW9kZWwuX19kYXRhUHJvdG8pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtb2RlbC5fX2RhdGFQcm90b1twcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBFbGVtZW50IGNsYXNzIG1peGluIHRoYXQgcHJvdmlkZXMgYmFzaWMgbWV0YS1wcm9ncmFtbWluZyBmb3IgY3JlYXRpbmcgb25lXG4gICAqIG9yIG1vcmUgcHJvcGVydHkgYWNjZXNzb3JzIChnZXR0ZXIvc2V0dGVyIHBhaXIpIHRoYXQgZW5xdWV1ZSBhbiBhc3luY1xuICAgKiAoYmF0Y2hlZCkgYF9wcm9wZXJ0aWVzQ2hhbmdlZGAgY2FsbGJhY2suXG4gICAqXG4gICAqIEZvciBiYXNpYyB1c2FnZSBvZiB0aGlzIG1peGluLCBzaW1wbHkgZGVjbGFyZSBhdHRyaWJ1dGVzIHRvIG9ic2VydmUgdmlhXG4gICAqIHRoZSBzdGFuZGFyZCBgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKWAsIGltcGxlbWVudCBgX3Byb3BlcnRpZXNDaGFuZ2VkYFxuICAgKiBvbiB0aGUgY2xhc3MsIGFuZCB0aGVuIGNhbGwgYE15Q2xhc3MuY3JlYXRlUHJvcGVydGllc0ZvckF0dHJpYnV0ZXMoKWAgb25jZVxuICAgKiBvbiB0aGUgY2xhc3MgdG8gZ2VuZXJhdGUgcHJvcGVydHkgYWNjZXNzb3JzIGZvciBlYWNoIG9ic2VydmVkIGF0dHJpYnV0ZVxuICAgKiBwcmlvciB0byBpbnN0YW5jaW5nLiAgTGFzdCwgY2FsbCBgdGhpcy5fZmx1c2hQcm9wZXJ0aWVzKClgIG9uY2UgdG8gZW5hYmxlXG4gICAqIHRoZSBhY2Nlc3NvcnMuXG4gICAqXG4gICAqIEFueSBgb2JzZXJ2ZWRBdHRyaWJ1dGVzYCB3aWxsIGF1dG9tYXRpY2FsbHkgYmVcbiAgICogZGVzZXJpYWxpemVkIHZpYSBgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrYCBhbmQgc2V0IHRvIHRoZSBhc3NvY2lhdGVkXG4gICAqIHByb3BlcnR5IHVzaW5nIGBkYXNoLWNhc2VgLXRvLWBjYW1lbENhc2VgIGNvbnZlbnRpb24uXG4gICAqXG4gICAqIEBtaXhpbkZ1bmN0aW9uXG4gICAqIEBwb2x5bWVyXG4gICAqIEBtZW1iZXJvZiBQb2x5bWVyXG4gICAqIEBzdW1tYXJ5IEVsZW1lbnQgY2xhc3MgbWl4aW4gZm9yIHJlYWN0aW5nIHRvIHByb3BlcnR5IGNoYW5nZXMgZnJvbVxuICAgKiAgIGdlbmVyYXRlZCBwcm9wZXJ0eSBhY2Nlc3NvcnMuXG4gICAqL1xuICBQb2x5bWVyLlByb3BlcnR5QWNjZXNzb3JzID0gUG9seW1lci5kZWR1cGluZ01peGluKHN1cGVyQ2xhc3MgPT4ge1xuXG4gICAgLyoqXG4gICAgICogQHBvbHltZXJcbiAgICAgKiBAbWl4aW5DbGFzc1xuICAgICAqIEBpbXBsZW1lbnRzIHtQb2x5bWVyX1Byb3BlcnR5QWNjZXNzb3JzfVxuICAgICAqIEBleHRlbmRzIEhUTUxFbGVtZW50XG4gICAgICogQHVucmVzdHJpY3RlZFxuICAgICAqL1xuICAgIGNsYXNzIFByb3BlcnR5QWNjZXNzb3JzIGV4dGVuZHMgc3VwZXJDbGFzcyB7XG5cbiAgICAgIC8qKlxuICAgICAgICogR2VuZXJhdGVzIHByb3BlcnR5IGFjY2Vzc29ycyBmb3IgYWxsIGF0dHJpYnV0ZXMgaW4gdGhlIHN0YW5kYXJkXG4gICAgICAgKiBzdGF0aWMgYG9ic2VydmVkQXR0cmlidXRlc2AgYXJyYXkuXG4gICAgICAgKlxuICAgICAgICogQXR0cmlidXRlIG5hbWVzIGFyZSBtYXBwZWQgdG8gcHJvcGVydHkgbmFtZXMgdXNpbmcgdGhlIGBkYXNoLWNhc2VgIHRvXG4gICAgICAgKiBgY2FtZWxDYXNlYCBjb252ZW50aW9uXG4gICAgICAgKlxuICAgICAgICovXG4gICAgICBzdGF0aWMgY3JlYXRlUHJvcGVydGllc0ZvckF0dHJpYnV0ZXMoKSB7XG4gICAgICAgIGxldCBhJCA9IHRoaXMub2JzZXJ2ZWRBdHRyaWJ1dGVzO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGkgPCBhJC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHRoaXMucHJvdG90eXBlLl9jcmVhdGVQcm9wZXJ0eUFjY2Vzc29yKGNhc2VNYXAuZGFzaFRvQ2FtZWxDYXNlKGEkW2ldKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cbiAgICAgICAgdGhpcy5fX3NlcmlhbGl6aW5nO1xuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy5fX2RhdGFDb3VudGVyO1xuICAgICAgICAvKiogQHR5cGUge2Jvb2xlYW59ICovXG4gICAgICAgIHRoaXMuX19kYXRhRW5hYmxlZDtcbiAgICAgICAgLyoqIEB0eXBlIHtib29sZWFufSAqL1xuICAgICAgICB0aGlzLl9fZGF0YVJlYWR5O1xuICAgICAgICAvKiogQHR5cGUge2Jvb2xlYW59ICovXG4gICAgICAgIHRoaXMuX19kYXRhSW52YWxpZDtcbiAgICAgICAgLyoqIEB0eXBlIHshT2JqZWN0fSAqL1xuICAgICAgICB0aGlzLl9fZGF0YTtcbiAgICAgICAgLyoqIEB0eXBlIHtPYmplY3R9ICovXG4gICAgICAgIHRoaXMuX19kYXRhUGVuZGluZztcbiAgICAgICAgLyoqIEB0eXBlIHtPYmplY3R9ICovXG4gICAgICAgIHRoaXMuX19kYXRhT2xkO1xuICAgICAgICAvKiogQHR5cGUge09iamVjdH0gKi9cbiAgICAgICAgdGhpcy5fX2RhdGFQcm90bztcbiAgICAgICAgLyoqIEB0eXBlIHtPYmplY3R9ICovXG4gICAgICAgIHRoaXMuX19kYXRhSGFzQWNjZXNzb3I7XG4gICAgICAgIC8qKiBAdHlwZSB7T2JqZWN0fSAqL1xuICAgICAgICB0aGlzLl9fZGF0YUluc3RhbmNlUHJvcHM7XG4gICAgICAgIHRoaXMuX2luaXRpYWxpemVQcm9wZXJ0aWVzKCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogSW1wbGVtZW50cyBuYXRpdmUgQ3VzdG9tIEVsZW1lbnRzIGBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2tgIHRvXG4gICAgICAgKiBzZXQgYW4gYXR0cmlidXRlIHZhbHVlIHRvIGEgcHJvcGVydHkgdmlhIGBfYXR0cmlidXRlVG9Qcm9wZXJ0eWAuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgTmFtZSBvZiBhdHRyaWJ1dGUgdGhhdCBjaGFuZ2VkXG4gICAgICAgKiBAcGFyYW0gez9zdHJpbmd9IG9sZCBPbGQgYXR0cmlidXRlIHZhbHVlXG4gICAgICAgKiBAcGFyYW0gez9zdHJpbmd9IHZhbHVlIE5ldyBhdHRyaWJ1dGUgdmFsdWVcbiAgICAgICAqL1xuICAgICAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIG9sZCwgdmFsdWUpIHtcbiAgICAgICAgaWYgKG9sZCAhPT0gdmFsdWUpIHtcbiAgICAgICAgICB0aGlzLl9hdHRyaWJ1dGVUb1Byb3BlcnR5KG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEluaXRpYWxpemVzIHRoZSBsb2NhbCBzdG9yYWdlIGZvciBwcm9wZXJ0eSBhY2Nlc3NvcnMuXG4gICAgICAgKlxuICAgICAgICogUHJvdmlkZWQgYXMgYW4gb3ZlcnJpZGUgcG9pbnQgZm9yIHBlcmZvcm1pbmcgYW55IHNldHVwIHdvcmsgcHJpb3JcbiAgICAgICAqIHRvIGluaXRpYWxpemluZyB0aGUgcHJvcGVydHkgYWNjZXNzb3Igc3lzdGVtLlxuICAgICAgICpcbiAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAqL1xuICAgICAgX2luaXRpYWxpemVQcm9wZXJ0aWVzKCkge1xuICAgICAgICB0aGlzLl9fc2VyaWFsaXppbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fX2RhdGFDb3VudGVyID0gMDtcbiAgICAgICAgdGhpcy5fX2RhdGFFbmFibGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX19kYXRhUmVhZHkgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fX2RhdGFJbnZhbGlkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX19kYXRhID0ge307XG4gICAgICAgIHRoaXMuX19kYXRhUGVuZGluZyA9IG51bGw7XG4gICAgICAgIHRoaXMuX19kYXRhT2xkID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuX19kYXRhUHJvdG8pIHtcbiAgICAgICAgICB0aGlzLl9pbml0aWFsaXplUHJvdG9Qcm9wZXJ0aWVzKHRoaXMuX19kYXRhUHJvdG8pO1xuICAgICAgICAgIHRoaXMuX19kYXRhUHJvdG8gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIENhcHR1cmUgaW5zdGFuY2UgcHJvcGVydGllczsgdGhlc2Ugd2lsbCBiZSBzZXQgaW50byBhY2Nlc3NvcnNcbiAgICAgICAgLy8gZHVyaW5nIGZpcnN0IGZsdXNoLiBEb24ndCBzZXQgdGhlbSBoZXJlLCBzaW5jZSB3ZSB3YW50XG4gICAgICAgIC8vIHRoZXNlIHRvIG92ZXJ3cml0ZSBkZWZhdWx0cy9jb25zdHJ1Y3RvciBhc3NpZ25tZW50c1xuICAgICAgICBmb3IgKGxldCBwIGluIHRoaXMuX19kYXRhSGFzQWNjZXNzb3IpIHtcbiAgICAgICAgICBpZiAodGhpcy5oYXNPd25Qcm9wZXJ0eShwKSkge1xuICAgICAgICAgICAgdGhpcy5fX2RhdGFJbnN0YW5jZVByb3BzID0gdGhpcy5fX2RhdGFJbnN0YW5jZVByb3BzIHx8IHt9O1xuICAgICAgICAgICAgdGhpcy5fX2RhdGFJbnN0YW5jZVByb3BzW3BdID0gdGhpc1twXTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzW3BdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENhbGxlZCBhdCBpbnN0YW5jZSB0aW1lIHdpdGggYmFnIG9mIHByb3BlcnRpZXMgdGhhdCB3ZXJlIG92ZXJ3cml0dGVuXG4gICAgICAgKiBieSBhY2Nlc3NvcnMgb24gdGhlIHByb3RvdHlwZSB3aGVuIGFjY2Vzc29ycyB3ZXJlIGNyZWF0ZWQuXG4gICAgICAgKlxuICAgICAgICogVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gc2V0cyB0aGVzZSBwcm9wZXJ0aWVzIGJhY2sgaW50byB0aGVcbiAgICAgICAqIHNldHRlciBhdCBpbnN0YW5jZSB0aW1lLiAgVGhpcyBtZXRob2QgaXMgcHJvdmlkZWQgYXMgYW4gb3ZlcnJpZGVcbiAgICAgICAqIHBvaW50IGZvciBjdXN0b21pemluZyBvciBwcm92aWRpbmcgbW9yZSBlZmZpY2llbnQgaW5pdGlhbGl6YXRpb24uXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzIEJhZyBvZiBwcm9wZXJ0eSB2YWx1ZXMgdGhhdCB3ZXJlIG92ZXJ3cml0dGVuXG4gICAgICAgKiAgIHdoZW4gY3JlYXRpbmcgcHJvcGVydHkgYWNjZXNzb3JzLlxuICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICovXG4gICAgICBfaW5pdGlhbGl6ZVByb3RvUHJvcGVydGllcyhwcm9wcykge1xuICAgICAgICBmb3IgKGxldCBwIGluIHByb3BzKSB7XG4gICAgICAgICAgdGhpcy5fc2V0UHJvcGVydHkocCwgcHJvcHNbcF0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ2FsbGVkIGF0IHJlYWR5IHRpbWUgd2l0aCBiYWcgb2YgaW5zdGFuY2UgcHJvcGVydGllcyB0aGF0IG92ZXJ3cm90ZVxuICAgICAgICogYWNjZXNzb3JzIHdoZW4gdGhlIGVsZW1lbnQgdXBncmFkZWQuXG4gICAgICAgKlxuICAgICAgICogVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gc2V0cyB0aGVzZSBwcm9wZXJ0aWVzIGJhY2sgaW50byB0aGVcbiAgICAgICAqIHNldHRlciBhdCByZWFkeSB0aW1lLiAgVGhpcyBtZXRob2QgaXMgcHJvdmlkZWQgYXMgYW4gb3ZlcnJpZGVcbiAgICAgICAqIHBvaW50IGZvciBjdXN0b21pemluZyBvciBwcm92aWRpbmcgbW9yZSBlZmZpY2llbnQgaW5pdGlhbGl6YXRpb24uXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzIEJhZyBvZiBwcm9wZXJ0eSB2YWx1ZXMgdGhhdCB3ZXJlIG92ZXJ3cml0dGVuXG4gICAgICAgKiAgIHdoZW4gY3JlYXRpbmcgcHJvcGVydHkgYWNjZXNzb3JzLlxuICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICovXG4gICAgICBfaW5pdGlhbGl6ZUluc3RhbmNlUHJvcGVydGllcyhwcm9wcykge1xuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMsIHByb3BzKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBFbnN1cmVzIHRoZSBlbGVtZW50IGhhcyB0aGUgZ2l2ZW4gYXR0cmlidXRlLiBJZiBpdCBkb2VzIG5vdCxcbiAgICAgICAqIGFzc2lnbnMgdGhlIGdpdmVuIHZhbHVlIHRvIHRoZSBhdHRyaWJ1dGUuXG4gICAgICAgKlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGUgTmFtZSBvZiBhdHRyaWJ1dGUgdG8gZW5zdXJlIGlzIHNldC5cbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSBvZiB0aGUgYXR0cmlidXRlLlxuICAgICAgICovXG4gICAgICBfZW5zdXJlQXR0cmlidXRlKGF0dHJpYnV0ZSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhc0F0dHJpYnV0ZShhdHRyaWJ1dGUpKSB7XG4gICAgICAgICAgdGhpcy5fdmFsdWVUb05vZGVBdHRyaWJ1dGUodGhpcywgdmFsdWUsIGF0dHJpYnV0ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBEZXNlcmlhbGl6ZXMgYW4gYXR0cmlidXRlIHRvIGl0cyBhc3NvY2lhdGVkIHByb3BlcnR5LlxuICAgICAgICpcbiAgICAgICAqIFRoaXMgbWV0aG9kIGNhbGxzIHRoZSBgX2Rlc2VyaWFsaXplVmFsdWVgIG1ldGhvZCB0byBjb252ZXJ0IHRoZSBzdHJpbmcgdG9cbiAgICAgICAqIGEgdHlwZWQgdmFsdWUuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGF0dHJpYnV0ZSBOYW1lIG9mIGF0dHJpYnV0ZSB0byBkZXNlcmlhbGl6ZS5cbiAgICAgICAqIEBwYXJhbSB7P3N0cmluZ30gdmFsdWUgb2YgdGhlIGF0dHJpYnV0ZS5cbiAgICAgICAqIEBwYXJhbSB7Kj19IHR5cGUgdHlwZSB0byBkZXNlcmlhbGl6ZSB0by5cbiAgICAgICAqL1xuICAgICAgX2F0dHJpYnV0ZVRvUHJvcGVydHkoYXR0cmlidXRlLCB2YWx1ZSwgdHlwZSkge1xuICAgICAgICAvLyBEb24ndCBkZXNlcmlhbGl6ZSBiYWNrIHRvIHByb3BlcnR5IGlmIGN1cnJlbnRseSByZWZsZWN0aW5nXG4gICAgICAgIGlmICghdGhpcy5fX3NlcmlhbGl6aW5nKSB7XG4gICAgICAgICAgbGV0IHByb3BlcnR5ID0gY2FzZU1hcC5kYXNoVG9DYW1lbENhc2UoYXR0cmlidXRlKTtcbiAgICAgICAgICB0aGlzW3Byb3BlcnR5XSA9IHRoaXMuX2Rlc2VyaWFsaXplVmFsdWUodmFsdWUsIHR5cGUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogU2VyaWFsaXplcyBhIHByb3BlcnR5IHRvIGl0cyBhc3NvY2lhdGVkIGF0dHJpYnV0ZS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgbmFtZSB0byByZWZsZWN0LlxuICAgICAgICogQHBhcmFtIHtzdHJpbmc9fSBhdHRyaWJ1dGUgQXR0cmlidXRlIG5hbWUgdG8gcmVmbGVjdC5cbiAgICAgICAqIEBwYXJhbSB7Kj19IHZhbHVlIFByb3BlcnR5IHZhbHVlIHRvIHJlZmVjdC5cbiAgICAgICAqL1xuICAgICAgX3Byb3BlcnR5VG9BdHRyaWJ1dGUocHJvcGVydHksIGF0dHJpYnV0ZSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5fX3NlcmlhbGl6aW5nID0gdHJ1ZTtcbiAgICAgICAgdmFsdWUgPSAoYXJndW1lbnRzLmxlbmd0aCA8IDMpID8gdGhpc1twcm9wZXJ0eV0gOiB2YWx1ZTtcbiAgICAgICAgdGhpcy5fdmFsdWVUb05vZGVBdHRyaWJ1dGUodGhpcywgdmFsdWUsXG4gICAgICAgICAgYXR0cmlidXRlIHx8IGNhc2VNYXAuY2FtZWxUb0Rhc2hDYXNlKHByb3BlcnR5KSk7XG4gICAgICAgIHRoaXMuX19zZXJpYWxpemluZyA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFNldHMgYSB0eXBlZCB2YWx1ZSB0byBhbiBIVE1MIGF0dHJpYnV0ZSBvbiBhIG5vZGUuXG4gICAgICAgKlxuICAgICAgICogVGhpcyBtZXRob2QgY2FsbHMgdGhlIGBfc2VyaWFsaXplVmFsdWVgIG1ldGhvZCB0byBjb252ZXJ0IHRoZSB0eXBlZFxuICAgICAgICogdmFsdWUgdG8gYSBzdHJpbmcuICBJZiB0aGUgYF9zZXJpYWxpemVWYWx1ZWAgbWV0aG9kIHJldHVybnMgYHVuZGVmaW5lZGAsXG4gICAgICAgKiB0aGUgYXR0cmlidXRlIHdpbGwgYmUgcmVtb3ZlZCAodGhpcyBpcyB0aGUgZGVmYXVsdCBmb3IgYm9vbGVhblxuICAgICAgICogdHlwZSBgZmFsc2VgKS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgRWxlbWVudCB0byBzZXQgYXR0cmlidXRlIHRvLlxuICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byBzZXJpYWxpemUuXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlIEF0dHJpYnV0ZSBuYW1lIHRvIHNlcmlhbGl6ZSB0by5cbiAgICAgICAqL1xuICAgICAgX3ZhbHVlVG9Ob2RlQXR0cmlidXRlKG5vZGUsIHZhbHVlLCBhdHRyaWJ1dGUpIHtcbiAgICAgICAgbGV0IHN0ciA9IHRoaXMuX3NlcmlhbGl6ZVZhbHVlKHZhbHVlKTtcbiAgICAgICAgaWYgKHN0ciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUoYXR0cmlidXRlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShhdHRyaWJ1dGUsIHN0cik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDb252ZXJ0cyBhIHR5cGVkIEphdmFTY3JpcHQgdmFsdWUgdG8gYSBzdHJpbmcuXG4gICAgICAgKlxuICAgICAgICogVGhpcyBtZXRob2QgaXMgY2FsbGVkIGJ5IFBvbHltZXIgd2hlbiBzZXR0aW5nIEpTIHByb3BlcnR5IHZhbHVlcyB0b1xuICAgICAgICogSFRNTCBhdHRyaWJ1dGVzLiAgVXNlcnMgbWF5IG92ZXJyaWRlIHRoaXMgbWV0aG9kIG9uIFBvbHltZXIgZWxlbWVudFxuICAgICAgICogcHJvdG90eXBlcyB0byBwcm92aWRlIHNlcmlhbGl6YXRpb24gZm9yIGN1c3RvbSB0eXBlcy5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFByb3BlcnR5IHZhbHVlIHRvIHNlcmlhbGl6ZS5cbiAgICAgICAqIEByZXR1cm4ge3N0cmluZyB8IHVuZGVmaW5lZH0gU3RyaW5nIHNlcmlhbGl6ZWQgZnJvbSB0aGUgcHJvdmlkZWQgcHJvcGVydHkgdmFsdWUuXG4gICAgICAgKi9cbiAgICAgIF9zZXJpYWxpemVWYWx1ZSh2YWx1ZSkge1xuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1mYWxsdGhyb3VnaCAqL1xuICAgICAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlID8gJycgOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICAgICAgICAgICAgICB9IGNhdGNoKHgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgIT0gbnVsbCA/IHZhbHVlLnRvU3RyaW5nKCkgOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDb252ZXJ0cyBhIHN0cmluZyB0byBhIHR5cGVkIEphdmFTY3JpcHQgdmFsdWUuXG4gICAgICAgKlxuICAgICAgICogVGhpcyBtZXRob2QgaXMgY2FsbGVkIGJ5IFBvbHltZXIgd2hlbiByZWFkaW5nIEhUTUwgYXR0cmlidXRlIHZhbHVlcyB0b1xuICAgICAgICogSlMgcHJvcGVydGllcy4gIFVzZXJzIG1heSBvdmVycmlkZSB0aGlzIG1ldGhvZCBvbiBQb2x5bWVyIGVsZW1lbnRcbiAgICAgICAqIHByb3RvdHlwZXMgdG8gcHJvdmlkZSBkZXNlcmlhbGl6YXRpb24gZm9yIGN1c3RvbSBgdHlwZWBzLiAgTm90ZSxcbiAgICAgICAqIHRoZSBgdHlwZWAgYXJndW1lbnQgaXMgdGhlIHZhbHVlIG9mIHRoZSBgdHlwZWAgZmllbGQgcHJvdmlkZWQgaW4gdGhlXG4gICAgICAgKiBgcHJvcGVydGllc2AgY29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGEgZ2l2ZW4gcHJvcGVydHksIGFuZCBpc1xuICAgICAgICogYnkgY29udmVudGlvbiB0aGUgY29uc3RydWN0b3IgZm9yIHRoZSB0eXBlIHRvIGRlc2VyaWFsaXplLlxuICAgICAgICpcbiAgICAgICAqIE5vdGU6IFRoZSByZXR1cm4gdmFsdWUgb2YgYHVuZGVmaW5lZGAgaXMgdXNlZCBhcyBhIHNlbnRpbmVsIHZhbHVlIHRvXG4gICAgICAgKiBpbmRpY2F0ZSB0aGUgYXR0cmlidXRlIHNob3VsZCBiZSByZW1vdmVkLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7P3N0cmluZ30gdmFsdWUgQXR0cmlidXRlIHZhbHVlIHRvIGRlc2VyaWFsaXplLlxuICAgICAgICogQHBhcmFtIHsqPX0gdHlwZSBUeXBlIHRvIGRlc2VyaWFsaXplIHRoZSBzdHJpbmcgdG8uXG4gICAgICAgKiBAcmV0dXJuIHsqfSBUeXBlZCB2YWx1ZSBkZXNlcmlhbGl6ZWQgZnJvbSB0aGUgcHJvdmlkZWQgc3RyaW5nLlxuICAgICAgICovXG4gICAgICBfZGVzZXJpYWxpemVWYWx1ZSh2YWx1ZSwgdHlwZSkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUgeyp9XG4gICAgICAgICAqL1xuICAgICAgICBsZXQgb3V0VmFsdWU7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgIGNhc2UgTnVtYmVyOlxuICAgICAgICAgICAgb3V0VmFsdWUgPSBOdW1iZXIodmFsdWUpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIEJvb2xlYW46XG4gICAgICAgICAgICBvdXRWYWx1ZSA9ICh2YWx1ZSAhPT0gbnVsbCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgT2JqZWN0OlxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgb3V0VmFsdWUgPSBKU09OLnBhcnNlKC8qKiBAdHlwZSBzdHJpbmcgKi8odmFsdWUpKTtcbiAgICAgICAgICAgIH0gY2F0Y2goeCkge1xuICAgICAgICAgICAgICAvLyBhbGxvdyBub24tSlNPTiBsaXRlcmFscyBsaWtlIFN0cmluZ3MgYW5kIE51bWJlcnNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBBcnJheTpcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIG91dFZhbHVlID0gSlNPTi5wYXJzZSgvKiogQHR5cGUgc3RyaW5nICovKHZhbHVlKSk7XG4gICAgICAgICAgICB9IGNhdGNoKHgpIHtcbiAgICAgICAgICAgICAgb3V0VmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYFBvbHltZXI6OkF0dHJpYnV0ZXM6IGNvdWxkbid0IGRlY29kZSBBcnJheSBhcyBKU09OOiAke3ZhbHVlfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIERhdGU6XG4gICAgICAgICAgICBvdXRWYWx1ZSA9IG5ldyBEYXRlKHZhbHVlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBTdHJpbmc6XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIG91dFZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvdXRWYWx1ZTtcbiAgICAgIH1cbiAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tZmFsbHRocm91Z2ggKi9cblxuICAgICAgLyoqXG4gICAgICAgKiBDcmVhdGVzIGEgc2V0dGVyL2dldHRlciBwYWlyIGZvciB0aGUgbmFtZWQgcHJvcGVydHkgd2l0aCBpdHMgb3duXG4gICAgICAgKiBsb2NhbCBzdG9yYWdlLiAgVGhlIGdldHRlciByZXR1cm5zIHRoZSB2YWx1ZSBpbiB0aGUgbG9jYWwgc3RvcmFnZSxcbiAgICAgICAqIGFuZCB0aGUgc2V0dGVyIGNhbGxzIGBfc2V0UHJvcGVydHlgLCB3aGljaCB1cGRhdGVzIHRoZSBsb2NhbCBzdG9yYWdlXG4gICAgICAgKiBmb3IgdGhlIHByb3BlcnR5IGFuZCBlbnF1ZXVlcyBhIGBfcHJvcGVydGllc0NoYW5nZWRgIGNhbGxiYWNrLlxuICAgICAgICpcbiAgICAgICAqIFRoaXMgbWV0aG9kIG1heSBiZSBjYWxsZWQgb24gYSBwcm90b3R5cGUgb3IgYW4gaW5zdGFuY2UuICBDYWxsaW5nXG4gICAgICAgKiB0aGlzIG1ldGhvZCBtYXkgb3ZlcndyaXRlIGEgcHJvcGVydHkgdmFsdWUgdGhhdCBhbHJlYWR5IGV4aXN0cyBvblxuICAgICAgICogdGhlIHByb3RvdHlwZS9pbnN0YW5jZSBieSBjcmVhdGluZyB0aGUgYWNjZXNzb3IuICBXaGVuIGNhbGxpbmcgb25cbiAgICAgICAqIGEgcHJvdG90eXBlLCBhbnkgb3ZlcndyaXR0ZW4gdmFsdWVzIGFyZSBzYXZlZCBpbiBgX19kYXRhUHJvdG9gLFxuICAgICAgICogYW5kIGl0IGlzIHVwIHRvIHRoZSBzdWJjbGFzc2VyIHRvIGRlY2lkZSBob3cvd2hlbiB0byBzZXQgdGhvc2VcbiAgICAgICAqIHByb3BlcnRpZXMgYmFjayBpbnRvIHRoZSBhY2Nlc3Nvci4gIFdoZW4gY2FsbGluZyBvbiBhbiBpbnN0YW5jZSxcbiAgICAgICAqIHRoZSBvdmVyd3JpdHRlbiB2YWx1ZSBpcyBzZXQgdmlhIGBfc2V0UGVuZGluZ1Byb3BlcnR5YCwgYW5kIHRoZVxuICAgICAgICogdXNlciBzaG91bGQgY2FsbCBgX2ludmFsaWRhdGVQcm9wZXJ0aWVzYCBvciBgX2ZsdXNoUHJvcGVydGllc2BcbiAgICAgICAqIGZvciB0aGUgdmFsdWVzIHRvIHRha2UgZWZmZWN0LlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBOYW1lIG9mIHRoZSBwcm9wZXJ0eVxuICAgICAgICogQHBhcmFtIHtib29sZWFuPX0gcmVhZE9ubHkgV2hlbiB0cnVlLCBubyBzZXR0ZXIgaXMgY3JlYXRlZDsgdGhlXG4gICAgICAgKiAgIHByb3RlY3RlZCBgX3NldFByb3BlcnR5YCBmdW5jdGlvbiBtdXN0IGJlIHVzZWQgdG8gc2V0IHRoZSBwcm9wZXJ0eVxuICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICovXG4gICAgICBfY3JlYXRlUHJvcGVydHlBY2Nlc3Nvcihwcm9wZXJ0eSwgcmVhZE9ubHkpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhc093blByb3BlcnR5KCdfX2RhdGFIYXNBY2Nlc3NvcicpKSB7XG4gICAgICAgICAgdGhpcy5fX2RhdGFIYXNBY2Nlc3NvciA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuX19kYXRhSGFzQWNjZXNzb3IpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5fX2RhdGFIYXNBY2Nlc3Nvcltwcm9wZXJ0eV0pIHtcbiAgICAgICAgICB0aGlzLl9fZGF0YUhhc0FjY2Vzc29yW3Byb3BlcnR5XSA9IHRydWU7XG4gICAgICAgICAgc2F2ZUFjY2Vzc29yVmFsdWUodGhpcywgcHJvcGVydHkpO1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBwcm9wZXJ0eSwge1xuICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgdmFsaWQtanNkb2MgKi9cbiAgICAgICAgICAgIC8qKiBAdGhpcyB7UHJvcGVydHlBY2Nlc3NvcnN9ICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fX2RhdGFbcHJvcGVydHldO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8qKiBAdGhpcyB7UHJvcGVydHlBY2Nlc3NvcnN9ICovXG4gICAgICAgICAgICBzZXQ6IHJlYWRPbmx5ID8gZnVuY3Rpb24oKSB7fSA6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3NldFByb3BlcnR5KHByb3BlcnR5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBlc2xpbnQtZW5hYmxlICovXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBsaWJyYXJ5IGNyZWF0ZWQgYW4gYWNjZXNzb3IgZm9yIHRoZSBnaXZlbiBwcm9wZXJ0eS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgbmFtZVxuICAgICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBhbiBhY2Nlc3NvciB3YXMgY3JlYXRlZFxuICAgICAgICovXG4gICAgICBfaGFzQWNjZXNzb3IocHJvcGVydHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19kYXRhSGFzQWNjZXNzb3IgJiYgdGhpcy5fX2RhdGFIYXNBY2Nlc3Nvcltwcm9wZXJ0eV07XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogVXBkYXRlcyB0aGUgbG9jYWwgc3RvcmFnZSBmb3IgYSBwcm9wZXJ0eSAodmlhIGBfc2V0UGVuZGluZ1Byb3BlcnR5YClcbiAgICAgICAqIGFuZCBlbnF1ZXVlcyBhIGBfcHJvZXBydGllc0NoYW5nZWRgIGNhbGxiYWNrLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBOYW1lIG9mIHRoZSBwcm9wZXJ0eVxuICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byBzZXRcbiAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAqL1xuICAgICAgX3NldFByb3BlcnR5KHByb3BlcnR5LCB2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5fc2V0UGVuZGluZ1Byb3BlcnR5KHByb3BlcnR5LCB2YWx1ZSkpIHtcbiAgICAgICAgICB0aGlzLl9pbnZhbGlkYXRlUHJvcGVydGllcygpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogVXBkYXRlcyB0aGUgbG9jYWwgc3RvcmFnZSBmb3IgYSBwcm9wZXJ0eSwgcmVjb3JkcyB0aGUgcHJldmlvdXMgdmFsdWUsXG4gICAgICAgKiBhbmQgYWRkcyBpdCB0byB0aGUgc2V0IG9mIFwicGVuZGluZyBjaGFuZ2VzXCIgdGhhdCB3aWxsIGJlIHBhc3NlZCB0byB0aGVcbiAgICAgICAqIGBfcHJvcGVydGllc0NoYW5nZWRgIGNhbGxiYWNrLiAgVGhpcyBtZXRob2QgZG9lcyBub3QgZW5xdWV1ZSB0aGVcbiAgICAgICAqIGBfcHJvcGVydGllc0NoYW5nZWRgIGNhbGxiYWNrLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBOYW1lIG9mIHRoZSBwcm9wZXJ0eVxuICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byBzZXRcbiAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGUgcHJvcGVydHkgY2hhbmdlZFxuICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICovXG4gICAgICBfc2V0UGVuZGluZ1Byb3BlcnR5KHByb3BlcnR5LCB2YWx1ZSkge1xuICAgICAgICBsZXQgb2xkID0gdGhpcy5fX2RhdGFbcHJvcGVydHldO1xuICAgICAgICBsZXQgY2hhbmdlZCA9IHRoaXMuX3Nob3VsZFByb3BlcnR5Q2hhbmdlKHByb3BlcnR5LCB2YWx1ZSwgb2xkKVxuICAgICAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgICAgIGlmICghdGhpcy5fX2RhdGFQZW5kaW5nKSB7XG4gICAgICAgICAgICB0aGlzLl9fZGF0YVBlbmRpbmcgPSB7fTtcbiAgICAgICAgICAgIHRoaXMuX19kYXRhT2xkID0ge307XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIEVuc3VyZSBvbGQgaXMgY2FwdHVyZWQgZnJvbSB0aGUgbGFzdCB0dXJuXG4gICAgICAgICAgaWYgKHRoaXMuX19kYXRhT2xkICYmICEocHJvcGVydHkgaW4gdGhpcy5fX2RhdGFPbGQpKSB7XG4gICAgICAgICAgICB0aGlzLl9fZGF0YU9sZFtwcm9wZXJ0eV0gPSBvbGQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX19kYXRhW3Byb3BlcnR5XSA9IHZhbHVlO1xuICAgICAgICAgIHRoaXMuX19kYXRhUGVuZGluZ1twcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hhbmdlZDtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHNwZWNpZmllZCBwcm9wZXJ0eSBoYXMgYSBwZW5kaW5nIGNoYW5nZS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcCBQcm9wZXJ0eSBuYW1lXG4gICAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHByb3BlcnR5IGhhcyBhIHBlbmRpbmcgY2hhbmdlXG4gICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgKi9cbiAgICAgIF9pc1Byb3BlcnR5UGVuZGluZyhwcm9wKSB7XG4gICAgICAgIHJldHVybiBCb29sZWFuKHRoaXMuX19kYXRhUGVuZGluZyAmJiAocHJvcCBpbiB0aGlzLl9fZGF0YVBlbmRpbmcpKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBNYXJrcyB0aGUgcHJvcGVydGllcyBhcyBpbnZhbGlkLCBhbmQgZW5xdWV1ZXMgYW4gYXN5bmNcbiAgICAgICAqIGBfcHJvcGVydGllc0NoYW5nZWRgIGNhbGxiYWNrLlxuICAgICAgICpcbiAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAqL1xuICAgICAgX2ludmFsaWRhdGVQcm9wZXJ0aWVzKCkge1xuICAgICAgICBpZiAoIXRoaXMuX19kYXRhSW52YWxpZCAmJiB0aGlzLl9fZGF0YVJlYWR5KSB7XG4gICAgICAgICAgdGhpcy5fX2RhdGFJbnZhbGlkID0gdHJ1ZTtcbiAgICAgICAgICBtaWNyb3Rhc2sucnVuKCgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9fZGF0YUludmFsaWQpIHtcbiAgICAgICAgICAgICAgdGhpcy5fX2RhdGFJbnZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgIHRoaXMuX2ZsdXNoUHJvcGVydGllcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ2FsbCB0byBlbmFibGUgcHJvcGVydHkgYWNjZXNzb3IgcHJvY2Vzc2luZy4gQmVmb3JlIHRoaXMgbWV0aG9kIGlzXG4gICAgICAgKiBjYWxsZWQgYWNjZXNzb3IgdmFsdWVzIHdpbGwgYmUgc2V0IGJ1dCBzaWRlIGVmZmVjdHMgYXJlXG4gICAgICAgKiBxdWV1ZWQuIFdoZW4gY2FsbGVkLCBhbnkgcGVuZGluZyBzaWRlIGVmZmVjdHMgb2NjdXIgaW1tZWRpYXRlbHkuXG4gICAgICAgKiBGb3IgZWxlbWVudHMsIGdlbmVyYWxseSBgY29ubmVjdGVkQ2FsbGJhY2tgIGlzIGEgbm9ybWFsIHNwb3QgdG8gZG8gc28uXG4gICAgICAgKiBJdCBpcyBzYWZlIHRvIGNhbGwgdGhpcyBtZXRob2QgbXVsdGlwbGUgdGltZXMgYXMgaXQgb25seSB0dXJucyBvblxuICAgICAgICogcHJvcGVydHkgYWNjZXNzb3JzIG9uY2UuXG4gICAgICAgKi9cbiAgICAgIF9lbmFibGVQcm9wZXJ0aWVzKCkge1xuICAgICAgICBpZiAoIXRoaXMuX19kYXRhRW5hYmxlZCkge1xuICAgICAgICAgIHRoaXMuX19kYXRhRW5hYmxlZCA9IHRydWU7XG4gICAgICAgICAgaWYgKHRoaXMuX19kYXRhSW5zdGFuY2VQcm9wcykge1xuICAgICAgICAgICAgdGhpcy5faW5pdGlhbGl6ZUluc3RhbmNlUHJvcGVydGllcyh0aGlzLl9fZGF0YUluc3RhbmNlUHJvcHMpO1xuICAgICAgICAgICAgdGhpcy5fX2RhdGFJbnN0YW5jZVByb3BzID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5yZWFkeSgpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDYWxscyB0aGUgYF9wcm9wZXJ0aWVzQ2hhbmdlZGAgY2FsbGJhY2sgd2l0aCB0aGUgY3VycmVudCBzZXQgb2ZcbiAgICAgICAqIHBlbmRpbmcgY2hhbmdlcyAoYW5kIG9sZCB2YWx1ZXMgcmVjb3JkZWQgd2hlbiBwZW5kaW5nIGNoYW5nZXMgd2VyZVxuICAgICAgICogc2V0KSwgYW5kIHJlc2V0cyB0aGUgcGVuZGluZyBzZXQgb2YgY2hhbmdlcy4gR2VuZXJhbGx5LCB0aGlzIG1ldGhvZFxuICAgICAgICogc2hvdWxkIG5vdCBiZSBjYWxsZWQgaW4gdXNlciBjb2RlLlxuICAgICAgICpcbiAgICAgICAqXG4gICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgKi9cbiAgICAgIF9mbHVzaFByb3BlcnRpZXMoKSB7XG4gICAgICAgIGlmICh0aGlzLl9fZGF0YVBlbmRpbmcgJiYgdGhpcy5fX2RhdGFPbGQpIHtcbiAgICAgICAgICBsZXQgY2hhbmdlZFByb3BzID0gdGhpcy5fX2RhdGFQZW5kaW5nO1xuICAgICAgICAgIHRoaXMuX19kYXRhUGVuZGluZyA9IG51bGw7XG4gICAgICAgICAgdGhpcy5fX2RhdGFDb3VudGVyKys7XG4gICAgICAgICAgdGhpcy5fcHJvcGVydGllc0NoYW5nZWQodGhpcy5fX2RhdGEsIGNoYW5nZWRQcm9wcywgdGhpcy5fX2RhdGFPbGQpO1xuICAgICAgICAgIHRoaXMuX19kYXRhQ291bnRlci0tO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogTGlmZWN5Y2xlIGNhbGxiYWNrIGNhbGxlZCB0aGUgZmlyc3QgdGltZSBwcm9wZXJ0aWVzIGFyZSBiZWluZyBmbHVzaGVkLlxuICAgICAgICogUHJpb3IgdG8gYHJlYWR5YCwgYWxsIHByb3BlcnR5IHNldHMgdGhyb3VnaCBhY2Nlc3NvcnMgYXJlIHF1ZXVlZCBhbmRcbiAgICAgICAqIHRoZWlyIGVmZmVjdHMgYXJlIGZsdXNoZWQgYWZ0ZXIgdGhpcyBtZXRob2QgcmV0dXJucy5cbiAgICAgICAqXG4gICAgICAgKiBVc2VycyBtYXkgb3ZlcnJpZGUgdGhpcyBmdW5jdGlvbiB0byBpbXBsZW1lbnQgYmVoYXZpb3IgdGhhdCBpc1xuICAgICAgICogZGVwZW5kZW50IG9uIHRoZSBlbGVtZW50IGhhdmluZyBpdHMgcHJvcGVydGllcyBpbml0aWFsaXplZCwgZS5nLlxuICAgICAgICogZnJvbSBkZWZhdWx0cyAoaW5pdGlhbGl6ZWQgZnJvbSBgY29uc3RydWN0b3JgLCBgX2luaXRpYWxpemVQcm9wZXJ0aWVzYCksXG4gICAgICAgKiBgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrYCwgb3IgdmFsdWVzIHByb3BhZ2F0ZWQgZnJvbSBob3N0IGUuZy4gdmlhXG4gICAgICAgKiBiaW5kaW5ncy4gIGBzdXBlci5yZWFkeSgpYCBtdXN0IGJlIGNhbGxlZCB0byBlbnN1cmUgdGhlIGRhdGEgc3lzdGVtXG4gICAgICAgKiBiZWNvbWVzIGVuYWJsZWQuXG4gICAgICAgKlxuICAgICAgICogQHB1YmxpY1xuICAgICAgICovXG4gICAgICByZWFkeSgpIHtcbiAgICAgICAgdGhpcy5fX2RhdGFSZWFkeSA9IHRydWU7XG4gICAgICAgIC8vIFJ1biBub3JtYWwgZmx1c2hcbiAgICAgICAgdGhpcy5fZmx1c2hQcm9wZXJ0aWVzKCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ2FsbGJhY2sgY2FsbGVkIHdoZW4gYW55IHByb3BlcnRpZXMgd2l0aCBhY2Nlc3NvcnMgY3JlYXRlZCB2aWFcbiAgICAgICAqIGBfY3JlYXRlUHJvcGVydHlBY2Nlc3NvcmAgaGF2ZSBiZWVuIHNldC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0geyFPYmplY3R9IGN1cnJlbnRQcm9wcyBCYWcgb2YgYWxsIGN1cnJlbnQgYWNjZXNzb3IgdmFsdWVzXG4gICAgICAgKiBAcGFyYW0geyFPYmplY3R9IGNoYW5nZWRQcm9wcyBCYWcgb2YgcHJvcGVydGllcyBjaGFuZ2VkIHNpbmNlIHRoZSBsYXN0XG4gICAgICAgKiAgIGNhbGwgdG8gYF9wcm9wZXJ0aWVzQ2hhbmdlZGBcbiAgICAgICAqIEBwYXJhbSB7IU9iamVjdH0gb2xkUHJvcHMgQmFnIG9mIHByZXZpb3VzIHZhbHVlcyBmb3IgZWFjaCBwcm9wZXJ0eVxuICAgICAgICogICBpbiBgY2hhbmdlZFByb3BzYFxuICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICovXG4gICAgICBfcHJvcGVydGllc0NoYW5nZWQoY3VycmVudFByb3BzLCBjaGFuZ2VkUHJvcHMsIG9sZFByb3BzKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBNZXRob2QgY2FsbGVkIHRvIGRldGVybWluZSB3aGV0aGVyIGEgcHJvcGVydHkgdmFsdWUgc2hvdWxkIGJlXG4gICAgICAgKiBjb25zaWRlcmVkIGFzIGEgY2hhbmdlIGFuZCBjYXVzZSB0aGUgYF9wcm9wZXJ0aWVzQ2hhbmdlZGAgY2FsbGJhY2tcbiAgICAgICAqIHRvIGJlIGVucXVldWVkLlxuICAgICAgICpcbiAgICAgICAqIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIHJldHVybnMgYHRydWVgIGZvciBwcmltaXRpdmUgdHlwZXMgaWYgYVxuICAgICAgICogc3RyaWN0IGVxdWFsaXR5IGNoZWNrIGZhaWxzLCBhbmQgcmV0dXJucyBgdHJ1ZWAgZm9yIGFsbCBPYmplY3QvQXJyYXlzLlxuICAgICAgICogVGhlIG1ldGhvZCBhbHdheXMgcmV0dXJucyBmYWxzZSBmb3IgYE5hTmAuXG4gICAgICAgKlxuICAgICAgICogT3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gZS5nLiBwcm92aWRlIHN0cmljdGVyIGNoZWNraW5nIGZvclxuICAgICAgICogT2JqZWN0cy9BcnJheXMgd2hlbiB1c2luZyBpbW11dGFibGUgcGF0dGVybnMuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IG5hbWVcbiAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgTmV3IHByb3BlcnR5IHZhbHVlXG4gICAgICAgKiBAcGFyYW0geyp9IG9sZCBQcmV2aW91cyBwcm9wZXJ0eSB2YWx1ZVxuICAgICAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgcHJvcGVydHkgc2hvdWxkIGJlIGNvbnNpZGVyZWQgYSBjaGFuZ2VcbiAgICAgICAqICAgYW5kIGVucXVldWUgYSBgX3Byb2VwcnRpZXNDaGFuZ2VkYCBjYWxsYmFja1xuICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICovXG4gICAgICBfc2hvdWxkUHJvcGVydHlDaGFuZ2UocHJvcGVydHksIHZhbHVlLCBvbGQpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAvLyBTdHJpY3QgZXF1YWxpdHkgY2hlY2tcbiAgICAgICAgICAob2xkICE9PSB2YWx1ZSAmJlxuICAgICAgICAgICAvLyBUaGlzIGVuc3VyZXMgKG9sZD09TmFOLCB2YWx1ZT09TmFOKSBhbHdheXMgcmV0dXJucyBmYWxzZVxuICAgICAgICAgICAob2xkID09PSBvbGQgfHwgdmFsdWUgPT09IHZhbHVlKSlcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgIH1cblxuICAgIHJldHVybiBQcm9wZXJ0eUFjY2Vzc29ycztcblxuICB9KTtcblxufSkoKTtcbjwvc2NyaXB0PlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi9taXhpbnMvcHJvcGVydHktYWNjZXNzb3JzLmh0bWwiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi91dGlscy9ib290Lmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi91dGlscy9taXhpbi5odG1sXCI+XG5cbjxzY3JpcHQ+XG4oZnVuY3Rpb24oKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIDEueCBiYWNrd2FyZHMtY29tcGF0aWJsZSBhdXRvLXdyYXBwZXIgZm9yIHRlbXBsYXRlIHR5cGUgZXh0ZW5zaW9uc1xuICAvLyBUaGlzIGlzIGEgY2xlYXIgbGF5ZXJpbmcgdmlvbGF0aW9uIGFuZCBnaXZlcyBmYXZvcmVkLW5hdGlvbiBzdGF0dXMgdG9cbiAgLy8gZG9tLWlmIGFuZCBkb20tcmVwZWF0IHRlbXBsYXRlcy4gIFRoaXMgaXMgYSBjb25jZWl0IHdlJ3JlIGNob29zaW5nIHRvIGtlZXBcbiAgLy8gYS4pIHRvIGVhc2UgMS54IGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5IGR1ZSB0byBsb3NzIG9mIGBpc2AsIGFuZFxuICAvLyBiLikgdG8gbWFpbnRhaW4gaWYvcmVwZWF0IGNhcGFiaWxpdHkgaW4gcGFyc2VyLWNvbnN0cmFpbmVkIGVsZW1lbnRzXG4gIC8vICAgICAoZS5nLiB0YWJsZSwgc2VsZWN0KSBpbiBsaWV1IG9mIG5hdGl2ZSBDRSB0eXBlIGV4dGVuc2lvbnMgd2l0aG91dFxuICAvLyAgICAgbWFzc2l2ZSBuZXcgaW52ZW50aW9uIGluIHRoaXMgc3BhY2UgKGUuZy4gZGlyZWN0aXZlIHN5c3RlbSlcbiAgY29uc3QgdGVtcGxhdGVFeHRlbnNpb25zID0ge1xuICAgICdkb20taWYnOiB0cnVlLFxuICAgICdkb20tcmVwZWF0JzogdHJ1ZVxuICB9O1xuICBmdW5jdGlvbiB3cmFwVGVtcGxhdGVFeHRlbnNpb24obm9kZSkge1xuICAgIGxldCBpcyA9IG5vZGUuZ2V0QXR0cmlidXRlKCdpcycpO1xuICAgIGlmIChpcyAmJiB0ZW1wbGF0ZUV4dGVuc2lvbnNbaXNdKSB7XG4gICAgICBsZXQgdCA9IG5vZGU7XG4gICAgICB0LnJlbW92ZUF0dHJpYnV0ZSgnaXMnKTtcbiAgICAgIG5vZGUgPSB0Lm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudChpcyk7XG4gICAgICB0LnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKG5vZGUsIHQpO1xuICAgICAgbm9kZS5hcHBlbmRDaGlsZCh0KTtcbiAgICAgIHdoaWxlKHQuYXR0cmlidXRlcy5sZW5ndGgpIHtcbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUodC5hdHRyaWJ1dGVzWzBdLm5hbWUsIHQuYXR0cmlidXRlc1swXS52YWx1ZSk7XG4gICAgICAgIHQucmVtb3ZlQXR0cmlidXRlKHQuYXR0cmlidXRlc1swXS5uYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICBmdW5jdGlvbiBmaW5kVGVtcGxhdGVOb2RlKHJvb3QsIG5vZGVJbmZvKSB7XG4gICAgLy8gcmVjdXJzaXZlbHkgYXNjZW5kIHRyZWUgdW50aWwgd2UgaGl0IHJvb3RcbiAgICBsZXQgcGFyZW50ID0gbm9kZUluZm8ucGFyZW50SW5mbyAmJiBmaW5kVGVtcGxhdGVOb2RlKHJvb3QsIG5vZGVJbmZvLnBhcmVudEluZm8pO1xuICAgIC8vIHVud2luZCB0aGUgc3RhY2ssIHJldHVybmluZyB0aGUgaW5kZXhlZCBub2RlIGF0IGVhY2ggbGV2ZWxcbiAgICBpZiAocGFyZW50KSB7XG4gICAgICAvLyBub3RlOiBtYXJnaW5hbGx5IGZhc3RlciB0aGFuIGluZGV4aW5nIHZpYSBjaGlsZE5vZGVzXG4gICAgICAvLyAoaHR0cDovL2pzcGVyZi5jb20vY2hpbGRub2Rlcy1sb29rdXApXG4gICAgICBmb3IgKGxldCBuPXBhcmVudC5maXJzdENoaWxkLCBpPTA7IG47IG49bi5uZXh0U2libGluZykge1xuICAgICAgICBpZiAobm9kZUluZm8ucGFyZW50SW5kZXggPT09IGkrKykge1xuICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiByb290O1xuICAgIH1cbiAgfVxuXG4gIC8vIGNvbnN0cnVjdCBgJGAgbWFwIChmcm9tIGlkIGFubm90YXRpb25zKVxuICBmdW5jdGlvbiBhcHBseUlkVG9NYXAoaW5zdCwgbWFwLCBub2RlLCBub2RlSW5mbykge1xuICAgIGlmIChub2RlSW5mby5pZCkge1xuICAgICAgbWFwW25vZGVJbmZvLmlkXSA9IG5vZGU7XG4gICAgfVxuICB9XG5cbiAgLy8gaW5zdGFsbCBldmVudCBsaXN0ZW5lcnMgKGZyb20gZXZlbnQgYW5ub3RhdGlvbnMpXG4gIGZ1bmN0aW9uIGFwcGx5RXZlbnRMaXN0ZW5lcihpbnN0LCBub2RlLCBub2RlSW5mbykge1xuICAgIGlmIChub2RlSW5mby5ldmVudHMgJiYgbm9kZUluZm8uZXZlbnRzLmxlbmd0aCkge1xuICAgICAgZm9yIChsZXQgaj0wLCBlJD1ub2RlSW5mby5ldmVudHMsIGU7IChqPGUkLmxlbmd0aCkgJiYgKGU9ZSRbal0pOyBqKyspIHtcbiAgICAgICAgaW5zdC5fYWRkTWV0aG9kRXZlbnRMaXN0ZW5lclRvTm9kZShub2RlLCBlLm5hbWUsIGUudmFsdWUsIGluc3QpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIHB1c2ggY29uZmlndXJhdGlvbiByZWZlcmVuY2VzIGF0IGNvbmZpZ3VyZSB0aW1lXG4gIGZ1bmN0aW9uIGFwcGx5VGVtcGxhdGVDb250ZW50KGluc3QsIG5vZGUsIG5vZGVJbmZvKSB7XG4gICAgaWYgKG5vZGVJbmZvLnRlbXBsYXRlSW5mbykge1xuICAgICAgbm9kZS5fdGVtcGxhdGVJbmZvID0gbm9kZUluZm8udGVtcGxhdGVJbmZvO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZU5vZGVFdmVudEhhbmRsZXIoY29udGV4dCwgZXZlbnROYW1lLCBtZXRob2ROYW1lKSB7XG4gICAgLy8gSW5zdGFuY2VzIGNhbiBvcHRpb25hbGx5IGhhdmUgYSBfbWV0aG9kSG9zdCB3aGljaCBhbGxvd3MgcmVkaXJlY3Rpbmcgd2hlcmVcbiAgICAvLyB0byBmaW5kIG1ldGhvZHMuIEN1cnJlbnRseSB1c2VkIGJ5IGB0ZW1wbGF0aXplYC5cbiAgICBjb250ZXh0ID0gY29udGV4dC5fbWV0aG9kSG9zdCB8fCBjb250ZXh0O1xuICAgIGxldCBoYW5kbGVyID0gZnVuY3Rpb24oZSkge1xuICAgICAgaWYgKGNvbnRleHRbbWV0aG9kTmFtZV0pIHtcbiAgICAgICAgY29udGV4dFttZXRob2ROYW1lXShlLCBlLmRldGFpbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4oJ2xpc3RlbmVyIG1ldGhvZCBgJyArIG1ldGhvZE5hbWUgKyAnYCBub3QgZGVmaW5lZCcpO1xuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIGhhbmRsZXI7XG4gIH1cblxuICAvKipcbiAgICogRWxlbWVudCBtaXhpbiB0aGF0IHByb3ZpZGVzIGJhc2ljIHRlbXBsYXRlIHBhcnNpbmcgYW5kIHN0YW1waW5nLCBpbmNsdWRpbmdcbiAgICogdGhlIGZvbGxvd2luZyB0ZW1wbGF0ZS1yZWxhdGVkIGZlYXR1cmVzIGZvciBzdGFtcGVkIHRlbXBsYXRlczpcbiAgICpcbiAgICogLSBEZWNsYXJhdGl2ZSBldmVudCBsaXN0ZW5lcnMgKGBvbi1ldmVudG5hbWU9XCJsaXN0ZW5lclwiYClcbiAgICogLSBNYXAgb2Ygbm9kZSBpZCdzIHRvIHN0YW1wZWQgbm9kZSBpbnN0YW5jZXMgKGB0aGlzLiQuaWRgKVxuICAgKiAtIE5lc3RlZCB0ZW1wbGF0ZSBjb250ZW50IGNhY2hpbmcvcmVtb3ZhbCBhbmQgcmUtaW5zdGFsbGF0aW9uIChwZXJmb3JtYW5jZVxuICAgKiAgIG9wdGltaXphdGlvbilcbiAgICpcbiAgICogQG1peGluRnVuY3Rpb25cbiAgICogQHBvbHltZXJcbiAgICogQG1lbWJlcm9mIFBvbHltZXJcbiAgICogQHN1bW1hcnkgRWxlbWVudCBjbGFzcyBtaXhpbiB0aGF0IHByb3ZpZGVzIGJhc2ljIHRlbXBsYXRlIHBhcnNpbmcgYW5kIHN0YW1waW5nXG4gICAqL1xuICBQb2x5bWVyLlRlbXBsYXRlU3RhbXAgPSBQb2x5bWVyLmRlZHVwaW5nTWl4aW4oc3VwZXJDbGFzcyA9PiB7XG5cbiAgICAvKipcbiAgICAgKiBAcG9seW1lclxuICAgICAqIEBtaXhpbkNsYXNzXG4gICAgICogQGltcGxlbWVudHMge1BvbHltZXJfVGVtcGxhdGVTdGFtcH1cbiAgICAgKi9cbiAgICBjbGFzcyBUZW1wbGF0ZVN0YW1wIGV4dGVuZHMgc3VwZXJDbGFzcyB7XG5cbiAgICAgIC8qKlxuICAgICAgICogU2NhbnMgYSB0ZW1wbGF0ZSB0byBwcm9kdWNlIHRlbXBsYXRlIG1ldGFkYXRhLlxuICAgICAgICpcbiAgICAgICAqIFRlbXBsYXRlLXNwZWNpZmljIG1ldGFkYXRhIGFyZSBzdG9yZWQgaW4gdGhlIG9iamVjdCByZXR1cm5lZCwgYW5kIG5vZGUtXG4gICAgICAgKiBzcGVjaWZpYyBtZXRhZGF0YSBhcmUgc3RvcmVkIGluIG9iamVjdHMgaW4gaXRzIGZsYXR0ZW5lZCBgbm9kZUluZm9MaXN0YFxuICAgICAgICogYXJyYXkuICBPbmx5IG5vZGVzIGluIHRoZSB0ZW1wbGF0ZSB0aGF0IHdlcmUgcGFyc2VkIGFzIG5vZGVzIG9mXG4gICAgICAgKiBpbnRlcmVzdCBjb250YWluIGFuIG9iamVjdCBpbiBgbm9kZUluZm9MaXN0YC4gIEVhY2ggYG5vZGVJbmZvYCBvYmplY3RcbiAgICAgICAqIGNvbnRhaW5zIGFuIGBpbmRleGAgKGBjaGlsZE5vZGVzYCBpbmRleCBpbiBwYXJlbnQpIGFuZCBvcHRpb25hbGx5XG4gICAgICAgKiBgcGFyZW50YCwgd2hpY2ggcG9pbnRzIHRvIG5vZGUgaW5mbyBvZiBpdHMgcGFyZW50IChpbmNsdWRpbmcgaXRzIGluZGV4KS5cbiAgICAgICAqXG4gICAgICAgKiBUaGUgdGVtcGxhdGUgbWV0YWRhdGEgb2JqZWN0IHJldHVybmVkIGZyb20gdGhpcyBtZXRob2QgaGFzIHRoZSBmb2xsb3dpbmdcbiAgICAgICAqIHN0cnVjdHVyZSAobWFueSBmaWVsZHMgb3B0aW9uYWwpOlxuICAgICAgICpcbiAgICAgICAqIGBgYGpzXG4gICAgICAgKiAgIHtcbiAgICAgICAqICAgICAvLyBGbGF0dGVuZWQgbGlzdCBvZiBub2RlIG1ldGFkYXRhIChmb3Igbm9kZXMgdGhhdCBnZW5lcmF0ZWQgbWV0YWRhdGEpXG4gICAgICAgKiAgICAgbm9kZUluZm9MaXN0OiBbXG4gICAgICAgKiAgICAgICB7XG4gICAgICAgKiAgICAgICAgIC8vIGBpZGAgYXR0cmlidXRlIGZvciBhbnkgbm9kZXMgd2l0aCBpZCdzIGZvciBnZW5lcmF0aW5nIGAkYCBtYXBcbiAgICAgICAqICAgICAgICAgaWQ6IHtzdHJpbmd9LFxuICAgICAgICogICAgICAgICAvLyBgb24tZXZlbnQ9XCJoYW5kbGVyXCJgIG1ldGFkYXRhXG4gICAgICAgKiAgICAgICAgIGV2ZW50czogW1xuICAgICAgICogICAgICAgICAgIHtcbiAgICAgICAqICAgICAgICAgICAgIG5hbWU6IHtzdHJpbmd9LCAgIC8vIGV2ZW50IG5hbWVcbiAgICAgICAqICAgICAgICAgICAgIHZhbHVlOiB7c3RyaW5nfSwgIC8vIGhhbmRsZXIgbWV0aG9kIG5hbWVcbiAgICAgICAqICAgICAgICAgICB9LCAuLi5cbiAgICAgICAqICAgICAgICAgXSxcbiAgICAgICAqICAgICAgICAgLy8gTm90ZXMgd2hlbiB0aGUgdGVtcGxhdGUgY29udGFpbmVkIGEgYDxzbG90PmAgZm9yIHNoYWR5IERPTVxuICAgICAgICogICAgICAgICAvLyBvcHRpbWl6YXRpb24gcHVycG9zZXNcbiAgICAgICAqICAgICAgICAgaGFzSW5zZXJ0aW9uUG9pbnQ6IHtib29sZWFufSxcbiAgICAgICAqICAgICAgICAgLy8gRm9yIG5lc3RlZCBgPHRlbXBsYXRlPmBgIG5vZGVzLCBuZXN0ZWQgdGVtcGxhdGUgbWV0YWRhdGFcbiAgICAgICAqICAgICAgICAgdGVtcGxhdGVJbmZvOiB7b2JqZWN0fSwgLy8gbmVzdGVkIHRlbXBsYXRlIG1ldGFkYXRhXG4gICAgICAgKiAgICAgICAgIC8vIE1ldGFkYXRhIHRvIGFsbG93IGVmZmljaWVudCByZXRyaWV2YWwgb2YgaW5zdGFuY2VkIG5vZGVcbiAgICAgICAqICAgICAgICAgLy8gY29ycmVzcG9uZGluZyB0byB0aGlzIG1ldGFkYXRhXG4gICAgICAgKiAgICAgICAgIHBhcmVudEluZm86IHtudW1iZXJ9LCAgIC8vIHJlZmVyZW5jZSB0byBwYXJlbnQgbm9kZUluZm8+XG4gICAgICAgKiAgICAgICAgIHBhcmVudEluZGV4OiB7bnVtYmVyfSwgIC8vIGluZGV4IGluIHBhcmVudCdzIGBjaGlsZE5vZGVzYCBjb2xsZWN0aW9uXG4gICAgICAgKiAgICAgICAgIGluZm9JbmRleDoge251bWJlcn0sICAgIC8vIGluZGV4IG9mIHRoaXMgYG5vZGVJbmZvYCBpbiBgdGVtcGxhdGVJbmZvLm5vZGVJbmZvTGlzdGBcbiAgICAgICAqICAgICAgIH0sXG4gICAgICAgKiAgICAgICAuLi5cbiAgICAgICAqICAgICBdLFxuICAgICAgICogICAgIC8vIFdoZW4gdHJ1ZSwgdGhlIHRlbXBsYXRlIGhhZCB0aGUgYHN0cmlwLXdoaXRlc3BhY2VgIGF0dHJpYnV0ZVxuICAgICAgICogICAgIC8vIG9yIHdhcyBuZXN0ZWQgaW4gYSB0ZW1wbGF0ZSB3aXRoIHRoYXQgc2V0dGluZ1xuICAgICAgICogICAgIHN0cmlwV2hpdGVzcGFjZToge2Jvb2xlYW59LFxuICAgICAgICogICAgIC8vIEZvciBuZXN0ZWQgdGVtcGxhdGVzLCBuZXN0ZWQgdGVtcGxhdGUgY29udGVudCBpcyBtb3ZlZCBpbnRvXG4gICAgICAgKiAgICAgLy8gYSBkb2N1bWVudCBmcmFnbWVudCBzdG9yZWQgaGVyZTsgdGhpcyBpcyBhbiBvcHRpbWl6YXRpb24gdG9cbiAgICAgICAqICAgICAvLyBhdm9pZCB0aGUgY29zdCBvZiBuZXN0ZWQgdGVtcGxhdGUgY2xvbmluZ1xuICAgICAgICogICAgIGNvbnRlbnQ6IHtEb2N1bWVudEZyYWdtZW50fVxuICAgICAgICogICB9XG4gICAgICAgKiBgYGBcbiAgICAgICAqXG4gICAgICAgKiBUaGlzIG1ldGhvZCBraWNrcyBvZmYgYSByZWN1cnNpdmUgdHJlZXdhbGsgYXMgZm9sbG93czpcbiAgICAgICAqXG4gICAgICAgKiBgYGBcbiAgICAgICAqICAgIF9wYXJzZVRlbXBsYXRlIDwtLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgKiAgICAgIF9wYXJzZVRlbXBsYXRlQ29udGVudCAgICAgICAgICAgICAgfFxuICAgICAgICogICAgICAgIF9wYXJzZVRlbXBsYXRlTm9kZSAgPC0tLS0tLS0tLS0tLXwtLStcbiAgICAgICAqICAgICAgICAgIF9wYXJzZVRlbXBsYXRlTmVzdGVkVGVtcGxhdGUgLS0rICB8XG4gICAgICAgKiAgICAgICAgICBfcGFyc2VUZW1wbGF0ZUNoaWxkTm9kZXMgLS0tLS0tLS0tK1xuICAgICAgICogICAgICAgICAgX3BhcnNlVGVtcGxhdGVOb2RlQXR0cmlidXRlc1xuICAgICAgICogICAgICAgICAgICBfcGFyc2VUZW1wbGF0ZU5vZGVBdHRyaWJ1dGVcbiAgICAgICAqXG4gICAgICAgKiBgYGBcbiAgICAgICAqXG4gICAgICAgKiBUaGVzZSBtZXRob2RzIG1heSBiZSBvdmVycmlkZGVuIHRvIGFkZCBjdXN0b20gbWV0YWRhdGEgYWJvdXQgdGVtcGxhdGVzXG4gICAgICAgKiB0byBlaXRoZXIgYHRlbXBsYXRlSW5mb2Agb3IgYG5vZGVJbmZvYC5cbiAgICAgICAqXG4gICAgICAgKiBOb3RlIHRoYXQgdGhpcyBtZXRob2QgbWF5IGJlIGRlc3RydWN0aXZlIHRvIHRoZSB0ZW1wbGF0ZSwgaW4gdGhhdFxuICAgICAgICogZS5nLiBldmVudCBhbm5vdGF0aW9ucyBtYXkgYmUgcmVtb3ZlZCBhZnRlciBiZWluZyBub3RlZCBpbiB0aGVcbiAgICAgICAqIHRlbXBsYXRlIG1ldGFkYXRhLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7IUhUTUxUZW1wbGF0ZUVsZW1lbnR9IHRlbXBsYXRlIFRlbXBsYXRlIHRvIHBhcnNlXG4gICAgICAgKiBAcGFyYW0ge1RlbXBsYXRlSW5mbz19IG91dGVyVGVtcGxhdGVJbmZvIFRlbXBsYXRlIG1ldGFkYXRhIGZyb20gdGhlIG91dGVyXG4gICAgICAgKiAgIHRlbXBsYXRlLCBmb3IgcGFyc2luZyBuZXN0ZWQgdGVtcGxhdGVzXG4gICAgICAgKiBAcmV0dXJuIHshVGVtcGxhdGVJbmZvfSBQYXJzZWQgdGVtcGxhdGUgbWV0YWRhdGFcbiAgICAgICAqL1xuICAgICAgc3RhdGljIF9wYXJzZVRlbXBsYXRlKHRlbXBsYXRlLCBvdXRlclRlbXBsYXRlSW5mbykge1xuICAgICAgICAvLyBzaW5jZSBhIHRlbXBsYXRlIG1heSBiZSByZS11c2VkLCBtZW1vLWl6ZSBtZXRhZGF0YVxuICAgICAgICBpZiAoIXRlbXBsYXRlLl90ZW1wbGF0ZUluZm8pIHtcbiAgICAgICAgICBsZXQgdGVtcGxhdGVJbmZvID0gdGVtcGxhdGUuX3RlbXBsYXRlSW5mbyA9IHt9O1xuICAgICAgICAgIHRlbXBsYXRlSW5mby5ub2RlSW5mb0xpc3QgPSBbXTtcbiAgICAgICAgICB0ZW1wbGF0ZUluZm8uc3RyaXBXaGl0ZVNwYWNlID1cbiAgICAgICAgICAgIChvdXRlclRlbXBsYXRlSW5mbyAmJiBvdXRlclRlbXBsYXRlSW5mby5zdHJpcFdoaXRlU3BhY2UpIHx8XG4gICAgICAgICAgICB0ZW1wbGF0ZS5oYXNBdHRyaWJ1dGUoJ3N0cmlwLXdoaXRlc3BhY2UnKTtcbiAgICAgICAgICB0aGlzLl9wYXJzZVRlbXBsYXRlQ29udGVudCh0ZW1wbGF0ZSwgdGVtcGxhdGVJbmZvLCB7cGFyZW50OiBudWxsfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRlbXBsYXRlLl90ZW1wbGF0ZUluZm87XG4gICAgICB9XG5cbiAgICAgIHN0YXRpYyBfcGFyc2VUZW1wbGF0ZUNvbnRlbnQodGVtcGxhdGUsIHRlbXBsYXRlSW5mbywgbm9kZUluZm8pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcnNlVGVtcGxhdGVOb2RlKHRlbXBsYXRlLmNvbnRlbnQsIHRlbXBsYXRlSW5mbywgbm9kZUluZm8pO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFBhcnNlcyB0ZW1wbGF0ZSBub2RlIGFuZCBhZGRzIHRlbXBsYXRlIGFuZCBub2RlIG1ldGFkYXRhIGJhc2VkIG9uXG4gICAgICAgKiB0aGUgY3VycmVudCBub2RlLCBhbmQgaXRzIGBjaGlsZE5vZGVzYCBhbmQgYGF0dHJpYnV0ZXNgLlxuICAgICAgICpcbiAgICAgICAqIFRoaXMgbWV0aG9kIG1heSBiZSBvdmVycmlkZGVuIHRvIGFkZCBjdXN0b20gbm9kZSBvciB0ZW1wbGF0ZSBzcGVjaWZpY1xuICAgICAgICogbWV0YWRhdGEgYmFzZWQgb24gdGhpcyBub2RlLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBOb2RlIHRvIHBhcnNlXG4gICAgICAgKiBAcGFyYW0geyFUZW1wbGF0ZUluZm99IHRlbXBsYXRlSW5mbyBUZW1wbGF0ZSBtZXRhZGF0YSBmb3IgY3VycmVudCB0ZW1wbGF0ZVxuICAgICAgICogQHBhcmFtIHshTm9kZUluZm99IG5vZGVJbmZvIE5vZGUgbWV0YWRhdGEgZm9yIGN1cnJlbnQgdGVtcGxhdGUuXG4gICAgICAgKiBAcmV0dXJuIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIHZpc2l0ZWQgbm9kZSBhZGRlZCBub2RlLXNwZWNpZmljXG4gICAgICAgKiAgIG1ldGFkYXRhIHRvIGBub2RlSW5mb2BcbiAgICAgICAqL1xuICAgICAgc3RhdGljIF9wYXJzZVRlbXBsYXRlTm9kZShub2RlLCB0ZW1wbGF0ZUluZm8sIG5vZGVJbmZvKSB7XG4gICAgICAgIGxldCBub3RlZDtcbiAgICAgICAgbGV0IGVsZW1lbnQgPSAvKiogQHR5cGUgRWxlbWVudCAqLyhub2RlKTtcbiAgICAgICAgaWYgKGVsZW1lbnQubG9jYWxOYW1lID09ICd0ZW1wbGF0ZScgJiYgIWVsZW1lbnQuaGFzQXR0cmlidXRlKCdwcmVzZXJ2ZS1jb250ZW50JykpIHtcbiAgICAgICAgICBub3RlZCA9IHRoaXMuX3BhcnNlVGVtcGxhdGVOZXN0ZWRUZW1wbGF0ZShlbGVtZW50LCB0ZW1wbGF0ZUluZm8sIG5vZGVJbmZvKSB8fCBub3RlZDtcbiAgICAgICAgfSBlbHNlIGlmIChlbGVtZW50LmxvY2FsTmFtZSA9PT0gJ3Nsb3QnKSB7XG4gICAgICAgICAgLy8gRm9yIFNoYWR5RG9tIG9wdGltaXphdGlvbiwgaW5kaWNhdGluZyB0aGVyZSBpcyBhbiBpbnNlcnRpb24gcG9pbnRcbiAgICAgICAgICB0ZW1wbGF0ZUluZm8uaGFzSW5zZXJ0aW9uUG9pbnQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbGVtZW50LmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICBub3RlZCA9IHRoaXMuX3BhcnNlVGVtcGxhdGVDaGlsZE5vZGVzKGVsZW1lbnQsIHRlbXBsYXRlSW5mbywgbm9kZUluZm8pIHx8IG5vdGVkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbGVtZW50Lmhhc0F0dHJpYnV0ZXMgJiYgZWxlbWVudC5oYXNBdHRyaWJ1dGVzKCkpIHtcbiAgICAgICAgICBub3RlZCA9IHRoaXMuX3BhcnNlVGVtcGxhdGVOb2RlQXR0cmlidXRlcyhlbGVtZW50LCB0ZW1wbGF0ZUluZm8sIG5vZGVJbmZvKSB8fCBub3RlZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm90ZWQ7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUGFyc2VzIHRlbXBsYXRlIGNoaWxkIG5vZGVzIGZvciB0aGUgZ2l2ZW4gcm9vdCBub2RlLlxuICAgICAgICpcbiAgICAgICAqIFRoaXMgbWV0aG9kIGFsc28gd3JhcHMgd2hpdGVsaXN0ZWQgbGVnYWN5IHRlbXBsYXRlIGV4dGVuc2lvbnNcbiAgICAgICAqIChgaXM9XCJkb20taWZcImAgYW5kIGBpcz1cImRvbS1yZXBlYXRcImApIHdpdGggdGhlaXIgZXF1aXZhbGVudCBlbGVtZW50XG4gICAgICAgKiB3cmFwcGVycywgY29sbGFwc2VzIHRleHQgbm9kZXMsIGFuZCBzdHJpcHMgd2hpdGVzcGFjZSBmcm9tIHRoZSB0ZW1wbGF0ZVxuICAgICAgICogaWYgdGhlIGB0ZW1wbGF0ZUluZm8uc3RyaXBXaGl0ZXNwYWNlYCBzZXR0aW5nIHdhcyBwcm92aWRlZC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge05vZGV9IHJvb3QgUm9vdCBub2RlIHdob3NlIGBjaGlsZE5vZGVzYCB3aWxsIGJlIHBhcnNlZFxuICAgICAgICogQHBhcmFtIHshVGVtcGxhdGVJbmZvfSB0ZW1wbGF0ZUluZm8gVGVtcGxhdGUgbWV0YWRhdGEgZm9yIGN1cnJlbnQgdGVtcGxhdGVcbiAgICAgICAqIEBwYXJhbSB7IU5vZGVJbmZvfSBub2RlSW5mbyBOb2RlIG1ldGFkYXRhIGZvciBjdXJyZW50IHRlbXBsYXRlLlxuICAgICAgICovXG4gICAgICBzdGF0aWMgX3BhcnNlVGVtcGxhdGVDaGlsZE5vZGVzKHJvb3QsIHRlbXBsYXRlSW5mbywgbm9kZUluZm8pIHtcbiAgICAgICAgZm9yIChsZXQgbm9kZT1yb290LmZpcnN0Q2hpbGQsIHBhcmVudEluZGV4PTAsIG5leHQ7IG5vZGU7IG5vZGU9bmV4dCkge1xuICAgICAgICAgIC8vIFdyYXAgdGVtcGxhdGVzXG4gICAgICAgICAgaWYgKG5vZGUubG9jYWxOYW1lID09ICd0ZW1wbGF0ZScpIHtcbiAgICAgICAgICAgIG5vZGUgPSB3cmFwVGVtcGxhdGVFeHRlbnNpb24obm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGNvbGxhcHNlIGFkamFjZW50IHRleHROb2RlczogZml4ZXMgYW4gSUUgaXNzdWUgdGhhdCBjYW4gY2F1c2VcbiAgICAgICAgICAvLyB0ZXh0IG5vZGVzIHRvIGJlIGluZXhwbGljYWJseSBzcGxpdCA9KFxuICAgICAgICAgIC8vIG5vdGUgdGhhdCByb290Lm5vcm1hbGl6ZSgpIHNob3VsZCB3b3JrIGJ1dCBkb2VzIG5vdCBzbyB3ZSBkbyB0aGlzXG4gICAgICAgICAgLy8gbWFudWFsbHkuXG4gICAgICAgICAgbmV4dCA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFKSB7XG4gICAgICAgICAgICBsZXQgLyoqIE5vZGUgKi8gbiA9IG5leHQ7XG4gICAgICAgICAgICB3aGlsZSAobiAmJiAobi5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUpKSB7XG4gICAgICAgICAgICAgIG5vZGUudGV4dENvbnRlbnQgKz0gbi50ZXh0Q29udGVudDtcbiAgICAgICAgICAgICAgbmV4dCA9IG4ubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgIHJvb3QucmVtb3ZlQ2hpbGQobik7XG4gICAgICAgICAgICAgIG4gPSBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gb3B0aW9uYWxseSBzdHJpcCB3aGl0ZXNwYWNlXG4gICAgICAgICAgICBpZiAodGVtcGxhdGVJbmZvLnN0cmlwV2hpdGVTcGFjZSAmJiAhbm9kZS50ZXh0Q29udGVudC50cmltKCkpIHtcbiAgICAgICAgICAgICAgcm9vdC5yZW1vdmVDaGlsZChub2RlKTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCBjaGlsZEluZm8gPSB7IHBhcmVudEluZGV4LCBwYXJlbnRJbmZvOiBub2RlSW5mbyB9O1xuICAgICAgICAgIGlmICh0aGlzLl9wYXJzZVRlbXBsYXRlTm9kZShub2RlLCB0ZW1wbGF0ZUluZm8sIGNoaWxkSW5mbykpIHtcbiAgICAgICAgICAgIGNoaWxkSW5mby5pbmZvSW5kZXggPSB0ZW1wbGF0ZUluZm8ubm9kZUluZm9MaXN0LnB1c2goLyoqIEB0eXBlIHshTm9kZUluZm99ICovKGNoaWxkSW5mbykpIC0gMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gSW5jcmVtZW50IGlmIG5vdCByZW1vdmVkXG4gICAgICAgICAgaWYgKG5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgcGFyZW50SW5kZXgrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBQYXJzZXMgdGVtcGxhdGUgY29udGVudCBmb3IgdGhlIGdpdmVuIG5lc3RlZCBgPHRlbXBsYXRlPmAuXG4gICAgICAgKlxuICAgICAgICogTmVzdGVkIHRlbXBsYXRlIGluZm8gaXMgc3RvcmVkIGFzIGB0ZW1wbGF0ZUluZm9gIGluIHRoZSBjdXJyZW50IG5vZGUnc1xuICAgICAgICogYG5vZGVJbmZvYC4gYHRlbXBsYXRlLmNvbnRlbnRgIGlzIHJlbW92ZWQgYW5kIHN0b3JlZCBpbiBgdGVtcGxhdGVJbmZvYC5cbiAgICAgICAqIEl0IHdpbGwgdGhlbiBiZSB0aGUgcmVzcG9uc2liaWxpdHkgb2YgdGhlIGhvc3QgdG8gc2V0IGl0IGJhY2sgdG8gdGhlXG4gICAgICAgKiB0ZW1wbGF0ZSBhbmQgZm9yIHVzZXJzIHN0YW1waW5nIG5lc3RlZCB0ZW1wbGF0ZXMgdG8gdXNlIHRoZVxuICAgICAgICogYF9jb250ZW50Rm9yVGVtcGxhdGVgIG1ldGhvZCB0byByZXRyaWV2ZSB0aGUgY29udGVudCBmb3IgdGhpcyB0ZW1wbGF0ZVxuICAgICAgICogKGFuIG9wdGltaXphdGlvbiB0byBhdm9pZCB0aGUgY29zdCBvZiBjbG9uaW5nIG5lc3RlZCB0ZW1wbGF0ZSBjb250ZW50KS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge0hUTUxUZW1wbGF0ZUVsZW1lbnR9IG5vZGUgTm9kZSB0byBwYXJzZSAoYSA8dGVtcGxhdGU+KVxuICAgICAgICogQHBhcmFtIHtUZW1wbGF0ZUluZm99IG91dGVyVGVtcGxhdGVJbmZvIFRlbXBsYXRlIG1ldGFkYXRhIGZvciBjdXJyZW50IHRlbXBsYXRlXG4gICAgICAgKiAgIHRoYXQgaW5jbHVkZXMgdGhlIHRlbXBsYXRlIGBub2RlYFxuICAgICAgICogQHBhcmFtIHshTm9kZUluZm99IG5vZGVJbmZvIE5vZGUgbWV0YWRhdGEgZm9yIGN1cnJlbnQgdGVtcGxhdGUuXG4gICAgICAgKiBAcmV0dXJuIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIHZpc2l0ZWQgbm9kZSBhZGRlZCBub2RlLXNwZWNpZmljXG4gICAgICAgKiAgIG1ldGFkYXRhIHRvIGBub2RlSW5mb2BcbiAgICAgICAqL1xuICAgICAgc3RhdGljIF9wYXJzZVRlbXBsYXRlTmVzdGVkVGVtcGxhdGUobm9kZSwgb3V0ZXJUZW1wbGF0ZUluZm8sIG5vZGVJbmZvKSB7XG4gICAgICAgIGxldCB0ZW1wbGF0ZUluZm8gPSB0aGlzLl9wYXJzZVRlbXBsYXRlKG5vZGUsIG91dGVyVGVtcGxhdGVJbmZvKTtcbiAgICAgICAgbGV0IGNvbnRlbnQgPSB0ZW1wbGF0ZUluZm8uY29udGVudCA9XG4gICAgICAgICAgbm9kZS5jb250ZW50Lm93bmVyRG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgICAgICBjb250ZW50LmFwcGVuZENoaWxkKG5vZGUuY29udGVudCk7XG4gICAgICAgIG5vZGVJbmZvLnRlbXBsYXRlSW5mbyA9IHRlbXBsYXRlSW5mbztcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUGFyc2VzIHRlbXBsYXRlIG5vZGUgYXR0cmlidXRlcyBhbmQgYWRkcyBub2RlIG1ldGFkYXRhIHRvIGBub2RlSW5mb2BcbiAgICAgICAqIGZvciBub2RlcyBvZiBpbnRlcmVzdC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgTm9kZSB0byBwYXJzZVxuICAgICAgICogQHBhcmFtIHtUZW1wbGF0ZUluZm99IHRlbXBsYXRlSW5mbyBUZW1wbGF0ZSBtZXRhZGF0YSBmb3IgY3VycmVudCB0ZW1wbGF0ZVxuICAgICAgICogQHBhcmFtIHtOb2RlSW5mb30gbm9kZUluZm8gTm9kZSBtZXRhZGF0YSBmb3IgY3VycmVudCB0ZW1wbGF0ZS5cbiAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgdmlzaXRlZCBub2RlIGFkZGVkIG5vZGUtc3BlY2lmaWNcbiAgICAgICAqICAgbWV0YWRhdGEgdG8gYG5vZGVJbmZvYFxuICAgICAgICovXG4gICAgICBzdGF0aWMgX3BhcnNlVGVtcGxhdGVOb2RlQXR0cmlidXRlcyhub2RlLCB0ZW1wbGF0ZUluZm8sIG5vZGVJbmZvKSB7XG4gICAgICAgIC8vIE1ha2UgY29weSBvZiBvcmlnaW5hbCBhdHRyaWJ1dGUgbGlzdCwgc2luY2UgdGhlIG9yZGVyIG1heSBjaGFuZ2VcbiAgICAgICAgLy8gYXMgYXR0cmlidXRlcyBhcmUgYWRkZWQgYW5kIHJlbW92ZWRcbiAgICAgICAgbGV0IG5vdGVkID0gZmFsc2U7XG4gICAgICAgIGxldCBhdHRycyA9IEFycmF5LmZyb20obm9kZS5hdHRyaWJ1dGVzKTtcbiAgICAgICAgZm9yIChsZXQgaT1hdHRycy5sZW5ndGgtMSwgYTsgKGE9YXR0cnNbaV0pOyBpLS0pIHtcbiAgICAgICAgICBub3RlZCA9IHRoaXMuX3BhcnNlVGVtcGxhdGVOb2RlQXR0cmlidXRlKG5vZGUsIHRlbXBsYXRlSW5mbywgbm9kZUluZm8sIGEubmFtZSwgYS52YWx1ZSkgfHwgbm90ZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vdGVkO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFBhcnNlcyBhIHNpbmdsZSB0ZW1wbGF0ZSBub2RlIGF0dHJpYnV0ZSBhbmQgYWRkcyBub2RlIG1ldGFkYXRhIHRvXG4gICAgICAgKiBgbm9kZUluZm9gIGZvciBhdHRyaWJ1dGVzIG9mIGludGVyZXN0LlxuICAgICAgICpcbiAgICAgICAqIFRoaXMgaW1wbGVtZW50YXRpb24gYWRkcyBtZXRhZGF0YSBmb3IgYG9uLWV2ZW50PVwiaGFuZGxlclwiYCBhdHRyaWJ1dGVzXG4gICAgICAgKiBhbmQgYGlkYCBhdHRyaWJ1dGVzLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZSBOb2RlIHRvIHBhcnNlXG4gICAgICAgKiBAcGFyYW0geyFUZW1wbGF0ZUluZm99IHRlbXBsYXRlSW5mbyBUZW1wbGF0ZSBtZXRhZGF0YSBmb3IgY3VycmVudCB0ZW1wbGF0ZVxuICAgICAgICogQHBhcmFtIHshTm9kZUluZm99IG5vZGVJbmZvIE5vZGUgbWV0YWRhdGEgZm9yIGN1cnJlbnQgdGVtcGxhdGUuXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBBdHRyaWJ1dGUgbmFtZVxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIEF0dHJpYnV0ZSB2YWx1ZVxuICAgICAgICogQHJldHVybiB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSB2aXNpdGVkIG5vZGUgYWRkZWQgbm9kZS1zcGVjaWZpY1xuICAgICAgICogICBtZXRhZGF0YSB0byBgbm9kZUluZm9gXG4gICAgICAgKi9cbiAgICAgIHN0YXRpYyBfcGFyc2VUZW1wbGF0ZU5vZGVBdHRyaWJ1dGUobm9kZSwgdGVtcGxhdGVJbmZvLCBub2RlSW5mbywgbmFtZSwgdmFsdWUpIHtcbiAgICAgICAgLy8gZXZlbnRzIChvbi0qKVxuICAgICAgICBpZiAobmFtZS5zbGljZSgwLCAzKSA9PT0gJ29uLScpIHtcbiAgICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICAgICAgICBub2RlSW5mby5ldmVudHMgPSBub2RlSW5mby5ldmVudHMgfHwgW107XG4gICAgICAgICAgbm9kZUluZm8uZXZlbnRzLnB1c2goe1xuICAgICAgICAgICAgbmFtZTogbmFtZS5zbGljZSgzKSxcbiAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc3RhdGljIGlkXG4gICAgICAgIGVsc2UgaWYgKG5hbWUgPT09ICdpZCcpIHtcbiAgICAgICAgICBub2RlSW5mby5pZCA9IHZhbHVlO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZXR1cm5zIHRoZSBgY29udGVudGAgZG9jdW1lbnQgZnJhZ21lbnQgZm9yIGEgZ2l2ZW4gdGVtcGxhdGUuXG4gICAgICAgKlxuICAgICAgICogRm9yIG5lc3RlZCB0ZW1wbGF0ZXMsIFBvbHltZXIgcGVyZm9ybXMgYW4gb3B0aW1pemF0aW9uIHRvIGNhY2hlIG5lc3RlZFxuICAgICAgICogdGVtcGxhdGUgY29udGVudCB0byBhdm9pZCB0aGUgY29zdCBvZiBjbG9uaW5nIGRlZXBseSBuZXN0ZWQgdGVtcGxhdGVzLlxuICAgICAgICogVGhpcyBtZXRob2QgcmV0cmlldmVzIHRoZSBjYWNoZWQgY29udGVudCBmb3IgYSBnaXZlbiB0ZW1wbGF0ZS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge0hUTUxUZW1wbGF0ZUVsZW1lbnR9IHRlbXBsYXRlIFRlbXBsYXRlIHRvIHJldHJpZXZlIGBjb250ZW50YCBmb3JcbiAgICAgICAqIEByZXR1cm4ge0RvY3VtZW50RnJhZ21lbnR9IENvbnRlbnQgZnJhZ21lbnRcbiAgICAgICAqL1xuICAgICAgc3RhdGljIF9jb250ZW50Rm9yVGVtcGxhdGUodGVtcGxhdGUpIHtcbiAgICAgICAgbGV0IHRlbXBsYXRlSW5mbyA9IC8qKiBAdHlwZSB7SFRNTFRlbXBsYXRlRWxlbWVudFdpdGhJbmZvfSAqLyAodGVtcGxhdGUpLl90ZW1wbGF0ZUluZm87XG4gICAgICAgIHJldHVybiAodGVtcGxhdGVJbmZvICYmIHRlbXBsYXRlSW5mby5jb250ZW50KSB8fCB0ZW1wbGF0ZS5jb250ZW50O1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENsb25lcyB0aGUgcHJvdmlkZWQgdGVtcGxhdGUgY29udGVudCBhbmQgcmV0dXJucyBhIGRvY3VtZW50IGZyYWdtZW50XG4gICAgICAgKiBjb250YWluaW5nIHRoZSBjbG9uZWQgZG9tLlxuICAgICAgICpcbiAgICAgICAqIFRoZSB0ZW1wbGF0ZSBpcyBwYXJzZWQgKG9uY2UgYW5kIG1lbW9pemVkKSB1c2luZyB0aGlzIGxpYnJhcnknc1xuICAgICAgICogdGVtcGxhdGUgcGFyc2luZyBmZWF0dXJlcywgYW5kIHByb3ZpZGVzIHRoZSBmb2xsb3dpbmcgdmFsdWUtYWRkZWRcbiAgICAgICAqIGZlYXR1cmVzOlxuICAgICAgICogKiBBZGRzIGRlY2xhcmF0aXZlIGV2ZW50IGxpc3RlbmVycyBmb3IgYG9uLWV2ZW50PVwiaGFuZGxlclwiYCBhdHRyaWJ1dGVzXG4gICAgICAgKiAqIEdlbmVyYXRlcyBhbiBcImlkIG1hcFwiIGZvciBhbGwgbm9kZXMgd2l0aCBpZCdzIHVuZGVyIGAkYCBvbiByZXR1cm5lZFxuICAgICAgICogICBkb2N1bWVudCBmcmFnbWVudFxuICAgICAgICogKiBQYXNzZXMgdGVtcGxhdGUgaW5mbyBpbmNsdWRpbmcgYGNvbnRlbnRgIGJhY2sgdG8gdGVtcGxhdGVzIGFzXG4gICAgICAgKiAgIGBfdGVtcGxhdGVJbmZvYCAoYSBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb24gdG8gYXZvaWQgZGVlcCB0ZW1wbGF0ZVxuICAgICAgICogICBjbG9uaW5nKVxuICAgICAgICpcbiAgICAgICAqIE5vdGUgdGhhdCB0aGUgbWVtb2l6ZWQgdGVtcGxhdGUgcGFyc2luZyBwcm9jZXNzIGlzIGRlc3RydWN0aXZlIHRvIHRoZVxuICAgICAgICogdGVtcGxhdGU6IGF0dHJpYnV0ZXMgZm9yIGJpbmRpbmdzIGFuZCBkZWNsYXJhdGl2ZSBldmVudCBsaXN0ZW5lcnMgYXJlXG4gICAgICAgKiByZW1vdmVkIGFmdGVyIGJlaW5nIG5vdGVkIGluIG5vdGVzLCBhbmQgYW55IG5lc3RlZCBgPHRlbXBsYXRlPi5jb250ZW50YFxuICAgICAgICogaXMgcmVtb3ZlZCBhbmQgc3RvcmVkIGluIG5vdGVzIGFzIHdlbGwuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHshSFRNTFRlbXBsYXRlRWxlbWVudH0gdGVtcGxhdGUgVGVtcGxhdGUgdG8gc3RhbXBcbiAgICAgICAqIEByZXR1cm4geyFTdGFtcGVkVGVtcGxhdGV9IENsb25lZCB0ZW1wbGF0ZSBjb250ZW50XG4gICAgICAgKi9cbiAgICAgIF9zdGFtcFRlbXBsYXRlKHRlbXBsYXRlKSB7XG4gICAgICAgIC8vIFBvbHlmaWxsIHN1cHBvcnQ6IGJvb3RzdHJhcCB0aGUgdGVtcGxhdGUgaWYgaXQgaGFzIG5vdCBhbHJlYWR5IGJlZW5cbiAgICAgICAgaWYgKHRlbXBsYXRlICYmICF0ZW1wbGF0ZS5jb250ZW50ICYmXG4gICAgICAgICAgICB3aW5kb3cuSFRNTFRlbXBsYXRlRWxlbWVudCAmJiBIVE1MVGVtcGxhdGVFbGVtZW50LmRlY29yYXRlKSB7XG4gICAgICAgICAgSFRNTFRlbXBsYXRlRWxlbWVudC5kZWNvcmF0ZSh0ZW1wbGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRlbXBsYXRlSW5mbyA9IHRoaXMuY29uc3RydWN0b3IuX3BhcnNlVGVtcGxhdGUodGVtcGxhdGUpO1xuICAgICAgICBsZXQgbm9kZUluZm8gPSB0ZW1wbGF0ZUluZm8ubm9kZUluZm9MaXN0O1xuICAgICAgICBsZXQgY29udGVudCA9IHRlbXBsYXRlSW5mby5jb250ZW50IHx8IHRlbXBsYXRlLmNvbnRlbnQ7XG4gICAgICAgIGxldCBkb20gPSAvKiogQHR5cGUgRG9jdW1lbnRGcmFnbWVudCAqLyAoZG9jdW1lbnQuaW1wb3J0Tm9kZShjb250ZW50LCB0cnVlKSk7XG4gICAgICAgIC8vIE5PVEU6IFNoYWR5RG9tIG9wdGltaXphdGlvbiBpbmRpY2F0aW5nIHRoZXJlIGlzIGFuIGluc2VydGlvbiBwb2ludFxuICAgICAgICBkb20uX19ub0luc2VydGlvblBvaW50ID0gIXRlbXBsYXRlSW5mby5oYXNJbnNlcnRpb25Qb2ludDtcbiAgICAgICAgbGV0IG5vZGVzID0gZG9tLm5vZGVMaXN0ID0gbmV3IEFycmF5KG5vZGVJbmZvLmxlbmd0aCk7XG4gICAgICAgIGRvbS4kID0ge307XG4gICAgICAgIGZvciAobGV0IGk9MCwgbD1ub2RlSW5mby5sZW5ndGgsIGluZm87IChpPGwpICYmIChpbmZvPW5vZGVJbmZvW2ldKTsgaSsrKSB7XG4gICAgICAgICAgbGV0IG5vZGUgPSBub2Rlc1tpXSA9IGZpbmRUZW1wbGF0ZU5vZGUoZG9tLCBpbmZvKTtcbiAgICAgICAgICBhcHBseUlkVG9NYXAodGhpcywgZG9tLiQsIG5vZGUsIGluZm8pO1xuICAgICAgICAgIGFwcGx5VGVtcGxhdGVDb250ZW50KHRoaXMsIG5vZGUsIGluZm8pO1xuICAgICAgICAgIGFwcGx5RXZlbnRMaXN0ZW5lcih0aGlzLCBub2RlLCBpbmZvKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLyoqIEB0eXBlIHshU3RhbXBlZFRlbXBsYXRlfSAqLyhkb20pO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEFkZHMgYW4gZXZlbnQgbGlzdGVuZXIgYnkgbWV0aG9kIG5hbWUgZm9yIHRoZSBldmVudCBwcm92aWRlZC5cbiAgICAgICAqXG4gICAgICAgKiBUaGlzIG1ldGhvZCBnZW5lcmF0ZXMgYSBoYW5kbGVyIGZ1bmN0aW9uIHRoYXQgbG9va3MgdXAgdGhlIG1ldGhvZFxuICAgICAgICogbmFtZSBhdCBoYW5kbGluZyB0aW1lLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBOb2RlIHRvIGFkZCBsaXN0ZW5lciBvblxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBOYW1lIG9mIGV2ZW50XG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kTmFtZSBOYW1lIG9mIG1ldGhvZFxuICAgICAgICogQHBhcmFtIHsqPX0gY29udGV4dCBDb250ZXh0IHRoZSBtZXRob2Qgd2lsbCBiZSBjYWxsZWQgb24gKGRlZmF1bHRzXG4gICAgICAgKiAgIHRvIGBub2RlYClcbiAgICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBHZW5lcmF0ZWQgaGFuZGxlciBmdW5jdGlvblxuICAgICAgICovXG4gICAgICBfYWRkTWV0aG9kRXZlbnRMaXN0ZW5lclRvTm9kZShub2RlLCBldmVudE5hbWUsIG1ldGhvZE5hbWUsIGNvbnRleHQpIHtcbiAgICAgICAgY29udGV4dCA9IGNvbnRleHQgfHwgbm9kZTtcbiAgICAgICAgbGV0IGhhbmRsZXIgPSBjcmVhdGVOb2RlRXZlbnRIYW5kbGVyKGNvbnRleHQsIGV2ZW50TmFtZSwgbWV0aG9kTmFtZSk7XG4gICAgICAgIHRoaXMuX2FkZEV2ZW50TGlzdGVuZXJUb05vZGUobm9kZSwgZXZlbnROYW1lLCBoYW5kbGVyKTtcbiAgICAgICAgcmV0dXJuIGhhbmRsZXI7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogT3ZlcnJpZGUgcG9pbnQgZm9yIGFkZGluZyBjdXN0b20gb3Igc2ltdWxhdGVkIGV2ZW50IGhhbmRsaW5nLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBOb2RlIHRvIGFkZCBldmVudCBsaXN0ZW5lciB0b1xuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBOYW1lIG9mIGV2ZW50XG4gICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIExpc3RlbmVyIGZ1bmN0aW9uIHRvIGFkZFxuICAgICAgICovXG4gICAgICBfYWRkRXZlbnRMaXN0ZW5lclRvTm9kZShub2RlLCBldmVudE5hbWUsIGhhbmRsZXIpIHtcbiAgICAgICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgaGFuZGxlcik7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogT3ZlcnJpZGUgcG9pbnQgZm9yIGFkZGluZyBjdXN0b20gb3Igc2ltdWxhdGVkIGV2ZW50IGhhbmRsaW5nLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBOb2RlIHRvIHJlbW92ZSBldmVudCBsaXN0ZW5lciBmcm9tXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIE5hbWUgb2YgZXZlbnRcbiAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIgTGlzdGVuZXIgZnVuY3Rpb24gdG8gcmVtb3ZlXG4gICAgICAgKi9cbiAgICAgIF9yZW1vdmVFdmVudExpc3RlbmVyRnJvbU5vZGUobm9kZSwgZXZlbnROYW1lLCBoYW5kbGVyKSB7XG4gICAgICAgIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGhhbmRsZXIpO1xuICAgICAgfVxuXG4gICAgfVxuXG4gICAgcmV0dXJuIFRlbXBsYXRlU3RhbXA7XG5cbiAgfSk7XG5cbn0pKCk7XG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvbWl4aW5zL3RlbXBsYXRlLXN0YW1wLmh0bWwiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE1IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi8uLi9wb2x5bWVyL3BvbHltZXIuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uLy4uL2lyb24tZmxleC1sYXlvdXQvaXJvbi1mbGV4LWxheW91dC5odG1sXCI+XG5cbjwhLS1cbmFwcC1kcmF3ZXIgaXMgYSBuYXZpZ2F0aW9uIGRyYXdlciB0aGF0IGNhbiBzbGlkZSBpbiBmcm9tIHRoZSBsZWZ0IG9yIHJpZ2h0LlxuXG5FeGFtcGxlOlxuXG5BbGlnbiB0aGUgZHJhd2VyIGF0IHRoZSBzdGFydCwgd2hpY2ggaXMgbGVmdCBpbiBMVFIgbGF5b3V0cyAoZGVmYXVsdCk6XG5cbmBgYGh0bWxcbjxhcHAtZHJhd2VyIG9wZW5lZD48L2FwcC1kcmF3ZXI+XG5gYGBcblxuQWxpZ24gdGhlIGRyYXdlciBhdCB0aGUgZW5kOlxuXG5gYGBodG1sXG48YXBwLWRyYXdlciBhbGlnbj1cImVuZFwiIG9wZW5lZD48L2FwcC1kcmF3ZXI+XG5gYGBcblxuVG8gbWFrZSB0aGUgY29udGVudHMgb2YgdGhlIGRyYXdlciBzY3JvbGxhYmxlLCBjcmVhdGUgYSB3cmFwcGVyIGZvciB0aGUgc2Nyb2xsXG5jb250ZW50LCBhbmQgYXBwbHkgaGVpZ2h0IGFuZCBvdmVyZmxvdyBzdHlsZXMgdG8gaXQuXG5cbmBgYGh0bWxcbjxhcHAtZHJhd2VyPlxuICA8ZGl2IHN0eWxlPVwiaGVpZ2h0OiAxMDAlOyBvdmVyZmxvdzogYXV0bztcIj48L2Rpdj5cbjwvYXBwLWRyYXdlcj5cbmBgYFxuXG4jIyMgU3R5bGluZ1xuXG5DdXN0b20gcHJvcGVydHkgICAgICAgICAgICAgICAgICB8IERlc2NyaXB0aW9uICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgRGVmYXVsdFxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18LS0tLS0tLS0tLS0tLS0tLS0tLS1cbmAtLWFwcC1kcmF3ZXItd2lkdGhgICAgICAgICAgICAgIHwgV2lkdGggb2YgdGhlIGRyYXdlciAgICAgICAgICAgICAgICAgICAgfCAyNTZweFxuYC0tYXBwLWRyYXdlci1jb250ZW50LWNvbnRhaW5lcmAgfCBNaXhpbiBmb3IgdGhlIGRyYXdlciBjb250ZW50IGNvbnRhaW5lciB8IHt9XG5gLS1hcHAtZHJhd2VyLXNjcmltLWJhY2tncm91bmRgICB8IEJhY2tncm91bmQgZm9yIHRoZSBzY3JpbSAgICAgICAgICAgICAgIHwgcmdiYSgwLCAwLCAwLCAwLjUpXG5cbioqTk9URToqKiBJZiB5b3UgdXNlIDxhcHAtZHJhd2VyPiB3aXRoIDxhcHAtZHJhd2VyLWxheW91dD4gYW5kIHNwZWNpZnkgYSB2YWx1ZSBmb3JcbmAtLWFwcC1kcmF3ZXItd2lkdGhgLCB0aGF0IHZhbHVlIG11c3QgYmUgYWNjZXNzaWJsZSBieSBib3RoIGVsZW1lbnRzLiBUaGlzIGNhbiBiZSBkb25lIGJ5XG5kZWZpbmluZyB0aGUgdmFsdWUgb24gdGhlIGA6aG9zdGAgdGhhdCBjb250YWlucyA8YXBwLWRyYXdlci1sYXlvdXQ+IChvciBgaHRtbGAgaWYgb3V0c2lkZVxuYSBzaGFkb3cgcm9vdCk6XG5cbmBgYGNzc1xuOmhvc3Qge1xuICAtLWFwcC1kcmF3ZXItd2lkdGg6IDMwMHB4O1xufVxuYGBgXG5cbkBncm91cCBBcHAgRWxlbWVudHNcbkBlbGVtZW50IGFwcC1kcmF3ZXJcbkBkZW1vIGFwcC1kcmF3ZXIvZGVtby9sZWZ0LWRyYXdlci5odG1sIFNpbXBsZSBMZWZ0IERyYXdlclxuQGRlbW8gYXBwLWRyYXdlci9kZW1vL3JpZ2h0LWRyYXdlci5odG1sIFJpZ2h0IERyYXdlciB3aXRoIEljb25zXG4tLT5cblxuPGRvbS1tb2R1bGUgaWQ9XCJhcHAtZHJhd2VyXCI+XG4gIDx0ZW1wbGF0ZT5cbiAgICA8c3R5bGU+XG4gICAgICA6aG9zdCB7XG4gICAgICAgIHBvc2l0aW9uOiBmaXhlZDtcbiAgICAgICAgdG9wOiAtMTIwcHg7XG4gICAgICAgIHJpZ2h0OiAwO1xuICAgICAgICBib3R0b206IC0xMjBweDtcbiAgICAgICAgbGVmdDogMDtcblxuICAgICAgICB2aXNpYmlsaXR5OiBoaWRkZW47XG5cbiAgICAgICAgdHJhbnNpdGlvbi1wcm9wZXJ0eTogdmlzaWJpbGl0eTtcbiAgICAgIH1cblxuICAgICAgOmhvc3QoW29wZW5lZF0pIHtcbiAgICAgICAgdmlzaWJpbGl0eTogdmlzaWJsZTtcbiAgICAgIH1cblxuICAgICAgOmhvc3QoW3BlcnNpc3RlbnRdKSB7XG4gICAgICAgIHdpZHRoOiB2YXIoLS1hcHAtZHJhd2VyLXdpZHRoLCAyNTZweCk7XG4gICAgICB9XG5cbiAgICAgIDpob3N0KFtwZXJzaXN0ZW50XVtwb3NpdGlvbj1sZWZ0XSkge1xuICAgICAgICByaWdodDogYXV0bztcbiAgICAgIH1cblxuICAgICAgOmhvc3QoW3BlcnNpc3RlbnRdW3Bvc2l0aW9uPXJpZ2h0XSkge1xuICAgICAgICBsZWZ0OiBhdXRvO1xuICAgICAgfVxuXG4gICAgICAjY29udGVudENvbnRhaW5lciB7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgdG9wOiAwO1xuICAgICAgICBib3R0b206IDA7XG4gICAgICAgIGxlZnQ6IDA7XG5cbiAgICAgICAgd2lkdGg6IHZhcigtLWFwcC1kcmF3ZXItd2lkdGgsIDI1NnB4KTtcbiAgICAgICAgcGFkZGluZzogMTIwcHggMDtcblxuICAgICAgICB0cmFuc2l0aW9uLXByb3BlcnR5OiAtd2Via2l0LXRyYW5zZm9ybTtcbiAgICAgICAgdHJhbnNpdGlvbi1wcm9wZXJ0eTogdHJhbnNmb3JtO1xuICAgICAgICAtd2Via2l0LXRyYW5zZm9ybTogdHJhbnNsYXRlM2QoLTEwMCUsIDAsIDApO1xuICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKC0xMDAlLCAwLCAwKTtcblxuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjRkZGO1xuXG4gICAgICAgIEBhcHBseSAtLWFwcC1kcmF3ZXItY29udGVudC1jb250YWluZXI7XG4gICAgICB9XG5cbiAgICAgICNjb250ZW50Q29udGFpbmVyW3BlcnNpc3RlbnRdIHtcbiAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICB9XG5cbiAgICAgICNjb250ZW50Q29udGFpbmVyW3Bvc2l0aW9uPXJpZ2h0XSB7XG4gICAgICAgIHJpZ2h0OiAwO1xuICAgICAgICBsZWZ0OiBhdXRvO1xuXG4gICAgICAgIC13ZWJraXQtdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgxMDAlLCAwLCAwKTtcbiAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgxMDAlLCAwLCAwKTtcbiAgICAgIH1cblxuICAgICAgI2NvbnRlbnRDb250YWluZXJbc3dpcGUtb3Blbl06OmFmdGVyIHtcbiAgICAgICAgcG9zaXRpb246IGZpeGVkO1xuICAgICAgICB0b3A6IDA7XG4gICAgICAgIGJvdHRvbTogMDtcbiAgICAgICAgbGVmdDogMTAwJTtcblxuICAgICAgICB2aXNpYmlsaXR5OiB2aXNpYmxlO1xuXG4gICAgICAgIHdpZHRoOiAyMHB4O1xuXG4gICAgICAgIGNvbnRlbnQ6ICcnO1xuICAgICAgfVxuXG4gICAgICAjY29udGVudENvbnRhaW5lcltzd2lwZS1vcGVuXVtwb3NpdGlvbj1yaWdodF06OmFmdGVyIHtcbiAgICAgICAgcmlnaHQ6IDEwMCU7XG4gICAgICAgIGxlZnQ6IGF1dG87XG4gICAgICB9XG5cbiAgICAgICNjb250ZW50Q29udGFpbmVyW29wZW5lZF0ge1xuICAgICAgICAtd2Via2l0LXRyYW5zZm9ybTogdHJhbnNsYXRlM2QoMCwgMCwgMCk7XG4gICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoMCwgMCwgMCk7XG4gICAgICB9XG5cbiAgICAgICNzY3JpbSB7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgdG9wOiAwO1xuICAgICAgICByaWdodDogMDtcbiAgICAgICAgYm90dG9tOiAwO1xuICAgICAgICBsZWZ0OiAwO1xuXG4gICAgICAgIHRyYW5zaXRpb24tcHJvcGVydHk6IG9wYWNpdHk7XG4gICAgICAgIC13ZWJraXQtdHJhbnNmb3JtOiB0cmFuc2xhdGVaKDApO1xuICAgICAgICB0cmFuc2Zvcm06ICB0cmFuc2xhdGVaKDApO1xuXG4gICAgICAgIG9wYWNpdHk6IDA7XG4gICAgICAgIGJhY2tncm91bmQ6IHZhcigtLWFwcC1kcmF3ZXItc2NyaW0tYmFja2dyb3VuZCwgcmdiYSgwLCAwLCAwLCAwLjUpKTtcbiAgICAgIH1cblxuICAgICAgI3NjcmltLnZpc2libGUge1xuICAgICAgICBvcGFjaXR5OiAxO1xuICAgICAgfVxuXG4gICAgICA6aG9zdChbbm8tdHJhbnNpdGlvbl0pICNjb250ZW50Q29udGFpbmVyIHtcbiAgICAgICAgdHJhbnNpdGlvbi1wcm9wZXJ0eTogbm9uZTtcbiAgICAgIH1cbiAgICA8L3N0eWxlPlxuXG4gICAgPGRpdiBpZD1cInNjcmltXCIgb24tY2xpY2s9XCJjbG9zZVwiPjwvZGl2PlxuXG4gICAgPCEtLSBIQUNLKGtlYW51bGVlKTogQmluZCBhdHRyaWJ1dGVzIGhlcmUgKGluIGFkZGl0aW9uIHRvIDpob3N0KSBmb3Igc3R5bGluZyB0byB3b3JrYXJvdW5kIFNhZmFyaVxuICAgIGJ1Zy4gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE3MDc2MiAtLT5cbiAgICA8ZGl2IGlkPVwiY29udGVudENvbnRhaW5lclwiIG9wZW5lZCQ9XCJbW29wZW5lZF1dXCIgcGVyc2lzdGVudCQ9XCJbW3BlcnNpc3RlbnRdXVwiXG4gICAgICAgIHBvc2l0aW9uJD1cIltbcG9zaXRpb25dXVwiIHN3aXBlLW9wZW4kPVwiW1tzd2lwZU9wZW5dXVwiPlxuICAgICAgPHNsb3Q+PC9zbG90PlxuICAgIDwvZGl2PlxuICA8L3RlbXBsYXRlPlxuXG4gIDxzY3JpcHQ+XG5cbiAgICBQb2x5bWVyKHtcbiAgICAgIGlzOiAnYXBwLWRyYXdlcicsXG5cbiAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBvcGVuZWQgc3RhdGUgb2YgdGhlIGRyYXdlci5cbiAgICAgICAgICovXG4gICAgICAgIG9wZW5lZDoge1xuICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgICAgdmFsdWU6IGZhbHNlLFxuICAgICAgICAgIG5vdGlmeTogdHJ1ZSxcbiAgICAgICAgICByZWZsZWN0VG9BdHRyaWJ1dGU6IHRydWVcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGRyYXdlciBkb2VzIG5vdCBoYXZlIGEgc2NyaW0gYW5kIGNhbm5vdCBiZSBzd2lwZWQgY2xvc2UuXG4gICAgICAgICAqL1xuICAgICAgICBwZXJzaXN0ZW50OiB7XG4gICAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgICB2YWx1ZTogZmFsc2UsXG4gICAgICAgICAgcmVmbGVjdFRvQXR0cmlidXRlOiB0cnVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0cmFuc2l0aW9uIGR1cmF0aW9uIG9mIHRoZSBkcmF3ZXIgaW4gbWlsbGlzZWNvbmRzLlxuICAgICAgICAgKi9cbiAgICAgICAgdHJhbnNpdGlvbkR1cmF0aW9uOiB7XG4gICAgICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgICAgIHZhbHVlOiAyMDBcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGFsaWdubWVudCBvZiB0aGUgZHJhd2VyIG9uIHRoZSBzY3JlZW4gKCdsZWZ0JywgJ3JpZ2h0JywgJ3N0YXJ0JyBvciAnZW5kJykuXG4gICAgICAgICAqICdzdGFydCcgY29tcHV0ZXMgdG8gbGVmdCBhbmQgJ2VuZCcgdG8gcmlnaHQgaW4gTFRSIGxheW91dCBhbmQgdmljZSB2ZXJzYSBpbiBSVExcbiAgICAgICAgICogbGF5b3V0LlxuICAgICAgICAgKi9cbiAgICAgICAgYWxpZ246IHtcbiAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgdmFsdWU6ICdsZWZ0J1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY29tcHV0ZWQsIHJlYWQtb25seSBwb3NpdGlvbiBvZiB0aGUgZHJhd2VyIG9uIHRoZSBzY3JlZW4gKCdsZWZ0JyBvciAncmlnaHQnKS5cbiAgICAgICAgICovXG4gICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgIHJlYWRPbmx5OiB0cnVlLFxuICAgICAgICAgIHJlZmxlY3RUb0F0dHJpYnV0ZTogdHJ1ZVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgYW4gYXJlYSBhdCB0aGUgZWRnZSBvZiB0aGUgc2NyZWVuIHRvIHN3aXBlIG9wZW4gdGhlIGRyYXdlci5cbiAgICAgICAgICovXG4gICAgICAgIHN3aXBlT3Blbjoge1xuICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgICAgdmFsdWU6IGZhbHNlLFxuICAgICAgICAgIHJlZmxlY3RUb0F0dHJpYnV0ZTogdHJ1ZVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcmFwIGtleWJvYXJkIGZvY3VzIHdoZW4gdGhlIGRyYXdlciBpcyBvcGVuZWQgYW5kIG5vdCBwZXJzaXN0ZW50LlxuICAgICAgICAgKi9cbiAgICAgICAgbm9Gb2N1c1RyYXA6IHtcbiAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEaXNhYmxlcyBzd2lwaW5nIG9uIHRoZSBkcmF3ZXIuXG4gICAgICAgICAqL1xuICAgICAgICBkaXNhYmxlU3dpcGU6IHtcbiAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBvYnNlcnZlcnM6IFtcbiAgICAgICAgJ3Jlc2V0TGF5b3V0KHBvc2l0aW9uLCBpc0F0dGFjaGVkKScsXG4gICAgICAgICdfcmVzZXRQb3NpdGlvbihhbGlnbiwgaXNBdHRhY2hlZCknLFxuICAgICAgICAnX3N0eWxlVHJhbnNpdGlvbkR1cmF0aW9uKHRyYW5zaXRpb25EdXJhdGlvbiknLFxuICAgICAgICAnX29wZW5lZFBlcnNpc3RlbnRDaGFuZ2VkKG9wZW5lZCwgcGVyc2lzdGVudCknXG4gICAgICBdLFxuXG4gICAgICBfdHJhbnNsYXRlT2Zmc2V0OiAwLFxuXG4gICAgICBfdHJhY2tEZXRhaWxzOiBudWxsLFxuXG4gICAgICBfZHJhd2VyU3RhdGU6IDAsXG5cbiAgICAgIF9ib3VuZEVzY0tleWRvd25IYW5kbGVyOiBudWxsLFxuXG4gICAgICBfZmlyc3RUYWJTdG9wOiBudWxsLFxuXG4gICAgICBfbGFzdFRhYlN0b3A6IG51bGwsXG5cbiAgICAgIGF0dGFjaGVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgUG9seW1lci5SZW5kZXJTdGF0dXMuYWZ0ZXJOZXh0UmVuZGVyKHRoaXMsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHRoaXMuX2JvdW5kRXNjS2V5ZG93bkhhbmRsZXIgPSB0aGlzLl9lc2NLZXlkb3duSGFuZGxlci5iaW5kKHRoaXMpO1xuICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuX3RhYktleWRvd25IYW5kbGVyLmJpbmQodGhpcykpXG5cbiAgICAgICAgICAvLyBPbmx5IGxpc3RlbiBmb3IgaG9yaXpvbnRhbCB0cmFjayBzbyB5b3UgY2FuIHZlcnRpY2FsbHkgc2Nyb2xsIGluc2lkZSB0aGUgZHJhd2VyLlxuICAgICAgICAgIHRoaXMubGlzdGVuKHRoaXMsICd0cmFjaycsICdfdHJhY2snKTtcbiAgICAgICAgICB0aGlzLnNldFNjcm9sbERpcmVjdGlvbigneScpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmZpcmUoJ2FwcC1yZXNldC1sYXlvdXQnKTtcbiAgICAgIH0sXG5cbiAgICAgIGRldGFjaGVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuX2JvdW5kRXNjS2V5ZG93bkhhbmRsZXIpO1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBPcGVucyB0aGUgZHJhd2VyLlxuICAgICAgICovXG4gICAgICBvcGVuOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5vcGVuZWQgPSB0cnVlO1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBDbG9zZXMgdGhlIGRyYXdlci5cbiAgICAgICAqL1xuICAgICAgY2xvc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLm9wZW5lZCA9IGZhbHNlO1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBUb2dnbGVzIHRoZSBkcmF3ZXIgb3BlbiBhbmQgY2xvc2UuXG4gICAgICAgKi9cbiAgICAgIHRvZ2dsZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMub3BlbmVkID0gIXRoaXMub3BlbmVkO1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBHZXRzIHRoZSB3aWR0aCBvZiB0aGUgZHJhd2VyLlxuICAgICAgICpcbiAgICAgICAqIEByZXR1cm4ge251bWJlcn0gVGhlIHdpZHRoIG9mIHRoZSBkcmF3ZXIgaW4gcGl4ZWxzLlxuICAgICAgICovXG4gICAgICBnZXRXaWR0aDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zYXZlZFdpZHRoIHx8IHRoaXMuJC5jb250ZW50Q29udGFpbmVyLm9mZnNldFdpZHRoO1xuICAgICAgfSxcblxuICAgICAgX2lzUlRMOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMpLmRpcmVjdGlvbiA9PT0gJ3J0bCc7XG4gICAgICB9LFxuXG4gICAgICBfcmVzZXRQb3NpdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5hbGlnbikge1xuICAgICAgICAgIGNhc2UgJ3N0YXJ0JzpcbiAgICAgICAgICAgIHRoaXMuX3NldFBvc2l0aW9uKHRoaXMuX2lzUlRMKCkgPyAncmlnaHQnIDogJ2xlZnQnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBjYXNlICdlbmQnOlxuICAgICAgICAgICAgdGhpcy5fc2V0UG9zaXRpb24odGhpcy5faXNSVEwoKSA/ICdsZWZ0JyA6ICdyaWdodCcpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NldFBvc2l0aW9uKHRoaXMuYWxpZ24pO1xuICAgICAgfSxcblxuICAgICAgX2VzY0tleWRvd25IYW5kbGVyOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICB2YXIgRVNDX0tFWUNPREUgPSAyNztcbiAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT09IEVTQ19LRVlDT0RFKSB7XG4gICAgICAgICAgLy8gUHJldmVudCBhbnkgc2lkZSBlZmZlY3RzIGlmIGFwcC1kcmF3ZXIgY2xvc2VzLlxuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBfdHJhY2s6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLnBlcnNpc3RlbnQgfHwgdGhpcy5kaXNhYmxlU3dpcGUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEaXNhYmxlIHVzZXIgc2VsZWN0aW9uIG9uIGRlc2t0b3AuXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgc3dpdGNoIChldmVudC5kZXRhaWwuc3RhdGUpIHtcbiAgICAgICAgICBjYXNlICdzdGFydCc6XG4gICAgICAgICAgICB0aGlzLl90cmFja1N0YXJ0KGV2ZW50KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3RyYWNrJzpcbiAgICAgICAgICAgIHRoaXMuX3RyYWNrTW92ZShldmVudCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdlbmQnOlxuICAgICAgICAgICAgdGhpcy5fdHJhY2tFbmQoZXZlbnQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIF90cmFja1N0YXJ0OiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICB0aGlzLl9kcmF3ZXJTdGF0ZSA9IHRoaXMuX0RSQVdFUl9TVEFURS5UUkFDS0lORztcblxuICAgICAgICB2YXIgcmVjdCA9IHRoaXMuJC5jb250ZW50Q29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB0aGlzLl9zYXZlZFdpZHRoID0gcmVjdC53aWR0aDtcbiAgICAgICAgaWYgKHRoaXMucG9zaXRpb24gPT09ICdsZWZ0Jykge1xuICAgICAgICAgIHRoaXMuX3RyYW5zbGF0ZU9mZnNldCA9IHJlY3QubGVmdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl90cmFuc2xhdGVPZmZzZXQgPSByZWN0LnJpZ2h0IC0gd2luZG93LmlubmVyV2lkdGg7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl90cmFja0RldGFpbHMgPSBbXTtcblxuICAgICAgICAvLyBEaXNhYmxlIHRyYW5zaXRpb25zIHNpbmNlIHN0eWxlIGF0dHJpYnV0ZXMgd2lsbCByZWZsZWN0IHVzZXIgdHJhY2sgZXZlbnRzLlxuICAgICAgICB0aGlzLl9zdHlsZVRyYW5zaXRpb25EdXJhdGlvbigwKTtcbiAgICAgICAgdGhpcy5zdHlsZS52aXNpYmlsaXR5ID0gJ3Zpc2libGUnO1xuICAgICAgfSxcblxuICAgICAgX3RyYWNrTW92ZTogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgdGhpcy5fdHJhbnNsYXRlRHJhd2VyKGV2ZW50LmRldGFpbC5keCArIHRoaXMuX3RyYW5zbGF0ZU9mZnNldCk7XG5cbiAgICAgICAgLy8gVXNlIERhdGUubm93KCkgc2luY2UgZXZlbnQudGltZVN0YW1wIGlzIGluY29uc2lzdGVudCBhY3Jvc3MgYnJvd3NlcnMgKGUuZy4gbW9zdFxuICAgICAgICAvLyBicm93c2VycyB1c2UgbWlsbGlzZWNvbmRzIGJ1dCBGRiA0NCB1c2VzIG1pY3Jvc2Vjb25kcykuXG4gICAgICAgIHRoaXMuX3RyYWNrRGV0YWlscy5wdXNoKHtcbiAgICAgICAgICBkeDogZXZlbnQuZGV0YWlsLmR4LFxuICAgICAgICAgIHRpbWVTdGFtcDogRGF0ZS5ub3coKVxuICAgICAgICB9KTtcbiAgICAgIH0sXG5cbiAgICAgIF90cmFja0VuZDogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgdmFyIHggPSBldmVudC5kZXRhaWwuZHggKyB0aGlzLl90cmFuc2xhdGVPZmZzZXQ7XG4gICAgICAgIHZhciBkcmF3ZXJXaWR0aCA9IHRoaXMuZ2V0V2lkdGgoKTtcbiAgICAgICAgdmFyIGlzUG9zaXRpb25MZWZ0ID0gdGhpcy5wb3NpdGlvbiA9PT0gJ2xlZnQnO1xuICAgICAgICB2YXIgaXNJbkVuZFN0YXRlID0gaXNQb3NpdGlvbkxlZnQgPyAoeCA+PSAwIHx8IHggPD0gLWRyYXdlcldpZHRoKSA6XG4gICAgICAgICAgKHggPD0gMCB8fCB4ID49IGRyYXdlcldpZHRoKTtcblxuICAgICAgICBpZiAoIWlzSW5FbmRTdGF0ZSkge1xuICAgICAgICAgIC8vIE5vIGxvbmdlciBuZWVkIHRoZSB0cmFjayBldmVudHMgYWZ0ZXIgdGhpcyBtZXRob2QgcmV0dXJucyAtIGFsbG93IHRoZW0gdG8gYmUgR0MnZC5cbiAgICAgICAgICB2YXIgdHJhY2tEZXRhaWxzID0gdGhpcy5fdHJhY2tEZXRhaWxzO1xuICAgICAgICAgIHRoaXMuX3RyYWNrRGV0YWlscyA9IG51bGw7XG5cbiAgICAgICAgICB0aGlzLl9mbGluZ0RyYXdlcihldmVudCwgdHJhY2tEZXRhaWxzKTtcbiAgICAgICAgICBpZiAodGhpcy5fZHJhd2VyU3RhdGUgPT09IHRoaXMuX0RSQVdFUl9TVEFURS5GTElOR0lORykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHRoZSBkcmF3ZXIgaXMgbm90IGZsaW5naW5nLCB0b2dnbGUgdGhlIG9wZW5lZCBzdGF0ZSBiYXNlZCBvbiB0aGUgcG9zaXRpb24gb2ZcbiAgICAgICAgLy8gdGhlIGRyYXdlci5cbiAgICAgICAgdmFyIGhhbGZXaWR0aCA9IGRyYXdlcldpZHRoIC8gMjtcbiAgICAgICAgaWYgKGV2ZW50LmRldGFpbC5keCA8IC1oYWxmV2lkdGgpIHtcbiAgICAgICAgICB0aGlzLm9wZW5lZCA9IHRoaXMucG9zaXRpb24gPT09ICdyaWdodCc7XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnQuZGV0YWlsLmR4ID4gaGFsZldpZHRoKSB7XG4gICAgICAgICAgdGhpcy5vcGVuZWQgPSB0aGlzLnBvc2l0aW9uID09PSAnbGVmdCc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNJbkVuZFN0YXRlKSB7XG4gICAgICAgICAgdGhpcy5kZWJvdW5jZSgnX3Jlc2V0RHJhd2VyU3RhdGUnLCB0aGlzLl9yZXNldERyYXdlclN0YXRlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmRlYm91bmNlKCdfcmVzZXREcmF3ZXJTdGF0ZScsIHRoaXMuX3Jlc2V0RHJhd2VyU3RhdGUsIHRoaXMudHJhbnNpdGlvbkR1cmF0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3N0eWxlVHJhbnNpdGlvbkR1cmF0aW9uKHRoaXMudHJhbnNpdGlvbkR1cmF0aW9uKTtcbiAgICAgICAgdGhpcy5fcmVzZXREcmF3ZXJUcmFuc2xhdGUoKTtcbiAgICAgICAgdGhpcy5zdHlsZS52aXNpYmlsaXR5ID0gJyc7XG4gICAgICB9LFxuXG4gICAgICBfY2FsY3VsYXRlVmVsb2NpdHk6IGZ1bmN0aW9uKGV2ZW50LCB0cmFja0RldGFpbHMpIHtcbiAgICAgICAgLy8gRmluZCB0aGUgb2xkZXN0IHRyYWNrIGV2ZW50IHRoYXQgaXMgd2l0aGluIDEwMG1zIHVzaW5nIGJpbmFyeSBzZWFyY2guXG4gICAgICAgIHZhciBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICB2YXIgdGltZUxvd2VyQm91bmQgPSBub3cgLSAxMDA7XG4gICAgICAgIHZhciB0cmFja0RldGFpbDtcbiAgICAgICAgdmFyIG1pbiA9IDA7XG4gICAgICAgIHZhciBtYXggPSB0cmFja0RldGFpbHMubGVuZ3RoIC0gMTtcblxuICAgICAgICB3aGlsZSAobWluIDw9IG1heCkge1xuICAgICAgICAgIC8vIEZsb29yIG9mIGF2ZXJhZ2Ugb2YgbWluIGFuZCBtYXguXG4gICAgICAgICAgdmFyIG1pZCA9IChtaW4gKyBtYXgpID4+IDE7XG4gICAgICAgICAgdmFyIGQgPSB0cmFja0RldGFpbHNbbWlkXTtcbiAgICAgICAgICBpZiAoZC50aW1lU3RhbXAgPj0gdGltZUxvd2VyQm91bmQpIHtcbiAgICAgICAgICAgIHRyYWNrRGV0YWlsID0gZDtcbiAgICAgICAgICAgIG1heCA9IG1pZCAtIDE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1pbiA9IG1pZCArIDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRyYWNrRGV0YWlsKSB7XG4gICAgICAgICAgdmFyIGR4ID0gZXZlbnQuZGV0YWlsLmR4IC0gdHJhY2tEZXRhaWwuZHg7XG4gICAgICAgICAgdmFyIGR0ID0gKG5vdyAtIHRyYWNrRGV0YWlsLnRpbWVTdGFtcCkgfHwgMTtcbiAgICAgICAgICByZXR1cm4gZHggLyBkdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH0sXG5cbiAgICAgIF9mbGluZ0RyYXdlcjogZnVuY3Rpb24oZXZlbnQsIHRyYWNrRGV0YWlscykge1xuICAgICAgICB2YXIgdmVsb2NpdHkgPSB0aGlzLl9jYWxjdWxhdGVWZWxvY2l0eShldmVudCwgdHJhY2tEZXRhaWxzKTtcblxuICAgICAgICAvLyBEbyBub3QgZmxpbmcgaWYgdmVsb2NpdHkgaXMgbm90IGFib3ZlIGEgdGhyZXNob2xkLlxuICAgICAgICBpZiAoTWF0aC5hYnModmVsb2NpdHkpIDwgdGhpcy5fTUlOX0ZMSU5HX1RIUkVTSE9MRCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2RyYXdlclN0YXRlID0gdGhpcy5fRFJBV0VSX1NUQVRFLkZMSU5HSU5HO1xuXG4gICAgICAgIHZhciB4ID0gZXZlbnQuZGV0YWlsLmR4ICsgdGhpcy5fdHJhbnNsYXRlT2Zmc2V0O1xuICAgICAgICB2YXIgZHJhd2VyV2lkdGggPSB0aGlzLmdldFdpZHRoKCk7XG4gICAgICAgIHZhciBpc1Bvc2l0aW9uTGVmdCA9IHRoaXMucG9zaXRpb24gPT09ICdsZWZ0JztcbiAgICAgICAgdmFyIGlzVmVsb2NpdHlQb3NpdGl2ZSA9IHZlbG9jaXR5ID4gMDtcbiAgICAgICAgdmFyIGlzQ2xvc2luZ0xlZnQgPSAhaXNWZWxvY2l0eVBvc2l0aXZlICYmIGlzUG9zaXRpb25MZWZ0O1xuICAgICAgICB2YXIgaXNDbG9zaW5nUmlnaHQgPSBpc1ZlbG9jaXR5UG9zaXRpdmUgJiYgIWlzUG9zaXRpb25MZWZ0O1xuICAgICAgICB2YXIgZHg7XG4gICAgICAgIGlmIChpc0Nsb3NpbmdMZWZ0KSB7XG4gICAgICAgICAgZHggPSAtKHggKyBkcmF3ZXJXaWR0aCk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNDbG9zaW5nUmlnaHQpIHtcbiAgICAgICAgICBkeCA9IChkcmF3ZXJXaWR0aCAtIHgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGR4ID0gLXg7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBFbmZvcmNlIGEgbWluaW11bSB0cmFuc2l0aW9uIHZlbG9jaXR5IHRvIG1ha2UgdGhlIGRyYXdlciBmZWVsIHNuYXBweS5cbiAgICAgICAgaWYgKGlzVmVsb2NpdHlQb3NpdGl2ZSkge1xuICAgICAgICAgIHZlbG9jaXR5ID0gTWF0aC5tYXgodmVsb2NpdHksIHRoaXMuX01JTl9UUkFOU0lUSU9OX1ZFTE9DSVRZKTtcbiAgICAgICAgICB0aGlzLm9wZW5lZCA9IHRoaXMucG9zaXRpb24gPT09ICdsZWZ0JztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2ZWxvY2l0eSA9IE1hdGgubWluKHZlbG9jaXR5LCAtdGhpcy5fTUlOX1RSQU5TSVRJT05fVkVMT0NJVFkpO1xuICAgICAgICAgIHRoaXMub3BlbmVkID0gdGhpcy5wb3NpdGlvbiA9PT0gJ3JpZ2h0JztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgYW1vdW50IG9mIHRpbWUgbmVlZGVkIHRvIGZpbmlzaCB0aGUgdHJhbnNpdGlvbiBiYXNlZCBvbiB0aGVcbiAgICAgICAgLy8gaW5pdGlhbCBzbG9wZSBvZiB0aGUgdGltaW5nIGZ1bmN0aW9uLlxuICAgICAgICB2YXIgdCA9IHRoaXMuX0ZMSU5HX0lOSVRJQUxfU0xPUEUgKiBkeCAvIHZlbG9jaXR5XG4gICAgICAgIHRoaXMuX3N0eWxlVHJhbnNpdGlvbkR1cmF0aW9uKHQpO1xuICAgICAgICB0aGlzLl9zdHlsZVRyYW5zaXRpb25UaW1pbmdGdW5jdGlvbih0aGlzLl9GTElOR19USU1JTkdfRlVOQ1RJT04pO1xuXG4gICAgICAgIHRoaXMuX3Jlc2V0RHJhd2VyVHJhbnNsYXRlKCk7XG4gICAgICAgIHRoaXMuZGVib3VuY2UoJ19yZXNldERyYXdlclN0YXRlJywgdGhpcy5fcmVzZXREcmF3ZXJTdGF0ZSwgdCk7XG4gICAgICB9LFxuXG4gICAgICBfc3R5bGVUcmFuc2l0aW9uRHVyYXRpb246IGZ1bmN0aW9uKGR1cmF0aW9uKSB7XG4gICAgICAgIHRoaXMuc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID0gZHVyYXRpb24gKyAnbXMnO1xuICAgICAgICB0aGlzLiQuY29udGVudENvbnRhaW5lci5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPSBkdXJhdGlvbiArICdtcyc7XG4gICAgICAgIHRoaXMuJC5zY3JpbS5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPSBkdXJhdGlvbiArICdtcyc7XG4gICAgICB9LFxuXG4gICAgICBfc3R5bGVUcmFuc2l0aW9uVGltaW5nRnVuY3Rpb246IGZ1bmN0aW9uKHRpbWluZ0Z1bmN0aW9uKSB7XG4gICAgICAgIHRoaXMuJC5jb250ZW50Q29udGFpbmVyLnN0eWxlLnRyYW5zaXRpb25UaW1pbmdGdW5jdGlvbiA9IHRpbWluZ0Z1bmN0aW9uO1xuICAgICAgICB0aGlzLiQuc2NyaW0uc3R5bGUudHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uID0gdGltaW5nRnVuY3Rpb247XG4gICAgICB9LFxuXG4gICAgICBfdHJhbnNsYXRlRHJhd2VyOiBmdW5jdGlvbih4KSB7XG4gICAgICAgIHZhciBkcmF3ZXJXaWR0aCA9IHRoaXMuZ2V0V2lkdGgoKTtcblxuICAgICAgICBpZiAodGhpcy5wb3NpdGlvbiA9PT0gJ2xlZnQnKSB7XG4gICAgICAgICAgeCA9IE1hdGgubWF4KC1kcmF3ZXJXaWR0aCwgTWF0aC5taW4oeCwgMCkpO1xuICAgICAgICAgIHRoaXMuJC5zY3JpbS5zdHlsZS5vcGFjaXR5ID0gMSArIHggLyBkcmF3ZXJXaWR0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB4ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oeCwgZHJhd2VyV2lkdGgpKTtcbiAgICAgICAgICB0aGlzLiQuc2NyaW0uc3R5bGUub3BhY2l0eSA9IDEgLSB4IC8gZHJhd2VyV2lkdGg7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnRyYW5zbGF0ZTNkKHggKyAncHgnLCAnMCcsICcwJywgdGhpcy4kLmNvbnRlbnRDb250YWluZXIpO1xuICAgICAgfSxcblxuICAgICAgX3Jlc2V0RHJhd2VyVHJhbnNsYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy4kLnNjcmltLnN0eWxlLm9wYWNpdHkgPSAnJztcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0oJycsIHRoaXMuJC5jb250ZW50Q29udGFpbmVyKTtcbiAgICAgIH0sXG5cbiAgICAgIF9yZXNldERyYXdlclN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG9sZFN0YXRlID0gdGhpcy5fZHJhd2VyU3RhdGU7XG5cbiAgICAgICAgLy8gSWYgdGhlIGRyYXdlciB3YXMgZmxpbmdpbmcsIHdlIG5lZWQgdG8gcmVzZXQgdGhlIHN0eWxlIGF0dHJpYnV0ZXMuXG4gICAgICAgIGlmIChvbGRTdGF0ZSA9PT0gdGhpcy5fRFJBV0VSX1NUQVRFLkZMSU5HSU5HKSB7XG4gICAgICAgICAgdGhpcy5fc3R5bGVUcmFuc2l0aW9uRHVyYXRpb24odGhpcy50cmFuc2l0aW9uRHVyYXRpb24pO1xuICAgICAgICAgIHRoaXMuX3N0eWxlVHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uKCcnKTtcbiAgICAgICAgICB0aGlzLnN0eWxlLnZpc2liaWxpdHkgPSAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3NhdmVkV2lkdGggPSBudWxsO1xuXG4gICAgICAgIGlmICh0aGlzLm9wZW5lZCkge1xuICAgICAgICAgIHRoaXMuX2RyYXdlclN0YXRlID0gdGhpcy5wZXJzaXN0ZW50ID9cbiAgICAgICAgICAgIHRoaXMuX0RSQVdFUl9TVEFURS5PUEVORURfUEVSU0lTVEVOVCA6IHRoaXMuX0RSQVdFUl9TVEFURS5PUEVORUQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fZHJhd2VyU3RhdGUgPSB0aGlzLl9EUkFXRVJfU1RBVEUuQ0xPU0VEO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9sZFN0YXRlICE9PSB0aGlzLl9kcmF3ZXJTdGF0ZSkge1xuICAgICAgICAgIGlmICh0aGlzLl9kcmF3ZXJTdGF0ZSA9PT0gdGhpcy5fRFJBV0VSX1NUQVRFLk9QRU5FRCkge1xuICAgICAgICAgICAgdGhpcy5fc2V0S2V5Ym9hcmRGb2N1c1RyYXAoKTtcbiAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLl9ib3VuZEVzY0tleWRvd25IYW5kbGVyKTtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuX2JvdW5kRXNjS2V5ZG93bkhhbmRsZXIpO1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5zdHlsZS5vdmVyZmxvdyA9ICcnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIERvbid0IGZpcmUgdGhlIGV2ZW50IG9uIGluaXRpYWwgbG9hZC5cbiAgICAgICAgICBpZiAob2xkU3RhdGUgIT09IHRoaXMuX0RSQVdFUl9TVEFURS5JTklUKSB7XG4gICAgICAgICAgICB0aGlzLmZpcmUoJ2FwcC1kcmF3ZXItdHJhbnNpdGlvbmVkJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFJlc2V0cyB0aGUgbGF5b3V0LlxuICAgICAgICpcbiAgICAgICAqIEBtZXRob2QgcmVzZXRMYXlvdXRcbiAgICAgICAqL1xuICAgICAgcmVzZXRMYXlvdXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmZpcmUoJ2FwcC1yZXNldC1sYXlvdXQnKTtcbiAgICAgIH0sXG5cbiAgICAgIF9zZXRLZXlib2FyZEZvY3VzVHJhcDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLm5vRm9jdXNUcmFwKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTk9URTogVW5sZXNzIHdlIHVzZSAvZGVlcC8gKHdoaWNoIHdlIHNob3VsZG4ndCBzaW5jZSBpdCdzIGRlcHJlY2F0ZWQpLCB0aGlzIHdpbGxcbiAgICAgICAgLy8gbm90IHNlbGVjdCBmb2N1c2FibGUgZWxlbWVudHMgaW5zaWRlIHNoYWRvdyByb290cy5cbiAgICAgICAgdmFyIGZvY3VzYWJsZUVsZW1lbnRzU2VsZWN0b3IgPSBbXG4gICAgICAgICAgICAnYVtocmVmXTpub3QoW3RhYmluZGV4PVwiLTFcIl0pJyxcbiAgICAgICAgICAgICdhcmVhW2hyZWZdOm5vdChbdGFiaW5kZXg9XCItMVwiXSknLFxuICAgICAgICAgICAgJ2lucHV0Om5vdChbZGlzYWJsZWRdKTpub3QoW3RhYmluZGV4PVwiLTFcIl0pJyxcbiAgICAgICAgICAgICdzZWxlY3Q6bm90KFtkaXNhYmxlZF0pOm5vdChbdGFiaW5kZXg9XCItMVwiXSknLFxuICAgICAgICAgICAgJ3RleHRhcmVhOm5vdChbZGlzYWJsZWRdKTpub3QoW3RhYmluZGV4PVwiLTFcIl0pJyxcbiAgICAgICAgICAgICdidXR0b246bm90KFtkaXNhYmxlZF0pOm5vdChbdGFiaW5kZXg9XCItMVwiXSknLFxuICAgICAgICAgICAgJ2lmcmFtZTpub3QoW3RhYmluZGV4PVwiLTFcIl0pJyxcbiAgICAgICAgICAgICdbdGFiaW5kZXhdOm5vdChbdGFiaW5kZXg9XCItMVwiXSknLFxuICAgICAgICAgICAgJ1tjb250ZW50RWRpdGFibGU9dHJ1ZV06bm90KFt0YWJpbmRleD1cIi0xXCJdKSdcbiAgICAgICAgICBdLmpvaW4oJywnKTtcbiAgICAgICAgdmFyIGZvY3VzYWJsZUVsZW1lbnRzID0gUG9seW1lci5kb20odGhpcykucXVlcnlTZWxlY3RvckFsbChmb2N1c2FibGVFbGVtZW50c1NlbGVjdG9yKTtcblxuICAgICAgICBpZiAoZm9jdXNhYmxlRWxlbWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHRoaXMuX2ZpcnN0VGFiU3RvcCA9IGZvY3VzYWJsZUVsZW1lbnRzWzBdO1xuICAgICAgICAgIHRoaXMuX2xhc3RUYWJTdG9wID0gZm9jdXNhYmxlRWxlbWVudHNbZm9jdXNhYmxlRWxlbWVudHMubGVuZ3RoIC0gMV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gUmVzZXQgc2F2ZWQgdGFiIHN0b3BzIHdoZW4gdGhlcmUgYXJlIG5vIGZvY3VzYWJsZSBlbGVtZW50cyBpbiB0aGUgZHJhd2VyLlxuICAgICAgICAgIHRoaXMuX2ZpcnN0VGFiU3RvcCA9IG51bGw7XG4gICAgICAgICAgdGhpcy5fbGFzdFRhYlN0b3AgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRm9jdXMgb24gYXBwLWRyYXdlciBpZiBpdCBoYXMgbm9uLXplcm8gdGFiaW5kZXguIE90aGVyd2lzZSwgZm9jdXMgdGhlIGZpcnN0IGZvY3VzYWJsZVxuICAgICAgICAvLyBlbGVtZW50IGluIHRoZSBkcmF3ZXIsIGlmIGl0IGV4aXN0cy4gVXNlIHRoZSB0YWJpbmRleCBhdHRyaWJ1dGUgc2luY2UgdGhlIHRoaXMudGFiSW5kZXhcbiAgICAgICAgLy8gcHJvcGVydHkgaW4gSUUvRWRnZSByZXR1cm5zIDAgKGluc3RlYWQgb2YgLTEpIHdoZW4gdGhlIGF0dHJpYnV0ZSBpcyBub3Qgc2V0LlxuICAgICAgICB2YXIgdGFiaW5kZXggPSB0aGlzLmdldEF0dHJpYnV0ZSgndGFiaW5kZXgnKTtcbiAgICAgICAgaWYgKHRhYmluZGV4ICYmIHBhcnNlSW50KHRhYmluZGV4LCAxMCkgPiAtMSkge1xuICAgICAgICAgIHRoaXMuZm9jdXMoKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9maXJzdFRhYlN0b3ApIHtcbiAgICAgICAgICB0aGlzLl9maXJzdFRhYlN0b3AuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgX3RhYktleWRvd25IYW5kbGVyOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICBpZiAodGhpcy5ub0ZvY3VzVHJhcCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBUQUJfS0VZQ09ERSA9IDk7XG4gICAgICAgIGlmICh0aGlzLl9kcmF3ZXJTdGF0ZSA9PT0gdGhpcy5fRFJBV0VSX1NUQVRFLk9QRU5FRCAmJiBldmVudC5rZXlDb2RlID09PSBUQUJfS0VZQ09ERSkge1xuICAgICAgICAgIGlmIChldmVudC5zaGlmdEtleSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2ZpcnN0VGFiU3RvcCAmJiBQb2x5bWVyLmRvbShldmVudCkubG9jYWxUYXJnZXQgPT09IHRoaXMuX2ZpcnN0VGFiU3RvcCkge1xuICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICB0aGlzLl9sYXN0VGFiU3RvcC5mb2N1cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fbGFzdFRhYlN0b3AgJiYgUG9seW1lci5kb20oZXZlbnQpLmxvY2FsVGFyZ2V0ID09PSB0aGlzLl9sYXN0VGFiU3RvcCkge1xuICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICB0aGlzLl9maXJzdFRhYlN0b3AuZm9jdXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIF9vcGVuZWRQZXJzaXN0ZW50Q2hhbmdlZDogZnVuY3Rpb24ob3BlbmVkLCBwZXJzaXN0ZW50KSB7XG4gICAgICAgIHRoaXMudG9nZ2xlQ2xhc3MoJ3Zpc2libGUnLCBvcGVuZWQgJiYgIXBlcnNpc3RlbnQsIHRoaXMuJC5zY3JpbSk7XG5cbiAgICAgICAgLy8gVXNlIGEgZGVib3VuY2UgdGltZXIgaW5zdGVhZCBvZiB0cmFuc2l0aW9uZW5kIHNpbmNlIHRyYW5zaXRpb25lbmQgd29uJ3QgZmlyZSB3aGVuXG4gICAgICAgIC8vIGFwcC1kcmF3ZXIgaXMgZGlzcGxheTogbm9uZS5cbiAgICAgICAgdGhpcy5kZWJvdW5jZSgnX3Jlc2V0RHJhd2VyU3RhdGUnLCB0aGlzLl9yZXNldERyYXdlclN0YXRlLCB0aGlzLnRyYW5zaXRpb25EdXJhdGlvbik7XG4gICAgICB9LFxuXG4gICAgICBfTUlOX0ZMSU5HX1RIUkVTSE9MRDogMC4yLFxuXG4gICAgICBfTUlOX1RSQU5TSVRJT05fVkVMT0NJVFk6IDEuMixcblxuICAgICAgX0ZMSU5HX1RJTUlOR19GVU5DVElPTjogJ2N1YmljLWJlemllcigwLjY2NywgMSwgMC42NjcsIDEpJyxcblxuICAgICAgX0ZMSU5HX0lOSVRJQUxfU0xPUEU6IDEuNSxcblxuICAgICAgX0RSQVdFUl9TVEFURToge1xuICAgICAgICBJTklUOiAwLFxuICAgICAgICBPUEVORUQ6IDEsXG4gICAgICAgIE9QRU5FRF9QRVJTSVNURU5UOiAyLFxuICAgICAgICBDTE9TRUQ6IDMsXG4gICAgICAgIFRSQUNLSU5HOiA0LFxuICAgICAgICBGTElOR0lORzogNVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEZpcmVkIHdoZW4gdGhlIGxheW91dCBvZiBhcHAtZHJhd2VyIGhhcyBjaGFuZ2VkLlxuICAgICAgICpcbiAgICAgICAqIEBldmVudCBhcHAtcmVzZXQtbGF5b3V0XG4gICAgICAgKi9cblxuICAgICAgLyoqXG4gICAgICAgKiBGaXJlZCB3aGVuIGFwcC1kcmF3ZXIgaGFzIGZpbmlzaGVkIHRyYW5zaXRpb25pbmcuXG4gICAgICAgKlxuICAgICAgICogQGV2ZW50IGFwcC1kcmF3ZXItdHJhbnNpdGlvbmVkXG4gICAgICAgKi9cbiAgICB9KTtcbiAgPC9zY3JpcHQ+XG48L2RvbS1tb2R1bGU+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL2FwcC1sYXlvdXQvYXBwLWRyYXdlci9hcHAtZHJhd2VyLmh0bWwiLCJcbnJlcXVpcmUoJy4vYXBwbHktc2hpbS5taW4uanMnKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvc2hhZHljc3MvYXBwbHktc2hpbS5odG1sIiwiKGZ1bmN0aW9uKCl7LypcblxuQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuKi9cbid1c2Ugc3RyaWN0Jzt2YXIgaz17fTtmdW5jdGlvbiBuKCl7dGhpcy5lbmQ9dGhpcy5zdGFydD0wO3RoaXMucnVsZXM9dGhpcy5wYXJlbnQ9dGhpcy5wcmV2aW91cz1udWxsO3RoaXMuY3NzVGV4dD10aGlzLnBhcnNlZENzc1RleHQ9XCJcIjt0aGlzLmF0UnVsZT0hMTt0aGlzLnR5cGU9MDt0aGlzLnBhcnNlZFNlbGVjdG9yPXRoaXMuc2VsZWN0b3I9dGhpcy5rZXlmcmFtZXNOYW1lPVwiXCJ9XG5mdW5jdGlvbiBwKGEpe2E9YS5yZXBsYWNlKGFhLFwiXCIpLnJlcGxhY2UoYmEsXCJcIik7dmFyIGI9cSxjPWEsZD1uZXcgbjtkLnN0YXJ0PTA7ZC5lbmQ9Yy5sZW5ndGg7Zm9yKHZhciBlPWQsZj0wLGg9Yy5sZW5ndGg7ZjxoO2YrKylpZihcIntcIj09PWNbZl0pe2UucnVsZXN8fChlLnJ1bGVzPVtdKTt2YXIgZz1lLG09Zy5ydWxlc1tnLnJ1bGVzLmxlbmd0aC0xXXx8bnVsbDtlPW5ldyBuO2Uuc3RhcnQ9ZisxO2UucGFyZW50PWc7ZS5wcmV2aW91cz1tO2cucnVsZXMucHVzaChlKX1lbHNlXCJ9XCI9PT1jW2ZdJiYoZS5lbmQ9ZisxLGU9ZS5wYXJlbnR8fGQpO3JldHVybiBiKGQsYSl9XG5mdW5jdGlvbiBxKGEsYil7dmFyIGM9Yi5zdWJzdHJpbmcoYS5zdGFydCxhLmVuZC0xKTthLnBhcnNlZENzc1RleHQ9YS5jc3NUZXh0PWMudHJpbSgpO2EucGFyZW50JiYoYz1iLnN1YnN0cmluZyhhLnByZXZpb3VzP2EucHJldmlvdXMuZW5kOmEucGFyZW50LnN0YXJ0LGEuc3RhcnQtMSksYz1jYShjKSxjPWMucmVwbGFjZShyLFwiIFwiKSxjPWMuc3Vic3RyaW5nKGMubGFzdEluZGV4T2YoXCI7XCIpKzEpLGM9YS5wYXJzZWRTZWxlY3Rvcj1hLnNlbGVjdG9yPWMudHJpbSgpLGEuYXRSdWxlPTA9PT1jLmluZGV4T2YoXCJAXCIpLGEuYXRSdWxlPzA9PT1jLmluZGV4T2YoXCJAbWVkaWFcIik/YS50eXBlPXQ6Yy5tYXRjaChkYSkmJihhLnR5cGU9dSxhLmtleWZyYW1lc05hbWU9YS5zZWxlY3Rvci5zcGxpdChyKS5wb3AoKSk6YS50eXBlPTA9PT1jLmluZGV4T2YoXCItLVwiKT92OngpO2lmKGM9YS5ydWxlcylmb3IodmFyIGQ9MCxlPWMubGVuZ3RoLGY7ZDxlJiYoZj1jW2RdKTtkKyspcShmLGIpO3JldHVybiBhfVxuZnVuY3Rpb24gY2EoYSl7cmV0dXJuIGEucmVwbGFjZSgvXFxcXChbMC05YS1mXXsxLDZ9KVxccy9naSxmdW5jdGlvbihhLGMpe2E9Yztmb3IoYz02LWEubGVuZ3RoO2MtLTspYT1cIjBcIithO3JldHVyblwiXFxcXFwiK2F9KX1cbmZ1bmN0aW9uIHkoYSxiLGMpe2M9dm9pZCAwPT09Yz9cIlwiOmM7dmFyIGQ9XCJcIjtpZihhLmNzc1RleHR8fGEucnVsZXMpe3ZhciBlPWEucnVsZXMsZjtpZihmPWUpZj1lWzBdLGY9IShmJiZmLnNlbGVjdG9yJiYwPT09Zi5zZWxlY3Rvci5pbmRleE9mKFwiLS1cIikpO2lmKGYpe2Y9MDtmb3IodmFyIGg9ZS5sZW5ndGgsZztmPGgmJihnPWVbZl0pO2YrKylkPXkoZyxiLGQpfWVsc2UgYj9iPWEuY3NzVGV4dDooYj1hLmNzc1RleHQsYj1iLnJlcGxhY2UoZWEsXCJcIikucmVwbGFjZShmYSxcIlwiKSxiPWIucmVwbGFjZShoYSxcIlwiKS5yZXBsYWNlKGlhLFwiXCIpKSwoZD1iLnRyaW0oKSkmJihkPVwiICBcIitkK1wiXFxuXCIpfWQmJihhLnNlbGVjdG9yJiYoYys9YS5zZWxlY3RvcitcIiB7XFxuXCIpLGMrPWQsYS5zZWxlY3RvciYmKGMrPVwifVxcblxcblwiKSk7cmV0dXJuIGN9XG52YXIgeD0xLHU9Nyx0PTQsdj0xRTMsYWE9L1xcL1xcKlteKl0qXFwqKyhbXi8qXVteKl0qXFwqKykqXFwvL2dpbSxiYT0vQGltcG9ydFteO10qOy9naW0sZWE9Lyg/Ol5bXjtcXC1cXHN9XSspPy0tW147e31dKj86W157fTtdKj8oPzpbO1xcbl18JCkvZ2ltLGZhPS8oPzpeW147XFwtXFxzfV0rKT8tLVteO3t9XSo/Oltee307XSo/e1tefV0qP30oPzpbO1xcbl18JCk/L2dpbSxoYT0vQGFwcGx5XFxzKlxcKD9bXik7XSpcXCk/XFxzKig/Ols7XFxuXXwkKT8vZ2ltLGlhPS9bXjs6XSo/OlteO10qP3ZhclxcKFteO10qXFwpKD86WztcXG5dfCQpPy9naW0sZGE9L15AW15cXHNdKmtleWZyYW1lcy8scj0vXFxzKy9nO3ZhciBqYT1Qcm9taXNlLnJlc29sdmUoKTtmdW5jdGlvbiBrYShhKXtpZihhPWtbYV0pYS5fYXBwbHlTaGltQ3VycmVudFZlcnNpb249YS5fYXBwbHlTaGltQ3VycmVudFZlcnNpb258fDAsYS5fYXBwbHlTaGltVmFsaWRhdGluZ1ZlcnNpb249YS5fYXBwbHlTaGltVmFsaWRhdGluZ1ZlcnNpb258fDAsYS5fYXBwbHlTaGltTmV4dFZlcnNpb249KGEuX2FwcGx5U2hpbU5leHRWZXJzaW9ufHwwKSsxfWZ1bmN0aW9uIHooYSl7cmV0dXJuIGEuX2FwcGx5U2hpbUN1cnJlbnRWZXJzaW9uPT09YS5fYXBwbHlTaGltTmV4dFZlcnNpb259ZnVuY3Rpb24gbGEoYSl7YS5fYXBwbHlTaGltVmFsaWRhdGluZ1ZlcnNpb249YS5fYXBwbHlTaGltTmV4dFZlcnNpb247YS5hfHwoYS5hPSEwLGphLnRoZW4oZnVuY3Rpb24oKXthLl9hcHBseVNoaW1DdXJyZW50VmVyc2lvbj1hLl9hcHBseVNoaW1OZXh0VmVyc2lvbjthLmE9ITF9KSl9O3ZhciBBPSEod2luZG93LlNoYWR5RE9NJiZ3aW5kb3cuU2hhZHlET00uaW5Vc2UpLEI7ZnVuY3Rpb24gQyhhKXtCPWEmJmEuc2hpbWNzc3Byb3BlcnRpZXM/ITE6QXx8IShuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9BcHBsZVdlYktpdFxcLzYwMXxFZGdlXFwvMTUvKXx8IXdpbmRvdy5DU1N8fCFDU1Muc3VwcG9ydHN8fCFDU1Muc3VwcG9ydHMoXCJib3gtc2hhZG93XCIsXCIwIDAgMCB2YXIoLS1mb28pXCIpKX13aW5kb3cuU2hhZHlDU1MmJnZvaWQgMCE9PXdpbmRvdy5TaGFkeUNTUy5uYXRpdmVDc3M/Qj13aW5kb3cuU2hhZHlDU1MubmF0aXZlQ3NzOndpbmRvdy5TaGFkeUNTUz8oQyh3aW5kb3cuU2hhZHlDU1MpLHdpbmRvdy5TaGFkeUNTUz12b2lkIDApOkMod2luZG93LldlYkNvbXBvbmVudHMmJndpbmRvdy5XZWJDb21wb25lbnRzLmZsYWdzKTt2YXIgRT1CO3ZhciBGPS8oPzpefFs7XFxze11cXHMqKSgtLVtcXHctXSo/KVxccyo6XFxzKig/OigoPzonKD86XFxcXCd8LikqPyd8XCIoPzpcXFxcXCJ8LikqP1wifFxcKFteKV0qP1xcKXxbXn07e10pKyl8XFx7KFtefV0qKVxcfSg/Oig/PVs7XFxzfV0pfCQpKS9naSxHPS8oPzpefFxcVyspQGFwcGx5XFxzKlxcKD8oW14pO1xcbl0qKVxcKT8vZ2ksbWE9L0BtZWRpYVxccyguKikvO2Z1bmN0aW9uIEgoYSl7aWYoIWEpcmV0dXJuXCJcIjtcInN0cmluZ1wiPT09dHlwZW9mIGEmJihhPXAoYSkpO3JldHVybiB5KGEsRSl9ZnVuY3Rpb24gSShhKXshYS5fX2Nzc1J1bGVzJiZhLnRleHRDb250ZW50JiYoYS5fX2Nzc1J1bGVzPXAoYS50ZXh0Q29udGVudCkpO3JldHVybiBhLl9fY3NzUnVsZXN8fG51bGx9ZnVuY3Rpb24gSihhLGIsYyxkKXtpZihhKXt2YXIgZT0hMSxmPWEudHlwZTtpZihkJiZmPT09dCl7dmFyIGg9YS5zZWxlY3Rvci5tYXRjaChtYSk7aCYmKHdpbmRvdy5tYXRjaE1lZGlhKGhbMV0pLm1hdGNoZXN8fChlPSEwKSl9Zj09PXg/YihhKTpjJiZmPT09dT9jKGEpOmY9PT12JiYoZT0hMCk7aWYoKGE9YS5ydWxlcykmJiFlKXtlPTA7Zj1hLmxlbmd0aDtmb3IodmFyIGc7ZTxmJiYoZz1hW2VdKTtlKyspSihnLGIsYyxkKX19fVxuZnVuY3Rpb24gSyhhLGIpe3ZhciBjPWEuaW5kZXhPZihcInZhcihcIik7aWYoLTE9PT1jKXJldHVybiBiKGEsXCJcIixcIlwiLFwiXCIpO2E6e3ZhciBkPTA7dmFyIGU9YyszO2Zvcih2YXIgZj1hLmxlbmd0aDtlPGY7ZSsrKWlmKFwiKFwiPT09YVtlXSlkKys7ZWxzZSBpZihcIilcIj09PWFbZV0mJjA9PT0tLWQpYnJlYWsgYTtlPS0xfWQ9YS5zdWJzdHJpbmcoYys0LGUpO2M9YS5zdWJzdHJpbmcoMCxjKTthPUsoYS5zdWJzdHJpbmcoZSsxKSxiKTtlPWQuaW5kZXhPZihcIixcIik7cmV0dXJuLTE9PT1lP2IoYyxkLnRyaW0oKSxcIlwiLGEpOmIoYyxkLnN1YnN0cmluZygwLGUpLnRyaW0oKSxkLnN1YnN0cmluZyhlKzEpLnRyaW0oKSxhKX07dmFyIG5hPS87XFxzKi9tLG9hPS9eXFxzKihpbml0aWFsKXwoaW5oZXJpdClcXHMqJC87ZnVuY3Rpb24gTCgpe3RoaXMuYT17fX1MLnByb3RvdHlwZS5zZXQ9ZnVuY3Rpb24oYSxiKXthPWEudHJpbSgpO3RoaXMuYVthXT17aDpiLGk6e319fTtMLnByb3RvdHlwZS5nZXQ9ZnVuY3Rpb24oYSl7YT1hLnRyaW0oKTtyZXR1cm4gdGhpcy5hW2FdfHxudWxsfTt2YXIgTT1udWxsO2Z1bmN0aW9uIE4oKXt0aGlzLmI9dGhpcy5jPW51bGw7dGhpcy5hPW5ldyBMfU4ucHJvdG90eXBlLm89ZnVuY3Rpb24oYSl7YT1HLnRlc3QoYSl8fEYudGVzdChhKTtHLmxhc3RJbmRleD0wO0YubGFzdEluZGV4PTA7cmV0dXJuIGF9O04ucHJvdG90eXBlLm09ZnVuY3Rpb24oYSxiKXthPWEuY29udGVudC5xdWVyeVNlbGVjdG9yKFwic3R5bGVcIik7dmFyIGM9bnVsbDthJiYoYz10aGlzLmooYSxiKSk7cmV0dXJuIGN9O1xuTi5wcm90b3R5cGUuaj1mdW5jdGlvbihhLGIpe2I9dm9pZCAwPT09Yj9cIlwiOmI7dmFyIGM9SShhKTt0aGlzLmwoYyxiKTthLnRleHRDb250ZW50PUgoYyk7cmV0dXJuIGN9O04ucHJvdG90eXBlLmY9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcyxjPUkoYSk7SihjLGZ1bmN0aW9uKGEpe1wiOnJvb3RcIj09PWEuc2VsZWN0b3ImJihhLnNlbGVjdG9yPVwiaHRtbFwiKTtiLmcoYSl9KTthLnRleHRDb250ZW50PUgoYyk7cmV0dXJuIGN9O04ucHJvdG90eXBlLmw9ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzO3RoaXMuYz1iO0ooYSxmdW5jdGlvbihhKXtjLmcoYSl9KTt0aGlzLmM9bnVsbH07Ti5wcm90b3R5cGUuZz1mdW5jdGlvbihhKXthLmNzc1RleHQ9cGEodGhpcyxhLnBhcnNlZENzc1RleHQpO1wiOnJvb3RcIj09PWEuc2VsZWN0b3ImJihhLnNlbGVjdG9yPVwiOmhvc3QgPiAqXCIpfTtcbmZ1bmN0aW9uIHBhKGEsYil7Yj1iLnJlcGxhY2UoRixmdW5jdGlvbihiLGQsZSxmKXtyZXR1cm4gcWEoYSxiLGQsZSxmKX0pO3JldHVybiBPKGEsYil9ZnVuY3Rpb24gTyhhLGIpe2Zvcih2YXIgYztjPUcuZXhlYyhiKTspe3ZhciBkPWNbMF0sZT1jWzFdO2M9Yy5pbmRleDt2YXIgZj1iLnNsaWNlKDAsYytkLmluZGV4T2YoXCJAYXBwbHlcIikpO2I9Yi5zbGljZShjK2QubGVuZ3RoKTt2YXIgaD1QKGEsZik7ZD12b2lkIDA7dmFyIGc9YTtlPWUucmVwbGFjZShuYSxcIlwiKTt2YXIgbT1bXTt2YXIgbD1nLmEuZ2V0KGUpO2x8fChnLmEuc2V0KGUse30pLGw9Zy5hLmdldChlKSk7aWYobClmb3IoZCBpbiBnLmMmJihsLmlbZy5jXT0hMCksbC5oKWc9aCYmaFtkXSxsPVtkLFwiOiB2YXIoXCIsZSxcIl8tX1wiLGRdLGcmJmwucHVzaChcIixcIixnKSxsLnB1c2goXCIpXCIpLG0ucHVzaChsLmpvaW4oXCJcIikpO2Q9bS5qb2luKFwiOyBcIik7Yj1cIlwiK2YrZCtiO0cubGFzdEluZGV4PWMrZC5sZW5ndGh9cmV0dXJuIGJ9XG5mdW5jdGlvbiBQKGEsYil7Yj1iLnNwbGl0KFwiO1wiKTtmb3IodmFyIGMsZCxlPXt9LGY9MCxoO2Y8Yi5sZW5ndGg7ZisrKWlmKGM9YltmXSlpZihoPWMuc3BsaXQoXCI6XCIpLDE8aC5sZW5ndGgpe2M9aFswXS50cmltKCk7dmFyIGc9YTtkPWM7aD1oLnNsaWNlKDEpLmpvaW4oXCI6XCIpO3ZhciBtPW9hLmV4ZWMoaCk7bSYmKG1bMV0/KGcuYnx8KGcuYj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibWV0YVwiKSxnLmIuc2V0QXR0cmlidXRlKFwiYXBwbHktc2hpbS1tZWFzdXJlXCIsXCJcIiksZy5iLnN0eWxlLmFsbD1cImluaXRpYWxcIixkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKGcuYikpLGQ9d2luZG93LmdldENvbXB1dGVkU3R5bGUoZy5iKS5nZXRQcm9wZXJ0eVZhbHVlKGQpKTpkPVwiYXBwbHktc2hpbS1pbmhlcml0XCIsaD1kKTtkPWg7ZVtjXT1kfXJldHVybiBlfWZ1bmN0aW9uIHJhKGEsYil7aWYoTSlmb3IodmFyIGMgaW4gYi5pKWMhPT1hLmMmJk0oYyl9XG5mdW5jdGlvbiBxYShhLGIsYyxkLGUpe2QmJksoZCxmdW5jdGlvbihiLGMpe2MmJmEuYS5nZXQoYykmJihlPVwiQGFwcGx5IFwiK2MrXCI7XCIpfSk7aWYoIWUpcmV0dXJuIGI7dmFyIGY9TyhhLGUpLGg9Yi5zbGljZSgwLGIuaW5kZXhPZihcIi0tXCIpKSxnPWY9UChhLGYpLG09YS5hLmdldChjKSxsPW0mJm0uaDtsP2c9T2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKGwpLGYpOmEuYS5zZXQoYyxnKTt2YXIgWD1bXSx3LFk9ITE7Zm9yKHcgaW4gZyl7dmFyIEQ9Zlt3XTt2b2lkIDA9PT1EJiYoRD1cImluaXRpYWxcIik7IWx8fHcgaW4gbHx8KFk9ITApO1gucHVzaChcIlwiK2MrXCJfLV9cIit3K1wiOiBcIitEKX1ZJiZyYShhLG0pO20mJihtLmg9Zyk7ZCYmKGg9YitcIjtcIitoKTtyZXR1cm5cIlwiK2grWC5qb2luKFwiOyBcIikrXCI7XCJ9Ti5wcm90b3R5cGUuZGV0ZWN0TWl4aW49Ti5wcm90b3R5cGUubztOLnByb3RvdHlwZS50cmFuc2Zvcm1TdHlsZT1OLnByb3RvdHlwZS5qO1xuTi5wcm90b3R5cGUudHJhbnNmb3JtQ3VzdG9tU3R5bGU9Ti5wcm90b3R5cGUuZjtOLnByb3RvdHlwZS50cmFuc2Zvcm1SdWxlcz1OLnByb3RvdHlwZS5sO04ucHJvdG90eXBlLnRyYW5zZm9ybVJ1bGU9Ti5wcm90b3R5cGUuZztOLnByb3RvdHlwZS50cmFuc2Zvcm1UZW1wbGF0ZT1OLnByb3RvdHlwZS5tO04ucHJvdG90eXBlLl9zZXBhcmF0b3I9XCJfLV9cIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoTi5wcm90b3R5cGUsXCJpbnZhbGlkQ2FsbGJhY2tcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIE19LHNldDpmdW5jdGlvbihhKXtNPWF9fSk7dmFyIFE9bnVsbCxSPXdpbmRvdy5IVE1MSW1wb3J0cyYmd2luZG93LkhUTUxJbXBvcnRzLndoZW5SZWFkeXx8bnVsbCxTO2Z1bmN0aW9uIHNhKGEpe3JlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbigpe1I/UihhKTooUXx8KFE9bmV3IFByb21pc2UoZnVuY3Rpb24oYSl7Uz1hfSksXCJjb21wbGV0ZVwiPT09ZG9jdW1lbnQucmVhZHlTdGF0ZT9TKCk6ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInJlYWR5c3RhdGVjaGFuZ2VcIixmdW5jdGlvbigpe1wiY29tcGxldGVcIj09PWRvY3VtZW50LnJlYWR5U3RhdGUmJlMoKX0pKSxRLnRoZW4oZnVuY3Rpb24oKXthJiZhKCl9KSl9KX07dmFyIFQ9bmV3IE47ZnVuY3Rpb24gVSgpe3ZhciBhPXRoaXM7dGhpcy5hPW51bGw7c2EoZnVuY3Rpb24oKXtWKGEpfSk7VC5pbnZhbGlkQ2FsbGJhY2s9a2F9ZnVuY3Rpb24gVihhKXthLmF8fChhLmE9d2luZG93LlNoYWR5Q1NTLkN1c3RvbVN0eWxlSW50ZXJmYWNlLGEuYSYmKGEuYS50cmFuc2Zvcm1DYWxsYmFjaz1mdW5jdGlvbihhKXtULmYoYSl9LGEuYS52YWxpZGF0ZUNhbGxiYWNrPWZ1bmN0aW9uKCl7cmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCl7YS5hLmVucXVldWVkJiZXKGEpfSl9KSl9VS5wcm90b3R5cGUucHJlcGFyZVRlbXBsYXRlPWZ1bmN0aW9uKGEsYil7Vih0aGlzKTtrW2JdPWE7Yj1ULm0oYSxiKTthLl9zdHlsZUFzdD1ifTtcbmZ1bmN0aW9uIFcoYSl7VihhKTtpZihhLmEpe3ZhciBiPWEuYS5wcm9jZXNzU3R5bGVzKCk7aWYoYS5hLmVucXVldWVkKXtmb3IodmFyIGM9MDtjPGIubGVuZ3RoO2MrKyl7dmFyIGQ9YS5hLmdldFN0eWxlRm9yQ3VzdG9tU3R5bGUoYltjXSk7ZCYmVC5mKGQpfWEuYS5lbnF1ZXVlZD0hMX19fVUucHJvdG90eXBlLnN0eWxlU3VidHJlZT1mdW5jdGlvbihhLGIpe1YodGhpcyk7aWYoYilmb3IodmFyIGMgaW4gYiludWxsPT09Yz9hLnN0eWxlLnJlbW92ZVByb3BlcnR5KGMpOmEuc3R5bGUuc2V0UHJvcGVydHkoYyxiW2NdKTtpZihhLnNoYWRvd1Jvb3QpZm9yKHRoaXMuc3R5bGVFbGVtZW50KGEpLGE9YS5zaGFkb3dSb290LmNoaWxkcmVufHxhLnNoYWRvd1Jvb3QuY2hpbGROb2RlcyxiPTA7YjxhLmxlbmd0aDtiKyspdGhpcy5zdHlsZVN1YnRyZWUoYVtiXSk7ZWxzZSBmb3IoYT1hLmNoaWxkcmVufHxhLmNoaWxkTm9kZXMsYj0wO2I8YS5sZW5ndGg7YisrKXRoaXMuc3R5bGVTdWJ0cmVlKGFbYl0pfTtcblUucHJvdG90eXBlLnN0eWxlRWxlbWVudD1mdW5jdGlvbihhKXtWKHRoaXMpO3ZhciBiPWEubG9jYWxOYW1lLGM7Yj8tMTxiLmluZGV4T2YoXCItXCIpP2M9YjpjPWEuZ2V0QXR0cmlidXRlJiZhLmdldEF0dHJpYnV0ZShcImlzXCIpfHxcIlwiOmM9YS5pcztpZigoYj1rW2NdKSYmIXooYikpe2lmKHooYil8fGIuX2FwcGx5U2hpbVZhbGlkYXRpbmdWZXJzaW9uIT09Yi5fYXBwbHlTaGltTmV4dFZlcnNpb24pdGhpcy5wcmVwYXJlVGVtcGxhdGUoYixjKSxsYShiKTtpZihhPWEuc2hhZG93Um9vdClpZihhPWEucXVlcnlTZWxlY3RvcihcInN0eWxlXCIpKWEuX19jc3NSdWxlcz1iLl9zdHlsZUFzdCxhLnRleHRDb250ZW50PUgoYi5fc3R5bGVBc3QpfX07VS5wcm90b3R5cGUuc3R5bGVEb2N1bWVudD1mdW5jdGlvbihhKXtWKHRoaXMpO3RoaXMuc3R5bGVTdWJ0cmVlKGRvY3VtZW50LmJvZHksYSl9O1xuaWYoIXdpbmRvdy5TaGFkeUNTU3x8IXdpbmRvdy5TaGFkeUNTUy5TY29waW5nU2hpbSl7dmFyIFo9bmV3IFUsdGE9d2luZG93LlNoYWR5Q1NTJiZ3aW5kb3cuU2hhZHlDU1MuQ3VzdG9tU3R5bGVJbnRlcmZhY2U7d2luZG93LlNoYWR5Q1NTPXtwcmVwYXJlVGVtcGxhdGU6ZnVuY3Rpb24oYSxiKXtXKFopO1oucHJlcGFyZVRlbXBsYXRlKGEsYil9LHN0eWxlU3VidHJlZTpmdW5jdGlvbihhLGIpe1coWik7Wi5zdHlsZVN1YnRyZWUoYSxiKX0sc3R5bGVFbGVtZW50OmZ1bmN0aW9uKGEpe1coWik7Wi5zdHlsZUVsZW1lbnQoYSl9LHN0eWxlRG9jdW1lbnQ6ZnVuY3Rpb24oYSl7VyhaKTtaLnN0eWxlRG9jdW1lbnQoYSl9LGdldENvbXB1dGVkU3R5bGVWYWx1ZTpmdW5jdGlvbihhLGIpe3JldHVybihhPXdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGEpLmdldFByb3BlcnR5VmFsdWUoYikpP2EudHJpbSgpOlwiXCJ9LG5hdGl2ZUNzczpFLG5hdGl2ZVNoYWRvdzpBfTt0YSYmKHdpbmRvdy5TaGFkeUNTUy5DdXN0b21TdHlsZUludGVyZmFjZT1cbnRhKX13aW5kb3cuU2hhZHlDU1MuQXBwbHlTaGltPVQ7fSkuY2FsbCh0aGlzKTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXBwbHktc2hpbS5taW4uanMubWFwXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL3NoYWR5Y3NzL2FwcGx5LXNoaW0ubWluLmpzIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cImJvb3QuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cImFzeW5jLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCJkZWJvdW5jZS5odG1sXCI+XG5cbjxzY3JpcHQ+XG4oZnVuY3Rpb24oKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIGRldGVjdCBuYXRpdmUgdG91Y2ggYWN0aW9uIHN1cHBvcnRcbiAgbGV0IEhBU19OQVRJVkVfVEEgPSB0eXBlb2YgZG9jdW1lbnQuaGVhZC5zdHlsZS50b3VjaEFjdGlvbiA9PT0gJ3N0cmluZyc7XG4gIGxldCBHRVNUVVJFX0tFWSA9ICdfX3BvbHltZXJHZXN0dXJlcyc7XG4gIGxldCBIQU5ETEVEX09CSiA9ICdfX3BvbHltZXJHZXN0dXJlc0hhbmRsZWQnO1xuICBsZXQgVE9VQ0hfQUNUSU9OID0gJ19fcG9seW1lckdlc3R1cmVzVG91Y2hBY3Rpb24nO1xuICAvLyByYWRpdXMgZm9yIHRhcCBhbmQgdHJhY2tcbiAgbGV0IFRBUF9ESVNUQU5DRSA9IDI1O1xuICBsZXQgVFJBQ0tfRElTVEFOQ0UgPSA1O1xuICAvLyBudW1iZXIgb2YgbGFzdCBOIHRyYWNrIHBvc2l0aW9ucyB0byBrZWVwXG4gIGxldCBUUkFDS19MRU5HVEggPSAyO1xuXG4gIC8vIERpc2FibGluZyBcIm1vdXNlXCIgaGFuZGxlcnMgZm9yIDI1MDBtcyBpcyBlbm91Z2hcbiAgbGV0IE1PVVNFX1RJTUVPVVQgPSAyNTAwO1xuICBsZXQgTU9VU0VfRVZFTlRTID0gWydtb3VzZWRvd24nLCAnbW91c2Vtb3ZlJywgJ21vdXNldXAnLCAnY2xpY2snXTtcbiAgLy8gYW4gYXJyYXkgb2YgYml0bWFzayB2YWx1ZXMgZm9yIG1hcHBpbmcgTW91c2VFdmVudC53aGljaCB0byBNb3VzZUV2ZW50LmJ1dHRvbnNcbiAgbGV0IE1PVVNFX1dISUNIX1RPX0JVVFRPTlMgPSBbMCwgMSwgNCwgMl07XG4gIGxldCBNT1VTRV9IQVNfQlVUVE9OUyA9IChmdW5jdGlvbigpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIG5ldyBNb3VzZUV2ZW50KCd0ZXN0Jywge2J1dHRvbnM6IDF9KS5idXR0b25zID09PSAxO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0pKCk7XG5cbiAgLyogZXNsaW50IG5vLWVtcHR5OiBbXCJlcnJvclwiLCB7IFwiYWxsb3dFbXB0eUNhdGNoXCI6IHRydWUgfV0gKi9cbiAgLy8gY2hlY2sgZm9yIHBhc3NpdmUgZXZlbnQgbGlzdGVuZXJzXG4gIGxldCBTVVBQT1JUU19QQVNTSVZFID0gZmFsc2U7XG4gIChmdW5jdGlvbigpIHtcbiAgICB0cnkge1xuICAgICAgbGV0IG9wdHMgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdwYXNzaXZlJywge2dldDogZnVuY3Rpb24oKSB7U1VQUE9SVFNfUEFTU0lWRSA9IHRydWU7fX0pXG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndGVzdCcsIG51bGwsIG9wdHMpO1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Rlc3QnLCBudWxsLCBvcHRzKTtcbiAgICB9IGNhdGNoKGUpIHt9XG4gIH0pKCk7XG5cbiAgLy8gQ2hlY2sgZm9yIHRvdWNoLW9ubHkgZGV2aWNlc1xuICBsZXQgSVNfVE9VQ0hfT05MWSA9IG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL2lQKD86W29hXWR8aG9uZSl8QW5kcm9pZC8pO1xuXG4gIGxldCBHZXN0dXJlUmVjb2duaXplciA9IGZ1bmN0aW9uKCl7fTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICBHZXN0dXJlUmVjb2duaXplci5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbigpe307XG4gIC8qKiBAdHlwZSB7ZnVuY3Rpb24oTW91c2VFdmVudCkgfCB1bmRlZmluZWR9ICovXG4gIEdlc3R1cmVSZWNvZ25pemVyLnByb3RvdHlwZS5tb3VzZWRvd247XG4gIC8qKiBAdHlwZSB7KGZ1bmN0aW9uKE1vdXNlRXZlbnQpIHwgdW5kZWZpbmVkKX0gKi9cbiAgR2VzdHVyZVJlY29nbml6ZXIucHJvdG90eXBlLm1vdXNlbW92ZTtcbiAgLyoqIEB0eXBlIHsoZnVuY3Rpb24oTW91c2VFdmVudCkgfCB1bmRlZmluZWQpfSAqL1xuICBHZXN0dXJlUmVjb2duaXplci5wcm90b3R5cGUubW91c2V1cDtcbiAgLyoqIEB0eXBlIHsoZnVuY3Rpb24oVG91Y2hFdmVudCkgfCB1bmRlZmluZWQpfSAqL1xuICBHZXN0dXJlUmVjb2duaXplci5wcm90b3R5cGUudG91Y2hzdGFydDtcbiAgLyoqIEB0eXBlIHsoZnVuY3Rpb24oVG91Y2hFdmVudCkgfCB1bmRlZmluZWQpfSAqL1xuICBHZXN0dXJlUmVjb2duaXplci5wcm90b3R5cGUudG91Y2htb3ZlO1xuICAvKiogQHR5cGUgeyhmdW5jdGlvbihUb3VjaEV2ZW50KSB8IHVuZGVmaW5lZCl9ICovXG4gIEdlc3R1cmVSZWNvZ25pemVyLnByb3RvdHlwZS50b3VjaGVuZDtcbiAgLyoqIEB0eXBlIHsoZnVuY3Rpb24oTW91c2VFdmVudCkgfCB1bmRlZmluZWQpfSAqL1xuICBHZXN0dXJlUmVjb2duaXplci5wcm90b3R5cGUuY2xpY2s7XG5cbiAgLy8gdG91Y2ggd2lsbCBtYWtlIHN5bnRoZXRpYyBtb3VzZSBldmVudHNcbiAgLy8gYHByZXZlbnREZWZhdWx0YCBvbiB0b3VjaGVuZCB3aWxsIGNhbmNlbCB0aGVtLFxuICAvLyBidXQgdGhpcyBicmVha3MgYDxpbnB1dD5gIGZvY3VzIGFuZCBsaW5rIGNsaWNrc1xuICAvLyBkaXNhYmxlIG1vdXNlIGhhbmRsZXJzIGZvciBNT1VTRV9USU1FT1VUIG1zIGFmdGVyXG4gIC8vIGEgdG91Y2hlbmQgdG8gaWdub3JlIHN5bnRoZXRpYyBtb3VzZSBldmVudHNcbiAgbGV0IG1vdXNlQ2FuY2VsbGVyID0gZnVuY3Rpb24obW91c2VFdmVudCkge1xuICAgIC8vIENoZWNrIGZvciBzb3VyY2VDYXBhYmlsaXRpZXMsIHVzZWQgdG8gZGlzdGluZ3Vpc2ggc3ludGhldGljIGV2ZW50c1xuICAgIC8vIGlmIG1vdXNlRXZlbnQgZGlkIG5vdCBjb21lIGZyb20gYSBkZXZpY2UgdGhhdCBmaXJlcyB0b3VjaCBldmVudHMsXG4gICAgLy8gaXQgd2FzIG1hZGUgYnkgYSByZWFsIG1vdXNlIGFuZCBzaG91bGQgYmUgY291bnRlZFxuICAgIC8vIGh0dHA6Ly93aWNnLmdpdGh1Yi5pby9JbnB1dERldmljZUNhcGFiaWxpdGllcy8jZG9tLWlucHV0ZGV2aWNlY2FwYWJpbGl0aWVzLWZpcmVzdG91Y2hldmVudHNcbiAgICBsZXQgc2MgPSBtb3VzZUV2ZW50LnNvdXJjZUNhcGFiaWxpdGllcztcbiAgICBpZiAoc2MgJiYgIXNjLmZpcmVzVG91Y2hFdmVudHMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gc2tpcCBzeW50aGV0aWMgbW91c2UgZXZlbnRzXG4gICAgbW91c2VFdmVudFtIQU5ETEVEX09CSl0gPSB7c2tpcDogdHJ1ZX07XG4gICAgLy8gZGlzYWJsZSBcImdob3N0IGNsaWNrc1wiXG4gICAgaWYgKG1vdXNlRXZlbnQudHlwZSA9PT0gJ2NsaWNrJykge1xuICAgICAgbGV0IHBhdGggPSBtb3VzZUV2ZW50LmNvbXBvc2VkUGF0aCAmJiBtb3VzZUV2ZW50LmNvbXBvc2VkUGF0aCgpO1xuICAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKHBhdGhbaV0gPT09IFBPSU5URVJTVEFURS5tb3VzZS50YXJnZXQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG1vdXNlRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIG1vdXNlRXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBzZXR1cCBUcnVlIHRvIGFkZCwgZmFsc2UgdG8gcmVtb3ZlLlxuICAgKi9cbiAgZnVuY3Rpb24gc2V0dXBUZWFyZG93bk1vdXNlQ2FuY2VsbGVyKHNldHVwKSB7XG4gICAgbGV0IGV2ZW50cyA9IElTX1RPVUNIX09OTFkgPyBbJ2NsaWNrJ10gOiBNT1VTRV9FVkVOVFM7XG4gICAgZm9yIChsZXQgaSA9IDAsIGVuOyBpIDwgZXZlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBlbiA9IGV2ZW50c1tpXTtcbiAgICAgIGlmIChzZXR1cCkge1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKGVuLCBtb3VzZUNhbmNlbGxlciwgdHJ1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGVuLCBtb3VzZUNhbmNlbGxlciwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaWdub3JlTW91c2UoZSkge1xuICAgIGlmICghUE9JTlRFUlNUQVRFLm1vdXNlLm1vdXNlSWdub3JlSm9iKSB7XG4gICAgICBzZXR1cFRlYXJkb3duTW91c2VDYW5jZWxsZXIodHJ1ZSk7XG4gICAgfVxuICAgIGxldCB1bnNldCA9IGZ1bmN0aW9uKCkge1xuICAgICAgc2V0dXBUZWFyZG93bk1vdXNlQ2FuY2VsbGVyKCk7XG4gICAgICBQT0lOVEVSU1RBVEUubW91c2UudGFyZ2V0ID0gbnVsbDtcbiAgICAgIFBPSU5URVJTVEFURS5tb3VzZS5tb3VzZUlnbm9yZUpvYiA9IG51bGw7XG4gICAgfTtcbiAgICBQT0lOVEVSU1RBVEUubW91c2UudGFyZ2V0ID0gZS5jb21wb3NlZFBhdGgoKVswXTtcbiAgICBQT0lOVEVSU1RBVEUubW91c2UubW91c2VJZ25vcmVKb2IgPSBQb2x5bWVyLkRlYm91bmNlci5kZWJvdW5jZShcbiAgICAgICAgICBQT0lOVEVSU1RBVEUubW91c2UubW91c2VJZ25vcmVKb2JcbiAgICAgICAgLCBQb2x5bWVyLkFzeW5jLnRpbWVPdXQuYWZ0ZXIoTU9VU0VfVElNRU9VVClcbiAgICAgICAgLCB1bnNldCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBldiBldmVudCB0byB0ZXN0IGZvciBsZWZ0IG1vdXNlIGJ1dHRvbiBkb3duXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IGhhcyBsZWZ0IG1vdXNlIGJ1dHRvbiBkb3duXG4gICAqL1xuICBmdW5jdGlvbiBoYXNMZWZ0TW91c2VCdXR0b24oZXYpIHtcbiAgICBsZXQgdHlwZSA9IGV2LnR5cGU7XG4gICAgLy8gZXhpdCBlYXJseSBpZiB0aGUgZXZlbnQgaXMgbm90IGEgbW91c2UgZXZlbnRcbiAgICBpZiAoTU9VU0VfRVZFTlRTLmluZGV4T2YodHlwZSkgPT09IC0xKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIGV2LmJ1dHRvbiBpcyBub3QgcmVsaWFibGUgZm9yIG1vdXNlbW92ZSAoMCBpcyBvdmVybG9hZGVkIGFzIGJvdGggbGVmdCBidXR0b24gYW5kIG5vIGJ1dHRvbnMpXG4gICAgLy8gaW5zdGVhZCB3ZSB1c2UgZXYuYnV0dG9ucyAoYml0bWFzayBvZiBidXR0b25zKSBvciBmYWxsIGJhY2sgdG8gZXYud2hpY2ggKGRlcHJlY2F0ZWQsIDAgZm9yIG5vIGJ1dHRvbnMsIDEgZm9yIGxlZnQgYnV0dG9uKVxuICAgIGlmICh0eXBlID09PSAnbW91c2Vtb3ZlJykge1xuICAgICAgLy8gYWxsb3cgdW5kZWZpbmVkIGZvciB0ZXN0aW5nIGV2ZW50c1xuICAgICAgbGV0IGJ1dHRvbnMgPSBldi5idXR0b25zID09PSB1bmRlZmluZWQgPyAxIDogZXYuYnV0dG9ucztcbiAgICAgIGlmICgoZXYgaW5zdGFuY2VvZiB3aW5kb3cuTW91c2VFdmVudCkgJiYgIU1PVVNFX0hBU19CVVRUT05TKSB7XG4gICAgICAgIGJ1dHRvbnMgPSBNT1VTRV9XSElDSF9UT19CVVRUT05TW2V2LndoaWNoXSB8fCAwO1xuICAgICAgfVxuICAgICAgLy8gYnV0dG9ucyBpcyBhIGJpdG1hc2ssIGNoZWNrIHRoYXQgdGhlIGxlZnQgYnV0dG9uIGJpdCBpcyBzZXQgKDEpXG4gICAgICByZXR1cm4gQm9vbGVhbihidXR0b25zICYgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGFsbG93IHVuZGVmaW5lZCBmb3IgdGVzdGluZyBldmVudHNcbiAgICAgIGxldCBidXR0b24gPSBldi5idXR0b24gPT09IHVuZGVmaW5lZCA/IDAgOiBldi5idXR0b247XG4gICAgICAvLyBldi5idXR0b24gaXMgMCBpbiBtb3VzZWRvd24vbW91c2V1cC9jbGljayBmb3IgbGVmdCBidXR0b24gYWN0aXZhdGlvblxuICAgICAgcmV0dXJuIGJ1dHRvbiA9PT0gMDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc1N5bnRoZXRpY0NsaWNrKGV2KSB7XG4gICAgaWYgKGV2LnR5cGUgPT09ICdjbGljaycpIHtcbiAgICAgIC8vIGV2LmRldGFpbCBpcyAwIGZvciBIVE1MRWxlbWVudC5jbGljayBpbiBtb3N0IGJyb3dzZXJzXG4gICAgICBpZiAoZXYuZGV0YWlsID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgLy8gaW4gdGhlIHdvcnN0IGNhc2UsIGNoZWNrIHRoYXQgdGhlIHgveSBwb3NpdGlvbiBvZiB0aGUgY2xpY2sgaXMgd2l0aGluXG4gICAgICAvLyB0aGUgYm91bmRpbmcgYm94IG9mIHRoZSB0YXJnZXQgb2YgdGhlIGV2ZW50XG4gICAgICAvLyBUaGFua3MgSUUgMTAgPjooXG4gICAgICBsZXQgdCA9IEdlc3R1cmVzLl9maW5kT3JpZ2luYWxUYXJnZXQoZXYpO1xuICAgICAgLy8gbWFrZSBzdXJlIHRoZSB0YXJnZXQgb2YgdGhlIGV2ZW50IGlzIGFuIGVsZW1lbnQgc28gd2UgY2FuIHVzZSBnZXRCb3VuZGluZ0NsaWVudFJlY3QsXG4gICAgICAvLyBpZiBub3QsIGp1c3QgYXNzdW1lIGl0IGlzIGEgc3ludGhldGljIGNsaWNrXG4gICAgICBpZiAoIXQubm9kZVR5cGUgfHwgLyoqIEB0eXBlIHtFbGVtZW50fSAqLyh0KS5ub2RlVHlwZSAhPT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBsZXQgYmNyID0gLyoqIEB0eXBlIHtFbGVtZW50fSAqLyh0KS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIC8vIHVzZSBwYWdlIHgveSB0byBhY2NvdW50IGZvciBzY3JvbGxpbmdcbiAgICAgIGxldCB4ID0gZXYucGFnZVgsIHkgPSBldi5wYWdlWTtcbiAgICAgIC8vIGV2IGlzIGEgc3ludGhldGljIGNsaWNrIGlmIHRoZSBwb3NpdGlvbiBpcyBvdXRzaWRlIHRoZSBib3VuZGluZyBib3ggb2YgdGhlIHRhcmdldFxuICAgICAgcmV0dXJuICEoKHggPj0gYmNyLmxlZnQgJiYgeCA8PSBiY3IucmlnaHQpICYmICh5ID49IGJjci50b3AgJiYgeSA8PSBiY3IuYm90dG9tKSk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGxldCBQT0lOVEVSU1RBVEUgPSB7XG4gICAgbW91c2U6IHtcbiAgICAgIHRhcmdldDogbnVsbCxcbiAgICAgIG1vdXNlSWdub3JlSm9iOiBudWxsXG4gICAgfSxcbiAgICB0b3VjaDoge1xuICAgICAgeDogMCxcbiAgICAgIHk6IDAsXG4gICAgICBpZDogLTEsXG4gICAgICBzY3JvbGxEZWNpZGVkOiBmYWxzZVxuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBmaXJzdFRvdWNoQWN0aW9uKGV2KSB7XG4gICAgbGV0IHRhID0gJ2F1dG8nO1xuICAgIGxldCBwYXRoID0gZXYuY29tcG9zZWRQYXRoICYmIGV2LmNvbXBvc2VkUGF0aCgpO1xuICAgIGlmIChwYXRoKSB7XG4gICAgICBmb3IgKGxldCBpID0gMCwgbjsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbiA9IHBhdGhbaV07XG4gICAgICAgIGlmIChuW1RPVUNIX0FDVElPTl0pIHtcbiAgICAgICAgICB0YSA9IG5bVE9VQ0hfQUNUSU9OXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGE7XG4gIH1cblxuICBmdW5jdGlvbiB0cmFja0RvY3VtZW50KHN0YXRlT2JqLCBtb3ZlZm4sIHVwZm4pIHtcbiAgICBzdGF0ZU9iai5tb3ZlZm4gPSBtb3ZlZm47XG4gICAgc3RhdGVPYmoudXBmbiA9IHVwZm47XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgbW92ZWZuKTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdXBmbik7XG4gIH1cblxuICBmdW5jdGlvbiB1bnRyYWNrRG9jdW1lbnQoc3RhdGVPYmopIHtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBzdGF0ZU9iai5tb3ZlZm4pO1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBzdGF0ZU9iai51cGZuKTtcbiAgICBzdGF0ZU9iai5tb3ZlZm4gPSBudWxsO1xuICAgIHN0YXRlT2JqLnVwZm4gPSBudWxsO1xuICB9XG5cbiAgLy8gdXNlIGEgZG9jdW1lbnQtd2lkZSB0b3VjaGVuZCBsaXN0ZW5lciB0byBzdGFydCB0aGUgZ2hvc3QtY2xpY2sgcHJldmVudGlvbiBtZWNoYW5pc21cbiAgLy8gVXNlIHBhc3NpdmUgZXZlbnQgbGlzdGVuZXJzLCBpZiBzdXBwb3J0ZWQsIHRvIG5vdCBhZmZlY3Qgc2Nyb2xsaW5nIHBlcmZvcm1hbmNlXG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgaWdub3JlTW91c2UsIFNVUFBPUlRTX1BBU1NJVkUgPyB7cGFzc2l2ZTogdHJ1ZX0gOiBmYWxzZSk7XG5cbiAgLyoqXG4gICAqIE1vZHVsZSBmb3IgYWRkaW5nIGxpc3RlbmVycyB0byBhIG5vZGUgZm9yIHRoZSBmb2xsb3dpbmcgbm9ybWFsaXplZFxuICAgKiBjcm9zcy1wbGF0Zm9ybSBcImdlc3R1cmVcIiBldmVudHM6XG4gICAqIC0gYGRvd25gIC0gbW91c2Ugb3IgdG91Y2ggd2VudCBkb3duXG4gICAqIC0gYHVwYCAtIG1vdXNlIG9yIHRvdWNoIHdlbnQgdXBcbiAgICogLSBgdGFwYCAtIG1vdXNlIGNsaWNrIG9yIGZpbmdlciB0YXBcbiAgICogLSBgdHJhY2tgIC0gbW91c2UgZHJhZyBvciB0b3VjaCBtb3ZlXG4gICAqXG4gICAqIEBuYW1lc3BhY2VcbiAgICogQG1lbWJlcm9mIFBvbHltZXJcbiAgICogQHN1bW1hcnkgTW9kdWxlIGZvciBhZGRpbmcgY3Jvc3MtcGxhdGZvcm0gZ2VzdHVyZSBldmVudCBsaXN0ZW5lcnMuXG4gICAqL1xuICBjb25zdCBHZXN0dXJlcyA9IHtcbiAgICBnZXN0dXJlczoge30sXG4gICAgcmVjb2duaXplcnM6IFtdLFxuXG4gICAgLyoqXG4gICAgICogRmluZHMgdGhlIGVsZW1lbnQgcmVuZGVyZWQgb24gdGhlIHNjcmVlbiBhdCB0aGUgcHJvdmlkZWQgY29vcmRpbmF0ZXMuXG4gICAgICpcbiAgICAgKiBTaW1pbGFyIHRvIGBkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50YCwgYnV0IHBpZXJjZXMgdGhyb3VnaFxuICAgICAqIHNoYWRvdyByb290cy5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBQb2x5bWVyLkdlc3R1cmVzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggSG9yaXpvbnRhbCBwaXhlbCBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgVmVydGljYWwgcGl4ZWwgY29vcmRpbmF0ZVxuICAgICAqIEByZXR1cm4ge0VsZW1lbnR9IFJldHVybnMgdGhlIGRlZXBlc3Qgc2hhZG93Um9vdCBpbmNsdXNpdmUgZWxlbWVudFxuICAgICAqIGZvdW5kIGF0IHRoZSBzY3JlZW4gcG9zaXRpb24gZ2l2ZW4uXG4gICAgICovXG4gICAgZGVlcFRhcmdldEZpbmQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgIGxldCBub2RlID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludCh4LCB5KTtcbiAgICAgIGxldCBuZXh0ID0gbm9kZTtcbiAgICAgIC8vIHRoaXMgY29kZSBwYXRoIGlzIG9ubHkgdGFrZW4gd2hlbiBuYXRpdmUgU2hhZG93RE9NIGlzIHVzZWRcbiAgICAgIC8vIGlmIHRoZXJlIGlzIGEgc2hhZG93cm9vdCwgaXQgbWF5IGhhdmUgYSBub2RlIGF0IHgveVxuICAgICAgLy8gaWYgdGhlcmUgaXMgbm90IGEgc2hhZG93cm9vdCwgZXhpdCB0aGUgbG9vcFxuICAgICAgd2hpbGUgKG5leHQgJiYgbmV4dC5zaGFkb3dSb290ICYmICF3aW5kb3cuU2hhZHlET00pIHtcbiAgICAgICAgLy8gaWYgdGhlcmUgaXMgYSBub2RlIGF0IHgveSBpbiB0aGUgc2hhZG93cm9vdCwgbG9vayBkZWVwZXJcbiAgICAgICAgbGV0IG9sZE5leHQgPSBuZXh0O1xuICAgICAgICBuZXh0ID0gbmV4dC5zaGFkb3dSb290LmVsZW1lbnRGcm9tUG9pbnQoeCwgeSk7XG4gICAgICAgIC8vIG9uIFNhZmFyaSwgZWxlbWVudEZyb21Qb2ludCBtYXkgcmV0dXJuIHRoZSBzaGFkb3dSb290IGhvc3RcbiAgICAgICAgaWYgKG9sZE5leHQgPT09IG5leHQpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAobmV4dCkge1xuICAgICAgICAgIG5vZGUgPSBuZXh0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIGEgY2hlYXBlciBjaGVjayB0aGFuIGV2LmNvbXBvc2VkUGF0aCgpWzBdO1xuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBldiBFdmVudC5cbiAgICAgKiBAcmV0dXJuIHtFdmVudFRhcmdldH0gUmV0dXJucyB0aGUgZXZlbnQgdGFyZ2V0LlxuICAgICAqL1xuICAgIF9maW5kT3JpZ2luYWxUYXJnZXQ6IGZ1bmN0aW9uKGV2KSB7XG4gICAgICAvLyBzaGFkb3dkb21cbiAgICAgIGlmIChldi5jb21wb3NlZFBhdGgpIHtcbiAgICAgICAgcmV0dXJuIC8qKiBAdHlwZSB7RXZlbnRUYXJnZXR9ICovKGV2LmNvbXBvc2VkUGF0aCgpWzBdKTtcbiAgICAgIH1cbiAgICAgIC8vIHNoYWR5ZG9tXG4gICAgICByZXR1cm4gZXYudGFyZ2V0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2IEV2ZW50LlxuICAgICAqL1xuICAgIF9oYW5kbGVOYXRpdmU6IGZ1bmN0aW9uKGV2KSB7XG4gICAgICBsZXQgaGFuZGxlZDtcbiAgICAgIGxldCB0eXBlID0gZXYudHlwZTtcbiAgICAgIGxldCBub2RlID0gZXYuY3VycmVudFRhcmdldDtcbiAgICAgIGxldCBnb2JqID0gbm9kZVtHRVNUVVJFX0tFWV07XG4gICAgICBpZiAoIWdvYmopIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGV0IGdzID0gZ29ialt0eXBlXTtcbiAgICAgIGlmICghZ3MpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCFldltIQU5ETEVEX09CSl0pIHtcbiAgICAgICAgZXZbSEFORExFRF9PQkpdID0ge307XG4gICAgICAgIGlmICh0eXBlLnNsaWNlKDAsIDUpID09PSAndG91Y2gnKSB7XG4gICAgICAgICAgZXYgPSAvKiogQHR5cGUge1RvdWNoRXZlbnR9ICovKGV2KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWFzc2lnblxuICAgICAgICAgIGxldCB0ID0gZXYuY2hhbmdlZFRvdWNoZXNbMF07XG4gICAgICAgICAgaWYgKHR5cGUgPT09ICd0b3VjaHN0YXJ0Jykge1xuICAgICAgICAgICAgLy8gb25seSBoYW5kbGUgdGhlIGZpcnN0IGZpbmdlclxuICAgICAgICAgICAgaWYgKGV2LnRvdWNoZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgIFBPSU5URVJTVEFURS50b3VjaC5pZCA9IHQuaWRlbnRpZmllcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKFBPSU5URVJTVEFURS50b3VjaC5pZCAhPT0gdC5pZGVudGlmaWVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghSEFTX05BVElWRV9UQSkge1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09ICd0b3VjaHN0YXJ0JyB8fCB0eXBlID09PSAndG91Y2htb3ZlJykge1xuICAgICAgICAgICAgICBHZXN0dXJlcy5faGFuZGxlVG91Y2hBY3Rpb24oZXYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaGFuZGxlZCA9IGV2W0hBTkRMRURfT0JKXTtcbiAgICAgIC8vIHVzZWQgdG8gaWdub3JlIHN5bnRoZXRpYyBtb3VzZSBldmVudHNcbiAgICAgIGlmIChoYW5kbGVkLnNraXApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGV0IHJlY29nbml6ZXJzID0gR2VzdHVyZXMucmVjb2duaXplcnM7XG4gICAgICAvLyByZXNldCByZWNvZ25pemVyIHN0YXRlXG4gICAgICBmb3IgKGxldCBpID0gMCwgcjsgaSA8IHJlY29nbml6ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHIgPSByZWNvZ25pemVyc1tpXTtcbiAgICAgICAgaWYgKGdzW3IubmFtZV0gJiYgIWhhbmRsZWRbci5uYW1lXSkge1xuICAgICAgICAgIGlmIChyLmZsb3cgJiYgci5mbG93LnN0YXJ0LmluZGV4T2YoZXYudHlwZSkgPiAtMSAmJiByLnJlc2V0KSB7XG4gICAgICAgICAgICByLnJlc2V0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBlbmZvcmNlIGdlc3R1cmUgcmVjb2duaXplciBvcmRlclxuICAgICAgZm9yIChsZXQgaSA9IDAsIHI7IGkgPCByZWNvZ25pemVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICByID0gcmVjb2duaXplcnNbaV07XG4gICAgICAgIGlmIChnc1tyLm5hbWVdICYmICFoYW5kbGVkW3IubmFtZV0pIHtcbiAgICAgICAgICBoYW5kbGVkW3IubmFtZV0gPSB0cnVlO1xuICAgICAgICAgIHJbdHlwZV0oZXYpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtUb3VjaEV2ZW50fSBldiBFdmVudC5cbiAgICAgKi9cbiAgICBfaGFuZGxlVG91Y2hBY3Rpb246IGZ1bmN0aW9uKGV2KSB7XG4gICAgICBsZXQgdCA9IGV2LmNoYW5nZWRUb3VjaGVzWzBdO1xuICAgICAgbGV0IHR5cGUgPSBldi50eXBlO1xuICAgICAgaWYgKHR5cGUgPT09ICd0b3VjaHN0YXJ0Jykge1xuICAgICAgICBQT0lOVEVSU1RBVEUudG91Y2gueCA9IHQuY2xpZW50WDtcbiAgICAgICAgUE9JTlRFUlNUQVRFLnRvdWNoLnkgPSB0LmNsaWVudFk7XG4gICAgICAgIFBPSU5URVJTVEFURS50b3VjaC5zY3JvbGxEZWNpZGVkID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICd0b3VjaG1vdmUnKSB7XG4gICAgICAgIGlmIChQT0lOVEVSU1RBVEUudG91Y2guc2Nyb2xsRGVjaWRlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBQT0lOVEVSU1RBVEUudG91Y2guc2Nyb2xsRGVjaWRlZCA9IHRydWU7XG4gICAgICAgIGxldCB0YSA9IGZpcnN0VG91Y2hBY3Rpb24oZXYpO1xuICAgICAgICBsZXQgcHJldmVudCA9IGZhbHNlO1xuICAgICAgICBsZXQgZHggPSBNYXRoLmFicyhQT0lOVEVSU1RBVEUudG91Y2gueCAtIHQuY2xpZW50WCk7XG4gICAgICAgIGxldCBkeSA9IE1hdGguYWJzKFBPSU5URVJTVEFURS50b3VjaC55IC0gdC5jbGllbnRZKTtcbiAgICAgICAgaWYgKCFldi5jYW5jZWxhYmxlKSB7XG4gICAgICAgICAgLy8gc2Nyb2xsaW5nIGlzIGhhcHBlbmluZ1xuICAgICAgICB9IGVsc2UgaWYgKHRhID09PSAnbm9uZScpIHtcbiAgICAgICAgICBwcmV2ZW50ID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmICh0YSA9PT0gJ3Bhbi14Jykge1xuICAgICAgICAgIHByZXZlbnQgPSBkeSA+IGR4O1xuICAgICAgICB9IGVsc2UgaWYgKHRhID09PSAncGFuLXknKSB7XG4gICAgICAgICAgcHJldmVudCA9IGR4ID4gZHk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByZXZlbnQpIHtcbiAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIEdlc3R1cmVzLnByZXZlbnQoJ3RyYWNrJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhbiBldmVudCBsaXN0ZW5lciB0byBhIG5vZGUgZm9yIHRoZSBnaXZlbiBnZXN0dXJlIHR5cGUuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgUG9seW1lci5HZXN0dXJlc1xuICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBOb2RlIHRvIGFkZCBsaXN0ZW5lciBvblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldlR5cGUgR2VzdHVyZSB0eXBlOiBgZG93bmAsIGB1cGAsIGB0cmFja2AsIG9yIGB0YXBgXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciBFdmVudCBsaXN0ZW5lciBmdW5jdGlvbiB0byBjYWxsXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIGEgZ2VzdHVyZSBldmVudCBsaXN0ZW5lciB3YXMgYWRkZWQuXG4gICAgICogQHRoaXMge0dlc3R1cmVzfVxuICAgICAqL1xuICAgIGFkZExpc3RlbmVyOiBmdW5jdGlvbihub2RlLCBldlR5cGUsIGhhbmRsZXIpIHtcbiAgICAgIGlmICh0aGlzLmdlc3R1cmVzW2V2VHlwZV0pIHtcbiAgICAgICAgdGhpcy5fYWRkKG5vZGUsIGV2VHlwZSwgaGFuZGxlcik7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFuIGV2ZW50IGxpc3RlbmVyIGZyb20gYSBub2RlIGZvciB0aGUgZ2l2ZW4gZ2VzdHVyZSB0eXBlLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIFBvbHltZXIuR2VzdHVyZXNcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgTm9kZSB0byByZW1vdmUgbGlzdGVuZXIgZnJvbVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldlR5cGUgR2VzdHVyZSB0eXBlOiBgZG93bmAsIGB1cGAsIGB0cmFja2AsIG9yIGB0YXBgXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciBFdmVudCBsaXN0ZW5lciBmdW5jdGlvbiBwcmV2aW91c2x5IHBhc3NlZCB0b1xuICAgICAqICBgYWRkTGlzdGVuZXJgLlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiBhIGdlc3R1cmUgZXZlbnQgbGlzdGVuZXIgd2FzIHJlbW92ZWQuXG4gICAgICogQHRoaXMge0dlc3R1cmVzfVxuICAgICAqL1xuICAgIHJlbW92ZUxpc3RlbmVyOiBmdW5jdGlvbihub2RlLCBldlR5cGUsIGhhbmRsZXIpIHtcbiAgICAgIGlmICh0aGlzLmdlc3R1cmVzW2V2VHlwZV0pIHtcbiAgICAgICAgdGhpcy5fcmVtb3ZlKG5vZGUsIGV2VHlwZSwgaGFuZGxlcik7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBhdXRvbWF0ZSB0aGUgZXZlbnQgbGlzdGVuZXJzIGZvciB0aGUgbmF0aXZlIGV2ZW50c1xuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBub2RlIE5vZGUgb24gd2hpY2ggdG8gYWRkIHRoZSBldmVudC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZUeXBlIEV2ZW50IHR5cGUgdG8gYWRkLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oRXZlbnQ/KX0gaGFuZGxlciBFdmVudCBoYW5kbGVyIGZ1bmN0aW9uLlxuICAgICAqIEB0aGlzIHtHZXN0dXJlc31cbiAgICAgKi9cbiAgICBfYWRkOiBmdW5jdGlvbihub2RlLCBldlR5cGUsIGhhbmRsZXIpIHtcbiAgICAgIGxldCByZWNvZ25pemVyID0gdGhpcy5nZXN0dXJlc1tldlR5cGVdO1xuICAgICAgbGV0IGRlcHMgPSByZWNvZ25pemVyLmRlcHM7XG4gICAgICBsZXQgbmFtZSA9IHJlY29nbml6ZXIubmFtZTtcbiAgICAgIGxldCBnb2JqID0gbm9kZVtHRVNUVVJFX0tFWV07XG4gICAgICBpZiAoIWdvYmopIHtcbiAgICAgICAgbm9kZVtHRVNUVVJFX0tFWV0gPSBnb2JqID0ge307XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBpID0gMCwgZGVwLCBnZDsgaSA8IGRlcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZGVwID0gZGVwc1tpXTtcbiAgICAgICAgLy8gZG9uJ3QgYWRkIG1vdXNlIGhhbmRsZXJzIG9uIGlPUyBiZWNhdXNlIHRoZXkgY2F1c2UgZ3JheSBzZWxlY3Rpb24gb3ZlcmxheXNcbiAgICAgICAgaWYgKElTX1RPVUNIX09OTFkgJiYgTU9VU0VfRVZFTlRTLmluZGV4T2YoZGVwKSA+IC0xICYmIGRlcCAhPT0gJ2NsaWNrJykge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGdkID0gZ29ialtkZXBdO1xuICAgICAgICBpZiAoIWdkKSB7XG4gICAgICAgICAgZ29ialtkZXBdID0gZ2QgPSB7X2NvdW50OiAwfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ2QuX2NvdW50ID09PSAwKSB7XG4gICAgICAgICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKGRlcCwgdGhpcy5faGFuZGxlTmF0aXZlKTtcbiAgICAgICAgfVxuICAgICAgICBnZFtuYW1lXSA9IChnZFtuYW1lXSB8fCAwKSArIDE7XG4gICAgICAgIGdkLl9jb3VudCA9IChnZC5fY291bnQgfHwgMCkgKyAxO1xuICAgICAgfVxuICAgICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKGV2VHlwZSwgaGFuZGxlcik7XG4gICAgICBpZiAocmVjb2duaXplci50b3VjaEFjdGlvbikge1xuICAgICAgICB0aGlzLnNldFRvdWNoQWN0aW9uKG5vZGUsIHJlY29nbml6ZXIudG91Y2hBY3Rpb24pO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBhdXRvbWF0ZSBldmVudCBsaXN0ZW5lciByZW1vdmFsIGZvciBuYXRpdmUgZXZlbnRzXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG5vZGUgTm9kZSBvbiB3aGljaCB0byByZW1vdmUgdGhlIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldlR5cGUgRXZlbnQgdHlwZSB0byByZW1vdmUuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihFdmVudD8pfSBoYW5kbGVyIEV2ZW50IGhhbmRsZXIgZnVuY3Rpb24uXG4gICAgICogQHRoaXMge0dlc3R1cmVzfVxuICAgICAqL1xuICAgIF9yZW1vdmU6IGZ1bmN0aW9uKG5vZGUsIGV2VHlwZSwgaGFuZGxlcikge1xuICAgICAgbGV0IHJlY29nbml6ZXIgPSB0aGlzLmdlc3R1cmVzW2V2VHlwZV07XG4gICAgICBsZXQgZGVwcyA9IHJlY29nbml6ZXIuZGVwcztcbiAgICAgIGxldCBuYW1lID0gcmVjb2duaXplci5uYW1lO1xuICAgICAgbGV0IGdvYmogPSBub2RlW0dFU1RVUkVfS0VZXTtcbiAgICAgIGlmIChnb2JqKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBkZXAsIGdkOyBpIDwgZGVwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGRlcCA9IGRlcHNbaV07XG4gICAgICAgICAgZ2QgPSBnb2JqW2RlcF07XG4gICAgICAgICAgaWYgKGdkICYmIGdkW25hbWVdKSB7XG4gICAgICAgICAgICBnZFtuYW1lXSA9IChnZFtuYW1lXSB8fCAxKSAtIDE7XG4gICAgICAgICAgICBnZC5fY291bnQgPSAoZ2QuX2NvdW50IHx8IDEpIC0gMTtcbiAgICAgICAgICAgIGlmIChnZC5fY291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKGRlcCwgdGhpcy5faGFuZGxlTmF0aXZlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihldlR5cGUsIGhhbmRsZXIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYSBuZXcgZ2VzdHVyZSBldmVudCByZWNvZ25pemVyIGZvciBhZGRpbmcgbmV3IGN1c3RvbVxuICAgICAqIGdlc3R1cmUgZXZlbnQgdHlwZXMuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgUG9seW1lci5HZXN0dXJlc1xuICAgICAqIEBwYXJhbSB7R2VzdHVyZVJlY29nbml6ZXJ9IHJlY29nIEdlc3R1cmUgcmVjb2duaXplciBkZXNjcmlwdG9yXG4gICAgICogQHRoaXMge0dlc3R1cmVzfVxuICAgICAqL1xuICAgIHJlZ2lzdGVyOiBmdW5jdGlvbihyZWNvZykge1xuICAgICAgdGhpcy5yZWNvZ25pemVycy5wdXNoKHJlY29nKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVjb2cuZW1pdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5nZXN0dXJlc1tyZWNvZy5lbWl0c1tpXV0gPSByZWNvZztcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZOYW1lIEV2ZW50IG5hbWUuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBSZXR1cm5zIHRoZSBnZXN0dXJlIGZvciB0aGUgZ2l2ZW4gZXZlbnQgbmFtZS5cbiAgICAgKiBAdGhpcyB7R2VzdHVyZXN9XG4gICAgICovXG4gICAgX2ZpbmRSZWNvZ25pemVyQnlFdmVudDogZnVuY3Rpb24oZXZOYW1lKSB7XG4gICAgICBmb3IgKGxldCBpID0gMCwgcjsgaSA8IHRoaXMucmVjb2duaXplcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgciA9IHRoaXMucmVjb2duaXplcnNbaV07XG4gICAgICAgIGZvciAobGV0IGogPSAwLCBuOyBqIDwgci5lbWl0cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIG4gPSByLmVtaXRzW2pdO1xuICAgICAgICAgIGlmIChuID09PSBldk5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiByO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgc2Nyb2xsaW5nIGRpcmVjdGlvbiBvbiBub2RlLlxuICAgICAqXG4gICAgICogVGhpcyB2YWx1ZSBpcyBjaGVja2VkIG9uIGZpcnN0IG1vdmUsIHRodXMgaXQgc2hvdWxkIGJlIGNhbGxlZCBwcmlvciB0b1xuICAgICAqIGFkZGluZyBldmVudCBsaXN0ZW5lcnMuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgUG9seW1lci5HZXN0dXJlc1xuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZSBOb2RlIHRvIHNldCB0b3VjaCBhY3Rpb24gc2V0dGluZyBvblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSBUb3VjaCBhY3Rpb24gdmFsdWVcbiAgICAgKi9cbiAgICBzZXRUb3VjaEFjdGlvbjogZnVuY3Rpb24obm9kZSwgdmFsdWUpIHtcbiAgICAgIGlmIChIQVNfTkFUSVZFX1RBKSB7XG4gICAgICAgIG5vZGUuc3R5bGUudG91Y2hBY3Rpb24gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIG5vZGVbVE9VQ0hfQUNUSU9OXSA9IHZhbHVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEaXNwYXRjaGVzIGFuIGV2ZW50IG9uIHRoZSBgdGFyZ2V0YCBlbGVtZW50IG9mIGB0eXBlYCB3aXRoIHRoZSBnaXZlblxuICAgICAqIGBkZXRhaWxgLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudFRhcmdldH0gdGFyZ2V0IFRoZSBlbGVtZW50IG9uIHdoaWNoIHRvIGZpcmUgYW4gZXZlbnQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgVGhlIHR5cGUgb2YgZXZlbnQgdG8gZmlyZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdD19IGRldGFpbCBUaGUgZGV0YWlsIG9iamVjdCB0byBwb3B1bGF0ZSBvbiB0aGUgZXZlbnQuXG4gICAgICovXG4gICAgX2ZpcmU6IGZ1bmN0aW9uKHRhcmdldCwgdHlwZSwgZGV0YWlsKSB7XG4gICAgICBsZXQgZXYgPSBuZXcgRXZlbnQodHlwZSwgeyBidWJibGVzOiB0cnVlLCBjYW5jZWxhYmxlOiB0cnVlLCBjb21wb3NlZDogdHJ1ZSB9KTtcbiAgICAgIGV2LmRldGFpbCA9IGRldGFpbDtcbiAgICAgIHRhcmdldC5kaXNwYXRjaEV2ZW50KGV2KTtcbiAgICAgIC8vIGZvcndhcmQgYHByZXZlbnREZWZhdWx0YCBpbiBhIGNsZWFuIHdheVxuICAgICAgaWYgKGV2LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgbGV0IHByZXZlbnRlciA9IGRldGFpbC5wcmV2ZW50ZXIgfHwgZGV0YWlsLnNvdXJjZUV2ZW50O1xuICAgICAgICBpZiAocHJldmVudGVyICYmIHByZXZlbnRlci5wcmV2ZW50RGVmYXVsdCkge1xuICAgICAgICAgIHByZXZlbnRlci5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFByZXZlbnRzIHRoZSBkaXNwYXRjaCBhbmQgZGVmYXVsdCBhY3Rpb24gb2YgdGhlIGdpdmVuIGV2ZW50IG5hbWUuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgUG9seW1lci5HZXN0dXJlc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldk5hbWUgRXZlbnQgbmFtZS5cbiAgICAgKiBAdGhpcyB7R2VzdHVyZXN9XG4gICAgICovXG4gICAgcHJldmVudDogZnVuY3Rpb24oZXZOYW1lKSB7XG4gICAgICBsZXQgcmVjb2duaXplciA9IHRoaXMuX2ZpbmRSZWNvZ25pemVyQnlFdmVudChldk5hbWUpO1xuICAgICAgaWYgKHJlY29nbml6ZXIuaW5mbykge1xuICAgICAgICByZWNvZ25pemVyLmluZm8ucHJldmVudCA9IHRydWU7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlc2V0IHRoZSAyNTAwbXMgdGltZW91dCBvbiBwcm9jZXNzaW5nIG1vdXNlIGlucHV0IGFmdGVyIGRldGVjdGluZyB0b3VjaCBpbnB1dC5cbiAgICAgKlxuICAgICAqIFRvdWNoIGlucHV0cyBjcmVhdGUgc3ludGhlc2l6ZWQgbW91c2UgaW5wdXRzIGFueXdoZXJlIGZyb20gMCB0byAyMDAwbXMgYWZ0ZXIgdGhlIHRvdWNoLlxuICAgICAqIFRoaXMgbWV0aG9kIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBkdXJpbmcgdGVzdGluZyB3aXRoIHNpbXVsYXRlZCB0b3VjaCBpbnB1dHMuXG4gICAgICogQ2FsbGluZyB0aGlzIG1ldGhvZCBpbiBwcm9kdWN0aW9uIG1heSBjYXVzZSBkdXBsaWNhdGUgdGFwcyBvciBvdGhlciBHZXN0dXJlcy5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBQb2x5bWVyLkdlc3R1cmVzXG4gICAgICovXG4gICAgcmVzZXRNb3VzZUNhbmNlbGxlcjogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoUE9JTlRFUlNUQVRFLm1vdXNlLm1vdXNlSWdub3JlSm9iKSB7XG4gICAgICAgIFBPSU5URVJTVEFURS5tb3VzZS5tb3VzZUlnbm9yZUpvYi5mbHVzaCgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKiBlc2xpbnQtZGlzYWJsZSB2YWxpZC1qc2RvYyAqL1xuXG4gIEdlc3R1cmVzLnJlZ2lzdGVyKHtcbiAgICBuYW1lOiAnZG93bnVwJyxcbiAgICBkZXBzOiBbJ21vdXNlZG93bicsICd0b3VjaHN0YXJ0JywgJ3RvdWNoZW5kJ10sXG4gICAgZmxvdzoge1xuICAgICAgc3RhcnQ6IFsnbW91c2Vkb3duJywgJ3RvdWNoc3RhcnQnXSxcbiAgICAgIGVuZDogWydtb3VzZXVwJywgJ3RvdWNoZW5kJ11cbiAgICB9LFxuICAgIGVtaXRzOiBbJ2Rvd24nLCAndXAnXSxcblxuICAgIGluZm86IHtcbiAgICAgIG1vdmVmbjogbnVsbCxcbiAgICAgIHVwZm46IG51bGxcbiAgICB9LFxuXG4gICAgLyoqIEB0aGlzIHtHZXN0dXJlUmVjb2duaXplcn0gKi9cbiAgICByZXNldDogZnVuY3Rpb24oKSB7XG4gICAgICB1bnRyYWNrRG9jdW1lbnQodGhpcy5pbmZvKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHRoaXMge0dlc3R1cmVSZWNvZ25pemVyfVxuICAgICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZVxuICAgICAqL1xuICAgIG1vdXNlZG93bjogZnVuY3Rpb24oZSkge1xuICAgICAgaWYgKCFoYXNMZWZ0TW91c2VCdXR0b24oZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGV0IHQgPSBHZXN0dXJlcy5fZmluZE9yaWdpbmFsVGFyZ2V0KGUpO1xuICAgICAgbGV0IHNlbGYgPSB0aGlzO1xuICAgICAgbGV0IG1vdmVmbiA9IGZ1bmN0aW9uIG1vdmVmbihlKSB7XG4gICAgICAgIGlmICghaGFzTGVmdE1vdXNlQnV0dG9uKGUpKSB7XG4gICAgICAgICAgc2VsZi5fZmlyZSgndXAnLCB0LCBlKTtcbiAgICAgICAgICB1bnRyYWNrRG9jdW1lbnQoc2VsZi5pbmZvKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGxldCB1cGZuID0gZnVuY3Rpb24gdXBmbihlKSB7XG4gICAgICAgIGlmIChoYXNMZWZ0TW91c2VCdXR0b24oZSkpIHtcbiAgICAgICAgICBzZWxmLl9maXJlKCd1cCcsIHQsIGUpO1xuICAgICAgICB9XG4gICAgICAgIHVudHJhY2tEb2N1bWVudChzZWxmLmluZm8pO1xuICAgICAgfTtcbiAgICAgIHRyYWNrRG9jdW1lbnQodGhpcy5pbmZvLCBtb3ZlZm4sIHVwZm4pO1xuICAgICAgdGhpcy5fZmlyZSgnZG93bicsIHQsIGUpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQHRoaXMge0dlc3R1cmVSZWNvZ25pemVyfVxuICAgICAqIEBwYXJhbSB7VG91Y2hFdmVudH0gZVxuICAgICAqL1xuICAgIHRvdWNoc3RhcnQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgIHRoaXMuX2ZpcmUoJ2Rvd24nLCBHZXN0dXJlcy5fZmluZE9yaWdpbmFsVGFyZ2V0KGUpLCBlLmNoYW5nZWRUb3VjaGVzWzBdLCBlKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEB0aGlzIHtHZXN0dXJlUmVjb2duaXplcn1cbiAgICAgKiBAcGFyYW0ge1RvdWNoRXZlbnR9IGVcbiAgICAgKi9cbiAgICB0b3VjaGVuZDogZnVuY3Rpb24oZSkge1xuICAgICAgdGhpcy5fZmlyZSgndXAnLCBHZXN0dXJlcy5fZmluZE9yaWdpbmFsVGFyZ2V0KGUpLCBlLmNoYW5nZWRUb3VjaGVzWzBdLCBlKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAgICogQHBhcmFtIHtFdmVudFRhcmdldH0gdGFyZ2V0XG4gICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmV2ZW50ZXJcbiAgICAgKi9cbiAgICBfZmlyZTogZnVuY3Rpb24odHlwZSwgdGFyZ2V0LCBldmVudCwgcHJldmVudGVyKSB7XG4gICAgICBHZXN0dXJlcy5fZmlyZSh0YXJnZXQsIHR5cGUsIHtcbiAgICAgICAgeDogZXZlbnQuY2xpZW50WCxcbiAgICAgICAgeTogZXZlbnQuY2xpZW50WSxcbiAgICAgICAgc291cmNlRXZlbnQ6IGV2ZW50LFxuICAgICAgICBwcmV2ZW50ZXI6IHByZXZlbnRlcixcbiAgICAgICAgcHJldmVudDogZnVuY3Rpb24oZSkge1xuICAgICAgICAgIHJldHVybiBHZXN0dXJlcy5wcmV2ZW50KGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuXG4gIEdlc3R1cmVzLnJlZ2lzdGVyKHtcbiAgICBuYW1lOiAndHJhY2snLFxuICAgIHRvdWNoQWN0aW9uOiAnbm9uZScsXG4gICAgZGVwczogWydtb3VzZWRvd24nLCAndG91Y2hzdGFydCcsICd0b3VjaG1vdmUnLCAndG91Y2hlbmQnXSxcbiAgICBmbG93OiB7XG4gICAgICBzdGFydDogWydtb3VzZWRvd24nLCAndG91Y2hzdGFydCddLFxuICAgICAgZW5kOiBbJ21vdXNldXAnLCAndG91Y2hlbmQnXVxuICAgIH0sXG4gICAgZW1pdHM6IFsndHJhY2snXSxcblxuICAgIGluZm86IHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwLFxuICAgICAgc3RhdGU6ICdzdGFydCcsXG4gICAgICBzdGFydGVkOiBmYWxzZSxcbiAgICAgIG1vdmVzOiBbXSxcbiAgICAgIC8qKiBAdGhpcyB7R2VzdHVyZVJlY29nbml6ZXJ9ICovXG4gICAgICBhZGRNb3ZlOiBmdW5jdGlvbihtb3ZlKSB7XG4gICAgICAgIGlmICh0aGlzLm1vdmVzLmxlbmd0aCA+IFRSQUNLX0xFTkdUSCkge1xuICAgICAgICAgIHRoaXMubW92ZXMuc2hpZnQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1vdmVzLnB1c2gobW92ZSk7XG4gICAgICB9LFxuICAgICAgbW92ZWZuOiBudWxsLFxuICAgICAgdXBmbjogbnVsbCxcbiAgICAgIHByZXZlbnQ6IGZhbHNlXG4gICAgfSxcblxuICAgIC8qKiBAdGhpcyB7R2VzdHVyZVJlY29nbml6ZXJ9ICovXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5pbmZvLnN0YXRlID0gJ3N0YXJ0JztcbiAgICAgIHRoaXMuaW5mby5zdGFydGVkID0gZmFsc2U7XG4gICAgICB0aGlzLmluZm8ubW92ZXMgPSBbXTtcbiAgICAgIHRoaXMuaW5mby54ID0gMDtcbiAgICAgIHRoaXMuaW5mby55ID0gMDtcbiAgICAgIHRoaXMuaW5mby5wcmV2ZW50ID0gZmFsc2U7XG4gICAgICB1bnRyYWNrRG9jdW1lbnQodGhpcy5pbmZvKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHRoaXMge0dlc3R1cmVSZWNvZ25pemVyfVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuICAgIGhhc01vdmVkRW5vdWdoOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICBpZiAodGhpcy5pbmZvLnByZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuaW5mby5zdGFydGVkKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgbGV0IGR4ID0gTWF0aC5hYnModGhpcy5pbmZvLnggLSB4KTtcbiAgICAgIGxldCBkeSA9IE1hdGguYWJzKHRoaXMuaW5mby55IC0geSk7XG4gICAgICByZXR1cm4gKGR4ID49IFRSQUNLX0RJU1RBTkNFIHx8IGR5ID49IFRSQUNLX0RJU1RBTkNFKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEB0aGlzIHtHZXN0dXJlUmVjb2duaXplcn1cbiAgICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGVcbiAgICAgKi9cbiAgICBtb3VzZWRvd246IGZ1bmN0aW9uKGUpIHtcbiAgICAgIGlmICghaGFzTGVmdE1vdXNlQnV0dG9uKGUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxldCB0ID0gR2VzdHVyZXMuX2ZpbmRPcmlnaW5hbFRhcmdldChlKTtcbiAgICAgIGxldCBzZWxmID0gdGhpcztcbiAgICAgIGxldCBtb3ZlZm4gPSBmdW5jdGlvbiBtb3ZlZm4oZSkge1xuICAgICAgICBsZXQgeCA9IGUuY2xpZW50WCwgeSA9IGUuY2xpZW50WTtcbiAgICAgICAgaWYgKHNlbGYuaGFzTW92ZWRFbm91Z2goeCwgeSkpIHtcbiAgICAgICAgICAvLyBmaXJzdCBtb3ZlIGlzICdzdGFydCcsIHN1YnNlcXVlbnQgbW92ZXMgYXJlICdtb3ZlJywgbW91c2V1cCBpcyAnZW5kJ1xuICAgICAgICAgIHNlbGYuaW5mby5zdGF0ZSA9IHNlbGYuaW5mby5zdGFydGVkID8gKGUudHlwZSA9PT0gJ21vdXNldXAnID8gJ2VuZCcgOiAndHJhY2snKSA6ICdzdGFydCc7XG4gICAgICAgICAgaWYgKHNlbGYuaW5mby5zdGF0ZSA9PT0gJ3N0YXJ0Jykge1xuICAgICAgICAgICAgLy8gaWYgYW5kIG9ubHkgaWYgdHJhY2tpbmcsIGFsd2F5cyBwcmV2ZW50IHRhcFxuICAgICAgICAgICAgR2VzdHVyZXMucHJldmVudCgndGFwJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNlbGYuaW5mby5hZGRNb3ZlKHt4OiB4LCB5OiB5fSk7XG4gICAgICAgICAgaWYgKCFoYXNMZWZ0TW91c2VCdXR0b24oZSkpIHtcbiAgICAgICAgICAgIC8vIGFsd2F5cyBfZmlyZSBcImVuZFwiXG4gICAgICAgICAgICBzZWxmLmluZm8uc3RhdGUgPSAnZW5kJztcbiAgICAgICAgICAgIHVudHJhY2tEb2N1bWVudChzZWxmLmluZm8pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzZWxmLl9maXJlKHQsIGUpO1xuICAgICAgICAgIHNlbGYuaW5mby5zdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGxldCB1cGZuID0gZnVuY3Rpb24gdXBmbihlKSB7XG4gICAgICAgIGlmIChzZWxmLmluZm8uc3RhcnRlZCkge1xuICAgICAgICAgIG1vdmVmbihlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlbW92ZSB0aGUgdGVtcG9yYXJ5IGxpc3RlbmVyc1xuICAgICAgICB1bnRyYWNrRG9jdW1lbnQoc2VsZi5pbmZvKTtcbiAgICAgIH07XG4gICAgICAvLyBhZGQgdGVtcG9yYXJ5IGRvY3VtZW50IGxpc3RlbmVycyBhcyBtb3VzZSByZXRhcmdldHNcbiAgICAgIHRyYWNrRG9jdW1lbnQodGhpcy5pbmZvLCBtb3ZlZm4sIHVwZm4pO1xuICAgICAgdGhpcy5pbmZvLnggPSBlLmNsaWVudFg7XG4gICAgICB0aGlzLmluZm8ueSA9IGUuY2xpZW50WTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEB0aGlzIHtHZXN0dXJlUmVjb2duaXplcn1cbiAgICAgKiBAcGFyYW0ge1RvdWNoRXZlbnR9IGVcbiAgICAgKi9cbiAgICB0b3VjaHN0YXJ0OiBmdW5jdGlvbihlKSB7XG4gICAgICBsZXQgY3QgPSBlLmNoYW5nZWRUb3VjaGVzWzBdO1xuICAgICAgdGhpcy5pbmZvLnggPSBjdC5jbGllbnRYO1xuICAgICAgdGhpcy5pbmZvLnkgPSBjdC5jbGllbnRZO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQHRoaXMge0dlc3R1cmVSZWNvZ25pemVyfVxuICAgICAqIEBwYXJhbSB7VG91Y2hFdmVudH0gZVxuICAgICAqL1xuICAgIHRvdWNobW92ZTogZnVuY3Rpb24oZSkge1xuICAgICAgbGV0IHQgPSBHZXN0dXJlcy5fZmluZE9yaWdpbmFsVGFyZ2V0KGUpO1xuICAgICAgbGV0IGN0ID0gZS5jaGFuZ2VkVG91Y2hlc1swXTtcbiAgICAgIGxldCB4ID0gY3QuY2xpZW50WCwgeSA9IGN0LmNsaWVudFk7XG4gICAgICBpZiAodGhpcy5oYXNNb3ZlZEVub3VnaCh4LCB5KSkge1xuICAgICAgICBpZiAodGhpcy5pbmZvLnN0YXRlID09PSAnc3RhcnQnKSB7XG4gICAgICAgICAgLy8gaWYgYW5kIG9ubHkgaWYgdHJhY2tpbmcsIGFsd2F5cyBwcmV2ZW50IHRhcFxuICAgICAgICAgIEdlc3R1cmVzLnByZXZlbnQoJ3RhcCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5mby5hZGRNb3ZlKHt4OiB4LCB5OiB5fSk7XG4gICAgICAgIHRoaXMuX2ZpcmUodCwgY3QpO1xuICAgICAgICB0aGlzLmluZm8uc3RhdGUgPSAndHJhY2snO1xuICAgICAgICB0aGlzLmluZm8uc3RhcnRlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBAdGhpcyB7R2VzdHVyZVJlY29nbml6ZXJ9XG4gICAgICogQHBhcmFtIHtUb3VjaEV2ZW50fSBlXG4gICAgICovXG4gICAgdG91Y2hlbmQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgIGxldCB0ID0gR2VzdHVyZXMuX2ZpbmRPcmlnaW5hbFRhcmdldChlKTtcbiAgICAgIGxldCBjdCA9IGUuY2hhbmdlZFRvdWNoZXNbMF07XG4gICAgICAvLyBvbmx5IHRyYWNrZW5kIGlmIHRyYWNrIHdhcyBzdGFydGVkIGFuZCBub3QgYWJvcnRlZFxuICAgICAgaWYgKHRoaXMuaW5mby5zdGFydGVkKSB7XG4gICAgICAgIC8vIHJlc2V0IHN0YXJ0ZWQgc3RhdGUgb24gdXBcbiAgICAgICAgdGhpcy5pbmZvLnN0YXRlID0gJ2VuZCc7XG4gICAgICAgIHRoaXMuaW5mby5hZGRNb3ZlKHt4OiBjdC5jbGllbnRYLCB5OiBjdC5jbGllbnRZfSk7XG4gICAgICAgIHRoaXMuX2ZpcmUodCwgY3QsIGUpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAdGhpcyB7R2VzdHVyZVJlY29nbml6ZXJ9XG4gICAgICogQHBhcmFtIHtFdmVudFRhcmdldH0gdGFyZ2V0XG4gICAgICogQHBhcmFtIHtUb3VjaH0gdG91Y2hcbiAgICAgKi9cbiAgICBfZmlyZTogZnVuY3Rpb24odGFyZ2V0LCB0b3VjaCkge1xuICAgICAgbGV0IHNlY29uZGxhc3QgPSB0aGlzLmluZm8ubW92ZXNbdGhpcy5pbmZvLm1vdmVzLmxlbmd0aCAtIDJdO1xuICAgICAgbGV0IGxhc3Rtb3ZlID0gdGhpcy5pbmZvLm1vdmVzW3RoaXMuaW5mby5tb3Zlcy5sZW5ndGggLSAxXTtcbiAgICAgIGxldCBkeCA9IGxhc3Rtb3ZlLnggLSB0aGlzLmluZm8ueDtcbiAgICAgIGxldCBkeSA9IGxhc3Rtb3ZlLnkgLSB0aGlzLmluZm8ueTtcbiAgICAgIGxldCBkZHgsIGRkeSA9IDA7XG4gICAgICBpZiAoc2Vjb25kbGFzdCkge1xuICAgICAgICBkZHggPSBsYXN0bW92ZS54IC0gc2Vjb25kbGFzdC54O1xuICAgICAgICBkZHkgPSBsYXN0bW92ZS55IC0gc2Vjb25kbGFzdC55O1xuICAgICAgfVxuICAgICAgR2VzdHVyZXMuX2ZpcmUodGFyZ2V0LCAndHJhY2snLCB7XG4gICAgICAgIHN0YXRlOiB0aGlzLmluZm8uc3RhdGUsXG4gICAgICAgIHg6IHRvdWNoLmNsaWVudFgsXG4gICAgICAgIHk6IHRvdWNoLmNsaWVudFksXG4gICAgICAgIGR4OiBkeCxcbiAgICAgICAgZHk6IGR5LFxuICAgICAgICBkZHg6IGRkeCxcbiAgICAgICAgZGR5OiBkZHksXG4gICAgICAgIHNvdXJjZUV2ZW50OiB0b3VjaCxcbiAgICAgICAgaG92ZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBHZXN0dXJlcy5kZWVwVGFyZ2V0RmluZCh0b3VjaC5jbGllbnRYLCB0b3VjaC5jbGllbnRZKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gIH0pO1xuXG4gIEdlc3R1cmVzLnJlZ2lzdGVyKHtcbiAgICBuYW1lOiAndGFwJyxcbiAgICBkZXBzOiBbJ21vdXNlZG93bicsICdjbGljaycsICd0b3VjaHN0YXJ0JywgJ3RvdWNoZW5kJ10sXG4gICAgZmxvdzoge1xuICAgICAgc3RhcnQ6IFsnbW91c2Vkb3duJywgJ3RvdWNoc3RhcnQnXSxcbiAgICAgIGVuZDogWydjbGljaycsICd0b3VjaGVuZCddXG4gICAgfSxcbiAgICBlbWl0czogWyd0YXAnXSxcbiAgICBpbmZvOiB7XG4gICAgICB4OiBOYU4sXG4gICAgICB5OiBOYU4sXG4gICAgICBwcmV2ZW50OiBmYWxzZVxuICAgIH0sXG4gICAgLyoqIEB0aGlzIHtHZXN0dXJlUmVjb2duaXplcn0gKi9cbiAgICByZXNldDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmluZm8ueCA9IE5hTjtcbiAgICAgIHRoaXMuaW5mby55ID0gTmFOO1xuICAgICAgdGhpcy5pbmZvLnByZXZlbnQgPSBmYWxzZTtcbiAgICB9LFxuICAgIC8qKiBAdGhpcyB7R2VzdHVyZVJlY29nbml6ZXJ9ICovXG4gICAgc2F2ZTogZnVuY3Rpb24oZSkge1xuICAgICAgdGhpcy5pbmZvLnggPSBlLmNsaWVudFg7XG4gICAgICB0aGlzLmluZm8ueSA9IGUuY2xpZW50WTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEB0aGlzIHtHZXN0dXJlUmVjb2duaXplcn1cbiAgICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGVcbiAgICAgKi9cbiAgICBtb3VzZWRvd246IGZ1bmN0aW9uKGUpIHtcbiAgICAgIGlmIChoYXNMZWZ0TW91c2VCdXR0b24oZSkpIHtcbiAgICAgICAgdGhpcy5zYXZlKGUpO1xuICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogQHRoaXMge0dlc3R1cmVSZWNvZ25pemVyfVxuICAgICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZVxuICAgICAqL1xuICAgIGNsaWNrOiBmdW5jdGlvbihlKSB7XG4gICAgICBpZiAoaGFzTGVmdE1vdXNlQnV0dG9uKGUpKSB7XG4gICAgICAgIHRoaXMuZm9yd2FyZChlKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEB0aGlzIHtHZXN0dXJlUmVjb2duaXplcn1cbiAgICAgKiBAcGFyYW0ge1RvdWNoRXZlbnR9IGVcbiAgICAgKi9cbiAgICB0b3VjaHN0YXJ0OiBmdW5jdGlvbihlKSB7XG4gICAgICB0aGlzLnNhdmUoZS5jaGFuZ2VkVG91Y2hlc1swXSwgZSk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBAdGhpcyB7R2VzdHVyZVJlY29nbml6ZXJ9XG4gICAgICogQHBhcmFtIHtUb3VjaEV2ZW50fSBlXG4gICAgICovXG4gICAgdG91Y2hlbmQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgIHRoaXMuZm9yd2FyZChlLmNoYW5nZWRUb3VjaGVzWzBdLCBlKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEB0aGlzIHtHZXN0dXJlUmVjb2duaXplcn1cbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJldmVudGVyXG4gICAgICovXG4gICAgZm9yd2FyZDogZnVuY3Rpb24oZSwgcHJldmVudGVyKSB7XG4gICAgICBsZXQgZHggPSBNYXRoLmFicyhlLmNsaWVudFggLSB0aGlzLmluZm8ueCk7XG4gICAgICBsZXQgZHkgPSBNYXRoLmFicyhlLmNsaWVudFkgLSB0aGlzLmluZm8ueSk7XG4gICAgICBsZXQgdCA9IEdlc3R1cmVzLl9maW5kT3JpZ2luYWxUYXJnZXQoZSk7XG4gICAgICAvLyBkeCxkeSBjYW4gYmUgTmFOIGlmIGBjbGlja2AgaGFzIGJlZW4gc2ltdWxhdGVkIGFuZCB0aGVyZSB3YXMgbm8gYGRvd25gIGZvciBgc3RhcnRgXG4gICAgICBpZiAoaXNOYU4oZHgpIHx8IGlzTmFOKGR5KSB8fCAoZHggPD0gVEFQX0RJU1RBTkNFICYmIGR5IDw9IFRBUF9ESVNUQU5DRSkgfHwgaXNTeW50aGV0aWNDbGljayhlKSkge1xuICAgICAgICAvLyBwcmV2ZW50IHRhcHMgZnJvbSBiZWluZyBnZW5lcmF0ZWQgaWYgYW4gZXZlbnQgaGFzIGNhbmNlbGVkIHRoZW1cbiAgICAgICAgaWYgKCF0aGlzLmluZm8ucHJldmVudCkge1xuICAgICAgICAgIEdlc3R1cmVzLl9maXJlKHQsICd0YXAnLCB7XG4gICAgICAgICAgICB4OiBlLmNsaWVudFgsXG4gICAgICAgICAgICB5OiBlLmNsaWVudFksXG4gICAgICAgICAgICBzb3VyY2VFdmVudDogZSxcbiAgICAgICAgICAgIHByZXZlbnRlcjogcHJldmVudGVyXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIC8qIGVzbGludC1lbmFibGUgdmFsaWQtanNkb2MgKi9cblxuICAvKiogQGRlcHJlY2F0ZWQgKi9cbiAgR2VzdHVyZXMuZmluZE9yaWdpbmFsVGFyZ2V0ID0gR2VzdHVyZXMuX2ZpbmRPcmlnaW5hbFRhcmdldDtcblxuICAvKiogQGRlcHJlY2F0ZWQgKi9cbiAgR2VzdHVyZXMuYWRkID0gR2VzdHVyZXMuYWRkTGlzdGVuZXI7XG5cbiAgLyoqIEBkZXByZWNhdGVkICovXG4gIEdlc3R1cmVzLnJlbW92ZSA9IEdlc3R1cmVzLnJlbW92ZUxpc3RlbmVyO1xuXG4gIFBvbHltZXIuR2VzdHVyZXMgPSBHZXN0dXJlcztcblxufSkoKTtcbjwvc2NyaXB0PlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi91dGlscy9nZXN0dXJlcy5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuXG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiYm9vdC5odG1sXCI+XG5cbjxzY3JpcHQ+XG5cbihmdW5jdGlvbigpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgLy8gcnVuIGEgY2FsbGJhY2sgd2hlbiBIVE1MSW1wb3J0cyBhcmUgcmVhZHkgb3IgaW1tZWRpYXRlbHkgaWZcbiAgLy8gdGhpcyBhcGkgaXMgbm90IGF2YWlsYWJsZS5cbiAgZnVuY3Rpb24gd2hlbkltcG9ydHNSZWFkeShjYikge1xuICAgIGlmICh3aW5kb3cuSFRNTEltcG9ydHMpIHtcbiAgICAgIEhUTUxJbXBvcnRzLndoZW5SZWFkeShjYik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNiKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlbmllbmNlIG1ldGhvZCBmb3IgaW1wb3J0aW5nIGFuIEhUTUwgZG9jdW1lbnQgaW1wZXJhdGl2ZWx5LlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBjcmVhdGVzIGEgbmV3IGA8bGluayByZWw9XCJpbXBvcnRcIj5gIGVsZW1lbnQgd2l0aFxuICAgKiB0aGUgcHJvdmlkZWQgVVJMIGFuZCBhcHBlbmRzIGl0IHRvIHRoZSBkb2N1bWVudCB0byBzdGFydCBsb2FkaW5nLlxuICAgKiBJbiB0aGUgYG9ubG9hZGAgY2FsbGJhY2ssIHRoZSBgaW1wb3J0YCBwcm9wZXJ0eSBvZiB0aGUgYGxpbmtgXG4gICAqIGVsZW1lbnQgd2lsbCBjb250YWluIHRoZSBpbXBvcnRlZCBkb2N1bWVudCBjb250ZW50cy5cbiAgICpcbiAgICogQG1lbWJlcm9mIFBvbHltZXJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGhyZWYgVVJMIHRvIGRvY3VtZW50IHRvIGxvYWQuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBvbmxvYWQgQ2FsbGJhY2sgdG8gbm90aWZ5IHdoZW4gYW4gaW1wb3J0IHN1Y2Nlc3NmdWxseVxuICAgKiAgIGxvYWRlZC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IG9uZXJyb3IgQ2FsbGJhY2sgdG8gbm90aWZ5IHdoZW4gYW4gaW1wb3J0XG4gICAqICAgdW5zdWNjZXNzZnVsbHkgbG9hZGVkLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBvcHRBc3luYyBUcnVlIGlmIHRoZSBpbXBvcnQgc2hvdWxkIGJlIGxvYWRlZCBgYXN5bmNgLlxuICAgKiAgIERlZmF1bHRzIHRvIGBmYWxzZWAuXG4gICAqIEByZXR1cm4ge0hUTUxMaW5rRWxlbWVudH0gVGhlIGxpbmsgZWxlbWVudCBmb3IgdGhlIFVSTCB0byBiZSBsb2FkZWQuXG4gICAqL1xuICBQb2x5bWVyLmltcG9ydEhyZWYgPSBmdW5jdGlvbihocmVmLCBvbmxvYWQsIG9uZXJyb3IsIG9wdEFzeW5jKSB7XG4gICAgbGV0IGxpbmsgPSAvKiogQHR5cGUge0hUTUxMaW5rRWxlbWVudH0gKi9cbiAgICAgIChkb2N1bWVudC5oZWFkLnF1ZXJ5U2VsZWN0b3IoJ2xpbmtbaHJlZj1cIicgKyBocmVmICsgJ1wiXVtpbXBvcnQtaHJlZl0nKSk7XG4gICAgaWYgKCFsaW5rKSB7XG4gICAgICBsaW5rID0gLyoqIEB0eXBlIHtIVE1MTGlua0VsZW1lbnR9ICovIChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaW5rJykpO1xuICAgICAgbGluay5yZWwgPSAnaW1wb3J0JztcbiAgICAgIGxpbmsuaHJlZiA9IGhyZWY7XG4gICAgICBsaW5rLnNldEF0dHJpYnV0ZSgnaW1wb3J0LWhyZWYnLCAnJyk7XG4gICAgfVxuICAgIC8vIGFsd2F5cyBlbnN1cmUgbGluayBoYXMgYGFzeW5jYCBhdHRyaWJ1dGUgaWYgdXNlciBzcGVjaWZpZWQgb25lLFxuICAgIC8vIGV2ZW4gaWYgaXQgd2FzIHByZXZpb3VzbHkgbm90IGFzeW5jLiBUaGlzIGlzIGNvbnNpZGVyZWQgbGVzcyBjb25mdXNpbmcuXG4gICAgaWYgKG9wdEFzeW5jKSB7XG4gICAgICBsaW5rLnNldEF0dHJpYnV0ZSgnYXN5bmMnLCAnJyk7XG4gICAgfVxuICAgIC8vIE5PVEU6IHRoZSBsaW5rIG1heSBub3cgYmUgaW4gMyBzdGF0ZXM6ICgxKSBwZW5kaW5nIGluc2VydGlvbixcbiAgICAvLyAoMikgaW5mbGlnaHQsICgzKSBhbHJlYWR5IGxhb2RlZC4gSW4gZWFjaCBjYXNlLCB3ZSBuZWVkIHRvIGFkZFxuICAgIC8vIGV2ZW50IGxpc3RlbmVycyB0byBwcm9jZXNzIGNhbGxiYWNrcy5cbiAgICBsZXQgY2xlYW51cCA9IGZ1bmN0aW9uKCkge1xuICAgICAgbGluay5yZW1vdmVFdmVudExpc3RlbmVyKCdsb2FkJywgbG9hZExpc3RlbmVyKTtcbiAgICAgIGxpbmsucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCBlcnJvckxpc3RlbmVyKTtcbiAgICB9XG4gICAgbGV0IGxvYWRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICBjbGVhbnVwKCk7XG4gICAgICAvLyBJbiBjYXNlIG9mIGEgc3VjY2Vzc2Z1bCBsb2FkLCBjYWNoZSB0aGUgbG9hZCBldmVudCBvbiB0aGUgbGluayBzb1xuICAgICAgLy8gdGhhdCBpdCBjYW4gYmUgdXNlZCB0byBzaG9ydC1jaXJjdWl0IHRoaXMgbWV0aG9kIGluIHRoZSBmdXR1cmUgd2hlblxuICAgICAgLy8gaXQgaXMgY2FsbGVkIHdpdGggdGhlIHNhbWUgaHJlZiBwYXJhbS5cbiAgICAgIGxpbmsuX19keW5hbWljSW1wb3J0TG9hZGVkID0gdHJ1ZTtcbiAgICAgIGlmIChvbmxvYWQpIHtcbiAgICAgICAgd2hlbkltcG9ydHNSZWFkeSgoKSA9PiB7XG4gICAgICAgICAgb25sb2FkKGV2ZW50KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBsZXQgZXJyb3JMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICBjbGVhbnVwKCk7XG4gICAgICAvLyBJbiBjYXNlIG9mIGFuIGVycm9yLCByZW1vdmUgdGhlIGxpbmsgZnJvbSB0aGUgZG9jdW1lbnQgc28gdGhhdCBpdFxuICAgICAgLy8gd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGNyZWF0ZWQgYWdhaW4gdGhlIG5leHQgdGltZSBgaW1wb3J0SHJlZmAgaXNcbiAgICAgIC8vIGNhbGxlZC5cbiAgICAgIGlmIChsaW5rLnBhcmVudE5vZGUpIHtcbiAgICAgICAgbGluay5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGxpbmspO1xuICAgICAgfVxuICAgICAgaWYgKG9uZXJyb3IpIHtcbiAgICAgICAgd2hlbkltcG9ydHNSZWFkeSgoKSA9PiB7XG4gICAgICAgICAgb25lcnJvcihldmVudCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gICAgbGluay5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgbG9hZExpc3RlbmVyKTtcbiAgICBsaW5rLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgZXJyb3JMaXN0ZW5lcik7XG4gICAgaWYgKGxpbmsucGFyZW50Tm9kZSA9PSBudWxsKSB7XG4gICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKGxpbmspO1xuICAgIC8vIGlmIHRoZSBsaW5rIGFscmVhZHkgbG9hZGVkLCBkaXNwYXRjaCBhIGZha2UgbG9hZCBldmVudFxuICAgIC8vIHNvIHRoYXQgbGlzdGVuZXJzIGFyZSBjYWxsZWQgYW5kIGdldCBhIHByb3BlciBldmVudCBhcmd1bWVudC5cbiAgICB9IGVsc2UgaWYgKGxpbmsuX19keW5hbWljSW1wb3J0TG9hZGVkKSB7XG4gICAgICBsaW5rLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdsb2FkJykpO1xuICAgIH1cbiAgICByZXR1cm4gbGluaztcbiAgfTtcblxufSkoKTtcbjwvc2NyaXB0PlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi91dGlscy9pbXBvcnQtaHJlZi5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cImJvb3QuaHRtbFwiPlxuXG48c2NyaXB0PlxuKGZ1bmN0aW9uKCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICBsZXQgc2NoZWR1bGVkID0gZmFsc2U7XG4gIGxldCBiZWZvcmVSZW5kZXJRdWV1ZSA9IFtdO1xuICBsZXQgYWZ0ZXJSZW5kZXJRdWV1ZSA9IFtdO1xuXG4gIGZ1bmN0aW9uIHNjaGVkdWxlKCkge1xuICAgIHNjaGVkdWxlZCA9IHRydWU7XG4gICAgLy8gYmVmb3JlIG5leHQgcmVuZGVyXG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCkge1xuICAgICAgc2NoZWR1bGVkID0gZmFsc2U7XG4gICAgICBmbHVzaFF1ZXVlKGJlZm9yZVJlbmRlclF1ZXVlKTtcbiAgICAgIC8vIGFmdGVyIHRoZSByZW5kZXJcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJ1blF1ZXVlKGFmdGVyUmVuZGVyUXVldWUpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBmbHVzaFF1ZXVlKHF1ZXVlKSB7XG4gICAgd2hpbGUgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgY2FsbE1ldGhvZChxdWV1ZS5zaGlmdCgpKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBydW5RdWV1ZShxdWV1ZSkge1xuICAgIGZvciAobGV0IGk9MCwgbD1xdWV1ZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGNhbGxNZXRob2QocXVldWUuc2hpZnQoKSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2FsbE1ldGhvZChpbmZvKSB7XG4gICAgY29uc3QgY29udGV4dCA9IGluZm9bMF07XG4gICAgY29uc3QgY2FsbGJhY2sgPSBpbmZvWzFdO1xuICAgIGNvbnN0IGFyZ3MgPSBpbmZvWzJdO1xuICAgIHRyeSB7XG4gICAgICBjYWxsYmFjay5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICB9IGNhdGNoKGUpIHtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBmbHVzaCgpIHtcbiAgICB3aGlsZSAoYmVmb3JlUmVuZGVyUXVldWUubGVuZ3RoIHx8IGFmdGVyUmVuZGVyUXVldWUubGVuZ3RoKSB7XG4gICAgICBmbHVzaFF1ZXVlKGJlZm9yZVJlbmRlclF1ZXVlKTtcbiAgICAgIGZsdXNoUXVldWUoYWZ0ZXJSZW5kZXJRdWV1ZSk7XG4gICAgfVxuICAgIHNjaGVkdWxlZCA9IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIE1vZHVsZSBmb3Igc2NoZWR1bGluZyBmbHVzaGFibGUgcHJlLXJlbmRlciBhbmQgcG9zdC1yZW5kZXIgdGFza3MuXG4gICAqXG4gICAqIEBuYW1lc3BhY2VcbiAgICogQG1lbWJlcm9mIFBvbHltZXJcbiAgICogQHN1bW1hcnkgTW9kdWxlIGZvciBzY2hlZHVsaW5nIGZsdXNoYWJsZSBwcmUtcmVuZGVyIGFuZCBwb3N0LXJlbmRlciB0YXNrcy5cbiAgICovXG4gIFBvbHltZXIuUmVuZGVyU3RhdHVzID0ge1xuXG4gICAgLyoqXG4gICAgICogRW5xdWV1ZXMgYSBjYWxsYmFjayB3aGljaCB3aWxsIGJlIHJ1biBiZWZvcmUgdGhlIG5leHQgcmVuZGVyLCBhdFxuICAgICAqIGByZXF1ZXN0QW5pbWF0aW9uRnJhbWVgIHRpbWluZy5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIHVzZWZ1bCBmb3IgZW5xdWV1aW5nIHdvcmsgdGhhdCByZXF1aXJlcyBET00gbWVhc3VyZW1lbnQsXG4gICAgICogc2luY2UgbWVhc3VyZW1lbnQgbWF5IG5vdCBiZSByZWxpYWJsZSBpbiBjdXN0b20gZWxlbWVudCBjYWxsYmFja3MgYmVmb3JlXG4gICAgICogdGhlIGZpcnN0IHJlbmRlciwgYXMgd2VsbCBhcyBmb3IgYmF0Y2hpbmcgbWVhc3VyZW1lbnQgdGFza3MgaW4gZ2VuZXJhbC5cbiAgICAgKlxuICAgICAqIFRhc2tzIGluIHRoaXMgcXVldWUgbWF5IGJlIGZsdXNoZWQgYnkgY2FsbGluZyBgUG9seW1lci5SZW5kZXJTdGF0dXMuZmx1c2goKWAuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgUG9seW1lci5SZW5kZXJTdGF0dXNcbiAgICAgKiBAcGFyYW0geyp9IGNvbnRleHQgQ29udGV4dCBvYmplY3QgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHdpbGwgYmUgYm91bmQgdG9cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCl9IGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJncyBBbiBhcnJheSBvZiBhcmd1bWVudHMgdG8gY2FsbCB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gd2l0aFxuICAgICAqL1xuICAgIGJlZm9yZU5leHRSZW5kZXI6IGZ1bmN0aW9uKGNvbnRleHQsIGNhbGxiYWNrLCBhcmdzKSB7XG4gICAgICBpZiAoIXNjaGVkdWxlZCkge1xuICAgICAgICBzY2hlZHVsZSgpO1xuICAgICAgfVxuICAgICAgYmVmb3JlUmVuZGVyUXVldWUucHVzaChbY29udGV4dCwgY2FsbGJhY2ssIGFyZ3NdKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRW5xdWV1ZXMgYSBjYWxsYmFjayB3aGljaCB3aWxsIGJlIHJ1biBhZnRlciB0aGUgbmV4dCByZW5kZXIsIGVxdWl2YWxlbnRcbiAgICAgKiB0byBvbmUgdGFzayAoYHNldFRpbWVvdXRgKSBhZnRlciB0aGUgbmV4dCBgcmVxdWVzdEFuaW1hdGlvbkZyYW1lYC5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIHVzZWZ1bCBmb3IgdHVuaW5nIHRoZSBmaXJzdC1yZW5kZXIgcGVyZm9ybWFuY2Ugb2YgYW5cbiAgICAgKiBlbGVtZW50IG9yIGFwcGxpY2F0aW9uIGJ5IGRlZmVycmluZyBub24tY3JpdGljYWwgd29yayB1bnRpbCBhZnRlciB0aGVcbiAgICAgKiBmaXJzdCBwYWludC4gIFR5cGljYWwgbm9uLXJlbmRlci1jcml0aWNhbCB3b3JrIG1heSBpbmNsdWRlIGFkZGluZyBVSVxuICAgICAqIGV2ZW50IGxpc3RlbmVycyBhbmQgYXJpYSBhdHRyaWJ1dGVzLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIFBvbHltZXIuUmVuZGVyU3RhdHVzXG4gICAgICogQHBhcmFtIHsqfSBjb250ZXh0IENvbnRleHQgb2JqZWN0IHRoZSBjYWxsYmFjayBmdW5jdGlvbiB3aWxsIGJlIGJvdW5kIHRvXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbigpfSBjYWxsYmFjayBDYWxsYmFjayBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgQW4gYXJyYXkgb2YgYXJndW1lbnRzIHRvIGNhbGwgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHdpdGhcbiAgICAgKi9cbiAgICBhZnRlck5leHRSZW5kZXI6IGZ1bmN0aW9uKGNvbnRleHQsIGNhbGxiYWNrLCBhcmdzKSB7XG4gICAgICBpZiAoIXNjaGVkdWxlZCkge1xuICAgICAgICBzY2hlZHVsZSgpO1xuICAgICAgfVxuICAgICAgYWZ0ZXJSZW5kZXJRdWV1ZS5wdXNoKFtjb250ZXh0LCBjYWxsYmFjaywgYXJnc10pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGbHVzaGVzIGFsbCBgYmVmb3JlTmV4dFJlbmRlcmAgdGFza3MsIGZvbGxvd2VkIGJ5IGFsbCBgYWZ0ZXJOZXh0UmVuZGVyYFxuICAgICAqIHRhc2tzLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIFBvbHltZXIuUmVuZGVyU3RhdHVzXG4gICAgICovXG4gICAgZmx1c2g6IGZsdXNoXG5cbiAgfTtcblxufSkoKTtcbjwvc2NyaXB0PlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi91dGlscy9yZW5kZXItc3RhdHVzLmh0bWwiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG48c2NyaXB0PlxuKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLy8gdW5yZXNvbHZlZFxuXG4gIGZ1bmN0aW9uIHJlc29sdmUoKSB7XG4gICAgZG9jdW1lbnQuYm9keS5yZW1vdmVBdHRyaWJ1dGUoJ3VucmVzb2x2ZWQnKTtcbiAgfVxuXG4gIGlmICh3aW5kb3cuV2ViQ29tcG9uZW50cykge1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdXZWJDb21wb25lbnRzUmVhZHknLCByZXNvbHZlKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gJ2ludGVyYWN0aXZlJyB8fCBkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnY29tcGxldGUnKSB7XG4gICAgICByZXNvbHZlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgcmVzb2x2ZSk7XG4gICAgfVxuICB9XG5cbn0pKCk7XG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvdXRpbHMvdW5yZXNvbHZlZC5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3V0aWxzL2Jvb3QuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3V0aWxzL3NldHRpbmdzLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi91dGlscy9mbGF0dGVuZWQtbm9kZXMtb2JzZXJ2ZXIuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3V0aWxzL2ZsdXNoLmh0bWxcIj5cbjxzY3JpcHQ+XG4oZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBjb25zdCBwID0gRWxlbWVudC5wcm90b3R5cGU7XG4gIC8qKlxuICAgKiBAY29uc3Qge2Z1bmN0aW9uKHRoaXM6RWxlbWVudCwgc3RyaW5nKTogYm9vbGVhbn1cbiAgICovXG4gIGNvbnN0IG5vcm1hbGl6ZWRNYXRjaGVzU2VsZWN0b3IgPSBwLm1hdGNoZXMgfHwgcC5tYXRjaGVzU2VsZWN0b3IgfHxcbiAgICBwLm1vek1hdGNoZXNTZWxlY3RvciB8fCBwLm1zTWF0Y2hlc1NlbGVjdG9yIHx8XG4gICAgcC5vTWF0Y2hlc1NlbGVjdG9yIHx8IHAud2Via2l0TWF0Y2hlc1NlbGVjdG9yO1xuXG4gIC8qKlxuICAgKiBDcm9zcy1wbGF0Zm9ybSBgZWxlbWVudC5tYXRjaGVzYCBzaGltLlxuICAgKlxuICAgKiBAZnVuY3Rpb24gbWF0Y2hlc1NlbGVjdG9yXG4gICAqIEBtZW1iZXJvZiBQb2x5bWVyLmRvbVxuICAgKiBAcGFyYW0geyFFbGVtZW50fSBub2RlIE5vZGUgdG8gY2hlY2sgc2VsZWN0b3IgYWdhaW5zdFxuICAgKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3IgU2VsZWN0b3IgdG8gbWF0Y2hcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBub2RlIG1hdGNoZWQgc2VsZWN0b3JcbiAgICovXG4gIGNvbnN0IG1hdGNoZXNTZWxlY3RvciA9IGZ1bmN0aW9uKG5vZGUsIHNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIG5vcm1hbGl6ZWRNYXRjaGVzU2VsZWN0b3IuY2FsbChub2RlLCBzZWxlY3Rvcik7XG4gIH1cblxuICAvKipcbiAgICogTm9kZSBBUEkgd3JhcHBlciBjbGFzcyByZXR1cm5lZCBmcm9tIGBQb2x5bWVyLmRvbS4odGFyZ2V0KWAgd2hlblxuICAgKiBgdGFyZ2V0YCBpcyBhIGBOb2RlYC5cbiAgICovXG4gIGNsYXNzIERvbUFwaSB7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgTm9kZSBmb3Igd2hpY2ggdG8gY3JlYXRlIGEgUG9seW1lci5kb20gaGVscGVyIG9iamVjdC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihub2RlKSB7XG4gICAgICB0aGlzLm5vZGUgPSBub2RlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gaW5zdGFuY2Ugb2YgYFBvbHltZXIuRmxhdHRlbmVkTm9kZXNPYnNlcnZlcmAgdGhhdFxuICAgICAqIGxpc3RlbnMgZm9yIG5vZGUgY2hhbmdlcyBvbiB0aGlzIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgd2hlbiBkaXJlY3Qgb3IgZGlzdHJpYnV0ZWQgY2hpbGRyZW5cbiAgICAgKiAgIG9mIHRoaXMgZWxlbWVudCBjaGFuZ2VzXG4gICAgICogQHJldHVybiB7UG9seW1lci5GbGF0dGVuZWROb2Rlc09ic2VydmVyfSBPYnNlcnZlciBpbnN0YW5jZVxuICAgICAqL1xuICAgIG9ic2VydmVOb2RlcyhjYWxsYmFjaykge1xuICAgICAgcmV0dXJuIG5ldyBQb2x5bWVyLkZsYXR0ZW5lZE5vZGVzT2JzZXJ2ZXIodGhpcy5ub2RlLCBjYWxsYmFjayk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGlzY29ubmVjdHMgYW4gb2JzZXJ2ZXIgcHJldmlvdXNseSBjcmVhdGVkIHZpYSBgb2JzZXJ2ZU5vZGVzYFxuICAgICAqXG4gICAgICogQHBhcmFtIHtQb2x5bWVyLkZsYXR0ZW5lZE5vZGVzT2JzZXJ2ZXJ9IG9ic2VydmVySGFuZGxlIE9ic2VydmVyIGluc3RhbmNlXG4gICAgICogICB0byBkaXNjb25uZWN0LlxuICAgICAqL1xuICAgIHVub2JzZXJ2ZU5vZGVzKG9ic2VydmVySGFuZGxlKSB7XG4gICAgICBvYnNlcnZlckhhbmRsZS5kaXNjb25uZWN0KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHJvdmlkZWQgYXMgYSBiYWNrd2FyZHMtY29tcGF0aWJsZSBBUEkgb25seS4gIFRoaXMgbWV0aG9kIGRvZXMgbm90aGluZy5cbiAgICAgKi9cbiAgICBub3RpZnlPYnNlcnZlcigpIHt9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHByb3ZpZGVkIG5vZGUgaXMgY29udGFpbmVkIHdpdGggdGhpcyBlbGVtZW50J3NcbiAgICAgKiBsaWdodC1ET00gY2hpbGRyZW4gb3Igc2hhZG93IHJvb3QsIGluY2x1ZGluZyBhbnkgbmVzdGVkIHNoYWRvdyByb290c1xuICAgICAqIG9mIGNoaWxkcmVuIHRoZXJlaW4uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgTm9kZSB0byB0ZXN0XG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBgbm9kZWAgaXMgY29udGFpbmVkIHdpdGhpblxuICAgICAqICAgdGhpcyBlbGVtZW50J3MgbGlnaHQgb3Igc2hhZG93IERPTS5cbiAgICAgKi9cbiAgICBkZWVwQ29udGFpbnMobm9kZSkge1xuICAgICAgaWYgKHRoaXMubm9kZS5jb250YWlucyhub2RlKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGxldCBuID0gbm9kZTtcbiAgICAgIGxldCBkb2MgPSBub2RlLm93bmVyRG9jdW1lbnQ7XG4gICAgICAvLyB3YWxrIGZyb20gbm9kZSB0byBgdGhpc2Agb3IgYGRvY3VtZW50YFxuICAgICAgd2hpbGUgKG4gJiYgbiAhPT0gZG9jICYmIG4gIT09IHRoaXMubm9kZSkge1xuICAgICAgICAvLyB1c2UgbG9naWNhbCBwYXJlbnRub2RlLCBvciBuYXRpdmUgU2hhZG93Um9vdCBob3N0XG4gICAgICAgIG4gPSBuLnBhcmVudE5vZGUgfHwgbi5ob3N0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIG4gPT09IHRoaXMubm9kZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSByb290IG5vZGUgb2YgdGhpcyBub2RlLiAgRXF1aXZhbGVudCB0byBgZ2V0Um9vZE5vZGUoKWAuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtOb2RlfSBUb3AgbW9zdCBlbGVtZW50IGluIHRoZSBkb20gdHJlZSBpbiB3aGljaCB0aGUgbm9kZVxuICAgICAqIGV4aXN0cy4gSWYgdGhlIG5vZGUgaXMgY29ubmVjdGVkIHRvIGEgZG9jdW1lbnQgdGhpcyBpcyBlaXRoZXIgYVxuICAgICAqIHNoYWRvd1Jvb3Qgb3IgdGhlIGRvY3VtZW50OyBvdGhlcndpc2UsIGl0IG1heSBiZSB0aGUgbm9kZVxuICAgICAqIGl0c2VsZiBvciBhIG5vZGUgb3IgZG9jdW1lbnQgZnJhZ21lbnQgY29udGFpbmluZyBpdC5cbiAgICAgKi9cbiAgICBnZXRPd25lclJvb3QoKSB7XG4gICAgICByZXR1cm4gdGhpcy5ub2RlLmdldFJvb3ROb2RlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRm9yIHNsb3QgZWxlbWVudHMsIHJldHVybnMgdGhlIG5vZGVzIGFzc2lnbmVkIHRvIHRoZSBzbG90OyBvdGhlcndpc2VcbiAgICAgKiBhbiBlbXB0eSBhcnJheS4gSXQgaXMgZXF1aXZhbGVudCB0byBgPHNsb3Q+LmFkZGlnbmVkTm9kZXMoe2ZsYXR0ZW46dHJ1ZX0pYC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0FycmF5PE5vZGU+fSBBcnJheSBvZiBhc3NpZ25lZCBub2Rlc1xuICAgICAqL1xuICAgIGdldERpc3RyaWJ1dGVkTm9kZXMoKSB7XG4gICAgICByZXR1cm4gKHRoaXMubm9kZS5sb2NhbE5hbWUgPT09ICdzbG90JykgP1xuICAgICAgICB0aGlzLm5vZGUuYXNzaWduZWROb2Rlcyh7ZmxhdHRlbjogdHJ1ZX0pIDpcbiAgICAgICAgW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBhcnJheSBvZiBhbGwgc2xvdHMgdGhpcyBlbGVtZW50IHdhcyBkaXN0cmlidXRlZCB0by5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0FycmF5PEhUTUxTbG90RWxlbWVudD59IERlc2NyaXB0aW9uXG4gICAgICovXG4gICAgZ2V0RGVzdGluYXRpb25JbnNlcnRpb25Qb2ludHMoKSB7XG4gICAgICBsZXQgaXAkID0gW107XG4gICAgICBsZXQgbiA9IHRoaXMubm9kZS5hc3NpZ25lZFNsb3Q7XG4gICAgICB3aGlsZSAobikge1xuICAgICAgICBpcCQucHVzaChuKTtcbiAgICAgICAgbiA9IG4uYXNzaWduZWRTbG90O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlwJDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxscyBgaW1wb3J0Tm9kZWAgb24gdGhlIGBvd25lckRvY3VtZW50YCBmb3IgdGhpcyBub2RlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlIE5vZGUgdG8gaW1wb3J0XG4gICAgICogQHBhcmFtIHtib29sZWFufSBkZWVwIFRydWUgaWYgdGhlIG5vZGUgc2hvdWxkIGJlIGNsb25lZCBkZWVwbHkgZHVyaW5nXG4gICAgICogICBpbXBvcnRcbiAgICAgKiBAcmV0dXJuIHtOb2RlfSBDbG9uZSBvZiBnaXZlbiBub2RlIGltcG9ydGVkIHRvIHRoaXMgb3duZXIgZG9jdW1lbnRcbiAgICAgKi9cbiAgICBpbXBvcnROb2RlKG5vZGUsIGRlZXApIHtcbiAgICAgIGxldCBkb2MgPSB0aGlzLm5vZGUgaW5zdGFuY2VvZiBEb2N1bWVudCA/IHRoaXMubm9kZSA6XG4gICAgICAgIHRoaXMubm9kZS5vd25lckRvY3VtZW50O1xuICAgICAgcmV0dXJuIGRvYy5pbXBvcnROb2RlKG5vZGUsIGRlZXApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge0FycmF5fSBSZXR1cm5zIGEgZmxhdHRlbmVkIGxpc3Qgb2YgYWxsIGNoaWxkIG5vZGVzIGFuZCBub2RlcyBhc3NpZ25lZFxuICAgICAqIHRvIGNoaWxkIHNsb3RzLlxuICAgICAqL1xuICAgIGdldEVmZmVjdGl2ZUNoaWxkTm9kZXMoKSB7XG4gICAgICByZXR1cm4gUG9seW1lci5GbGF0dGVuZWROb2Rlc09ic2VydmVyLmdldEZsYXR0ZW5lZE5vZGVzKHRoaXMubm9kZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGZpbHRlcmVkIGxpc3Qgb2YgZmxhdHRlbmVkIGNoaWxkIGVsZW1lbnRzIGZvciB0aGlzIGVsZW1lbnQgYmFzZWRcbiAgICAgKiBvbiB0aGUgZ2l2ZW4gc2VsZWN0b3IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3IgU2VsZWN0b3IgdG8gZmlsdGVyIG5vZGVzIGFnYWluc3RcbiAgICAgKiBAcmV0dXJuIHtBcnJheTxIVE1MRWxlbWVudD59IExpc3Qgb2YgZmxhdHRlbmVkIGNoaWxkIGVsZW1lbnRzXG4gICAgICovXG4gICAgcXVlcnlEaXN0cmlidXRlZEVsZW1lbnRzKHNlbGVjdG9yKSB7XG4gICAgICBsZXQgYyQgPSB0aGlzLmdldEVmZmVjdGl2ZUNoaWxkTm9kZXMoKTtcbiAgICAgIGxldCBsaXN0ID0gW107XG4gICAgICBmb3IgKGxldCBpPTAsIGw9YyQubGVuZ3RoLCBjOyAoaTxsKSAmJiAoYz1jJFtpXSk7IGkrKykge1xuICAgICAgICBpZiAoKGMubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKSAmJlxuICAgICAgICAgICAgbWF0Y2hlc1NlbGVjdG9yKGMsIHNlbGVjdG9yKSkge1xuICAgICAgICAgIGxpc3QucHVzaChjKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRm9yIHNoYWRvdyByb290cywgcmV0dXJucyB0aGUgY3VycmVudGx5IGZvY3VzZWQgZWxlbWVudCB3aXRoaW4gdGhpc1xuICAgICAqIHNoYWRvdyByb290LlxuICAgICAqXG4gICAgICogQHJldHVybiB7Tm9kZXx1bmRlZmluZWR9IEN1cnJlbnRseSBmb2N1c2VkIGVsZW1lbnRcbiAgICAgKi9cbiAgICBnZXQgYWN0aXZlRWxlbWVudCgpIHtcbiAgICAgIGxldCBub2RlID0gdGhpcy5ub2RlO1xuICAgICAgcmV0dXJuIG5vZGUuX2FjdGl2ZUVsZW1lbnQgIT09IHVuZGVmaW5lZCA/IG5vZGUuX2FjdGl2ZUVsZW1lbnQgOiBub2RlLmFjdGl2ZUVsZW1lbnQ7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZm9yd2FyZE1ldGhvZHMocHJvdG8sIG1ldGhvZHMpIHtcbiAgICBmb3IgKGxldCBpPTA7IGkgPCBtZXRob2RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgbWV0aG9kID0gbWV0aG9kc1tpXTtcbiAgICAgIHByb3RvW21ldGhvZF0gPSAvKiogQHRoaXMge0RvbUFwaX0gKi8gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGVbbWV0aG9kXS5hcHBseSh0aGlzLm5vZGUsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZm9yd2FyZFJlYWRPbmx5UHJvcGVydGllcyhwcm90bywgcHJvcGVydGllcykge1xuICAgIGZvciAobGV0IGk9MDsgaSA8IHByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBuYW1lID0gcHJvcGVydGllc1tpXTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90bywgbmFtZSwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiAvKiogQHR5cGUge0RvbUFwaX0gKi8gKHRoaXMpLm5vZGVbbmFtZV07XG4gICAgICAgIH0sXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZm9yd2FyZFByb3BlcnRpZXMocHJvdG8sIHByb3BlcnRpZXMpIHtcbiAgICBmb3IgKGxldCBpPTA7IGkgPCBwcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgbmFtZSA9IHByb3BlcnRpZXNbaV07XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG8sIG5hbWUsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gLyoqIEB0eXBlIHtEb21BcGl9ICovICh0aGlzKS5ub2RlW25hbWVdO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgLyoqIEB0eXBlIHtEb21BcGl9ICovICh0aGlzKS5ub2RlW25hbWVdID0gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgZm9yd2FyZE1ldGhvZHMoRG9tQXBpLnByb3RvdHlwZSwgW1xuICAgICdjbG9uZU5vZGUnLCAnYXBwZW5kQ2hpbGQnLCAnaW5zZXJ0QmVmb3JlJywgJ3JlbW92ZUNoaWxkJyxcbiAgICAncmVwbGFjZUNoaWxkJywgJ3NldEF0dHJpYnV0ZScsICdyZW1vdmVBdHRyaWJ1dGUnLFxuICAgICdxdWVyeVNlbGVjdG9yJywgJ3F1ZXJ5U2VsZWN0b3JBbGwnXG4gIF0pO1xuXG4gIGZvcndhcmRSZWFkT25seVByb3BlcnRpZXMoRG9tQXBpLnByb3RvdHlwZSwgW1xuICAgICdwYXJlbnROb2RlJywgJ2ZpcnN0Q2hpbGQnLCAnbGFzdENoaWxkJyxcbiAgICAnbmV4dFNpYmxpbmcnLCAncHJldmlvdXNTaWJsaW5nJywgJ2ZpcnN0RWxlbWVudENoaWxkJyxcbiAgICAnbGFzdEVsZW1lbnRDaGlsZCcsICduZXh0RWxlbWVudFNpYmxpbmcnLCAncHJldmlvdXNFbGVtZW50U2libGluZycsXG4gICAgJ2NoaWxkTm9kZXMnLCAnY2hpbGRyZW4nLCAnY2xhc3NMaXN0J1xuICBdKTtcblxuICBmb3J3YXJkUHJvcGVydGllcyhEb21BcGkucHJvdG90eXBlLCBbXG4gICAgJ3RleHRDb250ZW50JywgJ2lubmVySFRNTCdcbiAgXSk7XG5cblxuICAvKipcbiAgICogRXZlbnQgQVBJIHdyYXBwZXIgY2xhc3MgcmV0dXJuZWQgZnJvbSBgUG9seW1lci5kb20uKHRhcmdldClgIHdoZW5cbiAgICogYHRhcmdldGAgaXMgYW4gYEV2ZW50YC5cbiAgICovXG4gIGNsYXNzIEV2ZW50QXBpIHtcbiAgICBjb25zdHJ1Y3RvcihldmVudCkge1xuICAgICAgdGhpcy5ldmVudCA9IGV2ZW50O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGZpcnN0IG5vZGUgb24gdGhlIGBjb21wb3NlZFBhdGhgIG9mIHRoaXMgZXZlbnQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtOb2RlfSBUaGUgbm9kZSB0aGlzIGV2ZW50IHdhcyBkaXNwYXRjaGVkIHRvXG4gICAgICovXG4gICAgZ2V0IHJvb3RUYXJnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5ldmVudC5jb21wb3NlZFBhdGgoKVswXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBsb2NhbCAocmUtdGFyZ2V0ZWQpIHRhcmdldCBmb3IgdGhpcyBldmVudC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge05vZGV9IFRoZSBsb2NhbCAocmUtdGFyZ2V0ZWQpIHRhcmdldCBmb3IgdGhpcyBldmVudC5cbiAgICAgKi9cbiAgICBnZXQgbG9jYWxUYXJnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5ldmVudC50YXJnZXQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYGNvbXBvc2VkUGF0aGAgZm9yIHRoaXMgZXZlbnQuXG4gICAgICovXG4gICAgZ2V0IHBhdGgoKSB7XG4gICAgICByZXR1cm4gdGhpcy5ldmVudC5jb21wb3NlZFBhdGgoKTtcbiAgICB9XG4gIH1cblxuICBQb2x5bWVyLkRvbUFwaSA9IERvbUFwaTtcblxuICAvKipcbiAgICogTGVnYWN5IERPTSBhbmQgRXZlbnQgbWFuaXB1bGF0aW9uIEFQSSB3cmFwcGVyIGZhY3RvcnkgdXNlZCB0byBhYnN0cmFjdFxuICAgKiBkaWZmZXJlbmNlcyBiZXR3ZWVuIG5hdGl2ZSBTaGFkb3cgRE9NIGFuZCBcIlNoYWR5IERPTVwiIHdoZW4gcG9seWZpbGxpbmcgb25cbiAgICogb2xkZXIgYnJvd3NlcnMuXG4gICAqXG4gICAqIE5vdGUgdGhhdCBpbiBQb2x5bWVyIDIueCB1c2Ugb2YgYFBvbHltZXIuZG9tYCBpcyBubyBsb25nZXIgcmVxdWlyZWQgYW5kXG4gICAqIGluIHRoZSBtYWpvcml0eSBvZiBjYXNlcyBzaW1wbHkgZmFjYWRlcyBkaXJlY3RseSB0byB0aGUgc3RhbmRhcmQgbmF0aXZlXG4gICAqIEFQSS5cbiAgICpcbiAgICogQG5hbWVzcGFjZVxuICAgKiBAc3VtbWFyeSBMZWdhY3kgRE9NIGFuZCBFdmVudCBtYW5pcHVsYXRpb24gQVBJIHdyYXBwZXIgZmFjdG9yeSB1c2VkIHRvXG4gICAqIGFic3RyYWN0IGRpZmZlcmVuY2VzIGJldHdlZW4gbmF0aXZlIFNoYWRvdyBET00gYW5kIFwiU2hhZHkgRE9NLlwiXG4gICAqIEBtZW1iZXJvZiBQb2x5bWVyXG4gICAqIEBwYXJhbSB7IU5vZGV8RXZlbnR9IG9iaiBOb2RlIG9yIGV2ZW50IHRvIG9wZXJhdGUgb25cbiAgICogQHJldHVybiB7RG9tQXBpfEV2ZW50QXBpfSBXcmFwcGVyIHByb3ZpZGluZyBlaXRoZXIgbm9kZSBBUEkgb3IgZXZlbnQgQVBJXG4gICAqL1xuICBQb2x5bWVyLmRvbSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIG9iaiA9IG9iaiB8fCBkb2N1bWVudDtcbiAgICBpZiAoIW9iai5fX2RvbUFwaSkge1xuICAgICAgbGV0IGhlbHBlcjtcbiAgICAgIGlmIChvYmogaW5zdGFuY2VvZiBFdmVudCkge1xuICAgICAgICBoZWxwZXIgPSBuZXcgRXZlbnRBcGkob2JqKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhlbHBlciA9IG5ldyBEb21BcGkob2JqKTtcbiAgICAgIH1cbiAgICAgIG9iai5fX2RvbUFwaSA9IGhlbHBlcjtcbiAgICB9XG4gICAgcmV0dXJuIG9iai5fX2RvbUFwaTtcbiAgfTtcblxuICBQb2x5bWVyLmRvbS5tYXRjaGVzU2VsZWN0b3IgPSBtYXRjaGVzU2VsZWN0b3I7XG5cbiAgLyoqXG4gICAqIEZvcmNlcyBzZXZlcmFsIGNsYXNzZXMgb2YgYXN5bmNocm9ub3VzbHkgcXVldWVkIHRhc2tzIHRvIGZsdXNoOlxuICAgKiAtIERlYm91bmNlcnMgYWRkZWQgdmlhIGBQb2x5bWVyLmVucXVldWVEZWJvdW5jZXJgXG4gICAqIC0gU2hhZHlET00gZGlzdHJpYnV0aW9uXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGZhY2FkZXMgdG8gYFBvbHltZXIuZmx1c2hgLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgUG9seW1lci5kb21cbiAgICovXG4gIFBvbHltZXIuZG9tLmZsdXNoID0gUG9seW1lci5mbHVzaDtcblxuICAvKipcbiAgICogQWRkcyBhIGBQb2x5bWVyLkRlYm91bmNlcmAgdG8gYSBsaXN0IG9mIGdsb2JhbGx5IGZsdXNoYWJsZSB0YXNrcy5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgZmFjYWRlcyB0byBgUG9seW1lci5lbnF1ZXVlRGVib3VuY2VyYC5cbiAgICpcbiAgICogQG1lbWJlcm9mIFBvbHltZXIuZG9tXG4gICAqIEBwYXJhbSB7UG9seW1lci5EZWJvdW5jZXJ9IGRlYm91bmNlciBEZWJvdW5jZXIgdG8gZW5xdWV1ZVxuICAgKi9cbiAgUG9seW1lci5kb20uYWRkRGVib3VuY2VyID0gUG9seW1lci5lbnF1ZXVlRGVib3VuY2VyO1xufSkoKTtcbjwvc2NyaXB0PlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi9sZWdhY3kvcG9seW1lci5kb20uaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi91dGlscy9ib290Lmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi91dGlscy9hcnJheS1zcGxpY2UuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3V0aWxzL2FzeW5jLmh0bWxcIj5cbjxzY3JpcHQ+XG4oZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIGBub2RlYCBpcyBhIHNsb3QgZWxlbWVudFxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBub2RlIE5vZGUgdG8gdGVzdC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBgbm9kZWAgaXMgYSBzbG90XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBpc1Nsb3Qobm9kZSkge1xuICAgIHJldHVybiAobm9kZS5sb2NhbE5hbWUgPT09ICdzbG90Jyk7XG4gIH1cblxuICAvKipcbiAgICogQ2xhc3MgdGhhdCBsaXN0ZW5zIGZvciBjaGFuZ2VzIChhZGRpdGlvbnMgb3IgcmVtb3ZhbHMpIHRvXG4gICAqIFwiZmxhdHRlbmVkIG5vZGVzXCIgb24gYSBnaXZlbiBgbm9kZWAuIFRoZSBsaXN0IG9mIGZsYXR0ZW5lZCBub2RlcyBjb25zaXN0c1xuICAgKiBvZiBhIG5vZGUncyBjaGlsZHJlbiBhbmQsIGZvciBhbnkgY2hpbGRyZW4gdGhhdCBhcmUgYDxzbG90PmAgZWxlbWVudHMsXG4gICAqIHRoZSBleHBhbmRlZCBmbGF0dGVuZWQgbGlzdCBvZiBgYXNzaWduZWROb2Rlc2AuXG4gICAqIEZvciBleGFtcGxlLCBpZiB0aGUgb2JzZXJ2ZWQgbm9kZSBoYXMgY2hpbGRyZW4gYDxhPjwvYT48c2xvdD48L3Nsb3Q+PGI+PC9iPmBcbiAgICogYW5kIHRoZSBgPHNsb3Q+YCBoYXMgb25lIGA8ZGl2PmAgYXNzaWduZWQgdG8gaXQsIHRoZW4gdGhlIGZsYXR0ZW5lZFxuICAgKiBub2RlcyBsaXN0IGlzIGA8YT48L2E+PGRpdj48L2Rpdj48Yj48L2I+YC4gSWYgdGhlIGA8c2xvdD5gIGhhcyBvdGhlclxuICAgKiBgPHNsb3Q+YCBlbGVtZW50cyBhc3NpZ25lZCB0byBpdCwgdGhlc2UgYXJlIGZsYXR0ZW5lZCBhcyB3ZWxsLlxuICAgKlxuICAgKiBUaGUgcHJvdmlkZWQgYGNhbGxiYWNrYCBpcyBjYWxsZWQgd2hlbmV2ZXIgYW55IGNoYW5nZSB0byB0aGlzIGxpc3RcbiAgICogb2YgZmxhdHRlbmVkIG5vZGVzIG9jY3Vycywgd2hlcmUgYW4gYWRkaXRpb24gb3IgcmVtb3ZhbCBvZiBhIG5vZGUgaXNcbiAgICogY29uc2lkZXJlZCBhIGNoYW5nZS4gVGhlIGBjYWxsYmFja2AgaXMgY2FsbGVkIHdpdGggb25lIGFyZ3VtZW50LCBhbiBvYmplY3RcbiAgICogY29udGFpbmluZyBhbiBhcnJheSBvZiBhbnkgYGFkZGVkTm9kZXNgIGFuZCBgcmVtb3ZlZE5vZGVzYC5cbiAgICpcbiAgICogTm90ZTogdGhlIGNhbGxiYWNrIGlzIGNhbGxlZCBhc3luY2hyb25vdXMgdG8gYW55IGNoYW5nZXNcbiAgICogYXQgYSBtaWNyb3Rhc2sgY2hlY2twb2ludC4gVGhpcyBpcyBiZWNhdXNlIG9ic2VydmF0aW9uIGlzIHBlcmZvcm1lZCB1c2luZ1xuICAgKiBgTXV0YXRpb25PYnNlcnZlcmAgYW5kIHRoZSBgPHNsb3Q+YCBlbGVtZW50J3MgYHNsb3RjaGFuZ2VgIGV2ZW50IHdoaWNoXG4gICAqIGFyZSBhc3luY2hyb25vdXMuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBQb2x5bWVyXG4gICAqIEBzdW1tYXJ5IENsYXNzIHRoYXQgbGlzdGVucyBmb3IgY2hhbmdlcyAoYWRkaXRpb25zIG9yIHJlbW92YWxzKSB0b1xuICAgKiBcImZsYXR0ZW5lZCBub2Rlc1wiIG9uIGEgZ2l2ZW4gYG5vZGVgLlxuICAgKi9cbiAgY2xhc3MgRmxhdHRlbmVkTm9kZXNPYnNlcnZlciB7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBsaXN0IG9mIGZsYXR0ZW5lZCBub2RlcyBmb3IgdGhlIGdpdmVuIGBub2RlYC5cbiAgICAgKiBUaGlzIGxpc3QgY29uc2lzdHMgb2YgYSBub2RlJ3MgY2hpbGRyZW4gYW5kLCBmb3IgYW55IGNoaWxkcmVuXG4gICAgICogdGhhdCBhcmUgYDxzbG90PmAgZWxlbWVudHMsIHRoZSBleHBhbmRlZCBmbGF0dGVuZWQgbGlzdCBvZiBgYXNzaWduZWROb2Rlc2AuXG4gICAgICogRm9yIGV4YW1wbGUsIGlmIHRoZSBvYnNlcnZlZCBub2RlIGhhcyBjaGlsZHJlbiBgPGE+PC9hPjxzbG90Pjwvc2xvdD48Yj48L2I+YFxuICAgICAqIGFuZCB0aGUgYDxzbG90PmAgaGFzIG9uZSBgPGRpdj5gIGFzc2lnbmVkIHRvIGl0LCB0aGVuIHRoZSBmbGF0dGVuZWRcbiAgICAgKiBub2RlcyBsaXN0IGlzIGA8YT48L2E+PGRpdj48L2Rpdj48Yj48L2I+YC4gSWYgdGhlIGA8c2xvdD5gIGhhcyBvdGhlclxuICAgICAqIGA8c2xvdD5gIGVsZW1lbnRzIGFzc2lnbmVkIHRvIGl0LCB0aGVzZSBhcmUgZmxhdHRlbmVkIGFzIHdlbGwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fEhUTUxTbG90RWxlbWVudH0gbm9kZSBUaGUgbm9kZSBmb3Igd2hpY2ggdG8gcmV0dXJuIHRoZSBsaXN0IG9mIGZsYXR0ZW5lZCBub2Rlcy5cbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gVGhlIGxpc3Qgb2YgZmxhdHRlbmVkIG5vZGVzIGZvciB0aGUgZ2l2ZW4gYG5vZGVgLlxuICAgICovXG4gICAgc3RhdGljIGdldEZsYXR0ZW5lZE5vZGVzKG5vZGUpIHtcbiAgICAgIGlmIChpc1Nsb3Qobm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIC8qKiBAdHlwZSB7SFRNTFNsb3RFbGVtZW50fSAqLyAobm9kZSkuYXNzaWduZWROb2Rlcyh7ZmxhdHRlbjogdHJ1ZX0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20obm9kZS5jaGlsZE5vZGVzKS5tYXAobm9kZSA9PiB7XG4gICAgICAgICAgaWYgKGlzU2xvdChub2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuIC8qKiBAdHlwZSB7SFRNTFNsb3RFbGVtZW50fSAqLyAobm9kZSkuYXNzaWduZWROb2Rlcyh7ZmxhdHRlbjogdHJ1ZX0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gW25vZGVdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkucmVkdWNlKChhLCBiKSA9PiBhLmNvbmNhdChiKSwgW10pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Tm9kZX0gdGFyZ2V0IE5vZGUgb24gd2hpY2ggdG8gbGlzdGVuIGZvciBjaGFuZ2VzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIEZ1bmN0aW9uIGNhbGxlZCB3aGVuIHRoZXJlIGFyZSBhZGRpdGlvbnNcbiAgICAgKiBvciByZW1vdmFscyBmcm9tIHRoZSB0YXJnZXQncyBsaXN0IG9mIGZsYXR0ZW5lZCBub2Rlcy5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHRhcmdldCwgY2FsbGJhY2spIHtcbiAgICAgIC8qKiBAdHlwZSB7TXV0YXRpb25PYnNlcnZlcn0gKi9cbiAgICAgIHRoaXMuX3NoYWR5Q2hpbGRyZW5PYnNlcnZlciA9IG51bGw7XG4gICAgICAvKiogQHR5cGUge011dGF0aW9uT2JzZXJ2ZXJ9ICovXG4gICAgICB0aGlzLl9uYXRpdmVDaGlsZHJlbk9ic2VydmVyID0gbnVsbDtcbiAgICAgIHRoaXMuX2Nvbm5lY3RlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5fdGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgdGhpcy5fZWZmZWN0aXZlTm9kZXMgPSBbXTtcbiAgICAgIHRoaXMuX29ic2VydmVyID0gbnVsbDtcbiAgICAgIHRoaXMuX3NjaGVkdWxlZCA9IGZhbHNlO1xuICAgICAgLyoqIEB0eXBlIHtmdW5jdGlvbigpfSAqL1xuICAgICAgdGhpcy5fYm91bmRTY2hlZHVsZSA9ICgpID0+IHtcbiAgICAgICAgdGhpcy5fc2NoZWR1bGUoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY29ubmVjdCgpO1xuICAgICAgdGhpcy5fc2NoZWR1bGUoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBY3RpdmF0ZXMgYW4gb2JzZXJ2ZXIuIFRoaXMgbWV0aG9kIGlzIGF1dG9tYXRpY2FsbHkgY2FsbGVkIHdoZW5cbiAgICAgKiBhIGBGbGF0dGVuZWROb2Rlc09ic2VydmVyYCBpcyBjcmVhdGVkLiBJdCBzaG91bGQgb25seSBiZSBjYWxsZWQgdG9cbiAgICAgKiByZS1hY3RpdmF0ZSBhbiBvYnNlcnZlciB0aGF0IGhhcyBiZWVuIGRlYWN0aXZhdGVkIHZpYSB0aGUgYGRpc2Nvbm5lY3RgIG1ldGhvZC5cbiAgICAgKi9cbiAgICBjb25uZWN0KCkge1xuICAgICAgaWYgKGlzU2xvdCh0aGlzLl90YXJnZXQpKSB7XG4gICAgICAgIHRoaXMuX2xpc3RlblNsb3RzKFt0aGlzLl90YXJnZXRdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2xpc3RlblNsb3RzKHRoaXMuX3RhcmdldC5jaGlsZHJlbik7XG4gICAgICAgIGlmICh3aW5kb3cuU2hhZHlET00pIHtcbiAgICAgICAgICB0aGlzLl9zaGFkeUNoaWxkcmVuT2JzZXJ2ZXIgPVxuICAgICAgICAgICAgU2hhZHlET00ub2JzZXJ2ZUNoaWxkcmVuKHRoaXMuX3RhcmdldCwgKG11dGF0aW9ucykgPT4ge1xuICAgICAgICAgICAgICB0aGlzLl9wcm9jZXNzTXV0YXRpb25zKG11dGF0aW9ucyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9uYXRpdmVDaGlsZHJlbk9ic2VydmVyID1cbiAgICAgICAgICAgIG5ldyBNdXRhdGlvbk9ic2VydmVyKChtdXRhdGlvbnMpID0+IHtcbiAgICAgICAgICAgICAgdGhpcy5fcHJvY2Vzc011dGF0aW9ucyhtdXRhdGlvbnMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy5fbmF0aXZlQ2hpbGRyZW5PYnNlcnZlci5vYnNlcnZlKHRoaXMuX3RhcmdldCwge2NoaWxkTGlzdDogdHJ1ZX0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLl9jb25uZWN0ZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlYWN0aXZhdGVzIHRoZSBmbGF0dGVuZWQgbm9kZXMgb2JzZXJ2ZXIuIEFmdGVyIGNhbGxpbmcgdGhpcyBtZXRob2RcbiAgICAgKiB0aGUgb2JzZXJ2ZXIgY2FsbGJhY2sgd2lsbCBub3QgYmUgY2FsbGVkIHdoZW4gY2hhbmdlcyB0byBmbGF0dGVuZWQgbm9kZXNcbiAgICAgKiBvY2N1ci4gVGhlIGBjb25uZWN0YCBtZXRob2QgbWF5IGJlIHN1YnNlcXVlbnRseSBjYWxsZWQgdG8gcmVhY3RpdmF0ZVxuICAgICAqIHRoZSBvYnNlcnZlci5cbiAgICAgKi9cbiAgICBkaXNjb25uZWN0KCkge1xuICAgICAgaWYgKGlzU2xvdCh0aGlzLl90YXJnZXQpKSB7XG4gICAgICAgIHRoaXMuX3VubGlzdGVuU2xvdHMoW3RoaXMuX3RhcmdldF0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fdW5saXN0ZW5TbG90cyh0aGlzLl90YXJnZXQuY2hpbGRyZW4pO1xuICAgICAgICBpZiAod2luZG93LlNoYWR5RE9NICYmIHRoaXMuX3NoYWR5Q2hpbGRyZW5PYnNlcnZlcikge1xuICAgICAgICAgIFNoYWR5RE9NLnVub2JzZXJ2ZUNoaWxkcmVuKHRoaXMuX3NoYWR5Q2hpbGRyZW5PYnNlcnZlcik7XG4gICAgICAgICAgdGhpcy5fc2hhZHlDaGlsZHJlbk9ic2VydmVyID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9uYXRpdmVDaGlsZHJlbk9ic2VydmVyKSB7XG4gICAgICAgICAgdGhpcy5fbmF0aXZlQ2hpbGRyZW5PYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgdGhpcy5fbmF0aXZlQ2hpbGRyZW5PYnNlcnZlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuX2Nvbm5lY3RlZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIF9zY2hlZHVsZSgpIHtcbiAgICAgIGlmICghdGhpcy5fc2NoZWR1bGVkKSB7XG4gICAgICAgIHRoaXMuX3NjaGVkdWxlZCA9IHRydWU7XG4gICAgICAgIFBvbHltZXIuQXN5bmMubWljcm9UYXNrLnJ1bigoKSA9PiB0aGlzLmZsdXNoKCkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIF9wcm9jZXNzTXV0YXRpb25zKG11dGF0aW9ucykge1xuICAgICAgdGhpcy5fcHJvY2Vzc1Nsb3RNdXRhdGlvbnMobXV0YXRpb25zKTtcbiAgICAgIHRoaXMuZmx1c2goKTtcbiAgICB9XG5cbiAgICBfcHJvY2Vzc1Nsb3RNdXRhdGlvbnMobXV0YXRpb25zKSB7XG4gICAgICBpZiAobXV0YXRpb25zKSB7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaSA8IG11dGF0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGxldCBtdXRhdGlvbiA9IG11dGF0aW9uc1tpXTtcbiAgICAgICAgICBpZiAobXV0YXRpb24uYWRkZWROb2Rlcykge1xuICAgICAgICAgICAgdGhpcy5fbGlzdGVuU2xvdHMobXV0YXRpb24uYWRkZWROb2Rlcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtdXRhdGlvbi5yZW1vdmVkTm9kZXMpIHtcbiAgICAgICAgICAgIHRoaXMuX3VubGlzdGVuU2xvdHMobXV0YXRpb24ucmVtb3ZlZE5vZGVzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGbHVzaGVzIHRoZSBvYnNlcnZlciBjYXVzaW5nIGFueSBwZW5kaW5nIGNoYW5nZXMgdG8gYmUgaW1tZWRpYXRlbHlcbiAgICAgKiBkZWxpdmVyZWQgdGhlIG9ic2VydmVyIGNhbGxiYWNrLiBCeSBkZWZhdWx0IHRoZXNlIGNoYW5nZXMgYXJlIGRlbGl2ZXJlZFxuICAgICAqIGFzeW5jaHJvbm91c2x5IGF0IHRoZSBuZXh0IG1pY3JvdGFzayBjaGVja3BvaW50LlxuICAgICAqXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIGFueSBwZW5kaW5nIGNoYW5nZXMgY2F1c2VkIHRoZSBvYnNlcnZlclxuICAgICAqIGNhbGxiYWNrIHRvIHJ1bi5cbiAgICAgKi9cbiAgICBmbHVzaCgpIHtcbiAgICAgIGlmICghdGhpcy5fY29ubmVjdGVkKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICh3aW5kb3cuU2hhZHlET00pIHtcbiAgICAgICAgU2hhZHlET00uZmx1c2goKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9uYXRpdmVDaGlsZHJlbk9ic2VydmVyKSB7XG4gICAgICAgIHRoaXMuX3Byb2Nlc3NTbG90TXV0YXRpb25zKHRoaXMuX25hdGl2ZUNoaWxkcmVuT2JzZXJ2ZXIudGFrZVJlY29yZHMoKSk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX3NoYWR5Q2hpbGRyZW5PYnNlcnZlcikge1xuICAgICAgICB0aGlzLl9wcm9jZXNzU2xvdE11dGF0aW9ucyh0aGlzLl9zaGFkeUNoaWxkcmVuT2JzZXJ2ZXIudGFrZVJlY29yZHMoKSk7XG4gICAgICB9XG4gICAgICB0aGlzLl9zY2hlZHVsZWQgPSBmYWxzZTtcbiAgICAgIGxldCBpbmZvID0ge1xuICAgICAgICB0YXJnZXQ6IHRoaXMuX3RhcmdldCxcbiAgICAgICAgYWRkZWROb2RlczogW10sXG4gICAgICAgIHJlbW92ZWROb2RlczogW11cbiAgICAgIH07XG4gICAgICBsZXQgbmV3Tm9kZXMgPSB0aGlzLmNvbnN0cnVjdG9yLmdldEZsYXR0ZW5lZE5vZGVzKHRoaXMuX3RhcmdldCk7XG4gICAgICBsZXQgc3BsaWNlcyA9IFBvbHltZXIuQXJyYXlTcGxpY2UuY2FsY3VsYXRlU3BsaWNlcyhuZXdOb2RlcyxcbiAgICAgICAgdGhpcy5fZWZmZWN0aXZlTm9kZXMpO1xuICAgICAgLy8gcHJvY2VzcyByZW1vdmFsc1xuICAgICAgZm9yIChsZXQgaT0wLCBzOyAoaTxzcGxpY2VzLmxlbmd0aCkgJiYgKHM9c3BsaWNlc1tpXSk7IGkrKykge1xuICAgICAgICBmb3IgKGxldCBqPTAsIG47IChqIDwgcy5yZW1vdmVkLmxlbmd0aCkgJiYgKG49cy5yZW1vdmVkW2pdKTsgaisrKSB7XG4gICAgICAgICAgaW5mby5yZW1vdmVkTm9kZXMucHVzaChuKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gcHJvY2VzcyBhZGRzXG4gICAgICBmb3IgKGxldCBpPTAsIHM7IChpPHNwbGljZXMubGVuZ3RoKSAmJiAocz1zcGxpY2VzW2ldKTsgaSsrKSB7XG4gICAgICAgIGZvciAobGV0IGo9cy5pbmRleDsgaiA8IHMuaW5kZXggKyBzLmFkZGVkQ291bnQ7IGorKykge1xuICAgICAgICAgIGluZm8uYWRkZWROb2Rlcy5wdXNoKG5ld05vZGVzW2pdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gdXBkYXRlIGNhY2hlXG4gICAgICB0aGlzLl9lZmZlY3RpdmVOb2RlcyA9IG5ld05vZGVzO1xuICAgICAgbGV0IGRpZEZsdXNoID0gZmFsc2U7XG4gICAgICBpZiAoaW5mby5hZGRlZE5vZGVzLmxlbmd0aCB8fCBpbmZvLnJlbW92ZWROb2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgZGlkRmx1c2ggPSB0cnVlO1xuICAgICAgICB0aGlzLmNhbGxiYWNrLmNhbGwodGhpcy5fdGFyZ2V0LCBpbmZvKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkaWRGbHVzaDtcbiAgICB9XG5cbiAgICBfbGlzdGVuU2xvdHMobm9kZUxpc3QpIHtcbiAgICAgIGZvciAobGV0IGk9MDsgaSA8IG5vZGVMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBuID0gbm9kZUxpc3RbaV07XG4gICAgICAgIGlmIChpc1Nsb3QobikpIHtcbiAgICAgICAgICBuLmFkZEV2ZW50TGlzdGVuZXIoJ3Nsb3RjaGFuZ2UnLCB0aGlzLl9ib3VuZFNjaGVkdWxlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIF91bmxpc3RlblNsb3RzKG5vZGVMaXN0KSB7XG4gICAgICBmb3IgKGxldCBpPTA7IGkgPCBub2RlTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgbiA9IG5vZGVMaXN0W2ldO1xuICAgICAgICBpZiAoaXNTbG90KG4pKSB7XG4gICAgICAgICAgbi5yZW1vdmVFdmVudExpc3RlbmVyKCdzbG90Y2hhbmdlJywgdGhpcy5fYm91bmRTY2hlZHVsZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgfVxuXG4gIFBvbHltZXIuRmxhdHRlbmVkTm9kZXNPYnNlcnZlciA9IEZsYXR0ZW5lZE5vZGVzT2JzZXJ2ZXI7XG5cbn0pKCk7XG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvdXRpbHMvZmxhdHRlbmVkLW5vZGVzLW9ic2VydmVyLmh0bWwiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCJjbGFzcy5odG1sXCI+XG5cbjxzY3JpcHQ+XG5cbiAgKGZ1bmN0aW9uKCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIC8qKlxuICAgICAqIExlZ2FjeSBjbGFzcyBmYWN0b3J5IGFuZCByZWdpc3RyYXRpb24gaGVscGVyIGZvciBkZWZpbmluZyBQb2x5bWVyXG4gICAgICogZWxlbWVudHMuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBlcXVpdmFsZW50IHRvXG4gICAgICogYGN1c3RvbUVsZW1lbnRzLmRlZmluZShpbmZvLmlzLCBQb2x5bWVyLkNsYXNzKGluZm8pKTtgXG4gICAgICpcbiAgICAgKiBTZWUgYFBvbHltZXIuQ2xhc3NgIGZvciBkZXRhaWxzIG9uIHZhbGlkIGxlZ2FjeSBtZXRhZGF0YSBmb3JtYXQgZm9yIGBpbmZvYC5cbiAgICAgKlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqIEBmdW5jdGlvbiBQb2x5bWVyXG4gICAgICogQHBhcmFtIHshUG9seW1lckluaXR9IGluZm8gT2JqZWN0IGNvbnRhaW5pbmcgUG9seW1lciBtZXRhZGF0YSBhbmQgZnVuY3Rpb25zXG4gICAgICogICB0byBiZWNvbWUgY2xhc3MgbWV0aG9kcy5cbiAgICAgKiBAcmV0dXJuIHshSFRNTEVsZW1lbnR9IEdlbmVyYXRlZCBjbGFzc1xuICAgICAqIEBzdXBwcmVzcyB7ZHVwbGljYXRlLCBpbnZhbGlkQ2FzdHMsIGNoZWNrVHlwZXN9XG4gICAgICovXG4gICAgd2luZG93LlBvbHltZXIuX3BvbHltZXJGbiA9IGZ1bmN0aW9uKGluZm8pIHtcbiAgICAgIC8vIGlmIGlucHV0IGlzIGEgYGNsYXNzYCAoYWthIGEgZnVuY3Rpb24gd2l0aCBhIHByb3RvdHlwZSksIHVzZSB0aGUgcHJvdG90eXBlXG4gICAgICAvLyByZW1lbWJlciB0aGF0IHRoZSBgY29uc3RydWN0b3JgIHdpbGwgbmV2ZXIgYmUgY2FsbGVkXG4gICAgICBsZXQga2xhc3M7XG4gICAgICBpZiAodHlwZW9mIGluZm8gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAga2xhc3MgPSBpbmZvO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAga2xhc3MgPSBQb2x5bWVyLkNsYXNzKGluZm8pO1xuICAgICAgfVxuICAgICAgY3VzdG9tRWxlbWVudHMuZGVmaW5lKGtsYXNzLmlzLCAvKiogQHR5cGUgeyFIVE1MRWxlbWVudH0gKi8oa2xhc3MpKTtcbiAgICAgIHJldHVybiBrbGFzcztcbiAgICB9O1xuXG4gIH0pKCk7XG5cbjwvc2NyaXB0PlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi9sZWdhY3kvcG9seW1lci1mbi5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cImxlZ2FjeS1lbGVtZW50LW1peGluLmh0bWxcIj5cbjxzY3JpcHQ+XG5cbiAgKGZ1bmN0aW9uKCkge1xuXG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgbGV0IG1ldGFQcm9wcyA9IHtcbiAgICAgIGF0dGFjaGVkOiB0cnVlLFxuICAgICAgZGV0YWNoZWQ6IHRydWUsXG4gICAgICByZWFkeTogdHJ1ZSxcbiAgICAgIGNyZWF0ZWQ6IHRydWUsXG4gICAgICBiZWZvcmVSZWdpc3RlcjogdHJ1ZSxcbiAgICAgIHJlZ2lzdGVyZWQ6IHRydWUsXG4gICAgICBhdHRyaWJ1dGVDaGFuZ2VkOiB0cnVlLFxuICAgICAgLy8gbWV0YSBvYmplY3RzXG4gICAgICBiZWhhdmlvcnM6IHRydWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIGEgXCJsZWdhY3lcIiBiZWhhdmlvciBvciBhcnJheSBvZiBiZWhhdmlvcnMgdG8gdGhlIHByb3ZpZGVkIGNsYXNzLlxuICAgICAqXG4gICAgICogTm90ZTogdGhpcyBtZXRob2Qgd2lsbCBhdXRvbWF0aWNhbGx5IGFsc28gYXBwbHkgdGhlIGBQb2x5bWVyLkxlZ2FjeUVsZW1lbnRNaXhpbmBcbiAgICAgKiB0byBlbnN1cmUgdGhhdCBhbnkgbGVnYWN5IGJlaGF2aW9ycyBjYW4gcmVseSBvbiBsZWdhY3kgUG9seW1lciBBUEkgb25cbiAgICAgKiB0aGUgdW5kZXJseWluZyBlbGVtZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHshKE9iamVjdHxBcnJheSl9IGJlaGF2aW9ycyBCZWhhdmlvciBvYmplY3Qgb3IgYXJyYXkgb2YgYmVoYXZpb3JzLlxuICAgICAqIEBwYXJhbSB7IUhUTUxFbGVtZW50fGZ1bmN0aW9uKG5ldzpIVE1MRWxlbWVudCl9IGtsYXNzIEVsZW1lbnQgY2xhc3MuXG4gICAgICogQHJldHVybiB7ZnVuY3Rpb24obmV3OkhUTUxFbGVtZW50KX0gUmV0dXJucyBhIG5ldyBFbGVtZW50IGNsYXNzIGV4dGVuZGVkIGJ5IHRoZVxuICAgICAqIHBhc3NlZCBpbiBgYmVoYXZpb3JzYCBhbmQgYWxzbyBieSBgUG9seW1lci5MZWdhY3lFbGVtZW50TWl4aW5gLlxuICAgICAqIEBtZW1iZXJvZiBQb2x5bWVyXG4gICAgICogQHN1cHByZXNzIHtpbnZhbGlkQ2FzdHMsIGNoZWNrVHlwZXN9XG4gICAgICovXG4gICAgZnVuY3Rpb24gbWl4aW5CZWhhdmlvcnMoYmVoYXZpb3JzLCBrbGFzcykge1xuICAgICAgaWYgKCFiZWhhdmlvcnMpIHtcbiAgICAgICAgcmV0dXJuIC8qKiBAdHlwZSB7SFRNTEVsZW1lbnR9ICovKGtsYXNzKTtcbiAgICAgIH1cbiAgICAgIC8vIE5PVEU6IGVuc3VyZSB0aGUgYmFoZXZpb3IgaXMgZXh0ZW5kaW5nIGEgY2xhc3Mgd2l0aFxuICAgICAgLy8gbGVnYWN5IGVsZW1lbnQgYXBpLiBUaGlzIGlzIG5lY2Vzc2FyeSBzaW5jZSBiZWhhdmlvcnMgZXhwZWN0IHRvIGJlIGFibGVcbiAgICAgIC8vIHRvIGFjY2VzcyAxLnggbGVnYWN5IGFwaS5cbiAgICAgIGtsYXNzID0gUG9seW1lci5MZWdhY3lFbGVtZW50TWl4aW4oa2xhc3MpO1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGJlaGF2aW9ycykpIHtcbiAgICAgICAgYmVoYXZpb3JzID0gW2JlaGF2aW9yc107XG4gICAgICB9XG4gICAgICBsZXQgc3VwZXJCZWhhdmlvcnMgPSBrbGFzcy5wcm90b3R5cGUuYmVoYXZpb3JzO1xuICAgICAgLy8gZ2V0IGZsYXR0ZW5lZCwgZGVkdXBlZCBsaXN0IG9mIGJlaGF2aW9ycyAqbm90KiBhbHJlYWR5IG9uIHN1cGVyIGNsYXNzXG4gICAgICBiZWhhdmlvcnMgPSBmbGF0dGVuQmVoYXZpb3JzKGJlaGF2aW9ycywgbnVsbCwgc3VwZXJCZWhhdmlvcnMpO1xuICAgICAgLy8gbWl4aW4gbmV3IGJlaGF2aW9yc1xuICAgICAga2xhc3MgPSBfbWl4aW5CZWhhdmlvcnMoYmVoYXZpb3JzLCBrbGFzcyk7XG4gICAgICBpZiAoc3VwZXJCZWhhdmlvcnMpIHtcbiAgICAgICAgYmVoYXZpb3JzID0gc3VwZXJCZWhhdmlvcnMuY29uY2F0KGJlaGF2aW9ycyk7XG4gICAgICB9XG4gICAgICAvLyBTZXQgYmVoYXZpb3JzIG9uIHByb3RvdHlwZSBmb3IgQkMuLi5cbiAgICAgIGtsYXNzLnByb3RvdHlwZS5iZWhhdmlvcnMgPSBiZWhhdmlvcnM7XG4gICAgICByZXR1cm4ga2xhc3M7XG4gICAgfVxuXG4gICAgLy8gTk9URTpcbiAgICAvLyAxLnhcbiAgICAvLyBCZWhhdmlvcnMgd2VyZSBtaXhlZCBpbiAqaW4gcmV2ZXJzZSBvcmRlciogYW5kIGRlLWR1cGVkIG9uIHRoZSBmbHkuXG4gICAgLy8gVGhlIHJ1bGUgd2FzIHRoYXQgYmVoYXZpb3IgcHJvcGVydGllcyB3ZXJlIGNvcGllZCBvbnRvIHRoZSBlbGVtZW50XG4gICAgLy8gcHJvdG90eXBlIGlmIGFuZCBvbmx5IGlmIHRoZSBwcm9wZXJ0eSBkaWQgbm90IGFscmVhZHkgZXhpc3QuXG4gICAgLy8gR2l2ZW46IFBvbHltZXJ7IGJlaGF2aW9yczogW0EsIEIsIEMsIEEsIEJdfSwgcHJvcGVydHkgY29weSBvcmRlciB3YXM6XG4gICAgLy8gKDEpLCBCLCAoMiksIEEsICgzKSBDLiBUaGlzIG1lYW5zIHByb3RvdHlwZSBwcm9wZXJ0aWVzIHdpbiBvdmVyXG4gICAgLy8gQiBwcm9wZXJ0aWVzIHdpbiBvdmVyIEEgd2luIG92ZXIgQy4gVGhpcyBtaXJyb3JzIHdoYXQgd291bGQgaGFwcGVuXG4gICAgLy8gd2l0aCBpbmhlcml0YW5jZSBpZiBlbGVtZW50IGV4dGVuZGVkIEIgZXh0ZW5kZWQgQSBleHRlbmRlZCBDLlxuICAgIC8vXG4gICAgLy8gQWdhaW4gZ2l2ZW4sIFBvbHltZXJ7IGJlaGF2aW9yczogW0EsIEIsIEMsIEEsIEJdfSwgdGhlIHJlc3VsdGluZ1xuICAgIC8vIGBiZWhhdmlvcnNgIGFycmF5IHdhcyBbQywgQSwgQl0uXG4gICAgLy8gQmVoYXZpb3IgbGlmZWN5Y2xlIG1ldGhvZHMgd2VyZSBjYWxsZWQgaW4gYmVoYXZpb3IgYXJyYXkgb3JkZXJcbiAgICAvLyBmb2xsb3dlZCBieSB0aGUgZWxlbWVudCwgZS5nLiAoMSkgQy5jcmVhdGVkLCAoMikgQS5jcmVhdGVkLFxuICAgIC8vICgzKSBCLmNyZWF0ZWQsICg0KSBlbGVtZW50LmNyZWF0ZWQuIFRoZXJlIHdhcyBubyBzdXBwb3J0IGZvclxuICAgIC8vIHN1cGVyLCBhbmQgXCJzdXBlci1iZWhhdmlvclwiIG1ldGhvZHMgd2VyZSBjYWxsYWJsZSBvbmx5IGJ5IG5hbWUpLlxuICAgIC8vXG4gICAgLy8gMi54XG4gICAgLy8gQmVoYXZpb3JzIGFyZSBtYWRlIGludG8gcHJvcGVyIG1peGlucyB3aGljaCBsaXZlIGluIHRoZVxuICAgIC8vIGVsZW1lbnQncyBwcm90b3R5cGUgY2hhaW4uIEJlaGF2aW9ycyBhcmUgcGxhY2VkIGluIHRoZSBlbGVtZW50IHByb3RvdHlwZVxuICAgIC8vIGVsZGVzdCB0byB5b3VuZ2VzdCBhbmQgZGUtZHVwZWQgeW91bmdlc3QgdG8gb2xkZXN0OlxuICAgIC8vIFNvLCBmaXJzdCBbQSwgQiwgQywgQSwgQl0gYmVjb21lcyBbQywgQSwgQl0gdGhlbixcbiAgICAvLyB0aGUgZWxlbWVudCBwcm90b3R5cGUgYmVjb21lcyAob2xkZXN0KSAoMSkgUG9seW1lci5FbGVtZW50LCAoMikgY2xhc3MoQyksXG4gICAgLy8gKDMpIGNsYXNzKEEpLCAoNCkgY2xhc3MoQiksICg1KSBjbGFzcyhQb2x5bWVyKHsuLi59KSkuXG4gICAgLy8gUmVzdWx0OlxuICAgIC8vIFRoaXMgbWVhbnMgZWxlbWVudCBwcm9wZXJ0aWVzIHdpbiBvdmVyIEIgcHJvcGVydGllcyB3aW4gb3ZlciBBIHdpblxuICAgIC8vIG92ZXIgQy4gKHNhbWUgYXMgMS54KVxuICAgIC8vIElmIGxpZmVjeWNsZSBpcyBjYWxsZWQgKHN1cGVyIHRoZW4gbWUpLCBvcmRlciBpc1xuICAgIC8vICgxKSBDLmNyZWF0ZWQsICgyKSBBLmNyZWF0ZWQsICgzKSBCLmNyZWF0ZWQsICg0KSBlbGVtZW50LmNyZWF0ZWRcbiAgICAvLyAoYWdhaW4gc2FtZSBhcyAxLngpXG4gICAgZnVuY3Rpb24gX21peGluQmVoYXZpb3JzKGJlaGF2aW9ycywga2xhc3MpIHtcbiAgICAgIGZvciAobGV0IGk9MDsgaTxiZWhhdmlvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGIgPSBiZWhhdmlvcnNbaV07XG4gICAgICAgIGlmIChiKSB7XG4gICAgICAgICAga2xhc3MgPSBBcnJheS5pc0FycmF5KGIpID8gX21peGluQmVoYXZpb3JzKGIsIGtsYXNzKSA6XG4gICAgICAgICAgICBHZW5lcmF0ZUNsYXNzRnJvbUluZm8oYiwga2xhc3MpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4ga2xhc3M7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBcnJheX0gYmVoYXZpb3JzIExpc3Qgb2YgYmVoYXZpb3JzIHRvIGZsYXR0ZW4uXG4gICAgICogQHBhcmFtIHtBcnJheT19IGxpc3QgVGFyZ2V0IGxpc3QgdG8gZmxhdHRlbiBiZWhhdmlvcnMgaW50by5cbiAgICAgKiBAcGFyYW0ge0FycmF5PX0gZXhjbHVkZSBMaXN0IG9mIGJlaGF2aW9ycyB0byBleGNsdWRlIGZyb20gdGhlIGxpc3QuXG4gICAgICogQHJldHVybiB7IUFycmF5fSBSZXR1cm5zIHRoZSBsaXN0IG9mIGZsYXR0ZW5lZCBiZWhhdmlvcnMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmxhdHRlbkJlaGF2aW9ycyhiZWhhdmlvcnMsIGxpc3QsIGV4Y2x1ZGUpIHtcbiAgICAgIGxpc3QgPSBsaXN0IHx8IFtdO1xuICAgICAgZm9yIChsZXQgaT1iZWhhdmlvcnMubGVuZ3RoLTE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGxldCBiID0gYmVoYXZpb3JzW2ldO1xuICAgICAgICBpZiAoYikge1xuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGIpKSB7XG4gICAgICAgICAgICBmbGF0dGVuQmVoYXZpb3JzKGIsIGxpc3QpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBkZWR1cFxuICAgICAgICAgICAgaWYgKGxpc3QuaW5kZXhPZihiKSA8IDAgJiYgKCFleGNsdWRlIHx8IGV4Y2x1ZGUuaW5kZXhPZihiKSA8IDApKSB7XG4gICAgICAgICAgICAgIGxpc3QudW5zaGlmdChiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKCdiZWhhdmlvciBpcyBudWxsLCBjaGVjayBmb3IgbWlzc2luZyBvciA0MDQgaW1wb3J0Jyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBsaXN0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IVBvbHltZXJJbml0fSBpbmZvIFBvbHltZXIgaW5mbyBvYmplY3RcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKG5ldzpIVE1MRWxlbWVudCl9IEJhc2UgYmFzZSBjbGFzcyB0byBleHRlbmQgd2l0aCBpbmZvIG9iamVjdFxuICAgICAqIEByZXR1cm4ge2Z1bmN0aW9uKG5ldzpIVE1MRWxlbWVudCl9IEdlbmVyYXRlZCBjbGFzc1xuICAgICAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlc31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEdlbmVyYXRlQ2xhc3NGcm9tSW5mbyhpbmZvLCBCYXNlKSB7XG5cbiAgICAgIGNsYXNzIFBvbHltZXJHZW5lcmF0ZWQgZXh0ZW5kcyBCYXNlIHtcblxuICAgICAgICBzdGF0aWMgZ2V0IHByb3BlcnRpZXMoKSB7XG4gICAgICAgICAgcmV0dXJuIGluZm8ucHJvcGVydGllcztcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRpYyBnZXQgb2JzZXJ2ZXJzKCkge1xuICAgICAgICAgIHJldHVybiBpbmZvLm9ic2VydmVycztcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHtIVE1MVGVtcGxhdGVFbGVtZW50fSB0ZW1wbGF0ZSBmb3IgdGhpcyBjbGFzc1xuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGdldCB0ZW1wbGF0ZSgpIHtcbiAgICAgICAgICAvLyBnZXQgdGVtcGxhdGUgZmlyc3QgZnJvbSBhbnkgaW1wZXJhdGl2ZSBzZXQgaW4gYGluZm8uX3RlbXBsYXRlYFxuICAgICAgICAgIHJldHVybiBpbmZvLl90ZW1wbGF0ZSB8fFxuICAgICAgICAgICAgLy8gbmV4dCBsb29rIGluIGRvbS1tb2R1bGUgYXNzb2NpYXRlZCB3aXRoIHRoaXMgZWxlbWVudCdzIGlzLlxuICAgICAgICAgICAgUG9seW1lci5Eb21Nb2R1bGUgJiYgUG9seW1lci5Eb21Nb2R1bGUuaW1wb3J0KHRoaXMuaXMsICd0ZW1wbGF0ZScpIHx8XG4gICAgICAgICAgICAvLyBuZXh0IGxvb2sgZm9yIHN1cGVyY2xhc3MgdGVtcGxhdGUgKG5vdGU6IHVzZSBzdXBlcmNsYXNzIHN5bWJvbFxuICAgICAgICAgICAgLy8gdG8gZW5zdXJlIGNvcnJlY3QgYHRoaXMuaXNgKVxuICAgICAgICAgICAgQmFzZS50ZW1wbGF0ZSB8fFxuICAgICAgICAgICAgLy8gZmluYWxseSBmYWxsIGJhY2sgdG8gYF90ZW1wbGF0ZWAgaW4gZWxlbWVudCdzIHByb3RveXBlLlxuICAgICAgICAgICAgdGhpcy5wcm90b3R5cGUuX3RlbXBsYXRlIHx8XG4gICAgICAgICAgICBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgY3JlYXRlZCgpIHtcbiAgICAgICAgICBzdXBlci5jcmVhdGVkKCk7XG4gICAgICAgICAgaWYgKGluZm8uY3JlYXRlZCkge1xuICAgICAgICAgICAgaW5mby5jcmVhdGVkLmNhbGwodGhpcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgX3JlZ2lzdGVyZWQoKSB7XG4gICAgICAgICAgc3VwZXIuX3JlZ2lzdGVyZWQoKTtcbiAgICAgICAgICAvKiBOT1RFOiBgYmVmb3JlUmVnaXN0ZXJgIGlzIGNhbGxlZCBoZXJlIGZvciBiYywgYnV0IHRoZSBiZWhhdmlvclxuICAgICAgICAgICBpcyBkaWZmZXJlbnQgdGhhbiBpbiAxLnguIEluIDEuMCwgdGhlIG1ldGhvZCB3YXMgY2FsbGVkICphZnRlcipcbiAgICAgICAgICAgbWl4aW5nIHByb3RvdHlwZXMgdG9nZXRoZXIgYnV0ICpiZWZvcmUqIHByb2Nlc3Npbmcgb2YgbWV0YS1vYmplY3RzLlxuICAgICAgICAgICBIb3dldmVyLCBkeW5hbWljIGVmZmVjdHMgY2FuIHN0aWxsIGJlIHNldCBoZXJlIGFuZCBjYW4gYmUgZG9uZSBlaXRoZXJcbiAgICAgICAgICAgaW4gYGJlZm9yZVJlZ2lzdGVyYCBvciBgcmVnaXN0ZXJlZGAuIEl0IGlzIG5vIGxvbmdlciBwb3NzaWJsZSB0byBzZXRcbiAgICAgICAgICAgYGlzYCBpbiBgYmVmb3JlUmVnaXN0ZXJgIGFzIHlvdSBjb3VsZCBpbiAxLnguXG4gICAgICAgICAgKi9cbiAgICAgICAgICBpZiAoaW5mby5iZWZvcmVSZWdpc3Rlcikge1xuICAgICAgICAgICAgaW5mby5iZWZvcmVSZWdpc3Rlci5jYWxsKE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpbmZvLnJlZ2lzdGVyZWQpIHtcbiAgICAgICAgICAgIGluZm8ucmVnaXN0ZXJlZC5jYWxsKE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgX2FwcGx5TGlzdGVuZXJzKCkge1xuICAgICAgICAgIHN1cGVyLl9hcHBseUxpc3RlbmVycygpO1xuICAgICAgICAgIGlmIChpbmZvLmxpc3RlbmVycykge1xuICAgICAgICAgICAgZm9yIChsZXQgbCBpbiBpbmZvLmxpc3RlbmVycykge1xuICAgICAgICAgICAgICB0aGlzLl9hZGRNZXRob2RFdmVudExpc3RlbmVyVG9Ob2RlKHRoaXMsIGwsIGluZm8ubGlzdGVuZXJzW2xdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBub3RlOiBleGNlcHRpb24gdG8gXCJzdXBlciB0aGVuIG1lXCIgcnVsZTtcbiAgICAgICAgLy8gZG8gd29yayBiZWZvcmUgY2FsbGluZyBzdXBlciBzbyB0aGF0IHN1cGVyIGF0dHJpYnV0ZXNcbiAgICAgICAgLy8gb25seSBhcHBseSBpZiBub3QgYWxyZWFkeSBzZXQuXG4gICAgICAgIF9lbnN1cmVBdHRyaWJ1dGVzKCkge1xuICAgICAgICAgIGlmIChpbmZvLmhvc3RBdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBhIGluIGluZm8uaG9zdEF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgICAgdGhpcy5fZW5zdXJlQXR0cmlidXRlKGEsIGluZm8uaG9zdEF0dHJpYnV0ZXNbYV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBzdXBlci5fZW5zdXJlQXR0cmlidXRlcygpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVhZHkoKSB7XG4gICAgICAgICAgc3VwZXIucmVhZHkoKTtcbiAgICAgICAgICBpZiAoaW5mby5yZWFkeSkge1xuICAgICAgICAgICAgaW5mby5yZWFkeS5jYWxsKHRoaXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGF0dGFjaGVkKCkge1xuICAgICAgICAgIHN1cGVyLmF0dGFjaGVkKCk7XG4gICAgICAgICAgaWYgKGluZm8uYXR0YWNoZWQpIHtcbiAgICAgICAgICAgIGluZm8uYXR0YWNoZWQuY2FsbCh0aGlzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBkZXRhY2hlZCgpIHtcbiAgICAgICAgICBzdXBlci5kZXRhY2hlZCgpO1xuICAgICAgICAgIGlmIChpbmZvLmRldGFjaGVkKSB7XG4gICAgICAgICAgICBpbmZvLmRldGFjaGVkLmNhbGwodGhpcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYXR0cmlidXRlQ2hhbmdlZChuYW1lLCBvbGQsIHZhbHVlKSB7XG4gICAgICAgICAgc3VwZXIuYXR0cmlidXRlQ2hhbmdlZChuYW1lLCBvbGQsIHZhbHVlKTtcbiAgICAgICAgICBpZiAoaW5mby5hdHRyaWJ1dGVDaGFuZ2VkKSB7XG4gICAgICAgICAgICBpbmZvLmF0dHJpYnV0ZUNoYW5nZWQuY2FsbCh0aGlzLCBuYW1lLCBvbGQsIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgfVxuICAgICAgfVxuXG4gICAgICBQb2x5bWVyR2VuZXJhdGVkLmdlbmVyYXRlZEZyb20gPSBpbmZvXG5cbiAgICAgIGZvciAobGV0IHAgaW4gaW5mbykge1xuICAgICAgICAvLyBOT1RFOiBjYW5ub3QgY29weSBgbWV0YVByb3BzYCBtZXRob2RzIG9udG8gcHJvdG90eXBlIGF0IGxlYXN0IGJlY2F1c2VcbiAgICAgICAgLy8gYHN1cGVyLnJlYWR5YCBtdXN0IGJlIGNhbGxlZCBhbmQgaXMgbm90IGluY2x1ZGVkIGluIHRoZSB1c2VyIGZuLlxuICAgICAgICBpZiAoIShwIGluIG1ldGFQcm9wcykpIHtcbiAgICAgICAgICBsZXQgcGQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGluZm8sIHApO1xuICAgICAgICAgIGlmIChwZCkge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFBvbHltZXJHZW5lcmF0ZWQucHJvdG90eXBlLCBwLCBwZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBQb2x5bWVyR2VuZXJhdGVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhIGNsYXNzIHRoYXQgZXh0ZW5kcyBgUG9seW1lci5MZWdhY3lFbGVtZW50YCBiYXNlZCBvbiB0aGVcbiAgICAgKiBwcm92aWRlZCBpbmZvIG9iamVjdC4gIE1ldGFkYXRhIG9iamVjdHMgb24gdGhlIGBpbmZvYCBvYmplY3RcbiAgICAgKiAoYHByb3BlcnRpZXNgLCBgb2JzZXJ2ZXJzYCwgYGxpc3RlbmVyc2AsIGBiZWhhdmlvcnNgLCBgaXNgKSBhcmUgdXNlZFxuICAgICAqIGZvciBQb2x5bWVyJ3MgbWV0YS1wcm9ncmFtbWluZyBzeXN0ZW1zLCBhbmQgYW55IGZ1bmN0aW9ucyBhcmUgY29waWVkXG4gICAgICogdG8gdGhlIGdlbmVyYXRlZCBjbGFzcy5cbiAgICAgKlxuICAgICAqIFZhbGlkIFwibWV0YWRhdGFcIiB2YWx1ZXMgYXJlIGFzIGZvbGxvd3M6XG4gICAgICpcbiAgICAgKiBgaXNgOiBTdHJpbmcgcHJvdmlkaW5nIHRoZSB0YWcgbmFtZSB0byByZWdpc3RlciB0aGUgZWxlbWVudCB1bmRlci4gSW5cbiAgICAgKiBhZGRpdGlvbiwgaWYgYSBgZG9tLW1vZHVsZWAgd2l0aCB0aGUgc2FtZSBpZCBleGlzdHMsIHRoZSBmaXJzdCB0ZW1wbGF0ZVxuICAgICAqIGluIHRoYXQgYGRvbS1tb2R1bGVgIHdpbGwgYmUgc3RhbXBlZCBpbnRvIHRoZSBzaGFkb3cgcm9vdCBvZiB0aGlzIGVsZW1lbnQsXG4gICAgICogd2l0aCBzdXBwb3J0IGZvciBkZWNsYXJhdGl2ZSBldmVudCBsaXN0ZW5lcnMgKGBvbi0uLi5gKSwgUG9seW1lciBkYXRhXG4gICAgICogYmluZGluZ3MgKGBbWy4uLl1dYCBhbmQgYHt7Li4ufX1gKSwgYW5kIGlkLWJhc2VkIG5vZGUgZmluZGluZyBpbnRvXG4gICAgICogYHRoaXMuJGAuXG4gICAgICpcbiAgICAgKiBgcHJvcGVydGllc2A6IE9iamVjdCBkZXNjcmliaW5nIHByb3BlcnR5LXJlbGF0ZWQgbWV0YWRhdGEgdXNlZCBieSBQb2x5bWVyXG4gICAgICogZmVhdHVyZXMgKGtleTogcHJvcGVydHkgbmFtZXMsIHZhbHVlOiBvYmplY3QgY29udGFpbmluZyBwcm9wZXJ0eSBtZXRhZGF0YSkuXG4gICAgICogVmFsaWQga2V5cyBpbiBwZXItcHJvcGVydHkgbWV0YWRhdGEgaW5jbHVkZTpcbiAgICAgKiAtIGB0eXBlYCAoU3RyaW5nfE51bWJlcnxPYmplY3R8QXJyYXl8Li4uKTogVXNlZCBieVxuICAgICAqICAgYGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFja2AgdG8gZGV0ZXJtaW5lIGhvdyBzdHJpbmctYmFzZWQgYXR0cmlidXRlc1xuICAgICAqICAgYXJlIGRlc2VyaWFsaXplZCB0byBKYXZhU2NyaXB0IHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKiAtIGBub3RpZnlgIChib29sZWFuKTogQ2F1c2VzIGEgY2hhbmdlIGluIHRoZSBwcm9wZXJ0eSB0byBmaXJlIGFcbiAgICAgKiAgIG5vbi1idWJibGluZyBldmVudCBjYWxsZWQgYDxwcm9wZXJ0eT4tY2hhbmdlZGAuIEVsZW1lbnRzIHRoYXQgaGF2ZVxuICAgICAqICAgZW5hYmxlZCB0d28td2F5IGJpbmRpbmcgdG8gdGhlIHByb3BlcnR5IHVzZSB0aGlzIGV2ZW50IHRvIG9ic2VydmUgY2hhbmdlcy5cbiAgICAgKiAtIGByZWFkT25seWAgKGJvb2xlYW4pOiBDcmVhdGVzIGEgZ2V0dGVyIGZvciB0aGUgcHJvcGVydHksIGJ1dCBubyBzZXR0ZXIuXG4gICAgICogICBUbyBzZXQgYSByZWFkLW9ubHkgcHJvcGVydHksIHVzZSB0aGUgcHJpdmF0ZSBzZXR0ZXIgbWV0aG9kXG4gICAgICogICBgX3NldFByb3BlcnR5KHByb3BlcnR5LCB2YWx1ZSlgLlxuICAgICAqIC0gYG9ic2VydmVyYCAoc3RyaW5nKTogT2JzZXJ2ZXIgbWV0aG9kIG5hbWUgdGhhdCB3aWxsIGJlIGNhbGxlZCB3aGVuXG4gICAgICogICB0aGUgcHJvcGVydHkgY2hhbmdlcy4gVGhlIGFyZ3VtZW50cyBvZiB0aGUgbWV0aG9kIGFyZVxuICAgICAqICAgYCh2YWx1ZSwgcHJldmlvdXNWYWx1ZSlgLlxuICAgICAqIC0gYGNvbXB1dGVkYCAoc3RyaW5nKTogU3RyaW5nIGRlc2NyaWJpbmcgbWV0aG9kIGFuZCBkZXBlbmRlbnQgcHJvcGVydGllc1xuICAgICAqICAgZm9yIGNvbXB1dGluZyB0aGUgdmFsdWUgb2YgdGhpcyBwcm9wZXJ0eSAoZS5nLiBgJ2NvbXB1dGVGb28oYmFyLCB6b3QpJ2ApLlxuICAgICAqICAgQ29tcHV0ZWQgcHJvcGVydGllcyBhcmUgcmVhZC1vbmx5IGJ5IGRlZmF1bHQgYW5kIGNhbiBvbmx5IGJlIGNoYW5nZWRcbiAgICAgKiAgIHZpYSB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBjb21wdXRpbmcgbWV0aG9kLlxuICAgICAqXG4gICAgICogYG9ic2VydmVyc2A6IEFycmF5IG9mIHN0cmluZ3MgZGVzY3JpYmluZyBtdWx0aS1wcm9wZXJ0eSBvYnNlcnZlciBtZXRob2RzXG4gICAgICogIGFuZCB0aGVpciBkZXBlbmRlbnQgcHJvcGVydGllcyAoZS5nLiBgJ29ic2VydmVBQkMoYSwgYiwgYyknYCkuXG4gICAgICpcbiAgICAgKiBgbGlzdGVuZXJzYDogT2JqZWN0IGRlc2NyaWJpbmcgZXZlbnQgbGlzdGVuZXJzIHRvIGJlIGFkZGVkIHRvIGVhY2hcbiAgICAgKiAgaW5zdGFuY2Ugb2YgdGhpcyBlbGVtZW50IChrZXk6IGV2ZW50IG5hbWUsIHZhbHVlOiBtZXRob2QgbmFtZSkuXG4gICAgICpcbiAgICAgKiBgYmVoYXZpb3JzYDogQXJyYXkgb2YgYWRkaXRpb25hbCBgaW5mb2Agb2JqZWN0cyBjb250YWluaW5nIG1ldGFkYXRhXG4gICAgICogYW5kIGNhbGxiYWNrcyBpbiB0aGUgc2FtZSBmb3JtYXQgYXMgdGhlIGBpbmZvYCBvYmplY3QgaGVyZSB3aGljaCBhcmVcbiAgICAgKiBtZXJnZWQgaW50byB0aGlzIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBgaG9zdEF0dHJpYnV0ZXNgOiBPYmplY3QgbGlzdGluZyBhdHRyaWJ1dGVzIHRvIGJlIGFwcGxpZWQgdG8gdGhlIGhvc3RcbiAgICAgKiAgb25jZSBjcmVhdGVkIChrZXk6IGF0dHJpYnV0ZSBuYW1lLCB2YWx1ZTogYXR0cmlidXRlIHZhbHVlKS4gIFZhbHVlc1xuICAgICAqICBhcmUgc2VyaWFsaXplZCBiYXNlZCBvbiB0aGUgdHlwZSBvZiB0aGUgdmFsdWUuICBIb3N0IGF0dHJpYnV0ZXMgc2hvdWxkXG4gICAgICogIGdlbmVyYWxseSBiZSBsaW1pdGVkIHRvIGF0dHJpYnV0ZXMgc3VjaCBhcyBgdGFiSW5kZXhgIGFuZCBgYXJpYS0uLi5gLlxuICAgICAqICBBdHRyaWJ1dGVzIGluIGBob3N0QXR0cmlidXRlc2AgYXJlIG9ubHkgYXBwbGllZCBpZiBhIHVzZXItc3VwcGxpZWRcbiAgICAgKiAgYXR0cmlidXRlIGlzIG5vdCBhbHJlYWR5IHByZXNlbnQgKGF0dHJpYnV0ZXMgaW4gbWFya3VwIG92ZXJyaWRlXG4gICAgICogIGBob3N0QXR0cmlidXRlc2ApLlxuICAgICAqXG4gICAgICogSW4gYWRkaXRpb24sIHRoZSBmb2xsb3dpbmcgUG9seW1lci1zcGVjaWZpYyBjYWxsYmFja3MgbWF5IGJlIHByb3ZpZGVkOlxuICAgICAqIC0gYHJlZ2lzdGVyZWRgOiBjYWxsZWQgYWZ0ZXIgZmlyc3QgaW5zdGFuY2Ugb2YgdGhpcyBlbGVtZW50LFxuICAgICAqIC0gYGNyZWF0ZWRgOiBjYWxsZWQgZHVyaW5nIGBjb25zdHJ1Y3RvcmBcbiAgICAgKiAtIGBhdHRhY2hlZGA6IGNhbGxlZCBkdXJpbmcgYGNvbm5lY3RlZENhbGxiYWNrYFxuICAgICAqIC0gYGRldGFjaGVkYDogY2FsbGVkIGR1cmluZyBgZGlzY29ubmVjdGVkQ2FsbGJhY2tgXG4gICAgICogLSBgcmVhZHlgOiBjYWxsZWQgYmVmb3JlIGZpcnN0IGBhdHRhY2hlZGAsIGFmdGVyIGFsbCBwcm9wZXJ0aWVzIG9mXG4gICAgICogICB0aGlzIGVsZW1lbnQgaGF2ZSBiZWVuIHByb3BhZ2F0ZWQgdG8gaXRzIHRlbXBsYXRlIGFuZCBhbGwgb2JzZXJ2ZXJzXG4gICAgICogICBoYXZlIHJ1blxuICAgICAqXG4gICAgICogQHBhcmFtIHshUG9seW1lckluaXR9IGluZm8gT2JqZWN0IGNvbnRhaW5pbmcgUG9seW1lciBtZXRhZGF0YSBhbmQgZnVuY3Rpb25zXG4gICAgICogICB0byBiZWNvbWUgY2xhc3MgbWV0aG9kcy5cbiAgICAgKiBAcmV0dXJuIHtmdW5jdGlvbihuZXc6SFRNTEVsZW1lbnQpfSBHZW5lcmF0ZWQgY2xhc3NcbiAgICAgKiBAbWVtYmVyb2YgUG9seW1lclxuICAgICAqL1xuICAgIFBvbHltZXIuQ2xhc3MgPSBmdW5jdGlvbihpbmZvKSB7XG4gICAgICBpZiAoIWluZm8pIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdQb2x5bWVyLkNsYXNzIHJlcXVpcmVzIGBpbmZvYCBhcmd1bWVudCcpO1xuICAgICAgfVxuICAgICAgbGV0IGtsYXNzID0gR2VuZXJhdGVDbGFzc0Zyb21JbmZvKGluZm8sIGluZm8uYmVoYXZpb3JzID9cbiAgICAgICAgLy8gbm90ZTogbWl4aW5CZWhhdmlvcnMgZW5zdXJlcyBgTGVnYWN5RWxlbWVudE1peGluYC5cbiAgICAgICAgbWl4aW5CZWhhdmlvcnMoaW5mby5iZWhhdmlvcnMsIEhUTUxFbGVtZW50KSA6XG4gICAgICAgIFBvbHltZXIuTGVnYWN5RWxlbWVudE1peGluKEhUTUxFbGVtZW50KSk7XG4gICAgICAvLyBkZWNvcmF0ZSBrbGFzcyB3aXRoIHJlZ2lzdHJhdGlvbiBpbmZvXG4gICAgICBrbGFzcy5pcyA9IGluZm8uaXM7XG4gICAgICByZXR1cm4ga2xhc3M7XG4gICAgfVxuXG4gICAgUG9seW1lci5taXhpbkJlaGF2aW9ycyA9IG1peGluQmVoYXZpb3JzO1xuXG4gIH0pKCk7XG5cbjwvc2NyaXB0PlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi9sZWdhY3kvY2xhc3MuaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cblxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3V0aWxzL3RlbXBsYXRpemUuaHRtbFwiPlxuXG48c2NyaXB0PlxuICAoZnVuY3Rpb24oKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgbGV0IFRlbXBsYXRlSW5zdGFuY2VCYXNlID0gUG9seW1lci5UZW1wbGF0ZUluc3RhbmNlQmFzZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYge3tcbiAgICAgKiAgIF90ZW1wbGF0aXplclRlbXBsYXRlOiBIVE1MVGVtcGxhdGVFbGVtZW50LFxuICAgICAqICAgX3BhcmVudE1vZGVsOiBib29sZWFuLFxuICAgICAqICAgX2luc3RhbmNlUHJvcHM6IE9iamVjdCxcbiAgICAgKiAgIF9mb3J3YXJkSG9zdFByb3BWMjogRnVuY3Rpb24sXG4gICAgICogICBfbm90aWZ5SW5zdGFuY2VQcm9wVjI6IEZ1bmN0aW9uLFxuICAgICAqICAgY3RvcjogVGVtcGxhdGVJbnN0YW5jZUJhc2VcbiAgICAgKiB9fVxuICAgICAqL1xuICAgIGxldCBUZW1wbGF0aXplclVzZXI7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICAgIC8qKlxuICAgICAqIFRoZSBgUG9seW1lci5UZW1wbGF0aXplcmAgYmVoYXZpb3IgYWRkcyBtZXRob2RzIHRvIGdlbmVyYXRlIGluc3RhbmNlcyBvZlxuICAgICAqIHRlbXBsYXRlcyB0aGF0IGFyZSBlYWNoIG1hbmFnZWQgYnkgYW4gYW5vbnltb3VzIGBQb2x5bWVyLlByb3BlcnR5RWZmZWN0c2BcbiAgICAgKiBpbnN0YW5jZSB3aGVyZSBkYXRhLWJpbmRpbmdzIGluIHRoZSBzdGFtcGVkIHRlbXBsYXRlIGNvbnRlbnQgYXJlIGJvdW5kIHRvXG4gICAgICogYWNjZXNzb3JzIG9uIGl0c2VsZi5cbiAgICAgKlxuICAgICAqIFRoaXMgYmVoYXZpb3IgaXMgcHJvdmlkZWQgaW4gUG9seW1lciAyLnggYXMgYSBoeWJyaWQtZWxlbWVudCBjb252ZW5pZW5jZVxuICAgICAqIG9ubHkuICBGb3Igbm9uLWh5YnJpZCB1c2FnZSwgdGhlIGBQb2x5bWVyLlRlbXBsYXRpemVgIGxpYnJhcnlcbiAgICAgKiBzaG91bGQgYmUgdXNlZCBpbnN0ZWFkLlxuICAgICAqXG4gICAgICogRXhhbXBsZTpcbiAgICAgKlxuICAgICAqICAgICAvLyBHZXQgYSB0ZW1wbGF0ZSBmcm9tIHNvbWV3aGVyZSwgZS5nLiBsaWdodCBET01cbiAgICAgKiAgICAgbGV0IHRlbXBsYXRlID0gdGhpcy5xdWVyeVNlbGVjdG9yKCd0ZW1wbGF0ZScpO1xuICAgICAqICAgICAvLyBQcmVwYXJlIHRoZSB0ZW1wbGF0ZVxuICAgICAqICAgICB0aGlzLnRlbXBsYXRpemUodGVtcGxhdGUpO1xuICAgICAqICAgICAvLyBJbnN0YW5jZSB0aGUgdGVtcGxhdGUgd2l0aCBhbiBpbml0aWFsIGRhdGEgbW9kZWxcbiAgICAgKiAgICAgbGV0IGluc3RhbmNlID0gdGhpcy5zdGFtcCh7bXlQcm9wOiAnaW5pdGlhbCd9KTtcbiAgICAgKiAgICAgLy8gSW5zZXJ0IHRoZSBpbnN0YW5jZSdzIERPTSBzb21ld2hlcmUsIGUuZy4gbGlnaHQgRE9NXG4gICAgICogICAgIFBvbHltZXIuZG9tKHRoaXMpLmFwcGVuZENoaWxkKGluc3RhbmNlLnJvb3QpO1xuICAgICAqICAgICAvLyBDaGFuZ2luZyBhIHByb3BlcnR5IG9uIHRoZSBpbnN0YW5jZSB3aWxsIHByb3BhZ2F0ZSB0byBiaW5kaW5nc1xuICAgICAqICAgICAvLyBpbiB0aGUgdGVtcGxhdGVcbiAgICAgKiAgICAgaW5zdGFuY2UubXlQcm9wID0gJ25ldyB2YWx1ZSc7XG4gICAgICpcbiAgICAgKiBVc2VycyBvZiBgVGVtcGxhdGl6ZXJgIG1heSBuZWVkIHRvIGltcGxlbWVudCB0aGUgZm9sbG93aW5nIGFic3RyYWN0XG4gICAgICogQVBJJ3MgdG8gZGV0ZXJtaW5lIGhvdyBwcm9wZXJ0aWVzIGFuZCBwYXRocyBmcm9tIHRoZSBob3N0IHNob3VsZCBiZVxuICAgICAqIGZvcndhcmRlZCBpbnRvIHRvIGluc3RhbmNlczpcbiAgICAgKlxuICAgICAqICAgICBfZm9yd2FyZEhvc3RQcm9wVjI6IGZ1bmN0aW9uKHByb3AsIHZhbHVlKVxuICAgICAqXG4gICAgICogTGlrZXdpc2UsIHVzZXJzIG1heSBpbXBsZW1lbnQgdGhlc2UgYWRkaXRpb25hbCBhYnN0cmFjdCBBUEkncyB0byBkZXRlcm1pbmVcbiAgICAgKiBob3cgaW5zdGFuY2Utc3BlY2lmaWMgcHJvcGVydGllcyB0aGF0IGNoYW5nZSBvbiB0aGUgaW5zdGFuY2Ugc2hvdWxkIGJlXG4gICAgICogZm9yd2FyZGVkIG91dCB0byB0aGUgaG9zdCwgaWYgbmVjZXNzYXJ5LlxuICAgICAqXG4gICAgICogICAgIF9ub3RpZnlJbnN0YW5jZVByb3BWMjogZnVuY3Rpb24oaW5zdCwgcHJvcCwgdmFsdWUpXG4gICAgICpcbiAgICAgKiBJbiBvcmRlciB0byBkZXRlcm1pbmUgd2hpY2ggcHJvcGVydGllcyBhcmUgaW5zdGFuY2Utc3BlY2lmaWMgYW5kIHJlcXVpcmVcbiAgICAgKiBjdXN0b20gbm90aWZpY2F0aW9uIHZpYSBgX25vdGlmeUluc3RhbmNlUHJvcGAsIGRlZmluZSBhbiBgX2luc3RhbmNlUHJvcHNgXG4gICAgICogb2JqZWN0IGNvbnRhaW5pbmcga2V5cyBmb3IgZWFjaCBpbnN0YW5jZSBwcm9wLCBmb3IgZXhhbXBsZTpcbiAgICAgKlxuICAgICAqICAgICBfaW5zdGFuY2VQcm9wczoge1xuICAgICAqICAgICAgIGl0ZW06IHRydWUsXG4gICAgICogICAgICAgaW5kZXg6IHRydWVcbiAgICAgKiAgICAgfVxuICAgICAqXG4gICAgICogQW55IHByb3BlcnRpZXMgdXNlZCBpbiB0aGUgdGVtcGxhdGUgdGhhdCBhcmUgbm90IGRlZmluZWQgaW4gX2luc3RhbmNlUHJvcFxuICAgICAqIHdpbGwgYmUgZm9yd2FyZGVkIG91dCB0byB0aGUgVGVtcGxhdGl6ZSBgb3duZXJgIGF1dG9tYXRpY2FsbHkuXG4gICAgICpcbiAgICAgKiBVc2VycyBtYXkgYWxzbyBpbXBsZW1lbnQgdGhlIGZvbGxvd2luZyBhYnN0cmFjdCBmdW5jdGlvbiB0byBzaG93IG9yXG4gICAgICogaGlkZSBhbnkgRE9NIGdlbmVyYXRlZCB1c2luZyBgc3RhbXBgOlxuICAgICAqXG4gICAgICogICAgIF9zaG93SGlkZUNoaWxkcmVuOiBmdW5jdGlvbihzaG91bGRIaWRlKVxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IHNvbWUgY2FsbGJhY2tzIGFyZSBzdWZmaXhlZCB3aXRoIGBWMmAgaW4gdGhlIFBvbHltZXIgMi54IGJlaGF2aW9yXG4gICAgICogYXMgdGhlIGltcGxlbWVudGF0aW9ucyB3aWxsIG5lZWQgdG8gZGlmZmVyIGZyb20gdGhlIGNhbGxiYWNrcyByZXF1aXJlZFxuICAgICAqIGJ5IHRoZSAxLnggVGVtcGxhdGl6ZXIgQVBJIGR1ZSB0byBjaGFuZ2VzIGluIHRoZSBgVGVtcGxhdGVJbnN0YW5jZWAgQVBJXG4gICAgICogYmV0d2VlbiB2ZXJzaW9ucyAxLnggYW5kIDIueC5cbiAgICAgKlxuICAgICAqIEBwb2x5bWVyQmVoYXZpb3JcbiAgICAgKiBAbWVtYmVyb2YgUG9seW1lclxuICAgICAqL1xuICAgIGxldCBUZW1wbGF0aXplciA9IHtcblxuICAgICAgLyoqXG4gICAgICAgKiBHZW5lcmF0ZXMgYW4gYW5vbnltb3VzIGBUZW1wbGF0ZUluc3RhbmNlYCBjbGFzcyAoc3RvcmVkIGFzIGB0aGlzLmN0b3JgKVxuICAgICAgICogZm9yIHRoZSBwcm92aWRlZCB0ZW1wbGF0ZS4gIFRoaXMgbWV0aG9kIHNob3VsZCBiZSBjYWxsZWQgb25jZSBwZXJcbiAgICAgICAqIHRlbXBsYXRlIHRvIHByZXBhcmUgYW4gZWxlbWVudCBmb3Igc3RhbXBpbmcgdGhlIHRlbXBsYXRlLCBmb2xsb3dlZFxuICAgICAgICogYnkgYHN0YW1wYCB0byBjcmVhdGUgbmV3IGluc3RhbmNlcyBvZiB0aGUgdGVtcGxhdGUuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtIVE1MVGVtcGxhdGVFbGVtZW50fSB0ZW1wbGF0ZSBUZW1wbGF0ZSB0byBwcmVwYXJlXG4gICAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBtdXRhYmxlRGF0YSBXaGVuIGB0cnVlYCwgdGhlIGdlbmVyYXRlZCBjbGFzcyB3aWxsIHNraXBcbiAgICAgICAqICAgc3RyaWN0IGRpcnR5LWNoZWNraW5nIGZvciBvYmplY3RzIGFuZCBhcnJheXMgKGFsd2F5cyBjb25zaWRlciB0aGVtIHRvXG4gICAgICAgKiAgIGJlIFwiZGlydHlcIikuIERlZmF1bHRzIHRvIGZhbHNlLlxuICAgICAgICogQHRoaXMge1RlbXBsYXRpemVyVXNlcn1cbiAgICAgICAqL1xuICAgICAgdGVtcGxhdGl6ZSh0ZW1wbGF0ZSwgbXV0YWJsZURhdGEpIHtcbiAgICAgICAgdGhpcy5fdGVtcGxhdGl6ZXJUZW1wbGF0ZSA9IHRlbXBsYXRlO1xuICAgICAgICB0aGlzLmN0b3IgPSBQb2x5bWVyLlRlbXBsYXRpemUudGVtcGxhdGl6ZSh0ZW1wbGF0ZSwgdGhpcywge1xuICAgICAgICAgIG11dGFibGVEYXRhOiBCb29sZWFuKG11dGFibGVEYXRhKSxcbiAgICAgICAgICBwYXJlbnRNb2RlbDogdGhpcy5fcGFyZW50TW9kZWwsXG4gICAgICAgICAgaW5zdGFuY2VQcm9wczogdGhpcy5faW5zdGFuY2VQcm9wcyxcbiAgICAgICAgICBmb3J3YXJkSG9zdFByb3A6IHRoaXMuX2ZvcndhcmRIb3N0UHJvcFYyLFxuICAgICAgICAgIG5vdGlmeUluc3RhbmNlUHJvcDogdGhpcy5fbm90aWZ5SW5zdGFuY2VQcm9wVjJcbiAgICAgICAgfSk7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhlIHRlbXBsYXRlIHByZXBhcmVkIGJ5IGB0ZW1wbGF0aXplYC4gIFRoZSBvYmplY3RcbiAgICAgICAqIHJldHVybmVkIGlzIGFuIGluc3RhbmNlIG9mIHRoZSBhbm9ueW1vdXMgY2xhc3MgZ2VuZXJhdGVkIGJ5IGB0ZW1wbGF0aXplYFxuICAgICAgICogd2hvc2UgYHJvb3RgIHByb3BlcnR5IGlzIGEgZG9jdW1lbnQgZnJhZ21lbnQgY29udGFpbmluZyBuZXdseSBjbG9uZWRcbiAgICAgICAqIHRlbXBsYXRlIGNvbnRlbnQsIGFuZCB3aGljaCBoYXMgcHJvcGVydHkgYWNjZXNzb3JzIGNvcnJlc3BvbmRpbmcgdG9cbiAgICAgICAqIHByb3BlcnRpZXMgcmVmZXJlbmNlZCBpbiB0ZW1wbGF0ZSBiaW5kaW5ncy5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge09iamVjdD19IG1vZGVsIE9iamVjdCBjb250YWluaW5nIGluaXRpYWwgcHJvcGVydHkgdmFsdWVzIHRvXG4gICAgICAgKiAgIHBvcHVsYXRlIGludG8gdGhlIHRlbXBsYXRlIGJpbmRpbmdzLlxuICAgICAgICogQHJldHVybiB7VGVtcGxhdGVJbnN0YW5jZUJhc2V9IFJldHVybnMgdGhlIGNyZWF0ZWQgaW5zdGFuY2Ugb2ZcbiAgICAgICAqIHRoZSB0ZW1wbGF0ZSBwcmVwYXJlZCBieSBgdGVtcGxhdGl6ZWAuXG4gICAgICAgKiBAdGhpcyB7VGVtcGxhdGl6ZXJVc2VyfVxuICAgICAgICovXG4gICAgICBzdGFtcChtb2RlbCkge1xuICAgICAgICByZXR1cm4gbmV3IHRoaXMuY3Rvcihtb2RlbCk7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFJldHVybnMgdGhlIHRlbXBsYXRlIFwibW9kZWxcIiAoYFRlbXBsYXRlSW5zdGFuY2VgKSBhc3NvY2lhdGVkIHdpdGhcbiAgICAgICAqIGEgZ2l2ZW4gZWxlbWVudCwgd2hpY2ggc2VydmVzIGFzIHRoZSBiaW5kaW5nIHNjb3BlIGZvciB0aGUgdGVtcGxhdGVcbiAgICAgICAqIGluc3RhbmNlIHRoZSBlbGVtZW50IGlzIGNvbnRhaW5lZCBpbi4gIEEgdGVtcGxhdGUgbW9kZWwgc2hvdWxkIGJlIHVzZWRcbiAgICAgICAqIHRvIG1hbmlwdWxhdGUgZGF0YSBhc3NvY2lhdGVkIHdpdGggdGhpcyB0ZW1wbGF0ZSBpbnN0YW5jZS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCBFbGVtZW50IGZvciB3aGljaCB0byByZXR1cm4gYSB0ZW1wbGF0ZSBtb2RlbC5cbiAgICAgICAqIEByZXR1cm4ge1RlbXBsYXRlSW5zdGFuY2VCYXNlfSBNb2RlbCByZXByZXNlbnRpbmcgdGhlIGJpbmRpbmcgc2NvcGUgZm9yXG4gICAgICAgKiAgIHRoZSBlbGVtZW50LlxuICAgICAgICogQHRoaXMge1RlbXBsYXRpemVyVXNlcn1cbiAgICAgICAqL1xuICAgICAgbW9kZWxGb3JFbGVtZW50KGVsKSB7XG4gICAgICAgIHJldHVybiBQb2x5bWVyLlRlbXBsYXRpemUubW9kZWxGb3JFbGVtZW50KHRoaXMuX3RlbXBsYXRpemVyVGVtcGxhdGUsIGVsKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgUG9seW1lci5UZW1wbGF0aXplciA9IFRlbXBsYXRpemVyO1xuXG4gIH0pKCk7XG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvbGVnYWN5L3RlbXBsYXRpemVyLWJlaGF2aW9yLmh0bWwiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi91dGlscy9ib290Lmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi9taXhpbnMvcHJvcGVydHktZWZmZWN0cy5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vbWl4aW5zL211dGFibGUtZGF0YS5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vbWl4aW5zL2dlc3R1cmUtZXZlbnQtbGlzdGVuZXJzLmh0bWxcIj5cblxuPHNjcmlwdD5cblxuICAoZnVuY3Rpb24oKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQGV4dGVuZHMge0hUTUxFbGVtZW50fVxuICAgICAqIEBpbXBsZW1lbnRzIHtQb2x5bWVyX1Byb3BlcnR5RWZmZWN0c31cbiAgICAgKiBAaW1wbGVtZW50cyB7UG9seW1lcl9PcHRpb25hbE11dGFibGVEYXRhfVxuICAgICAqIEBpbXBsZW1lbnRzIHtQb2x5bWVyX0dlc3R1cmVFdmVudExpc3RlbmVyc31cbiAgICAgKi9cbiAgICBjb25zdCBkb21CaW5kQmFzZSA9XG4gICAgICBQb2x5bWVyLkdlc3R1cmVFdmVudExpc3RlbmVycyhcbiAgICAgICAgUG9seW1lci5PcHRpb25hbE11dGFibGVEYXRhKFxuICAgICAgICAgIFBvbHltZXIuUHJvcGVydHlFZmZlY3RzKEhUTUxFbGVtZW50KSkpO1xuXG4gICAgLyoqXG4gICAgICogQ3VzdG9tIGVsZW1lbnQgdG8gYWxsb3cgdXNpbmcgUG9seW1lcidzIHRlbXBsYXRlIGZlYXR1cmVzIChkYXRhIGJpbmRpbmcsXG4gICAgICogZGVjbGFyYXRpdmUgZXZlbnQgbGlzdGVuZXJzLCBldGMuKSBpbiB0aGUgbWFpbiBkb2N1bWVudCB3aXRob3V0IGRlZmluaW5nXG4gICAgICogYSBuZXcgY3VzdG9tIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBgPHRlbXBsYXRlPmAgdGFncyB1dGlsaXppbmcgYmluZGluZ3MgbWF5IGJlIHdyYXBwZWQgd2l0aCB0aGUgYDxkb20tYmluZD5gXG4gICAgICogZWxlbWVudCwgd2hpY2ggd2lsbCBpbW1lZGlhdGVseSBzdGFtcCB0aGUgd3JhcHBlZCB0ZW1wbGF0ZSBpbnRvIHRoZSBtYWluXG4gICAgICogZG9jdW1lbnQgYW5kIGJpbmQgZWxlbWVudHMgdG8gdGhlIGBkb20tYmluZGAgZWxlbWVudCBpdHNlbGYgYXMgdGhlXG4gICAgICogYmluZGluZyBzY29wZS5cbiAgICAgKlxuICAgICAqIEBwb2x5bWVyXG4gICAgICogQGN1c3RvbUVsZW1lbnRcbiAgICAgKiBAYXBwbGllc01peGluIFBvbHltZXIuUHJvcGVydHlFZmZlY3RzXG4gICAgICogQGFwcGxpZXNNaXhpbiBQb2x5bWVyLk9wdGlvbmFsTXV0YWJsZURhdGFcbiAgICAgKiBAYXBwbGllc01peGluIFBvbHltZXIuR2VzdHVyZUV2ZW50TGlzdGVuZXJzXG4gICAgICogQGV4dGVuZHMge2RvbUJpbmRCYXNlfVxuICAgICAqIEBtZW1iZXJvZiBQb2x5bWVyXG4gICAgICogQHN1bW1hcnkgQ3VzdG9tIGVsZW1lbnQgdG8gYWxsb3cgdXNpbmcgUG9seW1lcidzIHRlbXBsYXRlIGZlYXR1cmVzIChkYXRhXG4gICAgICogICBiaW5kaW5nLCBkZWNsYXJhdGl2ZSBldmVudCBsaXN0ZW5lcnMsIGV0Yy4pIGluIHRoZSBtYWluIGRvY3VtZW50LlxuICAgICAqL1xuICAgIGNsYXNzIERvbUJpbmQgZXh0ZW5kcyBkb21CaW5kQmFzZSB7XG5cbiAgICAgIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkgeyByZXR1cm4gWydtdXRhYmxlLWRhdGEnXSB9XG5cbiAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnJvb3QgPSBudWxsO1xuICAgICAgICB0aGlzLiQgPSBudWxsO1xuICAgICAgICB0aGlzLl9fY2hpbGRyZW4gPSBudWxsO1xuICAgICAgfVxuXG4gICAgICAvLyBhc3N1bWVzIG9ubHkgb25lIG9ic2VydmVkIGF0dHJpYnV0ZVxuICAgICAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKCkge1xuICAgICAgICB0aGlzLm11dGFibGVEYXRhID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgICB9XG5cbiAgICAgIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgICAgICB0aGlzLl9fcmVtb3ZlQ2hpbGRyZW4oKTtcbiAgICAgIH1cblxuICAgICAgX19pbnNlcnRDaGlsZHJlbigpIHtcbiAgICAgICAgdGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzLnJvb3QsIHRoaXMpO1xuICAgICAgfVxuXG4gICAgICBfX3JlbW92ZUNoaWxkcmVuKCkge1xuICAgICAgICBpZiAodGhpcy5fX2NoaWxkcmVuKSB7XG4gICAgICAgICAgZm9yIChsZXQgaT0wOyBpPHRoaXMuX19jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5yb290LmFwcGVuZENoaWxkKHRoaXMuX19jaGlsZHJlbltpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogRm9yY2VzIHRoZSBlbGVtZW50IHRvIHJlbmRlciBpdHMgY29udGVudC4gVGhpcyBpcyB0eXBpY2FsbHkgb25seVxuICAgICAgICogbmVjZXNzYXJ5IHRvIGNhbGwgaWYgSFRNTEltcG9ydHMgd2l0aCB0aGUgYXN5bmMgYXR0cmlidXRlIGFyZSB1c2VkLlxuICAgICAgICovXG4gICAgICByZW5kZXIoKSB7XG4gICAgICAgIGxldCB0ZW1wbGF0ZTtcbiAgICAgICAgaWYgKCF0aGlzLl9fY2hpbGRyZW4pIHtcbiAgICAgICAgICB0ZW1wbGF0ZSA9IC8qKiBAdHlwZSB7SFRNTFRlbXBsYXRlRWxlbWVudH0gKi8odGVtcGxhdGUgfHwgdGhpcy5xdWVyeVNlbGVjdG9yKCd0ZW1wbGF0ZScpKTtcbiAgICAgICAgICBpZiAoIXRlbXBsYXRlKSB7XG4gICAgICAgICAgICAvLyBXYWl0IHVudGlsIGNoaWxkTGlzdCBjaGFuZ2VzIGFuZCB0ZW1wbGF0ZSBzaG91bGQgYmUgdGhlcmUgYnkgdGhlblxuICAgICAgICAgICAgbGV0IG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoKCkgPT4ge1xuICAgICAgICAgICAgICB0ZW1wbGF0ZSA9IC8qKiBAdHlwZSB7SFRNTFRlbXBsYXRlRWxlbWVudH0gKi8odGhpcy5xdWVyeVNlbGVjdG9yKCd0ZW1wbGF0ZScpKTtcbiAgICAgICAgICAgICAgaWYgKHRlbXBsYXRlKSB7XG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkb20tYmluZCByZXF1aXJlcyBhIDx0ZW1wbGF0ZT4gY2hpbGQnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIG9ic2VydmVyLm9ic2VydmUodGhpcywge2NoaWxkTGlzdDogdHJ1ZX0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnJvb3QgPSB0aGlzLl9zdGFtcFRlbXBsYXRlKHRlbXBsYXRlKTtcbiAgICAgICAgICB0aGlzLiQgPSB0aGlzLnJvb3QuJDtcbiAgICAgICAgICB0aGlzLl9fY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgICBmb3IgKGxldCBuPXRoaXMucm9vdC5maXJzdENoaWxkOyBuOyBuPW4ubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuX19jaGlsZHJlblt0aGlzLl9fY2hpbGRyZW4ubGVuZ3RoXSA9IG47XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX2VuYWJsZVByb3BlcnRpZXMoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9faW5zZXJ0Q2hpbGRyZW4oKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnZG9tLWNoYW5nZScsIHtcbiAgICAgICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgICAgIGNvbXBvc2VkOiB0cnVlXG4gICAgICAgIH0pKTtcbiAgICAgIH1cblxuICAgIH1cblxuICAgIGN1c3RvbUVsZW1lbnRzLmRlZmluZSgnZG9tLWJpbmQnLCBEb21CaW5kKTtcblxuICB9KSgpO1xuXG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvZWxlbWVudHMvZG9tLWJpbmQuaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cblxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uLy4uL3BvbHltZXItZWxlbWVudC5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vdXRpbHMvdGVtcGxhdGl6ZS5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vdXRpbHMvZGVib3VuY2UuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3V0aWxzL2ZsdXNoLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi9taXhpbnMvbXV0YWJsZS1kYXRhLmh0bWxcIj5cblxuPHNjcmlwdD5cbihmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIGxldCBUZW1wbGF0ZUluc3RhbmNlQmFzZSA9IFBvbHltZXIuVGVtcGxhdGVJbnN0YW5jZUJhc2U7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBpbXBsZW1lbnRzIHtQb2x5bWVyX09wdGlvbmFsTXV0YWJsZURhdGF9XG4gICAqIEBleHRlbmRzIHtQb2x5bWVyLkVsZW1lbnR9XG4gICAqL1xuICBjb25zdCBkb21SZXBlYXRCYXNlID0gUG9seW1lci5PcHRpb25hbE11dGFibGVEYXRhKFBvbHltZXIuRWxlbWVudCk7XG5cbiAgLyoqXG4gICAqIFRoZSBgPGRvbS1yZXBlYXQ+YCBlbGVtZW50IHdpbGwgYXV0b21hdGljYWxseSBzdGFtcCBhbmQgYmluZHMgb25lIGluc3RhbmNlXG4gICAqIG9mIHRlbXBsYXRlIGNvbnRlbnQgdG8gZWFjaCBvYmplY3QgaW4gYSB1c2VyLXByb3ZpZGVkIGFycmF5LlxuICAgKiBgZG9tLXJlcGVhdGAgYWNjZXB0cyBhbiBgaXRlbXNgIHByb3BlcnR5LCBhbmQgb25lIGluc3RhbmNlIG9mIHRoZSB0ZW1wbGF0ZVxuICAgKiBpcyBzdGFtcGVkIGZvciBlYWNoIGl0ZW0gaW50byB0aGUgRE9NIGF0IHRoZSBsb2NhdGlvbiBvZiB0aGUgYGRvbS1yZXBlYXRgXG4gICAqIGVsZW1lbnQuICBUaGUgYGl0ZW1gIHByb3BlcnR5IHdpbGwgYmUgc2V0IG9uIGVhY2ggaW5zdGFuY2UncyBiaW5kaW5nXG4gICAqIHNjb3BlLCB0aHVzIHRlbXBsYXRlcyBzaG91bGQgYmluZCB0byBzdWItcHJvcGVydGllcyBvZiBgaXRlbWAuXG4gICAqXG4gICAqIEV4YW1wbGU6XG4gICAqXG4gICAqIGBgYGh0bWxcbiAgICogPGRvbS1tb2R1bGUgaWQ9XCJlbXBsb3llZS1saXN0XCI+XG4gICAqXG4gICAqICAgPHRlbXBsYXRlPlxuICAgKlxuICAgKiAgICAgPGRpdj4gRW1wbG95ZWUgbGlzdDogPC9kaXY+XG4gICAqICAgICA8dGVtcGxhdGUgaXM9XCJkb20tcmVwZWF0XCIgaXRlbXM9XCJ7e2VtcGxveWVlc319XCI+XG4gICAqICAgICAgICAgPGRpdj5GaXJzdCBuYW1lOiA8c3Bhbj57e2l0ZW0uZmlyc3R9fTwvc3Bhbj48L2Rpdj5cbiAgICogICAgICAgICA8ZGl2Pkxhc3QgbmFtZTogPHNwYW4+e3tpdGVtLmxhc3R9fTwvc3Bhbj48L2Rpdj5cbiAgICogICAgIDwvdGVtcGxhdGU+XG4gICAqXG4gICAqICAgPC90ZW1wbGF0ZT5cbiAgICpcbiAgICogICA8c2NyaXB0PlxuICAgKiAgICAgUG9seW1lcih7XG4gICAqICAgICAgIGlzOiAnZW1wbG95ZWUtbGlzdCcsXG4gICAqICAgICAgIHJlYWR5OiBmdW5jdGlvbigpIHtcbiAgICogICAgICAgICB0aGlzLmVtcGxveWVlcyA9IFtcbiAgICogICAgICAgICAgICAge2ZpcnN0OiAnQm9iJywgbGFzdDogJ1NtaXRoJ30sXG4gICAqICAgICAgICAgICAgIHtmaXJzdDogJ1NhbGx5JywgbGFzdDogJ0pvaG5zb24nfSxcbiAgICogICAgICAgICAgICAgLi4uXG4gICAqICAgICAgICAgXTtcbiAgICogICAgICAgfVxuICAgKiAgICAgfSk7XG4gICAqICAgPCAvc2NyaXB0PlxuICAgKlxuICAgKiA8L2RvbS1tb2R1bGU+XG4gICAqIGBgYFxuICAgKlxuICAgKiBOb3RpZmljYXRpb25zIGZvciBjaGFuZ2VzIHRvIGl0ZW1zIHN1Yi1wcm9wZXJ0aWVzIHdpbGwgYmUgZm9yd2FyZGVkIHRvIHRlbXBsYXRlXG4gICAqIGluc3RhbmNlcywgd2hpY2ggd2lsbCB1cGRhdGUgdmlhIHRoZSBub3JtYWwgc3RydWN0dXJlZCBkYXRhIG5vdGlmaWNhdGlvbiBzeXN0ZW0uXG4gICAqXG4gICAqIE11dGF0aW9ucyB0byB0aGUgYGl0ZW1zYCBhcnJheSBpdHNlbGYgc2hvdWxkIGJlIG1hZGUgdXNpbmcgdGhlIEFycmF5XG4gICAqIG11dGF0aW9uIEFQSSdzIG9uIGBQb2x5bWVyLkJhc2VgIChgcHVzaGAsIGBwb3BgLCBgc3BsaWNlYCwgYHNoaWZ0YCxcbiAgICogYHVuc2hpZnRgKSwgYW5kIHRlbXBsYXRlIGluc3RhbmNlcyB3aWxsIGJlIGtlcHQgaW4gc3luYyB3aXRoIHRoZSBkYXRhIGluIHRoZVxuICAgKiBhcnJheS5cbiAgICpcbiAgICogRXZlbnRzIGNhdWdodCBieSBldmVudCBoYW5kbGVycyB3aXRoaW4gdGhlIGBkb20tcmVwZWF0YCB0ZW1wbGF0ZSB3aWxsIGJlXG4gICAqIGRlY29yYXRlZCB3aXRoIGEgYG1vZGVsYCBwcm9wZXJ0eSwgd2hpY2ggcmVwcmVzZW50cyB0aGUgYmluZGluZyBzY29wZSBmb3JcbiAgICogZWFjaCB0ZW1wbGF0ZSBpbnN0YW5jZS4gIFRoZSBtb2RlbCBpcyBhbiBpbnN0YW5jZSBvZiBQb2x5bWVyLkJhc2UsIGFuZCBzaG91bGRcbiAgICogYmUgdXNlZCB0byBtYW5pcHVsYXRlIGRhdGEgb24gdGhlIGluc3RhbmNlLCBmb3IgZXhhbXBsZVxuICAgKiBgZXZlbnQubW9kZWwuc2V0KCdpdGVtLmNoZWNrZWQnLCB0cnVlKTtgLlxuICAgKlxuICAgKiBBbHRlcm5hdGl2ZWx5LCB0aGUgbW9kZWwgZm9yIGEgdGVtcGxhdGUgaW5zdGFuY2UgZm9yIGFuIGVsZW1lbnQgc3RhbXBlZCBieVxuICAgKiBhIGBkb20tcmVwZWF0YCBjYW4gYmUgb2J0YWluZWQgdXNpbmcgdGhlIGBtb2RlbEZvckVsZW1lbnRgIEFQSSBvbiB0aGVcbiAgICogYGRvbS1yZXBlYXRgIHRoYXQgc3RhbXBlZCBpdCwgZm9yIGV4YW1wbGVcbiAgICogYHRoaXMuJC5kb21SZXBlYXQubW9kZWxGb3JFbGVtZW50KGV2ZW50LnRhcmdldCkuc2V0KCdpdGVtLmNoZWNrZWQnLCB0cnVlKTtgLlxuICAgKiBUaGlzIG1heSBiZSB1c2VmdWwgZm9yIG1hbmlwdWxhdGluZyBpbnN0YW5jZSBkYXRhIG9mIGV2ZW50IHRhcmdldHMgb2J0YWluZWRcbiAgICogYnkgZXZlbnQgaGFuZGxlcnMgb24gcGFyZW50cyBvZiB0aGUgYGRvbS1yZXBlYXRgIChldmVudCBkZWxlZ2F0aW9uKS5cbiAgICpcbiAgICogQSB2aWV3LXNwZWNpZmljIGZpbHRlci9zb3J0IG1heSBiZSBhcHBsaWVkIHRvIGVhY2ggYGRvbS1yZXBlYXRgIGJ5IHN1cHBseWluZyBhXG4gICAqIGBmaWx0ZXJgIGFuZC9vciBgc29ydGAgcHJvcGVydHkuICBUaGlzIG1heSBiZSBhIHN0cmluZyB0aGF0IG5hbWVzIGEgZnVuY3Rpb24gb25cbiAgICogdGhlIGhvc3QsIG9yIGEgZnVuY3Rpb24gbWF5IGJlIGFzc2lnbmVkIHRvIHRoZSBwcm9wZXJ0eSBkaXJlY3RseS4gIFRoZSBmdW5jdGlvbnNcbiAgICogc2hvdWxkIGltcGxlbWVudGVkIGZvbGxvd2luZyB0aGUgc3RhbmRhcmQgYEFycmF5YCBmaWx0ZXIvc29ydCBBUEkuXG4gICAqXG4gICAqIEluIG9yZGVyIHRvIHJlLXJ1biB0aGUgZmlsdGVyIG9yIHNvcnQgZnVuY3Rpb25zIGJhc2VkIG9uIGNoYW5nZXMgdG8gc3ViLWZpZWxkc1xuICAgKiBvZiBgaXRlbXNgLCB0aGUgYG9ic2VydmVgIHByb3BlcnR5IG1heSBiZSBzZXQgYXMgYSBzcGFjZS1zZXBhcmF0ZWQgbGlzdCBvZlxuICAgKiBgaXRlbWAgc3ViLWZpZWxkcyB0aGF0IHNob3VsZCBjYXVzZSBhIHJlLWZpbHRlci9zb3J0IHdoZW4gbW9kaWZpZWQuICBJZlxuICAgKiB0aGUgZmlsdGVyIG9yIHNvcnQgZnVuY3Rpb24gZGVwZW5kcyBvbiBwcm9wZXJ0aWVzIG5vdCBjb250YWluZWQgaW4gYGl0ZW1zYCxcbiAgICogdGhlIHVzZXIgc2hvdWxkIG9ic2VydmUgY2hhbmdlcyB0byB0aG9zZSBwcm9wZXJ0aWVzIGFuZCBjYWxsIGByZW5kZXJgIHRvIHVwZGF0ZVxuICAgKiB0aGUgdmlldyBiYXNlZCBvbiB0aGUgZGVwZW5kZW5jeSBjaGFuZ2UuXG4gICAqXG4gICAqIEZvciBleGFtcGxlLCBmb3IgYW4gYGRvbS1yZXBlYXRgIHdpdGggYSBmaWx0ZXIgb2YgdGhlIGZvbGxvd2luZzpcbiAgICpcbiAgICogYGBganNcbiAgICogaXNFbmdpbmVlcjogZnVuY3Rpb24oaXRlbSkge1xuICAgKiAgICAgcmV0dXJuIGl0ZW0udHlwZSA9PSAnZW5naW5lZXInIHx8IGl0ZW0ubWFuYWdlci50eXBlID09ICdlbmdpbmVlcic7XG4gICAqIH1cbiAgICogYGBgXG4gICAqXG4gICAqIFRoZW4gdGhlIGBvYnNlcnZlYCBwcm9wZXJ0eSBzaG91bGQgYmUgY29uZmlndXJlZCBhcyBmb2xsb3dzOlxuICAgKlxuICAgKiBgYGBodG1sXG4gICAqIDx0ZW1wbGF0ZSBpcz1cImRvbS1yZXBlYXRcIiBpdGVtcz1cInt7ZW1wbG95ZWVzfX1cIlxuICAgKiAgICAgICAgICAgZmlsdGVyPVwiaXNFbmdpbmVlclwiIG9ic2VydmU9XCJ0eXBlIG1hbmFnZXIudHlwZVwiPlxuICAgKiBgYGBcbiAgICpcbiAgICogQGN1c3RvbUVsZW1lbnRcbiAgICogQHBvbHltZXJcbiAgICogQG1lbWJlcm9mIFBvbHltZXJcbiAgICogQGV4dGVuZHMge2RvbVJlcGVhdEJhc2V9XG4gICAqIEBhcHBsaWVzTWl4aW4gUG9seW1lci5PcHRpb25hbE11dGFibGVEYXRhXG4gICAqIEBzdW1tYXJ5IEN1c3RvbSBlbGVtZW50IGZvciBzdGFtcGluZyBpbnN0YW5jZSBvZiBhIHRlbXBsYXRlIGJvdW5kIHRvXG4gICAqICAgaXRlbXMgaW4gYW4gYXJyYXkuXG4gICAqL1xuICBjbGFzcyBEb21SZXBlYXQgZXh0ZW5kcyBkb21SZXBlYXRCYXNlIHtcblxuICAgIC8vIE5vdCBuZWVkZWQgdG8gZmluZCB0ZW1wbGF0ZTsgY2FuIGJlIHJlbW92ZWQgb25jZSB0aGUgYW5hbHl6ZXJcbiAgICAvLyBjYW4gZmluZCB0aGUgdGFnIG5hbWUgZnJvbSBjdXN0b21FbGVtZW50cy5kZWZpbmUgY2FsbFxuICAgIHN0YXRpYyBnZXQgaXMoKSB7IHJldHVybiAnZG9tLXJlcGVhdCc7IH1cblxuICAgIHN0YXRpYyBnZXQgdGVtcGxhdGUoKSB7IHJldHVybiBudWxsOyB9XG5cbiAgICBzdGF0aWMgZ2V0IHByb3BlcnRpZXMoKSB7XG5cbiAgICAgIC8qKlxuICAgICAgICogRmlyZWQgd2hlbmV2ZXIgRE9NIGlzIGFkZGVkIG9yIHJlbW92ZWQgYnkgdGhpcyB0ZW1wbGF0ZSAoYnlcbiAgICAgICAqIGRlZmF1bHQsIHJlbmRlcmluZyBvY2N1cnMgbGF6aWx5KS4gIFRvIGZvcmNlIGltbWVkaWF0ZSByZW5kZXJpbmcsIGNhbGxcbiAgICAgICAqIGByZW5kZXJgLlxuICAgICAgICpcbiAgICAgICAqIEBldmVudCBkb20tY2hhbmdlXG4gICAgICAgKi9cbiAgICAgIHJldHVybiB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIGFycmF5IGNvbnRhaW5pbmcgaXRlbXMgZGV0ZXJtaW5pbmcgaG93IG1hbnkgaW5zdGFuY2VzIG9mIHRoZSB0ZW1wbGF0ZVxuICAgICAgICAgKiB0byBzdGFtcCBhbmQgdGhhdCB0aGF0IGVhY2ggdGVtcGxhdGUgaW5zdGFuY2Ugc2hvdWxkIGJpbmQgdG8uXG4gICAgICAgICAqL1xuICAgICAgICBpdGVtczoge1xuICAgICAgICAgIHR5cGU6IEFycmF5XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBuYW1lIG9mIHRoZSB2YXJpYWJsZSB0byBhZGQgdG8gdGhlIGJpbmRpbmcgc2NvcGUgZm9yIHRoZSBhcnJheVxuICAgICAgICAgKiBlbGVtZW50IGFzc29jaWF0ZWQgd2l0aCBhIGdpdmVuIHRlbXBsYXRlIGluc3RhbmNlLlxuICAgICAgICAgKi9cbiAgICAgICAgYXM6IHtcbiAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgdmFsdWU6ICdpdGVtJ1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbmFtZSBvZiB0aGUgdmFyaWFibGUgdG8gYWRkIHRvIHRoZSBiaW5kaW5nIHNjb3BlIHdpdGggdGhlIGluZGV4XG4gICAgICAgICAqIG9mIHRoZSBpbnN0YW5jZSBpbiB0aGUgc29ydGVkIGFuZCBmaWx0ZXJlZCBsaXN0IG9mIHJlbmRlcmVkIGl0ZW1zLlxuICAgICAgICAgKiBOb3RlLCBmb3IgdGhlIGluZGV4IGluIHRoZSBgdGhpcy5pdGVtc2AgYXJyYXksIHVzZSB0aGUgdmFsdWUgb2YgdGhlXG4gICAgICAgICAqIGBpdGVtc0luZGV4QXNgIHByb3BlcnR5LlxuICAgICAgICAgKi9cbiAgICAgICAgaW5kZXhBczoge1xuICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICB2YWx1ZTogJ2luZGV4J1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbmFtZSBvZiB0aGUgdmFyaWFibGUgdG8gYWRkIHRvIHRoZSBiaW5kaW5nIHNjb3BlIHdpdGggdGhlIGluZGV4XG4gICAgICAgICAqIG9mIHRoZSBpbnN0YW5jZSBpbiB0aGUgYHRoaXMuaXRlbXNgIGFycmF5LiBOb3RlLCBmb3IgdGhlIGluZGV4IG9mXG4gICAgICAgICAqIHRoaXMgaW5zdGFuY2UgaW4gdGhlIHNvcnRlZCBhbmQgZmlsdGVyZWQgbGlzdCBvZiByZW5kZXJlZCBpdGVtcyxcbiAgICAgICAgICogdXNlIHRoZSB2YWx1ZSBvZiB0aGUgYGluZGV4QXNgIHByb3BlcnR5LlxuICAgICAgICAgKi9cbiAgICAgICAgaXRlbXNJbmRleEFzOiB7XG4gICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgIHZhbHVlOiAnaXRlbXNJbmRleCdcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQSBmdW5jdGlvbiB0aGF0IHNob3VsZCBkZXRlcm1pbmUgdGhlIHNvcnQgb3JkZXIgb2YgdGhlIGl0ZW1zLiAgVGhpc1xuICAgICAgICAgKiBwcm9wZXJ0eSBzaG91bGQgZWl0aGVyIGJlIHByb3ZpZGVkIGFzIGEgc3RyaW5nLCBpbmRpY2F0aW5nIGEgbWV0aG9kXG4gICAgICAgICAqIG5hbWUgb24gdGhlIGVsZW1lbnQncyBob3N0LCBvciBlbHNlIGJlIGFuIGFjdHVhbCBmdW5jdGlvbi4gIFRoZVxuICAgICAgICAgKiBmdW5jdGlvbiBzaG91bGQgbWF0Y2ggdGhlIHNvcnQgZnVuY3Rpb24gcGFzc2VkIHRvIGBBcnJheS5zb3J0YC5cbiAgICAgICAgICogVXNpbmcgYSBzb3J0IGZ1bmN0aW9uIGhhcyBubyBlZmZlY3Qgb24gdGhlIHVuZGVybHlpbmcgYGl0ZW1zYCBhcnJheS5cbiAgICAgICAgICovXG4gICAgICAgIHNvcnQ6IHtcbiAgICAgICAgICB0eXBlOiBGdW5jdGlvbixcbiAgICAgICAgICBvYnNlcnZlcjogJ19fc29ydENoYW5nZWQnXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCB0byBmaWx0ZXIgaXRlbXMgb3V0IG9mIHRoZSB2aWV3LiAgVGhpc1xuICAgICAgICAgKiBwcm9wZXJ0eSBzaG91bGQgZWl0aGVyIGJlIHByb3ZpZGVkIGFzIGEgc3RyaW5nLCBpbmRpY2F0aW5nIGEgbWV0aG9kXG4gICAgICAgICAqIG5hbWUgb24gdGhlIGVsZW1lbnQncyBob3N0LCBvciBlbHNlIGJlIGFuIGFjdHVhbCBmdW5jdGlvbi4gIFRoZVxuICAgICAgICAgKiBmdW5jdGlvbiBzaG91bGQgbWF0Y2ggdGhlIHNvcnQgZnVuY3Rpb24gcGFzc2VkIHRvIGBBcnJheS5maWx0ZXJgLlxuICAgICAgICAgKiBVc2luZyBhIGZpbHRlciBmdW5jdGlvbiBoYXMgbm8gZWZmZWN0IG9uIHRoZSB1bmRlcmx5aW5nIGBpdGVtc2AgYXJyYXkuXG4gICAgICAgICAqL1xuICAgICAgICBmaWx0ZXI6IHtcbiAgICAgICAgICB0eXBlOiBGdW5jdGlvbixcbiAgICAgICAgICBvYnNlcnZlcjogJ19fZmlsdGVyQ2hhbmdlZCdcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogV2hlbiB1c2luZyBhIGBmaWx0ZXJgIG9yIGBzb3J0YCBmdW5jdGlvbiwgdGhlIGBvYnNlcnZlYCBwcm9wZXJ0eVxuICAgICAgICAgKiBzaG91bGQgYmUgc2V0IHRvIGEgc3BhY2Utc2VwYXJhdGVkIGxpc3Qgb2YgdGhlIG5hbWVzIG9mIGl0ZW1cbiAgICAgICAgICogc3ViLWZpZWxkcyB0aGF0IHNob3VsZCB0cmlnZ2VyIGEgcmUtc29ydCBvciByZS1maWx0ZXIgd2hlbiBjaGFuZ2VkLlxuICAgICAgICAgKiBUaGVzZSBzaG91bGQgZ2VuZXJhbGx5IGJlIGZpZWxkcyBvZiBgaXRlbWAgdGhhdCB0aGUgc29ydCBvciBmaWx0ZXJcbiAgICAgICAgICogZnVuY3Rpb24gZGVwZW5kcyBvbi5cbiAgICAgICAgICovXG4gICAgICAgIG9ic2VydmU6IHtcbiAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgb2JzZXJ2ZXI6ICdfX29ic2VydmVDaGFuZ2VkJ1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGVuIHVzaW5nIGEgYGZpbHRlcmAgb3IgYHNvcnRgIGZ1bmN0aW9uLCB0aGUgYGRlbGF5YCBwcm9wZXJ0eVxuICAgICAgICAgKiBkZXRlcm1pbmVzIGEgZGVib3VuY2UgdGltZSBhZnRlciBhIGNoYW5nZSB0byBvYnNlcnZlZCBpdGVtXG4gICAgICAgICAqIHByb3BlcnRpZXMgdGhhdCBtdXN0IHBhc3MgYmVmb3JlIHRoZSBmaWx0ZXIgb3Igc29ydCBpcyByZS1ydW4uXG4gICAgICAgICAqIFRoaXMgaXMgdXNlZnVsIGluIHJhdGUtbGltaXRpbmcgc2h1ZmZpbmcgb2YgdGhlIHZpZXcgd2hlblxuICAgICAgICAgKiBpdGVtIGNoYW5nZXMgbWF5IGJlIGZyZXF1ZW50LlxuICAgICAgICAgKi9cbiAgICAgICAgZGVsYXk6IE51bWJlcixcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ291bnQgb2YgY3VycmVudGx5IHJlbmRlcmVkIGl0ZW1zIGFmdGVyIGBmaWx0ZXJgIChpZiBhbnkpIGhhcyBiZWVuIGFwcGxpZWQuXG4gICAgICAgICAqIElmIFwiY2h1bmtpbmcgbW9kZVwiIGlzIGVuYWJsZWQsIGByZW5kZXJlZEl0ZW1Db3VudGAgaXMgdXBkYXRlZCBlYWNoIHRpbWUgYVxuICAgICAgICAgKiBzZXQgb2YgdGVtcGxhdGUgaW5zdGFuY2VzIGlzIHJlbmRlcmVkLlxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgcmVuZGVyZWRJdGVtQ291bnQ6IHtcbiAgICAgICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICAgICAgbm90aWZ5OiB0cnVlLFxuICAgICAgICAgIHJlYWRPbmx5OiB0cnVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlZmluZXMgYW4gaW5pdGlhbCBjb3VudCBvZiB0ZW1wbGF0ZSBpbnN0YW5jZXMgdG8gcmVuZGVyIGFmdGVyIHNldHRpbmdcbiAgICAgICAgICogdGhlIGBpdGVtc2AgYXJyYXksIGJlZm9yZSB0aGUgbmV4dCBwYWludCwgYW5kIHB1dHMgdGhlIGBkb20tcmVwZWF0YFxuICAgICAgICAgKiBpbnRvIFwiY2h1bmtpbmcgbW9kZVwiLiAgVGhlIHJlbWFpbmluZyBpdGVtcyB3aWxsIGJlIGNyZWF0ZWQgYW5kIHJlbmRlcmVkXG4gICAgICAgICAqIGluY3JlbWVudGFsbHkgYXQgZWFjaCBhbmltYXRpb24gZnJhbWUgdGhlcm9mIHVudGlsIGFsbCBpbnN0YW5jZXMgaGF2ZVxuICAgICAgICAgKiBiZWVuIHJlbmRlcmVkLlxuICAgICAgICAgKi9cbiAgICAgICAgaW5pdGlhbENvdW50OiB7XG4gICAgICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgICAgIG9ic2VydmVyOiAnX19pbml0aWFsaXplQ2h1bmtpbmcnXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZW4gYGluaXRpYWxDb3VudGAgaXMgdXNlZCwgdGhpcyBwcm9wZXJ0eSBkZWZpbmVzIGEgZnJhbWUgcmF0ZSB0b1xuICAgICAgICAgKiB0YXJnZXQgYnkgdGhyb3R0bGluZyB0aGUgbnVtYmVyIG9mIGluc3RhbmNlcyByZW5kZXJlZCBlYWNoIGZyYW1lIHRvXG4gICAgICAgICAqIG5vdCBleGNlZWQgdGhlIGJ1ZGdldCBmb3IgdGhlIHRhcmdldCBmcmFtZSByYXRlLiAgU2V0dGluZyB0aGlzIHRvIGFcbiAgICAgICAgICogaGlnaGVyIG51bWJlciB3aWxsIGFsbG93IGxvd2VyIGxhdGVuY3kgYW5kIGhpZ2hlciB0aHJvdWdocHV0IGZvclxuICAgICAgICAgKiB0aGluZ3MgbGlrZSBldmVudCBoYW5kbGVycywgYnV0IHdpbGwgcmVzdWx0IGluIGEgbG9uZ2VyIHRpbWUgZm9yIHRoZVxuICAgICAgICAgKiByZW1haW5pbmcgaXRlbXMgdG8gY29tcGxldGUgcmVuZGVyaW5nLlxuICAgICAgICAgKi9cbiAgICAgICAgdGFyZ2V0RnJhbWVyYXRlOiB7XG4gICAgICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgICAgIHZhbHVlOiAyMFxuICAgICAgICB9LFxuXG4gICAgICAgIF90YXJnZXRGcmFtZVRpbWU6IHtcbiAgICAgICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICAgICAgY29tcHV0ZWQ6ICdfX2NvbXB1dGVGcmFtZVRpbWUodGFyZ2V0RnJhbWVyYXRlKSdcbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0IG9ic2VydmVycygpIHtcbiAgICAgIHJldHVybiBbICdfX2l0ZW1zQ2hhbmdlZChpdGVtcy4qKScgXVxuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgc3VwZXIoKTtcbiAgICAgIHRoaXMuX19pbnN0YW5jZXMgPSBbXTtcbiAgICAgIHRoaXMuX19saW1pdCA9IEluZmluaXR5O1xuICAgICAgdGhpcy5fX3Bvb2wgPSBbXTtcbiAgICAgIHRoaXMuX19yZW5kZXJEZWJvdW5jZXIgPSBudWxsO1xuICAgICAgdGhpcy5fX2l0ZW1zSWR4VG9JbnN0SWR4ID0ge307XG4gICAgICB0aGlzLl9fY2h1bmtDb3VudCA9IG51bGw7XG4gICAgICB0aGlzLl9fbGFzdENodW5rVGltZSA9IG51bGw7XG4gICAgICB0aGlzLl9fc29ydEZuID0gbnVsbDtcbiAgICAgIHRoaXMuX19maWx0ZXJGbiA9IG51bGw7XG4gICAgICB0aGlzLl9fb2JzZXJ2ZVBhdGhzID0gbnVsbDtcbiAgICAgIHRoaXMuX19jdG9yID0gbnVsbDtcbiAgICAgIHRoaXMuX19pc0RldGFjaGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMudGVtcGxhdGUgPSBudWxsO1xuICAgIH1cblxuICAgIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgICAgc3VwZXIuZGlzY29ubmVjdGVkQ2FsbGJhY2soKTtcbiAgICAgIHRoaXMuX19pc0RldGFjaGVkID0gdHJ1ZTtcbiAgICAgIGZvciAobGV0IGk9MDsgaTx0aGlzLl9faW5zdGFuY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuX19kZXRhY2hJbnN0YW5jZShpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgIHN1cGVyLmNvbm5lY3RlZENhbGxiYWNrKCk7XG4gICAgICAvLyBvbmx5IHBlcmZvcm0gYXR0YWNobWVudCBpZiB0aGUgZWxlbWVudCB3YXMgcHJldmlvdXNseSBkZXRhY2hlZC5cbiAgICAgIGlmICh0aGlzLl9faXNEZXRhY2hlZCkge1xuICAgICAgICB0aGlzLl9faXNEZXRhY2hlZCA9IGZhbHNlO1xuICAgICAgICBsZXQgcGFyZW50ID0gdGhpcy5wYXJlbnROb2RlO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8dGhpcy5fX2luc3RhbmNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHRoaXMuX19hdHRhY2hJbnN0YW5jZShpLCBwYXJlbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgX19lbnN1cmVUZW1wbGF0aXplZCgpIHtcbiAgICAgIC8vIFRlbXBsYXRpemluZyAoZ2VuZXJhdGluZyB0aGUgaW5zdGFuY2UgY29uc3RydWN0b3IpIG5lZWRzIHRvIHdhaXRcbiAgICAgIC8vIHVudGlsIHJlYWR5LCBzaW5jZSB3b24ndCBoYXZlIGl0cyB0ZW1wbGF0ZSBjb250ZW50IGhhbmRlZCBiYWNrIHRvXG4gICAgICAvLyBpdCB1bnRpbCB0aGVuXG4gICAgICBpZiAoIXRoaXMuX19jdG9yKSB7XG4gICAgICAgIGxldCB0ZW1wbGF0ZSA9IHRoaXMudGVtcGxhdGUgPSB0aGlzLnF1ZXJ5U2VsZWN0b3IoJ3RlbXBsYXRlJyk7XG4gICAgICAgIGlmICghdGVtcGxhdGUpIHtcbiAgICAgICAgICAvLyAvLyBXYWl0IHVudGlsIGNoaWxkTGlzdCBjaGFuZ2VzIGFuZCB0ZW1wbGF0ZSBzaG91bGQgYmUgdGhlcmUgYnkgdGhlblxuICAgICAgICAgIGxldCBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKCgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLnF1ZXJ5U2VsZWN0b3IoJ3RlbXBsYXRlJykpIHtcbiAgICAgICAgICAgICAgb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgICB0aGlzLl9fcmVuZGVyKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RvbS1yZXBlYXQgcmVxdWlyZXMgYSA8dGVtcGxhdGU+IGNoaWxkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgICBvYnNlcnZlci5vYnNlcnZlKHRoaXMsIHtjaGlsZExpc3Q6IHRydWV9KTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGVtcGxhdGUgaW5zdGFuY2UgcHJvcHMgdGhhdCBzaG91bGQgYmUgZXhjbHVkZWQgZnJvbSBmb3J3YXJkaW5nXG4gICAgICAgIGxldCBpbnN0YW5jZVByb3BzID0ge307XG4gICAgICAgIGluc3RhbmNlUHJvcHNbdGhpcy5hc10gPSB0cnVlO1xuICAgICAgICBpbnN0YW5jZVByb3BzW3RoaXMuaW5kZXhBc10gPSB0cnVlO1xuICAgICAgICBpbnN0YW5jZVByb3BzW3RoaXMuaXRlbXNJbmRleEFzXSA9IHRydWU7XG4gICAgICAgIHRoaXMuX19jdG9yID0gUG9seW1lci5UZW1wbGF0aXplLnRlbXBsYXRpemUodGVtcGxhdGUsIHRoaXMsIHtcbiAgICAgICAgICBtdXRhYmxlRGF0YTogdGhpcy5tdXRhYmxlRGF0YSxcbiAgICAgICAgICBwYXJlbnRNb2RlbDogdHJ1ZSxcbiAgICAgICAgICBpbnN0YW5jZVByb3BzOiBpbnN0YW5jZVByb3BzLFxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIEB0aGlzIHt0aGlzfVxuICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wIFByb3BlcnR5IHRvIHNldFxuICAgICAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgdG8gc2V0IHByb3BlcnR5IHRvXG4gICAgICAgICAgICovXG4gICAgICAgICAgZm9yd2FyZEhvc3RQcm9wOiBmdW5jdGlvbihwcm9wLCB2YWx1ZSkge1xuICAgICAgICAgICAgbGV0IGkkID0gdGhpcy5fX2luc3RhbmNlcztcbiAgICAgICAgICAgIGZvciAobGV0IGk9MCwgaW5zdDsgKGk8aSQubGVuZ3RoKSAmJiAoaW5zdD1pJFtpXSk7IGkrKykge1xuICAgICAgICAgICAgICBpbnN0LmZvcndhcmRIb3N0UHJvcChwcm9wLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBAdGhpcyB7dGhpc31cbiAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5zdCBJbnN0YW5jZSB0byBub3RpZnlcbiAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcCBQcm9wZXJ0eSB0byBub3RpZnlcbiAgICAgICAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIG5vdGlmeVxuICAgICAgICAgICAqL1xuICAgICAgICAgIG5vdGlmeUluc3RhbmNlUHJvcDogZnVuY3Rpb24oaW5zdCwgcHJvcCwgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChQb2x5bWVyLlBhdGgubWF0Y2hlcyh0aGlzLmFzLCBwcm9wKSkge1xuICAgICAgICAgICAgICBsZXQgaWR4ID0gaW5zdFt0aGlzLml0ZW1zSW5kZXhBc107XG4gICAgICAgICAgICAgIGlmIChwcm9wID09IHRoaXMuYXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLml0ZW1zW2lkeF0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBsZXQgcGF0aCA9IFBvbHltZXIuUGF0aC50cmFuc2xhdGUodGhpcy5hcywgJ2l0ZW1zLicgKyBpZHgsIHByb3ApO1xuICAgICAgICAgICAgICB0aGlzLm5vdGlmeVBhdGgocGF0aCwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBfX2dldE1ldGhvZEhvc3QoKSB7XG4gICAgICAvLyBUZWNobmljYWxseSB0aGlzIHNob3VsZCBiZSB0aGUgb3duZXIgb2YgdGhlIG91dGVybW9zdCB0ZW1wbGF0ZS5cbiAgICAgIC8vIEluIHNoYWRvdyBkb20sIHRoaXMgaXMgYWx3YXlzIGdldFJvb3ROb2RlKCkuaG9zdCwgYnV0IHdlIGNhblxuICAgICAgLy8gYXBwcm94aW1hdGUgdGhpcyB2aWEgY29vcGVyYXRpb24gd2l0aCBvdXIgZGF0YUhvc3QgYWx3YXlzIHNldHRpbmdcbiAgICAgIC8vIGBfbWV0aG9kSG9zdGAgYXMgbG9uZyBhcyB0aGVyZSB3ZXJlIGJpbmRpbmdzIChvciBpZCdzKSBvbiB0aGlzXG4gICAgICAvLyBpbnN0YW5jZSBjYXVzaW5nIGl0IHRvIGdldCBhIGRhdGFIb3N0LlxuICAgICAgcmV0dXJuIHRoaXMuX19kYXRhSG9zdC5fbWV0aG9kSG9zdCB8fCB0aGlzLl9fZGF0YUhvc3Q7XG4gICAgfVxuXG4gICAgX19zb3J0Q2hhbmdlZChzb3J0KSB7XG4gICAgICBsZXQgbWV0aG9kSG9zdCA9IHRoaXMuX19nZXRNZXRob2RIb3N0KCk7XG4gICAgICB0aGlzLl9fc29ydEZuID0gc29ydCAmJiAodHlwZW9mIHNvcnQgPT0gJ2Z1bmN0aW9uJyA/IHNvcnQgOlxuICAgICAgICBmdW5jdGlvbigpIHsgcmV0dXJuIG1ldGhvZEhvc3Rbc29ydF0uYXBwbHkobWV0aG9kSG9zdCwgYXJndW1lbnRzKTsgfSk7XG4gICAgICBpZiAodGhpcy5pdGVtcykge1xuICAgICAgICB0aGlzLl9fZGVib3VuY2VSZW5kZXIodGhpcy5fX3JlbmRlcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgX19maWx0ZXJDaGFuZ2VkKGZpbHRlcikge1xuICAgICAgbGV0IG1ldGhvZEhvc3QgPSB0aGlzLl9fZ2V0TWV0aG9kSG9zdCgpO1xuICAgICAgdGhpcy5fX2ZpbHRlckZuID0gZmlsdGVyICYmICh0eXBlb2YgZmlsdGVyID09ICdmdW5jdGlvbicgPyBmaWx0ZXIgOlxuICAgICAgICBmdW5jdGlvbigpIHsgcmV0dXJuIG1ldGhvZEhvc3RbZmlsdGVyXS5hcHBseShtZXRob2RIb3N0LCBhcmd1bWVudHMpOyB9KTtcbiAgICAgIGlmICh0aGlzLml0ZW1zKSB7XG4gICAgICAgIHRoaXMuX19kZWJvdW5jZVJlbmRlcih0aGlzLl9fcmVuZGVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfX2NvbXB1dGVGcmFtZVRpbWUocmF0ZSkge1xuICAgICAgcmV0dXJuIE1hdGguY2VpbCgxMDAwL3JhdGUpO1xuICAgIH1cblxuICAgIF9faW5pdGlhbGl6ZUNodW5raW5nKCkge1xuICAgICAgaWYgKHRoaXMuaW5pdGlhbENvdW50KSB7XG4gICAgICAgIHRoaXMuX19saW1pdCA9IHRoaXMuaW5pdGlhbENvdW50O1xuICAgICAgICB0aGlzLl9fY2h1bmtDb3VudCA9IHRoaXMuaW5pdGlhbENvdW50O1xuICAgICAgICB0aGlzLl9fbGFzdENodW5rVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgfVxuICAgIH1cblxuICAgIF9fdHJ5UmVuZGVyQ2h1bmsoKSB7XG4gICAgICAvLyBEZWJvdW5jZWQgc28gdGhhdCBtdWx0aXBsZSBjYWxscyB0aHJvdWdoIGBfcmVuZGVyYCBiZXR3ZWVuIGFuaW1hdGlvblxuICAgICAgLy8gZnJhbWVzIG9ubHkgcXVldWUgb25lIG5ldyByQUYgKGUuZy4gYXJyYXkgbXV0YXRpb24gJiBjaHVua2VkIHJlbmRlcilcbiAgICAgIGlmICh0aGlzLml0ZW1zICYmIHRoaXMuX19saW1pdCA8IHRoaXMuaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuX19kZWJvdW5jZVJlbmRlcih0aGlzLl9fcmVxdWVzdFJlbmRlckNodW5rKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfX3JlcXVlc3RSZW5kZXJDaHVuaygpIHtcbiAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKT0+dGhpcy5fX3JlbmRlckNodW5rKCkpO1xuICAgIH1cblxuICAgIF9fcmVuZGVyQ2h1bmsoKSB7XG4gICAgICAvLyBTaW1wbGUgYXV0byBjaHVua1NpemUgdGhyb3R0bGluZyBhbGdvcml0aG0gYmFzZWQgb24gZmVlZGJhY2sgbG9vcDpcbiAgICAgIC8vIG1lYXN1cmUgYWN0dWFsIHRpbWUgYmV0d2VlbiBmcmFtZXMgYW5kIHNjYWxlIGNodW5rIGNvdW50IGJ5IHJhdGlvXG4gICAgICAvLyBvZiB0YXJnZXQvYWN0dWFsIGZyYW1lIHRpbWVcbiAgICAgIGxldCBjdXJyQ2h1bmtUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBsZXQgcmF0aW8gPSB0aGlzLl90YXJnZXRGcmFtZVRpbWUgLyAoY3VyckNodW5rVGltZSAtIHRoaXMuX19sYXN0Q2h1bmtUaW1lKTtcbiAgICAgIHRoaXMuX19jaHVua0NvdW50ID0gTWF0aC5yb3VuZCh0aGlzLl9fY2h1bmtDb3VudCAqIHJhdGlvKSB8fCAxO1xuICAgICAgdGhpcy5fX2xpbWl0ICs9IHRoaXMuX19jaHVua0NvdW50O1xuICAgICAgdGhpcy5fX2xhc3RDaHVua1RpbWUgPSBjdXJyQ2h1bmtUaW1lO1xuICAgICAgdGhpcy5fX2RlYm91bmNlUmVuZGVyKHRoaXMuX19yZW5kZXIpO1xuICAgIH1cblxuICAgIF9fb2JzZXJ2ZUNoYW5nZWQoKSB7XG4gICAgICB0aGlzLl9fb2JzZXJ2ZVBhdGhzID0gdGhpcy5vYnNlcnZlICYmXG4gICAgICAgIHRoaXMub2JzZXJ2ZS5yZXBsYWNlKCcuKicsICcuJykuc3BsaXQoJyAnKTtcbiAgICB9XG5cbiAgICBfX2l0ZW1zQ2hhbmdlZChjaGFuZ2UpIHtcbiAgICAgIGlmICh0aGlzLml0ZW1zICYmICFBcnJheS5pc0FycmF5KHRoaXMuaXRlbXMpKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignZG9tLXJlcGVhdCBleHBlY3RlZCBhcnJheSBmb3IgYGl0ZW1zYCwgZm91bmQnLCB0aGlzLml0ZW1zKTtcbiAgICAgIH1cbiAgICAgIC8vIElmIHBhdGggd2FzIHRvIGFuIGl0ZW0gKGUuZy4gJ2l0ZW1zLjMnIG9yICdpdGVtcy4zLmZvbycpLCBmb3J3YXJkIHRoZVxuICAgICAgLy8gcGF0aCB0byB0aGF0IGluc3RhbmNlIHN5bmNocm9ub3VzbHkgKHJldHVucyBmYWxzZSBmb3Igbm9uLWl0ZW0gcGF0aHMpXG4gICAgICBpZiAoIXRoaXMuX19oYW5kbGVJdGVtUGF0aChjaGFuZ2UucGF0aCwgY2hhbmdlLnZhbHVlKSkge1xuICAgICAgICAvLyBPdGhlcndpc2UsIHRoZSBhcnJheSB3YXMgcmVzZXQgKCdpdGVtcycpIG9yIHNwbGljZWQgKCdpdGVtcy5zcGxpY2VzJyksXG4gICAgICAgIC8vIHNvIHF1ZXVlIGEgZnVsbCByZWZyZXNoXG4gICAgICAgIHRoaXMuX19pbml0aWFsaXplQ2h1bmtpbmcoKTtcbiAgICAgICAgdGhpcy5fX2RlYm91bmNlUmVuZGVyKHRoaXMuX19yZW5kZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIF9faGFuZGxlT2JzZXJ2ZWRQYXRocyhwYXRoKSB7XG4gICAgICBpZiAodGhpcy5fX29ic2VydmVQYXRocykge1xuICAgICAgICBwYXRoID0gcGF0aC5zdWJzdHJpbmcocGF0aC5pbmRleE9mKCcuJykgKyAxKTtcbiAgICAgICAgbGV0IHBhdGhzID0gdGhpcy5fX29ic2VydmVQYXRocztcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPHBhdGhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKHBhdGguaW5kZXhPZihwYXRoc1tpXSkgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuX19kZWJvdW5jZVJlbmRlcih0aGlzLl9fcmVuZGVyLCB0aGlzLmRlbGF5KTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24odGhpczpEb21SZXBlYXQpfSBmbiBGdW5jdGlvbiB0byBkZWJvdW5jZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcj19IGRlbGF5IERlbGF5IGluIG1zIHRvIGRlYm91bmNlIGJ5LlxuICAgICAqL1xuICAgIF9fZGVib3VuY2VSZW5kZXIoZm4sIGRlbGF5ID0gMCkge1xuICAgICAgdGhpcy5fX3JlbmRlckRlYm91bmNlciA9IFBvbHltZXIuRGVib3VuY2VyLmRlYm91bmNlKFxuICAgICAgICAgICAgdGhpcy5fX3JlbmRlckRlYm91bmNlclxuICAgICAgICAgICwgZGVsYXkgPiAwID8gUG9seW1lci5Bc3luYy50aW1lT3V0LmFmdGVyKGRlbGF5KSA6IFBvbHltZXIuQXN5bmMubWljcm9UYXNrXG4gICAgICAgICAgLCBmbi5iaW5kKHRoaXMpKTtcbiAgICAgIFBvbHltZXIuZW5xdWV1ZURlYm91bmNlcih0aGlzLl9fcmVuZGVyRGVib3VuY2VyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGb3JjZXMgdGhlIGVsZW1lbnQgdG8gcmVuZGVyIGl0cyBjb250ZW50LiBOb3JtYWxseSByZW5kZXJpbmcgaXNcbiAgICAgKiBhc3luY2hyb25vdXMgdG8gYSBwcm92b2tpbmcgY2hhbmdlLiBUaGlzIGlzIGRvbmUgZm9yIGVmZmljaWVuY3kgc29cbiAgICAgKiB0aGF0IG11bHRpcGxlIGNoYW5nZXMgdHJpZ2dlciBvbmx5IGEgc2luZ2xlIHJlbmRlci4gVGhlIHJlbmRlciBtZXRob2RcbiAgICAgKiBzaG91bGQgYmUgY2FsbGVkIGlmLCBmb3IgZXhhbXBsZSwgdGVtcGxhdGUgcmVuZGVyaW5nIGlzIHJlcXVpcmVkIHRvXG4gICAgICogdmFsaWRhdGUgYXBwbGljYXRpb24gc3RhdGUuXG4gICAgICovXG4gICAgcmVuZGVyKCkge1xuICAgICAgLy8gUXVldWUgdGhpcyByZXBlYXRlciwgdGhlbiBmbHVzaCBhbGwgaW4gb3JkZXJcbiAgICAgIHRoaXMuX19kZWJvdW5jZVJlbmRlcih0aGlzLl9fcmVuZGVyKTtcbiAgICAgIFBvbHltZXIuZmx1c2goKTtcbiAgICB9XG5cbiAgICBfX3JlbmRlcigpIHtcbiAgICAgIGlmICghdGhpcy5fX2Vuc3VyZVRlbXBsYXRpemVkKCkpIHtcbiAgICAgICAgLy8gTm8gdGVtcGxhdGUgZm91bmQgeWV0XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX19hcHBseUZ1bGxSZWZyZXNoKCk7XG4gICAgICAvLyBSZXNldCB0aGUgcG9vbFxuICAgICAgLy8gVE9ETyhrc2NoYWFmKTogUmV1c2UgcG9vbCBhY3Jvc3MgdHVybnMgYW5kIG5lc3RlZCB0ZW1wbGF0ZXNcbiAgICAgIC8vIE5vdyB0aGF0IG9iamVjdHMvYXJyYXlzIGFyZSByZS1ldmFsdWF0ZWQgd2hlbiBzZXQsIHdlIGNhbiBzYWZlbHlcbiAgICAgIC8vIHJldXNlIHBvb2xlZCBpbnN0YW5jZXMgYWNyb3NzIHR1cm5zLCBob3dldmVyIHdlIHN0aWxsIG5lZWQgdG8gZGVjaWRlXG4gICAgICAvLyBzZW1hbnRpY3MgcmVnYXJkaW5nIGhvdyBsb25nIHRvIGhvbGQsIGhvdyBtYW55IHRvIGhvbGQsIGV0Yy5cbiAgICAgIHRoaXMuX19wb29sLmxlbmd0aCA9IDA7XG4gICAgICAvLyBTZXQgcmVuZGVyZWQgaXRlbSBjb3VudFxuICAgICAgdGhpcy5fc2V0UmVuZGVyZWRJdGVtQ291bnQodGhpcy5fX2luc3RhbmNlcy5sZW5ndGgpO1xuICAgICAgLy8gTm90aWZ5IHVzZXJzXG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KCdkb20tY2hhbmdlJywge1xuICAgICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgICBjb21wb3NlZDogdHJ1ZVxuICAgICAgfSkpO1xuICAgICAgLy8gQ2hlY2sgdG8gc2VlIGlmIHdlIG5lZWQgdG8gcmVuZGVyIG1vcmUgaXRlbXNcbiAgICAgIHRoaXMuX190cnlSZW5kZXJDaHVuaygpO1xuICAgIH1cblxuICAgIF9fYXBwbHlGdWxsUmVmcmVzaCgpIHtcbiAgICAgIGxldCBpdGVtcyA9IHRoaXMuaXRlbXMgfHwgW107XG4gICAgICBsZXQgaXNudElkeFRvSXRlbXNJZHggPSBuZXcgQXJyYXkoaXRlbXMubGVuZ3RoKTtcbiAgICAgIGZvciAobGV0IGk9MDsgaTxpdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpc250SWR4VG9JdGVtc0lkeFtpXSA9IGk7XG4gICAgICB9XG4gICAgICAvLyBBcHBseSB1c2VyIGZpbHRlclxuICAgICAgaWYgKHRoaXMuX19maWx0ZXJGbikge1xuICAgICAgICBpc250SWR4VG9JdGVtc0lkeCA9IGlzbnRJZHhUb0l0ZW1zSWR4LmZpbHRlcigoaSwgaWR4LCBhcnJheSkgPT5cbiAgICAgICAgICB0aGlzLl9fZmlsdGVyRm4oaXRlbXNbaV0sIGlkeCwgYXJyYXkpKTtcbiAgICAgIH1cbiAgICAgIC8vIEFwcGx5IHVzZXIgc29ydFxuICAgICAgaWYgKHRoaXMuX19zb3J0Rm4pIHtcbiAgICAgICAgaXNudElkeFRvSXRlbXNJZHguc29ydCgoYSwgYikgPT4gdGhpcy5fX3NvcnRGbihpdGVtc1thXSwgaXRlbXNbYl0pKTtcbiAgICAgIH1cbiAgICAgIC8vIGl0ZW1zLT5pbnN0IG1hcCBrZXB0IGZvciBpdGVtIHBhdGggZm9yd2FyZGluZ1xuICAgICAgY29uc3QgaXRlbXNJZHhUb0luc3RJZHggPSB0aGlzLl9faXRlbXNJZHhUb0luc3RJZHggPSB7fTtcbiAgICAgIGxldCBpbnN0SWR4ID0gMDtcbiAgICAgIC8vIEdlbmVyYXRlIGluc3RhbmNlcyBhbmQgYXNzaWduIGl0ZW1zXG4gICAgICBjb25zdCBsaW1pdCA9IE1hdGgubWluKGlzbnRJZHhUb0l0ZW1zSWR4Lmxlbmd0aCwgdGhpcy5fX2xpbWl0KTtcbiAgICAgIGZvciAoOyBpbnN0SWR4PGxpbWl0OyBpbnN0SWR4KyspIHtcbiAgICAgICAgbGV0IGluc3QgPSB0aGlzLl9faW5zdGFuY2VzW2luc3RJZHhdO1xuICAgICAgICBsZXQgaXRlbUlkeCA9IGlzbnRJZHhUb0l0ZW1zSWR4W2luc3RJZHhdO1xuICAgICAgICBsZXQgaXRlbSA9IGl0ZW1zW2l0ZW1JZHhdO1xuICAgICAgICBpdGVtc0lkeFRvSW5zdElkeFtpdGVtSWR4XSA9IGluc3RJZHg7XG4gICAgICAgIGlmIChpbnN0ICYmIGluc3RJZHggPCB0aGlzLl9fbGltaXQpIHtcbiAgICAgICAgICBpbnN0Ll9zZXRQZW5kaW5nUHJvcGVydHkodGhpcy5hcywgaXRlbSk7XG4gICAgICAgICAgaW5zdC5fc2V0UGVuZGluZ1Byb3BlcnR5KHRoaXMuaW5kZXhBcywgaW5zdElkeCk7XG4gICAgICAgICAgaW5zdC5fc2V0UGVuZGluZ1Byb3BlcnR5KHRoaXMuaXRlbXNJbmRleEFzLCBpdGVtSWR4KTtcbiAgICAgICAgICBpbnN0Ll9mbHVzaFByb3BlcnRpZXMoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9faW5zZXJ0SW5zdGFuY2UoaXRlbSwgaW5zdElkeCwgaXRlbUlkeCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIFJlbW92ZSBhbnkgZXh0cmEgaW5zdGFuY2VzIGZyb20gcHJldmlvdXMgc3RhdGVcbiAgICAgIGZvciAobGV0IGk9dGhpcy5fX2luc3RhbmNlcy5sZW5ndGgtMTsgaT49aW5zdElkeDsgaS0tKSB7XG4gICAgICAgIHRoaXMuX19kZXRhY2hBbmRSZW1vdmVJbnN0YW5jZShpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfX2RldGFjaEluc3RhbmNlKGlkeCkge1xuICAgICAgbGV0IGluc3QgPSB0aGlzLl9faW5zdGFuY2VzW2lkeF07XG4gICAgICBmb3IgKGxldCBpPTA7IGk8aW5zdC5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgZWwgPSBpbnN0LmNoaWxkcmVuW2ldO1xuICAgICAgICBpbnN0LnJvb3QuYXBwZW5kQ2hpbGQoZWwpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGluc3Q7XG4gICAgfVxuXG4gICAgX19hdHRhY2hJbnN0YW5jZShpZHgsIHBhcmVudCkge1xuICAgICAgbGV0IGluc3QgPSB0aGlzLl9faW5zdGFuY2VzW2lkeF07XG4gICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKGluc3Qucm9vdCwgdGhpcyk7XG4gICAgfVxuXG4gICAgX19kZXRhY2hBbmRSZW1vdmVJbnN0YW5jZShpZHgpIHtcbiAgICAgIGxldCBpbnN0ID0gdGhpcy5fX2RldGFjaEluc3RhbmNlKGlkeCk7XG4gICAgICBpZiAoaW5zdCkge1xuICAgICAgICB0aGlzLl9fcG9vbC5wdXNoKGluc3QpO1xuICAgICAgfVxuICAgICAgdGhpcy5fX2luc3RhbmNlcy5zcGxpY2UoaWR4LCAxKTtcbiAgICB9XG5cbiAgICBfX3N0YW1wSW5zdGFuY2UoaXRlbSwgaW5zdElkeCwgaXRlbUlkeCkge1xuICAgICAgbGV0IG1vZGVsID0ge307XG4gICAgICBtb2RlbFt0aGlzLmFzXSA9IGl0ZW07XG4gICAgICBtb2RlbFt0aGlzLmluZGV4QXNdID0gaW5zdElkeDtcbiAgICAgIG1vZGVsW3RoaXMuaXRlbXNJbmRleEFzXSA9IGl0ZW1JZHg7XG4gICAgICByZXR1cm4gbmV3IHRoaXMuX19jdG9yKG1vZGVsKTtcbiAgICB9XG5cbiAgICBfX2luc2VydEluc3RhbmNlKGl0ZW0sIGluc3RJZHgsIGl0ZW1JZHgpIHtcbiAgICAgIGxldCBpbnN0ID0gdGhpcy5fX3Bvb2wucG9wKCk7XG4gICAgICBpZiAoaW5zdCkge1xuICAgICAgICAvLyBUT0RPKGtzY2hhYWYpOiBJZiB0aGUgcG9vbCBpcyBzaGFyZWQgYWNyb3NzIHR1cm5zLCBob3N0UHJvcHNcbiAgICAgICAgLy8gbmVlZCB0byBiZSByZS1zZXQgdG8gcmV1c2VkIGluc3RhbmNlcyBpbiBhZGRpdGlvbiB0byBpdGVtXG4gICAgICAgIGluc3QuX3NldFBlbmRpbmdQcm9wZXJ0eSh0aGlzLmFzLCBpdGVtKTtcbiAgICAgICAgaW5zdC5fc2V0UGVuZGluZ1Byb3BlcnR5KHRoaXMuaW5kZXhBcywgaW5zdElkeCk7XG4gICAgICAgIGluc3QuX3NldFBlbmRpbmdQcm9wZXJ0eSh0aGlzLml0ZW1zSW5kZXhBcywgaXRlbUlkeCk7XG4gICAgICAgIGluc3QuX2ZsdXNoUHJvcGVydGllcygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5zdCA9IHRoaXMuX19zdGFtcEluc3RhbmNlKGl0ZW0sIGluc3RJZHgsIGl0ZW1JZHgpO1xuICAgICAgfVxuICAgICAgbGV0IGJlZm9yZVJvdyA9IHRoaXMuX19pbnN0YW5jZXNbaW5zdElkeCArIDFdO1xuICAgICAgbGV0IGJlZm9yZU5vZGUgPSBiZWZvcmVSb3cgPyBiZWZvcmVSb3cuY2hpbGRyZW5bMF0gOiB0aGlzO1xuICAgICAgdGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZShpbnN0LnJvb3QsIGJlZm9yZU5vZGUpO1xuICAgICAgdGhpcy5fX2luc3RhbmNlc1tpbnN0SWR4XSA9IGluc3Q7XG4gICAgICByZXR1cm4gaW5zdDtcbiAgICB9XG5cbiAgICAvLyBJbXBsZW1lbnRzIGV4dGVuc2lvbiBwb2ludCBmcm9tIFRlbXBsYXRpemUgbWl4aW5cbiAgICBfc2hvd0hpZGVDaGlsZHJlbihoaWRkZW4pIHtcbiAgICAgIGZvciAobGV0IGk9MDsgaTx0aGlzLl9faW5zdGFuY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuX19pbnN0YW5jZXNbaV0uX3Nob3dIaWRlQ2hpbGRyZW4oaGlkZGVuKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDYWxsZWQgYXMgYSBzaWRlIGVmZmVjdCBvZiBhIGhvc3QgaXRlbXMuPGtleT4uPHBhdGg+IHBhdGggY2hhbmdlLFxuICAgIC8vIHJlc3BvbnNpYmxlIGZvciBub3RpZnlpbmcgaXRlbS48cGF0aD4gY2hhbmdlcyB0byBpbnN0IGZvciBrZXlcbiAgICBfX2hhbmRsZUl0ZW1QYXRoKHBhdGgsIHZhbHVlKSB7XG4gICAgICBsZXQgaXRlbXNQYXRoID0gcGF0aC5zbGljZSg2KTsgLy8gJ2l0ZW1zLicubGVuZ3RoID09IDZcbiAgICAgIGxldCBkb3QgPSBpdGVtc1BhdGguaW5kZXhPZignLicpO1xuICAgICAgbGV0IGl0ZW1zSWR4ID0gZG90IDwgMCA/IGl0ZW1zUGF0aCA6IGl0ZW1zUGF0aC5zdWJzdHJpbmcoMCwgZG90KTtcbiAgICAgIC8vIElmIHBhdGggd2FzIGluZGV4IGludG8gYXJyYXkuLi5cbiAgICAgIGlmIChpdGVtc0lkeCA9PSBwYXJzZUludChpdGVtc0lkeCwgMTApKSB7XG4gICAgICAgIGxldCBpdGVtU3ViUGF0aCA9IGRvdCA8IDAgPyAnJyA6IGl0ZW1zUGF0aC5zdWJzdHJpbmcoZG90KzEpO1xuICAgICAgICAvLyBJZiB0aGUgcGF0aCBpcyBvYnNlcnZlZCwgaXQgd2lsbCB0cmlnZ2VyIGEgZnVsbCByZWZyZXNoXG4gICAgICAgIHRoaXMuX19oYW5kbGVPYnNlcnZlZFBhdGhzKGl0ZW1TdWJQYXRoKTtcbiAgICAgICAgLy8gTm90ZSwgZXZlbiBpZiBhIHJ1bGwgcmVmcmVzaCBpcyB0cmlnZ2VyZWQsIGFsd2F5cyBkbyB0aGUgcGF0aFxuICAgICAgICAvLyBub3RpZmljYXRpb24gYmVjYXVzZSB1bmxlc3MgbXV0YWJsZURhdGEgaXMgdXNlZCBmb3IgZG9tLXJlcGVhdFxuICAgICAgICAvLyBhbmQgYWxsIGVsZW1lbnRzIGluIHRoZSBpbnN0YW5jZSBzdWJ0cmVlLCBhIGZ1bGwgcmVmcmVzaCBtYXlcbiAgICAgICAgLy8gbm90IHRyaWdnZXIgdGhlIHByb3BlciB1cGRhdGUuXG4gICAgICAgIGxldCBpbnN0SWR4ID0gdGhpcy5fX2l0ZW1zSWR4VG9JbnN0SWR4W2l0ZW1zSWR4XTtcbiAgICAgICAgbGV0IGluc3QgPSB0aGlzLl9faW5zdGFuY2VzW2luc3RJZHhdO1xuICAgICAgICBpZiAoaW5zdCkge1xuICAgICAgICAgIGxldCBpdGVtUGF0aCA9IHRoaXMuYXMgKyAoaXRlbVN1YlBhdGggPyAnLicgKyBpdGVtU3ViUGF0aCA6ICcnKTtcbiAgICAgICAgICAvLyBUaGlzIGlzIGVmZmVjdGl2ZWx5IGBub3RpZnlQYXRoYCwgYnV0IGF2b2lkcyBzb21lIG9mIHRoZSBvdmVyaGVhZFxuICAgICAgICAgIC8vIG9mIHRoZSBwdWJsaWMgQVBJXG4gICAgICAgICAgaW5zdC5fc2V0UGVuZGluZ1Byb3BlcnR5T3JQYXRoKGl0ZW1QYXRoLCB2YWx1ZSwgZmFsc2UsIHRydWUpO1xuICAgICAgICAgIGluc3QuX2ZsdXNoUHJvcGVydGllcygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGl0ZW0gYXNzb2NpYXRlZCB3aXRoIGEgZ2l2ZW4gZWxlbWVudCBzdGFtcGVkIGJ5XG4gICAgICogdGhpcyBgZG9tLXJlcGVhdGAuXG4gICAgICpcbiAgICAgKiBOb3RlLCB0byBtb2RpZnkgc3ViLXByb3BlcnRpZXMgb2YgdGhlIGl0ZW0sXG4gICAgICogYG1vZGVsRm9yRWxlbWVudChlbCkuc2V0KCdpdGVtLjxzdWItcHJvcD4nLCB2YWx1ZSlgXG4gICAgICogc2hvdWxkIGJlIHVzZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCBFbGVtZW50IGZvciB3aGljaCB0byByZXR1cm4gdGhlIGl0ZW0uXG4gICAgICogQHJldHVybiB7Kn0gSXRlbSBhc3NvY2lhdGVkIHdpdGggdGhlIGVsZW1lbnQuXG4gICAgICovXG4gICAgaXRlbUZvckVsZW1lbnQoZWwpIHtcbiAgICAgIGxldCBpbnN0YW5jZSA9IHRoaXMubW9kZWxGb3JFbGVtZW50KGVsKTtcbiAgICAgIHJldHVybiBpbnN0YW5jZSAmJiBpbnN0YW5jZVt0aGlzLmFzXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBpbnN0IGluZGV4IGZvciBhIGdpdmVuIGVsZW1lbnQgc3RhbXBlZCBieSB0aGlzIGBkb20tcmVwZWF0YC5cbiAgICAgKiBJZiBgc29ydGAgaXMgcHJvdmlkZWQsIHRoZSBpbmRleCB3aWxsIHJlZmxlY3QgdGhlIHNvcnRlZCBvcmRlciAocmF0aGVyXG4gICAgICogdGhhbiB0aGUgb3JpZ2luYWwgYXJyYXkgb3JkZXIpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgRWxlbWVudCBmb3Igd2hpY2ggdG8gcmV0dXJuIHRoZSBpbmRleC5cbiAgICAgKiBAcmV0dXJuIHsqfSBSb3cgaW5kZXggYXNzb2NpYXRlZCB3aXRoIHRoZSBlbGVtZW50IChub3RlIHRoaXMgbWF5XG4gICAgICogICBub3QgY29ycmVzcG9uZCB0byB0aGUgYXJyYXkgaW5kZXggaWYgYSB1c2VyIGBzb3J0YCBpcyBhcHBsaWVkKS5cbiAgICAgKi9cbiAgICBpbmRleEZvckVsZW1lbnQoZWwpIHtcbiAgICAgIGxldCBpbnN0YW5jZSA9IHRoaXMubW9kZWxGb3JFbGVtZW50KGVsKTtcbiAgICAgIHJldHVybiBpbnN0YW5jZSAmJiBpbnN0YW5jZVt0aGlzLmluZGV4QXNdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHRlbXBsYXRlIFwibW9kZWxcIiBhc3NvY2lhdGVkIHdpdGggYSBnaXZlbiBlbGVtZW50LCB3aGljaFxuICAgICAqIHNlcnZlcyBhcyB0aGUgYmluZGluZyBzY29wZSBmb3IgdGhlIHRlbXBsYXRlIGluc3RhbmNlIHRoZSBlbGVtZW50IGlzXG4gICAgICogY29udGFpbmVkIGluLiBBIHRlbXBsYXRlIG1vZGVsIGlzIGFuIGluc3RhbmNlIG9mIGBQb2x5bWVyLkJhc2VgLCBhbmRcbiAgICAgKiBzaG91bGQgYmUgdXNlZCB0byBtYW5pcHVsYXRlIGRhdGEgYXNzb2NpYXRlZCB3aXRoIHRoaXMgdGVtcGxhdGUgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBFeGFtcGxlOlxuICAgICAqXG4gICAgICogICBsZXQgbW9kZWwgPSBtb2RlbEZvckVsZW1lbnQoZWwpO1xuICAgICAqICAgaWYgKG1vZGVsLmluZGV4IDwgMTApIHtcbiAgICAgKiAgICAgbW9kZWwuc2V0KCdpdGVtLmNoZWNrZWQnLCB0cnVlKTtcbiAgICAgKiAgIH1cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIEVsZW1lbnQgZm9yIHdoaWNoIHRvIHJldHVybiBhIHRlbXBsYXRlIG1vZGVsLlxuICAgICAqIEByZXR1cm4ge1RlbXBsYXRlSW5zdGFuY2VCYXNlfSBNb2RlbCByZXByZXNlbnRpbmcgdGhlIGJpbmRpbmcgc2NvcGUgZm9yXG4gICAgICogICB0aGUgZWxlbWVudC5cbiAgICAgKi9cbiAgICBtb2RlbEZvckVsZW1lbnQoZWwpIHtcbiAgICAgIHJldHVybiBQb2x5bWVyLlRlbXBsYXRpemUubW9kZWxGb3JFbGVtZW50KHRoaXMudGVtcGxhdGUsIGVsKTtcbiAgICB9XG5cbiAgfVxuXG4gIGN1c3RvbUVsZW1lbnRzLmRlZmluZShEb21SZXBlYXQuaXMsIERvbVJlcGVhdCk7XG5cbiAgUG9seW1lci5Eb21SZXBlYXQgPSBEb21SZXBlYXQ7XG5cbn0pKCk7XG5cbjwvc2NyaXB0PlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi9lbGVtZW50cy9kb20tcmVwZWF0Lmh0bWwiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi8uLi9wb2x5bWVyLWVsZW1lbnQuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3V0aWxzL3RlbXBsYXRpemUuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3V0aWxzL2RlYm91bmNlLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi91dGlscy9mbHVzaC5odG1sXCI+XG5cbjxzY3JpcHQ+XG5cbihmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8qKlxuICAgKiBUaGUgYDxkb20taWY+YCBlbGVtZW50IHdpbGwgc3RhbXAgYSBsaWdodC1kb20gYDx0ZW1wbGF0ZT5gIGNoaWxkIHdoZW5cbiAgICogdGhlIGBpZmAgcHJvcGVydHkgYmVjb21lcyB0cnV0aHksIGFuZCB0aGUgdGVtcGxhdGUgY2FuIHVzZSBQb2x5bWVyXG4gICAqIGRhdGEtYmluZGluZyBhbmQgZGVjbGFyYXRpdmUgZXZlbnQgZmVhdHVyZXMgd2hlbiB1c2VkIGluIHRoZSBjb250ZXh0IG9mXG4gICAqIGEgUG9seW1lciBlbGVtZW50J3MgdGVtcGxhdGUuXG4gICAqXG4gICAqIFdoZW4gYGlmYCBiZWNvbWVzIGZhbHNleSwgdGhlIHN0YW1wZWQgY29udGVudCBpcyBoaWRkZW4gYnV0IG5vdFxuICAgKiByZW1vdmVkIGZyb20gZG9tLiBXaGVuIGBpZmAgc3Vic2VxdWVudGx5IGJlY29tZXMgdHJ1dGh5IGFnYWluLCB0aGUgY29udGVudFxuICAgKiBpcyBzaW1wbHkgcmUtc2hvd24uIFRoaXMgYXBwcm9hY2ggaXMgdXNlZCBkdWUgdG8gaXRzIGZhdm9yYWJsZSBwZXJmb3JtYW5jZVxuICAgKiBjaGFyYWN0ZXJpc3RpY3M6IHRoZSBleHBlbnNlIG9mIGNyZWF0aW5nIHRlbXBsYXRlIGNvbnRlbnQgaXMgcGFpZCBvbmx5XG4gICAqIG9uY2UgYW5kIGxhemlseS5cbiAgICpcbiAgICogU2V0IHRoZSBgcmVzdGFtcGAgcHJvcGVydHkgdG8gdHJ1ZSB0byBmb3JjZSB0aGUgc3RhbXBlZCBjb250ZW50IHRvIGJlXG4gICAqIGNyZWF0ZWQgLyBkZXN0cm95ZWQgd2hlbiB0aGUgYGlmYCBjb25kaXRpb24gY2hhbmdlcy5cbiAgICpcbiAgICogQGN1c3RvbUVsZW1lbnRcbiAgICogQHBvbHltZXJcbiAgICogQGV4dGVuZHMgUG9seW1lci5FbGVtZW50XG4gICAqIEBtZW1iZXJvZiBQb2x5bWVyXG4gICAqIEBzdW1tYXJ5IEN1c3RvbSBlbGVtZW50IHRoYXQgY29uZGl0aW9uYWxseSBzdGFtcHMgYW5kIGhpZGVzIG9yIHJlbW92ZXNcbiAgICogICB0ZW1wbGF0ZSBjb250ZW50IGJhc2VkIG9uIGEgYm9vbGVhbiBmbGFnLlxuICAgKi9cbiAgY2xhc3MgRG9tSWYgZXh0ZW5kcyBQb2x5bWVyLkVsZW1lbnQge1xuXG4gICAgLy8gTm90IG5lZWRlZCB0byBmaW5kIHRlbXBsYXRlOyBjYW4gYmUgcmVtb3ZlZCBvbmNlIHRoZSBhbmFseXplclxuICAgIC8vIGNhbiBmaW5kIHRoZSB0YWcgbmFtZSBmcm9tIGN1c3RvbUVsZW1lbnRzLmRlZmluZSBjYWxsXG4gICAgc3RhdGljIGdldCBpcygpIHsgcmV0dXJuICdkb20taWYnOyB9XG5cbiAgICBzdGF0aWMgZ2V0IHRlbXBsYXRlKCkgeyByZXR1cm4gbnVsbDsgfVxuXG4gICAgc3RhdGljIGdldCBwcm9wZXJ0aWVzKCkge1xuXG4gICAgICByZXR1cm4ge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlZCB3aGVuZXZlciBET00gaXMgYWRkZWQgb3IgcmVtb3ZlZC9oaWRkZW4gYnkgdGhpcyB0ZW1wbGF0ZSAoYnlcbiAgICAgICAgICogZGVmYXVsdCwgcmVuZGVyaW5nIG9jY3VycyBsYXppbHkpLiAgVG8gZm9yY2UgaW1tZWRpYXRlIHJlbmRlcmluZywgY2FsbFxuICAgICAgICAgKiBgcmVuZGVyYC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV2ZW50IGRvbS1jaGFuZ2VcbiAgICAgICAgICovXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhpcyB0ZW1wbGF0ZSBzaG91bGQgc3RhbXAuXG4gICAgICAgICAqL1xuICAgICAgICBpZjoge1xuICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgICAgb2JzZXJ2ZXI6ICdfX2RlYm91bmNlUmVuZGVyJ1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGVuIHRydWUsIGVsZW1lbnRzIHdpbGwgYmUgcmVtb3ZlZCBmcm9tIERPTSBhbmQgZGlzY2FyZGVkIHdoZW4gYGlmYFxuICAgICAgICAgKiBiZWNvbWVzIGZhbHNlIGFuZCByZS1jcmVhdGVkIGFuZCBhZGRlZCBiYWNrIHRvIHRoZSBET00gd2hlbiBgaWZgXG4gICAgICAgICAqIGJlY29tZXMgdHJ1ZS4gIEJ5IGRlZmF1bHQsIHN0YW1wZWQgZWxlbWVudHMgd2lsbCBiZSBoaWRkZW4gYnV0IGxlZnRcbiAgICAgICAgICogaW4gdGhlIERPTSB3aGVuIGBpZmAgYmVjb21lcyBmYWxzZSwgd2hpY2ggaXMgZ2VuZXJhbGx5IHJlc3VsdHNcbiAgICAgICAgICogaW4gYmV0dGVyIHBlcmZvcm1hbmNlLlxuICAgICAgICAgKi9cbiAgICAgICAgcmVzdGFtcDoge1xuICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgICAgb2JzZXJ2ZXI6ICdfX2RlYm91bmNlUmVuZGVyJ1xuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgc3VwZXIoKTtcbiAgICAgIHRoaXMuX19yZW5kZXJEZWJvdW5jZXIgPSBudWxsO1xuICAgICAgdGhpcy5fX2ludmFsaWRQcm9wcyA9IG51bGw7XG4gICAgICB0aGlzLl9faW5zdGFuY2UgPSBudWxsO1xuICAgICAgdGhpcy5fbGFzdElmID0gZmFsc2U7XG4gICAgICB0aGlzLl9fY3RvciA9IG51bGw7XG4gICAgfVxuXG4gICAgX19kZWJvdW5jZVJlbmRlcigpIHtcbiAgICAgIC8vIFJlbmRlciBpcyBhc3luYyBmb3IgMiByZWFzb25zOlxuICAgICAgLy8gMS4gVG8gZWxpbWluYXRlIGRvbSBjcmVhdGlvbiB0cmFzaGluZyBpZiB1c2VyIGNvZGUgdGhyYXNoZXMgYGlmYCBpbiB0aGVcbiAgICAgIC8vICAgIHNhbWUgdHVybi4gVGhpcyB3YXMgbW9yZSBjb21tb24gaW4gMS54IHdoZXJlIGEgY29tcG91bmQgY29tcHV0ZWRcbiAgICAgIC8vICAgIHByb3BlcnR5IGNvdWxkIHJlc3VsdCBpbiB0aGUgcmVzdWx0IGNoYW5naW5nIG11bHRpcGxlIHRpbWVzLCBidXQgaXNcbiAgICAgIC8vICAgIG1pdGlnYXRlZCB0byBhIGxhcmdlIGV4dGVudCBieSBiYXRjaGVkIHByb3BlcnR5IHByb2Nlc3NpbmcgaW4gMi54LlxuICAgICAgLy8gMi4gVG8gYXZvaWQgZG91YmxlIG9iamVjdCBwcm9wYWdhdGlvbiB3aGVuIGEgYmFnIGluY2x1ZGluZyB2YWx1ZXMgYm91bmRcbiAgICAgIC8vICAgIHRvIHRoZSBgaWZgIHByb3BlcnR5IGFzIHdlbGwgYXMgb25lIG9yIG1vcmUgaG9zdFByb3BzIGNvdWxkIGVucXVldWVcbiAgICAgIC8vICAgIHRoZSA8ZG9tLWlmPiB0byBmbHVzaCBiZWZvcmUgdGhlIDx0ZW1wbGF0ZT4ncyBob3N0IHByb3BlcnR5XG4gICAgICAvLyAgICBmb3J3YXJkaW5nLiBJbiB0aGF0IHNjZW5hcmlvIGNyZWF0aW5nIGFuIGluc3RhbmNlIHdvdWxkIHJlc3VsdCBpblxuICAgICAgLy8gICAgdGhlIGhvc3QgcHJvcHMgYmVpbmcgc2V0IG9uY2UsIGFuZCB0aGVuIHRoZSBlbnF1ZXVlZCBjaGFuZ2VzIG9uIHRoZVxuICAgICAgLy8gICAgdGVtcGxhdGUgd291bGQgc2V0IHByb3BlcnRpZXMgYSBzZWNvbmQgdGltZSwgcG90ZW50aWFsbHkgY2F1c2luZyBhblxuICAgICAgLy8gICAgb2JqZWN0IHRvIGJlIHNldCB0byBhbiBpbnN0YW5jZSBtb3JlIHRoYW4gb25jZS4gIENyZWF0aW5nIHRoZVxuICAgICAgLy8gICAgaW5zdGFuY2UgYXN5bmMgZnJvbSBmbHVzaGluZyBkYXRhIGVuc3VyZXMgdGhpcyBkb2Vzbid0IGhhcHBlbi4gSWZcbiAgICAgIC8vICAgIHdlIHdhbnRlZCBhIHN5bmMgb3B0aW9uIGluIHRoZSBmdXR1cmUsIHNpbXBseSBoYXZpbmcgPGRvbS1pZj4gZmx1c2hcbiAgICAgIC8vICAgIChvciBjbGVhcikgaXRzIHRlbXBsYXRlJ3MgcGVuZGluZyBob3N0IHByb3BlcnRpZXMgYmVmb3JlIGNyZWF0aW5nXG4gICAgICAvLyAgICB0aGUgaW5zdGFuY2Ugd291bGQgYWxzbyBhdm9pZCB0aGUgcHJvYmxlbS5cbiAgICAgIHRoaXMuX19yZW5kZXJEZWJvdW5jZXIgPSBQb2x5bWVyLkRlYm91bmNlci5kZWJvdW5jZShcbiAgICAgICAgICAgIHRoaXMuX19yZW5kZXJEZWJvdW5jZXJcbiAgICAgICAgICAsIFBvbHltZXIuQXN5bmMubWljcm9UYXNrXG4gICAgICAgICAgLCAoKSA9PiB0aGlzLl9fcmVuZGVyKCkpO1xuICAgICAgUG9seW1lci5lbnF1ZXVlRGVib3VuY2VyKHRoaXMuX19yZW5kZXJEZWJvdW5jZXIpO1xuICAgIH1cblxuICAgIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgICAgc3VwZXIuZGlzY29ubmVjdGVkQ2FsbGJhY2soKTtcbiAgICAgIGlmICghdGhpcy5wYXJlbnROb2RlIHx8XG4gICAgICAgICAgKHRoaXMucGFyZW50Tm9kZS5ub2RlVHlwZSA9PSBOb2RlLkRPQ1VNRU5UX0ZSQUdNRU5UX05PREUgJiZcbiAgICAgICAgICAgIXRoaXMucGFyZW50Tm9kZS5ob3N0KSkge1xuICAgICAgICB0aGlzLl9fdGVhcmRvd25JbnN0YW5jZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgICAgc3VwZXIuY29ubmVjdGVkQ2FsbGJhY2soKTtcbiAgICAgIGlmICh0aGlzLmlmKSB7XG4gICAgICAgIHRoaXMuX19kZWJvdW5jZVJlbmRlcigpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZvcmNlcyB0aGUgZWxlbWVudCB0byByZW5kZXIgaXRzIGNvbnRlbnQuIE5vcm1hbGx5IHJlbmRlcmluZyBpc1xuICAgICAqIGFzeW5jaHJvbm91cyB0byBhIHByb3Zva2luZyBjaGFuZ2UuIFRoaXMgaXMgZG9uZSBmb3IgZWZmaWNpZW5jeSBzb1xuICAgICAqIHRoYXQgbXVsdGlwbGUgY2hhbmdlcyB0cmlnZ2VyIG9ubHkgYSBzaW5nbGUgcmVuZGVyLiBUaGUgcmVuZGVyIG1ldGhvZFxuICAgICAqIHNob3VsZCBiZSBjYWxsZWQgaWYsIGZvciBleGFtcGxlLCB0ZW1wbGF0ZSByZW5kZXJpbmcgaXMgcmVxdWlyZWQgdG9cbiAgICAgKiB2YWxpZGF0ZSBhcHBsaWNhdGlvbiBzdGF0ZS5cbiAgICAgKi9cbiAgICByZW5kZXIoKSB7XG4gICAgICBQb2x5bWVyLmZsdXNoKCk7XG4gICAgfVxuXG4gICAgX19yZW5kZXIoKSB7XG4gICAgICBpZiAodGhpcy5pZikge1xuICAgICAgICBpZiAoIXRoaXMuX19lbnN1cmVJbnN0YW5jZSgpKSB7XG4gICAgICAgICAgLy8gTm8gdGVtcGxhdGUgZm91bmQgeWV0XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3Nob3dIaWRlQ2hpbGRyZW4oKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5yZXN0YW1wKSB7XG4gICAgICAgIHRoaXMuX190ZWFyZG93bkluc3RhbmNlKCk7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMucmVzdGFtcCAmJiB0aGlzLl9faW5zdGFuY2UpIHtcbiAgICAgICAgdGhpcy5fc2hvd0hpZGVDaGlsZHJlbigpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuaWYgIT0gdGhpcy5fbGFzdElmKSB7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ2RvbS1jaGFuZ2UnLCB7XG4gICAgICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgICAgICBjb21wb3NlZDogdHJ1ZVxuICAgICAgICB9KSk7XG4gICAgICAgIHRoaXMuX2xhc3RJZiA9IHRoaXMuaWY7XG4gICAgICB9XG4gICAgfVxuXG4gICAgX19lbnN1cmVJbnN0YW5jZSgpIHtcbiAgICAgIGxldCBwYXJlbnROb2RlID0gdGhpcy5wYXJlbnROb2RlO1xuICAgICAgLy8gR3VhcmQgYWdhaW5zdCBlbGVtZW50IGJlaW5nIGRldGFjaGVkIHdoaWxlIHJlbmRlciB3YXMgcXVldWVkXG4gICAgICBpZiAocGFyZW50Tm9kZSkge1xuICAgICAgICBpZiAoIXRoaXMuX19jdG9yKSB7XG4gICAgICAgICAgbGV0IHRlbXBsYXRlID0gdGhpcy5xdWVyeVNlbGVjdG9yKCd0ZW1wbGF0ZScpO1xuICAgICAgICAgIGlmICghdGVtcGxhdGUpIHtcbiAgICAgICAgICAgIC8vIFdhaXQgdW50aWwgY2hpbGRMaXN0IGNoYW5nZXMgYW5kIHRlbXBsYXRlIHNob3VsZCBiZSB0aGVyZSBieSB0aGVuXG4gICAgICAgICAgICBsZXQgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcigoKSA9PiB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLnF1ZXJ5U2VsZWN0b3IoJ3RlbXBsYXRlJykpIHtcbiAgICAgICAgICAgICAgICBvYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fX3JlbmRlcigpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZG9tLWlmIHJlcXVpcmVzIGEgPHRlbXBsYXRlPiBjaGlsZCcpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgb2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLCB7Y2hpbGRMaXN0OiB0cnVlfSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX19jdG9yID0gUG9seW1lci5UZW1wbGF0aXplLnRlbXBsYXRpemUodGVtcGxhdGUsIHRoaXMsIHtcbiAgICAgICAgICAgIC8vIGRvbS1pZiB0ZW1wbGF0aXplciBpbnN0YW5jZXMgcmVxdWlyZSBgbXV0YWJsZTogdHJ1ZWAsIGFzXG4gICAgICAgICAgICAvLyBgX19zeW5jSG9zdFByb3BlcnRpZXNgIHJlbGllcyBvbiB0aGF0IGJlaGF2aW9yIHRvIHN5bmMgb2JqZWN0c1xuICAgICAgICAgICAgbXV0YWJsZURhdGE6IHRydWUsXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wIFByb3BlcnR5IHRvIGZvcndhcmRcbiAgICAgICAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgb2YgcHJvcGVydHlcbiAgICAgICAgICAgICAqIEB0aGlzIHt0aGlzfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmb3J3YXJkSG9zdFByb3A6IGZ1bmN0aW9uKHByb3AsIHZhbHVlKSB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLl9faW5zdGFuY2UpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pZikge1xuICAgICAgICAgICAgICAgICAgdGhpcy5fX2luc3RhbmNlLmZvcndhcmRIb3N0UHJvcChwcm9wLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgYW4gaW5zdGFuY2UgYnV0IGFyZSBzcXVlbGNoaW5nIGhvc3QgcHJvcGVydHlcbiAgICAgICAgICAgICAgICAgIC8vIGZvcndhcmRpbmcgZHVlIHRvIGlmIGJlaW5nIGZhbHNlLCBub3RlIHRoZSBpbnZhbGlkYXRlZFxuICAgICAgICAgICAgICAgICAgLy8gcHJvcGVydGllcyBzbyBgX19zeW5jSG9zdFByb3BlcnRpZXNgIGNhbiBzeW5jIHRoZW0gdGhlIG5leHRcbiAgICAgICAgICAgICAgICAgIC8vIHRpbWUgYGlmYCBiZWNvbWVzIHRydWVcbiAgICAgICAgICAgICAgICAgIHRoaXMuX19pbnZhbGlkUHJvcHMgPSB0aGlzLl9faW52YWxpZFByb3BzIHx8IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9faW52YWxpZFByb3BzW1BvbHltZXIuUGF0aC5yb290KHByb3ApXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9faW5zdGFuY2UpIHtcbiAgICAgICAgICB0aGlzLl9faW5zdGFuY2UgPSBuZXcgdGhpcy5fX2N0b3IoKTtcbiAgICAgICAgICBwYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzLl9faW5zdGFuY2Uucm9vdCwgdGhpcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fX3N5bmNIb3N0UHJvcGVydGllcygpO1xuICAgICAgICAgIGxldCBjJCA9IHRoaXMuX19pbnN0YW5jZS5jaGlsZHJlbjtcbiAgICAgICAgICBpZiAoYyQgJiYgYyQubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBEZXRlY3QgY2FzZSB3aGVyZSBkb20taWYgd2FzIHJlLWF0dGFjaGVkIGluIG5ldyBwb3NpdGlvblxuICAgICAgICAgICAgbGV0IGxhc3RDaGlsZCA9IHRoaXMucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICAgICAgaWYgKGxhc3RDaGlsZCAhPT0gYyRbYyQubGVuZ3RoLTFdKSB7XG4gICAgICAgICAgICAgIGZvciAobGV0IGk9MCwgbjsgKGk8YyQubGVuZ3RoKSAmJiAobj1jJFtpXSk7IGkrKykge1xuICAgICAgICAgICAgICAgIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG4sIHRoaXMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBfX3N5bmNIb3N0UHJvcGVydGllcygpIHtcbiAgICAgIGxldCBwcm9wcyA9IHRoaXMuX19pbnZhbGlkUHJvcHM7XG4gICAgICBpZiAocHJvcHMpIHtcbiAgICAgICAgZm9yIChsZXQgcHJvcCBpbiBwcm9wcykge1xuICAgICAgICAgIHRoaXMuX19pbnN0YW5jZS5fc2V0UGVuZGluZ1Byb3BlcnR5KHByb3AsIHRoaXMuX19kYXRhSG9zdFtwcm9wXSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fX2ludmFsaWRQcm9wcyA9IG51bGw7XG4gICAgICAgIHRoaXMuX19pbnN0YW5jZS5fZmx1c2hQcm9wZXJ0aWVzKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgX190ZWFyZG93bkluc3RhbmNlKCkge1xuICAgICAgaWYgKHRoaXMuX19pbnN0YW5jZSkge1xuICAgICAgICBsZXQgYyQgPSB0aGlzLl9faW5zdGFuY2UuY2hpbGRyZW47XG4gICAgICAgIGlmIChjJCAmJiBjJC5sZW5ndGgpIHtcbiAgICAgICAgICAvLyB1c2UgZmlyc3QgY2hpbGQgcGFyZW50LCBmb3IgY2FzZSB3aGVuIGRvbS1pZiBtYXkgaGF2ZSBiZWVuIGRldGFjaGVkXG4gICAgICAgICAgbGV0IHBhcmVudCA9IGMkWzBdLnBhcmVudE5vZGU7XG4gICAgICAgICAgZm9yIChsZXQgaT0wLCBuOyAoaTxjJC5sZW5ndGgpICYmIChuPWMkW2ldKTsgaSsrKSB7XG4gICAgICAgICAgICBwYXJlbnQucmVtb3ZlQ2hpbGQobik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX19pbnN0YW5jZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX19pbnZhbGlkUHJvcHMgPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIF9zaG93SGlkZUNoaWxkcmVuKCkge1xuICAgICAgbGV0IGhpZGRlbiA9IHRoaXMuX19oaWRlVGVtcGxhdGVDaGlsZHJlbl9fIHx8ICF0aGlzLmlmO1xuICAgICAgaWYgKHRoaXMuX19pbnN0YW5jZSkge1xuICAgICAgICB0aGlzLl9faW5zdGFuY2UuX3Nob3dIaWRlQ2hpbGRyZW4oaGlkZGVuKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgfVxuXG4gIGN1c3RvbUVsZW1lbnRzLmRlZmluZShEb21JZi5pcywgRG9tSWYpO1xuXG4gIFBvbHltZXIuRG9tSWYgPSBEb21JZjtcblxufSkoKTtcbjwvc2NyaXB0PlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi9lbGVtZW50cy9kb20taWYuaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cblxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uLy4uL3BvbHltZXItZWxlbWVudC5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vdXRpbHMvbWl4aW4uaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3V0aWxzL2FycmF5LXNwbGljZS5odG1sXCI+XG5cbjxzY3JpcHQ+XG4oZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvKipcbiAgICogRWxlbWVudCBtaXhpbiBmb3IgcmVjb3JkaW5nIGR5bmFtaWMgYXNzb2NpYXRpb25zIGJldHdlZW4gaXRlbSBwYXRocyBpbiBhXG4gICAqIG1hc3RlciBgaXRlbXNgIGFycmF5IGFuZCBhIGBzZWxlY3RlZGAgYXJyYXkgc3VjaCB0aGF0IHBhdGggY2hhbmdlcyB0byB0aGVcbiAgICogbWFzdGVyIGFycmF5IChhdCB0aGUgaG9zdCkgZWxlbWVudCBvciBlbHNld2hlcmUgdmlhIGRhdGEtYmluZGluZykgYXJlXG4gICAqIGNvcnJlY3RseSBwcm9wYWdhdGVkIHRvIGl0ZW1zIGluIHRoZSBzZWxlY3RlZCBhcnJheSBhbmQgdmljZS12ZXJzYS5cbiAgICpcbiAgICogVGhlIGBpdGVtc2AgcHJvcGVydHkgYWNjZXB0cyBhbiBhcnJheSBvZiB1c2VyIGRhdGEsIGFuZCB2aWEgdGhlXG4gICAqIGBzZWxlY3QoaXRlbSlgIGFuZCBgZGVzZWxlY3QoaXRlbSlgIEFQSSwgdXBkYXRlcyB0aGUgYHNlbGVjdGVkYCBwcm9wZXJ0eVxuICAgKiB3aGljaCBtYXkgYmUgYm91bmQgdG8gb3RoZXIgcGFydHMgb2YgdGhlIGFwcGxpY2F0aW9uLCBhbmQgYW55IGNoYW5nZXMgdG9cbiAgICogc3ViLWZpZWxkcyBvZiBgc2VsZWN0ZWRgIGl0ZW0ocykgd2lsbCBiZSBrZXB0IGluIHN5bmMgd2l0aCBpdGVtcyBpbiB0aGVcbiAgICogYGl0ZW1zYCBhcnJheS4gIFdoZW4gYG11bHRpYCBpcyBmYWxzZSwgYHNlbGVjdGVkYCBpcyBhIHByb3BlcnR5XG4gICAqIHJlcHJlc2VudGluZyB0aGUgbGFzdCBzZWxlY3RlZCBpdGVtLiAgV2hlbiBgbXVsdGlgIGlzIHRydWUsIGBzZWxlY3RlZGBcbiAgICogaXMgYW4gYXJyYXkgb2YgbXVsdGlwbHkgc2VsZWN0ZWQgaXRlbXMuXG4gICAqXG4gICAqIEBwb2x5bWVyXG4gICAqIEBtaXhpbkZ1bmN0aW9uXG4gICAqIEBhcHBsaWVzTWl4aW4gUG9seW1lci5FbGVtZW50TWl4aW5cbiAgICogQG1lbWJlcm9mIFBvbHltZXJcbiAgICogQHN1bW1hcnkgRWxlbWVudCBtaXhpbiBmb3IgcmVjb3JkaW5nIGR5bmFtaWMgYXNzb2NpYXRpb25zIGJldHdlZW4gaXRlbSBwYXRocyBpbiBhXG4gICAqIG1hc3RlciBgaXRlbXNgIGFycmF5IGFuZCBhIGBzZWxlY3RlZGAgYXJyYXlcbiAgICovXG4gIGxldCBBcnJheVNlbGVjdG9yTWl4aW4gPSBQb2x5bWVyLmRlZHVwaW5nTWl4aW4oc3VwZXJDbGFzcyA9PiB7XG5cbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAZXh0ZW5kcyB7c3VwZXJDbGFzc31cbiAgICAgKiBAaW1wbGVtZW50cyB7UG9seW1lcl9FbGVtZW50TWl4aW59XG4gICAgICovXG4gICAgbGV0IGVsZW1lbnRCYXNlID0gUG9seW1lci5FbGVtZW50TWl4aW4oc3VwZXJDbGFzcyk7XG5cbiAgICAvKipcbiAgICAgKiBAcG9seW1lclxuICAgICAqIEBtaXhpbkNsYXNzXG4gICAgICogQGltcGxlbWVudHMge1BvbHltZXJfQXJyYXlTZWxlY3Rvck1peGlufVxuICAgICAqIEB1bnJlc3RyaWN0ZWRcbiAgICAgKi9cbiAgICBjbGFzcyBBcnJheVNlbGVjdG9yTWl4aW4gZXh0ZW5kcyBlbGVtZW50QmFzZSB7XG5cbiAgICAgIHN0YXRpYyBnZXQgcHJvcGVydGllcygpIHtcblxuICAgICAgICByZXR1cm4ge1xuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogQW4gYXJyYXkgY29udGFpbmluZyBpdGVtcyBmcm9tIHdoaWNoIHNlbGVjdGlvbiB3aWxsIGJlIG1hZGUuXG4gICAgICAgICAgICovXG4gICAgICAgICAgaXRlbXM6IHtcbiAgICAgICAgICAgIHR5cGU6IEFycmF5LFxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBXaGVuIGB0cnVlYCwgbXVsdGlwbGUgaXRlbXMgbWF5IGJlIHNlbGVjdGVkIGF0IG9uY2UgKGluIHRoaXMgY2FzZSxcbiAgICAgICAgICAgKiBgc2VsZWN0ZWRgIGlzIGFuIGFycmF5IG9mIGN1cnJlbnRseSBzZWxlY3RlZCBpdGVtcykuICBXaGVuIGBmYWxzZWAsXG4gICAgICAgICAgICogb25seSBvbmUgaXRlbSBtYXkgYmUgc2VsZWN0ZWQgYXQgYSB0aW1lLlxuICAgICAgICAgICAqL1xuICAgICAgICAgIG11bHRpOiB7XG4gICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgICAgdmFsdWU6IGZhbHNlLFxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBXaGVuIGBtdWx0aWAgaXMgdHJ1ZSwgdGhpcyBpcyBhbiBhcnJheSB0aGF0IGNvbnRhaW5zIGFueSBzZWxlY3RlZC5cbiAgICAgICAgICAgKiBXaGVuIGBtdWx0aWAgaXMgZmFsc2UsIHRoaXMgaXMgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBpdGVtLCBvciBgbnVsbGBcbiAgICAgICAgICAgKiBpZiBubyBpdGVtIGlzIHNlbGVjdGVkLlxuICAgICAgICAgICAqIEB0eXBlIHs/KE9iamVjdHxBcnJheTwhT2JqZWN0Pil9XG4gICAgICAgICAgICovXG4gICAgICAgICAgc2VsZWN0ZWQ6IHtcbiAgICAgICAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgICAgICAgIG5vdGlmeTogdHJ1ZVxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBXaGVuIGBtdWx0aWAgaXMgZmFsc2UsIHRoaXMgaXMgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBpdGVtLCBvciBgbnVsbGBcbiAgICAgICAgICAgKiBpZiBubyBpdGVtIGlzIHNlbGVjdGVkLlxuICAgICAgICAgICAqIEB0eXBlIHs/T2JqZWN0fVxuICAgICAgICAgICAqL1xuICAgICAgICAgIHNlbGVjdGVkSXRlbToge1xuICAgICAgICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgICAgICAgbm90aWZ5OiB0cnVlXG4gICAgICAgICAgfSxcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFdoZW4gYHRydWVgLCBjYWxsaW5nIGBzZWxlY3RgIG9uIGFuIGl0ZW0gdGhhdCBpcyBhbHJlYWR5IHNlbGVjdGVkXG4gICAgICAgICAgICogd2lsbCBkZXNlbGVjdCB0aGUgaXRlbS5cbiAgICAgICAgICAgKi9cbiAgICAgICAgICB0b2dnbGU6IHtcbiAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzdGF0aWMgZ2V0IG9ic2VydmVycygpIHtcbiAgICAgICAgcmV0dXJuIFsnX191cGRhdGVTZWxlY3Rpb24obXVsdGksIGl0ZW1zLiopJ11cbiAgICAgIH1cblxuICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX19sYXN0SXRlbXMgPSBudWxsO1xuICAgICAgICB0aGlzLl9fbGFzdE11bHRpID0gbnVsbDtcbiAgICAgICAgdGhpcy5fX3NlbGVjdGVkTWFwID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgX191cGRhdGVTZWxlY3Rpb24obXVsdGksIGl0ZW1zSW5mbykge1xuICAgICAgICBsZXQgcGF0aCA9IGl0ZW1zSW5mby5wYXRoO1xuICAgICAgICBpZiAocGF0aCA9PSAnaXRlbXMnKSB7XG4gICAgICAgICAgLy8gQ2FzZSAxIC0gaXRlbXMgYXJyYXkgY2hhbmdlZCwgc28gZGlmZiBhZ2FpbnN0IHByZXZpb3VzIGFycmF5IGFuZFxuICAgICAgICAgIC8vIGRlc2VsZWN0IGFueSByZW1vdmVkIGl0ZW1zIGFuZCBhZGp1c3Qgc2VsZWN0ZWQgaW5kaWNlc1xuICAgICAgICAgIGxldCBuZXdJdGVtcyA9IGl0ZW1zSW5mby5iYXNlIHx8IFtdO1xuICAgICAgICAgIGxldCBsYXN0SXRlbXMgPSB0aGlzLl9fbGFzdEl0ZW1zO1xuICAgICAgICAgIGxldCBsYXN0TXVsdGkgPSB0aGlzLl9fbGFzdE11bHRpO1xuICAgICAgICAgIGlmIChtdWx0aSAhPT0gbGFzdE11bHRpKSB7XG4gICAgICAgICAgICB0aGlzLmNsZWFyU2VsZWN0aW9uKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChsYXN0SXRlbXMpIHtcbiAgICAgICAgICAgIGxldCBzcGxpY2VzID0gUG9seW1lci5BcnJheVNwbGljZS5jYWxjdWxhdGVTcGxpY2VzKG5ld0l0ZW1zLCBsYXN0SXRlbXMpO1xuICAgICAgICAgICAgdGhpcy5fX2FwcGx5U3BsaWNlcyhzcGxpY2VzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fX2xhc3RJdGVtcyA9IG5ld0l0ZW1zO1xuICAgICAgICAgIHRoaXMuX19sYXN0TXVsdGkgPSBtdWx0aTtcbiAgICAgICAgfSBlbHNlIGlmIChpdGVtc0luZm8ucGF0aCA9PSAnaXRlbXMuc3BsaWNlcycpIHtcbiAgICAgICAgICAvLyBDYXNlIDIgLSBnb3Qgc3BlY2lmaWMgc3BsaWNlIGluZm9ybWF0aW9uIGRlc2NyaWJpbmcgdGhlIGFycmF5IG11dGF0aW9uOlxuICAgICAgICAgIC8vIGRlc2VsZWN0IGFueSByZW1vdmVkIGl0ZW1zIGFuZCBhZGp1c3Qgc2VsZWN0ZWQgaW5kaWNlc1xuICAgICAgICAgIHRoaXMuX19hcHBseVNwbGljZXMoaXRlbXNJbmZvLnZhbHVlLmluZGV4U3BsaWNlcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gQ2FzZSAzIC0gYW4gYXJyYXkgZWxlbWVudCB3YXMgY2hhbmdlZCwgc28gZGVzZWxlY3QgdGhlIHByZXZpb3VzXG4gICAgICAgICAgLy8gaXRlbSBmb3IgdGhhdCBpbmRleCBpZiBpdCB3YXMgcHJldmlvdXNseSBzZWxlY3RlZFxuICAgICAgICAgIGxldCBwYXJ0ID0gcGF0aC5zbGljZSgnaXRlbXMuJy5sZW5ndGgpO1xuICAgICAgICAgIGxldCBpZHggPSBwYXJzZUludChwYXJ0LCAxMCk7XG4gICAgICAgICAgaWYgKChwYXJ0LmluZGV4T2YoJy4nKSA8IDApICYmIHBhcnQgPT0gaWR4KSB7XG4gICAgICAgICAgICB0aGlzLl9fZGVzZWxlY3RDaGFuZ2VkSWR4KGlkeCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIF9fYXBwbHlTcGxpY2VzKHNwbGljZXMpIHtcbiAgICAgICAgbGV0IHNlbGVjdGVkID0gdGhpcy5fX3NlbGVjdGVkTWFwO1xuICAgICAgICAvLyBBZGp1c3Qgc2VsZWN0ZWQgaW5kaWNlcyBhbmQgbWFyayByZW1vdmFsc1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8c3BsaWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGxldCBzID0gc3BsaWNlc1tpXTtcbiAgICAgICAgICBzZWxlY3RlZC5mb3JFYWNoKChpZHgsIGl0ZW0pID0+IHtcbiAgICAgICAgICAgIGlmIChpZHggPCBzLmluZGV4KSB7XG4gICAgICAgICAgICAgIC8vIG5vIGNoYW5nZVxuICAgICAgICAgICAgfSBlbHNlIGlmIChpZHggPj0gcy5pbmRleCArIHMucmVtb3ZlZC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgLy8gYWRqdXN0IGluZGV4XG4gICAgICAgICAgICAgIHNlbGVjdGVkLnNldChpdGVtLCBpZHggKyBzLmFkZGVkQ291bnQgLSBzLnJlbW92ZWQubGVuZ3RoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIHJlbW92ZSBpbmRleFxuICAgICAgICAgICAgICBzZWxlY3RlZC5zZXQoaXRlbSwgLTEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGZvciAobGV0IGo9MDsgajxzLmFkZGVkQ291bnQ7IGorKykge1xuICAgICAgICAgICAgbGV0IGlkeCA9IHMuaW5kZXggKyBqO1xuICAgICAgICAgICAgaWYgKHNlbGVjdGVkLmhhcyh0aGlzLml0ZW1zW2lkeF0pKSB7XG4gICAgICAgICAgICAgIHNlbGVjdGVkLnNldCh0aGlzLml0ZW1zW2lkeF0sIGlkeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFVwZGF0ZSBsaW5rZWQgcGF0aHNcbiAgICAgICAgdGhpcy5fX3VwZGF0ZUxpbmtzKCk7XG4gICAgICAgIC8vIFJlbW92ZSBzZWxlY3RlZCBpdGVtcyB0aGF0IHdlcmUgcmVtb3ZlZCBmcm9tIHRoZSBpdGVtcyBhcnJheVxuICAgICAgICBsZXQgc2lkeCA9IDA7XG4gICAgICAgIHNlbGVjdGVkLmZvckVhY2goKGlkeCwgaXRlbSkgPT4ge1xuICAgICAgICAgIGlmIChpZHggPCAwKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5tdWx0aSkge1xuICAgICAgICAgICAgICB0aGlzLnNwbGljZSgnc2VsZWN0ZWQnLCBzaWR4LCAxKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWQgPSB0aGlzLnNlbGVjdGVkSXRlbSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxlY3RlZC5kZWxldGUoaXRlbSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNpZHgrKztcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBfX3VwZGF0ZUxpbmtzKCkge1xuICAgICAgICB0aGlzLl9fZGF0YUxpbmtlZFBhdGhzID0ge307XG4gICAgICAgIGlmICh0aGlzLm11bHRpKSB7XG4gICAgICAgICAgbGV0IHNpZHggPSAwO1xuICAgICAgICAgIHRoaXMuX19zZWxlY3RlZE1hcC5mb3JFYWNoKGlkeCA9PiB7XG4gICAgICAgICAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgICAgICAgICAgdGhpcy5saW5rUGF0aHMoJ2l0ZW1zLicgKyBpZHgsICdzZWxlY3RlZC4nICsgc2lkeCsrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9fc2VsZWN0ZWRNYXAuZm9yRWFjaChpZHggPT4ge1xuICAgICAgICAgICAgdGhpcy5saW5rUGF0aHMoJ3NlbGVjdGVkJywgJ2l0ZW1zLicgKyBpZHgpO1xuICAgICAgICAgICAgdGhpcy5saW5rUGF0aHMoJ3NlbGVjdGVkSXRlbScsICdpdGVtcy4nICsgaWR4KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENsZWFycyB0aGUgc2VsZWN0aW9uIHN0YXRlLlxuICAgICAgICpcbiAgICAgICAqL1xuICAgICAgY2xlYXJTZWxlY3Rpb24oKSB7XG4gICAgICAgIC8vIFVuYmluZCBwcmV2aW91cyBzZWxlY3Rpb25cbiAgICAgICAgdGhpcy5fX2RhdGFMaW5rZWRQYXRocyA9IHt9O1xuICAgICAgICAvLyBUaGUgc2VsZWN0ZWQgbWFwIHN0b3JlcyAzIHBpZWNlcyBvZiBpbmZvcm1hdGlvbjpcbiAgICAgICAgLy8ga2V5OiBpdGVtcyBhcnJheSBvYmplY3RcbiAgICAgICAgLy8gdmFsdWU6IGl0ZW1zIGFycmF5IGluZGV4XG4gICAgICAgIC8vIG9yZGVyOiBzZWxlY3RlZCBhcnJheSBpbmRleFxuICAgICAgICB0aGlzLl9fc2VsZWN0ZWRNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8vIEluaXRpYWxpemUgc2VsZWN0aW9uXG4gICAgICAgIHRoaXMuc2VsZWN0ZWQgPSB0aGlzLm11bHRpID8gW10gOiBudWxsXG4gICAgICAgIHRoaXMuc2VsZWN0ZWRJdGVtID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGl0ZW0gaXMgY3VycmVudGx5IHNlbGVjdGVkLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7Kn0gaXRlbSBJdGVtIGZyb20gYGl0ZW1zYCBhcnJheSB0byB0ZXN0XG4gICAgICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBpdGVtIGlzIHNlbGVjdGVkXG4gICAgICAgKi9cbiAgICAgIGlzU2VsZWN0ZWQoaXRlbSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX3NlbGVjdGVkTWFwLmhhcyhpdGVtKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGl0ZW0gaXMgY3VycmVudGx5IHNlbGVjdGVkLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpZHggSW5kZXggZnJvbSBgaXRlbXNgIGFycmF5IHRvIHRlc3RcbiAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIGl0ZW0gaXMgc2VsZWN0ZWRcbiAgICAgICAqL1xuICAgICAgaXNJbmRleFNlbGVjdGVkKGlkeCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1NlbGVjdGVkKHRoaXMuaXRlbXNbaWR4XSk7XG4gICAgICB9XG5cbiAgICAgIF9fZGVzZWxlY3RDaGFuZ2VkSWR4KGlkeCkge1xuICAgICAgICBsZXQgc2lkeCA9IHRoaXMuX19zZWxlY3RlZEluZGV4Rm9ySXRlbUluZGV4KGlkeCk7XG4gICAgICAgIGlmIChzaWR4ID49IDApIHtcbiAgICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgICAgdGhpcy5fX3NlbGVjdGVkTWFwLmZvckVhY2goKGlkeCwgaXRlbSkgPT4ge1xuICAgICAgICAgICAgaWYgKHNpZHggPT0gaSsrKSB7XG4gICAgICAgICAgICAgIHRoaXMuZGVzZWxlY3QoaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgX19zZWxlY3RlZEluZGV4Rm9ySXRlbUluZGV4KGlkeCkge1xuICAgICAgICBsZXQgc2VsZWN0ZWQgPSB0aGlzLl9fZGF0YUxpbmtlZFBhdGhzWydpdGVtcy4nICsgaWR4XTtcbiAgICAgICAgaWYgKHNlbGVjdGVkKSB7XG4gICAgICAgICAgcmV0dXJuIHBhcnNlSW50KHNlbGVjdGVkLnNsaWNlKCdzZWxlY3RlZC4nLmxlbmd0aCksIDEwKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIERlc2VsZWN0cyB0aGUgZ2l2ZW4gaXRlbSBpZiBpdCBpcyBhbHJlYWR5IHNlbGVjdGVkLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7Kn0gaXRlbSBJdGVtIGZyb20gYGl0ZW1zYCBhcnJheSB0byBkZXNlbGVjdFxuICAgICAgICovXG4gICAgICBkZXNlbGVjdChpdGVtKSB7XG4gICAgICAgIGxldCBpZHggPSB0aGlzLl9fc2VsZWN0ZWRNYXAuZ2V0KGl0ZW0pO1xuICAgICAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgICAgICB0aGlzLl9fc2VsZWN0ZWRNYXAuZGVsZXRlKGl0ZW0pO1xuICAgICAgICAgIGxldCBzaWR4O1xuICAgICAgICAgIGlmICh0aGlzLm11bHRpKSB7XG4gICAgICAgICAgICBzaWR4ID0gdGhpcy5fX3NlbGVjdGVkSW5kZXhGb3JJdGVtSW5kZXgoaWR4KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fX3VwZGF0ZUxpbmtzKCk7XG4gICAgICAgICAgaWYgKHRoaXMubXVsdGkpIHtcbiAgICAgICAgICAgIHRoaXMuc3BsaWNlKCdzZWxlY3RlZCcsIHNpZHgsIDEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkID0gdGhpcy5zZWxlY3RlZEl0ZW0gPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIERlc2VsZWN0cyB0aGUgZ2l2ZW4gaW5kZXggaWYgaXQgaXMgYWxyZWFkeSBzZWxlY3RlZC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0gaWR4IEluZGV4IGZyb20gYGl0ZW1zYCBhcnJheSB0byBkZXNlbGVjdFxuICAgICAgICovXG4gICAgICBkZXNlbGVjdEluZGV4KGlkeCkge1xuICAgICAgICB0aGlzLmRlc2VsZWN0KHRoaXMuaXRlbXNbaWR4XSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogU2VsZWN0cyB0aGUgZ2l2ZW4gaXRlbS4gIFdoZW4gYHRvZ2dsZWAgaXMgdHJ1ZSwgdGhpcyB3aWxsIGF1dG9tYXRpY2FsbHlcbiAgICAgICAqIGRlc2VsZWN0IHRoZSBpdGVtIGlmIGFscmVhZHkgc2VsZWN0ZWQuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHsqfSBpdGVtIEl0ZW0gZnJvbSBgaXRlbXNgIGFycmF5IHRvIHNlbGVjdFxuICAgICAgICovXG4gICAgICBzZWxlY3QoaXRlbSkge1xuICAgICAgICB0aGlzLnNlbGVjdEluZGV4KHRoaXMuaXRlbXMuaW5kZXhPZihpdGVtKSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogU2VsZWN0cyB0aGUgZ2l2ZW4gaW5kZXguICBXaGVuIGB0b2dnbGVgIGlzIHRydWUsIHRoaXMgd2lsbCBhdXRvbWF0aWNhbGx5XG4gICAgICAgKiBkZXNlbGVjdCB0aGUgaXRlbSBpZiBhbHJlYWR5IHNlbGVjdGVkLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpZHggSW5kZXggZnJvbSBgaXRlbXNgIGFycmF5IHRvIHNlbGVjdFxuICAgICAgICovXG4gICAgICBzZWxlY3RJbmRleChpZHgpIHtcbiAgICAgICAgbGV0IGl0ZW0gPSB0aGlzLml0ZW1zW2lkeF07XG4gICAgICAgIGlmICghdGhpcy5pc1NlbGVjdGVkKGl0ZW0pKSB7XG4gICAgICAgICAgaWYgKCF0aGlzLm11bHRpKSB7XG4gICAgICAgICAgICB0aGlzLl9fc2VsZWN0ZWRNYXAuY2xlYXIoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fX3NlbGVjdGVkTWFwLnNldChpdGVtLCBpZHgpO1xuICAgICAgICAgIHRoaXMuX191cGRhdGVMaW5rcygpO1xuICAgICAgICAgIGlmICh0aGlzLm11bHRpKSB7XG4gICAgICAgICAgICB0aGlzLnB1c2goJ3NlbGVjdGVkJywgaXRlbSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWQgPSB0aGlzLnNlbGVjdGVkSXRlbSA9IGl0ZW07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMudG9nZ2xlKSB7XG4gICAgICAgICAgdGhpcy5kZXNlbGVjdEluZGV4KGlkeCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgIH1cblxuICAgIHJldHVybiBBcnJheVNlbGVjdG9yTWl4aW47XG5cbiAgfSk7XG5cbiAgLy8gZXhwb3J0IG1peGluXG4gIFBvbHltZXIuQXJyYXlTZWxlY3Rvck1peGluID0gQXJyYXlTZWxlY3Rvck1peGluO1xuXG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQGV4dGVuZHMge1BvbHltZXIuRWxlbWVudH1cbiAgICogQGltcGxlbWVudHMge1BvbHltZXJfQXJyYXlTZWxlY3Rvck1peGlufVxuICAgKi9cbiAgbGV0IGJhc2VBcnJheVNlbGVjdG9yID0gQXJyYXlTZWxlY3Rvck1peGluKFBvbHltZXIuRWxlbWVudCk7XG5cbiAgLyoqXG4gICAqIEVsZW1lbnQgaW1wbGVtZW50aW5nIHRoZSBgUG9seW1lci5BcnJheVNlbGVjdG9yYCBtaXhpbiwgd2hpY2ggcmVjb3Jkc1xuICAgKiBkeW5hbWljIGFzc29jaWF0aW9ucyBiZXR3ZWVuIGl0ZW0gcGF0aHMgaW4gYSBtYXN0ZXIgYGl0ZW1zYCBhcnJheSBhbmQgYVxuICAgKiBgc2VsZWN0ZWRgIGFycmF5IHN1Y2ggdGhhdCBwYXRoIGNoYW5nZXMgdG8gdGhlIG1hc3RlciBhcnJheSAoYXQgdGhlIGhvc3QpXG4gICAqIGVsZW1lbnQgb3IgZWxzZXdoZXJlIHZpYSBkYXRhLWJpbmRpbmcpIGFyZSBjb3JyZWN0bHkgcHJvcGFnYXRlZCB0byBpdGVtc1xuICAgKiBpbiB0aGUgc2VsZWN0ZWQgYXJyYXkgYW5kIHZpY2UtdmVyc2EuXG4gICAqXG4gICAqIFRoZSBgaXRlbXNgIHByb3BlcnR5IGFjY2VwdHMgYW4gYXJyYXkgb2YgdXNlciBkYXRhLCBhbmQgdmlhIHRoZVxuICAgKiBgc2VsZWN0KGl0ZW0pYCBhbmQgYGRlc2VsZWN0KGl0ZW0pYCBBUEksIHVwZGF0ZXMgdGhlIGBzZWxlY3RlZGAgcHJvcGVydHlcbiAgICogd2hpY2ggbWF5IGJlIGJvdW5kIHRvIG90aGVyIHBhcnRzIG9mIHRoZSBhcHBsaWNhdGlvbiwgYW5kIGFueSBjaGFuZ2VzIHRvXG4gICAqIHN1Yi1maWVsZHMgb2YgYHNlbGVjdGVkYCBpdGVtKHMpIHdpbGwgYmUga2VwdCBpbiBzeW5jIHdpdGggaXRlbXMgaW4gdGhlXG4gICAqIGBpdGVtc2AgYXJyYXkuICBXaGVuIGBtdWx0aWAgaXMgZmFsc2UsIGBzZWxlY3RlZGAgaXMgYSBwcm9wZXJ0eVxuICAgKiByZXByZXNlbnRpbmcgdGhlIGxhc3Qgc2VsZWN0ZWQgaXRlbS4gIFdoZW4gYG11bHRpYCBpcyB0cnVlLCBgc2VsZWN0ZWRgXG4gICAqIGlzIGFuIGFycmF5IG9mIG11bHRpcGx5IHNlbGVjdGVkIGl0ZW1zLlxuICAgKlxuICAgKiBFeGFtcGxlOlxuICAgKlxuICAgKiBgYGBodG1sXG4gICAqIDxkb20tbW9kdWxlIGlkPVwiZW1wbG95ZWUtbGlzdFwiPlxuICAgKlxuICAgKiAgIDx0ZW1wbGF0ZT5cbiAgICpcbiAgICogICAgIDxkaXY+IEVtcGxveWVlIGxpc3Q6IDwvZGl2PlxuICAgKiAgICAgPHRlbXBsYXRlIGlzPVwiZG9tLXJlcGVhdFwiIGlkPVwiZW1wbG95ZWVMaXN0XCIgaXRlbXM9XCJ7e2VtcGxveWVlc319XCI+XG4gICAqICAgICAgICAgPGRpdj5GaXJzdCBuYW1lOiA8c3Bhbj57e2l0ZW0uZmlyc3R9fTwvc3Bhbj48L2Rpdj5cbiAgICogICAgICAgICA8ZGl2Pkxhc3QgbmFtZTogPHNwYW4+e3tpdGVtLmxhc3R9fTwvc3Bhbj48L2Rpdj5cbiAgICogICAgICAgICA8YnV0dG9uIG9uLWNsaWNrPVwidG9nZ2xlU2VsZWN0aW9uXCI+U2VsZWN0PC9idXR0b24+XG4gICAqICAgICA8L3RlbXBsYXRlPlxuICAgKlxuICAgKiAgICAgPGFycmF5LXNlbGVjdG9yIGlkPVwic2VsZWN0b3JcIiBpdGVtcz1cInt7ZW1wbG95ZWVzfX1cIiBzZWxlY3RlZD1cInt7c2VsZWN0ZWR9fVwiIG11bHRpIHRvZ2dsZT48L2FycmF5LXNlbGVjdG9yPlxuICAgKlxuICAgKiAgICAgPGRpdj4gU2VsZWN0ZWQgZW1wbG95ZWVzOiA8L2Rpdj5cbiAgICogICAgIDx0ZW1wbGF0ZSBpcz1cImRvbS1yZXBlYXRcIiBpdGVtcz1cInt7c2VsZWN0ZWR9fVwiPlxuICAgKiAgICAgICAgIDxkaXY+Rmlyc3QgbmFtZTogPHNwYW4+e3tpdGVtLmZpcnN0fX08L3NwYW4+PC9kaXY+XG4gICAqICAgICAgICAgPGRpdj5MYXN0IG5hbWU6IDxzcGFuPnt7aXRlbS5sYXN0fX08L3NwYW4+PC9kaXY+XG4gICAqICAgICA8L3RlbXBsYXRlPlxuICAgKlxuICAgKiAgIDwvdGVtcGxhdGU+XG4gICAqXG4gICAqIDwvZG9tLW1vZHVsZT5cbiAgICogYGBgXG4gICAqXG4gICAqIGBgYGpzXG4gICAqIFBvbHltZXIoe1xuICAgKiAgIGlzOiAnZW1wbG95ZWUtbGlzdCcsXG4gICAqICAgcmVhZHkoKSB7XG4gICAqICAgICB0aGlzLmVtcGxveWVlcyA9IFtcbiAgICogICAgICAgICB7Zmlyc3Q6ICdCb2InLCBsYXN0OiAnU21pdGgnfSxcbiAgICogICAgICAgICB7Zmlyc3Q6ICdTYWxseScsIGxhc3Q6ICdKb2huc29uJ30sXG4gICAqICAgICAgICAgLi4uXG4gICAqICAgICBdO1xuICAgKiAgIH0sXG4gICAqICAgdG9nZ2xlU2VsZWN0aW9uKGUpIHtcbiAgICogICAgIGxldCBpdGVtID0gdGhpcy4kLmVtcGxveWVlTGlzdC5pdGVtRm9yRWxlbWVudChlLnRhcmdldCk7XG4gICAqICAgICB0aGlzLiQuc2VsZWN0b3Iuc2VsZWN0KGl0ZW0pO1xuICAgKiAgIH1cbiAgICogfSk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBAcG9seW1lclxuICAgKiBAY3VzdG9tRWxlbWVudFxuICAgKiBAZXh0ZW5kcyB7YmFzZUFycmF5U2VsZWN0b3J9XG4gICAqIEBhcHBsaWVzTWl4aW4gUG9seW1lci5BcnJheVNlbGVjdG9yTWl4aW5cbiAgICogQG1lbWJlcm9mIFBvbHltZXJcbiAgICogQHN1bW1hcnkgQ3VzdG9tIGVsZW1lbnQgdGhhdCBsaW5rcyBwYXRocyBiZXR3ZWVuIGFuIGlucHV0IGBpdGVtc2AgYXJyYXkgYW5kXG4gICAqICAgYW4gb3V0cHV0IGBzZWxlY3RlZGAgaXRlbSBvciBhcnJheSBiYXNlZCBvbiBjYWxscyB0byBpdHMgc2VsZWN0aW9uIEFQSS5cbiAgICovXG4gIGNsYXNzIEFycmF5U2VsZWN0b3IgZXh0ZW5kcyBiYXNlQXJyYXlTZWxlY3RvciB7XG4gICAgLy8gTm90IG5lZWRlZCB0byBmaW5kIHRlbXBsYXRlOyBjYW4gYmUgcmVtb3ZlZCBvbmNlIHRoZSBhbmFseXplclxuICAgIC8vIGNhbiBmaW5kIHRoZSB0YWcgbmFtZSBmcm9tIGN1c3RvbUVsZW1lbnRzLmRlZmluZSBjYWxsXG4gICAgc3RhdGljIGdldCBpcygpIHsgcmV0dXJuICdhcnJheS1zZWxlY3RvcicgfVxuICB9XG4gIGN1c3RvbUVsZW1lbnRzLmRlZmluZShBcnJheVNlbGVjdG9yLmlzLCBBcnJheVNlbGVjdG9yKTtcbiAgUG9seW1lci5BcnJheVNlbGVjdG9yID0gQXJyYXlTZWxlY3RvcjtcblxufSkoKTtcblxuPC9zY3JpcHQ+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL3BvbHltZXIvbGliL2VsZW1lbnRzL2FycmF5LXNlbGVjdG9yLmh0bWwiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vLi4vLi4vc2hhZHljc3MvY3VzdG9tLXN0eWxlLWludGVyZmFjZS5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vdXRpbHMvc3R5bGUtZ2F0aGVyLmh0bWxcIj5cbjxzY3JpcHQ+XG4oZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBjb25zdCBhdHRyID0gJ2luY2x1ZGUnO1xuXG4gIGNvbnN0IEN1c3RvbVN0eWxlSW50ZXJmYWNlID0gd2luZG93LlNoYWR5Q1NTLkN1c3RvbVN0eWxlSW50ZXJmYWNlO1xuXG4gIC8qKlxuICAgKiBDdXN0b20gZWxlbWVudCBmb3IgZGVmaW5pbmcgc3R5bGVzIGluIHRoZSBtYWluIGRvY3VtZW50IHRoYXQgY2FuIHRha2VcbiAgICogYWR2YW50YWdlIG9mIHNldmVyYWwgc3BlY2lhbCBmZWF0dXJlcyBvZiBQb2x5bWVyJ3Mgc3R5bGluZyBzeXN0ZW06XG4gICAqXG4gICAqIC0gRG9jdW1lbnQgc3R5bGVzIGRlZmluZWQgaW4gYSBjdXN0b20tc3R5bGUgYXJlIHNoaW1tZWQgdG8gZW5zdXJlIHRoZXlcbiAgICogICBkbyBub3QgbGVhayBpbnRvIGxvY2FsIERPTSB3aGVuIHJ1bm5pbmcgb24gYnJvd3NlcnMgd2l0aG91dCBuYXRpdmVcbiAgICogICBTaGFkb3cgRE9NLlxuICAgKiAtIEN1c3RvbSBwcm9wZXJ0aWVzIHVzZWQgYnkgUG9seW1lcidzIHNoaW0gZm9yIGNyb3NzLXNjb3BlIHN0eWxpbmcgbWF5XG4gICAqICAgYmUgZGVmaW5lZCBpbiBhbiBjdXN0b20tc3R5bGUuIFVzZSB0aGUgOnJvb3Qgc2VsZWN0b3IgdG8gZGVmaW5lIGN1c3RvbVxuICAgKiAgIHByb3BlcnRpZXMgdGhhdCBhcHBseSB0byBhbGwgY3VzdG9tIGVsZW1lbnRzLlxuICAgKlxuICAgKiBUbyB1c2UsIHNpbXBseSB3cmFwIGFuIGlubGluZSBgPHN0eWxlPmAgdGFnIGluIHRoZSBtYWluIGRvY3VtZW50IHdob3NlXG4gICAqIENTUyB1c2VzIHRoZXNlIGZlYXR1cmVzIHdpdGggYSBgPGN1c3RvbS1zdHlsZT5gIGVsZW1lbnQuXG4gICAqXG4gICAqIEBjdXN0b21FbGVtZW50XG4gICAqIEBleHRlbmRzIEhUTUxFbGVtZW50XG4gICAqIEBtZW1iZXJvZiBQb2x5bWVyXG4gICAqIEBzdW1tYXJ5IEN1c3RvbSBlbGVtZW50IGZvciBkZWZpbmluZyBzdHlsZXMgaW4gdGhlIG1haW4gZG9jdW1lbnQgdGhhdCBjYW5cbiAgICogICB0YWtlIGFkdmFudGFnZSBvZiBQb2x5bWVyJ3Mgc3R5bGUgc2NvcGluZyBhbmQgY3VzdG9tIHByb3BlcnRpZXMgc2hpbXMuXG4gICAqL1xuICBjbGFzcyBDdXN0b21TdHlsZSBleHRlbmRzIEhUTUxFbGVtZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgIHN1cGVyKCk7XG4gICAgICB0aGlzLl9zdHlsZSA9IG51bGw7XG4gICAgICBDdXN0b21TdHlsZUludGVyZmFjZS5hZGRDdXN0b21TdHlsZSh0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbGlnaHQtRE9NIGA8c3R5bGU+YCBjaGlsZCB0aGlzIGVsZW1lbnQgd3JhcHMuICBVcG9uIGZpcnN0XG4gICAgICogY2FsbCBhbnkgc3R5bGUgbW9kdWxlcyByZWZlcmVuY2VkIHZpYSB0aGUgYGluY2x1ZGVgIGF0dHJpYnV0ZSB3aWxsIGJlXG4gICAgICogY29uY2F0ZW5hdGVkIHRvIHRoaXMgZWxlbWVudCdzIGA8c3R5bGU+YC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0hUTUxTdHlsZUVsZW1lbnR9IFRoaXMgZWxlbWVudCdzIGxpZ2h0LURPTSBgPHN0eWxlPmBcbiAgICAgKi9cbiAgICBnZXRTdHlsZSgpIHtcbiAgICAgIGlmICh0aGlzLl9zdHlsZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3R5bGU7XG4gICAgICB9XG4gICAgICBjb25zdCBzdHlsZSA9IC8qKiBAdHlwZSB7SFRNTFN0eWxlRWxlbWVudH0gKi8odGhpcy5xdWVyeVNlbGVjdG9yKCdzdHlsZScpKTtcbiAgICAgIGlmICghc3R5bGUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICB0aGlzLl9zdHlsZSA9IHN0eWxlO1xuICAgICAgY29uc3QgaW5jbHVkZSA9IHN0eWxlLmdldEF0dHJpYnV0ZShhdHRyKTtcbiAgICAgIGlmIChpbmNsdWRlKSB7XG4gICAgICAgIHN0eWxlLnJlbW92ZUF0dHJpYnV0ZShhdHRyKTtcbiAgICAgICAgc3R5bGUudGV4dENvbnRlbnQgPSBQb2x5bWVyLlN0eWxlR2F0aGVyLmNzc0Zyb21Nb2R1bGVzKGluY2x1ZGUpICsgc3R5bGUudGV4dENvbnRlbnQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fc3R5bGU7XG4gICAgfVxuICB9XG5cbiAgd2luZG93LmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnY3VzdG9tLXN0eWxlJywgQ3VzdG9tU3R5bGUpO1xuICBQb2x5bWVyLkN1c3RvbVN0eWxlID0gQ3VzdG9tU3R5bGU7XG59KSgpO1xuPC9zY3JpcHQ+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL3BvbHltZXIvbGliL2VsZW1lbnRzL2N1c3RvbS1zdHlsZS5odG1sIiwiXG5yZXF1aXJlKCcuL2N1c3RvbS1zdHlsZS1pbnRlcmZhY2UubWluLmpzJyk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL3NoYWR5Y3NzL2N1c3RvbS1zdHlsZS1pbnRlcmZhY2UuaHRtbCIsIihmdW5jdGlvbigpey8qXG5cbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiovXG4ndXNlIHN0cmljdCc7dmFyIGM9ISh3aW5kb3cuU2hhZHlET00mJndpbmRvdy5TaGFkeURPTS5pblVzZSksZjtmdW5jdGlvbiBnKGEpe2Y9YSYmYS5zaGltY3NzcHJvcGVydGllcz8hMTpjfHwhKG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL0FwcGxlV2ViS2l0XFwvNjAxfEVkZ2VcXC8xNS8pfHwhd2luZG93LkNTU3x8IUNTUy5zdXBwb3J0c3x8IUNTUy5zdXBwb3J0cyhcImJveC1zaGFkb3dcIixcIjAgMCAwIHZhcigtLWZvbylcIikpfXdpbmRvdy5TaGFkeUNTUyYmdm9pZCAwIT09d2luZG93LlNoYWR5Q1NTLm5hdGl2ZUNzcz9mPXdpbmRvdy5TaGFkeUNTUy5uYXRpdmVDc3M6d2luZG93LlNoYWR5Q1NTPyhnKHdpbmRvdy5TaGFkeUNTUyksd2luZG93LlNoYWR5Q1NTPXZvaWQgMCk6Zyh3aW5kb3cuV2ViQ29tcG9uZW50cyYmd2luZG93LldlYkNvbXBvbmVudHMuZmxhZ3MpO3ZhciBoPWY7ZnVuY3Rpb24gayhhLGIpe2Zvcih2YXIgZCBpbiBiKW51bGw9PT1kP2Euc3R5bGUucmVtb3ZlUHJvcGVydHkoZCk6YS5zdHlsZS5zZXRQcm9wZXJ0eShkLGJbZF0pfTt2YXIgbD1udWxsLG09d2luZG93LkhUTUxJbXBvcnRzJiZ3aW5kb3cuSFRNTEltcG9ydHMud2hlblJlYWR5fHxudWxsLG47ZnVuY3Rpb24gcCgpe3ZhciBhPXE7cmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCl7bT9tKGEpOihsfHwobD1uZXcgUHJvbWlzZShmdW5jdGlvbihhKXtuPWF9KSxcImNvbXBsZXRlXCI9PT1kb2N1bWVudC5yZWFkeVN0YXRlP24oKTpkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwicmVhZHlzdGF0ZWNoYW5nZVwiLGZ1bmN0aW9uKCl7XCJjb21wbGV0ZVwiPT09ZG9jdW1lbnQucmVhZHlTdGF0ZSYmbigpfSkpLGwudGhlbihmdW5jdGlvbigpe2EmJmEoKX0pKX0pfTt2YXIgcj1udWxsLHE9bnVsbDtmdW5jdGlvbiB0KCl7dGhpcy5jdXN0b21TdHlsZXM9W107dGhpcy5lbnF1ZXVlZD0hMX1mdW5jdGlvbiB1KGEpeyFhLmVucXVldWVkJiZxJiYoYS5lbnF1ZXVlZD0hMCxwKCkpfXQucHJvdG90eXBlLmM9ZnVuY3Rpb24oYSl7YS5fX3NlZW5CeVNoYWR5Q1NTfHwoYS5fX3NlZW5CeVNoYWR5Q1NTPSEwLHRoaXMuY3VzdG9tU3R5bGVzLnB1c2goYSksdSh0aGlzKSl9O3QucHJvdG90eXBlLmI9ZnVuY3Rpb24oYSl7aWYoYS5fX3NoYWR5Q1NTQ2FjaGVkU3R5bGUpcmV0dXJuIGEuX19zaGFkeUNTU0NhY2hlZFN0eWxlO3ZhciBiO2EuZ2V0U3R5bGU/Yj1hLmdldFN0eWxlKCk6Yj1hO3JldHVybiBifTtcbnQucHJvdG90eXBlLmE9ZnVuY3Rpb24oKXtmb3IodmFyIGE9dGhpcy5jdXN0b21TdHlsZXMsYj0wO2I8YS5sZW5ndGg7YisrKXt2YXIgZD1hW2JdO2lmKCFkLl9fc2hhZHlDU1NDYWNoZWRTdHlsZSl7dmFyIGU9dGhpcy5iKGQpO2UmJihlPWUuX19hcHBsaWVkRWxlbWVudHx8ZSxyJiZyKGUpLGQuX19zaGFkeUNTU0NhY2hlZFN0eWxlPWUpfX1yZXR1cm4gYX07dC5wcm90b3R5cGUuYWRkQ3VzdG9tU3R5bGU9dC5wcm90b3R5cGUuYzt0LnByb3RvdHlwZS5nZXRTdHlsZUZvckN1c3RvbVN0eWxlPXQucHJvdG90eXBlLmI7dC5wcm90b3R5cGUucHJvY2Vzc1N0eWxlcz10LnByb3RvdHlwZS5hO1xuT2JqZWN0LmRlZmluZVByb3BlcnRpZXModC5wcm90b3R5cGUse3RyYW5zZm9ybUNhbGxiYWNrOntnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gcn0sc2V0OmZ1bmN0aW9uKGEpe3I9YX19LHZhbGlkYXRlQ2FsbGJhY2s6e2dldDpmdW5jdGlvbigpe3JldHVybiBxfSxzZXQ6ZnVuY3Rpb24oYSl7dmFyIGI9ITE7cXx8KGI9ITApO3E9YTtiJiZ1KHRoaXMpfX19KTt2YXIgdj1uZXcgdDt3aW5kb3cuU2hhZHlDU1N8fCh3aW5kb3cuU2hhZHlDU1M9e3ByZXBhcmVUZW1wbGF0ZTpmdW5jdGlvbigpe30sc3R5bGVTdWJ0cmVlOmZ1bmN0aW9uKGEsYil7di5hKCk7ayhhLGIpfSxzdHlsZUVsZW1lbnQ6ZnVuY3Rpb24oKXt2LmEoKX0sc3R5bGVEb2N1bWVudDpmdW5jdGlvbihhKXt2LmEoKTtrKGRvY3VtZW50LmJvZHksYSl9LGdldENvbXB1dGVkU3R5bGVWYWx1ZTpmdW5jdGlvbihhLGIpe3JldHVybihhPXdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGEpLmdldFByb3BlcnR5VmFsdWUoYikpP2EudHJpbSgpOlwiXCJ9LG5hdGl2ZUNzczpoLG5hdGl2ZVNoYWRvdzpjfSk7d2luZG93LlNoYWR5Q1NTLkN1c3RvbVN0eWxlSW50ZXJmYWNlPXY7fSkuY2FsbCh0aGlzKTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3VzdG9tLXN0eWxlLWludGVyZmFjZS5taW4uanMubWFwXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL3NoYWR5Y3NzL2N1c3RvbS1zdHlsZS1pbnRlcmZhY2UubWluLmpzIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuXG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vbWl4aW5zL211dGFibGUtZGF0YS5odG1sXCI+XG5cbjxzY3JpcHQ+XG4oZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBsZXQgbXV0YWJsZVByb3BlcnR5Q2hhbmdlO1xuICAoXG4gICAgLyoqIEBzdXBwcmVzcyB7bWlzc2luZ1Byb3BlcnRpZXN9ICovXG4gICAgZnVuY3Rpb24oKSB7XG4gICAgbXV0YWJsZVByb3BlcnR5Q2hhbmdlID0gUG9seW1lci5NdXRhYmxlRGF0YS5fbXV0YWJsZVByb3BlcnR5Q2hhbmdlO1xuICB9KSgpO1xuXG4gIC8qKlxuICAgKiBMZWdhY3kgZWxlbWVudCBiZWhhdmlvciB0byBza2lwIHN0cmljdCBkaXJ0eS1jaGVja2luZyBmb3Igb2JqZWN0cyBhbmQgYXJyYXlzLFxuICAgKiAoYWx3YXlzIGNvbnNpZGVyIHRoZW0gdG8gYmUgXCJkaXJ0eVwiKSBmb3IgdXNlIG9uIGxlZ2FjeSBBUEkgUG9seW1lciBlbGVtZW50cy5cbiAgICpcbiAgICogQnkgZGVmYXVsdCwgYFBvbHltZXIuUHJvcGVydHlFZmZlY3RzYCBwZXJmb3JtcyBzdHJpY3QgZGlydHkgY2hlY2tpbmcgb25cbiAgICogb2JqZWN0cywgd2hpY2ggbWVhbnMgdGhhdCBhbnkgZGVlcCBtb2RpZmljYXRpb25zIHRvIGFuIG9iamVjdCBvciBhcnJheSB3aWxsXG4gICAqIG5vdCBiZSBwcm9wYWdhdGVkIHVubGVzcyBcImltbXV0YWJsZVwiIGRhdGEgcGF0dGVybnMgYXJlIHVzZWQgKGkuZS4gYWxsIG9iamVjdFxuICAgKiByZWZlcmVuY2VzIGZyb20gdGhlIHJvb3QgdG8gdGhlIG11dGF0aW9uIHdlcmUgY2hhbmdlZCkuXG4gICAqXG4gICAqIFBvbHltZXIgYWxzbyBwcm92aWRlcyBhIHByb3ByaWV0YXJ5IGRhdGEgbXV0YXRpb24gYW5kIHBhdGggbm90aWZpY2F0aW9uIEFQSVxuICAgKiAoZS5nLiBgbm90aWZ5UGF0aGAsIGBzZXRgLCBhbmQgYXJyYXkgbXV0YXRpb24gQVBJJ3MpIHRoYXQgYWxsb3cgZWZmaWNpZW50XG4gICAqIG11dGF0aW9uIGFuZCBub3RpZmljYXRpb24gb2YgZGVlcCBjaGFuZ2VzIGluIGFuIG9iamVjdCBncmFwaCB0byBhbGwgZWxlbWVudHNcbiAgICogYm91bmQgdG8gdGhlIHNhbWUgb2JqZWN0IGdyYXBoLlxuICAgKlxuICAgKiBJbiBjYXNlcyB3aGVyZSBuZWl0aGVyIGltbXV0YWJsZSBwYXR0ZXJucyBub3IgdGhlIGRhdGEgbXV0YXRpb24gQVBJIGNhbiBiZVxuICAgKiB1c2VkLCBhcHBseWluZyB0aGlzIG1peGluIHdpbGwgY2F1c2UgUG9seW1lciB0byBza2lwIGRpcnR5IGNoZWNraW5nIGZvclxuICAgKiBvYmplY3RzIGFuZCBhcnJheXMgKGFsd2F5cyBjb25zaWRlciB0aGVtIHRvIGJlIFwiZGlydHlcIikuICBUaGlzIGFsbG93cyBhXG4gICAqIHVzZXIgdG8gbWFrZSBhIGRlZXAgbW9kaWZpY2F0aW9uIHRvIGEgYm91bmQgb2JqZWN0IGdyYXBoLCBhbmQgdGhlbiBlaXRoZXJcbiAgICogc2ltcGx5IHJlLXNldCB0aGUgb2JqZWN0IChlLmcuIGB0aGlzLml0ZW1zID0gdGhpcy5pdGVtc2ApIG9yIGNhbGwgYG5vdGlmeVBhdGhgXG4gICAqIChlLmcuIGB0aGlzLm5vdGlmeVBhdGgoJ2l0ZW1zJylgKSB0byB1cGRhdGUgdGhlIHRyZWUuICBOb3RlIHRoYXQgYWxsXG4gICAqIGVsZW1lbnRzIHRoYXQgd2lzaCB0byBiZSB1cGRhdGVkIGJhc2VkIG9uIGRlZXAgbXV0YXRpb25zIG11c3QgYXBwbHkgdGhpc1xuICAgKiBtaXhpbiBvciBvdGhlcndpc2Ugc2tpcCBzdHJpY3QgZGlydHkgY2hlY2tpbmcgZm9yIG9iamVjdHMvYXJyYXlzLlxuICAgKlxuICAgKiBJbiBvcmRlciB0byBtYWtlIHRoZSBkaXJ0eSBjaGVjayBzdHJhdGVneSBjb25maWd1cmFibGUsIHNlZVxuICAgKiBgUG9seW1lci5PcHRpb25hbE11dGFibGVEYXRhQmVoYXZpb3JgLlxuICAgKlxuICAgKiBOb3RlLCB0aGUgcGVyZm9ybWFuY2UgY2hhcmFjdGVyaXN0aWNzIG9mIHByb3BhZ2F0aW5nIGxhcmdlIG9iamVjdCBncmFwaHNcbiAgICogd2lsbCBiZSB3b3JzZSBhcyBvcHBvc2VkIHRvIHVzaW5nIHN0cmljdCBkaXJ0eSBjaGVja2luZyB3aXRoIGltbXV0YWJsZVxuICAgKiBwYXR0ZXJucyBvciBQb2x5bWVyJ3MgcGF0aCBub3RpZmljYXRpb24gQVBJLlxuICAgKlxuICAgKiBAcG9seW1lckJlaGF2aW9yXG4gICAqIEBtZW1iZXJvZiBQb2x5bWVyXG4gICAqIEBzdW1tYXJ5IEJlaGF2aW9yIHRvIHNraXAgc3RyaWN0IGRpcnR5LWNoZWNraW5nIGZvciBvYmplY3RzIGFuZFxuICAgKiAgIGFycmF5c1xuICAgKi9cbiAgUG9seW1lci5NdXRhYmxlRGF0YUJlaGF2aW9yID0ge1xuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGVzIGBQb2x5bWVyLlByb3BlcnR5RWZmZWN0c2AgdG8gcHJvdmlkZSBvcHRpb24gZm9yIHNraXBwaW5nXG4gICAgICogc3RyaWN0IGVxdWFsaXR5IGNoZWNraW5nIGZvciBPYmplY3RzIGFuZCBBcnJheXMuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBwdWxscyB0aGUgdmFsdWUgdG8gZGlydHkgY2hlY2sgYWdhaW5zdCBmcm9tIHRoZSBgX19kYXRhVGVtcGBcbiAgICAgKiBjYWNoZSAocmF0aGVyIHRoYW4gdGhlIG5vcm1hbCBgX19kYXRhYCBjYWNoZSkgZm9yIE9iamVjdHMuICBTaW5jZSB0aGUgdGVtcFxuICAgICAqIGNhY2hlIGlzIGNsZWFyZWQgYXQgdGhlIGVuZCBvZiBhIHR1cm4sIHRoaXMgaW1wbGVtZW50YXRpb24gYWxsb3dzXG4gICAgICogc2lkZS1lZmZlY3RzIG9mIGRlZXAgb2JqZWN0IGNoYW5nZXMgdG8gYmUgcHJvY2Vzc2VkIGJ5IHJlLXNldHRpbmcgdGhlXG4gICAgICogc2FtZSBvYmplY3QgKHVzaW5nIHRoZSB0ZW1wIGNhY2hlIGFzIGFuIGluLXR1cm4gYmFja3N0b3AgdG8gcHJldmVudFxuICAgICAqIGN5Y2xlcyBkdWUgdG8gMi13YXkgbm90aWZpY2F0aW9uKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSBuYW1lXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBOZXcgcHJvcGVydHkgdmFsdWVcbiAgICAgKiBAcGFyYW0geyp9IG9sZCBQcmV2aW91cyBwcm9wZXJ0eSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIHByb3BlcnR5IHNob3VsZCBiZSBjb25zaWRlcmVkIGEgY2hhbmdlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9zaG91bGRQcm9wZXJ0eUNoYW5nZShwcm9wZXJ0eSwgdmFsdWUsIG9sZCkge1xuICAgICAgcmV0dXJuIG11dGFibGVQcm9wZXJ0eUNoYW5nZSh0aGlzLCBwcm9wZXJ0eSwgdmFsdWUsIG9sZCwgdHJ1ZSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBMZWdhY3kgZWxlbWVudCBiZWhhdmlvciB0byBhZGQgdGhlIG9wdGlvbmFsIGFiaWxpdHkgdG8gc2tpcCBzdHJpY3RcbiAgICogZGlydHktY2hlY2tpbmcgZm9yIG9iamVjdHMgYW5kIGFycmF5cyAoYWx3YXlzIGNvbnNpZGVyIHRoZW0gdG8gYmVcbiAgICogXCJkaXJ0eVwiKSBieSBzZXR0aW5nIGEgYG11dGFibGUtZGF0YWAgYXR0cmlidXRlIG9uIGFuIGVsZW1lbnQgaW5zdGFuY2UuXG4gICAqXG4gICAqIEJ5IGRlZmF1bHQsIGBQb2x5bWVyLlByb3BlcnR5RWZmZWN0c2AgcGVyZm9ybXMgc3RyaWN0IGRpcnR5IGNoZWNraW5nIG9uXG4gICAqIG9iamVjdHMsIHdoaWNoIG1lYW5zIHRoYXQgYW55IGRlZXAgbW9kaWZpY2F0aW9ucyB0byBhbiBvYmplY3Qgb3IgYXJyYXkgd2lsbFxuICAgKiBub3QgYmUgcHJvcGFnYXRlZCB1bmxlc3MgXCJpbW11dGFibGVcIiBkYXRhIHBhdHRlcm5zIGFyZSB1c2VkIChpLmUuIGFsbCBvYmplY3RcbiAgICogcmVmZXJlbmNlcyBmcm9tIHRoZSByb290IHRvIHRoZSBtdXRhdGlvbiB3ZXJlIGNoYW5nZWQpLlxuICAgKlxuICAgKiBQb2x5bWVyIGFsc28gcHJvdmlkZXMgYSBwcm9wcmlldGFyeSBkYXRhIG11dGF0aW9uIGFuZCBwYXRoIG5vdGlmaWNhdGlvbiBBUElcbiAgICogKGUuZy4gYG5vdGlmeVBhdGhgLCBgc2V0YCwgYW5kIGFycmF5IG11dGF0aW9uIEFQSSdzKSB0aGF0IGFsbG93IGVmZmljaWVudFxuICAgKiBtdXRhdGlvbiBhbmQgbm90aWZpY2F0aW9uIG9mIGRlZXAgY2hhbmdlcyBpbiBhbiBvYmplY3QgZ3JhcGggdG8gYWxsIGVsZW1lbnRzXG4gICAqIGJvdW5kIHRvIHRoZSBzYW1lIG9iamVjdCBncmFwaC5cbiAgICpcbiAgICogSW4gY2FzZXMgd2hlcmUgbmVpdGhlciBpbW11dGFibGUgcGF0dGVybnMgbm9yIHRoZSBkYXRhIG11dGF0aW9uIEFQSSBjYW4gYmVcbiAgICogdXNlZCwgYXBwbHlpbmcgdGhpcyBtaXhpbiB3aWxsIGFsbG93IFBvbHltZXIgdG8gc2tpcCBkaXJ0eSBjaGVja2luZyBmb3JcbiAgICogb2JqZWN0cyBhbmQgYXJyYXlzIChhbHdheXMgY29uc2lkZXIgdGhlbSB0byBiZSBcImRpcnR5XCIpLiAgVGhpcyBhbGxvd3MgYVxuICAgKiB1c2VyIHRvIG1ha2UgYSBkZWVwIG1vZGlmaWNhdGlvbiB0byBhIGJvdW5kIG9iamVjdCBncmFwaCwgYW5kIHRoZW4gZWl0aGVyXG4gICAqIHNpbXBseSByZS1zZXQgdGhlIG9iamVjdCAoZS5nLiBgdGhpcy5pdGVtcyA9IHRoaXMuaXRlbXNgKSBvciBjYWxsIGBub3RpZnlQYXRoYFxuICAgKiAoZS5nLiBgdGhpcy5ub3RpZnlQYXRoKCdpdGVtcycpYCkgdG8gdXBkYXRlIHRoZSB0cmVlLiAgTm90ZSB0aGF0IGFsbFxuICAgKiBlbGVtZW50cyB0aGF0IHdpc2ggdG8gYmUgdXBkYXRlZCBiYXNlZCBvbiBkZWVwIG11dGF0aW9ucyBtdXN0IGFwcGx5IHRoaXNcbiAgICogbWl4aW4gb3Igb3RoZXJ3aXNlIHNraXAgc3RyaWN0IGRpcnR5IGNoZWNraW5nIGZvciBvYmplY3RzL2FycmF5cy5cbiAgICpcbiAgICogV2hpbGUgdGhpcyBiZWhhdmlvciBhZGRzIHRoZSBhYmlsaXR5IHRvIGZvcmdvIE9iamVjdC9BcnJheSBkaXJ0eSBjaGVja2luZyxcbiAgICogdGhlIGBtdXRhYmxlRGF0YWAgZmxhZyBkZWZhdWx0cyB0byBmYWxzZSBhbmQgbXVzdCBiZSBzZXQgb24gdGhlIGluc3RhbmNlLlxuICAgKlxuICAgKiBOb3RlLCB0aGUgcGVyZm9ybWFuY2UgY2hhcmFjdGVyaXN0aWNzIG9mIHByb3BhZ2F0aW5nIGxhcmdlIG9iamVjdCBncmFwaHNcbiAgICogd2lsbCBiZSB3b3JzZSBieSByZWx5aW5nIG9uIGBtdXRhYmxlRGF0YTogdHJ1ZWAgYXMgb3Bwb3NlZCB0byB1c2luZ1xuICAgKiBzdHJpY3QgZGlydHkgY2hlY2tpbmcgd2l0aCBpbW11dGFibGUgcGF0dGVybnMgb3IgUG9seW1lcidzIHBhdGggbm90aWZpY2F0aW9uXG4gICAqIEFQSS5cbiAgICpcbiAgICogQHBvbHltZXJCZWhhdmlvclxuICAgKiBAbWVtYmVyb2YgUG9seW1lclxuICAgKiBAc3VtbWFyeSBCZWhhdmlvciB0byBvcHRpb25hbGx5IHNraXAgc3RyaWN0IGRpcnR5LWNoZWNraW5nIGZvciBvYmplY3RzIGFuZFxuICAgKiAgIGFycmF5c1xuICAgKi9cbiAgUG9seW1lci5PcHRpb25hbE11dGFibGVEYXRhQmVoYXZpb3IgPSB7XG5cbiAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAvKipcbiAgICAgICAqIEluc3RhbmNlLWxldmVsIGZsYWcgZm9yIGNvbmZpZ3VyaW5nIHRoZSBkaXJ0eS1jaGVja2luZyBzdHJhdGVneVxuICAgICAgICogZm9yIHRoaXMgZWxlbWVudC4gIFdoZW4gdHJ1ZSwgT2JqZWN0cyBhbmQgQXJyYXlzIHdpbGwgc2tpcCBkaXJ0eVxuICAgICAgICogY2hlY2tpbmcsIG90aGVyd2lzZSBzdHJpY3QgZXF1YWxpdHkgY2hlY2tpbmcgd2lsbCBiZSB1c2VkLlxuICAgICAgICovXG4gICAgICBtdXRhYmxlRGF0YTogQm9vbGVhblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZXMgYFBvbHltZXIuUHJvcGVydHlFZmZlY3RzYCB0byBza2lwIHN0cmljdCBlcXVhbGl0eSBjaGVja2luZ1xuICAgICAqIGZvciBPYmplY3RzIGFuZCBBcnJheXMuXG4gICAgICpcbiAgICAgKiBQdWxscyB0aGUgdmFsdWUgdG8gZGlydHkgY2hlY2sgYWdhaW5zdCBmcm9tIHRoZSBgX19kYXRhVGVtcGAgY2FjaGVcbiAgICAgKiAocmF0aGVyIHRoYW4gdGhlIG5vcm1hbCBgX19kYXRhYCBjYWNoZSkgZm9yIE9iamVjdHMuICBTaW5jZSB0aGUgdGVtcFxuICAgICAqIGNhY2hlIGlzIGNsZWFyZWQgYXQgdGhlIGVuZCBvZiBhIHR1cm4sIHRoaXMgaW1wbGVtZW50YXRpb24gYWxsb3dzXG4gICAgICogc2lkZS1lZmZlY3RzIG9mIGRlZXAgb2JqZWN0IGNoYW5nZXMgdG8gYmUgcHJvY2Vzc2VkIGJ5IHJlLXNldHRpbmcgdGhlXG4gICAgICogc2FtZSBvYmplY3QgKHVzaW5nIHRoZSB0ZW1wIGNhY2hlIGFzIGFuIGluLXR1cm4gYmFja3N0b3AgdG8gcHJldmVudFxuICAgICAqIGN5Y2xlcyBkdWUgdG8gMi13YXkgbm90aWZpY2F0aW9uKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSBuYW1lXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBOZXcgcHJvcGVydHkgdmFsdWVcbiAgICAgKiBAcGFyYW0geyp9IG9sZCBQcmV2aW91cyBwcm9wZXJ0eSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIHByb3BlcnR5IHNob3VsZCBiZSBjb25zaWRlcmVkIGEgY2hhbmdlXG4gICAgICogQHRoaXMge3RoaXN9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9zaG91bGRQcm9wZXJ0eUNoYW5nZShwcm9wZXJ0eSwgdmFsdWUsIG9sZCkge1xuICAgICAgcmV0dXJuIG11dGFibGVQcm9wZXJ0eUNoYW5nZSh0aGlzLCBwcm9wZXJ0eSwgdmFsdWUsIG9sZCwgdGhpcy5tdXRhYmxlRGF0YSk7XG4gICAgfVxuICB9O1xuXG59KSgpO1xuXG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvbGVnYWN5L211dGFibGUtZGF0YS1iZWhhdmlvci5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNSBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuXG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vLi4vcG9seW1lci9wb2x5bWVyLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi8uLi9pcm9uLW1lZGlhLXF1ZXJ5L2lyb24tbWVkaWEtcXVlcnkuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL2FwcC1sYXlvdXQtYmVoYXZpb3IvYXBwLWxheW91dC1iZWhhdmlvci5odG1sXCI+XG5cbjwhLS1cbmFwcC1kcmF3ZXItbGF5b3V0IGlzIGEgd3JhcHBlciBlbGVtZW50IHRoYXQgcG9zaXRpb25zIGFuIGFwcC1kcmF3ZXIgYW5kIG90aGVyIGNvbnRlbnQuIFdoZW5cbnRoZSB2aWV3cG9ydCB3aWR0aCBpcyBzbWFsbGVyIHRoYW4gYHJlc3BvbnNpdmVXaWR0aGAsIHRoaXMgZWxlbWVudCBjaGFuZ2VzIHRvIG5hcnJvdyBsYXlvdXQuXG5JbiBuYXJyb3cgbGF5b3V0LCB0aGUgZHJhd2VyIHdpbGwgYmUgc3RhY2tlZCBvbiB0b3Agb2YgdGhlIG1haW4gY29udGVudC4gVGhlIGRyYXdlciB3aWxsIHNsaWRlXG5pbi9vdXQgdG8gaGlkZS9yZXZlYWwgdGhlIG1haW4gY29udGVudC5cblxuQnkgZGVmYXVsdCB0aGUgZHJhd2VyIGlzIGFsaWduZWQgdG8gdGhlIHN0YXJ0LCB3aGljaCBpcyBsZWZ0IGluIExUUiBsYXlvdXRzOlxuXG5gYGBodG1sXG48YXBwLWRyYXdlci1sYXlvdXQ+XG4gIDxhcHAtZHJhd2VyIHNsb3Q9XCJkcmF3ZXJcIj5cbiAgICBkcmF3ZXIgY29udGVudFxuICA8L2FwcC1kcmF3ZXI+XG4gIDxkaXY+XG4gICAgbWFpbiBjb250ZW50XG4gIDwvZGl2PlxuPC9hcHAtZHJhd2VyLWxheW91dD5cbmBgYFxuXG5BbGlnbiB0aGUgZHJhd2VyIGF0IHRoZSBlbmQ6XG5cbmBgYGh0bWxcbjxhcHAtZHJhd2VyLWxheW91dD5cbiAgPGFwcC1kcmF3ZXIgc2xvdD1cImRyYXdlclwiIGFsaWduPVwiZW5kXCI+XG4gICAgIGRyYXdlciBjb250ZW50XG4gIDwvYXBwLWRyYXdlcj5cbiAgPGRpdj5cbiAgICBtYWluIGNvbnRlbnRcbiAgPC9kaXY+XG48L2FwcC1kcmF3ZXItbGF5b3V0PlxuYGBgXG5cbldpdGggYW4gYXBwLWhlYWRlci1sYXlvdXQ6XG5cbmBgYGh0bWxcbjxhcHAtZHJhd2VyLWxheW91dD5cbiAgPGFwcC1kcmF3ZXIgc2xvdD1cImRyYXdlclwiPlxuICAgIGRyYXdlci1jb250ZW50XG4gIDwvYXBwLWRyYXdlcj5cbiAgPGFwcC1oZWFkZXItbGF5b3V0PlxuICAgIDxhcHAtaGVhZGVyIHNsb3Q9XCJoZWFkZXJcIj5cbiAgICAgIDxhcHAtdG9vbGJhcj5cbiAgICAgICAgPGRpdiBtYWluLXRpdGxlPkFwcCBuYW1lPC9kaXY+XG4gICAgICA8L2FwcC10b29sYmFyPlxuICAgIDwvYXBwLWhlYWRlcj5cblxuICAgIG1haW4gY29udGVudFxuXG4gIDwvYXBwLWhlYWRlci1sYXlvdXQ+XG48L2FwcC1kcmF3ZXItbGF5b3V0PlxuYGBgXG5cbkFkZCB0aGUgYGRyYXdlci10b2dnbGVgIGF0dHJpYnV0ZSB0byBlbGVtZW50cyBpbnNpZGUgYGFwcC1kcmF3ZXItbGF5b3V0YCB0aGF0IHRvZ2dsZSB0aGUgZHJhd2VyIG9uIGNsaWNrIGV2ZW50czpcblxuYGBgaHRtbFxuPGFwcC1kcmF3ZXItbGF5b3V0PlxuICA8YXBwLWRyYXdlciBzbG90PVwiZHJhd2VyXCI+XG4gICAgZHJhd2VyLWNvbnRlbnRcbiAgPC9hcHAtZHJhd2VyPlxuICA8YXBwLWhlYWRlci1sYXlvdXQ+XG4gICAgPGFwcC1oZWFkZXIgc2xvdD1cImhlYWRlclwiPlxuICAgICAgPGFwcC10b29sYmFyPlxuICAgICAgICA8cGFwZXItaWNvbi1idXR0b24gaWNvbj1cIm1lbnVcIiBkcmF3ZXItdG9nZ2xlPjwvcGFwZXItaWNvbi1idXR0b24+XG4gICAgICAgIDxkaXYgbWFpbi10aXRsZT5BcHAgbmFtZTwvZGl2PlxuICAgICAgPC9hcHAtdG9vbGJhcj5cbiAgICA8L2FwcC1oZWFkZXI+XG5cbiAgICBtYWluIGNvbnRlbnRcblxuICA8L2FwcC1oZWFkZXItbGF5b3V0PlxuPC9hcHAtZHJhd2VyLWxheW91dD5cbmBgYFxuXG4qKk5PVEU6KiogV2l0aCBhcHAtbGF5b3V0IDIuMCwgdGhlIGBkcmF3ZXItdG9nZ2xlYCBlbGVtZW50IHdpbGwgbm90IGJlIGF1dG9tYXRpY2FsbHkgaGlkZGVuXG53aGVuIGFwcC1kcmF3ZXItbGF5b3V0IGlzIG5vdCBpbiBuYXJyb3cgbGF5b3V0LiBUbyBhZGQgdGhpcywgYWRkIHRoZSBmb2xsb3dpbmcgQ1NTIHJ1bGUgd2hlcmVcbmFwcC1kcmF3ZXItbGF5b3V0IGlzIHVzZWQ6XG5cbmBgYGNzc1xuYXBwLWRyYXdlci1sYXlvdXQ6bm90KFtuYXJyb3ddKSBbZHJhd2VyLXRvZ2dsZV0ge1xuICBkaXNwbGF5OiBub25lO1xufVxuYGBgXG5cbkFkZCB0aGUgYGZ1bGxibGVlZGAgYXR0cmlidXRlIHRvIGFwcC1kcmF3ZXItbGF5b3V0IHRvIG1ha2UgaXQgZml0IHRoZSBzaXplIG9mIGl0cyBjb250YWluZXI6XG5cbmBgYGh0bWxcbjxhcHAtZHJhd2VyLWxheW91dCBmdWxsYmxlZWQ+XG4gIDxhcHAtZHJhd2VyIHNsb3Q9XCJkcmF3ZXJcIj5cbiAgICAgZHJhd2VyIGNvbnRlbnRcbiAgPC9hcHAtZHJhd2VyPlxuICA8ZGl2PlxuICAgIG1haW4gY29udGVudFxuICA8L2Rpdj5cbjwvYXBwLWRyYXdlci1sYXlvdXQ+XG5gYGBcblxuIyMjIFN0eWxpbmdcblxuQ3VzdG9tIHByb3BlcnR5ICAgICAgICAgICAgICAgICAgICAgICAgICB8IERlc2NyaXB0aW9uICAgICAgICAgICAgICAgICAgICAgICAgICB8IERlZmF1bHRcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfC0tLS0tLS0tLVxuYC0tYXBwLWRyYXdlci13aWR0aGAgICAgICAgICAgICAgICAgICAgICB8IFdpZHRoIG9mIHRoZSBkcmF3ZXIgICAgICAgICAgICAgICAgICB8IDI1NnB4XG5gLS1hcHAtZHJhd2VyLWxheW91dC1jb250ZW50LXRyYW5zaXRpb25gIHwgVHJhbnNpdGlvbiBmb3IgdGhlIGNvbnRlbnQgY29udGFpbmVyIHwgbm9uZVxuXG4qKk5PVEU6KiogSWYgeW91IHVzZSA8YXBwLWRyYXdlcj4gd2l0aCA8YXBwLWRyYXdlci1sYXlvdXQ+IGFuZCBzcGVjaWZ5IGEgdmFsdWUgZm9yXG5gLS1hcHAtZHJhd2VyLXdpZHRoYCwgdGhhdCB2YWx1ZSBtdXN0IGJlIGFjY2Vzc2libGUgYnkgYm90aCBlbGVtZW50cy4gVGhpcyBjYW4gYmUgZG9uZSBieVxuZGVmaW5pbmcgdGhlIHZhbHVlIG9uIHRoZSBgOmhvc3RgIHRoYXQgY29udGFpbnMgPGFwcC1kcmF3ZXItbGF5b3V0PiAob3IgYGh0bWxgIGlmIG91dHNpZGVcbmEgc2hhZG93IHJvb3QpOlxuXG5gYGBjc3Ncbjpob3N0IHtcbiAgLS1hcHAtZHJhd2VyLXdpZHRoOiAzMDBweDtcbn1cbmBgYFxuXG5AZ3JvdXAgQXBwIEVsZW1lbnRzXG5AZWxlbWVudCBhcHAtZHJhd2VyLWxheW91dFxuQGRlbW8gYXBwLWRyYXdlci1sYXlvdXQvZGVtby9pbmRleC5odG1sXG4tLT5cblxuPGRvbS1tb2R1bGUgaWQ9XCJhcHAtZHJhd2VyLWxheW91dFwiPlxuICA8dGVtcGxhdGU+XG4gICAgPHN0eWxlPlxuICAgICAgOmhvc3Qge1xuICAgICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZvcmNlIGFwcC1kcmF3ZXItbGF5b3V0IHRvIGhhdmUgaXRzIG93biBzdGFja2luZyBjb250ZXh0IHNvIHRoYXQgaXRzIHBhcmVudCBjYW5cbiAgICAgICAgICogY29udHJvbCB0aGUgc3RhY2tpbmcgb2YgaXQgcmVsYXRpdmUgdG8gb3RoZXIgZWxlbWVudHMuXG4gICAgICAgICAqL1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgIHotaW5kZXg6IDA7XG4gICAgICB9XG5cbiAgICAgIDpob3N0IDo6c2xvdHRlZChbc2xvdD1kcmF3ZXJdKSB7XG4gICAgICAgIHotaW5kZXg6IDE7XG4gICAgICB9XG5cbiAgICAgIDpob3N0KFtmdWxsYmxlZWRdKSB7XG4gICAgICAgIEBhcHBseSAtLWxheW91dC1maXQ7XG4gICAgICB9XG5cbiAgICAgICNjb250ZW50Q29udGFpbmVyIHtcbiAgICAgICAgLyogQ3JlYXRlIGEgc3RhY2tpbmcgY29udGV4dCBoZXJlIHNvIHRoYXQgYWxsIGNoaWxkcmVuIGFwcGVhciBiZWxvdyB0aGUgaGVhZGVyLiAqL1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgIHotaW5kZXg6IDA7XG4gICAgICAgIGhlaWdodDogMTAwJTtcbiAgICAgICAgdHJhbnNpdGlvbjogdmFyKC0tYXBwLWRyYXdlci1sYXlvdXQtY29udGVudC10cmFuc2l0aW9uLCBub25lKTtcbiAgICAgIH1cblxuICAgICAgI2NvbnRlbnRDb250YWluZXJbZHJhd2VyLXBvc2l0aW9uPWxlZnRdIHtcbiAgICAgICAgbWFyZ2luLWxlZnQ6IHZhcigtLWFwcC1kcmF3ZXItd2lkdGgsIDI1NnB4KTtcbiAgICAgIH1cblxuICAgICAgI2NvbnRlbnRDb250YWluZXJbZHJhd2VyLXBvc2l0aW9uPXJpZ2h0XSB7XG4gICAgICAgIG1hcmdpbi1yaWdodDogdmFyKC0tYXBwLWRyYXdlci13aWR0aCwgMjU2cHgpO1xuICAgICAgfVxuICAgIDwvc3R5bGU+XG5cbiAgICA8c2xvdCBpZD1cImRyYXdlclNsb3RcIiBuYW1lPVwiZHJhd2VyXCI+PC9zbG90PlxuXG4gICAgPGRpdiBpZD1cImNvbnRlbnRDb250YWluZXJcIiBkcmF3ZXItcG9zaXRpb24kPVwiW1tfZHJhd2VyUG9zaXRpb25dXVwiPlxuICAgICAgPHNsb3Q+PC9zbG90PlxuICAgIDwvZGl2PlxuXG4gICAgPGlyb24tbWVkaWEtcXVlcnlcbiAgICAgICAgcXVlcnk9XCJbW19jb21wdXRlTWVkaWFRdWVyeShmb3JjZU5hcnJvdywgcmVzcG9uc2l2ZVdpZHRoKV1dXCJcbiAgICAgICAgb24tcXVlcnktbWF0Y2hlcy1jaGFuZ2VkPVwiX29uUXVlcnlNYXRjaGVzQ2hhbmdlZFwiPjwvaXJvbi1tZWRpYS1xdWVyeT5cbiAgPC90ZW1wbGF0ZT5cblxuICA8c2NyaXB0PlxuICAgIFBvbHltZXIoe1xuICAgICAgaXM6ICdhcHAtZHJhd2VyLWxheW91dCcsXG5cbiAgICAgIGJlaGF2aW9yczogW1xuICAgICAgICBQb2x5bWVyLkFwcExheW91dEJlaGF2aW9yXG4gICAgICBdLFxuXG4gICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0cnVlLCBpZ25vcmUgYHJlc3BvbnNpdmVXaWR0aGAgc2V0dGluZyBhbmQgZm9yY2UgdGhlIG5hcnJvdyBsYXlvdXQuXG4gICAgICAgICAqL1xuICAgICAgICBmb3JjZU5hcnJvdzoge1xuICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHRoZSB2aWV3cG9ydCdzIHdpZHRoIGlzIHNtYWxsZXIgdGhhbiB0aGlzIHZhbHVlLCB0aGUgcGFuZWwgd2lsbCBjaGFuZ2UgdG8gbmFycm93XG4gICAgICAgICAqIGxheW91dC4gSW4gdGhlIG1vZGUgdGhlIGRyYXdlciB3aWxsIGJlIGNsb3NlZC5cbiAgICAgICAgICovXG4gICAgICAgIHJlc3BvbnNpdmVXaWR0aDoge1xuICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICB2YWx1ZTogJzY0MHB4J1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRydWUgaWYgaXQgaXMgaW4gbmFycm93IGxheW91dC4gVGhpcyBpcyB1c2VmdWwgaWYgeW91IG5lZWQgdG8gc2hvdy9oaWRlXG4gICAgICAgICAqIGVsZW1lbnRzIGJhc2VkIG9uIHRoZSBsYXlvdXQuXG4gICAgICAgICAqL1xuICAgICAgICBuYXJyb3c6IHtcbiAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgIHJlZmxlY3RUb0F0dHJpYnV0ZTogdHJ1ZSxcbiAgICAgICAgICByZWFkT25seTogdHJ1ZSxcbiAgICAgICAgICBub3RpZnk6IHRydWVcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgdHJ1ZSwgdGhlIGRyYXdlciB3aWxsIGluaXRpYWxseSBiZSBvcGVuZWQgd2hlbiBpbiBuYXJyb3cgbGF5b3V0IG1vZGUuXG4gICAgICAgICAqL1xuICAgICAgICBvcGVuZWRXaGVuTmFycm93OiB7XG4gICAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgfSxcblxuICAgICAgICBfZHJhd2VyUG9zaXRpb246IHtcbiAgICAgICAgICB0eXBlOiBTdHJpbmdcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgbGlzdGVuZXJzOiB7XG4gICAgICAgICdjbGljayc6ICdfY2xpY2tIYW5kbGVyJ1xuICAgICAgfSxcblxuICAgICAgb2JzZXJ2ZXJzOiBbXG4gICAgICAgICdfbmFycm93Q2hhbmdlZChuYXJyb3cpJ1xuICAgICAgXSxcblxuICAgICAgLyoqXG4gICAgICAgKiBBIHJlZmVyZW5jZSB0byB0aGUgYXBwLWRyYXdlciBlbGVtZW50LlxuICAgICAgICpcbiAgICAgICAqIEBwcm9wZXJ0eSBkcmF3ZXJcbiAgICAgICAqL1xuICAgICAgZ2V0IGRyYXdlcigpIHtcbiAgICAgICAgcmV0dXJuIFBvbHltZXIuZG9tKHRoaXMuJC5kcmF3ZXJTbG90KS5nZXREaXN0cmlidXRlZE5vZGVzKClbMF07XG4gICAgICB9LFxuXG4gICAgICBhdHRhY2hlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIERpc2FibGUgZHJhd2VyIHRyYW5zaXRpb25zIHVudGlsIGFmdGVyIGFwcC1kcmF3ZXItbGF5b3V0IHNldHMgdGhlIGluaXRpYWwgb3BlbmVkIHN0YXRlLlxuICAgICAgICB2YXIgZHJhd2VyID0gdGhpcy5kcmF3ZXI7XG4gICAgICAgIGlmIChkcmF3ZXIpIHtcbiAgICAgICAgICBkcmF3ZXIuc2V0QXR0cmlidXRlKCduby10cmFuc2l0aW9uJywgJycpO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBfY2xpY2tIYW5kbGVyOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIHZhciB0YXJnZXQgPSBQb2x5bWVyLmRvbShlKS5sb2NhbFRhcmdldDtcbiAgICAgICAgaWYgKHRhcmdldCAmJiB0YXJnZXQuaGFzQXR0cmlidXRlKCdkcmF3ZXItdG9nZ2xlJykpIHtcbiAgICAgICAgICB2YXIgZHJhd2VyID0gdGhpcy5kcmF3ZXI7XG4gICAgICAgICAgaWYgKGRyYXdlciAmJiAhZHJhd2VyLnBlcnNpc3RlbnQpIHtcbiAgICAgICAgICAgIGRyYXdlci50b2dnbGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIF91cGRhdGVMYXlvdXRTdGF0ZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZHJhd2VyID0gdGhpcy5kcmF3ZXI7XG4gICAgICAgIGlmICghdGhpcy5pc0F0dGFjaGVkIHx8ICFkcmF3ZXIpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9kcmF3ZXJQb3NpdGlvbiA9IHRoaXMubmFycm93ID8gbnVsbCA6IGRyYXdlci5wb3NpdGlvbjtcbiAgICAgICAgaWYgKHRoaXMuX2RyYXdlck5lZWRzUmVzZXQpIHtcbiAgICAgICAgICBpZiAodGhpcy5uYXJyb3cpIHtcbiAgICAgICAgICAgIGRyYXdlci5vcGVuZWQgPSB0aGlzLm9wZW5lZFdoZW5OYXJyb3c7XG4gICAgICAgICAgICBkcmF3ZXIucGVyc2lzdGVudCA9IGZhbHNlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkcmF3ZXIub3BlbmVkID0gZHJhd2VyLnBlcnNpc3RlbnQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZHJhd2VyLmhhc0F0dHJpYnV0ZSgnbm8tdHJhbnNpdGlvbicpKSB7XG4gICAgICAgICAgICAvLyBFbmFibGUgZHJhd2VyIHRyYW5zaXRpb25zIGFmdGVyIGFwcC1kcmF3ZXItbGF5b3V0IHNldHMgdGhlIGluaXRpYWwgb3BlbmVkIHN0YXRlLlxuICAgICAgICAgICAgUG9seW1lci5SZW5kZXJTdGF0dXMuYWZ0ZXJOZXh0UmVuZGVyKHRoaXMsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBkcmF3ZXIucmVtb3ZlQXR0cmlidXRlKCduby10cmFuc2l0aW9uJyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fZHJhd2VyTmVlZHNSZXNldCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBfbmFycm93Q2hhbmdlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX2RyYXdlck5lZWRzUmVzZXQgPSB0cnVlO1xuICAgICAgICB0aGlzLnJlc2V0TGF5b3V0KCk7XG4gICAgICB9LFxuXG4gICAgICBfb25RdWVyeU1hdGNoZXNDaGFuZ2VkOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICB0aGlzLl9zZXROYXJyb3coZXZlbnQuZGV0YWlsLnZhbHVlKTtcbiAgICAgIH0sXG5cbiAgICAgIF9jb21wdXRlTWVkaWFRdWVyeTogZnVuY3Rpb24oZm9yY2VOYXJyb3csIHJlc3BvbnNpdmVXaWR0aCkge1xuICAgICAgICByZXR1cm4gZm9yY2VOYXJyb3cgPyAnKG1pbi13aWR0aDogMHB4KScgOiAnKG1heC13aWR0aDogJyArIHJlc3BvbnNpdmVXaWR0aCArICcpJztcbiAgICAgIH1cbiAgICB9KTtcbiAgPC9zY3JpcHQ+XG48L2RvbS1tb2R1bGU+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL2FwcC1sYXlvdXQvYXBwLWRyYXdlci1sYXlvdXQvYXBwLWRyYXdlci1sYXlvdXQuaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTUgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cblxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3BvbHltZXIvcG9seW1lci5odG1sXCI+XG5cbjwhLS1cbmBpcm9uLW1lZGlhLXF1ZXJ5YCBjYW4gYmUgdXNlZCB0byBkYXRhIGJpbmQgdG8gYSBDU1MgbWVkaWEgcXVlcnkuXG5UaGUgYHF1ZXJ5YCBwcm9wZXJ0eSBpcyBhIGJhcmUgQ1NTIG1lZGlhIHF1ZXJ5LlxuVGhlIGBxdWVyeS1tYXRjaGVzYCBwcm9wZXJ0eSBpcyBhIGJvb2xlYW4gcmVwcmVzZW50aW5nIHdoZXRoZXIgdGhlIHBhZ2UgbWF0Y2hlcyB0aGF0IG1lZGlhIHF1ZXJ5LlxuXG5FeGFtcGxlOlxuXG4gICAgPGlyb24tbWVkaWEtcXVlcnkgcXVlcnk9XCIobWluLXdpZHRoOiA2MDBweClcIiBxdWVyeS1tYXRjaGVzPVwie3txdWVyeU1hdGNoZXN9fVwiPjwvaXJvbi1tZWRpYS1xdWVyeT5cblxuQGdyb3VwIElyb24gRWxlbWVudHNcbkBkZW1vIGRlbW8vaW5kZXguaHRtbFxuQGhlcm8gaGVyby5zdmdcbkBlbGVtZW50IGlyb24tbWVkaWEtcXVlcnlcbi0tPlxuXG48c2NyaXB0PlxuXG4gIFBvbHltZXIoe1xuXG4gICAgaXM6ICdpcm9uLW1lZGlhLXF1ZXJ5JyxcblxuICAgIHByb3BlcnRpZXM6IHtcblxuICAgICAgLyoqXG4gICAgICAgKiBUaGUgQm9vbGVhbiByZXR1cm4gdmFsdWUgb2YgdGhlIG1lZGlhIHF1ZXJ5LlxuICAgICAgICovXG4gICAgICBxdWVyeU1hdGNoZXM6IHtcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgdmFsdWU6IGZhbHNlLFxuICAgICAgICByZWFkT25seTogdHJ1ZSxcbiAgICAgICAgbm90aWZ5OiB0cnVlXG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFRoZSBDU1MgbWVkaWEgcXVlcnkgdG8gZXZhbHVhdGUuXG4gICAgICAgKi9cbiAgICAgIHF1ZXJ5OiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgb2JzZXJ2ZXI6ICdxdWVyeUNoYW5nZWQnXG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIElmIHRydWUsIHRoZSBxdWVyeSBhdHRyaWJ1dGUgaXMgYXNzdW1lZCB0byBiZSBhIGNvbXBsZXRlIG1lZGlhIHF1ZXJ5XG4gICAgICAgKiBzdHJpbmcgcmF0aGVyIHRoYW4gYSBzaW5nbGUgbWVkaWEgZmVhdHVyZS5cbiAgICAgICAqL1xuICAgICAgZnVsbDoge1xuICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogQHR5cGUge2Z1bmN0aW9uKE1lZGlhUXVlcnlMaXN0KX1cbiAgICAgICAqL1xuICAgICAgX2JvdW5kTVFIYW5kbGVyOiB7XG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5xdWVyeUhhbmRsZXIuYmluZCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBAdHlwZSB7TWVkaWFRdWVyeUxpc3R9XG4gICAgICAgKi9cbiAgICAgIF9tcToge1xuICAgICAgICB2YWx1ZTogbnVsbFxuICAgICAgfVxuICAgIH0sXG5cbiAgICBhdHRhY2hlZDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICB0aGlzLnF1ZXJ5Q2hhbmdlZCgpO1xuICAgIH0sXG5cbiAgICBkZXRhY2hlZDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9yZW1vdmUoKTtcbiAgICB9LFxuXG4gICAgX2FkZDogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5fbXEpIHtcbiAgICAgICAgdGhpcy5fbXEuYWRkTGlzdGVuZXIodGhpcy5fYm91bmRNUUhhbmRsZXIpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBfcmVtb3ZlOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLl9tcSkge1xuICAgICAgICB0aGlzLl9tcS5yZW1vdmVMaXN0ZW5lcih0aGlzLl9ib3VuZE1RSGFuZGxlcik7XG4gICAgICB9XG4gICAgICB0aGlzLl9tcSA9IG51bGw7XG4gICAgfSxcblxuICAgIHF1ZXJ5Q2hhbmdlZDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9yZW1vdmUoKTtcbiAgICAgIHZhciBxdWVyeSA9IHRoaXMucXVlcnk7XG4gICAgICBpZiAoIXF1ZXJ5KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5mdWxsICYmIHF1ZXJ5WzBdICE9PSAnKCcpIHtcbiAgICAgICAgcXVlcnkgPSAnKCcgKyBxdWVyeSArICcpJztcbiAgICAgIH1cbiAgICAgIHRoaXMuX21xID0gd2luZG93Lm1hdGNoTWVkaWEocXVlcnkpO1xuICAgICAgdGhpcy5fYWRkKCk7XG4gICAgICB0aGlzLnF1ZXJ5SGFuZGxlcih0aGlzLl9tcSk7XG4gICAgfSxcblxuICAgIHF1ZXJ5SGFuZGxlcjogZnVuY3Rpb24obXEpIHtcbiAgICAgIHRoaXMuX3NldFF1ZXJ5TWF0Y2hlcyhtcS5tYXRjaGVzKTtcbiAgICB9XG5cbiAgfSk7XG5cbjwvc2NyaXB0PlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9pcm9uLW1lZGlhLXF1ZXJ5L2lyb24tbWVkaWEtcXVlcnkuaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTUgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cblxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uLy4uL3BvbHltZXIvcG9seW1lci5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vLi4vaXJvbi1mbGV4LWxheW91dC9pcm9uLWZsZXgtbGF5b3V0Lmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi9hcHAtc2Nyb2xsLWVmZmVjdHMvYXBwLXNjcm9sbC1lZmZlY3RzLWJlaGF2aW9yLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi9hcHAtbGF5b3V0LWJlaGF2aW9yL2FwcC1sYXlvdXQtYmVoYXZpb3IuaHRtbFwiPlxuXG48IS0tXG5hcHAtaGVhZGVyIGlzIGNvbnRhaW5lciBlbGVtZW50IGZvciBhcHAtdG9vbGJhcnMgYXQgdGhlIHRvcCBvZiB0aGUgc2NyZWVuIHRoYXQgY2FuIGhhdmUgc2Nyb2xsXG5lZmZlY3RzLiBCeSBkZWZhdWx0LCBhbiBhcHAtaGVhZGVyIG1vdmVzIGF3YXkgZnJvbSB0aGUgdmlld3BvcnQgd2hlbiBzY3JvbGxpbmcgZG93biBhbmRcbmlmIHVzaW5nIGByZXZlYWxzYCwgdGhlIGhlYWRlciBzbGlkZXMgYmFjayB3aGVuIHNjcm9sbGluZyBiYWNrIHVwLiBGb3IgZXhhbXBsZTpcblxuYGBgaHRtbFxuPGFwcC1oZWFkZXIgcmV2ZWFscz5cbiAgPGFwcC10b29sYmFyPlxuICAgIDxkaXYgbWFpbi10aXRsZT5BcHAgbmFtZTwvZGl2PlxuICA8L2FwcC10b29sYmFyPlxuPC9hcHAtaGVhZGVyPlxuYGBgXG5cbmFwcC1oZWFkZXIgY2FuIGFsc28gY29uZGVuc2Ugd2hlbiBzY3JvbGxpbmcgZG93bi4gVG8gYWNoaWV2ZSB0aGlzIGJlaGF2aW9yLCB0aGUgaGVhZGVyXG5tdXN0IGhhdmUgYSBsYXJnZXIgaGVpZ2h0IHRoYW4gdGhlIGBzdGlja3lgIGVsZW1lbnQgaW4gdGhlIGxpZ2h0IERPTS4gRm9yIGV4YW1wbGU6XG5cbmBgYGh0bWxcbjxhcHAtaGVhZGVyIHN0eWxlPVwiaGVpZ2h0OiA5NnB4O1wiIGNvbmRlbnNlcyBmaXhlZD5cbiAgPGFwcC10b29sYmFyIHN0eWxlPVwiaGVpZ2h0OiA2NHB4O1wiPlxuICAgIDxkaXYgbWFpbi10aXRsZT5BcHAgbmFtZTwvZGl2PlxuICA8L2FwcC10b29sYmFyPlxuPC9hcHAtaGVhZGVyPlxuYGBgXG5cbkluIHRoaXMgY2FzZSB0aGUgaGVhZGVyIGlzIGluaXRpYWxseSBgOTZweGAgdGFsbCwgYW5kIGl0IHNocmlua3MgdG8gYDY0cHhgIHdoZW4gc2Nyb2xsaW5nIGRvd24uXG5UaGF0IGlzIHdoYXQgaXMgbWVhbnQgYnkgXCJjb25kZW5zaW5nXCIuXG5cbiMjIyBTdGlja3kgZWxlbWVudFxuXG5UaGUgZWxlbWVudCB0aGF0IGlzIHBvc2l0aW9uZWQgZml4ZWQgdG8gdG9wIG9mIHRoZSBoZWFkZXIncyBgc2Nyb2xsVGFyZ2V0YCB3aGVuIGEgdGhyZXNob2xkXG5pcyByZWFjaGVkLCBzaW1pbGFyIHRvIGBwb3NpdGlvbjogc3RpY2t5YCBpbiBDU1MuIFRoaXMgZWxlbWVudCAqKm11c3QqKiBiZSBhbiBpbW1lZGlhdGVcbmNoaWxkIG9mIGFwcC1oZWFkZXIuIEJ5IGRlZmF1bHQsIHRoZSBgc3RpY2t5YCBlbGVtZW50IGlzIHRoZSBmaXJzdCBgYXBwLXRvb2xiYXIgdGhhdFxuaXMgYW4gaW1tZWRpYXRlIGNoaWxkIG9mIGFwcC1oZWFkZXIuXG5cbmBgYGh0bWxcbjxhcHAtaGVhZGVyIGNvbmRlbnNlcz5cbiAgPGFwcC10b29sYmFyPiBTdGlja3kgZWxlbWVudCA8L2FwcC10b29sYmFyPlxuPC9hcHAtaGVhZGVyPlxuYGBgXG5cbiMjIyMgQ3VzdG9taXppbmcgdGhlIHN0aWNreSBlbGVtZW50XG5cbmBgYGh0bWxcbjxhcHAtaGVhZGVyIGNvbmRlbnNlcz5cbiAgPGFwcC10b29sYmFyPjwvYXBwLXRvb2xiYXI+XG4gIDxhcHAtdG9vbGJhciBzdGlja3k+IFN0aWNreSBlbGVtZW50IDwvYXBwLXRvb2xiYXI+XG48L2FwcC1oZWFkZXI+XG5gYGBcblxuIyMjIFNjcm9sbCB0YXJnZXRcblxuVGhlIGFwcC1oZWFkZXIncyBgc2Nyb2xsVGFyZ2V0YCBwcm9wZXJ0eSBhbGxvd3MgdG8gY3VzdG9taXplIHRoZSBzY3JvbGxhYmxlIGVsZW1lbnQgdG8gd2hpY2hcbnRoZSBoZWFkZXIgcmVzcG9uZHMgd2hlbiB0aGUgdXNlciBzY3JvbGxzLiBCeSBkZWZhdWx0LCBhcHAtaGVhZGVyIHVzZXMgdGhlIGRvY3VtZW50IGFzXG50aGUgc2Nyb2xsIHRhcmdldCwgYnV0IHlvdSBjYW4gY3VzdG9taXplIHRoaXMgcHJvcGVydHkgYnkgc2V0dGluZyB0aGUgaWQgb2YgdGhlIGVsZW1lbnQsIGUuZy5cblxuYGBgaHRtbFxuPGRpdiBpZD1cInNjcm9sbGluZ1JlZ2lvblwiIHN0eWxlPVwib3ZlcmZsb3cteTogYXV0bztcIj5cbiAgPGFwcC1oZWFkZXIgc2Nyb2xsLXRhcmdldD1cInNjcm9sbGluZ1JlZ2lvblwiPlxuICA8L2FwcC1oZWFkZXI+XG48L2Rpdj5cbmBgYFxuXG5JbiB0aGlzIGNhc2UsIHRoZSBgc2Nyb2xsVGFyZ2V0YCBwcm9wZXJ0eSBwb2ludHMgdG8gdGhlIG91dGVyIGRpdiBlbGVtZW50LiBBbHRlcm5hdGl2ZWx5LFxueW91IGNhbiBzZXQgdGhpcyBwcm9wZXJ0eSBwcm9ncmFtbWF0aWNhbGx5OlxuXG5gYGBqc1xuYXBwSGVhZGVyLnNjcm9sbFRhcmdldCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjc2Nyb2xsaW5nUmVnaW9uXCIpO1xuYGBgXG5cbiMjIEJhY2tncm91bmRzXG5hcHAtaGVhZGVyIGhhcyB0d28gYmFja2dyb3VuZCBsYXllcnMgdGhhdCBjYW4gYmUgdXNlZCBmb3Igc3R5bGluZyB3aGVuIHRoZSBoZWFkZXIgaXMgY29uZGVuc2VkXG5vciB3aGVuIHRoZSBzY3JvbGxhYmxlIGVsZW1lbnQgaXMgc2Nyb2xsZWQgdG8gdGhlIHRvcC5cblxuIyMgU2Nyb2xsIGVmZmVjdHNcblxuU2Nyb2xsIGVmZmVjdHMgYXJlIF9vcHRpb25hbF8gdmlzdWFsIGVmZmVjdHMgYXBwbGllZCBpbiBhcHAtaGVhZGVyIGJhc2VkIG9uIHNjcm9sbCBwb3NpdGlvbi4gRm9yIGV4YW1wbGUsXG5UaGUgW01hdGVyaWFsIERlc2lnbiBzY3JvbGxpbmcgdGVjaG5pcXVlc10oaHR0cHM6Ly93d3cuZ29vZ2xlLmNvbS9kZXNpZ24vc3BlYy9wYXR0ZXJucy9zY3JvbGxpbmctdGVjaG5pcXVlcy5odG1sKVxucmVjb21tZW5kcyBlZmZlY3RzIHRoYXQgY2FuIGJlIGluc3RhbGxlZCB2aWEgdGhlIGBlZmZlY3RzYCBwcm9wZXJ0eS4gZS5nLlxuXG5gYGBodG1sXG48YXBwLWhlYWRlciBlZmZlY3RzPVwid2F0ZXJmYWxsXCI+XG4gIDxhcHAtdG9vbGJhcj5BcHAgbmFtZTwvYXBwLXRvb2xiYXI+XG48L2FwcC1oZWFkZXI+XG5gYGBcblxuIyMjIyBJbXBvcnRpbmcgdGhlIGVmZmVjdHNcblxuVG8gdXNlIHRoZSBzY3JvbGwgZWZmZWN0cywgeW91IG11c3QgZXhwbGljaXRseSBpbXBvcnQgdGhlbSBpbiBhZGRpdGlvbiB0byBgYXBwLWhlYWRlcmA6XG5cbmBgYGh0bWxcbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIvYm93ZXJfY29tcG9uZW50cy9hcHAtbGF5b3V0L2FwcC1zY3JvbGwtZWZmZWN0cy9hcHAtc2Nyb2xsLWVmZmVjdHMuaHRtbFwiPlxuYGBgXG5cbiMjIyMgTGlzdCBvZiBlZmZlY3RzXG5cbiogKipibGVuZC1iYWNrZ3JvdW5kKipcbkZhZGVzIGluL291dCB0d28gYmFja2dyb3VuZCBlbGVtZW50cyBieSBhcHBseWluZyBDU1Mgb3BhY2l0eSBiYXNlZCBvbiBzY3JvbGwgcG9zaXRpb24uXG5Zb3UgY2FuIHVzZSB0aGlzIGVmZmVjdCB0byBzbW9vdGhseSBjaGFuZ2UgdGhlIGJhY2tncm91bmQgY29sb3Igb3IgaW1hZ2Ugb2YgdGhlIGhlYWRlci5cbkZvciBleGFtcGxlLCB1c2luZyB0aGUgbWl4aW4gYC0tYXBwLWhlYWRlci1iYWNrZ3JvdW5kLXJlYXItbGF5ZXJgIGxldHMgeW91IGFzc2lnbiBhIGRpZmZlcmVudFxuYmFja2dyb3VuZCB3aGVuIHRoZSBoZWFkZXIgaXMgY29uZGVuc2VkOlxuXG5gYGBjc3NcbmFwcC1oZWFkZXIge1xuICBiYWNrZ3JvdW5kLWNvbG9yOiByZWQ7XG4gIC0tYXBwLWhlYWRlci1iYWNrZ3JvdW5kLXJlYXItbGF5ZXI6IHtcbiAgICAvKiBUaGUgaGVhZGVyIGlzIGJsdWUgd2hlbiBjb25kZW5zZWQgKi9cbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiBibHVlO1xuICB9O1xufVxuYGBgXG5cbiogKipmYWRlLWJhY2tncm91bmQqKlxuVXBvbiBzY3JvbGxpbmcgcGFzdCBhIHRocmVzaG9sZCwgdGhpcyBlZmZlY3Qgd2lsbCB0cmlnZ2VyIGFuIG9wYWNpdHkgdHJhbnNpdGlvbiB0b1xuZmFkZSBpbi9vdXQgdGhlIGJhY2tncm91bmRzLiBDb21wYXJlZCB0byB0aGUgYGJsZW5kLWJhY2tncm91bmRgIGVmZmVjdCxcbnRoaXMgZWZmZWN0IGRvZXNuJ3QgaW50ZXJwb2xhdGUgdGhlIG9wYWNpdHkgYmFzZWQgb24gc2Nyb2xsIHBvc2l0aW9uLlxuXG5cbiogKipwYXJhbGxheC1iYWNrZ3JvdW5kKipcbkEgc2ltcGxlIHBhcmFsbGF4IGVmZmVjdCB0aGF0IHZlcnRpY2FsbHkgdHJhbnNsYXRlcyB0aGUgYmFja2dyb3VuZHMgYmFzZWQgb24gYSBmcmFjdGlvblxub2YgdGhlIHNjcm9sbCBwb3NpdGlvbi4gRm9yIGV4YW1wbGU6XG5cbmBgYGNzc1xuYXBwLWhlYWRlciB7XG4gIC0tYXBwLWhlYWRlci1iYWNrZ3JvdW5kLWZyb250LWxheWVyOiB7XG4gICAgYmFja2dyb3VuZC1pbWFnZTogdXJsKC4uLik7XG4gIH07XG59XG5gYGBcbmBgYGh0bWxcbjxhcHAtaGVhZGVyIHN0eWxlPVwiaGVpZ2h0OiAzMDBweDtcIiBlZmZlY3RzPVwicGFyYWxsYXgtYmFja2dyb3VuZFwiPlxuICA8YXBwLXRvb2xiYXI+QXBwIG5hbWU8L2FwcC10b29sYmFyPlxuPC9hcHAtaGVhZGVyPlxuYGBgXG5cblRoZSBmcmFjdGlvbiBkZXRlcm1pbmVzIGhvdyBmYXIgdGhlIGJhY2tncm91bmQgbW92ZXMgcmVsYXRpdmUgdG8gdGhlIHNjcm9sbCBwb3NpdGlvbi5cblRoaXMgdmFsdWUgY2FuIGJlIGFzc2lnbmVkIHZpYSB0aGUgYHNjYWxhcmAgY29uZmlnIHZhbHVlIGFuZCBpdCBpcyB0eXBpY2FsbHkgYSB2YWx1ZVxuYmV0d2VlbiAwIGFuZCAxIGluY2x1c2l2ZS4gSWYgYHNjYWxhcj0wYCwgdGhlIGJhY2tncm91bmQgZG9lc24ndCBtb3ZlIGF3YXkgZnJvbSB0aGUgaGVhZGVyLlxuXG4qICoqcmVzaXplLXRpdGxlKipcblByb2dyZXNzaXZlbHkgaW50ZXJwb2xhdGVzIHRoZSBzaXplIG9mIHRoZSB0aXRsZSBmcm9tIHRoZSBlbGVtZW50IHdpdGggdGhlIGBtYWluLXRpdGxlYCBhdHRyaWJ1dGVcbnRvIHRoZSBlbGVtZW50IHdpdGggdGhlIGBjb25kZW5zZWQtdGl0bGVgIGF0dHJpYnV0ZSBhcyB0aGUgaGVhZGVyIGNvbmRlbnNlcy4gRm9yIGV4YW1wbGU6XG5cbmBgYGh0bWxcbjxhcHAtaGVhZGVyIGNvbmRlbnNlcyByZXZlYWxzIGVmZmVjdHM9XCJyZXNpemUtdGl0bGVcIj5cbiAgPGFwcC10b29sYmFyPlxuICAgICAgPGg0IGNvbmRlbnNlZC10aXRsZT5BcHAgbmFtZTwvaDQ+XG4gIDwvYXBwLXRvb2xiYXI+XG4gIDxhcHAtdG9vbGJhcj5cbiAgICAgIDxoMSBtYWluLXRpdGxlPkFwcCBuYW1lPC9oMT5cbiAgPC9hcHAtdG9vbGJhcj5cbjwvYXBwLWhlYWRlcj5cbmBgYFxuXG4qICoqcmVzaXplLXNuYXBwZWQtdGl0bGUqKlxuVXBvbiBzY3JvbGxpbmcgcGFzdCBhIHRocmVzaG9sZCwgdGhpcyBlZmZlY3QgZmFkZXMgaW4vb3V0IHRoZSB0aXRsZXMgdXNpbmcgb3BhY2l0eSB0cmFuc2l0aW9ucy5cblNpbWlsYXJseSB0byBgcmVzaXplLXRpdGxlYCwgdGhlIGBtYWluLXRpdGxlYCBhbmQgYGNvbmRlbnNlZC10aXRsZWAgZWxlbWVudHMgbXVzdCBiZSBwbGFjZWQgaW4gdGhlXG5saWdodCBET00uXG5cbiogKip3YXRlcmZhbGwqKlxuVG9nZ2xlcyB0aGUgc2hhZG93IHByb3BlcnR5IGluIGFwcC1oZWFkZXIgdG8gY3JlYXRlIGEgc2Vuc2Ugb2YgZGVwdGggKGFzIHJlY29tbWVuZGVkIGluIHRoZVxuTUQgc3BlYykgYmV0d2VlbiB0aGUgaGVhZGVyIGFuZCB0aGUgdW5kZXJuZWF0aCBjb250ZW50LiBZb3UgY2FuIGNoYW5nZSB0aGUgc2hhZG93IGJ5XG5jdXN0b21pemluZyB0aGUgYC0tYXBwLWhlYWRlci1zaGFkb3dgIG1peGluLiBGb3IgZXhhbXBsZTpcblxuYGBgY3NzXG5hcHAtaGVhZGVyIHtcbiAgLS1hcHAtaGVhZGVyLXNoYWRvdzoge1xuICAgIGJveC1zaGFkb3c6IGluc2V0IDBweCA1cHggMnB4IC0zcHggcmdiYSgwLCAwLCAwLCAwLjIpO1xuICB9O1xufVxuYGBgXG5cbmBgYGh0bWxcbjxhcHAtaGVhZGVyIGNvbmRlbnNlcyByZXZlYWxzIGVmZmVjdHM9XCJ3YXRlcmZhbGxcIj5cbiAgPGFwcC10b29sYmFyPlxuICAgICAgPGgxIG1haW4tdGl0bGU+QXBwIG5hbWU8L2gxPlxuICA8L2FwcC10b29sYmFyPlxuPC9hcHAtaGVhZGVyPlxuYGBgXG5cbiogKiptYXRlcmlhbCoqXG5JbnN0YWxscyB0aGUgd2F0ZXJmYWxsLCByZXNpemUtdGl0bGUsIGJsZW5kLWJhY2tncm91bmQgYW5kIHBhcmFsbGF4LWJhY2tncm91bmQgZWZmZWN0cy5cblxuIyMjIENvbnRlbnQgYXR0cmlidXRlc1xuXG5BdHRyaWJ1dGUgfCBEZXNjcmlwdGlvbiAgICAgICAgIHwgRGVmYXVsdFxuLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tLS0tLS0tLS18LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuYHN0aWNreWAgfCBFbGVtZW50IHRoYXQgcmVtYWlucyBhdCB0aGUgdG9wIHdoZW4gdGhlIGhlYWRlciBjb25kZW5zZXMuIHwgVGhlIGZpcnN0IGFwcC10b29sYmFyIGluIHRoZSBsaWdodCBET00uXG5cblxuIyMgU3R5bGluZ1xuXG5NaXhpbiB8IERlc2NyaXB0aW9uIHwgRGVmYXVsdFxuLS0tLS0tfC0tLS0tLS0tLS0tLS18LS0tLS0tLS0tLVxuYC0tYXBwLWhlYWRlci1iYWNrZ3JvdW5kLWZyb250LWxheWVyYCB8IEFwcGxpZXMgdG8gdGhlIGZyb250IGxheWVyIG9mIHRoZSBiYWNrZ3JvdW5kLiB8IHt9XG5gLS1hcHAtaGVhZGVyLWJhY2tncm91bmQtcmVhci1sYXllcmAgfCBBcHBsaWVzIHRvIHRoZSByZWFyIGxheWVyIG9mIHRoZSBiYWNrZ3JvdW5kLiB8IHt9XG5gLS1hcHAtaGVhZGVyLXNoYWRvd2AgfCBBcHBsaWVzIHRvIHRoZSBzaGFkb3cuIHwge31cblxuQGdyb3VwIEFwcCBFbGVtZW50c1xuQGVsZW1lbnQgYXBwLWhlYWRlclxuQGRlbW8gYXBwLWhlYWRlci9kZW1vL2JsZW5kLWJhY2tncm91bmQtMS5odG1sIEJsZW5kIEJhY2tncm91bmQgSW1hZ2VcbkBkZW1vIGFwcC1oZWFkZXIvZGVtby9ibGVuZC1iYWNrZ3JvdW5kLTIuaHRtbCBCbGVuZCAyIEJhY2tncm91bmQgSW1hZ2VzXG5AZGVtbyBhcHAtaGVhZGVyL2RlbW8vYmxlbmQtYmFja2dyb3VuZC0zLmh0bWwgQmxlbmQgQmFja2dyb3VuZCBDb2xvcnNcbkBkZW1vIGFwcC1oZWFkZXIvZGVtby9jb250YWN0cy5odG1sIENvbnRhY3RzIERlbW9cbkBkZW1vIGFwcC1oZWFkZXIvZGVtby9naXZlLmh0bWwgUmVzaXplIFNuYXBwZWQgVGl0bGUgRGVtb1xuQGRlbW8gYXBwLWhlYWRlci9kZW1vL211c2ljLmh0bWwgUmV2ZWFscyBEZW1vXG5AZGVtbyBhcHAtaGVhZGVyL2RlbW8vbm8tZWZmZWN0cy5odG1sIENvbmRlbnNlcyBhbmQgUmV2ZWFscyBEZW1vXG5AZGVtbyBhcHAtaGVhZGVyL2RlbW8vbm90ZXMuaHRtbCBGaXhlZCB3aXRoIER5bmFtaWMgU2hhZG93IERlbW9cbkBkZW1vIGFwcC1oZWFkZXIvZGVtby9jdXN0b20tc3RpY2t5LWVsZW1lbnQtMS5odG1sIEN1c3RvbSBTdGlja3kgRWxlbWVudCBEZW1vIDFcbkBkZW1vIGFwcC1oZWFkZXIvZGVtby9jdXN0b20tc3RpY2t5LWVsZW1lbnQtMi5odG1sIEN1c3RvbSBTdGlja3kgRWxlbWVudCBEZW1vIDJcblxuLS0+XG5cbjxkb20tbW9kdWxlIGlkPVwiYXBwLWhlYWRlclwiPlxuICA8dGVtcGxhdGU+XG4gICAgPHN0eWxlPlxuICAgICAgOmhvc3Qge1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgICAgICB0cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvbjogbGluZWFyO1xuICAgICAgICB0cmFuc2l0aW9uLXByb3BlcnR5OiAtd2Via2l0LXRyYW5zZm9ybTtcbiAgICAgICAgdHJhbnNpdGlvbi1wcm9wZXJ0eTogdHJhbnNmb3JtO1xuICAgICAgfVxuXG4gICAgICA6aG9zdDo6YmVmb3JlIHtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICByaWdodDogMHB4O1xuICAgICAgICBib3R0b206IC01cHg7XG4gICAgICAgIGxlZnQ6IDBweDtcbiAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgIGhlaWdodDogNXB4O1xuICAgICAgICBjb250ZW50OiBcIlwiO1xuICAgICAgICB0cmFuc2l0aW9uOiBvcGFjaXR5IDAuNHM7XG4gICAgICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xuICAgICAgICBvcGFjaXR5OiAwO1xuICAgICAgICBib3gtc2hhZG93OiBpbnNldCAwcHggNXB4IDZweCAtM3B4IHJnYmEoMCwgMCwgMCwgMC40KTtcbiAgICAgICAgd2lsbC1jaGFuZ2U6IG9wYWNpdHk7XG4gICAgICAgIEBhcHBseSAtLWFwcC1oZWFkZXItc2hhZG93O1xuICAgICAgfVxuXG4gICAgICA6aG9zdChbc2hhZG93XSk6OmJlZm9yZSB7XG4gICAgICAgIG9wYWNpdHk6IDE7XG4gICAgICB9XG5cbiAgICAgICNiYWNrZ3JvdW5kIHtcbiAgICAgICAgQGFwcGx5IC0tbGF5b3V0LWZpdDtcbiAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICAgIH1cblxuICAgICAgI2JhY2tncm91bmRGcm9udExheWVyLFxuICAgICAgI2JhY2tncm91bmRSZWFyTGF5ZXIge1xuICAgICAgICBAYXBwbHkgLS1sYXlvdXQtZml0O1xuICAgICAgICBoZWlnaHQ6IDEwMCU7XG4gICAgICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xuICAgICAgICBiYWNrZ3JvdW5kLXNpemU6IGNvdmVyO1xuICAgICAgfVxuXG4gICAgICAjYmFja2dyb3VuZEZyb250TGF5ZXIge1xuICAgICAgICBAYXBwbHkgLS1hcHAtaGVhZGVyLWJhY2tncm91bmQtZnJvbnQtbGF5ZXI7XG4gICAgICB9XG5cbiAgICAgICNiYWNrZ3JvdW5kUmVhckxheWVyIHtcbiAgICAgICAgb3BhY2l0eTogMDtcbiAgICAgICAgQGFwcGx5IC0tYXBwLWhlYWRlci1iYWNrZ3JvdW5kLXJlYXItbGF5ZXI7XG4gICAgICB9XG5cbiAgICAgICNjb250ZW50Q29udGFpbmVyIHtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgaGVpZ2h0OiAxMDAlO1xuICAgICAgfVxuXG4gICAgICA6aG9zdChbZGlzYWJsZWRdKSxcbiAgICAgIDpob3N0KFtkaXNhYmxlZF0pOjphZnRlcixcbiAgICAgIDpob3N0KFtkaXNhYmxlZF0pICNiYWNrZ3JvdW5kRnJvbnRMYXllcixcbiAgICAgIDpob3N0KFtkaXNhYmxlZF0pICNiYWNrZ3JvdW5kUmVhckxheWVyLFxuICAgICAgLyogU2lsZW50IHNjcm9sbGluZyBzaG91bGQgbm90IHJ1biBDU1MgdHJhbnNpdGlvbnMgKi9cbiAgICAgIDpob3N0KFtzaWxlbnQtc2Nyb2xsXSksXG4gICAgICA6aG9zdChbc2lsZW50LXNjcm9sbF0pOjphZnRlcixcbiAgICAgIDpob3N0KFtzaWxlbnQtc2Nyb2xsXSkgI2JhY2tncm91bmRGcm9udExheWVyLFxuICAgICAgOmhvc3QoW3NpbGVudC1zY3JvbGxdKSAjYmFja2dyb3VuZFJlYXJMYXllciB7XG4gICAgICAgIHRyYW5zaXRpb246IG5vbmUgIWltcG9ydGFudDtcbiAgICAgIH1cblxuICAgICAgOmhvc3QoW2Rpc2FibGVkXSkgOjpzbG90dGVkKGFwcC10b29sYmFyOmZpcnN0LW9mLXR5cGUpLFxuICAgICAgOmhvc3QoW2Rpc2FibGVkXSkgOjpzbG90dGVkKFtzdGlja3ldKSxcbiAgICAgIC8qIFNpbGVudCBzY3JvbGxpbmcgc2hvdWxkIG5vdCBydW4gQ1NTIHRyYW5zaXRpb25zICovXG4gICAgICA6aG9zdChbc2lsZW50LXNjcm9sbF0pIDo6c2xvdHRlZChhcHAtdG9vbGJhcjpmaXJzdC1vZi10eXBlKSxcbiAgICAgIDpob3N0KFtzaWxlbnQtc2Nyb2xsXSkgOjpzbG90dGVkKFtzdGlja3ldKSB7XG4gICAgICAgIHRyYW5zaXRpb246IG5vbmUgIWltcG9ydGFudDtcbiAgICAgIH1cblxuICAgIDwvc3R5bGU+XG4gICAgPGRpdiBpZD1cImNvbnRlbnRDb250YWluZXJcIj5cbiAgICAgIDxzbG90IGlkPVwic2xvdFwiPjwvc2xvdD5cbiAgICA8L2Rpdj5cbiAgPC90ZW1wbGF0ZT5cblxuICA8c2NyaXB0PlxuICAgIFBvbHltZXIoe1xuICAgICAgaXM6ICdhcHAtaGVhZGVyJyxcblxuICAgICAgYmVoYXZpb3JzOiBbXG4gICAgICAgIFBvbHltZXIuQXBwU2Nyb2xsRWZmZWN0c0JlaGF2aW9yLFxuICAgICAgICBQb2x5bWVyLkFwcExheW91dEJlaGF2aW9yXG4gICAgICBdLFxuXG4gICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0cnVlLCB0aGUgaGVhZGVyIHdpbGwgYXV0b21hdGljYWxseSBjb2xsYXBzZSB3aGVuIHNjcm9sbGluZyBkb3duLlxuICAgICAgICAgKiBUaGF0IGlzLCB0aGUgYHN0aWNreWAgZWxlbWVudCByZW1haW5zIHZpc2libGUgd2hlbiB0aGUgaGVhZGVyIGlzIGZ1bGx5IGNvbmRlbnNlZFxuICAgICAgICAgKiB3aGVyZWFzIHRoZSByZXN0IG9mIHRoZSBlbGVtZW50cyB3aWxsIGNvbGxhcHNlIGJlbG93IGBzdGlja3lgIGVsZW1lbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEJ5IGRlZmF1bHQsIHRoZSBgc3RpY2t5YCBlbGVtZW50IGlzIHRoZSBmaXJzdCB0b29sYmFyIGluIHRoZSBsaWdodCBET006XG4gICAgICAgICAqXG4gICAgICAgICAqYGBgaHRtbFxuICAgICAgICAgKiA8YXBwLWhlYWRlciBjb25kZW5zZXM+XG4gICAgICAgICAqICAgPGFwcC10b29sYmFyPlRoaXMgdG9vbGJhciByZW1haW5zIG9uIHRvcDwvYXBwLXRvb2xiYXI+XG4gICAgICAgICAqICAgPGFwcC10b29sYmFyPjwvYXBwLXRvb2xiYXI+XG4gICAgICAgICAqICAgPGFwcC10b29sYmFyPjwvYXBwLXRvb2xiYXI+XG4gICAgICAgICAqIDwvYXBwLWhlYWRlcj5cbiAgICAgICAgICogYGBgXG4gICAgICAgICAqXG4gICAgICAgICAqIEFkZGl0aW9uYWxseSwgeW91IGNhbiBzcGVjaWZ5IHdoaWNoIHRvb2xiYXIgb3IgZWxlbWVudCByZW1haW5zIHZpc2libGUgaW4gY29uZGVuc2VkIG1vZGVcbiAgICAgICAgICogYnkgYWRkaW5nIHRoZSBgc3RpY2t5YCBhdHRyaWJ1dGUgdG8gdGhhdCBlbGVtZW50LiBGb3IgZXhhbXBsZTogaWYgd2Ugd2FudCB0aGUgbGFzdFxuICAgICAgICAgKiB0b29sYmFyIHRvIHJlbWFpbiB2aXNpYmxlLCB3ZSBjYW4gYWRkIHRoZSBgc3RpY2t5YCBhdHRyaWJ1dGUgdG8gaXQuXG4gICAgICAgICAqXG4gICAgICAgICAqYGBgaHRtbFxuICAgICAgICAgKiA8YXBwLWhlYWRlciBjb25kZW5zZXM+XG4gICAgICAgICAqICAgPGFwcC10b29sYmFyPjwvYXBwLXRvb2xiYXI+XG4gICAgICAgICAqICAgPGFwcC10b29sYmFyPjwvYXBwLXRvb2xiYXI+XG4gICAgICAgICAqICAgPGFwcC10b29sYmFyIHN0aWNreT5UaGlzIHRvb2xiYXIgcmVtYWlucyBvbiB0b3A8L2FwcC10b29sYmFyPlxuICAgICAgICAgKiA8L2FwcC1oZWFkZXI+XG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKlxuICAgICAgICAgKiBOb3RlIHRoZSBgc3RpY2t5YCBlbGVtZW50IG11c3QgYmUgYSBkaXJlY3QgY2hpbGQgb2YgYGFwcC1oZWFkZXJgLlxuICAgICAgICAgKi9cbiAgICAgICAgY29uZGVuc2VzOiB7XG4gICAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogTWFudGFpbnMgdGhlIGhlYWRlciBmaXhlZCBhdCB0aGUgdG9wIHNvIGl0IG5ldmVyIG1vdmVzIGF3YXkuXG4gICAgICAgICAqL1xuICAgICAgICBmaXhlZDoge1xuICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNsaWRlcyBiYWNrIHRoZSBoZWFkZXIgd2hlbiBzY3JvbGxpbmcgYmFjayB1cC5cbiAgICAgICAgICovXG4gICAgICAgIHJldmVhbHM6IHtcbiAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEaXNwbGF5cyBhIHNoYWRvdyBiZWxvdyB0aGUgaGVhZGVyLlxuICAgICAgICAgKi9cbiAgICAgICAgc2hhZG93OiB7XG4gICAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgICByZWZsZWN0VG9BdHRyaWJ1dGU6IHRydWUsXG4gICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIG9ic2VydmVyczogW1xuICAgICAgICAnX2NvbmZpZ0NoYW5nZWQoaXNBdHRhY2hlZCwgY29uZGVuc2VzLCBmaXhlZCknXG4gICAgICBdLFxuXG4gICAgICAvKipcbiAgICAgICAqIEEgY2FjaGVkIG9mZnNldEhlaWdodCBvZiB0aGUgY3VycmVudCBlbGVtZW50LlxuICAgICAgICpcbiAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgKi9cbiAgICAgIF9oZWlnaHQ6IDAsXG5cbiAgICAgIC8qKlxuICAgICAgICogVGhlIGRpc3RhbmNlIGluIHBpeGVscyB0aGUgaGVhZGVyIHdpbGwgYmUgdHJhbnNsYXRlZCB0byB3aGVuIHNjcm9sbGluZy5cbiAgICAgICAqXG4gICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICovXG4gICAgICBfZEhlaWdodDogMCxcblxuICAgICAgLyoqXG4gICAgICAgKiBUaGUgb2Zmc2V0VG9wIG9mIGBfc3RpY2t5RWxgXG4gICAgICAgKlxuICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAqL1xuICAgICAgX3N0aWNreUVsVG9wOiAwLFxuXG4gICAgICAvKipcbiAgICAgICAqIEEgcmVmZXJlbmNlIHRvIHRoZSBlbGVtZW50IHRoYXQgcmVtYWlucyB2aXNpYmxlIHdoZW4gdGhlIGhlYWRlciBjb25kZW5zZXMuXG4gICAgICAgKlxuICAgICAgICogQHR5cGUge0hUTUxFbGVtZW50fVxuICAgICAgICovXG4gICAgICBfc3RpY2t5RWxSZWY6IG51bGwsXG5cbiAgICAgIC8qKlxuICAgICAgICogVGhlIGhlYWRlcidzIHRvcCB2YWx1ZSB1c2VkIGZvciB0aGUgYHRyYW5zZm9ybVlgXG4gICAgICAgKlxuICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAqL1xuICAgICAgX3RvcDogMCxcblxuICAgICAgLyoqXG4gICAgICAgKiBUaGUgY3VycmVudCBzY3JvbGwgcHJvZ3Jlc3MuXG4gICAgICAgKlxuICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAqL1xuICAgICAgX3Byb2dyZXNzOiAwLFxuXG4gICAgICBfd2FzU2Nyb2xsaW5nRG93bjogZmFsc2UsXG4gICAgICBfaW5pdFNjcm9sbFRvcDogMCxcbiAgICAgIF9pbml0VGltZXN0YW1wOiAwLFxuICAgICAgX2xhc3RUaW1lc3RhbXA6IDAsXG4gICAgICBfbGFzdFNjcm9sbFRvcDogMCxcblxuICAgICAgLyoqXG4gICAgICAgKiBUaGUgZGlzdGFuY2UgdGhlIGhlYWRlciBpcyBhbGxvd2VkIHRvIG1vdmUgYXdheS5cbiAgICAgICAqXG4gICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICovXG4gICAgICBnZXQgX21heEhlYWRlclRvcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZml4ZWQgPyB0aGlzLl9kSGVpZ2h0IDogdGhpcy5faGVpZ2h0ICsgNTtcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogUmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgc3RpY2t5IGVsZW1lbnQuXG4gICAgICAgKlxuICAgICAgICogQHJldHVybiB7SFRNTEVsZW1lbnR9P1xuICAgICAgICovXG4gICAgICBnZXQgX3N0aWNreUVsKCkge1xuICAgICAgICBpZiAodGhpcy5fc3RpY2t5RWxSZWYpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fc3RpY2t5RWxSZWY7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5vZGVzID0gUG9seW1lci5kb20odGhpcy4kLnNsb3QpLmdldERpc3RyaWJ1dGVkTm9kZXMoKTtcbiAgICAgICAgLy8gR2V0IHRoZSBlbGVtZW50IHdpdGggdGhlIHN0aWNreSBhdHRyaWJ1dGUgb24gaXQgb3IgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIGxpZ2h0IERPTS5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG5vZGU7IG5vZGUgPSBub2Rlc1tpXTsgaSsrKSB7XG4gICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5oYXNBdHRyaWJ1dGUoJ3N0aWNreScpKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3N0aWNreUVsUmVmID0gbm9kZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLl9zdGlja3lFbFJlZikge1xuICAgICAgICAgICAgICB0aGlzLl9zdGlja3lFbFJlZiA9IG5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGlja3lFbFJlZjtcbiAgICAgIH0sXG5cbiAgICAgIF9jb25maWdDaGFuZ2VkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5yZXNldExheW91dCgpO1xuICAgICAgICB0aGlzLl9ub3RpZnlMYXlvdXRDaGFuZ2VkKCk7XG4gICAgICB9LFxuXG4gICAgICBfdXBkYXRlTGF5b3V0U3RhdGVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMub2Zmc2V0V2lkdGggPT09IDAgJiYgdGhpcy5vZmZzZXRIZWlnaHQgPT09IDApIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNjcm9sbFRvcCA9IHRoaXMuX2NsYW1wZWRTY3JvbGxUb3A7XG4gICAgICAgIHZhciBmaXJzdFNldHVwID0gdGhpcy5faGVpZ2h0ID09PSAwIHx8IHNjcm9sbFRvcCA9PT0gMDtcbiAgICAgICAgdmFyIGN1cnJlbnREaXNhYmxlZCA9IHRoaXMuZGlzYWJsZWQ7XG4gICAgICAgIHRoaXMuX2hlaWdodCA9IHRoaXMub2Zmc2V0SGVpZ2h0O1xuICAgICAgICB0aGlzLl9zdGlja3lFbFJlZiA9IG51bGw7XG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICAvLyBwcmVwYXJlIGZvciBtZWFzdXJlbWVudFxuICAgICAgICBpZiAgKCFmaXJzdFNldHVwKSB7XG4gICAgICAgICAgdGhpcy5fdXBkYXRlU2Nyb2xsU3RhdGUoMCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX21heU1vdmUoKSkge1xuICAgICAgICAgIHRoaXMuX2RIZWlnaHQgPSB0aGlzLl9zdGlja3lFbCA/IHRoaXMuX2hlaWdodCAtIHRoaXMuX3N0aWNreUVsLm9mZnNldEhlaWdodCA6IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fZEhlaWdodCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc3RpY2t5RWxUb3AgPSB0aGlzLl9zdGlja3lFbCA/IHRoaXMuX3N0aWNreUVsLm9mZnNldFRvcCA6IDA7XG4gICAgICAgIHRoaXMuX3NldFVwRWZmZWN0KCk7XG4gICAgICAgIGlmIChmaXJzdFNldHVwKSB7XG4gICAgICAgICAgdGhpcy5fdXBkYXRlU2Nyb2xsU3RhdGUoc2Nyb2xsVG9wLCB0cnVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl91cGRhdGVTY3JvbGxTdGF0ZSh0aGlzLl9sYXN0U2Nyb2xsVG9wLCB0cnVlKTtcbiAgICAgICAgICB0aGlzLl9sYXlvdXRJZkRpcnR5KCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVzdG9yZSBubyB0cmFuc2l0aW9uXG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSBjdXJyZW50RGlzYWJsZWQ7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFVwZGF0ZXMgdGhlIHNjcm9sbCBzdGF0ZS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0gc2Nyb2xsVG9wXG4gICAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBmb3JjZVVwZGF0ZSAoZGVmYXVsdDogZmFsc2UpXG4gICAgICAgKi9cbiAgICAgIF91cGRhdGVTY3JvbGxTdGF0ZTogZnVuY3Rpb24oc2Nyb2xsVG9wLCBmb3JjZVVwZGF0ZSkge1xuICAgICAgICBpZiAodGhpcy5faGVpZ2h0ID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwcm9ncmVzcyA9IDA7XG4gICAgICAgIHZhciB0b3AgPSAwO1xuICAgICAgICB2YXIgbGFzdFRvcCA9IHRoaXMuX3RvcDtcbiAgICAgICAgdmFyIGxhc3RTY3JvbGxUb3AgPSB0aGlzLl9sYXN0U2Nyb2xsVG9wO1xuICAgICAgICB2YXIgbWF4SGVhZGVyVG9wID0gdGhpcy5fbWF4SGVhZGVyVG9wO1xuICAgICAgICB2YXIgZFNjcm9sbFRvcCA9IHNjcm9sbFRvcCAtIHRoaXMuX2xhc3RTY3JvbGxUb3A7XG4gICAgICAgIHZhciBhYnNEU2Nyb2xsVG9wID0gTWF0aC5hYnMoZFNjcm9sbFRvcCk7XG4gICAgICAgIHZhciBpc1Njcm9sbGluZ0Rvd24gPSBzY3JvbGxUb3AgPiB0aGlzLl9sYXN0U2Nyb2xsVG9wO1xuICAgICAgICB2YXIgbm93ID0gcGVyZm9ybWFuY2Uubm93KCk7XG5cbiAgICAgICAgaWYgKHRoaXMuX21heU1vdmUoKSkge1xuICAgICAgICAgIHRvcCA9IHRoaXMuX2NsYW1wKHRoaXMucmV2ZWFscyA/IGxhc3RUb3AgKyBkU2Nyb2xsVG9wIDogc2Nyb2xsVG9wLCAwLCBtYXhIZWFkZXJUb3ApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzY3JvbGxUb3AgPj0gdGhpcy5fZEhlaWdodCkge1xuICAgICAgICAgIHRvcCA9IHRoaXMuY29uZGVuc2VzICYmICF0aGlzLmZpeGVkID8gTWF0aC5tYXgodGhpcy5fZEhlaWdodCwgdG9wKSA6IHRvcDtcbiAgICAgICAgICB0aGlzLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9ICcwbXMnO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnJldmVhbHMgJiYgIXRoaXMuZGlzYWJsZWQgJiYgYWJzRFNjcm9sbFRvcCA8IDEwMCkge1xuICAgICAgICAgIC8vIHNldCB0aGUgaW5pdGlhbCBzY3JvbGwgcG9zaXRpb25cbiAgICAgICAgICBpZiAobm93IC0gdGhpcy5faW5pdFRpbWVzdGFtcCA+IDMwMCB8fCB0aGlzLl93YXNTY3JvbGxpbmdEb3duICE9PSBpc1Njcm9sbGluZ0Rvd24pIHtcbiAgICAgICAgICAgIHRoaXMuX2luaXRTY3JvbGxUb3AgPSBzY3JvbGxUb3A7XG4gICAgICAgICAgICB0aGlzLl9pbml0VGltZXN0YW1wID0gbm93O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc2Nyb2xsVG9wID49IG1heEhlYWRlclRvcCkge1xuICAgICAgICAgICAgLy8gY2hlY2sgaWYgdGhlIGhlYWRlciBpcyBhbGxvd2VkIHRvIHNuYXBcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyh0aGlzLl9pbml0U2Nyb2xsVG9wIC0gc2Nyb2xsVG9wKSA+IDMwIHx8IGFic0RTY3JvbGxUb3AgPiAxMCkge1xuICAgICAgICAgICAgICBpZiAoaXNTY3JvbGxpbmdEb3duICYmIHNjcm9sbFRvcCA+PSBtYXhIZWFkZXJUb3ApIHtcbiAgICAgICAgICAgICAgICB0b3AgPSBtYXhIZWFkZXJUb3A7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWlzU2Nyb2xsaW5nRG93biAmJiBzY3JvbGxUb3AgPj0gdGhpcy5fZEhlaWdodCkge1xuICAgICAgICAgICAgICAgIHRvcCA9IHRoaXMuY29uZGVuc2VzICYmICF0aGlzLmZpeGVkID8gdGhpcy5fZEhlaWdodCA6IDA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFyIHNjcm9sbFZlbG9jaXR5ID0gZFNjcm9sbFRvcCAvIChub3cgLSB0aGlzLl9sYXN0VGltZXN0YW1wKTtcbiAgICAgICAgICAgICAgdGhpcy5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPSB0aGlzLl9jbGFtcCgodG9wIC0gbGFzdFRvcCkgLyBzY3JvbGxWZWxvY2l0eSwgMCwgMzAwKSArICdtcyc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0b3AgPSB0aGlzLl90b3A7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9kSGVpZ2h0ID09PSAwKSB7XG4gICAgICAgICAgcHJvZ3Jlc3MgPSBzY3JvbGxUb3AgPiAwID8gMSA6IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJvZ3Jlc3MgPSB0b3AgLyB0aGlzLl9kSGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIGlmICghZm9yY2VVcGRhdGUpIHtcbiAgICAgICAgICB0aGlzLl9sYXN0U2Nyb2xsVG9wID0gc2Nyb2xsVG9wO1xuICAgICAgICAgIHRoaXMuX3RvcCA9IHRvcDtcbiAgICAgICAgICB0aGlzLl93YXNTY3JvbGxpbmdEb3duID0gaXNTY3JvbGxpbmdEb3duO1xuICAgICAgICAgIHRoaXMuX2xhc3RUaW1lc3RhbXAgPSBub3c7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvcmNlVXBkYXRlIHx8IHByb2dyZXNzICE9PSB0aGlzLl9wcm9ncmVzcyB8fCBsYXN0VG9wICE9PSB0b3AgfHwgc2Nyb2xsVG9wID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5fcHJvZ3Jlc3MgPSBwcm9ncmVzcztcbiAgICAgICAgICB0aGlzLl9ydW5FZmZlY3RzKHByb2dyZXNzLCB0b3ApO1xuICAgICAgICAgIHRoaXMuX3RyYW5zZm9ybUhlYWRlcih0b3ApO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgY3VycmVudCBoZWFkZXIgaXMgYWxsb3dlZCB0byBtb3ZlIGFzIHRoZSB1c2VyIHNjcm9sbHMuXG4gICAgICAgKlxuICAgICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgICAqL1xuICAgICAgX21heU1vdmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25kZW5zZXMgfHwgIXRoaXMuZml4ZWQ7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgY3VycmVudCBoZWFkZXIgd2lsbCBjb25kZW5zZSBiYXNlZCBvbiB0aGUgc2l6ZSBvZiB0aGUgaGVhZGVyXG4gICAgICAgKiBhbmQgdGhlIGBjb25zZW5zZXNgIHByb3BlcnR5LlxuICAgICAgICpcbiAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICAgKi9cbiAgICAgIHdpbGxDb25kZW5zZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kSGVpZ2h0ID4gMCAmJiB0aGlzLmNvbmRlbnNlcztcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBjdXJyZW50IGVsZW1lbnQgaXMgb24gdGhlIHNjcmVlbi5cbiAgICAgICAqIFRoYXQgaXMsIHZpc2libGUgaW4gdGhlIGN1cnJlbnQgdmlld3BvcnQuXG4gICAgICAgKlxuICAgICAgICogQG1ldGhvZCBpc09uU2NyZWVuXG4gICAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAgICovXG4gICAgICBpc09uU2NyZWVuOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hlaWdodCAhPT0gMCAmJiB0aGlzLl90b3AgPCB0aGlzLl9oZWlnaHQ7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGVyZSdzIGNvbnRlbnQgYmVsb3cgdGhlIGN1cnJlbnQgZWxlbWVudC5cbiAgICAgICAqXG4gICAgICAgKiBAbWV0aG9kIGlzQ29udGVudEJlbG93XG4gICAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAgICovXG4gICAgICBpc0NvbnRlbnRCZWxvdzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90b3AgPT09IDAgPyB0aGlzLl9jbGFtcGVkU2Nyb2xsVG9wID4gMCA6XG4gICAgICAgICAgICB0aGlzLl9jbGFtcGVkU2Nyb2xsVG9wIC0gdGhpcy5fbWF4SGVhZGVyVG9wID49IDA7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFRyYW5zZm9ybXMgdGhlIGhlYWRlci5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgICAgICovXG4gICAgICBfdHJhbnNmb3JtSGVhZGVyOiBmdW5jdGlvbih5KSB7XG4gICAgICAgIHRoaXMudHJhbnNsYXRlM2QoMCwgKC15KSArICdweCcsIDApO1xuICAgICAgICBpZiAodGhpcy5fc3RpY2t5RWwpIHtcbiAgICAgICAgICB0aGlzLnRyYW5zbGF0ZTNkKDAsIHRoaXMuY29uZGVuc2VzICYmIHkgPj0gdGhpcy5fc3RpY2t5RWxUb3AgP1xuICAgICAgICAgICAgICAoTWF0aC5taW4oeSwgdGhpcy5fZEhlaWdodCkgLSB0aGlzLl9zdGlja3lFbFRvcCkgKyAncHgnIDogMCwgIDAsIHRoaXMuX3N0aWNreUVsKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgX2NsYW1wOiBmdW5jdGlvbih2LCBtaW4sIG1heCkge1xuICAgICAgICByZXR1cm4gTWF0aC5taW4obWF4LCBNYXRoLm1heChtaW4sIHYpKTtcbiAgICAgIH0sXG5cbiAgICAgIF9lbnN1cmVCZ0NvbnRhaW5lcnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2JnQ29udGFpbmVyKSB7XG4gICAgICAgICAgdGhpcy5fYmdDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICB0aGlzLl9iZ0NvbnRhaW5lci5pZCA9ICdiYWNrZ3JvdW5kJztcbiAgICAgICAgICB0aGlzLl9iZ1JlYXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICB0aGlzLl9iZ1JlYXIuaWQgPSAnYmFja2dyb3VuZFJlYXJMYXllcic7XG4gICAgICAgICAgdGhpcy5fYmdDb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5fYmdSZWFyKTtcbiAgICAgICAgICB0aGlzLl9iZ0Zyb250ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgdGhpcy5fYmdGcm9udC5pZCA9ICdiYWNrZ3JvdW5kRnJvbnRMYXllcic7XG4gICAgICAgICAgdGhpcy5fYmdDb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5fYmdGcm9udCk7XG4gICAgICAgICAgUG9seW1lci5kb20odGhpcy5yb290KS5pbnNlcnRCZWZvcmUodGhpcy5fYmdDb250YWluZXIsIHRoaXMuJC5jb250ZW50Q29udGFpbmVyKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgX2dldERPTVJlZjogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgc3dpdGNoIChpZCkge1xuICAgICAgICAgIGNhc2UgJ2JhY2tncm91bmRGcm9udExheWVyJzpcbiAgICAgICAgICAgIHRoaXMuX2Vuc3VyZUJnQ29udGFpbmVycygpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2JnRnJvbnQ7XG4gICAgICAgICAgY2FzZSAnYmFja2dyb3VuZFJlYXJMYXllcic6XG4gICAgICAgICAgICB0aGlzLl9lbnN1cmVCZ0NvbnRhaW5lcnMoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9iZ1JlYXI7XG4gICAgICAgICAgY2FzZSAnYmFja2dyb3VuZCc6XG4gICAgICAgICAgICB0aGlzLl9lbnN1cmVCZ0NvbnRhaW5lcnMoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9iZ0NvbnRhaW5lcjtcbiAgICAgICAgICBjYXNlICdtYWluVGl0bGUnOlxuICAgICAgICAgICAgcmV0dXJuIFBvbHltZXIuZG9tKHRoaXMpLnF1ZXJ5U2VsZWN0b3IoJ1ttYWluLXRpdGxlXScpO1xuICAgICAgICAgIGNhc2UgJ2NvbmRlbnNlZFRpdGxlJzpcbiAgICAgICAgICAgIHJldHVybiBQb2x5bWVyLmRvbSh0aGlzKS5xdWVyeVNlbGVjdG9yKCdbY29uZGVuc2VkLXRpdGxlXScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBSZXR1cm5zIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSBwcm9ncmVzcyB2YWx1ZSBvZiB0aGUgc2Nyb2xsIGVmZmVjdHNcbiAgICAgICAqIGFuZCB0aGUgdG9wIHBvc2l0aW9uIG9mIHRoZSBoZWFkZXIuXG4gICAgICAgKlxuICAgICAgICogQG1ldGhvZCBnZXRTY3JvbGxTdGF0ZVxuICAgICAgICogQHJldHVybiB7T2JqZWN0fVxuICAgICAgICovXG4gICAgICBnZXRTY3JvbGxTdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB7IHByb2dyZXNzOiB0aGlzLl9wcm9ncmVzcywgdG9wOiB0aGlzLl90b3AgfTtcbiAgICAgIH1cbiAgICB9KTtcbiAgPC9zY3JpcHQ+XG48L2RvbS1tb2R1bGU+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL2FwcC1sYXlvdXQvYXBwLWhlYWRlci9hcHAtaGVhZGVyLmh0bWwiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi8uLi9wb2x5bWVyL3BvbHltZXIuaHRtbFwiPlxuXG48c2NyaXB0PlxuICBQb2x5bWVyLkFwcExheW91dCA9IFBvbHltZXIuQXBwTGF5b3V0IHx8IHt9O1xuXG4gIFBvbHltZXIuQXBwTGF5b3V0Ll9zY3JvbGxFZmZlY3RzID0gUG9seW1lci5BcHBMYXlvdXQuX3Njcm9sbEVmZmVjdHMgfHwge307XG5cbiAgUG9seW1lci5BcHBMYXlvdXQuc2Nyb2xsVGltaW5nRnVuY3Rpb24gPSBmdW5jdGlvbiBlYXNlT3V0UXVhZCh0LCBiLCBjLCBkKSB7XG4gICAgdCAvPSBkO1xuICAgIHJldHVybiAtYyAqIHQqKHQtMikgKyBiO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgYSBzY3JvbGwgZWZmZWN0IHRvIGJlIHVzZWQgaW4gZWxlbWVudHMgdGhhdCBpbXBsZW1lbnQgdGhlXG4gICAqIGBQb2x5bWVyLkFwcFNjcm9sbEVmZmVjdHNCZWhhdmlvcmAgYmVoYXZpb3IuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBlZmZlY3ROYW1lIFRoZSBlZmZlY3QgbmFtZS5cbiAgICogQHBhcmFtIHtPYmplY3R9IGVmZmVjdERlZiBUaGUgZWZmZWN0IGRlZmluaXRpb24uXG4gICAqL1xuICBQb2x5bWVyLkFwcExheW91dC5yZWdpc3RlckVmZmVjdCA9IGZ1bmN0aW9uIHJlZ2lzdGVyRWZmZWN0KGVmZmVjdE5hbWUsIGVmZmVjdERlZikge1xuICAgIGlmIChQb2x5bWVyLkFwcExheW91dC5fc2Nyb2xsRWZmZWN0c1tlZmZlY3ROYW1lXSAhPSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2VmZmVjdCBgJysgZWZmZWN0TmFtZSArICdgIGlzIGFscmVhZHkgcmVnaXN0ZXJlZC4nKTtcbiAgICB9XG4gICAgUG9seW1lci5BcHBMYXlvdXQuX3Njcm9sbEVmZmVjdHNbZWZmZWN0TmFtZV0gPSBlZmZlY3REZWY7XG4gIH07XG5cblxuICBQb2x5bWVyLkFwcExheW91dC5xdWVyeUFsbFJvb3QgPSBmdW5jdGlvbihzZWxlY3Rvciwgcm9vdCkge1xuICAgIHZhciBxdWV1ZSA9IFtyb290XTtcbiAgICB2YXIgbWF0Y2hlcyA9IFtdO1xuXG4gICAgd2hpbGUgKHF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgIHZhciBub2RlID0gcXVldWUuc2hpZnQoKTtcbiAgICAgIG1hdGNoZXMucHVzaC5hcHBseShtYXRjaGVzLCBub2RlLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpKTtcbiAgICAgIGZvciAoaSA9IDA7IG5vZGUuY2hpbGRyZW5baV07IGkrKykge1xuICAgICAgICBpZiAobm9kZS5jaGlsZHJlbltpXS5zaGFkb3dSb290KSB7XG4gICAgICAgICAgcXVldWUucHVzaChub2RlLmNoaWxkcmVuW2ldLnNoYWRvd1Jvb3QpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtYXRjaGVzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTY3JvbGxzIHRvIGEgcGFydGljdWxhciBzZXQgb2YgY29vcmRpbmF0ZXMgaW4gYSBzY3JvbGwgdGFyZ2V0LlxuICAgKiBJZiB0aGUgc2Nyb2xsIHRhcmdldCBpcyBub3QgZGVmaW5lZCwgdGhlbiBpdCB3b3VsZCB1c2UgdGhlIG1haW4gZG9jdW1lbnQgYXMgdGhlIHRhcmdldC5cbiAgICpcbiAgICogVG8gc2Nyb2xsIGluIGEgc21vb3RoIGZhc2hpb24sIHlvdSBjYW4gc2V0IHRoZSBvcHRpb24gYGJlaGF2aW9yOiAnc21vb3RoJ2AuIGUuZy5cbiAgICpcbiAgICogYGBganNcbiAgICogUG9seW1lci5BcHBMYXlvdXQuc2Nyb2xsKHt0b3A6IDAsIGJlaGF2aW9yOiAnc21vb3RoJ30pO1xuICAgKiBgYGBcbiAgICpcbiAgICogVG8gc2Nyb2xsIGluIGEgc2lsZW50IG1vZGUsIHdpdGhvdXQgbm90aWZ5aW5nIHNjcm9sbCBjaGFuZ2VzIHRvIGFueSBhcHAtbGF5b3V0IGVsZW1lbnRzLFxuICAgKiB5b3UgY2FuIHNldCB0aGUgb3B0aW9uIGBiZWhhdmlvcjogJ3NpbGVudCdgLiBUaGlzIGlzIHBhcnRpY3VsYXJseSB1c2VmdWwgd2UgeW91IGFyZSB1c2luZ1xuICAgKiBgYXBwLWhlYWRlcmAgYW5kIHlvdSBkZXNpcmUgdG8gc2Nyb2xsIHRvIHRoZSB0b3Agb2YgYSBzY3JvbGxpbmcgcmVnaW9uIHdpdGhvdXQgcnVubmluZ1xuICAgKiBzY3JvbGwgZWZmZWN0cy4gZS5nLlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiBQb2x5bWVyLkFwcExheW91dC5zY3JvbGwoe3RvcDogMCwgYmVoYXZpb3I6ICdzaWxlbnQnfSk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyB7dG9wOiBOdW1iZXIsIGxlZnQ6IE51bWJlciwgYmVoYXZpb3I6IFN0cmluZyhzbW9vdGggfCBzaWxlbnQpfVxuICAgKi9cbiAgUG9seW1lci5BcHBMYXlvdXQuc2Nyb2xsID0gZnVuY3Rpb24gc2Nyb2xsKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIHZhciBkb2NFbCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICB2YXIgdGFyZ2V0ID0gb3B0aW9ucy50YXJnZXQgfHwgZG9jRWw7XG4gICAgdmFyIGhhc05hdGl2ZVNjcm9sbEJlaGF2aW9yID0gJ3Njcm9sbEJlaGF2aW9yJyBpbiB0YXJnZXQuc3R5bGUgJiYgdGFyZ2V0LnNjcm9sbDtcbiAgICB2YXIgc2Nyb2xsQ2xhc3NOYW1lID0gJ2FwcC1sYXlvdXQtc2lsZW50LXNjcm9sbCc7XG4gICAgdmFyIHNjcm9sbFRvcCA9IG9wdGlvbnMudG9wIHx8IDA7XG4gICAgdmFyIHNjcm9sbExlZnQgPSBvcHRpb25zLmxlZnQgfHwgMDtcbiAgICB2YXIgc2Nyb2xsVG8gPSB0YXJnZXQgPT09IGRvY0VsID8gd2luZG93LnNjcm9sbFRvIDpcbiAgICAgIGZ1bmN0aW9uIHNjcm9sbFRvKHNjcm9sbExlZnQsIHNjcm9sbFRvcCkge1xuICAgICAgICB0YXJnZXQuc2Nyb2xsTGVmdCA9IHNjcm9sbExlZnQ7XG4gICAgICAgIHRhcmdldC5zY3JvbGxUb3AgPSBzY3JvbGxUb3A7XG4gICAgICB9O1xuXG4gICAgaWYgKG9wdGlvbnMuYmVoYXZpb3IgPT09ICdzbW9vdGgnKSB7XG5cbiAgICAgIGlmIChoYXNOYXRpdmVTY3JvbGxCZWhhdmlvcikge1xuXG4gICAgICAgIHRhcmdldC5zY3JvbGwob3B0aW9ucyk7XG5cbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgdmFyIHRpbWluZ0ZuID0gUG9seW1lci5BcHBMYXlvdXQuc2Nyb2xsVGltaW5nRnVuY3Rpb247XG4gICAgICAgIHZhciBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICB2YXIgY3VycmVudFNjcm9sbFRvcCA9IHRhcmdldCA9PT0gZG9jRWwgPyB3aW5kb3cucGFnZVlPZmZzZXQgOiB0YXJnZXQuc2Nyb2xsVG9wO1xuICAgICAgICB2YXIgY3VycmVudFNjcm9sbExlZnQgPSB0YXJnZXQgPT09IGRvY0VsID8gd2luZG93LnBhZ2VYT2Zmc2V0IDogdGFyZ2V0LnNjcm9sbExlZnQ7XG4gICAgICAgIHZhciBkZWx0YVNjcm9sbFRvcCA9IHNjcm9sbFRvcCAtIGN1cnJlbnRTY3JvbGxUb3A7XG4gICAgICAgIHZhciBkZWx0YVNjcm9sbExlZnQgPSBzY3JvbGxMZWZ0IC0gY3VycmVudFNjcm9sbExlZnQ7XG4gICAgICAgIHZhciBkdXJhdGlvbiA9IDMwMDtcbiAgICAgICAgdmFyIHVwZGF0ZUZyYW1lID0gKGZ1bmN0aW9uIHVwZGF0ZUZyYW1lKCkge1xuICAgICAgICAgIHZhciBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICAgIHZhciBlbGFwc2VkVGltZSA9IG5vdyAtIHN0YXJ0VGltZTtcblxuICAgICAgICAgIGlmIChlbGFwc2VkVGltZSA8IGR1cmF0aW9uKSB7XG4gICAgICAgICAgICBzY3JvbGxUbyh0aW1pbmdGbihlbGFwc2VkVGltZSwgY3VycmVudFNjcm9sbExlZnQsIGRlbHRhU2Nyb2xsTGVmdCwgZHVyYXRpb24pLFxuICAgICAgICAgICAgICAgIHRpbWluZ0ZuKGVsYXBzZWRUaW1lLCBjdXJyZW50U2Nyb2xsVG9wLCBkZWx0YVNjcm9sbFRvcCwgZHVyYXRpb24pKTtcbiAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSh1cGRhdGVGcmFtZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNjcm9sbFRvKHNjcm9sbExlZnQsIHNjcm9sbFRvcCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KS5iaW5kKHRoaXMpO1xuXG4gICAgICAgIHVwZGF0ZUZyYW1lKCk7XG4gICAgICB9XG5cbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMuYmVoYXZpb3IgPT09ICdzaWxlbnQnKSB7XG4gICAgICB2YXIgaGVhZGVycyA9IFBvbHltZXIuQXBwTGF5b3V0LnF1ZXJ5QWxsUm9vdCgnYXBwLWhlYWRlcicsIGRvY3VtZW50LmJvZHkpO1xuXG4gICAgICBoZWFkZXJzLmZvckVhY2goZnVuY3Rpb24oaGVhZGVyKSB7XG4gICAgICAgIGhlYWRlci5zZXRBdHRyaWJ1dGUoJ3NpbGVudC1zY3JvbGwnLCAnJyk7XG4gICAgICB9KTtcblxuICAgICAgLy8gQnJvd3NlcnMga2VlcCB0aGUgc2Nyb2xsIG1vbWVudHVtIGV2ZW4gaWYgdGhlIGJvdHRvbSBvZiB0aGUgc2Nyb2xsaW5nIGNvbnRlbnRcbiAgICAgIC8vIHdhcyByZWFjaGVkLiBUaGlzIG1lYW5zIHRoYXQgY2FsbGluZyBzY3JvbGwoe3RvcDogMCwgYmVoYXZpb3I6ICdzaWxlbnQnfSkgd2hlblxuICAgICAgLy8gdGhlIG1vbWVudHVtIGlzIHN0aWxsIGdvaW5nIHdpbGwgcmVzdWx0IGluIG1vcmUgc2Nyb2xsIGV2ZW50cyBhbmQgdGh1cyBzY3JvbGwgZWZmZWN0cy5cbiAgICAgIC8vIFRoaXMgc2VlbXMgdG8gb25seSBhcHBseSB3aGVuIHVzaW5nIGRvY3VtZW50IHNjcm9sbGluZy5cbiAgICAgIC8vIFRoZXJlZm9yZSwgd2hlbiBzaG91bGQgd2UgcmVtb3ZlIHRoZSBjbGFzcyBmcm9tIHRoZSBkb2N1bWVudCBlbGVtZW50P1xuXG4gICAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUoUG9seW1lci5BcHBMYXlvdXQuX3Njcm9sbFRpbWVyKTtcblxuICAgICAgUG9seW1lci5BcHBMYXlvdXQuX3Njcm9sbFRpbWVyID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbigpIHtcbiAgICAgICAgaGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uKGhlYWRlcikge1xuICAgICAgICAgIGhlYWRlci5yZW1vdmVBdHRyaWJ1dGUoJ3NpbGVudC1zY3JvbGwnKTtcbiAgICAgICAgfSk7XG4gICAgICAgIFBvbHltZXIuQXBwTGF5b3V0Ll9zY3JvbGxUaW1lciA9IG51bGw7XG4gICAgICB9KTtcblxuICAgICAgc2Nyb2xsVG8oc2Nyb2xsTGVmdCwgc2Nyb2xsVG9wKTtcblxuICAgIH0gZWxzZSB7XG5cbiAgICAgIHNjcm9sbFRvKHNjcm9sbExlZnQsIHNjcm9sbFRvcCk7XG5cbiAgICB9XG4gIH07XG5cbjwvc2NyaXB0PlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9hcHAtbGF5b3V0L2hlbHBlcnMvaGVscGVycy5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNSBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuXG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vLi4vcG9seW1lci9wb2x5bWVyLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi8uLi9pcm9uLWZsZXgtbGF5b3V0L2lyb24tZmxleC1sYXlvdXQuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL2FwcC1sYXlvdXQtYmVoYXZpb3IvYXBwLWxheW91dC1iZWhhdmlvci5odG1sXCI+XG5cbjwhLS1cbmFwcC1oZWFkZXItbGF5b3V0IGlzIGEgd3JhcHBlciBlbGVtZW50IHRoYXQgcG9zaXRpb25zIGFuIGFwcC1oZWFkZXIgYW5kIG90aGVyIGNvbnRlbnQuIFRoaXNcbmVsZW1lbnQgdXNlcyB0aGUgZG9jdW1lbnQgc2Nyb2xsIGJ5IGRlZmF1bHQsIGJ1dCBpdCBjYW4gYWxzbyBkZWZpbmUgaXRzIG93biBzY3JvbGxpbmcgcmVnaW9uLlxuXG5Vc2luZyB0aGUgZG9jdW1lbnQgc2Nyb2xsOlxuXG5gYGBodG1sXG48YXBwLWhlYWRlci1sYXlvdXQ+XG4gIDxhcHAtaGVhZGVyIHNsb3Q9XCJoZWFkZXJcIiBmaXhlZCBjb25kZW5zZXMgZWZmZWN0cz1cIndhdGVyZmFsbFwiPlxuICAgIDxhcHAtdG9vbGJhcj5cbiAgICAgIDxkaXYgbWFpbi10aXRsZT5BcHAgbmFtZTwvZGl2PlxuICAgIDwvYXBwLXRvb2xiYXI+XG4gIDwvYXBwLWhlYWRlcj5cbiAgPGRpdj5cbiAgICBtYWluIGNvbnRlbnRcbiAgPC9kaXY+XG48L2FwcC1oZWFkZXItbGF5b3V0PlxuYGBgXG5cblVzaW5nIGFuIG93biBzY3JvbGxpbmcgcmVnaW9uOlxuXG5gYGBodG1sXG48YXBwLWhlYWRlci1sYXlvdXQgaGFzLXNjcm9sbGluZy1yZWdpb24gc3R5bGU9XCJ3aWR0aDogMzAwcHg7IGhlaWdodDogNDAwcHg7XCI+XG4gIDxhcHAtaGVhZGVyIHNsb3Q9XCJoZWFkZXJcIiBmaXhlZCBjb25kZW5zZXMgZWZmZWN0cz1cIndhdGVyZmFsbFwiPlxuICAgIDxhcHAtdG9vbGJhcj5cbiAgICAgIDxkaXYgbWFpbi10aXRsZT5BcHAgbmFtZTwvZGl2PlxuICAgIDwvYXBwLXRvb2xiYXI+XG4gIDwvYXBwLWhlYWRlcj5cbiAgPGRpdj5cbiAgICBtYWluIGNvbnRlbnRcbiAgPC9kaXY+XG48L2FwcC1oZWFkZXItbGF5b3V0PlxuYGBgXG5cbkFkZCB0aGUgYGZ1bGxibGVlZGAgYXR0cmlidXRlIHRvIGFwcC1oZWFkZXItbGF5b3V0IHRvIG1ha2UgaXQgZml0IHRoZSBzaXplIG9mIGl0cyBjb250YWluZXI6XG5cbmBgYGh0bWxcbjxhcHAtaGVhZGVyLWxheW91dCBmdWxsYmxlZWQ+XG4gLi4uXG48L2FwcC1oZWFkZXItbGF5b3V0PlxuYGBgXG5cbkBncm91cCBBcHAgRWxlbWVudHNcbkBlbGVtZW50IGFwcC1oZWFkZXItbGF5b3V0XG5AZGVtbyBhcHAtaGVhZGVyLWxheW91dC9kZW1vL3NpbXBsZS5odG1sIFNpbXBsZSBEZW1vXG5AZGVtbyBhcHAtaGVhZGVyLWxheW91dC9kZW1vL3Njcm9sbGluZy1yZWdpb24uaHRtbCBTY3JvbGxpbmcgUmVnaW9uXG5AZGVtbyBhcHAtaGVhZGVyLWxheW91dC9kZW1vL211c2ljLmh0bWwgTXVzaWMgRGVtb1xuQGRlbW8gYXBwLWhlYWRlci1sYXlvdXQvZGVtby9mb290ZXIuaHRtbCBGb290ZXIgRGVtb1xuLS0+XG5cbjxkb20tbW9kdWxlIGlkPVwiYXBwLWhlYWRlci1sYXlvdXRcIj5cbiAgPHRlbXBsYXRlPlxuICAgIDxzdHlsZT5cbiAgICAgIDpob3N0IHtcbiAgICAgICAgZGlzcGxheTogYmxvY2s7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGb3JjZSBhcHAtaGVhZGVyLWxheW91dCB0byBoYXZlIGl0cyBvd24gc3RhY2tpbmcgY29udGV4dCBzbyB0aGF0IGl0cyBwYXJlbnQgY2FuXG4gICAgICAgICAqIGNvbnRyb2wgdGhlIHN0YWNraW5nIG9mIGl0IHJlbGF0aXZlIHRvIG90aGVyIGVsZW1lbnRzIChlLmcuIGFwcC1kcmF3ZXItbGF5b3V0KS5cbiAgICAgICAgICogVGhpcyBjb3VsZCBiZSBkb25lIHVzaW5nIGBpc29sYXRpb246IGlzb2xhdGVgLCBidXQgdGhhdCdzIG5vdCB3ZWxsIHN1cHBvcnRlZFxuICAgICAgICAgKiBhY3Jvc3MgYnJvd3NlcnMuXG4gICAgICAgICAqL1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgIHotaW5kZXg6IDA7XG4gICAgICB9XG5cbiAgICAgICN3cmFwcGVyIDo6c2xvdHRlZChbc2xvdD1oZWFkZXJdKSB7XG4gICAgICAgIEBhcHBseSAtLWxheW91dC1maXhlZC10b3A7XG4gICAgICAgIHotaW5kZXg6IDE7XG4gICAgICB9XG5cbiAgICAgICN3cmFwcGVyLmluaXRpYWxpemluZyA6OnNsb3R0ZWQoW3Nsb3Q9aGVhZGVyXSkge1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICB9XG5cbiAgICAgIDpob3N0KFtoYXMtc2Nyb2xsaW5nLXJlZ2lvbl0pIHtcbiAgICAgICAgaGVpZ2h0OiAxMDAlO1xuICAgICAgfVxuXG4gICAgICA6aG9zdChbaGFzLXNjcm9sbGluZy1yZWdpb25dKSAjd3JhcHBlciA6OnNsb3R0ZWQoW3Nsb3Q9aGVhZGVyXSkge1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICB9XG5cbiAgICAgIDpob3N0KFtoYXMtc2Nyb2xsaW5nLXJlZ2lvbl0pICN3cmFwcGVyLmluaXRpYWxpemluZyA6OnNsb3R0ZWQoW3Nsb3Q9aGVhZGVyXSkge1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICB9XG5cbiAgICAgIDpob3N0KFtoYXMtc2Nyb2xsaW5nLXJlZ2lvbl0pICN3cmFwcGVyICNjb250ZW50Q29udGFpbmVyIHtcbiAgICAgICAgQGFwcGx5IC0tbGF5b3V0LWZpdDtcbiAgICAgICAgb3ZlcmZsb3cteTogYXV0bztcbiAgICAgICAgLXdlYmtpdC1vdmVyZmxvdy1zY3JvbGxpbmc6IHRvdWNoO1xuICAgICAgfVxuXG4gICAgICA6aG9zdChbaGFzLXNjcm9sbGluZy1yZWdpb25dKSAjd3JhcHBlci5pbml0aWFsaXppbmcgI2NvbnRlbnRDb250YWluZXIge1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICB9XG5cbiAgICAgIDpob3N0KFtmdWxsYmxlZWRdKSB7XG4gICAgICAgIEBhcHBseSAtLWxheW91dC12ZXJ0aWNhbDtcbiAgICAgICAgQGFwcGx5IC0tbGF5b3V0LWZpdDtcbiAgICAgIH1cblxuICAgICAgOmhvc3QoW2Z1bGxibGVlZF0pICN3cmFwcGVyLFxuICAgICAgOmhvc3QoW2Z1bGxibGVlZF0pICN3cmFwcGVyICNjb250ZW50Q29udGFpbmVyIHtcbiAgICAgICAgQGFwcGx5IC0tbGF5b3V0LXZlcnRpY2FsO1xuICAgICAgICBAYXBwbHkgLS1sYXlvdXQtZmxleDtcbiAgICAgIH1cblxuICAgICAgI2NvbnRlbnRDb250YWluZXIge1xuICAgICAgICAvKiBDcmVhdGUgYSBzdGFja2luZyBjb250ZXh0IGhlcmUgc28gdGhhdCBhbGwgY2hpbGRyZW4gYXBwZWFyIGJlbG93IHRoZSBoZWFkZXIuICovXG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgei1pbmRleDogMDtcbiAgICAgIH1cblxuICAgIDwvc3R5bGU+XG5cbiAgICA8ZGl2IGlkPVwid3JhcHBlclwiIGNsYXNzPVwiaW5pdGlhbGl6aW5nXCI+XG4gICAgICA8c2xvdCBpZD1cImhlYWRlclNsb3RcIiBuYW1lPVwiaGVhZGVyXCI+PC9zbG90PlxuXG4gICAgICA8ZGl2IGlkPVwiY29udGVudENvbnRhaW5lclwiPlxuICAgICAgICA8c2xvdD48L3Nsb3Q+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cblxuICA8L3RlbXBsYXRlPlxuXG4gIDxzY3JpcHQ+XG4gICAgUG9seW1lcih7XG4gICAgICBpczogJ2FwcC1oZWFkZXItbGF5b3V0JyxcblxuICAgICAgYmVoYXZpb3JzOiBbXG4gICAgICAgIFBvbHltZXIuQXBwTGF5b3V0QmVoYXZpb3JcbiAgICAgIF0sXG5cbiAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHRydWUsIHRoZSBjdXJyZW50IGVsZW1lbnQgd2lsbCBoYXZlIGl0cyBvd24gc2Nyb2xsaW5nIHJlZ2lvbi5cbiAgICAgICAgICogT3RoZXJ3aXNlLCBpdCB3aWxsIHVzZSB0aGUgZG9jdW1lbnQgc2Nyb2xsIHRvIGNvbnRyb2wgdGhlIGhlYWRlci5cbiAgICAgICAgICovXG4gICAgICAgIGhhc1Njcm9sbGluZ1JlZ2lvbjoge1xuICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgICAgdmFsdWU6IGZhbHNlLFxuICAgICAgICAgIHJlZmxlY3RUb0F0dHJpYnV0ZTogdHJ1ZVxuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBvYnNlcnZlcnM6IFtcbiAgICAgICAgJ3Jlc2V0TGF5b3V0KGlzQXR0YWNoZWQsIGhhc1Njcm9sbGluZ1JlZ2lvbiknXG4gICAgICBdLFxuXG4gICAgICAvKipcbiAgICAgICAqIEEgcmVmZXJlbmNlIHRvIHRoZSBhcHAtaGVhZGVyIGVsZW1lbnQuXG4gICAgICAgKlxuICAgICAgICogQHByb3BlcnR5IGhlYWRlclxuICAgICAgICovXG4gICAgICBnZXQgaGVhZGVyKCkge1xuICAgICAgICByZXR1cm4gUG9seW1lci5kb20odGhpcy4kLmhlYWRlclNsb3QpLmdldERpc3RyaWJ1dGVkTm9kZXMoKVswXTtcbiAgICAgIH0sXG5cbiAgICAgIF91cGRhdGVMYXlvdXRTdGF0ZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaGVhZGVyID0gdGhpcy5oZWFkZXI7XG4gICAgICAgIGlmICghdGhpcy5pc0F0dGFjaGVkIHx8ICFoZWFkZXIpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBpbml0aWFsaXppbmcgY2xhc3MsIHdoaWNoIHN0YXRpY2x5IHBvc2l0aW9ucyB0aGUgaGVhZGVyIGFuZCB0aGUgY29udGVudFxuICAgICAgICAvLyB1bnRpbCB0aGUgaGVpZ2h0IG9mIHRoZSBoZWFkZXIgY2FuIGJlIHJlYWQuXG4gICAgICAgIHRoaXMuJC53cmFwcGVyLmNsYXNzTGlzdC5yZW1vdmUoJ2luaXRpYWxpemluZycpO1xuICAgICAgICAvLyBVcGRhdGUgc2Nyb2xsIHRhcmdldC5cbiAgICAgICAgaGVhZGVyLnNjcm9sbFRhcmdldCA9IHRoaXMuaGFzU2Nyb2xsaW5nUmVnaW9uID9cbiAgICAgICAgICAgIHRoaXMuJC5jb250ZW50Q29udGFpbmVyIDogdGhpcy5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgLy8gR2V0IGhlYWRlciBoZWlnaHQgaGVyZSBzbyB0aGF0IHN0eWxlIHJlYWRzIGFyZSBiYXRjaGVkIHRvZ2V0aGVyIGJlZm9yZSBzdHlsZSB3cml0ZXNcbiAgICAgICAgLy8gKGkuZS4gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkgYmVsb3cpLlxuICAgICAgICB2YXIgaGVhZGVySGVpZ2h0ID0gaGVhZGVyLm9mZnNldEhlaWdodDtcbiAgICAgICAgLy8gVXBkYXRlIHRoZSBoZWFkZXIgcG9zaXRpb24uXG4gICAgICAgIGlmICghdGhpcy5oYXNTY3JvbGxpbmdSZWdpb24pIHtcbiAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgcmVjdCA9IHRoaXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICB2YXIgcmlnaHRPZmZzZXQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGggLSByZWN0LnJpZ2h0O1xuICAgICAgICAgICAgaGVhZGVyLnN0eWxlLmxlZnQgPSByZWN0LmxlZnQgKyAncHgnO1xuICAgICAgICAgICAgaGVhZGVyLnN0eWxlLnJpZ2h0ID0gcmlnaHRPZmZzZXQgKyAncHgnO1xuICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaGVhZGVyLnN0eWxlLmxlZnQgPSAnJztcbiAgICAgICAgICBoZWFkZXIuc3R5bGUucmlnaHQgPSAnJztcbiAgICAgICAgfVxuICAgICAgICAvLyBVcGRhdGUgdGhlIGNvbnRlbnQgY29udGFpbmVyIHBvc2l0aW9uLlxuICAgICAgICB2YXIgY29udGFpbmVyU3R5bGUgPSB0aGlzLiQuY29udGVudENvbnRhaW5lci5zdHlsZTtcbiAgICAgICAgaWYgKGhlYWRlci5maXhlZCAmJiAhaGVhZGVyLmNvbmRlbnNlcyAmJiB0aGlzLmhhc1Njcm9sbGluZ1JlZ2lvbikge1xuICAgICAgICAgIC8vIElmIHRoZSBoZWFkZXIgc2l6ZSBkb2VzIG5vdCBjaGFuZ2UgYW5kIHdlJ3JlIHVzaW5nIGEgc2Nyb2xsaW5nIHJlZ2lvbiwgZXhjbHVkZVxuICAgICAgICAgIC8vIHRoZSBoZWFkZXIgYXJlYSBmcm9tIHRoZSBzY3JvbGxpbmcgcmVnaW9uIHNvIHRoYXQgdGhlIGhlYWRlciBkb2Vzbid0IG92ZXJsYXBcbiAgICAgICAgICAvLyB0aGUgc2Nyb2xsYmFyLlxuICAgICAgICAgIGNvbnRhaW5lclN0eWxlLm1hcmdpblRvcCA9IGhlYWRlckhlaWdodCArICdweCc7XG4gICAgICAgICAgY29udGFpbmVyU3R5bGUucGFkZGluZ1RvcCA9ICcnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnRhaW5lclN0eWxlLnBhZGRpbmdUb3AgPSBoZWFkZXJIZWlnaHQgKyAncHgnO1xuICAgICAgICAgIGNvbnRhaW5lclN0eWxlLm1hcmdpblRvcCA9ICcnO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICB9KTtcbiAgPC9zY3JpcHQ+XG48L2RvbS1tb2R1bGU+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL2FwcC1sYXlvdXQvYXBwLWhlYWRlci1sYXlvdXQvYXBwLWhlYWRlci1sYXlvdXQuaHRtbCIsIlxucmVxdWlyZSgnLi9lZmZlY3RzL2JsZW5kLWJhY2tncm91bmQuaHRtbCcpO1xuXG5yZXF1aXJlKCcuL2VmZmVjdHMvZmFkZS1iYWNrZ3JvdW5kLmh0bWwnKTtcblxucmVxdWlyZSgnLi9lZmZlY3RzL21hdGVyaWFsLmh0bWwnKTtcblxucmVxdWlyZSgnLi9lZmZlY3RzL3BhcmFsbGF4LWJhY2tncm91bmQuaHRtbCcpO1xuXG5yZXF1aXJlKCcuL2VmZmVjdHMvcmVzaXplLXNuYXBwZWQtdGl0bGUuaHRtbCcpO1xuXG5yZXF1aXJlKCcuL2VmZmVjdHMvcmVzaXplLXRpdGxlLmh0bWwnKTtcblxucmVxdWlyZSgnLi9lZmZlY3RzL3dhdGVyZmFsbC5odG1sJyk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL2FwcC1sYXlvdXQvYXBwLXNjcm9sbC1lZmZlY3RzL2FwcC1zY3JvbGwtZWZmZWN0cy5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNiBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuXG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vYXBwLXNjcm9sbC1lZmZlY3RzLWJlaGF2aW9yLmh0bWxcIj5cblxuPHNjcmlwdD5cbiAgLyoqXG4gICAqIFVwb24gc2Nyb2xsaW5nIHBhc3QgYSB0aHJlc2hvbGQsIGZhZGUgaW4gdGhlIHJlYXIgYmFja2dyb3VuZCBsYXllciBhbmQgZmFkZSBvdXQgdGhlIGZyb250XG4gICAqIGJhY2tncm91bmQgbGF5ZXIgKG9wYWNpdHkgQ1NTIHRyYW5zaXRpb25lZCBvdmVyIHRpbWUpLlxuICAgKlxuICAgKlxuICAgKi9cbiAgUG9seW1lci5BcHBMYXlvdXQucmVnaXN0ZXJFZmZlY3QoJ2ZhZGUtYmFja2dyb3VuZCcsIHtcbiAgICAvKiogQHRoaXMgUG9seW1lci5BcHBMYXlvdXQuRWxlbWVudFdpdGhCYWNrZ3JvdW5kICovXG4gICAgc2V0VXA6IGZ1bmN0aW9uIHNldFVwKGNvbmZpZykge1xuICAgICAgdmFyIGZ4ID0ge307XG4gICAgICB2YXIgZHVyYXRpb24gPSBjb25maWcuZHVyYXRpb24gfHwgJzAuNXMnO1xuICAgICAgZnguYmFja2dyb3VuZEZyb250TGF5ZXIgPSB0aGlzLl9nZXRET01SZWYoJ2JhY2tncm91bmRGcm9udExheWVyJyk7XG4gICAgICBmeC5iYWNrZ3JvdW5kUmVhckxheWVyID0gdGhpcy5fZ2V0RE9NUmVmKCdiYWNrZ3JvdW5kUmVhckxheWVyJyk7XG4gICAgICBmeC5iYWNrZ3JvdW5kRnJvbnRMYXllci5zdHlsZS53aWxsQ2hhbmdlID0gJ29wYWNpdHknO1xuICAgICAgZnguYmFja2dyb3VuZEZyb250TGF5ZXIuc3R5bGUud2Via2l0VHJhbnNmb3JtID0gJ3RyYW5zbGF0ZVooMCknO1xuICAgICAgZnguYmFja2dyb3VuZEZyb250TGF5ZXIuc3R5bGUudHJhbnNpdGlvblByb3BlcnR5ID0gJ29wYWNpdHknO1xuICAgICAgZnguYmFja2dyb3VuZEZyb250TGF5ZXIuc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID0gZHVyYXRpb247XG4gICAgICBmeC5iYWNrZ3JvdW5kUmVhckxheWVyLnN0eWxlLndpbGxDaGFuZ2UgPSAnb3BhY2l0eSc7XG4gICAgICBmeC5iYWNrZ3JvdW5kUmVhckxheWVyLnN0eWxlLndlYmtpdFRyYW5zZm9ybSA9ICd0cmFuc2xhdGVaKDApJztcbiAgICAgIGZ4LmJhY2tncm91bmRSZWFyTGF5ZXIuc3R5bGUudHJhbnNpdGlvblByb3BlcnR5ID0gJ29wYWNpdHknO1xuICAgICAgZnguYmFja2dyb3VuZFJlYXJMYXllci5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPSBkdXJhdGlvbjtcbiAgICAgIHRoaXMuX2Z4RmFkZUJhY2tncm91bmQgPSBmeDtcbiAgICB9LFxuICAgIC8qKiBAdGhpcyBQb2x5bWVyLkFwcExheW91dC5FbGVtZW50V2l0aEJhY2tncm91bmQgKi9cbiAgICBydW46IGZ1bmN0aW9uIHJ1bihwLCB5KSB7XG4gICAgICB2YXIgZnggPSB0aGlzLl9meEZhZGVCYWNrZ3JvdW5kO1xuICAgICAgaWYgKHAgPj0gMSkge1xuICAgICAgICBmeC5iYWNrZ3JvdW5kRnJvbnRMYXllci5zdHlsZS5vcGFjaXR5ID0gMDtcbiAgICAgICAgZnguYmFja2dyb3VuZFJlYXJMYXllci5zdHlsZS5vcGFjaXR5ID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZ4LmJhY2tncm91bmRGcm9udExheWVyLnN0eWxlLm9wYWNpdHkgPSAxO1xuICAgICAgICBmeC5iYWNrZ3JvdW5kUmVhckxheWVyLnN0eWxlLm9wYWNpdHkgPSAwO1xuICAgICAgfVxuICAgIH0sXG4gICAgLyoqIEB0aGlzIFBvbHltZXIuQXBwTGF5b3V0LkVsZW1lbnRXaXRoQmFja2dyb3VuZCAqL1xuICAgIHRlYXJEb3duOiBmdW5jdGlvbiB0ZWFyRG93bigpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLl9meEZhZGVCYWNrZ3JvdW5kO1xuICAgIH1cbiAgfSk7XG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvYXBwLWxheW91dC9hcHAtc2Nyb2xsLWVmZmVjdHMvZWZmZWN0cy9mYWRlLWJhY2tncm91bmQuaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTYgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cblxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL2FwcC1zY3JvbGwtZWZmZWN0cy1iZWhhdmlvci5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwid2F0ZXJmYWxsLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCJyZXNpemUtdGl0bGUuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cImJsZW5kLWJhY2tncm91bmQuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cInBhcmFsbGF4LWJhY2tncm91bmQuaHRtbFwiPlxuXG48c2NyaXB0PlxuICAvKipcbiAgICogU2hvcnRoYW5kIGZvciB0aGUgd2F0ZXJmYWxsLCByZXNpemUtdGl0bGUsIGJsZW5kLWJhY2tncm91bmQsIGFuZCBwYXJhbGxheC1iYWNrZ3JvdW5kIGVmZmVjdHMuXG4gICAqL1xuICBQb2x5bWVyLkFwcExheW91dC5yZWdpc3RlckVmZmVjdCgnbWF0ZXJpYWwnLCB7XG4gICAgLyoqXG4gICAgICogQHRoaXMgUG9seW1lci5BcHBMYXlvdXQuRWxlbWVudFdpdGhCYWNrZ3JvdW5kXG4gICAgICovXG4gICAgc2V0VXA6IGZ1bmN0aW9uIHNldFVwKCkge1xuICAgICAgdGhpcy5lZmZlY3RzID0gJ3dhdGVyZmFsbCByZXNpemUtdGl0bGUgYmxlbmQtYmFja2dyb3VuZCBwYXJhbGxheC1iYWNrZ3JvdW5kJztcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0pO1xuPC9zY3JpcHQ+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL2FwcC1sYXlvdXQvYXBwLXNjcm9sbC1lZmZlY3RzL2VmZmVjdHMvbWF0ZXJpYWwuaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTYgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cblxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL2FwcC1zY3JvbGwtZWZmZWN0cy1iZWhhdmlvci5odG1sXCI+XG5cbjxzY3JpcHQ+XG4gIC8qKlxuICAgKiBVcG9uIHNjcm9sbGluZyBwYXN0IGEgdGhyZXNob2xkLCBDU1MgdHJhbnNpdGlvbiB0aGUgZm9udCBzaXplIG9mIGEgZGVzaWduYXRlZCB0aXRsZSBlbGVtZW50XG4gICAqIGJldHdlZW4gdHdvIHZhbHVlcy5cbiAgICovXG4gIFBvbHltZXIuQXBwTGF5b3V0LnJlZ2lzdGVyRWZmZWN0KCdyZXNpemUtc25hcHBlZC10aXRsZScsIHtcbiAgICAvKipcbiAgICAgKiBAdGhpcyBQb2x5bWVyLkFwcExheW91dC5FbGVtZW50V2l0aEJhY2tncm91bmRcbiAgICAgKi9cbiAgICBzZXRVcDogZnVuY3Rpb24gc2V0VXAoY29uZmlnKSB7XG4gICAgICB2YXIgdGl0bGUgPSB0aGlzLl9nZXRET01SZWYoJ21haW5UaXRsZScpO1xuICAgICAgdmFyIGNvbmRlbnNlZFRpdGxlID0gdGhpcy5fZ2V0RE9NUmVmKCdjb25kZW5zZWRUaXRsZScpO1xuICAgICAgdmFyIGR1cmF0aW9uID0gY29uZmlnLmR1cmF0aW9uIHx8ICcwLjJzJztcbiAgICAgIHZhciBmeCA9IHt9O1xuXG4gICAgICBpZiAoIWNvbmRlbnNlZFRpdGxlKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignU2Nyb2xsIGVmZmVjdCBgcmVzaXplLXNuYXBwZWQtdGl0bGVgOiB1bmRlZmluZWQgYGNvbmRlbnNlZC10aXRsZWAnKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKCF0aXRsZSkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1Njcm9sbCBlZmZlY3QgYHJlc2l6ZS1zbmFwcGVkLXRpdGxlYDogdW5kZWZpbmVkIGBtYWluLXRpdGxlYCcpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHRpdGxlLnN0eWxlLnRyYW5zaXRpb25Qcm9wZXJ0eSA9ICdvcGFjaXR5JztcbiAgICAgIHRpdGxlLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9IGR1cmF0aW9uO1xuICAgICAgY29uZGVuc2VkVGl0bGUuc3R5bGUudHJhbnNpdGlvblByb3BlcnR5ID0gJ29wYWNpdHknO1xuICAgICAgY29uZGVuc2VkVGl0bGUuc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID0gZHVyYXRpb247XG4gICAgICBmeC5jb25kZW5zZWRUaXRsZSA9IGNvbmRlbnNlZFRpdGxlO1xuICAgICAgZngudGl0bGUgPSB0aXRsZTtcbiAgICAgIHRoaXMuX2Z4UmVzaXplU25hcHBlZFRpdGxlID0gZng7XG4gICAgfSxcbiAgICAvKiogQHRoaXMgUG9seW1lci5BcHBMYXlvdXQuRWxlbWVudFdpdGhCYWNrZ3JvdW5kICovXG4gICAgcnVuOiBmdW5jdGlvbiBydW4ocCwgeSkge1xuICAgICAgdmFyIGZ4ID0gdGhpcy5fZnhSZXNpemVTbmFwcGVkVGl0bGU7XG4gICAgICBpZiAocCA+IDApIHtcbiAgICAgICAgZngudGl0bGUuc3R5bGUub3BhY2l0eSA9IDA7XG4gICAgICAgIGZ4LmNvbmRlbnNlZFRpdGxlLnN0eWxlLm9wYWNpdHkgPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZngudGl0bGUuc3R5bGUub3BhY2l0eSA9IDE7XG4gICAgICAgIGZ4LmNvbmRlbnNlZFRpdGxlLnN0eWxlLm9wYWNpdHkgPSAwO1xuICAgICAgfVxuICAgIH0sXG4gICAgLyoqIEB0aGlzIFBvbHltZXIuQXBwTGF5b3V0LkVsZW1lbnRXaXRoQmFja2dyb3VuZCAqL1xuICAgIHRlYXJEb3duOiBmdW5jdGlvbiB0ZWFyRG93bigpIHtcbiAgICAgIHZhciBmeCA9IHRoaXMuX2Z4UmVzaXplU25hcHBlZFRpdGxlO1xuICAgICAgZngudGl0bGUuc3R5bGUudHJhbnNpdGlvbiA9ICcnO1xuICAgICAgZnguY29uZGVuc2VkVGl0bGUuc3R5bGUudHJhbnNpdGlvbiA9ICcnO1xuICAgICAgZGVsZXRlIHRoaXMuX2Z4UmVzaXplU25hcHBlZFRpdGxlO1xuICAgIH1cbiAgfSk7XG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvYXBwLWxheW91dC9hcHAtc2Nyb2xsLWVmZmVjdHMvZWZmZWN0cy9yZXNpemUtc25hcHBlZC10aXRsZS5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNSBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuXG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vLi4vcG9seW1lci9wb2x5bWVyLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi8uLi9pcm9uLWZsZXgtbGF5b3V0L2lyb24tZmxleC1sYXlvdXQuaHRtbFwiPlxuXG48IS0tXG5hcHAtdG9vbGJhciBpcyBhIGhvcml6b250YWwgdG9vbGJhciBjb250YWluaW5nIGl0ZW1zIHRoYXQgY2FuIGJlIHVzZWQgZm9yXG5sYWJlbCwgbmF2aWdhdGlvbiwgc2VhcmNoIGFuZCBhY3Rpb25zLlxuXG4jIyMgRXhhbXBsZVxuXG5BZGQgYSB0aXRsZSB0byB0aGUgdG9vbGJhci5cblxuYGBgaHRtbFxuPGFwcC10b29sYmFyPlxuICA8ZGl2IG1haW4tdGl0bGU+QXBwIG5hbWU8L2Rpdj5cbjwvYXBwLXRvb2xiYXI+XG5gYGBcblxuQWRkIGEgYnV0dG9uIHRvIHRoZSBsZWZ0IGFuZCByaWdodCBzaWRlIG9mIHRoZSB0b29sYmFyLlxuXG5gYGBodG1sXG48YXBwLXRvb2xiYXI+XG4gIDxwYXBlci1pY29uLWJ1dHRvbiBpY29uPVwibWVudVwiPjwvcGFwZXItaWNvbi1idXR0b24+XG4gIDxkaXYgbWFpbi10aXRsZT5BcHAgbmFtZTwvZGl2PlxuICA8cGFwZXItaWNvbi1idXR0b24gaWNvbj1cInNlYXJjaFwiPjwvcGFwZXItaWNvbi1idXR0b24+XG48L2FwcC10b29sYmFyPlxuYGBgXG5cbllvdSBjYW4gdXNlIHRoZSBhdHRyaWJ1dGVzIGB0b3AtaXRlbWAgb3IgYGJvdHRvbS1pdGVtYCB0byBjb21wbGV0ZWx5IGZpdCBhbiBlbGVtZW50XG50byB0aGUgdG9wIG9yIGJvdHRvbSBvZiB0aGUgdG9vbGJhciByZXNwZWN0aXZlbHkuXG5cbiMjIyBDb250ZW50IGF0dHJpYnV0ZXNcblxuQXR0cmlidXRlICAgICAgICAgICAgfCBEZXNjcmlwdGlvblxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuYG1haW4tdGl0bGVgICAgICAgICAgfCBUaGUgbWFpbiB0aXRsZSBlbGVtZW50LlxuYGNvbmRlbnNlZC10aXRsZWAgICAgfCBUaGUgdGl0bGUgZWxlbWVudCBpZiB1c2VkIGluc2lkZSBhIGNvbmRlbnNlZCBhcHAtaGVhZGVyLlxuYHNwYWNlcmAgICAgICAgICAgICAgfCBBZGRzIGEgbGVmdCBtYXJnaW4gb2YgYDY0cHhgLlxuYGJvdHRvbS1pdGVtYCAgICAgICAgfCBTdGlja3MgdGhlIGVsZW1lbnQgdG8gdGhlIGJvdHRvbSBvZiB0aGUgdG9vbGJhci5cbmB0b3AtaXRlbWAgICAgICAgICAgIHwgU3RpY2tzIHRoZSBlbGVtZW50IHRvIHRoZSB0b3Agb2YgdGhlIHRvb2xiYXIuXG5cbiMjIyBTdHlsaW5nXG5cbkN1c3RvbSBwcm9wZXJ0eSAgICAgICAgICAgICAgfCBEZXNjcmlwdGlvbiAgICAgICAgICAgICAgICAgIHwgRGVmYXVsdFxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5gLS1hcHAtdG9vbGJhci1mb250LXNpemVgICAgIHwgVG9vbGJhciBmb250IHNpemUgICAgICAgICAgICB8IDIwcHhcblxuQGdyb3VwIEFwcCBFbGVtZW50c1xuQGVsZW1lbnQgYXBwLXRvb2xiYXJcbkBkZW1vIGFwcC10b29sYmFyL2RlbW8vaW5kZXguaHRtbFxuLS0+XG5cbjxkb20tbW9kdWxlIGlkPVwiYXBwLXRvb2xiYXJcIj5cbiAgPHRlbXBsYXRlPlxuICAgIDxzdHlsZT5cblxuICAgICAgOmhvc3Qge1xuICAgICAgICBAYXBwbHkgLS1sYXlvdXQtaG9yaXpvbnRhbDtcbiAgICAgICAgQGFwcGx5IC0tbGF5b3V0LWNlbnRlcjtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICBoZWlnaHQ6IDY0cHg7XG4gICAgICAgIHBhZGRpbmc6IDAgMTZweDtcbiAgICAgICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG4gICAgICAgIGZvbnQtc2l6ZTogdmFyKC0tYXBwLXRvb2xiYXItZm9udC1zaXplLCAyMHB4KTtcbiAgICAgIH1cblxuICAgICAgOmhvc3QgOjpzbG90dGVkKCopIHtcbiAgICAgICAgcG9pbnRlci1ldmVudHM6IGF1dG87XG4gICAgICB9XG5cbiAgICAgIDpob3N0IDo6c2xvdHRlZChwYXBlci1pY29uLWJ1dHRvbikge1xuICAgICAgICAvKiBwYXBlci1pY29uLWJ1dHRvbi9pc3N1ZXMvMzMgKi9cbiAgICAgICAgZm9udC1zaXplOiAwO1xuICAgICAgfVxuXG4gICAgICA6aG9zdCA6OnNsb3R0ZWQoW21haW4tdGl0bGVdKSxcbiAgICAgIDpob3N0IDo6c2xvdHRlZChbY29uZGVuc2VkLXRpdGxlXSkge1xuICAgICAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcbiAgICAgICAgQGFwcGx5IC0tbGF5b3V0LWZsZXg7XG4gICAgICB9XG5cbiAgICAgIDpob3N0IDo6c2xvdHRlZChbYm90dG9tLWl0ZW1dKSB7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgcmlnaHQ6IDA7XG4gICAgICAgIGJvdHRvbTogMDtcbiAgICAgICAgbGVmdDogMDtcbiAgICAgIH1cblxuICAgICAgOmhvc3QgOjpzbG90dGVkKFt0b3AtaXRlbV0pIHtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICB0b3A6IDA7XG4gICAgICAgIHJpZ2h0OiAwO1xuICAgICAgICBsZWZ0OiAwO1xuICAgICAgfVxuXG4gICAgICA6aG9zdCA6OnNsb3R0ZWQoW3NwYWNlcl0pIHtcbiAgICAgICAgbWFyZ2luLWxlZnQ6IDY0cHg7XG4gICAgICB9XG4gICAgPC9zdHlsZT5cblxuICAgIDxzbG90Pjwvc2xvdD5cblxuICA8L3RlbXBsYXRlPlxuXG4gIDxzY3JpcHQ+XG4gICAgUG9seW1lcih7XG4gICAgICBpczogJ2FwcC10b29sYmFyJ1xuICAgIH0pO1xuICA8L3NjcmlwdD5cbjwvZG9tLW1vZHVsZT5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvYXBwLWxheW91dC9hcHAtdG9vbGJhci9hcHAtdG9vbGJhci5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNiBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3BvbHltZXIvcG9seW1lci5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vaXJvbi1sb2NhdGlvbi9pcm9uLWxvY2F0aW9uLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi9pcm9uLWxvY2F0aW9uL2lyb24tcXVlcnktcGFyYW1zLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCJhcHAtcm91dGUtY29udmVydGVyLWJlaGF2aW9yLmh0bWxcIj5cblxuPCEtLVxuYGFwcC1sb2NhdGlvbmAgaXMgYW4gZWxlbWVudCB0aGF0IHByb3ZpZGVzIHN5bmNocm9uaXphdGlvbiBiZXR3ZWVuIHRoZVxuYnJvd3NlciBsb2NhdGlvbiBiYXIgYW5kIHRoZSBzdGF0ZSBvZiBhbiBhcHAuIFdoZW4gY3JlYXRlZCwgYGFwcC1sb2NhdGlvbmBcbmVsZW1lbnRzIHdpbGwgYXV0b21hdGljYWxseSB3YXRjaCB0aGUgZ2xvYmFsIGxvY2F0aW9uIGZvciBjaGFuZ2VzLiBBcyBjaGFuZ2VzXG5vY2N1ciwgYGFwcC1sb2NhdGlvbmAgcHJvZHVjZXMgYW5kIHVwZGF0ZXMgYW4gb2JqZWN0IGNhbGxlZCBgcm91dGVgLiBUaGlzXG5gcm91dGVgIG9iamVjdCBpcyBzdWl0YWJsZSBmb3IgcGFzc2luZyBpbnRvIGEgYGFwcC1yb3V0ZWAsIGFuZCBvdGhlciBzaW1pbGFyXG5lbGVtZW50cy5cblxuQW4gZXhhbXBsZSBvZiB0aGUgcHVibGljIEFQSSBvZiBhIHJvdXRlIG9iamVjdCB0aGF0IGRlc2NyaWJlcyB0aGUgVVJMXG5gaHR0cHM6Ly9lbGVtZW50cy5wb2x5bWVyLXByb2plY3Qub3JnL2VsZW1lbnRzL2FwcC1sb2NhdGlvbmA6XG5cbiAgICB7XG4gICAgICBwcmVmaXg6ICcnLFxuICAgICAgcGF0aDogJy9lbGVtZW50cy9hcHAtbG9jYXRpb24nXG4gICAgfVxuXG5FeGFtcGxlIFVzYWdlOlxuXG4gICAgPGFwcC1sb2NhdGlvbiByb3V0ZT1cInt7cm91dGV9fVwiPjwvYXBwLWxvY2F0aW9uPlxuICAgIDxhcHAtcm91dGUgcm91dGU9XCJ7e3JvdXRlfX1cIiBwYXR0ZXJuPVwiLzpwYWdlXCIgZGF0YT1cInt7ZGF0YX19XCI+PC9hcHAtcm91dGU+XG5cbkFzIHlvdSBjYW4gc2VlIGFib3ZlLCB0aGUgYGFwcC1sb2NhdGlvbmAgZWxlbWVudCBwcm9kdWNlcyBhIGByb3V0ZWAgYW5kIHRoYXRcbnByb3BlcnR5IGlzIHRoZW4gYm91bmQgaW50byB0aGUgYGFwcC1yb3V0ZWAgZWxlbWVudC4gVGhlIGJpbmRpbmdzIGFyZSB0d28tXG5kaXJlY3Rpb25hbCwgc28gd2hlbiBjaGFuZ2VzIHRvIHRoZSBgcm91dGVgIG9iamVjdCBvY2N1ciB3aXRoaW4gYGFwcC1yb3V0ZWAsXG50aGV5IGF1dG9tYXRpY2FsbHkgcmVmbGVjdCBiYWNrIHRvIHRoZSBnbG9iYWwgbG9jYXRpb24uXG5cbiMjIyBIYXNoZXMgdnMgUGF0aHNcblxuQnkgZGVmYXVsdCBgYXBwLWxvY2F0aW9uYCByb3V0ZXMgdXNpbmcgdGhlIHBhdGhuYW1lIHBvcnRpb24gb2YgdGhlIFVSTC4gVGhpcyBoYXNcbmJyb2FkIGJyb3dzZXIgc3VwcG9ydCBidXQgaXQgZG9lcyByZXF1aXJlIGNvb3BlcmF0aW9uIG9mIHRoZSBiYWNrZW5kIHNlcnZlci4gQW5cbmBhcHAtbG9jYXRpb25gIGNhbiBiZSBjb25maWd1cmVkIHRvIHVzZSB0aGUgaGFzaCBwYXJ0IG9mIGEgVVJMIGluc3RlYWQgdXNpbmdcbnRoZSBgdXNlLWhhc2gtYXMtcGF0aGAgYXR0cmlidXRlLCBsaWtlIHNvOlxuXG4gICAgPGFwcC1sb2NhdGlvbiByb3V0ZT1cInt7cm91dGV9fVwiIHVzZS1oYXNoLWFzLXBhdGg+PC9hcHAtbG9jYXRpb24+XG5cbiMjIyBJbnRlZ3JhdGluZyB3aXRoIG90aGVyIHJvdXRpbmcgY29kZVxuXG5UaGVyZSBpcyBubyBzdGFuZGFyZCBldmVudCB0aGF0IGlzIGZpcmVkIHdoZW4gd2luZG93LmxvY2F0aW9uIGlzIG1vZGlmaWVkLlxuYGFwcC1sb2NhdGlvbmAgZmlyZXMgYSBgbG9jYXRpb24tY2hhbmdlZGAgZXZlbnQgb24gYHdpbmRvd2Agd2hlbiBpdCB1cGRhdGVzIHRoZVxubG9jYXRpb24uIEl0IGFsc28gbGlzdGVucyBmb3IgdGhhdCBzYW1lIGV2ZW50LCBhbmQgcmUtcmVhZHMgdGhlIFVSTCB3aGVuIGl0J3NcbmZpcmVkLiBUaGlzIG1ha2VzIGl0IHZlcnkgZWFzeSB0byBpbnRlcm9wIHdpdGggb3RoZXIgcm91dGluZyBjb2RlLlxuXG5TbyBmb3IgZXhhbXBsZSBpZiB5b3Ugd2FudCB0byBuYXZpZ2F0ZSB0byBgL25ld19wYXRoYCBpbXBlcmF0aXZlbHkgeW91IGNvdWxkXG5jYWxsIGB3aW5kb3cubG9jYXRpb24ucHVzaFN0YXRlYCBvciBgd2luZG93LmxvY2F0aW9uLnJlcGxhY2VTdGF0ZWAgZm9sbG93ZWQgYnlcbmZpcmluZyBhIGBsb2NhdGlvbi1jaGFuZ2VkYCBldmVudCBvbiBgd2luZG93YC4gaS5lLlxuXG4gICAgd2luZG93Lmhpc3RvcnkucHVzaFN0YXRlKHt9LCBudWxsLCAnL25ld19wYXRoJyk7XG4gICAgd2luZG93LmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KCdsb2NhdGlvbi1jaGFuZ2VkJykpO1xuXG5AZWxlbWVudCBhcHAtbG9jYXRpb25cbkBkZW1vIGRlbW8vaW5kZXguaHRtbFxuLS0+XG48ZG9tLW1vZHVsZSBpZD1cImFwcC1sb2NhdGlvblwiPlxuICA8dGVtcGxhdGU+XG4gICAgPGlyb24tcXVlcnktcGFyYW1zXG4gICAgICAgIHBhcmFtcy1zdHJpbmc9XCJ7e19fcXVlcnl9fVwiXG4gICAgICAgIHBhcmFtcy1vYmplY3Q9XCJ7e3F1ZXJ5UGFyYW1zfX1cIj5cbiAgICA8L2lyb24tcXVlcnktcGFyYW1zPlxuICAgIDxpcm9uLWxvY2F0aW9uXG4gICAgICAgIHBhdGg9XCJ7e19fcGF0aH19XCJcbiAgICAgICAgcXVlcnk9XCJ7e19fcXVlcnl9fVwiXG4gICAgICAgIGhhc2g9XCJ7e19faGFzaH19XCJcbiAgICAgICAgdXJsLXNwYWNlLXJlZ2V4PXt7dXJsU3BhY2VSZWdleH19PlxuICAgIDwvaXJvbi1sb2NhdGlvbj5cbiAgPC90ZW1wbGF0ZT5cbiAgPHNjcmlwdD5cbiAgICAoZnVuY3Rpb24oKSB7XG4gICAgICAndXNlIHN0cmljdCc7XG5cbiAgICAgIFBvbHltZXIoe1xuICAgICAgICBpczogJ2FwcC1sb2NhdGlvbicsXG5cbiAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIEEgbW9kZWwgcmVwcmVzZW50aW5nIHRoZSBkZXNlcmlhbGl6ZWQgcGF0aCB0aHJvdWdoIHRoZSByb3V0ZSB0cmVlLCBhc1xuICAgICAgICAgICAqIHdlbGwgYXMgdGhlIGN1cnJlbnQgcXVlcnlQYXJhbXMuXG4gICAgICAgICAgICovXG4gICAgICAgICAgcm91dGU6IHtcbiAgICAgICAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgICAgICAgIG5vdGlmeTogdHJ1ZVxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBJbiBtYW55IHNjZW5hcmlvcywgaXQgaXMgY29udmVuaWVudCB0byB0cmVhdCB0aGUgYGhhc2hgIGFzIGEgc3RhbmQtaW5cbiAgICAgICAgICAgKiBhbHRlcm5hdGl2ZSB0byB0aGUgYHBhdGhgLiBGb3IgZXhhbXBsZSwgaWYgZGVwbG95aW5nIGFuIGFwcCB0byBhIHN0YXRpY1xuICAgICAgICAgICAqIHdlYiBzZXJ2ZXIgKGUuZy4sIEdpdGh1YiBQYWdlcykgLSB3aGVyZSBvbmUgZG9lcyBub3QgaGF2ZSBjb250cm9sIG92ZXJcbiAgICAgICAgICAgKiBzZXJ2ZXItc2lkZSByb3V0aW5nIC0gaXQgaXMgdXN1YWxseSBhIGJldHRlciBleHBlcmllbmNlIHRvIHVzZSB0aGUgaGFzaFxuICAgICAgICAgICAqIHRvIHJlcHJlc2VudCBwYXRocyB0aHJvdWdoIG9uZSdzIGFwcC5cbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIFdoZW4gdGhpcyBwcm9wZXJ0eSBpcyBzZXQgdG8gdHJ1ZSwgdGhlIGBoYXNoYCB3aWxsIGJlIHVzZWQgaW4gcGxhY2Ugb2ZcblxuICAgICAgICAgICAqIHRoZSBgcGF0aGAgZm9yIGdlbmVyYXRpbmcgYSBgcm91dGVgLlxuICAgICAgICAgICAqL1xuICAgICAgICAgIHVzZUhhc2hBc1BhdGg6IHtcbiAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogQSByZWdleHAgdGhhdCBkZWZpbmVzIHRoZSBzZXQgb2YgVVJMcyB0aGF0IHNob3VsZCBiZSBjb25zaWRlcmVkIHBhcnRcbiAgICAgICAgICAgKiBvZiB0aGlzIHdlYiBhcHAuXG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiBDbGlja2luZyBvbiBhIGxpbmsgdGhhdCBtYXRjaGVzIHRoaXMgcmVnZXggd29uJ3QgcmVzdWx0IGluIGEgZnVsbCBwYWdlXG4gICAgICAgICAgICogbmF2aWdhdGlvbiwgYnV0IHdpbGwgaW5zdGVhZCBqdXN0IHVwZGF0ZSB0aGUgVVJMIHN0YXRlIGluIHBsYWNlLlxuICAgICAgICAgICAqXG4gICAgICAgICAgICogVGhpcyByZWdleHAgaXMgZ2l2ZW4gZXZlcnl0aGluZyBhZnRlciB0aGUgb3JpZ2luIGluIGFuIGFic29sdXRlXG4gICAgICAgICAgICogVVJMLiBTbyB0byBtYXRjaCBqdXN0IFVSTHMgdGhhdCBzdGFydCB3aXRoIC9zZWFyY2gvIGRvOlxuICAgICAgICAgICAqICAgICB1cmwtc3BhY2UtcmVnZXg9XCJeL3NlYXJjaC9cIlxuICAgICAgICAgICAqXG4gICAgICAgICAgICogQHR5cGUge3N0cmluZ3xSZWdFeHB9XG4gICAgICAgICAgICovXG4gICAgICAgICAgdXJsU3BhY2VSZWdleDoge1xuICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgICAgbm90aWZ5OiB0cnVlXG4gICAgICAgICAgfSxcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIEEgc2V0IG9mIGtleS92YWx1ZSBwYWlycyB0aGF0IGFyZSB1bml2ZXJzYWxseSBhY2Nlc3NpYmxlIHRvIGJyYW5jaGVzXG4gICAgICAgICAgICogb2YgdGhlIHJvdXRlIHRyZWUuXG4gICAgICAgICAgICovXG4gICAgICAgICAgX19xdWVyeVBhcmFtczoge1xuICAgICAgICAgICAgdHlwZTogT2JqZWN0XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFRoZSBwYXRobmFtZSBjb21wb25lbnQgb2YgdGhlIGN1cnJlbnQgVVJMLlxuICAgICAgICAgICAqL1xuICAgICAgICAgIF9fcGF0aDoge1xuICAgICAgICAgICAgdHlwZTogU3RyaW5nXG4gICAgICAgICAgfSxcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFRoZSBxdWVyeSBzdHJpbmcgcG9ydGlvbiBvZiB0aGUgY3VycmVudCBVUkwuXG4gICAgICAgICAgICovXG4gICAgICAgICAgX19xdWVyeToge1xuICAgICAgICAgICAgdHlwZTogU3RyaW5nXG4gICAgICAgICAgfSxcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFRoZSBoYXNoIHBvcnRpb24gb2YgdGhlIGN1cnJlbnQgVVJMLlxuICAgICAgICAgICAqL1xuICAgICAgICAgIF9faGFzaDoge1xuICAgICAgICAgICAgdHlwZTogU3RyaW5nXG4gICAgICAgICAgfSxcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFRoZSByb3V0ZSBwYXRoLCB3aGljaCB3aWxsIGJlIGVpdGhlciB0aGUgaGFzaCBvciB0aGUgcGF0aCwgZGVwZW5kaW5nXG4gICAgICAgICAgICogb24gdXNlSGFzaEFzUGF0aC5cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBwYXRoOiB7XG4gICAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgICBvYnNlcnZlcjogJ19fb25QYXRoQ2hhbmdlZCdcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogV2hldGhlciBvciBub3QgdGhlIHJlYWR5IGZ1bmN0aW9uIGhhcyBiZWVuIGNhbGxlZC5cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBfaXNSZWFkeToge1xuICAgICAgICAgICAgdHlwZTogQm9vbGVhblxuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBiZWhhdmlvcnM6IFtQb2x5bWVyLkFwcFJvdXRlQ29udmVydGVyQmVoYXZpb3JdLFxuXG4gICAgICAgIG9ic2VydmVyczogW1xuICAgICAgICAgICdfX2NvbXB1dGVSb3V0ZVBhdGgodXNlSGFzaEFzUGF0aCwgX19oYXNoLCBfX3BhdGgpJ1xuICAgICAgICBdLFxuXG4gICAgICAgIHJlYWR5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB0aGlzLl9pc1JlYWR5ID0gdHJ1ZTtcbiAgICAgICAgfSxcblxuICAgICAgICBfX2NvbXB1dGVSb3V0ZVBhdGg6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHRoaXMucGF0aCA9IHRoaXMudXNlSGFzaEFzUGF0aCA/IHRoaXMuX19oYXNoIDogdGhpcy5fX3BhdGg7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX19vblBhdGhDaGFuZ2VkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAoIXRoaXMuX2lzUmVhZHkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodGhpcy51c2VIYXNoQXNQYXRoKSB7XG4gICAgICAgICAgICB0aGlzLl9faGFzaCA9IHRoaXMucGF0aDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fX3BhdGggPSB0aGlzLnBhdGg7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KSgpO1xuICA8L3NjcmlwdD5cbjwvZG9tLW1vZHVsZT5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvYXBwLXJvdXRlL2FwcC1sb2NhdGlvbi5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNSBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuXG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vcG9seW1lci9wb2x5bWVyLmh0bWxcIj5cblxuPCEtLVxuXG5UaGUgYGlyb24tbG9jYXRpb25gIGVsZW1lbnQgbWFuYWdlcyBiaW5kaW5nIHRvIGFuZCBmcm9tIHRoZSBjdXJyZW50IFVSTC5cblxuaXJvbi1sb2NhdGlvbiBpcyB0aGUgZmlyc3QsIGFuZCBsb3dlc3QgbGV2ZWwgZWxlbWVudCBpbiB0aGUgUG9seW1lciB0ZWFtJ3NcbnJvdXRpbmcgc3lzdGVtLiBUaGlzIGlzIGEgYmV0YSByZWxlYXNlIG9mIGlyb24tbG9jYXRpb24gYXMgd2UgY29udGludWUgd29ya1xub24gaGlnaGVyIGxldmVsIGVsZW1lbnRzLCBhbmQgYXMgc3VjaCBpcm9uLWxvY2F0aW9uIG1heSB1bmRlcmdvIGJyZWFraW5nXG5jaGFuZ2VzLlxuXG4jIyMjIFByb3BlcnRpZXNcblxuV2hlbiB0aGUgVVJMIGlzOiBgL3NlYXJjaD9xdWVyeT01ODMjZGV0YWlsc2AgaXJvbi1sb2NhdGlvbidzIHByb3BlcnRpZXMgd2lsbCBiZTpcblxuICAtIHBhdGg6IGAnL3NlYXJjaCdgXG4gIC0gcXVlcnk6IGAncXVlcnk9NTgzJ2BcbiAgLSBoYXNoOiBgJ2RldGFpbHMnYFxuXG5UaGVzZSBiaW5kaW5ncyBhcmUgYmlkaXJlY3Rpb25hbC4gTW9kaWZ5aW5nIHRoZW0gd2lsbCBpbiB0dXJuIG1vZGlmeSB0aGUgVVJMLlxuXG5pcm9uLWxvY2F0aW9uIGlzIG9ubHkgYWN0aXZlIHdoaWxlIGl0IGlzIGF0dGFjaGVkIHRvIHRoZSBkb2N1bWVudC5cblxuIyMjIyBMaW5rc1xuXG5XaGlsZSBpcm9uLWxvY2F0aW9uIGlzIGFjdGl2ZSBpbiB0aGUgZG9jdW1lbnQgaXQgd2lsbCBpbnRlcmNlcHQgY2xpY2tzIG9uIGxpbmtzXG53aXRoaW4geW91ciBzaXRlLCB1cGRhdGluZyB0aGUgVVJMIHB1c2hpbmcgdGhlIHVwZGF0ZWQgVVJMIG91dCB0aHJvdWdoIHRoZVxuZGF0YWJpbmRpbmcgc3lzdGVtLiBpcm9uLWxvY2F0aW9uIG9ubHkgaW50ZXJjZXB0cyBjbGlja3Mgd2l0aCB0aGUgaW50ZW50IHRvXG5vcGVuIGluIHRoZSBzYW1lIHdpbmRvdywgc28gbWlkZGxlIG1vdXNlIGNsaWNrcyBhbmQgY3RybC9jbWQgY2xpY2tzIHdvcmsgZmluZS5cblxuWW91IGNhbiBjdXN0b21pemUgdGhpcyBiZWhhdmlvciB3aXRoIHRoZSBgdXJsU3BhY2VSZWdleGAuXG5cbiMjIyMgRHdlbGwgVGltZVxuXG5pcm9uLWxvY2F0aW9uIHByb3RlY3RzIGFnYWluc3QgYWNjaWRlbnRhbCBoaXN0b3J5IHNwYW1taW5nIGJ5IG9ubHkgYWRkaW5nXG5lbnRyaWVzIHRvIHRoZSB1c2VyJ3MgaGlzdG9yeSBpZiB0aGUgVVJMIHN0YXlzIHVuY2hhbmdlZCBmb3IgYGR3ZWxsVGltZWBcbm1pbGxpc2Vjb25kcy5cblxuQGRlbW8gZGVtby9pbmRleC5odG1sXG5cbiAtLT5cbjxzY3JpcHQ+XG4gIChmdW5jdGlvbigpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgd29ya2luZ1VSTDtcblxuICAgIHZhciB1cmxEb2MsIHVybEJhc2UsIGFuY2hvcjtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoXG4gICAgICogQHBhcmFtIHtzdHJpbmc9fSBiYXNlXG4gICAgICogQHJldHVybiB7IVVSTHwhSFRNTEFuY2hvckVsZW1lbnR9XG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVzb2x2ZVVSTChwYXRoLCBiYXNlKSB7XG4gICAgICBpZiAod29ya2luZ1VSTCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHdvcmtpbmdVUkwgPSBmYWxzZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgdSA9IG5ldyBVUkwoJ2InLCAnaHR0cDovL2EnKTtcbiAgICAgICAgICB1LnBhdGhuYW1lID0gJ2MlMjBkJztcbiAgICAgICAgICB3b3JraW5nVVJMID0gKHUuaHJlZiA9PT0gJ2h0dHA6Ly9hL2MlMjBkJyk7XG4gICAgICAgICAgd29ya2luZ1VSTCA9IHdvcmtpbmdVUkwgJiYgKG5ldyBVUkwoJ2h0dHA6Ly93d3cuZ29vZ2xlLmNvbS8/Zm9vIGJhcicpLmhyZWYgPT09ICdodHRwOi8vd3d3Lmdvb2dsZS5jb20vP2ZvbyUyMGJhcicpO1xuICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgfVxuICAgICAgaWYgKHdvcmtpbmdVUkwpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVUkwocGF0aCwgYmFzZSk7XG4gICAgICB9XG4gICAgICBpZiAoIXVybERvYykge1xuICAgICAgICB1cmxEb2MgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoJ3VybCcpO1xuICAgICAgICB1cmxCYXNlID0gdXJsRG9jLmNyZWF0ZUVsZW1lbnQoJ2Jhc2UnKTtcbiAgICAgICAgdXJsRG9jLmhlYWQuYXBwZW5kQ2hpbGQodXJsQmFzZSk7XG4gICAgICAgIGFuY2hvciA9IC8qKiBAdHlwZSB7SFRNTEFuY2hvckVsZW1lbnR9Ki8odXJsRG9jLmNyZWF0ZUVsZW1lbnQoJ2EnKSk7XG4gICAgICB9XG4gICAgICB1cmxCYXNlLmhyZWYgPSBiYXNlO1xuICAgICAgYW5jaG9yLmhyZWYgPSBwYXRoLnJlcGxhY2UoLyAvZywgJyUyMCcpO1xuICAgICAgcmV0dXJuIGFuY2hvcjtcbiAgICB9XG5cbiAgICBQb2x5bWVyKHtcbiAgICAgIGlzOiAnaXJvbi1sb2NhdGlvbicsXG5cbiAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBwYXRobmFtZSBjb21wb25lbnQgb2YgdGhlIFVSTC5cbiAgICAgICAgICovXG4gICAgICAgIHBhdGg6IHtcbiAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgbm90aWZ5OiB0cnVlLFxuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB3aW5kb3cuZGVjb2RlVVJJQ29tcG9uZW50KHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgcXVlcnkgc3RyaW5nIHBvcnRpb24gb2YgdGhlIFVSTC5cbiAgICAgICAgICovXG4gICAgICAgIHF1ZXJ5OiB7XG4gICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgIG5vdGlmeTogdHJ1ZSxcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gd2luZG93LmxvY2F0aW9uLnNlYXJjaC5zbGljZSgxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBoYXNoIGNvbXBvbmVudCBvZiB0aGUgVVJMLlxuICAgICAgICAgKi9cbiAgICAgICAgaGFzaDoge1xuICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICBub3RpZnk6IHRydWUsXG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5kZWNvZGVVUklDb21wb25lbnQod2luZG93LmxvY2F0aW9uLmhhc2guc2xpY2UoMSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgdGhlIHVzZXIgd2FzIG9uIGEgVVJMIGZvciBsZXNzIHRoYW4gYGR3ZWxsVGltZWAgbWlsbGlzZWNvbmRzLCBpdFxuICAgICAgICAgKiB3b24ndCBiZSBhZGRlZCB0byB0aGUgYnJvd3NlcidzIGhpc3RvcnksIGJ1dCBpbnN0ZWFkIHdpbGwgYmUgcmVwbGFjZWRcbiAgICAgICAgICogYnkgdGhlIG5leHQgZW50cnkuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgaXMgdG8gcHJldmVudCBsYXJnZSBudW1iZXJzIG9mIGVudHJpZXMgZnJvbSBjbG9nZ2luZyB1cCB0aGUgdXNlcidzXG4gICAgICAgICAqIGJyb3dzZXIgaGlzdG9yeS4gRGlzYWJsZSBieSBzZXR0aW5nIHRvIGEgbmVnYXRpdmUgbnVtYmVyLlxuICAgICAgICAgKi9cbiAgICAgICAgZHdlbGxUaW1lOiB7XG4gICAgICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgICAgIHZhbHVlOiAyMDAwXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgcmVnZXhwIHRoYXQgZGVmaW5lcyB0aGUgc2V0IG9mIFVSTHMgdGhhdCBzaG91bGQgYmUgY29uc2lkZXJlZCBwYXJ0XG4gICAgICAgICAqIG9mIHRoaXMgd2ViIGFwcC5cbiAgICAgICAgICpcbiAgICAgICAgICogQ2xpY2tpbmcgb24gYSBsaW5rIHRoYXQgbWF0Y2hlcyB0aGlzIHJlZ2V4IHdvbid0IHJlc3VsdCBpbiBhIGZ1bGwgcGFnZVxuICAgICAgICAgKiBuYXZpZ2F0aW9uLCBidXQgd2lsbCBpbnN0ZWFkIGp1c3QgdXBkYXRlIHRoZSBVUkwgc3RhdGUgaW4gcGxhY2UuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgcmVnZXhwIGlzIGdpdmVuIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIG9yaWdpbiBpbiBhbiBhYnNvbHV0ZVxuICAgICAgICAgKiBVUkwuIFNvIHRvIG1hdGNoIGp1c3QgVVJMcyB0aGF0IHN0YXJ0IHdpdGggL3NlYXJjaC8gZG86XG4gICAgICAgICAqICAgICB1cmwtc3BhY2UtcmVnZXg9XCJeL3NlYXJjaC9cIlxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfFJlZ0V4cH1cbiAgICAgICAgICovXG4gICAgICAgIHVybFNwYWNlUmVnZXg6IHtcbiAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgdmFsdWU6ICcnXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHVybFNwYWNlUmVnZXgsIGJ1dCBjb2VyY2VkIGludG8gYSByZWdleHAuXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtSZWdFeHB9XG4gICAgICAgICAqL1xuICAgICAgICBfdXJsU3BhY2VSZWdFeHA6IHtcbiAgICAgICAgICBjb21wdXRlZDogJ19tYWtlUmVnRXhwKHVybFNwYWNlUmVnZXgpJ1xuICAgICAgICB9LFxuXG4gICAgICAgIF9sYXN0Q2hhbmdlZEF0OiB7XG4gICAgICAgICAgdHlwZTogTnVtYmVyXG4gICAgICAgIH0sXG5cbiAgICAgICAgX2luaXRpYWxpemVkOiB7XG4gICAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgaG9zdEF0dHJpYnV0ZXM6IHtcbiAgICAgICAgaGlkZGVuOiB0cnVlXG4gICAgICB9LFxuXG4gICAgICBvYnNlcnZlcnM6IFtcbiAgICAgICAgJ191cGRhdGVVcmwocGF0aCwgcXVlcnksIGhhc2gpJ1xuICAgICAgXSxcblxuICAgICAgYXR0YWNoZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmxpc3Rlbih3aW5kb3csICdoYXNoY2hhbmdlJywgJ19oYXNoQ2hhbmdlZCcpO1xuICAgICAgICB0aGlzLmxpc3Rlbih3aW5kb3csICdsb2NhdGlvbi1jaGFuZ2VkJywgJ191cmxDaGFuZ2VkJyk7XG4gICAgICAgIHRoaXMubGlzdGVuKHdpbmRvdywgJ3BvcHN0YXRlJywgJ191cmxDaGFuZ2VkJyk7XG4gICAgICAgIHRoaXMubGlzdGVuKC8qKiBAdHlwZSB7IUhUTUxCb2R5RWxlbWVudH0gKi8oZG9jdW1lbnQuYm9keSksICdjbGljaycsICdfZ2xvYmFsT25DbGljaycpO1xuICAgICAgICAvLyBHaXZlIGEgMjAwbXMgZ3JhY2UgcGVyaW9kIHRvIG1ha2UgaW5pdGlhbCByZWRpcmVjdHMgd2l0aG91dCBhbnlcbiAgICAgICAgLy8gYWRkaXRpb25zIHRvIHRoZSB1c2VyJ3MgaGlzdG9yeS5cbiAgICAgICAgdGhpcy5fbGFzdENoYW5nZWRBdCA9IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKSAtICh0aGlzLmR3ZWxsVGltZSAtIDIwMCk7XG4gICAgICAgIHRoaXMuX2luaXRpYWxpemVkID0gdHJ1ZTtcblxuICAgICAgICB0aGlzLl91cmxDaGFuZ2VkKCk7XG4gICAgICB9LFxuXG4gICAgICBkZXRhY2hlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMudW5saXN0ZW4od2luZG93LCAnaGFzaGNoYW5nZScsICdfaGFzaENoYW5nZWQnKTtcbiAgICAgICAgdGhpcy51bmxpc3Rlbih3aW5kb3csICdsb2NhdGlvbi1jaGFuZ2VkJywgJ191cmxDaGFuZ2VkJyk7XG4gICAgICAgIHRoaXMudW5saXN0ZW4od2luZG93LCAncG9wc3RhdGUnLCAnX3VybENoYW5nZWQnKTtcbiAgICAgICAgdGhpcy51bmxpc3RlbigvKiogQHR5cGUgeyFIVE1MQm9keUVsZW1lbnR9ICovKGRvY3VtZW50LmJvZHkpLCAnY2xpY2snLCAnX2dsb2JhbE9uQ2xpY2snKTtcbiAgICAgICAgdGhpcy5faW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICAgIH0sXG5cbiAgICAgIF9oYXNoQ2hhbmdlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuaGFzaCA9IHdpbmRvdy5kZWNvZGVVUklDb21wb25lbnQod2luZG93LmxvY2F0aW9uLmhhc2guc3Vic3RyaW5nKDEpKTtcbiAgICAgIH0sXG5cbiAgICAgIF91cmxDaGFuZ2VkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gV2Ugd2FudCB0byBleHRyYWN0IGFsbCBpbmZvIG91dCBvZiB0aGUgdXBkYXRlZCBVUkwgYmVmb3JlIHdlXG4gICAgICAgIC8vIHRyeSB0byB3cml0ZSBhbnl0aGluZyBiYWNrIGludG8gaXQuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIGkuZS4gd2l0aG91dCBfZG9udFVwZGF0ZVVybCB3ZSdkIG92ZXJ3cml0ZSB0aGUgbmV3IHBhdGggd2l0aCB0aGUgb2xkXG4gICAgICAgIC8vIG9uZSB3aGVuIHdlIHNldCB0aGlzLmhhc2guIExpa2V3aXNlIGZvciBxdWVyeS5cbiAgICAgICAgdGhpcy5fZG9udFVwZGF0ZVVybCA9IHRydWU7XG4gICAgICAgIHRoaXMuX2hhc2hDaGFuZ2VkKCk7XG4gICAgICAgIHRoaXMucGF0aCA9IHdpbmRvdy5kZWNvZGVVUklDb21wb25lbnQod2luZG93LmxvY2F0aW9uLnBhdGhuYW1lKTtcbiAgICAgICAgdGhpcy5xdWVyeSA9IHdpbmRvdy5sb2NhdGlvbi5zZWFyY2guc3Vic3RyaW5nKDEpO1xuICAgICAgICB0aGlzLl9kb250VXBkYXRlVXJsID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVVybCgpO1xuICAgICAgfSxcblxuICAgICAgX2dldFVybDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwYXJ0aWFsbHlFbmNvZGVkUGF0aCA9IHdpbmRvdy5lbmNvZGVVUkkoXG4gICAgICAgICAgICB0aGlzLnBhdGgpLnJlcGxhY2UoL1xcIy9nLCAnJTIzJykucmVwbGFjZSgvXFw/L2csICclM0YnKTtcbiAgICAgICAgdmFyIHBhcnRpYWxseUVuY29kZWRRdWVyeSA9ICcnO1xuICAgICAgICBpZiAodGhpcy5xdWVyeSkge1xuICAgICAgICAgIHBhcnRpYWxseUVuY29kZWRRdWVyeSA9ICc/JyArIHRoaXMucXVlcnkucmVwbGFjZSgvXFwjL2csICclMjMnKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcGFydGlhbGx5RW5jb2RlZEhhc2ggPSAnJztcbiAgICAgICAgaWYgKHRoaXMuaGFzaCkge1xuICAgICAgICAgIHBhcnRpYWxseUVuY29kZWRIYXNoID0gJyMnICsgd2luZG93LmVuY29kZVVSSSh0aGlzLmhhc2gpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBwYXJ0aWFsbHlFbmNvZGVkUGF0aCArIHBhcnRpYWxseUVuY29kZWRRdWVyeSArIHBhcnRpYWxseUVuY29kZWRIYXNoKTtcbiAgICAgIH0sXG5cbiAgICAgIF91cGRhdGVVcmw6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fZG9udFVwZGF0ZVVybCB8fCAhdGhpcy5faW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5wYXRoID09PSB3aW5kb3cuZGVjb2RlVVJJQ29tcG9uZW50KHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSkgJiZcbiAgICAgICAgICAgIHRoaXMucXVlcnkgPT09IHdpbmRvdy5sb2NhdGlvbi5zZWFyY2guc3Vic3RyaW5nKDEpICYmXG4gICAgICAgICAgICB0aGlzLmhhc2ggPT09IHdpbmRvdy5kZWNvZGVVUklDb21wb25lbnQoXG4gICAgICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhhc2guc3Vic3RyaW5nKDEpKSkge1xuICAgICAgICAgIC8vIE5vdGhpbmcgdG8gZG8sIHRoZSBjdXJyZW50IFVSTCBpcyBhIHJlcHJlc2VudGF0aW9uIG9mIG91ciBwcm9wZXJ0aWVzLlxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBuZXdVcmwgPSB0aGlzLl9nZXRVcmwoKTtcbiAgICAgICAgLy8gTmVlZCB0byB1c2UgYSBmdWxsIFVSTCBpbiBjYXNlIHRoZSBjb250YWluaW5nIHBhZ2UgaGFzIGEgYmFzZSBVUkkuXG4gICAgICAgIHZhciBmdWxsTmV3VXJsID0gcmVzb2x2ZVVSTChuZXdVcmwsIHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCArICcvLycgKyB3aW5kb3cubG9jYXRpb24uaG9zdCkuaHJlZjtcbiAgICAgICAgdmFyIG5vdyA9IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgdmFyIHNob3VsZFJlcGxhY2UgPSB0aGlzLl9sYXN0Q2hhbmdlZEF0ICsgdGhpcy5kd2VsbFRpbWUgPiBub3c7XG4gICAgICAgIHRoaXMuX2xhc3RDaGFuZ2VkQXQgPSBub3c7XG5cbiAgICAgICAgaWYgKHNob3VsZFJlcGxhY2UpIHtcbiAgICAgICAgICB3aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGUoe30sICcnLCBmdWxsTmV3VXJsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUoe30sICcnLCBmdWxsTmV3VXJsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZmlyZSgnbG9jYXRpb24tY2hhbmdlZCcsIHt9LCB7bm9kZTogd2luZG93fSk7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIEEgbmVjZXNzYXJ5IGV2aWwgc28gdGhhdCBsaW5rcyB3b3JrIGFzIGV4cGVjdGVkLiBEb2VzIGl0cyBiZXN0IHRvXG4gICAgICAgKiBiYWlsIG91dCBlYXJseSBpZiBwb3NzaWJsZS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGV2ZW50IC5cbiAgICAgICAqL1xuICAgICAgX2dsb2JhbE9uQ2xpY2s6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIC8vIElmIGFub3RoZXIgZXZlbnQgaGFuZGxlciBoYXMgc3RvcHBlZCB0aGlzIGV2ZW50IHRoZW4gdGhlcmUncyBub3RoaW5nXG4gICAgICAgIC8vIGZvciB1cyB0byBkby4gVGhpcyBjYW4gaGFwcGVuIGUuZy4gd2hlbiB0aGVyZSBhcmUgbXVsdGlwbGVcbiAgICAgICAgLy8gaXJvbi1sb2NhdGlvbiBlbGVtZW50cyBpbiBhIHBhZ2UuXG4gICAgICAgIGlmIChldmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGhyZWYgPSB0aGlzLl9nZXRTYW1lT3JpZ2luTGlua0hyZWYoZXZlbnQpO1xuXG4gICAgICAgIGlmICghaHJlZikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgLy8gSWYgdGhlIG5hdmlnYXRpb24gaXMgdG8gdGhlIGN1cnJlbnQgcGFnZSB3ZSBzaG91bGRuJ3QgYWRkIGEgaGlzdG9yeVxuICAgICAgICAvLyBlbnRyeSBvciBmaXJlIGEgY2hhbmdlIGV2ZW50LlxuICAgICAgICBpZiAoaHJlZiA9PT0gd2luZG93LmxvY2F0aW9uLmhyZWYpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUoe30sICcnLCBocmVmKTtcbiAgICAgICAgdGhpcy5maXJlKCdsb2NhdGlvbi1jaGFuZ2VkJywge30sIHtub2RlOiB3aW5kb3d9KTtcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogUmV0dXJucyB0aGUgYWJzb2x1dGUgVVJMIG9mIHRoZSBsaW5rIChpZiBhbnkpIHRoYXQgdGhpcyBjbGljayBldmVudFxuICAgICAgICogaXMgY2xpY2tpbmcgb24sIGlmIHdlIGNhbiBhbmQgc2hvdWxkIG92ZXJyaWRlIHRoZSByZXN1bHRpbmcgZnVsbFxuICAgICAgICogcGFnZSBuYXZpZ2F0aW9uLiBSZXR1cm5zIG51bGwgb3RoZXJ3aXNlLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZXZlbnQgLlxuICAgICAgICogQHJldHVybiB7c3RyaW5nP30gLlxuICAgICAgICovXG4gICAgICBfZ2V0U2FtZU9yaWdpbkxpbmtIcmVmOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAvLyBXZSBvbmx5IGNhcmUgYWJvdXQgbGVmdC1jbGlja3MuXG4gICAgICAgIGlmIChldmVudC5idXR0b24gIT09IDApIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdlIGRvbid0IHdhbnQgbW9kaWZpZWQgY2xpY2tzLCB3aGVyZSB0aGUgaW50ZW50IGlzIHRvIG9wZW4gdGhlIHBhZ2VcbiAgICAgICAgLy8gaW4gYSBuZXcgdGFiLlxuICAgICAgICBpZiAoZXZlbnQubWV0YUtleSB8fCBldmVudC5jdHJsS2V5KSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZXZlbnRQYXRoID0gUG9seW1lci5kb20oZXZlbnQpLnBhdGg7XG4gICAgICAgIHZhciBhbmNob3IgPSBudWxsO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXZlbnRQYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGVsZW1lbnQgPSBldmVudFBhdGhbaV07XG5cbiAgICAgICAgICBpZiAoZWxlbWVudC50YWdOYW1lID09PSAnQScgJiYgZWxlbWVudC5ocmVmKSB7XG4gICAgICAgICAgICBhbmNob3IgPSBlbGVtZW50O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgdGhlcmUncyBubyBsaW5rIHRoZXJlJ3Mgbm90aGluZyB0byBkby5cbiAgICAgICAgaWYgKCFhbmNob3IpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRhcmdldCBibGFuayBpcyBhIG5ldyB0YWIsIGRvbid0IGludGVyY2VwdC5cbiAgICAgICAgaWYgKGFuY2hvci50YXJnZXQgPT09ICdfYmxhbmsnKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGUgbGluayBpcyBmb3IgYW4gZXhpc3RpbmcgcGFyZW50IGZyYW1lLCBkb24ndCBpbnRlcmNlcHQuXG4gICAgICAgIGlmICgoYW5jaG9yLnRhcmdldCA9PT0gJ190b3AnIHx8XG4gICAgICAgICAgICBhbmNob3IudGFyZ2V0ID09PSAnX3BhcmVudCcpICYmXG4gICAgICAgICAgICB3aW5kb3cudG9wICE9PSB3aW5kb3cpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBocmVmID0gYW5jaG9yLmhyZWY7XG5cbiAgICAgICAgLy8gSXQgb25seSBtYWtlcyBzZW5zZSBmb3IgdXMgdG8gaW50ZXJjZXB0IHNhbWUtb3JpZ2luIG5hdmlnYXRpb25zLlxuICAgICAgICAvLyBwdXNoU3RhdGUvcmVwbGFjZVN0YXRlIGRvbid0IHdvcmsgd2l0aCBjcm9zcy1vcmlnaW4gbGlua3MuXG4gICAgICAgIHZhciB1cmw7XG5cbiAgICAgICAgaWYgKGRvY3VtZW50LmJhc2VVUkkgIT0gbnVsbCkge1xuICAgICAgICAgIHVybCA9IHJlc29sdmVVUkwoaHJlZiwgLyoqIEB0eXBlIHtzdHJpbmd9ICovKGRvY3VtZW50LmJhc2VVUkkpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB1cmwgPSByZXNvbHZlVVJMKGhyZWYpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG9yaWdpbjtcblxuICAgICAgICAvLyBJRSBQb2x5ZmlsbFxuICAgICAgICBpZiAod2luZG93LmxvY2F0aW9uLm9yaWdpbikge1xuICAgICAgICAgIG9yaWdpbiA9IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3JpZ2luID0gd2luZG93LmxvY2F0aW9uLnByb3RvY29sICsgJy8vJyArIHdpbmRvdy5sb2NhdGlvbi5ob3N0O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHVybE9yaWdpbjtcblxuICAgICAgICBpZiAodXJsLm9yaWdpbikge1xuICAgICAgICAgIHVybE9yaWdpbiA9IHVybC5vcmlnaW47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdXJsT3JpZ2luID0gdXJsLnByb3RvY29sICsgJy8vJyArIHVybC5ob3N0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHVybE9yaWdpbiAhPT0gb3JpZ2luKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbm9ybWFsaXplZEhyZWYgPSB1cmwucGF0aG5hbWUgKyB1cmwuc2VhcmNoICsgdXJsLmhhc2g7XG5cbiAgICAgICAgLy8gcGF0aG5hbWUgc2hvdWxkIHN0YXJ0IHdpdGggJy8nLCBidXQgbWF5IG5vdCBpZiBgbmV3IFVSTGAgaXMgbm90IHN1cHBvcnRlZFxuICAgICAgICBpZiAobm9ybWFsaXplZEhyZWZbMF0gIT09ICcvJykge1xuICAgICAgICAgIG5vcm1hbGl6ZWRIcmVmID0gJy8nICsgbm9ybWFsaXplZEhyZWY7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB3ZSd2ZSBiZWVuIGNvbmZpZ3VyZWQgbm90IHRvIGhhbmRsZSB0aGlzIHVybC4uLiBkb24ndCBoYW5kbGUgaXQhXG4gICAgICAgIGlmICh0aGlzLl91cmxTcGFjZVJlZ0V4cCAmJlxuICAgICAgICAgICAgIXRoaXMuX3VybFNwYWNlUmVnRXhwLnRlc3Qobm9ybWFsaXplZEhyZWYpKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBOZWVkIHRvIHVzZSBhIGZ1bGwgVVJMIGluIGNhc2UgdGhlIGNvbnRhaW5pbmcgcGFnZSBoYXMgYSBiYXNlIFVSSS5cbiAgICAgICAgdmFyIGZ1bGxOb3JtYWxpemVkSHJlZiA9IHJlc29sdmVVUkwoXG4gICAgICAgICAgICBub3JtYWxpemVkSHJlZiwgd2luZG93LmxvY2F0aW9uLmhyZWYpLmhyZWY7XG4gICAgICAgIHJldHVybiBmdWxsTm9ybWFsaXplZEhyZWY7XG4gICAgICB9LFxuXG4gICAgICBfbWFrZVJlZ0V4cDogZnVuY3Rpb24odXJsU3BhY2VSZWdleCkge1xuICAgICAgICByZXR1cm4gUmVnRXhwKHVybFNwYWNlUmVnZXgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KSgpO1xuPC9zY3JpcHQ+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL2lyb24tbG9jYXRpb24vaXJvbi1sb2NhdGlvbi5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNSBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcblxuQGRlbW8gZGVtby9pcm9uLXF1ZXJ5LXBhcmFtcy5odG1sXG4tLT5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi9wb2x5bWVyL3BvbHltZXIuaHRtbFwiPlxuXG48c2NyaXB0PlxuICAndXNlIHN0cmljdCc7XG5cbiAgUG9seW1lcih7XG4gICAgaXM6ICdpcm9uLXF1ZXJ5LXBhcmFtcycsXG5cbiAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICBwYXJhbXNTdHJpbmc6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICBub3RpZnk6IHRydWUsXG4gICAgICAgIG9ic2VydmVyOiAncGFyYW1zU3RyaW5nQ2hhbmdlZCcsXG4gICAgICB9LFxuXG4gICAgICBwYXJhbXNPYmplY3Q6IHtcbiAgICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgICBub3RpZnk6IHRydWUsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIF9kb250UmVhY3Q6IHtcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICB9XG4gICAgfSxcblxuICAgIGhvc3RBdHRyaWJ1dGVzOiB7XG4gICAgICBoaWRkZW46IHRydWVcbiAgICB9LFxuXG4gICAgb2JzZXJ2ZXJzOiBbXG4gICAgICAncGFyYW1zT2JqZWN0Q2hhbmdlZChwYXJhbXNPYmplY3QuKiknXG4gICAgXSxcblxuICAgIHBhcmFtc1N0cmluZ0NoYW5nZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fZG9udFJlYWN0ID0gdHJ1ZTtcbiAgICAgIHRoaXMucGFyYW1zT2JqZWN0ID0gdGhpcy5fZGVjb2RlUGFyYW1zKHRoaXMucGFyYW1zU3RyaW5nKTtcbiAgICAgIHRoaXMuX2RvbnRSZWFjdCA9IGZhbHNlO1xuICAgIH0sXG5cbiAgICBwYXJhbXNPYmplY3RDaGFuZ2VkOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLl9kb250UmVhY3QpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5wYXJhbXNTdHJpbmcgPSB0aGlzLl9lbmNvZGVQYXJhbXModGhpcy5wYXJhbXNPYmplY3QpXG4gICAgICAgICAgLnJlcGxhY2UoLyUzRi9nLCAnPycpLnJlcGxhY2UoLyUyRi9nLCAnLycpLnJlcGxhY2UoLycvZywgJyUyNycpO1xuICAgIH0sXG5cbiAgICBfZW5jb2RlUGFyYW1zOiBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgIHZhciBlbmNvZGVkUGFyYW1zID0gW107XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gcGFyYW1zW2tleV07XG5cbiAgICAgICAgaWYgKHZhbHVlID09PSAnJykge1xuICAgICAgICAgIGVuY29kZWRQYXJhbXMucHVzaChlbmNvZGVVUklDb21wb25lbnQoa2V5KSk7XG5cbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSkge1xuICAgICAgICAgIGVuY29kZWRQYXJhbXMucHVzaChcbiAgICAgICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KGtleSkgK1xuICAgICAgICAgICAgICAnPScgK1xuICAgICAgICAgICAgICBlbmNvZGVVUklDb21wb25lbnQodmFsdWUudG9TdHJpbmcoKSlcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZW5jb2RlZFBhcmFtcy5qb2luKCcmJyk7XG4gICAgfSxcblxuICAgIF9kZWNvZGVQYXJhbXM6IGZ1bmN0aW9uKHBhcmFtU3RyaW5nKSB7XG4gICAgICB2YXIgcGFyYW1zID0ge307XG4gICAgICAvLyBXb3JrIGFyb3VuZCBhIGJ1ZyBpbiBkZWNvZGVVUklDb21wb25lbnQgd2hlcmUgKyBpcyBub3RcbiAgICAgIC8vIGNvbnZlcnRlZCB0byBzcGFjZXM6XG4gICAgICBwYXJhbVN0cmluZyA9IChwYXJhbVN0cmluZyB8fCAnJykucmVwbGFjZSgvXFwrL2csICclMjAnKTtcbiAgICAgIHZhciBwYXJhbUxpc3QgPSBwYXJhbVN0cmluZy5zcGxpdCgnJicpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJhbUxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHBhcmFtID0gcGFyYW1MaXN0W2ldLnNwbGl0KCc9Jyk7XG4gICAgICAgIGlmIChwYXJhbVswXSkge1xuICAgICAgICAgIHBhcmFtc1tkZWNvZGVVUklDb21wb25lbnQocGFyYW1bMF0pXSA9XG4gICAgICAgICAgICAgIGRlY29kZVVSSUNvbXBvbmVudChwYXJhbVsxXSB8fCAnJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfVxuICB9KTtcbjwvc2NyaXB0PlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9pcm9uLWxvY2F0aW9uL2lyb24tcXVlcnktcGFyYW1zLmh0bWwiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG48c2NyaXB0PlxuICAoZnVuY3Rpb24oKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgLyoqXG4gICAgICogUHJvdmlkZXMgYmlkaXJlY3Rpb25hbCBtYXBwaW5nIGJldHdlZW4gYHBhdGhgIGFuZCBgcXVlcnlQYXJhbXNgIGFuZCBhXG4gICAgICogYXBwLXJvdXRlIGNvbXBhdGlibGUgYHJvdXRlYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgc2VlIHRoZSBkb2NzIGZvciBgYXBwLXJvdXRlLWNvbnZlcnRlcmAuXG4gICAgICpcbiAgICAgKiBAcG9seW1lckJlaGF2aW9yXG4gICAgICovXG4gICAgUG9seW1lci5BcHBSb3V0ZUNvbnZlcnRlckJlaGF2aW9yID0ge1xuICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBtb2RlbCByZXByZXNlbnRpbmcgdGhlIGRlc2VyaWFsaXplZCBwYXRoIHRocm91Z2ggdGhlIHJvdXRlIHRyZWUsIGFzXG4gICAgICAgICAqIHdlbGwgYXMgdGhlIGN1cnJlbnQgcXVlcnlQYXJhbXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEEgcm91dGUgb2JqZWN0IGlzIHRoZSBrZXJuZWwgb2YgdGhlIHJvdXRpbmcgc3lzdGVtLiBJdCBpcyBpbnRlbmRlZCB0b1xuICAgICAgICAgKiBiZSBmZWQgaW50byBjb25zdW1pbmcgZWxlbWVudHMgc3VjaCBhcyBgYXBwLXJvdXRlYC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUgez9PYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICByb3V0ZToge1xuICAgICAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgICAgICBub3RpZnk6IHRydWVcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQSBzZXQgb2Yga2V5L3ZhbHVlIHBhaXJzIHRoYXQgYXJlIHVuaXZlcnNhbGx5IGFjY2Vzc2libGUgdG8gYnJhbmNoZXMgb2ZcbiAgICAgICAgICogdGhlIHJvdXRlIHRyZWUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHs/T2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgcXVlcnlQYXJhbXM6IHtcbiAgICAgICAgICB0eXBlOiBPYmplY3QsXG4gICAgICAgICAgbm90aWZ5OiB0cnVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBzZXJpYWxpemVkIHBhdGggdGhyb3VnaCB0aGUgcm91dGUgdHJlZS4gVGhpcyBjb3JyZXNwb25kcyB0byB0aGVcbiAgICAgICAgICogYHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZWAgdmFsdWUsIGFuZCB3aWxsIHVwZGF0ZSB0byByZWZsZWN0IGNoYW5nZXNcbiAgICAgICAgICogdG8gdGhhdCB2YWx1ZS5cbiAgICAgICAgICovXG4gICAgICAgIHBhdGg6IHtcbiAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgbm90aWZ5OiB0cnVlLFxuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBvYnNlcnZlcnM6IFtcbiAgICAgICAgJ19sb2NhdGlvbkNoYW5nZWQocGF0aCwgcXVlcnlQYXJhbXMpJyxcbiAgICAgICAgJ19yb3V0ZUNoYW5nZWQocm91dGUucHJlZml4LCByb3V0ZS5wYXRoKScsXG4gICAgICAgICdfcm91dGVRdWVyeVBhcmFtc0NoYW5nZWQocm91dGUuX19xdWVyeVBhcmFtcyknXG4gICAgICBdLFxuXG4gICAgICBjcmVhdGVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5saW5rUGF0aHMoJ3JvdXRlLl9fcXVlcnlQYXJhbXMnLCAncXVlcnlQYXJhbXMnKTtcbiAgICAgICAgdGhpcy5saW5rUGF0aHMoJ3F1ZXJ5UGFyYW1zJywgJ3JvdXRlLl9fcXVlcnlQYXJhbXMnKTtcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogSGFuZGxlciBjYWxsZWQgd2hlbiB0aGUgcGF0aCBvciBxdWVyeVBhcmFtcyBjaGFuZ2UuXG4gICAgICAgKi9cbiAgICAgIF9sb2NhdGlvbkNoYW5nZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5yb3V0ZSAmJlxuICAgICAgICAgICAgdGhpcy5yb3V0ZS5wYXRoID09PSB0aGlzLnBhdGggJiZcbiAgICAgICAgICAgIHRoaXMucXVlcnlQYXJhbXMgPT09IHRoaXMucm91dGUuX19xdWVyeVBhcmFtcykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJvdXRlID0ge1xuICAgICAgICAgIHByZWZpeDogJycsXG4gICAgICAgICAgcGF0aDogdGhpcy5wYXRoLFxuICAgICAgICAgIF9fcXVlcnlQYXJhbXM6IHRoaXMucXVlcnlQYXJhbXNcbiAgICAgICAgfTtcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogSGFuZGxlciBjYWxsZWQgd2hlbiB0aGUgcm91dGUgcHJlZml4IGFuZCByb3V0ZSBwYXRoIGNoYW5nZS5cbiAgICAgICAqL1xuICAgICAgX3JvdXRlQ2hhbmdlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5yb3V0ZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucGF0aCA9IHRoaXMucm91dGUucHJlZml4ICsgdGhpcy5yb3V0ZS5wYXRoO1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBIYW5kbGVyIGNhbGxlZCB3aGVuIHRoZSByb3V0ZSBxdWVyeVBhcmFtcyBjaGFuZ2UuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtICB7T2JqZWN0fSBxdWVyeVBhcmFtcyBBIHNldCBvZiBrZXkvdmFsdWUgcGFpcnMgdGhhdCBhcmVcbiAgICAgICAqIHVuaXZlcnNhbGx5IGFjY2Vzc2libGUgdG8gYnJhbmNoZXMgb2YgdGhlIHJvdXRlIHRyZWUuXG4gICAgICAgKi9cbiAgICAgIF9yb3V0ZVF1ZXJ5UGFyYW1zQ2hhbmdlZDogZnVuY3Rpb24ocXVlcnlQYXJhbXMpIHtcbiAgICAgICAgaWYgKCF0aGlzLnJvdXRlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucXVlcnlQYXJhbXMgPSBxdWVyeVBhcmFtcztcbiAgICAgIH1cbiAgICB9O1xuICB9KSgpO1xuPC9zY3JpcHQ+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL2FwcC1yb3V0ZS9hcHAtcm91dGUtY29udmVydGVyLWJlaGF2aW9yLmh0bWwiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi9wb2x5bWVyL3BvbHltZXIuaHRtbFwiPlxuXG48IS0tXG5gYXBwLXJvdXRlYCBpcyBhbiBlbGVtZW50IHRoYXQgZW5hYmxlcyBkZWNsYXJhdGl2ZSwgc2VsZi1kZXNjcmliaW5nIHJvdXRpbmdcbmZvciBhIHdlYiBhcHAuXG5cbj4gKm4uYi4gYXBwLXJvdXRlIGlzIHN0aWxsIGluIGJldGEuIFdlIGV4cGVjdCBpdCB3aWxsIG5lZWQgc29tZSBjaGFuZ2VzLiBXZSdyZSBjb3VudGluZyBvbiB5b3VyIGZlZWRiYWNrISpcblxuSW4gaXRzIHR5cGljYWwgdXNhZ2UsIGEgYGFwcC1yb3V0ZWAgZWxlbWVudCBjb25zdW1lcyBhbiBvYmplY3QgdGhhdCBkZXNjcmliZXNcbnNvbWUgc3RhdGUgYWJvdXQgdGhlIGN1cnJlbnQgcm91dGUsIHZpYSB0aGUgYHJvdXRlYCBwcm9wZXJ0eS4gSXQgdGhlbiBwYXJzZXNcbnRoYXQgc3RhdGUgdXNpbmcgdGhlIGBwYXR0ZXJuYCBwcm9wZXJ0eSwgYW5kIHByb2R1Y2VzIHR3byBhcnRpZmFjdHM6IHNvbWUgYGRhdGFgXG5yZWxhdGVkIHRvIHRoZSBgcm91dGVgLCBhbmQgYSBgdGFpbGAgdGhhdCBjb250YWlucyB0aGUgcmVzdCBvZiB0aGUgYHJvdXRlYCB0aGF0XG5kaWQgbm90IG1hdGNoLlxuXG5IZXJlIGlzIGEgYmFzaWMgZXhhbXBsZSwgd2hlbiB1c2VkIHdpdGggYGFwcC1sb2NhdGlvbmA6XG5cbiAgICA8YXBwLWxvY2F0aW9uIHJvdXRlPVwie3tyb3V0ZX19XCI+PC9hcHAtbG9jYXRpb24+XG4gICAgPGFwcC1yb3V0ZVxuICAgICAgICByb3V0ZT1cInt7cm91dGV9fVwiXG4gICAgICAgIHBhdHRlcm49XCIvOnBhZ2VcIlxuICAgICAgICBkYXRhPVwie3tkYXRhfX1cIlxuICAgICAgICB0YWlsPVwie3t0YWlsfX1cIj5cbiAgICA8L2FwcC1yb3V0ZT5cblxuSW4gdGhlIGFib3ZlIGV4YW1wbGUsIHRoZSBgYXBwLWxvY2F0aW9uYCBwcm9kdWNlcyBhIGByb3V0ZWAgdmFsdWUuIFRoZW4sIHRoZVxuYHJvdXRlLnBhdGhgIHByb3BlcnR5IGlzIG1hdGNoZWQgYnkgY29tcGFyaW5nIGl0IHRvIHRoZSBgcGF0dGVybmAgcHJvcGVydHkuIElmXG50aGUgYHBhdHRlcm5gIHByb3BlcnR5IG1hdGNoZXMgYHJvdXRlLnBhdGhgLCB0aGUgYGFwcC1yb3V0ZWAgd2lsbCBzZXQgb3IgdXBkYXRlXG5pdHMgYGRhdGFgIHByb3BlcnR5IHdpdGggYW4gb2JqZWN0IHdob3NlIHByb3BlcnRpZXMgY29ycmVzcG9uZCB0byB0aGUgcGFyYW1ldGVyc1xuaW4gYHBhdHRlcm5gLiBTbywgaW4gdGhlIGFib3ZlIGV4YW1wbGUsIGlmIGByb3V0ZS5wYXRoYCB3YXMgYCcvYWJvdXQnYCwgdGhlIHZhbHVlXG5vZiBgZGF0YWAgd291bGQgYmUgYHtcInBhZ2VcIjogXCJhYm91dFwifWAuXG5cblRoZSBgdGFpbGAgcHJvcGVydHkgcmVwcmVzZW50cyB0aGUgcmVtYWluaW5nIHBhcnQgb2YgdGhlIHJvdXRlIHN0YXRlIGFmdGVyIHRoZVxuYHBhdHRlcm5gIGhhcyBiZWVuIGFwcGxpZWQgdG8gYSBtYXRjaGluZyBgcm91dGVgLlxuXG5IZXJlIGlzIGFub3RoZXIgZXhhbXBsZSwgd2hlcmUgYHRhaWxgIGlzIHVzZWQ6XG5cbiAgICA8YXBwLWxvY2F0aW9uIHJvdXRlPVwie3tyb3V0ZX19XCI+PC9hcHAtbG9jYXRpb24+XG4gICAgPGFwcC1yb3V0ZVxuICAgICAgICByb3V0ZT1cInt7cm91dGV9fVwiXG4gICAgICAgIHBhdHRlcm49XCIvOnBhZ2VcIlxuICAgICAgICBkYXRhPVwie3tyb3V0ZURhdGF9fVwiXG4gICAgICAgIHRhaWw9XCJ7e3N1YnJvdXRlfX1cIj5cbiAgICA8L2FwcC1yb3V0ZT5cbiAgICA8YXBwLXJvdXRlXG4gICAgICAgIHJvdXRlPVwie3tzdWJyb3V0ZX19XCJcbiAgICAgICAgcGF0dGVybj1cIi86aWRcIlxuICAgICAgICBkYXRhPVwie3tzdWJyb3V0ZURhdGF9fVwiPlxuICAgIDwvYXBwLXJvdXRlPlxuXG5JbiB0aGUgYWJvdmUgZXhhbXBsZSwgdGhlcmUgYXJlIHR3byBgYXBwLXJvdXRlYCBlbGVtZW50cy4gVGhlIGZpcnN0XG5gYXBwLXJvdXRlYCBjb25zdW1lcyBhIGByb3V0ZWAuIFdoZW4gdGhlIGByb3V0ZWAgaXMgbWF0Y2hlZCwgdGhlIGZpcnN0XG5gYXBwLXJvdXRlYCBhbHNvIHByb2R1Y2VzIGByb3V0ZURhdGFgIGZyb20gaXRzIGBkYXRhYCwgYW5kIGBzdWJyb3V0ZWAgZnJvbVxuaXRzIGB0YWlsYC4gVGhlIHNlY29uZCBgYXBwLXJvdXRlYCBjb25zdW1lcyB0aGUgYHN1YnJvdXRlYCwgYW5kIHdoZW4gaXRcbm1hdGNoZXMsIGl0IHByb2R1Y2VzIGFuIG9iamVjdCBjYWxsZWQgYHN1YnJvdXRlRGF0YWAgZnJvbSBpdHMgYGRhdGFgLlxuXG5Tbywgd2hlbiBgcm91dGUucGF0aGAgaXMgYCcvYWJvdXQnYCwgdGhlIGByb3V0ZURhdGFgIG9iamVjdCB3aWxsIGxvb2sgbGlrZVxudGhpczogYHsgcGFnZTogJ2Fib3V0JyB9YFxuXG5BbmQgYHN1YnJvdXRlRGF0YWAgd2lsbCBiZSBudWxsLiBIb3dldmVyLCBpZiBgcm91dGUucGF0aGAgY2hhbmdlcyB0b1xuYCcvYXJ0aWNsZS8xMjMnYCwgdGhlIGByb3V0ZURhdGFgIG9iamVjdCB3aWxsIGxvb2sgbGlrZSB0aGlzOlxuYHsgcGFnZTogJ2FydGljbGUnIH1gXG5cbkFuZCB0aGUgYHN1YnJvdXRlRGF0YWAgd2lsbCBsb29rIGxpa2UgdGhpczogYHsgaWQ6ICcxMjMnIH1gXG5cbmBhcHAtcm91dGVgIGlzIHJlc3BvbnNpdmUgdG8gYmktZGlyZWN0aW9uYWwgY2hhbmdlcyB0byB0aGUgYGRhdGFgIG9iamVjdHNcbnRoZXkgcHJvZHVjZS4gU28sIGlmIGByb3V0ZURhdGEucGFnZWAgY2hhbmdlZCBmcm9tIGAnYXJ0aWNsZSdgIHRvIGAnYWJvdXQnYCxcbnRoZSBgYXBwLXJvdXRlYCB3aWxsIHVwZGF0ZSBgcm91dGUucGF0aGAuIFRoaXMgaW4tdHVybiB3aWxsIHVwZGF0ZSB0aGVcbmBhcHAtbG9jYXRpb25gLCBhbmQgY2F1c2UgdGhlIGdsb2JhbCBsb2NhdGlvbiBiYXIgdG8gY2hhbmdlIGl0cyB2YWx1ZS5cblxuQGVsZW1lbnQgYXBwLXJvdXRlXG5AZGVtbyBkZW1vL2luZGV4Lmh0bWxcbkBkZW1vIGRlbW8vZGF0YS1sb2FkaW5nLWRlbW8uaHRtbFxuQGRlbW8gZGVtby9zaW1wbGUtZGVtby5odG1sXG4tLT5cblxuPHNjcmlwdD5cbiAgKGZ1bmN0aW9uKCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIFBvbHltZXIoe1xuICAgICAgaXM6ICdhcHAtcm91dGUnLFxuXG4gICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgVVJMIGNvbXBvbmVudCBtYW5hZ2VkIGJ5IHRoaXMgZWxlbWVudC5cbiAgICAgICAgICovXG4gICAgICAgIHJvdXRlOiB7XG4gICAgICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgICAgIG5vdGlmeTogdHJ1ZVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgcGF0dGVybiBvZiBzbGFzaC1zZXBhcmF0ZWQgc2VnbWVudHMgdG8gbWF0Y2ggYHJvdXRlLnBhdGhgIGFnYWluc3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBleGFtcGxlIHRoZSBwYXR0ZXJuIFwiL2Zvb1wiIHdpbGwgbWF0Y2ggXCIvZm9vXCIgb3IgXCIvZm9vL2JhclwiXG4gICAgICAgICAqIGJ1dCBub3QgXCIvZm9vYmFyXCIuXG4gICAgICAgICAqXG4gICAgICAgICAqIFBhdGggc2VnbWVudHMgbGlrZSBgLzpuYW1lZGAgYXJlIG1hcHBlZCB0byBwcm9wZXJ0aWVzIG9uIHRoZSBgZGF0YWAgb2JqZWN0LlxuICAgICAgICAgKi9cbiAgICAgICAgcGF0dGVybjoge1xuICAgICAgICAgIHR5cGU6IFN0cmluZ1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgcGFyYW1ldGVyaXplZCB2YWx1ZXMgdGhhdCBhcmUgZXh0cmFjdGVkIGZyb20gdGhlIHJvdXRlIGFzXG4gICAgICAgICAqIGRlc2NyaWJlZCBieSBgcGF0dGVybmAuXG4gICAgICAgICAqL1xuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHtyZXR1cm4ge307fSxcbiAgICAgICAgICBub3RpZnk6IHRydWVcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUgez9PYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICBxdWVyeVBhcmFtczoge1xuICAgICAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgICAgfSxcbiAgICAgICAgICBub3RpZnk6IHRydWVcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHBhcnQgb2YgYHJvdXRlLnBhdGhgIE5PVCBjb25zdW1lZCBieSBgcGF0dGVybmAuXG4gICAgICAgICAqL1xuICAgICAgICB0YWlsOiB7XG4gICAgICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHtyZXR1cm4ge3BhdGg6IG51bGwsIHByZWZpeDogbnVsbCwgX19xdWVyeVBhcmFtczogbnVsbH07fSxcbiAgICAgICAgICBub3RpZnk6IHRydWVcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGUgY3VycmVudCByb3V0ZSBpcyBhY3RpdmUuIFRydWUgaWYgYHJvdXRlLnBhdGhgIG1hdGNoZXMgdGhlXG4gICAgICAgICAqIGBwYXR0ZXJuYCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAgICAgKi9cbiAgICAgICAgYWN0aXZlOiB7XG4gICAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgICBub3RpZnk6IHRydWUsXG4gICAgICAgICAgcmVhZE9ubHk6IHRydWVcbiAgICAgICAgfSxcblxuICAgICAgICBfcXVlcnlQYXJhbXNVcGRhdGluZzoge1xuICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7P3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIF9tYXRjaGVkOiB7XG4gICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgIHZhbHVlOiAnJ1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBvYnNlcnZlcnM6IFtcbiAgICAgICAgJ19fdHJ5VG9NYXRjaChyb3V0ZS5wYXRoLCBwYXR0ZXJuKScsXG4gICAgICAgICdfX3VwZGF0ZVBhdGhPbkRhdGFDaGFuZ2UoZGF0YS4qKScsXG4gICAgICAgICdfX3RhaWxQYXRoQ2hhbmdlZCh0YWlsLnBhdGgpJyxcbiAgICAgICAgJ19fcm91dGVRdWVyeVBhcmFtc0NoYW5nZWQocm91dGUuX19xdWVyeVBhcmFtcyknLFxuICAgICAgICAnX190YWlsUXVlcnlQYXJhbXNDaGFuZ2VkKHRhaWwuX19xdWVyeVBhcmFtcyknLFxuICAgICAgICAnX19xdWVyeVBhcmFtc0NoYW5nZWQocXVlcnlQYXJhbXMuKiknXG4gICAgICBdLFxuXG4gICAgICBjcmVhdGVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5saW5rUGF0aHMoJ3JvdXRlLl9fcXVlcnlQYXJhbXMnLCAndGFpbC5fX3F1ZXJ5UGFyYW1zJyk7XG4gICAgICAgIHRoaXMubGlua1BhdGhzKCd0YWlsLl9fcXVlcnlQYXJhbXMnLCAncm91dGUuX19xdWVyeVBhcmFtcycpO1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBEZWFsIHdpdGggdGhlIHF1ZXJ5IHBhcmFtcyBvYmplY3QgYmVpbmcgYXNzaWduZWQgdG8gd2hvbGVzYWxlLlxuICAgICAgICovXG4gICAgICBfX3JvdXRlUXVlcnlQYXJhbXNDaGFuZ2VkOiBmdW5jdGlvbihxdWVyeVBhcmFtcykge1xuICAgICAgICBpZiAocXVlcnlQYXJhbXMgJiYgdGhpcy50YWlsKSB7XG4gICAgICAgICAgaWYgKHRoaXMudGFpbC5fX3F1ZXJ5UGFyYW1zICE9PSBxdWVyeVBhcmFtcykge1xuICAgICAgICAgICAgdGhpcy5zZXQoJ3RhaWwuX19xdWVyeVBhcmFtcycsIHF1ZXJ5UGFyYW1zKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIXRoaXMuYWN0aXZlIHx8IHRoaXMuX3F1ZXJ5UGFyYW1zVXBkYXRpbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBDb3B5IHF1ZXJ5UGFyYW1zIGFuZCB0cmFjayB3aGV0aGVyIHRoZXJlIGFyZSBhbnkgZGlmZmVyZW5jZXMgY29tcGFyZWRcbiAgICAgICAgICAvLyB0byB0aGUgZXhpc3RpbmcgcXVlcnkgcGFyYW1zLlxuICAgICAgICAgIHZhciBjb3B5T2ZRdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICAgIHZhciBhbnl0aGluZ0NoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gcXVlcnlQYXJhbXMpIHtcbiAgICAgICAgICAgIGNvcHlPZlF1ZXJ5UGFyYW1zW2tleV0gPSBxdWVyeVBhcmFtc1trZXldO1xuICAgICAgICAgICAgaWYgKGFueXRoaW5nQ2hhbmdlZCB8fFxuICAgICAgICAgICAgICAgICF0aGlzLnF1ZXJ5UGFyYW1zIHx8XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXNba2V5XSAhPT0gdGhpcy5xdWVyeVBhcmFtc1trZXldKSB7XG4gICAgICAgICAgICAgIGFueXRoaW5nQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIE5lZWQgdG8gY2hlY2sgd2hldGhlciBhbnkga2V5cyB3ZXJlIGRlbGV0ZWRcbiAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5xdWVyeVBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFueXRoaW5nQ2hhbmdlZCB8fCAhKGtleSBpbiBxdWVyeVBhcmFtcykpIHtcbiAgICAgICAgICAgICAgYW55dGhpbmdDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFhbnl0aGluZ0NoYW5nZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fcXVlcnlQYXJhbXNVcGRhdGluZyA9IHRydWU7XG4gICAgICAgICAgdGhpcy5zZXQoJ3F1ZXJ5UGFyYW1zJywgY29weU9mUXVlcnlQYXJhbXMpO1xuICAgICAgICAgIHRoaXMuX3F1ZXJ5UGFyYW1zVXBkYXRpbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgX190YWlsUXVlcnlQYXJhbXNDaGFuZ2VkOiBmdW5jdGlvbihxdWVyeVBhcmFtcykge1xuICAgICAgICBpZiAocXVlcnlQYXJhbXMgJiYgdGhpcy5yb3V0ZSAmJiB0aGlzLnJvdXRlLl9fcXVlcnlQYXJhbXMgIT0gcXVlcnlQYXJhbXMpIHtcbiAgICAgICAgICB0aGlzLnNldCgncm91dGUuX19xdWVyeVBhcmFtcycsIHF1ZXJ5UGFyYW1zKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgX19xdWVyeVBhcmFtc0NoYW5nZWQ6IGZ1bmN0aW9uKGNoYW5nZXMpIHtcbiAgICAgICAgaWYgKCF0aGlzLmFjdGl2ZSB8fCB0aGlzLl9xdWVyeVBhcmFtc1VwZGF0aW5nKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zZXQoJ3JvdXRlLl9fJyArIGNoYW5nZXMucGF0aCwgY2hhbmdlcy52YWx1ZSk7XG4gICAgICB9LFxuXG4gICAgICBfX3Jlc2V0UHJvcGVydGllczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX3NldEFjdGl2ZShmYWxzZSk7XG4gICAgICAgIHRoaXMuX21hdGNoZWQgPSBudWxsO1xuICAgICAgfSxcblxuICAgICAgX190cnlUb01hdGNoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLnJvdXRlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBhdGggPSB0aGlzLnJvdXRlLnBhdGg7XG4gICAgICAgIHZhciBwYXR0ZXJuID0gdGhpcy5wYXR0ZXJuO1xuXG4gICAgICAgIGlmICghcGF0dGVybikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcGF0aCkge1xuICAgICAgICAgIHRoaXMuX19yZXNldFByb3BlcnRpZXMoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVtYWluaW5nUGllY2VzID0gcGF0aC5zcGxpdCgnLycpO1xuICAgICAgICB2YXIgcGF0dGVyblBpZWNlcyA9IHBhdHRlcm4uc3BsaXQoJy8nKTtcblxuICAgICAgICB2YXIgbWF0Y2hlZCA9IFtdO1xuICAgICAgICB2YXIgbmFtZWRNYXRjaGVzID0ge307XG5cbiAgICAgICAgZm9yICh2YXIgaT0wOyBpIDwgcGF0dGVyblBpZWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBwYXR0ZXJuUGllY2UgPSBwYXR0ZXJuUGllY2VzW2ldO1xuICAgICAgICAgIGlmICghcGF0dGVyblBpZWNlICYmIHBhdHRlcm5QaWVjZSAhPT0gJycpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgcGF0aFBpZWNlID0gcmVtYWluaW5nUGllY2VzLnNoaWZ0KCk7XG5cbiAgICAgICAgICAvLyBXZSBkb24ndCBtYXRjaCB0aGlzIHBhdGguXG4gICAgICAgICAgaWYgKCFwYXRoUGllY2UgJiYgcGF0aFBpZWNlICE9PSAnJykge1xuICAgICAgICAgICAgdGhpcy5fX3Jlc2V0UHJvcGVydGllcygpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtYXRjaGVkLnB1c2gocGF0aFBpZWNlKTtcblxuICAgICAgICAgIGlmIChwYXR0ZXJuUGllY2UuY2hhckF0KDApID09ICc6Jykge1xuICAgICAgICAgICAgbmFtZWRNYXRjaGVzW3BhdHRlcm5QaWVjZS5zbGljZSgxKV0gPSBwYXRoUGllY2U7XG4gICAgICAgICAgfSBlbHNlIGlmIChwYXR0ZXJuUGllY2UgIT09IHBhdGhQaWVjZSkge1xuICAgICAgICAgICAgdGhpcy5fX3Jlc2V0UHJvcGVydGllcygpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX21hdGNoZWQgPSBtYXRjaGVkLmpvaW4oJy8nKTtcblxuICAgICAgICAvLyBQcm9wZXJ0aWVzIHRoYXQgbXVzdCBiZSB1cGRhdGVkIGF0b21pY2FsbHkuXG4gICAgICAgIHZhciBwcm9wZXJ0eVVwZGF0ZXMgPSB7fTtcblxuICAgICAgICAvL3RoaXMuYWN0aXZlXG4gICAgICAgIGlmICghdGhpcy5hY3RpdmUpIHtcbiAgICAgICAgICBwcm9wZXJ0eVVwZGF0ZXMuYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRoaXMudGFpbFxuICAgICAgICB2YXIgdGFpbFByZWZpeCA9IHRoaXMucm91dGUucHJlZml4ICsgdGhpcy5fbWF0Y2hlZDtcbiAgICAgICAgdmFyIHRhaWxQYXRoID0gcmVtYWluaW5nUGllY2VzLmpvaW4oJy8nKTtcbiAgICAgICAgaWYgKHJlbWFpbmluZ1BpZWNlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdGFpbFBhdGggPSAnLycgKyB0YWlsUGF0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMudGFpbCB8fFxuICAgICAgICAgICAgdGhpcy50YWlsLnByZWZpeCAhPT0gdGFpbFByZWZpeCB8fFxuICAgICAgICAgICAgdGhpcy50YWlsLnBhdGggIT09IHRhaWxQYXRoKSB7XG4gICAgICAgICAgcHJvcGVydHlVcGRhdGVzLnRhaWwgPSB7XG4gICAgICAgICAgICBwcmVmaXg6IHRhaWxQcmVmaXgsXG4gICAgICAgICAgICBwYXRoOiB0YWlsUGF0aCxcbiAgICAgICAgICAgIF9fcXVlcnlQYXJhbXM6IHRoaXMucm91dGUuX19xdWVyeVBhcmFtc1xuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0aGlzLmRhdGFcbiAgICAgICAgcHJvcGVydHlVcGRhdGVzLmRhdGEgPSBuYW1lZE1hdGNoZXM7XG4gICAgICAgIHRoaXMuX2RhdGFJblVybCA9IHt9O1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gbmFtZWRNYXRjaGVzKSB7XG4gICAgICAgICAgdGhpcy5fZGF0YUluVXJsW2tleV0gPSBuYW1lZE1hdGNoZXNba2V5XTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnNldFByb3BlcnRpZXMpIHtcbiAgICAgICAgICBpZiAoIXRoaXMuYWN0aXZlKSB7XG4gICAgICAgICAgICB0aGlzLl9zZXRBY3RpdmUodHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGF0b21pYyB1cGRhdGVcbiAgICAgICAgICB0aGlzLnNldFByb3BlcnRpZXMocHJvcGVydHlVcGRhdGVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9fc2V0TXVsdGkocHJvcGVydHlVcGRhdGVzKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgX190YWlsUGF0aENoYW5nZWQ6IGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmFjdGl2ZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdGFpbFBhdGggPSBwYXRoO1xuICAgICAgICB2YXIgbmV3UGF0aCA9IHRoaXMuX21hdGNoZWQ7XG4gICAgICAgIGlmICh0YWlsUGF0aCkge1xuICAgICAgICAgIGlmICh0YWlsUGF0aC5jaGFyQXQoMCkgIT09ICcvJykge1xuICAgICAgICAgICAgdGFpbFBhdGggPSAnLycgKyB0YWlsUGF0aDtcbiAgICAgICAgICB9XG4gICAgICAgICAgbmV3UGF0aCArPSB0YWlsUGF0aDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldCgncm91dGUucGF0aCcsIG5ld1BhdGgpO1xuICAgICAgfSxcblxuICAgICAgX191cGRhdGVQYXRoT25EYXRhQ2hhbmdlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLnJvdXRlIHx8ICF0aGlzLmFjdGl2ZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmV3UGF0aCA9IHRoaXMuX19nZXRMaW5rKHt9KTtcbiAgICAgICAgdmFyIG9sZFBhdGggPSB0aGlzLl9fZ2V0TGluayh0aGlzLl9kYXRhSW5VcmwpO1xuICAgICAgICBpZiAobmV3UGF0aCA9PT0gb2xkUGF0aCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldCgncm91dGUucGF0aCcsIG5ld1BhdGgpO1xuICAgICAgfSxcblxuICAgICAgX19nZXRMaW5rOiBmdW5jdGlvbihvdmVycmlkZVZhbHVlcykge1xuICAgICAgICB2YXIgdmFsdWVzID0ge3RhaWw6IG51bGx9O1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5kYXRhKSB7XG4gICAgICAgICAgdmFsdWVzW2tleV0gPSB0aGlzLmRhdGFba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gb3ZlcnJpZGVWYWx1ZXMpIHtcbiAgICAgICAgICB2YWx1ZXNba2V5XSA9IG92ZXJyaWRlVmFsdWVzW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBhdHRlcm5QaWVjZXMgPSB0aGlzLnBhdHRlcm4uc3BsaXQoJy8nKTtcbiAgICAgICAgdmFyIGludGVycCA9IHBhdHRlcm5QaWVjZXMubWFwKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgaWYgKHZhbHVlWzBdID09ICc6Jykge1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZXNbdmFsdWUuc2xpY2UoMSldO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgICBpZiAodmFsdWVzLnRhaWwgJiYgdmFsdWVzLnRhaWwucGF0aCkge1xuICAgICAgICAgIGlmIChpbnRlcnAubGVuZ3RoID4gMCAmJiB2YWx1ZXMudGFpbC5wYXRoLmNoYXJBdCgwKSA9PT0gJy8nKSB7XG4gICAgICAgICAgICBpbnRlcnAucHVzaCh2YWx1ZXMudGFpbC5wYXRoLnNsaWNlKDEpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW50ZXJwLnB1c2godmFsdWVzLnRhaWwucGF0aCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnRlcnAuam9pbignLycpO1xuICAgICAgfSxcblxuICAgICAgX19zZXRNdWx0aTogZnVuY3Rpb24oc2V0T2JqKSB7XG4gICAgICAgIC8vIEhBQ0socmljdGljKTogc2tpcnRpbmcgYXJvdW5kIDEuMCdzIGxhY2sgb2YgYSBzZXRNdWx0aSBieSBwb2tpbmcgYXRcbiAgICAgICAgLy8gICAgIGludGVybmFsIGRhdGEgc3RydWN0dXJlcy4gSSB3b3VsZCBub3QgYWR2aXNlIHRoYXQgeW91IGNvcHkgdGhpc1xuICAgICAgICAvLyAgICAgZXhhbXBsZS5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gICAgIEluIHRoZSBmdXR1cmUgdGhpcyB3aWxsIGJlIGEgZmVhdHVyZSBvZiBQb2x5bWVyIGl0c2VsZi5cbiAgICAgICAgLy8gICAgIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL1BvbHltZXIvcG9seW1lci9pc3N1ZXMvMzY0MFxuICAgICAgICAvL1xuICAgICAgICAvLyAgICAgSGFja2luZyBhcm91bmQgd2l0aCBwcml2YXRlIG1ldGhvZHMgbGlrZSB0aGlzIGlzIGp1Z2dsaW5nIGZvb3RndW5zLFxuICAgICAgICAvLyAgICAgYW5kIGlzIGxpa2VseSB0byBoYXZlIHVuZXhwZWN0ZWQgYW5kIHVuc3VwcG9ydGVkIHJvdWdoIGVkZ2VzLlxuICAgICAgICAvL1xuICAgICAgICAvLyAgICAgQmUgeWUgc28gd2FybmVkLlxuICAgICAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiBzZXRPYmopIHtcbiAgICAgICAgICB0aGlzLl9wcm9wZXJ0eVNldHRlcihwcm9wZXJ0eSwgc2V0T2JqW3Byb3BlcnR5XSk7XG4gICAgICAgIH1cbiAgICAgICAgLy9ub3RpZnkgaW4gYSBzcGVjaWZpYyBvcmRlclxuICAgICAgICBpZiAoc2V0T2JqLmRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMuX3BhdGhFZmZlY3RvcignZGF0YScsIHRoaXMuZGF0YSk7XG4gICAgICAgICAgdGhpcy5fbm90aWZ5Q2hhbmdlKCdkYXRhJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNldE9iai5hY3RpdmUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMuX3BhdGhFZmZlY3RvcignYWN0aXZlJywgdGhpcy5hY3RpdmUpO1xuICAgICAgICAgIHRoaXMuX25vdGlmeUNoYW5nZSgnYWN0aXZlJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNldE9iai50YWlsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLl9wYXRoRWZmZWN0b3IoJ3RhaWwnLCB0aGlzLnRhaWwpO1xuICAgICAgICAgIHRoaXMuX25vdGlmeUNoYW5nZSgndGFpbCcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH0pKCk7XG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvYXBwLXJvdXRlL2FwcC1yb3V0ZS5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNSBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuXG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vcG9seW1lci9wb2x5bWVyLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi9pcm9uLXJlc2l6YWJsZS1iZWhhdmlvci9pcm9uLXJlc2l6YWJsZS1iZWhhdmlvci5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vaXJvbi1zZWxlY3Rvci9pcm9uLXNlbGVjdGFibGUuaHRtbFwiPlxuXG48IS0tXG5gaXJvbi1wYWdlc2AgaXMgdXNlZCB0byBzZWxlY3Qgb25lIG9mIGl0cyBjaGlsZHJlbiB0byBzaG93LiBPbmUgdXNlIGlzIHRvIGN5Y2xlIHRocm91Z2ggYSBsaXN0IG9mXG5jaGlsZHJlbiBcInBhZ2VzXCIuXG5cbkV4YW1wbGU6XG5cbiAgICA8aXJvbi1wYWdlcyBzZWxlY3RlZD1cIjBcIj5cbiAgICAgIDxkaXY+T25lPC9kaXY+XG4gICAgICA8ZGl2PlR3bzwvZGl2PlxuICAgICAgPGRpdj5UaHJlZTwvZGl2PlxuICAgIDwvaXJvbi1wYWdlcz5cblxuICAgIDxzY3JpcHQ+XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdmFyIHBhZ2VzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignaXJvbi1wYWdlcycpO1xuICAgICAgICBwYWdlcy5zZWxlY3ROZXh0KCk7XG4gICAgICB9KTtcbiAgICA8L3NjcmlwdD5cblxuQGdyb3VwIElyb24gRWxlbWVudHNcbkBoZXJvIGhlcm8uc3ZnXG5AZGVtbyBkZW1vL2luZGV4Lmh0bWxcbi0tPlxuXG48ZG9tLW1vZHVsZSBpZD1cImlyb24tcGFnZXNcIj5cblxuICA8dGVtcGxhdGU+XG4gICAgPHN0eWxlPlxuICAgICAgOmhvc3Qge1xuICAgICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgIH1cblxuICAgICAgOmhvc3QgPiA6OnNsb3R0ZWQoOm5vdCguaXJvbi1zZWxlY3RlZCkpIHtcbiAgICAgICAgZGlzcGxheTogbm9uZSAhaW1wb3J0YW50O1xuICAgICAgfVxuICAgIDwvc3R5bGU+XG5cbiAgICA8c2xvdD48L3Nsb3Q+XG4gIDwvdGVtcGxhdGU+XG5cbiAgPHNjcmlwdD5cbiAgICBQb2x5bWVyKHtcblxuICAgICAgaXM6ICdpcm9uLXBhZ2VzJyxcblxuICAgICAgYmVoYXZpb3JzOiBbXG4gICAgICAgIFBvbHltZXIuSXJvblJlc2l6YWJsZUJlaGF2aW9yLFxuICAgICAgICBQb2x5bWVyLklyb25TZWxlY3RhYmxlQmVoYXZpb3JcbiAgICAgIF0sXG5cbiAgICAgIHByb3BlcnRpZXM6IHtcblxuICAgICAgICAvLyBhcyB0aGUgc2VsZWN0ZWQgcGFnZSBpcyB0aGUgb25seSBvbmUgdmlzaWJsZSwgYWN0aXZhdGVFdmVudFxuICAgICAgICAvLyBpcyBib3RoIG5vbi1zZW5zaWNhbCBhbmQgcHJvYmxlbWF0aWM7IGUuZy4gaW4gY2FzZXMgd2hlcmUgYSB1c2VyXG4gICAgICAgIC8vIGhhbmRsZXIgYXR0ZW1wdHMgdG8gY2hhbmdlIHRoZSBwYWdlIGFuZCB0aGUgYWN0aXZhdGVFdmVudFxuICAgICAgICAvLyBoYW5kbGVyIGltbWVkaWF0ZWx5IGNoYW5nZXMgaXQgYmFja1xuICAgICAgICBhY3RpdmF0ZUV2ZW50OiB7XG4gICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgIHZhbHVlOiBudWxsXG4gICAgICAgIH1cblxuICAgICAgfSxcblxuICAgICAgb2JzZXJ2ZXJzOiBbXG4gICAgICAgICdfc2VsZWN0ZWRQYWdlQ2hhbmdlZChzZWxlY3RlZCknXG4gICAgICBdLFxuXG4gICAgICBfc2VsZWN0ZWRQYWdlQ2hhbmdlZDogZnVuY3Rpb24oc2VsZWN0ZWQsIG9sZCkge1xuICAgICAgICB0aGlzLmFzeW5jKHRoaXMubm90aWZ5UmVzaXplKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICA8L3NjcmlwdD5cbjwvZG9tLW1vZHVsZT5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvaXJvbi1wYWdlcy9pcm9uLXBhZ2VzLmh0bWwiLCJcbjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTUgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cblxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3BvbHltZXIvcG9seW1lci5odG1sXCI+XG5cbjxzY3JpcHQ+XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IUZ1bmN0aW9ufSBzZWxlY3RDYWxsYmFja1xuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG4gIFBvbHltZXIuSXJvblNlbGVjdGlvbiA9IGZ1bmN0aW9uKHNlbGVjdENhbGxiYWNrKSB7XG4gICAgdGhpcy5zZWxlY3Rpb24gPSBbXTtcbiAgICB0aGlzLnNlbGVjdENhbGxiYWNrID0gc2VsZWN0Q2FsbGJhY2s7XG4gIH07XG5cbiAgUG9seW1lci5Jcm9uU2VsZWN0aW9uLnByb3RvdHlwZSA9IHtcblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgc2VsZWN0ZWQgaXRlbShzKS5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgZ2V0XG4gICAgICogQHJldHVybnMgUmV0dXJucyB0aGUgc2VsZWN0ZWQgaXRlbShzKS4gSWYgdGhlIG11bHRpIHByb3BlcnR5IGlzIHRydWUsXG4gICAgICogYGdldGAgd2lsbCByZXR1cm4gYW4gYXJyYXksIG90aGVyd2lzZSBpdCB3aWxsIHJldHVyblxuICAgICAqIHRoZSBzZWxlY3RlZCBpdGVtIG9yIHVuZGVmaW5lZCBpZiB0aGVyZSBpcyBubyBzZWxlY3Rpb24uXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLm11bHRpID8gdGhpcy5zZWxlY3Rpb24uc2xpY2UoKSA6IHRoaXMuc2VsZWN0aW9uWzBdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgYWxsIHRoZSBzZWxlY3Rpb24gZXhjZXB0IHRoZSBvbmVzIGluZGljYXRlZC5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgY2xlYXJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBleGNsdWRlcyBpdGVtcyB0byBiZSBleGNsdWRlZC5cbiAgICAgKi9cbiAgICBjbGVhcjogZnVuY3Rpb24oZXhjbHVkZXMpIHtcbiAgICAgIHRoaXMuc2VsZWN0aW9uLnNsaWNlKCkuZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgIGlmICghZXhjbHVkZXMgfHwgZXhjbHVkZXMuaW5kZXhPZihpdGVtKSA8IDApIHtcbiAgICAgICAgICB0aGlzLnNldEl0ZW1TZWxlY3RlZChpdGVtLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH0sIHRoaXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgaWYgYSBnaXZlbiBpdGVtIGlzIHNlbGVjdGVkLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBpc1NlbGVjdGVkXG4gICAgICogQHBhcmFtIHsqfSBpdGVtIFRoZSBpdGVtIHdob3NlIHNlbGVjdGlvbiBzdGF0ZSBzaG91bGQgYmUgY2hlY2tlZC5cbiAgICAgKiBAcmV0dXJucyBSZXR1cm5zIHRydWUgaWYgYGl0ZW1gIGlzIHNlbGVjdGVkLlxuICAgICAqL1xuICAgIGlzU2VsZWN0ZWQ6IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgIHJldHVybiB0aGlzLnNlbGVjdGlvbi5pbmRleE9mKGl0ZW0pID49IDA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHNlbGVjdGlvbiBzdGF0ZSBmb3IgYSBnaXZlbiBpdGVtIHRvIGVpdGhlciBzZWxlY3RlZCBvciBkZXNlbGVjdGVkLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBzZXRJdGVtU2VsZWN0ZWRcbiAgICAgKiBAcGFyYW0geyp9IGl0ZW0gVGhlIGl0ZW0gdG8gc2VsZWN0LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNTZWxlY3RlZCBUcnVlIGZvciBzZWxlY3RlZCwgZmFsc2UgZm9yIGRlc2VsZWN0ZWQuXG4gICAgICovXG4gICAgc2V0SXRlbVNlbGVjdGVkOiBmdW5jdGlvbihpdGVtLCBpc1NlbGVjdGVkKSB7XG4gICAgICBpZiAoaXRlbSAhPSBudWxsKSB7XG4gICAgICAgIGlmIChpc1NlbGVjdGVkICE9PSB0aGlzLmlzU2VsZWN0ZWQoaXRlbSkpIHtcbiAgICAgICAgICAvLyBwcm9jZWVkIHRvIHVwZGF0ZSBzZWxlY3Rpb24gb25seSBpZiByZXF1ZXN0ZWQgc3RhdGUgZGlmZmVycyBmcm9tIGN1cnJlbnRcbiAgICAgICAgICBpZiAoaXNTZWxlY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24ucHVzaChpdGVtKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGkgPSB0aGlzLnNlbGVjdGlvbi5pbmRleE9mKGl0ZW0pO1xuICAgICAgICAgICAgaWYgKGkgPj0gMCkge1xuICAgICAgICAgICAgICB0aGlzLnNlbGVjdGlvbi5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLnNlbGVjdENhbGxiYWNrKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdENhbGxiYWNrKGl0ZW0sIGlzU2VsZWN0ZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBzZWxlY3Rpb24gc3RhdGUgZm9yIGEgZ2l2ZW4gaXRlbS4gSWYgdGhlIGBtdWx0aWAgcHJvcGVydHlcbiAgICAgKiBpcyB0cnVlLCB0aGVuIHRoZSBzZWxlY3RlZCBzdGF0ZSBvZiBgaXRlbWAgd2lsbCBiZSB0b2dnbGVkOyBvdGhlcndpc2VcbiAgICAgKiB0aGUgYGl0ZW1gIHdpbGwgYmUgc2VsZWN0ZWQuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHNlbGVjdFxuICAgICAqIEBwYXJhbSB7Kn0gaXRlbSBUaGUgaXRlbSB0byBzZWxlY3QuXG4gICAgICovXG4gICAgc2VsZWN0OiBmdW5jdGlvbihpdGVtKSB7XG4gICAgICBpZiAodGhpcy5tdWx0aSkge1xuICAgICAgICB0aGlzLnRvZ2dsZShpdGVtKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5nZXQoKSAhPT0gaXRlbSkge1xuICAgICAgICB0aGlzLnNldEl0ZW1TZWxlY3RlZCh0aGlzLmdldCgpLCBmYWxzZSk7XG4gICAgICAgIHRoaXMuc2V0SXRlbVNlbGVjdGVkKGl0ZW0sIHRydWUpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUb2dnbGVzIHRoZSBzZWxlY3Rpb24gc3RhdGUgZm9yIGBpdGVtYC5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgdG9nZ2xlXG4gICAgICogQHBhcmFtIHsqfSBpdGVtIFRoZSBpdGVtIHRvIHRvZ2dsZS5cbiAgICAgKi9cbiAgICB0b2dnbGU6IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgIHRoaXMuc2V0SXRlbVNlbGVjdGVkKGl0ZW0sICF0aGlzLmlzU2VsZWN0ZWQoaXRlbSkpO1xuICAgIH1cblxuICB9O1xuXG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvaXJvbi1zZWxlY3Rvci9pcm9uLXNlbGVjdGlvbi5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNSBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuXG5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi9wb2x5bWVyL3BvbHltZXIuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cImlyb24tbXVsdGktc2VsZWN0YWJsZS5odG1sXCI+XG5cbjxzY3JpcHQ+XG4gIC8qKlxuICBgaXJvbi1zZWxlY3RvcmAgaXMgYW4gZWxlbWVudCB3aGljaCBjYW4gYmUgdXNlZCB0byBtYW5hZ2UgYSBsaXN0IG9mIGVsZW1lbnRzXG4gIHRoYXQgY2FuIGJlIHNlbGVjdGVkLiAgVGFwcGluZyBvbiB0aGUgaXRlbSB3aWxsIG1ha2UgdGhlIGl0ZW0gc2VsZWN0ZWQuICBUaGUgYHNlbGVjdGVkYCBpbmRpY2F0ZXNcbiAgd2hpY2ggaXRlbSBpcyBiZWluZyBzZWxlY3RlZC4gIFRoZSBkZWZhdWx0IGlzIHRvIHVzZSB0aGUgaW5kZXggb2YgdGhlIGl0ZW0uXG5cbiAgRXhhbXBsZTpcblxuICAgICAgPGlyb24tc2VsZWN0b3Igc2VsZWN0ZWQ9XCIwXCI+XG4gICAgICAgIDxkaXY+SXRlbSAxPC9kaXY+XG4gICAgICAgIDxkaXY+SXRlbSAyPC9kaXY+XG4gICAgICAgIDxkaXY+SXRlbSAzPC9kaXY+XG4gICAgICA8L2lyb24tc2VsZWN0b3I+XG5cbiAgSWYgeW91IHdhbnQgdG8gdXNlIHRoZSBhdHRyaWJ1dGUgdmFsdWUgb2YgYW4gZWxlbWVudCBmb3IgYHNlbGVjdGVkYCBpbnN0ZWFkIG9mIHRoZSBpbmRleCxcbiAgc2V0IGBhdHRyRm9yU2VsZWN0ZWRgIHRvIHRoZSBuYW1lIG9mIHRoZSBhdHRyaWJ1dGUuICBGb3IgZXhhbXBsZSwgaWYgeW91IHdhbnQgdG8gc2VsZWN0IGl0ZW0gYnlcbiAgYG5hbWVgLCBzZXQgYGF0dHJGb3JTZWxlY3RlZGAgdG8gYG5hbWVgLlxuXG4gIEV4YW1wbGU6XG5cbiAgICAgIDxpcm9uLXNlbGVjdG9yIGF0dHItZm9yLXNlbGVjdGVkPVwibmFtZVwiIHNlbGVjdGVkPVwiZm9vXCI+XG4gICAgICAgIDxkaXYgbmFtZT1cImZvb1wiPkZvbzwvZGl2PlxuICAgICAgICA8ZGl2IG5hbWU9XCJiYXJcIj5CYXI8L2Rpdj5cbiAgICAgICAgPGRpdiBuYW1lPVwiem90XCI+Wm90PC9kaXY+XG4gICAgICA8L2lyb24tc2VsZWN0b3I+XG5cbiAgWW91IGNhbiBzcGVjaWZ5IGEgZGVmYXVsdCBmYWxsYmFjayB3aXRoIGBmYWxsYmFja1NlbGVjdGlvbmAgaW4gY2FzZSB0aGUgYHNlbGVjdGVkYCBhdHRyaWJ1dGUgZG9lc1xuICBub3QgbWF0Y2ggdGhlIGBhdHRyRm9yU2VsZWN0ZWRgIGF0dHJpYnV0ZSBvZiBhbnkgZWxlbWVudHMuXG5cbiAgRXhhbXBsZTpcblxuICAgICAgICA8aXJvbi1zZWxlY3RvciBhdHRyLWZvci1zZWxlY3RlZD1cIm5hbWVcIiBzZWxlY3RlZD1cIm5vbi1leGlzdGluZ1wiXG4gICAgICAgICAgICAgICAgICAgICAgIGZhbGxiYWNrLXNlbGVjdGlvbj1cImRlZmF1bHRcIj5cbiAgICAgICAgICA8ZGl2IG5hbWU9XCJmb29cIj5Gb288L2Rpdj5cbiAgICAgICAgICA8ZGl2IG5hbWU9XCJiYXJcIj5CYXI8L2Rpdj5cbiAgICAgICAgICA8ZGl2IG5hbWU9XCJkZWZhdWx0XCI+RGVmYXVsdDwvZGl2PlxuICAgICAgICA8L2lyb24tc2VsZWN0b3I+XG5cbiAgTm90ZTogV2hlbiB0aGUgc2VsZWN0b3IgaXMgbXVsdGksIHRoZSBzZWxlY3Rpb24gd2lsbCBzZXQgdG8gYGZhbGxiYWNrU2VsZWN0aW9uYCBpZmZcbiAgdGhlIG51bWJlciBvZiBtYXRjaGluZyBlbGVtZW50cyBpcyB6ZXJvLlxuXG4gIGBpcm9uLXNlbGVjdG9yYCBpcyBub3Qgc3R5bGVkLiBVc2UgdGhlIGBpcm9uLXNlbGVjdGVkYCBDU1MgY2xhc3MgdG8gc3R5bGUgdGhlIHNlbGVjdGVkIGVsZW1lbnQuXG5cbiAgRXhhbXBsZTpcblxuICAgICAgPHN0eWxlPlxuICAgICAgICAuaXJvbi1zZWxlY3RlZCB7XG4gICAgICAgICAgYmFja2dyb3VuZDogI2VlZTtcbiAgICAgICAgfVxuICAgICAgPC9zdHlsZT5cblxuICAgICAgLi4uXG5cbiAgICAgIDxpcm9uLXNlbGVjdG9yIHNlbGVjdGVkPVwiMFwiPlxuICAgICAgICA8ZGl2Pkl0ZW0gMTwvZGl2PlxuICAgICAgICA8ZGl2Pkl0ZW0gMjwvZGl2PlxuICAgICAgICA8ZGl2Pkl0ZW0gMzwvZGl2PlxuICAgICAgPC9pcm9uLXNlbGVjdG9yPlxuXG4gIEBkZW1vIGRlbW8vaW5kZXguaHRtbFxuICAqL1xuXG4gIFBvbHltZXIoe1xuXG4gICAgaXM6ICdpcm9uLXNlbGVjdG9yJyxcblxuICAgIGJlaGF2aW9yczogW1xuICAgICAgUG9seW1lci5Jcm9uTXVsdGlTZWxlY3RhYmxlQmVoYXZpb3JcbiAgICBdXG5cbiAgfSk7XG5cbjwvc2NyaXB0PlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9pcm9uLXNlbGVjdG9yL2lyb24tc2VsZWN0b3IuaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTUgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cblxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3BvbHltZXIvcG9seW1lci5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiaXJvbi1zZWxlY3RhYmxlLmh0bWxcIj5cblxuPHNjcmlwdD5cbiAgLyoqXG4gICAqIEBwb2x5bWVyQmVoYXZpb3IgUG9seW1lci5Jcm9uTXVsdGlTZWxlY3RhYmxlQmVoYXZpb3JcbiAgICovXG4gIFBvbHltZXIuSXJvbk11bHRpU2VsZWN0YWJsZUJlaGF2aW9ySW1wbCA9IHtcbiAgICBwcm9wZXJ0aWVzOiB7XG5cbiAgICAgIC8qKlxuICAgICAgICogSWYgdHJ1ZSwgbXVsdGlwbGUgc2VsZWN0aW9ucyBhcmUgYWxsb3dlZC5cbiAgICAgICAqL1xuICAgICAgbXVsdGk6IHtcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgdmFsdWU6IGZhbHNlLFxuICAgICAgICBvYnNlcnZlcjogJ211bHRpQ2hhbmdlZCdcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBzZWxlY3RlZCBlbGVtZW50cy4gVGhpcyBpcyB1c2VkIGluc3RlYWQgb2YgYHNlbGVjdGVkYCB3aGVuIGBtdWx0aWBcbiAgICAgICAqIGlzIHRydWUuXG4gICAgICAgKi9cbiAgICAgIHNlbGVjdGVkVmFsdWVzOiB7XG4gICAgICAgIHR5cGU6IEFycmF5LFxuICAgICAgICBub3RpZnk6IHRydWUsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogUmV0dXJucyBhbiBhcnJheSBvZiBjdXJyZW50bHkgc2VsZWN0ZWQgaXRlbXMuXG4gICAgICAgKi9cbiAgICAgIHNlbGVjdGVkSXRlbXM6IHtcbiAgICAgICAgdHlwZTogQXJyYXksXG4gICAgICAgIHJlYWRPbmx5OiB0cnVlLFxuICAgICAgICBub3RpZnk6IHRydWUsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICB9LFxuXG4gICAgb2JzZXJ2ZXJzOiBbXG4gICAgICAnX3VwZGF0ZVNlbGVjdGVkKHNlbGVjdGVkVmFsdWVzLnNwbGljZXMpJ1xuICAgIF0sXG5cbiAgICAvKipcbiAgICAgKiBTZWxlY3RzIHRoZSBnaXZlbiB2YWx1ZS4gSWYgdGhlIGBtdWx0aWAgcHJvcGVydHkgaXMgdHJ1ZSwgdGhlbiB0aGUgc2VsZWN0ZWQgc3RhdGUgb2YgdGhlXG4gICAgICogYHZhbHVlYCB3aWxsIGJlIHRvZ2dsZWQ7IG90aGVyd2lzZSB0aGUgYHZhbHVlYCB3aWxsIGJlIHNlbGVjdGVkLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBzZWxlY3RcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IHZhbHVlIHRoZSB2YWx1ZSB0byBzZWxlY3QuXG4gICAgICovXG4gICAgc2VsZWN0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgaWYgKHRoaXMubXVsdGkpIHtcbiAgICAgICAgdGhpcy5fdG9nZ2xlU2VsZWN0ZWQodmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zZWxlY3RlZCA9IHZhbHVlO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBtdWx0aUNoYW5nZWQ6IGZ1bmN0aW9uKG11bHRpKSB7XG4gICAgICB0aGlzLl9zZWxlY3Rpb24ubXVsdGkgPSBtdWx0aTtcbiAgICAgIHRoaXMuX3VwZGF0ZVNlbGVjdGVkKCk7XG4gICAgfSxcblxuICAgIC8vIFVOVVNFRCwgRk9SIEFQSSBDT01QQVRJQklMSVRZXG4gICAgZ2V0IF9zaG91bGRVcGRhdGVTZWxlY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZWxlY3RlZCAhPSBudWxsIHx8XG4gICAgICAgICh0aGlzLnNlbGVjdGVkVmFsdWVzICE9IG51bGwgJiYgdGhpcy5zZWxlY3RlZFZhbHVlcy5sZW5ndGgpO1xuICAgIH0sXG5cbiAgICBfdXBkYXRlQXR0ckZvclNlbGVjdGVkOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5tdWx0aSkge1xuICAgICAgICBQb2x5bWVyLklyb25TZWxlY3RhYmxlQmVoYXZpb3IuX3VwZGF0ZUF0dHJGb3JTZWxlY3RlZC5hcHBseSh0aGlzKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5zZWxlY3RlZEl0ZW1zICYmIHRoaXMuc2VsZWN0ZWRJdGVtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRWYWx1ZXMgPSB0aGlzLnNlbGVjdGVkSXRlbXMubWFwKGZ1bmN0aW9uKHNlbGVjdGVkSXRlbSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9pbmRleFRvVmFsdWUodGhpcy5pbmRleE9mKHNlbGVjdGVkSXRlbSkpO1xuICAgICAgICB9LCB0aGlzKS5maWx0ZXIoZnVuY3Rpb24odW5maWx0ZXJlZFZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIHVuZmlsdGVyZWRWYWx1ZSAhPSBudWxsO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgX3VwZGF0ZVNlbGVjdGVkOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLm11bHRpKSB7XG4gICAgICAgIHRoaXMuX3NlbGVjdE11bHRpKHRoaXMuc2VsZWN0ZWRWYWx1ZXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fc2VsZWN0U2VsZWN0ZWQodGhpcy5zZWxlY3RlZCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIF9zZWxlY3RNdWx0aTogZnVuY3Rpb24odmFsdWVzKSB7XG4gICAgICB2YWx1ZXMgPSB2YWx1ZXMgfHwgW107XG5cbiAgICAgIHZhciBzZWxlY3RlZEl0ZW1zID0gKHRoaXMuX3ZhbHVlc1RvSXRlbXModmFsdWVzKSB8fCBbXSkuZmlsdGVyKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0gIT09IG51bGwgJiYgaXRlbSAhPT0gdW5kZWZpbmVkO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIGNsZWFyIGFsbCBidXQgdGhlIGN1cnJlbnQgc2VsZWN0ZWQgaXRlbXNcbiAgICAgIHRoaXMuX3NlbGVjdGlvbi5jbGVhcihzZWxlY3RlZEl0ZW1zKTtcblxuICAgICAgLy8gc2VsZWN0IG9ubHkgdGhvc2Ugbm90IHNlbGVjdGVkIHlldFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxlY3RlZEl0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuX3NlbGVjdGlvbi5zZXRJdGVtU2VsZWN0ZWQoc2VsZWN0ZWRJdGVtc1tpXSwgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIGZvciBpdGVtcywgc2luY2UgdGhpcyBhcnJheSBpcyBwb3B1bGF0ZWQgb25seSB3aGVuIGF0dGFjaGVkXG4gICAgICBpZiAodGhpcy5mYWxsYmFja1NlbGVjdGlvbiAmJiAhdGhpcy5fc2VsZWN0aW9uLmdldCgpLmxlbmd0aCkge1xuICAgICAgICB2YXIgZmFsbGJhY2sgPSB0aGlzLl92YWx1ZVRvSXRlbSh0aGlzLmZhbGxiYWNrU2VsZWN0aW9uKTtcbiAgICAgICAgaWYgKGZhbGxiYWNrKSB7XG4gICAgICAgICAgdGhpcy5zZWxlY3QodGhpcy5mYWxsYmFja1NlbGVjdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgX3NlbGVjdGlvbkNoYW5nZTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcyA9IHRoaXMuX3NlbGVjdGlvbi5nZXQoKTtcbiAgICAgIGlmICh0aGlzLm11bHRpKSB7XG4gICAgICAgIHRoaXMuX3NldFNlbGVjdGVkSXRlbXMocyk7XG4gICAgICAgIHRoaXMuX3NldFNlbGVjdGVkSXRlbShzLmxlbmd0aCA/IHNbMF0gOiBudWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChzICE9PSBudWxsICYmIHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMuX3NldFNlbGVjdGVkSXRlbXMoW3NdKTtcbiAgICAgICAgICB0aGlzLl9zZXRTZWxlY3RlZEl0ZW0ocyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fc2V0U2VsZWN0ZWRJdGVtcyhbXSk7XG4gICAgICAgICAgdGhpcy5fc2V0U2VsZWN0ZWRJdGVtKG51bGwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIF90b2dnbGVTZWxlY3RlZDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHZhciBpID0gdGhpcy5zZWxlY3RlZFZhbHVlcy5pbmRleE9mKHZhbHVlKTtcbiAgICAgIHZhciB1bnNlbGVjdGVkID0gaSA8IDA7XG4gICAgICBpZiAodW5zZWxlY3RlZCkge1xuICAgICAgICB0aGlzLnB1c2goJ3NlbGVjdGVkVmFsdWVzJyx2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNwbGljZSgnc2VsZWN0ZWRWYWx1ZXMnLGksMSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIF92YWx1ZXNUb0l0ZW1zOiBmdW5jdGlvbih2YWx1ZXMpIHtcbiAgICAgIHJldHVybiAodmFsdWVzID09IG51bGwpID8gbnVsbCA6IHZhbHVlcy5tYXAoZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlVG9JdGVtKHZhbHVlKTtcbiAgICAgIH0sIHRoaXMpO1xuICAgIH1cbiAgfTtcblxuICAvKiogQHBvbHltZXJCZWhhdmlvciAqL1xuICBQb2x5bWVyLklyb25NdWx0aVNlbGVjdGFibGVCZWhhdmlvciA9IFtcbiAgICBQb2x5bWVyLklyb25TZWxlY3RhYmxlQmVoYXZpb3IsXG4gICAgUG9seW1lci5Jcm9uTXVsdGlTZWxlY3RhYmxlQmVoYXZpb3JJbXBsXG4gIF07XG5cbjwvc2NyaXB0PlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9pcm9uLXNlbGVjdG9yL2lyb24tbXVsdGktc2VsZWN0YWJsZS5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNSBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuXG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vcG9seW1lci9wb2x5bWVyLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi9pcm9uLWJlaGF2aW9ycy9pcm9uLWJ1dHRvbi1zdGF0ZS5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwicGFwZXItcmlwcGxlLWJlaGF2aW9yLmh0bWxcIj5cblxuPHNjcmlwdD5cbiAgLyoqXG4gICAqIGBQb2x5bWVyLlBhcGVySW5reUZvY3VzQmVoYXZpb3JgIGltcGxlbWVudHMgYSByaXBwbGUgd2hlbiB0aGUgZWxlbWVudCBoYXMga2V5Ym9hcmQgZm9jdXMuXG4gICAqXG4gICAqIEBwb2x5bWVyQmVoYXZpb3IgUG9seW1lci5QYXBlcklua3lGb2N1c0JlaGF2aW9yXG4gICAqL1xuICBQb2x5bWVyLlBhcGVySW5reUZvY3VzQmVoYXZpb3JJbXBsID0ge1xuICAgIG9ic2VydmVyczogW1xuICAgICAgJ19mb2N1c2VkQ2hhbmdlZChyZWNlaXZlZEZvY3VzRnJvbUtleWJvYXJkKSdcbiAgICBdLFxuXG4gICAgX2ZvY3VzZWRDaGFuZ2VkOiBmdW5jdGlvbihyZWNlaXZlZEZvY3VzRnJvbUtleWJvYXJkKSB7XG4gICAgICBpZiAocmVjZWl2ZWRGb2N1c0Zyb21LZXlib2FyZCkge1xuICAgICAgICB0aGlzLmVuc3VyZVJpcHBsZSgpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuaGFzUmlwcGxlKCkpIHtcbiAgICAgICAgdGhpcy5fcmlwcGxlLmhvbGREb3duID0gcmVjZWl2ZWRGb2N1c0Zyb21LZXlib2FyZDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgX2NyZWF0ZVJpcHBsZTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcmlwcGxlID0gUG9seW1lci5QYXBlclJpcHBsZUJlaGF2aW9yLl9jcmVhdGVSaXBwbGUoKTtcbiAgICAgIHJpcHBsZS5pZCA9ICdpbmsnO1xuICAgICAgcmlwcGxlLnNldEF0dHJpYnV0ZSgnY2VudGVyJywgJycpO1xuICAgICAgcmlwcGxlLmNsYXNzTGlzdC5hZGQoJ2NpcmNsZScpO1xuICAgICAgcmV0dXJuIHJpcHBsZTtcbiAgICB9XG4gIH07XG5cbiAgLyoqIEBwb2x5bWVyQmVoYXZpb3IgUG9seW1lci5QYXBlcklua3lGb2N1c0JlaGF2aW9yICovXG4gIFBvbHltZXIuUGFwZXJJbmt5Rm9jdXNCZWhhdmlvciA9IFtcbiAgICBQb2x5bWVyLklyb25CdXR0b25TdGF0ZSxcbiAgICBQb2x5bWVyLklyb25Db250cm9sU3RhdGUsXG4gICAgUG9seW1lci5QYXBlclJpcHBsZUJlaGF2aW9yLFxuICAgIFBvbHltZXIuUGFwZXJJbmt5Rm9jdXNCZWhhdmlvckltcGxcbiAgXTtcbjwvc2NyaXB0PlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9wYXBlci1iZWhhdmlvcnMvcGFwZXItaW5reS1mb2N1cy1iZWhhdmlvci5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNSBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuXG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vcG9seW1lci9wb2x5bWVyLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi9wYXBlci1yaXBwbGUvcGFwZXItcmlwcGxlLmh0bWxcIj5cblxuPHNjcmlwdD5cbiAgLyoqXG4gICAqIGBQb2x5bWVyLlBhcGVyUmlwcGxlQmVoYXZpb3JgIGR5bmFtaWNhbGx5IGltcGxlbWVudHMgYSByaXBwbGVcbiAgICogd2hlbiB0aGUgZWxlbWVudCBoYXMgZm9jdXMgdmlhIHBvaW50ZXIgb3Iga2V5Ym9hcmQuXG4gICAqXG4gICAqIE5PVEU6IFRoaXMgYmVoYXZpb3IgaXMgaW50ZW5kZWQgdG8gYmUgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIGFuZCBhZnRlclxuICAgKiBgUG9seW1lci5Jcm9uQnV0dG9uU3RhdGVgIGFuZCBgUG9seW1lci5Jcm9uQ29udHJvbFN0YXRlYC5cbiAgICpcbiAgICogQHBvbHltZXJCZWhhdmlvciBQb2x5bWVyLlBhcGVyUmlwcGxlQmVoYXZpb3JcbiAgICovXG4gIFBvbHltZXIuUGFwZXJSaXBwbGVCZWhhdmlvciA9IHtcbiAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAvKipcbiAgICAgICAqIElmIHRydWUsIHRoZSBlbGVtZW50IHdpbGwgbm90IHByb2R1Y2UgYSByaXBwbGUgZWZmZWN0IHdoZW4gaW50ZXJhY3RlZFxuICAgICAgICogd2l0aCB2aWEgdGhlIHBvaW50ZXIuXG4gICAgICAgKi9cbiAgICAgIG5vaW5rOiB7XG4gICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgIG9ic2VydmVyOiAnX25vaW5rQ2hhbmdlZCdcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogQHR5cGUge0VsZW1lbnR8dW5kZWZpbmVkfVxuICAgICAgICovXG4gICAgICBfcmlwcGxlQ29udGFpbmVyOiB7XG4gICAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRW5zdXJlcyBhIGA8cGFwZXItcmlwcGxlPmAgZWxlbWVudCBpcyBhdmFpbGFibGUgd2hlbiB0aGUgZWxlbWVudCBpc1xuICAgICAqIGZvY3VzZWQuXG4gICAgICovXG4gICAgX2J1dHRvblN0YXRlQ2hhbmdlZDogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5mb2N1c2VkKSB7XG4gICAgICAgIHRoaXMuZW5zdXJlUmlwcGxlKCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEluIGFkZGl0aW9uIHRvIHRoZSBmdW5jdGlvbmFsaXR5IHByb3ZpZGVkIGluIGBJcm9uQnV0dG9uU3RhdGVgLCBlbnN1cmVzXG4gICAgICogYSByaXBwbGUgZWZmZWN0IGlzIGNyZWF0ZWQgd2hlbiB0aGUgZWxlbWVudCBpcyBpbiBhIGBwcmVzc2VkYCBzdGF0ZS5cbiAgICAgKi9cbiAgICBfZG93bkhhbmRsZXI6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICBQb2x5bWVyLklyb25CdXR0b25TdGF0ZUltcGwuX2Rvd25IYW5kbGVyLmNhbGwodGhpcywgZXZlbnQpO1xuICAgICAgaWYgKHRoaXMucHJlc3NlZCkge1xuICAgICAgICB0aGlzLmVuc3VyZVJpcHBsZShldmVudCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEVuc3VyZXMgdGhpcyBlbGVtZW50IGNvbnRhaW5zIGEgcmlwcGxlIGVmZmVjdC4gRm9yIHN0YXJ0dXAgZWZmaWNpZW5jeVxuICAgICAqIHRoZSByaXBwbGUgZWZmZWN0IGlzIGR5bmFtaWNhbGx5IG9uIGRlbWFuZCB3aGVuIG5lZWRlZC5cbiAgICAgKiBAcGFyYW0geyFFdmVudD19IG9wdFRyaWdnZXJpbmdFdmVudCAob3B0aW9uYWwpIGV2ZW50IHRoYXQgdHJpZ2dlcmVkIHRoZVxuICAgICAqIHJpcHBsZS5cbiAgICAgKi9cbiAgICBlbnN1cmVSaXBwbGU6IGZ1bmN0aW9uKG9wdFRyaWdnZXJpbmdFdmVudCkge1xuICAgICAgaWYgKCF0aGlzLmhhc1JpcHBsZSgpKSB7XG4gICAgICAgIHRoaXMuX3JpcHBsZSA9IHRoaXMuX2NyZWF0ZVJpcHBsZSgpO1xuICAgICAgICB0aGlzLl9yaXBwbGUubm9pbmsgPSB0aGlzLm5vaW5rO1xuICAgICAgICB2YXIgcmlwcGxlQ29udGFpbmVyID0gdGhpcy5fcmlwcGxlQ29udGFpbmVyIHx8IHRoaXMucm9vdDtcbiAgICAgICAgaWYgKHJpcHBsZUNvbnRhaW5lcikge1xuICAgICAgICAgIFBvbHltZXIuZG9tKHJpcHBsZUNvbnRhaW5lcikuYXBwZW5kQ2hpbGQodGhpcy5fcmlwcGxlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0VHJpZ2dlcmluZ0V2ZW50KSB7XG4gICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGV2ZW50IGhhcHBlbmVkIGluc2lkZSBvZiB0aGUgcmlwcGxlIGNvbnRhaW5lclxuICAgICAgICAgIC8vIEZhbGwgYmFjayB0byBob3N0IGluc3RlYWQgb2YgdGhlIHJvb3QgYmVjYXVzZSBkaXN0cmlidXRlZCB0ZXh0XG4gICAgICAgICAgLy8gbm9kZXMgYXJlIG5vdCB2YWxpZCBldmVudCB0YXJnZXRzXG4gICAgICAgICAgdmFyIGRvbUNvbnRhaW5lciA9IFBvbHltZXIuZG9tKHRoaXMuX3JpcHBsZUNvbnRhaW5lciB8fCB0aGlzKTtcbiAgICAgICAgICB2YXIgdGFyZ2V0ID0gUG9seW1lci5kb20ob3B0VHJpZ2dlcmluZ0V2ZW50KS5yb290VGFyZ2V0O1xuICAgICAgICAgIGlmIChkb21Db250YWluZXIuZGVlcENvbnRhaW5zKCAvKiogQHR5cGUge05vZGV9ICovKHRhcmdldCkpKSB7XG4gICAgICAgICAgICB0aGlzLl9yaXBwbGUudWlEb3duQWN0aW9uKG9wdFRyaWdnZXJpbmdFdmVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGA8cGFwZXItcmlwcGxlPmAgZWxlbWVudCB1c2VkIGJ5IHRoaXMgZWxlbWVudCB0byBjcmVhdGVcbiAgICAgKiByaXBwbGUgZWZmZWN0cy4gVGhlIGVsZW1lbnQncyByaXBwbGUgaXMgY3JlYXRlZCBvbiBkZW1hbmQsIHdoZW5cbiAgICAgKiBuZWNlc3NhcnksIGFuZCBjYWxsaW5nIHRoaXMgbWV0aG9kIHdpbGwgZm9yY2UgdGhlXG4gICAgICogcmlwcGxlIHRvIGJlIGNyZWF0ZWQuXG4gICAgICovXG4gICAgZ2V0UmlwcGxlOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZW5zdXJlUmlwcGxlKCk7XG4gICAgICByZXR1cm4gdGhpcy5fcmlwcGxlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBlbGVtZW50IGN1cnJlbnRseSBjb250YWlucyBhIHJpcHBsZSBlZmZlY3QuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBoYXNSaXBwbGU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIEJvb2xlYW4odGhpcy5fcmlwcGxlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHRoZSBlbGVtZW50J3MgcmlwcGxlIGVmZmVjdCB2aWEgY3JlYXRpbmcgYSBgPHBhcGVyLXJpcHBsZT5gLlxuICAgICAqIE92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIGN1c3RvbWl6ZSB0aGUgcmlwcGxlIGVsZW1lbnQuXG4gICAgICogQHJldHVybiB7IVBhcGVyUmlwcGxlRWxlbWVudH0gUmV0dXJucyBhIGA8cGFwZXItcmlwcGxlPmAgZWxlbWVudC5cbiAgICAgKi9cbiAgICBfY3JlYXRlUmlwcGxlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAvKiogQHR5cGUgeyFQYXBlclJpcHBsZUVsZW1lbnR9ICovIChcbiAgICAgICAgICBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwYXBlci1yaXBwbGUnKSk7XG4gICAgfSxcblxuICAgIF9ub2lua0NoYW5nZWQ6IGZ1bmN0aW9uKG5vaW5rKSB7XG4gICAgICBpZiAodGhpcy5oYXNSaXBwbGUoKSkge1xuICAgICAgICB0aGlzLl9yaXBwbGUubm9pbmsgPSBub2luaztcbiAgICAgIH1cbiAgICB9XG4gIH07XG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvcGFwZXItYmVoYXZpb3JzL3BhcGVyLXJpcHBsZS1iZWhhdmlvci5odG1sIiwiXG5yZXF1aXJlKCcuLi9ib3dlcl9jb21wb25lbnRzL2lyb24taWNvbnNldC1zdmcvaXJvbi1pY29uc2V0LXN2Zy5odG1sJyk7XG5cbmNvbnN0IFJlZ2lzdGVySHRtbFRlbXBsYXRlID0gcmVxdWlyZSgncG9seW1lci13ZWJwYWNrLWxvYWRlci9yZWdpc3Rlci1odG1sLXRlbXBsYXRlJyk7XG5cblJlZ2lzdGVySHRtbFRlbXBsYXRlLnRvQm9keShcIjxpcm9uLWljb25zZXQtc3ZnIG5hbWU9bXktaWNvbnMgc2l6ZT0yND4gPHN2Zz4gPGRlZnM+IDxnIGlkPWFycm93LWJhY2s+IDxwYXRoIGQ9XFxcIk0yMCAxMUg3LjgzbDUuNTktNS41OUwxMiA0bC04IDggOCA4IDEuNDEtMS40MUw3LjgzIDEzSDIwdi0yelxcXCI+PC9wYXRoPiA8L2c+IDxnIGlkPW1lbnU+IDxwYXRoIGQ9XFxcIk0zIDE4aDE4di0ySDN2MnptMC01aDE4di0ySDN2MnptMC03djJoMThWNkgzelxcXCI+PC9wYXRoPiA8L2c+IDxnIGlkPWNoZXZyb24tcmlnaHQ+IDxwYXRoIGQ9XFxcIk0xMCA2TDguNTkgNy40MSAxMy4xNyAxMmwtNC41OCA0LjU5TDEwIDE4bDYtNnpcXFwiPjwvcGF0aD4gPC9nPiA8ZyBpZD1jbG9zZT4gPHBhdGggZD1cXFwiTTE5IDYuNDFMMTcuNTkgNSAxMiAxMC41OSA2LjQxIDUgNSA2LjQxIDEwLjU5IDEyIDUgMTcuNTkgNi40MSAxOSAxMiAxMy40MSAxNy41OSAxOSAxOSAxNy41OSAxMy40MSAxMnpcXFwiPjwvcGF0aD4gPC9nPiA8ZyBpZD1zZWFyY2g+PHBhdGggZD1cXFwiTTE1LjUgMTRoLS43OWwtLjI4LS4yN0MxNS40MSAxMi41OSAxNiAxMS4xMSAxNiA5LjUgMTYgNS45MSAxMy4wOSAzIDkuNSAzUzMgNS45MSAzIDkuNSA1LjkxIDE2IDkuNSAxNmMxLjYxIDAgMy4wOS0uNTkgNC4yMy0xLjU3bC4yNy4yOHYuNzlsNSA0Ljk5TDIwLjQ5IDE5bC00Ljk5LTV6bS02IDBDNy4wMSAxNCA1IDExLjk5IDUgOS41UzcuMDEgNSA5LjUgNSAxNCA3LjAxIDE0IDkuNSAxMS45OSAxNCA5LjUgMTR6XFxcIj48L3BhdGg+IDwvZz4gPC9kZWZzPiA8L3N2Zz4gPC9pcm9uLWljb25zZXQtc3ZnPlwiKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9teS1pY29ucy5odG1sIl0sInNvdXJjZVJvb3QiOiIifQ==