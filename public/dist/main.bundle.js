/******/ (function(modules) { // webpackBootstrap
/******/ 	// install a JSONP callback for chunk loading
/******/ 	var parentJsonpFunction = window["webpackJsonp"];
/******/ 	window["webpackJsonp"] = function webpackJsonpCallback(chunkIds, moreModules, executeModules) {
/******/ 		// add "moreModules" to the modules object,
/******/ 		// then flag all "chunkIds" as loaded and fire callback
/******/ 		var moduleId, chunkId, i = 0, resolves = [], result;
/******/ 		for(;i < chunkIds.length; i++) {
/******/ 			chunkId = chunkIds[i];
/******/ 			if(installedChunks[chunkId]) {
/******/ 				resolves.push(installedChunks[chunkId][0]);
/******/ 			}
/******/ 			installedChunks[chunkId] = 0;
/******/ 		}
/******/ 		for(moduleId in moreModules) {
/******/ 			if(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
/******/ 				modules[moduleId] = moreModules[moduleId];
/******/ 			}
/******/ 		}
/******/ 		if(parentJsonpFunction) parentJsonpFunction(chunkIds, moreModules, executeModules);
/******/ 		while(resolves.length) {
/******/ 			resolves.shift()();
/******/ 		}
/******/
/******/ 	};
/******/
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// objects to store loaded and loading chunks
/******/ 	var installedChunks = {
/******/ 		4: 0
/******/ 	};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/ 	// This file contains only the entry chunk.
/******/ 	// The chunk loading function for additional chunks
/******/ 	__webpack_require__.e = function requireEnsure(chunkId) {
/******/ 		var installedChunkData = installedChunks[chunkId];
/******/ 		if(installedChunkData === 0) {
/******/ 			return new Promise(function(resolve) { resolve(); });
/******/ 		}
/******/
/******/ 		// a Promise means "currently loading".
/******/ 		if(installedChunkData) {
/******/ 			return installedChunkData[2];
/******/ 		}
/******/
/******/ 		// setup Promise in chunk cache
/******/ 		var promise = new Promise(function(resolve, reject) {
/******/ 			installedChunkData = installedChunks[chunkId] = [resolve, reject];
/******/ 		});
/******/ 		installedChunkData[2] = promise;
/******/
/******/ 		// start chunk loading
/******/ 		var head = document.getElementsByTagName('head')[0];
/******/ 		var script = document.createElement('script');
/******/ 		script.type = 'text/javascript';
/******/ 		script.charset = 'utf-8';
/******/ 		script.async = true;
/******/ 		script.timeout = 120000;
/******/
/******/ 		if (__webpack_require__.nc) {
/******/ 			script.setAttribute("nonce", __webpack_require__.nc);
/******/ 		}
/******/ 		script.src = __webpack_require__.p + "" + chunkId + ".bundle.js";
/******/ 		var timeout = setTimeout(onScriptComplete, 120000);
/******/ 		script.onerror = script.onload = onScriptComplete;
/******/ 		function onScriptComplete() {
/******/ 			// avoid mem leaks in IE.
/******/ 			script.onerror = script.onload = null;
/******/ 			clearTimeout(timeout);
/******/ 			var chunk = installedChunks[chunkId];
/******/ 			if(chunk !== 0) {
/******/ 				if(chunk) {
/******/ 					chunk[1](new Error('Loading chunk ' + chunkId + ' failed.'));
/******/ 				}
/******/ 				installedChunks[chunkId] = undefined;
/******/ 			}
/******/ 		};
/******/ 		head.appendChild(script);
/******/
/******/ 		return promise;
/******/ 	};
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "dist/";
/******/
/******/ 	// on error function for async loading
/******/ 	__webpack_require__.oe = function(err) { console.error(err); throw err; };
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 30);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(19);

__webpack_require__(44);

__webpack_require__(46);

__webpack_require__(47);

__webpack_require__(48);

__webpack_require__(49);

__webpack_require__(50);

__webpack_require__(51);

__webpack_require__(54);

// bc
Polymer.Base = Polymer.LegacyElementMixin(HTMLElement).prototype;

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


(function () {
  'use strict';

  var userPolymer = window.Polymer;

  /**
   * @namespace Polymer
   * @summary Polymer is a lightweight library built on top of the web
   *   standards-based Web Components API's, and makes it easy to build your
   *   own custom HTML elements.
   * @param {!PolymerInit} info Prototype for the custom element. It must contain
   *   an `is` property to specify the element name. Other properties populate
   *   the element prototype. The `properties`, `observers`, `hostAttributes`,
   *   and `listeners` properties are processed to create element features.
   * @return {!Object} Returns a custom element class for the given provided
   *   prototype `info` object. The name of the element if given by `info.is`.
   */
  window.Polymer = function (info) {
    return window.Polymer._polymerFn(info);
  };

  // support user settings on the Polymer object
  if (userPolymer) {
    Object.assign(Polymer, userPolymer);
  }

  // To be plugged by legacy implementation if loaded
  /* eslint-disable valid-jsdoc */
  /**
   * @param {!PolymerInit} info Prototype for the custom element. It must contain
   *   an `is` property to specify the element name. Other properties populate
   *   the element prototype. The `properties`, `observers`, `hostAttributes`,
   *   and `listeners` properties are processed to create element features.
   * @return {!Object} Returns a custom element class for the given provided
   *   prototype `info` object. The name of the element if given by `info.is`.
   */
  window.Polymer._polymerFn = function (info) {
    // eslint-disable-line no-unused-vars
    throw new Error('Load polymer.html to use the Polymer() function.');
  };
  /* eslint-enable */

  window.Polymer.version = '2.0.1';

  /* eslint-disable no-unused-vars */
  /*
  When using Closure Compiler, JSCompiler_renameProperty(property, object) is replaced by the munged name for object[property]
  We cannot alias this function, so we have to use a small shim that has the same behavior when not compiling.
  */
  window.JSCompiler_renameProperty = function (prop, obj) {
    return prop;
  };
  /* eslint-enable */
})();

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/* eslint-env browser */

var RegisterHtmlTemplate = function () {
  function RegisterHtmlTemplate() {
    _classCallCheck(this, RegisterHtmlTemplate);
  }

  _createClass(RegisterHtmlTemplate, null, [{
    key: 'register',

    /**
     * Create a `<template>` element to hold `<dom-module>` content.
     * This bit of code will execute in the context of the main document,
     * calling `importNode` on the `<template>`, which in turn triggers
     * the lifecycle of the `<dom-module>` and allows it to insert its
     * content into Polymer's global module map. When a Polymer element
     * boots up it will fetch its template from this module map.
     * https://github.com/Polymer/polymer/blob/master/lib/mixins/element-mixin.html#L501-L538
     * @param {string} val A `<dom-module>` as an HTML string
     */
    value: function register(val) {
      var content = void 0;
      var template = document.createElement('template');
      template.innerHTML = val;
      if (template.content) {
        content = template.content; // eslint-disable-line prefer-destructuring
      } else {
        content = document.createDocumentFragment();
        while (template.firstChild) {
          content.appendChild(template.firstChild);
        }
      }
      document.importNode(content, true);
    }
    /**
     * Content that will be injected into the main document. This is primarily
     * for things like `<iron-iconset>` and `<custom-style>` which do not have
     * templates but rely on HTML Imports ability to apply content to the main
     * document.
     * @param {string} val An HTML string
     */

  }, {
    key: 'toBody',
    value: function toBody(val) {
      var trimmedVal = val.trim();
      if (trimmedVal) {
        var div = document.createElement('div');
        div.innerHTML = trimmedVal;
        if (div.firstChild) {
          if (document.body) {
            document.body.insertBefore(div.firstChild, document.body.firstChild);
          } else {
            document.addEventListener('DOMContentLoaded', function () {
              document.body.insertBefore(div.firstChild, document.body.firstChild);
            });
          }
        }
      }
    }
  }]);

  return RegisterHtmlTemplate;
}();

module.exports = RegisterHtmlTemplate;

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(1);

(function () {

  'use strict';

  // unique global id for deduping mixins.

  var dedupeId = 0;

  /**
   * @constructor
   * @extends {Function}
   */
  function MixinFunction() {}
  /** @type {(WeakMap | undefined)} */
  MixinFunction.prototype.__mixinApplications;
  /** @type {(Object | undefined)} */
  MixinFunction.prototype.__mixinSet;

  /* eslint-disable valid-jsdoc */
  /**
   * Wraps an ES6 class expression mixin such that the mixin is only applied
   * if it has not already been applied its base argument.  Also memoizes mixin
   * applications.
   *
   * @memberof Polymer
   * @template T
   * @param {T} mixin ES6 class expression mixin to wrap
   * @suppress {invalidCasts}
   */
  Polymer.dedupingMixin = function (mixin) {
    var mixinApplications = /** @type {!MixinFunction} */mixin.__mixinApplications;
    if (!mixinApplications) {
      mixinApplications = new WeakMap();
      /** @type {!MixinFunction} */mixin.__mixinApplications = mixinApplications;
    }
    // maintain a unique id for each mixin
    var mixinDedupeId = dedupeId++;
    function dedupingMixin(base) {
      var baseSet = /** @type {!MixinFunction} */base.__mixinSet;
      if (baseSet && baseSet[mixinDedupeId]) {
        return base;
      }
      var map = mixinApplications;
      var extended = map.get(base);
      if (!extended) {
        extended = /** @type {!Function} */mixin(base);
        map.set(base, extended);
      }
      // copy inherited mixin set from the extended class, or the base class
      // NOTE: we avoid use of Set here because some browser (IE11)
      // cannot extend a base Set via the constructor.
      var mixinSet = Object.create( /** @type {!MixinFunction} */extended.__mixinSet || baseSet || null);
      mixinSet[mixinDedupeId] = true;
      /** @type {!MixinFunction} */extended.__mixinSet = mixinSet;
      return extended;
    }

    return dedupingMixin;
  };
  /* eslint-enable valid-jsdoc */
})();

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

__webpack_require__(58);

__webpack_require__(59);

/**
 * `Polymer.AppScrollEffectsBehavior` provides an interface that allows an element to use scrolls effects.
 *
 * ### Importing the app-layout effects
 *
 * app-layout provides a set of scroll effects that can be used by explicitly importing
 * `app-scroll-effects.html`:
 *
 * ```html
 * <link rel="import" href="/bower_components/app-layout/app-scroll-effects/app-scroll-effects.html">
 * ```
 *
 * The scroll effects can also be used by individually importing
 * `app-layout/app-scroll-effects/effects/[effectName].html`. For example:
 *
 * ```html
 *  <link rel="import" href="/bower_components/app-layout/app-scroll-effects/effects/waterfall.html">
 * ```
 *
 * ### Consuming effects
 *
 * Effects can be consumed via the `effects` property. For example:
 *
 * ```html
 * <app-header effects="waterfall"></app-header>
 * ```
 *
 * ### Creating scroll effects
 *
 * You may want to create a custom scroll effect if you need to modify the CSS of an element
 * based on the scroll position.
 *
 * A scroll effect definition is an object with `setUp()`, `tearDown()` and `run()` functions.
 *
 * To register the effect, you can use `Polymer.AppLayout.registerEffect(effectName, effectDef)`
 * For example, let's define an effect that resizes the header's logo:
 *
 * ```js
 * Polymer.AppLayout.registerEffect('resizable-logo', {
 *   setUp: function(config) {
 *     // the effect's config is passed to the setUp.
 *     this._fxResizeLogo = { logo: Polymer.dom(this).querySelector('[logo]') };
 *   },
 *
 *   run: function(progress) {
 *      // the progress of the effect
 *      this.transform('scale3d(' + progress + ', '+ progress +', 1)',  this._fxResizeLogo.logo);
 *   },
 *
 *   tearDown: function() {
 *      // clean up and reset of states
 *      delete this._fxResizeLogo;
 *   }
 * });
 * ```
 * Now, you can consume the effect:
 *
 * ```html
 * <app-header id="appHeader" effects="resizable-logo">
 *   <img logo src="logo.svg">
 * </app-header>
 * ```
 *
 * ### Imperative API
 *
 * ```js
 * var logoEffect = appHeader.createEffect('resizable-logo', effectConfig);
 * // run the effect: logoEffect.run(progress);
 * // tear down the effect: logoEffect.tearDown();
 * ```
 *
 * ### Configuring effects
 *
 * For effects installed via the `effects` property, their configuration can be set
 * via the `effectsConfig` property. For example:
 *
 * ```html
 * <app-header effects="waterfall"
 *   effects-config='{"waterfall": {"startsAt": 0, "endsAt": 0.5}}'>
 * </app-header>
 * ```
 *
 * All effects have a `startsAt` and `endsAt` config property. They specify at what
 * point the effect should start and end. This value goes from 0 to 1 inclusive.
 *
 * @polymerBehavior
 */
Polymer.AppScrollEffectsBehavior = [Polymer.IronScrollTargetBehavior, {

  properties: {

    /**
     * A space-separated list of the effects names that will be triggered when the user scrolls.
     * e.g. `waterfall parallax-background` installs the `waterfall` and `parallax-background`.
     */
    effects: {
      type: String
    },

    /**
     * An object that configurates the effects installed via the `effects` property. e.g.
     * ```js
     *  element.effectsConfig = {
     *   "blend-background": {
     *     "startsAt": 0.5
     *   }
     * };
     * ```
     * Every effect has at least two config properties: `startsAt` and `endsAt`.
     * These properties indicate when the event should start and end respectively
     * and relative to the overall element progress. So for example, if `blend-background`
     * starts at `0.5`, the effect will only start once the current element reaches 0.5
     * of its progress. In this context, the progress is a value in the range of `[0, 1]`
     * that indicates where this element is on the screen relative to the viewport.
     */
    effectsConfig: {
      type: Object,
      value: function value() {
        return {};
      }
    },

    /**
     * Disables CSS transitions and scroll effects on the element.
     */
    disabled: {
      type: Boolean,
      reflectToAttribute: true,
      value: false
    },

    /**
     * Allows to set a `scrollTop` threshold. When greater than 0, `thresholdTriggered`
     * is true only when the scroll target's `scrollTop` has reached this value.
     *
     * For example, if `threshold = 100`, `thresholdTriggered` is true when the `scrollTop`
     * is at least `100`.
     */
    threshold: {
      type: Number,
      value: 0
    },

    /**
     * True if the `scrollTop` threshold (set in `scrollTopThreshold`) has
     * been reached.
     */
    thresholdTriggered: {
      type: Boolean,
      notify: true,
      readOnly: true,
      reflectToAttribute: true
    }
  },

  observers: ['_effectsChanged(effects, effectsConfig, isAttached)'],

  /**
   * Updates the scroll state. This method should be overridden
   * by the consumer of this behavior.
   *
   * @method _updateScrollState
   */
  _updateScrollState: function _updateScrollState() {},

  /**
   * Returns true if the current element is on the screen.
   * That is, visible in the current viewport. This method should be
   * overridden by the consumer of this behavior.
   *
   * @method isOnScreen
   * @return {boolean}
   */
  isOnScreen: function isOnScreen() {
    return false;
  },

  /**
   * Returns true if there's content below the current element. This method
   * should be overridden by the consumer of this behavior.
   *
   * @method isContentBelow
   * @return {boolean}
   */
  isContentBelow: function isContentBelow() {
    return false;
  },

  /**
   * List of effects handlers that will take place during scroll.
   *
   * @type {Array<Function>}
   */
  _effectsRunFn: null,

  /**
   * List of the effects definitions installed via the `effects` property.
   *
   * @type {Array<Object>}
   */
  _effects: null,

  /**
   * The clamped value of `_scrollTop`.
   * @type number
   */
  get _clampedScrollTop() {
    return Math.max(0, this._scrollTop);
  },

  detached: function detached() {
    this._tearDownEffects();
  },

  /**
   * Creates an effect object from an effect's name that can be used to run
   * effects programmatically.
   *
   * @method createEffect
   * @param {string} effectName The effect's name registered via `Polymer.AppLayout.registerEffect`.
   * @param {Object=} effectConfig The effect config object. (Optional)
   * @return {Object} An effect object with the following functions:
   *
   *  * `effect.setUp()`, Sets up the requirements for the effect.
   *       This function is called automatically before the `effect` function returns.
   *  * `effect.run(progress, y)`, Runs the effect given a `progress`.
   *  * `effect.tearDown()`, Cleans up any DOM nodes or element references used by the effect.
   *
   * Example:
   * ```js
   * var parallax = element.createEffect('parallax-background');
   * // runs the effect
   * parallax.run(0.5, 0);
   * ```
   */
  createEffect: function createEffect(effectName, effectConfig) {
    var effectDef = Polymer.AppLayout._scrollEffects[effectName];
    if (!effectDef) {
      throw new ReferenceError(this._getUndefinedMsg(effectName));
    }
    var prop = this._boundEffect(effectDef, effectConfig || {});
    prop.setUp();
    return prop;
  },

  /**
   * Called when `effects` or `effectsConfig` changes.
   */
  _effectsChanged: function _effectsChanged(effects, effectsConfig, isAttached) {
    this._tearDownEffects();

    if (!effects || !isAttached) {
      return;
    }
    effects.split(' ').forEach(function (effectName) {
      var effectDef;
      if (effectName !== '') {
        if (effectDef = Polymer.AppLayout._scrollEffects[effectName]) {
          this._effects.push(this._boundEffect(effectDef, effectsConfig[effectName]));
        } else {
          console.warn(this._getUndefinedMsg(effectName));
        }
      }
    }, this);

    this._setUpEffect();
  },

  /**
   * Forces layout
   */
  _layoutIfDirty: function _layoutIfDirty() {
    return this.offsetWidth;
  },

  /**
   * Returns an effect object bound to the current context.
   *
   * @param {Object} effectDef
   * @param {Object=} effectsConfig The effect config object if the effect accepts config values. (Optional)
   */
  _boundEffect: function _boundEffect(effectDef, effectsConfig) {
    effectsConfig = effectsConfig || {};
    var startsAt = parseFloat(effectsConfig.startsAt || 0);
    var endsAt = parseFloat(effectsConfig.endsAt || 1);
    var deltaS = endsAt - startsAt;
    var noop = function noop() {};
    // fast path if possible
    var runFn = startsAt === 0 && endsAt === 1 ? effectDef.run : function (progress, y) {
      effectDef.run.call(this, Math.max(0, (progress - startsAt) / deltaS), y);
    };
    return {
      setUp: effectDef.setUp ? effectDef.setUp.bind(this, effectsConfig) : noop,
      run: effectDef.run ? runFn.bind(this) : noop,
      tearDown: effectDef.tearDown ? effectDef.tearDown.bind(this) : noop
    };
  },

  /**
   * Sets up the effects.
   */
  _setUpEffect: function _setUpEffect() {
    if (this.isAttached && this._effects) {
      this._effectsRunFn = [];
      this._effects.forEach(function (effectDef) {
        // install the effect only if no error was reported
        if (effectDef.setUp() !== false) {
          this._effectsRunFn.push(effectDef.run);
        }
      }, this);
    }
  },

  /**
   * Tears down the effects.
   */
  _tearDownEffects: function _tearDownEffects() {
    if (this._effects) {
      this._effects.forEach(function (effectDef) {
        effectDef.tearDown();
      });
    }
    this._effectsRunFn = [];
    this._effects = [];
  },

  /**
   * Runs the effects.
   *
   * @param {number} p The progress
   * @param {number} y The top position of the current element relative to the viewport.
   */
  _runEffects: function _runEffects(p, y) {
    if (this._effectsRunFn) {
      this._effectsRunFn.forEach(function (run) {
        run(p, y);
      });
    }
  },

  /**
   * Overrides the `_scrollHandler`.
   */
  _scrollHandler: function _scrollHandler() {
    if (!this.disabled) {
      var scrollTop = this._clampedScrollTop;
      this._updateScrollState(scrollTop);
      if (this.threshold > 0) {
        this._setThresholdTriggered(scrollTop >= this.threshold);
      }
    }
  },

  /**
   * Override this method to return a reference to a node in the local DOM.
   * The node is consumed by a scroll effect.
   *
   * @param {string} id The id for the node.
   */
  _getDOMRef: function _getDOMRef(id) {
    console.warn('_getDOMRef', '`' + id + '` is undefined');
  },

  _getUndefinedMsg: function _getUndefinedMsg(effectName) {
    return 'Scroll effect `' + effectName + '` is undefined. ' + 'Did you forget to import app-layout/app-scroll-effects/effects/' + effectName + '.html ?';
  }

}];

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

var RegisterHtmlTemplate = __webpack_require__(2);

RegisterHtmlTemplate.toBody("<custom-style> <style is=custom-style>html{--layout:{display:-ms-flexbox;display:-webkit-flex;display:flex};--layout-inline:{display:-ms-inline-flexbox;display:-webkit-inline-flex;display:inline-flex};--layout-horizontal:{@apply --layout;-ms-flex-direction:row;-webkit-flex-direction:row;flex-direction:row};--layout-horizontal-reverse:{@apply --layout;-ms-flex-direction:row-reverse;-webkit-flex-direction:row-reverse;flex-direction:row-reverse};--layout-vertical:{@apply --layout;-ms-flex-direction:column;-webkit-flex-direction:column;flex-direction:column};--layout-vertical-reverse:{@apply --layout;-ms-flex-direction:column-reverse;-webkit-flex-direction:column-reverse;flex-direction:column-reverse};--layout-wrap:{-ms-flex-wrap:wrap;-webkit-flex-wrap:wrap;flex-wrap:wrap};--layout-wrap-reverse:{-ms-flex-wrap:wrap-reverse;-webkit-flex-wrap:wrap-reverse;flex-wrap:wrap-reverse};--layout-flex-auto:{-ms-flex:1 1 auto;-webkit-flex:1 1 auto;flex:1 1 auto};--layout-flex-none:{-ms-flex:none;-webkit-flex:none;flex:none};--layout-flex:{-ms-flex:1 1 .000000001px;-webkit-flex:1;flex:1;-webkit-flex-basis:.000000001px;flex-basis:.000000001px};--layout-flex-2:{-ms-flex:2;-webkit-flex:2;flex:2};--layout-flex-3:{-ms-flex:3;-webkit-flex:3;flex:3};--layout-flex-4:{-ms-flex:4;-webkit-flex:4;flex:4};--layout-flex-5:{-ms-flex:5;-webkit-flex:5;flex:5};--layout-flex-6:{-ms-flex:6;-webkit-flex:6;flex:6};--layout-flex-7:{-ms-flex:7;-webkit-flex:7;flex:7};--layout-flex-8:{-ms-flex:8;-webkit-flex:8;flex:8};--layout-flex-9:{-ms-flex:9;-webkit-flex:9;flex:9};--layout-flex-10:{-ms-flex:10;-webkit-flex:10;flex:10};--layout-flex-11:{-ms-flex:11;-webkit-flex:11;flex:11};--layout-flex-12:{-ms-flex:12;-webkit-flex:12;flex:12};--layout-start:{-ms-flex-align:start;-webkit-align-items:flex-start;align-items:flex-start};--layout-center:{-ms-flex-align:center;-webkit-align-items:center;align-items:center};--layout-end:{-ms-flex-align:end;-webkit-align-items:flex-end;align-items:flex-end};--layout-baseline:{-ms-flex-align:baseline;-webkit-align-items:baseline;align-items:baseline};--layout-start-justified:{-ms-flex-pack:start;-webkit-justify-content:flex-start;justify-content:flex-start};--layout-center-justified:{-ms-flex-pack:center;-webkit-justify-content:center;justify-content:center};--layout-end-justified:{-ms-flex-pack:end;-webkit-justify-content:flex-end;justify-content:flex-end};--layout-around-justified:{-ms-flex-pack:distribute;-webkit-justify-content:space-around;justify-content:space-around};--layout-justified:{-ms-flex-pack:justify;-webkit-justify-content:space-between;justify-content:space-between};--layout-center-center:{@apply --layout-center;@apply --layout-center-justified;};--layout-self-start:{-ms-align-self:flex-start;-webkit-align-self:flex-start;align-self:flex-start};--layout-self-center:{-ms-align-self:center;-webkit-align-self:center;align-self:center};--layout-self-end:{-ms-align-self:flex-end;-webkit-align-self:flex-end;align-self:flex-end};--layout-self-stretch:{-ms-align-self:stretch;-webkit-align-self:stretch;align-self:stretch};--layout-self-baseline:{-ms-align-self:baseline;-webkit-align-self:baseline;align-self:baseline};--layout-start-aligned:{-ms-flex-line-pack:start;-ms-align-content:flex-start;-webkit-align-content:flex-start;align-content:flex-start};--layout-end-aligned:{-ms-flex-line-pack:end;-ms-align-content:flex-end;-webkit-align-content:flex-end;align-content:flex-end};--layout-center-aligned:{-ms-flex-line-pack:center;-ms-align-content:center;-webkit-align-content:center;align-content:center};--layout-between-aligned:{-ms-flex-line-pack:justify;-ms-align-content:space-between;-webkit-align-content:space-between;align-content:space-between};--layout-around-aligned:{-ms-flex-line-pack:distribute;-ms-align-content:space-around;-webkit-align-content:space-around;align-content:space-around};--layout-block:{display:block};--layout-invisible:{visibility:hidden!important};--layout-relative:{position:relative};--layout-fit:{position:absolute;top:0;right:0;bottom:0;left:0};--layout-scroll:{-webkit-overflow-scrolling:touch;overflow:auto};--layout-fullbleed:{margin:0;height:100vh};--layout-fixed-top:{position:fixed;top:0;left:0;right:0};--layout-fixed-right:{position:fixed;top:0;right:0;bottom:0};--layout-fixed-bottom:{position:fixed;right:0;bottom:0;left:0};--layout-fixed-left:{position:fixed;top:0;bottom:0;left:0};}</style> </custom-style>");

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(16);

(function () {
  'use strict';

  /**
   * Base class that provides the core API for Polymer's meta-programming
   * features including template stamping, data-binding, attribute deserialization,
   * and property change observation.
   *
   * @customElement
   * @polymer
   * @memberof Polymer
   * @constructor
   * @implements {Polymer_ElementMixin}
   * @extends HTMLElement
   * @appliesMixin Polymer.ElementMixin
   * @summary Custom element base class that provides the core API for Polymer's
   *   key meta-programming features including template stamping, data-binding,
   *   attribute deserialization, and property change observation
   */

  var Element = Polymer.ElementMixin(HTMLElement);
  /**
   * @constructor
   * @implements {Polymer_ElementMixin}
   * @extends {HTMLElement}
   */
  Polymer.Element = Element;
})();

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(1);

(function () {
  'use strict';

  var CSS_URL_RX = /(url\()([^)]*)(\))/g;
  var ABS_URL = /(^\/)|(^#)|(^[\w-\d]*:)/;
  var workingURL = void 0;
  var resolveDoc = void 0;
  /**
   * Resolves the given URL against the provided `baseUri'.
   *
   * @memberof Polymer.ResolveUrl
   * @param {string} url Input URL to resolve
   * @param {?string=} baseURI Base URI to resolve the URL against
   * @return {string} resolved URL
   */
  function resolveUrl(url, baseURI) {
    if (url && ABS_URL.test(url)) {
      return url;
    }
    // Lazy feature detection.
    if (workingURL === undefined) {
      workingURL = false;
      try {
        var u = new URL('b', 'http://a');
        u.pathname = 'c%20d';
        workingURL = u.href === 'http://a/c%20d';
      } catch (e) {
        // silently fail
      }
    }
    if (!baseURI) {
      baseURI = document.baseURI || window.location.href;
    }
    if (workingURL) {
      return new URL(url, baseURI).href;
    }
    // Fallback to creating an anchor into a disconnected document.
    if (!resolveDoc) {
      resolveDoc = document.implementation.createHTMLDocument('temp');
      resolveDoc.base = resolveDoc.createElement('base');
      resolveDoc.head.appendChild(resolveDoc.base);
      resolveDoc.anchor = resolveDoc.createElement('a');
      resolveDoc.body.appendChild(resolveDoc.anchor);
    }
    resolveDoc.base.href = baseURI;
    resolveDoc.anchor.href = url;
    return resolveDoc.anchor.href || url;
  }

  /**
   * Resolves any relative URL's in the given CSS text against the provided
   * `ownerDocument`'s `baseURI`.
   *
   * @memberof Polymer.ResolveUrl
   * @param {string} cssText CSS text to process
   * @param {string} baseURI Base URI to resolve the URL against
   * @return {string} Processed CSS text with resolved URL's
   */
  function resolveCss(cssText, baseURI) {
    return cssText.replace(CSS_URL_RX, function (m, pre, url, post) {
      return pre + '\'' + resolveUrl(url.replace(/["']/g, ''), baseURI) + '\'' + post;
    });
  }

  /**
   * Returns a path from a given `url`. The path includes the trailing
   * `/` from the url.
   *
   * @memberof Polymer.ResolveUrl
   * @param {string} url Input URL to transform
   * @return {string} resolved path
   */
  function pathFromUrl(url) {
    return url.substring(0, url.lastIndexOf('/') + 1);
  }

  /**
   * Module with utilities for resolving relative URL's.
   *
   * @namespace
   * @memberof Polymer
   * @summary Module with utilities for resolving relative URL's.
   */
  Polymer.ResolveUrl = {
    resolveCss: resolveCss,
    resolveUrl: resolveUrl,
    pathFromUrl: pathFromUrl
  };
})();

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(1);

(function () {

  'use strict';

  /** @typedef {{run: function(function(), number=):number, cancel: function(number)}} */

  var AsyncInterface = void 0; // eslint-disable-line no-unused-vars

  // Microtask implemented using Mutation Observer
  var microtaskCurrHandle = 0;
  var microtaskLastHandle = 0;
  var microtaskCallbacks = [];
  var microtaskNodeContent = 0;
  var microtaskNode = document.createTextNode('');
  new window.MutationObserver(microtaskFlush).observe(microtaskNode, { characterData: true });

  function microtaskFlush() {
    var len = microtaskCallbacks.length;
    for (var i = 0; i < len; i++) {
      var cb = microtaskCallbacks[i];
      if (cb) {
        try {
          cb();
        } catch (e) {
          setTimeout(function () {
            throw e;
          });
        }
      }
    }
    microtaskCallbacks.splice(0, len);
    microtaskLastHandle += len;
  }

  /**
   * Module that provides a number of strategies for enqueuing asynchronous
   * tasks.  Each sub-module provides a standard `run(fn)` interface that returns a
   * handle, and a `cancel(handle)` interface for canceling async tasks before
   * they run.
   *
   * @namespace
   * @memberof Polymer
   * @summary Module that provides a number of strategies for enqueuing asynchronous
   * tasks.
   */
  Polymer.Async = {

    /**
     * Async interface wrapper around `setTimeout`.
     *
     * @namespace
     * @memberof Polymer.Async
     * @summary Async interface wrapper around `setTimeout`.
     */
    timeOut: {
      /**
       * Returns a sub-module with the async interface providing the provided
       * delay.
       *
       * @memberof Polymer.Async.timeOut
       * @param {number} delay Time to wait before calling callbacks in ms
       * @return {AsyncInterface} An async timeout interface
       */
      after: function after(delay) {
        return {
          run: function run(fn) {
            return setTimeout(fn, delay);
          },

          cancel: window.clearTimeout.bind(window)
        };
      },

      /**
       * Enqueues a function called in the next task.
       *
       * @memberof Polymer.Async.timeOut
       * @param {Function} fn Callback to run
       * @return {number} Handle used for canceling task
       */
      run: window.setTimeout.bind(window),
      /**
       * Cancels a previously enqueued `timeOut` callback.
       *
       * @memberof Polymer.Async.timeOut
       * @param {number} handle Handle returned from `run` of callback to cancel
       */
      cancel: window.clearTimeout.bind(window)
    },

    /**
     * Async interface wrapper around `requestAnimationFrame`.
     *
     * @namespace
     * @memberof Polymer.Async
     * @summary Async interface wrapper around `requestAnimationFrame`.
     */
    animationFrame: {
      /**
       * Enqueues a function called at `requestAnimationFrame` timing.
       *
       * @memberof Polymer.Async.animationFrame
       * @param {Function} fn Callback to run
       * @return {number} Handle used for canceling task
       */
      run: window.requestAnimationFrame.bind(window),
      /**
       * Cancels a previously enqueued `animationFrame` callback.
       *
       * @memberof Polymer.Async.timeOut
       * @param {number} handle Handle returned from `run` of callback to cancel
       */
      cancel: window.cancelAnimationFrame.bind(window)
    },

    /**
     * Async interface wrapper around `requestIdleCallback`.  Falls back to
     * `setTimeout` on browsers that do not support `requestIdleCallback`.
     *
     * @namespace
     * @memberof Polymer.Async
     * @summary Async interface wrapper around `requestIdleCallback`.
     */
    idlePeriod: {
      /**
       * Enqueues a function called at `requestIdleCallback` timing.
       *
       * @memberof Polymer.Async.idlePeriod
       * @param {function(IdleDeadline)} fn Callback to run
       * @return {number} Handle used for canceling task
       */
      run: function run(fn) {
        return window.requestIdleCallback ? window.requestIdleCallback(fn) : window.setTimeout(fn, 16);
      },

      /**
       * Cancels a previously enqueued `idlePeriod` callback.
       *
       * @memberof Polymer.Async.idlePeriod
       * @param {number} handle Handle returned from `run` of callback to cancel
       */
      cancel: function cancel(handle) {
        window.cancelIdleCallback ? window.cancelIdleCallback(handle) : window.clearTimeout(handle);
      }
    },

    /**
     * Async interface for enqueueing callbacks that run at microtask timing.
     *
     * Note that microtask timing is achieved via a single `MutationObserver`,
     * and thus callbacks enqueued with this API will all run in a single
     * batch, and not interleaved with other microtasks such as promises.
     * Promises are avoided as an implementation choice for the time being
     * due to Safari bugs that cause Promises to lack microtask guarantees.
     *
     * @namespace
     * @memberof Polymer.Async
     * @summary Async interface for enqueueing callbacks that run at microtask
     *   timing.
     */
    microTask: {

      /**
       * Enqueues a function called at microtask timing.
       *
       * @memberof Polymer.Async.microTask
       * @param {Function} callback Callback to run
       * @return {number} Handle used for canceling task
       */
      run: function run(callback) {
        microtaskNode.textContent = microtaskNodeContent++;
        microtaskCallbacks.push(callback);
        return microtaskCurrHandle++;
      },


      /**
       * Cancels a previously enqueued `microTask` callback.
       *
       * @memberof Polymer.Async.microTask
       * @param {number} handle Handle returned from `run` of callback to cancel
       */
      cancel: function cancel(handle) {
        var idx = handle - microtaskLastHandle;
        if (idx >= 0) {
          if (!microtaskCallbacks[idx]) {
            throw new Error('invalid async handle: ' + handle);
          }
          microtaskCallbacks[idx] = null;
        }
      }
    }
  };
})();

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

__webpack_require__(3);

(function () {
  'use strict';

  // Common implementation for mixin & behavior

  function mutablePropertyChange(inst, property, value, old, mutableData) {
    var isObject = void 0;
    if (mutableData) {
      isObject = (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && value !== null;
      // Pull `old` for Objects from temp cache, but treat `null` as a primitive
      if (isObject) {
        old = inst.__dataTemp[property];
      }
    }
    // Strict equality check, but return false for NaN===NaN
    var shouldChange = old !== value && (old === old || value === value);
    // Objects are stored in temporary cache (cleared at end of
    // turn), which is used for dirty-checking
    if (isObject && shouldChange) {
      inst.__dataTemp[property] = value;
    }
    return shouldChange;
  }

  /**
   * Element class mixin to skip strict dirty-checking for objects and arrays
   * (always consider them to be "dirty"), for use on elements utilizing
   * `Polymer.PropertyEffects`
   *
   * By default, `Polymer.PropertyEffects` performs strict dirty checking on
   * objects, which means that any deep modifications to an object or array will
   * not be propagated unless "immutable" data patterns are used (i.e. all object
   * references from the root to the mutation were changed).
   *
   * Polymer also provides a proprietary data mutation and path notification API
   * (e.g. `notifyPath`, `set`, and array mutation API's) that allow efficient
   * mutation and notification of deep changes in an object graph to all elements
   * bound to the same object graph.
   *
   * In cases where neither immutable patterns nor the data mutation API can be
   * used, applying this mixin will cause Polymer to skip dirty checking for
   * objects and arrays (always consider them to be "dirty").  This allows a
   * user to make a deep modification to a bound object graph, and then either
   * simply re-set the object (e.g. `this.items = this.items`) or call `notifyPath`
   * (e.g. `this.notifyPath('items')`) to update the tree.  Note that all
   * elements that wish to be updated based on deep mutations must apply this
   * mixin or otherwise skip strict dirty checking for objects/arrays.
   *
   * In order to make the dirty check strategy configurable, see
   * `Polymer.OptionalMutableData`.
   *
   * Note, the performance characteristics of propagating large object graphs
   * will be worse as opposed to using strict dirty checking with immutable
   * patterns or Polymer's path notification API.
   *
   * @mixinFunction
   * @polymer
   * @memberof Polymer
   * @summary Element class mixin to skip strict dirty-checking for objects
   *   and arrays
   */
  Polymer.MutableData = Polymer.dedupingMixin(function (superClass) {

    /**
     * @polymer
     * @mixinClass
     * @implements {Polymer_MutableData}
     */
    var MutableData = function (_superClass) {
      _inherits(MutableData, _superClass);

      function MutableData() {
        _classCallCheck(this, MutableData);

        return _possibleConstructorReturn(this, (MutableData.__proto__ || Object.getPrototypeOf(MutableData)).apply(this, arguments));
      }

      _createClass(MutableData, [{
        key: '_shouldPropertyChange',

        /**
         * Overrides `Polymer.PropertyEffects` to provide option for skipping
         * strict equality checking for Objects and Arrays.
         *
         * This method pulls the value to dirty check against from the `__dataTemp`
         * cache (rather than the normal `__data` cache) for Objects.  Since the temp
         * cache is cleared at the end of a turn, this implementation allows
         * side-effects of deep object changes to be processed by re-setting the
         * same object (using the temp cache as an in-turn backstop to prevent
         * cycles due to 2-way notification).
         *
         * @param {string} property Property name
         * @param {*} value New property value
         * @param {*} old Previous property value
         * @return {boolean} Whether the property should be considered a change
         * @protected
         */
        value: function _shouldPropertyChange(property, value, old) {
          return mutablePropertyChange(this, property, value, old, true);
        }
      }]);

      return MutableData;
    }(superClass);
    /** @type {boolean} */


    MutableData.prototype.mutableData = false;

    return MutableData;
  });

  /**
   * Element class mixin to add the optional ability to skip strict
   * dirty-checking for objects and arrays (always consider them to be
   * "dirty") by setting a `mutable-data` attribute on an element instance.
   *
   * By default, `Polymer.PropertyEffects` performs strict dirty checking on
   * objects, which means that any deep modifications to an object or array will
   * not be propagated unless "immutable" data patterns are used (i.e. all object
   * references from the root to the mutation were changed).
   *
   * Polymer also provides a proprietary data mutation and path notification API
   * (e.g. `notifyPath`, `set`, and array mutation API's) that allow efficient
   * mutation and notification of deep changes in an object graph to all elements
   * bound to the same object graph.
   *
   * In cases where neither immutable patterns nor the data mutation API can be
   * used, applying this mixin will allow Polymer to skip dirty checking for
   * objects and arrays (always consider them to be "dirty").  This allows a
   * user to make a deep modification to a bound object graph, and then either
   * simply re-set the object (e.g. `this.items = this.items`) or call `notifyPath`
   * (e.g. `this.notifyPath('items')`) to update the tree.  Note that all
   * elements that wish to be updated based on deep mutations must apply this
   * mixin or otherwise skip strict dirty checking for objects/arrays.
   *
   * While this mixin adds the ability to forgo Object/Array dirty checking,
   * the `mutableData` flag defaults to false and must be set on the instance.
   *
   * Note, the performance characteristics of propagating large object graphs
   * will be worse by relying on `mutableData: true` as opposed to using
   * strict dirty checking with immutable patterns or Polymer's path notification
   * API.
   *
   * @mixinFunction
   * @polymer
   * @memberof Polymer
   * @summary Element class mixin to optionally skip strict dirty-checking
   *   for objects and arrays
   */
  Polymer.OptionalMutableData = Polymer.dedupingMixin(function (superClass) {

    /**
     * @mixinClass
     * @polymer
     * @implements {Polymer_OptionalMutableData}
     */
    var OptionalMutableData = function (_superClass2) {
      _inherits(OptionalMutableData, _superClass2);

      function OptionalMutableData() {
        _classCallCheck(this, OptionalMutableData);

        return _possibleConstructorReturn(this, (OptionalMutableData.__proto__ || Object.getPrototypeOf(OptionalMutableData)).apply(this, arguments));
      }

      _createClass(OptionalMutableData, [{
        key: '_shouldPropertyChange',


        /**
         * Overrides `Polymer.PropertyEffects` to provide option for skipping
         * strict equality checking for Objects and Arrays.
         *
         * When `this.mutableData` is true on this instance, this method
         * pulls the value to dirty check against from the `__dataTemp` cache
         * (rather than the normal `__data` cache) for Objects.  Since the temp
         * cache is cleared at the end of a turn, this implementation allows
         * side-effects of deep object changes to be processed by re-setting the
         * same object (using the temp cache as an in-turn backstop to prevent
         * cycles due to 2-way notification).
         *
         * @param {string} property Property name
         * @param {*} value New property value
         * @param {*} old Previous property value
         * @return {boolean} Whether the property should be considered a change
         * @protected
         */
        value: function _shouldPropertyChange(property, value, old) {
          return mutablePropertyChange(this, property, value, old, this.mutableData);
        }
      }], [{
        key: 'properties',
        get: function get() {
          return {
            /**
             * Instance-level flag for configuring the dirty-checking strategy
             * for this element.  When true, Objects and Arrays will skip dirty
             * checking, otherwise strict equality checking will be used.
             */
            mutableData: Boolean
          };
        }
      }]);

      return OptionalMutableData;
    }(superClass);

    return OptionalMutableData;
  });

  // Export for use by legacy behavior
  Polymer.MutableData._mutablePropertyChange = mutablePropertyChange;
})();

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(1);

(function () {
  'use strict';

  var caseMap = {};
  var DASH_TO_CAMEL = /-[a-z]/g;
  var CAMEL_TO_DASH = /([A-Z])/g;

  /**
   * Module with utilities for converting between "dash-case" and "camelCase"
   * identifiers.
   *
   * @namespace
   * @memberof Polymer
   * @summary Module that provides utilities for converting between "dash-case"
   *   and "camelCase".
   */
  var CaseMap = {

    /**
     * Converts "dash-case" identifier (e.g. `foo-bar-baz`) to "camelCase"
     * (e.g. `fooBarBaz`).
     *
     * @memberof Polymer.CaseMap
     * @param {string} dash Dash-case identifier
     * @return {string} Camel-case representation of the identifier
     */
    dashToCamelCase: function dashToCamelCase(dash) {
      return caseMap[dash] || (caseMap[dash] = dash.indexOf('-') < 0 ? dash : dash.replace(DASH_TO_CAMEL, function (m) {
        return m[1].toUpperCase();
      }));
    },


    /**
     * Converts "camelCase" identifier (e.g. `fooBarBaz`) to "dash-case"
     * (e.g. `foo-bar-baz`).
     *
     * @memberof Polymer.CaseMap
     * @param {string} camel Camel-case identifier
     * @return {string} Dash-case representation of the identifier
     */
    camelToDashCase: function camelToDashCase(camel) {
      return caseMap[camel] || (caseMap[camel] = camel.replace(CAMEL_TO_DASH, '-$1').toLowerCase());
    }
  };

  Polymer.CaseMap = CaseMap;
})();

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

__webpack_require__(1);

__webpack_require__(3);

__webpack_require__(32);

__webpack_require__(10);

__webpack_require__(33);

__webpack_require__(34);

(function () {

  'use strict';

  /** @const {Object} */

  var CaseMap = Polymer.CaseMap;

  // Monotonically increasing unique ID used for de-duping effects triggered
  // from multiple properties in the same turn
  var dedupeId = 0;

  /**
   * Property effect types; effects are stored on the prototype using these keys
   * @enum {string}
   */
  var TYPES = {
    COMPUTE: '__computeEffects',
    REFLECT: '__reflectEffects',
    NOTIFY: '__notifyEffects',
    PROPAGATE: '__propagateEffects',
    OBSERVE: '__observeEffects',
    READ_ONLY: '__readOnly'

    /**
     * @typedef {{
     * name: (string | undefined),
     * structured: (boolean | undefined),
     * wildcard: (boolean | undefined)
     * }}
     */
  };var DataTrigger = void 0; //eslint-disable-line no-unused-vars

  /**
   * @typedef {{
   * info: ?,
   * trigger: (!DataTrigger | undefined),
   * fn: (!Function | undefined)
   * }}
   */
  var DataEffect = void 0; //eslint-disable-line no-unused-vars

  var PropertyEffectsType = void 0; //eslint-disable-line no-unused-vars

  /**
   * Ensures that the model has an own-property map of effects for the given type.
   * The model may be a prototype or an instance.
   *
   * Property effects are stored as arrays of effects by property in a map,
   * by named type on the model. e.g.
   *
   *   __computeEffects: {
   *     foo: [ ... ],
   *     bar: [ ... ]
   *   }
   *
   * If the model does not yet have an effect map for the type, one is created
   * and returned.  If it does, but it is not an own property (i.e. the
   * prototype had effects), the the map is deeply cloned and the copy is
   * set on the model and returned, ready for new effects to be added.
   *
   * @param {Object} model Prototype or instance
   * @param {string} type Property effect type
   * @return {Object} The own-property map of effects for the given type
   * @private
   */
  function ensureOwnEffectMap(model, type) {
    var effects = model[type];
    if (!effects) {
      effects = model[type] = {};
    } else if (!model.hasOwnProperty(type)) {
      effects = model[type] = Object.create(model[type]);
      for (var p in effects) {
        var protoFx = effects[p];
        var instFx = effects[p] = Array(protoFx.length);
        for (var i = 0; i < protoFx.length; i++) {
          instFx[i] = protoFx[i];
        }
      }
    }
    return effects;
  }

  // -- effects ----------------------------------------------

  /**
   * Runs all effects of a given type for the given set of property changes
   * on an instance.
   *
   * @param {!PropertyEffectsType} inst The instance with effects to run
   * @param {Object} effects Object map of property-to-Array of effects
   * @param {Object} props Bag of current property changes
   * @param {Object=} oldProps Bag of previous values for changed properties
   * @param {boolean=} hasPaths True with `props` contains one or more paths
   * @param {*=} extraArgs Additional metadata to pass to effect function
   * @return {boolean} True if an effect ran for this property
   * @private
   */
  function runEffects(inst, effects, props, oldProps, hasPaths, extraArgs) {
    if (effects) {
      var ran = false;
      var id = dedupeId++;
      for (var prop in props) {
        if (runEffectsForProperty(inst, effects, id, prop, props, oldProps, hasPaths, extraArgs)) {
          ran = true;
        }
      }
      return ran;
    }
    return false;
  }

  /**
   * Runs a list of effects for a given property.
   *
   * @param {!PropertyEffectsType} inst The instance with effects to run
   * @param {Object} effects Object map of property-to-Array of effects
   * @param {number} dedupeId Counter used for de-duping effects
   * @param {string} prop Name of changed property
   * @param {*} props Changed properties
   * @param {*} oldProps Old properties
   * @param {boolean=} hasPaths True with `props` contains one or more paths
   * @param {*=} extraArgs Additional metadata to pass to effect function
   * @return {boolean} True if an effect ran for this property
   * @private
   */
  function runEffectsForProperty(inst, effects, dedupeId, prop, props, oldProps, hasPaths, extraArgs) {
    var ran = false;
    var rootProperty = hasPaths ? Polymer.Path.root(prop) : prop;
    var fxs = effects[rootProperty];
    if (fxs) {
      for (var i = 0, l = fxs.length, fx; i < l && (fx = fxs[i]); i++) {
        if ((!fx.info || fx.info.lastRun !== dedupeId) && (!hasPaths || pathMatchesTrigger(prop, fx.trigger))) {
          if (fx.info) {
            fx.info.lastRun = dedupeId;
          }
          fx.fn(inst, prop, props, oldProps, fx.info, hasPaths, extraArgs);
          ran = true;
        }
      }
    }
    return ran;
  }

  /**
   * Determines whether a property/path that has changed matches the trigger
   * criteria for an effect.  A trigger is a descriptor with the following
   * structure, which matches the descriptors returned from `parseArg`.
   * e.g. for `foo.bar.*`:
   * ```
   * trigger: {
   *   name: 'a.b',
   *   structured: true,
   *   wildcard: true
   * }
   * ```
   * If no trigger is given, the path is deemed to match.
   *
   * @param {string} path Path or property that changed
   * @param {DataTrigger} trigger Descriptor
   * @return {boolean} Whether the path matched the trigger
   */
  function pathMatchesTrigger(path, trigger) {
    if (trigger) {
      var triggerPath = trigger.name;
      return triggerPath == path || trigger.structured && Polymer.Path.isAncestor(triggerPath, path) || trigger.wildcard && Polymer.Path.isDescendant(triggerPath, path);
    } else {
      return true;
    }
  }

  /**
   * Implements the "observer" effect.
   *
   * Calls the method with `info.methodName` on the instance, passing the
   * new and old values.
   *
   * @param {!PropertyEffectsType} inst The instance the effect will be run on
   * @param {string} property Name of property
   * @param {Object} props Bag of current property changes
   * @param {Object} oldProps Bag of previous values for changed properties
   * @param {?} info Effect metadata
   * @private
   */
  function runObserverEffect(inst, property, props, oldProps, info) {
    var fn = inst[info.methodName];
    var changedProp = info.property;
    if (fn) {
      fn.call(inst, inst.__data[changedProp], oldProps[changedProp]);
    } else if (!info.dynamicFn) {
      console.warn('observer method `' + info.methodName + '` not defined');
    }
  }

  /**
   * Runs "notify" effects for a set of changed properties.
   *
   * This method differs from the generic `runEffects` method in that it
   * will dispatch path notification events in the case that the property
   * changed was a path and the root property for that path didn't have a
   * "notify" effect.  This is to maintain 1.0 behavior that did not require
   * `notify: true` to ensure object sub-property notifications were
   * sent.
   *
   * @param {!PropertyEffectsType} inst The instance with effects to run
   * @param {Object} notifyProps Bag of properties to notify
   * @param {Object} props Bag of current property changes
   * @param {Object} oldProps Bag of previous values for changed properties
   * @param {boolean} hasPaths True with `props` contains one or more paths
   * @private
   */
  function runNotifyEffects(inst, notifyProps, props, oldProps, hasPaths) {
    // Notify
    var fxs = inst[TYPES.NOTIFY];
    var notified = void 0;
    var id = dedupeId++;
    // Try normal notify effects; if none, fall back to try path notification
    for (var prop in notifyProps) {
      if (notifyProps[prop]) {
        if (fxs && runEffectsForProperty(inst, fxs, id, prop, props, oldProps, hasPaths)) {
          notified = true;
        } else if (hasPaths && notifyPath(inst, prop, props)) {
          notified = true;
        }
      }
    }
    // Flush host if we actually notified and host was batching
    // And the host has already initialized clients; this prevents
    // an issue with a host observing data changes before clients are ready.
    var host = void 0;
    if (notified && (host = inst.__dataHost) && host._invalidateProperties) {
      host._invalidateProperties();
    }
  }

  /**
   * Dispatches {property}-changed events with path information in the detail
   * object to indicate a sub-path of the property was changed.
   *
   * @param {!PropertyEffectsType} inst The element from which to fire the event
   * @param {string} path The path that was changed
   * @param {Object} props Bag of current property changes
   * @return {boolean} Returns true if the path was notified
   * @private
   */
  function notifyPath(inst, path, props) {
    var rootProperty = Polymer.Path.root(path);
    if (rootProperty !== path) {
      var eventName = Polymer.CaseMap.camelToDashCase(rootProperty) + '-changed';
      dispatchNotifyEvent(inst, eventName, props[path], path);
      return true;
    }
    return false;
  }

  /**
   * Dispatches {property}-changed events to indicate a property (or path)
   * changed.
   *
   * @param {!PropertyEffectsType} inst The element from which to fire the event
   * @param {string} eventName The name of the event to send ('{property}-changed')
   * @param {*} value The value of the changed property
   * @param {string | null | undefined} path If a sub-path of this property changed, the path
   *   that changed (optional).
   * @private
   * @suppress {invalidCasts}
   */
  function dispatchNotifyEvent(inst, eventName, value, path) {
    var detail = {
      value: value,
      queueProperty: true
    };
    if (path) {
      detail.path = path;
    }
    /** @type {!HTMLElement} */inst.dispatchEvent(new CustomEvent(eventName, { detail: detail }));
  }

  /**
   * Implements the "notify" effect.
   *
   * Dispatches a non-bubbling event named `info.eventName` on the instance
   * with a detail object containing the new `value`.
   *
   * @param {!PropertyEffectsType} inst The instance the effect will be run on
   * @param {string} property Name of property
   * @param {Object} props Bag of current property changes
   * @param {Object} oldProps Bag of previous values for changed properties
   * @param {?} info Effect metadata
   * @param {boolean} hasPaths True with `props` contains one or more paths
   * @private
   */
  function runNotifyEffect(inst, property, props, oldProps, info, hasPaths) {
    var rootProperty = hasPaths ? Polymer.Path.root(property) : property;
    var path = rootProperty != property ? property : null;
    var value = path ? Polymer.Path.get(inst, path) : inst.__data[property];
    if (path && value === undefined) {
      value = props[property]; // specifically for .splices
    }
    dispatchNotifyEvent(inst, info.eventName, value, path);
  }

  /**
   * Handler function for 2-way notification events. Receives context
   * information captured in the `addNotifyListener` closure from the
   * `__notifyListeners` metadata.
   *
   * Sets the value of the notified property to the host property or path.  If
   * the event contained path information, translate that path to the host
   * scope's name for that path first.
   *
   * @param {CustomEvent} event Notification event (e.g. '<property>-changed')
   * @param {!PropertyEffectsType} inst Host element instance handling the notification event
   * @param {string} fromProp Child element property that was bound
   * @param {string} toPath Host property/path that was bound
   * @param {boolean} negate Whether the binding was negated
   * @private
   */
  function handleNotification(event, inst, fromProp, toPath, negate) {
    var value = void 0;
    var detail = /** @type {Object} */event.detail;
    var fromPath = detail && detail.path;
    if (fromPath) {
      toPath = Polymer.Path.translate(fromProp, toPath, fromPath);
      value = detail && detail.value;
    } else {
      value = event.target[fromProp];
    }
    value = negate ? !value : value;
    if (!inst[TYPES.READ_ONLY] || !inst[TYPES.READ_ONLY][toPath]) {
      if (inst._setPendingPropertyOrPath(toPath, value, true, Boolean(fromPath)) && (!detail || !detail.queueProperty)) {
        inst._invalidateProperties();
      }
    }
  }

  /**
   * Implements the "reflect" effect.
   *
   * Sets the attribute named `info.attrName` to the given property value.
   *
   * @param {!PropertyEffectsType} inst The instance the effect will be run on
   * @param {string} property Name of property
   * @param {Object} props Bag of current property changes
   * @param {Object} oldProps Bag of previous values for changed properties
   * @param {?} info Effect metadata
   * @private
   */
  function runReflectEffect(inst, property, props, oldProps, info) {
    var value = inst.__data[property];
    if (Polymer.sanitizeDOMValue) {
      value = Polymer.sanitizeDOMValue(value, info.attrName, 'attribute', /** @type {Node} */inst);
    }
    inst._propertyToAttribute(property, info.attrName, value);
  }

  /**
   * Runs "computed" effects for a set of changed properties.
   *
   * This method differs from the generic `runEffects` method in that it
   * continues to run computed effects based on the output of each pass until
   * there are no more newly computed properties.  This ensures that all
   * properties that will be computed by the initial set of changes are
   * computed before other effects (binding propagation, observers, and notify)
   * run.
   *
   * @param {!PropertyEffectsType} inst The instance the effect will be run on
   * @param {!Object} changedProps Bag of changed properties
   * @param {!Object} oldProps Bag of previous values for changed properties
   * @param {boolean} hasPaths True with `props` contains one or more paths
   * @private
   */
  function runComputedEffects(inst, changedProps, oldProps, hasPaths) {
    var computeEffects = inst[TYPES.COMPUTE];
    if (computeEffects) {
      var inputProps = changedProps;
      while (runEffects(inst, computeEffects, inputProps, oldProps, hasPaths)) {
        Object.assign(oldProps, inst.__dataOld);
        Object.assign(changedProps, inst.__dataPending);
        inputProps = inst.__dataPending;
        inst.__dataPending = null;
      }
    }
  }

  /**
   * Implements the "computed property" effect by running the method with the
   * values of the arguments specified in the `info` object and setting the
   * return value to the computed property specified.
   *
   * @param {!PropertyEffectsType} inst The instance the effect will be run on
   * @param {string} property Name of property
   * @param {Object} props Bag of current property changes
   * @param {Object} oldProps Bag of previous values for changed properties
   * @param {?} info Effect metadata
   * @private
   */
  function runComputedEffect(inst, property, props, oldProps, info) {
    var result = runMethodEffect(inst, property, props, oldProps, info);
    var computedProp = info.methodInfo;
    if (inst.__dataHasAccessor && inst.__dataHasAccessor[computedProp]) {
      inst._setPendingProperty(computedProp, result, true);
    } else {
      inst[computedProp] = result;
    }
  }

  /**
   * Computes path changes based on path links set up using the `linkPaths`
   * API.
   *
   * @param {!PropertyEffectsType} inst The instance whose props are changing
   * @param {string | !Array<(string|number)>} path Path that has changed
   * @param {*} value Value of changed path
   * @private
   */
  function computeLinkedPaths(inst, path, value) {
    var links = inst.__dataLinkedPaths;
    if (links) {
      var link = void 0;
      for (var a in links) {
        var b = links[a];
        if (Polymer.Path.isDescendant(a, path)) {
          link = Polymer.Path.translate(a, b, path);
          inst._setPendingPropertyOrPath(link, value, true, true);
        } else if (Polymer.Path.isDescendant(b, path)) {
          link = Polymer.Path.translate(b, a, path);
          inst._setPendingPropertyOrPath(link, value, true, true);
        }
      }
    }
  }

  // -- bindings ----------------------------------------------

  /**
   * Adds binding metadata to the current `nodeInfo`, and binding effects
   * for all part dependencies to `templateInfo`.
   *
   * @param {Function} constructor Class that `_parseTemplate` is currently
   *   running on
   * @param {TemplateInfo} templateInfo Template metadata for current template
   * @param {NodeInfo} nodeInfo Node metadata for current template node
   * @param {string} kind Binding kind, either 'property', 'attribute', or 'text'
   * @param {string} target Target property name
   * @param {!Array<!BindingPart>} parts Array of binding part metadata
   * @param {string=} literal Literal text surrounding binding parts (specified
   *   only for 'property' bindings, since these must be initialized as part
   *   of boot-up)
   * @private
   */
  function addBinding(constructor, templateInfo, nodeInfo, kind, target, parts, literal) {
    // Create binding metadata and add to nodeInfo
    nodeInfo.bindings = nodeInfo.bindings || [];
    var /** Binding */binding = { kind: kind, target: target, parts: parts, literal: literal, isCompound: parts.length !== 1 };
    nodeInfo.bindings.push(binding);
    // Add listener info to binding metadata
    if (shouldAddListener(binding)) {
      var _binding$parts$ = binding.parts[0],
          event = _binding$parts$.event,
          negate = _binding$parts$.negate;

      binding.listenerEvent = event || CaseMap.camelToDashCase(target) + '-changed';
      binding.listenerNegate = negate;
    }
    // Add "propagate" property effects to templateInfo
    var index = templateInfo.nodeInfoList.length;
    for (var i = 0; i < binding.parts.length; i++) {
      var part = binding.parts[i];
      part.compoundIndex = i;
      addEffectForBindingPart(constructor, templateInfo, binding, part, index);
    }
  }

  /**
   * Adds property effects to the given `templateInfo` for the given binding
   * part.
   *
   * @param {Function} constructor Class that `_parseTemplate` is currently
   *   running on
   * @param {TemplateInfo} templateInfo Template metadata for current template
   * @param {!Binding} binding Binding metadata
   * @param {!BindingPart} part Binding part metadata
   * @param {number} index Index into `nodeInfoList` for this node
   */
  function addEffectForBindingPart(constructor, templateInfo, binding, part, index) {
    if (!part.literal) {
      if (binding.kind === 'attribute' && binding.target[0] === '-') {
        console.warn('Cannot set attribute ' + binding.target + ' because "-" is not a valid attribute starting character');
      } else {
        var dependencies = part.dependencies;
        var info = { index: index, binding: binding, part: part, evaluator: constructor };
        for (var j = 0; j < dependencies.length; j++) {
          var trigger = dependencies[j];
          if (typeof trigger == 'string') {
            trigger = parseArg(trigger);
            trigger.wildcard = true;
          }
          constructor._addTemplatePropertyEffect(templateInfo, trigger.rootProperty, {
            fn: runBindingEffect,
            info: info, trigger: trigger
          });
        }
      }
    }
  }

  /**
   * Implements the "binding" (property/path binding) effect.
   *
   * Note that binding syntax is overridable via `_parseBindings` and
   * `_evaluateBinding`.  This method will call `_evaluateBinding` for any
   * non-literal parts returned from `_parseBindings`.  However,
   * there is no support for _path_ bindings via custom binding parts,
   * as this is specific to Polymer's path binding syntax.
   *
   * @param {!PropertyEffectsType} inst The instance the effect will be run on
   * @param {string} path Name of property
   * @param {Object} props Bag of current property changes
   * @param {Object} oldProps Bag of previous values for changed properties
   * @param {?} info Effect metadata
   * @param {boolean} hasPaths True with `props` contains one or more paths
   * @param {Array} nodeList List of nodes associated with `nodeInfoList` template
   *   metadata
   * @private
   */
  function runBindingEffect(inst, path, props, oldProps, info, hasPaths, nodeList) {
    var node = nodeList[info.index];
    var binding = info.binding;
    var part = info.part;
    // Subpath notification: transform path and set to client
    // e.g.: foo="{{obj.sub}}", path: 'obj.sub.prop', set 'foo.prop'=obj.sub.prop
    if (hasPaths && part.source && path.length > part.source.length && binding.kind == 'property' && !binding.isCompound && node.__dataHasAccessor && node.__dataHasAccessor[binding.target]) {
      var value = props[path];
      path = Polymer.Path.translate(part.source, binding.target, path);
      if (node._setPendingPropertyOrPath(path, value, false, true)) {
        inst._enqueueClient(node);
      }
    } else {
      var _value = info.evaluator._evaluateBinding(inst, part, path, props, oldProps, hasPaths);
      // Propagate value to child
      applyBindingValue(inst, node, binding, part, _value);
    }
  }

  /**
   * Sets the value for an "binding" (binding) effect to a node,
   * either as a property or attribute.
   *
   * @param {!PropertyEffectsType} inst The instance owning the binding effect
   * @param {Node} node Target node for binding
   * @param {!Binding} binding Binding metadata
   * @param {!BindingPart} part Binding part metadata
   * @param {*} value Value to set
   * @private
   */
  function applyBindingValue(inst, node, binding, part, value) {
    value = computeBindingValue(node, value, binding, part);
    if (Polymer.sanitizeDOMValue) {
      value = Polymer.sanitizeDOMValue(value, binding.target, binding.kind, node);
    }
    if (binding.kind == 'attribute') {
      // Attribute binding
      inst._valueToNodeAttribute( /** @type {Element} */node, value, binding.target);
    } else {
      // Property binding
      var prop = binding.target;
      if (node.__dataHasAccessor && node.__dataHasAccessor[prop]) {
        if (!node[TYPES.READ_ONLY] || !node[TYPES.READ_ONLY][prop]) {
          if (node._setPendingProperty(prop, value)) {
            inst._enqueueClient(node);
          }
        }
      } else {
        inst._setUnmanagedPropertyToNode(node, prop, value);
      }
    }
  }

  /**
   * Transforms an "binding" effect value based on compound & negation
   * effect metadata, as well as handling for special-case properties
   *
   * @param {Node} node Node the value will be set to
   * @param {*} value Value to set
   * @param {!Binding} binding Binding metadata
   * @param {!BindingPart} part Binding part metadata
   * @return {*} Transformed value to set
   * @private
   */
  function computeBindingValue(node, value, binding, part) {
    if (binding.isCompound) {
      var storage = node.__dataCompoundStorage[binding.target];
      storage[part.compoundIndex] = value;
      value = storage.join('');
    }
    if (binding.kind !== 'attribute') {
      // Some browsers serialize `undefined` to `"undefined"`
      if (binding.target === 'textContent' || node.localName == 'input' && binding.target == 'value') {
        value = value == undefined ? '' : value;
      }
    }
    return value;
  }

  /**
   * Returns true if a binding's metadata meets all the requirements to allow
   * 2-way binding, and therefore a `<property>-changed` event listener should be
   * added:
   * - used curly braces
   * - is a property (not attribute) binding
   * - is not a textContent binding
   * - is not compound
   *
   * @param {!Binding} binding Binding metadata
   * @return {boolean} True if 2-way listener should be added
   * @private
   */
  function shouldAddListener(binding) {
    return Boolean(binding.target) && binding.kind != 'attribute' && binding.kind != 'text' && !binding.isCompound && binding.parts[0].mode === '{';
  }

  /**
   * Setup compound binding storage structures, notify listeners, and dataHost
   * references onto the bound nodeList.
   *
   * @param {!PropertyEffectsType} inst Instance that bas been previously bound
   * @param {TemplateInfo} templateInfo Template metadata
   * @private
   */
  function setupBindings(inst, templateInfo) {
    // Setup compound storage, dataHost, and notify listeners
    var nodeList = templateInfo.nodeList,
        nodeInfoList = templateInfo.nodeInfoList;

    if (nodeInfoList.length) {
      for (var i = 0; i < nodeInfoList.length; i++) {
        var info = nodeInfoList[i];
        var node = nodeList[i];
        var bindings = info.bindings;
        if (bindings) {
          for (var _i = 0; _i < bindings.length; _i++) {
            var binding = bindings[_i];
            setupCompoundStorage(node, binding);
            addNotifyListener(node, inst, binding);
          }
        }
        node.__dataHost = inst;
      }
    }
  }

  /**
   * Initializes `__dataCompoundStorage` local storage on a bound node with
   * initial literal data for compound bindings, and sets the joined
   * literal parts to the bound property.
   *
   * When changes to compound parts occur, they are first set into the compound
   * storage array for that property, and then the array is joined to result in
   * the final value set to the property/attribute.
   *
   * @param {Node} node Bound node to initialize
   * @param {Binding} binding Binding metadata
   * @private
   */
  function setupCompoundStorage(node, binding) {
    if (binding.isCompound) {
      // Create compound storage map
      var storage = node.__dataCompoundStorage || (node.__dataCompoundStorage = {});
      var parts = binding.parts;
      // Copy literals from parts into storage for this binding
      var literals = new Array(parts.length);
      for (var j = 0; j < parts.length; j++) {
        literals[j] = parts[j].literal;
      }
      var target = binding.target;
      storage[target] = literals;
      // Configure properties with their literal parts
      if (binding.literal && binding.kind == 'property') {
        node[target] = binding.literal;
      }
    }
  }

  /**
   * Adds a 2-way binding notification event listener to the node specified
   *
   * @param {Object} node Child element to add listener to
   * @param {!PropertyEffectsType} inst Host element instance to handle notification event
   * @param {Binding} binding Binding metadata
   * @private
   */
  function addNotifyListener(node, inst, binding) {
    if (binding.listenerEvent) {
      var part = binding.parts[0];
      node.addEventListener(binding.listenerEvent, function (e) {
        handleNotification(e, inst, binding.target, part.source, part.negate);
      });
    }
  }

  // -- for method-based effects (complexObserver & computed) --------------

  /**
   * Adds property effects for each argument in the method signature (and
   * optionally, for the method name if `dynamic` is true) that calls the
   * provided effect function.
   *
   * @param {Element | Object} model Prototype or instance
   * @param {!MethodSignature} sig Method signature metadata
   * @param {string} type Type of property effect to add
   * @param {Function} effectFn Function to run when arguments change
   * @param {*=} methodInfo Effect-specific information to be included in
   *   method effect metadata
   * @param {boolean|Object=} dynamicFn Boolean or object map indicating whether
   *   method names should be included as a dependency to the effect. Note,
   *   defaults to true if the signature is static (sig.static is true).
   * @private
   */
  function createMethodEffect(model, sig, type, effectFn, methodInfo, dynamicFn) {
    dynamicFn = sig.static || dynamicFn && ((typeof dynamicFn === 'undefined' ? 'undefined' : _typeof(dynamicFn)) !== 'object' || dynamicFn[sig.methodName]);
    var info = {
      methodName: sig.methodName,
      args: sig.args,
      methodInfo: methodInfo,
      dynamicFn: dynamicFn
    };
    for (var i = 0, arg; i < sig.args.length && (arg = sig.args[i]); i++) {
      if (!arg.literal) {
        model._addPropertyEffect(arg.rootProperty, type, {
          fn: effectFn, info: info, trigger: arg
        });
      }
    }
    if (dynamicFn) {
      model._addPropertyEffect(sig.methodName, type, {
        fn: effectFn, info: info
      });
    }
  }

  /**
   * Calls a method with arguments marshaled from properties on the instance
   * based on the method signature contained in the effect metadata.
   *
   * Multi-property observers, computed properties, and inline computing
   * functions call this function to invoke the method, then use the return
   * value accordingly.
   *
   * @param {!PropertyEffectsType} inst The instance the effect will be run on
   * @param {string} property Name of property
   * @param {Object} props Bag of current property changes
   * @param {Object} oldProps Bag of previous values for changed properties
   * @param {?} info Effect metadata
   * @return {*} Returns the return value from the method invocation
   * @private
   */
  function runMethodEffect(inst, property, props, oldProps, info) {
    // Instances can optionally have a _methodHost which allows redirecting where
    // to find methods. Currently used by `templatize`.
    var context = inst._methodHost || inst;
    var fn = context[info.methodName];
    if (fn) {
      var args = marshalArgs(inst.__data, info.args, property, props);
      return fn.apply(context, args);
    } else if (!info.dynamicFn) {
      console.warn('method `' + info.methodName + '` not defined');
    }
  }

  var emptyArray = [];

  // Regular expressions used for binding
  var IDENT = '(?:' + '[a-zA-Z_$][\\w.:$\\-*]*' + ')';
  var NUMBER = '(?:' + '[-+]?[0-9]*\\.?[0-9]+(?:[eE][-+]?[0-9]+)?' + ')';
  var SQUOTE_STRING = '(?:' + '\'(?:[^\'\\\\]|\\\\.)*\'' + ')';
  var DQUOTE_STRING = '(?:' + '"(?:[^"\\\\]|\\\\.)*"' + ')';
  var STRING = '(?:' + SQUOTE_STRING + '|' + DQUOTE_STRING + ')';
  var ARGUMENT = '(?:(' + IDENT + '|' + NUMBER + '|' + STRING + ')\\s*' + ')';
  var ARGUMENTS = '(?:' + ARGUMENT + '(?:,\\s*' + ARGUMENT + ')*' + ')';
  var ARGUMENT_LIST = '(?:' + '\\(\\s*' + '(?:' + ARGUMENTS + '?' + ')' + '\\)\\s*' + ')';
  var BINDING = '(' + IDENT + '\\s*' + ARGUMENT_LIST + '?' + ')'; // Group 3
  var OPEN_BRACKET = '(\\[\\[|{{)' + '\\s*';
  var CLOSE_BRACKET = '(?:]]|}})';
  var NEGATE = '(?:(!)\\s*)?'; // Group 2
  var EXPRESSION = OPEN_BRACKET + NEGATE + BINDING + CLOSE_BRACKET;
  var bindingRegex = new RegExp(EXPRESSION, "g");

  /**
   * Create a string from binding parts of all the literal parts
   *
   * @param {!Array<BindingPart>} parts All parts to stringify
   * @return {string} String made from the literal parts
   */
  function literalFromParts(parts) {
    var s = '';
    for (var i = 0; i < parts.length; i++) {
      var literal = parts[i].literal;
      s += literal || '';
    }
    return s;
  }

  /**
   * Parses an expression string for a method signature, and returns a metadata
   * describing the method in terms of `methodName`, `static` (whether all the
   * arguments are literals), and an array of `args`
   *
   * @param {string} expression The expression to parse
   * @return {?MethodSignature} The method metadata object if a method expression was
   *   found, otherwise `undefined`
   * @private
   */
  function parseMethod(expression) {
    // tries to match valid javascript property names
    var m = expression.match(/([^\s]+?)\(([\s\S]*)\)/);
    if (m) {
      var methodName = m[1];
      var sig = { methodName: methodName, static: true, args: emptyArray };
      if (m[2].trim()) {
        // replace escaped commas with comma entity, split on un-escaped commas
        var args = m[2].replace(/\\,/g, '&comma;').split(',');
        return parseArgs(args, sig);
      } else {
        return sig;
      }
    }
    return null;
  }

  /**
   * Parses an array of arguments and sets the `args` property of the supplied
   * signature metadata object. Sets the `static` property to false if any
   * argument is a non-literal.
   *
   * @param {!Array<string>} argList Array of argument names
   * @param {!MethodSignature} sig Method signature metadata object
   * @return {!MethodSignature} The updated signature metadata object
   * @private
   */
  function parseArgs(argList, sig) {
    sig.args = argList.map(function (rawArg) {
      var arg = parseArg(rawArg);
      if (!arg.literal) {
        sig.static = false;
      }
      return arg;
    }, this);
    return sig;
  }

  /**
   * Parses an individual argument, and returns an argument metadata object
   * with the following fields:
   *
   *   {
   *     value: 'prop',        // property/path or literal value
   *     literal: false,       // whether argument is a literal
   *     structured: false,    // whether the property is a path
   *     rootProperty: 'prop', // the root property of the path
   *     wildcard: false       // whether the argument was a wildcard '.*' path
   *   }
   *
   * @param {string} rawArg The string value of the argument
   * @return {!MethodArg} Argument metadata object
   * @private
   */
  function parseArg(rawArg) {
    // clean up whitespace
    var arg = rawArg.trim()
    // replace comma entity with comma
    .replace(/&comma;/g, ',')
    // repair extra escape sequences; note only commas strictly need
    // escaping, but we allow any other char to be escaped since its
    // likely users will do this
    .replace(/\\(.)/g, '\$1');
    // basic argument descriptor
    var a = {
      name: arg,
      value: '',
      literal: false
    };
    // detect literal value (must be String or Number)
    var fc = arg[0];
    if (fc === '-') {
      fc = arg[1];
    }
    if (fc >= '0' && fc <= '9') {
      fc = '#';
    }
    switch (fc) {
      case "'":
      case '"':
        a.value = arg.slice(1, -1);
        a.literal = true;
        break;
      case '#':
        a.value = Number(arg);
        a.literal = true;
        break;
    }
    // if not literal, look for structured path
    if (!a.literal) {
      a.rootProperty = Polymer.Path.root(arg);
      // detect structured path (has dots)
      a.structured = Polymer.Path.isPath(arg);
      if (a.structured) {
        a.wildcard = arg.slice(-2) == '.*';
        if (a.wildcard) {
          a.name = arg.slice(0, -2);
        }
      }
    }
    return a;
  }

  /**
   * Gather the argument values for a method specified in the provided array
   * of argument metadata.
   *
   * The `path` and `value` arguments are used to fill in wildcard descriptor
   * when the method is being called as a result of a path notification.
   *
   * @param {Object} data Instance data storage object to read properties from
   * @param {!Array<!MethodArg>} args Array of argument metadata
   * @param {string} path Property/path name that triggered the method effect
   * @param {Object} props Bag of current property changes
   * @return {Array<*>} Array of argument values
   * @private
   */
  function marshalArgs(data, args, path, props) {
    var values = [];
    for (var i = 0, l = args.length; i < l; i++) {
      var arg = args[i];
      var name = arg.name;
      var v = void 0;
      if (arg.literal) {
        v = arg.value;
      } else {
        if (arg.structured) {
          v = Polymer.Path.get(data, name);
          // when data is not stored e.g. `splices`
          if (v === undefined) {
            v = props[name];
          }
        } else {
          v = data[name];
        }
      }
      if (arg.wildcard) {
        // Only send the actual path changed info if the change that
        // caused the observer to run matched the wildcard
        var baseChanged = name.indexOf(path + '.') === 0;
        var matches = path.indexOf(name) === 0 && !baseChanged;
        values[i] = {
          path: matches ? path : name,
          value: matches ? props[path] : v,
          base: v
        };
      } else {
        values[i] = v;
      }
    }
    return values;
  }

  // data api

  /**
   * Sends array splice notifications (`.splices` and `.length`)
   *
   * Note: this implementation only accepts normalized paths
   *
   * @param {!PropertyEffectsType} inst Instance to send notifications to
   * @param {Array} array The array the mutations occurred on
   * @param {string} path The path to the array that was mutated
   * @param {Array} splices Array of splice records
   * @private
   */
  function _notifySplices(inst, array, path, splices) {
    var splicesPath = path + '.splices';
    inst.notifyPath(splicesPath, { indexSplices: splices });
    inst.notifyPath(path + '.length', array.length);
    // Null here to allow potentially large splice records to be GC'ed.
    inst.__data[splicesPath] = { indexSplices: null };
  }

  /**
   * Creates a splice record and sends an array splice notification for
   * the described mutation
   *
   * Note: this implementation only accepts normalized paths
   *
   * @param {!PropertyEffectsType} inst Instance to send notifications to
   * @param {Array} array The array the mutations occurred on
   * @param {string} path The path to the array that was mutated
   * @param {number} index Index at which the array mutation occurred
   * @param {number} addedCount Number of added items
   * @param {Array} removed Array of removed items
   * @private
   */
  function notifySplice(inst, array, path, index, addedCount, removed) {
    _notifySplices(inst, array, path, [{
      index: index,
      addedCount: addedCount,
      removed: removed,
      object: array,
      type: 'splice'
    }]);
  }

  /**
   * Returns an upper-cased version of the string.
   *
   * @param {string} name String to uppercase
   * @return {string} Uppercased string
   * @private
   */
  function upper(name) {
    return name[0].toUpperCase() + name.substring(1);
  }

  /**
   * Element class mixin that provides meta-programming for Polymer's template
   * binding and data observation (collectively, "property effects") system.
   *
   * This mixin uses provides the following key static methods for adding
   * property effects to an element class:
   * - `addPropertyEffect`
   * - `createPropertyObserver`
   * - `createMethodObserver`
   * - `createNotifyingProperty`
   * - `createReadOnlyProperty`
   * - `createReflectedProperty`
   * - `createComputedProperty`
   * - `bindTemplate`
   *
   * Each method creates one or more property accessors, along with metadata
   * used by this mixin's implementation of `_propertiesChanged` to perform
   * the property effects.
   *
   * Underscored versions of the above methods also exist on the element
   * prototype for adding property effects on instances at runtime.
   *
   * Note that this mixin overrides several `PropertyAccessors` methods, in
   * many cases to maintain guarantees provided by the Polymer 1.x features;
   * notably it changes property accessors to be synchronous by default
   * whereas the default when using `PropertyAccessors` standalone is to be
   * async by default.
   *
   * @mixinFunction
   * @polymer
   * @appliesMixin Polymer.TemplateStamp
   * @appliesMixin Polymer.PropertyAccessors
   * @memberof Polymer
   * @summary Element class mixin that provides meta-programming for Polymer's
   * template binding and data observation system.
   */
  Polymer.PropertyEffects = Polymer.dedupingMixin(function (superClass) {

    /**
     * @constructor
     * @extends {superClass}
     * @implements {Polymer_PropertyAccessors}
     * @implements {Polymer_TemplateStamp}
     * @unrestricted
     */
    var propertyEffectsBase = Polymer.TemplateStamp(Polymer.PropertyAccessors(superClass));

    /**
     * @polymer
     * @mixinClass
     * @implements {Polymer_PropertyEffects}
     * @extends {propertyEffectsBase}
     * @unrestricted
     */

    var PropertyEffects = function (_propertyEffectsBase) {
      _inherits(PropertyEffects, _propertyEffectsBase);

      function PropertyEffects() {
        _classCallCheck(this, PropertyEffects);

        /** @type {boolean} */
        var _this = _possibleConstructorReturn(this, (PropertyEffects.__proto__ || Object.getPrototypeOf(PropertyEffects)).call(this));

        _this.__dataClientsReady;
        /** @type {Array} */
        _this.__dataPendingClients;
        /** @type {Object} */
        _this.__dataToNotify;
        /** @type {Object} */
        _this.__dataLinkedPaths;
        /** @type {boolean} */
        _this.__dataHasPaths;
        /** @type {Object} */
        _this.__dataCompoundStorage;
        /** @type {Polymer_PropertyEffects} */
        _this.__dataHost;
        /** @type {!Object} */
        _this.__dataTemp;
        /** @type {boolean} */
        _this.__dataClientsInitialized;
        /** @type {!Object} */
        _this.__data;
        /** @type {!Object} */
        _this.__dataPending;
        /** @type {!Object} */
        _this.__dataOld;
        /** @type {Object} */
        _this.__computeEffects;
        /** @type {Object} */
        _this.__reflectEffects;
        /** @type {Object} */
        _this.__notifyEffects;
        /** @type {Object} */
        _this.__propagateEffects;
        /** @type {Object} */
        _this.__observeEffects;
        /** @type {Object} */
        _this.__readOnly;
        /** @type {number} */
        _this.__dataCounter;
        /** @type {!TemplateInfo} */
        _this.__templateInfo;
        return _this;
      }

      _createClass(PropertyEffects, [{
        key: '_initializeProperties',
        value: function _initializeProperties() {
          _get(PropertyEffects.prototype.__proto__ || Object.getPrototypeOf(PropertyEffects.prototype), '_initializeProperties', this).call(this);
          hostStack.registerHost(this);
          this.__dataClientsReady = false;
          this.__dataPendingClients = null;
          this.__dataToNotify = null;
          this.__dataLinkedPaths = null;
          this.__dataHasPaths = false;
          // May be set on instance prior to upgrade
          this.__dataCompoundStorage = this.__dataCompoundStorage || null;
          this.__dataHost = this.__dataHost || null;
          this.__dataTemp = {};
          this.__dataClientsInitialized = false;
        }

        /**
         * Overrides `Polymer.PropertyAccessors` implementation to provide a
         * more efficient implementation of initializing properties from
         * the prototype on the instance.
         *
         * @override
         * @param {Object} props Properties to initialize on the prototype
         */

      }, {
        key: '_initializeProtoProperties',
        value: function _initializeProtoProperties(props) {
          this.__data = Object.create(props);
          this.__dataPending = Object.create(props);
          this.__dataOld = {};
        }

        /**
         * Overrides `Polymer.PropertyAccessors` implementation to avoid setting
         * `_setProperty`'s `shouldNotify: true`.
         *
         * @override
         * @param {Object} props Properties to initialize on the instance
         */

      }, {
        key: '_initializeInstanceProperties',
        value: function _initializeInstanceProperties(props) {
          var readOnly = this[TYPES.READ_ONLY];
          for (var prop in props) {
            if (!readOnly || !readOnly[prop]) {
              this.__dataPending = this.__dataPending || {};
              this.__dataOld = this.__dataOld || {};
              this.__data[prop] = this.__dataPending[prop] = props[prop];
            }
          }
        }

        // Prototype setup ----------------------------------------

        /**
         * Equivalent to static `addPropertyEffect` API but can be called on
         * an instance to add effects at runtime.  See that method for
         * full API docs.
         *
         * @param {string} property Property that should trigger the effect
         * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES
         * @param {Object=} effect Effect metadata object
         * @protected
         */

      }, {
        key: '_addPropertyEffect',
        value: function _addPropertyEffect(property, type, effect) {
          this._createPropertyAccessor(property, type == TYPES.READ_ONLY);
          // effects are accumulated into arrays per property based on type
          var effects = ensureOwnEffectMap(this, type)[property];
          if (!effects) {
            effects = this[type][property] = [];
          }
          effects.push(effect);
        }

        /**
         * Removes the given property effect.
         *
         * @param {string} property Property the effect was associated with
         * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES
         * @param {Object=} effect Effect metadata object to remove
         */

      }, {
        key: '_removePropertyEffect',
        value: function _removePropertyEffect(property, type, effect) {
          var effects = ensureOwnEffectMap(this, type)[property];
          var idx = effects.indexOf(effect);
          if (idx >= 0) {
            effects.splice(idx, 1);
          }
        }

        /**
         * Returns whether the current prototype/instance has a property effect
         * of a certain type.
         *
         * @param {string} property Property name
         * @param {string=} type Effect type, from this.PROPERTY_EFFECT_TYPES
         * @return {boolean} True if the prototype/instance has an effect of this type
         * @protected
         */

      }, {
        key: '_hasPropertyEffect',
        value: function _hasPropertyEffect(property, type) {
          var effects = this[type];
          return Boolean(effects && effects[property]);
        }

        /**
         * Returns whether the current prototype/instance has a "read only"
         * accessor for the given property.
         *
         * @param {string} property Property name
         * @return {boolean} True if the prototype/instance has an effect of this type
         * @protected
         */

      }, {
        key: '_hasReadOnlyEffect',
        value: function _hasReadOnlyEffect(property) {
          return this._hasPropertyEffect(property, TYPES.READ_ONLY);
        }

        /**
         * Returns whether the current prototype/instance has a "notify"
         * property effect for the given property.
         *
         * @param {string} property Property name
         * @return {boolean} True if the prototype/instance has an effect of this type
         * @protected
         */

      }, {
        key: '_hasNotifyEffect',
        value: function _hasNotifyEffect(property) {
          return this._hasPropertyEffect(property, TYPES.NOTIFY);
        }

        /**
         * Returns whether the current prototype/instance has a "reflect to attribute"
         * property effect for the given property.
         *
         * @param {string} property Property name
         * @return {boolean} True if the prototype/instance has an effect of this type
         * @protected
         */

      }, {
        key: '_hasReflectEffect',
        value: function _hasReflectEffect(property) {
          return this._hasPropertyEffect(property, TYPES.REFLECT);
        }

        /**
         * Returns whether the current prototype/instance has a "computed"
         * property effect for the given property.
         *
         * @param {string} property Property name
         * @return {boolean} True if the prototype/instance has an effect of this type
         * @protected
         */

      }, {
        key: '_hasComputedEffect',
        value: function _hasComputedEffect(property) {
          return this._hasPropertyEffect(property, TYPES.COMPUTE);
        }

        // Runtime ----------------------------------------

        /**
         * Sets a pending property or path.  If the root property of the path in
         * question had no accessor, the path is set, otherwise it is enqueued
         * via `_setPendingProperty`.
         *
         * This function isolates relatively expensive functionality necessary
         * for the public API (`set`, `setProperties`, `notifyPath`, and property
         * change listeners via {{...}} bindings), such that it is only done
         * when paths enter the system, and not at every propagation step.  It
         * also sets a `__dataHasPaths` flag on the instance which is used to
         * fast-path slower path-matching code in the property effects host paths.
         *
         * `path` can be a path string or array of path parts as accepted by the
         * public API.
         *
         * @param {string | !Array<number|string>} path Path to set
         * @param {*} value Value to set
         * @param {boolean=} shouldNotify Set to true if this change should
         *  cause a property notification event dispatch
         * @param {boolean=} isPathNotification If the path being set is a path
         *   notification of an already changed value, as opposed to a request
         *   to set and notify the change.  In the latter `false` case, a dirty
         *   check is performed and then the value is set to the path before
         *   enqueuing the pending property change.
         * @return {boolean} Returns true if the property/path was enqueued in
         *   the pending changes bag.
         * @protected
         */

      }, {
        key: '_setPendingPropertyOrPath',
        value: function _setPendingPropertyOrPath(path, value, shouldNotify, isPathNotification) {
          if (isPathNotification || Polymer.Path.root(Array.isArray(path) ? path[0] : path) !== path) {
            // Dirty check changes being set to a path against the actual object,
            // since this is the entry point for paths into the system; from here
            // the only dirty checks are against the `__dataTemp` cache to prevent
            // duplicate work in the same turn only. Note, if this was a notification
            // of a change already set to a path (isPathNotification: true),
            // we always let the change through and skip the `set` since it was
            // already dirty checked at the point of entry and the underlying
            // object has already been updated
            if (!isPathNotification) {
              var old = Polymer.Path.get(this, path);
              path = /** @type {string} */Polymer.Path.set(this, path, value);
              // Use property-accessor's simpler dirty check
              if (!path || !_get(PropertyEffects.prototype.__proto__ || Object.getPrototypeOf(PropertyEffects.prototype), '_shouldPropertyChange', this).call(this, path, value, old)) {
                return false;
              }
            }
            this.__dataHasPaths = true;
            if (this._setPendingProperty( /**@type{string}*/path, value, shouldNotify)) {
              computeLinkedPaths(this, path, value);
              return true;
            }
          } else {
            if (this.__dataHasAccessor && this.__dataHasAccessor[path]) {
              return this._setPendingProperty( /**@type{string}*/path, value, shouldNotify);
            } else {
              this[path] = value;
            }
          }
          return false;
        }

        /**
         * Applies a value to a non-Polymer element/node's property.
         *
         * The implementation makes a best-effort at binding interop:
         * Some native element properties have side-effects when
         * re-setting the same value (e.g. setting `<input>.value` resets the
         * cursor position), so we do a dirty-check before setting the value.
         * However, for better interop with non-Polymer custom elements that
         * accept objects, we explicitly re-set object changes coming from the
         * Polymer world (which may include deep object changes without the
         * top reference changing), erring on the side of providing more
         * information.
         *
         * Users may override this method to provide alternate approaches.
         *
         * @param {Node} node The node to set a property on
         * @param {string} prop The property to set
         * @param {*} value The value to set
         * @protected
         */

      }, {
        key: '_setUnmanagedPropertyToNode',
        value: function _setUnmanagedPropertyToNode(node, prop, value) {
          // It is a judgment call that resetting primitives is
          // "bad" and resettings objects is also "good"; alternatively we could
          // implement a whitelist of tag & property values that should never
          // be reset (e.g. <input>.value && <select>.value)
          if (value !== node[prop] || (typeof value === 'undefined' ? 'undefined' : _typeof(value)) == 'object') {
            node[prop] = value;
          }
        }

        /**
         * Overrides the `PropertyAccessors` implementation to introduce special
         * dirty check logic depending on the property & value being set:
         *
         * 1. Any value set to a path (e.g. 'obj.prop': 42 or 'obj.prop': {...})
         *    Stored in `__dataTemp`, dirty checked against `__dataTemp`
         * 2. Object set to simple property (e.g. 'prop': {...})
         *    Stored in `__dataTemp` and `__data`, dirty checked against
         *    `__dataTemp` by default implementation of `_shouldPropertyChange`
         * 3. Primitive value set to simple property (e.g. 'prop': 42)
         *    Stored in `__data`, dirty checked against `__data`
         *
         * The dirty-check is important to prevent cycles due to two-way
         * notification, but paths and objects are only dirty checked against any
         * previous value set during this turn via a "temporary cache" that is
         * cleared when the last `_propertiesChaged` exits. This is so:
         * a. any cached array paths (e.g. 'array.3.prop') may be invalidated
         *    due to array mutations like shift/unshift/splice; this is fine
         *    since path changes are dirty-checked at user entry points like `set`
         * b. dirty-checking for objects only lasts one turn to allow the user
         *    to mutate the object in-place and re-set it with the same identity
         *    and have all sub-properties re-propagated in a subsequent turn.
         *
         * The temp cache is not necessarily sufficient to prevent invalid array
         * paths, since a splice can happen during the same turn (with pathological
         * user code); we could introduce a "fixup" for temporarily cached array
         * paths if needed: https://github.com/Polymer/polymer/issues/4227
         *
         * @param {string} property Name of the property
         * @param {*} value Value to set
         * @param {boolean=} shouldNotify True if property should fire notification
         *   event (applies only for `notify: true` properties)
         * @return {boolean} Returns true if the property changed
         * @override
         */

      }, {
        key: '_setPendingProperty',
        value: function _setPendingProperty(property, value, shouldNotify) {
          var isPath = this.__dataHasPaths && Polymer.Path.isPath(property);
          var prevProps = isPath ? this.__dataTemp : this.__data;
          if (this._shouldPropertyChange(property, value, prevProps[property])) {
            if (!this.__dataPending) {
              this.__dataPending = {};
              this.__dataOld = {};
            }
            // Ensure old is captured from the last turn
            if (!(property in this.__dataOld)) {
              this.__dataOld[property] = this.__data[property];
            }
            // Paths are stored in temporary cache (cleared at end of turn),
            // which is used for dirty-checking, all others stored in __data
            if (isPath) {
              this.__dataTemp[property] = value;
            } else {
              this.__data[property] = value;
            }
            // All changes go into pending property bag, passed to _propertiesChanged
            this.__dataPending[property] = value;
            // Track properties that should notify separately
            if (isPath || this[TYPES.NOTIFY] && this[TYPES.NOTIFY][property]) {
              this.__dataToNotify = this.__dataToNotify || {};
              this.__dataToNotify[property] = shouldNotify;
            }
            return true;
          }
          return false;
        }

        /**
         * Overrides base implementation to ensure all accessors set `shouldNotify`
         * to true, for per-property notification tracking.
         *
         * @override
         */

      }, {
        key: '_setProperty',
        value: function _setProperty(property, value) {
          if (this._setPendingProperty(property, value, true)) {
            this._invalidateProperties();
          }
        }

        /**
         * Overrides `PropertyAccessor`'s default async queuing of
         * `_propertiesChanged`: if `__dataReady` is false (has not yet been
         * manually flushed), the function no-ops; otherwise flushes
         * `_propertiesChanged` synchronously.
         *
         * @override
         */

      }, {
        key: '_invalidateProperties',
        value: function _invalidateProperties() {
          if (this.__dataReady) {
            this._flushProperties();
          }
        }

        /**
         * Enqueues the given client on a list of pending clients, whose
         * pending property changes can later be flushed via a call to
         * `_flushClients`.
         *
         * @param {Object} client PropertyEffects client to enqueue
         * @protected
         */

      }, {
        key: '_enqueueClient',
        value: function _enqueueClient(client) {
          this.__dataPendingClients = this.__dataPendingClients || [];
          if (client !== this) {
            this.__dataPendingClients.push(client);
          }
        }

        /**
         * Flushes any clients previously enqueued via `_enqueueClient`, causing
         * their `_flushProperties` method to run.
         *
         * @protected
         */

      }, {
        key: '_flushClients',
        value: function _flushClients() {
          if (!this.__dataClientsReady) {
            this.__dataClientsReady = true;
            this._readyClients();
            // Override point where accessors are turned on; importantly,
            // this is after clients have fully readied, providing a guarantee
            // that any property effects occur only after all clients are ready.
            this.__dataReady = true;
          } else {
            this.__enableOrFlushClients();
          }
        }

        // NOTE: We ensure clients either enable or flush as appropriate. This
        // handles two corner cases:
        // (1) clients flush properly when connected/enabled before the host
        // enables; e.g.
        //   (a) Templatize stamps with no properties and does not flush and
        //   (b) the instance is inserted into dom and
        //   (c) then the instance flushes.
        // (2) clients enable properly when not connected/enabled when the host
        // flushes; e.g.
        //   (a) a template is runtime stamped and not yet connected/enabled
        //   (b) a host sets a property, causing stamped dom to flush
        //   (c) the stamped dom enables.

      }, {
        key: '__enableOrFlushClients',
        value: function __enableOrFlushClients() {
          var clients = this.__dataPendingClients;
          if (clients) {
            this.__dataPendingClients = null;
            for (var i = 0; i < clients.length; i++) {
              var client = clients[i];
              if (!client.__dataEnabled) {
                client._enableProperties();
              } else if (client.__dataPending) {
                client._flushProperties();
              }
            }
          }
        }

        /**
         * Perform any initial setup on client dom. Called before the first
         * `_flushProperties` call on client dom and before any element
         * observers are called.
         *
         * @protected
         */

      }, {
        key: '_readyClients',
        value: function _readyClients() {
          this.__enableOrFlushClients();
        }

        /**
         * Sets a bag of property changes to this instance, and
         * synchronously processes all effects of the properties as a batch.
         *
         * Property names must be simple properties, not paths.  Batched
         * path propagation is not supported.
         *
         * @param {Object} props Bag of one or more key-value pairs whose key is
         *   a property and value is the new value to set for that property.
         * @param {boolean=} setReadOnly When true, any private values set in
         *   `props` will be set. By default, `setProperties` will not set
         *   `readOnly: true` root properties.
         * @public
         */

      }, {
        key: 'setProperties',
        value: function setProperties(props, setReadOnly) {
          for (var path in props) {
            if (setReadOnly || !this[TYPES.READ_ONLY] || !this[TYPES.READ_ONLY][path]) {
              //TODO(kschaaf): explicitly disallow paths in setProperty?
              // wildcard observers currently only pass the first changed path
              // in the `info` object, and you could do some odd things batching
              // paths, e.g. {'foo.bar': {...}, 'foo': null}
              this._setPendingPropertyOrPath(path, props[path], true);
            }
          }
          this._invalidateProperties();
        }

        /**
         * Overrides `PropertyAccessors` so that property accessor
         * side effects are not enabled until after client dom is fully ready.
         * Also calls `_flushClients` callback to ensure client dom is enabled
         * that was not enabled as a result of flushing properties.
         *
         * @override
         */

      }, {
        key: 'ready',
        value: function ready() {
          // It is important that `super.ready()` is not called here as it
          // immediately turns on accessors. Instead, we wait until `readyClients`
          // to enable accessors to provide a guarantee that clients are ready
          // before processing any accessors side effects.
          this._flushProperties();
          // If no data was pending, `_flushProperties` will not `flushClients`
          // so ensure this is done.
          if (!this.__dataClientsReady) {
            this._flushClients();
          }
          // Before ready, client notifications do not trigger _flushProperties.
          // Therefore a flush is necessary here if data has been set.
          if (this.__dataPending) {
            this._flushProperties();
          }
        }

        /**
         * Implements `PropertyAccessors`'s properties changed callback.
         *
         * Runs each class of effects for the batch of changed properties in
         * a specific order (compute, propagate, reflect, observe, notify).
         *
         * @override
         */

      }, {
        key: '_propertiesChanged',
        value: function _propertiesChanged(currentProps, changedProps, oldProps) {
          // ----------------------------
          // let c = Object.getOwnPropertyNames(changedProps || {});
          // window.debug && console.group(this.localName + '#' + this.id + ': ' + c);
          // if (window.debug) { debugger; }
          // ----------------------------
          var hasPaths = this.__dataHasPaths;
          this.__dataHasPaths = false;
          // Compute properties
          runComputedEffects(this, changedProps, oldProps, hasPaths);
          // Clear notify properties prior to possible reentry (propagate, observe),
          // but after computing effects have a chance to add to them
          var notifyProps = this.__dataToNotify;
          this.__dataToNotify = null;
          // Propagate properties to clients
          this._propagatePropertyChanges(changedProps, oldProps, hasPaths);
          // Flush clients
          this._flushClients();
          // Reflect properties
          runEffects(this, this[TYPES.REFLECT], changedProps, oldProps, hasPaths);
          // Observe properties
          runEffects(this, this[TYPES.OBSERVE], changedProps, oldProps, hasPaths);
          // Notify properties to host
          if (notifyProps) {
            runNotifyEffects(this, notifyProps, changedProps, oldProps, hasPaths);
          }
          // Clear temporary cache at end of turn
          if (this.__dataCounter == 1) {
            this.__dataTemp = {};
          }
          // ----------------------------
          // window.debug && console.groupEnd(this.localName + '#' + this.id + ': ' + c);
          // ----------------------------
        }

        /**
         * Called to propagate any property changes to stamped template nodes
         * managed by this element.
         *
         * @param {Object} changedProps Bag of changed properties
         * @param {Object} oldProps Bag of previous values for changed properties
         * @param {boolean} hasPaths True with `props` contains one or more paths
         * @protected
         */

      }, {
        key: '_propagatePropertyChanges',
        value: function _propagatePropertyChanges(changedProps, oldProps, hasPaths) {
          if (this[TYPES.PROPAGATE]) {
            runEffects(this, this[TYPES.PROPAGATE], changedProps, oldProps, hasPaths);
          }
          var templateInfo = this.__templateInfo;
          while (templateInfo) {
            runEffects(this, templateInfo.propertyEffects, changedProps, oldProps, hasPaths, templateInfo.nodeList);
            templateInfo = templateInfo.nextTemplateInfo;
          }
        }

        /**
         * Aliases one data path as another, such that path notifications from one
         * are routed to the other.
         *
         * @param {string | !Array<string|number>} to Target path to link.
         * @param {string | !Array<string|number>} from Source path to link.
         * @public
         */

      }, {
        key: 'linkPaths',
        value: function linkPaths(to, from) {
          to = Polymer.Path.normalize(to);
          from = Polymer.Path.normalize(from);
          this.__dataLinkedPaths = this.__dataLinkedPaths || {};
          this.__dataLinkedPaths[to] = from;
        }

        /**
         * Removes a data path alias previously established with `_linkPaths`.
         *
         * Note, the path to unlink should be the target (`to`) used when
         * linking the paths.
         *
         * @param {string | !Array<string|number>} path Target path to unlink.
         * @public
         */

      }, {
        key: 'unlinkPaths',
        value: function unlinkPaths(path) {
          path = Polymer.Path.normalize(path);
          if (this.__dataLinkedPaths) {
            delete this.__dataLinkedPaths[path];
          }
        }

        /**
         * Notify that an array has changed.
         *
         * Example:
         *
         *     this.items = [ {name: 'Jim'}, {name: 'Todd'}, {name: 'Bill'} ];
         *     ...
         *     this.items.splice(1, 1, {name: 'Sam'});
         *     this.items.push({name: 'Bob'});
         *     this.notifySplices('items', [
         *       { index: 1, removed: [{name: 'Todd'}], addedCount: 1, obect: this.items, type: 'splice' },
         *       { index: 3, removed: [], addedCount: 1, object: this.items, type: 'splice'}
         *     ]);
         *
         * @param {string} path Path that should be notified.
         * @param {Array} splices Array of splice records indicating ordered
         *   changes that occurred to the array. Each record should have the
         *   following fields:
         *    * index: index at which the change occurred
         *    * removed: array of items that were removed from this index
         *    * addedCount: number of new items added at this index
         *    * object: a reference to the array in question
         *    * type: the string literal 'splice'
         *
         *   Note that splice records _must_ be normalized such that they are
         *   reported in index order (raw results from `Object.observe` are not
         *   ordered and must be normalized/merged before notifying).
         * @public
        */

      }, {
        key: 'notifySplices',
        value: function notifySplices(path, splices) {
          var info = { path: '' };
          var array = /** @type {Array} */Polymer.Path.get(this, path, info);
          _notifySplices(this, array, info.path, splices);
        }

        /**
         * Convenience method for reading a value from a path.
         *
         * Note, if any part in the path is undefined, this method returns
         * `undefined` (this method does not throw when dereferencing undefined
         * paths).
         *
         * @param {(string|!Array<(string|number)>)} path Path to the value
         *   to read.  The path may be specified as a string (e.g. `foo.bar.baz`)
         *   or an array of path parts (e.g. `['foo.bar', 'baz']`).  Note that
         *   bracketed expressions are not supported; string-based path parts
         *   *must* be separated by dots.  Note that when dereferencing array
         *   indices, the index may be used as a dotted part directly
         *   (e.g. `users.12.name` or `['users', 12, 'name']`).
         * @param {Object=} root Root object from which the path is evaluated.
         * @return {*} Value at the path, or `undefined` if any part of the path
         *   is undefined.
         * @public
         */

      }, {
        key: 'get',
        value: function get(path, root) {
          return Polymer.Path.get(root || this, path);
        }

        /**
         * Convenience method for setting a value to a path and notifying any
         * elements bound to the same path.
         *
         * Note, if any part in the path except for the last is undefined,
         * this method does nothing (this method does not throw when
         * dereferencing undefined paths).
         *
         * @param {(string|!Array<(string|number)>)} path Path to the value
         *   to write.  The path may be specified as a string (e.g. `'foo.bar.baz'`)
         *   or an array of path parts (e.g. `['foo.bar', 'baz']`).  Note that
         *   bracketed expressions are not supported; string-based path parts
         *   *must* be separated by dots.  Note that when dereferencing array
         *   indices, the index may be used as a dotted part directly
         *   (e.g. `'users.12.name'` or `['users', 12, 'name']`).
         * @param {*} value Value to set at the specified path.
         * @param {Object=} root Root object from which the path is evaluated.
         *   When specified, no notification will occur.
         * @public
        */

      }, {
        key: 'set',
        value: function set(path, value, root) {
          if (root) {
            Polymer.Path.set(root, path, value);
          } else {
            if (!this[TYPES.READ_ONLY] || !this[TYPES.READ_ONLY][/** @type {string} */path]) {
              if (this._setPendingPropertyOrPath(path, value, true)) {
                this._invalidateProperties();
              }
            }
          }
        }

        /**
         * Adds items onto the end of the array at the path specified.
         *
         * The arguments after `path` and return value match that of
         * `Array.prototype.push`.
         *
         * This method notifies other paths to the same array that a
         * splice occurred to the array.
         *
         * @param {string} path Path to array.
         * @param {...*} items Items to push onto array
         * @return {number} New length of the array.
         * @public
         */

      }, {
        key: 'push',
        value: function push(path) {
          var info = { path: '' };
          var array = /** @type {Array}*/Polymer.Path.get(this, path, info);
          var len = array.length;

          for (var _len = arguments.length, items = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            items[_key - 1] = arguments[_key];
          }

          var ret = array.push.apply(array, items);
          if (items.length) {
            notifySplice(this, array, info.path, len, items.length, []);
          }
          return ret;
        }

        /**
         * Removes an item from the end of array at the path specified.
         *
         * The arguments after `path` and return value match that of
         * `Array.prototype.pop`.
         *
         * This method notifies other paths to the same array that a
         * splice occurred to the array.
         *
         * @param {string} path Path to array.
         * @return {*} Item that was removed.
         * @public
         */

      }, {
        key: 'pop',
        value: function pop(path) {
          var info = { path: '' };
          var array = /** @type {Array} */Polymer.Path.get(this, path, info);
          var hadLength = Boolean(array.length);
          var ret = array.pop();
          if (hadLength) {
            notifySplice(this, array, info.path, array.length, 0, [ret]);
          }
          return ret;
        }

        /**
         * Starting from the start index specified, removes 0 or more items
         * from the array and inserts 0 or more new items in their place.
         *
         * The arguments after `path` and return value match that of
         * `Array.prototype.splice`.
         *
         * This method notifies other paths to the same array that a
         * splice occurred to the array.
         *
         * @param {string} path Path to array.
         * @param {number} start Index from which to start removing/inserting.
         * @param {number} deleteCount Number of items to remove.
         * @param {...*} items Items to insert into array.
         * @return {Array} Array of removed items.
         * @public
         */

      }, {
        key: 'splice',
        value: function splice(path, start, deleteCount) {
          var info = { path: '' };
          var array = /** @type {Array} */Polymer.Path.get(this, path, info);
          // Normalize fancy native splice handling of crazy start values
          if (start < 0) {
            start = array.length - Math.floor(-start);
          } else {
            start = Math.floor(start);
          }
          if (!start) {
            start = 0;
          }

          for (var _len2 = arguments.length, items = Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {
            items[_key2 - 3] = arguments[_key2];
          }

          var ret = array.splice.apply(array, [start, deleteCount].concat(items));
          if (items.length || ret.length) {
            notifySplice(this, array, info.path, start, items.length, ret);
          }
          return ret;
        }

        /**
         * Removes an item from the beginning of array at the path specified.
         *
         * The arguments after `path` and return value match that of
         * `Array.prototype.pop`.
         *
         * This method notifies other paths to the same array that a
         * splice occurred to the array.
         *
         * @param {string} path Path to array.
         * @return {*} Item that was removed.
         * @public
         */

      }, {
        key: 'shift',
        value: function shift(path) {
          var info = { path: '' };
          var array = /** @type {Array} */Polymer.Path.get(this, path, info);
          var hadLength = Boolean(array.length);
          var ret = array.shift();
          if (hadLength) {
            notifySplice(this, array, info.path, 0, 0, [ret]);
          }
          return ret;
        }

        /**
         * Adds items onto the beginning of the array at the path specified.
         *
         * The arguments after `path` and return value match that of
         * `Array.prototype.push`.
         *
         * This method notifies other paths to the same array that a
         * splice occurred to the array.
         *
         * @param {string} path Path to array.
         * @param {...*} items Items to insert info array
         * @return {number} New length of the array.
         * @public
         */

      }, {
        key: 'unshift',
        value: function unshift(path) {
          var info = { path: '' };
          var array = /** @type {Array} */Polymer.Path.get(this, path, info);

          for (var _len3 = arguments.length, items = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
            items[_key3 - 1] = arguments[_key3];
          }

          var ret = array.unshift.apply(array, items);
          if (items.length) {
            notifySplice(this, array, info.path, 0, items.length, []);
          }
          return ret;
        }

        /**
         * Notify that a path has changed.
         *
         * Example:
         *
         *     this.item.user.name = 'Bob';
         *     this.notifyPath('item.user.name');
         *
         * @param {string} path Path that should be notified.
         * @param {*=} value Value at the path (optional).
         * @public
        */

      }, {
        key: 'notifyPath',
        value: function notifyPath(path, value) {
          /** @type {string} */
          var propPath = void 0;
          if (arguments.length == 1) {
            // Get value if not supplied
            var info = { path: '' };
            value = Polymer.Path.get(this, path, info);
            propPath = info.path;
          } else if (Array.isArray(path)) {
            // Normalize path if needed
            propPath = Polymer.Path.normalize(path);
          } else {
            propPath = /** @type{string} */path;
          }
          if (this._setPendingPropertyOrPath(propPath, value, true, true)) {
            this._invalidateProperties();
          }
        }

        /**
         * Equivalent to static `createReadOnlyProperty` API but can be called on
         * an instance to add effects at runtime.  See that method for
         * full API docs.
         *
         * @param {string} property Property name
         * @param {boolean=} protectedSetter Creates a custom protected setter
         *   when `true`.
         * @protected
         */

      }, {
        key: '_createReadOnlyProperty',
        value: function _createReadOnlyProperty(property, protectedSetter) {
          this._addPropertyEffect(property, TYPES.READ_ONLY);
          if (protectedSetter) {
            this['_set' + upper(property)] = /** @this {PropertyEffects} */function (value) {
              this._setProperty(property, value);
            };
          }
        }

        /**
         * Equivalent to static `createPropertyObserver` API but can be called on
         * an instance to add effects at runtime.  See that method for
         * full API docs.
         *
         * @param {string} property Property name
         * @param {string} methodName Name of observer method to call
         * @param {boolean=} dynamicFn Whether the method name should be included as
         *   a dependency to the effect.
         * @protected
         */

      }, {
        key: '_createPropertyObserver',
        value: function _createPropertyObserver(property, methodName, dynamicFn) {
          var info = { property: property, methodName: methodName, dynamicFn: Boolean(dynamicFn) };
          this._addPropertyEffect(property, TYPES.OBSERVE, {
            fn: runObserverEffect, info: info, trigger: { name: property }
          });
          if (dynamicFn) {
            this._addPropertyEffect(methodName, TYPES.OBSERVE, {
              fn: runObserverEffect, info: info, trigger: { name: methodName }
            });
          }
        }

        /**
         * Equivalent to static `createMethodObserver` API but can be called on
         * an instance to add effects at runtime.  See that method for
         * full API docs.
         *
         * @param {string} expression Method expression
         * @param {boolean|Object=} dynamicFn Boolean or object map indicating
         *   whether method names should be included as a dependency to the effect.
         * @protected
         */

      }, {
        key: '_createMethodObserver',
        value: function _createMethodObserver(expression, dynamicFn) {
          var sig = parseMethod(expression);
          if (!sig) {
            throw new Error("Malformed observer expression '" + expression + "'");
          }
          createMethodEffect(this, sig, TYPES.OBSERVE, runMethodEffect, null, dynamicFn);
        }

        /**
         * Equivalent to static `createNotifyingProperty` API but can be called on
         * an instance to add effects at runtime.  See that method for
         * full API docs.
         *
         * @param {string} property Property name
         * @protected
         */

      }, {
        key: '_createNotifyingProperty',
        value: function _createNotifyingProperty(property) {
          this._addPropertyEffect(property, TYPES.NOTIFY, {
            fn: runNotifyEffect,
            info: {
              eventName: CaseMap.camelToDashCase(property) + '-changed',
              property: property
            }
          });
        }

        /**
         * Equivalent to static `createReflectedProperty` API but can be called on
         * an instance to add effects at runtime.  See that method for
         * full API docs.
         *
         * @param {string} property Property name
         * @protected
         */

      }, {
        key: '_createReflectedProperty',
        value: function _createReflectedProperty(property) {
          var attr = CaseMap.camelToDashCase(property);
          if (attr[0] === '-') {
            console.warn('Property ' + property + ' cannot be reflected to attribute ' + attr + ' because "-" is not a valid starting attribute name. Use a lowercase first letter for the property thisead.');
          } else {
            this._addPropertyEffect(property, TYPES.REFLECT, {
              fn: runReflectEffect,
              info: {
                attrName: attr
              }
            });
          }
        }

        /**
         * Equivalent to static `createComputedProperty` API but can be called on
         * an instance to add effects at runtime.  See that method for
         * full API docs.
         *
         * @param {string} property Name of computed property to set
         * @param {string} expression Method expression
         * @param {boolean|Object=} dynamicFn Boolean or object map indicating
         *   whether method names should be included as a dependency to the effect.
         * @protected
         */

      }, {
        key: '_createComputedProperty',
        value: function _createComputedProperty(property, expression, dynamicFn) {
          var sig = parseMethod(expression);
          if (!sig) {
            throw new Error("Malformed computed expression '" + expression + "'");
          }
          createMethodEffect(this, sig, TYPES.COMPUTE, runComputedEffect, property, dynamicFn);
        }

        // -- static class methods ------------

        /**
         * Ensures an accessor exists for the specified property, and adds
         * to a list of "property effects" that will run when the accessor for
         * the specified property is set.  Effects are grouped by "type", which
         * roughly corresponds to a phase in effect processing.  The effect
         * metadata should be in the following form:
         *
         *   {
         *     fn: effectFunction, // Reference to function to call to perform effect
         *     info: { ... }       // Effect metadata passed to function
         *     trigger: {          // Optional triggering metadata; if not provided
         *       name: string      // the property is treated as a wildcard
         *       structured: boolean
         *       wildcard: boolean
         *     }
         *   }
         *
         * Effects are called from `_propertiesChanged` in the following order by
         * type:
         *
         * 1. COMPUTE
         * 2. PROPAGATE
         * 3. REFLECT
         * 4. OBSERVE
         * 5. NOTIFY
         *
         * Effect functions are called with the following signature:
         *
         *   effectFunction(inst, path, props, oldProps, info, hasPaths)
         *
         * @param {string} property Property that should trigger the effect
         * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES
         * @param {Object=} effect Effect metadata object
         * @protected
         */

      }, {
        key: '_bindTemplate',


        // -- binding ----------------------------------------------

        /**
         * Equivalent to static `bindTemplate` API but can be called on
         * an instance to add effects at runtime.  See that method for
         * full API docs.
         *
         * This method may be called on the prototype (for prototypical template
         * binding, to avoid creating accessors every instance) once per prototype,
         * and will be called with `runtimeBinding: true` by `_stampTemplate` to
         * create and link an instance of the template metadata associated with a
         * particular stamping.
         *
         * @param {HTMLTemplateElement} template Template containing binding
         *   bindings
         * @param {boolean=} instanceBinding When false (default), performs
         *   "prototypical" binding of the template and overwrites any previously
         *   bound template for the class. When true (as passed from
         *   `_stampTemplate`), the template info is instanced and linked into
         *   the list of bound templates.
         * @return {!TemplateInfo} Template metadata object; for `runtimeBinding`,
         *   this is an instance of the prototypical template info
         * @protected
         */
        value: function _bindTemplate(template, instanceBinding) {
          var templateInfo = this.constructor._parseTemplate(template);
          var wasPreBound = this.__templateInfo == templateInfo;
          // Optimization: since this is called twice for proto-bound templates,
          // don't attempt to recreate accessors if this template was pre-bound
          if (!wasPreBound) {
            for (var prop in templateInfo.propertyEffects) {
              this._createPropertyAccessor(prop);
            }
          }
          if (instanceBinding) {
            // For instance-time binding, create instance of template metadata
            // and link into list of templates if necessary
            templateInfo = /** @type {!TemplateInfo} */Object.create(templateInfo);
            templateInfo.wasPreBound = wasPreBound;
            if (!wasPreBound && this.__templateInfo) {
              var last = this.__templateInfoLast || this.__templateInfo;
              this.__templateInfoLast = last.nextTemplateInfo = templateInfo;
              templateInfo.previousTemplateInfo = last;
              return templateInfo;
            }
          }
          return this.__templateInfo = templateInfo;
        }

        /**
         * Adds a property effect to the given template metadata, which is run
         * at the "propagate" stage of `_propertiesChanged` when the template
         * has been bound to the element via `_bindTemplate`.
         *
         * The `effect` object should match the format in `_addPropertyEffect`.
         *
         * @param {Object} templateInfo Template metadata to add effect to
         * @param {string} prop Property that should trigger the effect
         * @param {Object=} effect Effect metadata object
         * @protected
         */

      }, {
        key: '_stampTemplate',


        /**
         * Stamps the provided template and performs instance-time setup for
         * Polymer template features, including data bindings, declarative event
         * listeners, and the `this.$` map of `id`'s to nodes.  A document fragment
         * is returned containing the stamped DOM, ready for insertion into the
         * DOM.
         *
         * This method may be called more than once; however note that due to
         * `shadycss` polyfill limitations, only styles from templates prepared
         * using `ShadyCSS.prepareTemplate` will be correctly polyfilled (scoped
         * to the shadow root and support CSS custom properties), and note that
         * `ShadyCSS.prepareTemplate` may only be called once per element. As such,
         * any styles required by in runtime-stamped templates must be included
         * in the main element template.
         *
         * @param {!HTMLTemplateElement} template Template to stamp
         * @return {!StampedTemplate} Cloned template content
         * @override
         * @protected
         */
        value: function _stampTemplate(template) {
          // Ensures that created dom is `_enqueueClient`'d to this element so
          // that it can be flushed on next call to `_flushProperties`
          hostStack.beginHosting(this);
          var dom = _get(PropertyEffects.prototype.__proto__ || Object.getPrototypeOf(PropertyEffects.prototype), '_stampTemplate', this).call(this, template);
          hostStack.endHosting(this);
          var templateInfo = /** @type {!TemplateInfo} */this._bindTemplate(template, true);
          // Add template-instance-specific data to instanced templateInfo
          templateInfo.nodeList = dom.nodeList;
          // Capture child nodes to allow unstamping of non-prototypical templates
          if (!templateInfo.wasPreBound) {
            var nodes = templateInfo.childNodes = [];
            for (var n = dom.firstChild; n; n = n.nextSibling) {
              nodes.push(n);
            }
          }
          dom.templateInfo = templateInfo;
          // Setup compound storage, 2-way listeners, and dataHost for bindings
          setupBindings(this, templateInfo);
          // Flush properties into template nodes if already booted
          if (this.__dataReady) {
            runEffects(this, templateInfo.propertyEffects, this.__data, null, false, templateInfo.nodeList);
          }
          return dom;
        }

        /**
         * Removes and unbinds the nodes previously contained in the provided
         * DocumentFragment returned from `_stampTemplate`.
         *
         * @param {!StampedTemplate} dom DocumentFragment previously returned
         *   from `_stampTemplate` associated with the nodes to be removed
         * @protected
         */

      }, {
        key: '_removeBoundDom',
        value: function _removeBoundDom(dom) {
          // Unlink template info
          var templateInfo = dom.templateInfo;
          if (templateInfo.previousTemplateInfo) {
            templateInfo.previousTemplateInfo.nextTemplateInfo = templateInfo.nextTemplateInfo;
          }
          if (templateInfo.nextTemplateInfo) {
            templateInfo.nextTemplateInfo.previousTemplateInfo = templateInfo.previousTemplateInfo;
          }
          if (this.__templateInfoLast == templateInfo) {
            this.__templateInfoLast = templateInfo.previousTemplateInfo;
          }
          templateInfo.previousTemplateInfo = templateInfo.nextTemplateInfo = null;
          // Remove stamped nodes
          var nodes = templateInfo.childNodes;
          for (var i = 0; i < nodes.length; i++) {
            var node = nodes[i];
            node.parentNode.removeChild(node);
          }
        }

        /**
         * Overrides default `TemplateStamp` implementation to add support for
         * parsing bindings from `TextNode`'s' `textContent`.  A `bindings`
         * array is added to `nodeInfo` and populated with binding metadata
         * with information capturing the binding target, and a `parts` array
         * with one or more metadata objects capturing the source(s) of the
         * binding.
         *
         * @override
         * @param {Node} node Node to parse
         * @param {TemplateInfo} templateInfo Template metadata for current template
         * @param {NodeInfo} nodeInfo Node metadata for current template node
         * @return {boolean} `true` if the visited node added node-specific
         *   metadata to `nodeInfo`
         * @protected
         * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
         */

      }, {
        key: 'PROPERTY_EFFECT_TYPES',
        get: function get() {
          return TYPES;
        }
      }], [{
        key: 'addPropertyEffect',
        value: function addPropertyEffect(property, type, effect) {
          this.prototype._addPropertyEffect(property, type, effect);
        }

        /**
         * Creates a single-property observer for the given property.
         *
         * @param {string} property Property name
         * @param {string} methodName Name of observer method to call
         * @param {boolean=} dynamicFn Whether the method name should be included as
         *   a dependency to the effect.
         * @protected
         */

      }, {
        key: 'createPropertyObserver',
        value: function createPropertyObserver(property, methodName, dynamicFn) {
          this.prototype._createPropertyObserver(property, methodName, dynamicFn);
        }

        /**
         * Creates a multi-property "method observer" based on the provided
         * expression, which should be a string in the form of a normal Javascript
         * function signature: `'methodName(arg1, [..., argn])'`.  Each argument
         * should correspond to a property or path in the context of this
         * prototype (or instance), or may be a literal string or number.
         *
         * @param {string} expression Method expression
         * @param {boolean|Object=} dynamicFn Boolean or object map indicating
         *   whether method names should be included as a dependency to the effect.
         * @protected
         */

      }, {
        key: 'createMethodObserver',
        value: function createMethodObserver(expression, dynamicFn) {
          this.prototype._createMethodObserver(expression, dynamicFn);
        }

        /**
         * Causes the setter for the given property to dispatch `<property>-changed`
         * events to notify of changes to the property.
         *
         * @param {string} property Property name
         * @protected
         */

      }, {
        key: 'createNotifyingProperty',
        value: function createNotifyingProperty(property) {
          this.prototype._createNotifyingProperty(property);
        }

        /**
         * Creates a read-only accessor for the given property.
         *
         * To set the property, use the protected `_setProperty` API.
         * To create a custom protected setter (e.g. `_setMyProp()` for
         * property `myProp`), pass `true` for `protectedSetter`.
         *
         * Note, if the property will have other property effects, this method
         * should be called first, before adding other effects.
         *
         * @param {string} property Property name
         * @param {boolean=} protectedSetter Creates a custom protected setter
         *   when `true`.
         * @protected
         */

      }, {
        key: 'createReadOnlyProperty',
        value: function createReadOnlyProperty(property, protectedSetter) {
          this.prototype._createReadOnlyProperty(property, protectedSetter);
        }

        /**
         * Causes the setter for the given property to reflect the property value
         * to a (dash-cased) attribute of the same name.
         *
         * @param {string} property Property name
         * @protected
         */

      }, {
        key: 'createReflectedProperty',
        value: function createReflectedProperty(property) {
          this.prototype._createReflectedProperty(property);
        }

        /**
         * Creates a computed property whose value is set to the result of the
         * method described by the given `expression` each time one or more
         * arguments to the method changes.  The expression should be a string
         * in the form of a normal Javascript function signature:
         * `'methodName(arg1, [..., argn])'`
         *
         * @param {string} property Name of computed property to set
         * @param {string} expression Method expression
         * @param {boolean|Object=} dynamicFn Boolean or object map indicating whether
         *   method names should be included as a dependency to the effect.
         * @protected
         */

      }, {
        key: 'createComputedProperty',
        value: function createComputedProperty(property, expression, dynamicFn) {
          this.prototype._createComputedProperty(property, expression, dynamicFn);
        }

        /**
         * Parses the provided template to ensure binding effects are created
         * for them, and then ensures property accessors are created for any
         * dependent properties in the template.  Binding effects for bound
         * templates are stored in a linked list on the instance so that
         * templates can be efficiently stamped and unstamped.
         *
         * @param {HTMLTemplateElement} template Template containing binding
         *   bindings
         * @return {Object} Template metadata object
         * @protected
         */

      }, {
        key: 'bindTemplate',
        value: function bindTemplate(template) {
          return this.prototype._bindTemplate(template);
        }
      }, {
        key: '_addTemplatePropertyEffect',
        value: function _addTemplatePropertyEffect(templateInfo, prop, effect) {
          var hostProps = templateInfo.hostProps = templateInfo.hostProps || {};
          hostProps[prop] = true;
          var effects = templateInfo.propertyEffects = templateInfo.propertyEffects || {};
          var propEffects = effects[prop] = effects[prop] || [];
          propEffects.push(effect);
        }
      }, {
        key: '_parseTemplateNode',
        value: function _parseTemplateNode(node, templateInfo, nodeInfo) {
          var noted = _get(PropertyEffects.__proto__ || Object.getPrototypeOf(PropertyEffects), '_parseTemplateNode', this).call(this, node, templateInfo, nodeInfo);
          if (node.nodeType === Node.TEXT_NODE) {
            var parts = this._parseBindings(node.textContent, templateInfo);
            if (parts) {
              // Initialize the textContent with any literal parts
              // NOTE: default to a space here so the textNode remains; some browsers
              // (IE) evacipate an empty textNode following cloneNode/importNode.
              node.textContent = literalFromParts(parts) || ' ';
              addBinding(this, templateInfo, nodeInfo, 'text', 'textContent', parts);
              noted = true;
            }
          }
          return noted;
        }

        /**
         * Overrides default `TemplateStamp` implementation to add support for
         * parsing bindings from attributes.  A `bindings`
         * array is added to `nodeInfo` and populated with binding metadata
         * with information capturing the binding target, and a `parts` array
         * with one or more metadata objects capturing the source(s) of the
         * binding.
         *
         * @override
         * @param {Element} node Node to parse
         * @param {TemplateInfo} templateInfo Template metadata for current template
         * @param {NodeInfo} nodeInfo Node metadata for current template node
         * @return {boolean} `true` if the visited node added node-specific
         *   metadata to `nodeInfo`
         * @protected
         * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
         */

      }, {
        key: '_parseTemplateNodeAttribute',
        value: function _parseTemplateNodeAttribute(node, templateInfo, nodeInfo, name, value) {
          var parts = this._parseBindings(value, templateInfo);
          if (parts) {
            // Attribute or property
            var origName = name;
            var kind = 'property';
            if (name[name.length - 1] == '$') {
              name = name.slice(0, -1);
              kind = 'attribute';
            }
            // Initialize attribute bindings with any literal parts
            var literal = literalFromParts(parts);
            if (literal && kind == 'attribute') {
              node.setAttribute(name, literal);
            }
            // Clear attribute before removing, since IE won't allow removing
            // `value` attribute if it previously had a value (can't
            // unconditionally set '' before removing since attributes with `$`
            // can't be set using setAttribute)
            if (node.localName === 'input' && origName === 'value') {
              node.setAttribute(origName, '');
            }
            // Remove annotation
            node.removeAttribute(origName);
            // Case hackery: attributes are lower-case, but bind targets
            // (properties) are case sensitive. Gambit is to map dash-case to
            // camel-case: `foo-bar` becomes `fooBar`.
            // Attribute bindings are excepted.
            if (kind === 'property') {
              name = Polymer.CaseMap.dashToCamelCase(name);
            }
            addBinding(this, templateInfo, nodeInfo, kind, name, parts, literal);
            return true;
          } else {
            return _get(PropertyEffects.__proto__ || Object.getPrototypeOf(PropertyEffects), '_parseTemplateNodeAttribute', this).call(this, node, templateInfo, nodeInfo, name, value);
          }
        }

        /**
         * Overrides default `TemplateStamp` implementation to add support for
         * binding the properties that a nested template depends on to the template
         * as `_host_<property>`.
         *
         * @override
         * @param {Node} node Node to parse
         * @param {TemplateInfo} templateInfo Template metadata for current template
         * @param {NodeInfo} nodeInfo Node metadata for current template node
         * @return {boolean} `true` if the visited node added node-specific
         *   metadata to `nodeInfo`
         * @protected
         * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
         */

      }, {
        key: '_parseTemplateNestedTemplate',
        value: function _parseTemplateNestedTemplate(node, templateInfo, nodeInfo) {
          var noted = _get(PropertyEffects.__proto__ || Object.getPrototypeOf(PropertyEffects), '_parseTemplateNestedTemplate', this).call(this, node, templateInfo, nodeInfo);
          // Merge host props into outer template and add bindings
          var hostProps = nodeInfo.templateInfo.hostProps;
          var mode = '{';
          for (var source in hostProps) {
            var parts = [{ mode: mode, source: source, dependencies: [source] }];
            addBinding(this, templateInfo, nodeInfo, 'property', '_host_' + source, parts);
          }
          return noted;
        }

        /**
         * Called to parse text in a template (either attribute values or
         * textContent) into binding metadata.
         *
         * Any overrides of this method should return an array of binding part
         * metadata  representing one or more bindings found in the provided text
         * and any "literal" text in between.  Any non-literal parts will be passed
         * to `_evaluateBinding` when any dependencies change.  The only required
         * fields of each "part" in the returned array are as follows:
         *
         * - `dependencies` - Array containing trigger metadata for each property
         *   that should trigger the binding to update
         * - `literal` - String containing text if the part represents a literal;
         *   in this case no `dependencies` are needed
         *
         * Additional metadata for use by `_evaluateBinding` may be provided in
         * each part object as needed.
         *
         * The default implementation handles the following types of bindings
         * (one or more may be intermixed with literal strings):
         * - Property binding: `[[prop]]`
         * - Path binding: `[[object.prop]]`
         * - Negated property or path bindings: `[[!prop]]` or `[[!object.prop]]`
         * - Two-way property or path bindings (supports negation):
         *   `{{prop}}`, `{{object.prop}}`, `{{!prop}}` or `{{!object.prop}}`
         * - Inline computed method (supports negation):
         *   `[[compute(a, 'literal', b)]]`, `[[!compute(a, 'literal', b)]]`
         *
         * @param {string} text Text to parse from attribute or textContent
         * @param {Object} templateInfo Current template metadata
         * @return {Array<!BindingPart>} Array of binding part metadata
         * @protected
         */

      }, {
        key: '_parseBindings',
        value: function _parseBindings(text, templateInfo) {
          var parts = [];
          var lastIndex = 0;
          var m = void 0;
          // Example: "literal1{{prop}}literal2[[!compute(foo,bar)]]final"
          // Regex matches:
          //        Iteration 1:  Iteration 2:
          // m[1]: '{{'          '[['
          // m[2]: ''            '!'
          // m[3]: 'prop'        'compute(foo,bar)'
          while ((m = bindingRegex.exec(text)) !== null) {
            // Add literal part
            if (m.index > lastIndex) {
              parts.push({ literal: text.slice(lastIndex, m.index) });
            }
            // Add binding part
            var mode = m[1][0];
            var negate = Boolean(m[2]);
            var source = m[3].trim();
            var customEvent = false,
                notifyEvent = '',
                colon = -1;
            if (mode == '{' && (colon = source.indexOf('::')) > 0) {
              notifyEvent = source.substring(colon + 2);
              source = source.substring(0, colon);
              customEvent = true;
            }
            var signature = parseMethod(source);
            var dependencies = [];
            if (signature) {
              // Inline computed function
              var args = signature.args,
                  methodName = signature.methodName;

              for (var i = 0; i < args.length; i++) {
                var arg = args[i];
                if (!arg.literal) {
                  dependencies.push(arg);
                }
              }
              var dynamicFns = templateInfo.dynamicFns;
              if (dynamicFns && dynamicFns[methodName] || signature.static) {
                dependencies.push(methodName);
                signature.dynamicFn = true;
              }
            } else {
              // Property or path
              dependencies.push(source);
            }
            parts.push({
              source: source, mode: mode, negate: negate, customEvent: customEvent, signature: signature, dependencies: dependencies,
              event: notifyEvent
            });
            lastIndex = bindingRegex.lastIndex;
          }
          // Add a final literal part
          if (lastIndex && lastIndex < text.length) {
            var literal = text.substring(lastIndex);
            if (literal) {
              parts.push({
                literal: literal
              });
            }
          }
          if (parts.length) {
            return parts;
          } else {
            return null;
          }
        }

        /**
         * Called to evaluate a previously parsed binding part based on a set of
         * one or more changed dependencies.
         *
         * @param {this} inst Element that should be used as scope for
         *   binding dependencies
         * @param {BindingPart} part Binding part metadata
         * @param {string} path Property/path that triggered this effect
         * @param {Object} props Bag of current property changes
         * @param {Object} oldProps Bag of previous values for changed properties
         * @param {boolean} hasPaths True with `props` contains one or more paths
         * @return {*} Value the binding part evaluated to
         * @protected
         */

      }, {
        key: '_evaluateBinding',
        value: function _evaluateBinding(inst, part, path, props, oldProps, hasPaths) {
          var value = void 0;
          if (part.signature) {
            value = runMethodEffect(inst, path, props, oldProps, part.signature);
          } else if (path != part.source) {
            value = Polymer.Path.get(inst, part.source);
          } else {
            if (hasPaths && Polymer.Path.isPath(path)) {
              value = Polymer.Path.get(inst, path);
            } else {
              value = inst.__data[path];
            }
          }
          if (part.negate) {
            value = !value;
          }
          return value;
        }
      }]);

      return PropertyEffects;
    }(propertyEffectsBase);

    // make a typing for closure :P


    PropertyEffectsType = PropertyEffects;

    return PropertyEffects;
  });

  /**
   * Helper api for enqueing client dom created by a host element.
   *
   * By default elements are flushed via `_flushProperties` when
   * `connectedCallback` is called. Elements attach their client dom to
   * themselves at `ready` time which results from this first flush.
   * This provides an ordering guarantee that the client dom an element
   * creates is flushed before the element itself (i.e. client `ready`
   * fires before host `ready`).
   *
   * However, if `_flushProperties` is called *before* an element is connected,
   * as for example `Templatize` does, this ordering guarantee cannot be
   * satisfied because no elements are connected. (Note: Bound elements that
   * receive data do become enqueued clients and are properly ordered but
   * unbound elements are not.)
   *
   * To maintain the desired "client before host" ordering guarantee for this
   * case we rely on the "host stack. Client nodes registers themselves with
   * the creating host element when created. This ensures that all client dom
   * is readied in the proper order, maintaining the desired guarantee.
   *
   * @private
   */
  var hostStack = {

    stack: [],

    /**
     * @param {*} inst Instance to add to hostStack
     * @this {hostStack}
     */
    registerHost: function registerHost(inst) {
      if (this.stack.length) {
        var host = this.stack[this.stack.length - 1];
        host._enqueueClient(inst);
      }
    },


    /**
     * @param {*} inst Instance to begin hosting
     * @this {hostStack}
     */
    beginHosting: function beginHosting(inst) {
      this.stack.push(inst);
    },


    /**
     * @param {*} inst Instance to end hosting
     * @this {hostStack}
     */
    endHosting: function endHosting(inst) {
      var stackLen = this.stack.length;
      if (stackLen && this.stack[stackLen - 1] == inst) {
        this.stack.pop();
      }
    }
  };
})();

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

__webpack_require__(1);

__webpack_require__(3);

__webpack_require__(8);

(function () {
  'use strict';

  /** @typedef {{run: function(function(), number=):number, cancel: function(number)}} */

  var AsyncModule = void 0; // eslint-disable-line no-unused-vars

  /**
   * @summary Collapse multiple callbacks into one invocation after a timer.
   * @memberof Polymer
   */

  var Debouncer = function () {
    function Debouncer() {
      _classCallCheck(this, Debouncer);

      this._asyncModule = null;
      this._callback = null;
      this._timer = null;
    }
    /**
     * Sets the scheduler; that is, a module with the Async interface,
     * a callback and optional arguments to be passed to the run function
     * from the async module.
     *
     * @param {!AsyncModule} asyncModule Object with Async interface.
     * @param {function()} callback Callback to run.
     */


    _createClass(Debouncer, [{
      key: 'setConfig',
      value: function setConfig(asyncModule, callback) {
        var _this = this;

        this._asyncModule = asyncModule;
        this._callback = callback;
        this._timer = this._asyncModule.run(function () {
          _this._timer = null;
          _this._callback();
        });
      }
      /**
       * Cancels an active debouncer and returns a reference to itself.
       */

    }, {
      key: 'cancel',
      value: function cancel() {
        if (this.isActive()) {
          this._asyncModule.cancel(this._timer);
          this._timer = null;
        }
      }
      /**
       * Flushes an active debouncer and returns a reference to itself.
       */

    }, {
      key: 'flush',
      value: function flush() {
        if (this.isActive()) {
          this.cancel();
          this._callback();
        }
      }
      /**
       * Returns true if the debouncer is active.
       *
       * @return {boolean} True if active.
       */

    }, {
      key: 'isActive',
      value: function isActive() {
        return this._timer != null;
      }
      /**
       * Creates a debouncer if no debouncer is passed as a parameter
       * or it cancels an active debouncer otherwise. The following
       * example shows how a debouncer can be called multiple times within a
       * microtask and "debounced" such that the provided callback function is
       * called once. Add this method to a custom element:
       *
       * _debounceWork() {
       *   this._debounceJob = Polymer.Debouncer.debounce(this._debounceJob,
       *       Polymer.Async.microTask, () => {
       *     this._doWork();
       *   });
       * }
       *
       * If the `_debounceWork` method is called multiple times within the same
       * microtask, the `_doWork` function will be called only once at the next
       * microtask checkpoint.
       *
       * Note: In testing it is often convenient to avoid asynchrony. To accomplish
       * this with a debouncer, you can use `Polymer.enqueueDebouncer` and
       * `Polymer.flush`. For example, extend the above example by adding
       * `Polymer.enqueueDebouncer(this._debounceJob)` at the end of the
       * `_debounceWork` method. Then in a test, call `Polymer.flush` to ensure
       * the debouncer has completed.
       *
       * @param {Debouncer?} debouncer Debouncer object.
       * @param {!AsyncModule} asyncModule Object with Async interface
       * @param {function()} callback Callback to run.
       * @return {!Debouncer} Returns a debouncer object.
       */

    }], [{
      key: 'debounce',
      value: function debounce(debouncer, asyncModule, callback) {
        if (debouncer instanceof Debouncer) {
          debouncer.cancel();
        } else {
          debouncer = new Debouncer();
        }
        debouncer.setConfig(asyncModule, callback);
        return debouncer;
      }
    }]);

    return Debouncer;
  }();

  Polymer.Debouncer = Debouncer;
})();

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(1);

(function () {
  'use strict';

  var debouncerQueue = [];

  /**
   * Adds a `Polymer.Debouncer` to a list of globally flushable tasks.
   *
   * @memberof Polymer
   * @param {Polymer.Debouncer} debouncer Debouncer to enqueue
   */
  Polymer.enqueueDebouncer = function (debouncer) {
    debouncerQueue.push(debouncer);
  };

  function flushDebouncers() {
    var didFlush = Boolean(debouncerQueue.length);
    while (debouncerQueue.length) {
      try {
        debouncerQueue.shift().flush();
      } catch (e) {
        setTimeout(function () {
          throw e;
        });
      }
    }
    return didFlush;
  }

  /**
   * Forces several classes of asynchronously queued tasks to flush:
   * - Debouncers added via `enqueueDebouncer`
   * - ShadyDOM distribution
   *
   * @memberof Polymer
   */
  Polymer.flush = function () {
    var shadyDOM = void 0,
        debouncers = void 0;
    do {
      shadyDOM = window.ShadyDOM && ShadyDOM.flush();
      if (window.ShadyCSS && window.ShadyCSS.ScopingShim) {
        window.ShadyCSS.ScopingShim.flush();
      }
      debouncers = flushDebouncers();
    } while (shadyDOM || debouncers);
  };
})();

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

__webpack_require__(1);

__webpack_require__(11);

__webpack_require__(9);

(function () {
  'use strict';

  // Base class for HTMLTemplateElement extension that has property effects
  // machinery for propagating host properties to children. This is an ES5
  // class only because Babel (incorrectly) requires super() in the class
  // constructor even though no `this` is used and it returns an instance.

  var newInstance = null;
  /**
   * @constructor
   * @extends {HTMLTemplateElement}
   */
  function HTMLTemplateElementExtension() {
    return newInstance;
  }
  HTMLTemplateElementExtension.prototype = Object.create(HTMLTemplateElement.prototype, {
    constructor: {
      value: HTMLTemplateElementExtension,
      writable: true
    }
  });
  /**
   * @constructor
   * @implements {Polymer_PropertyEffects}
   * @extends {HTMLTemplateElementExtension}
   */
  var DataTemplate = Polymer.PropertyEffects(HTMLTemplateElementExtension);
  /**
   * @constructor
   * @implements {Polymer_MutableData}
   * @extends {DataTemplate}
   */
  var MutableDataTemplate = Polymer.MutableData(DataTemplate);

  // Applies a DataTemplate subclass to a <template> instance
  function upgradeTemplate(template, constructor) {
    newInstance = template;
    Object.setPrototypeOf(template, constructor.prototype);
    new constructor();
    newInstance = null;
  }

  // Base class for TemplateInstance's
  /**
   * @constructor
   * @implements {Polymer_PropertyEffects}
   */
  var base = Polymer.PropertyEffects(function () {
    function _class() {
      _classCallCheck(this, _class);
    }

    return _class;
  }());

  /**
   * @polymer
   * @customElement
   * @appliesMixin Polymer.PropertyEffects
   * @unrestricted
   */

  var TemplateInstanceBase = function (_base) {
    _inherits(TemplateInstanceBase, _base);

    function TemplateInstanceBase(props) {
      _classCallCheck(this, TemplateInstanceBase);

      var _this = _possibleConstructorReturn(this, (TemplateInstanceBase.__proto__ || Object.getPrototypeOf(TemplateInstanceBase)).call(this));

      _this._configureProperties(props);
      _this.root = _this._stampTemplate(_this.__dataHost);
      // Save list of stamped children
      var children = _this.children = [];
      for (var n = _this.root.firstChild; n; n = n.nextSibling) {
        children.push(n);
        n.__templatizeInstance = _this;
      }
      if (_this.__templatizeOwner.__hideTemplateChildren__) {
        _this._showHideChildren(true);
      }
      // Flush props only when props are passed if instance props exist
      // or when there isn't instance props.
      var options = _this.__templatizeOptions;
      if (props && options.instanceProps || !options.instanceProps) {
        _this._enableProperties();
      }
      return _this;
    }
    /**
     * Configure the given `props` by calling `_setPendingProperty`. Also
     * sets any properties stored in `__hostProps`.
     * @private
     * @param {Object} props Object of property name-value pairs to set.
     */


    _createClass(TemplateInstanceBase, [{
      key: '_configureProperties',
      value: function _configureProperties(props) {
        var options = this.__templatizeOptions;
        if (props) {
          for (var iprop in options.instanceProps) {
            if (iprop in props) {
              this._setPendingProperty(iprop, props[iprop]);
            }
          }
        }
        for (var hprop in this.__hostProps) {
          this._setPendingProperty(hprop, this.__dataHost['_host_' + hprop]);
        }
      }
      /**
       * Forwards a host property to this instance.  This method should be
       * called on instances from the `options.forwardHostProp` callback
       * to propagate changes of host properties to each instance.
       *
       * Note this method enqueues the change, which are flushed as a batch.
       *
       * @param {string} prop Property or path name
       * @param {*} value Value of the property to forward
       */

    }, {
      key: 'forwardHostProp',
      value: function forwardHostProp(prop, value) {
        if (this._setPendingPropertyOrPath(prop, value, false, true)) {
          this.__dataHost._enqueueClient(this);
        }
      }
      /**
       * @override
       */

    }, {
      key: '_addEventListenerToNode',
      value: function _addEventListenerToNode(node, eventName, handler) {
        var _this2 = this;

        if (this._methodHost && this.__templatizeOptions.parentModel) {
          // If this instance should be considered a parent model, decorate
          // events this template instance as `model`
          this._methodHost._addEventListenerToNode(node, eventName, function (e) {
            e.model = _this2;
            handler(e);
          });
        } else {
          // Otherwise delegate to the template's host (which could be)
          // another template instance
          var templateHost = this.__dataHost.__dataHost;
          if (templateHost) {
            templateHost._addEventListenerToNode(node, eventName, handler);
          }
        }
      }
      /**
       * Shows or hides the template instance top level child elements. For
       * text nodes, `textContent` is removed while "hidden" and replaced when
       * "shown."
       * @param {boolean} hide Set to true to hide the children;
       * set to false to show them.
       * @protected
       */

    }, {
      key: '_showHideChildren',
      value: function _showHideChildren(hide) {
        var c = this.children;
        for (var i = 0; i < c.length; i++) {
          var n = c[i];
          // Ignore non-changes
          if (Boolean(hide) != Boolean(n.__hideTemplateChildren__)) {
            if (n.nodeType === Node.TEXT_NODE) {
              if (hide) {
                n.__polymerTextContent__ = n.textContent;
                n.textContent = '';
              } else {
                n.textContent = n.__polymerTextContent__;
              }
            } else if (n.style) {
              if (hide) {
                n.__polymerDisplay__ = n.style.display;
                n.style.display = 'none';
              } else {
                n.style.display = n.__polymerDisplay__;
              }
            }
          }
          n.__hideTemplateChildren__ = hide;
          if (n._showHideChildren) {
            n._showHideChildren(hide);
          }
        }
      }
      /**
       * Overrides default property-effects implementation to intercept
       * textContent bindings while children are "hidden" and cache in
       * private storage for later retrieval.
       *
       * @override
       */

    }, {
      key: '_setUnmanagedPropertyToNode',
      value: function _setUnmanagedPropertyToNode(node, prop, value) {
        if (node.__hideTemplateChildren__ && node.nodeType == Node.TEXT_NODE && prop == 'textContent') {
          node.__polymerTextContent__ = value;
        } else {
          _get(TemplateInstanceBase.prototype.__proto__ || Object.getPrototypeOf(TemplateInstanceBase.prototype), '_setUnmanagedPropertyToNode', this).call(this, node, prop, value);
        }
      }
      /**
       * Find the parent model of this template instance.  The parent model
       * is either another templatize instance that had option `parentModel: true`,
       * or else the host element.
       *
       * @return {Polymer_PropertyEffects} The parent model of this instance
       */

    }, {
      key: 'parentModel',
      get: function get() {
        var model = this.__parentModel;
        if (!model) {
          var options = void 0;
          model = this;
          do {
            // A template instance's `__dataHost` is a <template>
            // `model.__dataHost.__dataHost` is the template's host
            model = model.__dataHost.__dataHost;
          } while ((options = model.__templatizeOptions) && !options.parentModel);
          this.__parentModel = model;
        }
        return model;
      }
    }]);

    return TemplateInstanceBase;
  }(base);

  /** @type {!DataTemplate} */


  TemplateInstanceBase.prototype.__dataHost;
  /** @type {!TemplatizeOptions} */
  TemplateInstanceBase.prototype.__templatizeOptions;
  /** @type {!Polymer_PropertyEffects} */
  TemplateInstanceBase.prototype._methodHost;
  /** @type {!Object} */
  TemplateInstanceBase.prototype.__templatizeOwner;
  /** @type {!Object} */
  TemplateInstanceBase.prototype.__hostProps;

  /**
   * @constructor
   * @extends {TemplateInstanceBase}
   * @implements {Polymer_MutableData}
   */
  var MutableTemplateInstanceBase = Polymer.MutableData(TemplateInstanceBase);

  function findMethodHost(template) {
    // Technically this should be the owner of the outermost template.
    // In shadow dom, this is always getRootNode().host, but we can
    // approximate this via cooperation with our dataHost always setting
    // `_methodHost` as long as there were bindings (or id's) on this
    // instance causing it to get a dataHost.
    var templateHost = template.__dataHost;
    return templateHost && templateHost._methodHost || templateHost;
  }

  /* eslint-disable valid-jsdoc */
  /**
   * @suppress {missingProperties} class.prototype is not defined for some reason
   */
  function createTemplatizerClass(template, templateInfo, options) {
    // Anonymous class created by the templatize
    var base = options.mutableData ? MutableTemplateInstanceBase : TemplateInstanceBase;
    /**
     * @constructor
     * @extends {base}
     */
    var klass = function (_base2) {
      _inherits(klass, _base2);

      function klass() {
        _classCallCheck(this, klass);

        return _possibleConstructorReturn(this, (klass.__proto__ || Object.getPrototypeOf(klass)).apply(this, arguments));
      }

      return klass;
    }(base);
    klass.prototype.__templatizeOptions = options;
    klass.prototype._bindTemplate(template);
    addNotifyEffects(klass, template, templateInfo, options);
    return klass;
  }

  /**
   * @suppress {missingProperties} class.prototype is not defined for some reason
   */
  function addPropagateEffects(template, templateInfo, options) {
    var userForwardHostProp = options.forwardHostProp;
    if (userForwardHostProp) {
      // Provide data API and property effects on memoized template class
      var klass = templateInfo.templatizeTemplateClass;
      if (!klass) {
        var _base3 = options.mutableData ? MutableDataTemplate : DataTemplate;
        klass = templateInfo.templatizeTemplateClass = function (_base4) {
          _inherits(TemplatizedTemplate, _base4);

          function TemplatizedTemplate() {
            _classCallCheck(this, TemplatizedTemplate);

            return _possibleConstructorReturn(this, (TemplatizedTemplate.__proto__ || Object.getPrototypeOf(TemplatizedTemplate)).apply(this, arguments));
          }

          return TemplatizedTemplate;
        }(_base3);
        // Add template - >instances effects
        // and host <- template effects
        var hostProps = templateInfo.hostProps;
        for (var prop in hostProps) {
          klass.prototype._addPropertyEffect('_host_' + prop, klass.prototype.PROPERTY_EFFECT_TYPES.PROPAGATE, { fn: createForwardHostPropEffect(prop, userForwardHostProp) });
          klass.prototype._createNotifyingProperty('_host_' + prop);
        }
      }
      upgradeTemplate(template, klass);
      // Mix any pre-bound data into __data; no need to flush this to
      // instances since they pull from the template at instance-time
      if (template.__dataProto) {
        // Note, generally `__dataProto` could be chained, but it's guaranteed
        // to not be since this is a vanilla template we just added effects to
        Object.assign(template.__data, template.__dataProto);
      }
      // Clear any pending data for performance
      template.__dataTemp = {};
      template.__dataPending = null;
      template.__dataOld = null;
      template._enableProperties();
    }
  }
  /* eslint-enable valid-jsdoc */

  function createForwardHostPropEffect(hostProp, userForwardHostProp) {
    return function forwardHostProp(template, prop, props) {
      userForwardHostProp.call(template.__templatizeOwner, prop.substring('_host_'.length), props[prop]);
    };
  }

  function addNotifyEffects(klass, template, templateInfo, options) {
    var hostProps = templateInfo.hostProps || {};
    for (var iprop in options.instanceProps) {
      delete hostProps[iprop];
      var userNotifyInstanceProp = options.notifyInstanceProp;
      if (userNotifyInstanceProp) {
        klass.prototype._addPropertyEffect(iprop, klass.prototype.PROPERTY_EFFECT_TYPES.NOTIFY, { fn: createNotifyInstancePropEffect(iprop, userNotifyInstanceProp) });
      }
    }
    if (options.forwardHostProp && template.__dataHost) {
      for (var hprop in hostProps) {
        klass.prototype._addPropertyEffect(hprop, klass.prototype.PROPERTY_EFFECT_TYPES.NOTIFY, { fn: createNotifyHostPropEffect() });
      }
    }
  }

  function createNotifyInstancePropEffect(instProp, userNotifyInstanceProp) {
    return function notifyInstanceProp(inst, prop, props) {
      userNotifyInstanceProp.call(inst.__templatizeOwner, inst, prop, props[prop]);
    };
  }

  function createNotifyHostPropEffect() {
    return function notifyHostProp(inst, prop, props) {
      inst.__dataHost._setPendingPropertyOrPath('_host_' + prop, props[prop], true, true);
    };
  }

  /**
   * Module for preparing and stamping instances of templates that utilize
   * Polymer's data-binding and declarative event listener features.
   *
   * Example:
   *
   *     // Get a template from somewhere, e.g. light DOM
   *     let template = this.querySelector('template');
   *     // Prepare the template
   *     let TemplateClass = Polymer.Templatize.templatize(template);
   *     // Instance the template with an initial data model
   *     let instance = new TemplateClass({myProp: 'initial'});
   *     // Insert the instance's DOM somewhere, e.g. element's shadow DOM
   *     this.shadowRoot.appendChild(instance.root);
   *     // Changing a property on the instance will propagate to bindings
   *     // in the template
   *     instance.myProp = 'new value';
   *
   * The `options` dictionary passed to `templatize` allows for customizing
   * features of the generated template class, including how outer-scope host
   * properties should be forwarded into template instances, how any instance
   * properties added into the template's scope should be notified out to
   * the host, and whether the instance should be decorated as a "parent model"
   * of any event handlers.
   *
   *     // Customze property forwarding and event model decoration
   *     let TemplateClass = Polymer.Templatize.templatize(template, this, {
   *       parentModel: true,
   *       instanceProps: {...},
   *       forwardHostProp(property, value) {...},
   *       notifyInstanceProp(instance, property, value) {...},
   *     });
   *
   *
   * @namespace
   * @memberof Polymer
   * @summary Module for preparing and stamping instances of templates
   *   utilizing Polymer templating features.
   */

  var Templatize = {

    /**
     * Returns an anonymous `Polymer.PropertyEffects` class bound to the
     * `<template>` provided.  Instancing the class will result in the
     * template being stamped into document fragment stored as the instance's
     * `root` property, after which it can be appended to the DOM.
     *
     * Templates may utilize all Polymer data-binding features as well as
     * declarative event listeners.  Event listeners and inline computing
     * functions in the template will be called on the host of the template.
     *
     * The constructor returned takes a single argument dictionary of initial
     * property values to propagate into template bindings.  Additionally
     * host properties can be forwarded in, and instance properties can be
     * notified out by providing optional callbacks in the `options` dictionary.
     *
     * Valid configuration in `options` are as follows:
     *
     * - `forwardHostProp(property, value)`: Called when a property referenced
     *   in the template changed on the template's host. As this library does
     *   not retain references to templates instanced by the user, it is the
     *   templatize owner's responsibility to forward host property changes into
     *   user-stamped instances.  The `instance.forwardHostProp(property, value)`
     *    method on the generated class should be called to forward host
     *   properties into the template to prevent unnecessary property-changed
     *   notifications. Any properties referenced in the template that are not
     *   defined in `instanceProps` will be notified up to the template's host
     *   automatically.
     * - `instanceProps`: Dictionary of property names that will be added
     *   to the instance by the templatize owner.  These properties shadow any
     *   host properties, and changes within the template to these properties
     *   will result in `notifyInstanceProp` being called.
     * - `mutableData`: When `true`, the generated class will skip strict
     *   dirty-checking for objects and arrays (always consider them to be
     *   "dirty").
     * - `notifyInstanceProp(instance, property, value)`: Called when
     *   an instance property changes.  Users may choose to call `notifyPath`
     *   on e.g. the owner to notify the change.
     * - `parentModel`: When `true`, events handled by declarative event listeners
     *   (`on-event="handler"`) will be decorated with a `model` property pointing
     *   to the template instance that stamped it.  It will also be returned
     *   from `instance.parentModel` in cases where template instance nesting
     *   causes an inner model to shadow an outer model.
     *
     * Note that the class returned from `templatize` is generated only once
     * for a given `<template>` using `options` from the first call for that
     * template, and the cached class is returned for all subsequent calls to
     * `templatize` for that template.  As such, `options` callbacks should not
     * close over owner-specific properties since only the first `options` is
     * used; rather, callbacks are called bound to the `owner`, and so context
     * needed from the callbacks (such as references to `instances` stamped)
     * should be stored on the `owner` such that they can be retrieved via `this`.
     *
     * @memberof Polymer.Templatize
     * @param {!HTMLTemplateElement} template Template to templatize
     * @param {!Polymer_PropertyEffects} owner Owner of the template instances;
     *   any optional callbacks will be bound to this owner.
     * @param {Object=} options Options dictionary (see summary for details)
     * @return {function(new:TemplateInstanceBase)} Generated class bound to the template
     *   provided
     * @suppress {invalidCasts}
     */
    templatize: function templatize(template, owner, options) {
      options = /** @type {!TemplatizeOptions} */options || {};
      if (template.__templatizeOwner) {
        throw new Error('A <template> can only be templatized once');
      }
      template.__templatizeOwner = owner;
      var templateInfo = owner.constructor._parseTemplate(template);
      // Get memoized base class for the prototypical template, which
      // includes property effects for binding template & forwarding
      var baseClass = templateInfo.templatizeInstanceClass;
      if (!baseClass) {
        baseClass = createTemplatizerClass(template, templateInfo, options);
        templateInfo.templatizeInstanceClass = baseClass;
      }
      // Host property forwarding must be installed onto template instance
      addPropagateEffects(template, templateInfo, options);
      // Subclass base class and add reference for this specific template
      var klass = function (_baseClass) {
        _inherits(TemplateInstance, _baseClass);

        function TemplateInstance() {
          _classCallCheck(this, TemplateInstance);

          return _possibleConstructorReturn(this, (TemplateInstance.__proto__ || Object.getPrototypeOf(TemplateInstance)).apply(this, arguments));
        }

        return TemplateInstance;
      }(baseClass);
      klass.prototype._methodHost = findMethodHost(template);
      klass.prototype.__dataHost = template;
      klass.prototype.__templatizeOwner = owner;
      klass.prototype.__hostProps = templateInfo.hostProps;
      return (/** @type {function(new:TemplateInstanceBase)} */klass
      );
    },


    /**
     * Returns the template "model" associated with a given element, which
     * serves as the binding scope for the template instance the element is
     * contained in. A template model is an instance of
     * `TemplateInstanceBase`, and should be used to manipulate data
     * associated with this template instance.
     *
     * Example:
     *
     *   let model = modelForElement(el);
     *   if (model.index < 10) {
     *     model.set('item.checked', true);
     *   }
     *
     * @memberof Polymer.Templatize
     * @param {HTMLTemplateElement} template The model will be returned for
     *   elements stamped from this template
     * @param {Node} node Node for which to return a template model.
     * @return {TemplateInstanceBase} Template instance representing the
     *   binding scope for the element
     */
    modelForElement: function modelForElement(template, node) {
      var model = void 0;
      while (node) {
        // An element with a __templatizeInstance marks the top boundary
        // of a scope; walk up until we find one, and then ensure that
        // its __dataHost matches `this`, meaning this dom-repeat stamped it
        if (model = node.__templatizeInstance) {
          // Found an element stamped by another template; keep walking up
          // from its __dataHost
          if (model.__dataHost != template) {
            node = model.__dataHost;
          } else {
            return model;
          }
        } else {
          // Still in a template scope, keep going up until
          // a __templatizeInstance is found
          node = node.parentNode;
        }
      }
      return null;
    }
  };

  Polymer.Templatize = Templatize;
  Polymer.TemplateInstanceBase = TemplateInstanceBase;
})();

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

__webpack_require__(22);

/**
 * @polymerBehavior Polymer.AppLayoutBehavior
 **/
Polymer.AppLayoutBehavior = [Polymer.IronResizableBehavior, {

  listeners: {
    'app-reset-layout': '_appResetLayoutHandler',
    'iron-resize': 'resetLayout'
  },

  attached: function attached() {
    this.fire('app-reset-layout');
  },

  _appResetLayoutHandler: function _appResetLayoutHandler(e) {
    if (Polymer.dom(e).path[0] === this) {
      return;
    }
    this.resetLayout();
    e.stopPropagation();
  },

  _updateLayoutStates: function _updateLayoutStates() {
    console.error('unimplemented');
  },

  /**
   * Resets the layout. If you changed the size of this element via CSS
   * you can notify the changes by either firing the `iron-resize` event
   * or calling `resetLayout` directly.
   *
   * @method resetLayout
   */
  resetLayout: function resetLayout() {
    // Polymer v2.x
    var self = this;
    var cb = this._updateLayoutStates.bind(this);
    if (Polymer.Async && Polymer.Async.animationFrame) {
      this._layoutDebouncer = Polymer.Debouncer.debounce(this._layoutDebouncer, Polymer.Async.animationFrame, cb);
      Polymer.enqueueDebouncer(this._layoutDebouncer);
    }
    // Polymer v1.x
    else {
        this.debounce('resetLayout', cb);
      }
    this._notifyDescendantResize();
  },

  _notifyLayoutChanged: function _notifyLayoutChanged() {
    var self = this;
    // TODO: the event `app-reset-layout` can be fired synchronously
    // as long as `_updateLayoutStates` waits for all the microtasks after rAF.
    // E.g. requestAnimationFrame(setTimeOut())
    requestAnimationFrame(function () {
      self.fire('app-reset-layout');
    });
  },

  _notifyDescendantResize: function _notifyDescendantResize() {
    if (!this.isAttached) {
      return;
    }
    this._interestedResizables.forEach(function (resizable) {
      if (this.resizerShouldNotify(resizable)) {
        this._notifyDescendant(resizable);
      }
    }, this);
  }
}];

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

__webpack_require__(1);

__webpack_require__(17);

__webpack_require__(3);

__webpack_require__(10);

__webpack_require__(18);

__webpack_require__(7);

__webpack_require__(31);

__webpack_require__(11);

(function () {
  'use strict';

  /**
   * Element class mixin that provides the core API for Polymer's meta-programming
   * features including template stamping, data-binding, attribute deserialization,
   * and property change observation.
   *
   * Subclassers may provide the following static getters to return metadata
   * used to configure Polymer's features for the class:
   *
   * - `static get is()`: When the template is provided via a `dom-module`,
   *   users should return the `dom-module` id from a static `is` getter.  If
   *   no template is needed or the template is provided directly via the
   *   `template` getter, there is no need to define `is` for the element.
   *
   * - `static get template()`: Users may provide the template directly (as
   *   opposed to via `dom-module`) by implementing a static `template` getter.
   *   The getter may return an `HTMLTemplateElement` or a string, which will
   *   automatically be parsed into a template.
   *
   * - `static get properties()`: Should return an object describing
   *   property-related metadata used by Polymer features (key: property name
   *   value: object containing property metadata). Valid keys in per-property
   *   metadata include:
   *   - `type` (String|Number|Object|Array|...): Used by
   *     `attributeChangedCallback` to determine how string-based attributes
   *     are deserialized to JavaScript property values.
   *   - `notify` (boolean): Causes a change in the property to fire a
   *     non-bubbling event called `<property>-changed`. Elements that have
   *     enabled two-way binding to the property use this event to observe changes.
   *   - `readOnly` (boolean): Creates a getter for the property, but no setter.
   *     To set a read-only property, use the private setter method
   *     `_setProperty(property, value)`.
   *   - `observer` (string): Observer method name that will be called when
   *     the property changes. The arguments of the method are
   *     `(value, previousValue)`.
   *   - `computed` (string): String describing method and dependent properties
   *     for computing the value of this property (e.g. `'computeFoo(bar, zot)'`).
   *     Computed properties are read-only by default and can only be changed
   *     via the return value of the computing method.
   *
   * - `static get observers()`: Array of strings describing multi-property
   *   observer methods and their dependent properties (e.g.
   *   `'observeABC(a, b, c)'`).
   *
   * The base class provides default implementations for the following standard
   * custom element lifecycle callbacks; users may override these, but should
   * call the super method to ensure
   * - `constructor`: Run when the element is created or upgraded
   * - `connectedCallback`: Run each time the element is connected to the
   *   document
   * - `disconnectedCallback`: Run each time the element is disconnected from
   *   the document
   * - `attributeChangedCallback`: Run each time an attribute in
   *   `observedAttributes` is set or removed (note: this element's default
   *   `observedAttributes` implementation will automatically return an array
   *   of dash-cased attributes based on `properties`)
   *
   * @mixinFunction
   * @polymer
   * @appliesMixin Polymer.PropertyEffects
   * @memberof Polymer
   * @property rootPath {string} Set to the value of `Polymer.rootPath`,
   *   which defaults to the main document path
   * @property importPath {string} Set to the value of the class's static
   *   `importPath` property, which defaults to the path of this element's
   *   `dom-module` (when `is` is used), but can be overridden for other
   *   import strategies.
   * @summary Element class mixin that provides the core API for Polymer's
   * meta-programming features.
   */

  Polymer.ElementMixin = Polymer.dedupingMixin(function (base) {

    /**
     * @constructor
     * @extends {base}
     * @implements {Polymer_PropertyEffects}
     */
    var polymerElementBase = Polymer.PropertyEffects(base);

    var caseMap = Polymer.CaseMap;

    /**
     * Returns the `properties` object specifically on `klass`. Use for:
     * (1) super chain mixes togther to make `propertiesForClass` which is
     * then used to make `observedAttributes`.
     * (2) properties effects and observers are created from it at `finalize` time.
     *
     * @param {HTMLElement} klass Element class
     * @return {Object} Object containing own properties for this class
     * @private
     */
    function ownPropertiesForClass(klass) {
      if (!klass.hasOwnProperty(JSCompiler_renameProperty('__ownProperties', klass))) {
        klass.__ownProperties = klass.hasOwnProperty(JSCompiler_renameProperty('properties', klass)) ?
        /** @type PolymerElementConstructor */klass.properties : {};
      }
      return klass.__ownProperties;
    }

    /**
     * Returns the `observers` array specifically on `klass`. Use for
     * setting up observers.
     *
     * @param {HTMLElement} klass Element class
     * @return {Array} Array containing own observers for this class
     * @private
     */
    function ownObserversForClass(klass) {
      if (!klass.hasOwnProperty(JSCompiler_renameProperty('__ownObservers', klass))) {
        klass.__ownObservers = klass.hasOwnProperty(JSCompiler_renameProperty('observers', klass)) ?
        /** @type PolymerElementConstructor */klass.observers : [];
      }
      return klass.__ownObservers;
    }

    /**
     * Mixes `props` into `flattenedProps` but upgrades shorthand type
     * syntax to { type: Type}.
     *
     * @param {Object} flattenedProps Bag to collect flattened properties into
     * @param {Object} props Bag of properties to add to `flattenedProps`
     * @return {Object} The input `flattenedProps` bag
     * @private
     */
    function flattenProperties(flattenedProps, props) {
      for (var p in props) {
        var o = props[p];
        if (typeof o == 'function') {
          o = { type: o };
        }
        flattenedProps[p] = o;
      }
      return flattenedProps;
    }

    /**
     * Returns a flattened list of properties mixed together from the chain of all
     * constructor's `config.properties`. This list is used to create
     * (1) observedAttributes,
     * (2) class property default values
     *
     * @param {PolymerElementConstructor} klass Element class
     * @return {PolymerElementProperties} Flattened properties for this class
     * @suppress {missingProperties} class.prototype is not a property for some reason?
     * @private
     */
    function propertiesForClass(klass) {
      if (!klass.hasOwnProperty(JSCompiler_renameProperty('__classProperties', klass))) {
        klass.__classProperties = flattenProperties({}, ownPropertiesForClass(klass));
        var superCtor = Object.getPrototypeOf(klass.prototype).constructor;
        if (superCtor.prototype instanceof PolymerElement) {
          klass.__classProperties = Object.assign(Object.create(propertiesForClass( /** @type PolymerElementConstructor */superCtor)), klass.__classProperties);
        }
      }
      return klass.__classProperties;
    }

    /**
     * Returns a list of properties with default values.
     * This list is created as an optimization since it is a subset of
     * the list returned from `propertiesForClass`.
     * This list is used in `_initializeProperties` to set property defaults.
     *
     * @param {PolymerElementConstructor} klass Element class
     * @return {PolymerElementProperties} Flattened properties for this class
     *   that have default values
     * @private
     */
    function propertyDefaultsForClass(klass) {
      if (!klass.hasOwnProperty(JSCompiler_renameProperty('__classPropertyDefaults', klass))) {
        klass.__classPropertyDefaults = null;
        var props = propertiesForClass(klass);
        for (var p in props) {
          var info = props[p];
          if ('value' in info) {
            klass.__classPropertyDefaults = klass.__classPropertyDefaults || {};
            klass.__classPropertyDefaults[p] = info;
          }
        }
      }
      return klass.__classPropertyDefaults;
    }

    /**
     * Returns true if a `klass` has finalized. Called in `ElementClass.finalize()`
     * @param {PolymerElementConstructor} klass Element class
     * @return {boolean} True if all metaprogramming for this class has been
     *   completed
     * @private
     */
    function hasClassFinalized(klass) {
      return klass.hasOwnProperty(JSCompiler_renameProperty('__finalized', klass));
    }

    /**
     * Called by `ElementClass.finalize()`. Ensures this `klass` and
     * *all superclasses* are finalized by traversing the prototype chain
     * and calling `klass.finalize()`.
     *
     * @param {PolymerElementConstructor} klass Element class
     * @private
     */
    function finalizeClassAndSuper(klass) {
      var proto = /** @type PolymerElementConstructor */klass.prototype;
      var superCtor = Object.getPrototypeOf(proto).constructor;
      if (superCtor.prototype instanceof PolymerElement) {
        superCtor.finalize();
      }
      finalizeClass(klass);
    }

    /**
     * Configures a `klass` based on a staic `klass.config` object and
     * a `template`. This includes creating accessors and effects
     * for properties in `config` and the `template` as well as preparing the
     * `template` for stamping.
     *
     * @param {PolymerElementConstructor} klass Element class
     * @private
     */
    function finalizeClass(klass) {
      klass.__finalized = true;
      var proto = /** @type PolymerElementConstructor */klass.prototype;
      if (klass.hasOwnProperty(JSCompiler_renameProperty('is', klass)) && klass.is) {
        Polymer.telemetry.register(proto);
      }
      var props = ownPropertiesForClass(klass);
      if (props) {
        finalizeProperties(proto, props);
      }
      var observers = ownObserversForClass(klass);
      if (observers) {
        finalizeObservers(proto, observers, props);
      }
      // note: create "working" template that is finalized at instance time
      var template = /** @type PolymerElementConstructor */klass.template;
      if (template) {
        if (typeof template === 'string') {
          var t = document.createElement('template');
          t.innerHTML = template;
          template = t;
        } else {
          template = template.cloneNode(true);
        }
        proto._template = template;
      }
    }

    /**
     * Configures a `proto` based on a `properties` object.
     * Leverages `PropertyEffects` to create property accessors and effects
     * supporting, observers, reflecting to attributes, change notification,
     * computed properties, and read only properties.
     * @param {PolymerElement} proto Element class prototype to add accessors
     *    and effects to
     * @param {Object} properties Flattened bag of property descriptors for
     *    this class
     * @private
     */
    function finalizeProperties(proto, properties) {
      for (var p in properties) {
        createPropertyFromConfig(proto, p, properties[p], properties);
      }
    }

    /**
     * Configures a `proto` based on a `observers` array.
     * Leverages `PropertyEffects` to create observers.
     * @param {PolymerElement} proto Element class prototype to add accessors
     *   and effects to
     * @param {Object} observers Flattened array of observer descriptors for
     *   this class
     * @param {Object} dynamicFns Object containing keys for any properties
     *   that are functions and should trigger the effect when the function
     *   reference is changed
     * @private
     */
    function finalizeObservers(proto, observers, dynamicFns) {
      for (var i = 0; i < observers.length; i++) {
        proto._createMethodObserver(observers[i], dynamicFns);
      }
    }

    /**
     * Creates effects for a property.
     *
     * Note, once a property has been set to
     * `readOnly`, `computed`, `reflectToAttribute`, or `notify`
     * these values may not be changed. For example, a subclass cannot
     * alter these settings. However, additional `observers` may be added
     * by subclasses.
     *
     * The info object should may contain property metadata as follows:
     *
     * * `type`: {function} type to which an attribute matching the property
     * is deserialized. Note the property is camel-cased from a dash-cased
     * attribute. For example, 'foo-bar' attribute is dersialized to a
     * property named 'fooBar'.
     *
     * * `readOnly`: {boolean} creates a readOnly property and
     * makes a private setter for the private of the form '_setFoo' for a
     * property 'foo',
     *
     * * `computed`: {string} creates a computed property. A computed property
     * also automatically is set to `readOnly: true`. The value is calculated
     * by running a method and arguments parsed from the given string. For
     * example 'compute(foo)' will compute a given property when the
     * 'foo' property changes by executing the 'compute' method. This method
     * must return the computed value.
     *
     * * `reflectToAttriute`: {boolean} If true, the property value is reflected
     * to an attribute of the same name. Note, the attribute is dash-cased
     * so a property named 'fooBar' is reflected as 'foo-bar'.
     *
     * * `notify`: {boolean} sends a non-bubbling notification event when
     * the property changes. For example, a property named 'foo' sends an
     * event named 'foo-changed' with `event.detail` set to the value of
     * the property.
     *
     * * observer: {string} name of a method that runs when the property
     * changes. The arguments of the method are (value, previousValue).
     *
     * Note: Users may want control over modifying property
     * effects via subclassing. For example, a user might want to make a
     * reflectToAttribute property not do so in a subclass. We've chosen to
     * disable this because it leads to additional complication.
     * For example, a readOnly effect generates a special setter. If a subclass
     * disables the effect, the setter would fail unexpectedly.
     * Based on feedback, we may want to try to make effects more malleable
     * and/or provide an advanced api for manipulating them.
     * Also consider adding warnings when an effect cannot be changed.
     *
     * @param {PolymerElement} proto Element class prototype to add accessors
     *   and effects to
     * @param {string} name Name of the property.
     * @param {Object} info Info object from which to create property effects.
     * Supported keys:
     * @param {Object} allProps Flattened map of all properties defined in this
     *   element (including inherited properties)
     * @private
     */
    function createPropertyFromConfig(proto, name, info, allProps) {
      // computed forces readOnly...
      if (info.computed) {
        info.readOnly = true;
      }
      // Note, since all computed properties are readOnly, this prevents
      // adding additional computed property effects (which leads to a confusing
      // setup where multiple triggers for setting a property)
      // While we do have `hasComputedEffect` this is set on the property's
      // dependencies rather than itself.
      if (info.computed && !proto._hasReadOnlyEffect(name)) {
        proto._createComputedProperty(name, info.computed, allProps);
      }
      if (info.readOnly && !proto._hasReadOnlyEffect(name)) {
        proto._createReadOnlyProperty(name, !info.computed);
      }
      if (info.reflectToAttribute && !proto._hasReflectEffect(name)) {
        proto._createReflectedProperty(name);
      }
      if (info.notify && !proto._hasNotifyEffect(name)) {
        proto._createNotifyingProperty(name);
      }
      // always add observer
      if (info.observer) {
        proto._createPropertyObserver(name, info.observer, allProps[info.observer]);
      }
    }

    /**
     * Configures an element `proto` to function with a given `template`.
     * The element name `is` and extends `ext` must be specified for ShadyCSS
     * style scoping.
     *
     * @param {PolymerElement} proto Element class prototype to add accessors
     *   and effects to
     * @param {!HTMLTemplateElement} template Template to process and bind
     * @param {string} baseURI URL against which to resolve urls in
     *   style element cssText
     * @param {string} is Tag name (or type extension name) for this element
     * @param {string=} ext For type extensions, the tag name that was extended
     * @private
     */
    function finalizeTemplate(proto, template, baseURI, is, ext) {
      // support `include="module-name"`
      var cssText = Polymer.StyleGather.cssFromTemplate(template, baseURI) + Polymer.StyleGather.cssFromModuleImports(is);
      if (cssText) {
        var style = document.createElement('style');
        style.textContent = cssText;
        template.content.insertBefore(style, template.content.firstChild);
      }
      if (window.ShadyCSS) {
        window.ShadyCSS.prepareTemplate(template, is, ext);
      }
      proto._bindTemplate(template);
    }

    /**
     * @polymer
     * @mixinClass
     * @unrestricted
     * @implements {Polymer_ElementMixin}
     */

    var PolymerElement = function (_polymerElementBase) {
      _inherits(PolymerElement, _polymerElementBase);

      function PolymerElement() {
        _classCallCheck(this, PolymerElement);

        return _possibleConstructorReturn(this, (PolymerElement.__proto__ || Object.getPrototypeOf(PolymerElement)).apply(this, arguments));
      }

      _createClass(PolymerElement, [{
        key: '_initializeProperties',


        /**
         * Overrides the default `Polymer.PropertyAccessors` to ensure class
         * metaprogramming related to property accessors and effects has
         * completed (calls `finalize`).
         *
         * It also initializes any property defaults provided via `value` in
         * `properties` metadata.
         *
         * @override
         * @suppress {invalidCasts}
         */
        value: function _initializeProperties() {
          Polymer.telemetry.instanceCount++;
          this.constructor.finalize();
          var importPath = this.constructor.importPath;
          // note: finalize template when we have access to `localName` to
          // avoid dependence on `is` for polyfilling styling.
          if (this._template && !this._template.__polymerFinalized) {
            this._template.__polymerFinalized = true;
            var baseURI = importPath ? Polymer.ResolveUrl.resolveUrl(importPath) : '';
            finalizeTemplate( /** @type {!PolymerElement} */this.__proto__, this._template, baseURI,
            /**@type {!HTMLElement}*/this.localName);
          }
          _get(PolymerElement.prototype.__proto__ || Object.getPrototypeOf(PolymerElement.prototype), '_initializeProperties', this).call(this);
          // set path defaults
          this.rootPath = Polymer.rootPath;
          this.importPath = importPath;
          // apply property defaults...
          var p$ = propertyDefaultsForClass(this.constructor);
          if (!p$) {
            return;
          }
          for (var p in p$) {
            var info = p$[p];
            // Don't set default value if there is already an own property, which
            // happens when a `properties` property with default but no effects had
            // a property set (e.g. bound) by its host before upgrade
            if (!this.hasOwnProperty(p)) {
              var value = typeof info.value == 'function' ? info.value.call(this) : info.value;
              // Set via `_setProperty` if there is an accessor, to enable
              // initializing readOnly property defaults
              if (this._hasAccessor(p)) {
                this._setPendingProperty(p, value, true);
              } else {
                this[p] = value;
              }
            }
          }
        }

        /**
         * Provides a default implementation of the standard Custom Elements
         * `connectedCallback`.
         *
         * The default implementation enables the property effects system and
         * flushes any pending properties, and updates shimmed CSS properties
         * when using the ShadyCSS scoping/custom properties polyfill.
         *
         * @suppress {invalidCasts}
         */

      }, {
        key: 'connectedCallback',
        value: function connectedCallback() {
          if (window.ShadyCSS && this._template) {
            window.ShadyCSS.styleElement( /** @type {!HTMLElement} */this);
          }
          this._enableProperties();
        }

        /**
         * Provides a default implementation of the standard Custom Elements
         * `disconnectedCallback`.
         */

      }, {
        key: 'disconnectedCallback',
        value: function disconnectedCallback() {}

        /**
         * Stamps the element template.
         *
         * @override
         */

      }, {
        key: 'ready',
        value: function ready() {
          if (this._template) {
            this.root = this._stampTemplate(this._template);
            this.$ = this.root.$;
          }
          _get(PolymerElement.prototype.__proto__ || Object.getPrototypeOf(PolymerElement.prototype), 'ready', this).call(this);
        }

        /**
         * Implements `PropertyEffects`'s `_readyClients` call. Attaches
         * element dom by calling `_attachDom` with the dom stamped from the
         * element's template via `_stampTemplate`. Note that this allows
         * client dom to be attached to the element prior to any observers
         * running.
         *
         * @override
         */

      }, {
        key: '_readyClients',
        value: function _readyClients() {
          if (this._template) {
            this.root = this._attachDom(this.root);
          }
          // The super._readyClients here sets the clients initialized flag.
          // We must wait to do this until after client dom is created/attached
          // so that this flag can be checked to prevent notifications fired
          // during this process from being handled before clients are ready.
          _get(PolymerElement.prototype.__proto__ || Object.getPrototypeOf(PolymerElement.prototype), '_readyClients', this).call(this);
        }

        /**
         * Attaches an element's stamped dom to itself. By default,
         * this method creates a `shadowRoot` and adds the dom to it.
         * However, this method may be overridden to allow an element
         * to put its dom in another location.
         *
         * @throws {Error}
         * @suppress {missingReturn}
         * @param {NodeList} dom to attach to the element.
         * @return {Node} node to which the dom has been attached.
         */

      }, {
        key: '_attachDom',
        value: function _attachDom(dom) {
          if (this.attachShadow) {
            if (dom) {
              if (!this.shadowRoot) {
                this.attachShadow({ mode: 'open' });
              }
              this.shadowRoot.appendChild(dom);
              return this.shadowRoot;
            }
            return null;
          } else {
            throw new Error('ShadowDOM not available. ' +
            // TODO(sorvell): move to compile-time conditional when supported
            'Polymer.Element can create dom as children instead of in ' + 'ShadowDOM by setting `this.root = this;\` before \`ready\`.');
          }
        }

        /**
         * Provides a default implementation of the standard Custom Elements
         * `attributeChangedCallback`.
         *
         * By default, attributes declared in `properties` metadata are
         * deserialized using their `type` information to properties of the
         * same name.  "Dash-cased" attributes are deserialzed to "camelCase"
         * properties.
         *
         * @param {string} name Name of attribute.
         * @param {?string} old Old value of attribute.
         * @param {?string} value Current value of attribute.
         * @override
         */

      }, {
        key: 'attributeChangedCallback',
        value: function attributeChangedCallback(name, old, value) {
          if (old !== value) {
            var property = caseMap.dashToCamelCase(name);
            var type = propertiesForClass(this.constructor)[property].type;
            if (!this._hasReadOnlyEffect(property)) {
              this._attributeToProperty(name, value, type);
            }
          }
        }

        /**
         * When using the ShadyCSS scoping and custom property shim, causes all
         * shimmed styles in this element (and its subtree) to be updated
         * based on current custom property values.
         *
         * The optional parameter overrides inline custom property styles with an
         * object of properties where the keys are CSS properties, and the values
         * are strings.
         *
         * Example: `this.updateStyles({'--color': 'blue'})`
         *
         * These properties are retained unless a value of `null` is set.
         *
         * @param {Object=} properties Bag of custom property key/values to
         *   apply to this element.
         * @suppress {invalidCasts}
         */

      }, {
        key: 'updateStyles',
        value: function updateStyles(properties) {
          if (window.ShadyCSS) {
            window.ShadyCSS.styleSubtree( /** @type {!HTMLElement} */this, properties);
          }
        }

        /**
         * Rewrites a given URL relative to a base URL. The base URL defaults to
         * the original location of the document containing the `dom-module` for
         * this element. This method will return the same URL before and after
         * bundling.
         *
         * @param {string} url URL to resolve.
         * @param {string=} base Optional base URL to resolve against, defaults
         * to the element's `importPath`
         * @return {string} Rewritten URL relative to base
         */

      }, {
        key: 'resolveUrl',
        value: function resolveUrl(url, base) {
          if (!base && this.importPath) {
            base = Polymer.ResolveUrl.resolveUrl(this.importPath);
          }
          return Polymer.ResolveUrl.resolveUrl(url, base);
        }

        /**
         * Overrides `PropertyAccessors` to add map of dynamic functions on
         * template info, for consumption by `PropertyEffects` template binding
         * code. This map determines which method templates should have accessors
         * created for them.
         *
         * @override
         * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
         */

      }], [{
        key: 'finalize',


        /**
         * Called automatically when the first element instance is created to
         * ensure that class finalization work has been completed.
         * May be called by users to eagerly perform class finalization work
         * prior to the creation of the first element instance.
         *
         * Class finalization work generally includes meta-programming such as
         * creating property accessors and any property effect metadata needed for
         * the features used.
         *
         * @public
         */
        value: function finalize() {
          if (!hasClassFinalized(this)) {
            finalizeClassAndSuper(this);
          }
        }

        /**
         * Returns the template that will be stamped into this element's shadow root.
         *
         * If a `static get is()` getter is defined, the default implementation
         * will return the first `<template>` in a `dom-module` whose `id`
         * matches this element's `is`.
         *
         * Users may override this getter to return an arbitrary template
         * (in which case the `is` getter is unnecessary). The template returned
         * may be either an `HTMLTemplateElement` or a string that will be
         * automatically parsed into a template.
         *
         * Note that when subclassing, if the super class overrode the default
         * implementation and the subclass would like to provide an alternate
         * template via a `dom-module`, it should override this getter and
         * return `Polymer.DomModule.import(this.is, 'template')`.
         *
         * If a subclass would like to modify the super class template, it should
         * clone it rather than modify it in place.  If the getter does expensive
         * work such as cloning/modifying a template, it should memoize the
         * template for maximum performance:
         *
         *   let memoizedTemplate;
         *   class MySubClass extends MySuperClass {
         *     static get template() {
         *       if (!memoizedTemplate) {
         *         memoizedTemplate = super.template.cloneNode(true);
         *         let subContent = document.createElement('div');
         *         subContent.textContent = 'This came from MySubClass';
         *         memoizedTemplate.content.appendChild(subContent);
         *       }
         *       return memoizedTemplate;
         *     }
         *   }
         *
         * @return {HTMLTemplateElement|string} Template to be stamped
         */

      }, {
        key: '_parseTemplateContent',
        value: function _parseTemplateContent(template, templateInfo, nodeInfo) {
          templateInfo.dynamicFns = templateInfo.dynamicFns || propertiesForClass(this);
          return _get(PolymerElement.__proto__ || Object.getPrototypeOf(PolymerElement), '_parseTemplateContent', this).call(this, template, templateInfo, nodeInfo);
        }
      }, {
        key: 'observedAttributes',


        /**
         * Standard Custom Elements V1 API.  The default implementation returns
         * a list of dash-cased attributes based on a flattening of all properties
         * declared in `static get properties()` for this element and any
         * superclasses.
         *
         * @return {Array} Observed attribute list
         */
        get: function get() {
          if (!this.hasOwnProperty(JSCompiler_renameProperty('__observedAttributes', this))) {
            var list = [];
            var properties = propertiesForClass(this);
            for (var prop in properties) {
              list.push(Polymer.CaseMap.camelToDashCase(prop));
            }
            this.__observedAttributes = list;
          }
          return this.__observedAttributes;
        }
      }, {
        key: 'template',
        get: function get() {
          if (!this.hasOwnProperty(JSCompiler_renameProperty('_template', this))) {
            this._template = Polymer.DomModule && Polymer.DomModule.import(
            /** @type PolymerElementConstructor*/this.is, 'template') ||
            // note: implemented so a subclass can retrieve the super
            // template; call the super impl this way so that `this` points
            // to the superclass.
            Object.getPrototypeOf( /** @type PolymerElementConstructor*/this.prototype).constructor.template;
          }
          return this._template;
        }

        /**
         * Path matching the url from which the element was imported.
         * This path is used to resolve url's in template style cssText.
         * The `importPath` property is also set on element instances and can be
         * used to create bindings relative to the import path.
         * Defaults to the path matching the url containing a `dom-module` element
         * matching this element's static `is` property.
         * Note, this path should contain a trailing `/`.
         *
         * @return {string} The import path for this element class
         */

      }, {
        key: 'importPath',
        get: function get() {
          if (!this.hasOwnProperty(JSCompiler_renameProperty('_importPath', this))) {
            var module = Polymer.DomModule && Polymer.DomModule.import( /** @type PolymerElementConstructor */this.is);
            this._importPath = module ? module.assetpath : '' || Object.getPrototypeOf( /** @type PolymerElementConstructor*/this.prototype).constructor.importPath;
          }
          return this._importPath;
        }
      }]);

      return PolymerElement;
    }(polymerElementBase);

    return PolymerElement;
  });

  /**
   * Provides basic tracking of element definitions (registrations) and
   * instance counts.
   *
   * @namespace
   * @summary Provides basic tracking of element definitions (registrations) and
   * instance counts.
   */
  Polymer.telemetry = {
    /**
     * Total number of Polymer element instances created.
     * @type {number}
     */
    instanceCount: 0,
    /**
     * Array of Polymer element classes that have been finalized.
     * @type {Array<Polymer.Element>}
     */
    registrations: [],
    /**
     * @param {!PolymerElementConstructor} prototype Element prototype to log
     * @this {this}
     * @private
     */
    _regLog: function _regLog(prototype) {
      console.log('[' + prototype.is + ']: registered');
    },
    /**
     * Registers a class prototype for telemetry purposes.
     * @param {HTMLElement} prototype Element prototype to register
     * @this {this}
     * @protected
     */
    register: function register(prototype) {
      this.registrations.push(prototype);
      Polymer.log && this._regLog(prototype);
    },
    /**
     * Logs all elements registered with an `is` to the console.
     * @public
     * @this {this}
     */
    dumpRegistrations: function dumpRegistrations() {
      this.registrations.forEach(this._regLog);
    }
  };

  /**
   * When using the ShadyCSS scoping and custom property shim, causes all
   * shimmed `styles` (via `custom-style`) in the document (and its subtree)
   * to be updated based on current custom property values.
   *
   * The optional parameter overrides inline custom property styles with an
   * object of properties where the keys are CSS properties, and the values
   * are strings.
   *
   * Example: `Polymer.updateStyles({'--color': 'blue'})`
   *
   * These properties are retained unless a value of `null` is set.
   *
   * @param {Object=} props Bag of custom property key/values to
   *   apply to the document.
   */
  Polymer.updateStyles = function (props) {
    if (window.ShadyCSS) {
      window.ShadyCSS.styleDocument(props);
    }
  };
})();

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(1);

__webpack_require__(7);

/** @suppress {deprecated} */
(function () {
  'use strict';

  /**
   * Legacy settings.
   * @namespace
   * @memberof Polymer
   */

  var settings = Polymer.Settings || {};
  settings.useShadow = !window.ShadyDOM;
  settings.useNativeCSSProperties = Boolean(!window.ShadyCSS || window.ShadyCSS.nativeCss);
  settings.useNativeCustomElements = !window.customElements.polyfillWrapFlushCallback;

  /**
   * Sets the global, legacy settings.
   *
   * @deprecated
   * @memberof Polymer
   */
  Polymer.Settings = settings;

  /**
   * Globally settable property that is automatically assigned to
   * `Polymer.ElementMixin` instances, useful for binding in templates to
   * make URL's relative to an application's root.  Defaults to the main
   * document URL, but can be overridden by users.  It may be useful to set
   * `Polymer.rootPath` to provide a stable application mount path when
   * using client side routing.
   *
   * @memberof Polymer
   */
  var rootPath = Polymer.rootPath || Polymer.ResolveUrl.pathFromUrl(document.baseURI || window.location.href);

  Polymer.rootPath = rootPath;

  /**
   * Sets the global rootPath property used by `Polymer.ElementMixin` and
   * available via `Polymer.rootPath`.
   *
   * @memberof Polymer
   * @param {string} path The new root path
   */
  Polymer.setRootPath = function (path) {
    Polymer.rootPath = path;
  };
})();

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(7);

(function () {
  'use strict';

  var MODULE_STYLE_LINK_SELECTOR = 'link[rel=import][type~=css]';
  var INCLUDE_ATTR = 'include';

  function importModule(moduleId) {
    if (!Polymer.DomModule) {
      return null;
    }
    return Polymer.DomModule.import(moduleId);
  }

  /** @typedef {{assetpath: string}} */
  var templateWithAssetPath = void 0; // eslint-disable-line no-unused-vars

  /**
   * Module with utilities for collection CSS text from `<templates>`, external
   * stylesheets, and `dom-module`s.
   *
   * @namespace
   * @memberof Polymer
   * @summary Module with utilities for collection CSS text from various sources.
   */
  var StyleGather = {

    /**
     * Returns CSS text of styles in a space-separated list of `dom-module`s.
     *
     * @memberof Polymer.StyleGather
     * @param {string} moduleIds List of dom-module id's within which to
     * search for css.
     * @return {string} Concatenated CSS content from specified `dom-module`s
     * @this {StyleGather}
     */
    cssFromModules: function cssFromModules(moduleIds) {
      var modules = moduleIds.trim().split(' ');
      var cssText = '';
      for (var i = 0; i < modules.length; i++) {
        cssText += this.cssFromModule(modules[i]);
      }
      return cssText;
    },


    /**
     * Returns CSS text of styles in a given `dom-module`.  CSS in a `dom-module`
     * can come either from `<style>`s within the first `<template>`, or else
     * from one or more `<link rel="import" type="css">` links outside the
     * template.
     *
     * Any `<styles>` processed are removed from their original location.
     *
     * @memberof Polymer.StyleGather
     * @param {string} moduleId dom-module id to gather styles from
     * @return {string} Concatenated CSS content from specified `dom-module`
     * @this {StyleGather}
     */
    cssFromModule: function cssFromModule(moduleId) {
      var m = importModule(moduleId);
      if (m && m._cssText === undefined) {
        var cssText = '';
        // include css from the first template in the module
        var t = m.querySelector('template');
        if (t) {
          cssText += this.cssFromTemplate(t, /** @type {templateWithAssetPath }*/m.assetpath);
        }
        // module imports: <link rel="import" type="css">
        cssText += this.cssFromModuleImports(moduleId);
        m._cssText = cssText || null;
      }
      if (!m) {
        console.warn('Could not find style data in module named', moduleId);
      }
      return m && m._cssText || '';
    },


    /**
     * Returns CSS text of `<styles>` within a given template.
     *
     * Any `<styles>` processed are removed from their original location.
     *
     * @memberof Polymer.StyleGather
     * @param {HTMLTemplateElement} template Template to gather styles from
     * @param {string} baseURI Base URI to resolve the URL against
     * @return {string} Concatenated CSS content from specified template
     * @this {StyleGather}
     */
    cssFromTemplate: function cssFromTemplate(template, baseURI) {
      var cssText = '';
      // if element is a template, get content from its .content
      var e$ = template.content.querySelectorAll('style');
      for (var i = 0; i < e$.length; i++) {
        var e = e$[i];
        // support style sharing by allowing styles to "include"
        // other dom-modules that contain styling
        var include = e.getAttribute(INCLUDE_ATTR);
        if (include) {
          cssText += this.cssFromModules(include);
        }
        e.parentNode.removeChild(e);
        cssText += baseURI ? Polymer.ResolveUrl.resolveCss(e.textContent, baseURI) : e.textContent;
      }
      return cssText;
    },


    /**
     * Returns CSS text from stylsheets loaded via `<link rel="import" type="css">`
     * links within the specified `dom-module`.
     *
     * @memberof Polymer.StyleGather
     * @param {string} moduleId Id of `dom-module` to gather CSS from
     * @return {string} Concatenated CSS content from links in specified `dom-module`
     * @this {StyleGather}
     */
    cssFromModuleImports: function cssFromModuleImports(moduleId) {
      var cssText = '';
      var m = importModule(moduleId);
      if (!m) {
        return cssText;
      }
      var p$ = m.querySelectorAll(MODULE_STYLE_LINK_SELECTOR);
      for (var i = 0; i < p$.length; i++) {
        var p = p$[i];
        if (p.import) {
          var importDoc = p.import;
          // NOTE: polyfill affordance.
          // under the HTMLImports polyfill, there will be no 'body',
          // but the import pseudo-doc can be used directly.
          var container = importDoc.body ? importDoc.body : importDoc;
          cssText += Polymer.ResolveUrl.resolveCss(container.textContent, importDoc.baseURI);
        }
      }
      return cssText;
    }
  };

  Polymer.StyleGather = StyleGather;
})();

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

__webpack_require__(36);

__webpack_require__(16);

__webpack_require__(20);

__webpack_require__(3);

__webpack_require__(39);

__webpack_require__(40);

__webpack_require__(41);

__webpack_require__(42);

(function () {

  'use strict';

  var styleInterface = window.ShadyCSS;

  /**
   * Element class mixin that provides Polymer's "legacy" API intended to be
   * backward-compatible to the greatest extent possible with the API
   * found on the Polymer 1.x `Polymer.Base` prototype applied to all elements
   * defined using the `Polymer({...})` function.
   *
   * @mixinFunction
   * @polymer
   * @appliesMixin Polymer.ElementMixin
   * @appliesMixin Polymer.GestureEventListeners
   * @property isAttached {boolean} Set to `true` in this element's
   *   `connectedCallback` and `false` in `disconnectedCallback`
   * @memberof Polymer
   * @summary Element class mixin that provides Polymer's "legacy" API
   */
  Polymer.LegacyElementMixin = Polymer.dedupingMixin(function (base) {

    /**
     * @constructor
     * @extends {base}
     * @implements {Polymer_ElementMixin}
     * @implements {Polymer_GestureEventListeners}
     */
    var legacyElementBase = Polymer.GestureEventListeners(Polymer.ElementMixin(base));

    /**
     * Map of simple names to touch action names
     * @dict
     */
    var DIRECTION_MAP = {
      'x': 'pan-x',
      'y': 'pan-y',
      'none': 'none',
      'all': 'auto'
    };

    /**
     * @polymer
     * @mixinClass
     * @extends {legacyElementBase}
     * @implements {Polymer_LegacyElementMixin}
     * @unrestricted
     */

    var LegacyElement = function (_legacyElementBase) {
      _inherits(LegacyElement, _legacyElementBase);

      function LegacyElement() {
        _classCallCheck(this, LegacyElement);

        var _this = _possibleConstructorReturn(this, (LegacyElement.__proto__ || Object.getPrototypeOf(LegacyElement)).call(this));

        _this.root = _this;
        _this.created();
        return _this;
      }

      /**
       * Legacy callback called during the `constructor`, for overriding
       * by the user.
       */


      _createClass(LegacyElement, [{
        key: 'created',
        value: function created() {}

        /**
         * Provides an implementation of `connectedCallback`
         * which adds Polymer legacy API's `attached` method.
         * @override
         */

      }, {
        key: 'connectedCallback',
        value: function connectedCallback() {
          _get(LegacyElement.prototype.__proto__ || Object.getPrototypeOf(LegacyElement.prototype), 'connectedCallback', this).call(this);
          this.isAttached = true;
          this.attached();
        }

        /**
         * Legacy callback called during `connectedCallback`, for overriding
         * by the user.
         */

      }, {
        key: 'attached',
        value: function attached() {}

        /**
         * Provides an implementation of `disconnectedCallback`
         * which adds Polymer legacy API's `detached` method.
         * @override
         */

      }, {
        key: 'disconnectedCallback',
        value: function disconnectedCallback() {
          _get(LegacyElement.prototype.__proto__ || Object.getPrototypeOf(LegacyElement.prototype), 'disconnectedCallback', this).call(this);
          this.isAttached = false;
          this.detached();
        }

        /**
         * Legacy callback called during `disconnectedCallback`, for overriding
         * by the user.
         */

      }, {
        key: 'detached',
        value: function detached() {}

        /**
         * Provides an override implementation of `attributeChangedCallback`
         * which adds the Polymer legacy API's `attributeChanged` method.
         * @param {string} name Name of attribute.
         * @param {?string} old Old value of attribute.
         * @param {?string} value Current value of attribute.
         * @override
         */

      }, {
        key: 'attributeChangedCallback',
        value: function attributeChangedCallback(name, old, value) {
          if (old !== value) {
            _get(LegacyElement.prototype.__proto__ || Object.getPrototypeOf(LegacyElement.prototype), 'attributeChangedCallback', this).call(this, name, old, value);
            this.attributeChanged(name, old, value);
          }
        }

        /**
         * Legacy callback called during `attributeChangedChallback`, for overriding
         * by the user.
         * @param {string} name Name of attribute.
         * @param {?string} old Old value of attribute.
         * @param {?string} value Current value of attribute.
         */

      }, {
        key: 'attributeChanged',
        value: function attributeChanged(name, old, value) {} // eslint-disable-line no-unused-vars

        /**
         * Overrides the default `Polymer.PropertyEffects` implementation to
         * add support for class initialization via the `_registered` callback.
         * This is called only when the first instance of the element is created.
         *
         * @override
         */

      }, {
        key: '_initializeProperties',
        value: function _initializeProperties() {
          var proto = Object.getPrototypeOf(this);
          if (!proto.hasOwnProperty('__hasRegisterFinished')) {
            proto.__hasRegisterFinished = true;
            this._registered();
          }
          _get(LegacyElement.prototype.__proto__ || Object.getPrototypeOf(LegacyElement.prototype), '_initializeProperties', this).call(this);
        }

        /**
         * Called automatically when an element is initializing.
         * Users may override this method to perform class registration time
         * work. The implementation should ensure the work is performed
         * only once for the class.
         * @protected
         */

      }, {
        key: '_registered',
        value: function _registered() {}

        /**
         * Overrides the default `Polymer.PropertyEffects` implementation to
         * add support for installing `hostAttributes` and `listeners`.
         *
         * @override
         */

      }, {
        key: 'ready',
        value: function ready() {
          this._ensureAttributes();
          this._applyListeners();
          _get(LegacyElement.prototype.__proto__ || Object.getPrototypeOf(LegacyElement.prototype), 'ready', this).call(this);
        }

        /**
         * Ensures an element has required attributes. Called when the element
         * is being readied via `ready`. Users should override to set the
         * element's required attributes. The implementation should be sure
         * to check and not override existing attributes added by
         * the user of the element. Typically, setting attributes should be left
         * to the element user and not done here; reasonable exceptions include
         * setting aria roles and focusability.
         * @protected
         */

      }, {
        key: '_ensureAttributes',
        value: function _ensureAttributes() {}

        /**
         * Adds element event listeners. Called when the element
         * is being readied via `ready`. Users should override to
         * add any required element event listeners.
         * In performance critical elements, the work done here should be kept
         * to a minimum since it is done before the element is rendered. In
         * these elements, consider adding listeners asychronously so as not to
         * block render.
         * @protected
         */

      }, {
        key: '_applyListeners',
        value: function _applyListeners() {}

        /**
         * Converts a typed JavaScript value to a string.
         *
         * Note this method is provided as backward-compatible legacy API
         * only.  It is not directly called by any Polymer features. To customize
         * how properties are serialized to attributes for attribute bindings and
         * `reflectToAttribute: true` properties as well as this method, override
         * the `_serializeValue` method provided by `Polymer.PropertyAccessors`.
         *
         * @param {*} value Value to deserialize
         * @return {string | undefined} Serialized value
         */

      }, {
        key: 'serialize',
        value: function serialize(value) {
          return this._serializeValue(value);
        }

        /**
         * Converts a string to a typed JavaScript value.
         *
         * Note this method is provided as backward-compatible legacy API
         * only.  It is not directly called by any Polymer features.  To customize
         * how attributes are deserialized to properties for in
         * `attributeChangedCallback`, override `_deserializeValue` method
         * provided by `Polymer.PropertyAccessors`.
         *
         * @param {string} value String to deserialize
         * @param {*} type Type to deserialize the string to
         * @return {*} Returns the deserialized value in the `type` given.
         */

      }, {
        key: 'deserialize',
        value: function deserialize(value, type) {
          return this._deserializeValue(value, type);
        }

        /**
         * Serializes a property to its associated attribute.
         *
         * Note this method is provided as backward-compatible legacy API
         * only.  It is not directly called by any Polymer features.
         *
         * @param {string} property Property name to reflect.
         * @param {string=} attribute Attribute name to reflect.
         * @param {*=} value Property value to refect.
         */

      }, {
        key: 'reflectPropertyToAttribute',
        value: function reflectPropertyToAttribute(property, attribute, value) {
          this._propertyToAttribute(property, attribute, value);
        }

        /**
         * Sets a typed value to an HTML attribute on a node.
         *
         * Note this method is provided as backward-compatible legacy API
         * only.  It is not directly called by any Polymer features.
         *
         * @param {*} value Value to serialize.
         * @param {string} attribute Attribute name to serialize to.
         * @param {Element} node Element to set attribute to.
         */

      }, {
        key: 'serializeValueToAttribute',
        value: function serializeValueToAttribute(value, attribute, node) {
          this._valueToNodeAttribute( /** @type {Element} */node || this, value, attribute);
        }

        /**
         * Copies own properties (including accessor descriptors) from a source
         * object to a target object.
         *
         * @param {Object} prototype Target object to copy properties to.
         * @param {Object} api Source object to copy properties from.
         * @return {Object} prototype object that was passed as first argument.
         */

      }, {
        key: 'extend',
        value: function extend(prototype, api) {
          if (!(prototype && api)) {
            return prototype || api;
          }
          var n$ = Object.getOwnPropertyNames(api);
          for (var i = 0, n; i < n$.length && (n = n$[i]); i++) {
            var pd = Object.getOwnPropertyDescriptor(api, n);
            if (pd) {
              Object.defineProperty(prototype, n, pd);
            }
          }
          return prototype;
        }

        /**
         * Copies props from a source object to a target object.
         *
         * Note, this method uses a simple `for...in` strategy for enumerating
         * properties.  To ensure only `ownProperties` are copied from source
         * to target and that accessor implementations are copied, use `extend`.
         *
         * @param {Object} target Target object to copy properties to.
         * @param {Object} source Source object to copy properties from.
         * @return {Object} Target object that was passed as first argument.
         */

      }, {
        key: 'mixin',
        value: function mixin(target, source) {
          for (var i in source) {
            target[i] = source[i];
          }
          return target;
        }

        /**
         * Sets the prototype of an object.
         *
         * Note this method is provided as backward-compatible legacy API
         * only.  It is not directly called by any Polymer features.
         * @param {Object} object The object on which to set the prototype.
         * @param {Object} prototype The prototype that will be set on the given
         * `object`.
         * @return {Object} Returns the given `object` with its prototype set
         * to the given `prototype` object.
         */

      }, {
        key: 'chainObject',
        value: function chainObject(object, prototype) {
          if (object && prototype && object !== prototype) {
            object.__proto__ = prototype;
          }
          return object;
        }

        /* **** Begin Template **** */

        /**
         * Calls `importNode` on the `content` of the `template` specified and
         * returns a document fragment containing the imported content.
         *
         * @param {HTMLTemplateElement} template HTML template element to instance.
         * @return {DocumentFragment} Document fragment containing the imported
         *   template content.
        */

      }, {
        key: 'instanceTemplate',
        value: function instanceTemplate(template) {
          var content = this.constructor._contentForTemplate(template);
          var dom = /** @type {DocumentFragment} */
          document.importNode(content, true);
          return dom;
        }

        /* **** Begin Events **** */

        /**
         * Dispatches a custom event with an optional detail value.
         *
         * @param {string} type Name of event type.
         * @param {*=} detail Detail value containing event-specific
         *   payload.
         * @param {{ bubbles: (boolean|undefined), cancelable: (boolean|undefined), composed: (boolean|undefined) }=}
         *  options Object specifying options.  These may include:
         *  `bubbles` (boolean, defaults to `true`),
         *  `cancelable` (boolean, defaults to false), and
         *  `node` on which to fire the event (HTMLElement, defaults to `this`).
         * @return {Event} The new event that was fired.
         */

      }, {
        key: 'fire',
        value: function fire(type, detail, options) {
          options = options || {};
          detail = detail === null || detail === undefined ? {} : detail;
          var event = new Event(type, {
            bubbles: options.bubbles === undefined ? true : options.bubbles,
            cancelable: Boolean(options.cancelable),
            composed: options.composed === undefined ? true : options.composed
          });
          event.detail = detail;
          var node = options.node || this;
          node.dispatchEvent(event);
          return event;
        }

        /**
         * Convenience method to add an event listener on a given element,
         * late bound to a named method on this element.
         *
         * @param {Element} node Element to add event listener to.
         * @param {string} eventName Name of event to listen for.
         * @param {string} methodName Name of handler method on `this` to call.
         */

      }, {
        key: 'listen',
        value: function listen(node, eventName, methodName) {
          node = /** @type {Element} */node || this;
          var hbl = this.__boundListeners || (this.__boundListeners = new WeakMap());
          var bl = hbl.get(node);
          if (!bl) {
            bl = {};
            hbl.set(node, bl);
          }
          var key = eventName + methodName;
          if (!bl[key]) {
            bl[key] = this._addMethodEventListenerToNode(node, eventName, methodName, this);
          }
        }

        /**
         * Convenience method to remove an event listener from a given element,
         * late bound to a named method on this element.
         *
         * @param {Element} node Element to remove event listener from.
         * @param {string} eventName Name of event to stop listening to.
         * @param {string} methodName Name of handler method on `this` to not call
         anymore.
         */

      }, {
        key: 'unlisten',
        value: function unlisten(node, eventName, methodName) {
          node = /** @type {Element} */node || this;
          var bl = this.__boundListeners && this.__boundListeners.get(node);
          var key = eventName + methodName;
          var handler = bl && bl[key];
          if (handler) {
            this._removeEventListenerFromNode(node, eventName, handler);
            bl[key] = null;
          }
        }

        /**
         * Override scrolling behavior to all direction, one direction, or none.
         *
         * Valid scroll directions:
         *   - 'all': scroll in any direction
         *   - 'x': scroll only in the 'x' direction
         *   - 'y': scroll only in the 'y' direction
         *   - 'none': disable scrolling for this node
         *
         * @param {string=} direction Direction to allow scrolling
         * Defaults to `all`.
         * @param {Element=} node Element to apply scroll direction setting.
         * Defaults to `this`.
         */

      }, {
        key: 'setScrollDirection',
        value: function setScrollDirection(direction, node) {
          Polymer.Gestures.setTouchAction( /** @type {Element} */node || this, DIRECTION_MAP[direction] || 'auto');
        }
        /* **** End Events **** */

        /**
         * Convenience method to run `querySelector` on this local DOM scope.
         *
         * This function calls `Polymer.dom(this.root).querySelector(slctr)`.
         *
         * @param {string} slctr Selector to run on this local DOM scope
         * @return {Element} Element found by the selector, or null if not found.
         */

      }, {
        key: '$$',
        value: function $$(slctr) {
          return this.root.querySelector(slctr);
        }

        /**
         * Return the element whose local dom within which this element
         * is contained. This is a shorthand for
         * `this.getRootNode().host`.
         * @this {Element}
         */

      }, {
        key: 'distributeContent',


        /**
         * Force this element to distribute its children to its local dom.
         * This should not be necessary as of Polymer 2.0.2 and is provided only
         * for backwards compatibility.
         */
        value: function distributeContent() {
          if (window.ShadyDOM && this.shadowRoot) {
            ShadyDOM.flush();
          }
        }

        /**
         * Returns a list of nodes that are the effective childNodes. The effective
         * childNodes list is the same as the element's childNodes except that
         * any `<content>` elements are replaced with the list of nodes distributed
         * to the `<content>`, the result of its `getDistributedNodes` method.
         * @this {Element}
         * @return {Array<Node>} List of effctive child nodes.
         */

      }, {
        key: 'getEffectiveChildNodes',
        value: function getEffectiveChildNodes() {
          return (/** @type {Polymer.DomApi} */Polymer.dom(this).getEffectiveChildNodes()
          );
        }

        /**
         * Returns a list of nodes distributed within this element that match
         * `selector`. These can be dom children or elements distributed to
         * children that are insertion points.
         * @param {string} selector Selector to run.
         * @this {Element}
         * @return {Array<Node>} List of distributed elements that match selector.
         */

      }, {
        key: 'queryDistributedElements',
        value: function queryDistributedElements(selector) {
          return (/** @type {Polymer.DomApi} */Polymer.dom(this).queryDistributedElements(selector)
          );
        }

        /**
         * Returns a list of elements that are the effective children. The effective
         * children list is the same as the element's children except that
         * any `<content>` elements are replaced with the list of elements
         * distributed to the `<content>`.
         *
         * @return {Array<Node>} List of effctive children.
         */

      }, {
        key: 'getEffectiveChildren',
        value: function getEffectiveChildren() {
          var list = this.getEffectiveChildNodes();
          return list.filter(function ( /** @type {Node} */n) {
            return n.nodeType === Node.ELEMENT_NODE;
          });
        }

        /**
         * Returns a string of text content that is the concatenation of the
         * text content's of the element's effective childNodes (the elements
         * returned by <a href="#getEffectiveChildNodes>getEffectiveChildNodes</a>.
         *
         * @return {string} List of effctive children.
         */

      }, {
        key: 'getEffectiveTextContent',
        value: function getEffectiveTextContent() {
          var cn = this.getEffectiveChildNodes();
          var tc = [];
          for (var i = 0, c; c = cn[i]; i++) {
            if (c.nodeType !== Node.COMMENT_NODE) {
              tc.push(c.textContent);
            }
          }
          return tc.join('');
        }

        /**
         * Returns the first effective childNode within this element that
         * match `selector`. These can be dom child nodes or elements distributed
         * to children that are insertion points.
         * @param {string} selector Selector to run.
         * @return {Object<Node>} First effective child node that matches selector.
         */

      }, {
        key: 'queryEffectiveChildren',
        value: function queryEffectiveChildren(selector) {
          var e$ = this.queryDistributedElements(selector);
          return e$ && e$[0];
        }

        /**
         * Returns a list of effective childNodes within this element that
         * match `selector`. These can be dom child nodes or elements distributed
         * to children that are insertion points.
         * @param {string} selector Selector to run.
         * @return {Array<Node>} List of effective child nodes that match selector.
         */

      }, {
        key: 'queryAllEffectiveChildren',
        value: function queryAllEffectiveChildren(selector) {
          return this.queryDistributedElements(selector);
        }

        /**
         * Returns a list of nodes distributed to this element's `<slot>`.
         *
         * If this element contains more than one `<slot>` in its local DOM,
         * an optional selector may be passed to choose the desired content.
         *
         * @param {string=} slctr CSS selector to choose the desired
         *   `<slot>`.  Defaults to `content`.
         * @return {Array<Node>} List of distributed nodes for the `<slot>`.
         */

      }, {
        key: 'getContentChildNodes',
        value: function getContentChildNodes(slctr) {
          var content = this.root.querySelector(slctr || 'slot');
          return content ? /** @type {Polymer.DomApi} */Polymer.dom(content).getDistributedNodes() : [];
        }

        /**
         * Returns a list of element children distributed to this element's
         * `<slot>`.
         *
         * If this element contains more than one `<slot>` in its
         * local DOM, an optional selector may be passed to choose the desired
         * content.  This method differs from `getContentChildNodes` in that only
         * elements are returned.
         *
         * @param {string=} slctr CSS selector to choose the desired
         *   `<content>`.  Defaults to `content`.
         * @return {Array<HTMLElement>} List of distributed nodes for the
         *   `<slot>`.
         * @suppress {invalidCasts}
         */

      }, {
        key: 'getContentChildren',
        value: function getContentChildren(slctr) {
          return (/** @type {Array<HTMLElement>} */this.getContentChildNodes(slctr).filter(function (n) {
              return n.nodeType === Node.ELEMENT_NODE;
            })
          );
        }

        /**
         * Checks whether an element is in this element's light DOM tree.
         *
         * @param {?Node} node The element to be checked.
         * @this {Element}
         * @return {boolean} true if node is in this element's light DOM tree.
         */

      }, {
        key: 'isLightDescendant',
        value: function isLightDescendant(node) {
          return this !== node && this.contains(node) && this.getRootNode() === node.getRootNode();
        }

        /**
         * Checks whether an element is in this element's local DOM tree.
         *
         * @param {Element=} node The element to be checked.
         * @return {boolean} true if node is in this element's local DOM tree.
         */

      }, {
        key: 'isLocalDescendant',
        value: function isLocalDescendant(node) {
          return this.root === node.getRootNode();
        }

        // NOTE: should now be handled by ShadyCss library.

      }, {
        key: 'scopeSubtree',
        value: function scopeSubtree(container, shouldObserve) {} // eslint-disable-line no-unused-vars


        /**
         * Returns the computed style value for the given property.
         * @param {string} property The css property name.
         * @return {string} Returns the computed css property value for the given
         * `property`.
         */

      }, {
        key: 'getComputedStyleValue',
        value: function getComputedStyleValue(property) {
          return styleInterface.getComputedStyleValue(this, property);
        }

        // debounce

        /**
         * Call `debounce` to collapse multiple requests for a named task into
         * one invocation which is made after the wait time has elapsed with
         * no new request.  If no wait time is given, the callback will be called
         * at microtask timing (guaranteed before paint).
         *
         *     debouncedClickAction(e) {
         *       // will not call `processClick` more than once per 100ms
         *       this.debounce('click', function() {
         *        this.processClick();
         *       } 100);
         *     }
         *
         * @param {string} jobName String to indentify the debounce job.
         * @param {function()} callback Function that is called (with `this`
         *   context) when the wait time elapses.
         * @param {number} wait Optional wait time in milliseconds (ms) after the
         *   last signal that must elapse before invoking `callback`
         * @return {Object} Returns a debouncer object on which exists the
         * following methods: `isActive()` returns true if the debouncer is
         * active; `cancel()` cancels the debouncer if it is active;
         * `flush()` immediately invokes the debounced callback if the debouncer
         * is active.
         */

      }, {
        key: 'debounce',
        value: function debounce(jobName, callback, wait) {
          this._debouncers = this._debouncers || {};
          return this._debouncers[jobName] = Polymer.Debouncer.debounce(this._debouncers[jobName], wait > 0 ? Polymer.Async.timeOut.after(wait) : Polymer.Async.microTask, callback.bind(this));
        }

        /**
         * Returns whether a named debouncer is active.
         *
         * @param {string} jobName The name of the debouncer started with `debounce`
         * @return {boolean} Whether the debouncer is active (has not yet fired).
         */

      }, {
        key: 'isDebouncerActive',
        value: function isDebouncerActive(jobName) {
          this._debouncers = this._debouncers || {};
          var debouncer = this._debouncers[jobName];
          return !!(debouncer && debouncer.isActive());
        }

        /**
         * Immediately calls the debouncer `callback` and inactivates it.
         *
         * @param {string} jobName The name of the debouncer started with `debounce`
         */

      }, {
        key: 'flushDebouncer',
        value: function flushDebouncer(jobName) {
          this._debouncers = this._debouncers || {};
          var debouncer = this._debouncers[jobName];
          if (debouncer) {
            debouncer.flush();
          }
        }

        /**
         * Cancels an active debouncer.  The `callback` will not be called.
         *
         * @param {string} jobName The name of the debouncer started with `debounce`
         */

      }, {
        key: 'cancelDebouncer',
        value: function cancelDebouncer(jobName) {
          this._debouncers = this._debouncers || {};
          var debouncer = this._debouncers[jobName];
          if (debouncer) {
            debouncer.cancel();
          }
        }

        /**
         * Runs a callback function asyncronously.
         *
         * By default (if no waitTime is specified), async callbacks are run at
         * microtask timing, which will occur before paint.
         *
         * @param {Function} callback The callback function to run, bound to `this`.
         * @param {number=} waitTime Time to wait before calling the
         *   `callback`.  If unspecified or 0, the callback will be run at microtask
         *   timing (before paint).
         * @return {number} Handle that may be used to cancel the async job.
         */

      }, {
        key: 'async',
        value: function async(callback, waitTime) {
          return waitTime > 0 ? Polymer.Async.timeOut.run(callback.bind(this), waitTime) : ~Polymer.Async.microTask.run(callback.bind(this));
        }

        /**
         * Cancels an async operation started with `async`.
         *
         * @param {number} handle Handle returned from original `async` call to
         *   cancel.
         */

      }, {
        key: 'cancelAsync',
        value: function cancelAsync(handle) {
          handle < 0 ? Polymer.Async.microTask.cancel(~handle) : Polymer.Async.timeOut.cancel(handle);
        }

        // other

        /**
         * Convenience method for creating an element and configuring it.
         *
         * @param {string} tag HTML element tag to create.
         * @param {Object} props Object of properties to configure on the
         *    instance.
         * @return {Element} Newly created and configured element.
         */

      }, {
        key: 'create',
        value: function create(tag, props) {
          var elt = document.createElement(tag);
          if (props) {
            if (elt.setProperties) {
              elt.setProperties(props);
            } else {
              for (var n in props) {
                elt[n] = props[n];
              }
            }
          }
          return elt;
        }

        /**
         * Convenience method for importing an HTML document imperatively.
         *
         * This method creates a new `<link rel="import">` element with
         * the provided URL and appends it to the document to start loading.
         * In the `onload` callback, the `import` property of the `link`
         * element will contain the imported document contents.
         *
         * @param {string} href URL to document to load.
         * @param {Function} onload Callback to notify when an import successfully
         *   loaded.
         * @param {Function} onerror Callback to notify when an import
         *   unsuccessfully loaded.
         * @param {boolean} optAsync True if the import should be loaded `async`.
         *   Defaults to `false`.
         * @return {HTMLLinkElement} The link element for the URL to be loaded.
         */

      }, {
        key: 'importHref',
        value: function importHref(href, onload, onerror, optAsync) {
          // eslint-disable-line no-unused-vars
          var loadFn = onload ? onload.bind(this) : null;
          var errorFn = onerror ? onerror.bind(this) : null;
          return Polymer.importHref(href, loadFn, errorFn, optAsync);
        }

        /**
         * Polyfill for Element.prototype.matches, which is sometimes still
         * prefixed.
         *
         * @param {string} selector Selector to test.
         * @param {Element=} node Element to test the selector against.
         * @return {boolean} Whether the element matches the selector.
         */

      }, {
        key: 'elementMatches',
        value: function elementMatches(selector, node) {
          return Polymer.dom.matchesSelector( /** @type {!Element} */node || this, selector);
        }

        /**
         * Toggles an HTML attribute on or off.
         *
         * @param {string} name HTML attribute name
         * @param {boolean=} bool Boolean to force the attribute on or off.
         *    When unspecified, the state of the attribute will be reversed.
         * @param {Element=} node Node to target.  Defaults to `this`.
         */

      }, {
        key: 'toggleAttribute',
        value: function toggleAttribute(name, bool, node) {
          node = /** @type {Element} */node || this;
          if (arguments.length == 1) {
            bool = !node.hasAttribute(name);
          }
          if (bool) {
            node.setAttribute(name, '');
          } else {
            node.removeAttribute(name);
          }
        }

        /**
         * Toggles a CSS class on or off.
         *
         * @param {string} name CSS class name
         * @param {boolean=} bool Boolean to force the class on or off.
         *    When unspecified, the state of the class will be reversed.
         * @param {Element=} node Node to target.  Defaults to `this`.
         */

      }, {
        key: 'toggleClass',
        value: function toggleClass(name, bool, node) {
          node = /** @type {Element} */node || this;
          if (arguments.length == 1) {
            bool = !node.classList.contains(name);
          }
          if (bool) {
            node.classList.add(name);
          } else {
            node.classList.remove(name);
          }
        }

        /**
         * Cross-platform helper for setting an element's CSS `transform` property.
         *
         * @param {string} transformText Transform setting.
         * @param {Element=} node Element to apply the transform to.
         * Defaults to `this`
         */

      }, {
        key: 'transform',
        value: function transform(transformText, node) {
          node = /** @type {Element} */node || this;
          node.style.webkitTransform = transformText;
          node.style.transform = transformText;
        }

        /**
         * Cross-platform helper for setting an element's CSS `translate3d`
         * property.
         *
         * @param {number} x X offset.
         * @param {number} y Y offset.
         * @param {number} z Z offset.
         * @param {Element=} node Element to apply the transform to.
         * Defaults to `this`.
         */

      }, {
        key: 'translate3d',
        value: function translate3d(x, y, z, node) {
          node = /** @type {Element} */node || this;
          this.transform('translate3d(' + x + ',' + y + ',' + z + ')', node);
        }

        /**
         * Removes an item from an array, if it exists.
         *
         * If the array is specified by path, a change notification is
         * generated, so that observers, data bindings and computed
         * properties watching that path can update.
         *
         * If the array is passed directly, **no change
         * notification is generated**.
         *
         * @param {string | !Array<number|string>} arrayOrPath Path to array from which to remove the item
         *   (or the array itself).
         * @param {*} item Item to remove.
         * @return {Array} Array containing item removed.
         */

      }, {
        key: 'arrayDelete',
        value: function arrayDelete(arrayOrPath, item) {
          var index = void 0;
          if (Array.isArray(arrayOrPath)) {
            index = arrayOrPath.indexOf(item);
            if (index >= 0) {
              return arrayOrPath.splice(index, 1);
            }
          } else {
            var arr = Polymer.Path.get(this, arrayOrPath);
            index = arr.indexOf(item);
            if (index >= 0) {
              return this.splice(arrayOrPath, index, 1);
            }
          }
          return null;
        }

        // logging

        /**
         * Facades `console.log`/`warn`/`error` as override point.
         *
         * @param {string} level One of 'log', 'warn', 'error'
         * @param {Array} args Array of strings or objects to log
         */

      }, {
        key: '_logger',
        value: function _logger(level, args) {
          var _console;

          // accept ['foo', 'bar'] and [['foo', 'bar']]
          if (Array.isArray(args) && args.length === 1) {
            args = args[0];
          }
          switch (level) {
            case 'log':
            case 'warn':
            case 'error':
              (_console = console)[level].apply(_console, _toConsumableArray(args));
          }
        }

        /**
         * Facades `console.log` as an override point.
         *
         * @param {...*} args Array of strings or objects to log
         */

      }, {
        key: '_log',
        value: function _log() {
          for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          this._logger('log', args);
        }

        /**
         * Facades `console.warn` as an override point.
         *
         * @param {...*} args Array of strings or objects to log
         */

      }, {
        key: '_warn',
        value: function _warn() {
          for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }

          this._logger('warn', args);
        }

        /**
         * Facades `console.error` as an override point.
         *
         * @param {...*} args Array of strings or objects to log
         */

      }, {
        key: '_error',
        value: function _error() {
          for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
            args[_key3] = arguments[_key3];
          }

          this._logger('error', args);
        }

        /**
         * Formats a message using the element type an a method name.
         *
         * @param {string} methodName Method name to associate with message
         * @param {...*} args Array of strings or objects to log
         * @return {Array} Array with formatting information for `console`
         *   logging.
         */

      }, {
        key: '_logf',
        value: function _logf(methodName) {
          for (var _len4 = arguments.length, args = Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
            args[_key4 - 1] = arguments[_key4];
          }

          return ['[%s::%s]', this.is, methodName].concat(args);
        }
      }, {
        key: 'domHost',
        get: function get() {
          var root = this.getRootNode();
          return root instanceof DocumentFragment ? /** @type {ShadowRoot} */root.host : root;
        }
      }]);

      return LegacyElement;
    }(legacyElementBase);

    LegacyElement.prototype.is = '';

    return LegacyElement;
  });
})();

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

__webpack_require__(1);

__webpack_require__(3);

__webpack_require__(38);

(function () {

  'use strict';

  /**
   * @const {Polymer.Gestures}
   */

  var gestures = Polymer.Gestures;

  /**
   * Element class mixin that provides API for adding Polymer's cross-platform
   * gesture events to nodes.
   *
   * The API is designed to be compatible with override points implemented
   * in `Polymer.TemplateStamp` such that declarative event listeners in
   * templates will support gesture events when this mixin is applied along with
   * `Polymer.TemplateStamp`.
   *
   * @mixinFunction
   * @polymer
   * @memberof Polymer
   * @summary Element class mixin that provides API for adding Polymer's cross-platform
   * gesture events to nodes
   */
  Polymer.GestureEventListeners = Polymer.dedupingMixin(function (superClass) {

    /**
     * @polymer
     * @mixinClass
     * @implements {Polymer_GestureEventListeners}
     */
    var GestureEventListeners = function (_superClass) {
      _inherits(GestureEventListeners, _superClass);

      function GestureEventListeners() {
        _classCallCheck(this, GestureEventListeners);

        return _possibleConstructorReturn(this, (GestureEventListeners.__proto__ || Object.getPrototypeOf(GestureEventListeners)).apply(this, arguments));
      }

      _createClass(GestureEventListeners, [{
        key: '_addEventListenerToNode',
        value: function _addEventListenerToNode(node, eventName, handler) {
          if (!gestures.addListener(node, eventName, handler)) {
            _get(GestureEventListeners.prototype.__proto__ || Object.getPrototypeOf(GestureEventListeners.prototype), '_addEventListenerToNode', this).call(this, node, eventName, handler);
          }
        }
      }, {
        key: '_removeEventListenerFromNode',
        value: function _removeEventListenerFromNode(node, eventName, handler) {
          if (!gestures.removeListener(node, eventName, handler)) {
            _get(GestureEventListeners.prototype.__proto__ || Object.getPrototypeOf(GestureEventListeners.prototype), '_removeEventListenerFromNode', this).call(this, node, eventName, handler);
          }
        }
      }]);

      return GestureEventListeners;
    }(superClass);

    return GestureEventListeners;
  });
})();

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(1);

(function () {

  'use strict';

  function newSplice(index, removed, addedCount) {
    return {
      index: index,
      removed: removed,
      addedCount: addedCount
    };
  }

  var EDIT_LEAVE = 0;
  var EDIT_UPDATE = 1;
  var EDIT_ADD = 2;
  var EDIT_DELETE = 3;

  // Note: This function is *based* on the computation of the Levenshtein
  // "edit" distance. The one change is that "updates" are treated as two
  // edits - not one. With Array splices, an update is really a delete
  // followed by an add. By retaining this, we optimize for "keeping" the
  // maximum array items in the original array. For example:
  //
  //   'xxxx123' -> '123yyyy'
  //
  // With 1-edit updates, the shortest path would be just to update all seven
  // characters. With 2-edit updates, we delete 4, leave 3, and add 4. This
  // leaves the substring '123' intact.
  function calcEditDistances(current, currentStart, currentEnd, old, oldStart, oldEnd) {
    // "Deletion" columns
    var rowCount = oldEnd - oldStart + 1;
    var columnCount = currentEnd - currentStart + 1;
    var distances = new Array(rowCount);

    // "Addition" rows. Initialize null column.
    for (var i = 0; i < rowCount; i++) {
      distances[i] = new Array(columnCount);
      distances[i][0] = i;
    }

    // Initialize null row
    for (var j = 0; j < columnCount; j++) {
      distances[0][j] = j;
    }for (var _i = 1; _i < rowCount; _i++) {
      for (var _j = 1; _j < columnCount; _j++) {
        if (equals(current[currentStart + _j - 1], old[oldStart + _i - 1])) distances[_i][_j] = distances[_i - 1][_j - 1];else {
          var north = distances[_i - 1][_j] + 1;
          var west = distances[_i][_j - 1] + 1;
          distances[_i][_j] = north < west ? north : west;
        }
      }
    }

    return distances;
  }

  // This starts at the final weight, and walks "backward" by finding
  // the minimum previous weight recursively until the origin of the weight
  // matrix.
  function spliceOperationsFromEditDistances(distances) {
    var i = distances.length - 1;
    var j = distances[0].length - 1;
    var current = distances[i][j];
    var edits = [];
    while (i > 0 || j > 0) {
      if (i == 0) {
        edits.push(EDIT_ADD);
        j--;
        continue;
      }
      if (j == 0) {
        edits.push(EDIT_DELETE);
        i--;
        continue;
      }
      var northWest = distances[i - 1][j - 1];
      var west = distances[i - 1][j];
      var north = distances[i][j - 1];

      var min = void 0;
      if (west < north) min = west < northWest ? west : northWest;else min = north < northWest ? north : northWest;

      if (min == northWest) {
        if (northWest == current) {
          edits.push(EDIT_LEAVE);
        } else {
          edits.push(EDIT_UPDATE);
          current = northWest;
        }
        i--;
        j--;
      } else if (min == west) {
        edits.push(EDIT_DELETE);
        i--;
        current = west;
      } else {
        edits.push(EDIT_ADD);
        j--;
        current = north;
      }
    }

    edits.reverse();
    return edits;
  }

  /**
   * Splice Projection functions:
   *
   * A splice map is a representation of how a previous array of items
   * was transformed into a new array of items. Conceptually it is a list of
   * tuples of
   *
   *   <index, removed, addedCount>
   *
   * which are kept in ascending index order of. The tuple represents that at
   * the |index|, |removed| sequence of items were removed, and counting forward
   * from |index|, |addedCount| items were added.
   */

  /**
   * Lacking individual splice mutation information, the minimal set of
   * splices can be synthesized given the previous state and final state of an
   * array. The basic approach is to calculate the edit distance matrix and
   * choose the shortest path through it.
   *
   * Complexity: O(l * p)
   *   l: The length of the current array
   *   p: The length of the old array
   *
   * @param {Array} current The current "changed" array for which to
   * calculate splices.
   * @param {number} currentStart Starting index in the `current` array for
   * which splices are calculated.
   * @param {number} currentEnd Ending index in the `current` array for
   * which splices are calculated.
   * @param {Array} old The original "unchanged" array to compare `current`
   * against to determine splices.
   * @param {number} oldStart Starting index in the `old` array for
   * which splices are calculated.
   * @param {number} oldEnd Ending index in the `old` array for
   * which splices are calculated.
   * @return {Array} Returns an array of splice record objects. Each of these
   * contains: `index` the location where the splice occurred; `removed`
   * the array of removed items from this location; `addedCount` the number
   * of items added at this location.
   */
  function calcSplices(current, currentStart, currentEnd, old, oldStart, oldEnd) {
    var prefixCount = 0;
    var suffixCount = 0;
    var splice = void 0;

    var minLength = Math.min(currentEnd - currentStart, oldEnd - oldStart);
    if (currentStart == 0 && oldStart == 0) prefixCount = sharedPrefix(current, old, minLength);

    if (currentEnd == current.length && oldEnd == old.length) suffixCount = sharedSuffix(current, old, minLength - prefixCount);

    currentStart += prefixCount;
    oldStart += prefixCount;
    currentEnd -= suffixCount;
    oldEnd -= suffixCount;

    if (currentEnd - currentStart == 0 && oldEnd - oldStart == 0) return [];

    if (currentStart == currentEnd) {
      splice = newSplice(currentStart, [], 0);
      while (oldStart < oldEnd) {
        splice.removed.push(old[oldStart++]);
      }return [splice];
    } else if (oldStart == oldEnd) return [newSplice(currentStart, [], currentEnd - currentStart)];

    var ops = spliceOperationsFromEditDistances(calcEditDistances(current, currentStart, currentEnd, old, oldStart, oldEnd));

    splice = undefined;
    var splices = [];
    var index = currentStart;
    var oldIndex = oldStart;
    for (var i = 0; i < ops.length; i++) {
      switch (ops[i]) {
        case EDIT_LEAVE:
          if (splice) {
            splices.push(splice);
            splice = undefined;
          }

          index++;
          oldIndex++;
          break;
        case EDIT_UPDATE:
          if (!splice) splice = newSplice(index, [], 0);

          splice.addedCount++;
          index++;

          splice.removed.push(old[oldIndex]);
          oldIndex++;
          break;
        case EDIT_ADD:
          if (!splice) splice = newSplice(index, [], 0);

          splice.addedCount++;
          index++;
          break;
        case EDIT_DELETE:
          if (!splice) splice = newSplice(index, [], 0);

          splice.removed.push(old[oldIndex]);
          oldIndex++;
          break;
      }
    }

    if (splice) {
      splices.push(splice);
    }
    return splices;
  }

  function sharedPrefix(current, old, searchLength) {
    for (var i = 0; i < searchLength; i++) {
      if (!equals(current[i], old[i])) return i;
    }return searchLength;
  }

  function sharedSuffix(current, old, searchLength) {
    var index1 = current.length;
    var index2 = old.length;
    var count = 0;
    while (count < searchLength && equals(current[--index1], old[--index2])) {
      count++;
    }return count;
  }

  function calculateSplices(current, previous) {
    return calcSplices(current, 0, current.length, previous, 0, previous.length);
  }

  function equals(currentValue, previousValue) {
    return currentValue === previousValue;
  }

  /**
   * @namespace
   * @memberof Polymer
   * @summary Module that provides utilities for diffing arrays.
   */
  Polymer.ArraySplice = {
    /**
     * Returns an array of splice records indicating the minimum edits required
     * to transform the `previous` array into the `current` array.
     *
     * Splice records are ordered by index and contain the following fields:
     * - `index`: index where edit started
     * - `removed`: array of removed items from this index
     * - `addedCount`: number of items added at this index
     *
     * This function is based on the Levenshtein "minimum edit distance"
     * algorithm. Note that updates are treated as removal followed by addition.
     *
     * The worst-case time complexity of this algorithm is `O(l * p)`
     *   l: The length of the current array
     *   p: The length of the previous array
     *
     * However, the worst-case complexity is reduced by an `O(n)` optimization
     * to detect any shared prefix & suffix between the two arrays and only
     * perform the more expensive minimum edit distance calculation over the
     * non-shared portions of the arrays.
     *
     * @memberof Polymer.ArraySplice
     * @param {Array} current The "changed" array for which splices will be
     * calculated.
     * @param {Array} previous The "unchanged" original array to compare
     * `current` against to determine the splices.
     * @return {Array} Returns an array of splice record objects. Each of these
     * contains: `index` the location where the splice occurred; `removed`
     * the array of removed items from this location; `addedCount` the number
     * of items added at this location.
     */
    calculateSplices: calculateSplices
  };
})();

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

/**
 * `IronResizableBehavior` is a behavior that can be used in Polymer elements to
 * coordinate the flow of resize events between "resizers" (elements that control the
 * size or hidden state of their children) and "resizables" (elements that need to be
 * notified when they are resized or un-hidden by their parents in order to take
 * action on their new measurements).
 *
 * Elements that perform measurement should add the `IronResizableBehavior` behavior to
 * their element definition and listen for the `iron-resize` event on themselves.
 * This event will be fired when they become showing after having been hidden,
 * when they are resized explicitly by another resizable, or when the window has been
 * resized.
 *
 * Note, the `iron-resize` event is non-bubbling.
 *
 * @polymerBehavior Polymer.IronResizableBehavior
 * @demo demo/index.html
 **/
Polymer.IronResizableBehavior = {
  properties: {
    /**
     * The closest ancestor element that implements `IronResizableBehavior`.
     */
    _parentResizable: {
      type: Object,
      observer: '_parentResizableChanged'
    },

    /**
     * True if this element is currently notifying its descendant elements of
     * resize.
     */
    _notifyingDescendant: {
      type: Boolean,
      value: false
    }
  },

  listeners: {
    'iron-request-resize-notifications': '_onIronRequestResizeNotifications'
  },

  created: function created() {
    // We don't really need property effects on these, and also we want them
    // to be created before the `_parentResizable` observer fires:
    this._interestedResizables = [];
    this._boundNotifyResize = this.notifyResize.bind(this);
  },

  attached: function attached() {
    this._requestResizeNotifications();
  },

  detached: function detached() {
    if (this._parentResizable) {
      this._parentResizable.stopResizeNotificationsFor(this);
    } else {
      window.removeEventListener('resize', this._boundNotifyResize);
    }

    this._parentResizable = null;
  },

  /**
   * Can be called to manually notify a resizable and its descendant
   * resizables of a resize change.
   */
  notifyResize: function notifyResize() {
    if (!this.isAttached) {
      return;
    }

    this._interestedResizables.forEach(function (resizable) {
      if (this.resizerShouldNotify(resizable)) {
        this._notifyDescendant(resizable);
      }
    }, this);

    this._fireResize();
  },

  /**
   * Used to assign the closest resizable ancestor to this resizable
   * if the ancestor detects a request for notifications.
   */
  assignParentResizable: function assignParentResizable(parentResizable) {
    this._parentResizable = parentResizable;
  },

  /**
   * Used to remove a resizable descendant from the list of descendants
   * that should be notified of a resize change.
   */
  stopResizeNotificationsFor: function stopResizeNotificationsFor(target) {
    var index = this._interestedResizables.indexOf(target);

    if (index > -1) {
      this._interestedResizables.splice(index, 1);
      this.unlisten(target, 'iron-resize', '_onDescendantIronResize');
    }
  },

  /**
   * This method can be overridden to filter nested elements that should or
   * should not be notified by the current element. Return true if an element
   * should be notified, or false if it should not be notified.
   *
   * @param {HTMLElement} element A candidate descendant element that
   * implements `IronResizableBehavior`.
   * @return {boolean} True if the `element` should be notified of resize.
   */
  resizerShouldNotify: function resizerShouldNotify(element) {
    return true;
  },

  _onDescendantIronResize: function _onDescendantIronResize(event) {
    if (this._notifyingDescendant) {
      event.stopPropagation();
      return;
    }

    // NOTE(cdata): In ShadowDOM, event retargeting makes echoing of the
    // otherwise non-bubbling event "just work." We do it manually here for
    // the case where Polymer is not using shadow roots for whatever reason:
    if (!Polymer.Settings.useShadow) {
      this._fireResize();
    }
  },

  _fireResize: function _fireResize() {
    this.fire('iron-resize', null, {
      node: this,
      bubbles: false
    });
  },

  _onIronRequestResizeNotifications: function _onIronRequestResizeNotifications(event) {
    var target = /** @type {!EventTarget} */Polymer.dom(event).rootTarget;
    if (target === this) {
      return;
    }

    if (this._interestedResizables.indexOf(target) === -1) {
      this._interestedResizables.push(target);
      this.listen(target, 'iron-resize', '_onDescendantIronResize');
    }

    target.assignParentResizable(this);
    this._notifyDescendant(target);

    event.stopPropagation();
  },

  _parentResizableChanged: function _parentResizableChanged(parentResizable) {
    if (parentResizable) {
      window.removeEventListener('resize', this._boundNotifyResize);
    }
  },

  _notifyDescendant: function _notifyDescendant(descendant) {
    // NOTE(cdata): In IE10, attached is fired on children first, so it's
    // important not to notify them if the parent is not attached yet (or
    // else they will get redundantly notified when the parent attaches).
    if (!this.isAttached) {
      return;
    }

    this._notifyingDescendant = true;
    descendant.notifyResize();
    this._notifyingDescendant = false;
  },

  _requestResizeNotifications: function _requestResizeNotifications() {
    if (!this.isAttached) return;

    // NOTE(valdrin) In CustomElements v1 with native HTMLImports, the order
    // of imports affects the order of `attached` callbacks (see webcomponents/custom-elements#15).
    // This might cause a child to notify parents too early (as the parent
    // still has to be upgraded), resulting in a parent not able to keep track
    // of the `_interestedResizables`. To solve this, we wait for the document
    // to be done loading before firing the event.
    if (document.readyState === 'loading') {
      var _requestResizeNotifications = this._requestResizeNotifications.bind(this);
      document.addEventListener('readystatechange', function readystatechanged() {
        document.removeEventListener('readystatechange', readystatechanged);
        _requestResizeNotifications();
      });
    } else {
      this.fire('iron-request-resize-notifications', null, {
        node: this,
        bubbles: true,
        cancelable: true
      });

      if (!this._parentResizable) {
        window.addEventListener('resize', this._boundNotifyResize);
        this.notifyResize();
      }
    }
  }
};

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(4);

/**
 * While scrolling down, fade in the rear background layer and fade out the front background
 * layer (opacity interpolated based on scroll position).
 */
Polymer.AppLayout.registerEffect('blend-background', {
  /** @this Polymer.AppLayout.ElementWithBackground */
  setUp: function setUp() {
    var fx = {};
    fx.backgroundFrontLayer = this._getDOMRef('backgroundFrontLayer');
    fx.backgroundRearLayer = this._getDOMRef('backgroundRearLayer');
    fx.backgroundFrontLayer.style.willChange = 'opacity';
    fx.backgroundFrontLayer.style.transform = 'translateZ(0)';
    fx.backgroundRearLayer.style.willChange = 'opacity';
    fx.backgroundRearLayer.style.transform = 'translateZ(0)';
    fx.backgroundRearLayer.style.opacity = 0;
    this._fxBlendBackground = fx;
  },
  /** @this Polymer.AppLayout.ElementWithBackground */
  run: function run(p, y) {
    var fx = this._fxBlendBackground;
    fx.backgroundFrontLayer.style.opacity = 1 - p;
    fx.backgroundRearLayer.style.opacity = p;
  },
  /** @this Polymer.AppLayout.ElementWithBackground */
  tearDown: function tearDown() {
    delete this._fxBlendBackground;
  }
});

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(4);

/**
 * Toggles the shadow property in app-header when content is scrolled to create a sense of depth
 * between the element and the content underneath.
 */
Polymer.AppLayout.registerEffect('waterfall', {
  /**
   *  @this Polymer.AppLayout.ElementWithBackground
   */
  run: function run() {
    this.shadow = this.isOnScreen() && this.isContentBelow();
  }
});

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(4);

(function () {
  function interpolate(progress, points, fn, ctx) {
    fn.apply(ctx, points.map(function (point) {
      return point[0] + (point[1] - point[0]) * progress;
    }));
  }

  /**
   * Transform the font size of a designated title element between two values based on the scroll
   * position.
   */
  Polymer.AppLayout.registerEffect('resize-title', {
    /** @this Polymer.AppLayout.ElementWithBackground */
    setUp: function setUp() {
      var title = this._getDOMRef('mainTitle');
      var condensedTitle = this._getDOMRef('condensedTitle');

      if (!condensedTitle) {
        console.warn('Scroll effect `resize-title`: undefined `condensed-title`');
        return false;
      }
      if (!title) {
        console.warn('Scroll effect `resize-title`: undefined `main-title`');
        return false;
      }

      condensedTitle.style.willChange = 'opacity';
      condensedTitle.style.webkitTransform = 'translateZ(0)';
      condensedTitle.style.transform = 'translateZ(0)';
      condensedTitle.style.webkitTransformOrigin = 'left top';
      condensedTitle.style.transformOrigin = 'left top';

      title.style.willChange = 'opacity';
      title.style.webkitTransformOrigin = 'left top';
      title.style.transformOrigin = 'left top';
      title.style.webkitTransform = 'translateZ(0)';
      title.style.transform = 'translateZ(0)';

      var titleClientRect = title.getBoundingClientRect();
      var condensedTitleClientRect = condensedTitle.getBoundingClientRect();
      var fx = {};

      fx.scale = parseInt(window.getComputedStyle(condensedTitle)['font-size'], 10) / parseInt(window.getComputedStyle(title)['font-size'], 10);
      fx.titleDX = titleClientRect.left - condensedTitleClientRect.left;
      fx.titleDY = titleClientRect.top - condensedTitleClientRect.top;
      fx.condensedTitle = condensedTitle;
      fx.title = title;

      this._fxResizeTitle = fx;
    },
    /** @this PolymerElement */
    run: function run(p, y) {
      var fx = this._fxResizeTitle;
      if (!this.condenses) {
        y = 0;
      }
      if (p >= 1) {
        fx.title.style.opacity = 0;
        fx.condensedTitle.style.opacity = 1;
      } else {
        fx.title.style.opacity = 1;
        fx.condensedTitle.style.opacity = 0;
      }
      interpolate(Math.min(1, p), [[1, fx.scale], [0, -fx.titleDX], [y, y - fx.titleDY]], function (scale, translateX, translateY) {
        this.transform('translate(' + translateX + 'px, ' + translateY + 'px) ' + 'scale3d(' + scale + ', ' + scale + ', 1)', fx.title);
      }, this);
    },
    /** @this Polymer.AppLayout.ElementWithBackground */
    tearDown: function tearDown() {
      delete this._fxResizeTitle;
    }
  });
})();

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(4);

/**
 * Vertically translate the background based on a factor of the scroll position.
 */
Polymer.AppLayout.registerEffect('parallax-background', {
  /**
   * @param {{scalar: string}} config
   * @this Polymer.AppLayout.ElementWithBackground
   */
  setUp: function setUp(config) {
    var fx = {};
    var scalar = parseFloat(config.scalar);
    fx.background = this._getDOMRef('background');
    fx.backgroundFrontLayer = this._getDOMRef('backgroundFrontLayer');
    fx.backgroundRearLayer = this._getDOMRef('backgroundRearLayer');
    fx.deltaBg = fx.backgroundFrontLayer.offsetHeight - fx.background.offsetHeight;
    if (fx.deltaBg === 0) {
      if (isNaN(scalar)) {
        scalar = 0.8;
      }
      fx.deltaBg = this._dHeight * scalar;
    } else {
      if (isNaN(scalar)) {
        scalar = 1;
      }
      fx.deltaBg = fx.deltaBg * scalar;
    }
    this._fxParallaxBackground = fx;
  },
  /** @this Polymer.AppLayout.ElementWithBackground */
  run: function run(p, y) {
    var fx = this._fxParallaxBackground;
    this.transform('translate3d(0px, ' + fx.deltaBg * Math.min(1, p) + 'px, 0px)', fx.backgroundFrontLayer);
    if (fx.backgroundRearLayer) {
      this.transform('translate3d(0px, ' + fx.deltaBg * Math.min(1, p) + 'px, 0px)', fx.backgroundRearLayer);
    }
  },
  /** @this Polymer.AppLayout.ElementWithBackground */
  tearDown: function tearDown() {
    delete this._fxParallaxBackground;
  }
});

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

__webpack_require__(72);

/**
 * @polymerBehavior Polymer.IronSelectableBehavior
 */
Polymer.IronSelectableBehavior = {

  /**
   * Fired when iron-selector is activated (selected or deselected).
   * It is fired before the selected items are changed.
   * Cancel the event to abort selection.
   *
   * @event iron-activate
   */

  /**
   * Fired when an item is selected
   *
   * @event iron-select
   */

  /**
   * Fired when an item is deselected
   *
   * @event iron-deselect
   */

  /**
   * Fired when the list of selectable items changes (e.g., items are
   * added or removed). The detail of the event is a mutation record that
   * describes what changed.
   *
   * @event iron-items-changed
   */

  properties: {

    /**
     * If you want to use an attribute value or property of an element for
     * `selected` instead of the index, set this to the name of the attribute
     * or property. Hyphenated values are converted to camel case when used to
     * look up the property of a selectable element. Camel cased values are
     * *not* converted to hyphenated values for attribute lookup. It's
     * recommended that you provide the hyphenated form of the name so that
     * selection works in both cases. (Use `attr-or-property-name` instead of
     * `attrOrPropertyName`.)
     */
    attrForSelected: {
      type: String,
      value: null
    },

    /**
     * Gets or sets the selected element. The default is to use the index of the item.
     * @type {string|number}
     */
    selected: {
      type: String,
      notify: true
    },

    /**
     * Returns the currently selected item.
     *
     * @type {?Object}
     */
    selectedItem: {
      type: Object,
      readOnly: true,
      notify: true
    },

    /**
     * The event that fires from items when they are selected. Selectable
     * will listen for this event from items and update the selection state.
     * Set to empty string to listen to no events.
     */
    activateEvent: {
      type: String,
      value: 'tap',
      observer: '_activateEventChanged'
    },

    /**
     * This is a CSS selector string.  If this is set, only items that match the CSS selector
     * are selectable.
     */
    selectable: String,

    /**
     * The class to set on elements when selected.
     */
    selectedClass: {
      type: String,
      value: 'iron-selected'
    },

    /**
     * The attribute to set on elements when selected.
     */
    selectedAttribute: {
      type: String,
      value: null
    },

    /**
     * Default fallback if the selection based on selected with `attrForSelected`
     * is not found.
     */
    fallbackSelection: {
      type: String,
      value: null
    },

    /**
     * The list of items from which a selection can be made.
     */
    items: {
      type: Array,
      readOnly: true,
      notify: true,
      value: function value() {
        return [];
      }
    },

    /**
     * The set of excluded elements where the key is the `localName`
     * of the element that will be ignored from the item list.
     *
     * @default {template: 1}
     */
    _excludedLocalNames: {
      type: Object,
      value: function value() {
        return {
          'template': 1,
          'dom-bind': 1,
          'dom-if': 1,
          'dom-repeat': 1
        };
      }
    }
  },

  observers: ['_updateAttrForSelected(attrForSelected)', '_updateSelected(selected)', '_checkFallback(fallbackSelection)'],

  created: function created() {
    this._bindFilterItem = this._filterItem.bind(this);
    this._selection = new Polymer.IronSelection(this._applySelection.bind(this));
  },

  attached: function attached() {
    this._observer = this._observeItems(this);
    this._addListener(this.activateEvent);
  },

  detached: function detached() {
    if (this._observer) {
      Polymer.dom(this).unobserveNodes(this._observer);
    }
    this._removeListener(this.activateEvent);
  },

  /**
   * Returns the index of the given item.
   *
   * @method indexOf
   * @param {Object} item
   * @returns Returns the index of the item
   */
  indexOf: function indexOf(item) {
    return this.items.indexOf(item);
  },

  /**
   * Selects the given value.
   *
   * @method select
   * @param {string|number} value the value to select.
   */
  select: function select(value) {
    this.selected = value;
  },

  /**
   * Selects the previous item.
   *
   * @method selectPrevious
   */
  selectPrevious: function selectPrevious() {
    var length = this.items.length;
    var index = (Number(this._valueToIndex(this.selected)) - 1 + length) % length;
    this.selected = this._indexToValue(index);
  },

  /**
   * Selects the next item.
   *
   * @method selectNext
   */
  selectNext: function selectNext() {
    var index = (Number(this._valueToIndex(this.selected)) + 1) % this.items.length;
    this.selected = this._indexToValue(index);
  },

  /**
   * Selects the item at the given index.
   *
   * @method selectIndex
   */
  selectIndex: function selectIndex(index) {
    this.select(this._indexToValue(index));
  },

  /**
   * Force a synchronous update of the `items` property.
   *
   * NOTE: Consider listening for the `iron-items-changed` event to respond to
   * updates to the set of selectable items after updates to the DOM list and
   * selection state have been made.
   *
   * WARNING: If you are using this method, you should probably consider an
   * alternate approach. Synchronously querying for items is potentially
   * slow for many use cases. The `items` property will update asynchronously
   * on its own to reflect selectable items in the DOM.
   */
  forceSynchronousItemUpdate: function forceSynchronousItemUpdate() {
    if (this._observer && typeof this._observer.flush === "function") {
      // NOTE(bicknellr): `Polymer.dom.flush` above is no longer sufficient to
      // trigger `observeNodes` callbacks. Polymer 2.x returns an object from
      // `observeNodes` with a `flush` that synchronously gives the callback
      // any pending MutationRecords (retrieved with `takeRecords`). Any case
      // where ShadyDOM flushes were expected to synchronously trigger item
      // updates will now require calling `forceSynchronousItemUpdate`.
      this._observer.flush();
    } else {
      this._updateItems();
    }
  },

  // UNUSED, FOR API COMPATIBILITY
  get _shouldUpdateSelection() {
    return this.selected != null;
  },

  _checkFallback: function _checkFallback() {
    this._updateSelected();
  },

  _addListener: function _addListener(eventName) {
    this.listen(this, eventName, '_activateHandler');
  },

  _removeListener: function _removeListener(eventName) {
    this.unlisten(this, eventName, '_activateHandler');
  },

  _activateEventChanged: function _activateEventChanged(eventName, old) {
    this._removeListener(old);
    this._addListener(eventName);
  },

  _updateItems: function _updateItems() {
    var nodes = Polymer.dom(this).queryDistributedElements(this.selectable || '*');
    nodes = Array.prototype.filter.call(nodes, this._bindFilterItem);
    this._setItems(nodes);
  },

  _updateAttrForSelected: function _updateAttrForSelected() {
    if (this.selectedItem) {
      this.selected = this._valueForItem(this.selectedItem);
    }
  },

  _updateSelected: function _updateSelected() {
    this._selectSelected(this.selected);
  },

  _selectSelected: function _selectSelected(selected) {
    if (!this.items) {
      return;
    }

    var item = this._valueToItem(this.selected);
    if (item) {
      this._selection.select(item);
    } else {
      this._selection.clear();
    }
    // Check for items, since this array is populated only when attached
    // Since Number(0) is falsy, explicitly check for undefined
    if (this.fallbackSelection && this.items.length && this._selection.get() === undefined) {
      this.selected = this.fallbackSelection;
    }
  },

  _filterItem: function _filterItem(node) {
    return !this._excludedLocalNames[node.localName];
  },

  _valueToItem: function _valueToItem(value) {
    return value == null ? null : this.items[this._valueToIndex(value)];
  },

  _valueToIndex: function _valueToIndex(value) {
    if (this.attrForSelected) {
      for (var i = 0, item; item = this.items[i]; i++) {
        if (this._valueForItem(item) == value) {
          return i;
        }
      }
    } else {
      return Number(value);
    }
  },

  _indexToValue: function _indexToValue(index) {
    if (this.attrForSelected) {
      var item = this.items[index];
      if (item) {
        return this._valueForItem(item);
      }
    } else {
      return index;
    }
  },

  _valueForItem: function _valueForItem(item) {
    if (!item) {
      return null;
    }

    var propValue = item[Polymer.CaseMap.dashToCamelCase(this.attrForSelected)];
    return propValue != undefined ? propValue : item.getAttribute(this.attrForSelected);
  },

  _applySelection: function _applySelection(item, isSelected) {
    if (this.selectedClass) {
      this.toggleClass(this.selectedClass, isSelected, item);
    }
    if (this.selectedAttribute) {
      this.toggleAttribute(this.selectedAttribute, isSelected, item);
    }
    this._selectionChange();
    this.fire('iron-' + (isSelected ? 'select' : 'deselect'), { item: item });
  },

  _selectionChange: function _selectionChange() {
    this._setSelectedItem(this._selection.get());
  },

  // observe items change under the given node.
  _observeItems: function _observeItems(node) {
    return Polymer.dom(node).observeNodes(function (mutation) {
      this._updateItems();
      this._updateSelected();

      // Let other interested parties know about the change so that
      // we don't have to recreate mutation observers everywhere.
      this.fire('iron-items-changed', mutation, {
        bubbles: false,
        cancelable: false
      });
    });
  },

  _activateHandler: function _activateHandler(e) {
    var t = e.target;
    var items = this.items;
    while (t && t != this) {
      var i = items.indexOf(t);
      if (i >= 0) {
        var value = this._indexToValue(i);
        this._itemActivate(value, t);
        return;
      }
      t = t.parentNode;
    }
  },

  _itemActivate: function _itemActivate(value, item) {
    if (!this.fire('iron-activate', { selected: value, item: item }, { cancelable: true }).defaultPrevented) {
      this.select(value);
    }
  }

};

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

(function () {

  /**
   * @constructor
   * @param {{type: (string|null), key: (string|null), value: *}} options
   */
  function IronMeta(options) {
    this.type = options && options.type || 'default';
    this.key = options && options.key;
    if ('value' in options) {
      this.value = options.value;
    }
  }

  IronMeta.types = {};

  IronMeta.prototype = {
    get value() {
      var type = this.type;
      var key = this.key;

      if (type && key) {
        return IronMeta.types[type] && IronMeta.types[type][key];
      }
    },

    set value(value) {
      var type = this.type;
      var key = this.key;

      if (type && key) {
        type = IronMeta.types[type] = IronMeta.types[type] || {};
        if (value == null) {
          delete type[key];
        } else {
          type[key] = value;
        }
      }
    },

    get list() {
      var type = this.type;

      if (type) {
        return Object.keys(IronMeta.types[this.type]).map(function (key) {
          return metaDatas[this.type][key];
        }, this);
      }
    },

    byKey: function byKey(key) {
      this.key = key;
      return this.value;
    }
  };

  Polymer.IronMeta = IronMeta;

  var metaDatas = Polymer.IronMeta.types;

  Polymer({

    is: 'iron-meta',

    properties: {

      /**
       * The type of meta-data.  All meta-data of the same type is stored
       * together.
       * @type {string}
       */
      type: {
        type: String,
        value: 'default'
      },

      /**
       * The key used to store `value` under the `type` namespace.
       * @type {?string}
       */
      key: {
        type: String
      },

      /**
       * The meta-data to store or retrieve.
       * @type {*}
       */
      value: {
        type: String,
        notify: true
      },

      /**
       * If true, `value` is set to the iron-meta instance itself.
       */
      self: {
        type: Boolean,
        observer: '_selfChanged'
      },

      __meta: {
        type: Boolean,
        computed: '__computeMeta(type, key, value)'
      }
    },

    hostAttributes: {
      hidden: true
    },

    __computeMeta: function __computeMeta(type, key, value) {
      var meta = new Polymer.IronMeta({
        type: type,
        key: key
      });

      if (value !== undefined && value !== meta.value) {
        meta.value = value;
      } else if (this.value !== meta.value) {
        this.value = meta.value;
      }

      return meta;
    },

    get list() {
      return this.__meta && this.__meta.list;
    },

    _selfChanged: function _selfChanged(self) {
      if (self) {
        this.value = this;
      }
    },

    /**
     * Retrieves meta data value by key.
     *
     * @method byKey
     * @param {string} key The key of the meta-data to be returned.
     * @return {*}
     */
    byKey: function byKey(key) {
      return new Polymer.IronMeta({
        type: this.type,
        key: key
      }).value;
    }
  });
})();

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

(function () {
  'use strict';

  /**
   * Chrome uses an older version of DOM Level 3 Keyboard Events
   *
   * Most keys are labeled as text, but some are Unicode codepoints.
   * Values taken from: http://www.w3.org/TR/2007/WD-DOM-Level-3-Events-20071221/keyset.html#KeySet-Set
   */

  var KEY_IDENTIFIER = {
    'U+0008': 'backspace',
    'U+0009': 'tab',
    'U+001B': 'esc',
    'U+0020': 'space',
    'U+007F': 'del'
  };

  /**
   * Special table for KeyboardEvent.keyCode.
   * KeyboardEvent.keyIdentifier is better, and KeyBoardEvent.key is even better
   * than that.
   *
   * Values from: https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent.keyCode#Value_of_keyCode
   */
  var KEY_CODE = {
    8: 'backspace',
    9: 'tab',
    13: 'enter',
    27: 'esc',
    33: 'pageup',
    34: 'pagedown',
    35: 'end',
    36: 'home',
    32: 'space',
    37: 'left',
    38: 'up',
    39: 'right',
    40: 'down',
    46: 'del',
    106: '*'
  };

  /**
   * MODIFIER_KEYS maps the short name for modifier keys used in a key
   * combo string to the property name that references those same keys
   * in a KeyboardEvent instance.
   */
  var MODIFIER_KEYS = {
    'shift': 'shiftKey',
    'ctrl': 'ctrlKey',
    'alt': 'altKey',
    'meta': 'metaKey'
  };

  /**
   * KeyboardEvent.key is mostly represented by printable character made by
   * the keyboard, with unprintable keys labeled nicely.
   *
   * However, on OS X, Alt+char can make a Unicode character that follows an
   * Apple-specific mapping. In this case, we fall back to .keyCode.
   */
  var KEY_CHAR = /[a-z0-9*]/;

  /**
   * Matches a keyIdentifier string.
   */
  var IDENT_CHAR = /U\+/;

  /**
   * Matches arrow keys in Gecko 27.0+
   */
  var ARROW_KEY = /^arrow/;

  /**
   * Matches space keys everywhere (notably including IE10's exceptional name
   * `spacebar`).
   */
  var SPACE_KEY = /^space(bar)?/;

  /**
   * Matches ESC key.
   *
   * Value from: http://w3c.github.io/uievents-key/#key-Escape
   */
  var ESC_KEY = /^escape$/;

  /**
   * Transforms the key.
   * @param {string} key The KeyBoardEvent.key
   * @param {Boolean} [noSpecialChars] Limits the transformation to
   * alpha-numeric characters.
   */
  function transformKey(key, noSpecialChars) {
    var validKey = '';
    if (key) {
      var lKey = key.toLowerCase();
      if (lKey === ' ' || SPACE_KEY.test(lKey)) {
        validKey = 'space';
      } else if (ESC_KEY.test(lKey)) {
        validKey = 'esc';
      } else if (lKey.length == 1) {
        if (!noSpecialChars || KEY_CHAR.test(lKey)) {
          validKey = lKey;
        }
      } else if (ARROW_KEY.test(lKey)) {
        validKey = lKey.replace('arrow', '');
      } else if (lKey == 'multiply') {
        // numpad '*' can map to Multiply on IE/Windows
        validKey = '*';
      } else {
        validKey = lKey;
      }
    }
    return validKey;
  }

  function transformKeyIdentifier(keyIdent) {
    var validKey = '';
    if (keyIdent) {
      if (keyIdent in KEY_IDENTIFIER) {
        validKey = KEY_IDENTIFIER[keyIdent];
      } else if (IDENT_CHAR.test(keyIdent)) {
        keyIdent = parseInt(keyIdent.replace('U+', '0x'), 16);
        validKey = String.fromCharCode(keyIdent).toLowerCase();
      } else {
        validKey = keyIdent.toLowerCase();
      }
    }
    return validKey;
  }

  function transformKeyCode(keyCode) {
    var validKey = '';
    if (Number(keyCode)) {
      if (keyCode >= 65 && keyCode <= 90) {
        // ascii a-z
        // lowercase is 32 offset from uppercase
        validKey = String.fromCharCode(32 + keyCode);
      } else if (keyCode >= 112 && keyCode <= 123) {
        // function keys f1-f12
        validKey = 'f' + (keyCode - 112 + 1);
      } else if (keyCode >= 48 && keyCode <= 57) {
        // top 0-9 keys
        validKey = String(keyCode - 48);
      } else if (keyCode >= 96 && keyCode <= 105) {
        // num pad 0-9
        validKey = String(keyCode - 96);
      } else {
        validKey = KEY_CODE[keyCode];
      }
    }
    return validKey;
  }

  /**
    * Calculates the normalized key for a KeyboardEvent.
    * @param {KeyboardEvent} keyEvent
    * @param {Boolean} [noSpecialChars] Set to true to limit keyEvent.key
    * transformation to alpha-numeric chars. This is useful with key
    * combinations like shift + 2, which on FF for MacOS produces
    * keyEvent.key = @
    * To get 2 returned, set noSpecialChars = true
    * To get @ returned, set noSpecialChars = false
   */
  function normalizedKeyForEvent(keyEvent, noSpecialChars) {
    // Fall back from .key, to .detail.key for artifical keyboard events,
    // and then to deprecated .keyIdentifier and .keyCode.
    if (keyEvent.key) {
      return transformKey(keyEvent.key, noSpecialChars);
    }
    if (keyEvent.detail && keyEvent.detail.key) {
      return transformKey(keyEvent.detail.key, noSpecialChars);
    }
    return transformKeyIdentifier(keyEvent.keyIdentifier) || transformKeyCode(keyEvent.keyCode) || '';
  }

  function keyComboMatchesEvent(keyCombo, event) {
    // For combos with modifiers we support only alpha-numeric keys
    var keyEvent = normalizedKeyForEvent(event, keyCombo.hasModifiers);
    return keyEvent === keyCombo.key && (!keyCombo.hasModifiers || !!event.shiftKey === !!keyCombo.shiftKey && !!event.ctrlKey === !!keyCombo.ctrlKey && !!event.altKey === !!keyCombo.altKey && !!event.metaKey === !!keyCombo.metaKey);
  }

  function parseKeyComboString(keyComboString) {
    if (keyComboString.length === 1) {
      return {
        combo: keyComboString,
        key: keyComboString,
        event: 'keydown'
      };
    }
    return keyComboString.split('+').reduce(function (parsedKeyCombo, keyComboPart) {
      var eventParts = keyComboPart.split(':');
      var keyName = eventParts[0];
      var event = eventParts[1];

      if (keyName in MODIFIER_KEYS) {
        parsedKeyCombo[MODIFIER_KEYS[keyName]] = true;
        parsedKeyCombo.hasModifiers = true;
      } else {
        parsedKeyCombo.key = keyName;
        parsedKeyCombo.event = event || 'keydown';
      }

      return parsedKeyCombo;
    }, {
      combo: keyComboString.split(':').shift()
    });
  }

  function parseEventString(eventString) {
    return eventString.trim().split(' ').map(function (keyComboString) {
      return parseKeyComboString(keyComboString);
    });
  }

  /**
   * `Polymer.IronA11yKeysBehavior` provides a normalized interface for processing
   * keyboard commands that pertain to [WAI-ARIA best practices](http://www.w3.org/TR/wai-aria-practices/#kbd_general_binding).
   * The element takes care of browser differences with respect to Keyboard events
   * and uses an expressive syntax to filter key presses.
   *
   * Use the `keyBindings` prototype property to express what combination of keys
   * will trigger the callback. A key binding has the format
   * `"KEY+MODIFIER:EVENT": "callback"` (`"KEY": "callback"` or
   * `"KEY:EVENT": "callback"` are valid as well). Some examples:
   *
   *      keyBindings: {
   *        'space': '_onKeydown', // same as 'space:keydown'
   *        'shift+tab': '_onKeydown',
   *        'enter:keypress': '_onKeypress',
   *        'esc:keyup': '_onKeyup'
   *      }
   *
   * The callback will receive with an event containing the following information in `event.detail`:
   *
   *      _onKeydown: function(event) {
   *        console.log(event.detail.combo); // KEY+MODIFIER, e.g. "shift+tab"
   *        console.log(event.detail.key); // KEY only, e.g. "tab"
   *        console.log(event.detail.event); // EVENT, e.g. "keydown"
   *        console.log(event.detail.keyboardEvent); // the original KeyboardEvent
   *      }
   *
   * Use the `keyEventTarget` attribute to set up event handlers on a specific
   * node.
   *
   * See the [demo source code](https://github.com/PolymerElements/iron-a11y-keys-behavior/blob/master/demo/x-key-aware.html)
   * for an example.
   *
   * @demo demo/index.html
   * @polymerBehavior
   */
  Polymer.IronA11yKeysBehavior = {
    properties: {
      /**
       * The EventTarget that will be firing relevant KeyboardEvents. Set it to
       * `null` to disable the listeners.
       * @type {?EventTarget}
       */
      keyEventTarget: {
        type: Object,
        value: function value() {
          return this;
        }
      },

      /**
       * If true, this property will cause the implementing element to
       * automatically stop propagation on any handled KeyboardEvents.
       */
      stopKeyboardEventPropagation: {
        type: Boolean,
        value: false
      },

      _boundKeyHandlers: {
        type: Array,
        value: function value() {
          return [];
        }
      },

      // We use this due to a limitation in IE10 where instances will have
      // own properties of everything on the "prototype".
      _imperativeKeyBindings: {
        type: Object,
        value: function value() {
          return {};
        }
      }
    },

    observers: ['_resetKeyEventListeners(keyEventTarget, _boundKeyHandlers)'],

    /**
     * To be used to express what combination of keys  will trigger the relative
     * callback. e.g. `keyBindings: { 'esc': '_onEscPressed'}`
     * @type {!Object}
     */
    keyBindings: {},

    registered: function registered() {
      this._prepKeyBindings();
    },

    attached: function attached() {
      this._listenKeyEventListeners();
    },

    detached: function detached() {
      this._unlistenKeyEventListeners();
    },

    /**
     * Can be used to imperatively add a key binding to the implementing
     * element. This is the imperative equivalent of declaring a keybinding
     * in the `keyBindings` prototype property.
     *
     * @param {string} eventString
     * @param {string} handlerName
     */
    addOwnKeyBinding: function addOwnKeyBinding(eventString, handlerName) {
      this._imperativeKeyBindings[eventString] = handlerName;
      this._prepKeyBindings();
      this._resetKeyEventListeners();
    },

    /**
     * When called, will remove all imperatively-added key bindings.
     */
    removeOwnKeyBindings: function removeOwnKeyBindings() {
      this._imperativeKeyBindings = {};
      this._prepKeyBindings();
      this._resetKeyEventListeners();
    },

    /**
     * Returns true if a keyboard event matches `eventString`.
     *
     * @param {KeyboardEvent} event
     * @param {string} eventString
     * @return {boolean}
     */
    keyboardEventMatchesKeys: function keyboardEventMatchesKeys(event, eventString) {
      var keyCombos = parseEventString(eventString);
      for (var i = 0; i < keyCombos.length; ++i) {
        if (keyComboMatchesEvent(keyCombos[i], event)) {
          return true;
        }
      }
      return false;
    },

    _collectKeyBindings: function _collectKeyBindings() {
      var keyBindings = this.behaviors.map(function (behavior) {
        return behavior.keyBindings;
      });

      if (keyBindings.indexOf(this.keyBindings) === -1) {
        keyBindings.push(this.keyBindings);
      }

      return keyBindings;
    },

    _prepKeyBindings: function _prepKeyBindings() {
      this._keyBindings = {};

      this._collectKeyBindings().forEach(function (keyBindings) {
        for (var eventString in keyBindings) {
          this._addKeyBinding(eventString, keyBindings[eventString]);
        }
      }, this);

      for (var eventString in this._imperativeKeyBindings) {
        this._addKeyBinding(eventString, this._imperativeKeyBindings[eventString]);
      }

      // Give precedence to combos with modifiers to be checked first.
      for (var eventName in this._keyBindings) {
        this._keyBindings[eventName].sort(function (kb1, kb2) {
          var b1 = kb1[0].hasModifiers;
          var b2 = kb2[0].hasModifiers;
          return b1 === b2 ? 0 : b1 ? -1 : 1;
        });
      }
    },

    _addKeyBinding: function _addKeyBinding(eventString, handlerName) {
      parseEventString(eventString).forEach(function (keyCombo) {
        this._keyBindings[keyCombo.event] = this._keyBindings[keyCombo.event] || [];

        this._keyBindings[keyCombo.event].push([keyCombo, handlerName]);
      }, this);
    },

    _resetKeyEventListeners: function _resetKeyEventListeners() {
      this._unlistenKeyEventListeners();

      if (this.isAttached) {
        this._listenKeyEventListeners();
      }
    },

    _listenKeyEventListeners: function _listenKeyEventListeners() {
      if (!this.keyEventTarget) {
        return;
      }
      Object.keys(this._keyBindings).forEach(function (eventName) {
        var keyBindings = this._keyBindings[eventName];
        var boundKeyHandler = this._onKeyBindingEvent.bind(this, keyBindings);

        this._boundKeyHandlers.push([this.keyEventTarget, eventName, boundKeyHandler]);

        this.keyEventTarget.addEventListener(eventName, boundKeyHandler);
      }, this);
    },

    _unlistenKeyEventListeners: function _unlistenKeyEventListeners() {
      var keyHandlerTuple;
      var keyEventTarget;
      var eventName;
      var boundKeyHandler;

      while (this._boundKeyHandlers.length) {
        // My kingdom for block-scope binding and destructuring assignment..
        keyHandlerTuple = this._boundKeyHandlers.pop();
        keyEventTarget = keyHandlerTuple[0];
        eventName = keyHandlerTuple[1];
        boundKeyHandler = keyHandlerTuple[2];

        keyEventTarget.removeEventListener(eventName, boundKeyHandler);
      }
    },

    _onKeyBindingEvent: function _onKeyBindingEvent(keyBindings, event) {
      if (this.stopKeyboardEventPropagation) {
        event.stopPropagation();
      }

      // if event has been already prevented, don't do anything
      if (event.defaultPrevented) {
        return;
      }

      for (var i = 0; i < keyBindings.length; i++) {
        var keyCombo = keyBindings[i][0];
        var handlerName = keyBindings[i][1];
        if (keyComboMatchesEvent(keyCombo, event)) {
          this._triggerKeyHandler(keyCombo, handlerName, event);
          // exit the loop if eventDefault was prevented
          if (event.defaultPrevented) {
            return;
          }
        }
      }
    },

    _triggerKeyHandler: function _triggerKeyHandler(keyCombo, handlerName, keyboardEvent) {
      var detail = Object.create(keyCombo);
      detail.keyboardEvent = keyboardEvent;
      var event = new CustomEvent(keyCombo.event, {
        detail: detail,
        cancelable: true
      });
      this[handlerName].call(this, event);
      if (event.defaultPrevented) {
        keyboardEvent.preventDefault();
      }
    }
  };
})();

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

__webpack_require__(6);

__webpack_require__(35);

__webpack_require__(55);

__webpack_require__(57);

__webpack_require__(60);

__webpack_require__(61);

__webpack_require__(65);

__webpack_require__(66);

__webpack_require__(70);

__webpack_require__(71);

__webpack_require__(73);

__webpack_require__(75);

__webpack_require__(84);

var RegisterHtmlTemplate = __webpack_require__(2);

RegisterHtmlTemplate.register("<dom-module id=my-app> <template> <style>:host{--app-primary-color:#4285f4;--app-secondary-color:black;display:block}app-drawer-layout:not([narrow]) [drawer-toggle]{display:none}app-header{color:#fff;background-color:var(--app-primary-color)}app-header paper-icon-button{--paper-icon-button-ink-color:white}.drawer-list{margin:0 20px}.drawer-list a{display:block;padding:0 16px;text-decoration:none;color:var(--app-secondary-color);line-height:40px}.drawer-list a.iron-selected{color:#000;font-weight:700}</style> <app-location route={{route}} url-space-regex=^[[rootPath]]></app-location> <app-route route={{route}} pattern=[[rootPath]]:page data={{routeData}} tail={{subroute}}></app-route> <app-drawer-layout fullbleed=\"\"> <app-drawer id=drawer slot=drawer> <app-toolbar>Menu</app-toolbar> <iron-selector selected=[[page]] attr-for-selected=name class=drawer-list role=navigation> <a name=view1 href$=[[rootPath]]view1>View One</a> <a name=view2 href$=[[rootPath]]view2>View Two</a> <a name=view3 href$=[[rootPath]]view3>View Three</a> <a name=view4 href$=[[rootPath]]view4>View Four</a> </iron-selector> </app-drawer> <app-header-layout has-scrolling-region=\"\"> <app-header slot=header condenses=\"\" reveals=\"\" effects=waterfall> <app-toolbar> <paper-icon-button icon=my-icons:menu drawer-toggle=\"\"></paper-icon-button> <div main-title=\"\">My App</div> </app-toolbar> </app-header> <iron-pages selected=[[page]] attr-for-selected=name fallback-selection=view404 role=main> <my-view1 name=view1></my-view1> <my-view2 name=view2></my-view2> <my-view3 name=view3></my-view3> <my-view404 name=view404></my-view404> </iron-pages> </app-header-layout> </app-drawer-layout> </template> </dom-module>");

var MyApp = function (_Polymer$Element) {
  _inherits(MyApp, _Polymer$Element);

  _createClass(MyApp, null, [{
    key: 'is',
    get: function get() {
      return 'my-app';
    }
  }, {
    key: 'properties',
    get: function get() {
      return {
        page: {
          type: String,
          reflectToAttribute: true,
          observer: '_pageChanged'
        },
        routeData: Object,
        subroute: String,
        rootPath: {
          type: String,
          value: '/'
        },
        lazyPages: {
          type: Object,
          value: {
            view1: function view1() {
              __webpack_require__.e/* import() */(2).then(__webpack_require__.bind(null, 86));
            },
            view2: function view2() {
              __webpack_require__.e/* import() */(1).then(__webpack_require__.bind(null, 87));
            },
            view3: function view3() {
              __webpack_require__.e/* import() */(0).then(__webpack_require__.bind(null, 88));
            },
            view404: function view404() {
              __webpack_require__.e/* import() */(3).then(__webpack_require__.bind(null, 89));
            }
          }
        }
      };
    }
  }, {
    key: 'observers',
    get: function get() {
      return ['_routePageChanged(routeData.page)'];
    }
  }]);

  function MyApp() {
    _classCallCheck(this, MyApp);

    return _possibleConstructorReturn(this, (MyApp.__proto__ || Object.getPrototypeOf(MyApp)).call(this));
  }

  _createClass(MyApp, [{
    key: '_routePageChanged',
    value: function _routePageChanged(page) {
      // Polymer 2.0 will call with `undefined` on initialization.
      // Ignore until we are properly called with a string.
      if (page === undefined) {
        return;
      }

      // If no page was found in the route data, page will be an empty string.
      // Deault to 'view1' in that case.
      this.page = page || 'view1';

      // Close a non-persistent drawer when the page & route are changed.
      if (!this.$.drawer.persistent) {
        this.$.drawer.close();
      }
    }
  }, {
    key: '_pageChanged',
    value: function _pageChanged(page) {
      if (this.lazyPages[page]) {
        this.lazyPages[page]();
      } else {
        this._showPage404();
      }
    }
  }, {
    key: '_showPage404',
    value: function _showPage404() {
      this.page = 'view404';
    }
  }]);

  return MyApp;
}(Polymer.Element);

window.customElements.define(MyApp.is, MyApp);

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

__webpack_require__(1);

__webpack_require__(7);

(function () {
  'use strict';

  var modules = {};
  var lcModules = {};
  function findModule(id) {
    return modules[id] || lcModules[id.toLowerCase()];
  }

  function styleOutsideTemplateCheck(inst) {
    if (inst.querySelector('style')) {
      console.warn('dom-module %s has style outside template', inst.id);
    }
  }

  /**
   * The `dom-module` element registers the dom it contains to the name given
   * by the module's id attribute. It provides a unified database of dom
   * accessible via its static `import` API.
   *
   * A key use case of `dom-module` is for providing custom element `<template>`s
   * via HTML imports that are parsed by the native HTML parser, that can be
   * relocated during a bundling pass and still looked up by `id`.
   *
   * Example:
   *
   *     <dom-module id="foo">
   *       <img src="stuff.png">
   *     </dom-module>
   *
   * Then in code in some other location that cannot access the dom-module above
   *
   *     let img = document.createElement('dom-module').import('foo', 'img');
   *
   * @customElement
   * @extends HTMLElement
   * @memberof Polymer
   * @summary Custom element that provides a registry of relocatable DOM content
   *   by `id` that is agnostic to bundling.
   * @unrestricted
   */

  var DomModule = function (_HTMLElement) {
    _inherits(DomModule, _HTMLElement);

    function DomModule() {
      _classCallCheck(this, DomModule);

      return _possibleConstructorReturn(this, (DomModule.__proto__ || Object.getPrototypeOf(DomModule)).apply(this, arguments));
    }

    _createClass(DomModule, [{
      key: 'attributeChangedCallback',
      value: function attributeChangedCallback(name, old, value) {
        if (old !== value) {
          this.register();
        }
      }

      /**
       * The absolute URL of the original location of this `dom-module`.
       *
       * This value will differ from this element's `ownerDocument` in the
       * following ways:
       * - Takes into account any `assetpath` attribute added during bundling
       *   to indicate the original location relative to the bundled location
       * - Uses the HTMLImports polyfill's `importForElement` API to ensure
       *   the path is relative to the import document's location since
       *   `ownerDocument` is not currently polyfilled
       */

    }, {
      key: 'register',


      /**
       * Registers the dom-module at a given id. This method should only be called
       * when a dom-module is imperatively created. For
       * example, `document.createElement('dom-module').register('foo')`.
       * @param {string=} id The id at which to register the dom-module.
       */
      value: function register(id) {
        id = id || this.id;
        if (id) {
          this.id = id;
          // store id separate from lowercased id so that
          // in all cases mixedCase id will stored distinctly
          // and lowercase version is a fallback
          modules[id] = this;
          lcModules[id.toLowerCase()] = this;
          styleOutsideTemplateCheck(this);
        }
      }
    }, {
      key: 'assetpath',
      get: function get() {
        // Don't override existing assetpath.
        if (!this.__assetpath) {
          // note: assetpath set via an attribute must be relative to this
          // element's location; accomodate polyfilled HTMLImports
          var owner = window.HTMLImports && HTMLImports.importForElement ? HTMLImports.importForElement(this) || document : this.ownerDocument;
          var url = Polymer.ResolveUrl.resolveUrl(this.getAttribute('assetpath') || '', owner.baseURI);
          this.__assetpath = Polymer.ResolveUrl.pathFromUrl(url);
        }
        return this.__assetpath;
      }
    }], [{
      key: 'import',


      /**
       * Retrieves the element specified by the css `selector` in the module
       * registered by `id`. For example, this.import('foo', 'img');
       * @param {string} id The id of the dom-module in which to search.
       * @param {string=} selector The css selector by which to find the element.
       * @return {Element} Returns the element which matches `selector` in the
       * module registered at the specified `id`.
       */
      value: function _import(id, selector) {
        if (id) {
          var m = findModule(id);
          if (m && selector) {
            return m.querySelector(selector);
          }
          return m;
        }
        return null;
      }
    }, {
      key: 'observedAttributes',
      get: function get() {
        return ['id'];
      }
    }]);

    return DomModule;
  }(HTMLElement);

  DomModule.prototype['modules'] = modules;

  customElements.define('dom-module', DomModule);

  // export
  Polymer.DomModule = DomModule;
})();

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(1);

(function () {
  'use strict';

  /**
   * Module with utilities for manipulating structured data path strings.
   *
   * @namespace
   * @memberof Polymer
   * @summary Module with utilities for manipulating structured data path strings.
   */

  var Path = {

    /**
     * Returns true if the given string is a structured data path (has dots).
     *
     * Example:
     *
     * ```
     * Polymer.Path.isPath('foo.bar.baz') // true
     * Polymer.Path.isPath('foo')         // false
     * ```
     *
     * @memberof Polymer.Path
     * @param {string} path Path string
     * @return {boolean} True if the string contained one or more dots
     */
    isPath: function isPath(path) {
      return path.indexOf('.') >= 0;
    },

    /**
     * Returns the root property name for the given path.
     *
     * Example:
     *
     * ```
     * Polymer.Path.root('foo.bar.baz') // 'foo'
     * Polymer.Path.root('foo')         // 'foo'
     * ```
     *
     * @memberof Polymer.Path
     * @param {string} path Path string
     * @return {string} Root property name
     */
    root: function root(path) {
      var dotIndex = path.indexOf('.');
      if (dotIndex === -1) {
        return path;
      }
      return path.slice(0, dotIndex);
    },

    /**
     * Given `base` is `foo.bar`, `foo` is an ancestor, `foo.bar` is not
     * Returns true if the given path is an ancestor of the base path.
     *
     * Example:
     *
     * ```
     * Polymer.Path.isAncestor('foo.bar', 'foo')         // true
     * Polymer.Path.isAncestor('foo.bar', 'foo.bar')     // false
     * Polymer.Path.isAncestor('foo.bar', 'foo.bar.baz') // false
     * ```
     *
     * @memberof Polymer.Path
     * @param {string} base Path string to test against.
     * @param {string} path Path string to test.
     * @return {boolean} True if `path` is an ancestor of `base`.
     */
    isAncestor: function isAncestor(base, path) {
      //     base.startsWith(path + '.');
      return base.indexOf(path + '.') === 0;
    },

    /**
     * Given `base` is `foo.bar`, `foo.bar.baz` is an descendant
     *
     * Example:
     *
     * ```
     * Polymer.Path.isDescendant('foo.bar', 'foo.bar.baz') // true
     * Polymer.Path.isDescendant('foo.bar', 'foo.bar')     // false
     * Polymer.Path.isDescendant('foo.bar', 'foo')         // false
     * ```
     *
     * @memberof Polymer.Path
     * @param {string} base Path string to test against.
     * @param {string} path Path string to test.
     * @return {boolean} True if `path` is a descendant of `base`.
     */
    isDescendant: function isDescendant(base, path) {
      //     path.startsWith(base + '.');
      return path.indexOf(base + '.') === 0;
    },

    /**
     * Replaces a previous base path with a new base path, preserving the
     * remainder of the path.
     *
     * User must ensure `path` has a prefix of `base`.
     *
     * Example:
     *
     * ```
     * Polymer.Path.translate('foo.bar', 'zot' 'foo.bar.baz') // 'zot.baz'
     * ```
     *
     * @memberof Polymer.Path
     * @param {string} base Current base string to remove
     * @param {string} newBase New base string to replace with
     * @param {string} path Path to translate
     * @return {string} Translated string
     */
    translate: function translate(base, newBase, path) {
      return newBase + path.slice(base.length);
    },

    /**
     * @param {string} base Path string to test against
     * @param {string} path Path string to test
     * @return {boolean} True if `path` is equal to `base`
     * @this {Path}
     */
    matches: function matches(base, path) {
      return base === path || this.isAncestor(base, path) || this.isDescendant(base, path);
    },

    /**
     * Converts array-based paths to flattened path.  String-based paths
     * are returned as-is.
     *
     * Example:
     *
     * ```
     * Polymer.Path.normalize(['foo.bar', 0, 'baz'])  // 'foo.bar.0.baz'
     * Polymer.Path.normalize('foo.bar.0.baz')        // 'foo.bar.0.baz'
     * ```
     *
     * @memberof Polymer.Path
     * @param {string | !Array<string|number>} path Input path
     * @return {string} Flattened path
     */
    normalize: function normalize(path) {
      if (Array.isArray(path)) {
        var parts = [];
        for (var i = 0; i < path.length; i++) {
          var args = path[i].toString().split('.');
          for (var j = 0; j < args.length; j++) {
            parts.push(args[j]);
          }
        }
        return parts.join('.');
      } else {
        return path;
      }
    },

    /**
     * Splits a path into an array of property names. Accepts either arrays
     * of path parts or strings.
     *
     * Example:
     *
     * ```
     * Polymer.Path.split(['foo.bar', 0, 'baz'])  // ['foo', 'bar', '0', 'baz']
     * Polymer.Path.split('foo.bar.0.baz')        // ['foo', 'bar', '0', 'baz']
     * ```
     *
     * @memberof Polymer.Path
     * @param {string | !Array<string|number>} path Input path
     * @return {!Array<string>} Array of path parts
     * @this {Path}
     * @suppress {checkTypes}
     */
    split: function split(path) {
      if (Array.isArray(path)) {
        return this.normalize(path).split('.');
      }
      return path.toString().split('.');
    },

    /**
     * Reads a value from a path.  If any sub-property in the path is `undefined`,
     * this method returns `undefined` (will never throw.
     *
     * @memberof Polymer.Path
     * @param {Object} root Object from which to dereference path from
     * @param {string | !Array<string|number>} path Path to read
     * @param {Object=} info If an object is provided to `info`, the normalized
     *  (flattened) path will be set to `info.path`.
     * @return {*} Value at path, or `undefined` if the path could not be
     *  fully dereferenced.
     * @this {Path}
     */
    get: function get(root, path, info) {
      var prop = root;
      var parts = this.split(path);
      // Loop over path parts[0..n-1] and dereference
      for (var i = 0; i < parts.length; i++) {
        if (!prop) {
          return;
        }
        var part = parts[i];
        prop = prop[part];
      }
      if (info) {
        info.path = parts.join('.');
      }
      return prop;
    },

    /**
     * Sets a value to a path.  If any sub-property in the path is `undefined`,
     * this method will no-op.
     *
     * @memberof Polymer.Path
     * @param {Object} root Object from which to dereference path from
     * @param {string | !Array<string|number>} path Path to set
     * @param {*} value Value to set to path
     * @return {string | undefined} The normalized version of the input path
     * @this {Path}
     */
    set: function set(root, path, value) {
      var prop = root;
      var parts = this.split(path);
      var last = parts[parts.length - 1];
      if (parts.length > 1) {
        // Loop over path parts[0..n-2] and dereference
        for (var i = 0; i < parts.length - 1; i++) {
          var part = parts[i];
          prop = prop[part];
          if (!prop) {
            return;
          }
        }
        // Set value to object at end of path
        prop[last] = value;
      } else {
        // Simple property set
        prop[path] = value;
      }
      return parts.join('.');
    }

  };

  /**
   * Returns true if the given string is a structured data path (has dots).
   *
   * This function is deprecated.  Use `Polymer.Path.isPath` instead.
   *
   * Example:
   *
   * ```
   * Polymer.Path.isDeep('foo.bar.baz') // true
   * Polymer.Path.isDeep('foo')         // false
   * ```
   *
   * @deprecated
   * @memberof Polymer.Path
   * @param {string} path Path string
   * @return {boolean} True if the string contained one or more dots
   */
  Path.isDeep = Path.isPath;

  Polymer.Path = Path;
})();

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

__webpack_require__(1);

__webpack_require__(3);

__webpack_require__(10);

__webpack_require__(8);

(function () {

  'use strict';

  var caseMap = Polymer.CaseMap;

  var microtask = Polymer.Async.microTask;

  // Save map of native properties; this forms a blacklist or properties
  // that won't have their values "saved" by `saveAccessorValue`, since
  // reading from an HTMLElement accessor from the context of a prototype throws
  var nativeProperties = {};
  var proto = HTMLElement.prototype;
  while (proto) {
    var props = Object.getOwnPropertyNames(proto);
    for (var i = 0; i < props.length; i++) {
      nativeProperties[props[i]] = true;
    }
    proto = Object.getPrototypeOf(proto);
  }

  /**
   * Used to save the value of a property that will be overridden with
   * an accessor. If the `model` is a prototype, the values will be saved
   * in `__dataProto`, and it's up to the user (or downstream mixin) to
   * decide how/when to set these values back into the accessors.
   * If `model` is already an instance (it has a `__data` property), then
   * the value will be set as a pending property, meaning the user should
   * call `_invalidateProperties` or `_flushProperties` to take effect
   *
   * @param {Object} model Prototype or instance
   * @param {string} property Name of property
   * @private
   */
  function saveAccessorValue(model, property) {
    // Don't read/store value for any native properties since they could throw
    if (!nativeProperties[property]) {
      var value = model[property];
      if (value !== undefined) {
        if (model.__data) {
          // Adding accessor to instance; update the property
          // It is the user's responsibility to call _flushProperties
          model._setPendingProperty(property, value);
        } else {
          // Adding accessor to proto; save proto's value for instance-time use
          if (!model.__dataProto) {
            model.__dataProto = {};
          } else if (!model.hasOwnProperty(JSCompiler_renameProperty('__dataProto', model))) {
            model.__dataProto = Object.create(model.__dataProto);
          }
          model.__dataProto[property] = value;
        }
      }
    }
  }

  /**
   * Element class mixin that provides basic meta-programming for creating one
   * or more property accessors (getter/setter pair) that enqueue an async
   * (batched) `_propertiesChanged` callback.
   *
   * For basic usage of this mixin, simply declare attributes to observe via
   * the standard `static get observedAttributes()`, implement `_propertiesChanged`
   * on the class, and then call `MyClass.createPropertiesForAttributes()` once
   * on the class to generate property accessors for each observed attribute
   * prior to instancing.  Last, call `this._flushProperties()` once to enable
   * the accessors.
   *
   * Any `observedAttributes` will automatically be
   * deserialized via `attributeChangedCallback` and set to the associated
   * property using `dash-case`-to-`camelCase` convention.
   *
   * @mixinFunction
   * @polymer
   * @memberof Polymer
   * @summary Element class mixin for reacting to property changes from
   *   generated property accessors.
   */
  Polymer.PropertyAccessors = Polymer.dedupingMixin(function (superClass) {

    /**
     * @polymer
     * @mixinClass
     * @implements {Polymer_PropertyAccessors}
     * @extends HTMLElement
     * @unrestricted
     */
    var PropertyAccessors = function (_superClass) {
      _inherits(PropertyAccessors, _superClass);

      _createClass(PropertyAccessors, null, [{
        key: 'createPropertiesForAttributes',


        /**
         * Generates property accessors for all attributes in the standard
         * static `observedAttributes` array.
         *
         * Attribute names are mapped to property names using the `dash-case` to
         * `camelCase` convention
         *
         */
        value: function createPropertiesForAttributes() {
          var a$ = this.observedAttributes;
          for (var _i = 0; _i < a$.length; _i++) {
            this.prototype._createPropertyAccessor(caseMap.dashToCamelCase(a$[_i]));
          }
        }
      }]);

      function PropertyAccessors() {
        _classCallCheck(this, PropertyAccessors);

        /** @type {boolean} */
        var _this = _possibleConstructorReturn(this, (PropertyAccessors.__proto__ || Object.getPrototypeOf(PropertyAccessors)).call(this));

        _this.__serializing;
        /** @type {number} */
        _this.__dataCounter;
        /** @type {boolean} */
        _this.__dataEnabled;
        /** @type {boolean} */
        _this.__dataReady;
        /** @type {boolean} */
        _this.__dataInvalid;
        /** @type {!Object} */
        _this.__data;
        /** @type {Object} */
        _this.__dataPending;
        /** @type {Object} */
        _this.__dataOld;
        /** @type {Object} */
        _this.__dataProto;
        /** @type {Object} */
        _this.__dataHasAccessor;
        /** @type {Object} */
        _this.__dataInstanceProps;
        _this._initializeProperties();
        return _this;
      }

      /**
       * Implements native Custom Elements `attributeChangedCallback` to
       * set an attribute value to a property via `_attributeToProperty`.
       *
       * @param {string} name Name of attribute that changed
       * @param {?string} old Old attribute value
       * @param {?string} value New attribute value
       */


      _createClass(PropertyAccessors, [{
        key: 'attributeChangedCallback',
        value: function attributeChangedCallback(name, old, value) {
          if (old !== value) {
            this._attributeToProperty(name, value);
          }
        }

        /**
         * Initializes the local storage for property accessors.
         *
         * Provided as an override point for performing any setup work prior
         * to initializing the property accessor system.
         *
         * @protected
         */

      }, {
        key: '_initializeProperties',
        value: function _initializeProperties() {
          this.__serializing = false;
          this.__dataCounter = 0;
          this.__dataEnabled = false;
          this.__dataReady = false;
          this.__dataInvalid = false;
          this.__data = {};
          this.__dataPending = null;
          this.__dataOld = null;
          if (this.__dataProto) {
            this._initializeProtoProperties(this.__dataProto);
            this.__dataProto = null;
          }
          // Capture instance properties; these will be set into accessors
          // during first flush. Don't set them here, since we want
          // these to overwrite defaults/constructor assignments
          for (var p in this.__dataHasAccessor) {
            if (this.hasOwnProperty(p)) {
              this.__dataInstanceProps = this.__dataInstanceProps || {};
              this.__dataInstanceProps[p] = this[p];
              delete this[p];
            }
          }
        }

        /**
         * Called at instance time with bag of properties that were overwritten
         * by accessors on the prototype when accessors were created.
         *
         * The default implementation sets these properties back into the
         * setter at instance time.  This method is provided as an override
         * point for customizing or providing more efficient initialization.
         *
         * @param {Object} props Bag of property values that were overwritten
         *   when creating property accessors.
         * @protected
         */

      }, {
        key: '_initializeProtoProperties',
        value: function _initializeProtoProperties(props) {
          for (var p in props) {
            this._setProperty(p, props[p]);
          }
        }

        /**
         * Called at ready time with bag of instance properties that overwrote
         * accessors when the element upgraded.
         *
         * The default implementation sets these properties back into the
         * setter at ready time.  This method is provided as an override
         * point for customizing or providing more efficient initialization.
         *
         * @param {Object} props Bag of property values that were overwritten
         *   when creating property accessors.
         * @protected
         */

      }, {
        key: '_initializeInstanceProperties',
        value: function _initializeInstanceProperties(props) {
          Object.assign(this, props);
        }

        /**
         * Ensures the element has the given attribute. If it does not,
         * assigns the given value to the attribute.
         *
         *
         * @param {string} attribute Name of attribute to ensure is set.
         * @param {string} value of the attribute.
         */

      }, {
        key: '_ensureAttribute',
        value: function _ensureAttribute(attribute, value) {
          if (!this.hasAttribute(attribute)) {
            this._valueToNodeAttribute(this, value, attribute);
          }
        }

        /**
         * Deserializes an attribute to its associated property.
         *
         * This method calls the `_deserializeValue` method to convert the string to
         * a typed value.
         *
         * @param {string} attribute Name of attribute to deserialize.
         * @param {?string} value of the attribute.
         * @param {*=} type type to deserialize to.
         */

      }, {
        key: '_attributeToProperty',
        value: function _attributeToProperty(attribute, value, type) {
          // Don't deserialize back to property if currently reflecting
          if (!this.__serializing) {
            var property = caseMap.dashToCamelCase(attribute);
            this[property] = this._deserializeValue(value, type);
          }
        }

        /**
         * Serializes a property to its associated attribute.
         *
         * @param {string} property Property name to reflect.
         * @param {string=} attribute Attribute name to reflect.
         * @param {*=} value Property value to refect.
         */

      }, {
        key: '_propertyToAttribute',
        value: function _propertyToAttribute(property, attribute, value) {
          this.__serializing = true;
          value = arguments.length < 3 ? this[property] : value;
          this._valueToNodeAttribute(this, value, attribute || caseMap.camelToDashCase(property));
          this.__serializing = false;
        }

        /**
         * Sets a typed value to an HTML attribute on a node.
         *
         * This method calls the `_serializeValue` method to convert the typed
         * value to a string.  If the `_serializeValue` method returns `undefined`,
         * the attribute will be removed (this is the default for boolean
         * type `false`).
         *
         * @param {Element} node Element to set attribute to.
         * @param {*} value Value to serialize.
         * @param {string} attribute Attribute name to serialize to.
         */

      }, {
        key: '_valueToNodeAttribute',
        value: function _valueToNodeAttribute(node, value, attribute) {
          var str = this._serializeValue(value);
          if (str === undefined) {
            node.removeAttribute(attribute);
          } else {
            node.setAttribute(attribute, str);
          }
        }

        /**
         * Converts a typed JavaScript value to a string.
         *
         * This method is called by Polymer when setting JS property values to
         * HTML attributes.  Users may override this method on Polymer element
         * prototypes to provide serialization for custom types.
         *
         * @param {*} value Property value to serialize.
         * @return {string | undefined} String serialized from the provided property value.
         */

      }, {
        key: '_serializeValue',
        value: function _serializeValue(value) {
          /* eslint-disable no-fallthrough */
          switch (typeof value === 'undefined' ? 'undefined' : _typeof(value)) {
            case 'boolean':
              return value ? '' : undefined;

            case 'object':
              if (value instanceof Date) {
                return value.toString();
              } else if (value) {
                try {
                  return JSON.stringify(value);
                } catch (x) {
                  return '';
                }
              }

            default:
              return value != null ? value.toString() : undefined;
          }
        }

        /**
         * Converts a string to a typed JavaScript value.
         *
         * This method is called by Polymer when reading HTML attribute values to
         * JS properties.  Users may override this method on Polymer element
         * prototypes to provide deserialization for custom `type`s.  Note,
         * the `type` argument is the value of the `type` field provided in the
         * `properties` configuration object for a given property, and is
         * by convention the constructor for the type to deserialize.
         *
         * Note: The return value of `undefined` is used as a sentinel value to
         * indicate the attribute should be removed.
         *
         * @param {?string} value Attribute value to deserialize.
         * @param {*=} type Type to deserialize the string to.
         * @return {*} Typed value deserialized from the provided string.
         */

      }, {
        key: '_deserializeValue',
        value: function _deserializeValue(value, type) {
          /**
           * @type {*}
           */
          var outValue = void 0;
          switch (type) {
            case Number:
              outValue = Number(value);
              break;

            case Boolean:
              outValue = value !== null;
              break;

            case Object:
              try {
                outValue = JSON.parse( /** @type string */value);
              } catch (x) {
                // allow non-JSON literals like Strings and Numbers
              }
              break;

            case Array:
              try {
                outValue = JSON.parse( /** @type string */value);
              } catch (x) {
                outValue = null;
                console.warn('Polymer::Attributes: couldn\'t decode Array as JSON: ' + value);
              }
              break;

            case Date:
              outValue = new Date(value);
              break;

            case String:
            default:
              outValue = value;
              break;
          }

          return outValue;
        }
        /* eslint-enable no-fallthrough */

        /**
         * Creates a setter/getter pair for the named property with its own
         * local storage.  The getter returns the value in the local storage,
         * and the setter calls `_setProperty`, which updates the local storage
         * for the property and enqueues a `_propertiesChanged` callback.
         *
         * This method may be called on a prototype or an instance.  Calling
         * this method may overwrite a property value that already exists on
         * the prototype/instance by creating the accessor.  When calling on
         * a prototype, any overwritten values are saved in `__dataProto`,
         * and it is up to the subclasser to decide how/when to set those
         * properties back into the accessor.  When calling on an instance,
         * the overwritten value is set via `_setPendingProperty`, and the
         * user should call `_invalidateProperties` or `_flushProperties`
         * for the values to take effect.
         *
         * @param {string} property Name of the property
         * @param {boolean=} readOnly When true, no setter is created; the
         *   protected `_setProperty` function must be used to set the property
         * @protected
         */

      }, {
        key: '_createPropertyAccessor',
        value: function _createPropertyAccessor(property, readOnly) {
          if (!this.hasOwnProperty('__dataHasAccessor')) {
            this.__dataHasAccessor = Object.assign({}, this.__dataHasAccessor);
          }
          if (!this.__dataHasAccessor[property]) {
            this.__dataHasAccessor[property] = true;
            saveAccessorValue(this, property);
            Object.defineProperty(this, property, {
              /* eslint-disable valid-jsdoc */
              /** @this {PropertyAccessors} */
              get: function get() {
                return this.__data[property];
              },
              /** @this {PropertyAccessors} */
              set: readOnly ? function () {} : function (value) {
                this._setProperty(property, value);
              }
              /* eslint-enable */
            });
          }
        }

        /**
         * Returns true if this library created an accessor for the given property.
         *
         * @param {string} property Property name
         * @return {boolean} True if an accessor was created
         */

      }, {
        key: '_hasAccessor',
        value: function _hasAccessor(property) {
          return this.__dataHasAccessor && this.__dataHasAccessor[property];
        }

        /**
         * Updates the local storage for a property (via `_setPendingProperty`)
         * and enqueues a `_proeprtiesChanged` callback.
         *
         * @param {string} property Name of the property
         * @param {*} value Value to set
         * @protected
         */

      }, {
        key: '_setProperty',
        value: function _setProperty(property, value) {
          if (this._setPendingProperty(property, value)) {
            this._invalidateProperties();
          }
        }

        /**
         * Updates the local storage for a property, records the previous value,
         * and adds it to the set of "pending changes" that will be passed to the
         * `_propertiesChanged` callback.  This method does not enqueue the
         * `_propertiesChanged` callback.
         *
         * @param {string} property Name of the property
         * @param {*} value Value to set
         * @return {boolean} Returns true if the property changed
         * @protected
         */

      }, {
        key: '_setPendingProperty',
        value: function _setPendingProperty(property, value) {
          var old = this.__data[property];
          var changed = this._shouldPropertyChange(property, value, old);
          if (changed) {
            if (!this.__dataPending) {
              this.__dataPending = {};
              this.__dataOld = {};
            }
            // Ensure old is captured from the last turn
            if (this.__dataOld && !(property in this.__dataOld)) {
              this.__dataOld[property] = old;
            }
            this.__data[property] = value;
            this.__dataPending[property] = value;
          }
          return changed;
        }

        /**
         * Returns true if the specified property has a pending change.
         *
         * @param {string} prop Property name
         * @return {boolean} True if property has a pending change
         * @protected
         */

      }, {
        key: '_isPropertyPending',
        value: function _isPropertyPending(prop) {
          return Boolean(this.__dataPending && prop in this.__dataPending);
        }

        /**
         * Marks the properties as invalid, and enqueues an async
         * `_propertiesChanged` callback.
         *
         * @protected
         */

      }, {
        key: '_invalidateProperties',
        value: function _invalidateProperties() {
          var _this2 = this;

          if (!this.__dataInvalid && this.__dataReady) {
            this.__dataInvalid = true;
            microtask.run(function () {
              if (_this2.__dataInvalid) {
                _this2.__dataInvalid = false;
                _this2._flushProperties();
              }
            });
          }
        }

        /**
         * Call to enable property accessor processing. Before this method is
         * called accessor values will be set but side effects are
         * queued. When called, any pending side effects occur immediately.
         * For elements, generally `connectedCallback` is a normal spot to do so.
         * It is safe to call this method multiple times as it only turns on
         * property accessors once.
         */

      }, {
        key: '_enableProperties',
        value: function _enableProperties() {
          if (!this.__dataEnabled) {
            this.__dataEnabled = true;
            if (this.__dataInstanceProps) {
              this._initializeInstanceProperties(this.__dataInstanceProps);
              this.__dataInstanceProps = null;
            }
            this.ready();
          }
        }

        /**
         * Calls the `_propertiesChanged` callback with the current set of
         * pending changes (and old values recorded when pending changes were
         * set), and resets the pending set of changes. Generally, this method
         * should not be called in user code.
         *
         *
         * @protected
         */

      }, {
        key: '_flushProperties',
        value: function _flushProperties() {
          if (this.__dataPending && this.__dataOld) {
            var changedProps = this.__dataPending;
            this.__dataPending = null;
            this.__dataCounter++;
            this._propertiesChanged(this.__data, changedProps, this.__dataOld);
            this.__dataCounter--;
          }
        }

        /**
         * Lifecycle callback called the first time properties are being flushed.
         * Prior to `ready`, all property sets through accessors are queued and
         * their effects are flushed after this method returns.
         *
         * Users may override this function to implement behavior that is
         * dependent on the element having its properties initialized, e.g.
         * from defaults (initialized from `constructor`, `_initializeProperties`),
         * `attributeChangedCallback`, or values propagated from host e.g. via
         * bindings.  `super.ready()` must be called to ensure the data system
         * becomes enabled.
         *
         * @public
         */

      }, {
        key: 'ready',
        value: function ready() {
          this.__dataReady = true;
          // Run normal flush
          this._flushProperties();
        }

        /**
         * Callback called when any properties with accessors created via
         * `_createPropertyAccessor` have been set.
         *
         * @param {!Object} currentProps Bag of all current accessor values
         * @param {!Object} changedProps Bag of properties changed since the last
         *   call to `_propertiesChanged`
         * @param {!Object} oldProps Bag of previous values for each property
         *   in `changedProps`
         * @protected
         */

      }, {
        key: '_propertiesChanged',
        value: function _propertiesChanged(currentProps, changedProps, oldProps) {} // eslint-disable-line no-unused-vars


        /**
         * Method called to determine whether a property value should be
         * considered as a change and cause the `_propertiesChanged` callback
         * to be enqueued.
         *
         * The default implementation returns `true` for primitive types if a
         * strict equality check fails, and returns `true` for all Object/Arrays.
         * The method always returns false for `NaN`.
         *
         * Override this method to e.g. provide stricter checking for
         * Objects/Arrays when using immutable patterns.
         *
         * @param {string} property Property name
         * @param {*} value New property value
         * @param {*} old Previous property value
         * @return {boolean} Whether the property should be considered a change
         *   and enqueue a `_proeprtiesChanged` callback
         * @protected
         */

      }, {
        key: '_shouldPropertyChange',
        value: function _shouldPropertyChange(property, value, old) {
          return (
            // Strict equality check
            old !== value && (
            // This ensures (old==NaN, value==NaN) always returns false
            old === old || value === value)
          );
        }
      }]);

      return PropertyAccessors;
    }(superClass);

    return PropertyAccessors;
  });
})();

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

__webpack_require__(1);

__webpack_require__(3);

(function () {

  'use strict';

  // 1.x backwards-compatible auto-wrapper for template type extensions
  // This is a clear layering violation and gives favored-nation status to
  // dom-if and dom-repeat templates.  This is a conceit we're choosing to keep
  // a.) to ease 1.x backwards-compatibility due to loss of `is`, and
  // b.) to maintain if/repeat capability in parser-constrained elements
  //     (e.g. table, select) in lieu of native CE type extensions without
  //     massive new invention in this space (e.g. directive system)

  var templateExtensions = {
    'dom-if': true,
    'dom-repeat': true
  };
  function wrapTemplateExtension(node) {
    var is = node.getAttribute('is');
    if (is && templateExtensions[is]) {
      var t = node;
      t.removeAttribute('is');
      node = t.ownerDocument.createElement(is);
      t.parentNode.replaceChild(node, t);
      node.appendChild(t);
      while (t.attributes.length) {
        node.setAttribute(t.attributes[0].name, t.attributes[0].value);
        t.removeAttribute(t.attributes[0].name);
      }
    }
    return node;
  }

  function findTemplateNode(root, nodeInfo) {
    // recursively ascend tree until we hit root
    var parent = nodeInfo.parentInfo && findTemplateNode(root, nodeInfo.parentInfo);
    // unwind the stack, returning the indexed node at each level
    if (parent) {
      // note: marginally faster than indexing via childNodes
      // (http://jsperf.com/childnodes-lookup)
      for (var n = parent.firstChild, i = 0; n; n = n.nextSibling) {
        if (nodeInfo.parentIndex === i++) {
          return n;
        }
      }
    } else {
      return root;
    }
  }

  // construct `$` map (from id annotations)
  function applyIdToMap(inst, map, node, nodeInfo) {
    if (nodeInfo.id) {
      map[nodeInfo.id] = node;
    }
  }

  // install event listeners (from event annotations)
  function applyEventListener(inst, node, nodeInfo) {
    if (nodeInfo.events && nodeInfo.events.length) {
      for (var j = 0, e$ = nodeInfo.events, e; j < e$.length && (e = e$[j]); j++) {
        inst._addMethodEventListenerToNode(node, e.name, e.value, inst);
      }
    }
  }

  // push configuration references at configure time
  function applyTemplateContent(inst, node, nodeInfo) {
    if (nodeInfo.templateInfo) {
      node._templateInfo = nodeInfo.templateInfo;
    }
  }

  function createNodeEventHandler(context, eventName, methodName) {
    // Instances can optionally have a _methodHost which allows redirecting where
    // to find methods. Currently used by `templatize`.
    context = context._methodHost || context;
    var handler = function handler(e) {
      if (context[methodName]) {
        context[methodName](e, e.detail);
      } else {
        console.warn('listener method `' + methodName + '` not defined');
      }
    };
    return handler;
  }

  /**
   * Element mixin that provides basic template parsing and stamping, including
   * the following template-related features for stamped templates:
   *
   * - Declarative event listeners (`on-eventname="listener"`)
   * - Map of node id's to stamped node instances (`this.$.id`)
   * - Nested template content caching/removal and re-installation (performance
   *   optimization)
   *
   * @mixinFunction
   * @polymer
   * @memberof Polymer
   * @summary Element class mixin that provides basic template parsing and stamping
   */
  Polymer.TemplateStamp = Polymer.dedupingMixin(function (superClass) {

    /**
     * @polymer
     * @mixinClass
     * @implements {Polymer_TemplateStamp}
     */
    var TemplateStamp = function (_superClass) {
      _inherits(TemplateStamp, _superClass);

      function TemplateStamp() {
        _classCallCheck(this, TemplateStamp);

        return _possibleConstructorReturn(this, (TemplateStamp.__proto__ || Object.getPrototypeOf(TemplateStamp)).apply(this, arguments));
      }

      _createClass(TemplateStamp, [{
        key: '_stampTemplate',


        /**
         * Clones the provided template content and returns a document fragment
         * containing the cloned dom.
         *
         * The template is parsed (once and memoized) using this library's
         * template parsing features, and provides the following value-added
         * features:
         * * Adds declarative event listeners for `on-event="handler"` attributes
         * * Generates an "id map" for all nodes with id's under `$` on returned
         *   document fragment
         * * Passes template info including `content` back to templates as
         *   `_templateInfo` (a performance optimization to avoid deep template
         *   cloning)
         *
         * Note that the memoized template parsing process is destructive to the
         * template: attributes for bindings and declarative event listeners are
         * removed after being noted in notes, and any nested `<template>.content`
         * is removed and stored in notes as well.
         *
         * @param {!HTMLTemplateElement} template Template to stamp
         * @return {!StampedTemplate} Cloned template content
         */
        value: function _stampTemplate(template) {
          // Polyfill support: bootstrap the template if it has not already been
          if (template && !template.content && window.HTMLTemplateElement && HTMLTemplateElement.decorate) {
            HTMLTemplateElement.decorate(template);
          }
          var templateInfo = this.constructor._parseTemplate(template);
          var nodeInfo = templateInfo.nodeInfoList;
          var content = templateInfo.content || template.content;
          var dom = /** @type DocumentFragment */document.importNode(content, true);
          // NOTE: ShadyDom optimization indicating there is an insertion point
          dom.__noInsertionPoint = !templateInfo.hasInsertionPoint;
          var nodes = dom.nodeList = new Array(nodeInfo.length);
          dom.$ = {};
          for (var i = 0, l = nodeInfo.length, info; i < l && (info = nodeInfo[i]); i++) {
            var node = nodes[i] = findTemplateNode(dom, info);
            applyIdToMap(this, dom.$, node, info);
            applyTemplateContent(this, node, info);
            applyEventListener(this, node, info);
          }
          return (/** @type {!StampedTemplate} */dom
          );
        }

        /**
         * Adds an event listener by method name for the event provided.
         *
         * This method generates a handler function that looks up the method
         * name at handling time.
         *
         * @param {Node} node Node to add listener on
         * @param {string} eventName Name of event
         * @param {string} methodName Name of method
         * @param {*=} context Context the method will be called on (defaults
         *   to `node`)
         * @return {Function} Generated handler function
         */

      }, {
        key: '_addMethodEventListenerToNode',
        value: function _addMethodEventListenerToNode(node, eventName, methodName, context) {
          context = context || node;
          var handler = createNodeEventHandler(context, eventName, methodName);
          this._addEventListenerToNode(node, eventName, handler);
          return handler;
        }

        /**
         * Override point for adding custom or simulated event handling.
         *
         * @param {Node} node Node to add event listener to
         * @param {string} eventName Name of event
         * @param {Function} handler Listener function to add
         */

      }, {
        key: '_addEventListenerToNode',
        value: function _addEventListenerToNode(node, eventName, handler) {
          node.addEventListener(eventName, handler);
        }

        /**
         * Override point for adding custom or simulated event handling.
         *
         * @param {Node} node Node to remove event listener from
         * @param {string} eventName Name of event
         * @param {Function} handler Listener function to remove
         */

      }, {
        key: '_removeEventListenerFromNode',
        value: function _removeEventListenerFromNode(node, eventName, handler) {
          node.removeEventListener(eventName, handler);
        }
      }], [{
        key: '_parseTemplate',


        /**
         * Scans a template to produce template metadata.
         *
         * Template-specific metadata are stored in the object returned, and node-
         * specific metadata are stored in objects in its flattened `nodeInfoList`
         * array.  Only nodes in the template that were parsed as nodes of
         * interest contain an object in `nodeInfoList`.  Each `nodeInfo` object
         * contains an `index` (`childNodes` index in parent) and optionally
         * `parent`, which points to node info of its parent (including its index).
         *
         * The template metadata object returned from this method has the following
         * structure (many fields optional):
         *
         * ```js
         *   {
         *     // Flattened list of node metadata (for nodes that generated metadata)
         *     nodeInfoList: [
         *       {
         *         // `id` attribute for any nodes with id's for generating `$` map
         *         id: {string},
         *         // `on-event="handler"` metadata
         *         events: [
         *           {
         *             name: {string},   // event name
         *             value: {string},  // handler method name
         *           }, ...
         *         ],
         *         // Notes when the template contained a `<slot>` for shady DOM
         *         // optimization purposes
         *         hasInsertionPoint: {boolean},
         *         // For nested `<template>`` nodes, nested template metadata
         *         templateInfo: {object}, // nested template metadata
         *         // Metadata to allow efficient retrieval of instanced node
         *         // corresponding to this metadata
         *         parentInfo: {number},   // reference to parent nodeInfo>
         *         parentIndex: {number},  // index in parent's `childNodes` collection
         *         infoIndex: {number},    // index of this `nodeInfo` in `templateInfo.nodeInfoList`
         *       },
         *       ...
         *     ],
         *     // When true, the template had the `strip-whitespace` attribute
         *     // or was nested in a template with that setting
         *     stripWhitespace: {boolean},
         *     // For nested templates, nested template content is moved into
         *     // a document fragment stored here; this is an optimization to
         *     // avoid the cost of nested template cloning
         *     content: {DocumentFragment}
         *   }
         * ```
         *
         * This method kicks off a recursive treewalk as follows:
         *
         * ```
         *    _parseTemplate <---------------------+
         *      _parseTemplateContent              |
         *        _parseTemplateNode  <------------|--+
         *          _parseTemplateNestedTemplate --+  |
         *          _parseTemplateChildNodes ---------+
         *          _parseTemplateNodeAttributes
         *            _parseTemplateNodeAttribute
         *
         * ```
         *
         * These methods may be overridden to add custom metadata about templates
         * to either `templateInfo` or `nodeInfo`.
         *
         * Note that this method may be destructive to the template, in that
         * e.g. event annotations may be removed after being noted in the
         * template metadata.
         *
         * @param {!HTMLTemplateElement} template Template to parse
         * @param {TemplateInfo=} outerTemplateInfo Template metadata from the outer
         *   template, for parsing nested templates
         * @return {!TemplateInfo} Parsed template metadata
         */
        value: function _parseTemplate(template, outerTemplateInfo) {
          // since a template may be re-used, memo-ize metadata
          if (!template._templateInfo) {
            var templateInfo = template._templateInfo = {};
            templateInfo.nodeInfoList = [];
            templateInfo.stripWhiteSpace = outerTemplateInfo && outerTemplateInfo.stripWhiteSpace || template.hasAttribute('strip-whitespace');
            this._parseTemplateContent(template, templateInfo, { parent: null });
          }
          return template._templateInfo;
        }
      }, {
        key: '_parseTemplateContent',
        value: function _parseTemplateContent(template, templateInfo, nodeInfo) {
          return this._parseTemplateNode(template.content, templateInfo, nodeInfo);
        }

        /**
         * Parses template node and adds template and node metadata based on
         * the current node, and its `childNodes` and `attributes`.
         *
         * This method may be overridden to add custom node or template specific
         * metadata based on this node.
         *
         * @param {Node} node Node to parse
         * @param {!TemplateInfo} templateInfo Template metadata for current template
         * @param {!NodeInfo} nodeInfo Node metadata for current template.
         * @return {boolean} `true` if the visited node added node-specific
         *   metadata to `nodeInfo`
         */

      }, {
        key: '_parseTemplateNode',
        value: function _parseTemplateNode(node, templateInfo, nodeInfo) {
          var noted = void 0;
          var element = /** @type Element */node;
          if (element.localName == 'template' && !element.hasAttribute('preserve-content')) {
            noted = this._parseTemplateNestedTemplate(element, templateInfo, nodeInfo) || noted;
          } else if (element.localName === 'slot') {
            // For ShadyDom optimization, indicating there is an insertion point
            templateInfo.hasInsertionPoint = true;
          }
          if (element.firstChild) {
            noted = this._parseTemplateChildNodes(element, templateInfo, nodeInfo) || noted;
          }
          if (element.hasAttributes && element.hasAttributes()) {
            noted = this._parseTemplateNodeAttributes(element, templateInfo, nodeInfo) || noted;
          }
          return noted;
        }

        /**
         * Parses template child nodes for the given root node.
         *
         * This method also wraps whitelisted legacy template extensions
         * (`is="dom-if"` and `is="dom-repeat"`) with their equivalent element
         * wrappers, collapses text nodes, and strips whitespace from the template
         * if the `templateInfo.stripWhitespace` setting was provided.
         *
         * @param {Node} root Root node whose `childNodes` will be parsed
         * @param {!TemplateInfo} templateInfo Template metadata for current template
         * @param {!NodeInfo} nodeInfo Node metadata for current template.
         */

      }, {
        key: '_parseTemplateChildNodes',
        value: function _parseTemplateChildNodes(root, templateInfo, nodeInfo) {
          for (var node = root.firstChild, parentIndex = 0, next; node; node = next) {
            // Wrap templates
            if (node.localName == 'template') {
              node = wrapTemplateExtension(node);
            }
            // collapse adjacent textNodes: fixes an IE issue that can cause
            // text nodes to be inexplicably split =(
            // note that root.normalize() should work but does not so we do this
            // manually.
            next = node.nextSibling;
            if (node.nodeType === Node.TEXT_NODE) {
              var /** Node */n = next;
              while (n && n.nodeType === Node.TEXT_NODE) {
                node.textContent += n.textContent;
                next = n.nextSibling;
                root.removeChild(n);
                n = next;
              }
              // optionally strip whitespace
              if (templateInfo.stripWhiteSpace && !node.textContent.trim()) {
                root.removeChild(node);
                continue;
              }
            }
            var childInfo = { parentIndex: parentIndex, parentInfo: nodeInfo };
            if (this._parseTemplateNode(node, templateInfo, childInfo)) {
              childInfo.infoIndex = templateInfo.nodeInfoList.push( /** @type {!NodeInfo} */childInfo) - 1;
            }
            // Increment if not removed
            if (node.parentNode) {
              parentIndex++;
            }
          }
        }

        /**
         * Parses template content for the given nested `<template>`.
         *
         * Nested template info is stored as `templateInfo` in the current node's
         * `nodeInfo`. `template.content` is removed and stored in `templateInfo`.
         * It will then be the responsibility of the host to set it back to the
         * template and for users stamping nested templates to use the
         * `_contentForTemplate` method to retrieve the content for this template
         * (an optimization to avoid the cost of cloning nested template content).
         *
         * @param {HTMLTemplateElement} node Node to parse (a <template>)
         * @param {TemplateInfo} outerTemplateInfo Template metadata for current template
         *   that includes the template `node`
         * @param {!NodeInfo} nodeInfo Node metadata for current template.
         * @return {boolean} `true` if the visited node added node-specific
         *   metadata to `nodeInfo`
         */

      }, {
        key: '_parseTemplateNestedTemplate',
        value: function _parseTemplateNestedTemplate(node, outerTemplateInfo, nodeInfo) {
          var templateInfo = this._parseTemplate(node, outerTemplateInfo);
          var content = templateInfo.content = node.content.ownerDocument.createDocumentFragment();
          content.appendChild(node.content);
          nodeInfo.templateInfo = templateInfo;
          return true;
        }

        /**
         * Parses template node attributes and adds node metadata to `nodeInfo`
         * for nodes of interest.
         *
         * @param {Element} node Node to parse
         * @param {TemplateInfo} templateInfo Template metadata for current template
         * @param {NodeInfo} nodeInfo Node metadata for current template.
         * @return {boolean} `true` if the visited node added node-specific
         *   metadata to `nodeInfo`
         */

      }, {
        key: '_parseTemplateNodeAttributes',
        value: function _parseTemplateNodeAttributes(node, templateInfo, nodeInfo) {
          // Make copy of original attribute list, since the order may change
          // as attributes are added and removed
          var noted = false;
          var attrs = Array.from(node.attributes);
          for (var i = attrs.length - 1, a; a = attrs[i]; i--) {
            noted = this._parseTemplateNodeAttribute(node, templateInfo, nodeInfo, a.name, a.value) || noted;
          }
          return noted;
        }

        /**
         * Parses a single template node attribute and adds node metadata to
         * `nodeInfo` for attributes of interest.
         *
         * This implementation adds metadata for `on-event="handler"` attributes
         * and `id` attributes.
         *
         * @param {Element} node Node to parse
         * @param {!TemplateInfo} templateInfo Template metadata for current template
         * @param {!NodeInfo} nodeInfo Node metadata for current template.
         * @param {string} name Attribute name
         * @param {string} value Attribute value
         * @return {boolean} `true` if the visited node added node-specific
         *   metadata to `nodeInfo`
         */

      }, {
        key: '_parseTemplateNodeAttribute',
        value: function _parseTemplateNodeAttribute(node, templateInfo, nodeInfo, name, value) {
          // events (on-*)
          if (name.slice(0, 3) === 'on-') {
            node.removeAttribute(name);
            nodeInfo.events = nodeInfo.events || [];
            nodeInfo.events.push({
              name: name.slice(3),
              value: value
            });
            return true;
          }
          // static id
          else if (name === 'id') {
              nodeInfo.id = value;
              return true;
            }
          return false;
        }

        /**
         * Returns the `content` document fragment for a given template.
         *
         * For nested templates, Polymer performs an optimization to cache nested
         * template content to avoid the cost of cloning deeply nested templates.
         * This method retrieves the cached content for a given template.
         *
         * @param {HTMLTemplateElement} template Template to retrieve `content` for
         * @return {DocumentFragment} Content fragment
         */

      }, {
        key: '_contentForTemplate',
        value: function _contentForTemplate(template) {
          var templateInfo = /** @type {HTMLTemplateElementWithInfo} */template._templateInfo;
          return templateInfo && templateInfo.content || template.content;
        }
      }]);

      return TemplateStamp;
    }(superClass);

    return TemplateStamp;
  });
})();

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

__webpack_require__(5);

var RegisterHtmlTemplate = __webpack_require__(2);

RegisterHtmlTemplate.register("<dom-module id=app-drawer> <template> <style>:host{position:fixed;top:-120px;right:0;bottom:-120px;left:0;visibility:hidden;transition-property:visibility}:host([opened]){visibility:visible}:host([persistent]){width:var(--app-drawer-width,256px)}:host([persistent][position=left]){right:auto}:host([persistent][position=right]){left:auto}#contentContainer{position:absolute;top:0;bottom:0;left:0;width:var(--app-drawer-width,256px);padding:120px 0;transition-property:-webkit-transform;transition-property:transform;-webkit-transform:translate3d(-100%,0,0);transform:translate3d(-100%,0,0);background-color:#fff;@apply --app-drawer-content-container;}#contentContainer[persistent]{width:100%}#contentContainer[position=right]{right:0;left:auto;-webkit-transform:translate3d(100%,0,0);transform:translate3d(100%,0,0)}#contentContainer[swipe-open]::after{position:fixed;top:0;bottom:0;left:100%;visibility:visible;width:20px;content:''}#contentContainer[swipe-open][position=right]::after{right:100%;left:auto}#contentContainer[opened]{-webkit-transform:translate3d(0,0,0);transform:translate3d(0,0,0)}#scrim{position:absolute;top:0;right:0;bottom:0;left:0;transition-property:opacity;-webkit-transform:translateZ(0);transform:translateZ(0);opacity:0;background:var(--app-drawer-scrim-background,rgba(0,0,0,.5))}#scrim.visible{opacity:1}:host([no-transition]) #contentContainer{transition-property:none}</style> <div id=scrim on-click=close></div> <div id=contentContainer opened$=[[opened]] persistent$=[[persistent]] position$=[[position]] swipe-open$=[[swipeOpen]]> <slot></slot> </div> </template> </dom-module>");

Polymer({
  is: 'app-drawer',

  properties: {
    /**
     * The opened state of the drawer.
     */
    opened: {
      type: Boolean,
      value: false,
      notify: true,
      reflectToAttribute: true
    },

    /**
     * The drawer does not have a scrim and cannot be swiped close.
     */
    persistent: {
      type: Boolean,
      value: false,
      reflectToAttribute: true
    },

    /**
     * The transition duration of the drawer in milliseconds.
     */
    transitionDuration: {
      type: Number,
      value: 200
    },

    /**
     * The alignment of the drawer on the screen ('left', 'right', 'start' or 'end').
     * 'start' computes to left and 'end' to right in LTR layout and vice versa in RTL
     * layout.
     */
    align: {
      type: String,
      value: 'left'
    },

    /**
     * The computed, read-only position of the drawer on the screen ('left' or 'right').
     */
    position: {
      type: String,
      readOnly: true,
      reflectToAttribute: true
    },

    /**
     * Create an area at the edge of the screen to swipe open the drawer.
     */
    swipeOpen: {
      type: Boolean,
      value: false,
      reflectToAttribute: true
    },

    /**
     * Trap keyboard focus when the drawer is opened and not persistent.
     */
    noFocusTrap: {
      type: Boolean,
      value: false
    },

    /**
     * Disables swiping on the drawer.
     */
    disableSwipe: {
      type: Boolean,
      value: false
    }
  },

  observers: ['resetLayout(position, isAttached)', '_resetPosition(align, isAttached)', '_styleTransitionDuration(transitionDuration)', '_openedPersistentChanged(opened, persistent)'],

  _translateOffset: 0,

  _trackDetails: null,

  _drawerState: 0,

  _boundEscKeydownHandler: null,

  _firstTabStop: null,

  _lastTabStop: null,

  attached: function attached() {
    Polymer.RenderStatus.afterNextRender(this, function () {
      this._boundEscKeydownHandler = this._escKeydownHandler.bind(this);
      this.addEventListener('keydown', this._tabKeydownHandler.bind(this));

      // Only listen for horizontal track so you can vertically scroll inside the drawer.
      this.listen(this, 'track', '_track');
      this.setScrollDirection('y');
    });

    this.fire('app-reset-layout');
  },

  detached: function detached() {
    document.removeEventListener('keydown', this._boundEscKeydownHandler);
  },

  /**
   * Opens the drawer.
   */
  open: function open() {
    this.opened = true;
  },

  /**
   * Closes the drawer.
   */
  close: function close() {
    this.opened = false;
  },

  /**
   * Toggles the drawer open and close.
   */
  toggle: function toggle() {
    this.opened = !this.opened;
  },

  /**
   * Gets the width of the drawer.
   *
   * @return {number} The width of the drawer in pixels.
   */
  getWidth: function getWidth() {
    return this._savedWidth || this.$.contentContainer.offsetWidth;
  },

  _isRTL: function _isRTL() {
    return window.getComputedStyle(this).direction === 'rtl';
  },

  _resetPosition: function _resetPosition() {
    switch (this.align) {
      case 'start':
        this._setPosition(this._isRTL() ? 'right' : 'left');
        return;
      case 'end':
        this._setPosition(this._isRTL() ? 'left' : 'right');
        return;
    }
    this._setPosition(this.align);
  },

  _escKeydownHandler: function _escKeydownHandler(event) {
    var ESC_KEYCODE = 27;
    if (event.keyCode === ESC_KEYCODE) {
      // Prevent any side effects if app-drawer closes.
      event.preventDefault();
      this.close();
    }
  },

  _track: function _track(event) {
    if (this.persistent || this.disableSwipe) {
      return;
    }

    // Disable user selection on desktop.
    event.preventDefault();

    switch (event.detail.state) {
      case 'start':
        this._trackStart(event);
        break;
      case 'track':
        this._trackMove(event);
        break;
      case 'end':
        this._trackEnd(event);
        break;
    }
  },

  _trackStart: function _trackStart(event) {
    this._drawerState = this._DRAWER_STATE.TRACKING;

    var rect = this.$.contentContainer.getBoundingClientRect();
    this._savedWidth = rect.width;
    if (this.position === 'left') {
      this._translateOffset = rect.left;
    } else {
      this._translateOffset = rect.right - window.innerWidth;
    }

    this._trackDetails = [];

    // Disable transitions since style attributes will reflect user track events.
    this._styleTransitionDuration(0);
    this.style.visibility = 'visible';
  },

  _trackMove: function _trackMove(event) {
    this._translateDrawer(event.detail.dx + this._translateOffset);

    // Use Date.now() since event.timeStamp is inconsistent across browsers (e.g. most
    // browsers use milliseconds but FF 44 uses microseconds).
    this._trackDetails.push({
      dx: event.detail.dx,
      timeStamp: Date.now()
    });
  },

  _trackEnd: function _trackEnd(event) {
    var x = event.detail.dx + this._translateOffset;
    var drawerWidth = this.getWidth();
    var isPositionLeft = this.position === 'left';
    var isInEndState = isPositionLeft ? x >= 0 || x <= -drawerWidth : x <= 0 || x >= drawerWidth;

    if (!isInEndState) {
      // No longer need the track events after this method returns - allow them to be GC'd.
      var trackDetails = this._trackDetails;
      this._trackDetails = null;

      this._flingDrawer(event, trackDetails);
      if (this._drawerState === this._DRAWER_STATE.FLINGING) {
        return;
      }
    }

    // If the drawer is not flinging, toggle the opened state based on the position of
    // the drawer.
    var halfWidth = drawerWidth / 2;
    if (event.detail.dx < -halfWidth) {
      this.opened = this.position === 'right';
    } else if (event.detail.dx > halfWidth) {
      this.opened = this.position === 'left';
    }

    if (isInEndState) {
      this.debounce('_resetDrawerState', this._resetDrawerState);
    } else {
      this.debounce('_resetDrawerState', this._resetDrawerState, this.transitionDuration);
    }

    this._styleTransitionDuration(this.transitionDuration);
    this._resetDrawerTranslate();
    this.style.visibility = '';
  },

  _calculateVelocity: function _calculateVelocity(event, trackDetails) {
    // Find the oldest track event that is within 100ms using binary search.
    var now = Date.now();
    var timeLowerBound = now - 100;
    var trackDetail;
    var min = 0;
    var max = trackDetails.length - 1;

    while (min <= max) {
      // Floor of average of min and max.
      var mid = min + max >> 1;
      var d = trackDetails[mid];
      if (d.timeStamp >= timeLowerBound) {
        trackDetail = d;
        max = mid - 1;
      } else {
        min = mid + 1;
      }
    }

    if (trackDetail) {
      var dx = event.detail.dx - trackDetail.dx;
      var dt = now - trackDetail.timeStamp || 1;
      return dx / dt;
    }
    return 0;
  },

  _flingDrawer: function _flingDrawer(event, trackDetails) {
    var velocity = this._calculateVelocity(event, trackDetails);

    // Do not fling if velocity is not above a threshold.
    if (Math.abs(velocity) < this._MIN_FLING_THRESHOLD) {
      return;
    }

    this._drawerState = this._DRAWER_STATE.FLINGING;

    var x = event.detail.dx + this._translateOffset;
    var drawerWidth = this.getWidth();
    var isPositionLeft = this.position === 'left';
    var isVelocityPositive = velocity > 0;
    var isClosingLeft = !isVelocityPositive && isPositionLeft;
    var isClosingRight = isVelocityPositive && !isPositionLeft;
    var dx;
    if (isClosingLeft) {
      dx = -(x + drawerWidth);
    } else if (isClosingRight) {
      dx = drawerWidth - x;
    } else {
      dx = -x;
    }

    // Enforce a minimum transition velocity to make the drawer feel snappy.
    if (isVelocityPositive) {
      velocity = Math.max(velocity, this._MIN_TRANSITION_VELOCITY);
      this.opened = this.position === 'left';
    } else {
      velocity = Math.min(velocity, -this._MIN_TRANSITION_VELOCITY);
      this.opened = this.position === 'right';
    }

    // Calculate the amount of time needed to finish the transition based on the
    // initial slope of the timing function.
    var t = this._FLING_INITIAL_SLOPE * dx / velocity;
    this._styleTransitionDuration(t);
    this._styleTransitionTimingFunction(this._FLING_TIMING_FUNCTION);

    this._resetDrawerTranslate();
    this.debounce('_resetDrawerState', this._resetDrawerState, t);
  },

  _styleTransitionDuration: function _styleTransitionDuration(duration) {
    this.style.transitionDuration = duration + 'ms';
    this.$.contentContainer.style.transitionDuration = duration + 'ms';
    this.$.scrim.style.transitionDuration = duration + 'ms';
  },

  _styleTransitionTimingFunction: function _styleTransitionTimingFunction(timingFunction) {
    this.$.contentContainer.style.transitionTimingFunction = timingFunction;
    this.$.scrim.style.transitionTimingFunction = timingFunction;
  },

  _translateDrawer: function _translateDrawer(x) {
    var drawerWidth = this.getWidth();

    if (this.position === 'left') {
      x = Math.max(-drawerWidth, Math.min(x, 0));
      this.$.scrim.style.opacity = 1 + x / drawerWidth;
    } else {
      x = Math.max(0, Math.min(x, drawerWidth));
      this.$.scrim.style.opacity = 1 - x / drawerWidth;
    }

    this.translate3d(x + 'px', '0', '0', this.$.contentContainer);
  },

  _resetDrawerTranslate: function _resetDrawerTranslate() {
    this.$.scrim.style.opacity = '';
    this.transform('', this.$.contentContainer);
  },

  _resetDrawerState: function _resetDrawerState() {
    var oldState = this._drawerState;

    // If the drawer was flinging, we need to reset the style attributes.
    if (oldState === this._DRAWER_STATE.FLINGING) {
      this._styleTransitionDuration(this.transitionDuration);
      this._styleTransitionTimingFunction('');
      this.style.visibility = '';
    }

    this._savedWidth = null;

    if (this.opened) {
      this._drawerState = this.persistent ? this._DRAWER_STATE.OPENED_PERSISTENT : this._DRAWER_STATE.OPENED;
    } else {
      this._drawerState = this._DRAWER_STATE.CLOSED;
    }

    if (oldState !== this._drawerState) {
      if (this._drawerState === this._DRAWER_STATE.OPENED) {
        this._setKeyboardFocusTrap();
        document.addEventListener('keydown', this._boundEscKeydownHandler);
        document.body.style.overflow = 'hidden';
      } else {
        document.removeEventListener('keydown', this._boundEscKeydownHandler);
        document.body.style.overflow = '';
      }

      // Don't fire the event on initial load.
      if (oldState !== this._DRAWER_STATE.INIT) {
        this.fire('app-drawer-transitioned');
      }
    }
  },

  /**
   * Resets the layout.
   *
   * @method resetLayout
   */
  resetLayout: function resetLayout() {
    this.fire('app-reset-layout');
  },

  _setKeyboardFocusTrap: function _setKeyboardFocusTrap() {
    if (this.noFocusTrap) {
      return;
    }

    // NOTE: Unless we use /deep/ (which we shouldn't since it's deprecated), this will
    // not select focusable elements inside shadow roots.
    var focusableElementsSelector = ['a[href]:not([tabindex="-1"])', 'area[href]:not([tabindex="-1"])', 'input:not([disabled]):not([tabindex="-1"])', 'select:not([disabled]):not([tabindex="-1"])', 'textarea:not([disabled]):not([tabindex="-1"])', 'button:not([disabled]):not([tabindex="-1"])', 'iframe:not([tabindex="-1"])', '[tabindex]:not([tabindex="-1"])', '[contentEditable=true]:not([tabindex="-1"])'].join(',');
    var focusableElements = Polymer.dom(this).querySelectorAll(focusableElementsSelector);

    if (focusableElements.length > 0) {
      this._firstTabStop = focusableElements[0];
      this._lastTabStop = focusableElements[focusableElements.length - 1];
    } else {
      // Reset saved tab stops when there are no focusable elements in the drawer.
      this._firstTabStop = null;
      this._lastTabStop = null;
    }

    // Focus on app-drawer if it has non-zero tabindex. Otherwise, focus the first focusable
    // element in the drawer, if it exists. Use the tabindex attribute since the this.tabIndex
    // property in IE/Edge returns 0 (instead of -1) when the attribute is not set.
    var tabindex = this.getAttribute('tabindex');
    if (tabindex && parseInt(tabindex, 10) > -1) {
      this.focus();
    } else if (this._firstTabStop) {
      this._firstTabStop.focus();
    }
  },

  _tabKeydownHandler: function _tabKeydownHandler(event) {
    if (this.noFocusTrap) {
      return;
    }

    var TAB_KEYCODE = 9;
    if (this._drawerState === this._DRAWER_STATE.OPENED && event.keyCode === TAB_KEYCODE) {
      if (event.shiftKey) {
        if (this._firstTabStop && Polymer.dom(event).localTarget === this._firstTabStop) {
          event.preventDefault();
          this._lastTabStop.focus();
        }
      } else {
        if (this._lastTabStop && Polymer.dom(event).localTarget === this._lastTabStop) {
          event.preventDefault();
          this._firstTabStop.focus();
        }
      }
    }
  },

  _openedPersistentChanged: function _openedPersistentChanged(opened, persistent) {
    this.toggleClass('visible', opened && !persistent, this.$.scrim);

    // Use a debounce timer instead of transitionend since transitionend won't fire when
    // app-drawer is display: none.
    this.debounce('_resetDrawerState', this._resetDrawerState, this.transitionDuration);
  },

  _MIN_FLING_THRESHOLD: 0.2,

  _MIN_TRANSITION_VELOCITY: 1.2,

  _FLING_TIMING_FUNCTION: 'cubic-bezier(0.667, 1, 0.667, 1)',

  _FLING_INITIAL_SLOPE: 1.5,

  _DRAWER_STATE: {
    INIT: 0,
    OPENED: 1,
    OPENED_PERSISTENT: 2,
    CLOSED: 3,
    TRACKING: 4,
    FLINGING: 5

    /**
     * Fired when the layout of app-drawer has changed.
     *
     * @event app-reset-layout
     */

    /**
     * Fired when app-drawer has finished transitioning.
     *
     * @event app-drawer-transitioned
     */
  } });

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(37);

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


(function () {
  /*
  Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
  This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
  The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
  The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
  Code distributed by Google as part of the polymer project is also
  subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
  */
  'use strict';
  var k = {};function n() {
    this.end = this.start = 0;this.rules = this.parent = this.previous = null;this.cssText = this.parsedCssText = "";this.atRule = !1;this.type = 0;this.parsedSelector = this.selector = this.keyframesName = "";
  }
  function p(a) {
    a = a.replace(aa, "").replace(ba, "");var b = q,
        c = a,
        d = new n();d.start = 0;d.end = c.length;for (var e = d, f = 0, h = c.length; f < h; f++) {
      if ("{" === c[f]) {
        e.rules || (e.rules = []);var g = e,
            m = g.rules[g.rules.length - 1] || null;e = new n();e.start = f + 1;e.parent = g;e.previous = m;g.rules.push(e);
      } else "}" === c[f] && (e.end = f + 1, e = e.parent || d);
    }return b(d, a);
  }
  function q(a, b) {
    var c = b.substring(a.start, a.end - 1);a.parsedCssText = a.cssText = c.trim();a.parent && (c = b.substring(a.previous ? a.previous.end : a.parent.start, a.start - 1), c = ca(c), c = c.replace(r, " "), c = c.substring(c.lastIndexOf(";") + 1), c = a.parsedSelector = a.selector = c.trim(), a.atRule = 0 === c.indexOf("@"), a.atRule ? 0 === c.indexOf("@media") ? a.type = t : c.match(da) && (a.type = u, a.keyframesName = a.selector.split(r).pop()) : a.type = 0 === c.indexOf("--") ? v : x);if (c = a.rules) for (var d = 0, e = c.length, f; d < e && (f = c[d]); d++) {
      q(f, b);
    }return a;
  }
  function ca(a) {
    return a.replace(/\\([0-9a-f]{1,6})\s/gi, function (a, c) {
      a = c;for (c = 6 - a.length; c--;) {
        a = "0" + a;
      }return "\\" + a;
    });
  }
  function y(a, b, c) {
    c = void 0 === c ? "" : c;var d = "";if (a.cssText || a.rules) {
      var e = a.rules,
          f;if (f = e) f = e[0], f = !(f && f.selector && 0 === f.selector.indexOf("--"));if (f) {
        f = 0;for (var h = e.length, g; f < h && (g = e[f]); f++) {
          d = y(g, b, d);
        }
      } else b ? b = a.cssText : (b = a.cssText, b = b.replace(ea, "").replace(fa, ""), b = b.replace(ha, "").replace(ia, "")), (d = b.trim()) && (d = "  " + d + "\n");
    }d && (a.selector && (c += a.selector + " {\n"), c += d, a.selector && (c += "}\n\n"));return c;
  }
  var x = 1,
      u = 7,
      t = 4,
      v = 1E3,
      aa = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//gim,
      ba = /@import[^;]*;/gim,
      ea = /(?:^[^;\-\s}]+)?--[^;{}]*?:[^{};]*?(?:[;\n]|$)/gim,
      fa = /(?:^[^;\-\s}]+)?--[^;{}]*?:[^{};]*?{[^}]*?}(?:[;\n]|$)?/gim,
      ha = /@apply\s*\(?[^);]*\)?\s*(?:[;\n]|$)?/gim,
      ia = /[^;:]*?:[^;]*?var\([^;]*\)(?:[;\n]|$)?/gim,
      da = /^@[^\s]*keyframes/,
      r = /\s+/g;var ja = Promise.resolve();function ka(a) {
    if (a = k[a]) a._applyShimCurrentVersion = a._applyShimCurrentVersion || 0, a._applyShimValidatingVersion = a._applyShimValidatingVersion || 0, a._applyShimNextVersion = (a._applyShimNextVersion || 0) + 1;
  }function z(a) {
    return a._applyShimCurrentVersion === a._applyShimNextVersion;
  }function la(a) {
    a._applyShimValidatingVersion = a._applyShimNextVersion;a.a || (a.a = !0, ja.then(function () {
      a._applyShimCurrentVersion = a._applyShimNextVersion;a.a = !1;
    }));
  };var A = !(window.ShadyDOM && window.ShadyDOM.inUse),
      B;function C(a) {
    B = a && a.shimcssproperties ? !1 : A || !(navigator.userAgent.match(/AppleWebKit\/601|Edge\/15/) || !window.CSS || !CSS.supports || !CSS.supports("box-shadow", "0 0 0 var(--foo)"));
  }window.ShadyCSS && void 0 !== window.ShadyCSS.nativeCss ? B = window.ShadyCSS.nativeCss : window.ShadyCSS ? (C(window.ShadyCSS), window.ShadyCSS = void 0) : C(window.WebComponents && window.WebComponents.flags);var E = B;var F = /(?:^|[;\s{]\s*)(--[\w-]*?)\s*:\s*(?:((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};{])+)|\{([^}]*)\}(?:(?=[;\s}])|$))/gi,
      G = /(?:^|\W+)@apply\s*\(?([^);\n]*)\)?/gi,
      ma = /@media\s(.*)/;function H(a) {
    if (!a) return "";"string" === typeof a && (a = p(a));return y(a, E);
  }function I(a) {
    !a.__cssRules && a.textContent && (a.__cssRules = p(a.textContent));return a.__cssRules || null;
  }function J(a, b, c, d) {
    if (a) {
      var e = !1,
          f = a.type;if (d && f === t) {
        var h = a.selector.match(ma);h && (window.matchMedia(h[1]).matches || (e = !0));
      }f === x ? b(a) : c && f === u ? c(a) : f === v && (e = !0);if ((a = a.rules) && !e) {
        e = 0;f = a.length;for (var g; e < f && (g = a[e]); e++) {
          J(g, b, c, d);
        }
      }
    }
  }
  function K(a, b) {
    var c = a.indexOf("var(");if (-1 === c) return b(a, "", "", "");a: {
      var d = 0;var e = c + 3;for (var f = a.length; e < f; e++) {
        if ("(" === a[e]) d++;else if (")" === a[e] && 0 === --d) break a;
      }e = -1;
    }d = a.substring(c + 4, e);c = a.substring(0, c);a = K(a.substring(e + 1), b);e = d.indexOf(",");return -1 === e ? b(c, d.trim(), "", a) : b(c, d.substring(0, e).trim(), d.substring(e + 1).trim(), a);
  };var na = /;\s*/m,
      oa = /^\s*(initial)|(inherit)\s*$/;function L() {
    this.a = {};
  }L.prototype.set = function (a, b) {
    a = a.trim();this.a[a] = { h: b, i: {} };
  };L.prototype.get = function (a) {
    a = a.trim();return this.a[a] || null;
  };var M = null;function N() {
    this.b = this.c = null;this.a = new L();
  }N.prototype.o = function (a) {
    a = G.test(a) || F.test(a);G.lastIndex = 0;F.lastIndex = 0;return a;
  };N.prototype.m = function (a, b) {
    a = a.content.querySelector("style");var c = null;a && (c = this.j(a, b));return c;
  };
  N.prototype.j = function (a, b) {
    b = void 0 === b ? "" : b;var c = I(a);this.l(c, b);a.textContent = H(c);return c;
  };N.prototype.f = function (a) {
    var b = this,
        c = I(a);J(c, function (a) {
      ":root" === a.selector && (a.selector = "html");b.g(a);
    });a.textContent = H(c);return c;
  };N.prototype.l = function (a, b) {
    var c = this;this.c = b;J(a, function (a) {
      c.g(a);
    });this.c = null;
  };N.prototype.g = function (a) {
    a.cssText = pa(this, a.parsedCssText);":root" === a.selector && (a.selector = ":host > *");
  };
  function pa(a, b) {
    b = b.replace(F, function (b, d, e, f) {
      return qa(a, b, d, e, f);
    });return O(a, b);
  }function O(a, b) {
    for (var c; c = G.exec(b);) {
      var d = c[0],
          e = c[1];c = c.index;var f = b.slice(0, c + d.indexOf("@apply"));b = b.slice(c + d.length);var h = P(a, f);d = void 0;var g = a;e = e.replace(na, "");var m = [];var l = g.a.get(e);l || (g.a.set(e, {}), l = g.a.get(e));if (l) for (d in g.c && (l.i[g.c] = !0), l.h) {
        g = h && h[d], l = [d, ": var(", e, "_-_", d], g && l.push(",", g), l.push(")"), m.push(l.join(""));
      }d = m.join("; ");b = "" + f + d + b;G.lastIndex = c + d.length;
    }return b;
  }
  function P(a, b) {
    b = b.split(";");for (var c, d, e = {}, f = 0, h; f < b.length; f++) {
      if (c = b[f]) if (h = c.split(":"), 1 < h.length) {
        c = h[0].trim();var g = a;d = c;h = h.slice(1).join(":");var m = oa.exec(h);m && (m[1] ? (g.b || (g.b = document.createElement("meta"), g.b.setAttribute("apply-shim-measure", ""), g.b.style.all = "initial", document.head.appendChild(g.b)), d = window.getComputedStyle(g.b).getPropertyValue(d)) : d = "apply-shim-inherit", h = d);d = h;e[c] = d;
      }
    }return e;
  }function ra(a, b) {
    if (M) for (var c in b.i) {
      c !== a.c && M(c);
    }
  }
  function qa(a, b, c, d, e) {
    d && K(d, function (b, c) {
      c && a.a.get(c) && (e = "@apply " + c + ";");
    });if (!e) return b;var f = O(a, e),
        h = b.slice(0, b.indexOf("--")),
        g = f = P(a, f),
        m = a.a.get(c),
        l = m && m.h;l ? g = Object.assign(Object.create(l), f) : a.a.set(c, g);var X = [],
        w,
        Y = !1;for (w in g) {
      var D = f[w];void 0 === D && (D = "initial");!l || w in l || (Y = !0);X.push("" + c + "_-_" + w + ": " + D);
    }Y && ra(a, m);m && (m.h = g);d && (h = b + ";" + h);return "" + h + X.join("; ") + ";";
  }N.prototype.detectMixin = N.prototype.o;N.prototype.transformStyle = N.prototype.j;
  N.prototype.transformCustomStyle = N.prototype.f;N.prototype.transformRules = N.prototype.l;N.prototype.transformRule = N.prototype.g;N.prototype.transformTemplate = N.prototype.m;N.prototype._separator = "_-_";Object.defineProperty(N.prototype, "invalidCallback", { get: function get() {
      return M;
    }, set: function set(a) {
      M = a;
    } });var Q = null,
      R = window.HTMLImports && window.HTMLImports.whenReady || null,
      S;function sa(a) {
    requestAnimationFrame(function () {
      R ? R(a) : (Q || (Q = new Promise(function (a) {
        S = a;
      }), "complete" === document.readyState ? S() : document.addEventListener("readystatechange", function () {
        "complete" === document.readyState && S();
      })), Q.then(function () {
        a && a();
      }));
    });
  };var T = new N();function U() {
    var a = this;this.a = null;sa(function () {
      V(a);
    });T.invalidCallback = ka;
  }function V(a) {
    a.a || (a.a = window.ShadyCSS.CustomStyleInterface, a.a && (a.a.transformCallback = function (a) {
      T.f(a);
    }, a.a.validateCallback = function () {
      requestAnimationFrame(function () {
        a.a.enqueued && W(a);
      });
    }));
  }U.prototype.prepareTemplate = function (a, b) {
    V(this);k[b] = a;b = T.m(a, b);a._styleAst = b;
  };
  function W(a) {
    V(a);if (a.a) {
      var b = a.a.processStyles();if (a.a.enqueued) {
        for (var c = 0; c < b.length; c++) {
          var d = a.a.getStyleForCustomStyle(b[c]);d && T.f(d);
        }a.a.enqueued = !1;
      }
    }
  }U.prototype.styleSubtree = function (a, b) {
    V(this);if (b) for (var c in b) {
      null === c ? a.style.removeProperty(c) : a.style.setProperty(c, b[c]);
    }if (a.shadowRoot) for (this.styleElement(a), a = a.shadowRoot.children || a.shadowRoot.childNodes, b = 0; b < a.length; b++) {
      this.styleSubtree(a[b]);
    } else for (a = a.children || a.childNodes, b = 0; b < a.length; b++) {
      this.styleSubtree(a[b]);
    }
  };
  U.prototype.styleElement = function (a) {
    V(this);var b = a.localName,
        c;b ? -1 < b.indexOf("-") ? c = b : c = a.getAttribute && a.getAttribute("is") || "" : c = a.is;if ((b = k[c]) && !z(b)) {
      if (z(b) || b._applyShimValidatingVersion !== b._applyShimNextVersion) this.prepareTemplate(b, c), la(b);if (a = a.shadowRoot) if (a = a.querySelector("style")) a.__cssRules = b._styleAst, a.textContent = H(b._styleAst);
    }
  };U.prototype.styleDocument = function (a) {
    V(this);this.styleSubtree(document.body, a);
  };
  if (!window.ShadyCSS || !window.ShadyCSS.ScopingShim) {
    var Z = new U(),
        ta = window.ShadyCSS && window.ShadyCSS.CustomStyleInterface;window.ShadyCSS = { prepareTemplate: function prepareTemplate(a, b) {
        W(Z);Z.prepareTemplate(a, b);
      }, styleSubtree: function styleSubtree(a, b) {
        W(Z);Z.styleSubtree(a, b);
      }, styleElement: function styleElement(a) {
        W(Z);Z.styleElement(a);
      }, styleDocument: function styleDocument(a) {
        W(Z);Z.styleDocument(a);
      }, getComputedStyleValue: function getComputedStyleValue(a, b) {
        return (a = window.getComputedStyle(a).getPropertyValue(b)) ? a.trim() : "";
      }, nativeCss: E, nativeShadow: A };ta && (window.ShadyCSS.CustomStyleInterface = ta);
  }window.ShadyCSS.ApplyShim = T;
}).call(undefined);

//# sourceMappingURL=apply-shim.min.js.map

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(1);

__webpack_require__(8);

__webpack_require__(12);

(function () {

  'use strict';

  // detect native touch action support

  var HAS_NATIVE_TA = typeof document.head.style.touchAction === 'string';
  var GESTURE_KEY = '__polymerGestures';
  var HANDLED_OBJ = '__polymerGesturesHandled';
  var TOUCH_ACTION = '__polymerGesturesTouchAction';
  // radius for tap and track
  var TAP_DISTANCE = 25;
  var TRACK_DISTANCE = 5;
  // number of last N track positions to keep
  var TRACK_LENGTH = 2;

  // Disabling "mouse" handlers for 2500ms is enough
  var MOUSE_TIMEOUT = 2500;
  var MOUSE_EVENTS = ['mousedown', 'mousemove', 'mouseup', 'click'];
  // an array of bitmask values for mapping MouseEvent.which to MouseEvent.buttons
  var MOUSE_WHICH_TO_BUTTONS = [0, 1, 4, 2];
  var MOUSE_HAS_BUTTONS = function () {
    try {
      return new MouseEvent('test', { buttons: 1 }).buttons === 1;
    } catch (e) {
      return false;
    }
  }();

  /* eslint no-empty: ["error", { "allowEmptyCatch": true }] */
  // check for passive event listeners
  var SUPPORTS_PASSIVE = false;
  (function () {
    try {
      var opts = Object.defineProperty({}, 'passive', { get: function get() {
          SUPPORTS_PASSIVE = true;
        } });
      window.addEventListener('test', null, opts);
      window.removeEventListener('test', null, opts);
    } catch (e) {}
  })();

  // Check for touch-only devices
  var IS_TOUCH_ONLY = navigator.userAgent.match(/iP(?:[oa]d|hone)|Android/);

  var GestureRecognizer = function GestureRecognizer() {}; // eslint-disable-line no-unused-vars
  GestureRecognizer.prototype.reset = function () {};
  /** @type {function(MouseEvent) | undefined} */
  GestureRecognizer.prototype.mousedown;
  /** @type {(function(MouseEvent) | undefined)} */
  GestureRecognizer.prototype.mousemove;
  /** @type {(function(MouseEvent) | undefined)} */
  GestureRecognizer.prototype.mouseup;
  /** @type {(function(TouchEvent) | undefined)} */
  GestureRecognizer.prototype.touchstart;
  /** @type {(function(TouchEvent) | undefined)} */
  GestureRecognizer.prototype.touchmove;
  /** @type {(function(TouchEvent) | undefined)} */
  GestureRecognizer.prototype.touchend;
  /** @type {(function(MouseEvent) | undefined)} */
  GestureRecognizer.prototype.click;

  // touch will make synthetic mouse events
  // `preventDefault` on touchend will cancel them,
  // but this breaks `<input>` focus and link clicks
  // disable mouse handlers for MOUSE_TIMEOUT ms after
  // a touchend to ignore synthetic mouse events
  var mouseCanceller = function mouseCanceller(mouseEvent) {
    // Check for sourceCapabilities, used to distinguish synthetic events
    // if mouseEvent did not come from a device that fires touch events,
    // it was made by a real mouse and should be counted
    // http://wicg.github.io/InputDeviceCapabilities/#dom-inputdevicecapabilities-firestouchevents
    var sc = mouseEvent.sourceCapabilities;
    if (sc && !sc.firesTouchEvents) {
      return;
    }
    // skip synthetic mouse events
    mouseEvent[HANDLED_OBJ] = { skip: true };
    // disable "ghost clicks"
    if (mouseEvent.type === 'click') {
      var path = mouseEvent.composedPath && mouseEvent.composedPath();
      if (path) {
        for (var i = 0; i < path.length; i++) {
          if (path[i] === POINTERSTATE.mouse.target) {
            return;
          }
        }
      }
      mouseEvent.preventDefault();
      mouseEvent.stopPropagation();
    }
  };

  /**
   * @param {boolean=} setup True to add, false to remove.
   */
  function setupTeardownMouseCanceller(setup) {
    var events = IS_TOUCH_ONLY ? ['click'] : MOUSE_EVENTS;
    for (var i = 0, en; i < events.length; i++) {
      en = events[i];
      if (setup) {
        document.addEventListener(en, mouseCanceller, true);
      } else {
        document.removeEventListener(en, mouseCanceller, true);
      }
    }
  }

  function ignoreMouse(e) {
    if (!POINTERSTATE.mouse.mouseIgnoreJob) {
      setupTeardownMouseCanceller(true);
    }
    var unset = function unset() {
      setupTeardownMouseCanceller();
      POINTERSTATE.mouse.target = null;
      POINTERSTATE.mouse.mouseIgnoreJob = null;
    };
    POINTERSTATE.mouse.target = e.composedPath()[0];
    POINTERSTATE.mouse.mouseIgnoreJob = Polymer.Debouncer.debounce(POINTERSTATE.mouse.mouseIgnoreJob, Polymer.Async.timeOut.after(MOUSE_TIMEOUT), unset);
  }

  /**
   * @param {MouseEvent} ev event to test for left mouse button down
   * @return {boolean} has left mouse button down
   */
  function hasLeftMouseButton(ev) {
    var type = ev.type;
    // exit early if the event is not a mouse event
    if (MOUSE_EVENTS.indexOf(type) === -1) {
      return false;
    }
    // ev.button is not reliable for mousemove (0 is overloaded as both left button and no buttons)
    // instead we use ev.buttons (bitmask of buttons) or fall back to ev.which (deprecated, 0 for no buttons, 1 for left button)
    if (type === 'mousemove') {
      // allow undefined for testing events
      var buttons = ev.buttons === undefined ? 1 : ev.buttons;
      if (ev instanceof window.MouseEvent && !MOUSE_HAS_BUTTONS) {
        buttons = MOUSE_WHICH_TO_BUTTONS[ev.which] || 0;
      }
      // buttons is a bitmask, check that the left button bit is set (1)
      return Boolean(buttons & 1);
    } else {
      // allow undefined for testing events
      var button = ev.button === undefined ? 0 : ev.button;
      // ev.button is 0 in mousedown/mouseup/click for left button activation
      return button === 0;
    }
  }

  function isSyntheticClick(ev) {
    if (ev.type === 'click') {
      // ev.detail is 0 for HTMLElement.click in most browsers
      if (ev.detail === 0) {
        return true;
      }
      // in the worst case, check that the x/y position of the click is within
      // the bounding box of the target of the event
      // Thanks IE 10 >:(
      var t = Gestures._findOriginalTarget(ev);
      // make sure the target of the event is an element so we can use getBoundingClientRect,
      // if not, just assume it is a synthetic click
      if (!t.nodeType || /** @type {Element} */t.nodeType !== Node.ELEMENT_NODE) {
        return true;
      }
      var bcr = /** @type {Element} */t.getBoundingClientRect();
      // use page x/y to account for scrolling
      var x = ev.pageX,
          y = ev.pageY;
      // ev is a synthetic click if the position is outside the bounding box of the target
      return !(x >= bcr.left && x <= bcr.right && y >= bcr.top && y <= bcr.bottom);
    }
    return false;
  }

  var POINTERSTATE = {
    mouse: {
      target: null,
      mouseIgnoreJob: null
    },
    touch: {
      x: 0,
      y: 0,
      id: -1,
      scrollDecided: false
    }
  };

  function firstTouchAction(ev) {
    var ta = 'auto';
    var path = ev.composedPath && ev.composedPath();
    if (path) {
      for (var i = 0, n; i < path.length; i++) {
        n = path[i];
        if (n[TOUCH_ACTION]) {
          ta = n[TOUCH_ACTION];
          break;
        }
      }
    }
    return ta;
  }

  function trackDocument(stateObj, movefn, upfn) {
    stateObj.movefn = movefn;
    stateObj.upfn = upfn;
    document.addEventListener('mousemove', movefn);
    document.addEventListener('mouseup', upfn);
  }

  function untrackDocument(stateObj) {
    document.removeEventListener('mousemove', stateObj.movefn);
    document.removeEventListener('mouseup', stateObj.upfn);
    stateObj.movefn = null;
    stateObj.upfn = null;
  }

  // use a document-wide touchend listener to start the ghost-click prevention mechanism
  // Use passive event listeners, if supported, to not affect scrolling performance
  document.addEventListener('touchend', ignoreMouse, SUPPORTS_PASSIVE ? { passive: true } : false);

  /**
   * Module for adding listeners to a node for the following normalized
   * cross-platform "gesture" events:
   * - `down` - mouse or touch went down
   * - `up` - mouse or touch went up
   * - `tap` - mouse click or finger tap
   * - `track` - mouse drag or touch move
   *
   * @namespace
   * @memberof Polymer
   * @summary Module for adding cross-platform gesture event listeners.
   */
  var Gestures = {
    gestures: {},
    recognizers: [],

    /**
     * Finds the element rendered on the screen at the provided coordinates.
     *
     * Similar to `document.elementFromPoint`, but pierces through
     * shadow roots.
     *
     * @memberof Polymer.Gestures
     * @param {number} x Horizontal pixel coordinate
     * @param {number} y Vertical pixel coordinate
     * @return {Element} Returns the deepest shadowRoot inclusive element
     * found at the screen position given.
     */
    deepTargetFind: function deepTargetFind(x, y) {
      var node = document.elementFromPoint(x, y);
      var next = node;
      // this code path is only taken when native ShadowDOM is used
      // if there is a shadowroot, it may have a node at x/y
      // if there is not a shadowroot, exit the loop
      while (next && next.shadowRoot && !window.ShadyDOM) {
        // if there is a node at x/y in the shadowroot, look deeper
        var oldNext = next;
        next = next.shadowRoot.elementFromPoint(x, y);
        // on Safari, elementFromPoint may return the shadowRoot host
        if (oldNext === next) {
          break;
        }
        if (next) {
          node = next;
        }
      }
      return node;
    },
    /**
     * a cheaper check than ev.composedPath()[0];
     *
     * @private
     * @param {Event} ev Event.
     * @return {EventTarget} Returns the event target.
     */
    _findOriginalTarget: function _findOriginalTarget(ev) {
      // shadowdom
      if (ev.composedPath) {
        return (/** @type {EventTarget} */ev.composedPath()[0]
        );
      }
      // shadydom
      return ev.target;
    },

    /**
     * @private
     * @param {Event} ev Event.
     */
    _handleNative: function _handleNative(ev) {
      var handled = void 0;
      var type = ev.type;
      var node = ev.currentTarget;
      var gobj = node[GESTURE_KEY];
      if (!gobj) {
        return;
      }
      var gs = gobj[type];
      if (!gs) {
        return;
      }
      if (!ev[HANDLED_OBJ]) {
        ev[HANDLED_OBJ] = {};
        if (type.slice(0, 5) === 'touch') {
          ev = /** @type {TouchEvent} */ev; // eslint-disable-line no-self-assign
          var t = ev.changedTouches[0];
          if (type === 'touchstart') {
            // only handle the first finger
            if (ev.touches.length === 1) {
              POINTERSTATE.touch.id = t.identifier;
            }
          }
          if (POINTERSTATE.touch.id !== t.identifier) {
            return;
          }
          if (!HAS_NATIVE_TA) {
            if (type === 'touchstart' || type === 'touchmove') {
              Gestures._handleTouchAction(ev);
            }
          }
        }
      }
      handled = ev[HANDLED_OBJ];
      // used to ignore synthetic mouse events
      if (handled.skip) {
        return;
      }
      var recognizers = Gestures.recognizers;
      // reset recognizer state
      for (var i = 0, r; i < recognizers.length; i++) {
        r = recognizers[i];
        if (gs[r.name] && !handled[r.name]) {
          if (r.flow && r.flow.start.indexOf(ev.type) > -1 && r.reset) {
            r.reset();
          }
        }
      }
      // enforce gesture recognizer order
      for (var _i = 0, _r; _i < recognizers.length; _i++) {
        _r = recognizers[_i];
        if (gs[_r.name] && !handled[_r.name]) {
          handled[_r.name] = true;
          _r[type](ev);
        }
      }
    },

    /**
     * @private
     * @param {TouchEvent} ev Event.
     */
    _handleTouchAction: function _handleTouchAction(ev) {
      var t = ev.changedTouches[0];
      var type = ev.type;
      if (type === 'touchstart') {
        POINTERSTATE.touch.x = t.clientX;
        POINTERSTATE.touch.y = t.clientY;
        POINTERSTATE.touch.scrollDecided = false;
      } else if (type === 'touchmove') {
        if (POINTERSTATE.touch.scrollDecided) {
          return;
        }
        POINTERSTATE.touch.scrollDecided = true;
        var ta = firstTouchAction(ev);
        var prevent = false;
        var dx = Math.abs(POINTERSTATE.touch.x - t.clientX);
        var dy = Math.abs(POINTERSTATE.touch.y - t.clientY);
        if (!ev.cancelable) {
          // scrolling is happening
        } else if (ta === 'none') {
          prevent = true;
        } else if (ta === 'pan-x') {
          prevent = dy > dx;
        } else if (ta === 'pan-y') {
          prevent = dx > dy;
        }
        if (prevent) {
          ev.preventDefault();
        } else {
          Gestures.prevent('track');
        }
      }
    },

    /**
     * Adds an event listener to a node for the given gesture type.
     *
     * @memberof Polymer.Gestures
     * @param {Node} node Node to add listener on
     * @param {string} evType Gesture type: `down`, `up`, `track`, or `tap`
     * @param {Function} handler Event listener function to call
     * @return {boolean} Returns true if a gesture event listener was added.
     * @this {Gestures}
     */
    addListener: function addListener(node, evType, handler) {
      if (this.gestures[evType]) {
        this._add(node, evType, handler);
        return true;
      }
      return false;
    },

    /**
     * Removes an event listener from a node for the given gesture type.
     *
     * @memberof Polymer.Gestures
     * @param {Node} node Node to remove listener from
     * @param {string} evType Gesture type: `down`, `up`, `track`, or `tap`
     * @param {Function} handler Event listener function previously passed to
     *  `addListener`.
     * @return {boolean} Returns true if a gesture event listener was removed.
     * @this {Gestures}
     */
    removeListener: function removeListener(node, evType, handler) {
      if (this.gestures[evType]) {
        this._remove(node, evType, handler);
        return true;
      }
      return false;
    },

    /**
     * automate the event listeners for the native events
     *
     * @private
     * @param {HTMLElement} node Node on which to add the event.
     * @param {string} evType Event type to add.
     * @param {function(Event?)} handler Event handler function.
     * @this {Gestures}
     */
    _add: function _add(node, evType, handler) {
      var recognizer = this.gestures[evType];
      var deps = recognizer.deps;
      var name = recognizer.name;
      var gobj = node[GESTURE_KEY];
      if (!gobj) {
        node[GESTURE_KEY] = gobj = {};
      }
      for (var i = 0, dep, gd; i < deps.length; i++) {
        dep = deps[i];
        // don't add mouse handlers on iOS because they cause gray selection overlays
        if (IS_TOUCH_ONLY && MOUSE_EVENTS.indexOf(dep) > -1 && dep !== 'click') {
          continue;
        }
        gd = gobj[dep];
        if (!gd) {
          gobj[dep] = gd = { _count: 0 };
        }
        if (gd._count === 0) {
          node.addEventListener(dep, this._handleNative);
        }
        gd[name] = (gd[name] || 0) + 1;
        gd._count = (gd._count || 0) + 1;
      }
      node.addEventListener(evType, handler);
      if (recognizer.touchAction) {
        this.setTouchAction(node, recognizer.touchAction);
      }
    },

    /**
     * automate event listener removal for native events
     *
     * @private
     * @param {HTMLElement} node Node on which to remove the event.
     * @param {string} evType Event type to remove.
     * @param {function(Event?)} handler Event handler function.
     * @this {Gestures}
     */
    _remove: function _remove(node, evType, handler) {
      var recognizer = this.gestures[evType];
      var deps = recognizer.deps;
      var name = recognizer.name;
      var gobj = node[GESTURE_KEY];
      if (gobj) {
        for (var i = 0, dep, gd; i < deps.length; i++) {
          dep = deps[i];
          gd = gobj[dep];
          if (gd && gd[name]) {
            gd[name] = (gd[name] || 1) - 1;
            gd._count = (gd._count || 1) - 1;
            if (gd._count === 0) {
              node.removeEventListener(dep, this._handleNative);
            }
          }
        }
      }
      node.removeEventListener(evType, handler);
    },

    /**
     * Registers a new gesture event recognizer for adding new custom
     * gesture event types.
     *
     * @memberof Polymer.Gestures
     * @param {GestureRecognizer} recog Gesture recognizer descriptor
     * @this {Gestures}
     */
    register: function register(recog) {
      this.recognizers.push(recog);
      for (var i = 0; i < recog.emits.length; i++) {
        this.gestures[recog.emits[i]] = recog;
      }
    },

    /**
     * @private
     * @param {string} evName Event name.
     * @return {Object} Returns the gesture for the given event name.
     * @this {Gestures}
     */
    _findRecognizerByEvent: function _findRecognizerByEvent(evName) {
      for (var i = 0, r; i < this.recognizers.length; i++) {
        r = this.recognizers[i];
        for (var j = 0, n; j < r.emits.length; j++) {
          n = r.emits[j];
          if (n === evName) {
            return r;
          }
        }
      }
      return null;
    },

    /**
     * Sets scrolling direction on node.
     *
     * This value is checked on first move, thus it should be called prior to
     * adding event listeners.
     *
     * @memberof Polymer.Gestures
     * @param {Element} node Node to set touch action setting on
     * @param {string} value Touch action value
     */
    setTouchAction: function setTouchAction(node, value) {
      if (HAS_NATIVE_TA) {
        node.style.touchAction = value;
      }
      node[TOUCH_ACTION] = value;
    },

    /**
     * Dispatches an event on the `target` element of `type` with the given
     * `detail`.
     * @private
     * @param {EventTarget} target The element on which to fire an event.
     * @param {string} type The type of event to fire.
     * @param {Object=} detail The detail object to populate on the event.
     */
    _fire: function _fire(target, type, detail) {
      var ev = new Event(type, { bubbles: true, cancelable: true, composed: true });
      ev.detail = detail;
      target.dispatchEvent(ev);
      // forward `preventDefault` in a clean way
      if (ev.defaultPrevented) {
        var preventer = detail.preventer || detail.sourceEvent;
        if (preventer && preventer.preventDefault) {
          preventer.preventDefault();
        }
      }
    },

    /**
     * Prevents the dispatch and default action of the given event name.
     *
     * @memberof Polymer.Gestures
     * @param {string} evName Event name.
     * @this {Gestures}
     */
    prevent: function prevent(evName) {
      var recognizer = this._findRecognizerByEvent(evName);
      if (recognizer.info) {
        recognizer.info.prevent = true;
      }
    },

    /**
     * Reset the 2500ms timeout on processing mouse input after detecting touch input.
     *
     * Touch inputs create synthesized mouse inputs anywhere from 0 to 2000ms after the touch.
     * This method should only be called during testing with simulated touch inputs.
     * Calling this method in production may cause duplicate taps or other Gestures.
     *
     * @memberof Polymer.Gestures
     */
    resetMouseCanceller: function resetMouseCanceller() {
      if (POINTERSTATE.mouse.mouseIgnoreJob) {
        POINTERSTATE.mouse.mouseIgnoreJob.flush();
      }
    }
  };

  /* eslint-disable valid-jsdoc */

  Gestures.register({
    name: 'downup',
    deps: ['mousedown', 'touchstart', 'touchend'],
    flow: {
      start: ['mousedown', 'touchstart'],
      end: ['mouseup', 'touchend']
    },
    emits: ['down', 'up'],

    info: {
      movefn: null,
      upfn: null
    },

    /** @this {GestureRecognizer} */
    reset: function reset() {
      untrackDocument(this.info);
    },

    /**
     * @this {GestureRecognizer}
     * @param {MouseEvent} e
     */
    mousedown: function mousedown(e) {
      if (!hasLeftMouseButton(e)) {
        return;
      }
      var t = Gestures._findOriginalTarget(e);
      var self = this;
      var movefn = function movefn(e) {
        if (!hasLeftMouseButton(e)) {
          self._fire('up', t, e);
          untrackDocument(self.info);
        }
      };
      var upfn = function upfn(e) {
        if (hasLeftMouseButton(e)) {
          self._fire('up', t, e);
        }
        untrackDocument(self.info);
      };
      trackDocument(this.info, movefn, upfn);
      this._fire('down', t, e);
    },
    /**
     * @this {GestureRecognizer}
     * @param {TouchEvent} e
     */
    touchstart: function touchstart(e) {
      this._fire('down', Gestures._findOriginalTarget(e), e.changedTouches[0], e);
    },
    /**
     * @this {GestureRecognizer}
     * @param {TouchEvent} e
     */
    touchend: function touchend(e) {
      this._fire('up', Gestures._findOriginalTarget(e), e.changedTouches[0], e);
    },
    /**
     * @param {string} type
     * @param {EventTarget} target
     * @param {Event} event
     * @param {Function} preventer
     */
    _fire: function _fire(type, target, event, preventer) {
      Gestures._fire(target, type, {
        x: event.clientX,
        y: event.clientY,
        sourceEvent: event,
        preventer: preventer,
        prevent: function prevent(e) {
          return Gestures.prevent(e);
        }
      });
    }
  });

  Gestures.register({
    name: 'track',
    touchAction: 'none',
    deps: ['mousedown', 'touchstart', 'touchmove', 'touchend'],
    flow: {
      start: ['mousedown', 'touchstart'],
      end: ['mouseup', 'touchend']
    },
    emits: ['track'],

    info: {
      x: 0,
      y: 0,
      state: 'start',
      started: false,
      moves: [],
      /** @this {GestureRecognizer} */
      addMove: function addMove(move) {
        if (this.moves.length > TRACK_LENGTH) {
          this.moves.shift();
        }
        this.moves.push(move);
      },
      movefn: null,
      upfn: null,
      prevent: false
    },

    /** @this {GestureRecognizer} */
    reset: function reset() {
      this.info.state = 'start';
      this.info.started = false;
      this.info.moves = [];
      this.info.x = 0;
      this.info.y = 0;
      this.info.prevent = false;
      untrackDocument(this.info);
    },

    /**
     * @this {GestureRecognizer}
     * @param {number} x
     * @param {number} y
     * @return {boolean}
     */
    hasMovedEnough: function hasMovedEnough(x, y) {
      if (this.info.prevent) {
        return false;
      }
      if (this.info.started) {
        return true;
      }
      var dx = Math.abs(this.info.x - x);
      var dy = Math.abs(this.info.y - y);
      return dx >= TRACK_DISTANCE || dy >= TRACK_DISTANCE;
    },
    /**
     * @this {GestureRecognizer}
     * @param {MouseEvent} e
     */
    mousedown: function mousedown(e) {
      if (!hasLeftMouseButton(e)) {
        return;
      }
      var t = Gestures._findOriginalTarget(e);
      var self = this;
      var movefn = function movefn(e) {
        var x = e.clientX,
            y = e.clientY;
        if (self.hasMovedEnough(x, y)) {
          // first move is 'start', subsequent moves are 'move', mouseup is 'end'
          self.info.state = self.info.started ? e.type === 'mouseup' ? 'end' : 'track' : 'start';
          if (self.info.state === 'start') {
            // if and only if tracking, always prevent tap
            Gestures.prevent('tap');
          }
          self.info.addMove({ x: x, y: y });
          if (!hasLeftMouseButton(e)) {
            // always _fire "end"
            self.info.state = 'end';
            untrackDocument(self.info);
          }
          self._fire(t, e);
          self.info.started = true;
        }
      };
      var upfn = function upfn(e) {
        if (self.info.started) {
          movefn(e);
        }

        // remove the temporary listeners
        untrackDocument(self.info);
      };
      // add temporary document listeners as mouse retargets
      trackDocument(this.info, movefn, upfn);
      this.info.x = e.clientX;
      this.info.y = e.clientY;
    },
    /**
     * @this {GestureRecognizer}
     * @param {TouchEvent} e
     */
    touchstart: function touchstart(e) {
      var ct = e.changedTouches[0];
      this.info.x = ct.clientX;
      this.info.y = ct.clientY;
    },
    /**
     * @this {GestureRecognizer}
     * @param {TouchEvent} e
     */
    touchmove: function touchmove(e) {
      var t = Gestures._findOriginalTarget(e);
      var ct = e.changedTouches[0];
      var x = ct.clientX,
          y = ct.clientY;
      if (this.hasMovedEnough(x, y)) {
        if (this.info.state === 'start') {
          // if and only if tracking, always prevent tap
          Gestures.prevent('tap');
        }
        this.info.addMove({ x: x, y: y });
        this._fire(t, ct);
        this.info.state = 'track';
        this.info.started = true;
      }
    },
    /**
     * @this {GestureRecognizer}
     * @param {TouchEvent} e
     */
    touchend: function touchend(e) {
      var t = Gestures._findOriginalTarget(e);
      var ct = e.changedTouches[0];
      // only trackend if track was started and not aborted
      if (this.info.started) {
        // reset started state on up
        this.info.state = 'end';
        this.info.addMove({ x: ct.clientX, y: ct.clientY });
        this._fire(t, ct, e);
      }
    },

    /**
     * @this {GestureRecognizer}
     * @param {EventTarget} target
     * @param {Touch} touch
     */
    _fire: function _fire(target, touch) {
      var secondlast = this.info.moves[this.info.moves.length - 2];
      var lastmove = this.info.moves[this.info.moves.length - 1];
      var dx = lastmove.x - this.info.x;
      var dy = lastmove.y - this.info.y;
      var ddx = void 0,
          ddy = 0;
      if (secondlast) {
        ddx = lastmove.x - secondlast.x;
        ddy = lastmove.y - secondlast.y;
      }
      Gestures._fire(target, 'track', {
        state: this.info.state,
        x: touch.clientX,
        y: touch.clientY,
        dx: dx,
        dy: dy,
        ddx: ddx,
        ddy: ddy,
        sourceEvent: touch,
        hover: function hover() {
          return Gestures.deepTargetFind(touch.clientX, touch.clientY);
        }
      });
    }

  });

  Gestures.register({
    name: 'tap',
    deps: ['mousedown', 'click', 'touchstart', 'touchend'],
    flow: {
      start: ['mousedown', 'touchstart'],
      end: ['click', 'touchend']
    },
    emits: ['tap'],
    info: {
      x: NaN,
      y: NaN,
      prevent: false
    },
    /** @this {GestureRecognizer} */
    reset: function reset() {
      this.info.x = NaN;
      this.info.y = NaN;
      this.info.prevent = false;
    },
    /** @this {GestureRecognizer} */
    save: function save(e) {
      this.info.x = e.clientX;
      this.info.y = e.clientY;
    },
    /**
     * @this {GestureRecognizer}
     * @param {MouseEvent} e
     */
    mousedown: function mousedown(e) {
      if (hasLeftMouseButton(e)) {
        this.save(e);
      }
    },
    /**
     * @this {GestureRecognizer}
     * @param {MouseEvent} e
     */
    click: function click(e) {
      if (hasLeftMouseButton(e)) {
        this.forward(e);
      }
    },
    /**
     * @this {GestureRecognizer}
     * @param {TouchEvent} e
     */
    touchstart: function touchstart(e) {
      this.save(e.changedTouches[0], e);
    },
    /**
     * @this {GestureRecognizer}
     * @param {TouchEvent} e
     */
    touchend: function touchend(e) {
      this.forward(e.changedTouches[0], e);
    },
    /**
     * @this {GestureRecognizer}
     * @param {Event} e
     * @param {Function} preventer
     */
    forward: function forward(e, preventer) {
      var dx = Math.abs(e.clientX - this.info.x);
      var dy = Math.abs(e.clientY - this.info.y);
      var t = Gestures._findOriginalTarget(e);
      // dx,dy can be NaN if `click` has been simulated and there was no `down` for `start`
      if (isNaN(dx) || isNaN(dy) || dx <= TAP_DISTANCE && dy <= TAP_DISTANCE || isSyntheticClick(e)) {
        // prevent taps from being generated if an event has canceled them
        if (!this.info.prevent) {
          Gestures._fire(t, 'tap', {
            x: e.clientX,
            y: e.clientY,
            sourceEvent: e,
            preventer: preventer
          });
        }
      }
    }
  });

  /* eslint-enable valid-jsdoc */

  /** @deprecated */
  Gestures.findOriginalTarget = Gestures._findOriginalTarget;

  /** @deprecated */
  Gestures.add = Gestures.addListener;

  /** @deprecated */
  Gestures.remove = Gestures.removeListener;

  Polymer.Gestures = Gestures;
})();

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(1);

(function () {

  'use strict';

  // run a callback when HTMLImports are ready or immediately if
  // this api is not available.

  function whenImportsReady(cb) {
    if (window.HTMLImports) {
      HTMLImports.whenReady(cb);
    } else {
      cb();
    }
  }

  /**
   * Convenience method for importing an HTML document imperatively.
   *
   * This method creates a new `<link rel="import">` element with
   * the provided URL and appends it to the document to start loading.
   * In the `onload` callback, the `import` property of the `link`
   * element will contain the imported document contents.
   *
   * @memberof Polymer
   * @param {string} href URL to document to load.
   * @param {Function=} onload Callback to notify when an import successfully
   *   loaded.
   * @param {Function=} onerror Callback to notify when an import
   *   unsuccessfully loaded.
   * @param {boolean=} optAsync True if the import should be loaded `async`.
   *   Defaults to `false`.
   * @return {HTMLLinkElement} The link element for the URL to be loaded.
   */
  Polymer.importHref = function (href, onload, onerror, optAsync) {
    var link = /** @type {HTMLLinkElement} */
    document.head.querySelector('link[href="' + href + '"][import-href]');
    if (!link) {
      link = /** @type {HTMLLinkElement} */document.createElement('link');
      link.rel = 'import';
      link.href = href;
      link.setAttribute('import-href', '');
    }
    // always ensure link has `async` attribute if user specified one,
    // even if it was previously not async. This is considered less confusing.
    if (optAsync) {
      link.setAttribute('async', '');
    }
    // NOTE: the link may now be in 3 states: (1) pending insertion,
    // (2) inflight, (3) already laoded. In each case, we need to add
    // event listeners to process callbacks.
    var cleanup = function cleanup() {
      link.removeEventListener('load', loadListener);
      link.removeEventListener('error', errorListener);
    };
    var loadListener = function loadListener(event) {
      cleanup();
      // In case of a successful load, cache the load event on the link so
      // that it can be used to short-circuit this method in the future when
      // it is called with the same href param.
      link.__dynamicImportLoaded = true;
      if (onload) {
        whenImportsReady(function () {
          onload(event);
        });
      }
    };
    var errorListener = function errorListener(event) {
      cleanup();
      // In case of an error, remove the link from the document so that it
      // will be automatically created again the next time `importHref` is
      // called.
      if (link.parentNode) {
        link.parentNode.removeChild(link);
      }
      if (onerror) {
        whenImportsReady(function () {
          onerror(event);
        });
      }
    };
    link.addEventListener('load', loadListener);
    link.addEventListener('error', errorListener);
    if (link.parentNode == null) {
      document.head.appendChild(link);
      // if the link already loaded, dispatch a fake load event
      // so that listeners are called and get a proper event argument.
    } else if (link.__dynamicImportLoaded) {
      link.dispatchEvent(new Event('load'));
    }
    return link;
  };
})();

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(1);

(function () {

  'use strict';

  var scheduled = false;
  var beforeRenderQueue = [];
  var afterRenderQueue = [];

  function schedule() {
    scheduled = true;
    // before next render
    requestAnimationFrame(function () {
      scheduled = false;
      flushQueue(beforeRenderQueue);
      // after the render
      setTimeout(function () {
        runQueue(afterRenderQueue);
      });
    });
  }

  function flushQueue(queue) {
    while (queue.length) {
      callMethod(queue.shift());
    }
  }

  function runQueue(queue) {
    for (var i = 0, l = queue.length; i < l; i++) {
      callMethod(queue.shift());
    }
  }

  function callMethod(info) {
    var context = info[0];
    var callback = info[1];
    var args = info[2];
    try {
      callback.apply(context, args);
    } catch (e) {
      setTimeout(function () {
        throw e;
      });
    }
  }

  function flush() {
    while (beforeRenderQueue.length || afterRenderQueue.length) {
      flushQueue(beforeRenderQueue);
      flushQueue(afterRenderQueue);
    }
    scheduled = false;
  }

  /**
   * Module for scheduling flushable pre-render and post-render tasks.
   *
   * @namespace
   * @memberof Polymer
   * @summary Module for scheduling flushable pre-render and post-render tasks.
   */
  Polymer.RenderStatus = {

    /**
     * Enqueues a callback which will be run before the next render, at
     * `requestAnimationFrame` timing.
     *
     * This method is useful for enqueuing work that requires DOM measurement,
     * since measurement may not be reliable in custom element callbacks before
     * the first render, as well as for batching measurement tasks in general.
     *
     * Tasks in this queue may be flushed by calling `Polymer.RenderStatus.flush()`.
     *
     * @memberof Polymer.RenderStatus
     * @param {*} context Context object the callback function will be bound to
     * @param {function()} callback Callback function
     * @param {Array} args An array of arguments to call the callback function with
     */
    beforeNextRender: function beforeNextRender(context, callback, args) {
      if (!scheduled) {
        schedule();
      }
      beforeRenderQueue.push([context, callback, args]);
    },

    /**
     * Enqueues a callback which will be run after the next render, equivalent
     * to one task (`setTimeout`) after the next `requestAnimationFrame`.
     *
     * This method is useful for tuning the first-render performance of an
     * element or application by deferring non-critical work until after the
     * first paint.  Typical non-render-critical work may include adding UI
     * event listeners and aria attributes.
     *
     * @memberof Polymer.RenderStatus
     * @param {*} context Context object the callback function will be bound to
     * @param {function()} callback Callback function
     * @param {Array} args An array of arguments to call the callback function with
     */
    afterNextRender: function afterNextRender(context, callback, args) {
      if (!scheduled) {
        schedule();
      }
      afterRenderQueue.push([context, callback, args]);
    },

    /**
     * Flushes all `beforeNextRender` tasks, followed by all `afterNextRender`
     * tasks.
     *
     * @memberof Polymer.RenderStatus
     */
    flush: flush

  };
})();

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


(function () {
  'use strict';

  // unresolved

  function resolve() {
    document.body.removeAttribute('unresolved');
  }

  if (window.WebComponents) {
    window.addEventListener('WebComponentsReady', resolve);
  } else {
    if (document.readyState === 'interactive' || document.readyState === 'complete') {
      resolve();
    } else {
      window.addEventListener('DOMContentLoaded', resolve);
    }
  }
})();

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

__webpack_require__(1);

__webpack_require__(17);

__webpack_require__(43);

__webpack_require__(13);

(function () {
  'use strict';

  var p = Element.prototype;
  /**
   * @const {function(this:Element, string): boolean}
   */
  var normalizedMatchesSelector = p.matches || p.matchesSelector || p.mozMatchesSelector || p.msMatchesSelector || p.oMatchesSelector || p.webkitMatchesSelector;

  /**
   * Cross-platform `element.matches` shim.
   *
   * @function matchesSelector
   * @memberof Polymer.dom
   * @param {!Element} node Node to check selector against
   * @param {string} selector Selector to match
   * @return {boolean} True if node matched selector
   */
  var matchesSelector = function matchesSelector(node, selector) {
    return normalizedMatchesSelector.call(node, selector);
  };

  /**
   * Node API wrapper class returned from `Polymer.dom.(target)` when
   * `target` is a `Node`.
   */

  var DomApi = function () {

    /**
     * @param {Node} node Node for which to create a Polymer.dom helper object.
     */
    function DomApi(node) {
      _classCallCheck(this, DomApi);

      this.node = node;
    }

    /**
     * Returns an instance of `Polymer.FlattenedNodesObserver` that
     * listens for node changes on this element.
     *
     * @param {Function} callback Called when direct or distributed children
     *   of this element changes
     * @return {Polymer.FlattenedNodesObserver} Observer instance
     */


    _createClass(DomApi, [{
      key: 'observeNodes',
      value: function observeNodes(callback) {
        return new Polymer.FlattenedNodesObserver(this.node, callback);
      }

      /**
       * Disconnects an observer previously created via `observeNodes`
       *
       * @param {Polymer.FlattenedNodesObserver} observerHandle Observer instance
       *   to disconnect.
       */

    }, {
      key: 'unobserveNodes',
      value: function unobserveNodes(observerHandle) {
        observerHandle.disconnect();
      }

      /**
       * Provided as a backwards-compatible API only.  This method does nothing.
       */

    }, {
      key: 'notifyObserver',
      value: function notifyObserver() {}

      /**
       * Returns true if the provided node is contained with this element's
       * light-DOM children or shadow root, including any nested shadow roots
       * of children therein.
       *
       * @param {Node} node Node to test
       * @return {boolean} Returns true if the given `node` is contained within
       *   this element's light or shadow DOM.
       */

    }, {
      key: 'deepContains',
      value: function deepContains(node) {
        if (this.node.contains(node)) {
          return true;
        }
        var n = node;
        var doc = node.ownerDocument;
        // walk from node to `this` or `document`
        while (n && n !== doc && n !== this.node) {
          // use logical parentnode, or native ShadowRoot host
          n = n.parentNode || n.host;
        }
        return n === this.node;
      }

      /**
       * Returns the root node of this node.  Equivalent to `getRoodNode()`.
       *
       * @return {Node} Top most element in the dom tree in which the node
       * exists. If the node is connected to a document this is either a
       * shadowRoot or the document; otherwise, it may be the node
       * itself or a node or document fragment containing it.
       */

    }, {
      key: 'getOwnerRoot',
      value: function getOwnerRoot() {
        return this.node.getRootNode();
      }

      /**
       * For slot elements, returns the nodes assigned to the slot; otherwise
       * an empty array. It is equivalent to `<slot>.addignedNodes({flatten:true})`.
       *
       * @return {Array<Node>} Array of assigned nodes
       */

    }, {
      key: 'getDistributedNodes',
      value: function getDistributedNodes() {
        return this.node.localName === 'slot' ? this.node.assignedNodes({ flatten: true }) : [];
      }

      /**
       * Returns an array of all slots this element was distributed to.
       *
       * @return {Array<HTMLSlotElement>} Description
       */

    }, {
      key: 'getDestinationInsertionPoints',
      value: function getDestinationInsertionPoints() {
        var ip$ = [];
        var n = this.node.assignedSlot;
        while (n) {
          ip$.push(n);
          n = n.assignedSlot;
        }
        return ip$;
      }

      /**
       * Calls `importNode` on the `ownerDocument` for this node.
       *
       * @param {Node} node Node to import
       * @param {boolean} deep True if the node should be cloned deeply during
       *   import
       * @return {Node} Clone of given node imported to this owner document
       */

    }, {
      key: 'importNode',
      value: function importNode(node, deep) {
        var doc = this.node instanceof Document ? this.node : this.node.ownerDocument;
        return doc.importNode(node, deep);
      }

      /**
       * @return {Array} Returns a flattened list of all child nodes and nodes assigned
       * to child slots.
       */

    }, {
      key: 'getEffectiveChildNodes',
      value: function getEffectiveChildNodes() {
        return Polymer.FlattenedNodesObserver.getFlattenedNodes(this.node);
      }

      /**
       * Returns a filtered list of flattened child elements for this element based
       * on the given selector.
       *
       * @param {string} selector Selector to filter nodes against
       * @return {Array<HTMLElement>} List of flattened child elements
       */

    }, {
      key: 'queryDistributedElements',
      value: function queryDistributedElements(selector) {
        var c$ = this.getEffectiveChildNodes();
        var list = [];
        for (var i = 0, l = c$.length, c; i < l && (c = c$[i]); i++) {
          if (c.nodeType === Node.ELEMENT_NODE && matchesSelector(c, selector)) {
            list.push(c);
          }
        }
        return list;
      }

      /**
       * For shadow roots, returns the currently focused element within this
       * shadow root.
       *
       * @return {Node|undefined} Currently focused element
       */

    }, {
      key: 'activeElement',
      get: function get() {
        var node = this.node;
        return node._activeElement !== undefined ? node._activeElement : node.activeElement;
      }
    }]);

    return DomApi;
  }();

  function forwardMethods(proto, methods) {
    var _loop = function _loop(i) {
      var method = methods[i];
      proto[method] = /** @this {DomApi} */function () {
        return this.node[method].apply(this.node, arguments);
      };
    };

    for (var i = 0; i < methods.length; i++) {
      _loop(i);
    }
  }

  function forwardReadOnlyProperties(proto, properties) {
    var _loop2 = function _loop2(i) {
      var name = properties[i];
      Object.defineProperty(proto, name, {
        get: function get() {
          return (/** @type {DomApi} */this.node[name]
          );
        },
        configurable: true
      });
    };

    for (var i = 0; i < properties.length; i++) {
      _loop2(i);
    }
  }

  function forwardProperties(proto, properties) {
    var _loop3 = function _loop3(i) {
      var name = properties[i];
      Object.defineProperty(proto, name, {
        get: function get() {
          return (/** @type {DomApi} */this.node[name]
          );
        },
        set: function set(value) {
          /** @type {DomApi} */this.node[name] = value;
        },
        configurable: true
      });
    };

    for (var i = 0; i < properties.length; i++) {
      _loop3(i);
    }
  }

  forwardMethods(DomApi.prototype, ['cloneNode', 'appendChild', 'insertBefore', 'removeChild', 'replaceChild', 'setAttribute', 'removeAttribute', 'querySelector', 'querySelectorAll']);

  forwardReadOnlyProperties(DomApi.prototype, ['parentNode', 'firstChild', 'lastChild', 'nextSibling', 'previousSibling', 'firstElementChild', 'lastElementChild', 'nextElementSibling', 'previousElementSibling', 'childNodes', 'children', 'classList']);

  forwardProperties(DomApi.prototype, ['textContent', 'innerHTML']);

  /**
   * Event API wrapper class returned from `Polymer.dom.(target)` when
   * `target` is an `Event`.
   */

  var EventApi = function () {
    function EventApi(event) {
      _classCallCheck(this, EventApi);

      this.event = event;
    }

    /**
     * Returns the first node on the `composedPath` of this event.
     *
     * @return {Node} The node this event was dispatched to
     */


    _createClass(EventApi, [{
      key: 'rootTarget',
      get: function get() {
        return this.event.composedPath()[0];
      }

      /**
       * Returns the local (re-targeted) target for this event.
       *
       * @return {Node} The local (re-targeted) target for this event.
       */

    }, {
      key: 'localTarget',
      get: function get() {
        return this.event.target;
      }

      /**
       * Returns the `composedPath` for this event.
       */

    }, {
      key: 'path',
      get: function get() {
        return this.event.composedPath();
      }
    }]);

    return EventApi;
  }();

  Polymer.DomApi = DomApi;

  /**
   * Legacy DOM and Event manipulation API wrapper factory used to abstract
   * differences between native Shadow DOM and "Shady DOM" when polyfilling on
   * older browsers.
   *
   * Note that in Polymer 2.x use of `Polymer.dom` is no longer required and
   * in the majority of cases simply facades directly to the standard native
   * API.
   *
   * @namespace
   * @summary Legacy DOM and Event manipulation API wrapper factory used to
   * abstract differences between native Shadow DOM and "Shady DOM."
   * @memberof Polymer
   * @param {!Node|Event} obj Node or event to operate on
   * @return {DomApi|EventApi} Wrapper providing either node API or event API
   */
  Polymer.dom = function (obj) {
    obj = obj || document;
    if (!obj.__domApi) {
      var helper = void 0;
      if (obj instanceof Event) {
        helper = new EventApi(obj);
      } else {
        helper = new DomApi(obj);
      }
      obj.__domApi = helper;
    }
    return obj.__domApi;
  };

  Polymer.dom.matchesSelector = matchesSelector;

  /**
   * Forces several classes of asynchronously queued tasks to flush:
   * - Debouncers added via `Polymer.enqueueDebouncer`
   * - ShadyDOM distribution
   *
   * This method facades to `Polymer.flush`.
   *
   * @memberof Polymer.dom
   */
  Polymer.dom.flush = Polymer.flush;

  /**
   * Adds a `Polymer.Debouncer` to a list of globally flushable tasks.
   *
   * This method facades to `Polymer.enqueueDebouncer`.
   *
   * @memberof Polymer.dom
   * @param {Polymer.Debouncer} debouncer Debouncer to enqueue
   */
  Polymer.dom.addDebouncer = Polymer.enqueueDebouncer;
})();

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

__webpack_require__(1);

__webpack_require__(21);

__webpack_require__(8);

(function () {
  'use strict';

  /**
   * Returns true if `node` is a slot element
   * @param {HTMLElement} node Node to test.
   * @return {boolean} Returns true if the given `node` is a slot
   * @private
   */

  function isSlot(node) {
    return node.localName === 'slot';
  }

  /**
   * Class that listens for changes (additions or removals) to
   * "flattened nodes" on a given `node`. The list of flattened nodes consists
   * of a node's children and, for any children that are `<slot>` elements,
   * the expanded flattened list of `assignedNodes`.
   * For example, if the observed node has children `<a></a><slot></slot><b></b>`
   * and the `<slot>` has one `<div>` assigned to it, then the flattened
   * nodes list is `<a></a><div></div><b></b>`. If the `<slot>` has other
   * `<slot>` elements assigned to it, these are flattened as well.
   *
   * The provided `callback` is called whenever any change to this list
   * of flattened nodes occurs, where an addition or removal of a node is
   * considered a change. The `callback` is called with one argument, an object
   * containing an array of any `addedNodes` and `removedNodes`.
   *
   * Note: the callback is called asynchronous to any changes
   * at a microtask checkpoint. This is because observation is performed using
   * `MutationObserver` and the `<slot>` element's `slotchange` event which
   * are asynchronous.
   *
   * @memberof Polymer
   * @summary Class that listens for changes (additions or removals) to
   * "flattened nodes" on a given `node`.
   */

  var FlattenedNodesObserver = function () {
    _createClass(FlattenedNodesObserver, null, [{
      key: 'getFlattenedNodes',


      /**
       * Returns the list of flattened nodes for the given `node`.
       * This list consists of a node's children and, for any children
       * that are `<slot>` elements, the expanded flattened list of `assignedNodes`.
       * For example, if the observed node has children `<a></a><slot></slot><b></b>`
       * and the `<slot>` has one `<div>` assigned to it, then the flattened
       * nodes list is `<a></a><div></div><b></b>`. If the `<slot>` has other
       * `<slot>` elements assigned to it, these are flattened as well.
       *
       * @param {HTMLElement|HTMLSlotElement} node The node for which to return the list of flattened nodes.
       * @return {Array} The list of flattened nodes for the given `node`.
      */
      value: function getFlattenedNodes(node) {
        if (isSlot(node)) {
          return (/** @type {HTMLSlotElement} */node.assignedNodes({ flatten: true })
          );
        } else {
          return Array.from(node.childNodes).map(function (node) {
            if (isSlot(node)) {
              return (/** @type {HTMLSlotElement} */node.assignedNodes({ flatten: true })
              );
            } else {
              return [node];
            }
          }).reduce(function (a, b) {
            return a.concat(b);
          }, []);
        }
      }

      /**
       * @param {Node} target Node on which to listen for changes.
       * @param {Function} callback Function called when there are additions
       * or removals from the target's list of flattened nodes.
      */

    }]);

    function FlattenedNodesObserver(target, callback) {
      var _this = this;

      _classCallCheck(this, FlattenedNodesObserver);

      /** @type {MutationObserver} */
      this._shadyChildrenObserver = null;
      /** @type {MutationObserver} */
      this._nativeChildrenObserver = null;
      this._connected = false;
      this._target = target;
      this.callback = callback;
      this._effectiveNodes = [];
      this._observer = null;
      this._scheduled = false;
      /** @type {function()} */
      this._boundSchedule = function () {
        _this._schedule();
      };
      this.connect();
      this._schedule();
    }

    /**
     * Activates an observer. This method is automatically called when
     * a `FlattenedNodesObserver` is created. It should only be called to
     * re-activate an observer that has been deactivated via the `disconnect` method.
     */


    _createClass(FlattenedNodesObserver, [{
      key: 'connect',
      value: function connect() {
        var _this2 = this;

        if (isSlot(this._target)) {
          this._listenSlots([this._target]);
        } else {
          this._listenSlots(this._target.children);
          if (window.ShadyDOM) {
            this._shadyChildrenObserver = ShadyDOM.observeChildren(this._target, function (mutations) {
              _this2._processMutations(mutations);
            });
          } else {
            this._nativeChildrenObserver = new MutationObserver(function (mutations) {
              _this2._processMutations(mutations);
            });
            this._nativeChildrenObserver.observe(this._target, { childList: true });
          }
        }
        this._connected = true;
      }

      /**
       * Deactivates the flattened nodes observer. After calling this method
       * the observer callback will not be called when changes to flattened nodes
       * occur. The `connect` method may be subsequently called to reactivate
       * the observer.
       */

    }, {
      key: 'disconnect',
      value: function disconnect() {
        if (isSlot(this._target)) {
          this._unlistenSlots([this._target]);
        } else {
          this._unlistenSlots(this._target.children);
          if (window.ShadyDOM && this._shadyChildrenObserver) {
            ShadyDOM.unobserveChildren(this._shadyChildrenObserver);
            this._shadyChildrenObserver = null;
          } else if (this._nativeChildrenObserver) {
            this._nativeChildrenObserver.disconnect();
            this._nativeChildrenObserver = null;
          }
        }
        this._connected = false;
      }
    }, {
      key: '_schedule',
      value: function _schedule() {
        var _this3 = this;

        if (!this._scheduled) {
          this._scheduled = true;
          Polymer.Async.microTask.run(function () {
            return _this3.flush();
          });
        }
      }
    }, {
      key: '_processMutations',
      value: function _processMutations(mutations) {
        this._processSlotMutations(mutations);
        this.flush();
      }
    }, {
      key: '_processSlotMutations',
      value: function _processSlotMutations(mutations) {
        if (mutations) {
          for (var i = 0; i < mutations.length; i++) {
            var mutation = mutations[i];
            if (mutation.addedNodes) {
              this._listenSlots(mutation.addedNodes);
            }
            if (mutation.removedNodes) {
              this._unlistenSlots(mutation.removedNodes);
            }
          }
        }
      }

      /**
       * Flushes the observer causing any pending changes to be immediately
       * delivered the observer callback. By default these changes are delivered
       * asynchronously at the next microtask checkpoint.
       *
       * @return {boolean} Returns true if any pending changes caused the observer
       * callback to run.
       */

    }, {
      key: 'flush',
      value: function flush() {
        if (!this._connected) {
          return false;
        }
        if (window.ShadyDOM) {
          ShadyDOM.flush();
        }
        if (this._nativeChildrenObserver) {
          this._processSlotMutations(this._nativeChildrenObserver.takeRecords());
        } else if (this._shadyChildrenObserver) {
          this._processSlotMutations(this._shadyChildrenObserver.takeRecords());
        }
        this._scheduled = false;
        var info = {
          target: this._target,
          addedNodes: [],
          removedNodes: []
        };
        var newNodes = this.constructor.getFlattenedNodes(this._target);
        var splices = Polymer.ArraySplice.calculateSplices(newNodes, this._effectiveNodes);
        // process removals
        for (var i = 0, s; i < splices.length && (s = splices[i]); i++) {
          for (var j = 0, n; j < s.removed.length && (n = s.removed[j]); j++) {
            info.removedNodes.push(n);
          }
        }
        // process adds
        for (var _i = 0, _s; _i < splices.length && (_s = splices[_i]); _i++) {
          for (var _j = _s.index; _j < _s.index + _s.addedCount; _j++) {
            info.addedNodes.push(newNodes[_j]);
          }
        }
        // update cache
        this._effectiveNodes = newNodes;
        var didFlush = false;
        if (info.addedNodes.length || info.removedNodes.length) {
          didFlush = true;
          this.callback.call(this._target, info);
        }
        return didFlush;
      }
    }, {
      key: '_listenSlots',
      value: function _listenSlots(nodeList) {
        for (var i = 0; i < nodeList.length; i++) {
          var n = nodeList[i];
          if (isSlot(n)) {
            n.addEventListener('slotchange', this._boundSchedule);
          }
        }
      }
    }, {
      key: '_unlistenSlots',
      value: function _unlistenSlots(nodeList) {
        for (var i = 0; i < nodeList.length; i++) {
          var n = nodeList[i];
          if (isSlot(n)) {
            n.removeEventListener('slotchange', this._boundSchedule);
          }
        }
      }
    }]);

    return FlattenedNodesObserver;
  }();

  Polymer.FlattenedNodesObserver = FlattenedNodesObserver;
})();

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(45);

(function () {
  'use strict';

  /**
   * Legacy class factory and registration helper for defining Polymer
   * elements.
   *
   * This method is equivalent to
   * `customElements.define(info.is, Polymer.Class(info));`
   *
   * See `Polymer.Class` for details on valid legacy metadata format for `info`.
   *
   * @override
   * @function Polymer
   * @param {!PolymerInit} info Object containing Polymer metadata and functions
   *   to become class methods.
   * @return {!HTMLElement} Generated class
   * @suppress {duplicate, invalidCasts, checkTypes}
   */

  window.Polymer._polymerFn = function (info) {
    // if input is a `class` (aka a function with a prototype), use the prototype
    // remember that the `constructor` will never be called
    var klass = void 0;
    if (typeof info === 'function') {
      klass = info;
    } else {
      klass = Polymer.Class(info);
    }
    customElements.define(klass.is, /** @type {!HTMLElement} */klass);
    return klass;
  };
})();

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

__webpack_require__(19);

(function () {

  'use strict';

  var metaProps = {
    attached: true,
    detached: true,
    ready: true,
    created: true,
    beforeRegister: true,
    registered: true,
    attributeChanged: true,
    // meta objects
    behaviors: true

    /**
     * Applies a "legacy" behavior or array of behaviors to the provided class.
     *
     * Note: this method will automatically also apply the `Polymer.LegacyElementMixin`
     * to ensure that any legacy behaviors can rely on legacy Polymer API on
     * the underlying element.
     *
     * @param {!(Object|Array)} behaviors Behavior object or array of behaviors.
     * @param {!HTMLElement|function(new:HTMLElement)} klass Element class.
     * @return {function(new:HTMLElement)} Returns a new Element class extended by the
     * passed in `behaviors` and also by `Polymer.LegacyElementMixin`.
     * @memberof Polymer
     * @suppress {invalidCasts, checkTypes}
     */
  };function mixinBehaviors(behaviors, klass) {
    if (!behaviors) {
      return (/** @type {HTMLElement} */klass
      );
    }
    // NOTE: ensure the bahevior is extending a class with
    // legacy element api. This is necessary since behaviors expect to be able
    // to access 1.x legacy api.
    klass = Polymer.LegacyElementMixin(klass);
    if (!Array.isArray(behaviors)) {
      behaviors = [behaviors];
    }
    var superBehaviors = klass.prototype.behaviors;
    // get flattened, deduped list of behaviors *not* already on super class
    behaviors = flattenBehaviors(behaviors, null, superBehaviors);
    // mixin new behaviors
    klass = _mixinBehaviors(behaviors, klass);
    if (superBehaviors) {
      behaviors = superBehaviors.concat(behaviors);
    }
    // Set behaviors on prototype for BC...
    klass.prototype.behaviors = behaviors;
    return klass;
  }

  // NOTE:
  // 1.x
  // Behaviors were mixed in *in reverse order* and de-duped on the fly.
  // The rule was that behavior properties were copied onto the element
  // prototype if and only if the property did not already exist.
  // Given: Polymer{ behaviors: [A, B, C, A, B]}, property copy order was:
  // (1), B, (2), A, (3) C. This means prototype properties win over
  // B properties win over A win over C. This mirrors what would happen
  // with inheritance if element extended B extended A extended C.
  //
  // Again given, Polymer{ behaviors: [A, B, C, A, B]}, the resulting
  // `behaviors` array was [C, A, B].
  // Behavior lifecycle methods were called in behavior array order
  // followed by the element, e.g. (1) C.created, (2) A.created,
  // (3) B.created, (4) element.created. There was no support for
  // super, and "super-behavior" methods were callable only by name).
  //
  // 2.x
  // Behaviors are made into proper mixins which live in the
  // element's prototype chain. Behaviors are placed in the element prototype
  // eldest to youngest and de-duped youngest to oldest:
  // So, first [A, B, C, A, B] becomes [C, A, B] then,
  // the element prototype becomes (oldest) (1) Polymer.Element, (2) class(C),
  // (3) class(A), (4) class(B), (5) class(Polymer({...})).
  // Result:
  // This means element properties win over B properties win over A win
  // over C. (same as 1.x)
  // If lifecycle is called (super then me), order is
  // (1) C.created, (2) A.created, (3) B.created, (4) element.created
  // (again same as 1.x)
  function _mixinBehaviors(behaviors, klass) {
    for (var i = 0; i < behaviors.length; i++) {
      var b = behaviors[i];
      if (b) {
        klass = Array.isArray(b) ? _mixinBehaviors(b, klass) : GenerateClassFromInfo(b, klass);
      }
    }
    return klass;
  }

  /**
   * @param {Array} behaviors List of behaviors to flatten.
   * @param {Array=} list Target list to flatten behaviors into.
   * @param {Array=} exclude List of behaviors to exclude from the list.
   * @return {!Array} Returns the list of flattened behaviors.
   */
  function flattenBehaviors(behaviors, list, exclude) {
    list = list || [];
    for (var i = behaviors.length - 1; i >= 0; i--) {
      var b = behaviors[i];
      if (b) {
        if (Array.isArray(b)) {
          flattenBehaviors(b, list);
        } else {
          // dedup
          if (list.indexOf(b) < 0 && (!exclude || exclude.indexOf(b) < 0)) {
            list.unshift(b);
          }
        }
      } else {
        console.warn('behavior is null, check for missing or 404 import');
      }
    }
    return list;
  }

  /**
   * @param {!PolymerInit} info Polymer info object
   * @param {function(new:HTMLElement)} Base base class to extend with info object
   * @return {function(new:HTMLElement)} Generated class
   * @suppress {checkTypes}
   * @private
   */
  function GenerateClassFromInfo(info, Base) {
    var PolymerGenerated = function (_Base) {
      _inherits(PolymerGenerated, _Base);

      function PolymerGenerated() {
        _classCallCheck(this, PolymerGenerated);

        return _possibleConstructorReturn(this, (PolymerGenerated.__proto__ || Object.getPrototypeOf(PolymerGenerated)).apply(this, arguments));
      }

      _createClass(PolymerGenerated, [{
        key: 'created',
        value: function created() {
          _get(PolymerGenerated.prototype.__proto__ || Object.getPrototypeOf(PolymerGenerated.prototype), 'created', this).call(this);
          if (info.created) {
            info.created.call(this);
          }
        }
      }, {
        key: '_registered',
        value: function _registered() {
          _get(PolymerGenerated.prototype.__proto__ || Object.getPrototypeOf(PolymerGenerated.prototype), '_registered', this).call(this);
          /* NOTE: `beforeRegister` is called here for bc, but the behavior
           is different than in 1.x. In 1.0, the method was called *after*
           mixing prototypes together but *before* processing of meta-objects.
           However, dynamic effects can still be set here and can be done either
           in `beforeRegister` or `registered`. It is no longer possible to set
           `is` in `beforeRegister` as you could in 1.x.
          */
          if (info.beforeRegister) {
            info.beforeRegister.call(Object.getPrototypeOf(this));
          }
          if (info.registered) {
            info.registered.call(Object.getPrototypeOf(this));
          }
        }
      }, {
        key: '_applyListeners',
        value: function _applyListeners() {
          _get(PolymerGenerated.prototype.__proto__ || Object.getPrototypeOf(PolymerGenerated.prototype), '_applyListeners', this).call(this);
          if (info.listeners) {
            for (var l in info.listeners) {
              this._addMethodEventListenerToNode(this, l, info.listeners[l]);
            }
          }
        }

        // note: exception to "super then me" rule;
        // do work before calling super so that super attributes
        // only apply if not already set.

      }, {
        key: '_ensureAttributes',
        value: function _ensureAttributes() {
          if (info.hostAttributes) {
            for (var a in info.hostAttributes) {
              this._ensureAttribute(a, info.hostAttributes[a]);
            }
          }
          _get(PolymerGenerated.prototype.__proto__ || Object.getPrototypeOf(PolymerGenerated.prototype), '_ensureAttributes', this).call(this);
        }
      }, {
        key: 'ready',
        value: function ready() {
          _get(PolymerGenerated.prototype.__proto__ || Object.getPrototypeOf(PolymerGenerated.prototype), 'ready', this).call(this);
          if (info.ready) {
            info.ready.call(this);
          }
        }
      }, {
        key: 'attached',
        value: function attached() {
          _get(PolymerGenerated.prototype.__proto__ || Object.getPrototypeOf(PolymerGenerated.prototype), 'attached', this).call(this);
          if (info.attached) {
            info.attached.call(this);
          }
        }
      }, {
        key: 'detached',
        value: function detached() {
          _get(PolymerGenerated.prototype.__proto__ || Object.getPrototypeOf(PolymerGenerated.prototype), 'detached', this).call(this);
          if (info.detached) {
            info.detached.call(this);
          }
        }
      }, {
        key: 'attributeChanged',
        value: function attributeChanged(name, old, value) {
          _get(PolymerGenerated.prototype.__proto__ || Object.getPrototypeOf(PolymerGenerated.prototype), 'attributeChanged', this).call(this, name, old, value);
          if (info.attributeChanged) {
            info.attributeChanged.call(this, name, old, value);
          }
        }
      }], [{
        key: 'properties',
        get: function get() {
          return info.properties;
        }
      }, {
        key: 'observers',
        get: function get() {
          return info.observers;
        }

        /**
         * @return {HTMLTemplateElement} template for this class
         */

      }, {
        key: 'template',
        get: function get() {
          // get template first from any imperative set in `info._template`
          return info._template ||
          // next look in dom-module associated with this element's is.
          Polymer.DomModule && Polymer.DomModule.import(this.is, 'template') ||
          // next look for superclass template (note: use superclass symbol
          // to ensure correct `this.is`)
          Base.template ||
          // finally fall back to `_template` in element's protoype.
          this.prototype._template || null;
        }
      }]);

      return PolymerGenerated;
    }(Base);

    PolymerGenerated.generatedFrom = info;

    for (var p in info) {
      // NOTE: cannot copy `metaProps` methods onto prototype at least because
      // `super.ready` must be called and is not included in the user fn.
      if (!(p in metaProps)) {
        var pd = Object.getOwnPropertyDescriptor(info, p);
        if (pd) {
          Object.defineProperty(PolymerGenerated.prototype, p, pd);
        }
      }
    }

    return PolymerGenerated;
  }

  /**
   * Generates a class that extends `Polymer.LegacyElement` based on the
   * provided info object.  Metadata objects on the `info` object
   * (`properties`, `observers`, `listeners`, `behaviors`, `is`) are used
   * for Polymer's meta-programming systems, and any functions are copied
   * to the generated class.
   *
   * Valid "metadata" values are as follows:
   *
   * `is`: String providing the tag name to register the element under. In
   * addition, if a `dom-module` with the same id exists, the first template
   * in that `dom-module` will be stamped into the shadow root of this element,
   * with support for declarative event listeners (`on-...`), Polymer data
   * bindings (`[[...]]` and `{{...}}`), and id-based node finding into
   * `this.$`.
   *
   * `properties`: Object describing property-related metadata used by Polymer
   * features (key: property names, value: object containing property metadata).
   * Valid keys in per-property metadata include:
   * - `type` (String|Number|Object|Array|...): Used by
   *   `attributeChangedCallback` to determine how string-based attributes
   *   are deserialized to JavaScript property values.
   * - `notify` (boolean): Causes a change in the property to fire a
   *   non-bubbling event called `<property>-changed`. Elements that have
   *   enabled two-way binding to the property use this event to observe changes.
   * - `readOnly` (boolean): Creates a getter for the property, but no setter.
   *   To set a read-only property, use the private setter method
   *   `_setProperty(property, value)`.
   * - `observer` (string): Observer method name that will be called when
   *   the property changes. The arguments of the method are
   *   `(value, previousValue)`.
   * - `computed` (string): String describing method and dependent properties
   *   for computing the value of this property (e.g. `'computeFoo(bar, zot)'`).
   *   Computed properties are read-only by default and can only be changed
   *   via the return value of the computing method.
   *
   * `observers`: Array of strings describing multi-property observer methods
   *  and their dependent properties (e.g. `'observeABC(a, b, c)'`).
   *
   * `listeners`: Object describing event listeners to be added to each
   *  instance of this element (key: event name, value: method name).
   *
   * `behaviors`: Array of additional `info` objects containing metadata
   * and callbacks in the same format as the `info` object here which are
   * merged into this element.
   *
   * `hostAttributes`: Object listing attributes to be applied to the host
   *  once created (key: attribute name, value: attribute value).  Values
   *  are serialized based on the type of the value.  Host attributes should
   *  generally be limited to attributes such as `tabIndex` and `aria-...`.
   *  Attributes in `hostAttributes` are only applied if a user-supplied
   *  attribute is not already present (attributes in markup override
   *  `hostAttributes`).
   *
   * In addition, the following Polymer-specific callbacks may be provided:
   * - `registered`: called after first instance of this element,
   * - `created`: called during `constructor`
   * - `attached`: called during `connectedCallback`
   * - `detached`: called during `disconnectedCallback`
   * - `ready`: called before first `attached`, after all properties of
   *   this element have been propagated to its template and all observers
   *   have run
   *
   * @param {!PolymerInit} info Object containing Polymer metadata and functions
   *   to become class methods.
   * @return {function(new:HTMLElement)} Generated class
   * @memberof Polymer
   */
  Polymer.Class = function (info) {
    if (!info) {
      console.warn('Polymer.Class requires `info` argument');
    }
    var klass = GenerateClassFromInfo(info, info.behaviors ?
    // note: mixinBehaviors ensures `LegacyElementMixin`.
    mixinBehaviors(info.behaviors, HTMLElement) : Polymer.LegacyElementMixin(HTMLElement));
    // decorate klass with registration info
    klass.is = info.is;
    return klass;
  };

  Polymer.mixinBehaviors = mixinBehaviors;
})();

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(14);

(function () {
  'use strict';

  var TemplateInstanceBase = Polymer.TemplateInstanceBase; // eslint-disable-line

  /**
   * @typedef {{
   *   _templatizerTemplate: HTMLTemplateElement,
   *   _parentModel: boolean,
   *   _instanceProps: Object,
   *   _forwardHostPropV2: Function,
   *   _notifyInstancePropV2: Function,
   *   ctor: TemplateInstanceBase
   * }}
   */
  var TemplatizerUser = void 0; // eslint-disable-line

  /**
   * The `Polymer.Templatizer` behavior adds methods to generate instances of
   * templates that are each managed by an anonymous `Polymer.PropertyEffects`
   * instance where data-bindings in the stamped template content are bound to
   * accessors on itself.
   *
   * This behavior is provided in Polymer 2.x as a hybrid-element convenience
   * only.  For non-hybrid usage, the `Polymer.Templatize` library
   * should be used instead.
   *
   * Example:
   *
   *     // Get a template from somewhere, e.g. light DOM
   *     let template = this.querySelector('template');
   *     // Prepare the template
   *     this.templatize(template);
   *     // Instance the template with an initial data model
   *     let instance = this.stamp({myProp: 'initial'});
   *     // Insert the instance's DOM somewhere, e.g. light DOM
   *     Polymer.dom(this).appendChild(instance.root);
   *     // Changing a property on the instance will propagate to bindings
   *     // in the template
   *     instance.myProp = 'new value';
   *
   * Users of `Templatizer` may need to implement the following abstract
   * API's to determine how properties and paths from the host should be
   * forwarded into to instances:
   *
   *     _forwardHostPropV2: function(prop, value)
   *
   * Likewise, users may implement these additional abstract API's to determine
   * how instance-specific properties that change on the instance should be
   * forwarded out to the host, if necessary.
   *
   *     _notifyInstancePropV2: function(inst, prop, value)
   *
   * In order to determine which properties are instance-specific and require
   * custom notification via `_notifyInstanceProp`, define an `_instanceProps`
   * object containing keys for each instance prop, for example:
   *
   *     _instanceProps: {
   *       item: true,
   *       index: true
   *     }
   *
   * Any properties used in the template that are not defined in _instanceProp
   * will be forwarded out to the Templatize `owner` automatically.
   *
   * Users may also implement the following abstract function to show or
   * hide any DOM generated using `stamp`:
   *
   *     _showHideChildren: function(shouldHide)
   *
   * Note that some callbacks are suffixed with `V2` in the Polymer 2.x behavior
   * as the implementations will need to differ from the callbacks required
   * by the 1.x Templatizer API due to changes in the `TemplateInstance` API
   * between versions 1.x and 2.x.
   *
   * @polymerBehavior
   * @memberof Polymer
   */
  var Templatizer = {

    /**
     * Generates an anonymous `TemplateInstance` class (stored as `this.ctor`)
     * for the provided template.  This method should be called once per
     * template to prepare an element for stamping the template, followed
     * by `stamp` to create new instances of the template.
     *
     * @param {HTMLTemplateElement} template Template to prepare
     * @param {boolean=} mutableData When `true`, the generated class will skip
     *   strict dirty-checking for objects and arrays (always consider them to
     *   be "dirty"). Defaults to false.
     * @this {TemplatizerUser}
     */
    templatize: function templatize(template, mutableData) {
      this._templatizerTemplate = template;
      this.ctor = Polymer.Templatize.templatize(template, this, {
        mutableData: Boolean(mutableData),
        parentModel: this._parentModel,
        instanceProps: this._instanceProps,
        forwardHostProp: this._forwardHostPropV2,
        notifyInstanceProp: this._notifyInstancePropV2
      });
    },


    /**
     * Creates an instance of the template prepared by `templatize`.  The object
     * returned is an instance of the anonymous class generated by `templatize`
     * whose `root` property is a document fragment containing newly cloned
     * template content, and which has property accessors corresponding to
     * properties referenced in template bindings.
     *
     * @param {Object=} model Object containing initial property values to
     *   populate into the template bindings.
     * @return {TemplateInstanceBase} Returns the created instance of
     * the template prepared by `templatize`.
     * @this {TemplatizerUser}
     */
    stamp: function stamp(model) {
      return new this.ctor(model);
    },


    /**
     * Returns the template "model" (`TemplateInstance`) associated with
     * a given element, which serves as the binding scope for the template
     * instance the element is contained in.  A template model should be used
     * to manipulate data associated with this template instance.
     *
     * @param {HTMLElement} el Element for which to return a template model.
     * @return {TemplateInstanceBase} Model representing the binding scope for
     *   the element.
     * @this {TemplatizerUser}
     */
    modelForElement: function modelForElement(el) {
      return Polymer.Templatize.modelForElement(this._templatizerTemplate, el);
    }
  };

  Polymer.Templatizer = Templatizer;
})();

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

__webpack_require__(1);

__webpack_require__(11);

__webpack_require__(9);

__webpack_require__(20);

(function () {
  'use strict';

  /**
   * @constructor
   * @extends {HTMLElement}
   * @implements {Polymer_PropertyEffects}
   * @implements {Polymer_OptionalMutableData}
   * @implements {Polymer_GestureEventListeners}
   */

  var domBindBase = Polymer.GestureEventListeners(Polymer.OptionalMutableData(Polymer.PropertyEffects(HTMLElement)));

  /**
   * Custom element to allow using Polymer's template features (data binding,
   * declarative event listeners, etc.) in the main document without defining
   * a new custom element.
   *
   * `<template>` tags utilizing bindings may be wrapped with the `<dom-bind>`
   * element, which will immediately stamp the wrapped template into the main
   * document and bind elements to the `dom-bind` element itself as the
   * binding scope.
   *
   * @polymer
   * @customElement
   * @appliesMixin Polymer.PropertyEffects
   * @appliesMixin Polymer.OptionalMutableData
   * @appliesMixin Polymer.GestureEventListeners
   * @extends {domBindBase}
   * @memberof Polymer
   * @summary Custom element to allow using Polymer's template features (data
   *   binding, declarative event listeners, etc.) in the main document.
   */

  var DomBind = function (_domBindBase) {
    _inherits(DomBind, _domBindBase);

    _createClass(DomBind, null, [{
      key: 'observedAttributes',
      get: function get() {
        return ['mutable-data'];
      }
    }]);

    function DomBind() {
      _classCallCheck(this, DomBind);

      var _this = _possibleConstructorReturn(this, (DomBind.__proto__ || Object.getPrototypeOf(DomBind)).call(this));

      _this.root = null;
      _this.$ = null;
      _this.__children = null;
      return _this;
    }

    // assumes only one observed attribute


    _createClass(DomBind, [{
      key: 'attributeChangedCallback',
      value: function attributeChangedCallback() {
        this.mutableData = true;
      }
    }, {
      key: 'connectedCallback',
      value: function connectedCallback() {
        this.render();
      }
    }, {
      key: 'disconnectedCallback',
      value: function disconnectedCallback() {
        this.__removeChildren();
      }
    }, {
      key: '__insertChildren',
      value: function __insertChildren() {
        this.parentNode.insertBefore(this.root, this);
      }
    }, {
      key: '__removeChildren',
      value: function __removeChildren() {
        if (this.__children) {
          for (var i = 0; i < this.__children.length; i++) {
            this.root.appendChild(this.__children[i]);
          }
        }
      }

      /**
       * Forces the element to render its content. This is typically only
       * necessary to call if HTMLImports with the async attribute are used.
       */

    }, {
      key: 'render',
      value: function render() {
        var _this2 = this;

        var template = void 0;
        if (!this.__children) {
          template = /** @type {HTMLTemplateElement} */template || this.querySelector('template');
          if (!template) {
            // Wait until childList changes and template should be there by then
            var observer = new MutationObserver(function () {
              template = /** @type {HTMLTemplateElement} */_this2.querySelector('template');
              if (template) {
                observer.disconnect();
                _this2.render();
              } else {
                throw new Error('dom-bind requires a <template> child');
              }
            });
            observer.observe(this, { childList: true });
            return;
          }
          this.root = this._stampTemplate(template);
          this.$ = this.root.$;
          this.__children = [];
          for (var n = this.root.firstChild; n; n = n.nextSibling) {
            this.__children[this.__children.length] = n;
          }
          this._enableProperties();
        }
        this.__insertChildren();
        this.dispatchEvent(new CustomEvent('dom-change', {
          bubbles: true,
          composed: true
        }));
      }
    }]);

    return DomBind;
  }(domBindBase);

  customElements.define('dom-bind', DomBind);
})();

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

__webpack_require__(6);

__webpack_require__(14);

__webpack_require__(12);

__webpack_require__(13);

__webpack_require__(9);

(function () {
  'use strict';

  var TemplateInstanceBase = Polymer.TemplateInstanceBase; // eslint-disable-line

  /**
   * @constructor
   * @implements {Polymer_OptionalMutableData}
   * @extends {Polymer.Element}
   */
  var domRepeatBase = Polymer.OptionalMutableData(Polymer.Element);

  /**
   * The `<dom-repeat>` element will automatically stamp and binds one instance
   * of template content to each object in a user-provided array.
   * `dom-repeat` accepts an `items` property, and one instance of the template
   * is stamped for each item into the DOM at the location of the `dom-repeat`
   * element.  The `item` property will be set on each instance's binding
   * scope, thus templates should bind to sub-properties of `item`.
   *
   * Example:
   *
   * ```html
   * <dom-module id="employee-list">
   *
   *   <template>
   *
   *     <div> Employee list: </div>
   *     <template is="dom-repeat" items="{{employees}}">
   *         <div>First name: <span>{{item.first}}</span></div>
   *         <div>Last name: <span>{{item.last}}</span></div>
   *     </template>
   *
   *   </template>
   *
   *   <script>
   *     Polymer({
   *       is: 'employee-list',
   *       ready: function() {
   *         this.employees = [
   *             {first: 'Bob', last: 'Smith'},
   *             {first: 'Sally', last: 'Johnson'},
   *             ...
   *         ];
   *       }
   *     });
   *   < /script>
   *
   * </dom-module>
   * ```
   *
   * Notifications for changes to items sub-properties will be forwarded to template
   * instances, which will update via the normal structured data notification system.
   *
   * Mutations to the `items` array itself should be made using the Array
   * mutation API's on `Polymer.Base` (`push`, `pop`, `splice`, `shift`,
   * `unshift`), and template instances will be kept in sync with the data in the
   * array.
   *
   * Events caught by event handlers within the `dom-repeat` template will be
   * decorated with a `model` property, which represents the binding scope for
   * each template instance.  The model is an instance of Polymer.Base, and should
   * be used to manipulate data on the instance, for example
   * `event.model.set('item.checked', true);`.
   *
   * Alternatively, the model for a template instance for an element stamped by
   * a `dom-repeat` can be obtained using the `modelForElement` API on the
   * `dom-repeat` that stamped it, for example
   * `this.$.domRepeat.modelForElement(event.target).set('item.checked', true);`.
   * This may be useful for manipulating instance data of event targets obtained
   * by event handlers on parents of the `dom-repeat` (event delegation).
   *
   * A view-specific filter/sort may be applied to each `dom-repeat` by supplying a
   * `filter` and/or `sort` property.  This may be a string that names a function on
   * the host, or a function may be assigned to the property directly.  The functions
   * should implemented following the standard `Array` filter/sort API.
   *
   * In order to re-run the filter or sort functions based on changes to sub-fields
   * of `items`, the `observe` property may be set as a space-separated list of
   * `item` sub-fields that should cause a re-filter/sort when modified.  If
   * the filter or sort function depends on properties not contained in `items`,
   * the user should observe changes to those properties and call `render` to update
   * the view based on the dependency change.
   *
   * For example, for an `dom-repeat` with a filter of the following:
   *
   * ```js
   * isEngineer: function(item) {
   *     return item.type == 'engineer' || item.manager.type == 'engineer';
   * }
   * ```
   *
   * Then the `observe` property should be configured as follows:
   *
   * ```html
   * <template is="dom-repeat" items="{{employees}}"
   *           filter="isEngineer" observe="type manager.type">
   * ```
   *
   * @customElement
   * @polymer
   * @memberof Polymer
   * @extends {domRepeatBase}
   * @appliesMixin Polymer.OptionalMutableData
   * @summary Custom element for stamping instance of a template bound to
   *   items in an array.
   */

  var DomRepeat = function (_domRepeatBase) {
    _inherits(DomRepeat, _domRepeatBase);

    _createClass(DomRepeat, null, [{
      key: 'is',


      // Not needed to find template; can be removed once the analyzer
      // can find the tag name from customElements.define call
      get: function get() {
        return 'dom-repeat';
      }
    }, {
      key: 'template',
      get: function get() {
        return null;
      }
    }, {
      key: 'properties',
      get: function get() {

        /**
         * Fired whenever DOM is added or removed by this template (by
         * default, rendering occurs lazily).  To force immediate rendering, call
         * `render`.
         *
         * @event dom-change
         */
        return {

          /**
           * An array containing items determining how many instances of the template
           * to stamp and that that each template instance should bind to.
           */
          items: {
            type: Array
          },

          /**
           * The name of the variable to add to the binding scope for the array
           * element associated with a given template instance.
           */
          as: {
            type: String,
            value: 'item'
          },

          /**
           * The name of the variable to add to the binding scope with the index
           * of the instance in the sorted and filtered list of rendered items.
           * Note, for the index in the `this.items` array, use the value of the
           * `itemsIndexAs` property.
           */
          indexAs: {
            type: String,
            value: 'index'
          },

          /**
           * The name of the variable to add to the binding scope with the index
           * of the instance in the `this.items` array. Note, for the index of
           * this instance in the sorted and filtered list of rendered items,
           * use the value of the `indexAs` property.
           */
          itemsIndexAs: {
            type: String,
            value: 'itemsIndex'
          },

          /**
           * A function that should determine the sort order of the items.  This
           * property should either be provided as a string, indicating a method
           * name on the element's host, or else be an actual function.  The
           * function should match the sort function passed to `Array.sort`.
           * Using a sort function has no effect on the underlying `items` array.
           */
          sort: {
            type: Function,
            observer: '__sortChanged'
          },

          /**
           * A function that can be used to filter items out of the view.  This
           * property should either be provided as a string, indicating a method
           * name on the element's host, or else be an actual function.  The
           * function should match the sort function passed to `Array.filter`.
           * Using a filter function has no effect on the underlying `items` array.
           */
          filter: {
            type: Function,
            observer: '__filterChanged'
          },

          /**
           * When using a `filter` or `sort` function, the `observe` property
           * should be set to a space-separated list of the names of item
           * sub-fields that should trigger a re-sort or re-filter when changed.
           * These should generally be fields of `item` that the sort or filter
           * function depends on.
           */
          observe: {
            type: String,
            observer: '__observeChanged'
          },

          /**
           * When using a `filter` or `sort` function, the `delay` property
           * determines a debounce time after a change to observed item
           * properties that must pass before the filter or sort is re-run.
           * This is useful in rate-limiting shuffing of the view when
           * item changes may be frequent.
           */
          delay: Number,

          /**
           * Count of currently rendered items after `filter` (if any) has been applied.
           * If "chunking mode" is enabled, `renderedItemCount` is updated each time a
           * set of template instances is rendered.
           *
           */
          renderedItemCount: {
            type: Number,
            notify: true,
            readOnly: true
          },

          /**
           * Defines an initial count of template instances to render after setting
           * the `items` array, before the next paint, and puts the `dom-repeat`
           * into "chunking mode".  The remaining items will be created and rendered
           * incrementally at each animation frame therof until all instances have
           * been rendered.
           */
          initialCount: {
            type: Number,
            observer: '__initializeChunking'
          },

          /**
           * When `initialCount` is used, this property defines a frame rate to
           * target by throttling the number of instances rendered each frame to
           * not exceed the budget for the target frame rate.  Setting this to a
           * higher number will allow lower latency and higher throughput for
           * things like event handlers, but will result in a longer time for the
           * remaining items to complete rendering.
           */
          targetFramerate: {
            type: Number,
            value: 20
          },

          _targetFrameTime: {
            type: Number,
            computed: '__computeFrameTime(targetFramerate)'
          }

        };
      }
    }, {
      key: 'observers',
      get: function get() {
        return ['__itemsChanged(items.*)'];
      }
    }]);

    function DomRepeat() {
      _classCallCheck(this, DomRepeat);

      var _this = _possibleConstructorReturn(this, (DomRepeat.__proto__ || Object.getPrototypeOf(DomRepeat)).call(this));

      _this.__instances = [];
      _this.__limit = Infinity;
      _this.__pool = [];
      _this.__renderDebouncer = null;
      _this.__itemsIdxToInstIdx = {};
      _this.__chunkCount = null;
      _this.__lastChunkTime = null;
      _this.__sortFn = null;
      _this.__filterFn = null;
      _this.__observePaths = null;
      _this.__ctor = null;
      _this.__isDetached = true;
      _this.template = null;
      return _this;
    }

    _createClass(DomRepeat, [{
      key: 'disconnectedCallback',
      value: function disconnectedCallback() {
        _get(DomRepeat.prototype.__proto__ || Object.getPrototypeOf(DomRepeat.prototype), 'disconnectedCallback', this).call(this);
        this.__isDetached = true;
        for (var i = 0; i < this.__instances.length; i++) {
          this.__detachInstance(i);
        }
      }
    }, {
      key: 'connectedCallback',
      value: function connectedCallback() {
        _get(DomRepeat.prototype.__proto__ || Object.getPrototypeOf(DomRepeat.prototype), 'connectedCallback', this).call(this);
        // only perform attachment if the element was previously detached.
        if (this.__isDetached) {
          this.__isDetached = false;
          var parent = this.parentNode;
          for (var i = 0; i < this.__instances.length; i++) {
            this.__attachInstance(i, parent);
          }
        }
      }
    }, {
      key: '__ensureTemplatized',
      value: function __ensureTemplatized() {
        var _this2 = this;

        // Templatizing (generating the instance constructor) needs to wait
        // until ready, since won't have its template content handed back to
        // it until then
        if (!this.__ctor) {
          var template = this.template = this.querySelector('template');
          if (!template) {
            // // Wait until childList changes and template should be there by then
            var observer = new MutationObserver(function () {
              if (_this2.querySelector('template')) {
                observer.disconnect();
                _this2.__render();
              } else {
                throw new Error('dom-repeat requires a <template> child');
              }
            });
            observer.observe(this, { childList: true });
            return false;
          }
          // Template instance props that should be excluded from forwarding
          var instanceProps = {};
          instanceProps[this.as] = true;
          instanceProps[this.indexAs] = true;
          instanceProps[this.itemsIndexAs] = true;
          this.__ctor = Polymer.Templatize.templatize(template, this, {
            mutableData: this.mutableData,
            parentModel: true,
            instanceProps: instanceProps,
            /**
             * @this {this}
             * @param {string} prop Property to set
             * @param {*} value Value to set property to
             */
            forwardHostProp: function forwardHostProp(prop, value) {
              var i$ = this.__instances;
              for (var i = 0, inst; i < i$.length && (inst = i$[i]); i++) {
                inst.forwardHostProp(prop, value);
              }
            },
            /**
             * @this {this}
             * @param {Object} inst Instance to notify
             * @param {string} prop Property to notify
             * @param {*} value Value to notify
             */
            notifyInstanceProp: function notifyInstanceProp(inst, prop, value) {
              if (Polymer.Path.matches(this.as, prop)) {
                var idx = inst[this.itemsIndexAs];
                if (prop == this.as) {
                  this.items[idx] = value;
                }
                var path = Polymer.Path.translate(this.as, 'items.' + idx, prop);
                this.notifyPath(path, value);
              }
            }
          });
        }
        return true;
      }
    }, {
      key: '__getMethodHost',
      value: function __getMethodHost() {
        // Technically this should be the owner of the outermost template.
        // In shadow dom, this is always getRootNode().host, but we can
        // approximate this via cooperation with our dataHost always setting
        // `_methodHost` as long as there were bindings (or id's) on this
        // instance causing it to get a dataHost.
        return this.__dataHost._methodHost || this.__dataHost;
      }
    }, {
      key: '__sortChanged',
      value: function __sortChanged(sort) {
        var methodHost = this.__getMethodHost();
        this.__sortFn = sort && (typeof sort == 'function' ? sort : function () {
          return methodHost[sort].apply(methodHost, arguments);
        });
        if (this.items) {
          this.__debounceRender(this.__render);
        }
      }
    }, {
      key: '__filterChanged',
      value: function __filterChanged(filter) {
        var methodHost = this.__getMethodHost();
        this.__filterFn = filter && (typeof filter == 'function' ? filter : function () {
          return methodHost[filter].apply(methodHost, arguments);
        });
        if (this.items) {
          this.__debounceRender(this.__render);
        }
      }
    }, {
      key: '__computeFrameTime',
      value: function __computeFrameTime(rate) {
        return Math.ceil(1000 / rate);
      }
    }, {
      key: '__initializeChunking',
      value: function __initializeChunking() {
        if (this.initialCount) {
          this.__limit = this.initialCount;
          this.__chunkCount = this.initialCount;
          this.__lastChunkTime = performance.now();
        }
      }
    }, {
      key: '__tryRenderChunk',
      value: function __tryRenderChunk() {
        // Debounced so that multiple calls through `_render` between animation
        // frames only queue one new rAF (e.g. array mutation & chunked render)
        if (this.items && this.__limit < this.items.length) {
          this.__debounceRender(this.__requestRenderChunk);
        }
      }
    }, {
      key: '__requestRenderChunk',
      value: function __requestRenderChunk() {
        var _this3 = this;

        requestAnimationFrame(function () {
          return _this3.__renderChunk();
        });
      }
    }, {
      key: '__renderChunk',
      value: function __renderChunk() {
        // Simple auto chunkSize throttling algorithm based on feedback loop:
        // measure actual time between frames and scale chunk count by ratio
        // of target/actual frame time
        var currChunkTime = performance.now();
        var ratio = this._targetFrameTime / (currChunkTime - this.__lastChunkTime);
        this.__chunkCount = Math.round(this.__chunkCount * ratio) || 1;
        this.__limit += this.__chunkCount;
        this.__lastChunkTime = currChunkTime;
        this.__debounceRender(this.__render);
      }
    }, {
      key: '__observeChanged',
      value: function __observeChanged() {
        this.__observePaths = this.observe && this.observe.replace('.*', '.').split(' ');
      }
    }, {
      key: '__itemsChanged',
      value: function __itemsChanged(change) {
        if (this.items && !Array.isArray(this.items)) {
          console.warn('dom-repeat expected array for `items`, found', this.items);
        }
        // If path was to an item (e.g. 'items.3' or 'items.3.foo'), forward the
        // path to that instance synchronously (retuns false for non-item paths)
        if (!this.__handleItemPath(change.path, change.value)) {
          // Otherwise, the array was reset ('items') or spliced ('items.splices'),
          // so queue a full refresh
          this.__initializeChunking();
          this.__debounceRender(this.__render);
        }
      }
    }, {
      key: '__handleObservedPaths',
      value: function __handleObservedPaths(path) {
        if (this.__observePaths) {
          path = path.substring(path.indexOf('.') + 1);
          var paths = this.__observePaths;
          for (var i = 0; i < paths.length; i++) {
            if (path.indexOf(paths[i]) === 0) {
              this.__debounceRender(this.__render, this.delay);
              return true;
            }
          }
        }
      }

      /**
       * @param {function(this:DomRepeat)} fn Function to debounce.
       * @param {number=} delay Delay in ms to debounce by.
       */

    }, {
      key: '__debounceRender',
      value: function __debounceRender(fn) {
        var delay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

        this.__renderDebouncer = Polymer.Debouncer.debounce(this.__renderDebouncer, delay > 0 ? Polymer.Async.timeOut.after(delay) : Polymer.Async.microTask, fn.bind(this));
        Polymer.enqueueDebouncer(this.__renderDebouncer);
      }

      /**
       * Forces the element to render its content. Normally rendering is
       * asynchronous to a provoking change. This is done for efficiency so
       * that multiple changes trigger only a single render. The render method
       * should be called if, for example, template rendering is required to
       * validate application state.
       */

    }, {
      key: 'render',
      value: function render() {
        // Queue this repeater, then flush all in order
        this.__debounceRender(this.__render);
        Polymer.flush();
      }
    }, {
      key: '__render',
      value: function __render() {
        if (!this.__ensureTemplatized()) {
          // No template found yet
          return;
        }
        this.__applyFullRefresh();
        // Reset the pool
        // TODO(kschaaf): Reuse pool across turns and nested templates
        // Now that objects/arrays are re-evaluated when set, we can safely
        // reuse pooled instances across turns, however we still need to decide
        // semantics regarding how long to hold, how many to hold, etc.
        this.__pool.length = 0;
        // Set rendered item count
        this._setRenderedItemCount(this.__instances.length);
        // Notify users
        this.dispatchEvent(new CustomEvent('dom-change', {
          bubbles: true,
          composed: true
        }));
        // Check to see if we need to render more items
        this.__tryRenderChunk();
      }
    }, {
      key: '__applyFullRefresh',
      value: function __applyFullRefresh() {
        var _this4 = this;

        var items = this.items || [];
        var isntIdxToItemsIdx = new Array(items.length);
        for (var i = 0; i < items.length; i++) {
          isntIdxToItemsIdx[i] = i;
        }
        // Apply user filter
        if (this.__filterFn) {
          isntIdxToItemsIdx = isntIdxToItemsIdx.filter(function (i, idx, array) {
            return _this4.__filterFn(items[i], idx, array);
          });
        }
        // Apply user sort
        if (this.__sortFn) {
          isntIdxToItemsIdx.sort(function (a, b) {
            return _this4.__sortFn(items[a], items[b]);
          });
        }
        // items->inst map kept for item path forwarding
        var itemsIdxToInstIdx = this.__itemsIdxToInstIdx = {};
        var instIdx = 0;
        // Generate instances and assign items
        var limit = Math.min(isntIdxToItemsIdx.length, this.__limit);
        for (; instIdx < limit; instIdx++) {
          var inst = this.__instances[instIdx];
          var itemIdx = isntIdxToItemsIdx[instIdx];
          var item = items[itemIdx];
          itemsIdxToInstIdx[itemIdx] = instIdx;
          if (inst && instIdx < this.__limit) {
            inst._setPendingProperty(this.as, item);
            inst._setPendingProperty(this.indexAs, instIdx);
            inst._setPendingProperty(this.itemsIndexAs, itemIdx);
            inst._flushProperties();
          } else {
            this.__insertInstance(item, instIdx, itemIdx);
          }
        }
        // Remove any extra instances from previous state
        for (var _i = this.__instances.length - 1; _i >= instIdx; _i--) {
          this.__detachAndRemoveInstance(_i);
        }
      }
    }, {
      key: '__detachInstance',
      value: function __detachInstance(idx) {
        var inst = this.__instances[idx];
        for (var i = 0; i < inst.children.length; i++) {
          var el = inst.children[i];
          inst.root.appendChild(el);
        }
        return inst;
      }
    }, {
      key: '__attachInstance',
      value: function __attachInstance(idx, parent) {
        var inst = this.__instances[idx];
        parent.insertBefore(inst.root, this);
      }
    }, {
      key: '__detachAndRemoveInstance',
      value: function __detachAndRemoveInstance(idx) {
        var inst = this.__detachInstance(idx);
        if (inst) {
          this.__pool.push(inst);
        }
        this.__instances.splice(idx, 1);
      }
    }, {
      key: '__stampInstance',
      value: function __stampInstance(item, instIdx, itemIdx) {
        var model = {};
        model[this.as] = item;
        model[this.indexAs] = instIdx;
        model[this.itemsIndexAs] = itemIdx;
        return new this.__ctor(model);
      }
    }, {
      key: '__insertInstance',
      value: function __insertInstance(item, instIdx, itemIdx) {
        var inst = this.__pool.pop();
        if (inst) {
          // TODO(kschaaf): If the pool is shared across turns, hostProps
          // need to be re-set to reused instances in addition to item
          inst._setPendingProperty(this.as, item);
          inst._setPendingProperty(this.indexAs, instIdx);
          inst._setPendingProperty(this.itemsIndexAs, itemIdx);
          inst._flushProperties();
        } else {
          inst = this.__stampInstance(item, instIdx, itemIdx);
        }
        var beforeRow = this.__instances[instIdx + 1];
        var beforeNode = beforeRow ? beforeRow.children[0] : this;
        this.parentNode.insertBefore(inst.root, beforeNode);
        this.__instances[instIdx] = inst;
        return inst;
      }

      // Implements extension point from Templatize mixin

    }, {
      key: '_showHideChildren',
      value: function _showHideChildren(hidden) {
        for (var i = 0; i < this.__instances.length; i++) {
          this.__instances[i]._showHideChildren(hidden);
        }
      }

      // Called as a side effect of a host items.<key>.<path> path change,
      // responsible for notifying item.<path> changes to inst for key

    }, {
      key: '__handleItemPath',
      value: function __handleItemPath(path, value) {
        var itemsPath = path.slice(6); // 'items.'.length == 6
        var dot = itemsPath.indexOf('.');
        var itemsIdx = dot < 0 ? itemsPath : itemsPath.substring(0, dot);
        // If path was index into array...
        if (itemsIdx == parseInt(itemsIdx, 10)) {
          var itemSubPath = dot < 0 ? '' : itemsPath.substring(dot + 1);
          // If the path is observed, it will trigger a full refresh
          this.__handleObservedPaths(itemSubPath);
          // Note, even if a rull refresh is triggered, always do the path
          // notification because unless mutableData is used for dom-repeat
          // and all elements in the instance subtree, a full refresh may
          // not trigger the proper update.
          var instIdx = this.__itemsIdxToInstIdx[itemsIdx];
          var inst = this.__instances[instIdx];
          if (inst) {
            var itemPath = this.as + (itemSubPath ? '.' + itemSubPath : '');
            // This is effectively `notifyPath`, but avoids some of the overhead
            // of the public API
            inst._setPendingPropertyOrPath(itemPath, value, false, true);
            inst._flushProperties();
          }
          return true;
        }
      }

      /**
       * Returns the item associated with a given element stamped by
       * this `dom-repeat`.
       *
       * Note, to modify sub-properties of the item,
       * `modelForElement(el).set('item.<sub-prop>', value)`
       * should be used.
       *
       * @param {HTMLElement} el Element for which to return the item.
       * @return {*} Item associated with the element.
       */

    }, {
      key: 'itemForElement',
      value: function itemForElement(el) {
        var instance = this.modelForElement(el);
        return instance && instance[this.as];
      }

      /**
       * Returns the inst index for a given element stamped by this `dom-repeat`.
       * If `sort` is provided, the index will reflect the sorted order (rather
       * than the original array order).
       *
       * @param {HTMLElement} el Element for which to return the index.
       * @return {*} Row index associated with the element (note this may
       *   not correspond to the array index if a user `sort` is applied).
       */

    }, {
      key: 'indexForElement',
      value: function indexForElement(el) {
        var instance = this.modelForElement(el);
        return instance && instance[this.indexAs];
      }

      /**
       * Returns the template "model" associated with a given element, which
       * serves as the binding scope for the template instance the element is
       * contained in. A template model is an instance of `Polymer.Base`, and
       * should be used to manipulate data associated with this template instance.
       *
       * Example:
       *
       *   let model = modelForElement(el);
       *   if (model.index < 10) {
       *     model.set('item.checked', true);
       *   }
       *
       * @param {HTMLElement} el Element for which to return a template model.
       * @return {TemplateInstanceBase} Model representing the binding scope for
       *   the element.
       */

    }, {
      key: 'modelForElement',
      value: function modelForElement(el) {
        return Polymer.Templatize.modelForElement(this.template, el);
      }
    }]);

    return DomRepeat;
  }(domRepeatBase);

  customElements.define(DomRepeat.is, DomRepeat);

  Polymer.DomRepeat = DomRepeat;
})();

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

__webpack_require__(6);

__webpack_require__(14);

__webpack_require__(12);

__webpack_require__(13);

(function () {
  'use strict';

  /**
   * The `<dom-if>` element will stamp a light-dom `<template>` child when
   * the `if` property becomes truthy, and the template can use Polymer
   * data-binding and declarative event features when used in the context of
   * a Polymer element's template.
   *
   * When `if` becomes falsey, the stamped content is hidden but not
   * removed from dom. When `if` subsequently becomes truthy again, the content
   * is simply re-shown. This approach is used due to its favorable performance
   * characteristics: the expense of creating template content is paid only
   * once and lazily.
   *
   * Set the `restamp` property to true to force the stamped content to be
   * created / destroyed when the `if` condition changes.
   *
   * @customElement
   * @polymer
   * @extends Polymer.Element
   * @memberof Polymer
   * @summary Custom element that conditionally stamps and hides or removes
   *   template content based on a boolean flag.
   */

  var DomIf = function (_Polymer$Element) {
    _inherits(DomIf, _Polymer$Element);

    _createClass(DomIf, null, [{
      key: 'is',


      // Not needed to find template; can be removed once the analyzer
      // can find the tag name from customElements.define call
      get: function get() {
        return 'dom-if';
      }
    }, {
      key: 'template',
      get: function get() {
        return null;
      }
    }, {
      key: 'properties',
      get: function get() {

        return {

          /**
           * Fired whenever DOM is added or removed/hidden by this template (by
           * default, rendering occurs lazily).  To force immediate rendering, call
           * `render`.
           *
           * @event dom-change
           */

          /**
           * A boolean indicating whether this template should stamp.
           */
          if: {
            type: Boolean,
            observer: '__debounceRender'
          },

          /**
           * When true, elements will be removed from DOM and discarded when `if`
           * becomes false and re-created and added back to the DOM when `if`
           * becomes true.  By default, stamped elements will be hidden but left
           * in the DOM when `if` becomes false, which is generally results
           * in better performance.
           */
          restamp: {
            type: Boolean,
            observer: '__debounceRender'
          }

        };
      }
    }]);

    function DomIf() {
      _classCallCheck(this, DomIf);

      var _this = _possibleConstructorReturn(this, (DomIf.__proto__ || Object.getPrototypeOf(DomIf)).call(this));

      _this.__renderDebouncer = null;
      _this.__invalidProps = null;
      _this.__instance = null;
      _this._lastIf = false;
      _this.__ctor = null;
      return _this;
    }

    _createClass(DomIf, [{
      key: '__debounceRender',
      value: function __debounceRender() {
        var _this2 = this;

        // Render is async for 2 reasons:
        // 1. To eliminate dom creation trashing if user code thrashes `if` in the
        //    same turn. This was more common in 1.x where a compound computed
        //    property could result in the result changing multiple times, but is
        //    mitigated to a large extent by batched property processing in 2.x.
        // 2. To avoid double object propagation when a bag including values bound
        //    to the `if` property as well as one or more hostProps could enqueue
        //    the <dom-if> to flush before the <template>'s host property
        //    forwarding. In that scenario creating an instance would result in
        //    the host props being set once, and then the enqueued changes on the
        //    template would set properties a second time, potentially causing an
        //    object to be set to an instance more than once.  Creating the
        //    instance async from flushing data ensures this doesn't happen. If
        //    we wanted a sync option in the future, simply having <dom-if> flush
        //    (or clear) its template's pending host properties before creating
        //    the instance would also avoid the problem.
        this.__renderDebouncer = Polymer.Debouncer.debounce(this.__renderDebouncer, Polymer.Async.microTask, function () {
          return _this2.__render();
        });
        Polymer.enqueueDebouncer(this.__renderDebouncer);
      }
    }, {
      key: 'disconnectedCallback',
      value: function disconnectedCallback() {
        _get(DomIf.prototype.__proto__ || Object.getPrototypeOf(DomIf.prototype), 'disconnectedCallback', this).call(this);
        if (!this.parentNode || this.parentNode.nodeType == Node.DOCUMENT_FRAGMENT_NODE && !this.parentNode.host) {
          this.__teardownInstance();
        }
      }
    }, {
      key: 'connectedCallback',
      value: function connectedCallback() {
        _get(DomIf.prototype.__proto__ || Object.getPrototypeOf(DomIf.prototype), 'connectedCallback', this).call(this);
        if (this.if) {
          this.__debounceRender();
        }
      }

      /**
       * Forces the element to render its content. Normally rendering is
       * asynchronous to a provoking change. This is done for efficiency so
       * that multiple changes trigger only a single render. The render method
       * should be called if, for example, template rendering is required to
       * validate application state.
       */

    }, {
      key: 'render',
      value: function render() {
        Polymer.flush();
      }
    }, {
      key: '__render',
      value: function __render() {
        if (this.if) {
          if (!this.__ensureInstance()) {
            // No template found yet
            return;
          }
          this._showHideChildren();
        } else if (this.restamp) {
          this.__teardownInstance();
        }
        if (!this.restamp && this.__instance) {
          this._showHideChildren();
        }
        if (this.if != this._lastIf) {
          this.dispatchEvent(new CustomEvent('dom-change', {
            bubbles: true,
            composed: true
          }));
          this._lastIf = this.if;
        }
      }
    }, {
      key: '__ensureInstance',
      value: function __ensureInstance() {
        var _this3 = this;

        var parentNode = this.parentNode;
        // Guard against element being detached while render was queued
        if (parentNode) {
          if (!this.__ctor) {
            var template = this.querySelector('template');
            if (!template) {
              // Wait until childList changes and template should be there by then
              var observer = new MutationObserver(function () {
                if (_this3.querySelector('template')) {
                  observer.disconnect();
                  _this3.__render();
                } else {
                  throw new Error('dom-if requires a <template> child');
                }
              });
              observer.observe(this, { childList: true });
              return false;
            }
            this.__ctor = Polymer.Templatize.templatize(template, this, {
              // dom-if templatizer instances require `mutable: true`, as
              // `__syncHostProperties` relies on that behavior to sync objects
              mutableData: true,
              /**
               * @param {string} prop Property to forward
               * @param {*} value Value of property
               * @this {this}
               */
              forwardHostProp: function forwardHostProp(prop, value) {
                if (this.__instance) {
                  if (this.if) {
                    this.__instance.forwardHostProp(prop, value);
                  } else {
                    // If we have an instance but are squelching host property
                    // forwarding due to if being false, note the invalidated
                    // properties so `__syncHostProperties` can sync them the next
                    // time `if` becomes true
                    this.__invalidProps = this.__invalidProps || Object.create(null);
                    this.__invalidProps[Polymer.Path.root(prop)] = true;
                  }
                }
              }
            });
          }
          if (!this.__instance) {
            this.__instance = new this.__ctor();
            parentNode.insertBefore(this.__instance.root, this);
          } else {
            this.__syncHostProperties();
            var c$ = this.__instance.children;
            if (c$ && c$.length) {
              // Detect case where dom-if was re-attached in new position
              var lastChild = this.previousSibling;
              if (lastChild !== c$[c$.length - 1]) {
                for (var i = 0, n; i < c$.length && (n = c$[i]); i++) {
                  parentNode.insertBefore(n, this);
                }
              }
            }
          }
        }
        return true;
      }
    }, {
      key: '__syncHostProperties',
      value: function __syncHostProperties() {
        var props = this.__invalidProps;
        if (props) {
          for (var prop in props) {
            this.__instance._setPendingProperty(prop, this.__dataHost[prop]);
          }
          this.__invalidProps = null;
          this.__instance._flushProperties();
        }
      }
    }, {
      key: '__teardownInstance',
      value: function __teardownInstance() {
        if (this.__instance) {
          var c$ = this.__instance.children;
          if (c$ && c$.length) {
            // use first child parent, for case when dom-if may have been detached
            var parent = c$[0].parentNode;
            for (var i = 0, n; i < c$.length && (n = c$[i]); i++) {
              parent.removeChild(n);
            }
          }
          this.__instance = null;
          this.__invalidProps = null;
        }
      }
    }, {
      key: '_showHideChildren',
      value: function _showHideChildren() {
        var hidden = this.__hideTemplateChildren__ || !this.if;
        if (this.__instance) {
          this.__instance._showHideChildren(hidden);
        }
      }
    }]);

    return DomIf;
  }(Polymer.Element);

  customElements.define(DomIf.is, DomIf);

  Polymer.DomIf = DomIf;
})();

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

__webpack_require__(6);

__webpack_require__(3);

__webpack_require__(21);

(function () {
  'use strict';

  /**
   * Element mixin for recording dynamic associations between item paths in a
   * master `items` array and a `selected` array such that path changes to the
   * master array (at the host) element or elsewhere via data-binding) are
   * correctly propagated to items in the selected array and vice-versa.
   *
   * The `items` property accepts an array of user data, and via the
   * `select(item)` and `deselect(item)` API, updates the `selected` property
   * which may be bound to other parts of the application, and any changes to
   * sub-fields of `selected` item(s) will be kept in sync with items in the
   * `items` array.  When `multi` is false, `selected` is a property
   * representing the last selected item.  When `multi` is true, `selected`
   * is an array of multiply selected items.
   *
   * @polymer
   * @mixinFunction
   * @appliesMixin Polymer.ElementMixin
   * @memberof Polymer
   * @summary Element mixin for recording dynamic associations between item paths in a
   * master `items` array and a `selected` array
   */

  var ArraySelectorMixin = Polymer.dedupingMixin(function (superClass) {

    /**
     * @constructor
     * @extends {superClass}
     * @implements {Polymer_ElementMixin}
     */
    var elementBase = Polymer.ElementMixin(superClass);

    /**
     * @polymer
     * @mixinClass
     * @implements {Polymer_ArraySelectorMixin}
     * @unrestricted
     */

    var ArraySelectorMixin = function (_elementBase) {
      _inherits(ArraySelectorMixin, _elementBase);

      _createClass(ArraySelectorMixin, null, [{
        key: 'properties',
        get: function get() {

          return {

            /**
             * An array containing items from which selection will be made.
             */
            items: {
              type: Array
            },

            /**
             * When `true`, multiple items may be selected at once (in this case,
             * `selected` is an array of currently selected items).  When `false`,
             * only one item may be selected at a time.
             */
            multi: {
              type: Boolean,
              value: false
            },

            /**
             * When `multi` is true, this is an array that contains any selected.
             * When `multi` is false, this is the currently selected item, or `null`
             * if no item is selected.
             * @type {?(Object|Array<!Object>)}
             */
            selected: {
              type: Object,
              notify: true
            },

            /**
             * When `multi` is false, this is the currently selected item, or `null`
             * if no item is selected.
             * @type {?Object}
             */
            selectedItem: {
              type: Object,
              notify: true
            },

            /**
             * When `true`, calling `select` on an item that is already selected
             * will deselect the item.
             */
            toggle: {
              type: Boolean,
              value: false
            }

          };
        }
      }, {
        key: 'observers',
        get: function get() {
          return ['__updateSelection(multi, items.*)'];
        }
      }]);

      function ArraySelectorMixin() {
        _classCallCheck(this, ArraySelectorMixin);

        var _this = _possibleConstructorReturn(this, (ArraySelectorMixin.__proto__ || Object.getPrototypeOf(ArraySelectorMixin)).call(this));

        _this.__lastItems = null;
        _this.__lastMulti = null;
        _this.__selectedMap = null;
        return _this;
      }

      _createClass(ArraySelectorMixin, [{
        key: '__updateSelection',
        value: function __updateSelection(multi, itemsInfo) {
          var path = itemsInfo.path;
          if (path == 'items') {
            // Case 1 - items array changed, so diff against previous array and
            // deselect any removed items and adjust selected indices
            var newItems = itemsInfo.base || [];
            var lastItems = this.__lastItems;
            var lastMulti = this.__lastMulti;
            if (multi !== lastMulti) {
              this.clearSelection();
            }
            if (lastItems) {
              var splices = Polymer.ArraySplice.calculateSplices(newItems, lastItems);
              this.__applySplices(splices);
            }
            this.__lastItems = newItems;
            this.__lastMulti = multi;
          } else if (itemsInfo.path == 'items.splices') {
            // Case 2 - got specific splice information describing the array mutation:
            // deselect any removed items and adjust selected indices
            this.__applySplices(itemsInfo.value.indexSplices);
          } else {
            // Case 3 - an array element was changed, so deselect the previous
            // item for that index if it was previously selected
            var part = path.slice('items.'.length);
            var idx = parseInt(part, 10);
            if (part.indexOf('.') < 0 && part == idx) {
              this.__deselectChangedIdx(idx);
            }
          }
        }
      }, {
        key: '__applySplices',
        value: function __applySplices(splices) {
          var _this2 = this;

          var selected = this.__selectedMap;
          // Adjust selected indices and mark removals

          var _loop = function _loop(i) {
            var s = splices[i];
            selected.forEach(function (idx, item) {
              if (idx < s.index) {
                // no change
              } else if (idx >= s.index + s.removed.length) {
                // adjust index
                selected.set(item, idx + s.addedCount - s.removed.length);
              } else {
                // remove index
                selected.set(item, -1);
              }
            });
            for (var j = 0; j < s.addedCount; j++) {
              var idx = s.index + j;
              if (selected.has(_this2.items[idx])) {
                selected.set(_this2.items[idx], idx);
              }
            }
          };

          for (var i = 0; i < splices.length; i++) {
            _loop(i);
          }
          // Update linked paths
          this.__updateLinks();
          // Remove selected items that were removed from the items array
          var sidx = 0;
          selected.forEach(function (idx, item) {
            if (idx < 0) {
              if (_this2.multi) {
                _this2.splice('selected', sidx, 1);
              } else {
                _this2.selected = _this2.selectedItem = null;
              }
              selected.delete(item);
            } else {
              sidx++;
            }
          });
        }
      }, {
        key: '__updateLinks',
        value: function __updateLinks() {
          var _this3 = this;

          this.__dataLinkedPaths = {};
          if (this.multi) {
            var sidx = 0;
            this.__selectedMap.forEach(function (idx) {
              if (idx >= 0) {
                _this3.linkPaths('items.' + idx, 'selected.' + sidx++);
              }
            });
          } else {
            this.__selectedMap.forEach(function (idx) {
              _this3.linkPaths('selected', 'items.' + idx);
              _this3.linkPaths('selectedItem', 'items.' + idx);
            });
          }
        }

        /**
         * Clears the selection state.
         *
         */

      }, {
        key: 'clearSelection',
        value: function clearSelection() {
          // Unbind previous selection
          this.__dataLinkedPaths = {};
          // The selected map stores 3 pieces of information:
          // key: items array object
          // value: items array index
          // order: selected array index
          this.__selectedMap = new Map();
          // Initialize selection
          this.selected = this.multi ? [] : null;
          this.selectedItem = null;
        }

        /**
         * Returns whether the item is currently selected.
         *
         * @param {*} item Item from `items` array to test
         * @return {boolean} Whether the item is selected
         */

      }, {
        key: 'isSelected',
        value: function isSelected(item) {
          return this.__selectedMap.has(item);
        }

        /**
         * Returns whether the item is currently selected.
         *
         * @param {number} idx Index from `items` array to test
         * @return {boolean} Whether the item is selected
         */

      }, {
        key: 'isIndexSelected',
        value: function isIndexSelected(idx) {
          return this.isSelected(this.items[idx]);
        }
      }, {
        key: '__deselectChangedIdx',
        value: function __deselectChangedIdx(idx) {
          var _this4 = this;

          var sidx = this.__selectedIndexForItemIndex(idx);
          if (sidx >= 0) {
            var i = 0;
            this.__selectedMap.forEach(function (idx, item) {
              if (sidx == i++) {
                _this4.deselect(item);
              }
            });
          }
        }
      }, {
        key: '__selectedIndexForItemIndex',
        value: function __selectedIndexForItemIndex(idx) {
          var selected = this.__dataLinkedPaths['items.' + idx];
          if (selected) {
            return parseInt(selected.slice('selected.'.length), 10);
          }
        }

        /**
         * Deselects the given item if it is already selected.
         *
         * @param {*} item Item from `items` array to deselect
         */

      }, {
        key: 'deselect',
        value: function deselect(item) {
          var idx = this.__selectedMap.get(item);
          if (idx >= 0) {
            this.__selectedMap.delete(item);
            var sidx = void 0;
            if (this.multi) {
              sidx = this.__selectedIndexForItemIndex(idx);
            }
            this.__updateLinks();
            if (this.multi) {
              this.splice('selected', sidx, 1);
            } else {
              this.selected = this.selectedItem = null;
            }
          }
        }

        /**
         * Deselects the given index if it is already selected.
         *
         * @param {number} idx Index from `items` array to deselect
         */

      }, {
        key: 'deselectIndex',
        value: function deselectIndex(idx) {
          this.deselect(this.items[idx]);
        }

        /**
         * Selects the given item.  When `toggle` is true, this will automatically
         * deselect the item if already selected.
         *
         * @param {*} item Item from `items` array to select
         */

      }, {
        key: 'select',
        value: function select(item) {
          this.selectIndex(this.items.indexOf(item));
        }

        /**
         * Selects the given index.  When `toggle` is true, this will automatically
         * deselect the item if already selected.
         *
         * @param {number} idx Index from `items` array to select
         */

      }, {
        key: 'selectIndex',
        value: function selectIndex(idx) {
          var item = this.items[idx];
          if (!this.isSelected(item)) {
            if (!this.multi) {
              this.__selectedMap.clear();
            }
            this.__selectedMap.set(item, idx);
            this.__updateLinks();
            if (this.multi) {
              this.push('selected', item);
            } else {
              this.selected = this.selectedItem = item;
            }
          } else if (this.toggle) {
            this.deselectIndex(idx);
          }
        }
      }]);

      return ArraySelectorMixin;
    }(elementBase);

    return ArraySelectorMixin;
  });

  // export mixin
  Polymer.ArraySelectorMixin = ArraySelectorMixin;

  /**
   * @constructor
   * @extends {Polymer.Element}
   * @implements {Polymer_ArraySelectorMixin}
   */
  var baseArraySelector = ArraySelectorMixin(Polymer.Element);

  /**
   * Element implementing the `Polymer.ArraySelector` mixin, which records
   * dynamic associations between item paths in a master `items` array and a
   * `selected` array such that path changes to the master array (at the host)
   * element or elsewhere via data-binding) are correctly propagated to items
   * in the selected array and vice-versa.
   *
   * The `items` property accepts an array of user data, and via the
   * `select(item)` and `deselect(item)` API, updates the `selected` property
   * which may be bound to other parts of the application, and any changes to
   * sub-fields of `selected` item(s) will be kept in sync with items in the
   * `items` array.  When `multi` is false, `selected` is a property
   * representing the last selected item.  When `multi` is true, `selected`
   * is an array of multiply selected items.
   *
   * Example:
   *
   * ```html
   * <dom-module id="employee-list">
   *
   *   <template>
   *
   *     <div> Employee list: </div>
   *     <template is="dom-repeat" id="employeeList" items="{{employees}}">
   *         <div>First name: <span>{{item.first}}</span></div>
   *         <div>Last name: <span>{{item.last}}</span></div>
   *         <button on-click="toggleSelection">Select</button>
   *     </template>
   *
   *     <array-selector id="selector" items="{{employees}}" selected="{{selected}}" multi toggle></array-selector>
   *
   *     <div> Selected employees: </div>
   *     <template is="dom-repeat" items="{{selected}}">
   *         <div>First name: <span>{{item.first}}</span></div>
   *         <div>Last name: <span>{{item.last}}</span></div>
   *     </template>
   *
   *   </template>
   *
   * </dom-module>
   * ```
   *
   * ```js
   * Polymer({
   *   is: 'employee-list',
   *   ready() {
   *     this.employees = [
   *         {first: 'Bob', last: 'Smith'},
   *         {first: 'Sally', last: 'Johnson'},
   *         ...
   *     ];
   *   },
   *   toggleSelection(e) {
   *     let item = this.$.employeeList.itemForElement(e.target);
   *     this.$.selector.select(item);
   *   }
   * });
   * ```
   *
   * @polymer
   * @customElement
   * @extends {baseArraySelector}
   * @appliesMixin Polymer.ArraySelectorMixin
   * @memberof Polymer
   * @summary Custom element that links paths between an input `items` array and
   *   an output `selected` item or array based on calls to its selection API.
   */

  var ArraySelector = function (_baseArraySelector) {
    _inherits(ArraySelector, _baseArraySelector);

    function ArraySelector() {
      _classCallCheck(this, ArraySelector);

      return _possibleConstructorReturn(this, (ArraySelector.__proto__ || Object.getPrototypeOf(ArraySelector)).apply(this, arguments));
    }

    _createClass(ArraySelector, null, [{
      key: 'is',

      // Not needed to find template; can be removed once the analyzer
      // can find the tag name from customElements.define call
      get: function get() {
        return 'array-selector';
      }
    }]);

    return ArraySelector;
  }(baseArraySelector);

  customElements.define(ArraySelector.is, ArraySelector);
  Polymer.ArraySelector = ArraySelector;
})();

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

__webpack_require__(52);

__webpack_require__(18);

(function () {
  'use strict';

  var attr = 'include';

  var CustomStyleInterface = window.ShadyCSS.CustomStyleInterface;

  /**
   * Custom element for defining styles in the main document that can take
   * advantage of several special features of Polymer's styling system:
   *
   * - Document styles defined in a custom-style are shimmed to ensure they
   *   do not leak into local DOM when running on browsers without native
   *   Shadow DOM.
   * - Custom properties used by Polymer's shim for cross-scope styling may
   *   be defined in an custom-style. Use the :root selector to define custom
   *   properties that apply to all custom elements.
   *
   * To use, simply wrap an inline `<style>` tag in the main document whose
   * CSS uses these features with a `<custom-style>` element.
   *
   * @customElement
   * @extends HTMLElement
   * @memberof Polymer
   * @summary Custom element for defining styles in the main document that can
   *   take advantage of Polymer's style scoping and custom properties shims.
   */

  var CustomStyle = function (_HTMLElement) {
    _inherits(CustomStyle, _HTMLElement);

    function CustomStyle() {
      _classCallCheck(this, CustomStyle);

      var _this = _possibleConstructorReturn(this, (CustomStyle.__proto__ || Object.getPrototypeOf(CustomStyle)).call(this));

      _this._style = null;
      CustomStyleInterface.addCustomStyle(_this);
      return _this;
    }
    /**
     * Returns the light-DOM `<style>` child this element wraps.  Upon first
     * call any style modules referenced via the `include` attribute will be
     * concatenated to this element's `<style>`.
     *
     * @return {HTMLStyleElement} This element's light-DOM `<style>`
     */


    _createClass(CustomStyle, [{
      key: 'getStyle',
      value: function getStyle() {
        if (this._style) {
          return this._style;
        }
        var style = /** @type {HTMLStyleElement} */this.querySelector('style');
        if (!style) {
          return null;
        }
        this._style = style;
        var include = style.getAttribute(attr);
        if (include) {
          style.removeAttribute(attr);
          style.textContent = Polymer.StyleGather.cssFromModules(include) + style.textContent;
        }
        return this._style;
      }
    }]);

    return CustomStyle;
  }(HTMLElement);

  window.customElements.define('custom-style', CustomStyle);
  Polymer.CustomStyle = CustomStyle;
})();

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(53);

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


(function () {
  /*
  Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
  This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
  The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
  The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
  Code distributed by Google as part of the polymer project is also
  subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
  */
  'use strict';
  var c = !(window.ShadyDOM && window.ShadyDOM.inUse),
      f;function g(a) {
    f = a && a.shimcssproperties ? !1 : c || !(navigator.userAgent.match(/AppleWebKit\/601|Edge\/15/) || !window.CSS || !CSS.supports || !CSS.supports("box-shadow", "0 0 0 var(--foo)"));
  }window.ShadyCSS && void 0 !== window.ShadyCSS.nativeCss ? f = window.ShadyCSS.nativeCss : window.ShadyCSS ? (g(window.ShadyCSS), window.ShadyCSS = void 0) : g(window.WebComponents && window.WebComponents.flags);var h = f;function k(a, b) {
    for (var d in b) {
      null === d ? a.style.removeProperty(d) : a.style.setProperty(d, b[d]);
    }
  };var l = null,
      m = window.HTMLImports && window.HTMLImports.whenReady || null,
      n;function p() {
    var a = q;requestAnimationFrame(function () {
      m ? m(a) : (l || (l = new Promise(function (a) {
        n = a;
      }), "complete" === document.readyState ? n() : document.addEventListener("readystatechange", function () {
        "complete" === document.readyState && n();
      })), l.then(function () {
        a && a();
      }));
    });
  };var r = null,
      q = null;function t() {
    this.customStyles = [];this.enqueued = !1;
  }function u(a) {
    !a.enqueued && q && (a.enqueued = !0, p());
  }t.prototype.c = function (a) {
    a.__seenByShadyCSS || (a.__seenByShadyCSS = !0, this.customStyles.push(a), u(this));
  };t.prototype.b = function (a) {
    if (a.__shadyCSSCachedStyle) return a.__shadyCSSCachedStyle;var b;a.getStyle ? b = a.getStyle() : b = a;return b;
  };
  t.prototype.a = function () {
    for (var a = this.customStyles, b = 0; b < a.length; b++) {
      var d = a[b];if (!d.__shadyCSSCachedStyle) {
        var e = this.b(d);e && (e = e.__appliedElement || e, r && r(e), d.__shadyCSSCachedStyle = e);
      }
    }return a;
  };t.prototype.addCustomStyle = t.prototype.c;t.prototype.getStyleForCustomStyle = t.prototype.b;t.prototype.processStyles = t.prototype.a;
  Object.defineProperties(t.prototype, { transformCallback: { get: function get() {
        return r;
      }, set: function set(a) {
        r = a;
      } }, validateCallback: { get: function get() {
        return q;
      }, set: function set(a) {
        var b = !1;q || (b = !0);q = a;b && u(this);
      } } });var v = new t();window.ShadyCSS || (window.ShadyCSS = { prepareTemplate: function prepareTemplate() {}, styleSubtree: function styleSubtree(a, b) {
      v.a();k(a, b);
    }, styleElement: function styleElement() {
      v.a();
    }, styleDocument: function styleDocument(a) {
      v.a();k(document.body, a);
    }, getComputedStyleValue: function getComputedStyleValue(a, b) {
      return (a = window.getComputedStyle(a).getPropertyValue(b)) ? a.trim() : "";
    }, nativeCss: h, nativeShadow: c });window.ShadyCSS.CustomStyleInterface = v;
}).call(undefined);

//# sourceMappingURL=custom-style-interface.min.js.map

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(9);

(function () {
  'use strict';

  var mutablePropertyChange = void 0;
  (
  /** @suppress {missingProperties} */
  function () {
    mutablePropertyChange = Polymer.MutableData._mutablePropertyChange;
  })();

  /**
   * Legacy element behavior to skip strict dirty-checking for objects and arrays,
   * (always consider them to be "dirty") for use on legacy API Polymer elements.
   *
   * By default, `Polymer.PropertyEffects` performs strict dirty checking on
   * objects, which means that any deep modifications to an object or array will
   * not be propagated unless "immutable" data patterns are used (i.e. all object
   * references from the root to the mutation were changed).
   *
   * Polymer also provides a proprietary data mutation and path notification API
   * (e.g. `notifyPath`, `set`, and array mutation API's) that allow efficient
   * mutation and notification of deep changes in an object graph to all elements
   * bound to the same object graph.
   *
   * In cases where neither immutable patterns nor the data mutation API can be
   * used, applying this mixin will cause Polymer to skip dirty checking for
   * objects and arrays (always consider them to be "dirty").  This allows a
   * user to make a deep modification to a bound object graph, and then either
   * simply re-set the object (e.g. `this.items = this.items`) or call `notifyPath`
   * (e.g. `this.notifyPath('items')`) to update the tree.  Note that all
   * elements that wish to be updated based on deep mutations must apply this
   * mixin or otherwise skip strict dirty checking for objects/arrays.
   *
   * In order to make the dirty check strategy configurable, see
   * `Polymer.OptionalMutableDataBehavior`.
   *
   * Note, the performance characteristics of propagating large object graphs
   * will be worse as opposed to using strict dirty checking with immutable
   * patterns or Polymer's path notification API.
   *
   * @polymerBehavior
   * @memberof Polymer
   * @summary Behavior to skip strict dirty-checking for objects and
   *   arrays
   */
  Polymer.MutableDataBehavior = {

    /**
     * Overrides `Polymer.PropertyEffects` to provide option for skipping
     * strict equality checking for Objects and Arrays.
     *
     * This method pulls the value to dirty check against from the `__dataTemp`
     * cache (rather than the normal `__data` cache) for Objects.  Since the temp
     * cache is cleared at the end of a turn, this implementation allows
     * side-effects of deep object changes to be processed by re-setting the
     * same object (using the temp cache as an in-turn backstop to prevent
     * cycles due to 2-way notification).
     *
     * @param {string} property Property name
     * @param {*} value New property value
     * @param {*} old Previous property value
     * @return {boolean} Whether the property should be considered a change
     * @protected
     */
    _shouldPropertyChange: function _shouldPropertyChange(property, value, old) {
      return mutablePropertyChange(this, property, value, old, true);
    }
  };

  /**
   * Legacy element behavior to add the optional ability to skip strict
   * dirty-checking for objects and arrays (always consider them to be
   * "dirty") by setting a `mutable-data` attribute on an element instance.
   *
   * By default, `Polymer.PropertyEffects` performs strict dirty checking on
   * objects, which means that any deep modifications to an object or array will
   * not be propagated unless "immutable" data patterns are used (i.e. all object
   * references from the root to the mutation were changed).
   *
   * Polymer also provides a proprietary data mutation and path notification API
   * (e.g. `notifyPath`, `set`, and array mutation API's) that allow efficient
   * mutation and notification of deep changes in an object graph to all elements
   * bound to the same object graph.
   *
   * In cases where neither immutable patterns nor the data mutation API can be
   * used, applying this mixin will allow Polymer to skip dirty checking for
   * objects and arrays (always consider them to be "dirty").  This allows a
   * user to make a deep modification to a bound object graph, and then either
   * simply re-set the object (e.g. `this.items = this.items`) or call `notifyPath`
   * (e.g. `this.notifyPath('items')`) to update the tree.  Note that all
   * elements that wish to be updated based on deep mutations must apply this
   * mixin or otherwise skip strict dirty checking for objects/arrays.
   *
   * While this behavior adds the ability to forgo Object/Array dirty checking,
   * the `mutableData` flag defaults to false and must be set on the instance.
   *
   * Note, the performance characteristics of propagating large object graphs
   * will be worse by relying on `mutableData: true` as opposed to using
   * strict dirty checking with immutable patterns or Polymer's path notification
   * API.
   *
   * @polymerBehavior
   * @memberof Polymer
   * @summary Behavior to optionally skip strict dirty-checking for objects and
   *   arrays
   */
  Polymer.OptionalMutableDataBehavior = {

    properties: {
      /**
       * Instance-level flag for configuring the dirty-checking strategy
       * for this element.  When true, Objects and Arrays will skip dirty
       * checking, otherwise strict equality checking will be used.
       */
      mutableData: Boolean
    },

    /**
     * Overrides `Polymer.PropertyEffects` to skip strict equality checking
     * for Objects and Arrays.
     *
     * Pulls the value to dirty check against from the `__dataTemp` cache
     * (rather than the normal `__data` cache) for Objects.  Since the temp
     * cache is cleared at the end of a turn, this implementation allows
     * side-effects of deep object changes to be processed by re-setting the
     * same object (using the temp cache as an in-turn backstop to prevent
     * cycles due to 2-way notification).
     *
     * @param {string} property Property name
     * @param {*} value New property value
     * @param {*} old Previous property value
     * @return {boolean} Whether the property should be considered a change
     * @this {this}
     * @protected
     */
    _shouldPropertyChange: function _shouldPropertyChange(property, value, old) {
      return mutablePropertyChange(this, property, value, old, this.mutableData);
    }
  };
})();

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

__webpack_require__(56);

__webpack_require__(15);

var RegisterHtmlTemplate = __webpack_require__(2);

RegisterHtmlTemplate.register("<dom-module id=app-drawer-layout> <template> <style>:host{display:block;position:relative;z-index:0}:host ::slotted([slot=drawer]){z-index:1}:host([fullbleed]){@apply --layout-fit;}#contentContainer{position:relative;z-index:0;height:100%;transition:var(--app-drawer-layout-content-transition,none)}#contentContainer[drawer-position=left]{margin-left:var(--app-drawer-width,256px)}#contentContainer[drawer-position=right]{margin-right:var(--app-drawer-width,256px)}</style> <slot id=drawerSlot name=drawer></slot> <div id=contentContainer drawer-position$=[[_drawerPosition]]> <slot></slot> </div> <iron-media-query query=\"[[_computeMediaQuery(forceNarrow, responsiveWidth)]]\" on-query-matches-changed=_onQueryMatchesChanged></iron-media-query> </template> </dom-module>");

Polymer({
  is: 'app-drawer-layout',

  behaviors: [Polymer.AppLayoutBehavior],

  properties: {
    /**
     * If true, ignore `responsiveWidth` setting and force the narrow layout.
     */
    forceNarrow: {
      type: Boolean,
      value: false
    },

    /**
     * If the viewport's width is smaller than this value, the panel will change to narrow
     * layout. In the mode the drawer will be closed.
     */
    responsiveWidth: {
      type: String,
      value: '640px'
    },

    /**
     * Returns true if it is in narrow layout. This is useful if you need to show/hide
     * elements based on the layout.
     */
    narrow: {
      type: Boolean,
      reflectToAttribute: true,
      readOnly: true,
      notify: true
    },

    /**
     * If true, the drawer will initially be opened when in narrow layout mode.
     */
    openedWhenNarrow: {
      type: Boolean,
      value: false
    },

    _drawerPosition: {
      type: String
    }
  },

  listeners: {
    'click': '_clickHandler'
  },

  observers: ['_narrowChanged(narrow)'],

  /**
   * A reference to the app-drawer element.
   *
   * @property drawer
   */
  get drawer() {
    return Polymer.dom(this.$.drawerSlot).getDistributedNodes()[0];
  },

  attached: function attached() {
    // Disable drawer transitions until after app-drawer-layout sets the initial opened state.
    var drawer = this.drawer;
    if (drawer) {
      drawer.setAttribute('no-transition', '');
    }
  },

  _clickHandler: function _clickHandler(e) {
    var target = Polymer.dom(e).localTarget;
    if (target && target.hasAttribute('drawer-toggle')) {
      var drawer = this.drawer;
      if (drawer && !drawer.persistent) {
        drawer.toggle();
      }
    }
  },

  _updateLayoutStates: function _updateLayoutStates() {
    var drawer = this.drawer;
    if (!this.isAttached || !drawer) {
      return;
    }

    this._drawerPosition = this.narrow ? null : drawer.position;
    if (this._drawerNeedsReset) {
      if (this.narrow) {
        drawer.opened = this.openedWhenNarrow;
        drawer.persistent = false;
      } else {
        drawer.opened = drawer.persistent = true;
      }
      if (drawer.hasAttribute('no-transition')) {
        // Enable drawer transitions after app-drawer-layout sets the initial opened state.
        Polymer.RenderStatus.afterNextRender(this, function () {
          drawer.removeAttribute('no-transition');
        });
      }
      this._drawerNeedsReset = false;
    }
  },

  _narrowChanged: function _narrowChanged() {
    this._drawerNeedsReset = true;
    this.resetLayout();
  },

  _onQueryMatchesChanged: function _onQueryMatchesChanged(event) {
    this._setNarrow(event.detail.value);
  },

  _computeMediaQuery: function _computeMediaQuery(forceNarrow, responsiveWidth) {
    return forceNarrow ? '(min-width: 0px)' : '(max-width: ' + responsiveWidth + ')';
  }
});

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

Polymer({

  is: 'iron-media-query',

  properties: {

    /**
     * The Boolean return value of the media query.
     */
    queryMatches: {
      type: Boolean,
      value: false,
      readOnly: true,
      notify: true
    },

    /**
     * The CSS media query to evaluate.
     */
    query: {
      type: String,
      observer: 'queryChanged'
    },

    /**
     * If true, the query attribute is assumed to be a complete media query
     * string rather than a single media feature.
     */
    full: {
      type: Boolean,
      value: false
    },

    /**
     * @type {function(MediaQueryList)}
     */
    _boundMQHandler: {
      value: function value() {
        return this.queryHandler.bind(this);
      }
    },

    /**
     * @type {MediaQueryList}
     */
    _mq: {
      value: null
    }
  },

  attached: function attached() {
    this.style.display = 'none';
    this.queryChanged();
  },

  detached: function detached() {
    this._remove();
  },

  _add: function _add() {
    if (this._mq) {
      this._mq.addListener(this._boundMQHandler);
    }
  },

  _remove: function _remove() {
    if (this._mq) {
      this._mq.removeListener(this._boundMQHandler);
    }
    this._mq = null;
  },

  queryChanged: function queryChanged() {
    this._remove();
    var query = this.query;
    if (!query) {
      return;
    }
    if (!this.full && query[0] !== '(') {
      query = '(' + query + ')';
    }
    this._mq = window.matchMedia(query);
    this._add();
    this.queryHandler(this._mq);
  },

  queryHandler: function queryHandler(mq) {
    this._setQueryMatches(mq.matches);
  }

});

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

__webpack_require__(5);

__webpack_require__(4);

__webpack_require__(15);

var RegisterHtmlTemplate = __webpack_require__(2);

RegisterHtmlTemplate.register("<dom-module id=app-header> <template> <style>:host{position:relative;display:block;transition-timing-function:linear;transition-property:-webkit-transform;transition-property:transform}:host::before{position:absolute;right:0;bottom:-5px;left:0;width:100%;height:5px;content:\"\";transition:opacity .4s;pointer-events:none;opacity:0;box-shadow:inset 0 5px 6px -3px rgba(0,0,0,.4);will-change:opacity;@apply --app-header-shadow;}:host([shadow])::before{opacity:1}#background{@apply --layout-fit;overflow:hidden}#backgroundFrontLayer,#backgroundRearLayer{@apply --layout-fit;height:100%;pointer-events:none;background-size:cover}#backgroundFrontLayer{@apply --app-header-background-front-layer;}#backgroundRearLayer{opacity:0;@apply --app-header-background-rear-layer;}#contentContainer{position:relative;width:100%;height:100%}:host([disabled]),:host([disabled]) #backgroundFrontLayer,:host([disabled]) #backgroundRearLayer,:host([disabled])::after,:host([silent-scroll]),:host([silent-scroll]) #backgroundFrontLayer,:host([silent-scroll]) #backgroundRearLayer,:host([silent-scroll])::after{transition:none!important}:host([disabled]) ::slotted([sticky]),:host([disabled]) ::slotted(app-toolbar:first-of-type),:host([silent-scroll]) ::slotted([sticky]),:host([silent-scroll]) ::slotted(app-toolbar:first-of-type){transition:none!important}</style> <div id=contentContainer> <slot id=slot></slot> </div> </template> </dom-module>");

Polymer({
  is: 'app-header',

  behaviors: [Polymer.AppScrollEffectsBehavior, Polymer.AppLayoutBehavior],

  properties: {
    /**
     * If true, the header will automatically collapse when scrolling down.
     * That is, the `sticky` element remains visible when the header is fully condensed
     * whereas the rest of the elements will collapse below `sticky` element.
     *
     * By default, the `sticky` element is the first toolbar in the light DOM:
     *
     *```html
     * <app-header condenses>
     *   <app-toolbar>This toolbar remains on top</app-toolbar>
     *   <app-toolbar></app-toolbar>
     *   <app-toolbar></app-toolbar>
     * </app-header>
     * ```
     *
     * Additionally, you can specify which toolbar or element remains visible in condensed mode
     * by adding the `sticky` attribute to that element. For example: if we want the last
     * toolbar to remain visible, we can add the `sticky` attribute to it.
     *
     *```html
     * <app-header condenses>
     *   <app-toolbar></app-toolbar>
     *   <app-toolbar></app-toolbar>
     *   <app-toolbar sticky>This toolbar remains on top</app-toolbar>
     * </app-header>
     * ```
     *
     * Note the `sticky` element must be a direct child of `app-header`.
     */
    condenses: {
      type: Boolean,
      value: false
    },

    /**
     * Mantains the header fixed at the top so it never moves away.
     */
    fixed: {
      type: Boolean,
      value: false
    },

    /**
     * Slides back the header when scrolling back up.
     */
    reveals: {
      type: Boolean,
      value: false
    },

    /**
     * Displays a shadow below the header.
     */
    shadow: {
      type: Boolean,
      reflectToAttribute: true,
      value: false
    }
  },

  observers: ['_configChanged(isAttached, condenses, fixed)'],

  /**
   * A cached offsetHeight of the current element.
   *
   * @type {number}
   */
  _height: 0,

  /**
   * The distance in pixels the header will be translated to when scrolling.
   *
   * @type {number}
   */
  _dHeight: 0,

  /**
   * The offsetTop of `_stickyEl`
   *
   * @type {number}
   */
  _stickyElTop: 0,

  /**
   * A reference to the element that remains visible when the header condenses.
   *
   * @type {HTMLElement}
   */
  _stickyElRef: null,

  /**
   * The header's top value used for the `transformY`
   *
   * @type {number}
   */
  _top: 0,

  /**
   * The current scroll progress.
   *
   * @type {number}
   */
  _progress: 0,

  _wasScrollingDown: false,
  _initScrollTop: 0,
  _initTimestamp: 0,
  _lastTimestamp: 0,
  _lastScrollTop: 0,

  /**
   * The distance the header is allowed to move away.
   *
   * @type {number}
   */
  get _maxHeaderTop() {
    return this.fixed ? this._dHeight : this._height + 5;
  },

  /**
   * Returns a reference to the sticky element.
   *
   * @return {HTMLElement}?
   */
  get _stickyEl() {
    if (this._stickyElRef) {
      return this._stickyElRef;
    }
    var nodes = Polymer.dom(this.$.slot).getDistributedNodes();
    // Get the element with the sticky attribute on it or the first element in the light DOM.
    for (var i = 0, node; node = nodes[i]; i++) {
      if (node.nodeType === Node.ELEMENT_NODE) {
        if (node.hasAttribute('sticky')) {
          this._stickyElRef = node;
          break;
        } else if (!this._stickyElRef) {
          this._stickyElRef = node;
        }
      }
    }
    return this._stickyElRef;
  },

  _configChanged: function _configChanged() {
    this.resetLayout();
    this._notifyLayoutChanged();
  },

  _updateLayoutStates: function _updateLayoutStates() {
    if (this.offsetWidth === 0 && this.offsetHeight === 0) {
      return;
    }
    var scrollTop = this._clampedScrollTop;
    var firstSetup = this._height === 0 || scrollTop === 0;
    var currentDisabled = this.disabled;
    this._height = this.offsetHeight;
    this._stickyElRef = null;
    this.disabled = true;
    // prepare for measurement
    if (!firstSetup) {
      this._updateScrollState(0, true);
    }
    if (this._mayMove()) {
      this._dHeight = this._stickyEl ? this._height - this._stickyEl.offsetHeight : 0;
    } else {
      this._dHeight = 0;
    }
    this._stickyElTop = this._stickyEl ? this._stickyEl.offsetTop : 0;
    this._setUpEffect();
    if (firstSetup) {
      this._updateScrollState(scrollTop, true);
    } else {
      this._updateScrollState(this._lastScrollTop, true);
      this._layoutIfDirty();
    }
    // restore no transition
    this.disabled = currentDisabled;
  },

  /**
   * Updates the scroll state.
   *
   * @param {number} scrollTop
   * @param {boolean=} forceUpdate (default: false)
   */
  _updateScrollState: function _updateScrollState(scrollTop, forceUpdate) {
    if (this._height === 0) {
      return;
    }
    var progress = 0;
    var top = 0;
    var lastTop = this._top;
    var lastScrollTop = this._lastScrollTop;
    var maxHeaderTop = this._maxHeaderTop;
    var dScrollTop = scrollTop - this._lastScrollTop;
    var absDScrollTop = Math.abs(dScrollTop);
    var isScrollingDown = scrollTop > this._lastScrollTop;
    var now = performance.now();

    if (this._mayMove()) {
      top = this._clamp(this.reveals ? lastTop + dScrollTop : scrollTop, 0, maxHeaderTop);
    }
    if (scrollTop >= this._dHeight) {
      top = this.condenses && !this.fixed ? Math.max(this._dHeight, top) : top;
      this.style.transitionDuration = '0ms';
    }
    if (this.reveals && !this.disabled && absDScrollTop < 100) {
      // set the initial scroll position
      if (now - this._initTimestamp > 300 || this._wasScrollingDown !== isScrollingDown) {
        this._initScrollTop = scrollTop;
        this._initTimestamp = now;
      }
      if (scrollTop >= maxHeaderTop) {
        // check if the header is allowed to snap
        if (Math.abs(this._initScrollTop - scrollTop) > 30 || absDScrollTop > 10) {
          if (isScrollingDown && scrollTop >= maxHeaderTop) {
            top = maxHeaderTop;
          } else if (!isScrollingDown && scrollTop >= this._dHeight) {
            top = this.condenses && !this.fixed ? this._dHeight : 0;
          }
          var scrollVelocity = dScrollTop / (now - this._lastTimestamp);
          this.style.transitionDuration = this._clamp((top - lastTop) / scrollVelocity, 0, 300) + 'ms';
        } else {
          top = this._top;
        }
      }
    }
    if (this._dHeight === 0) {
      progress = scrollTop > 0 ? 1 : 0;
    } else {
      progress = top / this._dHeight;
    }
    if (!forceUpdate) {
      this._lastScrollTop = scrollTop;
      this._top = top;
      this._wasScrollingDown = isScrollingDown;
      this._lastTimestamp = now;
    }
    if (forceUpdate || progress !== this._progress || lastTop !== top || scrollTop === 0) {
      this._progress = progress;
      this._runEffects(progress, top);
      this._transformHeader(top);
    }
  },

  /**
   * Returns true if the current header is allowed to move as the user scrolls.
   *
   * @return {boolean}
   */
  _mayMove: function _mayMove() {
    return this.condenses || !this.fixed;
  },

  /**
   * Returns true if the current header will condense based on the size of the header
   * and the `consenses` property.
   *
   * @return {boolean}
   */
  willCondense: function willCondense() {
    return this._dHeight > 0 && this.condenses;
  },

  /**
   * Returns true if the current element is on the screen.
   * That is, visible in the current viewport.
   *
   * @method isOnScreen
   * @return {boolean}
   */
  isOnScreen: function isOnScreen() {
    return this._height !== 0 && this._top < this._height;
  },

  /**
   * Returns true if there's content below the current element.
   *
   * @method isContentBelow
   * @return {boolean}
   */
  isContentBelow: function isContentBelow() {
    return this._top === 0 ? this._clampedScrollTop > 0 : this._clampedScrollTop - this._maxHeaderTop >= 0;
  },

  /**
   * Transforms the header.
   *
   * @param {number} y
   */
  _transformHeader: function _transformHeader(y) {
    this.translate3d(0, -y + 'px', 0);
    if (this._stickyEl) {
      this.translate3d(0, this.condenses && y >= this._stickyElTop ? Math.min(y, this._dHeight) - this._stickyElTop + 'px' : 0, 0, this._stickyEl);
    }
  },

  _clamp: function _clamp(v, min, max) {
    return Math.min(max, Math.max(min, v));
  },

  _ensureBgContainers: function _ensureBgContainers() {
    if (!this._bgContainer) {
      this._bgContainer = document.createElement('div');
      this._bgContainer.id = 'background';
      this._bgRear = document.createElement('div');
      this._bgRear.id = 'backgroundRearLayer';
      this._bgContainer.appendChild(this._bgRear);
      this._bgFront = document.createElement('div');
      this._bgFront.id = 'backgroundFrontLayer';
      this._bgContainer.appendChild(this._bgFront);
      Polymer.dom(this.root).insertBefore(this._bgContainer, this.$.contentContainer);
    }
  },

  _getDOMRef: function _getDOMRef(id) {
    switch (id) {
      case 'backgroundFrontLayer':
        this._ensureBgContainers();
        return this._bgFront;
      case 'backgroundRearLayer':
        this._ensureBgContainers();
        return this._bgRear;
      case 'background':
        this._ensureBgContainers();
        return this._bgContainer;
      case 'mainTitle':
        return Polymer.dom(this).querySelector('[main-title]');
      case 'condensedTitle':
        return Polymer.dom(this).querySelector('[condensed-title]');
    }
    return null;
  },

  /**
   * Returns an object containing the progress value of the scroll effects
   * and the top position of the header.
   *
   * @method getScrollState
   * @return {Object}
   */
  getScrollState: function getScrollState() {
    return { progress: this._progress, top: this._top };
  }
});

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

/**
 * `Polymer.IronScrollTargetBehavior` allows an element to respond to scroll events from a
 * designated scroll target.
 *
 * Elements that consume this behavior can override the `_scrollHandler`
 * method to add logic on the scroll event.
 *
 * @demo demo/scrolling-region.html Scrolling Region
 * @demo demo/document.html Document Element
 * @polymerBehavior
 */
Polymer.IronScrollTargetBehavior = {

  properties: {

    /**
     * Specifies the element that will handle the scroll event
     * on the behalf of the current element. This is typically a reference to an element,
     * but there are a few more posibilities:
     *
     * ### Elements id
     *
     *```html
     * <div id="scrollable-element" style="overflow: auto;">
     *  <x-element scroll-target="scrollable-element">
     *    <!-- Content-->
     *  </x-element>
     * </div>
     *```
     * In this case, the `scrollTarget` will point to the outer div element.
     *
     * ### Document scrolling
     *
     * For document scrolling, you can use the reserved word `document`:
     *
     *```html
     * <x-element scroll-target="document">
     *   <!-- Content -->
     * </x-element>
     *```
     *
     * ### Elements reference
     *
     *```js
     * appHeader.scrollTarget = document.querySelector('#scrollable-element');
     *```
     *
     * @type {HTMLElement}
     * @default document
     */
    scrollTarget: {
      type: HTMLElement,
      value: function value() {
        return this._defaultScrollTarget;
      }
    }
  },

  observers: ['_scrollTargetChanged(scrollTarget, isAttached)'],

  /**
   * True if the event listener should be installed.
   */
  _shouldHaveListener: true,

  _scrollTargetChanged: function _scrollTargetChanged(scrollTarget, isAttached) {
    var eventTarget;

    if (this._oldScrollTarget) {
      this._toggleScrollListener(false, this._oldScrollTarget);
      this._oldScrollTarget = null;
    }
    if (!isAttached) {
      return;
    }
    // Support element id references
    if (scrollTarget === 'document') {

      this.scrollTarget = this._doc;
    } else if (typeof scrollTarget === 'string') {

      var domHost = this.domHost;

      this.scrollTarget = domHost && domHost.$ ? domHost.$[scrollTarget] : Polymer.dom(this.ownerDocument).querySelector('#' + scrollTarget);
    } else if (this._isValidScrollTarget()) {

      this._oldScrollTarget = scrollTarget;
      this._toggleScrollListener(this._shouldHaveListener, scrollTarget);
    }
  },

  /**
   * Runs on every scroll event. Consumer of this behavior may override this method.
   *
   * @protected
   */
  _scrollHandler: function scrollHandler() {},

  /**
   * The default scroll target. Consumers of this behavior may want to customize
   * the default scroll target.
   *
   * @type {Element}
   */
  get _defaultScrollTarget() {
    return this._doc;
  },

  /**
   * Shortcut for the document element
   *
   * @type {Element}
   */
  get _doc() {
    return this.ownerDocument.documentElement;
  },

  /**
   * Gets the number of pixels that the content of an element is scrolled upward.
   *
   * @type {number}
   */
  get _scrollTop() {
    if (this._isValidScrollTarget()) {
      return this.scrollTarget === this._doc ? window.pageYOffset : this.scrollTarget.scrollTop;
    }
    return 0;
  },

  /**
   * Gets the number of pixels that the content of an element is scrolled to the left.
   *
   * @type {number}
   */
  get _scrollLeft() {
    if (this._isValidScrollTarget()) {
      return this.scrollTarget === this._doc ? window.pageXOffset : this.scrollTarget.scrollLeft;
    }
    return 0;
  },

  /**
   * Sets the number of pixels that the content of an element is scrolled upward.
   *
   * @type {number}
   */
  set _scrollTop(top) {
    if (this.scrollTarget === this._doc) {
      window.scrollTo(window.pageXOffset, top);
    } else if (this._isValidScrollTarget()) {
      this.scrollTarget.scrollTop = top;
    }
  },

  /**
   * Sets the number of pixels that the content of an element is scrolled to the left.
   *
   * @type {number}
   */
  set _scrollLeft(left) {
    if (this.scrollTarget === this._doc) {
      window.scrollTo(left, window.pageYOffset);
    } else if (this._isValidScrollTarget()) {
      this.scrollTarget.scrollLeft = left;
    }
  },

  /**
   * Scrolls the content to a particular place.
   *
   * @method scroll
   * @param {number} left The left position
   * @param {number} top The top position
   */
  scroll: function scroll(left, top) {
    if (this.scrollTarget === this._doc) {
      window.scrollTo(left, top);
    } else if (this._isValidScrollTarget()) {
      this.scrollTarget.scrollLeft = left;
      this.scrollTarget.scrollTop = top;
    }
  },

  /**
   * Gets the width of the scroll target.
   *
   * @type {number}
   */
  get _scrollTargetWidth() {
    if (this._isValidScrollTarget()) {
      return this.scrollTarget === this._doc ? window.innerWidth : this.scrollTarget.offsetWidth;
    }
    return 0;
  },

  /**
   * Gets the height of the scroll target.
   *
   * @type {number}
   */
  get _scrollTargetHeight() {
    if (this._isValidScrollTarget()) {
      return this.scrollTarget === this._doc ? window.innerHeight : this.scrollTarget.offsetHeight;
    }
    return 0;
  },

  /**
   * Returns true if the scroll target is a valid HTMLElement.
   *
   * @return {boolean}
   */
  _isValidScrollTarget: function _isValidScrollTarget() {
    return this.scrollTarget instanceof HTMLElement;
  },

  _toggleScrollListener: function _toggleScrollListener(yes, scrollTarget) {
    var eventTarget = scrollTarget === this._doc ? window : scrollTarget;
    if (yes) {
      if (!this._boundScrollHandler) {
        this._boundScrollHandler = this._scrollHandler.bind(this);
        eventTarget.addEventListener('scroll', this._boundScrollHandler);
      }
    } else {
      if (this._boundScrollHandler) {
        eventTarget.removeEventListener('scroll', this._boundScrollHandler);
        this._boundScrollHandler = null;
      }
    }
  },

  /**
   * Enables or disables the scroll event listener.
   *
   * @param {boolean} yes True to add the event, False to remove it.
   */
  toggleScrollListener: function toggleScrollListener(yes) {
    this._shouldHaveListener = yes;
    this._toggleScrollListener(yes, this.scrollTarget);
  }

};

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

Polymer.AppLayout = Polymer.AppLayout || {};

Polymer.AppLayout._scrollEffects = Polymer.AppLayout._scrollEffects || {};

Polymer.AppLayout.scrollTimingFunction = function easeOutQuad(t, b, c, d) {
  t /= d;
  return -c * t * (t - 2) + b;
};

/**
 * Registers a scroll effect to be used in elements that implement the
 * `Polymer.AppScrollEffectsBehavior` behavior.
 *
 * @param {string} effectName The effect name.
 * @param {Object} effectDef The effect definition.
 */
Polymer.AppLayout.registerEffect = function registerEffect(effectName, effectDef) {
  if (Polymer.AppLayout._scrollEffects[effectName] != null) {
    throw new Error('effect `' + effectName + '` is already registered.');
  }
  Polymer.AppLayout._scrollEffects[effectName] = effectDef;
};

Polymer.AppLayout.queryAllRoot = function (selector, root) {
  var queue = [root];
  var matches = [];

  while (queue.length > 0) {
    var node = queue.shift();
    matches.push.apply(matches, node.querySelectorAll(selector));
    for (i = 0; node.children[i]; i++) {
      if (node.children[i].shadowRoot) {
        queue.push(node.children[i].shadowRoot);
      }
    }
  }
  return matches;
};

/**
 * Scrolls to a particular set of coordinates in a scroll target.
 * If the scroll target is not defined, then it would use the main document as the target.
 *
 * To scroll in a smooth fashion, you can set the option `behavior: 'smooth'`. e.g.
 *
 * ```js
 * Polymer.AppLayout.scroll({top: 0, behavior: 'smooth'});
 * ```
 *
 * To scroll in a silent mode, without notifying scroll changes to any app-layout elements,
 * you can set the option `behavior: 'silent'`. This is particularly useful we you are using
 * `app-header` and you desire to scroll to the top of a scrolling region without running
 * scroll effects. e.g.
 *
 * ```js
 * Polymer.AppLayout.scroll({top: 0, behavior: 'silent'});
 * ```
 *
 * @param {Object} options {top: Number, left: Number, behavior: String(smooth | silent)}
 */
Polymer.AppLayout.scroll = function scroll(options) {
  options = options || {};

  var docEl = document.documentElement;
  var target = options.target || docEl;
  var hasNativeScrollBehavior = 'scrollBehavior' in target.style && target.scroll;
  var scrollClassName = 'app-layout-silent-scroll';
  var scrollTop = options.top || 0;
  var scrollLeft = options.left || 0;
  var scrollTo = target === docEl ? window.scrollTo : function scrollTo(scrollLeft, scrollTop) {
    target.scrollLeft = scrollLeft;
    target.scrollTop = scrollTop;
  };

  if (options.behavior === 'smooth') {

    if (hasNativeScrollBehavior) {

      target.scroll(options);
    } else {

      var timingFn = Polymer.AppLayout.scrollTimingFunction;
      var startTime = Date.now();
      var currentScrollTop = target === docEl ? window.pageYOffset : target.scrollTop;
      var currentScrollLeft = target === docEl ? window.pageXOffset : target.scrollLeft;
      var deltaScrollTop = scrollTop - currentScrollTop;
      var deltaScrollLeft = scrollLeft - currentScrollLeft;
      var duration = 300;
      var updateFrame = function updateFrame() {
        var now = Date.now();
        var elapsedTime = now - startTime;

        if (elapsedTime < duration) {
          scrollTo(timingFn(elapsedTime, currentScrollLeft, deltaScrollLeft, duration), timingFn(elapsedTime, currentScrollTop, deltaScrollTop, duration));
          requestAnimationFrame(updateFrame);
        } else {
          scrollTo(scrollLeft, scrollTop);
        }
      }.bind(this);

      updateFrame();
    }
  } else if (options.behavior === 'silent') {
    var headers = Polymer.AppLayout.queryAllRoot('app-header', document.body);

    headers.forEach(function (header) {
      header.setAttribute('silent-scroll', '');
    });

    // Browsers keep the scroll momentum even if the bottom of the scrolling content
    // was reached. This means that calling scroll({top: 0, behavior: 'silent'}) when
    // the momentum is still going will result in more scroll events and thus scroll effects.
    // This seems to only apply when using document scrolling.
    // Therefore, when should we remove the class from the document element?

    window.cancelAnimationFrame(Polymer.AppLayout._scrollTimer);

    Polymer.AppLayout._scrollTimer = window.requestAnimationFrame(function () {
      headers.forEach(function (header) {
        header.removeAttribute('silent-scroll');
      });
      Polymer.AppLayout._scrollTimer = null;
    });

    scrollTo(scrollLeft, scrollTop);
  } else {

    scrollTo(scrollLeft, scrollTop);
  }
};

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

__webpack_require__(5);

__webpack_require__(15);

var RegisterHtmlTemplate = __webpack_require__(2);

RegisterHtmlTemplate.register("<dom-module id=app-header-layout> <template> <style>:host{display:block;position:relative;z-index:0}#wrapper ::slotted([slot=header]){@apply --layout-fixed-top;z-index:1}#wrapper.initializing ::slotted([slot=header]){position:relative}:host([has-scrolling-region]){height:100%}:host([has-scrolling-region]) #wrapper ::slotted([slot=header]){position:absolute}:host([has-scrolling-region]) #wrapper.initializing ::slotted([slot=header]){position:relative}:host([has-scrolling-region]) #wrapper #contentContainer{@apply --layout-fit;overflow-y:auto;-webkit-overflow-scrolling:touch}:host([has-scrolling-region]) #wrapper.initializing #contentContainer{position:relative}:host([fullbleed]){@apply --layout-vertical;@apply --layout-fit;}:host([fullbleed]) #wrapper,:host([fullbleed]) #wrapper #contentContainer{@apply --layout-vertical;@apply --layout-flex;}#contentContainer{position:relative;z-index:0}</style> <div id=wrapper class=initializing> <slot id=headerSlot name=header></slot> <div id=contentContainer> <slot></slot> </div> </div> </template> </dom-module>");

Polymer({
  is: 'app-header-layout',

  behaviors: [Polymer.AppLayoutBehavior],

  properties: {
    /**
     * If true, the current element will have its own scrolling region.
     * Otherwise, it will use the document scroll to control the header.
     */
    hasScrollingRegion: {
      type: Boolean,
      value: false,
      reflectToAttribute: true
    }
  },

  observers: ['resetLayout(isAttached, hasScrollingRegion)'],

  /**
   * A reference to the app-header element.
   *
   * @property header
   */
  get header() {
    return Polymer.dom(this.$.headerSlot).getDistributedNodes()[0];
  },

  _updateLayoutStates: function _updateLayoutStates() {
    var header = this.header;
    if (!this.isAttached || !header) {
      return;
    }
    // Remove the initializing class, which staticly positions the header and the content
    // until the height of the header can be read.
    this.$.wrapper.classList.remove('initializing');
    // Update scroll target.
    header.scrollTarget = this.hasScrollingRegion ? this.$.contentContainer : this.ownerDocument.documentElement;
    // Get header height here so that style reads are batched together before style writes
    // (i.e. getBoundingClientRect() below).
    var headerHeight = header.offsetHeight;
    // Update the header position.
    if (!this.hasScrollingRegion) {
      requestAnimationFrame(function () {
        var rect = this.getBoundingClientRect();
        var rightOffset = document.documentElement.clientWidth - rect.right;
        header.style.left = rect.left + 'px';
        header.style.right = rightOffset + 'px';
      }.bind(this));
    } else {
      header.style.left = '';
      header.style.right = '';
    }
    // Update the content container position.
    var containerStyle = this.$.contentContainer.style;
    if (header.fixed && !header.condenses && this.hasScrollingRegion) {
      // If the header size does not change and we're using a scrolling region, exclude
      // the header area from the scrolling region so that the header doesn't overlap
      // the scrollbar.
      containerStyle.marginTop = headerHeight + 'px';
      containerStyle.paddingTop = '';
    } else {
      containerStyle.paddingTop = headerHeight + 'px';
      containerStyle.marginTop = '';
    }
  }

});

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(23);

__webpack_require__(62);

__webpack_require__(63);

__webpack_require__(26);

__webpack_require__(64);

__webpack_require__(25);

__webpack_require__(24);

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(4);

/**
 * Upon scrolling past a threshold, fade in the rear background layer and fade out the front
 * background layer (opacity CSS transitioned over time).
 *
 *
 */
Polymer.AppLayout.registerEffect('fade-background', {
  /** @this Polymer.AppLayout.ElementWithBackground */
  setUp: function setUp(config) {
    var fx = {};
    var duration = config.duration || '0.5s';
    fx.backgroundFrontLayer = this._getDOMRef('backgroundFrontLayer');
    fx.backgroundRearLayer = this._getDOMRef('backgroundRearLayer');
    fx.backgroundFrontLayer.style.willChange = 'opacity';
    fx.backgroundFrontLayer.style.webkitTransform = 'translateZ(0)';
    fx.backgroundFrontLayer.style.transitionProperty = 'opacity';
    fx.backgroundFrontLayer.style.transitionDuration = duration;
    fx.backgroundRearLayer.style.willChange = 'opacity';
    fx.backgroundRearLayer.style.webkitTransform = 'translateZ(0)';
    fx.backgroundRearLayer.style.transitionProperty = 'opacity';
    fx.backgroundRearLayer.style.transitionDuration = duration;
    this._fxFadeBackground = fx;
  },
  /** @this Polymer.AppLayout.ElementWithBackground */
  run: function run(p, y) {
    var fx = this._fxFadeBackground;
    if (p >= 1) {
      fx.backgroundFrontLayer.style.opacity = 0;
      fx.backgroundRearLayer.style.opacity = 1;
    } else {
      fx.backgroundFrontLayer.style.opacity = 1;
      fx.backgroundRearLayer.style.opacity = 0;
    }
  },
  /** @this Polymer.AppLayout.ElementWithBackground */
  tearDown: function tearDown() {
    delete this._fxFadeBackground;
  }
});

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(4);

__webpack_require__(24);

__webpack_require__(25);

__webpack_require__(23);

__webpack_require__(26);

/**
 * Shorthand for the waterfall, resize-title, blend-background, and parallax-background effects.
 */
Polymer.AppLayout.registerEffect('material', {
  /**
   * @this Polymer.AppLayout.ElementWithBackground
   */
  setUp: function setUp() {
    this.effects = 'waterfall resize-title blend-background parallax-background';
    return false;
  }
});

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(4);

/**
 * Upon scrolling past a threshold, CSS transition the font size of a designated title element
 * between two values.
 */
Polymer.AppLayout.registerEffect('resize-snapped-title', {
  /**
   * @this Polymer.AppLayout.ElementWithBackground
   */
  setUp: function setUp(config) {
    var title = this._getDOMRef('mainTitle');
    var condensedTitle = this._getDOMRef('condensedTitle');
    var duration = config.duration || '0.2s';
    var fx = {};

    if (!condensedTitle) {
      console.warn('Scroll effect `resize-snapped-title`: undefined `condensed-title`');
      return false;
    }
    if (!title) {
      console.warn('Scroll effect `resize-snapped-title`: undefined `main-title`');
      return false;
    }

    title.style.transitionProperty = 'opacity';
    title.style.transitionDuration = duration;
    condensedTitle.style.transitionProperty = 'opacity';
    condensedTitle.style.transitionDuration = duration;
    fx.condensedTitle = condensedTitle;
    fx.title = title;
    this._fxResizeSnappedTitle = fx;
  },
  /** @this Polymer.AppLayout.ElementWithBackground */
  run: function run(p, y) {
    var fx = this._fxResizeSnappedTitle;
    if (p > 0) {
      fx.title.style.opacity = 0;
      fx.condensedTitle.style.opacity = 1;
    } else {
      fx.title.style.opacity = 1;
      fx.condensedTitle.style.opacity = 0;
    }
  },
  /** @this Polymer.AppLayout.ElementWithBackground */
  tearDown: function tearDown() {
    var fx = this._fxResizeSnappedTitle;
    fx.title.style.transition = '';
    fx.condensedTitle.style.transition = '';
    delete this._fxResizeSnappedTitle;
  }
});

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

__webpack_require__(5);

var RegisterHtmlTemplate = __webpack_require__(2);

RegisterHtmlTemplate.register("<dom-module id=app-toolbar> <template> <style>:host{@apply --layout-horizontal;@apply --layout-center;position:relative;height:64px;padding:0 16px;pointer-events:none;font-size:var(--app-toolbar-font-size,20px)}:host ::slotted(*){pointer-events:auto}:host ::slotted(paper-icon-button){font-size:0}:host ::slotted([condensed-title]),:host ::slotted([main-title]){pointer-events:none;@apply --layout-flex;}:host ::slotted([bottom-item]){position:absolute;right:0;bottom:0;left:0}:host ::slotted([top-item]){position:absolute;top:0;right:0;left:0}:host ::slotted([spacer]){margin-left:64px}</style> <slot></slot> </template> </dom-module>");

Polymer({
  is: 'app-toolbar'
});

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

__webpack_require__(67);

__webpack_require__(68);

__webpack_require__(69);

var RegisterHtmlTemplate = __webpack_require__(2);

RegisterHtmlTemplate.register("<dom-module id=app-location> <template> <iron-query-params params-string={{__query}} params-object={{queryParams}}> </iron-query-params> <iron-location path={{__path}} query={{__query}} hash={{__hash}} url-space-regex={{urlSpaceRegex}}> </iron-location> </template> </dom-module>");

(function () {
  'use strict';

  Polymer({
    is: 'app-location',

    properties: {
      /**
       * A model representing the deserialized path through the route tree, as
       * well as the current queryParams.
       */
      route: {
        type: Object,
        notify: true
      },

      /**
       * In many scenarios, it is convenient to treat the `hash` as a stand-in
       * alternative to the `path`. For example, if deploying an app to a static
       * web server (e.g., Github Pages) - where one does not have control over
       * server-side routing - it is usually a better experience to use the hash
       * to represent paths through one's app.
       *
       * When this property is set to true, the `hash` will be used in place of
        * the `path` for generating a `route`.
       */
      useHashAsPath: {
        type: Boolean,
        value: false
      },

      /**
       * A regexp that defines the set of URLs that should be considered part
       * of this web app.
       *
       * Clicking on a link that matches this regex won't result in a full page
       * navigation, but will instead just update the URL state in place.
       *
       * This regexp is given everything after the origin in an absolute
       * URL. So to match just URLs that start with /search/ do:
       *     url-space-regex="^/search/"
       *
       * @type {string|RegExp}
       */
      urlSpaceRegex: {
        type: String,
        notify: true
      },

      /**
       * A set of key/value pairs that are universally accessible to branches
       * of the route tree.
       */
      __queryParams: {
        type: Object
      },

      /**
       * The pathname component of the current URL.
       */
      __path: {
        type: String
      },

      /**
       * The query string portion of the current URL.
       */
      __query: {
        type: String
      },

      /**
       * The hash portion of the current URL.
       */
      __hash: {
        type: String
      },

      /**
       * The route path, which will be either the hash or the path, depending
       * on useHashAsPath.
       */
      path: {
        type: String,
        observer: '__onPathChanged'
      },

      /**
       * Whether or not the ready function has been called.
       */
      _isReady: {
        type: Boolean
      }
    },

    behaviors: [Polymer.AppRouteConverterBehavior],

    observers: ['__computeRoutePath(useHashAsPath, __hash, __path)'],

    ready: function ready() {
      this._isReady = true;
    },

    __computeRoutePath: function __computeRoutePath() {
      this.path = this.useHashAsPath ? this.__hash : this.__path;
    },

    __onPathChanged: function __onPathChanged() {
      if (!this._isReady) {
        return;
      }

      if (this.useHashAsPath) {
        this.__hash = this.path;
      } else {
        this.__path = this.path;
      }
    }
  });
})();

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

(function () {
  'use strict';

  var workingURL;

  var urlDoc, urlBase, anchor;

  /**
   * @param {string} path
   * @param {string=} base
   * @return {!URL|!HTMLAnchorElement}
   */
  function resolveURL(path, base) {
    if (workingURL === undefined) {
      workingURL = false;
      try {
        var u = new URL('b', 'http://a');
        u.pathname = 'c%20d';
        workingURL = u.href === 'http://a/c%20d';
        workingURL = workingURL && new URL('http://www.google.com/?foo bar').href === 'http://www.google.com/?foo%20bar';
      } catch (e) {}
    }
    if (workingURL) {
      return new URL(path, base);
    }
    if (!urlDoc) {
      urlDoc = document.implementation.createHTMLDocument('url');
      urlBase = urlDoc.createElement('base');
      urlDoc.head.appendChild(urlBase);
      anchor = /** @type {HTMLAnchorElement}*/urlDoc.createElement('a');
    }
    urlBase.href = base;
    anchor.href = path.replace(/ /g, '%20');
    return anchor;
  }

  Polymer({
    is: 'iron-location',

    properties: {
      /**
       * The pathname component of the URL.
       */
      path: {
        type: String,
        notify: true,
        value: function value() {
          return window.decodeURIComponent(window.location.pathname);
        }
      },

      /**
       * The query string portion of the URL.
       */
      query: {
        type: String,
        notify: true,
        value: function value() {
          return window.location.search.slice(1);
        }
      },

      /**
       * The hash component of the URL.
       */
      hash: {
        type: String,
        notify: true,
        value: function value() {
          return window.decodeURIComponent(window.location.hash.slice(1));
        }
      },

      /**
       * If the user was on a URL for less than `dwellTime` milliseconds, it
       * won't be added to the browser's history, but instead will be replaced
       * by the next entry.
       *
       * This is to prevent large numbers of entries from clogging up the user's
       * browser history. Disable by setting to a negative number.
       */
      dwellTime: {
        type: Number,
        value: 2000
      },

      /**
       * A regexp that defines the set of URLs that should be considered part
       * of this web app.
       *
       * Clicking on a link that matches this regex won't result in a full page
       * navigation, but will instead just update the URL state in place.
       *
       * This regexp is given everything after the origin in an absolute
       * URL. So to match just URLs that start with /search/ do:
       *     url-space-regex="^/search/"
       *
       * @type {string|RegExp}
       */
      urlSpaceRegex: {
        type: String,
        value: ''
      },

      /**
       * urlSpaceRegex, but coerced into a regexp.
       *
       * @type {RegExp}
       */
      _urlSpaceRegExp: {
        computed: '_makeRegExp(urlSpaceRegex)'
      },

      _lastChangedAt: {
        type: Number
      },

      _initialized: {
        type: Boolean,
        value: false
      }
    },

    hostAttributes: {
      hidden: true
    },

    observers: ['_updateUrl(path, query, hash)'],

    attached: function attached() {
      this.listen(window, 'hashchange', '_hashChanged');
      this.listen(window, 'location-changed', '_urlChanged');
      this.listen(window, 'popstate', '_urlChanged');
      this.listen( /** @type {!HTMLBodyElement} */document.body, 'click', '_globalOnClick');
      // Give a 200ms grace period to make initial redirects without any
      // additions to the user's history.
      this._lastChangedAt = window.performance.now() - (this.dwellTime - 200);
      this._initialized = true;

      this._urlChanged();
    },

    detached: function detached() {
      this.unlisten(window, 'hashchange', '_hashChanged');
      this.unlisten(window, 'location-changed', '_urlChanged');
      this.unlisten(window, 'popstate', '_urlChanged');
      this.unlisten( /** @type {!HTMLBodyElement} */document.body, 'click', '_globalOnClick');
      this._initialized = false;
    },

    _hashChanged: function _hashChanged() {
      this.hash = window.decodeURIComponent(window.location.hash.substring(1));
    },

    _urlChanged: function _urlChanged() {
      // We want to extract all info out of the updated URL before we
      // try to write anything back into it.
      //
      // i.e. without _dontUpdateUrl we'd overwrite the new path with the old
      // one when we set this.hash. Likewise for query.
      this._dontUpdateUrl = true;
      this._hashChanged();
      this.path = window.decodeURIComponent(window.location.pathname);
      this.query = window.location.search.substring(1);
      this._dontUpdateUrl = false;
      this._updateUrl();
    },

    _getUrl: function _getUrl() {
      var partiallyEncodedPath = window.encodeURI(this.path).replace(/\#/g, '%23').replace(/\?/g, '%3F');
      var partiallyEncodedQuery = '';
      if (this.query) {
        partiallyEncodedQuery = '?' + this.query.replace(/\#/g, '%23');
      }
      var partiallyEncodedHash = '';
      if (this.hash) {
        partiallyEncodedHash = '#' + window.encodeURI(this.hash);
      }
      return partiallyEncodedPath + partiallyEncodedQuery + partiallyEncodedHash;
    },

    _updateUrl: function _updateUrl() {
      if (this._dontUpdateUrl || !this._initialized) {
        return;
      }

      if (this.path === window.decodeURIComponent(window.location.pathname) && this.query === window.location.search.substring(1) && this.hash === window.decodeURIComponent(window.location.hash.substring(1))) {
        // Nothing to do, the current URL is a representation of our properties.
        return;
      }

      var newUrl = this._getUrl();
      // Need to use a full URL in case the containing page has a base URI.
      var fullNewUrl = resolveURL(newUrl, window.location.protocol + '//' + window.location.host).href;
      var now = window.performance.now();
      var shouldReplace = this._lastChangedAt + this.dwellTime > now;
      this._lastChangedAt = now;

      if (shouldReplace) {
        window.history.replaceState({}, '', fullNewUrl);
      } else {
        window.history.pushState({}, '', fullNewUrl);
      }

      this.fire('location-changed', {}, { node: window });
    },

    /**
     * A necessary evil so that links work as expected. Does its best to
     * bail out early if possible.
     *
     * @param {MouseEvent} event .
     */
    _globalOnClick: function _globalOnClick(event) {
      // If another event handler has stopped this event then there's nothing
      // for us to do. This can happen e.g. when there are multiple
      // iron-location elements in a page.
      if (event.defaultPrevented) {
        return;
      }

      var href = this._getSameOriginLinkHref(event);

      if (!href) {
        return;
      }

      event.preventDefault();

      // If the navigation is to the current page we shouldn't add a history
      // entry or fire a change event.
      if (href === window.location.href) {
        return;
      }

      window.history.pushState({}, '', href);
      this.fire('location-changed', {}, { node: window });
    },

    /**
     * Returns the absolute URL of the link (if any) that this click event
     * is clicking on, if we can and should override the resulting full
     * page navigation. Returns null otherwise.
     *
     * @param {MouseEvent} event .
     * @return {string?} .
     */
    _getSameOriginLinkHref: function _getSameOriginLinkHref(event) {
      // We only care about left-clicks.
      if (event.button !== 0) {
        return null;
      }

      // We don't want modified clicks, where the intent is to open the page
      // in a new tab.
      if (event.metaKey || event.ctrlKey) {
        return null;
      }

      var eventPath = Polymer.dom(event).path;
      var anchor = null;

      for (var i = 0; i < eventPath.length; i++) {
        var element = eventPath[i];

        if (element.tagName === 'A' && element.href) {
          anchor = element;
          break;
        }
      }

      // If there's no link there's nothing to do.
      if (!anchor) {
        return null;
      }

      // Target blank is a new tab, don't intercept.
      if (anchor.target === '_blank') {
        return null;
      }

      // If the link is for an existing parent frame, don't intercept.
      if ((anchor.target === '_top' || anchor.target === '_parent') && window.top !== window) {
        return null;
      }

      var href = anchor.href;

      // It only makes sense for us to intercept same-origin navigations.
      // pushState/replaceState don't work with cross-origin links.
      var url;

      if (document.baseURI != null) {
        url = resolveURL(href, /** @type {string} */document.baseURI);
      } else {
        url = resolveURL(href);
      }

      var origin;

      // IE Polyfill
      if (window.location.origin) {
        origin = window.location.origin;
      } else {
        origin = window.location.protocol + '//' + window.location.host;
      }

      var urlOrigin;

      if (url.origin) {
        urlOrigin = url.origin;
      } else {
        urlOrigin = url.protocol + '//' + url.host;
      }

      if (urlOrigin !== origin) {
        return null;
      }

      var normalizedHref = url.pathname + url.search + url.hash;

      // pathname should start with '/', but may not if `new URL` is not supported
      if (normalizedHref[0] !== '/') {
        normalizedHref = '/' + normalizedHref;
      }

      // If we've been configured not to handle this url... don't handle it!
      if (this._urlSpaceRegExp && !this._urlSpaceRegExp.test(normalizedHref)) {
        return null;
      }

      // Need to use a full URL in case the containing page has a base URI.
      var fullNormalizedHref = resolveURL(normalizedHref, window.location.href).href;
      return fullNormalizedHref;
    },

    _makeRegExp: function _makeRegExp(urlSpaceRegex) {
      return RegExp(urlSpaceRegex);
    }
  });
})();

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

'use strict';

Polymer({
  is: 'iron-query-params',

  properties: {
    paramsString: {
      type: String,
      notify: true,
      observer: 'paramsStringChanged'
    },

    paramsObject: {
      type: Object,
      notify: true,
      value: function value() {
        return {};
      }
    },

    _dontReact: {
      type: Boolean,
      value: false
    }
  },

  hostAttributes: {
    hidden: true
  },

  observers: ['paramsObjectChanged(paramsObject.*)'],

  paramsStringChanged: function paramsStringChanged() {
    this._dontReact = true;
    this.paramsObject = this._decodeParams(this.paramsString);
    this._dontReact = false;
  },

  paramsObjectChanged: function paramsObjectChanged() {
    if (this._dontReact) {
      return;
    }
    this.paramsString = this._encodeParams(this.paramsObject).replace(/%3F/g, '?').replace(/%2F/g, '/').replace(/'/g, '%27');
  },

  _encodeParams: function _encodeParams(params) {
    var encodedParams = [];

    for (var key in params) {
      var value = params[key];

      if (value === '') {
        encodedParams.push(encodeURIComponent(key));
      } else if (value) {
        encodedParams.push(encodeURIComponent(key) + '=' + encodeURIComponent(value.toString()));
      }
    }
    return encodedParams.join('&');
  },

  _decodeParams: function _decodeParams(paramString) {
    var params = {};
    // Work around a bug in decodeURIComponent where + is not
    // converted to spaces:
    paramString = (paramString || '').replace(/\+/g, '%20');
    var paramList = paramString.split('&');
    for (var i = 0; i < paramList.length; i++) {
      var param = paramList[i].split('=');
      if (param[0]) {
        params[decodeURIComponent(param[0])] = decodeURIComponent(param[1] || '');
      }
    }
    return params;
  }
});

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


(function () {
  'use strict';

  /**
   * Provides bidirectional mapping between `path` and `queryParams` and a
   * app-route compatible `route` object.
   *
   * For more information, see the docs for `app-route-converter`.
   *
   * @polymerBehavior
   */

  Polymer.AppRouteConverterBehavior = {
    properties: {
      /**
       * A model representing the deserialized path through the route tree, as
       * well as the current queryParams.
       *
       * A route object is the kernel of the routing system. It is intended to
       * be fed into consuming elements such as `app-route`.
       *
       * @type {?Object}
       */
      route: {
        type: Object,
        notify: true
      },

      /**
       * A set of key/value pairs that are universally accessible to branches of
       * the route tree.
       *
       * @type {?Object}
       */
      queryParams: {
        type: Object,
        notify: true
      },

      /**
       * The serialized path through the route tree. This corresponds to the
       * `window.location.pathname` value, and will update to reflect changes
       * to that value.
       */
      path: {
        type: String,
        notify: true
      }
    },

    observers: ['_locationChanged(path, queryParams)', '_routeChanged(route.prefix, route.path)', '_routeQueryParamsChanged(route.__queryParams)'],

    created: function created() {
      this.linkPaths('route.__queryParams', 'queryParams');
      this.linkPaths('queryParams', 'route.__queryParams');
    },

    /**
     * Handler called when the path or queryParams change.
     */
    _locationChanged: function _locationChanged() {
      if (this.route && this.route.path === this.path && this.queryParams === this.route.__queryParams) {
        return;
      }
      this.route = {
        prefix: '',
        path: this.path,
        __queryParams: this.queryParams
      };
    },

    /**
     * Handler called when the route prefix and route path change.
     */
    _routeChanged: function _routeChanged() {
      if (!this.route) {
        return;
      }

      this.path = this.route.prefix + this.route.path;
    },

    /**
     * Handler called when the route queryParams change.
     *
     * @param  {Object} queryParams A set of key/value pairs that are
     * universally accessible to branches of the route tree.
     */
    _routeQueryParamsChanged: function _routeQueryParamsChanged(queryParams) {
      if (!this.route) {
        return;
      }
      this.queryParams = queryParams;
    }
  };
})();

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

(function () {
  'use strict';

  Polymer({
    is: 'app-route',

    properties: {
      /**
       * The URL component managed by this element.
       */
      route: {
        type: Object,
        notify: true
      },

      /**
       * The pattern of slash-separated segments to match `route.path` against.
       *
       * For example the pattern "/foo" will match "/foo" or "/foo/bar"
       * but not "/foobar".
       *
       * Path segments like `/:named` are mapped to properties on the `data` object.
       */
      pattern: {
        type: String
      },

      /**
       * The parameterized values that are extracted from the route as
       * described by `pattern`.
       */
      data: {
        type: Object,
        value: function value() {
          return {};
        },
        notify: true
      },

      /**
       * @type {?Object}
       */
      queryParams: {
        type: Object,
        value: function value() {
          return {};
        },
        notify: true
      },

      /**
       * The part of `route.path` NOT consumed by `pattern`.
       */
      tail: {
        type: Object,
        value: function value() {
          return { path: null, prefix: null, __queryParams: null };
        },
        notify: true
      },

      /**
       * Whether the current route is active. True if `route.path` matches the
       * `pattern`, false otherwise.
       */
      active: {
        type: Boolean,
        notify: true,
        readOnly: true
      },

      _queryParamsUpdating: {
        type: Boolean,
        value: false
      },
      /**
       * @type {?string}
       */
      _matched: {
        type: String,
        value: ''
      }
    },

    observers: ['__tryToMatch(route.path, pattern)', '__updatePathOnDataChange(data.*)', '__tailPathChanged(tail.path)', '__routeQueryParamsChanged(route.__queryParams)', '__tailQueryParamsChanged(tail.__queryParams)', '__queryParamsChanged(queryParams.*)'],

    created: function created() {
      this.linkPaths('route.__queryParams', 'tail.__queryParams');
      this.linkPaths('tail.__queryParams', 'route.__queryParams');
    },

    /**
     * Deal with the query params object being assigned to wholesale.
     */
    __routeQueryParamsChanged: function __routeQueryParamsChanged(queryParams) {
      if (queryParams && this.tail) {
        if (this.tail.__queryParams !== queryParams) {
          this.set('tail.__queryParams', queryParams);
        }

        if (!this.active || this._queryParamsUpdating) {
          return;
        }

        // Copy queryParams and track whether there are any differences compared
        // to the existing query params.
        var copyOfQueryParams = {};
        var anythingChanged = false;
        for (var key in queryParams) {
          copyOfQueryParams[key] = queryParams[key];
          if (anythingChanged || !this.queryParams || queryParams[key] !== this.queryParams[key]) {
            anythingChanged = true;
          }
        }
        // Need to check whether any keys were deleted
        for (var key in this.queryParams) {
          if (anythingChanged || !(key in queryParams)) {
            anythingChanged = true;
            break;
          }
        }

        if (!anythingChanged) {
          return;
        }
        this._queryParamsUpdating = true;
        this.set('queryParams', copyOfQueryParams);
        this._queryParamsUpdating = false;
      }
    },

    __tailQueryParamsChanged: function __tailQueryParamsChanged(queryParams) {
      if (queryParams && this.route && this.route.__queryParams != queryParams) {
        this.set('route.__queryParams', queryParams);
      }
    },

    __queryParamsChanged: function __queryParamsChanged(changes) {
      if (!this.active || this._queryParamsUpdating) {
        return;
      }

      this.set('route.__' + changes.path, changes.value);
    },

    __resetProperties: function __resetProperties() {
      this._setActive(false);
      this._matched = null;
    },

    __tryToMatch: function __tryToMatch() {
      if (!this.route) {
        return;
      }

      var path = this.route.path;
      var pattern = this.pattern;

      if (!pattern) {
        return;
      }

      if (!path) {
        this.__resetProperties();
        return;
      }

      var remainingPieces = path.split('/');
      var patternPieces = pattern.split('/');

      var matched = [];
      var namedMatches = {};

      for (var i = 0; i < patternPieces.length; i++) {
        var patternPiece = patternPieces[i];
        if (!patternPiece && patternPiece !== '') {
          break;
        }
        var pathPiece = remainingPieces.shift();

        // We don't match this path.
        if (!pathPiece && pathPiece !== '') {
          this.__resetProperties();
          return;
        }
        matched.push(pathPiece);

        if (patternPiece.charAt(0) == ':') {
          namedMatches[patternPiece.slice(1)] = pathPiece;
        } else if (patternPiece !== pathPiece) {
          this.__resetProperties();
          return;
        }
      }

      this._matched = matched.join('/');

      // Properties that must be updated atomically.
      var propertyUpdates = {};

      //this.active
      if (!this.active) {
        propertyUpdates.active = true;
      }

      // this.tail
      var tailPrefix = this.route.prefix + this._matched;
      var tailPath = remainingPieces.join('/');
      if (remainingPieces.length > 0) {
        tailPath = '/' + tailPath;
      }
      if (!this.tail || this.tail.prefix !== tailPrefix || this.tail.path !== tailPath) {
        propertyUpdates.tail = {
          prefix: tailPrefix,
          path: tailPath,
          __queryParams: this.route.__queryParams
        };
      }

      // this.data
      propertyUpdates.data = namedMatches;
      this._dataInUrl = {};
      for (var key in namedMatches) {
        this._dataInUrl[key] = namedMatches[key];
      }

      if (this.setProperties) {
        if (!this.active) {
          this._setActive(true);
        }
        // atomic update
        this.setProperties(propertyUpdates);
      } else {
        this.__setMulti(propertyUpdates);
      }
    },

    __tailPathChanged: function __tailPathChanged(path) {
      if (!this.active) {
        return;
      }
      var tailPath = path;
      var newPath = this._matched;
      if (tailPath) {
        if (tailPath.charAt(0) !== '/') {
          tailPath = '/' + tailPath;
        }
        newPath += tailPath;
      }
      this.set('route.path', newPath);
    },

    __updatePathOnDataChange: function __updatePathOnDataChange() {
      if (!this.route || !this.active) {
        return;
      }
      var newPath = this.__getLink({});
      var oldPath = this.__getLink(this._dataInUrl);
      if (newPath === oldPath) {
        return;
      }
      this.set('route.path', newPath);
    },

    __getLink: function __getLink(overrideValues) {
      var values = { tail: null };
      for (var key in this.data) {
        values[key] = this.data[key];
      }
      for (var key in overrideValues) {
        values[key] = overrideValues[key];
      }
      var patternPieces = this.pattern.split('/');
      var interp = patternPieces.map(function (value) {
        if (value[0] == ':') {
          value = values[value.slice(1)];
        }
        return value;
      }, this);
      if (values.tail && values.tail.path) {
        if (interp.length > 0 && values.tail.path.charAt(0) === '/') {
          interp.push(values.tail.path.slice(1));
        } else {
          interp.push(values.tail.path);
        }
      }
      return interp.join('/');
    },

    __setMulti: function __setMulti(setObj) {
      // HACK(rictic): skirting around 1.0's lack of a setMulti by poking at
      //     internal data structures. I would not advise that you copy this
      //     example.
      //
      //     In the future this will be a feature of Polymer itself.
      //     See: https://github.com/Polymer/polymer/issues/3640
      //
      //     Hacking around with private methods like this is juggling footguns,
      //     and is likely to have unexpected and unsupported rough edges.
      //
      //     Be ye so warned.
      for (var property in setObj) {
        this._propertySetter(property, setObj[property]);
      }
      //notify in a specific order
      if (setObj.data !== undefined) {
        this._pathEffector('data', this.data);
        this._notifyChange('data');
      }
      if (setObj.active !== undefined) {
        this._pathEffector('active', this.active);
        this._notifyChange('active');
      }
      if (setObj.tail !== undefined) {
        this._pathEffector('tail', this.tail);
        this._notifyChange('tail');
      }
    }
  });
})();

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

__webpack_require__(22);

__webpack_require__(27);

var RegisterHtmlTemplate = __webpack_require__(2);

RegisterHtmlTemplate.register("<dom-module id=iron-pages> <template> <style>:host{display:block}:host>::slotted(:not(.iron-selected)){display:none!important}</style> <slot></slot> </template> </dom-module>");

Polymer({

  is: 'iron-pages',

  behaviors: [Polymer.IronResizableBehavior, Polymer.IronSelectableBehavior],

  properties: {

    // as the selected page is the only one visible, activateEvent
    // is both non-sensical and problematic; e.g. in cases where a user
    // handler attempts to change the page and the activateEvent
    // handler immediately changes it back
    activateEvent: {
      type: String,
      value: null
    }

  },

  observers: ['_selectedPageChanged(selected)'],

  _selectedPageChanged: function _selectedPageChanged(selected, old) {
    this.async(this.notifyResize);
  }
});

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

/**
 * @param {!Function} selectCallback
 * @constructor
 */
Polymer.IronSelection = function (selectCallback) {
  this.selection = [];
  this.selectCallback = selectCallback;
};

Polymer.IronSelection.prototype = {

  /**
   * Retrieves the selected item(s).
   *
   * @method get
   * @returns Returns the selected item(s). If the multi property is true,
   * `get` will return an array, otherwise it will return
   * the selected item or undefined if there is no selection.
   */
  get: function get() {
    return this.multi ? this.selection.slice() : this.selection[0];
  },

  /**
   * Clears all the selection except the ones indicated.
   *
   * @method clear
   * @param {Array} excludes items to be excluded.
   */
  clear: function clear(excludes) {
    this.selection.slice().forEach(function (item) {
      if (!excludes || excludes.indexOf(item) < 0) {
        this.setItemSelected(item, false);
      }
    }, this);
  },

  /**
   * Indicates if a given item is selected.
   *
   * @method isSelected
   * @param {*} item The item whose selection state should be checked.
   * @returns Returns true if `item` is selected.
   */
  isSelected: function isSelected(item) {
    return this.selection.indexOf(item) >= 0;
  },

  /**
   * Sets the selection state for a given item to either selected or deselected.
   *
   * @method setItemSelected
   * @param {*} item The item to select.
   * @param {boolean} isSelected True for selected, false for deselected.
   */
  setItemSelected: function setItemSelected(item, isSelected) {
    if (item != null) {
      if (isSelected !== this.isSelected(item)) {
        // proceed to update selection only if requested state differs from current
        if (isSelected) {
          this.selection.push(item);
        } else {
          var i = this.selection.indexOf(item);
          if (i >= 0) {
            this.selection.splice(i, 1);
          }
        }
        if (this.selectCallback) {
          this.selectCallback(item, isSelected);
        }
      }
    }
  },

  /**
   * Sets the selection state for a given item. If the `multi` property
   * is true, then the selected state of `item` will be toggled; otherwise
   * the `item` will be selected.
   *
   * @method select
   * @param {*} item The item to select.
   */
  select: function select(item) {
    if (this.multi) {
      this.toggle(item);
    } else if (this.get() !== item) {
      this.setItemSelected(this.get(), false);
      this.setItemSelected(item, true);
    }
  },

  /**
   * Toggles the selection state for `item`.
   *
   * @method toggle
   * @param {*} item The item to toggle.
   */
  toggle: function toggle(item) {
    this.setItemSelected(item, !this.isSelected(item));
  }

};

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

__webpack_require__(74);

/**
`iron-selector` is an element which can be used to manage a list of elements
that can be selected.  Tapping on the item will make the item selected.  The `selected` indicates
which item is being selected.  The default is to use the index of the item.
 Example:
     <iron-selector selected="0">
      <div>Item 1</div>
      <div>Item 2</div>
      <div>Item 3</div>
    </iron-selector>
 If you want to use the attribute value of an element for `selected` instead of the index,
set `attrForSelected` to the name of the attribute.  For example, if you want to select item by
`name`, set `attrForSelected` to `name`.
 Example:
     <iron-selector attr-for-selected="name" selected="foo">
      <div name="foo">Foo</div>
      <div name="bar">Bar</div>
      <div name="zot">Zot</div>
    </iron-selector>
 You can specify a default fallback with `fallbackSelection` in case the `selected` attribute does
not match the `attrForSelected` attribute of any elements.
 Example:
       <iron-selector attr-for-selected="name" selected="non-existing"
                     fallback-selection="default">
        <div name="foo">Foo</div>
        <div name="bar">Bar</div>
        <div name="default">Default</div>
      </iron-selector>
 Note: When the selector is multi, the selection will set to `fallbackSelection` iff
the number of matching elements is zero.
 `iron-selector` is not styled. Use the `iron-selected` CSS class to style the selected element.
 Example:
     <style>
      .iron-selected {
        background: #eee;
      }
    </style>
     ...
     <iron-selector selected="0">
      <div>Item 1</div>
      <div>Item 2</div>
      <div>Item 3</div>
    </iron-selector>
 @demo demo/index.html
*/

Polymer({

  is: 'iron-selector',

  behaviors: [Polymer.IronMultiSelectableBehavior]

});

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

__webpack_require__(27);

/**
 * @polymerBehavior Polymer.IronMultiSelectableBehavior
 */
Polymer.IronMultiSelectableBehaviorImpl = {
  properties: {

    /**
     * If true, multiple selections are allowed.
     */
    multi: {
      type: Boolean,
      value: false,
      observer: 'multiChanged'
    },

    /**
     * Gets or sets the selected elements. This is used instead of `selected` when `multi`
     * is true.
     */
    selectedValues: {
      type: Array,
      notify: true,
      value: function value() {
        return [];
      }
    },

    /**
     * Returns an array of currently selected items.
     */
    selectedItems: {
      type: Array,
      readOnly: true,
      notify: true,
      value: function value() {
        return [];
      }
    }

  },

  observers: ['_updateSelected(selectedValues.splices)'],

  /**
   * Selects the given value. If the `multi` property is true, then the selected state of the
   * `value` will be toggled; otherwise the `value` will be selected.
   *
   * @method select
   * @param {string|number} value the value to select.
   */
  select: function select(value) {
    if (this.multi) {
      this._toggleSelected(value);
    } else {
      this.selected = value;
    }
  },

  multiChanged: function multiChanged(multi) {
    this._selection.multi = multi;
    this._updateSelected();
  },

  // UNUSED, FOR API COMPATIBILITY
  get _shouldUpdateSelection() {
    return this.selected != null || this.selectedValues != null && this.selectedValues.length;
  },

  _updateAttrForSelected: function _updateAttrForSelected() {
    if (!this.multi) {
      Polymer.IronSelectableBehavior._updateAttrForSelected.apply(this);
    } else if (this.selectedItems && this.selectedItems.length > 0) {
      this.selectedValues = this.selectedItems.map(function (selectedItem) {
        return this._indexToValue(this.indexOf(selectedItem));
      }, this).filter(function (unfilteredValue) {
        return unfilteredValue != null;
      }, this);
    }
  },

  _updateSelected: function _updateSelected() {
    if (this.multi) {
      this._selectMulti(this.selectedValues);
    } else {
      this._selectSelected(this.selected);
    }
  },

  _selectMulti: function _selectMulti(values) {
    values = values || [];

    var selectedItems = (this._valuesToItems(values) || []).filter(function (item) {
      return item !== null && item !== undefined;
    });

    // clear all but the current selected items
    this._selection.clear(selectedItems);

    // select only those not selected yet
    for (var i = 0; i < selectedItems.length; i++) {
      this._selection.setItemSelected(selectedItems[i], true);
    }

    // Check for items, since this array is populated only when attached
    if (this.fallbackSelection && !this._selection.get().length) {
      var fallback = this._valueToItem(this.fallbackSelection);
      if (fallback) {
        this.select(this.fallbackSelection);
      }
    }
  },

  _selectionChange: function _selectionChange() {
    var s = this._selection.get();
    if (this.multi) {
      this._setSelectedItems(s);
      this._setSelectedItem(s.length ? s[0] : null);
    } else {
      if (s !== null && s !== undefined) {
        this._setSelectedItems([s]);
        this._setSelectedItem(s);
      } else {
        this._setSelectedItems([]);
        this._setSelectedItem(null);
      }
    }
  },

  _toggleSelected: function _toggleSelected(value) {
    var i = this.selectedValues.indexOf(value);
    var unselected = i < 0;
    if (unselected) {
      this.push('selectedValues', value);
    } else {
      this.splice('selectedValues', i, 1);
    }
  },

  _valuesToItems: function _valuesToItems(values) {
    return values == null ? null : values.map(function (value) {
      return this._valueToItem(value);
    }, this);
  }
};

/** @polymerBehavior */
Polymer.IronMultiSelectableBehavior = [Polymer.IronSelectableBehavior, Polymer.IronMultiSelectableBehaviorImpl];

/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

__webpack_require__(76);

__webpack_require__(77);

__webpack_require__(82);

var RegisterHtmlTemplate = __webpack_require__(2);

RegisterHtmlTemplate.register("<dom-module id=paper-icon-button> <template strip-whitespace=\"\"> <style>:host{display:inline-block;position:relative;padding:8px;outline:0;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;z-index:0;line-height:1;width:40px;height:40px;-webkit-tap-highlight-color:transparent;-webkit-tap-highlight-color:transparent;box-sizing:border-box!important;@apply --paper-icon-button;}:host #ink{color:var(--paper-icon-button-ink-color,var(--primary-text-color));opacity:.6}:host([disabled]){color:var(--paper-icon-button-disabled-text,var(--disabled-text-color));pointer-events:none;cursor:auto;@apply --paper-icon-button-disabled;}:host([hidden]){display:none!important}:host(:hover){@apply --paper-icon-button-hover;}iron-icon{--iron-icon-width:100%;--iron-icon-height:100%}</style> <iron-icon id=icon src=[[src]] icon=[[icon]] alt$=[[alt]]></iron-icon> </template> </dom-module>");

Polymer({
  is: 'paper-icon-button',

  hostAttributes: {
    role: 'button',
    tabindex: '0'
  },

  behaviors: [Polymer.PaperInkyFocusBehavior],

  properties: {
    /**
     * The URL of an image for the icon. If the src property is specified,
     * the icon property should not be.
     */
    src: {
      type: String
    },

    /**
     * Specifies the icon name or index in the set of icons available in
     * the icon's icon set. If the icon property is specified,
     * the src property should not be.
     */
    icon: {
      type: String
    },

    /**
     * Specifies the alternate text for the button, for accessibility.
     */
    alt: {
      type: String,
      observer: "_altChanged"
    }
  },

  _altChanged: function _altChanged(newValue, oldValue) {
    var label = this.getAttribute('aria-label');

    // Don't stomp over a user-set aria-label.
    if (!label || oldValue == label) {
      this.setAttribute('aria-label', newValue);
    }
  }
});

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

__webpack_require__(28);

__webpack_require__(5);

var RegisterHtmlTemplate = __webpack_require__(2);

RegisterHtmlTemplate.register("<dom-module id=iron-icon> <template> <style>:host{@apply --layout-inline;@apply --layout-center-center;position:relative;vertical-align:middle;fill:var(--iron-icon-fill-color,currentcolor);stroke:var(--iron-icon-stroke-color,none);width:var(--iron-icon-width,24px);height:var(--iron-icon-height,24px);@apply --iron-icon;}:host([hidden]){display:none}</style> </template> </dom-module>");

Polymer({

  is: 'iron-icon',

  properties: {

    /**
     * The name of the icon to use. The name should be of the form:
     * `iconset_name:icon_name`.
     */
    icon: {
      type: String
    },

    /**
     * The name of the theme to used, if one is specified by the
     * iconset.
     */
    theme: {
      type: String
    },

    /**
     * If using iron-icon without an iconset, you can set the src to be
     * the URL of an individual icon image file. Note that this will take
     * precedence over a given icon attribute.
     */
    src: {
      type: String
    },

    /**
     * @type {!Polymer.IronMeta}
     */
    _meta: {
      value: Polymer.Base.create('iron-meta', { type: 'iconset' })
    }

  },

  observers: ['_updateIcon(_meta, isAttached)', '_updateIcon(theme, isAttached)', '_srcChanged(src, isAttached)', '_iconChanged(icon, isAttached)'],

  _DEFAULT_ICONSET: 'icons',

  _iconChanged: function _iconChanged(icon) {
    var parts = (icon || '').split(':');
    this._iconName = parts.pop();
    this._iconsetName = parts.pop() || this._DEFAULT_ICONSET;
    this._updateIcon();
  },

  _srcChanged: function _srcChanged(src) {
    this._updateIcon();
  },

  _usesIconset: function _usesIconset() {
    return this.icon || !this.src;
  },

  /** @suppress {visibility} */
  _updateIcon: function _updateIcon() {
    if (this._usesIconset()) {
      if (this._img && this._img.parentNode) {
        Polymer.dom(this.root).removeChild(this._img);
      }
      if (this._iconName === "") {
        if (this._iconset) {
          this._iconset.removeIcon(this);
        }
      } else if (this._iconsetName && this._meta) {
        this._iconset = /** @type {?Polymer.Iconset} */this._meta.byKey(this._iconsetName);
        if (this._iconset) {
          this._iconset.applyIcon(this, this._iconName, this.theme);
          this.unlisten(window, 'iron-iconset-added', '_updateIcon');
        } else {
          this.listen(window, 'iron-iconset-added', '_updateIcon');
        }
      }
    } else {
      if (this._iconset) {
        this._iconset.removeIcon(this);
      }
      if (!this._img) {
        this._img = document.createElement('img');
        this._img.style.width = '100%';
        this._img.style.height = '100%';
        this._img.draggable = false;
      }
      this._img.src = this.src;
      Polymer.dom(this.root).appendChild(this._img);
    }
  }

});

/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

__webpack_require__(78);

__webpack_require__(80);

/**
 * `Polymer.PaperInkyFocusBehavior` implements a ripple when the element has keyboard focus.
 *
 * @polymerBehavior Polymer.PaperInkyFocusBehavior
 */
Polymer.PaperInkyFocusBehaviorImpl = {
  observers: ['_focusedChanged(receivedFocusFromKeyboard)'],

  _focusedChanged: function _focusedChanged(receivedFocusFromKeyboard) {
    if (receivedFocusFromKeyboard) {
      this.ensureRipple();
    }
    if (this.hasRipple()) {
      this._ripple.holdDown = receivedFocusFromKeyboard;
    }
  },

  _createRipple: function _createRipple() {
    var ripple = Polymer.PaperRippleBehavior._createRipple();
    ripple.id = 'ink';
    ripple.setAttribute('center', '');
    ripple.classList.add('circle');
    return ripple;
  }
};

/** @polymerBehavior Polymer.PaperInkyFocusBehavior */
Polymer.PaperInkyFocusBehavior = [Polymer.IronButtonState, Polymer.IronControlState, Polymer.PaperRippleBehavior, Polymer.PaperInkyFocusBehaviorImpl];

/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

__webpack_require__(29);

__webpack_require__(79);

/**
 * @demo demo/index.html
 * @polymerBehavior Polymer.IronButtonState
 */
Polymer.IronButtonStateImpl = {

  properties: {

    /**
     * If true, the user is currently holding down the button.
     */
    pressed: {
      type: Boolean,
      readOnly: true,
      value: false,
      reflectToAttribute: true,
      observer: '_pressedChanged'
    },

    /**
     * If true, the button toggles the active state with each tap or press
     * of the spacebar.
     */
    toggles: {
      type: Boolean,
      value: false,
      reflectToAttribute: true
    },

    /**
     * If true, the button is a toggle and is currently in the active state.
     */
    active: {
      type: Boolean,
      value: false,
      notify: true,
      reflectToAttribute: true
    },

    /**
     * True if the element is currently being pressed by a "pointer," which
     * is loosely defined as mouse or touch input (but specifically excluding
     * keyboard input).
     */
    pointerDown: {
      type: Boolean,
      readOnly: true,
      value: false
    },

    /**
     * True if the input device that caused the element to receive focus
     * was a keyboard.
     */
    receivedFocusFromKeyboard: {
      type: Boolean,
      readOnly: true
    },

    /**
     * The aria attribute to be set if the button is a toggle and in the
     * active state.
     */
    ariaActiveAttribute: {
      type: String,
      value: 'aria-pressed',
      observer: '_ariaActiveAttributeChanged'
    }
  },

  listeners: {
    down: '_downHandler',
    up: '_upHandler',
    tap: '_tapHandler'
  },

  observers: ['_focusChanged(focused)', '_activeChanged(active, ariaActiveAttribute)'],

  keyBindings: {
    'enter:keydown': '_asyncClick',
    'space:keydown': '_spaceKeyDownHandler',
    'space:keyup': '_spaceKeyUpHandler'
  },

  _mouseEventRe: /^mouse/,

  _tapHandler: function _tapHandler() {
    if (this.toggles) {
      // a tap is needed to toggle the active state
      this._userActivate(!this.active);
    } else {
      this.active = false;
    }
  },

  _focusChanged: function _focusChanged(focused) {
    this._detectKeyboardFocus(focused);

    if (!focused) {
      this._setPressed(false);
    }
  },

  _detectKeyboardFocus: function _detectKeyboardFocus(focused) {
    this._setReceivedFocusFromKeyboard(!this.pointerDown && focused);
  },

  // to emulate native checkbox, (de-)activations from a user interaction fire
  // 'change' events
  _userActivate: function _userActivate(active) {
    if (this.active !== active) {
      this.active = active;
      this.fire('change');
    }
  },

  _downHandler: function _downHandler(event) {
    this._setPointerDown(true);
    this._setPressed(true);
    this._setReceivedFocusFromKeyboard(false);
  },

  _upHandler: function _upHandler() {
    this._setPointerDown(false);
    this._setPressed(false);
  },

  /**
   * @param {!KeyboardEvent} event .
   */
  _spaceKeyDownHandler: function _spaceKeyDownHandler(event) {
    var keyboardEvent = event.detail.keyboardEvent;
    var target = Polymer.dom(keyboardEvent).localTarget;

    // Ignore the event if this is coming from a focused light child, since that
    // element will deal with it.
    if (this.isLightDescendant( /** @type {Node} */target)) return;

    keyboardEvent.preventDefault();
    keyboardEvent.stopImmediatePropagation();
    this._setPressed(true);
  },

  /**
   * @param {!KeyboardEvent} event .
   */
  _spaceKeyUpHandler: function _spaceKeyUpHandler(event) {
    var keyboardEvent = event.detail.keyboardEvent;
    var target = Polymer.dom(keyboardEvent).localTarget;

    // Ignore the event if this is coming from a focused light child, since that
    // element will deal with it.
    if (this.isLightDescendant( /** @type {Node} */target)) return;

    if (this.pressed) {
      this._asyncClick();
    }
    this._setPressed(false);
  },

  // trigger click asynchronously, the asynchrony is useful to allow one
  // event handler to unwind before triggering another event
  _asyncClick: function _asyncClick() {
    this.async(function () {
      this.click();
    }, 1);
  },

  // any of these changes are considered a change to button state

  _pressedChanged: function _pressedChanged(pressed) {
    this._changedButtonState();
  },

  _ariaActiveAttributeChanged: function _ariaActiveAttributeChanged(value, oldValue) {
    if (oldValue && oldValue != value && this.hasAttribute(oldValue)) {
      this.removeAttribute(oldValue);
    }
  },

  _activeChanged: function _activeChanged(active, ariaActiveAttribute) {
    if (this.toggles) {
      this.setAttribute(this.ariaActiveAttribute, active ? 'true' : 'false');
    } else {
      this.removeAttribute(this.ariaActiveAttribute);
    }
    this._changedButtonState();
  },

  _controlStateChanged: function _controlStateChanged() {
    if (this.disabled) {
      this._setPressed(false);
    } else {
      this._changedButtonState();
    }
  },

  // provide hook for follow-on behaviors to react to button-state

  _changedButtonState: function _changedButtonState() {
    if (this._buttonStateChanged) {
      this._buttonStateChanged(); // abstract
    }
  }

};

/** @polymerBehavior */
Polymer.IronButtonState = [Polymer.IronA11yKeysBehavior, Polymer.IronButtonStateImpl];

/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

/**
 * @demo demo/index.html
 * @polymerBehavior
 */
Polymer.IronControlState = {

  properties: {

    /**
     * If true, the element currently has focus.
     */
    focused: {
      type: Boolean,
      value: false,
      notify: true,
      readOnly: true,
      reflectToAttribute: true
    },

    /**
     * If true, the user cannot interact with this element.
     */
    disabled: {
      type: Boolean,
      value: false,
      notify: true,
      observer: '_disabledChanged',
      reflectToAttribute: true
    },

    _oldTabIndex: {
      type: Number
    },

    _boundFocusBlurHandler: {
      type: Function,
      value: function value() {
        return this._focusBlurHandler.bind(this);
      }
    },

    __handleEventRetargeting: {
      type: Boolean,
      value: function value() {
        return !this.shadowRoot && !Polymer.Element;
      }
    }
  },

  observers: ['_changedControlState(focused, disabled)'],

  ready: function ready() {
    this.addEventListener('focus', this._boundFocusBlurHandler, true);
    this.addEventListener('blur', this._boundFocusBlurHandler, true);
  },

  _focusBlurHandler: function _focusBlurHandler(event) {
    // In Polymer 2.0, the library takes care of retargeting events.
    if (Polymer.Element) {
      this._setFocused(event.type === 'focus');
      return;
    }

    // NOTE(cdata):  if we are in ShadowDOM land, `event.target` will
    // eventually become `this` due to retargeting; if we are not in
    // ShadowDOM land, `event.target` will eventually become `this` due
    // to the second conditional which fires a synthetic event (that is also
    // handled). In either case, we can disregard `event.path`.
    if (event.target === this) {
      this._setFocused(event.type === 'focus');
    } else if (this.__handleEventRetargeting) {
      var target = /** @type {Node} */Polymer.dom(event).localTarget;
      if (!this.isLightDescendant(target)) {
        this.fire(event.type, { sourceEvent: event }, {
          node: this,
          bubbles: event.bubbles,
          cancelable: event.cancelable
        });
      }
    }
  },

  _disabledChanged: function _disabledChanged(disabled, old) {
    this.setAttribute('aria-disabled', disabled ? 'true' : 'false');
    this.style.pointerEvents = disabled ? 'none' : '';
    if (disabled) {
      this._oldTabIndex = this.tabIndex;
      this._setFocused(false);
      this.tabIndex = -1;
      this.blur();
    } else if (this._oldTabIndex !== undefined) {
      this.tabIndex = this._oldTabIndex;
    }
  },

  _changedControlState: function _changedControlState() {
    // _controlStateChanged is abstract, follow-on behaviors may implement it
    if (this._controlStateChanged) {
      this._controlStateChanged();
    }
  }

};

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

__webpack_require__(81);

/**
 * `Polymer.PaperRippleBehavior` dynamically implements a ripple
 * when the element has focus via pointer or keyboard.
 *
 * NOTE: This behavior is intended to be used in conjunction with and after
 * `Polymer.IronButtonState` and `Polymer.IronControlState`.
 *
 * @polymerBehavior Polymer.PaperRippleBehavior
 */
Polymer.PaperRippleBehavior = {
  properties: {
    /**
     * If true, the element will not produce a ripple effect when interacted
     * with via the pointer.
     */
    noink: {
      type: Boolean,
      observer: '_noinkChanged'
    },

    /**
     * @type {Element|undefined}
     */
    _rippleContainer: {
      type: Object
    }
  },

  /**
   * Ensures a `<paper-ripple>` element is available when the element is
   * focused.
   */
  _buttonStateChanged: function _buttonStateChanged() {
    if (this.focused) {
      this.ensureRipple();
    }
  },

  /**
   * In addition to the functionality provided in `IronButtonState`, ensures
   * a ripple effect is created when the element is in a `pressed` state.
   */
  _downHandler: function _downHandler(event) {
    Polymer.IronButtonStateImpl._downHandler.call(this, event);
    if (this.pressed) {
      this.ensureRipple(event);
    }
  },

  /**
   * Ensures this element contains a ripple effect. For startup efficiency
   * the ripple effect is dynamically on demand when needed.
   * @param {!Event=} optTriggeringEvent (optional) event that triggered the
   * ripple.
   */
  ensureRipple: function ensureRipple(optTriggeringEvent) {
    if (!this.hasRipple()) {
      this._ripple = this._createRipple();
      this._ripple.noink = this.noink;
      var rippleContainer = this._rippleContainer || this.root;
      if (rippleContainer) {
        Polymer.dom(rippleContainer).appendChild(this._ripple);
      }
      if (optTriggeringEvent) {
        // Check if the event happened inside of the ripple container
        // Fall back to host instead of the root because distributed text
        // nodes are not valid event targets
        var domContainer = Polymer.dom(this._rippleContainer || this);
        var target = Polymer.dom(optTriggeringEvent).rootTarget;
        if (domContainer.deepContains( /** @type {Node} */target)) {
          this._ripple.uiDownAction(optTriggeringEvent);
        }
      }
    }
  },

  /**
   * Returns the `<paper-ripple>` element used by this element to create
   * ripple effects. The element's ripple is created on demand, when
   * necessary, and calling this method will force the
   * ripple to be created.
   */
  getRipple: function getRipple() {
    this.ensureRipple();
    return this._ripple;
  },

  /**
   * Returns true if this element currently contains a ripple effect.
   * @return {boolean}
   */
  hasRipple: function hasRipple() {
    return Boolean(this._ripple);
  },

  /**
   * Create the element's ripple effect via creating a `<paper-ripple>`.
   * Override this method to customize the ripple element.
   * @return {!PaperRippleElement} Returns a `<paper-ripple>` element.
   */
  _createRipple: function _createRipple() {
    return (/** @type {!PaperRippleElement} */document.createElement('paper-ripple')
    );
  },

  _noinkChanged: function _noinkChanged(noink) {
    if (this.hasRipple()) {
      this._ripple.noink = noink;
    }
  }
};

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

__webpack_require__(29);

var RegisterHtmlTemplate = __webpack_require__(2);

RegisterHtmlTemplate.register("<dom-module id=paper-ripple> <template> <style>:host{display:block;position:absolute;border-radius:inherit;overflow:hidden;top:0;left:0;right:0;bottom:0;pointer-events:none}:host([animating]){-webkit-transform:translate(0,0);transform:translate3d(0,0,0)}#background,#waves,.wave,.wave-container{pointer-events:none;position:absolute;top:0;left:0;width:100%;height:100%}#background,.wave{opacity:0}#waves,.wave{overflow:hidden}.wave,.wave-container{border-radius:50%}:host(.circle) #background,:host(.circle) #waves{border-radius:50%}:host(.circle) .wave-container{overflow:hidden}</style> <div id=background></div> <div id=waves></div> </template> </dom-module>");

(function () {
  'use strict';

  var Utility = {
    distance: function distance(x1, y1, x2, y2) {
      var xDelta = x1 - x2;
      var yDelta = y1 - y2;

      return Math.sqrt(xDelta * xDelta + yDelta * yDelta);
    },

    now: window.performance && window.performance.now ? window.performance.now.bind(window.performance) : Date.now
  };

  /**
   * @param {HTMLElement} element
   * @constructor
   */
  function ElementMetrics(element) {
    this.element = element;
    this.width = this.boundingRect.width;
    this.height = this.boundingRect.height;

    this.size = Math.max(this.width, this.height);
  }

  ElementMetrics.prototype = {
    get boundingRect() {
      return this.element.getBoundingClientRect();
    },

    furthestCornerDistanceFrom: function furthestCornerDistanceFrom(x, y) {
      var topLeft = Utility.distance(x, y, 0, 0);
      var topRight = Utility.distance(x, y, this.width, 0);
      var bottomLeft = Utility.distance(x, y, 0, this.height);
      var bottomRight = Utility.distance(x, y, this.width, this.height);

      return Math.max(topLeft, topRight, bottomLeft, bottomRight);
    }
  };

  /**
   * @param {HTMLElement} element
   * @constructor
   */
  function Ripple(element) {
    this.element = element;
    this.color = window.getComputedStyle(element).color;

    this.wave = document.createElement('div');
    this.waveContainer = document.createElement('div');
    this.wave.style.backgroundColor = this.color;
    this.wave.classList.add('wave');
    this.waveContainer.classList.add('wave-container');
    Polymer.dom(this.waveContainer).appendChild(this.wave);

    this.resetInteractionState();
  }

  Ripple.MAX_RADIUS = 300;

  Ripple.prototype = {
    get recenters() {
      return this.element.recenters;
    },

    get center() {
      return this.element.center;
    },

    get mouseDownElapsed() {
      var elapsed;

      if (!this.mouseDownStart) {
        return 0;
      }

      elapsed = Utility.now() - this.mouseDownStart;

      if (this.mouseUpStart) {
        elapsed -= this.mouseUpElapsed;
      }

      return elapsed;
    },

    get mouseUpElapsed() {
      return this.mouseUpStart ? Utility.now() - this.mouseUpStart : 0;
    },

    get mouseDownElapsedSeconds() {
      return this.mouseDownElapsed / 1000;
    },

    get mouseUpElapsedSeconds() {
      return this.mouseUpElapsed / 1000;
    },

    get mouseInteractionSeconds() {
      return this.mouseDownElapsedSeconds + this.mouseUpElapsedSeconds;
    },

    get initialOpacity() {
      return this.element.initialOpacity;
    },

    get opacityDecayVelocity() {
      return this.element.opacityDecayVelocity;
    },

    get radius() {
      var width2 = this.containerMetrics.width * this.containerMetrics.width;
      var height2 = this.containerMetrics.height * this.containerMetrics.height;
      var waveRadius = Math.min(Math.sqrt(width2 + height2), Ripple.MAX_RADIUS) * 1.1 + 5;

      var duration = 1.1 - 0.2 * (waveRadius / Ripple.MAX_RADIUS);
      var timeNow = this.mouseInteractionSeconds / duration;
      var size = waveRadius * (1 - Math.pow(80, -timeNow));

      return Math.abs(size);
    },

    get opacity() {
      if (!this.mouseUpStart) {
        return this.initialOpacity;
      }

      return Math.max(0, this.initialOpacity - this.mouseUpElapsedSeconds * this.opacityDecayVelocity);
    },

    get outerOpacity() {
      // Linear increase in background opacity, capped at the opacity
      // of the wavefront (waveOpacity).
      var outerOpacity = this.mouseUpElapsedSeconds * 0.3;
      var waveOpacity = this.opacity;

      return Math.max(0, Math.min(outerOpacity, waveOpacity));
    },

    get isOpacityFullyDecayed() {
      return this.opacity < 0.01 && this.radius >= Math.min(this.maxRadius, Ripple.MAX_RADIUS);
    },

    get isRestingAtMaxRadius() {
      return this.opacity >= this.initialOpacity && this.radius >= Math.min(this.maxRadius, Ripple.MAX_RADIUS);
    },

    get isAnimationComplete() {
      return this.mouseUpStart ? this.isOpacityFullyDecayed : this.isRestingAtMaxRadius;
    },

    get translationFraction() {
      return Math.min(1, this.radius / this.containerMetrics.size * 2 / Math.sqrt(2));
    },

    get xNow() {
      if (this.xEnd) {
        return this.xStart + this.translationFraction * (this.xEnd - this.xStart);
      }

      return this.xStart;
    },

    get yNow() {
      if (this.yEnd) {
        return this.yStart + this.translationFraction * (this.yEnd - this.yStart);
      }

      return this.yStart;
    },

    get isMouseDown() {
      return this.mouseDownStart && !this.mouseUpStart;
    },

    resetInteractionState: function resetInteractionState() {
      this.maxRadius = 0;
      this.mouseDownStart = 0;
      this.mouseUpStart = 0;

      this.xStart = 0;
      this.yStart = 0;
      this.xEnd = 0;
      this.yEnd = 0;
      this.slideDistance = 0;

      this.containerMetrics = new ElementMetrics(this.element);
    },

    draw: function draw() {
      var scale;
      var translateString;
      var dx;
      var dy;

      this.wave.style.opacity = this.opacity;

      scale = this.radius / (this.containerMetrics.size / 2);
      dx = this.xNow - this.containerMetrics.width / 2;
      dy = this.yNow - this.containerMetrics.height / 2;

      // 2d transform for safari because of border-radius and overflow:hidden clipping bug.
      // https://bugs.webkit.org/show_bug.cgi?id=98538
      this.waveContainer.style.webkitTransform = 'translate(' + dx + 'px, ' + dy + 'px)';
      this.waveContainer.style.transform = 'translate3d(' + dx + 'px, ' + dy + 'px, 0)';
      this.wave.style.webkitTransform = 'scale(' + scale + ',' + scale + ')';
      this.wave.style.transform = 'scale3d(' + scale + ',' + scale + ',1)';
    },

    /** @param {Event=} event */
    downAction: function downAction(event) {
      var xCenter = this.containerMetrics.width / 2;
      var yCenter = this.containerMetrics.height / 2;

      this.resetInteractionState();
      this.mouseDownStart = Utility.now();

      if (this.center) {
        this.xStart = xCenter;
        this.yStart = yCenter;
        this.slideDistance = Utility.distance(this.xStart, this.yStart, this.xEnd, this.yEnd);
      } else {
        this.xStart = event ? event.detail.x - this.containerMetrics.boundingRect.left : this.containerMetrics.width / 2;
        this.yStart = event ? event.detail.y - this.containerMetrics.boundingRect.top : this.containerMetrics.height / 2;
      }

      if (this.recenters) {
        this.xEnd = xCenter;
        this.yEnd = yCenter;
        this.slideDistance = Utility.distance(this.xStart, this.yStart, this.xEnd, this.yEnd);
      }

      this.maxRadius = this.containerMetrics.furthestCornerDistanceFrom(this.xStart, this.yStart);

      this.waveContainer.style.top = (this.containerMetrics.height - this.containerMetrics.size) / 2 + 'px';
      this.waveContainer.style.left = (this.containerMetrics.width - this.containerMetrics.size) / 2 + 'px';

      this.waveContainer.style.width = this.containerMetrics.size + 'px';
      this.waveContainer.style.height = this.containerMetrics.size + 'px';
    },

    /** @param {Event=} event */
    upAction: function upAction(event) {
      if (!this.isMouseDown) {
        return;
      }

      this.mouseUpStart = Utility.now();
    },

    remove: function remove() {
      Polymer.dom(this.waveContainer.parentNode).removeChild(this.waveContainer);
    }
  };

  Polymer({
    is: 'paper-ripple',

    behaviors: [Polymer.IronA11yKeysBehavior],

    properties: {
      /**
       * The initial opacity set on the wave.
       *
       * @attribute initialOpacity
       * @type number
       * @default 0.25
       */
      initialOpacity: {
        type: Number,
        value: 0.25
      },

      /**
       * How fast (opacity per second) the wave fades out.
       *
       * @attribute opacityDecayVelocity
       * @type number
       * @default 0.8
       */
      opacityDecayVelocity: {
        type: Number,
        value: 0.8
      },

      /**
       * If true, ripples will exhibit a gravitational pull towards
       * the center of their container as they fade away.
       *
       * @attribute recenters
       * @type boolean
       * @default false
       */
      recenters: {
        type: Boolean,
        value: false
      },

      /**
       * If true, ripples will center inside its container
       *
       * @attribute recenters
       * @type boolean
       * @default false
       */
      center: {
        type: Boolean,
        value: false
      },

      /**
       * A list of the visual ripples.
       *
       * @attribute ripples
       * @type Array
       * @default []
       */
      ripples: {
        type: Array,
        value: function value() {
          return [];
        }
      },

      /**
       * True when there are visible ripples animating within the
       * element.
       */
      animating: {
        type: Boolean,
        readOnly: true,
        reflectToAttribute: true,
        value: false
      },

      /**
       * If true, the ripple will remain in the "down" state until `holdDown`
       * is set to false again.
       */
      holdDown: {
        type: Boolean,
        value: false,
        observer: '_holdDownChanged'
      },

      /**
       * If true, the ripple will not generate a ripple effect
       * via pointer interaction.
       * Calling ripple's imperative api like `simulatedRipple` will
       * still generate the ripple effect.
       */
      noink: {
        type: Boolean,
        value: false
      },

      _animating: {
        type: Boolean
      },

      _boundAnimate: {
        type: Function,
        value: function value() {
          return this.animate.bind(this);
        }
      }
    },

    get target() {
      return this.keyEventTarget;
    },

    keyBindings: {
      'enter:keydown': '_onEnterKeydown',
      'space:keydown': '_onSpaceKeydown',
      'space:keyup': '_onSpaceKeyup'
    },

    attached: function attached() {
      // Set up a11yKeysBehavior to listen to key events on the target,
      // so that space and enter activate the ripple even if the target doesn't
      // handle key events. The key handlers deal with `noink` themselves.
      if (this.parentNode.nodeType == 11) {
        // DOCUMENT_FRAGMENT_NODE
        this.keyEventTarget = Polymer.dom(this).getOwnerRoot().host;
      } else {
        this.keyEventTarget = this.parentNode;
      }
      var keyEventTarget = /** @type {!EventTarget} */this.keyEventTarget;
      this.listen(keyEventTarget, 'up', 'uiUpAction');
      this.listen(keyEventTarget, 'down', 'uiDownAction');
    },

    detached: function detached() {
      this.unlisten(this.keyEventTarget, 'up', 'uiUpAction');
      this.unlisten(this.keyEventTarget, 'down', 'uiDownAction');
      this.keyEventTarget = null;
    },

    get shouldKeepAnimating() {
      for (var index = 0; index < this.ripples.length; ++index) {
        if (!this.ripples[index].isAnimationComplete) {
          return true;
        }
      }

      return false;
    },

    simulatedRipple: function simulatedRipple() {
      this.downAction(null);

      // Please see polymer/polymer#1305
      this.async(function () {
        this.upAction();
      }, 1);
    },

    /**
     * Provokes a ripple down effect via a UI event,
     * respecting the `noink` property.
     * @param {Event=} event
     */
    uiDownAction: function uiDownAction(event) {
      if (!this.noink) {
        this.downAction(event);
      }
    },

    /**
     * Provokes a ripple down effect via a UI event,
     * *not* respecting the `noink` property.
     * @param {Event=} event
     */
    downAction: function downAction(event) {
      if (this.holdDown && this.ripples.length > 0) {
        return;
      }

      var ripple = this.addRipple();

      ripple.downAction(event);

      if (!this._animating) {
        this._animating = true;
        this.animate();
      }
    },

    /**
     * Provokes a ripple up effect via a UI event,
     * respecting the `noink` property.
     * @param {Event=} event
     */
    uiUpAction: function uiUpAction(event) {
      if (!this.noink) {
        this.upAction(event);
      }
    },

    /**
     * Provokes a ripple up effect via a UI event,
     * *not* respecting the `noink` property.
     * @param {Event=} event
     */
    upAction: function upAction(event) {
      if (this.holdDown) {
        return;
      }

      this.ripples.forEach(function (ripple) {
        ripple.upAction(event);
      });

      this._animating = true;
      this.animate();
    },

    onAnimationComplete: function onAnimationComplete() {
      this._animating = false;
      this.$.background.style.backgroundColor = null;
      this.fire('transitionend');
    },

    addRipple: function addRipple() {
      var ripple = new Ripple(this);

      Polymer.dom(this.$.waves).appendChild(ripple.waveContainer);
      this.$.background.style.backgroundColor = ripple.color;
      this.ripples.push(ripple);

      this._setAnimating(true);

      return ripple;
    },

    removeRipple: function removeRipple(ripple) {
      var rippleIndex = this.ripples.indexOf(ripple);

      if (rippleIndex < 0) {
        return;
      }

      this.ripples.splice(rippleIndex, 1);

      ripple.remove();

      if (!this.ripples.length) {
        this._setAnimating(false);
      }
    },

    /**
     * This conflicts with Element#antimate().
     * https://developer.mozilla.org/en-US/docs/Web/API/Element/animate
     * @suppress {checkTypes}
     */
    animate: function animate() {
      if (!this._animating) {
        return;
      }
      var index;
      var ripple;

      for (index = 0; index < this.ripples.length; ++index) {
        ripple = this.ripples[index];

        ripple.draw();

        this.$.background.style.opacity = ripple.outerOpacity;

        if (ripple.isOpacityFullyDecayed && !ripple.isRestingAtMaxRadius) {
          this.removeRipple(ripple);
        }
      }

      if (!this.shouldKeepAnimating && this.ripples.length === 0) {
        this.onAnimationComplete();
      } else {
        window.requestAnimationFrame(this._boundAnimate);
      }
    },

    _onEnterKeydown: function _onEnterKeydown() {
      this.uiDownAction();
      this.async(this.uiUpAction, 1);
    },

    _onSpaceKeydown: function _onSpaceKeydown() {
      this.uiDownAction();
    },

    _onSpaceKeyup: function _onSpaceKeyup() {
      this.uiUpAction();
    },

    // note: holdDown does not respect noink since it can be a focus based
    // effect.
    _holdDownChanged: function _holdDownChanged(newVal, oldVal) {
      if (oldVal === undefined) {
        return;
      }
      if (newVal) {
        this.downAction();
      } else {
        this.upAction();
      }
    }

    /**
    Fired when the animation finishes.
    This is useful if you want to wait until
    the ripple animation finishes to perform some action.
     @event transitionend
    @param {{node: Object}} detail Contains the animated node.
    */
  });
})();

/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

__webpack_require__(83);

var RegisterHtmlTemplate = __webpack_require__(2);

RegisterHtmlTemplate.toBody("<custom-style> <style is=custom-style>html{--primary-text-color:var(--light-theme-text-color);--primary-background-color:var(--light-theme-background-color);--secondary-text-color:var(--light-theme-secondary-color);--disabled-text-color:var(--light-theme-disabled-color);--divider-color:var(--light-theme-divider-color);--error-color:var(--paper-deep-orange-a700);--primary-color:var(--paper-indigo-500);--light-primary-color:var(--paper-indigo-100);--dark-primary-color:var(--paper-indigo-700);--accent-color:var(--paper-pink-a200);--light-accent-color:var(--paper-pink-a100);--dark-accent-color:var(--paper-pink-a400);--light-theme-background-color:#ffffff;--light-theme-base-color:#000000;--light-theme-text-color:var(--paper-grey-900);--light-theme-secondary-color:#737373;--light-theme-disabled-color:#9b9b9b;--light-theme-divider-color:#dbdbdb;--dark-theme-background-color:var(--paper-grey-900);--dark-theme-base-color:#ffffff;--dark-theme-text-color:#ffffff;--dark-theme-secondary-color:#bcbcbc;--dark-theme-disabled-color:#646464;--dark-theme-divider-color:#3c3c3c;--text-primary-color:var(--dark-theme-text-color);--default-primary-color:var(--primary-color)}</style> </custom-style>");

/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

var RegisterHtmlTemplate = __webpack_require__(2);

RegisterHtmlTemplate.toBody("<custom-style> <style is=custom-style>html{--google-red-100:#f4c7c3;--google-red-300:#e67c73;--google-red-500:#db4437;--google-red-700:#c53929;--google-blue-100:#c6dafc;--google-blue-300:#7baaf7;--google-blue-500:#4285f4;--google-blue-700:#3367d6;--google-green-100:#b7e1cd;--google-green-300:#57bb8a;--google-green-500:#0f9d58;--google-green-700:#0b8043;--google-yellow-100:#fce8b2;--google-yellow-300:#f7cb4d;--google-yellow-500:#f4b400;--google-yellow-700:#f09300;--google-grey-100:#f5f5f5;--google-grey-300:#e0e0e0;--google-grey-500:#9e9e9e;--google-grey-700:#616161;--paper-red-50:#ffebee;--paper-red-100:#ffcdd2;--paper-red-200:#ef9a9a;--paper-red-300:#e57373;--paper-red-400:#ef5350;--paper-red-500:#f44336;--paper-red-600:#e53935;--paper-red-700:#d32f2f;--paper-red-800:#c62828;--paper-red-900:#b71c1c;--paper-red-a100:#ff8a80;--paper-red-a200:#ff5252;--paper-red-a400:#ff1744;--paper-red-a700:#d50000;--paper-pink-50:#fce4ec;--paper-pink-100:#f8bbd0;--paper-pink-200:#f48fb1;--paper-pink-300:#f06292;--paper-pink-400:#ec407a;--paper-pink-500:#e91e63;--paper-pink-600:#d81b60;--paper-pink-700:#c2185b;--paper-pink-800:#ad1457;--paper-pink-900:#880e4f;--paper-pink-a100:#ff80ab;--paper-pink-a200:#ff4081;--paper-pink-a400:#f50057;--paper-pink-a700:#c51162;--paper-purple-50:#f3e5f5;--paper-purple-100:#e1bee7;--paper-purple-200:#ce93d8;--paper-purple-300:#ba68c8;--paper-purple-400:#ab47bc;--paper-purple-500:#9c27b0;--paper-purple-600:#8e24aa;--paper-purple-700:#7b1fa2;--paper-purple-800:#6a1b9a;--paper-purple-900:#4a148c;--paper-purple-a100:#ea80fc;--paper-purple-a200:#e040fb;--paper-purple-a400:#d500f9;--paper-purple-a700:#aa00ff;--paper-deep-purple-50:#ede7f6;--paper-deep-purple-100:#d1c4e9;--paper-deep-purple-200:#b39ddb;--paper-deep-purple-300:#9575cd;--paper-deep-purple-400:#7e57c2;--paper-deep-purple-500:#673ab7;--paper-deep-purple-600:#5e35b1;--paper-deep-purple-700:#512da8;--paper-deep-purple-800:#4527a0;--paper-deep-purple-900:#311b92;--paper-deep-purple-a100:#b388ff;--paper-deep-purple-a200:#7c4dff;--paper-deep-purple-a400:#651fff;--paper-deep-purple-a700:#6200ea;--paper-indigo-50:#e8eaf6;--paper-indigo-100:#c5cae9;--paper-indigo-200:#9fa8da;--paper-indigo-300:#7986cb;--paper-indigo-400:#5c6bc0;--paper-indigo-500:#3f51b5;--paper-indigo-600:#3949ab;--paper-indigo-700:#303f9f;--paper-indigo-800:#283593;--paper-indigo-900:#1a237e;--paper-indigo-a100:#8c9eff;--paper-indigo-a200:#536dfe;--paper-indigo-a400:#3d5afe;--paper-indigo-a700:#304ffe;--paper-blue-50:#e3f2fd;--paper-blue-100:#bbdefb;--paper-blue-200:#90caf9;--paper-blue-300:#64b5f6;--paper-blue-400:#42a5f5;--paper-blue-500:#2196f3;--paper-blue-600:#1e88e5;--paper-blue-700:#1976d2;--paper-blue-800:#1565c0;--paper-blue-900:#0d47a1;--paper-blue-a100:#82b1ff;--paper-blue-a200:#448aff;--paper-blue-a400:#2979ff;--paper-blue-a700:#2962ff;--paper-light-blue-50:#e1f5fe;--paper-light-blue-100:#b3e5fc;--paper-light-blue-200:#81d4fa;--paper-light-blue-300:#4fc3f7;--paper-light-blue-400:#29b6f6;--paper-light-blue-500:#03a9f4;--paper-light-blue-600:#039be5;--paper-light-blue-700:#0288d1;--paper-light-blue-800:#0277bd;--paper-light-blue-900:#01579b;--paper-light-blue-a100:#80d8ff;--paper-light-blue-a200:#40c4ff;--paper-light-blue-a400:#00b0ff;--paper-light-blue-a700:#0091ea;--paper-cyan-50:#e0f7fa;--paper-cyan-100:#b2ebf2;--paper-cyan-200:#80deea;--paper-cyan-300:#4dd0e1;--paper-cyan-400:#26c6da;--paper-cyan-500:#00bcd4;--paper-cyan-600:#00acc1;--paper-cyan-700:#0097a7;--paper-cyan-800:#00838f;--paper-cyan-900:#006064;--paper-cyan-a100:#84ffff;--paper-cyan-a200:#18ffff;--paper-cyan-a400:#00e5ff;--paper-cyan-a700:#00b8d4;--paper-teal-50:#e0f2f1;--paper-teal-100:#b2dfdb;--paper-teal-200:#80cbc4;--paper-teal-300:#4db6ac;--paper-teal-400:#26a69a;--paper-teal-500:#009688;--paper-teal-600:#00897b;--paper-teal-700:#00796b;--paper-teal-800:#00695c;--paper-teal-900:#004d40;--paper-teal-a100:#a7ffeb;--paper-teal-a200:#64ffda;--paper-teal-a400:#1de9b6;--paper-teal-a700:#00bfa5;--paper-green-50:#e8f5e9;--paper-green-100:#c8e6c9;--paper-green-200:#a5d6a7;--paper-green-300:#81c784;--paper-green-400:#66bb6a;--paper-green-500:#4caf50;--paper-green-600:#43a047;--paper-green-700:#388e3c;--paper-green-800:#2e7d32;--paper-green-900:#1b5e20;--paper-green-a100:#b9f6ca;--paper-green-a200:#69f0ae;--paper-green-a400:#00e676;--paper-green-a700:#00c853;--paper-light-green-50:#f1f8e9;--paper-light-green-100:#dcedc8;--paper-light-green-200:#c5e1a5;--paper-light-green-300:#aed581;--paper-light-green-400:#9ccc65;--paper-light-green-500:#8bc34a;--paper-light-green-600:#7cb342;--paper-light-green-700:#689f38;--paper-light-green-800:#558b2f;--paper-light-green-900:#33691e;--paper-light-green-a100:#ccff90;--paper-light-green-a200:#b2ff59;--paper-light-green-a400:#76ff03;--paper-light-green-a700:#64dd17;--paper-lime-50:#f9fbe7;--paper-lime-100:#f0f4c3;--paper-lime-200:#e6ee9c;--paper-lime-300:#dce775;--paper-lime-400:#d4e157;--paper-lime-500:#cddc39;--paper-lime-600:#c0ca33;--paper-lime-700:#afb42b;--paper-lime-800:#9e9d24;--paper-lime-900:#827717;--paper-lime-a100:#f4ff81;--paper-lime-a200:#eeff41;--paper-lime-a400:#c6ff00;--paper-lime-a700:#aeea00;--paper-yellow-50:#fffde7;--paper-yellow-100:#fff9c4;--paper-yellow-200:#fff59d;--paper-yellow-300:#fff176;--paper-yellow-400:#ffee58;--paper-yellow-500:#ffeb3b;--paper-yellow-600:#fdd835;--paper-yellow-700:#fbc02d;--paper-yellow-800:#f9a825;--paper-yellow-900:#f57f17;--paper-yellow-a100:#ffff8d;--paper-yellow-a200:#ffff00;--paper-yellow-a400:#ffea00;--paper-yellow-a700:#ffd600;--paper-amber-50:#fff8e1;--paper-amber-100:#ffecb3;--paper-amber-200:#ffe082;--paper-amber-300:#ffd54f;--paper-amber-400:#ffca28;--paper-amber-500:#ffc107;--paper-amber-600:#ffb300;--paper-amber-700:#ffa000;--paper-amber-800:#ff8f00;--paper-amber-900:#ff6f00;--paper-amber-a100:#ffe57f;--paper-amber-a200:#ffd740;--paper-amber-a400:#ffc400;--paper-amber-a700:#ffab00;--paper-orange-50:#fff3e0;--paper-orange-100:#ffe0b2;--paper-orange-200:#ffcc80;--paper-orange-300:#ffb74d;--paper-orange-400:#ffa726;--paper-orange-500:#ff9800;--paper-orange-600:#fb8c00;--paper-orange-700:#f57c00;--paper-orange-800:#ef6c00;--paper-orange-900:#e65100;--paper-orange-a100:#ffd180;--paper-orange-a200:#ffab40;--paper-orange-a400:#ff9100;--paper-orange-a700:#ff6500;--paper-deep-orange-50:#fbe9e7;--paper-deep-orange-100:#ffccbc;--paper-deep-orange-200:#ffab91;--paper-deep-orange-300:#ff8a65;--paper-deep-orange-400:#ff7043;--paper-deep-orange-500:#ff5722;--paper-deep-orange-600:#f4511e;--paper-deep-orange-700:#e64a19;--paper-deep-orange-800:#d84315;--paper-deep-orange-900:#bf360c;--paper-deep-orange-a100:#ff9e80;--paper-deep-orange-a200:#ff6e40;--paper-deep-orange-a400:#ff3d00;--paper-deep-orange-a700:#dd2c00;--paper-brown-50:#efebe9;--paper-brown-100:#d7ccc8;--paper-brown-200:#bcaaa4;--paper-brown-300:#a1887f;--paper-brown-400:#8d6e63;--paper-brown-500:#795548;--paper-brown-600:#6d4c41;--paper-brown-700:#5d4037;--paper-brown-800:#4e342e;--paper-brown-900:#3e2723;--paper-grey-50:#fafafa;--paper-grey-100:#f5f5f5;--paper-grey-200:#eeeeee;--paper-grey-300:#e0e0e0;--paper-grey-400:#bdbdbd;--paper-grey-500:#9e9e9e;--paper-grey-600:#757575;--paper-grey-700:#616161;--paper-grey-800:#424242;--paper-grey-900:#212121;--paper-blue-grey-50:#eceff1;--paper-blue-grey-100:#cfd8dc;--paper-blue-grey-200:#b0bec5;--paper-blue-grey-300:#90a4ae;--paper-blue-grey-400:#78909c;--paper-blue-grey-500:#607d8b;--paper-blue-grey-600:#546e7a;--paper-blue-grey-700:#455a64;--paper-blue-grey-800:#37474f;--paper-blue-grey-900:#263238;--dark-divider-opacity:0.12;--dark-disabled-opacity:0.38;--dark-secondary-opacity:0.54;--dark-primary-opacity:0.87;--light-divider-opacity:0.12;--light-disabled-opacity:0.3;--light-secondary-opacity:0.7;--light-primary-opacity:1.0}</style> </custom-style>");

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(85);

var RegisterHtmlTemplate = __webpack_require__(2);

RegisterHtmlTemplate.toBody("<iron-iconset-svg name=my-icons size=24> <svg> <defs> <g id=arrow-back> <path d=\"M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z\"></path> </g> <g id=menu> <path d=\"M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z\"></path> </g> <g id=chevron-right> <path d=\"M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z\"></path> </g> <g id=close> <path d=\"M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z\"></path> </g> </defs> </svg> </iron-iconset-svg>");

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

__webpack_require__(28);

/**
 * The `iron-iconset-svg` element allows users to define their own icon sets
 * that contain svg icons. The svg icon elements should be children of the
 * `iron-iconset-svg` element. Multiple icons should be given distinct id's.
 *
 * Using svg elements to create icons has a few advantages over traditional
 * bitmap graphics like jpg or png. Icons that use svg are vector based so
 * they are resolution independent and should look good on any device. They
 * are stylable via css. Icons can be themed, colorized, and even animated.
 *
 * Example:
 *
 *     <iron-iconset-svg name="my-svg-icons" size="24">
 *       <svg>
 *         <defs>
 *           <g id="shape">
 *             <rect x="12" y="0" width="12" height="24" />
 *             <circle cx="12" cy="12" r="12" />
 *           </g>
 *         </defs>
 *       </svg>
 *     </iron-iconset-svg>
 *
 * This will automatically register the icon set "my-svg-icons" to the iconset
 * database.  To use these icons from within another element, make a
 * `iron-iconset` element and call the `byId` method
 * to retrieve a given iconset. To apply a particular icon inside an
 * element use the `applyIcon` method. For example:
 *
 *     iconset.applyIcon(iconNode, 'car');
 *
 * @element iron-iconset-svg
 * @demo demo/index.html
 * @implements {Polymer.Iconset}
 */
Polymer({
  is: 'iron-iconset-svg',

  properties: {

    /**
     * The name of the iconset.
     */
    name: {
      type: String,
      observer: '_nameChanged'
    },

    /**
     * The size of an individual icon. Note that icons must be square.
     */
    size: {
      type: Number,
      value: 24
    },

    /**
     * Set to true to enable mirroring of icons where specified when they are
     * stamped. Icons that should be mirrored should be decorated with a
     * `mirror-in-rtl` attribute.
     *
     * NOTE: For performance reasons, direction will be resolved once per
     * document per iconset, so moving icons in and out of RTL subtrees will
     * not cause their mirrored state to change.
     */
    rtlMirroring: {
      type: Boolean,
      value: false
    },

    /**
     * Set to true to measure RTL based on the dir attribute on the body or
     * html elements (measured on document.body or document.documentElement as
     * available).
     */
    useGlobalRtlAttribute: {
      type: Boolean,
      value: false
    }
  },

  created: function created() {
    this._meta = new Polymer.IronMeta({ type: 'iconset', key: null, value: null });
  },

  attached: function attached() {
    this.style.display = 'none';
  },

  /**
   * Construct an array of all icon names in this iconset.
   *
   * @return {!Array} Array of icon names.
   */
  getIconNames: function getIconNames() {
    this._icons = this._createIconMap();
    return Object.keys(this._icons).map(function (n) {
      return this.name + ':' + n;
    }, this);
  },

  /**
   * Applies an icon to the given element.
   *
   * An svg icon is prepended to the element's shadowRoot if it exists,
   * otherwise to the element itself.
   *
   * If RTL mirroring is enabled, and the icon is marked to be mirrored in
   * RTL, the element will be tested (once and only once ever for each
   * iconset) to determine the direction of the subtree the element is in.
   * This direction will apply to all future icon applications, although only
   * icons marked to be mirrored will be affected.
   *
   * @method applyIcon
   * @param {Element} element Element to which the icon is applied.
   * @param {string} iconName Name of the icon to apply.
   * @return {?Element} The svg element which renders the icon.
   */
  applyIcon: function applyIcon(element, iconName) {
    // Remove old svg element
    this.removeIcon(element);
    // install new svg element
    var svg = this._cloneIcon(iconName, this.rtlMirroring && this._targetIsRTL(element));
    if (svg) {
      // insert svg element into shadow root, if it exists
      var pde = Polymer.dom(element.root || element);
      pde.insertBefore(svg, pde.childNodes[0]);
      return element._svgIcon = svg;
    }
    return null;
  },

  /**
   * Remove an icon from the given element by undoing the changes effected
   * by `applyIcon`.
   *
   * @param {Element} element The element from which the icon is removed.
   */
  removeIcon: function removeIcon(element) {
    // Remove old svg element
    if (element._svgIcon) {
      Polymer.dom(element.root || element).removeChild(element._svgIcon);
      element._svgIcon = null;
    }
  },

  /**
   * Measures and memoizes the direction of the element. Note that this
   * measurement is only done once and the result is memoized for future
   * invocations.
   */
  _targetIsRTL: function _targetIsRTL(target) {
    if (this.__targetIsRTL == null) {
      if (this.useGlobalRtlAttribute) {
        var globalElement = document.body && document.body.hasAttribute('dir') ? document.body : document.documentElement;

        this.__targetIsRTL = globalElement.getAttribute('dir') === 'rtl';
      } else {
        if (target && target.nodeType !== Node.ELEMENT_NODE) {
          target = target.host;
        }

        this.__targetIsRTL = target && window.getComputedStyle(target)['direction'] === 'rtl';
      }
    }

    return this.__targetIsRTL;
  },

  /**
   *
   * When name is changed, register iconset metadata
   *
   */
  _nameChanged: function _nameChanged() {
    this._meta.value = null;
    this._meta.key = this.name;
    this._meta.value = this;

    this.async(function () {
      this.fire('iron-iconset-added', this, { node: window });
    });
  },

  /**
   * Create a map of child SVG elements by id.
   *
   * @return {!Object} Map of id's to SVG elements.
   */
  _createIconMap: function _createIconMap() {
    // Objects chained to Object.prototype (`{}`) have members. Specifically,
    // on FF there is a `watch` method that confuses the icon map, so we
    // need to use a null-based object here.
    var icons = Object.create(null);
    Polymer.dom(this).querySelectorAll('[id]').forEach(function (icon) {
      icons[icon.id] = icon;
    });
    return icons;
  },

  /**
   * Produce installable clone of the SVG element matching `id` in this
   * iconset, or `undefined` if there is no matching element.
   *
   * @return {Element} Returns an installable clone of the SVG element
   * matching `id`.
   */
  _cloneIcon: function _cloneIcon(id, mirrorAllowed) {
    // create the icon map on-demand, since the iconset itself has no discrete
    // signal to know when it's children are fully parsed
    this._icons = this._icons || this._createIconMap();
    return this._prepareSvgClone(this._icons[id], this.size, mirrorAllowed);
  },

  /**
   * @param {Element} sourceSvg
   * @param {number} size
   * @param {Boolean} mirrorAllowed
   * @return {Element}
   */
  _prepareSvgClone: function _prepareSvgClone(sourceSvg, size, mirrorAllowed) {
    if (sourceSvg) {
      var content = sourceSvg.cloneNode(true),
          svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg'),
          viewBox = content.getAttribute('viewBox') || '0 0 ' + size + ' ' + size,
          cssText = 'pointer-events: none; display: block; width: 100%; height: 100%;';

      if (mirrorAllowed && content.hasAttribute('mirror-in-rtl')) {
        cssText += '-webkit-transform:scale(-1,1);transform:scale(-1,1);';
      }

      svg.setAttribute('viewBox', viewBox);
      svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');
      svg.setAttribute('focusable', 'false');
      // TODO(dfreedm): `pointer-events: none` works around https://crbug.com/370136
      // TODO(sjmiles): inline style may not be ideal, but avoids requiring a shadow-root
      svg.style.cssText = cssText;
      svg.appendChild(content).removeAttribute('id');
      return svg;
    }
    return null;
  }

});

/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgZTUwOTNkNWQxZDc1MDZkNTQ5ODQiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL3BvbHltZXIuaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL3BvbHltZXIvbGliL3V0aWxzL2Jvb3QuaHRtbCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcG9seW1lci13ZWJwYWNrLWxvYWRlci9yZWdpc3Rlci1odG1sLXRlbXBsYXRlLmpzIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvdXRpbHMvbWl4aW4uaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL2FwcC1sYXlvdXQvYXBwLXNjcm9sbC1lZmZlY3RzL2FwcC1zY3JvbGwtZWZmZWN0cy1iZWhhdmlvci5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvaXJvbi1mbGV4LWxheW91dC9pcm9uLWZsZXgtbGF5b3V0Lmh0bWwiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL3BvbHltZXItZWxlbWVudC5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvdXRpbHMvcmVzb2x2ZS11cmwuaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL3BvbHltZXIvbGliL3V0aWxzL2FzeW5jLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi9taXhpbnMvbXV0YWJsZS1kYXRhLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi91dGlscy9jYXNlLW1hcC5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvbWl4aW5zL3Byb3BlcnR5LWVmZmVjdHMuaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL3BvbHltZXIvbGliL3V0aWxzL2RlYm91bmNlLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi91dGlscy9mbHVzaC5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvdXRpbHMvdGVtcGxhdGl6ZS5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvYXBwLWxheW91dC9hcHAtbGF5b3V0LWJlaGF2aW9yL2FwcC1sYXlvdXQtYmVoYXZpb3IuaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL3BvbHltZXIvbGliL21peGlucy9lbGVtZW50LW1peGluLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi91dGlscy9zZXR0aW5ncy5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvdXRpbHMvc3R5bGUtZ2F0aGVyLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi9sZWdhY3kvbGVnYWN5LWVsZW1lbnQtbWl4aW4uaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL3BvbHltZXIvbGliL21peGlucy9nZXN0dXJlLWV2ZW50LWxpc3RlbmVycy5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvdXRpbHMvYXJyYXktc3BsaWNlLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9pcm9uLXJlc2l6YWJsZS1iZWhhdmlvci9pcm9uLXJlc2l6YWJsZS1iZWhhdmlvci5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvYXBwLWxheW91dC9hcHAtc2Nyb2xsLWVmZmVjdHMvZWZmZWN0cy9ibGVuZC1iYWNrZ3JvdW5kLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9hcHAtbGF5b3V0L2FwcC1zY3JvbGwtZWZmZWN0cy9lZmZlY3RzL3dhdGVyZmFsbC5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvYXBwLWxheW91dC9hcHAtc2Nyb2xsLWVmZmVjdHMvZWZmZWN0cy9yZXNpemUtdGl0bGUuaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL2FwcC1sYXlvdXQvYXBwLXNjcm9sbC1lZmZlY3RzL2VmZmVjdHMvcGFyYWxsYXgtYmFja2dyb3VuZC5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvaXJvbi1zZWxlY3Rvci9pcm9uLXNlbGVjdGFibGUuaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL2lyb24tbWV0YS9pcm9uLW1ldGEuaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL2lyb24tYTExeS1rZXlzLWJlaGF2aW9yL2lyb24tYTExeS1rZXlzLWJlaGF2aW9yLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vc3JjL215LWFwcC5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvZWxlbWVudHMvZG9tLW1vZHVsZS5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvdXRpbHMvcGF0aC5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvbWl4aW5zL3Byb3BlcnR5LWFjY2Vzc29ycy5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvbWl4aW5zL3RlbXBsYXRlLXN0YW1wLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9hcHAtbGF5b3V0L2FwcC1kcmF3ZXIvYXBwLWRyYXdlci5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvc2hhZHljc3MvYXBwbHktc2hpbS5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvc2hhZHljc3MvYXBwbHktc2hpbS5taW4uanMiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi91dGlscy9nZXN0dXJlcy5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvdXRpbHMvaW1wb3J0LWhyZWYuaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL3BvbHltZXIvbGliL3V0aWxzL3JlbmRlci1zdGF0dXMuaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL3BvbHltZXIvbGliL3V0aWxzL3VucmVzb2x2ZWQuaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL3BvbHltZXIvbGliL2xlZ2FjeS9wb2x5bWVyLmRvbS5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvdXRpbHMvZmxhdHRlbmVkLW5vZGVzLW9ic2VydmVyLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi9sZWdhY3kvcG9seW1lci1mbi5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvbGVnYWN5L2NsYXNzLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi9sZWdhY3kvdGVtcGxhdGl6ZXItYmVoYXZpb3IuaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL3BvbHltZXIvbGliL2VsZW1lbnRzL2RvbS1iaW5kLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi9lbGVtZW50cy9kb20tcmVwZWF0Lmh0bWwiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi9lbGVtZW50cy9kb20taWYuaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL3BvbHltZXIvbGliL2VsZW1lbnRzL2FycmF5LXNlbGVjdG9yLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi9lbGVtZW50cy9jdXN0b20tc3R5bGUuaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL3NoYWR5Y3NzL2N1c3RvbS1zdHlsZS1pbnRlcmZhY2UuaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL3NoYWR5Y3NzL2N1c3RvbS1zdHlsZS1pbnRlcmZhY2UubWluLmpzIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvbGVnYWN5L211dGFibGUtZGF0YS1iZWhhdmlvci5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvYXBwLWxheW91dC9hcHAtZHJhd2VyLWxheW91dC9hcHAtZHJhd2VyLWxheW91dC5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvaXJvbi1tZWRpYS1xdWVyeS9pcm9uLW1lZGlhLXF1ZXJ5Lmh0bWwiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9hcHAtbGF5b3V0L2FwcC1oZWFkZXIvYXBwLWhlYWRlci5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvaXJvbi1zY3JvbGwtdGFyZ2V0LWJlaGF2aW9yL2lyb24tc2Nyb2xsLXRhcmdldC1iZWhhdmlvci5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvYXBwLWxheW91dC9oZWxwZXJzL2hlbHBlcnMuaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL2FwcC1sYXlvdXQvYXBwLWhlYWRlci1sYXlvdXQvYXBwLWhlYWRlci1sYXlvdXQuaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL2FwcC1sYXlvdXQvYXBwLXNjcm9sbC1lZmZlY3RzL2FwcC1zY3JvbGwtZWZmZWN0cy5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvYXBwLWxheW91dC9hcHAtc2Nyb2xsLWVmZmVjdHMvZWZmZWN0cy9mYWRlLWJhY2tncm91bmQuaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL2FwcC1sYXlvdXQvYXBwLXNjcm9sbC1lZmZlY3RzL2VmZmVjdHMvbWF0ZXJpYWwuaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL2FwcC1sYXlvdXQvYXBwLXNjcm9sbC1lZmZlY3RzL2VmZmVjdHMvcmVzaXplLXNuYXBwZWQtdGl0bGUuaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL2FwcC1sYXlvdXQvYXBwLXRvb2xiYXIvYXBwLXRvb2xiYXIuaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL2FwcC1yb3V0ZS9hcHAtbG9jYXRpb24uaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL2lyb24tbG9jYXRpb24vaXJvbi1sb2NhdGlvbi5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvaXJvbi1sb2NhdGlvbi9pcm9uLXF1ZXJ5LXBhcmFtcy5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvYXBwLXJvdXRlL2FwcC1yb3V0ZS1jb252ZXJ0ZXItYmVoYXZpb3IuaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL2FwcC1yb3V0ZS9hcHAtcm91dGUuaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL2lyb24tcGFnZXMvaXJvbi1wYWdlcy5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvaXJvbi1zZWxlY3Rvci9pcm9uLXNlbGVjdGlvbi5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvaXJvbi1zZWxlY3Rvci9pcm9uLXNlbGVjdG9yLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9pcm9uLXNlbGVjdG9yL2lyb24tbXVsdGktc2VsZWN0YWJsZS5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvcGFwZXItaWNvbi1idXR0b24vcGFwZXItaWNvbi1idXR0b24uaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL2lyb24taWNvbi9pcm9uLWljb24uaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL3BhcGVyLWJlaGF2aW9ycy9wYXBlci1pbmt5LWZvY3VzLWJlaGF2aW9yLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9pcm9uLWJlaGF2aW9ycy9pcm9uLWJ1dHRvbi1zdGF0ZS5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvaXJvbi1iZWhhdmlvcnMvaXJvbi1jb250cm9sLXN0YXRlLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9wYXBlci1iZWhhdmlvcnMvcGFwZXItcmlwcGxlLWJlaGF2aW9yLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9wYXBlci1yaXBwbGUvcGFwZXItcmlwcGxlLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9wYXBlci1zdHlsZXMvZGVmYXVsdC10aGVtZS5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvcGFwZXItc3R5bGVzL2NvbG9yLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vc3JjL215LWljb25zLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9pcm9uLWljb25zZXQtc3ZnL2lyb24taWNvbnNldC1zdmcuaHRtbCJdLCJuYW1lcyI6WyJSZWdpc3Rlckh0bWxUZW1wbGF0ZSIsInZhbCIsImNvbnRlbnQiLCJ0ZW1wbGF0ZSIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImlubmVySFRNTCIsImNyZWF0ZURvY3VtZW50RnJhZ21lbnQiLCJmaXJzdENoaWxkIiwiYXBwZW5kQ2hpbGQiLCJpbXBvcnROb2RlIiwidHJpbW1lZFZhbCIsInRyaW0iLCJkaXYiLCJib2R5IiwiaW5zZXJ0QmVmb3JlIiwiYWRkRXZlbnRMaXN0ZW5lciIsIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIiwidG9Cb2R5IiwiayIsIm4iLCJlbmQiLCJzdGFydCIsInJ1bGVzIiwicGFyZW50IiwicHJldmlvdXMiLCJjc3NUZXh0IiwicGFyc2VkQ3NzVGV4dCIsImF0UnVsZSIsInR5cGUiLCJwYXJzZWRTZWxlY3RvciIsInNlbGVjdG9yIiwia2V5ZnJhbWVzTmFtZSIsInAiLCJhIiwicmVwbGFjZSIsImFhIiwiYmEiLCJiIiwicSIsImMiLCJkIiwibGVuZ3RoIiwiZSIsImYiLCJoIiwiZyIsIm0iLCJwdXNoIiwic3Vic3RyaW5nIiwiY2EiLCJyIiwibGFzdEluZGV4T2YiLCJpbmRleE9mIiwidCIsIm1hdGNoIiwiZGEiLCJ1Iiwic3BsaXQiLCJwb3AiLCJ2IiwieCIsInkiLCJlYSIsImZhIiwiaGEiLCJpYSIsImphIiwiUHJvbWlzZSIsInJlc29sdmUiLCJrYSIsIl9hcHBseVNoaW1DdXJyZW50VmVyc2lvbiIsIl9hcHBseVNoaW1WYWxpZGF0aW5nVmVyc2lvbiIsIl9hcHBseVNoaW1OZXh0VmVyc2lvbiIsInoiLCJsYSIsInRoZW4iLCJBIiwid2luZG93IiwiU2hhZHlET00iLCJpblVzZSIsIkIiLCJDIiwic2hpbWNzc3Byb3BlcnRpZXMiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJDU1MiLCJzdXBwb3J0cyIsIlNoYWR5Q1NTIiwibmF0aXZlQ3NzIiwiV2ViQ29tcG9uZW50cyIsImZsYWdzIiwiRSIsIkYiLCJHIiwibWEiLCJIIiwiSSIsIl9fY3NzUnVsZXMiLCJ0ZXh0Q29udGVudCIsIkoiLCJtYXRjaE1lZGlhIiwibWF0Y2hlcyIsIksiLCJuYSIsIm9hIiwiTCIsInByb3RvdHlwZSIsInNldCIsImkiLCJnZXQiLCJNIiwiTiIsIm8iLCJ0ZXN0IiwibGFzdEluZGV4IiwicXVlcnlTZWxlY3RvciIsImoiLCJsIiwicGEiLCJxYSIsIk8iLCJleGVjIiwiaW5kZXgiLCJzbGljZSIsIlAiLCJqb2luIiwic2V0QXR0cmlidXRlIiwic3R5bGUiLCJhbGwiLCJoZWFkIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImdldFByb3BlcnR5VmFsdWUiLCJyYSIsIk9iamVjdCIsImFzc2lnbiIsImNyZWF0ZSIsIlgiLCJ3IiwiWSIsIkQiLCJkZXRlY3RNaXhpbiIsInRyYW5zZm9ybVN0eWxlIiwidHJhbnNmb3JtQ3VzdG9tU3R5bGUiLCJ0cmFuc2Zvcm1SdWxlcyIsInRyYW5zZm9ybVJ1bGUiLCJ0cmFuc2Zvcm1UZW1wbGF0ZSIsIl9zZXBhcmF0b3IiLCJkZWZpbmVQcm9wZXJ0eSIsIlEiLCJSIiwiSFRNTEltcG9ydHMiLCJ3aGVuUmVhZHkiLCJTIiwic2EiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJyZWFkeVN0YXRlIiwiVCIsIlUiLCJWIiwiaW52YWxpZENhbGxiYWNrIiwiQ3VzdG9tU3R5bGVJbnRlcmZhY2UiLCJ0cmFuc2Zvcm1DYWxsYmFjayIsInZhbGlkYXRlQ2FsbGJhY2siLCJlbnF1ZXVlZCIsIlciLCJwcmVwYXJlVGVtcGxhdGUiLCJfc3R5bGVBc3QiLCJwcm9jZXNzU3R5bGVzIiwiZ2V0U3R5bGVGb3JDdXN0b21TdHlsZSIsInN0eWxlU3VidHJlZSIsInJlbW92ZVByb3BlcnR5Iiwic2V0UHJvcGVydHkiLCJzaGFkb3dSb290Iiwic3R5bGVFbGVtZW50IiwiY2hpbGRyZW4iLCJjaGlsZE5vZGVzIiwibG9jYWxOYW1lIiwiZ2V0QXR0cmlidXRlIiwiaXMiLCJzdHlsZURvY3VtZW50IiwiU2NvcGluZ1NoaW0iLCJaIiwidGEiLCJnZXRDb21wdXRlZFN0eWxlVmFsdWUiLCJuYXRpdmVTaGFkb3ciLCJBcHBseVNoaW0iLCJjYWxsIiwiY3VzdG9tU3R5bGVzIiwiX19zZWVuQnlTaGFkeUNTUyIsIl9fc2hhZHlDU1NDYWNoZWRTdHlsZSIsImdldFN0eWxlIiwiX19hcHBsaWVkRWxlbWVudCIsImFkZEN1c3RvbVN0eWxlIiwiZGVmaW5lUHJvcGVydGllcyJdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFRLG9CQUFvQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUEwQyxXQUFXLEVBQUU7QUFDdkQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQTJCLDBCQUEwQixFQUFFO0FBQ3ZELHlDQUFpQyxlQUFlO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhEQUFzRCwrREFBK0Q7O0FBRXJIO0FBQ0E7O0FBRUE7QUFDQSxrREFBMEMsb0JBQW9CLFdBQVc7O0FBRXpFO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDeEhTLFFBQU0sT0FBUyxRQUFtQixtQkFBYSxhQUFVLFU7Ozs7Ozs7OztBQ2JsRSxDQUFVLFlBQUU7QUFDRTs7QUFFWixNQUFrQixjQUFRLE9BQVE7Ozs7Ozs7Ozs7Ozs7O0FBYzVCLFNBQVMsVUFBVSxVQUFLLE1BQUU7QUFDOUIsV0FBYSxPQUFRLFFBQVcsV0FDbEM7Ozs7QUFHRyxNQUFZLGFBQUU7QUFDVCxXQUFPLE9BQVEsU0FDdkI7Ozs7Ozs7Ozs7Ozs7QUFZTSxTQUFRLFFBQVksYUFBVSxVQUFLLE1BQUU7O0FBQ3pDLFVBQU0sSUFBUyxNQUNqQjs7OztBQUdNLFNBQVEsUUFBUyxVQUFTOzs7Ozs7O0FBTzFCLFNBQTJCLDRCQUFVLFVBQUssTUFBSyxLQUFFO0FBQ3JELFdBQ0Y7O0FBR0Y7QUFBSSxLOzs7Ozs7Ozs7Ozs7O0FDL0RKOztJQUVNQSxvQjs7Ozs7Ozs7QUFDSjs7Ozs7Ozs7Ozs2QkFVZ0JDLEcsRUFBSztBQUNuQixVQUFJQyxnQkFBSjtBQUNBLFVBQU1DLFdBQVdDLFNBQVNDLGFBQVQsQ0FBdUIsVUFBdkIsQ0FBakI7QUFDQUYsZUFBU0csU0FBVCxHQUFxQkwsR0FBckI7QUFDQSxVQUFJRSxTQUFTRCxPQUFiLEVBQXNCO0FBQ3BCQSxrQkFBVUMsU0FBU0QsT0FBbkIsQ0FEb0IsQ0FDUTtBQUM3QixPQUZELE1BRU87QUFDTEEsa0JBQVVFLFNBQVNHLHNCQUFULEVBQVY7QUFDQSxlQUFPSixTQUFTSyxVQUFoQixFQUE0QjtBQUMxQk4sa0JBQVFPLFdBQVIsQ0FBb0JOLFNBQVNLLFVBQTdCO0FBQ0Q7QUFDRjtBQUNESixlQUFTTSxVQUFULENBQW9CUixPQUFwQixFQUE2QixJQUE3QjtBQUNEO0FBQ0Q7Ozs7Ozs7Ozs7MkJBT2NELEcsRUFBSztBQUNqQixVQUFNVSxhQUFhVixJQUFJVyxJQUFKLEVBQW5CO0FBQ0EsVUFBSUQsVUFBSixFQUFnQjtBQUNkLFlBQU1FLE1BQU1ULFNBQVNDLGFBQVQsQ0FBdUIsS0FBdkIsQ0FBWjtBQUNBUSxZQUFJUCxTQUFKLEdBQWdCSyxVQUFoQjtBQUNBLFlBQUlFLElBQUlMLFVBQVIsRUFBb0I7QUFDbEIsY0FBSUosU0FBU1UsSUFBYixFQUFtQjtBQUNqQlYscUJBQVNVLElBQVQsQ0FBY0MsWUFBZCxDQUEyQkYsSUFBSUwsVUFBL0IsRUFBMkNKLFNBQVNVLElBQVQsQ0FBY04sVUFBekQ7QUFDRCxXQUZELE1BRU87QUFDTEoscUJBQVNZLGdCQUFULENBQTBCLGtCQUExQixFQUE4QyxZQUFNO0FBQ2xEWix1QkFBU1UsSUFBVCxDQUFjQyxZQUFkLENBQTJCRixJQUFJTCxVQUEvQixFQUEyQ0osU0FBU1UsSUFBVCxDQUFjTixVQUF6RDtBQUNELGFBRkQ7QUFHRDtBQUNGO0FBQ0Y7QUFDRjs7Ozs7O0FBR0hTLE9BQU9DLE9BQVAsR0FBaUJsQixvQkFBakIsQzs7Ozs7Ozs7Ozs7QUN0Q0EsQ0FBVSxZQUFFOztBQUVFOzs7O0FBR1osTUFBYSxXQUFHOzs7Ozs7QUFNaEIsV0FBdUIsZ0JBQUU7O0FBRVosZ0JBQVUsVUFBb0I7O0FBRTlCLGdCQUFVLFVBQVc7Ozs7Ozs7Ozs7Ozs7QUFhM0IsVUFBZSxnQkFBVSxVQUFNLE9BQUU7QUFDdEMsUUFBc0IsaURBQXNDLEtBQVAsQ0FBMkI7QUFDN0UsUUFBQyxDQUFrQixtQkFBRTtBQUNKLDBCQUFFLElBQWE7bUNBQ0csS0FBUCxDQUE0QixzQkFDM0Q7OztBQUVBLFFBQWtCLGdCQUFZO0FBQzlCLGFBQXNCLGNBQUssTUFBRTtBQUMzQixVQUFZLHVDQUFxQyxJQUFOLENBQWlCO0FBQ3pELFVBQVMsV0FBVSxRQUFlLGdCQUFFO0FBQ3JDLGVBQ0Y7O0FBQ0EsVUFBUSxNQUFtQjtBQUMzQixVQUFhLFdBQUssSUFBSSxJQUFNO0FBQ3pCLFVBQUMsQ0FBUyxVQUFFO0FBQ0osMkNBQWlDLEtBQVAsQ0FBYTtBQUM3QyxZQUFJLElBQUssTUFDZDs7Ozs7QUFJQSxVQUFhLFdBQVEsT0FBTyxxQ0FBd0MsUUFBVixDQUFzQixjQUFXLFdBQVE7QUFDM0YsZUFBZ0IsaUJBQU07bUNBQ1MsUUFBVixDQUFzQixhQUFVO0FBQzdELGFBQ0Y7OztBQUVBLFdBQ0Y7QUFBQztBQUdIO0FBQUksSzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDNEJLLFFBQTBCLDRCQUN4QixRQUF5Qjs7QUFHdEI7Ozs7OztBQU1EO0FBQ0QsWUFDTDtBQUZROzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFvQkk7QUFDUCxZQUFRO0FBQ1AsYUFBVyxpQkFBRTtBQUNoQixlQUNGO0FBQ0Q7QUFMYzs7Ozs7QUFVUDtBQUNGLFlBQVM7QUFDSywwQkFBTTtBQUNuQixhQUNOO0FBSlM7Ozs7Ozs7OztBQWFEO0FBQ0gsWUFBUTtBQUNQLGFBQ047QUFIVTs7Ozs7O0FBU087QUFDWixZQUFTO0FBQ1AsY0FBTTtBQUNKLGdCQUFNO0FBQ0ksMEJBRXJCO0FBTnFCO0FBMURWOztBQWtFSCxhQUFFLENBRVY7Ozs7Ozs7O0FBUWlCLHNCQUFXLDhCQUFHLENBQUM7Ozs7Ozs7Ozs7QUFVdkIsY0FBVyxzQkFBRTtBQUNyQixXQUNGO0FBQUM7Ozs7Ozs7OztBQVNhLGtCQUFXLDBCQUFFO0FBQ3pCLFdBQ0Y7QUFBQzs7Ozs7OztBQU9ZLGlCQUFNOzs7Ozs7O0FBT1gsWUFBTTs7Ozs7O0FBTWQsTUFBc0Isb0JBQUU7QUFDdEIsV0FBVyxLQUFJLElBQUUsR0FBTSxLQUN6QjtBQUFDOztBQUVPLFlBQVcsb0JBQUU7QUFDZixTQUNOO0FBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBdUJXLGdCQUFVLHNCQUFXLFlBQWMsY0FBRTtBQUMvQyxRQUFjLFlBQVMsUUFBVSxVQUFlLGVBQVk7QUFDekQsUUFBQyxDQUFVLFdBQUU7QUFDZCxZQUFNLElBQWtCLGVBQUssS0FBaUIsaUJBQ2hEOztBQUNBLFFBQVMsT0FBTSxLQUFhLGFBQVUsV0FBZSxnQkFBTTtBQUN2RCxTQUFRO0FBQ1osV0FDRjtBQUFDOzs7OztBQUtjLG1CQUFVLHlCQUFRLFNBQWUsZUFBWSxZQUFFO0FBQ3hELFNBQW1COztBQUVwQixRQUFDLENBQVMsV0FBRyxDQUFXLFlBQUU7QUFFN0I7O0FBQ08sWUFBTSxNQUFLLEtBQVEsUUFBUyxVQUFXLFlBQUU7QUFDOUMsVUFBYTtBQUNWLFVBQVksZUFBTSxJQUFFO0FBQ2pCLFlBQVcsWUFBUyxRQUFVLFVBQWUsZUFBYSxhQUFFO0FBQzFELGVBQVMsU0FBSyxLQUFLLEtBQWEsYUFBVSxXQUFlLGNBQy9EO0FBQUUsZUFBSztBQUNFLGtCQUFLLEtBQUssS0FBaUIsaUJBQ3BDO0FBQ0Y7QUFDRjtBQUFDLE9BQU87O0FBRUosU0FDTjtBQUFDOzs7OztBQUthLGtCQUFXLDBCQUFFO0FBQ3pCLFdBQVcsS0FDYjtBQUFDOzs7Ozs7OztBQVFXLGdCQUFVLHNCQUFVLFdBQWUsZUFBRTtBQUNqQyxvQkFBZ0IsaUJBQUs7QUFDbkMsUUFBYSxXQUFZLFdBQWMsY0FBVSxZQUFLO0FBQ3RELFFBQVcsU0FBWSxXQUFjLGNBQVEsVUFBSztBQUNsRCxRQUFXLFNBQVMsU0FBVTtBQUM5QixRQUFTLE9BQVcsZ0JBQUcsQ0FBQzs7QUFFeEIsUUFBVSxRQUFZLGFBQU0sS0FBVSxXQUFPLENBQWpDLEdBQTRDLFVBQUssTUFDbkQsVUFBUyxVQUFHLEdBQUU7QUFDWCxnQkFBSSxJQUFLLEtBQUssTUFDZixLQUFJLElBQUUsR0FBRSxDQUFVLFdBQVksWUFBUyxTQUNqRDtBQUFDO0FBQ0g7QUFDTyxhQUFXLFVBQU8sUUFBVyxVQUFNLE1BQUssS0FBSyxNQUFpQixpQkFBTTtBQUN0RSxXQUFXLFVBQUssTUFBTyxNQUFLLEtBQU8sUUFBTTtBQUNwQyxnQkFBVyxVQUFVLFdBQVcsVUFBUyxTQUFLLEtBQU8sUUFFakU7QUFMUztBQUtSOzs7OztBQUtXLGdCQUFXLHdCQUFFO0FBQ3BCLFFBQUssS0FBWSxjQUFPLEtBQVMsVUFBRTtBQUNoQyxXQUFlLGdCQUFJO0FBQ25CLFdBQVMsU0FBUSxRQUFTLFVBQVUsV0FBRTs7QUFFckMsWUFBVSxVQUFTLFlBQVMsT0FBRTtBQUMzQixlQUFjLGNBQUssS0FBVSxVQUNuQztBQUNGO0FBQUMsU0FDSDtBQUNGO0FBQUM7Ozs7O0FBS2Usb0JBQVcsNEJBQUU7QUFDeEIsUUFBSyxLQUFTLFVBQUU7QUFDYixXQUFTLFNBQVEsUUFBUyxVQUFVLFdBQUU7QUFDL0Isa0JBQ1g7QUFDRjs7QUFDSSxTQUFlLGdCQUFJO0FBQ25CLFNBQVUsV0FDaEI7QUFBQzs7Ozs7Ozs7QUFRVSxlQUFVLHFCQUFFLEdBQUcsR0FBRTtBQUN2QixRQUFLLEtBQWMsZUFBRTtBQUNsQixXQUFjLGNBQVEsUUFBUyxVQUFJLEtBQUU7QUFDcEMsWUFBRSxHQUNQO0FBQ0Y7QUFDRjtBQUFDOzs7OztBQUthLGtCQUFXLDBCQUFFO0FBQ3RCLFFBQUMsQ0FBSyxLQUFTLFVBQUU7QUFDbEIsVUFBYyxZQUFNLEtBQWtCO0FBQ2xDLFdBQW1CLG1CQUFXO0FBQy9CLFVBQUssS0FBVyxZQUFHLEdBQUU7QUFDbEIsYUFBdUIsdUJBQVcsYUFBTyxLQUMvQztBQUNGO0FBQ0Y7QUFBQzs7Ozs7Ozs7QUFRUyxjQUFVLG9CQUFHLElBQUU7QUFDaEIsWUFBSyxLQUFhLGNBQUssTUFBSyxLQUNyQztBQUFDOztBQUVlLG9CQUFVLDBCQUFXLFlBQUU7QUFDckMsV0FBeUIsb0JBQWEsYUFBcUIscUJBQ1csb0VBQWEsYUFDckY7QUFFQTs7QUE3UkQsQ0FGa0MsRTs7Ozs7Ozs7O0FDckdyQyxtQkFBQW1CLENBQVEsQ0FBUjs7QUFFQSxJQUFNbkIsdUJBQXVCLG1CQUFBbUIsQ0FBUSxDQUFSLENBQTdCOztBQUVBbkIscUJBQXFCb0IsTUFBckIsQ0FBNEIsOHpJQUE1QixFOzs7Ozs7Ozs7OztBQ01BLENBQVUsWUFBRTtBQUNFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBa0JaLE1BQWMsVUFBUyxRQUFhLGFBQWE7Ozs7OztBQU0xQyxVQUFTLFVBQ2xCO0FBQUksSzs7Ozs7Ozs7Ozs7QUN4QkYsQ0FBVSxZQUFFO0FBQ0U7O0FBRVosTUFBZSxhQUF1QjtBQUN0QyxNQUFZLFVBQTJCO0FBQ3ZDLE1BQWM7QUFDZCxNQUFjOzs7Ozs7Ozs7QUFTZCxXQUFtQixXQUFJLEtBQVMsU0FBRTtBQUM3QixRQUFLLE9BQVUsUUFBSyxLQUFLLE1BQUU7QUFDNUIsYUFDRjs7O0FBRUcsUUFBWSxlQUFhLFdBQUU7QUFDakIsbUJBQU87QUFDbEIsVUFBSTtBQUNGLFlBQVEsSUFBRSxJQUFPLElBQUksS0FBYTtBQUNqQyxVQUFVLFdBQVM7QUFDUCxxQkFBRSxFQUFNLFNBQ3ZCO1FBQVEsT0FBRSxHQUFFO0FBRVo7QUFDRjs7QUFDRyxRQUFDLENBQVEsU0FBRTtBQUNKLGdCQUFVLFNBQVMsV0FBUyxPQUFTLFNBQy9DOztBQUNHLFFBQVcsWUFBRTtBQUNkLGFBQVEsSUFBTyxJQUFJLEtBQVcsUUFBdkIsQ0FDVDs7O0FBRUcsUUFBQyxDQUFXLFlBQUU7QUFDSixtQkFBVSxTQUFlLGVBQW1CLG1CQUFRO0FBQ3JELGlCQUFNLE9BQVksV0FBYyxjQUFRO0FBQ3hDLGlCQUFLLEtBQVksWUFBVyxXQUFNO0FBQ2xDLGlCQUFRLFNBQVksV0FBYyxjQUFLO0FBQ3ZDLGlCQUFLLEtBQVksWUFBVyxXQUN4Qzs7QUFDVSxlQUFLLEtBQU0sT0FBUztBQUNwQixlQUFPLE9BQU0sT0FBSztBQUM1QixXQUFpQixXQUFPLE9BQU0sUUFFaEM7Ozs7Ozs7Ozs7OztBQVdBLFdBQW1CLFdBQVEsU0FBUyxTQUFFO0FBQ3BDLG1CQUFzQixRQUFXLFlBQVUsVUFBRSxHQUFLLEtBQUssS0FBTSxNQUFFO0FBQzdELGFBQVcsTUFBTyxPQUNOLFdBQUksSUFBUSxRQUFRLFNBQUssS0FBVyxXQUN6QyxPQUNUO0FBQ0YsS0FMZ0I7Ozs7Ozs7Ozs7O0FBZWhCLFdBQW9CLFlBQUksS0FBRTtBQUN4QixXQUFVLElBQVUsVUFBRSxHQUFLLElBQVksWUFBTSxPQUMvQzs7Ozs7Ozs7OztBQVNPLFVBQVk7QUFDUCxnQkFBWTtBQUNaLGdCQUFZO0FBQ1gsaUJBR2Y7QUFOdUI7QUFNbkIsSzs7Ozs7Ozs7Ozs7QUM3Rk4sQ0FBVSxZQUFFOztBQUVFOzs7O0FBR1osTUFBa0I7OztBQUdsQixNQUF3QixzQkFBRztBQUMzQixNQUF3QixzQkFBRztBQUMzQixNQUF1QixxQkFBSTtBQUMzQixNQUF5Qix1QkFBRztBQUM1QixNQUFrQixnQkFBVSxTQUFlLGVBQUk7QUFDL0MsTUFBVSxPQUFpQixpQkFBZ0IsZ0JBQVEsUUFBYyxlQUFFLEVBQWMsZUFBUTs7QUFFekYsV0FBd0IsaUJBQUU7QUFDeEIsUUFBVSxNQUFvQixtQkFBTztBQUNqQyxTQUFDLElBQU0sSUFBRyxHQUFJLElBQUssS0FBSyxLQUFFO0FBQzVCLFVBQU8sS0FBb0IsbUJBQUc7QUFDM0IsVUFBRyxJQUFFO0FBQ04sWUFBSTtBQUVKO1VBQVEsT0FBRSxHQUFFO0FBQ0EscUJBQUksWUFBRztBQUFFLGtCQUFRO0FBQzdCO0FBQ0Y7QUFDRjs7QUFDa0IsdUJBQU8sT0FBRSxHQUFNO0FBQ2IsMkJBQ3RCOzs7Ozs7Ozs7Ozs7OztBQWFPLFVBQU87Ozs7Ozs7OztBQVNMOzs7Ozs7Ozs7QUFTQSw0QkFBTSxPQUFFO0FBQ1g7QUFDSyw0QkFBRyxJQUFFO0FBQUUsbUJBQWlCLFdBQUcsSUFBUztBQUFDOztBQUNsQyxrQkFBUSxPQUFhLGFBQUssS0FFcEM7QUFKVTtBQUlUOzs7Ozs7Ozs7QUFRRSxXQUFRLE9BQVcsV0FBSyxLQUFROzs7Ozs7O0FBTzdCLGNBQVEsT0FBYSxhQUFLLEtBQ2pDO0FBOUJROzs7Ozs7Ozs7QUF1Q0s7Ozs7Ozs7O0FBUVQsV0FBUSxPQUFzQixzQkFBSyxLQUFROzs7Ozs7O0FBT3hDLGNBQVEsT0FBcUIscUJBQUssS0FDekM7QUFoQmU7Ozs7Ozs7Ozs7QUEwQk47Ozs7Ozs7O0FBUUwsd0JBQUcsSUFBRTtBQUNOLGVBQWEsT0FBcUIsc0JBQzFCLE9BQW9CLG9CQUFLLE1BQ3pCLE9BQVcsV0FBRyxJQUN4QjtBQUFDOzs7Ozs7OztBQU9LLDhCQUFPLFFBQUU7QUFDUCxlQUFvQixxQkFDbEIsT0FBbUIsbUJBQVMsVUFDNUIsT0FBYSxhQUN2QjtBQUNEO0FBeEJXOzs7Ozs7Ozs7Ozs7Ozs7O0FBd0NIOzs7Ozs7Ozs7QUFTSix3QkFBUyxVQUFFO0FBQ0Msc0JBQWEsY0FBd0I7QUFDaEMsMkJBQUssS0FBVTtBQUNqQyxlQUNGO0FBQUM7Ozs7Ozs7OztBQVFLLDhCQUFPLFFBQUU7QUFDYixZQUFVLE1BQVMsU0FBcUI7QUFDckMsWUFBSyxPQUFJLEdBQUU7QUFDVCxjQUFDLENBQW1CLG1CQUFLLE1BQUU7QUFDNUIsa0JBQU0sSUFBUyxNQUEwQiwyQkFDM0M7O0FBQ2tCLDZCQUFNLE9BQzFCO0FBQ0Y7QUFLTjtBQWxDZTtBQWxIRztBQW9KZCxLOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM3TEosQ0FBVSxZQUFFO0FBQ0U7Ozs7QUFHWixXQUE4QixzQkFBSyxNQUFVLFVBQU8sT0FBSyxLQUFhLGFBQUU7QUFDdEUsUUFBWTtBQUNULFFBQVksYUFBRTtBQUNKLGlCQUFDLFFBQWEsMERBQWEsWUFBUyxVQUFTOztBQUVyRCxVQUFTLFVBQUU7QUFDUixjQUFNLEtBQVcsV0FDdkI7QUFDRjs7O0FBRUEsUUFBbUIsZUFBSyxRQUFhLFVBQUssUUFBUSxPQUFTLFVBQVc7OztBQUduRSxRQUFVLFlBQWUsY0FBRTtBQUN4QixXQUFXLFdBQVcsWUFDNUI7O0FBQ0EsV0FDRjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXVDTyxVQUFhLHNCQUF1QixjQUFZOztBQU9yRDs7Ozs7QUFQd0QsUUFPdEM7Ozs7Ozs7Ozs7OztBQWtCSzs7Ozs7Ozs7Ozs7Ozs7Ozs7OENBQVMsVUFBTyxPQUFLLEtBQUU7QUFDMUMsaUJBQTRCLHNCQUFLLE1BQVUsVUFBTyxPQUFLLEtBQ3pEO0FBRUY7Ozs7TUF0QnFDOzs7O0FBd0IxQixnQkFBVSxVQUFhLGNBQU87O0FBRXpDLFdBRUY7QUFBRSxHQW5DMkI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE0RXRCLFVBQXFCLDhCQUF1QixjQUFZOztBQU83RDs7Ozs7QUFQZ0UsUUFPdEM7Ozs7Ozs7Ozs7Ozs7QUErQkg7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs4Q0FBUyxVQUFPLE9BQUssS0FBRTtBQUMxQyxpQkFBNEIsc0JBQUssTUFBVSxVQUFPLE9BQUssS0FBTSxLQUMvRDtBQUNGOzs7NEJBaEMwQjtBQUN0Qjs7Ozs7O0FBTWEseUJBRWY7QUFSUzs7Ozs7TUFEYTs7QUFrQ3hCLFdBRUY7QUFBRSxHQTdDbUM7OztBQWdEOUIsVUFBWSxZQUF3Qix5QkFFN0M7QUFBSSxLOzs7Ozs7Ozs7OztBQzVMSixDQUFVLFlBQUU7QUFDRTs7QUFFWixNQUFjLFVBQUk7QUFDbEIsTUFBb0IsZ0JBQVc7QUFDL0IsTUFBb0IsZ0JBQVk7Ozs7Ozs7Ozs7O0FBV2hDLE1BQWM7Ozs7Ozs7Ozs7QUFVRyw4Q0FBSyxNQUFFO0FBQ3BCLHFCQUF3QixVQUNmLFFBQU8sUUFBTSxLQUFRLFFBQU0sT0FBSSxJQUFPLFlBQWMsUUFBYyx5QkFDbkU7QUFBSixlQUFRLEVBQUcsR0FHakI7T0FKdUQsQ0FEdkM7QUFLZjs7Ozs7Ozs7Ozs7QUFVYyw4Q0FBTSxPQUFFO0FBQ3JCLGFBQWMsUUFBVyxXQUNoQixRQUFRLFNBQU8sTUFBUSxRQUFjLGVBQVEsT0FFeEQ7QUFFRDtBQWhDZTs7QUFrQ1QsVUFBUyxVQUNsQjtBQUFJLEs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3hDSixDQUFVLFlBQUU7O0FBRUU7Ozs7QUFHWixNQUFjLFVBQVMsUUFBUTs7OztBQUkvQixNQUFhLFdBQUc7Ozs7OztBQU1oQixNQUFZO0FBQ0gsYUFBb0I7QUFDcEIsYUFBb0I7QUFDckIsWUFBbUI7QUFDaEIsZUFBc0I7QUFDeEIsYUFBb0I7QUFDbEIsZUFDWDs7Ozs7Ozs7O0FBUGMsSUFnQmQsSUFBZTs7Ozs7Ozs7O0FBU2YsTUFBYzs7QUFFZCxNQUF1Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBd0J2QixXQUEyQixtQkFBTSxPQUFNLE1BQUU7QUFDdkMsUUFBWSxVQUFPLE1BQU07QUFDdEIsUUFBQyxDQUFRLFNBQUU7QUFDSixnQkFBTyxNQUFPLFFBQ3hCO0FBQUUsV0FBUSxJQUFDLENBQU0sTUFBZSxlQUFNLE9BQUU7QUFDOUIsZ0JBQU8sTUFBTyxRQUFRLE9BQU8sT0FBTSxNQUFPO0FBQzlDLFdBQUMsSUFBTSxLQUFVLFNBQUU7QUFDckIsWUFBWSxVQUFTLFFBQUc7QUFDeEIsWUFBVyxTQUFTLFFBQUksS0FBTyxNQUFRLFFBQVE7QUFDM0MsYUFBQyxJQUFLLElBQUUsR0FBRyxJQUFRLFFBQU8sUUFBSyxLQUFFO0FBQzdCLGlCQUFJLEtBQVMsUUFDckI7QUFDRjtBQUNGOztBQUNBLFdBQ0Y7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWlCQSxXQUFtQixXQUFLLE1BQVMsU0FBTyxPQUFVLFVBQVUsVUFBVyxXQUFFO0FBQ3BFLFFBQVEsU0FBRTtBQUNYLFVBQVEsTUFBTztBQUNmLFVBQU8sS0FBWTtBQUNmLFdBQUMsSUFBUyxRQUFRLE9BQUU7QUFDbkIsWUFBc0Isc0JBQUssTUFBUyxTQUFJLElBQU0sTUFBTyxPQUFVLFVBQVUsVUFBWSxZQUFFO0FBQ3BGLGdCQUNOO0FBQ0Y7O0FBQ0EsYUFDRjs7QUFDQSxXQUNGOzs7Ozs7Ozs7Ozs7Ozs7OztBQWdCQSxXQUE4QixzQkFBSyxNQUFTLFNBQVUsVUFBTSxNQUFPLE9BQVUsVUFBVSxVQUFXLFdBQUU7QUFDbEcsUUFBUSxNQUFPO0FBQ2YsUUFBaUIsZUFBVyxXQUFTLFFBQUssS0FBSyxLQUFPLFFBQU07QUFDNUQsUUFBUSxNQUFTLFFBQWM7QUFDNUIsUUFBSSxLQUFFO0FBQ0gsV0FBQyxJQUFLLElBQUUsR0FBRyxJQUFJLElBQU8sUUFBSSxJQUFJLElBQU8sQ0FBVCxLQUFZLEtBQUksSUFBSSxLQUFLLEtBQUU7QUFDdEQsWUFBQyxDQUFDLENBQUcsR0FBTSxRQUFLLEdBQUssS0FBUyxZQUM3QixjQUFDLENBQVUsWUFBcUIsbUJBQUssTUFBSSxHQUFVLFdBQUU7QUFDcEQsY0FBRyxHQUFLLE1BQUU7QUFDVCxlQUFLLEtBQVMsVUFDbEI7O0FBQ0UsYUFBRyxHQUFLLE1BQU0sTUFBTyxPQUFVLFVBQUksR0FBSyxNQUFVLFVBQVk7QUFDNUQsZ0JBQ047QUFDRjtBQUNGOztBQUNBLFdBQ0Y7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW9CQSxXQUEyQixtQkFBSyxNQUFTLFNBQUU7QUFDdEMsUUFBUSxTQUFFO0FBQ1gsVUFBZ0IsY0FBUyxRQUFLO0FBQzlCLGFBQW9CLGVBQ2xCLElBREssSUFDRyxRQUFZLGNBQVUsUUFBSyxLQUFXLFdBQVksYUFDMUQsU0FBUSxRQUFVLFlBQVUsUUFBSyxLQUFhLGFBQVksYUFDOUQ7QUFBRSxXQUFLO0FBQ0wsYUFDRjtBQUNGOzs7Ozs7Ozs7Ozs7Ozs7O0FBZUEsV0FBMEIsa0JBQUssTUFBVSxVQUFPLE9BQVUsVUFBTSxNQUFFO0FBQ2hFLFFBQU8sS0FBTSxLQUFLLEtBQVk7QUFDOUIsUUFBZ0IsY0FBTSxLQUFTO0FBQzVCLFFBQUcsSUFBRTtBQUNKLFNBQUssS0FBSyxNQUFNLEtBQU8sT0FBYSxjQUFVLFNBQ2xEO0FBQUUsV0FBUSxJQUFDLENBQUssS0FBVSxXQUFFO0FBQ25CLGNBQUssS0FBcUIsc0JBQU0sS0FBWSxhQUNyRDtBQUNGOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW1CQSxXQUF5QixpQkFBSyxNQUFhLGFBQU8sT0FBVSxVQUFVLFVBQUU7O0FBRXRFLFFBQVEsTUFBTSxLQUFNLE1BQVE7QUFDNUIsUUFBWTtBQUNaLFFBQU8sS0FBWTs7QUFFZixTQUFDLElBQVMsUUFBYyxhQUFFO0FBQ3pCLFVBQVksWUFBTSxPQUFFO0FBQ2xCLFlBQUssT0FBd0Isc0JBQUssTUFBSyxLQUFJLElBQU0sTUFBTyxPQUFVLFVBQVcsV0FBRTtBQUN2RSxxQkFDWDtBQUFFLGVBQVEsSUFBVSxZQUFhLFdBQUssTUFBTSxNQUFRLFFBQUU7QUFDM0MscUJBQ1g7QUFDRjtBQUNGOzs7OztBQUlBLFFBQVE7QUFDTCxRQUFhLGFBQU0sT0FBTSxLQUFhLGVBQU8sS0FBc0IsdUJBQUU7QUFDbEUsV0FDTjtBQUNGOzs7Ozs7Ozs7Ozs7O0FBWUEsV0FBbUIsV0FBSyxNQUFNLE1BQU8sT0FBRTtBQUNyQyxRQUFpQixlQUFTLFFBQUssS0FBSyxLQUFNO0FBQ3ZDLFFBQWMsaUJBQVEsTUFBRTtBQUN6QixVQUFjLFlBQVMsUUFBUSxRQUFnQixnQkFBZSxnQkFBWTtBQUN2RCwwQkFBSyxNQUFXLFdBQU8sTUFBTSxPQUFPO0FBQ3ZELGFBQ0Y7O0FBQ0EsV0FDRjs7Ozs7Ozs7Ozs7Ozs7O0FBY0EsV0FBNEIsb0JBQUssTUFBVyxXQUFPLE9BQU0sTUFBRTtBQUN6RCxRQUFXO0FBQ0osYUFBTztBQUNDLHFCQUNkO0FBSFk7QUFJVixRQUFLLE1BQUU7QUFDRixhQUFNLE9BQ2Q7OytCQUNpQyxJQUFOLENBQW9CLGNBQUMsSUFBZSxZQUFVLFdBQUUsRUFDN0U7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBZ0JBLFdBQXdCLGdCQUFLLE1BQVUsVUFBTyxPQUFVLFVBQU0sTUFBVSxVQUFFO0FBQ3hFLFFBQWlCLGVBQVcsV0FBUyxRQUFLLEtBQUssS0FBVyxZQUFVO0FBQ3BFLFFBQVMsT0FBZSxnQkFBWSxXQUFXLFdBQU07QUFDckQsUUFBVSxRQUFPLE9BQVMsUUFBSyxLQUFJLElBQUssTUFBUSxRQUFNLEtBQU8sT0FBVTtBQUNwRSxRQUFNLFFBQVMsVUFBYTtBQUN2QixjQUFPLE1BQVUsVUFEUSxDQUVqQzs7QUFDbUIsd0JBQUssTUFBTSxLQUFVLFdBQU8sT0FDakQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFrQkEsV0FBMkIsbUJBQU0sT0FBTSxNQUFVLFVBQVEsUUFBUSxRQUFFO0FBQ2pFLFFBQVM7QUFDVCxRQUFXLFNBQXVCLHFCQUFNLE1BQVE7QUFDaEQsUUFBYSxXQUFTLFVBQVMsT0FBSztBQUNqQyxRQUFTLFVBQUU7QUFDTCxlQUFTLFFBQUssS0FBVSxVQUFTLFVBQVEsUUFBVztBQUNyRCxjQUFTLFVBQVMsT0FDMUI7QUFBRSxXQUFLO0FBQ0MsY0FBTyxNQUFPLE9BQ3RCOztBQUNNLFlBQVMsU0FBRSxDQUFPLFFBQU87QUFDNUIsUUFBQyxDQUFLLEtBQU0sTUFBWSxjQUFHLENBQUssS0FBTSxNQUFXLFdBQVEsU0FBRTtBQUN6RCxVQUFLLEtBQTBCLDBCQUFPLFFBQU8sT0FBTSxNQUFTLFFBQzFELGVBQUMsQ0FBUSxVQUFHLENBQU8sT0FBZSxnQkFBRTtBQUNuQyxhQUNOO0FBQ0Y7QUFDRjs7Ozs7Ozs7Ozs7Ozs7O0FBY0EsV0FBeUIsaUJBQUssTUFBVSxVQUFPLE9BQVUsVUFBTSxNQUFFO0FBQy9ELFFBQVUsUUFBTSxLQUFPLE9BQVU7QUFDOUIsUUFBUSxRQUFpQixrQkFBRTtBQUN0QixjQUFTLFFBQWlCLGlCQUFNLE9BQU0sS0FBUyxVQUFhLGFBQXFCLG1CQUN6Rjs7QUFDSSxTQUFxQixxQkFBUyxVQUFNLEtBQVMsVUFDbkQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFrQkEsV0FBMkIsbUJBQUssTUFBYyxjQUFVLFVBQVUsVUFBRTtBQUNsRSxRQUFtQixpQkFBTSxLQUFNLE1BQVM7QUFDckMsUUFBZSxnQkFBRTtBQUNsQixVQUFlLGFBQWM7QUFDdkIsYUFBVyxXQUFLLE1BQWdCLGdCQUFZLFlBQVUsVUFBVyxXQUFFO0FBQ2pFLGVBQU8sT0FBUyxVQUFNLEtBQVc7QUFDakMsZUFBTyxPQUFhLGNBQU0sS0FBZTtBQUNwQyxxQkFBTSxLQUFjO0FBQzNCLGFBQWUsZ0JBQ3JCO0FBQ0Y7QUFDRjs7Ozs7Ozs7Ozs7Ozs7O0FBY0EsV0FBMEIsa0JBQUssTUFBVSxVQUFPLE9BQVUsVUFBTSxNQUFFO0FBQ2hFLFFBQVcsU0FBaUIsZ0JBQUssTUFBVSxVQUFPLE9BQVUsVUFBTztBQUNuRSxRQUFpQixlQUFNLEtBQVc7QUFDL0IsUUFBSyxLQUFtQixxQkFBTyxLQUFrQixrQkFBYyxlQUFFO0FBQzlELFdBQW9CLG9CQUFhLGNBQVEsUUFDL0M7QUFBRSxXQUFLO0FBQ0QsV0FBZSxnQkFDckI7QUFDRjs7Ozs7Ozs7Ozs7O0FBV0EsV0FBMkIsbUJBQUssTUFBTSxNQUFPLE9BQUU7QUFDN0MsUUFBVSxRQUFNLEtBQWtCO0FBQy9CLFFBQU0sT0FBRTtBQUNULFVBQVE7QUFDSixXQUFDLElBQU0sS0FBUSxPQUFFO0FBQ25CLFlBQU0sSUFBTyxNQUFHO0FBQ2IsWUFBUSxRQUFLLEtBQWEsYUFBRSxHQUFPLE9BQUU7QUFDakMsaUJBQVMsUUFBSyxLQUFVLFVBQUUsR0FBRyxHQUFPO0FBQ3JDLGVBQTBCLDBCQUFLLE1BQU8sT0FBTSxNQUNsRDtBQUFFLGVBQVEsSUFBUSxRQUFLLEtBQWEsYUFBRSxHQUFPLE9BQUU7QUFDeEMsaUJBQVMsUUFBSyxLQUFVLFVBQUUsR0FBRyxHQUFPO0FBQ3JDLGVBQTBCLDBCQUFLLE1BQU8sT0FBTSxNQUNsRDtBQUNGO0FBQ0Y7QUFDRjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBb0JBLFdBQW1CLFdBQVksYUFBYyxjQUFVLFVBQU0sTUFBUSxRQUFPLE9BQVMsU0FBRTs7QUFFN0UsYUFBVSxXQUFVLFNBQVUsWUFBSztBQUMzQyxzQkFBMkIsVUFBRSxFQUFNLFlBQVEsZ0JBQU8sY0FBUyxrQkFBYyxZQUFNLE1BQVEsV0FBUTtBQUN2RixhQUFTLFNBQUssS0FBUzs7QUFFNUIsUUFBa0Isa0JBQVM7QUFDeEIsNEJBQXlCLFFBQU0sTUFBRztVQUE1QjtVQUFVOztBQUNiLGNBQWUsZ0JBQVcsU0FBUSxRQUFnQixnQkFBUyxVQUFhO0FBQ3hFLGNBQWdCLGlCQUN6Qjs7O0FBRUEsUUFBVSxRQUFjLGFBQWEsYUFBTztBQUN4QyxTQUFDLElBQUssSUFBRSxHQUFHLElBQVEsUUFBTSxNQUFPLFFBQUssS0FBRTtBQUN6QyxVQUFTLE9BQVMsUUFBTSxNQUFHO0FBQ3ZCLFdBQWUsZ0JBQUc7QUFDQyw4QkFBWSxhQUFjLGNBQVMsU0FBTSxNQUNsRTtBQUNGOzs7Ozs7Ozs7Ozs7OztBQWFBLFdBQWdDLHdCQUFZLGFBQWMsY0FBUyxTQUFNLE1BQU8sT0FBRTtBQUM3RSxRQUFDLENBQUssS0FBUSxTQUFFO0FBQ2QsVUFBUSxRQUFNLFNBQWdCLGVBQVUsUUFBTyxPQUFJLE9BQU8sS0FBRTtBQUN0RCxnQkFBSyxLQUF5QiwwQkFBUyxRQUFRLFNBRXhEO0FBQUUsYUFBSztBQUNMLFlBQWlCLGVBQU0sS0FBYTtBQUNwQyxZQUFTLE9BQUUsRUFBTyxjQUFTLGtCQUFNLFlBQVcsV0FBZTtBQUN2RCxhQUFDLElBQUssSUFBRSxHQUFHLElBQWEsYUFBTyxRQUFLLEtBQUU7QUFDeEMsY0FBWSxVQUFjLGFBQUc7QUFDMUIsY0FBQyxPQUFlLFdBQVcsVUFBRTtBQUN0QixzQkFBVSxTQUFTO0FBQ3BCLG9CQUFVLFdBQ25COztBQUNXLHNCQUEyQiwyQkFBYSxjQUFTLFFBQWE7QUFDckUsZ0JBQWtCO0FBQ2hCLHdCQUVSO0FBSjZFO0FBSy9FO0FBQ0Y7QUFDRjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXFCQSxXQUF5QixpQkFBSyxNQUFNLE1BQU8sT0FBVSxVQUFNLE1BQVUsVUFBVSxVQUFFO0FBQy9FLFFBQVMsT0FBVSxTQUFLLEtBQU87QUFDL0IsUUFBWSxVQUFNLEtBQVE7QUFDMUIsUUFBUyxPQUFNLEtBQUs7OztBQUdqQixRQUFVLFlBQU8sS0FBVyxVQUFLLEtBQVEsU0FBTSxLQUFPLE9BQ3JELFVBQVEsUUFBTSxRQUFlLGNBQUcsQ0FBUSxRQUFZLGNBQ2hELEtBQW1CLHFCQUFPLEtBQWtCLGtCQUFRLFFBQVEsU0FBRTtBQUNwRSxVQUFVLFFBQU8sTUFBTTtBQUNsQixhQUFTLFFBQUssS0FBVSxVQUFLLEtBQU8sUUFBUyxRQUFPLFFBQU87QUFDN0QsVUFBSyxLQUEwQiwwQkFBSyxNQUFPLE9BQU8sT0FBTyxPQUFFO0FBQ3hELGFBQWUsZUFDckI7QUFDRjtBQUFFLFdBQUs7QUFDTCxVQUFVLFNBQU0sS0FBVSxVQUFpQixpQkFBSyxNQUFNLE1BQU0sTUFBTyxPQUFVLFVBQVc7O0FBRXZFLHdCQUFLLE1BQU0sTUFBUyxTQUFNLE1BQzdDO0FBQ0Y7Ozs7Ozs7Ozs7Ozs7O0FBYUEsV0FBMEIsa0JBQUssTUFBTSxNQUFTLFNBQU0sTUFBTyxPQUFFO0FBQ3JELFlBQXFCLG9CQUFLLE1BQU8sT0FBUyxTQUFPO0FBQ3BELFFBQVEsUUFBaUIsa0JBQUU7QUFDdEIsY0FBUyxRQUFpQixpQkFBTSxPQUFTLFFBQU8sUUFBUyxRQUFLLE1BQ3RFOztBQUNHLFFBQVEsUUFBTSxRQUFjLGFBQUU7O0FBRTNCLFdBQXNCLHVCQUF1QixzQkFBTSxNQUFPLE9BQVMsUUFDekU7QUFBRSxXQUFLOztBQUVMLFVBQVMsT0FBUyxRQUFPO0FBQ3RCLFVBQUssS0FBbUIscUJBQU8sS0FBa0Isa0JBQU0sT0FBRTtBQUN2RCxZQUFDLENBQUssS0FBTSxNQUFZLGNBQUcsQ0FBSyxLQUFNLE1BQVcsV0FBTSxPQUFFO0FBQ3ZELGNBQUssS0FBb0Isb0JBQUssTUFBUSxRQUFFO0FBQ3JDLGlCQUFlLGVBQ3JCO0FBQ0Y7QUFDRjtBQUFFLGFBQU07QUFDRixhQUE0Qiw0QkFBSyxNQUFNLE1BQzdDO0FBQ0Y7QUFDRjs7Ozs7Ozs7Ozs7Ozs7QUFhQSxXQUE0QixvQkFBSyxNQUFPLE9BQVMsU0FBTSxNQUFFO0FBQ3BELFFBQVEsUUFBVyxZQUFFO0FBQ3RCLFVBQVksVUFBTSxLQUFzQixzQkFBUSxRQUFRO0FBQ2pELGNBQUssS0FBZ0IsaUJBQU87QUFDN0IsY0FBUyxRQUFLLEtBQ3RCOztBQUNHLFFBQVEsUUFBTSxTQUFlLGFBQUU7O0FBRTdCLFVBQVEsUUFBUSxXQUNmLGlCQUFLLEtBQVcsYUFBVyxXQUFVLFFBQVEsVUFBVyxTQUFFO0FBQ3RELGdCQUFRLFNBQWEsWUFBSyxLQUNsQztBQUNGOztBQUNBLFdBQ0Y7Ozs7Ozs7Ozs7Ozs7Ozs7QUFlQSxXQUEwQixrQkFBUSxTQUFFO0FBQ2xDLFdBQWMsUUFBUSxRQUFTLFdBQ2pCLFFBQU0sUUFBZSxlQUNyQixRQUFNLFFBQVUsVUFDdkIsQ0FBUSxRQUFZLGNBQ2IsUUFBTSxNQUFHLEdBQU0sU0FDL0I7Ozs7Ozs7Ozs7O0FBVUEsV0FBc0IsY0FBSyxNQUFjO0FBRW5DO0FBRnFDLFFBRTVCLFdBQThCO1FBQWQ7O0FBQzFCLFFBQWEsYUFBTyxRQUFFO0FBQ25CLFdBQUMsSUFBSyxJQUFFLEdBQUksSUFBYyxhQUFPLFFBQUssS0FBRTtBQUMxQyxZQUFTLE9BQWMsYUFBRztBQUMxQixZQUFTLE9BQVUsU0FBRztBQUN0QixZQUFhLFdBQU0sS0FBUztBQUN6QixZQUFTLFVBQUU7QUFDUixlQUFDLElBQUssS0FBRSxHQUFHLEtBQVMsU0FBTyxRQUFLLE1BQUU7QUFDcEMsZ0JBQVksVUFBVSxTQUFHO0FBQ0wsaUNBQUssTUFBVTtBQUNsQiw4QkFBSyxNQUFNLE1BQzlCO0FBQ0Y7O0FBQ0ksYUFBWSxhQUNsQjtBQUNGO0FBQ0Y7Ozs7Ozs7Ozs7Ozs7Ozs7QUFlQSxXQUE2QixxQkFBSyxNQUFTLFNBQUU7QUFDeEMsUUFBUSxRQUFXLFlBQUU7O0FBRXRCLFVBQVksVUFBTSxLQUNoQiwwQkFBSyxLQUF1Qix3QkFBSztBQUNuQyxVQUFVLFFBQVMsUUFBTTs7QUFFekIsVUFBYSxXQUFFLElBQVMsTUFBTSxNQUFRO0FBQ2xDLFdBQUMsSUFBSyxJQUFFLEdBQUcsSUFBTSxNQUFPLFFBQUssS0FBRTtBQUN6QixpQkFBSSxLQUFPLE1BQUcsR0FDeEI7O0FBQ0EsVUFBVyxTQUFTLFFBQU87QUFDcEIsY0FBUyxVQUFVOztBQUV2QixVQUFRLFFBQVMsV0FBVSxRQUFNLFFBQWEsWUFBRTtBQUM3QyxhQUFTLFVBQVMsUUFDeEI7QUFDRjtBQUNGOzs7Ozs7Ozs7OztBQVVBLFdBQTBCLGtCQUFLLE1BQU0sTUFBUyxTQUFFO0FBQzNDLFFBQVEsUUFBYyxlQUFFO0FBQ3pCLFVBQVMsT0FBUyxRQUFNLE1BQUc7QUFDdkIsV0FBaUIsaUJBQVEsUUFBYyxlQUFVLFVBQUUsR0FBRTtBQUNyQywyQkFBRSxHQUFNLE1BQVMsUUFBTyxRQUFNLEtBQU8sUUFBTSxLQUMvRDtBQUNGO0FBQ0Y7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW9CQSxXQUEyQixtQkFBTSxPQUFLLEtBQU0sTUFBVSxVQUFZLFlBQVcsV0FBRTtBQUNuRSxnQkFBSyxJQUFXLFVBQ3hCLGNBQUMsUUFBaUIsa0VBQWEsWUFBWSxVQUFJLElBQWM7QUFDL0QsUUFBUztBQUNHLGtCQUFLLElBQVc7QUFDdEIsWUFBSyxJQUFLO0FBQ0o7QUFFWDtBQUxVO0FBTVAsU0FBQyxJQUFLLElBQUUsR0FBSyxLQUFJLElBQUksSUFBSyxLQUFZLE1BQXZCLEtBQTJCLE1BQUksSUFBSyxLQUFJLEtBQUssS0FBRTtBQUM3RCxVQUFDLENBQUksSUFBUSxTQUFFO0FBQ1gsY0FBbUIsbUJBQUksSUFBYSxjQUFNO0FBQzNDLGNBQVUsVUFBTSxNQUFNLE1BQVMsU0FFckM7QUFIbUQ7QUFJckQ7O0FBQ0csUUFBVSxXQUFFO0FBQ1IsWUFBbUIsbUJBQUksSUFBVyxZQUFNO0FBQ3pDLFlBQVUsVUFBTSxNQUV0QjtBQUhpRDtBQUluRDs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWtCQSxXQUF3QixnQkFBSyxNQUFVLFVBQU8sT0FBVSxVQUFNLE1BQUU7OztBQUc5RCxRQUFZLFVBQU0sS0FBYSxlQUFPO0FBQ3RDLFFBQU8sS0FBUyxRQUFLLEtBQVk7QUFDOUIsUUFBRyxJQUFFO0FBQ04sVUFBUyxPQUFhLFlBQUssS0FBTyxRQUFNLEtBQUssTUFBVSxVQUFRO0FBQy9ELGFBQVMsR0FBTSxNQUFRLFNBQ3pCO0FBQUUsV0FBUSxJQUFDLENBQUssS0FBVSxXQUFFO0FBQ25CLGNBQUssS0FBWSxhQUFNLEtBQVksYUFDNUM7QUFDRjs7O0FBRUEsTUFBaUIsYUFBSTs7O0FBR3JCLE1BQWEsUUFBUSxRQUE0Qiw0QkFBSztBQUN0RCxNQUFhLFNBQVEsUUFBOEMsOENBQUs7QUFDeEUsTUFBb0IsZ0JBQVEsUUFBNkIsNkJBQUs7QUFDOUQsTUFBb0IsZ0JBQVEsUUFBMEIsMEJBQUs7QUFDM0QsTUFBYSxTQUFRLFFBQWdCLGdCQUFNLE1BQWdCLGdCQUFLO0FBQ2hFLE1BQWUsV0FBUyxTQUFRLFFBQU0sTUFBUyxTQUFNLE1BQVUsU0FBVSxVQUFLO0FBQzlFLE1BQWdCLFlBQVEsUUFBVyxXQUFhLGFBQVcsV0FBTyxPQUFLO0FBQ3ZFLE1BQW9CLGdCQUFRLFFBQVksWUFDSixRQUFZLFlBQU0sTUFBTSxNQUN0QixZQUFLO0FBQzNDLE1BQWMsVUFBTSxNQUFRLFFBQVMsU0FBZ0IsZ0JBQU0sTUFBSztBQUNoRSxNQUFtQixlQUFnQixnQkFBUTtBQUMzQyxNQUFvQixnQkFBYTtBQUNqQyxNQUFhLFNBQWdCO0FBQzdCLE1BQWlCLGFBQWUsZUFBUyxTQUFVLFVBQWU7QUFDbEUsTUFBbUIsZUFBRSxJQUFVLE9BQVcsWUFBTTs7Ozs7Ozs7QUFRaEQsV0FBeUIsaUJBQU0sT0FBRTtBQUMvQixRQUFNLElBQUk7QUFDTixTQUFDLElBQUssSUFBRSxHQUFHLElBQU0sTUFBTyxRQUFLLEtBQUU7QUFDakMsVUFBWSxVQUFPLE1BQUcsR0FBUTtBQUM1QixXQUFXLFdBQ2Y7O0FBQ0EsV0FDRjs7Ozs7Ozs7Ozs7OztBQVlBLFdBQW9CLFlBQVcsWUFBRTs7QUFFL0IsUUFBTSxJQUFZLFdBQU0sTUFBMEI7QUFDL0MsUUFBRSxHQUFFO0FBQ0wsVUFBZSxhQUFHLEVBQUc7QUFDckIsVUFBUSxNQUFFLEVBQVksd0JBQVEsUUFBTSxNQUFNLE1BQWM7QUFDckQsVUFBRSxFQUFHLEdBQU8sUUFBRTs7QUFFZixZQUFTLE9BQUcsRUFBRyxHQUFRLFFBQU8sUUFBWSxXQUFNLE1BQUs7QUFDckQsZUFBZ0IsVUFBSyxNQUN2QjtBQUFFLGFBQUs7QUFDTCxlQUNGO0FBQ0Y7O0FBQ0EsV0FDRjs7Ozs7Ozs7Ozs7OztBQVlBLFdBQWtCLFVBQVEsU0FBSyxLQUFFO0FBQzVCLFFBQU0sZUFBYSxJQUFTLFVBQU8sUUFBRTtBQUN0QyxVQUFRLE1BQVUsU0FBUTtBQUN2QixVQUFDLENBQUksSUFBUSxTQUFFO0FBQ2IsWUFBUSxTQUNiOztBQUNBLGFBQ0Y7QUFBQyxLQU5pQixFQU1WO0FBQ1IsV0FDRjs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWtCQSxXQUFpQixTQUFPLFFBQUU7O0FBRXhCLFFBQVEsYUFBYztBQUVwQjtBQUZjLEtBRU4sUUFBVyxZQUFLOzs7QUFJeEI7S0FBUSxRQUFTLFVBQ2pCOztBQUVGLFFBQU07QUFDQSxZQUFLO0FBQ0osYUFBSTtBQUNGLGVBQ1I7QUFKTzs7QUFNUixRQUFPLEtBQUssSUFBRztBQUNaLFFBQUksT0FBTyxLQUFFO0FBQ1gsV0FBSyxJQUNWOztBQUNHLFFBQUksTUFBTyxPQUFNLE1BQU0sS0FBRTtBQUN2QixXQUNMOztBQUNNLFlBQUs7QUFDVCxXQUFRO0FBQ1IsV0FBUTtBQUNMLFVBQU8sUUFBSyxJQUFNLE1BQUUsR0FBRSxDQUFHO0FBQ3pCLFVBQVMsVUFBTTtBQUNYO0FBQ1AsV0FBUTtBQUNMLFVBQU8sUUFBUSxPQUFLO0FBQ3BCLFVBQVMsVUFBTTtBQUVwQjs7O0FBRUcsUUFBQyxDQUFFLEVBQVEsU0FBRTtBQUNiLFFBQWMsZUFBUyxRQUFLLEtBQUssS0FBSzs7QUFFdEMsUUFBWSxhQUFTLFFBQUssS0FBTyxPQUFLO0FBQ3BDLFVBQUUsRUFBVyxZQUFFO0FBQ2YsVUFBWSxXQUFJLElBQU0sTUFBQyxDQUFJLE1BQVE7QUFDakMsWUFBRSxFQUFTLFVBQUU7QUFDYixZQUFNLE9BQUssSUFBTSxNQUFFLEdBQUUsQ0FDeEI7QUFDRjtBQUNGOztBQUNBLFdBQ0Y7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBZ0JBLFdBQW9CLFlBQUssTUFBTSxNQUFNLE1BQU8sT0FBRTtBQUM1QyxRQUFXLFNBQUk7QUFDWCxTQUFDLElBQUssSUFBRSxHQUFHLElBQUssS0FBTyxRQUFHLElBQUUsR0FBSyxLQUFFO0FBQ3JDLFVBQVEsTUFBTSxLQUFHO0FBQ2pCLFVBQVMsT0FBSyxJQUFLO0FBQ25CLFVBQUs7QUFDRixVQUFJLElBQVEsU0FBRTtBQUNiLFlBQUssSUFDVDtBQUFFLGFBQUs7QUFDRixZQUFJLElBQVcsWUFBRTtBQUNoQixjQUFTLFFBQUssS0FBSSxJQUFLLE1BQU87O0FBRTdCLGNBQUcsTUFBYSxXQUFFO0FBQ2pCLGdCQUFPLE1BQ1g7QUFDRjtBQUFFLGVBQUs7QUFDSCxjQUFNLEtBQ1Y7QUFDRjs7QUFDRyxVQUFJLElBQVMsVUFBRTs7O0FBR2hCLFlBQWtCLGNBQUssS0FBUSxRQUFNLE9BQU8sU0FBTTtBQUNsRCxZQUFjLFVBQUssS0FBUSxRQUFPLFVBQU0sS0FBRyxDQUFhO0FBQ2xELGVBQUk7QUFDSixnQkFBVSxVQUFPLE9BQU07QUFDdEIsaUJBQVUsVUFBTyxNQUFPLFFBQUc7QUFDNUIsZ0JBRVI7QUFMYztBQUtaLGFBQUs7QUFDQyxlQUFJLEtBQ1o7QUFDRjs7QUFDQSxXQUNGOzs7Ozs7Ozs7Ozs7Ozs7O0FBZUEsV0FBc0IsZUFBSyxNQUFPLE9BQU0sTUFBUyxTQUFFO0FBQ2pELFFBQWdCLGNBQU8sT0FBWTtBQUMvQixTQUFXLFdBQVksYUFBRSxFQUFjLGNBQVk7QUFDbkQsU0FBVyxXQUFNLE9BQVcsV0FBTyxNQUFROztBQUUzQyxTQUFPLE9BQWMsZUFBRSxFQUFhLGNBQzFDOzs7Ozs7Ozs7Ozs7Ozs7OztBQWdCQSxXQUFxQixhQUFLLE1BQU8sT0FBTSxNQUFPLE9BQVksWUFBUyxTQUFFO0FBQ3RELG1CQUFLLE1BQU8sT0FBTTtBQUN4QixhQUFPO0FBQ0Ysa0JBQVk7QUFDZixlQUFTO0FBQ1YsY0FBTztBQUNULFlBRVI7QUFQb0MsS0FBRDs7Ozs7Ozs7OztBQWdCbkMsV0FBYyxNQUFLLE1BQUU7QUFDbkIsV0FBVyxLQUFHLEdBQWUsZ0JBQU0sS0FBVSxVQUMvQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBc0NPLFVBQWlCLDBCQUF1QixjQUFZOzs7Ozs7Ozs7QUFTekQsUUFBMEIsc0JBQVMsUUFBYyxjQUFRLFFBQWtCLGtCQUFhOztBQVN4Rjs7Ozs7Ozs7QUFsQjRELFFBa0J0Qzs7O0FBRVI7QUFDSDs7Ozs7QUFFSCxjQUFtQjs7QUFFbkIsY0FBcUI7O0FBRXJCLGNBQWU7O0FBRWYsY0FBa0I7O0FBRWxCLGNBQWU7O0FBRWYsY0FBc0I7O0FBRXRCLGNBQVc7O0FBRVgsY0FBVzs7QUFFWCxjQUF5Qjs7QUFFekIsY0FBTzs7QUFFUCxjQUFjOztBQUVkLGNBQVU7O0FBRVYsY0FBaUI7O0FBRWpCLGNBQWlCOztBQUVqQixjQUFnQjs7QUFFaEIsY0FBbUI7O0FBRW5CLGNBQWlCOztBQUVqQixjQUFXOztBQUVYLGNBQWM7O0FBRWQsY0FDTjs7QUFFMEI7Ozs7Z0RBSUY7QUFDTztBQUNwQixvQkFBYSxhQUFNO0FBQ3hCLGVBQW9CLHFCQUFPO0FBQzNCLGVBQXNCLHVCQUFNO0FBQzVCLGVBQWdCLGlCQUFNO0FBQ3RCLGVBQW1CLG9CQUFNO0FBQ3pCLGVBQWdCLGlCQUFPOztBQUV2QixlQUF1Qix3QkFBTSxLQUF1Qix5QkFBTztBQUMzRCxlQUFZLGFBQU0sS0FBWSxjQUFPO0FBQ3JDLGVBQVksYUFBSTtBQUNoQixlQUEwQiwyQkFDaEM7OztBQVUwQjs7Ozs7Ozs7Ozs7bURBQU0sT0FBRTtBQUM1QixlQUFRLFNBQVEsT0FBTyxPQUFPO0FBQzlCLGVBQWUsZ0JBQVEsT0FBTyxPQUFPO0FBQ3JDLGVBQVcsWUFDakI7OztBQVM2Qjs7Ozs7Ozs7OztzREFBTSxPQUFFO0FBQ25DLGNBQWEsV0FBTSxLQUFNLE1BQVc7QUFDaEMsZUFBQyxJQUFTLFFBQVEsT0FBRTtBQUNuQixnQkFBQyxDQUFVLFlBQUcsQ0FBUyxTQUFNLE9BQUU7QUFDNUIsbUJBQWUsZ0JBQU0sS0FBZSxpQkFBSztBQUN6QyxtQkFBVyxZQUFNLEtBQVcsYUFBSztBQUNqQyxtQkFBTyxPQUFPLFFBQU0sS0FBYyxjQUFPLFFBQU8sTUFDdEQ7QUFDRjtBQUNGOzs7OztBQWNrQjs7Ozs7Ozs7Ozs7OzsyQ0FBUyxVQUFNLE1BQVEsUUFBRTtBQUNyQyxlQUF3Qix3QkFBUyxVQUFPLFFBQVEsTUFBVzs7QUFFL0QsY0FBWSxVQUFvQixtQkFBSyxNQUFPLE1BQVU7QUFDbkQsY0FBQyxDQUFRLFNBQUU7QUFDSixzQkFBTSxLQUFNLE1BQVcsWUFDakM7O0FBQ08sa0JBQUssS0FDZDs7O0FBU3FCOzs7Ozs7Ozs7OzhDQUFTLFVBQU0sTUFBUSxRQUFFO0FBQzVDLGNBQVksVUFBb0IsbUJBQUssTUFBTyxNQUFVO0FBQ3RELGNBQVEsTUFBUyxRQUFRLFFBQVE7QUFDOUIsY0FBSyxPQUFJLEdBQUU7QUFDTCxvQkFBTyxPQUFJLEtBQ3BCO0FBQ0Y7OztBQVdrQjs7Ozs7Ozs7Ozs7OzJDQUFTLFVBQU0sTUFBRTtBQUNqQyxjQUFZLFVBQU0sS0FBTTtBQUN4QixpQkFBYyxRQUFTLFdBQVUsUUFDbkM7OztBQVVrQjs7Ozs7Ozs7Ozs7MkNBQVMsVUFBRTtBQUMzQixpQkFBVyxLQUFtQixtQkFBUyxVQUFPLE1BQ2hEOzs7QUFVZ0I7Ozs7Ozs7Ozs7O3lDQUFTLFVBQUU7QUFDekIsaUJBQVcsS0FBbUIsbUJBQVMsVUFBTyxNQUNoRDs7O0FBVWlCOzs7Ozs7Ozs7OzswQ0FBUyxVQUFFO0FBQzFCLGlCQUFXLEtBQW1CLG1CQUFTLFVBQU8sTUFDaEQ7OztBQVVrQjs7Ozs7Ozs7Ozs7MkNBQVMsVUFBRTtBQUMzQixpQkFBVyxLQUFtQixtQkFBUyxVQUFPLE1BQ2hEOzs7OztBQWdDeUI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7a0RBQUssTUFBTyxPQUFjLGNBQW9CLG9CQUFFO0FBQ3BFLGNBQW9CLHNCQUNaLFFBQUssS0FBSyxLQUFNLE1BQVEsUUFBTyxRQUFNLEtBQUksS0FBUSxVQUFRLE1BQUU7Ozs7Ozs7OztBQVNqRSxnQkFBQyxDQUFtQixvQkFBRTtBQUN2QixrQkFBUSxNQUFTLFFBQUssS0FBSSxJQUFLLE1BQU87QUFDakMscUJBQXdCLHFCQUFRLFFBQUssS0FBSSxJQUFLLE1BQU0sTUFBUzs7QUFFL0Qsa0JBQUMsQ0FBTSxRQUErQix5SUFBSyxNQUFPLE9BQU0sTUFBRTtBQUMzRCx1QkFDRjtBQUNGOztBQUNJLGlCQUFnQixpQkFBTTtBQUN2QixnQkFBSyxLQUFvQixxQkFBbUIsa0JBQU0sTUFBTyxPQUFlLGVBQUU7QUFDekQsaUNBQUssTUFBTSxNQUFRO0FBQ3JDLHFCQUNGO0FBQ0Y7QUFBRSxpQkFBSztBQUNGLGdCQUFLLEtBQW1CLHFCQUFPLEtBQWtCLGtCQUFNLE9BQUU7QUFDMUQscUJBQVcsS0FBb0IscUJBQW1CLGtCQUFNLE1BQU8sT0FDakU7QUFBRSxtQkFBSztBQUNELG1CQUFPLFFBQ2I7QUFDRjs7QUFDQSxpQkFDRjs7O0FBc0IyQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0RBQUssTUFBTSxNQUFPLE9BQUU7Ozs7O0FBSzFDLGNBQU8sVUFBUSxLQUFPLFNBQUcsUUFBYSx5REFBVyxVQUFFO0FBQ2hELGlCQUFPLFFBQ2I7QUFDRjs7O0FBcUNtQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7NENBQVMsVUFBTyxPQUFjLGNBQUU7QUFDakQsY0FBVyxTQUFNLEtBQWdCLGtCQUFVLFFBQUssS0FBTyxPQUFVO0FBQ2pFLGNBQWMsWUFBUyxTQUFNLEtBQVksYUFBTSxLQUFPO0FBQ25ELGNBQUssS0FBc0Isc0JBQVMsVUFBTyxPQUFXLFVBQVcsWUFBRTtBQUNqRSxnQkFBQyxDQUFLLEtBQWMsZUFBRTtBQUNuQixtQkFBZSxnQkFBSTtBQUNuQixtQkFBVyxZQUNqQjs7O0FBRUcsZ0JBQUUsRUFBVSxZQUFPLEtBQVcsWUFBRTtBQUM3QixtQkFBVSxVQUFXLFlBQU0sS0FBTyxPQUN4Qzs7OztBQUdHLGdCQUFPLFFBQUU7QUFDTixtQkFBVyxXQUFXLFlBQzVCO0FBQUUsbUJBQUs7QUFDRCxtQkFBTyxPQUFXLFlBQ3hCOzs7QUFFSSxpQkFBYyxjQUFXLFlBQU87O0FBRWpDLGdCQUFXLFVBQUssS0FBTSxNQUFTLFdBQU8sS0FBTSxNQUFRLFFBQVcsV0FBRTtBQUM5RCxtQkFBZ0IsaUJBQU0sS0FBZ0Isa0JBQUs7QUFDM0MsbUJBQWUsZUFBVyxZQUNoQzs7QUFDQSxtQkFDRjs7QUFDQSxpQkFDRjs7O0FBUVk7Ozs7Ozs7OztxQ0FBUyxVQUFPLE9BQUU7QUFDekIsY0FBSyxLQUFvQixvQkFBUyxVQUFPLE9BQU8sT0FBRTtBQUMvQyxpQkFDTjtBQUNGOzs7QUFVc0I7Ozs7Ozs7Ozs7O2dEQUFFO0FBQ25CLGNBQUssS0FBWSxhQUFFO0FBQ2hCLGlCQUNOO0FBQ0Y7OztBQVVjOzs7Ozs7Ozs7Ozt1Q0FBTyxRQUFFO0FBQ2pCLGVBQXNCLHVCQUFNLEtBQXNCLHdCQUFLO0FBQ3hELGNBQVEsV0FBUSxNQUFFO0FBQ2YsaUJBQXFCLHFCQUFLLEtBQ2hDO0FBQ0Y7OztBQVFjOzs7Ozs7Ozs7d0NBQUU7QUFDWCxjQUFDLENBQUssS0FBbUIsb0JBQUU7QUFDeEIsaUJBQW9CLHFCQUFNO0FBQzFCLGlCQUFnQjs7OztBQUloQixpQkFBYSxjQUNuQjtBQUFFLGlCQUFLO0FBQ0QsaUJBQ047QUFDRjs7Ozs7Ozs7Ozs7Ozs7QUFjdUI7Ozs7aURBQUU7QUFDdkIsY0FBWSxVQUFNLEtBQXFCO0FBQ3BDLGNBQVEsU0FBRTtBQUNQLGlCQUFzQix1QkFBTTtBQUM1QixpQkFBQyxJQUFLLElBQUUsR0FBSSxJQUFTLFFBQU8sUUFBSyxLQUFFO0FBQ3JDLGtCQUFXLFNBQVMsUUFBRztBQUNwQixrQkFBQyxDQUFPLE9BQWMsZUFBRTtBQUNuQix1QkFDUjtBQUFFLHFCQUFRLElBQU8sT0FBYyxlQUFFO0FBQ3pCLHVCQUNSO0FBQ0Y7QUFDRjtBQUNGOzs7QUFTYzs7Ozs7Ozs7Ozt3Q0FBRTtBQUNWLGVBQ047OztBQWdCYTs7Ozs7Ozs7Ozs7Ozs7Ozs7c0NBQU0sT0FBYSxhQUFFO0FBQzVCLGVBQUMsSUFBUyxRQUFRLE9BQUU7QUFDbkIsZ0JBQWEsZUFBRyxDQUFLLEtBQU0sTUFBWSxjQUFHLENBQUssS0FBTSxNQUFXLFdBQU0sT0FBRTs7Ozs7QUFLckUsbUJBQTBCLDBCQUFLLE1BQU8sTUFBTSxPQUNsRDtBQUNGOztBQUNJLGVBQ047OztBQVVNOzs7Ozs7Ozs7OztnQ0FBRTs7Ozs7QUFLRixlQUFtQjs7O0FBR3BCLGNBQUMsQ0FBSyxLQUFtQixvQkFBRTtBQUN4QixpQkFDTjs7OztBQUdHLGNBQUssS0FBYyxlQUFFO0FBQ2xCLGlCQUNOO0FBQ0Y7OztBQVVrQjs7Ozs7Ozs7Ozs7MkNBQWEsY0FBYyxjQUFVLFVBQUU7Ozs7OztBQU12RCxjQUFhLFdBQU0sS0FBZTtBQUM5QixlQUFnQixpQkFBTzs7QUFFVCw2QkFBSyxNQUFjLGNBQVUsVUFBVzs7O0FBRzFELGNBQWdCLGNBQU0sS0FBZTtBQUNqQyxlQUFnQixpQkFBTTs7QUFFdEIsZUFBMEIsMEJBQWEsY0FBVSxVQUFXOztBQUU1RCxlQUFnQjs7QUFFVixxQkFBSyxNQUFNLEtBQU0sTUFBUyxVQUFjLGNBQVUsVUFBVzs7QUFFN0QscUJBQUssTUFBTSxLQUFNLE1BQVMsVUFBYyxjQUFVLFVBQVc7O0FBRXBFLGNBQVksYUFBRTtBQUNDLDZCQUFLLE1BQWEsYUFBYyxjQUFVLFVBQzVEOzs7QUFFRyxjQUFLLEtBQWUsaUJBQUksR0FBRTtBQUN2QixpQkFBWSxhQUNsQjs7OztBQUlGOzs7QUFXeUI7Ozs7Ozs7Ozs7OztrREFBYSxjQUFVLFVBQVUsVUFBRTtBQUN2RCxjQUFLLEtBQU0sTUFBVyxZQUFFO0FBQ2YsdUJBQUssTUFBTSxLQUFNLE1BQVcsWUFBYyxjQUFVLFVBQ2hFOztBQUNBLGNBQWlCLGVBQU0sS0FBZTtBQUNoQyxpQkFBYSxjQUFFO0FBQ1QsdUJBQUssTUFBYyxhQUFnQixpQkFBYyxjQUFVLFVBQzNELFVBQWMsYUFBVTtBQUNyQiwyQkFBYyxhQUM3QjtBQUNGOzs7QUFVUzs7Ozs7Ozs7Ozs7a0NBQUcsSUFBTSxNQUFFO0FBQ2YsZUFBUyxRQUFLLEtBQVUsVUFBSTtBQUMxQixpQkFBUyxRQUFLLEtBQVUsVUFBTTtBQUMvQixlQUFtQixvQkFBTSxLQUFtQixxQkFBSztBQUNqRCxlQUFrQixrQkFBSyxNQUM3Qjs7O0FBV1c7Ozs7Ozs7Ozs7OztvQ0FBSyxNQUFFO0FBQ1gsaUJBQVMsUUFBSyxLQUFVLFVBQU07QUFDaEMsY0FBSyxLQUFrQixtQkFBRTtBQUMxQixtQkFBVyxLQUFrQixrQkFDL0I7QUFDRjs7O0FBK0JhOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztzQ0FBSyxNQUFTLFNBQUU7QUFDM0IsY0FBUyxPQUFFLEVBQUssTUFBSztBQUNyQixjQUFVLFFBQXNCLG9CQUFRLFFBQUssS0FBSSxJQUFLLE1BQU0sTUFBUTtBQUN2RCx5QkFBSyxNQUFPLE9BQU0sS0FBSyxNQUN0Qzs7O0FBcUJHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzRCQUFLLE1BQU0sTUFBRTtBQUNkLGlCQUFjLFFBQUssS0FBSSxJQUFNLFFBQU8sTUFDdEM7OztBQXNCRzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7NEJBQUssTUFBTyxPQUFNLE1BQUU7QUFDbEIsY0FBSyxNQUFFO0FBQ0Qsb0JBQUssS0FBSSxJQUFLLE1BQU0sTUFDN0I7QUFBRSxpQkFBSztBQUNGLGdCQUFDLENBQUssS0FBTSxNQUFZLGNBQUcsQ0FBSyxLQUFNLE1BQVcsV0FBc0IscUJBQU8sT0FBRTtBQUM5RSxrQkFBSyxLQUEwQiwwQkFBSyxNQUFPLE9BQU8sT0FBRTtBQUNqRCxxQkFDTjtBQUNGO0FBQ0Y7QUFDRjs7O0FBZ0JJOzs7Ozs7Ozs7Ozs7Ozs7Ozs2QkFBTztBQUNULGNBQVMsT0FBRSxFQUFLLE1BQUs7QUFDckIsY0FBVSxRQUFxQixtQkFBUSxRQUFLLEtBQUksSUFBSyxNQUFNLE1BQVE7QUFDbkUsY0FBUSxNQUFPLE1BQU87O0FBSEg7QUFBRjs7O0FBSWpCLGNBQVEsTUFBTyxNQUFNLGtCQUFTO0FBQzNCLGNBQU0sTUFBTyxRQUFFO0FBQ0oseUJBQUssTUFBTyxPQUFNLEtBQUssTUFBSyxLQUFPLE1BQU8sUUFDeEQ7O0FBQ0EsaUJBQ0Y7OztBQWVHOzs7Ozs7Ozs7Ozs7Ozs7OzRCQUFLLE1BQUU7QUFDUixjQUFTLE9BQUUsRUFBSyxNQUFLO0FBQ3JCLGNBQVUsUUFBc0Isb0JBQVEsUUFBSyxLQUFJLElBQUssTUFBTSxNQUFRO0FBQ3BFLGNBQWMsWUFBUyxRQUFNLE1BQVE7QUFDckMsY0FBUSxNQUFPLE1BQU07QUFDbEIsY0FBVSxXQUFFO0FBQ0QseUJBQUssTUFBTyxPQUFNLEtBQUssTUFBTyxNQUFPLFFBQUcsR0FBRSxDQUN4RDs7QUFDQSxpQkFDRjs7O0FBbUJNOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsrQkFBSyxNQUFPLE9BQWU7QUFDL0IsY0FBUyxPQUFFLEVBQU0sTUFBSztBQUN0QixjQUFVLFFBQXNCLG9CQUFRLFFBQUssS0FBSSxJQUFLLE1BQU0sTUFBUTs7QUFFakUsY0FBTyxRQUFHLEdBQUU7QUFDUCxvQkFBTyxNQUFRLFNBQU0sS0FBTSxNQUFDLENBQ3BDO0FBQUUsaUJBQUs7QUFDQyxvQkFBTSxLQUFNLE1BQ3BCOztBQUNHLGNBQUMsQ0FBTSxPQUFFO0FBQ0osb0JBQ1I7OztBQVh5QztBQUFGOzs7QUFZdkMsY0FBUSxNQUFPLE1BQU8scUJBQU0sT0FBZSxvQkFBUztBQUNqRCxjQUFNLE1BQVEsVUFBTSxJQUFPLFFBQUU7QUFDbEIseUJBQUssTUFBTyxPQUFNLEtBQUssTUFBTyxPQUFPLE1BQU8sUUFDMUQ7O0FBQ0EsaUJBQ0Y7OztBQWVLOzs7Ozs7Ozs7Ozs7Ozs7OzhCQUFLLE1BQUU7QUFDVixjQUFTLE9BQUUsRUFBSyxNQUFLO0FBQ3JCLGNBQVUsUUFBc0Isb0JBQVEsUUFBSyxLQUFJLElBQUssTUFBTSxNQUFRO0FBQ3BFLGNBQWMsWUFBUyxRQUFNLE1BQVE7QUFDckMsY0FBUSxNQUFPLE1BQVE7QUFDcEIsY0FBVSxXQUFFO0FBQ0QseUJBQUssTUFBTyxPQUFNLEtBQUssTUFBRyxHQUFHLEdBQUUsQ0FDN0M7O0FBQ0EsaUJBQ0Y7OztBQWdCTzs7Ozs7Ozs7Ozs7Ozs7Ozs7Z0NBQU87QUFDWixjQUFTLE9BQUUsRUFBSyxNQUFLO0FBQ3JCLGNBQVUsUUFBc0Isb0JBQVEsUUFBSyxLQUFJLElBQUssTUFBTSxNQUFROztBQUY5QztBQUFGOzs7QUFHcEIsY0FBUSxNQUFPLE1BQVMscUJBQVM7QUFDOUIsY0FBTSxNQUFPLFFBQUU7QUFDSix5QkFBSyxNQUFPLE9BQU0sS0FBSyxNQUFHLEdBQU8sTUFBTyxRQUN0RDs7QUFDQSxpQkFDRjs7O0FBY1U7Ozs7Ozs7Ozs7Ozs7OzttQ0FBSyxNQUFPLE9BQUU7O0FBRXRCLGNBQVk7QUFDVCxjQUFVLFVBQVEsVUFBSSxHQUFFOztBQUV6QixnQkFBUyxPQUFFLEVBQUssTUFBSztBQUNmLG9CQUFTLFFBQUssS0FBSSxJQUFLLE1BQU0sTUFBTztBQUNqQyx1QkFBTSxLQUNqQjtBQUFFLHFCQUFjLE1BQVEsUUFBTSxPQUFFOztBQUVyQix1QkFBUyxRQUFLLEtBQVUsVUFDbkM7QUFBRSxXQUhRLE1BR0g7QUFDSSx1QkFBc0Isb0JBQ2pDOztBQUNHLGNBQUssS0FBMEIsMEJBQVMsVUFBTyxPQUFNLE1BQU8sT0FBRTtBQUMzRCxpQkFDTjtBQUNGOzs7QUFZdUI7Ozs7Ozs7Ozs7Ozs7Z0RBQVMsVUFBaUIsaUJBQUU7QUFDN0MsZUFBbUIsbUJBQVMsVUFBTyxNQUFXO0FBQy9DLGNBQWdCLGlCQUFFO0FBQ2YsaUJBQVEsU0FBTyxNQUFZLDJDQUF3QyxVQUFNLE9BQUU7QUFDekUsbUJBQWEsYUFBUyxVQUM1QjtBQUNGO0FBQ0Y7OztBQWF1Qjs7Ozs7Ozs7Ozs7Ozs7Z0RBQVMsVUFBWSxZQUFXLFdBQUU7QUFDdkQsY0FBUyxPQUFFLEVBQVUsb0JBQVksd0JBQVcsV0FBUyxRQUFhO0FBQzlELGVBQW1CLG1CQUFTLFVBQU8sTUFBUTtBQUMzQyxnQkFBbUIsbUJBQU0sWUFBUyxTQUFFLEVBQUssTUFDM0M7QUFGK0M7QUFHOUMsY0FBVSxXQUFFO0FBQ1QsaUJBQW1CLG1CQUFXLFlBQU8sTUFBUTtBQUM3QyxrQkFBbUIsbUJBQU0sWUFBUyxTQUFFLEVBQUssTUFFL0M7QUFIcUQ7QUFJdkQ7OztBQVlxQjs7Ozs7Ozs7Ozs7Ozs4Q0FBVyxZQUFXLFdBQUU7QUFDM0MsY0FBUSxNQUFhLFlBQVk7QUFDOUIsY0FBQyxDQUFJLEtBQUU7QUFDUixrQkFBTSxJQUFTLE1BQW1DLG9DQUFhLGFBQ2pFOztBQUNrQiw2QkFBSyxNQUFLLEtBQU8sTUFBUSxTQUFpQixpQkFBTSxNQUNwRTs7O0FBVXdCOzs7Ozs7Ozs7OztpREFBUyxVQUFFO0FBQzdCLGVBQW1CLG1CQUFTLFVBQU8sTUFBTztBQUMxQyxnQkFBaUI7QUFDZjtBQUNPLHlCQUFTLFFBQWdCLGdCQUFXLFlBQVk7QUFDakQsd0JBR2Q7QUFMVTtBQUZ3Qzs7O0FBaUIxQjs7Ozs7Ozs7Ozs7aURBQVMsVUFBRTtBQUNqQyxjQUFTLE9BQVMsUUFBZ0IsZ0JBQVU7QUFDekMsY0FBSyxLQUFJLE9BQU8sS0FBRTtBQUNaLG9CQUFLLEtBQWEsY0FBVyxXQUF1Qyx1Q0FDcEUsT0FDVDtBQUFFLGlCQUFLO0FBQ0QsaUJBQW1CLG1CQUFTLFVBQU8sTUFBUTtBQUMzQyxrQkFBa0I7QUFDaEI7QUFDTSwwQkFHZDtBQUpVO0FBRnlDO0FBT3JEOzs7QUFhdUI7Ozs7Ozs7Ozs7Ozs7O2dEQUFTLFVBQVksWUFBVyxXQUFFO0FBQ3ZELGNBQVEsTUFBYSxZQUFZO0FBQzlCLGNBQUMsQ0FBSSxLQUFFO0FBQ1Isa0JBQU0sSUFBUyxNQUFtQyxvQ0FBYSxhQUNqRTs7QUFDa0IsNkJBQUssTUFBSyxLQUFPLE1BQVEsU0FBbUIsbUJBQVUsVUFDMUU7Ozs7O0FBdUN3Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBbUlYOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3NDQUFTLFVBQWlCLGlCQUFFO0FBQ3ZDLGNBQWlCLGVBQU0sS0FBWSxZQUFlLGVBQVU7QUFDNUQsY0FBZ0IsY0FBTSxLQUFnQixrQkFBZTs7O0FBR2xELGNBQUMsQ0FBWSxhQUFFO0FBQ1osaUJBQUMsSUFBUyxRQUFlLGFBQWdCLGlCQUFFO0FBQ3pDLG1CQUF3Qix3QkFDOUI7QUFDRjs7QUFDRyxjQUFnQixpQkFBRTs7O0FBR04sMkJBQThCLDRCQUFPLE9BQU8sT0FBZTtBQUM1RCx5QkFBYSxjQUFhO0FBQ25DLGdCQUFDLENBQWEsZUFBTyxLQUFlLGdCQUFFO0FBQ3ZDLGtCQUFTLE9BQU0sS0FBb0Isc0JBQU8sS0FBZTtBQUNyRCxtQkFBb0IscUJBQU0sS0FBa0IsbUJBQWM7QUFDbEQsMkJBQXNCLHVCQUFNO0FBQ3hDLHFCQUNGO0FBQ0Y7O0FBQ0EsaUJBQVcsS0FBZ0IsaUJBQzdCOzs7QUFjaUM7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBNEJuQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7dUNBQVMsVUFBRTs7O0FBR2Qsb0JBQWEsYUFBTTtBQUM1QixjQUE4Qix1SUFBVTtBQUMvQixvQkFBVyxXQUFNO0FBQzFCLGNBQWlCLGVBQThCLDRCQUFLLEtBQWMsY0FBUyxVQUFROztBQUV2RSx1QkFBVSxXQUFLLElBQVM7O0FBRWpDLGNBQUMsQ0FBYSxhQUFZLGFBQUU7QUFDN0IsZ0JBQVUsUUFBYyxhQUFZLGFBQUk7QUFDcEMsaUJBQUMsSUFBSyxJQUFJLElBQVcsWUFBRyxHQUFHLElBQUUsRUFBWSxhQUFFO0FBQ3hDLG9CQUFLLEtBQ1o7QUFDRjs7QUFDRyxjQUFjLGVBQWM7O0FBRWxCLHdCQUFLLE1BQWU7O0FBRTlCLGNBQUssS0FBWSxhQUFFO0FBQ1YsdUJBQUssTUFBYyxhQUFnQixpQkFBTSxLQUFPLFFBQU0sTUFDekQsT0FBYyxhQUN2Qjs7QUFDQSxpQkFDRjs7O0FBVWU7Ozs7Ozs7Ozs7O3dDQUFJLEtBQUU7O0FBRW5CLGNBQWlCLGVBQUssSUFBYTtBQUNoQyxjQUFhLGFBQXFCLHNCQUFFO0FBQ3pCLHlCQUFxQixxQkFBa0IsbUJBQ3JDLGFBQ2hCOztBQUNHLGNBQWEsYUFBaUIsa0JBQUU7QUFDckIseUJBQWlCLGlCQUFzQix1QkFDckMsYUFDaEI7O0FBQ0csY0FBSyxLQUFvQixzQkFBZSxjQUFFO0FBQ3ZDLGlCQUFvQixxQkFBYyxhQUN4Qzs7QUFDWSx1QkFBc0IsdUJBQWMsYUFBa0IsbUJBQU07O0FBRXhFLGNBQVUsUUFBYyxhQUFXO0FBQy9CLGVBQUMsSUFBSyxJQUFFLEdBQUcsSUFBTSxNQUFPLFFBQUssS0FBRTtBQUNqQyxnQkFBUyxPQUFPLE1BQUc7QUFDZixpQkFBVyxXQUFZLFlBQzdCO0FBQ0Y7OztBQW1CeUI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzRCQXR0Q0c7QUFDMUIsaUJBQ0Y7QUFFc0I7OzswQ0FtOEJXLFVBQU0sTUFBUSxRQUFFO0FBQzNDLGVBQVUsVUFBbUIsbUJBQVMsVUFBTSxNQUNsRDs7O0FBVzZCOzs7Ozs7Ozs7Ozs7K0NBQVMsVUFBWSxZQUFXLFdBQUU7QUFDekQsZUFBVSxVQUF3Qix3QkFBUyxVQUFZLFlBQzdEOzs7QUFjMkI7Ozs7Ozs7Ozs7Ozs7Ozs2Q0FBVyxZQUFXLFdBQUU7QUFDN0MsZUFBVSxVQUFzQixzQkFBVyxZQUNqRDs7O0FBUzhCOzs7Ozs7Ozs7O2dEQUFTLFVBQUU7QUFDbkMsZUFBVSxVQUF5Qix5QkFDekM7OztBQWlCNkI7Ozs7Ozs7Ozs7Ozs7Ozs7OzsrQ0FBUyxVQUFpQixpQkFBRTtBQUNuRCxlQUFVLFVBQXdCLHdCQUFTLFVBQ2pEOzs7QUFTOEI7Ozs7Ozs7Ozs7Z0RBQVMsVUFBRTtBQUNuQyxlQUFVLFVBQXlCLHlCQUN6Qzs7O0FBZTZCOzs7Ozs7Ozs7Ozs7Ozs7OytDQUFTLFVBQVksWUFBVyxXQUFFO0FBQ3pELGVBQVUsVUFBd0Isd0JBQVMsVUFBWSxZQUM3RDs7O0FBY21COzs7Ozs7Ozs7Ozs7Ozs7cUNBQVMsVUFBRTtBQUM1QixpQkFBVyxLQUFVLFVBQWMsY0FDckM7Ozs7bURBK0Q4QyxjQUFNLE1BQVEsUUFBRTtBQUM1RCxjQUFjLFlBQWMsYUFBVyxZQUFjLGFBQVcsYUFBSztBQUM1RCxvQkFBTyxRQUFNO0FBQ3RCLGNBQVksVUFBYyxhQUFpQixrQkFBYyxhQUFpQixtQkFBSztBQUMvRSxjQUFnQixjQUFTLFFBQU8sUUFBUyxRQUFPLFNBQUs7QUFDMUMsc0JBQUssS0FDbEI7Ozs7MkNBaUc4QixNQUFjLGNBQVUsVUFBRTtBQUN0RCxjQUFvQyx5SEFBSyxNQUFjLGNBQVc7QUFDL0QsY0FBSyxLQUFVLGFBQVEsS0FBVSxXQUFFO0FBQ3BDLGdCQUFVLFFBQU0sS0FBZSxlQUFLLEtBQVksYUFBZTtBQUM1RCxnQkFBTSxPQUFFOzs7O0FBSUwsbUJBQWEsY0FBa0IsaUJBQVEsVUFBTTtBQUN2Qyx5QkFBSyxNQUFjLGNBQVUsVUFBUSxRQUFlLGVBQVE7QUFDaEUsc0JBQ1I7QUFDRjs7QUFDQSxpQkFDRjs7O0FBbUJrQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0RBQUssTUFBYyxjQUFVLFVBQU0sTUFBTyxPQUFFO0FBQzVFLGNBQVUsUUFBTSxLQUFlLGVBQU0sT0FBZTtBQUNqRCxjQUFNLE9BQUU7O0FBRVQsZ0JBQWEsV0FBTTtBQUNuQixnQkFBUyxPQUFZO0FBQ2xCLGdCQUFLLEtBQUssS0FBTyxTQUFJLE1BQU0sS0FBRTtBQUN6QixxQkFBTSxLQUFNLE1BQUUsR0FBRSxDQUFHO0FBQ25CLHFCQUNQOzs7QUFFQSxnQkFBWSxVQUFrQixpQkFBTztBQUNsQyxnQkFBUyxXQUFRLFFBQWMsYUFBRTtBQUM5QixtQkFBYSxhQUFLLE1BQ3hCOzs7Ozs7QUFLRyxnQkFBSyxLQUFXLGNBQVksV0FBWSxhQUFXLFNBQUU7QUFDbEQsbUJBQWEsYUFBUyxVQUM1Qjs7O0FBRUksaUJBQWdCLGdCQUFVOzs7OztBQUszQixnQkFBTSxTQUFjLFlBQUU7QUFDbEIscUJBQVMsUUFBUSxRQUFnQixnQkFDeEM7O0FBQ1UsdUJBQUssTUFBYyxjQUFVLFVBQU0sTUFBTSxNQUFPLE9BQVU7QUFDcEUsbUJBQ0Y7QUFBRSxpQkFBSztBQUNtQyw2SUFBSyxNQUFjLGNBQVUsVUFBTSxNQUM3RTtBQUNGOzs7QUFnQm1DOzs7Ozs7Ozs7Ozs7Ozs7OztxREFBSyxNQUFjLGNBQVUsVUFBRTtBQUNoRSxjQUE4QyxtSUFBSyxNQUFjLGNBQVc7O0FBRTVFLGNBQWMsWUFBVSxTQUFhLGFBQVU7QUFDL0MsY0FBUyxPQUFLO0FBQ1YsZUFBQyxJQUFXLFVBQVksV0FBRTtBQUM1QixnQkFBVSxRQUFFLENBQUMsRUFBTSxZQUFRLGdCQUFjLGNBQUUsQ0FBVztBQUM1Qyx1QkFBSyxNQUFjLGNBQVUsVUFBWSxZQUFXLFdBQVEsUUFDeEU7O0FBQ0EsaUJBQ0Y7OztBQW1DcUI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt1Q0FBSyxNQUFjLGNBQUU7QUFDeEMsY0FBVSxRQUFJO0FBQ2QsY0FBYyxZQUFHO0FBQ2pCLGNBQUs7Ozs7Ozs7QUFPQyxpQkFBQyxDQUFHLElBQWMsYUFBSyxLQUFRLFdBQVEsTUFBRTs7QUFFMUMsZ0JBQUUsRUFBTyxRQUFXLFdBQUU7QUFDbEIsb0JBQUssS0FBQyxFQUFRLFNBQU0sS0FBTSxNQUFVLFdBQUcsRUFDOUM7OztBQUVBLGdCQUFTLE9BQUcsRUFBRyxHQUFHO0FBQ2xCLGdCQUFXLFNBQVMsUUFBRSxFQUFJO0FBQzFCLGdCQUFXLFNBQUcsRUFBRyxHQUFPO0FBQ3hCLGdCQUFnQixjQUFPO2dCQUFjLGNBQUk7Z0JBQVEsUUFBRSxDQUFFO0FBQ2xELGdCQUFNLFFBQU8sT0FBRyxDQUFPLFFBQVEsT0FBUSxRQUFRLFNBQUcsR0FBRTtBQUN6Qyw0QkFBUSxPQUFVLFVBQU8sUUFBSTtBQUNsQyx1QkFBUSxPQUFVLFVBQUUsR0FBUTtBQUN2Qiw0QkFDZDs7QUFDQSxnQkFBYyxZQUFhLFlBQVE7QUFDbkMsZ0JBQWlCLGVBQUk7QUFDbEIsZ0JBQVU7QUFFUDtBQUZTLGtCQUVKLE9BQXlCO2tCQUFYOztBQUNuQixtQkFBQyxJQUFLLElBQUUsR0FBRyxJQUFLLEtBQU8sUUFBSyxLQUFFO0FBQ2hDLG9CQUFRLE1BQU0sS0FBRztBQUNkLG9CQUFDLENBQUksSUFBUSxTQUFFO0FBQ0osK0JBQUssS0FDbkI7QUFDRjs7QUFDQSxrQkFBZSxhQUFjLGFBQVc7QUFDckMsa0JBQVksY0FBYSxXQUFhLGVBQVksVUFBTyxRQUFFO0FBQ2hELDZCQUFLLEtBQVk7QUFDcEIsMEJBQVcsWUFDdEI7QUFDRjtBQUFFLG1CQUFLOztBQUVPLDJCQUFLLEtBQ25COztBQUNLLGtCQUFLO0FBQ0YsOEJBQU0sWUFBUSxnQkFBYSwwQkFBVyxzQkFBYztBQUNyRCxxQkFDTDtBQUhTO0FBSUQsd0JBQWMsYUFDMUI7OztBQUVHLGNBQVcsYUFBYSxZQUFNLEtBQU8sUUFBRTtBQUN4QyxnQkFBWSxVQUFNLEtBQVUsVUFBVztBQUNwQyxnQkFBUSxTQUFFO0FBQ04sb0JBQUs7QUFDRCx5QkFFWDtBQUhhO0FBSWY7O0FBQ0csY0FBTSxNQUFPLFFBQUU7QUFDaEIsbUJBQ0Y7QUFBRSxpQkFBSztBQUNMLG1CQUNGO0FBQ0Y7OztBQWdCdUI7Ozs7Ozs7Ozs7Ozs7Ozs7O3lDQUFLLE1BQU0sTUFBTSxNQUFPLE9BQVUsVUFBVSxVQUFFO0FBQ25FLGNBQVM7QUFDTixjQUFLLEtBQVUsV0FBRTtBQUNaLG9CQUFpQixnQkFBSyxNQUFNLE1BQU8sT0FBVSxVQUFNLEtBQzNEO0FBQUUscUJBQWMsUUFBTyxLQUFPLFFBQUU7QUFDeEIsb0JBQVMsUUFBSyxLQUFJLElBQUssTUFBTSxLQUNyQztBQUFFLFdBRlEsTUFFSDtBQUNGLGdCQUFVLFlBQVUsUUFBSyxLQUFPLE9BQU0sT0FBRTtBQUNuQyxzQkFBUyxRQUFLLEtBQUksSUFBSyxNQUMvQjtBQUFFLG1CQUFLO0FBQ0Msc0JBQU0sS0FBTyxPQUNyQjtBQUNGOztBQUNHLGNBQUssS0FBTyxRQUFFO0FBQ1Qsb0JBQUUsQ0FDVjs7QUFDQSxpQkFDRjtBQUVGOzs7O01BMStDa0Q7Ozs7O0FBNitDOUIsMEJBQWlCOztBQUVyQyxXQUNGO0FBQUUsR0FsZ0QrQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTJoRGpDLE1BQWM7O0FBRVAsV0FBSTs7Ozs7O0FBTUcsd0NBQUssTUFBRTtBQUNkLFVBQUssS0FBTSxNQUFPLFFBQUU7QUFDckIsWUFBUyxPQUFNLEtBQU0sTUFBSyxLQUFNLE1BQU8sU0FBRztBQUN0QyxhQUFlLGVBQ3JCO0FBQ0Y7QUFBQzs7Ozs7OztBQU1XLHdDQUFLLE1BQUU7QUFDYixXQUFNLE1BQUssS0FDakI7QUFBQzs7Ozs7OztBQU1TLG9DQUFLLE1BQUU7QUFDZixVQUFhLFdBQU0sS0FBTSxNQUFPO0FBQzdCLFVBQVUsWUFBTyxLQUFNLE1BQVMsV0FBSSxNQUFPLE1BQUU7QUFDMUMsYUFBTSxNQUNaO0FBQ0Y7QUFJSjtBQXBDa0I7QUFvQ2QsSzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3JuRkosQ0FBVTtBQUNJOzs7O0FBR1osTUFBZTs7QUFNZjs7Ozs7QUFWVSxNQVVNO0FBQ0Y7QUFBRTs7QUFDUixXQUFjLGVBQU07QUFDcEIsV0FBVyxZQUFNO0FBQ2pCLFdBQVEsU0FDZDs7QUFTUzs7Ozs7Ozs7Ozs7O2dDQUFZLGFBQVU7QUFBRTs7QUFDM0IsYUFBYyxlQUFhO0FBQzNCLGFBQVcsWUFBVTtBQUNyQixhQUFRLGNBQW1CLGFBQUksSUFBSSxZQUFHO0FBQ3BDLGdCQUFRLFNBQU07QUFDZCxnQkFDTjtBQUNGLFNBSm9COztBQVFiOzs7Ozs7K0JBQUU7QUFDSixZQUFLLEtBQVcsWUFBRTtBQUNmLGVBQWEsYUFBTyxPQUFLLEtBQVE7QUFDakMsZUFBUSxTQUNkO0FBQ0Y7O0FBSU07Ozs7Ozs4QkFBRTtBQUNILFlBQUssS0FBVyxZQUFFO0FBQ2YsZUFBUztBQUNULGVBQ047QUFDRjs7QUFNUzs7Ozs7Ozs7aUNBQUU7QUFDVCxlQUFXLEtBQVEsVUFDckI7O0FBK0JlOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7K0JBQVUsV0FBYSxhQUFVLFVBQUU7QUFDN0MsWUFBVyxxQkFBb0IsV0FBRTtBQUN6QixvQkFDWDtBQUFFLGVBQUs7QUFDSyxzQkFBRSxJQUNkOztBQUNTLGtCQUFVLFVBQVksYUFBVztBQUMxQyxlQUNGO0FBQ0Y7Ozs7OztBQUVPLFVBQVcsWUFDcEI7QUFBSSxLOzs7Ozs7Ozs7OztBQ3ZHSixDQUFVLFlBQUU7QUFDRTs7QUFFWixNQUFtQixpQkFBSTs7Ozs7Ozs7QUFRaEIsVUFBa0IsbUJBQVUsVUFBVSxXQUFFO0FBQy9CLG1CQUFLLEtBQ3JCOzs7QUFFQSxXQUF5QixrQkFBRTtBQUN6QixRQUFlLFdBQVMsUUFBZSxlQUFRO0FBQ3pDLFdBQWUsZUFBTyxRQUFFO0FBQzVCLFVBQUk7QUFDWSx1QkFBUSxRQUN4QjtRQUFPLE9BQUUsR0FBRTtBQUNDLG1CQUFJLFlBQUc7QUFDZixnQkFDRjtBQUNGO0FBQ0Y7O0FBQ0EsV0FDRjs7Ozs7Ozs7OztBQVNPLFVBQU8sUUFBVyxZQUFFO0FBQ3pCLFFBQVk7UUFBWTtBQUN4QixPQUFHO0FBQ1EsaUJBQVEsT0FBVSxZQUFXLFNBQVE7QUFDM0MsVUFBTyxPQUFVLFlBQVMsT0FBUyxTQUFZLGFBQUU7QUFDNUMsZUFBUyxTQUFZLFlBQzdCOztBQUNXLG1CQUNiO0FBQVEsYUFBVSxZQUNwQjtBQUVGO0FBQUksSzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzNDRixDQUFVO0FBQ0k7Ozs7Ozs7QUFNWixNQUFnQixjQUFNOzs7OztBQUt0QixXQUFzQywrQkFBRTtBQUFFLFdBQW9COztBQUNsQywrQkFBVyxtQkFBZSxPQUFvQixvQkFBVTtBQUN2RTtBQUNKLGFBQThCO0FBQzNCLGdCQUVWO0FBSmE7QUFEdUUsR0FBdkM7Ozs7OztBQVcvQyxNQUFtQixlQUFTLFFBQWdCLGdCQUE4Qjs7Ozs7O0FBTTFFLE1BQTBCLHNCQUFTLFFBQVksWUFBYzs7O0FBRzdELFdBQXdCLGdCQUFTLFVBQWEsYUFBRTtBQUNsQyxrQkFBVTtBQUNoQixXQUFlLGVBQVMsVUFBYSxZQUFXO0FBQ3RELFFBQWlCO0FBQ0wsa0JBQ2Q7Ozs7Ozs7O0FBT0EsTUFBVyxlQUFtQztBQUExQjs7Ozs7OztBQVFwQjs7Ozs7OztBQXJEVSxNQXFEaUI7OztBQUNkLGtDQUFNO0FBQ1I7Ozs7QUFDSCxZQUFxQixxQkFBTztBQUM1QixZQUFNLE9BQU0sTUFBZSxlQUFLLE1BQVk7O0FBRWhELFVBQWEsV0FBTSxNQUFVLFdBQUk7QUFDN0IsV0FBQyxJQUFNLElBQU0sTUFBSyxLQUFXLFlBQUcsR0FBRyxJQUFFLEVBQVksYUFBRTtBQUM3QyxpQkFBSyxLQUFHO0FBQ2YsVUFDSDs7QUFDRyxVQUFLLE1BQWtCLGtCQUF5QiwwQkFBRTtBQUMvQyxjQUFrQixrQkFDeEI7Ozs7QUFHQSxVQUFZLFVBQU0sTUFBb0I7QUFDbkMsVUFBUSxTQUFVLFFBQWdCLGFBQWpDLElBQW9DLENBQVEsUUFBYyxlQUFFO0FBQzFELGNBQ047QUFDRjs7O0FBT29COzs7Ozs7Ozs7OzJDQUFNLE9BQUU7QUFDMUIsWUFBWSxVQUFNLEtBQW9CO0FBQ25DLFlBQU0sT0FBRTtBQUNMLGVBQUMsSUFBVSxTQUFVLFFBQWMsZUFBRTtBQUNwQyxnQkFBTyxTQUFRLE9BQUU7QUFDZCxtQkFBb0Isb0JBQU0sT0FBTyxNQUN2QztBQUNGO0FBQ0Y7O0FBQ0ksYUFBQyxJQUFVLFNBQU8sS0FBWSxhQUFFO0FBQzlCLGVBQW9CLG9CQUFNLE9BQU0sS0FBVyxXQUFVLFdBQzNEO0FBQ0Y7O0FBV2U7Ozs7Ozs7Ozs7Ozs7c0NBQUssTUFBTyxPQUFFO0FBQ3hCLFlBQUssS0FBMEIsMEJBQUssTUFBTyxPQUFPLE9BQU8sT0FBRTtBQUN4RCxlQUFXLFdBQWUsZUFDaEM7QUFDRjs7QUFJdUI7Ozs7Ozs4Q0FBSyxNQUFXLFdBQVM7QUFBRTs7QUFDN0MsWUFBSyxLQUFhLGVBQU8sS0FBb0Isb0JBQVksYUFBRTs7O0FBR3hELGVBQVksWUFBd0Isd0JBQUssTUFBVyxXQUFFLFVBQUksR0FBRztBQUM5RCxjQUFhO0FBQ1Asb0JBQ1Q7QUFDRjtBQUFFLGVBQUs7OztBQUdMLGNBQWlCLGVBQU0sS0FBVyxXQUFXO0FBQzFDLGNBQWEsY0FBRTtBQUNKLHlCQUF3Qix3QkFBSyxNQUFXLFdBQ3REO0FBQ0Y7QUFDRjs7QUFTaUI7Ozs7Ozs7Ozs7O3dDQUFLLE1BQUU7QUFDdEIsWUFBTSxJQUFNLEtBQVM7QUFDakIsYUFBQyxJQUFLLElBQUUsR0FBRyxJQUFFLEVBQU8sUUFBSyxLQUFFO0FBQzdCLGNBQU0sSUFBRyxFQUFHOztBQUVULGNBQVEsUUFBTyxTQUFVLFFBQUUsRUFBMEIsMkJBQUU7QUFDckQsZ0JBQUUsRUFBVSxhQUFRLEtBQVUsV0FBRTtBQUM5QixrQkFBSyxNQUFFO0FBQ1Asa0JBQXdCLHlCQUFHLEVBQVk7QUFDdkMsa0JBQWEsY0FDaEI7QUFBRSxxQkFBSztBQUNKLGtCQUFhLGNBQUcsRUFDbkI7QUFDRjtBQUFFLG1CQUFRLElBQUUsRUFBTSxPQUFFO0FBQ2Ysa0JBQUssTUFBRTtBQUNQLGtCQUFvQixxQkFBRyxFQUFNLE1BQVE7QUFDckMsa0JBQU0sTUFBUyxVQUNsQjtBQUFFLHFCQUFLO0FBQ0osa0JBQU0sTUFBUyxVQUFHLEVBQ3JCO0FBQ0Y7QUFDRjs7QUFDQyxZQUEwQiwyQkFBTTtBQUM5QixjQUFFLEVBQWtCLG1CQUFFO0FBQ3RCLGNBQWtCLGtCQUNyQjtBQUNGO0FBQ0Y7O0FBUTJCOzs7Ozs7Ozs7O2tEQUFLLE1BQU0sTUFBTyxPQUFFO0FBQzFDLFlBQUssS0FBMEIsNEJBQzFCLEtBQVUsWUFBTyxLQUFXLGFBQVEsUUFBZ0IsZUFBRTtBQUN4RCxlQUF3Qix5QkFDOUI7QUFBRSxlQUFLO0FBQzRCLGtLQUFLLE1BQU0sTUFDOUM7QUFDRjs7QUFRZ0I7Ozs7Ozs7Ozs7MEJBQUU7QUFDaEIsWUFBVSxRQUFNLEtBQWM7QUFDM0IsWUFBQyxDQUFNLE9BQUU7QUFDVixjQUFXO0FBQ0wsa0JBQUU7QUFDUixhQUFHOzs7QUFHSyxvQkFBTyxNQUFXLFdBQzFCO0FBQVEsbUJBQUMsQ0FBUyxVQUFPLE1BQXNCLHdCQUFHLENBQVEsUUFBWTtBQUNsRSxlQUFlLGdCQUNyQjs7QUFDQSxlQUNGO0FBQ0Y7Ozs7SUFuSndDOzs7OztBQXNKcEIsdUJBQVUsVUFBVzs7QUFFckIsdUJBQVUsVUFBb0I7O0FBRTlCLHVCQUFVLFVBQVk7O0FBRXRCLHVCQUFVLFVBQWtCOztBQUU1Qix1QkFBVSxVQUFZOzs7Ozs7O0FBTzFDLE1BQWtDLDhCQUFTLFFBQVksWUFBc0I7O0FBRTdFLFdBQXVCLGVBQVMsVUFBRTs7Ozs7O0FBTWhDLFFBQWlCLGVBQVUsU0FBVztBQUN0QyxXQUFvQixnQkFBZSxhQUFhLGVBQ2xEOzs7Ozs7O0FBTUEsV0FBK0IsdUJBQVMsVUFBYyxjQUFTLFNBQUU7O0FBRS9ELFFBQVMsT0FBUyxRQUFhLGNBQ0QsOEJBQXNCOzs7OztBQUtwRDtBQUFrQjs7Ozs7Ozs7O01BQWU7QUFDNUIsVUFBVSxVQUFxQixzQkFBUztBQUN4QyxVQUFVLFVBQWMsY0FBVTtBQUN2QixxQkFBTSxPQUFVLFVBQWMsY0FBVTtBQUN4RCxXQUNGOzs7Ozs7QUFLQSxXQUE0QixvQkFBUyxVQUFjLGNBQVMsU0FBRTtBQUM1RCxRQUF3QixzQkFBUyxRQUFnQjtBQUM5QyxRQUFvQixxQkFBRTs7QUFFdkIsVUFBVSxRQUFjLGFBQXdCO0FBQzdDLFVBQUMsQ0FBTSxPQUFFO0FBQ1YsWUFBUyxTQUFTLFFBQWEsY0FBc0Isc0JBQWM7QUFDN0QsNkJBQ3NCO0FBRFI7Ozs7Ozs7OztVQUNzQjs7O0FBRzFDLFlBQWMsWUFBYyxhQUFVO0FBQ2xDLGFBQUMsSUFBUyxRQUFZLFdBQUU7QUFDckIsZ0JBQVUsVUFBbUIsbUJBQVUsV0FBTSxNQUMzQyxNQUFVLFVBQXNCLHNCQUFVLFdBQy9DLEVBQUcsSUFBNkIsNEJBQUssTUFBd0I7QUFDMUQsZ0JBQVUsVUFBeUIseUJBQVUsV0FDcEQ7QUFDRjs7QUFDZSxzQkFBUyxVQUFROzs7QUFHN0IsVUFBUyxTQUFZLGFBQUU7OztBQUdsQixlQUFPLE9BQVMsU0FBTyxRQUFVLFNBQ3pDOzs7QUFFUSxlQUFZLGFBQUk7QUFDaEIsZUFBZSxnQkFBTTtBQUNyQixlQUFXLFlBQU07QUFDakIsZUFDVjtBQUNGOzs7O0FBR0EsV0FBb0MsNEJBQVMsVUFBcUIscUJBQUU7QUFDbEUsV0FBTyxTQUF3QixnQkFBUyxVQUFNLE1BQU8sT0FBRTtBQUNsQywwQkFBSyxLQUFTLFNBQWtCLG1CQUM3QyxLQUFVLFVBQVMsU0FBUSxTQUFPLE1BQzFDO0FBQ0Y7OztBQUVBLFdBQXlCLGlCQUFNLE9BQVUsVUFBYyxjQUFTLFNBQUU7QUFDaEUsUUFBYyxZQUFjLGFBQVcsYUFBSztBQUN4QyxTQUFDLElBQVUsU0FBVSxRQUFjLGVBQUU7QUFDdkMsYUFBZ0IsVUFBTztBQUN2QixVQUEyQix5QkFBUyxRQUFtQjtBQUNwRCxVQUF1Qix3QkFBRTtBQUNyQixjQUFVLFVBQW1CLG1CQUFNLE9BQ2pDLE1BQVUsVUFBc0Isc0JBQU8sUUFDNUMsRUFBRyxJQUFnQywrQkFBTSxPQUM3QztBQUNGOztBQUNHLFFBQVEsUUFBaUIsbUJBQVcsU0FBVyxZQUFFO0FBQzlDLFdBQUMsSUFBVSxTQUFZLFdBQUU7QUFDdEIsY0FBVSxVQUFtQixtQkFBTSxPQUNqQyxNQUFVLFVBQXNCLHNCQUFPLFFBQzVDLEVBQUcsSUFDUDtBQUNGO0FBQ0Y7OztBQUVBLFdBQXVDLCtCQUFTLFVBQXdCLHdCQUFFO0FBQ3hFLFdBQU8sU0FBMkIsbUJBQUssTUFBTSxNQUFPLE9BQUU7QUFDOUIsNkJBQUssS0FBSyxLQUFrQixtQkFDNUMsTUFBTSxNQUFPLE1BQ3JCO0FBQ0Y7OztBQUVBLFdBQW9DLDZCQUFFO0FBQ3BDLFdBQU8sU0FBdUIsZUFBSyxNQUFNLE1BQU8sT0FBRTtBQUM1QyxXQUFXLFdBQTBCLDBCQUFVLFdBQU0sTUFBTyxNQUFNLE9BQU0sTUFDOUU7QUFDRjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTBDQSxNQUFpQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBK0RMLG9DQUFTLFVBQU8sT0FBUyxTQUFFO0FBQzNCLGdCQUFtQyxpQ0FBUyxXQUFNO0FBQ3ZELFVBQVMsU0FBa0IsbUJBQUU7QUFDOUIsY0FBTSxJQUFTLE1BQ2pCOztBQUNRLGVBQW1CLG9CQUFPO0FBQ2xDLFVBQWlCLGVBQU8sTUFBWSxZQUFlLGVBQVU7OztBQUc3RCxVQUFjLFlBQWMsYUFBd0I7QUFDakQsVUFBQyxDQUFVLFdBQUU7QUFDSixvQkFBd0IsdUJBQVMsVUFBYyxjQUFVO0FBQ3ZELHFCQUF5QiwwQkFDdkM7OztBQUVtQiwwQkFBUyxVQUFjLGNBQVU7O0FBRXBEO0FBQW1DOzs7Ozs7Ozs7UUFBb0I7QUFDbEQsWUFBVSxVQUFhLGNBQWdCLGVBQVU7QUFDakQsWUFBVSxVQUFZLGFBQVU7QUFDaEMsWUFBVSxVQUFtQixvQkFBTztBQUNwQyxZQUFVLFVBQWEsY0FBYyxhQUFVO0FBQ3BELGFBQXdELGtEQUMxRDs7QUFBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBdUJjLDhDQUFTLFVBQU0sTUFBRTtBQUM5QixVQUFTO0FBQ0gsYUFBSyxNQUFFOzs7O0FBSVAsWUFBTyxRQUFNLEtBQXNCLHNCQUFFOzs7QUFHcEMsY0FBTSxNQUFZLGNBQVcsVUFBRTtBQUMzQixtQkFBTyxNQUNkO0FBQUUsaUJBQUs7QUFDTCxtQkFDRjtBQUNGO0FBQUUsZUFBSzs7O0FBR0EsaUJBQU0sS0FDYjtBQUNGOztBQUNBLGFBQ0Y7QUFDRjtBQW5JbUI7O0FBcUlaLFVBQVksYUFBWTtBQUN4QixVQUFzQix1QkFFL0I7QUFBSSxLOzs7Ozs7Ozs7Ozs7Ozs7O0FDcmZHLFFBQW1CLHFCQUNqQixRQUFzQjs7QUFFcEI7QUFDVyx3QkFBMEI7QUFDL0IsbUJBQ2Q7QUFIVTs7QUFLSCxZQUFXLG9CQUFFO0FBQ2YsU0FBSyxLQUNYO0FBQUM7O0FBRXFCLDBCQUFVLGdDQUFFLEdBQUU7QUFDL0IsUUFBUSxRQUFJLElBQUcsR0FBSyxLQUFJLE9BQVEsTUFBRTtBQUVyQzs7QUFDSSxTQUFjO0FBQ2pCLE1BQ0g7QUFBQzs7QUFFa0IsdUJBQVcsK0JBQUU7QUFDdkIsWUFBTSxNQUNmO0FBQUM7Ozs7Ozs7OztBQVNVLGVBQVcsdUJBQUU7O0FBRXRCLFFBQVMsT0FBTTtBQUNmLFFBQU8sS0FBTSxLQUFvQixvQkFBSyxLQUFNO0FBQ3pDLFFBQVEsUUFBTyxTQUFVLFFBQU0sTUFBZSxnQkFBRTtBQUM3QyxXQUFrQixtQkFBUyxRQUFVLFVBQVMsU0FDMUMsS0FBaUIsa0JBQ2QsUUFBTSxNQUFlLGdCQUN6QjtBQUNBLGNBQWlCLGlCQUFLLEtBQy9COztBQUVBO1NBQUs7QUFDQyxhQUFTLFNBQWMsZUFDN0I7O0FBQ0ksU0FDTjtBQUFDOztBQUVtQix3QkFBVyxnQ0FBRTtBQUMvQixRQUFTLE9BQU07Ozs7QUFJTSwwQkFBVSxZQUFFO0FBQzNCLFdBQUssS0FDWDtBQUNGO0FBQUM7O0FBRXNCLDJCQUFXLG1DQUFFO0FBQy9CLFFBQUMsQ0FBSyxLQUFXLFlBQUU7QUFFdEI7O0FBQ0ksU0FBc0Isc0JBQVEsUUFBUyxVQUFVLFdBQUU7QUFDbEQsVUFBSyxLQUFvQixvQkFBVyxZQUFFO0FBQ25DLGFBQWtCLGtCQUN4QjtBQUNGO0FBQUMsT0FDSDtBQUNBO0FBcEUrQixDQURMLEU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDRTlCLENBQVUsWUFBRTtBQUNFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF1RUwsVUFBYyx1QkFBdUIsY0FBTTs7Ozs7OztBQU9oRCxRQUF5QixxQkFBUyxRQUFnQixnQkFBTTs7QUFFeEQsUUFBWSxVQUFTLFFBQVE7Ozs7Ozs7Ozs7OztBQVk3QixhQUE4QixzQkFBTSxPQUFFO0FBQ2pDLFVBQUMsQ0FBTSxNQUFlLGVBQ0UsMEJBQWtCLG1CQUFTLFNBQUU7QUFDakQsY0FBaUIsa0JBQ2YsTUFBZSxlQUEwQiwwQkFBYSxjQUFVOzhDQUN2QixLQUFQLENBQW1CLGFBQzlEOztBQUNBLGFBQVksTUFDZDs7Ozs7Ozs7Ozs7QUFVQSxhQUE2QixxQkFBTSxPQUFFO0FBQ2hDLFVBQUMsQ0FBTSxNQUFlLGVBQ0UsMEJBQWlCLGtCQUFTLFNBQUU7QUFDaEQsY0FBZ0IsaUJBQ2QsTUFBZSxlQUEwQiwwQkFBWSxhQUFVOzhDQUN0QixLQUFQLENBQWtCLFlBQzdEOztBQUNBLGFBQVksTUFDZDs7Ozs7Ozs7Ozs7O0FBV0EsYUFBMEIsa0JBQWUsZ0JBQU8sT0FBRTtBQUM1QyxXQUFDLElBQU0sS0FBUSxPQUFFO0FBQ25CLFlBQU0sSUFBTyxNQUFHO0FBQ2IsWUFBQyxPQUFTLEtBQWEsWUFBRTtBQUN4QixjQUFFLEVBQU0sTUFDWjs7QUFDYyx1QkFBSSxLQUNwQjs7QUFDQSxhQUNGOzs7Ozs7Ozs7Ozs7OztBQWFBLGFBQTJCLG1CQUFNLE9BQUU7QUFDOUIsVUFBQyxDQUFNLE1BQWUsZUFDRSwwQkFBb0IscUJBQVMsU0FBRTtBQUNuRCxjQUFtQixvQkFDUCxrQkFBRyxJQUF1QixzQkFBUTtBQUNuRCxZQUFjLFlBQVEsT0FBZSxlQUFNLE1BQVcsV0FBWTtBQUMvRCxZQUFVLFVBQVcscUJBQXlCLGdCQUFFO0FBQzVDLGdCQUFtQixvQkFBUSxPQUFPLE9BQy9CLE9BQU8sT0FBbUIsb0JBQXVDLHNDQUFhLGFBQy9FLE1BQ1Q7QUFDRjs7QUFDQSxhQUFZLE1BQ2Q7Ozs7Ozs7Ozs7Ozs7O0FBYUEsYUFBaUMseUJBQU0sT0FBRTtBQUNwQyxVQUFDLENBQU0sTUFBZSxlQUNFLDBCQUEwQiwyQkFBUyxTQUFFO0FBQ3pELGNBQXlCLDBCQUFNO0FBQ3BDLFlBQVUsUUFBb0IsbUJBQU87QUFDakMsYUFBQyxJQUFNLEtBQVEsT0FBRTtBQUNuQixjQUFTLE9BQU8sTUFBRztBQUNoQixjQUFTLFdBQU8sTUFBRTtBQUNkLGtCQUF5QiwwQkFBTyxNQUF5QiwyQkFBSztBQUM5RCxrQkFBd0Isd0JBQUksS0FDbkM7QUFDRjtBQUNGOztBQUNBLGFBQVksTUFDZDs7Ozs7Ozs7OztBQVNBLGFBQTBCLGtCQUFNLE9BQUU7QUFDaEMsYUFBWSxNQUFlLGVBQTBCLDBCQUFjLGVBQ3JFOzs7Ozs7Ozs7OztBQVVBLGFBQThCLHNCQUFNLE9BQUU7QUFDcEMsVUFBVSw4Q0FBZ0QsS0FBUCxDQUFpQjtBQUNwRSxVQUFjLFlBQVEsT0FBZSxlQUFPLE9BQVk7QUFDckQsVUFBVSxVQUFXLHFCQUF5QixnQkFBRTtBQUN4QyxrQkFDWDs7QUFDYSxvQkFDZjs7Ozs7Ozs7Ozs7O0FBV0EsYUFBc0IsY0FBTSxPQUFFO0FBQ3ZCLFlBQWEsY0FBTTtBQUN4QixVQUFVLDhDQUFnRCxLQUFQLENBQWlCO0FBQ2pFLFVBQU0sTUFBZSxlQUNHLDBCQUFLLE1BQVUsV0FBUSxNQUFHLElBQUU7QUFDOUMsZ0JBQVUsVUFBUyxTQUM1Qjs7QUFDQSxVQUFVLFFBQXVCLHNCQUFPO0FBQ3JDLFVBQU0sT0FBRTtBQUNTLDJCQUFNLE9BQzFCOztBQUNBLFVBQWMsWUFBc0IscUJBQU87QUFDeEMsVUFBVSxXQUFFO0FBQ0ksMEJBQU0sT0FBVyxXQUNwQzs7O0FBRUEsVUFBYSxpREFBZ0QsS0FBUCxDQUFnQjtBQUNuRSxVQUFTLFVBQUU7QUFDVCxZQUFDLE9BQWdCLGFBQVksVUFBRTtBQUNoQyxjQUFNLElBQVUsU0FBYyxjQUFZO0FBQ3pDLFlBQVcsWUFBVTtBQUNiLHFCQUNYO0FBQUUsZUFBSztBQUNJLHFCQUFVLFNBQVUsVUFDL0I7O0FBQ0ssY0FBVyxZQUNsQjtBQUNGOzs7Ozs7Ozs7Ozs7OztBQWFBLGFBQTJCLG1CQUFNLE9BQVksWUFBRTtBQUN6QyxXQUFDLElBQU0sS0FBYSxZQUFFO0FBQ0EsaUNBQU0sT0FBRyxHQUFZLFdBQUcsSUFDbEQ7QUFDRjs7Ozs7Ozs7Ozs7Ozs7O0FBY0EsYUFBMEIsa0JBQU0sT0FBVyxXQUFZLFlBQUU7QUFDbkQsV0FBQyxJQUFLLElBQUUsR0FBSSxJQUFXLFVBQU8sUUFBSyxLQUFFO0FBQ2xDLGNBQXNCLHNCQUFVLFVBQUcsSUFDMUM7QUFDRjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTREQSxhQUFpQyx5QkFBTSxPQUFNLE1BQU0sTUFBVSxVQUFFOztBQUUxRCxVQUFLLEtBQVMsVUFBRTtBQUNiLGFBQVUsV0FDaEI7Ozs7Ozs7QUFNRyxVQUFLLEtBQVcsWUFBRyxDQUFNLE1BQW1CLG1CQUFNLE9BQUU7QUFDaEQsY0FBd0Isd0JBQUssTUFBTSxLQUFTLFVBQ25EOztBQUNHLFVBQUssS0FBVSxZQUFHLENBQU0sTUFBbUIsbUJBQU0sT0FBRTtBQUMvQyxjQUF3Qix3QkFBSyxNQUFFLENBQUssS0FDM0M7O0FBQ0csVUFBSyxLQUFvQixzQkFBRyxDQUFNLE1BQWtCLGtCQUFNLE9BQUU7QUFDeEQsY0FBeUIseUJBQ2hDOztBQUNHLFVBQUssS0FBUSxVQUFHLENBQU0sTUFBaUIsaUJBQU0sT0FBRTtBQUMzQyxjQUF5Qix5QkFDaEM7OztBQUVHLFVBQUssS0FBUyxVQUFFO0FBQ1osY0FBd0Isd0JBQUssTUFBTSxLQUFTLFVBQVUsU0FBSyxLQUNsRTtBQUNGOzs7Ozs7Ozs7Ozs7Ozs7OztBQWdCQSxhQUF5QixpQkFBTSxPQUFVLFVBQVMsU0FBSSxJQUFLLEtBQUU7O0FBRTNELFVBQVksVUFDSCxRQUFZLFlBQWdCLGdCQUFTLFVBQVcsV0FDaEQsUUFBWSxZQUFxQixxQkFBSTtBQUMzQyxVQUFRLFNBQUU7QUFDWCxZQUFVLFFBQVUsU0FBYyxjQUFTO0FBQ3RDLGNBQWEsY0FBUztBQUNuQixpQkFBUSxRQUFhLGFBQU0sT0FBVSxTQUFRLFFBQ3ZEOztBQUNHLFVBQU8sT0FBUyxVQUFFO0FBQ2IsZUFBUyxTQUFnQixnQkFBUyxVQUFJLElBQzlDOztBQUNLLFlBQWMsY0FDckI7OztBQVFBOzs7Ozs7O0FBelZtRCxRQXlWOUI7Ozs7Ozs7Ozs7Ozs7QUF3SEc7Ozs7Ozs7Ozs7O2dEQUFFO0FBQ2Ysa0JBQVUsVUFBZ0I7QUFDN0IsZUFBWSxZQUFXO0FBQzNCLGNBQWlCLGFBQU0sS0FBWSxZQUFXOzs7QUFHM0MsY0FBSyxLQUFXLGFBQUcsQ0FBSyxLQUFVLFVBQW1CLG9CQUFFO0FBQ3BELGlCQUFVLFVBQW9CLHFCQUFNO0FBQ3hDLGdCQUFjLFVBQ0QsYUFBUyxRQUFXLFdBQVcsV0FBYSxjQUFJO0FBQzdDLDhCQUErQiw4QkFBSyxLQUFXLFdBQU0sS0FBVSxXQUFTO3FDQUN2RCxJQUFOLENBQzdCOztBQUM2Qjs7QUFFekIsZUFBVSxXQUFTLFFBQVM7QUFDNUIsZUFBWSxhQUFZOztBQUU1QixjQUFPLEtBQTBCLHlCQUFLLEtBQWE7QUFDaEQsY0FBQyxDQUFHLElBQUU7QUFFVDs7QUFDSSxlQUFDLElBQU0sS0FBSyxJQUFFO0FBQ2hCLGdCQUFTLE9BQUksR0FBRzs7OztBQUliLGdCQUFDLENBQUssS0FBZSxlQUFHLElBQUU7QUFDM0Isa0JBQVUsUUFBRSxPQUFXLEtBQU8sU0FBYyxhQUN0QyxLQUFNLE1BQUssS0FBTyxRQUNsQixLQUFNOzs7QUFHVCxrQkFBSyxLQUFhLGFBQUcsSUFBRTtBQUNwQixxQkFBb0Isb0JBQUUsR0FBTyxPQUNuQztBQUFFLHFCQUFLO0FBQ0QscUJBQUksS0FDVjtBQUNGO0FBQ0Y7QUFDRjs7O0FBWWtCOzs7Ozs7Ozs7Ozs7OzRDQUFFO0FBQ2YsY0FBTyxPQUFVLFlBQU8sS0FBVSxXQUFFO0FBQy9CLG1CQUFTLFNBQWEsY0FBNEIsMkJBQzFEOztBQUNJLGVBQ047OztBQU1xQjs7Ozs7OzsrQ0FBRzs7QUFPbEI7Ozs7Ozs7O2dDQUFFO0FBQ0gsY0FBSyxLQUFVLFdBQUU7QUFDZCxpQkFBTSxPQUFNLEtBQWUsZUFBSyxLQUFXO0FBQzNDLGlCQUFHLElBQU0sS0FBSyxLQUNwQjs7QUFFRjs7O0FBV2M7Ozs7Ozs7Ozs7Ozt3Q0FBRTtBQUNYLGNBQUssS0FBVSxXQUFFO0FBQ2QsaUJBQU0sT0FBTSxLQUFXLFdBQUssS0FDbEM7Ozs7OztBQU1GOzs7QUFjVTs7Ozs7Ozs7Ozs7Ozs7bUNBQUksS0FBRTtBQUNYLGNBQUssS0FBYSxjQUFFO0FBQ2xCLGdCQUFJLEtBQUU7QUFDSixrQkFBQyxDQUFLLEtBQVcsWUFBRTtBQUNoQixxQkFBYSxhQUFDLEVBQUssTUFDekI7O0FBQ0ksbUJBQVcsV0FBWSxZQUFLO0FBQ2hDLHFCQUFXLEtBQ2I7O0FBQ0EsbUJBQ0Y7QUFBRSxpQkFBSztBQUNMLGtCQUFNLElBQVMsTUFBNkI7O0FBRWdCLDBFQUU5RDtBQUNGOzs7QUFnQndCOzs7Ozs7Ozs7Ozs7Ozs7OztpREFBSyxNQUFLLEtBQU8sT0FBRTtBQUN0QyxjQUFLLFFBQVMsT0FBRTtBQUNqQixnQkFBYSxXQUFTLFFBQWdCLGdCQUFNO0FBQzVDLGdCQUFTLE9BQW9CLG1CQUFLLEtBQWEsYUFBVSxVQUFLO0FBQzNELGdCQUFDLENBQUssS0FBbUIsbUJBQVUsV0FBRTtBQUNsQyxtQkFBcUIscUJBQUssTUFBTyxPQUN2QztBQUNGO0FBQ0Y7OztBQW1CWTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7cUNBQVcsWUFBRTtBQUNwQixjQUFPLE9BQVMsVUFBRTtBQUNiLG1CQUFTLFNBQWEsY0FBNEIsMkJBQU0sTUFDaEU7QUFDRjs7O0FBYVU7Ozs7Ozs7Ozs7Ozs7O21DQUFJLEtBQU0sTUFBRTtBQUNqQixjQUFDLENBQU0sUUFBTyxLQUFXLFlBQUU7QUFDdkIsbUJBQVMsUUFBVyxXQUFXLFdBQUssS0FDM0M7O0FBQ0EsaUJBQWMsUUFBVyxXQUFXLFdBQUksS0FDMUM7OztBQVc0Qjs7Ozs7Ozs7Ozs7Ozs7QUFoU1o7Ozs7Ozs7Ozs7OzttQ0FBRTtBQUNiLGNBQUMsQ0FBa0Isa0JBQU0sT0FBRTtBQUNQLGtDQUN2QjtBQUNGOzs7QUF1Q29COzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzhDQXFQaUIsVUFBYyxjQUFVLFVBQUU7QUFDakQsdUJBQVksYUFBYyxhQUFZLGNBQXFCLG1CQUFNO0FBQzNDLG1JQUFTLFVBQWMsY0FDM0Q7QUFFRjs7Ozs7QUE3VGdDOzs7Ozs7Ozs0QkFBRTtBQUMzQixjQUFDLENBQUssS0FBZSxlQUEwQiwwQkFBdUIsd0JBQVEsUUFBRTtBQUNqRixnQkFBUyxPQUFJO0FBQ2IsZ0JBQWUsYUFBb0IsbUJBQU07QUFDckMsaUJBQUMsSUFBUyxRQUFhLFlBQUU7QUFDdkIsbUJBQUssS0FBUSxRQUFRLFFBQWdCLGdCQUMzQzs7QUFDSSxpQkFBc0IsdUJBQzVCOztBQUNBLGlCQUFXLEtBQ2I7Ozs7NEJBeURzQjtBQUNqQixjQUFDLENBQUssS0FBZSxlQUEwQiwwQkFBWSxhQUFRLFFBQUU7QUFDbEUsaUJBQVcsWUFBUyxRQUFXLGFBQVUsUUFBVSxVQUFPO2lEQUNoQixJQUFOLENBQVMsSUFBYzs7OztBQUl2RCxtQkFBZSxxREFBNkMsSUFBTixDQUFpQixXQUFZLFlBQzdGOztBQUNBLGlCQUFXLEtBQ2I7OztBQWFzQjs7Ozs7Ozs7Ozs7Ozs7NEJBQUU7QUFDbkIsY0FBQyxDQUFLLEtBQWUsZUFBMEIsMEJBQWMsZUFBUSxRQUFFO0FBQ3RFLGdCQUFhLFNBQVMsUUFBVyxhQUFVLFFBQVUsVUFBTyw4Q0FBOEMsSUFBTixDQUFVO0FBQzFHLGlCQUFhLGNBQVMsU0FBUSxPQUFXLFlBQUssTUFDNUMsT0FBZSxxREFBNkMsSUFBTixDQUFpQixXQUFZLFlBQzdGOztBQUNBLGlCQUFXLEtBQ2I7Ozs7O01BM0c4Qzs7QUF5VWhELFdBQ0Y7QUFBRSxHQW5xQjRCOzs7Ozs7Ozs7O0FBNnFCdkIsVUFBVzs7Ozs7QUFLSCxtQkFBRzs7Ozs7QUFLSCxtQkFBSTs7Ozs7O0FBTVYsYUFBVSxpQkFBVSxXQUFFO0FBQ3BCLGNBQUksSUFBSyxNQUFXLFVBQUksS0FDakM7QUFBQzs7Ozs7OztBQU9PLGNBQVUsa0JBQVUsV0FBRTtBQUN4QixXQUFjLGNBQUssS0FBVztBQUMzQixjQUFLLE9BQU8sS0FBUSxRQUM3QjtBQUFDOzs7Ozs7QUFNZ0IsdUJBQVcsNkJBQUU7QUFDeEIsV0FBYyxjQUFRLFFBQUssS0FDakM7QUFDRDtBQXJDbUI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXVEYixVQUFjLGVBQVUsVUFBTSxPQUFFO0FBQ2xDLFFBQU8sT0FBUyxVQUFFO0FBQ2IsYUFBUyxTQUFjLGNBQy9CO0FBQ0Y7QUFFRjtBQUFJLEs7Ozs7Ozs7Ozs7Ozs7O0FDdnpCSixDQUFVLFlBQUU7QUFDRTs7Ozs7Ozs7QUFPWixNQUFlLFdBQVMsUUFBVSxZQUFLO0FBQy9CLFdBQVcsWUFBRyxDQUFPLE9BQVU7QUFDL0IsV0FBd0IseUJBQ3ZCLFFBQUMsQ0FBTyxPQUFVLFlBQVMsT0FBUyxTQUFXO0FBQ2hELFdBQXlCLDBCQUM5QixDQUFPLE9BQWUsZUFBMkI7Ozs7Ozs7O0FBUTdDLFVBQVUsV0FBVTs7Ozs7Ozs7Ozs7O0FBWTNCLE1BQWEsV0FBUyxRQUFVLFlBQ3ZCLFFBQVcsV0FBWSxZQUFTLFNBQVMsV0FBUyxPQUFTLFNBQU07O0FBRW5FLFVBQVUsV0FBVTs7Ozs7Ozs7O0FBU3BCLFVBQWEsY0FBVSxVQUFLLE1BQUU7QUFDNUIsWUFBVSxXQUNuQjtBQUNGO0FBQUksSzs7Ozs7Ozs7Ozs7QUNwREosQ0FBVSxZQUFFO0FBQ0U7O0FBRVosTUFBaUMsNkJBQStCO0FBQ2hFLE1BQW1CLGVBQVc7O0FBRTlCLFdBQXFCLGFBQVMsVUFBRTtBQUMzQixRQUFDLENBQVEsUUFBVSxXQUFFO0FBQ3RCLGFBQ0Y7O0FBQ0EsV0FBYyxRQUFVLFVBQU8sT0FDakM7Ozs7QUFHQSxNQUF5Qjs7Ozs7Ozs7OztBQVV6QixNQUFrQjs7Ozs7Ozs7Ozs7QUFXRiw0Q0FBVSxXQUFFO0FBQ3hCLFVBQVksVUFBVyxVQUFPLE9BQU0sTUFBSztBQUN6QyxVQUFZLFVBQUk7QUFDWixXQUFDLElBQUssSUFBRSxHQUFJLElBQVMsUUFBTyxRQUFLLEtBQUU7QUFDN0IsbUJBQU8sS0FBYyxjQUFRLFFBQ3ZDOztBQUNBLGFBQ0Y7QUFBQzs7Ozs7Ozs7Ozs7Ozs7OztBQWVZLDBDQUFTLFVBQUU7QUFDdEIsVUFBTSxJQUFjLGFBQVU7QUFDM0IsVUFBRyxLQUFJLEVBQVUsYUFBYSxXQUFFO0FBQ2pDLFlBQVksVUFBSTs7QUFFaEIsWUFBTSxJQUFHLEVBQWMsY0FBWTtBQUNoQyxZQUFFLEdBQUU7QUFDRyxxQkFBTyxLQUFnQixnQkFBRSx1Q0FBeUMsQ0FBSCxDQUN6RTs7O0FBRVEsbUJBQU8sS0FBcUIscUJBQVU7QUFDN0MsVUFBVSxXQUFVLFdBQ3ZCOztBQUNHLFVBQUMsQ0FBRSxHQUFFO0FBQ0MsZ0JBQUssS0FBNEMsNkNBQzFEOztBQUNBLGFBQVMsS0FBSSxFQUFVLFlBQ3pCO0FBQUM7Ozs7Ozs7Ozs7Ozs7O0FBYWMsOENBQVMsVUFBUyxTQUFFO0FBQ2pDLFVBQVksVUFBSTs7QUFFaEIsVUFBTyxLQUFVLFNBQVEsUUFBaUIsaUJBQVM7QUFDL0MsV0FBQyxJQUFLLElBQUUsR0FBSSxJQUFJLEdBQU8sUUFBSyxLQUFFO0FBQ2hDLFlBQU0sSUFBSSxHQUFHOzs7QUFHYixZQUFZLFVBQUcsRUFBYSxhQUFjO0FBQ3ZDLFlBQVEsU0FBRTtBQUNILHFCQUFPLEtBQWUsZUFDaEM7O0FBQ0MsVUFBVyxXQUFZLFlBQUc7QUFDbkIsbUJBQVcsVUFDVixRQUFXLFdBQVcsV0FBRSxFQUFZLGFBQVcsV0FBRyxFQUM3RDs7QUFDQSxhQUNGO0FBQUM7Ozs7Ozs7Ozs7OztBQVdtQix3REFBUyxVQUFFO0FBQzdCLFVBQVksVUFBSTtBQUNoQixVQUFNLElBQWMsYUFBVTtBQUMzQixVQUFDLENBQUUsR0FBRTtBQUNOLGVBQ0Y7O0FBQ0EsVUFBTyxLQUFHLEVBQWlCLGlCQUE0QjtBQUNuRCxXQUFDLElBQUssSUFBRSxHQUFJLElBQUksR0FBTyxRQUFLLEtBQUU7QUFDaEMsWUFBTSxJQUFJLEdBQUc7QUFDVixZQUFFLEVBQU8sUUFBRTtBQUNaLGNBQWMsWUFBRyxFQUFPOzs7O0FBSXhCLGNBQWMsWUFBVyxVQUFNLE9BQVcsVUFBTSxPQUFXO0FBQ25ELHFCQUNDLFFBQVcsV0FBVyxXQUFVLFVBQVksYUFDeEMsVUFDZjtBQUNGOztBQUNBLGFBQ0Y7QUFDRDtBQWpIbUI7O0FBbUhiLFVBQWEsY0FDdEI7QUFBSSxLOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbklKLENBQVUsWUFBRTs7QUFFRTs7QUFFWixNQUFtQixpQkFBUSxPQUFTOzs7Ozs7Ozs7Ozs7Ozs7OztBQWlCN0IsVUFBb0IsNkJBQXVCLGNBQUMsVUFBTzs7Ozs7Ozs7QUFReEQsUUFBd0Isb0JBQVMsUUFBc0Isc0JBQVEsUUFBYSxhQUFPOzs7Ozs7QUFNbkYsUUFBb0I7QUFDZixXQUFTO0FBQ1QsV0FBUztBQUNOLGNBQVE7QUFDVCxhQUNOO0FBTHFCOztBQWN0Qjs7Ozs7Ozs7QUE1QjJELFFBNEJ2Qzs7O0FBRU47QUFDSDs7OztBQUNILGNBQVk7QUFDWixjQUNOOzs7O0FBTVE7Ozs7Ozs7O2tDQUFHOztBQU9POzs7Ozs7Ozs0Q0FBRTtBQUNPO0FBQ3JCLGVBQVksYUFBTTtBQUNsQixlQUNOOzs7QUFNUzs7Ozs7OzttQ0FBRzs7QUFPUzs7Ozs7Ozs7K0NBQUU7QUFDTztBQUN4QixlQUFZLGFBQU87QUFDbkIsZUFDTjs7O0FBTVM7Ozs7Ozs7bUNBQUc7O0FBVVk7Ozs7Ozs7Ozs7O2lEQUFLLE1BQUssS0FBTyxPQUFFO0FBQ3RDLGNBQUssUUFBUyxPQUFFO0FBQ2EsbUpBQUssTUFBSyxLQUFRO0FBQzVDLGlCQUFpQixpQkFBSyxNQUFLLEtBQ2pDO0FBQ0Y7OztBQVNnQjs7Ozs7Ozs7Ozt5Q0FBSyxNQUFLLEtBQU8sT0FBRzs7QUFTZDs7Ozs7Ozs7OztnREFBRTtBQUN0QixjQUFVLFFBQVEsT0FBZSxlQUFNO0FBQ3BDLGNBQUMsQ0FBTSxNQUFlLGVBQXlCLDBCQUFFO0FBQzdDLGtCQUF1Qix3QkFBTTtBQUM5QixpQkFDTjs7QUFFRjs7O0FBU1k7Ozs7Ozs7Ozs7c0NBQUc7O0FBUVQ7Ozs7Ozs7OztnQ0FBRTtBQUNGLGVBQW9CO0FBQ3BCLGVBQWtCO0FBRXhCOzs7QUFZa0I7Ozs7Ozs7Ozs7Ozs7NENBQUc7O0FBWUw7Ozs7Ozs7Ozs7Ozs7MENBQUc7O0FBY1Y7Ozs7Ozs7Ozs7Ozs7OztrQ0FBTSxPQUFFO0FBQ2YsaUJBQVcsS0FBZ0IsZ0JBQzdCOzs7QUFlVzs7Ozs7Ozs7Ozs7Ozs7OztvQ0FBTSxPQUFNLE1BQUU7QUFDdkIsaUJBQVcsS0FBa0Isa0JBQU0sT0FDckM7OztBQVkwQjs7Ozs7Ozs7Ozs7OzttREFBUyxVQUFXLFdBQU8sT0FBRTtBQUNqRCxlQUFxQixxQkFBUyxVQUFXLFdBQy9DOzs7QUFZeUI7Ozs7Ozs7Ozs7Ozs7a0RBQU0sT0FBVyxXQUFNLE1BQUU7QUFDNUMsZUFBc0IsdUJBQXdCLHNCQUFNLFFBQVEsTUFBTyxPQUN6RTs7O0FBVU07Ozs7Ozs7Ozs7OytCQUFVLFdBQUssS0FBRTtBQUNsQixjQUFFLEVBQVcsYUFBTyxNQUFFO0FBQ3ZCLG1CQUFpQixhQUNuQjs7QUFDQSxjQUFPLEtBQVEsT0FBb0Isb0JBQUs7QUFDcEMsZUFBQyxJQUFLLElBQUUsR0FBRyxHQUFJLElBQUcsR0FBWSxNQUFqQixLQUFtQixJQUFHLEdBQUksS0FBSyxLQUFFO0FBQ2hELGdCQUFPLEtBQVEsT0FBeUIseUJBQUksS0FBSTtBQUM3QyxnQkFBRyxJQUFFO0FBQ0EscUJBQWUsZUFBVSxXQUFHLEdBQ3BDO0FBQ0Y7O0FBQ0EsaUJBQ0Y7OztBQWFLOzs7Ozs7Ozs7Ozs7Ozs4QkFBTyxRQUFRLFFBQUU7QUFDaEIsZUFBQyxJQUFNLEtBQVMsUUFBRTtBQUNkLG1CQUFJLEtBQVEsT0FDcEI7O0FBQ0EsaUJBQ0Y7OztBQWFXOzs7Ozs7Ozs7Ozs7OztvQ0FBTyxRQUFXLFdBQUU7QUFDMUIsY0FBUSxVQUFhLGFBQVUsV0FBYSxXQUFFO0FBQ3pDLG1CQUFXLFlBQ25COztBQUNBLGlCQUNGOzs7OztBQVlnQjs7Ozs7Ozs7Ozs7eUNBQVMsVUFBRTtBQUN6QixjQUFZLFVBQU0sS0FBWSxZQUFvQixvQkFBVTtBQUM1RCxjQUFRLE1BQ047QUFBUyxtQkFBVyxXQUFRLFNBQVE7QUFDdEMsaUJBQ0Y7Ozs7O0FBbUJJOzs7Ozs7Ozs7Ozs7Ozs7OzZCQUFLLE1BQVEsUUFBUyxTQUFFO0FBQ2xCLG9CQUFVLFdBQUs7QUFDaEIsbUJBQVUsV0FBUyxRQUFVLFdBQWUsU0FBMUMsR0FBK0MsS0FBUTtBQUNoRSxjQUFVLFlBQVcsTUFBSztBQUNqQixxQkFBUyxRQUFTLFlBQWMsWUFBTyxPQUFTLFFBQVE7QUFDckQsd0JBQVMsUUFBUSxRQUFZO0FBQy9CLHNCQUFTLFFBQVUsYUFBYyxZQUFNLE9BQVMsUUFDeEQ7QUFKMEIsV0FBaEI7QUFLUCxnQkFBUSxTQUFRO0FBQ3JCLGNBQVMsT0FBUyxRQUFNLFFBQU87QUFDM0IsZUFBYyxjQUFNO0FBQ3hCLGlCQUNGOzs7QUFVTTs7Ozs7Ozs7Ozs7K0JBQUssTUFBVyxXQUFZLFlBQUU7QUFDN0IsaUJBQXlCLHNCQUFNLFFBQVE7QUFDNUMsY0FBUSxNQUFNLEtBQ1oscUJBQUssS0FBa0IsbUJBQUUsSUFBYztBQUN6QyxjQUFPLEtBQUssSUFBSSxJQUFNO0FBQ25CLGNBQUMsQ0FBRyxJQUFFO0FBQ0osaUJBQUk7QUFDSixnQkFBSSxJQUFLLE1BQ2Q7O0FBQ0EsY0FBUSxNQUFZLFlBQVk7QUFDN0IsY0FBQyxDQUFHLEdBQUssTUFBRTtBQUNWLGVBQU0sT0FBTSxLQUE4Qiw4QkFDdEMsTUFBVyxXQUFZLFlBQy9CO0FBQ0Y7OztBQVdROzs7Ozs7Ozs7Ozs7aUNBQUssTUFBVyxXQUFZLFlBQUU7QUFDL0IsaUJBQXlCLHNCQUFNLFFBQVE7QUFDNUMsY0FBTyxLQUFNLEtBQWtCLG9CQUFPLEtBQWlCLGlCQUFJLElBQU07QUFDakUsY0FBUSxNQUFZLFlBQVk7QUFDaEMsY0FBWSxVQUFLLE1BQUssR0FBSztBQUN4QixjQUFRLFNBQUU7QUFDUCxpQkFBNkIsNkJBQUssTUFBVyxXQUFVO0FBQ3pELGVBQU0sT0FDVjtBQUNGOzs7QUFnQmtCOzs7Ozs7Ozs7Ozs7Ozs7OzsyQ0FBVSxXQUFNLE1BQUU7QUFDM0Isa0JBQVMsU0FBZSxnQkFBd0Isc0JBQU0sUUFBUSxNQUFlLGNBQVksY0FDbEc7Ozs7QUFXRTs7Ozs7Ozs7Ozs7MkJBQU0sT0FBRTtBQUNSLGlCQUFXLEtBQUssS0FBYyxjQUNoQzs7O0FBUVk7Ozs7Ozs7Ozs7O0FBVU07Ozs7OzRDQUFFO0FBQ2YsY0FBTyxPQUFVLFlBQU8sS0FBVyxZQUFFO0FBQzlCLHFCQUNWO0FBQ0Y7OztBQVV1Qjs7Ozs7Ozs7Ozs7aURBQUU7QUFDdkIsK0NBQTZDLFFBQUksSUFBTyxLQUFuQixDQUN2Qzs7OztBQVV3Qjs7Ozs7Ozs7Ozs7aURBQVMsVUFBRTtBQUNqQywrQ0FBNkMsUUFBSSxJQUFPLEtBQW5CLENBQTRDLHlCQUNuRjs7OztBQVVxQjs7Ozs7Ozs7Ozs7K0NBQUU7QUFDckIsY0FBUyxPQUFNLEtBQXlCO0FBQ3hDLHNCQUFrQixPQUFTLDhCQUFzQixHQUFFO0FBQzFDLG1CQUFFLEVBQVUsYUFBUSxLQUM3QjtBQUNGLFdBSGE7OztBQVlXOzs7Ozs7Ozs7O2tEQUFFO0FBQ3hCLGNBQU8sS0FBTSxLQUF5QjtBQUN0QyxjQUFPLEtBQUk7QUFDUCxlQUFDLElBQUssSUFBRSxHQUFLLEdBQUcsSUFBSSxHQUFJLElBQUssS0FBRTtBQUM5QixnQkFBRSxFQUFVLGFBQVEsS0FBYSxjQUFFO0FBQ2xDLGlCQUFLLEtBQUUsRUFDWDtBQUNGOztBQUNBLGlCQUFTLEdBQUssS0FDaEI7OztBQVNzQjs7Ozs7Ozs7OzsrQ0FBUyxVQUFFO0FBQy9CLGNBQU8sS0FBTSxLQUF5Qix5QkFBVTtBQUNoRCxpQkFBVSxNQUFLLEdBQ2pCOzs7QUFTeUI7Ozs7Ozs7Ozs7a0RBQVMsVUFBRTtBQUNsQyxpQkFBVyxLQUF5Qix5QkFDdEM7OztBQVlvQjs7Ozs7Ozs7Ozs7Ozs2Q0FBTSxPQUFFO0FBQzFCLGNBQVksVUFBTSxLQUFLLEtBQWMsY0FBTyxTQUFVO0FBQ3RELGlCQUFlLHVDQUF1QyxRQUFJLElBQVUsUUFBdEIsQ0FBNkMsd0JBQzdGOzs7QUFpQmtCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7MkNBQU0sT0FBRTtBQUN4QixpQkFBd0MsdUNBQTBCLHFCQUFPLE9BQU8sT0FBUyxVQUFFLEdBQUU7QUFDcEYscUJBQUUsRUFBVSxhQUFRLEtBQzdCO0FBQ0YsYUFIK0M7Ozs7QUFZOUI7Ozs7Ozs7Ozs7MENBQUssTUFBRTtBQUN0QixpQkFBWSxTQUFTLFFBQU8sS0FBUyxTQUFPLFNBQ3BDLEtBQWUsa0JBQVEsS0FDakM7OztBQVFpQjs7Ozs7Ozs7OzBDQUFLLE1BQUU7QUFDdEIsaUJBQVcsS0FBTSxTQUFRLEtBQzNCOzs7QUFHWTs7OztxQ0FBVSxXQUFlLGVBQUUsR0FDdkM7OztBQVFxQjs7Ozs7Ozs7OzhDQUFTLFVBQUU7QUFDOUIsaUJBQXFCLGVBQXNCLHNCQUFLLE1BQ2xEOzs7OztBQTRCUTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2lDQUFRLFNBQVUsVUFBTSxNQUFFO0FBQzVCLGVBQWEsY0FBTSxLQUFhLGVBQUs7QUFDekMsaUJBQVcsS0FBWSxZQUFVLFdBQVMsUUFBVSxVQUFTLFNBQ25ELEtBQVksWUFDbEIsVUFBTyxPQUFJLElBQVMsUUFBTSxNQUFRLFFBQU0sTUFBTyxRQUFTLFFBQU0sTUFDOUQsV0FBVSxTQUFLLEtBQ3JCOzs7QUFRaUI7Ozs7Ozs7OzswQ0FBUSxTQUFFO0FBQ3JCLGVBQWEsY0FBTSxLQUFhLGVBQUs7QUFDekMsY0FBYyxZQUFNLEtBQVksWUFBUztBQUN6QyxpQkFBTyxDQUFFLEVBQVcsYUFBWSxVQUNsQzs7O0FBT2M7Ozs7Ozs7O3VDQUFRLFNBQUU7QUFDbEIsZUFBYSxjQUFNLEtBQWEsZUFBSztBQUN6QyxjQUFjLFlBQU0sS0FBWSxZQUFTO0FBQ3RDLGNBQVUsV0FBRTtBQUNKLHNCQUNYO0FBQ0Y7OztBQU9lOzs7Ozs7Ozt3Q0FBUSxTQUFFO0FBQ25CLGVBQWEsY0FBTSxLQUFhLGVBQUk7QUFDeEMsY0FBYyxZQUFNLEtBQVksWUFBUztBQUN0QyxjQUFVLFdBQUU7QUFDSixzQkFDWDtBQUNGOzs7QUFjSzs7Ozs7Ozs7Ozs7Ozs7OzhCQUFTLFVBQVUsVUFBRTtBQUN4QixpQkFBZ0IsV0FBSSxJQUFTLFFBQU0sTUFBUSxRQUFJLElBQVMsU0FBSyxLQUFNLE9BQVksWUFDM0UsQ0FBUSxRQUFNLE1BQVUsVUFBSSxJQUFTLFNBQUssS0FDaEQ7OztBQVFXOzs7Ozs7Ozs7b0NBQU8sUUFBRTtBQUNYLG1CQUFJLElBQVMsUUFBTSxNQUFVLFVBQU8sT0FBQyxDQUFTLFVBQzFDLFFBQU0sTUFBUSxRQUFPLE9BQ2xDOzs7OztBQVlNOzs7Ozs7Ozs7OzsrQkFBSSxLQUFPLE9BQUU7QUFDakIsY0FBUSxNQUFVLFNBQWMsY0FBSztBQUNsQyxjQUFNLE9BQUU7QUFDTixnQkFBSSxJQUFjLGVBQUU7QUFDbEIsa0JBQWMsY0FDbkI7QUFBRSxtQkFBSztBQUNELG1CQUFDLElBQU0sS0FBUSxPQUFFO0FBQ2hCLG9CQUFJLEtBQU8sTUFDaEI7QUFDRjtBQUNGOztBQUNBLGlCQUNGOzs7QUFtQlU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O21DQUFLLE1BQVEsUUFBUyxTQUFVLFVBQUU7O0FBQzFDLGNBQVcsU0FBUyxTQUFRLE9BQUssS0FBTyxRQUFNO0FBQzlDLGNBQVksVUFBVSxVQUFTLFFBQUssS0FBTyxRQUFNO0FBQ2pELGlCQUFjLFFBQVcsV0FBSyxNQUFRLFFBQVMsU0FDakQ7OztBQVVjOzs7Ozs7Ozs7Ozt1Q0FBUyxVQUFNLE1BQUU7QUFDN0IsaUJBQWMsUUFBSSxJQUFnQixpQkFBeUIsdUJBQU0sUUFBUSxNQUMzRTs7O0FBVWU7Ozs7Ozs7Ozs7O3dDQUFLLE1BQU0sTUFBTSxNQUFFO0FBQzNCLGlCQUF5QixzQkFBTSxRQUFRO0FBQ3pDLGNBQVUsVUFBUSxVQUFJLEdBQUU7QUFDcEIsbUJBQUUsQ0FBSyxLQUFhLGFBQzNCOztBQUNHLGNBQUssTUFBRTtBQUNKLGlCQUFhLGFBQUssTUFDeEI7QUFBRSxpQkFBSztBQUNELGlCQUFnQixnQkFDdEI7QUFDRjs7O0FBV1c7Ozs7Ozs7Ozs7O29DQUFLLE1BQU0sTUFBTSxNQUFFO0FBQ3ZCLGlCQUF5QixzQkFBTSxRQUFRO0FBQ3pDLGNBQVUsVUFBUSxVQUFJLEdBQUU7QUFDcEIsbUJBQUUsQ0FBSyxLQUFVLFVBQVMsU0FDakM7O0FBQ0csY0FBSyxNQUFFO0FBQ0osaUJBQVUsVUFBSSxJQUNwQjtBQUFFLGlCQUFLO0FBQ0QsaUJBQVUsVUFBTyxPQUN2QjtBQUNGOzs7QUFTUzs7Ozs7Ozs7OztrQ0FBYyxlQUFNLE1BQUU7QUFDeEIsaUJBQXlCLHNCQUFNLFFBQVE7QUFDeEMsZUFBTSxNQUFpQixrQkFBZTtBQUN0QyxlQUFNLE1BQVcsWUFDdkI7OztBQVlXOzs7Ozs7Ozs7Ozs7O29DQUFFLEdBQUcsR0FBRyxHQUFNLE1BQUU7QUFDcEIsaUJBQXlCLHNCQUFNLFFBQVE7QUFDeEMsZUFBVSxVQUFnQixpQkFBSSxJQUFNLE1BQUksSUFBTSxNQUFJLElBQUssS0FDN0Q7OztBQWlCVzs7Ozs7Ozs7Ozs7Ozs7Ozs7O29DQUFZLGFBQU0sTUFBRTtBQUM3QixjQUFTO0FBQ04sY0FBTSxNQUFRLFFBQWEsY0FBRTtBQUN4QixvQkFBYSxZQUFRLFFBQU07QUFDOUIsZ0JBQU8sU0FBSSxHQUFFO0FBQ2QscUJBQWtCLFlBQU8sT0FBTSxPQUNqQztBQUNGO0FBQUUsaUJBQUs7QUFDTCxnQkFBUSxNQUFTLFFBQUssS0FBSSxJQUFLLE1BQWM7QUFDdkMsb0JBQUssSUFBUSxRQUFNO0FBQ3RCLGdCQUFPLFNBQUksR0FBRTtBQUNkLHFCQUFXLEtBQU8sT0FBWSxhQUFPLE9BQ3ZDO0FBQ0Y7O0FBQ0EsaUJBQ0Y7Ozs7O0FBVU87Ozs7Ozs7OztnQ0FBTSxPQUFNO0FBQUU7OztBQUVoQixjQUFNLE1BQVEsUUFBTyxTQUFPLEtBQVEsV0FBSyxHQUFFO0FBQ3ZDLG1CQUFNLEtBQ2I7O0FBQ00sa0JBQVE7QUFDWixpQkFBVTtBQUNWLGlCQUFXO0FBQ1gsaUJBQVk7QUFDSCxtQ0FBUSwwQ0FFckI7Ozs7QUFPSzs7Ozs7Ozs7O0FBQVM7QUFBRjs7O0FBQ04sZUFBUSxRQUFNLE9BQ3BCOzs7QUFPTTs7Ozs7Ozs7O0FBQVM7QUFBRjs7O0FBQ1AsZUFBUSxRQUFPLFFBQ3JCOzs7QUFPTzs7Ozs7Ozs7O0FBQVM7QUFBRjs7O0FBQ1IsZUFBUSxRQUFRLFNBQ3RCOzs7QUFVSzs7Ozs7Ozs7Ozs7OEJBQWE7QUFBUztBQUFGOzs7QUFDaEIsa0JBQVcsWUFBTSxLQUFHLElBQWMsbUJBQzNDO0FBRUY7Ozs0QkF4ZWdCO0FBQ1osY0FBUyxPQUFNLEtBQWM7QUFDN0IsaUJBQWEsZ0JBQTZCLGdCQUFuQyw0QkFBcUUsSUFBTixDQUFZLE9BQ3BGOzs7OztNQWhZNEM7O0FBdTJCakMsa0JBQVUsVUFBSSxLQUFJOztBQUUvQixXQUVGO0FBRUYsR0F6NEJzQztBQXk0QmxDLEs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNwNkJKLENBQVUsWUFBRTs7QUFFRTs7Ozs7O0FBS1osTUFBZSxXQUFTLFFBQVM7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUIxQixVQUF1QixnQ0FBdUIsY0FBWTs7QUFPL0Q7Ozs7O0FBUGtFLFFBT3RDOzs7Ozs7Ozs7OztnREFFRSxNQUFXLFdBQVMsU0FBRTtBQUM3QyxjQUFDLENBQVMsU0FBWSxZQUFLLE1BQVcsV0FBVSxVQUFFO0FBQ3RCLGtLQUFLLE1BQVcsV0FDL0M7QUFDRjtBQUU0Qjs7O3FEQUFLLE1BQVcsV0FBUyxTQUFFO0FBQ2xELGNBQUMsQ0FBUyxTQUFlLGVBQUssTUFBVyxXQUFVLFVBQUU7QUFDcEIsdUtBQUssTUFBVyxXQUNwRDtBQUNGO0FBRUY7Ozs7TUFaeUI7O0FBY3pCLFdBRUY7QUFFRixHQTNCeUM7QUEyQnJDLEs7Ozs7Ozs7Ozs7O0FDdERKLENBQVUsWUFBRTs7QUFFRTs7QUFFWixXQUFrQixVQUFNLE9BQVMsU0FBWSxZQUFFO0FBQzdDO0FBQ08sYUFBTztBQUNMLGVBQVM7QUFDTixrQkFFZDtBQUxTOzs7QUFPVCxNQUFpQixhQUFHO0FBQ3BCLE1BQWtCLGNBQUc7QUFDckIsTUFBZSxXQUFHO0FBQ2xCLE1BQWtCLGNBQUc7Ozs7Ozs7Ozs7Ozs7QUFhckIsV0FBMEIsa0JBQVEsU0FBYyxjQUFZLFlBQzdCLEtBQVUsVUFBUSxRQUFFOztBQUVqRCxRQUFhLFdBQVMsU0FBVyxXQUFHO0FBQ3BDLFFBQWdCLGNBQWEsYUFBZSxlQUFHO0FBQy9DLFFBQWMsWUFBRSxJQUFTLE1BQVU7OztBQUcvQixTQUFDLElBQU0sSUFBRyxHQUFJLElBQVUsVUFBSyxLQUFFO0FBQ3hCLGdCQUFJLEtBQUUsSUFBUyxNQUFhO0FBQzVCLGdCQUFHLEdBQUksS0FDbEI7Ozs7QUFHSSxTQUFDLElBQU0sSUFBRyxHQUFJLElBQWEsYUFBSztBQUN6QixnQkFBRyxHQUFJLEtBQUc7S0FFakIsS0FBQyxJQUFNLEtBQUcsR0FBSSxLQUFVLFVBQUssTUFBRTtBQUM3QixXQUFDLElBQU0sS0FBRyxHQUFJLEtBQWEsYUFBSyxNQUFFO0FBQ2pDLFlBQU8sT0FBUSxRQUFjLGVBQUksS0FBSSxJQUFLLElBQVUsV0FBSSxLQUFLLEtBQ3JELFVBQUcsSUFBSSxNQUFXLFVBQUcsS0FBSSxHQUFHLEtBQ3ZDLFFBQUs7QUFDSCxjQUFVLFFBQVcsVUFBRyxLQUFJLEdBQUksTUFBRztBQUNuQyxjQUFTLE9BQVcsVUFBRyxJQUFHLEtBQUssS0FBRztBQUN6QixvQkFBRyxJQUFJLE1BQVEsUUFBTyxPQUFRLFFBQ3pDO0FBQ0Y7QUFDRjs7O0FBRUEsV0FDRjs7Ozs7O0FBS0EsV0FBMEMsa0NBQVUsV0FBRTtBQUNwRCxRQUFNLElBQVcsVUFBUSxTQUFHO0FBQzVCLFFBQU0sSUFBVyxVQUFHLEdBQVEsU0FBRztBQUMvQixRQUFZLFVBQVcsVUFBRyxHQUFHO0FBQzdCLFFBQVUsUUFBSTtBQUNSLFdBQUcsSUFBSSxLQUFLLElBQUcsR0FBRTtBQUNsQixVQUFHLEtBQUksR0FBRTtBQUNMLGNBQUssS0FBVTtBQUNqQjtBQUVMOztBQUNHLFVBQUcsS0FBSSxHQUFFO0FBQ0wsY0FBSyxLQUFhO0FBQ3BCO0FBRUw7O0FBQ0EsVUFBYyxZQUFXLFVBQUcsSUFBSSxHQUFHLElBQUk7QUFDdkMsVUFBUyxPQUFXLFVBQUcsSUFBSSxHQUFHO0FBQzlCLFVBQVUsUUFBVyxVQUFHLEdBQUcsSUFBSTs7QUFFL0IsVUFBTztBQUNKLFVBQU0sT0FBTyxPQUNWLE1BQU8sT0FBWSxZQUFPLE9BQ2hDLGVBQ00sTUFBUSxRQUFZLFlBQVEsUUFBVzs7QUFFMUMsVUFBSyxPQUFZLFdBQUU7QUFDakIsWUFBVyxhQUFVLFNBQUU7QUFDbkIsZ0JBQUssS0FDWjtBQUFFLGVBQUs7QUFDQSxnQkFBSyxLQUFhO0FBQ2Ysb0JBQ1Y7O0FBQ0c7QUFFTDtBQUFFLGlCQUFhLE9BQU8sTUFBRTtBQUNqQixjQUFLLEtBQWE7QUFDcEI7QUFDSyxrQkFDVjtBQUFFLE9BSlEsTUFJSDtBQUNBLGNBQUssS0FBVTtBQUNqQjtBQUNLLGtCQUNWO0FBQ0Y7OztBQUVLLFVBQVU7QUFDZixXQUNGOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTJDQSxXQUFvQixZQUFRLFNBQWMsY0FBWSxZQUM3QixLQUFVLFVBQVEsUUFBRTtBQUMzQyxRQUFnQixjQUFHO0FBQ25CLFFBQWdCLGNBQUc7QUFDbkIsUUFBVTs7QUFFVixRQUFjLFlBQU0sS0FBSSxJQUFZLGFBQWMsY0FBUyxTQUFXO0FBQ25FLFFBQWMsZ0JBQUssS0FBWSxZQUFJLEdBQ3hCLGNBQWMsYUFBUSxTQUFLLEtBQVk7O0FBRWxELFFBQVksY0FBVSxRQUFRLFVBQVUsVUFBTSxJQUFPLFFBQzFDLGNBQWMsYUFBUSxTQUFLLEtBQVksWUFBYzs7QUFFdEQsb0JBQWM7QUFDbEIsZ0JBQWM7QUFDWixrQkFBYztBQUNsQixjQUFjOztBQUVsQixRQUFZLGFBQWUsZ0JBQUssS0FBVSxTQUFXLFlBQUksR0FDMUQsT0FBUzs7QUFFUixRQUFjLGdCQUFhLFlBQUU7QUFDdkIsZUFBVyxVQUFhLGNBQUksSUFBSTtBQUNqQyxhQUFVLFdBQVE7QUFDaEIsZUFBUSxRQUFLLEtBQUksSUFBYTtPQUV0QyxPQUFPLENBQ1Q7QUFBRSxXQUFRLElBQVUsWUFBUyxRQUMzQixPQUFPLENBQVcsVUFBYSxjQUFJLElBQWEsYUFBaUI7O0FBRW5FLFFBQVEsTUFBbUMsa0NBQ3RCLGtCQUFRLFNBQWMsY0FBWSxZQUN6QixLQUFVLFVBQVU7O0FBRTNDLGFBQVc7QUFDbEIsUUFBWSxVQUFJO0FBQ2hCLFFBQVUsUUFBYztBQUN4QixRQUFhLFdBQVU7QUFDbkIsU0FBQyxJQUFNLElBQUcsR0FBSSxJQUFLLElBQU8sUUFBSyxLQUFFO0FBQzdCLGNBQUksSUFBSztBQUNiLGFBQWU7QUFDVixjQUFPLFFBQUU7QUFDSCxvQkFBSyxLQUFRO0FBQ2IscUJBQ1Q7OztBQUVPO0FBQ0c7QUFDTDtBQUNQLGFBQWdCO0FBQ1gsY0FBQyxDQUFPLFFBQ0YsU0FBVyxVQUFNLE9BQUksSUFBSTs7QUFFNUIsaUJBQWE7QUFDWjs7QUFFRCxpQkFBUSxRQUFLLEtBQUksSUFBVztBQUN4QjtBQUNMO0FBQ1AsYUFBYTtBQUNSLGNBQUMsQ0FBTyxRQUNGLFNBQVcsVUFBTSxPQUFJLElBQUk7O0FBRTVCLGlCQUFhO0FBQ1o7QUFDRjtBQUNQLGFBQWdCO0FBQ1gsY0FBQyxDQUFPLFFBQ0YsU0FBVyxVQUFNLE9BQUksSUFBSTs7QUFFNUIsaUJBQVEsUUFBSyxLQUFJLElBQVc7QUFDeEI7QUFHaEI7Ozs7QUFFRyxRQUFPLFFBQUU7QUFDSCxjQUFLLEtBQ2Q7O0FBQ0EsV0FDRjs7O0FBRUEsV0FBcUIsYUFBUSxTQUFLLEtBQWMsY0FBRTtBQUM1QyxTQUFDLElBQU0sSUFBRyxHQUFJLElBQWMsY0FBSztBQUNoQyxVQUFDLENBQU8sT0FBUSxRQUFHLElBQUssSUFBSSxLQUM3QixPQUFRO0tBQ1osT0FDRjs7O0FBRUEsV0FBcUIsYUFBUSxTQUFLLEtBQWMsY0FBRTtBQUNoRCxRQUFXLFNBQVMsUUFBTztBQUMzQixRQUFXLFNBQUssSUFBTztBQUN2QixRQUFVLFFBQUc7QUFDUCxXQUFPLFFBQWUsZ0JBQVMsT0FBUSxRQUFDLEVBQVMsU0FBSyxJQUFDLEVBQVU7QUFDOUQ7S0FFVCxPQUNGOzs7QUFFQSxXQUF5QixpQkFBUSxTQUFVLFVBQUU7QUFDM0MsV0FBa0IsWUFBUSxTQUFHLEdBQVMsUUFBTyxRQUFVLFVBQUcsR0FDMUIsU0FDbEM7OztBQUVBLFdBQWUsT0FBYSxjQUFlLGVBQUU7QUFDM0MsV0FBb0IsaUJBQ3RCOzs7Ozs7OztBQU9PLFVBQWE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBbUN0QjtBQW5Dd0I7QUFtQ3BCLEs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDMVJLLFFBQXVCO0FBQ2xCOzs7O0FBSVE7QUFDVixZQUFRO0FBQ0osZ0JBQ1Q7QUFIaUI7Ozs7OztBQVNFO0FBQ2QsWUFBUztBQUNSLGFBRVI7QUFKdUI7QUFiWjs7QUFtQkg7QUFDNEIseUNBQ3BDO0FBRlU7O0FBSUosV0FBVyxtQkFBRTs7O0FBR2QsU0FBdUIsd0JBQUk7QUFDM0IsU0FBb0IscUJBQU0sS0FBYSxhQUFLLEtBQ2xEO0FBQUM7O0FBRU8sWUFBVyxvQkFBRTtBQUNmLFNBQ047QUFBQzs7QUFFTyxZQUFXLG9CQUFFO0FBQ2hCLFFBQUssS0FBaUIsa0JBQUU7QUFDckIsV0FBaUIsaUJBQTJCLDJCQUNsRDtBQUFFLFdBQUs7QUFDQyxhQUFvQixvQkFBUyxVQUFNLEtBQzNDOzs7QUFFSSxTQUFrQixtQkFDeEI7QUFBQzs7Ozs7O0FBTVcsZ0JBQVcsd0JBQUU7QUFDcEIsUUFBQyxDQUFLLEtBQVcsWUFBRTtBQUV0Qjs7O0FBRUksU0FBc0Isc0JBQVEsUUFBUyxVQUFVLFdBQUU7QUFDbEQsVUFBSyxLQUFvQixvQkFBVyxZQUFFO0FBQ25DLGFBQWtCLGtCQUN4QjtBQUNGO0FBQUMsT0FBTzs7QUFFSixTQUNOO0FBQUM7Ozs7OztBQU1vQix5QkFBVSwrQkFBZ0IsaUJBQUU7QUFDM0MsU0FBa0IsbUJBQ3hCO0FBQUM7Ozs7OztBQU15Qiw4QkFBVSxvQ0FBTyxRQUFFO0FBQzNDLFFBQVUsUUFBTSxLQUFzQixzQkFBUSxRQUFROztBQUVuRCxRQUFPLFFBQUUsQ0FBRSxHQUFFO0FBQ1YsV0FBc0Isc0JBQU8sT0FBTSxPQUFJO0FBQ3ZDLFdBQVMsU0FBTyxRQUFlLGVBQ3JDO0FBQ0Y7QUFBQzs7Ozs7Ozs7Ozs7QUFXa0IsdUJBQVUsNkJBQVEsU0FBRTtBQUFFLFdBQWE7QUFBQzs7QUFFaEMsMkJBQVUsaUNBQU0sT0FBRTtBQUNwQyxRQUFLLEtBQXFCLHNCQUFFO0FBQ3hCLFlBQWtCO0FBRXpCOzs7Ozs7QUFLRyxRQUFDLENBQVEsUUFBUyxTQUFVLFdBQUU7QUFDM0IsV0FDTjtBQUNGO0FBQUM7O0FBRVUsZUFBVyx1QkFBRTtBQUNsQixTQUFLLEtBQWMsZUFBTTtBQUN2QixZQUFNO0FBQ0gsZUFFWDtBQUppQztBQUloQzs7QUFFZ0MscUNBQVUsMkNBQU0sT0FBRTtBQUNqRCxRQUFXLFNBQThCLDJCQUFRLFFBQUksSUFBTyxPQUFZO0FBQ3JFLFFBQVEsV0FBUSxNQUFFO0FBRXJCOzs7QUFFRyxRQUFLLEtBQXNCLHNCQUFRLFFBQVMsWUFBSSxDQUFFLEdBQUU7QUFDakQsV0FBc0Isc0JBQUssS0FBUTtBQUNuQyxXQUFPLE9BQU8sUUFBZSxlQUNuQzs7O0FBRU0sV0FBc0Isc0JBQU07QUFDOUIsU0FBa0Isa0JBQVE7O0FBRXpCLFVBQ1A7QUFBQzs7QUFFc0IsMkJBQVUsaUNBQWdCLGlCQUFFO0FBQzlDLFFBQWdCLGlCQUFFO0FBQ2IsYUFBb0Isb0JBQVMsVUFBTSxLQUMzQztBQUNGO0FBQUM7O0FBRWdCLHFCQUFVLDJCQUFXLFlBQUU7Ozs7QUFJbkMsUUFBQyxDQUFLLEtBQVcsWUFBRTtBQUV0Qjs7O0FBRUksU0FBc0IsdUJBQU07QUFDdEIsZUFBZTtBQUNyQixTQUFzQix1QkFDNUI7QUFBQzs7QUFFMEIsK0JBQVcsdUNBQUU7QUFDbkMsUUFBQyxDQUFLLEtBQVcsWUFDWjs7Ozs7Ozs7QUFRTCxRQUFTLFNBQVksZUFBYSxXQUFFO0FBQ3JDLFVBQWdDLDhCQUFNLEtBQTRCLDRCQUFLLEtBQU07QUFDckUsZUFBaUIsaUJBQW1CLG9CQUFFLFNBQTJCLG9CQUFFO0FBQ2pFLGlCQUFvQixvQkFBbUIsb0JBQW9CO0FBRXJFO0FBQ0Y7QUFBRSxXQUFLO0FBQ0QsV0FBSyxLQUFvQyxxQ0FBTTtBQUM3QyxjQUFNO0FBQ0gsaUJBQU07QUFDSCxvQkFDVjtBQUptRDs7QUFNbEQsVUFBQyxDQUFLLEtBQWlCLGtCQUFFO0FBQ3BCLGVBQWlCLGlCQUFTLFVBQU0sS0FBb0I7QUFDdEQsYUFDTjtBQUNGO0FBQ0Y7QUFDRDtBQXJMK0IsRTs7Ozs7Ozs7Ozs7Ozs7O0FDZHpCLFFBQVUsVUFBZSxlQUFtQjs7QUFFNUMsU0FBRSxTQUFlLFFBQUU7QUFDdEIsUUFBTyxLQUFJO0FBQ1QsT0FBc0IsdUJBQU0sS0FBVyxXQUF3QjtBQUMvRCxPQUFxQixzQkFBTSxLQUFXLFdBQXVCO0FBQzdELE9BQXFCLHFCQUFNLE1BQVksYUFBVztBQUNsRCxPQUFxQixxQkFBTSxNQUFXLFlBQWlCO0FBQ3ZELE9BQW9CLG9CQUFNLE1BQVksYUFBVztBQUNqRCxPQUFvQixvQkFBTSxNQUFXLFlBQWlCO0FBQ3RELE9BQW9CLG9CQUFNLE1BQVMsVUFBRztBQUNwQyxTQUFvQixxQkFDMUI7QUFBQzs7QUFFRSxPQUFFLFNBQVksSUFBRSxHQUFHLEdBQUU7QUFDdEIsUUFBTyxLQUFNLEtBQW1CO0FBQzlCLE9BQXFCLHFCQUFNLE1BQVMsVUFBSSxJQUFHO0FBQzNDLE9BQW9CLG9CQUFNLE1BQVMsVUFDdkM7QUFBQzs7QUFFTyxZQUFFLFNBQWtCLFdBQUU7QUFDNUIsV0FBVyxLQUNiO0FBQ0E7QUF2Qm1ELEc7Ozs7Ozs7Ozs7Ozs7OztBQ0E5QyxRQUFVLFVBQWUsZUFBWTs7OztBQUl2QyxPQUFFLFNBQWEsTUFBRTtBQUNkLFNBQVEsU0FBTSxLQUFjLGdCQUFPLEtBQ3pDO0FBQ0E7QUFQNEMsRzs7Ozs7Ozs7Ozs7QUNKOUMsQ0FBVSxZQUFFO0FBQ1YsV0FBb0IsWUFBUyxVQUFRLFFBQUksSUFBSyxLQUFFO0FBQzVDLE9BQU0sTUFBSSxZQUFZLElBQVMsVUFBTSxPQUFFO0FBQ3ZDLGFBQVksTUFBSSxLQUFFLENBQU0sTUFBSSxLQUFPLE1BQUssTUFDMUM7QUFDRixLQUhzQjs7Ozs7OztBQVNmLFVBQVUsVUFBZSxlQUFlOztBQUV4QyxXQUFFLFNBQWUsUUFBRTtBQUN0QixVQUFVLFFBQU0sS0FBVyxXQUFhO0FBQ3hDLFVBQW1CLGlCQUFNLEtBQVcsV0FBa0I7O0FBRW5ELFVBQUMsQ0FBZSxnQkFBRTtBQUNaLGdCQUFLLEtBQTZEO0FBQ3pFLGVBQ0Y7O0FBQ0csVUFBQyxDQUFNLE9BQUU7QUFDSCxnQkFBSyxLQUF3RDtBQUNwRSxlQUNGOzs7QUFFYyxxQkFBTSxNQUFZLGFBQVc7QUFDN0IscUJBQU0sTUFBaUIsa0JBQWlCO0FBQ3hDLHFCQUFNLE1BQVcsWUFBaUI7QUFDbEMscUJBQU0sTUFBdUIsd0JBQVk7QUFDekMscUJBQU0sTUFBaUIsa0JBQVk7O0FBRTVDLFlBQU0sTUFBWSxhQUFXO0FBQzdCLFlBQU0sTUFBdUIsd0JBQVk7QUFDekMsWUFBTSxNQUFpQixrQkFBWTtBQUNuQyxZQUFNLE1BQWlCLGtCQUFpQjtBQUN4QyxZQUFNLE1BQVcsWUFBaUI7O0FBRXZDLFVBQW9CLGtCQUFPLE1BQXdCO0FBQ25ELFVBQTZCLDJCQUFnQixlQUF3QjtBQUNyRSxVQUFPLEtBQUk7O0FBRVQsU0FBTyxRQUFVLFNBQU8sT0FBaUIsaUJBQWdCLGdCQUFhLGNBQU0sTUFDbEUsU0FBTyxPQUFpQixpQkFBTyxPQUFhLGNBQUs7QUFDM0QsU0FBUyxVQUFpQixnQkFBTSxPQUEwQix5QkFBSztBQUMvRCxTQUFTLFVBQWlCLGdCQUFLLE1BQTBCLHlCQUFJO0FBQzdELFNBQWdCLGlCQUFnQjtBQUNoQyxTQUFPLFFBQU87O0FBRVosV0FBZ0IsaUJBQ3RCO0FBQUM7O0FBRUUsU0FBRSxTQUFZLElBQUUsR0FBRyxHQUFFO0FBQ3RCLFVBQU8sS0FBTSxLQUFlO0FBQ3pCLFVBQUMsQ0FBSyxLQUFVLFdBQUU7QUFDakIsWUFDSjs7QUFDRyxVQUFHLEtBQUksR0FBRTtBQUNSLFdBQU0sTUFBTSxNQUFTLFVBQUc7QUFDeEIsV0FBZSxlQUFNLE1BQVMsVUFDbEM7QUFBRSxhQUFLO0FBQ0gsV0FBTSxNQUFNLE1BQVMsVUFBRztBQUN4QixXQUFlLGVBQU0sTUFBUyxVQUNsQzs7QUFDVyxrQkFBSyxLQUFJLElBQUUsR0FBSSxJQUFFLENBQUUsQ0FBRSxHQUFJLEdBQU8sUUFBRSxDQUFFLEdBQUUsQ0FBRyxHQUFTLFVBQUUsQ0FBRSxHQUFHLElBQUcsR0FBVyxXQUN4RSxVQUFNLE9BQVksWUFBWSxZQUFFO0FBQ2xDLGFBQVUsVUFBYyxlQUFhLGFBQVMsU0FBYSxhQUFTLFNBQ3pELGFBQVEsUUFBTyxPQUFRLFFBQVEsUUFBSSxHQUNwRDtBQUFDLFNBQ0w7QUFBQzs7QUFFTyxjQUFFLFNBQWtCLFdBQUU7QUFDNUIsYUFBVyxLQUNiO0FBRUo7QUFoRW1EO0FBZ0UvQyxLOzs7Ozs7Ozs7Ozs7OztBQ3hFRyxRQUFVLFVBQWUsZUFBc0I7Ozs7O0FBSy9DLFNBQUUsU0FBYyxNQUFPLFFBQUU7QUFDNUIsUUFBTyxLQUFJO0FBQ1gsUUFBVyxTQUFZLFdBQU8sT0FBUTtBQUNwQyxPQUFZLGFBQU0sS0FBVyxXQUFjO0FBQzNDLE9BQXNCLHVCQUFNLEtBQVcsV0FBd0I7QUFDL0QsT0FBcUIsc0JBQU0sS0FBVyxXQUF1QjtBQUM3RCxPQUFTLFVBQUksR0FBcUIscUJBQWMsZUFBSSxHQUFXLFdBQWE7QUFDM0UsUUFBRyxHQUFTLFlBQUssR0FBRTtBQUNqQixVQUFNLE1BQVEsU0FBRTtBQUNWLGlCQUNUOztBQUNFLFNBQVMsVUFBTSxLQUFVLFdBQzdCO0FBQUUsV0FBSztBQUNGLFVBQU0sTUFBUSxTQUFFO0FBQ1YsaUJBQ1Q7O0FBQ0UsU0FBUyxVQUFJLEdBQVMsVUFDMUI7O0FBQ0ksU0FBdUIsd0JBQzdCO0FBQUM7O0FBRUUsT0FBRSxTQUFZLElBQUUsR0FBRyxHQUFFO0FBQ3RCLFFBQU8sS0FBTSxLQUFzQjtBQUMvQixTQUFVLFVBQXVCLHNCQUFHLEdBQVMsVUFBTSxLQUFJLElBQUUsR0FBTSxLQUFZLFlBQUksR0FBc0I7QUFDdEcsUUFBRyxHQUFvQixxQkFBRTtBQUN0QixXQUFVLFVBQXVCLHNCQUFHLEdBQVMsVUFBTSxLQUFJLElBQUUsR0FBTSxLQUFZLFlBQUksR0FDckY7QUFDRjtBQUFDOztBQUVPLFlBQUUsU0FBa0IsV0FBRTtBQUM1QixXQUFXLEtBQ2I7QUFDQTtBQXJDc0QsRzs7Ozs7Ozs7Ozs7Ozs7OztBQ0NqRCxRQUF3Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBOEJuQjs7Ozs7Ozs7Ozs7O0FBWU87QUFDVCxZQUFRO0FBQ1AsYUFDTjtBQUhnQjs7Ozs7O0FBU1Q7QUFDRixZQUFRO0FBQ04sY0FDUDtBQUhTOzs7Ozs7O0FBVUU7QUFDTixZQUFRO0FBQ0osZ0JBQU07QUFDUixjQUNQO0FBSmE7Ozs7Ozs7QUFXRDtBQUNQLFlBQVE7QUFDUCxhQUFPO0FBQ0osZ0JBQ1Q7QUFKYzs7Ozs7O0FBVUwsZ0JBQVE7Ozs7O0FBS0w7QUFDUCxZQUFRO0FBQ1AsYUFDTjtBQUhjOzs7OztBQVFFO0FBQ1gsWUFBUTtBQUNQLGFBQ047QUFIa0I7Ozs7OztBQVNGO0FBQ1gsWUFBUTtBQUNQLGFBQ047QUFIa0I7Ozs7O0FBUWQ7QUFDQyxZQUFPO0FBQ0gsZ0JBQU07QUFDUixjQUFNO0FBQ1AsYUFBVyxpQkFBRTtBQUNoQixlQUNGO0FBQ0Q7QUFQTTs7Ozs7Ozs7QUFlWTtBQUNiLFlBQVE7QUFDUCxhQUFXLGlCQUFFO0FBQ2hCO0FBQ1ksc0JBQUc7QUFDSCxzQkFBRztBQUNMLG9CQUFHO0FBQ0Msd0JBRWhCO0FBTlM7QUFRWjtBQVhzQjtBQWpHWDs7QUE4R0gsYUFBRSxDQUNnQywyQ0FDZCw2QkFFNUI7O0FBRU0sV0FBVyxtQkFBRTtBQUNkLFNBQWlCLGtCQUFNLEtBQVksWUFBSyxLQUFNO0FBQzlDLFNBQVksYUFBRSxJQUFXLFFBQWMsY0FBSyxLQUFnQixnQkFBSyxLQUN2RTtBQUFDOztBQUVPLFlBQVcsb0JBQUU7QUFDZixTQUFXLFlBQU0sS0FBYyxjQUFNO0FBQ3JDLFNBQWEsYUFBSyxLQUN4QjtBQUFDOztBQUVPLFlBQVcsb0JBQUU7QUFDaEIsUUFBSyxLQUFVLFdBQUU7QUFDWCxjQUFJLElBQU0sTUFBZSxlQUFLLEtBQ3ZDOztBQUNJLFNBQWdCLGdCQUFLLEtBQzNCO0FBQUM7Ozs7Ozs7OztBQVNNLFdBQVUsaUJBQUssTUFBRTtBQUN0QixXQUFXLEtBQU0sTUFBUSxRQUMzQjtBQUFDOzs7Ozs7OztBQVFLLFVBQVUsZ0JBQU0sT0FBRTtBQUNsQixTQUFVLFdBQ2hCO0FBQUM7Ozs7Ozs7QUFPYSxrQkFBVywwQkFBRTtBQUN6QixRQUFXLFNBQU0sS0FBTSxNQUFPO0FBQzlCLFFBQVUsUUFBRSxDQUFPLE9BQUssS0FBYyxjQUFLLEtBQVksYUFBSSxJQUFVLFVBQVE7QUFDekUsU0FBVSxXQUFNLEtBQWMsY0FDcEM7QUFBQzs7Ozs7OztBQU9TLGNBQVcsc0JBQUU7QUFDckIsUUFBVSxRQUFFLENBQU8sT0FBSyxLQUFjLGNBQUssS0FBWSxhQUFLLEtBQU0sS0FBTSxNQUFPO0FBQzNFLFNBQVUsV0FBTSxLQUFjLGNBQ3BDO0FBQUM7Ozs7Ozs7QUFPVSxlQUFVLHFCQUFNLE9BQUU7QUFDdkIsU0FBTyxPQUFLLEtBQWMsY0FDaEM7QUFBQzs7Ozs7Ozs7Ozs7Ozs7QUFjeUIsOEJBQVcsc0NBQUU7QUFDbEMsUUFBSyxLQUFXLGFBQUcsT0FBVyxLQUFVLFVBQU8sVUFBYyxZQUFFOzs7Ozs7O0FBTzVELFdBQVUsVUFDaEI7QUFBRSxXQUFLO0FBQ0QsV0FDTjtBQUNGO0FBQUM7OztBQUdELE1BQTJCLHlCQUFFO0FBQzNCLFdBQVcsS0FBVSxZQUN2QjtBQUFDOztBQUVhLGtCQUFXLDBCQUFFO0FBQ3JCLFNBQ047QUFBQzs7QUFFVyxnQkFBVSxzQkFBVSxXQUFFO0FBQzVCLFNBQU8sT0FBSyxNQUFXLFdBQzdCO0FBQUM7O0FBRWMsbUJBQVUseUJBQVUsV0FBRTtBQUMvQixTQUFTLFNBQUssTUFBVyxXQUMvQjtBQUFDOztBQUVvQix5QkFBVSwrQkFBVSxXQUFLLEtBQUU7QUFDMUMsU0FBZ0IsZ0JBQUs7QUFDckIsU0FBYSxhQUNuQjtBQUFDOztBQUVXLGdCQUFXLHdCQUFFO0FBQ3ZCLFFBQVUsUUFBUyxRQUFJLElBQU0sTUFBeUIseUJBQUssS0FBWSxjQUFPO0FBQ3hFLFlBQU8sTUFBVSxVQUFPLE9BQUssS0FBTSxPQUFNLEtBQWlCO0FBQzVELFNBQVUsVUFDaEI7QUFBQzs7QUFFcUIsMEJBQVcsa0NBQUU7QUFDOUIsUUFBSyxLQUFhLGNBQUU7QUFDakIsV0FBVSxXQUFNLEtBQWMsY0FBSyxLQUN6QztBQUNGO0FBQUM7O0FBRWMsbUJBQVcsMkJBQUU7QUFDdEIsU0FBZ0IsZ0JBQUssS0FDM0I7QUFBQzs7QUFFYyxtQkFBVSx5QkFBUyxVQUFFO0FBQy9CLFFBQUMsQ0FBSyxLQUFNLE9BQUU7QUFFakI7OztBQUVBLFFBQVMsT0FBTSxLQUFhLGFBQUssS0FBVTtBQUN4QyxRQUFLLE1BQUU7QUFDSixXQUFXLFdBQU8sT0FDeEI7QUFBRSxXQUFLO0FBQ0QsV0FBVyxXQUNqQjs7OztBQUdHLFFBQUssS0FBbUIscUJBQU8sS0FBTSxNQUFXLFVBQUssS0FBVyxXQUFPLFVBQWMsV0FBRTtBQUNwRixXQUFVLFdBQU0sS0FDdEI7QUFDRjtBQUFDOztBQUVVLGVBQVUscUJBQUssTUFBRTtBQUMxQixXQUFPLENBQUssS0FBb0Isb0JBQUssS0FDdkM7QUFBQzs7QUFFVyxnQkFBVSxzQkFBTSxPQUFFO0FBQzVCLFdBQWMsU0FBUyxJQUFoQixHQUF1QixPQUFNLEtBQU0sTUFBSyxLQUFjLGNBQy9EO0FBQUM7O0FBRVksaUJBQVUsdUJBQU0sT0FBRTtBQUMxQixRQUFLLEtBQWdCLGlCQUFFO0FBQ3BCLFdBQUMsSUFBTSxJQUFHLEdBQU0sTUFBTyxPQUFNLEtBQU0sTUFBRyxJQUFLLEtBQUU7QUFDNUMsWUFBSyxLQUFjLGNBQU8sU0FBUSxPQUFFO0FBQ3JDLGlCQUNGO0FBQ0Y7QUFDRjtBQUFFLFdBQUs7QUFDTCxhQUFhLE9BQ2Y7QUFDRjtBQUFDOztBQUVZLGlCQUFVLHVCQUFNLE9BQUU7QUFDMUIsUUFBSyxLQUFnQixpQkFBRTtBQUN4QixVQUFTLE9BQU0sS0FBTSxNQUFPO0FBQ3pCLFVBQUssTUFBRTtBQUNSLGVBQVcsS0FBYyxjQUMzQjtBQUNGO0FBQUUsV0FBSztBQUNMLGFBQ0Y7QUFDRjtBQUFDOztBQUVZLGlCQUFVLHVCQUFLLE1BQUU7QUFDekIsUUFBQyxDQUFLLE1BQUU7QUFDVCxhQUNGOzs7QUFFQSxRQUFjLFlBQU0sS0FBUSxRQUFRLFFBQWdCLGdCQUFLLEtBQWtCO0FBQzNFLFdBQWlCLGFBQWEsWUFBWSxZQUFNLEtBQWEsYUFBSyxLQUNwRTtBQUFDOztBQUVjLG1CQUFVLHlCQUFLLE1BQVksWUFBRTtBQUN2QyxRQUFLLEtBQWMsZUFBRTtBQUNsQixXQUFZLFlBQUssS0FBYyxlQUFZLFlBQ2pEOztBQUNHLFFBQUssS0FBa0IsbUJBQUU7QUFDdEIsV0FBZ0IsZ0JBQUssS0FBa0IsbUJBQVksWUFDekQ7O0FBQ0ksU0FBbUI7QUFDbkIsU0FBSyxLQUFXLFdBQVksYUFBVyxXQUFhLGFBQUUsRUFBSyxNQUNqRTtBQUFDOztBQUVlLG9CQUFXLDRCQUFFO0FBQ3ZCLFNBQWlCLGlCQUFLLEtBQVcsV0FDdkM7QUFBQzs7O0FBR1ksaUJBQVUsdUJBQUssTUFBRTtBQUM1QixtQkFBa0IsSUFBTSxNQUFhLGFBQVMsVUFBUyxVQUFFO0FBQ25ELFdBQWU7QUFDZixXQUFrQjs7OztBQUlsQixXQUFLLEtBQXFCLHNCQUFVO0FBQy9CLGlCQUFPO0FBQ0osb0JBRWQ7QUFKNEM7QUFLOUMsS0FYZ0I7QUFXZjs7QUFFZSxvQkFBVSwwQkFBRSxHQUFFO0FBQzVCLFFBQU0sSUFBRyxFQUFPO0FBQ2hCLFFBQVUsUUFBTSxLQUFNO0FBQ2hCLFdBQUcsS0FBSyxLQUFPLE1BQUU7QUFDckIsVUFBTSxJQUFPLE1BQVEsUUFBRztBQUNyQixVQUFHLEtBQUksR0FBRTtBQUNWLFlBQVUsUUFBTSxLQUFjLGNBQUc7QUFDN0IsYUFBYyxjQUFNLE9BQUk7QUFFOUI7O0FBQ0UsVUFBRyxFQUNQO0FBQ0Y7QUFBQzs7QUFFWSxpQkFBVSx1QkFBTSxPQUFNLE1BQUU7QUFDaEMsUUFBQyxDQUFLLEtBQUssS0FBZ0IsaUJBQzFCLEVBQVMsVUFBTyxPQUFNLE1BQU8sUUFBRSxFQUFXLFlBQVEsUUFBaUIsa0JBQUU7QUFDbkUsV0FBTyxPQUNiO0FBQ0Y7QUFFRDs7QUFuWWdDLEU7Ozs7Ozs7Ozs7O0FDc0NqQyxDQUFVLFlBQUU7Ozs7OztBQU1WLFdBQWlCLFNBQVEsU0FBRTtBQUNyQixTQUFNLE9BQVcsV0FBVSxRQUFPLElBQTFCLElBQXNDO0FBQzlDLFNBQUssTUFBVSxXQUFVLFFBQUk7QUFDOUIsUUFBUyxXQUFVLFNBQUU7QUFDbEIsV0FBTyxRQUFTLFFBQ3RCO0FBQ0Y7OztBQUVRLFdBQU8sUUFBSTs7QUFFWCxXQUFXO0FBQ2pCLFFBQVUsUUFBRTtBQUNWLFVBQVMsT0FBTSxLQUFLO0FBQ3BCLFVBQVEsTUFBTSxLQUFJOztBQUVmLFVBQU0sUUFBTSxLQUFFO0FBQ2YsZUFBZSxTQUFNLE1BQU8sU0FBVyxTQUFNLE1BQU0sTUFDckQ7QUFDRjtBQUFDOztBQUVELFFBQVMsTUFBTSxPQUFFO0FBQ2YsVUFBUyxPQUFNLEtBQUs7QUFDcEIsVUFBUSxNQUFNLEtBQUk7O0FBRWYsVUFBTSxRQUFNLEtBQUU7QUFDVixlQUFVLFNBQU0sTUFBTyxRQUFVLFNBQU0sTUFBTyxTQUFLO0FBQ3JELFlBQU8sU0FBTyxNQUFFO0FBQ2pCLGlCQUFXLEtBQ2I7QUFBRSxlQUFLO0FBQ0QsZUFBTSxPQUNaO0FBQ0Y7QUFDRjtBQUFDOztBQUVELFFBQVMsT0FBRTtBQUNULFVBQVMsT0FBTSxLQUFLOztBQUVqQixVQUFLLE1BQUU7QUFDUixzQkFBa0IsS0FBUyxTQUFNLE1BQUssS0FBTyxPQUFJLElBQVMsVUFBSSxLQUFFO0FBQzlELGlCQUFnQixVQUFLLEtBQU0sTUFDN0I7QUFBQyxTQUZZLEVBR2Y7QUFDRjtBQUFDOztBQUVJLFdBQVUsZUFBSSxLQUFFO0FBQ2YsV0FBSyxNQUFLO0FBQ2QsYUFBVyxLQUNiO0FBQ0Q7QUF0Q29COztBQXdDZCxVQUFVLFdBQVU7O0FBRTNCLE1BQWMsWUFBUyxRQUFTLFNBQU07O0FBRS9COztBQUVILFFBQWE7O0FBRUw7Ozs7Ozs7QUFPSjtBQUNFLGNBQVE7QUFDUCxlQUNOO0FBSEs7Ozs7OztBQVNIO0FBQ0csY0FDTDtBQUZJOzs7Ozs7QUFRQTtBQUNDLGNBQVE7QUFDTixnQkFDUDtBQUhNOzs7OztBQVFGO0FBQ0MsY0FBUztBQUNMLGtCQUNUO0FBSE07O0FBS0Q7QUFDQSxjQUFTO0FBQ0wsa0JBRVg7QUFKUztBQXJDRTs7QUEyQ0U7QUFDTixjQUNQO0FBRmU7O0FBSUgsbUJBQVUsdUJBQUssTUFBSyxLQUFPLE9BQUU7QUFDeEMsVUFBUyxXQUFhLFFBQVM7QUFDekIsY0FBTTtBQUNQLGFBQ0g7QUFIOEIsT0FBckI7O0FBS1IsVUFBTyxVQUFjLGFBQVMsVUFBUSxLQUFNLE9BQUU7QUFDM0MsYUFBTyxRQUNiO0FBQUUsYUFBUSxJQUFLLEtBQU8sVUFBUSxLQUFNLE9BQUU7QUFDaEMsYUFBTyxRQUFNLEtBQ25COzs7QUFFQSxhQUNGO0FBQUM7O0FBRUQsUUFBUyxPQUFFO0FBQ1QsYUFBVyxLQUFRLFVBQU8sS0FBTyxPQUNuQztBQUFDOztBQUVXLGtCQUFVLHNCQUFLLE1BQUU7QUFDeEIsVUFBSyxNQUFFO0FBQ0osYUFBTyxRQUNiO0FBQ0Y7QUFBQzs7Ozs7Ozs7O0FBU0ksV0FBVSxlQUFJLEtBQUU7QUFDbkIsaUJBQWtCLFFBQVM7QUFDckIsY0FBTSxLQUFLO0FBQ1osYUFDSDtBQUgwQixPQUFyQixFQUlUO0FBRUo7QUExRlU7QUEwRk4sSzs7Ozs7Ozs7Ozs7QUNoTUosQ0FBVSxZQUFFO0FBQ0U7Ozs7Ozs7OztBQVFaLE1BQW1CO0FBQ1QsY0FBYTtBQUNiLGNBQU87QUFDUCxjQUFPO0FBQ1AsY0FBUztBQUNULGNBQ1Q7QUFOb0I7Ozs7Ozs7OztBQWVyQixNQUFhO0FBQ1YsT0FBYTtBQUNiLE9BQU87QUFDTixRQUFTO0FBQ1QsUUFBTztBQUNQLFFBQVU7QUFDVixRQUFZO0FBQ1osUUFBTztBQUNQLFFBQVE7QUFDUixRQUFTO0FBQ1QsUUFBUTtBQUNSLFFBQU07QUFDTixRQUFTO0FBQ1QsUUFBUTtBQUNSLFFBQU87QUFDTixTQUNKO0FBaEJjOzs7Ozs7O0FBdUJmLE1BQWtCO0FBQ1QsYUFBWTtBQUNiLFlBQVc7QUFDWixXQUFVO0FBQ1QsWUFDUDtBQUxtQjs7Ozs7Ozs7O0FBY3BCLE1BQWEsV0FBYTs7Ozs7QUFLMUIsTUFBZSxhQUFPOzs7OztBQUt0QixNQUFjLFlBQVU7Ozs7OztBQU14QixNQUFjLFlBQWdCOzs7Ozs7O0FBTzlCLE1BQVksVUFBWTs7Ozs7Ozs7QUFReEIsV0FBcUIsYUFBSSxLQUFnQixnQkFBRTtBQUN6QyxRQUFhLFdBQUk7QUFDZCxRQUFJLEtBQUU7QUFDUCxVQUFTLE9BQUssSUFBYztBQUN6QixVQUFNLFNBQVEsT0FBWSxVQUFLLEtBQU0sT0FBRTtBQUMvQixtQkFDWDtBQUFFLGlCQUFnQixRQUFLLEtBQU0sT0FBRTtBQUNwQixtQkFDWDtBQUFFLE9BRlEsVUFFSyxLQUFRLFVBQUksR0FBRTtBQUN4QixZQUFDLENBQWdCLGtCQUFXLFNBQUssS0FBTSxPQUFFO0FBQ2pDLHFCQUNYO0FBQ0Y7QUFBRSxPQUpRLFVBSVUsVUFBSyxLQUFNLE9BQUU7QUFDdEIsbUJBQU0sS0FBUSxRQUFRLFNBQ2pDO0FBQUUsT0FGUSxVQUVNLFFBQWEsWUFBRTs7QUFFcEIsbUJBQ1g7QUFBRSxPQUhRLE1BR0g7QUFDSSxtQkFDWDtBQUNGOztBQUNBLFdBQ0Y7OztBQUVBLFdBQStCLHVCQUFTLFVBQUU7QUFDeEMsUUFBYSxXQUFJO0FBQ2QsUUFBUyxVQUFFO0FBQ1QsVUFBVSxZQUFpQixnQkFBRTtBQUNyQixtQkFBZ0IsZUFDM0I7QUFBRSxpQkFBbUIsV0FBSyxLQUFVLFdBQUU7QUFDM0IsbUJBQVUsU0FBUyxTQUFRLFFBQUssTUFBTyxPQUFLO0FBQzVDLG1CQUFRLE9BQWEsYUFBVSxVQUMxQztBQUFFLE9BSFEsTUFHSDtBQUNJLG1CQUFVLFNBQ3JCO0FBQ0Y7O0FBQ0EsV0FDRjs7O0FBRUEsV0FBeUIsaUJBQVEsU0FBRTtBQUNqQyxRQUFhLFdBQUk7QUFDZCxRQUFPLE9BQVMsVUFBRTtBQUNoQixVQUFTLFdBQU0sTUFBVyxXQUFLLElBQUU7OztBQUd6QixtQkFBUSxPQUFhLGFBQUksS0FDcEM7QUFBRSxpQkFBaUIsV0FBTyxPQUFXLFdBQU0sS0FBRTs7QUFFbEMsbUJBQVEsT0FBUyxVQUFNLE1BQ2xDO0FBQUUsT0FIUSxVQUdTLFdBQU0sTUFBVyxXQUFLLElBQUU7O0FBRWhDLG1CQUFRLE9BQVMsVUFDNUI7QUFBRSxPQUhRLFVBR1MsV0FBTSxNQUFXLFdBQU0sS0FBRTs7QUFFakMsbUJBQVEsT0FBUyxVQUM1QjtBQUFFLE9BSFEsTUFHSDtBQUNJLG1CQUFVLFNBQ3JCO0FBQ0Y7O0FBQ0EsV0FDRjs7Ozs7Ozs7Ozs7OztBQVlBLFdBQThCLHNCQUFTLFVBQWdCLGdCQUFFOzs7QUFHcEQsUUFBUyxTQUFJLEtBQUU7QUFDaEIsYUFBbUIsYUFBUyxTQUFJLEtBQ2xDOztBQUNHLFFBQVMsU0FBUSxVQUFXLFNBQU8sT0FBSSxLQUFFO0FBQzFDLGFBQW1CLGFBQVMsU0FBTyxPQUFJLEtBQ3pDOztBQUNBLFdBQTZCLHVCQUFTLFNBQWdCLGtCQUNwQyxpQkFBUyxTQUFVLFlBQ3ZDOzs7QUFFQSxXQUE2QixxQkFBUyxVQUFPLE9BQUU7O0FBRTdDLFFBQWEsV0FBdUIsc0JBQU0sT0FBVSxTQUFjO0FBQ2xFLFdBQWdCLGFBQVksU0FDMUIsUUFBQyxDQUFTLFNBQWlCLGdCQUN6QixDQUFDLENBQU0sTUFBVSxhQUFJLENBQUMsQ0FBUyxTQUFVLFlBQ3pDLENBQUMsQ0FBTSxNQUFTLFlBQUksQ0FBQyxDQUFTLFNBQVMsV0FDdkMsQ0FBQyxDQUFNLE1BQVEsV0FBSSxDQUFDLENBQVMsU0FBUSxVQUNyQyxDQUFDLENBQU0sTUFBUyxZQUFJLENBQUMsQ0FBUyxTQUVwQzs7O0FBRUEsV0FBNEIsb0JBQWUsZ0JBQUU7QUFDeEMsUUFBZSxlQUFRLFdBQUssR0FBRTtBQUMvQjtBQUNPLGVBQWdCO0FBQ2xCLGFBQWdCO0FBQ2QsZUFFVDtBQUxTOztBQU1ULDBCQUEyQixNQUFLLEtBQU8sT0FBUyxVQUFlLGdCQUFjLGNBQUU7QUFDN0UsVUFBZSxhQUFjLGFBQU0sTUFBSztBQUN4QyxVQUFZLFVBQVksV0FBRztBQUMzQixVQUFVLFFBQVksV0FBRzs7QUFFdEIsVUFBUyxXQUFnQixlQUFFO0FBQ2QsdUJBQWMsY0FBVyxZQUFNO0FBQy9CLHVCQUFjLGVBQzlCO0FBQUUsYUFBSztBQUNTLHVCQUFLLE1BQVM7QUFDZCx1QkFBTyxRQUFRLFNBQy9COzs7QUFFQSxhQUNGO0FBQUMsS0Fkb0I7QUFlZCxhQUFnQixlQUFNLE1BQUssS0FFcEM7QUFISzs7O0FBS0wsV0FBeUIsaUJBQVksYUFBRTtBQUNyQyx1QkFBeUIsT0FBTSxNQUFLLEtBQUksSUFBUyxVQUFlLGdCQUFFO0FBQ2hFLGFBQTBCLG9CQUM1QjtBQUNGLEtBSG9COzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF5Q2IsVUFBc0I7QUFDakI7Ozs7OztBQU1NO0FBQ1IsY0FBUTtBQUNQLGVBQVcsaUJBQUU7QUFDaEIsaUJBQ0Y7QUFDRDtBQUxlOzs7Ozs7QUFXWTtBQUN0QixjQUFTO0FBQ1IsZUFDTjtBQUg2Qjs7QUFLYjtBQUNYLGNBQU87QUFDTixlQUFXLGlCQUFFO0FBQ2hCLGlCQUNGO0FBQ0Q7QUFMa0I7Ozs7QUFTRztBQUNoQixjQUFRO0FBQ1AsZUFBVyxpQkFBRTtBQUNoQixpQkFDRjtBQUVIO0FBTnlCO0FBL0JkOztBQXVDSCxlQUFFLENBRVY7Ozs7Ozs7QUFRVSxpQkFBSTs7QUFFTCxnQkFBVyxzQkFBRTtBQUNqQixXQUNOO0FBQUM7O0FBRU8sY0FBVyxvQkFBRTtBQUNmLFdBQ047QUFBQzs7QUFFTyxjQUFXLG9CQUFFO0FBQ2YsV0FDTjtBQUFDOzs7Ozs7Ozs7O0FBVWUsc0JBQVUsMEJBQVksYUFBYSxhQUFFO0FBQy9DLFdBQXVCLHVCQUFjLGVBQWE7QUFDbEQsV0FBbUI7QUFDbkIsV0FDTjtBQUFDOzs7OztBQUttQiwwQkFBVyxnQ0FBRTtBQUMzQixXQUF3Qix5QkFBSTtBQUM1QixXQUFtQjtBQUNuQixXQUNOO0FBQUM7Ozs7Ozs7OztBQVN1Qiw4QkFBVSxrQ0FBTSxPQUFhLGFBQUU7QUFDckQsVUFBYyxZQUFrQixpQkFBYTtBQUN6QyxXQUFDLElBQU0sSUFBRyxHQUFJLElBQVcsVUFBTyxRQUFFLEVBQUcsR0FBRTtBQUN0QyxZQUFxQixxQkFBVSxVQUFHLElBQVEsUUFBRTtBQUM3QyxpQkFDRjtBQUNGOztBQUNBLGFBQ0Y7QUFBQzs7QUFFa0IseUJBQVcsK0JBQUU7QUFDOUIsVUFBZ0IsbUJBQWdCLFVBQUksSUFBUyxVQUFTLFVBQUU7QUFDdEQsZUFBZSxTQUNqQjtBQUFFLE9BRm9COztBQUluQixVQUFZLFlBQVEsUUFBSyxLQUFjLGlCQUFJLENBQUUsR0FBRTtBQUNyQyxvQkFBSyxLQUFLLEtBQ3ZCOzs7QUFFQSxhQUNGO0FBQUM7O0FBRWUsc0JBQVcsNEJBQUU7QUFDdkIsV0FBYyxlQUFJOztBQUVsQixXQUFzQixzQkFBUSxRQUFTLFVBQVksYUFBRTtBQUNuRCxhQUFDLElBQWdCLGVBQWMsYUFBRTtBQUMvQixlQUFlLGVBQVksYUFBYSxZQUM5QztBQUNGO0FBQUMsU0FBTzs7QUFFSixXQUFDLElBQWdCLGVBQU8sS0FBdUIsd0JBQUU7QUFDL0MsYUFBZSxlQUFZLGFBQU0sS0FBdUIsdUJBQzlEOzs7O0FBR0ksV0FBQyxJQUFjLGFBQU8sS0FBYSxjQUFFO0FBQ25DLGFBQWEsYUFBVyxXQUFLLEtBQVUsVUFBSSxLQUFLLEtBQUU7QUFDcEQsY0FBTyxLQUFLLElBQUcsR0FBYTtBQUM1QixjQUFPLEtBQUssSUFBRyxHQUFhO0FBQzVCLGlCQUFXLE9BQVEsRUFBWixHQUFnQixJQUFLLEtBQUUsQ0FBRyxJQUNuQztBQUNGO0FBQ0Y7QUFBQzs7QUFFYSxvQkFBVSx3QkFBWSxhQUFhLGFBQUU7QUFDakMsdUJBQWEsYUFBUSxRQUFTLFVBQVMsVUFBRTtBQUNuRCxhQUFhLGFBQVMsU0FBUSxTQUM1QixLQUFhLGFBQVMsU0FBUSxVQUFLOztBQUVyQyxhQUFhLGFBQVMsU0FBTyxPQUFLLEtBQUMsQ0FDN0IsVUFHWjtBQUFDLFNBQ0g7QUFBQzs7QUFFc0IsNkJBQVcsbUNBQUU7QUFDOUIsV0FBNkI7O0FBRTlCLFVBQUssS0FBVyxZQUFFO0FBQ2YsYUFDTjtBQUNGO0FBQUM7O0FBRXVCLDhCQUFXLG9DQUFFO0FBQ2hDLFVBQUMsQ0FBSyxLQUFlLGdCQUFFO0FBRTFCOztBQUNNLGFBQUssS0FBSyxLQUFjLGNBQVEsUUFBUyxVQUFVLFdBQUU7QUFDekQsWUFBZ0IsY0FBTSxLQUFhLGFBQVc7QUFDOUMsWUFBb0Isa0JBQU0sS0FBbUIsbUJBQUssS0FBSyxNQUFjOztBQUVqRSxhQUFrQixrQkFBSyxLQUFDLENBQUssS0FBZSxnQkFBVyxXQUFtQjs7QUFFMUUsYUFBZSxlQUFpQixpQkFBVSxXQUNoRDtBQUFDLFNBQ0g7QUFBQzs7QUFFeUIsZ0NBQVcsc0NBQUU7QUFDckMsVUFBbUI7QUFDbkIsVUFBa0I7QUFDbEIsVUFBYTtBQUNiLFVBQW1COztBQUViLGFBQUssS0FBa0Isa0JBQU8sUUFBRTs7QUFFcEIsMEJBQU0sS0FBa0Isa0JBQU07QUFDL0IseUJBQWlCLGdCQUFHO0FBQ3pCLG9CQUFpQixnQkFBRztBQUNkLDBCQUFpQixnQkFBRzs7QUFFdEIsdUJBQW9CLG9CQUFVLFdBQzlDO0FBQ0Y7QUFBQzs7QUFFaUIsd0JBQVUsNEJBQVksYUFBTyxPQUFFO0FBQzVDLFVBQUssS0FBNkIsOEJBQUU7QUFDaEMsY0FDUDs7OztBQUdHLFVBQU0sTUFBaUIsa0JBQUU7QUFFNUI7OztBQUVJLFdBQUMsSUFBTSxJQUFHLEdBQUksSUFBYSxZQUFPLFFBQUssS0FBRTtBQUMzQyxZQUFhLFdBQWEsWUFBRyxHQUFHO0FBQ2hDLFlBQWdCLGNBQWEsWUFBRyxHQUFHO0FBQ2hDLFlBQXFCLHFCQUFTLFVBQVEsUUFBRTtBQUNyQyxlQUFtQixtQkFBUyxVQUFhLGFBQVE7O0FBRWxELGNBQU0sTUFBaUIsa0JBQUU7QUFFNUI7QUFDRjtBQUNGO0FBQ0Y7QUFBQzs7QUFFaUIsd0JBQVUsNEJBQVMsVUFBYSxhQUFlLGVBQUU7QUFDakUsVUFBVyxTQUFRLE9BQU8sT0FBVTtBQUM5QixhQUFlLGdCQUFlO0FBQ3BDLFVBQVUsWUFBaUIsWUFBUyxTQUFNO0FBQ2xDLGdCQUFRO0FBQ0osb0JBQ1Y7QUFIMEMsT0FBaEM7QUFJUixXQUFhLGFBQUssS0FBSyxNQUFRO0FBQ2hDLFVBQU0sTUFBaUIsa0JBQUU7QUFDYixzQkFDZjtBQUNGO0FBRUo7QUFsT2lDO0FBa083QixLOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OEJDcFlGOztJQUFZOzs7Ozt3QkFFTTtBQUFFLGFBQWlCO0FBRWI7Ozt3QkFBRTtBQUN0QjtBQUNNO0FBQ0UsZ0JBQVE7QUFDTSw4QkFBTTtBQUNoQixvQkFDVDtBQUpLO0FBS0csbUJBQVE7QUFDVCxrQkFBUTtBQUNSO0FBQ0YsZ0JBQVE7QUFDUCxpQkFDTjtBQUhTO0FBSUQ7QUFDSCxnQkFBUTtBQUNQO0FBQ0UsbUJBQVcsaUJBQUU7QUFDViw2RkFDUjtBQUFDO0FBQ0ksbUJBQVcsaUJBQUU7QUFDViw2RkFDUjtBQUFDO0FBQ0ksbUJBQVcsaUJBQUU7QUFDViw2RkFDUjtBQUFDO0FBQ00scUJBQVcsbUJBQUU7QUFDWiw2RkFDUjtBQUlSO0FBaEJhO0FBRkU7QUFaTjtBQWdDWTs7O3dCQUFFO0FBQ3JCLGFBQU8sQ0FHVDs7OztBQUVZO0FBRVo7OztBQUVpQjs7OztzQ0FBSyxNQUFFOzs7QUFHbkIsVUFBTSxTQUFhLFdBQUU7QUFFeEI7Ozs7O0FBSUksV0FBTSxPQUFPLFFBQVU7OztBQUd4QixVQUFDLENBQUssS0FBRSxFQUFPLE9BQVcsWUFBRTtBQUN6QixhQUFFLEVBQU8sT0FDZjtBQUNGO0FBRVk7OztpQ0FBSyxNQUFFO0FBQ2YsVUFBSyxLQUFVLFVBQU0sT0FBQztBQUNsQixhQUFVLFVBQ2hCO0FBQUUsYUFBSztBQUNELGFBQ047QUFDRjtBQUVhOzs7bUNBQUU7QUFDVCxXQUFNLE9BQ1o7QUFDRjs7OztFQTNFMkIsUUFFWDs7QUEyRVYsT0FBZSxlQUFPLE9BQU0sTUFBRyxJQUFRLE87Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzlLakQsQ0FBVTtBQUNJOztBQUVaLE1BQVksVUFBSTtBQUNoQixNQUFjLFlBQUk7QUFDbEIsV0FBbUIsV0FBRyxJQUFFO0FBQ3RCLFdBQWMsUUFBSyxPQUFZLFVBQUcsR0FDcEM7OztBQUVBLFdBQWtDLDBCQUFLLE1BQUU7QUFDcEMsUUFBSyxLQUFjLGNBQVMsVUFBRTtBQUN4QixjQUFLLEtBQTJDLDRDQUFNLEtBQy9EO0FBQ0Y7OztBQTRCQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBekNVLE1BeUNNOzs7Ozs7Ozs7OzsrQ0F1QmUsTUFBSyxLQUFPLE9BQUU7QUFDdEMsWUFBSyxRQUFTLE9BQUU7QUFDYixlQUNOO0FBQ0Y7OztBQWFjOzs7Ozs7Ozs7Ozs7Ozs7O0FBb0JOOzs7Ozs7K0JBQUcsSUFBRTtBQUNSLGFBQUssTUFBTyxLQUFHO0FBQ2YsWUFBRyxJQUFFO0FBQ0YsZUFBSSxLQUFJOzs7O0FBSUwsa0JBQUssTUFBTTtBQUNULG9CQUFHLEdBQWdCLGlCQUFNO0FBQ1Qsb0NBQzNCO0FBQ0Y7QUFDRjs7OzBCQWhDa0I7O0FBRVgsWUFBQyxDQUFLLEtBQVksYUFBRTs7O0FBR3JCLGNBQVksUUFBUSxPQUFhLGVBQWMsWUFBa0IsbUJBQ3BELFlBQWlCLGlCQUFPLFNBQVksV0FBTSxLQUFjO0FBQ3JFLGNBQVUsTUFBUyxRQUFXLFdBQVcsV0FDbkMsS0FBYSxhQUFjLGdCQUFLLElBQU8sTUFBUztBQUNsRCxlQUFhLGNBQVMsUUFBVyxXQUFZLFlBQ25EOztBQUNBLGVBQVcsS0FDYjs7Ozs7O0FBeENhOzs7Ozs7Ozs4QkFBRyxJQUFVLFVBQUU7QUFDdkIsWUFBRyxJQUFFO0FBQ04sY0FBTSxJQUFZLFdBQUk7QUFDbkIsY0FBRyxLQUFXLFVBQUU7QUFDakIsbUJBQVEsRUFBYyxjQUN4Qjs7QUFDQSxpQkFDRjs7QUFDQSxlQUNGO0FBRXdCOzs7MEJBckJRO0FBQUUsZUFBTyxDQUFPOzs7OztJQUFsQjs7QUF3RXZCLFlBQVUsVUFBWSxhQUFTOztBQUUxQixpQkFBTyxPQUFhLGNBQVk7OztBQUd2QyxVQUFXLFlBRXBCO0FBQUksSzs7Ozs7Ozs7Ozs7QUN6SEosQ0FBVSxZQUFFO0FBQ0U7Ozs7Ozs7Ozs7QUFTWixNQUFXOzs7Ozs7Ozs7Ozs7Ozs7O0FBZ0JILFlBQVUsZ0JBQUssTUFBRTtBQUNyQixhQUFXLEtBQVEsUUFBTSxRQUMzQjtBQUFDOzs7Ozs7Ozs7Ozs7Ozs7O0FBZ0JHLFVBQVUsY0FBSyxNQUFFO0FBQ25CLFVBQWEsV0FBTSxLQUFRLFFBQUs7QUFDN0IsVUFBVSxhQUFJLENBQUUsR0FBRTtBQUNuQixlQUNGOztBQUNBLGFBQVcsS0FBTSxNQUFFLEdBQ3JCO0FBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFtQlMsZ0JBQVUsb0JBQUssTUFBTSxNQUFFOztBQUUvQixhQUFXLEtBQVEsUUFBTSxPQUFPLFNBQ2xDO0FBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWtCVyxrQkFBVSxzQkFBSyxNQUFNLE1BQUU7O0FBRWpDLGFBQVcsS0FBUSxRQUFNLE9BQU8sU0FDbEM7QUFBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFvQlEsZUFBVSxtQkFBSyxNQUFTLFNBQU0sTUFBRTtBQUN2QyxhQUFlLFVBQU0sS0FBTSxNQUFLLEtBQ2xDO0FBQUM7Ozs7Ozs7O0FBUU0sYUFBVSxpQkFBSyxNQUFNLE1BQUU7QUFDNUIsYUFBYSxTQUFVLElBQWhCLElBQ0ksS0FBVyxXQUFLLE1BQVEsU0FDeEIsS0FBYSxhQUFLLE1BQy9CO0FBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJRLGVBQVUsbUJBQUssTUFBRTtBQUNyQixVQUFNLE1BQVEsUUFBTSxPQUFFO0FBQ3ZCLFlBQVUsUUFBSTtBQUNWLGFBQUMsSUFBSyxJQUFFLEdBQUcsSUFBSyxLQUFPLFFBQUssS0FBRTtBQUNoQyxjQUFTLE9BQU0sS0FBRyxHQUFXLFdBQU0sTUFBSztBQUNwQyxlQUFDLElBQUssSUFBRSxHQUFHLElBQUssS0FBTyxRQUFLLEtBQUU7QUFDM0Isa0JBQUssS0FBSyxLQUNqQjtBQUNGOztBQUNBLGVBQVksTUFBSyxLQUNuQjtBQUFFLGFBQUs7QUFDTCxlQUNGO0FBQ0Y7QUFBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW1CSSxXQUFVLGVBQUssTUFBRTtBQUNqQixVQUFNLE1BQVEsUUFBTSxPQUFFO0FBQ3ZCLGVBQVcsS0FBVSxVQUFNLE1BQU0sTUFDbkM7O0FBQ0EsYUFBVyxLQUFXLFdBQU0sTUFDOUI7QUFBQzs7Ozs7Ozs7Ozs7Ozs7O0FBZUUsU0FBVSxhQUFLLE1BQU0sTUFBTSxNQUFFO0FBQzlCLFVBQVMsT0FBTTtBQUNmLFVBQVUsUUFBTSxLQUFNLE1BQU07O0FBRXhCLFdBQUMsSUFBSyxJQUFFLEdBQUcsSUFBTSxNQUFPLFFBQUssS0FBRTtBQUM5QixZQUFDLENBQUssTUFBRTtBQUVYOztBQUNBLFlBQVMsT0FBTyxNQUFHO0FBQ2QsZUFBTSxLQUNiOztBQUNHLFVBQUssTUFBRTtBQUNKLGFBQU0sT0FBTyxNQUFLLEtBQ3hCOztBQUNBLGFBQ0Y7QUFBQzs7Ozs7Ozs7Ozs7OztBQWFFLFNBQVUsYUFBSyxNQUFNLE1BQU8sT0FBRTtBQUMvQixVQUFTLE9BQU07QUFDZixVQUFVLFFBQU0sS0FBTSxNQUFNO0FBQzVCLFVBQVMsT0FBTyxNQUFNLE1BQU8sU0FBRztBQUM3QixVQUFNLE1BQVEsU0FBRyxHQUFFOztBQUVoQixhQUFDLElBQUssSUFBRSxHQUFHLElBQU0sTUFBTyxTQUFFLEdBQUssS0FBRTtBQUNuQyxjQUFTLE9BQU8sTUFBRztBQUNkLGlCQUFNLEtBQU07QUFDZCxjQUFDLENBQUssTUFBRTtBQUVYO0FBQ0Y7OztBQUVJLGFBQU8sUUFDYjtBQUFFLGFBQUs7O0FBRUQsYUFBTyxRQUNiOztBQUNBLGFBQVksTUFBSyxLQUNuQjtBQUVEOztBQTVPWTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQStQVCxPQUFRLFNBQU0sS0FBTzs7QUFFbEIsVUFBTSxPQUVmO0FBQUksSzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDMVFKLENBQVUsWUFBRTs7QUFFRTs7QUFFWixNQUFZLFVBQVMsUUFBUTs7QUFFN0IsTUFBYyxZQUFTLFFBQU0sTUFBVTs7Ozs7QUFLdkMsTUFBdUIsbUJBQUk7QUFDM0IsTUFBVSxRQUFhLFlBQVU7QUFDM0IsU0FBTSxPQUFFO0FBQ1osUUFBVSxRQUFRLE9BQW9CLG9CQUFPO0FBQ3pDLFNBQUMsSUFBSyxJQUFFLEdBQUcsSUFBTSxNQUFPLFFBQUssS0FBRTtBQUNqQix1QkFBTSxNQUFLLE1BQzdCOztBQUNNLFlBQVEsT0FBZSxlQUMvQjs7Ozs7Ozs7Ozs7Ozs7OztBQWVBLFdBQTBCLGtCQUFNLE9BQVUsVUFBRTs7QUFFdkMsUUFBQyxDQUFpQixpQkFBVSxXQUFFO0FBQy9CLFVBQVUsUUFBTyxNQUFVO0FBQ3hCLFVBQU8sVUFBYSxXQUFFO0FBQ3BCLFlBQU0sTUFBTyxRQUFFOzs7QUFHWCxnQkFBb0Isb0JBQVMsVUFDcEM7QUFBRSxlQUFLOztBQUVGLGNBQUMsQ0FBTSxNQUFZLGFBQUU7QUFDakIsa0JBQWEsY0FDcEI7QUFBRSxpQkFBUSxJQUFDLENBQU0sTUFBZSxlQUEwQiwwQkFBYyxlQUFTLFNBQUU7QUFDNUUsa0JBQWEsY0FBUSxPQUFPLE9BQU0sTUFDekM7O0FBQ0ssZ0JBQVksWUFBVyxZQUM5QjtBQUNGO0FBQ0Y7QUFDRjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXdCTyxVQUFtQiw0QkFBdUIsY0FBWTs7QUFTM0Q7Ozs7Ozs7QUFUOEQsUUFTdEM7Ozs7Ozs7QUFVZTs7Ozs7Ozs7d0RBQUU7QUFDckMsY0FBTyxLQUFNLEtBQW1CO0FBQzVCLGVBQUMsSUFBSyxLQUFFLEdBQUksS0FBSSxHQUFPLFFBQUssTUFBRTtBQUM1QixpQkFBVSxVQUF3Qix3QkFBUSxRQUFnQixnQkFBRyxHQUNuRTtBQUNGOzs7O0FBRVk7QUFDSDs7Ozs7QUFFSCxjQUFjOztBQUVkLGNBQWM7O0FBRWQsY0FBYzs7QUFFZCxjQUFZOztBQUVaLGNBQWM7O0FBRWQsY0FBTzs7QUFFUCxjQUFjOztBQUVkLGNBQVU7O0FBRVYsY0FBWTs7QUFFWixjQUFrQjs7QUFFbEIsY0FBb0I7QUFDcEIsY0FDTjs7OztBQVV3Qjs7Ozs7Ozs7Ozs7O2lEQUFLLE1BQUssS0FBTyxPQUFFO0FBQ3RDLGNBQUssUUFBUyxPQUFFO0FBQ2IsaUJBQXFCLHFCQUFLLE1BQ2hDO0FBQ0Y7OztBQVVzQjs7Ozs7Ozs7Ozs7Z0RBQUU7QUFDbEIsZUFBZSxnQkFBTztBQUN0QixlQUFlLGdCQUFHO0FBQ2xCLGVBQWUsZ0JBQU87QUFDdEIsZUFBYSxjQUFPO0FBQ3BCLGVBQWUsZ0JBQU87QUFDdEIsZUFBUSxTQUFJO0FBQ1osZUFBZSxnQkFBTTtBQUNyQixlQUFXLFlBQU07QUFDbEIsY0FBSyxLQUFZLGFBQUU7QUFDaEIsaUJBQTJCLDJCQUFLLEtBQWE7QUFDN0MsaUJBQWEsY0FDbkI7Ozs7O0FBSUksZUFBQyxJQUFNLEtBQU8sS0FBa0IsbUJBQUU7QUFDakMsZ0JBQUssS0FBZSxlQUFHLElBQUU7QUFDdEIsbUJBQXFCLHNCQUFNLEtBQXFCLHVCQUFLO0FBQ3JELG1CQUFvQixvQkFBSSxLQUFNLEtBQUc7QUFDckMscUJBQVcsS0FDYjtBQUNGO0FBQ0Y7OztBQWMwQjs7Ozs7Ozs7Ozs7Ozs7O21EQUFNLE9BQUU7QUFDNUIsZUFBQyxJQUFNLEtBQVEsT0FBRTtBQUNmLGlCQUFhLGFBQUUsR0FBTyxNQUM1QjtBQUNGOzs7QUFjNkI7Ozs7Ozs7Ozs7Ozs7OztzREFBTSxPQUFFO0FBQzdCLGlCQUFPLE9BQUssTUFDcEI7OztBQVVnQjs7Ozs7Ozs7Ozs7eUNBQVUsV0FBTyxPQUFFO0FBQzlCLGNBQUMsQ0FBSyxLQUFhLGFBQVcsWUFBRTtBQUM3QixpQkFBc0Isc0JBQUssTUFBTyxPQUN4QztBQUNGOzs7QUFZb0I7Ozs7Ozs7Ozs7Ozs7NkNBQVUsV0FBTyxPQUFNLE1BQUU7O0FBRXhDLGNBQUMsQ0FBSyxLQUFjLGVBQUU7QUFDdkIsZ0JBQWEsV0FBUyxRQUFnQixnQkFBVztBQUM3QyxpQkFBVyxZQUFNLEtBQWtCLGtCQUFNLE9BQy9DO0FBQ0Y7OztBQVNvQjs7Ozs7Ozs7Ozs2Q0FBUyxVQUFXLFdBQU8sT0FBRTtBQUMzQyxlQUFlLGdCQUFNO0FBQ25CLGtCQUFZLFVBQVEsU0FBSyxDQUF2QixHQUE2QixLQUFXLFlBQU87QUFDbkQsZUFBc0Isc0JBQUssTUFBTyxPQUMxQixhQUFVLFFBQWdCLGdCQUFXO0FBQzdDLGVBQWUsZ0JBQ3JCOzs7QUFjcUI7Ozs7Ozs7Ozs7Ozs7Ozs4Q0FBSyxNQUFPLE9BQVcsV0FBRTtBQUM1QyxjQUFRLE1BQU0sS0FBZ0IsZ0JBQU87QUFDbEMsY0FBSyxRQUFhLFdBQUU7QUFDakIsaUJBQWdCLGdCQUN0QjtBQUFFLGlCQUFLO0FBQ0QsaUJBQWEsYUFBVSxXQUM3QjtBQUNGOzs7QUFZZTs7Ozs7Ozs7Ozs7Ozt3Q0FBTSxPQUFFOztBQUViLHlCQUFjO0FBQ3BCLGlCQUFjO0FBQ1oscUJBQWEsUUFBSyxLQUFXOztBQUUvQixpQkFBYTtBQUNSLGtCQUFPLGlCQUFlLE1BQUU7QUFDekIsdUJBQVksTUFDZDtBQUFFLHFCQUFRLElBQU0sT0FBRTtBQUNoQixvQkFBSTtBQUNGLHlCQUFXLEtBQVUsVUFDdkI7a0JBQU8sT0FBRSxHQUFFO0FBQ1QseUJBQ0Y7QUFDRjs7O0FBRUs7QUFDTCxxQkFBYSxTQUFRLE9BQU8sTUFBWSxhQUU5Qzs7OztBQW1CaUI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzBDQUFNLE9BQU0sTUFBRTs7OztBQUk3QixjQUFZO0FBQ0wsa0JBQU87QUFDWixpQkFBVztBQUNBLHlCQUFRLE9BQU87QUFDbkI7O0FBRVAsaUJBQVk7QUFDQyx5QkFBTyxVQUFTO0FBQ3RCOztBQUVQLGlCQUFXO0FBQ1Qsa0JBQUk7QUFDTywyQkFBTSxLQUFNLE9BQW9CLG1CQUMzQztnQkFBTyxPQUFFLEdBQUU7QUFFWDs7QUFDSzs7QUFFUCxpQkFBVTtBQUNSLGtCQUFJO0FBQ08sMkJBQU0sS0FBTSxPQUFvQixtQkFDM0M7Z0JBQU8sT0FBRSxHQUFFO0FBQ0EsMkJBQU07QUFDUix3QkFBTSwrREFDZjs7QUFDSzs7QUFFUCxpQkFBUztBQUNFLHlCQUFFLElBQVEsS0FBTztBQUNyQjs7QUFFUCxpQkFBVztBQUNKO0FBQ0kseUJBQU87QUFFcEI7OztBQUVBLGlCQUNGOzs7O0FBd0J1Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2dEQUFTLFVBQVUsVUFBRTtBQUN2QyxjQUFDLENBQUssS0FBZSxlQUFxQixzQkFBRTtBQUN6QyxpQkFBbUIsb0JBQVEsT0FBTyxPQUFHLElBQU0sS0FDakQ7O0FBQ0csY0FBQyxDQUFLLEtBQWtCLGtCQUFVLFdBQUU7QUFDakMsaUJBQWtCLGtCQUFXLFlBQU07QUFDdEIsOEJBQUssTUFBVztBQUMzQixtQkFBZSxlQUFLLE1BQVU7OztBQUcvQixtQkFBVyxlQUFFO0FBQ2QsdUJBQVcsS0FBTyxPQUNwQjtBQUFDOztBQUVFLG1CQUFXLFdBQVcsWUFBRyxDQUFFLElBQVUsVUFBTSxPQUFFO0FBQzFDLHFCQUFhLGFBQVMsVUFDNUI7O0FBR0o7QUFad0M7QUFhMUM7OztBQVFZOzs7Ozs7Ozs7cUNBQVMsVUFBRTtBQUNyQixpQkFBVyxLQUFtQixxQkFBTyxLQUFrQixrQkFDekQ7OztBQVVZOzs7Ozs7Ozs7OztxQ0FBUyxVQUFPLE9BQUU7QUFDekIsY0FBSyxLQUFvQixvQkFBUyxVQUFRLFFBQUU7QUFDekMsaUJBQ047QUFDRjs7O0FBYW1COzs7Ozs7Ozs7Ozs7Ozs0Q0FBUyxVQUFPLE9BQUU7QUFDbkMsY0FBUSxNQUFNLEtBQU8sT0FBVTtBQUMvQixjQUFZLFVBQU0sS0FBc0Isc0JBQVMsVUFBTyxPQUFLO0FBQzFELGNBQVEsU0FBRTtBQUNSLGdCQUFDLENBQUssS0FBYyxlQUFFO0FBQ25CLG1CQUFlLGdCQUFJO0FBQ25CLG1CQUFXLFlBQ2pCOzs7QUFFRyxnQkFBSyxLQUFXLGFBQUksRUFBVSxZQUFPLEtBQVcsWUFBRTtBQUMvQyxtQkFBVSxVQUFXLFlBQzNCOztBQUNJLGlCQUFPLE9BQVcsWUFBTztBQUN6QixpQkFBYyxjQUFXLFlBQy9COztBQUNBLGlCQUNGOzs7QUFTa0I7Ozs7Ozs7Ozs7MkNBQUssTUFBRTtBQUN2QixpQkFBYyxRQUFLLEtBQWtCLGlCQUFNLFFBQU8sS0FDcEQ7OztBQVFzQjs7Ozs7Ozs7OztBQUFFOztBQUNuQixjQUFDLENBQUssS0FBZSxpQkFBTyxLQUFZLGFBQUU7QUFDdkMsaUJBQWUsZ0JBQU07QUFDaEIsc0JBQUksSUFBSSxZQUFHO0FBQ2Ysa0JBQUssT0FBYyxlQUFFO0FBQ2xCLHVCQUFlLGdCQUFPO0FBQ3RCLHVCQUNOO0FBQ0Y7QUFDRjtBQUNGOzs7QUFVa0I7Ozs7Ozs7Ozs7OzRDQUFFO0FBQ2YsY0FBQyxDQUFLLEtBQWMsZUFBRTtBQUNuQixpQkFBZSxnQkFBTTtBQUN0QixnQkFBSyxLQUFvQixxQkFBRTtBQUN4QixtQkFBOEIsOEJBQUssS0FBcUI7QUFDeEQsbUJBQXFCLHNCQUMzQjs7QUFDSSxpQkFDTjtBQUNGOzs7QUFXaUI7Ozs7Ozs7Ozs7OzsyQ0FBRTtBQUNkLGNBQUssS0FBZSxpQkFBTyxLQUFVLFdBQUU7QUFDeEMsZ0JBQWlCLGVBQU0sS0FBYztBQUNqQyxpQkFBZSxnQkFBTTtBQUNyQixpQkFBZ0I7QUFDaEIsaUJBQW1CLG1CQUFLLEtBQU8sUUFBYyxjQUFNLEtBQVc7QUFDOUQsaUJBQ047QUFDRjs7O0FBZ0JNOzs7Ozs7Ozs7Ozs7Ozs7OztnQ0FBRTtBQUNGLGVBQWEsY0FBTTs7QUFFbkIsZUFDTjs7O0FBYWtCOzs7Ozs7Ozs7Ozs7OzsyQ0FBYSxjQUFjLGNBQVUsVUFBRSxHQUN6RDs7O0FBcUJxQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs4Q0FBUyxVQUFPLE9BQUssS0FBRTtBQUNuQztBQUVMO0FBQUssb0JBQVU7QUFFZDtBQUFLLG9CQUFRLE9BQVMsVUFFM0I7O0FBRUY7Ozs7TUFoZ0IyQzs7QUFrZ0IzQyxXQUVGO0FBRUYsR0EvZ0JxQztBQStnQmpDLEs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQy9sQkosQ0FBVSxZQUFFOztBQUVFOzs7Ozs7Ozs7O0FBU1osTUFBeUI7QUFDZixjQUFNO0FBQ0Ysa0JBQ2I7QUFIMEI7QUFJM0IsV0FBOEIsc0JBQUssTUFBRTtBQUNuQyxRQUFPLEtBQU0sS0FBYSxhQUFNO0FBQzdCLFFBQUksTUFBcUIsbUJBQUksS0FBRTtBQUNoQyxVQUFNLElBQU07QUFDWCxRQUFnQixnQkFBTTtBQUNsQixhQUFHLEVBQWMsY0FBYyxjQUFJO0FBQ3ZDLFFBQVcsV0FBYSxhQUFLLE1BQUk7QUFDOUIsV0FBWSxZQUFHO0FBQ2QsYUFBRSxFQUFXLFdBQU8sUUFBRTtBQUNyQixhQUFhLGFBQUUsRUFBVyxXQUFHLEdBQUssTUFBRyxFQUFXLFdBQUcsR0FBTztBQUM3RCxVQUFnQixnQkFBRSxFQUFXLFdBQUcsR0FDbkM7QUFDRjs7QUFDQSxXQUNGOzs7QUFFQSxXQUF5QixpQkFBSyxNQUFVLFVBQUU7O0FBRXhDLFFBQVcsU0FBVSxTQUFZLGNBQW1CLGlCQUFLLE1BQVUsU0FBWTs7QUFFNUUsUUFBTyxRQUFFOzs7QUFHTixXQUFDLElBQUssSUFBTyxPQUFXLFlBQUcsSUFBRSxHQUFHLEdBQUcsSUFBRSxFQUFZLGFBQUU7QUFDbEQsWUFBUyxTQUFhLGdCQUFPLEtBQUU7QUFDaEMsaUJBQ0Y7QUFDRjtBQUNGO0FBQUUsV0FBSztBQUNMLGFBQ0Y7QUFDRjs7OztBQUdBLFdBQXFCLGFBQUssTUFBSyxLQUFNLE1BQVUsVUFBRTtBQUM1QyxRQUFTLFNBQUcsSUFBRTtBQUNaLFVBQVMsU0FBSyxNQUNuQjtBQUNGOzs7O0FBR0EsV0FBMkIsbUJBQUssTUFBTSxNQUFVLFVBQUU7QUFDN0MsUUFBUyxTQUFRLFVBQVcsU0FBTyxPQUFPLFFBQUU7QUFDekMsV0FBQyxJQUFLLElBQUUsR0FBSSxLQUFTLFNBQU8sUUFBRyxHQUFJLElBQUcsR0FBWSxNQUFqQixLQUFtQixJQUFHLEdBQUksS0FBSyxLQUFFO0FBQ2hFLGFBQThCLDhCQUFLLE1BQUcsRUFBSyxNQUFHLEVBQU0sT0FDMUQ7QUFDRjtBQUNGOzs7O0FBR0EsV0FBNkIscUJBQUssTUFBTSxNQUFVLFVBQUU7QUFDL0MsUUFBUyxTQUFhLGNBQUU7QUFDckIsV0FBZSxnQkFBVSxTQUMvQjtBQUNGOzs7QUFFQSxXQUErQix1QkFBUSxTQUFXLFdBQVksWUFBRTs7O0FBR3RELGNBQVMsUUFBYSxlQUFVO0FBQ3hDLFFBQVksVUFBVSxpQkFBRSxHQUFFO0FBQ3JCLFVBQVEsUUFBWSxhQUFFO0FBQ2hCLGdCQUFZLFlBQUUsR0FBRyxFQUMxQjtBQUFFLGFBQUs7QUFDRSxnQkFBSyxLQUFxQixzQkFBYSxhQUNoRDtBQUNGO0FBQUM7QUFDRCxXQUNGOzs7Ozs7Ozs7Ozs7Ozs7OztBQWdCTyxVQUFlLHdCQUF1QixjQUFZOztBQU92RDs7Ozs7QUFQMEQsUUFPdEM7Ozs7Ozs7Ozs7Ozs7QUFtU0o7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7dUNBQVMsVUFBRTs7QUFFcEIsY0FBVSxZQUFHLENBQVMsU0FBUyxXQUN4QixPQUFxQix1QkFBc0Isb0JBQVMsVUFBRTtBQUMzQyxnQ0FBUyxTQUM5Qjs7QUFDQSxjQUFpQixlQUFNLEtBQVksWUFBZSxlQUFVO0FBQzVELGNBQWEsV0FBYyxhQUFhO0FBQ3hDLGNBQVksVUFBYyxhQUFTLFdBQVcsU0FBUTtBQUN0RCxjQUFRLE1BQWdDLDZCQUFTLFNBQVcsV0FBUSxTQUFROztBQUV6RSxjQUFvQixxQkFBRSxDQUFhLGFBQWtCO0FBQ3hELGNBQVUsUUFBSyxJQUFVLFdBQUUsSUFBUyxNQUFTLFNBQVE7QUFDbEQsY0FBRyxJQUFJO0FBQ04sZUFBQyxJQUFLLElBQUUsR0FBRyxJQUFTLFNBQU8sUUFBTSxNQUFJLElBQU8sQ0FBVCxLQUFjLE9BQVMsU0FBSSxLQUFLLEtBQUU7QUFDdkUsZ0JBQVMsT0FBTyxNQUFJLEtBQWtCLGlCQUFJLEtBQU87QUFDckMseUJBQUssTUFBSyxJQUFFLEdBQU0sTUFBTztBQUNqQixpQ0FBSyxNQUFNLE1BQU87QUFDcEIsK0JBQUssTUFBTSxNQUMvQjs7QUFDQSxpQkFBc0MsZ0NBQ3hDOzs7O0FBZTZCOzs7Ozs7Ozs7Ozs7Ozs7O3NEQUFLLE1BQVcsV0FBWSxZQUFTLFNBQUU7QUFDMUQsb0JBQVUsV0FBTztBQUN6QixjQUFZLFVBQXdCLHVCQUFRLFNBQVcsV0FBYTtBQUNoRSxlQUF3Qix3QkFBSyxNQUFXLFdBQVU7QUFDdEQsaUJBQ0Y7OztBQVN1Qjs7Ozs7Ozs7OztnREFBSyxNQUFXLFdBQVMsU0FBRTtBQUM1QyxlQUFpQixpQkFBVSxXQUNqQzs7O0FBUzRCOzs7Ozs7Ozs7O3FEQUFLLE1BQVcsV0FBUyxTQUFFO0FBQ2pELGVBQW9CLG9CQUFVLFdBQ3BDO0FBRUY7Ozs7O0FBdlJ1Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3VDQUFTLFVBQW1CLG1CQUFFOztBQUU5QyxjQUFDLENBQVMsU0FBYyxlQUFFO0FBQzNCLGdCQUFpQixlQUFVLFNBQWUsZ0JBQUk7QUFDbEMseUJBQWMsZUFBSTtBQUNsQix5QkFBaUIsa0JBQ1IscUJBQW9CLGtCQUFrQixlQUF6RCxJQUNRLFNBQWEsYUFBb0I7QUFDdkMsaUJBQXNCLHNCQUFTLFVBQWMsY0FBRSxFQUFPLFFBQzVEOztBQUNBLGlCQUFlLFNBQ2pCO0FBRTRCOzs7OENBQVMsVUFBYyxjQUFVLFVBQUU7QUFDN0QsaUJBQVcsS0FBbUIsbUJBQVMsU0FBUSxTQUFjLGNBQy9EOzs7QUFleUI7Ozs7Ozs7Ozs7Ozs7Ozs7MkNBQUssTUFBYyxjQUFVLFVBQUU7QUFDdEQsY0FBUztBQUNULGNBQVksVUFBc0Isb0JBQU07QUFDckMsY0FBUSxRQUFXLGFBQWMsY0FBRyxDQUFRLFFBQWEsYUFBb0IscUJBQUU7QUFDMUUsb0JBQU0sS0FBNkIsNkJBQVEsU0FBYyxjQUFZLGFBQzdFO0FBQUUsaUJBQVEsSUFBUSxRQUFXLGNBQVUsUUFBRTs7QUFFM0IseUJBQW1CLG9CQUNqQzs7QUFDRyxjQUFRLFFBQVcsWUFBRTtBQUNoQixvQkFBTSxLQUF5Qix5QkFBUSxTQUFjLGNBQVksYUFDekU7O0FBQ0csY0FBUSxRQUFlLGlCQUFVLFFBQWdCLGlCQUFFO0FBQzlDLG9CQUFNLEtBQTZCLDZCQUFRLFNBQWMsY0FBWSxhQUM3RTs7QUFDQSxpQkFDRjs7O0FBYytCOzs7Ozs7Ozs7Ozs7Ozs7aURBQUssTUFBYyxjQUFVLFVBQUU7QUFDeEQsZUFBQyxJQUFRLE9BQUssS0FBVyxZQUFhLGNBQUUsR0FBTSxNQUFNLE1BQU0sT0FBSyxNQUFFOztBQUVoRSxnQkFBSyxLQUFXLGFBQWEsWUFBRTtBQUMzQixxQkFBdUIsc0JBQzlCOzs7Ozs7QUFLSyxtQkFBTSxLQUFZO0FBQ3BCLGdCQUFLLEtBQVUsYUFBUSxLQUFVLFdBQUU7QUFDcEMsNkJBQWtCLElBQU07QUFDbEIscUJBQU0sS0FBRSxFQUFVLGFBQVEsS0FBVyxXQUFFO0FBQ3ZDLHFCQUFhLGVBQUksRUFBWTtBQUM1Qix1QkFBRyxFQUFZO0FBQ2hCLHFCQUFZLFlBQUc7QUFDakIsb0JBQ0o7OztBQUVHLGtCQUFhLGFBQWlCLG1CQUFHLENBQUssS0FBWSxZQUFPLFFBQUU7QUFDeEQscUJBQVksWUFBTTtBQUV4QjtBQUNGOztBQUNBLGdCQUFjLFlBQUUsRUFBYSwwQkFBWSxZQUFZO0FBQ2xELGdCQUFLLEtBQW1CLG1CQUFLLE1BQWMsY0FBWSxZQUFFO0FBQ2pELHdCQUFXLFlBQWMsYUFBYSxhQUFLLE1BQXlCLHdCQUFhLGFBQzVGOzs7QUFFRyxnQkFBSyxLQUFXLFlBQUU7QUFFckI7QUFDRjtBQUNGOzs7QUFtQm1DOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztxREFBSyxNQUFtQixtQkFBVSxVQUFFO0FBQ3JFLGNBQWlCLGVBQU0sS0FBZSxlQUFLLE1BQW9CO0FBQy9ELGNBQVksVUFBYyxhQUFTLFVBQzdCLEtBQVEsUUFBYyxjQUF5QjtBQUM5QyxrQkFBWSxZQUFLLEtBQVM7QUFDekIsbUJBQWMsZUFBYztBQUNwQyxpQkFDRjs7O0FBWW1DOzs7Ozs7Ozs7Ozs7O3FEQUFLLE1BQWMsY0FBVSxVQUFFOzs7QUFHaEUsY0FBVSxRQUFPO0FBQ2pCLGNBQVUsUUFBTyxNQUFLLEtBQUssS0FBWTtBQUNuQyxlQUFDLElBQUssSUFBTSxNQUFPLFNBQUUsR0FBSyxHQUFFLElBQU0sTUFBSSxJQUFLLEtBQUU7QUFDekMsb0JBQU0sS0FBNEIsNEJBQUssTUFBYyxjQUFVLFVBQUcsRUFBSyxNQUFHLEVBQVEsVUFDMUY7O0FBQ0EsaUJBQ0Y7OztBQWlCa0M7Ozs7Ozs7Ozs7Ozs7Ozs7OztvREFBSyxNQUFjLGNBQVUsVUFBTSxNQUFPLE9BQUU7O0FBRXpFLGNBQUssS0FBTSxNQUFFLEdBQUssT0FBUyxPQUFFO0FBQzFCLGlCQUFnQixnQkFBTTtBQUNsQixxQkFBUSxTQUFVLFNBQVEsVUFBSztBQUMvQixxQkFBTyxPQUFLO0FBQ2Qsb0JBQU0sS0FBTSxNQUFHO0FBRW5CO0FBSG1CO0FBSXJCLG1CQUNGOztBQUVBO2VBQVEsSUFBTSxTQUFRLE1BQUU7QUFDZCx1QkFBSSxLQUFPO0FBQ25CLHFCQUNGOztBQUNBLGlCQUNGOzs7QUFZMEI7Ozs7Ozs7Ozs7Ozs7NENBQVMsVUFBRTtBQUNuQyxjQUFpQix5REFBdUQsUUFBVixDQUF3QjtBQUN0RixpQkFBcUIsZ0JBQWUsYUFBVSxPQUF2QyxJQUFrRCxTQUMzRDs7Ozs7TUEzUXFDOztBQXNXdkMsV0FFRjtBQUVGLEdBalhpQztBQWlYN0IsSzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN6U087QUFDSCxNQUFjOztBQUVOOzs7O0FBSUY7QUFDQSxZQUFTO0FBQ1IsYUFBTztBQUNOLGNBQU07QUFDTSwwQkFDbkI7QUFMTzs7Ozs7QUFVRTtBQUNKLFlBQVM7QUFDUixhQUFPO0FBQ00sMEJBQ25CO0FBSlc7Ozs7O0FBU007QUFDWixZQUFRO0FBQ1AsYUFDTjtBQUhtQjs7Ozs7OztBQVVmO0FBQ0MsWUFBUTtBQUNQLGFBQ047QUFITTs7Ozs7QUFRQztBQUNGLFlBQVE7QUFDSixnQkFBTTtBQUNJLDBCQUNuQjtBQUpTOzs7OztBQVNEO0FBQ0gsWUFBUztBQUNSLGFBQU87QUFDTSwwQkFDbkI7QUFKVTs7Ozs7QUFTQTtBQUNMLFlBQVM7QUFDUixhQUNOO0FBSFk7Ozs7O0FBUUQ7QUFDTixZQUFTO0FBQ1IsYUFFUjtBQUplO0FBbkVKLEdBSE47O0FBNEVHLGFBQUUsQ0FDMEIscUNBQ0EscUNBQ1csZ0RBRS9DOztBQUVlLG9CQUFHOztBQUVOLGlCQUFNOztBQUVQLGdCQUFHOztBQUVRLDJCQUFNOztBQUVoQixpQkFBTTs7QUFFUCxnQkFBTTs7QUFFVixZQUFXLG9CQUFFO0FBQ1osWUFBYSxhQUFnQixnQkFBSyxNQUFXLFlBQUU7QUFDaEQsV0FBeUIsMEJBQU0sS0FBbUIsbUJBQUssS0FBTTtBQUM3RCxXQUFpQixpQkFBVSxXQUFNLEtBQW1CLG1CQUFLLEtBQU07OztBQUcvRCxXQUFPLE9BQUssTUFBUyxTQUFXO0FBQ2hDLFdBQW1CLG1CQUN6QjtBQUFFOztBQUVFLFNBQUssS0FDWDtBQUFDOztBQUVPLFlBQVcsb0JBQUU7QUFDWCxhQUFvQixvQkFBVSxXQUFNLEtBQzlDO0FBQUM7Ozs7O0FBS0csUUFBVyxnQkFBRTtBQUNYLFNBQVEsU0FDZDtBQUFDOzs7OztBQUtJLFNBQVcsaUJBQUU7QUFDWixTQUFRLFNBQ2Q7QUFBQzs7Ozs7QUFLSyxVQUFXLGtCQUFFO0FBQ2IsU0FBUSxTQUFFLENBQUssS0FDckI7QUFBQzs7Ozs7OztBQU9PLFlBQVcsb0JBQUU7QUFDbkIsV0FBVyxLQUFhLGVBQU8sS0FBRSxFQUFpQixpQkFDcEQ7QUFBQzs7QUFFSyxVQUFXLGtCQUFFO0FBQ2pCLFdBQWEsT0FBaUIsaUJBQU0sTUFBVyxjQUNqRDtBQUFDOztBQUVhLGtCQUFXLDBCQUFFO0FBQ2xCLFlBQUssS0FBUTtBQUNsQixXQUFZO0FBQ04sYUFBYSxhQUFLLEtBQVUsV0FBVSxVQUFTO0FBQzdDO0FBQ1IsV0FBVTtBQUNKLGFBQWEsYUFBSyxLQUFVLFdBQVMsU0FBVTtBQUV2RDs7QUFDSSxTQUFhLGFBQUssS0FDeEI7QUFBQzs7QUFFaUIsc0JBQVUsNEJBQU0sT0FBRTtBQUNsQyxRQUFnQixjQUFJO0FBQ2pCLFFBQU0sTUFBUyxZQUFlLGFBQUU7O0FBRTVCLFlBQWlCO0FBQ2xCLFdBQ047QUFDRjtBQUFDOztBQUVLLFVBQVUsZ0JBQU0sT0FBRTtBQUNuQixRQUFLLEtBQVksY0FBTyxLQUFhLGNBQUU7QUFFMUM7Ozs7QUFHSyxVQUFpQjs7QUFFZixZQUFNLE1BQU8sT0FBUTtBQUMxQixXQUFZO0FBQ04sYUFBWSxZQUFPO0FBQ2xCO0FBQ1AsV0FBWTtBQUNOLGFBQVcsV0FBTztBQUNqQjtBQUNQLFdBQVU7QUFDSixhQUFVLFVBQU87QUFHM0I7O0FBQUM7O0FBRVUsZUFBVSxxQkFBTSxPQUFFO0FBQ3ZCLFNBQWMsZUFBTSxLQUFjLGNBQVM7O0FBRS9DLFFBQVMsT0FBTSxLQUFFLEVBQWlCLGlCQUF3QjtBQUN0RCxTQUFhLGNBQU0sS0FBTTtBQUMxQixRQUFLLEtBQVUsYUFBVSxRQUFFO0FBQ3hCLFdBQWtCLG1CQUFNLEtBQzlCO0FBQUUsV0FBSztBQUNELFdBQWtCLG1CQUFNLEtBQU8sUUFBUSxPQUM3Qzs7O0FBRUksU0FBZSxnQkFBSTs7O0FBR25CLFNBQXlCLHlCQUFHO0FBQzVCLFNBQU0sTUFBWSxhQUN4QjtBQUFDOztBQUVTLGNBQVUsb0JBQU0sT0FBRTtBQUN0QixTQUFpQixpQkFBTSxNQUFPLE9BQUksS0FBTSxLQUFrQjs7OztBQUkxRCxTQUFjLGNBQUs7QUFDbkIsVUFBTyxNQUFPLE9BQUc7QUFDVixpQkFBTSxLQUVuQjtBQUowQjtBQUl6Qjs7QUFFUSxhQUFVLG1CQUFNLE9BQUU7QUFDekIsUUFBTSxJQUFPLE1BQU8sT0FBSSxLQUFNLEtBQWlCO0FBQy9DLFFBQWdCLGNBQU0sS0FBVztBQUNqQyxRQUFtQixpQkFBTSxLQUFVLGFBQVU7QUFDN0MsUUFBaUIsZUFBbUIsaUJBQUcsS0FBSyxLQUFLLEtBQUcsQ0FDbEQsY0FBRyxLQUFLLEtBQUssS0FBZTs7QUFFM0IsUUFBQyxDQUFhLGNBQUU7O0FBRWpCLFVBQWlCLGVBQU0sS0FBYztBQUNqQyxXQUFlLGdCQUFNOztBQUVyQixXQUFhLGFBQU0sT0FBZTtBQUNuQyxVQUFLLEtBQWMsaUJBQVEsS0FBYyxjQUFTLFVBQUU7QUFFdkQ7QUFDRjs7Ozs7QUFJQSxRQUFjLFlBQWMsY0FBRztBQUM1QixRQUFNLE1BQU8sT0FBSSxLQUFFLENBQVUsV0FBRTtBQUM1QixXQUFRLFNBQU0sS0FBVSxhQUM5QjtBQUFFLFdBQVEsSUFBTSxNQUFPLE9BQUksS0FBVyxXQUFFO0FBQ2xDLFdBQVEsU0FBTSxLQUFVLGFBQzlCOzs7QUFFRyxRQUFhLGNBQUU7QUFDWixXQUFTLFNBQW9CLHFCQUFNLEtBQ3pDO0FBQUUsV0FBSztBQUNELFdBQVMsU0FBb0IscUJBQU0sS0FBa0IsbUJBQU0sS0FDakU7OztBQUVJLFNBQXlCLHlCQUFLLEtBQW9CO0FBQ2xELFNBQXdCO0FBQ3hCLFNBQU0sTUFBWSxhQUN4QjtBQUFDOztBQUVpQixzQkFBVSw0QkFBTSxPQUFjLGNBQUU7O0FBRWhELFFBQVEsTUFBTSxLQUFNO0FBQ3BCLFFBQW1CLGlCQUFNLE1BQUs7QUFDOUIsUUFBZTtBQUNmLFFBQVEsTUFBRztBQUNYLFFBQVEsTUFBYyxhQUFRLFNBQUc7O0FBRTNCLFdBQUssT0FBTSxLQUFFOztBQUVqQixVQUFRLE1BQU8sTUFBTyxHQUFaLElBQWdCO0FBQzFCLFVBQU0sSUFBYyxhQUFLO0FBQ3RCLFVBQUUsRUFBVyxhQUFpQixnQkFBRTtBQUNyQixzQkFBRztBQUNYLGNBQU0sTUFDWjtBQUFFLGFBQUs7QUFDRCxjQUFNLE1BQ1o7QUFDRjs7O0FBRUcsUUFBWSxhQUFFO0FBQ2YsVUFBTyxLQUFPLE1BQU8sT0FBSSxLQUFhLFlBQUc7QUFDekMsVUFBTyxLQUFPLE1BQWEsWUFBWSxTQUE5QixJQUFrQztBQUMzQyxhQUFVLEtBQ1o7O0FBQ0EsV0FDRjtBQUFDOztBQUVXLGdCQUFVLHNCQUFNLE9BQWMsY0FBRTtBQUMxQyxRQUFhLFdBQU0sS0FBbUIsbUJBQU0sT0FBZTs7O0FBR3hELFFBQUssS0FBSSxJQUFXLFlBQU0sS0FBcUIsc0JBQUU7QUFFcEQ7OztBQUVJLFNBQWMsZUFBTSxLQUFjLGNBQVM7O0FBRS9DLFFBQU0sSUFBTyxNQUFPLE9BQUksS0FBTSxLQUFpQjtBQUMvQyxRQUFnQixjQUFNLEtBQVc7QUFDakMsUUFBbUIsaUJBQU0sS0FBVSxhQUFVO0FBQzdDLFFBQXVCLHFCQUFXLFdBQUc7QUFDckMsUUFBa0IsZ0JBQUUsQ0FBb0Isc0JBQWlCO0FBQ3pELFFBQW1CLGlCQUFxQixzQkFBRyxDQUFlO0FBQzFELFFBQU07QUFDSCxRQUFjLGVBQUU7QUFDZCxXQUFHLEVBQUcsSUFDWDtBQUFFLGVBQXVCLGdCQUFFO0FBQ3BCLFdBQWEsY0FDcEI7QUFBRSxLQUZRLE1BRUg7QUFDRixXQUFFLENBQ1A7Ozs7QUFHRyxRQUFtQixvQkFBRTtBQUNiLGlCQUFNLEtBQUksSUFBUyxVQUFNLEtBQTBCO0FBQ3hELFdBQVEsU0FBTSxLQUFVLGFBQzlCO0FBQUUsV0FBSztBQUNJLGlCQUFNLEtBQUksSUFBUyxVQUFFLENBQUssS0FBMEI7QUFDekQsV0FBUSxTQUFNLEtBQVUsYUFDOUI7Ozs7O0FBSUEsUUFBTSxJQUFNLEtBQXNCLHVCQUFLLEtBQUU7QUFDckMsU0FBeUIseUJBQUc7QUFDNUIsU0FBK0IsK0JBQUssS0FBd0I7O0FBRTVELFNBQXdCO0FBQ3hCLFNBQVMsU0FBb0IscUJBQU0sS0FBa0IsbUJBQzNEO0FBQUM7O0FBRXVCLDRCQUFVLGtDQUFTLFVBQUU7QUFDdkMsU0FBTSxNQUFvQixxQkFBVyxXQUFNO0FBQzNDLFNBQUUsRUFBaUIsaUJBQU0sTUFBb0IscUJBQVcsV0FBTTtBQUM5RCxTQUFFLEVBQU0sTUFBTSxNQUFvQixxQkFBVyxXQUNuRDtBQUFDOztBQUU2QixrQ0FBVSx3Q0FBZSxnQkFBRTtBQUNuRCxTQUFFLEVBQWlCLGlCQUFNLE1BQTBCLDJCQUFnQjtBQUNuRSxTQUFFLEVBQU0sTUFBTSxNQUEwQiwyQkFDOUM7QUFBQzs7QUFFZSxvQkFBVSwwQkFBRSxHQUFFO0FBQzVCLFFBQWdCLGNBQU0sS0FBVzs7QUFFOUIsUUFBSyxLQUFVLGFBQVUsUUFBRTtBQUMxQixVQUFNLEtBQUksSUFBQyxDQUFZLGFBQU0sS0FBSSxJQUFFLEdBQUs7QUFDdEMsV0FBRSxFQUFNLE1BQU0sTUFBUyxVQUFJLElBQUksSUFDckM7QUFBRSxXQUFLO0FBQ0gsVUFBTSxLQUFJLElBQUUsR0FBTSxLQUFJLElBQUUsR0FBZTtBQUNyQyxXQUFFLEVBQU0sTUFBTSxNQUFTLFVBQUksSUFBSSxJQUNyQzs7O0FBRUksU0FBWSxZQUFHLElBQU0sTUFBSyxLQUFLLEtBQU0sS0FBRSxFQUM3QztBQUFDOztBQUVvQix5QkFBVyxpQ0FBRTtBQUM1QixTQUFFLEVBQU0sTUFBTSxNQUFTLFVBQUk7QUFDM0IsU0FBVSxVQUFHLElBQU0sS0FBRSxFQUMzQjtBQUFDOztBQUVnQixxQkFBVyw2QkFBRTtBQUM1QixRQUFhLFdBQU0sS0FBYTs7O0FBRzdCLFFBQVUsYUFBUSxLQUFjLGNBQVMsVUFBRTtBQUN4QyxXQUF5Qix5QkFBSyxLQUFvQjtBQUNsRCxXQUErQiwrQkFBSTtBQUNuQyxXQUFNLE1BQVksYUFDeEI7OztBQUVJLFNBQWEsY0FBTTs7QUFFcEIsUUFBSyxLQUFPLFFBQUU7QUFDWCxXQUFjLGVBQU0sS0FBWSxhQUM5QixLQUFjLGNBQW1CLG9CQUFNLEtBQWMsY0FDN0Q7QUFBRSxXQUFLO0FBQ0QsV0FBYyxlQUFNLEtBQWMsY0FDeEM7OztBQUVHLFFBQVUsYUFBUSxLQUFhLGNBQUU7QUFDL0IsVUFBSyxLQUFjLGlCQUFRLEtBQWMsY0FBTyxRQUFFO0FBQy9DLGFBQXdCO0FBQ3BCLGlCQUFpQixpQkFBVSxXQUFNLEtBQXlCO0FBQzFELGlCQUFLLEtBQU0sTUFBVSxXQUMvQjtBQUFFLGFBQUs7QUFDRyxpQkFBb0Isb0JBQVUsV0FBTSxLQUF5QjtBQUM3RCxpQkFBSyxLQUFNLE1BQVUsV0FDL0I7Ozs7QUFHRyxVQUFVLGFBQVEsS0FBYyxjQUFLLE1BQUU7QUFDcEMsYUFBSyxLQUNYO0FBQ0Y7QUFDRjtBQUFDOzs7Ozs7O0FBT1UsZUFBVyx1QkFBRTtBQUNsQixTQUFLLEtBQ1g7QUFBQzs7QUFFb0IseUJBQVcsaUNBQUU7QUFDN0IsUUFBSyxLQUFZLGFBQUU7QUFFdEI7Ozs7O0FBSUEsUUFBOEIsNEJBQUUsQ0FDRSxnQ0FDRyxtQ0FDVyw4Q0FDQywrQ0FDRSxpREFDRiwrQ0FDaEIsK0JBQ0ksbUNBRWxDLCtDQUFLLEtBQUs7QUFDYixRQUFzQixvQkFBUyxRQUFJLElBQU0sTUFBaUIsaUJBQTJCOztBQUVsRixRQUFrQixrQkFBUSxTQUFHLEdBQUU7QUFDNUIsV0FBZSxnQkFBbUIsa0JBQUc7QUFDckMsV0FBYyxlQUFtQixrQkFBa0Isa0JBQVEsU0FDakU7QUFBRSxXQUFLOztBQUVELFdBQWUsZ0JBQU07QUFDckIsV0FBYyxlQUNwQjs7Ozs7O0FBS0EsUUFBYSxXQUFNLEtBQWEsYUFBWTtBQUN6QyxRQUFVLFlBQVcsU0FBUyxVQUFNLE1BQUUsQ0FBRSxHQUFFO0FBQ3ZDLFdBQ047QUFBRSxXQUFRLElBQUssS0FBYyxlQUFFO0FBQ3pCLFdBQWMsY0FDcEI7QUFDRjtBQUFDOztBQUVpQixzQkFBVSw0QkFBTSxPQUFFO0FBQy9CLFFBQUssS0FBWSxhQUFFO0FBRXRCOzs7QUFFQSxRQUFnQixjQUFHO0FBQ2hCLFFBQUssS0FBYyxpQkFBUSxLQUFjLGNBQVEsVUFBUSxNQUFTLFlBQWUsYUFBRTtBQUNqRixVQUFNLE1BQVMsVUFBRTtBQUNmLFlBQUssS0FBZSxpQkFBVSxRQUFJLElBQU8sT0FBYSxnQkFBUSxLQUFjLGVBQUU7QUFDMUUsZ0JBQWlCO0FBQ2xCLGVBQWEsYUFDbkI7QUFDRjtBQUFFLGFBQUs7QUFDRixZQUFLLEtBQWMsZ0JBQVUsUUFBSSxJQUFPLE9BQWEsZ0JBQVEsS0FBYSxjQUFFO0FBQ3hFLGdCQUFpQjtBQUNsQixlQUFjLGNBQ3BCO0FBQ0Y7QUFDRjtBQUNGO0FBQUM7O0FBRXVCLDRCQUFVLGtDQUFPLFFBQVksWUFBRTtBQUNqRCxTQUFZLFlBQVUsV0FBUyxVQUFHLENBQVcsWUFBTSxLQUFFLEVBQU87Ozs7QUFJNUQsU0FBUyxTQUFvQixxQkFBTSxLQUFrQixtQkFBTSxLQUNqRTtBQUFDOztBQUVtQix3QkFBSzs7QUFFRCw0QkFBSzs7QUFFUCwwQkFBb0M7O0FBRXRDLHdCQUFLOztBQUVaO0FBQ1AsVUFBRztBQUNELFlBQUc7QUFDUSx1QkFBRztBQUNkLFlBQUc7QUFDRCxjQUFHO0FBQ0gsY0FDVjs7Ozs7Ozs7QUFhQTs7Ozs7QUFwQmUsTzs7Ozs7Ozs7O0FDdnBCckIsbUJBQUFELENBQVEsRUFBUixFOzs7Ozs7Ozs7QUNEQSxDQUFDLFlBQVU7QUFBQzs7Ozs7Ozs7QUFTWjtBQUFhLE1BQUlFLElBQUUsRUFBTixDQUFTLFNBQVNDLENBQVQsR0FBWTtBQUFDLFNBQUtDLEdBQUwsR0FBUyxLQUFLQyxLQUFMLEdBQVcsQ0FBcEIsQ0FBc0IsS0FBS0MsS0FBTCxHQUFXLEtBQUtDLE1BQUwsR0FBWSxLQUFLQyxRQUFMLEdBQWMsSUFBckMsQ0FBMEMsS0FBS0MsT0FBTCxHQUFhLEtBQUtDLGFBQUwsR0FBbUIsRUFBaEMsQ0FBbUMsS0FBS0MsTUFBTCxHQUFZLENBQUMsQ0FBYixDQUFlLEtBQUtDLElBQUwsR0FBVSxDQUFWLENBQVksS0FBS0MsY0FBTCxHQUFvQixLQUFLQyxRQUFMLEdBQWMsS0FBS0MsYUFBTCxHQUFtQixFQUFyRDtBQUF3RDtBQUN6TixXQUFTQyxDQUFULENBQVdDLENBQVgsRUFBYTtBQUFDQSxRQUFFQSxFQUFFQyxPQUFGLENBQVVDLEVBQVYsRUFBYSxFQUFiLEVBQWlCRCxPQUFqQixDQUF5QkUsRUFBekIsRUFBNEIsRUFBNUIsQ0FBRixDQUFrQyxJQUFJQyxJQUFFQyxDQUFOO0FBQUEsUUFBUUMsSUFBRU4sQ0FBVjtBQUFBLFFBQVlPLElBQUUsSUFBSXJCLENBQUosRUFBZCxDQUFvQnFCLEVBQUVuQixLQUFGLEdBQVEsQ0FBUixDQUFVbUIsRUFBRXBCLEdBQUYsR0FBTW1CLEVBQUVFLE1BQVIsQ0FBZSxLQUFJLElBQUlDLElBQUVGLENBQU4sRUFBUUcsSUFBRSxDQUFWLEVBQVlDLElBQUVMLEVBQUVFLE1BQXBCLEVBQTJCRSxJQUFFQyxDQUE3QixFQUErQkQsR0FBL0I7QUFBbUMsVUFBRyxRQUFNSixFQUFFSSxDQUFGLENBQVQsRUFBYztBQUFDRCxVQUFFcEIsS0FBRixLQUFVb0IsRUFBRXBCLEtBQUYsR0FBUSxFQUFsQixFQUFzQixJQUFJdUIsSUFBRUgsQ0FBTjtBQUFBLFlBQVFJLElBQUVELEVBQUV2QixLQUFGLENBQVF1QixFQUFFdkIsS0FBRixDQUFRbUIsTUFBUixHQUFlLENBQXZCLEtBQTJCLElBQXJDLENBQTBDQyxJQUFFLElBQUl2QixDQUFKLEVBQUYsQ0FBUXVCLEVBQUVyQixLQUFGLEdBQVFzQixJQUFFLENBQVYsQ0FBWUQsRUFBRW5CLE1BQUYsR0FBU3NCLENBQVQsQ0FBV0gsRUFBRWxCLFFBQUYsR0FBV3NCLENBQVgsQ0FBYUQsRUFBRXZCLEtBQUYsQ0FBUXlCLElBQVIsQ0FBYUwsQ0FBYjtBQUFnQixPQUEzSSxNQUErSSxRQUFNSCxFQUFFSSxDQUFGLENBQU4sS0FBYUQsRUFBRXRCLEdBQUYsR0FBTXVCLElBQUUsQ0FBUixFQUFVRCxJQUFFQSxFQUFFbkIsTUFBRixJQUFVaUIsQ0FBbkM7QUFBbEwsS0FBd04sT0FBT0gsRUFBRUcsQ0FBRixFQUFJUCxDQUFKLENBQVA7QUFBYztBQUNuVSxXQUFTSyxDQUFULENBQVdMLENBQVgsRUFBYUksQ0FBYixFQUFlO0FBQUMsUUFBSUUsSUFBRUYsRUFBRVcsU0FBRixDQUFZZixFQUFFWixLQUFkLEVBQW9CWSxFQUFFYixHQUFGLEdBQU0sQ0FBMUIsQ0FBTixDQUFtQ2EsRUFBRVAsYUFBRixHQUFnQk8sRUFBRVIsT0FBRixHQUFVYyxFQUFFOUIsSUFBRixFQUExQixDQUFtQ3dCLEVBQUVWLE1BQUYsS0FBV2dCLElBQUVGLEVBQUVXLFNBQUYsQ0FBWWYsRUFBRVQsUUFBRixHQUFXUyxFQUFFVCxRQUFGLENBQVdKLEdBQXRCLEdBQTBCYSxFQUFFVixNQUFGLENBQVNGLEtBQS9DLEVBQXFEWSxFQUFFWixLQUFGLEdBQVEsQ0FBN0QsQ0FBRixFQUFrRWtCLElBQUVVLEdBQUdWLENBQUgsQ0FBcEUsRUFBMEVBLElBQUVBLEVBQUVMLE9BQUYsQ0FBVWdCLENBQVYsRUFBWSxHQUFaLENBQTVFLEVBQTZGWCxJQUFFQSxFQUFFUyxTQUFGLENBQVlULEVBQUVZLFdBQUYsQ0FBYyxHQUFkLElBQW1CLENBQS9CLENBQS9GLEVBQWlJWixJQUFFTixFQUFFSixjQUFGLEdBQWlCSSxFQUFFSCxRQUFGLEdBQVdTLEVBQUU5QixJQUFGLEVBQS9KLEVBQXdLd0IsRUFBRU4sTUFBRixHQUFTLE1BQUlZLEVBQUVhLE9BQUYsQ0FBVSxHQUFWLENBQXJMLEVBQW9NbkIsRUFBRU4sTUFBRixHQUFTLE1BQUlZLEVBQUVhLE9BQUYsQ0FBVSxRQUFWLENBQUosR0FBd0JuQixFQUFFTCxJQUFGLEdBQU95QixDQUEvQixHQUFpQ2QsRUFBRWUsS0FBRixDQUFRQyxFQUFSLE1BQWN0QixFQUFFTCxJQUFGLEdBQU80QixDQUFQLEVBQVN2QixFQUFFRixhQUFGLEdBQWdCRSxFQUFFSCxRQUFGLENBQVcyQixLQUFYLENBQWlCUCxDQUFqQixFQUFvQlEsR0FBcEIsRUFBdkMsQ0FBMUMsR0FBNEd6QixFQUFFTCxJQUFGLEdBQU8sTUFBSVcsRUFBRWEsT0FBRixDQUFVLElBQVYsQ0FBSixHQUFvQk8sQ0FBcEIsR0FBc0JDLENBQXhWLEVBQTJWLElBQUdyQixJQUFFTixFQUFFWCxLQUFQLEVBQWEsS0FBSSxJQUFJa0IsSUFBRSxDQUFOLEVBQVFFLElBQUVILEVBQUVFLE1BQVosRUFBbUJFLENBQXZCLEVBQXlCSCxJQUFFRSxDQUFGLEtBQU1DLElBQUVKLEVBQUVDLENBQUYsQ0FBUixDQUF6QixFQUF1Q0EsR0FBdkM7QUFBMkNGLFFBQUVLLENBQUYsRUFBSU4sQ0FBSjtBQUEzQyxLQUFrRCxPQUFPSixDQUFQO0FBQVM7QUFDemYsV0FBU2dCLEVBQVQsQ0FBWWhCLENBQVosRUFBYztBQUFDLFdBQU9BLEVBQUVDLE9BQUYsQ0FBVSx1QkFBVixFQUFrQyxVQUFTRCxDQUFULEVBQVdNLENBQVgsRUFBYTtBQUFDTixVQUFFTSxDQUFGLENBQUksS0FBSUEsSUFBRSxJQUFFTixFQUFFUSxNQUFWLEVBQWlCRixHQUFqQjtBQUFzQk4sWUFBRSxNQUFJQSxDQUFOO0FBQXRCLE9BQThCLE9BQU0sT0FBS0EsQ0FBWDtBQUFhLEtBQS9GLENBQVA7QUFBd0c7QUFDdkgsV0FBUzRCLENBQVQsQ0FBVzVCLENBQVgsRUFBYUksQ0FBYixFQUFlRSxDQUFmLEVBQWlCO0FBQUNBLFFBQUUsS0FBSyxDQUFMLEtBQVNBLENBQVQsR0FBVyxFQUFYLEdBQWNBLENBQWhCLENBQWtCLElBQUlDLElBQUUsRUFBTixDQUFTLElBQUdQLEVBQUVSLE9BQUYsSUFBV1EsRUFBRVgsS0FBaEIsRUFBc0I7QUFBQyxVQUFJb0IsSUFBRVQsRUFBRVgsS0FBUjtBQUFBLFVBQWNxQixDQUFkLENBQWdCLElBQUdBLElBQUVELENBQUwsRUFBT0MsSUFBRUQsRUFBRSxDQUFGLENBQUYsRUFBT0MsSUFBRSxFQUFFQSxLQUFHQSxFQUFFYixRQUFMLElBQWUsTUFBSWEsRUFBRWIsUUFBRixDQUFXc0IsT0FBWCxDQUFtQixJQUFuQixDQUFyQixDQUFULENBQXdELElBQUdULENBQUgsRUFBSztBQUFDQSxZQUFFLENBQUYsQ0FBSSxLQUFJLElBQUlDLElBQUVGLEVBQUVELE1BQVIsRUFBZUksQ0FBbkIsRUFBcUJGLElBQUVDLENBQUYsS0FBTUMsSUFBRUgsRUFBRUMsQ0FBRixDQUFSLENBQXJCLEVBQW1DQSxHQUFuQztBQUF1Q0gsY0FBRXFCLEVBQUVoQixDQUFGLEVBQUlSLENBQUosRUFBTUcsQ0FBTixDQUFGO0FBQXZDO0FBQWtELE9BQTVELE1BQWlFSCxJQUFFQSxJQUFFSixFQUFFUixPQUFOLElBQWVZLElBQUVKLEVBQUVSLE9BQUosRUFBWVksSUFBRUEsRUFBRUgsT0FBRixDQUFVNEIsRUFBVixFQUFhLEVBQWIsRUFBaUI1QixPQUFqQixDQUF5QjZCLEVBQXpCLEVBQTRCLEVBQTVCLENBQWQsRUFBOEMxQixJQUFFQSxFQUFFSCxPQUFGLENBQVU4QixFQUFWLEVBQWEsRUFBYixFQUFpQjlCLE9BQWpCLENBQXlCK0IsRUFBekIsRUFBNEIsRUFBNUIsQ0FBL0QsR0FBZ0csQ0FBQ3pCLElBQUVILEVBQUU1QixJQUFGLEVBQUgsTUFBZStCLElBQUUsT0FBS0EsQ0FBTCxHQUFPLElBQXhCLENBQWhHO0FBQThILFdBQUlQLEVBQUVILFFBQUYsS0FBYVMsS0FBR04sRUFBRUgsUUFBRixHQUFXLE1BQTNCLEdBQW1DUyxLQUFHQyxDQUF0QyxFQUF3Q1AsRUFBRUgsUUFBRixLQUFhUyxLQUFHLE9BQWhCLENBQTVDLEVBQXNFLE9BQU9BLENBQVA7QUFBUztBQUNqYSxNQUFJcUIsSUFBRSxDQUFOO0FBQUEsTUFBUUosSUFBRSxDQUFWO0FBQUEsTUFBWUgsSUFBRSxDQUFkO0FBQUEsTUFBZ0JNLElBQUUsR0FBbEI7QUFBQSxNQUFzQnhCLEtBQUcsbUNBQXpCO0FBQUEsTUFBNkRDLEtBQUcsa0JBQWhFO0FBQUEsTUFBbUYwQixLQUFHLG1EQUF0RjtBQUFBLE1BQTBJQyxLQUFHLDREQUE3STtBQUFBLE1BQTBNQyxLQUFHLHlDQUE3TTtBQUFBLE1BQXVQQyxLQUFHLDJDQUExUDtBQUFBLE1BQXNTVixLQUFHLG1CQUF6UztBQUFBLE1BQTZUTCxJQUFFLE1BQS9ULENBQXNVLElBQUlnQixLQUFHQyxRQUFRQyxPQUFSLEVBQVAsQ0FBeUIsU0FBU0MsRUFBVCxDQUFZcEMsQ0FBWixFQUFjO0FBQUMsUUFBR0EsSUFBRWYsRUFBRWUsQ0FBRixDQUFMLEVBQVVBLEVBQUVxQyx3QkFBRixHQUEyQnJDLEVBQUVxQyx3QkFBRixJQUE0QixDQUF2RCxFQUF5RHJDLEVBQUVzQywyQkFBRixHQUE4QnRDLEVBQUVzQywyQkFBRixJQUErQixDQUF0SCxFQUF3SHRDLEVBQUV1QyxxQkFBRixHQUF3QixDQUFDdkMsRUFBRXVDLHFCQUFGLElBQXlCLENBQTFCLElBQTZCLENBQTdLO0FBQStLLFlBQVNDLENBQVQsQ0FBV3hDLENBQVgsRUFBYTtBQUFDLFdBQU9BLEVBQUVxQyx3QkFBRixLQUE2QnJDLEVBQUV1QyxxQkFBdEM7QUFBNEQsWUFBU0UsRUFBVCxDQUFZekMsQ0FBWixFQUFjO0FBQUNBLE1BQUVzQywyQkFBRixHQUE4QnRDLEVBQUV1QyxxQkFBaEMsQ0FBc0R2QyxFQUFFQSxDQUFGLEtBQU1BLEVBQUVBLENBQUYsR0FBSSxDQUFDLENBQUwsRUFBT2lDLEdBQUdTLElBQUgsQ0FBUSxZQUFVO0FBQUMxQyxRQUFFcUMsd0JBQUYsR0FBMkJyQyxFQUFFdUMscUJBQTdCLENBQW1EdkMsRUFBRUEsQ0FBRixHQUFJLENBQUMsQ0FBTDtBQUFPLEtBQTdFLENBQWI7QUFBNkYsSUFBQyxJQUFJMkMsSUFBRSxFQUFFQyxPQUFPQyxRQUFQLElBQWlCRCxPQUFPQyxRQUFQLENBQWdCQyxLQUFuQyxDQUFOO0FBQUEsTUFBZ0RDLENBQWhELENBQWtELFNBQVNDLENBQVQsQ0FBV2hELENBQVgsRUFBYTtBQUFDK0MsUUFBRS9DLEtBQUdBLEVBQUVpRCxpQkFBTCxHQUF1QixDQUFDLENBQXhCLEdBQTBCTixLQUFHLEVBQUVPLFVBQVVDLFNBQVYsQ0FBb0I5QixLQUFwQixDQUEwQiwyQkFBMUIsS0FBd0QsQ0FBQ3VCLE9BQU9RLEdBQWhFLElBQXFFLENBQUNBLElBQUlDLFFBQTFFLElBQW9GLENBQUNELElBQUlDLFFBQUosQ0FBYSxZQUFiLEVBQTBCLGtCQUExQixDQUF2RixDQUEvQjtBQUFxSyxVQUFPQyxRQUFQLElBQWlCLEtBQUssQ0FBTCxLQUFTVixPQUFPVSxRQUFQLENBQWdCQyxTQUExQyxHQUFvRFIsSUFBRUgsT0FBT1UsUUFBUCxDQUFnQkMsU0FBdEUsR0FBZ0ZYLE9BQU9VLFFBQVAsSUFBaUJOLEVBQUVKLE9BQU9VLFFBQVQsR0FBbUJWLE9BQU9VLFFBQVAsR0FBZ0IsS0FBSyxDQUF6RCxJQUE0RE4sRUFBRUosT0FBT1ksYUFBUCxJQUFzQlosT0FBT1ksYUFBUCxDQUFxQkMsS0FBN0MsQ0FBNUksQ0FBZ00sSUFBSUMsSUFBRVgsQ0FBTixDQUFRLElBQUlZLElBQUUseUhBQU47QUFBQSxNQUFnSUMsSUFBRSxzQ0FBbEk7QUFBQSxNQUF5S0MsS0FBRyxjQUE1SyxDQUEyTCxTQUFTQyxDQUFULENBQVc5RCxDQUFYLEVBQWE7QUFBQyxRQUFHLENBQUNBLENBQUosRUFBTSxPQUFNLEVBQU4sQ0FBUyxhQUFXLE9BQU9BLENBQWxCLEtBQXNCQSxJQUFFRCxFQUFFQyxDQUFGLENBQXhCLEVBQThCLE9BQU80QixFQUFFNUIsQ0FBRixFQUFJMEQsQ0FBSixDQUFQO0FBQWMsWUFBU0ssQ0FBVCxDQUFXL0QsQ0FBWCxFQUFhO0FBQUMsS0FBQ0EsRUFBRWdFLFVBQUgsSUFBZWhFLEVBQUVpRSxXQUFqQixLQUErQmpFLEVBQUVnRSxVQUFGLEdBQWFqRSxFQUFFQyxFQUFFaUUsV0FBSixDQUE1QyxFQUE4RCxPQUFPakUsRUFBRWdFLFVBQUYsSUFBYyxJQUFyQjtBQUEwQixZQUFTRSxDQUFULENBQVdsRSxDQUFYLEVBQWFJLENBQWIsRUFBZUUsQ0FBZixFQUFpQkMsQ0FBakIsRUFBbUI7QUFBQyxRQUFHUCxDQUFILEVBQUs7QUFBQyxVQUFJUyxJQUFFLENBQUMsQ0FBUDtBQUFBLFVBQVNDLElBQUVWLEVBQUVMLElBQWIsQ0FBa0IsSUFBR1ksS0FBR0csTUFBSVUsQ0FBVixFQUFZO0FBQUMsWUFBSVQsSUFBRVgsRUFBRUgsUUFBRixDQUFXd0IsS0FBWCxDQUFpQndDLEVBQWpCLENBQU4sQ0FBMkJsRCxNQUFJaUMsT0FBT3VCLFVBQVAsQ0FBa0J4RCxFQUFFLENBQUYsQ0FBbEIsRUFBd0J5RCxPQUF4QixLQUFrQzNELElBQUUsQ0FBQyxDQUFyQyxDQUFKO0FBQTZDLGFBQUlrQixDQUFKLEdBQU12QixFQUFFSixDQUFGLENBQU4sR0FBV00sS0FBR0ksTUFBSWEsQ0FBUCxHQUFTakIsRUFBRU4sQ0FBRixDQUFULEdBQWNVLE1BQUlnQixDQUFKLEtBQVFqQixJQUFFLENBQUMsQ0FBWCxDQUF6QixDQUF1QyxJQUFHLENBQUNULElBQUVBLEVBQUVYLEtBQUwsS0FBYSxDQUFDb0IsQ0FBakIsRUFBbUI7QUFBQ0EsWUFBRSxDQUFGLENBQUlDLElBQUVWLEVBQUVRLE1BQUosQ0FBVyxLQUFJLElBQUlJLENBQVIsRUFBVUgsSUFBRUMsQ0FBRixLQUFNRSxJQUFFWixFQUFFUyxDQUFGLENBQVIsQ0FBVixFQUF3QkEsR0FBeEI7QUFBNEJ5RCxZQUFFdEQsQ0FBRixFQUFJUixDQUFKLEVBQU1FLENBQU4sRUFBUUMsQ0FBUjtBQUE1QjtBQUF1QztBQUFDO0FBQUM7QUFDL3hELFdBQVM4RCxDQUFULENBQVdyRSxDQUFYLEVBQWFJLENBQWIsRUFBZTtBQUFDLFFBQUlFLElBQUVOLEVBQUVtQixPQUFGLENBQVUsTUFBVixDQUFOLENBQXdCLElBQUcsQ0FBQyxDQUFELEtBQUtiLENBQVIsRUFBVSxPQUFPRixFQUFFSixDQUFGLEVBQUksRUFBSixFQUFPLEVBQVAsRUFBVSxFQUFWLENBQVAsQ0FBcUJBLEdBQUU7QUFBQyxVQUFJTyxJQUFFLENBQU4sQ0FBUSxJQUFJRSxJQUFFSCxJQUFFLENBQVIsQ0FBVSxLQUFJLElBQUlJLElBQUVWLEVBQUVRLE1BQVosRUFBbUJDLElBQUVDLENBQXJCLEVBQXVCRCxHQUF2QjtBQUEyQixZQUFHLFFBQU1ULEVBQUVTLENBQUYsQ0FBVCxFQUFjRixJQUFkLEtBQXVCLElBQUcsUUFBTVAsRUFBRVMsQ0FBRixDQUFOLElBQVksTUFBSSxFQUFFRixDQUFyQixFQUF1QixNQUFNUCxDQUFOO0FBQXpFLE9BQWlGUyxJQUFFLENBQUMsQ0FBSDtBQUFLLFNBQUVULEVBQUVlLFNBQUYsQ0FBWVQsSUFBRSxDQUFkLEVBQWdCRyxDQUFoQixDQUFGLENBQXFCSCxJQUFFTixFQUFFZSxTQUFGLENBQVksQ0FBWixFQUFjVCxDQUFkLENBQUYsQ0FBbUJOLElBQUVxRSxFQUFFckUsRUFBRWUsU0FBRixDQUFZTixJQUFFLENBQWQsQ0FBRixFQUFtQkwsQ0FBbkIsQ0FBRixDQUF3QkssSUFBRUYsRUFBRVksT0FBRixDQUFVLEdBQVYsQ0FBRixDQUFpQixPQUFNLENBQUMsQ0FBRCxLQUFLVixDQUFMLEdBQU9MLEVBQUVFLENBQUYsRUFBSUMsRUFBRS9CLElBQUYsRUFBSixFQUFhLEVBQWIsRUFBZ0J3QixDQUFoQixDQUFQLEdBQTBCSSxFQUFFRSxDQUFGLEVBQUlDLEVBQUVRLFNBQUYsQ0FBWSxDQUFaLEVBQWNOLENBQWQsRUFBaUJqQyxJQUFqQixFQUFKLEVBQTRCK0IsRUFBRVEsU0FBRixDQUFZTixJQUFFLENBQWQsRUFBaUJqQyxJQUFqQixFQUE1QixFQUFvRHdCLENBQXBELENBQWhDO0FBQXVGLElBQUMsSUFBSXNFLEtBQUcsT0FBUDtBQUFBLE1BQWVDLEtBQUcsNkJBQWxCLENBQWdELFNBQVNDLENBQVQsR0FBWTtBQUFDLFNBQUt4RSxDQUFMLEdBQU8sRUFBUDtBQUFVLEtBQUV5RSxTQUFGLENBQVlDLEdBQVosR0FBZ0IsVUFBUzFFLENBQVQsRUFBV0ksQ0FBWCxFQUFhO0FBQUNKLFFBQUVBLEVBQUV4QixJQUFGLEVBQUYsQ0FBVyxLQUFLd0IsQ0FBTCxDQUFPQSxDQUFQLElBQVUsRUFBQ1csR0FBRVAsQ0FBSCxFQUFLdUUsR0FBRSxFQUFQLEVBQVY7QUFBcUIsR0FBOUQsQ0FBK0RILEVBQUVDLFNBQUYsQ0FBWUcsR0FBWixHQUFnQixVQUFTNUUsQ0FBVCxFQUFXO0FBQUNBLFFBQUVBLEVBQUV4QixJQUFGLEVBQUYsQ0FBVyxPQUFPLEtBQUt3QixDQUFMLENBQU9BLENBQVAsS0FBVyxJQUFsQjtBQUF1QixHQUE5RCxDQUErRCxJQUFJNkUsSUFBRSxJQUFOLENBQVcsU0FBU0MsQ0FBVCxHQUFZO0FBQUMsU0FBSzFFLENBQUwsR0FBTyxLQUFLRSxDQUFMLEdBQU8sSUFBZCxDQUFtQixLQUFLTixDQUFMLEdBQU8sSUFBSXdFLENBQUosRUFBUDtBQUFhLEtBQUVDLFNBQUYsQ0FBWU0sQ0FBWixHQUFjLFVBQVMvRSxDQUFULEVBQVc7QUFBQ0EsUUFBRTRELEVBQUVvQixJQUFGLENBQU9oRixDQUFQLEtBQVcyRCxFQUFFcUIsSUFBRixDQUFPaEYsQ0FBUCxDQUFiLENBQXVCNEQsRUFBRXFCLFNBQUYsR0FBWSxDQUFaLENBQWN0QixFQUFFc0IsU0FBRixHQUFZLENBQVosQ0FBYyxPQUFPakYsQ0FBUDtBQUFTLEdBQXRGLENBQXVGOEUsRUFBRUwsU0FBRixDQUFZNUQsQ0FBWixHQUFjLFVBQVNiLENBQVQsRUFBV0ksQ0FBWCxFQUFhO0FBQUNKLFFBQUVBLEVBQUVsQyxPQUFGLENBQVVvSCxhQUFWLENBQXdCLE9BQXhCLENBQUYsQ0FBbUMsSUFBSTVFLElBQUUsSUFBTixDQUFXTixNQUFJTSxJQUFFLEtBQUs2RSxDQUFMLENBQU9uRixDQUFQLEVBQVNJLENBQVQsQ0FBTixFQUFtQixPQUFPRSxDQUFQO0FBQVMsR0FBdEc7QUFDL3FCd0UsSUFBRUwsU0FBRixDQUFZVSxDQUFaLEdBQWMsVUFBU25GLENBQVQsRUFBV0ksQ0FBWCxFQUFhO0FBQUNBLFFBQUUsS0FBSyxDQUFMLEtBQVNBLENBQVQsR0FBVyxFQUFYLEdBQWNBLENBQWhCLENBQWtCLElBQUlFLElBQUV5RCxFQUFFL0QsQ0FBRixDQUFOLENBQVcsS0FBS29GLENBQUwsQ0FBTzlFLENBQVAsRUFBU0YsQ0FBVCxFQUFZSixFQUFFaUUsV0FBRixHQUFjSCxFQUFFeEQsQ0FBRixDQUFkLENBQW1CLE9BQU9BLENBQVA7QUFBUyxHQUFqRyxDQUFrR3dFLEVBQUVMLFNBQUYsQ0FBWS9ELENBQVosR0FBYyxVQUFTVixDQUFULEVBQVc7QUFBQyxRQUFJSSxJQUFFLElBQU47QUFBQSxRQUFXRSxJQUFFeUQsRUFBRS9ELENBQUYsQ0FBYixDQUFrQmtFLEVBQUU1RCxDQUFGLEVBQUksVUFBU04sQ0FBVCxFQUFXO0FBQUMsa0JBQVVBLEVBQUVILFFBQVosS0FBdUJHLEVBQUVILFFBQUYsR0FBVyxNQUFsQyxFQUEwQ08sRUFBRVEsQ0FBRixDQUFJWixDQUFKO0FBQU8sS0FBakUsRUFBbUVBLEVBQUVpRSxXQUFGLEdBQWNILEVBQUV4RCxDQUFGLENBQWQsQ0FBbUIsT0FBT0EsQ0FBUDtBQUFTLEdBQTNJLENBQTRJd0UsRUFBRUwsU0FBRixDQUFZVyxDQUFaLEdBQWMsVUFBU3BGLENBQVQsRUFBV0ksQ0FBWCxFQUFhO0FBQUMsUUFBSUUsSUFBRSxJQUFOLENBQVcsS0FBS0EsQ0FBTCxHQUFPRixDQUFQLENBQVM4RCxFQUFFbEUsQ0FBRixFQUFJLFVBQVNBLENBQVQsRUFBVztBQUFDTSxRQUFFTSxDQUFGLENBQUlaLENBQUo7QUFBTyxLQUF2QixFQUF5QixLQUFLTSxDQUFMLEdBQU8sSUFBUDtBQUFZLEdBQXJGLENBQXNGd0UsRUFBRUwsU0FBRixDQUFZN0QsQ0FBWixHQUFjLFVBQVNaLENBQVQsRUFBVztBQUFDQSxNQUFFUixPQUFGLEdBQVU2RixHQUFHLElBQUgsRUFBUXJGLEVBQUVQLGFBQVYsQ0FBVixDQUFtQyxZQUFVTyxFQUFFSCxRQUFaLEtBQXVCRyxFQUFFSCxRQUFGLEdBQVcsV0FBbEM7QUFBK0MsR0FBNUc7QUFDcFUsV0FBU3dGLEVBQVQsQ0FBWXJGLENBQVosRUFBY0ksQ0FBZCxFQUFnQjtBQUFDQSxRQUFFQSxFQUFFSCxPQUFGLENBQVUwRCxDQUFWLEVBQVksVUFBU3ZELENBQVQsRUFBV0csQ0FBWCxFQUFhRSxDQUFiLEVBQWVDLENBQWYsRUFBaUI7QUFBQyxhQUFPNEUsR0FBR3RGLENBQUgsRUFBS0ksQ0FBTCxFQUFPRyxDQUFQLEVBQVNFLENBQVQsRUFBV0MsQ0FBWCxDQUFQO0FBQXFCLEtBQW5ELENBQUYsQ0FBdUQsT0FBTzZFLEVBQUV2RixDQUFGLEVBQUlJLENBQUosQ0FBUDtBQUFjLFlBQVNtRixDQUFULENBQVd2RixDQUFYLEVBQWFJLENBQWIsRUFBZTtBQUFDLFNBQUksSUFBSUUsQ0FBUixFQUFVQSxJQUFFc0QsRUFBRTRCLElBQUYsQ0FBT3BGLENBQVAsQ0FBWixHQUF1QjtBQUFDLFVBQUlHLElBQUVELEVBQUUsQ0FBRixDQUFOO0FBQUEsVUFBV0csSUFBRUgsRUFBRSxDQUFGLENBQWIsQ0FBa0JBLElBQUVBLEVBQUVtRixLQUFKLENBQVUsSUFBSS9FLElBQUVOLEVBQUVzRixLQUFGLENBQVEsQ0FBUixFQUFVcEYsSUFBRUMsRUFBRVksT0FBRixDQUFVLFFBQVYsQ0FBWixDQUFOLENBQXVDZixJQUFFQSxFQUFFc0YsS0FBRixDQUFRcEYsSUFBRUMsRUFBRUMsTUFBWixDQUFGLENBQXNCLElBQUlHLElBQUVnRixFQUFFM0YsQ0FBRixFQUFJVSxDQUFKLENBQU4sQ0FBYUgsSUFBRSxLQUFLLENBQVAsQ0FBUyxJQUFJSyxJQUFFWixDQUFOLENBQVFTLElBQUVBLEVBQUVSLE9BQUYsQ0FBVXFFLEVBQVYsRUFBYSxFQUFiLENBQUYsQ0FBbUIsSUFBSXpELElBQUUsRUFBTixDQUFTLElBQUl1RSxJQUFFeEUsRUFBRVosQ0FBRixDQUFJNEUsR0FBSixDQUFRbkUsQ0FBUixDQUFOLENBQWlCMkUsTUFBSXhFLEVBQUVaLENBQUYsQ0FBSTBFLEdBQUosQ0FBUWpFLENBQVIsRUFBVSxFQUFWLEdBQWMyRSxJQUFFeEUsRUFBRVosQ0FBRixDQUFJNEUsR0FBSixDQUFRbkUsQ0FBUixDQUFwQixFQUFnQyxJQUFHMkUsQ0FBSCxFQUFLLEtBQUk3RSxDQUFKLElBQVNLLEVBQUVOLENBQUYsS0FBTThFLEVBQUVULENBQUYsQ0FBSS9ELEVBQUVOLENBQU4sSUFBUyxDQUFDLENBQWhCLEdBQW1COEUsRUFBRXpFLENBQTlCO0FBQWdDQyxZQUFFRCxLQUFHQSxFQUFFSixDQUFGLENBQUwsRUFBVTZFLElBQUUsQ0FBQzdFLENBQUQsRUFBRyxRQUFILEVBQVlFLENBQVosRUFBYyxLQUFkLEVBQW9CRixDQUFwQixDQUFaLEVBQW1DSyxLQUFHd0UsRUFBRXRFLElBQUYsQ0FBTyxHQUFQLEVBQVdGLENBQVgsQ0FBdEMsRUFBb0R3RSxFQUFFdEUsSUFBRixDQUFPLEdBQVAsQ0FBcEQsRUFBZ0VELEVBQUVDLElBQUYsQ0FBT3NFLEVBQUVRLElBQUYsQ0FBTyxFQUFQLENBQVAsQ0FBaEU7QUFBaEMsT0FBbUhyRixJQUFFTSxFQUFFK0UsSUFBRixDQUFPLElBQVAsQ0FBRixDQUFleEYsSUFBRSxLQUFHTSxDQUFILEdBQUtILENBQUwsR0FBT0gsQ0FBVCxDQUFXd0QsRUFBRXFCLFNBQUYsR0FBWTNFLElBQUVDLEVBQUVDLE1BQWhCO0FBQXVCLFlBQU9KLENBQVA7QUFBUztBQUNwZixXQUFTdUYsQ0FBVCxDQUFXM0YsQ0FBWCxFQUFhSSxDQUFiLEVBQWU7QUFBQ0EsUUFBRUEsRUFBRW9CLEtBQUYsQ0FBUSxHQUFSLENBQUYsQ0FBZSxLQUFJLElBQUlsQixDQUFKLEVBQU1DLENBQU4sRUFBUUUsSUFBRSxFQUFWLEVBQWFDLElBQUUsQ0FBZixFQUFpQkMsQ0FBckIsRUFBdUJELElBQUVOLEVBQUVJLE1BQTNCLEVBQWtDRSxHQUFsQztBQUFzQyxVQUFHSixJQUFFRixFQUFFTSxDQUFGLENBQUwsRUFBVSxJQUFHQyxJQUFFTCxFQUFFa0IsS0FBRixDQUFRLEdBQVIsQ0FBRixFQUFlLElBQUViLEVBQUVILE1BQXRCLEVBQTZCO0FBQUNGLFlBQUVLLEVBQUUsQ0FBRixFQUFLbkMsSUFBTCxFQUFGLENBQWMsSUFBSW9DLElBQUVaLENBQU4sQ0FBUU8sSUFBRUQsQ0FBRixDQUFJSyxJQUFFQSxFQUFFK0UsS0FBRixDQUFRLENBQVIsRUFBV0UsSUFBWCxDQUFnQixHQUFoQixDQUFGLENBQXVCLElBQUkvRSxJQUFFMEQsR0FBR2lCLElBQUgsQ0FBUTdFLENBQVIsQ0FBTixDQUFpQkUsTUFBSUEsRUFBRSxDQUFGLEtBQU1ELEVBQUVSLENBQUYsS0FBTVEsRUFBRVIsQ0FBRixHQUFJcEMsU0FBU0MsYUFBVCxDQUF1QixNQUF2QixDQUFKLEVBQW1DMkMsRUFBRVIsQ0FBRixDQUFJeUYsWUFBSixDQUFpQixvQkFBakIsRUFBc0MsRUFBdEMsQ0FBbkMsRUFBNkVqRixFQUFFUixDQUFGLENBQUkwRixLQUFKLENBQVVDLEdBQVYsR0FBYyxTQUEzRixFQUFxRy9ILFNBQVNnSSxJQUFULENBQWMzSCxXQUFkLENBQTBCdUMsRUFBRVIsQ0FBNUIsQ0FBM0csR0FBMklHLElBQUVxQyxPQUFPcUQsZ0JBQVAsQ0FBd0JyRixFQUFFUixDQUExQixFQUE2QjhGLGdCQUE3QixDQUE4QzNGLENBQTlDLENBQW5KLElBQXFNQSxJQUFFLG9CQUF2TSxFQUE0TkksSUFBRUosQ0FBbE8sRUFBcU9BLElBQUVJLENBQUYsQ0FBSUYsRUFBRUgsQ0FBRixJQUFLQyxDQUFMO0FBQU87QUFBaFksS0FBZ1ksT0FBT0UsQ0FBUDtBQUFTLFlBQVMwRixFQUFULENBQVluRyxDQUFaLEVBQWNJLENBQWQsRUFBZ0I7QUFBQyxRQUFHeUUsQ0FBSCxFQUFLLEtBQUksSUFBSXZFLENBQVIsSUFBYUYsRUFBRXVFLENBQWY7QUFBaUJyRSxZQUFJTixFQUFFTSxDQUFOLElBQVN1RSxFQUFFdkUsQ0FBRixDQUFUO0FBQWpCO0FBQStCO0FBQzdkLFdBQVNnRixFQUFULENBQVl0RixDQUFaLEVBQWNJLENBQWQsRUFBZ0JFLENBQWhCLEVBQWtCQyxDQUFsQixFQUFvQkUsQ0FBcEIsRUFBc0I7QUFBQ0YsU0FBRzhELEVBQUU5RCxDQUFGLEVBQUksVUFBU0gsQ0FBVCxFQUFXRSxDQUFYLEVBQWE7QUFBQ0EsV0FBR04sRUFBRUEsQ0FBRixDQUFJNEUsR0FBSixDQUFRdEUsQ0FBUixDQUFILEtBQWdCRyxJQUFFLFlBQVVILENBQVYsR0FBWSxHQUE5QjtBQUFtQyxLQUFyRCxDQUFILENBQTBELElBQUcsQ0FBQ0csQ0FBSixFQUFNLE9BQU9MLENBQVAsQ0FBUyxJQUFJTSxJQUFFNkUsRUFBRXZGLENBQUYsRUFBSVMsQ0FBSixDQUFOO0FBQUEsUUFBYUUsSUFBRVAsRUFBRXNGLEtBQUYsQ0FBUSxDQUFSLEVBQVV0RixFQUFFZSxPQUFGLENBQVUsSUFBVixDQUFWLENBQWY7QUFBQSxRQUEwQ1AsSUFBRUYsSUFBRWlGLEVBQUUzRixDQUFGLEVBQUlVLENBQUosQ0FBOUM7QUFBQSxRQUFxREcsSUFBRWIsRUFBRUEsQ0FBRixDQUFJNEUsR0FBSixDQUFRdEUsQ0FBUixDQUF2RDtBQUFBLFFBQWtFOEUsSUFBRXZFLEtBQUdBLEVBQUVGLENBQXpFLENBQTJFeUUsSUFBRXhFLElBQUV3RixPQUFPQyxNQUFQLENBQWNELE9BQU9FLE1BQVAsQ0FBY2xCLENBQWQsQ0FBZCxFQUErQjFFLENBQS9CLENBQUosR0FBc0NWLEVBQUVBLENBQUYsQ0FBSTBFLEdBQUosQ0FBUXBFLENBQVIsRUFBVU0sQ0FBVixDQUF0QyxDQUFtRCxJQUFJMkYsSUFBRSxFQUFOO0FBQUEsUUFBU0MsQ0FBVDtBQUFBLFFBQVdDLElBQUUsQ0FBQyxDQUFkLENBQWdCLEtBQUlELENBQUosSUFBUzVGLENBQVQsRUFBVztBQUFDLFVBQUk4RixJQUFFaEcsRUFBRThGLENBQUYsQ0FBTixDQUFXLEtBQUssQ0FBTCxLQUFTRSxDQUFULEtBQWFBLElBQUUsU0FBZixFQUEwQixDQUFDdEIsQ0FBRCxJQUFJb0IsS0FBS3BCLENBQVQsS0FBYXFCLElBQUUsQ0FBQyxDQUFoQixFQUFtQkYsRUFBRXpGLElBQUYsQ0FBTyxLQUFHUixDQUFILEdBQUssS0FBTCxHQUFXa0csQ0FBWCxHQUFhLElBQWIsR0FBa0JFLENBQXpCO0FBQTRCLFVBQUdQLEdBQUduRyxDQUFILEVBQUthLENBQUwsQ0FBSCxDQUFXQSxNQUFJQSxFQUFFRixDQUFGLEdBQUlDLENBQVIsRUFBV0wsTUFBSUksSUFBRVAsSUFBRSxHQUFGLEdBQU1PLENBQVosRUFBZSxPQUFNLEtBQUdBLENBQUgsR0FBSzRGLEVBQUVYLElBQUYsQ0FBTyxJQUFQLENBQUwsR0FBa0IsR0FBeEI7QUFBNEIsS0FBRW5CLFNBQUYsQ0FBWWtDLFdBQVosR0FBd0I3QixFQUFFTCxTQUFGLENBQVlNLENBQXBDLENBQXNDRCxFQUFFTCxTQUFGLENBQVltQyxjQUFaLEdBQTJCOUIsRUFBRUwsU0FBRixDQUFZVSxDQUF2QztBQUNyYkwsSUFBRUwsU0FBRixDQUFZb0Msb0JBQVosR0FBaUMvQixFQUFFTCxTQUFGLENBQVkvRCxDQUE3QyxDQUErQ29FLEVBQUVMLFNBQUYsQ0FBWXFDLGNBQVosR0FBMkJoQyxFQUFFTCxTQUFGLENBQVlXLENBQXZDLENBQXlDTixFQUFFTCxTQUFGLENBQVlzQyxhQUFaLEdBQTBCakMsRUFBRUwsU0FBRixDQUFZN0QsQ0FBdEMsQ0FBd0NrRSxFQUFFTCxTQUFGLENBQVl1QyxpQkFBWixHQUE4QmxDLEVBQUVMLFNBQUYsQ0FBWTVELENBQTFDLENBQTRDaUUsRUFBRUwsU0FBRixDQUFZd0MsVUFBWixHQUF1QixLQUF2QixDQUE2QmIsT0FBT2MsY0FBUCxDQUFzQnBDLEVBQUVMLFNBQXhCLEVBQWtDLGlCQUFsQyxFQUFvRCxFQUFDRyxLQUFJLGVBQVU7QUFBQyxhQUFPQyxDQUFQO0FBQVMsS0FBekIsRUFBMEJILEtBQUksYUFBUzFFLENBQVQsRUFBVztBQUFDNkUsVUFBRTdFLENBQUY7QUFBSSxLQUE5QyxFQUFwRCxFQUFxRyxJQUFJbUgsSUFBRSxJQUFOO0FBQUEsTUFBV0MsSUFBRXhFLE9BQU95RSxXQUFQLElBQW9CekUsT0FBT3lFLFdBQVAsQ0FBbUJDLFNBQXZDLElBQWtELElBQS9EO0FBQUEsTUFBb0VDLENBQXBFLENBQXNFLFNBQVNDLEVBQVQsQ0FBWXhILENBQVosRUFBYztBQUFDeUgsMEJBQXNCLFlBQVU7QUFBQ0wsVUFBRUEsRUFBRXBILENBQUYsQ0FBRixJQUFRbUgsTUFBSUEsSUFBRSxJQUFJakYsT0FBSixDQUFZLFVBQVNsQyxDQUFULEVBQVc7QUFBQ3VILFlBQUV2SCxDQUFGO0FBQUksT0FBNUIsQ0FBRixFQUFnQyxlQUFhaEMsU0FBUzBKLFVBQXRCLEdBQWlDSCxHQUFqQyxHQUFxQ3ZKLFNBQVNZLGdCQUFULENBQTBCLGtCQUExQixFQUE2QyxZQUFVO0FBQUMsdUJBQWFaLFNBQVMwSixVQUF0QixJQUFrQ0gsR0FBbEM7QUFBc0MsT0FBOUYsQ0FBekUsR0FBMEtKLEVBQUV6RSxJQUFGLENBQU8sWUFBVTtBQUFDMUMsYUFBR0EsR0FBSDtBQUFPLE9BQXpCLENBQWxMO0FBQThNLEtBQS9PO0FBQWlQLElBQUMsSUFBSTJILElBQUUsSUFBSTdDLENBQUosRUFBTixDQUFZLFNBQVM4QyxDQUFULEdBQVk7QUFBQyxRQUFJNUgsSUFBRSxJQUFOLENBQVcsS0FBS0EsQ0FBTCxHQUFPLElBQVAsQ0FBWXdILEdBQUcsWUFBVTtBQUFDSyxRQUFFN0gsQ0FBRjtBQUFLLEtBQW5CLEVBQXFCMkgsRUFBRUcsZUFBRixHQUFrQjFGLEVBQWxCO0FBQXFCLFlBQVN5RixDQUFULENBQVc3SCxDQUFYLEVBQWE7QUFBQ0EsTUFBRUEsQ0FBRixLQUFNQSxFQUFFQSxDQUFGLEdBQUk0QyxPQUFPVSxRQUFQLENBQWdCeUUsb0JBQXBCLEVBQXlDL0gsRUFBRUEsQ0FBRixLQUFNQSxFQUFFQSxDQUFGLENBQUlnSSxpQkFBSixHQUFzQixVQUFTaEksQ0FBVCxFQUFXO0FBQUMySCxRQUFFakgsQ0FBRixDQUFJVixDQUFKO0FBQU8sS0FBekMsRUFBMENBLEVBQUVBLENBQUYsQ0FBSWlJLGdCQUFKLEdBQXFCLFlBQVU7QUFBQ1IsNEJBQXNCLFlBQVU7QUFBQ3pILFVBQUVBLENBQUYsQ0FBSWtJLFFBQUosSUFBY0MsRUFBRW5JLENBQUYsQ0FBZDtBQUFtQixPQUFwRDtBQUFzRCxLQUF0SSxDQUEvQztBQUF3TCxLQUFFeUUsU0FBRixDQUFZMkQsZUFBWixHQUE0QixVQUFTcEksQ0FBVCxFQUFXSSxDQUFYLEVBQWE7QUFBQ3lILE1BQUUsSUFBRixFQUFRNUksRUFBRW1CLENBQUYsSUFBS0osQ0FBTCxDQUFPSSxJQUFFdUgsRUFBRTlHLENBQUYsQ0FBSWIsQ0FBSixFQUFNSSxDQUFOLENBQUYsQ0FBV0osRUFBRXFJLFNBQUYsR0FBWWpJLENBQVo7QUFBYyxHQUFsRjtBQUNyNUIsV0FBUytILENBQVQsQ0FBV25JLENBQVgsRUFBYTtBQUFDNkgsTUFBRTdILENBQUYsRUFBSyxJQUFHQSxFQUFFQSxDQUFMLEVBQU87QUFBQyxVQUFJSSxJQUFFSixFQUFFQSxDQUFGLENBQUlzSSxhQUFKLEVBQU4sQ0FBMEIsSUFBR3RJLEVBQUVBLENBQUYsQ0FBSWtJLFFBQVAsRUFBZ0I7QUFBQyxhQUFJLElBQUk1SCxJQUFFLENBQVYsRUFBWUEsSUFBRUYsRUFBRUksTUFBaEIsRUFBdUJGLEdBQXZCLEVBQTJCO0FBQUMsY0FBSUMsSUFBRVAsRUFBRUEsQ0FBRixDQUFJdUksc0JBQUosQ0FBMkJuSSxFQUFFRSxDQUFGLENBQTNCLENBQU4sQ0FBdUNDLEtBQUdvSCxFQUFFakgsQ0FBRixDQUFJSCxDQUFKLENBQUg7QUFBVSxXQUFFUCxDQUFGLENBQUlrSSxRQUFKLEdBQWEsQ0FBQyxDQUFkO0FBQWdCO0FBQUM7QUFBQyxLQUFFekQsU0FBRixDQUFZK0QsWUFBWixHQUF5QixVQUFTeEksQ0FBVCxFQUFXSSxDQUFYLEVBQWE7QUFBQ3lILE1BQUUsSUFBRixFQUFRLElBQUd6SCxDQUFILEVBQUssS0FBSSxJQUFJRSxDQUFSLElBQWFGLENBQWI7QUFBZSxlQUFPRSxDQUFQLEdBQVNOLEVBQUU4RixLQUFGLENBQVEyQyxjQUFSLENBQXVCbkksQ0FBdkIsQ0FBVCxHQUFtQ04sRUFBRThGLEtBQUYsQ0FBUTRDLFdBQVIsQ0FBb0JwSSxDQUFwQixFQUFzQkYsRUFBRUUsQ0FBRixDQUF0QixDQUFuQztBQUFmLEtBQThFLElBQUdOLEVBQUUySSxVQUFMLEVBQWdCLEtBQUksS0FBS0MsWUFBTCxDQUFrQjVJLENBQWxCLEdBQXFCQSxJQUFFQSxFQUFFMkksVUFBRixDQUFhRSxRQUFiLElBQXVCN0ksRUFBRTJJLFVBQUYsQ0FBYUcsVUFBM0QsRUFBc0UxSSxJQUFFLENBQTVFLEVBQThFQSxJQUFFSixFQUFFUSxNQUFsRixFQUF5RkosR0FBekY7QUFBNkYsV0FBS29JLFlBQUwsQ0FBa0J4SSxFQUFFSSxDQUFGLENBQWxCO0FBQTdGLEtBQWhCLE1BQTBJLEtBQUlKLElBQUVBLEVBQUU2SSxRQUFGLElBQVk3SSxFQUFFOEksVUFBaEIsRUFBMkIxSSxJQUFFLENBQWpDLEVBQW1DQSxJQUFFSixFQUFFUSxNQUF2QyxFQUE4Q0osR0FBOUM7QUFBa0QsV0FBS29JLFlBQUwsQ0FBa0J4SSxFQUFFSSxDQUFGLENBQWxCO0FBQWxEO0FBQTBFLEdBQXRWO0FBQ3JLd0gsSUFBRW5ELFNBQUYsQ0FBWW1FLFlBQVosR0FBeUIsVUFBUzVJLENBQVQsRUFBVztBQUFDNkgsTUFBRSxJQUFGLEVBQVEsSUFBSXpILElBQUVKLEVBQUUrSSxTQUFSO0FBQUEsUUFBa0J6SSxDQUFsQixDQUFvQkYsSUFBRSxDQUFDLENBQUQsR0FBR0EsRUFBRWUsT0FBRixDQUFVLEdBQVYsQ0FBSCxHQUFrQmIsSUFBRUYsQ0FBcEIsR0FBc0JFLElBQUVOLEVBQUVnSixZQUFGLElBQWdCaEosRUFBRWdKLFlBQUYsQ0FBZSxJQUFmLENBQWhCLElBQXNDLEVBQWhFLEdBQW1FMUksSUFBRU4sRUFBRWlKLEVBQXZFLENBQTBFLElBQUcsQ0FBQzdJLElBQUVuQixFQUFFcUIsQ0FBRixDQUFILEtBQVUsQ0FBQ2tDLEVBQUVwQyxDQUFGLENBQWQsRUFBbUI7QUFBQyxVQUFHb0MsRUFBRXBDLENBQUYsS0FBTUEsRUFBRWtDLDJCQUFGLEtBQWdDbEMsRUFBRW1DLHFCQUEzQyxFQUFpRSxLQUFLNkYsZUFBTCxDQUFxQmhJLENBQXJCLEVBQXVCRSxDQUF2QixHQUEwQm1DLEdBQUdyQyxDQUFILENBQTFCLENBQWdDLElBQUdKLElBQUVBLEVBQUUySSxVQUFQLEVBQWtCLElBQUczSSxJQUFFQSxFQUFFa0YsYUFBRixDQUFnQixPQUFoQixDQUFMLEVBQThCbEYsRUFBRWdFLFVBQUYsR0FBYTVELEVBQUVpSSxTQUFmLEVBQXlCckksRUFBRWlFLFdBQUYsR0FBY0gsRUFBRTFELEVBQUVpSSxTQUFKLENBQXZDO0FBQXNEO0FBQUMsR0FBdlcsQ0FBd1dULEVBQUVuRCxTQUFGLENBQVl5RSxhQUFaLEdBQTBCLFVBQVNsSixDQUFULEVBQVc7QUFBQzZILE1BQUUsSUFBRixFQUFRLEtBQUtXLFlBQUwsQ0FBa0J4SyxTQUFTVSxJQUEzQixFQUFnQ3NCLENBQWhDO0FBQW1DLEdBQWpGO0FBQ3hXLE1BQUcsQ0FBQzRDLE9BQU9VLFFBQVIsSUFBa0IsQ0FBQ1YsT0FBT1UsUUFBUCxDQUFnQjZGLFdBQXRDLEVBQWtEO0FBQUMsUUFBSUMsSUFBRSxJQUFJeEIsQ0FBSixFQUFOO0FBQUEsUUFBWXlCLEtBQUd6RyxPQUFPVSxRQUFQLElBQWlCVixPQUFPVSxRQUFQLENBQWdCeUUsb0JBQWhELENBQXFFbkYsT0FBT1UsUUFBUCxHQUFnQixFQUFDOEUsaUJBQWdCLHlCQUFTcEksQ0FBVCxFQUFXSSxDQUFYLEVBQWE7QUFBQytILFVBQUVpQixDQUFGLEVBQUtBLEVBQUVoQixlQUFGLENBQWtCcEksQ0FBbEIsRUFBb0JJLENBQXBCO0FBQXVCLE9BQTNELEVBQTREb0ksY0FBYSxzQkFBU3hJLENBQVQsRUFBV0ksQ0FBWCxFQUFhO0FBQUMrSCxVQUFFaUIsQ0FBRixFQUFLQSxFQUFFWixZQUFGLENBQWV4SSxDQUFmLEVBQWlCSSxDQUFqQjtBQUFvQixPQUFoSCxFQUFpSHdJLGNBQWEsc0JBQVM1SSxDQUFULEVBQVc7QUFBQ21JLFVBQUVpQixDQUFGLEVBQUtBLEVBQUVSLFlBQUYsQ0FBZTVJLENBQWY7QUFBa0IsT0FBakssRUFBa0trSixlQUFjLHVCQUFTbEosQ0FBVCxFQUFXO0FBQUNtSSxVQUFFaUIsQ0FBRixFQUFLQSxFQUFFRixhQUFGLENBQWdCbEosQ0FBaEI7QUFBbUIsT0FBcE4sRUFBcU5zSix1QkFBc0IsK0JBQVN0SixDQUFULEVBQVdJLENBQVgsRUFBYTtBQUFDLGVBQU0sQ0FBQ0osSUFBRTRDLE9BQU9xRCxnQkFBUCxDQUF3QmpHLENBQXhCLEVBQTJCa0csZ0JBQTNCLENBQTRDOUYsQ0FBNUMsQ0FBSCxJQUFtREosRUFBRXhCLElBQUYsRUFBbkQsR0FBNEQsRUFBbEU7QUFBcUUsT0FBOVQsRUFBK1QrRSxXQUFVRyxDQUF6VSxFQUEyVTZGLGNBQWE1RyxDQUF4VixFQUFoQixDQUEyVzBHLE9BQUt6RyxPQUFPVSxRQUFQLENBQWdCeUUsb0JBQWhCLEdBQ3hlc0IsRUFEbWU7QUFDL2QsVUFBTy9GLFFBQVAsQ0FBZ0JrRyxTQUFoQixHQUEwQjdCLENBQTFCO0FBQTZCLENBeEJqQyxFQXdCbUM4QixJQXhCbkM7O0FBMEJBLDBDOzs7Ozs7Ozs7Ozs7Ozs7QUNaQSxDQUFVLFlBQUU7O0FBRUU7Ozs7QUFHWixNQUFrQixnQkFBRSxPQUFlLFNBQUssS0FBTSxNQUFhLGdCQUFZO0FBQ3ZFLE1BQWdCLGNBQXFCO0FBQ3JDLE1BQWdCLGNBQTRCO0FBQzVDLE1BQWlCLGVBQWdDOztBQUVqRCxNQUFpQixlQUFJO0FBQ3JCLE1BQW1CLGlCQUFHOztBQUV0QixNQUFpQixlQUFHOzs7QUFHcEIsTUFBa0IsZ0JBQU07QUFDeEIsTUFBaUIsZUFBRSxDQUFZLGFBQWEsYUFBVyxXQUFVOztBQUVqRSxNQUEyQix5QkFBRSxDQUFFLEdBQUcsR0FBRyxHQUFJO0FBQ3pDLE1BQXNCLG9CQUFZLFlBQUU7QUFDbEMsUUFBSTtBQUNGLGFBQU8sSUFBYyxXQUFPLFFBQUUsRUFBUSxTQUFLLEtBQVMsWUFDdEQ7TUFBUSxPQUFFLEdBQUU7QUFDVixhQUNGO0FBQ0Y7QUFBSSxHQU5vQjs7OztBQVV4QixNQUFxQixtQkFBTztBQUM1QixHQUFVLFlBQUU7QUFDVixRQUFJO0FBQ0YsVUFBUyxjQUF1QixlQUFHLElBQVcsYUFBTSxLQUFXLGVBQUU7QUFBa0IsNkJBQU87QUFBRSxTQUE1QyxFQUEvQjtBQUNYLGFBQWlCLGlCQUFPLFFBQU0sTUFBTztBQUNyQyxhQUFvQixvQkFBTyxRQUFNLE1BQ3pDO01BQU8sT0FBRSxHQUFHLENBQ2Q7QUFBSTs7O0FBR0osTUFBa0IsZ0JBQVcsVUFBVSxVQUFNLE1BQTRCOztBQUV6RSxNQUFzQixvQkFBVyw2QkFBRSxDQUFDO0FBQ25CLG9CQUFVLFVBQU8sUUFBVyxZQUFFLENBQUM7O0FBRS9CLG9CQUFVLFVBQVU7O0FBRXBCLG9CQUFVLFVBQVU7O0FBRXBCLG9CQUFVLFVBQVE7O0FBRWxCLG9CQUFVLFVBQVc7O0FBRXJCLG9CQUFVLFVBQVU7O0FBRXBCLG9CQUFVLFVBQVM7O0FBRW5CLG9CQUFVLFVBQU07Ozs7Ozs7QUFPakMsTUFBbUIsaUJBQVUsd0JBQVcsWUFBRTs7Ozs7QUFLeEMsUUFBTyxLQUFZLFdBQW1CO0FBQ25DLFFBQUksTUFBRyxDQUFHLEdBQWlCLGtCQUFFO0FBRWhDOzs7QUFFVSxlQUFjLGVBQUUsRUFBSyxNQUFPOztBQUVuQyxRQUFXLFdBQU0sU0FBVyxTQUFFO0FBQy9CLFVBQVMsT0FBWSxXQUFjLGdCQUFhLFdBQWU7QUFDNUQsVUFBSyxNQUFFO0FBQ0osYUFBQyxJQUFNLElBQUcsR0FBSSxJQUFNLEtBQU8sUUFBSyxLQUFFO0FBQ2pDLGNBQUssS0FBSSxPQUFnQixhQUFNLE1BQU8sUUFBRTtBQUUzQztBQUNGO0FBQ0Y7O0FBQ1UsaUJBQWlCO0FBQ2pCLGlCQUNaO0FBQ0Y7QUFBQzs7Ozs7QUFLRCxXQUFvQyw0QkFBTSxPQUFFO0FBQzFDLFFBQVcsU0FBZ0IsZ0JBQUUsQ0FBVSxXQUFjO0FBQ2pELFNBQUMsSUFBTSxJQUFHLEdBQUksSUFBSSxJQUFRLE9BQU8sUUFBSyxLQUFFO0FBQ3ZDLFdBQVEsT0FBRztBQUNYLFVBQU0sT0FBRTtBQUNELGlCQUFpQixpQkFBRyxJQUFnQixnQkFDOUM7QUFBRSxhQUFLO0FBQ0csaUJBQW9CLG9CQUFHLElBQWdCLGdCQUNqRDtBQUNGO0FBQ0Y7OztBQUVBLFdBQW9CLFlBQUUsR0FBRTtBQUNuQixRQUFDLENBQWEsYUFBTSxNQUFlLGdCQUFFO0FBQ1gsa0NBQzdCOztBQUNBLFFBQVUsUUFBVyxpQkFBRTtBQUNRO0FBQ2pCLG1CQUFNLE1BQVEsU0FBTTtBQUNwQixtQkFBTSxNQUFnQixpQkFDcEM7QUFBQztBQUNXLGlCQUFNLE1BQVEsU0FBRyxFQUFlLGVBQUc7QUFDbkMsaUJBQU0sTUFBZ0IsaUJBQVMsUUFBVSxVQUFTLFNBQzVDLGFBQU0sTUFDcEIsZ0JBQVMsUUFBTSxNQUFRLFFBQU0sTUFDN0IsZ0JBQ047Ozs7Ozs7QUFNQSxXQUEyQixtQkFBRyxJQUFFO0FBQzlCLFFBQVMsT0FBSSxHQUFLOztBQUVmLFFBQWEsYUFBUSxRQUFPLFVBQUksQ0FBRSxHQUFFO0FBQ3JDLGFBQ0Y7Ozs7QUFHRyxRQUFNLFNBQWUsYUFBRTs7QUFFeEIsVUFBWSxVQUFJLEdBQVMsWUFBYyxZQUFJLElBQUksR0FBUTtBQUNwRCxVQUFLLGNBQWlCLE9BQWEsVUFBbEMsSUFBcUMsQ0FBa0IsbUJBQUU7QUFDbkQsa0JBQXdCLHVCQUFHLEdBQVEsVUFDN0M7OztBQUVBLGFBQWMsUUFBUyxVQUN6QjtBQUFFLFdBQUs7O0FBRUwsVUFBVyxTQUFJLEdBQVEsV0FBYyxZQUFJLElBQUksR0FBTzs7QUFFcEQsYUFBYyxXQUNoQjtBQUNGOzs7QUFFQSxXQUF5QixpQkFBRyxJQUFFO0FBQ3pCLFFBQUcsR0FBTSxTQUFXLFNBQUU7O0FBRXBCLFVBQUcsR0FBUSxXQUFLLEdBQUU7QUFDbkIsZUFDRjs7Ozs7QUFJQSxVQUFNLElBQVUsU0FBb0Isb0JBQUk7OztBQUdyQyxVQUFDLENBQUUsRUFBVSxrQ0FBNEIsQ0FBSCxDQUFhLGFBQVEsS0FBYSxjQUFFO0FBQzNFLGVBQ0Y7O0FBQ0EsVUFBUSw0QkFBMkIsQ0FBSCxDQUEyQjs7QUFFM0QsVUFBTSxJQUFJLEdBQU07VUFBSSxJQUFJLEdBQU07O0FBRTlCLGFBQVEsRUFBSSxLQUFNLElBQU0sUUFBSyxLQUFNLElBQVcsS0FBckMsSUFBd0MsS0FBTSxJQUFLLE9BQUssS0FBTSxJQUN6RTs7QUFDQSxXQUNGOzs7QUFFQSxNQUFpQjtBQUNWO0FBQ0csY0FBTTtBQUNFLHNCQUNmO0FBSE07QUFJRjtBQUNGLFNBQUc7QUFDSCxTQUFHO0FBQ0YsVUFBRSxDQUFFO0FBQ08scUJBRWhCO0FBTlE7QUFMVTs7QUFhbkIsV0FBeUIsaUJBQUcsSUFBRTtBQUM1QixRQUFPLEtBQVE7QUFDZixRQUFTLE9BQUksR0FBYyxnQkFBSyxHQUFlO0FBQzVDLFFBQUssTUFBRTtBQUNKLFdBQUMsSUFBTSxJQUFHLEdBQUcsR0FBSSxJQUFNLEtBQU8sUUFBSyxLQUFFO0FBQ3JDLFlBQU0sS0FBRztBQUNSLFlBQUUsRUFBYyxlQUFFO0FBQ2hCLGVBQUcsRUFBYztBQUV0QjtBQUNGO0FBQ0Y7O0FBQ0EsV0FDRjs7O0FBRUEsV0FBc0IsY0FBUyxVQUFRLFFBQU0sTUFBRTtBQUNyQyxhQUFRLFNBQVE7QUFDaEIsYUFBTSxPQUFNO0FBQ1osYUFBaUIsaUJBQVksYUFBUztBQUN0QyxhQUFpQixpQkFBVSxXQUNyQzs7O0FBRUEsV0FBd0IsZ0JBQVMsVUFBRTtBQUN6QixhQUFvQixvQkFBWSxhQUFVLFNBQVE7QUFDbEQsYUFBb0Isb0JBQVUsV0FBVSxTQUFNO0FBQzlDLGFBQVEsU0FBTTtBQUNkLGFBQU0sT0FDaEI7Ozs7O0FBSVEsV0FBaUIsaUJBQVcsWUFBYSxhQUFtQixtQkFBRSxFQUFRLFNBQVEsU0FBUTs7Ozs7Ozs7Ozs7Ozs7QUFjOUYsTUFBZTtBQUNMLGNBQUk7QUFDRCxpQkFBSTs7Ozs7Ozs7Ozs7Ozs7QUFjRCxvQkFBVSx3QkFBRSxHQUFHLEdBQUU7QUFDN0IsVUFBUyxPQUFVLFNBQWlCLGlCQUFFLEdBQUk7QUFDMUMsVUFBUyxPQUFNOzs7O0FBSVQsYUFBTSxRQUFPLEtBQVksY0FBRyxDQUFPLE9BQVMsVUFBRTs7QUFFbEQsWUFBWSxVQUFNO0FBQ2IsZUFBTSxLQUFXLFdBQWlCLGlCQUFFLEdBQUk7O0FBRTFDLFlBQVMsWUFBUSxNQUFFO0FBRXRCOztBQUNHLFlBQUssTUFBRTtBQUNILGlCQUNQO0FBQ0Y7O0FBQ0EsYUFDRjtBQUFDOzs7Ozs7OztBQVFrQix5QkFBVSw2QkFBRyxJQUFFOztBQUU3QixVQUFHLEdBQWEsY0FBRTtBQUNuQixlQUFpQywyQkFBRyxHQUFlLGVBQ3JEOzs7O0FBRUEsYUFBUyxHQUNYO0FBQUM7Ozs7OztBQU1ZLG1CQUFVLHVCQUFHLElBQUU7QUFDMUIsVUFBVztBQUNYLFVBQVMsT0FBSSxHQUFLO0FBQ2xCLFVBQVMsT0FBSSxHQUFjO0FBQzNCLFVBQVMsT0FBTSxLQUFhO0FBQ3pCLFVBQUMsQ0FBSyxNQUFFO0FBRVg7O0FBQ0EsVUFBTyxLQUFNLEtBQU07QUFDaEIsVUFBQyxDQUFHLElBQUU7QUFFVDs7QUFDRyxVQUFDLENBQUcsR0FBYSxjQUFFO0FBQ2xCLFdBQWMsZUFBSTtBQUNqQixZQUFLLEtBQU0sTUFBRSxHQUFLLE9BQVcsU0FBRTtBQUM3QixlQUEyQix5QkFBSTtBQUNsQyxjQUFNLElBQUksR0FBZSxlQUFHO0FBQ3pCLGNBQU0sU0FBZ0IsY0FBRTs7QUFFdEIsZ0JBQUcsR0FBUSxRQUFRLFdBQUssR0FBRTtBQUNmLDJCQUFNLE1BQUksS0FBRyxFQUMzQjtBQUNGOztBQUNHLGNBQWEsYUFBTSxNQUFJLE9BQUssRUFBVyxZQUFFO0FBRTVDOztBQUNHLGNBQUMsQ0FBYyxlQUFFO0FBQ2YsZ0JBQU0sU0FBaUIsZ0JBQVEsU0FBZSxhQUFFO0FBQ3pDLHVCQUFtQixtQkFDN0I7QUFDRjtBQUNGO0FBQ0Y7O0FBQ1EsZ0JBQUksR0FBYTs7QUFFdEIsVUFBUSxRQUFLLE1BQUU7QUFFbEI7O0FBQ0EsVUFBZ0IsY0FBVSxTQUFZOztBQUVsQyxXQUFDLElBQU0sSUFBRyxHQUFHLEdBQUksSUFBYSxZQUFPLFFBQUssS0FBRTtBQUM1QyxZQUFhLFlBQUc7QUFDZixZQUFHLEdBQUUsRUFBTyxTQUFHLENBQVEsUUFBRSxFQUFNLE9BQUU7QUFDL0IsY0FBRSxFQUFNLFFBQUksRUFBSyxLQUFNLE1BQVEsUUFBRyxHQUFPLFFBQUUsQ0FBRyxLQUFJLEVBQU0sT0FBRTtBQUMxRCxjQUNIO0FBQ0Y7QUFDRjs7O0FBRUksV0FBQyxJQUFNLEtBQUcsR0FBRyxJQUFJLEtBQWEsWUFBTyxRQUFLLE1BQUU7QUFDNUMsYUFBYSxZQUFHO0FBQ2YsWUFBRyxHQUFFLEdBQU8sU0FBRyxDQUFRLFFBQUUsR0FBTSxPQUFFO0FBQzNCLGtCQUFFLEdBQU8sUUFBTTtBQUNyQixhQUFNLE1BQ1Q7QUFDRjtBQUNGO0FBQUM7Ozs7OztBQU1pQix3QkFBVSw0QkFBRyxJQUFFO0FBQy9CLFVBQU0sSUFBSSxHQUFlLGVBQUc7QUFDNUIsVUFBUyxPQUFJLEdBQUs7QUFDZixVQUFNLFNBQWdCLGNBQUU7QUFDYixxQkFBTSxNQUFHLElBQUcsRUFBUTtBQUNwQixxQkFBTSxNQUFHLElBQUcsRUFBUTtBQUNwQixxQkFBTSxNQUFlLGdCQUNuQztBQUFFLGFBQVEsSUFBTSxTQUFlLGFBQUU7QUFDNUIsWUFBYSxhQUFNLE1BQWMsZUFBRTtBQUV0Qzs7QUFDWSxxQkFBTSxNQUFlLGdCQUFNO0FBQ3ZDLFlBQU8sS0FBa0IsaUJBQUk7QUFDN0IsWUFBWSxVQUFPO0FBQ25CLFlBQU8sS0FBTSxLQUFJLElBQWEsYUFBTSxNQUFHLElBQUcsRUFBUztBQUNuRCxZQUFPLEtBQU0sS0FBSSxJQUFhLGFBQU0sTUFBRyxJQUFHLEVBQVM7QUFDaEQsWUFBQyxDQUFHLEdBQVcsWUFBRTtBQUVwQjtBQUFFLG1CQUFZLE9BQVUsUUFBRTtBQUNoQixvQkFDVjtBQUFFLFNBRlEsVUFFSSxPQUFXLFNBQUU7QUFDakIsb0JBQUssS0FDZjtBQUFFLFNBRlEsTUFFQSxJQUFJLE9BQVcsU0FBRTtBQUNqQixvQkFBSyxLQUNmOztBQUNHLFlBQVEsU0FBRTtBQUNULGFBQ0o7QUFBRSxlQUFLO0FBQ0csbUJBQVEsUUFDbEI7QUFDRjtBQUNGO0FBQUM7Ozs7Ozs7Ozs7OztBQVlVLGlCQUFVLHFCQUFLLE1BQVEsUUFBUyxTQUFFO0FBQ3hDLFVBQUssS0FBUyxTQUFRLFNBQUU7QUFDckIsYUFBSyxLQUFLLE1BQVEsUUFBVTtBQUNoQyxlQUNGOztBQUNBLGFBQ0Y7QUFBQzs7Ozs7Ozs7Ozs7OztBQWFhLG9CQUFVLHdCQUFLLE1BQVEsUUFBUyxTQUFFO0FBQzNDLFVBQUssS0FBUyxTQUFRLFNBQUU7QUFDckIsYUFBUSxRQUFLLE1BQVEsUUFBVTtBQUNuQyxlQUNGOztBQUNBLGFBQ0Y7QUFBQzs7Ozs7Ozs7Ozs7QUFXRyxVQUFVLGNBQUssTUFBUSxRQUFTLFNBQUU7QUFDcEMsVUFBZSxhQUFNLEtBQVMsU0FBUTtBQUN0QyxVQUFTLE9BQVksV0FBSztBQUMxQixVQUFTLE9BQVksV0FBSztBQUMxQixVQUFTLE9BQU0sS0FBYTtBQUN6QixVQUFDLENBQUssTUFBRTtBQUNMLGFBQWMsZUFBTyxPQUMzQjs7QUFDSSxXQUFDLElBQU0sSUFBRyxHQUFLLEtBQUksSUFBSSxJQUFNLEtBQU8sUUFBSyxLQUFFO0FBQ3pDLGNBQU0sS0FBRzs7QUFFVixZQUFlLGlCQUFlLGFBQVEsUUFBTSxPQUFFLENBQUcsS0FBTyxRQUFXLFNBQUU7QUFFeEU7O0FBQ0csYUFBTSxLQUFLO0FBQ1gsWUFBQyxDQUFHLElBQUU7QUFDSCxlQUFNLE9BQUssS0FBRSxFQUFPLFFBQzFCOztBQUNHLFlBQUcsR0FBUSxXQUFLLEdBQUU7QUFDZixlQUFpQixpQkFBSSxLQUFNLEtBQ2pDOztBQUNFLFdBQU8sUUFBRSxDQUFHLEdBQU8sU0FBTSxLQUFHO0FBQzVCLFdBQVEsU0FBRSxDQUFHLEdBQVEsVUFBTSxLQUMvQjs7QUFDSSxXQUFpQixpQkFBTyxRQUFVO0FBQ25DLFVBQVcsV0FBWSxhQUFFO0FBQ3RCLGFBQWUsZUFBSyxNQUFZLFdBQ3RDO0FBQ0Y7QUFBQzs7Ozs7Ozs7Ozs7QUFXTSxhQUFVLGlCQUFLLE1BQVEsUUFBUyxTQUFFO0FBQ3ZDLFVBQWUsYUFBTSxLQUFTLFNBQVE7QUFDdEMsVUFBUyxPQUFZLFdBQUs7QUFDMUIsVUFBUyxPQUFZLFdBQUs7QUFDMUIsVUFBUyxPQUFNLEtBQWE7QUFDekIsVUFBSyxNQUFFO0FBQ0osYUFBQyxJQUFNLElBQUcsR0FBSyxLQUFJLElBQUksSUFBTSxLQUFPLFFBQUssS0FBRTtBQUN6QyxnQkFBTSxLQUFHO0FBQ1YsZUFBTSxLQUFLO0FBQ1gsY0FBSSxNQUFLLEdBQU0sT0FBRTtBQUNoQixlQUFPLFFBQUUsQ0FBRyxHQUFPLFNBQU0sS0FBRztBQUM1QixlQUFRLFNBQUUsQ0FBRyxHQUFRLFVBQU0sS0FBRztBQUM3QixnQkFBRyxHQUFRLFdBQUssR0FBRTtBQUNmLG1CQUFvQixvQkFBSSxLQUFNLEtBQ3BDO0FBQ0Y7QUFDRjtBQUNGOztBQUNJLFdBQW9CLG9CQUFPLFFBQ2pDO0FBQUM7Ozs7Ozs7Ozs7QUFVTyxjQUFVLGtCQUFNLE9BQUU7QUFDcEIsV0FBWSxZQUFLLEtBQU87QUFDeEIsV0FBQyxJQUFNLElBQUcsR0FBSSxJQUFPLE1BQU0sTUFBTyxRQUFLLEtBQUU7QUFDdkMsYUFBUyxTQUFNLE1BQU0sTUFBSyxNQUNoQztBQUNGO0FBQUM7Ozs7Ozs7O0FBUXFCLDRCQUFVLGdDQUFPLFFBQUU7QUFDbkMsV0FBQyxJQUFNLElBQUcsR0FBRyxHQUFJLElBQU0sS0FBWSxZQUFPLFFBQUssS0FBRTtBQUNqRCxZQUFNLEtBQVksWUFBRztBQUNuQixhQUFDLElBQU0sSUFBRyxHQUFHLEdBQUksSUFBRyxFQUFNLE1BQU8sUUFBSyxLQUFFO0FBQ3hDLGNBQUcsRUFBTSxNQUFHO0FBQ1gsY0FBRyxNQUFVLFFBQUU7QUFDaEIsbUJBQ0Y7QUFDRjtBQUNGOztBQUNBLGFBQ0Y7QUFBQzs7Ozs7Ozs7Ozs7O0FBWWEsb0JBQVUsd0JBQUssTUFBTyxPQUFFO0FBQ2pDLFVBQWMsZUFBRTtBQUNiLGFBQU0sTUFBYSxjQUN6Qjs7QUFDSSxXQUFlLGdCQUNyQjtBQUFDOzs7Ozs7Ozs7O0FBVUksV0FBVSxlQUFPLFFBQU0sTUFBUSxRQUFFO0FBQ3BDLFVBQU8sS0FBRSxJQUFTLE1BQUssTUFBRSxFQUFTLFNBQU0sTUFBWSxZQUFNLE1BQVUsVUFBUztBQUMzRSxTQUFRLFNBQVE7QUFDWixhQUFjLGNBQUk7O0FBRXJCLFVBQUcsR0FBaUIsa0JBQUU7QUFDdkIsWUFBYyxZQUFRLE9BQVcsYUFBUyxPQUFZO0FBQ25ELFlBQVcsYUFBWSxVQUFlLGdCQUFFO0FBQ2hDLG9CQUNYO0FBQ0Y7QUFDRjtBQUFDOzs7Ozs7Ozs7QUFTTSxhQUFVLGlCQUFPLFFBQUU7QUFDeEIsVUFBZSxhQUFNLEtBQXVCLHVCQUFRO0FBQ2pELFVBQVcsV0FBSyxNQUFFO0FBQ1QsbUJBQUssS0FBUyxVQUMxQjtBQUNGO0FBQUM7Ozs7Ozs7Ozs7O0FBV2tCLHlCQUFXLCtCQUFFO0FBQzNCLFVBQWEsYUFBTSxNQUFlLGdCQUFFO0FBQ3pCLHFCQUFNLE1BQWUsZUFDbkM7QUFDRjtBQUNEO0FBcldnQjs7OztBQXlXVCxXQUFTO0FBQ1gsVUFBVTtBQUNWLFVBQUUsQ0FBWSxhQUFjLGNBQWE7QUFDekM7QUFDRyxhQUFFLENBQVksYUFBZTtBQUMvQixXQUFFLENBQVUsV0FDaEI7QUFISztBQUlELFdBQUUsQ0FBTyxRQUFPOztBQUVqQjtBQUNJLGNBQU07QUFDUixZQUNMO0FBSEs7OztBQU1ELFdBQVcsaUJBQUU7QUFDRCxzQkFBSyxLQUN0QjtBQUFDOzs7Ozs7QUFNUSxlQUFVLG1CQUFFLEdBQUU7QUFDbEIsVUFBQyxDQUFtQixtQkFBRyxJQUFFO0FBRTVCOztBQUNBLFVBQU0sSUFBVSxTQUFvQixvQkFBRztBQUN2QyxVQUFTLE9BQU07QUFDZixVQUFXLFNBQUUsU0FBZSxPQUFFLEdBQUU7QUFDM0IsWUFBQyxDQUFtQixtQkFBRyxJQUFFO0FBQ3RCLGVBQU0sTUFBSyxNQUFHLEdBQUk7QUFDUCwwQkFBSyxLQUN0QjtBQUNGO0FBQUM7QUFDRCxVQUFTLE9BQUUsU0FBYSxLQUFFLEdBQUU7QUFDdkIsWUFBbUIsbUJBQUcsSUFBRTtBQUNyQixlQUFNLE1BQUssTUFBRyxHQUNwQjs7QUFDZSx3QkFBSyxLQUN0QjtBQUFDO0FBQ1ksb0JBQUssS0FBSyxNQUFRLFFBQU87QUFDbEMsV0FBTSxNQUFPLFFBQUcsR0FDdEI7QUFBQzs7Ozs7QUFLUyxnQkFBVSxvQkFBRSxHQUFFO0FBQ2xCLFdBQU0sTUFBTyxRQUFVLFNBQW9CLG9CQUFHLElBQUcsRUFBZSxlQUFHLElBQ3pFO0FBQUM7Ozs7O0FBS08sY0FBVSxrQkFBRSxHQUFFO0FBQ2hCLFdBQU0sTUFBSyxNQUFVLFNBQW9CLG9CQUFHLElBQUcsRUFBZSxlQUFHLElBQ3ZFO0FBQUM7Ozs7Ozs7QUFPSSxXQUFVLGVBQUssTUFBUSxRQUFPLE9BQVcsV0FBRTtBQUN0QyxlQUFNLE1BQU8sUUFBTTtBQUN4QixXQUFPLE1BQVE7QUFDZixXQUFPLE1BQVE7QUFDTCxxQkFBTztBQUNULG1CQUFXO0FBQ2IsaUJBQVUsaUJBQUUsR0FBRTtBQUNuQixpQkFBZSxTQUFRLFFBQ3pCO0FBRUo7QUFUK0I7QUFVL0I7QUEzRWdCOztBQTZFVixXQUFTO0FBQ1gsVUFBUztBQUNGLGlCQUFRO0FBQ2YsVUFBRSxDQUFZLGFBQWMsY0FBYSxhQUFhO0FBQ3REO0FBQ0csYUFBRSxDQUFZLGFBQWU7QUFDL0IsV0FBRSxDQUFVLFdBQ2hCO0FBSEs7QUFJRCxXQUFFLENBQVM7O0FBRVo7QUFDRCxTQUFHO0FBQ0gsU0FBRztBQUNDLGFBQVM7QUFDUCxlQUFPO0FBQ1QsYUFBSTs7QUFFRixlQUFVLGlCQUFLLE1BQUU7QUFDbkIsWUFBSyxLQUFNLE1BQVEsU0FBYyxjQUFFO0FBQ2hDLGVBQU0sTUFDWjs7QUFDSSxhQUFNLE1BQUssS0FDakI7QUFBQztBQUNLLGNBQU07QUFDUixZQUFNO0FBQ0gsZUFDUjtBQWhCSzs7O0FBbUJELFdBQVcsaUJBQUU7QUFDWixXQUFLLEtBQU8sUUFBUztBQUNyQixXQUFLLEtBQVMsVUFBTztBQUNyQixXQUFLLEtBQU8sUUFBSTtBQUNoQixXQUFLLEtBQUcsSUFBRztBQUNYLFdBQUssS0FBRyxJQUFHO0FBQ1gsV0FBSyxLQUFTLFVBQU87QUFDVixzQkFBSyxLQUN0QjtBQUFDOzs7Ozs7OztBQVFhLG9CQUFVLHdCQUFFLEdBQUcsR0FBRTtBQUMxQixVQUFLLEtBQUssS0FBUSxTQUFFO0FBQ3JCLGVBQ0Y7O0FBQ0csVUFBSyxLQUFLLEtBQVEsU0FBRTtBQUNyQixlQUNGOztBQUNBLFVBQU8sS0FBTSxLQUFJLElBQUssS0FBSyxLQUFHLElBQUk7QUFDbEMsVUFBTyxLQUFNLEtBQUksSUFBSyxLQUFLLEtBQUcsSUFBSTtBQUMzQixhQUFJLE1BQWtCLGtCQUFNLE1BQ3JDO0FBQUM7Ozs7O0FBS1EsZUFBVSxtQkFBRSxHQUFFO0FBQ2xCLFVBQUMsQ0FBbUIsbUJBQUcsSUFBRTtBQUU1Qjs7QUFDQSxVQUFNLElBQVUsU0FBb0Isb0JBQUc7QUFDdkMsVUFBUyxPQUFNO0FBQ2YsVUFBVyxTQUFFLFNBQWUsT0FBRSxHQUFFO0FBQzlCLFlBQU0sSUFBRyxFQUFRO1lBQUksSUFBRyxFQUFRO0FBQzdCLFlBQUssS0FBZSxlQUFFLEdBQUksSUFBRTs7QUFFekIsZUFBSyxLQUFPLFFBQU0sS0FBSyxLQUFXLFVBQUUsRUFBTSxTQUFjLFlBQVEsUUFBVyxVQUFTO0FBQ3JGLGNBQUssS0FBSyxLQUFPLFVBQVcsU0FBRTs7QUFFdkIscUJBQVEsUUFDbEI7O0FBQ0ksZUFBSyxLQUFRLFFBQUMsRUFBRSxHQUFHLEdBQUcsR0FBSztBQUM1QixjQUFDLENBQW1CLG1CQUFHLElBQUU7O0FBRXRCLGlCQUFLLEtBQU8sUUFBTztBQUNSLDRCQUFLLEtBQ3RCOztBQUNJLGVBQU0sTUFBRSxHQUFJO0FBQ1osZUFBSyxLQUFTLFVBQ3BCO0FBQ0Y7QUFBQztBQUNELFVBQVMsT0FBRSxTQUFhLEtBQUUsR0FBRTtBQUN2QixZQUFLLEtBQUssS0FBUSxTQUFFO0FBQ2YsaUJBQ1I7Ozs7QUFHZSx3QkFBSyxLQUN0QjtBQUFDOztBQUVZLG9CQUFLLEtBQUssTUFBUSxRQUFPO0FBQ2xDLFdBQUssS0FBRyxJQUFHLEVBQVE7QUFDbkIsV0FBSyxLQUFHLElBQUcsRUFDakI7QUFBQzs7Ozs7QUFLUyxnQkFBVSxvQkFBRSxHQUFFO0FBQ3RCLFVBQU8sS0FBRyxFQUFlLGVBQUc7QUFDeEIsV0FBSyxLQUFHLElBQUksR0FBUTtBQUNwQixXQUFLLEtBQUcsSUFBSSxHQUNsQjtBQUFDOzs7OztBQUtRLGVBQVUsbUJBQUUsR0FBRTtBQUNyQixVQUFNLElBQVUsU0FBb0Isb0JBQUc7QUFDdkMsVUFBTyxLQUFHLEVBQWUsZUFBRztBQUM1QixVQUFNLElBQUksR0FBUTtVQUFJLElBQUksR0FBUTtBQUMvQixVQUFLLEtBQWUsZUFBRSxHQUFJLElBQUU7QUFDMUIsWUFBSyxLQUFLLEtBQU8sVUFBVyxTQUFFOztBQUV2QixtQkFBUSxRQUNsQjs7QUFDSSxhQUFLLEtBQVEsUUFBQyxFQUFFLEdBQUcsR0FBRyxHQUFLO0FBQzNCLGFBQU0sTUFBRSxHQUFLO0FBQ2IsYUFBSyxLQUFPLFFBQVM7QUFDckIsYUFBSyxLQUFTLFVBQ3BCO0FBQ0Y7QUFBQzs7Ozs7QUFLTyxjQUFVLGtCQUFFLEdBQUU7QUFDcEIsVUFBTSxJQUFVLFNBQW9CLG9CQUFHO0FBQ3ZDLFVBQU8sS0FBRyxFQUFlLGVBQUc7O0FBRXpCLFVBQUssS0FBSyxLQUFRLFNBQUU7O0FBRWpCLGFBQUssS0FBTyxRQUFPO0FBQ25CLGFBQUssS0FBUSxRQUFDLEVBQUUsR0FBSSxHQUFRLFNBQUcsR0FBSSxHQUFVO0FBQzdDLGFBQU0sTUFBRSxHQUFJLElBQ2xCO0FBQ0Y7QUFBQzs7Ozs7OztBQU9JLFdBQVUsZUFBTyxRQUFPLE9BQUU7QUFDN0IsVUFBZSxhQUFNLEtBQUssS0FBTSxNQUFLLEtBQUssS0FBTSxNQUFRLFNBQUk7QUFDNUQsVUFBYSxXQUFNLEtBQUssS0FBTSxNQUFLLEtBQUssS0FBTSxNQUFRLFNBQUk7QUFDMUQsVUFBTyxLQUFVLFNBQUcsSUFBTSxLQUFLLEtBQUU7QUFDakMsVUFBTyxLQUFVLFNBQUcsSUFBTSxLQUFLLEtBQUU7QUFDakMsVUFBTztVQUFNLE1BQUc7QUFDYixVQUFXLFlBQUU7QUFDVixjQUFVLFNBQUcsSUFBWSxXQUFFO0FBQzNCLGNBQVUsU0FBRyxJQUFZLFdBQy9COztBQUNRLGVBQU0sTUFBTyxRQUFTO0FBQ3ZCLGVBQU0sS0FBSyxLQUFNO0FBQ3JCLFdBQU8sTUFBUTtBQUNmLFdBQU8sTUFBUTtBQUNkLFlBQUk7QUFDSixZQUFJO0FBQ0gsYUFBSztBQUNMLGFBQUs7QUFDRyxxQkFBTztBQUNiLGVBQVcsaUJBQUU7QUFDaEIsaUJBQWUsU0FBZSxlQUFNLE1BQVEsU0FBTyxNQUNyRDtBQUVKO0FBYmtDO0FBZWxDOztBQTVLZ0I7O0FBOEtWLFdBQVM7QUFDWCxVQUFPO0FBQ1AsVUFBRSxDQUFZLGFBQVMsU0FBYyxjQUFhO0FBQ2xEO0FBQ0csYUFBRSxDQUFZLGFBQWU7QUFDL0IsV0FBRSxDQUFRLFNBQ2Q7QUFISztBQUlELFdBQUUsQ0FBTztBQUNWO0FBQ0QsU0FBSztBQUNMLFNBQUs7QUFDQyxlQUNSO0FBSks7O0FBTUQsV0FBVyxpQkFBRTtBQUNaLFdBQUssS0FBRyxJQUFLO0FBQ2IsV0FBSyxLQUFHLElBQUs7QUFDYixXQUFLLEtBQVMsVUFDcEI7QUFBQzs7QUFFRyxVQUFVLGNBQUUsR0FBRTtBQUNaLFdBQUssS0FBRyxJQUFHLEVBQVE7QUFDbkIsV0FBSyxLQUFHLElBQUcsRUFDakI7QUFBQzs7Ozs7QUFLUSxlQUFVLG1CQUFFLEdBQUU7QUFDbEIsVUFBbUIsbUJBQUcsSUFBRTtBQUNyQixhQUFLLEtBQ1g7QUFDRjtBQUFDOzs7OztBQUtJLFdBQVUsZUFBRSxHQUFFO0FBQ2QsVUFBbUIsbUJBQUcsSUFBRTtBQUNyQixhQUFRLFFBQ2Q7QUFDRjtBQUFDOzs7OztBQUtTLGdCQUFVLG9CQUFFLEdBQUU7QUFDbEIsV0FBSyxLQUFFLEVBQWUsZUFBRyxJQUMvQjtBQUFDOzs7OztBQUtPLGNBQVUsa0JBQUUsR0FBRTtBQUNoQixXQUFRLFFBQUUsRUFBZSxlQUFHLElBQ2xDO0FBQUM7Ozs7OztBQU1NLGFBQVUsaUJBQUUsR0FBVyxXQUFFO0FBQzlCLFVBQU8sS0FBTSxLQUFJLElBQUUsRUFBUyxVQUFNLEtBQUssS0FBRztBQUMxQyxVQUFPLEtBQU0sS0FBSSxJQUFFLEVBQVMsVUFBTSxLQUFLLEtBQUc7QUFDMUMsVUFBTSxJQUFVLFNBQW9CLG9CQUFHOztBQUVwQyxVQUFNLE1BQUssT0FBUSxNQUFRLE9BQUksTUFBZ0IsZ0JBQU0sTUFBaUIsZ0JBQW1CLGlCQUFHLElBQUU7O0FBRTVGLFlBQUMsQ0FBSyxLQUFLLEtBQVEsU0FBRTtBQUNkLG1CQUFNLE1BQUUsR0FBTztBQUNwQixlQUFHLEVBQVE7QUFDWCxlQUFHLEVBQVE7QUFDRCx5QkFBRztBQUNMLHVCQUViO0FBTjJCO0FBTzdCO0FBQ0Y7QUFDQTtBQTlFZ0I7Ozs7O0FBbUZWLFdBQW9CLHFCQUFVLFNBQW9COzs7QUFHbEQsV0FBSyxNQUFVLFNBQVk7OztBQUczQixXQUFRLFNBQVUsU0FBZTs7QUFFbEMsVUFBVSxXQUVuQjtBQUFJLEs7Ozs7Ozs7Ozs7O0FDeDZCSixDQUFVLFlBQUU7O0FBRUU7Ozs7O0FBSVosV0FBeUIsaUJBQUcsSUFBRTtBQUN6QixRQUFPLE9BQVksYUFBRTtBQUNYLGtCQUFVLFVBQ3ZCO0FBQUUsV0FBSztBQUVQO0FBQ0Y7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW9CTyxVQUFZLGFBQVUsVUFBSyxNQUFRLFFBQVMsU0FBVSxVQUFFO0FBQzdELFFBQVMsT0FDUDtBQUFTLGFBQUssS0FBYyxjQUFlLGdCQUFPLE9BQXFCO0FBQ3RFLFFBQUMsQ0FBSyxNQUFFO0FBQ0osYUFBaUMsOEJBQVMsU0FBYyxjQUFTO0FBQ2xFLFdBQUssTUFBVTtBQUNmLFdBQU0sT0FBTTtBQUNaLFdBQWEsYUFBYyxlQUNqQzs7OztBQUdHLFFBQVMsVUFBRTtBQUNSLFdBQWEsYUFBUSxTQUMzQjs7Ozs7QUFJQSxRQUFZLFVBQVcsbUJBQUU7QUFDbkIsV0FBb0Isb0JBQU8sUUFBZTtBQUMxQyxXQUFvQixvQkFBUSxTQUNsQzs7QUFDQSxRQUFpQixlQUFVLHNCQUFNLE9BQUU7QUFDeEI7Ozs7QUFJTCxXQUF1Qix3QkFBTTtBQUM5QixVQUFPLFFBQUU7QUFDTSx5QkFBSSxZQUFHO0FBQ2YsaUJBQ1I7QUFDRjtBQUNGO0FBQUM7QUFDRCxRQUFrQixnQkFBVSx1QkFBTSxPQUFFO0FBQ3pCOzs7O0FBSU4sVUFBSyxLQUFXLFlBQUU7QUFDZixhQUFXLFdBQVksWUFDN0I7O0FBQ0csVUFBUSxTQUFFO0FBQ0sseUJBQUksWUFBRztBQUNkLGtCQUNUO0FBQ0Y7QUFDRjtBQUFDO0FBQ0csU0FBaUIsaUJBQU8sUUFBZTtBQUN2QyxTQUFpQixpQkFBUSxTQUFnQjtBQUMxQyxRQUFLLEtBQVksY0FBTyxNQUFFO0FBQ25CLGVBQUssS0FBWSxZQUFNOztBQUdqQztBQUFFLFdBQVEsSUFBSyxLQUFzQix1QkFBRTtBQUNqQyxXQUFjLGNBQUMsSUFBUyxNQUM5Qjs7QUFDQSxXQUNGO0FBRUY7QUFBSSxLOzs7Ozs7Ozs7OztBQzdGSixDQUFVLFlBQUU7O0FBRUU7O0FBRVosTUFBYyxZQUFPO0FBQ3JCLE1BQXNCLG9CQUFJO0FBQzFCLE1BQXFCLG1CQUFJOztBQUV6QixXQUFrQixXQUFFO0FBQ1IsZ0JBQU07O0FBRUssMEJBQVUsWUFBRTtBQUNyQixrQkFBTztBQUNQLGlCQUFtQjs7QUFFbkIsaUJBQVUsWUFBRTtBQUNaLGlCQUNWO0FBQ0Y7QUFDRjs7O0FBRUEsV0FBbUIsV0FBTSxPQUFFO0FBQ25CLFdBQU0sTUFBTyxRQUFFO0FBQ1QsaUJBQU0sTUFDbEI7QUFDRjs7O0FBRUEsV0FBaUIsU0FBTSxPQUFFO0FBQ25CLFNBQUMsSUFBSyxJQUFFLEdBQUcsSUFBTSxNQUFPLFFBQUksSUFBRyxHQUFLLEtBQUU7QUFDOUIsaUJBQU0sTUFDbEI7QUFDRjs7O0FBRUEsV0FBbUIsV0FBSyxNQUFFO0FBQ3hCLFFBQWMsVUFBTSxLQUFHO0FBQ3ZCLFFBQWUsV0FBTSxLQUFHO0FBQ3hCLFFBQVcsT0FBTSxLQUFHO0FBQ3BCLFFBQUk7QUFDTSxlQUFNLE1BQVEsU0FDeEI7TUFBTyxPQUFFLEdBQUU7QUFDQyxpQkFBSSxZQUFHO0FBQ2YsY0FDRjtBQUNGO0FBQ0Y7OztBQUVBLFdBQWUsUUFBRTtBQUNULFdBQWtCLGtCQUFRLFVBQW1CLGlCQUFPLFFBQUU7QUFDaEQsaUJBQW1CO0FBQ25CLGlCQUNaOztBQUNVLGdCQUNaOzs7Ozs7Ozs7O0FBU08sVUFBYzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkgsc0JBQVUsMEJBQVEsU0FBVSxVQUFNLE1BQUU7QUFDL0MsVUFBQyxDQUFVLFdBQUU7QUFFaEI7O0FBQ2lCLHdCQUFLLEtBQUMsQ0FBUSxTQUFVLFVBQzNDO0FBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7QUFnQmMscUJBQVUseUJBQVEsU0FBVSxVQUFNLE1BQUU7QUFDOUMsVUFBQyxDQUFVLFdBQUU7QUFFaEI7O0FBQ2dCLHVCQUFLLEtBQUMsQ0FBUSxTQUFVLFVBQzFDO0FBQUM7Ozs7Ozs7O0FBUUksV0FJVDs7QUF2RHlCO0FBdURyQixLOzs7Ozs7Ozs7QUN0SEosQ0FBVSxZQUFFO0FBQ0U7Ozs7QUFJWixXQUFpQixVQUFFO0FBQ1QsYUFBSyxLQUFnQixnQkFDL0I7OztBQUVHLE1BQU8sT0FBYyxlQUFFO0FBQ2xCLFdBQWlCLGlCQUFxQixzQkFDOUM7QUFBRSxTQUFLO0FBQ0YsUUFBUyxTQUFZLGVBQWtCLGlCQUFXLFNBQVksZUFBYyxZQUFFO0FBRWpGO0FBQUUsV0FBSztBQUNDLGFBQWlCLGlCQUFtQixvQkFDNUM7QUFDRjtBQUVGO0FBQUksSzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDZkosQ0FBVTtBQUNJOztBQUVaLE1BQVEsSUFBUyxRQUFVOzs7O0FBSTNCLE1BQWdDLDRCQUFHLEVBQVMsV0FBSSxFQUFpQixtQkFDOUQsRUFBb0Isc0JBQUksRUFBbUIscUJBQzNDLEVBQWtCLG9CQUFJLEVBQXNCOzs7Ozs7Ozs7OztBQVcvQyxNQUFzQixrQkFBVSx5QkFBSyxNQUFVLFVBQUU7QUFDL0MsV0FBZ0MsMEJBQUssS0FBSyxNQUM1Qzs7O0FBTUE7Ozs7O0FBNUJVLE1BNEJHOzs7OztBQUtBLG9CQUFLO0FBQUU7O0FBQ1osV0FBTSxPQUNaOzs7QUFVWTs7Ozs7Ozs7Ozs7O21DQUFTLFVBQUU7QUFDckIsZUFBTyxJQUFXLFFBQXVCLHVCQUFLLEtBQUssTUFDckQ7OztBQVFjOzs7Ozs7Ozs7cUNBQWUsZ0JBQUU7QUFDZix1QkFDaEI7OztBQUtlOzs7Ozs7dUNBQUc7O0FBV047Ozs7Ozs7Ozs7OzttQ0FBSyxNQUFFO0FBQ2QsWUFBSyxLQUFLLEtBQVMsU0FBTSxPQUFFO0FBQzVCLGlCQUNGOztBQUNBLFlBQU0sSUFBTTtBQUNaLFlBQVEsTUFBTSxLQUFjOztBQUV0QixlQUFHLEtBQUssTUFBUSxPQUFLLE1BQVEsS0FBSyxNQUFFOztBQUV0QyxjQUFHLEVBQVksY0FBSSxFQUN2Qjs7QUFDQSxlQUFTLE1BQVEsS0FDbkI7OztBQVVhOzs7Ozs7Ozs7OztxQ0FBRTtBQUNiLGVBQVcsS0FBSyxLQUNsQjs7O0FBUW9COzs7Ozs7Ozs7NENBQUU7QUFDcEIsZUFBWSxLQUFLLEtBQVcsY0FBWSxNQUFqQyxHQUNELEtBQUssS0FBYyxjQUFDLEVBQVEsU0FBUyxVQUU3Qzs7O0FBTzhCOzs7Ozs7OztzREFBRTtBQUM5QixZQUFRLE1BQUk7QUFDWixZQUFNLElBQU0sS0FBSyxLQUFhO0FBQ3hCLGVBQUUsR0FBRTtBQUNMLGNBQUssS0FBRztBQUNULGNBQUcsRUFDUDs7QUFDQSxlQUNGOzs7QUFVVTs7Ozs7Ozs7Ozs7aUNBQUssTUFBTSxNQUFFO0FBQ3JCLFlBQVEsTUFBTSxLQUFNLGdCQUFvQixXQUFNLEtBQU0sT0FDOUMsS0FBSyxLQUFjO0FBQ3pCLGVBQVUsSUFBVyxXQUFLLE1BQzVCOzs7QUFNdUI7Ozs7Ozs7K0NBQUU7QUFDdkIsZUFBYyxRQUF1Qix1QkFBa0Isa0JBQUssS0FDOUQ7OztBQVN3Qjs7Ozs7Ozs7OzsrQ0FBUyxVQUFFO0FBQ2pDLFlBQU8sS0FBTSxLQUF5QjtBQUN0QyxZQUFTLE9BQUk7QUFDVCxhQUFDLElBQUssSUFBRSxHQUFHLElBQUcsR0FBTyxRQUFHLEdBQUksSUFBTyxDQUFULEtBQVcsSUFBRyxHQUFJLEtBQUssS0FBRTtBQUNsRCxjQUFHLEVBQVUsYUFBUSxLQUFlLFlBQW5DLElBQ2UsZ0JBQUUsR0FBVyxXQUFFO0FBQzVCLGlCQUFLLEtBQ1g7QUFDRjs7QUFDQSxlQUNGOzs7QUFRa0I7Ozs7Ozs7OzswQkFBRTtBQUNsQixZQUFTLE9BQU0sS0FBSztBQUNwQixlQUFXLEtBQWdCLG1CQUFjLFlBQU0sS0FBZ0IsaUJBQU0sS0FDdkU7QUFDRjs7Ozs7O0FBRUEsV0FBdUIsZUFBTSxPQUFTO0FBQUU7QUFFcEMsVUFBVyxTQUFTLFFBQUc7QUFDbEIsWUFBUywrQkFBaUMsWUFBRTtBQUMvQyxlQUFXLEtBQUssS0FBUSxRQUFNLE1BQUssS0FBSyxNQUMxQztBQUNGOzs7QUFMSSxTQUFDLFFBQU8sR0FBSSxJQUFTLFFBQU8sUUFBSztBQUFFLFlBQTdCO0FBTVo7OztBQUVBLFdBQWtDLDBCQUFNLE9BQVk7QUFBRTtBQUVsRCxVQUFTLE9BQVksV0FBRztBQUNsQixhQUFlLGVBQU0sT0FBTTtBQUM1QixhQUFXLGVBQUU7QUFDZCx1Q0FBbUMsSUFBTixDQUFXLEtBQzFDOztBQUFDO0FBQ1csc0JBRWhCO0FBTnFDOzs7QUFGakMsU0FBQyxJQUFLLElBQUUsR0FBSSxJQUFZLFdBQU8sUUFBSztBQUFFO0FBUzVDOzs7QUFFQSxXQUEwQixrQkFBTSxPQUFZO0FBQUU7QUFFMUMsVUFBUyxPQUFZLFdBQUc7QUFDbEIsYUFBZSxlQUFNLE9BQU07QUFDNUIsYUFBVyxlQUFFO0FBQ2QsdUNBQW1DLElBQU4sQ0FBVyxLQUMxQzs7QUFBQztBQUNFLGFBQVUsYUFBTSxPQUFFOytCQUNTLElBQU4sQ0FBVyxLQUFPLFFBQzFDO0FBQUM7QUFDVyxzQkFFaEI7QUFUcUM7OztBQUZqQyxTQUFDLElBQUssSUFBRSxHQUFJLElBQVksV0FBTyxRQUFLO0FBQUU7QUFZNUM7OztBQUVjLGlCQUFPLE9BQVUsV0FBRSxDQUNwQixhQUFlLGVBQWdCLGdCQUFlLGVBQzNDLGdCQUFnQixnQkFBbUIsbUJBQ2xDLGlCQUNmOztBQUV1Qiw0QkFBTyxPQUFVLFdBQUUsQ0FDOUIsY0FBYyxjQUFhLGFBQzFCLGVBQW1CLG1CQUFxQixxQkFDbkMsb0JBQXNCLHNCQUEwQiwwQkFDdEQsY0FBWSxZQUN4Qjs7QUFFZSxvQkFBTyxPQUFVLFdBQUUsQ0FDckIsZUFDYjs7QUFPRjs7Ozs7TUFBZTtBQUNGLHNCQUFNO0FBQUU7O0FBQ2IsV0FBTyxRQUNiOzs7QUFPZTs7Ozs7Ozs7OzBCQUFFO0FBQ2YsZUFBVyxLQUFNLE1BQWUsZUFDbEM7OztBQU9nQjs7Ozs7Ozs7MEJBQUU7QUFDaEIsZUFBVyxLQUFNLE1BQ25COzs7QUFLUzs7Ozs7OzBCQUFFO0FBQ1QsZUFBVyxLQUFNLE1BQ25CO0FBQ0Y7Ozs7OztBQUVPLFVBQVEsU0FBUTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBa0JoQixVQUFLLE1BQVUsVUFBSSxLQUFFO0FBQ3RCLFVBQU0sT0FBVztBQUNsQixRQUFDLENBQUksSUFBUyxVQUFFO0FBQ2pCLFVBQVU7QUFDUCxVQUFLLGVBQWdCLE9BQUU7QUFDakIsaUJBQUUsSUFBWSxTQUN2QjtBQUFFLGFBQUs7QUFDRSxpQkFBRSxJQUFVLE9BQ3JCOztBQUNHLFVBQVUsV0FDZjs7QUFDQSxXQUFVLElBQ1o7QUFBQzs7QUFFTSxVQUFJLElBQWlCLGtCQUFpQjs7Ozs7Ozs7Ozs7QUFXdEMsVUFBSSxJQUFPLFFBQVMsUUFBTTs7Ozs7Ozs7OztBQVUxQixVQUFJLElBQWMsZUFBUyxRQUNwQztBQUFJLEs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNuVUosQ0FBVTtBQUNJOzs7Ozs7Ozs7QUFRWixXQUFlLE9BQUssTUFBRTtBQUNiLFdBQUssS0FBVyxjQUN6Qjs7O0FBMEJBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBckNVLE1BcUNtQjs7Ozs7QUFjSDs7Ozs7Ozs7Ozs7O3dDQUFLLE1BQUU7QUFDMUIsWUFBTyxPQUFNLE9BQUU7QUFDaEIsZ0RBQTRDLElBQU4sQ0FBb0IsY0FBQyxFQUFRLFNBQ3JFOztBQUFFLGVBQUs7QUFDTCx1QkFBaUIsS0FBSyxLQUFZLFlBQUksSUFBTSxnQkFBRztBQUMxQyxnQkFBTyxPQUFNLE9BQUU7QUFDaEIsb0RBQTRDLElBQU4sQ0FBb0IsY0FBQyxFQUFRLFNBQ3JFOztBQUFFLG1CQUFLO0FBQ0wscUJBQU8sQ0FDVDtBQUNGO0FBQUUsV0FOVSxFQU1ILGlCQUFHLEdBQUs7QUFBUCxtQkFBVyxFQUFPLE9BQUc7YUFDakM7QUFDRjs7Ozs7Ozs7Ozs7QUFPVyxvQ0FBTyxRQUFVO0FBQUU7Ozs7O0FBRXhCLFdBQXdCLHlCQUFNOztBQUU5QixXQUF5QiwwQkFBTTtBQUMvQixXQUFZLGFBQU87QUFDbkIsV0FBUyxVQUFRO0FBQ2pCLFdBQVUsV0FBVTtBQUNwQixXQUFpQixrQkFBSTtBQUNyQixXQUFXLFlBQU07QUFDakIsV0FBWSxhQUFPOztBQUVuQixXQUFnQixpQkFBSyxZQUFHO0FBQ3RCLGNBQ047O0FBQ0ksV0FBVTtBQUNWLFdBQ047OztBQU9ROzs7Ozs7Ozs7O0FBQUU7O0FBQ0wsWUFBTyxPQUFLLEtBQVMsVUFBRTtBQUNwQixlQUFhLGFBQUMsQ0FBSyxLQUN6QjtBQUFFLGVBQUs7QUFDRCxlQUFhLGFBQUssS0FBUSxRQUFVO0FBQ3JDLGNBQU8sT0FBUyxVQUFFO0FBQ2YsaUJBQXdCLGtDQUNGLGdCQUFLLEtBQVEsU0FBRSxVQUFZLFdBQUc7QUFDaEQscUJBQWtCLGtCQUN4QjtBQUNKLGFBSFk7QUFHVixpQkFBSztBQUNELGlCQUF5Qiw4QkFDUCxpQkFBQyxVQUFZLFdBQUc7QUFDOUIscUJBQWtCLGtCQUN4QjtBQUFFLGFBRkY7QUFHRSxpQkFBd0Isd0JBQVEsUUFBSyxLQUFRLFNBQUUsRUFBVSxXQUMvRDtBQUNGOztBQUNJLGFBQVksYUFDbEI7OztBQVFXOzs7Ozs7Ozs7bUNBQUU7QUFDUixZQUFPLE9BQUssS0FBUyxVQUFFO0FBQ3BCLGVBQWUsZUFBQyxDQUFLLEtBQzNCO0FBQUUsZUFBSztBQUNELGVBQWUsZUFBSyxLQUFRLFFBQVU7QUFDdkMsY0FBTyxPQUFVLFlBQU8sS0FBdUIsd0JBQUU7QUFDMUMscUJBQWtCLGtCQUFLLEtBQXdCO0FBQ25ELGlCQUF3Qix5QkFDOUI7QUFBRSxpQkFBUSxJQUFLLEtBQXdCLHlCQUFFO0FBQ25DLGlCQUF3Qix3QkFBYTtBQUNyQyxpQkFBeUIsMEJBQy9CO0FBQ0Y7O0FBQ0ksYUFBWSxhQUNsQjtBQUVVOzs7O0FBQUU7O0FBQ1AsWUFBQyxDQUFLLEtBQVcsWUFBRTtBQUNoQixlQUFZLGFBQU07QUFDZixrQkFBTSxNQUFVLFVBQUk7QUFBSSxtQkFBTyxPQUN4Qzs7QUFDRjtBQUVpQjs7O3dDQUFVLFdBQUU7QUFDdkIsYUFBc0Isc0JBQVc7QUFDakMsYUFDTjtBQUVxQjs7OzRDQUFVLFdBQUU7QUFDNUIsWUFBVSxXQUFFO0FBQ1QsZUFBQyxJQUFLLElBQUUsR0FBSSxJQUFXLFVBQU8sUUFBSyxLQUFFO0FBQ3ZDLGdCQUFhLFdBQVcsVUFBRztBQUN4QixnQkFBUyxTQUFXLFlBQUU7QUFDbkIsbUJBQWEsYUFBUyxTQUM1Qjs7QUFDRyxnQkFBUyxTQUFhLGNBQUU7QUFDckIsbUJBQWUsZUFBUyxTQUM5QjtBQUNGO0FBQ0Y7QUFDRjs7O0FBVU07Ozs7Ozs7Ozs7OzhCQUFFO0FBQ0gsWUFBQyxDQUFLLEtBQVcsWUFBRTtBQUNwQixpQkFDRjs7QUFDRyxZQUFPLE9BQVMsVUFBRTtBQUNYLG1CQUNWOztBQUNHLFlBQUssS0FBd0IseUJBQUU7QUFDNUIsZUFBc0Isc0JBQUssS0FBd0Isd0JBQ3pEO0FBQUUsZUFBUSxJQUFLLEtBQXVCLHdCQUFFO0FBQ2xDLGVBQXNCLHNCQUFLLEtBQXVCLHVCQUN4RDs7QUFDSSxhQUFZLGFBQU87QUFDdkIsWUFBUztBQUNELGtCQUFNLEtBQVE7QUFDVixzQkFBSTtBQUNGLHdCQUNiO0FBSlU7QUFLWCxZQUFhLFdBQU0sS0FBWSxZQUFrQixrQkFBSyxLQUFTO0FBQy9ELFlBQVksVUFBUyxRQUFZLFlBQWlCLGlCQUFTLFVBQ3JELEtBQWlCOztBQUVuQixhQUFDLElBQUssSUFBRSxHQUFHLEdBQUksSUFBUSxRQUFZLE1BQXRCLEtBQXdCLElBQVEsUUFBSSxLQUFLLEtBQUU7QUFDdEQsZUFBQyxJQUFLLElBQUUsR0FBRyxHQUFLLElBQUcsRUFBUSxRQUFZLE1BQTFCLEtBQTRCLElBQUUsRUFBUSxRQUFJLEtBQUssS0FBRTtBQUM1RCxpQkFBYSxhQUFLLEtBQ3hCO0FBQ0Y7OztBQUVJLGFBQUMsSUFBSyxLQUFFLEdBQUcsSUFBSSxLQUFRLFFBQVksTUFBdEIsS0FBd0IsS0FBUSxRQUFJLE1BQUssTUFBRTtBQUN0RCxlQUFDLElBQUssS0FBRSxHQUFNLE9BQUksS0FBRyxHQUFPLFFBQUcsR0FBVyxZQUFLLE1BQUU7QUFDL0MsaUJBQVcsV0FBSyxLQUFTLFNBQy9CO0FBQ0Y7OztBQUVJLGFBQWlCLGtCQUFVO0FBQy9CLFlBQWEsV0FBTztBQUNqQixZQUFLLEtBQVcsV0FBUSxVQUFPLEtBQWEsYUFBTyxRQUFFO0FBQzdDLHFCQUFNO0FBQ1gsZUFBUyxTQUFLLEtBQUssS0FBUSxTQUNqQzs7QUFDQSxlQUNGO0FBRVk7OzttQ0FBUyxVQUFFO0FBQ2pCLGFBQUMsSUFBSyxJQUFFLEdBQUksSUFBVSxTQUFPLFFBQUssS0FBRTtBQUN0QyxjQUFNLElBQVUsU0FBRztBQUNoQixjQUFPLE9BQUcsSUFBRTtBQUNaLGNBQWlCLGlCQUFhLGNBQU0sS0FDdkM7QUFDRjtBQUNGO0FBRWM7OztxQ0FBUyxVQUFFO0FBQ25CLGFBQUMsSUFBSyxJQUFFLEdBQUksSUFBVSxTQUFPLFFBQUssS0FBRTtBQUN0QyxjQUFNLElBQVUsU0FBRztBQUNoQixjQUFPLE9BQUcsSUFBRTtBQUNaLGNBQW9CLG9CQUFhLGNBQU0sS0FDMUM7QUFDRjtBQUNGO0FBRUY7Ozs7OztBQUVPLFVBQXdCLHlCQUVqQztBQUFJLEs7Ozs7Ozs7Ozs7O0FDM09GLENBQVUsWUFBRTtBQUNFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBa0JOLFNBQVEsUUFBWSxhQUFVLFVBQUssTUFBRTs7O0FBR3pDLFFBQVM7QUFDTixRQUFDLE9BQVksU0FBYyxZQUFFO0FBQ3hCLGNBQ1I7QUFBRSxXQUFLO0FBQ0MsY0FBUyxRQUFNLE1BQ3ZCOztBQUNjLG1CQUFPLE9BQU0sTUFBRyxJQUE2QiwyQkFBUTtBQUNuRSxXQUNGO0FBRUY7QUFBSSxLOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNsQ0osQ0FBVSxZQUFFOztBQUVFOztBQUVaLE1BQWM7QUFDSixjQUFNO0FBQ04sY0FBTTtBQUNULFdBQU07QUFDSixhQUFNO0FBQ0Msb0JBQU07QUFDVixnQkFBTTtBQUNBLHNCQUFNOztBQUViLGVBQ1g7Ozs7Ozs7Ozs7Ozs7Ozs7QUFWZ0IsSUEwQmhCLFNBQXVCLGVBQVUsV0FBTyxPQUFFO0FBQ3JDLFFBQUMsQ0FBVSxXQUFFO0FBQ2QsYUFBaUMsMkJBQ25DOzs7Ozs7QUFJTSxZQUFTLFFBQW1CLG1CQUFPO0FBQ3RDLFFBQUMsQ0FBTSxNQUFRLFFBQVcsWUFBRTtBQUNuQixrQkFBRSxDQUNkOztBQUNBLFFBQW1CLGlCQUFPLE1BQVUsVUFBVTs7QUFFcEMsZ0JBQWtCLGlCQUFVLFdBQU0sTUFBaUI7O0FBRXZELFlBQWlCLGdCQUFVLFdBQVE7QUFDdEMsUUFBZSxnQkFBRTtBQUNSLGtCQUFnQixlQUFPLE9BQ25DOzs7QUFFSyxVQUFVLFVBQVcsWUFBVztBQUNyQyxXQUNGOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFnQ0EsV0FBd0IsZ0JBQVUsV0FBTyxPQUFFO0FBQ3JDLFNBQUMsSUFBSyxJQUFFLEdBQUcsSUFBVSxVQUFPLFFBQUssS0FBRTtBQUNyQyxVQUFNLElBQVcsVUFBRztBQUNqQixVQUFFLEdBQUU7QUFDQyxnQkFBTyxNQUFRLFFBQUksS0FBaUIsZ0JBQUUsR0FBUyxTQUM5QixzQkFBRSxHQUMzQjtBQUNGOztBQUNBLFdBQ0Y7Ozs7Ozs7OztBQVFBLFdBQXlCLGlCQUFVLFdBQU0sTUFBUyxTQUFFO0FBQzdDLFdBQU8sUUFBSztBQUNiLFNBQUMsSUFBSyxJQUFVLFVBQU8sU0FBRSxHQUFJLEtBQUksR0FBSyxLQUFFO0FBQzFDLFVBQU0sSUFBVyxVQUFHO0FBQ2pCLFVBQUUsR0FBRTtBQUNGLFlBQU0sTUFBUSxRQUFHLElBQUU7QUFDSiwyQkFBRSxHQUNwQjtBQUFFLGVBQUs7O0FBRUYsY0FBSyxLQUFRLFFBQUksS0FBTyxNQUFDLENBQVMsV0FBVSxRQUFRLFFBQUksS0FBSSxJQUFFO0FBQzNELGlCQUFRLFFBQ2Q7QUFDRjtBQUNGO0FBQUUsYUFBSztBQUNFLGdCQUFLLEtBQ2Q7QUFDRjs7QUFDQSxXQUNGOzs7Ozs7Ozs7O0FBU0EsV0FBOEIsc0JBQUssTUFBTTtBQUV2QyxRQUF1Qjs7Ozs7Ozs7Ozs7a0NBMEJYO0FBQ087QUFDWixjQUFLLEtBQVEsU0FBRTtBQUNaLGlCQUFRLFFBQUssS0FDbkI7QUFDRjtBQUVZOzs7c0NBQUU7QUFDTzs7Ozs7Ozs7QUFRaEIsY0FBSyxLQUFlLGdCQUFFO0FBQ25CLGlCQUFlLGVBQUssS0FBTyxPQUFlLGVBQ2hEOztBQUNHLGNBQUssS0FBVyxZQUFFO0FBQ2YsaUJBQVcsV0FBSyxLQUFPLE9BQWUsZUFDNUM7QUFDRjtBQUVnQjs7OzBDQUFFO0FBQ087QUFDcEIsY0FBSyxLQUFVLFdBQUU7QUFDZCxpQkFBQyxJQUFNLEtBQU8sS0FBVSxXQUFFO0FBQ3hCLG1CQUE4Qiw4QkFBSyxNQUFHLEdBQU0sS0FBVSxVQUM1RDtBQUNGO0FBQ0Y7Ozs7O0FBS2tCOzs7OzRDQUFFO0FBQ2YsY0FBSyxLQUFlLGdCQUFFO0FBQ25CLGlCQUFDLElBQU0sS0FBTyxLQUFlLGdCQUFFO0FBQzdCLG1CQUFpQixpQkFBRSxHQUFNLEtBQWUsZUFDOUM7QUFDRjs7QUFFRjtBQUVNOzs7Z0NBQUU7QUFDTztBQUNWLGNBQUssS0FBTSxPQUFFO0FBQ1YsaUJBQU0sTUFBSyxLQUNqQjtBQUNGO0FBRVM7OzttQ0FBRTtBQUNPO0FBQ2IsY0FBSyxLQUFTLFVBQUU7QUFDYixpQkFBUyxTQUFLLEtBQ3BCO0FBQ0Y7QUFFUzs7O21DQUFFO0FBQ087QUFDYixjQUFLLEtBQVMsVUFBRTtBQUNiLGlCQUFTLFNBQUssS0FDcEI7QUFDRjtBQUVnQjs7O3lDQUFLLE1BQUssS0FBTyxPQUFFO0FBQ1gsK0lBQUssTUFBSyxLQUFRO0FBQ3JDLGNBQUssS0FBaUIsa0JBQUU7QUFDckIsaUJBQWlCLGlCQUFLLEtBQUssTUFBTSxNQUFLLEtBQzVDO0FBQ0g7QUFDRDs7OzRCQWhHMEI7QUFDdEIsaUJBQVcsS0FDYjtBQUVxQjs7OzRCQUFFO0FBQ3JCLGlCQUFXLEtBQ2I7OztBQUtvQjs7Ozs7OzRCQUFFOztBQUVwQixpQkFBVyxLQUFXOztBQUViLGtCQUFXLGFBQVUsUUFBVSxVQUFPLE9BQUssS0FBRyxJQUFjOzs7QUFHL0QsZUFBVTs7QUFFVixlQUFVLFVBQVcsYUFFN0I7QUFFUTs7OztNQXhCYzs7QUFrR1IscUJBQWUsZ0JBQUU7O0FBRTdCLFNBQUMsSUFBTSxLQUFPLE1BQUU7OztBQUdmLFVBQUUsRUFBRyxLQUFhLFlBQUU7QUFDckIsWUFBTyxLQUFRLE9BQXlCLHlCQUFLLE1BQUk7QUFDOUMsWUFBRyxJQUFFO0FBQ0EsaUJBQWUsZUFBaUIsaUJBQVUsV0FBRyxHQUNyRDtBQUNGO0FBQ0Y7OztBQUVBLFdBQ0Y7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBc0VPLFVBQU8sUUFBVSxVQUFLLE1BQUU7QUFDMUIsUUFBQyxDQUFLLE1BQUU7QUFDRixjQUFLLEtBQ2Q7O0FBQ0EsUUFBVSxRQUF1QixzQkFBSyxNQUFNLEtBQVc7O0FBRXZDLG1CQUFLLEtBQVUsV0FBZSxlQUNyQyxRQUFtQixtQkFBYzs7QUFFckMsVUFBSSxLQUFNLEtBQUc7QUFDbEIsV0FDRjs7O0FBRU8sVUFBZ0IsaUJBRXpCO0FBQUksSzs7Ozs7Ozs7Ozs7QUN4VUosQ0FBVSxZQUFFO0FBQ0U7O0FBRVosTUFBeUIsdUJBQVMsUUFBcUI7Ozs7Ozs7Ozs7OztBQVl2RCxNQUFtQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBK0RuQixNQUFnQjs7Ozs7Ozs7Ozs7Ozs7QUFjSixvQ0FBUyxVQUFhLGFBQUU7QUFDNUIsV0FBc0IsdUJBQVU7QUFDaEMsV0FBTSxlQUFvQixXQUFXLFdBQVMsVUFBTTtBQUMzQyxxQkFBUyxRQUFhO0FBQ3RCLHFCQUFNLEtBQWE7QUFDakIsdUJBQU0sS0FBZTtBQUNuQix5QkFBTSxLQUFtQjtBQUN0Qiw0QkFBTSxLQUU1QjtBQVA0RCxPQUF2QztBQU9wQjs7Ozs7Ozs7Ozs7Ozs7OztBQWVJLDBCQUFNLE9BQUU7QUFDWCxhQUFPLElBQVEsS0FBSyxLQUN0QjtBQUFDOzs7Ozs7Ozs7Ozs7OztBQWFjLDhDQUFHLElBQUU7QUFDbEIsYUFBYyxRQUFXLFdBQWdCLGdCQUFLLEtBQXFCLHNCQUNyRTtBQUNEO0FBeERpQjs7QUEwRFgsVUFBYSxjQUV0QjtBQUFJLEs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN0SUosQ0FBVTtBQUNJOzs7Ozs7Ozs7O0FBU1osTUFBa0IsY0FDVCxRQUFzQixzQkFDcEIsUUFBb0Isb0JBQ2xCLFFBQWdCLGdCQUFlOztBQXNCNUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW5DVSxNQW1DSTs7Ozs7MEJBRW9CO0FBQUUsZUFBTyxDQUFpQjs7OztBQUU5QztBQUNIOzs7O0FBQ0gsWUFBTSxPQUFNO0FBQ1osWUFBRyxJQUFNO0FBQ1QsWUFBWSxhQUNsQjs7OztBQUd5Qjs7Ozs7aURBQUU7QUFDckIsYUFBYSxjQUNuQjtBQUVrQjs7OzBDQUFFO0FBQ2QsYUFDTjtBQUVxQjs7OzZDQUFFO0FBQ2pCLGFBQ047QUFFaUI7Ozt5Q0FBRTtBQUNiLGFBQVcsV0FBYSxhQUFLLEtBQUssTUFDeEM7QUFFaUI7Ozt5Q0FBRTtBQUNkLFlBQUssS0FBVyxZQUFFO0FBQ2YsZUFBQyxJQUFLLElBQUUsR0FBRyxJQUFLLEtBQVcsV0FBTyxRQUFLLEtBQUU7QUFDdkMsaUJBQUssS0FBWSxZQUFLLEtBQVcsV0FDdkM7QUFDRjtBQUNGOzs7QUFNTzs7Ozs7Ozs7QUFBRTs7QUFDUCxZQUFZO0FBQ1QsWUFBQyxDQUFLLEtBQVcsWUFBRTtBQUNYLHFCQUFvQyxrQ0FBVSxZQUFPLEtBQWMsY0FBYTtBQUN0RixjQUFDLENBQVMsVUFBRTs7QUFFYixnQkFBYSxlQUFzQixpQkFBSSxZQUFHO0FBQy9CLHlCQUFvQyxrQ0FBSyxPQUFjLGNBQWE7QUFDMUUsa0JBQVMsVUFBRTtBQUNKLHlCQUFhO0FBQ2pCLHVCQUNOO0FBQUUscUJBQUs7QUFDTCxzQkFBTSxJQUFTLE1BQ2pCO0FBQ0Y7QUFBQyxhQVJjO0FBU1AscUJBQVEsUUFBSyxNQUFFLEVBQVUsV0FBUTtBQUUzQzs7QUFDSSxlQUFNLE9BQU0sS0FBZSxlQUFVO0FBQ3JDLGVBQUcsSUFBTSxLQUFLLEtBQUU7QUFDaEIsZUFBWSxhQUFJO0FBQ2hCLGVBQUMsSUFBSyxJQUFLLEtBQUssS0FBVyxZQUFHLEdBQUcsSUFBRSxFQUFZLGFBQUU7QUFDL0MsaUJBQVcsV0FBSyxLQUFXLFdBQVMsVUFDMUM7O0FBQ0ksZUFDTjs7QUFDSSxhQUFtQjtBQUNuQixhQUFjLGtCQUFnQixZQUFhO0FBQ3RDLG1CQUFNO0FBQ0wsb0JBRVo7QUFKbUQsU0FBOUI7QUFNdkI7Ozs7SUF2RWdDOztBQXlFbEIsaUJBQU8sT0FBVyxZQUVsQztBQUFJLEs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDaEhOLENBQVU7QUFDSTs7QUFFWixNQUF5Qix1QkFBUyxRQUFxQjs7Ozs7OztBQU92RCxNQUFvQixnQkFBUyxRQUFvQixvQkFBUSxRQUFTOztBQWlHbEU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTNHVSxNQTJHTTs7Ozs7Ozs7QUFJQTswQkFBRTtBQUFFLGVBQXFCO0FBRW5COzs7MEJBQUU7QUFBRSxlQUFhO0FBRWY7OzswQkFBRTs7Ozs7Ozs7O0FBU3RCOzs7Ozs7QUFNTztBQUNDLGtCQUNMO0FBRk07Ozs7OztBQVFMO0FBQ0ksa0JBQVE7QUFDUCxtQkFDTjtBQUhHOzs7Ozs7OztBQVdHO0FBQ0Qsa0JBQVE7QUFDUCxtQkFDTjtBQUhROzs7Ozs7OztBQVdHO0FBQ04sa0JBQVE7QUFDUCxtQkFDTjtBQUhhOzs7Ozs7Ozs7QUFZVjtBQUNFLGtCQUFVO0FBQ04sc0JBQ1Q7QUFISzs7Ozs7Ozs7O0FBWUE7QUFDQSxrQkFBVTtBQUNOLHNCQUNUO0FBSE87Ozs7Ozs7OztBQVlEO0FBQ0Qsa0JBQVE7QUFDSixzQkFDVDtBQUhROzs7Ozs7Ozs7QUFZSixpQkFBUTs7Ozs7Ozs7QUFRSTtBQUNYLGtCQUFRO0FBQ04sb0JBQU07QUFDSixzQkFDVDtBQUprQjs7Ozs7Ozs7O0FBYVA7QUFDTixrQkFBUTtBQUNKLHNCQUNUO0FBSGE7Ozs7Ozs7Ozs7QUFhQztBQUNULGtCQUFRO0FBQ1AsbUJBQ047QUFIZ0I7O0FBS0Q7QUFDVixrQkFBUTtBQUNKLHNCQUtkO0FBUHNCOztBQTNIYjtBQW9JWTs7OzBCQUFFO0FBQ3JCLGVBQU8sQ0FDVDs7OztBQUVZO0FBQ0g7Ozs7QUFDSCxZQUFhLGNBQUk7QUFDakIsWUFBUyxVQUFVO0FBQ25CLFlBQVEsU0FBSTtBQUNaLFlBQW1CLG9CQUFNO0FBQ3pCLFlBQXFCLHNCQUFJO0FBQ3pCLFlBQWMsZUFBTTtBQUNwQixZQUFpQixrQkFBTTtBQUN2QixZQUFVLFdBQU07QUFDaEIsWUFBWSxhQUFNO0FBQ2xCLFlBQWdCLGlCQUFNO0FBQ3RCLFlBQVEsU0FBTTtBQUNkLFlBQWMsZUFBTTtBQUNwQixZQUFVLFdBQ2hCOztBQUVxQjs7Ozs2Q0FBRTtBQUNPO0FBQ3hCLGFBQWMsZUFBTTtBQUNwQixhQUFDLElBQUssSUFBRSxHQUFHLElBQUssS0FBWSxZQUFPLFFBQUssS0FBRTtBQUN4QyxlQUFpQixpQkFDdkI7QUFDRjtBQUVrQjs7OzBDQUFFO0FBQ087O0FBRXRCLFlBQUssS0FBYSxjQUFFO0FBQ2pCLGVBQWMsZUFBTztBQUN6QixjQUFXLFNBQU0sS0FBVztBQUN4QixlQUFDLElBQUssSUFBRSxHQUFHLElBQUssS0FBWSxZQUFPLFFBQUssS0FBRTtBQUN4QyxpQkFBaUIsaUJBQUUsR0FDekI7QUFDRjtBQUNGO0FBRW9COzs7O0FBQUU7Ozs7O0FBSWpCLFlBQUMsQ0FBSyxLQUFPLFFBQUU7QUFDaEIsY0FBYSxXQUFNLEtBQVUsV0FBTSxLQUFjLGNBQVk7QUFDMUQsY0FBQyxDQUFTLFVBQUU7O0FBRWIsZ0JBQWEsZUFBc0IsaUJBQUksWUFBRztBQUNyQyxrQkFBSyxPQUFjLGNBQVksYUFBRTtBQUMxQix5QkFBYTtBQUNqQix1QkFDTjtBQUFFLHFCQUFLO0FBQ0wsc0JBQU0sSUFBUyxNQUNqQjtBQUNGO0FBQUMsYUFQYztBQVFQLHFCQUFRLFFBQUssTUFBRSxFQUFVLFdBQVE7QUFDekMsbUJBQ0Y7OztBQUVBLGNBQWtCLGdCQUFJO0FBQ1Qsd0JBQUssS0FBSyxNQUFNO0FBQ2hCLHdCQUFLLEtBQVUsV0FBTTtBQUNyQix3QkFBSyxLQUFlLGdCQUFNO0FBQ25DLGVBQVEsaUJBQW9CLFdBQVcsV0FBUyxVQUFNO0FBQzdDLHlCQUFNLEtBQVk7QUFDbEIseUJBQU07QUFDSiwyQkFBZTs7Ozs7O0FBTWIsNkJBQVUseUJBQUssTUFBTyxPQUFFO0FBQ3JDLGtCQUFPLEtBQU0sS0FBWTtBQUNyQixtQkFBQyxJQUFLLElBQUUsR0FBTSxNQUFJLElBQUcsR0FBWSxNQUFqQixLQUFzQixPQUFHLEdBQUksS0FBSyxLQUFFO0FBQ2xELHFCQUFnQixnQkFBSyxNQUMzQjtBQUNGO0FBQUM7Ozs7Ozs7QUFPaUIsZ0NBQVUsNEJBQUssTUFBTSxNQUFPLE9BQUU7QUFDM0Msa0JBQVEsUUFBSyxLQUFRLFFBQUssS0FBRyxJQUFPLE9BQUU7QUFDdkMsb0JBQVEsTUFBTSxLQUFLLEtBQWM7QUFDOUIsb0JBQU0sUUFBTyxLQUFHLElBQUU7QUFDZix1QkFBTSxNQUFNLE9BQ2xCOztBQUNBLG9CQUFTLE9BQVMsUUFBSyxLQUFVLFVBQUssS0FBRyxJQUFXLFdBQUssS0FBTztBQUM1RCxxQkFBVyxXQUFLLE1BQ3RCO0FBQ0Y7QUFFSjtBQWhDOEQsV0FBdkM7O0FBaUN2QixlQUNGO0FBRWdCOzs7d0NBQUU7Ozs7OztBQU1oQixlQUFXLEtBQVcsV0FBYSxlQUFPLEtBQzVDO0FBRWE7OztvQ0FBSyxNQUFFO0FBQ2xCLFlBQWUsYUFBTSxLQUFrQjtBQUNuQyxhQUFVLG9CQUFXLE9BQVksUUFBYyxhQUFPLE9BQy9DLFlBQUU7QUFBRSxpQkFBaUIsV0FBTSxNQUFNLE1BQVcsWUFBYztBQUFFLFNBRC9DO0FBRXJCLFlBQUssS0FBTSxPQUFFO0FBQ1YsZUFBaUIsaUJBQUssS0FDNUI7QUFDRjtBQUVlOzs7c0NBQU8sUUFBRTtBQUN0QixZQUFlLGFBQU0sS0FBa0I7QUFDbkMsYUFBWSx3QkFBYSxPQUFjLFVBQWMsYUFBUyxTQUN2RCxZQUFFO0FBQUUsaUJBQWlCLFdBQVEsUUFBTSxNQUFXLFlBQWM7QUFBRSxTQUQ3QztBQUV6QixZQUFLLEtBQU0sT0FBRTtBQUNWLGVBQWlCLGlCQUFLLEtBQzVCO0FBQ0Y7QUFFa0I7Ozt5Q0FBSyxNQUFFO0FBQ3ZCLGVBQVcsS0FBSyxLQUFLLE9BQ3ZCO0FBRXFCOzs7NkNBQUU7QUFDbEIsWUFBSyxLQUFhLGNBQUU7QUFDakIsZUFBUyxVQUFNLEtBQWE7QUFDNUIsZUFBYyxlQUFNLEtBQWE7QUFDakMsZUFBaUIsa0JBQWEsWUFDcEM7QUFDRjtBQUVpQjs7O3lDQUFFOzs7QUFHZCxZQUFLLEtBQU8sU0FBTyxLQUFTLFVBQU0sS0FBTSxNQUFPLFFBQUU7QUFDOUMsZUFBaUIsaUJBQUssS0FDNUI7QUFDRjtBQUVxQjs7OztBQUFFOztBQUNBO0FBQUcsaUJBQU0sT0FDaEM7O0FBRWM7OztzQ0FBRTs7OztBQUlkLFlBQWtCLGdCQUFhLFlBQU07QUFDckMsWUFBVSxRQUFNLEtBQW9CLG9CQUFlLGdCQUFNLEtBQWlCO0FBQ3RFLGFBQWMsZUFBTSxLQUFNLE1BQUssS0FBYyxlQUFTLFVBQUk7QUFDMUQsYUFBUyxXQUFPLEtBQWE7QUFDN0IsYUFBaUIsa0JBQWU7QUFDaEMsYUFBaUIsaUJBQUssS0FDNUI7QUFFaUI7Ozt5Q0FBRTtBQUNiLGFBQWdCLGlCQUFNLEtBQVMsV0FDN0IsS0FBUSxRQUFRLFFBQUssTUFBTSxLQUFNLE1BQ3pDO0FBRWM7OztxQ0FBTyxRQUFFO0FBQ2xCLFlBQUssS0FBTyxTQUFHLENBQU0sTUFBUSxRQUFLLEtBQU8sUUFBRTtBQUNyQyxrQkFBSyxLQUErQyxnREFBTSxLQUNuRTs7OztBQUdHLFlBQUMsQ0FBSyxLQUFpQixpQkFBTyxPQUFLLE1BQVEsT0FBTyxRQUFFOzs7QUFHakQsZUFBdUI7QUFDdkIsZUFBaUIsaUJBQUssS0FDNUI7QUFDRjtBQUVxQjs7OzRDQUFLLE1BQUU7QUFDdkIsWUFBSyxLQUFlLGdCQUFFO0FBQ2xCLGlCQUFNLEtBQVUsVUFBSyxLQUFRLFFBQU0sT0FBSTtBQUM1QyxjQUFVLFFBQU0sS0FBZTtBQUMzQixlQUFDLElBQUssSUFBRSxHQUFHLElBQU0sTUFBTyxRQUFLLEtBQUU7QUFDOUIsZ0JBQUssS0FBUSxRQUFNLE1BQUssUUFBSyxHQUFFO0FBQzVCLG1CQUFpQixpQkFBSyxLQUFTLFVBQU0sS0FBTztBQUNoRCxxQkFDRjtBQUNGO0FBQ0Y7QUFDRjs7O0FBTWdCOzs7Ozs7O3VDQUFHO0FBQWEsWUFBTCw0RUFBRzs7QUFDeEIsYUFBbUIsb0JBQVMsUUFBVSxVQUFTLFNBQ3pDLEtBQ04sbUJBQVEsUUFBSSxJQUFTLFFBQU0sTUFBUSxRQUFNLE1BQVEsU0FBUyxRQUFNLE1BQ2hFLFdBQUksR0FBSyxLQUFPO0FBQ2IsZ0JBQWlCLGlCQUFLLEtBQy9COzs7QUFTTzs7Ozs7Ozs7OzsrQkFBRTs7QUFFSCxhQUFpQixpQkFBSyxLQUFVO0FBQzdCLGdCQUNUO0FBRVM7OztpQ0FBRTtBQUNOLFlBQUMsQ0FBSyxLQUFzQix1QkFBRTs7QUFHakM7O0FBQ0ksYUFBcUI7Ozs7OztBQU1yQixhQUFPLE9BQVEsU0FBRzs7QUFFbEIsYUFBc0Isc0JBQUssS0FBWSxZQUFROztBQUUvQyxhQUFjLGtCQUFnQixZQUFhO0FBQ3RDLG1CQUFNO0FBQ0wsb0JBQ1A7QUFIOEMsU0FBOUI7O0FBS2YsYUFDTjtBQUVtQjs7OztBQUFFOztBQUNuQixZQUFVLFFBQU0sS0FBTyxTQUFLO0FBQzVCLFlBQXNCLG9CQUFFLElBQVMsTUFBTSxNQUFRO0FBQzNDLGFBQUMsSUFBSyxJQUFFLEdBQUcsSUFBTSxNQUFPLFFBQUssS0FBRTtBQUNoQiw0QkFBSSxLQUN2Qjs7O0FBRUcsWUFBSyxLQUFXLFlBQUU7QUFDRCxnREFBMEIsaUJBQUcsR0FBSyxLQUFTO0FBQWhCLG1CQUN2QyxPQUFXLFdBQU0sTUFBRyxJQUFLLEtBQ2pDO1dBRnVDOzs7QUFJcEMsWUFBSyxLQUFTLFVBQUU7QUFDQSw0QkFBSyxlQUFHLEdBQUs7QUFBUCxtQkFBYyxPQUFTLFNBQU0sTUFBRyxJQUFPLE1BQ2hFOzs7O0FBRUEsWUFBd0Isb0JBQU0sS0FBcUIsc0JBQUk7QUFDdkQsWUFBWSxVQUFHOztBQUVmLFlBQVksUUFBTSxLQUFJLElBQWtCLGtCQUFPLFFBQU0sS0FBUztBQUN6RCxlQUFTLFVBQU0sT0FBVyxXQUFFO0FBQy9CLGNBQVMsT0FBTSxLQUFZLFlBQVM7QUFDcEMsY0FBWSxVQUFtQixrQkFBUztBQUN4QyxjQUFTLE9BQU8sTUFBUztBQUNSLDRCQUFVLFdBQVM7QUFDakMsY0FBTSxRQUFXLFVBQU0sS0FBUSxTQUFFO0FBQzlCLGlCQUFvQixvQkFBSyxLQUFHLElBQU87QUFDbkMsaUJBQW9CLG9CQUFLLEtBQVEsU0FBVTtBQUMzQyxpQkFBb0Isb0JBQUssS0FBYSxjQUFVO0FBQ2hELGlCQUNOO0FBQUUsaUJBQUs7QUFDRCxpQkFBaUIsaUJBQUssTUFBUyxTQUNyQztBQUNGOzs7QUFFSSxhQUFDLElBQUssS0FBSyxLQUFZLFlBQU8sU0FBRSxHQUFHLE1BQVMsU0FBSyxNQUFFO0FBQ2pELGVBQTBCLDBCQUNoQztBQUNGO0FBRWdCOzs7dUNBQUksS0FBRTtBQUNwQixZQUFTLE9BQU0sS0FBWSxZQUFLO0FBQzVCLGFBQUMsSUFBSyxJQUFFLEdBQUcsSUFBSyxLQUFTLFNBQU8sUUFBSyxLQUFFO0FBQ3pDLGNBQU8sS0FBTSxLQUFTLFNBQUc7QUFDckIsZUFBSyxLQUFZLFlBQ3ZCOztBQUNBLGVBQ0Y7QUFFZ0I7Ozt1Q0FBSSxLQUFRLFFBQUU7QUFDNUIsWUFBUyxPQUFNLEtBQVksWUFBSztBQUMxQixlQUFhLGFBQUssS0FBSyxNQUMvQjtBQUV5Qjs7O2dEQUFJLEtBQUU7QUFDN0IsWUFBUyxPQUFNLEtBQWlCLGlCQUFLO0FBQ2xDLFlBQUssTUFBRTtBQUNKLGVBQU8sT0FBSyxLQUNsQjs7QUFDSSxhQUFZLFlBQU8sT0FBSSxLQUM3QjtBQUVlOzs7c0NBQUssTUFBUyxTQUFTLFNBQUU7QUFDdEMsWUFBVSxRQUFJO0FBQ1QsY0FBSyxLQUFLLE1BQU07QUFDaEIsY0FBSyxLQUFVLFdBQVM7QUFDeEIsY0FBSyxLQUFlLGdCQUFTO0FBQ2xDLGVBQU8sSUFBUSxLQUFPLE9BQ3hCO0FBRWdCOzs7dUNBQUssTUFBUyxTQUFTLFNBQUU7QUFDdkMsWUFBUyxPQUFNLEtBQU8sT0FBTTtBQUN6QixZQUFLLE1BQUU7OztBQUdKLGVBQW9CLG9CQUFLLEtBQUcsSUFBTztBQUNuQyxlQUFvQixvQkFBSyxLQUFRLFNBQVU7QUFDM0MsZUFBb0Isb0JBQUssS0FBYSxjQUFVO0FBQ2hELGVBQ047QUFBRSxlQUFLO0FBQ0EsaUJBQU0sS0FBZ0IsZ0JBQUssTUFBUyxTQUMzQzs7QUFDQSxZQUFjLFlBQU0sS0FBWSxZQUFTLFVBQUk7QUFDN0MsWUFBZSxhQUFZLFlBQVcsVUFBUyxTQUFJLEtBQU07QUFDckQsYUFBVyxXQUFhLGFBQUssS0FBSyxNQUFhO0FBQy9DLGFBQVksWUFBVSxXQUFNO0FBQ2hDLGVBQ0Y7OztBQUdpQjs7Ozt3Q0FBTyxRQUFFO0FBQ3BCLGFBQUMsSUFBSyxJQUFFLEdBQUcsSUFBSyxLQUFZLFlBQU8sUUFBSyxLQUFFO0FBQ3hDLGVBQVksWUFBRyxHQUFrQixrQkFDdkM7QUFDRjs7OztBQUlnQjs7Ozt1Q0FBSyxNQUFPO0FBQzFCLFlBQWMsWUFBTSxLQUFNLE1BQUcsR0FERDtBQUU1QixZQUFRLE1BQVcsVUFBUSxRQUFLO0FBQ2hDLFlBQWEsV0FBTSxNQUFJLElBQVksWUFBVyxVQUFVLFVBQUUsR0FBTTs7QUFFN0QsWUFBVSxZQUFXLFNBQVMsVUFBSyxLQUFFO0FBQ3RDLGNBQWdCLGNBQU0sTUFBSSxJQUFLLEtBQVcsVUFBVSxVQUFJLE1BQUc7O0FBRXZELGVBQXNCLHNCQUFhOzs7OztBQUt2QyxjQUFZLFVBQU0sS0FBb0Isb0JBQVU7QUFDaEQsY0FBUyxPQUFNLEtBQVksWUFBUztBQUNqQyxjQUFLLE1BQUU7QUFDUixnQkFBYSxXQUFNLEtBQU0sTUFBYSxjQUFNLE1BQWMsY0FBSzs7O0FBRzNELGlCQUEwQiwwQkFBUyxVQUFPLE9BQU8sT0FBTztBQUN4RCxpQkFDTjs7QUFDQSxpQkFDRjtBQUNGOzs7QUFhYzs7Ozs7Ozs7Ozs7Ozs7cUNBQUcsSUFBRTtBQUNqQixZQUFhLFdBQU0sS0FBZ0IsZ0JBQUk7QUFDdkMsZUFBZ0IsWUFBVyxTQUFLLEtBQ2xDOzs7QUFXZTs7Ozs7Ozs7Ozs7O3NDQUFHLElBQUU7QUFDbEIsWUFBYSxXQUFNLEtBQWdCLGdCQUFJO0FBQ3ZDLGVBQWdCLFlBQVcsU0FBSyxLQUNsQzs7O0FBbUJlOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztzQ0FBRyxJQUFFO0FBQ2xCLGVBQWMsUUFBVyxXQUFnQixnQkFBSyxLQUFTLFVBQ3pEO0FBRUY7Ozs7SUF4akJzQzs7QUEwakJ4QixpQkFBTyxPQUFVLFVBQUcsSUFBWTs7QUFFdkMsVUFBVyxZQUVwQjtBQUFJLEs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3pxQkosQ0FBVTtBQUNJOztBQXdCWjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF6QlUsTUF5QkU7Ozs7Ozs7O0FBSUk7MEJBQUU7QUFBRSxlQUFpQjtBQUVmOzs7MEJBQUU7QUFBRSxlQUFhO0FBRWY7OzswQkFBRTs7QUFFdEI7Ozs7Ozs7Ozs7Ozs7QUFhSTtBQUNJLGtCQUFTO0FBQ0wsc0JBQ1Q7QUFIRzs7Ozs7Ozs7O0FBWUc7QUFDRCxrQkFBUztBQUNMLHNCQUtkO0FBUGE7O0FBekJKOzs7O0FBa0NHO0FBQ0g7Ozs7QUFDSCxZQUFtQixvQkFBTTtBQUN6QixZQUFnQixpQkFBTTtBQUN0QixZQUFZLGFBQU07QUFDbEIsWUFBUyxVQUFPO0FBQ2hCLFlBQVEsU0FDZDs7QUFFaUI7Ozs7O0FBQUU7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWlCYixhQUFtQiw0QkFBbUIsVUFBUyxTQUN6QyxLQUNOLG1CQUFTLFFBQU0sTUFDZjtBQUFLLGlCQUFPLE9BQVk7U0FISTtBQUl6QixnQkFBaUIsaUJBQUssS0FDL0I7QUFFcUI7Ozs2Q0FBRTtBQUNPO0FBQ3pCLFlBQUMsQ0FBSyxLQUNMLGNBQUssS0FBVyxXQUFVLFlBQU8sS0FBd0IsMEJBQ3hELENBQUssS0FBVyxXQUFNLE1BQUU7QUFDdkIsZUFDTjtBQUNGO0FBRWtCOzs7MENBQUU7QUFDTztBQUN0QixZQUFLLEtBQUcsSUFBRTtBQUNQLGVBQ047QUFDRjs7O0FBU087Ozs7Ozs7Ozs7K0JBQUU7QUFDQSxnQkFDVDtBQUVTOzs7aUNBQUU7QUFDTixZQUFLLEtBQUcsSUFBRTtBQUNSLGNBQUMsQ0FBSyxLQUFtQixvQkFBRTs7QUFHOUI7O0FBQ0ksZUFDTjtBQUFFLGVBQVEsSUFBSyxLQUFRLFNBQUU7QUFDbkIsZUFDTjs7QUFDRyxZQUFDLENBQUssS0FBUyxXQUFPLEtBQVcsWUFBRTtBQUNoQyxlQUNOOztBQUNHLFlBQUssS0FBSSxNQUFPLEtBQVEsU0FBRTtBQUN2QixlQUFjLGtCQUFnQixZQUFhO0FBQ3RDLHFCQUFNO0FBQ0wsc0JBQ1A7QUFIOEMsV0FBOUI7QUFJZixlQUFTLFVBQU0sS0FDckI7QUFDRjtBQUVpQjs7OztBQUFFOztBQUNqQixZQUFlLGFBQU0sS0FBVzs7QUFFN0IsWUFBVyxZQUFFO0FBQ1gsY0FBQyxDQUFLLEtBQU8sUUFBRTtBQUNoQixnQkFBYSxXQUFNLEtBQWMsY0FBWTtBQUMxQyxnQkFBQyxDQUFTLFVBQUU7O0FBRWIsa0JBQWEsZUFBc0IsaUJBQUksWUFBRztBQUNyQyxvQkFBSyxPQUFjLGNBQVksYUFBRTtBQUMxQiwyQkFBYTtBQUNqQix5QkFDTjtBQUFFLHVCQUFLO0FBQ0wsd0JBQU0sSUFBUyxNQUNqQjtBQUNGO0FBQUMsZUFQYztBQVFQLHVCQUFRLFFBQUssTUFBRSxFQUFVLFdBQVE7QUFDekMscUJBQ0Y7O0FBQ0ksaUJBQVEsaUJBQW9CLFdBQVcsV0FBUyxVQUFNOzs7QUFHN0MsMkJBQU07Ozs7OztBQU1GLCtCQUFVLHlCQUFLLE1BQU8sT0FBRTtBQUNsQyxvQkFBSyxLQUFXLFlBQUU7QUFDaEIsc0JBQUssS0FBRyxJQUFFO0FBQ1AseUJBQVcsV0FBZ0IsZ0JBQUssTUFDdEM7QUFBRSx5QkFBSzs7Ozs7QUFLRCx5QkFBZ0IsaUJBQU0sS0FBZ0Isa0JBQVMsT0FBTyxPQUFNO0FBQzVELHlCQUFlLGVBQVEsUUFBSyxLQUFLLEtBQVEsU0FDL0M7QUFDRjtBQUNGO0FBRUo7QUF4QjhELGFBQXZDOztBQXlCcEIsY0FBQyxDQUFLLEtBQVcsWUFBRTtBQUNoQixpQkFBWSxhQUFFLElBQVEsS0FBUztBQUN6Qix1QkFBYSxhQUFLLEtBQVcsV0FBSyxNQUM5QztBQUFFLGlCQUFLO0FBQ0QsaUJBQXVCO0FBQzNCLGdCQUFPLEtBQU0sS0FBVyxXQUFTO0FBQzlCLGdCQUFJLE1BQUssR0FBTyxRQUFFOztBQUVuQixrQkFBYyxZQUFNLEtBQWdCO0FBQ2pDLGtCQUFXLGNBQU0sR0FBRyxHQUFPLFNBQUcsSUFBRTtBQUM3QixxQkFBQyxJQUFLLElBQUUsR0FBRyxHQUFJLElBQUcsR0FBWSxNQUFqQixLQUFtQixJQUFHLEdBQUksS0FBSyxLQUFFO0FBQ3RDLDZCQUFhLGFBQUUsR0FDM0I7QUFDRjtBQUNGO0FBQ0Y7QUFDRjs7QUFDQSxlQUNGO0FBRXFCOzs7NkNBQUU7QUFDckIsWUFBVSxRQUFNLEtBQWU7QUFDNUIsWUFBTSxPQUFFO0FBQ0wsZUFBQyxJQUFTLFFBQVEsT0FBRTtBQUNsQixpQkFBVyxXQUFvQixvQkFBSyxNQUFNLEtBQVcsV0FDM0Q7O0FBQ0ksZUFBZ0IsaUJBQU07QUFDdEIsZUFBVyxXQUNqQjtBQUNGO0FBRW1COzs7MkNBQUU7QUFDaEIsWUFBSyxLQUFXLFlBQUU7QUFDbkIsY0FBTyxLQUFNLEtBQVcsV0FBUztBQUM5QixjQUFJLE1BQUssR0FBTyxRQUFFOztBQUVuQixnQkFBVyxTQUFJLEdBQUcsR0FBVztBQUN6QixpQkFBQyxJQUFLLElBQUUsR0FBRyxHQUFJLElBQUcsR0FBWSxNQUFqQixLQUFtQixJQUFHLEdBQUksS0FBSyxLQUFFO0FBQzFDLHFCQUFZLFlBQ3BCO0FBQ0Y7O0FBQ0ksZUFBWSxhQUFNO0FBQ2xCLGVBQWdCLGlCQUN0QjtBQUNGO0FBRWtCOzs7MENBQUU7QUFDbEIsWUFBVyxTQUFNLEtBQTBCLDRCQUFHLENBQUssS0FBRztBQUNuRCxZQUFLLEtBQVcsWUFBRTtBQUNmLGVBQVcsV0FBa0Isa0JBQ25DO0FBQ0Y7QUFFRjs7OztJQS9OMkIsUUFBUzs7QUFpT3RCLGlCQUFPLE9BQU0sTUFBRyxJQUFROztBQUUvQixVQUFPLFFBRWhCO0FBQUksSzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNoUUosQ0FBVTtBQUNJOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF1QlosTUFBdUIsNkJBQXVCLGNBQVk7Ozs7Ozs7QUFPeEQsUUFBZ0IsY0FBUyxRQUFhLGFBQVk7O0FBUWxEOzs7Ozs7O0FBZjJELFFBZWxDOzs7Ozs0QkFFQzs7QUFFdEI7Ozs7O0FBS087QUFDQyxvQkFDTDtBQUZNOzs7Ozs7O0FBU0Y7QUFDQyxvQkFBUztBQUNSLHFCQUNOO0FBSE07Ozs7Ozs7O0FBV0M7QUFDRixvQkFBUTtBQUNOLHNCQUNQO0FBSFM7Ozs7Ozs7QUFVRTtBQUNOLG9CQUFRO0FBQ04sc0JBQ1A7QUFIYTs7Ozs7O0FBU1I7QUFDQSxvQkFBUztBQUNSLHFCQUlYO0FBTlk7O0FBNUNIO0FBb0RZOzs7NEJBQUU7QUFDckIsaUJBQU8sQ0FDVDs7OztBQUVZO0FBQ0g7Ozs7QUFDSCxjQUFhLGNBQU07QUFDbkIsY0FBYSxjQUFNO0FBQ25CLGNBQWUsZ0JBQ3JCOztBQUVpQjs7OzswQ0FBTSxPQUFXLFdBQUU7QUFDbEMsY0FBUyxPQUFXLFVBQUs7QUFDdEIsY0FBTSxRQUFVLFNBQUU7OztBQUduQixnQkFBYSxXQUFXLFVBQU0sUUFBSztBQUNuQyxnQkFBYyxZQUFNLEtBQVk7QUFDaEMsZ0JBQWMsWUFBTSxLQUFZO0FBQzdCLGdCQUFPLFVBQWEsV0FBRTtBQUNuQixtQkFDTjs7QUFDRyxnQkFBVSxXQUFFO0FBQ2Isa0JBQVksVUFBUyxRQUFZLFlBQWlCLGlCQUFTLFVBQVk7QUFDbkUsbUJBQWUsZUFDckI7O0FBQ0ksaUJBQWEsY0FBVTtBQUN2QixpQkFBYSxjQUNuQjtBQUFFLHFCQUFrQixVQUFNLFFBQWtCLGlCQUFFOzs7QUFHeEMsaUJBQWUsZUFBVSxVQUFNLE1BQ3JDO0FBQUUsV0FKUSxNQUlIOzs7QUFHTCxnQkFBUyxPQUFNLEtBQU0sTUFBUyxTQUFRO0FBQ3RDLGdCQUFRLE1BQVUsU0FBSyxNQUFLO0FBQ3pCLGdCQUFNLEtBQVEsUUFBTSxPQUFLLENBQXhCLElBQWdDLFFBQU0sS0FBRTtBQUN0QyxtQkFBcUIscUJBQzNCO0FBQ0Y7QUFDRjtBQUVjOzs7dUNBQVE7QUFBRTs7QUFDdEIsY0FBYSxXQUFNLEtBQWM7Ozs7QUFHL0IsZ0JBQU0sSUFBUyxRQUFHO0FBQ1YscUJBQVEsUUFBQyxVQUFJLEtBQVEsTUFBRztBQUMzQixrQkFBSyxNQUFHLEVBQU0sT0FBRTtBQUVuQjtBQUFFLHlCQUFhLE9BQUksRUFBTyxRQUFHLEVBQVEsUUFBTyxRQUFFOztBQUVwQyx5QkFBSSxJQUFLLE1BQU0sTUFBRyxFQUFZLGFBQUcsRUFBUSxRQUNuRDtBQUFFLGVBSFEsTUFHSDs7QUFFRyx5QkFBSSxJQUFLLE1BQUUsQ0FDckI7QUFDRjtBQUFFO0FBQ0UsaUJBQUMsSUFBSyxJQUFFLEdBQUcsSUFBRSxFQUFXLFlBQUssS0FBRTtBQUNqQyxrQkFBUSxNQUFHLEVBQU8sUUFBRztBQUNsQixrQkFBUyxTQUFJLElBQUssT0FBTSxNQUFNLE9BQUU7QUFDekIseUJBQUksSUFBSyxPQUFNLE1BQUssTUFDOUI7QUFDRjtBQUNGOzs7QUFuQkksZUFBQyxRQUFPLEdBQUcsSUFBUSxRQUFPLFFBQUs7QUFBRSxrQkFBM0I7OztBQXFCTixlQUFnQjs7QUFFcEIsY0FBUyxPQUFHO0FBQ0osbUJBQVEsUUFBQyxVQUFJLEtBQVEsTUFBRztBQUMzQixnQkFBSyxNQUFHLEdBQUU7QUFDUixrQkFBSyxPQUFNLE9BQUU7QUFDVix1QkFBTyxPQUFXLFlBQU0sTUFDOUI7QUFBRSxxQkFBSztBQUNELHVCQUFVLFdBQU0sT0FBYyxlQUNwQzs7QUFDUSx1QkFBTyxPQUNqQjtBQUFFLG1CQUFLO0FBRVA7QUFDRjtBQUNGO0FBRWM7Ozs7QUFBRTs7QUFDVixlQUFtQixvQkFBSTtBQUN4QixjQUFLLEtBQU0sT0FBRTtBQUNkLGdCQUFTLE9BQUc7QUFDUixpQkFBYyxjQUFRLFFBQUssZUFBRztBQUM3QixrQkFBSyxPQUFJLEdBQUU7QUFDUix1QkFBVSxVQUFVLFdBQUssS0FBYyxjQUM3QztBQUNGO0FBQ0Y7QUFBRSxpQkFBSztBQUNELGlCQUFjLGNBQVEsUUFBSyxlQUFHO0FBQzVCLHFCQUFVLFVBQVcsWUFBVyxXQUFNO0FBQ3RDLHFCQUFVLFVBQWUsZ0JBQVcsV0FDMUM7QUFDRjtBQUNGOzs7QUFNZTs7Ozs7Ozt5Q0FBRTs7QUFFWCxlQUFtQixvQkFBSTs7Ozs7QUFLdkIsZUFBZSxnQkFBRSxJQUFTOztBQUUxQixlQUFVLFdBQU0sS0FBTyxRQUFLLEtBQUU7QUFDOUIsZUFBYyxlQUNwQjs7O0FBUVU7Ozs7Ozs7OzttQ0FBSyxNQUFFO0FBQ2YsaUJBQVcsS0FBYyxjQUFJLElBQy9COzs7QUFRZTs7Ozs7Ozs7O3dDQUFJLEtBQUU7QUFDbkIsaUJBQVcsS0FBVyxXQUFLLEtBQU0sTUFDbkM7QUFFb0I7Ozs2Q0FBSTtBQUFFOztBQUN4QixjQUFTLE9BQU0sS0FBNEIsNEJBQUs7QUFDN0MsY0FBTSxRQUFJLEdBQUU7QUFDYixnQkFBTSxJQUFHO0FBQ0wsaUJBQWMsY0FBUSxRQUFDLFVBQUksS0FBUSxNQUFHO0FBQ3JDLGtCQUFNLFFBQU0sS0FBRTtBQUNYLHVCQUFTLFNBQ2Y7QUFDRjtBQUNGO0FBQ0Y7QUFFMkI7OztvREFBSSxLQUFFO0FBQy9CLGNBQWEsV0FBTSxLQUFrQixrQkFBVSxXQUFNO0FBQ2xELGNBQVMsVUFBRTtBQUNaLG1CQUFlLFNBQVMsU0FBTSxNQUFZLFlBQVEsU0FDcEQ7QUFDRjs7O0FBT1E7Ozs7Ozs7O2lDQUFLLE1BQUU7QUFDYixjQUFRLE1BQU0sS0FBYyxjQUFJLElBQU07QUFDbkMsY0FBSyxPQUFJLEdBQUU7QUFDUixpQkFBYyxjQUFPLE9BQU07QUFDL0IsZ0JBQVE7QUFDTCxnQkFBSyxLQUFNLE9BQUU7QUFDVCxxQkFBTSxLQUE0Qiw0QkFDekM7O0FBQ0ksaUJBQWdCO0FBQ2pCLGdCQUFLLEtBQU0sT0FBRTtBQUNWLG1CQUFPLE9BQVcsWUFBTSxNQUM5QjtBQUFFLG1CQUFLO0FBQ0QsbUJBQVUsV0FBTSxLQUFjLGVBQ3BDO0FBQ0Y7QUFDRjs7O0FBT2E7Ozs7Ozs7O3NDQUFJLEtBQUU7QUFDYixlQUFTLFNBQUssS0FBTSxNQUMxQjs7O0FBUU07Ozs7Ozs7OzsrQkFBSyxNQUFFO0FBQ1AsZUFBWSxZQUFLLEtBQU0sTUFBUSxRQUNyQzs7O0FBUVc7Ozs7Ozs7OztvQ0FBSSxLQUFFO0FBQ2YsY0FBUyxPQUFNLEtBQU0sTUFBSztBQUN2QixjQUFDLENBQUssS0FBVyxXQUFNLE9BQUU7QUFDdkIsZ0JBQUMsQ0FBSyxLQUFNLE9BQUU7QUFDWCxtQkFBYyxjQUNwQjs7QUFDSSxpQkFBYyxjQUFJLElBQUssTUFBTTtBQUM3QixpQkFBZ0I7QUFDakIsZ0JBQUssS0FBTSxPQUFFO0FBQ1YsbUJBQUssS0FBVyxZQUN0QjtBQUFFLG1CQUFLO0FBQ0QsbUJBQVUsV0FBTSxLQUFjLGVBQ3BDO0FBQ0Y7QUFBRSxpQkFBUSxJQUFLLEtBQU8sUUFBRTtBQUNsQixpQkFBYyxjQUNwQjtBQUNGO0FBRUY7Ozs7TUFwUndCOztBQXNSeEIsV0FFRjtBQUFFLEdBelM4Qjs7O0FBNFN6QixVQUFvQixxQkFBb0I7Ozs7Ozs7QUFPL0MsTUFBc0Isb0JBQW9CLG1CQUFRLFFBQVM7O0FBcUUzRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFoWlUsTUFnWlU7Ozs7Ozs7Ozs7Ozs7QUFHSjswQkFBRTtBQUFFLGVBQXdCO0FBQzVDOzs7O0lBSjhDOztBQUtoQyxpQkFBTyxPQUFjLGNBQUcsSUFBZ0I7QUFDL0MsVUFBZSxnQkFFeEI7QUFBSSxLOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMzWkosQ0FBVTtBQUNJOztBQUVaLE1BQVcsT0FBVzs7QUFFdEIsTUFBMkIsdUJBQVEsT0FBUyxTQUFxQjs7QUFzQmpFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUEzQlUsTUEyQlE7OztBQUNKO0FBQ0g7Ozs7QUFDSCxZQUFRLFNBQU07QUFDRSwyQkFDdEI7OztBQVFTOzs7Ozs7Ozs7OztpQ0FBRTtBQUNOLFlBQUssS0FBTyxRQUFFO0FBQ2YsaUJBQVcsS0FDYjs7QUFDQSxZQUFZLFFBQWlDLCtCQUFLLEtBQWMsY0FBVTtBQUN2RSxZQUFDLENBQU0sT0FBRTtBQUNWLGlCQUNGOztBQUNJLGFBQVEsU0FBTztBQUNuQixZQUFjLFVBQU8sTUFBYSxhQUFNO0FBQ3JDLFlBQVEsU0FBRTtBQUNOLGdCQUFnQixnQkFBTTtBQUN0QixnQkFBYSxjQUFTLFFBQVksWUFBZSxlQUFVLFdBQU8sTUFDekU7O0FBQ0EsZUFBVyxLQUNiO0FBQ0Y7Ozs7SUE3QnNDOztBQStCaEMsU0FBZSxlQUFPLE9BQWUsZ0JBQWM7QUFDbEQsVUFBYSxjQUN0QjtBQUFJLEs7Ozs7Ozs7OztBQ3ZFSixtQkFBQTFLLENBQVEsRUFBUixFOzs7Ozs7Ozs7QUNEQSxDQUFDLFlBQVU7QUFBQzs7Ozs7Ozs7QUFTWjtBQUFhLE1BQUl1QixJQUFFLEVBQUVzQyxPQUFPQyxRQUFQLElBQWlCRCxPQUFPQyxRQUFQLENBQWdCQyxLQUFuQyxDQUFOO0FBQUEsTUFBZ0RwQyxDQUFoRCxDQUFrRCxTQUFTRSxDQUFULENBQVdaLENBQVgsRUFBYTtBQUFDVSxRQUFFVixLQUFHQSxFQUFFaUQsaUJBQUwsR0FBdUIsQ0FBQyxDQUF4QixHQUEwQjNDLEtBQUcsRUFBRTRDLFVBQVVDLFNBQVYsQ0FBb0I5QixLQUFwQixDQUEwQiwyQkFBMUIsS0FBd0QsQ0FBQ3VCLE9BQU9RLEdBQWhFLElBQXFFLENBQUNBLElBQUlDLFFBQTFFLElBQW9GLENBQUNELElBQUlDLFFBQUosQ0FBYSxZQUFiLEVBQTBCLGtCQUExQixDQUF2RixDQUEvQjtBQUFxSyxVQUFPQyxRQUFQLElBQWlCLEtBQUssQ0FBTCxLQUFTVixPQUFPVSxRQUFQLENBQWdCQyxTQUExQyxHQUFvRDdDLElBQUVrQyxPQUFPVSxRQUFQLENBQWdCQyxTQUF0RSxHQUFnRlgsT0FBT1UsUUFBUCxJQUFpQjFDLEVBQUVnQyxPQUFPVSxRQUFULEdBQW1CVixPQUFPVSxRQUFQLEdBQWdCLEtBQUssQ0FBekQsSUFBNEQxQyxFQUFFZ0MsT0FBT1ksYUFBUCxJQUFzQlosT0FBT1ksYUFBUCxDQUFxQkMsS0FBN0MsQ0FBNUksQ0FBZ00sSUFBSTlDLElBQUVELENBQU4sQ0FBUSxTQUFTekIsQ0FBVCxDQUFXZSxDQUFYLEVBQWFJLENBQWIsRUFBZTtBQUFDLFNBQUksSUFBSUcsQ0FBUixJQUFhSCxDQUFiO0FBQWUsZUFBT0csQ0FBUCxHQUFTUCxFQUFFOEYsS0FBRixDQUFRMkMsY0FBUixDQUF1QmxJLENBQXZCLENBQVQsR0FBbUNQLEVBQUU4RixLQUFGLENBQVE0QyxXQUFSLENBQW9CbkksQ0FBcEIsRUFBc0JILEVBQUVHLENBQUYsQ0FBdEIsQ0FBbkM7QUFBZjtBQUE4RSxJQUFDLElBQUk2RSxJQUFFLElBQU47QUFBQSxNQUFXdkUsSUFBRStCLE9BQU95RSxXQUFQLElBQW9CekUsT0FBT3lFLFdBQVAsQ0FBbUJDLFNBQXZDLElBQWtELElBQS9EO0FBQUEsTUFBb0VwSSxDQUFwRSxDQUFzRSxTQUFTYSxDQUFULEdBQVk7QUFBQyxRQUFJQyxJQUFFSyxDQUFOLENBQVFvSCxzQkFBc0IsWUFBVTtBQUFDNUcsVUFBRUEsRUFBRWIsQ0FBRixDQUFGLElBQVFvRixNQUFJQSxJQUFFLElBQUlsRCxPQUFKLENBQVksVUFBU2xDLENBQVQsRUFBVztBQUFDZCxZQUFFYyxDQUFGO0FBQUksT0FBNUIsQ0FBRixFQUFnQyxlQUFhaEMsU0FBUzBKLFVBQXRCLEdBQWlDeEksR0FBakMsR0FBcUNsQixTQUFTWSxnQkFBVCxDQUEwQixrQkFBMUIsRUFBNkMsWUFBVTtBQUFDLHVCQUFhWixTQUFTMEosVUFBdEIsSUFBa0N4SSxHQUFsQztBQUFzQyxPQUE5RixDQUF6RSxHQUEwS2tHLEVBQUUxQyxJQUFGLENBQU8sWUFBVTtBQUFDMUMsYUFBR0EsR0FBSDtBQUFPLE9BQXpCLENBQWxMO0FBQThNLEtBQS9PO0FBQWlQLElBQUMsSUFBSWlCLElBQUUsSUFBTjtBQUFBLE1BQVdaLElBQUUsSUFBYixDQUFrQixTQUFTZSxDQUFULEdBQVk7QUFBQyxTQUFLc0ksWUFBTCxHQUFrQixFQUFsQixDQUFxQixLQUFLeEIsUUFBTCxHQUFjLENBQUMsQ0FBZjtBQUFpQixZQUFTM0csQ0FBVCxDQUFXdkIsQ0FBWCxFQUFhO0FBQUMsS0FBQ0EsRUFBRWtJLFFBQUgsSUFBYTdILENBQWIsS0FBaUJMLEVBQUVrSSxRQUFGLEdBQVcsQ0FBQyxDQUFaLEVBQWNuSSxHQUEvQjtBQUFvQyxLQUFFMEUsU0FBRixDQUFZbkUsQ0FBWixHQUFjLFVBQVNOLENBQVQsRUFBVztBQUFDQSxNQUFFMkosZ0JBQUYsS0FBcUIzSixFQUFFMkosZ0JBQUYsR0FBbUIsQ0FBQyxDQUFwQixFQUFzQixLQUFLRCxZQUFMLENBQWtCNUksSUFBbEIsQ0FBdUJkLENBQXZCLENBQXRCLEVBQWdEdUIsRUFBRSxJQUFGLENBQXJFO0FBQThFLEdBQXhHLENBQXlHSCxFQUFFcUQsU0FBRixDQUFZckUsQ0FBWixHQUFjLFVBQVNKLENBQVQsRUFBVztBQUFDLFFBQUdBLEVBQUU0SixxQkFBTCxFQUEyQixPQUFPNUosRUFBRTRKLHFCQUFULENBQStCLElBQUl4SixDQUFKLENBQU1KLEVBQUU2SixRQUFGLEdBQVd6SixJQUFFSixFQUFFNkosUUFBRixFQUFiLEdBQTBCekosSUFBRUosQ0FBNUIsQ0FBOEIsT0FBT0ksQ0FBUDtBQUFTLEdBQWpJO0FBQ3RrQ2dCLElBQUVxRCxTQUFGLENBQVl6RSxDQUFaLEdBQWMsWUFBVTtBQUFDLFNBQUksSUFBSUEsSUFBRSxLQUFLMEosWUFBWCxFQUF3QnRKLElBQUUsQ0FBOUIsRUFBZ0NBLElBQUVKLEVBQUVRLE1BQXBDLEVBQTJDSixHQUEzQyxFQUErQztBQUFDLFVBQUlHLElBQUVQLEVBQUVJLENBQUYsQ0FBTixDQUFXLElBQUcsQ0FBQ0csRUFBRXFKLHFCQUFOLEVBQTRCO0FBQUMsWUFBSW5KLElBQUUsS0FBS0wsQ0FBTCxDQUFPRyxDQUFQLENBQU4sQ0FBZ0JFLE1BQUlBLElBQUVBLEVBQUVxSixnQkFBRixJQUFvQnJKLENBQXRCLEVBQXdCUSxLQUFHQSxFQUFFUixDQUFGLENBQTNCLEVBQWdDRixFQUFFcUoscUJBQUYsR0FBd0JuSixDQUE1RDtBQUErRDtBQUFDLFlBQU9ULENBQVA7QUFBUyxHQUExTSxDQUEyTW9CLEVBQUVxRCxTQUFGLENBQVlzRixjQUFaLEdBQTJCM0ksRUFBRXFELFNBQUYsQ0FBWW5FLENBQXZDLENBQXlDYyxFQUFFcUQsU0FBRixDQUFZOEQsc0JBQVosR0FBbUNuSCxFQUFFcUQsU0FBRixDQUFZckUsQ0FBL0MsQ0FBaURnQixFQUFFcUQsU0FBRixDQUFZNkQsYUFBWixHQUEwQmxILEVBQUVxRCxTQUFGLENBQVl6RSxDQUF0QztBQUNyU29HLFNBQU80RCxnQkFBUCxDQUF3QjVJLEVBQUVxRCxTQUExQixFQUFvQyxFQUFDdUQsbUJBQWtCLEVBQUNwRCxLQUFJLGVBQVU7QUFBQyxlQUFPM0QsQ0FBUDtBQUFTLE9BQXpCLEVBQTBCeUQsS0FBSSxhQUFTMUUsQ0FBVCxFQUFXO0FBQUNpQixZQUFFakIsQ0FBRjtBQUFJLE9BQTlDLEVBQW5CLEVBQW1FaUksa0JBQWlCLEVBQUNyRCxLQUFJLGVBQVU7QUFBQyxlQUFPdkUsQ0FBUDtBQUFTLE9BQXpCLEVBQTBCcUUsS0FBSSxhQUFTMUUsQ0FBVCxFQUFXO0FBQUMsWUFBSUksSUFBRSxDQUFDLENBQVAsQ0FBU0MsTUFBSUQsSUFBRSxDQUFDLENBQVAsRUFBVUMsSUFBRUwsQ0FBRixDQUFJSSxLQUFHbUIsRUFBRSxJQUFGLENBQUg7QUFBVyxPQUE1RSxFQUFwRixFQUFwQyxFQUF3TSxJQUFJRyxJQUFFLElBQUlOLENBQUosRUFBTixDQUFZd0IsT0FBT1UsUUFBUCxLQUFrQlYsT0FBT1UsUUFBUCxHQUFnQixFQUFDOEUsaUJBQWdCLDJCQUFVLENBQUUsQ0FBN0IsRUFBOEJJLGNBQWEsc0JBQVN4SSxDQUFULEVBQVdJLENBQVgsRUFBYTtBQUFDc0IsUUFBRTFCLENBQUYsR0FBTWYsRUFBRWUsQ0FBRixFQUFJSSxDQUFKO0FBQU8sS0FBdEUsRUFBdUV3SSxjQUFhLHdCQUFVO0FBQUNsSCxRQUFFMUIsQ0FBRjtBQUFNLEtBQXJHLEVBQXNHa0osZUFBYyx1QkFBU2xKLENBQVQsRUFBVztBQUFDMEIsUUFBRTFCLENBQUYsR0FBTWYsRUFBRWpCLFNBQVNVLElBQVgsRUFBZ0JzQixDQUFoQjtBQUFtQixLQUF6SixFQUEwSnNKLHVCQUFzQiwrQkFBU3RKLENBQVQsRUFBV0ksQ0FBWCxFQUFhO0FBQUMsYUFBTSxDQUFDSixJQUFFNEMsT0FBT3FELGdCQUFQLENBQXdCakcsQ0FBeEIsRUFBMkJrRyxnQkFBM0IsQ0FBNEM5RixDQUE1QyxDQUFILElBQW1ESixFQUFFeEIsSUFBRixFQUFuRCxHQUE0RCxFQUFsRTtBQUFxRSxLQUFuUSxFQUFvUStFLFdBQVU1QyxDQUE5USxFQUFnUjRJLGNBQWFqSixDQUE3UixFQUFsQyxFQUFtVXNDLE9BQU9VLFFBQVAsQ0FBZ0J5RSxvQkFBaEIsR0FBcUNyRyxDQUFyQztBQUF3QyxDQVgvakIsRUFXaWtCK0gsSUFYamtCOztBQWFBLHNEOzs7Ozs7Ozs7OztBQ0FBLENBQVUsWUFBRTtBQUNFOztBQUVaLE1BQXlCO0FBQ3pCOztBQUVXLGNBQUU7QUFDVyw0QkFBUyxRQUFZLFlBQzdDO0FBQUk7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFxQ0csVUFBcUI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFtQkwsMERBQVMsVUFBTyxPQUFLLEtBQUU7QUFDMUMsYUFBNEIsc0JBQUssTUFBVSxVQUFPLE9BQUssS0FDekQ7QUFDRDtBQXRCNkI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTZEdkIsVUFBNkI7O0FBRXhCOzs7Ozs7QUFNRyxtQkFDWjtBQVBXOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTJCUywwREFBUyxVQUFPLE9BQUssS0FBRTtBQUMxQyxhQUE0QixzQkFBSyxNQUFVLFVBQU8sT0FBSyxLQUFNLEtBQy9EO0FBR0o7QUFsQ3dDO0FBa0NwQyxLOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDOEJPO0FBQ0gsTUFBcUI7O0FBRWQsYUFBRSxDQUNGLFFBQ1I7O0FBRVM7Ozs7QUFJRztBQUNMLFlBQVM7QUFDUixhQUNOO0FBSFk7Ozs7OztBQVNFO0FBQ1QsWUFBUTtBQUNQLGFBQ047QUFIZ0I7Ozs7OztBQVNYO0FBQ0EsWUFBUztBQUNLLDBCQUFNO0FBQ2hCLGdCQUFNO0FBQ1IsY0FDUDtBQUxPOzs7OztBQVVRO0FBQ1YsWUFBUztBQUNSLGFBQ047QUFIaUI7O0FBS0g7QUFDVCxZQUVQO0FBSGtCO0FBckNQOztBQTBDSDtBQUNBLGFBQ1I7QUFGVTs7QUFJRixhQUFFLENBRVY7Ozs7Ozs7QUFPRCxNQUFXLFNBQUU7QUFDWCxXQUFjLFFBQUksSUFBSyxLQUFFLEVBQVksWUFBc0Isc0JBQzdEO0FBQUM7O0FBRU8sWUFBVyxvQkFBRTs7QUFFbkIsUUFBVyxTQUFNLEtBQU87QUFDckIsUUFBTyxRQUFFO0FBQ0osYUFBYSxhQUFnQixpQkFDckM7QUFDRjtBQUFDOztBQUVZLGlCQUFVLHVCQUFFLEdBQUU7QUFDekIsUUFBVyxTQUFTLFFBQUksSUFBRyxHQUFZO0FBQ3BDLFFBQVEsVUFBUyxPQUFhLGFBQWlCLGtCQUFFO0FBQ2xELFVBQVcsU0FBTSxLQUFPO0FBQ3JCLFVBQVEsVUFBRyxDQUFPLE9BQVcsWUFBRTtBQUMxQixlQUNSO0FBQ0Y7QUFDRjtBQUFDOztBQUVrQix1QkFBVywrQkFBRTtBQUM5QixRQUFXLFNBQU0sS0FBTztBQUNyQixRQUFDLENBQUssS0FBWSxjQUFHLENBQU8sUUFBRTtBQUVqQzs7O0FBRUksU0FBaUIsa0JBQU0sS0FBUSxTQUFPLE9BQVEsT0FBUztBQUN4RCxRQUFLLEtBQWtCLG1CQUFFO0FBQ3ZCLFVBQUssS0FBTyxRQUFFO0FBQ1QsZUFBUSxTQUFNLEtBQWlCO0FBQy9CLGVBQVksYUFDcEI7QUFBRSxhQUFLO0FBQ0MsZUFBUSxTQUFRLE9BQVksYUFDcEM7O0FBQ0csVUFBTyxPQUFhLGFBQWlCLGtCQUFFOztBQUVqQyxnQkFBYSxhQUFnQixnQkFBSyxNQUFXLFlBQUU7QUFDOUMsaUJBQWdCLGdCQUN4QjtBQUNGOztBQUNJLFdBQW1CLG9CQUN6QjtBQUNGO0FBQUM7O0FBRWEsa0JBQVcsMEJBQUU7QUFDckIsU0FBbUIsb0JBQU07QUFDekIsU0FDTjtBQUFDOztBQUVxQiwwQkFBVSxnQ0FBTSxPQUFFO0FBQ2xDLFNBQVcsV0FBTSxNQUFPLE9BQzlCO0FBQUM7O0FBRWlCLHNCQUFVLDRCQUFZLGFBQWlCLGlCQUFFO0FBQ3pELFdBQW1CLGNBQXFCLHFCQUFpQixpQkFBa0Isa0JBQzdFO0FBQ0E7QUF4SE0sRzs7Ozs7Ozs7Ozs7QUMxSkg7O0FBRUgsTUFBb0I7O0FBRVo7Ozs7O0FBS0k7QUFDTixZQUFTO0FBQ1IsYUFBTztBQUNKLGdCQUFNO0FBQ1IsY0FDUDtBQUxhOzs7OztBQVVUO0FBQ0MsWUFBUTtBQUNKLGdCQUNUO0FBSE07Ozs7OztBQVNIO0FBQ0UsWUFBUztBQUNSLGFBQ047QUFISzs7Ozs7QUFRUztBQUNSLGFBQVcsaUJBQUU7QUFDaEIsZUFBVyxLQUFhLGFBQUssS0FDL0I7QUFDRDtBQUpnQjs7Ozs7QUFTZDtBQUNJLGFBRVI7QUFITTtBQXpDSzs7QUE4Q0osWUFBVyxvQkFBRTtBQUNmLFNBQU0sTUFBUyxVQUFRO0FBQ3ZCLFNBQ047QUFBQzs7QUFFTyxZQUFXLG9CQUFFO0FBQ2YsU0FDTjtBQUFDOztBQUVHLFFBQVcsZ0JBQUU7QUFDWixRQUFLLEtBQUksS0FBRTtBQUNSLFdBQUksSUFBWSxZQUFLLEtBQzNCO0FBQ0Y7QUFBQzs7QUFFTSxXQUFXLG1CQUFFO0FBQ2YsUUFBSyxLQUFJLEtBQUU7QUFDUixXQUFJLElBQWUsZUFBSyxLQUM5Qjs7QUFDSSxTQUFLLE1BQ1g7QUFBQzs7QUFFVyxnQkFBVyx3QkFBRTtBQUNuQixTQUFVO0FBQ2QsUUFBVSxRQUFNLEtBQU07QUFDbkIsUUFBQyxDQUFNLE9BQUU7QUFFWjs7QUFDRyxRQUFDLENBQUssS0FBTSxRQUFRLE1BQUksT0FBTyxLQUFFO0FBQzVCLGNBQU0sTUFBUSxRQUN0Qjs7QUFDSSxTQUFLLE1BQVEsT0FBVyxXQUFPO0FBQy9CLFNBQU87QUFDUCxTQUFhLGFBQUssS0FDeEI7QUFBQzs7QUFFVyxnQkFBVSxzQkFBRyxJQUFFO0FBQ3JCLFNBQWlCLGlCQUFHLEdBQzFCO0FBRUE7O0FBMUZNLEc7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzRSQztBQUNILE1BQWM7O0FBRVAsYUFBRSxDQUNGLFFBQXlCLDBCQUN6QixRQUNSOztBQUVTOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE4QkM7QUFDSCxZQUFTO0FBQ1IsYUFDTjtBQUhVOzs7OztBQVFOO0FBQ0MsWUFBUztBQUNSLGFBQ047QUFITTs7Ozs7QUFRQTtBQUNELFlBQVM7QUFDUixhQUNOO0FBSFE7Ozs7O0FBUUg7QUFDQSxZQUFTO0FBQ0ssMEJBQU07QUFDbkIsYUFFUjtBQUxTO0FBdERFOztBQTZESCxhQUFFLENBRVY7Ozs7Ozs7QUFPTSxXQUFHOzs7Ozs7O0FBT0YsWUFBRzs7Ozs7OztBQU9DLGdCQUFHOzs7Ozs7O0FBT0gsZ0JBQU07Ozs7Ozs7QUFPZCxRQUFHOzs7Ozs7O0FBT0UsYUFBRzs7QUFFSyxxQkFBTztBQUNWLGtCQUFHO0FBQ0gsa0JBQUc7QUFDSCxrQkFBRztBQUNILGtCQUFHOzs7Ozs7O0FBT2pCLE1BQWtCLGdCQUFFO0FBQ2xCLFdBQVcsS0FBTyxRQUFNLEtBQVUsV0FBTSxLQUFTLFVBQ25EO0FBQUM7Ozs7Ozs7QUFPRCxNQUFjLFlBQUU7QUFDWCxRQUFLLEtBQWEsY0FBRTtBQUNyQixhQUFXLEtBQ2I7O0FBQ0EsUUFBVSxRQUFTLFFBQUksSUFBSyxLQUFFLEVBQU0sTUFBc0I7O0FBRXRELFNBQUMsSUFBTSxJQUFHLEdBQU0sTUFBTyxPQUFPLE1BQUcsSUFBSyxLQUFFO0FBQ3ZDLFVBQUssS0FBVSxhQUFRLEtBQWEsY0FBRTtBQUNwQyxZQUFLLEtBQWEsYUFBVSxXQUFFO0FBQzNCLGVBQWMsZUFBTTtBQUUxQjtBQUFFLGVBQVEsSUFBQyxDQUFLLEtBQWEsY0FBRTtBQUN6QixlQUFjLGVBQ3BCO0FBQ0Y7QUFDRjs7QUFDQSxXQUFXLEtBQ2I7QUFBQzs7QUFFYSxrQkFBVywwQkFBRTtBQUNyQixTQUFjO0FBQ2QsU0FDTjtBQUFDOztBQUVrQix1QkFBVywrQkFBRTtBQUMzQixRQUFLLEtBQWEsZ0JBQU0sS0FBTyxLQUFjLGlCQUFLLEdBQUU7QUFFdkQ7O0FBQ0EsUUFBYyxZQUFNLEtBQWtCO0FBQ3RDLFFBQWUsYUFBTSxLQUFTLFlBQU0sS0FBYSxjQUFLO0FBQ3RELFFBQW9CLGtCQUFNLEtBQVM7QUFDL0IsU0FBUyxVQUFNLEtBQWE7QUFDNUIsU0FBYyxlQUFNO0FBQ3BCLFNBQVUsV0FBTTs7QUFFaEIsUUFBQyxDQUFXLFlBQUU7QUFDWixXQUFtQixtQkFBRSxHQUMzQjs7QUFDRyxRQUFLLEtBQVcsWUFBRTtBQUNmLFdBQVUsV0FBTSxLQUFXLFlBQU0sS0FBUyxVQUFNLEtBQVUsVUFBYyxlQUM5RTtBQUFFLFdBQUs7QUFDRCxXQUFVLFdBQ2hCOztBQUNJLFNBQWMsZUFBTSxLQUFXLFlBQU0sS0FBVSxVQUFXLFlBQUc7QUFDN0QsU0FBZTtBQUNoQixRQUFXLFlBQUU7QUFDVixXQUFtQixtQkFBVSxXQUNuQztBQUFFLFdBQUs7QUFDRCxXQUFtQixtQkFBSyxLQUFlLGdCQUFPO0FBQzlDLFdBQ047OztBQUVJLFNBQVUsV0FDaEI7QUFBQzs7Ozs7Ozs7QUFRaUIsc0JBQVUsNEJBQVUsV0FBYSxhQUFFO0FBQ2hELFFBQUssS0FBUyxZQUFLLEdBQUU7QUFFeEI7O0FBQ0EsUUFBYSxXQUFHO0FBQ2hCLFFBQVEsTUFBRztBQUNYLFFBQVksVUFBTSxLQUFLO0FBQ3ZCLFFBQWtCLGdCQUFNLEtBQWU7QUFDdkMsUUFBaUIsZUFBTSxLQUFjO0FBQ3JDLFFBQWUsYUFBWSxZQUFNLEtBQWU7QUFDaEQsUUFBa0IsZ0JBQU0sS0FBSSxJQUFZO0FBQ3hDLFFBQW9CLGtCQUFZLFlBQU0sS0FBZTtBQUNyRCxRQUFRLE1BQWEsWUFBTTs7QUFFeEIsUUFBSyxLQUFXLFlBQUU7QUFDZixZQUFNLEtBQU8sT0FBSyxLQUFTLFVBQVUsVUFBYSxhQUFXLFdBQUcsR0FDdEU7O0FBQ0csUUFBVyxhQUFPLEtBQVMsVUFBRTtBQUMxQixZQUFNLEtBQVcsYUFBRyxDQUFLLEtBQU8sUUFBTSxLQUFJLElBQUssS0FBUyxVQUFPLE9BQUs7QUFDcEUsV0FBTSxNQUFvQixxQkFDaEM7O0FBQ0csUUFBSyxLQUFTLFdBQUcsQ0FBSyxLQUFVLFlBQWlCLGdCQUFLLEtBQUU7O0FBRXRELFVBQUssTUFBTSxLQUFnQixpQkFBTSxPQUFPLEtBQW1CLHNCQUFtQixpQkFBRTtBQUM3RSxhQUFnQixpQkFBVztBQUMzQixhQUFnQixpQkFDdEI7O0FBQ0csVUFBVyxhQUFlLGNBQUU7O0FBRTFCLFlBQUssS0FBSSxJQUFLLEtBQWdCLGlCQUFhLGFBQUssTUFBaUIsZ0JBQUksSUFBRTtBQUNyRSxjQUFpQixtQkFBYSxhQUFlLGNBQUU7QUFDNUMsa0JBQ047QUFBRSxpQkFBUSxJQUFDLENBQWlCLG1CQUFhLGFBQU8sS0FBUyxVQUFFO0FBQ3JELGtCQUFNLEtBQVcsYUFBRyxDQUFLLEtBQU8sUUFBTSxLQUFVLFdBQ3REOztBQUNBLGNBQW1CLGlCQUFlLGNBQUssTUFBTSxLQUFnQjtBQUN6RCxlQUFNLE1BQW9CLHFCQUFNLEtBQU8sT0FBQyxDQUFLLE1BQVcsV0FBZ0IsZ0JBQUcsR0FBTyxPQUN4RjtBQUFFLGVBQUs7QUFDRCxnQkFBTSxLQUNaO0FBQ0Y7QUFDRjs7QUFDRyxRQUFLLEtBQVUsYUFBSyxHQUFFO0FBQ2QsaUJBQVksWUFBSSxJQUFJLElBQy9CO0FBQUUsV0FBSztBQUNJLGlCQUFNLE1BQU0sS0FDdkI7O0FBQ0csUUFBQyxDQUFZLGFBQUU7QUFDWixXQUFnQixpQkFBVztBQUMzQixXQUFNLE9BQUs7QUFDWCxXQUFtQixvQkFBaUI7QUFDcEMsV0FBZ0IsaUJBQ3RCOztBQUNHLFFBQWEsZUFBWSxhQUFRLEtBQVcsYUFBVyxZQUFRLE9BQWEsY0FBSyxHQUFFO0FBQ2hGLFdBQVcsWUFBVTtBQUNyQixXQUFZLFlBQVMsVUFBTTtBQUMzQixXQUFpQixpQkFDdkI7QUFDRjtBQUFDOzs7Ozs7O0FBT08sWUFBVyxvQkFBRTtBQUNuQixXQUFXLEtBQVcsYUFBRyxDQUFLLEtBQ2hDO0FBQUM7Ozs7Ozs7O0FBUVcsZ0JBQVcsd0JBQUU7QUFDdkIsV0FBVyxLQUFVLFdBQUksS0FBTyxLQUNsQztBQUFDOzs7Ozs7Ozs7QUFTUyxjQUFXLHNCQUFFO0FBQ3JCLFdBQVcsS0FBUyxZQUFNLEtBQU8sS0FBTSxPQUFNLEtBQy9DO0FBQUM7Ozs7Ozs7O0FBUWEsa0JBQVcsMEJBQUU7QUFDekIsV0FBVyxLQUFNLFNBQU0sSUFBTSxLQUFtQixvQkFBSSxJQUM1QyxLQUFtQixvQkFBTSxLQUFlLGlCQUNsRDtBQUFDOzs7Ozs7O0FBT2Usb0JBQVUsMEJBQUUsR0FBRTtBQUN4QixTQUFZLFlBQUUsR0FBRyxDQUFJLENBQUwsR0FBVyxNQUFJO0FBQ2hDLFFBQUssS0FBVSxXQUFFO0FBQ2QsV0FBWSxZQUFFLEdBQU0sS0FBVyxhQUFLLEtBQU8sS0FBYyxlQUNwRCxLQUFJLElBQUUsR0FBTSxLQUFXLFlBQU0sS0FBZSxZQUFqRCxHQUF3RCxPQUFHLEdBQUksR0FBTSxLQUMzRTtBQUNGO0FBQUM7O0FBRUssVUFBVSxnQkFBRSxHQUFLLEtBQUssS0FBRTtBQUM1QixXQUFXLEtBQUksSUFBSSxLQUFNLEtBQUksSUFBSSxLQUNuQztBQUFDOztBQUVrQix1QkFBVywrQkFBRTtBQUMzQixRQUFDLENBQUssS0FBYSxjQUFFO0FBQ2xCLFdBQWMsZUFBVSxTQUFjLGNBQU87QUFDN0MsV0FBYSxhQUFJLEtBQWM7QUFDL0IsV0FBUyxVQUFVLFNBQWMsY0FBTztBQUN4QyxXQUFRLFFBQUksS0FBdUI7QUFDbkMsV0FBYSxhQUFZLFlBQUssS0FBUztBQUN2QyxXQUFVLFdBQVUsU0FBYyxjQUFPO0FBQ3pDLFdBQVMsU0FBSSxLQUF3QjtBQUNyQyxXQUFhLGFBQVksWUFBSyxLQUFVO0FBQ3JDLGNBQUksSUFBSyxLQUFNLE1BQWEsYUFBSyxLQUFhLGNBQU0sS0FBRSxFQUMvRDtBQUNGO0FBQUM7O0FBRVMsY0FBVSxvQkFBRyxJQUFFO0FBQ2hCLFlBQUs7QUFDVixXQUEyQjtBQUNyQixhQUFzQjtBQUMxQixlQUFXLEtBQVM7QUFDdEIsV0FBMEI7QUFDcEIsYUFBc0I7QUFDMUIsZUFBVyxLQUFRO0FBQ3JCLFdBQWlCO0FBQ1gsYUFBc0I7QUFDMUIsZUFBVyxLQUFhO0FBQzFCLFdBQWdCO0FBQ2QsZUFBYyxRQUFJLElBQU0sTUFBYyxjQUFnQjtBQUN4RCxXQUFxQjtBQUNuQixlQUFjLFFBQUksSUFBTSxNQUFjLGNBQzFDOztBQUNBLFdBQ0Y7QUFBQzs7Ozs7Ozs7O0FBU2Esa0JBQVcsMEJBQUU7QUFDekIsV0FBTyxFQUFVLFVBQU0sS0FBVSxXQUFLLEtBQU0sS0FDOUM7QUFDQTtBQXJXTSxHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDaFNILFFBQTBCOztBQUVyQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXFDSTtBQUNOLFlBQWE7QUFDWixhQUFXLGlCQUFFO0FBQ2hCLGVBQVcsS0FDYjtBQUVIO0FBTmU7QUFyQ0o7O0FBNkNILGFBQUUsQ0FFVjs7Ozs7QUFLa0IsdUJBQU07O0FBRUwsd0JBQVUsOEJBQWEsY0FBWSxZQUFFO0FBQ3ZELFFBQWU7O0FBRVosUUFBSyxLQUFpQixrQkFBRTtBQUNyQixXQUFzQixzQkFBTSxPQUFNLEtBQWtCO0FBQ3BELFdBQWtCLG1CQUN4Qjs7QUFDRyxRQUFDLENBQVcsWUFBRTtBQUVqQjs7O0FBRUcsUUFBYyxpQkFBYyxZQUFFOztBQUUzQixXQUFjLGVBQU0sS0FFMUI7QUFBRSxlQUFTLE9BQW9CLGlCQUFZLFVBQUU7O0FBRTNDLFVBQVksVUFBTSxLQUFROztBQUV0QixXQUFjLGVBQVUsV0FBVSxRQUFHLElBQVMsUUFBRSxFQUFlLGdCQUN4RCxRQUFJLElBQUssS0FBZSxlQUFjLGNBQUssTUFFeEQ7QUFBRSxLQVBRLE1BT0EsSUFBSyxLQUF1Qix3QkFBRTs7QUFFbEMsV0FBa0IsbUJBQWM7QUFDaEMsV0FBc0Isc0JBQUssS0FBb0IscUJBRXJEO0FBQ0Y7QUFBQzs7Ozs7OztBQU9hLGtCQUFFLFNBQXVCLGdCQUFHLENBQUM7Ozs7Ozs7O0FBUTNDLE1BQXlCLHVCQUFFO0FBQ3pCLFdBQVcsS0FDYjtBQUFDOzs7Ozs7O0FBT0QsTUFBUyxPQUFFO0FBQ1QsV0FBVyxLQUFjLGNBQzNCO0FBQUM7Ozs7Ozs7QUFPRCxNQUFlLGFBQUU7QUFDWixRQUFLLEtBQXVCLHdCQUFFO0FBQy9CLGFBQVcsS0FBYyxpQkFBUSxLQUFNLE9BQVEsT0FBYSxjQUFNLEtBQWEsYUFDakY7O0FBQ0EsV0FDRjtBQUFDOzs7Ozs7O0FBT0QsTUFBZ0IsY0FBRTtBQUNiLFFBQUssS0FBdUIsd0JBQUU7QUFDL0IsYUFBVyxLQUFjLGlCQUFRLEtBQU0sT0FBUSxPQUFhLGNBQU0sS0FBYSxhQUNqRjs7QUFDQSxXQUNGO0FBQUM7Ozs7Ozs7QUFPRCxNQUFjLFdBQUksS0FBRTtBQUNmLFFBQUssS0FBYyxpQkFBUSxLQUFLLE1BQUU7QUFDN0IsYUFBUyxTQUFPLE9BQVksYUFDcEM7QUFBRSxXQUFRLElBQUssS0FBdUIsd0JBQUU7QUFDbEMsV0FBYSxhQUFXLFlBQzlCO0FBQ0Y7QUFBQzs7Ozs7OztBQU9ELE1BQWUsWUFBSyxNQUFFO0FBQ2pCLFFBQUssS0FBYyxpQkFBUSxLQUFLLE1BQUU7QUFDN0IsYUFBUyxTQUFLLE1BQVEsT0FDOUI7QUFBRSxXQUFRLElBQUssS0FBdUIsd0JBQUU7QUFDbEMsV0FBYSxhQUFZLGFBQy9CO0FBQ0Y7QUFBQzs7Ozs7Ozs7O0FBU0ssVUFBVSxnQkFBSyxNQUFLLEtBQUU7QUFDdEIsUUFBSyxLQUFjLGlCQUFRLEtBQUssTUFBRTtBQUM5QixhQUFTLFNBQUssTUFDdEI7QUFBRSxXQUFRLElBQUssS0FBdUIsd0JBQUU7QUFDbEMsV0FBYSxhQUFZLGFBQU07QUFDL0IsV0FBYSxhQUFXLFlBQzlCO0FBQ0Y7QUFBQzs7Ozs7OztBQU9ELE1BQXVCLHFCQUFFO0FBQ3BCLFFBQUssS0FBdUIsd0JBQUU7QUFDL0IsYUFBVyxLQUFjLGlCQUFRLEtBQU0sT0FBUSxPQUFZLGFBQU0sS0FBYSxhQUNoRjs7QUFDQSxXQUNGO0FBQUM7Ozs7Ozs7QUFPRCxNQUF3QixzQkFBRTtBQUNyQixRQUFLLEtBQXVCLHdCQUFFO0FBQy9CLGFBQVcsS0FBYyxpQkFBUSxLQUFNLE9BQVEsT0FBYSxjQUFNLEtBQWEsYUFDakY7O0FBQ0EsV0FDRjtBQUFDOzs7Ozs7O0FBT21CLHdCQUFXLGdDQUFFO0FBQy9CLFdBQVcsS0FBYyx3QkFDM0I7QUFBQzs7QUFFb0IseUJBQVUsK0JBQUksS0FBYyxjQUFFO0FBQ2pELFFBQWdCLGNBQWUsaUJBQVEsS0FBTSxPQUFTLFNBQWM7QUFDakUsUUFBSSxLQUFFO0FBQ0osVUFBQyxDQUFLLEtBQW9CLHFCQUFFO0FBQ3pCLGFBQXFCLHNCQUFNLEtBQWUsZUFBSyxLQUFNO0FBQzlDLG9CQUFpQixpQkFBUyxVQUFNLEtBQzdDO0FBQ0Y7QUFBRSxXQUFLO0FBQ0YsVUFBSyxLQUFvQixxQkFBRTtBQUNqQixvQkFBb0Isb0JBQVMsVUFBTSxLQUFxQjtBQUMvRCxhQUFxQixzQkFDM0I7QUFDRjtBQUNGO0FBQUM7Ozs7Ozs7QUFPbUIsd0JBQVUsOEJBQUksS0FBRTtBQUM5QixTQUFxQixzQkFBSztBQUMxQixTQUFzQixzQkFBSSxLQUFNLEtBQ3RDO0FBRUQ7O0FBNU9rQyxFOzs7Ozs7Ozs7OztBQ1o1QixRQUFXLFlBQVMsUUFBVyxhQUFLOztBQUVwQyxRQUFVLFVBQWdCLGlCQUFTLFFBQVUsVUFBZ0Isa0JBQUs7O0FBRWxFLFFBQVUsVUFBc0IsdUJBQUUsU0FBb0IsWUFBRSxHQUFHLEdBQUcsR0FBRyxHQUFFO0FBQ3RFLE9BQUk7QUFDTixTQUFPLENBQUcsSUFBSSxLQUFFLElBQUksS0FDdEI7QUFBQzs7Ozs7Ozs7O0FBU00sUUFBVSxVQUFnQixpQkFBRSxTQUF1QixlQUFXLFlBQVcsV0FBRTtBQUM3RSxNQUFRLFFBQVUsVUFBZSxlQUFhLGVBQU8sTUFBRTtBQUN4RCxVQUFNLElBQVMsTUFBVyxhQUFhLGFBQ3pDOztBQUNPLFVBQVUsVUFBZSxlQUFhLGNBQy9DO0FBQUM7O0FBR00sUUFBVSxVQUFjLGVBQVUsVUFBUyxVQUFNLE1BQUU7QUFDeEQsTUFBVSxRQUFFLENBQU07QUFDbEIsTUFBWSxVQUFJOztBQUVWLFNBQU0sTUFBUSxTQUFHLEdBQUU7QUFDdkIsUUFBUyxPQUFPLE1BQVE7QUFDakIsWUFBSyxLQUFNLE1BQVEsU0FBTSxLQUFpQixpQkFBVztBQUN4RCxTQUFHLElBQUcsR0FBTSxLQUFTLFNBQUcsSUFBSyxLQUFFO0FBQzlCLFVBQUssS0FBUyxTQUFHLEdBQVcsWUFBRTtBQUMxQixjQUFLLEtBQUssS0FBUyxTQUFHLEdBQzdCO0FBQ0Y7QUFDRjs7QUFDQSxTQUNGO0FBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBdUJNLFFBQVUsVUFBUSxTQUFFLFNBQWUsT0FBUSxTQUFFO0FBQzFDLFlBQVUsV0FBSzs7QUFFdkIsTUFBVSxRQUFVLFNBQWdCO0FBQ3BDLE1BQVcsU0FBUyxRQUFRLFVBQVE7QUFDcEMsTUFBNEIsMEJBQW1CLG9CQUFTLE9BQU8sU0FBUyxPQUFPO0FBQy9FLE1BQW9CLGtCQUE0QjtBQUNoRCxNQUFjLFlBQVMsUUFBSyxPQUFJO0FBQ2hDLE1BQWUsYUFBUyxRQUFNLFFBQUk7QUFDbEMsTUFBYSxXQUFTLFdBQVUsUUFBUSxPQUFVLFdBQ2hELFNBQWlCLFNBQVcsWUFBVyxXQUFFO0FBQ2pDLFdBQVksYUFBWTtBQUN4QixXQUFXLFlBQ25CO0FBQUM7O0FBRUEsTUFBUSxRQUFVLGFBQVksVUFBRTs7QUFFOUIsUUFBd0IseUJBQUU7O0FBRXJCLGFBQU8sT0FFZjtBQUFFLFdBQUs7O0FBRUwsVUFBYSxXQUFTLFFBQVUsVUFBcUI7QUFDckQsVUFBYyxZQUFNLEtBQU07QUFDMUIsVUFBcUIsbUJBQVMsV0FBVSxRQUFRLE9BQWEsY0FBUSxPQUFVO0FBQy9FLFVBQXNCLG9CQUFTLFdBQVUsUUFBUSxPQUFhLGNBQVEsT0FBVztBQUNqRixVQUFtQixpQkFBWSxZQUFrQjtBQUNqRCxVQUFvQixrQkFBYSxhQUFtQjtBQUNwRCxVQUFhLFdBQUs7QUFDbEIsVUFBZ0IsY0FBRyxTQUFxQixjQUFFO0FBQ3hDLFlBQVEsTUFBTSxLQUFNO0FBQ3BCLFlBQWdCLGNBQU0sTUFBVzs7QUFFOUIsWUFBYSxjQUFVLFVBQUU7QUFDbEIsbUJBQVMsU0FBWSxhQUFtQixtQkFBaUIsaUJBQVcsV0FDaEUsU0FBWSxhQUFrQixrQkFBZ0IsZ0JBQVk7QUFDakQsZ0NBQ3ZCO0FBQUUsZUFBSztBQUNHLG1CQUFXLFlBQ3JCO0FBQ0Y7QUFBRSxPQVhnQixDQVdYLEtBQU07O0FBR2Y7QUFFRjtBQUFFLGFBQWdCLFFBQVUsYUFBWSxVQUFFO0FBQ3hDLFFBQVksVUFBUyxRQUFVLFVBQWEsYUFBYSxjQUFVLFNBQU07O0FBRWxFLFlBQVEsUUFBUyxVQUFPLFFBQUU7QUFDekIsYUFBYSxhQUFnQixpQkFDckM7QUFBRTs7Ozs7Ozs7QUFRSSxXQUFxQixxQkFBUSxRQUFVLFVBQWM7O0FBRXBELFlBQVUsVUFBYyxzQkFBOEIsc0JBQVUsWUFBRTtBQUNoRSxjQUFRLFFBQVMsVUFBTyxRQUFFO0FBQ3pCLGVBQWdCLGdCQUN4QjtBQUFFO0FBQ0ssY0FBVSxVQUFjLGVBQ2pDO0FBQUUsS0FMcUM7O0FBTy9CLGFBQVcsWUFFckI7QUFBRSxHQXhCUSxNQXdCSDs7QUFFRyxhQUFXLFlBRXJCO0FBQ0Y7QUFBQyxFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDVFE7QUFDSCxNQUFxQjs7QUFFZCxhQUFFLENBQ0YsUUFDUjs7QUFFUzs7Ozs7QUFLVTtBQUNaLFlBQVM7QUFDUixhQUFPO0FBQ00sMEJBRXJCO0FBTHFCO0FBTFY7O0FBWUgsYUFBRSxDQUVWOzs7Ozs7O0FBT0QsTUFBVyxTQUFFO0FBQ1gsV0FBYyxRQUFJLElBQUssS0FBRSxFQUFZLFlBQXNCLHNCQUM3RDtBQUFDOztBQUVrQix1QkFBVywrQkFBRTtBQUM5QixRQUFXLFNBQU0sS0FBTztBQUNyQixRQUFDLENBQUssS0FBWSxjQUFHLENBQU8sUUFBRTtBQUVqQzs7OztBQUdJLFNBQUUsRUFBUSxRQUFVLFVBQU8sT0FBZ0I7O0FBRXpDLFdBQWMsZUFBTSxLQUFvQixxQkFDdEMsS0FBRSxFQUFrQixtQkFBTSxLQUFjLGNBQWdCOzs7QUFHaEUsUUFBaUIsZUFBUSxPQUFhOztBQUVuQyxRQUFDLENBQUssS0FBbUIsb0JBQUU7QUFDUCx3Q0FBWTtBQUMvQixZQUFTLE9BQU0sS0FBd0I7QUFDdkMsWUFBZ0IsY0FBVSxTQUFnQixnQkFBYSxjQUFNLEtBQU07QUFDN0QsZUFBTSxNQUFNLE9BQU0sS0FBTSxPQUFNO0FBQzlCLGVBQU0sTUFBTyxRQUFjLGNBQ25DO0FBQUMsT0FMOEIsQ0FLekIsS0FDUjtBQUFFLFdBQUs7QUFDQyxhQUFNLE1BQU0sT0FBSTtBQUNoQixhQUFNLE1BQU8sUUFDckI7OztBQUVBLFFBQW1CLGlCQUFNLEtBQUUsRUFBaUIsaUJBQU07QUFDL0MsUUFBTyxPQUFPLFNBQUcsQ0FBTyxPQUFXLGFBQU8sS0FBbUIsb0JBQUU7Ozs7QUFJbEQscUJBQVcsWUFBZSxlQUFNO0FBQ2hDLHFCQUFZLGFBQzVCO0FBQUUsV0FBSztBQUNTLHFCQUFZLGFBQWUsZUFBTTtBQUNqQyxxQkFBVyxZQUMzQjtBQUNGO0FBRUE7O0FBeEVNLEc7Ozs7Ozs7OztBQzNJWixtQkFBQTFLLENBQVEsRUFBUjs7QUFFQSxtQkFBQUEsQ0FBUSxFQUFSOztBQUVBLG1CQUFBQSxDQUFRLEVBQVI7O0FBRUEsbUJBQUFBLENBQVEsRUFBUjs7QUFFQSxtQkFBQUEsQ0FBUSxFQUFSOztBQUVBLG1CQUFBQSxDQUFRLEVBQVI7O0FBRUEsbUJBQUFBLENBQVEsRUFBUixFOzs7Ozs7Ozs7Ozs7Ozs7OztBQ01TLFFBQVUsVUFBZSxlQUFrQjs7QUFFM0MsU0FBRSxTQUFjLE1BQU8sUUFBRTtBQUM1QixRQUFPLEtBQUk7QUFDWCxRQUFhLFdBQVEsT0FBVSxZQUFTO0FBQ3RDLE9BQXNCLHVCQUFNLEtBQVcsV0FBd0I7QUFDL0QsT0FBcUIsc0JBQU0sS0FBVyxXQUF1QjtBQUM3RCxPQUFxQixxQkFBTSxNQUFZLGFBQVc7QUFDbEQsT0FBcUIscUJBQU0sTUFBaUIsa0JBQWlCO0FBQzdELE9BQXFCLHFCQUFNLE1BQW9CLHFCQUFXO0FBQzFELE9BQXFCLHFCQUFNLE1BQW9CLHFCQUFVO0FBQ3pELE9BQW9CLG9CQUFNLE1BQVksYUFBVztBQUNqRCxPQUFvQixvQkFBTSxNQUFpQixrQkFBaUI7QUFDNUQsT0FBb0Isb0JBQU0sTUFBb0IscUJBQVc7QUFDekQsT0FBb0Isb0JBQU0sTUFBb0IscUJBQVU7QUFDdEQsU0FBbUIsb0JBQ3pCO0FBQUM7O0FBRUUsT0FBRSxTQUFZLElBQUUsR0FBRyxHQUFFO0FBQ3RCLFFBQU8sS0FBTSxLQUFrQjtBQUM1QixRQUFHLEtBQUksR0FBRTtBQUNSLFNBQXFCLHFCQUFNLE1BQVMsVUFBRztBQUN2QyxTQUFvQixvQkFBTSxNQUFTLFVBQ3ZDO0FBQUUsV0FBSztBQUNILFNBQXFCLHFCQUFNLE1BQVMsVUFBRztBQUN2QyxTQUFvQixvQkFBTSxNQUFTLFVBQ3ZDO0FBQ0Y7QUFBQzs7QUFFTyxZQUFFLFNBQWtCLFdBQUU7QUFDNUIsV0FBVyxLQUNiO0FBQ0E7QUFoQ2tELEc7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNDN0MsUUFBVSxVQUFlLGVBQVc7Ozs7QUFJcEMsU0FBRSxTQUFlLFFBQUU7QUFDbEIsU0FBUyxVQUErRDtBQUM1RSxXQUNGO0FBQ0E7QUFSMkMsRzs7Ozs7Ozs7Ozs7Ozs7O0FDSHRDLFFBQVUsVUFBZSxlQUF1Qjs7OztBQUloRCxTQUFFLFNBQWMsTUFBTyxRQUFFO0FBQzVCLFFBQVUsUUFBTSxLQUFXLFdBQWE7QUFDeEMsUUFBbUIsaUJBQU0sS0FBVyxXQUFrQjtBQUN0RCxRQUFhLFdBQVEsT0FBVSxZQUFTO0FBQ3hDLFFBQU8sS0FBSTs7QUFFUixRQUFDLENBQWUsZ0JBQUU7QUFDWixjQUFLLEtBQXFFO0FBQ2pGLGFBQ0Y7O0FBQ0csUUFBQyxDQUFNLE9BQUU7QUFDSCxjQUFLLEtBQWdFO0FBQzVFLGFBQ0Y7OztBQUVLLFVBQU0sTUFBb0IscUJBQVc7QUFDckMsVUFBTSxNQUFvQixxQkFBVTtBQUMzQixtQkFBTSxNQUFvQixxQkFBVztBQUNyQyxtQkFBTSxNQUFvQixxQkFBVTtBQUNoRCxPQUFnQixpQkFBZ0I7QUFDaEMsT0FBTyxRQUFPO0FBQ1osU0FBdUIsd0JBQzdCO0FBQUM7O0FBRUUsT0FBRSxTQUFZLElBQUUsR0FBRyxHQUFFO0FBQ3RCLFFBQU8sS0FBTSxLQUFzQjtBQUNoQyxRQUFHLElBQUcsR0FBRTtBQUNQLFNBQU0sTUFBTSxNQUFTLFVBQUc7QUFDeEIsU0FBZSxlQUFNLE1BQVMsVUFDbEM7QUFBRSxXQUFLO0FBQ0gsU0FBTSxNQUFNLE1BQVMsVUFBRztBQUN4QixTQUFlLGVBQU0sTUFBUyxVQUNsQztBQUNGO0FBQUM7O0FBRU8sWUFBRSxTQUFrQixXQUFFO0FBQzVCLFFBQU8sS0FBTSxLQUFzQjtBQUNqQyxPQUFNLE1BQU0sTUFBWSxhQUFJO0FBQzVCLE9BQWUsZUFBTSxNQUFZLGFBQUk7QUFDdkMsV0FBVyxLQUNiO0FBQ0E7QUE3Q3VELEc7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDaUdoRDtBQUNILE1BQ0Y7QUFGTSxHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNsQ1IsQ0FBVSxZQUFFO0FBQ0U7O0FBRUw7QUFDSCxRQUFnQjs7QUFFUjs7Ozs7QUFLSDtBQUNDLGNBQVE7QUFDTixnQkFDUDtBQUhNOzs7Ozs7Ozs7Ozs7QUFnQk07QUFDUCxjQUFTO0FBQ1IsZUFDTjtBQUhjOzs7Ozs7Ozs7Ozs7Ozs7QUFrQkY7QUFDUCxjQUFRO0FBQ04sZ0JBQ1A7QUFIYzs7Ozs7O0FBU0Y7QUFDUCxjQUNMO0FBRmM7Ozs7O0FBT1Q7QUFDQSxjQUNMO0FBRk87Ozs7O0FBT0Q7QUFDRCxjQUNMO0FBRlE7Ozs7O0FBT0g7QUFDQSxjQUNMO0FBRk87Ozs7OztBQVFKO0FBQ0UsY0FBUTtBQUNKLGtCQUNUO0FBSEs7Ozs7O0FBUUU7QUFDRixjQUVQO0FBSFc7QUFyRkE7O0FBMEZILGVBQUUsQ0FBUSxRQUEyQjs7QUFFckMsZUFBRSxDQUVWOztBQUVJLFdBQVcsaUJBQUU7QUFDWixXQUFVLFdBQ2hCO0FBQUM7O0FBRWlCLHdCQUFXLDhCQUFFO0FBQ3pCLFdBQU0sT0FBTSxLQUFlLGdCQUFNLEtBQVEsU0FBTSxLQUNyRDtBQUFDOztBQUVjLHFCQUFXLDJCQUFFO0FBQ3ZCLFVBQUMsQ0FBSyxLQUFTLFVBQUU7QUFFcEI7OztBQUVHLFVBQUssS0FBYyxlQUFFO0FBQ2xCLGFBQVEsU0FBTSxLQUNwQjtBQUFFLGFBQUs7QUFDRCxhQUFRLFNBQU0sS0FDcEI7QUFDRjtBQUVKO0FBdkhVO0FBdUhOLEs7Ozs7Ozs7Ozs7O0FDdEpOLENBQVUsWUFBRTtBQUNFOztBQUVaLE1BQWM7O0FBRWQsTUFBVSxRQUFTLFNBQVE7Ozs7Ozs7QUFPM0IsV0FBbUIsV0FBSyxNQUFNLE1BQUU7QUFDM0IsUUFBWSxlQUFhLFdBQUU7QUFDakIsbUJBQU87QUFDbEIsVUFBSTtBQUNGLFlBQU0sSUFBRSxJQUFPLElBQUksS0FBYTtBQUMvQixVQUFVLFdBQVM7QUFDUCxxQkFBRSxFQUFNLFNBQXFCO0FBQy9CLHFCQUFnQixjQUFDLElBQU8sSUFBa0Msa0NBQU0sU0FDN0U7UUFBUSxPQUFFLEdBQUcsQ0FDZjs7QUFDRyxRQUFXLFlBQUU7QUFDZCxhQUFPLElBQU8sSUFBSyxNQUNyQjs7QUFDRyxRQUFDLENBQU8sUUFBRTtBQUNKLGVBQVUsU0FBZSxlQUFtQixtQkFBTztBQUNsRCxnQkFBUSxPQUFjLGNBQVE7QUFDaEMsYUFBSyxLQUFZLFlBQVM7QUFDekIsZUFBaUMsK0JBQU8sT0FBYyxjQUMvRDs7QUFDTyxZQUFNLE9BQU07QUFDYixXQUFNLE9BQU0sS0FBUSxRQUFLLE1BQVE7QUFDdkMsV0FDRjs7O0FBRU87QUFDSCxRQUFpQjs7QUFFVDs7OztBQUlKO0FBQ0UsY0FBUTtBQUNOLGdCQUFNO0FBQ1AsZUFBVyxpQkFBRTtBQUNoQixpQkFBYSxPQUFtQixtQkFBTyxPQUFTLFNBQ2xEO0FBQ0Q7QUFOSzs7Ozs7QUFXRDtBQUNDLGNBQVE7QUFDTixnQkFBTTtBQUNQLGVBQVcsaUJBQUU7QUFDaEIsaUJBQWEsT0FBUyxTQUFPLE9BQU0sTUFDckM7QUFDRDtBQU5NOzs7OztBQVdIO0FBQ0UsY0FBUTtBQUNOLGdCQUFNO0FBQ1AsZUFBVyxpQkFBRTtBQUNoQixpQkFBYSxPQUFtQixtQkFBTyxPQUFTLFNBQUssS0FBTSxNQUM3RDtBQUNEO0FBTks7Ozs7Ozs7Ozs7QUFnQkc7QUFDSCxjQUFRO0FBQ1AsZUFDTjtBQUhVOzs7Ozs7Ozs7Ozs7Ozs7QUFrQkU7QUFDUCxjQUFRO0FBQ1AsZUFDTjtBQUhjOzs7Ozs7O0FBVUE7QUFDTCxrQkFDVDtBQUZnQjs7QUFJSDtBQUNSLGNBQ0w7QUFGZTs7QUFJSjtBQUNOLGNBQVM7QUFDUixlQUVSO0FBSmU7QUE5RUo7O0FBb0ZFO0FBQ04sY0FDUDtBQUZlOztBQUlQLGVBQUUsQ0FFVjs7QUFFTyxjQUFXLG9CQUFFO0FBQ2YsV0FBTyxPQUFPLFFBQWMsY0FBaUI7QUFDN0MsV0FBTyxPQUFPLFFBQW9CLG9CQUFnQjtBQUNsRCxXQUFPLE9BQU8sUUFBWSxZQUFnQjtBQUMxQyxXQUFPLFFBQWdDLCtCQUFTLFNBQU0sTUFBUyxTQUFtQjs7O0FBR2xGLFdBQWdCLGlCQUFRLE9BQVksWUFBUyxTQUFLLEtBQVcsWUFBTTtBQUNuRSxXQUFjLGVBQU07O0FBRXBCLFdBQ047QUFBQzs7QUFFTyxjQUFXLG9CQUFFO0FBQ2YsV0FBUyxTQUFPLFFBQWMsY0FBaUI7QUFDL0MsV0FBUyxTQUFPLFFBQW9CLG9CQUFnQjtBQUNwRCxXQUFTLFNBQU8sUUFBWSxZQUFnQjtBQUM1QyxXQUFTLFVBQWdDLCtCQUFTLFNBQU0sTUFBUyxTQUFtQjtBQUNwRixXQUFjLGVBQ3BCO0FBQUM7O0FBRVcsa0JBQVcsd0JBQUU7QUFDbkIsV0FBTSxPQUFRLE9BQW1CLG1CQUFPLE9BQVMsU0FBSyxLQUFVLFVBQ3RFO0FBQUM7O0FBRVUsaUJBQVcsdUJBQUU7Ozs7OztBQU1sQixXQUFnQixpQkFBTTtBQUN0QixXQUFlO0FBQ2YsV0FBTSxPQUFRLE9BQW1CLG1CQUFPLE9BQVMsU0FBVTtBQUMzRCxXQUFPLFFBQVEsT0FBUyxTQUFPLE9BQVUsVUFBRztBQUM1QyxXQUFnQixpQkFBTztBQUN2QixXQUNOO0FBQUM7O0FBRU0sYUFBVyxtQkFBRTtBQUNsQixVQUF5Qix1QkFBUSxPQUFVLFVBQ25DLEtBQU0sTUFBUSxRQUFNLE9BQVEsT0FBUSxRQUFNLE9BQVE7QUFDMUQsVUFBMEIsd0JBQUk7QUFDM0IsVUFBSyxLQUFNLE9BQUU7QUFDUSxnQ0FBTSxNQUFNLEtBQU0sTUFBUSxRQUFNLE9BQ3hEOztBQUNBLFVBQXlCLHVCQUFJO0FBQzFCLFVBQUssS0FBSyxNQUFFO0FBQ1EsK0JBQU0sTUFBUSxPQUFVLFVBQUssS0FDcEQ7O0FBQ08sYUFDa0IsdUJBQXdCLHdCQUNuRDtBQUFDOztBQUVTLGdCQUFXLHNCQUFFO0FBQ2xCLFVBQUssS0FBZ0Isa0JBQUcsQ0FBSyxLQUFhLGNBQUU7QUFFL0M7OztBQUVHLFVBQUssS0FBTSxTQUFVLE9BQW1CLG1CQUFPLE9BQVMsU0FBVyxhQUM5RCxLQUFPLFVBQVUsT0FBUyxTQUFPLE9BQVUsVUFBSSxNQUMvQyxLQUFNLFNBQVUsT0FBbUIsbUJBQzdCLE9BQVMsU0FBSyxLQUFVLFVBQUksS0FBRTs7QUFHNUM7OztBQUVBLFVBQVcsU0FBTSxLQUFVOztBQUUzQixVQUFlLGFBQVksV0FBTyxRQUFRLE9BQVMsU0FBVSxXQUFPLE9BQVEsT0FBUyxTQUFNLE1BQUs7QUFDaEcsVUFBUSxNQUFRLE9BQVksWUFBTTtBQUNsQyxVQUFrQixnQkFBTSxLQUFnQixpQkFBTSxLQUFXLFlBQUs7QUFDMUQsV0FBZ0IsaUJBQUs7O0FBRXRCLFVBQWMsZUFBRTtBQUNYLGVBQVEsUUFBYSxhQUFHLElBQUksSUFDcEM7QUFBRSxhQUFLO0FBQ0MsZUFBUSxRQUFVLFVBQUcsSUFBSSxJQUNqQzs7O0FBRUksV0FBSyxLQUFtQixvQkFBSSxJQUFFLEVBQUssTUFDekM7QUFBQzs7Ozs7Ozs7QUFRYSxvQkFBVSx3QkFBTSxPQUFFOzs7O0FBSTNCLFVBQU0sTUFBaUIsa0JBQUU7QUFFNUI7OztBQUVBLFVBQVMsT0FBTSxLQUF1Qix1QkFBTzs7QUFFMUMsVUFBQyxDQUFLLE1BQUU7QUFFWDs7O0FBRUssWUFBaUI7Ozs7QUFJbkIsVUFBTSxTQUFVLE9BQVMsU0FBSyxNQUFFO0FBRW5DOzs7QUFFTSxhQUFRLFFBQVUsVUFBRyxJQUFJLElBQU87QUFDbEMsV0FBSyxLQUFtQixvQkFBSSxJQUFFLEVBQUssTUFDekM7QUFBQzs7Ozs7Ozs7OztBQVVxQiw0QkFBVSxnQ0FBTSxPQUFFOztBQUVuQyxVQUFNLE1BQVEsV0FBSyxHQUFFO0FBQ3RCLGVBQ0Y7Ozs7O0FBSUcsVUFBTSxNQUFTLFdBQVEsTUFBUSxTQUFFO0FBQ2xDLGVBQ0Y7OztBQUVBLFVBQWMsWUFBUyxRQUFJLElBQU8sT0FBSztBQUN2QyxVQUFXLFNBQU07O0FBRWIsV0FBQyxJQUFNLElBQUcsR0FBSSxJQUFXLFVBQU8sUUFBSyxLQUFFO0FBQ3pDLFlBQVksVUFBVyxVQUFHOztBQUV2QixZQUFRLFFBQVMsWUFBUSxPQUFVLFFBQUssTUFBRTtBQUNwQyxtQkFBUztBQUVsQjtBQUNGOzs7O0FBR0csVUFBQyxDQUFPLFFBQUU7QUFDWCxlQUNGOzs7O0FBR0csVUFBTyxPQUFRLFdBQVksVUFBRTtBQUM5QixlQUNGOzs7O0FBR0csVUFBQyxDQUFPLE9BQVEsV0FBVyxVQUNwQixPQUFRLFdBQWUsY0FDdkIsT0FBSyxRQUFVLFFBQUU7QUFDekIsZUFDRjs7O0FBRUEsVUFBUyxPQUFRLE9BQUs7Ozs7QUFJdEIsVUFBTzs7QUFFSixVQUFTLFNBQVMsV0FBTyxNQUFFO0FBQ3hCLGNBQVksV0FBSyxNQUF1QixxQkFBUyxTQUN2RDtBQUFFLGFBQUs7QUFDRCxjQUFZLFdBQ2xCOzs7QUFFQSxVQUFVOzs7QUFHUCxVQUFPLE9BQVMsU0FBTyxRQUFFO0FBQ25CLGlCQUFRLE9BQVMsU0FDMUI7QUFBRSxhQUFLO0FBQ0UsaUJBQVEsT0FBUyxTQUFVLFdBQU8sT0FBUSxPQUFTLFNBQzVEOzs7QUFFQSxVQUFhOztBQUVWLFVBQUksSUFBTyxRQUFFO0FBQ0osb0JBQUssSUFDakI7QUFBRSxhQUFLO0FBQ0ssb0JBQUssSUFBVSxXQUFPLE9BQUssSUFDdkM7OztBQUVHLFVBQVcsY0FBVSxRQUFFO0FBQ3hCLGVBQ0Y7OztBQUVBLFVBQW1CLGlCQUFLLElBQVUsV0FBSyxJQUFRLFNBQUssSUFBSzs7O0FBR3RELFVBQWUsZUFBSSxPQUFPLEtBQUU7QUFDZCx5QkFBTSxNQUN2Qjs7OztBQUdHLFVBQUssS0FBaUIsbUJBQ3JCLENBQUssS0FBZ0IsZ0JBQUssS0FBZ0IsaUJBQUU7QUFDOUMsZUFDRjs7OztBQUdBLFVBQXVCLHFCQUFZLFdBQ2pCLGdCQUFRLE9BQVMsU0FBTSxNQUFLO0FBQzlDLGFBQ0Y7QUFBQzs7QUFFVSxpQkFBVSxxQkFBYyxlQUFFO0FBQ25DLGFBQWEsT0FDZjtBQUVKO0FBM1RVO0FBMlROLEs7Ozs7Ozs7Ozs7O0FDcllROztBQUVMO0FBQ0gsTUFBcUI7O0FBRWI7QUFDSTtBQUNOLFlBQVE7QUFDTixjQUFNO0FBQ0osZ0JBQ1Q7QUFKYTs7QUFNRjtBQUNOLFlBQVE7QUFDTixjQUFNO0FBQ1AsYUFBVyxpQkFBRTtBQUNoQixlQUNGO0FBQ0Q7QUFOYTs7QUFRSjtBQUNKLFlBQVM7QUFDUixhQUVSO0FBSmE7QUFmRjs7QUFxQkU7QUFDTixZQUNQO0FBRmU7O0FBSVAsYUFBRSxDQUVWOztBQUVrQix1QkFBVywrQkFBRTtBQUMxQixTQUFZLGFBQU07QUFDbEIsU0FBYyxlQUFNLEtBQWMsY0FBSyxLQUFjO0FBQ3JELFNBQVksYUFDbEI7QUFBQzs7QUFFa0IsdUJBQVcsK0JBQUU7QUFDM0IsUUFBSyxLQUFXLFlBQUU7QUFFckI7O0FBQ0ksU0FBYyxlQUFNLEtBQWMsY0FBSyxLQUN2QyxjQUFRLFFBQU8sUUFBTSxLQUFRLFFBQU8sUUFBTSxLQUFRLFFBQUssTUFDN0Q7QUFBQzs7QUFFWSxpQkFBVSx1QkFBTyxRQUFFO0FBQzlCLFFBQWtCLGdCQUFJOztBQUVsQixTQUFDLElBQVEsT0FBUyxRQUFFO0FBQ3RCLFVBQVUsUUFBUSxPQUFLOztBQUVwQixVQUFPLFVBQU0sSUFBRTtBQUNILHNCQUFLLEtBQW1CLG1CQUV2QztBQUFFLGFBQVEsSUFBTSxPQUFFO0FBQ0gsc0JBQUssS0FDSSxtQkFBTSxPQUNwQixNQUNjLG1CQUFNLE1BRTlCO0FBQ0Y7O0FBQ0EsV0FBb0IsY0FBSyxLQUMzQjtBQUFDOztBQUVZLGlCQUFVLHVCQUFZLGFBQUU7QUFDbkMsUUFBVyxTQUFJOzs7QUFHSCxrQkFBRSxDQUFhLGVBQU0sSUFBUSxRQUFNLE9BQVE7QUFDdkQsUUFBYyxZQUFhLFlBQU0sTUFBSztBQUNsQyxTQUFDLElBQU0sSUFBRyxHQUFJLElBQVcsVUFBTyxRQUFLLEtBQUU7QUFDekMsVUFBVSxRQUFXLFVBQUcsR0FBTSxNQUFLO0FBQ2hDLFVBQU0sTUFBRyxJQUFFO0FBQ04sZUFBbUIsbUJBQU0sTUFBTSxPQUNmLG1CQUFNLE1BQUksTUFDbEM7QUFDRjs7QUFDQSxXQUNGO0FBQ0E7QUFqRk0sRzs7Ozs7Ozs7O0FDTlIsQ0FBVSxZQUFFO0FBQ0U7Ozs7Ozs7Ozs7O0FBVUwsVUFBMkI7QUFDdEI7Ozs7Ozs7Ozs7QUFVSDtBQUNDLGNBQVE7QUFDTixnQkFDUDtBQUhNOzs7Ozs7OztBQVdJO0FBQ0wsY0FBUTtBQUNOLGdCQUNQO0FBSFk7Ozs7Ozs7QUFVVDtBQUNFLGNBQVE7QUFDTixnQkFFVDtBQUpPO0FBL0JJOztBQXFDSCxlQUFFLENBQzRCLHVDQUNJLDJDQUUxQzs7QUFFTSxhQUFXLG1CQUFFO0FBQ2QsV0FBVSxVQUFzQix1QkFBZ0I7QUFDaEQsV0FBVSxVQUFjLGVBQzlCO0FBQUM7Ozs7O0FBS2Usc0JBQVcsNEJBQUU7QUFDeEIsVUFBSyxLQUFPLFNBQ1AsS0FBTSxNQUFNLFNBQVEsS0FBTSxRQUMxQixLQUFhLGdCQUFRLEtBQU0sTUFBYyxlQUFFO0FBRW5EOztBQUNJLFdBQU87QUFDSCxnQkFBSTtBQUNOLGNBQU0sS0FBSztBQUNGLHVCQUFNLEtBRXZCO0FBTGU7QUFLZDs7Ozs7QUFLWSxtQkFBVyx5QkFBRTtBQUNyQixVQUFDLENBQUssS0FBTSxPQUFFO0FBRWpCOzs7QUFFSSxXQUFNLE9BQU0sS0FBTSxNQUFRLFNBQU0sS0FBTSxNQUM1QztBQUFDOzs7Ozs7OztBQVF1Qiw4QkFBVSxrQ0FBWSxhQUFFO0FBQzNDLFVBQUMsQ0FBSyxLQUFNLE9BQUU7QUFFakI7O0FBQ0ksV0FBYSxjQUNuQjtBQUVKO0FBekZzQztBQXlGbEMsSzs7Ozs7Ozs7Ozs7QUN4QkosQ0FBVSxZQUFFO0FBQ0U7O0FBRUw7QUFDSCxRQUFhOztBQUVMOzs7O0FBSUg7QUFDQyxjQUFRO0FBQ04sZ0JBQ1A7QUFITTs7Ozs7Ozs7OztBQWFBO0FBQ0QsY0FDTDtBQUZROzs7Ozs7QUFRTDtBQUNFLGNBQVE7QUFDUCxlQUFXLGlCQUFFO0FBQUMsaUJBQVU7QUFBQztBQUN4QixnQkFDUDtBQUpLOzs7OztBQVNLO0FBQ0wsY0FBUTtBQUNQLGVBQVcsaUJBQUU7QUFDaEIsaUJBQ0Y7QUFBQztBQUNLLGdCQUNQO0FBTlk7Ozs7O0FBV1Q7QUFDRSxjQUFRO0FBQ1AsZUFBVyxpQkFBRTtBQUFDLGlCQUFPLEVBQUssTUFBTSxNQUFRLFFBQU0sTUFBZSxlQUFRO0FBQUM7QUFDckUsZ0JBQ1A7QUFKSzs7Ozs7O0FBVUE7QUFDQSxjQUFTO0FBQ1AsZ0JBQU07QUFDSixrQkFDVDtBQUpPOztBQU1ZO0FBQ2QsY0FBUztBQUNSLGVBQ047QUFIcUI7Ozs7QUFPZDtBQUNGLGNBQVE7QUFDUCxlQUVSO0FBSlc7QUFwRUE7O0FBMEVILGVBQUUsQ0FDMEIscUNBQ0Qsb0NBQ0osZ0NBQ2tCLGtEQUNGLGdEQUUvQzs7QUFFTSxhQUFXLG1CQUFFO0FBQ2QsV0FBVSxVQUFzQix1QkFBdUI7QUFDdkQsV0FBVSxVQUFxQixzQkFDckM7QUFBQzs7Ozs7QUFLd0IsK0JBQVUsbUNBQVksYUFBRTtBQUM1QyxVQUFhLGVBQU8sS0FBSyxNQUFFO0FBQ3pCLFlBQUssS0FBSyxLQUFlLGtCQUFlLGFBQUU7QUFDdkMsZUFBSSxJQUFxQixzQkFDL0I7OztBQUVHLFlBQUMsQ0FBSyxLQUFRLFVBQU8sS0FBcUIsc0JBQUU7QUFFL0M7Ozs7O0FBSUEsWUFBc0Isb0JBQUk7QUFDMUIsWUFBb0Isa0JBQU87QUFDdkIsYUFBQyxJQUFRLE9BQWMsYUFBRTtBQUNWLDRCQUFNLE9BQWEsWUFBSztBQUN0QyxjQUFpQixtQkFDaEIsQ0FBSyxLQUFhLGVBQ1AsWUFBTSxTQUFRLEtBQVksWUFBSyxNQUFFO0FBQzlCLDhCQUNsQjtBQUNGOzs7QUFFSSxhQUFDLElBQVEsT0FBTyxLQUFZLGFBQUU7QUFDN0IsY0FBaUIsbUJBQUksRUFBSyxPQUFlLGNBQUU7QUFDNUIsOEJBQU07QUFFeEI7QUFDRjs7O0FBRUcsWUFBQyxDQUFnQixpQkFBRTtBQUV0Qjs7QUFDSSxhQUFzQix1QkFBTTtBQUM1QixhQUFJLElBQWMsZUFBb0I7QUFDdEMsYUFBc0IsdUJBQzVCO0FBQ0Y7QUFBQzs7QUFFdUIsOEJBQVUsa0NBQVksYUFBRTtBQUMzQyxVQUFhLGVBQU8sS0FBTyxTQUFPLEtBQU0sTUFBZSxpQkFBYyxhQUFFO0FBQ3BFLGFBQUksSUFBc0IsdUJBQ2hDO0FBQ0Y7QUFBQzs7QUFFbUIsMEJBQVUsOEJBQVEsU0FBRTtBQUNuQyxVQUFDLENBQUssS0FBUSxVQUFPLEtBQXFCLHNCQUFFO0FBRS9DOzs7QUFFSSxXQUFJLElBQVksYUFBUyxRQUFLLE1BQVMsUUFDN0M7QUFBQzs7QUFFZ0IsdUJBQVcsNkJBQUU7QUFDeEIsV0FBVyxXQUFPO0FBQ2xCLFdBQVUsV0FDaEI7QUFBQzs7QUFFVyxrQkFBVyx3QkFBRTtBQUNwQixVQUFDLENBQUssS0FBTSxPQUFFO0FBRWpCOzs7QUFFQSxVQUFTLE9BQU0sS0FBTSxNQUFLO0FBQzFCLFVBQVksVUFBTSxLQUFROztBQUV2QixVQUFDLENBQVEsU0FBRTtBQUVkOzs7QUFFRyxVQUFDLENBQUssTUFBRTtBQUNMLGFBQW9CO0FBRTFCOzs7QUFFQSxVQUFvQixrQkFBTSxLQUFNLE1BQUs7QUFDckMsVUFBa0IsZ0JBQVMsUUFBTSxNQUFLOztBQUV0QyxVQUFZLFVBQUk7QUFDaEIsVUFBaUIsZUFBSTs7QUFFakIsV0FBQyxJQUFLLElBQUUsR0FBSSxJQUFlLGNBQU8sUUFBSyxLQUFFO0FBQzNDLFlBQWlCLGVBQWUsY0FBRztBQUNoQyxZQUFDLENBQWMsZ0JBQWdCLGlCQUFNLElBQUU7QUFFMUM7O0FBQ0EsWUFBYyxZQUFpQixnQkFBUTs7O0FBR3BDLFlBQUMsQ0FBVyxhQUFhLGNBQU0sSUFBRTtBQUM5QixlQUFvQjtBQUUxQjs7QUFDTyxnQkFBSyxLQUFXOztBQUVwQixZQUFhLGFBQU8sT0FBSSxNQUFNLEtBQUU7QUFDckIsdUJBQWEsYUFBTSxNQUFLLE1BQ3RDO0FBQUUsZUFBUSxJQUFjLGlCQUFhLFdBQUU7QUFDakMsZUFBb0I7QUFFMUI7QUFDRjs7O0FBRUksV0FBVSxXQUFTLFFBQUssS0FBSzs7O0FBR2pDLFVBQW9CLGtCQUFJOzs7QUFHckIsVUFBQyxDQUFLLEtBQU8sUUFBRTtBQUNELHdCQUFRLFNBQ3pCOzs7O0FBR0EsVUFBZSxhQUFNLEtBQU0sTUFBUSxTQUFNLEtBQVM7QUFDbEQsVUFBYSxXQUFpQixnQkFBSyxLQUFLO0FBQ3JDLFVBQWdCLGdCQUFRLFNBQUcsR0FBRTtBQUNyQixtQkFBTSxNQUNqQjs7QUFDRyxVQUFDLENBQUssS0FBTSxRQUNQLEtBQUssS0FBUSxXQUFlLGNBQzVCLEtBQUssS0FBTSxTQUFZLFVBQUU7QUFDaEIsd0JBQU07QUFDYixrQkFBWTtBQUNkLGdCQUFVO0FBQ0QseUJBQU0sS0FBTSxNQUU3QjtBQUx5Qjs7OztBQVFWLHNCQUFNLE9BQWM7QUFDL0IsV0FBWSxhQUFJO0FBQ2hCLFdBQUMsSUFBUSxPQUFlLGNBQUU7QUFDeEIsYUFBVyxXQUFNLE9BQWMsYUFDckM7OztBQUVHLFVBQUssS0FBYyxlQUFFO0FBQ25CLFlBQUMsQ0FBSyxLQUFPLFFBQUU7QUFDWixlQUFXLFdBQ2pCOzs7QUFFSSxhQUFjLGNBQ3BCO0FBQUUsYUFBSztBQUNELGFBQVcsV0FDakI7QUFDRjtBQUFDOztBQUVnQix1QkFBVSwyQkFBSyxNQUFFO0FBQzdCLFVBQUMsQ0FBSyxLQUFPLFFBQUU7QUFFbEI7O0FBQ0EsVUFBYSxXQUFNO0FBQ25CLFVBQVksVUFBTSxLQUFTO0FBQ3hCLFVBQVMsVUFBRTtBQUNULFlBQVMsU0FBTyxPQUFJLE9BQU8sS0FBRTtBQUNyQixxQkFBTSxNQUNqQjs7QUFDUSxtQkFDVjs7QUFDSSxXQUFJLElBQWEsY0FDdkI7QUFBQzs7QUFFdUIsOEJBQVcsb0NBQUU7QUFDaEMsVUFBQyxDQUFLLEtBQU8sU0FBRyxDQUFLLEtBQU8sUUFBRTtBQUVqQzs7QUFDQSxVQUFZLFVBQU0sS0FBVSxVQUFJO0FBQ2hDLFVBQVksVUFBTSxLQUFVLFVBQUssS0FBWTtBQUMxQyxVQUFTLFlBQVcsU0FBRTtBQUV6Qjs7QUFDSSxXQUFJLElBQWEsY0FDdkI7QUFBQzs7QUFFUSxlQUFVLG1CQUFlLGdCQUFFO0FBQ2xDLFVBQVcsU0FBRSxFQUFLLE1BQU87QUFDckIsV0FBQyxJQUFRLE9BQU8sS0FBSyxNQUFFO0FBQ25CLGVBQU0sT0FBTSxLQUFLLEtBQ3pCOztBQUNJLFdBQUMsSUFBUSxPQUFpQixnQkFBRTtBQUN4QixlQUFNLE9BQWdCLGVBQzlCOztBQUNBLFVBQWtCLGdCQUFNLEtBQVEsUUFBTSxNQUFLO0FBQzNDLFVBQVcsdUJBQW1CLElBQVMsVUFBTSxPQUFFO0FBQzFDLFlBQU0sTUFBSSxNQUFNLEtBQUU7QUFDYixrQkFBUSxPQUFNLE1BQU0sTUFDNUI7O0FBQ0EsZUFDRjtBQUFDLE9BTHlCLEVBS2xCO0FBQ0wsVUFBTyxPQUFNLFFBQVMsT0FBSyxLQUFLLE1BQUU7QUFDaEMsWUFBTyxPQUFRLFNBQUksS0FBUyxPQUFLLEtBQUssS0FBTyxPQUFJLE9BQU8sS0FBRTtBQUNyRCxpQkFBSyxLQUFPLE9BQUssS0FBSyxLQUFNLE1BQ3BDO0FBQUUsZUFBSztBQUNDLGlCQUFLLEtBQU8sT0FBSyxLQUN6QjtBQUNGOztBQUNBLGFBQWEsT0FBSyxLQUNwQjtBQUFDOztBQUVTLGdCQUFVLG9CQUFPLFFBQUU7Ozs7Ozs7Ozs7OztBQVl2QixXQUFDLElBQWEsWUFBUyxRQUFFO0FBQ3ZCLGFBQWdCLGdCQUFTLFVBQVEsT0FDdkM7OztBQUVHLFVBQU8sT0FBTSxTQUFhLFdBQUU7QUFDekIsYUFBYyxjQUFPLFFBQU0sS0FBTTtBQUNqQyxhQUFjLGNBQ3BCOztBQUNHLFVBQU8sT0FBUSxXQUFhLFdBQUU7QUFDM0IsYUFBYyxjQUFTLFVBQU0sS0FBUTtBQUNyQyxhQUFjLGNBQ3BCOztBQUNHLFVBQU8sT0FBTSxTQUFhLFdBQUU7QUFDekIsYUFBYyxjQUFPLFFBQU0sS0FBTTtBQUNqQyxhQUFjLGNBQ3BCO0FBQ0Y7QUFFSjtBQW5VVTtBQW1VTixLOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDcldLOztBQUVILE1BQWM7O0FBRVAsYUFBRSxDQUNGLFFBQXNCLHVCQUN0QixRQUNSOztBQUVTOzs7Ozs7QUFNSztBQUNQLFlBQVE7QUFDUCxhQUdSO0FBTGdCOztBQU5MOztBQWFILGFBQUUsQ0FFVjs7QUFFbUIsd0JBQVUsOEJBQVMsVUFBSyxLQUFFO0FBQ3hDLFNBQU0sTUFBSyxLQUNqQjtBQUNBO0FBN0JNLEc7Ozs7Ozs7Ozs7Ozs7OztBQ3BDSCxRQUFlLGdCQUFVLFVBQWUsZ0JBQUU7QUFDM0MsT0FBVyxZQUFJO0FBQ2YsT0FBZ0IsaUJBQ3RCO0FBQUM7O0FBRU0sUUFBYyxjQUFXOzs7Ozs7Ozs7O0FBVTNCLE9BQVcsZUFBRTtBQUNkLFdBQVcsS0FBTyxRQUFNLEtBQVUsVUFBUyxVQUFNLEtBQVUsVUFDN0Q7QUFBQzs7Ozs7Ozs7QUFRSSxTQUFVLGVBQVMsVUFBRTtBQUNwQixTQUFVLFVBQVEsUUFBUSxRQUFTLFVBQUssTUFBRTtBQUN6QyxVQUFDLENBQVUsWUFBVyxTQUFRLFFBQU8sUUFBRyxHQUFFO0FBQ3ZDLGFBQWdCLGdCQUFLLE1BQzNCO0FBQ0Y7QUFBQyxPQUNIO0FBQUM7Ozs7Ozs7OztBQVNTLGNBQVUsb0JBQUssTUFBRTtBQUN6QixXQUFXLEtBQVUsVUFBUSxRQUFPLFNBQ3RDO0FBQUM7Ozs7Ozs7OztBQVNjLG1CQUFVLHlCQUFLLE1BQVksWUFBRTtBQUN2QyxRQUFNLFFBQU8sTUFBRTtBQUNiLFVBQVksZUFBUSxLQUFXLFdBQU0sT0FBRTs7QUFFckMsWUFBVyxZQUFFO0FBQ1YsZUFBVSxVQUFLLEtBQ3JCO0FBQUUsZUFBSztBQUNMLGNBQU0sSUFBTSxLQUFVLFVBQVEsUUFBTTtBQUNqQyxjQUFHLEtBQUksR0FBRTtBQUNOLGlCQUFVLFVBQU8sT0FBRSxHQUN6QjtBQUNGOztBQUNHLFlBQUssS0FBZSxnQkFBRTtBQUNuQixlQUFlLGVBQUssTUFDMUI7QUFDRjtBQUNGO0FBQ0Y7QUFBQzs7Ozs7Ozs7OztBQVVLLFVBQVUsZ0JBQUssTUFBRTtBQUNsQixRQUFLLEtBQU0sT0FBRTtBQUNWLFdBQU8sT0FDYjtBQUFFLFdBQVEsSUFBSyxLQUFPLFVBQVEsTUFBRTtBQUMxQixXQUFnQixnQkFBSyxLQUFNLE9BQVE7QUFDbkMsV0FBZ0IsZ0JBQUssTUFDM0I7QUFDRjtBQUFDOzs7Ozs7OztBQVFLLFVBQVUsZ0JBQUssTUFBRTtBQUNqQixTQUFnQixnQkFBSyxNQUFFLENBQUssS0FBVyxXQUM3QztBQUVEOztBQTVGaUMsRTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNvRDNCOztBQUVILE1BQWlCOztBQUVWLGFBQUUsQ0FDRixRQUdUOztBQVJNLEc7Ozs7Ozs7Ozs7Ozs7Ozs7QUMzREQsUUFBaUM7QUFDNUI7Ozs7O0FBS0g7QUFDQyxZQUFTO0FBQ1IsYUFBTztBQUNKLGdCQUNUO0FBSk07Ozs7OztBQVVPO0FBQ1IsWUFBTztBQUNMLGNBQU07QUFDUCxhQUFXLGlCQUFFO0FBQ2hCLGVBQ0Y7QUFDRDtBQU5lOzs7OztBQVdIO0FBQ1AsWUFBTztBQUNILGdCQUFNO0FBQ1IsY0FBTTtBQUNQLGFBQVcsaUJBQUU7QUFDaEIsZUFDRjtBQUdIO0FBVGdCOztBQTFCTDs7QUFxQ0gsYUFBRSxDQUVWOzs7Ozs7Ozs7QUFTSyxVQUFVLGdCQUFNLE9BQUU7QUFDbkIsUUFBSyxLQUFNLE9BQUU7QUFDVixXQUFnQixnQkFDdEI7QUFBRSxXQUFLO0FBQ0QsV0FBVSxXQUNoQjtBQUNGO0FBQUM7O0FBRVcsZ0JBQVUsc0JBQU0sT0FBRTtBQUN4QixTQUFXLFdBQU8sUUFBTztBQUN6QixTQUNOO0FBQUM7OztBQUdELE1BQTJCLHlCQUFFO0FBQzNCLFdBQVcsS0FBVSxZQUNuQixRQUFLLEtBQWdCLGtCQUFRLFFBQU8sS0FBZSxlQUN2RDtBQUFDOztBQUVxQiwwQkFBVyxrQ0FBRTtBQUM5QixRQUFDLENBQUssS0FBTSxPQUFFO0FBQ1IsY0FBdUIsdUJBQXVCLHVCQUFNLE1BQzdEO0FBQUUsV0FBUSxJQUFLLEtBQWUsaUJBQU8sS0FBYyxjQUFRLFNBQUcsR0FBRTtBQUMxRCxXQUFnQixzQkFBb0IsY0FBSSxJQUFTLFVBQWEsY0FBRTtBQUNsRSxlQUFXLEtBQWMsY0FBSyxLQUFRLFFBQ3hDO0FBQUMsT0FGeUIsRUFFbEIsTUFBTyxPQUFTLFVBQWdCLGlCQUFFO0FBQ3hDLGVBQXVCLG1CQUN6QjtBQUFDLFNBQ0g7QUFDRjtBQUFDOztBQUVjLG1CQUFXLDJCQUFFO0FBQ3ZCLFFBQUssS0FBTSxPQUFFO0FBQ1YsV0FBYSxhQUFLLEtBQ3hCO0FBQUUsV0FBSztBQUNELFdBQWdCLGdCQUFLLEtBQzNCO0FBQ0Y7QUFBQzs7QUFFVyxnQkFBVSxzQkFBTyxRQUFFO0FBQ3RCLGFBQVMsVUFBSzs7QUFFckIsUUFBa0IsaUJBQU8sS0FBZSxlQUFTLFdBQU0sSUFBTyxPQUFTLFVBQUssTUFBRTtBQUM1RSxhQUFZLFNBQVMsUUFBUSxTQUMvQjtBQUFFLEtBRmtCOzs7QUFLaEIsU0FBVyxXQUFNLE1BQWU7OztBQUdoQyxTQUFDLElBQU0sSUFBRyxHQUFJLElBQWUsY0FBTyxRQUFLLEtBQUU7QUFDekMsV0FBVyxXQUFnQixnQkFBYyxjQUFHLElBQ2xEOzs7O0FBR0csUUFBSyxLQUFtQixxQkFBRyxDQUFLLEtBQVcsV0FBTSxNQUFPLFFBQUU7QUFDM0QsVUFBYSxXQUFNLEtBQWEsYUFBSyxLQUFtQjtBQUNyRCxVQUFTLFVBQUU7QUFDUixhQUFPLE9BQUssS0FDbEI7QUFDRjtBQUNGO0FBQUM7O0FBRWUsb0JBQVcsNEJBQUU7QUFDM0IsUUFBTSxJQUFNLEtBQVcsV0FBTTtBQUMxQixRQUFLLEtBQU0sT0FBRTtBQUNWLFdBQWtCLGtCQUFHO0FBQ3JCLFdBQWlCLGlCQUFFLEVBQVEsU0FBRyxFQUFJLEtBQ3hDO0FBQUUsV0FBSztBQUNGLFVBQUcsTUFBUyxRQUFLLE1BQWEsV0FBRTtBQUM3QixhQUFrQixrQkFBQyxDQUFJO0FBQ3ZCLGFBQWlCLGlCQUN2QjtBQUFFLGFBQUs7QUFDRCxhQUFrQixrQkFBSTtBQUN0QixhQUFpQixpQkFDdkI7QUFDRjtBQUNGO0FBQUM7O0FBRWMsbUJBQVUseUJBQU0sT0FBRTtBQUMvQixRQUFNLElBQU0sS0FBZSxlQUFRLFFBQU87QUFDMUMsUUFBZSxhQUFJLElBQUc7QUFDbkIsUUFBVyxZQUFFO0FBQ1YsV0FBSyxLQUFpQixrQkFDNUI7QUFBRSxXQUFLO0FBQ0QsV0FBTyxPQUFpQixrQkFBRSxHQUNoQztBQUNGO0FBQUM7O0FBRWEsa0JBQVUsd0JBQU8sUUFBRTtBQUMvQixXQUFlLFVBQVMsSUFBakIsR0FBd0IsY0FBWSxJQUFTLFVBQU0sT0FBRTtBQUMxRCxhQUFXLEtBQWEsYUFDMUI7QUFBQyxLQUZzQyxFQUd6QztBQUNEO0FBL0l5Qzs7O0FBa0puQyxRQUE2Qiw4QkFBRSxDQUM3QixRQUF1Qix3QkFDdkIsUUFDUixpQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbkNRO0FBQ0gsTUFBcUI7O0FBRVQ7QUFDUixVQUFVO0FBQ04sY0FDVDtBQUhlOztBQUtQLGFBQUUsQ0FDRixRQUNSOztBQUVTOzs7OztBQUtMO0FBQ0csWUFDTDtBQUZJOzs7Ozs7O0FBU0Q7QUFDRSxZQUNMO0FBRks7Ozs7O0FBT0g7QUFDRyxZQUFRO0FBQ0osZ0JBRVg7QUFKTTtBQXJCSzs7QUEyQkQsZUFBVSxxQkFBUyxVQUFVLFVBQUU7QUFDeEMsUUFBVSxRQUFNLEtBQWEsYUFBYzs7O0FBR3hDLFFBQUMsQ0FBTyxTQUFZLFlBQVEsT0FBRTtBQUMzQixXQUFhLGFBQWEsY0FDaEM7QUFDRjtBQUNBO0FBL0NNLEc7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNyQkQ7O0FBRUgsTUFBYTs7QUFFTDs7Ozs7O0FBTUo7QUFDRSxZQUNMO0FBRks7Ozs7OztBQVFEO0FBQ0MsWUFDTDtBQUZNOzs7Ozs7O0FBU0o7QUFDRyxZQUNMO0FBRkk7Ozs7O0FBT0E7QUFDRSxhQUFTLFFBQUssS0FBTyxPQUFZLGFBQUUsRUFBSyxNQUdoRDtBQUpROztBQTlCRzs7QUFvQ0gsYUFBRSxDQUN1QixrQ0FDQSxrQ0FDRixnQ0FFL0I7O0FBRWUsb0JBQVM7O0FBRWIsZ0JBQVUsc0JBQUssTUFBRTtBQUMzQixRQUFVLFFBQUUsQ0FBTSxRQUFNLElBQU0sTUFBSztBQUMvQixTQUFXLFlBQU8sTUFBTTtBQUN4QixTQUFjLGVBQU8sTUFBTyxTQUFPLEtBQWlCO0FBQ3BELFNBQ047QUFBQzs7QUFFVSxlQUFVLHFCQUFJLEtBQUU7QUFDckIsU0FDTjtBQUFDOztBQUVXLGdCQUFXLHdCQUFFO0FBQ3ZCLFdBQVcsS0FBTSxRQUFHLENBQUssS0FDM0I7QUFBQzs7O0FBR1UsZUFBVyx1QkFBRTtBQUNuQixRQUFLLEtBQWUsZ0JBQUU7QUFDcEIsVUFBSyxLQUFNLFFBQU8sS0FBSyxLQUFXLFlBQUU7QUFDOUIsZ0JBQUksSUFBSyxLQUFNLE1BQVksWUFBSyxLQUN6Qzs7QUFDRyxVQUFLLEtBQVcsY0FBTSxJQUFFO0FBQ3RCLFlBQUssS0FBUyxVQUFFO0FBQ2IsZUFBUyxTQUFXLFdBQzFCO0FBQ0Y7QUFBRSxhQUFRLElBQUssS0FBYyxnQkFBTyxLQUFNLE9BQUU7QUFDdEMsYUFBVSxXQUFrQywrQkFDMUMsS0FBTSxNQUFNLE1BQUssS0FBZTtBQUNuQyxZQUFLLEtBQVMsVUFBRTtBQUNiLGVBQVMsU0FBVSxVQUFLLE1BQU0sS0FBVSxXQUFNLEtBQU87QUFDckQsZUFBUyxTQUFPLFFBQXNCLHNCQUM1QztBQUFFLGVBQUs7QUFDRCxlQUFPLE9BQU8sUUFBc0Isc0JBQzFDO0FBQ0Y7QUFDRjtBQUFFLFdBQUs7QUFDRixVQUFLLEtBQVMsVUFBRTtBQUNiLGFBQVMsU0FBVyxXQUMxQjs7QUFDRyxVQUFDLENBQUssS0FBSyxNQUFFO0FBQ1YsYUFBTSxPQUFVLFNBQWMsY0FBTztBQUNyQyxhQUFLLEtBQU0sTUFBTyxRQUFRO0FBQzFCLGFBQUssS0FBTSxNQUFRLFNBQVE7QUFDM0IsYUFBSyxLQUFXLFlBQ3RCOztBQUNJLFdBQUssS0FBSyxNQUFNLEtBQUk7QUFDakIsY0FBSSxJQUFLLEtBQU0sTUFBWSxZQUFLLEtBQ3pDO0FBQ0Y7QUFFQTs7QUFuR00sRzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMxRkgsUUFBNEI7QUFDeEIsYUFBRSxDQUVWOztBQUVjLG1CQUFVLHlCQUEwQiwyQkFBRTtBQUNoRCxRQUEwQiwyQkFBRTtBQUN6QixXQUNOOztBQUNHLFFBQUssS0FBWSxhQUFFO0FBQ2hCLFdBQVEsUUFBVSxXQUN4QjtBQUNGO0FBQUM7O0FBRVksaUJBQVcseUJBQUU7QUFDeEIsUUFBVyxTQUFTLFFBQW9CLG9CQUFnQjtBQUNsRCxXQUFJLEtBQU87QUFDWCxXQUFhLGFBQVMsVUFBSztBQUMzQixXQUFVLFVBQUksSUFBVTtBQUM5QixXQUNGO0FBQ0Q7QUFyQm9DOzs7QUF3QjlCLFFBQXdCLHlCQUFFLENBQ3hCLFFBQWdCLGlCQUNoQixRQUFpQixrQkFDakIsUUFBb0IscUJBQ3BCLFFBQ1IsNEI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM3Qk0sUUFBcUI7O0FBRWhCOzs7OztBQUtEO0FBQ0QsWUFBUztBQUNMLGdCQUFNO0FBQ1QsYUFBTztBQUNNLDBCQUFNO0FBQ2hCLGdCQUNUO0FBTlE7Ozs7OztBQVlGO0FBQ0QsWUFBUztBQUNSLGFBQU87QUFDTSwwQkFDbkI7QUFKUTs7Ozs7QUFTSDtBQUNBLFlBQVM7QUFDUixhQUFPO0FBQ04sY0FBTTtBQUNNLDBCQUNuQjtBQUxPOzs7Ozs7O0FBWUc7QUFDTCxZQUFTO0FBQ0wsZ0JBQU07QUFDVCxhQUNOO0FBSlk7Ozs7OztBQVVZO0FBQ25CLFlBQVM7QUFDTCxnQkFDVDtBQUgwQjs7Ozs7O0FBU1I7QUFDYixZQUFRO0FBQ1AsYUFBZ0I7QUFDYixnQkFFWDtBQUxzQjtBQXpEWDs7QUFnRUg7QUFDSCxVQUFnQjtBQUNsQixRQUFjO0FBQ2IsU0FDSjtBQUpVOztBQU1GLGFBQUUsQ0FDZSwwQkFFekI7O0FBRVU7QUFDTSxxQkFBZTtBQUNmLHFCQUF3QjtBQUMxQixtQkFDZDtBQUpZOztBQU1BLGlCQUFVOztBQUVaLGVBQVcsdUJBQUU7QUFDbkIsUUFBSyxLQUFRLFNBQUU7O0FBRVosV0FBYyxjQUFDLENBQUssS0FDMUI7QUFBRSxXQUFLO0FBQ0QsV0FBUSxTQUNkO0FBQ0Y7QUFBQzs7QUFFWSxpQkFBVSx1QkFBUSxTQUFFO0FBQzNCLFNBQXFCLHFCQUFTOztBQUUvQixRQUFDLENBQVEsU0FBRTtBQUNSLFdBQVksWUFDbEI7QUFDRjtBQUFDOztBQUVtQix3QkFBVSw4QkFBUSxTQUFFO0FBQ2xDLFNBQThCLDhCQUFDLENBQUssS0FBYSxlQUN2RDtBQUFDOzs7O0FBSVksaUJBQVUsdUJBQU8sUUFBRTtBQUMzQixRQUFLLEtBQVEsV0FBVSxRQUFFO0FBQ3RCLFdBQVEsU0FBUTtBQUNoQixXQUFLLEtBQ1g7QUFDRjtBQUFDOztBQUVXLGdCQUFVLHNCQUFNLE9BQUU7QUFDeEIsU0FBZ0IsZ0JBQU07QUFDdEIsU0FBWSxZQUFNO0FBQ2xCLFNBQThCLDhCQUNwQztBQUFDOztBQUVTLGNBQVcsc0JBQUU7QUFDakIsU0FBZ0IsZ0JBQU87QUFDdkIsU0FBWSxZQUNsQjtBQUFDOzs7OztBQUttQix3QkFBVSw4QkFBTSxPQUFFO0FBQ3BDLFFBQWtCLGdCQUFPLE1BQU8sT0FBYztBQUM5QyxRQUFXLFNBQVMsUUFBSSxJQUFlLGVBQVk7Ozs7QUFJaEQsUUFBSyxLQUFrQixtQkFBb0IsbUJBQVMsU0FDL0M7O0FBRUssa0JBQWlCO0FBQ2pCLGtCQUEyQjtBQUNwQyxTQUFZLFlBQ2xCO0FBQUM7Ozs7O0FBS2lCLHNCQUFVLDRCQUFNLE9BQUU7QUFDbEMsUUFBa0IsZ0JBQU8sTUFBTyxPQUFjO0FBQzlDLFFBQVcsU0FBUyxRQUFJLElBQWUsZUFBWTs7OztBQUloRCxRQUFLLEtBQWtCLG1CQUFvQixtQkFBUyxTQUMvQzs7QUFFTCxRQUFLLEtBQVEsU0FBRTtBQUNaLFdBQ047O0FBQ0ksU0FBWSxZQUNsQjtBQUFDOzs7O0FBSVUsZUFBVyx1QkFBRTtBQUNsQixTQUFNLE1BQVUsWUFBRTtBQUNoQixXQUNOO0FBQUMsT0FDSDtBQUFDOzs7O0FBSWMsbUJBQVUseUJBQVEsU0FBRTtBQUM3QixTQUNOO0FBQUM7O0FBRTBCLCtCQUFVLHFDQUFNLE9BQVUsVUFBRTtBQUNsRCxRQUFVLFlBQVksWUFBUyxTQUFPLEtBQWEsYUFBVSxXQUFFO0FBQzVELFdBQWdCLGdCQUN0QjtBQUNGO0FBQUM7O0FBRWEsa0JBQVUsd0JBQU8sUUFBcUIscUJBQUU7QUFDakQsUUFBSyxLQUFRLFNBQUU7QUFDWixXQUFhLGFBQUssS0FBb0IscUJBQ2pCLFNBQVMsU0FDcEM7QUFBRSxXQUFLO0FBQ0QsV0FBZ0IsZ0JBQUssS0FDM0I7O0FBQ0ksU0FDTjtBQUFDOztBQUVtQix3QkFBVyxnQ0FBRTtBQUM1QixRQUFLLEtBQVMsVUFBRTtBQUNiLFdBQVksWUFDbEI7QUFBRSxXQUFLO0FBQ0QsV0FDTjtBQUNGO0FBQUM7Ozs7QUFJa0IsdUJBQVcsK0JBQUU7QUFDM0IsUUFBSyxLQUFvQjtBQUN0QixXQUFzQixzQkFERSxDQUU5QjtBQUNGO0FBRUQ7O0FBL002Qjs7O0FBa052QixRQUFpQixrQkFBRSxDQUNqQixRQUFxQixzQkFDckIsUUFDUixxQjs7Ozs7Ozs7Ozs7Ozs7O0FDdk5NLFFBQWtCOztBQUViOzs7OztBQUtEO0FBQ0QsWUFBUztBQUNSLGFBQU87QUFDTixjQUFNO0FBQ0osZ0JBQU07QUFDSSwwQkFDbkI7QUFOUTs7Ozs7QUFXRDtBQUNGLFlBQVM7QUFDUixhQUFPO0FBQ04sY0FBTTtBQUNKLGdCQUFvQjtBQUNWLDBCQUNuQjtBQU5TOztBQVFFO0FBQ04sWUFDTDtBQUZhOztBQUlRO0FBQ2hCLFlBQVU7QUFDVCxhQUFXLGlCQUFFO0FBQ2hCLGVBQVcsS0FBa0Isa0JBQUssS0FDcEM7QUFDRDtBQUx1Qjs7QUFPQTtBQUNsQixZQUFTO0FBQ1IsYUFBVyxpQkFBRTtBQUNoQixlQUFPLENBQUssS0FBWSxjQUFHLENBQVEsUUFDckM7QUFFSDtBQU4yQjtBQW5DaEI7O0FBMkNILGFBQUUsQ0FFVjs7QUFFSSxTQUFXLGlCQUFFO0FBQ1osU0FBaUIsaUJBQVEsU0FBTSxLQUF1Qix3QkFBTztBQUM3RCxTQUFpQixpQkFBTyxRQUFNLEtBQXVCLHdCQUMzRDtBQUFDOztBQUVnQixxQkFBVSwyQkFBTSxPQUFFOztBQUU5QixRQUFRLFFBQVEsU0FBRTtBQUNmLFdBQVksWUFBTSxNQUFNLFNBQVk7QUFFMUM7Ozs7Ozs7O0FBT0csUUFBTSxNQUFRLFdBQVEsTUFBRTtBQUNyQixXQUFZLFlBQU0sTUFBTSxTQUM5QjtBQUFFLFdBQVEsSUFBSyxLQUF5QiwwQkFBRTtBQUN4QyxVQUFXLFNBQXFCLG1CQUFRLFFBQUksSUFBTyxPQUFhO0FBQzdELFVBQUMsQ0FBSyxLQUFrQixrQkFBUSxTQUFFO0FBQy9CLGFBQUssS0FBTSxNQUFLLE1BQUUsRUFBWSxhQUFRO0FBQ3BDLGdCQUFNO0FBQ0gsbUJBQU8sTUFBUTtBQUNaLHNCQUFPLE1BRXJCO0FBTDhDO0FBTWhEO0FBQ0Y7QUFBQzs7QUFFZSxvQkFBVSwwQkFBUyxVQUFLLEtBQUU7QUFDcEMsU0FBYSxhQUFnQixpQkFBVyxXQUFTLFNBQVU7QUFDM0QsU0FBTSxNQUFlLGdCQUFXLFdBQVMsU0FBSTtBQUM5QyxRQUFTLFVBQUU7QUFDUixXQUFjLGVBQU0sS0FBUztBQUM3QixXQUFZLFlBQU87QUFDbkIsV0FBVSxXQUFFLENBQUU7QUFDZCxXQUNOO0FBQUUsV0FBUSxJQUFLLEtBQWMsaUJBQWEsV0FBRTtBQUN0QyxXQUFVLFdBQU0sS0FDdEI7QUFDRjtBQUFDOztBQUVtQix3QkFBVyxnQ0FBRTs7QUFFNUIsUUFBSyxLQUFxQixzQkFBRTtBQUN6QixXQUNOO0FBQ0Y7QUFFRDs7QUFwRzBCLEU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNLcEIsUUFBcUI7QUFDaEI7Ozs7O0FBS0g7QUFDQyxZQUFTO0FBQ0wsZ0JBQ1Q7QUFITTs7Ozs7QUFRUztBQUNWLFlBRVA7QUFIbUI7QUFiUjs7Ozs7O0FBc0JPLHVCQUFXLCtCQUFFO0FBQzNCLFFBQUssS0FBUSxTQUFFO0FBQ1osV0FDTjtBQUNGO0FBQUM7Ozs7OztBQU1XLGdCQUFVLHNCQUFNLE9BQUU7QUFDckIsWUFBb0Isb0JBQWEsYUFBSyxLQUFLLE1BQVE7QUFDdkQsUUFBSyxLQUFRLFNBQUU7QUFDWixXQUFhLGFBQ25CO0FBQ0Y7QUFBQzs7Ozs7Ozs7QUFRVyxnQkFBVSxzQkFBbUIsb0JBQUU7QUFDdEMsUUFBQyxDQUFLLEtBQVksYUFBRTtBQUNqQixXQUFTLFVBQU0sS0FBZ0I7QUFDL0IsV0FBUSxRQUFPLFFBQU0sS0FBTTtBQUMvQixVQUFvQixrQkFBTSxLQUFrQixvQkFBTyxLQUFLO0FBQ3JELFVBQWdCLGlCQUFFO0FBQ1osZ0JBQUksSUFBaUIsaUJBQVksWUFBSyxLQUMvQzs7QUFDRyxVQUFtQixvQkFBRTs7OztBQUl0QixZQUFpQixlQUFTLFFBQUksSUFBSyxLQUFrQixvQkFBUTtBQUM3RCxZQUFXLFNBQVMsUUFBSSxJQUFvQixvQkFBVztBQUNwRCxZQUFhLGFBQWEsY0FBcUIsbUJBQVMsU0FBRTtBQUN2RCxlQUFRLFFBQWEsYUFDM0I7QUFDRjtBQUNGO0FBQ0Y7QUFBQzs7Ozs7Ozs7QUFRUSxhQUFXLHFCQUFFO0FBQ2hCLFNBQWU7QUFDbkIsV0FBVyxLQUNiO0FBQUM7Ozs7OztBQU1RLGFBQVcscUJBQUU7QUFDcEIsV0FBYyxRQUFLLEtBQ3JCO0FBQUM7Ozs7Ozs7QUFPWSxpQkFBVyx5QkFBRTtBQUN4QixXQUEwQyxtQ0FDOUIsU0FBYyxjQUM1Qjs7QUFBQzs7QUFFWSxpQkFBVSx1QkFBTSxPQUFFO0FBQzFCLFFBQUssS0FBWSxhQUFFO0FBQ2hCLFdBQVEsUUFBTyxRQUNyQjtBQUNGO0FBQ0Q7QUFyRzZCLEU7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDZ0k5QixDQUFVLFlBQUU7QUFDRTs7QUFFWixNQUFZO0FBQ0YsY0FBVSxrQkFBRyxJQUFJLElBQUksSUFBSSxJQUFFO0FBQ2pDLFVBQWEsU0FBSSxLQUFLO0FBQ3RCLFVBQWEsU0FBSSxLQUFLOztBQUV0QixhQUFXLEtBQUssS0FBUSxTQUFTLFNBQVMsU0FDNUM7QUFBQzs7QUFFRSxTQUFRLE9BQWEsZUFBUyxPQUFZLFlBQUssTUFDeEMsT0FBWSxZQUFJLElBQUssS0FBTyxPQUFjLGVBQU0sS0FDM0Q7QUFWYTs7Ozs7O0FBZ0JkLFdBQXVCLGVBQVEsU0FBRTtBQUMzQixTQUFTLFVBQVM7QUFDbEIsU0FBTyxRQUFNLEtBQWEsYUFBTTtBQUNoQyxTQUFRLFNBQU0sS0FBYSxhQUFPOztBQUVsQyxTQUFNLE9BQU0sS0FBSSxJQUFLLEtBQU0sT0FBTSxLQUN2Qzs7O0FBRWMsaUJBQVc7QUFDdkIsUUFBa0IsZUFBRTtBQUNsQixhQUFXLEtBQVEsUUFDckI7QUFBQzs7QUFFeUIsZ0NBQVUsb0NBQUUsR0FBRyxHQUFFO0FBQ3pDLFVBQVksVUFBUyxRQUFTLFNBQUUsR0FBRyxHQUFHLEdBQUk7QUFDMUMsVUFBYSxXQUFTLFFBQVMsU0FBRSxHQUFHLEdBQU0sS0FBTSxPQUFJO0FBQ3BELFVBQWUsYUFBUyxRQUFTLFNBQUUsR0FBRyxHQUFHLEdBQU0sS0FBUTtBQUN2RCxVQUFnQixjQUFTLFFBQVMsU0FBRSxHQUFHLEdBQU0sS0FBTSxPQUFNLEtBQVE7O0FBRWpFLGFBQVcsS0FBSSxJQUFRLFNBQVUsVUFBWSxZQUMvQztBQUNEO0FBYjBCOzs7Ozs7QUFtQjNCLFdBQWUsT0FBUSxTQUFFO0FBQ25CLFNBQVMsVUFBUztBQUNsQixTQUFPLFFBQVEsT0FBaUIsaUJBQVMsU0FBTTs7QUFFL0MsU0FBTSxPQUFVLFNBQWMsY0FBTztBQUNyQyxTQUFlLGdCQUFVLFNBQWMsY0FBTztBQUM5QyxTQUFLLEtBQU0sTUFBaUIsa0JBQU0sS0FBTTtBQUN4QyxTQUFLLEtBQVUsVUFBSSxJQUFRO0FBQzNCLFNBQWMsY0FBVSxVQUFJLElBQWtCO0FBQzNDLFlBQUksSUFBSyxLQUFlLGVBQVksWUFBSyxLQUFNOztBQUVsRCxTQUNOOzs7QUFFTSxTQUFZLGFBQUs7O0FBRWpCLFNBQVc7QUFDZixRQUFjLFlBQUU7QUFDZCxhQUFXLEtBQVEsUUFDckI7QUFBQzs7QUFFRCxRQUFXLFNBQUU7QUFDWCxhQUFXLEtBQVEsUUFDckI7QUFBQzs7QUFFRCxRQUFxQixtQkFBRTtBQUNyQixVQUFXOztBQUVSLFVBQUMsQ0FBSyxLQUFlLGdCQUFFO0FBQ3hCLGVBQ0Y7OztBQUVRLGdCQUFTLFFBQU8sUUFBTSxLQUFlOztBQUUxQyxVQUFLLEtBQWEsY0FBRTtBQUNiLG1CQUFPLEtBQ2pCOzs7QUFFQSxhQUNGO0FBQUM7O0FBRUQsUUFBbUIsaUJBQUU7QUFDbkIsYUFBVyxLQUFjLGVBQ2hCLFFBQVEsUUFBTSxLQUFjLGVBQ3ZDO0FBQUM7O0FBRUQsUUFBNEIsMEJBQUU7QUFDNUIsYUFBVyxLQUFrQixtQkFDL0I7QUFBQzs7QUFFRCxRQUEwQix3QkFBRTtBQUMxQixhQUFXLEtBQWdCLGlCQUM3QjtBQUFDOztBQUVELFFBQTRCLDBCQUFFO0FBQzVCLGFBQVcsS0FBeUIsMEJBQU0sS0FDNUM7QUFBQzs7QUFFRCxRQUFtQixpQkFBRTtBQUNuQixhQUFXLEtBQVEsUUFDckI7QUFBQzs7QUFFRCxRQUF5Qix1QkFBRTtBQUN6QixhQUFXLEtBQVEsUUFDckI7QUFBQzs7QUFFRCxRQUFXLFNBQUU7QUFDWCxVQUFXLFNBQU0sS0FBaUIsaUJBQU8sUUFBTSxLQUFpQixpQkFBTTtBQUN0RSxVQUFZLFVBQU0sS0FBaUIsaUJBQVEsU0FBTSxLQUFpQixpQkFBTztBQUN6RSxVQUFlLGFBQU0sS0FBSSxJQUNuQixLQUFLLEtBQVEsU0FBVSxVQUNyQixPQUNOLGNBQU0sTUFBRzs7QUFFWCxVQUFhLFdBQU0sTUFBUSxPQUFZLGFBQVEsT0FBWTtBQUMzRCxVQUFZLFVBQU0sS0FBeUIsMEJBQVU7QUFDckQsVUFBUyxPQUFlLGNBQUcsSUFBTSxLQUFJLElBQUcsSUFBRSxDQUFVOztBQUVwRCxhQUFXLEtBQUksSUFDakI7QUFBQzs7QUFFRCxRQUFZLFVBQUU7QUFDVCxVQUFDLENBQUssS0FBYSxjQUFFO0FBQ3RCLGVBQVcsS0FDYjs7O0FBRUEsYUFBVyxLQUFJLElBQ1osR0FDRyxLQUFnQixpQkFBTSxLQUF1Qix3QkFBTSxLQUUzRDtBQUFDOztBQUVELFFBQWlCLGVBQUU7OztBQUdqQixVQUFpQixlQUFNLEtBQXVCLHdCQUFLO0FBQ25ELFVBQWdCLGNBQU0sS0FBUTs7QUFFOUIsYUFBVyxLQUFJLElBQ1osR0FDRyxLQUFJLElBQWEsY0FFekI7QUFBQzs7QUFFRCxRQUEwQix3QkFBRTtBQUMxQixhQUFXLEtBQVMsVUFBTyxRQUNyQixLQUFRLFVBQU8sS0FBSSxJQUFLLEtBQVUsV0FBUSxPQUNsRDtBQUFDOztBQUVELFFBQXlCLHVCQUFFO0FBQ3pCLGFBQVcsS0FBUyxXQUFPLEtBQWdCLGtCQUNyQyxLQUFRLFVBQU8sS0FBSSxJQUFLLEtBQVUsV0FBUSxPQUNsRDtBQUFDOztBQUVELFFBQXdCLHNCQUFFO0FBQ3hCLGFBQVcsS0FBYyxlQUNuQixLQUF1Qix3QkFBTSxLQUNyQztBQUFDOztBQUVELFFBQXdCLHNCQUFFO0FBQ3hCLGFBQVcsS0FBSSxJQUNaLEdBQ0csS0FBUSxTQUFNLEtBQWlCLGlCQUFNLE9BQUksSUFBTSxLQUFLLEtBRTVEO0FBQUM7O0FBRUQsUUFBUyxPQUFFO0FBQ04sVUFBSyxLQUFLLE1BQUU7QUFDYixlQUFXLEtBQVEsU0FBTSxLQUF1Qix1QkFBSyxLQUFNLE9BQU0sS0FDbkU7OztBQUVBLGFBQVcsS0FDYjtBQUFDOztBQUVELFFBQVMsT0FBRTtBQUNOLFVBQUssS0FBSyxNQUFFO0FBQ2IsZUFBVyxLQUFRLFNBQU0sS0FBdUIsdUJBQUssS0FBTSxPQUFNLEtBQ25FOzs7QUFFQSxhQUFXLEtBQ2I7QUFBQzs7QUFFRCxRQUFnQixjQUFFO0FBQ2hCLGFBQVcsS0FBZ0Isa0JBQUcsQ0FBSyxLQUNyQztBQUFDOztBQUVvQiwyQkFBVyxpQ0FBRTtBQUM1QixXQUFXLFlBQUc7QUFDZCxXQUFnQixpQkFBRztBQUNuQixXQUFjLGVBQUc7O0FBRWpCLFdBQVEsU0FBRztBQUNYLFdBQVEsU0FBRztBQUNYLFdBQU0sT0FBRztBQUNULFdBQU0sT0FBRztBQUNULFdBQWUsZ0JBQUc7O0FBRWxCLFdBQWtCLG1CQUFFLElBQWtCLGVBQUssS0FDakQ7QUFBQzs7QUFFRyxVQUFXLGdCQUFFO0FBQ2YsVUFBUztBQUNULFVBQW1CO0FBQ25CLFVBQU07QUFDTixVQUFNOztBQUVGLFdBQUssS0FBTSxNQUFTLFVBQU0sS0FBUTs7QUFFaEMsY0FBTSxLQUFVLFVBQUssS0FBaUIsaUJBQU0sT0FBSTtBQUNuRCxXQUFNLEtBQVEsT0FBSyxLQUFpQixpQkFBTyxRQUFJO0FBQy9DLFdBQU0sS0FBUSxPQUFLLEtBQWlCLGlCQUFRLFNBQUk7Ozs7QUFLL0MsV0FBYyxjQUFNLE1BQWlCLGtCQUFlLGVBQUssS0FBUyxTQUFLLEtBQU87QUFDOUUsV0FBYyxjQUFNLE1BQVcsWUFBaUIsaUJBQUssS0FBUyxTQUFLLEtBQVU7QUFDN0UsV0FBSyxLQUFNLE1BQWlCLGtCQUFXLFdBQVEsUUFBTSxNQUFRLFFBQUs7QUFDbEUsV0FBSyxLQUFNLE1BQVcsWUFBYSxhQUFRLFFBQU0sTUFBUSxRQUMvRDtBQUFDOzs7QUFHUyxnQkFBVSxvQkFBTSxPQUFFO0FBQzFCLFVBQVksVUFBTSxLQUFpQixpQkFBTyxRQUFHO0FBQzdDLFVBQVksVUFBTSxLQUFpQixpQkFBUSxTQUFHOztBQUUxQyxXQUF3QjtBQUN4QixXQUFnQixpQkFBUyxRQUFNOztBQUVoQyxVQUFLLEtBQU8sUUFBRTtBQUNYLGFBQVEsU0FBUztBQUNqQixhQUFRLFNBQVM7QUFDakIsYUFBZSxnQkFBUyxRQUFTLFNBQy9CLEtBQU8sUUFBTSxLQUFPLFFBQU0sS0FBSyxNQUFNLEtBRTdDO0FBQUUsYUFBSztBQUNELGFBQVEsU0FBUSxRQUNYLE1BQU8sT0FBRyxJQUFNLEtBQWlCLGlCQUFhLGFBQU0sT0FDckQsS0FBaUIsaUJBQU8sUUFBRztBQUMvQixhQUFRLFNBQVEsUUFDWCxNQUFPLE9BQUcsSUFBTSxLQUFpQixpQkFBYSxhQUFLLE1BQ3BELEtBQWlCLGlCQUFRLFNBQ25DOzs7QUFFRyxVQUFLLEtBQVUsV0FBRTtBQUNkLGFBQU0sT0FBUztBQUNmLGFBQU0sT0FBUztBQUNmLGFBQWUsZ0JBQVMsUUFBUyxTQUMvQixLQUFPLFFBQU0sS0FBTyxRQUFNLEtBQUssTUFBTSxLQUU3Qzs7O0FBRUksV0FBVyxZQUFNLEtBQWlCLGlCQUEyQiwyQkFDM0QsS0FBTyxRQUNQLEtBQ0w7O0FBRUcsV0FBYyxjQUFNLE1BQUssTUFDM0IsQ0FBSyxLQUFpQixpQkFBUSxTQUFNLEtBQWlCLGlCQUFPLFFBQUksSUFBTTtBQUNwRSxXQUFjLGNBQU0sTUFBTSxPQUM1QixDQUFLLEtBQWlCLGlCQUFPLFFBQU0sS0FBaUIsaUJBQU8sUUFBSSxJQUFNOztBQUVuRSxXQUFjLGNBQU0sTUFBTyxRQUFNLEtBQWlCLGlCQUFNLE9BQU07QUFDOUQsV0FBYyxjQUFNLE1BQVEsU0FBTSxLQUFpQixpQkFBTSxPQUMvRDtBQUFDOzs7QUFHTyxjQUFVLGtCQUFNLE9BQUU7QUFDckIsVUFBQyxDQUFLLEtBQVksYUFBRTtBQUV2Qjs7O0FBRUksV0FBYyxlQUFTLFFBQzdCO0FBQUM7O0FBRUssWUFBVyxrQkFBRTtBQUNWLGNBQUksSUFBSyxLQUFjLGNBQVksWUFBWSxZQUNoRCxLQUVSO0FBQ0Q7QUFoT2tCOztBQWtPWjtBQUNILFFBQWdCOztBQUVULGVBQUUsQ0FDRixRQUNSOztBQUVTOzs7Ozs7OztBQVFNO0FBQ1IsY0FBUTtBQUNQLGVBQ047QUFIZTs7Ozs7Ozs7O0FBWUk7QUFDZCxjQUFRO0FBQ1AsZUFDTjtBQUhxQjs7Ozs7Ozs7OztBQWFiO0FBQ0gsY0FBUztBQUNSLGVBQ047QUFIVTs7Ozs7Ozs7O0FBWUw7QUFDQSxjQUFTO0FBQ1IsZUFDTjtBQUhPOzs7Ozs7Ozs7QUFZRDtBQUNELGNBQU87QUFDTixlQUFXLGlCQUFFO0FBQ2hCLGlCQUNGO0FBQ0Q7QUFMUTs7Ozs7O0FBV0E7QUFDSCxjQUFTO0FBQ0wsa0JBQU07QUFDSSw0QkFBTTtBQUNuQixlQUNOO0FBTFU7Ozs7OztBQVdIO0FBQ0YsY0FBUztBQUNSLGVBQU87QUFDSixrQkFDVDtBQUpTOzs7Ozs7OztBQVlMO0FBQ0MsY0FBUztBQUNSLGVBQ047QUFITTs7QUFLRztBQUNKLGNBQ0w7QUFGVzs7QUFJQztBQUNQLGNBQVU7QUFDVCxlQUFXLGlCQUFFO0FBQ2hCLGlCQUFXLEtBQVEsUUFBSyxLQUMxQjtBQUVIO0FBTmdCO0FBcEdMOztBQTRHWixRQUFZLFNBQUU7QUFDWixhQUFXLEtBQ2I7QUFBQzs7QUFFVTtBQUNNLHVCQUFtQjtBQUNuQix1QkFBbUI7QUFDckIscUJBQ2Q7QUFKWTs7QUFNTCxjQUFXLG9CQUFFOzs7O0FBSWhCLFVBQUssS0FBVyxXQUFVLFlBQUssSUFBRTs7QUFDOUIsYUFBZ0IsaUJBQVMsUUFBSSxJQUFNLE1BQWUsZUFDeEQ7QUFBRSxhQUFLO0FBQ0QsYUFBZ0IsaUJBQU0sS0FDNUI7O0FBQ0EsVUFBbUIsaUJBQThCLDJCQUFLLEtBQWdCO0FBQ2xFLFdBQU8sT0FBZSxnQkFBTSxNQUFlO0FBQzNDLFdBQU8sT0FBZSxnQkFBUSxRQUNwQztBQUFDOztBQUVPLGNBQVcsb0JBQUU7QUFDZixXQUFTLFNBQUssS0FBZSxnQkFBTSxNQUFlO0FBQ2xELFdBQVMsU0FBSyxLQUFlLGdCQUFRLFFBQWlCO0FBQ3RELFdBQWdCLGlCQUN0QjtBQUFDOztBQUVELFFBQXlCLHNCQUFFO0FBQ3JCLFdBQUMsSUFBVSxRQUFHLEdBQVEsUUFBTSxLQUFRLFFBQU8sUUFBRSxFQUFPLE9BQUU7QUFDckQsWUFBQyxDQUFLLEtBQVEsUUFBTyxPQUFvQixxQkFBRTtBQUM1QyxpQkFDRjtBQUNGOzs7QUFFQSxhQUNGO0FBQUM7O0FBRWMscUJBQVcsMkJBQUU7QUFDdEIsV0FBVyxXQUFNOzs7QUFHakIsV0FBTSxNQUFVLFlBQUU7QUFDaEIsYUFDTjtBQUFDLFNBQ0g7QUFBQzs7Ozs7OztBQU9XLGtCQUFVLHNCQUFNLE9BQUU7QUFDekIsVUFBQyxDQUFLLEtBQU0sT0FBRTtBQUNYLGFBQVcsV0FDakI7QUFDRjtBQUFDOzs7Ozs7O0FBT1MsZ0JBQVUsb0JBQU0sT0FBRTtBQUN2QixVQUFLLEtBQVUsWUFBTyxLQUFRLFFBQVEsU0FBRyxHQUFFO0FBRTlDOzs7QUFFQSxVQUFXLFNBQU0sS0FBWTs7QUFFdkIsYUFBVyxXQUFPOztBQUVyQixVQUFDLENBQUssS0FBVyxZQUFFO0FBQ2hCLGFBQVksYUFBTTtBQUNsQixhQUNOO0FBQ0Y7QUFBQzs7Ozs7OztBQU9TLGdCQUFVLG9CQUFNLE9BQUU7QUFDdkIsVUFBQyxDQUFLLEtBQU0sT0FBRTtBQUNYLGFBQVMsU0FDZjtBQUNGO0FBQUM7Ozs7Ozs7QUFPTyxjQUFVLGtCQUFNLE9BQUU7QUFDckIsVUFBSyxLQUFTLFVBQUU7QUFFbkI7OztBQUVJLFdBQVEsUUFBUSxRQUFTLFVBQU8sUUFBRTtBQUM5QixlQUFTLFNBQ2pCO0FBQUU7O0FBRUUsV0FBWSxhQUFNO0FBQ2xCLFdBQ047QUFBQzs7QUFFa0IseUJBQVcsK0JBQUU7QUFDMUIsV0FBWSxhQUFPO0FBQ25CLFdBQUUsRUFBVyxXQUFNLE1BQWlCLGtCQUFNO0FBQzFDLFdBQUssS0FDWDtBQUFDOztBQUVRLGVBQVcscUJBQUU7QUFDcEIsVUFBVyxTQUFFLElBQVUsT0FBTTs7QUFFdEIsY0FBSSxJQUFLLEtBQUUsRUFBTyxPQUFZLFlBQU8sT0FBZTtBQUN2RCxXQUFFLEVBQVcsV0FBTSxNQUFpQixrQkFBUSxPQUFNO0FBQ2xELFdBQVEsUUFBSyxLQUFROztBQUVyQixXQUFjLGNBQU07O0FBRXhCLGFBQ0Y7QUFBQzs7QUFFVyxrQkFBVSxzQkFBTyxRQUFFO0FBQzdCLFVBQWdCLGNBQU0sS0FBUSxRQUFRLFFBQVE7O0FBRTNDLFVBQWEsY0FBRyxHQUFFO0FBRXJCOzs7QUFFSSxXQUFRLFFBQU8sT0FBWSxhQUFJOztBQUU3QixhQUFTOztBQUVaLFVBQUMsQ0FBSyxLQUFRLFFBQU8sUUFBRTtBQUNwQixhQUFjLGNBQ3BCO0FBQ0Y7QUFBQzs7Ozs7OztBQU9NLGFBQVcsbUJBQUU7QUFDZixVQUFDLENBQUssS0FBVyxZQUFFO0FBRXRCOztBQUNBLFVBQVM7QUFDVCxVQUFVOztBQUVOLFdBQU8sUUFBRyxHQUFRLFFBQU0sS0FBUSxRQUFPLFFBQUUsRUFBTyxPQUFFO0FBQzdDLGlCQUFNLEtBQVEsUUFBTzs7QUFFdEIsZUFBTzs7QUFFVCxhQUFFLEVBQVcsV0FBTSxNQUFTLFVBQVEsT0FBYTs7QUFFbEQsWUFBTyxPQUF1Qix5QkFBRyxDQUFPLE9BQXFCLHNCQUFFO0FBQzVELGVBQWEsYUFDbkI7QUFDRjs7O0FBRUcsVUFBQyxDQUFLLEtBQXFCLHVCQUFPLEtBQVEsUUFBUSxXQUFLLEdBQUU7QUFDdEQsYUFDTjtBQUFFLGFBQUs7QUFDQyxlQUFzQixzQkFBSyxLQUNuQztBQUNGO0FBQUM7O0FBRWMscUJBQVcsMkJBQUU7QUFDdEIsV0FBZTtBQUNmLFdBQU0sTUFBSyxLQUFXLFlBQzVCO0FBQUM7O0FBRWMscUJBQVcsMkJBQUU7QUFDdEIsV0FDTjtBQUFDOztBQUVZLG1CQUFXLHlCQUFFO0FBQ3BCLFdBQ047QUFBQzs7OztBQUllLHNCQUFVLDBCQUFPLFFBQVEsUUFBRTtBQUN0QyxVQUFRLFdBQWEsV0FBRTtBQUUxQjs7QUFDRyxVQUFPLFFBQUU7QUFDTixhQUNOO0FBQUUsYUFBSztBQUNELGFBQ047QUFDRjs7O0FBV0o7Ozs7Ozs7QUFwVVU7QUFvVU4sSzs7Ozs7Ozs7O0FDMXZCTixtQkFBQUEsQ0FBUSxDQUFSOztBQUVBLG1CQUFBQSxDQUFRLEVBQVI7O0FBRUEsSUFBTW5CLHVCQUF1QixtQkFBQW1CLENBQVEsQ0FBUixDQUE3Qjs7QUFFQW5CLHFCQUFxQm9CLE1BQXJCLENBQTRCLDJxQ0FBNUIsRTs7Ozs7Ozs7O0FDTkEsbUJBQUFELENBQVEsQ0FBUjs7QUFFQSxJQUFNbkIsdUJBQXVCLG1CQUFBbUIsQ0FBUSxDQUFSLENBQTdCOztBQUVBbkIscUJBQXFCb0IsTUFBckIsQ0FBNEIsMm1QQUE1QixFOzs7Ozs7Ozs7QUNKQSxtQkFBQUQsQ0FBUSxFQUFSOztBQUVBLElBQU1uQix1QkFBdUIsbUJBQUFtQixDQUFRLENBQVIsQ0FBN0I7O0FBRUFuQixxQkFBcUJvQixNQUFyQixDQUE0Qiw4ZkFBNUIsRTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDNENTO0FBQ0gsTUFBb0I7O0FBRVo7Ozs7O0FBS0o7QUFDRSxZQUFRO0FBQ0osZ0JBQ1Q7QUFISzs7Ozs7QUFRRjtBQUNFLFlBQVE7QUFDUCxhQUNOO0FBSEs7Ozs7Ozs7Ozs7O0FBY007QUFDTixZQUFTO0FBQ1IsYUFDTjtBQUhhOzs7Ozs7O0FBVU87QUFDZixZQUFTO0FBQ1IsYUFFUjtBQUp3QjtBQXJDYjs7QUEyQ0wsV0FBVyxtQkFBRTtBQUNkLFNBQU8sUUFBRSxJQUFXLFFBQVMsU0FBQyxFQUFLLE1BQVcsV0FBSyxLQUFNLE1BQU8sT0FDdEU7QUFBQzs7QUFFTyxZQUFXLG9CQUFFO0FBQ2YsU0FBTSxNQUFTLFVBQ3JCO0FBQUM7Ozs7Ozs7QUFPVyxnQkFBVyx3QkFBRTtBQUNuQixTQUFRLFNBQU0sS0FBaUI7QUFDbkMsa0JBQWtCLEtBQUssS0FBUSxRQUFJLElBQVMsVUFBRSxHQUFFO0FBQzlDLGFBQVcsS0FBTSxPQUFNLE1BQ3pCO0FBQUMsS0FGWSxFQUdmO0FBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFtQlEsYUFBVSxtQkFBUSxTQUFVLFVBQUU7O0FBRWpDLFNBQVcsV0FBUzs7QUFFeEIsUUFBUSxNQUFNLEtBQVcsV0FBUyxVQUMxQixLQUFjLGdCQUFPLEtBQWEsYUFBVTtBQUNqRCxRQUFJLEtBQUU7O0FBRVAsVUFBUSxNQUFTLFFBQUksSUFBUSxRQUFNLFFBQVc7QUFDM0MsVUFBYSxhQUFJLEtBQUssSUFBVyxXQUFJO0FBQ3hDLGFBQWMsUUFBVSxXQUMxQjs7QUFDQSxXQUNGO0FBQUM7Ozs7Ozs7O0FBUVMsY0FBVSxvQkFBUSxTQUFFOztBQUV6QixRQUFRLFFBQVMsVUFBRTtBQUNiLGNBQUksSUFBUSxRQUFNLFFBQVcsU0FBWSxZQUFRLFFBQVU7QUFDM0QsY0FBVSxXQUNuQjtBQUNGO0FBQUM7Ozs7Ozs7QUFPVyxnQkFBVSxzQkFBTyxRQUFFO0FBQzFCLFFBQUssS0FBZSxpQkFBTyxNQUFFO0FBQzNCLFVBQUssS0FBc0IsdUJBQUU7QUFDOUIsWUFBa0IsZ0JBQ0wsU0FBTSxRQUFXLFNBQUssS0FBYSxhQUN4QyxNQURKLEdBQ2MsU0FDVixPQUFVLFNBQWdCOztBQUU5QixhQUFlLGdCQUFlLGNBQWEsYUFBUSxXQUN6RDtBQUFFLGFBQUs7QUFDRixZQUFRLFVBQVMsT0FBVSxhQUFRLEtBQWEsY0FBRTtBQUM1QyxtQkFBUSxPQUNqQjs7O0FBRUksYUFBZSxnQkFBUyxVQUNsQixPQUFpQixpQkFBUSxRQUFjLGlCQUNuRDtBQUNGOzs7QUFFQSxXQUFXLEtBQ2I7QUFBQzs7Ozs7OztBQU9XLGdCQUFXLHdCQUFFO0FBQ25CLFNBQU0sTUFBTyxRQUFNO0FBQ25CLFNBQU0sTUFBSyxNQUFNLEtBQUs7QUFDdEIsU0FBTSxNQUFPLFFBQU07O0FBRW5CLFNBQU0sTUFBVSxZQUFFO0FBQ2hCLFdBQUssS0FBcUIsc0JBQU0sTUFBRSxFQUFLLE1BQzdDO0FBQ0Y7QUFBQzs7Ozs7OztBQU9hLGtCQUFXLDBCQUFFOzs7O0FBSXpCLFFBQVUsUUFBUSxPQUFPLE9BQU07QUFDeEIsWUFBSSxJQUFNLE1BQWlCLGlCQUNoQyxRQUFRLFFBQVMsVUFBSyxNQUFFO0FBQ2pCLFlBQUssS0FBSyxNQUNqQjtBQUFFO0FBQ0osV0FDRjtBQUFDOzs7Ozs7Ozs7QUFTUyxjQUFVLG9CQUFHLElBQWUsZUFBRTs7O0FBR2xDLFNBQVEsU0FBTSxLQUFRLFVBQU8sS0FBaUI7QUFDbEQsV0FBVyxLQUFpQixpQkFBSyxLQUFPLE9BQUksS0FBTSxLQUFLLE1BQ3pEO0FBQUM7Ozs7Ozs7O0FBUWUsb0JBQVUsMEJBQVUsV0FBTSxNQUFlLGVBQUU7QUFDdEQsUUFBVSxXQUFFO0FBQ2IsVUFBWSxVQUFXLFVBQVUsVUFBTTtVQUMvQixNQUFVLFNBQWdCLGdCQUE2Qiw4QkFBUTtVQUMzRCxVQUFTLFFBQWEsYUFBWSxjQUFVLFNBQU8sT0FBTSxNQUFNO1VBQy9ELFVBQW9FOztBQUU3RSxVQUFlLGlCQUFVLFFBQWEsYUFBaUIsa0JBQUU7QUFDbEQsbUJBQ1Y7OztBQUVHLFVBQWEsYUFBVSxXQUFVO0FBQ2pDLFVBQWEsYUFBc0IsdUJBQWtCO0FBQ3JELFVBQWEsYUFBWSxhQUFVOzs7QUFHbkMsVUFBTSxNQUFTLFVBQVM7QUFDeEIsVUFBWSxZQUFTLFNBQWdCLGdCQUFNO0FBQzlDLGFBQ0Y7O0FBQ0EsV0FDRjtBQUVBOztBQXROTSxHIiwiZmlsZSI6Im1haW4uYnVuZGxlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gaW5zdGFsbCBhIEpTT05QIGNhbGxiYWNrIGZvciBjaHVuayBsb2FkaW5nXG4gXHR2YXIgcGFyZW50SnNvbnBGdW5jdGlvbiA9IHdpbmRvd1tcIndlYnBhY2tKc29ucFwiXTtcbiBcdHdpbmRvd1tcIndlYnBhY2tKc29ucFwiXSA9IGZ1bmN0aW9uIHdlYnBhY2tKc29ucENhbGxiYWNrKGNodW5rSWRzLCBtb3JlTW9kdWxlcywgZXhlY3V0ZU1vZHVsZXMpIHtcbiBcdFx0Ly8gYWRkIFwibW9yZU1vZHVsZXNcIiB0byB0aGUgbW9kdWxlcyBvYmplY3QsXG4gXHRcdC8vIHRoZW4gZmxhZyBhbGwgXCJjaHVua0lkc1wiIGFzIGxvYWRlZCBhbmQgZmlyZSBjYWxsYmFja1xuIFx0XHR2YXIgbW9kdWxlSWQsIGNodW5rSWQsIGkgPSAwLCByZXNvbHZlcyA9IFtdLCByZXN1bHQ7XG4gXHRcdGZvcig7aSA8IGNodW5rSWRzLmxlbmd0aDsgaSsrKSB7XG4gXHRcdFx0Y2h1bmtJZCA9IGNodW5rSWRzW2ldO1xuIFx0XHRcdGlmKGluc3RhbGxlZENodW5rc1tjaHVua0lkXSkge1xuIFx0XHRcdFx0cmVzb2x2ZXMucHVzaChpbnN0YWxsZWRDaHVua3NbY2h1bmtJZF1bMF0pO1xuIFx0XHRcdH1cbiBcdFx0XHRpbnN0YWxsZWRDaHVua3NbY2h1bmtJZF0gPSAwO1xuIFx0XHR9XG4gXHRcdGZvcihtb2R1bGVJZCBpbiBtb3JlTW9kdWxlcykge1xuIFx0XHRcdGlmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb3JlTW9kdWxlcywgbW9kdWxlSWQpKSB7XG4gXHRcdFx0XHRtb2R1bGVzW21vZHVsZUlkXSA9IG1vcmVNb2R1bGVzW21vZHVsZUlkXTtcbiBcdFx0XHR9XG4gXHRcdH1cbiBcdFx0aWYocGFyZW50SnNvbnBGdW5jdGlvbikgcGFyZW50SnNvbnBGdW5jdGlvbihjaHVua0lkcywgbW9yZU1vZHVsZXMsIGV4ZWN1dGVNb2R1bGVzKTtcbiBcdFx0d2hpbGUocmVzb2x2ZXMubGVuZ3RoKSB7XG4gXHRcdFx0cmVzb2x2ZXMuc2hpZnQoKSgpO1xuIFx0XHR9XG5cbiBcdH07XG5cbiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIG9iamVjdHMgdG8gc3RvcmUgbG9hZGVkIGFuZCBsb2FkaW5nIGNodW5rc1xuIFx0dmFyIGluc3RhbGxlZENodW5rcyA9IHtcbiBcdFx0NDogMFxuIFx0fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG4gXHQvLyBUaGlzIGZpbGUgY29udGFpbnMgb25seSB0aGUgZW50cnkgY2h1bmsuXG4gXHQvLyBUaGUgY2h1bmsgbG9hZGluZyBmdW5jdGlvbiBmb3IgYWRkaXRpb25hbCBjaHVua3NcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZSA9IGZ1bmN0aW9uIHJlcXVpcmVFbnN1cmUoY2h1bmtJZCkge1xuIFx0XHR2YXIgaW5zdGFsbGVkQ2h1bmtEYXRhID0gaW5zdGFsbGVkQ2h1bmtzW2NodW5rSWRdO1xuIFx0XHRpZihpbnN0YWxsZWRDaHVua0RhdGEgPT09IDApIHtcbiBcdFx0XHRyZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSkgeyByZXNvbHZlKCk7IH0pO1xuIFx0XHR9XG5cbiBcdFx0Ly8gYSBQcm9taXNlIG1lYW5zIFwiY3VycmVudGx5IGxvYWRpbmdcIi5cbiBcdFx0aWYoaW5zdGFsbGVkQ2h1bmtEYXRhKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZENodW5rRGF0YVsyXTtcbiBcdFx0fVxuXG4gXHRcdC8vIHNldHVwIFByb21pc2UgaW4gY2h1bmsgY2FjaGVcbiBcdFx0dmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiBcdFx0XHRpbnN0YWxsZWRDaHVua0RhdGEgPSBpbnN0YWxsZWRDaHVua3NbY2h1bmtJZF0gPSBbcmVzb2x2ZSwgcmVqZWN0XTtcbiBcdFx0fSk7XG4gXHRcdGluc3RhbGxlZENodW5rRGF0YVsyXSA9IHByb21pc2U7XG5cbiBcdFx0Ly8gc3RhcnQgY2h1bmsgbG9hZGluZ1xuIFx0XHR2YXIgaGVhZCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF07XG4gXHRcdHZhciBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiBcdFx0c2NyaXB0LnR5cGUgPSAndGV4dC9qYXZhc2NyaXB0JztcbiBcdFx0c2NyaXB0LmNoYXJzZXQgPSAndXRmLTgnO1xuIFx0XHRzY3JpcHQuYXN5bmMgPSB0cnVlO1xuIFx0XHRzY3JpcHQudGltZW91dCA9IDEyMDAwMDtcblxuIFx0XHRpZiAoX193ZWJwYWNrX3JlcXVpcmVfXy5uYykge1xuIFx0XHRcdHNjcmlwdC5zZXRBdHRyaWJ1dGUoXCJub25jZVwiLCBfX3dlYnBhY2tfcmVxdWlyZV9fLm5jKTtcbiBcdFx0fVxuIFx0XHRzY3JpcHQuc3JjID0gX193ZWJwYWNrX3JlcXVpcmVfXy5wICsgXCJcIiArIGNodW5rSWQgKyBcIi5idW5kbGUuanNcIjtcbiBcdFx0dmFyIHRpbWVvdXQgPSBzZXRUaW1lb3V0KG9uU2NyaXB0Q29tcGxldGUsIDEyMDAwMCk7XG4gXHRcdHNjcmlwdC5vbmVycm9yID0gc2NyaXB0Lm9ubG9hZCA9IG9uU2NyaXB0Q29tcGxldGU7XG4gXHRcdGZ1bmN0aW9uIG9uU2NyaXB0Q29tcGxldGUoKSB7XG4gXHRcdFx0Ly8gYXZvaWQgbWVtIGxlYWtzIGluIElFLlxuIFx0XHRcdHNjcmlwdC5vbmVycm9yID0gc2NyaXB0Lm9ubG9hZCA9IG51bGw7XG4gXHRcdFx0Y2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuIFx0XHRcdHZhciBjaHVuayA9IGluc3RhbGxlZENodW5rc1tjaHVua0lkXTtcbiBcdFx0XHRpZihjaHVuayAhPT0gMCkge1xuIFx0XHRcdFx0aWYoY2h1bmspIHtcbiBcdFx0XHRcdFx0Y2h1bmtbMV0obmV3IEVycm9yKCdMb2FkaW5nIGNodW5rICcgKyBjaHVua0lkICsgJyBmYWlsZWQuJykpO1xuIFx0XHRcdFx0fVxuIFx0XHRcdFx0aW5zdGFsbGVkQ2h1bmtzW2NodW5rSWRdID0gdW5kZWZpbmVkO1xuIFx0XHRcdH1cbiBcdFx0fTtcbiBcdFx0aGVhZC5hcHBlbmRDaGlsZChzY3JpcHQpO1xuXG4gXHRcdHJldHVybiBwcm9taXNlO1xuIFx0fTtcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbiBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbiBcdFx0XHR9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJkaXN0L1wiO1xuXG4gXHQvLyBvbiBlcnJvciBmdW5jdGlvbiBmb3IgYXN5bmMgbG9hZGluZ1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vZSA9IGZ1bmN0aW9uKGVycikgeyBjb25zb2xlLmVycm9yKGVycik7IHRocm93IGVycjsgfTtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAzMCk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay9ib290c3RyYXAgZTUwOTNkNWQxZDc1MDZkNTQ5ODQiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwibGliL2xlZ2FjeS9sZWdhY3ktZWxlbWVudC1taXhpbi5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwibGliL2xlZ2FjeS9wb2x5bWVyLWZuLmh0bWxcIj5cbjwhLS0gdGVtcGxhdGUgZWxlbWVudHMgLS0+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwibGliL2xlZ2FjeS90ZW1wbGF0aXplci1iZWhhdmlvci5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwibGliL2VsZW1lbnRzL2RvbS1iaW5kLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCJsaWIvZWxlbWVudHMvZG9tLXJlcGVhdC5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwibGliL2VsZW1lbnRzL2RvbS1pZi5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwibGliL2VsZW1lbnRzL2FycmF5LXNlbGVjdG9yLmh0bWxcIj5cbjwhLS0gY3VzdG9tLXN0eWxlIC0tPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cImxpYi9lbGVtZW50cy9jdXN0b20tc3R5bGUuaHRtbFwiPlxuPCEtLSBiYyBiZWhhdmlvcnMgLS0+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwibGliL2xlZ2FjeS9tdXRhYmxlLWRhdGEtYmVoYXZpb3IuaHRtbFwiPlxuPHNjcmlwdD5cbiAgLy8gYmNcbiAgUG9seW1lci5CYXNlID0gUG9seW1lci5MZWdhY3lFbGVtZW50TWl4aW4oSFRNTEVsZW1lbnQpLnByb3RvdHlwZTtcbjwvc2NyaXB0PlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL3BvbHltZXIuaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cbjxzY3JpcHQ+XG4oZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBjb25zdCB1c2VyUG9seW1lciA9IHdpbmRvdy5Qb2x5bWVyO1xuXG4gIC8qKlxuICAgKiBAbmFtZXNwYWNlIFBvbHltZXJcbiAgICogQHN1bW1hcnkgUG9seW1lciBpcyBhIGxpZ2h0d2VpZ2h0IGxpYnJhcnkgYnVpbHQgb24gdG9wIG9mIHRoZSB3ZWJcbiAgICogICBzdGFuZGFyZHMtYmFzZWQgV2ViIENvbXBvbmVudHMgQVBJJ3MsIGFuZCBtYWtlcyBpdCBlYXN5IHRvIGJ1aWxkIHlvdXJcbiAgICogICBvd24gY3VzdG9tIEhUTUwgZWxlbWVudHMuXG4gICAqIEBwYXJhbSB7IVBvbHltZXJJbml0fSBpbmZvIFByb3RvdHlwZSBmb3IgdGhlIGN1c3RvbSBlbGVtZW50LiBJdCBtdXN0IGNvbnRhaW5cbiAgICogICBhbiBgaXNgIHByb3BlcnR5IHRvIHNwZWNpZnkgdGhlIGVsZW1lbnQgbmFtZS4gT3RoZXIgcHJvcGVydGllcyBwb3B1bGF0ZVxuICAgKiAgIHRoZSBlbGVtZW50IHByb3RvdHlwZS4gVGhlIGBwcm9wZXJ0aWVzYCwgYG9ic2VydmVyc2AsIGBob3N0QXR0cmlidXRlc2AsXG4gICAqICAgYW5kIGBsaXN0ZW5lcnNgIHByb3BlcnRpZXMgYXJlIHByb2Nlc3NlZCB0byBjcmVhdGUgZWxlbWVudCBmZWF0dXJlcy5cbiAgICogQHJldHVybiB7IU9iamVjdH0gUmV0dXJucyBhIGN1c3RvbSBlbGVtZW50IGNsYXNzIGZvciB0aGUgZ2l2ZW4gcHJvdmlkZWRcbiAgICogICBwcm90b3R5cGUgYGluZm9gIG9iamVjdC4gVGhlIG5hbWUgb2YgdGhlIGVsZW1lbnQgaWYgZ2l2ZW4gYnkgYGluZm8uaXNgLlxuICAgKi9cbiAgd2luZG93LlBvbHltZXIgPSBmdW5jdGlvbihpbmZvKSB7XG4gICAgcmV0dXJuIHdpbmRvdy5Qb2x5bWVyLl9wb2x5bWVyRm4oaW5mbyk7XG4gIH1cblxuICAvLyBzdXBwb3J0IHVzZXIgc2V0dGluZ3Mgb24gdGhlIFBvbHltZXIgb2JqZWN0XG4gIGlmICh1c2VyUG9seW1lcikge1xuICAgIE9iamVjdC5hc3NpZ24oUG9seW1lciwgdXNlclBvbHltZXIpO1xuICB9XG5cbiAgLy8gVG8gYmUgcGx1Z2dlZCBieSBsZWdhY3kgaW1wbGVtZW50YXRpb24gaWYgbG9hZGVkXG4gIC8qIGVzbGludC1kaXNhYmxlIHZhbGlkLWpzZG9jICovXG4gIC8qKlxuICAgKiBAcGFyYW0geyFQb2x5bWVySW5pdH0gaW5mbyBQcm90b3R5cGUgZm9yIHRoZSBjdXN0b20gZWxlbWVudC4gSXQgbXVzdCBjb250YWluXG4gICAqICAgYW4gYGlzYCBwcm9wZXJ0eSB0byBzcGVjaWZ5IHRoZSBlbGVtZW50IG5hbWUuIE90aGVyIHByb3BlcnRpZXMgcG9wdWxhdGVcbiAgICogICB0aGUgZWxlbWVudCBwcm90b3R5cGUuIFRoZSBgcHJvcGVydGllc2AsIGBvYnNlcnZlcnNgLCBgaG9zdEF0dHJpYnV0ZXNgLFxuICAgKiAgIGFuZCBgbGlzdGVuZXJzYCBwcm9wZXJ0aWVzIGFyZSBwcm9jZXNzZWQgdG8gY3JlYXRlIGVsZW1lbnQgZmVhdHVyZXMuXG4gICAqIEByZXR1cm4geyFPYmplY3R9IFJldHVybnMgYSBjdXN0b20gZWxlbWVudCBjbGFzcyBmb3IgdGhlIGdpdmVuIHByb3ZpZGVkXG4gICAqICAgcHJvdG90eXBlIGBpbmZvYCBvYmplY3QuIFRoZSBuYW1lIG9mIHRoZSBlbGVtZW50IGlmIGdpdmVuIGJ5IGBpbmZvLmlzYC5cbiAgICovXG4gIHdpbmRvdy5Qb2x5bWVyLl9wb2x5bWVyRm4gPSBmdW5jdGlvbihpbmZvKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0xvYWQgcG9seW1lci5odG1sIHRvIHVzZSB0aGUgUG9seW1lcigpIGZ1bmN0aW9uLicpO1xuICB9XG4gIC8qIGVzbGludC1lbmFibGUgKi9cblxuICB3aW5kb3cuUG9seW1lci52ZXJzaW9uID0gJzIuMC4xJztcblxuICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuICAvKlxuICBXaGVuIHVzaW5nIENsb3N1cmUgQ29tcGlsZXIsIEpTQ29tcGlsZXJfcmVuYW1lUHJvcGVydHkocHJvcGVydHksIG9iamVjdCkgaXMgcmVwbGFjZWQgYnkgdGhlIG11bmdlZCBuYW1lIGZvciBvYmplY3RbcHJvcGVydHldXG4gIFdlIGNhbm5vdCBhbGlhcyB0aGlzIGZ1bmN0aW9uLCBzbyB3ZSBoYXZlIHRvIHVzZSBhIHNtYWxsIHNoaW0gdGhhdCBoYXMgdGhlIHNhbWUgYmVoYXZpb3Igd2hlbiBub3QgY29tcGlsaW5nLlxuICAqL1xuICB3aW5kb3cuSlNDb21waWxlcl9yZW5hbWVQcm9wZXJ0eSA9IGZ1bmN0aW9uKHByb3AsIG9iaikge1xuICAgIHJldHVybiBwcm9wO1xuICB9XG4gIC8qIGVzbGludC1lbmFibGUgKi9cblxufSkoKTtcbjwvc2NyaXB0PlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi91dGlscy9ib290Lmh0bWwiLCIvKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cblxuY2xhc3MgUmVnaXN0ZXJIdG1sVGVtcGxhdGUge1xuICAvKipcbiAgICogQ3JlYXRlIGEgYDx0ZW1wbGF0ZT5gIGVsZW1lbnQgdG8gaG9sZCBgPGRvbS1tb2R1bGU+YCBjb250ZW50LlxuICAgKiBUaGlzIGJpdCBvZiBjb2RlIHdpbGwgZXhlY3V0ZSBpbiB0aGUgY29udGV4dCBvZiB0aGUgbWFpbiBkb2N1bWVudCxcbiAgICogY2FsbGluZyBgaW1wb3J0Tm9kZWAgb24gdGhlIGA8dGVtcGxhdGU+YCwgd2hpY2ggaW4gdHVybiB0cmlnZ2Vyc1xuICAgKiB0aGUgbGlmZWN5Y2xlIG9mIHRoZSBgPGRvbS1tb2R1bGU+YCBhbmQgYWxsb3dzIGl0IHRvIGluc2VydCBpdHNcbiAgICogY29udGVudCBpbnRvIFBvbHltZXIncyBnbG9iYWwgbW9kdWxlIG1hcC4gV2hlbiBhIFBvbHltZXIgZWxlbWVudFxuICAgKiBib290cyB1cCBpdCB3aWxsIGZldGNoIGl0cyB0ZW1wbGF0ZSBmcm9tIHRoaXMgbW9kdWxlIG1hcC5cbiAgICogaHR0cHM6Ly9naXRodWIuY29tL1BvbHltZXIvcG9seW1lci9ibG9iL21hc3Rlci9saWIvbWl4aW5zL2VsZW1lbnQtbWl4aW4uaHRtbCNMNTAxLUw1MzhcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbCBBIGA8ZG9tLW1vZHVsZT5gIGFzIGFuIEhUTUwgc3RyaW5nXG4gICAqL1xuICBzdGF0aWMgcmVnaXN0ZXIodmFsKSB7XG4gICAgbGV0IGNvbnRlbnQ7XG4gICAgY29uc3QgdGVtcGxhdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScpO1xuICAgIHRlbXBsYXRlLmlubmVySFRNTCA9IHZhbDtcbiAgICBpZiAodGVtcGxhdGUuY29udGVudCkge1xuICAgICAgY29udGVudCA9IHRlbXBsYXRlLmNvbnRlbnQ7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcHJlZmVyLWRlc3RydWN0dXJpbmdcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICAgIHdoaWxlICh0ZW1wbGF0ZS5maXJzdENoaWxkKSB7XG4gICAgICAgIGNvbnRlbnQuYXBwZW5kQ2hpbGQodGVtcGxhdGUuZmlyc3RDaGlsZCk7XG4gICAgICB9XG4gICAgfVxuICAgIGRvY3VtZW50LmltcG9ydE5vZGUoY29udGVudCwgdHJ1ZSk7XG4gIH1cbiAgLyoqXG4gICAqIENvbnRlbnQgdGhhdCB3aWxsIGJlIGluamVjdGVkIGludG8gdGhlIG1haW4gZG9jdW1lbnQuIFRoaXMgaXMgcHJpbWFyaWx5XG4gICAqIGZvciB0aGluZ3MgbGlrZSBgPGlyb24taWNvbnNldD5gIGFuZCBgPGN1c3RvbS1zdHlsZT5gIHdoaWNoIGRvIG5vdCBoYXZlXG4gICAqIHRlbXBsYXRlcyBidXQgcmVseSBvbiBIVE1MIEltcG9ydHMgYWJpbGl0eSB0byBhcHBseSBjb250ZW50IHRvIHRoZSBtYWluXG4gICAqIGRvY3VtZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsIEFuIEhUTUwgc3RyaW5nXG4gICAqL1xuICBzdGF0aWMgdG9Cb2R5KHZhbCkge1xuICAgIGNvbnN0IHRyaW1tZWRWYWwgPSB2YWwudHJpbSgpO1xuICAgIGlmICh0cmltbWVkVmFsKSB7XG4gICAgICBjb25zdCBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGRpdi5pbm5lckhUTUwgPSB0cmltbWVkVmFsO1xuICAgICAgaWYgKGRpdi5maXJzdENoaWxkKSB7XG4gICAgICAgIGlmIChkb2N1bWVudC5ib2R5KSB7XG4gICAgICAgICAgZG9jdW1lbnQuYm9keS5pbnNlcnRCZWZvcmUoZGl2LmZpcnN0Q2hpbGQsIGRvY3VtZW50LmJvZHkuZmlyc3RDaGlsZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsICgpID0+IHtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuaW5zZXJ0QmVmb3JlKGRpdi5maXJzdENoaWxkLCBkb2N1bWVudC5ib2R5LmZpcnN0Q2hpbGQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVnaXN0ZXJIdG1sVGVtcGxhdGU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcG9seW1lci13ZWJwYWNrLWxvYWRlci9yZWdpc3Rlci1odG1sLXRlbXBsYXRlLmpzIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuXG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiYm9vdC5odG1sXCI+XG5cbjxzY3JpcHQ+XG5cbihmdW5jdGlvbigpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgLy8gdW5pcXVlIGdsb2JhbCBpZCBmb3IgZGVkdXBpbmcgbWl4aW5zLlxuICBsZXQgZGVkdXBlSWQgPSAwO1xuXG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQGV4dGVuZHMge0Z1bmN0aW9ufVxuICAgKi9cbiAgZnVuY3Rpb24gTWl4aW5GdW5jdGlvbigpe31cbiAgLyoqIEB0eXBlIHsoV2Vha01hcCB8IHVuZGVmaW5lZCl9ICovXG4gIE1peGluRnVuY3Rpb24ucHJvdG90eXBlLl9fbWl4aW5BcHBsaWNhdGlvbnM7XG4gIC8qKiBAdHlwZSB7KE9iamVjdCB8IHVuZGVmaW5lZCl9ICovXG4gIE1peGluRnVuY3Rpb24ucHJvdG90eXBlLl9fbWl4aW5TZXQ7XG5cbiAgLyogZXNsaW50LWRpc2FibGUgdmFsaWQtanNkb2MgKi9cbiAgLyoqXG4gICAqIFdyYXBzIGFuIEVTNiBjbGFzcyBleHByZXNzaW9uIG1peGluIHN1Y2ggdGhhdCB0aGUgbWl4aW4gaXMgb25seSBhcHBsaWVkXG4gICAqIGlmIGl0IGhhcyBub3QgYWxyZWFkeSBiZWVuIGFwcGxpZWQgaXRzIGJhc2UgYXJndW1lbnQuICBBbHNvIG1lbW9pemVzIG1peGluXG4gICAqIGFwcGxpY2F0aW9ucy5cbiAgICpcbiAgICogQG1lbWJlcm9mIFBvbHltZXJcbiAgICogQHRlbXBsYXRlIFRcbiAgICogQHBhcmFtIHtUfSBtaXhpbiBFUzYgY2xhc3MgZXhwcmVzc2lvbiBtaXhpbiB0byB3cmFwXG4gICAqIEBzdXBwcmVzcyB7aW52YWxpZENhc3RzfVxuICAgKi9cbiAgUG9seW1lci5kZWR1cGluZ01peGluID0gZnVuY3Rpb24obWl4aW4pIHtcbiAgICBsZXQgbWl4aW5BcHBsaWNhdGlvbnMgPSAvKiogQHR5cGUgeyFNaXhpbkZ1bmN0aW9ufSAqLyhtaXhpbikuX19taXhpbkFwcGxpY2F0aW9ucztcbiAgICBpZiAoIW1peGluQXBwbGljYXRpb25zKSB7XG4gICAgICBtaXhpbkFwcGxpY2F0aW9ucyA9IG5ldyBXZWFrTWFwKCk7XG4gICAgICAvKiogQHR5cGUgeyFNaXhpbkZ1bmN0aW9ufSAqLyhtaXhpbikuX19taXhpbkFwcGxpY2F0aW9ucyA9IG1peGluQXBwbGljYXRpb25zO1xuICAgIH1cbiAgICAvLyBtYWludGFpbiBhIHVuaXF1ZSBpZCBmb3IgZWFjaCBtaXhpblxuICAgIGxldCBtaXhpbkRlZHVwZUlkID0gZGVkdXBlSWQrKztcbiAgICBmdW5jdGlvbiBkZWR1cGluZ01peGluKGJhc2UpIHtcbiAgICAgIGxldCBiYXNlU2V0ID0gLyoqIEB0eXBlIHshTWl4aW5GdW5jdGlvbn0gKi8oYmFzZSkuX19taXhpblNldDtcbiAgICAgIGlmIChiYXNlU2V0ICYmIGJhc2VTZXRbbWl4aW5EZWR1cGVJZF0pIHtcbiAgICAgICAgcmV0dXJuIGJhc2U7XG4gICAgICB9XG4gICAgICBsZXQgbWFwID0gbWl4aW5BcHBsaWNhdGlvbnM7XG4gICAgICBsZXQgZXh0ZW5kZWQgPSBtYXAuZ2V0KGJhc2UpO1xuICAgICAgaWYgKCFleHRlbmRlZCkge1xuICAgICAgICBleHRlbmRlZCA9IC8qKiBAdHlwZSB7IUZ1bmN0aW9ufSAqLyhtaXhpbikoYmFzZSk7XG4gICAgICAgIG1hcC5zZXQoYmFzZSwgZXh0ZW5kZWQpO1xuICAgICAgfVxuICAgICAgLy8gY29weSBpbmhlcml0ZWQgbWl4aW4gc2V0IGZyb20gdGhlIGV4dGVuZGVkIGNsYXNzLCBvciB0aGUgYmFzZSBjbGFzc1xuICAgICAgLy8gTk9URTogd2UgYXZvaWQgdXNlIG9mIFNldCBoZXJlIGJlY2F1c2Ugc29tZSBicm93c2VyIChJRTExKVxuICAgICAgLy8gY2Fubm90IGV4dGVuZCBhIGJhc2UgU2V0IHZpYSB0aGUgY29uc3RydWN0b3IuXG4gICAgICBsZXQgbWl4aW5TZXQgPSBPYmplY3QuY3JlYXRlKC8qKiBAdHlwZSB7IU1peGluRnVuY3Rpb259ICovKGV4dGVuZGVkKS5fX21peGluU2V0IHx8IGJhc2VTZXQgfHwgbnVsbCk7XG4gICAgICBtaXhpblNldFttaXhpbkRlZHVwZUlkXSA9IHRydWU7XG4gICAgICAvKiogQHR5cGUgeyFNaXhpbkZ1bmN0aW9ufSAqLyhleHRlbmRlZCkuX19taXhpblNldCA9IG1peGluU2V0O1xuICAgICAgcmV0dXJuIGV4dGVuZGVkO1xuICAgIH1cblxuICAgIHJldHVybiBkZWR1cGluZ01peGluO1xuICB9O1xuICAvKiBlc2xpbnQtZW5hYmxlIHZhbGlkLWpzZG9jICovXG5cbn0pKCk7XG5cbjwvc2NyaXB0PlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi91dGlscy9taXhpbi5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNiBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuXG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vLi4vcG9seW1lci9wb2x5bWVyLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi8uLi9pcm9uLXNjcm9sbC10YXJnZXQtYmVoYXZpb3IvaXJvbi1zY3JvbGwtdGFyZ2V0LWJlaGF2aW9yLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi9oZWxwZXJzL2hlbHBlcnMuaHRtbFwiPlxuXG48c2NyaXB0PlxuICAvKipcbiAgICogYFBvbHltZXIuQXBwU2Nyb2xsRWZmZWN0c0JlaGF2aW9yYCBwcm92aWRlcyBhbiBpbnRlcmZhY2UgdGhhdCBhbGxvd3MgYW4gZWxlbWVudCB0byB1c2Ugc2Nyb2xscyBlZmZlY3RzLlxuICAgKlxuICAgKiAjIyMgSW1wb3J0aW5nIHRoZSBhcHAtbGF5b3V0IGVmZmVjdHNcbiAgICpcbiAgICogYXBwLWxheW91dCBwcm92aWRlcyBhIHNldCBvZiBzY3JvbGwgZWZmZWN0cyB0aGF0IGNhbiBiZSB1c2VkIGJ5IGV4cGxpY2l0bHkgaW1wb3J0aW5nXG4gICAqIGBhcHAtc2Nyb2xsLWVmZmVjdHMuaHRtbGA6XG4gICAqXG4gICAqIGBgYGh0bWxcbiAgICogPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi9ib3dlcl9jb21wb25lbnRzL2FwcC1sYXlvdXQvYXBwLXNjcm9sbC1lZmZlY3RzL2FwcC1zY3JvbGwtZWZmZWN0cy5odG1sXCI+XG4gICAqIGBgYFxuICAgKlxuICAgKiBUaGUgc2Nyb2xsIGVmZmVjdHMgY2FuIGFsc28gYmUgdXNlZCBieSBpbmRpdmlkdWFsbHkgaW1wb3J0aW5nXG4gICAqIGBhcHAtbGF5b3V0L2FwcC1zY3JvbGwtZWZmZWN0cy9lZmZlY3RzL1tlZmZlY3ROYW1lXS5odG1sYC4gRm9yIGV4YW1wbGU6XG4gICAqXG4gICAqIGBgYGh0bWxcbiAgICogIDxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIvYm93ZXJfY29tcG9uZW50cy9hcHAtbGF5b3V0L2FwcC1zY3JvbGwtZWZmZWN0cy9lZmZlY3RzL3dhdGVyZmFsbC5odG1sXCI+XG4gICAqIGBgYFxuICAgKlxuICAgKiAjIyMgQ29uc3VtaW5nIGVmZmVjdHNcbiAgICpcbiAgICogRWZmZWN0cyBjYW4gYmUgY29uc3VtZWQgdmlhIHRoZSBgZWZmZWN0c2AgcHJvcGVydHkuIEZvciBleGFtcGxlOlxuICAgKlxuICAgKiBgYGBodG1sXG4gICAqIDxhcHAtaGVhZGVyIGVmZmVjdHM9XCJ3YXRlcmZhbGxcIj48L2FwcC1oZWFkZXI+XG4gICAqIGBgYFxuICAgKlxuICAgKiAjIyMgQ3JlYXRpbmcgc2Nyb2xsIGVmZmVjdHNcbiAgICpcbiAgICogWW91IG1heSB3YW50IHRvIGNyZWF0ZSBhIGN1c3RvbSBzY3JvbGwgZWZmZWN0IGlmIHlvdSBuZWVkIHRvIG1vZGlmeSB0aGUgQ1NTIG9mIGFuIGVsZW1lbnRcbiAgICogYmFzZWQgb24gdGhlIHNjcm9sbCBwb3NpdGlvbi5cbiAgICpcbiAgICogQSBzY3JvbGwgZWZmZWN0IGRlZmluaXRpb24gaXMgYW4gb2JqZWN0IHdpdGggYHNldFVwKClgLCBgdGVhckRvd24oKWAgYW5kIGBydW4oKWAgZnVuY3Rpb25zLlxuICAgKlxuICAgKiBUbyByZWdpc3RlciB0aGUgZWZmZWN0LCB5b3UgY2FuIHVzZSBgUG9seW1lci5BcHBMYXlvdXQucmVnaXN0ZXJFZmZlY3QoZWZmZWN0TmFtZSwgZWZmZWN0RGVmKWBcbiAgICogRm9yIGV4YW1wbGUsIGxldCdzIGRlZmluZSBhbiBlZmZlY3QgdGhhdCByZXNpemVzIHRoZSBoZWFkZXIncyBsb2dvOlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiBQb2x5bWVyLkFwcExheW91dC5yZWdpc3RlckVmZmVjdCgncmVzaXphYmxlLWxvZ28nLCB7XG4gICAqICAgc2V0VXA6IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgKiAgICAgLy8gdGhlIGVmZmVjdCdzIGNvbmZpZyBpcyBwYXNzZWQgdG8gdGhlIHNldFVwLlxuICAgKiAgICAgdGhpcy5fZnhSZXNpemVMb2dvID0geyBsb2dvOiBQb2x5bWVyLmRvbSh0aGlzKS5xdWVyeVNlbGVjdG9yKCdbbG9nb10nKSB9O1xuICAgKiAgIH0sXG4gICAqXG4gICAqICAgcnVuOiBmdW5jdGlvbihwcm9ncmVzcykge1xuICAgKiAgICAgIC8vIHRoZSBwcm9ncmVzcyBvZiB0aGUgZWZmZWN0XG4gICAqICAgICAgdGhpcy50cmFuc2Zvcm0oJ3NjYWxlM2QoJyArIHByb2dyZXNzICsgJywgJysgcHJvZ3Jlc3MgKycsIDEpJywgIHRoaXMuX2Z4UmVzaXplTG9nby5sb2dvKTtcbiAgICogICB9LFxuICAgKlxuICAgKiAgIHRlYXJEb3duOiBmdW5jdGlvbigpIHtcbiAgICogICAgICAvLyBjbGVhbiB1cCBhbmQgcmVzZXQgb2Ygc3RhdGVzXG4gICAqICAgICAgZGVsZXRlIHRoaXMuX2Z4UmVzaXplTG9nbztcbiAgICogICB9XG4gICAqIH0pO1xuICAgKiBgYGBcbiAgICogTm93LCB5b3UgY2FuIGNvbnN1bWUgdGhlIGVmZmVjdDpcbiAgICpcbiAgICogYGBgaHRtbFxuICAgKiA8YXBwLWhlYWRlciBpZD1cImFwcEhlYWRlclwiIGVmZmVjdHM9XCJyZXNpemFibGUtbG9nb1wiPlxuICAgKiAgIDxpbWcgbG9nbyBzcmM9XCJsb2dvLnN2Z1wiPlxuICAgKiA8L2FwcC1oZWFkZXI+XG4gICAqIGBgYFxuICAgKlxuICAgKiAjIyMgSW1wZXJhdGl2ZSBBUElcbiAgICpcbiAgICogYGBganNcbiAgICogdmFyIGxvZ29FZmZlY3QgPSBhcHBIZWFkZXIuY3JlYXRlRWZmZWN0KCdyZXNpemFibGUtbG9nbycsIGVmZmVjdENvbmZpZyk7XG4gICAqIC8vIHJ1biB0aGUgZWZmZWN0OiBsb2dvRWZmZWN0LnJ1bihwcm9ncmVzcyk7XG4gICAqIC8vIHRlYXIgZG93biB0aGUgZWZmZWN0OiBsb2dvRWZmZWN0LnRlYXJEb3duKCk7XG4gICAqIGBgYFxuICAgKlxuICAgKiAjIyMgQ29uZmlndXJpbmcgZWZmZWN0c1xuICAgKlxuICAgKiBGb3IgZWZmZWN0cyBpbnN0YWxsZWQgdmlhIHRoZSBgZWZmZWN0c2AgcHJvcGVydHksIHRoZWlyIGNvbmZpZ3VyYXRpb24gY2FuIGJlIHNldFxuICAgKiB2aWEgdGhlIGBlZmZlY3RzQ29uZmlnYCBwcm9wZXJ0eS4gRm9yIGV4YW1wbGU6XG4gICAqXG4gICAqIGBgYGh0bWxcbiAgICogPGFwcC1oZWFkZXIgZWZmZWN0cz1cIndhdGVyZmFsbFwiXG4gICAqICAgZWZmZWN0cy1jb25maWc9J3tcIndhdGVyZmFsbFwiOiB7XCJzdGFydHNBdFwiOiAwLCBcImVuZHNBdFwiOiAwLjV9fSc+XG4gICAqIDwvYXBwLWhlYWRlcj5cbiAgICogYGBgXG4gICAqXG4gICAqIEFsbCBlZmZlY3RzIGhhdmUgYSBgc3RhcnRzQXRgIGFuZCBgZW5kc0F0YCBjb25maWcgcHJvcGVydHkuIFRoZXkgc3BlY2lmeSBhdCB3aGF0XG4gICAqIHBvaW50IHRoZSBlZmZlY3Qgc2hvdWxkIHN0YXJ0IGFuZCBlbmQuIFRoaXMgdmFsdWUgZ29lcyBmcm9tIDAgdG8gMSBpbmNsdXNpdmUuXG4gICAqXG4gICAqIEBwb2x5bWVyQmVoYXZpb3JcbiAgICovXG4gIFBvbHltZXIuQXBwU2Nyb2xsRWZmZWN0c0JlaGF2aW9yID0gW1xuICAgIFBvbHltZXIuSXJvblNjcm9sbFRhcmdldEJlaGF2aW9yLFxuICAge1xuXG4gICAgcHJvcGVydGllczoge1xuXG4gICAgICAvKipcbiAgICAgICAqIEEgc3BhY2Utc2VwYXJhdGVkIGxpc3Qgb2YgdGhlIGVmZmVjdHMgbmFtZXMgdGhhdCB3aWxsIGJlIHRyaWdnZXJlZCB3aGVuIHRoZSB1c2VyIHNjcm9sbHMuXG4gICAgICAgKiBlLmcuIGB3YXRlcmZhbGwgcGFyYWxsYXgtYmFja2dyb3VuZGAgaW5zdGFsbHMgdGhlIGB3YXRlcmZhbGxgIGFuZCBgcGFyYWxsYXgtYmFja2dyb3VuZGAuXG4gICAgICAgKi9cbiAgICAgIGVmZmVjdHM6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nXG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIEFuIG9iamVjdCB0aGF0IGNvbmZpZ3VyYXRlcyB0aGUgZWZmZWN0cyBpbnN0YWxsZWQgdmlhIHRoZSBgZWZmZWN0c2AgcHJvcGVydHkuIGUuZy5cbiAgICAgICAqIGBgYGpzXG4gICAgICAgKiAgZWxlbWVudC5lZmZlY3RzQ29uZmlnID0ge1xuICAgICAgICogICBcImJsZW5kLWJhY2tncm91bmRcIjoge1xuICAgICAgICogICAgIFwic3RhcnRzQXRcIjogMC41XG4gICAgICAgKiAgIH1cbiAgICAgICAqIH07XG4gICAgICAgKiBgYGBcbiAgICAgICAqIEV2ZXJ5IGVmZmVjdCBoYXMgYXQgbGVhc3QgdHdvIGNvbmZpZyBwcm9wZXJ0aWVzOiBgc3RhcnRzQXRgIGFuZCBgZW5kc0F0YC5cbiAgICAgICAqIFRoZXNlIHByb3BlcnRpZXMgaW5kaWNhdGUgd2hlbiB0aGUgZXZlbnQgc2hvdWxkIHN0YXJ0IGFuZCBlbmQgcmVzcGVjdGl2ZWx5XG4gICAgICAgKiBhbmQgcmVsYXRpdmUgdG8gdGhlIG92ZXJhbGwgZWxlbWVudCBwcm9ncmVzcy4gU28gZm9yIGV4YW1wbGUsIGlmIGBibGVuZC1iYWNrZ3JvdW5kYFxuICAgICAgICogc3RhcnRzIGF0IGAwLjVgLCB0aGUgZWZmZWN0IHdpbGwgb25seSBzdGFydCBvbmNlIHRoZSBjdXJyZW50IGVsZW1lbnQgcmVhY2hlcyAwLjVcbiAgICAgICAqIG9mIGl0cyBwcm9ncmVzcy4gSW4gdGhpcyBjb250ZXh0LCB0aGUgcHJvZ3Jlc3MgaXMgYSB2YWx1ZSBpbiB0aGUgcmFuZ2Ugb2YgYFswLCAxXWBcbiAgICAgICAqIHRoYXQgaW5kaWNhdGVzIHdoZXJlIHRoaXMgZWxlbWVudCBpcyBvbiB0aGUgc2NyZWVuIHJlbGF0aXZlIHRvIHRoZSB2aWV3cG9ydC5cbiAgICAgICAqL1xuICAgICAgZWZmZWN0c0NvbmZpZzoge1xuICAgICAgICB0eXBlOiBPYmplY3QsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogRGlzYWJsZXMgQ1NTIHRyYW5zaXRpb25zIGFuZCBzY3JvbGwgZWZmZWN0cyBvbiB0aGUgZWxlbWVudC5cbiAgICAgICAqL1xuICAgICAgZGlzYWJsZWQ6IHtcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgcmVmbGVjdFRvQXR0cmlidXRlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogQWxsb3dzIHRvIHNldCBhIGBzY3JvbGxUb3BgIHRocmVzaG9sZC4gV2hlbiBncmVhdGVyIHRoYW4gMCwgYHRocmVzaG9sZFRyaWdnZXJlZGBcbiAgICAgICAqIGlzIHRydWUgb25seSB3aGVuIHRoZSBzY3JvbGwgdGFyZ2V0J3MgYHNjcm9sbFRvcGAgaGFzIHJlYWNoZWQgdGhpcyB2YWx1ZS5cbiAgICAgICAqXG4gICAgICAgKiBGb3IgZXhhbXBsZSwgaWYgYHRocmVzaG9sZCA9IDEwMGAsIGB0aHJlc2hvbGRUcmlnZ2VyZWRgIGlzIHRydWUgd2hlbiB0aGUgYHNjcm9sbFRvcGBcbiAgICAgICAqIGlzIGF0IGxlYXN0IGAxMDBgLlxuICAgICAgICovXG4gICAgICB0aHJlc2hvbGQ6IHtcbiAgICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgICB2YWx1ZTogMFxuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBUcnVlIGlmIHRoZSBgc2Nyb2xsVG9wYCB0aHJlc2hvbGQgKHNldCBpbiBgc2Nyb2xsVG9wVGhyZXNob2xkYCkgaGFzXG4gICAgICAgKiBiZWVuIHJlYWNoZWQuXG4gICAgICAgKi9cbiAgICAgIHRocmVzaG9sZFRyaWdnZXJlZDoge1xuICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICBub3RpZnk6IHRydWUsXG4gICAgICAgIHJlYWRPbmx5OiB0cnVlLFxuICAgICAgICByZWZsZWN0VG9BdHRyaWJ1dGU6IHRydWVcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgb2JzZXJ2ZXJzOiBbXG4gICAgICAnX2VmZmVjdHNDaGFuZ2VkKGVmZmVjdHMsIGVmZmVjdHNDb25maWcsIGlzQXR0YWNoZWQpJ1xuICAgIF0sXG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBzY3JvbGwgc3RhdGUuIFRoaXMgbWV0aG9kIHNob3VsZCBiZSBvdmVycmlkZGVuXG4gICAgICogYnkgdGhlIGNvbnN1bWVyIG9mIHRoaXMgYmVoYXZpb3IuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIF91cGRhdGVTY3JvbGxTdGF0ZVxuICAgICAqL1xuICAgIF91cGRhdGVTY3JvbGxTdGF0ZTogZnVuY3Rpb24oKSB7fSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgY3VycmVudCBlbGVtZW50IGlzIG9uIHRoZSBzY3JlZW4uXG4gICAgICogVGhhdCBpcywgdmlzaWJsZSBpbiB0aGUgY3VycmVudCB2aWV3cG9ydC4gVGhpcyBtZXRob2Qgc2hvdWxkIGJlXG4gICAgICogb3ZlcnJpZGRlbiBieSB0aGUgY29uc3VtZXIgb2YgdGhpcyBiZWhhdmlvci5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgaXNPblNjcmVlblxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgaXNPblNjcmVlbjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGVyZSdzIGNvbnRlbnQgYmVsb3cgdGhlIGN1cnJlbnQgZWxlbWVudC4gVGhpcyBtZXRob2RcbiAgICAgKiBzaG91bGQgYmUgb3ZlcnJpZGRlbiBieSB0aGUgY29uc3VtZXIgb2YgdGhpcyBiZWhhdmlvci5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgaXNDb250ZW50QmVsb3dcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuICAgIGlzQ29udGVudEJlbG93OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTGlzdCBvZiBlZmZlY3RzIGhhbmRsZXJzIHRoYXQgd2lsbCB0YWtlIHBsYWNlIGR1cmluZyBzY3JvbGwuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7QXJyYXk8RnVuY3Rpb24+fVxuICAgICAqL1xuICAgIF9lZmZlY3RzUnVuRm46IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBMaXN0IG9mIHRoZSBlZmZlY3RzIGRlZmluaXRpb25zIGluc3RhbGxlZCB2aWEgdGhlIGBlZmZlY3RzYCBwcm9wZXJ0eS5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtBcnJheTxPYmplY3Q+fVxuICAgICAqL1xuICAgIF9lZmZlY3RzOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogVGhlIGNsYW1wZWQgdmFsdWUgb2YgYF9zY3JvbGxUb3BgLlxuICAgICAqIEB0eXBlIG51bWJlclxuICAgICAqL1xuICAgIGdldCBfY2xhbXBlZFNjcm9sbFRvcCgpIHtcbiAgICAgIHJldHVybiBNYXRoLm1heCgwLCB0aGlzLl9zY3JvbGxUb3ApO1xuICAgIH0sXG5cbiAgICBkZXRhY2hlZDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl90ZWFyRG93bkVmZmVjdHMoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBlZmZlY3Qgb2JqZWN0IGZyb20gYW4gZWZmZWN0J3MgbmFtZSB0aGF0IGNhbiBiZSB1c2VkIHRvIHJ1blxuICAgICAqIGVmZmVjdHMgcHJvZ3JhbW1hdGljYWxseS5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgY3JlYXRlRWZmZWN0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGVmZmVjdE5hbWUgVGhlIGVmZmVjdCdzIG5hbWUgcmVnaXN0ZXJlZCB2aWEgYFBvbHltZXIuQXBwTGF5b3V0LnJlZ2lzdGVyRWZmZWN0YC5cbiAgICAgKiBAcGFyYW0ge09iamVjdD19IGVmZmVjdENvbmZpZyBUaGUgZWZmZWN0IGNvbmZpZyBvYmplY3QuIChPcHRpb25hbClcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEFuIGVmZmVjdCBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIGZ1bmN0aW9uczpcbiAgICAgKlxuICAgICAqICAqIGBlZmZlY3Quc2V0VXAoKWAsIFNldHMgdXAgdGhlIHJlcXVpcmVtZW50cyBmb3IgdGhlIGVmZmVjdC5cbiAgICAgKiAgICAgICBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBhdXRvbWF0aWNhbGx5IGJlZm9yZSB0aGUgYGVmZmVjdGAgZnVuY3Rpb24gcmV0dXJucy5cbiAgICAgKiAgKiBgZWZmZWN0LnJ1bihwcm9ncmVzcywgeSlgLCBSdW5zIHRoZSBlZmZlY3QgZ2l2ZW4gYSBgcHJvZ3Jlc3NgLlxuICAgICAqICAqIGBlZmZlY3QudGVhckRvd24oKWAsIENsZWFucyB1cCBhbnkgRE9NIG5vZGVzIG9yIGVsZW1lbnQgcmVmZXJlbmNlcyB1c2VkIGJ5IHRoZSBlZmZlY3QuXG4gICAgICpcbiAgICAgKiBFeGFtcGxlOlxuICAgICAqIGBgYGpzXG4gICAgICogdmFyIHBhcmFsbGF4ID0gZWxlbWVudC5jcmVhdGVFZmZlY3QoJ3BhcmFsbGF4LWJhY2tncm91bmQnKTtcbiAgICAgKiAvLyBydW5zIHRoZSBlZmZlY3RcbiAgICAgKiBwYXJhbGxheC5ydW4oMC41LCAwKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBjcmVhdGVFZmZlY3Q6IGZ1bmN0aW9uKGVmZmVjdE5hbWUsIGVmZmVjdENvbmZpZykge1xuICAgICAgdmFyIGVmZmVjdERlZiA9IFBvbHltZXIuQXBwTGF5b3V0Ll9zY3JvbGxFZmZlY3RzW2VmZmVjdE5hbWVdO1xuICAgICAgaWYgKCFlZmZlY3REZWYpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKHRoaXMuX2dldFVuZGVmaW5lZE1zZyhlZmZlY3ROYW1lKSk7XG4gICAgICB9XG4gICAgICB2YXIgcHJvcCA9IHRoaXMuX2JvdW5kRWZmZWN0KGVmZmVjdERlZiwgZWZmZWN0Q29uZmlnIHx8IHt9KTtcbiAgICAgIHByb3Auc2V0VXAoKTtcbiAgICAgIHJldHVybiBwcm9wO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiBgZWZmZWN0c2Agb3IgYGVmZmVjdHNDb25maWdgIGNoYW5nZXMuXG4gICAgICovXG4gICAgX2VmZmVjdHNDaGFuZ2VkOiBmdW5jdGlvbihlZmZlY3RzLCBlZmZlY3RzQ29uZmlnLCBpc0F0dGFjaGVkKSB7XG4gICAgICB0aGlzLl90ZWFyRG93bkVmZmVjdHMoKTtcblxuICAgICAgaWYgKCFlZmZlY3RzIHx8ICFpc0F0dGFjaGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGVmZmVjdHMuc3BsaXQoJyAnKS5mb3JFYWNoKGZ1bmN0aW9uKGVmZmVjdE5hbWUpIHtcbiAgICAgICAgdmFyIGVmZmVjdERlZjtcbiAgICAgICAgaWYgKGVmZmVjdE5hbWUgIT09ICcnKSB7XG4gICAgICAgICAgaWYgKChlZmZlY3REZWYgPSBQb2x5bWVyLkFwcExheW91dC5fc2Nyb2xsRWZmZWN0c1tlZmZlY3ROYW1lXSkpIHtcbiAgICAgICAgICAgIHRoaXMuX2VmZmVjdHMucHVzaCh0aGlzLl9ib3VuZEVmZmVjdChlZmZlY3REZWYsIGVmZmVjdHNDb25maWdbZWZmZWN0TmFtZV0pKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKHRoaXMuX2dldFVuZGVmaW5lZE1zZyhlZmZlY3ROYW1lKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCB0aGlzKTtcblxuICAgICAgdGhpcy5fc2V0VXBFZmZlY3QoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRm9yY2VzIGxheW91dFxuICAgICAqL1xuICAgIF9sYXlvdXRJZkRpcnR5OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLm9mZnNldFdpZHRoO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGVmZmVjdCBvYmplY3QgYm91bmQgdG8gdGhlIGN1cnJlbnQgY29udGV4dC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlZmZlY3REZWZcbiAgICAgKiBAcGFyYW0ge09iamVjdD19IGVmZmVjdHNDb25maWcgVGhlIGVmZmVjdCBjb25maWcgb2JqZWN0IGlmIHRoZSBlZmZlY3QgYWNjZXB0cyBjb25maWcgdmFsdWVzLiAoT3B0aW9uYWwpXG4gICAgICovXG4gICAgX2JvdW5kRWZmZWN0OiBmdW5jdGlvbihlZmZlY3REZWYsIGVmZmVjdHNDb25maWcpIHtcbiAgICAgIGVmZmVjdHNDb25maWcgPSBlZmZlY3RzQ29uZmlnIHx8IHt9O1xuICAgICAgdmFyIHN0YXJ0c0F0ID0gcGFyc2VGbG9hdChlZmZlY3RzQ29uZmlnLnN0YXJ0c0F0IHx8IDApO1xuICAgICAgdmFyIGVuZHNBdCA9IHBhcnNlRmxvYXQoZWZmZWN0c0NvbmZpZy5lbmRzQXQgfHwgMSk7XG4gICAgICB2YXIgZGVsdGFTID0gZW5kc0F0IC0gc3RhcnRzQXQ7XG4gICAgICB2YXIgbm9vcCA9IGZ1bmN0aW9uKCkge307XG4gICAgICAvLyBmYXN0IHBhdGggaWYgcG9zc2libGVcbiAgICAgIHZhciBydW5GbiA9IChzdGFydHNBdCA9PT0gMCAmJiBlbmRzQXQgPT09IDEpID8gZWZmZWN0RGVmLnJ1biA6XG4gICAgICAgIGZ1bmN0aW9uKHByb2dyZXNzLCB5KSB7XG4gICAgICAgICAgZWZmZWN0RGVmLnJ1bi5jYWxsKHRoaXMsXG4gICAgICAgICAgICAgIE1hdGgubWF4KDAsIChwcm9ncmVzcyAtIHN0YXJ0c0F0KSAvIGRlbHRhUyksIHkpO1xuICAgICAgICB9O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2V0VXA6IGVmZmVjdERlZi5zZXRVcCA/IGVmZmVjdERlZi5zZXRVcC5iaW5kKHRoaXMsIGVmZmVjdHNDb25maWcpIDogbm9vcCxcbiAgICAgICAgcnVuOiBlZmZlY3REZWYucnVuID8gcnVuRm4uYmluZCh0aGlzKSA6IG5vb3AsXG4gICAgICAgIHRlYXJEb3duOiBlZmZlY3REZWYudGVhckRvd24gPyBlZmZlY3REZWYudGVhckRvd24uYmluZCh0aGlzKSA6IG5vb3BcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgdXAgdGhlIGVmZmVjdHMuXG4gICAgICovXG4gICAgX3NldFVwRWZmZWN0OiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmlzQXR0YWNoZWQgJiYgdGhpcy5fZWZmZWN0cykge1xuICAgICAgICB0aGlzLl9lZmZlY3RzUnVuRm4gPSBbXTtcbiAgICAgICAgdGhpcy5fZWZmZWN0cy5mb3JFYWNoKGZ1bmN0aW9uKGVmZmVjdERlZikge1xuICAgICAgICAgIC8vIGluc3RhbGwgdGhlIGVmZmVjdCBvbmx5IGlmIG5vIGVycm9yIHdhcyByZXBvcnRlZFxuICAgICAgICAgIGlmIChlZmZlY3REZWYuc2V0VXAoKSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRoaXMuX2VmZmVjdHNSdW5Gbi5wdXNoKGVmZmVjdERlZi5ydW4pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRlYXJzIGRvd24gdGhlIGVmZmVjdHMuXG4gICAgICovXG4gICAgX3RlYXJEb3duRWZmZWN0czogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5fZWZmZWN0cykge1xuICAgICAgICB0aGlzLl9lZmZlY3RzLmZvckVhY2goZnVuY3Rpb24oZWZmZWN0RGVmKSB7XG4gICAgICAgICAgZWZmZWN0RGVmLnRlYXJEb3duKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdGhpcy5fZWZmZWN0c1J1bkZuID0gW107XG4gICAgICB0aGlzLl9lZmZlY3RzID0gW107XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJ1bnMgdGhlIGVmZmVjdHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcCBUaGUgcHJvZ3Jlc3NcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSBUaGUgdG9wIHBvc2l0aW9uIG9mIHRoZSBjdXJyZW50IGVsZW1lbnQgcmVsYXRpdmUgdG8gdGhlIHZpZXdwb3J0LlxuICAgICAqL1xuICAgIF9ydW5FZmZlY3RzOiBmdW5jdGlvbihwLCB5KSB7XG4gICAgICBpZiAodGhpcy5fZWZmZWN0c1J1bkZuKSB7XG4gICAgICAgIHRoaXMuX2VmZmVjdHNSdW5Gbi5mb3JFYWNoKGZ1bmN0aW9uKHJ1bikge1xuICAgICAgICAgIHJ1bihwLCB5KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlcyB0aGUgYF9zY3JvbGxIYW5kbGVyYC5cbiAgICAgKi9cbiAgICBfc2Nyb2xsSGFuZGxlcjogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgdmFyIHNjcm9sbFRvcCA9IHRoaXMuX2NsYW1wZWRTY3JvbGxUb3A7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVNjcm9sbFN0YXRlKHNjcm9sbFRvcCk7XG4gICAgICAgIGlmICh0aGlzLnRocmVzaG9sZCA+IDApIHtcbiAgICAgICAgICB0aGlzLl9zZXRUaHJlc2hvbGRUcmlnZ2VyZWQoc2Nyb2xsVG9wID49IHRoaXMudGhyZXNob2xkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSB0aGlzIG1ldGhvZCB0byByZXR1cm4gYSByZWZlcmVuY2UgdG8gYSBub2RlIGluIHRoZSBsb2NhbCBET00uXG4gICAgICogVGhlIG5vZGUgaXMgY29uc3VtZWQgYnkgYSBzY3JvbGwgZWZmZWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkIFRoZSBpZCBmb3IgdGhlIG5vZGUuXG4gICAgICovXG4gICAgX2dldERPTVJlZjogZnVuY3Rpb24oaWQpIHtcbiAgICAgIGNvbnNvbGUud2FybignX2dldERPTVJlZicsICdgJysgaWQgKydgIGlzIHVuZGVmaW5lZCcpO1xuICAgIH0sXG5cbiAgICBfZ2V0VW5kZWZpbmVkTXNnOiBmdW5jdGlvbihlZmZlY3ROYW1lKSB7XG4gICAgICByZXR1cm4gJ1Njcm9sbCBlZmZlY3QgYCcgKyBlZmZlY3ROYW1lICsgJ2AgaXMgdW5kZWZpbmVkLiAnICtcbiAgICAgICAgICAnRGlkIHlvdSBmb3JnZXQgdG8gaW1wb3J0IGFwcC1sYXlvdXQvYXBwLXNjcm9sbC1lZmZlY3RzL2VmZmVjdHMvJyArIGVmZmVjdE5hbWUgKyAnLmh0bWwgPyc7XG4gICAgfVxuXG4gIH1dO1xuXG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvYXBwLWxheW91dC9hcHAtc2Nyb2xsLWVmZmVjdHMvYXBwLXNjcm9sbC1lZmZlY3RzLWJlaGF2aW9yLmh0bWwiLCJcbnJlcXVpcmUoJy4uL3BvbHltZXIvcG9seW1lci5odG1sJyk7XG5cbmNvbnN0IFJlZ2lzdGVySHRtbFRlbXBsYXRlID0gcmVxdWlyZSgncG9seW1lci13ZWJwYWNrLWxvYWRlci9yZWdpc3Rlci1odG1sLXRlbXBsYXRlJyk7XG5cblJlZ2lzdGVySHRtbFRlbXBsYXRlLnRvQm9keShcIjxjdXN0b20tc3R5bGU+IDxzdHlsZSBpcz1jdXN0b20tc3R5bGU+aHRtbHstLWxheW91dDp7ZGlzcGxheTotbXMtZmxleGJveDtkaXNwbGF5Oi13ZWJraXQtZmxleDtkaXNwbGF5OmZsZXh9Oy0tbGF5b3V0LWlubGluZTp7ZGlzcGxheTotbXMtaW5saW5lLWZsZXhib3g7ZGlzcGxheTotd2Via2l0LWlubGluZS1mbGV4O2Rpc3BsYXk6aW5saW5lLWZsZXh9Oy0tbGF5b3V0LWhvcml6b250YWw6e0BhcHBseSAtLWxheW91dDstbXMtZmxleC1kaXJlY3Rpb246cm93Oy13ZWJraXQtZmxleC1kaXJlY3Rpb246cm93O2ZsZXgtZGlyZWN0aW9uOnJvd307LS1sYXlvdXQtaG9yaXpvbnRhbC1yZXZlcnNlOntAYXBwbHkgLS1sYXlvdXQ7LW1zLWZsZXgtZGlyZWN0aW9uOnJvdy1yZXZlcnNlOy13ZWJraXQtZmxleC1kaXJlY3Rpb246cm93LXJldmVyc2U7ZmxleC1kaXJlY3Rpb246cm93LXJldmVyc2V9Oy0tbGF5b3V0LXZlcnRpY2FsOntAYXBwbHkgLS1sYXlvdXQ7LW1zLWZsZXgtZGlyZWN0aW9uOmNvbHVtbjstd2Via2l0LWZsZXgtZGlyZWN0aW9uOmNvbHVtbjtmbGV4LWRpcmVjdGlvbjpjb2x1bW59Oy0tbGF5b3V0LXZlcnRpY2FsLXJldmVyc2U6e0BhcHBseSAtLWxheW91dDstbXMtZmxleC1kaXJlY3Rpb246Y29sdW1uLXJldmVyc2U7LXdlYmtpdC1mbGV4LWRpcmVjdGlvbjpjb2x1bW4tcmV2ZXJzZTtmbGV4LWRpcmVjdGlvbjpjb2x1bW4tcmV2ZXJzZX07LS1sYXlvdXQtd3JhcDp7LW1zLWZsZXgtd3JhcDp3cmFwOy13ZWJraXQtZmxleC13cmFwOndyYXA7ZmxleC13cmFwOndyYXB9Oy0tbGF5b3V0LXdyYXAtcmV2ZXJzZTp7LW1zLWZsZXgtd3JhcDp3cmFwLXJldmVyc2U7LXdlYmtpdC1mbGV4LXdyYXA6d3JhcC1yZXZlcnNlO2ZsZXgtd3JhcDp3cmFwLXJldmVyc2V9Oy0tbGF5b3V0LWZsZXgtYXV0bzp7LW1zLWZsZXg6MSAxIGF1dG87LXdlYmtpdC1mbGV4OjEgMSBhdXRvO2ZsZXg6MSAxIGF1dG99Oy0tbGF5b3V0LWZsZXgtbm9uZTp7LW1zLWZsZXg6bm9uZTstd2Via2l0LWZsZXg6bm9uZTtmbGV4Om5vbmV9Oy0tbGF5b3V0LWZsZXg6ey1tcy1mbGV4OjEgMSAuMDAwMDAwMDAxcHg7LXdlYmtpdC1mbGV4OjE7ZmxleDoxOy13ZWJraXQtZmxleC1iYXNpczouMDAwMDAwMDAxcHg7ZmxleC1iYXNpczouMDAwMDAwMDAxcHh9Oy0tbGF5b3V0LWZsZXgtMjp7LW1zLWZsZXg6Mjstd2Via2l0LWZsZXg6MjtmbGV4OjJ9Oy0tbGF5b3V0LWZsZXgtMzp7LW1zLWZsZXg6Mzstd2Via2l0LWZsZXg6MztmbGV4OjN9Oy0tbGF5b3V0LWZsZXgtNDp7LW1zLWZsZXg6NDstd2Via2l0LWZsZXg6NDtmbGV4OjR9Oy0tbGF5b3V0LWZsZXgtNTp7LW1zLWZsZXg6NTstd2Via2l0LWZsZXg6NTtmbGV4OjV9Oy0tbGF5b3V0LWZsZXgtNjp7LW1zLWZsZXg6Njstd2Via2l0LWZsZXg6NjtmbGV4OjZ9Oy0tbGF5b3V0LWZsZXgtNzp7LW1zLWZsZXg6Nzstd2Via2l0LWZsZXg6NztmbGV4Ojd9Oy0tbGF5b3V0LWZsZXgtODp7LW1zLWZsZXg6ODstd2Via2l0LWZsZXg6ODtmbGV4Ojh9Oy0tbGF5b3V0LWZsZXgtOTp7LW1zLWZsZXg6OTstd2Via2l0LWZsZXg6OTtmbGV4Ojl9Oy0tbGF5b3V0LWZsZXgtMTA6ey1tcy1mbGV4OjEwOy13ZWJraXQtZmxleDoxMDtmbGV4OjEwfTstLWxheW91dC1mbGV4LTExOnstbXMtZmxleDoxMTstd2Via2l0LWZsZXg6MTE7ZmxleDoxMX07LS1sYXlvdXQtZmxleC0xMjp7LW1zLWZsZXg6MTI7LXdlYmtpdC1mbGV4OjEyO2ZsZXg6MTJ9Oy0tbGF5b3V0LXN0YXJ0OnstbXMtZmxleC1hbGlnbjpzdGFydDstd2Via2l0LWFsaWduLWl0ZW1zOmZsZXgtc3RhcnQ7YWxpZ24taXRlbXM6ZmxleC1zdGFydH07LS1sYXlvdXQtY2VudGVyOnstbXMtZmxleC1hbGlnbjpjZW50ZXI7LXdlYmtpdC1hbGlnbi1pdGVtczpjZW50ZXI7YWxpZ24taXRlbXM6Y2VudGVyfTstLWxheW91dC1lbmQ6ey1tcy1mbGV4LWFsaWduOmVuZDstd2Via2l0LWFsaWduLWl0ZW1zOmZsZXgtZW5kO2FsaWduLWl0ZW1zOmZsZXgtZW5kfTstLWxheW91dC1iYXNlbGluZTp7LW1zLWZsZXgtYWxpZ246YmFzZWxpbmU7LXdlYmtpdC1hbGlnbi1pdGVtczpiYXNlbGluZTthbGlnbi1pdGVtczpiYXNlbGluZX07LS1sYXlvdXQtc3RhcnQtanVzdGlmaWVkOnstbXMtZmxleC1wYWNrOnN0YXJ0Oy13ZWJraXQtanVzdGlmeS1jb250ZW50OmZsZXgtc3RhcnQ7anVzdGlmeS1jb250ZW50OmZsZXgtc3RhcnR9Oy0tbGF5b3V0LWNlbnRlci1qdXN0aWZpZWQ6ey1tcy1mbGV4LXBhY2s6Y2VudGVyOy13ZWJraXQtanVzdGlmeS1jb250ZW50OmNlbnRlcjtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyfTstLWxheW91dC1lbmQtanVzdGlmaWVkOnstbXMtZmxleC1wYWNrOmVuZDstd2Via2l0LWp1c3RpZnktY29udGVudDpmbGV4LWVuZDtqdXN0aWZ5LWNvbnRlbnQ6ZmxleC1lbmR9Oy0tbGF5b3V0LWFyb3VuZC1qdXN0aWZpZWQ6ey1tcy1mbGV4LXBhY2s6ZGlzdHJpYnV0ZTstd2Via2l0LWp1c3RpZnktY29udGVudDpzcGFjZS1hcm91bmQ7anVzdGlmeS1jb250ZW50OnNwYWNlLWFyb3VuZH07LS1sYXlvdXQtanVzdGlmaWVkOnstbXMtZmxleC1wYWNrOmp1c3RpZnk7LXdlYmtpdC1qdXN0aWZ5LWNvbnRlbnQ6c3BhY2UtYmV0d2VlbjtqdXN0aWZ5LWNvbnRlbnQ6c3BhY2UtYmV0d2Vlbn07LS1sYXlvdXQtY2VudGVyLWNlbnRlcjp7QGFwcGx5IC0tbGF5b3V0LWNlbnRlcjtAYXBwbHkgLS1sYXlvdXQtY2VudGVyLWp1c3RpZmllZDt9Oy0tbGF5b3V0LXNlbGYtc3RhcnQ6ey1tcy1hbGlnbi1zZWxmOmZsZXgtc3RhcnQ7LXdlYmtpdC1hbGlnbi1zZWxmOmZsZXgtc3RhcnQ7YWxpZ24tc2VsZjpmbGV4LXN0YXJ0fTstLWxheW91dC1zZWxmLWNlbnRlcjp7LW1zLWFsaWduLXNlbGY6Y2VudGVyOy13ZWJraXQtYWxpZ24tc2VsZjpjZW50ZXI7YWxpZ24tc2VsZjpjZW50ZXJ9Oy0tbGF5b3V0LXNlbGYtZW5kOnstbXMtYWxpZ24tc2VsZjpmbGV4LWVuZDstd2Via2l0LWFsaWduLXNlbGY6ZmxleC1lbmQ7YWxpZ24tc2VsZjpmbGV4LWVuZH07LS1sYXlvdXQtc2VsZi1zdHJldGNoOnstbXMtYWxpZ24tc2VsZjpzdHJldGNoOy13ZWJraXQtYWxpZ24tc2VsZjpzdHJldGNoO2FsaWduLXNlbGY6c3RyZXRjaH07LS1sYXlvdXQtc2VsZi1iYXNlbGluZTp7LW1zLWFsaWduLXNlbGY6YmFzZWxpbmU7LXdlYmtpdC1hbGlnbi1zZWxmOmJhc2VsaW5lO2FsaWduLXNlbGY6YmFzZWxpbmV9Oy0tbGF5b3V0LXN0YXJ0LWFsaWduZWQ6ey1tcy1mbGV4LWxpbmUtcGFjazpzdGFydDstbXMtYWxpZ24tY29udGVudDpmbGV4LXN0YXJ0Oy13ZWJraXQtYWxpZ24tY29udGVudDpmbGV4LXN0YXJ0O2FsaWduLWNvbnRlbnQ6ZmxleC1zdGFydH07LS1sYXlvdXQtZW5kLWFsaWduZWQ6ey1tcy1mbGV4LWxpbmUtcGFjazplbmQ7LW1zLWFsaWduLWNvbnRlbnQ6ZmxleC1lbmQ7LXdlYmtpdC1hbGlnbi1jb250ZW50OmZsZXgtZW5kO2FsaWduLWNvbnRlbnQ6ZmxleC1lbmR9Oy0tbGF5b3V0LWNlbnRlci1hbGlnbmVkOnstbXMtZmxleC1saW5lLXBhY2s6Y2VudGVyOy1tcy1hbGlnbi1jb250ZW50OmNlbnRlcjstd2Via2l0LWFsaWduLWNvbnRlbnQ6Y2VudGVyO2FsaWduLWNvbnRlbnQ6Y2VudGVyfTstLWxheW91dC1iZXR3ZWVuLWFsaWduZWQ6ey1tcy1mbGV4LWxpbmUtcGFjazpqdXN0aWZ5Oy1tcy1hbGlnbi1jb250ZW50OnNwYWNlLWJldHdlZW47LXdlYmtpdC1hbGlnbi1jb250ZW50OnNwYWNlLWJldHdlZW47YWxpZ24tY29udGVudDpzcGFjZS1iZXR3ZWVufTstLWxheW91dC1hcm91bmQtYWxpZ25lZDp7LW1zLWZsZXgtbGluZS1wYWNrOmRpc3RyaWJ1dGU7LW1zLWFsaWduLWNvbnRlbnQ6c3BhY2UtYXJvdW5kOy13ZWJraXQtYWxpZ24tY29udGVudDpzcGFjZS1hcm91bmQ7YWxpZ24tY29udGVudDpzcGFjZS1hcm91bmR9Oy0tbGF5b3V0LWJsb2NrOntkaXNwbGF5OmJsb2NrfTstLWxheW91dC1pbnZpc2libGU6e3Zpc2liaWxpdHk6aGlkZGVuIWltcG9ydGFudH07LS1sYXlvdXQtcmVsYXRpdmU6e3Bvc2l0aW9uOnJlbGF0aXZlfTstLWxheW91dC1maXQ6e3Bvc2l0aW9uOmFic29sdXRlO3RvcDowO3JpZ2h0OjA7Ym90dG9tOjA7bGVmdDowfTstLWxheW91dC1zY3JvbGw6ey13ZWJraXQtb3ZlcmZsb3ctc2Nyb2xsaW5nOnRvdWNoO292ZXJmbG93OmF1dG99Oy0tbGF5b3V0LWZ1bGxibGVlZDp7bWFyZ2luOjA7aGVpZ2h0OjEwMHZofTstLWxheW91dC1maXhlZC10b3A6e3Bvc2l0aW9uOmZpeGVkO3RvcDowO2xlZnQ6MDtyaWdodDowfTstLWxheW91dC1maXhlZC1yaWdodDp7cG9zaXRpb246Zml4ZWQ7dG9wOjA7cmlnaHQ6MDtib3R0b206MH07LS1sYXlvdXQtZml4ZWQtYm90dG9tOntwb3NpdGlvbjpmaXhlZDtyaWdodDowO2JvdHRvbTowO2xlZnQ6MH07LS1sYXlvdXQtZml4ZWQtbGVmdDp7cG9zaXRpb246Zml4ZWQ7dG9wOjA7Ym90dG9tOjA7bGVmdDowfTt9PC9zdHlsZT4gPC9jdXN0b20tc3R5bGU+XCIpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9pcm9uLWZsZXgtbGF5b3V0L2lyb24tZmxleC1sYXlvdXQuaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCJsaWIvbWl4aW5zL2VsZW1lbnQtbWl4aW4uaHRtbFwiPlxuPHNjcmlwdD5cbihmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8qKlxuICAgKiBCYXNlIGNsYXNzIHRoYXQgcHJvdmlkZXMgdGhlIGNvcmUgQVBJIGZvciBQb2x5bWVyJ3MgbWV0YS1wcm9ncmFtbWluZ1xuICAgKiBmZWF0dXJlcyBpbmNsdWRpbmcgdGVtcGxhdGUgc3RhbXBpbmcsIGRhdGEtYmluZGluZywgYXR0cmlidXRlIGRlc2VyaWFsaXphdGlvbixcbiAgICogYW5kIHByb3BlcnR5IGNoYW5nZSBvYnNlcnZhdGlvbi5cbiAgICpcbiAgICogQGN1c3RvbUVsZW1lbnRcbiAgICogQHBvbHltZXJcbiAgICogQG1lbWJlcm9mIFBvbHltZXJcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBpbXBsZW1lbnRzIHtQb2x5bWVyX0VsZW1lbnRNaXhpbn1cbiAgICogQGV4dGVuZHMgSFRNTEVsZW1lbnRcbiAgICogQGFwcGxpZXNNaXhpbiBQb2x5bWVyLkVsZW1lbnRNaXhpblxuICAgKiBAc3VtbWFyeSBDdXN0b20gZWxlbWVudCBiYXNlIGNsYXNzIHRoYXQgcHJvdmlkZXMgdGhlIGNvcmUgQVBJIGZvciBQb2x5bWVyJ3NcbiAgICogICBrZXkgbWV0YS1wcm9ncmFtbWluZyBmZWF0dXJlcyBpbmNsdWRpbmcgdGVtcGxhdGUgc3RhbXBpbmcsIGRhdGEtYmluZGluZyxcbiAgICogICBhdHRyaWJ1dGUgZGVzZXJpYWxpemF0aW9uLCBhbmQgcHJvcGVydHkgY2hhbmdlIG9ic2VydmF0aW9uXG4gICAqL1xuICBjb25zdCBFbGVtZW50ID0gUG9seW1lci5FbGVtZW50TWl4aW4oSFRNTEVsZW1lbnQpO1xuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBpbXBsZW1lbnRzIHtQb2x5bWVyX0VsZW1lbnRNaXhpbn1cbiAgICogQGV4dGVuZHMge0hUTUxFbGVtZW50fVxuICAgKi9cbiAgUG9seW1lci5FbGVtZW50ID0gRWxlbWVudDtcbn0pKCk7XG48L3NjcmlwdD5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL3BvbHltZXIvcG9seW1lci1lbGVtZW50Lmh0bWwiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiYm9vdC5odG1sXCI+XG5cbjxzY3JpcHQ+XG5cbiAgKGZ1bmN0aW9uKCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGxldCBDU1NfVVJMX1JYID0gLyh1cmxcXCgpKFteKV0qKShcXCkpL2c7XG4gICAgbGV0IEFCU19VUkwgPSAvKF5cXC8pfCheIyl8KF5bXFx3LVxcZF0qOikvO1xuICAgIGxldCB3b3JraW5nVVJMO1xuICAgIGxldCByZXNvbHZlRG9jO1xuICAgIC8qKlxuICAgICAqIFJlc29sdmVzIHRoZSBnaXZlbiBVUkwgYWdhaW5zdCB0aGUgcHJvdmlkZWQgYGJhc2VVcmknLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIFBvbHltZXIuUmVzb2x2ZVVybFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgSW5wdXQgVVJMIHRvIHJlc29sdmVcbiAgICAgKiBAcGFyYW0gez9zdHJpbmc9fSBiYXNlVVJJIEJhc2UgVVJJIHRvIHJlc29sdmUgdGhlIFVSTCBhZ2FpbnN0XG4gICAgICogQHJldHVybiB7c3RyaW5nfSByZXNvbHZlZCBVUkxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXNvbHZlVXJsKHVybCwgYmFzZVVSSSkge1xuICAgICAgaWYgKHVybCAmJiBBQlNfVVJMLnRlc3QodXJsKSkge1xuICAgICAgICByZXR1cm4gdXJsO1xuICAgICAgfVxuICAgICAgLy8gTGF6eSBmZWF0dXJlIGRldGVjdGlvbi5cbiAgICAgIGlmICh3b3JraW5nVVJMID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgd29ya2luZ1VSTCA9IGZhbHNlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHUgPSBuZXcgVVJMKCdiJywgJ2h0dHA6Ly9hJyk7XG4gICAgICAgICAgdS5wYXRobmFtZSA9ICdjJTIwZCc7XG4gICAgICAgICAgd29ya2luZ1VSTCA9ICh1LmhyZWYgPT09ICdodHRwOi8vYS9jJTIwZCcpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgLy8gc2lsZW50bHkgZmFpbFxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWJhc2VVUkkpIHtcbiAgICAgICAgYmFzZVVSSSA9IGRvY3VtZW50LmJhc2VVUkkgfHwgd2luZG93LmxvY2F0aW9uLmhyZWY7XG4gICAgICB9XG4gICAgICBpZiAod29ya2luZ1VSTCkge1xuICAgICAgICByZXR1cm4gKG5ldyBVUkwodXJsLCBiYXNlVVJJKSkuaHJlZjtcbiAgICAgIH1cbiAgICAgIC8vIEZhbGxiYWNrIHRvIGNyZWF0aW5nIGFuIGFuY2hvciBpbnRvIGEgZGlzY29ubmVjdGVkIGRvY3VtZW50LlxuICAgICAgaWYgKCFyZXNvbHZlRG9jKSB7XG4gICAgICAgIHJlc29sdmVEb2MgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoJ3RlbXAnKTtcbiAgICAgICAgcmVzb2x2ZURvYy5iYXNlID0gcmVzb2x2ZURvYy5jcmVhdGVFbGVtZW50KCdiYXNlJyk7XG4gICAgICAgIHJlc29sdmVEb2MuaGVhZC5hcHBlbmRDaGlsZChyZXNvbHZlRG9jLmJhc2UpO1xuICAgICAgICByZXNvbHZlRG9jLmFuY2hvciA9IHJlc29sdmVEb2MuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgICAgICByZXNvbHZlRG9jLmJvZHkuYXBwZW5kQ2hpbGQocmVzb2x2ZURvYy5hbmNob3IpO1xuICAgICAgfVxuICAgICAgcmVzb2x2ZURvYy5iYXNlLmhyZWYgPSBiYXNlVVJJO1xuICAgICAgcmVzb2x2ZURvYy5hbmNob3IuaHJlZiA9IHVybDtcbiAgICAgIHJldHVybiByZXNvbHZlRG9jLmFuY2hvci5ocmVmIHx8IHVybDtcblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlc29sdmVzIGFueSByZWxhdGl2ZSBVUkwncyBpbiB0aGUgZ2l2ZW4gQ1NTIHRleHQgYWdhaW5zdCB0aGUgcHJvdmlkZWRcbiAgICAgKiBgb3duZXJEb2N1bWVudGAncyBgYmFzZVVSSWAuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgUG9seW1lci5SZXNvbHZlVXJsXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNzc1RleHQgQ1NTIHRleHQgdG8gcHJvY2Vzc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlVVJJIEJhc2UgVVJJIHRvIHJlc29sdmUgdGhlIFVSTCBhZ2FpbnN0XG4gICAgICogQHJldHVybiB7c3RyaW5nfSBQcm9jZXNzZWQgQ1NTIHRleHQgd2l0aCByZXNvbHZlZCBVUkwnc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlc29sdmVDc3MoY3NzVGV4dCwgYmFzZVVSSSkge1xuICAgICAgcmV0dXJuIGNzc1RleHQucmVwbGFjZShDU1NfVVJMX1JYLCBmdW5jdGlvbihtLCBwcmUsIHVybCwgcG9zdCkge1xuICAgICAgICByZXR1cm4gcHJlICsgJ1xcJycgK1xuICAgICAgICAgIHJlc29sdmVVcmwodXJsLnJlcGxhY2UoL1tcIiddL2csICcnKSwgYmFzZVVSSSkgK1xuICAgICAgICAgICdcXCcnICsgcG9zdDtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBwYXRoIGZyb20gYSBnaXZlbiBgdXJsYC4gVGhlIHBhdGggaW5jbHVkZXMgdGhlIHRyYWlsaW5nXG4gICAgICogYC9gIGZyb20gdGhlIHVybC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBQb2x5bWVyLlJlc29sdmVVcmxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsIElucHV0IFVSTCB0byB0cmFuc2Zvcm1cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IHJlc29sdmVkIHBhdGhcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYXRoRnJvbVVybCh1cmwpIHtcbiAgICAgIHJldHVybiB1cmwuc3Vic3RyaW5nKDAsIHVybC5sYXN0SW5kZXhPZignLycpICsgMSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTW9kdWxlIHdpdGggdXRpbGl0aWVzIGZvciByZXNvbHZpbmcgcmVsYXRpdmUgVVJMJ3MuXG4gICAgICpcbiAgICAgKiBAbmFtZXNwYWNlXG4gICAgICogQG1lbWJlcm9mIFBvbHltZXJcbiAgICAgKiBAc3VtbWFyeSBNb2R1bGUgd2l0aCB1dGlsaXRpZXMgZm9yIHJlc29sdmluZyByZWxhdGl2ZSBVUkwncy5cbiAgICAgKi9cbiAgICBQb2x5bWVyLlJlc29sdmVVcmwgPSB7XG4gICAgICByZXNvbHZlQ3NzOiByZXNvbHZlQ3NzLFxuICAgICAgcmVzb2x2ZVVybDogcmVzb2x2ZVVybCxcbiAgICAgIHBhdGhGcm9tVXJsOiBwYXRoRnJvbVVybFxuICAgIH07XG5cbiAgfSkoKTtcblxuPC9zY3JpcHQ+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL3BvbHltZXIvbGliL3V0aWxzL3Jlc29sdmUtdXJsLmh0bWwiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiYm9vdC5odG1sXCI+XG5cbjxzY3JpcHQ+XG4oZnVuY3Rpb24oKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8qKiBAdHlwZWRlZiB7e3J1bjogZnVuY3Rpb24oZnVuY3Rpb24oKSwgbnVtYmVyPSk6bnVtYmVyLCBjYW5jZWw6IGZ1bmN0aW9uKG51bWJlcil9fSAqL1xuICBsZXQgQXN5bmNJbnRlcmZhY2U7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblxuICAvLyBNaWNyb3Rhc2sgaW1wbGVtZW50ZWQgdXNpbmcgTXV0YXRpb24gT2JzZXJ2ZXJcbiAgbGV0IG1pY3JvdGFza0N1cnJIYW5kbGUgPSAwO1xuICBsZXQgbWljcm90YXNrTGFzdEhhbmRsZSA9IDA7XG4gIGxldCBtaWNyb3Rhc2tDYWxsYmFja3MgPSBbXTtcbiAgbGV0IG1pY3JvdGFza05vZGVDb250ZW50ID0gMDtcbiAgbGV0IG1pY3JvdGFza05vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyk7XG4gIG5ldyB3aW5kb3cuTXV0YXRpb25PYnNlcnZlcihtaWNyb3Rhc2tGbHVzaCkub2JzZXJ2ZShtaWNyb3Rhc2tOb2RlLCB7Y2hhcmFjdGVyRGF0YTogdHJ1ZX0pO1xuXG4gIGZ1bmN0aW9uIG1pY3JvdGFza0ZsdXNoKCkge1xuICAgIGNvbnN0IGxlbiA9IG1pY3JvdGFza0NhbGxiYWNrcy5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgbGV0IGNiID0gbWljcm90YXNrQ2FsbGJhY2tzW2ldO1xuICAgICAgaWYgKGNiKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY2IoKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4geyB0aHJvdyBlIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIG1pY3JvdGFza0NhbGxiYWNrcy5zcGxpY2UoMCwgbGVuKTtcbiAgICBtaWNyb3Rhc2tMYXN0SGFuZGxlICs9IGxlbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBNb2R1bGUgdGhhdCBwcm92aWRlcyBhIG51bWJlciBvZiBzdHJhdGVnaWVzIGZvciBlbnF1ZXVpbmcgYXN5bmNocm9ub3VzXG4gICAqIHRhc2tzLiAgRWFjaCBzdWItbW9kdWxlIHByb3ZpZGVzIGEgc3RhbmRhcmQgYHJ1bihmbilgIGludGVyZmFjZSB0aGF0IHJldHVybnMgYVxuICAgKiBoYW5kbGUsIGFuZCBhIGBjYW5jZWwoaGFuZGxlKWAgaW50ZXJmYWNlIGZvciBjYW5jZWxpbmcgYXN5bmMgdGFza3MgYmVmb3JlXG4gICAqIHRoZXkgcnVuLlxuICAgKlxuICAgKiBAbmFtZXNwYWNlXG4gICAqIEBtZW1iZXJvZiBQb2x5bWVyXG4gICAqIEBzdW1tYXJ5IE1vZHVsZSB0aGF0IHByb3ZpZGVzIGEgbnVtYmVyIG9mIHN0cmF0ZWdpZXMgZm9yIGVucXVldWluZyBhc3luY2hyb25vdXNcbiAgICogdGFza3MuXG4gICAqL1xuICBQb2x5bWVyLkFzeW5jID0ge1xuXG4gICAgLyoqXG4gICAgICogQXN5bmMgaW50ZXJmYWNlIHdyYXBwZXIgYXJvdW5kIGBzZXRUaW1lb3V0YC5cbiAgICAgKlxuICAgICAqIEBuYW1lc3BhY2VcbiAgICAgKiBAbWVtYmVyb2YgUG9seW1lci5Bc3luY1xuICAgICAqIEBzdW1tYXJ5IEFzeW5jIGludGVyZmFjZSB3cmFwcGVyIGFyb3VuZCBgc2V0VGltZW91dGAuXG4gICAgICovXG4gICAgdGltZU91dDoge1xuICAgICAgLyoqXG4gICAgICAgKiBSZXR1cm5zIGEgc3ViLW1vZHVsZSB3aXRoIHRoZSBhc3luYyBpbnRlcmZhY2UgcHJvdmlkaW5nIHRoZSBwcm92aWRlZFxuICAgICAgICogZGVsYXkuXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlcm9mIFBvbHltZXIuQXN5bmMudGltZU91dFxuICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGRlbGF5IFRpbWUgdG8gd2FpdCBiZWZvcmUgY2FsbGluZyBjYWxsYmFja3MgaW4gbXNcbiAgICAgICAqIEByZXR1cm4ge0FzeW5jSW50ZXJmYWNlfSBBbiBhc3luYyB0aW1lb3V0IGludGVyZmFjZVxuICAgICAgICovXG4gICAgICBhZnRlcihkZWxheSkge1xuICAgICAgICByZXR1cm4gIHtcbiAgICAgICAgICBydW4oZm4pIHsgcmV0dXJuIHNldFRpbWVvdXQoZm4sIGRlbGF5KSB9LFxuICAgICAgICAgIGNhbmNlbDogd2luZG93LmNsZWFyVGltZW91dC5iaW5kKHdpbmRvdylcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8qKlxuICAgICAgICogRW5xdWV1ZXMgYSBmdW5jdGlvbiBjYWxsZWQgaW4gdGhlIG5leHQgdGFzay5cbiAgICAgICAqXG4gICAgICAgKiBAbWVtYmVyb2YgUG9seW1lci5Bc3luYy50aW1lT3V0XG4gICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBDYWxsYmFjayB0byBydW5cbiAgICAgICAqIEByZXR1cm4ge251bWJlcn0gSGFuZGxlIHVzZWQgZm9yIGNhbmNlbGluZyB0YXNrXG4gICAgICAgKi9cbiAgICAgIHJ1bjogd2luZG93LnNldFRpbWVvdXQuYmluZCh3aW5kb3cpLFxuICAgICAgLyoqXG4gICAgICAgKiBDYW5jZWxzIGEgcHJldmlvdXNseSBlbnF1ZXVlZCBgdGltZU91dGAgY2FsbGJhY2suXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlcm9mIFBvbHltZXIuQXN5bmMudGltZU91dFxuICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGhhbmRsZSBIYW5kbGUgcmV0dXJuZWQgZnJvbSBgcnVuYCBvZiBjYWxsYmFjayB0byBjYW5jZWxcbiAgICAgICAqL1xuICAgICAgY2FuY2VsOiB3aW5kb3cuY2xlYXJUaW1lb3V0LmJpbmQod2luZG93KVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBc3luYyBpbnRlcmZhY2Ugd3JhcHBlciBhcm91bmQgYHJlcXVlc3RBbmltYXRpb25GcmFtZWAuXG4gICAgICpcbiAgICAgKiBAbmFtZXNwYWNlXG4gICAgICogQG1lbWJlcm9mIFBvbHltZXIuQXN5bmNcbiAgICAgKiBAc3VtbWFyeSBBc3luYyBpbnRlcmZhY2Ugd3JhcHBlciBhcm91bmQgYHJlcXVlc3RBbmltYXRpb25GcmFtZWAuXG4gICAgICovXG4gICAgYW5pbWF0aW9uRnJhbWU6IHtcbiAgICAgIC8qKlxuICAgICAgICogRW5xdWV1ZXMgYSBmdW5jdGlvbiBjYWxsZWQgYXQgYHJlcXVlc3RBbmltYXRpb25GcmFtZWAgdGltaW5nLlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJvZiBQb2x5bWVyLkFzeW5jLmFuaW1hdGlvbkZyYW1lXG4gICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBDYWxsYmFjayB0byBydW5cbiAgICAgICAqIEByZXR1cm4ge251bWJlcn0gSGFuZGxlIHVzZWQgZm9yIGNhbmNlbGluZyB0YXNrXG4gICAgICAgKi9cbiAgICAgIHJ1bjogd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZS5iaW5kKHdpbmRvdyksXG4gICAgICAvKipcbiAgICAgICAqIENhbmNlbHMgYSBwcmV2aW91c2x5IGVucXVldWVkIGBhbmltYXRpb25GcmFtZWAgY2FsbGJhY2suXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlcm9mIFBvbHltZXIuQXN5bmMudGltZU91dFxuICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGhhbmRsZSBIYW5kbGUgcmV0dXJuZWQgZnJvbSBgcnVuYCBvZiBjYWxsYmFjayB0byBjYW5jZWxcbiAgICAgICAqL1xuICAgICAgY2FuY2VsOiB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUuYmluZCh3aW5kb3cpXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFzeW5jIGludGVyZmFjZSB3cmFwcGVyIGFyb3VuZCBgcmVxdWVzdElkbGVDYWxsYmFja2AuICBGYWxscyBiYWNrIHRvXG4gICAgICogYHNldFRpbWVvdXRgIG9uIGJyb3dzZXJzIHRoYXQgZG8gbm90IHN1cHBvcnQgYHJlcXVlc3RJZGxlQ2FsbGJhY2tgLlxuICAgICAqXG4gICAgICogQG5hbWVzcGFjZVxuICAgICAqIEBtZW1iZXJvZiBQb2x5bWVyLkFzeW5jXG4gICAgICogQHN1bW1hcnkgQXN5bmMgaW50ZXJmYWNlIHdyYXBwZXIgYXJvdW5kIGByZXF1ZXN0SWRsZUNhbGxiYWNrYC5cbiAgICAgKi9cbiAgICBpZGxlUGVyaW9kOiB7XG4gICAgICAvKipcbiAgICAgICAqIEVucXVldWVzIGEgZnVuY3Rpb24gY2FsbGVkIGF0IGByZXF1ZXN0SWRsZUNhbGxiYWNrYCB0aW1pbmcuXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlcm9mIFBvbHltZXIuQXN5bmMuaWRsZVBlcmlvZFxuICAgICAgICogQHBhcmFtIHtmdW5jdGlvbihJZGxlRGVhZGxpbmUpfSBmbiBDYWxsYmFjayB0byBydW5cbiAgICAgICAqIEByZXR1cm4ge251bWJlcn0gSGFuZGxlIHVzZWQgZm9yIGNhbmNlbGluZyB0YXNrXG4gICAgICAgKi9cbiAgICAgIHJ1bihmbikge1xuICAgICAgICByZXR1cm4gd2luZG93LnJlcXVlc3RJZGxlQ2FsbGJhY2sgP1xuICAgICAgICAgIHdpbmRvdy5yZXF1ZXN0SWRsZUNhbGxiYWNrKGZuKSA6XG4gICAgICAgICAgd2luZG93LnNldFRpbWVvdXQoZm4sIDE2KTtcbiAgICAgIH0sXG4gICAgICAvKipcbiAgICAgICAqIENhbmNlbHMgYSBwcmV2aW91c2x5IGVucXVldWVkIGBpZGxlUGVyaW9kYCBjYWxsYmFjay5cbiAgICAgICAqXG4gICAgICAgKiBAbWVtYmVyb2YgUG9seW1lci5Bc3luYy5pZGxlUGVyaW9kXG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0gaGFuZGxlIEhhbmRsZSByZXR1cm5lZCBmcm9tIGBydW5gIG9mIGNhbGxiYWNrIHRvIGNhbmNlbFxuICAgICAgICovXG4gICAgICBjYW5jZWwoaGFuZGxlKSB7XG4gICAgICAgIHdpbmRvdy5jYW5jZWxJZGxlQ2FsbGJhY2sgP1xuICAgICAgICAgIHdpbmRvdy5jYW5jZWxJZGxlQ2FsbGJhY2soaGFuZGxlKSA6XG4gICAgICAgICAgd2luZG93LmNsZWFyVGltZW91dChoYW5kbGUpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBc3luYyBpbnRlcmZhY2UgZm9yIGVucXVldWVpbmcgY2FsbGJhY2tzIHRoYXQgcnVuIGF0IG1pY3JvdGFzayB0aW1pbmcuXG4gICAgICpcbiAgICAgKiBOb3RlIHRoYXQgbWljcm90YXNrIHRpbWluZyBpcyBhY2hpZXZlZCB2aWEgYSBzaW5nbGUgYE11dGF0aW9uT2JzZXJ2ZXJgLFxuICAgICAqIGFuZCB0aHVzIGNhbGxiYWNrcyBlbnF1ZXVlZCB3aXRoIHRoaXMgQVBJIHdpbGwgYWxsIHJ1biBpbiBhIHNpbmdsZVxuICAgICAqIGJhdGNoLCBhbmQgbm90IGludGVybGVhdmVkIHdpdGggb3RoZXIgbWljcm90YXNrcyBzdWNoIGFzIHByb21pc2VzLlxuICAgICAqIFByb21pc2VzIGFyZSBhdm9pZGVkIGFzIGFuIGltcGxlbWVudGF0aW9uIGNob2ljZSBmb3IgdGhlIHRpbWUgYmVpbmdcbiAgICAgKiBkdWUgdG8gU2FmYXJpIGJ1Z3MgdGhhdCBjYXVzZSBQcm9taXNlcyB0byBsYWNrIG1pY3JvdGFzayBndWFyYW50ZWVzLlxuICAgICAqXG4gICAgICogQG5hbWVzcGFjZVxuICAgICAqIEBtZW1iZXJvZiBQb2x5bWVyLkFzeW5jXG4gICAgICogQHN1bW1hcnkgQXN5bmMgaW50ZXJmYWNlIGZvciBlbnF1ZXVlaW5nIGNhbGxiYWNrcyB0aGF0IHJ1biBhdCBtaWNyb3Rhc2tcbiAgICAgKiAgIHRpbWluZy5cbiAgICAgKi9cbiAgICBtaWNyb1Rhc2s6IHtcblxuICAgICAgLyoqXG4gICAgICAgKiBFbnF1ZXVlcyBhIGZ1bmN0aW9uIGNhbGxlZCBhdCBtaWNyb3Rhc2sgdGltaW5nLlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJvZiBQb2x5bWVyLkFzeW5jLm1pY3JvVGFza1xuICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgdG8gcnVuXG4gICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IEhhbmRsZSB1c2VkIGZvciBjYW5jZWxpbmcgdGFza1xuICAgICAgICovXG4gICAgICBydW4oY2FsbGJhY2spIHtcbiAgICAgICAgbWljcm90YXNrTm9kZS50ZXh0Q29udGVudCA9IG1pY3JvdGFza05vZGVDb250ZW50Kys7XG4gICAgICAgIG1pY3JvdGFza0NhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgcmV0dXJuIG1pY3JvdGFza0N1cnJIYW5kbGUrKztcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogQ2FuY2VscyBhIHByZXZpb3VzbHkgZW5xdWV1ZWQgYG1pY3JvVGFza2AgY2FsbGJhY2suXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlcm9mIFBvbHltZXIuQXN5bmMubWljcm9UYXNrXG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0gaGFuZGxlIEhhbmRsZSByZXR1cm5lZCBmcm9tIGBydW5gIG9mIGNhbGxiYWNrIHRvIGNhbmNlbFxuICAgICAgICovXG4gICAgICBjYW5jZWwoaGFuZGxlKSB7XG4gICAgICAgIGNvbnN0IGlkeCA9IGhhbmRsZSAtIG1pY3JvdGFza0xhc3RIYW5kbGU7XG4gICAgICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgICAgIGlmICghbWljcm90YXNrQ2FsbGJhY2tzW2lkeF0pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBhc3luYyBoYW5kbGU6ICcgKyBoYW5kbGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtaWNyb3Rhc2tDYWxsYmFja3NbaWR4XSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgIH1cbiAgfTtcblxufSkoKTtcbjwvc2NyaXB0PlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi91dGlscy9hc3luYy5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuXG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vdXRpbHMvbWl4aW4uaHRtbFwiPlxuXG48c2NyaXB0PlxuKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLy8gQ29tbW9uIGltcGxlbWVudGF0aW9uIGZvciBtaXhpbiAmIGJlaGF2aW9yXG4gIGZ1bmN0aW9uIG11dGFibGVQcm9wZXJ0eUNoYW5nZShpbnN0LCBwcm9wZXJ0eSwgdmFsdWUsIG9sZCwgbXV0YWJsZURhdGEpIHtcbiAgICBsZXQgaXNPYmplY3Q7XG4gICAgaWYgKG11dGFibGVEYXRhKSB7XG4gICAgICBpc09iamVjdCA9ICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsKTtcbiAgICAgIC8vIFB1bGwgYG9sZGAgZm9yIE9iamVjdHMgZnJvbSB0ZW1wIGNhY2hlLCBidXQgdHJlYXQgYG51bGxgIGFzIGEgcHJpbWl0aXZlXG4gICAgICBpZiAoaXNPYmplY3QpIHtcbiAgICAgICAgb2xkID0gaW5zdC5fX2RhdGFUZW1wW3Byb3BlcnR5XTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gU3RyaWN0IGVxdWFsaXR5IGNoZWNrLCBidXQgcmV0dXJuIGZhbHNlIGZvciBOYU49PT1OYU5cbiAgICBsZXQgc2hvdWxkQ2hhbmdlID0gKG9sZCAhPT0gdmFsdWUgJiYgKG9sZCA9PT0gb2xkIHx8IHZhbHVlID09PSB2YWx1ZSkpO1xuICAgIC8vIE9iamVjdHMgYXJlIHN0b3JlZCBpbiB0ZW1wb3JhcnkgY2FjaGUgKGNsZWFyZWQgYXQgZW5kIG9mXG4gICAgLy8gdHVybiksIHdoaWNoIGlzIHVzZWQgZm9yIGRpcnR5LWNoZWNraW5nXG4gICAgaWYgKGlzT2JqZWN0ICYmIHNob3VsZENoYW5nZSkge1xuICAgICAgaW5zdC5fX2RhdGFUZW1wW3Byb3BlcnR5XSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gc2hvdWxkQ2hhbmdlO1xuICB9XG5cbiAgLyoqXG4gICAqIEVsZW1lbnQgY2xhc3MgbWl4aW4gdG8gc2tpcCBzdHJpY3QgZGlydHktY2hlY2tpbmcgZm9yIG9iamVjdHMgYW5kIGFycmF5c1xuICAgKiAoYWx3YXlzIGNvbnNpZGVyIHRoZW0gdG8gYmUgXCJkaXJ0eVwiKSwgZm9yIHVzZSBvbiBlbGVtZW50cyB1dGlsaXppbmdcbiAgICogYFBvbHltZXIuUHJvcGVydHlFZmZlY3RzYFxuICAgKlxuICAgKiBCeSBkZWZhdWx0LCBgUG9seW1lci5Qcm9wZXJ0eUVmZmVjdHNgIHBlcmZvcm1zIHN0cmljdCBkaXJ0eSBjaGVja2luZyBvblxuICAgKiBvYmplY3RzLCB3aGljaCBtZWFucyB0aGF0IGFueSBkZWVwIG1vZGlmaWNhdGlvbnMgdG8gYW4gb2JqZWN0IG9yIGFycmF5IHdpbGxcbiAgICogbm90IGJlIHByb3BhZ2F0ZWQgdW5sZXNzIFwiaW1tdXRhYmxlXCIgZGF0YSBwYXR0ZXJucyBhcmUgdXNlZCAoaS5lLiBhbGwgb2JqZWN0XG4gICAqIHJlZmVyZW5jZXMgZnJvbSB0aGUgcm9vdCB0byB0aGUgbXV0YXRpb24gd2VyZSBjaGFuZ2VkKS5cbiAgICpcbiAgICogUG9seW1lciBhbHNvIHByb3ZpZGVzIGEgcHJvcHJpZXRhcnkgZGF0YSBtdXRhdGlvbiBhbmQgcGF0aCBub3RpZmljYXRpb24gQVBJXG4gICAqIChlLmcuIGBub3RpZnlQYXRoYCwgYHNldGAsIGFuZCBhcnJheSBtdXRhdGlvbiBBUEkncykgdGhhdCBhbGxvdyBlZmZpY2llbnRcbiAgICogbXV0YXRpb24gYW5kIG5vdGlmaWNhdGlvbiBvZiBkZWVwIGNoYW5nZXMgaW4gYW4gb2JqZWN0IGdyYXBoIHRvIGFsbCBlbGVtZW50c1xuICAgKiBib3VuZCB0byB0aGUgc2FtZSBvYmplY3QgZ3JhcGguXG4gICAqXG4gICAqIEluIGNhc2VzIHdoZXJlIG5laXRoZXIgaW1tdXRhYmxlIHBhdHRlcm5zIG5vciB0aGUgZGF0YSBtdXRhdGlvbiBBUEkgY2FuIGJlXG4gICAqIHVzZWQsIGFwcGx5aW5nIHRoaXMgbWl4aW4gd2lsbCBjYXVzZSBQb2x5bWVyIHRvIHNraXAgZGlydHkgY2hlY2tpbmcgZm9yXG4gICAqIG9iamVjdHMgYW5kIGFycmF5cyAoYWx3YXlzIGNvbnNpZGVyIHRoZW0gdG8gYmUgXCJkaXJ0eVwiKS4gIFRoaXMgYWxsb3dzIGFcbiAgICogdXNlciB0byBtYWtlIGEgZGVlcCBtb2RpZmljYXRpb24gdG8gYSBib3VuZCBvYmplY3QgZ3JhcGgsIGFuZCB0aGVuIGVpdGhlclxuICAgKiBzaW1wbHkgcmUtc2V0IHRoZSBvYmplY3QgKGUuZy4gYHRoaXMuaXRlbXMgPSB0aGlzLml0ZW1zYCkgb3IgY2FsbCBgbm90aWZ5UGF0aGBcbiAgICogKGUuZy4gYHRoaXMubm90aWZ5UGF0aCgnaXRlbXMnKWApIHRvIHVwZGF0ZSB0aGUgdHJlZS4gIE5vdGUgdGhhdCBhbGxcbiAgICogZWxlbWVudHMgdGhhdCB3aXNoIHRvIGJlIHVwZGF0ZWQgYmFzZWQgb24gZGVlcCBtdXRhdGlvbnMgbXVzdCBhcHBseSB0aGlzXG4gICAqIG1peGluIG9yIG90aGVyd2lzZSBza2lwIHN0cmljdCBkaXJ0eSBjaGVja2luZyBmb3Igb2JqZWN0cy9hcnJheXMuXG4gICAqXG4gICAqIEluIG9yZGVyIHRvIG1ha2UgdGhlIGRpcnR5IGNoZWNrIHN0cmF0ZWd5IGNvbmZpZ3VyYWJsZSwgc2VlXG4gICAqIGBQb2x5bWVyLk9wdGlvbmFsTXV0YWJsZURhdGFgLlxuICAgKlxuICAgKiBOb3RlLCB0aGUgcGVyZm9ybWFuY2UgY2hhcmFjdGVyaXN0aWNzIG9mIHByb3BhZ2F0aW5nIGxhcmdlIG9iamVjdCBncmFwaHNcbiAgICogd2lsbCBiZSB3b3JzZSBhcyBvcHBvc2VkIHRvIHVzaW5nIHN0cmljdCBkaXJ0eSBjaGVja2luZyB3aXRoIGltbXV0YWJsZVxuICAgKiBwYXR0ZXJucyBvciBQb2x5bWVyJ3MgcGF0aCBub3RpZmljYXRpb24gQVBJLlxuICAgKlxuICAgKiBAbWl4aW5GdW5jdGlvblxuICAgKiBAcG9seW1lclxuICAgKiBAbWVtYmVyb2YgUG9seW1lclxuICAgKiBAc3VtbWFyeSBFbGVtZW50IGNsYXNzIG1peGluIHRvIHNraXAgc3RyaWN0IGRpcnR5LWNoZWNraW5nIGZvciBvYmplY3RzXG4gICAqICAgYW5kIGFycmF5c1xuICAgKi9cbiAgUG9seW1lci5NdXRhYmxlRGF0YSA9IFBvbHltZXIuZGVkdXBpbmdNaXhpbihzdXBlckNsYXNzID0+IHtcblxuICAgIC8qKlxuICAgICAqIEBwb2x5bWVyXG4gICAgICogQG1peGluQ2xhc3NcbiAgICAgKiBAaW1wbGVtZW50cyB7UG9seW1lcl9NdXRhYmxlRGF0YX1cbiAgICAgKi9cbiAgICBjbGFzcyBNdXRhYmxlRGF0YSBleHRlbmRzIHN1cGVyQ2xhc3Mge1xuICAgICAgLyoqXG4gICAgICAgKiBPdmVycmlkZXMgYFBvbHltZXIuUHJvcGVydHlFZmZlY3RzYCB0byBwcm92aWRlIG9wdGlvbiBmb3Igc2tpcHBpbmdcbiAgICAgICAqIHN0cmljdCBlcXVhbGl0eSBjaGVja2luZyBmb3IgT2JqZWN0cyBhbmQgQXJyYXlzLlxuICAgICAgICpcbiAgICAgICAqIFRoaXMgbWV0aG9kIHB1bGxzIHRoZSB2YWx1ZSB0byBkaXJ0eSBjaGVjayBhZ2FpbnN0IGZyb20gdGhlIGBfX2RhdGFUZW1wYFxuICAgICAgICogY2FjaGUgKHJhdGhlciB0aGFuIHRoZSBub3JtYWwgYF9fZGF0YWAgY2FjaGUpIGZvciBPYmplY3RzLiAgU2luY2UgdGhlIHRlbXBcbiAgICAgICAqIGNhY2hlIGlzIGNsZWFyZWQgYXQgdGhlIGVuZCBvZiBhIHR1cm4sIHRoaXMgaW1wbGVtZW50YXRpb24gYWxsb3dzXG4gICAgICAgKiBzaWRlLWVmZmVjdHMgb2YgZGVlcCBvYmplY3QgY2hhbmdlcyB0byBiZSBwcm9jZXNzZWQgYnkgcmUtc2V0dGluZyB0aGVcbiAgICAgICAqIHNhbWUgb2JqZWN0ICh1c2luZyB0aGUgdGVtcCBjYWNoZSBhcyBhbiBpbi10dXJuIGJhY2tzdG9wIHRvIHByZXZlbnRcbiAgICAgICAqIGN5Y2xlcyBkdWUgdG8gMi13YXkgbm90aWZpY2F0aW9uKS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgbmFtZVxuICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBOZXcgcHJvcGVydHkgdmFsdWVcbiAgICAgICAqIEBwYXJhbSB7Kn0gb2xkIFByZXZpb3VzIHByb3BlcnR5IHZhbHVlXG4gICAgICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBwcm9wZXJ0eSBzaG91bGQgYmUgY29uc2lkZXJlZCBhIGNoYW5nZVxuICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICovXG4gICAgICBfc2hvdWxkUHJvcGVydHlDaGFuZ2UocHJvcGVydHksIHZhbHVlLCBvbGQpIHtcbiAgICAgICAgcmV0dXJuIG11dGFibGVQcm9wZXJ0eUNoYW5nZSh0aGlzLCBwcm9wZXJ0eSwgdmFsdWUsIG9sZCwgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICB9XG4gICAgLyoqIEB0eXBlIHtib29sZWFufSAqL1xuICAgIE11dGFibGVEYXRhLnByb3RvdHlwZS5tdXRhYmxlRGF0YSA9IGZhbHNlO1xuXG4gICAgcmV0dXJuIE11dGFibGVEYXRhO1xuXG4gIH0pO1xuXG5cbiAgLyoqXG4gICAqIEVsZW1lbnQgY2xhc3MgbWl4aW4gdG8gYWRkIHRoZSBvcHRpb25hbCBhYmlsaXR5IHRvIHNraXAgc3RyaWN0XG4gICAqIGRpcnR5LWNoZWNraW5nIGZvciBvYmplY3RzIGFuZCBhcnJheXMgKGFsd2F5cyBjb25zaWRlciB0aGVtIHRvIGJlXG4gICAqIFwiZGlydHlcIikgYnkgc2V0dGluZyBhIGBtdXRhYmxlLWRhdGFgIGF0dHJpYnV0ZSBvbiBhbiBlbGVtZW50IGluc3RhbmNlLlxuICAgKlxuICAgKiBCeSBkZWZhdWx0LCBgUG9seW1lci5Qcm9wZXJ0eUVmZmVjdHNgIHBlcmZvcm1zIHN0cmljdCBkaXJ0eSBjaGVja2luZyBvblxuICAgKiBvYmplY3RzLCB3aGljaCBtZWFucyB0aGF0IGFueSBkZWVwIG1vZGlmaWNhdGlvbnMgdG8gYW4gb2JqZWN0IG9yIGFycmF5IHdpbGxcbiAgICogbm90IGJlIHByb3BhZ2F0ZWQgdW5sZXNzIFwiaW1tdXRhYmxlXCIgZGF0YSBwYXR0ZXJucyBhcmUgdXNlZCAoaS5lLiBhbGwgb2JqZWN0XG4gICAqIHJlZmVyZW5jZXMgZnJvbSB0aGUgcm9vdCB0byB0aGUgbXV0YXRpb24gd2VyZSBjaGFuZ2VkKS5cbiAgICpcbiAgICogUG9seW1lciBhbHNvIHByb3ZpZGVzIGEgcHJvcHJpZXRhcnkgZGF0YSBtdXRhdGlvbiBhbmQgcGF0aCBub3RpZmljYXRpb24gQVBJXG4gICAqIChlLmcuIGBub3RpZnlQYXRoYCwgYHNldGAsIGFuZCBhcnJheSBtdXRhdGlvbiBBUEkncykgdGhhdCBhbGxvdyBlZmZpY2llbnRcbiAgICogbXV0YXRpb24gYW5kIG5vdGlmaWNhdGlvbiBvZiBkZWVwIGNoYW5nZXMgaW4gYW4gb2JqZWN0IGdyYXBoIHRvIGFsbCBlbGVtZW50c1xuICAgKiBib3VuZCB0byB0aGUgc2FtZSBvYmplY3QgZ3JhcGguXG4gICAqXG4gICAqIEluIGNhc2VzIHdoZXJlIG5laXRoZXIgaW1tdXRhYmxlIHBhdHRlcm5zIG5vciB0aGUgZGF0YSBtdXRhdGlvbiBBUEkgY2FuIGJlXG4gICAqIHVzZWQsIGFwcGx5aW5nIHRoaXMgbWl4aW4gd2lsbCBhbGxvdyBQb2x5bWVyIHRvIHNraXAgZGlydHkgY2hlY2tpbmcgZm9yXG4gICAqIG9iamVjdHMgYW5kIGFycmF5cyAoYWx3YXlzIGNvbnNpZGVyIHRoZW0gdG8gYmUgXCJkaXJ0eVwiKS4gIFRoaXMgYWxsb3dzIGFcbiAgICogdXNlciB0byBtYWtlIGEgZGVlcCBtb2RpZmljYXRpb24gdG8gYSBib3VuZCBvYmplY3QgZ3JhcGgsIGFuZCB0aGVuIGVpdGhlclxuICAgKiBzaW1wbHkgcmUtc2V0IHRoZSBvYmplY3QgKGUuZy4gYHRoaXMuaXRlbXMgPSB0aGlzLml0ZW1zYCkgb3IgY2FsbCBgbm90aWZ5UGF0aGBcbiAgICogKGUuZy4gYHRoaXMubm90aWZ5UGF0aCgnaXRlbXMnKWApIHRvIHVwZGF0ZSB0aGUgdHJlZS4gIE5vdGUgdGhhdCBhbGxcbiAgICogZWxlbWVudHMgdGhhdCB3aXNoIHRvIGJlIHVwZGF0ZWQgYmFzZWQgb24gZGVlcCBtdXRhdGlvbnMgbXVzdCBhcHBseSB0aGlzXG4gICAqIG1peGluIG9yIG90aGVyd2lzZSBza2lwIHN0cmljdCBkaXJ0eSBjaGVja2luZyBmb3Igb2JqZWN0cy9hcnJheXMuXG4gICAqXG4gICAqIFdoaWxlIHRoaXMgbWl4aW4gYWRkcyB0aGUgYWJpbGl0eSB0byBmb3JnbyBPYmplY3QvQXJyYXkgZGlydHkgY2hlY2tpbmcsXG4gICAqIHRoZSBgbXV0YWJsZURhdGFgIGZsYWcgZGVmYXVsdHMgdG8gZmFsc2UgYW5kIG11c3QgYmUgc2V0IG9uIHRoZSBpbnN0YW5jZS5cbiAgICpcbiAgICogTm90ZSwgdGhlIHBlcmZvcm1hbmNlIGNoYXJhY3RlcmlzdGljcyBvZiBwcm9wYWdhdGluZyBsYXJnZSBvYmplY3QgZ3JhcGhzXG4gICAqIHdpbGwgYmUgd29yc2UgYnkgcmVseWluZyBvbiBgbXV0YWJsZURhdGE6IHRydWVgIGFzIG9wcG9zZWQgdG8gdXNpbmdcbiAgICogc3RyaWN0IGRpcnR5IGNoZWNraW5nIHdpdGggaW1tdXRhYmxlIHBhdHRlcm5zIG9yIFBvbHltZXIncyBwYXRoIG5vdGlmaWNhdGlvblxuICAgKiBBUEkuXG4gICAqXG4gICAqIEBtaXhpbkZ1bmN0aW9uXG4gICAqIEBwb2x5bWVyXG4gICAqIEBtZW1iZXJvZiBQb2x5bWVyXG4gICAqIEBzdW1tYXJ5IEVsZW1lbnQgY2xhc3MgbWl4aW4gdG8gb3B0aW9uYWxseSBza2lwIHN0cmljdCBkaXJ0eS1jaGVja2luZ1xuICAgKiAgIGZvciBvYmplY3RzIGFuZCBhcnJheXNcbiAgICovXG4gIFBvbHltZXIuT3B0aW9uYWxNdXRhYmxlRGF0YSA9IFBvbHltZXIuZGVkdXBpbmdNaXhpbihzdXBlckNsYXNzID0+IHtcblxuICAgIC8qKlxuICAgICAqIEBtaXhpbkNsYXNzXG4gICAgICogQHBvbHltZXJcbiAgICAgKiBAaW1wbGVtZW50cyB7UG9seW1lcl9PcHRpb25hbE11dGFibGVEYXRhfVxuICAgICAqL1xuICAgIGNsYXNzIE9wdGlvbmFsTXV0YWJsZURhdGEgZXh0ZW5kcyBzdXBlckNsYXNzIHtcblxuICAgICAgc3RhdGljIGdldCBwcm9wZXJ0aWVzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIEluc3RhbmNlLWxldmVsIGZsYWcgZm9yIGNvbmZpZ3VyaW5nIHRoZSBkaXJ0eS1jaGVja2luZyBzdHJhdGVneVxuICAgICAgICAgICAqIGZvciB0aGlzIGVsZW1lbnQuICBXaGVuIHRydWUsIE9iamVjdHMgYW5kIEFycmF5cyB3aWxsIHNraXAgZGlydHlcbiAgICAgICAgICAgKiBjaGVja2luZywgb3RoZXJ3aXNlIHN0cmljdCBlcXVhbGl0eSBjaGVja2luZyB3aWxsIGJlIHVzZWQuXG4gICAgICAgICAgICovXG4gICAgICAgICAgbXV0YWJsZURhdGE6IEJvb2xlYW5cbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBPdmVycmlkZXMgYFBvbHltZXIuUHJvcGVydHlFZmZlY3RzYCB0byBwcm92aWRlIG9wdGlvbiBmb3Igc2tpcHBpbmdcbiAgICAgICAqIHN0cmljdCBlcXVhbGl0eSBjaGVja2luZyBmb3IgT2JqZWN0cyBhbmQgQXJyYXlzLlxuICAgICAgICpcbiAgICAgICAqIFdoZW4gYHRoaXMubXV0YWJsZURhdGFgIGlzIHRydWUgb24gdGhpcyBpbnN0YW5jZSwgdGhpcyBtZXRob2RcbiAgICAgICAqIHB1bGxzIHRoZSB2YWx1ZSB0byBkaXJ0eSBjaGVjayBhZ2FpbnN0IGZyb20gdGhlIGBfX2RhdGFUZW1wYCBjYWNoZVxuICAgICAgICogKHJhdGhlciB0aGFuIHRoZSBub3JtYWwgYF9fZGF0YWAgY2FjaGUpIGZvciBPYmplY3RzLiAgU2luY2UgdGhlIHRlbXBcbiAgICAgICAqIGNhY2hlIGlzIGNsZWFyZWQgYXQgdGhlIGVuZCBvZiBhIHR1cm4sIHRoaXMgaW1wbGVtZW50YXRpb24gYWxsb3dzXG4gICAgICAgKiBzaWRlLWVmZmVjdHMgb2YgZGVlcCBvYmplY3QgY2hhbmdlcyB0byBiZSBwcm9jZXNzZWQgYnkgcmUtc2V0dGluZyB0aGVcbiAgICAgICAqIHNhbWUgb2JqZWN0ICh1c2luZyB0aGUgdGVtcCBjYWNoZSBhcyBhbiBpbi10dXJuIGJhY2tzdG9wIHRvIHByZXZlbnRcbiAgICAgICAqIGN5Y2xlcyBkdWUgdG8gMi13YXkgbm90aWZpY2F0aW9uKS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgbmFtZVxuICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBOZXcgcHJvcGVydHkgdmFsdWVcbiAgICAgICAqIEBwYXJhbSB7Kn0gb2xkIFByZXZpb3VzIHByb3BlcnR5IHZhbHVlXG4gICAgICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBwcm9wZXJ0eSBzaG91bGQgYmUgY29uc2lkZXJlZCBhIGNoYW5nZVxuICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICovXG4gICAgICBfc2hvdWxkUHJvcGVydHlDaGFuZ2UocHJvcGVydHksIHZhbHVlLCBvbGQpIHtcbiAgICAgICAgcmV0dXJuIG11dGFibGVQcm9wZXJ0eUNoYW5nZSh0aGlzLCBwcm9wZXJ0eSwgdmFsdWUsIG9sZCwgdGhpcy5tdXRhYmxlRGF0YSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIE9wdGlvbmFsTXV0YWJsZURhdGE7XG5cbiAgfSk7XG5cbiAgLy8gRXhwb3J0IGZvciB1c2UgYnkgbGVnYWN5IGJlaGF2aW9yXG4gIFBvbHltZXIuTXV0YWJsZURhdGEuX211dGFibGVQcm9wZXJ0eUNoYW5nZSA9IG11dGFibGVQcm9wZXJ0eUNoYW5nZTtcblxufSkoKTtcbjwvc2NyaXB0PlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi9taXhpbnMvbXV0YWJsZS1kYXRhLmh0bWwiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiYm9vdC5odG1sXCI+XG48c2NyaXB0PlxuKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgY29uc3QgY2FzZU1hcCA9IHt9O1xuICBjb25zdCBEQVNIX1RPX0NBTUVMID0gLy1bYS16XS9nO1xuICBjb25zdCBDQU1FTF9UT19EQVNIID0gLyhbQS1aXSkvZztcblxuICAvKipcbiAgICogTW9kdWxlIHdpdGggdXRpbGl0aWVzIGZvciBjb252ZXJ0aW5nIGJldHdlZW4gXCJkYXNoLWNhc2VcIiBhbmQgXCJjYW1lbENhc2VcIlxuICAgKiBpZGVudGlmaWVycy5cbiAgICpcbiAgICogQG5hbWVzcGFjZVxuICAgKiBAbWVtYmVyb2YgUG9seW1lclxuICAgKiBAc3VtbWFyeSBNb2R1bGUgdGhhdCBwcm92aWRlcyB1dGlsaXRpZXMgZm9yIGNvbnZlcnRpbmcgYmV0d2VlbiBcImRhc2gtY2FzZVwiXG4gICAqICAgYW5kIFwiY2FtZWxDYXNlXCIuXG4gICAqL1xuICBjb25zdCBDYXNlTWFwID0ge1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgXCJkYXNoLWNhc2VcIiBpZGVudGlmaWVyIChlLmcuIGBmb28tYmFyLWJhemApIHRvIFwiY2FtZWxDYXNlXCJcbiAgICAgKiAoZS5nLiBgZm9vQmFyQmF6YCkuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgUG9seW1lci5DYXNlTWFwXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRhc2ggRGFzaC1jYXNlIGlkZW50aWZpZXJcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IENhbWVsLWNhc2UgcmVwcmVzZW50YXRpb24gb2YgdGhlIGlkZW50aWZpZXJcbiAgICAgKi9cbiAgICBkYXNoVG9DYW1lbENhc2UoZGFzaCkge1xuICAgICAgcmV0dXJuIGNhc2VNYXBbZGFzaF0gfHwgKFxuICAgICAgICBjYXNlTWFwW2Rhc2hdID0gZGFzaC5pbmRleE9mKCctJykgPCAwID8gZGFzaCA6IGRhc2gucmVwbGFjZShEQVNIX1RPX0NBTUVMLFxuICAgICAgICAgIChtKSA9PiBtWzFdLnRvVXBwZXJDYXNlKClcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgXCJjYW1lbENhc2VcIiBpZGVudGlmaWVyIChlLmcuIGBmb29CYXJCYXpgKSB0byBcImRhc2gtY2FzZVwiXG4gICAgICogKGUuZy4gYGZvby1iYXItYmF6YCkuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgUG9seW1lci5DYXNlTWFwXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNhbWVsIENhbWVsLWNhc2UgaWRlbnRpZmllclxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gRGFzaC1jYXNlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBpZGVudGlmaWVyXG4gICAgICovXG4gICAgY2FtZWxUb0Rhc2hDYXNlKGNhbWVsKSB7XG4gICAgICByZXR1cm4gY2FzZU1hcFtjYW1lbF0gfHwgKFxuICAgICAgICBjYXNlTWFwW2NhbWVsXSA9IGNhbWVsLnJlcGxhY2UoQ0FNRUxfVE9fREFTSCwgJy0kMScpLnRvTG93ZXJDYXNlKClcbiAgICAgICk7XG4gICAgfVxuXG4gIH07XG5cbiAgUG9seW1lci5DYXNlTWFwID0gQ2FzZU1hcDtcbn0pKCk7XG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvdXRpbHMvY2FzZS1tYXAuaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cblxuXG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vdXRpbHMvYm9vdC5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vdXRpbHMvbWl4aW4uaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3V0aWxzL3BhdGguaHRtbFwiPlxuPCEtLSBmb3Igbm90aWZ5LCByZWZsZWN0IC0tPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3V0aWxzL2Nhc2UtbWFwLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCJwcm9wZXJ0eS1hY2Nlc3NvcnMuaHRtbFwiPlxuPCEtLSBmb3IgYW5ub3RhdGVkIGVmZmVjdHMgLS0+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwidGVtcGxhdGUtc3RhbXAuaHRtbFwiPlxuXG5cbjxzY3JpcHQ+XG4oZnVuY3Rpb24oKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8qKiBAY29uc3Qge09iamVjdH0gKi9cbiAgY29uc3QgQ2FzZU1hcCA9IFBvbHltZXIuQ2FzZU1hcDtcblxuICAvLyBNb25vdG9uaWNhbGx5IGluY3JlYXNpbmcgdW5pcXVlIElEIHVzZWQgZm9yIGRlLWR1cGluZyBlZmZlY3RzIHRyaWdnZXJlZFxuICAvLyBmcm9tIG11bHRpcGxlIHByb3BlcnRpZXMgaW4gdGhlIHNhbWUgdHVyblxuICBsZXQgZGVkdXBlSWQgPSAwO1xuXG4gIC8qKlxuICAgKiBQcm9wZXJ0eSBlZmZlY3QgdHlwZXM7IGVmZmVjdHMgYXJlIHN0b3JlZCBvbiB0aGUgcHJvdG90eXBlIHVzaW5nIHRoZXNlIGtleXNcbiAgICogQGVudW0ge3N0cmluZ31cbiAgICovXG4gIGNvbnN0IFRZUEVTID0ge1xuICAgIENPTVBVVEU6ICdfX2NvbXB1dGVFZmZlY3RzJyxcbiAgICBSRUZMRUNUOiAnX19yZWZsZWN0RWZmZWN0cycsXG4gICAgTk9USUZZOiAnX19ub3RpZnlFZmZlY3RzJyxcbiAgICBQUk9QQUdBVEU6ICdfX3Byb3BhZ2F0ZUVmZmVjdHMnLFxuICAgIE9CU0VSVkU6ICdfX29ic2VydmVFZmZlY3RzJyxcbiAgICBSRUFEX09OTFk6ICdfX3JlYWRPbmx5J1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlZGVmIHt7XG4gICAqIG5hbWU6IChzdHJpbmcgfCB1bmRlZmluZWQpLFxuICAgKiBzdHJ1Y3R1cmVkOiAoYm9vbGVhbiB8IHVuZGVmaW5lZCksXG4gICAqIHdpbGRjYXJkOiAoYm9vbGVhbiB8IHVuZGVmaW5lZClcbiAgICogfX1cbiAgICovXG4gIGxldCBEYXRhVHJpZ2dlcjsgLy9lc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cbiAgLyoqXG4gICAqIEB0eXBlZGVmIHt7XG4gICAqIGluZm86ID8sXG4gICAqIHRyaWdnZXI6ICghRGF0YVRyaWdnZXIgfCB1bmRlZmluZWQpLFxuICAgKiBmbjogKCFGdW5jdGlvbiB8IHVuZGVmaW5lZClcbiAgICogfX1cbiAgICovXG4gIGxldCBEYXRhRWZmZWN0OyAvL2VzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblxuICBsZXQgUHJvcGVydHlFZmZlY3RzVHlwZTsgLy9lc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cbiAgLyoqXG4gICAqIEVuc3VyZXMgdGhhdCB0aGUgbW9kZWwgaGFzIGFuIG93bi1wcm9wZXJ0eSBtYXAgb2YgZWZmZWN0cyBmb3IgdGhlIGdpdmVuIHR5cGUuXG4gICAqIFRoZSBtb2RlbCBtYXkgYmUgYSBwcm90b3R5cGUgb3IgYW4gaW5zdGFuY2UuXG4gICAqXG4gICAqIFByb3BlcnR5IGVmZmVjdHMgYXJlIHN0b3JlZCBhcyBhcnJheXMgb2YgZWZmZWN0cyBieSBwcm9wZXJ0eSBpbiBhIG1hcCxcbiAgICogYnkgbmFtZWQgdHlwZSBvbiB0aGUgbW9kZWwuIGUuZy5cbiAgICpcbiAgICogICBfX2NvbXB1dGVFZmZlY3RzOiB7XG4gICAqICAgICBmb286IFsgLi4uIF0sXG4gICAqICAgICBiYXI6IFsgLi4uIF1cbiAgICogICB9XG4gICAqXG4gICAqIElmIHRoZSBtb2RlbCBkb2VzIG5vdCB5ZXQgaGF2ZSBhbiBlZmZlY3QgbWFwIGZvciB0aGUgdHlwZSwgb25lIGlzIGNyZWF0ZWRcbiAgICogYW5kIHJldHVybmVkLiAgSWYgaXQgZG9lcywgYnV0IGl0IGlzIG5vdCBhbiBvd24gcHJvcGVydHkgKGkuZS4gdGhlXG4gICAqIHByb3RvdHlwZSBoYWQgZWZmZWN0cyksIHRoZSB0aGUgbWFwIGlzIGRlZXBseSBjbG9uZWQgYW5kIHRoZSBjb3B5IGlzXG4gICAqIHNldCBvbiB0aGUgbW9kZWwgYW5kIHJldHVybmVkLCByZWFkeSBmb3IgbmV3IGVmZmVjdHMgdG8gYmUgYWRkZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBtb2RlbCBQcm90b3R5cGUgb3IgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgUHJvcGVydHkgZWZmZWN0IHR5cGVcbiAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgb3duLXByb3BlcnR5IG1hcCBvZiBlZmZlY3RzIGZvciB0aGUgZ2l2ZW4gdHlwZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gZW5zdXJlT3duRWZmZWN0TWFwKG1vZGVsLCB0eXBlKSB7XG4gICAgbGV0IGVmZmVjdHMgPSBtb2RlbFt0eXBlXTtcbiAgICBpZiAoIWVmZmVjdHMpIHtcbiAgICAgIGVmZmVjdHMgPSBtb2RlbFt0eXBlXSA9IHt9O1xuICAgIH0gZWxzZSBpZiAoIW1vZGVsLmhhc093blByb3BlcnR5KHR5cGUpKSB7XG4gICAgICBlZmZlY3RzID0gbW9kZWxbdHlwZV0gPSBPYmplY3QuY3JlYXRlKG1vZGVsW3R5cGVdKTtcbiAgICAgIGZvciAobGV0IHAgaW4gZWZmZWN0cykge1xuICAgICAgICBsZXQgcHJvdG9GeCA9IGVmZmVjdHNbcF07XG4gICAgICAgIGxldCBpbnN0RnggPSBlZmZlY3RzW3BdID0gQXJyYXkocHJvdG9GeC5sZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8cHJvdG9GeC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGluc3RGeFtpXSA9IHByb3RvRnhbaV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVmZmVjdHM7XG4gIH1cblxuICAvLyAtLSBlZmZlY3RzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvKipcbiAgICogUnVucyBhbGwgZWZmZWN0cyBvZiBhIGdpdmVuIHR5cGUgZm9yIHRoZSBnaXZlbiBzZXQgb2YgcHJvcGVydHkgY2hhbmdlc1xuICAgKiBvbiBhbiBpbnN0YW5jZS5cbiAgICpcbiAgICogQHBhcmFtIHshUHJvcGVydHlFZmZlY3RzVHlwZX0gaW5zdCBUaGUgaW5zdGFuY2Ugd2l0aCBlZmZlY3RzIHRvIHJ1blxuICAgKiBAcGFyYW0ge09iamVjdH0gZWZmZWN0cyBPYmplY3QgbWFwIG9mIHByb3BlcnR5LXRvLUFycmF5IG9mIGVmZmVjdHNcbiAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzIEJhZyBvZiBjdXJyZW50IHByb3BlcnR5IGNoYW5nZXNcbiAgICogQHBhcmFtIHtPYmplY3Q9fSBvbGRQcm9wcyBCYWcgb2YgcHJldmlvdXMgdmFsdWVzIGZvciBjaGFuZ2VkIHByb3BlcnRpZXNcbiAgICogQHBhcmFtIHtib29sZWFuPX0gaGFzUGF0aHMgVHJ1ZSB3aXRoIGBwcm9wc2AgY29udGFpbnMgb25lIG9yIG1vcmUgcGF0aHNcbiAgICogQHBhcmFtIHsqPX0gZXh0cmFBcmdzIEFkZGl0aW9uYWwgbWV0YWRhdGEgdG8gcGFzcyB0byBlZmZlY3QgZnVuY3Rpb25cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBhbiBlZmZlY3QgcmFuIGZvciB0aGlzIHByb3BlcnR5XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBydW5FZmZlY3RzKGluc3QsIGVmZmVjdHMsIHByb3BzLCBvbGRQcm9wcywgaGFzUGF0aHMsIGV4dHJhQXJncykge1xuICAgIGlmIChlZmZlY3RzKSB7XG4gICAgICBsZXQgcmFuID0gZmFsc2U7XG4gICAgICBsZXQgaWQgPSBkZWR1cGVJZCsrO1xuICAgICAgZm9yIChsZXQgcHJvcCBpbiBwcm9wcykge1xuICAgICAgICBpZiAocnVuRWZmZWN0c0ZvclByb3BlcnR5KGluc3QsIGVmZmVjdHMsIGlkLCBwcm9wLCBwcm9wcywgb2xkUHJvcHMsIGhhc1BhdGhzLCBleHRyYUFyZ3MpKSB7XG4gICAgICAgICAgcmFuID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJhbjtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJ1bnMgYSBsaXN0IG9mIGVmZmVjdHMgZm9yIGEgZ2l2ZW4gcHJvcGVydHkuXG4gICAqXG4gICAqIEBwYXJhbSB7IVByb3BlcnR5RWZmZWN0c1R5cGV9IGluc3QgVGhlIGluc3RhbmNlIHdpdGggZWZmZWN0cyB0byBydW5cbiAgICogQHBhcmFtIHtPYmplY3R9IGVmZmVjdHMgT2JqZWN0IG1hcCBvZiBwcm9wZXJ0eS10by1BcnJheSBvZiBlZmZlY3RzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkZWR1cGVJZCBDb3VudGVyIHVzZWQgZm9yIGRlLWR1cGluZyBlZmZlY3RzXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wIE5hbWUgb2YgY2hhbmdlZCBwcm9wZXJ0eVxuICAgKiBAcGFyYW0geyp9IHByb3BzIENoYW5nZWQgcHJvcGVydGllc1xuICAgKiBAcGFyYW0geyp9IG9sZFByb3BzIE9sZCBwcm9wZXJ0aWVzXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IGhhc1BhdGhzIFRydWUgd2l0aCBgcHJvcHNgIGNvbnRhaW5zIG9uZSBvciBtb3JlIHBhdGhzXG4gICAqIEBwYXJhbSB7Kj19IGV4dHJhQXJncyBBZGRpdGlvbmFsIG1ldGFkYXRhIHRvIHBhc3MgdG8gZWZmZWN0IGZ1bmN0aW9uXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYW4gZWZmZWN0IHJhbiBmb3IgdGhpcyBwcm9wZXJ0eVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gcnVuRWZmZWN0c0ZvclByb3BlcnR5KGluc3QsIGVmZmVjdHMsIGRlZHVwZUlkLCBwcm9wLCBwcm9wcywgb2xkUHJvcHMsIGhhc1BhdGhzLCBleHRyYUFyZ3MpIHtcbiAgICBsZXQgcmFuID0gZmFsc2U7XG4gICAgbGV0IHJvb3RQcm9wZXJ0eSA9IGhhc1BhdGhzID8gUG9seW1lci5QYXRoLnJvb3QocHJvcCkgOiBwcm9wO1xuICAgIGxldCBmeHMgPSBlZmZlY3RzW3Jvb3RQcm9wZXJ0eV07XG4gICAgaWYgKGZ4cykge1xuICAgICAgZm9yIChsZXQgaT0wLCBsPWZ4cy5sZW5ndGgsIGZ4OyAoaTxsKSAmJiAoZng9ZnhzW2ldKTsgaSsrKSB7XG4gICAgICAgIGlmICgoIWZ4LmluZm8gfHwgZnguaW5mby5sYXN0UnVuICE9PSBkZWR1cGVJZCkgJiZcbiAgICAgICAgICAgICghaGFzUGF0aHMgfHwgcGF0aE1hdGNoZXNUcmlnZ2VyKHByb3AsIGZ4LnRyaWdnZXIpKSkge1xuICAgICAgICAgIGlmIChmeC5pbmZvKSB7XG4gICAgICAgICAgICBmeC5pbmZvLmxhc3RSdW4gPSBkZWR1cGVJZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnguZm4oaW5zdCwgcHJvcCwgcHJvcHMsIG9sZFByb3BzLCBmeC5pbmZvLCBoYXNQYXRocywgZXh0cmFBcmdzKTtcbiAgICAgICAgICByYW4gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByYW47XG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIGEgcHJvcGVydHkvcGF0aCB0aGF0IGhhcyBjaGFuZ2VkIG1hdGNoZXMgdGhlIHRyaWdnZXJcbiAgICogY3JpdGVyaWEgZm9yIGFuIGVmZmVjdC4gIEEgdHJpZ2dlciBpcyBhIGRlc2NyaXB0b3Igd2l0aCB0aGUgZm9sbG93aW5nXG4gICAqIHN0cnVjdHVyZSwgd2hpY2ggbWF0Y2hlcyB0aGUgZGVzY3JpcHRvcnMgcmV0dXJuZWQgZnJvbSBgcGFyc2VBcmdgLlxuICAgKiBlLmcuIGZvciBgZm9vLmJhci4qYDpcbiAgICogYGBgXG4gICAqIHRyaWdnZXI6IHtcbiAgICogICBuYW1lOiAnYS5iJyxcbiAgICogICBzdHJ1Y3R1cmVkOiB0cnVlLFxuICAgKiAgIHdpbGRjYXJkOiB0cnVlXG4gICAqIH1cbiAgICogYGBgXG4gICAqIElmIG5vIHRyaWdnZXIgaXMgZ2l2ZW4sIHRoZSBwYXRoIGlzIGRlZW1lZCB0byBtYXRjaC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggUGF0aCBvciBwcm9wZXJ0eSB0aGF0IGNoYW5nZWRcbiAgICogQHBhcmFtIHtEYXRhVHJpZ2dlcn0gdHJpZ2dlciBEZXNjcmlwdG9yXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIHBhdGggbWF0Y2hlZCB0aGUgdHJpZ2dlclxuICAgKi9cbiAgZnVuY3Rpb24gcGF0aE1hdGNoZXNUcmlnZ2VyKHBhdGgsIHRyaWdnZXIpIHtcbiAgICBpZiAodHJpZ2dlcikge1xuICAgICAgbGV0IHRyaWdnZXJQYXRoID0gdHJpZ2dlci5uYW1lO1xuICAgICAgcmV0dXJuICh0cmlnZ2VyUGF0aCA9PSBwYXRoKSB8fFxuICAgICAgICAodHJpZ2dlci5zdHJ1Y3R1cmVkICYmIFBvbHltZXIuUGF0aC5pc0FuY2VzdG9yKHRyaWdnZXJQYXRoLCBwYXRoKSkgfHxcbiAgICAgICAgKHRyaWdnZXIud2lsZGNhcmQgJiYgUG9seW1lci5QYXRoLmlzRGVzY2VuZGFudCh0cmlnZ2VyUGF0aCwgcGF0aCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSW1wbGVtZW50cyB0aGUgXCJvYnNlcnZlclwiIGVmZmVjdC5cbiAgICpcbiAgICogQ2FsbHMgdGhlIG1ldGhvZCB3aXRoIGBpbmZvLm1ldGhvZE5hbWVgIG9uIHRoZSBpbnN0YW5jZSwgcGFzc2luZyB0aGVcbiAgICogbmV3IGFuZCBvbGQgdmFsdWVzLlxuICAgKlxuICAgKiBAcGFyYW0geyFQcm9wZXJ0eUVmZmVjdHNUeXBlfSBpbnN0IFRoZSBpbnN0YW5jZSB0aGUgZWZmZWN0IHdpbGwgYmUgcnVuIG9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBOYW1lIG9mIHByb3BlcnR5XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBCYWcgb2YgY3VycmVudCBwcm9wZXJ0eSBjaGFuZ2VzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvbGRQcm9wcyBCYWcgb2YgcHJldmlvdXMgdmFsdWVzIGZvciBjaGFuZ2VkIHByb3BlcnRpZXNcbiAgICogQHBhcmFtIHs/fSBpbmZvIEVmZmVjdCBtZXRhZGF0YVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gcnVuT2JzZXJ2ZXJFZmZlY3QoaW5zdCwgcHJvcGVydHksIHByb3BzLCBvbGRQcm9wcywgaW5mbykge1xuICAgIGxldCBmbiA9IGluc3RbaW5mby5tZXRob2ROYW1lXTtcbiAgICBsZXQgY2hhbmdlZFByb3AgPSBpbmZvLnByb3BlcnR5O1xuICAgIGlmIChmbikge1xuICAgICAgZm4uY2FsbChpbnN0LCBpbnN0Ll9fZGF0YVtjaGFuZ2VkUHJvcF0sIG9sZFByb3BzW2NoYW5nZWRQcm9wXSk7XG4gICAgfSBlbHNlIGlmICghaW5mby5keW5hbWljRm4pIHtcbiAgICAgIGNvbnNvbGUud2Fybignb2JzZXJ2ZXIgbWV0aG9kIGAnICsgaW5mby5tZXRob2ROYW1lICsgJ2Agbm90IGRlZmluZWQnKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUnVucyBcIm5vdGlmeVwiIGVmZmVjdHMgZm9yIGEgc2V0IG9mIGNoYW5nZWQgcHJvcGVydGllcy5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgZGlmZmVycyBmcm9tIHRoZSBnZW5lcmljIGBydW5FZmZlY3RzYCBtZXRob2QgaW4gdGhhdCBpdFxuICAgKiB3aWxsIGRpc3BhdGNoIHBhdGggbm90aWZpY2F0aW9uIGV2ZW50cyBpbiB0aGUgY2FzZSB0aGF0IHRoZSBwcm9wZXJ0eVxuICAgKiBjaGFuZ2VkIHdhcyBhIHBhdGggYW5kIHRoZSByb290IHByb3BlcnR5IGZvciB0aGF0IHBhdGggZGlkbid0IGhhdmUgYVxuICAgKiBcIm5vdGlmeVwiIGVmZmVjdC4gIFRoaXMgaXMgdG8gbWFpbnRhaW4gMS4wIGJlaGF2aW9yIHRoYXQgZGlkIG5vdCByZXF1aXJlXG4gICAqIGBub3RpZnk6IHRydWVgIHRvIGVuc3VyZSBvYmplY3Qgc3ViLXByb3BlcnR5IG5vdGlmaWNhdGlvbnMgd2VyZVxuICAgKiBzZW50LlxuICAgKlxuICAgKiBAcGFyYW0geyFQcm9wZXJ0eUVmZmVjdHNUeXBlfSBpbnN0IFRoZSBpbnN0YW5jZSB3aXRoIGVmZmVjdHMgdG8gcnVuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBub3RpZnlQcm9wcyBCYWcgb2YgcHJvcGVydGllcyB0byBub3RpZnlcbiAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzIEJhZyBvZiBjdXJyZW50IHByb3BlcnR5IGNoYW5nZXNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9sZFByb3BzIEJhZyBvZiBwcmV2aW91cyB2YWx1ZXMgZm9yIGNoYW5nZWQgcHJvcGVydGllc1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhhc1BhdGhzIFRydWUgd2l0aCBgcHJvcHNgIGNvbnRhaW5zIG9uZSBvciBtb3JlIHBhdGhzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBydW5Ob3RpZnlFZmZlY3RzKGluc3QsIG5vdGlmeVByb3BzLCBwcm9wcywgb2xkUHJvcHMsIGhhc1BhdGhzKSB7XG4gICAgLy8gTm90aWZ5XG4gICAgbGV0IGZ4cyA9IGluc3RbVFlQRVMuTk9USUZZXTtcbiAgICBsZXQgbm90aWZpZWQ7XG4gICAgbGV0IGlkID0gZGVkdXBlSWQrKztcbiAgICAvLyBUcnkgbm9ybWFsIG5vdGlmeSBlZmZlY3RzOyBpZiBub25lLCBmYWxsIGJhY2sgdG8gdHJ5IHBhdGggbm90aWZpY2F0aW9uXG4gICAgZm9yIChsZXQgcHJvcCBpbiBub3RpZnlQcm9wcykge1xuICAgICAgaWYgKG5vdGlmeVByb3BzW3Byb3BdKSB7XG4gICAgICAgIGlmIChmeHMgJiYgcnVuRWZmZWN0c0ZvclByb3BlcnR5KGluc3QsIGZ4cywgaWQsIHByb3AsIHByb3BzLCBvbGRQcm9wcywgaGFzUGF0aHMpKSB7XG4gICAgICAgICAgbm90aWZpZWQgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGhhc1BhdGhzICYmIG5vdGlmeVBhdGgoaW5zdCwgcHJvcCwgcHJvcHMpKSB7XG4gICAgICAgICAgbm90aWZpZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIEZsdXNoIGhvc3QgaWYgd2UgYWN0dWFsbHkgbm90aWZpZWQgYW5kIGhvc3Qgd2FzIGJhdGNoaW5nXG4gICAgLy8gQW5kIHRoZSBob3N0IGhhcyBhbHJlYWR5IGluaXRpYWxpemVkIGNsaWVudHM7IHRoaXMgcHJldmVudHNcbiAgICAvLyBhbiBpc3N1ZSB3aXRoIGEgaG9zdCBvYnNlcnZpbmcgZGF0YSBjaGFuZ2VzIGJlZm9yZSBjbGllbnRzIGFyZSByZWFkeS5cbiAgICBsZXQgaG9zdDtcbiAgICBpZiAobm90aWZpZWQgJiYgKGhvc3QgPSBpbnN0Ll9fZGF0YUhvc3QpICYmIGhvc3QuX2ludmFsaWRhdGVQcm9wZXJ0aWVzKSB7XG4gICAgICBob3N0Ll9pbnZhbGlkYXRlUHJvcGVydGllcygpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNwYXRjaGVzIHtwcm9wZXJ0eX0tY2hhbmdlZCBldmVudHMgd2l0aCBwYXRoIGluZm9ybWF0aW9uIGluIHRoZSBkZXRhaWxcbiAgICogb2JqZWN0IHRvIGluZGljYXRlIGEgc3ViLXBhdGggb2YgdGhlIHByb3BlcnR5IHdhcyBjaGFuZ2VkLlxuICAgKlxuICAgKiBAcGFyYW0geyFQcm9wZXJ0eUVmZmVjdHNUeXBlfSBpbnN0IFRoZSBlbGVtZW50IGZyb20gd2hpY2ggdG8gZmlyZSB0aGUgZXZlbnRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggVGhlIHBhdGggdGhhdCB3YXMgY2hhbmdlZFxuICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgQmFnIG9mIGN1cnJlbnQgcHJvcGVydHkgY2hhbmdlc1xuICAgKiBAcmV0dXJuIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgdGhlIHBhdGggd2FzIG5vdGlmaWVkXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBub3RpZnlQYXRoKGluc3QsIHBhdGgsIHByb3BzKSB7XG4gICAgbGV0IHJvb3RQcm9wZXJ0eSA9IFBvbHltZXIuUGF0aC5yb290KHBhdGgpO1xuICAgIGlmIChyb290UHJvcGVydHkgIT09IHBhdGgpIHtcbiAgICAgIGxldCBldmVudE5hbWUgPSBQb2x5bWVyLkNhc2VNYXAuY2FtZWxUb0Rhc2hDYXNlKHJvb3RQcm9wZXJ0eSkgKyAnLWNoYW5nZWQnO1xuICAgICAgZGlzcGF0Y2hOb3RpZnlFdmVudChpbnN0LCBldmVudE5hbWUsIHByb3BzW3BhdGhdLCBwYXRoKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogRGlzcGF0Y2hlcyB7cHJvcGVydHl9LWNoYW5nZWQgZXZlbnRzIHRvIGluZGljYXRlIGEgcHJvcGVydHkgKG9yIHBhdGgpXG4gICAqIGNoYW5nZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7IVByb3BlcnR5RWZmZWN0c1R5cGV9IGluc3QgVGhlIGVsZW1lbnQgZnJvbSB3aGljaCB0byBmaXJlIHRoZSBldmVudFxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byBzZW5kICgne3Byb3BlcnR5fS1jaGFuZ2VkJylcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgb2YgdGhlIGNoYW5nZWQgcHJvcGVydHlcbiAgICogQHBhcmFtIHtzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkfSBwYXRoIElmIGEgc3ViLXBhdGggb2YgdGhpcyBwcm9wZXJ0eSBjaGFuZ2VkLCB0aGUgcGF0aFxuICAgKiAgIHRoYXQgY2hhbmdlZCAob3B0aW9uYWwpLlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAc3VwcHJlc3Mge2ludmFsaWRDYXN0c31cbiAgICovXG4gIGZ1bmN0aW9uIGRpc3BhdGNoTm90aWZ5RXZlbnQoaW5zdCwgZXZlbnROYW1lLCB2YWx1ZSwgcGF0aCkge1xuICAgIGxldCBkZXRhaWwgPSB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBxdWV1ZVByb3BlcnR5OiB0cnVlXG4gICAgfTtcbiAgICBpZiAocGF0aCkge1xuICAgICAgZGV0YWlsLnBhdGggPSBwYXRoO1xuICAgIH1cbiAgICAvKiogQHR5cGUgeyFIVE1MRWxlbWVudH0gKi8oaW5zdCkuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoZXZlbnROYW1lLCB7IGRldGFpbCB9KSk7XG4gIH1cblxuICAvKipcbiAgICogSW1wbGVtZW50cyB0aGUgXCJub3RpZnlcIiBlZmZlY3QuXG4gICAqXG4gICAqIERpc3BhdGNoZXMgYSBub24tYnViYmxpbmcgZXZlbnQgbmFtZWQgYGluZm8uZXZlbnROYW1lYCBvbiB0aGUgaW5zdGFuY2VcbiAgICogd2l0aCBhIGRldGFpbCBvYmplY3QgY29udGFpbmluZyB0aGUgbmV3IGB2YWx1ZWAuXG4gICAqXG4gICAqIEBwYXJhbSB7IVByb3BlcnR5RWZmZWN0c1R5cGV9IGluc3QgVGhlIGluc3RhbmNlIHRoZSBlZmZlY3Qgd2lsbCBiZSBydW4gb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IE5hbWUgb2YgcHJvcGVydHlcbiAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzIEJhZyBvZiBjdXJyZW50IHByb3BlcnR5IGNoYW5nZXNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9sZFByb3BzIEJhZyBvZiBwcmV2aW91cyB2YWx1ZXMgZm9yIGNoYW5nZWQgcHJvcGVydGllc1xuICAgKiBAcGFyYW0gez99IGluZm8gRWZmZWN0IG1ldGFkYXRhXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaGFzUGF0aHMgVHJ1ZSB3aXRoIGBwcm9wc2AgY29udGFpbnMgb25lIG9yIG1vcmUgcGF0aHNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIHJ1bk5vdGlmeUVmZmVjdChpbnN0LCBwcm9wZXJ0eSwgcHJvcHMsIG9sZFByb3BzLCBpbmZvLCBoYXNQYXRocykge1xuICAgIGxldCByb290UHJvcGVydHkgPSBoYXNQYXRocyA/IFBvbHltZXIuUGF0aC5yb290KHByb3BlcnR5KSA6IHByb3BlcnR5O1xuICAgIGxldCBwYXRoID0gcm9vdFByb3BlcnR5ICE9IHByb3BlcnR5ID8gcHJvcGVydHkgOiBudWxsO1xuICAgIGxldCB2YWx1ZSA9IHBhdGggPyBQb2x5bWVyLlBhdGguZ2V0KGluc3QsIHBhdGgpIDogaW5zdC5fX2RhdGFbcHJvcGVydHldO1xuICAgIGlmIChwYXRoICYmIHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhbHVlID0gcHJvcHNbcHJvcGVydHldOyAgLy8gc3BlY2lmaWNhbGx5IGZvciAuc3BsaWNlc1xuICAgIH1cbiAgICBkaXNwYXRjaE5vdGlmeUV2ZW50KGluc3QsIGluZm8uZXZlbnROYW1lLCB2YWx1ZSwgcGF0aCk7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlciBmdW5jdGlvbiBmb3IgMi13YXkgbm90aWZpY2F0aW9uIGV2ZW50cy4gUmVjZWl2ZXMgY29udGV4dFxuICAgKiBpbmZvcm1hdGlvbiBjYXB0dXJlZCBpbiB0aGUgYGFkZE5vdGlmeUxpc3RlbmVyYCBjbG9zdXJlIGZyb20gdGhlXG4gICAqIGBfX25vdGlmeUxpc3RlbmVyc2AgbWV0YWRhdGEuXG4gICAqXG4gICAqIFNldHMgdGhlIHZhbHVlIG9mIHRoZSBub3RpZmllZCBwcm9wZXJ0eSB0byB0aGUgaG9zdCBwcm9wZXJ0eSBvciBwYXRoLiAgSWZcbiAgICogdGhlIGV2ZW50IGNvbnRhaW5lZCBwYXRoIGluZm9ybWF0aW9uLCB0cmFuc2xhdGUgdGhhdCBwYXRoIHRvIHRoZSBob3N0XG4gICAqIHNjb3BlJ3MgbmFtZSBmb3IgdGhhdCBwYXRoIGZpcnN0LlxuICAgKlxuICAgKiBAcGFyYW0ge0N1c3RvbUV2ZW50fSBldmVudCBOb3RpZmljYXRpb24gZXZlbnQgKGUuZy4gJzxwcm9wZXJ0eT4tY2hhbmdlZCcpXG4gICAqIEBwYXJhbSB7IVByb3BlcnR5RWZmZWN0c1R5cGV9IGluc3QgSG9zdCBlbGVtZW50IGluc3RhbmNlIGhhbmRsaW5nIHRoZSBub3RpZmljYXRpb24gZXZlbnRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZyb21Qcm9wIENoaWxkIGVsZW1lbnQgcHJvcGVydHkgdGhhdCB3YXMgYm91bmRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRvUGF0aCBIb3N0IHByb3BlcnR5L3BhdGggdGhhdCB3YXMgYm91bmRcbiAgICogQHBhcmFtIHtib29sZWFufSBuZWdhdGUgV2hldGhlciB0aGUgYmluZGluZyB3YXMgbmVnYXRlZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gaGFuZGxlTm90aWZpY2F0aW9uKGV2ZW50LCBpbnN0LCBmcm9tUHJvcCwgdG9QYXRoLCBuZWdhdGUpIHtcbiAgICBsZXQgdmFsdWU7XG4gICAgbGV0IGRldGFpbCA9IC8qKiBAdHlwZSB7T2JqZWN0fSAqLyhldmVudC5kZXRhaWwpO1xuICAgIGxldCBmcm9tUGF0aCA9IGRldGFpbCAmJiBkZXRhaWwucGF0aDtcbiAgICBpZiAoZnJvbVBhdGgpIHtcbiAgICAgIHRvUGF0aCA9IFBvbHltZXIuUGF0aC50cmFuc2xhdGUoZnJvbVByb3AsIHRvUGF0aCwgZnJvbVBhdGgpO1xuICAgICAgdmFsdWUgPSBkZXRhaWwgJiYgZGV0YWlsLnZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSA9IGV2ZW50LnRhcmdldFtmcm9tUHJvcF07XG4gICAgfVxuICAgIHZhbHVlID0gbmVnYXRlID8gIXZhbHVlIDogdmFsdWU7XG4gICAgaWYgKCFpbnN0W1RZUEVTLlJFQURfT05MWV0gfHwgIWluc3RbVFlQRVMuUkVBRF9PTkxZXVt0b1BhdGhdKSB7XG4gICAgICBpZiAoaW5zdC5fc2V0UGVuZGluZ1Byb3BlcnR5T3JQYXRoKHRvUGF0aCwgdmFsdWUsIHRydWUsIEJvb2xlYW4oZnJvbVBhdGgpKVxuICAgICAgICAmJiAoIWRldGFpbCB8fCAhZGV0YWlsLnF1ZXVlUHJvcGVydHkpKSB7XG4gICAgICAgIGluc3QuX2ludmFsaWRhdGVQcm9wZXJ0aWVzKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEltcGxlbWVudHMgdGhlIFwicmVmbGVjdFwiIGVmZmVjdC5cbiAgICpcbiAgICogU2V0cyB0aGUgYXR0cmlidXRlIG5hbWVkIGBpbmZvLmF0dHJOYW1lYCB0byB0aGUgZ2l2ZW4gcHJvcGVydHkgdmFsdWUuXG4gICAqXG4gICAqIEBwYXJhbSB7IVByb3BlcnR5RWZmZWN0c1R5cGV9IGluc3QgVGhlIGluc3RhbmNlIHRoZSBlZmZlY3Qgd2lsbCBiZSBydW4gb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IE5hbWUgb2YgcHJvcGVydHlcbiAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzIEJhZyBvZiBjdXJyZW50IHByb3BlcnR5IGNoYW5nZXNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9sZFByb3BzIEJhZyBvZiBwcmV2aW91cyB2YWx1ZXMgZm9yIGNoYW5nZWQgcHJvcGVydGllc1xuICAgKiBAcGFyYW0gez99IGluZm8gRWZmZWN0IG1ldGFkYXRhXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBydW5SZWZsZWN0RWZmZWN0KGluc3QsIHByb3BlcnR5LCBwcm9wcywgb2xkUHJvcHMsIGluZm8pIHtcbiAgICBsZXQgdmFsdWUgPSBpbnN0Ll9fZGF0YVtwcm9wZXJ0eV07XG4gICAgaWYgKFBvbHltZXIuc2FuaXRpemVET01WYWx1ZSkge1xuICAgICAgdmFsdWUgPSBQb2x5bWVyLnNhbml0aXplRE9NVmFsdWUodmFsdWUsIGluZm8uYXR0ck5hbWUsICdhdHRyaWJ1dGUnLCAvKiogQHR5cGUge05vZGV9ICovKGluc3QpKTtcbiAgICB9XG4gICAgaW5zdC5fcHJvcGVydHlUb0F0dHJpYnV0ZShwcm9wZXJ0eSwgaW5mby5hdHRyTmFtZSwgdmFsdWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJ1bnMgXCJjb21wdXRlZFwiIGVmZmVjdHMgZm9yIGEgc2V0IG9mIGNoYW5nZWQgcHJvcGVydGllcy5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgZGlmZmVycyBmcm9tIHRoZSBnZW5lcmljIGBydW5FZmZlY3RzYCBtZXRob2QgaW4gdGhhdCBpdFxuICAgKiBjb250aW51ZXMgdG8gcnVuIGNvbXB1dGVkIGVmZmVjdHMgYmFzZWQgb24gdGhlIG91dHB1dCBvZiBlYWNoIHBhc3MgdW50aWxcbiAgICogdGhlcmUgYXJlIG5vIG1vcmUgbmV3bHkgY29tcHV0ZWQgcHJvcGVydGllcy4gIFRoaXMgZW5zdXJlcyB0aGF0IGFsbFxuICAgKiBwcm9wZXJ0aWVzIHRoYXQgd2lsbCBiZSBjb21wdXRlZCBieSB0aGUgaW5pdGlhbCBzZXQgb2YgY2hhbmdlcyBhcmVcbiAgICogY29tcHV0ZWQgYmVmb3JlIG90aGVyIGVmZmVjdHMgKGJpbmRpbmcgcHJvcGFnYXRpb24sIG9ic2VydmVycywgYW5kIG5vdGlmeSlcbiAgICogcnVuLlxuICAgKlxuICAgKiBAcGFyYW0geyFQcm9wZXJ0eUVmZmVjdHNUeXBlfSBpbnN0IFRoZSBpbnN0YW5jZSB0aGUgZWZmZWN0IHdpbGwgYmUgcnVuIG9uXG4gICAqIEBwYXJhbSB7IU9iamVjdH0gY2hhbmdlZFByb3BzIEJhZyBvZiBjaGFuZ2VkIHByb3BlcnRpZXNcbiAgICogQHBhcmFtIHshT2JqZWN0fSBvbGRQcm9wcyBCYWcgb2YgcHJldmlvdXMgdmFsdWVzIGZvciBjaGFuZ2VkIHByb3BlcnRpZXNcbiAgICogQHBhcmFtIHtib29sZWFufSBoYXNQYXRocyBUcnVlIHdpdGggYHByb3BzYCBjb250YWlucyBvbmUgb3IgbW9yZSBwYXRoc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gcnVuQ29tcHV0ZWRFZmZlY3RzKGluc3QsIGNoYW5nZWRQcm9wcywgb2xkUHJvcHMsIGhhc1BhdGhzKSB7XG4gICAgbGV0IGNvbXB1dGVFZmZlY3RzID0gaW5zdFtUWVBFUy5DT01QVVRFXTtcbiAgICBpZiAoY29tcHV0ZUVmZmVjdHMpIHtcbiAgICAgIGxldCBpbnB1dFByb3BzID0gY2hhbmdlZFByb3BzO1xuICAgICAgd2hpbGUgKHJ1bkVmZmVjdHMoaW5zdCwgY29tcHV0ZUVmZmVjdHMsIGlucHV0UHJvcHMsIG9sZFByb3BzLCBoYXNQYXRocykpIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihvbGRQcm9wcywgaW5zdC5fX2RhdGFPbGQpO1xuICAgICAgICBPYmplY3QuYXNzaWduKGNoYW5nZWRQcm9wcywgaW5zdC5fX2RhdGFQZW5kaW5nKTtcbiAgICAgICAgaW5wdXRQcm9wcyA9IGluc3QuX19kYXRhUGVuZGluZztcbiAgICAgICAgaW5zdC5fX2RhdGFQZW5kaW5nID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSW1wbGVtZW50cyB0aGUgXCJjb21wdXRlZCBwcm9wZXJ0eVwiIGVmZmVjdCBieSBydW5uaW5nIHRoZSBtZXRob2Qgd2l0aCB0aGVcbiAgICogdmFsdWVzIG9mIHRoZSBhcmd1bWVudHMgc3BlY2lmaWVkIGluIHRoZSBgaW5mb2Agb2JqZWN0IGFuZCBzZXR0aW5nIHRoZVxuICAgKiByZXR1cm4gdmFsdWUgdG8gdGhlIGNvbXB1dGVkIHByb3BlcnR5IHNwZWNpZmllZC5cbiAgICpcbiAgICogQHBhcmFtIHshUHJvcGVydHlFZmZlY3RzVHlwZX0gaW5zdCBUaGUgaW5zdGFuY2UgdGhlIGVmZmVjdCB3aWxsIGJlIHJ1biBvblxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgTmFtZSBvZiBwcm9wZXJ0eVxuICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgQmFnIG9mIGN1cnJlbnQgcHJvcGVydHkgY2hhbmdlc1xuICAgKiBAcGFyYW0ge09iamVjdH0gb2xkUHJvcHMgQmFnIG9mIHByZXZpb3VzIHZhbHVlcyBmb3IgY2hhbmdlZCBwcm9wZXJ0aWVzXG4gICAqIEBwYXJhbSB7P30gaW5mbyBFZmZlY3QgbWV0YWRhdGFcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIHJ1bkNvbXB1dGVkRWZmZWN0KGluc3QsIHByb3BlcnR5LCBwcm9wcywgb2xkUHJvcHMsIGluZm8pIHtcbiAgICBsZXQgcmVzdWx0ID0gcnVuTWV0aG9kRWZmZWN0KGluc3QsIHByb3BlcnR5LCBwcm9wcywgb2xkUHJvcHMsIGluZm8pO1xuICAgIGxldCBjb21wdXRlZFByb3AgPSBpbmZvLm1ldGhvZEluZm87XG4gICAgaWYgKGluc3QuX19kYXRhSGFzQWNjZXNzb3IgJiYgaW5zdC5fX2RhdGFIYXNBY2Nlc3Nvcltjb21wdXRlZFByb3BdKSB7XG4gICAgICBpbnN0Ll9zZXRQZW5kaW5nUHJvcGVydHkoY29tcHV0ZWRQcm9wLCByZXN1bHQsIHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnN0W2NvbXB1dGVkUHJvcF0gPSByZXN1bHQ7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbXB1dGVzIHBhdGggY2hhbmdlcyBiYXNlZCBvbiBwYXRoIGxpbmtzIHNldCB1cCB1c2luZyB0aGUgYGxpbmtQYXRoc2BcbiAgICogQVBJLlxuICAgKlxuICAgKiBAcGFyYW0geyFQcm9wZXJ0eUVmZmVjdHNUeXBlfSBpbnN0IFRoZSBpbnN0YW5jZSB3aG9zZSBwcm9wcyBhcmUgY2hhbmdpbmdcbiAgICogQHBhcmFtIHtzdHJpbmcgfCAhQXJyYXk8KHN0cmluZ3xudW1iZXIpPn0gcGF0aCBQYXRoIHRoYXQgaGFzIGNoYW5nZWRcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSBvZiBjaGFuZ2VkIHBhdGhcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIGNvbXB1dGVMaW5rZWRQYXRocyhpbnN0LCBwYXRoLCB2YWx1ZSkge1xuICAgIGxldCBsaW5rcyA9IGluc3QuX19kYXRhTGlua2VkUGF0aHM7XG4gICAgaWYgKGxpbmtzKSB7XG4gICAgICBsZXQgbGluaztcbiAgICAgIGZvciAobGV0IGEgaW4gbGlua3MpIHtcbiAgICAgICAgbGV0IGIgPSBsaW5rc1thXTtcbiAgICAgICAgaWYgKFBvbHltZXIuUGF0aC5pc0Rlc2NlbmRhbnQoYSwgcGF0aCkpIHtcbiAgICAgICAgICBsaW5rID0gUG9seW1lci5QYXRoLnRyYW5zbGF0ZShhLCBiLCBwYXRoKTtcbiAgICAgICAgICBpbnN0Ll9zZXRQZW5kaW5nUHJvcGVydHlPclBhdGgobGluaywgdmFsdWUsIHRydWUsIHRydWUpO1xuICAgICAgICB9IGVsc2UgaWYgKFBvbHltZXIuUGF0aC5pc0Rlc2NlbmRhbnQoYiwgcGF0aCkpIHtcbiAgICAgICAgICBsaW5rID0gUG9seW1lci5QYXRoLnRyYW5zbGF0ZShiLCBhLCBwYXRoKTtcbiAgICAgICAgICBpbnN0Ll9zZXRQZW5kaW5nUHJvcGVydHlPclBhdGgobGluaywgdmFsdWUsIHRydWUsIHRydWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gLS0gYmluZGluZ3MgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8qKlxuICAgKiBBZGRzIGJpbmRpbmcgbWV0YWRhdGEgdG8gdGhlIGN1cnJlbnQgYG5vZGVJbmZvYCwgYW5kIGJpbmRpbmcgZWZmZWN0c1xuICAgKiBmb3IgYWxsIHBhcnQgZGVwZW5kZW5jaWVzIHRvIGB0ZW1wbGF0ZUluZm9gLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb25zdHJ1Y3RvciBDbGFzcyB0aGF0IGBfcGFyc2VUZW1wbGF0ZWAgaXMgY3VycmVudGx5XG4gICAqICAgcnVubmluZyBvblxuICAgKiBAcGFyYW0ge1RlbXBsYXRlSW5mb30gdGVtcGxhdGVJbmZvIFRlbXBsYXRlIG1ldGFkYXRhIGZvciBjdXJyZW50IHRlbXBsYXRlXG4gICAqIEBwYXJhbSB7Tm9kZUluZm99IG5vZGVJbmZvIE5vZGUgbWV0YWRhdGEgZm9yIGN1cnJlbnQgdGVtcGxhdGUgbm9kZVxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2luZCBCaW5kaW5nIGtpbmQsIGVpdGhlciAncHJvcGVydHknLCAnYXR0cmlidXRlJywgb3IgJ3RleHQnXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0YXJnZXQgVGFyZ2V0IHByb3BlcnR5IG5hbWVcbiAgICogQHBhcmFtIHshQXJyYXk8IUJpbmRpbmdQYXJ0Pn0gcGFydHMgQXJyYXkgb2YgYmluZGluZyBwYXJ0IG1ldGFkYXRhXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gbGl0ZXJhbCBMaXRlcmFsIHRleHQgc3Vycm91bmRpbmcgYmluZGluZyBwYXJ0cyAoc3BlY2lmaWVkXG4gICAqICAgb25seSBmb3IgJ3Byb3BlcnR5JyBiaW5kaW5ncywgc2luY2UgdGhlc2UgbXVzdCBiZSBpbml0aWFsaXplZCBhcyBwYXJ0XG4gICAqICAgb2YgYm9vdC11cClcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIGFkZEJpbmRpbmcoY29uc3RydWN0b3IsIHRlbXBsYXRlSW5mbywgbm9kZUluZm8sIGtpbmQsIHRhcmdldCwgcGFydHMsIGxpdGVyYWwpIHtcbiAgICAvLyBDcmVhdGUgYmluZGluZyBtZXRhZGF0YSBhbmQgYWRkIHRvIG5vZGVJbmZvXG4gICAgbm9kZUluZm8uYmluZGluZ3MgPSBub2RlSW5mby5iaW5kaW5ncyB8fCBbXTtcbiAgICBsZXQgLyoqIEJpbmRpbmcgKi8gYmluZGluZyA9IHsga2luZCwgdGFyZ2V0LCBwYXJ0cywgbGl0ZXJhbCwgaXNDb21wb3VuZDogKHBhcnRzLmxlbmd0aCAhPT0gMSkgfTtcbiAgICBub2RlSW5mby5iaW5kaW5ncy5wdXNoKGJpbmRpbmcpO1xuICAgIC8vIEFkZCBsaXN0ZW5lciBpbmZvIHRvIGJpbmRpbmcgbWV0YWRhdGFcbiAgICBpZiAoc2hvdWxkQWRkTGlzdGVuZXIoYmluZGluZykpIHtcbiAgICAgIGxldCB7ZXZlbnQsIG5lZ2F0ZX0gPSBiaW5kaW5nLnBhcnRzWzBdO1xuICAgICAgYmluZGluZy5saXN0ZW5lckV2ZW50ID0gZXZlbnQgfHwgKENhc2VNYXAuY2FtZWxUb0Rhc2hDYXNlKHRhcmdldCkgKyAnLWNoYW5nZWQnKTtcbiAgICAgIGJpbmRpbmcubGlzdGVuZXJOZWdhdGUgPSBuZWdhdGU7XG4gICAgfVxuICAgIC8vIEFkZCBcInByb3BhZ2F0ZVwiIHByb3BlcnR5IGVmZmVjdHMgdG8gdGVtcGxhdGVJbmZvXG4gICAgbGV0IGluZGV4ID0gdGVtcGxhdGVJbmZvLm5vZGVJbmZvTGlzdC5sZW5ndGg7XG4gICAgZm9yIChsZXQgaT0wOyBpPGJpbmRpbmcucGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBwYXJ0ID0gYmluZGluZy5wYXJ0c1tpXTtcbiAgICAgIHBhcnQuY29tcG91bmRJbmRleCA9IGk7XG4gICAgICBhZGRFZmZlY3RGb3JCaW5kaW5nUGFydChjb25zdHJ1Y3RvciwgdGVtcGxhdGVJbmZvLCBiaW5kaW5nLCBwYXJ0LCBpbmRleCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgcHJvcGVydHkgZWZmZWN0cyB0byB0aGUgZ2l2ZW4gYHRlbXBsYXRlSW5mb2AgZm9yIHRoZSBnaXZlbiBiaW5kaW5nXG4gICAqIHBhcnQuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbnN0cnVjdG9yIENsYXNzIHRoYXQgYF9wYXJzZVRlbXBsYXRlYCBpcyBjdXJyZW50bHlcbiAgICogICBydW5uaW5nIG9uXG4gICAqIEBwYXJhbSB7VGVtcGxhdGVJbmZvfSB0ZW1wbGF0ZUluZm8gVGVtcGxhdGUgbWV0YWRhdGEgZm9yIGN1cnJlbnQgdGVtcGxhdGVcbiAgICogQHBhcmFtIHshQmluZGluZ30gYmluZGluZyBCaW5kaW5nIG1ldGFkYXRhXG4gICAqIEBwYXJhbSB7IUJpbmRpbmdQYXJ0fSBwYXJ0IEJpbmRpbmcgcGFydCBtZXRhZGF0YVxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSW5kZXggaW50byBgbm9kZUluZm9MaXN0YCBmb3IgdGhpcyBub2RlXG4gICAqL1xuICBmdW5jdGlvbiBhZGRFZmZlY3RGb3JCaW5kaW5nUGFydChjb25zdHJ1Y3RvciwgdGVtcGxhdGVJbmZvLCBiaW5kaW5nLCBwYXJ0LCBpbmRleCkge1xuICAgIGlmICghcGFydC5saXRlcmFsKSB7XG4gICAgICBpZiAoYmluZGluZy5raW5kID09PSAnYXR0cmlidXRlJyAmJiBiaW5kaW5nLnRhcmdldFswXSA9PT0gJy0nKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignQ2Fubm90IHNldCBhdHRyaWJ1dGUgJyArIGJpbmRpbmcudGFyZ2V0ICtcbiAgICAgICAgICAnIGJlY2F1c2UgXCItXCIgaXMgbm90IGEgdmFsaWQgYXR0cmlidXRlIHN0YXJ0aW5nIGNoYXJhY3RlcicpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IGRlcGVuZGVuY2llcyA9IHBhcnQuZGVwZW5kZW5jaWVzO1xuICAgICAgICBsZXQgaW5mbyA9IHsgaW5kZXgsIGJpbmRpbmcsIHBhcnQsIGV2YWx1YXRvcjogY29uc3RydWN0b3IgfTtcbiAgICAgICAgZm9yIChsZXQgaj0wOyBqPGRlcGVuZGVuY2llcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGxldCB0cmlnZ2VyID0gZGVwZW5kZW5jaWVzW2pdO1xuICAgICAgICAgIGlmICh0eXBlb2YgdHJpZ2dlciA9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdHJpZ2dlciA9IHBhcnNlQXJnKHRyaWdnZXIpO1xuICAgICAgICAgICAgdHJpZ2dlci53aWxkY2FyZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0cnVjdG9yLl9hZGRUZW1wbGF0ZVByb3BlcnR5RWZmZWN0KHRlbXBsYXRlSW5mbywgdHJpZ2dlci5yb290UHJvcGVydHksIHtcbiAgICAgICAgICAgIGZuOiBydW5CaW5kaW5nRWZmZWN0LFxuICAgICAgICAgICAgaW5mbywgdHJpZ2dlclxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEltcGxlbWVudHMgdGhlIFwiYmluZGluZ1wiIChwcm9wZXJ0eS9wYXRoIGJpbmRpbmcpIGVmZmVjdC5cbiAgICpcbiAgICogTm90ZSB0aGF0IGJpbmRpbmcgc3ludGF4IGlzIG92ZXJyaWRhYmxlIHZpYSBgX3BhcnNlQmluZGluZ3NgIGFuZFxuICAgKiBgX2V2YWx1YXRlQmluZGluZ2AuICBUaGlzIG1ldGhvZCB3aWxsIGNhbGwgYF9ldmFsdWF0ZUJpbmRpbmdgIGZvciBhbnlcbiAgICogbm9uLWxpdGVyYWwgcGFydHMgcmV0dXJuZWQgZnJvbSBgX3BhcnNlQmluZGluZ3NgLiAgSG93ZXZlcixcbiAgICogdGhlcmUgaXMgbm8gc3VwcG9ydCBmb3IgX3BhdGhfIGJpbmRpbmdzIHZpYSBjdXN0b20gYmluZGluZyBwYXJ0cyxcbiAgICogYXMgdGhpcyBpcyBzcGVjaWZpYyB0byBQb2x5bWVyJ3MgcGF0aCBiaW5kaW5nIHN5bnRheC5cbiAgICpcbiAgICogQHBhcmFtIHshUHJvcGVydHlFZmZlY3RzVHlwZX0gaW5zdCBUaGUgaW5zdGFuY2UgdGhlIGVmZmVjdCB3aWxsIGJlIHJ1biBvblxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBOYW1lIG9mIHByb3BlcnR5XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBCYWcgb2YgY3VycmVudCBwcm9wZXJ0eSBjaGFuZ2VzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvbGRQcm9wcyBCYWcgb2YgcHJldmlvdXMgdmFsdWVzIGZvciBjaGFuZ2VkIHByb3BlcnRpZXNcbiAgICogQHBhcmFtIHs/fSBpbmZvIEVmZmVjdCBtZXRhZGF0YVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhhc1BhdGhzIFRydWUgd2l0aCBgcHJvcHNgIGNvbnRhaW5zIG9uZSBvciBtb3JlIHBhdGhzXG4gICAqIEBwYXJhbSB7QXJyYXl9IG5vZGVMaXN0IExpc3Qgb2Ygbm9kZXMgYXNzb2NpYXRlZCB3aXRoIGBub2RlSW5mb0xpc3RgIHRlbXBsYXRlXG4gICAqICAgbWV0YWRhdGFcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIHJ1bkJpbmRpbmdFZmZlY3QoaW5zdCwgcGF0aCwgcHJvcHMsIG9sZFByb3BzLCBpbmZvLCBoYXNQYXRocywgbm9kZUxpc3QpIHtcbiAgICBsZXQgbm9kZSA9IG5vZGVMaXN0W2luZm8uaW5kZXhdO1xuICAgIGxldCBiaW5kaW5nID0gaW5mby5iaW5kaW5nO1xuICAgIGxldCBwYXJ0ID0gaW5mby5wYXJ0O1xuICAgIC8vIFN1YnBhdGggbm90aWZpY2F0aW9uOiB0cmFuc2Zvcm0gcGF0aCBhbmQgc2V0IHRvIGNsaWVudFxuICAgIC8vIGUuZy46IGZvbz1cInt7b2JqLnN1Yn19XCIsIHBhdGg6ICdvYmouc3ViLnByb3AnLCBzZXQgJ2Zvby5wcm9wJz1vYmouc3ViLnByb3BcbiAgICBpZiAoaGFzUGF0aHMgJiYgcGFydC5zb3VyY2UgJiYgKHBhdGgubGVuZ3RoID4gcGFydC5zb3VyY2UubGVuZ3RoKSAmJlxuICAgICAgICAoYmluZGluZy5raW5kID09ICdwcm9wZXJ0eScpICYmICFiaW5kaW5nLmlzQ29tcG91bmQgJiZcbiAgICAgICAgbm9kZS5fX2RhdGFIYXNBY2Nlc3NvciAmJiBub2RlLl9fZGF0YUhhc0FjY2Vzc29yW2JpbmRpbmcudGFyZ2V0XSkge1xuICAgICAgbGV0IHZhbHVlID0gcHJvcHNbcGF0aF07XG4gICAgICBwYXRoID0gUG9seW1lci5QYXRoLnRyYW5zbGF0ZShwYXJ0LnNvdXJjZSwgYmluZGluZy50YXJnZXQsIHBhdGgpO1xuICAgICAgaWYgKG5vZGUuX3NldFBlbmRpbmdQcm9wZXJ0eU9yUGF0aChwYXRoLCB2YWx1ZSwgZmFsc2UsIHRydWUpKSB7XG4gICAgICAgIGluc3QuX2VucXVldWVDbGllbnQobm9kZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCB2YWx1ZSA9IGluZm8uZXZhbHVhdG9yLl9ldmFsdWF0ZUJpbmRpbmcoaW5zdCwgcGFydCwgcGF0aCwgcHJvcHMsIG9sZFByb3BzLCBoYXNQYXRocyk7XG4gICAgICAvLyBQcm9wYWdhdGUgdmFsdWUgdG8gY2hpbGRcbiAgICAgIGFwcGx5QmluZGluZ1ZhbHVlKGluc3QsIG5vZGUsIGJpbmRpbmcsIHBhcnQsIHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgdmFsdWUgZm9yIGFuIFwiYmluZGluZ1wiIChiaW5kaW5nKSBlZmZlY3QgdG8gYSBub2RlLFxuICAgKiBlaXRoZXIgYXMgYSBwcm9wZXJ0eSBvciBhdHRyaWJ1dGUuXG4gICAqXG4gICAqIEBwYXJhbSB7IVByb3BlcnR5RWZmZWN0c1R5cGV9IGluc3QgVGhlIGluc3RhbmNlIG93bmluZyB0aGUgYmluZGluZyBlZmZlY3RcbiAgICogQHBhcmFtIHtOb2RlfSBub2RlIFRhcmdldCBub2RlIGZvciBiaW5kaW5nXG4gICAqIEBwYXJhbSB7IUJpbmRpbmd9IGJpbmRpbmcgQmluZGluZyBtZXRhZGF0YVxuICAgKiBAcGFyYW0geyFCaW5kaW5nUGFydH0gcGFydCBCaW5kaW5nIHBhcnQgbWV0YWRhdGFcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byBzZXRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIGFwcGx5QmluZGluZ1ZhbHVlKGluc3QsIG5vZGUsIGJpbmRpbmcsIHBhcnQsIHZhbHVlKSB7XG4gICAgdmFsdWUgPSBjb21wdXRlQmluZGluZ1ZhbHVlKG5vZGUsIHZhbHVlLCBiaW5kaW5nLCBwYXJ0KTtcbiAgICBpZiAoUG9seW1lci5zYW5pdGl6ZURPTVZhbHVlKSB7XG4gICAgICB2YWx1ZSA9IFBvbHltZXIuc2FuaXRpemVET01WYWx1ZSh2YWx1ZSwgYmluZGluZy50YXJnZXQsIGJpbmRpbmcua2luZCwgbm9kZSk7XG4gICAgfVxuICAgIGlmIChiaW5kaW5nLmtpbmQgPT0gJ2F0dHJpYnV0ZScpIHtcbiAgICAgIC8vIEF0dHJpYnV0ZSBiaW5kaW5nXG4gICAgICBpbnN0Ll92YWx1ZVRvTm9kZUF0dHJpYnV0ZSgvKiogQHR5cGUge0VsZW1lbnR9ICovKG5vZGUpLCB2YWx1ZSwgYmluZGluZy50YXJnZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBQcm9wZXJ0eSBiaW5kaW5nXG4gICAgICBsZXQgcHJvcCA9IGJpbmRpbmcudGFyZ2V0O1xuICAgICAgaWYgKG5vZGUuX19kYXRhSGFzQWNjZXNzb3IgJiYgbm9kZS5fX2RhdGFIYXNBY2Nlc3Nvcltwcm9wXSkge1xuICAgICAgICBpZiAoIW5vZGVbVFlQRVMuUkVBRF9PTkxZXSB8fCAhbm9kZVtUWVBFUy5SRUFEX09OTFldW3Byb3BdKSB7XG4gICAgICAgICAgaWYgKG5vZGUuX3NldFBlbmRpbmdQcm9wZXJ0eShwcm9wLCB2YWx1ZSkpIHtcbiAgICAgICAgICAgIGluc3QuX2VucXVldWVDbGllbnQobm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgIHtcbiAgICAgICAgaW5zdC5fc2V0VW5tYW5hZ2VkUHJvcGVydHlUb05vZGUobm9kZSwgcHJvcCwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUcmFuc2Zvcm1zIGFuIFwiYmluZGluZ1wiIGVmZmVjdCB2YWx1ZSBiYXNlZCBvbiBjb21wb3VuZCAmIG5lZ2F0aW9uXG4gICAqIGVmZmVjdCBtZXRhZGF0YSwgYXMgd2VsbCBhcyBoYW5kbGluZyBmb3Igc3BlY2lhbC1jYXNlIHByb3BlcnRpZXNcbiAgICpcbiAgICogQHBhcmFtIHtOb2RlfSBub2RlIE5vZGUgdGhlIHZhbHVlIHdpbGwgYmUgc2V0IHRvXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgdG8gc2V0XG4gICAqIEBwYXJhbSB7IUJpbmRpbmd9IGJpbmRpbmcgQmluZGluZyBtZXRhZGF0YVxuICAgKiBAcGFyYW0geyFCaW5kaW5nUGFydH0gcGFydCBCaW5kaW5nIHBhcnQgbWV0YWRhdGFcbiAgICogQHJldHVybiB7Kn0gVHJhbnNmb3JtZWQgdmFsdWUgdG8gc2V0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBjb21wdXRlQmluZGluZ1ZhbHVlKG5vZGUsIHZhbHVlLCBiaW5kaW5nLCBwYXJ0KSB7XG4gICAgaWYgKGJpbmRpbmcuaXNDb21wb3VuZCkge1xuICAgICAgbGV0IHN0b3JhZ2UgPSBub2RlLl9fZGF0YUNvbXBvdW5kU3RvcmFnZVtiaW5kaW5nLnRhcmdldF07XG4gICAgICBzdG9yYWdlW3BhcnQuY29tcG91bmRJbmRleF0gPSB2YWx1ZTtcbiAgICAgIHZhbHVlID0gc3RvcmFnZS5qb2luKCcnKTtcbiAgICB9XG4gICAgaWYgKGJpbmRpbmcua2luZCAhPT0gJ2F0dHJpYnV0ZScpIHtcbiAgICAgIC8vIFNvbWUgYnJvd3NlcnMgc2VyaWFsaXplIGB1bmRlZmluZWRgIHRvIGBcInVuZGVmaW5lZFwiYFxuICAgICAgaWYgKGJpbmRpbmcudGFyZ2V0ID09PSAndGV4dENvbnRlbnQnIHx8XG4gICAgICAgICAgKG5vZGUubG9jYWxOYW1lID09ICdpbnB1dCcgJiYgYmluZGluZy50YXJnZXQgPT0gJ3ZhbHVlJykpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZSA9PSB1bmRlZmluZWQgPyAnJyA6IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIGEgYmluZGluZydzIG1ldGFkYXRhIG1lZXRzIGFsbCB0aGUgcmVxdWlyZW1lbnRzIHRvIGFsbG93XG4gICAqIDItd2F5IGJpbmRpbmcsIGFuZCB0aGVyZWZvcmUgYSBgPHByb3BlcnR5Pi1jaGFuZ2VkYCBldmVudCBsaXN0ZW5lciBzaG91bGQgYmVcbiAgICogYWRkZWQ6XG4gICAqIC0gdXNlZCBjdXJseSBicmFjZXNcbiAgICogLSBpcyBhIHByb3BlcnR5IChub3QgYXR0cmlidXRlKSBiaW5kaW5nXG4gICAqIC0gaXMgbm90IGEgdGV4dENvbnRlbnQgYmluZGluZ1xuICAgKiAtIGlzIG5vdCBjb21wb3VuZFxuICAgKlxuICAgKiBAcGFyYW0geyFCaW5kaW5nfSBiaW5kaW5nIEJpbmRpbmcgbWV0YWRhdGFcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiAyLXdheSBsaXN0ZW5lciBzaG91bGQgYmUgYWRkZWRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIHNob3VsZEFkZExpc3RlbmVyKGJpbmRpbmcpIHtcbiAgICByZXR1cm4gQm9vbGVhbihiaW5kaW5nLnRhcmdldCkgJiZcbiAgICAgICAgICAgYmluZGluZy5raW5kICE9ICdhdHRyaWJ1dGUnICYmXG4gICAgICAgICAgIGJpbmRpbmcua2luZCAhPSAndGV4dCcgJiZcbiAgICAgICAgICAgIWJpbmRpbmcuaXNDb21wb3VuZCAmJlxuICAgICAgICAgICBiaW5kaW5nLnBhcnRzWzBdLm1vZGUgPT09ICd7JztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXR1cCBjb21wb3VuZCBiaW5kaW5nIHN0b3JhZ2Ugc3RydWN0dXJlcywgbm90aWZ5IGxpc3RlbmVycywgYW5kIGRhdGFIb3N0XG4gICAqIHJlZmVyZW5jZXMgb250byB0aGUgYm91bmQgbm9kZUxpc3QuXG4gICAqXG4gICAqIEBwYXJhbSB7IVByb3BlcnR5RWZmZWN0c1R5cGV9IGluc3QgSW5zdGFuY2UgdGhhdCBiYXMgYmVlbiBwcmV2aW91c2x5IGJvdW5kXG4gICAqIEBwYXJhbSB7VGVtcGxhdGVJbmZvfSB0ZW1wbGF0ZUluZm8gVGVtcGxhdGUgbWV0YWRhdGFcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIHNldHVwQmluZGluZ3MoaW5zdCwgdGVtcGxhdGVJbmZvKSB7XG4gICAgLy8gU2V0dXAgY29tcG91bmQgc3RvcmFnZSwgZGF0YUhvc3QsIGFuZCBub3RpZnkgbGlzdGVuZXJzXG4gICAgbGV0IHtub2RlTGlzdCwgbm9kZUluZm9MaXN0fSA9IHRlbXBsYXRlSW5mbztcbiAgICBpZiAobm9kZUluZm9MaXN0Lmxlbmd0aCkge1xuICAgICAgZm9yIChsZXQgaT0wOyBpIDwgbm9kZUluZm9MaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBpbmZvID0gbm9kZUluZm9MaXN0W2ldO1xuICAgICAgICBsZXQgbm9kZSA9IG5vZGVMaXN0W2ldO1xuICAgICAgICBsZXQgYmluZGluZ3MgPSBpbmZvLmJpbmRpbmdzO1xuICAgICAgICBpZiAoYmluZGluZ3MpIHtcbiAgICAgICAgICBmb3IgKGxldCBpPTA7IGk8YmluZGluZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBiaW5kaW5nID0gYmluZGluZ3NbaV07XG4gICAgICAgICAgICBzZXR1cENvbXBvdW5kU3RvcmFnZShub2RlLCBiaW5kaW5nKTtcbiAgICAgICAgICAgIGFkZE5vdGlmeUxpc3RlbmVyKG5vZGUsIGluc3QsIGJpbmRpbmcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBub2RlLl9fZGF0YUhvc3QgPSBpbnN0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyBgX19kYXRhQ29tcG91bmRTdG9yYWdlYCBsb2NhbCBzdG9yYWdlIG9uIGEgYm91bmQgbm9kZSB3aXRoXG4gICAqIGluaXRpYWwgbGl0ZXJhbCBkYXRhIGZvciBjb21wb3VuZCBiaW5kaW5ncywgYW5kIHNldHMgdGhlIGpvaW5lZFxuICAgKiBsaXRlcmFsIHBhcnRzIHRvIHRoZSBib3VuZCBwcm9wZXJ0eS5cbiAgICpcbiAgICogV2hlbiBjaGFuZ2VzIHRvIGNvbXBvdW5kIHBhcnRzIG9jY3VyLCB0aGV5IGFyZSBmaXJzdCBzZXQgaW50byB0aGUgY29tcG91bmRcbiAgICogc3RvcmFnZSBhcnJheSBmb3IgdGhhdCBwcm9wZXJ0eSwgYW5kIHRoZW4gdGhlIGFycmF5IGlzIGpvaW5lZCB0byByZXN1bHQgaW5cbiAgICogdGhlIGZpbmFsIHZhbHVlIHNldCB0byB0aGUgcHJvcGVydHkvYXR0cmlidXRlLlxuICAgKlxuICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgQm91bmQgbm9kZSB0byBpbml0aWFsaXplXG4gICAqIEBwYXJhbSB7QmluZGluZ30gYmluZGluZyBCaW5kaW5nIG1ldGFkYXRhXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBzZXR1cENvbXBvdW5kU3RvcmFnZShub2RlLCBiaW5kaW5nKSB7XG4gICAgaWYgKGJpbmRpbmcuaXNDb21wb3VuZCkge1xuICAgICAgLy8gQ3JlYXRlIGNvbXBvdW5kIHN0b3JhZ2UgbWFwXG4gICAgICBsZXQgc3RvcmFnZSA9IG5vZGUuX19kYXRhQ29tcG91bmRTdG9yYWdlIHx8XG4gICAgICAgIChub2RlLl9fZGF0YUNvbXBvdW5kU3RvcmFnZSA9IHt9KTtcbiAgICAgIGxldCBwYXJ0cyA9IGJpbmRpbmcucGFydHM7XG4gICAgICAvLyBDb3B5IGxpdGVyYWxzIGZyb20gcGFydHMgaW50byBzdG9yYWdlIGZvciB0aGlzIGJpbmRpbmdcbiAgICAgIGxldCBsaXRlcmFscyA9IG5ldyBBcnJheShwYXJ0cy5sZW5ndGgpO1xuICAgICAgZm9yIChsZXQgaj0wOyBqPHBhcnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGxpdGVyYWxzW2pdID0gcGFydHNbal0ubGl0ZXJhbDtcbiAgICAgIH1cbiAgICAgIGxldCB0YXJnZXQgPSBiaW5kaW5nLnRhcmdldDtcbiAgICAgIHN0b3JhZ2VbdGFyZ2V0XSA9IGxpdGVyYWxzO1xuICAgICAgLy8gQ29uZmlndXJlIHByb3BlcnRpZXMgd2l0aCB0aGVpciBsaXRlcmFsIHBhcnRzXG4gICAgICBpZiAoYmluZGluZy5saXRlcmFsICYmIGJpbmRpbmcua2luZCA9PSAncHJvcGVydHknKSB7XG4gICAgICAgIG5vZGVbdGFyZ2V0XSA9IGJpbmRpbmcubGl0ZXJhbDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhIDItd2F5IGJpbmRpbmcgbm90aWZpY2F0aW9uIGV2ZW50IGxpc3RlbmVyIHRvIHRoZSBub2RlIHNwZWNpZmllZFxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gbm9kZSBDaGlsZCBlbGVtZW50IHRvIGFkZCBsaXN0ZW5lciB0b1xuICAgKiBAcGFyYW0geyFQcm9wZXJ0eUVmZmVjdHNUeXBlfSBpbnN0IEhvc3QgZWxlbWVudCBpbnN0YW5jZSB0byBoYW5kbGUgbm90aWZpY2F0aW9uIGV2ZW50XG4gICAqIEBwYXJhbSB7QmluZGluZ30gYmluZGluZyBCaW5kaW5nIG1ldGFkYXRhXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBhZGROb3RpZnlMaXN0ZW5lcihub2RlLCBpbnN0LCBiaW5kaW5nKSB7XG4gICAgaWYgKGJpbmRpbmcubGlzdGVuZXJFdmVudCkge1xuICAgICAgbGV0IHBhcnQgPSBiaW5kaW5nLnBhcnRzWzBdO1xuICAgICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKGJpbmRpbmcubGlzdGVuZXJFdmVudCwgZnVuY3Rpb24oZSkge1xuICAgICAgICBoYW5kbGVOb3RpZmljYXRpb24oZSwgaW5zdCwgYmluZGluZy50YXJnZXQsIHBhcnQuc291cmNlLCBwYXJ0Lm5lZ2F0ZSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvLyAtLSBmb3IgbWV0aG9kLWJhc2VkIGVmZmVjdHMgKGNvbXBsZXhPYnNlcnZlciAmIGNvbXB1dGVkKSAtLS0tLS0tLS0tLS0tLVxuXG4gIC8qKlxuICAgKiBBZGRzIHByb3BlcnR5IGVmZmVjdHMgZm9yIGVhY2ggYXJndW1lbnQgaW4gdGhlIG1ldGhvZCBzaWduYXR1cmUgKGFuZFxuICAgKiBvcHRpb25hbGx5LCBmb3IgdGhlIG1ldGhvZCBuYW1lIGlmIGBkeW5hbWljYCBpcyB0cnVlKSB0aGF0IGNhbGxzIHRoZVxuICAgKiBwcm92aWRlZCBlZmZlY3QgZnVuY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7RWxlbWVudCB8IE9iamVjdH0gbW9kZWwgUHJvdG90eXBlIG9yIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7IU1ldGhvZFNpZ25hdHVyZX0gc2lnIE1ldGhvZCBzaWduYXR1cmUgbWV0YWRhdGFcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgVHlwZSBvZiBwcm9wZXJ0eSBlZmZlY3QgdG8gYWRkXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGVmZmVjdEZuIEZ1bmN0aW9uIHRvIHJ1biB3aGVuIGFyZ3VtZW50cyBjaGFuZ2VcbiAgICogQHBhcmFtIHsqPX0gbWV0aG9kSW5mbyBFZmZlY3Qtc3BlY2lmaWMgaW5mb3JtYXRpb24gdG8gYmUgaW5jbHVkZWQgaW5cbiAgICogICBtZXRob2QgZWZmZWN0IG1ldGFkYXRhXG4gICAqIEBwYXJhbSB7Ym9vbGVhbnxPYmplY3Q9fSBkeW5hbWljRm4gQm9vbGVhbiBvciBvYmplY3QgbWFwIGluZGljYXRpbmcgd2hldGhlclxuICAgKiAgIG1ldGhvZCBuYW1lcyBzaG91bGQgYmUgaW5jbHVkZWQgYXMgYSBkZXBlbmRlbmN5IHRvIHRoZSBlZmZlY3QuIE5vdGUsXG4gICAqICAgZGVmYXVsdHMgdG8gdHJ1ZSBpZiB0aGUgc2lnbmF0dXJlIGlzIHN0YXRpYyAoc2lnLnN0YXRpYyBpcyB0cnVlKS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIGNyZWF0ZU1ldGhvZEVmZmVjdChtb2RlbCwgc2lnLCB0eXBlLCBlZmZlY3RGbiwgbWV0aG9kSW5mbywgZHluYW1pY0ZuKSB7XG4gICAgZHluYW1pY0ZuID0gc2lnLnN0YXRpYyB8fCAoZHluYW1pY0ZuICYmXG4gICAgICAodHlwZW9mIGR5bmFtaWNGbiAhPT0gJ29iamVjdCcgfHwgZHluYW1pY0ZuW3NpZy5tZXRob2ROYW1lXSkpO1xuICAgIGxldCBpbmZvID0ge1xuICAgICAgbWV0aG9kTmFtZTogc2lnLm1ldGhvZE5hbWUsXG4gICAgICBhcmdzOiBzaWcuYXJncyxcbiAgICAgIG1ldGhvZEluZm8sXG4gICAgICBkeW5hbWljRm5cbiAgICB9O1xuICAgIGZvciAobGV0IGk9MCwgYXJnOyAoaTxzaWcuYXJncy5sZW5ndGgpICYmIChhcmc9c2lnLmFyZ3NbaV0pOyBpKyspIHtcbiAgICAgIGlmICghYXJnLmxpdGVyYWwpIHtcbiAgICAgICAgbW9kZWwuX2FkZFByb3BlcnR5RWZmZWN0KGFyZy5yb290UHJvcGVydHksIHR5cGUsIHtcbiAgICAgICAgICBmbjogZWZmZWN0Rm4sIGluZm86IGluZm8sIHRyaWdnZXI6IGFyZ1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGR5bmFtaWNGbikge1xuICAgICAgbW9kZWwuX2FkZFByb3BlcnR5RWZmZWN0KHNpZy5tZXRob2ROYW1lLCB0eXBlLCB7XG4gICAgICAgIGZuOiBlZmZlY3RGbiwgaW5mbzogaW5mb1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENhbGxzIGEgbWV0aG9kIHdpdGggYXJndW1lbnRzIG1hcnNoYWxlZCBmcm9tIHByb3BlcnRpZXMgb24gdGhlIGluc3RhbmNlXG4gICAqIGJhc2VkIG9uIHRoZSBtZXRob2Qgc2lnbmF0dXJlIGNvbnRhaW5lZCBpbiB0aGUgZWZmZWN0IG1ldGFkYXRhLlxuICAgKlxuICAgKiBNdWx0aS1wcm9wZXJ0eSBvYnNlcnZlcnMsIGNvbXB1dGVkIHByb3BlcnRpZXMsIGFuZCBpbmxpbmUgY29tcHV0aW5nXG4gICAqIGZ1bmN0aW9ucyBjYWxsIHRoaXMgZnVuY3Rpb24gdG8gaW52b2tlIHRoZSBtZXRob2QsIHRoZW4gdXNlIHRoZSByZXR1cm5cbiAgICogdmFsdWUgYWNjb3JkaW5nbHkuXG4gICAqXG4gICAqIEBwYXJhbSB7IVByb3BlcnR5RWZmZWN0c1R5cGV9IGluc3QgVGhlIGluc3RhbmNlIHRoZSBlZmZlY3Qgd2lsbCBiZSBydW4gb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IE5hbWUgb2YgcHJvcGVydHlcbiAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzIEJhZyBvZiBjdXJyZW50IHByb3BlcnR5IGNoYW5nZXNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9sZFByb3BzIEJhZyBvZiBwcmV2aW91cyB2YWx1ZXMgZm9yIGNoYW5nZWQgcHJvcGVydGllc1xuICAgKiBAcGFyYW0gez99IGluZm8gRWZmZWN0IG1ldGFkYXRhXG4gICAqIEByZXR1cm4geyp9IFJldHVybnMgdGhlIHJldHVybiB2YWx1ZSBmcm9tIHRoZSBtZXRob2QgaW52b2NhdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gcnVuTWV0aG9kRWZmZWN0KGluc3QsIHByb3BlcnR5LCBwcm9wcywgb2xkUHJvcHMsIGluZm8pIHtcbiAgICAvLyBJbnN0YW5jZXMgY2FuIG9wdGlvbmFsbHkgaGF2ZSBhIF9tZXRob2RIb3N0IHdoaWNoIGFsbG93cyByZWRpcmVjdGluZyB3aGVyZVxuICAgIC8vIHRvIGZpbmQgbWV0aG9kcy4gQ3VycmVudGx5IHVzZWQgYnkgYHRlbXBsYXRpemVgLlxuICAgIGxldCBjb250ZXh0ID0gaW5zdC5fbWV0aG9kSG9zdCB8fCBpbnN0O1xuICAgIGxldCBmbiA9IGNvbnRleHRbaW5mby5tZXRob2ROYW1lXTtcbiAgICBpZiAoZm4pIHtcbiAgICAgIGxldCBhcmdzID0gbWFyc2hhbEFyZ3MoaW5zdC5fX2RhdGEsIGluZm8uYXJncywgcHJvcGVydHksIHByb3BzKTtcbiAgICAgIHJldHVybiBmbi5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICB9IGVsc2UgaWYgKCFpbmZvLmR5bmFtaWNGbikge1xuICAgICAgY29uc29sZS53YXJuKCdtZXRob2QgYCcgKyBpbmZvLm1ldGhvZE5hbWUgKyAnYCBub3QgZGVmaW5lZCcpO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGVtcHR5QXJyYXkgPSBbXTtcblxuICAvLyBSZWd1bGFyIGV4cHJlc3Npb25zIHVzZWQgZm9yIGJpbmRpbmdcbiAgY29uc3QgSURFTlQgID0gJyg/OicgKyAnW2EtekEtWl8kXVtcXFxcdy46JFxcXFwtKl0qJyArICcpJztcbiAgY29uc3QgTlVNQkVSID0gJyg/OicgKyAnWy0rXT9bMC05XSpcXFxcLj9bMC05XSsoPzpbZUVdWy0rXT9bMC05XSspPycgKyAnKSc7XG4gIGNvbnN0IFNRVU9URV9TVFJJTkcgPSAnKD86JyArICdcXCcoPzpbXlxcJ1xcXFxcXFxcXXxcXFxcXFxcXC4pKlxcJycgKyAnKSc7XG4gIGNvbnN0IERRVU9URV9TVFJJTkcgPSAnKD86JyArICdcIig/OlteXCJcXFxcXFxcXF18XFxcXFxcXFwuKSpcIicgKyAnKSc7XG4gIGNvbnN0IFNUUklORyA9ICcoPzonICsgU1FVT1RFX1NUUklORyArICd8JyArIERRVU9URV9TVFJJTkcgKyAnKSc7XG4gIGNvbnN0IEFSR1VNRU5UID0gJyg/OignICsgSURFTlQgKyAnfCcgKyBOVU1CRVIgKyAnfCcgKyAgU1RSSU5HICsgJylcXFxccyonICsgJyknO1xuICBjb25zdCBBUkdVTUVOVFMgPSAnKD86JyArIEFSR1VNRU5UICsgJyg/OixcXFxccyonICsgQVJHVU1FTlQgKyAnKSonICsgJyknO1xuICBjb25zdCBBUkdVTUVOVF9MSVNUID0gJyg/OicgKyAnXFxcXChcXFxccyonICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyg/OicgKyBBUkdVTUVOVFMgKyAnPycgKyAnKScgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1xcXFwpXFxcXHMqJyArICcpJztcbiAgY29uc3QgQklORElORyA9ICcoJyArIElERU5UICsgJ1xcXFxzKicgKyBBUkdVTUVOVF9MSVNUICsgJz8nICsgJyknOyAvLyBHcm91cCAzXG4gIGNvbnN0IE9QRU5fQlJBQ0tFVCA9ICcoXFxcXFtcXFxcW3x7eyknICsgJ1xcXFxzKic7XG4gIGNvbnN0IENMT1NFX0JSQUNLRVQgPSAnKD86XV18fX0pJztcbiAgY29uc3QgTkVHQVRFID0gJyg/OighKVxcXFxzKik/JzsgLy8gR3JvdXAgMlxuICBjb25zdCBFWFBSRVNTSU9OID0gT1BFTl9CUkFDS0VUICsgTkVHQVRFICsgQklORElORyArIENMT1NFX0JSQUNLRVQ7XG4gIGNvbnN0IGJpbmRpbmdSZWdleCA9IG5ldyBSZWdFeHAoRVhQUkVTU0lPTiwgXCJnXCIpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBzdHJpbmcgZnJvbSBiaW5kaW5nIHBhcnRzIG9mIGFsbCB0aGUgbGl0ZXJhbCBwYXJ0c1xuICAgKlxuICAgKiBAcGFyYW0geyFBcnJheTxCaW5kaW5nUGFydD59IHBhcnRzIEFsbCBwYXJ0cyB0byBzdHJpbmdpZnlcbiAgICogQHJldHVybiB7c3RyaW5nfSBTdHJpbmcgbWFkZSBmcm9tIHRoZSBsaXRlcmFsIHBhcnRzXG4gICAqL1xuICBmdW5jdGlvbiBsaXRlcmFsRnJvbVBhcnRzKHBhcnRzKSB7XG4gICAgbGV0IHMgPSAnJztcbiAgICBmb3IgKGxldCBpPTA7IGk8cGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBsaXRlcmFsID0gcGFydHNbaV0ubGl0ZXJhbDtcbiAgICAgIHMgKz0gbGl0ZXJhbCB8fCAnJztcbiAgICB9XG4gICAgcmV0dXJuIHM7XG4gIH1cblxuICAvKipcbiAgICogUGFyc2VzIGFuIGV4cHJlc3Npb24gc3RyaW5nIGZvciBhIG1ldGhvZCBzaWduYXR1cmUsIGFuZCByZXR1cm5zIGEgbWV0YWRhdGFcbiAgICogZGVzY3JpYmluZyB0aGUgbWV0aG9kIGluIHRlcm1zIG9mIGBtZXRob2ROYW1lYCwgYHN0YXRpY2AgKHdoZXRoZXIgYWxsIHRoZVxuICAgKiBhcmd1bWVudHMgYXJlIGxpdGVyYWxzKSwgYW5kIGFuIGFycmF5IG9mIGBhcmdzYFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXhwcmVzc2lvbiBUaGUgZXhwcmVzc2lvbiB0byBwYXJzZVxuICAgKiBAcmV0dXJuIHs/TWV0aG9kU2lnbmF0dXJlfSBUaGUgbWV0aG9kIG1ldGFkYXRhIG9iamVjdCBpZiBhIG1ldGhvZCBleHByZXNzaW9uIHdhc1xuICAgKiAgIGZvdW5kLCBvdGhlcndpc2UgYHVuZGVmaW5lZGBcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIHBhcnNlTWV0aG9kKGV4cHJlc3Npb24pIHtcbiAgICAvLyB0cmllcyB0byBtYXRjaCB2YWxpZCBqYXZhc2NyaXB0IHByb3BlcnR5IG5hbWVzXG4gICAgbGV0IG0gPSBleHByZXNzaW9uLm1hdGNoKC8oW15cXHNdKz8pXFwoKFtcXHNcXFNdKilcXCkvKTtcbiAgICBpZiAobSkge1xuICAgICAgbGV0IG1ldGhvZE5hbWUgPSBtWzFdO1xuICAgICAgbGV0IHNpZyA9IHsgbWV0aG9kTmFtZSwgc3RhdGljOiB0cnVlLCBhcmdzOiBlbXB0eUFycmF5IH07XG4gICAgICBpZiAobVsyXS50cmltKCkpIHtcbiAgICAgICAgLy8gcmVwbGFjZSBlc2NhcGVkIGNvbW1hcyB3aXRoIGNvbW1hIGVudGl0eSwgc3BsaXQgb24gdW4tZXNjYXBlZCBjb21tYXNcbiAgICAgICAgbGV0IGFyZ3MgPSBtWzJdLnJlcGxhY2UoL1xcXFwsL2csICcmY29tbWE7Jykuc3BsaXQoJywnKTtcbiAgICAgICAgcmV0dXJuIHBhcnNlQXJncyhhcmdzLCBzaWcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHNpZztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcbiAgICogUGFyc2VzIGFuIGFycmF5IG9mIGFyZ3VtZW50cyBhbmQgc2V0cyB0aGUgYGFyZ3NgIHByb3BlcnR5IG9mIHRoZSBzdXBwbGllZFxuICAgKiBzaWduYXR1cmUgbWV0YWRhdGEgb2JqZWN0LiBTZXRzIHRoZSBgc3RhdGljYCBwcm9wZXJ0eSB0byBmYWxzZSBpZiBhbnlcbiAgICogYXJndW1lbnQgaXMgYSBub24tbGl0ZXJhbC5cbiAgICpcbiAgICogQHBhcmFtIHshQXJyYXk8c3RyaW5nPn0gYXJnTGlzdCBBcnJheSBvZiBhcmd1bWVudCBuYW1lc1xuICAgKiBAcGFyYW0geyFNZXRob2RTaWduYXR1cmV9IHNpZyBNZXRob2Qgc2lnbmF0dXJlIG1ldGFkYXRhIG9iamVjdFxuICAgKiBAcmV0dXJuIHshTWV0aG9kU2lnbmF0dXJlfSBUaGUgdXBkYXRlZCBzaWduYXR1cmUgbWV0YWRhdGEgb2JqZWN0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBwYXJzZUFyZ3MoYXJnTGlzdCwgc2lnKSB7XG4gICAgc2lnLmFyZ3MgPSBhcmdMaXN0Lm1hcChmdW5jdGlvbihyYXdBcmcpIHtcbiAgICAgIGxldCBhcmcgPSBwYXJzZUFyZyhyYXdBcmcpO1xuICAgICAgaWYgKCFhcmcubGl0ZXJhbCkge1xuICAgICAgICBzaWcuc3RhdGljID0gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJnO1xuICAgIH0sIHRoaXMpO1xuICAgIHJldHVybiBzaWc7XG4gIH1cblxuICAvKipcbiAgICogUGFyc2VzIGFuIGluZGl2aWR1YWwgYXJndW1lbnQsIGFuZCByZXR1cm5zIGFuIGFyZ3VtZW50IG1ldGFkYXRhIG9iamVjdFxuICAgKiB3aXRoIHRoZSBmb2xsb3dpbmcgZmllbGRzOlxuICAgKlxuICAgKiAgIHtcbiAgICogICAgIHZhbHVlOiAncHJvcCcsICAgICAgICAvLyBwcm9wZXJ0eS9wYXRoIG9yIGxpdGVyYWwgdmFsdWVcbiAgICogICAgIGxpdGVyYWw6IGZhbHNlLCAgICAgICAvLyB3aGV0aGVyIGFyZ3VtZW50IGlzIGEgbGl0ZXJhbFxuICAgKiAgICAgc3RydWN0dXJlZDogZmFsc2UsICAgIC8vIHdoZXRoZXIgdGhlIHByb3BlcnR5IGlzIGEgcGF0aFxuICAgKiAgICAgcm9vdFByb3BlcnR5OiAncHJvcCcsIC8vIHRoZSByb290IHByb3BlcnR5IG9mIHRoZSBwYXRoXG4gICAqICAgICB3aWxkY2FyZDogZmFsc2UgICAgICAgLy8gd2hldGhlciB0aGUgYXJndW1lbnQgd2FzIGEgd2lsZGNhcmQgJy4qJyBwYXRoXG4gICAqICAgfVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmF3QXJnIFRoZSBzdHJpbmcgdmFsdWUgb2YgdGhlIGFyZ3VtZW50XG4gICAqIEByZXR1cm4geyFNZXRob2RBcmd9IEFyZ3VtZW50IG1ldGFkYXRhIG9iamVjdFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gcGFyc2VBcmcocmF3QXJnKSB7XG4gICAgLy8gY2xlYW4gdXAgd2hpdGVzcGFjZVxuICAgIGxldCBhcmcgPSByYXdBcmcudHJpbSgpXG4gICAgICAvLyByZXBsYWNlIGNvbW1hIGVudGl0eSB3aXRoIGNvbW1hXG4gICAgICAucmVwbGFjZSgvJmNvbW1hOy9nLCAnLCcpXG4gICAgICAvLyByZXBhaXIgZXh0cmEgZXNjYXBlIHNlcXVlbmNlczsgbm90ZSBvbmx5IGNvbW1hcyBzdHJpY3RseSBuZWVkXG4gICAgICAvLyBlc2NhcGluZywgYnV0IHdlIGFsbG93IGFueSBvdGhlciBjaGFyIHRvIGJlIGVzY2FwZWQgc2luY2UgaXRzXG4gICAgICAvLyBsaWtlbHkgdXNlcnMgd2lsbCBkbyB0aGlzXG4gICAgICAucmVwbGFjZSgvXFxcXCguKS9nLCAnXFwkMScpXG4gICAgICA7XG4gICAgLy8gYmFzaWMgYXJndW1lbnQgZGVzY3JpcHRvclxuICAgIGxldCBhID0ge1xuICAgICAgbmFtZTogYXJnLFxuICAgICAgdmFsdWU6ICcnLFxuICAgICAgbGl0ZXJhbDogZmFsc2VcbiAgICB9O1xuICAgIC8vIGRldGVjdCBsaXRlcmFsIHZhbHVlIChtdXN0IGJlIFN0cmluZyBvciBOdW1iZXIpXG4gICAgbGV0IGZjID0gYXJnWzBdO1xuICAgIGlmIChmYyA9PT0gJy0nKSB7XG4gICAgICBmYyA9IGFyZ1sxXTtcbiAgICB9XG4gICAgaWYgKGZjID49ICcwJyAmJiBmYyA8PSAnOScpIHtcbiAgICAgIGZjID0gJyMnO1xuICAgIH1cbiAgICBzd2l0Y2goZmMpIHtcbiAgICAgIGNhc2UgXCInXCI6XG4gICAgICBjYXNlICdcIic6XG4gICAgICAgIGEudmFsdWUgPSBhcmcuc2xpY2UoMSwgLTEpO1xuICAgICAgICBhLmxpdGVyYWwgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJyMnOlxuICAgICAgICBhLnZhbHVlID0gTnVtYmVyKGFyZyk7XG4gICAgICAgIGEubGl0ZXJhbCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAvLyBpZiBub3QgbGl0ZXJhbCwgbG9vayBmb3Igc3RydWN0dXJlZCBwYXRoXG4gICAgaWYgKCFhLmxpdGVyYWwpIHtcbiAgICAgIGEucm9vdFByb3BlcnR5ID0gUG9seW1lci5QYXRoLnJvb3QoYXJnKTtcbiAgICAgIC8vIGRldGVjdCBzdHJ1Y3R1cmVkIHBhdGggKGhhcyBkb3RzKVxuICAgICAgYS5zdHJ1Y3R1cmVkID0gUG9seW1lci5QYXRoLmlzUGF0aChhcmcpO1xuICAgICAgaWYgKGEuc3RydWN0dXJlZCkge1xuICAgICAgICBhLndpbGRjYXJkID0gKGFyZy5zbGljZSgtMikgPT0gJy4qJyk7XG4gICAgICAgIGlmIChhLndpbGRjYXJkKSB7XG4gICAgICAgICAgYS5uYW1lID0gYXJnLnNsaWNlKDAsIC0yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHYXRoZXIgdGhlIGFyZ3VtZW50IHZhbHVlcyBmb3IgYSBtZXRob2Qgc3BlY2lmaWVkIGluIHRoZSBwcm92aWRlZCBhcnJheVxuICAgKiBvZiBhcmd1bWVudCBtZXRhZGF0YS5cbiAgICpcbiAgICogVGhlIGBwYXRoYCBhbmQgYHZhbHVlYCBhcmd1bWVudHMgYXJlIHVzZWQgdG8gZmlsbCBpbiB3aWxkY2FyZCBkZXNjcmlwdG9yXG4gICAqIHdoZW4gdGhlIG1ldGhvZCBpcyBiZWluZyBjYWxsZWQgYXMgYSByZXN1bHQgb2YgYSBwYXRoIG5vdGlmaWNhdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgSW5zdGFuY2UgZGF0YSBzdG9yYWdlIG9iamVjdCB0byByZWFkIHByb3BlcnRpZXMgZnJvbVxuICAgKiBAcGFyYW0geyFBcnJheTwhTWV0aG9kQXJnPn0gYXJncyBBcnJheSBvZiBhcmd1bWVudCBtZXRhZGF0YVxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBQcm9wZXJ0eS9wYXRoIG5hbWUgdGhhdCB0cmlnZ2VyZWQgdGhlIG1ldGhvZCBlZmZlY3RcbiAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzIEJhZyBvZiBjdXJyZW50IHByb3BlcnR5IGNoYW5nZXNcbiAgICogQHJldHVybiB7QXJyYXk8Kj59IEFycmF5IG9mIGFyZ3VtZW50IHZhbHVlc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gbWFyc2hhbEFyZ3MoZGF0YSwgYXJncywgcGF0aCwgcHJvcHMpIHtcbiAgICBsZXQgdmFsdWVzID0gW107XG4gICAgZm9yIChsZXQgaT0wLCBsPWFyZ3MubGVuZ3RoOyBpPGw7IGkrKykge1xuICAgICAgbGV0IGFyZyA9IGFyZ3NbaV07XG4gICAgICBsZXQgbmFtZSA9IGFyZy5uYW1lO1xuICAgICAgbGV0IHY7XG4gICAgICBpZiAoYXJnLmxpdGVyYWwpIHtcbiAgICAgICAgdiA9IGFyZy52YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChhcmcuc3RydWN0dXJlZCkge1xuICAgICAgICAgIHYgPSBQb2x5bWVyLlBhdGguZ2V0KGRhdGEsIG5hbWUpO1xuICAgICAgICAgIC8vIHdoZW4gZGF0YSBpcyBub3Qgc3RvcmVkIGUuZy4gYHNwbGljZXNgXG4gICAgICAgICAgaWYgKHYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdiA9IHByb3BzW25hbWVdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2ID0gZGF0YVtuYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGFyZy53aWxkY2FyZCkge1xuICAgICAgICAvLyBPbmx5IHNlbmQgdGhlIGFjdHVhbCBwYXRoIGNoYW5nZWQgaW5mbyBpZiB0aGUgY2hhbmdlIHRoYXRcbiAgICAgICAgLy8gY2F1c2VkIHRoZSBvYnNlcnZlciB0byBydW4gbWF0Y2hlZCB0aGUgd2lsZGNhcmRcbiAgICAgICAgbGV0IGJhc2VDaGFuZ2VkID0gKG5hbWUuaW5kZXhPZihwYXRoICsgJy4nKSA9PT0gMCk7XG4gICAgICAgIGxldCBtYXRjaGVzID0gKHBhdGguaW5kZXhPZihuYW1lKSA9PT0gMCAmJiAhYmFzZUNoYW5nZWQpO1xuICAgICAgICB2YWx1ZXNbaV0gPSB7XG4gICAgICAgICAgcGF0aDogbWF0Y2hlcyA/IHBhdGggOiBuYW1lLFxuICAgICAgICAgIHZhbHVlOiBtYXRjaGVzID8gcHJvcHNbcGF0aF0gOiB2LFxuICAgICAgICAgIGJhc2U6IHZcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlc1tpXSA9IHY7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZXM7XG4gIH1cblxuICAvLyBkYXRhIGFwaVxuXG4gIC8qKlxuICAgKiBTZW5kcyBhcnJheSBzcGxpY2Ugbm90aWZpY2F0aW9ucyAoYC5zcGxpY2VzYCBhbmQgYC5sZW5ndGhgKVxuICAgKlxuICAgKiBOb3RlOiB0aGlzIGltcGxlbWVudGF0aW9uIG9ubHkgYWNjZXB0cyBub3JtYWxpemVkIHBhdGhzXG4gICAqXG4gICAqIEBwYXJhbSB7IVByb3BlcnR5RWZmZWN0c1R5cGV9IGluc3QgSW5zdGFuY2UgdG8gc2VuZCBub3RpZmljYXRpb25zIHRvXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0aGUgbXV0YXRpb25zIG9jY3VycmVkIG9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIHRoZSBhcnJheSB0aGF0IHdhcyBtdXRhdGVkXG4gICAqIEBwYXJhbSB7QXJyYXl9IHNwbGljZXMgQXJyYXkgb2Ygc3BsaWNlIHJlY29yZHNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIG5vdGlmeVNwbGljZXMoaW5zdCwgYXJyYXksIHBhdGgsIHNwbGljZXMpIHtcbiAgICBsZXQgc3BsaWNlc1BhdGggPSBwYXRoICsgJy5zcGxpY2VzJztcbiAgICBpbnN0Lm5vdGlmeVBhdGgoc3BsaWNlc1BhdGgsIHsgaW5kZXhTcGxpY2VzOiBzcGxpY2VzIH0pO1xuICAgIGluc3Qubm90aWZ5UGF0aChwYXRoICsgJy5sZW5ndGgnLCBhcnJheS5sZW5ndGgpO1xuICAgIC8vIE51bGwgaGVyZSB0byBhbGxvdyBwb3RlbnRpYWxseSBsYXJnZSBzcGxpY2UgcmVjb3JkcyB0byBiZSBHQydlZC5cbiAgICBpbnN0Ll9fZGF0YVtzcGxpY2VzUGF0aF0gPSB7aW5kZXhTcGxpY2VzOiBudWxsfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgc3BsaWNlIHJlY29yZCBhbmQgc2VuZHMgYW4gYXJyYXkgc3BsaWNlIG5vdGlmaWNhdGlvbiBmb3JcbiAgICogdGhlIGRlc2NyaWJlZCBtdXRhdGlvblxuICAgKlxuICAgKiBOb3RlOiB0aGlzIGltcGxlbWVudGF0aW9uIG9ubHkgYWNjZXB0cyBub3JtYWxpemVkIHBhdGhzXG4gICAqXG4gICAqIEBwYXJhbSB7IVByb3BlcnR5RWZmZWN0c1R5cGV9IGluc3QgSW5zdGFuY2UgdG8gc2VuZCBub3RpZmljYXRpb25zIHRvXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0aGUgbXV0YXRpb25zIG9jY3VycmVkIG9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIHRoZSBhcnJheSB0aGF0IHdhcyBtdXRhdGVkXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleCBhdCB3aGljaCB0aGUgYXJyYXkgbXV0YXRpb24gb2NjdXJyZWRcbiAgICogQHBhcmFtIHtudW1iZXJ9IGFkZGVkQ291bnQgTnVtYmVyIG9mIGFkZGVkIGl0ZW1zXG4gICAqIEBwYXJhbSB7QXJyYXl9IHJlbW92ZWQgQXJyYXkgb2YgcmVtb3ZlZCBpdGVtc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gbm90aWZ5U3BsaWNlKGluc3QsIGFycmF5LCBwYXRoLCBpbmRleCwgYWRkZWRDb3VudCwgcmVtb3ZlZCkge1xuICAgIG5vdGlmeVNwbGljZXMoaW5zdCwgYXJyYXksIHBhdGgsIFt7XG4gICAgICBpbmRleDogaW5kZXgsXG4gICAgICBhZGRlZENvdW50OiBhZGRlZENvdW50LFxuICAgICAgcmVtb3ZlZDogcmVtb3ZlZCxcbiAgICAgIG9iamVjdDogYXJyYXksXG4gICAgICB0eXBlOiAnc3BsaWNlJ1xuICAgIH1dKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIHVwcGVyLWNhc2VkIHZlcnNpb24gb2YgdGhlIHN0cmluZy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgU3RyaW5nIHRvIHVwcGVyY2FzZVxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFVwcGVyY2FzZWQgc3RyaW5nXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiB1cHBlcihuYW1lKSB7XG4gICAgcmV0dXJuIG5hbWVbMF0udG9VcHBlckNhc2UoKSArIG5hbWUuc3Vic3RyaW5nKDEpO1xuICB9XG5cbiAgLyoqXG4gICAqIEVsZW1lbnQgY2xhc3MgbWl4aW4gdGhhdCBwcm92aWRlcyBtZXRhLXByb2dyYW1taW5nIGZvciBQb2x5bWVyJ3MgdGVtcGxhdGVcbiAgICogYmluZGluZyBhbmQgZGF0YSBvYnNlcnZhdGlvbiAoY29sbGVjdGl2ZWx5LCBcInByb3BlcnR5IGVmZmVjdHNcIikgc3lzdGVtLlxuICAgKlxuICAgKiBUaGlzIG1peGluIHVzZXMgcHJvdmlkZXMgdGhlIGZvbGxvd2luZyBrZXkgc3RhdGljIG1ldGhvZHMgZm9yIGFkZGluZ1xuICAgKiBwcm9wZXJ0eSBlZmZlY3RzIHRvIGFuIGVsZW1lbnQgY2xhc3M6XG4gICAqIC0gYGFkZFByb3BlcnR5RWZmZWN0YFxuICAgKiAtIGBjcmVhdGVQcm9wZXJ0eU9ic2VydmVyYFxuICAgKiAtIGBjcmVhdGVNZXRob2RPYnNlcnZlcmBcbiAgICogLSBgY3JlYXRlTm90aWZ5aW5nUHJvcGVydHlgXG4gICAqIC0gYGNyZWF0ZVJlYWRPbmx5UHJvcGVydHlgXG4gICAqIC0gYGNyZWF0ZVJlZmxlY3RlZFByb3BlcnR5YFxuICAgKiAtIGBjcmVhdGVDb21wdXRlZFByb3BlcnR5YFxuICAgKiAtIGBiaW5kVGVtcGxhdGVgXG4gICAqXG4gICAqIEVhY2ggbWV0aG9kIGNyZWF0ZXMgb25lIG9yIG1vcmUgcHJvcGVydHkgYWNjZXNzb3JzLCBhbG9uZyB3aXRoIG1ldGFkYXRhXG4gICAqIHVzZWQgYnkgdGhpcyBtaXhpbidzIGltcGxlbWVudGF0aW9uIG9mIGBfcHJvcGVydGllc0NoYW5nZWRgIHRvIHBlcmZvcm1cbiAgICogdGhlIHByb3BlcnR5IGVmZmVjdHMuXG4gICAqXG4gICAqIFVuZGVyc2NvcmVkIHZlcnNpb25zIG9mIHRoZSBhYm92ZSBtZXRob2RzIGFsc28gZXhpc3Qgb24gdGhlIGVsZW1lbnRcbiAgICogcHJvdG90eXBlIGZvciBhZGRpbmcgcHJvcGVydHkgZWZmZWN0cyBvbiBpbnN0YW5jZXMgYXQgcnVudGltZS5cbiAgICpcbiAgICogTm90ZSB0aGF0IHRoaXMgbWl4aW4gb3ZlcnJpZGVzIHNldmVyYWwgYFByb3BlcnR5QWNjZXNzb3JzYCBtZXRob2RzLCBpblxuICAgKiBtYW55IGNhc2VzIHRvIG1haW50YWluIGd1YXJhbnRlZXMgcHJvdmlkZWQgYnkgdGhlIFBvbHltZXIgMS54IGZlYXR1cmVzO1xuICAgKiBub3RhYmx5IGl0IGNoYW5nZXMgcHJvcGVydHkgYWNjZXNzb3JzIHRvIGJlIHN5bmNocm9ub3VzIGJ5IGRlZmF1bHRcbiAgICogd2hlcmVhcyB0aGUgZGVmYXVsdCB3aGVuIHVzaW5nIGBQcm9wZXJ0eUFjY2Vzc29yc2Agc3RhbmRhbG9uZSBpcyB0byBiZVxuICAgKiBhc3luYyBieSBkZWZhdWx0LlxuICAgKlxuICAgKiBAbWl4aW5GdW5jdGlvblxuICAgKiBAcG9seW1lclxuICAgKiBAYXBwbGllc01peGluIFBvbHltZXIuVGVtcGxhdGVTdGFtcFxuICAgKiBAYXBwbGllc01peGluIFBvbHltZXIuUHJvcGVydHlBY2Nlc3NvcnNcbiAgICogQG1lbWJlcm9mIFBvbHltZXJcbiAgICogQHN1bW1hcnkgRWxlbWVudCBjbGFzcyBtaXhpbiB0aGF0IHByb3ZpZGVzIG1ldGEtcHJvZ3JhbW1pbmcgZm9yIFBvbHltZXInc1xuICAgKiB0ZW1wbGF0ZSBiaW5kaW5nIGFuZCBkYXRhIG9ic2VydmF0aW9uIHN5c3RlbS5cbiAgICovXG4gIFBvbHltZXIuUHJvcGVydHlFZmZlY3RzID0gUG9seW1lci5kZWR1cGluZ01peGluKHN1cGVyQ2xhc3MgPT4ge1xuXG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQGV4dGVuZHMge3N1cGVyQ2xhc3N9XG4gICAgICogQGltcGxlbWVudHMge1BvbHltZXJfUHJvcGVydHlBY2Nlc3NvcnN9XG4gICAgICogQGltcGxlbWVudHMge1BvbHltZXJfVGVtcGxhdGVTdGFtcH1cbiAgICAgKiBAdW5yZXN0cmljdGVkXG4gICAgICovXG4gICAgY29uc3QgcHJvcGVydHlFZmZlY3RzQmFzZSA9IFBvbHltZXIuVGVtcGxhdGVTdGFtcChQb2x5bWVyLlByb3BlcnR5QWNjZXNzb3JzKHN1cGVyQ2xhc3MpKTtcblxuICAgIC8qKlxuICAgICAqIEBwb2x5bWVyXG4gICAgICogQG1peGluQ2xhc3NcbiAgICAgKiBAaW1wbGVtZW50cyB7UG9seW1lcl9Qcm9wZXJ0eUVmZmVjdHN9XG4gICAgICogQGV4dGVuZHMge3Byb3BlcnR5RWZmZWN0c0Jhc2V9XG4gICAgICogQHVucmVzdHJpY3RlZFxuICAgICAqL1xuICAgIGNsYXNzIFByb3BlcnR5RWZmZWN0cyBleHRlbmRzIHByb3BlcnR5RWZmZWN0c0Jhc2Uge1xuXG4gICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLyoqIEB0eXBlIHtib29sZWFufSAqL1xuICAgICAgICB0aGlzLl9fZGF0YUNsaWVudHNSZWFkeTtcbiAgICAgICAgLyoqIEB0eXBlIHtBcnJheX0gKi9cbiAgICAgICAgdGhpcy5fX2RhdGFQZW5kaW5nQ2xpZW50cztcbiAgICAgICAgLyoqIEB0eXBlIHtPYmplY3R9ICovXG4gICAgICAgIHRoaXMuX19kYXRhVG9Ob3RpZnk7XG4gICAgICAgIC8qKiBAdHlwZSB7T2JqZWN0fSAqL1xuICAgICAgICB0aGlzLl9fZGF0YUxpbmtlZFBhdGhzO1xuICAgICAgICAvKiogQHR5cGUge2Jvb2xlYW59ICovXG4gICAgICAgIHRoaXMuX19kYXRhSGFzUGF0aHM7XG4gICAgICAgIC8qKiBAdHlwZSB7T2JqZWN0fSAqL1xuICAgICAgICB0aGlzLl9fZGF0YUNvbXBvdW5kU3RvcmFnZTtcbiAgICAgICAgLyoqIEB0eXBlIHtQb2x5bWVyX1Byb3BlcnR5RWZmZWN0c30gKi9cbiAgICAgICAgdGhpcy5fX2RhdGFIb3N0O1xuICAgICAgICAvKiogQHR5cGUgeyFPYmplY3R9ICovXG4gICAgICAgIHRoaXMuX19kYXRhVGVtcDtcbiAgICAgICAgLyoqIEB0eXBlIHtib29sZWFufSAqL1xuICAgICAgICB0aGlzLl9fZGF0YUNsaWVudHNJbml0aWFsaXplZDtcbiAgICAgICAgLyoqIEB0eXBlIHshT2JqZWN0fSAqL1xuICAgICAgICB0aGlzLl9fZGF0YTtcbiAgICAgICAgLyoqIEB0eXBlIHshT2JqZWN0fSAqL1xuICAgICAgICB0aGlzLl9fZGF0YVBlbmRpbmc7XG4gICAgICAgIC8qKiBAdHlwZSB7IU9iamVjdH0gKi9cbiAgICAgICAgdGhpcy5fX2RhdGFPbGQ7XG4gICAgICAgIC8qKiBAdHlwZSB7T2JqZWN0fSAqL1xuICAgICAgICB0aGlzLl9fY29tcHV0ZUVmZmVjdHM7XG4gICAgICAgIC8qKiBAdHlwZSB7T2JqZWN0fSAqL1xuICAgICAgICB0aGlzLl9fcmVmbGVjdEVmZmVjdHM7XG4gICAgICAgIC8qKiBAdHlwZSB7T2JqZWN0fSAqL1xuICAgICAgICB0aGlzLl9fbm90aWZ5RWZmZWN0cztcbiAgICAgICAgLyoqIEB0eXBlIHtPYmplY3R9ICovXG4gICAgICAgIHRoaXMuX19wcm9wYWdhdGVFZmZlY3RzO1xuICAgICAgICAvKiogQHR5cGUge09iamVjdH0gKi9cbiAgICAgICAgdGhpcy5fX29ic2VydmVFZmZlY3RzO1xuICAgICAgICAvKiogQHR5cGUge09iamVjdH0gKi9cbiAgICAgICAgdGhpcy5fX3JlYWRPbmx5O1xuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy5fX2RhdGFDb3VudGVyO1xuICAgICAgICAvKiogQHR5cGUgeyFUZW1wbGF0ZUluZm99ICovXG4gICAgICAgIHRoaXMuX190ZW1wbGF0ZUluZm87XG4gICAgICB9XG5cbiAgICAgIGdldCBQUk9QRVJUWV9FRkZFQ1RfVFlQRVMoKSB7XG4gICAgICAgIHJldHVybiBUWVBFUztcbiAgICAgIH1cblxuICAgICAgX2luaXRpYWxpemVQcm9wZXJ0aWVzKCkge1xuICAgICAgICBzdXBlci5faW5pdGlhbGl6ZVByb3BlcnRpZXMoKTtcbiAgICAgICAgaG9zdFN0YWNrLnJlZ2lzdGVySG9zdCh0aGlzKTtcbiAgICAgICAgdGhpcy5fX2RhdGFDbGllbnRzUmVhZHkgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fX2RhdGFQZW5kaW5nQ2xpZW50cyA9IG51bGw7XG4gICAgICAgIHRoaXMuX19kYXRhVG9Ob3RpZnkgPSBudWxsO1xuICAgICAgICB0aGlzLl9fZGF0YUxpbmtlZFBhdGhzID0gbnVsbDtcbiAgICAgICAgdGhpcy5fX2RhdGFIYXNQYXRocyA9IGZhbHNlO1xuICAgICAgICAvLyBNYXkgYmUgc2V0IG9uIGluc3RhbmNlIHByaW9yIHRvIHVwZ3JhZGVcbiAgICAgICAgdGhpcy5fX2RhdGFDb21wb3VuZFN0b3JhZ2UgPSB0aGlzLl9fZGF0YUNvbXBvdW5kU3RvcmFnZSB8fCBudWxsO1xuICAgICAgICB0aGlzLl9fZGF0YUhvc3QgPSB0aGlzLl9fZGF0YUhvc3QgfHwgbnVsbDtcbiAgICAgICAgdGhpcy5fX2RhdGFUZW1wID0ge307XG4gICAgICAgIHRoaXMuX19kYXRhQ2xpZW50c0luaXRpYWxpemVkID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogT3ZlcnJpZGVzIGBQb2x5bWVyLlByb3BlcnR5QWNjZXNzb3JzYCBpbXBsZW1lbnRhdGlvbiB0byBwcm92aWRlIGFcbiAgICAgICAqIG1vcmUgZWZmaWNpZW50IGltcGxlbWVudGF0aW9uIG9mIGluaXRpYWxpemluZyBwcm9wZXJ0aWVzIGZyb21cbiAgICAgICAqIHRoZSBwcm90b3R5cGUgb24gdGhlIGluc3RhbmNlLlxuICAgICAgICpcbiAgICAgICAqIEBvdmVycmlkZVxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzIFByb3BlcnRpZXMgdG8gaW5pdGlhbGl6ZSBvbiB0aGUgcHJvdG90eXBlXG4gICAgICAgKi9cbiAgICAgIF9pbml0aWFsaXplUHJvdG9Qcm9wZXJ0aWVzKHByb3BzKSB7XG4gICAgICAgIHRoaXMuX19kYXRhID0gT2JqZWN0LmNyZWF0ZShwcm9wcyk7XG4gICAgICAgIHRoaXMuX19kYXRhUGVuZGluZyA9IE9iamVjdC5jcmVhdGUocHJvcHMpO1xuICAgICAgICB0aGlzLl9fZGF0YU9sZCA9IHt9O1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIE92ZXJyaWRlcyBgUG9seW1lci5Qcm9wZXJ0eUFjY2Vzc29yc2AgaW1wbGVtZW50YXRpb24gdG8gYXZvaWQgc2V0dGluZ1xuICAgICAgICogYF9zZXRQcm9wZXJ0eWAncyBgc2hvdWxkTm90aWZ5OiB0cnVlYC5cbiAgICAgICAqXG4gICAgICAgKiBAb3ZlcnJpZGVcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBQcm9wZXJ0aWVzIHRvIGluaXRpYWxpemUgb24gdGhlIGluc3RhbmNlXG4gICAgICAgKi9cbiAgICAgIF9pbml0aWFsaXplSW5zdGFuY2VQcm9wZXJ0aWVzKHByb3BzKSB7XG4gICAgICAgIGxldCByZWFkT25seSA9IHRoaXNbVFlQRVMuUkVBRF9PTkxZXTtcbiAgICAgICAgZm9yIChsZXQgcHJvcCBpbiBwcm9wcykge1xuICAgICAgICAgIGlmICghcmVhZE9ubHkgfHwgIXJlYWRPbmx5W3Byb3BdKSB7XG4gICAgICAgICAgICB0aGlzLl9fZGF0YVBlbmRpbmcgPSB0aGlzLl9fZGF0YVBlbmRpbmcgfHwge307XG4gICAgICAgICAgICB0aGlzLl9fZGF0YU9sZCA9IHRoaXMuX19kYXRhT2xkIHx8IHt9O1xuICAgICAgICAgICAgdGhpcy5fX2RhdGFbcHJvcF0gPSB0aGlzLl9fZGF0YVBlbmRpbmdbcHJvcF0gPSBwcm9wc1twcm9wXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gUHJvdG90eXBlIHNldHVwIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgLyoqXG4gICAgICAgKiBFcXVpdmFsZW50IHRvIHN0YXRpYyBgYWRkUHJvcGVydHlFZmZlY3RgIEFQSSBidXQgY2FuIGJlIGNhbGxlZCBvblxuICAgICAgICogYW4gaW5zdGFuY2UgdG8gYWRkIGVmZmVjdHMgYXQgcnVudGltZS4gIFNlZSB0aGF0IG1ldGhvZCBmb3JcbiAgICAgICAqIGZ1bGwgQVBJIGRvY3MuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IHRoYXQgc2hvdWxkIHRyaWdnZXIgdGhlIGVmZmVjdFxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgRWZmZWN0IHR5cGUsIGZyb20gdGhpcy5QUk9QRVJUWV9FRkZFQ1RfVFlQRVNcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0PX0gZWZmZWN0IEVmZmVjdCBtZXRhZGF0YSBvYmplY3RcbiAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAqL1xuICAgICAgX2FkZFByb3BlcnR5RWZmZWN0KHByb3BlcnR5LCB0eXBlLCBlZmZlY3QpIHtcbiAgICAgICAgdGhpcy5fY3JlYXRlUHJvcGVydHlBY2Nlc3Nvcihwcm9wZXJ0eSwgdHlwZSA9PSBUWVBFUy5SRUFEX09OTFkpO1xuICAgICAgICAvLyBlZmZlY3RzIGFyZSBhY2N1bXVsYXRlZCBpbnRvIGFycmF5cyBwZXIgcHJvcGVydHkgYmFzZWQgb24gdHlwZVxuICAgICAgICBsZXQgZWZmZWN0cyA9IGVuc3VyZU93bkVmZmVjdE1hcCh0aGlzLCB0eXBlKVtwcm9wZXJ0eV07XG4gICAgICAgIGlmICghZWZmZWN0cykge1xuICAgICAgICAgIGVmZmVjdHMgPSB0aGlzW3R5cGVdW3Byb3BlcnR5XSA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGVmZmVjdHMucHVzaChlZmZlY3QpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJlbW92ZXMgdGhlIGdpdmVuIHByb3BlcnR5IGVmZmVjdC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgdGhlIGVmZmVjdCB3YXMgYXNzb2NpYXRlZCB3aXRoXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBFZmZlY3QgdHlwZSwgZnJvbSB0aGlzLlBST1BFUlRZX0VGRkVDVF9UWVBFU1xuICAgICAgICogQHBhcmFtIHtPYmplY3Q9fSBlZmZlY3QgRWZmZWN0IG1ldGFkYXRhIG9iamVjdCB0byByZW1vdmVcbiAgICAgICAqL1xuICAgICAgX3JlbW92ZVByb3BlcnR5RWZmZWN0KHByb3BlcnR5LCB0eXBlLCBlZmZlY3QpIHtcbiAgICAgICAgbGV0IGVmZmVjdHMgPSBlbnN1cmVPd25FZmZlY3RNYXAodGhpcywgdHlwZSlbcHJvcGVydHldO1xuICAgICAgICBsZXQgaWR4ID0gZWZmZWN0cy5pbmRleE9mKGVmZmVjdCk7XG4gICAgICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgICAgIGVmZmVjdHMuc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGN1cnJlbnQgcHJvdG90eXBlL2luc3RhbmNlIGhhcyBhIHByb3BlcnR5IGVmZmVjdFxuICAgICAgICogb2YgYSBjZXJ0YWluIHR5cGUuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IG5hbWVcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nPX0gdHlwZSBFZmZlY3QgdHlwZSwgZnJvbSB0aGlzLlBST1BFUlRZX0VGRkVDVF9UWVBFU1xuICAgICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgcHJvdG90eXBlL2luc3RhbmNlIGhhcyBhbiBlZmZlY3Qgb2YgdGhpcyB0eXBlXG4gICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgKi9cbiAgICAgIF9oYXNQcm9wZXJ0eUVmZmVjdChwcm9wZXJ0eSwgdHlwZSkge1xuICAgICAgICBsZXQgZWZmZWN0cyA9IHRoaXNbdHlwZV07XG4gICAgICAgIHJldHVybiBCb29sZWFuKGVmZmVjdHMgJiYgZWZmZWN0c1twcm9wZXJ0eV0pO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgY3VycmVudCBwcm90b3R5cGUvaW5zdGFuY2UgaGFzIGEgXCJyZWFkIG9ubHlcIlxuICAgICAgICogYWNjZXNzb3IgZm9yIHRoZSBnaXZlbiBwcm9wZXJ0eS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgbmFtZVxuICAgICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgcHJvdG90eXBlL2luc3RhbmNlIGhhcyBhbiBlZmZlY3Qgb2YgdGhpcyB0eXBlXG4gICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgKi9cbiAgICAgIF9oYXNSZWFkT25seUVmZmVjdChwcm9wZXJ0eSkge1xuICAgICAgICByZXR1cm4gdGhpcy5faGFzUHJvcGVydHlFZmZlY3QocHJvcGVydHksIFRZUEVTLlJFQURfT05MWSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBjdXJyZW50IHByb3RvdHlwZS9pbnN0YW5jZSBoYXMgYSBcIm5vdGlmeVwiXG4gICAgICAgKiBwcm9wZXJ0eSBlZmZlY3QgZm9yIHRoZSBnaXZlbiBwcm9wZXJ0eS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgbmFtZVxuICAgICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgcHJvdG90eXBlL2luc3RhbmNlIGhhcyBhbiBlZmZlY3Qgb2YgdGhpcyB0eXBlXG4gICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgKi9cbiAgICAgIF9oYXNOb3RpZnlFZmZlY3QocHJvcGVydHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hhc1Byb3BlcnR5RWZmZWN0KHByb3BlcnR5LCBUWVBFUy5OT1RJRlkpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgY3VycmVudCBwcm90b3R5cGUvaW5zdGFuY2UgaGFzIGEgXCJyZWZsZWN0IHRvIGF0dHJpYnV0ZVwiXG4gICAgICAgKiBwcm9wZXJ0eSBlZmZlY3QgZm9yIHRoZSBnaXZlbiBwcm9wZXJ0eS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgbmFtZVxuICAgICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgcHJvdG90eXBlL2luc3RhbmNlIGhhcyBhbiBlZmZlY3Qgb2YgdGhpcyB0eXBlXG4gICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgKi9cbiAgICAgIF9oYXNSZWZsZWN0RWZmZWN0KHByb3BlcnR5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oYXNQcm9wZXJ0eUVmZmVjdChwcm9wZXJ0eSwgVFlQRVMuUkVGTEVDVCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBjdXJyZW50IHByb3RvdHlwZS9pbnN0YW5jZSBoYXMgYSBcImNvbXB1dGVkXCJcbiAgICAgICAqIHByb3BlcnR5IGVmZmVjdCBmb3IgdGhlIGdpdmVuIHByb3BlcnR5LlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSBuYW1lXG4gICAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBwcm90b3R5cGUvaW5zdGFuY2UgaGFzIGFuIGVmZmVjdCBvZiB0aGlzIHR5cGVcbiAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAqL1xuICAgICAgX2hhc0NvbXB1dGVkRWZmZWN0KHByb3BlcnR5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oYXNQcm9wZXJ0eUVmZmVjdChwcm9wZXJ0eSwgVFlQRVMuQ09NUFVURSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFJ1bnRpbWUgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAvKipcbiAgICAgICAqIFNldHMgYSBwZW5kaW5nIHByb3BlcnR5IG9yIHBhdGguICBJZiB0aGUgcm9vdCBwcm9wZXJ0eSBvZiB0aGUgcGF0aCBpblxuICAgICAgICogcXVlc3Rpb24gaGFkIG5vIGFjY2Vzc29yLCB0aGUgcGF0aCBpcyBzZXQsIG90aGVyd2lzZSBpdCBpcyBlbnF1ZXVlZFxuICAgICAgICogdmlhIGBfc2V0UGVuZGluZ1Byb3BlcnR5YC5cbiAgICAgICAqXG4gICAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzb2xhdGVzIHJlbGF0aXZlbHkgZXhwZW5zaXZlIGZ1bmN0aW9uYWxpdHkgbmVjZXNzYXJ5XG4gICAgICAgKiBmb3IgdGhlIHB1YmxpYyBBUEkgKGBzZXRgLCBgc2V0UHJvcGVydGllc2AsIGBub3RpZnlQYXRoYCwgYW5kIHByb3BlcnR5XG4gICAgICAgKiBjaGFuZ2UgbGlzdGVuZXJzIHZpYSB7ey4uLn19IGJpbmRpbmdzKSwgc3VjaCB0aGF0IGl0IGlzIG9ubHkgZG9uZVxuICAgICAgICogd2hlbiBwYXRocyBlbnRlciB0aGUgc3lzdGVtLCBhbmQgbm90IGF0IGV2ZXJ5IHByb3BhZ2F0aW9uIHN0ZXAuICBJdFxuICAgICAgICogYWxzbyBzZXRzIGEgYF9fZGF0YUhhc1BhdGhzYCBmbGFnIG9uIHRoZSBpbnN0YW5jZSB3aGljaCBpcyB1c2VkIHRvXG4gICAgICAgKiBmYXN0LXBhdGggc2xvd2VyIHBhdGgtbWF0Y2hpbmcgY29kZSBpbiB0aGUgcHJvcGVydHkgZWZmZWN0cyBob3N0IHBhdGhzLlxuICAgICAgICpcbiAgICAgICAqIGBwYXRoYCBjYW4gYmUgYSBwYXRoIHN0cmluZyBvciBhcnJheSBvZiBwYXRoIHBhcnRzIGFzIGFjY2VwdGVkIGJ5IHRoZVxuICAgICAgICogcHVibGljIEFQSS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZyB8ICFBcnJheTxudW1iZXJ8c3RyaW5nPn0gcGF0aCBQYXRoIHRvIHNldFxuICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byBzZXRcbiAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IHNob3VsZE5vdGlmeSBTZXQgdG8gdHJ1ZSBpZiB0aGlzIGNoYW5nZSBzaG91bGRcbiAgICAgICAqICBjYXVzZSBhIHByb3BlcnR5IG5vdGlmaWNhdGlvbiBldmVudCBkaXNwYXRjaFxuICAgICAgICogQHBhcmFtIHtib29sZWFuPX0gaXNQYXRoTm90aWZpY2F0aW9uIElmIHRoZSBwYXRoIGJlaW5nIHNldCBpcyBhIHBhdGhcbiAgICAgICAqICAgbm90aWZpY2F0aW9uIG9mIGFuIGFscmVhZHkgY2hhbmdlZCB2YWx1ZSwgYXMgb3Bwb3NlZCB0byBhIHJlcXVlc3RcbiAgICAgICAqICAgdG8gc2V0IGFuZCBub3RpZnkgdGhlIGNoYW5nZS4gIEluIHRoZSBsYXR0ZXIgYGZhbHNlYCBjYXNlLCBhIGRpcnR5XG4gICAgICAgKiAgIGNoZWNrIGlzIHBlcmZvcm1lZCBhbmQgdGhlbiB0aGUgdmFsdWUgaXMgc2V0IHRvIHRoZSBwYXRoIGJlZm9yZVxuICAgICAgICogICBlbnF1ZXVpbmcgdGhlIHBlbmRpbmcgcHJvcGVydHkgY2hhbmdlLlxuICAgICAgICogQHJldHVybiB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZSBwcm9wZXJ0eS9wYXRoIHdhcyBlbnF1ZXVlZCBpblxuICAgICAgICogICB0aGUgcGVuZGluZyBjaGFuZ2VzIGJhZy5cbiAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAqL1xuICAgICAgX3NldFBlbmRpbmdQcm9wZXJ0eU9yUGF0aChwYXRoLCB2YWx1ZSwgc2hvdWxkTm90aWZ5LCBpc1BhdGhOb3RpZmljYXRpb24pIHtcbiAgICAgICAgaWYgKGlzUGF0aE5vdGlmaWNhdGlvbiB8fFxuICAgICAgICAgICAgUG9seW1lci5QYXRoLnJvb3QoQXJyYXkuaXNBcnJheShwYXRoKSA/IHBhdGhbMF0gOiBwYXRoKSAhPT0gcGF0aCkge1xuICAgICAgICAgIC8vIERpcnR5IGNoZWNrIGNoYW5nZXMgYmVpbmcgc2V0IHRvIGEgcGF0aCBhZ2FpbnN0IHRoZSBhY3R1YWwgb2JqZWN0LFxuICAgICAgICAgIC8vIHNpbmNlIHRoaXMgaXMgdGhlIGVudHJ5IHBvaW50IGZvciBwYXRocyBpbnRvIHRoZSBzeXN0ZW07IGZyb20gaGVyZVxuICAgICAgICAgIC8vIHRoZSBvbmx5IGRpcnR5IGNoZWNrcyBhcmUgYWdhaW5zdCB0aGUgYF9fZGF0YVRlbXBgIGNhY2hlIHRvIHByZXZlbnRcbiAgICAgICAgICAvLyBkdXBsaWNhdGUgd29yayBpbiB0aGUgc2FtZSB0dXJuIG9ubHkuIE5vdGUsIGlmIHRoaXMgd2FzIGEgbm90aWZpY2F0aW9uXG4gICAgICAgICAgLy8gb2YgYSBjaGFuZ2UgYWxyZWFkeSBzZXQgdG8gYSBwYXRoIChpc1BhdGhOb3RpZmljYXRpb246IHRydWUpLFxuICAgICAgICAgIC8vIHdlIGFsd2F5cyBsZXQgdGhlIGNoYW5nZSB0aHJvdWdoIGFuZCBza2lwIHRoZSBgc2V0YCBzaW5jZSBpdCB3YXNcbiAgICAgICAgICAvLyBhbHJlYWR5IGRpcnR5IGNoZWNrZWQgYXQgdGhlIHBvaW50IG9mIGVudHJ5IGFuZCB0aGUgdW5kZXJseWluZ1xuICAgICAgICAgIC8vIG9iamVjdCBoYXMgYWxyZWFkeSBiZWVuIHVwZGF0ZWRcbiAgICAgICAgICBpZiAoIWlzUGF0aE5vdGlmaWNhdGlvbikge1xuICAgICAgICAgICAgbGV0IG9sZCA9IFBvbHltZXIuUGF0aC5nZXQodGhpcywgcGF0aCk7XG4gICAgICAgICAgICBwYXRoID0gLyoqIEB0eXBlIHtzdHJpbmd9ICovIChQb2x5bWVyLlBhdGguc2V0KHRoaXMsIHBhdGgsIHZhbHVlKSk7XG4gICAgICAgICAgICAvLyBVc2UgcHJvcGVydHktYWNjZXNzb3IncyBzaW1wbGVyIGRpcnR5IGNoZWNrXG4gICAgICAgICAgICBpZiAoIXBhdGggfHwgIXN1cGVyLl9zaG91bGRQcm9wZXJ0eUNoYW5nZShwYXRoLCB2YWx1ZSwgb2xkKSkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX19kYXRhSGFzUGF0aHMgPSB0cnVlO1xuICAgICAgICAgIGlmICh0aGlzLl9zZXRQZW5kaW5nUHJvcGVydHkoLyoqQHR5cGV7c3RyaW5nfSovKHBhdGgpLCB2YWx1ZSwgc2hvdWxkTm90aWZ5KSkge1xuICAgICAgICAgICAgY29tcHV0ZUxpbmtlZFBhdGhzKHRoaXMsIHBhdGgsIHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodGhpcy5fX2RhdGFIYXNBY2Nlc3NvciAmJiB0aGlzLl9fZGF0YUhhc0FjY2Vzc29yW3BhdGhdKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2V0UGVuZGluZ1Byb3BlcnR5KC8qKkB0eXBle3N0cmluZ30qLyhwYXRoKSwgdmFsdWUsIHNob3VsZE5vdGlmeSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXNbcGF0aF0gPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEFwcGxpZXMgYSB2YWx1ZSB0byBhIG5vbi1Qb2x5bWVyIGVsZW1lbnQvbm9kZSdzIHByb3BlcnR5LlxuICAgICAgICpcbiAgICAgICAqIFRoZSBpbXBsZW1lbnRhdGlvbiBtYWtlcyBhIGJlc3QtZWZmb3J0IGF0IGJpbmRpbmcgaW50ZXJvcDpcbiAgICAgICAqIFNvbWUgbmF0aXZlIGVsZW1lbnQgcHJvcGVydGllcyBoYXZlIHNpZGUtZWZmZWN0cyB3aGVuXG4gICAgICAgKiByZS1zZXR0aW5nIHRoZSBzYW1lIHZhbHVlIChlLmcuIHNldHRpbmcgYDxpbnB1dD4udmFsdWVgIHJlc2V0cyB0aGVcbiAgICAgICAqIGN1cnNvciBwb3NpdGlvbiksIHNvIHdlIGRvIGEgZGlydHktY2hlY2sgYmVmb3JlIHNldHRpbmcgdGhlIHZhbHVlLlxuICAgICAgICogSG93ZXZlciwgZm9yIGJldHRlciBpbnRlcm9wIHdpdGggbm9uLVBvbHltZXIgY3VzdG9tIGVsZW1lbnRzIHRoYXRcbiAgICAgICAqIGFjY2VwdCBvYmplY3RzLCB3ZSBleHBsaWNpdGx5IHJlLXNldCBvYmplY3QgY2hhbmdlcyBjb21pbmcgZnJvbSB0aGVcbiAgICAgICAqIFBvbHltZXIgd29ybGQgKHdoaWNoIG1heSBpbmNsdWRlIGRlZXAgb2JqZWN0IGNoYW5nZXMgd2l0aG91dCB0aGVcbiAgICAgICAqIHRvcCByZWZlcmVuY2UgY2hhbmdpbmcpLCBlcnJpbmcgb24gdGhlIHNpZGUgb2YgcHJvdmlkaW5nIG1vcmVcbiAgICAgICAqIGluZm9ybWF0aW9uLlxuICAgICAgICpcbiAgICAgICAqIFVzZXJzIG1heSBvdmVycmlkZSB0aGlzIG1ldGhvZCB0byBwcm92aWRlIGFsdGVybmF0ZSBhcHByb2FjaGVzLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBUaGUgbm9kZSB0byBzZXQgYSBwcm9wZXJ0eSBvblxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3AgVGhlIHByb3BlcnR5IHRvIHNldFxuICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0XG4gICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgKi9cbiAgICAgIF9zZXRVbm1hbmFnZWRQcm9wZXJ0eVRvTm9kZShub2RlLCBwcm9wLCB2YWx1ZSkge1xuICAgICAgICAvLyBJdCBpcyBhIGp1ZGdtZW50IGNhbGwgdGhhdCByZXNldHRpbmcgcHJpbWl0aXZlcyBpc1xuICAgICAgICAvLyBcImJhZFwiIGFuZCByZXNldHRpbmdzIG9iamVjdHMgaXMgYWxzbyBcImdvb2RcIjsgYWx0ZXJuYXRpdmVseSB3ZSBjb3VsZFxuICAgICAgICAvLyBpbXBsZW1lbnQgYSB3aGl0ZWxpc3Qgb2YgdGFnICYgcHJvcGVydHkgdmFsdWVzIHRoYXQgc2hvdWxkIG5ldmVyXG4gICAgICAgIC8vIGJlIHJlc2V0IChlLmcuIDxpbnB1dD4udmFsdWUgJiYgPHNlbGVjdD4udmFsdWUpXG4gICAgICAgIGlmICh2YWx1ZSAhPT0gbm9kZVtwcm9wXSB8fCB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBub2RlW3Byb3BdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBPdmVycmlkZXMgdGhlIGBQcm9wZXJ0eUFjY2Vzc29yc2AgaW1wbGVtZW50YXRpb24gdG8gaW50cm9kdWNlIHNwZWNpYWxcbiAgICAgICAqIGRpcnR5IGNoZWNrIGxvZ2ljIGRlcGVuZGluZyBvbiB0aGUgcHJvcGVydHkgJiB2YWx1ZSBiZWluZyBzZXQ6XG4gICAgICAgKlxuICAgICAgICogMS4gQW55IHZhbHVlIHNldCB0byBhIHBhdGggKGUuZy4gJ29iai5wcm9wJzogNDIgb3IgJ29iai5wcm9wJzogey4uLn0pXG4gICAgICAgKiAgICBTdG9yZWQgaW4gYF9fZGF0YVRlbXBgLCBkaXJ0eSBjaGVja2VkIGFnYWluc3QgYF9fZGF0YVRlbXBgXG4gICAgICAgKiAyLiBPYmplY3Qgc2V0IHRvIHNpbXBsZSBwcm9wZXJ0eSAoZS5nLiAncHJvcCc6IHsuLi59KVxuICAgICAgICogICAgU3RvcmVkIGluIGBfX2RhdGFUZW1wYCBhbmQgYF9fZGF0YWAsIGRpcnR5IGNoZWNrZWQgYWdhaW5zdFxuICAgICAgICogICAgYF9fZGF0YVRlbXBgIGJ5IGRlZmF1bHQgaW1wbGVtZW50YXRpb24gb2YgYF9zaG91bGRQcm9wZXJ0eUNoYW5nZWBcbiAgICAgICAqIDMuIFByaW1pdGl2ZSB2YWx1ZSBzZXQgdG8gc2ltcGxlIHByb3BlcnR5IChlLmcuICdwcm9wJzogNDIpXG4gICAgICAgKiAgICBTdG9yZWQgaW4gYF9fZGF0YWAsIGRpcnR5IGNoZWNrZWQgYWdhaW5zdCBgX19kYXRhYFxuICAgICAgICpcbiAgICAgICAqIFRoZSBkaXJ0eS1jaGVjayBpcyBpbXBvcnRhbnQgdG8gcHJldmVudCBjeWNsZXMgZHVlIHRvIHR3by13YXlcbiAgICAgICAqIG5vdGlmaWNhdGlvbiwgYnV0IHBhdGhzIGFuZCBvYmplY3RzIGFyZSBvbmx5IGRpcnR5IGNoZWNrZWQgYWdhaW5zdCBhbnlcbiAgICAgICAqIHByZXZpb3VzIHZhbHVlIHNldCBkdXJpbmcgdGhpcyB0dXJuIHZpYSBhIFwidGVtcG9yYXJ5IGNhY2hlXCIgdGhhdCBpc1xuICAgICAgICogY2xlYXJlZCB3aGVuIHRoZSBsYXN0IGBfcHJvcGVydGllc0NoYWdlZGAgZXhpdHMuIFRoaXMgaXMgc286XG4gICAgICAgKiBhLiBhbnkgY2FjaGVkIGFycmF5IHBhdGhzIChlLmcuICdhcnJheS4zLnByb3AnKSBtYXkgYmUgaW52YWxpZGF0ZWRcbiAgICAgICAqICAgIGR1ZSB0byBhcnJheSBtdXRhdGlvbnMgbGlrZSBzaGlmdC91bnNoaWZ0L3NwbGljZTsgdGhpcyBpcyBmaW5lXG4gICAgICAgKiAgICBzaW5jZSBwYXRoIGNoYW5nZXMgYXJlIGRpcnR5LWNoZWNrZWQgYXQgdXNlciBlbnRyeSBwb2ludHMgbGlrZSBgc2V0YFxuICAgICAgICogYi4gZGlydHktY2hlY2tpbmcgZm9yIG9iamVjdHMgb25seSBsYXN0cyBvbmUgdHVybiB0byBhbGxvdyB0aGUgdXNlclxuICAgICAgICogICAgdG8gbXV0YXRlIHRoZSBvYmplY3QgaW4tcGxhY2UgYW5kIHJlLXNldCBpdCB3aXRoIHRoZSBzYW1lIGlkZW50aXR5XG4gICAgICAgKiAgICBhbmQgaGF2ZSBhbGwgc3ViLXByb3BlcnRpZXMgcmUtcHJvcGFnYXRlZCBpbiBhIHN1YnNlcXVlbnQgdHVybi5cbiAgICAgICAqXG4gICAgICAgKiBUaGUgdGVtcCBjYWNoZSBpcyBub3QgbmVjZXNzYXJpbHkgc3VmZmljaWVudCB0byBwcmV2ZW50IGludmFsaWQgYXJyYXlcbiAgICAgICAqIHBhdGhzLCBzaW5jZSBhIHNwbGljZSBjYW4gaGFwcGVuIGR1cmluZyB0aGUgc2FtZSB0dXJuICh3aXRoIHBhdGhvbG9naWNhbFxuICAgICAgICogdXNlciBjb2RlKTsgd2UgY291bGQgaW50cm9kdWNlIGEgXCJmaXh1cFwiIGZvciB0ZW1wb3JhcmlseSBjYWNoZWQgYXJyYXlcbiAgICAgICAqIHBhdGhzIGlmIG5lZWRlZDogaHR0cHM6Ly9naXRodWIuY29tL1BvbHltZXIvcG9seW1lci9pc3N1ZXMvNDIyN1xuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBOYW1lIG9mIHRoZSBwcm9wZXJ0eVxuICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byBzZXRcbiAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IHNob3VsZE5vdGlmeSBUcnVlIGlmIHByb3BlcnR5IHNob3VsZCBmaXJlIG5vdGlmaWNhdGlvblxuICAgICAgICogICBldmVudCAoYXBwbGllcyBvbmx5IGZvciBgbm90aWZ5OiB0cnVlYCBwcm9wZXJ0aWVzKVxuICAgICAgICogQHJldHVybiB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZSBwcm9wZXJ0eSBjaGFuZ2VkXG4gICAgICAgKiBAb3ZlcnJpZGVcbiAgICAgICAqL1xuICAgICAgX3NldFBlbmRpbmdQcm9wZXJ0eShwcm9wZXJ0eSwgdmFsdWUsIHNob3VsZE5vdGlmeSkge1xuICAgICAgICBsZXQgaXNQYXRoID0gdGhpcy5fX2RhdGFIYXNQYXRocyAmJiBQb2x5bWVyLlBhdGguaXNQYXRoKHByb3BlcnR5KTtcbiAgICAgICAgbGV0IHByZXZQcm9wcyA9IGlzUGF0aCA/IHRoaXMuX19kYXRhVGVtcCA6IHRoaXMuX19kYXRhO1xuICAgICAgICBpZiAodGhpcy5fc2hvdWxkUHJvcGVydHlDaGFuZ2UocHJvcGVydHksIHZhbHVlLCBwcmV2UHJvcHNbcHJvcGVydHldKSkge1xuICAgICAgICAgIGlmICghdGhpcy5fX2RhdGFQZW5kaW5nKSB7XG4gICAgICAgICAgICB0aGlzLl9fZGF0YVBlbmRpbmcgPSB7fTtcbiAgICAgICAgICAgIHRoaXMuX19kYXRhT2xkID0ge307XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIEVuc3VyZSBvbGQgaXMgY2FwdHVyZWQgZnJvbSB0aGUgbGFzdCB0dXJuXG4gICAgICAgICAgaWYgKCEocHJvcGVydHkgaW4gdGhpcy5fX2RhdGFPbGQpKSB7XG4gICAgICAgICAgICB0aGlzLl9fZGF0YU9sZFtwcm9wZXJ0eV0gPSB0aGlzLl9fZGF0YVtwcm9wZXJ0eV07XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFBhdGhzIGFyZSBzdG9yZWQgaW4gdGVtcG9yYXJ5IGNhY2hlIChjbGVhcmVkIGF0IGVuZCBvZiB0dXJuKSxcbiAgICAgICAgICAvLyB3aGljaCBpcyB1c2VkIGZvciBkaXJ0eS1jaGVja2luZywgYWxsIG90aGVycyBzdG9yZWQgaW4gX19kYXRhXG4gICAgICAgICAgaWYgKGlzUGF0aCkge1xuICAgICAgICAgICAgdGhpcy5fX2RhdGFUZW1wW3Byb3BlcnR5XSA9IHZhbHVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9fZGF0YVtwcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gQWxsIGNoYW5nZXMgZ28gaW50byBwZW5kaW5nIHByb3BlcnR5IGJhZywgcGFzc2VkIHRvIF9wcm9wZXJ0aWVzQ2hhbmdlZFxuICAgICAgICAgIHRoaXMuX19kYXRhUGVuZGluZ1twcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICAgICAgICAvLyBUcmFjayBwcm9wZXJ0aWVzIHRoYXQgc2hvdWxkIG5vdGlmeSBzZXBhcmF0ZWx5XG4gICAgICAgICAgaWYgKGlzUGF0aCB8fCAodGhpc1tUWVBFUy5OT1RJRlldICYmIHRoaXNbVFlQRVMuTk9USUZZXVtwcm9wZXJ0eV0pKSB7XG4gICAgICAgICAgICB0aGlzLl9fZGF0YVRvTm90aWZ5ID0gdGhpcy5fX2RhdGFUb05vdGlmeSB8fCB7fTtcbiAgICAgICAgICAgIHRoaXMuX19kYXRhVG9Ob3RpZnlbcHJvcGVydHldID0gc2hvdWxkTm90aWZ5O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogT3ZlcnJpZGVzIGJhc2UgaW1wbGVtZW50YXRpb24gdG8gZW5zdXJlIGFsbCBhY2Nlc3NvcnMgc2V0IGBzaG91bGROb3RpZnlgXG4gICAgICAgKiB0byB0cnVlLCBmb3IgcGVyLXByb3BlcnR5IG5vdGlmaWNhdGlvbiB0cmFja2luZy5cbiAgICAgICAqXG4gICAgICAgKiBAb3ZlcnJpZGVcbiAgICAgICAqL1xuICAgICAgX3NldFByb3BlcnR5KHByb3BlcnR5LCB2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5fc2V0UGVuZGluZ1Byb3BlcnR5KHByb3BlcnR5LCB2YWx1ZSwgdHJ1ZSkpIHtcbiAgICAgICAgICB0aGlzLl9pbnZhbGlkYXRlUHJvcGVydGllcygpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogT3ZlcnJpZGVzIGBQcm9wZXJ0eUFjY2Vzc29yYCdzIGRlZmF1bHQgYXN5bmMgcXVldWluZyBvZlxuICAgICAgICogYF9wcm9wZXJ0aWVzQ2hhbmdlZGA6IGlmIGBfX2RhdGFSZWFkeWAgaXMgZmFsc2UgKGhhcyBub3QgeWV0IGJlZW5cbiAgICAgICAqIG1hbnVhbGx5IGZsdXNoZWQpLCB0aGUgZnVuY3Rpb24gbm8tb3BzOyBvdGhlcndpc2UgZmx1c2hlc1xuICAgICAgICogYF9wcm9wZXJ0aWVzQ2hhbmdlZGAgc3luY2hyb25vdXNseS5cbiAgICAgICAqXG4gICAgICAgKiBAb3ZlcnJpZGVcbiAgICAgICAqL1xuICAgICAgX2ludmFsaWRhdGVQcm9wZXJ0aWVzKCkge1xuICAgICAgICBpZiAodGhpcy5fX2RhdGFSZWFkeSkge1xuICAgICAgICAgIHRoaXMuX2ZsdXNoUHJvcGVydGllcygpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogRW5xdWV1ZXMgdGhlIGdpdmVuIGNsaWVudCBvbiBhIGxpc3Qgb2YgcGVuZGluZyBjbGllbnRzLCB3aG9zZVxuICAgICAgICogcGVuZGluZyBwcm9wZXJ0eSBjaGFuZ2VzIGNhbiBsYXRlciBiZSBmbHVzaGVkIHZpYSBhIGNhbGwgdG9cbiAgICAgICAqIGBfZmx1c2hDbGllbnRzYC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2xpZW50IFByb3BlcnR5RWZmZWN0cyBjbGllbnQgdG8gZW5xdWV1ZVxuICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICovXG4gICAgICBfZW5xdWV1ZUNsaWVudChjbGllbnQpIHtcbiAgICAgICAgdGhpcy5fX2RhdGFQZW5kaW5nQ2xpZW50cyA9IHRoaXMuX19kYXRhUGVuZGluZ0NsaWVudHMgfHwgW107XG4gICAgICAgIGlmIChjbGllbnQgIT09IHRoaXMpIHtcbiAgICAgICAgICB0aGlzLl9fZGF0YVBlbmRpbmdDbGllbnRzLnB1c2goY2xpZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEZsdXNoZXMgYW55IGNsaWVudHMgcHJldmlvdXNseSBlbnF1ZXVlZCB2aWEgYF9lbnF1ZXVlQ2xpZW50YCwgY2F1c2luZ1xuICAgICAgICogdGhlaXIgYF9mbHVzaFByb3BlcnRpZXNgIG1ldGhvZCB0byBydW4uXG4gICAgICAgKlxuICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICovXG4gICAgICBfZmx1c2hDbGllbnRzKCkge1xuICAgICAgICBpZiAoIXRoaXMuX19kYXRhQ2xpZW50c1JlYWR5KSB7XG4gICAgICAgICAgdGhpcy5fX2RhdGFDbGllbnRzUmVhZHkgPSB0cnVlO1xuICAgICAgICAgIHRoaXMuX3JlYWR5Q2xpZW50cygpO1xuICAgICAgICAgIC8vIE92ZXJyaWRlIHBvaW50IHdoZXJlIGFjY2Vzc29ycyBhcmUgdHVybmVkIG9uOyBpbXBvcnRhbnRseSxcbiAgICAgICAgICAvLyB0aGlzIGlzIGFmdGVyIGNsaWVudHMgaGF2ZSBmdWxseSByZWFkaWVkLCBwcm92aWRpbmcgYSBndWFyYW50ZWVcbiAgICAgICAgICAvLyB0aGF0IGFueSBwcm9wZXJ0eSBlZmZlY3RzIG9jY3VyIG9ubHkgYWZ0ZXIgYWxsIGNsaWVudHMgYXJlIHJlYWR5LlxuICAgICAgICAgIHRoaXMuX19kYXRhUmVhZHkgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX19lbmFibGVPckZsdXNoQ2xpZW50cygpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIE5PVEU6IFdlIGVuc3VyZSBjbGllbnRzIGVpdGhlciBlbmFibGUgb3IgZmx1c2ggYXMgYXBwcm9wcmlhdGUuIFRoaXNcbiAgICAgIC8vIGhhbmRsZXMgdHdvIGNvcm5lciBjYXNlczpcbiAgICAgIC8vICgxKSBjbGllbnRzIGZsdXNoIHByb3Blcmx5IHdoZW4gY29ubmVjdGVkL2VuYWJsZWQgYmVmb3JlIHRoZSBob3N0XG4gICAgICAvLyBlbmFibGVzOyBlLmcuXG4gICAgICAvLyAgIChhKSBUZW1wbGF0aXplIHN0YW1wcyB3aXRoIG5vIHByb3BlcnRpZXMgYW5kIGRvZXMgbm90IGZsdXNoIGFuZFxuICAgICAgLy8gICAoYikgdGhlIGluc3RhbmNlIGlzIGluc2VydGVkIGludG8gZG9tIGFuZFxuICAgICAgLy8gICAoYykgdGhlbiB0aGUgaW5zdGFuY2UgZmx1c2hlcy5cbiAgICAgIC8vICgyKSBjbGllbnRzIGVuYWJsZSBwcm9wZXJseSB3aGVuIG5vdCBjb25uZWN0ZWQvZW5hYmxlZCB3aGVuIHRoZSBob3N0XG4gICAgICAvLyBmbHVzaGVzOyBlLmcuXG4gICAgICAvLyAgIChhKSBhIHRlbXBsYXRlIGlzIHJ1bnRpbWUgc3RhbXBlZCBhbmQgbm90IHlldCBjb25uZWN0ZWQvZW5hYmxlZFxuICAgICAgLy8gICAoYikgYSBob3N0IHNldHMgYSBwcm9wZXJ0eSwgY2F1c2luZyBzdGFtcGVkIGRvbSB0byBmbHVzaFxuICAgICAgLy8gICAoYykgdGhlIHN0YW1wZWQgZG9tIGVuYWJsZXMuXG4gICAgICBfX2VuYWJsZU9yRmx1c2hDbGllbnRzKCkge1xuICAgICAgICBsZXQgY2xpZW50cyA9IHRoaXMuX19kYXRhUGVuZGluZ0NsaWVudHM7XG4gICAgICAgIGlmIChjbGllbnRzKSB7XG4gICAgICAgICAgdGhpcy5fX2RhdGFQZW5kaW5nQ2xpZW50cyA9IG51bGw7XG4gICAgICAgICAgZm9yIChsZXQgaT0wOyBpIDwgY2xpZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGNsaWVudCA9IGNsaWVudHNbaV07XG4gICAgICAgICAgICBpZiAoIWNsaWVudC5fX2RhdGFFbmFibGVkKSB7XG4gICAgICAgICAgICAgIGNsaWVudC5fZW5hYmxlUHJvcGVydGllcygpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjbGllbnQuX19kYXRhUGVuZGluZykge1xuICAgICAgICAgICAgICBjbGllbnQuX2ZsdXNoUHJvcGVydGllcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFBlcmZvcm0gYW55IGluaXRpYWwgc2V0dXAgb24gY2xpZW50IGRvbS4gQ2FsbGVkIGJlZm9yZSB0aGUgZmlyc3RcbiAgICAgICAqIGBfZmx1c2hQcm9wZXJ0aWVzYCBjYWxsIG9uIGNsaWVudCBkb20gYW5kIGJlZm9yZSBhbnkgZWxlbWVudFxuICAgICAgICogb2JzZXJ2ZXJzIGFyZSBjYWxsZWQuXG4gICAgICAgKlxuICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICovXG4gICAgICBfcmVhZHlDbGllbnRzKCkge1xuICAgICAgICB0aGlzLl9fZW5hYmxlT3JGbHVzaENsaWVudHMoKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBTZXRzIGEgYmFnIG9mIHByb3BlcnR5IGNoYW5nZXMgdG8gdGhpcyBpbnN0YW5jZSwgYW5kXG4gICAgICAgKiBzeW5jaHJvbm91c2x5IHByb2Nlc3NlcyBhbGwgZWZmZWN0cyBvZiB0aGUgcHJvcGVydGllcyBhcyBhIGJhdGNoLlxuICAgICAgICpcbiAgICAgICAqIFByb3BlcnR5IG5hbWVzIG11c3QgYmUgc2ltcGxlIHByb3BlcnRpZXMsIG5vdCBwYXRocy4gIEJhdGNoZWRcbiAgICAgICAqIHBhdGggcHJvcGFnYXRpb24gaXMgbm90IHN1cHBvcnRlZC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgQmFnIG9mIG9uZSBvciBtb3JlIGtleS12YWx1ZSBwYWlycyB3aG9zZSBrZXkgaXNcbiAgICAgICAqICAgYSBwcm9wZXJ0eSBhbmQgdmFsdWUgaXMgdGhlIG5ldyB2YWx1ZSB0byBzZXQgZm9yIHRoYXQgcHJvcGVydHkuXG4gICAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBzZXRSZWFkT25seSBXaGVuIHRydWUsIGFueSBwcml2YXRlIHZhbHVlcyBzZXQgaW5cbiAgICAgICAqICAgYHByb3BzYCB3aWxsIGJlIHNldC4gQnkgZGVmYXVsdCwgYHNldFByb3BlcnRpZXNgIHdpbGwgbm90IHNldFxuICAgICAgICogICBgcmVhZE9ubHk6IHRydWVgIHJvb3QgcHJvcGVydGllcy5cbiAgICAgICAqIEBwdWJsaWNcbiAgICAgICAqL1xuICAgICAgc2V0UHJvcGVydGllcyhwcm9wcywgc2V0UmVhZE9ubHkpIHtcbiAgICAgICAgZm9yIChsZXQgcGF0aCBpbiBwcm9wcykge1xuICAgICAgICAgIGlmIChzZXRSZWFkT25seSB8fCAhdGhpc1tUWVBFUy5SRUFEX09OTFldIHx8ICF0aGlzW1RZUEVTLlJFQURfT05MWV1bcGF0aF0pIHtcbiAgICAgICAgICAgIC8vVE9ETyhrc2NoYWFmKTogZXhwbGljaXRseSBkaXNhbGxvdyBwYXRocyBpbiBzZXRQcm9wZXJ0eT9cbiAgICAgICAgICAgIC8vIHdpbGRjYXJkIG9ic2VydmVycyBjdXJyZW50bHkgb25seSBwYXNzIHRoZSBmaXJzdCBjaGFuZ2VkIHBhdGhcbiAgICAgICAgICAgIC8vIGluIHRoZSBgaW5mb2Agb2JqZWN0LCBhbmQgeW91IGNvdWxkIGRvIHNvbWUgb2RkIHRoaW5ncyBiYXRjaGluZ1xuICAgICAgICAgICAgLy8gcGF0aHMsIGUuZy4geydmb28uYmFyJzogey4uLn0sICdmb28nOiBudWxsfVxuICAgICAgICAgICAgdGhpcy5fc2V0UGVuZGluZ1Byb3BlcnR5T3JQYXRoKHBhdGgsIHByb3BzW3BhdGhdLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faW52YWxpZGF0ZVByb3BlcnRpZXMoKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBPdmVycmlkZXMgYFByb3BlcnR5QWNjZXNzb3JzYCBzbyB0aGF0IHByb3BlcnR5IGFjY2Vzc29yXG4gICAgICAgKiBzaWRlIGVmZmVjdHMgYXJlIG5vdCBlbmFibGVkIHVudGlsIGFmdGVyIGNsaWVudCBkb20gaXMgZnVsbHkgcmVhZHkuXG4gICAgICAgKiBBbHNvIGNhbGxzIGBfZmx1c2hDbGllbnRzYCBjYWxsYmFjayB0byBlbnN1cmUgY2xpZW50IGRvbSBpcyBlbmFibGVkXG4gICAgICAgKiB0aGF0IHdhcyBub3QgZW5hYmxlZCBhcyBhIHJlc3VsdCBvZiBmbHVzaGluZyBwcm9wZXJ0aWVzLlxuICAgICAgICpcbiAgICAgICAqIEBvdmVycmlkZVxuICAgICAgICovXG4gICAgICByZWFkeSgpIHtcbiAgICAgICAgLy8gSXQgaXMgaW1wb3J0YW50IHRoYXQgYHN1cGVyLnJlYWR5KClgIGlzIG5vdCBjYWxsZWQgaGVyZSBhcyBpdFxuICAgICAgICAvLyBpbW1lZGlhdGVseSB0dXJucyBvbiBhY2Nlc3NvcnMuIEluc3RlYWQsIHdlIHdhaXQgdW50aWwgYHJlYWR5Q2xpZW50c2BcbiAgICAgICAgLy8gdG8gZW5hYmxlIGFjY2Vzc29ycyB0byBwcm92aWRlIGEgZ3VhcmFudGVlIHRoYXQgY2xpZW50cyBhcmUgcmVhZHlcbiAgICAgICAgLy8gYmVmb3JlIHByb2Nlc3NpbmcgYW55IGFjY2Vzc29ycyBzaWRlIGVmZmVjdHMuXG4gICAgICAgIHRoaXMuX2ZsdXNoUHJvcGVydGllcygpO1xuICAgICAgICAvLyBJZiBubyBkYXRhIHdhcyBwZW5kaW5nLCBgX2ZsdXNoUHJvcGVydGllc2Agd2lsbCBub3QgYGZsdXNoQ2xpZW50c2BcbiAgICAgICAgLy8gc28gZW5zdXJlIHRoaXMgaXMgZG9uZS5cbiAgICAgICAgaWYgKCF0aGlzLl9fZGF0YUNsaWVudHNSZWFkeSkge1xuICAgICAgICAgIHRoaXMuX2ZsdXNoQ2xpZW50cygpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEJlZm9yZSByZWFkeSwgY2xpZW50IG5vdGlmaWNhdGlvbnMgZG8gbm90IHRyaWdnZXIgX2ZsdXNoUHJvcGVydGllcy5cbiAgICAgICAgLy8gVGhlcmVmb3JlIGEgZmx1c2ggaXMgbmVjZXNzYXJ5IGhlcmUgaWYgZGF0YSBoYXMgYmVlbiBzZXQuXG4gICAgICAgIGlmICh0aGlzLl9fZGF0YVBlbmRpbmcpIHtcbiAgICAgICAgICB0aGlzLl9mbHVzaFByb3BlcnRpZXMoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEltcGxlbWVudHMgYFByb3BlcnR5QWNjZXNzb3JzYCdzIHByb3BlcnRpZXMgY2hhbmdlZCBjYWxsYmFjay5cbiAgICAgICAqXG4gICAgICAgKiBSdW5zIGVhY2ggY2xhc3Mgb2YgZWZmZWN0cyBmb3IgdGhlIGJhdGNoIG9mIGNoYW5nZWQgcHJvcGVydGllcyBpblxuICAgICAgICogYSBzcGVjaWZpYyBvcmRlciAoY29tcHV0ZSwgcHJvcGFnYXRlLCByZWZsZWN0LCBvYnNlcnZlLCBub3RpZnkpLlxuICAgICAgICpcbiAgICAgICAqIEBvdmVycmlkZVxuICAgICAgICovXG4gICAgICBfcHJvcGVydGllc0NoYW5nZWQoY3VycmVudFByb3BzLCBjaGFuZ2VkUHJvcHMsIG9sZFByb3BzKSB7XG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gbGV0IGMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhjaGFuZ2VkUHJvcHMgfHwge30pO1xuICAgICAgICAvLyB3aW5kb3cuZGVidWcgJiYgY29uc29sZS5ncm91cCh0aGlzLmxvY2FsTmFtZSArICcjJyArIHRoaXMuaWQgKyAnOiAnICsgYyk7XG4gICAgICAgIC8vIGlmICh3aW5kb3cuZGVidWcpIHsgZGVidWdnZXI7IH1cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICBsZXQgaGFzUGF0aHMgPSB0aGlzLl9fZGF0YUhhc1BhdGhzO1xuICAgICAgICB0aGlzLl9fZGF0YUhhc1BhdGhzID0gZmFsc2U7XG4gICAgICAgIC8vIENvbXB1dGUgcHJvcGVydGllc1xuICAgICAgICBydW5Db21wdXRlZEVmZmVjdHModGhpcywgY2hhbmdlZFByb3BzLCBvbGRQcm9wcywgaGFzUGF0aHMpO1xuICAgICAgICAvLyBDbGVhciBub3RpZnkgcHJvcGVydGllcyBwcmlvciB0byBwb3NzaWJsZSByZWVudHJ5IChwcm9wYWdhdGUsIG9ic2VydmUpLFxuICAgICAgICAvLyBidXQgYWZ0ZXIgY29tcHV0aW5nIGVmZmVjdHMgaGF2ZSBhIGNoYW5jZSB0byBhZGQgdG8gdGhlbVxuICAgICAgICBsZXQgbm90aWZ5UHJvcHMgPSB0aGlzLl9fZGF0YVRvTm90aWZ5O1xuICAgICAgICB0aGlzLl9fZGF0YVRvTm90aWZ5ID0gbnVsbDtcbiAgICAgICAgLy8gUHJvcGFnYXRlIHByb3BlcnRpZXMgdG8gY2xpZW50c1xuICAgICAgICB0aGlzLl9wcm9wYWdhdGVQcm9wZXJ0eUNoYW5nZXMoY2hhbmdlZFByb3BzLCBvbGRQcm9wcywgaGFzUGF0aHMpO1xuICAgICAgICAvLyBGbHVzaCBjbGllbnRzXG4gICAgICAgIHRoaXMuX2ZsdXNoQ2xpZW50cygpO1xuICAgICAgICAvLyBSZWZsZWN0IHByb3BlcnRpZXNcbiAgICAgICAgcnVuRWZmZWN0cyh0aGlzLCB0aGlzW1RZUEVTLlJFRkxFQ1RdLCBjaGFuZ2VkUHJvcHMsIG9sZFByb3BzLCBoYXNQYXRocyk7XG4gICAgICAgIC8vIE9ic2VydmUgcHJvcGVydGllc1xuICAgICAgICBydW5FZmZlY3RzKHRoaXMsIHRoaXNbVFlQRVMuT0JTRVJWRV0sIGNoYW5nZWRQcm9wcywgb2xkUHJvcHMsIGhhc1BhdGhzKTtcbiAgICAgICAgLy8gTm90aWZ5IHByb3BlcnRpZXMgdG8gaG9zdFxuICAgICAgICBpZiAobm90aWZ5UHJvcHMpIHtcbiAgICAgICAgICBydW5Ob3RpZnlFZmZlY3RzKHRoaXMsIG5vdGlmeVByb3BzLCBjaGFuZ2VkUHJvcHMsIG9sZFByb3BzLCBoYXNQYXRocyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2xlYXIgdGVtcG9yYXJ5IGNhY2hlIGF0IGVuZCBvZiB0dXJuXG4gICAgICAgIGlmICh0aGlzLl9fZGF0YUNvdW50ZXIgPT0gMSkge1xuICAgICAgICAgIHRoaXMuX19kYXRhVGVtcCA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gd2luZG93LmRlYnVnICYmIGNvbnNvbGUuZ3JvdXBFbmQodGhpcy5sb2NhbE5hbWUgKyAnIycgKyB0aGlzLmlkICsgJzogJyArIGMpO1xuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ2FsbGVkIHRvIHByb3BhZ2F0ZSBhbnkgcHJvcGVydHkgY2hhbmdlcyB0byBzdGFtcGVkIHRlbXBsYXRlIG5vZGVzXG4gICAgICAgKiBtYW5hZ2VkIGJ5IHRoaXMgZWxlbWVudC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2hhbmdlZFByb3BzIEJhZyBvZiBjaGFuZ2VkIHByb3BlcnRpZXNcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvbGRQcm9wcyBCYWcgb2YgcHJldmlvdXMgdmFsdWVzIGZvciBjaGFuZ2VkIHByb3BlcnRpZXNcbiAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaGFzUGF0aHMgVHJ1ZSB3aXRoIGBwcm9wc2AgY29udGFpbnMgb25lIG9yIG1vcmUgcGF0aHNcbiAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAqL1xuICAgICAgX3Byb3BhZ2F0ZVByb3BlcnR5Q2hhbmdlcyhjaGFuZ2VkUHJvcHMsIG9sZFByb3BzLCBoYXNQYXRocykge1xuICAgICAgICBpZiAodGhpc1tUWVBFUy5QUk9QQUdBVEVdKSB7XG4gICAgICAgICAgcnVuRWZmZWN0cyh0aGlzLCB0aGlzW1RZUEVTLlBST1BBR0FURV0sIGNoYW5nZWRQcm9wcywgb2xkUHJvcHMsIGhhc1BhdGhzKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdGVtcGxhdGVJbmZvID0gdGhpcy5fX3RlbXBsYXRlSW5mbztcbiAgICAgICAgd2hpbGUgKHRlbXBsYXRlSW5mbykge1xuICAgICAgICAgIHJ1bkVmZmVjdHModGhpcywgdGVtcGxhdGVJbmZvLnByb3BlcnR5RWZmZWN0cywgY2hhbmdlZFByb3BzLCBvbGRQcm9wcyxcbiAgICAgICAgICAgIGhhc1BhdGhzLCB0ZW1wbGF0ZUluZm8ubm9kZUxpc3QpO1xuICAgICAgICAgIHRlbXBsYXRlSW5mbyA9IHRlbXBsYXRlSW5mby5uZXh0VGVtcGxhdGVJbmZvO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQWxpYXNlcyBvbmUgZGF0YSBwYXRoIGFzIGFub3RoZXIsIHN1Y2ggdGhhdCBwYXRoIG5vdGlmaWNhdGlvbnMgZnJvbSBvbmVcbiAgICAgICAqIGFyZSByb3V0ZWQgdG8gdGhlIG90aGVyLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgIUFycmF5PHN0cmluZ3xudW1iZXI+fSB0byBUYXJnZXQgcGF0aCB0byBsaW5rLlxuICAgICAgICogQHBhcmFtIHtzdHJpbmcgfCAhQXJyYXk8c3RyaW5nfG51bWJlcj59IGZyb20gU291cmNlIHBhdGggdG8gbGluay5cbiAgICAgICAqIEBwdWJsaWNcbiAgICAgICAqL1xuICAgICAgbGlua1BhdGhzKHRvLCBmcm9tKSB7XG4gICAgICAgIHRvID0gUG9seW1lci5QYXRoLm5vcm1hbGl6ZSh0byk7XG4gICAgICAgIGZyb20gPSBQb2x5bWVyLlBhdGgubm9ybWFsaXplKGZyb20pO1xuICAgICAgICB0aGlzLl9fZGF0YUxpbmtlZFBhdGhzID0gdGhpcy5fX2RhdGFMaW5rZWRQYXRocyB8fCB7fTtcbiAgICAgICAgdGhpcy5fX2RhdGFMaW5rZWRQYXRoc1t0b10gPSBmcm9tO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJlbW92ZXMgYSBkYXRhIHBhdGggYWxpYXMgcHJldmlvdXNseSBlc3RhYmxpc2hlZCB3aXRoIGBfbGlua1BhdGhzYC5cbiAgICAgICAqXG4gICAgICAgKiBOb3RlLCB0aGUgcGF0aCB0byB1bmxpbmsgc2hvdWxkIGJlIHRoZSB0YXJnZXQgKGB0b2ApIHVzZWQgd2hlblxuICAgICAgICogbGlua2luZyB0aGUgcGF0aHMuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmcgfCAhQXJyYXk8c3RyaW5nfG51bWJlcj59IHBhdGggVGFyZ2V0IHBhdGggdG8gdW5saW5rLlxuICAgICAgICogQHB1YmxpY1xuICAgICAgICovXG4gICAgICB1bmxpbmtQYXRocyhwYXRoKSB7XG4gICAgICAgIHBhdGggPSBQb2x5bWVyLlBhdGgubm9ybWFsaXplKHBhdGgpO1xuICAgICAgICBpZiAodGhpcy5fX2RhdGFMaW5rZWRQYXRocykge1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLl9fZGF0YUxpbmtlZFBhdGhzW3BhdGhdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogTm90aWZ5IHRoYXQgYW4gYXJyYXkgaGFzIGNoYW5nZWQuXG4gICAgICAgKlxuICAgICAgICogRXhhbXBsZTpcbiAgICAgICAqXG4gICAgICAgKiAgICAgdGhpcy5pdGVtcyA9IFsge25hbWU6ICdKaW0nfSwge25hbWU6ICdUb2RkJ30sIHtuYW1lOiAnQmlsbCd9IF07XG4gICAgICAgKiAgICAgLi4uXG4gICAgICAgKiAgICAgdGhpcy5pdGVtcy5zcGxpY2UoMSwgMSwge25hbWU6ICdTYW0nfSk7XG4gICAgICAgKiAgICAgdGhpcy5pdGVtcy5wdXNoKHtuYW1lOiAnQm9iJ30pO1xuICAgICAgICogICAgIHRoaXMubm90aWZ5U3BsaWNlcygnaXRlbXMnLCBbXG4gICAgICAgKiAgICAgICB7IGluZGV4OiAxLCByZW1vdmVkOiBbe25hbWU6ICdUb2RkJ31dLCBhZGRlZENvdW50OiAxLCBvYmVjdDogdGhpcy5pdGVtcywgdHlwZTogJ3NwbGljZScgfSxcbiAgICAgICAqICAgICAgIHsgaW5kZXg6IDMsIHJlbW92ZWQ6IFtdLCBhZGRlZENvdW50OiAxLCBvYmplY3Q6IHRoaXMuaXRlbXMsIHR5cGU6ICdzcGxpY2UnfVxuICAgICAgICogICAgIF0pO1xuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFBhdGggdGhhdCBzaG91bGQgYmUgbm90aWZpZWQuXG4gICAgICAgKiBAcGFyYW0ge0FycmF5fSBzcGxpY2VzIEFycmF5IG9mIHNwbGljZSByZWNvcmRzIGluZGljYXRpbmcgb3JkZXJlZFxuICAgICAgICogICBjaGFuZ2VzIHRoYXQgb2NjdXJyZWQgdG8gdGhlIGFycmF5LiBFYWNoIHJlY29yZCBzaG91bGQgaGF2ZSB0aGVcbiAgICAgICAqICAgZm9sbG93aW5nIGZpZWxkczpcbiAgICAgICAqICAgICogaW5kZXg6IGluZGV4IGF0IHdoaWNoIHRoZSBjaGFuZ2Ugb2NjdXJyZWRcbiAgICAgICAqICAgICogcmVtb3ZlZDogYXJyYXkgb2YgaXRlbXMgdGhhdCB3ZXJlIHJlbW92ZWQgZnJvbSB0aGlzIGluZGV4XG4gICAgICAgKiAgICAqIGFkZGVkQ291bnQ6IG51bWJlciBvZiBuZXcgaXRlbXMgYWRkZWQgYXQgdGhpcyBpbmRleFxuICAgICAgICogICAgKiBvYmplY3Q6IGEgcmVmZXJlbmNlIHRvIHRoZSBhcnJheSBpbiBxdWVzdGlvblxuICAgICAgICogICAgKiB0eXBlOiB0aGUgc3RyaW5nIGxpdGVyYWwgJ3NwbGljZSdcbiAgICAgICAqXG4gICAgICAgKiAgIE5vdGUgdGhhdCBzcGxpY2UgcmVjb3JkcyBfbXVzdF8gYmUgbm9ybWFsaXplZCBzdWNoIHRoYXQgdGhleSBhcmVcbiAgICAgICAqICAgcmVwb3J0ZWQgaW4gaW5kZXggb3JkZXIgKHJhdyByZXN1bHRzIGZyb20gYE9iamVjdC5vYnNlcnZlYCBhcmUgbm90XG4gICAgICAgKiAgIG9yZGVyZWQgYW5kIG11c3QgYmUgbm9ybWFsaXplZC9tZXJnZWQgYmVmb3JlIG5vdGlmeWluZykuXG4gICAgICAgKiBAcHVibGljXG4gICAgICAqL1xuICAgICAgbm90aWZ5U3BsaWNlcyhwYXRoLCBzcGxpY2VzKSB7XG4gICAgICAgIGxldCBpbmZvID0ge3BhdGg6ICcnfTtcbiAgICAgICAgbGV0IGFycmF5ID0gLyoqIEB0eXBlIHtBcnJheX0gKi8oUG9seW1lci5QYXRoLmdldCh0aGlzLCBwYXRoLCBpbmZvKSk7XG4gICAgICAgIG5vdGlmeVNwbGljZXModGhpcywgYXJyYXksIGluZm8ucGF0aCwgc3BsaWNlcyk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ29udmVuaWVuY2UgbWV0aG9kIGZvciByZWFkaW5nIGEgdmFsdWUgZnJvbSBhIHBhdGguXG4gICAgICAgKlxuICAgICAgICogTm90ZSwgaWYgYW55IHBhcnQgaW4gdGhlIHBhdGggaXMgdW5kZWZpbmVkLCB0aGlzIG1ldGhvZCByZXR1cm5zXG4gICAgICAgKiBgdW5kZWZpbmVkYCAodGhpcyBtZXRob2QgZG9lcyBub3QgdGhyb3cgd2hlbiBkZXJlZmVyZW5jaW5nIHVuZGVmaW5lZFxuICAgICAgICogcGF0aHMpLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7KHN0cmluZ3whQXJyYXk8KHN0cmluZ3xudW1iZXIpPil9IHBhdGggUGF0aCB0byB0aGUgdmFsdWVcbiAgICAgICAqICAgdG8gcmVhZC4gIFRoZSBwYXRoIG1heSBiZSBzcGVjaWZpZWQgYXMgYSBzdHJpbmcgKGUuZy4gYGZvby5iYXIuYmF6YClcbiAgICAgICAqICAgb3IgYW4gYXJyYXkgb2YgcGF0aCBwYXJ0cyAoZS5nLiBgWydmb28uYmFyJywgJ2JheiddYCkuICBOb3RlIHRoYXRcbiAgICAgICAqICAgYnJhY2tldGVkIGV4cHJlc3Npb25zIGFyZSBub3Qgc3VwcG9ydGVkOyBzdHJpbmctYmFzZWQgcGF0aCBwYXJ0c1xuICAgICAgICogICAqbXVzdCogYmUgc2VwYXJhdGVkIGJ5IGRvdHMuICBOb3RlIHRoYXQgd2hlbiBkZXJlZmVyZW5jaW5nIGFycmF5XG4gICAgICAgKiAgIGluZGljZXMsIHRoZSBpbmRleCBtYXkgYmUgdXNlZCBhcyBhIGRvdHRlZCBwYXJ0IGRpcmVjdGx5XG4gICAgICAgKiAgIChlLmcuIGB1c2Vycy4xMi5uYW1lYCBvciBgWyd1c2VycycsIDEyLCAnbmFtZSddYCkuXG4gICAgICAgKiBAcGFyYW0ge09iamVjdD19IHJvb3QgUm9vdCBvYmplY3QgZnJvbSB3aGljaCB0aGUgcGF0aCBpcyBldmFsdWF0ZWQuXG4gICAgICAgKiBAcmV0dXJuIHsqfSBWYWx1ZSBhdCB0aGUgcGF0aCwgb3IgYHVuZGVmaW5lZGAgaWYgYW55IHBhcnQgb2YgdGhlIHBhdGhcbiAgICAgICAqICAgaXMgdW5kZWZpbmVkLlxuICAgICAgICogQHB1YmxpY1xuICAgICAgICovXG4gICAgICBnZXQocGF0aCwgcm9vdCkge1xuICAgICAgICByZXR1cm4gUG9seW1lci5QYXRoLmdldChyb290IHx8IHRoaXMsIHBhdGgpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENvbnZlbmllbmNlIG1ldGhvZCBmb3Igc2V0dGluZyBhIHZhbHVlIHRvIGEgcGF0aCBhbmQgbm90aWZ5aW5nIGFueVxuICAgICAgICogZWxlbWVudHMgYm91bmQgdG8gdGhlIHNhbWUgcGF0aC5cbiAgICAgICAqXG4gICAgICAgKiBOb3RlLCBpZiBhbnkgcGFydCBpbiB0aGUgcGF0aCBleGNlcHQgZm9yIHRoZSBsYXN0IGlzIHVuZGVmaW5lZCxcbiAgICAgICAqIHRoaXMgbWV0aG9kIGRvZXMgbm90aGluZyAodGhpcyBtZXRob2QgZG9lcyBub3QgdGhyb3cgd2hlblxuICAgICAgICogZGVyZWZlcmVuY2luZyB1bmRlZmluZWQgcGF0aHMpLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7KHN0cmluZ3whQXJyYXk8KHN0cmluZ3xudW1iZXIpPil9IHBhdGggUGF0aCB0byB0aGUgdmFsdWVcbiAgICAgICAqICAgdG8gd3JpdGUuICBUaGUgcGF0aCBtYXkgYmUgc3BlY2lmaWVkIGFzIGEgc3RyaW5nIChlLmcuIGAnZm9vLmJhci5iYXonYClcbiAgICAgICAqICAgb3IgYW4gYXJyYXkgb2YgcGF0aCBwYXJ0cyAoZS5nLiBgWydmb28uYmFyJywgJ2JheiddYCkuICBOb3RlIHRoYXRcbiAgICAgICAqICAgYnJhY2tldGVkIGV4cHJlc3Npb25zIGFyZSBub3Qgc3VwcG9ydGVkOyBzdHJpbmctYmFzZWQgcGF0aCBwYXJ0c1xuICAgICAgICogICAqbXVzdCogYmUgc2VwYXJhdGVkIGJ5IGRvdHMuICBOb3RlIHRoYXQgd2hlbiBkZXJlZmVyZW5jaW5nIGFycmF5XG4gICAgICAgKiAgIGluZGljZXMsIHRoZSBpbmRleCBtYXkgYmUgdXNlZCBhcyBhIGRvdHRlZCBwYXJ0IGRpcmVjdGx5XG4gICAgICAgKiAgIChlLmcuIGAndXNlcnMuMTIubmFtZSdgIG9yIGBbJ3VzZXJzJywgMTIsICduYW1lJ11gKS5cbiAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgdG8gc2V0IGF0IHRoZSBzcGVjaWZpZWQgcGF0aC5cbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0PX0gcm9vdCBSb290IG9iamVjdCBmcm9tIHdoaWNoIHRoZSBwYXRoIGlzIGV2YWx1YXRlZC5cbiAgICAgICAqICAgV2hlbiBzcGVjaWZpZWQsIG5vIG5vdGlmaWNhdGlvbiB3aWxsIG9jY3VyLlxuICAgICAgICogQHB1YmxpY1xuICAgICAgKi9cbiAgICAgIHNldChwYXRoLCB2YWx1ZSwgcm9vdCkge1xuICAgICAgICBpZiAocm9vdCkge1xuICAgICAgICAgIFBvbHltZXIuUGF0aC5zZXQocm9vdCwgcGF0aCwgdmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICghdGhpc1tUWVBFUy5SRUFEX09OTFldIHx8ICF0aGlzW1RZUEVTLlJFQURfT05MWV1bLyoqIEB0eXBlIHtzdHJpbmd9ICovKHBhdGgpXSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3NldFBlbmRpbmdQcm9wZXJ0eU9yUGF0aChwYXRoLCB2YWx1ZSwgdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgdGhpcy5faW52YWxpZGF0ZVByb3BlcnRpZXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBBZGRzIGl0ZW1zIG9udG8gdGhlIGVuZCBvZiB0aGUgYXJyYXkgYXQgdGhlIHBhdGggc3BlY2lmaWVkLlxuICAgICAgICpcbiAgICAgICAqIFRoZSBhcmd1bWVudHMgYWZ0ZXIgYHBhdGhgIGFuZCByZXR1cm4gdmFsdWUgbWF0Y2ggdGhhdCBvZlxuICAgICAgICogYEFycmF5LnByb3RvdHlwZS5wdXNoYC5cbiAgICAgICAqXG4gICAgICAgKiBUaGlzIG1ldGhvZCBub3RpZmllcyBvdGhlciBwYXRocyB0byB0aGUgc2FtZSBhcnJheSB0aGF0IGFcbiAgICAgICAqIHNwbGljZSBvY2N1cnJlZCB0byB0aGUgYXJyYXkuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggUGF0aCB0byBhcnJheS5cbiAgICAgICAqIEBwYXJhbSB7Li4uKn0gaXRlbXMgSXRlbXMgdG8gcHVzaCBvbnRvIGFycmF5XG4gICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IE5ldyBsZW5ndGggb2YgdGhlIGFycmF5LlxuICAgICAgICogQHB1YmxpY1xuICAgICAgICovXG4gICAgICBwdXNoKHBhdGgsIC4uLml0ZW1zKSB7XG4gICAgICAgIGxldCBpbmZvID0ge3BhdGg6ICcnfTtcbiAgICAgICAgbGV0IGFycmF5ID0gLyoqIEB0eXBlIHtBcnJheX0qLyhQb2x5bWVyLlBhdGguZ2V0KHRoaXMsIHBhdGgsIGluZm8pKTtcbiAgICAgICAgbGV0IGxlbiA9IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgbGV0IHJldCA9IGFycmF5LnB1c2goLi4uaXRlbXMpO1xuICAgICAgICBpZiAoaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgbm90aWZ5U3BsaWNlKHRoaXMsIGFycmF5LCBpbmZvLnBhdGgsIGxlbiwgaXRlbXMubGVuZ3RoLCBbXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZW1vdmVzIGFuIGl0ZW0gZnJvbSB0aGUgZW5kIG9mIGFycmF5IGF0IHRoZSBwYXRoIHNwZWNpZmllZC5cbiAgICAgICAqXG4gICAgICAgKiBUaGUgYXJndW1lbnRzIGFmdGVyIGBwYXRoYCBhbmQgcmV0dXJuIHZhbHVlIG1hdGNoIHRoYXQgb2ZcbiAgICAgICAqIGBBcnJheS5wcm90b3R5cGUucG9wYC5cbiAgICAgICAqXG4gICAgICAgKiBUaGlzIG1ldGhvZCBub3RpZmllcyBvdGhlciBwYXRocyB0byB0aGUgc2FtZSBhcnJheSB0aGF0IGFcbiAgICAgICAqIHNwbGljZSBvY2N1cnJlZCB0byB0aGUgYXJyYXkuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggUGF0aCB0byBhcnJheS5cbiAgICAgICAqIEByZXR1cm4geyp9IEl0ZW0gdGhhdCB3YXMgcmVtb3ZlZC5cbiAgICAgICAqIEBwdWJsaWNcbiAgICAgICAqL1xuICAgICAgcG9wKHBhdGgpIHtcbiAgICAgICAgbGV0IGluZm8gPSB7cGF0aDogJyd9O1xuICAgICAgICBsZXQgYXJyYXkgPSAvKiogQHR5cGUge0FycmF5fSAqLyhQb2x5bWVyLlBhdGguZ2V0KHRoaXMsIHBhdGgsIGluZm8pKTtcbiAgICAgICAgbGV0IGhhZExlbmd0aCA9IEJvb2xlYW4oYXJyYXkubGVuZ3RoKTtcbiAgICAgICAgbGV0IHJldCA9IGFycmF5LnBvcCgpO1xuICAgICAgICBpZiAoaGFkTGVuZ3RoKSB7XG4gICAgICAgICAgbm90aWZ5U3BsaWNlKHRoaXMsIGFycmF5LCBpbmZvLnBhdGgsIGFycmF5Lmxlbmd0aCwgMCwgW3JldF0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogU3RhcnRpbmcgZnJvbSB0aGUgc3RhcnQgaW5kZXggc3BlY2lmaWVkLCByZW1vdmVzIDAgb3IgbW9yZSBpdGVtc1xuICAgICAgICogZnJvbSB0aGUgYXJyYXkgYW5kIGluc2VydHMgMCBvciBtb3JlIG5ldyBpdGVtcyBpbiB0aGVpciBwbGFjZS5cbiAgICAgICAqXG4gICAgICAgKiBUaGUgYXJndW1lbnRzIGFmdGVyIGBwYXRoYCBhbmQgcmV0dXJuIHZhbHVlIG1hdGNoIHRoYXQgb2ZcbiAgICAgICAqIGBBcnJheS5wcm90b3R5cGUuc3BsaWNlYC5cbiAgICAgICAqXG4gICAgICAgKiBUaGlzIG1ldGhvZCBub3RpZmllcyBvdGhlciBwYXRocyB0byB0aGUgc2FtZSBhcnJheSB0aGF0IGFcbiAgICAgICAqIHNwbGljZSBvY2N1cnJlZCB0byB0aGUgYXJyYXkuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggUGF0aCB0byBhcnJheS5cbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBJbmRleCBmcm9tIHdoaWNoIHRvIHN0YXJ0IHJlbW92aW5nL2luc2VydGluZy5cbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkZWxldGVDb3VudCBOdW1iZXIgb2YgaXRlbXMgdG8gcmVtb3ZlLlxuICAgICAgICogQHBhcmFtIHsuLi4qfSBpdGVtcyBJdGVtcyB0byBpbnNlcnQgaW50byBhcnJheS5cbiAgICAgICAqIEByZXR1cm4ge0FycmF5fSBBcnJheSBvZiByZW1vdmVkIGl0ZW1zLlxuICAgICAgICogQHB1YmxpY1xuICAgICAgICovXG4gICAgICBzcGxpY2UocGF0aCwgc3RhcnQsIGRlbGV0ZUNvdW50LCAuLi5pdGVtcykge1xuICAgICAgICBsZXQgaW5mbyA9IHtwYXRoIDogJyd9O1xuICAgICAgICBsZXQgYXJyYXkgPSAvKiogQHR5cGUge0FycmF5fSAqLyhQb2x5bWVyLlBhdGguZ2V0KHRoaXMsIHBhdGgsIGluZm8pKTtcbiAgICAgICAgLy8gTm9ybWFsaXplIGZhbmN5IG5hdGl2ZSBzcGxpY2UgaGFuZGxpbmcgb2YgY3Jhenkgc3RhcnQgdmFsdWVzXG4gICAgICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgICAgICBzdGFydCA9IGFycmF5Lmxlbmd0aCAtIE1hdGguZmxvb3IoLXN0YXJ0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdGFydCA9IE1hdGguZmxvb3Ioc3RhcnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc3RhcnQpIHtcbiAgICAgICAgICBzdGFydCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJldCA9IGFycmF5LnNwbGljZShzdGFydCwgZGVsZXRlQ291bnQsIC4uLml0ZW1zKTtcbiAgICAgICAgaWYgKGl0ZW1zLmxlbmd0aCB8fCByZXQubGVuZ3RoKSB7XG4gICAgICAgICAgbm90aWZ5U3BsaWNlKHRoaXMsIGFycmF5LCBpbmZvLnBhdGgsIHN0YXJ0LCBpdGVtcy5sZW5ndGgsIHJldCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZW1vdmVzIGFuIGl0ZW0gZnJvbSB0aGUgYmVnaW5uaW5nIG9mIGFycmF5IGF0IHRoZSBwYXRoIHNwZWNpZmllZC5cbiAgICAgICAqXG4gICAgICAgKiBUaGUgYXJndW1lbnRzIGFmdGVyIGBwYXRoYCBhbmQgcmV0dXJuIHZhbHVlIG1hdGNoIHRoYXQgb2ZcbiAgICAgICAqIGBBcnJheS5wcm90b3R5cGUucG9wYC5cbiAgICAgICAqXG4gICAgICAgKiBUaGlzIG1ldGhvZCBub3RpZmllcyBvdGhlciBwYXRocyB0byB0aGUgc2FtZSBhcnJheSB0aGF0IGFcbiAgICAgICAqIHNwbGljZSBvY2N1cnJlZCB0byB0aGUgYXJyYXkuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggUGF0aCB0byBhcnJheS5cbiAgICAgICAqIEByZXR1cm4geyp9IEl0ZW0gdGhhdCB3YXMgcmVtb3ZlZC5cbiAgICAgICAqIEBwdWJsaWNcbiAgICAgICAqL1xuICAgICAgc2hpZnQocGF0aCkge1xuICAgICAgICBsZXQgaW5mbyA9IHtwYXRoOiAnJ307XG4gICAgICAgIGxldCBhcnJheSA9IC8qKiBAdHlwZSB7QXJyYXl9ICovKFBvbHltZXIuUGF0aC5nZXQodGhpcywgcGF0aCwgaW5mbykpO1xuICAgICAgICBsZXQgaGFkTGVuZ3RoID0gQm9vbGVhbihhcnJheS5sZW5ndGgpO1xuICAgICAgICBsZXQgcmV0ID0gYXJyYXkuc2hpZnQoKTtcbiAgICAgICAgaWYgKGhhZExlbmd0aCkge1xuICAgICAgICAgIG5vdGlmeVNwbGljZSh0aGlzLCBhcnJheSwgaW5mby5wYXRoLCAwLCAwLCBbcmV0XSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBBZGRzIGl0ZW1zIG9udG8gdGhlIGJlZ2lubmluZyBvZiB0aGUgYXJyYXkgYXQgdGhlIHBhdGggc3BlY2lmaWVkLlxuICAgICAgICpcbiAgICAgICAqIFRoZSBhcmd1bWVudHMgYWZ0ZXIgYHBhdGhgIGFuZCByZXR1cm4gdmFsdWUgbWF0Y2ggdGhhdCBvZlxuICAgICAgICogYEFycmF5LnByb3RvdHlwZS5wdXNoYC5cbiAgICAgICAqXG4gICAgICAgKiBUaGlzIG1ldGhvZCBub3RpZmllcyBvdGhlciBwYXRocyB0byB0aGUgc2FtZSBhcnJheSB0aGF0IGFcbiAgICAgICAqIHNwbGljZSBvY2N1cnJlZCB0byB0aGUgYXJyYXkuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggUGF0aCB0byBhcnJheS5cbiAgICAgICAqIEBwYXJhbSB7Li4uKn0gaXRlbXMgSXRlbXMgdG8gaW5zZXJ0IGluZm8gYXJyYXlcbiAgICAgICAqIEByZXR1cm4ge251bWJlcn0gTmV3IGxlbmd0aCBvZiB0aGUgYXJyYXkuXG4gICAgICAgKiBAcHVibGljXG4gICAgICAgKi9cbiAgICAgIHVuc2hpZnQocGF0aCwgLi4uaXRlbXMpIHtcbiAgICAgICAgbGV0IGluZm8gPSB7cGF0aDogJyd9O1xuICAgICAgICBsZXQgYXJyYXkgPSAvKiogQHR5cGUge0FycmF5fSAqLyhQb2x5bWVyLlBhdGguZ2V0KHRoaXMsIHBhdGgsIGluZm8pKTtcbiAgICAgICAgbGV0IHJldCA9IGFycmF5LnVuc2hpZnQoLi4uaXRlbXMpO1xuICAgICAgICBpZiAoaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgbm90aWZ5U3BsaWNlKHRoaXMsIGFycmF5LCBpbmZvLnBhdGgsIDAsIGl0ZW1zLmxlbmd0aCwgW10pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogTm90aWZ5IHRoYXQgYSBwYXRoIGhhcyBjaGFuZ2VkLlxuICAgICAgICpcbiAgICAgICAqIEV4YW1wbGU6XG4gICAgICAgKlxuICAgICAgICogICAgIHRoaXMuaXRlbS51c2VyLm5hbWUgPSAnQm9iJztcbiAgICAgICAqICAgICB0aGlzLm5vdGlmeVBhdGgoJ2l0ZW0udXNlci5uYW1lJyk7XG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggUGF0aCB0aGF0IHNob3VsZCBiZSBub3RpZmllZC5cbiAgICAgICAqIEBwYXJhbSB7Kj19IHZhbHVlIFZhbHVlIGF0IHRoZSBwYXRoIChvcHRpb25hbCkuXG4gICAgICAgKiBAcHVibGljXG4gICAgICAqL1xuICAgICAgbm90aWZ5UGF0aChwYXRoLCB2YWx1ZSkge1xuICAgICAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgICAgICAgbGV0IHByb3BQYXRoO1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgLy8gR2V0IHZhbHVlIGlmIG5vdCBzdXBwbGllZFxuICAgICAgICAgIGxldCBpbmZvID0ge3BhdGg6ICcnfTtcbiAgICAgICAgICB2YWx1ZSA9IFBvbHltZXIuUGF0aC5nZXQodGhpcywgcGF0aCwgaW5mbyk7XG4gICAgICAgICAgcHJvcFBhdGggPSBpbmZvLnBhdGg7XG4gICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShwYXRoKSkge1xuICAgICAgICAgIC8vIE5vcm1hbGl6ZSBwYXRoIGlmIG5lZWRlZFxuICAgICAgICAgIHByb3BQYXRoID0gUG9seW1lci5QYXRoLm5vcm1hbGl6ZShwYXRoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcm9wUGF0aCA9IC8qKiBAdHlwZXtzdHJpbmd9ICovKHBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9zZXRQZW5kaW5nUHJvcGVydHlPclBhdGgocHJvcFBhdGgsIHZhbHVlLCB0cnVlLCB0cnVlKSkge1xuICAgICAgICAgIHRoaXMuX2ludmFsaWRhdGVQcm9wZXJ0aWVzKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBFcXVpdmFsZW50IHRvIHN0YXRpYyBgY3JlYXRlUmVhZE9ubHlQcm9wZXJ0eWAgQVBJIGJ1dCBjYW4gYmUgY2FsbGVkIG9uXG4gICAgICAgKiBhbiBpbnN0YW5jZSB0byBhZGQgZWZmZWN0cyBhdCBydW50aW1lLiAgU2VlIHRoYXQgbWV0aG9kIGZvclxuICAgICAgICogZnVsbCBBUEkgZG9jcy5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgbmFtZVxuICAgICAgICogQHBhcmFtIHtib29sZWFuPX0gcHJvdGVjdGVkU2V0dGVyIENyZWF0ZXMgYSBjdXN0b20gcHJvdGVjdGVkIHNldHRlclxuICAgICAgICogICB3aGVuIGB0cnVlYC5cbiAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAqL1xuICAgICAgX2NyZWF0ZVJlYWRPbmx5UHJvcGVydHkocHJvcGVydHksIHByb3RlY3RlZFNldHRlcikge1xuICAgICAgICB0aGlzLl9hZGRQcm9wZXJ0eUVmZmVjdChwcm9wZXJ0eSwgVFlQRVMuUkVBRF9PTkxZKTtcbiAgICAgICAgaWYgKHByb3RlY3RlZFNldHRlcikge1xuICAgICAgICAgIHRoaXNbJ19zZXQnICsgdXBwZXIocHJvcGVydHkpXSA9IC8qKiBAdGhpcyB7UHJvcGVydHlFZmZlY3RzfSAqL2Z1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9zZXRQcm9wZXJ0eShwcm9wZXJ0eSwgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEVxdWl2YWxlbnQgdG8gc3RhdGljIGBjcmVhdGVQcm9wZXJ0eU9ic2VydmVyYCBBUEkgYnV0IGNhbiBiZSBjYWxsZWQgb25cbiAgICAgICAqIGFuIGluc3RhbmNlIHRvIGFkZCBlZmZlY3RzIGF0IHJ1bnRpbWUuICBTZWUgdGhhdCBtZXRob2QgZm9yXG4gICAgICAgKiBmdWxsIEFQSSBkb2NzLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSBuYW1lXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kTmFtZSBOYW1lIG9mIG9ic2VydmVyIG1ldGhvZCB0byBjYWxsXG4gICAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBkeW5hbWljRm4gV2hldGhlciB0aGUgbWV0aG9kIG5hbWUgc2hvdWxkIGJlIGluY2x1ZGVkIGFzXG4gICAgICAgKiAgIGEgZGVwZW5kZW5jeSB0byB0aGUgZWZmZWN0LlxuICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICovXG4gICAgICBfY3JlYXRlUHJvcGVydHlPYnNlcnZlcihwcm9wZXJ0eSwgbWV0aG9kTmFtZSwgZHluYW1pY0ZuKSB7XG4gICAgICAgIGxldCBpbmZvID0geyBwcm9wZXJ0eSwgbWV0aG9kTmFtZSwgZHluYW1pY0ZuOiBCb29sZWFuKGR5bmFtaWNGbikgfTtcbiAgICAgICAgdGhpcy5fYWRkUHJvcGVydHlFZmZlY3QocHJvcGVydHksIFRZUEVTLk9CU0VSVkUsIHtcbiAgICAgICAgICBmbjogcnVuT2JzZXJ2ZXJFZmZlY3QsIGluZm8sIHRyaWdnZXI6IHtuYW1lOiBwcm9wZXJ0eX1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChkeW5hbWljRm4pIHtcbiAgICAgICAgICB0aGlzLl9hZGRQcm9wZXJ0eUVmZmVjdChtZXRob2ROYW1lLCBUWVBFUy5PQlNFUlZFLCB7XG4gICAgICAgICAgICBmbjogcnVuT2JzZXJ2ZXJFZmZlY3QsIGluZm8sIHRyaWdnZXI6IHtuYW1lOiBtZXRob2ROYW1lfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogRXF1aXZhbGVudCB0byBzdGF0aWMgYGNyZWF0ZU1ldGhvZE9ic2VydmVyYCBBUEkgYnV0IGNhbiBiZSBjYWxsZWQgb25cbiAgICAgICAqIGFuIGluc3RhbmNlIHRvIGFkZCBlZmZlY3RzIGF0IHJ1bnRpbWUuICBTZWUgdGhhdCBtZXRob2QgZm9yXG4gICAgICAgKiBmdWxsIEFQSSBkb2NzLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBleHByZXNzaW9uIE1ldGhvZCBleHByZXNzaW9uXG4gICAgICAgKiBAcGFyYW0ge2Jvb2xlYW58T2JqZWN0PX0gZHluYW1pY0ZuIEJvb2xlYW4gb3Igb2JqZWN0IG1hcCBpbmRpY2F0aW5nXG4gICAgICAgKiAgIHdoZXRoZXIgbWV0aG9kIG5hbWVzIHNob3VsZCBiZSBpbmNsdWRlZCBhcyBhIGRlcGVuZGVuY3kgdG8gdGhlIGVmZmVjdC5cbiAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAqL1xuICAgICAgX2NyZWF0ZU1ldGhvZE9ic2VydmVyKGV4cHJlc3Npb24sIGR5bmFtaWNGbikge1xuICAgICAgICBsZXQgc2lnID0gcGFyc2VNZXRob2QoZXhwcmVzc2lvbik7XG4gICAgICAgIGlmICghc2lnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWFsZm9ybWVkIG9ic2VydmVyIGV4cHJlc3Npb24gJ1wiICsgZXhwcmVzc2lvbiArIFwiJ1wiKTtcbiAgICAgICAgfVxuICAgICAgICBjcmVhdGVNZXRob2RFZmZlY3QodGhpcywgc2lnLCBUWVBFUy5PQlNFUlZFLCBydW5NZXRob2RFZmZlY3QsIG51bGwsIGR5bmFtaWNGbik7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogRXF1aXZhbGVudCB0byBzdGF0aWMgYGNyZWF0ZU5vdGlmeWluZ1Byb3BlcnR5YCBBUEkgYnV0IGNhbiBiZSBjYWxsZWQgb25cbiAgICAgICAqIGFuIGluc3RhbmNlIHRvIGFkZCBlZmZlY3RzIGF0IHJ1bnRpbWUuICBTZWUgdGhhdCBtZXRob2QgZm9yXG4gICAgICAgKiBmdWxsIEFQSSBkb2NzLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSBuYW1lXG4gICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgKi9cbiAgICAgIF9jcmVhdGVOb3RpZnlpbmdQcm9wZXJ0eShwcm9wZXJ0eSkge1xuICAgICAgICB0aGlzLl9hZGRQcm9wZXJ0eUVmZmVjdChwcm9wZXJ0eSwgVFlQRVMuTk9USUZZLCB7XG4gICAgICAgICAgZm46IHJ1bk5vdGlmeUVmZmVjdCxcbiAgICAgICAgICBpbmZvOiB7XG4gICAgICAgICAgICBldmVudE5hbWU6IENhc2VNYXAuY2FtZWxUb0Rhc2hDYXNlKHByb3BlcnR5KSArICctY2hhbmdlZCcsXG4gICAgICAgICAgICBwcm9wZXJ0eTogcHJvcGVydHlcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEVxdWl2YWxlbnQgdG8gc3RhdGljIGBjcmVhdGVSZWZsZWN0ZWRQcm9wZXJ0eWAgQVBJIGJ1dCBjYW4gYmUgY2FsbGVkIG9uXG4gICAgICAgKiBhbiBpbnN0YW5jZSB0byBhZGQgZWZmZWN0cyBhdCBydW50aW1lLiAgU2VlIHRoYXQgbWV0aG9kIGZvclxuICAgICAgICogZnVsbCBBUEkgZG9jcy5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgbmFtZVxuICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICovXG4gICAgICBfY3JlYXRlUmVmbGVjdGVkUHJvcGVydHkocHJvcGVydHkpIHtcbiAgICAgICAgbGV0IGF0dHIgPSBDYXNlTWFwLmNhbWVsVG9EYXNoQ2FzZShwcm9wZXJ0eSk7XG4gICAgICAgIGlmIChhdHRyWzBdID09PSAnLScpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ1Byb3BlcnR5ICcgKyBwcm9wZXJ0eSArICcgY2Fubm90IGJlIHJlZmxlY3RlZCB0byBhdHRyaWJ1dGUgJyArXG4gICAgICAgICAgICBhdHRyICsgJyBiZWNhdXNlIFwiLVwiIGlzIG5vdCBhIHZhbGlkIHN0YXJ0aW5nIGF0dHJpYnV0ZSBuYW1lLiBVc2UgYSBsb3dlcmNhc2UgZmlyc3QgbGV0dGVyIGZvciB0aGUgcHJvcGVydHkgdGhpc2VhZC4nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9hZGRQcm9wZXJ0eUVmZmVjdChwcm9wZXJ0eSwgVFlQRVMuUkVGTEVDVCwge1xuICAgICAgICAgICAgZm46IHJ1blJlZmxlY3RFZmZlY3QsXG4gICAgICAgICAgICBpbmZvOiB7XG4gICAgICAgICAgICAgIGF0dHJOYW1lOiBhdHRyXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBFcXVpdmFsZW50IHRvIHN0YXRpYyBgY3JlYXRlQ29tcHV0ZWRQcm9wZXJ0eWAgQVBJIGJ1dCBjYW4gYmUgY2FsbGVkIG9uXG4gICAgICAgKiBhbiBpbnN0YW5jZSB0byBhZGQgZWZmZWN0cyBhdCBydW50aW1lLiAgU2VlIHRoYXQgbWV0aG9kIGZvclxuICAgICAgICogZnVsbCBBUEkgZG9jcy5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgTmFtZSBvZiBjb21wdXRlZCBwcm9wZXJ0eSB0byBzZXRcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBleHByZXNzaW9uIE1ldGhvZCBleHByZXNzaW9uXG4gICAgICAgKiBAcGFyYW0ge2Jvb2xlYW58T2JqZWN0PX0gZHluYW1pY0ZuIEJvb2xlYW4gb3Igb2JqZWN0IG1hcCBpbmRpY2F0aW5nXG4gICAgICAgKiAgIHdoZXRoZXIgbWV0aG9kIG5hbWVzIHNob3VsZCBiZSBpbmNsdWRlZCBhcyBhIGRlcGVuZGVuY3kgdG8gdGhlIGVmZmVjdC5cbiAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAqL1xuICAgICAgX2NyZWF0ZUNvbXB1dGVkUHJvcGVydHkocHJvcGVydHksIGV4cHJlc3Npb24sIGR5bmFtaWNGbikge1xuICAgICAgICBsZXQgc2lnID0gcGFyc2VNZXRob2QoZXhwcmVzc2lvbik7XG4gICAgICAgIGlmICghc2lnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWFsZm9ybWVkIGNvbXB1dGVkIGV4cHJlc3Npb24gJ1wiICsgZXhwcmVzc2lvbiArIFwiJ1wiKTtcbiAgICAgICAgfVxuICAgICAgICBjcmVhdGVNZXRob2RFZmZlY3QodGhpcywgc2lnLCBUWVBFUy5DT01QVVRFLCBydW5Db21wdXRlZEVmZmVjdCwgcHJvcGVydHksIGR5bmFtaWNGbik7XG4gICAgICB9XG5cbiAgICAgIC8vIC0tIHN0YXRpYyBjbGFzcyBtZXRob2RzIC0tLS0tLS0tLS0tLVxuXG4gICAgICAvKipcbiAgICAgICAqIEVuc3VyZXMgYW4gYWNjZXNzb3IgZXhpc3RzIGZvciB0aGUgc3BlY2lmaWVkIHByb3BlcnR5LCBhbmQgYWRkc1xuICAgICAgICogdG8gYSBsaXN0IG9mIFwicHJvcGVydHkgZWZmZWN0c1wiIHRoYXQgd2lsbCBydW4gd2hlbiB0aGUgYWNjZXNzb3IgZm9yXG4gICAgICAgKiB0aGUgc3BlY2lmaWVkIHByb3BlcnR5IGlzIHNldC4gIEVmZmVjdHMgYXJlIGdyb3VwZWQgYnkgXCJ0eXBlXCIsIHdoaWNoXG4gICAgICAgKiByb3VnaGx5IGNvcnJlc3BvbmRzIHRvIGEgcGhhc2UgaW4gZWZmZWN0IHByb2Nlc3NpbmcuICBUaGUgZWZmZWN0XG4gICAgICAgKiBtZXRhZGF0YSBzaG91bGQgYmUgaW4gdGhlIGZvbGxvd2luZyBmb3JtOlxuICAgICAgICpcbiAgICAgICAqICAge1xuICAgICAgICogICAgIGZuOiBlZmZlY3RGdW5jdGlvbiwgLy8gUmVmZXJlbmNlIHRvIGZ1bmN0aW9uIHRvIGNhbGwgdG8gcGVyZm9ybSBlZmZlY3RcbiAgICAgICAqICAgICBpbmZvOiB7IC4uLiB9ICAgICAgIC8vIEVmZmVjdCBtZXRhZGF0YSBwYXNzZWQgdG8gZnVuY3Rpb25cbiAgICAgICAqICAgICB0cmlnZ2VyOiB7ICAgICAgICAgIC8vIE9wdGlvbmFsIHRyaWdnZXJpbmcgbWV0YWRhdGE7IGlmIG5vdCBwcm92aWRlZFxuICAgICAgICogICAgICAgbmFtZTogc3RyaW5nICAgICAgLy8gdGhlIHByb3BlcnR5IGlzIHRyZWF0ZWQgYXMgYSB3aWxkY2FyZFxuICAgICAgICogICAgICAgc3RydWN0dXJlZDogYm9vbGVhblxuICAgICAgICogICAgICAgd2lsZGNhcmQ6IGJvb2xlYW5cbiAgICAgICAqICAgICB9XG4gICAgICAgKiAgIH1cbiAgICAgICAqXG4gICAgICAgKiBFZmZlY3RzIGFyZSBjYWxsZWQgZnJvbSBgX3Byb3BlcnRpZXNDaGFuZ2VkYCBpbiB0aGUgZm9sbG93aW5nIG9yZGVyIGJ5XG4gICAgICAgKiB0eXBlOlxuICAgICAgICpcbiAgICAgICAqIDEuIENPTVBVVEVcbiAgICAgICAqIDIuIFBST1BBR0FURVxuICAgICAgICogMy4gUkVGTEVDVFxuICAgICAgICogNC4gT0JTRVJWRVxuICAgICAgICogNS4gTk9USUZZXG4gICAgICAgKlxuICAgICAgICogRWZmZWN0IGZ1bmN0aW9ucyBhcmUgY2FsbGVkIHdpdGggdGhlIGZvbGxvd2luZyBzaWduYXR1cmU6XG4gICAgICAgKlxuICAgICAgICogICBlZmZlY3RGdW5jdGlvbihpbnN0LCBwYXRoLCBwcm9wcywgb2xkUHJvcHMsIGluZm8sIGhhc1BhdGhzKVxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSB0aGF0IHNob3VsZCB0cmlnZ2VyIHRoZSBlZmZlY3RcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIEVmZmVjdCB0eXBlLCBmcm9tIHRoaXMuUFJPUEVSVFlfRUZGRUNUX1RZUEVTXG4gICAgICAgKiBAcGFyYW0ge09iamVjdD19IGVmZmVjdCBFZmZlY3QgbWV0YWRhdGEgb2JqZWN0XG4gICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgKi9cbiAgICAgIHN0YXRpYyBhZGRQcm9wZXJ0eUVmZmVjdChwcm9wZXJ0eSwgdHlwZSwgZWZmZWN0KSB7XG4gICAgICAgIHRoaXMucHJvdG90eXBlLl9hZGRQcm9wZXJ0eUVmZmVjdChwcm9wZXJ0eSwgdHlwZSwgZWZmZWN0KTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDcmVhdGVzIGEgc2luZ2xlLXByb3BlcnR5IG9ic2VydmVyIGZvciB0aGUgZ2l2ZW4gcHJvcGVydHkuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IG5hbWVcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2ROYW1lIE5hbWUgb2Ygb2JzZXJ2ZXIgbWV0aG9kIHRvIGNhbGxcbiAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IGR5bmFtaWNGbiBXaGV0aGVyIHRoZSBtZXRob2QgbmFtZSBzaG91bGQgYmUgaW5jbHVkZWQgYXNcbiAgICAgICAqICAgYSBkZXBlbmRlbmN5IHRvIHRoZSBlZmZlY3QuXG4gICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgKi9cbiAgICAgIHN0YXRpYyBjcmVhdGVQcm9wZXJ0eU9ic2VydmVyKHByb3BlcnR5LCBtZXRob2ROYW1lLCBkeW5hbWljRm4pIHtcbiAgICAgICAgdGhpcy5wcm90b3R5cGUuX2NyZWF0ZVByb3BlcnR5T2JzZXJ2ZXIocHJvcGVydHksIG1ldGhvZE5hbWUsIGR5bmFtaWNGbik7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ3JlYXRlcyBhIG11bHRpLXByb3BlcnR5IFwibWV0aG9kIG9ic2VydmVyXCIgYmFzZWQgb24gdGhlIHByb3ZpZGVkXG4gICAgICAgKiBleHByZXNzaW9uLCB3aGljaCBzaG91bGQgYmUgYSBzdHJpbmcgaW4gdGhlIGZvcm0gb2YgYSBub3JtYWwgSmF2YXNjcmlwdFxuICAgICAgICogZnVuY3Rpb24gc2lnbmF0dXJlOiBgJ21ldGhvZE5hbWUoYXJnMSwgWy4uLiwgYXJnbl0pJ2AuICBFYWNoIGFyZ3VtZW50XG4gICAgICAgKiBzaG91bGQgY29ycmVzcG9uZCB0byBhIHByb3BlcnR5IG9yIHBhdGggaW4gdGhlIGNvbnRleHQgb2YgdGhpc1xuICAgICAgICogcHJvdG90eXBlIChvciBpbnN0YW5jZSksIG9yIG1heSBiZSBhIGxpdGVyYWwgc3RyaW5nIG9yIG51bWJlci5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXhwcmVzc2lvbiBNZXRob2QgZXhwcmVzc2lvblxuICAgICAgICogQHBhcmFtIHtib29sZWFufE9iamVjdD19IGR5bmFtaWNGbiBCb29sZWFuIG9yIG9iamVjdCBtYXAgaW5kaWNhdGluZ1xuICAgICAgICogICB3aGV0aGVyIG1ldGhvZCBuYW1lcyBzaG91bGQgYmUgaW5jbHVkZWQgYXMgYSBkZXBlbmRlbmN5IHRvIHRoZSBlZmZlY3QuXG4gICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgKi9cbiAgICAgIHN0YXRpYyBjcmVhdGVNZXRob2RPYnNlcnZlcihleHByZXNzaW9uLCBkeW5hbWljRm4pIHtcbiAgICAgICAgdGhpcy5wcm90b3R5cGUuX2NyZWF0ZU1ldGhvZE9ic2VydmVyKGV4cHJlc3Npb24sIGR5bmFtaWNGbik7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ2F1c2VzIHRoZSBzZXR0ZXIgZm9yIHRoZSBnaXZlbiBwcm9wZXJ0eSB0byBkaXNwYXRjaCBgPHByb3BlcnR5Pi1jaGFuZ2VkYFxuICAgICAgICogZXZlbnRzIHRvIG5vdGlmeSBvZiBjaGFuZ2VzIHRvIHRoZSBwcm9wZXJ0eS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgbmFtZVxuICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICovXG4gICAgICBzdGF0aWMgY3JlYXRlTm90aWZ5aW5nUHJvcGVydHkocHJvcGVydHkpIHtcbiAgICAgICAgdGhpcy5wcm90b3R5cGUuX2NyZWF0ZU5vdGlmeWluZ1Byb3BlcnR5KHByb3BlcnR5KTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDcmVhdGVzIGEgcmVhZC1vbmx5IGFjY2Vzc29yIGZvciB0aGUgZ2l2ZW4gcHJvcGVydHkuXG4gICAgICAgKlxuICAgICAgICogVG8gc2V0IHRoZSBwcm9wZXJ0eSwgdXNlIHRoZSBwcm90ZWN0ZWQgYF9zZXRQcm9wZXJ0eWAgQVBJLlxuICAgICAgICogVG8gY3JlYXRlIGEgY3VzdG9tIHByb3RlY3RlZCBzZXR0ZXIgKGUuZy4gYF9zZXRNeVByb3AoKWAgZm9yXG4gICAgICAgKiBwcm9wZXJ0eSBgbXlQcm9wYCksIHBhc3MgYHRydWVgIGZvciBgcHJvdGVjdGVkU2V0dGVyYC5cbiAgICAgICAqXG4gICAgICAgKiBOb3RlLCBpZiB0aGUgcHJvcGVydHkgd2lsbCBoYXZlIG90aGVyIHByb3BlcnR5IGVmZmVjdHMsIHRoaXMgbWV0aG9kXG4gICAgICAgKiBzaG91bGQgYmUgY2FsbGVkIGZpcnN0LCBiZWZvcmUgYWRkaW5nIG90aGVyIGVmZmVjdHMuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IG5hbWVcbiAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IHByb3RlY3RlZFNldHRlciBDcmVhdGVzIGEgY3VzdG9tIHByb3RlY3RlZCBzZXR0ZXJcbiAgICAgICAqICAgd2hlbiBgdHJ1ZWAuXG4gICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgKi9cbiAgICAgIHN0YXRpYyBjcmVhdGVSZWFkT25seVByb3BlcnR5KHByb3BlcnR5LCBwcm90ZWN0ZWRTZXR0ZXIpIHtcbiAgICAgICAgdGhpcy5wcm90b3R5cGUuX2NyZWF0ZVJlYWRPbmx5UHJvcGVydHkocHJvcGVydHksIHByb3RlY3RlZFNldHRlcik7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ2F1c2VzIHRoZSBzZXR0ZXIgZm9yIHRoZSBnaXZlbiBwcm9wZXJ0eSB0byByZWZsZWN0IHRoZSBwcm9wZXJ0eSB2YWx1ZVxuICAgICAgICogdG8gYSAoZGFzaC1jYXNlZCkgYXR0cmlidXRlIG9mIHRoZSBzYW1lIG5hbWUuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IG5hbWVcbiAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAqL1xuICAgICAgc3RhdGljIGNyZWF0ZVJlZmxlY3RlZFByb3BlcnR5KHByb3BlcnR5KSB7XG4gICAgICAgIHRoaXMucHJvdG90eXBlLl9jcmVhdGVSZWZsZWN0ZWRQcm9wZXJ0eShwcm9wZXJ0eSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ3JlYXRlcyBhIGNvbXB1dGVkIHByb3BlcnR5IHdob3NlIHZhbHVlIGlzIHNldCB0byB0aGUgcmVzdWx0IG9mIHRoZVxuICAgICAgICogbWV0aG9kIGRlc2NyaWJlZCBieSB0aGUgZ2l2ZW4gYGV4cHJlc3Npb25gIGVhY2ggdGltZSBvbmUgb3IgbW9yZVxuICAgICAgICogYXJndW1lbnRzIHRvIHRoZSBtZXRob2QgY2hhbmdlcy4gIFRoZSBleHByZXNzaW9uIHNob3VsZCBiZSBhIHN0cmluZ1xuICAgICAgICogaW4gdGhlIGZvcm0gb2YgYSBub3JtYWwgSmF2YXNjcmlwdCBmdW5jdGlvbiBzaWduYXR1cmU6XG4gICAgICAgKiBgJ21ldGhvZE5hbWUoYXJnMSwgWy4uLiwgYXJnbl0pJ2BcbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgTmFtZSBvZiBjb21wdXRlZCBwcm9wZXJ0eSB0byBzZXRcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBleHByZXNzaW9uIE1ldGhvZCBleHByZXNzaW9uXG4gICAgICAgKiBAcGFyYW0ge2Jvb2xlYW58T2JqZWN0PX0gZHluYW1pY0ZuIEJvb2xlYW4gb3Igb2JqZWN0IG1hcCBpbmRpY2F0aW5nIHdoZXRoZXJcbiAgICAgICAqICAgbWV0aG9kIG5hbWVzIHNob3VsZCBiZSBpbmNsdWRlZCBhcyBhIGRlcGVuZGVuY3kgdG8gdGhlIGVmZmVjdC5cbiAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAqL1xuICAgICAgc3RhdGljIGNyZWF0ZUNvbXB1dGVkUHJvcGVydHkocHJvcGVydHksIGV4cHJlc3Npb24sIGR5bmFtaWNGbikge1xuICAgICAgICB0aGlzLnByb3RvdHlwZS5fY3JlYXRlQ29tcHV0ZWRQcm9wZXJ0eShwcm9wZXJ0eSwgZXhwcmVzc2lvbiwgZHluYW1pY0ZuKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBQYXJzZXMgdGhlIHByb3ZpZGVkIHRlbXBsYXRlIHRvIGVuc3VyZSBiaW5kaW5nIGVmZmVjdHMgYXJlIGNyZWF0ZWRcbiAgICAgICAqIGZvciB0aGVtLCBhbmQgdGhlbiBlbnN1cmVzIHByb3BlcnR5IGFjY2Vzc29ycyBhcmUgY3JlYXRlZCBmb3IgYW55XG4gICAgICAgKiBkZXBlbmRlbnQgcHJvcGVydGllcyBpbiB0aGUgdGVtcGxhdGUuICBCaW5kaW5nIGVmZmVjdHMgZm9yIGJvdW5kXG4gICAgICAgKiB0ZW1wbGF0ZXMgYXJlIHN0b3JlZCBpbiBhIGxpbmtlZCBsaXN0IG9uIHRoZSBpbnN0YW5jZSBzbyB0aGF0XG4gICAgICAgKiB0ZW1wbGF0ZXMgY2FuIGJlIGVmZmljaWVudGx5IHN0YW1wZWQgYW5kIHVuc3RhbXBlZC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge0hUTUxUZW1wbGF0ZUVsZW1lbnR9IHRlbXBsYXRlIFRlbXBsYXRlIGNvbnRhaW5pbmcgYmluZGluZ1xuICAgICAgICogICBiaW5kaW5nc1xuICAgICAgICogQHJldHVybiB7T2JqZWN0fSBUZW1wbGF0ZSBtZXRhZGF0YSBvYmplY3RcbiAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAqL1xuICAgICAgc3RhdGljIGJpbmRUZW1wbGF0ZSh0ZW1wbGF0ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm90b3R5cGUuX2JpbmRUZW1wbGF0ZSh0ZW1wbGF0ZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIC0tIGJpbmRpbmcgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAvKipcbiAgICAgICAqIEVxdWl2YWxlbnQgdG8gc3RhdGljIGBiaW5kVGVtcGxhdGVgIEFQSSBidXQgY2FuIGJlIGNhbGxlZCBvblxuICAgICAgICogYW4gaW5zdGFuY2UgdG8gYWRkIGVmZmVjdHMgYXQgcnVudGltZS4gIFNlZSB0aGF0IG1ldGhvZCBmb3JcbiAgICAgICAqIGZ1bGwgQVBJIGRvY3MuXG4gICAgICAgKlxuICAgICAgICogVGhpcyBtZXRob2QgbWF5IGJlIGNhbGxlZCBvbiB0aGUgcHJvdG90eXBlIChmb3IgcHJvdG90eXBpY2FsIHRlbXBsYXRlXG4gICAgICAgKiBiaW5kaW5nLCB0byBhdm9pZCBjcmVhdGluZyBhY2Nlc3NvcnMgZXZlcnkgaW5zdGFuY2UpIG9uY2UgcGVyIHByb3RvdHlwZSxcbiAgICAgICAqIGFuZCB3aWxsIGJlIGNhbGxlZCB3aXRoIGBydW50aW1lQmluZGluZzogdHJ1ZWAgYnkgYF9zdGFtcFRlbXBsYXRlYCB0b1xuICAgICAgICogY3JlYXRlIGFuZCBsaW5rIGFuIGluc3RhbmNlIG9mIHRoZSB0ZW1wbGF0ZSBtZXRhZGF0YSBhc3NvY2lhdGVkIHdpdGggYVxuICAgICAgICogcGFydGljdWxhciBzdGFtcGluZy5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge0hUTUxUZW1wbGF0ZUVsZW1lbnR9IHRlbXBsYXRlIFRlbXBsYXRlIGNvbnRhaW5pbmcgYmluZGluZ1xuICAgICAgICogICBiaW5kaW5nc1xuICAgICAgICogQHBhcmFtIHtib29sZWFuPX0gaW5zdGFuY2VCaW5kaW5nIFdoZW4gZmFsc2UgKGRlZmF1bHQpLCBwZXJmb3Jtc1xuICAgICAgICogICBcInByb3RvdHlwaWNhbFwiIGJpbmRpbmcgb2YgdGhlIHRlbXBsYXRlIGFuZCBvdmVyd3JpdGVzIGFueSBwcmV2aW91c2x5XG4gICAgICAgKiAgIGJvdW5kIHRlbXBsYXRlIGZvciB0aGUgY2xhc3MuIFdoZW4gdHJ1ZSAoYXMgcGFzc2VkIGZyb21cbiAgICAgICAqICAgYF9zdGFtcFRlbXBsYXRlYCksIHRoZSB0ZW1wbGF0ZSBpbmZvIGlzIGluc3RhbmNlZCBhbmQgbGlua2VkIGludG9cbiAgICAgICAqICAgdGhlIGxpc3Qgb2YgYm91bmQgdGVtcGxhdGVzLlxuICAgICAgICogQHJldHVybiB7IVRlbXBsYXRlSW5mb30gVGVtcGxhdGUgbWV0YWRhdGEgb2JqZWN0OyBmb3IgYHJ1bnRpbWVCaW5kaW5nYCxcbiAgICAgICAqICAgdGhpcyBpcyBhbiBpbnN0YW5jZSBvZiB0aGUgcHJvdG90eXBpY2FsIHRlbXBsYXRlIGluZm9cbiAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAqL1xuICAgICAgX2JpbmRUZW1wbGF0ZSh0ZW1wbGF0ZSwgaW5zdGFuY2VCaW5kaW5nKSB7XG4gICAgICAgIGxldCB0ZW1wbGF0ZUluZm8gPSB0aGlzLmNvbnN0cnVjdG9yLl9wYXJzZVRlbXBsYXRlKHRlbXBsYXRlKTtcbiAgICAgICAgbGV0IHdhc1ByZUJvdW5kID0gdGhpcy5fX3RlbXBsYXRlSW5mbyA9PSB0ZW1wbGF0ZUluZm87XG4gICAgICAgIC8vIE9wdGltaXphdGlvbjogc2luY2UgdGhpcyBpcyBjYWxsZWQgdHdpY2UgZm9yIHByb3RvLWJvdW5kIHRlbXBsYXRlcyxcbiAgICAgICAgLy8gZG9uJ3QgYXR0ZW1wdCB0byByZWNyZWF0ZSBhY2Nlc3NvcnMgaWYgdGhpcyB0ZW1wbGF0ZSB3YXMgcHJlLWJvdW5kXG4gICAgICAgIGlmICghd2FzUHJlQm91bmQpIHtcbiAgICAgICAgICBmb3IgKGxldCBwcm9wIGluIHRlbXBsYXRlSW5mby5wcm9wZXJ0eUVmZmVjdHMpIHtcbiAgICAgICAgICAgIHRoaXMuX2NyZWF0ZVByb3BlcnR5QWNjZXNzb3IocHJvcCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpbnN0YW5jZUJpbmRpbmcpIHtcbiAgICAgICAgICAvLyBGb3IgaW5zdGFuY2UtdGltZSBiaW5kaW5nLCBjcmVhdGUgaW5zdGFuY2Ugb2YgdGVtcGxhdGUgbWV0YWRhdGFcbiAgICAgICAgICAvLyBhbmQgbGluayBpbnRvIGxpc3Qgb2YgdGVtcGxhdGVzIGlmIG5lY2Vzc2FyeVxuICAgICAgICAgIHRlbXBsYXRlSW5mbyA9IC8qKiBAdHlwZSB7IVRlbXBsYXRlSW5mb30gKi8oT2JqZWN0LmNyZWF0ZSh0ZW1wbGF0ZUluZm8pKTtcbiAgICAgICAgICB0ZW1wbGF0ZUluZm8ud2FzUHJlQm91bmQgPSB3YXNQcmVCb3VuZDtcbiAgICAgICAgICBpZiAoIXdhc1ByZUJvdW5kICYmIHRoaXMuX190ZW1wbGF0ZUluZm8pIHtcbiAgICAgICAgICAgIGxldCBsYXN0ID0gdGhpcy5fX3RlbXBsYXRlSW5mb0xhc3QgfHwgdGhpcy5fX3RlbXBsYXRlSW5mbztcbiAgICAgICAgICAgIHRoaXMuX190ZW1wbGF0ZUluZm9MYXN0ID0gbGFzdC5uZXh0VGVtcGxhdGVJbmZvID0gdGVtcGxhdGVJbmZvO1xuICAgICAgICAgICAgdGVtcGxhdGVJbmZvLnByZXZpb3VzVGVtcGxhdGVJbmZvID0gbGFzdDtcbiAgICAgICAgICAgIHJldHVybiB0ZW1wbGF0ZUluZm87XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9fdGVtcGxhdGVJbmZvID0gdGVtcGxhdGVJbmZvO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEFkZHMgYSBwcm9wZXJ0eSBlZmZlY3QgdG8gdGhlIGdpdmVuIHRlbXBsYXRlIG1ldGFkYXRhLCB3aGljaCBpcyBydW5cbiAgICAgICAqIGF0IHRoZSBcInByb3BhZ2F0ZVwiIHN0YWdlIG9mIGBfcHJvcGVydGllc0NoYW5nZWRgIHdoZW4gdGhlIHRlbXBsYXRlXG4gICAgICAgKiBoYXMgYmVlbiBib3VuZCB0byB0aGUgZWxlbWVudCB2aWEgYF9iaW5kVGVtcGxhdGVgLlxuICAgICAgICpcbiAgICAgICAqIFRoZSBgZWZmZWN0YCBvYmplY3Qgc2hvdWxkIG1hdGNoIHRoZSBmb3JtYXQgaW4gYF9hZGRQcm9wZXJ0eUVmZmVjdGAuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IHRlbXBsYXRlSW5mbyBUZW1wbGF0ZSBtZXRhZGF0YSB0byBhZGQgZWZmZWN0IHRvXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcCBQcm9wZXJ0eSB0aGF0IHNob3VsZCB0cmlnZ2VyIHRoZSBlZmZlY3RcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0PX0gZWZmZWN0IEVmZmVjdCBtZXRhZGF0YSBvYmplY3RcbiAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAqL1xuICAgICAgc3RhdGljIF9hZGRUZW1wbGF0ZVByb3BlcnR5RWZmZWN0KHRlbXBsYXRlSW5mbywgcHJvcCwgZWZmZWN0KSB7XG4gICAgICAgIGxldCBob3N0UHJvcHMgPSB0ZW1wbGF0ZUluZm8uaG9zdFByb3BzID0gdGVtcGxhdGVJbmZvLmhvc3RQcm9wcyB8fCB7fTtcbiAgICAgICAgaG9zdFByb3BzW3Byb3BdID0gdHJ1ZTtcbiAgICAgICAgbGV0IGVmZmVjdHMgPSB0ZW1wbGF0ZUluZm8ucHJvcGVydHlFZmZlY3RzID0gdGVtcGxhdGVJbmZvLnByb3BlcnR5RWZmZWN0cyB8fCB7fTtcbiAgICAgICAgbGV0IHByb3BFZmZlY3RzID0gZWZmZWN0c1twcm9wXSA9IGVmZmVjdHNbcHJvcF0gfHwgW107XG4gICAgICAgIHByb3BFZmZlY3RzLnB1c2goZWZmZWN0KTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBTdGFtcHMgdGhlIHByb3ZpZGVkIHRlbXBsYXRlIGFuZCBwZXJmb3JtcyBpbnN0YW5jZS10aW1lIHNldHVwIGZvclxuICAgICAgICogUG9seW1lciB0ZW1wbGF0ZSBmZWF0dXJlcywgaW5jbHVkaW5nIGRhdGEgYmluZGluZ3MsIGRlY2xhcmF0aXZlIGV2ZW50XG4gICAgICAgKiBsaXN0ZW5lcnMsIGFuZCB0aGUgYHRoaXMuJGAgbWFwIG9mIGBpZGAncyB0byBub2Rlcy4gIEEgZG9jdW1lbnQgZnJhZ21lbnRcbiAgICAgICAqIGlzIHJldHVybmVkIGNvbnRhaW5pbmcgdGhlIHN0YW1wZWQgRE9NLCByZWFkeSBmb3IgaW5zZXJ0aW9uIGludG8gdGhlXG4gICAgICAgKiBET00uXG4gICAgICAgKlxuICAgICAgICogVGhpcyBtZXRob2QgbWF5IGJlIGNhbGxlZCBtb3JlIHRoYW4gb25jZTsgaG93ZXZlciBub3RlIHRoYXQgZHVlIHRvXG4gICAgICAgKiBgc2hhZHljc3NgIHBvbHlmaWxsIGxpbWl0YXRpb25zLCBvbmx5IHN0eWxlcyBmcm9tIHRlbXBsYXRlcyBwcmVwYXJlZFxuICAgICAgICogdXNpbmcgYFNoYWR5Q1NTLnByZXBhcmVUZW1wbGF0ZWAgd2lsbCBiZSBjb3JyZWN0bHkgcG9seWZpbGxlZCAoc2NvcGVkXG4gICAgICAgKiB0byB0aGUgc2hhZG93IHJvb3QgYW5kIHN1cHBvcnQgQ1NTIGN1c3RvbSBwcm9wZXJ0aWVzKSwgYW5kIG5vdGUgdGhhdFxuICAgICAgICogYFNoYWR5Q1NTLnByZXBhcmVUZW1wbGF0ZWAgbWF5IG9ubHkgYmUgY2FsbGVkIG9uY2UgcGVyIGVsZW1lbnQuIEFzIHN1Y2gsXG4gICAgICAgKiBhbnkgc3R5bGVzIHJlcXVpcmVkIGJ5IGluIHJ1bnRpbWUtc3RhbXBlZCB0ZW1wbGF0ZXMgbXVzdCBiZSBpbmNsdWRlZFxuICAgICAgICogaW4gdGhlIG1haW4gZWxlbWVudCB0ZW1wbGF0ZS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0geyFIVE1MVGVtcGxhdGVFbGVtZW50fSB0ZW1wbGF0ZSBUZW1wbGF0ZSB0byBzdGFtcFxuICAgICAgICogQHJldHVybiB7IVN0YW1wZWRUZW1wbGF0ZX0gQ2xvbmVkIHRlbXBsYXRlIGNvbnRlbnRcbiAgICAgICAqIEBvdmVycmlkZVxuICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICovXG4gICAgICBfc3RhbXBUZW1wbGF0ZSh0ZW1wbGF0ZSkge1xuICAgICAgICAvLyBFbnN1cmVzIHRoYXQgY3JlYXRlZCBkb20gaXMgYF9lbnF1ZXVlQ2xpZW50YCdkIHRvIHRoaXMgZWxlbWVudCBzb1xuICAgICAgICAvLyB0aGF0IGl0IGNhbiBiZSBmbHVzaGVkIG9uIG5leHQgY2FsbCB0byBgX2ZsdXNoUHJvcGVydGllc2BcbiAgICAgICAgaG9zdFN0YWNrLmJlZ2luSG9zdGluZyh0aGlzKTtcbiAgICAgICAgbGV0IGRvbSA9IHN1cGVyLl9zdGFtcFRlbXBsYXRlKHRlbXBsYXRlKTtcbiAgICAgICAgaG9zdFN0YWNrLmVuZEhvc3RpbmcodGhpcyk7XG4gICAgICAgIGxldCB0ZW1wbGF0ZUluZm8gPSAvKiogQHR5cGUgeyFUZW1wbGF0ZUluZm99ICovKHRoaXMuX2JpbmRUZW1wbGF0ZSh0ZW1wbGF0ZSwgdHJ1ZSkpO1xuICAgICAgICAvLyBBZGQgdGVtcGxhdGUtaW5zdGFuY2Utc3BlY2lmaWMgZGF0YSB0byBpbnN0YW5jZWQgdGVtcGxhdGVJbmZvXG4gICAgICAgIHRlbXBsYXRlSW5mby5ub2RlTGlzdCA9IGRvbS5ub2RlTGlzdDtcbiAgICAgICAgLy8gQ2FwdHVyZSBjaGlsZCBub2RlcyB0byBhbGxvdyB1bnN0YW1waW5nIG9mIG5vbi1wcm90b3R5cGljYWwgdGVtcGxhdGVzXG4gICAgICAgIGlmICghdGVtcGxhdGVJbmZvLndhc1ByZUJvdW5kKSB7XG4gICAgICAgICAgbGV0IG5vZGVzID0gdGVtcGxhdGVJbmZvLmNoaWxkTm9kZXMgPSBbXTtcbiAgICAgICAgICBmb3IgKGxldCBuPWRvbS5maXJzdENoaWxkOyBuOyBuPW4ubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICAgIG5vZGVzLnB1c2gobik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGRvbS50ZW1wbGF0ZUluZm8gPSB0ZW1wbGF0ZUluZm87XG4gICAgICAgIC8vIFNldHVwIGNvbXBvdW5kIHN0b3JhZ2UsIDItd2F5IGxpc3RlbmVycywgYW5kIGRhdGFIb3N0IGZvciBiaW5kaW5nc1xuICAgICAgICBzZXR1cEJpbmRpbmdzKHRoaXMsIHRlbXBsYXRlSW5mbyk7XG4gICAgICAgIC8vIEZsdXNoIHByb3BlcnRpZXMgaW50byB0ZW1wbGF0ZSBub2RlcyBpZiBhbHJlYWR5IGJvb3RlZFxuICAgICAgICBpZiAodGhpcy5fX2RhdGFSZWFkeSkge1xuICAgICAgICAgIHJ1bkVmZmVjdHModGhpcywgdGVtcGxhdGVJbmZvLnByb3BlcnR5RWZmZWN0cywgdGhpcy5fX2RhdGEsIG51bGwsXG4gICAgICAgICAgICBmYWxzZSwgdGVtcGxhdGVJbmZvLm5vZGVMaXN0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZG9tO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJlbW92ZXMgYW5kIHVuYmluZHMgdGhlIG5vZGVzIHByZXZpb3VzbHkgY29udGFpbmVkIGluIHRoZSBwcm92aWRlZFxuICAgICAgICogRG9jdW1lbnRGcmFnbWVudCByZXR1cm5lZCBmcm9tIGBfc3RhbXBUZW1wbGF0ZWAuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHshU3RhbXBlZFRlbXBsYXRlfSBkb20gRG9jdW1lbnRGcmFnbWVudCBwcmV2aW91c2x5IHJldHVybmVkXG4gICAgICAgKiAgIGZyb20gYF9zdGFtcFRlbXBsYXRlYCBhc3NvY2lhdGVkIHdpdGggdGhlIG5vZGVzIHRvIGJlIHJlbW92ZWRcbiAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAqL1xuICAgICAgX3JlbW92ZUJvdW5kRG9tKGRvbSkge1xuICAgICAgICAvLyBVbmxpbmsgdGVtcGxhdGUgaW5mb1xuICAgICAgICBsZXQgdGVtcGxhdGVJbmZvID0gZG9tLnRlbXBsYXRlSW5mbztcbiAgICAgICAgaWYgKHRlbXBsYXRlSW5mby5wcmV2aW91c1RlbXBsYXRlSW5mbykge1xuICAgICAgICAgIHRlbXBsYXRlSW5mby5wcmV2aW91c1RlbXBsYXRlSW5mby5uZXh0VGVtcGxhdGVJbmZvID1cbiAgICAgICAgICAgIHRlbXBsYXRlSW5mby5uZXh0VGVtcGxhdGVJbmZvO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0ZW1wbGF0ZUluZm8ubmV4dFRlbXBsYXRlSW5mbykge1xuICAgICAgICAgIHRlbXBsYXRlSW5mby5uZXh0VGVtcGxhdGVJbmZvLnByZXZpb3VzVGVtcGxhdGVJbmZvID1cbiAgICAgICAgICAgIHRlbXBsYXRlSW5mby5wcmV2aW91c1RlbXBsYXRlSW5mbztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fX3RlbXBsYXRlSW5mb0xhc3QgPT0gdGVtcGxhdGVJbmZvKSB7XG4gICAgICAgICAgdGhpcy5fX3RlbXBsYXRlSW5mb0xhc3QgPSB0ZW1wbGF0ZUluZm8ucHJldmlvdXNUZW1wbGF0ZUluZm87XG4gICAgICAgIH1cbiAgICAgICAgdGVtcGxhdGVJbmZvLnByZXZpb3VzVGVtcGxhdGVJbmZvID0gdGVtcGxhdGVJbmZvLm5leHRUZW1wbGF0ZUluZm8gPSBudWxsO1xuICAgICAgICAvLyBSZW1vdmUgc3RhbXBlZCBub2Rlc1xuICAgICAgICBsZXQgbm9kZXMgPSB0ZW1wbGF0ZUluZm8uY2hpbGROb2RlcztcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgbGV0IG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgICBub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBPdmVycmlkZXMgZGVmYXVsdCBgVGVtcGxhdGVTdGFtcGAgaW1wbGVtZW50YXRpb24gdG8gYWRkIHN1cHBvcnQgZm9yXG4gICAgICAgKiBwYXJzaW5nIGJpbmRpbmdzIGZyb20gYFRleHROb2RlYCdzJyBgdGV4dENvbnRlbnRgLiAgQSBgYmluZGluZ3NgXG4gICAgICAgKiBhcnJheSBpcyBhZGRlZCB0byBgbm9kZUluZm9gIGFuZCBwb3B1bGF0ZWQgd2l0aCBiaW5kaW5nIG1ldGFkYXRhXG4gICAgICAgKiB3aXRoIGluZm9ybWF0aW9uIGNhcHR1cmluZyB0aGUgYmluZGluZyB0YXJnZXQsIGFuZCBhIGBwYXJ0c2AgYXJyYXlcbiAgICAgICAqIHdpdGggb25lIG9yIG1vcmUgbWV0YWRhdGEgb2JqZWN0cyBjYXB0dXJpbmcgdGhlIHNvdXJjZShzKSBvZiB0aGVcbiAgICAgICAqIGJpbmRpbmcuXG4gICAgICAgKlxuICAgICAgICogQG92ZXJyaWRlXG4gICAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgTm9kZSB0byBwYXJzZVxuICAgICAgICogQHBhcmFtIHtUZW1wbGF0ZUluZm99IHRlbXBsYXRlSW5mbyBUZW1wbGF0ZSBtZXRhZGF0YSBmb3IgY3VycmVudCB0ZW1wbGF0ZVxuICAgICAgICogQHBhcmFtIHtOb2RlSW5mb30gbm9kZUluZm8gTm9kZSBtZXRhZGF0YSBmb3IgY3VycmVudCB0ZW1wbGF0ZSBub2RlXG4gICAgICAgKiBAcmV0dXJuIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIHZpc2l0ZWQgbm9kZSBhZGRlZCBub2RlLXNwZWNpZmljXG4gICAgICAgKiAgIG1ldGFkYXRhIHRvIGBub2RlSW5mb2BcbiAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAqIEBzdXBwcmVzcyB7bWlzc2luZ1Byb3BlcnRpZXN9IEludGVyZmFjZXMgaW4gY2xvc3VyZSBkbyBub3QgaW5oZXJpdCBzdGF0aWNzLCBidXQgY2xhc3NlcyBkb1xuICAgICAgICovXG4gICAgICBzdGF0aWMgX3BhcnNlVGVtcGxhdGVOb2RlKG5vZGUsIHRlbXBsYXRlSW5mbywgbm9kZUluZm8pIHtcbiAgICAgICAgbGV0IG5vdGVkID0gc3VwZXIuX3BhcnNlVGVtcGxhdGVOb2RlKG5vZGUsIHRlbXBsYXRlSW5mbywgbm9kZUluZm8pO1xuICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUpIHtcbiAgICAgICAgICBsZXQgcGFydHMgPSB0aGlzLl9wYXJzZUJpbmRpbmdzKG5vZGUudGV4dENvbnRlbnQsIHRlbXBsYXRlSW5mbyk7XG4gICAgICAgICAgaWYgKHBhcnRzKSB7XG4gICAgICAgICAgICAvLyBJbml0aWFsaXplIHRoZSB0ZXh0Q29udGVudCB3aXRoIGFueSBsaXRlcmFsIHBhcnRzXG4gICAgICAgICAgICAvLyBOT1RFOiBkZWZhdWx0IHRvIGEgc3BhY2UgaGVyZSBzbyB0aGUgdGV4dE5vZGUgcmVtYWluczsgc29tZSBicm93c2Vyc1xuICAgICAgICAgICAgLy8gKElFKSBldmFjaXBhdGUgYW4gZW1wdHkgdGV4dE5vZGUgZm9sbG93aW5nIGNsb25lTm9kZS9pbXBvcnROb2RlLlxuICAgICAgICAgICAgbm9kZS50ZXh0Q29udGVudCA9IGxpdGVyYWxGcm9tUGFydHMocGFydHMpIHx8ICcgJztcbiAgICAgICAgICAgIGFkZEJpbmRpbmcodGhpcywgdGVtcGxhdGVJbmZvLCBub2RlSW5mbywgJ3RleHQnLCAndGV4dENvbnRlbnQnLCBwYXJ0cyk7XG4gICAgICAgICAgICBub3RlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub3RlZDtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBPdmVycmlkZXMgZGVmYXVsdCBgVGVtcGxhdGVTdGFtcGAgaW1wbGVtZW50YXRpb24gdG8gYWRkIHN1cHBvcnQgZm9yXG4gICAgICAgKiBwYXJzaW5nIGJpbmRpbmdzIGZyb20gYXR0cmlidXRlcy4gIEEgYGJpbmRpbmdzYFxuICAgICAgICogYXJyYXkgaXMgYWRkZWQgdG8gYG5vZGVJbmZvYCBhbmQgcG9wdWxhdGVkIHdpdGggYmluZGluZyBtZXRhZGF0YVxuICAgICAgICogd2l0aCBpbmZvcm1hdGlvbiBjYXB0dXJpbmcgdGhlIGJpbmRpbmcgdGFyZ2V0LCBhbmQgYSBgcGFydHNgIGFycmF5XG4gICAgICAgKiB3aXRoIG9uZSBvciBtb3JlIG1ldGFkYXRhIG9iamVjdHMgY2FwdHVyaW5nIHRoZSBzb3VyY2Uocykgb2YgdGhlXG4gICAgICAgKiBiaW5kaW5nLlxuICAgICAgICpcbiAgICAgICAqIEBvdmVycmlkZVxuICAgICAgICogQHBhcmFtIHtFbGVtZW50fSBub2RlIE5vZGUgdG8gcGFyc2VcbiAgICAgICAqIEBwYXJhbSB7VGVtcGxhdGVJbmZvfSB0ZW1wbGF0ZUluZm8gVGVtcGxhdGUgbWV0YWRhdGEgZm9yIGN1cnJlbnQgdGVtcGxhdGVcbiAgICAgICAqIEBwYXJhbSB7Tm9kZUluZm99IG5vZGVJbmZvIE5vZGUgbWV0YWRhdGEgZm9yIGN1cnJlbnQgdGVtcGxhdGUgbm9kZVxuICAgICAgICogQHJldHVybiB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSB2aXNpdGVkIG5vZGUgYWRkZWQgbm9kZS1zcGVjaWZpY1xuICAgICAgICogICBtZXRhZGF0YSB0byBgbm9kZUluZm9gXG4gICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgKiBAc3VwcHJlc3Mge21pc3NpbmdQcm9wZXJ0aWVzfSBJbnRlcmZhY2VzIGluIGNsb3N1cmUgZG8gbm90IGluaGVyaXQgc3RhdGljcywgYnV0IGNsYXNzZXMgZG9cbiAgICAgICAqL1xuICAgICAgc3RhdGljIF9wYXJzZVRlbXBsYXRlTm9kZUF0dHJpYnV0ZShub2RlLCB0ZW1wbGF0ZUluZm8sIG5vZGVJbmZvLCBuYW1lLCB2YWx1ZSkge1xuICAgICAgICBsZXQgcGFydHMgPSB0aGlzLl9wYXJzZUJpbmRpbmdzKHZhbHVlLCB0ZW1wbGF0ZUluZm8pO1xuICAgICAgICBpZiAocGFydHMpIHtcbiAgICAgICAgICAvLyBBdHRyaWJ1dGUgb3IgcHJvcGVydHlcbiAgICAgICAgICBsZXQgb3JpZ05hbWUgPSBuYW1lO1xuICAgICAgICAgIGxldCBraW5kID0gJ3Byb3BlcnR5JztcbiAgICAgICAgICBpZiAobmFtZVtuYW1lLmxlbmd0aC0xXSA9PSAnJCcpIHtcbiAgICAgICAgICAgIG5hbWUgPSBuYW1lLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgICAgIGtpbmQgPSAnYXR0cmlidXRlJztcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gSW5pdGlhbGl6ZSBhdHRyaWJ1dGUgYmluZGluZ3Mgd2l0aCBhbnkgbGl0ZXJhbCBwYXJ0c1xuICAgICAgICAgIGxldCBsaXRlcmFsID0gbGl0ZXJhbEZyb21QYXJ0cyhwYXJ0cyk7XG4gICAgICAgICAgaWYgKGxpdGVyYWwgJiYga2luZCA9PSAnYXR0cmlidXRlJykge1xuICAgICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUobmFtZSwgbGl0ZXJhbCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIENsZWFyIGF0dHJpYnV0ZSBiZWZvcmUgcmVtb3ZpbmcsIHNpbmNlIElFIHdvbid0IGFsbG93IHJlbW92aW5nXG4gICAgICAgICAgLy8gYHZhbHVlYCBhdHRyaWJ1dGUgaWYgaXQgcHJldmlvdXNseSBoYWQgYSB2YWx1ZSAoY2FuJ3RcbiAgICAgICAgICAvLyB1bmNvbmRpdGlvbmFsbHkgc2V0ICcnIGJlZm9yZSByZW1vdmluZyBzaW5jZSBhdHRyaWJ1dGVzIHdpdGggYCRgXG4gICAgICAgICAgLy8gY2FuJ3QgYmUgc2V0IHVzaW5nIHNldEF0dHJpYnV0ZSlcbiAgICAgICAgICBpZiAobm9kZS5sb2NhbE5hbWUgPT09ICdpbnB1dCcgJiYgb3JpZ05hbWUgPT09ICd2YWx1ZScpIHtcbiAgICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKG9yaWdOYW1lLCAnJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFJlbW92ZSBhbm5vdGF0aW9uXG4gICAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUob3JpZ05hbWUpO1xuICAgICAgICAgIC8vIENhc2UgaGFja2VyeTogYXR0cmlidXRlcyBhcmUgbG93ZXItY2FzZSwgYnV0IGJpbmQgdGFyZ2V0c1xuICAgICAgICAgIC8vIChwcm9wZXJ0aWVzKSBhcmUgY2FzZSBzZW5zaXRpdmUuIEdhbWJpdCBpcyB0byBtYXAgZGFzaC1jYXNlIHRvXG4gICAgICAgICAgLy8gY2FtZWwtY2FzZTogYGZvby1iYXJgIGJlY29tZXMgYGZvb0JhcmAuXG4gICAgICAgICAgLy8gQXR0cmlidXRlIGJpbmRpbmdzIGFyZSBleGNlcHRlZC5cbiAgICAgICAgICBpZiAoa2luZCA9PT0gJ3Byb3BlcnR5Jykge1xuICAgICAgICAgICAgbmFtZSA9IFBvbHltZXIuQ2FzZU1hcC5kYXNoVG9DYW1lbENhc2UobmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGFkZEJpbmRpbmcodGhpcywgdGVtcGxhdGVJbmZvLCBub2RlSW5mbywga2luZCwgbmFtZSwgcGFydHMsIGxpdGVyYWwpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBzdXBlci5fcGFyc2VUZW1wbGF0ZU5vZGVBdHRyaWJ1dGUobm9kZSwgdGVtcGxhdGVJbmZvLCBub2RlSW5mbywgbmFtZSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogT3ZlcnJpZGVzIGRlZmF1bHQgYFRlbXBsYXRlU3RhbXBgIGltcGxlbWVudGF0aW9uIHRvIGFkZCBzdXBwb3J0IGZvclxuICAgICAgICogYmluZGluZyB0aGUgcHJvcGVydGllcyB0aGF0IGEgbmVzdGVkIHRlbXBsYXRlIGRlcGVuZHMgb24gdG8gdGhlIHRlbXBsYXRlXG4gICAgICAgKiBhcyBgX2hvc3RfPHByb3BlcnR5PmAuXG4gICAgICAgKlxuICAgICAgICogQG92ZXJyaWRlXG4gICAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgTm9kZSB0byBwYXJzZVxuICAgICAgICogQHBhcmFtIHtUZW1wbGF0ZUluZm99IHRlbXBsYXRlSW5mbyBUZW1wbGF0ZSBtZXRhZGF0YSBmb3IgY3VycmVudCB0ZW1wbGF0ZVxuICAgICAgICogQHBhcmFtIHtOb2RlSW5mb30gbm9kZUluZm8gTm9kZSBtZXRhZGF0YSBmb3IgY3VycmVudCB0ZW1wbGF0ZSBub2RlXG4gICAgICAgKiBAcmV0dXJuIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIHZpc2l0ZWQgbm9kZSBhZGRlZCBub2RlLXNwZWNpZmljXG4gICAgICAgKiAgIG1ldGFkYXRhIHRvIGBub2RlSW5mb2BcbiAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAqIEBzdXBwcmVzcyB7bWlzc2luZ1Byb3BlcnRpZXN9IEludGVyZmFjZXMgaW4gY2xvc3VyZSBkbyBub3QgaW5oZXJpdCBzdGF0aWNzLCBidXQgY2xhc3NlcyBkb1xuICAgICAgICovXG4gICAgICBzdGF0aWMgX3BhcnNlVGVtcGxhdGVOZXN0ZWRUZW1wbGF0ZShub2RlLCB0ZW1wbGF0ZUluZm8sIG5vZGVJbmZvKSB7XG4gICAgICAgIGxldCBub3RlZCA9IHN1cGVyLl9wYXJzZVRlbXBsYXRlTmVzdGVkVGVtcGxhdGUobm9kZSwgdGVtcGxhdGVJbmZvLCBub2RlSW5mbyk7XG4gICAgICAgIC8vIE1lcmdlIGhvc3QgcHJvcHMgaW50byBvdXRlciB0ZW1wbGF0ZSBhbmQgYWRkIGJpbmRpbmdzXG4gICAgICAgIGxldCBob3N0UHJvcHMgPSBub2RlSW5mby50ZW1wbGF0ZUluZm8uaG9zdFByb3BzO1xuICAgICAgICBsZXQgbW9kZSA9ICd7JztcbiAgICAgICAgZm9yIChsZXQgc291cmNlIGluIGhvc3RQcm9wcykge1xuICAgICAgICAgIGxldCBwYXJ0cyA9IFt7IG1vZGUsIHNvdXJjZSwgZGVwZW5kZW5jaWVzOiBbc291cmNlXSB9XTtcbiAgICAgICAgICBhZGRCaW5kaW5nKHRoaXMsIHRlbXBsYXRlSW5mbywgbm9kZUluZm8sICdwcm9wZXJ0eScsICdfaG9zdF8nICsgc291cmNlLCBwYXJ0cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vdGVkO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENhbGxlZCB0byBwYXJzZSB0ZXh0IGluIGEgdGVtcGxhdGUgKGVpdGhlciBhdHRyaWJ1dGUgdmFsdWVzIG9yXG4gICAgICAgKiB0ZXh0Q29udGVudCkgaW50byBiaW5kaW5nIG1ldGFkYXRhLlxuICAgICAgICpcbiAgICAgICAqIEFueSBvdmVycmlkZXMgb2YgdGhpcyBtZXRob2Qgc2hvdWxkIHJldHVybiBhbiBhcnJheSBvZiBiaW5kaW5nIHBhcnRcbiAgICAgICAqIG1ldGFkYXRhICByZXByZXNlbnRpbmcgb25lIG9yIG1vcmUgYmluZGluZ3MgZm91bmQgaW4gdGhlIHByb3ZpZGVkIHRleHRcbiAgICAgICAqIGFuZCBhbnkgXCJsaXRlcmFsXCIgdGV4dCBpbiBiZXR3ZWVuLiAgQW55IG5vbi1saXRlcmFsIHBhcnRzIHdpbGwgYmUgcGFzc2VkXG4gICAgICAgKiB0byBgX2V2YWx1YXRlQmluZGluZ2Agd2hlbiBhbnkgZGVwZW5kZW5jaWVzIGNoYW5nZS4gIFRoZSBvbmx5IHJlcXVpcmVkXG4gICAgICAgKiBmaWVsZHMgb2YgZWFjaCBcInBhcnRcIiBpbiB0aGUgcmV0dXJuZWQgYXJyYXkgYXJlIGFzIGZvbGxvd3M6XG4gICAgICAgKlxuICAgICAgICogLSBgZGVwZW5kZW5jaWVzYCAtIEFycmF5IGNvbnRhaW5pbmcgdHJpZ2dlciBtZXRhZGF0YSBmb3IgZWFjaCBwcm9wZXJ0eVxuICAgICAgICogICB0aGF0IHNob3VsZCB0cmlnZ2VyIHRoZSBiaW5kaW5nIHRvIHVwZGF0ZVxuICAgICAgICogLSBgbGl0ZXJhbGAgLSBTdHJpbmcgY29udGFpbmluZyB0ZXh0IGlmIHRoZSBwYXJ0IHJlcHJlc2VudHMgYSBsaXRlcmFsO1xuICAgICAgICogICBpbiB0aGlzIGNhc2Ugbm8gYGRlcGVuZGVuY2llc2AgYXJlIG5lZWRlZFxuICAgICAgICpcbiAgICAgICAqIEFkZGl0aW9uYWwgbWV0YWRhdGEgZm9yIHVzZSBieSBgX2V2YWx1YXRlQmluZGluZ2AgbWF5IGJlIHByb3ZpZGVkIGluXG4gICAgICAgKiBlYWNoIHBhcnQgb2JqZWN0IGFzIG5lZWRlZC5cbiAgICAgICAqXG4gICAgICAgKiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBoYW5kbGVzIHRoZSBmb2xsb3dpbmcgdHlwZXMgb2YgYmluZGluZ3NcbiAgICAgICAqIChvbmUgb3IgbW9yZSBtYXkgYmUgaW50ZXJtaXhlZCB3aXRoIGxpdGVyYWwgc3RyaW5ncyk6XG4gICAgICAgKiAtIFByb3BlcnR5IGJpbmRpbmc6IGBbW3Byb3BdXWBcbiAgICAgICAqIC0gUGF0aCBiaW5kaW5nOiBgW1tvYmplY3QucHJvcF1dYFxuICAgICAgICogLSBOZWdhdGVkIHByb3BlcnR5IG9yIHBhdGggYmluZGluZ3M6IGBbWyFwcm9wXV1gIG9yIGBbWyFvYmplY3QucHJvcF1dYFxuICAgICAgICogLSBUd28td2F5IHByb3BlcnR5IG9yIHBhdGggYmluZGluZ3MgKHN1cHBvcnRzIG5lZ2F0aW9uKTpcbiAgICAgICAqICAgYHt7cHJvcH19YCwgYHt7b2JqZWN0LnByb3B9fWAsIGB7eyFwcm9wfX1gIG9yIGB7eyFvYmplY3QucHJvcH19YFxuICAgICAgICogLSBJbmxpbmUgY29tcHV0ZWQgbWV0aG9kIChzdXBwb3J0cyBuZWdhdGlvbik6XG4gICAgICAgKiAgIGBbW2NvbXB1dGUoYSwgJ2xpdGVyYWwnLCBiKV1dYCwgYFtbIWNvbXB1dGUoYSwgJ2xpdGVyYWwnLCBiKV1dYFxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IFRleHQgdG8gcGFyc2UgZnJvbSBhdHRyaWJ1dGUgb3IgdGV4dENvbnRlbnRcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0ZW1wbGF0ZUluZm8gQ3VycmVudCB0ZW1wbGF0ZSBtZXRhZGF0YVxuICAgICAgICogQHJldHVybiB7QXJyYXk8IUJpbmRpbmdQYXJ0Pn0gQXJyYXkgb2YgYmluZGluZyBwYXJ0IG1ldGFkYXRhXG4gICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgKi9cbiAgICAgIHN0YXRpYyBfcGFyc2VCaW5kaW5ncyh0ZXh0LCB0ZW1wbGF0ZUluZm8pIHtcbiAgICAgICAgbGV0IHBhcnRzID0gW107XG4gICAgICAgIGxldCBsYXN0SW5kZXggPSAwO1xuICAgICAgICBsZXQgbTtcbiAgICAgICAgLy8gRXhhbXBsZTogXCJsaXRlcmFsMXt7cHJvcH19bGl0ZXJhbDJbWyFjb21wdXRlKGZvbyxiYXIpXV1maW5hbFwiXG4gICAgICAgIC8vIFJlZ2V4IG1hdGNoZXM6XG4gICAgICAgIC8vICAgICAgICBJdGVyYXRpb24gMTogIEl0ZXJhdGlvbiAyOlxuICAgICAgICAvLyBtWzFdOiAne3snICAgICAgICAgICdbWydcbiAgICAgICAgLy8gbVsyXTogJycgICAgICAgICAgICAnISdcbiAgICAgICAgLy8gbVszXTogJ3Byb3AnICAgICAgICAnY29tcHV0ZShmb28sYmFyKSdcbiAgICAgICAgd2hpbGUgKChtID0gYmluZGluZ1JlZ2V4LmV4ZWModGV4dCkpICE9PSBudWxsKSB7XG4gICAgICAgICAgLy8gQWRkIGxpdGVyYWwgcGFydFxuICAgICAgICAgIGlmIChtLmluZGV4ID4gbGFzdEluZGV4KSB7XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKHtsaXRlcmFsOiB0ZXh0LnNsaWNlKGxhc3RJbmRleCwgbS5pbmRleCl9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gQWRkIGJpbmRpbmcgcGFydFxuICAgICAgICAgIGxldCBtb2RlID0gbVsxXVswXTtcbiAgICAgICAgICBsZXQgbmVnYXRlID0gQm9vbGVhbihtWzJdKTtcbiAgICAgICAgICBsZXQgc291cmNlID0gbVszXS50cmltKCk7XG4gICAgICAgICAgbGV0IGN1c3RvbUV2ZW50ID0gZmFsc2UsIG5vdGlmeUV2ZW50ID0gJycsIGNvbG9uID0gLTE7XG4gICAgICAgICAgaWYgKG1vZGUgPT0gJ3snICYmIChjb2xvbiA9IHNvdXJjZS5pbmRleE9mKCc6OicpKSA+IDApIHtcbiAgICAgICAgICAgIG5vdGlmeUV2ZW50ID0gc291cmNlLnN1YnN0cmluZyhjb2xvbiArIDIpO1xuICAgICAgICAgICAgc291cmNlID0gc291cmNlLnN1YnN0cmluZygwLCBjb2xvbik7XG4gICAgICAgICAgICBjdXN0b21FdmVudCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCBzaWduYXR1cmUgPSBwYXJzZU1ldGhvZChzb3VyY2UpO1xuICAgICAgICAgIGxldCBkZXBlbmRlbmNpZXMgPSBbXTtcbiAgICAgICAgICBpZiAoc2lnbmF0dXJlKSB7XG4gICAgICAgICAgICAvLyBJbmxpbmUgY29tcHV0ZWQgZnVuY3Rpb25cbiAgICAgICAgICAgIGxldCB7YXJncywgbWV0aG9kTmFtZX0gPSBzaWduYXR1cmU7XG4gICAgICAgICAgICBmb3IgKGxldCBpPTA7IGk8YXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBsZXQgYXJnID0gYXJnc1tpXTtcbiAgICAgICAgICAgICAgaWYgKCFhcmcubGl0ZXJhbCkge1xuICAgICAgICAgICAgICAgIGRlcGVuZGVuY2llcy5wdXNoKGFyZyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBkeW5hbWljRm5zID0gdGVtcGxhdGVJbmZvLmR5bmFtaWNGbnM7XG4gICAgICAgICAgICBpZiAoZHluYW1pY0ZucyAmJiBkeW5hbWljRm5zW21ldGhvZE5hbWVdIHx8IHNpZ25hdHVyZS5zdGF0aWMpIHtcbiAgICAgICAgICAgICAgZGVwZW5kZW5jaWVzLnB1c2gobWV0aG9kTmFtZSk7XG4gICAgICAgICAgICAgIHNpZ25hdHVyZS5keW5hbWljRm4gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBQcm9wZXJ0eSBvciBwYXRoXG4gICAgICAgICAgICBkZXBlbmRlbmNpZXMucHVzaChzb3VyY2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwYXJ0cy5wdXNoKHtcbiAgICAgICAgICAgIHNvdXJjZSwgbW9kZSwgbmVnYXRlLCBjdXN0b21FdmVudCwgc2lnbmF0dXJlLCBkZXBlbmRlbmNpZXMsXG4gICAgICAgICAgICBldmVudDogbm90aWZ5RXZlbnRcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBsYXN0SW5kZXggPSBiaW5kaW5nUmVnZXgubGFzdEluZGV4O1xuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCBhIGZpbmFsIGxpdGVyYWwgcGFydFxuICAgICAgICBpZiAobGFzdEluZGV4ICYmIGxhc3RJbmRleCA8IHRleHQubGVuZ3RoKSB7XG4gICAgICAgICAgbGV0IGxpdGVyYWwgPSB0ZXh0LnN1YnN0cmluZyhsYXN0SW5kZXgpO1xuICAgICAgICAgIGlmIChsaXRlcmFsKSB7XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKHtcbiAgICAgICAgICAgICAgbGl0ZXJhbDogbGl0ZXJhbFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0cy5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gcGFydHM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDYWxsZWQgdG8gZXZhbHVhdGUgYSBwcmV2aW91c2x5IHBhcnNlZCBiaW5kaW5nIHBhcnQgYmFzZWQgb24gYSBzZXQgb2ZcbiAgICAgICAqIG9uZSBvciBtb3JlIGNoYW5nZWQgZGVwZW5kZW5jaWVzLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7dGhpc30gaW5zdCBFbGVtZW50IHRoYXQgc2hvdWxkIGJlIHVzZWQgYXMgc2NvcGUgZm9yXG4gICAgICAgKiAgIGJpbmRpbmcgZGVwZW5kZW5jaWVzXG4gICAgICAgKiBAcGFyYW0ge0JpbmRpbmdQYXJ0fSBwYXJ0IEJpbmRpbmcgcGFydCBtZXRhZGF0YVxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggUHJvcGVydHkvcGF0aCB0aGF0IHRyaWdnZXJlZCB0aGlzIGVmZmVjdFxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzIEJhZyBvZiBjdXJyZW50IHByb3BlcnR5IGNoYW5nZXNcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvbGRQcm9wcyBCYWcgb2YgcHJldmlvdXMgdmFsdWVzIGZvciBjaGFuZ2VkIHByb3BlcnRpZXNcbiAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaGFzUGF0aHMgVHJ1ZSB3aXRoIGBwcm9wc2AgY29udGFpbnMgb25lIG9yIG1vcmUgcGF0aHNcbiAgICAgICAqIEByZXR1cm4geyp9IFZhbHVlIHRoZSBiaW5kaW5nIHBhcnQgZXZhbHVhdGVkIHRvXG4gICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgKi9cbiAgICAgIHN0YXRpYyBfZXZhbHVhdGVCaW5kaW5nKGluc3QsIHBhcnQsIHBhdGgsIHByb3BzLCBvbGRQcm9wcywgaGFzUGF0aHMpIHtcbiAgICAgICAgbGV0IHZhbHVlO1xuICAgICAgICBpZiAocGFydC5zaWduYXR1cmUpIHtcbiAgICAgICAgICB2YWx1ZSA9IHJ1bk1ldGhvZEVmZmVjdChpbnN0LCBwYXRoLCBwcm9wcywgb2xkUHJvcHMsIHBhcnQuc2lnbmF0dXJlKTtcbiAgICAgICAgfSBlbHNlIGlmIChwYXRoICE9IHBhcnQuc291cmNlKSB7XG4gICAgICAgICAgdmFsdWUgPSBQb2x5bWVyLlBhdGguZ2V0KGluc3QsIHBhcnQuc291cmNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoaGFzUGF0aHMgJiYgUG9seW1lci5QYXRoLmlzUGF0aChwYXRoKSkge1xuICAgICAgICAgICAgdmFsdWUgPSBQb2x5bWVyLlBhdGguZ2V0KGluc3QsIHBhdGgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGluc3QuX19kYXRhW3BhdGhdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydC5uZWdhdGUpIHtcbiAgICAgICAgICB2YWx1ZSA9ICF2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG5cbiAgICB9XG5cbiAgICAvLyBtYWtlIGEgdHlwaW5nIGZvciBjbG9zdXJlIDpQXG4gICAgUHJvcGVydHlFZmZlY3RzVHlwZSA9IFByb3BlcnR5RWZmZWN0cztcblxuICAgIHJldHVybiBQcm9wZXJ0eUVmZmVjdHM7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBIZWxwZXIgYXBpIGZvciBlbnF1ZWluZyBjbGllbnQgZG9tIGNyZWF0ZWQgYnkgYSBob3N0IGVsZW1lbnQuXG4gICAqXG4gICAqIEJ5IGRlZmF1bHQgZWxlbWVudHMgYXJlIGZsdXNoZWQgdmlhIGBfZmx1c2hQcm9wZXJ0aWVzYCB3aGVuXG4gICAqIGBjb25uZWN0ZWRDYWxsYmFja2AgaXMgY2FsbGVkLiBFbGVtZW50cyBhdHRhY2ggdGhlaXIgY2xpZW50IGRvbSB0b1xuICAgKiB0aGVtc2VsdmVzIGF0IGByZWFkeWAgdGltZSB3aGljaCByZXN1bHRzIGZyb20gdGhpcyBmaXJzdCBmbHVzaC5cbiAgICogVGhpcyBwcm92aWRlcyBhbiBvcmRlcmluZyBndWFyYW50ZWUgdGhhdCB0aGUgY2xpZW50IGRvbSBhbiBlbGVtZW50XG4gICAqIGNyZWF0ZXMgaXMgZmx1c2hlZCBiZWZvcmUgdGhlIGVsZW1lbnQgaXRzZWxmIChpLmUuIGNsaWVudCBgcmVhZHlgXG4gICAqIGZpcmVzIGJlZm9yZSBob3N0IGByZWFkeWApLlxuICAgKlxuICAgKiBIb3dldmVyLCBpZiBgX2ZsdXNoUHJvcGVydGllc2AgaXMgY2FsbGVkICpiZWZvcmUqIGFuIGVsZW1lbnQgaXMgY29ubmVjdGVkLFxuICAgKiBhcyBmb3IgZXhhbXBsZSBgVGVtcGxhdGl6ZWAgZG9lcywgdGhpcyBvcmRlcmluZyBndWFyYW50ZWUgY2Fubm90IGJlXG4gICAqIHNhdGlzZmllZCBiZWNhdXNlIG5vIGVsZW1lbnRzIGFyZSBjb25uZWN0ZWQuIChOb3RlOiBCb3VuZCBlbGVtZW50cyB0aGF0XG4gICAqIHJlY2VpdmUgZGF0YSBkbyBiZWNvbWUgZW5xdWV1ZWQgY2xpZW50cyBhbmQgYXJlIHByb3Blcmx5IG9yZGVyZWQgYnV0XG4gICAqIHVuYm91bmQgZWxlbWVudHMgYXJlIG5vdC4pXG4gICAqXG4gICAqIFRvIG1haW50YWluIHRoZSBkZXNpcmVkIFwiY2xpZW50IGJlZm9yZSBob3N0XCIgb3JkZXJpbmcgZ3VhcmFudGVlIGZvciB0aGlzXG4gICAqIGNhc2Ugd2UgcmVseSBvbiB0aGUgXCJob3N0IHN0YWNrLiBDbGllbnQgbm9kZXMgcmVnaXN0ZXJzIHRoZW1zZWx2ZXMgd2l0aFxuICAgKiB0aGUgY3JlYXRpbmcgaG9zdCBlbGVtZW50IHdoZW4gY3JlYXRlZC4gVGhpcyBlbnN1cmVzIHRoYXQgYWxsIGNsaWVudCBkb21cbiAgICogaXMgcmVhZGllZCBpbiB0aGUgcHJvcGVyIG9yZGVyLCBtYWludGFpbmluZyB0aGUgZGVzaXJlZCBndWFyYW50ZWUuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBsZXQgaG9zdFN0YWNrID0ge1xuXG4gICAgc3RhY2s6IFtdLFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHsqfSBpbnN0IEluc3RhbmNlIHRvIGFkZCB0byBob3N0U3RhY2tcbiAgICAgKiBAdGhpcyB7aG9zdFN0YWNrfVxuICAgICAqL1xuICAgIHJlZ2lzdGVySG9zdChpbnN0KSB7XG4gICAgICBpZiAodGhpcy5zdGFjay5sZW5ndGgpIHtcbiAgICAgICAgbGV0IGhvc3QgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoLTFdO1xuICAgICAgICBob3N0Ll9lbnF1ZXVlQ2xpZW50KGluc3QpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyp9IGluc3QgSW5zdGFuY2UgdG8gYmVnaW4gaG9zdGluZ1xuICAgICAqIEB0aGlzIHtob3N0U3RhY2t9XG4gICAgICovXG4gICAgYmVnaW5Ib3N0aW5nKGluc3QpIHtcbiAgICAgIHRoaXMuc3RhY2sucHVzaChpbnN0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHsqfSBpbnN0IEluc3RhbmNlIHRvIGVuZCBob3N0aW5nXG4gICAgICogQHRoaXMge2hvc3RTdGFja31cbiAgICAgKi9cbiAgICBlbmRIb3N0aW5nKGluc3QpIHtcbiAgICAgIGxldCBzdGFja0xlbiA9IHRoaXMuc3RhY2subGVuZ3RoO1xuICAgICAgaWYgKHN0YWNrTGVuICYmIHRoaXMuc3RhY2tbc3RhY2tMZW4tMV0gPT0gaW5zdCkge1xuICAgICAgICB0aGlzLnN0YWNrLnBvcCgpO1xuICAgICAgfVxuICAgIH1cblxuICB9XG5cbn0pKCk7XG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvbWl4aW5zL3Byb3BlcnR5LWVmZmVjdHMuaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCJib290Lmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCJtaXhpbi5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiYXN5bmMuaHRtbFwiPlxuXG48c2NyaXB0PlxuKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLyoqIEB0eXBlZGVmIHt7cnVuOiBmdW5jdGlvbihmdW5jdGlvbigpLCBudW1iZXI9KTpudW1iZXIsIGNhbmNlbDogZnVuY3Rpb24obnVtYmVyKX19ICovXG4gIGxldCBBc3luY01vZHVsZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuXG4gIC8qKlxuICAgKiBAc3VtbWFyeSBDb2xsYXBzZSBtdWx0aXBsZSBjYWxsYmFja3MgaW50byBvbmUgaW52b2NhdGlvbiBhZnRlciBhIHRpbWVyLlxuICAgKiBAbWVtYmVyb2YgUG9seW1lclxuICAgKi9cbiAgY2xhc3MgRGVib3VuY2VyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgIHRoaXMuX2FzeW5jTW9kdWxlID0gbnVsbDtcbiAgICAgIHRoaXMuX2NhbGxiYWNrID0gbnVsbDtcbiAgICAgIHRoaXMuX3RpbWVyID0gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgc2NoZWR1bGVyOyB0aGF0IGlzLCBhIG1vZHVsZSB3aXRoIHRoZSBBc3luYyBpbnRlcmZhY2UsXG4gICAgICogYSBjYWxsYmFjayBhbmQgb3B0aW9uYWwgYXJndW1lbnRzIHRvIGJlIHBhc3NlZCB0byB0aGUgcnVuIGZ1bmN0aW9uXG4gICAgICogZnJvbSB0aGUgYXN5bmMgbW9kdWxlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHshQXN5bmNNb2R1bGV9IGFzeW5jTW9kdWxlIE9iamVjdCB3aXRoIEFzeW5jIGludGVyZmFjZS5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCl9IGNhbGxiYWNrIENhbGxiYWNrIHRvIHJ1bi5cbiAgICAgKi9cbiAgICBzZXRDb25maWcoYXN5bmNNb2R1bGUsIGNhbGxiYWNrKSB7XG4gICAgICB0aGlzLl9hc3luY01vZHVsZSA9IGFzeW5jTW9kdWxlO1xuICAgICAgdGhpcy5fY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgIHRoaXMuX3RpbWVyID0gdGhpcy5fYXN5bmNNb2R1bGUucnVuKCgpID0+IHtcbiAgICAgICAgdGhpcy5fdGltZXIgPSBudWxsO1xuICAgICAgICB0aGlzLl9jYWxsYmFjaygpXG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FuY2VscyBhbiBhY3RpdmUgZGVib3VuY2VyIGFuZCByZXR1cm5zIGEgcmVmZXJlbmNlIHRvIGl0c2VsZi5cbiAgICAgKi9cbiAgICBjYW5jZWwoKSB7XG4gICAgICBpZiAodGhpcy5pc0FjdGl2ZSgpKSB7XG4gICAgICAgIHRoaXMuX2FzeW5jTW9kdWxlLmNhbmNlbCh0aGlzLl90aW1lcik7XG4gICAgICAgIHRoaXMuX3RpbWVyID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRmx1c2hlcyBhbiBhY3RpdmUgZGVib3VuY2VyIGFuZCByZXR1cm5zIGEgcmVmZXJlbmNlIHRvIGl0c2VsZi5cbiAgICAgKi9cbiAgICBmbHVzaCgpIHtcbiAgICAgIGlmICh0aGlzLmlzQWN0aXZlKCkpIHtcbiAgICAgICAgdGhpcy5jYW5jZWwoKTtcbiAgICAgICAgdGhpcy5fY2FsbGJhY2soKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBkZWJvdW5jZXIgaXMgYWN0aXZlLlxuICAgICAqXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBhY3RpdmUuXG4gICAgICovXG4gICAgaXNBY3RpdmUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdGltZXIgIT0gbnVsbDtcbiAgICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgZGVib3VuY2VyIGlmIG5vIGRlYm91bmNlciBpcyBwYXNzZWQgYXMgYSBwYXJhbWV0ZXJcbiAgICogb3IgaXQgY2FuY2VscyBhbiBhY3RpdmUgZGVib3VuY2VyIG90aGVyd2lzZS4gVGhlIGZvbGxvd2luZ1xuICAgKiBleGFtcGxlIHNob3dzIGhvdyBhIGRlYm91bmNlciBjYW4gYmUgY2FsbGVkIG11bHRpcGxlIHRpbWVzIHdpdGhpbiBhXG4gICAqIG1pY3JvdGFzayBhbmQgXCJkZWJvdW5jZWRcIiBzdWNoIHRoYXQgdGhlIHByb3ZpZGVkIGNhbGxiYWNrIGZ1bmN0aW9uIGlzXG4gICAqIGNhbGxlZCBvbmNlLiBBZGQgdGhpcyBtZXRob2QgdG8gYSBjdXN0b20gZWxlbWVudDpcbiAgICpcbiAgICogX2RlYm91bmNlV29yaygpIHtcbiAgICogICB0aGlzLl9kZWJvdW5jZUpvYiA9IFBvbHltZXIuRGVib3VuY2VyLmRlYm91bmNlKHRoaXMuX2RlYm91bmNlSm9iLFxuICAgKiAgICAgICBQb2x5bWVyLkFzeW5jLm1pY3JvVGFzaywgKCkgPT4ge1xuICAgKiAgICAgdGhpcy5fZG9Xb3JrKCk7XG4gICAqICAgfSk7XG4gICAqIH1cbiAgICpcbiAgICogSWYgdGhlIGBfZGVib3VuY2VXb3JrYCBtZXRob2QgaXMgY2FsbGVkIG11bHRpcGxlIHRpbWVzIHdpdGhpbiB0aGUgc2FtZVxuICAgKiBtaWNyb3Rhc2ssIHRoZSBgX2RvV29ya2AgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgb25seSBvbmNlIGF0IHRoZSBuZXh0XG4gICAqIG1pY3JvdGFzayBjaGVja3BvaW50LlxuICAgKlxuICAgKiBOb3RlOiBJbiB0ZXN0aW5nIGl0IGlzIG9mdGVuIGNvbnZlbmllbnQgdG8gYXZvaWQgYXN5bmNocm9ueS4gVG8gYWNjb21wbGlzaFxuICAgKiB0aGlzIHdpdGggYSBkZWJvdW5jZXIsIHlvdSBjYW4gdXNlIGBQb2x5bWVyLmVucXVldWVEZWJvdW5jZXJgIGFuZFxuICAgKiBgUG9seW1lci5mbHVzaGAuIEZvciBleGFtcGxlLCBleHRlbmQgdGhlIGFib3ZlIGV4YW1wbGUgYnkgYWRkaW5nXG4gICAqIGBQb2x5bWVyLmVucXVldWVEZWJvdW5jZXIodGhpcy5fZGVib3VuY2VKb2IpYCBhdCB0aGUgZW5kIG9mIHRoZVxuICAgKiBgX2RlYm91bmNlV29ya2AgbWV0aG9kLiBUaGVuIGluIGEgdGVzdCwgY2FsbCBgUG9seW1lci5mbHVzaGAgdG8gZW5zdXJlXG4gICAqIHRoZSBkZWJvdW5jZXIgaGFzIGNvbXBsZXRlZC5cbiAgICpcbiAgICogQHBhcmFtIHtEZWJvdW5jZXI/fSBkZWJvdW5jZXIgRGVib3VuY2VyIG9iamVjdC5cbiAgICogQHBhcmFtIHshQXN5bmNNb2R1bGV9IGFzeW5jTW9kdWxlIE9iamVjdCB3aXRoIEFzeW5jIGludGVyZmFjZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCl9IGNhbGxiYWNrIENhbGxiYWNrIHRvIHJ1bi5cbiAgICogQHJldHVybiB7IURlYm91bmNlcn0gUmV0dXJucyBhIGRlYm91bmNlciBvYmplY3QuXG4gICAqL1xuICAgIHN0YXRpYyBkZWJvdW5jZShkZWJvdW5jZXIsIGFzeW5jTW9kdWxlLCBjYWxsYmFjaykge1xuICAgICAgaWYgKGRlYm91bmNlciBpbnN0YW5jZW9mIERlYm91bmNlcikge1xuICAgICAgICBkZWJvdW5jZXIuY2FuY2VsKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWJvdW5jZXIgPSBuZXcgRGVib3VuY2VyKCk7XG4gICAgICB9XG4gICAgICBkZWJvdW5jZXIuc2V0Q29uZmlnKGFzeW5jTW9kdWxlLCBjYWxsYmFjayk7XG4gICAgICByZXR1cm4gZGVib3VuY2VyO1xuICAgIH1cbiAgfVxuXG4gIFBvbHltZXIuRGVib3VuY2VyID0gRGVib3VuY2VyO1xufSkoKTtcbjwvc2NyaXB0PlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi91dGlscy9kZWJvdW5jZS5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cImJvb3QuaHRtbFwiPlxuPHNjcmlwdD5cbihmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIGxldCBkZWJvdW5jZXJRdWV1ZSA9IFtdO1xuXG4gIC8qKlxuICAgKiBBZGRzIGEgYFBvbHltZXIuRGVib3VuY2VyYCB0byBhIGxpc3Qgb2YgZ2xvYmFsbHkgZmx1c2hhYmxlIHRhc2tzLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgUG9seW1lclxuICAgKiBAcGFyYW0ge1BvbHltZXIuRGVib3VuY2VyfSBkZWJvdW5jZXIgRGVib3VuY2VyIHRvIGVucXVldWVcbiAgICovXG4gIFBvbHltZXIuZW5xdWV1ZURlYm91bmNlciA9IGZ1bmN0aW9uKGRlYm91bmNlcikge1xuICAgIGRlYm91bmNlclF1ZXVlLnB1c2goZGVib3VuY2VyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZsdXNoRGVib3VuY2VycygpIHtcbiAgICBjb25zdCBkaWRGbHVzaCA9IEJvb2xlYW4oZGVib3VuY2VyUXVldWUubGVuZ3RoKTtcbiAgICB3aGlsZSAoZGVib3VuY2VyUXVldWUubGVuZ3RoKSB7XG4gICAgICB0cnkge1xuICAgICAgICBkZWJvdW5jZXJRdWV1ZS5zaGlmdCgpLmZsdXNoKCk7XG4gICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkaWRGbHVzaDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGb3JjZXMgc2V2ZXJhbCBjbGFzc2VzIG9mIGFzeW5jaHJvbm91c2x5IHF1ZXVlZCB0YXNrcyB0byBmbHVzaDpcbiAgICogLSBEZWJvdW5jZXJzIGFkZGVkIHZpYSBgZW5xdWV1ZURlYm91bmNlcmBcbiAgICogLSBTaGFkeURPTSBkaXN0cmlidXRpb25cbiAgICpcbiAgICogQG1lbWJlcm9mIFBvbHltZXJcbiAgICovXG4gIFBvbHltZXIuZmx1c2ggPSBmdW5jdGlvbigpIHtcbiAgICBsZXQgc2hhZHlET00sIGRlYm91bmNlcnM7XG4gICAgZG8ge1xuICAgICAgc2hhZHlET00gPSB3aW5kb3cuU2hhZHlET00gJiYgU2hhZHlET00uZmx1c2goKTtcbiAgICAgIGlmICh3aW5kb3cuU2hhZHlDU1MgJiYgd2luZG93LlNoYWR5Q1NTLlNjb3BpbmdTaGltKSB7XG4gICAgICAgIHdpbmRvdy5TaGFkeUNTUy5TY29waW5nU2hpbS5mbHVzaCgpO1xuICAgICAgfVxuICAgICAgZGVib3VuY2VycyA9IGZsdXNoRGVib3VuY2VycygpO1xuICAgIH0gd2hpbGUgKHNoYWR5RE9NIHx8IGRlYm91bmNlcnMpO1xuICB9XG5cbn0pKCk7XG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvdXRpbHMvZmx1c2guaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cblxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cImJvb3QuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL21peGlucy9wcm9wZXJ0eS1lZmZlY3RzLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi9taXhpbnMvbXV0YWJsZS1kYXRhLmh0bWxcIj5cblxuPHNjcmlwdD5cbiAgKGZ1bmN0aW9uKCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIC8vIEJhc2UgY2xhc3MgZm9yIEhUTUxUZW1wbGF0ZUVsZW1lbnQgZXh0ZW5zaW9uIHRoYXQgaGFzIHByb3BlcnR5IGVmZmVjdHNcbiAgICAvLyBtYWNoaW5lcnkgZm9yIHByb3BhZ2F0aW5nIGhvc3QgcHJvcGVydGllcyB0byBjaGlsZHJlbi4gVGhpcyBpcyBhbiBFUzVcbiAgICAvLyBjbGFzcyBvbmx5IGJlY2F1c2UgQmFiZWwgKGluY29ycmVjdGx5KSByZXF1aXJlcyBzdXBlcigpIGluIHRoZSBjbGFzc1xuICAgIC8vIGNvbnN0cnVjdG9yIGV2ZW4gdGhvdWdoIG5vIGB0aGlzYCBpcyB1c2VkIGFuZCBpdCByZXR1cm5zIGFuIGluc3RhbmNlLlxuICAgIGxldCBuZXdJbnN0YW5jZSA9IG51bGw7XG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQGV4dGVuZHMge0hUTUxUZW1wbGF0ZUVsZW1lbnR9XG4gICAgICovXG4gICAgZnVuY3Rpb24gSFRNTFRlbXBsYXRlRWxlbWVudEV4dGVuc2lvbigpIHsgcmV0dXJuIG5ld0luc3RhbmNlOyB9XG4gICAgSFRNTFRlbXBsYXRlRWxlbWVudEV4dGVuc2lvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEhUTUxUZW1wbGF0ZUVsZW1lbnQucHJvdG90eXBlLCB7XG4gICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICB2YWx1ZTogSFRNTFRlbXBsYXRlRWxlbWVudEV4dGVuc2lvbixcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAaW1wbGVtZW50cyB7UG9seW1lcl9Qcm9wZXJ0eUVmZmVjdHN9XG4gICAgICogQGV4dGVuZHMge0hUTUxUZW1wbGF0ZUVsZW1lbnRFeHRlbnNpb259XG4gICAgICovXG4gICAgY29uc3QgRGF0YVRlbXBsYXRlID0gUG9seW1lci5Qcm9wZXJ0eUVmZmVjdHMoSFRNTFRlbXBsYXRlRWxlbWVudEV4dGVuc2lvbik7XG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQGltcGxlbWVudHMge1BvbHltZXJfTXV0YWJsZURhdGF9XG4gICAgICogQGV4dGVuZHMge0RhdGFUZW1wbGF0ZX1cbiAgICAgKi9cbiAgICBjb25zdCBNdXRhYmxlRGF0YVRlbXBsYXRlID0gUG9seW1lci5NdXRhYmxlRGF0YShEYXRhVGVtcGxhdGUpO1xuXG4gICAgLy8gQXBwbGllcyBhIERhdGFUZW1wbGF0ZSBzdWJjbGFzcyB0byBhIDx0ZW1wbGF0ZT4gaW5zdGFuY2VcbiAgICBmdW5jdGlvbiB1cGdyYWRlVGVtcGxhdGUodGVtcGxhdGUsIGNvbnN0cnVjdG9yKSB7XG4gICAgICBuZXdJbnN0YW5jZSA9IHRlbXBsYXRlO1xuICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRlbXBsYXRlLCBjb25zdHJ1Y3Rvci5wcm90b3R5cGUpO1xuICAgICAgbmV3IGNvbnN0cnVjdG9yKCk7XG4gICAgICBuZXdJbnN0YW5jZSA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gQmFzZSBjbGFzcyBmb3IgVGVtcGxhdGVJbnN0YW5jZSdzXG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQGltcGxlbWVudHMge1BvbHltZXJfUHJvcGVydHlFZmZlY3RzfVxuICAgICAqL1xuICAgIGNvbnN0IGJhc2UgPSBQb2x5bWVyLlByb3BlcnR5RWZmZWN0cyhjbGFzcyB7fSk7XG5cbiAgICAvKipcbiAgICAgKiBAcG9seW1lclxuICAgICAqIEBjdXN0b21FbGVtZW50XG4gICAgICogQGFwcGxpZXNNaXhpbiBQb2x5bWVyLlByb3BlcnR5RWZmZWN0c1xuICAgICAqIEB1bnJlc3RyaWN0ZWRcbiAgICAgKi9cbiAgICBjbGFzcyBUZW1wbGF0ZUluc3RhbmNlQmFzZSBleHRlbmRzIGJhc2Uge1xuICAgICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5fY29uZmlndXJlUHJvcGVydGllcyhwcm9wcyk7XG4gICAgICAgIHRoaXMucm9vdCA9IHRoaXMuX3N0YW1wVGVtcGxhdGUodGhpcy5fX2RhdGFIb3N0KTtcbiAgICAgICAgLy8gU2F2ZSBsaXN0IG9mIHN0YW1wZWQgY2hpbGRyZW5cbiAgICAgICAgbGV0IGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbiA9IFtdO1xuICAgICAgICBmb3IgKGxldCBuID0gdGhpcy5yb290LmZpcnN0Q2hpbGQ7IG47IG49bi5uZXh0U2libGluZykge1xuICAgICAgICAgIGNoaWxkcmVuLnB1c2gobik7XG4gICAgICAgICAgbi5fX3RlbXBsYXRpemVJbnN0YW5jZSA9IHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX190ZW1wbGF0aXplT3duZXIuX19oaWRlVGVtcGxhdGVDaGlsZHJlbl9fKSB7XG4gICAgICAgICAgdGhpcy5fc2hvd0hpZGVDaGlsZHJlbih0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGbHVzaCBwcm9wcyBvbmx5IHdoZW4gcHJvcHMgYXJlIHBhc3NlZCBpZiBpbnN0YW5jZSBwcm9wcyBleGlzdFxuICAgICAgICAvLyBvciB3aGVuIHRoZXJlIGlzbid0IGluc3RhbmNlIHByb3BzLlxuICAgICAgICBsZXQgb3B0aW9ucyA9IHRoaXMuX190ZW1wbGF0aXplT3B0aW9ucztcbiAgICAgICAgaWYgKChwcm9wcyAmJiBvcHRpb25zLmluc3RhbmNlUHJvcHMpIHx8ICFvcHRpb25zLmluc3RhbmNlUHJvcHMpIHtcbiAgICAgICAgICB0aGlzLl9lbmFibGVQcm9wZXJ0aWVzKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogQ29uZmlndXJlIHRoZSBnaXZlbiBgcHJvcHNgIGJ5IGNhbGxpbmcgYF9zZXRQZW5kaW5nUHJvcGVydHlgLiBBbHNvXG4gICAgICAgKiBzZXRzIGFueSBwcm9wZXJ0aWVzIHN0b3JlZCBpbiBgX19ob3N0UHJvcHNgLlxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBPYmplY3Qgb2YgcHJvcGVydHkgbmFtZS12YWx1ZSBwYWlycyB0byBzZXQuXG4gICAgICAgKi9cbiAgICAgIF9jb25maWd1cmVQcm9wZXJ0aWVzKHByb3BzKSB7XG4gICAgICAgIGxldCBvcHRpb25zID0gdGhpcy5fX3RlbXBsYXRpemVPcHRpb25zO1xuICAgICAgICBpZiAocHJvcHMpIHtcbiAgICAgICAgICBmb3IgKGxldCBpcHJvcCBpbiBvcHRpb25zLmluc3RhbmNlUHJvcHMpIHtcbiAgICAgICAgICAgIGlmIChpcHJvcCBpbiBwcm9wcykge1xuICAgICAgICAgICAgICB0aGlzLl9zZXRQZW5kaW5nUHJvcGVydHkoaXByb3AsIHByb3BzW2lwcm9wXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGhwcm9wIGluIHRoaXMuX19ob3N0UHJvcHMpIHtcbiAgICAgICAgICB0aGlzLl9zZXRQZW5kaW5nUHJvcGVydHkoaHByb3AsIHRoaXMuX19kYXRhSG9zdFsnX2hvc3RfJyArIGhwcm9wXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogRm9yd2FyZHMgYSBob3N0IHByb3BlcnR5IHRvIHRoaXMgaW5zdGFuY2UuICBUaGlzIG1ldGhvZCBzaG91bGQgYmVcbiAgICAgICAqIGNhbGxlZCBvbiBpbnN0YW5jZXMgZnJvbSB0aGUgYG9wdGlvbnMuZm9yd2FyZEhvc3RQcm9wYCBjYWxsYmFja1xuICAgICAgICogdG8gcHJvcGFnYXRlIGNoYW5nZXMgb2YgaG9zdCBwcm9wZXJ0aWVzIHRvIGVhY2ggaW5zdGFuY2UuXG4gICAgICAgKlxuICAgICAgICogTm90ZSB0aGlzIG1ldGhvZCBlbnF1ZXVlcyB0aGUgY2hhbmdlLCB3aGljaCBhcmUgZmx1c2hlZCBhcyBhIGJhdGNoLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wIFByb3BlcnR5IG9yIHBhdGggbmFtZVxuICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSBvZiB0aGUgcHJvcGVydHkgdG8gZm9yd2FyZFxuICAgICAgICovXG4gICAgICBmb3J3YXJkSG9zdFByb3AocHJvcCwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuX3NldFBlbmRpbmdQcm9wZXJ0eU9yUGF0aChwcm9wLCB2YWx1ZSwgZmFsc2UsIHRydWUpKSB7XG4gICAgICAgICAgdGhpcy5fX2RhdGFIb3N0Ll9lbnF1ZXVlQ2xpZW50KHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIEBvdmVycmlkZVxuICAgICAgICovXG4gICAgICBfYWRkRXZlbnRMaXN0ZW5lclRvTm9kZShub2RlLCBldmVudE5hbWUsIGhhbmRsZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuX21ldGhvZEhvc3QgJiYgdGhpcy5fX3RlbXBsYXRpemVPcHRpb25zLnBhcmVudE1vZGVsKSB7XG4gICAgICAgICAgLy8gSWYgdGhpcyBpbnN0YW5jZSBzaG91bGQgYmUgY29uc2lkZXJlZCBhIHBhcmVudCBtb2RlbCwgZGVjb3JhdGVcbiAgICAgICAgICAvLyBldmVudHMgdGhpcyB0ZW1wbGF0ZSBpbnN0YW5jZSBhcyBgbW9kZWxgXG4gICAgICAgICAgdGhpcy5fbWV0aG9kSG9zdC5fYWRkRXZlbnRMaXN0ZW5lclRvTm9kZShub2RlLCBldmVudE5hbWUsIChlKSA9PiB7XG4gICAgICAgICAgICBlLm1vZGVsID0gdGhpcztcbiAgICAgICAgICAgIGhhbmRsZXIoZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gT3RoZXJ3aXNlIGRlbGVnYXRlIHRvIHRoZSB0ZW1wbGF0ZSdzIGhvc3QgKHdoaWNoIGNvdWxkIGJlKVxuICAgICAgICAgIC8vIGFub3RoZXIgdGVtcGxhdGUgaW5zdGFuY2VcbiAgICAgICAgICBsZXQgdGVtcGxhdGVIb3N0ID0gdGhpcy5fX2RhdGFIb3N0Ll9fZGF0YUhvc3Q7XG4gICAgICAgICAgaWYgKHRlbXBsYXRlSG9zdCkge1xuICAgICAgICAgICAgdGVtcGxhdGVIb3N0Ll9hZGRFdmVudExpc3RlbmVyVG9Ob2RlKG5vZGUsIGV2ZW50TmFtZSwgaGFuZGxlcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIFNob3dzIG9yIGhpZGVzIHRoZSB0ZW1wbGF0ZSBpbnN0YW5jZSB0b3AgbGV2ZWwgY2hpbGQgZWxlbWVudHMuIEZvclxuICAgICAgICogdGV4dCBub2RlcywgYHRleHRDb250ZW50YCBpcyByZW1vdmVkIHdoaWxlIFwiaGlkZGVuXCIgYW5kIHJlcGxhY2VkIHdoZW5cbiAgICAgICAqIFwic2hvd24uXCJcbiAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaGlkZSBTZXQgdG8gdHJ1ZSB0byBoaWRlIHRoZSBjaGlsZHJlbjtcbiAgICAgICAqIHNldCB0byBmYWxzZSB0byBzaG93IHRoZW0uXG4gICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgKi9cbiAgICAgIF9zaG93SGlkZUNoaWxkcmVuKGhpZGUpIHtcbiAgICAgICAgbGV0IGMgPSB0aGlzLmNoaWxkcmVuO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8Yy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGxldCBuID0gY1tpXTtcbiAgICAgICAgICAvLyBJZ25vcmUgbm9uLWNoYW5nZXNcbiAgICAgICAgICBpZiAoQm9vbGVhbihoaWRlKSAhPSBCb29sZWFuKG4uX19oaWRlVGVtcGxhdGVDaGlsZHJlbl9fKSkge1xuICAgICAgICAgICAgaWYgKG4ubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFKSB7XG4gICAgICAgICAgICAgIGlmIChoaWRlKSB7XG4gICAgICAgICAgICAgICAgbi5fX3BvbHltZXJUZXh0Q29udGVudF9fID0gbi50ZXh0Q29udGVudDtcbiAgICAgICAgICAgICAgICBuLnRleHRDb250ZW50ID0gJyc7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbi50ZXh0Q29udGVudCA9IG4uX19wb2x5bWVyVGV4dENvbnRlbnRfXztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChuLnN0eWxlKSB7XG4gICAgICAgICAgICAgIGlmIChoaWRlKSB7XG4gICAgICAgICAgICAgICAgbi5fX3BvbHltZXJEaXNwbGF5X18gPSBuLnN0eWxlLmRpc3BsYXk7XG4gICAgICAgICAgICAgICAgbi5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG4uc3R5bGUuZGlzcGxheSA9IG4uX19wb2x5bWVyRGlzcGxheV9fO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIG4uX19oaWRlVGVtcGxhdGVDaGlsZHJlbl9fID0gaGlkZTtcbiAgICAgICAgICBpZiAobi5fc2hvd0hpZGVDaGlsZHJlbikge1xuICAgICAgICAgICAgbi5fc2hvd0hpZGVDaGlsZHJlbihoaWRlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogT3ZlcnJpZGVzIGRlZmF1bHQgcHJvcGVydHktZWZmZWN0cyBpbXBsZW1lbnRhdGlvbiB0byBpbnRlcmNlcHRcbiAgICAgICAqIHRleHRDb250ZW50IGJpbmRpbmdzIHdoaWxlIGNoaWxkcmVuIGFyZSBcImhpZGRlblwiIGFuZCBjYWNoZSBpblxuICAgICAgICogcHJpdmF0ZSBzdG9yYWdlIGZvciBsYXRlciByZXRyaWV2YWwuXG4gICAgICAgKlxuICAgICAgICogQG92ZXJyaWRlXG4gICAgICAgKi9cbiAgICAgIF9zZXRVbm1hbmFnZWRQcm9wZXJ0eVRvTm9kZShub2RlLCBwcm9wLCB2YWx1ZSkge1xuICAgICAgICBpZiAobm9kZS5fX2hpZGVUZW1wbGF0ZUNoaWxkcmVuX18gJiZcbiAgICAgICAgICAgIG5vZGUubm9kZVR5cGUgPT0gTm9kZS5URVhUX05PREUgJiYgcHJvcCA9PSAndGV4dENvbnRlbnQnKSB7XG4gICAgICAgICAgbm9kZS5fX3BvbHltZXJUZXh0Q29udGVudF9fID0gdmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3VwZXIuX3NldFVubWFuYWdlZFByb3BlcnR5VG9Ob2RlKG5vZGUsIHByb3AsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBGaW5kIHRoZSBwYXJlbnQgbW9kZWwgb2YgdGhpcyB0ZW1wbGF0ZSBpbnN0YW5jZS4gIFRoZSBwYXJlbnQgbW9kZWxcbiAgICAgICAqIGlzIGVpdGhlciBhbm90aGVyIHRlbXBsYXRpemUgaW5zdGFuY2UgdGhhdCBoYWQgb3B0aW9uIGBwYXJlbnRNb2RlbDogdHJ1ZWAsXG4gICAgICAgKiBvciBlbHNlIHRoZSBob3N0IGVsZW1lbnQuXG4gICAgICAgKlxuICAgICAgICogQHJldHVybiB7UG9seW1lcl9Qcm9wZXJ0eUVmZmVjdHN9IFRoZSBwYXJlbnQgbW9kZWwgb2YgdGhpcyBpbnN0YW5jZVxuICAgICAgICovXG4gICAgICBnZXQgcGFyZW50TW9kZWwoKSB7XG4gICAgICAgIGxldCBtb2RlbCA9IHRoaXMuX19wYXJlbnRNb2RlbDtcbiAgICAgICAgaWYgKCFtb2RlbCkge1xuICAgICAgICAgIGxldCBvcHRpb25zO1xuICAgICAgICAgIG1vZGVsID0gdGhpc1xuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIC8vIEEgdGVtcGxhdGUgaW5zdGFuY2UncyBgX19kYXRhSG9zdGAgaXMgYSA8dGVtcGxhdGU+XG4gICAgICAgICAgICAvLyBgbW9kZWwuX19kYXRhSG9zdC5fX2RhdGFIb3N0YCBpcyB0aGUgdGVtcGxhdGUncyBob3N0XG4gICAgICAgICAgICBtb2RlbCA9IG1vZGVsLl9fZGF0YUhvc3QuX19kYXRhSG9zdDtcbiAgICAgICAgICB9IHdoaWxlICgob3B0aW9ucyA9IG1vZGVsLl9fdGVtcGxhdGl6ZU9wdGlvbnMpICYmICFvcHRpb25zLnBhcmVudE1vZGVsKVxuICAgICAgICAgIHRoaXMuX19wYXJlbnRNb2RlbCA9IG1vZGVsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtb2RlbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogQHR5cGUgeyFEYXRhVGVtcGxhdGV9ICovXG4gICAgVGVtcGxhdGVJbnN0YW5jZUJhc2UucHJvdG90eXBlLl9fZGF0YUhvc3Q7XG4gICAgLyoqIEB0eXBlIHshVGVtcGxhdGl6ZU9wdGlvbnN9ICovXG4gICAgVGVtcGxhdGVJbnN0YW5jZUJhc2UucHJvdG90eXBlLl9fdGVtcGxhdGl6ZU9wdGlvbnM7XG4gICAgLyoqIEB0eXBlIHshUG9seW1lcl9Qcm9wZXJ0eUVmZmVjdHN9ICovXG4gICAgVGVtcGxhdGVJbnN0YW5jZUJhc2UucHJvdG90eXBlLl9tZXRob2RIb3N0O1xuICAgIC8qKiBAdHlwZSB7IU9iamVjdH0gKi9cbiAgICBUZW1wbGF0ZUluc3RhbmNlQmFzZS5wcm90b3R5cGUuX190ZW1wbGF0aXplT3duZXI7XG4gICAgLyoqIEB0eXBlIHshT2JqZWN0fSAqL1xuICAgIFRlbXBsYXRlSW5zdGFuY2VCYXNlLnByb3RvdHlwZS5fX2hvc3RQcm9wcztcblxuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBleHRlbmRzIHtUZW1wbGF0ZUluc3RhbmNlQmFzZX1cbiAgICAgKiBAaW1wbGVtZW50cyB7UG9seW1lcl9NdXRhYmxlRGF0YX1cbiAgICAgKi9cbiAgICBjb25zdCBNdXRhYmxlVGVtcGxhdGVJbnN0YW5jZUJhc2UgPSBQb2x5bWVyLk11dGFibGVEYXRhKFRlbXBsYXRlSW5zdGFuY2VCYXNlKTtcblxuICAgIGZ1bmN0aW9uIGZpbmRNZXRob2RIb3N0KHRlbXBsYXRlKSB7XG4gICAgICAvLyBUZWNobmljYWxseSB0aGlzIHNob3VsZCBiZSB0aGUgb3duZXIgb2YgdGhlIG91dGVybW9zdCB0ZW1wbGF0ZS5cbiAgICAgIC8vIEluIHNoYWRvdyBkb20sIHRoaXMgaXMgYWx3YXlzIGdldFJvb3ROb2RlKCkuaG9zdCwgYnV0IHdlIGNhblxuICAgICAgLy8gYXBwcm94aW1hdGUgdGhpcyB2aWEgY29vcGVyYXRpb24gd2l0aCBvdXIgZGF0YUhvc3QgYWx3YXlzIHNldHRpbmdcbiAgICAgIC8vIGBfbWV0aG9kSG9zdGAgYXMgbG9uZyBhcyB0aGVyZSB3ZXJlIGJpbmRpbmdzIChvciBpZCdzKSBvbiB0aGlzXG4gICAgICAvLyBpbnN0YW5jZSBjYXVzaW5nIGl0IHRvIGdldCBhIGRhdGFIb3N0LlxuICAgICAgbGV0IHRlbXBsYXRlSG9zdCA9IHRlbXBsYXRlLl9fZGF0YUhvc3Q7XG4gICAgICByZXR1cm4gdGVtcGxhdGVIb3N0ICYmIHRlbXBsYXRlSG9zdC5fbWV0aG9kSG9zdCB8fCB0ZW1wbGF0ZUhvc3Q7XG4gICAgfVxuXG4gICAgLyogZXNsaW50LWRpc2FibGUgdmFsaWQtanNkb2MgKi9cbiAgICAvKipcbiAgICAgKiBAc3VwcHJlc3Mge21pc3NpbmdQcm9wZXJ0aWVzfSBjbGFzcy5wcm90b3R5cGUgaXMgbm90IGRlZmluZWQgZm9yIHNvbWUgcmVhc29uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlVGVtcGxhdGl6ZXJDbGFzcyh0ZW1wbGF0ZSwgdGVtcGxhdGVJbmZvLCBvcHRpb25zKSB7XG4gICAgICAvLyBBbm9ueW1vdXMgY2xhc3MgY3JlYXRlZCBieSB0aGUgdGVtcGxhdGl6ZVxuICAgICAgbGV0IGJhc2UgPSBvcHRpb25zLm11dGFibGVEYXRhID9cbiAgICAgICAgTXV0YWJsZVRlbXBsYXRlSW5zdGFuY2VCYXNlIDogVGVtcGxhdGVJbnN0YW5jZUJhc2U7XG4gICAgICAvKipcbiAgICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAgICogQGV4dGVuZHMge2Jhc2V9XG4gICAgICAgKi9cbiAgICAgIGxldCBrbGFzcyA9IGNsYXNzIGV4dGVuZHMgYmFzZSB7IH1cbiAgICAgIGtsYXNzLnByb3RvdHlwZS5fX3RlbXBsYXRpemVPcHRpb25zID0gb3B0aW9ucztcbiAgICAgIGtsYXNzLnByb3RvdHlwZS5fYmluZFRlbXBsYXRlKHRlbXBsYXRlKTtcbiAgICAgIGFkZE5vdGlmeUVmZmVjdHMoa2xhc3MsIHRlbXBsYXRlLCB0ZW1wbGF0ZUluZm8sIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIGtsYXNzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBzdXBwcmVzcyB7bWlzc2luZ1Byb3BlcnRpZXN9IGNsYXNzLnByb3RvdHlwZSBpcyBub3QgZGVmaW5lZCBmb3Igc29tZSByZWFzb25cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhZGRQcm9wYWdhdGVFZmZlY3RzKHRlbXBsYXRlLCB0ZW1wbGF0ZUluZm8sIG9wdGlvbnMpIHtcbiAgICAgIGxldCB1c2VyRm9yd2FyZEhvc3RQcm9wID0gb3B0aW9ucy5mb3J3YXJkSG9zdFByb3A7XG4gICAgICBpZiAodXNlckZvcndhcmRIb3N0UHJvcCkge1xuICAgICAgICAvLyBQcm92aWRlIGRhdGEgQVBJIGFuZCBwcm9wZXJ0eSBlZmZlY3RzIG9uIG1lbW9pemVkIHRlbXBsYXRlIGNsYXNzXG4gICAgICAgIGxldCBrbGFzcyA9IHRlbXBsYXRlSW5mby50ZW1wbGF0aXplVGVtcGxhdGVDbGFzcztcbiAgICAgICAgaWYgKCFrbGFzcykge1xuICAgICAgICAgIGxldCBiYXNlID0gb3B0aW9ucy5tdXRhYmxlRGF0YSA/IE11dGFibGVEYXRhVGVtcGxhdGUgOiBEYXRhVGVtcGxhdGU7XG4gICAgICAgICAga2xhc3MgPSB0ZW1wbGF0ZUluZm8udGVtcGxhdGl6ZVRlbXBsYXRlQ2xhc3MgPVxuICAgICAgICAgICAgY2xhc3MgVGVtcGxhdGl6ZWRUZW1wbGF0ZSBleHRlbmRzIGJhc2Uge31cbiAgICAgICAgICAvLyBBZGQgdGVtcGxhdGUgLSA+aW5zdGFuY2VzIGVmZmVjdHNcbiAgICAgICAgICAvLyBhbmQgaG9zdCA8LSB0ZW1wbGF0ZSBlZmZlY3RzXG4gICAgICAgICAgbGV0IGhvc3RQcm9wcyA9IHRlbXBsYXRlSW5mby5ob3N0UHJvcHM7XG4gICAgICAgICAgZm9yIChsZXQgcHJvcCBpbiBob3N0UHJvcHMpIHtcbiAgICAgICAgICAgIGtsYXNzLnByb3RvdHlwZS5fYWRkUHJvcGVydHlFZmZlY3QoJ19ob3N0XycgKyBwcm9wLFxuICAgICAgICAgICAgICBrbGFzcy5wcm90b3R5cGUuUFJPUEVSVFlfRUZGRUNUX1RZUEVTLlBST1BBR0FURSxcbiAgICAgICAgICAgICAge2ZuOiBjcmVhdGVGb3J3YXJkSG9zdFByb3BFZmZlY3QocHJvcCwgdXNlckZvcndhcmRIb3N0UHJvcCl9KTtcbiAgICAgICAgICAgIGtsYXNzLnByb3RvdHlwZS5fY3JlYXRlTm90aWZ5aW5nUHJvcGVydHkoJ19ob3N0XycgKyBwcm9wKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdXBncmFkZVRlbXBsYXRlKHRlbXBsYXRlLCBrbGFzcyk7XG4gICAgICAgIC8vIE1peCBhbnkgcHJlLWJvdW5kIGRhdGEgaW50byBfX2RhdGE7IG5vIG5lZWQgdG8gZmx1c2ggdGhpcyB0b1xuICAgICAgICAvLyBpbnN0YW5jZXMgc2luY2UgdGhleSBwdWxsIGZyb20gdGhlIHRlbXBsYXRlIGF0IGluc3RhbmNlLXRpbWVcbiAgICAgICAgaWYgKHRlbXBsYXRlLl9fZGF0YVByb3RvKSB7XG4gICAgICAgICAgLy8gTm90ZSwgZ2VuZXJhbGx5IGBfX2RhdGFQcm90b2AgY291bGQgYmUgY2hhaW5lZCwgYnV0IGl0J3MgZ3VhcmFudGVlZFxuICAgICAgICAgIC8vIHRvIG5vdCBiZSBzaW5jZSB0aGlzIGlzIGEgdmFuaWxsYSB0ZW1wbGF0ZSB3ZSBqdXN0IGFkZGVkIGVmZmVjdHMgdG9cbiAgICAgICAgICBPYmplY3QuYXNzaWduKHRlbXBsYXRlLl9fZGF0YSwgdGVtcGxhdGUuX19kYXRhUHJvdG8pO1xuICAgICAgICB9XG4gICAgICAgIC8vIENsZWFyIGFueSBwZW5kaW5nIGRhdGEgZm9yIHBlcmZvcm1hbmNlXG4gICAgICAgIHRlbXBsYXRlLl9fZGF0YVRlbXAgPSB7fTtcbiAgICAgICAgdGVtcGxhdGUuX19kYXRhUGVuZGluZyA9IG51bGw7XG4gICAgICAgIHRlbXBsYXRlLl9fZGF0YU9sZCA9IG51bGw7XG4gICAgICAgIHRlbXBsYXRlLl9lbmFibGVQcm9wZXJ0aWVzKCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qIGVzbGludC1lbmFibGUgdmFsaWQtanNkb2MgKi9cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUZvcndhcmRIb3N0UHJvcEVmZmVjdChob3N0UHJvcCwgdXNlckZvcndhcmRIb3N0UHJvcCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIGZvcndhcmRIb3N0UHJvcCh0ZW1wbGF0ZSwgcHJvcCwgcHJvcHMpIHtcbiAgICAgICAgdXNlckZvcndhcmRIb3N0UHJvcC5jYWxsKHRlbXBsYXRlLl9fdGVtcGxhdGl6ZU93bmVyLFxuICAgICAgICAgIHByb3Auc3Vic3RyaW5nKCdfaG9zdF8nLmxlbmd0aCksIHByb3BzW3Byb3BdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGROb3RpZnlFZmZlY3RzKGtsYXNzLCB0ZW1wbGF0ZSwgdGVtcGxhdGVJbmZvLCBvcHRpb25zKSB7XG4gICAgICBsZXQgaG9zdFByb3BzID0gdGVtcGxhdGVJbmZvLmhvc3RQcm9wcyB8fCB7fTtcbiAgICAgIGZvciAobGV0IGlwcm9wIGluIG9wdGlvbnMuaW5zdGFuY2VQcm9wcykge1xuICAgICAgICBkZWxldGUgaG9zdFByb3BzW2lwcm9wXTtcbiAgICAgICAgbGV0IHVzZXJOb3RpZnlJbnN0YW5jZVByb3AgPSBvcHRpb25zLm5vdGlmeUluc3RhbmNlUHJvcDtcbiAgICAgICAgaWYgKHVzZXJOb3RpZnlJbnN0YW5jZVByb3ApIHtcbiAgICAgICAgICBrbGFzcy5wcm90b3R5cGUuX2FkZFByb3BlcnR5RWZmZWN0KGlwcm9wLFxuICAgICAgICAgICAga2xhc3MucHJvdG90eXBlLlBST1BFUlRZX0VGRkVDVF9UWVBFUy5OT1RJRlksXG4gICAgICAgICAgICB7Zm46IGNyZWF0ZU5vdGlmeUluc3RhbmNlUHJvcEVmZmVjdChpcHJvcCwgdXNlck5vdGlmeUluc3RhbmNlUHJvcCl9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuZm9yd2FyZEhvc3RQcm9wICYmIHRlbXBsYXRlLl9fZGF0YUhvc3QpIHtcbiAgICAgICAgZm9yIChsZXQgaHByb3AgaW4gaG9zdFByb3BzKSB7XG4gICAgICAgICAga2xhc3MucHJvdG90eXBlLl9hZGRQcm9wZXJ0eUVmZmVjdChocHJvcCxcbiAgICAgICAgICAgIGtsYXNzLnByb3RvdHlwZS5QUk9QRVJUWV9FRkZFQ1RfVFlQRVMuTk9USUZZLFxuICAgICAgICAgICAge2ZuOiBjcmVhdGVOb3RpZnlIb3N0UHJvcEVmZmVjdCgpfSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZU5vdGlmeUluc3RhbmNlUHJvcEVmZmVjdChpbnN0UHJvcCwgdXNlck5vdGlmeUluc3RhbmNlUHJvcCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIG5vdGlmeUluc3RhbmNlUHJvcChpbnN0LCBwcm9wLCBwcm9wcykge1xuICAgICAgICB1c2VyTm90aWZ5SW5zdGFuY2VQcm9wLmNhbGwoaW5zdC5fX3RlbXBsYXRpemVPd25lcixcbiAgICAgICAgICBpbnN0LCBwcm9wLCBwcm9wc1twcm9wXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlTm90aWZ5SG9zdFByb3BFZmZlY3QoKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gbm90aWZ5SG9zdFByb3AoaW5zdCwgcHJvcCwgcHJvcHMpIHtcbiAgICAgICAgaW5zdC5fX2RhdGFIb3N0Ll9zZXRQZW5kaW5nUHJvcGVydHlPclBhdGgoJ19ob3N0XycgKyBwcm9wLCBwcm9wc1twcm9wXSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTW9kdWxlIGZvciBwcmVwYXJpbmcgYW5kIHN0YW1waW5nIGluc3RhbmNlcyBvZiB0ZW1wbGF0ZXMgdGhhdCB1dGlsaXplXG4gICAgICogUG9seW1lcidzIGRhdGEtYmluZGluZyBhbmQgZGVjbGFyYXRpdmUgZXZlbnQgbGlzdGVuZXIgZmVhdHVyZXMuXG4gICAgICpcbiAgICAgKiBFeGFtcGxlOlxuICAgICAqXG4gICAgICogICAgIC8vIEdldCBhIHRlbXBsYXRlIGZyb20gc29tZXdoZXJlLCBlLmcuIGxpZ2h0IERPTVxuICAgICAqICAgICBsZXQgdGVtcGxhdGUgPSB0aGlzLnF1ZXJ5U2VsZWN0b3IoJ3RlbXBsYXRlJyk7XG4gICAgICogICAgIC8vIFByZXBhcmUgdGhlIHRlbXBsYXRlXG4gICAgICogICAgIGxldCBUZW1wbGF0ZUNsYXNzID0gUG9seW1lci5UZW1wbGF0aXplLnRlbXBsYXRpemUodGVtcGxhdGUpO1xuICAgICAqICAgICAvLyBJbnN0YW5jZSB0aGUgdGVtcGxhdGUgd2l0aCBhbiBpbml0aWFsIGRhdGEgbW9kZWxcbiAgICAgKiAgICAgbGV0IGluc3RhbmNlID0gbmV3IFRlbXBsYXRlQ2xhc3Moe215UHJvcDogJ2luaXRpYWwnfSk7XG4gICAgICogICAgIC8vIEluc2VydCB0aGUgaW5zdGFuY2UncyBET00gc29tZXdoZXJlLCBlLmcuIGVsZW1lbnQncyBzaGFkb3cgRE9NXG4gICAgICogICAgIHRoaXMuc2hhZG93Um9vdC5hcHBlbmRDaGlsZChpbnN0YW5jZS5yb290KTtcbiAgICAgKiAgICAgLy8gQ2hhbmdpbmcgYSBwcm9wZXJ0eSBvbiB0aGUgaW5zdGFuY2Ugd2lsbCBwcm9wYWdhdGUgdG8gYmluZGluZ3NcbiAgICAgKiAgICAgLy8gaW4gdGhlIHRlbXBsYXRlXG4gICAgICogICAgIGluc3RhbmNlLm15UHJvcCA9ICduZXcgdmFsdWUnO1xuICAgICAqXG4gICAgICogVGhlIGBvcHRpb25zYCBkaWN0aW9uYXJ5IHBhc3NlZCB0byBgdGVtcGxhdGl6ZWAgYWxsb3dzIGZvciBjdXN0b21pemluZ1xuICAgICAqIGZlYXR1cmVzIG9mIHRoZSBnZW5lcmF0ZWQgdGVtcGxhdGUgY2xhc3MsIGluY2x1ZGluZyBob3cgb3V0ZXItc2NvcGUgaG9zdFxuICAgICAqIHByb3BlcnRpZXMgc2hvdWxkIGJlIGZvcndhcmRlZCBpbnRvIHRlbXBsYXRlIGluc3RhbmNlcywgaG93IGFueSBpbnN0YW5jZVxuICAgICAqIHByb3BlcnRpZXMgYWRkZWQgaW50byB0aGUgdGVtcGxhdGUncyBzY29wZSBzaG91bGQgYmUgbm90aWZpZWQgb3V0IHRvXG4gICAgICogdGhlIGhvc3QsIGFuZCB3aGV0aGVyIHRoZSBpbnN0YW5jZSBzaG91bGQgYmUgZGVjb3JhdGVkIGFzIGEgXCJwYXJlbnQgbW9kZWxcIlxuICAgICAqIG9mIGFueSBldmVudCBoYW5kbGVycy5cbiAgICAgKlxuICAgICAqICAgICAvLyBDdXN0b216ZSBwcm9wZXJ0eSBmb3J3YXJkaW5nIGFuZCBldmVudCBtb2RlbCBkZWNvcmF0aW9uXG4gICAgICogICAgIGxldCBUZW1wbGF0ZUNsYXNzID0gUG9seW1lci5UZW1wbGF0aXplLnRlbXBsYXRpemUodGVtcGxhdGUsIHRoaXMsIHtcbiAgICAgKiAgICAgICBwYXJlbnRNb2RlbDogdHJ1ZSxcbiAgICAgKiAgICAgICBpbnN0YW5jZVByb3BzOiB7Li4ufSxcbiAgICAgKiAgICAgICBmb3J3YXJkSG9zdFByb3AocHJvcGVydHksIHZhbHVlKSB7Li4ufSxcbiAgICAgKiAgICAgICBub3RpZnlJbnN0YW5jZVByb3AoaW5zdGFuY2UsIHByb3BlcnR5LCB2YWx1ZSkgey4uLn0sXG4gICAgICogICAgIH0pO1xuICAgICAqXG4gICAgICpcbiAgICAgKiBAbmFtZXNwYWNlXG4gICAgICogQG1lbWJlcm9mIFBvbHltZXJcbiAgICAgKiBAc3VtbWFyeSBNb2R1bGUgZm9yIHByZXBhcmluZyBhbmQgc3RhbXBpbmcgaW5zdGFuY2VzIG9mIHRlbXBsYXRlc1xuICAgICAqICAgdXRpbGl6aW5nIFBvbHltZXIgdGVtcGxhdGluZyBmZWF0dXJlcy5cbiAgICAgKi9cblxuICAgIGNvbnN0IFRlbXBsYXRpemUgPSB7XG5cbiAgICAgIC8qKlxuICAgICAgICogUmV0dXJucyBhbiBhbm9ueW1vdXMgYFBvbHltZXIuUHJvcGVydHlFZmZlY3RzYCBjbGFzcyBib3VuZCB0byB0aGVcbiAgICAgICAqIGA8dGVtcGxhdGU+YCBwcm92aWRlZC4gIEluc3RhbmNpbmcgdGhlIGNsYXNzIHdpbGwgcmVzdWx0IGluIHRoZVxuICAgICAgICogdGVtcGxhdGUgYmVpbmcgc3RhbXBlZCBpbnRvIGRvY3VtZW50IGZyYWdtZW50IHN0b3JlZCBhcyB0aGUgaW5zdGFuY2Unc1xuICAgICAgICogYHJvb3RgIHByb3BlcnR5LCBhZnRlciB3aGljaCBpdCBjYW4gYmUgYXBwZW5kZWQgdG8gdGhlIERPTS5cbiAgICAgICAqXG4gICAgICAgKiBUZW1wbGF0ZXMgbWF5IHV0aWxpemUgYWxsIFBvbHltZXIgZGF0YS1iaW5kaW5nIGZlYXR1cmVzIGFzIHdlbGwgYXNcbiAgICAgICAqIGRlY2xhcmF0aXZlIGV2ZW50IGxpc3RlbmVycy4gIEV2ZW50IGxpc3RlbmVycyBhbmQgaW5saW5lIGNvbXB1dGluZ1xuICAgICAgICogZnVuY3Rpb25zIGluIHRoZSB0ZW1wbGF0ZSB3aWxsIGJlIGNhbGxlZCBvbiB0aGUgaG9zdCBvZiB0aGUgdGVtcGxhdGUuXG4gICAgICAgKlxuICAgICAgICogVGhlIGNvbnN0cnVjdG9yIHJldHVybmVkIHRha2VzIGEgc2luZ2xlIGFyZ3VtZW50IGRpY3Rpb25hcnkgb2YgaW5pdGlhbFxuICAgICAgICogcHJvcGVydHkgdmFsdWVzIHRvIHByb3BhZ2F0ZSBpbnRvIHRlbXBsYXRlIGJpbmRpbmdzLiAgQWRkaXRpb25hbGx5XG4gICAgICAgKiBob3N0IHByb3BlcnRpZXMgY2FuIGJlIGZvcndhcmRlZCBpbiwgYW5kIGluc3RhbmNlIHByb3BlcnRpZXMgY2FuIGJlXG4gICAgICAgKiBub3RpZmllZCBvdXQgYnkgcHJvdmlkaW5nIG9wdGlvbmFsIGNhbGxiYWNrcyBpbiB0aGUgYG9wdGlvbnNgIGRpY3Rpb25hcnkuXG4gICAgICAgKlxuICAgICAgICogVmFsaWQgY29uZmlndXJhdGlvbiBpbiBgb3B0aW9uc2AgYXJlIGFzIGZvbGxvd3M6XG4gICAgICAgKlxuICAgICAgICogLSBgZm9yd2FyZEhvc3RQcm9wKHByb3BlcnR5LCB2YWx1ZSlgOiBDYWxsZWQgd2hlbiBhIHByb3BlcnR5IHJlZmVyZW5jZWRcbiAgICAgICAqICAgaW4gdGhlIHRlbXBsYXRlIGNoYW5nZWQgb24gdGhlIHRlbXBsYXRlJ3MgaG9zdC4gQXMgdGhpcyBsaWJyYXJ5IGRvZXNcbiAgICAgICAqICAgbm90IHJldGFpbiByZWZlcmVuY2VzIHRvIHRlbXBsYXRlcyBpbnN0YW5jZWQgYnkgdGhlIHVzZXIsIGl0IGlzIHRoZVxuICAgICAgICogICB0ZW1wbGF0aXplIG93bmVyJ3MgcmVzcG9uc2liaWxpdHkgdG8gZm9yd2FyZCBob3N0IHByb3BlcnR5IGNoYW5nZXMgaW50b1xuICAgICAgICogICB1c2VyLXN0YW1wZWQgaW5zdGFuY2VzLiAgVGhlIGBpbnN0YW5jZS5mb3J3YXJkSG9zdFByb3AocHJvcGVydHksIHZhbHVlKWBcbiAgICAgICAqICAgIG1ldGhvZCBvbiB0aGUgZ2VuZXJhdGVkIGNsYXNzIHNob3VsZCBiZSBjYWxsZWQgdG8gZm9yd2FyZCBob3N0XG4gICAgICAgKiAgIHByb3BlcnRpZXMgaW50byB0aGUgdGVtcGxhdGUgdG8gcHJldmVudCB1bm5lY2Vzc2FyeSBwcm9wZXJ0eS1jaGFuZ2VkXG4gICAgICAgKiAgIG5vdGlmaWNhdGlvbnMuIEFueSBwcm9wZXJ0aWVzIHJlZmVyZW5jZWQgaW4gdGhlIHRlbXBsYXRlIHRoYXQgYXJlIG5vdFxuICAgICAgICogICBkZWZpbmVkIGluIGBpbnN0YW5jZVByb3BzYCB3aWxsIGJlIG5vdGlmaWVkIHVwIHRvIHRoZSB0ZW1wbGF0ZSdzIGhvc3RcbiAgICAgICAqICAgYXV0b21hdGljYWxseS5cbiAgICAgICAqIC0gYGluc3RhbmNlUHJvcHNgOiBEaWN0aW9uYXJ5IG9mIHByb3BlcnR5IG5hbWVzIHRoYXQgd2lsbCBiZSBhZGRlZFxuICAgICAgICogICB0byB0aGUgaW5zdGFuY2UgYnkgdGhlIHRlbXBsYXRpemUgb3duZXIuICBUaGVzZSBwcm9wZXJ0aWVzIHNoYWRvdyBhbnlcbiAgICAgICAqICAgaG9zdCBwcm9wZXJ0aWVzLCBhbmQgY2hhbmdlcyB3aXRoaW4gdGhlIHRlbXBsYXRlIHRvIHRoZXNlIHByb3BlcnRpZXNcbiAgICAgICAqICAgd2lsbCByZXN1bHQgaW4gYG5vdGlmeUluc3RhbmNlUHJvcGAgYmVpbmcgY2FsbGVkLlxuICAgICAgICogLSBgbXV0YWJsZURhdGFgOiBXaGVuIGB0cnVlYCwgdGhlIGdlbmVyYXRlZCBjbGFzcyB3aWxsIHNraXAgc3RyaWN0XG4gICAgICAgKiAgIGRpcnR5LWNoZWNraW5nIGZvciBvYmplY3RzIGFuZCBhcnJheXMgKGFsd2F5cyBjb25zaWRlciB0aGVtIHRvIGJlXG4gICAgICAgKiAgIFwiZGlydHlcIikuXG4gICAgICAgKiAtIGBub3RpZnlJbnN0YW5jZVByb3AoaW5zdGFuY2UsIHByb3BlcnR5LCB2YWx1ZSlgOiBDYWxsZWQgd2hlblxuICAgICAgICogICBhbiBpbnN0YW5jZSBwcm9wZXJ0eSBjaGFuZ2VzLiAgVXNlcnMgbWF5IGNob29zZSB0byBjYWxsIGBub3RpZnlQYXRoYFxuICAgICAgICogICBvbiBlLmcuIHRoZSBvd25lciB0byBub3RpZnkgdGhlIGNoYW5nZS5cbiAgICAgICAqIC0gYHBhcmVudE1vZGVsYDogV2hlbiBgdHJ1ZWAsIGV2ZW50cyBoYW5kbGVkIGJ5IGRlY2xhcmF0aXZlIGV2ZW50IGxpc3RlbmVyc1xuICAgICAgICogICAoYG9uLWV2ZW50PVwiaGFuZGxlclwiYCkgd2lsbCBiZSBkZWNvcmF0ZWQgd2l0aCBhIGBtb2RlbGAgcHJvcGVydHkgcG9pbnRpbmdcbiAgICAgICAqICAgdG8gdGhlIHRlbXBsYXRlIGluc3RhbmNlIHRoYXQgc3RhbXBlZCBpdC4gIEl0IHdpbGwgYWxzbyBiZSByZXR1cm5lZFxuICAgICAgICogICBmcm9tIGBpbnN0YW5jZS5wYXJlbnRNb2RlbGAgaW4gY2FzZXMgd2hlcmUgdGVtcGxhdGUgaW5zdGFuY2UgbmVzdGluZ1xuICAgICAgICogICBjYXVzZXMgYW4gaW5uZXIgbW9kZWwgdG8gc2hhZG93IGFuIG91dGVyIG1vZGVsLlxuICAgICAgICpcbiAgICAgICAqIE5vdGUgdGhhdCB0aGUgY2xhc3MgcmV0dXJuZWQgZnJvbSBgdGVtcGxhdGl6ZWAgaXMgZ2VuZXJhdGVkIG9ubHkgb25jZVxuICAgICAgICogZm9yIGEgZ2l2ZW4gYDx0ZW1wbGF0ZT5gIHVzaW5nIGBvcHRpb25zYCBmcm9tIHRoZSBmaXJzdCBjYWxsIGZvciB0aGF0XG4gICAgICAgKiB0ZW1wbGF0ZSwgYW5kIHRoZSBjYWNoZWQgY2xhc3MgaXMgcmV0dXJuZWQgZm9yIGFsbCBzdWJzZXF1ZW50IGNhbGxzIHRvXG4gICAgICAgKiBgdGVtcGxhdGl6ZWAgZm9yIHRoYXQgdGVtcGxhdGUuICBBcyBzdWNoLCBgb3B0aW9uc2AgY2FsbGJhY2tzIHNob3VsZCBub3RcbiAgICAgICAqIGNsb3NlIG92ZXIgb3duZXItc3BlY2lmaWMgcHJvcGVydGllcyBzaW5jZSBvbmx5IHRoZSBmaXJzdCBgb3B0aW9uc2AgaXNcbiAgICAgICAqIHVzZWQ7IHJhdGhlciwgY2FsbGJhY2tzIGFyZSBjYWxsZWQgYm91bmQgdG8gdGhlIGBvd25lcmAsIGFuZCBzbyBjb250ZXh0XG4gICAgICAgKiBuZWVkZWQgZnJvbSB0aGUgY2FsbGJhY2tzIChzdWNoIGFzIHJlZmVyZW5jZXMgdG8gYGluc3RhbmNlc2Agc3RhbXBlZClcbiAgICAgICAqIHNob3VsZCBiZSBzdG9yZWQgb24gdGhlIGBvd25lcmAgc3VjaCB0aGF0IHRoZXkgY2FuIGJlIHJldHJpZXZlZCB2aWEgYHRoaXNgLlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJvZiBQb2x5bWVyLlRlbXBsYXRpemVcbiAgICAgICAqIEBwYXJhbSB7IUhUTUxUZW1wbGF0ZUVsZW1lbnR9IHRlbXBsYXRlIFRlbXBsYXRlIHRvIHRlbXBsYXRpemVcbiAgICAgICAqIEBwYXJhbSB7IVBvbHltZXJfUHJvcGVydHlFZmZlY3RzfSBvd25lciBPd25lciBvZiB0aGUgdGVtcGxhdGUgaW5zdGFuY2VzO1xuICAgICAgICogICBhbnkgb3B0aW9uYWwgY2FsbGJhY2tzIHdpbGwgYmUgYm91bmQgdG8gdGhpcyBvd25lci5cbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9ucyBPcHRpb25zIGRpY3Rpb25hcnkgKHNlZSBzdW1tYXJ5IGZvciBkZXRhaWxzKVxuICAgICAgICogQHJldHVybiB7ZnVuY3Rpb24obmV3OlRlbXBsYXRlSW5zdGFuY2VCYXNlKX0gR2VuZXJhdGVkIGNsYXNzIGJvdW5kIHRvIHRoZSB0ZW1wbGF0ZVxuICAgICAgICogICBwcm92aWRlZFxuICAgICAgICogQHN1cHByZXNzIHtpbnZhbGlkQ2FzdHN9XG4gICAgICAgKi9cbiAgICAgIHRlbXBsYXRpemUodGVtcGxhdGUsIG93bmVyLCBvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSAvKiogQHR5cGUgeyFUZW1wbGF0aXplT3B0aW9uc30gKi8ob3B0aW9ucyB8fCB7fSk7XG4gICAgICAgIGlmICh0ZW1wbGF0ZS5fX3RlbXBsYXRpemVPd25lcikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQSA8dGVtcGxhdGU+IGNhbiBvbmx5IGJlIHRlbXBsYXRpemVkIG9uY2UnKTtcbiAgICAgICAgfVxuICAgICAgICB0ZW1wbGF0ZS5fX3RlbXBsYXRpemVPd25lciA9IG93bmVyO1xuICAgICAgICBsZXQgdGVtcGxhdGVJbmZvID0gb3duZXIuY29uc3RydWN0b3IuX3BhcnNlVGVtcGxhdGUodGVtcGxhdGUpO1xuICAgICAgICAvLyBHZXQgbWVtb2l6ZWQgYmFzZSBjbGFzcyBmb3IgdGhlIHByb3RvdHlwaWNhbCB0ZW1wbGF0ZSwgd2hpY2hcbiAgICAgICAgLy8gaW5jbHVkZXMgcHJvcGVydHkgZWZmZWN0cyBmb3IgYmluZGluZyB0ZW1wbGF0ZSAmIGZvcndhcmRpbmdcbiAgICAgICAgbGV0IGJhc2VDbGFzcyA9IHRlbXBsYXRlSW5mby50ZW1wbGF0aXplSW5zdGFuY2VDbGFzcztcbiAgICAgICAgaWYgKCFiYXNlQ2xhc3MpIHtcbiAgICAgICAgICBiYXNlQ2xhc3MgPSBjcmVhdGVUZW1wbGF0aXplckNsYXNzKHRlbXBsYXRlLCB0ZW1wbGF0ZUluZm8sIG9wdGlvbnMpO1xuICAgICAgICAgIHRlbXBsYXRlSW5mby50ZW1wbGF0aXplSW5zdGFuY2VDbGFzcyA9IGJhc2VDbGFzcztcbiAgICAgICAgfVxuICAgICAgICAvLyBIb3N0IHByb3BlcnR5IGZvcndhcmRpbmcgbXVzdCBiZSBpbnN0YWxsZWQgb250byB0ZW1wbGF0ZSBpbnN0YW5jZVxuICAgICAgICBhZGRQcm9wYWdhdGVFZmZlY3RzKHRlbXBsYXRlLCB0ZW1wbGF0ZUluZm8sIG9wdGlvbnMpO1xuICAgICAgICAvLyBTdWJjbGFzcyBiYXNlIGNsYXNzIGFuZCBhZGQgcmVmZXJlbmNlIGZvciB0aGlzIHNwZWNpZmljIHRlbXBsYXRlXG4gICAgICAgIGxldCBrbGFzcyA9IGNsYXNzIFRlbXBsYXRlSW5zdGFuY2UgZXh0ZW5kcyBiYXNlQ2xhc3Mge307XG4gICAgICAgIGtsYXNzLnByb3RvdHlwZS5fbWV0aG9kSG9zdCA9IGZpbmRNZXRob2RIb3N0KHRlbXBsYXRlKTtcbiAgICAgICAga2xhc3MucHJvdG90eXBlLl9fZGF0YUhvc3QgPSB0ZW1wbGF0ZTtcbiAgICAgICAga2xhc3MucHJvdG90eXBlLl9fdGVtcGxhdGl6ZU93bmVyID0gb3duZXI7XG4gICAgICAgIGtsYXNzLnByb3RvdHlwZS5fX2hvc3RQcm9wcyA9IHRlbXBsYXRlSW5mby5ob3N0UHJvcHM7XG4gICAgICAgIHJldHVybiAvKiogQHR5cGUge2Z1bmN0aW9uKG5ldzpUZW1wbGF0ZUluc3RhbmNlQmFzZSl9ICovKGtsYXNzKTtcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogUmV0dXJucyB0aGUgdGVtcGxhdGUgXCJtb2RlbFwiIGFzc29jaWF0ZWQgd2l0aCBhIGdpdmVuIGVsZW1lbnQsIHdoaWNoXG4gICAgICAgKiBzZXJ2ZXMgYXMgdGhlIGJpbmRpbmcgc2NvcGUgZm9yIHRoZSB0ZW1wbGF0ZSBpbnN0YW5jZSB0aGUgZWxlbWVudCBpc1xuICAgICAgICogY29udGFpbmVkIGluLiBBIHRlbXBsYXRlIG1vZGVsIGlzIGFuIGluc3RhbmNlIG9mXG4gICAgICAgKiBgVGVtcGxhdGVJbnN0YW5jZUJhc2VgLCBhbmQgc2hvdWxkIGJlIHVzZWQgdG8gbWFuaXB1bGF0ZSBkYXRhXG4gICAgICAgKiBhc3NvY2lhdGVkIHdpdGggdGhpcyB0ZW1wbGF0ZSBpbnN0YW5jZS5cbiAgICAgICAqXG4gICAgICAgKiBFeGFtcGxlOlxuICAgICAgICpcbiAgICAgICAqICAgbGV0IG1vZGVsID0gbW9kZWxGb3JFbGVtZW50KGVsKTtcbiAgICAgICAqICAgaWYgKG1vZGVsLmluZGV4IDwgMTApIHtcbiAgICAgICAqICAgICBtb2RlbC5zZXQoJ2l0ZW0uY2hlY2tlZCcsIHRydWUpO1xuICAgICAgICogICB9XG4gICAgICAgKlxuICAgICAgICogQG1lbWJlcm9mIFBvbHltZXIuVGVtcGxhdGl6ZVxuICAgICAgICogQHBhcmFtIHtIVE1MVGVtcGxhdGVFbGVtZW50fSB0ZW1wbGF0ZSBUaGUgbW9kZWwgd2lsbCBiZSByZXR1cm5lZCBmb3JcbiAgICAgICAqICAgZWxlbWVudHMgc3RhbXBlZCBmcm9tIHRoaXMgdGVtcGxhdGVcbiAgICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBOb2RlIGZvciB3aGljaCB0byByZXR1cm4gYSB0ZW1wbGF0ZSBtb2RlbC5cbiAgICAgICAqIEByZXR1cm4ge1RlbXBsYXRlSW5zdGFuY2VCYXNlfSBUZW1wbGF0ZSBpbnN0YW5jZSByZXByZXNlbnRpbmcgdGhlXG4gICAgICAgKiAgIGJpbmRpbmcgc2NvcGUgZm9yIHRoZSBlbGVtZW50XG4gICAgICAgKi9cbiAgICAgIG1vZGVsRm9yRWxlbWVudCh0ZW1wbGF0ZSwgbm9kZSkge1xuICAgICAgICBsZXQgbW9kZWw7XG4gICAgICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgICAgLy8gQW4gZWxlbWVudCB3aXRoIGEgX190ZW1wbGF0aXplSW5zdGFuY2UgbWFya3MgdGhlIHRvcCBib3VuZGFyeVxuICAgICAgICAgIC8vIG9mIGEgc2NvcGU7IHdhbGsgdXAgdW50aWwgd2UgZmluZCBvbmUsIGFuZCB0aGVuIGVuc3VyZSB0aGF0XG4gICAgICAgICAgLy8gaXRzIF9fZGF0YUhvc3QgbWF0Y2hlcyBgdGhpc2AsIG1lYW5pbmcgdGhpcyBkb20tcmVwZWF0IHN0YW1wZWQgaXRcbiAgICAgICAgICBpZiAoKG1vZGVsID0gbm9kZS5fX3RlbXBsYXRpemVJbnN0YW5jZSkpIHtcbiAgICAgICAgICAgIC8vIEZvdW5kIGFuIGVsZW1lbnQgc3RhbXBlZCBieSBhbm90aGVyIHRlbXBsYXRlOyBrZWVwIHdhbGtpbmcgdXBcbiAgICAgICAgICAgIC8vIGZyb20gaXRzIF9fZGF0YUhvc3RcbiAgICAgICAgICAgIGlmIChtb2RlbC5fX2RhdGFIb3N0ICE9IHRlbXBsYXRlKSB7XG4gICAgICAgICAgICAgIG5vZGUgPSBtb2RlbC5fX2RhdGFIb3N0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG1vZGVsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBTdGlsbCBpbiBhIHRlbXBsYXRlIHNjb3BlLCBrZWVwIGdvaW5nIHVwIHVudGlsXG4gICAgICAgICAgICAvLyBhIF9fdGVtcGxhdGl6ZUluc3RhbmNlIGlzIGZvdW5kXG4gICAgICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBQb2x5bWVyLlRlbXBsYXRpemUgPSBUZW1wbGF0aXplO1xuICAgIFBvbHltZXIuVGVtcGxhdGVJbnN0YW5jZUJhc2UgPSBUZW1wbGF0ZUluc3RhbmNlQmFzZTtcblxuICB9KSgpO1xuXG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvdXRpbHMvdGVtcGxhdGl6ZS5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNiBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuXG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vLi4vcG9seW1lci9wb2x5bWVyLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi8uLi9pcm9uLXJlc2l6YWJsZS1iZWhhdmlvci9pcm9uLXJlc2l6YWJsZS1iZWhhdmlvci5odG1sXCI+XG5cbjxzY3JpcHQ+XG5cbiAgLyoqXG4gICAqIEBwb2x5bWVyQmVoYXZpb3IgUG9seW1lci5BcHBMYXlvdXRCZWhhdmlvclxuICAgKiovXG4gIFBvbHltZXIuQXBwTGF5b3V0QmVoYXZpb3IgPSBbXG4gICAgUG9seW1lci5Jcm9uUmVzaXphYmxlQmVoYXZpb3IsIHtcblxuICAgIGxpc3RlbmVyczoge1xuICAgICAgJ2FwcC1yZXNldC1sYXlvdXQnOiAnX2FwcFJlc2V0TGF5b3V0SGFuZGxlcicsXG4gICAgICAnaXJvbi1yZXNpemUnOiAncmVzZXRMYXlvdXQnXG4gICAgfSxcblxuICAgIGF0dGFjaGVkOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZmlyZSgnYXBwLXJlc2V0LWxheW91dCcpO1xuICAgIH0sXG5cbiAgICBfYXBwUmVzZXRMYXlvdXRIYW5kbGVyOiBmdW5jdGlvbihlKSB7XG4gICAgICBpZiAoUG9seW1lci5kb20oZSkucGF0aFswXSA9PT0gdGhpcykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLnJlc2V0TGF5b3V0KCk7XG4gICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH0sXG5cbiAgICBfdXBkYXRlTGF5b3V0U3RhdGVzOiBmdW5jdGlvbigpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ3VuaW1wbGVtZW50ZWQnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVzZXRzIHRoZSBsYXlvdXQuIElmIHlvdSBjaGFuZ2VkIHRoZSBzaXplIG9mIHRoaXMgZWxlbWVudCB2aWEgQ1NTXG4gICAgICogeW91IGNhbiBub3RpZnkgdGhlIGNoYW5nZXMgYnkgZWl0aGVyIGZpcmluZyB0aGUgYGlyb24tcmVzaXplYCBldmVudFxuICAgICAqIG9yIGNhbGxpbmcgYHJlc2V0TGF5b3V0YCBkaXJlY3RseS5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgcmVzZXRMYXlvdXRcbiAgICAgKi9cbiAgICByZXNldExheW91dDogZnVuY3Rpb24oKSB7XG4gICAgICAvLyBQb2x5bWVyIHYyLnhcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBjYiA9IHRoaXMuX3VwZGF0ZUxheW91dFN0YXRlcy5iaW5kKHRoaXMpO1xuICAgICAgaWYgKFBvbHltZXIuQXN5bmMgJiYgUG9seW1lci5Bc3luYy5hbmltYXRpb25GcmFtZSkge1xuICAgICAgICB0aGlzLl9sYXlvdXREZWJvdW5jZXIgPSBQb2x5bWVyLkRlYm91bmNlci5kZWJvdW5jZShcbiAgICAgICAgICAgIHRoaXMuX2xheW91dERlYm91bmNlcixcbiAgICAgICAgICAgIFBvbHltZXIuQXN5bmMuYW5pbWF0aW9uRnJhbWUsXG4gICAgICAgICAgICBjYik7XG4gICAgICAgIFBvbHltZXIuZW5xdWV1ZURlYm91bmNlcih0aGlzLl9sYXlvdXREZWJvdW5jZXIpO1xuICAgICAgfVxuICAgICAgLy8gUG9seW1lciB2MS54XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5kZWJvdW5jZSgncmVzZXRMYXlvdXQnLCBjYik7XG4gICAgICB9XG4gICAgICB0aGlzLl9ub3RpZnlEZXNjZW5kYW50UmVzaXplKCk7XG4gICAgfSxcblxuICAgIF9ub3RpZnlMYXlvdXRDaGFuZ2VkOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIC8vIFRPRE86IHRoZSBldmVudCBgYXBwLXJlc2V0LWxheW91dGAgY2FuIGJlIGZpcmVkIHN5bmNocm9ub3VzbHlcbiAgICAgIC8vIGFzIGxvbmcgYXMgYF91cGRhdGVMYXlvdXRTdGF0ZXNgIHdhaXRzIGZvciBhbGwgdGhlIG1pY3JvdGFza3MgYWZ0ZXIgckFGLlxuICAgICAgLy8gRS5nLiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoc2V0VGltZU91dCgpKVxuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCkge1xuICAgICAgICBzZWxmLmZpcmUoJ2FwcC1yZXNldC1sYXlvdXQnKTtcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBfbm90aWZ5RGVzY2VuZGFudFJlc2l6ZTogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXRoaXMuaXNBdHRhY2hlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl9pbnRlcmVzdGVkUmVzaXphYmxlcy5mb3JFYWNoKGZ1bmN0aW9uKHJlc2l6YWJsZSkge1xuICAgICAgICBpZiAodGhpcy5yZXNpemVyU2hvdWxkTm90aWZ5KHJlc2l6YWJsZSkpIHtcbiAgICAgICAgICB0aGlzLl9ub3RpZnlEZXNjZW5kYW50KHJlc2l6YWJsZSk7XG4gICAgICAgIH1cbiAgICAgIH0sIHRoaXMpO1xuICAgIH1cbiAgfV07XG5cbjwvc2NyaXB0PlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9hcHAtbGF5b3V0L2FwcC1sYXlvdXQtYmVoYXZpb3IvYXBwLWxheW91dC1iZWhhdmlvci5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuXG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vdXRpbHMvYm9vdC5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vdXRpbHMvc2V0dGluZ3MuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3V0aWxzL21peGluLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi91dGlscy9jYXNlLW1hcC5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vdXRpbHMvc3R5bGUtZ2F0aGVyLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi91dGlscy9yZXNvbHZlLXVybC5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vZWxlbWVudHMvZG9tLW1vZHVsZS5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwicHJvcGVydHktZWZmZWN0cy5odG1sXCI+XG5cbjxzY3JpcHQ+XG4oZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvKipcbiAgICogRWxlbWVudCBjbGFzcyBtaXhpbiB0aGF0IHByb3ZpZGVzIHRoZSBjb3JlIEFQSSBmb3IgUG9seW1lcidzIG1ldGEtcHJvZ3JhbW1pbmdcbiAgICogZmVhdHVyZXMgaW5jbHVkaW5nIHRlbXBsYXRlIHN0YW1waW5nLCBkYXRhLWJpbmRpbmcsIGF0dHJpYnV0ZSBkZXNlcmlhbGl6YXRpb24sXG4gICAqIGFuZCBwcm9wZXJ0eSBjaGFuZ2Ugb2JzZXJ2YXRpb24uXG4gICAqXG4gICAqIFN1YmNsYXNzZXJzIG1heSBwcm92aWRlIHRoZSBmb2xsb3dpbmcgc3RhdGljIGdldHRlcnMgdG8gcmV0dXJuIG1ldGFkYXRhXG4gICAqIHVzZWQgdG8gY29uZmlndXJlIFBvbHltZXIncyBmZWF0dXJlcyBmb3IgdGhlIGNsYXNzOlxuICAgKlxuICAgKiAtIGBzdGF0aWMgZ2V0IGlzKClgOiBXaGVuIHRoZSB0ZW1wbGF0ZSBpcyBwcm92aWRlZCB2aWEgYSBgZG9tLW1vZHVsZWAsXG4gICAqICAgdXNlcnMgc2hvdWxkIHJldHVybiB0aGUgYGRvbS1tb2R1bGVgIGlkIGZyb20gYSBzdGF0aWMgYGlzYCBnZXR0ZXIuICBJZlxuICAgKiAgIG5vIHRlbXBsYXRlIGlzIG5lZWRlZCBvciB0aGUgdGVtcGxhdGUgaXMgcHJvdmlkZWQgZGlyZWN0bHkgdmlhIHRoZVxuICAgKiAgIGB0ZW1wbGF0ZWAgZ2V0dGVyLCB0aGVyZSBpcyBubyBuZWVkIHRvIGRlZmluZSBgaXNgIGZvciB0aGUgZWxlbWVudC5cbiAgICpcbiAgICogLSBgc3RhdGljIGdldCB0ZW1wbGF0ZSgpYDogVXNlcnMgbWF5IHByb3ZpZGUgdGhlIHRlbXBsYXRlIGRpcmVjdGx5IChhc1xuICAgKiAgIG9wcG9zZWQgdG8gdmlhIGBkb20tbW9kdWxlYCkgYnkgaW1wbGVtZW50aW5nIGEgc3RhdGljIGB0ZW1wbGF0ZWAgZ2V0dGVyLlxuICAgKiAgIFRoZSBnZXR0ZXIgbWF5IHJldHVybiBhbiBgSFRNTFRlbXBsYXRlRWxlbWVudGAgb3IgYSBzdHJpbmcsIHdoaWNoIHdpbGxcbiAgICogICBhdXRvbWF0aWNhbGx5IGJlIHBhcnNlZCBpbnRvIGEgdGVtcGxhdGUuXG4gICAqXG4gICAqIC0gYHN0YXRpYyBnZXQgcHJvcGVydGllcygpYDogU2hvdWxkIHJldHVybiBhbiBvYmplY3QgZGVzY3JpYmluZ1xuICAgKiAgIHByb3BlcnR5LXJlbGF0ZWQgbWV0YWRhdGEgdXNlZCBieSBQb2x5bWVyIGZlYXR1cmVzIChrZXk6IHByb3BlcnR5IG5hbWVcbiAgICogICB2YWx1ZTogb2JqZWN0IGNvbnRhaW5pbmcgcHJvcGVydHkgbWV0YWRhdGEpLiBWYWxpZCBrZXlzIGluIHBlci1wcm9wZXJ0eVxuICAgKiAgIG1ldGFkYXRhIGluY2x1ZGU6XG4gICAqICAgLSBgdHlwZWAgKFN0cmluZ3xOdW1iZXJ8T2JqZWN0fEFycmF5fC4uLik6IFVzZWQgYnlcbiAgICogICAgIGBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2tgIHRvIGRldGVybWluZSBob3cgc3RyaW5nLWJhc2VkIGF0dHJpYnV0ZXNcbiAgICogICAgIGFyZSBkZXNlcmlhbGl6ZWQgdG8gSmF2YVNjcmlwdCBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAqICAgLSBgbm90aWZ5YCAoYm9vbGVhbik6IENhdXNlcyBhIGNoYW5nZSBpbiB0aGUgcHJvcGVydHkgdG8gZmlyZSBhXG4gICAqICAgICBub24tYnViYmxpbmcgZXZlbnQgY2FsbGVkIGA8cHJvcGVydHk+LWNoYW5nZWRgLiBFbGVtZW50cyB0aGF0IGhhdmVcbiAgICogICAgIGVuYWJsZWQgdHdvLXdheSBiaW5kaW5nIHRvIHRoZSBwcm9wZXJ0eSB1c2UgdGhpcyBldmVudCB0byBvYnNlcnZlIGNoYW5nZXMuXG4gICAqICAgLSBgcmVhZE9ubHlgIChib29sZWFuKTogQ3JlYXRlcyBhIGdldHRlciBmb3IgdGhlIHByb3BlcnR5LCBidXQgbm8gc2V0dGVyLlxuICAgKiAgICAgVG8gc2V0IGEgcmVhZC1vbmx5IHByb3BlcnR5LCB1c2UgdGhlIHByaXZhdGUgc2V0dGVyIG1ldGhvZFxuICAgKiAgICAgYF9zZXRQcm9wZXJ0eShwcm9wZXJ0eSwgdmFsdWUpYC5cbiAgICogICAtIGBvYnNlcnZlcmAgKHN0cmluZyk6IE9ic2VydmVyIG1ldGhvZCBuYW1lIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2hlblxuICAgKiAgICAgdGhlIHByb3BlcnR5IGNoYW5nZXMuIFRoZSBhcmd1bWVudHMgb2YgdGhlIG1ldGhvZCBhcmVcbiAgICogICAgIGAodmFsdWUsIHByZXZpb3VzVmFsdWUpYC5cbiAgICogICAtIGBjb21wdXRlZGAgKHN0cmluZyk6IFN0cmluZyBkZXNjcmliaW5nIG1ldGhvZCBhbmQgZGVwZW5kZW50IHByb3BlcnRpZXNcbiAgICogICAgIGZvciBjb21wdXRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgcHJvcGVydHkgKGUuZy4gYCdjb21wdXRlRm9vKGJhciwgem90KSdgKS5cbiAgICogICAgIENvbXB1dGVkIHByb3BlcnRpZXMgYXJlIHJlYWQtb25seSBieSBkZWZhdWx0IGFuZCBjYW4gb25seSBiZSBjaGFuZ2VkXG4gICAqICAgICB2aWEgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgY29tcHV0aW5nIG1ldGhvZC5cbiAgICpcbiAgICogLSBgc3RhdGljIGdldCBvYnNlcnZlcnMoKWA6IEFycmF5IG9mIHN0cmluZ3MgZGVzY3JpYmluZyBtdWx0aS1wcm9wZXJ0eVxuICAgKiAgIG9ic2VydmVyIG1ldGhvZHMgYW5kIHRoZWlyIGRlcGVuZGVudCBwcm9wZXJ0aWVzIChlLmcuXG4gICAqICAgYCdvYnNlcnZlQUJDKGEsIGIsIGMpJ2ApLlxuICAgKlxuICAgKiBUaGUgYmFzZSBjbGFzcyBwcm92aWRlcyBkZWZhdWx0IGltcGxlbWVudGF0aW9ucyBmb3IgdGhlIGZvbGxvd2luZyBzdGFuZGFyZFxuICAgKiBjdXN0b20gZWxlbWVudCBsaWZlY3ljbGUgY2FsbGJhY2tzOyB1c2VycyBtYXkgb3ZlcnJpZGUgdGhlc2UsIGJ1dCBzaG91bGRcbiAgICogY2FsbCB0aGUgc3VwZXIgbWV0aG9kIHRvIGVuc3VyZVxuICAgKiAtIGBjb25zdHJ1Y3RvcmA6IFJ1biB3aGVuIHRoZSBlbGVtZW50IGlzIGNyZWF0ZWQgb3IgdXBncmFkZWRcbiAgICogLSBgY29ubmVjdGVkQ2FsbGJhY2tgOiBSdW4gZWFjaCB0aW1lIHRoZSBlbGVtZW50IGlzIGNvbm5lY3RlZCB0byB0aGVcbiAgICogICBkb2N1bWVudFxuICAgKiAtIGBkaXNjb25uZWN0ZWRDYWxsYmFja2A6IFJ1biBlYWNoIHRpbWUgdGhlIGVsZW1lbnQgaXMgZGlzY29ubmVjdGVkIGZyb21cbiAgICogICB0aGUgZG9jdW1lbnRcbiAgICogLSBgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrYDogUnVuIGVhY2ggdGltZSBhbiBhdHRyaWJ1dGUgaW5cbiAgICogICBgb2JzZXJ2ZWRBdHRyaWJ1dGVzYCBpcyBzZXQgb3IgcmVtb3ZlZCAobm90ZTogdGhpcyBlbGVtZW50J3MgZGVmYXVsdFxuICAgKiAgIGBvYnNlcnZlZEF0dHJpYnV0ZXNgIGltcGxlbWVudGF0aW9uIHdpbGwgYXV0b21hdGljYWxseSByZXR1cm4gYW4gYXJyYXlcbiAgICogICBvZiBkYXNoLWNhc2VkIGF0dHJpYnV0ZXMgYmFzZWQgb24gYHByb3BlcnRpZXNgKVxuICAgKlxuICAgKiBAbWl4aW5GdW5jdGlvblxuICAgKiBAcG9seW1lclxuICAgKiBAYXBwbGllc01peGluIFBvbHltZXIuUHJvcGVydHlFZmZlY3RzXG4gICAqIEBtZW1iZXJvZiBQb2x5bWVyXG4gICAqIEBwcm9wZXJ0eSByb290UGF0aCB7c3RyaW5nfSBTZXQgdG8gdGhlIHZhbHVlIG9mIGBQb2x5bWVyLnJvb3RQYXRoYCxcbiAgICogICB3aGljaCBkZWZhdWx0cyB0byB0aGUgbWFpbiBkb2N1bWVudCBwYXRoXG4gICAqIEBwcm9wZXJ0eSBpbXBvcnRQYXRoIHtzdHJpbmd9IFNldCB0byB0aGUgdmFsdWUgb2YgdGhlIGNsYXNzJ3Mgc3RhdGljXG4gICAqICAgYGltcG9ydFBhdGhgIHByb3BlcnR5LCB3aGljaCBkZWZhdWx0cyB0byB0aGUgcGF0aCBvZiB0aGlzIGVsZW1lbnQnc1xuICAgKiAgIGBkb20tbW9kdWxlYCAod2hlbiBgaXNgIGlzIHVzZWQpLCBidXQgY2FuIGJlIG92ZXJyaWRkZW4gZm9yIG90aGVyXG4gICAqICAgaW1wb3J0IHN0cmF0ZWdpZXMuXG4gICAqIEBzdW1tYXJ5IEVsZW1lbnQgY2xhc3MgbWl4aW4gdGhhdCBwcm92aWRlcyB0aGUgY29yZSBBUEkgZm9yIFBvbHltZXInc1xuICAgKiBtZXRhLXByb2dyYW1taW5nIGZlYXR1cmVzLlxuICAgKi9cbiAgUG9seW1lci5FbGVtZW50TWl4aW4gPSBQb2x5bWVyLmRlZHVwaW5nTWl4aW4oYmFzZSA9PiB7XG5cbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAZXh0ZW5kcyB7YmFzZX1cbiAgICAgKiBAaW1wbGVtZW50cyB7UG9seW1lcl9Qcm9wZXJ0eUVmZmVjdHN9XG4gICAgICovXG4gICAgY29uc3QgcG9seW1lckVsZW1lbnRCYXNlID0gUG9seW1lci5Qcm9wZXJ0eUVmZmVjdHMoYmFzZSk7XG5cbiAgICBsZXQgY2FzZU1hcCA9IFBvbHltZXIuQ2FzZU1hcDtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGBwcm9wZXJ0aWVzYCBvYmplY3Qgc3BlY2lmaWNhbGx5IG9uIGBrbGFzc2AuIFVzZSBmb3I6XG4gICAgICogKDEpIHN1cGVyIGNoYWluIG1peGVzIHRvZ3RoZXIgdG8gbWFrZSBgcHJvcGVydGllc0ZvckNsYXNzYCB3aGljaCBpc1xuICAgICAqIHRoZW4gdXNlZCB0byBtYWtlIGBvYnNlcnZlZEF0dHJpYnV0ZXNgLlxuICAgICAqICgyKSBwcm9wZXJ0aWVzIGVmZmVjdHMgYW5kIG9ic2VydmVycyBhcmUgY3JlYXRlZCBmcm9tIGl0IGF0IGBmaW5hbGl6ZWAgdGltZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGtsYXNzIEVsZW1lbnQgY2xhc3NcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdCBjb250YWluaW5nIG93biBwcm9wZXJ0aWVzIGZvciB0aGlzIGNsYXNzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvd25Qcm9wZXJ0aWVzRm9yQ2xhc3Moa2xhc3MpIHtcbiAgICAgIGlmICgha2xhc3MuaGFzT3duUHJvcGVydHkoXG4gICAgICAgIEpTQ29tcGlsZXJfcmVuYW1lUHJvcGVydHkoJ19fb3duUHJvcGVydGllcycsIGtsYXNzKSkpIHtcbiAgICAgICAga2xhc3MuX19vd25Qcm9wZXJ0aWVzID1cbiAgICAgICAgICBrbGFzcy5oYXNPd25Qcm9wZXJ0eShKU0NvbXBpbGVyX3JlbmFtZVByb3BlcnR5KCdwcm9wZXJ0aWVzJywga2xhc3MpKSA/XG4gICAgICAgICAgLyoqIEB0eXBlIFBvbHltZXJFbGVtZW50Q29uc3RydWN0b3IgKi8gKGtsYXNzKS5wcm9wZXJ0aWVzIDoge307XG4gICAgICB9XG4gICAgICByZXR1cm4ga2xhc3MuX19vd25Qcm9wZXJ0aWVzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGBvYnNlcnZlcnNgIGFycmF5IHNwZWNpZmljYWxseSBvbiBga2xhc3NgLiBVc2UgZm9yXG4gICAgICogc2V0dGluZyB1cCBvYnNlcnZlcnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBrbGFzcyBFbGVtZW50IGNsYXNzXG4gICAgICogQHJldHVybiB7QXJyYXl9IEFycmF5IGNvbnRhaW5pbmcgb3duIG9ic2VydmVycyBmb3IgdGhpcyBjbGFzc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZnVuY3Rpb24gb3duT2JzZXJ2ZXJzRm9yQ2xhc3Moa2xhc3MpIHtcbiAgICAgIGlmICgha2xhc3MuaGFzT3duUHJvcGVydHkoXG4gICAgICAgIEpTQ29tcGlsZXJfcmVuYW1lUHJvcGVydHkoJ19fb3duT2JzZXJ2ZXJzJywga2xhc3MpKSkge1xuICAgICAgICBrbGFzcy5fX293bk9ic2VydmVycyA9XG4gICAgICAgICAga2xhc3MuaGFzT3duUHJvcGVydHkoSlNDb21waWxlcl9yZW5hbWVQcm9wZXJ0eSgnb2JzZXJ2ZXJzJywga2xhc3MpKSA/XG4gICAgICAgICAgLyoqIEB0eXBlIFBvbHltZXJFbGVtZW50Q29uc3RydWN0b3IgKi8gKGtsYXNzKS5vYnNlcnZlcnMgOiBbXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBrbGFzcy5fX293bk9ic2VydmVycztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNaXhlcyBgcHJvcHNgIGludG8gYGZsYXR0ZW5lZFByb3BzYCBidXQgdXBncmFkZXMgc2hvcnRoYW5kIHR5cGVcbiAgICAgKiBzeW50YXggdG8geyB0eXBlOiBUeXBlfS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBmbGF0dGVuZWRQcm9wcyBCYWcgdG8gY29sbGVjdCBmbGF0dGVuZWQgcHJvcGVydGllcyBpbnRvXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzIEJhZyBvZiBwcm9wZXJ0aWVzIHRvIGFkZCB0byBgZmxhdHRlbmVkUHJvcHNgXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgaW5wdXQgYGZsYXR0ZW5lZFByb3BzYCBiYWdcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZsYXR0ZW5Qcm9wZXJ0aWVzKGZsYXR0ZW5lZFByb3BzLCBwcm9wcykge1xuICAgICAgZm9yIChsZXQgcCBpbiBwcm9wcykge1xuICAgICAgICBsZXQgbyA9IHByb3BzW3BdO1xuICAgICAgICBpZiAodHlwZW9mIG8gPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIG8gPSB7IHR5cGU6IG8gfTtcbiAgICAgICAgfVxuICAgICAgICBmbGF0dGVuZWRQcm9wc1twXSA9IG87XG4gICAgICB9XG4gICAgICByZXR1cm4gZmxhdHRlbmVkUHJvcHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGZsYXR0ZW5lZCBsaXN0IG9mIHByb3BlcnRpZXMgbWl4ZWQgdG9nZXRoZXIgZnJvbSB0aGUgY2hhaW4gb2YgYWxsXG4gICAgICogY29uc3RydWN0b3IncyBgY29uZmlnLnByb3BlcnRpZXNgLiBUaGlzIGxpc3QgaXMgdXNlZCB0byBjcmVhdGVcbiAgICAgKiAoMSkgb2JzZXJ2ZWRBdHRyaWJ1dGVzLFxuICAgICAqICgyKSBjbGFzcyBwcm9wZXJ0eSBkZWZhdWx0IHZhbHVlc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtQb2x5bWVyRWxlbWVudENvbnN0cnVjdG9yfSBrbGFzcyBFbGVtZW50IGNsYXNzXG4gICAgICogQHJldHVybiB7UG9seW1lckVsZW1lbnRQcm9wZXJ0aWVzfSBGbGF0dGVuZWQgcHJvcGVydGllcyBmb3IgdGhpcyBjbGFzc1xuICAgICAqIEBzdXBwcmVzcyB7bWlzc2luZ1Byb3BlcnRpZXN9IGNsYXNzLnByb3RvdHlwZSBpcyBub3QgYSBwcm9wZXJ0eSBmb3Igc29tZSByZWFzb24/XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwcm9wZXJ0aWVzRm9yQ2xhc3Moa2xhc3MpIHtcbiAgICAgIGlmICgha2xhc3MuaGFzT3duUHJvcGVydHkoXG4gICAgICAgIEpTQ29tcGlsZXJfcmVuYW1lUHJvcGVydHkoJ19fY2xhc3NQcm9wZXJ0aWVzJywga2xhc3MpKSkge1xuICAgICAgICBrbGFzcy5fX2NsYXNzUHJvcGVydGllcyA9XG4gICAgICAgIGZsYXR0ZW5Qcm9wZXJ0aWVzKHt9LCBvd25Qcm9wZXJ0aWVzRm9yQ2xhc3Moa2xhc3MpKTtcbiAgICAgICAgbGV0IHN1cGVyQ3RvciA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihrbGFzcy5wcm90b3R5cGUpLmNvbnN0cnVjdG9yO1xuICAgICAgICBpZiAoc3VwZXJDdG9yLnByb3RvdHlwZSBpbnN0YW5jZW9mIFBvbHltZXJFbGVtZW50KSB7XG4gICAgICAgICAga2xhc3MuX19jbGFzc1Byb3BlcnRpZXMgPSBPYmplY3QuYXNzaWduKFxuICAgICAgICAgICAgT2JqZWN0LmNyZWF0ZShwcm9wZXJ0aWVzRm9yQ2xhc3MoLyoqIEB0eXBlIFBvbHltZXJFbGVtZW50Q29uc3RydWN0b3IgKi8oc3VwZXJDdG9yKSkpLFxuICAgICAgICAgICAga2xhc3MuX19jbGFzc1Byb3BlcnRpZXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4ga2xhc3MuX19jbGFzc1Byb3BlcnRpZXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGxpc3Qgb2YgcHJvcGVydGllcyB3aXRoIGRlZmF1bHQgdmFsdWVzLlxuICAgICAqIFRoaXMgbGlzdCBpcyBjcmVhdGVkIGFzIGFuIG9wdGltaXphdGlvbiBzaW5jZSBpdCBpcyBhIHN1YnNldCBvZlxuICAgICAqIHRoZSBsaXN0IHJldHVybmVkIGZyb20gYHByb3BlcnRpZXNGb3JDbGFzc2AuXG4gICAgICogVGhpcyBsaXN0IGlzIHVzZWQgaW4gYF9pbml0aWFsaXplUHJvcGVydGllc2AgdG8gc2V0IHByb3BlcnR5IGRlZmF1bHRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQb2x5bWVyRWxlbWVudENvbnN0cnVjdG9yfSBrbGFzcyBFbGVtZW50IGNsYXNzXG4gICAgICogQHJldHVybiB7UG9seW1lckVsZW1lbnRQcm9wZXJ0aWVzfSBGbGF0dGVuZWQgcHJvcGVydGllcyBmb3IgdGhpcyBjbGFzc1xuICAgICAqICAgdGhhdCBoYXZlIGRlZmF1bHQgdmFsdWVzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwcm9wZXJ0eURlZmF1bHRzRm9yQ2xhc3Moa2xhc3MpIHtcbiAgICAgIGlmICgha2xhc3MuaGFzT3duUHJvcGVydHkoXG4gICAgICAgIEpTQ29tcGlsZXJfcmVuYW1lUHJvcGVydHkoJ19fY2xhc3NQcm9wZXJ0eURlZmF1bHRzJywga2xhc3MpKSkge1xuICAgICAgICBrbGFzcy5fX2NsYXNzUHJvcGVydHlEZWZhdWx0cyA9IG51bGw7XG4gICAgICAgIGxldCBwcm9wcyA9IHByb3BlcnRpZXNGb3JDbGFzcyhrbGFzcyk7XG4gICAgICAgIGZvciAobGV0IHAgaW4gcHJvcHMpIHtcbiAgICAgICAgICBsZXQgaW5mbyA9IHByb3BzW3BdO1xuICAgICAgICAgIGlmICgndmFsdWUnIGluIGluZm8pIHtcbiAgICAgICAgICAgIGtsYXNzLl9fY2xhc3NQcm9wZXJ0eURlZmF1bHRzID0ga2xhc3MuX19jbGFzc1Byb3BlcnR5RGVmYXVsdHMgfHwge307XG4gICAgICAgICAgICBrbGFzcy5fX2NsYXNzUHJvcGVydHlEZWZhdWx0c1twXSA9IGluZm87XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4ga2xhc3MuX19jbGFzc1Byb3BlcnR5RGVmYXVsdHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIGEgYGtsYXNzYCBoYXMgZmluYWxpemVkLiBDYWxsZWQgaW4gYEVsZW1lbnRDbGFzcy5maW5hbGl6ZSgpYFxuICAgICAqIEBwYXJhbSB7UG9seW1lckVsZW1lbnRDb25zdHJ1Y3Rvcn0ga2xhc3MgRWxlbWVudCBjbGFzc1xuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYWxsIG1ldGFwcm9ncmFtbWluZyBmb3IgdGhpcyBjbGFzcyBoYXMgYmVlblxuICAgICAqICAgY29tcGxldGVkXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBoYXNDbGFzc0ZpbmFsaXplZChrbGFzcykge1xuICAgICAgcmV0dXJuIGtsYXNzLmhhc093blByb3BlcnR5KEpTQ29tcGlsZXJfcmVuYW1lUHJvcGVydHkoJ19fZmluYWxpemVkJywga2xhc3MpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgYnkgYEVsZW1lbnRDbGFzcy5maW5hbGl6ZSgpYC4gRW5zdXJlcyB0aGlzIGBrbGFzc2AgYW5kXG4gICAgICogKmFsbCBzdXBlcmNsYXNzZXMqIGFyZSBmaW5hbGl6ZWQgYnkgdHJhdmVyc2luZyB0aGUgcHJvdG90eXBlIGNoYWluXG4gICAgICogYW5kIGNhbGxpbmcgYGtsYXNzLmZpbmFsaXplKClgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQb2x5bWVyRWxlbWVudENvbnN0cnVjdG9yfSBrbGFzcyBFbGVtZW50IGNsYXNzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5hbGl6ZUNsYXNzQW5kU3VwZXIoa2xhc3MpIHtcbiAgICAgIGxldCBwcm90byA9IC8qKiBAdHlwZSBQb2x5bWVyRWxlbWVudENvbnN0cnVjdG9yICovIChrbGFzcykucHJvdG90eXBlO1xuICAgICAgbGV0IHN1cGVyQ3RvciA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihwcm90bykuY29uc3RydWN0b3I7XG4gICAgICBpZiAoc3VwZXJDdG9yLnByb3RvdHlwZSBpbnN0YW5jZW9mIFBvbHltZXJFbGVtZW50KSB7XG4gICAgICAgIHN1cGVyQ3Rvci5maW5hbGl6ZSgpO1xuICAgICAgfVxuICAgICAgZmluYWxpemVDbGFzcyhrbGFzcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29uZmlndXJlcyBhIGBrbGFzc2AgYmFzZWQgb24gYSBzdGFpYyBga2xhc3MuY29uZmlnYCBvYmplY3QgYW5kXG4gICAgICogYSBgdGVtcGxhdGVgLiBUaGlzIGluY2x1ZGVzIGNyZWF0aW5nIGFjY2Vzc29ycyBhbmQgZWZmZWN0c1xuICAgICAqIGZvciBwcm9wZXJ0aWVzIGluIGBjb25maWdgIGFuZCB0aGUgYHRlbXBsYXRlYCBhcyB3ZWxsIGFzIHByZXBhcmluZyB0aGVcbiAgICAgKiBgdGVtcGxhdGVgIGZvciBzdGFtcGluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UG9seW1lckVsZW1lbnRDb25zdHJ1Y3Rvcn0ga2xhc3MgRWxlbWVudCBjbGFzc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmluYWxpemVDbGFzcyhrbGFzcykge1xuICAgICAga2xhc3MuX19maW5hbGl6ZWQgPSB0cnVlO1xuICAgICAgbGV0IHByb3RvID0gLyoqIEB0eXBlIFBvbHltZXJFbGVtZW50Q29uc3RydWN0b3IgKi8gKGtsYXNzKS5wcm90b3R5cGU7XG4gICAgICBpZiAoa2xhc3MuaGFzT3duUHJvcGVydHkoXG4gICAgICAgIEpTQ29tcGlsZXJfcmVuYW1lUHJvcGVydHkoJ2lzJywga2xhc3MpKSAmJiBrbGFzcy5pcykge1xuICAgICAgICBQb2x5bWVyLnRlbGVtZXRyeS5yZWdpc3Rlcihwcm90byk7XG4gICAgICB9XG4gICAgICBsZXQgcHJvcHMgPSBvd25Qcm9wZXJ0aWVzRm9yQ2xhc3Moa2xhc3MpO1xuICAgICAgaWYgKHByb3BzKSB7XG4gICAgICAgIGZpbmFsaXplUHJvcGVydGllcyhwcm90bywgcHJvcHMpO1xuICAgICAgfVxuICAgICAgbGV0IG9ic2VydmVycyA9IG93bk9ic2VydmVyc0ZvckNsYXNzKGtsYXNzKTtcbiAgICAgIGlmIChvYnNlcnZlcnMpIHtcbiAgICAgICAgZmluYWxpemVPYnNlcnZlcnMocHJvdG8sIG9ic2VydmVycywgcHJvcHMpO1xuICAgICAgfVxuICAgICAgLy8gbm90ZTogY3JlYXRlIFwid29ya2luZ1wiIHRlbXBsYXRlIHRoYXQgaXMgZmluYWxpemVkIGF0IGluc3RhbmNlIHRpbWVcbiAgICAgIGxldCB0ZW1wbGF0ZSA9IC8qKiBAdHlwZSBQb2x5bWVyRWxlbWVudENvbnN0cnVjdG9yICovIChrbGFzcykudGVtcGxhdGU7XG4gICAgICBpZiAodGVtcGxhdGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0ZW1wbGF0ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBsZXQgdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJyk7XG4gICAgICAgICAgdC5pbm5lckhUTUwgPSB0ZW1wbGF0ZTtcbiAgICAgICAgICB0ZW1wbGF0ZSA9IHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGVtcGxhdGUgPSB0ZW1wbGF0ZS5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcHJvdG8uX3RlbXBsYXRlID0gdGVtcGxhdGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29uZmlndXJlcyBhIGBwcm90b2AgYmFzZWQgb24gYSBgcHJvcGVydGllc2Agb2JqZWN0LlxuICAgICAqIExldmVyYWdlcyBgUHJvcGVydHlFZmZlY3RzYCB0byBjcmVhdGUgcHJvcGVydHkgYWNjZXNzb3JzIGFuZCBlZmZlY3RzXG4gICAgICogc3VwcG9ydGluZywgb2JzZXJ2ZXJzLCByZWZsZWN0aW5nIHRvIGF0dHJpYnV0ZXMsIGNoYW5nZSBub3RpZmljYXRpb24sXG4gICAgICogY29tcHV0ZWQgcHJvcGVydGllcywgYW5kIHJlYWQgb25seSBwcm9wZXJ0aWVzLlxuICAgICAqIEBwYXJhbSB7UG9seW1lckVsZW1lbnR9IHByb3RvIEVsZW1lbnQgY2xhc3MgcHJvdG90eXBlIHRvIGFkZCBhY2Nlc3NvcnNcbiAgICAgKiAgICBhbmQgZWZmZWN0cyB0b1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wZXJ0aWVzIEZsYXR0ZW5lZCBiYWcgb2YgcHJvcGVydHkgZGVzY3JpcHRvcnMgZm9yXG4gICAgICogICAgdGhpcyBjbGFzc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmluYWxpemVQcm9wZXJ0aWVzKHByb3RvLCBwcm9wZXJ0aWVzKSB7XG4gICAgICBmb3IgKGxldCBwIGluIHByb3BlcnRpZXMpIHtcbiAgICAgICAgY3JlYXRlUHJvcGVydHlGcm9tQ29uZmlnKHByb3RvLCBwLCBwcm9wZXJ0aWVzW3BdLCBwcm9wZXJ0aWVzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb25maWd1cmVzIGEgYHByb3RvYCBiYXNlZCBvbiBhIGBvYnNlcnZlcnNgIGFycmF5LlxuICAgICAqIExldmVyYWdlcyBgUHJvcGVydHlFZmZlY3RzYCB0byBjcmVhdGUgb2JzZXJ2ZXJzLlxuICAgICAqIEBwYXJhbSB7UG9seW1lckVsZW1lbnR9IHByb3RvIEVsZW1lbnQgY2xhc3MgcHJvdG90eXBlIHRvIGFkZCBhY2Nlc3NvcnNcbiAgICAgKiAgIGFuZCBlZmZlY3RzIHRvXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9ic2VydmVycyBGbGF0dGVuZWQgYXJyYXkgb2Ygb2JzZXJ2ZXIgZGVzY3JpcHRvcnMgZm9yXG4gICAgICogICB0aGlzIGNsYXNzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGR5bmFtaWNGbnMgT2JqZWN0IGNvbnRhaW5pbmcga2V5cyBmb3IgYW55IHByb3BlcnRpZXNcbiAgICAgKiAgIHRoYXQgYXJlIGZ1bmN0aW9ucyBhbmQgc2hvdWxkIHRyaWdnZXIgdGhlIGVmZmVjdCB3aGVuIHRoZSBmdW5jdGlvblxuICAgICAqICAgcmVmZXJlbmNlIGlzIGNoYW5nZWRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbmFsaXplT2JzZXJ2ZXJzKHByb3RvLCBvYnNlcnZlcnMsIGR5bmFtaWNGbnMpIHtcbiAgICAgIGZvciAobGV0IGk9MDsgaSA8IG9ic2VydmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBwcm90by5fY3JlYXRlTWV0aG9kT2JzZXJ2ZXIob2JzZXJ2ZXJzW2ldLCBkeW5hbWljRm5zKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGVmZmVjdHMgZm9yIGEgcHJvcGVydHkuXG4gICAgICpcbiAgICAgKiBOb3RlLCBvbmNlIGEgcHJvcGVydHkgaGFzIGJlZW4gc2V0IHRvXG4gICAgICogYHJlYWRPbmx5YCwgYGNvbXB1dGVkYCwgYHJlZmxlY3RUb0F0dHJpYnV0ZWAsIG9yIGBub3RpZnlgXG4gICAgICogdGhlc2UgdmFsdWVzIG1heSBub3QgYmUgY2hhbmdlZC4gRm9yIGV4YW1wbGUsIGEgc3ViY2xhc3MgY2Fubm90XG4gICAgICogYWx0ZXIgdGhlc2Ugc2V0dGluZ3MuIEhvd2V2ZXIsIGFkZGl0aW9uYWwgYG9ic2VydmVyc2AgbWF5IGJlIGFkZGVkXG4gICAgICogYnkgc3ViY2xhc3Nlcy5cbiAgICAgKlxuICAgICAqIFRoZSBpbmZvIG9iamVjdCBzaG91bGQgbWF5IGNvbnRhaW4gcHJvcGVydHkgbWV0YWRhdGEgYXMgZm9sbG93czpcbiAgICAgKlxuICAgICAqICogYHR5cGVgOiB7ZnVuY3Rpb259IHR5cGUgdG8gd2hpY2ggYW4gYXR0cmlidXRlIG1hdGNoaW5nIHRoZSBwcm9wZXJ0eVxuICAgICAqIGlzIGRlc2VyaWFsaXplZC4gTm90ZSB0aGUgcHJvcGVydHkgaXMgY2FtZWwtY2FzZWQgZnJvbSBhIGRhc2gtY2FzZWRcbiAgICAgKiBhdHRyaWJ1dGUuIEZvciBleGFtcGxlLCAnZm9vLWJhcicgYXR0cmlidXRlIGlzIGRlcnNpYWxpemVkIHRvIGFcbiAgICAgKiBwcm9wZXJ0eSBuYW1lZCAnZm9vQmFyJy5cbiAgICAgKlxuICAgICAqICogYHJlYWRPbmx5YDoge2Jvb2xlYW59IGNyZWF0ZXMgYSByZWFkT25seSBwcm9wZXJ0eSBhbmRcbiAgICAgKiBtYWtlcyBhIHByaXZhdGUgc2V0dGVyIGZvciB0aGUgcHJpdmF0ZSBvZiB0aGUgZm9ybSAnX3NldEZvbycgZm9yIGFcbiAgICAgKiBwcm9wZXJ0eSAnZm9vJyxcbiAgICAgKlxuICAgICAqICogYGNvbXB1dGVkYDoge3N0cmluZ30gY3JlYXRlcyBhIGNvbXB1dGVkIHByb3BlcnR5LiBBIGNvbXB1dGVkIHByb3BlcnR5XG4gICAgICogYWxzbyBhdXRvbWF0aWNhbGx5IGlzIHNldCB0byBgcmVhZE9ubHk6IHRydWVgLiBUaGUgdmFsdWUgaXMgY2FsY3VsYXRlZFxuICAgICAqIGJ5IHJ1bm5pbmcgYSBtZXRob2QgYW5kIGFyZ3VtZW50cyBwYXJzZWQgZnJvbSB0aGUgZ2l2ZW4gc3RyaW5nLiBGb3JcbiAgICAgKiBleGFtcGxlICdjb21wdXRlKGZvbyknIHdpbGwgY29tcHV0ZSBhIGdpdmVuIHByb3BlcnR5IHdoZW4gdGhlXG4gICAgICogJ2ZvbycgcHJvcGVydHkgY2hhbmdlcyBieSBleGVjdXRpbmcgdGhlICdjb21wdXRlJyBtZXRob2QuIFRoaXMgbWV0aG9kXG4gICAgICogbXVzdCByZXR1cm4gdGhlIGNvbXB1dGVkIHZhbHVlLlxuICAgICAqXG4gICAgICogKiBgcmVmbGVjdFRvQXR0cml1dGVgOiB7Ym9vbGVhbn0gSWYgdHJ1ZSwgdGhlIHByb3BlcnR5IHZhbHVlIGlzIHJlZmxlY3RlZFxuICAgICAqIHRvIGFuIGF0dHJpYnV0ZSBvZiB0aGUgc2FtZSBuYW1lLiBOb3RlLCB0aGUgYXR0cmlidXRlIGlzIGRhc2gtY2FzZWRcbiAgICAgKiBzbyBhIHByb3BlcnR5IG5hbWVkICdmb29CYXInIGlzIHJlZmxlY3RlZCBhcyAnZm9vLWJhcicuXG4gICAgICpcbiAgICAgKiAqIGBub3RpZnlgOiB7Ym9vbGVhbn0gc2VuZHMgYSBub24tYnViYmxpbmcgbm90aWZpY2F0aW9uIGV2ZW50IHdoZW5cbiAgICAgKiB0aGUgcHJvcGVydHkgY2hhbmdlcy4gRm9yIGV4YW1wbGUsIGEgcHJvcGVydHkgbmFtZWQgJ2Zvbycgc2VuZHMgYW5cbiAgICAgKiBldmVudCBuYW1lZCAnZm9vLWNoYW5nZWQnIHdpdGggYGV2ZW50LmRldGFpbGAgc2V0IHRvIHRoZSB2YWx1ZSBvZlxuICAgICAqIHRoZSBwcm9wZXJ0eS5cbiAgICAgKlxuICAgICAqICogb2JzZXJ2ZXI6IHtzdHJpbmd9IG5hbWUgb2YgYSBtZXRob2QgdGhhdCBydW5zIHdoZW4gdGhlIHByb3BlcnR5XG4gICAgICogY2hhbmdlcy4gVGhlIGFyZ3VtZW50cyBvZiB0aGUgbWV0aG9kIGFyZSAodmFsdWUsIHByZXZpb3VzVmFsdWUpLlxuICAgICAqXG4gICAgICogTm90ZTogVXNlcnMgbWF5IHdhbnQgY29udHJvbCBvdmVyIG1vZGlmeWluZyBwcm9wZXJ0eVxuICAgICAqIGVmZmVjdHMgdmlhIHN1YmNsYXNzaW5nLiBGb3IgZXhhbXBsZSwgYSB1c2VyIG1pZ2h0IHdhbnQgdG8gbWFrZSBhXG4gICAgICogcmVmbGVjdFRvQXR0cmlidXRlIHByb3BlcnR5IG5vdCBkbyBzbyBpbiBhIHN1YmNsYXNzLiBXZSd2ZSBjaG9zZW4gdG9cbiAgICAgKiBkaXNhYmxlIHRoaXMgYmVjYXVzZSBpdCBsZWFkcyB0byBhZGRpdGlvbmFsIGNvbXBsaWNhdGlvbi5cbiAgICAgKiBGb3IgZXhhbXBsZSwgYSByZWFkT25seSBlZmZlY3QgZ2VuZXJhdGVzIGEgc3BlY2lhbCBzZXR0ZXIuIElmIGEgc3ViY2xhc3NcbiAgICAgKiBkaXNhYmxlcyB0aGUgZWZmZWN0LCB0aGUgc2V0dGVyIHdvdWxkIGZhaWwgdW5leHBlY3RlZGx5LlxuICAgICAqIEJhc2VkIG9uIGZlZWRiYWNrLCB3ZSBtYXkgd2FudCB0byB0cnkgdG8gbWFrZSBlZmZlY3RzIG1vcmUgbWFsbGVhYmxlXG4gICAgICogYW5kL29yIHByb3ZpZGUgYW4gYWR2YW5jZWQgYXBpIGZvciBtYW5pcHVsYXRpbmcgdGhlbS5cbiAgICAgKiBBbHNvIGNvbnNpZGVyIGFkZGluZyB3YXJuaW5ncyB3aGVuIGFuIGVmZmVjdCBjYW5ub3QgYmUgY2hhbmdlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UG9seW1lckVsZW1lbnR9IHByb3RvIEVsZW1lbnQgY2xhc3MgcHJvdG90eXBlIHRvIGFkZCBhY2Nlc3NvcnNcbiAgICAgKiAgIGFuZCBlZmZlY3RzIHRvXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgTmFtZSBvZiB0aGUgcHJvcGVydHkuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGluZm8gSW5mbyBvYmplY3QgZnJvbSB3aGljaCB0byBjcmVhdGUgcHJvcGVydHkgZWZmZWN0cy5cbiAgICAgKiBTdXBwb3J0ZWQga2V5czpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYWxsUHJvcHMgRmxhdHRlbmVkIG1hcCBvZiBhbGwgcHJvcGVydGllcyBkZWZpbmVkIGluIHRoaXNcbiAgICAgKiAgIGVsZW1lbnQgKGluY2x1ZGluZyBpbmhlcml0ZWQgcHJvcGVydGllcylcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVByb3BlcnR5RnJvbUNvbmZpZyhwcm90bywgbmFtZSwgaW5mbywgYWxsUHJvcHMpIHtcbiAgICAgIC8vIGNvbXB1dGVkIGZvcmNlcyByZWFkT25seS4uLlxuICAgICAgaWYgKGluZm8uY29tcHV0ZWQpIHtcbiAgICAgICAgaW5mby5yZWFkT25seSA9IHRydWU7XG4gICAgICB9XG4gICAgICAvLyBOb3RlLCBzaW5jZSBhbGwgY29tcHV0ZWQgcHJvcGVydGllcyBhcmUgcmVhZE9ubHksIHRoaXMgcHJldmVudHNcbiAgICAgIC8vIGFkZGluZyBhZGRpdGlvbmFsIGNvbXB1dGVkIHByb3BlcnR5IGVmZmVjdHMgKHdoaWNoIGxlYWRzIHRvIGEgY29uZnVzaW5nXG4gICAgICAvLyBzZXR1cCB3aGVyZSBtdWx0aXBsZSB0cmlnZ2VycyBmb3Igc2V0dGluZyBhIHByb3BlcnR5KVxuICAgICAgLy8gV2hpbGUgd2UgZG8gaGF2ZSBgaGFzQ29tcHV0ZWRFZmZlY3RgIHRoaXMgaXMgc2V0IG9uIHRoZSBwcm9wZXJ0eSdzXG4gICAgICAvLyBkZXBlbmRlbmNpZXMgcmF0aGVyIHRoYW4gaXRzZWxmLlxuICAgICAgaWYgKGluZm8uY29tcHV0ZWQgICYmICFwcm90by5faGFzUmVhZE9ubHlFZmZlY3QobmFtZSkpIHtcbiAgICAgICAgcHJvdG8uX2NyZWF0ZUNvbXB1dGVkUHJvcGVydHkobmFtZSwgaW5mby5jb21wdXRlZCwgYWxsUHJvcHMpO1xuICAgICAgfVxuICAgICAgaWYgKGluZm8ucmVhZE9ubHkgJiYgIXByb3RvLl9oYXNSZWFkT25seUVmZmVjdChuYW1lKSkge1xuICAgICAgICBwcm90by5fY3JlYXRlUmVhZE9ubHlQcm9wZXJ0eShuYW1lLCAhaW5mby5jb21wdXRlZCk7XG4gICAgICB9XG4gICAgICBpZiAoaW5mby5yZWZsZWN0VG9BdHRyaWJ1dGUgJiYgIXByb3RvLl9oYXNSZWZsZWN0RWZmZWN0KG5hbWUpKSB7XG4gICAgICAgIHByb3RvLl9jcmVhdGVSZWZsZWN0ZWRQcm9wZXJ0eShuYW1lKTtcbiAgICAgIH1cbiAgICAgIGlmIChpbmZvLm5vdGlmeSAmJiAhcHJvdG8uX2hhc05vdGlmeUVmZmVjdChuYW1lKSkge1xuICAgICAgICBwcm90by5fY3JlYXRlTm90aWZ5aW5nUHJvcGVydHkobmFtZSk7XG4gICAgICB9XG4gICAgICAvLyBhbHdheXMgYWRkIG9ic2VydmVyXG4gICAgICBpZiAoaW5mby5vYnNlcnZlcikge1xuICAgICAgICBwcm90by5fY3JlYXRlUHJvcGVydHlPYnNlcnZlcihuYW1lLCBpbmZvLm9ic2VydmVyLCBhbGxQcm9wc1tpbmZvLm9ic2VydmVyXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29uZmlndXJlcyBhbiBlbGVtZW50IGBwcm90b2AgdG8gZnVuY3Rpb24gd2l0aCBhIGdpdmVuIGB0ZW1wbGF0ZWAuXG4gICAgICogVGhlIGVsZW1lbnQgbmFtZSBgaXNgIGFuZCBleHRlbmRzIGBleHRgIG11c3QgYmUgc3BlY2lmaWVkIGZvciBTaGFkeUNTU1xuICAgICAqIHN0eWxlIHNjb3BpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BvbHltZXJFbGVtZW50fSBwcm90byBFbGVtZW50IGNsYXNzIHByb3RvdHlwZSB0byBhZGQgYWNjZXNzb3JzXG4gICAgICogICBhbmQgZWZmZWN0cyB0b1xuICAgICAqIEBwYXJhbSB7IUhUTUxUZW1wbGF0ZUVsZW1lbnR9IHRlbXBsYXRlIFRlbXBsYXRlIHRvIHByb2Nlc3MgYW5kIGJpbmRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYmFzZVVSSSBVUkwgYWdhaW5zdCB3aGljaCB0byByZXNvbHZlIHVybHMgaW5cbiAgICAgKiAgIHN0eWxlIGVsZW1lbnQgY3NzVGV4dFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpcyBUYWcgbmFtZSAob3IgdHlwZSBleHRlbnNpb24gbmFtZSkgZm9yIHRoaXMgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7c3RyaW5nPX0gZXh0IEZvciB0eXBlIGV4dGVuc2lvbnMsIHRoZSB0YWcgbmFtZSB0aGF0IHdhcyBleHRlbmRlZFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmluYWxpemVUZW1wbGF0ZShwcm90bywgdGVtcGxhdGUsIGJhc2VVUkksIGlzLCBleHQpIHtcbiAgICAgIC8vIHN1cHBvcnQgYGluY2x1ZGU9XCJtb2R1bGUtbmFtZVwiYFxuICAgICAgbGV0IGNzc1RleHQgPVxuICAgICAgICBQb2x5bWVyLlN0eWxlR2F0aGVyLmNzc0Zyb21UZW1wbGF0ZSh0ZW1wbGF0ZSwgYmFzZVVSSSkgK1xuICAgICAgICBQb2x5bWVyLlN0eWxlR2F0aGVyLmNzc0Zyb21Nb2R1bGVJbXBvcnRzKGlzKTtcbiAgICAgIGlmIChjc3NUZXh0KSB7XG4gICAgICAgIGxldCBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgICAgIHN0eWxlLnRleHRDb250ZW50ID0gY3NzVGV4dDtcbiAgICAgICAgdGVtcGxhdGUuY29udGVudC5pbnNlcnRCZWZvcmUoc3R5bGUsIHRlbXBsYXRlLmNvbnRlbnQuZmlyc3RDaGlsZCk7XG4gICAgICB9XG4gICAgICBpZiAod2luZG93LlNoYWR5Q1NTKSB7XG4gICAgICAgIHdpbmRvdy5TaGFkeUNTUy5wcmVwYXJlVGVtcGxhdGUodGVtcGxhdGUsIGlzLCBleHQpO1xuICAgICAgfVxuICAgICAgcHJvdG8uX2JpbmRUZW1wbGF0ZSh0ZW1wbGF0ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBvbHltZXJcbiAgICAgKiBAbWl4aW5DbGFzc1xuICAgICAqIEB1bnJlc3RyaWN0ZWRcbiAgICAgKiBAaW1wbGVtZW50cyB7UG9seW1lcl9FbGVtZW50TWl4aW59XG4gICAgICovXG4gICAgY2xhc3MgUG9seW1lckVsZW1lbnQgZXh0ZW5kcyBwb2x5bWVyRWxlbWVudEJhc2Uge1xuXG4gICAgICAvKipcbiAgICAgICAqIFN0YW5kYXJkIEN1c3RvbSBFbGVtZW50cyBWMSBBUEkuICBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiByZXR1cm5zXG4gICAgICAgKiBhIGxpc3Qgb2YgZGFzaC1jYXNlZCBhdHRyaWJ1dGVzIGJhc2VkIG9uIGEgZmxhdHRlbmluZyBvZiBhbGwgcHJvcGVydGllc1xuICAgICAgICogZGVjbGFyZWQgaW4gYHN0YXRpYyBnZXQgcHJvcGVydGllcygpYCBmb3IgdGhpcyBlbGVtZW50IGFuZCBhbnlcbiAgICAgICAqIHN1cGVyY2xhc3Nlcy5cbiAgICAgICAqXG4gICAgICAgKiBAcmV0dXJuIHtBcnJheX0gT2JzZXJ2ZWQgYXR0cmlidXRlIGxpc3RcbiAgICAgICAqL1xuICAgICAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgICAgIGlmICghdGhpcy5oYXNPd25Qcm9wZXJ0eShKU0NvbXBpbGVyX3JlbmFtZVByb3BlcnR5KCdfX29ic2VydmVkQXR0cmlidXRlcycsIHRoaXMpKSkge1xuICAgICAgICAgIGxldCBsaXN0ID0gW107XG4gICAgICAgICAgbGV0IHByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzRm9yQ2xhc3ModGhpcyk7XG4gICAgICAgICAgZm9yIChsZXQgcHJvcCBpbiBwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICBsaXN0LnB1c2goUG9seW1lci5DYXNlTWFwLmNhbWVsVG9EYXNoQ2FzZShwcm9wKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX19vYnNlcnZlZEF0dHJpYnV0ZXMgPSBsaXN0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9fb2JzZXJ2ZWRBdHRyaWJ1dGVzO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENhbGxlZCBhdXRvbWF0aWNhbGx5IHdoZW4gdGhlIGZpcnN0IGVsZW1lbnQgaW5zdGFuY2UgaXMgY3JlYXRlZCB0b1xuICAgICAgICogZW5zdXJlIHRoYXQgY2xhc3MgZmluYWxpemF0aW9uIHdvcmsgaGFzIGJlZW4gY29tcGxldGVkLlxuICAgICAgICogTWF5IGJlIGNhbGxlZCBieSB1c2VycyB0byBlYWdlcmx5IHBlcmZvcm0gY2xhc3MgZmluYWxpemF0aW9uIHdvcmtcbiAgICAgICAqIHByaW9yIHRvIHRoZSBjcmVhdGlvbiBvZiB0aGUgZmlyc3QgZWxlbWVudCBpbnN0YW5jZS5cbiAgICAgICAqXG4gICAgICAgKiBDbGFzcyBmaW5hbGl6YXRpb24gd29yayBnZW5lcmFsbHkgaW5jbHVkZXMgbWV0YS1wcm9ncmFtbWluZyBzdWNoIGFzXG4gICAgICAgKiBjcmVhdGluZyBwcm9wZXJ0eSBhY2Nlc3NvcnMgYW5kIGFueSBwcm9wZXJ0eSBlZmZlY3QgbWV0YWRhdGEgbmVlZGVkIGZvclxuICAgICAgICogdGhlIGZlYXR1cmVzIHVzZWQuXG4gICAgICAgKlxuICAgICAgICogQHB1YmxpY1xuICAgICAgICovXG4gICAgICBzdGF0aWMgZmluYWxpemUoKSB7XG4gICAgICAgIGlmICghaGFzQ2xhc3NGaW5hbGl6ZWQodGhpcykpIHtcbiAgICAgICAgICBmaW5hbGl6ZUNsYXNzQW5kU3VwZXIodGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZXR1cm5zIHRoZSB0ZW1wbGF0ZSB0aGF0IHdpbGwgYmUgc3RhbXBlZCBpbnRvIHRoaXMgZWxlbWVudCdzIHNoYWRvdyByb290LlxuICAgICAgICpcbiAgICAgICAqIElmIGEgYHN0YXRpYyBnZXQgaXMoKWAgZ2V0dGVyIGlzIGRlZmluZWQsIHRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uXG4gICAgICAgKiB3aWxsIHJldHVybiB0aGUgZmlyc3QgYDx0ZW1wbGF0ZT5gIGluIGEgYGRvbS1tb2R1bGVgIHdob3NlIGBpZGBcbiAgICAgICAqIG1hdGNoZXMgdGhpcyBlbGVtZW50J3MgYGlzYC5cbiAgICAgICAqXG4gICAgICAgKiBVc2VycyBtYXkgb3ZlcnJpZGUgdGhpcyBnZXR0ZXIgdG8gcmV0dXJuIGFuIGFyYml0cmFyeSB0ZW1wbGF0ZVxuICAgICAgICogKGluIHdoaWNoIGNhc2UgdGhlIGBpc2AgZ2V0dGVyIGlzIHVubmVjZXNzYXJ5KS4gVGhlIHRlbXBsYXRlIHJldHVybmVkXG4gICAgICAgKiBtYXkgYmUgZWl0aGVyIGFuIGBIVE1MVGVtcGxhdGVFbGVtZW50YCBvciBhIHN0cmluZyB0aGF0IHdpbGwgYmVcbiAgICAgICAqIGF1dG9tYXRpY2FsbHkgcGFyc2VkIGludG8gYSB0ZW1wbGF0ZS5cbiAgICAgICAqXG4gICAgICAgKiBOb3RlIHRoYXQgd2hlbiBzdWJjbGFzc2luZywgaWYgdGhlIHN1cGVyIGNsYXNzIG92ZXJyb2RlIHRoZSBkZWZhdWx0XG4gICAgICAgKiBpbXBsZW1lbnRhdGlvbiBhbmQgdGhlIHN1YmNsYXNzIHdvdWxkIGxpa2UgdG8gcHJvdmlkZSBhbiBhbHRlcm5hdGVcbiAgICAgICAqIHRlbXBsYXRlIHZpYSBhIGBkb20tbW9kdWxlYCwgaXQgc2hvdWxkIG92ZXJyaWRlIHRoaXMgZ2V0dGVyIGFuZFxuICAgICAgICogcmV0dXJuIGBQb2x5bWVyLkRvbU1vZHVsZS5pbXBvcnQodGhpcy5pcywgJ3RlbXBsYXRlJylgLlxuICAgICAgICpcbiAgICAgICAqIElmIGEgc3ViY2xhc3Mgd291bGQgbGlrZSB0byBtb2RpZnkgdGhlIHN1cGVyIGNsYXNzIHRlbXBsYXRlLCBpdCBzaG91bGRcbiAgICAgICAqIGNsb25lIGl0IHJhdGhlciB0aGFuIG1vZGlmeSBpdCBpbiBwbGFjZS4gIElmIHRoZSBnZXR0ZXIgZG9lcyBleHBlbnNpdmVcbiAgICAgICAqIHdvcmsgc3VjaCBhcyBjbG9uaW5nL21vZGlmeWluZyBhIHRlbXBsYXRlLCBpdCBzaG91bGQgbWVtb2l6ZSB0aGVcbiAgICAgICAqIHRlbXBsYXRlIGZvciBtYXhpbXVtIHBlcmZvcm1hbmNlOlxuICAgICAgICpcbiAgICAgICAqICAgbGV0IG1lbW9pemVkVGVtcGxhdGU7XG4gICAgICAgKiAgIGNsYXNzIE15U3ViQ2xhc3MgZXh0ZW5kcyBNeVN1cGVyQ2xhc3Mge1xuICAgICAgICogICAgIHN0YXRpYyBnZXQgdGVtcGxhdGUoKSB7XG4gICAgICAgKiAgICAgICBpZiAoIW1lbW9pemVkVGVtcGxhdGUpIHtcbiAgICAgICAqICAgICAgICAgbWVtb2l6ZWRUZW1wbGF0ZSA9IHN1cGVyLnRlbXBsYXRlLmNsb25lTm9kZSh0cnVlKTtcbiAgICAgICAqICAgICAgICAgbGV0IHN1YkNvbnRlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAqICAgICAgICAgc3ViQ29udGVudC50ZXh0Q29udGVudCA9ICdUaGlzIGNhbWUgZnJvbSBNeVN1YkNsYXNzJztcbiAgICAgICAqICAgICAgICAgbWVtb2l6ZWRUZW1wbGF0ZS5jb250ZW50LmFwcGVuZENoaWxkKHN1YkNvbnRlbnQpO1xuICAgICAgICogICAgICAgfVxuICAgICAgICogICAgICAgcmV0dXJuIG1lbW9pemVkVGVtcGxhdGU7XG4gICAgICAgKiAgICAgfVxuICAgICAgICogICB9XG4gICAgICAgKlxuICAgICAgICogQHJldHVybiB7SFRNTFRlbXBsYXRlRWxlbWVudHxzdHJpbmd9IFRlbXBsYXRlIHRvIGJlIHN0YW1wZWRcbiAgICAgICAqL1xuICAgICAgc3RhdGljIGdldCB0ZW1wbGF0ZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhc093blByb3BlcnR5KEpTQ29tcGlsZXJfcmVuYW1lUHJvcGVydHkoJ190ZW1wbGF0ZScsIHRoaXMpKSkge1xuICAgICAgICAgIHRoaXMuX3RlbXBsYXRlID0gUG9seW1lci5Eb21Nb2R1bGUgJiYgUG9seW1lci5Eb21Nb2R1bGUuaW1wb3J0KFxuICAgICAgICAgICAgLyoqIEB0eXBlIFBvbHltZXJFbGVtZW50Q29uc3RydWN0b3IqLyAodGhpcykuaXMsICd0ZW1wbGF0ZScpIHx8XG4gICAgICAgICAgICAvLyBub3RlOiBpbXBsZW1lbnRlZCBzbyBhIHN1YmNsYXNzIGNhbiByZXRyaWV2ZSB0aGUgc3VwZXJcbiAgICAgICAgICAgIC8vIHRlbXBsYXRlOyBjYWxsIHRoZSBzdXBlciBpbXBsIHRoaXMgd2F5IHNvIHRoYXQgYHRoaXNgIHBvaW50c1xuICAgICAgICAgICAgLy8gdG8gdGhlIHN1cGVyY2xhc3MuXG4gICAgICAgICAgICBPYmplY3QuZ2V0UHJvdG90eXBlT2YoLyoqIEB0eXBlIFBvbHltZXJFbGVtZW50Q29uc3RydWN0b3IqLyAodGhpcykucHJvdG90eXBlKS5jb25zdHJ1Y3Rvci50ZW1wbGF0ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fdGVtcGxhdGU7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUGF0aCBtYXRjaGluZyB0aGUgdXJsIGZyb20gd2hpY2ggdGhlIGVsZW1lbnQgd2FzIGltcG9ydGVkLlxuICAgICAgICogVGhpcyBwYXRoIGlzIHVzZWQgdG8gcmVzb2x2ZSB1cmwncyBpbiB0ZW1wbGF0ZSBzdHlsZSBjc3NUZXh0LlxuICAgICAgICogVGhlIGBpbXBvcnRQYXRoYCBwcm9wZXJ0eSBpcyBhbHNvIHNldCBvbiBlbGVtZW50IGluc3RhbmNlcyBhbmQgY2FuIGJlXG4gICAgICAgKiB1c2VkIHRvIGNyZWF0ZSBiaW5kaW5ncyByZWxhdGl2ZSB0byB0aGUgaW1wb3J0IHBhdGguXG4gICAgICAgKiBEZWZhdWx0cyB0byB0aGUgcGF0aCBtYXRjaGluZyB0aGUgdXJsIGNvbnRhaW5pbmcgYSBgZG9tLW1vZHVsZWAgZWxlbWVudFxuICAgICAgICogbWF0Y2hpbmcgdGhpcyBlbGVtZW50J3Mgc3RhdGljIGBpc2AgcHJvcGVydHkuXG4gICAgICAgKiBOb3RlLCB0aGlzIHBhdGggc2hvdWxkIGNvbnRhaW4gYSB0cmFpbGluZyBgL2AuXG4gICAgICAgKlxuICAgICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgaW1wb3J0IHBhdGggZm9yIHRoaXMgZWxlbWVudCBjbGFzc1xuICAgICAgICovXG4gICAgICBzdGF0aWMgZ2V0IGltcG9ydFBhdGgoKSB7XG4gICAgICAgIGlmICghdGhpcy5oYXNPd25Qcm9wZXJ0eShKU0NvbXBpbGVyX3JlbmFtZVByb3BlcnR5KCdfaW1wb3J0UGF0aCcsIHRoaXMpKSkge1xuICAgICAgICAgICAgY29uc3QgbW9kdWxlID0gUG9seW1lci5Eb21Nb2R1bGUgJiYgUG9seW1lci5Eb21Nb2R1bGUuaW1wb3J0KC8qKiBAdHlwZSBQb2x5bWVyRWxlbWVudENvbnN0cnVjdG9yICovICh0aGlzKS5pcyk7XG4gICAgICAgICAgICB0aGlzLl9pbXBvcnRQYXRoID0gbW9kdWxlID8gbW9kdWxlLmFzc2V0cGF0aCA6ICcnIHx8XG4gICAgICAgICAgICBPYmplY3QuZ2V0UHJvdG90eXBlT2YoLyoqIEB0eXBlIFBvbHltZXJFbGVtZW50Q29uc3RydWN0b3IqLyAodGhpcykucHJvdG90eXBlKS5jb25zdHJ1Y3Rvci5pbXBvcnRQYXRoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9pbXBvcnRQYXRoO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIE92ZXJyaWRlcyB0aGUgZGVmYXVsdCBgUG9seW1lci5Qcm9wZXJ0eUFjY2Vzc29yc2AgdG8gZW5zdXJlIGNsYXNzXG4gICAgICAgKiBtZXRhcHJvZ3JhbW1pbmcgcmVsYXRlZCB0byBwcm9wZXJ0eSBhY2Nlc3NvcnMgYW5kIGVmZmVjdHMgaGFzXG4gICAgICAgKiBjb21wbGV0ZWQgKGNhbGxzIGBmaW5hbGl6ZWApLlxuICAgICAgICpcbiAgICAgICAqIEl0IGFsc28gaW5pdGlhbGl6ZXMgYW55IHByb3BlcnR5IGRlZmF1bHRzIHByb3ZpZGVkIHZpYSBgdmFsdWVgIGluXG4gICAgICAgKiBgcHJvcGVydGllc2AgbWV0YWRhdGEuXG4gICAgICAgKlxuICAgICAgICogQG92ZXJyaWRlXG4gICAgICAgKiBAc3VwcHJlc3Mge2ludmFsaWRDYXN0c31cbiAgICAgICAqL1xuICAgICAgX2luaXRpYWxpemVQcm9wZXJ0aWVzKCkge1xuICAgICAgICBQb2x5bWVyLnRlbGVtZXRyeS5pbnN0YW5jZUNvdW50Kys7XG4gICAgICAgIHRoaXMuY29uc3RydWN0b3IuZmluYWxpemUoKTtcbiAgICAgICAgY29uc3QgaW1wb3J0UGF0aCA9IHRoaXMuY29uc3RydWN0b3IuaW1wb3J0UGF0aDtcbiAgICAgICAgLy8gbm90ZTogZmluYWxpemUgdGVtcGxhdGUgd2hlbiB3ZSBoYXZlIGFjY2VzcyB0byBgbG9jYWxOYW1lYCB0b1xuICAgICAgICAvLyBhdm9pZCBkZXBlbmRlbmNlIG9uIGBpc2AgZm9yIHBvbHlmaWxsaW5nIHN0eWxpbmcuXG4gICAgICAgIGlmICh0aGlzLl90ZW1wbGF0ZSAmJiAhdGhpcy5fdGVtcGxhdGUuX19wb2x5bWVyRmluYWxpemVkKSB7XG4gICAgICAgICAgdGhpcy5fdGVtcGxhdGUuX19wb2x5bWVyRmluYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgICBjb25zdCBiYXNlVVJJID1cbiAgICAgICAgICAgIGltcG9ydFBhdGggPyBQb2x5bWVyLlJlc29sdmVVcmwucmVzb2x2ZVVybChpbXBvcnRQYXRoKSA6ICcnO1xuICAgICAgICAgIGZpbmFsaXplVGVtcGxhdGUoLyoqIEB0eXBlIHshUG9seW1lckVsZW1lbnR9ICovKHRoaXMuX19wcm90b19fKSwgdGhpcy5fdGVtcGxhdGUsIGJhc2VVUkksXG4gICAgICAgICAgICAvKipAdHlwZSB7IUhUTUxFbGVtZW50fSovKHRoaXMpLmxvY2FsTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIuX2luaXRpYWxpemVQcm9wZXJ0aWVzKCk7XG4gICAgICAgIC8vIHNldCBwYXRoIGRlZmF1bHRzXG4gICAgICAgIHRoaXMucm9vdFBhdGggPSBQb2x5bWVyLnJvb3RQYXRoO1xuICAgICAgICB0aGlzLmltcG9ydFBhdGggPSBpbXBvcnRQYXRoO1xuICAgICAgICAvLyBhcHBseSBwcm9wZXJ0eSBkZWZhdWx0cy4uLlxuICAgICAgICBsZXQgcCQgPSBwcm9wZXJ0eURlZmF1bHRzRm9yQ2xhc3ModGhpcy5jb25zdHJ1Y3Rvcik7XG4gICAgICAgIGlmICghcCQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgcCBpbiBwJCkge1xuICAgICAgICAgIGxldCBpbmZvID0gcCRbcF07XG4gICAgICAgICAgLy8gRG9uJ3Qgc2V0IGRlZmF1bHQgdmFsdWUgaWYgdGhlcmUgaXMgYWxyZWFkeSBhbiBvd24gcHJvcGVydHksIHdoaWNoXG4gICAgICAgICAgLy8gaGFwcGVucyB3aGVuIGEgYHByb3BlcnRpZXNgIHByb3BlcnR5IHdpdGggZGVmYXVsdCBidXQgbm8gZWZmZWN0cyBoYWRcbiAgICAgICAgICAvLyBhIHByb3BlcnR5IHNldCAoZS5nLiBib3VuZCkgYnkgaXRzIGhvc3QgYmVmb3JlIHVwZ3JhZGVcbiAgICAgICAgICBpZiAoIXRoaXMuaGFzT3duUHJvcGVydHkocCkpIHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IHR5cGVvZiBpbmZvLnZhbHVlID09ICdmdW5jdGlvbicgP1xuICAgICAgICAgICAgICBpbmZvLnZhbHVlLmNhbGwodGhpcykgOlxuICAgICAgICAgICAgICBpbmZvLnZhbHVlO1xuICAgICAgICAgICAgLy8gU2V0IHZpYSBgX3NldFByb3BlcnR5YCBpZiB0aGVyZSBpcyBhbiBhY2Nlc3NvciwgdG8gZW5hYmxlXG4gICAgICAgICAgICAvLyBpbml0aWFsaXppbmcgcmVhZE9ubHkgcHJvcGVydHkgZGVmYXVsdHNcbiAgICAgICAgICAgIGlmICh0aGlzLl9oYXNBY2Nlc3NvcihwKSkge1xuICAgICAgICAgICAgICB0aGlzLl9zZXRQZW5kaW5nUHJvcGVydHkocCwgdmFsdWUsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpc1twXSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFByb3ZpZGVzIGEgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgc3RhbmRhcmQgQ3VzdG9tIEVsZW1lbnRzXG4gICAgICAgKiBgY29ubmVjdGVkQ2FsbGJhY2tgLlxuICAgICAgICpcbiAgICAgICAqIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIGVuYWJsZXMgdGhlIHByb3BlcnR5IGVmZmVjdHMgc3lzdGVtIGFuZFxuICAgICAgICogZmx1c2hlcyBhbnkgcGVuZGluZyBwcm9wZXJ0aWVzLCBhbmQgdXBkYXRlcyBzaGltbWVkIENTUyBwcm9wZXJ0aWVzXG4gICAgICAgKiB3aGVuIHVzaW5nIHRoZSBTaGFkeUNTUyBzY29waW5nL2N1c3RvbSBwcm9wZXJ0aWVzIHBvbHlmaWxsLlxuICAgICAgICpcbiAgICAgICAqIEBzdXBwcmVzcyB7aW52YWxpZENhc3RzfVxuICAgICAgICovXG4gICAgICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgICAgaWYgKHdpbmRvdy5TaGFkeUNTUyAmJiB0aGlzLl90ZW1wbGF0ZSkge1xuICAgICAgICAgIHdpbmRvdy5TaGFkeUNTUy5zdHlsZUVsZW1lbnQoLyoqIEB0eXBlIHshSFRNTEVsZW1lbnR9ICovKHRoaXMpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9lbmFibGVQcm9wZXJ0aWVzKCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUHJvdmlkZXMgYSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIG9mIHRoZSBzdGFuZGFyZCBDdXN0b20gRWxlbWVudHNcbiAgICAgICAqIGBkaXNjb25uZWN0ZWRDYWxsYmFja2AuXG4gICAgICAgKi9cbiAgICAgIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge31cblxuICAgICAgLyoqXG4gICAgICAgKiBTdGFtcHMgdGhlIGVsZW1lbnQgdGVtcGxhdGUuXG4gICAgICAgKlxuICAgICAgICogQG92ZXJyaWRlXG4gICAgICAgKi9cbiAgICAgIHJlYWR5KCkge1xuICAgICAgICBpZiAodGhpcy5fdGVtcGxhdGUpIHtcbiAgICAgICAgICB0aGlzLnJvb3QgPSB0aGlzLl9zdGFtcFRlbXBsYXRlKHRoaXMuX3RlbXBsYXRlKTtcbiAgICAgICAgICB0aGlzLiQgPSB0aGlzLnJvb3QuJDtcbiAgICAgICAgfVxuICAgICAgICBzdXBlci5yZWFkeSgpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEltcGxlbWVudHMgYFByb3BlcnR5RWZmZWN0c2AncyBgX3JlYWR5Q2xpZW50c2AgY2FsbC4gQXR0YWNoZXNcbiAgICAgICAqIGVsZW1lbnQgZG9tIGJ5IGNhbGxpbmcgYF9hdHRhY2hEb21gIHdpdGggdGhlIGRvbSBzdGFtcGVkIGZyb20gdGhlXG4gICAgICAgKiBlbGVtZW50J3MgdGVtcGxhdGUgdmlhIGBfc3RhbXBUZW1wbGF0ZWAuIE5vdGUgdGhhdCB0aGlzIGFsbG93c1xuICAgICAgICogY2xpZW50IGRvbSB0byBiZSBhdHRhY2hlZCB0byB0aGUgZWxlbWVudCBwcmlvciB0byBhbnkgb2JzZXJ2ZXJzXG4gICAgICAgKiBydW5uaW5nLlxuICAgICAgICpcbiAgICAgICAqIEBvdmVycmlkZVxuICAgICAgICovXG4gICAgICBfcmVhZHlDbGllbnRzKCkge1xuICAgICAgICBpZiAodGhpcy5fdGVtcGxhdGUpIHtcbiAgICAgICAgICB0aGlzLnJvb3QgPSB0aGlzLl9hdHRhY2hEb20odGhpcy5yb290KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGUgc3VwZXIuX3JlYWR5Q2xpZW50cyBoZXJlIHNldHMgdGhlIGNsaWVudHMgaW5pdGlhbGl6ZWQgZmxhZy5cbiAgICAgICAgLy8gV2UgbXVzdCB3YWl0IHRvIGRvIHRoaXMgdW50aWwgYWZ0ZXIgY2xpZW50IGRvbSBpcyBjcmVhdGVkL2F0dGFjaGVkXG4gICAgICAgIC8vIHNvIHRoYXQgdGhpcyBmbGFnIGNhbiBiZSBjaGVja2VkIHRvIHByZXZlbnQgbm90aWZpY2F0aW9ucyBmaXJlZFxuICAgICAgICAvLyBkdXJpbmcgdGhpcyBwcm9jZXNzIGZyb20gYmVpbmcgaGFuZGxlZCBiZWZvcmUgY2xpZW50cyBhcmUgcmVhZHkuXG4gICAgICAgIHN1cGVyLl9yZWFkeUNsaWVudHMoKTtcbiAgICAgIH1cblxuXG4gICAgICAvKipcbiAgICAgICAqIEF0dGFjaGVzIGFuIGVsZW1lbnQncyBzdGFtcGVkIGRvbSB0byBpdHNlbGYuIEJ5IGRlZmF1bHQsXG4gICAgICAgKiB0aGlzIG1ldGhvZCBjcmVhdGVzIGEgYHNoYWRvd1Jvb3RgIGFuZCBhZGRzIHRoZSBkb20gdG8gaXQuXG4gICAgICAgKiBIb3dldmVyLCB0aGlzIG1ldGhvZCBtYXkgYmUgb3ZlcnJpZGRlbiB0byBhbGxvdyBhbiBlbGVtZW50XG4gICAgICAgKiB0byBwdXQgaXRzIGRvbSBpbiBhbm90aGVyIGxvY2F0aW9uLlxuICAgICAgICpcbiAgICAgICAqIEB0aHJvd3Mge0Vycm9yfVxuICAgICAgICogQHN1cHByZXNzIHttaXNzaW5nUmV0dXJufVxuICAgICAgICogQHBhcmFtIHtOb2RlTGlzdH0gZG9tIHRvIGF0dGFjaCB0byB0aGUgZWxlbWVudC5cbiAgICAgICAqIEByZXR1cm4ge05vZGV9IG5vZGUgdG8gd2hpY2ggdGhlIGRvbSBoYXMgYmVlbiBhdHRhY2hlZC5cbiAgICAgICAqL1xuICAgICAgX2F0dGFjaERvbShkb20pIHtcbiAgICAgICAgaWYgKHRoaXMuYXR0YWNoU2hhZG93KSB7XG4gICAgICAgICAgaWYgKGRvbSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnNoYWRvd1Jvb3QpIHtcbiAgICAgICAgICAgICAgdGhpcy5hdHRhY2hTaGFkb3coe21vZGU6ICdvcGVuJ30pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zaGFkb3dSb290LmFwcGVuZENoaWxkKGRvbSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zaGFkb3dSb290O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NoYWRvd0RPTSBub3QgYXZhaWxhYmxlLiAnICtcbiAgICAgICAgICAgIC8vIFRPRE8oc29ydmVsbCk6IG1vdmUgdG8gY29tcGlsZS10aW1lIGNvbmRpdGlvbmFsIHdoZW4gc3VwcG9ydGVkXG4gICAgICAgICAgJ1BvbHltZXIuRWxlbWVudCBjYW4gY3JlYXRlIGRvbSBhcyBjaGlsZHJlbiBpbnN0ZWFkIG9mIGluICcgK1xuICAgICAgICAgICdTaGFkb3dET00gYnkgc2V0dGluZyBgdGhpcy5yb290ID0gdGhpcztcXGAgYmVmb3JlIFxcYHJlYWR5XFxgLicpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUHJvdmlkZXMgYSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIG9mIHRoZSBzdGFuZGFyZCBDdXN0b20gRWxlbWVudHNcbiAgICAgICAqIGBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2tgLlxuICAgICAgICpcbiAgICAgICAqIEJ5IGRlZmF1bHQsIGF0dHJpYnV0ZXMgZGVjbGFyZWQgaW4gYHByb3BlcnRpZXNgIG1ldGFkYXRhIGFyZVxuICAgICAgICogZGVzZXJpYWxpemVkIHVzaW5nIHRoZWlyIGB0eXBlYCBpbmZvcm1hdGlvbiB0byBwcm9wZXJ0aWVzIG9mIHRoZVxuICAgICAgICogc2FtZSBuYW1lLiAgXCJEYXNoLWNhc2VkXCIgYXR0cmlidXRlcyBhcmUgZGVzZXJpYWx6ZWQgdG8gXCJjYW1lbENhc2VcIlxuICAgICAgICogcHJvcGVydGllcy5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBOYW1lIG9mIGF0dHJpYnV0ZS5cbiAgICAgICAqIEBwYXJhbSB7P3N0cmluZ30gb2xkIE9sZCB2YWx1ZSBvZiBhdHRyaWJ1dGUuXG4gICAgICAgKiBAcGFyYW0gez9zdHJpbmd9IHZhbHVlIEN1cnJlbnQgdmFsdWUgb2YgYXR0cmlidXRlLlxuICAgICAgICogQG92ZXJyaWRlXG4gICAgICAgKi9cbiAgICAgIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBvbGQsIHZhbHVlKSB7XG4gICAgICAgIGlmIChvbGQgIT09IHZhbHVlKSB7XG4gICAgICAgICAgbGV0IHByb3BlcnR5ID0gY2FzZU1hcC5kYXNoVG9DYW1lbENhc2UobmFtZSk7XG4gICAgICAgICAgbGV0IHR5cGUgPSBwcm9wZXJ0aWVzRm9yQ2xhc3ModGhpcy5jb25zdHJ1Y3RvcilbcHJvcGVydHldLnR5cGU7XG4gICAgICAgICAgaWYgKCF0aGlzLl9oYXNSZWFkT25seUVmZmVjdChwcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgIHRoaXMuX2F0dHJpYnV0ZVRvUHJvcGVydHkobmFtZSwgdmFsdWUsIHR5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFdoZW4gdXNpbmcgdGhlIFNoYWR5Q1NTIHNjb3BpbmcgYW5kIGN1c3RvbSBwcm9wZXJ0eSBzaGltLCBjYXVzZXMgYWxsXG4gICAgICAgKiBzaGltbWVkIHN0eWxlcyBpbiB0aGlzIGVsZW1lbnQgKGFuZCBpdHMgc3VidHJlZSkgdG8gYmUgdXBkYXRlZFxuICAgICAgICogYmFzZWQgb24gY3VycmVudCBjdXN0b20gcHJvcGVydHkgdmFsdWVzLlxuICAgICAgICpcbiAgICAgICAqIFRoZSBvcHRpb25hbCBwYXJhbWV0ZXIgb3ZlcnJpZGVzIGlubGluZSBjdXN0b20gcHJvcGVydHkgc3R5bGVzIHdpdGggYW5cbiAgICAgICAqIG9iamVjdCBvZiBwcm9wZXJ0aWVzIHdoZXJlIHRoZSBrZXlzIGFyZSBDU1MgcHJvcGVydGllcywgYW5kIHRoZSB2YWx1ZXNcbiAgICAgICAqIGFyZSBzdHJpbmdzLlxuICAgICAgICpcbiAgICAgICAqIEV4YW1wbGU6IGB0aGlzLnVwZGF0ZVN0eWxlcyh7Jy0tY29sb3InOiAnYmx1ZSd9KWBcbiAgICAgICAqXG4gICAgICAgKiBUaGVzZSBwcm9wZXJ0aWVzIGFyZSByZXRhaW5lZCB1bmxlc3MgYSB2YWx1ZSBvZiBgbnVsbGAgaXMgc2V0LlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0PX0gcHJvcGVydGllcyBCYWcgb2YgY3VzdG9tIHByb3BlcnR5IGtleS92YWx1ZXMgdG9cbiAgICAgICAqICAgYXBwbHkgdG8gdGhpcyBlbGVtZW50LlxuICAgICAgICogQHN1cHByZXNzIHtpbnZhbGlkQ2FzdHN9XG4gICAgICAgKi9cbiAgICAgIHVwZGF0ZVN0eWxlcyhwcm9wZXJ0aWVzKSB7XG4gICAgICAgIGlmICh3aW5kb3cuU2hhZHlDU1MpIHtcbiAgICAgICAgICB3aW5kb3cuU2hhZHlDU1Muc3R5bGVTdWJ0cmVlKC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqLyh0aGlzKSwgcHJvcGVydGllcyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZXdyaXRlcyBhIGdpdmVuIFVSTCByZWxhdGl2ZSB0byBhIGJhc2UgVVJMLiBUaGUgYmFzZSBVUkwgZGVmYXVsdHMgdG9cbiAgICAgICAqIHRoZSBvcmlnaW5hbCBsb2NhdGlvbiBvZiB0aGUgZG9jdW1lbnQgY29udGFpbmluZyB0aGUgYGRvbS1tb2R1bGVgIGZvclxuICAgICAgICogdGhpcyBlbGVtZW50LiBUaGlzIG1ldGhvZCB3aWxsIHJldHVybiB0aGUgc2FtZSBVUkwgYmVmb3JlIGFuZCBhZnRlclxuICAgICAgICogYnVuZGxpbmcuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHVybCBVUkwgdG8gcmVzb2x2ZS5cbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nPX0gYmFzZSBPcHRpb25hbCBiYXNlIFVSTCB0byByZXNvbHZlIGFnYWluc3QsIGRlZmF1bHRzXG4gICAgICAgKiB0byB0aGUgZWxlbWVudCdzIGBpbXBvcnRQYXRoYFxuICAgICAgICogQHJldHVybiB7c3RyaW5nfSBSZXdyaXR0ZW4gVVJMIHJlbGF0aXZlIHRvIGJhc2VcbiAgICAgICAqL1xuICAgICAgcmVzb2x2ZVVybCh1cmwsIGJhc2UpIHtcbiAgICAgICAgaWYgKCFiYXNlICYmIHRoaXMuaW1wb3J0UGF0aCkge1xuICAgICAgICAgIGJhc2UgPSBQb2x5bWVyLlJlc29sdmVVcmwucmVzb2x2ZVVybCh0aGlzLmltcG9ydFBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQb2x5bWVyLlJlc29sdmVVcmwucmVzb2x2ZVVybCh1cmwsIGJhc2UpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIE92ZXJyaWRlcyBgUHJvcGVydHlBY2Nlc3NvcnNgIHRvIGFkZCBtYXAgb2YgZHluYW1pYyBmdW5jdGlvbnMgb25cbiAgICAgICAqIHRlbXBsYXRlIGluZm8sIGZvciBjb25zdW1wdGlvbiBieSBgUHJvcGVydHlFZmZlY3RzYCB0ZW1wbGF0ZSBiaW5kaW5nXG4gICAgICAgKiBjb2RlLiBUaGlzIG1hcCBkZXRlcm1pbmVzIHdoaWNoIG1ldGhvZCB0ZW1wbGF0ZXMgc2hvdWxkIGhhdmUgYWNjZXNzb3JzXG4gICAgICAgKiBjcmVhdGVkIGZvciB0aGVtLlxuICAgICAgICpcbiAgICAgICAqIEBvdmVycmlkZVxuICAgICAgICogQHN1cHByZXNzIHttaXNzaW5nUHJvcGVydGllc30gSW50ZXJmYWNlcyBpbiBjbG9zdXJlIGRvIG5vdCBpbmhlcml0IHN0YXRpY3MsIGJ1dCBjbGFzc2VzIGRvXG4gICAgICAgKi9cbiAgICAgIHN0YXRpYyBfcGFyc2VUZW1wbGF0ZUNvbnRlbnQodGVtcGxhdGUsIHRlbXBsYXRlSW5mbywgbm9kZUluZm8pIHtcbiAgICAgICAgdGVtcGxhdGVJbmZvLmR5bmFtaWNGbnMgPSB0ZW1wbGF0ZUluZm8uZHluYW1pY0ZucyB8fCBwcm9wZXJ0aWVzRm9yQ2xhc3ModGhpcyk7XG4gICAgICAgIHJldHVybiBzdXBlci5fcGFyc2VUZW1wbGF0ZUNvbnRlbnQodGVtcGxhdGUsIHRlbXBsYXRlSW5mbywgbm9kZUluZm8pO1xuICAgICAgfVxuXG4gICAgfVxuXG4gICAgcmV0dXJuIFBvbHltZXJFbGVtZW50O1xuICB9KTtcblxuICAvKipcbiAgICogUHJvdmlkZXMgYmFzaWMgdHJhY2tpbmcgb2YgZWxlbWVudCBkZWZpbml0aW9ucyAocmVnaXN0cmF0aW9ucykgYW5kXG4gICAqIGluc3RhbmNlIGNvdW50cy5cbiAgICpcbiAgICogQG5hbWVzcGFjZVxuICAgKiBAc3VtbWFyeSBQcm92aWRlcyBiYXNpYyB0cmFja2luZyBvZiBlbGVtZW50IGRlZmluaXRpb25zIChyZWdpc3RyYXRpb25zKSBhbmRcbiAgICogaW5zdGFuY2UgY291bnRzLlxuICAgKi9cbiAgUG9seW1lci50ZWxlbWV0cnkgPSB7XG4gICAgLyoqXG4gICAgICogVG90YWwgbnVtYmVyIG9mIFBvbHltZXIgZWxlbWVudCBpbnN0YW5jZXMgY3JlYXRlZC5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIGluc3RhbmNlQ291bnQ6IDAsXG4gICAgLyoqXG4gICAgICogQXJyYXkgb2YgUG9seW1lciBlbGVtZW50IGNsYXNzZXMgdGhhdCBoYXZlIGJlZW4gZmluYWxpemVkLlxuICAgICAqIEB0eXBlIHtBcnJheTxQb2x5bWVyLkVsZW1lbnQ+fVxuICAgICAqL1xuICAgIHJlZ2lzdHJhdGlvbnM6IFtdLFxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IVBvbHltZXJFbGVtZW50Q29uc3RydWN0b3J9IHByb3RvdHlwZSBFbGVtZW50IHByb3RvdHlwZSB0byBsb2dcbiAgICAgKiBAdGhpcyB7dGhpc31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZWdMb2c6IGZ1bmN0aW9uKHByb3RvdHlwZSkge1xuICAgICAgY29uc29sZS5sb2coJ1snICsgcHJvdG90eXBlLmlzICsgJ106IHJlZ2lzdGVyZWQnKVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIGEgY2xhc3MgcHJvdG90eXBlIGZvciB0ZWxlbWV0cnkgcHVycG9zZXMuXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcHJvdG90eXBlIEVsZW1lbnQgcHJvdG90eXBlIHRvIHJlZ2lzdGVyXG4gICAgICogQHRoaXMge3RoaXN9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHJlZ2lzdGVyOiBmdW5jdGlvbihwcm90b3R5cGUpIHtcbiAgICAgIHRoaXMucmVnaXN0cmF0aW9ucy5wdXNoKHByb3RvdHlwZSk7XG4gICAgICBQb2x5bWVyLmxvZyAmJiB0aGlzLl9yZWdMb2cocHJvdG90eXBlKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIExvZ3MgYWxsIGVsZW1lbnRzIHJlZ2lzdGVyZWQgd2l0aCBhbiBgaXNgIHRvIHRoZSBjb25zb2xlLlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAdGhpcyB7dGhpc31cbiAgICAgKi9cbiAgICBkdW1wUmVnaXN0cmF0aW9uczogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnJlZ2lzdHJhdGlvbnMuZm9yRWFjaCh0aGlzLl9yZWdMb2cpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogV2hlbiB1c2luZyB0aGUgU2hhZHlDU1Mgc2NvcGluZyBhbmQgY3VzdG9tIHByb3BlcnR5IHNoaW0sIGNhdXNlcyBhbGxcbiAgICogc2hpbW1lZCBgc3R5bGVzYCAodmlhIGBjdXN0b20tc3R5bGVgKSBpbiB0aGUgZG9jdW1lbnQgKGFuZCBpdHMgc3VidHJlZSlcbiAgICogdG8gYmUgdXBkYXRlZCBiYXNlZCBvbiBjdXJyZW50IGN1c3RvbSBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAqXG4gICAqIFRoZSBvcHRpb25hbCBwYXJhbWV0ZXIgb3ZlcnJpZGVzIGlubGluZSBjdXN0b20gcHJvcGVydHkgc3R5bGVzIHdpdGggYW5cbiAgICogb2JqZWN0IG9mIHByb3BlcnRpZXMgd2hlcmUgdGhlIGtleXMgYXJlIENTUyBwcm9wZXJ0aWVzLCBhbmQgdGhlIHZhbHVlc1xuICAgKiBhcmUgc3RyaW5ncy5cbiAgICpcbiAgICogRXhhbXBsZTogYFBvbHltZXIudXBkYXRlU3R5bGVzKHsnLS1jb2xvcic6ICdibHVlJ30pYFxuICAgKlxuICAgKiBUaGVzZSBwcm9wZXJ0aWVzIGFyZSByZXRhaW5lZCB1bmxlc3MgYSB2YWx1ZSBvZiBgbnVsbGAgaXMgc2V0LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdD19IHByb3BzIEJhZyBvZiBjdXN0b20gcHJvcGVydHkga2V5L3ZhbHVlcyB0b1xuICAgKiAgIGFwcGx5IHRvIHRoZSBkb2N1bWVudC5cbiAgICovXG4gIFBvbHltZXIudXBkYXRlU3R5bGVzID0gZnVuY3Rpb24ocHJvcHMpIHtcbiAgICBpZiAod2luZG93LlNoYWR5Q1NTKSB7XG4gICAgICB3aW5kb3cuU2hhZHlDU1Muc3R5bGVEb2N1bWVudChwcm9wcyk7XG4gICAgfVxuICB9O1xuXG59KSgpO1xuPC9zY3JpcHQ+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL3BvbHltZXIvbGliL21peGlucy9lbGVtZW50LW1peGluLmh0bWwiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi91dGlscy9ib290Lmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi91dGlscy9yZXNvbHZlLXVybC5odG1sXCI+XG5cbjxzY3JpcHQ+XG4vKiogQHN1cHByZXNzIHtkZXByZWNhdGVkfSAqL1xuKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLyoqXG4gICAqIExlZ2FjeSBzZXR0aW5ncy5cbiAgICogQG5hbWVzcGFjZVxuICAgKiBAbWVtYmVyb2YgUG9seW1lclxuICAgKi9cbiAgY29uc3Qgc2V0dGluZ3MgPSBQb2x5bWVyLlNldHRpbmdzIHx8IHt9O1xuICBzZXR0aW5ncy51c2VTaGFkb3cgPSAhKHdpbmRvdy5TaGFkeURPTSk7XG4gIHNldHRpbmdzLnVzZU5hdGl2ZUNTU1Byb3BlcnRpZXMgPVxuICAgIEJvb2xlYW4oIXdpbmRvdy5TaGFkeUNTUyB8fCB3aW5kb3cuU2hhZHlDU1MubmF0aXZlQ3NzKTtcbiAgc2V0dGluZ3MudXNlTmF0aXZlQ3VzdG9tRWxlbWVudHMgPVxuICAgICEod2luZG93LmN1c3RvbUVsZW1lbnRzLnBvbHlmaWxsV3JhcEZsdXNoQ2FsbGJhY2spO1xuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBnbG9iYWwsIGxlZ2FjeSBzZXR0aW5ncy5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWRcbiAgICogQG1lbWJlcm9mIFBvbHltZXJcbiAgICovXG4gIFBvbHltZXIuU2V0dGluZ3MgPSBzZXR0aW5ncztcblxuICAvKipcbiAgICogR2xvYmFsbHkgc2V0dGFibGUgcHJvcGVydHkgdGhhdCBpcyBhdXRvbWF0aWNhbGx5IGFzc2lnbmVkIHRvXG4gICAqIGBQb2x5bWVyLkVsZW1lbnRNaXhpbmAgaW5zdGFuY2VzLCB1c2VmdWwgZm9yIGJpbmRpbmcgaW4gdGVtcGxhdGVzIHRvXG4gICAqIG1ha2UgVVJMJ3MgcmVsYXRpdmUgdG8gYW4gYXBwbGljYXRpb24ncyByb290LiAgRGVmYXVsdHMgdG8gdGhlIG1haW5cbiAgICogZG9jdW1lbnQgVVJMLCBidXQgY2FuIGJlIG92ZXJyaWRkZW4gYnkgdXNlcnMuICBJdCBtYXkgYmUgdXNlZnVsIHRvIHNldFxuICAgKiBgUG9seW1lci5yb290UGF0aGAgdG8gcHJvdmlkZSBhIHN0YWJsZSBhcHBsaWNhdGlvbiBtb3VudCBwYXRoIHdoZW5cbiAgICogdXNpbmcgY2xpZW50IHNpZGUgcm91dGluZy5cbiAgICpcbiAgICogQG1lbWJlcm9mIFBvbHltZXJcbiAgICovXG4gIGxldCByb290UGF0aCA9IFBvbHltZXIucm9vdFBhdGggfHxcbiAgICBQb2x5bWVyLlJlc29sdmVVcmwucGF0aEZyb21VcmwoZG9jdW1lbnQuYmFzZVVSSSB8fCB3aW5kb3cubG9jYXRpb24uaHJlZik7XG5cbiAgUG9seW1lci5yb290UGF0aCA9IHJvb3RQYXRoO1xuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBnbG9iYWwgcm9vdFBhdGggcHJvcGVydHkgdXNlZCBieSBgUG9seW1lci5FbGVtZW50TWl4aW5gIGFuZFxuICAgKiBhdmFpbGFibGUgdmlhIGBQb2x5bWVyLnJvb3RQYXRoYC5cbiAgICpcbiAgICogQG1lbWJlcm9mIFBvbHltZXJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggVGhlIG5ldyByb290IHBhdGhcbiAgICovXG4gIFBvbHltZXIuc2V0Um9vdFBhdGggPSBmdW5jdGlvbihwYXRoKSB7XG4gICAgUG9seW1lci5yb290UGF0aCA9IHBhdGg7XG4gIH1cbn0pKCk7XG48L3NjcmlwdD5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL3BvbHltZXIvbGliL3V0aWxzL3NldHRpbmdzLmh0bWwiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwicmVzb2x2ZS11cmwuaHRtbFwiPlxuPHNjcmlwdD5cbihmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIGNvbnN0IE1PRFVMRV9TVFlMRV9MSU5LX1NFTEVDVE9SID0gJ2xpbmtbcmVsPWltcG9ydF1bdHlwZX49Y3NzXSc7XG4gIGNvbnN0IElOQ0xVREVfQVRUUiA9ICdpbmNsdWRlJztcblxuICBmdW5jdGlvbiBpbXBvcnRNb2R1bGUobW9kdWxlSWQpIHtcbiAgICBpZiAoIVBvbHltZXIuRG9tTW9kdWxlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIFBvbHltZXIuRG9tTW9kdWxlLmltcG9ydChtb2R1bGVJZCk7XG4gIH1cblxuICAvKiogQHR5cGVkZWYge3thc3NldHBhdGg6IHN0cmluZ319ICovXG4gIGxldCB0ZW1wbGF0ZVdpdGhBc3NldFBhdGg7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblxuICAvKipcbiAgICogTW9kdWxlIHdpdGggdXRpbGl0aWVzIGZvciBjb2xsZWN0aW9uIENTUyB0ZXh0IGZyb20gYDx0ZW1wbGF0ZXM+YCwgZXh0ZXJuYWxcbiAgICogc3R5bGVzaGVldHMsIGFuZCBgZG9tLW1vZHVsZWBzLlxuICAgKlxuICAgKiBAbmFtZXNwYWNlXG4gICAqIEBtZW1iZXJvZiBQb2x5bWVyXG4gICAqIEBzdW1tYXJ5IE1vZHVsZSB3aXRoIHV0aWxpdGllcyBmb3IgY29sbGVjdGlvbiBDU1MgdGV4dCBmcm9tIHZhcmlvdXMgc291cmNlcy5cbiAgICovXG4gIGNvbnN0IFN0eWxlR2F0aGVyID0ge1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBDU1MgdGV4dCBvZiBzdHlsZXMgaW4gYSBzcGFjZS1zZXBhcmF0ZWQgbGlzdCBvZiBgZG9tLW1vZHVsZWBzLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIFBvbHltZXIuU3R5bGVHYXRoZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbW9kdWxlSWRzIExpc3Qgb2YgZG9tLW1vZHVsZSBpZCdzIHdpdGhpbiB3aGljaCB0b1xuICAgICAqIHNlYXJjaCBmb3IgY3NzLlxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gQ29uY2F0ZW5hdGVkIENTUyBjb250ZW50IGZyb20gc3BlY2lmaWVkIGBkb20tbW9kdWxlYHNcbiAgICAgKiBAdGhpcyB7U3R5bGVHYXRoZXJ9XG4gICAgICovXG4gICAgY3NzRnJvbU1vZHVsZXMobW9kdWxlSWRzKSB7XG4gICAgICBsZXQgbW9kdWxlcyA9IG1vZHVsZUlkcy50cmltKCkuc3BsaXQoJyAnKTtcbiAgICAgIGxldCBjc3NUZXh0ID0gJyc7XG4gICAgICBmb3IgKGxldCBpPTA7IGkgPCBtb2R1bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNzc1RleHQgKz0gdGhpcy5jc3NGcm9tTW9kdWxlKG1vZHVsZXNbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNzc1RleHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgQ1NTIHRleHQgb2Ygc3R5bGVzIGluIGEgZ2l2ZW4gYGRvbS1tb2R1bGVgLiAgQ1NTIGluIGEgYGRvbS1tb2R1bGVgXG4gICAgICogY2FuIGNvbWUgZWl0aGVyIGZyb20gYDxzdHlsZT5gcyB3aXRoaW4gdGhlIGZpcnN0IGA8dGVtcGxhdGU+YCwgb3IgZWxzZVxuICAgICAqIGZyb20gb25lIG9yIG1vcmUgYDxsaW5rIHJlbD1cImltcG9ydFwiIHR5cGU9XCJjc3NcIj5gIGxpbmtzIG91dHNpZGUgdGhlXG4gICAgICogdGVtcGxhdGUuXG4gICAgICpcbiAgICAgKiBBbnkgYDxzdHlsZXM+YCBwcm9jZXNzZWQgYXJlIHJlbW92ZWQgZnJvbSB0aGVpciBvcmlnaW5hbCBsb2NhdGlvbi5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBQb2x5bWVyLlN0eWxlR2F0aGVyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1vZHVsZUlkIGRvbS1tb2R1bGUgaWQgdG8gZ2F0aGVyIHN0eWxlcyBmcm9tXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBDb25jYXRlbmF0ZWQgQ1NTIGNvbnRlbnQgZnJvbSBzcGVjaWZpZWQgYGRvbS1tb2R1bGVgXG4gICAgICogQHRoaXMge1N0eWxlR2F0aGVyfVxuICAgICAqL1xuICAgIGNzc0Zyb21Nb2R1bGUobW9kdWxlSWQpIHtcbiAgICAgIGxldCBtID0gaW1wb3J0TW9kdWxlKG1vZHVsZUlkKTtcbiAgICAgIGlmIChtICYmIG0uX2Nzc1RleHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgY3NzVGV4dCA9ICcnO1xuICAgICAgICAvLyBpbmNsdWRlIGNzcyBmcm9tIHRoZSBmaXJzdCB0ZW1wbGF0ZSBpbiB0aGUgbW9kdWxlXG4gICAgICAgIGxldCB0ID0gbS5xdWVyeVNlbGVjdG9yKCd0ZW1wbGF0ZScpO1xuICAgICAgICBpZiAodCkge1xuICAgICAgICAgIGNzc1RleHQgKz0gdGhpcy5jc3NGcm9tVGVtcGxhdGUodCwgLyoqIEB0eXBlIHt0ZW1wbGF0ZVdpdGhBc3NldFBhdGggfSovKG0pLmFzc2V0cGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbW9kdWxlIGltcG9ydHM6IDxsaW5rIHJlbD1cImltcG9ydFwiIHR5cGU9XCJjc3NcIj5cbiAgICAgICAgY3NzVGV4dCArPSB0aGlzLmNzc0Zyb21Nb2R1bGVJbXBvcnRzKG1vZHVsZUlkKTtcbiAgICAgICAgbS5fY3NzVGV4dCA9IGNzc1RleHQgfHwgbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmICghbSkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0NvdWxkIG5vdCBmaW5kIHN0eWxlIGRhdGEgaW4gbW9kdWxlIG5hbWVkJywgbW9kdWxlSWQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG0gJiYgbS5fY3NzVGV4dCB8fCAnJztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBDU1MgdGV4dCBvZiBgPHN0eWxlcz5gIHdpdGhpbiBhIGdpdmVuIHRlbXBsYXRlLlxuICAgICAqXG4gICAgICogQW55IGA8c3R5bGVzPmAgcHJvY2Vzc2VkIGFyZSByZW1vdmVkIGZyb20gdGhlaXIgb3JpZ2luYWwgbG9jYXRpb24uXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgUG9seW1lci5TdHlsZUdhdGhlclxuICAgICAqIEBwYXJhbSB7SFRNTFRlbXBsYXRlRWxlbWVudH0gdGVtcGxhdGUgVGVtcGxhdGUgdG8gZ2F0aGVyIHN0eWxlcyBmcm9tXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGJhc2VVUkkgQmFzZSBVUkkgdG8gcmVzb2x2ZSB0aGUgVVJMIGFnYWluc3RcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IENvbmNhdGVuYXRlZCBDU1MgY29udGVudCBmcm9tIHNwZWNpZmllZCB0ZW1wbGF0ZVxuICAgICAqIEB0aGlzIHtTdHlsZUdhdGhlcn1cbiAgICAgKi9cbiAgICBjc3NGcm9tVGVtcGxhdGUodGVtcGxhdGUsIGJhc2VVUkkpIHtcbiAgICAgIGxldCBjc3NUZXh0ID0gJyc7XG4gICAgICAvLyBpZiBlbGVtZW50IGlzIGEgdGVtcGxhdGUsIGdldCBjb250ZW50IGZyb20gaXRzIC5jb250ZW50XG4gICAgICBsZXQgZSQgPSB0ZW1wbGF0ZS5jb250ZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ3N0eWxlJyk7XG4gICAgICBmb3IgKGxldCBpPTA7IGkgPCBlJC5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgZSA9IGUkW2ldO1xuICAgICAgICAvLyBzdXBwb3J0IHN0eWxlIHNoYXJpbmcgYnkgYWxsb3dpbmcgc3R5bGVzIHRvIFwiaW5jbHVkZVwiXG4gICAgICAgIC8vIG90aGVyIGRvbS1tb2R1bGVzIHRoYXQgY29udGFpbiBzdHlsaW5nXG4gICAgICAgIGxldCBpbmNsdWRlID0gZS5nZXRBdHRyaWJ1dGUoSU5DTFVERV9BVFRSKTtcbiAgICAgICAgaWYgKGluY2x1ZGUpIHtcbiAgICAgICAgICBjc3NUZXh0ICs9IHRoaXMuY3NzRnJvbU1vZHVsZXMoaW5jbHVkZSk7XG4gICAgICAgIH1cbiAgICAgICAgZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGUpO1xuICAgICAgICBjc3NUZXh0ICs9IGJhc2VVUkkgP1xuICAgICAgICAgIFBvbHltZXIuUmVzb2x2ZVVybC5yZXNvbHZlQ3NzKGUudGV4dENvbnRlbnQsIGJhc2VVUkkpIDogZS50ZXh0Q29udGVudDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjc3NUZXh0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIENTUyB0ZXh0IGZyb20gc3R5bHNoZWV0cyBsb2FkZWQgdmlhIGA8bGluayByZWw9XCJpbXBvcnRcIiB0eXBlPVwiY3NzXCI+YFxuICAgICAqIGxpbmtzIHdpdGhpbiB0aGUgc3BlY2lmaWVkIGBkb20tbW9kdWxlYC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBQb2x5bWVyLlN0eWxlR2F0aGVyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1vZHVsZUlkIElkIG9mIGBkb20tbW9kdWxlYCB0byBnYXRoZXIgQ1NTIGZyb21cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IENvbmNhdGVuYXRlZCBDU1MgY29udGVudCBmcm9tIGxpbmtzIGluIHNwZWNpZmllZCBgZG9tLW1vZHVsZWBcbiAgICAgKiBAdGhpcyB7U3R5bGVHYXRoZXJ9XG4gICAgICovXG4gICAgY3NzRnJvbU1vZHVsZUltcG9ydHMobW9kdWxlSWQpIHtcbiAgICAgIGxldCBjc3NUZXh0ID0gJyc7XG4gICAgICBsZXQgbSA9IGltcG9ydE1vZHVsZShtb2R1bGVJZCk7XG4gICAgICBpZiAoIW0pIHtcbiAgICAgICAgcmV0dXJuIGNzc1RleHQ7XG4gICAgICB9XG4gICAgICBsZXQgcCQgPSBtLnF1ZXJ5U2VsZWN0b3JBbGwoTU9EVUxFX1NUWUxFX0xJTktfU0VMRUNUT1IpO1xuICAgICAgZm9yIChsZXQgaT0wOyBpIDwgcCQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IHAgPSBwJFtpXTtcbiAgICAgICAgaWYgKHAuaW1wb3J0KSB7XG4gICAgICAgICAgbGV0IGltcG9ydERvYyA9IHAuaW1wb3J0O1xuICAgICAgICAgIC8vIE5PVEU6IHBvbHlmaWxsIGFmZm9yZGFuY2UuXG4gICAgICAgICAgLy8gdW5kZXIgdGhlIEhUTUxJbXBvcnRzIHBvbHlmaWxsLCB0aGVyZSB3aWxsIGJlIG5vICdib2R5JyxcbiAgICAgICAgICAvLyBidXQgdGhlIGltcG9ydCBwc2V1ZG8tZG9jIGNhbiBiZSB1c2VkIGRpcmVjdGx5LlxuICAgICAgICAgIGxldCBjb250YWluZXIgPSBpbXBvcnREb2MuYm9keSA/IGltcG9ydERvYy5ib2R5IDogaW1wb3J0RG9jO1xuICAgICAgICAgIGNzc1RleHQgKz1cbiAgICAgICAgICAgIFBvbHltZXIuUmVzb2x2ZVVybC5yZXNvbHZlQ3NzKGNvbnRhaW5lci50ZXh0Q29udGVudCxcbiAgICAgICAgICAgICAgaW1wb3J0RG9jLmJhc2VVUkkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gY3NzVGV4dDtcbiAgICB9XG4gIH07XG5cbiAgUG9seW1lci5TdHlsZUdhdGhlciA9IFN0eWxlR2F0aGVyO1xufSkoKTtcbjwvc2NyaXB0PlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi91dGlscy9zdHlsZS1nYXRoZXIuaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cblxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uLy4uLy4uL3NoYWR5Y3NzL2FwcGx5LXNoaW0uaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL21peGlucy9lbGVtZW50LW1peGluLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi9taXhpbnMvZ2VzdHVyZS1ldmVudC1saXN0ZW5lcnMuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3V0aWxzL21peGluLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi91dGlscy9pbXBvcnQtaHJlZi5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vdXRpbHMvcmVuZGVyLXN0YXR1cy5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vdXRpbHMvdW5yZXNvbHZlZC5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwicG9seW1lci5kb20uaHRtbFwiPlxuXG48c2NyaXB0PlxuKGZ1bmN0aW9uKCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICBsZXQgc3R5bGVJbnRlcmZhY2UgPSB3aW5kb3cuU2hhZHlDU1M7XG5cbiAgLyoqXG4gICAqIEVsZW1lbnQgY2xhc3MgbWl4aW4gdGhhdCBwcm92aWRlcyBQb2x5bWVyJ3MgXCJsZWdhY3lcIiBBUEkgaW50ZW5kZWQgdG8gYmVcbiAgICogYmFja3dhcmQtY29tcGF0aWJsZSB0byB0aGUgZ3JlYXRlc3QgZXh0ZW50IHBvc3NpYmxlIHdpdGggdGhlIEFQSVxuICAgKiBmb3VuZCBvbiB0aGUgUG9seW1lciAxLnggYFBvbHltZXIuQmFzZWAgcHJvdG90eXBlIGFwcGxpZWQgdG8gYWxsIGVsZW1lbnRzXG4gICAqIGRlZmluZWQgdXNpbmcgdGhlIGBQb2x5bWVyKHsuLi59KWAgZnVuY3Rpb24uXG4gICAqXG4gICAqIEBtaXhpbkZ1bmN0aW9uXG4gICAqIEBwb2x5bWVyXG4gICAqIEBhcHBsaWVzTWl4aW4gUG9seW1lci5FbGVtZW50TWl4aW5cbiAgICogQGFwcGxpZXNNaXhpbiBQb2x5bWVyLkdlc3R1cmVFdmVudExpc3RlbmVyc1xuICAgKiBAcHJvcGVydHkgaXNBdHRhY2hlZCB7Ym9vbGVhbn0gU2V0IHRvIGB0cnVlYCBpbiB0aGlzIGVsZW1lbnQnc1xuICAgKiAgIGBjb25uZWN0ZWRDYWxsYmFja2AgYW5kIGBmYWxzZWAgaW4gYGRpc2Nvbm5lY3RlZENhbGxiYWNrYFxuICAgKiBAbWVtYmVyb2YgUG9seW1lclxuICAgKiBAc3VtbWFyeSBFbGVtZW50IGNsYXNzIG1peGluIHRoYXQgcHJvdmlkZXMgUG9seW1lcidzIFwibGVnYWN5XCIgQVBJXG4gICAqL1xuICBQb2x5bWVyLkxlZ2FjeUVsZW1lbnRNaXhpbiA9IFBvbHltZXIuZGVkdXBpbmdNaXhpbigoYmFzZSkgPT4ge1xuXG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQGV4dGVuZHMge2Jhc2V9XG4gICAgICogQGltcGxlbWVudHMge1BvbHltZXJfRWxlbWVudE1peGlufVxuICAgICAqIEBpbXBsZW1lbnRzIHtQb2x5bWVyX0dlc3R1cmVFdmVudExpc3RlbmVyc31cbiAgICAgKi9cbiAgICBjb25zdCBsZWdhY3lFbGVtZW50QmFzZSA9IFBvbHltZXIuR2VzdHVyZUV2ZW50TGlzdGVuZXJzKFBvbHltZXIuRWxlbWVudE1peGluKGJhc2UpKTtcblxuICAgIC8qKlxuICAgICAqIE1hcCBvZiBzaW1wbGUgbmFtZXMgdG8gdG91Y2ggYWN0aW9uIG5hbWVzXG4gICAgICogQGRpY3RcbiAgICAgKi9cbiAgICBjb25zdCBESVJFQ1RJT05fTUFQID0ge1xuICAgICAgJ3gnOiAncGFuLXgnLFxuICAgICAgJ3knOiAncGFuLXknLFxuICAgICAgJ25vbmUnOiAnbm9uZScsXG4gICAgICAnYWxsJzogJ2F1dG8nXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBwb2x5bWVyXG4gICAgICogQG1peGluQ2xhc3NcbiAgICAgKiBAZXh0ZW5kcyB7bGVnYWN5RWxlbWVudEJhc2V9XG4gICAgICogQGltcGxlbWVudHMge1BvbHltZXJfTGVnYWN5RWxlbWVudE1peGlufVxuICAgICAqIEB1bnJlc3RyaWN0ZWRcbiAgICAgKi9cbiAgICBjbGFzcyBMZWdhY3lFbGVtZW50IGV4dGVuZHMgbGVnYWN5RWxlbWVudEJhc2Uge1xuXG4gICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5yb290ID0gdGhpcztcbiAgICAgICAgdGhpcy5jcmVhdGVkKCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogTGVnYWN5IGNhbGxiYWNrIGNhbGxlZCBkdXJpbmcgdGhlIGBjb25zdHJ1Y3RvcmAsIGZvciBvdmVycmlkaW5nXG4gICAgICAgKiBieSB0aGUgdXNlci5cbiAgICAgICAqL1xuICAgICAgY3JlYXRlZCgpIHt9XG5cbiAgICAgIC8qKlxuICAgICAgICogUHJvdmlkZXMgYW4gaW1wbGVtZW50YXRpb24gb2YgYGNvbm5lY3RlZENhbGxiYWNrYFxuICAgICAgICogd2hpY2ggYWRkcyBQb2x5bWVyIGxlZ2FjeSBBUEkncyBgYXR0YWNoZWRgIG1ldGhvZC5cbiAgICAgICAqIEBvdmVycmlkZVxuICAgICAgICovXG4gICAgICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgICAgc3VwZXIuY29ubmVjdGVkQ2FsbGJhY2soKTtcbiAgICAgICAgdGhpcy5pc0F0dGFjaGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5hdHRhY2hlZCgpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIExlZ2FjeSBjYWxsYmFjayBjYWxsZWQgZHVyaW5nIGBjb25uZWN0ZWRDYWxsYmFja2AsIGZvciBvdmVycmlkaW5nXG4gICAgICAgKiBieSB0aGUgdXNlci5cbiAgICAgICAqL1xuICAgICAgYXR0YWNoZWQoKSB7fVxuXG4gICAgICAvKipcbiAgICAgICAqIFByb3ZpZGVzIGFuIGltcGxlbWVudGF0aW9uIG9mIGBkaXNjb25uZWN0ZWRDYWxsYmFja2BcbiAgICAgICAqIHdoaWNoIGFkZHMgUG9seW1lciBsZWdhY3kgQVBJJ3MgYGRldGFjaGVkYCBtZXRob2QuXG4gICAgICAgKiBAb3ZlcnJpZGVcbiAgICAgICAqL1xuICAgICAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgICAgIHN1cGVyLmRpc2Nvbm5lY3RlZENhbGxiYWNrKCk7XG4gICAgICAgIHRoaXMuaXNBdHRhY2hlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRldGFjaGVkKCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogTGVnYWN5IGNhbGxiYWNrIGNhbGxlZCBkdXJpbmcgYGRpc2Nvbm5lY3RlZENhbGxiYWNrYCwgZm9yIG92ZXJyaWRpbmdcbiAgICAgICAqIGJ5IHRoZSB1c2VyLlxuICAgICAgICovXG4gICAgICBkZXRhY2hlZCgpIHt9XG5cbiAgICAgIC8qKlxuICAgICAgICogUHJvdmlkZXMgYW4gb3ZlcnJpZGUgaW1wbGVtZW50YXRpb24gb2YgYGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFja2BcbiAgICAgICAqIHdoaWNoIGFkZHMgdGhlIFBvbHltZXIgbGVnYWN5IEFQSSdzIGBhdHRyaWJ1dGVDaGFuZ2VkYCBtZXRob2QuXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBOYW1lIG9mIGF0dHJpYnV0ZS5cbiAgICAgICAqIEBwYXJhbSB7P3N0cmluZ30gb2xkIE9sZCB2YWx1ZSBvZiBhdHRyaWJ1dGUuXG4gICAgICAgKiBAcGFyYW0gez9zdHJpbmd9IHZhbHVlIEN1cnJlbnQgdmFsdWUgb2YgYXR0cmlidXRlLlxuICAgICAgICogQG92ZXJyaWRlXG4gICAgICAgKi9cbiAgICAgIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBvbGQsIHZhbHVlKSB7XG4gICAgICAgIGlmIChvbGQgIT09IHZhbHVlKSB7XG4gICAgICAgICAgc3VwZXIuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIG9sZCwgdmFsdWUpO1xuICAgICAgICAgIHRoaXMuYXR0cmlidXRlQ2hhbmdlZChuYW1lLCBvbGQsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIExlZ2FjeSBjYWxsYmFjayBjYWxsZWQgZHVyaW5nIGBhdHRyaWJ1dGVDaGFuZ2VkQ2hhbGxiYWNrYCwgZm9yIG92ZXJyaWRpbmdcbiAgICAgICAqIGJ5IHRoZSB1c2VyLlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgTmFtZSBvZiBhdHRyaWJ1dGUuXG4gICAgICAgKiBAcGFyYW0gez9zdHJpbmd9IG9sZCBPbGQgdmFsdWUgb2YgYXR0cmlidXRlLlxuICAgICAgICogQHBhcmFtIHs/c3RyaW5nfSB2YWx1ZSBDdXJyZW50IHZhbHVlIG9mIGF0dHJpYnV0ZS5cbiAgICAgICAqL1xuICAgICAgYXR0cmlidXRlQ2hhbmdlZChuYW1lLCBvbGQsIHZhbHVlKSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cbiAgICAgIC8qKlxuICAgICAgICogT3ZlcnJpZGVzIHRoZSBkZWZhdWx0IGBQb2x5bWVyLlByb3BlcnR5RWZmZWN0c2AgaW1wbGVtZW50YXRpb24gdG9cbiAgICAgICAqIGFkZCBzdXBwb3J0IGZvciBjbGFzcyBpbml0aWFsaXphdGlvbiB2aWEgdGhlIGBfcmVnaXN0ZXJlZGAgY2FsbGJhY2suXG4gICAgICAgKiBUaGlzIGlzIGNhbGxlZCBvbmx5IHdoZW4gdGhlIGZpcnN0IGluc3RhbmNlIG9mIHRoZSBlbGVtZW50IGlzIGNyZWF0ZWQuXG4gICAgICAgKlxuICAgICAgICogQG92ZXJyaWRlXG4gICAgICAgKi9cbiAgICAgIF9pbml0aWFsaXplUHJvcGVydGllcygpIHtcbiAgICAgICAgbGV0IHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpO1xuICAgICAgICBpZiAoIXByb3RvLmhhc093blByb3BlcnR5KCdfX2hhc1JlZ2lzdGVyRmluaXNoZWQnKSkge1xuICAgICAgICAgIHByb3RvLl9faGFzUmVnaXN0ZXJGaW5pc2hlZCA9IHRydWU7XG4gICAgICAgICAgdGhpcy5fcmVnaXN0ZXJlZCgpO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyLl9pbml0aWFsaXplUHJvcGVydGllcygpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENhbGxlZCBhdXRvbWF0aWNhbGx5IHdoZW4gYW4gZWxlbWVudCBpcyBpbml0aWFsaXppbmcuXG4gICAgICAgKiBVc2VycyBtYXkgb3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gcGVyZm9ybSBjbGFzcyByZWdpc3RyYXRpb24gdGltZVxuICAgICAgICogd29yay4gVGhlIGltcGxlbWVudGF0aW9uIHNob3VsZCBlbnN1cmUgdGhlIHdvcmsgaXMgcGVyZm9ybWVkXG4gICAgICAgKiBvbmx5IG9uY2UgZm9yIHRoZSBjbGFzcy5cbiAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAqL1xuICAgICAgX3JlZ2lzdGVyZWQoKSB7fVxuXG4gICAgICAvKipcbiAgICAgICAqIE92ZXJyaWRlcyB0aGUgZGVmYXVsdCBgUG9seW1lci5Qcm9wZXJ0eUVmZmVjdHNgIGltcGxlbWVudGF0aW9uIHRvXG4gICAgICAgKiBhZGQgc3VwcG9ydCBmb3IgaW5zdGFsbGluZyBgaG9zdEF0dHJpYnV0ZXNgIGFuZCBgbGlzdGVuZXJzYC5cbiAgICAgICAqXG4gICAgICAgKiBAb3ZlcnJpZGVcbiAgICAgICAqL1xuICAgICAgcmVhZHkoKSB7XG4gICAgICAgIHRoaXMuX2Vuc3VyZUF0dHJpYnV0ZXMoKTtcbiAgICAgICAgdGhpcy5fYXBwbHlMaXN0ZW5lcnMoKTtcbiAgICAgICAgc3VwZXIucmVhZHkoKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBFbnN1cmVzIGFuIGVsZW1lbnQgaGFzIHJlcXVpcmVkIGF0dHJpYnV0ZXMuIENhbGxlZCB3aGVuIHRoZSBlbGVtZW50XG4gICAgICAgKiBpcyBiZWluZyByZWFkaWVkIHZpYSBgcmVhZHlgLiBVc2VycyBzaG91bGQgb3ZlcnJpZGUgdG8gc2V0IHRoZVxuICAgICAgICogZWxlbWVudCdzIHJlcXVpcmVkIGF0dHJpYnV0ZXMuIFRoZSBpbXBsZW1lbnRhdGlvbiBzaG91bGQgYmUgc3VyZVxuICAgICAgICogdG8gY2hlY2sgYW5kIG5vdCBvdmVycmlkZSBleGlzdGluZyBhdHRyaWJ1dGVzIGFkZGVkIGJ5XG4gICAgICAgKiB0aGUgdXNlciBvZiB0aGUgZWxlbWVudC4gVHlwaWNhbGx5LCBzZXR0aW5nIGF0dHJpYnV0ZXMgc2hvdWxkIGJlIGxlZnRcbiAgICAgICAqIHRvIHRoZSBlbGVtZW50IHVzZXIgYW5kIG5vdCBkb25lIGhlcmU7IHJlYXNvbmFibGUgZXhjZXB0aW9ucyBpbmNsdWRlXG4gICAgICAgKiBzZXR0aW5nIGFyaWEgcm9sZXMgYW5kIGZvY3VzYWJpbGl0eS5cbiAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAqL1xuICAgICAgX2Vuc3VyZUF0dHJpYnV0ZXMoKSB7fVxuXG4gICAgICAvKipcbiAgICAgICAqIEFkZHMgZWxlbWVudCBldmVudCBsaXN0ZW5lcnMuIENhbGxlZCB3aGVuIHRoZSBlbGVtZW50XG4gICAgICAgKiBpcyBiZWluZyByZWFkaWVkIHZpYSBgcmVhZHlgLiBVc2VycyBzaG91bGQgb3ZlcnJpZGUgdG9cbiAgICAgICAqIGFkZCBhbnkgcmVxdWlyZWQgZWxlbWVudCBldmVudCBsaXN0ZW5lcnMuXG4gICAgICAgKiBJbiBwZXJmb3JtYW5jZSBjcml0aWNhbCBlbGVtZW50cywgdGhlIHdvcmsgZG9uZSBoZXJlIHNob3VsZCBiZSBrZXB0XG4gICAgICAgKiB0byBhIG1pbmltdW0gc2luY2UgaXQgaXMgZG9uZSBiZWZvcmUgdGhlIGVsZW1lbnQgaXMgcmVuZGVyZWQuIEluXG4gICAgICAgKiB0aGVzZSBlbGVtZW50cywgY29uc2lkZXIgYWRkaW5nIGxpc3RlbmVycyBhc3ljaHJvbm91c2x5IHNvIGFzIG5vdCB0b1xuICAgICAgICogYmxvY2sgcmVuZGVyLlxuICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICovXG4gICAgICBfYXBwbHlMaXN0ZW5lcnMoKSB7fVxuXG4gICAgICAvKipcbiAgICAgICAqIENvbnZlcnRzIGEgdHlwZWQgSmF2YVNjcmlwdCB2YWx1ZSB0byBhIHN0cmluZy5cbiAgICAgICAqXG4gICAgICAgKiBOb3RlIHRoaXMgbWV0aG9kIGlzIHByb3ZpZGVkIGFzIGJhY2t3YXJkLWNvbXBhdGlibGUgbGVnYWN5IEFQSVxuICAgICAgICogb25seS4gIEl0IGlzIG5vdCBkaXJlY3RseSBjYWxsZWQgYnkgYW55IFBvbHltZXIgZmVhdHVyZXMuIFRvIGN1c3RvbWl6ZVxuICAgICAgICogaG93IHByb3BlcnRpZXMgYXJlIHNlcmlhbGl6ZWQgdG8gYXR0cmlidXRlcyBmb3IgYXR0cmlidXRlIGJpbmRpbmdzIGFuZFxuICAgICAgICogYHJlZmxlY3RUb0F0dHJpYnV0ZTogdHJ1ZWAgcHJvcGVydGllcyBhcyB3ZWxsIGFzIHRoaXMgbWV0aG9kLCBvdmVycmlkZVxuICAgICAgICogdGhlIGBfc2VyaWFsaXplVmFsdWVgIG1ldGhvZCBwcm92aWRlZCBieSBgUG9seW1lci5Qcm9wZXJ0eUFjY2Vzc29yc2AuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byBkZXNlcmlhbGl6ZVxuICAgICAgICogQHJldHVybiB7c3RyaW5nIHwgdW5kZWZpbmVkfSBTZXJpYWxpemVkIHZhbHVlXG4gICAgICAgKi9cbiAgICAgIHNlcmlhbGl6ZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2VyaWFsaXplVmFsdWUodmFsdWUpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENvbnZlcnRzIGEgc3RyaW5nIHRvIGEgdHlwZWQgSmF2YVNjcmlwdCB2YWx1ZS5cbiAgICAgICAqXG4gICAgICAgKiBOb3RlIHRoaXMgbWV0aG9kIGlzIHByb3ZpZGVkIGFzIGJhY2t3YXJkLWNvbXBhdGlibGUgbGVnYWN5IEFQSVxuICAgICAgICogb25seS4gIEl0IGlzIG5vdCBkaXJlY3RseSBjYWxsZWQgYnkgYW55IFBvbHltZXIgZmVhdHVyZXMuICBUbyBjdXN0b21pemVcbiAgICAgICAqIGhvdyBhdHRyaWJ1dGVzIGFyZSBkZXNlcmlhbGl6ZWQgdG8gcHJvcGVydGllcyBmb3IgaW5cbiAgICAgICAqIGBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2tgLCBvdmVycmlkZSBgX2Rlc2VyaWFsaXplVmFsdWVgIG1ldGhvZFxuICAgICAgICogcHJvdmlkZWQgYnkgYFBvbHltZXIuUHJvcGVydHlBY2Nlc3NvcnNgLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSBTdHJpbmcgdG8gZGVzZXJpYWxpemVcbiAgICAgICAqIEBwYXJhbSB7Kn0gdHlwZSBUeXBlIHRvIGRlc2VyaWFsaXplIHRoZSBzdHJpbmcgdG9cbiAgICAgICAqIEByZXR1cm4geyp9IFJldHVybnMgdGhlIGRlc2VyaWFsaXplZCB2YWx1ZSBpbiB0aGUgYHR5cGVgIGdpdmVuLlxuICAgICAgICovXG4gICAgICBkZXNlcmlhbGl6ZSh2YWx1ZSwgdHlwZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVzZXJpYWxpemVWYWx1ZSh2YWx1ZSwgdHlwZSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogU2VyaWFsaXplcyBhIHByb3BlcnR5IHRvIGl0cyBhc3NvY2lhdGVkIGF0dHJpYnV0ZS5cbiAgICAgICAqXG4gICAgICAgKiBOb3RlIHRoaXMgbWV0aG9kIGlzIHByb3ZpZGVkIGFzIGJhY2t3YXJkLWNvbXBhdGlibGUgbGVnYWN5IEFQSVxuICAgICAgICogb25seS4gIEl0IGlzIG5vdCBkaXJlY3RseSBjYWxsZWQgYnkgYW55IFBvbHltZXIgZmVhdHVyZXMuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IG5hbWUgdG8gcmVmbGVjdC5cbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nPX0gYXR0cmlidXRlIEF0dHJpYnV0ZSBuYW1lIHRvIHJlZmxlY3QuXG4gICAgICAgKiBAcGFyYW0geyo9fSB2YWx1ZSBQcm9wZXJ0eSB2YWx1ZSB0byByZWZlY3QuXG4gICAgICAgKi9cbiAgICAgIHJlZmxlY3RQcm9wZXJ0eVRvQXR0cmlidXRlKHByb3BlcnR5LCBhdHRyaWJ1dGUsIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3Byb3BlcnR5VG9BdHRyaWJ1dGUocHJvcGVydHksIGF0dHJpYnV0ZSwgdmFsdWUpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFNldHMgYSB0eXBlZCB2YWx1ZSB0byBhbiBIVE1MIGF0dHJpYnV0ZSBvbiBhIG5vZGUuXG4gICAgICAgKlxuICAgICAgICogTm90ZSB0aGlzIG1ldGhvZCBpcyBwcm92aWRlZCBhcyBiYWNrd2FyZC1jb21wYXRpYmxlIGxlZ2FjeSBBUElcbiAgICAgICAqIG9ubHkuICBJdCBpcyBub3QgZGlyZWN0bHkgY2FsbGVkIGJ5IGFueSBQb2x5bWVyIGZlYXR1cmVzLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgdG8gc2VyaWFsaXplLlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGF0dHJpYnV0ZSBBdHRyaWJ1dGUgbmFtZSB0byBzZXJpYWxpemUgdG8uXG4gICAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgRWxlbWVudCB0byBzZXQgYXR0cmlidXRlIHRvLlxuICAgICAgICovXG4gICAgICBzZXJpYWxpemVWYWx1ZVRvQXR0cmlidXRlKHZhbHVlLCBhdHRyaWJ1dGUsIG5vZGUpIHtcbiAgICAgICAgdGhpcy5fdmFsdWVUb05vZGVBdHRyaWJ1dGUoLyoqIEB0eXBlIHtFbGVtZW50fSAqLyAobm9kZSB8fCB0aGlzKSwgdmFsdWUsIGF0dHJpYnV0ZSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ29waWVzIG93biBwcm9wZXJ0aWVzIChpbmNsdWRpbmcgYWNjZXNzb3IgZGVzY3JpcHRvcnMpIGZyb20gYSBzb3VyY2VcbiAgICAgICAqIG9iamVjdCB0byBhIHRhcmdldCBvYmplY3QuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IHByb3RvdHlwZSBUYXJnZXQgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyB0by5cbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhcGkgU291cmNlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgZnJvbS5cbiAgICAgICAqIEByZXR1cm4ge09iamVjdH0gcHJvdG90eXBlIG9iamVjdCB0aGF0IHdhcyBwYXNzZWQgYXMgZmlyc3QgYXJndW1lbnQuXG4gICAgICAgKi9cbiAgICAgIGV4dGVuZChwcm90b3R5cGUsIGFwaSkge1xuICAgICAgICBpZiAoIShwcm90b3R5cGUgJiYgYXBpKSkge1xuICAgICAgICAgIHJldHVybiBwcm90b3R5cGUgfHwgYXBpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBuJCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGFwaSk7XG4gICAgICAgIGZvciAobGV0IGk9MCwgbjsgKGk8biQubGVuZ3RoKSAmJiAobj1uJFtpXSk7IGkrKykge1xuICAgICAgICAgIGxldCBwZCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYXBpLCBuKTtcbiAgICAgICAgICBpZiAocGQpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90b3R5cGUsIG4sIHBkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb3RvdHlwZTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDb3BpZXMgcHJvcHMgZnJvbSBhIHNvdXJjZSBvYmplY3QgdG8gYSB0YXJnZXQgb2JqZWN0LlxuICAgICAgICpcbiAgICAgICAqIE5vdGUsIHRoaXMgbWV0aG9kIHVzZXMgYSBzaW1wbGUgYGZvci4uLmluYCBzdHJhdGVneSBmb3IgZW51bWVyYXRpbmdcbiAgICAgICAqIHByb3BlcnRpZXMuICBUbyBlbnN1cmUgb25seSBgb3duUHJvcGVydGllc2AgYXJlIGNvcGllZCBmcm9tIHNvdXJjZVxuICAgICAgICogdG8gdGFyZ2V0IGFuZCB0aGF0IGFjY2Vzc29yIGltcGxlbWVudGF0aW9ucyBhcmUgY29waWVkLCB1c2UgYGV4dGVuZGAuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBUYXJnZXQgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyB0by5cbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgU291cmNlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgZnJvbS5cbiAgICAgICAqIEByZXR1cm4ge09iamVjdH0gVGFyZ2V0IG9iamVjdCB0aGF0IHdhcyBwYXNzZWQgYXMgZmlyc3QgYXJndW1lbnQuXG4gICAgICAgKi9cbiAgICAgIG1peGluKHRhcmdldCwgc291cmNlKSB7XG4gICAgICAgIGZvciAobGV0IGkgaW4gc291cmNlKSB7XG4gICAgICAgICAgdGFyZ2V0W2ldID0gc291cmNlW2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogU2V0cyB0aGUgcHJvdG90eXBlIG9mIGFuIG9iamVjdC5cbiAgICAgICAqXG4gICAgICAgKiBOb3RlIHRoaXMgbWV0aG9kIGlzIHByb3ZpZGVkIGFzIGJhY2t3YXJkLWNvbXBhdGlibGUgbGVnYWN5IEFQSVxuICAgICAgICogb25seS4gIEl0IGlzIG5vdCBkaXJlY3RseSBjYWxsZWQgYnkgYW55IFBvbHltZXIgZmVhdHVyZXMuXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3Qgb24gd2hpY2ggdG8gc2V0IHRoZSBwcm90b3R5cGUuXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvdG90eXBlIFRoZSBwcm90b3R5cGUgdGhhdCB3aWxsIGJlIHNldCBvbiB0aGUgZ2l2ZW5cbiAgICAgICAqIGBvYmplY3RgLlxuICAgICAgICogQHJldHVybiB7T2JqZWN0fSBSZXR1cm5zIHRoZSBnaXZlbiBgb2JqZWN0YCB3aXRoIGl0cyBwcm90b3R5cGUgc2V0XG4gICAgICAgKiB0byB0aGUgZ2l2ZW4gYHByb3RvdHlwZWAgb2JqZWN0LlxuICAgICAgICovXG4gICAgICBjaGFpbk9iamVjdChvYmplY3QsIHByb3RvdHlwZSkge1xuICAgICAgICBpZiAob2JqZWN0ICYmIHByb3RvdHlwZSAmJiBvYmplY3QgIT09IHByb3RvdHlwZSkge1xuICAgICAgICAgIG9iamVjdC5fX3Byb3RvX18gPSBwcm90b3R5cGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgIH1cblxuICAgICAgLyogKioqKiBCZWdpbiBUZW1wbGF0ZSAqKioqICovXG5cbiAgICAgIC8qKlxuICAgICAgICogQ2FsbHMgYGltcG9ydE5vZGVgIG9uIHRoZSBgY29udGVudGAgb2YgdGhlIGB0ZW1wbGF0ZWAgc3BlY2lmaWVkIGFuZFxuICAgICAgICogcmV0dXJucyBhIGRvY3VtZW50IGZyYWdtZW50IGNvbnRhaW5pbmcgdGhlIGltcG9ydGVkIGNvbnRlbnQuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtIVE1MVGVtcGxhdGVFbGVtZW50fSB0ZW1wbGF0ZSBIVE1MIHRlbXBsYXRlIGVsZW1lbnQgdG8gaW5zdGFuY2UuXG4gICAgICAgKiBAcmV0dXJuIHtEb2N1bWVudEZyYWdtZW50fSBEb2N1bWVudCBmcmFnbWVudCBjb250YWluaW5nIHRoZSBpbXBvcnRlZFxuICAgICAgICogICB0ZW1wbGF0ZSBjb250ZW50LlxuICAgICAgKi9cbiAgICAgIGluc3RhbmNlVGVtcGxhdGUodGVtcGxhdGUpIHtcbiAgICAgICAgbGV0IGNvbnRlbnQgPSB0aGlzLmNvbnN0cnVjdG9yLl9jb250ZW50Rm9yVGVtcGxhdGUodGVtcGxhdGUpO1xuICAgICAgICBsZXQgZG9tID0gLyoqIEB0eXBlIHtEb2N1bWVudEZyYWdtZW50fSAqL1xuICAgICAgICAgIChkb2N1bWVudC5pbXBvcnROb2RlKGNvbnRlbnQsIHRydWUpKTtcbiAgICAgICAgcmV0dXJuIGRvbTtcbiAgICAgIH1cblxuICAgICAgLyogKioqKiBCZWdpbiBFdmVudHMgKioqKiAqL1xuXG5cblxuICAgICAgLyoqXG4gICAgICAgKiBEaXNwYXRjaGVzIGEgY3VzdG9tIGV2ZW50IHdpdGggYW4gb3B0aW9uYWwgZGV0YWlsIHZhbHVlLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIE5hbWUgb2YgZXZlbnQgdHlwZS5cbiAgICAgICAqIEBwYXJhbSB7Kj19IGRldGFpbCBEZXRhaWwgdmFsdWUgY29udGFpbmluZyBldmVudC1zcGVjaWZpY1xuICAgICAgICogICBwYXlsb2FkLlxuICAgICAgICogQHBhcmFtIHt7IGJ1YmJsZXM6IChib29sZWFufHVuZGVmaW5lZCksIGNhbmNlbGFibGU6IChib29sZWFufHVuZGVmaW5lZCksIGNvbXBvc2VkOiAoYm9vbGVhbnx1bmRlZmluZWQpIH09fVxuICAgICAgICogIG9wdGlvbnMgT2JqZWN0IHNwZWNpZnlpbmcgb3B0aW9ucy4gIFRoZXNlIG1heSBpbmNsdWRlOlxuICAgICAgICogIGBidWJibGVzYCAoYm9vbGVhbiwgZGVmYXVsdHMgdG8gYHRydWVgKSxcbiAgICAgICAqICBgY2FuY2VsYWJsZWAgKGJvb2xlYW4sIGRlZmF1bHRzIHRvIGZhbHNlKSwgYW5kXG4gICAgICAgKiAgYG5vZGVgIG9uIHdoaWNoIHRvIGZpcmUgdGhlIGV2ZW50IChIVE1MRWxlbWVudCwgZGVmYXVsdHMgdG8gYHRoaXNgKS5cbiAgICAgICAqIEByZXR1cm4ge0V2ZW50fSBUaGUgbmV3IGV2ZW50IHRoYXQgd2FzIGZpcmVkLlxuICAgICAgICovXG4gICAgICBmaXJlKHR5cGUsIGRldGFpbCwgb3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgZGV0YWlsID0gKGRldGFpbCA9PT0gbnVsbCB8fCBkZXRhaWwgPT09IHVuZGVmaW5lZCkgPyB7fSA6IGRldGFpbDtcbiAgICAgICAgbGV0IGV2ZW50ID0gbmV3IEV2ZW50KHR5cGUsIHtcbiAgICAgICAgICBidWJibGVzOiBvcHRpb25zLmJ1YmJsZXMgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBvcHRpb25zLmJ1YmJsZXMsXG4gICAgICAgICAgY2FuY2VsYWJsZTogQm9vbGVhbihvcHRpb25zLmNhbmNlbGFibGUpLFxuICAgICAgICAgIGNvbXBvc2VkOiBvcHRpb25zLmNvbXBvc2VkID09PSB1bmRlZmluZWQgPyB0cnVlOiBvcHRpb25zLmNvbXBvc2VkXG4gICAgICAgIH0pO1xuICAgICAgICBldmVudC5kZXRhaWwgPSBkZXRhaWw7XG4gICAgICAgIGxldCBub2RlID0gb3B0aW9ucy5ub2RlIHx8IHRoaXM7XG4gICAgICAgIG5vZGUuZGlzcGF0Y2hFdmVudChldmVudClcbiAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENvbnZlbmllbmNlIG1ldGhvZCB0byBhZGQgYW4gZXZlbnQgbGlzdGVuZXIgb24gYSBnaXZlbiBlbGVtZW50LFxuICAgICAgICogbGF0ZSBib3VuZCB0byBhIG5hbWVkIG1ldGhvZCBvbiB0aGlzIGVsZW1lbnQuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtFbGVtZW50fSBub2RlIEVsZW1lbnQgdG8gYWRkIGV2ZW50IGxpc3RlbmVyIHRvLlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBOYW1lIG9mIGV2ZW50IHRvIGxpc3RlbiBmb3IuXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kTmFtZSBOYW1lIG9mIGhhbmRsZXIgbWV0aG9kIG9uIGB0aGlzYCB0byBjYWxsLlxuICAgICAgICovXG4gICAgICBsaXN0ZW4obm9kZSwgZXZlbnROYW1lLCBtZXRob2ROYW1lKSB7XG4gICAgICAgIG5vZGUgPSAvKiogQHR5cGUge0VsZW1lbnR9ICovIChub2RlIHx8IHRoaXMpO1xuICAgICAgICBsZXQgaGJsID0gdGhpcy5fX2JvdW5kTGlzdGVuZXJzIHx8XG4gICAgICAgICAgKHRoaXMuX19ib3VuZExpc3RlbmVycyA9IG5ldyBXZWFrTWFwKCkpO1xuICAgICAgICBsZXQgYmwgPSBoYmwuZ2V0KG5vZGUpO1xuICAgICAgICBpZiAoIWJsKSB7XG4gICAgICAgICAgYmwgPSB7fTtcbiAgICAgICAgICBoYmwuc2V0KG5vZGUsIGJsKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQga2V5ID0gZXZlbnROYW1lICsgbWV0aG9kTmFtZTtcbiAgICAgICAgaWYgKCFibFtrZXldKSB7XG4gICAgICAgICAgYmxba2V5XSA9IHRoaXMuX2FkZE1ldGhvZEV2ZW50TGlzdGVuZXJUb05vZGUoXG4gICAgICAgICAgICBub2RlLCBldmVudE5hbWUsIG1ldGhvZE5hbWUsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ29udmVuaWVuY2UgbWV0aG9kIHRvIHJlbW92ZSBhbiBldmVudCBsaXN0ZW5lciBmcm9tIGEgZ2l2ZW4gZWxlbWVudCxcbiAgICAgICAqIGxhdGUgYm91bmQgdG8gYSBuYW1lZCBtZXRob2Qgb24gdGhpcyBlbGVtZW50LlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZSBFbGVtZW50IHRvIHJlbW92ZSBldmVudCBsaXN0ZW5lciBmcm9tLlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBOYW1lIG9mIGV2ZW50IHRvIHN0b3AgbGlzdGVuaW5nIHRvLlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZE5hbWUgTmFtZSBvZiBoYW5kbGVyIG1ldGhvZCBvbiBgdGhpc2AgdG8gbm90IGNhbGxcbiAgICAgICBhbnltb3JlLlxuICAgICAgICovXG4gICAgICB1bmxpc3Rlbihub2RlLCBldmVudE5hbWUsIG1ldGhvZE5hbWUpIHtcbiAgICAgICAgbm9kZSA9IC8qKiBAdHlwZSB7RWxlbWVudH0gKi8gKG5vZGUgfHwgdGhpcyk7XG4gICAgICAgIGxldCBibCA9IHRoaXMuX19ib3VuZExpc3RlbmVycyAmJiB0aGlzLl9fYm91bmRMaXN0ZW5lcnMuZ2V0KG5vZGUpO1xuICAgICAgICBsZXQga2V5ID0gZXZlbnROYW1lICsgbWV0aG9kTmFtZTtcbiAgICAgICAgbGV0IGhhbmRsZXIgPSBibCAmJiBibFtrZXldO1xuICAgICAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICAgIHRoaXMuX3JlbW92ZUV2ZW50TGlzdGVuZXJGcm9tTm9kZShub2RlLCBldmVudE5hbWUsIGhhbmRsZXIpO1xuICAgICAgICAgIGJsW2tleV0gPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogT3ZlcnJpZGUgc2Nyb2xsaW5nIGJlaGF2aW9yIHRvIGFsbCBkaXJlY3Rpb24sIG9uZSBkaXJlY3Rpb24sIG9yIG5vbmUuXG4gICAgICAgKlxuICAgICAgICogVmFsaWQgc2Nyb2xsIGRpcmVjdGlvbnM6XG4gICAgICAgKiAgIC0gJ2FsbCc6IHNjcm9sbCBpbiBhbnkgZGlyZWN0aW9uXG4gICAgICAgKiAgIC0gJ3gnOiBzY3JvbGwgb25seSBpbiB0aGUgJ3gnIGRpcmVjdGlvblxuICAgICAgICogICAtICd5Jzogc2Nyb2xsIG9ubHkgaW4gdGhlICd5JyBkaXJlY3Rpb25cbiAgICAgICAqICAgLSAnbm9uZSc6IGRpc2FibGUgc2Nyb2xsaW5nIGZvciB0aGlzIG5vZGVcbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZz19IGRpcmVjdGlvbiBEaXJlY3Rpb24gdG8gYWxsb3cgc2Nyb2xsaW5nXG4gICAgICAgKiBEZWZhdWx0cyB0byBgYWxsYC5cbiAgICAgICAqIEBwYXJhbSB7RWxlbWVudD19IG5vZGUgRWxlbWVudCB0byBhcHBseSBzY3JvbGwgZGlyZWN0aW9uIHNldHRpbmcuXG4gICAgICAgKiBEZWZhdWx0cyB0byBgdGhpc2AuXG4gICAgICAgKi9cbiAgICAgIHNldFNjcm9sbERpcmVjdGlvbihkaXJlY3Rpb24sIG5vZGUpIHtcbiAgICAgICAgUG9seW1lci5HZXN0dXJlcy5zZXRUb3VjaEFjdGlvbigvKiogQHR5cGUge0VsZW1lbnR9ICovIChub2RlIHx8IHRoaXMpLCBESVJFQ1RJT05fTUFQW2RpcmVjdGlvbl0gfHwgJ2F1dG8nKTtcbiAgICAgIH1cbiAgICAgIC8qICoqKiogRW5kIEV2ZW50cyAqKioqICovXG5cbiAgICAgIC8qKlxuICAgICAgICogQ29udmVuaWVuY2UgbWV0aG9kIHRvIHJ1biBgcXVlcnlTZWxlY3RvcmAgb24gdGhpcyBsb2NhbCBET00gc2NvcGUuXG4gICAgICAgKlxuICAgICAgICogVGhpcyBmdW5jdGlvbiBjYWxscyBgUG9seW1lci5kb20odGhpcy5yb290KS5xdWVyeVNlbGVjdG9yKHNsY3RyKWAuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHNsY3RyIFNlbGVjdG9yIHRvIHJ1biBvbiB0aGlzIGxvY2FsIERPTSBzY29wZVxuICAgICAgICogQHJldHVybiB7RWxlbWVudH0gRWxlbWVudCBmb3VuZCBieSB0aGUgc2VsZWN0b3IsIG9yIG51bGwgaWYgbm90IGZvdW5kLlxuICAgICAgICovXG4gICAgICAkJChzbGN0cikge1xuICAgICAgICByZXR1cm4gdGhpcy5yb290LnF1ZXJ5U2VsZWN0b3Ioc2xjdHIpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJldHVybiB0aGUgZWxlbWVudCB3aG9zZSBsb2NhbCBkb20gd2l0aGluIHdoaWNoIHRoaXMgZWxlbWVudFxuICAgICAgICogaXMgY29udGFpbmVkLiBUaGlzIGlzIGEgc2hvcnRoYW5kIGZvclxuICAgICAgICogYHRoaXMuZ2V0Um9vdE5vZGUoKS5ob3N0YC5cbiAgICAgICAqIEB0aGlzIHtFbGVtZW50fVxuICAgICAgICovXG4gICAgICBnZXQgZG9tSG9zdCgpIHtcbiAgICAgICAgbGV0IHJvb3QgPSB0aGlzLmdldFJvb3ROb2RlKCk7XG4gICAgICAgIHJldHVybiAocm9vdCBpbnN0YW5jZW9mIERvY3VtZW50RnJhZ21lbnQpID8gLyoqIEB0eXBlIHtTaGFkb3dSb290fSAqLyAocm9vdCkuaG9zdCA6IHJvb3Q7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogRm9yY2UgdGhpcyBlbGVtZW50IHRvIGRpc3RyaWJ1dGUgaXRzIGNoaWxkcmVuIHRvIGl0cyBsb2NhbCBkb20uXG4gICAgICAgKiBUaGlzIHNob3VsZCBub3QgYmUgbmVjZXNzYXJ5IGFzIG9mIFBvbHltZXIgMi4wLjIgYW5kIGlzIHByb3ZpZGVkIG9ubHlcbiAgICAgICAqIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cbiAgICAgICAqL1xuICAgICAgZGlzdHJpYnV0ZUNvbnRlbnQoKSB7XG4gICAgICAgIGlmICh3aW5kb3cuU2hhZHlET00gJiYgdGhpcy5zaGFkb3dSb290KSB7XG4gICAgICAgICAgU2hhZHlET00uZmx1c2goKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJldHVybnMgYSBsaXN0IG9mIG5vZGVzIHRoYXQgYXJlIHRoZSBlZmZlY3RpdmUgY2hpbGROb2Rlcy4gVGhlIGVmZmVjdGl2ZVxuICAgICAgICogY2hpbGROb2RlcyBsaXN0IGlzIHRoZSBzYW1lIGFzIHRoZSBlbGVtZW50J3MgY2hpbGROb2RlcyBleGNlcHQgdGhhdFxuICAgICAgICogYW55IGA8Y29udGVudD5gIGVsZW1lbnRzIGFyZSByZXBsYWNlZCB3aXRoIHRoZSBsaXN0IG9mIG5vZGVzIGRpc3RyaWJ1dGVkXG4gICAgICAgKiB0byB0aGUgYDxjb250ZW50PmAsIHRoZSByZXN1bHQgb2YgaXRzIGBnZXREaXN0cmlidXRlZE5vZGVzYCBtZXRob2QuXG4gICAgICAgKiBAdGhpcyB7RWxlbWVudH1cbiAgICAgICAqIEByZXR1cm4ge0FycmF5PE5vZGU+fSBMaXN0IG9mIGVmZmN0aXZlIGNoaWxkIG5vZGVzLlxuICAgICAgICovXG4gICAgICBnZXRFZmZlY3RpdmVDaGlsZE5vZGVzKCkge1xuICAgICAgICByZXR1cm4gLyoqIEB0eXBlIHtQb2x5bWVyLkRvbUFwaX0gKi8gKFBvbHltZXIuZG9tKHRoaXMpKS5nZXRFZmZlY3RpdmVDaGlsZE5vZGVzKCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUmV0dXJucyBhIGxpc3Qgb2Ygbm9kZXMgZGlzdHJpYnV0ZWQgd2l0aGluIHRoaXMgZWxlbWVudCB0aGF0IG1hdGNoXG4gICAgICAgKiBgc2VsZWN0b3JgLiBUaGVzZSBjYW4gYmUgZG9tIGNoaWxkcmVuIG9yIGVsZW1lbnRzIGRpc3RyaWJ1dGVkIHRvXG4gICAgICAgKiBjaGlsZHJlbiB0aGF0IGFyZSBpbnNlcnRpb24gcG9pbnRzLlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yIFNlbGVjdG9yIHRvIHJ1bi5cbiAgICAgICAqIEB0aGlzIHtFbGVtZW50fVxuICAgICAgICogQHJldHVybiB7QXJyYXk8Tm9kZT59IExpc3Qgb2YgZGlzdHJpYnV0ZWQgZWxlbWVudHMgdGhhdCBtYXRjaCBzZWxlY3Rvci5cbiAgICAgICAqL1xuICAgICAgcXVlcnlEaXN0cmlidXRlZEVsZW1lbnRzKHNlbGVjdG9yKSB7XG4gICAgICAgIHJldHVybiAvKiogQHR5cGUge1BvbHltZXIuRG9tQXBpfSAqLyAoUG9seW1lci5kb20odGhpcykpLnF1ZXJ5RGlzdHJpYnV0ZWRFbGVtZW50cyhzZWxlY3Rvcik7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUmV0dXJucyBhIGxpc3Qgb2YgZWxlbWVudHMgdGhhdCBhcmUgdGhlIGVmZmVjdGl2ZSBjaGlsZHJlbi4gVGhlIGVmZmVjdGl2ZVxuICAgICAgICogY2hpbGRyZW4gbGlzdCBpcyB0aGUgc2FtZSBhcyB0aGUgZWxlbWVudCdzIGNoaWxkcmVuIGV4Y2VwdCB0aGF0XG4gICAgICAgKiBhbnkgYDxjb250ZW50PmAgZWxlbWVudHMgYXJlIHJlcGxhY2VkIHdpdGggdGhlIGxpc3Qgb2YgZWxlbWVudHNcbiAgICAgICAqIGRpc3RyaWJ1dGVkIHRvIHRoZSBgPGNvbnRlbnQ+YC5cbiAgICAgICAqXG4gICAgICAgKiBAcmV0dXJuIHtBcnJheTxOb2RlPn0gTGlzdCBvZiBlZmZjdGl2ZSBjaGlsZHJlbi5cbiAgICAgICAqL1xuICAgICAgZ2V0RWZmZWN0aXZlQ2hpbGRyZW4oKSB7XG4gICAgICAgIGxldCBsaXN0ID0gdGhpcy5nZXRFZmZlY3RpdmVDaGlsZE5vZGVzKCk7XG4gICAgICAgIHJldHVybiBsaXN0LmZpbHRlcihmdW5jdGlvbigvKiogQHR5cGUge05vZGV9ICovIG4pIHtcbiAgICAgICAgICByZXR1cm4gKG4ubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUmV0dXJucyBhIHN0cmluZyBvZiB0ZXh0IGNvbnRlbnQgdGhhdCBpcyB0aGUgY29uY2F0ZW5hdGlvbiBvZiB0aGVcbiAgICAgICAqIHRleHQgY29udGVudCdzIG9mIHRoZSBlbGVtZW50J3MgZWZmZWN0aXZlIGNoaWxkTm9kZXMgKHRoZSBlbGVtZW50c1xuICAgICAgICogcmV0dXJuZWQgYnkgPGEgaHJlZj1cIiNnZXRFZmZlY3RpdmVDaGlsZE5vZGVzPmdldEVmZmVjdGl2ZUNoaWxkTm9kZXM8L2E+LlxuICAgICAgICpcbiAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gTGlzdCBvZiBlZmZjdGl2ZSBjaGlsZHJlbi5cbiAgICAgICAqL1xuICAgICAgZ2V0RWZmZWN0aXZlVGV4dENvbnRlbnQoKSB7XG4gICAgICAgIGxldCBjbiA9IHRoaXMuZ2V0RWZmZWN0aXZlQ2hpbGROb2RlcygpO1xuICAgICAgICBsZXQgdGMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaT0wLCBjOyAoYyA9IGNuW2ldKTsgaSsrKSB7XG4gICAgICAgICAgaWYgKGMubm9kZVR5cGUgIT09IE5vZGUuQ09NTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICB0Yy5wdXNoKGMudGV4dENvbnRlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGMuam9pbignJyk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUmV0dXJucyB0aGUgZmlyc3QgZWZmZWN0aXZlIGNoaWxkTm9kZSB3aXRoaW4gdGhpcyBlbGVtZW50IHRoYXRcbiAgICAgICAqIG1hdGNoIGBzZWxlY3RvcmAuIFRoZXNlIGNhbiBiZSBkb20gY2hpbGQgbm9kZXMgb3IgZWxlbWVudHMgZGlzdHJpYnV0ZWRcbiAgICAgICAqIHRvIGNoaWxkcmVuIHRoYXQgYXJlIGluc2VydGlvbiBwb2ludHMuXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3IgU2VsZWN0b3IgdG8gcnVuLlxuICAgICAgICogQHJldHVybiB7T2JqZWN0PE5vZGU+fSBGaXJzdCBlZmZlY3RpdmUgY2hpbGQgbm9kZSB0aGF0IG1hdGNoZXMgc2VsZWN0b3IuXG4gICAgICAgKi9cbiAgICAgIHF1ZXJ5RWZmZWN0aXZlQ2hpbGRyZW4oc2VsZWN0b3IpIHtcbiAgICAgICAgbGV0IGUkID0gdGhpcy5xdWVyeURpc3RyaWJ1dGVkRWxlbWVudHMoc2VsZWN0b3IpO1xuICAgICAgICByZXR1cm4gZSQgJiYgZSRbMF07XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUmV0dXJucyBhIGxpc3Qgb2YgZWZmZWN0aXZlIGNoaWxkTm9kZXMgd2l0aGluIHRoaXMgZWxlbWVudCB0aGF0XG4gICAgICAgKiBtYXRjaCBgc2VsZWN0b3JgLiBUaGVzZSBjYW4gYmUgZG9tIGNoaWxkIG5vZGVzIG9yIGVsZW1lbnRzIGRpc3RyaWJ1dGVkXG4gICAgICAgKiB0byBjaGlsZHJlbiB0aGF0IGFyZSBpbnNlcnRpb24gcG9pbnRzLlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yIFNlbGVjdG9yIHRvIHJ1bi5cbiAgICAgICAqIEByZXR1cm4ge0FycmF5PE5vZGU+fSBMaXN0IG9mIGVmZmVjdGl2ZSBjaGlsZCBub2RlcyB0aGF0IG1hdGNoIHNlbGVjdG9yLlxuICAgICAgICovXG4gICAgICBxdWVyeUFsbEVmZmVjdGl2ZUNoaWxkcmVuKHNlbGVjdG9yKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnF1ZXJ5RGlzdHJpYnV0ZWRFbGVtZW50cyhzZWxlY3Rvcik7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUmV0dXJucyBhIGxpc3Qgb2Ygbm9kZXMgZGlzdHJpYnV0ZWQgdG8gdGhpcyBlbGVtZW50J3MgYDxzbG90PmAuXG4gICAgICAgKlxuICAgICAgICogSWYgdGhpcyBlbGVtZW50IGNvbnRhaW5zIG1vcmUgdGhhbiBvbmUgYDxzbG90PmAgaW4gaXRzIGxvY2FsIERPTSxcbiAgICAgICAqIGFuIG9wdGlvbmFsIHNlbGVjdG9yIG1heSBiZSBwYXNzZWQgdG8gY2hvb3NlIHRoZSBkZXNpcmVkIGNvbnRlbnQuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmc9fSBzbGN0ciBDU1Mgc2VsZWN0b3IgdG8gY2hvb3NlIHRoZSBkZXNpcmVkXG4gICAgICAgKiAgIGA8c2xvdD5gLiAgRGVmYXVsdHMgdG8gYGNvbnRlbnRgLlxuICAgICAgICogQHJldHVybiB7QXJyYXk8Tm9kZT59IExpc3Qgb2YgZGlzdHJpYnV0ZWQgbm9kZXMgZm9yIHRoZSBgPHNsb3Q+YC5cbiAgICAgICAqL1xuICAgICAgZ2V0Q29udGVudENoaWxkTm9kZXMoc2xjdHIpIHtcbiAgICAgICAgbGV0IGNvbnRlbnQgPSB0aGlzLnJvb3QucXVlcnlTZWxlY3RvcihzbGN0ciB8fCAnc2xvdCcpO1xuICAgICAgICByZXR1cm4gY29udGVudCA/IC8qKiBAdHlwZSB7UG9seW1lci5Eb21BcGl9ICovKFBvbHltZXIuZG9tKGNvbnRlbnQpKS5nZXREaXN0cmlidXRlZE5vZGVzKCkgOiBbXTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBlbGVtZW50IGNoaWxkcmVuIGRpc3RyaWJ1dGVkIHRvIHRoaXMgZWxlbWVudCdzXG4gICAgICAgKiBgPHNsb3Q+YC5cbiAgICAgICAqXG4gICAgICAgKiBJZiB0aGlzIGVsZW1lbnQgY29udGFpbnMgbW9yZSB0aGFuIG9uZSBgPHNsb3Q+YCBpbiBpdHNcbiAgICAgICAqIGxvY2FsIERPTSwgYW4gb3B0aW9uYWwgc2VsZWN0b3IgbWF5IGJlIHBhc3NlZCB0byBjaG9vc2UgdGhlIGRlc2lyZWRcbiAgICAgICAqIGNvbnRlbnQuICBUaGlzIG1ldGhvZCBkaWZmZXJzIGZyb20gYGdldENvbnRlbnRDaGlsZE5vZGVzYCBpbiB0aGF0IG9ubHlcbiAgICAgICAqIGVsZW1lbnRzIGFyZSByZXR1cm5lZC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZz19IHNsY3RyIENTUyBzZWxlY3RvciB0byBjaG9vc2UgdGhlIGRlc2lyZWRcbiAgICAgICAqICAgYDxjb250ZW50PmAuICBEZWZhdWx0cyB0byBgY29udGVudGAuXG4gICAgICAgKiBAcmV0dXJuIHtBcnJheTxIVE1MRWxlbWVudD59IExpc3Qgb2YgZGlzdHJpYnV0ZWQgbm9kZXMgZm9yIHRoZVxuICAgICAgICogICBgPHNsb3Q+YC5cbiAgICAgICAqIEBzdXBwcmVzcyB7aW52YWxpZENhc3RzfVxuICAgICAgICovXG4gICAgICBnZXRDb250ZW50Q2hpbGRyZW4oc2xjdHIpIHtcbiAgICAgICAgcmV0dXJuIC8qKiBAdHlwZSB7QXJyYXk8SFRNTEVsZW1lbnQ+fSAqLyh0aGlzLmdldENvbnRlbnRDaGlsZE5vZGVzKHNsY3RyKS5maWx0ZXIoZnVuY3Rpb24obikge1xuICAgICAgICAgIHJldHVybiAobi5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUpO1xuICAgICAgICB9KSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ2hlY2tzIHdoZXRoZXIgYW4gZWxlbWVudCBpcyBpbiB0aGlzIGVsZW1lbnQncyBsaWdodCBET00gdHJlZS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0gez9Ob2RlfSBub2RlIFRoZSBlbGVtZW50IHRvIGJlIGNoZWNrZWQuXG4gICAgICAgKiBAdGhpcyB7RWxlbWVudH1cbiAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgbm9kZSBpcyBpbiB0aGlzIGVsZW1lbnQncyBsaWdodCBET00gdHJlZS5cbiAgICAgICAqL1xuICAgICAgaXNMaWdodERlc2NlbmRhbnQobm9kZSkge1xuICAgICAgICByZXR1cm4gdGhpcyAhPT0gbm9kZSAmJiB0aGlzLmNvbnRhaW5zKG5vZGUpICYmXG4gICAgICAgICAgICB0aGlzLmdldFJvb3ROb2RlKCkgPT09IG5vZGUuZ2V0Um9vdE5vZGUoKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDaGVja3Mgd2hldGhlciBhbiBlbGVtZW50IGlzIGluIHRoaXMgZWxlbWVudCdzIGxvY2FsIERPTSB0cmVlLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7RWxlbWVudD19IG5vZGUgVGhlIGVsZW1lbnQgdG8gYmUgY2hlY2tlZC5cbiAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgbm9kZSBpcyBpbiB0aGlzIGVsZW1lbnQncyBsb2NhbCBET00gdHJlZS5cbiAgICAgICAqL1xuICAgICAgaXNMb2NhbERlc2NlbmRhbnQobm9kZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yb290ID09PSBub2RlLmdldFJvb3ROb2RlKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIE5PVEU6IHNob3VsZCBub3cgYmUgaGFuZGxlZCBieSBTaGFkeUNzcyBsaWJyYXJ5LlxuICAgICAgc2NvcGVTdWJ0cmVlKGNvbnRhaW5lciwgc2hvdWxkT2JzZXJ2ZSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUmV0dXJucyB0aGUgY29tcHV0ZWQgc3R5bGUgdmFsdWUgZm9yIHRoZSBnaXZlbiBwcm9wZXJ0eS5cbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBUaGUgY3NzIHByb3BlcnR5IG5hbWUuXG4gICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbXB1dGVkIGNzcyBwcm9wZXJ0eSB2YWx1ZSBmb3IgdGhlIGdpdmVuXG4gICAgICAgKiBgcHJvcGVydHlgLlxuICAgICAgICovXG4gICAgICBnZXRDb21wdXRlZFN0eWxlVmFsdWUocHJvcGVydHkpIHtcbiAgICAgICAgcmV0dXJuIHN0eWxlSW50ZXJmYWNlLmdldENvbXB1dGVkU3R5bGVWYWx1ZSh0aGlzLCBwcm9wZXJ0eSk7XG4gICAgICB9XG5cbiAgICAgIC8vIGRlYm91bmNlXG5cbiAgICAgIC8qKlxuICAgICAgICogQ2FsbCBgZGVib3VuY2VgIHRvIGNvbGxhcHNlIG11bHRpcGxlIHJlcXVlc3RzIGZvciBhIG5hbWVkIHRhc2sgaW50b1xuICAgICAgICogb25lIGludm9jYXRpb24gd2hpY2ggaXMgbWFkZSBhZnRlciB0aGUgd2FpdCB0aW1lIGhhcyBlbGFwc2VkIHdpdGhcbiAgICAgICAqIG5vIG5ldyByZXF1ZXN0LiAgSWYgbm8gd2FpdCB0aW1lIGlzIGdpdmVuLCB0aGUgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWRcbiAgICAgICAqIGF0IG1pY3JvdGFzayB0aW1pbmcgKGd1YXJhbnRlZWQgYmVmb3JlIHBhaW50KS5cbiAgICAgICAqXG4gICAgICAgKiAgICAgZGVib3VuY2VkQ2xpY2tBY3Rpb24oZSkge1xuICAgICAgICogICAgICAgLy8gd2lsbCBub3QgY2FsbCBgcHJvY2Vzc0NsaWNrYCBtb3JlIHRoYW4gb25jZSBwZXIgMTAwbXNcbiAgICAgICAqICAgICAgIHRoaXMuZGVib3VuY2UoJ2NsaWNrJywgZnVuY3Rpb24oKSB7XG4gICAgICAgKiAgICAgICAgdGhpcy5wcm9jZXNzQ2xpY2soKTtcbiAgICAgICAqICAgICAgIH0gMTAwKTtcbiAgICAgICAqICAgICB9XG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGpvYk5hbWUgU3RyaW5nIHRvIGluZGVudGlmeSB0aGUgZGVib3VuY2Ugam9iLlxuICAgICAgICogQHBhcmFtIHtmdW5jdGlvbigpfSBjYWxsYmFjayBGdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCAod2l0aCBgdGhpc2BcbiAgICAgICAqICAgY29udGV4dCkgd2hlbiB0aGUgd2FpdCB0aW1lIGVsYXBzZXMuXG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0gd2FpdCBPcHRpb25hbCB3YWl0IHRpbWUgaW4gbWlsbGlzZWNvbmRzIChtcykgYWZ0ZXIgdGhlXG4gICAgICAgKiAgIGxhc3Qgc2lnbmFsIHRoYXQgbXVzdCBlbGFwc2UgYmVmb3JlIGludm9raW5nIGBjYWxsYmFja2BcbiAgICAgICAqIEByZXR1cm4ge09iamVjdH0gUmV0dXJucyBhIGRlYm91bmNlciBvYmplY3Qgb24gd2hpY2ggZXhpc3RzIHRoZVxuICAgICAgICogZm9sbG93aW5nIG1ldGhvZHM6IGBpc0FjdGl2ZSgpYCByZXR1cm5zIHRydWUgaWYgdGhlIGRlYm91bmNlciBpc1xuICAgICAgICogYWN0aXZlOyBgY2FuY2VsKClgIGNhbmNlbHMgdGhlIGRlYm91bmNlciBpZiBpdCBpcyBhY3RpdmU7XG4gICAgICAgKiBgZmx1c2goKWAgaW1tZWRpYXRlbHkgaW52b2tlcyB0aGUgZGVib3VuY2VkIGNhbGxiYWNrIGlmIHRoZSBkZWJvdW5jZXJcbiAgICAgICAqIGlzIGFjdGl2ZS5cbiAgICAgICAqL1xuICAgICAgZGVib3VuY2Uoam9iTmFtZSwgY2FsbGJhY2ssIHdhaXQpIHtcbiAgICAgICAgdGhpcy5fZGVib3VuY2VycyA9IHRoaXMuX2RlYm91bmNlcnMgfHwge307XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWJvdW5jZXJzW2pvYk5hbWVdID0gUG9seW1lci5EZWJvdW5jZXIuZGVib3VuY2UoXG4gICAgICAgICAgICAgIHRoaXMuX2RlYm91bmNlcnNbam9iTmFtZV1cbiAgICAgICAgICAgICwgd2FpdCA+IDAgPyBQb2x5bWVyLkFzeW5jLnRpbWVPdXQuYWZ0ZXIod2FpdCkgOiBQb2x5bWVyLkFzeW5jLm1pY3JvVGFza1xuICAgICAgICAgICAgLCBjYWxsYmFjay5iaW5kKHRoaXMpKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZXR1cm5zIHdoZXRoZXIgYSBuYW1lZCBkZWJvdW5jZXIgaXMgYWN0aXZlLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBqb2JOYW1lIFRoZSBuYW1lIG9mIHRoZSBkZWJvdW5jZXIgc3RhcnRlZCB3aXRoIGBkZWJvdW5jZWBcbiAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIGRlYm91bmNlciBpcyBhY3RpdmUgKGhhcyBub3QgeWV0IGZpcmVkKS5cbiAgICAgICAqL1xuICAgICAgaXNEZWJvdW5jZXJBY3RpdmUoam9iTmFtZSkge1xuICAgICAgICB0aGlzLl9kZWJvdW5jZXJzID0gdGhpcy5fZGVib3VuY2VycyB8fCB7fTtcbiAgICAgICAgbGV0IGRlYm91bmNlciA9IHRoaXMuX2RlYm91bmNlcnNbam9iTmFtZV07XG4gICAgICAgIHJldHVybiAhIShkZWJvdW5jZXIgJiYgZGVib3VuY2VyLmlzQWN0aXZlKCkpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEltbWVkaWF0ZWx5IGNhbGxzIHRoZSBkZWJvdW5jZXIgYGNhbGxiYWNrYCBhbmQgaW5hY3RpdmF0ZXMgaXQuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGpvYk5hbWUgVGhlIG5hbWUgb2YgdGhlIGRlYm91bmNlciBzdGFydGVkIHdpdGggYGRlYm91bmNlYFxuICAgICAgICovXG4gICAgICBmbHVzaERlYm91bmNlcihqb2JOYW1lKSB7XG4gICAgICAgIHRoaXMuX2RlYm91bmNlcnMgPSB0aGlzLl9kZWJvdW5jZXJzIHx8IHt9O1xuICAgICAgICBsZXQgZGVib3VuY2VyID0gdGhpcy5fZGVib3VuY2Vyc1tqb2JOYW1lXTtcbiAgICAgICAgaWYgKGRlYm91bmNlcikge1xuICAgICAgICAgIGRlYm91bmNlci5mbHVzaCgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ2FuY2VscyBhbiBhY3RpdmUgZGVib3VuY2VyLiAgVGhlIGBjYWxsYmFja2Agd2lsbCBub3QgYmUgY2FsbGVkLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBqb2JOYW1lIFRoZSBuYW1lIG9mIHRoZSBkZWJvdW5jZXIgc3RhcnRlZCB3aXRoIGBkZWJvdW5jZWBcbiAgICAgICAqL1xuICAgICAgY2FuY2VsRGVib3VuY2VyKGpvYk5hbWUpIHtcbiAgICAgICAgdGhpcy5fZGVib3VuY2VycyA9IHRoaXMuX2RlYm91bmNlcnMgfHwge31cbiAgICAgICAgbGV0IGRlYm91bmNlciA9IHRoaXMuX2RlYm91bmNlcnNbam9iTmFtZV07XG4gICAgICAgIGlmIChkZWJvdW5jZXIpIHtcbiAgICAgICAgICBkZWJvdW5jZXIuY2FuY2VsKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSdW5zIGEgY2FsbGJhY2sgZnVuY3Rpb24gYXN5bmNyb25vdXNseS5cbiAgICAgICAqXG4gICAgICAgKiBCeSBkZWZhdWx0IChpZiBubyB3YWl0VGltZSBpcyBzcGVjaWZpZWQpLCBhc3luYyBjYWxsYmFja3MgYXJlIHJ1biBhdFxuICAgICAgICogbWljcm90YXNrIHRpbWluZywgd2hpY2ggd2lsbCBvY2N1ciBiZWZvcmUgcGFpbnQuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIHJ1biwgYm91bmQgdG8gYHRoaXNgLlxuICAgICAgICogQHBhcmFtIHtudW1iZXI9fSB3YWl0VGltZSBUaW1lIHRvIHdhaXQgYmVmb3JlIGNhbGxpbmcgdGhlXG4gICAgICAgKiAgIGBjYWxsYmFja2AuICBJZiB1bnNwZWNpZmllZCBvciAwLCB0aGUgY2FsbGJhY2sgd2lsbCBiZSBydW4gYXQgbWljcm90YXNrXG4gICAgICAgKiAgIHRpbWluZyAoYmVmb3JlIHBhaW50KS5cbiAgICAgICAqIEByZXR1cm4ge251bWJlcn0gSGFuZGxlIHRoYXQgbWF5IGJlIHVzZWQgdG8gY2FuY2VsIHRoZSBhc3luYyBqb2IuXG4gICAgICAgKi9cbiAgICAgIGFzeW5jKGNhbGxiYWNrLCB3YWl0VGltZSkge1xuICAgICAgICByZXR1cm4gd2FpdFRpbWUgPiAwID8gUG9seW1lci5Bc3luYy50aW1lT3V0LnJ1bihjYWxsYmFjay5iaW5kKHRoaXMpLCB3YWl0VGltZSkgOlxuICAgICAgICAgICAgflBvbHltZXIuQXN5bmMubWljcm9UYXNrLnJ1bihjYWxsYmFjay5iaW5kKHRoaXMpKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDYW5jZWxzIGFuIGFzeW5jIG9wZXJhdGlvbiBzdGFydGVkIHdpdGggYGFzeW5jYC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0gaGFuZGxlIEhhbmRsZSByZXR1cm5lZCBmcm9tIG9yaWdpbmFsIGBhc3luY2AgY2FsbCB0b1xuICAgICAgICogICBjYW5jZWwuXG4gICAgICAgKi9cbiAgICAgIGNhbmNlbEFzeW5jKGhhbmRsZSkge1xuICAgICAgICBoYW5kbGUgPCAwID8gUG9seW1lci5Bc3luYy5taWNyb1Rhc2suY2FuY2VsKH5oYW5kbGUpIDpcbiAgICAgICAgICAgIFBvbHltZXIuQXN5bmMudGltZU91dC5jYW5jZWwoaGFuZGxlKTtcbiAgICAgIH1cblxuICAgICAgLy8gb3RoZXJcblxuICAgICAgLyoqXG4gICAgICAgKiBDb252ZW5pZW5jZSBtZXRob2QgZm9yIGNyZWF0aW5nIGFuIGVsZW1lbnQgYW5kIGNvbmZpZ3VyaW5nIGl0LlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgSFRNTCBlbGVtZW50IHRhZyB0byBjcmVhdGUuXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgT2JqZWN0IG9mIHByb3BlcnRpZXMgdG8gY29uZmlndXJlIG9uIHRoZVxuICAgICAgICogICAgaW5zdGFuY2UuXG4gICAgICAgKiBAcmV0dXJuIHtFbGVtZW50fSBOZXdseSBjcmVhdGVkIGFuZCBjb25maWd1cmVkIGVsZW1lbnQuXG4gICAgICAgKi9cbiAgICAgIGNyZWF0ZSh0YWcsIHByb3BzKSB7XG4gICAgICAgIGxldCBlbHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIGlmIChwcm9wcykge1xuICAgICAgICAgIGlmIChlbHQuc2V0UHJvcGVydGllcykge1xuICAgICAgICAgICAgZWx0LnNldFByb3BlcnRpZXMocHJvcHMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGxldCBuIGluIHByb3BzKSB7XG4gICAgICAgICAgICAgIGVsdFtuXSA9IHByb3BzW25dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZWx0O1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENvbnZlbmllbmNlIG1ldGhvZCBmb3IgaW1wb3J0aW5nIGFuIEhUTUwgZG9jdW1lbnQgaW1wZXJhdGl2ZWx5LlxuICAgICAgICpcbiAgICAgICAqIFRoaXMgbWV0aG9kIGNyZWF0ZXMgYSBuZXcgYDxsaW5rIHJlbD1cImltcG9ydFwiPmAgZWxlbWVudCB3aXRoXG4gICAgICAgKiB0aGUgcHJvdmlkZWQgVVJMIGFuZCBhcHBlbmRzIGl0IHRvIHRoZSBkb2N1bWVudCB0byBzdGFydCBsb2FkaW5nLlxuICAgICAgICogSW4gdGhlIGBvbmxvYWRgIGNhbGxiYWNrLCB0aGUgYGltcG9ydGAgcHJvcGVydHkgb2YgdGhlIGBsaW5rYFxuICAgICAgICogZWxlbWVudCB3aWxsIGNvbnRhaW4gdGhlIGltcG9ydGVkIGRvY3VtZW50IGNvbnRlbnRzLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBocmVmIFVSTCB0byBkb2N1bWVudCB0byBsb2FkLlxuICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gb25sb2FkIENhbGxiYWNrIHRvIG5vdGlmeSB3aGVuIGFuIGltcG9ydCBzdWNjZXNzZnVsbHlcbiAgICAgICAqICAgbG9hZGVkLlxuICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gb25lcnJvciBDYWxsYmFjayB0byBub3RpZnkgd2hlbiBhbiBpbXBvcnRcbiAgICAgICAqICAgdW5zdWNjZXNzZnVsbHkgbG9hZGVkLlxuICAgICAgICogQHBhcmFtIHtib29sZWFufSBvcHRBc3luYyBUcnVlIGlmIHRoZSBpbXBvcnQgc2hvdWxkIGJlIGxvYWRlZCBgYXN5bmNgLlxuICAgICAgICogICBEZWZhdWx0cyB0byBgZmFsc2VgLlxuICAgICAgICogQHJldHVybiB7SFRNTExpbmtFbGVtZW50fSBUaGUgbGluayBlbGVtZW50IGZvciB0aGUgVVJMIHRvIGJlIGxvYWRlZC5cbiAgICAgICAqL1xuICAgICAgaW1wb3J0SHJlZihocmVmLCBvbmxvYWQsIG9uZXJyb3IsIG9wdEFzeW5jKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgICAgbGV0IGxvYWRGbiA9IG9ubG9hZCA/IG9ubG9hZC5iaW5kKHRoaXMpIDogbnVsbDtcbiAgICAgICAgbGV0IGVycm9yRm4gPSBvbmVycm9yID8gb25lcnJvci5iaW5kKHRoaXMpIDogbnVsbDtcbiAgICAgICAgcmV0dXJuIFBvbHltZXIuaW1wb3J0SHJlZihocmVmLCBsb2FkRm4sIGVycm9yRm4sIG9wdEFzeW5jKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBQb2x5ZmlsbCBmb3IgRWxlbWVudC5wcm90b3R5cGUubWF0Y2hlcywgd2hpY2ggaXMgc29tZXRpbWVzIHN0aWxsXG4gICAgICAgKiBwcmVmaXhlZC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3IgU2VsZWN0b3IgdG8gdGVzdC5cbiAgICAgICAqIEBwYXJhbSB7RWxlbWVudD19IG5vZGUgRWxlbWVudCB0byB0ZXN0IHRoZSBzZWxlY3RvciBhZ2FpbnN0LlxuICAgICAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgZWxlbWVudCBtYXRjaGVzIHRoZSBzZWxlY3Rvci5cbiAgICAgICAqL1xuICAgICAgZWxlbWVudE1hdGNoZXMoc2VsZWN0b3IsIG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIFBvbHltZXIuZG9tLm1hdGNoZXNTZWxlY3RvcigvKiogQHR5cGUgeyFFbGVtZW50fSAqLyAobm9kZSB8fCB0aGlzKSwgc2VsZWN0b3IpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFRvZ2dsZXMgYW4gSFRNTCBhdHRyaWJ1dGUgb24gb3Igb2ZmLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIEhUTUwgYXR0cmlidXRlIG5hbWVcbiAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IGJvb2wgQm9vbGVhbiB0byBmb3JjZSB0aGUgYXR0cmlidXRlIG9uIG9yIG9mZi5cbiAgICAgICAqICAgIFdoZW4gdW5zcGVjaWZpZWQsIHRoZSBzdGF0ZSBvZiB0aGUgYXR0cmlidXRlIHdpbGwgYmUgcmV2ZXJzZWQuXG4gICAgICAgKiBAcGFyYW0ge0VsZW1lbnQ9fSBub2RlIE5vZGUgdG8gdGFyZ2V0LiAgRGVmYXVsdHMgdG8gYHRoaXNgLlxuICAgICAgICovXG4gICAgICB0b2dnbGVBdHRyaWJ1dGUobmFtZSwgYm9vbCwgbm9kZSkge1xuICAgICAgICBub2RlID0gLyoqIEB0eXBlIHtFbGVtZW50fSAqLyAobm9kZSB8fCB0aGlzKTtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMSkge1xuICAgICAgICAgIGJvb2wgPSAhbm9kZS5oYXNBdHRyaWJ1dGUobmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJvb2wpIHtcbiAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShuYW1lLCAnJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuXG4gICAgICAvKipcbiAgICAgICAqIFRvZ2dsZXMgYSBDU1MgY2xhc3Mgb24gb3Igb2ZmLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIENTUyBjbGFzcyBuYW1lXG4gICAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBib29sIEJvb2xlYW4gdG8gZm9yY2UgdGhlIGNsYXNzIG9uIG9yIG9mZi5cbiAgICAgICAqICAgIFdoZW4gdW5zcGVjaWZpZWQsIHRoZSBzdGF0ZSBvZiB0aGUgY2xhc3Mgd2lsbCBiZSByZXZlcnNlZC5cbiAgICAgICAqIEBwYXJhbSB7RWxlbWVudD19IG5vZGUgTm9kZSB0byB0YXJnZXQuICBEZWZhdWx0cyB0byBgdGhpc2AuXG4gICAgICAgKi9cbiAgICAgIHRvZ2dsZUNsYXNzKG5hbWUsIGJvb2wsIG5vZGUpIHtcbiAgICAgICAgbm9kZSA9IC8qKiBAdHlwZSB7RWxlbWVudH0gKi8gKG5vZGUgfHwgdGhpcyk7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICBib29sID0gIW5vZGUuY2xhc3NMaXN0LmNvbnRhaW5zKG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChib29sKSB7XG4gICAgICAgICAgbm9kZS5jbGFzc0xpc3QuYWRkKG5hbWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGUuY2xhc3NMaXN0LnJlbW92ZShuYW1lKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENyb3NzLXBsYXRmb3JtIGhlbHBlciBmb3Igc2V0dGluZyBhbiBlbGVtZW50J3MgQ1NTIGB0cmFuc2Zvcm1gIHByb3BlcnR5LlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0cmFuc2Zvcm1UZXh0IFRyYW5zZm9ybSBzZXR0aW5nLlxuICAgICAgICogQHBhcmFtIHtFbGVtZW50PX0gbm9kZSBFbGVtZW50IHRvIGFwcGx5IHRoZSB0cmFuc2Zvcm0gdG8uXG4gICAgICAgKiBEZWZhdWx0cyB0byBgdGhpc2BcbiAgICAgICAqL1xuICAgICAgdHJhbnNmb3JtKHRyYW5zZm9ybVRleHQsIG5vZGUpIHtcbiAgICAgICAgbm9kZSA9IC8qKiBAdHlwZSB7RWxlbWVudH0gKi8gKG5vZGUgfHwgdGhpcyk7XG4gICAgICAgIG5vZGUuc3R5bGUud2Via2l0VHJhbnNmb3JtID0gdHJhbnNmb3JtVGV4dDtcbiAgICAgICAgbm9kZS5zdHlsZS50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1UZXh0O1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENyb3NzLXBsYXRmb3JtIGhlbHBlciBmb3Igc2V0dGluZyBhbiBlbGVtZW50J3MgQ1NTIGB0cmFuc2xhdGUzZGBcbiAgICAgICAqIHByb3BlcnR5LlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IFggb2Zmc2V0LlxuICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHkgWSBvZmZzZXQuXG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0geiBaIG9mZnNldC5cbiAgICAgICAqIEBwYXJhbSB7RWxlbWVudD19IG5vZGUgRWxlbWVudCB0byBhcHBseSB0aGUgdHJhbnNmb3JtIHRvLlxuICAgICAgICogRGVmYXVsdHMgdG8gYHRoaXNgLlxuICAgICAgICovXG4gICAgICB0cmFuc2xhdGUzZCh4LCB5LCB6LCBub2RlKSB7XG4gICAgICAgIG5vZGUgPSAvKiogQHR5cGUge0VsZW1lbnR9ICovIChub2RlIHx8IHRoaXMpO1xuICAgICAgICB0aGlzLnRyYW5zZm9ybSgndHJhbnNsYXRlM2QoJyArIHggKyAnLCcgKyB5ICsgJywnICsgeiArICcpJywgbm9kZSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUmVtb3ZlcyBhbiBpdGVtIGZyb20gYW4gYXJyYXksIGlmIGl0IGV4aXN0cy5cbiAgICAgICAqXG4gICAgICAgKiBJZiB0aGUgYXJyYXkgaXMgc3BlY2lmaWVkIGJ5IHBhdGgsIGEgY2hhbmdlIG5vdGlmaWNhdGlvbiBpc1xuICAgICAgICogZ2VuZXJhdGVkLCBzbyB0aGF0IG9ic2VydmVycywgZGF0YSBiaW5kaW5ncyBhbmQgY29tcHV0ZWRcbiAgICAgICAqIHByb3BlcnRpZXMgd2F0Y2hpbmcgdGhhdCBwYXRoIGNhbiB1cGRhdGUuXG4gICAgICAgKlxuICAgICAgICogSWYgdGhlIGFycmF5IGlzIHBhc3NlZCBkaXJlY3RseSwgKipubyBjaGFuZ2VcbiAgICAgICAqIG5vdGlmaWNhdGlvbiBpcyBnZW5lcmF0ZWQqKi5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZyB8ICFBcnJheTxudW1iZXJ8c3RyaW5nPn0gYXJyYXlPclBhdGggUGF0aCB0byBhcnJheSBmcm9tIHdoaWNoIHRvIHJlbW92ZSB0aGUgaXRlbVxuICAgICAgICogICAob3IgdGhlIGFycmF5IGl0c2VsZikuXG4gICAgICAgKiBAcGFyYW0geyp9IGl0ZW0gSXRlbSB0byByZW1vdmUuXG4gICAgICAgKiBAcmV0dXJuIHtBcnJheX0gQXJyYXkgY29udGFpbmluZyBpdGVtIHJlbW92ZWQuXG4gICAgICAgKi9cbiAgICAgIGFycmF5RGVsZXRlKGFycmF5T3JQYXRoLCBpdGVtKSB7XG4gICAgICAgIGxldCBpbmRleDtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJyYXlPclBhdGgpKSB7XG4gICAgICAgICAgaW5kZXggPSBhcnJheU9yUGF0aC5pbmRleE9mKGl0ZW0pO1xuICAgICAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJyYXlPclBhdGguc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGV0IGFyciA9IFBvbHltZXIuUGF0aC5nZXQodGhpcywgYXJyYXlPclBhdGgpO1xuICAgICAgICAgIGluZGV4ID0gYXJyLmluZGV4T2YoaXRlbSk7XG4gICAgICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNwbGljZShhcnJheU9yUGF0aCwgaW5kZXgsIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgLy8gbG9nZ2luZ1xuXG4gICAgICAvKipcbiAgICAgICAqIEZhY2FkZXMgYGNvbnNvbGUubG9nYC9gd2FybmAvYGVycm9yYCBhcyBvdmVycmlkZSBwb2ludC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbGV2ZWwgT25lIG9mICdsb2cnLCAnd2FybicsICdlcnJvcidcbiAgICAgICAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgQXJyYXkgb2Ygc3RyaW5ncyBvciBvYmplY3RzIHRvIGxvZ1xuICAgICAgICovXG4gICAgICBfbG9nZ2VyKGxldmVsLCBhcmdzKSB7XG4gICAgICAgIC8vIGFjY2VwdCBbJ2ZvbycsICdiYXInXSBhbmQgW1snZm9vJywgJ2JhciddXVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhcmdzKSAmJiBhcmdzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIGFyZ3MgPSBhcmdzWzBdO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaChsZXZlbCkge1xuICAgICAgICAgIGNhc2UgJ2xvZyc6XG4gICAgICAgICAgY2FzZSAnd2Fybic6XG4gICAgICAgICAgY2FzZSAnZXJyb3InOlxuICAgICAgICAgICAgY29uc29sZVtsZXZlbF0oLi4uYXJncyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBGYWNhZGVzIGBjb25zb2xlLmxvZ2AgYXMgYW4gb3ZlcnJpZGUgcG9pbnQuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHsuLi4qfSBhcmdzIEFycmF5IG9mIHN0cmluZ3Mgb3Igb2JqZWN0cyB0byBsb2dcbiAgICAgICAqL1xuICAgICAgX2xvZyguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuX2xvZ2dlcignbG9nJywgYXJncyk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogRmFjYWRlcyBgY29uc29sZS53YXJuYCBhcyBhbiBvdmVycmlkZSBwb2ludC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0gey4uLip9IGFyZ3MgQXJyYXkgb2Ygc3RyaW5ncyBvciBvYmplY3RzIHRvIGxvZ1xuICAgICAgICovXG4gICAgICBfd2FybiguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuX2xvZ2dlcignd2FybicsIGFyZ3MpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEZhY2FkZXMgYGNvbnNvbGUuZXJyb3JgIGFzIGFuIG92ZXJyaWRlIHBvaW50LlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7Li4uKn0gYXJncyBBcnJheSBvZiBzdHJpbmdzIG9yIG9iamVjdHMgdG8gbG9nXG4gICAgICAgKi9cbiAgICAgIF9lcnJvciguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuX2xvZ2dlcignZXJyb3InLCBhcmdzKVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEZvcm1hdHMgYSBtZXNzYWdlIHVzaW5nIHRoZSBlbGVtZW50IHR5cGUgYW4gYSBtZXRob2QgbmFtZS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kTmFtZSBNZXRob2QgbmFtZSB0byBhc3NvY2lhdGUgd2l0aCBtZXNzYWdlXG4gICAgICAgKiBAcGFyYW0gey4uLip9IGFyZ3MgQXJyYXkgb2Ygc3RyaW5ncyBvciBvYmplY3RzIHRvIGxvZ1xuICAgICAgICogQHJldHVybiB7QXJyYXl9IEFycmF5IHdpdGggZm9ybWF0dGluZyBpbmZvcm1hdGlvbiBmb3IgYGNvbnNvbGVgXG4gICAgICAgKiAgIGxvZ2dpbmcuXG4gICAgICAgKi9cbiAgICAgIF9sb2dmKG1ldGhvZE5hbWUsIC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIFsnWyVzOjolc10nLCB0aGlzLmlzLCBtZXRob2ROYW1lLCAuLi5hcmdzXTtcbiAgICAgIH1cblxuICAgIH1cblxuICAgIExlZ2FjeUVsZW1lbnQucHJvdG90eXBlLmlzID0gJyc7XG5cbiAgICByZXR1cm4gTGVnYWN5RWxlbWVudDtcblxuICB9KTtcblxufSkoKTtcbjwvc2NyaXB0PlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi9sZWdhY3kvbGVnYWN5LWVsZW1lbnQtbWl4aW4uaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi91dGlscy9ib290Lmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi91dGlscy9taXhpbi5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vdXRpbHMvZ2VzdHVyZXMuaHRtbFwiPlxuXG48c2NyaXB0PlxuKGZ1bmN0aW9uKCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICAvKipcbiAgICogQGNvbnN0IHtQb2x5bWVyLkdlc3R1cmVzfVxuICAgKi9cbiAgY29uc3QgZ2VzdHVyZXMgPSBQb2x5bWVyLkdlc3R1cmVzO1xuXG4gIC8qKlxuICAgKiBFbGVtZW50IGNsYXNzIG1peGluIHRoYXQgcHJvdmlkZXMgQVBJIGZvciBhZGRpbmcgUG9seW1lcidzIGNyb3NzLXBsYXRmb3JtXG4gICAqIGdlc3R1cmUgZXZlbnRzIHRvIG5vZGVzLlxuICAgKlxuICAgKiBUaGUgQVBJIGlzIGRlc2lnbmVkIHRvIGJlIGNvbXBhdGlibGUgd2l0aCBvdmVycmlkZSBwb2ludHMgaW1wbGVtZW50ZWRcbiAgICogaW4gYFBvbHltZXIuVGVtcGxhdGVTdGFtcGAgc3VjaCB0aGF0IGRlY2xhcmF0aXZlIGV2ZW50IGxpc3RlbmVycyBpblxuICAgKiB0ZW1wbGF0ZXMgd2lsbCBzdXBwb3J0IGdlc3R1cmUgZXZlbnRzIHdoZW4gdGhpcyBtaXhpbiBpcyBhcHBsaWVkIGFsb25nIHdpdGhcbiAgICogYFBvbHltZXIuVGVtcGxhdGVTdGFtcGAuXG4gICAqXG4gICAqIEBtaXhpbkZ1bmN0aW9uXG4gICAqIEBwb2x5bWVyXG4gICAqIEBtZW1iZXJvZiBQb2x5bWVyXG4gICAqIEBzdW1tYXJ5IEVsZW1lbnQgY2xhc3MgbWl4aW4gdGhhdCBwcm92aWRlcyBBUEkgZm9yIGFkZGluZyBQb2x5bWVyJ3MgY3Jvc3MtcGxhdGZvcm1cbiAgICogZ2VzdHVyZSBldmVudHMgdG8gbm9kZXNcbiAgICovXG4gIFBvbHltZXIuR2VzdHVyZUV2ZW50TGlzdGVuZXJzID0gUG9seW1lci5kZWR1cGluZ01peGluKHN1cGVyQ2xhc3MgPT4ge1xuXG4gICAgLyoqXG4gICAgICogQHBvbHltZXJcbiAgICAgKiBAbWl4aW5DbGFzc1xuICAgICAqIEBpbXBsZW1lbnRzIHtQb2x5bWVyX0dlc3R1cmVFdmVudExpc3RlbmVyc31cbiAgICAgKi9cbiAgICBjbGFzcyBHZXN0dXJlRXZlbnRMaXN0ZW5lcnMgZXh0ZW5kcyBzdXBlckNsYXNzIHtcblxuICAgICAgX2FkZEV2ZW50TGlzdGVuZXJUb05vZGUobm9kZSwgZXZlbnROYW1lLCBoYW5kbGVyKSB7XG4gICAgICAgIGlmICghZ2VzdHVyZXMuYWRkTGlzdGVuZXIobm9kZSwgZXZlbnROYW1lLCBoYW5kbGVyKSkge1xuICAgICAgICAgIHN1cGVyLl9hZGRFdmVudExpc3RlbmVyVG9Ob2RlKG5vZGUsIGV2ZW50TmFtZSwgaGFuZGxlcik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgX3JlbW92ZUV2ZW50TGlzdGVuZXJGcm9tTm9kZShub2RlLCBldmVudE5hbWUsIGhhbmRsZXIpIHtcbiAgICAgICAgaWYgKCFnZXN0dXJlcy5yZW1vdmVMaXN0ZW5lcihub2RlLCBldmVudE5hbWUsIGhhbmRsZXIpKSB7XG4gICAgICAgICAgc3VwZXIuX3JlbW92ZUV2ZW50TGlzdGVuZXJGcm9tTm9kZShub2RlLCBldmVudE5hbWUsIGhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICB9XG5cbiAgICByZXR1cm4gR2VzdHVyZUV2ZW50TGlzdGVuZXJzO1xuXG4gIH0pO1xuXG59KSgpO1xuPC9zY3JpcHQ+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL3BvbHltZXIvbGliL21peGlucy9nZXN0dXJlLWV2ZW50LWxpc3RlbmVycy5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cImJvb3QuaHRtbFwiPlxuPHNjcmlwdD5cbihmdW5jdGlvbigpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgZnVuY3Rpb24gbmV3U3BsaWNlKGluZGV4LCByZW1vdmVkLCBhZGRlZENvdW50KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgIHJlbW92ZWQ6IHJlbW92ZWQsXG4gICAgICBhZGRlZENvdW50OiBhZGRlZENvdW50XG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0IEVESVRfTEVBVkUgPSAwO1xuICBjb25zdCBFRElUX1VQREFURSA9IDE7XG4gIGNvbnN0IEVESVRfQUREID0gMjtcbiAgY29uc3QgRURJVF9ERUxFVEUgPSAzO1xuXG4gIC8vIE5vdGU6IFRoaXMgZnVuY3Rpb24gaXMgKmJhc2VkKiBvbiB0aGUgY29tcHV0YXRpb24gb2YgdGhlIExldmVuc2h0ZWluXG4gIC8vIFwiZWRpdFwiIGRpc3RhbmNlLiBUaGUgb25lIGNoYW5nZSBpcyB0aGF0IFwidXBkYXRlc1wiIGFyZSB0cmVhdGVkIGFzIHR3b1xuICAvLyBlZGl0cyAtIG5vdCBvbmUuIFdpdGggQXJyYXkgc3BsaWNlcywgYW4gdXBkYXRlIGlzIHJlYWxseSBhIGRlbGV0ZVxuICAvLyBmb2xsb3dlZCBieSBhbiBhZGQuIEJ5IHJldGFpbmluZyB0aGlzLCB3ZSBvcHRpbWl6ZSBmb3IgXCJrZWVwaW5nXCIgdGhlXG4gIC8vIG1heGltdW0gYXJyYXkgaXRlbXMgaW4gdGhlIG9yaWdpbmFsIGFycmF5LiBGb3IgZXhhbXBsZTpcbiAgLy9cbiAgLy8gICAneHh4eDEyMycgLT4gJzEyM3l5eXknXG4gIC8vXG4gIC8vIFdpdGggMS1lZGl0IHVwZGF0ZXMsIHRoZSBzaG9ydGVzdCBwYXRoIHdvdWxkIGJlIGp1c3QgdG8gdXBkYXRlIGFsbCBzZXZlblxuICAvLyBjaGFyYWN0ZXJzLiBXaXRoIDItZWRpdCB1cGRhdGVzLCB3ZSBkZWxldGUgNCwgbGVhdmUgMywgYW5kIGFkZCA0LiBUaGlzXG4gIC8vIGxlYXZlcyB0aGUgc3Vic3RyaW5nICcxMjMnIGludGFjdC5cbiAgZnVuY3Rpb24gY2FsY0VkaXREaXN0YW5jZXMoY3VycmVudCwgY3VycmVudFN0YXJ0LCBjdXJyZW50RW5kLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2xkLCBvbGRTdGFydCwgb2xkRW5kKSB7XG4gICAgLy8gXCJEZWxldGlvblwiIGNvbHVtbnNcbiAgICBsZXQgcm93Q291bnQgPSBvbGRFbmQgLSBvbGRTdGFydCArIDE7XG4gICAgbGV0IGNvbHVtbkNvdW50ID0gY3VycmVudEVuZCAtIGN1cnJlbnRTdGFydCArIDE7XG4gICAgbGV0IGRpc3RhbmNlcyA9IG5ldyBBcnJheShyb3dDb3VudCk7XG5cbiAgICAvLyBcIkFkZGl0aW9uXCIgcm93cy4gSW5pdGlhbGl6ZSBudWxsIGNvbHVtbi5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJvd0NvdW50OyBpKyspIHtcbiAgICAgIGRpc3RhbmNlc1tpXSA9IG5ldyBBcnJheShjb2x1bW5Db3VudCk7XG4gICAgICBkaXN0YW5jZXNbaV1bMF0gPSBpO1xuICAgIH1cblxuICAgIC8vIEluaXRpYWxpemUgbnVsbCByb3dcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNvbHVtbkNvdW50OyBqKyspXG4gICAgICBkaXN0YW5jZXNbMF1bal0gPSBqO1xuXG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCByb3dDb3VudDsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqID0gMTsgaiA8IGNvbHVtbkNvdW50OyBqKyspIHtcbiAgICAgICAgaWYgKGVxdWFscyhjdXJyZW50W2N1cnJlbnRTdGFydCArIGogLSAxXSwgb2xkW29sZFN0YXJ0ICsgaSAtIDFdKSlcbiAgICAgICAgICBkaXN0YW5jZXNbaV1bal0gPSBkaXN0YW5jZXNbaSAtIDFdW2ogLSAxXTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgbGV0IG5vcnRoID0gZGlzdGFuY2VzW2kgLSAxXVtqXSArIDE7XG4gICAgICAgICAgbGV0IHdlc3QgPSBkaXN0YW5jZXNbaV1baiAtIDFdICsgMTtcbiAgICAgICAgICBkaXN0YW5jZXNbaV1bal0gPSBub3J0aCA8IHdlc3QgPyBub3J0aCA6IHdlc3Q7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZGlzdGFuY2VzO1xuICB9XG5cbiAgLy8gVGhpcyBzdGFydHMgYXQgdGhlIGZpbmFsIHdlaWdodCwgYW5kIHdhbGtzIFwiYmFja3dhcmRcIiBieSBmaW5kaW5nXG4gIC8vIHRoZSBtaW5pbXVtIHByZXZpb3VzIHdlaWdodCByZWN1cnNpdmVseSB1bnRpbCB0aGUgb3JpZ2luIG9mIHRoZSB3ZWlnaHRcbiAgLy8gbWF0cml4LlxuICBmdW5jdGlvbiBzcGxpY2VPcGVyYXRpb25zRnJvbUVkaXREaXN0YW5jZXMoZGlzdGFuY2VzKSB7XG4gICAgbGV0IGkgPSBkaXN0YW5jZXMubGVuZ3RoIC0gMTtcbiAgICBsZXQgaiA9IGRpc3RhbmNlc1swXS5sZW5ndGggLSAxO1xuICAgIGxldCBjdXJyZW50ID0gZGlzdGFuY2VzW2ldW2pdO1xuICAgIGxldCBlZGl0cyA9IFtdO1xuICAgIHdoaWxlIChpID4gMCB8fCBqID4gMCkge1xuICAgICAgaWYgKGkgPT0gMCkge1xuICAgICAgICBlZGl0cy5wdXNoKEVESVRfQUREKTtcbiAgICAgICAgai0tO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChqID09IDApIHtcbiAgICAgICAgZWRpdHMucHVzaChFRElUX0RFTEVURSk7XG4gICAgICAgIGktLTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBsZXQgbm9ydGhXZXN0ID0gZGlzdGFuY2VzW2kgLSAxXVtqIC0gMV07XG4gICAgICBsZXQgd2VzdCA9IGRpc3RhbmNlc1tpIC0gMV1bal07XG4gICAgICBsZXQgbm9ydGggPSBkaXN0YW5jZXNbaV1baiAtIDFdO1xuXG4gICAgICBsZXQgbWluO1xuICAgICAgaWYgKHdlc3QgPCBub3J0aClcbiAgICAgICAgbWluID0gd2VzdCA8IG5vcnRoV2VzdCA/IHdlc3QgOiBub3J0aFdlc3Q7XG4gICAgICBlbHNlXG4gICAgICAgIG1pbiA9IG5vcnRoIDwgbm9ydGhXZXN0ID8gbm9ydGggOiBub3J0aFdlc3Q7XG5cbiAgICAgIGlmIChtaW4gPT0gbm9ydGhXZXN0KSB7XG4gICAgICAgIGlmIChub3J0aFdlc3QgPT0gY3VycmVudCkge1xuICAgICAgICAgIGVkaXRzLnB1c2goRURJVF9MRUFWRSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZWRpdHMucHVzaChFRElUX1VQREFURSk7XG4gICAgICAgICAgY3VycmVudCA9IG5vcnRoV2VzdDtcbiAgICAgICAgfVxuICAgICAgICBpLS07XG4gICAgICAgIGotLTtcbiAgICAgIH0gZWxzZSBpZiAobWluID09IHdlc3QpIHtcbiAgICAgICAgZWRpdHMucHVzaChFRElUX0RFTEVURSk7XG4gICAgICAgIGktLTtcbiAgICAgICAgY3VycmVudCA9IHdlc3Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlZGl0cy5wdXNoKEVESVRfQUREKTtcbiAgICAgICAgai0tO1xuICAgICAgICBjdXJyZW50ID0gbm9ydGg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZWRpdHMucmV2ZXJzZSgpO1xuICAgIHJldHVybiBlZGl0cztcbiAgfVxuXG4gIC8qKlxuICAgKiBTcGxpY2UgUHJvamVjdGlvbiBmdW5jdGlvbnM6XG4gICAqXG4gICAqIEEgc3BsaWNlIG1hcCBpcyBhIHJlcHJlc2VudGF0aW9uIG9mIGhvdyBhIHByZXZpb3VzIGFycmF5IG9mIGl0ZW1zXG4gICAqIHdhcyB0cmFuc2Zvcm1lZCBpbnRvIGEgbmV3IGFycmF5IG9mIGl0ZW1zLiBDb25jZXB0dWFsbHkgaXQgaXMgYSBsaXN0IG9mXG4gICAqIHR1cGxlcyBvZlxuICAgKlxuICAgKiAgIDxpbmRleCwgcmVtb3ZlZCwgYWRkZWRDb3VudD5cbiAgICpcbiAgICogd2hpY2ggYXJlIGtlcHQgaW4gYXNjZW5kaW5nIGluZGV4IG9yZGVyIG9mLiBUaGUgdHVwbGUgcmVwcmVzZW50cyB0aGF0IGF0XG4gICAqIHRoZSB8aW5kZXh8LCB8cmVtb3ZlZHwgc2VxdWVuY2Ugb2YgaXRlbXMgd2VyZSByZW1vdmVkLCBhbmQgY291bnRpbmcgZm9yd2FyZFxuICAgKiBmcm9tIHxpbmRleHwsIHxhZGRlZENvdW50fCBpdGVtcyB3ZXJlIGFkZGVkLlxuICAgKi9cblxuICAvKipcbiAgICogTGFja2luZyBpbmRpdmlkdWFsIHNwbGljZSBtdXRhdGlvbiBpbmZvcm1hdGlvbiwgdGhlIG1pbmltYWwgc2V0IG9mXG4gICAqIHNwbGljZXMgY2FuIGJlIHN5bnRoZXNpemVkIGdpdmVuIHRoZSBwcmV2aW91cyBzdGF0ZSBhbmQgZmluYWwgc3RhdGUgb2YgYW5cbiAgICogYXJyYXkuIFRoZSBiYXNpYyBhcHByb2FjaCBpcyB0byBjYWxjdWxhdGUgdGhlIGVkaXQgZGlzdGFuY2UgbWF0cml4IGFuZFxuICAgKiBjaG9vc2UgdGhlIHNob3J0ZXN0IHBhdGggdGhyb3VnaCBpdC5cbiAgICpcbiAgICogQ29tcGxleGl0eTogTyhsICogcClcbiAgICogICBsOiBUaGUgbGVuZ3RoIG9mIHRoZSBjdXJyZW50IGFycmF5XG4gICAqICAgcDogVGhlIGxlbmd0aCBvZiB0aGUgb2xkIGFycmF5XG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IGN1cnJlbnQgVGhlIGN1cnJlbnQgXCJjaGFuZ2VkXCIgYXJyYXkgZm9yIHdoaWNoIHRvXG4gICAqIGNhbGN1bGF0ZSBzcGxpY2VzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gY3VycmVudFN0YXJ0IFN0YXJ0aW5nIGluZGV4IGluIHRoZSBgY3VycmVudGAgYXJyYXkgZm9yXG4gICAqIHdoaWNoIHNwbGljZXMgYXJlIGNhbGN1bGF0ZWQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjdXJyZW50RW5kIEVuZGluZyBpbmRleCBpbiB0aGUgYGN1cnJlbnRgIGFycmF5IGZvclxuICAgKiB3aGljaCBzcGxpY2VzIGFyZSBjYWxjdWxhdGVkLlxuICAgKiBAcGFyYW0ge0FycmF5fSBvbGQgVGhlIG9yaWdpbmFsIFwidW5jaGFuZ2VkXCIgYXJyYXkgdG8gY29tcGFyZSBgY3VycmVudGBcbiAgICogYWdhaW5zdCB0byBkZXRlcm1pbmUgc3BsaWNlcy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG9sZFN0YXJ0IFN0YXJ0aW5nIGluZGV4IGluIHRoZSBgb2xkYCBhcnJheSBmb3JcbiAgICogd2hpY2ggc3BsaWNlcyBhcmUgY2FsY3VsYXRlZC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG9sZEVuZCBFbmRpbmcgaW5kZXggaW4gdGhlIGBvbGRgIGFycmF5IGZvclxuICAgKiB3aGljaCBzcGxpY2VzIGFyZSBjYWxjdWxhdGVkLlxuICAgKiBAcmV0dXJuIHtBcnJheX0gUmV0dXJucyBhbiBhcnJheSBvZiBzcGxpY2UgcmVjb3JkIG9iamVjdHMuIEVhY2ggb2YgdGhlc2VcbiAgICogY29udGFpbnM6IGBpbmRleGAgdGhlIGxvY2F0aW9uIHdoZXJlIHRoZSBzcGxpY2Ugb2NjdXJyZWQ7IGByZW1vdmVkYFxuICAgKiB0aGUgYXJyYXkgb2YgcmVtb3ZlZCBpdGVtcyBmcm9tIHRoaXMgbG9jYXRpb247IGBhZGRlZENvdW50YCB0aGUgbnVtYmVyXG4gICAqIG9mIGl0ZW1zIGFkZGVkIGF0IHRoaXMgbG9jYXRpb24uXG4gICAqL1xuICBmdW5jdGlvbiBjYWxjU3BsaWNlcyhjdXJyZW50LCBjdXJyZW50U3RhcnQsIGN1cnJlbnRFbmQsXG4gICAgICAgICAgICAgICAgICAgICAgICBvbGQsIG9sZFN0YXJ0LCBvbGRFbmQpIHtcbiAgICBsZXQgcHJlZml4Q291bnQgPSAwO1xuICAgIGxldCBzdWZmaXhDb3VudCA9IDA7XG4gICAgbGV0IHNwbGljZTtcblxuICAgIGxldCBtaW5MZW5ndGggPSBNYXRoLm1pbihjdXJyZW50RW5kIC0gY3VycmVudFN0YXJ0LCBvbGRFbmQgLSBvbGRTdGFydCk7XG4gICAgaWYgKGN1cnJlbnRTdGFydCA9PSAwICYmIG9sZFN0YXJ0ID09IDApXG4gICAgICBwcmVmaXhDb3VudCA9IHNoYXJlZFByZWZpeChjdXJyZW50LCBvbGQsIG1pbkxlbmd0aCk7XG5cbiAgICBpZiAoY3VycmVudEVuZCA9PSBjdXJyZW50Lmxlbmd0aCAmJiBvbGRFbmQgPT0gb2xkLmxlbmd0aClcbiAgICAgIHN1ZmZpeENvdW50ID0gc2hhcmVkU3VmZml4KGN1cnJlbnQsIG9sZCwgbWluTGVuZ3RoIC0gcHJlZml4Q291bnQpO1xuXG4gICAgY3VycmVudFN0YXJ0ICs9IHByZWZpeENvdW50O1xuICAgIG9sZFN0YXJ0ICs9IHByZWZpeENvdW50O1xuICAgIGN1cnJlbnRFbmQgLT0gc3VmZml4Q291bnQ7XG4gICAgb2xkRW5kIC09IHN1ZmZpeENvdW50O1xuXG4gICAgaWYgKGN1cnJlbnRFbmQgLSBjdXJyZW50U3RhcnQgPT0gMCAmJiBvbGRFbmQgLSBvbGRTdGFydCA9PSAwKVxuICAgICAgcmV0dXJuIFtdO1xuXG4gICAgaWYgKGN1cnJlbnRTdGFydCA9PSBjdXJyZW50RW5kKSB7XG4gICAgICBzcGxpY2UgPSBuZXdTcGxpY2UoY3VycmVudFN0YXJ0LCBbXSwgMCk7XG4gICAgICB3aGlsZSAob2xkU3RhcnQgPCBvbGRFbmQpXG4gICAgICAgIHNwbGljZS5yZW1vdmVkLnB1c2gob2xkW29sZFN0YXJ0KytdKTtcblxuICAgICAgcmV0dXJuIFsgc3BsaWNlIF07XG4gICAgfSBlbHNlIGlmIChvbGRTdGFydCA9PSBvbGRFbmQpXG4gICAgICByZXR1cm4gWyBuZXdTcGxpY2UoY3VycmVudFN0YXJ0LCBbXSwgY3VycmVudEVuZCAtIGN1cnJlbnRTdGFydCkgXTtcblxuICAgIGxldCBvcHMgPSBzcGxpY2VPcGVyYXRpb25zRnJvbUVkaXREaXN0YW5jZXMoXG4gICAgICAgIGNhbGNFZGl0RGlzdGFuY2VzKGN1cnJlbnQsIGN1cnJlbnRTdGFydCwgY3VycmVudEVuZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbGQsIG9sZFN0YXJ0LCBvbGRFbmQpKTtcblxuICAgIHNwbGljZSA9IHVuZGVmaW5lZDtcbiAgICBsZXQgc3BsaWNlcyA9IFtdO1xuICAgIGxldCBpbmRleCA9IGN1cnJlbnRTdGFydDtcbiAgICBsZXQgb2xkSW5kZXggPSBvbGRTdGFydDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgc3dpdGNoKG9wc1tpXSkge1xuICAgICAgICBjYXNlIEVESVRfTEVBVkU6XG4gICAgICAgICAgaWYgKHNwbGljZSkge1xuICAgICAgICAgICAgc3BsaWNlcy5wdXNoKHNwbGljZSk7XG4gICAgICAgICAgICBzcGxpY2UgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgICBvbGRJbmRleCsrO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEVESVRfVVBEQVRFOlxuICAgICAgICAgIGlmICghc3BsaWNlKVxuICAgICAgICAgICAgc3BsaWNlID0gbmV3U3BsaWNlKGluZGV4LCBbXSwgMCk7XG5cbiAgICAgICAgICBzcGxpY2UuYWRkZWRDb3VudCsrO1xuICAgICAgICAgIGluZGV4Kys7XG5cbiAgICAgICAgICBzcGxpY2UucmVtb3ZlZC5wdXNoKG9sZFtvbGRJbmRleF0pO1xuICAgICAgICAgIG9sZEluZGV4Kys7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgRURJVF9BREQ6XG4gICAgICAgICAgaWYgKCFzcGxpY2UpXG4gICAgICAgICAgICBzcGxpY2UgPSBuZXdTcGxpY2UoaW5kZXgsIFtdLCAwKTtcblxuICAgICAgICAgIHNwbGljZS5hZGRlZENvdW50Kys7XG4gICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBFRElUX0RFTEVURTpcbiAgICAgICAgICBpZiAoIXNwbGljZSlcbiAgICAgICAgICAgIHNwbGljZSA9IG5ld1NwbGljZShpbmRleCwgW10sIDApO1xuXG4gICAgICAgICAgc3BsaWNlLnJlbW92ZWQucHVzaChvbGRbb2xkSW5kZXhdKTtcbiAgICAgICAgICBvbGRJbmRleCsrO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzcGxpY2UpIHtcbiAgICAgIHNwbGljZXMucHVzaChzcGxpY2UpO1xuICAgIH1cbiAgICByZXR1cm4gc3BsaWNlcztcbiAgfVxuXG4gIGZ1bmN0aW9uIHNoYXJlZFByZWZpeChjdXJyZW50LCBvbGQsIHNlYXJjaExlbmd0aCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VhcmNoTGVuZ3RoOyBpKyspXG4gICAgICBpZiAoIWVxdWFscyhjdXJyZW50W2ldLCBvbGRbaV0pKVxuICAgICAgICByZXR1cm4gaTtcbiAgICByZXR1cm4gc2VhcmNoTGVuZ3RoO1xuICB9XG5cbiAgZnVuY3Rpb24gc2hhcmVkU3VmZml4KGN1cnJlbnQsIG9sZCwgc2VhcmNoTGVuZ3RoKSB7XG4gICAgbGV0IGluZGV4MSA9IGN1cnJlbnQubGVuZ3RoO1xuICAgIGxldCBpbmRleDIgPSBvbGQubGVuZ3RoO1xuICAgIGxldCBjb3VudCA9IDA7XG4gICAgd2hpbGUgKGNvdW50IDwgc2VhcmNoTGVuZ3RoICYmIGVxdWFscyhjdXJyZW50Wy0taW5kZXgxXSwgb2xkWy0taW5kZXgyXSkpXG4gICAgICBjb3VudCsrO1xuXG4gICAgcmV0dXJuIGNvdW50O1xuICB9XG5cbiAgZnVuY3Rpb24gY2FsY3VsYXRlU3BsaWNlcyhjdXJyZW50LCBwcmV2aW91cykge1xuICAgIHJldHVybiBjYWxjU3BsaWNlcyhjdXJyZW50LCAwLCBjdXJyZW50Lmxlbmd0aCwgcHJldmlvdXMsIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldmlvdXMubGVuZ3RoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGVxdWFscyhjdXJyZW50VmFsdWUsIHByZXZpb3VzVmFsdWUpIHtcbiAgICByZXR1cm4gY3VycmVudFZhbHVlID09PSBwcmV2aW91c1ZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBuYW1lc3BhY2VcbiAgICogQG1lbWJlcm9mIFBvbHltZXJcbiAgICogQHN1bW1hcnkgTW9kdWxlIHRoYXQgcHJvdmlkZXMgdXRpbGl0aWVzIGZvciBkaWZmaW5nIGFycmF5cy5cbiAgICovXG4gIFBvbHltZXIuQXJyYXlTcGxpY2UgPSB7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBhcnJheSBvZiBzcGxpY2UgcmVjb3JkcyBpbmRpY2F0aW5nIHRoZSBtaW5pbXVtIGVkaXRzIHJlcXVpcmVkXG4gICAgICogdG8gdHJhbnNmb3JtIHRoZSBgcHJldmlvdXNgIGFycmF5IGludG8gdGhlIGBjdXJyZW50YCBhcnJheS5cbiAgICAgKlxuICAgICAqIFNwbGljZSByZWNvcmRzIGFyZSBvcmRlcmVkIGJ5IGluZGV4IGFuZCBjb250YWluIHRoZSBmb2xsb3dpbmcgZmllbGRzOlxuICAgICAqIC0gYGluZGV4YDogaW5kZXggd2hlcmUgZWRpdCBzdGFydGVkXG4gICAgICogLSBgcmVtb3ZlZGA6IGFycmF5IG9mIHJlbW92ZWQgaXRlbXMgZnJvbSB0aGlzIGluZGV4XG4gICAgICogLSBgYWRkZWRDb3VudGA6IG51bWJlciBvZiBpdGVtcyBhZGRlZCBhdCB0aGlzIGluZGV4XG4gICAgICpcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGJhc2VkIG9uIHRoZSBMZXZlbnNodGVpbiBcIm1pbmltdW0gZWRpdCBkaXN0YW5jZVwiXG4gICAgICogYWxnb3JpdGhtLiBOb3RlIHRoYXQgdXBkYXRlcyBhcmUgdHJlYXRlZCBhcyByZW1vdmFsIGZvbGxvd2VkIGJ5IGFkZGl0aW9uLlxuICAgICAqXG4gICAgICogVGhlIHdvcnN0LWNhc2UgdGltZSBjb21wbGV4aXR5IG9mIHRoaXMgYWxnb3JpdGhtIGlzIGBPKGwgKiBwKWBcbiAgICAgKiAgIGw6IFRoZSBsZW5ndGggb2YgdGhlIGN1cnJlbnQgYXJyYXlcbiAgICAgKiAgIHA6IFRoZSBsZW5ndGggb2YgdGhlIHByZXZpb3VzIGFycmF5XG4gICAgICpcbiAgICAgKiBIb3dldmVyLCB0aGUgd29yc3QtY2FzZSBjb21wbGV4aXR5IGlzIHJlZHVjZWQgYnkgYW4gYE8obilgIG9wdGltaXphdGlvblxuICAgICAqIHRvIGRldGVjdCBhbnkgc2hhcmVkIHByZWZpeCAmIHN1ZmZpeCBiZXR3ZWVuIHRoZSB0d28gYXJyYXlzIGFuZCBvbmx5XG4gICAgICogcGVyZm9ybSB0aGUgbW9yZSBleHBlbnNpdmUgbWluaW11bSBlZGl0IGRpc3RhbmNlIGNhbGN1bGF0aW9uIG92ZXIgdGhlXG4gICAgICogbm9uLXNoYXJlZCBwb3J0aW9ucyBvZiB0aGUgYXJyYXlzLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIFBvbHltZXIuQXJyYXlTcGxpY2VcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBjdXJyZW50IFRoZSBcImNoYW5nZWRcIiBhcnJheSBmb3Igd2hpY2ggc3BsaWNlcyB3aWxsIGJlXG4gICAgICogY2FsY3VsYXRlZC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwcmV2aW91cyBUaGUgXCJ1bmNoYW5nZWRcIiBvcmlnaW5hbCBhcnJheSB0byBjb21wYXJlXG4gICAgICogYGN1cnJlbnRgIGFnYWluc3QgdG8gZGV0ZXJtaW5lIHRoZSBzcGxpY2VzLlxuICAgICAqIEByZXR1cm4ge0FycmF5fSBSZXR1cm5zIGFuIGFycmF5IG9mIHNwbGljZSByZWNvcmQgb2JqZWN0cy4gRWFjaCBvZiB0aGVzZVxuICAgICAqIGNvbnRhaW5zOiBgaW5kZXhgIHRoZSBsb2NhdGlvbiB3aGVyZSB0aGUgc3BsaWNlIG9jY3VycmVkOyBgcmVtb3ZlZGBcbiAgICAgKiB0aGUgYXJyYXkgb2YgcmVtb3ZlZCBpdGVtcyBmcm9tIHRoaXMgbG9jYXRpb247IGBhZGRlZENvdW50YCB0aGUgbnVtYmVyXG4gICAgICogb2YgaXRlbXMgYWRkZWQgYXQgdGhpcyBsb2NhdGlvbi5cbiAgICAgKi9cbiAgICBjYWxjdWxhdGVTcGxpY2VzXG4gIH1cblxufSkoKTtcbjwvc2NyaXB0PlxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvdXRpbHMvYXJyYXktc3BsaWNlLmh0bWwiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE1IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi9wb2x5bWVyL3BvbHltZXIuaHRtbFwiPlxuXG48c2NyaXB0PlxuICAvKipcbiAgICogYElyb25SZXNpemFibGVCZWhhdmlvcmAgaXMgYSBiZWhhdmlvciB0aGF0IGNhbiBiZSB1c2VkIGluIFBvbHltZXIgZWxlbWVudHMgdG9cbiAgICogY29vcmRpbmF0ZSB0aGUgZmxvdyBvZiByZXNpemUgZXZlbnRzIGJldHdlZW4gXCJyZXNpemVyc1wiIChlbGVtZW50cyB0aGF0IGNvbnRyb2wgdGhlXG4gICAqIHNpemUgb3IgaGlkZGVuIHN0YXRlIG9mIHRoZWlyIGNoaWxkcmVuKSBhbmQgXCJyZXNpemFibGVzXCIgKGVsZW1lbnRzIHRoYXQgbmVlZCB0byBiZVxuICAgKiBub3RpZmllZCB3aGVuIHRoZXkgYXJlIHJlc2l6ZWQgb3IgdW4taGlkZGVuIGJ5IHRoZWlyIHBhcmVudHMgaW4gb3JkZXIgdG8gdGFrZVxuICAgKiBhY3Rpb24gb24gdGhlaXIgbmV3IG1lYXN1cmVtZW50cykuXG4gICAqXG4gICAqIEVsZW1lbnRzIHRoYXQgcGVyZm9ybSBtZWFzdXJlbWVudCBzaG91bGQgYWRkIHRoZSBgSXJvblJlc2l6YWJsZUJlaGF2aW9yYCBiZWhhdmlvciB0b1xuICAgKiB0aGVpciBlbGVtZW50IGRlZmluaXRpb24gYW5kIGxpc3RlbiBmb3IgdGhlIGBpcm9uLXJlc2l6ZWAgZXZlbnQgb24gdGhlbXNlbHZlcy5cbiAgICogVGhpcyBldmVudCB3aWxsIGJlIGZpcmVkIHdoZW4gdGhleSBiZWNvbWUgc2hvd2luZyBhZnRlciBoYXZpbmcgYmVlbiBoaWRkZW4sXG4gICAqIHdoZW4gdGhleSBhcmUgcmVzaXplZCBleHBsaWNpdGx5IGJ5IGFub3RoZXIgcmVzaXphYmxlLCBvciB3aGVuIHRoZSB3aW5kb3cgaGFzIGJlZW5cbiAgICogcmVzaXplZC5cbiAgICpcbiAgICogTm90ZSwgdGhlIGBpcm9uLXJlc2l6ZWAgZXZlbnQgaXMgbm9uLWJ1YmJsaW5nLlxuICAgKlxuICAgKiBAcG9seW1lckJlaGF2aW9yIFBvbHltZXIuSXJvblJlc2l6YWJsZUJlaGF2aW9yXG4gICAqIEBkZW1vIGRlbW8vaW5kZXguaHRtbFxuICAgKiovXG4gIFBvbHltZXIuSXJvblJlc2l6YWJsZUJlaGF2aW9yID0ge1xuICAgIHByb3BlcnRpZXM6IHtcbiAgICAgIC8qKlxuICAgICAgICogVGhlIGNsb3Nlc3QgYW5jZXN0b3IgZWxlbWVudCB0aGF0IGltcGxlbWVudHMgYElyb25SZXNpemFibGVCZWhhdmlvcmAuXG4gICAgICAgKi9cbiAgICAgIF9wYXJlbnRSZXNpemFibGU6IHtcbiAgICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgICBvYnNlcnZlcjogJ19wYXJlbnRSZXNpemFibGVDaGFuZ2VkJ1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBUcnVlIGlmIHRoaXMgZWxlbWVudCBpcyBjdXJyZW50bHkgbm90aWZ5aW5nIGl0cyBkZXNjZW5kYW50IGVsZW1lbnRzIG9mXG4gICAgICAgKiByZXNpemUuXG4gICAgICAgKi9cbiAgICAgIF9ub3RpZnlpbmdEZXNjZW5kYW50OiB7XG4gICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBsaXN0ZW5lcnM6IHtcbiAgICAgICdpcm9uLXJlcXVlc3QtcmVzaXplLW5vdGlmaWNhdGlvbnMnOiAnX29uSXJvblJlcXVlc3RSZXNpemVOb3RpZmljYXRpb25zJ1xuICAgIH0sXG5cbiAgICBjcmVhdGVkOiBmdW5jdGlvbigpIHtcbiAgICAgIC8vIFdlIGRvbid0IHJlYWxseSBuZWVkIHByb3BlcnR5IGVmZmVjdHMgb24gdGhlc2UsIGFuZCBhbHNvIHdlIHdhbnQgdGhlbVxuICAgICAgLy8gdG8gYmUgY3JlYXRlZCBiZWZvcmUgdGhlIGBfcGFyZW50UmVzaXphYmxlYCBvYnNlcnZlciBmaXJlczpcbiAgICAgIHRoaXMuX2ludGVyZXN0ZWRSZXNpemFibGVzID0gW107XG4gICAgICB0aGlzLl9ib3VuZE5vdGlmeVJlc2l6ZSA9IHRoaXMubm90aWZ5UmVzaXplLmJpbmQodGhpcyk7XG4gICAgfSxcblxuICAgIGF0dGFjaGVkOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX3JlcXVlc3RSZXNpemVOb3RpZmljYXRpb25zKCk7XG4gICAgfSxcblxuICAgIGRldGFjaGVkOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLl9wYXJlbnRSZXNpemFibGUpIHtcbiAgICAgICAgdGhpcy5fcGFyZW50UmVzaXphYmxlLnN0b3BSZXNpemVOb3RpZmljYXRpb25zRm9yKHRoaXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuX2JvdW5kTm90aWZ5UmVzaXplKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fcGFyZW50UmVzaXphYmxlID0gbnVsbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FuIGJlIGNhbGxlZCB0byBtYW51YWxseSBub3RpZnkgYSByZXNpemFibGUgYW5kIGl0cyBkZXNjZW5kYW50XG4gICAgICogcmVzaXphYmxlcyBvZiBhIHJlc2l6ZSBjaGFuZ2UuXG4gICAgICovXG4gICAgbm90aWZ5UmVzaXplOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5pc0F0dGFjaGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5faW50ZXJlc3RlZFJlc2l6YWJsZXMuZm9yRWFjaChmdW5jdGlvbihyZXNpemFibGUpIHtcbiAgICAgICAgaWYgKHRoaXMucmVzaXplclNob3VsZE5vdGlmeShyZXNpemFibGUpKSB7XG4gICAgICAgICAgdGhpcy5fbm90aWZ5RGVzY2VuZGFudChyZXNpemFibGUpO1xuICAgICAgICB9XG4gICAgICB9LCB0aGlzKTtcblxuICAgICAgdGhpcy5fZmlyZVJlc2l6ZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIGFzc2lnbiB0aGUgY2xvc2VzdCByZXNpemFibGUgYW5jZXN0b3IgdG8gdGhpcyByZXNpemFibGVcbiAgICAgKiBpZiB0aGUgYW5jZXN0b3IgZGV0ZWN0cyBhIHJlcXVlc3QgZm9yIG5vdGlmaWNhdGlvbnMuXG4gICAgICovXG4gICAgYXNzaWduUGFyZW50UmVzaXphYmxlOiBmdW5jdGlvbihwYXJlbnRSZXNpemFibGUpIHtcbiAgICAgIHRoaXMuX3BhcmVudFJlc2l6YWJsZSA9IHBhcmVudFJlc2l6YWJsZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVXNlZCB0byByZW1vdmUgYSByZXNpemFibGUgZGVzY2VuZGFudCBmcm9tIHRoZSBsaXN0IG9mIGRlc2NlbmRhbnRzXG4gICAgICogdGhhdCBzaG91bGQgYmUgbm90aWZpZWQgb2YgYSByZXNpemUgY2hhbmdlLlxuICAgICAqL1xuICAgIHN0b3BSZXNpemVOb3RpZmljYXRpb25zRm9yOiBmdW5jdGlvbih0YXJnZXQpIHtcbiAgICAgIHZhciBpbmRleCA9IHRoaXMuX2ludGVyZXN0ZWRSZXNpemFibGVzLmluZGV4T2YodGFyZ2V0KTtcblxuICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgdGhpcy5faW50ZXJlc3RlZFJlc2l6YWJsZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgdGhpcy51bmxpc3Rlbih0YXJnZXQsICdpcm9uLXJlc2l6ZScsICdfb25EZXNjZW5kYW50SXJvblJlc2l6ZScpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBjYW4gYmUgb3ZlcnJpZGRlbiB0byBmaWx0ZXIgbmVzdGVkIGVsZW1lbnRzIHRoYXQgc2hvdWxkIG9yXG4gICAgICogc2hvdWxkIG5vdCBiZSBub3RpZmllZCBieSB0aGUgY3VycmVudCBlbGVtZW50LiBSZXR1cm4gdHJ1ZSBpZiBhbiBlbGVtZW50XG4gICAgICogc2hvdWxkIGJlIG5vdGlmaWVkLCBvciBmYWxzZSBpZiBpdCBzaG91bGQgbm90IGJlIG5vdGlmaWVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCBBIGNhbmRpZGF0ZSBkZXNjZW5kYW50IGVsZW1lbnQgdGhhdFxuICAgICAqIGltcGxlbWVudHMgYElyb25SZXNpemFibGVCZWhhdmlvcmAuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgYGVsZW1lbnRgIHNob3VsZCBiZSBub3RpZmllZCBvZiByZXNpemUuXG4gICAgICovXG4gICAgcmVzaXplclNob3VsZE5vdGlmeTogZnVuY3Rpb24oZWxlbWVudCkgeyByZXR1cm4gdHJ1ZTsgfSxcblxuICAgIF9vbkRlc2NlbmRhbnRJcm9uUmVzaXplOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgaWYgKHRoaXMuX25vdGlmeWluZ0Rlc2NlbmRhbnQpIHtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gTk9URShjZGF0YSk6IEluIFNoYWRvd0RPTSwgZXZlbnQgcmV0YXJnZXRpbmcgbWFrZXMgZWNob2luZyBvZiB0aGVcbiAgICAgIC8vIG90aGVyd2lzZSBub24tYnViYmxpbmcgZXZlbnQgXCJqdXN0IHdvcmsuXCIgV2UgZG8gaXQgbWFudWFsbHkgaGVyZSBmb3JcbiAgICAgIC8vIHRoZSBjYXNlIHdoZXJlIFBvbHltZXIgaXMgbm90IHVzaW5nIHNoYWRvdyByb290cyBmb3Igd2hhdGV2ZXIgcmVhc29uOlxuICAgICAgaWYgKCFQb2x5bWVyLlNldHRpbmdzLnVzZVNoYWRvdykge1xuICAgICAgICB0aGlzLl9maXJlUmVzaXplKCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIF9maXJlUmVzaXplOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZmlyZSgnaXJvbi1yZXNpemUnLCBudWxsLCB7XG4gICAgICAgIG5vZGU6IHRoaXMsXG4gICAgICAgIGJ1YmJsZXM6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgX29uSXJvblJlcXVlc3RSZXNpemVOb3RpZmljYXRpb25zOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgdmFyIHRhcmdldCA9IC8qKiBAdHlwZSB7IUV2ZW50VGFyZ2V0fSAqLyAoUG9seW1lci5kb20oZXZlbnQpLnJvb3RUYXJnZXQpO1xuICAgICAgaWYgKHRhcmdldCA9PT0gdGhpcykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9pbnRlcmVzdGVkUmVzaXphYmxlcy5pbmRleE9mKHRhcmdldCkgPT09IC0xKSB7XG4gICAgICAgIHRoaXMuX2ludGVyZXN0ZWRSZXNpemFibGVzLnB1c2godGFyZ2V0KTtcbiAgICAgICAgdGhpcy5saXN0ZW4odGFyZ2V0LCAnaXJvbi1yZXNpemUnLCAnX29uRGVzY2VuZGFudElyb25SZXNpemUnKTtcbiAgICAgIH1cblxuICAgICAgdGFyZ2V0LmFzc2lnblBhcmVudFJlc2l6YWJsZSh0aGlzKTtcbiAgICAgIHRoaXMuX25vdGlmeURlc2NlbmRhbnQodGFyZ2V0KTtcblxuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfSxcblxuICAgIF9wYXJlbnRSZXNpemFibGVDaGFuZ2VkOiBmdW5jdGlvbihwYXJlbnRSZXNpemFibGUpIHtcbiAgICAgIGlmIChwYXJlbnRSZXNpemFibGUpIHtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuX2JvdW5kTm90aWZ5UmVzaXplKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgX25vdGlmeURlc2NlbmRhbnQ6IGZ1bmN0aW9uKGRlc2NlbmRhbnQpIHtcbiAgICAgIC8vIE5PVEUoY2RhdGEpOiBJbiBJRTEwLCBhdHRhY2hlZCBpcyBmaXJlZCBvbiBjaGlsZHJlbiBmaXJzdCwgc28gaXQnc1xuICAgICAgLy8gaW1wb3J0YW50IG5vdCB0byBub3RpZnkgdGhlbSBpZiB0aGUgcGFyZW50IGlzIG5vdCBhdHRhY2hlZCB5ZXQgKG9yXG4gICAgICAvLyBlbHNlIHRoZXkgd2lsbCBnZXQgcmVkdW5kYW50bHkgbm90aWZpZWQgd2hlbiB0aGUgcGFyZW50IGF0dGFjaGVzKS5cbiAgICAgIGlmICghdGhpcy5pc0F0dGFjaGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fbm90aWZ5aW5nRGVzY2VuZGFudCA9IHRydWU7XG4gICAgICBkZXNjZW5kYW50Lm5vdGlmeVJlc2l6ZSgpO1xuICAgICAgdGhpcy5fbm90aWZ5aW5nRGVzY2VuZGFudCA9IGZhbHNlO1xuICAgIH0sXG4gICAgXG4gICAgX3JlcXVlc3RSZXNpemVOb3RpZmljYXRpb25zOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5pc0F0dGFjaGVkKVxuICAgICAgICByZXR1cm47XG4gICAgICBcbiAgICAgIC8vIE5PVEUodmFsZHJpbikgSW4gQ3VzdG9tRWxlbWVudHMgdjEgd2l0aCBuYXRpdmUgSFRNTEltcG9ydHMsIHRoZSBvcmRlclxuICAgICAgLy8gb2YgaW1wb3J0cyBhZmZlY3RzIHRoZSBvcmRlciBvZiBgYXR0YWNoZWRgIGNhbGxiYWNrcyAoc2VlIHdlYmNvbXBvbmVudHMvY3VzdG9tLWVsZW1lbnRzIzE1KS5cbiAgICAgIC8vIFRoaXMgbWlnaHQgY2F1c2UgYSBjaGlsZCB0byBub3RpZnkgcGFyZW50cyB0b28gZWFybHkgKGFzIHRoZSBwYXJlbnRcbiAgICAgIC8vIHN0aWxsIGhhcyB0byBiZSB1cGdyYWRlZCksIHJlc3VsdGluZyBpbiBhIHBhcmVudCBub3QgYWJsZSB0byBrZWVwIHRyYWNrXG4gICAgICAvLyBvZiB0aGUgYF9pbnRlcmVzdGVkUmVzaXphYmxlc2AuIFRvIHNvbHZlIHRoaXMsIHdlIHdhaXQgZm9yIHRoZSBkb2N1bWVudFxuICAgICAgLy8gdG8gYmUgZG9uZSBsb2FkaW5nIGJlZm9yZSBmaXJpbmcgdGhlIGV2ZW50LlxuICAgICAgaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdsb2FkaW5nJykge1xuICAgICAgICB2YXIgX3JlcXVlc3RSZXNpemVOb3RpZmljYXRpb25zID0gdGhpcy5fcmVxdWVzdFJlc2l6ZU5vdGlmaWNhdGlvbnMuYmluZCh0aGlzKTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncmVhZHlzdGF0ZWNoYW5nZScsIGZ1bmN0aW9uIHJlYWR5c3RhdGVjaGFuZ2VkKCkge1xuICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3JlYWR5c3RhdGVjaGFuZ2UnLCByZWFkeXN0YXRlY2hhbmdlZCk7XG4gICAgICAgICAgX3JlcXVlc3RSZXNpemVOb3RpZmljYXRpb25zKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5maXJlKCdpcm9uLXJlcXVlc3QtcmVzaXplLW5vdGlmaWNhdGlvbnMnLCBudWxsLCB7XG4gICAgICAgICAgbm9kZTogdGhpcyxcbiAgICAgICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgICAgIGNhbmNlbGFibGU6IHRydWVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9wYXJlbnRSZXNpemFibGUpIHtcbiAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5fYm91bmROb3RpZnlSZXNpemUpO1xuICAgICAgICAgIHRoaXMubm90aWZ5UmVzaXplKCk7XG4gICAgICAgIH0gXG4gICAgICB9XG4gICAgfVxuICB9O1xuPC9zY3JpcHQ+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL2lyb24tcmVzaXphYmxlLWJlaGF2aW9yL2lyb24tcmVzaXphYmxlLWJlaGF2aW9yLmh0bWwiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi9hcHAtc2Nyb2xsLWVmZmVjdHMtYmVoYXZpb3IuaHRtbFwiPlxuXG48c2NyaXB0PlxuICAvKipcbiAgICogV2hpbGUgc2Nyb2xsaW5nIGRvd24sIGZhZGUgaW4gdGhlIHJlYXIgYmFja2dyb3VuZCBsYXllciBhbmQgZmFkZSBvdXQgdGhlIGZyb250IGJhY2tncm91bmRcbiAgICogbGF5ZXIgKG9wYWNpdHkgaW50ZXJwb2xhdGVkIGJhc2VkIG9uIHNjcm9sbCBwb3NpdGlvbikuXG4gICAqL1xuICBQb2x5bWVyLkFwcExheW91dC5yZWdpc3RlckVmZmVjdCgnYmxlbmQtYmFja2dyb3VuZCcsIHtcbiAgICAvKiogQHRoaXMgUG9seW1lci5BcHBMYXlvdXQuRWxlbWVudFdpdGhCYWNrZ3JvdW5kICovXG4gICAgc2V0VXA6IGZ1bmN0aW9uIHNldFVwKCkge1xuICAgICAgdmFyIGZ4ID0ge307XG4gICAgICBmeC5iYWNrZ3JvdW5kRnJvbnRMYXllciA9IHRoaXMuX2dldERPTVJlZignYmFja2dyb3VuZEZyb250TGF5ZXInKTtcbiAgICAgIGZ4LmJhY2tncm91bmRSZWFyTGF5ZXIgPSB0aGlzLl9nZXRET01SZWYoJ2JhY2tncm91bmRSZWFyTGF5ZXInKTtcbiAgICAgIGZ4LmJhY2tncm91bmRGcm9udExheWVyLnN0eWxlLndpbGxDaGFuZ2UgPSAnb3BhY2l0eSc7XG4gICAgICBmeC5iYWNrZ3JvdW5kRnJvbnRMYXllci5zdHlsZS50cmFuc2Zvcm0gPSAndHJhbnNsYXRlWigwKSc7XG4gICAgICBmeC5iYWNrZ3JvdW5kUmVhckxheWVyLnN0eWxlLndpbGxDaGFuZ2UgPSAnb3BhY2l0eSc7XG4gICAgICBmeC5iYWNrZ3JvdW5kUmVhckxheWVyLnN0eWxlLnRyYW5zZm9ybSA9ICd0cmFuc2xhdGVaKDApJztcbiAgICAgIGZ4LmJhY2tncm91bmRSZWFyTGF5ZXIuc3R5bGUub3BhY2l0eSA9IDA7XG4gICAgICB0aGlzLl9meEJsZW5kQmFja2dyb3VuZCA9IGZ4O1xuICAgIH0sXG4gICAgLyoqIEB0aGlzIFBvbHltZXIuQXBwTGF5b3V0LkVsZW1lbnRXaXRoQmFja2dyb3VuZCAqL1xuICAgIHJ1bjogZnVuY3Rpb24gcnVuKHAsIHkpIHtcbiAgICAgIHZhciBmeCA9IHRoaXMuX2Z4QmxlbmRCYWNrZ3JvdW5kO1xuICAgICAgZnguYmFja2dyb3VuZEZyb250TGF5ZXIuc3R5bGUub3BhY2l0eSA9IDEgLSBwO1xuICAgICAgZnguYmFja2dyb3VuZFJlYXJMYXllci5zdHlsZS5vcGFjaXR5ID0gcDtcbiAgICB9LFxuICAgIC8qKiBAdGhpcyBQb2x5bWVyLkFwcExheW91dC5FbGVtZW50V2l0aEJhY2tncm91bmQgKi9cbiAgICB0ZWFyRG93bjogZnVuY3Rpb24gdGVhckRvd24oKSB7XG4gICAgICBkZWxldGUgdGhpcy5fZnhCbGVuZEJhY2tncm91bmQ7XG4gICAgfVxuICB9KTtcbjwvc2NyaXB0PlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9hcHAtbGF5b3V0L2FwcC1zY3JvbGwtZWZmZWN0cy9lZmZlY3RzL2JsZW5kLWJhY2tncm91bmQuaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTYgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cblxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL2FwcC1zY3JvbGwtZWZmZWN0cy1iZWhhdmlvci5odG1sXCI+XG5cbjxzY3JpcHQ+XG4gIC8qKlxuICAgKiBUb2dnbGVzIHRoZSBzaGFkb3cgcHJvcGVydHkgaW4gYXBwLWhlYWRlciB3aGVuIGNvbnRlbnQgaXMgc2Nyb2xsZWQgdG8gY3JlYXRlIGEgc2Vuc2Ugb2YgZGVwdGhcbiAgICogYmV0d2VlbiB0aGUgZWxlbWVudCBhbmQgdGhlIGNvbnRlbnQgdW5kZXJuZWF0aC5cbiAgICovXG4gIFBvbHltZXIuQXBwTGF5b3V0LnJlZ2lzdGVyRWZmZWN0KCd3YXRlcmZhbGwnLCB7XG4gICAgLyoqXG4gICAgICogIEB0aGlzIFBvbHltZXIuQXBwTGF5b3V0LkVsZW1lbnRXaXRoQmFja2dyb3VuZFxuICAgICAqL1xuICAgIHJ1bjogZnVuY3Rpb24gcnVuKCkge1xuICAgICAgdGhpcy5zaGFkb3cgPSB0aGlzLmlzT25TY3JlZW4oKSAmJiB0aGlzLmlzQ29udGVudEJlbG93KCk7XG4gICAgfVxuICB9KTtcbjwvc2NyaXB0PlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9hcHAtbGF5b3V0L2FwcC1zY3JvbGwtZWZmZWN0cy9lZmZlY3RzL3dhdGVyZmFsbC5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNiBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuXG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vYXBwLXNjcm9sbC1lZmZlY3RzLWJlaGF2aW9yLmh0bWxcIj5cblxuPHNjcmlwdD5cbiAgKGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIGludGVycG9sYXRlKHByb2dyZXNzLCBwb2ludHMsIGZuLCBjdHgpIHtcbiAgICAgIGZuLmFwcGx5KGN0eCwgcG9pbnRzLm1hcChmdW5jdGlvbihwb2ludCkge1xuICAgICAgICByZXR1cm4gcG9pbnRbMF0gKyAocG9pbnRbMV0gLSBwb2ludFswXSkgKiBwcm9ncmVzcztcbiAgICAgIH0pKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm0gdGhlIGZvbnQgc2l6ZSBvZiBhIGRlc2lnbmF0ZWQgdGl0bGUgZWxlbWVudCBiZXR3ZWVuIHR3byB2YWx1ZXMgYmFzZWQgb24gdGhlIHNjcm9sbFxuICAgICAqIHBvc2l0aW9uLlxuICAgICAqL1xuICAgIFBvbHltZXIuQXBwTGF5b3V0LnJlZ2lzdGVyRWZmZWN0KCdyZXNpemUtdGl0bGUnLCB7XG4gICAgICAvKiogQHRoaXMgUG9seW1lci5BcHBMYXlvdXQuRWxlbWVudFdpdGhCYWNrZ3JvdW5kICovXG4gICAgICBzZXRVcDogZnVuY3Rpb24gc2V0VXAoKSB7XG4gICAgICAgIHZhciB0aXRsZSA9IHRoaXMuX2dldERPTVJlZignbWFpblRpdGxlJyk7XG4gICAgICAgIHZhciBjb25kZW5zZWRUaXRsZSA9IHRoaXMuX2dldERPTVJlZignY29uZGVuc2VkVGl0bGUnKTtcblxuICAgICAgICBpZiAoIWNvbmRlbnNlZFRpdGxlKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKCdTY3JvbGwgZWZmZWN0IGByZXNpemUtdGl0bGVgOiB1bmRlZmluZWQgYGNvbmRlbnNlZC10aXRsZWAnKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aXRsZSkge1xuICAgICAgICAgIGNvbnNvbGUud2FybignU2Nyb2xsIGVmZmVjdCBgcmVzaXplLXRpdGxlYDogdW5kZWZpbmVkIGBtYWluLXRpdGxlYCcpO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbmRlbnNlZFRpdGxlLnN0eWxlLndpbGxDaGFuZ2UgPSAnb3BhY2l0eSc7XG4gICAgICAgIGNvbmRlbnNlZFRpdGxlLnN0eWxlLndlYmtpdFRyYW5zZm9ybSA9ICd0cmFuc2xhdGVaKDApJztcbiAgICAgICAgY29uZGVuc2VkVGl0bGUuc3R5bGUudHJhbnNmb3JtID0gJ3RyYW5zbGF0ZVooMCknO1xuICAgICAgICBjb25kZW5zZWRUaXRsZS5zdHlsZS53ZWJraXRUcmFuc2Zvcm1PcmlnaW4gPSAnbGVmdCB0b3AnO1xuICAgICAgICBjb25kZW5zZWRUaXRsZS5zdHlsZS50cmFuc2Zvcm1PcmlnaW4gPSAnbGVmdCB0b3AnO1xuXG4gICAgICAgIHRpdGxlLnN0eWxlLndpbGxDaGFuZ2UgPSAnb3BhY2l0eSc7XG4gICAgICAgIHRpdGxlLnN0eWxlLndlYmtpdFRyYW5zZm9ybU9yaWdpbiA9ICdsZWZ0IHRvcCc7XG4gICAgICAgIHRpdGxlLnN0eWxlLnRyYW5zZm9ybU9yaWdpbiA9ICdsZWZ0IHRvcCc7XG4gICAgICAgIHRpdGxlLnN0eWxlLndlYmtpdFRyYW5zZm9ybSA9ICd0cmFuc2xhdGVaKDApJztcbiAgICAgICAgdGl0bGUuc3R5bGUudHJhbnNmb3JtID0gJ3RyYW5zbGF0ZVooMCknO1xuXG4gICAgICAgIHZhciB0aXRsZUNsaWVudFJlY3QgPSB0aXRsZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgdmFyIGNvbmRlbnNlZFRpdGxlQ2xpZW50UmVjdCA9IGNvbmRlbnNlZFRpdGxlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB2YXIgZnggPSB7fTtcblxuICAgICAgICBmeC5zY2FsZSA9IHBhcnNlSW50KHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGNvbmRlbnNlZFRpdGxlKVsnZm9udC1zaXplJ10sIDEwKSAvXG4gICAgICAgICAgICBwYXJzZUludCh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aXRsZSlbJ2ZvbnQtc2l6ZSddLCAxMCk7XG4gICAgICAgIGZ4LnRpdGxlRFggPSB0aXRsZUNsaWVudFJlY3QubGVmdCAtIGNvbmRlbnNlZFRpdGxlQ2xpZW50UmVjdC5sZWZ0O1xuICAgICAgICBmeC50aXRsZURZID0gdGl0bGVDbGllbnRSZWN0LnRvcCAtIGNvbmRlbnNlZFRpdGxlQ2xpZW50UmVjdC50b3A7XG4gICAgICAgIGZ4LmNvbmRlbnNlZFRpdGxlID0gY29uZGVuc2VkVGl0bGU7XG4gICAgICAgIGZ4LnRpdGxlID0gdGl0bGU7XG5cbiAgICAgICAgdGhpcy5fZnhSZXNpemVUaXRsZSA9IGZ4O1xuICAgICAgfSxcbiAgICAgIC8qKiBAdGhpcyBQb2x5bWVyRWxlbWVudCAqL1xuICAgICAgcnVuOiBmdW5jdGlvbiBydW4ocCwgeSkge1xuICAgICAgICB2YXIgZnggPSB0aGlzLl9meFJlc2l6ZVRpdGxlO1xuICAgICAgICBpZiAoIXRoaXMuY29uZGVuc2VzKSB7XG4gICAgICAgICAgeSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHAgPj0gMSkge1xuICAgICAgICAgIGZ4LnRpdGxlLnN0eWxlLm9wYWNpdHkgPSAwO1xuICAgICAgICAgIGZ4LmNvbmRlbnNlZFRpdGxlLnN0eWxlLm9wYWNpdHkgPSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZ4LnRpdGxlLnN0eWxlLm9wYWNpdHkgPSAxO1xuICAgICAgICAgIGZ4LmNvbmRlbnNlZFRpdGxlLnN0eWxlLm9wYWNpdHkgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGludGVycG9sYXRlKE1hdGgubWluKDEsIHApLCBbIFsxLCBmeC5zY2FsZV0sIFswLCAtZngudGl0bGVEWF0sIFt5LCB5LWZ4LnRpdGxlRFldIF0sXG4gICAgICAgICAgZnVuY3Rpb24oc2NhbGUsIHRyYW5zbGF0ZVgsIHRyYW5zbGF0ZVkpIHtcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtKCd0cmFuc2xhdGUoJyArIHRyYW5zbGF0ZVggKyAncHgsICcgKyB0cmFuc2xhdGVZICsgJ3B4KSAnICtcbiAgICAgICAgICAgICAgICAnc2NhbGUzZCgnICsgc2NhbGUgKyAnLCAnICsgc2NhbGUgKyAnLCAxKScsIGZ4LnRpdGxlKTtcbiAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgIH0sXG4gICAgICAvKiogQHRoaXMgUG9seW1lci5BcHBMYXlvdXQuRWxlbWVudFdpdGhCYWNrZ3JvdW5kICovXG4gICAgICB0ZWFyRG93bjogZnVuY3Rpb24gdGVhckRvd24oKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9meFJlc2l6ZVRpdGxlO1xuICAgICAgfVxuICAgIH0pO1xuICB9KSgpO1xuPC9zY3JpcHQ+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL2FwcC1sYXlvdXQvYXBwLXNjcm9sbC1lZmZlY3RzL2VmZmVjdHMvcmVzaXplLXRpdGxlLmh0bWwiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi9hcHAtc2Nyb2xsLWVmZmVjdHMtYmVoYXZpb3IuaHRtbFwiPlxuXG48c2NyaXB0PlxuICAvKipcbiAgICogVmVydGljYWxseSB0cmFuc2xhdGUgdGhlIGJhY2tncm91bmQgYmFzZWQgb24gYSBmYWN0b3Igb2YgdGhlIHNjcm9sbCBwb3NpdGlvbi5cbiAgICovXG4gIFBvbHltZXIuQXBwTGF5b3V0LnJlZ2lzdGVyRWZmZWN0KCdwYXJhbGxheC1iYWNrZ3JvdW5kJywge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7e3NjYWxhcjogc3RyaW5nfX0gY29uZmlnXG4gICAgICogQHRoaXMgUG9seW1lci5BcHBMYXlvdXQuRWxlbWVudFdpdGhCYWNrZ3JvdW5kXG4gICAgICovXG4gICAgc2V0VXA6IGZ1bmN0aW9uIHNldFVwKGNvbmZpZykge1xuICAgICAgdmFyIGZ4ID0ge307XG4gICAgICB2YXIgc2NhbGFyID0gcGFyc2VGbG9hdChjb25maWcuc2NhbGFyKTtcbiAgICAgIGZ4LmJhY2tncm91bmQgPSB0aGlzLl9nZXRET01SZWYoJ2JhY2tncm91bmQnKTtcbiAgICAgIGZ4LmJhY2tncm91bmRGcm9udExheWVyID0gdGhpcy5fZ2V0RE9NUmVmKCdiYWNrZ3JvdW5kRnJvbnRMYXllcicpO1xuICAgICAgZnguYmFja2dyb3VuZFJlYXJMYXllciA9IHRoaXMuX2dldERPTVJlZignYmFja2dyb3VuZFJlYXJMYXllcicpO1xuICAgICAgZnguZGVsdGFCZyA9IGZ4LmJhY2tncm91bmRGcm9udExheWVyLm9mZnNldEhlaWdodCAtIGZ4LmJhY2tncm91bmQub2Zmc2V0SGVpZ2h0O1xuICAgICAgaWYgKGZ4LmRlbHRhQmcgPT09IDApIHtcbiAgICAgICAgaWYgKGlzTmFOKHNjYWxhcikpIHtcbiAgICAgICAgICBzY2FsYXIgPSAwLjg7XG4gICAgICAgIH1cbiAgICAgICAgZnguZGVsdGFCZyA9IHRoaXMuX2RIZWlnaHQgKiBzY2FsYXI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXNOYU4oc2NhbGFyKSkge1xuICAgICAgICAgIHNjYWxhciA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgZnguZGVsdGFCZyA9IGZ4LmRlbHRhQmcgKiBzY2FsYXI7XG4gICAgICB9XG4gICAgICB0aGlzLl9meFBhcmFsbGF4QmFja2dyb3VuZCA9IGZ4O1xuICAgIH0sXG4gICAgLyoqIEB0aGlzIFBvbHltZXIuQXBwTGF5b3V0LkVsZW1lbnRXaXRoQmFja2dyb3VuZCAqL1xuICAgIHJ1bjogZnVuY3Rpb24gcnVuKHAsIHkpIHtcbiAgICAgIHZhciBmeCA9IHRoaXMuX2Z4UGFyYWxsYXhCYWNrZ3JvdW5kO1xuICAgICAgdGhpcy50cmFuc2Zvcm0oJ3RyYW5zbGF0ZTNkKDBweCwgJyArIChmeC5kZWx0YUJnICogTWF0aC5taW4oMSwgcCkpICsgJ3B4LCAwcHgpJywgZnguYmFja2dyb3VuZEZyb250TGF5ZXIpO1xuICAgICAgaWYgKGZ4LmJhY2tncm91bmRSZWFyTGF5ZXIpIHtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0oJ3RyYW5zbGF0ZTNkKDBweCwgJyArIChmeC5kZWx0YUJnICogTWF0aC5taW4oMSwgcCkpICsgJ3B4LCAwcHgpJywgZnguYmFja2dyb3VuZFJlYXJMYXllcik7XG4gICAgICB9XG4gICAgfSxcbiAgICAvKiogQHRoaXMgUG9seW1lci5BcHBMYXlvdXQuRWxlbWVudFdpdGhCYWNrZ3JvdW5kICovXG4gICAgdGVhckRvd246IGZ1bmN0aW9uIHRlYXJEb3duKCkge1xuICAgICAgZGVsZXRlIHRoaXMuX2Z4UGFyYWxsYXhCYWNrZ3JvdW5kO1xuICAgIH1cbiAgfSk7XG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvYXBwLWxheW91dC9hcHAtc2Nyb2xsLWVmZmVjdHMvZWZmZWN0cy9wYXJhbGxheC1iYWNrZ3JvdW5kLmh0bWwiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE1IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi9wb2x5bWVyL3BvbHltZXIuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cImlyb24tc2VsZWN0aW9uLmh0bWxcIj5cblxuPHNjcmlwdD5cbiAgLyoqXG4gICAqIEBwb2x5bWVyQmVoYXZpb3IgUG9seW1lci5Jcm9uU2VsZWN0YWJsZUJlaGF2aW9yXG4gICAqL1xuICBQb2x5bWVyLklyb25TZWxlY3RhYmxlQmVoYXZpb3IgPSB7XG5cbiAgICAgIC8qKlxuICAgICAgICogRmlyZWQgd2hlbiBpcm9uLXNlbGVjdG9yIGlzIGFjdGl2YXRlZCAoc2VsZWN0ZWQgb3IgZGVzZWxlY3RlZCkuXG4gICAgICAgKiBJdCBpcyBmaXJlZCBiZWZvcmUgdGhlIHNlbGVjdGVkIGl0ZW1zIGFyZSBjaGFuZ2VkLlxuICAgICAgICogQ2FuY2VsIHRoZSBldmVudCB0byBhYm9ydCBzZWxlY3Rpb24uXG4gICAgICAgKlxuICAgICAgICogQGV2ZW50IGlyb24tYWN0aXZhdGVcbiAgICAgICAqL1xuXG4gICAgICAvKipcbiAgICAgICAqIEZpcmVkIHdoZW4gYW4gaXRlbSBpcyBzZWxlY3RlZFxuICAgICAgICpcbiAgICAgICAqIEBldmVudCBpcm9uLXNlbGVjdFxuICAgICAgICovXG5cbiAgICAgIC8qKlxuICAgICAgICogRmlyZWQgd2hlbiBhbiBpdGVtIGlzIGRlc2VsZWN0ZWRcbiAgICAgICAqXG4gICAgICAgKiBAZXZlbnQgaXJvbi1kZXNlbGVjdFxuICAgICAgICovXG5cbiAgICAgIC8qKlxuICAgICAgICogRmlyZWQgd2hlbiB0aGUgbGlzdCBvZiBzZWxlY3RhYmxlIGl0ZW1zIGNoYW5nZXMgKGUuZy4sIGl0ZW1zIGFyZVxuICAgICAgICogYWRkZWQgb3IgcmVtb3ZlZCkuIFRoZSBkZXRhaWwgb2YgdGhlIGV2ZW50IGlzIGEgbXV0YXRpb24gcmVjb3JkIHRoYXRcbiAgICAgICAqIGRlc2NyaWJlcyB3aGF0IGNoYW5nZWQuXG4gICAgICAgKlxuICAgICAgICogQGV2ZW50IGlyb24taXRlbXMtY2hhbmdlZFxuICAgICAgICovXG5cbiAgICBwcm9wZXJ0aWVzOiB7XG5cbiAgICAgIC8qKlxuICAgICAgICogSWYgeW91IHdhbnQgdG8gdXNlIGFuIGF0dHJpYnV0ZSB2YWx1ZSBvciBwcm9wZXJ0eSBvZiBhbiBlbGVtZW50IGZvclxuICAgICAgICogYHNlbGVjdGVkYCBpbnN0ZWFkIG9mIHRoZSBpbmRleCwgc2V0IHRoaXMgdG8gdGhlIG5hbWUgb2YgdGhlIGF0dHJpYnV0ZVxuICAgICAgICogb3IgcHJvcGVydHkuIEh5cGhlbmF0ZWQgdmFsdWVzIGFyZSBjb252ZXJ0ZWQgdG8gY2FtZWwgY2FzZSB3aGVuIHVzZWQgdG9cbiAgICAgICAqIGxvb2sgdXAgdGhlIHByb3BlcnR5IG9mIGEgc2VsZWN0YWJsZSBlbGVtZW50LiBDYW1lbCBjYXNlZCB2YWx1ZXMgYXJlXG4gICAgICAgKiAqbm90KiBjb252ZXJ0ZWQgdG8gaHlwaGVuYXRlZCB2YWx1ZXMgZm9yIGF0dHJpYnV0ZSBsb29rdXAuIEl0J3NcbiAgICAgICAqIHJlY29tbWVuZGVkIHRoYXQgeW91IHByb3ZpZGUgdGhlIGh5cGhlbmF0ZWQgZm9ybSBvZiB0aGUgbmFtZSBzbyB0aGF0XG4gICAgICAgKiBzZWxlY3Rpb24gd29ya3MgaW4gYm90aCBjYXNlcy4gKFVzZSBgYXR0ci1vci1wcm9wZXJ0eS1uYW1lYCBpbnN0ZWFkIG9mXG4gICAgICAgKiBgYXR0ck9yUHJvcGVydHlOYW1lYC4pXG4gICAgICAgKi9cbiAgICAgIGF0dHJGb3JTZWxlY3RlZDoge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIHZhbHVlOiBudWxsXG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgc2VsZWN0ZWQgZWxlbWVudC4gVGhlIGRlZmF1bHQgaXMgdG8gdXNlIHRoZSBpbmRleCBvZiB0aGUgaXRlbS5cbiAgICAgICAqIEB0eXBlIHtzdHJpbmd8bnVtYmVyfVxuICAgICAgICovXG4gICAgICBzZWxlY3RlZDoge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIG5vdGlmeTogdHJ1ZVxuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgaXRlbS5cbiAgICAgICAqXG4gICAgICAgKiBAdHlwZSB7P09iamVjdH1cbiAgICAgICAqL1xuICAgICAgc2VsZWN0ZWRJdGVtOiB7XG4gICAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgICAgcmVhZE9ubHk6IHRydWUsXG4gICAgICAgIG5vdGlmeTogdHJ1ZVxuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBUaGUgZXZlbnQgdGhhdCBmaXJlcyBmcm9tIGl0ZW1zIHdoZW4gdGhleSBhcmUgc2VsZWN0ZWQuIFNlbGVjdGFibGVcbiAgICAgICAqIHdpbGwgbGlzdGVuIGZvciB0aGlzIGV2ZW50IGZyb20gaXRlbXMgYW5kIHVwZGF0ZSB0aGUgc2VsZWN0aW9uIHN0YXRlLlxuICAgICAgICogU2V0IHRvIGVtcHR5IHN0cmluZyB0byBsaXN0ZW4gdG8gbm8gZXZlbnRzLlxuICAgICAgICovXG4gICAgICBhY3RpdmF0ZUV2ZW50OiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgdmFsdWU6ICd0YXAnLFxuICAgICAgICBvYnNlcnZlcjogJ19hY3RpdmF0ZUV2ZW50Q2hhbmdlZCdcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogVGhpcyBpcyBhIENTUyBzZWxlY3RvciBzdHJpbmcuICBJZiB0aGlzIGlzIHNldCwgb25seSBpdGVtcyB0aGF0IG1hdGNoIHRoZSBDU1Mgc2VsZWN0b3JcbiAgICAgICAqIGFyZSBzZWxlY3RhYmxlLlxuICAgICAgICovXG4gICAgICBzZWxlY3RhYmxlOiBTdHJpbmcsXG5cbiAgICAgIC8qKlxuICAgICAgICogVGhlIGNsYXNzIHRvIHNldCBvbiBlbGVtZW50cyB3aGVuIHNlbGVjdGVkLlxuICAgICAgICovXG4gICAgICBzZWxlY3RlZENsYXNzOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgdmFsdWU6ICdpcm9uLXNlbGVjdGVkJ1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBUaGUgYXR0cmlidXRlIHRvIHNldCBvbiBlbGVtZW50cyB3aGVuIHNlbGVjdGVkLlxuICAgICAgICovXG4gICAgICBzZWxlY3RlZEF0dHJpYnV0ZToge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIHZhbHVlOiBudWxsXG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIERlZmF1bHQgZmFsbGJhY2sgaWYgdGhlIHNlbGVjdGlvbiBiYXNlZCBvbiBzZWxlY3RlZCB3aXRoIGBhdHRyRm9yU2VsZWN0ZWRgXG4gICAgICAgKiBpcyBub3QgZm91bmQuXG4gICAgICAgKi9cbiAgICAgIGZhbGxiYWNrU2VsZWN0aW9uOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgdmFsdWU6IG51bGxcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogVGhlIGxpc3Qgb2YgaXRlbXMgZnJvbSB3aGljaCBhIHNlbGVjdGlvbiBjYW4gYmUgbWFkZS5cbiAgICAgICAqL1xuICAgICAgaXRlbXM6IHtcbiAgICAgICAgdHlwZTogQXJyYXksXG4gICAgICAgIHJlYWRPbmx5OiB0cnVlLFxuICAgICAgICBub3RpZnk6IHRydWUsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogVGhlIHNldCBvZiBleGNsdWRlZCBlbGVtZW50cyB3aGVyZSB0aGUga2V5IGlzIHRoZSBgbG9jYWxOYW1lYFxuICAgICAgICogb2YgdGhlIGVsZW1lbnQgdGhhdCB3aWxsIGJlIGlnbm9yZWQgZnJvbSB0aGUgaXRlbSBsaXN0LlxuICAgICAgICpcbiAgICAgICAqIEBkZWZhdWx0IHt0ZW1wbGF0ZTogMX1cbiAgICAgICAqL1xuICAgICAgX2V4Y2x1ZGVkTG9jYWxOYW1lczoge1xuICAgICAgICB0eXBlOiBPYmplY3QsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ3RlbXBsYXRlJzogMSxcbiAgICAgICAgICAgICdkb20tYmluZCc6IDEsXG4gICAgICAgICAgICAnZG9tLWlmJzogMSxcbiAgICAgICAgICAgICdkb20tcmVwZWF0JzogMSxcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIG9ic2VydmVyczogW1xuICAgICAgJ191cGRhdGVBdHRyRm9yU2VsZWN0ZWQoYXR0ckZvclNlbGVjdGVkKScsXG4gICAgICAnX3VwZGF0ZVNlbGVjdGVkKHNlbGVjdGVkKScsXG4gICAgICAnX2NoZWNrRmFsbGJhY2soZmFsbGJhY2tTZWxlY3Rpb24pJ1xuICAgIF0sXG5cbiAgICBjcmVhdGVkOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX2JpbmRGaWx0ZXJJdGVtID0gdGhpcy5fZmlsdGVySXRlbS5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5fc2VsZWN0aW9uID0gbmV3IFBvbHltZXIuSXJvblNlbGVjdGlvbih0aGlzLl9hcHBseVNlbGVjdGlvbi5iaW5kKHRoaXMpKTtcbiAgICB9LFxuXG4gICAgYXR0YWNoZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fb2JzZXJ2ZXIgPSB0aGlzLl9vYnNlcnZlSXRlbXModGhpcyk7XG4gICAgICB0aGlzLl9hZGRMaXN0ZW5lcih0aGlzLmFjdGl2YXRlRXZlbnQpO1xuICAgIH0sXG5cbiAgICBkZXRhY2hlZDogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5fb2JzZXJ2ZXIpIHtcbiAgICAgICAgUG9seW1lci5kb20odGhpcykudW5vYnNlcnZlTm9kZXModGhpcy5fb2JzZXJ2ZXIpO1xuICAgICAgfVxuICAgICAgdGhpcy5fcmVtb3ZlTGlzdGVuZXIodGhpcy5hY3RpdmF0ZUV2ZW50KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGdpdmVuIGl0ZW0uXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGluZGV4T2ZcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaXRlbVxuICAgICAqIEByZXR1cm5zIFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBpdGVtXG4gICAgICovXG4gICAgaW5kZXhPZjogZnVuY3Rpb24oaXRlbSkge1xuICAgICAgcmV0dXJuIHRoaXMuaXRlbXMuaW5kZXhPZihpdGVtKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2VsZWN0cyB0aGUgZ2l2ZW4gdmFsdWUuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHNlbGVjdFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gdmFsdWUgdGhlIHZhbHVlIHRvIHNlbGVjdC5cbiAgICAgKi9cbiAgICBzZWxlY3Q6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICB0aGlzLnNlbGVjdGVkID0gdmFsdWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNlbGVjdHMgdGhlIHByZXZpb3VzIGl0ZW0uXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHNlbGVjdFByZXZpb3VzXG4gICAgICovXG4gICAgc2VsZWN0UHJldmlvdXM6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGxlbmd0aCA9IHRoaXMuaXRlbXMubGVuZ3RoO1xuICAgICAgdmFyIGluZGV4ID0gKE51bWJlcih0aGlzLl92YWx1ZVRvSW5kZXgodGhpcy5zZWxlY3RlZCkpIC0gMSArIGxlbmd0aCkgJSBsZW5ndGg7XG4gICAgICB0aGlzLnNlbGVjdGVkID0gdGhpcy5faW5kZXhUb1ZhbHVlKGluZGV4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2VsZWN0cyB0aGUgbmV4dCBpdGVtLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBzZWxlY3ROZXh0XG4gICAgICovXG4gICAgc2VsZWN0TmV4dDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaW5kZXggPSAoTnVtYmVyKHRoaXMuX3ZhbHVlVG9JbmRleCh0aGlzLnNlbGVjdGVkKSkgKyAxKSAlIHRoaXMuaXRlbXMubGVuZ3RoO1xuICAgICAgdGhpcy5zZWxlY3RlZCA9IHRoaXMuX2luZGV4VG9WYWx1ZShpbmRleCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNlbGVjdHMgdGhlIGl0ZW0gYXQgdGhlIGdpdmVuIGluZGV4LlxuICAgICAqXG4gICAgICogQG1ldGhvZCBzZWxlY3RJbmRleFxuICAgICAqL1xuICAgIHNlbGVjdEluZGV4OiBmdW5jdGlvbihpbmRleCkge1xuICAgICAgdGhpcy5zZWxlY3QodGhpcy5faW5kZXhUb1ZhbHVlKGluZGV4KSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZvcmNlIGEgc3luY2hyb25vdXMgdXBkYXRlIG9mIHRoZSBgaXRlbXNgIHByb3BlcnR5LlxuICAgICAqXG4gICAgICogTk9URTogQ29uc2lkZXIgbGlzdGVuaW5nIGZvciB0aGUgYGlyb24taXRlbXMtY2hhbmdlZGAgZXZlbnQgdG8gcmVzcG9uZCB0b1xuICAgICAqIHVwZGF0ZXMgdG8gdGhlIHNldCBvZiBzZWxlY3RhYmxlIGl0ZW1zIGFmdGVyIHVwZGF0ZXMgdG8gdGhlIERPTSBsaXN0IGFuZFxuICAgICAqIHNlbGVjdGlvbiBzdGF0ZSBoYXZlIGJlZW4gbWFkZS5cbiAgICAgKlxuICAgICAqIFdBUk5JTkc6IElmIHlvdSBhcmUgdXNpbmcgdGhpcyBtZXRob2QsIHlvdSBzaG91bGQgcHJvYmFibHkgY29uc2lkZXIgYW5cbiAgICAgKiBhbHRlcm5hdGUgYXBwcm9hY2guIFN5bmNocm9ub3VzbHkgcXVlcnlpbmcgZm9yIGl0ZW1zIGlzIHBvdGVudGlhbGx5XG4gICAgICogc2xvdyBmb3IgbWFueSB1c2UgY2FzZXMuIFRoZSBgaXRlbXNgIHByb3BlcnR5IHdpbGwgdXBkYXRlIGFzeW5jaHJvbm91c2x5XG4gICAgICogb24gaXRzIG93biB0byByZWZsZWN0IHNlbGVjdGFibGUgaXRlbXMgaW4gdGhlIERPTS5cbiAgICAgKi9cbiAgICBmb3JjZVN5bmNocm9ub3VzSXRlbVVwZGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5fb2JzZXJ2ZXIgJiYgdHlwZW9mIHRoaXMuX29ic2VydmVyLmZsdXNoID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgLy8gTk9URShiaWNrbmVsbHIpOiBgUG9seW1lci5kb20uZmx1c2hgIGFib3ZlIGlzIG5vIGxvbmdlciBzdWZmaWNpZW50IHRvXG4gICAgICAgIC8vIHRyaWdnZXIgYG9ic2VydmVOb2Rlc2AgY2FsbGJhY2tzLiBQb2x5bWVyIDIueCByZXR1cm5zIGFuIG9iamVjdCBmcm9tXG4gICAgICAgIC8vIGBvYnNlcnZlTm9kZXNgIHdpdGggYSBgZmx1c2hgIHRoYXQgc3luY2hyb25vdXNseSBnaXZlcyB0aGUgY2FsbGJhY2tcbiAgICAgICAgLy8gYW55IHBlbmRpbmcgTXV0YXRpb25SZWNvcmRzIChyZXRyaWV2ZWQgd2l0aCBgdGFrZVJlY29yZHNgKS4gQW55IGNhc2VcbiAgICAgICAgLy8gd2hlcmUgU2hhZHlET00gZmx1c2hlcyB3ZXJlIGV4cGVjdGVkIHRvIHN5bmNocm9ub3VzbHkgdHJpZ2dlciBpdGVtXG4gICAgICAgIC8vIHVwZGF0ZXMgd2lsbCBub3cgcmVxdWlyZSBjYWxsaW5nIGBmb3JjZVN5bmNocm9ub3VzSXRlbVVwZGF0ZWAuXG4gICAgICAgIHRoaXMuX29ic2VydmVyLmZsdXNoKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl91cGRhdGVJdGVtcygpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBVTlVTRUQsIEZPUiBBUEkgQ09NUEFUSUJJTElUWVxuICAgIGdldCBfc2hvdWxkVXBkYXRlU2VsZWN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0ZWQgIT0gbnVsbDtcbiAgICB9LFxuXG4gICAgX2NoZWNrRmFsbGJhY2s6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fdXBkYXRlU2VsZWN0ZWQoKTtcbiAgICB9LFxuXG4gICAgX2FkZExpc3RlbmVyOiBmdW5jdGlvbihldmVudE5hbWUpIHtcbiAgICAgIHRoaXMubGlzdGVuKHRoaXMsIGV2ZW50TmFtZSwgJ19hY3RpdmF0ZUhhbmRsZXInKTtcbiAgICB9LFxuXG4gICAgX3JlbW92ZUxpc3RlbmVyOiBmdW5jdGlvbihldmVudE5hbWUpIHtcbiAgICAgIHRoaXMudW5saXN0ZW4odGhpcywgZXZlbnROYW1lLCAnX2FjdGl2YXRlSGFuZGxlcicpO1xuICAgIH0sXG5cbiAgICBfYWN0aXZhdGVFdmVudENoYW5nZWQ6IGZ1bmN0aW9uKGV2ZW50TmFtZSwgb2xkKSB7XG4gICAgICB0aGlzLl9yZW1vdmVMaXN0ZW5lcihvbGQpO1xuICAgICAgdGhpcy5fYWRkTGlzdGVuZXIoZXZlbnROYW1lKTtcbiAgICB9LFxuXG4gICAgX3VwZGF0ZUl0ZW1zOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBub2RlcyA9IFBvbHltZXIuZG9tKHRoaXMpLnF1ZXJ5RGlzdHJpYnV0ZWRFbGVtZW50cyh0aGlzLnNlbGVjdGFibGUgfHwgJyonKTtcbiAgICAgIG5vZGVzID0gQXJyYXkucHJvdG90eXBlLmZpbHRlci5jYWxsKG5vZGVzLCB0aGlzLl9iaW5kRmlsdGVySXRlbSk7XG4gICAgICB0aGlzLl9zZXRJdGVtcyhub2Rlcyk7XG4gICAgfSxcblxuICAgIF91cGRhdGVBdHRyRm9yU2VsZWN0ZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuc2VsZWN0ZWRJdGVtKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWQgPSB0aGlzLl92YWx1ZUZvckl0ZW0odGhpcy5zZWxlY3RlZEl0ZW0pO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBfdXBkYXRlU2VsZWN0ZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fc2VsZWN0U2VsZWN0ZWQodGhpcy5zZWxlY3RlZCk7XG4gICAgfSxcblxuICAgIF9zZWxlY3RTZWxlY3RlZDogZnVuY3Rpb24oc2VsZWN0ZWQpIHtcbiAgICAgIGlmICghdGhpcy5pdGVtcykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBpdGVtID0gdGhpcy5fdmFsdWVUb0l0ZW0odGhpcy5zZWxlY3RlZCk7XG4gICAgICBpZiAoaXRlbSkge1xuICAgICAgICB0aGlzLl9zZWxlY3Rpb24uc2VsZWN0KGl0ZW0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fc2VsZWN0aW9uLmNsZWFyKCk7XG4gICAgICB9XG4gICAgICAvLyBDaGVjayBmb3IgaXRlbXMsIHNpbmNlIHRoaXMgYXJyYXkgaXMgcG9wdWxhdGVkIG9ubHkgd2hlbiBhdHRhY2hlZFxuICAgICAgLy8gU2luY2UgTnVtYmVyKDApIGlzIGZhbHN5LCBleHBsaWNpdGx5IGNoZWNrIGZvciB1bmRlZmluZWRcbiAgICAgIGlmICh0aGlzLmZhbGxiYWNrU2VsZWN0aW9uICYmIHRoaXMuaXRlbXMubGVuZ3RoICYmICh0aGlzLl9zZWxlY3Rpb24uZ2V0KCkgPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgdGhpcy5zZWxlY3RlZCA9IHRoaXMuZmFsbGJhY2tTZWxlY3Rpb247XG4gICAgICB9XG4gICAgfSxcblxuICAgIF9maWx0ZXJJdGVtOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICByZXR1cm4gIXRoaXMuX2V4Y2x1ZGVkTG9jYWxOYW1lc1tub2RlLmxvY2FsTmFtZV07XG4gICAgfSxcblxuICAgIF92YWx1ZVRvSXRlbTogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiAodmFsdWUgPT0gbnVsbCkgPyBudWxsIDogdGhpcy5pdGVtc1t0aGlzLl92YWx1ZVRvSW5kZXgodmFsdWUpXTtcbiAgICB9LFxuXG4gICAgX3ZhbHVlVG9JbmRleDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIGlmICh0aGlzLmF0dHJGb3JTZWxlY3RlZCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgaXRlbTsgaXRlbSA9IHRoaXMuaXRlbXNbaV07IGkrKykge1xuICAgICAgICAgIGlmICh0aGlzLl92YWx1ZUZvckl0ZW0oaXRlbSkgPT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIE51bWJlcih2YWx1ZSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIF9pbmRleFRvVmFsdWU6IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICBpZiAodGhpcy5hdHRyRm9yU2VsZWN0ZWQpIHtcbiAgICAgICAgdmFyIGl0ZW0gPSB0aGlzLml0ZW1zW2luZGV4XTtcbiAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWVGb3JJdGVtKGl0ZW0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICB9XG4gICAgfSxcblxuICAgIF92YWx1ZUZvckl0ZW06IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgIGlmICghaXRlbSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIHByb3BWYWx1ZSA9IGl0ZW1bUG9seW1lci5DYXNlTWFwLmRhc2hUb0NhbWVsQ2FzZSh0aGlzLmF0dHJGb3JTZWxlY3RlZCldO1xuICAgICAgcmV0dXJuIHByb3BWYWx1ZSAhPSB1bmRlZmluZWQgPyBwcm9wVmFsdWUgOiBpdGVtLmdldEF0dHJpYnV0ZSh0aGlzLmF0dHJGb3JTZWxlY3RlZCk7XG4gICAgfSxcblxuICAgIF9hcHBseVNlbGVjdGlvbjogZnVuY3Rpb24oaXRlbSwgaXNTZWxlY3RlZCkge1xuICAgICAgaWYgKHRoaXMuc2VsZWN0ZWRDbGFzcykge1xuICAgICAgICB0aGlzLnRvZ2dsZUNsYXNzKHRoaXMuc2VsZWN0ZWRDbGFzcywgaXNTZWxlY3RlZCwgaXRlbSk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5zZWxlY3RlZEF0dHJpYnV0ZSkge1xuICAgICAgICB0aGlzLnRvZ2dsZUF0dHJpYnV0ZSh0aGlzLnNlbGVjdGVkQXR0cmlidXRlLCBpc1NlbGVjdGVkLCBpdGVtKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3NlbGVjdGlvbkNoYW5nZSgpO1xuICAgICAgdGhpcy5maXJlKCdpcm9uLScgKyAoaXNTZWxlY3RlZCA/ICdzZWxlY3QnIDogJ2Rlc2VsZWN0JyksIHtpdGVtOiBpdGVtfSk7XG4gICAgfSxcblxuICAgIF9zZWxlY3Rpb25DaGFuZ2U6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fc2V0U2VsZWN0ZWRJdGVtKHRoaXMuX3NlbGVjdGlvbi5nZXQoKSk7XG4gICAgfSxcblxuICAgIC8vIG9ic2VydmUgaXRlbXMgY2hhbmdlIHVuZGVyIHRoZSBnaXZlbiBub2RlLlxuICAgIF9vYnNlcnZlSXRlbXM6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHJldHVybiBQb2x5bWVyLmRvbShub2RlKS5vYnNlcnZlTm9kZXMoZnVuY3Rpb24obXV0YXRpb24pIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlSXRlbXMoKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlU2VsZWN0ZWQoKTtcblxuICAgICAgICAvLyBMZXQgb3RoZXIgaW50ZXJlc3RlZCBwYXJ0aWVzIGtub3cgYWJvdXQgdGhlIGNoYW5nZSBzbyB0aGF0XG4gICAgICAgIC8vIHdlIGRvbid0IGhhdmUgdG8gcmVjcmVhdGUgbXV0YXRpb24gb2JzZXJ2ZXJzIGV2ZXJ5d2hlcmUuXG4gICAgICAgIHRoaXMuZmlyZSgnaXJvbi1pdGVtcy1jaGFuZ2VkJywgbXV0YXRpb24sIHtcbiAgICAgICAgICBidWJibGVzOiBmYWxzZSxcbiAgICAgICAgICBjYW5jZWxhYmxlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBfYWN0aXZhdGVIYW5kbGVyOiBmdW5jdGlvbihlKSB7XG4gICAgICB2YXIgdCA9IGUudGFyZ2V0O1xuICAgICAgdmFyIGl0ZW1zID0gdGhpcy5pdGVtcztcbiAgICAgIHdoaWxlICh0ICYmIHQgIT0gdGhpcykge1xuICAgICAgICB2YXIgaSA9IGl0ZW1zLmluZGV4T2YodCk7XG4gICAgICAgIGlmIChpID49IDApIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLl9pbmRleFRvVmFsdWUoaSk7XG4gICAgICAgICAgdGhpcy5faXRlbUFjdGl2YXRlKHZhbHVlLCB0KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdCA9IHQucGFyZW50Tm9kZTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgX2l0ZW1BY3RpdmF0ZTogZnVuY3Rpb24odmFsdWUsIGl0ZW0pIHtcbiAgICAgIGlmICghdGhpcy5maXJlKCdpcm9uLWFjdGl2YXRlJyxcbiAgICAgICAgICB7c2VsZWN0ZWQ6IHZhbHVlLCBpdGVtOiBpdGVtfSwge2NhbmNlbGFibGU6IHRydWV9KS5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0KHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgfTtcblxuPC9zY3JpcHQ+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL2lyb24tc2VsZWN0b3IvaXJvbi1zZWxlY3RhYmxlLmh0bWwiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE1IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi9wb2x5bWVyL3BvbHltZXIuaHRtbFwiPlxuXG48IS0tXG5gaXJvbi1tZXRhYCBpcyBhIGdlbmVyaWMgZWxlbWVudCB5b3UgY2FuIHVzZSBmb3Igc2hhcmluZyBpbmZvcm1hdGlvbiBhY3Jvc3MgdGhlIERPTSB0cmVlLlxuSXQgdXNlcyBbbW9ub3N0YXRlIHBhdHRlcm5dKGh0dHA6Ly9jMi5jb20vY2dpL3dpa2k/TW9ub3N0YXRlUGF0dGVybikgc3VjaCB0aGF0IGFueVxuaW5zdGFuY2Ugb2YgaXJvbi1tZXRhIGhhcyBhY2Nlc3MgdG8gdGhlIHNoYXJlZFxuaW5mb3JtYXRpb24uIFlvdSBjYW4gdXNlIGBpcm9uLW1ldGFgIHRvIHNoYXJlIHdoYXRldmVyIHlvdSB3YW50IChvciBjcmVhdGUgYW4gZXh0ZW5zaW9uXG5bbGlrZSB4LW1ldGFdIGZvciBlbmhhbmNlbWVudHMpLlxuXG5UaGUgYGlyb24tbWV0YWAgaW5zdGFuY2VzIGNvbnRhaW5pbmcgeW91ciBhY3R1YWwgZGF0YSBjYW4gYmUgbG9hZGVkIGluIGFuIGltcG9ydCxcbm9yIGNvbnN0cnVjdGVkIGluIGFueSB3YXkgeW91IHNlZSBmaXQuIFRoZSBvbmx5IHJlcXVpcmVtZW50IGlzIHRoYXQgeW91IGNyZWF0ZSB0aGVtXG5iZWZvcmUgeW91IHRyeSB0byBhY2Nlc3MgdGhlbS5cblxuRXhhbXBsZXM6XG5cbklmIEkgY3JlYXRlIGFuIGluc3RhbmNlIGxpa2UgdGhpczpcblxuICAgIDxpcm9uLW1ldGEga2V5PVwiaW5mb1wiIHZhbHVlPVwiZm9vL2JhclwiPjwvaXJvbi1tZXRhPlxuXG5Ob3RlIHRoYXQgdmFsdWU9XCJmb28vYmFyXCIgaXMgdGhlIG1ldGFkYXRhIEkndmUgZGVmaW5lZC4gSSBjb3VsZCBkZWZpbmUgbW9yZVxuYXR0cmlidXRlcyBvciB1c2UgY2hpbGQgbm9kZXMgdG8gZGVmaW5lIGFkZGl0aW9uYWwgbWV0YWRhdGEuXG5cbk5vdyBJIGNhbiBhY2Nlc3MgdGhhdCBlbGVtZW50IChhbmQgaXQncyBtZXRhZGF0YSkgZnJvbSBhbnkgaXJvbi1tZXRhIGluc3RhbmNlXG52aWEgdGhlIGJ5S2V5IG1ldGhvZCwgZS5nLlxuXG4gICAgbWV0YS5ieUtleSgnaW5mbycpO1xuXG5QdXJlIGltcGVyYXRpdmUgZm9ybSB3b3VsZCBiZSBsaWtlOlxuXG4gICAgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaXJvbi1tZXRhJykuYnlLZXkoJ2luZm8nKTtcblxuT3IsIGluIGEgUG9seW1lciBlbGVtZW50LCB5b3UgY2FuIGluY2x1ZGUgYSBtZXRhIGluIHlvdXIgdGVtcGxhdGU6XG5cbiAgICA8aXJvbi1tZXRhIGlkPVwibWV0YVwiPjwvaXJvbi1tZXRhPlxuICAgIC4uLlxuICAgIHRoaXMuJC5tZXRhLmJ5S2V5KCdpbmZvJyk7XG5cbkBncm91cCBJcm9uIEVsZW1lbnRzXG5AZGVtbyBkZW1vL2luZGV4Lmh0bWxcbkBoZXJvIGhlcm8uc3ZnXG5AZWxlbWVudCBpcm9uLW1ldGFcbi0tPlxuXG48c2NyaXB0PlxuXG4gIChmdW5jdGlvbigpIHtcblxuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7e3R5cGU6IChzdHJpbmd8bnVsbCksIGtleTogKHN0cmluZ3xudWxsKSwgdmFsdWU6ICp9fSBvcHRpb25zXG4gICAgICovXG4gICAgZnVuY3Rpb24gSXJvbk1ldGEob3B0aW9ucykge1xuICAgICAgdGhpcy50eXBlID0gKG9wdGlvbnMgJiYgb3B0aW9ucy50eXBlKSB8fCAnZGVmYXVsdCc7XG4gICAgICB0aGlzLmtleSA9IG9wdGlvbnMgJiYgb3B0aW9ucy5rZXk7XG4gICAgICBpZiAoJ3ZhbHVlJyBpbiBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSBvcHRpb25zLnZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIElyb25NZXRhLnR5cGVzID0ge307XG5cbiAgICBJcm9uTWV0YS5wcm90b3R5cGUgPSB7XG4gICAgICBnZXQgdmFsdWUoKSB7XG4gICAgICAgIHZhciB0eXBlID0gdGhpcy50eXBlO1xuICAgICAgICB2YXIga2V5ID0gdGhpcy5rZXk7XG5cbiAgICAgICAgaWYgKHR5cGUgJiYga2V5KSB7XG4gICAgICAgICAgcmV0dXJuIElyb25NZXRhLnR5cGVzW3R5cGVdICYmIElyb25NZXRhLnR5cGVzW3R5cGVdW2tleV07XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIHNldCB2YWx1ZSh2YWx1ZSkge1xuICAgICAgICB2YXIgdHlwZSA9IHRoaXMudHlwZTtcbiAgICAgICAgdmFyIGtleSA9IHRoaXMua2V5O1xuXG4gICAgICAgIGlmICh0eXBlICYmIGtleSkge1xuICAgICAgICAgIHR5cGUgPSBJcm9uTWV0YS50eXBlc1t0eXBlXSA9IElyb25NZXRhLnR5cGVzW3R5cGVdIHx8IHt9O1xuICAgICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBkZWxldGUgdHlwZVtrZXldO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0eXBlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIGdldCBsaXN0KCkge1xuICAgICAgICB2YXIgdHlwZSA9IHRoaXMudHlwZTtcblxuICAgICAgICBpZiAodHlwZSkge1xuICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhJcm9uTWV0YS50eXBlc1t0aGlzLnR5cGVdKS5tYXAoZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gbWV0YURhdGFzW3RoaXMudHlwZV1ba2V5XTtcbiAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgYnlLZXk6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgICB9XG4gICAgfTtcblxuICAgIFBvbHltZXIuSXJvbk1ldGEgPSBJcm9uTWV0YTtcblxuICAgIHZhciBtZXRhRGF0YXMgPSBQb2x5bWVyLklyb25NZXRhLnR5cGVzO1xuXG4gICAgUG9seW1lcih7XG5cbiAgICAgIGlzOiAnaXJvbi1tZXRhJyxcblxuICAgICAgcHJvcGVydGllczoge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdHlwZSBvZiBtZXRhLWRhdGEuICBBbGwgbWV0YS1kYXRhIG9mIHRoZSBzYW1lIHR5cGUgaXMgc3RvcmVkXG4gICAgICAgICAqIHRvZ2V0aGVyLlxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdHlwZToge1xuICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICB2YWx1ZTogJ2RlZmF1bHQnLFxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUga2V5IHVzZWQgdG8gc3RvcmUgYHZhbHVlYCB1bmRlciB0aGUgYHR5cGVgIG5hbWVzcGFjZS5cbiAgICAgICAgICogQHR5cGUgez9zdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICBrZXk6IHtcbiAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBtZXRhLWRhdGEgdG8gc3RvcmUgb3IgcmV0cmlldmUuXG4gICAgICAgICAqIEB0eXBlIHsqfVxuICAgICAgICAgKi9cbiAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgbm90aWZ5OiB0cnVlLFxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0cnVlLCBgdmFsdWVgIGlzIHNldCB0byB0aGUgaXJvbi1tZXRhIGluc3RhbmNlIGl0c2VsZi5cbiAgICAgICAgICovXG4gICAgICAgICBzZWxmOiB7XG4gICAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgICBvYnNlcnZlcjogJ19zZWxmQ2hhbmdlZCdcbiAgICAgICAgfSxcblxuICAgICAgICBfX21ldGE6IHtcbiAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgIGNvbXB1dGVkOiAnX19jb21wdXRlTWV0YSh0eXBlLCBrZXksIHZhbHVlKSdcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgaG9zdEF0dHJpYnV0ZXM6IHtcbiAgICAgICAgaGlkZGVuOiB0cnVlXG4gICAgICB9LFxuXG4gICAgICBfX2NvbXB1dGVNZXRhOiBmdW5jdGlvbih0eXBlLCBrZXksIHZhbHVlKSB7XG4gICAgICAgIHZhciBtZXRhID0gbmV3IFBvbHltZXIuSXJvbk1ldGEoe1xuICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAga2V5OiBrZXlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG1ldGEudmFsdWUpIHtcbiAgICAgICAgICBtZXRhLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy52YWx1ZSAhPT0gbWV0YS52YWx1ZSkge1xuICAgICAgICAgIHRoaXMudmFsdWUgPSBtZXRhLnZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1ldGE7XG4gICAgICB9LFxuXG4gICAgICBnZXQgbGlzdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19tZXRhICYmIHRoaXMuX19tZXRhLmxpc3Q7XG4gICAgICB9LFxuXG4gICAgICBfc2VsZkNoYW5nZWQ6IGZ1bmN0aW9uKHNlbGYpIHtcbiAgICAgICAgaWYgKHNlbGYpIHtcbiAgICAgICAgICB0aGlzLnZhbHVlID0gdGhpcztcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBSZXRyaWV2ZXMgbWV0YSBkYXRhIHZhbHVlIGJ5IGtleS5cbiAgICAgICAqXG4gICAgICAgKiBAbWV0aG9kIGJ5S2V5XG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGEtZGF0YSB0byBiZSByZXR1cm5lZC5cbiAgICAgICAqIEByZXR1cm4geyp9XG4gICAgICAgKi9cbiAgICAgIGJ5S2V5OiBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2x5bWVyLklyb25NZXRhKHtcbiAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgICAga2V5OiBrZXlcbiAgICAgICAgfSkudmFsdWU7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pKCk7XG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvaXJvbi1tZXRhL2lyb24tbWV0YS5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNSBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuXG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vcG9seW1lci9wb2x5bWVyLmh0bWxcIj5cblxuPHNjcmlwdD5cbiAgKGZ1bmN0aW9uKCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIC8qKlxuICAgICAqIENocm9tZSB1c2VzIGFuIG9sZGVyIHZlcnNpb24gb2YgRE9NIExldmVsIDMgS2V5Ym9hcmQgRXZlbnRzXG4gICAgICpcbiAgICAgKiBNb3N0IGtleXMgYXJlIGxhYmVsZWQgYXMgdGV4dCwgYnV0IHNvbWUgYXJlIFVuaWNvZGUgY29kZXBvaW50cy5cbiAgICAgKiBWYWx1ZXMgdGFrZW4gZnJvbTogaHR0cDovL3d3dy53My5vcmcvVFIvMjAwNy9XRC1ET00tTGV2ZWwtMy1FdmVudHMtMjAwNzEyMjEva2V5c2V0Lmh0bWwjS2V5U2V0LVNldFxuICAgICAqL1xuICAgIHZhciBLRVlfSURFTlRJRklFUiA9IHtcbiAgICAgICdVKzAwMDgnOiAnYmFja3NwYWNlJyxcbiAgICAgICdVKzAwMDknOiAndGFiJyxcbiAgICAgICdVKzAwMUInOiAnZXNjJyxcbiAgICAgICdVKzAwMjAnOiAnc3BhY2UnLFxuICAgICAgJ1UrMDA3Ric6ICdkZWwnXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNwZWNpYWwgdGFibGUgZm9yIEtleWJvYXJkRXZlbnQua2V5Q29kZS5cbiAgICAgKiBLZXlib2FyZEV2ZW50LmtleUlkZW50aWZpZXIgaXMgYmV0dGVyLCBhbmQgS2V5Qm9hcmRFdmVudC5rZXkgaXMgZXZlbiBiZXR0ZXJcbiAgICAgKiB0aGFuIHRoYXQuXG4gICAgICpcbiAgICAgKiBWYWx1ZXMgZnJvbTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0tleWJvYXJkRXZlbnQua2V5Q29kZSNWYWx1ZV9vZl9rZXlDb2RlXG4gICAgICovXG4gICAgdmFyIEtFWV9DT0RFID0ge1xuICAgICAgODogJ2JhY2tzcGFjZScsXG4gICAgICA5OiAndGFiJyxcbiAgICAgIDEzOiAnZW50ZXInLFxuICAgICAgMjc6ICdlc2MnLFxuICAgICAgMzM6ICdwYWdldXAnLFxuICAgICAgMzQ6ICdwYWdlZG93bicsXG4gICAgICAzNTogJ2VuZCcsXG4gICAgICAzNjogJ2hvbWUnLFxuICAgICAgMzI6ICdzcGFjZScsXG4gICAgICAzNzogJ2xlZnQnLFxuICAgICAgMzg6ICd1cCcsXG4gICAgICAzOTogJ3JpZ2h0JyxcbiAgICAgIDQwOiAnZG93bicsXG4gICAgICA0NjogJ2RlbCcsXG4gICAgICAxMDY6ICcqJ1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBNT0RJRklFUl9LRVlTIG1hcHMgdGhlIHNob3J0IG5hbWUgZm9yIG1vZGlmaWVyIGtleXMgdXNlZCBpbiBhIGtleVxuICAgICAqIGNvbWJvIHN0cmluZyB0byB0aGUgcHJvcGVydHkgbmFtZSB0aGF0IHJlZmVyZW5jZXMgdGhvc2Ugc2FtZSBrZXlzXG4gICAgICogaW4gYSBLZXlib2FyZEV2ZW50IGluc3RhbmNlLlxuICAgICAqL1xuICAgIHZhciBNT0RJRklFUl9LRVlTID0ge1xuICAgICAgJ3NoaWZ0JzogJ3NoaWZ0S2V5JyxcbiAgICAgICdjdHJsJzogJ2N0cmxLZXknLFxuICAgICAgJ2FsdCc6ICdhbHRLZXknLFxuICAgICAgJ21ldGEnOiAnbWV0YUtleSdcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogS2V5Ym9hcmRFdmVudC5rZXkgaXMgbW9zdGx5IHJlcHJlc2VudGVkIGJ5IHByaW50YWJsZSBjaGFyYWN0ZXIgbWFkZSBieVxuICAgICAqIHRoZSBrZXlib2FyZCwgd2l0aCB1bnByaW50YWJsZSBrZXlzIGxhYmVsZWQgbmljZWx5LlxuICAgICAqXG4gICAgICogSG93ZXZlciwgb24gT1MgWCwgQWx0K2NoYXIgY2FuIG1ha2UgYSBVbmljb2RlIGNoYXJhY3RlciB0aGF0IGZvbGxvd3MgYW5cbiAgICAgKiBBcHBsZS1zcGVjaWZpYyBtYXBwaW5nLiBJbiB0aGlzIGNhc2UsIHdlIGZhbGwgYmFjayB0byAua2V5Q29kZS5cbiAgICAgKi9cbiAgICB2YXIgS0VZX0NIQVIgPSAvW2EtejAtOSpdLztcblxuICAgIC8qKlxuICAgICAqIE1hdGNoZXMgYSBrZXlJZGVudGlmaWVyIHN0cmluZy5cbiAgICAgKi9cbiAgICB2YXIgSURFTlRfQ0hBUiA9IC9VXFwrLztcblxuICAgIC8qKlxuICAgICAqIE1hdGNoZXMgYXJyb3cga2V5cyBpbiBHZWNrbyAyNy4wK1xuICAgICAqL1xuICAgIHZhciBBUlJPV19LRVkgPSAvXmFycm93LztcblxuICAgIC8qKlxuICAgICAqIE1hdGNoZXMgc3BhY2Uga2V5cyBldmVyeXdoZXJlIChub3RhYmx5IGluY2x1ZGluZyBJRTEwJ3MgZXhjZXB0aW9uYWwgbmFtZVxuICAgICAqIGBzcGFjZWJhcmApLlxuICAgICAqL1xuICAgIHZhciBTUEFDRV9LRVkgPSAvXnNwYWNlKGJhcik/LztcblxuICAgIC8qKlxuICAgICAqIE1hdGNoZXMgRVNDIGtleS5cbiAgICAgKlxuICAgICAqIFZhbHVlIGZyb206IGh0dHA6Ly93M2MuZ2l0aHViLmlvL3VpZXZlbnRzLWtleS8ja2V5LUVzY2FwZVxuICAgICAqL1xuICAgIHZhciBFU0NfS0VZID0gL15lc2NhcGUkLztcblxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybXMgdGhlIGtleS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBLZXlCb2FyZEV2ZW50LmtleVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW25vU3BlY2lhbENoYXJzXSBMaW1pdHMgdGhlIHRyYW5zZm9ybWF0aW9uIHRvXG4gICAgICogYWxwaGEtbnVtZXJpYyBjaGFyYWN0ZXJzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRyYW5zZm9ybUtleShrZXksIG5vU3BlY2lhbENoYXJzKSB7XG4gICAgICB2YXIgdmFsaWRLZXkgPSAnJztcbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgdmFyIGxLZXkgPSBrZXkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKGxLZXkgPT09ICcgJyB8fCBTUEFDRV9LRVkudGVzdChsS2V5KSkge1xuICAgICAgICAgIHZhbGlkS2V5ID0gJ3NwYWNlJztcbiAgICAgICAgfSBlbHNlIGlmIChFU0NfS0VZLnRlc3QobEtleSkpIHtcbiAgICAgICAgICB2YWxpZEtleSA9ICdlc2MnO1xuICAgICAgICB9IGVsc2UgaWYgKGxLZXkubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICBpZiAoIW5vU3BlY2lhbENoYXJzIHx8IEtFWV9DSEFSLnRlc3QobEtleSkpIHtcbiAgICAgICAgICAgIHZhbGlkS2V5ID0gbEtleTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoQVJST1dfS0VZLnRlc3QobEtleSkpIHtcbiAgICAgICAgICB2YWxpZEtleSA9IGxLZXkucmVwbGFjZSgnYXJyb3cnLCAnJyk7XG4gICAgICAgIH0gZWxzZSBpZiAobEtleSA9PSAnbXVsdGlwbHknKSB7XG4gICAgICAgICAgLy8gbnVtcGFkICcqJyBjYW4gbWFwIHRvIE11bHRpcGx5IG9uIElFL1dpbmRvd3NcbiAgICAgICAgICB2YWxpZEtleSA9ICcqJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWxpZEtleSA9IGxLZXk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWxpZEtleTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0cmFuc2Zvcm1LZXlJZGVudGlmaWVyKGtleUlkZW50KSB7XG4gICAgICB2YXIgdmFsaWRLZXkgPSAnJztcbiAgICAgIGlmIChrZXlJZGVudCkge1xuICAgICAgICBpZiAoa2V5SWRlbnQgaW4gS0VZX0lERU5USUZJRVIpIHtcbiAgICAgICAgICB2YWxpZEtleSA9IEtFWV9JREVOVElGSUVSW2tleUlkZW50XTtcbiAgICAgICAgfSBlbHNlIGlmIChJREVOVF9DSEFSLnRlc3Qoa2V5SWRlbnQpKSB7XG4gICAgICAgICAga2V5SWRlbnQgPSBwYXJzZUludChrZXlJZGVudC5yZXBsYWNlKCdVKycsICcweCcpLCAxNik7XG4gICAgICAgICAgdmFsaWRLZXkgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGtleUlkZW50KS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbGlkS2V5ID0ga2V5SWRlbnQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbGlkS2V5O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRyYW5zZm9ybUtleUNvZGUoa2V5Q29kZSkge1xuICAgICAgdmFyIHZhbGlkS2V5ID0gJyc7XG4gICAgICBpZiAoTnVtYmVyKGtleUNvZGUpKSB7XG4gICAgICAgIGlmIChrZXlDb2RlID49IDY1ICYmIGtleUNvZGUgPD0gOTApIHtcbiAgICAgICAgICAvLyBhc2NpaSBhLXpcbiAgICAgICAgICAvLyBsb3dlcmNhc2UgaXMgMzIgb2Zmc2V0IGZyb20gdXBwZXJjYXNlXG4gICAgICAgICAgdmFsaWRLZXkgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDMyICsga2V5Q29kZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoa2V5Q29kZSA+PSAxMTIgJiYga2V5Q29kZSA8PSAxMjMpIHtcbiAgICAgICAgICAvLyBmdW5jdGlvbiBrZXlzIGYxLWYxMlxuICAgICAgICAgIHZhbGlkS2V5ID0gJ2YnICsgKGtleUNvZGUgLSAxMTIgKyAxKTtcbiAgICAgICAgfSBlbHNlIGlmIChrZXlDb2RlID49IDQ4ICYmIGtleUNvZGUgPD0gNTcpIHtcbiAgICAgICAgICAvLyB0b3AgMC05IGtleXNcbiAgICAgICAgICB2YWxpZEtleSA9IFN0cmluZyhrZXlDb2RlIC0gNDgpO1xuICAgICAgICB9IGVsc2UgaWYgKGtleUNvZGUgPj0gOTYgJiYga2V5Q29kZSA8PSAxMDUpIHtcbiAgICAgICAgICAvLyBudW0gcGFkIDAtOVxuICAgICAgICAgIHZhbGlkS2V5ID0gU3RyaW5nKGtleUNvZGUgLSA5Nik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsaWRLZXkgPSBLRVlfQ09ERVtrZXlDb2RlXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbGlkS2V5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAgKiBDYWxjdWxhdGVzIHRoZSBub3JtYWxpemVkIGtleSBmb3IgYSBLZXlib2FyZEV2ZW50LlxuICAgICAgKiBAcGFyYW0ge0tleWJvYXJkRXZlbnR9IGtleUV2ZW50XG4gICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW25vU3BlY2lhbENoYXJzXSBTZXQgdG8gdHJ1ZSB0byBsaW1pdCBrZXlFdmVudC5rZXlcbiAgICAgICogdHJhbnNmb3JtYXRpb24gdG8gYWxwaGEtbnVtZXJpYyBjaGFycy4gVGhpcyBpcyB1c2VmdWwgd2l0aCBrZXlcbiAgICAgICogY29tYmluYXRpb25zIGxpa2Ugc2hpZnQgKyAyLCB3aGljaCBvbiBGRiBmb3IgTWFjT1MgcHJvZHVjZXNcbiAgICAgICoga2V5RXZlbnQua2V5ID0gQFxuICAgICAgKiBUbyBnZXQgMiByZXR1cm5lZCwgc2V0IG5vU3BlY2lhbENoYXJzID0gdHJ1ZVxuICAgICAgKiBUbyBnZXQgQCByZXR1cm5lZCwgc2V0IG5vU3BlY2lhbENoYXJzID0gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBub3JtYWxpemVkS2V5Rm9yRXZlbnQoa2V5RXZlbnQsIG5vU3BlY2lhbENoYXJzKSB7XG4gICAgICAvLyBGYWxsIGJhY2sgZnJvbSAua2V5LCB0byAuZGV0YWlsLmtleSBmb3IgYXJ0aWZpY2FsIGtleWJvYXJkIGV2ZW50cyxcbiAgICAgIC8vIGFuZCB0aGVuIHRvIGRlcHJlY2F0ZWQgLmtleUlkZW50aWZpZXIgYW5kIC5rZXlDb2RlLlxuICAgICAgaWYgKGtleUV2ZW50LmtleSkge1xuICAgICAgICByZXR1cm4gdHJhbnNmb3JtS2V5KGtleUV2ZW50LmtleSwgbm9TcGVjaWFsQ2hhcnMpO1xuICAgICAgfVxuICAgICAgaWYgKGtleUV2ZW50LmRldGFpbCAmJiBrZXlFdmVudC5kZXRhaWwua2V5KSB7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1LZXkoa2V5RXZlbnQuZGV0YWlsLmtleSwgbm9TcGVjaWFsQ2hhcnMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRyYW5zZm9ybUtleUlkZW50aWZpZXIoa2V5RXZlbnQua2V5SWRlbnRpZmllcikgfHxcbiAgICAgICAgdHJhbnNmb3JtS2V5Q29kZShrZXlFdmVudC5rZXlDb2RlKSB8fCAnJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBrZXlDb21ib01hdGNoZXNFdmVudChrZXlDb21ibywgZXZlbnQpIHtcbiAgICAgIC8vIEZvciBjb21ib3Mgd2l0aCBtb2RpZmllcnMgd2Ugc3VwcG9ydCBvbmx5IGFscGhhLW51bWVyaWMga2V5c1xuICAgICAgdmFyIGtleUV2ZW50ID0gbm9ybWFsaXplZEtleUZvckV2ZW50KGV2ZW50LCBrZXlDb21iby5oYXNNb2RpZmllcnMpO1xuICAgICAgcmV0dXJuIGtleUV2ZW50ID09PSBrZXlDb21iby5rZXkgJiZcbiAgICAgICAgKCFrZXlDb21iby5oYXNNb2RpZmllcnMgfHwgKFxuICAgICAgICAgICEhZXZlbnQuc2hpZnRLZXkgPT09ICEha2V5Q29tYm8uc2hpZnRLZXkgJiZcbiAgICAgICAgICAhIWV2ZW50LmN0cmxLZXkgPT09ICEha2V5Q29tYm8uY3RybEtleSAmJlxuICAgICAgICAgICEhZXZlbnQuYWx0S2V5ID09PSAhIWtleUNvbWJvLmFsdEtleSAmJlxuICAgICAgICAgICEhZXZlbnQubWV0YUtleSA9PT0gISFrZXlDb21iby5tZXRhS2V5KVxuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlS2V5Q29tYm9TdHJpbmcoa2V5Q29tYm9TdHJpbmcpIHtcbiAgICAgIGlmIChrZXlDb21ib1N0cmluZy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBjb21ibzoga2V5Q29tYm9TdHJpbmcsXG4gICAgICAgICAga2V5OiBrZXlDb21ib1N0cmluZyxcbiAgICAgICAgICBldmVudDogJ2tleWRvd24nXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ga2V5Q29tYm9TdHJpbmcuc3BsaXQoJysnKS5yZWR1Y2UoZnVuY3Rpb24ocGFyc2VkS2V5Q29tYm8sIGtleUNvbWJvUGFydCkge1xuICAgICAgICB2YXIgZXZlbnRQYXJ0cyA9IGtleUNvbWJvUGFydC5zcGxpdCgnOicpO1xuICAgICAgICB2YXIga2V5TmFtZSA9IGV2ZW50UGFydHNbMF07XG4gICAgICAgIHZhciBldmVudCA9IGV2ZW50UGFydHNbMV07XG5cbiAgICAgICAgaWYgKGtleU5hbWUgaW4gTU9ESUZJRVJfS0VZUykge1xuICAgICAgICAgIHBhcnNlZEtleUNvbWJvW01PRElGSUVSX0tFWVNba2V5TmFtZV1dID0gdHJ1ZTtcbiAgICAgICAgICBwYXJzZWRLZXlDb21iby5oYXNNb2RpZmllcnMgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhcnNlZEtleUNvbWJvLmtleSA9IGtleU5hbWU7XG4gICAgICAgICAgcGFyc2VkS2V5Q29tYm8uZXZlbnQgPSBldmVudCB8fCAna2V5ZG93bic7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGFyc2VkS2V5Q29tYm87XG4gICAgICB9LCB7XG4gICAgICAgIGNvbWJvOiBrZXlDb21ib1N0cmluZy5zcGxpdCgnOicpLnNoaWZ0KClcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlRXZlbnRTdHJpbmcoZXZlbnRTdHJpbmcpIHtcbiAgICAgIHJldHVybiBldmVudFN0cmluZy50cmltKCkuc3BsaXQoJyAnKS5tYXAoZnVuY3Rpb24oa2V5Q29tYm9TdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlS2V5Q29tYm9TdHJpbmcoa2V5Q29tYm9TdHJpbmcpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogYFBvbHltZXIuSXJvbkExMXlLZXlzQmVoYXZpb3JgIHByb3ZpZGVzIGEgbm9ybWFsaXplZCBpbnRlcmZhY2UgZm9yIHByb2Nlc3NpbmdcbiAgICAgKiBrZXlib2FyZCBjb21tYW5kcyB0aGF0IHBlcnRhaW4gdG8gW1dBSS1BUklBIGJlc3QgcHJhY3RpY2VzXShodHRwOi8vd3d3LnczLm9yZy9UUi93YWktYXJpYS1wcmFjdGljZXMvI2tiZF9nZW5lcmFsX2JpbmRpbmcpLlxuICAgICAqIFRoZSBlbGVtZW50IHRha2VzIGNhcmUgb2YgYnJvd3NlciBkaWZmZXJlbmNlcyB3aXRoIHJlc3BlY3QgdG8gS2V5Ym9hcmQgZXZlbnRzXG4gICAgICogYW5kIHVzZXMgYW4gZXhwcmVzc2l2ZSBzeW50YXggdG8gZmlsdGVyIGtleSBwcmVzc2VzLlxuICAgICAqXG4gICAgICogVXNlIHRoZSBga2V5QmluZGluZ3NgIHByb3RvdHlwZSBwcm9wZXJ0eSB0byBleHByZXNzIHdoYXQgY29tYmluYXRpb24gb2Yga2V5c1xuICAgICAqIHdpbGwgdHJpZ2dlciB0aGUgY2FsbGJhY2suIEEga2V5IGJpbmRpbmcgaGFzIHRoZSBmb3JtYXRcbiAgICAgKiBgXCJLRVkrTU9ESUZJRVI6RVZFTlRcIjogXCJjYWxsYmFja1wiYCAoYFwiS0VZXCI6IFwiY2FsbGJhY2tcImAgb3JcbiAgICAgKiBgXCJLRVk6RVZFTlRcIjogXCJjYWxsYmFja1wiYCBhcmUgdmFsaWQgYXMgd2VsbCkuIFNvbWUgZXhhbXBsZXM6XG4gICAgICpcbiAgICAgKiAgICAgIGtleUJpbmRpbmdzOiB7XG4gICAgICogICAgICAgICdzcGFjZSc6ICdfb25LZXlkb3duJywgLy8gc2FtZSBhcyAnc3BhY2U6a2V5ZG93bidcbiAgICAgKiAgICAgICAgJ3NoaWZ0K3RhYic6ICdfb25LZXlkb3duJyxcbiAgICAgKiAgICAgICAgJ2VudGVyOmtleXByZXNzJzogJ19vbktleXByZXNzJyxcbiAgICAgKiAgICAgICAgJ2VzYzprZXl1cCc6ICdfb25LZXl1cCdcbiAgICAgKiAgICAgIH1cbiAgICAgKlxuICAgICAqIFRoZSBjYWxsYmFjayB3aWxsIHJlY2VpdmUgd2l0aCBhbiBldmVudCBjb250YWluaW5nIHRoZSBmb2xsb3dpbmcgaW5mb3JtYXRpb24gaW4gYGV2ZW50LmRldGFpbGA6XG4gICAgICpcbiAgICAgKiAgICAgIF9vbktleWRvd246IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICogICAgICAgIGNvbnNvbGUubG9nKGV2ZW50LmRldGFpbC5jb21ibyk7IC8vIEtFWStNT0RJRklFUiwgZS5nLiBcInNoaWZ0K3RhYlwiXG4gICAgICogICAgICAgIGNvbnNvbGUubG9nKGV2ZW50LmRldGFpbC5rZXkpOyAvLyBLRVkgb25seSwgZS5nLiBcInRhYlwiXG4gICAgICogICAgICAgIGNvbnNvbGUubG9nKGV2ZW50LmRldGFpbC5ldmVudCk7IC8vIEVWRU5ULCBlLmcuIFwia2V5ZG93blwiXG4gICAgICogICAgICAgIGNvbnNvbGUubG9nKGV2ZW50LmRldGFpbC5rZXlib2FyZEV2ZW50KTsgLy8gdGhlIG9yaWdpbmFsIEtleWJvYXJkRXZlbnRcbiAgICAgKiAgICAgIH1cbiAgICAgKlxuICAgICAqIFVzZSB0aGUgYGtleUV2ZW50VGFyZ2V0YCBhdHRyaWJ1dGUgdG8gc2V0IHVwIGV2ZW50IGhhbmRsZXJzIG9uIGEgc3BlY2lmaWNcbiAgICAgKiBub2RlLlxuICAgICAqXG4gICAgICogU2VlIHRoZSBbZGVtbyBzb3VyY2UgY29kZV0oaHR0cHM6Ly9naXRodWIuY29tL1BvbHltZXJFbGVtZW50cy9pcm9uLWExMXkta2V5cy1iZWhhdmlvci9ibG9iL21hc3Rlci9kZW1vL3gta2V5LWF3YXJlLmh0bWwpXG4gICAgICogZm9yIGFuIGV4YW1wbGUuXG4gICAgICpcbiAgICAgKiBAZGVtbyBkZW1vL2luZGV4Lmh0bWxcbiAgICAgKiBAcG9seW1lckJlaGF2aW9yXG4gICAgICovXG4gICAgUG9seW1lci5Jcm9uQTExeUtleXNCZWhhdmlvciA9IHtcbiAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBFdmVudFRhcmdldCB0aGF0IHdpbGwgYmUgZmlyaW5nIHJlbGV2YW50IEtleWJvYXJkRXZlbnRzLiBTZXQgaXQgdG9cbiAgICAgICAgICogYG51bGxgIHRvIGRpc2FibGUgdGhlIGxpc3RlbmVycy5cbiAgICAgICAgICogQHR5cGUgez9FdmVudFRhcmdldH1cbiAgICAgICAgICovXG4gICAgICAgIGtleUV2ZW50VGFyZ2V0OiB7XG4gICAgICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgdHJ1ZSwgdGhpcyBwcm9wZXJ0eSB3aWxsIGNhdXNlIHRoZSBpbXBsZW1lbnRpbmcgZWxlbWVudCB0b1xuICAgICAgICAgKiBhdXRvbWF0aWNhbGx5IHN0b3AgcHJvcGFnYXRpb24gb24gYW55IGhhbmRsZWQgS2V5Ym9hcmRFdmVudHMuXG4gICAgICAgICAqL1xuICAgICAgICBzdG9wS2V5Ym9hcmRFdmVudFByb3BhZ2F0aW9uOiB7XG4gICAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgfSxcblxuICAgICAgICBfYm91bmRLZXlIYW5kbGVyczoge1xuICAgICAgICAgIHR5cGU6IEFycmF5LFxuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gV2UgdXNlIHRoaXMgZHVlIHRvIGEgbGltaXRhdGlvbiBpbiBJRTEwIHdoZXJlIGluc3RhbmNlcyB3aWxsIGhhdmVcbiAgICAgICAgLy8gb3duIHByb3BlcnRpZXMgb2YgZXZlcnl0aGluZyBvbiB0aGUgXCJwcm90b3R5cGVcIi5cbiAgICAgICAgX2ltcGVyYXRpdmVLZXlCaW5kaW5nczoge1xuICAgICAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBvYnNlcnZlcnM6IFtcbiAgICAgICAgJ19yZXNldEtleUV2ZW50TGlzdGVuZXJzKGtleUV2ZW50VGFyZ2V0LCBfYm91bmRLZXlIYW5kbGVycyknXG4gICAgICBdLFxuXG5cbiAgICAgIC8qKlxuICAgICAgICogVG8gYmUgdXNlZCB0byBleHByZXNzIHdoYXQgY29tYmluYXRpb24gb2Yga2V5cyAgd2lsbCB0cmlnZ2VyIHRoZSByZWxhdGl2ZVxuICAgICAgICogY2FsbGJhY2suIGUuZy4gYGtleUJpbmRpbmdzOiB7ICdlc2MnOiAnX29uRXNjUHJlc3NlZCd9YFxuICAgICAgICogQHR5cGUgeyFPYmplY3R9XG4gICAgICAgKi9cbiAgICAgIGtleUJpbmRpbmdzOiB7fSxcblxuICAgICAgcmVnaXN0ZXJlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX3ByZXBLZXlCaW5kaW5ncygpO1xuICAgICAgfSxcblxuICAgICAgYXR0YWNoZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9saXN0ZW5LZXlFdmVudExpc3RlbmVycygpO1xuICAgICAgfSxcblxuICAgICAgZGV0YWNoZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl91bmxpc3RlbktleUV2ZW50TGlzdGVuZXJzKCk7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIENhbiBiZSB1c2VkIHRvIGltcGVyYXRpdmVseSBhZGQgYSBrZXkgYmluZGluZyB0byB0aGUgaW1wbGVtZW50aW5nXG4gICAgICAgKiBlbGVtZW50LiBUaGlzIGlzIHRoZSBpbXBlcmF0aXZlIGVxdWl2YWxlbnQgb2YgZGVjbGFyaW5nIGEga2V5YmluZGluZ1xuICAgICAgICogaW4gdGhlIGBrZXlCaW5kaW5nc2AgcHJvdG90eXBlIHByb3BlcnR5LlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFN0cmluZ1xuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGhhbmRsZXJOYW1lXG4gICAgICAgKi9cbiAgICAgIGFkZE93bktleUJpbmRpbmc6IGZ1bmN0aW9uKGV2ZW50U3RyaW5nLCBoYW5kbGVyTmFtZSkge1xuICAgICAgICB0aGlzLl9pbXBlcmF0aXZlS2V5QmluZGluZ3NbZXZlbnRTdHJpbmddID0gaGFuZGxlck5hbWU7XG4gICAgICAgIHRoaXMuX3ByZXBLZXlCaW5kaW5ncygpO1xuICAgICAgICB0aGlzLl9yZXNldEtleUV2ZW50TGlzdGVuZXJzKCk7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFdoZW4gY2FsbGVkLCB3aWxsIHJlbW92ZSBhbGwgaW1wZXJhdGl2ZWx5LWFkZGVkIGtleSBiaW5kaW5ncy5cbiAgICAgICAqL1xuICAgICAgcmVtb3ZlT3duS2V5QmluZGluZ3M6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9pbXBlcmF0aXZlS2V5QmluZGluZ3MgPSB7fTtcbiAgICAgICAgdGhpcy5fcHJlcEtleUJpbmRpbmdzKCk7XG4gICAgICAgIHRoaXMuX3Jlc2V0S2V5RXZlbnRMaXN0ZW5lcnMoKTtcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogUmV0dXJucyB0cnVlIGlmIGEga2V5Ym9hcmQgZXZlbnQgbWF0Y2hlcyBgZXZlbnRTdHJpbmdgLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7S2V5Ym9hcmRFdmVudH0gZXZlbnRcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFN0cmluZ1xuICAgICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgICAqL1xuICAgICAga2V5Ym9hcmRFdmVudE1hdGNoZXNLZXlzOiBmdW5jdGlvbihldmVudCwgZXZlbnRTdHJpbmcpIHtcbiAgICAgICAgdmFyIGtleUNvbWJvcyA9IHBhcnNlRXZlbnRTdHJpbmcoZXZlbnRTdHJpbmcpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleUNvbWJvcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGlmIChrZXlDb21ib01hdGNoZXNFdmVudChrZXlDb21ib3NbaV0sIGV2ZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0sXG5cbiAgICAgIF9jb2xsZWN0S2V5QmluZGluZ3M6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIga2V5QmluZGluZ3MgPSB0aGlzLmJlaGF2aW9ycy5tYXAoZnVuY3Rpb24oYmVoYXZpb3IpIHtcbiAgICAgICAgICByZXR1cm4gYmVoYXZpb3Iua2V5QmluZGluZ3M7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChrZXlCaW5kaW5ncy5pbmRleE9mKHRoaXMua2V5QmluZGluZ3MpID09PSAtMSkge1xuICAgICAgICAgIGtleUJpbmRpbmdzLnB1c2godGhpcy5rZXlCaW5kaW5ncyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ga2V5QmluZGluZ3M7XG4gICAgICB9LFxuXG4gICAgICBfcHJlcEtleUJpbmRpbmdzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fa2V5QmluZGluZ3MgPSB7fTtcblxuICAgICAgICB0aGlzLl9jb2xsZWN0S2V5QmluZGluZ3MoKS5mb3JFYWNoKGZ1bmN0aW9uKGtleUJpbmRpbmdzKSB7XG4gICAgICAgICAgZm9yICh2YXIgZXZlbnRTdHJpbmcgaW4ga2V5QmluZGluZ3MpIHtcbiAgICAgICAgICAgIHRoaXMuX2FkZEtleUJpbmRpbmcoZXZlbnRTdHJpbmcsIGtleUJpbmRpbmdzW2V2ZW50U3RyaW5nXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICBmb3IgKHZhciBldmVudFN0cmluZyBpbiB0aGlzLl9pbXBlcmF0aXZlS2V5QmluZGluZ3MpIHtcbiAgICAgICAgICB0aGlzLl9hZGRLZXlCaW5kaW5nKGV2ZW50U3RyaW5nLCB0aGlzLl9pbXBlcmF0aXZlS2V5QmluZGluZ3NbZXZlbnRTdHJpbmddKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEdpdmUgcHJlY2VkZW5jZSB0byBjb21ib3Mgd2l0aCBtb2RpZmllcnMgdG8gYmUgY2hlY2tlZCBmaXJzdC5cbiAgICAgICAgZm9yICh2YXIgZXZlbnROYW1lIGluIHRoaXMuX2tleUJpbmRpbmdzKSB7XG4gICAgICAgICAgdGhpcy5fa2V5QmluZGluZ3NbZXZlbnROYW1lXS5zb3J0KGZ1bmN0aW9uIChrYjEsIGtiMikge1xuICAgICAgICAgICAgdmFyIGIxID0ga2IxWzBdLmhhc01vZGlmaWVycztcbiAgICAgICAgICAgIHZhciBiMiA9IGtiMlswXS5oYXNNb2RpZmllcnM7XG4gICAgICAgICAgICByZXR1cm4gKGIxID09PSBiMikgPyAwIDogYjEgPyAtMSA6IDE7XG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgX2FkZEtleUJpbmRpbmc6IGZ1bmN0aW9uKGV2ZW50U3RyaW5nLCBoYW5kbGVyTmFtZSkge1xuICAgICAgICBwYXJzZUV2ZW50U3RyaW5nKGV2ZW50U3RyaW5nKS5mb3JFYWNoKGZ1bmN0aW9uKGtleUNvbWJvKSB7XG4gICAgICAgICAgdGhpcy5fa2V5QmluZGluZ3Nba2V5Q29tYm8uZXZlbnRdID1cbiAgICAgICAgICAgIHRoaXMuX2tleUJpbmRpbmdzW2tleUNvbWJvLmV2ZW50XSB8fCBbXTtcblxuICAgICAgICAgIHRoaXMuX2tleUJpbmRpbmdzW2tleUNvbWJvLmV2ZW50XS5wdXNoKFtcbiAgICAgICAgICAgIGtleUNvbWJvLFxuICAgICAgICAgICAgaGFuZGxlck5hbWVcbiAgICAgICAgICBdKTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICB9LFxuXG4gICAgICBfcmVzZXRLZXlFdmVudExpc3RlbmVyczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX3VubGlzdGVuS2V5RXZlbnRMaXN0ZW5lcnMoKTtcblxuICAgICAgICBpZiAodGhpcy5pc0F0dGFjaGVkKSB7XG4gICAgICAgICAgdGhpcy5fbGlzdGVuS2V5RXZlbnRMaXN0ZW5lcnMoKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgX2xpc3RlbktleUV2ZW50TGlzdGVuZXJzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmtleUV2ZW50VGFyZ2V0KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5rZXlzKHRoaXMuX2tleUJpbmRpbmdzKS5mb3JFYWNoKGZ1bmN0aW9uKGV2ZW50TmFtZSkge1xuICAgICAgICAgIHZhciBrZXlCaW5kaW5ncyA9IHRoaXMuX2tleUJpbmRpbmdzW2V2ZW50TmFtZV07XG4gICAgICAgICAgdmFyIGJvdW5kS2V5SGFuZGxlciA9IHRoaXMuX29uS2V5QmluZGluZ0V2ZW50LmJpbmQodGhpcywga2V5QmluZGluZ3MpO1xuXG4gICAgICAgICAgdGhpcy5fYm91bmRLZXlIYW5kbGVycy5wdXNoKFt0aGlzLmtleUV2ZW50VGFyZ2V0LCBldmVudE5hbWUsIGJvdW5kS2V5SGFuZGxlcl0pO1xuXG4gICAgICAgICAgdGhpcy5rZXlFdmVudFRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgYm91bmRLZXlIYW5kbGVyKTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICB9LFxuXG4gICAgICBfdW5saXN0ZW5LZXlFdmVudExpc3RlbmVyczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBrZXlIYW5kbGVyVHVwbGU7XG4gICAgICAgIHZhciBrZXlFdmVudFRhcmdldDtcbiAgICAgICAgdmFyIGV2ZW50TmFtZTtcbiAgICAgICAgdmFyIGJvdW5kS2V5SGFuZGxlcjtcblxuICAgICAgICB3aGlsZSAodGhpcy5fYm91bmRLZXlIYW5kbGVycy5sZW5ndGgpIHtcbiAgICAgICAgICAvLyBNeSBraW5nZG9tIGZvciBibG9jay1zY29wZSBiaW5kaW5nIGFuZCBkZXN0cnVjdHVyaW5nIGFzc2lnbm1lbnQuLlxuICAgICAgICAgIGtleUhhbmRsZXJUdXBsZSA9IHRoaXMuX2JvdW5kS2V5SGFuZGxlcnMucG9wKCk7XG4gICAgICAgICAga2V5RXZlbnRUYXJnZXQgPSBrZXlIYW5kbGVyVHVwbGVbMF07XG4gICAgICAgICAgZXZlbnROYW1lID0ga2V5SGFuZGxlclR1cGxlWzFdO1xuICAgICAgICAgIGJvdW5kS2V5SGFuZGxlciA9IGtleUhhbmRsZXJUdXBsZVsyXTtcblxuICAgICAgICAgIGtleUV2ZW50VGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBib3VuZEtleUhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBfb25LZXlCaW5kaW5nRXZlbnQ6IGZ1bmN0aW9uKGtleUJpbmRpbmdzLCBldmVudCkge1xuICAgICAgICBpZiAodGhpcy5zdG9wS2V5Ym9hcmRFdmVudFByb3BhZ2F0aW9uKSB7XG4gICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiBldmVudCBoYXMgYmVlbiBhbHJlYWR5IHByZXZlbnRlZCwgZG9uJ3QgZG8gYW55dGhpbmdcbiAgICAgICAgaWYgKGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleUJpbmRpbmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGtleUNvbWJvID0ga2V5QmluZGluZ3NbaV1bMF07XG4gICAgICAgICAgdmFyIGhhbmRsZXJOYW1lID0ga2V5QmluZGluZ3NbaV1bMV07XG4gICAgICAgICAgaWYgKGtleUNvbWJvTWF0Y2hlc0V2ZW50KGtleUNvbWJvLCBldmVudCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3RyaWdnZXJLZXlIYW5kbGVyKGtleUNvbWJvLCBoYW5kbGVyTmFtZSwgZXZlbnQpO1xuICAgICAgICAgICAgLy8gZXhpdCB0aGUgbG9vcCBpZiBldmVudERlZmF1bHQgd2FzIHByZXZlbnRlZFxuICAgICAgICAgICAgaWYgKGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgX3RyaWdnZXJLZXlIYW5kbGVyOiBmdW5jdGlvbihrZXlDb21ibywgaGFuZGxlck5hbWUsIGtleWJvYXJkRXZlbnQpIHtcbiAgICAgICAgdmFyIGRldGFpbCA9IE9iamVjdC5jcmVhdGUoa2V5Q29tYm8pO1xuICAgICAgICBkZXRhaWwua2V5Ym9hcmRFdmVudCA9IGtleWJvYXJkRXZlbnQ7XG4gICAgICAgIHZhciBldmVudCA9IG5ldyBDdXN0b21FdmVudChrZXlDb21iby5ldmVudCwge1xuICAgICAgICAgIGRldGFpbDogZGV0YWlsLFxuICAgICAgICAgIGNhbmNlbGFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXNbaGFuZGxlck5hbWVdLmNhbGwodGhpcywgZXZlbnQpO1xuICAgICAgICBpZiAoZXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICAgIGtleWJvYXJkRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH0pKCk7XG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvaXJvbi1hMTF5LWtleXMtYmVoYXZpb3IvaXJvbi1hMTF5LWtleXMtYmVoYXZpb3IuaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTYgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cblxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9wb2x5bWVyLWVsZW1lbnQuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL2Jvd2VyX2NvbXBvbmVudHMvYXBwLWxheW91dC9hcHAtZHJhd2VyL2FwcC1kcmF3ZXIuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL2Jvd2VyX2NvbXBvbmVudHMvYXBwLWxheW91dC9hcHAtZHJhd2VyLWxheW91dC9hcHAtZHJhd2VyLWxheW91dC5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vYm93ZXJfY29tcG9uZW50cy9hcHAtbGF5b3V0L2FwcC1oZWFkZXIvYXBwLWhlYWRlci5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vYm93ZXJfY29tcG9uZW50cy9hcHAtbGF5b3V0L2FwcC1oZWFkZXItbGF5b3V0L2FwcC1oZWFkZXItbGF5b3V0Lmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi9ib3dlcl9jb21wb25lbnRzL2FwcC1sYXlvdXQvYXBwLXNjcm9sbC1lZmZlY3RzL2FwcC1zY3JvbGwtZWZmZWN0cy5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vYm93ZXJfY29tcG9uZW50cy9hcHAtbGF5b3V0L2FwcC10b29sYmFyL2FwcC10b29sYmFyLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi9ib3dlcl9jb21wb25lbnRzL2FwcC1yb3V0ZS9hcHAtbG9jYXRpb24uaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL2Jvd2VyX2NvbXBvbmVudHMvYXBwLXJvdXRlL2FwcC1yb3V0ZS5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vYm93ZXJfY29tcG9uZW50cy9pcm9uLXBhZ2VzL2lyb24tcGFnZXMuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL2Jvd2VyX2NvbXBvbmVudHMvaXJvbi1zZWxlY3Rvci9pcm9uLXNlbGVjdG9yLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi9ib3dlcl9jb21wb25lbnRzL3BhcGVyLWljb24tYnV0dG9uL3BhcGVyLWljb24tYnV0dG9uLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCJteS1pY29ucy5odG1sXCI+XG5cbjxkb20tbW9kdWxlIGlkPVwibXktYXBwXCI+XG4gIDx0ZW1wbGF0ZT5cbiAgICA8c3R5bGU+XG4gICAgICA6aG9zdCB7XG4gICAgICAgIC0tYXBwLXByaW1hcnktY29sb3I6ICM0Mjg1ZjQ7XG4gICAgICAgIC0tYXBwLXNlY29uZGFyeS1jb2xvcjogYmxhY2s7XG5cbiAgICAgICAgZGlzcGxheTogYmxvY2s7XG4gICAgICB9XG5cbiAgICAgIGFwcC1kcmF3ZXItbGF5b3V0Om5vdChbbmFycm93XSkgW2RyYXdlci10b2dnbGVdIHtcbiAgICAgICAgZGlzcGxheTogbm9uZTtcbiAgICAgIH1cblxuICAgICAgYXBwLWhlYWRlciB7XG4gICAgICAgIGNvbG9yOiAjZmZmO1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1hcHAtcHJpbWFyeS1jb2xvcik7XG4gICAgICB9XG5cbiAgICAgIGFwcC1oZWFkZXIgcGFwZXItaWNvbi1idXR0b24ge1xuICAgICAgICAtLXBhcGVyLWljb24tYnV0dG9uLWluay1jb2xvcjogd2hpdGU7XG4gICAgICB9XG5cbiAgICAgIC5kcmF3ZXItbGlzdCB7XG4gICAgICAgIG1hcmdpbjogMCAyMHB4O1xuICAgICAgfVxuXG4gICAgICAuZHJhd2VyLWxpc3QgYSB7XG4gICAgICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgICAgICBwYWRkaW5nOiAwIDE2cHg7XG4gICAgICAgIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcbiAgICAgICAgY29sb3I6IHZhcigtLWFwcC1zZWNvbmRhcnktY29sb3IpO1xuICAgICAgICBsaW5lLWhlaWdodDogNDBweDtcbiAgICAgIH1cblxuICAgICAgLmRyYXdlci1saXN0IGEuaXJvbi1zZWxlY3RlZCB7XG4gICAgICAgIGNvbG9yOiBibGFjaztcbiAgICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgICB9XG4gICAgPC9zdHlsZT5cblxuICAgIDxhcHAtbG9jYXRpb24gcm91dGU9XCJ7e3JvdXRlfX1cIiB1cmwtc3BhY2UtcmVnZXg9XCJeW1tyb290UGF0aF1dXCI+PC9hcHAtbG9jYXRpb24+XG4gICAgPGFwcC1yb3V0ZVxuICAgICAgICByb3V0ZT1cInt7cm91dGV9fVwiXG4gICAgICAgIHBhdHRlcm49XCJbW3Jvb3RQYXRoXV06cGFnZVwiXG4gICAgICAgIGRhdGE9XCJ7e3JvdXRlRGF0YX19XCJcbiAgICAgICAgdGFpbD1cInt7c3Vicm91dGV9fVwiPjwvYXBwLXJvdXRlPlxuXG4gICAgPGFwcC1kcmF3ZXItbGF5b3V0IGZ1bGxibGVlZD5cbiAgICAgIDwhLS0gRHJhd2VyIGNvbnRlbnQgLS0+XG4gICAgICA8YXBwLWRyYXdlciBpZD1cImRyYXdlclwiIHNsb3Q9XCJkcmF3ZXJcIj5cbiAgICAgICAgPGFwcC10b29sYmFyPk1lbnU8L2FwcC10b29sYmFyPlxuICAgICAgICA8aXJvbi1zZWxlY3RvciBzZWxlY3RlZD1cIltbcGFnZV1dXCIgYXR0ci1mb3Itc2VsZWN0ZWQ9XCJuYW1lXCIgY2xhc3M9XCJkcmF3ZXItbGlzdFwiIHJvbGU9XCJuYXZpZ2F0aW9uXCI+XG4gICAgICAgICAgPGEgbmFtZT1cInZpZXcxXCIgaHJlZiQ9XCJbW3Jvb3RQYXRoXV12aWV3MVwiPlZpZXcgT25lPC9hPlxuICAgICAgICAgIDxhIG5hbWU9XCJ2aWV3MlwiIGhyZWYkPVwiW1tyb290UGF0aF1ddmlldzJcIj5WaWV3IFR3bzwvYT5cbiAgICAgICAgICA8YSBuYW1lPVwidmlldzNcIiBocmVmJD1cIltbcm9vdFBhdGhdXXZpZXczXCI+VmlldyBUaHJlZTwvYT5cbiAgICAgICAgICA8YSBuYW1lPVwidmlldzRcIiBocmVmJD1cIltbcm9vdFBhdGhdXXZpZXc0XCI+VmlldyBGb3VyPC9hPlxuICAgICAgICA8L2lyb24tc2VsZWN0b3I+XG4gICAgICA8L2FwcC1kcmF3ZXI+XG5cbiAgICAgIDwhLS0gTWFpbiBjb250ZW50IC0tPlxuICAgICAgPGFwcC1oZWFkZXItbGF5b3V0IGhhcy1zY3JvbGxpbmctcmVnaW9uPlxuXG4gICAgICAgIDxhcHAtaGVhZGVyIHNsb3Q9XCJoZWFkZXJcIiBjb25kZW5zZXMgcmV2ZWFscyBlZmZlY3RzPVwid2F0ZXJmYWxsXCI+XG4gICAgICAgICAgPGFwcC10b29sYmFyPlxuICAgICAgICAgICAgPHBhcGVyLWljb24tYnV0dG9uIGljb249XCJteS1pY29uczptZW51XCIgZHJhd2VyLXRvZ2dsZT48L3BhcGVyLWljb24tYnV0dG9uPlxuICAgICAgICAgICAgPGRpdiBtYWluLXRpdGxlPk15IEFwcDwvZGl2PlxuICAgICAgICAgIDwvYXBwLXRvb2xiYXI+XG4gICAgICAgIDwvYXBwLWhlYWRlcj5cblxuICAgICAgICA8aXJvbi1wYWdlc1xuICAgICAgICAgICAgc2VsZWN0ZWQ9XCJbW3BhZ2VdXVwiXG4gICAgICAgICAgICBhdHRyLWZvci1zZWxlY3RlZD1cIm5hbWVcIlxuICAgICAgICAgICAgZmFsbGJhY2stc2VsZWN0aW9uPVwidmlldzQwNFwiXG4gICAgICAgICAgICByb2xlPVwibWFpblwiPlxuICAgICAgICAgIDxteS12aWV3MSBuYW1lPVwidmlldzFcIj48L215LXZpZXcxPlxuICAgICAgICAgIDxteS12aWV3MiBuYW1lPVwidmlldzJcIj48L215LXZpZXcyPlxuICAgICAgICAgIDxteS12aWV3MyBuYW1lPVwidmlldzNcIj48L215LXZpZXczPlxuICAgICAgICAgIDxteS12aWV3NDA0IG5hbWU9XCJ2aWV3NDA0XCI+PC9teS12aWV3NDA0PlxuICAgICAgICA8L2lyb24tcGFnZXM+XG4gICAgICA8L2FwcC1oZWFkZXItbGF5b3V0PlxuICAgIDwvYXBwLWRyYXdlci1sYXlvdXQ+XG4gIDwvdGVtcGxhdGU+XG5cbiAgPHNjcmlwdD5cbiAgICBjbGFzcyBNeUFwcCBleHRlbmRzIFBvbHltZXIuRWxlbWVudCB7XG5cbiAgICAgIHN0YXRpYyBnZXQgaXMoKSB7IHJldHVybiAnbXktYXBwJzsgfVxuXG4gICAgICBzdGF0aWMgZ2V0IHByb3BlcnRpZXMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcGFnZToge1xuICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgICAgcmVmbGVjdFRvQXR0cmlidXRlOiB0cnVlLFxuICAgICAgICAgICAgb2JzZXJ2ZXI6ICdfcGFnZUNoYW5nZWQnLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgcm91dGVEYXRhOiBPYmplY3QsXG4gICAgICAgICAgc3Vicm91dGU6IFN0cmluZyxcbiAgICAgICAgICByb290UGF0aDoge1xuICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgICAgdmFsdWU6ICcvJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgbGF6eVBhZ2VzOiB7XG4gICAgICAgICAgICB0eXBlOiBPYmplY3QsXG4gICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICB2aWV3MTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaW1wb3J0KC8qIHdlYnBhY2tDaHVua05hbWU6IFwibXktdmlldzFcIiAqLyAnLi9teS12aWV3MS5odG1sJyk7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHZpZXcyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpbXBvcnQoLyogd2VicGFja0NodW5rTmFtZTogXCJteS12aWV3MlwiICovICcuL215LXZpZXcyLmh0bWwnKTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgdmlldzM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGltcG9ydCgvKiB3ZWJwYWNrQ2h1bmtOYW1lOiBcIm15LXZpZXczXCIgKi8gJy4vbXktdmlldzMuaHRtbCcpO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB2aWV3NDA0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpbXBvcnQoLyogd2VicGFja0NodW5rTmFtZTogXCJteS12aWV3NDA0XCIgKi8gJy4vbXktdmlldzQwNC5odG1sJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHN0YXRpYyBnZXQgb2JzZXJ2ZXJzKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICdfcm91dGVQYWdlQ2hhbmdlZChyb3V0ZURhdGEucGFnZSknLFxuICAgICAgICBdO1xuICAgICAgfVxuXG4gICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgIH1cblxuICAgICAgX3JvdXRlUGFnZUNoYW5nZWQocGFnZSkge1xuICAgICAgICAvLyBQb2x5bWVyIDIuMCB3aWxsIGNhbGwgd2l0aCBgdW5kZWZpbmVkYCBvbiBpbml0aWFsaXphdGlvbi5cbiAgICAgICAgLy8gSWdub3JlIHVudGlsIHdlIGFyZSBwcm9wZXJseSBjYWxsZWQgd2l0aCBhIHN0cmluZy5cbiAgICAgICAgaWYgKHBhZ2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIG5vIHBhZ2Ugd2FzIGZvdW5kIGluIHRoZSByb3V0ZSBkYXRhLCBwYWdlIHdpbGwgYmUgYW4gZW1wdHkgc3RyaW5nLlxuICAgICAgICAvLyBEZWF1bHQgdG8gJ3ZpZXcxJyBpbiB0aGF0IGNhc2UuXG4gICAgICAgIHRoaXMucGFnZSA9IHBhZ2UgfHwgJ3ZpZXcxJztcblxuICAgICAgICAvLyBDbG9zZSBhIG5vbi1wZXJzaXN0ZW50IGRyYXdlciB3aGVuIHRoZSBwYWdlICYgcm91dGUgYXJlIGNoYW5nZWQuXG4gICAgICAgIGlmICghdGhpcy4kLmRyYXdlci5wZXJzaXN0ZW50KSB7XG4gICAgICAgICAgdGhpcy4kLmRyYXdlci5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIF9wYWdlQ2hhbmdlZChwYWdlKSB7XG4gICAgICAgIGlmKHRoaXMubGF6eVBhZ2VzW3BhZ2VdKXtcbiAgICAgICAgICB0aGlzLmxhenlQYWdlc1twYWdlXSgpOyAgICAgICBcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9zaG93UGFnZTQwNCgpO1xuICAgICAgICB9ICAgICAgICBcbiAgICAgIH1cblxuICAgICAgX3Nob3dQYWdlNDA0KCkge1xuICAgICAgICB0aGlzLnBhZ2UgPSAndmlldzQwNCc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgd2luZG93LmN1c3RvbUVsZW1lbnRzLmRlZmluZShNeUFwcC5pcywgTXlBcHApO1xuICA8L3NjcmlwdD5cbjwvZG9tLW1vZHVsZT5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9teS1hcHAuaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi91dGlscy9ib290Lmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi91dGlscy9yZXNvbHZlLXVybC5odG1sXCI+XG48c2NyaXB0PlxuKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgbGV0IG1vZHVsZXMgPSB7fTtcbiAgbGV0IGxjTW9kdWxlcyA9IHt9O1xuICBmdW5jdGlvbiBmaW5kTW9kdWxlKGlkKSB7XG4gICAgcmV0dXJuIG1vZHVsZXNbaWRdIHx8IGxjTW9kdWxlc1tpZC50b0xvd2VyQ2FzZSgpXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHN0eWxlT3V0c2lkZVRlbXBsYXRlQ2hlY2soaW5zdCkge1xuICAgIGlmIChpbnN0LnF1ZXJ5U2VsZWN0b3IoJ3N0eWxlJykpIHtcbiAgICAgIGNvbnNvbGUud2FybignZG9tLW1vZHVsZSAlcyBoYXMgc3R5bGUgb3V0c2lkZSB0ZW1wbGF0ZScsIGluc3QuaWQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYGRvbS1tb2R1bGVgIGVsZW1lbnQgcmVnaXN0ZXJzIHRoZSBkb20gaXQgY29udGFpbnMgdG8gdGhlIG5hbWUgZ2l2ZW5cbiAgICogYnkgdGhlIG1vZHVsZSdzIGlkIGF0dHJpYnV0ZS4gSXQgcHJvdmlkZXMgYSB1bmlmaWVkIGRhdGFiYXNlIG9mIGRvbVxuICAgKiBhY2Nlc3NpYmxlIHZpYSBpdHMgc3RhdGljIGBpbXBvcnRgIEFQSS5cbiAgICpcbiAgICogQSBrZXkgdXNlIGNhc2Ugb2YgYGRvbS1tb2R1bGVgIGlzIGZvciBwcm92aWRpbmcgY3VzdG9tIGVsZW1lbnQgYDx0ZW1wbGF0ZT5gc1xuICAgKiB2aWEgSFRNTCBpbXBvcnRzIHRoYXQgYXJlIHBhcnNlZCBieSB0aGUgbmF0aXZlIEhUTUwgcGFyc2VyLCB0aGF0IGNhbiBiZVxuICAgKiByZWxvY2F0ZWQgZHVyaW5nIGEgYnVuZGxpbmcgcGFzcyBhbmQgc3RpbGwgbG9va2VkIHVwIGJ5IGBpZGAuXG4gICAqXG4gICAqIEV4YW1wbGU6XG4gICAqXG4gICAqICAgICA8ZG9tLW1vZHVsZSBpZD1cImZvb1wiPlxuICAgKiAgICAgICA8aW1nIHNyYz1cInN0dWZmLnBuZ1wiPlxuICAgKiAgICAgPC9kb20tbW9kdWxlPlxuICAgKlxuICAgKiBUaGVuIGluIGNvZGUgaW4gc29tZSBvdGhlciBsb2NhdGlvbiB0aGF0IGNhbm5vdCBhY2Nlc3MgdGhlIGRvbS1tb2R1bGUgYWJvdmVcbiAgICpcbiAgICogICAgIGxldCBpbWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkb20tbW9kdWxlJykuaW1wb3J0KCdmb28nLCAnaW1nJyk7XG4gICAqXG4gICAqIEBjdXN0b21FbGVtZW50XG4gICAqIEBleHRlbmRzIEhUTUxFbGVtZW50XG4gICAqIEBtZW1iZXJvZiBQb2x5bWVyXG4gICAqIEBzdW1tYXJ5IEN1c3RvbSBlbGVtZW50IHRoYXQgcHJvdmlkZXMgYSByZWdpc3RyeSBvZiByZWxvY2F0YWJsZSBET00gY29udGVudFxuICAgKiAgIGJ5IGBpZGAgdGhhdCBpcyBhZ25vc3RpYyB0byBidW5kbGluZy5cbiAgICogQHVucmVzdHJpY3RlZFxuICAgKi9cbiAgY2xhc3MgRG9tTW9kdWxlIGV4dGVuZHMgSFRNTEVsZW1lbnQge1xuXG4gICAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7IHJldHVybiBbJ2lkJ10gfVxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSBlbGVtZW50IHNwZWNpZmllZCBieSB0aGUgY3NzIGBzZWxlY3RvcmAgaW4gdGhlIG1vZHVsZVxuICAgICAqIHJlZ2lzdGVyZWQgYnkgYGlkYC4gRm9yIGV4YW1wbGUsIHRoaXMuaW1wb3J0KCdmb28nLCAnaW1nJyk7XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkIFRoZSBpZCBvZiB0aGUgZG9tLW1vZHVsZSBpbiB3aGljaCB0byBzZWFyY2guXG4gICAgICogQHBhcmFtIHtzdHJpbmc9fSBzZWxlY3RvciBUaGUgY3NzIHNlbGVjdG9yIGJ5IHdoaWNoIHRvIGZpbmQgdGhlIGVsZW1lbnQuXG4gICAgICogQHJldHVybiB7RWxlbWVudH0gUmV0dXJucyB0aGUgZWxlbWVudCB3aGljaCBtYXRjaGVzIGBzZWxlY3RvcmAgaW4gdGhlXG4gICAgICogbW9kdWxlIHJlZ2lzdGVyZWQgYXQgdGhlIHNwZWNpZmllZCBgaWRgLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbXBvcnQoaWQsIHNlbGVjdG9yKSB7XG4gICAgICBpZiAoaWQpIHtcbiAgICAgICAgbGV0IG0gPSBmaW5kTW9kdWxlKGlkKTtcbiAgICAgICAgaWYgKG0gJiYgc2VsZWN0b3IpIHtcbiAgICAgICAgICByZXR1cm4gbS5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBvbGQsIHZhbHVlKSB7XG4gICAgICBpZiAob2xkICE9PSB2YWx1ZSkge1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGFic29sdXRlIFVSTCBvZiB0aGUgb3JpZ2luYWwgbG9jYXRpb24gb2YgdGhpcyBgZG9tLW1vZHVsZWAuXG4gICAgICpcbiAgICAgKiBUaGlzIHZhbHVlIHdpbGwgZGlmZmVyIGZyb20gdGhpcyBlbGVtZW50J3MgYG93bmVyRG9jdW1lbnRgIGluIHRoZVxuICAgICAqIGZvbGxvd2luZyB3YXlzOlxuICAgICAqIC0gVGFrZXMgaW50byBhY2NvdW50IGFueSBgYXNzZXRwYXRoYCBhdHRyaWJ1dGUgYWRkZWQgZHVyaW5nIGJ1bmRsaW5nXG4gICAgICogICB0byBpbmRpY2F0ZSB0aGUgb3JpZ2luYWwgbG9jYXRpb24gcmVsYXRpdmUgdG8gdGhlIGJ1bmRsZWQgbG9jYXRpb25cbiAgICAgKiAtIFVzZXMgdGhlIEhUTUxJbXBvcnRzIHBvbHlmaWxsJ3MgYGltcG9ydEZvckVsZW1lbnRgIEFQSSB0byBlbnN1cmVcbiAgICAgKiAgIHRoZSBwYXRoIGlzIHJlbGF0aXZlIHRvIHRoZSBpbXBvcnQgZG9jdW1lbnQncyBsb2NhdGlvbiBzaW5jZVxuICAgICAqICAgYG93bmVyRG9jdW1lbnRgIGlzIG5vdCBjdXJyZW50bHkgcG9seWZpbGxlZFxuICAgICAqL1xuICAgIGdldCBhc3NldHBhdGgoKSB7XG4gICAgICAvLyBEb24ndCBvdmVycmlkZSBleGlzdGluZyBhc3NldHBhdGguXG4gICAgICBpZiAoIXRoaXMuX19hc3NldHBhdGgpIHtcbiAgICAgICAgLy8gbm90ZTogYXNzZXRwYXRoIHNldCB2aWEgYW4gYXR0cmlidXRlIG11c3QgYmUgcmVsYXRpdmUgdG8gdGhpc1xuICAgICAgICAvLyBlbGVtZW50J3MgbG9jYXRpb247IGFjY29tb2RhdGUgcG9seWZpbGxlZCBIVE1MSW1wb3J0c1xuICAgICAgICBjb25zdCBvd25lciA9IHdpbmRvdy5IVE1MSW1wb3J0cyAmJiBIVE1MSW1wb3J0cy5pbXBvcnRGb3JFbGVtZW50ID9cbiAgICAgICAgICBIVE1MSW1wb3J0cy5pbXBvcnRGb3JFbGVtZW50KHRoaXMpIHx8IGRvY3VtZW50IDogdGhpcy5vd25lckRvY3VtZW50O1xuICAgICAgICBjb25zdCB1cmwgPSBQb2x5bWVyLlJlc29sdmVVcmwucmVzb2x2ZVVybChcbiAgICAgICAgICB0aGlzLmdldEF0dHJpYnV0ZSgnYXNzZXRwYXRoJykgfHwgJycsIG93bmVyLmJhc2VVUkkpO1xuICAgICAgICB0aGlzLl9fYXNzZXRwYXRoID0gUG9seW1lci5SZXNvbHZlVXJsLnBhdGhGcm9tVXJsKHVybCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fX2Fzc2V0cGF0aDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgdGhlIGRvbS1tb2R1bGUgYXQgYSBnaXZlbiBpZC4gVGhpcyBtZXRob2Qgc2hvdWxkIG9ubHkgYmUgY2FsbGVkXG4gICAgICogd2hlbiBhIGRvbS1tb2R1bGUgaXMgaW1wZXJhdGl2ZWx5IGNyZWF0ZWQuIEZvclxuICAgICAqIGV4YW1wbGUsIGBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkb20tbW9kdWxlJykucmVnaXN0ZXIoJ2ZvbycpYC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZz19IGlkIFRoZSBpZCBhdCB3aGljaCB0byByZWdpc3RlciB0aGUgZG9tLW1vZHVsZS5cbiAgICAgKi9cbiAgICByZWdpc3RlcihpZCkge1xuICAgICAgaWQgPSBpZCB8fCB0aGlzLmlkO1xuICAgICAgaWYgKGlkKSB7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgLy8gc3RvcmUgaWQgc2VwYXJhdGUgZnJvbSBsb3dlcmNhc2VkIGlkIHNvIHRoYXRcbiAgICAgICAgLy8gaW4gYWxsIGNhc2VzIG1peGVkQ2FzZSBpZCB3aWxsIHN0b3JlZCBkaXN0aW5jdGx5XG4gICAgICAgIC8vIGFuZCBsb3dlcmNhc2UgdmVyc2lvbiBpcyBhIGZhbGxiYWNrXG4gICAgICAgIG1vZHVsZXNbaWRdID0gdGhpcztcbiAgICAgICAgbGNNb2R1bGVzW2lkLnRvTG93ZXJDYXNlKCldID0gdGhpcztcbiAgICAgICAgc3R5bGVPdXRzaWRlVGVtcGxhdGVDaGVjayh0aGlzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBEb21Nb2R1bGUucHJvdG90eXBlWydtb2R1bGVzJ10gPSBtb2R1bGVzO1xuXG4gIGN1c3RvbUVsZW1lbnRzLmRlZmluZSgnZG9tLW1vZHVsZScsIERvbU1vZHVsZSk7XG5cbiAgLy8gZXhwb3J0XG4gIFBvbHltZXIuRG9tTW9kdWxlID0gRG9tTW9kdWxlO1xuXG59KSgpO1xuPC9zY3JpcHQ+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL3BvbHltZXIvbGliL2VsZW1lbnRzL2RvbS1tb2R1bGUuaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cblxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cImJvb3QuaHRtbFwiPlxuXG48c2NyaXB0PlxuKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLyoqXG4gICAqIE1vZHVsZSB3aXRoIHV0aWxpdGllcyBmb3IgbWFuaXB1bGF0aW5nIHN0cnVjdHVyZWQgZGF0YSBwYXRoIHN0cmluZ3MuXG4gICAqXG4gICAqIEBuYW1lc3BhY2VcbiAgICogQG1lbWJlcm9mIFBvbHltZXJcbiAgICogQHN1bW1hcnkgTW9kdWxlIHdpdGggdXRpbGl0aWVzIGZvciBtYW5pcHVsYXRpbmcgc3RydWN0dXJlZCBkYXRhIHBhdGggc3RyaW5ncy5cbiAgICovXG4gIGNvbnN0IFBhdGggPSB7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHN0cmluZyBpcyBhIHN0cnVjdHVyZWQgZGF0YSBwYXRoIChoYXMgZG90cykuXG4gICAgICpcbiAgICAgKiBFeGFtcGxlOlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogUG9seW1lci5QYXRoLmlzUGF0aCgnZm9vLmJhci5iYXonKSAvLyB0cnVlXG4gICAgICogUG9seW1lci5QYXRoLmlzUGF0aCgnZm9vJykgICAgICAgICAvLyBmYWxzZVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIFBvbHltZXIuUGF0aFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFBhdGggc3RyaW5nXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgc3RyaW5nIGNvbnRhaW5lZCBvbmUgb3IgbW9yZSBkb3RzXG4gICAgICovXG4gICAgaXNQYXRoOiBmdW5jdGlvbihwYXRoKSB7XG4gICAgICByZXR1cm4gcGF0aC5pbmRleE9mKCcuJykgPj0gMDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcm9vdCBwcm9wZXJ0eSBuYW1lIGZvciB0aGUgZ2l2ZW4gcGF0aC5cbiAgICAgKlxuICAgICAqIEV4YW1wbGU6XG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiBQb2x5bWVyLlBhdGgucm9vdCgnZm9vLmJhci5iYXonKSAvLyAnZm9vJ1xuICAgICAqIFBvbHltZXIuUGF0aC5yb290KCdmb28nKSAgICAgICAgIC8vICdmb28nXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgUG9seW1lci5QYXRoXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggUGF0aCBzdHJpbmdcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFJvb3QgcHJvcGVydHkgbmFtZVxuICAgICAqL1xuICAgIHJvb3Q6IGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgIGxldCBkb3RJbmRleCA9IHBhdGguaW5kZXhPZignLicpO1xuICAgICAgaWYgKGRvdEluZGV4ID09PSAtMSkge1xuICAgICAgICByZXR1cm4gcGF0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXRoLnNsaWNlKDAsIGRvdEluZGV4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2l2ZW4gYGJhc2VgIGlzIGBmb28uYmFyYCwgYGZvb2AgaXMgYW4gYW5jZXN0b3IsIGBmb28uYmFyYCBpcyBub3RcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHBhdGggaXMgYW4gYW5jZXN0b3Igb2YgdGhlIGJhc2UgcGF0aC5cbiAgICAgKlxuICAgICAqIEV4YW1wbGU6XG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiBQb2x5bWVyLlBhdGguaXNBbmNlc3RvcignZm9vLmJhcicsICdmb28nKSAgICAgICAgIC8vIHRydWVcbiAgICAgKiBQb2x5bWVyLlBhdGguaXNBbmNlc3RvcignZm9vLmJhcicsICdmb28uYmFyJykgICAgIC8vIGZhbHNlXG4gICAgICogUG9seW1lci5QYXRoLmlzQW5jZXN0b3IoJ2Zvby5iYXInLCAnZm9vLmJhci5iYXonKSAvLyBmYWxzZVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIFBvbHltZXIuUGF0aFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlIFBhdGggc3RyaW5nIHRvIHRlc3QgYWdhaW5zdC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBQYXRoIHN0cmluZyB0byB0ZXN0LlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYHBhdGhgIGlzIGFuIGFuY2VzdG9yIG9mIGBiYXNlYC5cbiAgICAgKi9cbiAgICBpc0FuY2VzdG9yOiBmdW5jdGlvbihiYXNlLCBwYXRoKSB7XG4gICAgICAvLyAgICAgYmFzZS5zdGFydHNXaXRoKHBhdGggKyAnLicpO1xuICAgICAgcmV0dXJuIGJhc2UuaW5kZXhPZihwYXRoICsgJy4nKSA9PT0gMDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2l2ZW4gYGJhc2VgIGlzIGBmb28uYmFyYCwgYGZvby5iYXIuYmF6YCBpcyBhbiBkZXNjZW5kYW50XG4gICAgICpcbiAgICAgKiBFeGFtcGxlOlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogUG9seW1lci5QYXRoLmlzRGVzY2VuZGFudCgnZm9vLmJhcicsICdmb28uYmFyLmJheicpIC8vIHRydWVcbiAgICAgKiBQb2x5bWVyLlBhdGguaXNEZXNjZW5kYW50KCdmb28uYmFyJywgJ2Zvby5iYXInKSAgICAgLy8gZmFsc2VcbiAgICAgKiBQb2x5bWVyLlBhdGguaXNEZXNjZW5kYW50KCdmb28uYmFyJywgJ2ZvbycpICAgICAgICAgLy8gZmFsc2VcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBQb2x5bWVyLlBhdGhcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYmFzZSBQYXRoIHN0cmluZyB0byB0ZXN0IGFnYWluc3QuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggUGF0aCBzdHJpbmcgdG8gdGVzdC5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGBwYXRoYCBpcyBhIGRlc2NlbmRhbnQgb2YgYGJhc2VgLlxuICAgICAqL1xuICAgIGlzRGVzY2VuZGFudDogZnVuY3Rpb24oYmFzZSwgcGF0aCkge1xuICAgICAgLy8gICAgIHBhdGguc3RhcnRzV2l0aChiYXNlICsgJy4nKTtcbiAgICAgIHJldHVybiBwYXRoLmluZGV4T2YoYmFzZSArICcuJykgPT09IDA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlcGxhY2VzIGEgcHJldmlvdXMgYmFzZSBwYXRoIHdpdGggYSBuZXcgYmFzZSBwYXRoLCBwcmVzZXJ2aW5nIHRoZVxuICAgICAqIHJlbWFpbmRlciBvZiB0aGUgcGF0aC5cbiAgICAgKlxuICAgICAqIFVzZXIgbXVzdCBlbnN1cmUgYHBhdGhgIGhhcyBhIHByZWZpeCBvZiBgYmFzZWAuXG4gICAgICpcbiAgICAgKiBFeGFtcGxlOlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogUG9seW1lci5QYXRoLnRyYW5zbGF0ZSgnZm9vLmJhcicsICd6b3QnICdmb28uYmFyLmJheicpIC8vICd6b3QuYmF6J1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIFBvbHltZXIuUGF0aFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlIEN1cnJlbnQgYmFzZSBzdHJpbmcgdG8gcmVtb3ZlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5ld0Jhc2UgTmV3IGJhc2Ugc3RyaW5nIHRvIHJlcGxhY2Ugd2l0aFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFBhdGggdG8gdHJhbnNsYXRlXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBUcmFuc2xhdGVkIHN0cmluZ1xuICAgICAqL1xuICAgIHRyYW5zbGF0ZTogZnVuY3Rpb24oYmFzZSwgbmV3QmFzZSwgcGF0aCkge1xuICAgICAgcmV0dXJuIG5ld0Jhc2UgKyBwYXRoLnNsaWNlKGJhc2UubGVuZ3RoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGJhc2UgUGF0aCBzdHJpbmcgdG8gdGVzdCBhZ2FpbnN0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggUGF0aCBzdHJpbmcgdG8gdGVzdFxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYHBhdGhgIGlzIGVxdWFsIHRvIGBiYXNlYFxuICAgICAqIEB0aGlzIHtQYXRofVxuICAgICAqL1xuICAgIG1hdGNoZXM6IGZ1bmN0aW9uKGJhc2UsIHBhdGgpIHtcbiAgICAgIHJldHVybiAoYmFzZSA9PT0gcGF0aCkgfHxcbiAgICAgICAgICAgICB0aGlzLmlzQW5jZXN0b3IoYmFzZSwgcGF0aCkgfHxcbiAgICAgICAgICAgICB0aGlzLmlzRGVzY2VuZGFudChiYXNlLCBwYXRoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYXJyYXktYmFzZWQgcGF0aHMgdG8gZmxhdHRlbmVkIHBhdGguICBTdHJpbmctYmFzZWQgcGF0aHNcbiAgICAgKiBhcmUgcmV0dXJuZWQgYXMtaXMuXG4gICAgICpcbiAgICAgKiBFeGFtcGxlOlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogUG9seW1lci5QYXRoLm5vcm1hbGl6ZShbJ2Zvby5iYXInLCAwLCAnYmF6J10pICAvLyAnZm9vLmJhci4wLmJheidcbiAgICAgKiBQb2x5bWVyLlBhdGgubm9ybWFsaXplKCdmb28uYmFyLjAuYmF6JykgICAgICAgIC8vICdmb28uYmFyLjAuYmF6J1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIFBvbHltZXIuUGF0aFxuICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgIUFycmF5PHN0cmluZ3xudW1iZXI+fSBwYXRoIElucHV0IHBhdGhcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IEZsYXR0ZW5lZCBwYXRoXG4gICAgICovXG4gICAgbm9ybWFsaXplOiBmdW5jdGlvbihwYXRoKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXRoKSkge1xuICAgICAgICBsZXQgcGFydHMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBsZXQgYXJncyA9IHBhdGhbaV0udG9TdHJpbmcoKS5zcGxpdCgnLicpO1xuICAgICAgICAgIGZvciAobGV0IGo9MDsgajxhcmdzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKGFyZ3Nbal0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFydHMuam9pbignLicpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNwbGl0cyBhIHBhdGggaW50byBhbiBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy4gQWNjZXB0cyBlaXRoZXIgYXJyYXlzXG4gICAgICogb2YgcGF0aCBwYXJ0cyBvciBzdHJpbmdzLlxuICAgICAqXG4gICAgICogRXhhbXBsZTpcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIFBvbHltZXIuUGF0aC5zcGxpdChbJ2Zvby5iYXInLCAwLCAnYmF6J10pICAvLyBbJ2ZvbycsICdiYXInLCAnMCcsICdiYXonXVxuICAgICAqIFBvbHltZXIuUGF0aC5zcGxpdCgnZm9vLmJhci4wLmJheicpICAgICAgICAvLyBbJ2ZvbycsICdiYXInLCAnMCcsICdiYXonXVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIFBvbHltZXIuUGF0aFxuICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgIUFycmF5PHN0cmluZ3xudW1iZXI+fSBwYXRoIElucHV0IHBhdGhcbiAgICAgKiBAcmV0dXJuIHshQXJyYXk8c3RyaW5nPn0gQXJyYXkgb2YgcGF0aCBwYXJ0c1xuICAgICAqIEB0aGlzIHtQYXRofVxuICAgICAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlc31cbiAgICAgKi9cbiAgICBzcGxpdDogZnVuY3Rpb24ocGF0aCkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGF0aCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9ybWFsaXplKHBhdGgpLnNwbGl0KCcuJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGF0aC50b1N0cmluZygpLnNwbGl0KCcuJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlYWRzIGEgdmFsdWUgZnJvbSBhIHBhdGguICBJZiBhbnkgc3ViLXByb3BlcnR5IGluIHRoZSBwYXRoIGlzIGB1bmRlZmluZWRgLFxuICAgICAqIHRoaXMgbWV0aG9kIHJldHVybnMgYHVuZGVmaW5lZGAgKHdpbGwgbmV2ZXIgdGhyb3cuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgUG9seW1lci5QYXRoXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJvb3QgT2JqZWN0IGZyb20gd2hpY2ggdG8gZGVyZWZlcmVuY2UgcGF0aCBmcm9tXG4gICAgICogQHBhcmFtIHtzdHJpbmcgfCAhQXJyYXk8c3RyaW5nfG51bWJlcj59IHBhdGggUGF0aCB0byByZWFkXG4gICAgICogQHBhcmFtIHtPYmplY3Q9fSBpbmZvIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCB0byBgaW5mb2AsIHRoZSBub3JtYWxpemVkXG4gICAgICogIChmbGF0dGVuZWQpIHBhdGggd2lsbCBiZSBzZXQgdG8gYGluZm8ucGF0aGAuXG4gICAgICogQHJldHVybiB7Kn0gVmFsdWUgYXQgcGF0aCwgb3IgYHVuZGVmaW5lZGAgaWYgdGhlIHBhdGggY291bGQgbm90IGJlXG4gICAgICogIGZ1bGx5IGRlcmVmZXJlbmNlZC5cbiAgICAgKiBAdGhpcyB7UGF0aH1cbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uKHJvb3QsIHBhdGgsIGluZm8pIHtcbiAgICAgIGxldCBwcm9wID0gcm9vdDtcbiAgICAgIGxldCBwYXJ0cyA9IHRoaXMuc3BsaXQocGF0aCk7XG4gICAgICAvLyBMb29wIG92ZXIgcGF0aCBwYXJ0c1swLi5uLTFdIGFuZCBkZXJlZmVyZW5jZVxuICAgICAgZm9yIChsZXQgaT0wOyBpPHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICghcHJvcCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcGFydCA9IHBhcnRzW2ldO1xuICAgICAgICBwcm9wID0gcHJvcFtwYXJ0XTtcbiAgICAgIH1cbiAgICAgIGlmIChpbmZvKSB7XG4gICAgICAgIGluZm8ucGF0aCA9IHBhcnRzLmpvaW4oJy4nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwcm9wO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgdmFsdWUgdG8gYSBwYXRoLiAgSWYgYW55IHN1Yi1wcm9wZXJ0eSBpbiB0aGUgcGF0aCBpcyBgdW5kZWZpbmVkYCxcbiAgICAgKiB0aGlzIG1ldGhvZCB3aWxsIG5vLW9wLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIFBvbHltZXIuUGF0aFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByb290IE9iamVjdCBmcm9tIHdoaWNoIHRvIGRlcmVmZXJlbmNlIHBhdGggZnJvbVxuICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgIUFycmF5PHN0cmluZ3xudW1iZXI+fSBwYXRoIFBhdGggdG8gc2V0XG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byBzZXQgdG8gcGF0aFxuICAgICAqIEByZXR1cm4ge3N0cmluZyB8IHVuZGVmaW5lZH0gVGhlIG5vcm1hbGl6ZWQgdmVyc2lvbiBvZiB0aGUgaW5wdXQgcGF0aFxuICAgICAqIEB0aGlzIHtQYXRofVxuICAgICAqL1xuICAgIHNldDogZnVuY3Rpb24ocm9vdCwgcGF0aCwgdmFsdWUpIHtcbiAgICAgIGxldCBwcm9wID0gcm9vdDtcbiAgICAgIGxldCBwYXJ0cyA9IHRoaXMuc3BsaXQocGF0aCk7XG4gICAgICBsZXQgbGFzdCA9IHBhcnRzW3BhcnRzLmxlbmd0aC0xXTtcbiAgICAgIGlmIChwYXJ0cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIC8vIExvb3Agb3ZlciBwYXRoIHBhcnRzWzAuLm4tMl0gYW5kIGRlcmVmZXJlbmNlXG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxwYXJ0cy5sZW5ndGgtMTsgaSsrKSB7XG4gICAgICAgICAgbGV0IHBhcnQgPSBwYXJ0c1tpXTtcbiAgICAgICAgICBwcm9wID0gcHJvcFtwYXJ0XTtcbiAgICAgICAgICBpZiAoIXByb3ApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2V0IHZhbHVlIHRvIG9iamVjdCBhdCBlbmQgb2YgcGF0aFxuICAgICAgICBwcm9wW2xhc3RdID0gdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBTaW1wbGUgcHJvcGVydHkgc2V0XG4gICAgICAgIHByb3BbcGF0aF0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJ0cy5qb2luKCcuJyk7XG4gICAgfVxuXG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gc3RyaW5nIGlzIGEgc3RydWN0dXJlZCBkYXRhIHBhdGggKGhhcyBkb3RzKS5cbiAgICpcbiAgICogVGhpcyBmdW5jdGlvbiBpcyBkZXByZWNhdGVkLiAgVXNlIGBQb2x5bWVyLlBhdGguaXNQYXRoYCBpbnN0ZWFkLlxuICAgKlxuICAgKiBFeGFtcGxlOlxuICAgKlxuICAgKiBgYGBcbiAgICogUG9seW1lci5QYXRoLmlzRGVlcCgnZm9vLmJhci5iYXonKSAvLyB0cnVlXG4gICAqIFBvbHltZXIuUGF0aC5pc0RlZXAoJ2ZvbycpICAgICAgICAgLy8gZmFsc2VcbiAgICogYGBgXG4gICAqXG4gICAqIEBkZXByZWNhdGVkXG4gICAqIEBtZW1iZXJvZiBQb2x5bWVyLlBhdGhcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggUGF0aCBzdHJpbmdcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgc3RyaW5nIGNvbnRhaW5lZCBvbmUgb3IgbW9yZSBkb3RzXG4gICAqL1xuICBQYXRoLmlzRGVlcCA9IFBhdGguaXNQYXRoO1xuXG4gIFBvbHltZXIuUGF0aCA9IFBhdGg7XG5cbn0pKCk7XG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvdXRpbHMvcGF0aC5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuXG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vdXRpbHMvYm9vdC5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vdXRpbHMvbWl4aW4uaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3V0aWxzL2Nhc2UtbWFwLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi91dGlscy9hc3luYy5odG1sXCI+XG5cbjxzY3JpcHQ+XG4oZnVuY3Rpb24oKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIGxldCBjYXNlTWFwID0gUG9seW1lci5DYXNlTWFwO1xuXG4gIGxldCBtaWNyb3Rhc2sgPSBQb2x5bWVyLkFzeW5jLm1pY3JvVGFzaztcblxuICAvLyBTYXZlIG1hcCBvZiBuYXRpdmUgcHJvcGVydGllczsgdGhpcyBmb3JtcyBhIGJsYWNrbGlzdCBvciBwcm9wZXJ0aWVzXG4gIC8vIHRoYXQgd29uJ3QgaGF2ZSB0aGVpciB2YWx1ZXMgXCJzYXZlZFwiIGJ5IGBzYXZlQWNjZXNzb3JWYWx1ZWAsIHNpbmNlXG4gIC8vIHJlYWRpbmcgZnJvbSBhbiBIVE1MRWxlbWVudCBhY2Nlc3NvciBmcm9tIHRoZSBjb250ZXh0IG9mIGEgcHJvdG90eXBlIHRocm93c1xuICBjb25zdCBuYXRpdmVQcm9wZXJ0aWVzID0ge307XG4gIGxldCBwcm90byA9IEhUTUxFbGVtZW50LnByb3RvdHlwZTtcbiAgd2hpbGUgKHByb3RvKSB7XG4gICAgbGV0IHByb3BzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocHJvdG8pO1xuICAgIGZvciAobGV0IGk9MDsgaTxwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgbmF0aXZlUHJvcGVydGllc1twcm9wc1tpXV0gPSB0cnVlO1xuICAgIH1cbiAgICBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihwcm90byk7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCB0byBzYXZlIHRoZSB2YWx1ZSBvZiBhIHByb3BlcnR5IHRoYXQgd2lsbCBiZSBvdmVycmlkZGVuIHdpdGhcbiAgICogYW4gYWNjZXNzb3IuIElmIHRoZSBgbW9kZWxgIGlzIGEgcHJvdG90eXBlLCB0aGUgdmFsdWVzIHdpbGwgYmUgc2F2ZWRcbiAgICogaW4gYF9fZGF0YVByb3RvYCwgYW5kIGl0J3MgdXAgdG8gdGhlIHVzZXIgKG9yIGRvd25zdHJlYW0gbWl4aW4pIHRvXG4gICAqIGRlY2lkZSBob3cvd2hlbiB0byBzZXQgdGhlc2UgdmFsdWVzIGJhY2sgaW50byB0aGUgYWNjZXNzb3JzLlxuICAgKiBJZiBgbW9kZWxgIGlzIGFscmVhZHkgYW4gaW5zdGFuY2UgKGl0IGhhcyBhIGBfX2RhdGFgIHByb3BlcnR5KSwgdGhlblxuICAgKiB0aGUgdmFsdWUgd2lsbCBiZSBzZXQgYXMgYSBwZW5kaW5nIHByb3BlcnR5LCBtZWFuaW5nIHRoZSB1c2VyIHNob3VsZFxuICAgKiBjYWxsIGBfaW52YWxpZGF0ZVByb3BlcnRpZXNgIG9yIGBfZmx1c2hQcm9wZXJ0aWVzYCB0byB0YWtlIGVmZmVjdFxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gbW9kZWwgUHJvdG90eXBlIG9yIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBOYW1lIG9mIHByb3BlcnR5XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBzYXZlQWNjZXNzb3JWYWx1ZShtb2RlbCwgcHJvcGVydHkpIHtcbiAgICAvLyBEb24ndCByZWFkL3N0b3JlIHZhbHVlIGZvciBhbnkgbmF0aXZlIHByb3BlcnRpZXMgc2luY2UgdGhleSBjb3VsZCB0aHJvd1xuICAgIGlmICghbmF0aXZlUHJvcGVydGllc1twcm9wZXJ0eV0pIHtcbiAgICAgIGxldCB2YWx1ZSA9IG1vZGVsW3Byb3BlcnR5XTtcbiAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChtb2RlbC5fX2RhdGEpIHtcbiAgICAgICAgICAvLyBBZGRpbmcgYWNjZXNzb3IgdG8gaW5zdGFuY2U7IHVwZGF0ZSB0aGUgcHJvcGVydHlcbiAgICAgICAgICAvLyBJdCBpcyB0aGUgdXNlcidzIHJlc3BvbnNpYmlsaXR5IHRvIGNhbGwgX2ZsdXNoUHJvcGVydGllc1xuICAgICAgICAgIG1vZGVsLl9zZXRQZW5kaW5nUHJvcGVydHkocHJvcGVydHksIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBBZGRpbmcgYWNjZXNzb3IgdG8gcHJvdG87IHNhdmUgcHJvdG8ncyB2YWx1ZSBmb3IgaW5zdGFuY2UtdGltZSB1c2VcbiAgICAgICAgICBpZiAoIW1vZGVsLl9fZGF0YVByb3RvKSB7XG4gICAgICAgICAgICBtb2RlbC5fX2RhdGFQcm90byA9IHt9O1xuICAgICAgICAgIH0gZWxzZSBpZiAoIW1vZGVsLmhhc093blByb3BlcnR5KEpTQ29tcGlsZXJfcmVuYW1lUHJvcGVydHkoJ19fZGF0YVByb3RvJywgbW9kZWwpKSkge1xuICAgICAgICAgICAgbW9kZWwuX19kYXRhUHJvdG8gPSBPYmplY3QuY3JlYXRlKG1vZGVsLl9fZGF0YVByb3RvKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbW9kZWwuX19kYXRhUHJvdG9bcHJvcGVydHldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRWxlbWVudCBjbGFzcyBtaXhpbiB0aGF0IHByb3ZpZGVzIGJhc2ljIG1ldGEtcHJvZ3JhbW1pbmcgZm9yIGNyZWF0aW5nIG9uZVxuICAgKiBvciBtb3JlIHByb3BlcnR5IGFjY2Vzc29ycyAoZ2V0dGVyL3NldHRlciBwYWlyKSB0aGF0IGVucXVldWUgYW4gYXN5bmNcbiAgICogKGJhdGNoZWQpIGBfcHJvcGVydGllc0NoYW5nZWRgIGNhbGxiYWNrLlxuICAgKlxuICAgKiBGb3IgYmFzaWMgdXNhZ2Ugb2YgdGhpcyBtaXhpbiwgc2ltcGx5IGRlY2xhcmUgYXR0cmlidXRlcyB0byBvYnNlcnZlIHZpYVxuICAgKiB0aGUgc3RhbmRhcmQgYHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKClgLCBpbXBsZW1lbnQgYF9wcm9wZXJ0aWVzQ2hhbmdlZGBcbiAgICogb24gdGhlIGNsYXNzLCBhbmQgdGhlbiBjYWxsIGBNeUNsYXNzLmNyZWF0ZVByb3BlcnRpZXNGb3JBdHRyaWJ1dGVzKClgIG9uY2VcbiAgICogb24gdGhlIGNsYXNzIHRvIGdlbmVyYXRlIHByb3BlcnR5IGFjY2Vzc29ycyBmb3IgZWFjaCBvYnNlcnZlZCBhdHRyaWJ1dGVcbiAgICogcHJpb3IgdG8gaW5zdGFuY2luZy4gIExhc3QsIGNhbGwgYHRoaXMuX2ZsdXNoUHJvcGVydGllcygpYCBvbmNlIHRvIGVuYWJsZVxuICAgKiB0aGUgYWNjZXNzb3JzLlxuICAgKlxuICAgKiBBbnkgYG9ic2VydmVkQXR0cmlidXRlc2Agd2lsbCBhdXRvbWF0aWNhbGx5IGJlXG4gICAqIGRlc2VyaWFsaXplZCB2aWEgYGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFja2AgYW5kIHNldCB0byB0aGUgYXNzb2NpYXRlZFxuICAgKiBwcm9wZXJ0eSB1c2luZyBgZGFzaC1jYXNlYC10by1gY2FtZWxDYXNlYCBjb252ZW50aW9uLlxuICAgKlxuICAgKiBAbWl4aW5GdW5jdGlvblxuICAgKiBAcG9seW1lclxuICAgKiBAbWVtYmVyb2YgUG9seW1lclxuICAgKiBAc3VtbWFyeSBFbGVtZW50IGNsYXNzIG1peGluIGZvciByZWFjdGluZyB0byBwcm9wZXJ0eSBjaGFuZ2VzIGZyb21cbiAgICogICBnZW5lcmF0ZWQgcHJvcGVydHkgYWNjZXNzb3JzLlxuICAgKi9cbiAgUG9seW1lci5Qcm9wZXJ0eUFjY2Vzc29ycyA9IFBvbHltZXIuZGVkdXBpbmdNaXhpbihzdXBlckNsYXNzID0+IHtcblxuICAgIC8qKlxuICAgICAqIEBwb2x5bWVyXG4gICAgICogQG1peGluQ2xhc3NcbiAgICAgKiBAaW1wbGVtZW50cyB7UG9seW1lcl9Qcm9wZXJ0eUFjY2Vzc29yc31cbiAgICAgKiBAZXh0ZW5kcyBIVE1MRWxlbWVudFxuICAgICAqIEB1bnJlc3RyaWN0ZWRcbiAgICAgKi9cbiAgICBjbGFzcyBQcm9wZXJ0eUFjY2Vzc29ycyBleHRlbmRzIHN1cGVyQ2xhc3Mge1xuXG4gICAgICAvKipcbiAgICAgICAqIEdlbmVyYXRlcyBwcm9wZXJ0eSBhY2Nlc3NvcnMgZm9yIGFsbCBhdHRyaWJ1dGVzIGluIHRoZSBzdGFuZGFyZFxuICAgICAgICogc3RhdGljIGBvYnNlcnZlZEF0dHJpYnV0ZXNgIGFycmF5LlxuICAgICAgICpcbiAgICAgICAqIEF0dHJpYnV0ZSBuYW1lcyBhcmUgbWFwcGVkIHRvIHByb3BlcnR5IG5hbWVzIHVzaW5nIHRoZSBgZGFzaC1jYXNlYCB0b1xuICAgICAgICogYGNhbWVsQ2FzZWAgY29udmVudGlvblxuICAgICAgICpcbiAgICAgICAqL1xuICAgICAgc3RhdGljIGNyZWF0ZVByb3BlcnRpZXNGb3JBdHRyaWJ1dGVzKCkge1xuICAgICAgICBsZXQgYSQgPSB0aGlzLm9ic2VydmVkQXR0cmlidXRlcztcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpIDwgYSQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB0aGlzLnByb3RvdHlwZS5fY3JlYXRlUHJvcGVydHlBY2Nlc3NvcihjYXNlTWFwLmRhc2hUb0NhbWVsQ2FzZShhJFtpXSkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICAvKiogQHR5cGUge2Jvb2xlYW59ICovXG4gICAgICAgIHRoaXMuX19zZXJpYWxpemluZztcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMuX19kYXRhQ291bnRlcjtcbiAgICAgICAgLyoqIEB0eXBlIHtib29sZWFufSAqL1xuICAgICAgICB0aGlzLl9fZGF0YUVuYWJsZWQ7XG4gICAgICAgIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cbiAgICAgICAgdGhpcy5fX2RhdGFSZWFkeTtcbiAgICAgICAgLyoqIEB0eXBlIHtib29sZWFufSAqL1xuICAgICAgICB0aGlzLl9fZGF0YUludmFsaWQ7XG4gICAgICAgIC8qKiBAdHlwZSB7IU9iamVjdH0gKi9cbiAgICAgICAgdGhpcy5fX2RhdGE7XG4gICAgICAgIC8qKiBAdHlwZSB7T2JqZWN0fSAqL1xuICAgICAgICB0aGlzLl9fZGF0YVBlbmRpbmc7XG4gICAgICAgIC8qKiBAdHlwZSB7T2JqZWN0fSAqL1xuICAgICAgICB0aGlzLl9fZGF0YU9sZDtcbiAgICAgICAgLyoqIEB0eXBlIHtPYmplY3R9ICovXG4gICAgICAgIHRoaXMuX19kYXRhUHJvdG87XG4gICAgICAgIC8qKiBAdHlwZSB7T2JqZWN0fSAqL1xuICAgICAgICB0aGlzLl9fZGF0YUhhc0FjY2Vzc29yO1xuICAgICAgICAvKiogQHR5cGUge09iamVjdH0gKi9cbiAgICAgICAgdGhpcy5fX2RhdGFJbnN0YW5jZVByb3BzO1xuICAgICAgICB0aGlzLl9pbml0aWFsaXplUHJvcGVydGllcygpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEltcGxlbWVudHMgbmF0aXZlIEN1c3RvbSBFbGVtZW50cyBgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrYCB0b1xuICAgICAgICogc2V0IGFuIGF0dHJpYnV0ZSB2YWx1ZSB0byBhIHByb3BlcnR5IHZpYSBgX2F0dHJpYnV0ZVRvUHJvcGVydHlgLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE5hbWUgb2YgYXR0cmlidXRlIHRoYXQgY2hhbmdlZFxuICAgICAgICogQHBhcmFtIHs/c3RyaW5nfSBvbGQgT2xkIGF0dHJpYnV0ZSB2YWx1ZVxuICAgICAgICogQHBhcmFtIHs/c3RyaW5nfSB2YWx1ZSBOZXcgYXR0cmlidXRlIHZhbHVlXG4gICAgICAgKi9cbiAgICAgIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBvbGQsIHZhbHVlKSB7XG4gICAgICAgIGlmIChvbGQgIT09IHZhbHVlKSB7XG4gICAgICAgICAgdGhpcy5fYXR0cmlidXRlVG9Qcm9wZXJ0eShuYW1lLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBJbml0aWFsaXplcyB0aGUgbG9jYWwgc3RvcmFnZSBmb3IgcHJvcGVydHkgYWNjZXNzb3JzLlxuICAgICAgICpcbiAgICAgICAqIFByb3ZpZGVkIGFzIGFuIG92ZXJyaWRlIHBvaW50IGZvciBwZXJmb3JtaW5nIGFueSBzZXR1cCB3b3JrIHByaW9yXG4gICAgICAgKiB0byBpbml0aWFsaXppbmcgdGhlIHByb3BlcnR5IGFjY2Vzc29yIHN5c3RlbS5cbiAgICAgICAqXG4gICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgKi9cbiAgICAgIF9pbml0aWFsaXplUHJvcGVydGllcygpIHtcbiAgICAgICAgdGhpcy5fX3NlcmlhbGl6aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX19kYXRhQ291bnRlciA9IDA7XG4gICAgICAgIHRoaXMuX19kYXRhRW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9fZGF0YVJlYWR5ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX19kYXRhSW52YWxpZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9fZGF0YSA9IHt9O1xuICAgICAgICB0aGlzLl9fZGF0YVBlbmRpbmcgPSBudWxsO1xuICAgICAgICB0aGlzLl9fZGF0YU9sZCA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLl9fZGF0YVByb3RvKSB7XG4gICAgICAgICAgdGhpcy5faW5pdGlhbGl6ZVByb3RvUHJvcGVydGllcyh0aGlzLl9fZGF0YVByb3RvKTtcbiAgICAgICAgICB0aGlzLl9fZGF0YVByb3RvID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBDYXB0dXJlIGluc3RhbmNlIHByb3BlcnRpZXM7IHRoZXNlIHdpbGwgYmUgc2V0IGludG8gYWNjZXNzb3JzXG4gICAgICAgIC8vIGR1cmluZyBmaXJzdCBmbHVzaC4gRG9uJ3Qgc2V0IHRoZW0gaGVyZSwgc2luY2Ugd2Ugd2FudFxuICAgICAgICAvLyB0aGVzZSB0byBvdmVyd3JpdGUgZGVmYXVsdHMvY29uc3RydWN0b3IgYXNzaWdubWVudHNcbiAgICAgICAgZm9yIChsZXQgcCBpbiB0aGlzLl9fZGF0YUhhc0FjY2Vzc29yKSB7XG4gICAgICAgICAgaWYgKHRoaXMuaGFzT3duUHJvcGVydHkocCkpIHtcbiAgICAgICAgICAgIHRoaXMuX19kYXRhSW5zdGFuY2VQcm9wcyA9IHRoaXMuX19kYXRhSW5zdGFuY2VQcm9wcyB8fCB7fTtcbiAgICAgICAgICAgIHRoaXMuX19kYXRhSW5zdGFuY2VQcm9wc1twXSA9IHRoaXNbcF07XG4gICAgICAgICAgICBkZWxldGUgdGhpc1twXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDYWxsZWQgYXQgaW5zdGFuY2UgdGltZSB3aXRoIGJhZyBvZiBwcm9wZXJ0aWVzIHRoYXQgd2VyZSBvdmVyd3JpdHRlblxuICAgICAgICogYnkgYWNjZXNzb3JzIG9uIHRoZSBwcm90b3R5cGUgd2hlbiBhY2Nlc3NvcnMgd2VyZSBjcmVhdGVkLlxuICAgICAgICpcbiAgICAgICAqIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIHNldHMgdGhlc2UgcHJvcGVydGllcyBiYWNrIGludG8gdGhlXG4gICAgICAgKiBzZXR0ZXIgYXQgaW5zdGFuY2UgdGltZS4gIFRoaXMgbWV0aG9kIGlzIHByb3ZpZGVkIGFzIGFuIG92ZXJyaWRlXG4gICAgICAgKiBwb2ludCBmb3IgY3VzdG9taXppbmcgb3IgcHJvdmlkaW5nIG1vcmUgZWZmaWNpZW50IGluaXRpYWxpemF0aW9uLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBCYWcgb2YgcHJvcGVydHkgdmFsdWVzIHRoYXQgd2VyZSBvdmVyd3JpdHRlblxuICAgICAgICogICB3aGVuIGNyZWF0aW5nIHByb3BlcnR5IGFjY2Vzc29ycy5cbiAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAqL1xuICAgICAgX2luaXRpYWxpemVQcm90b1Byb3BlcnRpZXMocHJvcHMpIHtcbiAgICAgICAgZm9yIChsZXQgcCBpbiBwcm9wcykge1xuICAgICAgICAgIHRoaXMuX3NldFByb3BlcnR5KHAsIHByb3BzW3BdKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENhbGxlZCBhdCByZWFkeSB0aW1lIHdpdGggYmFnIG9mIGluc3RhbmNlIHByb3BlcnRpZXMgdGhhdCBvdmVyd3JvdGVcbiAgICAgICAqIGFjY2Vzc29ycyB3aGVuIHRoZSBlbGVtZW50IHVwZ3JhZGVkLlxuICAgICAgICpcbiAgICAgICAqIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIHNldHMgdGhlc2UgcHJvcGVydGllcyBiYWNrIGludG8gdGhlXG4gICAgICAgKiBzZXR0ZXIgYXQgcmVhZHkgdGltZS4gIFRoaXMgbWV0aG9kIGlzIHByb3ZpZGVkIGFzIGFuIG92ZXJyaWRlXG4gICAgICAgKiBwb2ludCBmb3IgY3VzdG9taXppbmcgb3IgcHJvdmlkaW5nIG1vcmUgZWZmaWNpZW50IGluaXRpYWxpemF0aW9uLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBCYWcgb2YgcHJvcGVydHkgdmFsdWVzIHRoYXQgd2VyZSBvdmVyd3JpdHRlblxuICAgICAgICogICB3aGVuIGNyZWF0aW5nIHByb3BlcnR5IGFjY2Vzc29ycy5cbiAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAqL1xuICAgICAgX2luaXRpYWxpemVJbnN0YW5jZVByb3BlcnRpZXMocHJvcHMpIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBwcm9wcyk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogRW5zdXJlcyB0aGUgZWxlbWVudCBoYXMgdGhlIGdpdmVuIGF0dHJpYnV0ZS4gSWYgaXQgZG9lcyBub3QsXG4gICAgICAgKiBhc3NpZ25zIHRoZSBnaXZlbiB2YWx1ZSB0byB0aGUgYXR0cmlidXRlLlxuICAgICAgICpcbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlIE5hbWUgb2YgYXR0cmlidXRlIHRvIGVuc3VyZSBpcyBzZXQuXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgb2YgdGhlIGF0dHJpYnV0ZS5cbiAgICAgICAqL1xuICAgICAgX2Vuc3VyZUF0dHJpYnV0ZShhdHRyaWJ1dGUsIHZhbHVlKSB7XG4gICAgICAgIGlmICghdGhpcy5oYXNBdHRyaWJ1dGUoYXR0cmlidXRlKSkge1xuICAgICAgICAgIHRoaXMuX3ZhbHVlVG9Ob2RlQXR0cmlidXRlKHRoaXMsIHZhbHVlLCBhdHRyaWJ1dGUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogRGVzZXJpYWxpemVzIGFuIGF0dHJpYnV0ZSB0byBpdHMgYXNzb2NpYXRlZCBwcm9wZXJ0eS5cbiAgICAgICAqXG4gICAgICAgKiBUaGlzIG1ldGhvZCBjYWxscyB0aGUgYF9kZXNlcmlhbGl6ZVZhbHVlYCBtZXRob2QgdG8gY29udmVydCB0aGUgc3RyaW5nIHRvXG4gICAgICAgKiBhIHR5cGVkIHZhbHVlLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGUgTmFtZSBvZiBhdHRyaWJ1dGUgdG8gZGVzZXJpYWxpemUuXG4gICAgICAgKiBAcGFyYW0gez9zdHJpbmd9IHZhbHVlIG9mIHRoZSBhdHRyaWJ1dGUuXG4gICAgICAgKiBAcGFyYW0geyo9fSB0eXBlIHR5cGUgdG8gZGVzZXJpYWxpemUgdG8uXG4gICAgICAgKi9cbiAgICAgIF9hdHRyaWJ1dGVUb1Byb3BlcnR5KGF0dHJpYnV0ZSwgdmFsdWUsIHR5cGUpIHtcbiAgICAgICAgLy8gRG9uJ3QgZGVzZXJpYWxpemUgYmFjayB0byBwcm9wZXJ0eSBpZiBjdXJyZW50bHkgcmVmbGVjdGluZ1xuICAgICAgICBpZiAoIXRoaXMuX19zZXJpYWxpemluZykge1xuICAgICAgICAgIGxldCBwcm9wZXJ0eSA9IGNhc2VNYXAuZGFzaFRvQ2FtZWxDYXNlKGF0dHJpYnV0ZSk7XG4gICAgICAgICAgdGhpc1twcm9wZXJ0eV0gPSB0aGlzLl9kZXNlcmlhbGl6ZVZhbHVlKHZhbHVlLCB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFNlcmlhbGl6ZXMgYSBwcm9wZXJ0eSB0byBpdHMgYXNzb2NpYXRlZCBhdHRyaWJ1dGUuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IG5hbWUgdG8gcmVmbGVjdC5cbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nPX0gYXR0cmlidXRlIEF0dHJpYnV0ZSBuYW1lIHRvIHJlZmxlY3QuXG4gICAgICAgKiBAcGFyYW0geyo9fSB2YWx1ZSBQcm9wZXJ0eSB2YWx1ZSB0byByZWZlY3QuXG4gICAgICAgKi9cbiAgICAgIF9wcm9wZXJ0eVRvQXR0cmlidXRlKHByb3BlcnR5LCBhdHRyaWJ1dGUsIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX19zZXJpYWxpemluZyA9IHRydWU7XG4gICAgICAgIHZhbHVlID0gKGFyZ3VtZW50cy5sZW5ndGggPCAzKSA/IHRoaXNbcHJvcGVydHldIDogdmFsdWU7XG4gICAgICAgIHRoaXMuX3ZhbHVlVG9Ob2RlQXR0cmlidXRlKHRoaXMsIHZhbHVlLFxuICAgICAgICAgIGF0dHJpYnV0ZSB8fCBjYXNlTWFwLmNhbWVsVG9EYXNoQ2FzZShwcm9wZXJ0eSkpO1xuICAgICAgICB0aGlzLl9fc2VyaWFsaXppbmcgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBTZXRzIGEgdHlwZWQgdmFsdWUgdG8gYW4gSFRNTCBhdHRyaWJ1dGUgb24gYSBub2RlLlxuICAgICAgICpcbiAgICAgICAqIFRoaXMgbWV0aG9kIGNhbGxzIHRoZSBgX3NlcmlhbGl6ZVZhbHVlYCBtZXRob2QgdG8gY29udmVydCB0aGUgdHlwZWRcbiAgICAgICAqIHZhbHVlIHRvIGEgc3RyaW5nLiAgSWYgdGhlIGBfc2VyaWFsaXplVmFsdWVgIG1ldGhvZCByZXR1cm5zIGB1bmRlZmluZWRgLFxuICAgICAgICogdGhlIGF0dHJpYnV0ZSB3aWxsIGJlIHJlbW92ZWQgKHRoaXMgaXMgdGhlIGRlZmF1bHQgZm9yIGJvb2xlYW5cbiAgICAgICAqIHR5cGUgYGZhbHNlYCkuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtFbGVtZW50fSBub2RlIEVsZW1lbnQgdG8gc2V0IGF0dHJpYnV0ZSB0by5cbiAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgdG8gc2VyaWFsaXplLlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGF0dHJpYnV0ZSBBdHRyaWJ1dGUgbmFtZSB0byBzZXJpYWxpemUgdG8uXG4gICAgICAgKi9cbiAgICAgIF92YWx1ZVRvTm9kZUF0dHJpYnV0ZShub2RlLCB2YWx1ZSwgYXR0cmlidXRlKSB7XG4gICAgICAgIGxldCBzdHIgPSB0aGlzLl9zZXJpYWxpemVWYWx1ZSh2YWx1ZSk7XG4gICAgICAgIGlmIChzdHIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKGF0dHJpYnV0ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoYXR0cmlidXRlLCBzdHIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ29udmVydHMgYSB0eXBlZCBKYXZhU2NyaXB0IHZhbHVlIHRvIGEgc3RyaW5nLlxuICAgICAgICpcbiAgICAgICAqIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCBieSBQb2x5bWVyIHdoZW4gc2V0dGluZyBKUyBwcm9wZXJ0eSB2YWx1ZXMgdG9cbiAgICAgICAqIEhUTUwgYXR0cmlidXRlcy4gIFVzZXJzIG1heSBvdmVycmlkZSB0aGlzIG1ldGhvZCBvbiBQb2x5bWVyIGVsZW1lbnRcbiAgICAgICAqIHByb3RvdHlwZXMgdG8gcHJvdmlkZSBzZXJpYWxpemF0aW9uIGZvciBjdXN0b20gdHlwZXMuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBQcm9wZXJ0eSB2YWx1ZSB0byBzZXJpYWxpemUuXG4gICAgICAgKiBAcmV0dXJuIHtzdHJpbmcgfCB1bmRlZmluZWR9IFN0cmluZyBzZXJpYWxpemVkIGZyb20gdGhlIHByb3ZpZGVkIHByb3BlcnR5IHZhbHVlLlxuICAgICAgICovXG4gICAgICBfc2VyaWFsaXplVmFsdWUodmFsdWUpIHtcbiAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tZmFsbHRocm91Z2ggKi9cbiAgICAgICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSA/ICcnIDogdW5kZWZpbmVkO1xuXG4gICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCh4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlICE9IG51bGwgPyB2YWx1ZS50b1N0cmluZygpIDogdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ29udmVydHMgYSBzdHJpbmcgdG8gYSB0eXBlZCBKYXZhU2NyaXB0IHZhbHVlLlxuICAgICAgICpcbiAgICAgICAqIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCBieSBQb2x5bWVyIHdoZW4gcmVhZGluZyBIVE1MIGF0dHJpYnV0ZSB2YWx1ZXMgdG9cbiAgICAgICAqIEpTIHByb3BlcnRpZXMuICBVc2VycyBtYXkgb3ZlcnJpZGUgdGhpcyBtZXRob2Qgb24gUG9seW1lciBlbGVtZW50XG4gICAgICAgKiBwcm90b3R5cGVzIHRvIHByb3ZpZGUgZGVzZXJpYWxpemF0aW9uIGZvciBjdXN0b20gYHR5cGVgcy4gIE5vdGUsXG4gICAgICAgKiB0aGUgYHR5cGVgIGFyZ3VtZW50IGlzIHRoZSB2YWx1ZSBvZiB0aGUgYHR5cGVgIGZpZWxkIHByb3ZpZGVkIGluIHRoZVxuICAgICAgICogYHByb3BlcnRpZXNgIGNvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBhIGdpdmVuIHByb3BlcnR5LCBhbmQgaXNcbiAgICAgICAqIGJ5IGNvbnZlbnRpb24gdGhlIGNvbnN0cnVjdG9yIGZvciB0aGUgdHlwZSB0byBkZXNlcmlhbGl6ZS5cbiAgICAgICAqXG4gICAgICAgKiBOb3RlOiBUaGUgcmV0dXJuIHZhbHVlIG9mIGB1bmRlZmluZWRgIGlzIHVzZWQgYXMgYSBzZW50aW5lbCB2YWx1ZSB0b1xuICAgICAgICogaW5kaWNhdGUgdGhlIGF0dHJpYnV0ZSBzaG91bGQgYmUgcmVtb3ZlZC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0gez9zdHJpbmd9IHZhbHVlIEF0dHJpYnV0ZSB2YWx1ZSB0byBkZXNlcmlhbGl6ZS5cbiAgICAgICAqIEBwYXJhbSB7Kj19IHR5cGUgVHlwZSB0byBkZXNlcmlhbGl6ZSB0aGUgc3RyaW5nIHRvLlxuICAgICAgICogQHJldHVybiB7Kn0gVHlwZWQgdmFsdWUgZGVzZXJpYWxpemVkIGZyb20gdGhlIHByb3ZpZGVkIHN0cmluZy5cbiAgICAgICAqL1xuICAgICAgX2Rlc2VyaWFsaXplVmFsdWUodmFsdWUsIHR5cGUpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHsqfVxuICAgICAgICAgKi9cbiAgICAgICAgbGV0IG91dFZhbHVlO1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICBjYXNlIE51bWJlcjpcbiAgICAgICAgICAgIG91dFZhbHVlID0gTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBCb29sZWFuOlxuICAgICAgICAgICAgb3V0VmFsdWUgPSAodmFsdWUgIT09IG51bGwpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIE9iamVjdDpcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIG91dFZhbHVlID0gSlNPTi5wYXJzZSgvKiogQHR5cGUgc3RyaW5nICovKHZhbHVlKSk7XG4gICAgICAgICAgICB9IGNhdGNoKHgpIHtcbiAgICAgICAgICAgICAgLy8gYWxsb3cgbm9uLUpTT04gbGl0ZXJhbHMgbGlrZSBTdHJpbmdzIGFuZCBOdW1iZXJzXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgQXJyYXk6XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBvdXRWYWx1ZSA9IEpTT04ucGFyc2UoLyoqIEB0eXBlIHN0cmluZyAqLyh2YWx1ZSkpO1xuICAgICAgICAgICAgfSBjYXRjaCh4KSB7XG4gICAgICAgICAgICAgIG91dFZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBQb2x5bWVyOjpBdHRyaWJ1dGVzOiBjb3VsZG4ndCBkZWNvZGUgQXJyYXkgYXMgSlNPTjogJHt2YWx1ZX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBEYXRlOlxuICAgICAgICAgICAgb3V0VmFsdWUgPSBuZXcgRGF0ZSh2YWx1ZSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgU3RyaW5nOlxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBvdXRWYWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb3V0VmFsdWU7XG4gICAgICB9XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLWZhbGx0aHJvdWdoICovXG5cbiAgICAgIC8qKlxuICAgICAgICogQ3JlYXRlcyBhIHNldHRlci9nZXR0ZXIgcGFpciBmb3IgdGhlIG5hbWVkIHByb3BlcnR5IHdpdGggaXRzIG93blxuICAgICAgICogbG9jYWwgc3RvcmFnZS4gIFRoZSBnZXR0ZXIgcmV0dXJucyB0aGUgdmFsdWUgaW4gdGhlIGxvY2FsIHN0b3JhZ2UsXG4gICAgICAgKiBhbmQgdGhlIHNldHRlciBjYWxscyBgX3NldFByb3BlcnR5YCwgd2hpY2ggdXBkYXRlcyB0aGUgbG9jYWwgc3RvcmFnZVxuICAgICAgICogZm9yIHRoZSBwcm9wZXJ0eSBhbmQgZW5xdWV1ZXMgYSBgX3Byb3BlcnRpZXNDaGFuZ2VkYCBjYWxsYmFjay5cbiAgICAgICAqXG4gICAgICAgKiBUaGlzIG1ldGhvZCBtYXkgYmUgY2FsbGVkIG9uIGEgcHJvdG90eXBlIG9yIGFuIGluc3RhbmNlLiAgQ2FsbGluZ1xuICAgICAgICogdGhpcyBtZXRob2QgbWF5IG92ZXJ3cml0ZSBhIHByb3BlcnR5IHZhbHVlIHRoYXQgYWxyZWFkeSBleGlzdHMgb25cbiAgICAgICAqIHRoZSBwcm90b3R5cGUvaW5zdGFuY2UgYnkgY3JlYXRpbmcgdGhlIGFjY2Vzc29yLiAgV2hlbiBjYWxsaW5nIG9uXG4gICAgICAgKiBhIHByb3RvdHlwZSwgYW55IG92ZXJ3cml0dGVuIHZhbHVlcyBhcmUgc2F2ZWQgaW4gYF9fZGF0YVByb3RvYCxcbiAgICAgICAqIGFuZCBpdCBpcyB1cCB0byB0aGUgc3ViY2xhc3NlciB0byBkZWNpZGUgaG93L3doZW4gdG8gc2V0IHRob3NlXG4gICAgICAgKiBwcm9wZXJ0aWVzIGJhY2sgaW50byB0aGUgYWNjZXNzb3IuICBXaGVuIGNhbGxpbmcgb24gYW4gaW5zdGFuY2UsXG4gICAgICAgKiB0aGUgb3ZlcndyaXR0ZW4gdmFsdWUgaXMgc2V0IHZpYSBgX3NldFBlbmRpbmdQcm9wZXJ0eWAsIGFuZCB0aGVcbiAgICAgICAqIHVzZXIgc2hvdWxkIGNhbGwgYF9pbnZhbGlkYXRlUHJvcGVydGllc2Agb3IgYF9mbHVzaFByb3BlcnRpZXNgXG4gICAgICAgKiBmb3IgdGhlIHZhbHVlcyB0byB0YWtlIGVmZmVjdC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgTmFtZSBvZiB0aGUgcHJvcGVydHlcbiAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IHJlYWRPbmx5IFdoZW4gdHJ1ZSwgbm8gc2V0dGVyIGlzIGNyZWF0ZWQ7IHRoZVxuICAgICAgICogICBwcm90ZWN0ZWQgYF9zZXRQcm9wZXJ0eWAgZnVuY3Rpb24gbXVzdCBiZSB1c2VkIHRvIHNldCB0aGUgcHJvcGVydHlcbiAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAqL1xuICAgICAgX2NyZWF0ZVByb3BlcnR5QWNjZXNzb3IocHJvcGVydHksIHJlYWRPbmx5KSB7XG4gICAgICAgIGlmICghdGhpcy5oYXNPd25Qcm9wZXJ0eSgnX19kYXRhSGFzQWNjZXNzb3InKSkge1xuICAgICAgICAgIHRoaXMuX19kYXRhSGFzQWNjZXNzb3IgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLl9fZGF0YUhhc0FjY2Vzc29yKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX19kYXRhSGFzQWNjZXNzb3JbcHJvcGVydHldKSB7XG4gICAgICAgICAgdGhpcy5fX2RhdGFIYXNBY2Nlc3Nvcltwcm9wZXJ0eV0gPSB0cnVlO1xuICAgICAgICAgIHNhdmVBY2Nlc3NvclZhbHVlKHRoaXMsIHByb3BlcnR5KTtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgcHJvcGVydHksIHtcbiAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIHZhbGlkLWpzZG9jICovXG4gICAgICAgICAgICAvKiogQHRoaXMge1Byb3BlcnR5QWNjZXNzb3JzfSAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX19kYXRhW3Byb3BlcnR5XTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvKiogQHRoaXMge1Byb3BlcnR5QWNjZXNzb3JzfSAqL1xuICAgICAgICAgICAgc2V0OiByZWFkT25seSA/IGZ1bmN0aW9uKCkge30gOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICB0aGlzLl9zZXRQcm9wZXJ0eShwcm9wZXJ0eSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogZXNsaW50LWVuYWJsZSAqL1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgbGlicmFyeSBjcmVhdGVkIGFuIGFjY2Vzc29yIGZvciB0aGUgZ2l2ZW4gcHJvcGVydHkuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IG5hbWVcbiAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYW4gYWNjZXNzb3Igd2FzIGNyZWF0ZWRcbiAgICAgICAqL1xuICAgICAgX2hhc0FjY2Vzc29yKHByb3BlcnR5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fZGF0YUhhc0FjY2Vzc29yICYmIHRoaXMuX19kYXRhSGFzQWNjZXNzb3JbcHJvcGVydHldO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFVwZGF0ZXMgdGhlIGxvY2FsIHN0b3JhZ2UgZm9yIGEgcHJvcGVydHkgKHZpYSBgX3NldFBlbmRpbmdQcm9wZXJ0eWApXG4gICAgICAgKiBhbmQgZW5xdWV1ZXMgYSBgX3Byb2VwcnRpZXNDaGFuZ2VkYCBjYWxsYmFjay5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgTmFtZSBvZiB0aGUgcHJvcGVydHlcbiAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgdG8gc2V0XG4gICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgKi9cbiAgICAgIF9zZXRQcm9wZXJ0eShwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuX3NldFBlbmRpbmdQcm9wZXJ0eShwcm9wZXJ0eSwgdmFsdWUpKSB7XG4gICAgICAgICAgdGhpcy5faW52YWxpZGF0ZVByb3BlcnRpZXMoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFVwZGF0ZXMgdGhlIGxvY2FsIHN0b3JhZ2UgZm9yIGEgcHJvcGVydHksIHJlY29yZHMgdGhlIHByZXZpb3VzIHZhbHVlLFxuICAgICAgICogYW5kIGFkZHMgaXQgdG8gdGhlIHNldCBvZiBcInBlbmRpbmcgY2hhbmdlc1wiIHRoYXQgd2lsbCBiZSBwYXNzZWQgdG8gdGhlXG4gICAgICAgKiBgX3Byb3BlcnRpZXNDaGFuZ2VkYCBjYWxsYmFjay4gIFRoaXMgbWV0aG9kIGRvZXMgbm90IGVucXVldWUgdGhlXG4gICAgICAgKiBgX3Byb3BlcnRpZXNDaGFuZ2VkYCBjYWxsYmFjay5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgTmFtZSBvZiB0aGUgcHJvcGVydHlcbiAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgdG8gc2V0XG4gICAgICAgKiBAcmV0dXJuIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgdGhlIHByb3BlcnR5IGNoYW5nZWRcbiAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAqL1xuICAgICAgX3NldFBlbmRpbmdQcm9wZXJ0eShwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgICAgICAgbGV0IG9sZCA9IHRoaXMuX19kYXRhW3Byb3BlcnR5XTtcbiAgICAgICAgbGV0IGNoYW5nZWQgPSB0aGlzLl9zaG91bGRQcm9wZXJ0eUNoYW5nZShwcm9wZXJ0eSwgdmFsdWUsIG9sZClcbiAgICAgICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgICAgICBpZiAoIXRoaXMuX19kYXRhUGVuZGluZykge1xuICAgICAgICAgICAgdGhpcy5fX2RhdGFQZW5kaW5nID0ge307XG4gICAgICAgICAgICB0aGlzLl9fZGF0YU9sZCA9IHt9O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBFbnN1cmUgb2xkIGlzIGNhcHR1cmVkIGZyb20gdGhlIGxhc3QgdHVyblxuICAgICAgICAgIGlmICh0aGlzLl9fZGF0YU9sZCAmJiAhKHByb3BlcnR5IGluIHRoaXMuX19kYXRhT2xkKSkge1xuICAgICAgICAgICAgdGhpcy5fX2RhdGFPbGRbcHJvcGVydHldID0gb2xkO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9fZGF0YVtwcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICAgICAgICB0aGlzLl9fZGF0YVBlbmRpbmdbcHJvcGVydHldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNoYW5nZWQ7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBzcGVjaWZpZWQgcHJvcGVydHkgaGFzIGEgcGVuZGluZyBjaGFuZ2UuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3AgUHJvcGVydHkgbmFtZVxuICAgICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBwcm9wZXJ0eSBoYXMgYSBwZW5kaW5nIGNoYW5nZVxuICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICovXG4gICAgICBfaXNQcm9wZXJ0eVBlbmRpbmcocHJvcCkge1xuICAgICAgICByZXR1cm4gQm9vbGVhbih0aGlzLl9fZGF0YVBlbmRpbmcgJiYgKHByb3AgaW4gdGhpcy5fX2RhdGFQZW5kaW5nKSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogTWFya3MgdGhlIHByb3BlcnRpZXMgYXMgaW52YWxpZCwgYW5kIGVucXVldWVzIGFuIGFzeW5jXG4gICAgICAgKiBgX3Byb3BlcnRpZXNDaGFuZ2VkYCBjYWxsYmFjay5cbiAgICAgICAqXG4gICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgKi9cbiAgICAgIF9pbnZhbGlkYXRlUHJvcGVydGllcygpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9fZGF0YUludmFsaWQgJiYgdGhpcy5fX2RhdGFSZWFkeSkge1xuICAgICAgICAgIHRoaXMuX19kYXRhSW52YWxpZCA9IHRydWU7XG4gICAgICAgICAgbWljcm90YXNrLnJ1bigoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5fX2RhdGFJbnZhbGlkKSB7XG4gICAgICAgICAgICAgIHRoaXMuX19kYXRhSW52YWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgICB0aGlzLl9mbHVzaFByb3BlcnRpZXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENhbGwgdG8gZW5hYmxlIHByb3BlcnR5IGFjY2Vzc29yIHByb2Nlc3NpbmcuIEJlZm9yZSB0aGlzIG1ldGhvZCBpc1xuICAgICAgICogY2FsbGVkIGFjY2Vzc29yIHZhbHVlcyB3aWxsIGJlIHNldCBidXQgc2lkZSBlZmZlY3RzIGFyZVxuICAgICAgICogcXVldWVkLiBXaGVuIGNhbGxlZCwgYW55IHBlbmRpbmcgc2lkZSBlZmZlY3RzIG9jY3VyIGltbWVkaWF0ZWx5LlxuICAgICAgICogRm9yIGVsZW1lbnRzLCBnZW5lcmFsbHkgYGNvbm5lY3RlZENhbGxiYWNrYCBpcyBhIG5vcm1hbCBzcG90IHRvIGRvIHNvLlxuICAgICAgICogSXQgaXMgc2FmZSB0byBjYWxsIHRoaXMgbWV0aG9kIG11bHRpcGxlIHRpbWVzIGFzIGl0IG9ubHkgdHVybnMgb25cbiAgICAgICAqIHByb3BlcnR5IGFjY2Vzc29ycyBvbmNlLlxuICAgICAgICovXG4gICAgICBfZW5hYmxlUHJvcGVydGllcygpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9fZGF0YUVuYWJsZWQpIHtcbiAgICAgICAgICB0aGlzLl9fZGF0YUVuYWJsZWQgPSB0cnVlO1xuICAgICAgICAgIGlmICh0aGlzLl9fZGF0YUluc3RhbmNlUHJvcHMpIHtcbiAgICAgICAgICAgIHRoaXMuX2luaXRpYWxpemVJbnN0YW5jZVByb3BlcnRpZXModGhpcy5fX2RhdGFJbnN0YW5jZVByb3BzKTtcbiAgICAgICAgICAgIHRoaXMuX19kYXRhSW5zdGFuY2VQcm9wcyA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMucmVhZHkoKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ2FsbHMgdGhlIGBfcHJvcGVydGllc0NoYW5nZWRgIGNhbGxiYWNrIHdpdGggdGhlIGN1cnJlbnQgc2V0IG9mXG4gICAgICAgKiBwZW5kaW5nIGNoYW5nZXMgKGFuZCBvbGQgdmFsdWVzIHJlY29yZGVkIHdoZW4gcGVuZGluZyBjaGFuZ2VzIHdlcmVcbiAgICAgICAqIHNldCksIGFuZCByZXNldHMgdGhlIHBlbmRpbmcgc2V0IG9mIGNoYW5nZXMuIEdlbmVyYWxseSwgdGhpcyBtZXRob2RcbiAgICAgICAqIHNob3VsZCBub3QgYmUgY2FsbGVkIGluIHVzZXIgY29kZS5cbiAgICAgICAqXG4gICAgICAgKlxuICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICovXG4gICAgICBfZmx1c2hQcm9wZXJ0aWVzKCkge1xuICAgICAgICBpZiAodGhpcy5fX2RhdGFQZW5kaW5nICYmIHRoaXMuX19kYXRhT2xkKSB7XG4gICAgICAgICAgbGV0IGNoYW5nZWRQcm9wcyA9IHRoaXMuX19kYXRhUGVuZGluZztcbiAgICAgICAgICB0aGlzLl9fZGF0YVBlbmRpbmcgPSBudWxsO1xuICAgICAgICAgIHRoaXMuX19kYXRhQ291bnRlcisrO1xuICAgICAgICAgIHRoaXMuX3Byb3BlcnRpZXNDaGFuZ2VkKHRoaXMuX19kYXRhLCBjaGFuZ2VkUHJvcHMsIHRoaXMuX19kYXRhT2xkKTtcbiAgICAgICAgICB0aGlzLl9fZGF0YUNvdW50ZXItLTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIExpZmVjeWNsZSBjYWxsYmFjayBjYWxsZWQgdGhlIGZpcnN0IHRpbWUgcHJvcGVydGllcyBhcmUgYmVpbmcgZmx1c2hlZC5cbiAgICAgICAqIFByaW9yIHRvIGByZWFkeWAsIGFsbCBwcm9wZXJ0eSBzZXRzIHRocm91Z2ggYWNjZXNzb3JzIGFyZSBxdWV1ZWQgYW5kXG4gICAgICAgKiB0aGVpciBlZmZlY3RzIGFyZSBmbHVzaGVkIGFmdGVyIHRoaXMgbWV0aG9kIHJldHVybnMuXG4gICAgICAgKlxuICAgICAgICogVXNlcnMgbWF5IG92ZXJyaWRlIHRoaXMgZnVuY3Rpb24gdG8gaW1wbGVtZW50IGJlaGF2aW9yIHRoYXQgaXNcbiAgICAgICAqIGRlcGVuZGVudCBvbiB0aGUgZWxlbWVudCBoYXZpbmcgaXRzIHByb3BlcnRpZXMgaW5pdGlhbGl6ZWQsIGUuZy5cbiAgICAgICAqIGZyb20gZGVmYXVsdHMgKGluaXRpYWxpemVkIGZyb20gYGNvbnN0cnVjdG9yYCwgYF9pbml0aWFsaXplUHJvcGVydGllc2ApLFxuICAgICAgICogYGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFja2AsIG9yIHZhbHVlcyBwcm9wYWdhdGVkIGZyb20gaG9zdCBlLmcuIHZpYVxuICAgICAgICogYmluZGluZ3MuICBgc3VwZXIucmVhZHkoKWAgbXVzdCBiZSBjYWxsZWQgdG8gZW5zdXJlIHRoZSBkYXRhIHN5c3RlbVxuICAgICAgICogYmVjb21lcyBlbmFibGVkLlxuICAgICAgICpcbiAgICAgICAqIEBwdWJsaWNcbiAgICAgICAqL1xuICAgICAgcmVhZHkoKSB7XG4gICAgICAgIHRoaXMuX19kYXRhUmVhZHkgPSB0cnVlO1xuICAgICAgICAvLyBSdW4gbm9ybWFsIGZsdXNoXG4gICAgICAgIHRoaXMuX2ZsdXNoUHJvcGVydGllcygpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENhbGxiYWNrIGNhbGxlZCB3aGVuIGFueSBwcm9wZXJ0aWVzIHdpdGggYWNjZXNzb3JzIGNyZWF0ZWQgdmlhXG4gICAgICAgKiBgX2NyZWF0ZVByb3BlcnR5QWNjZXNzb3JgIGhhdmUgYmVlbiBzZXQuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHshT2JqZWN0fSBjdXJyZW50UHJvcHMgQmFnIG9mIGFsbCBjdXJyZW50IGFjY2Vzc29yIHZhbHVlc1xuICAgICAgICogQHBhcmFtIHshT2JqZWN0fSBjaGFuZ2VkUHJvcHMgQmFnIG9mIHByb3BlcnRpZXMgY2hhbmdlZCBzaW5jZSB0aGUgbGFzdFxuICAgICAgICogICBjYWxsIHRvIGBfcHJvcGVydGllc0NoYW5nZWRgXG4gICAgICAgKiBAcGFyYW0geyFPYmplY3R9IG9sZFByb3BzIEJhZyBvZiBwcmV2aW91cyB2YWx1ZXMgZm9yIGVhY2ggcHJvcGVydHlcbiAgICAgICAqICAgaW4gYGNoYW5nZWRQcm9wc2BcbiAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAqL1xuICAgICAgX3Byb3BlcnRpZXNDaGFuZ2VkKGN1cnJlbnRQcm9wcywgY2hhbmdlZFByb3BzLCBvbGRQcm9wcykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogTWV0aG9kIGNhbGxlZCB0byBkZXRlcm1pbmUgd2hldGhlciBhIHByb3BlcnR5IHZhbHVlIHNob3VsZCBiZVxuICAgICAgICogY29uc2lkZXJlZCBhcyBhIGNoYW5nZSBhbmQgY2F1c2UgdGhlIGBfcHJvcGVydGllc0NoYW5nZWRgIGNhbGxiYWNrXG4gICAgICAgKiB0byBiZSBlbnF1ZXVlZC5cbiAgICAgICAqXG4gICAgICAgKiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiByZXR1cm5zIGB0cnVlYCBmb3IgcHJpbWl0aXZlIHR5cGVzIGlmIGFcbiAgICAgICAqIHN0cmljdCBlcXVhbGl0eSBjaGVjayBmYWlscywgYW5kIHJldHVybnMgYHRydWVgIGZvciBhbGwgT2JqZWN0L0FycmF5cy5cbiAgICAgICAqIFRoZSBtZXRob2QgYWx3YXlzIHJldHVybnMgZmFsc2UgZm9yIGBOYU5gLlxuICAgICAgICpcbiAgICAgICAqIE92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIGUuZy4gcHJvdmlkZSBzdHJpY3RlciBjaGVja2luZyBmb3JcbiAgICAgICAqIE9iamVjdHMvQXJyYXlzIHdoZW4gdXNpbmcgaW1tdXRhYmxlIHBhdHRlcm5zLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSBuYW1lXG4gICAgICAgKiBAcGFyYW0geyp9IHZhbHVlIE5ldyBwcm9wZXJ0eSB2YWx1ZVxuICAgICAgICogQHBhcmFtIHsqfSBvbGQgUHJldmlvdXMgcHJvcGVydHkgdmFsdWVcbiAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIHByb3BlcnR5IHNob3VsZCBiZSBjb25zaWRlcmVkIGEgY2hhbmdlXG4gICAgICAgKiAgIGFuZCBlbnF1ZXVlIGEgYF9wcm9lcHJ0aWVzQ2hhbmdlZGAgY2FsbGJhY2tcbiAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAqL1xuICAgICAgX3Nob3VsZFByb3BlcnR5Q2hhbmdlKHByb3BlcnR5LCB2YWx1ZSwgb2xkKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgLy8gU3RyaWN0IGVxdWFsaXR5IGNoZWNrXG4gICAgICAgICAgKG9sZCAhPT0gdmFsdWUgJiZcbiAgICAgICAgICAgLy8gVGhpcyBlbnN1cmVzIChvbGQ9PU5hTiwgdmFsdWU9PU5hTikgYWx3YXlzIHJldHVybnMgZmFsc2VcbiAgICAgICAgICAgKG9sZCA9PT0gb2xkIHx8IHZhbHVlID09PSB2YWx1ZSkpXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICB9XG5cbiAgICByZXR1cm4gUHJvcGVydHlBY2Nlc3NvcnM7XG5cbiAgfSk7XG5cbn0pKCk7XG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvbWl4aW5zL3Byb3BlcnR5LWFjY2Vzc29ycy5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuXG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vdXRpbHMvYm9vdC5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vdXRpbHMvbWl4aW4uaHRtbFwiPlxuXG48c2NyaXB0PlxuKGZ1bmN0aW9uKCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICAvLyAxLnggYmFja3dhcmRzLWNvbXBhdGlibGUgYXV0by13cmFwcGVyIGZvciB0ZW1wbGF0ZSB0eXBlIGV4dGVuc2lvbnNcbiAgLy8gVGhpcyBpcyBhIGNsZWFyIGxheWVyaW5nIHZpb2xhdGlvbiBhbmQgZ2l2ZXMgZmF2b3JlZC1uYXRpb24gc3RhdHVzIHRvXG4gIC8vIGRvbS1pZiBhbmQgZG9tLXJlcGVhdCB0ZW1wbGF0ZXMuICBUaGlzIGlzIGEgY29uY2VpdCB3ZSdyZSBjaG9vc2luZyB0byBrZWVwXG4gIC8vIGEuKSB0byBlYXNlIDEueCBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eSBkdWUgdG8gbG9zcyBvZiBgaXNgLCBhbmRcbiAgLy8gYi4pIHRvIG1haW50YWluIGlmL3JlcGVhdCBjYXBhYmlsaXR5IGluIHBhcnNlci1jb25zdHJhaW5lZCBlbGVtZW50c1xuICAvLyAgICAgKGUuZy4gdGFibGUsIHNlbGVjdCkgaW4gbGlldSBvZiBuYXRpdmUgQ0UgdHlwZSBleHRlbnNpb25zIHdpdGhvdXRcbiAgLy8gICAgIG1hc3NpdmUgbmV3IGludmVudGlvbiBpbiB0aGlzIHNwYWNlIChlLmcuIGRpcmVjdGl2ZSBzeXN0ZW0pXG4gIGNvbnN0IHRlbXBsYXRlRXh0ZW5zaW9ucyA9IHtcbiAgICAnZG9tLWlmJzogdHJ1ZSxcbiAgICAnZG9tLXJlcGVhdCc6IHRydWVcbiAgfTtcbiAgZnVuY3Rpb24gd3JhcFRlbXBsYXRlRXh0ZW5zaW9uKG5vZGUpIHtcbiAgICBsZXQgaXMgPSBub2RlLmdldEF0dHJpYnV0ZSgnaXMnKTtcbiAgICBpZiAoaXMgJiYgdGVtcGxhdGVFeHRlbnNpb25zW2lzXSkge1xuICAgICAgbGV0IHQgPSBub2RlO1xuICAgICAgdC5yZW1vdmVBdHRyaWJ1dGUoJ2lzJyk7XG4gICAgICBub2RlID0gdC5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoaXMpO1xuICAgICAgdC5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChub2RlLCB0KTtcbiAgICAgIG5vZGUuYXBwZW5kQ2hpbGQodCk7XG4gICAgICB3aGlsZSh0LmF0dHJpYnV0ZXMubGVuZ3RoKSB7XG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKHQuYXR0cmlidXRlc1swXS5uYW1lLCB0LmF0dHJpYnV0ZXNbMF0udmFsdWUpO1xuICAgICAgICB0LnJlbW92ZUF0dHJpYnV0ZSh0LmF0dHJpYnV0ZXNbMF0ubmFtZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgZnVuY3Rpb24gZmluZFRlbXBsYXRlTm9kZShyb290LCBub2RlSW5mbykge1xuICAgIC8vIHJlY3Vyc2l2ZWx5IGFzY2VuZCB0cmVlIHVudGlsIHdlIGhpdCByb290XG4gICAgbGV0IHBhcmVudCA9IG5vZGVJbmZvLnBhcmVudEluZm8gJiYgZmluZFRlbXBsYXRlTm9kZShyb290LCBub2RlSW5mby5wYXJlbnRJbmZvKTtcbiAgICAvLyB1bndpbmQgdGhlIHN0YWNrLCByZXR1cm5pbmcgdGhlIGluZGV4ZWQgbm9kZSBhdCBlYWNoIGxldmVsXG4gICAgaWYgKHBhcmVudCkge1xuICAgICAgLy8gbm90ZTogbWFyZ2luYWxseSBmYXN0ZXIgdGhhbiBpbmRleGluZyB2aWEgY2hpbGROb2Rlc1xuICAgICAgLy8gKGh0dHA6Ly9qc3BlcmYuY29tL2NoaWxkbm9kZXMtbG9va3VwKVxuICAgICAgZm9yIChsZXQgbj1wYXJlbnQuZmlyc3RDaGlsZCwgaT0wOyBuOyBuPW4ubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgaWYgKG5vZGVJbmZvLnBhcmVudEluZGV4ID09PSBpKyspIHtcbiAgICAgICAgICByZXR1cm4gbjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcm9vdDtcbiAgICB9XG4gIH1cblxuICAvLyBjb25zdHJ1Y3QgYCRgIG1hcCAoZnJvbSBpZCBhbm5vdGF0aW9ucylcbiAgZnVuY3Rpb24gYXBwbHlJZFRvTWFwKGluc3QsIG1hcCwgbm9kZSwgbm9kZUluZm8pIHtcbiAgICBpZiAobm9kZUluZm8uaWQpIHtcbiAgICAgIG1hcFtub2RlSW5mby5pZF0gPSBub2RlO1xuICAgIH1cbiAgfVxuXG4gIC8vIGluc3RhbGwgZXZlbnQgbGlzdGVuZXJzIChmcm9tIGV2ZW50IGFubm90YXRpb25zKVxuICBmdW5jdGlvbiBhcHBseUV2ZW50TGlzdGVuZXIoaW5zdCwgbm9kZSwgbm9kZUluZm8pIHtcbiAgICBpZiAobm9kZUluZm8uZXZlbnRzICYmIG5vZGVJbmZvLmV2ZW50cy5sZW5ndGgpIHtcbiAgICAgIGZvciAobGV0IGo9MCwgZSQ9bm9kZUluZm8uZXZlbnRzLCBlOyAoajxlJC5sZW5ndGgpICYmIChlPWUkW2pdKTsgaisrKSB7XG4gICAgICAgIGluc3QuX2FkZE1ldGhvZEV2ZW50TGlzdGVuZXJUb05vZGUobm9kZSwgZS5uYW1lLCBlLnZhbHVlLCBpbnN0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBwdXNoIGNvbmZpZ3VyYXRpb24gcmVmZXJlbmNlcyBhdCBjb25maWd1cmUgdGltZVxuICBmdW5jdGlvbiBhcHBseVRlbXBsYXRlQ29udGVudChpbnN0LCBub2RlLCBub2RlSW5mbykge1xuICAgIGlmIChub2RlSW5mby50ZW1wbGF0ZUluZm8pIHtcbiAgICAgIG5vZGUuX3RlbXBsYXRlSW5mbyA9IG5vZGVJbmZvLnRlbXBsYXRlSW5mbztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVOb2RlRXZlbnRIYW5kbGVyKGNvbnRleHQsIGV2ZW50TmFtZSwgbWV0aG9kTmFtZSkge1xuICAgIC8vIEluc3RhbmNlcyBjYW4gb3B0aW9uYWxseSBoYXZlIGEgX21ldGhvZEhvc3Qgd2hpY2ggYWxsb3dzIHJlZGlyZWN0aW5nIHdoZXJlXG4gICAgLy8gdG8gZmluZCBtZXRob2RzLiBDdXJyZW50bHkgdXNlZCBieSBgdGVtcGxhdGl6ZWAuXG4gICAgY29udGV4dCA9IGNvbnRleHQuX21ldGhvZEhvc3QgfHwgY29udGV4dDtcbiAgICBsZXQgaGFuZGxlciA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgIGlmIChjb250ZXh0W21ldGhvZE5hbWVdKSB7XG4gICAgICAgIGNvbnRleHRbbWV0aG9kTmFtZV0oZSwgZS5kZXRhaWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdsaXN0ZW5lciBtZXRob2QgYCcgKyBtZXRob2ROYW1lICsgJ2Agbm90IGRlZmluZWQnKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBoYW5kbGVyO1xuICB9XG5cbiAgLyoqXG4gICAqIEVsZW1lbnQgbWl4aW4gdGhhdCBwcm92aWRlcyBiYXNpYyB0ZW1wbGF0ZSBwYXJzaW5nIGFuZCBzdGFtcGluZywgaW5jbHVkaW5nXG4gICAqIHRoZSBmb2xsb3dpbmcgdGVtcGxhdGUtcmVsYXRlZCBmZWF0dXJlcyBmb3Igc3RhbXBlZCB0ZW1wbGF0ZXM6XG4gICAqXG4gICAqIC0gRGVjbGFyYXRpdmUgZXZlbnQgbGlzdGVuZXJzIChgb24tZXZlbnRuYW1lPVwibGlzdGVuZXJcImApXG4gICAqIC0gTWFwIG9mIG5vZGUgaWQncyB0byBzdGFtcGVkIG5vZGUgaW5zdGFuY2VzIChgdGhpcy4kLmlkYClcbiAgICogLSBOZXN0ZWQgdGVtcGxhdGUgY29udGVudCBjYWNoaW5nL3JlbW92YWwgYW5kIHJlLWluc3RhbGxhdGlvbiAocGVyZm9ybWFuY2VcbiAgICogICBvcHRpbWl6YXRpb24pXG4gICAqXG4gICAqIEBtaXhpbkZ1bmN0aW9uXG4gICAqIEBwb2x5bWVyXG4gICAqIEBtZW1iZXJvZiBQb2x5bWVyXG4gICAqIEBzdW1tYXJ5IEVsZW1lbnQgY2xhc3MgbWl4aW4gdGhhdCBwcm92aWRlcyBiYXNpYyB0ZW1wbGF0ZSBwYXJzaW5nIGFuZCBzdGFtcGluZ1xuICAgKi9cbiAgUG9seW1lci5UZW1wbGF0ZVN0YW1wID0gUG9seW1lci5kZWR1cGluZ01peGluKHN1cGVyQ2xhc3MgPT4ge1xuXG4gICAgLyoqXG4gICAgICogQHBvbHltZXJcbiAgICAgKiBAbWl4aW5DbGFzc1xuICAgICAqIEBpbXBsZW1lbnRzIHtQb2x5bWVyX1RlbXBsYXRlU3RhbXB9XG4gICAgICovXG4gICAgY2xhc3MgVGVtcGxhdGVTdGFtcCBleHRlbmRzIHN1cGVyQ2xhc3Mge1xuXG4gICAgICAvKipcbiAgICAgICAqIFNjYW5zIGEgdGVtcGxhdGUgdG8gcHJvZHVjZSB0ZW1wbGF0ZSBtZXRhZGF0YS5cbiAgICAgICAqXG4gICAgICAgKiBUZW1wbGF0ZS1zcGVjaWZpYyBtZXRhZGF0YSBhcmUgc3RvcmVkIGluIHRoZSBvYmplY3QgcmV0dXJuZWQsIGFuZCBub2RlLVxuICAgICAgICogc3BlY2lmaWMgbWV0YWRhdGEgYXJlIHN0b3JlZCBpbiBvYmplY3RzIGluIGl0cyBmbGF0dGVuZWQgYG5vZGVJbmZvTGlzdGBcbiAgICAgICAqIGFycmF5LiAgT25seSBub2RlcyBpbiB0aGUgdGVtcGxhdGUgdGhhdCB3ZXJlIHBhcnNlZCBhcyBub2RlcyBvZlxuICAgICAgICogaW50ZXJlc3QgY29udGFpbiBhbiBvYmplY3QgaW4gYG5vZGVJbmZvTGlzdGAuICBFYWNoIGBub2RlSW5mb2Agb2JqZWN0XG4gICAgICAgKiBjb250YWlucyBhbiBgaW5kZXhgIChgY2hpbGROb2Rlc2AgaW5kZXggaW4gcGFyZW50KSBhbmQgb3B0aW9uYWxseVxuICAgICAgICogYHBhcmVudGAsIHdoaWNoIHBvaW50cyB0byBub2RlIGluZm8gb2YgaXRzIHBhcmVudCAoaW5jbHVkaW5nIGl0cyBpbmRleCkuXG4gICAgICAgKlxuICAgICAgICogVGhlIHRlbXBsYXRlIG1ldGFkYXRhIG9iamVjdCByZXR1cm5lZCBmcm9tIHRoaXMgbWV0aG9kIGhhcyB0aGUgZm9sbG93aW5nXG4gICAgICAgKiBzdHJ1Y3R1cmUgKG1hbnkgZmllbGRzIG9wdGlvbmFsKTpcbiAgICAgICAqXG4gICAgICAgKiBgYGBqc1xuICAgICAgICogICB7XG4gICAgICAgKiAgICAgLy8gRmxhdHRlbmVkIGxpc3Qgb2Ygbm9kZSBtZXRhZGF0YSAoZm9yIG5vZGVzIHRoYXQgZ2VuZXJhdGVkIG1ldGFkYXRhKVxuICAgICAgICogICAgIG5vZGVJbmZvTGlzdDogW1xuICAgICAgICogICAgICAge1xuICAgICAgICogICAgICAgICAvLyBgaWRgIGF0dHJpYnV0ZSBmb3IgYW55IG5vZGVzIHdpdGggaWQncyBmb3IgZ2VuZXJhdGluZyBgJGAgbWFwXG4gICAgICAgKiAgICAgICAgIGlkOiB7c3RyaW5nfSxcbiAgICAgICAqICAgICAgICAgLy8gYG9uLWV2ZW50PVwiaGFuZGxlclwiYCBtZXRhZGF0YVxuICAgICAgICogICAgICAgICBldmVudHM6IFtcbiAgICAgICAqICAgICAgICAgICB7XG4gICAgICAgKiAgICAgICAgICAgICBuYW1lOiB7c3RyaW5nfSwgICAvLyBldmVudCBuYW1lXG4gICAgICAgKiAgICAgICAgICAgICB2YWx1ZToge3N0cmluZ30sICAvLyBoYW5kbGVyIG1ldGhvZCBuYW1lXG4gICAgICAgKiAgICAgICAgICAgfSwgLi4uXG4gICAgICAgKiAgICAgICAgIF0sXG4gICAgICAgKiAgICAgICAgIC8vIE5vdGVzIHdoZW4gdGhlIHRlbXBsYXRlIGNvbnRhaW5lZCBhIGA8c2xvdD5gIGZvciBzaGFkeSBET01cbiAgICAgICAqICAgICAgICAgLy8gb3B0aW1pemF0aW9uIHB1cnBvc2VzXG4gICAgICAgKiAgICAgICAgIGhhc0luc2VydGlvblBvaW50OiB7Ym9vbGVhbn0sXG4gICAgICAgKiAgICAgICAgIC8vIEZvciBuZXN0ZWQgYDx0ZW1wbGF0ZT5gYCBub2RlcywgbmVzdGVkIHRlbXBsYXRlIG1ldGFkYXRhXG4gICAgICAgKiAgICAgICAgIHRlbXBsYXRlSW5mbzoge29iamVjdH0sIC8vIG5lc3RlZCB0ZW1wbGF0ZSBtZXRhZGF0YVxuICAgICAgICogICAgICAgICAvLyBNZXRhZGF0YSB0byBhbGxvdyBlZmZpY2llbnQgcmV0cmlldmFsIG9mIGluc3RhbmNlZCBub2RlXG4gICAgICAgKiAgICAgICAgIC8vIGNvcnJlc3BvbmRpbmcgdG8gdGhpcyBtZXRhZGF0YVxuICAgICAgICogICAgICAgICBwYXJlbnRJbmZvOiB7bnVtYmVyfSwgICAvLyByZWZlcmVuY2UgdG8gcGFyZW50IG5vZGVJbmZvPlxuICAgICAgICogICAgICAgICBwYXJlbnRJbmRleDoge251bWJlcn0sICAvLyBpbmRleCBpbiBwYXJlbnQncyBgY2hpbGROb2Rlc2AgY29sbGVjdGlvblxuICAgICAgICogICAgICAgICBpbmZvSW5kZXg6IHtudW1iZXJ9LCAgICAvLyBpbmRleCBvZiB0aGlzIGBub2RlSW5mb2AgaW4gYHRlbXBsYXRlSW5mby5ub2RlSW5mb0xpc3RgXG4gICAgICAgKiAgICAgICB9LFxuICAgICAgICogICAgICAgLi4uXG4gICAgICAgKiAgICAgXSxcbiAgICAgICAqICAgICAvLyBXaGVuIHRydWUsIHRoZSB0ZW1wbGF0ZSBoYWQgdGhlIGBzdHJpcC13aGl0ZXNwYWNlYCBhdHRyaWJ1dGVcbiAgICAgICAqICAgICAvLyBvciB3YXMgbmVzdGVkIGluIGEgdGVtcGxhdGUgd2l0aCB0aGF0IHNldHRpbmdcbiAgICAgICAqICAgICBzdHJpcFdoaXRlc3BhY2U6IHtib29sZWFufSxcbiAgICAgICAqICAgICAvLyBGb3IgbmVzdGVkIHRlbXBsYXRlcywgbmVzdGVkIHRlbXBsYXRlIGNvbnRlbnQgaXMgbW92ZWQgaW50b1xuICAgICAgICogICAgIC8vIGEgZG9jdW1lbnQgZnJhZ21lbnQgc3RvcmVkIGhlcmU7IHRoaXMgaXMgYW4gb3B0aW1pemF0aW9uIHRvXG4gICAgICAgKiAgICAgLy8gYXZvaWQgdGhlIGNvc3Qgb2YgbmVzdGVkIHRlbXBsYXRlIGNsb25pbmdcbiAgICAgICAqICAgICBjb250ZW50OiB7RG9jdW1lbnRGcmFnbWVudH1cbiAgICAgICAqICAgfVxuICAgICAgICogYGBgXG4gICAgICAgKlxuICAgICAgICogVGhpcyBtZXRob2Qga2lja3Mgb2ZmIGEgcmVjdXJzaXZlIHRyZWV3YWxrIGFzIGZvbGxvd3M6XG4gICAgICAgKlxuICAgICAgICogYGBgXG4gICAgICAgKiAgICBfcGFyc2VUZW1wbGF0ZSA8LS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICogICAgICBfcGFyc2VUZW1wbGF0ZUNvbnRlbnQgICAgICAgICAgICAgIHxcbiAgICAgICAqICAgICAgICBfcGFyc2VUZW1wbGF0ZU5vZGUgIDwtLS0tLS0tLS0tLS18LS0rXG4gICAgICAgKiAgICAgICAgICBfcGFyc2VUZW1wbGF0ZU5lc3RlZFRlbXBsYXRlIC0tKyAgfFxuICAgICAgICogICAgICAgICAgX3BhcnNlVGVtcGxhdGVDaGlsZE5vZGVzIC0tLS0tLS0tLStcbiAgICAgICAqICAgICAgICAgIF9wYXJzZVRlbXBsYXRlTm9kZUF0dHJpYnV0ZXNcbiAgICAgICAqICAgICAgICAgICAgX3BhcnNlVGVtcGxhdGVOb2RlQXR0cmlidXRlXG4gICAgICAgKlxuICAgICAgICogYGBgXG4gICAgICAgKlxuICAgICAgICogVGhlc2UgbWV0aG9kcyBtYXkgYmUgb3ZlcnJpZGRlbiB0byBhZGQgY3VzdG9tIG1ldGFkYXRhIGFib3V0IHRlbXBsYXRlc1xuICAgICAgICogdG8gZWl0aGVyIGB0ZW1wbGF0ZUluZm9gIG9yIGBub2RlSW5mb2AuXG4gICAgICAgKlxuICAgICAgICogTm90ZSB0aGF0IHRoaXMgbWV0aG9kIG1heSBiZSBkZXN0cnVjdGl2ZSB0byB0aGUgdGVtcGxhdGUsIGluIHRoYXRcbiAgICAgICAqIGUuZy4gZXZlbnQgYW5ub3RhdGlvbnMgbWF5IGJlIHJlbW92ZWQgYWZ0ZXIgYmVpbmcgbm90ZWQgaW4gdGhlXG4gICAgICAgKiB0ZW1wbGF0ZSBtZXRhZGF0YS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0geyFIVE1MVGVtcGxhdGVFbGVtZW50fSB0ZW1wbGF0ZSBUZW1wbGF0ZSB0byBwYXJzZVxuICAgICAgICogQHBhcmFtIHtUZW1wbGF0ZUluZm89fSBvdXRlclRlbXBsYXRlSW5mbyBUZW1wbGF0ZSBtZXRhZGF0YSBmcm9tIHRoZSBvdXRlclxuICAgICAgICogICB0ZW1wbGF0ZSwgZm9yIHBhcnNpbmcgbmVzdGVkIHRlbXBsYXRlc1xuICAgICAgICogQHJldHVybiB7IVRlbXBsYXRlSW5mb30gUGFyc2VkIHRlbXBsYXRlIG1ldGFkYXRhXG4gICAgICAgKi9cbiAgICAgIHN0YXRpYyBfcGFyc2VUZW1wbGF0ZSh0ZW1wbGF0ZSwgb3V0ZXJUZW1wbGF0ZUluZm8pIHtcbiAgICAgICAgLy8gc2luY2UgYSB0ZW1wbGF0ZSBtYXkgYmUgcmUtdXNlZCwgbWVtby1pemUgbWV0YWRhdGFcbiAgICAgICAgaWYgKCF0ZW1wbGF0ZS5fdGVtcGxhdGVJbmZvKSB7XG4gICAgICAgICAgbGV0IHRlbXBsYXRlSW5mbyA9IHRlbXBsYXRlLl90ZW1wbGF0ZUluZm8gPSB7fTtcbiAgICAgICAgICB0ZW1wbGF0ZUluZm8ubm9kZUluZm9MaXN0ID0gW107XG4gICAgICAgICAgdGVtcGxhdGVJbmZvLnN0cmlwV2hpdGVTcGFjZSA9XG4gICAgICAgICAgICAob3V0ZXJUZW1wbGF0ZUluZm8gJiYgb3V0ZXJUZW1wbGF0ZUluZm8uc3RyaXBXaGl0ZVNwYWNlKSB8fFxuICAgICAgICAgICAgdGVtcGxhdGUuaGFzQXR0cmlidXRlKCdzdHJpcC13aGl0ZXNwYWNlJyk7XG4gICAgICAgICAgdGhpcy5fcGFyc2VUZW1wbGF0ZUNvbnRlbnQodGVtcGxhdGUsIHRlbXBsYXRlSW5mbywge3BhcmVudDogbnVsbH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ZW1wbGF0ZS5fdGVtcGxhdGVJbmZvO1xuICAgICAgfVxuXG4gICAgICBzdGF0aWMgX3BhcnNlVGVtcGxhdGVDb250ZW50KHRlbXBsYXRlLCB0ZW1wbGF0ZUluZm8sIG5vZGVJbmZvKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJzZVRlbXBsYXRlTm9kZSh0ZW1wbGF0ZS5jb250ZW50LCB0ZW1wbGF0ZUluZm8sIG5vZGVJbmZvKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBQYXJzZXMgdGVtcGxhdGUgbm9kZSBhbmQgYWRkcyB0ZW1wbGF0ZSBhbmQgbm9kZSBtZXRhZGF0YSBiYXNlZCBvblxuICAgICAgICogdGhlIGN1cnJlbnQgbm9kZSwgYW5kIGl0cyBgY2hpbGROb2Rlc2AgYW5kIGBhdHRyaWJ1dGVzYC5cbiAgICAgICAqXG4gICAgICAgKiBUaGlzIG1ldGhvZCBtYXkgYmUgb3ZlcnJpZGRlbiB0byBhZGQgY3VzdG9tIG5vZGUgb3IgdGVtcGxhdGUgc3BlY2lmaWNcbiAgICAgICAqIG1ldGFkYXRhIGJhc2VkIG9uIHRoaXMgbm9kZS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgTm9kZSB0byBwYXJzZVxuICAgICAgICogQHBhcmFtIHshVGVtcGxhdGVJbmZvfSB0ZW1wbGF0ZUluZm8gVGVtcGxhdGUgbWV0YWRhdGEgZm9yIGN1cnJlbnQgdGVtcGxhdGVcbiAgICAgICAqIEBwYXJhbSB7IU5vZGVJbmZvfSBub2RlSW5mbyBOb2RlIG1ldGFkYXRhIGZvciBjdXJyZW50IHRlbXBsYXRlLlxuICAgICAgICogQHJldHVybiB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSB2aXNpdGVkIG5vZGUgYWRkZWQgbm9kZS1zcGVjaWZpY1xuICAgICAgICogICBtZXRhZGF0YSB0byBgbm9kZUluZm9gXG4gICAgICAgKi9cbiAgICAgIHN0YXRpYyBfcGFyc2VUZW1wbGF0ZU5vZGUobm9kZSwgdGVtcGxhdGVJbmZvLCBub2RlSW5mbykge1xuICAgICAgICBsZXQgbm90ZWQ7XG4gICAgICAgIGxldCBlbGVtZW50ID0gLyoqIEB0eXBlIEVsZW1lbnQgKi8obm9kZSk7XG4gICAgICAgIGlmIChlbGVtZW50LmxvY2FsTmFtZSA9PSAndGVtcGxhdGUnICYmICFlbGVtZW50Lmhhc0F0dHJpYnV0ZSgncHJlc2VydmUtY29udGVudCcpKSB7XG4gICAgICAgICAgbm90ZWQgPSB0aGlzLl9wYXJzZVRlbXBsYXRlTmVzdGVkVGVtcGxhdGUoZWxlbWVudCwgdGVtcGxhdGVJbmZvLCBub2RlSW5mbykgfHwgbm90ZWQ7XG4gICAgICAgIH0gZWxzZSBpZiAoZWxlbWVudC5sb2NhbE5hbWUgPT09ICdzbG90Jykge1xuICAgICAgICAgIC8vIEZvciBTaGFkeURvbSBvcHRpbWl6YXRpb24sIGluZGljYXRpbmcgdGhlcmUgaXMgYW4gaW5zZXJ0aW9uIHBvaW50XG4gICAgICAgICAgdGVtcGxhdGVJbmZvLmhhc0luc2VydGlvblBvaW50ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZWxlbWVudC5maXJzdENoaWxkKSB7XG4gICAgICAgICAgbm90ZWQgPSB0aGlzLl9wYXJzZVRlbXBsYXRlQ2hpbGROb2RlcyhlbGVtZW50LCB0ZW1wbGF0ZUluZm8sIG5vZGVJbmZvKSB8fCBub3RlZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZWxlbWVudC5oYXNBdHRyaWJ1dGVzICYmIGVsZW1lbnQuaGFzQXR0cmlidXRlcygpKSB7XG4gICAgICAgICAgbm90ZWQgPSB0aGlzLl9wYXJzZVRlbXBsYXRlTm9kZUF0dHJpYnV0ZXMoZWxlbWVudCwgdGVtcGxhdGVJbmZvLCBub2RlSW5mbykgfHwgbm90ZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vdGVkO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFBhcnNlcyB0ZW1wbGF0ZSBjaGlsZCBub2RlcyBmb3IgdGhlIGdpdmVuIHJvb3Qgbm9kZS5cbiAgICAgICAqXG4gICAgICAgKiBUaGlzIG1ldGhvZCBhbHNvIHdyYXBzIHdoaXRlbGlzdGVkIGxlZ2FjeSB0ZW1wbGF0ZSBleHRlbnNpb25zXG4gICAgICAgKiAoYGlzPVwiZG9tLWlmXCJgIGFuZCBgaXM9XCJkb20tcmVwZWF0XCJgKSB3aXRoIHRoZWlyIGVxdWl2YWxlbnQgZWxlbWVudFxuICAgICAgICogd3JhcHBlcnMsIGNvbGxhcHNlcyB0ZXh0IG5vZGVzLCBhbmQgc3RyaXBzIHdoaXRlc3BhY2UgZnJvbSB0aGUgdGVtcGxhdGVcbiAgICAgICAqIGlmIHRoZSBgdGVtcGxhdGVJbmZvLnN0cmlwV2hpdGVzcGFjZWAgc2V0dGluZyB3YXMgcHJvdmlkZWQuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtOb2RlfSByb290IFJvb3Qgbm9kZSB3aG9zZSBgY2hpbGROb2Rlc2Agd2lsbCBiZSBwYXJzZWRcbiAgICAgICAqIEBwYXJhbSB7IVRlbXBsYXRlSW5mb30gdGVtcGxhdGVJbmZvIFRlbXBsYXRlIG1ldGFkYXRhIGZvciBjdXJyZW50IHRlbXBsYXRlXG4gICAgICAgKiBAcGFyYW0geyFOb2RlSW5mb30gbm9kZUluZm8gTm9kZSBtZXRhZGF0YSBmb3IgY3VycmVudCB0ZW1wbGF0ZS5cbiAgICAgICAqL1xuICAgICAgc3RhdGljIF9wYXJzZVRlbXBsYXRlQ2hpbGROb2Rlcyhyb290LCB0ZW1wbGF0ZUluZm8sIG5vZGVJbmZvKSB7XG4gICAgICAgIGZvciAobGV0IG5vZGU9cm9vdC5maXJzdENoaWxkLCBwYXJlbnRJbmRleD0wLCBuZXh0OyBub2RlOyBub2RlPW5leHQpIHtcbiAgICAgICAgICAvLyBXcmFwIHRlbXBsYXRlc1xuICAgICAgICAgIGlmIChub2RlLmxvY2FsTmFtZSA9PSAndGVtcGxhdGUnKSB7XG4gICAgICAgICAgICBub2RlID0gd3JhcFRlbXBsYXRlRXh0ZW5zaW9uKG5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBjb2xsYXBzZSBhZGphY2VudCB0ZXh0Tm9kZXM6IGZpeGVzIGFuIElFIGlzc3VlIHRoYXQgY2FuIGNhdXNlXG4gICAgICAgICAgLy8gdGV4dCBub2RlcyB0byBiZSBpbmV4cGxpY2FibHkgc3BsaXQgPShcbiAgICAgICAgICAvLyBub3RlIHRoYXQgcm9vdC5ub3JtYWxpemUoKSBzaG91bGQgd29yayBidXQgZG9lcyBub3Qgc28gd2UgZG8gdGhpc1xuICAgICAgICAgIC8vIG1hbnVhbGx5LlxuICAgICAgICAgIG5leHQgPSBub2RlLm5leHRTaWJsaW5nO1xuICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSkge1xuICAgICAgICAgICAgbGV0IC8qKiBOb2RlICovIG4gPSBuZXh0O1xuICAgICAgICAgICAgd2hpbGUgKG4gJiYgKG4ubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFKSkge1xuICAgICAgICAgICAgICBub2RlLnRleHRDb250ZW50ICs9IG4udGV4dENvbnRlbnQ7XG4gICAgICAgICAgICAgIG5leHQgPSBuLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICByb290LnJlbW92ZUNoaWxkKG4pO1xuICAgICAgICAgICAgICBuID0gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIG9wdGlvbmFsbHkgc3RyaXAgd2hpdGVzcGFjZVxuICAgICAgICAgICAgaWYgKHRlbXBsYXRlSW5mby5zdHJpcFdoaXRlU3BhY2UgJiYgIW5vZGUudGV4dENvbnRlbnQudHJpbSgpKSB7XG4gICAgICAgICAgICAgIHJvb3QucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgY2hpbGRJbmZvID0geyBwYXJlbnRJbmRleCwgcGFyZW50SW5mbzogbm9kZUluZm8gfTtcbiAgICAgICAgICBpZiAodGhpcy5fcGFyc2VUZW1wbGF0ZU5vZGUobm9kZSwgdGVtcGxhdGVJbmZvLCBjaGlsZEluZm8pKSB7XG4gICAgICAgICAgICBjaGlsZEluZm8uaW5mb0luZGV4ID0gdGVtcGxhdGVJbmZvLm5vZGVJbmZvTGlzdC5wdXNoKC8qKiBAdHlwZSB7IU5vZGVJbmZvfSAqLyhjaGlsZEluZm8pKSAtIDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIEluY3JlbWVudCBpZiBub3QgcmVtb3ZlZFxuICAgICAgICAgIGlmIChub2RlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIHBhcmVudEluZGV4Kys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUGFyc2VzIHRlbXBsYXRlIGNvbnRlbnQgZm9yIHRoZSBnaXZlbiBuZXN0ZWQgYDx0ZW1wbGF0ZT5gLlxuICAgICAgICpcbiAgICAgICAqIE5lc3RlZCB0ZW1wbGF0ZSBpbmZvIGlzIHN0b3JlZCBhcyBgdGVtcGxhdGVJbmZvYCBpbiB0aGUgY3VycmVudCBub2RlJ3NcbiAgICAgICAqIGBub2RlSW5mb2AuIGB0ZW1wbGF0ZS5jb250ZW50YCBpcyByZW1vdmVkIGFuZCBzdG9yZWQgaW4gYHRlbXBsYXRlSW5mb2AuXG4gICAgICAgKiBJdCB3aWxsIHRoZW4gYmUgdGhlIHJlc3BvbnNpYmlsaXR5IG9mIHRoZSBob3N0IHRvIHNldCBpdCBiYWNrIHRvIHRoZVxuICAgICAgICogdGVtcGxhdGUgYW5kIGZvciB1c2VycyBzdGFtcGluZyBuZXN0ZWQgdGVtcGxhdGVzIHRvIHVzZSB0aGVcbiAgICAgICAqIGBfY29udGVudEZvclRlbXBsYXRlYCBtZXRob2QgdG8gcmV0cmlldmUgdGhlIGNvbnRlbnQgZm9yIHRoaXMgdGVtcGxhdGVcbiAgICAgICAqIChhbiBvcHRpbWl6YXRpb24gdG8gYXZvaWQgdGhlIGNvc3Qgb2YgY2xvbmluZyBuZXN0ZWQgdGVtcGxhdGUgY29udGVudCkuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtIVE1MVGVtcGxhdGVFbGVtZW50fSBub2RlIE5vZGUgdG8gcGFyc2UgKGEgPHRlbXBsYXRlPilcbiAgICAgICAqIEBwYXJhbSB7VGVtcGxhdGVJbmZvfSBvdXRlclRlbXBsYXRlSW5mbyBUZW1wbGF0ZSBtZXRhZGF0YSBmb3IgY3VycmVudCB0ZW1wbGF0ZVxuICAgICAgICogICB0aGF0IGluY2x1ZGVzIHRoZSB0ZW1wbGF0ZSBgbm9kZWBcbiAgICAgICAqIEBwYXJhbSB7IU5vZGVJbmZvfSBub2RlSW5mbyBOb2RlIG1ldGFkYXRhIGZvciBjdXJyZW50IHRlbXBsYXRlLlxuICAgICAgICogQHJldHVybiB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSB2aXNpdGVkIG5vZGUgYWRkZWQgbm9kZS1zcGVjaWZpY1xuICAgICAgICogICBtZXRhZGF0YSB0byBgbm9kZUluZm9gXG4gICAgICAgKi9cbiAgICAgIHN0YXRpYyBfcGFyc2VUZW1wbGF0ZU5lc3RlZFRlbXBsYXRlKG5vZGUsIG91dGVyVGVtcGxhdGVJbmZvLCBub2RlSW5mbykge1xuICAgICAgICBsZXQgdGVtcGxhdGVJbmZvID0gdGhpcy5fcGFyc2VUZW1wbGF0ZShub2RlLCBvdXRlclRlbXBsYXRlSW5mbyk7XG4gICAgICAgIGxldCBjb250ZW50ID0gdGVtcGxhdGVJbmZvLmNvbnRlbnQgPVxuICAgICAgICAgIG5vZGUuY29udGVudC5vd25lckRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICAgICAgY29udGVudC5hcHBlbmRDaGlsZChub2RlLmNvbnRlbnQpO1xuICAgICAgICBub2RlSW5mby50ZW1wbGF0ZUluZm8gPSB0ZW1wbGF0ZUluZm87XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFBhcnNlcyB0ZW1wbGF0ZSBub2RlIGF0dHJpYnV0ZXMgYW5kIGFkZHMgbm9kZSBtZXRhZGF0YSB0byBgbm9kZUluZm9gXG4gICAgICAgKiBmb3Igbm9kZXMgb2YgaW50ZXJlc3QuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtFbGVtZW50fSBub2RlIE5vZGUgdG8gcGFyc2VcbiAgICAgICAqIEBwYXJhbSB7VGVtcGxhdGVJbmZvfSB0ZW1wbGF0ZUluZm8gVGVtcGxhdGUgbWV0YWRhdGEgZm9yIGN1cnJlbnQgdGVtcGxhdGVcbiAgICAgICAqIEBwYXJhbSB7Tm9kZUluZm99IG5vZGVJbmZvIE5vZGUgbWV0YWRhdGEgZm9yIGN1cnJlbnQgdGVtcGxhdGUuXG4gICAgICAgKiBAcmV0dXJuIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIHZpc2l0ZWQgbm9kZSBhZGRlZCBub2RlLXNwZWNpZmljXG4gICAgICAgKiAgIG1ldGFkYXRhIHRvIGBub2RlSW5mb2BcbiAgICAgICAqL1xuICAgICAgc3RhdGljIF9wYXJzZVRlbXBsYXRlTm9kZUF0dHJpYnV0ZXMobm9kZSwgdGVtcGxhdGVJbmZvLCBub2RlSW5mbykge1xuICAgICAgICAvLyBNYWtlIGNvcHkgb2Ygb3JpZ2luYWwgYXR0cmlidXRlIGxpc3QsIHNpbmNlIHRoZSBvcmRlciBtYXkgY2hhbmdlXG4gICAgICAgIC8vIGFzIGF0dHJpYnV0ZXMgYXJlIGFkZGVkIGFuZCByZW1vdmVkXG4gICAgICAgIGxldCBub3RlZCA9IGZhbHNlO1xuICAgICAgICBsZXQgYXR0cnMgPSBBcnJheS5mcm9tKG5vZGUuYXR0cmlidXRlcyk7XG4gICAgICAgIGZvciAobGV0IGk9YXR0cnMubGVuZ3RoLTEsIGE7IChhPWF0dHJzW2ldKTsgaS0tKSB7XG4gICAgICAgICAgbm90ZWQgPSB0aGlzLl9wYXJzZVRlbXBsYXRlTm9kZUF0dHJpYnV0ZShub2RlLCB0ZW1wbGF0ZUluZm8sIG5vZGVJbmZvLCBhLm5hbWUsIGEudmFsdWUpIHx8IG5vdGVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub3RlZDtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBQYXJzZXMgYSBzaW5nbGUgdGVtcGxhdGUgbm9kZSBhdHRyaWJ1dGUgYW5kIGFkZHMgbm9kZSBtZXRhZGF0YSB0b1xuICAgICAgICogYG5vZGVJbmZvYCBmb3IgYXR0cmlidXRlcyBvZiBpbnRlcmVzdC5cbiAgICAgICAqXG4gICAgICAgKiBUaGlzIGltcGxlbWVudGF0aW9uIGFkZHMgbWV0YWRhdGEgZm9yIGBvbi1ldmVudD1cImhhbmRsZXJcImAgYXR0cmlidXRlc1xuICAgICAgICogYW5kIGBpZGAgYXR0cmlidXRlcy5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgTm9kZSB0byBwYXJzZVxuICAgICAgICogQHBhcmFtIHshVGVtcGxhdGVJbmZvfSB0ZW1wbGF0ZUluZm8gVGVtcGxhdGUgbWV0YWRhdGEgZm9yIGN1cnJlbnQgdGVtcGxhdGVcbiAgICAgICAqIEBwYXJhbSB7IU5vZGVJbmZvfSBub2RlSW5mbyBOb2RlIG1ldGFkYXRhIGZvciBjdXJyZW50IHRlbXBsYXRlLlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgQXR0cmlidXRlIG5hbWVcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSBBdHRyaWJ1dGUgdmFsdWVcbiAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgdmlzaXRlZCBub2RlIGFkZGVkIG5vZGUtc3BlY2lmaWNcbiAgICAgICAqICAgbWV0YWRhdGEgdG8gYG5vZGVJbmZvYFxuICAgICAgICovXG4gICAgICBzdGF0aWMgX3BhcnNlVGVtcGxhdGVOb2RlQXR0cmlidXRlKG5vZGUsIHRlbXBsYXRlSW5mbywgbm9kZUluZm8sIG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIC8vIGV2ZW50cyAob24tKilcbiAgICAgICAgaWYgKG5hbWUuc2xpY2UoMCwgMykgPT09ICdvbi0nKSB7XG4gICAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgICAgICAgbm9kZUluZm8uZXZlbnRzID0gbm9kZUluZm8uZXZlbnRzIHx8IFtdO1xuICAgICAgICAgIG5vZGVJbmZvLmV2ZW50cy5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6IG5hbWUuc2xpY2UoMyksXG4gICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIHN0YXRpYyBpZFxuICAgICAgICBlbHNlIGlmIChuYW1lID09PSAnaWQnKSB7XG4gICAgICAgICAgbm9kZUluZm8uaWQgPSB2YWx1ZTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUmV0dXJucyB0aGUgYGNvbnRlbnRgIGRvY3VtZW50IGZyYWdtZW50IGZvciBhIGdpdmVuIHRlbXBsYXRlLlxuICAgICAgICpcbiAgICAgICAqIEZvciBuZXN0ZWQgdGVtcGxhdGVzLCBQb2x5bWVyIHBlcmZvcm1zIGFuIG9wdGltaXphdGlvbiB0byBjYWNoZSBuZXN0ZWRcbiAgICAgICAqIHRlbXBsYXRlIGNvbnRlbnQgdG8gYXZvaWQgdGhlIGNvc3Qgb2YgY2xvbmluZyBkZWVwbHkgbmVzdGVkIHRlbXBsYXRlcy5cbiAgICAgICAqIFRoaXMgbWV0aG9kIHJldHJpZXZlcyB0aGUgY2FjaGVkIGNvbnRlbnQgZm9yIGEgZ2l2ZW4gdGVtcGxhdGUuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtIVE1MVGVtcGxhdGVFbGVtZW50fSB0ZW1wbGF0ZSBUZW1wbGF0ZSB0byByZXRyaWV2ZSBgY29udGVudGAgZm9yXG4gICAgICAgKiBAcmV0dXJuIHtEb2N1bWVudEZyYWdtZW50fSBDb250ZW50IGZyYWdtZW50XG4gICAgICAgKi9cbiAgICAgIHN0YXRpYyBfY29udGVudEZvclRlbXBsYXRlKHRlbXBsYXRlKSB7XG4gICAgICAgIGxldCB0ZW1wbGF0ZUluZm8gPSAvKiogQHR5cGUge0hUTUxUZW1wbGF0ZUVsZW1lbnRXaXRoSW5mb30gKi8gKHRlbXBsYXRlKS5fdGVtcGxhdGVJbmZvO1xuICAgICAgICByZXR1cm4gKHRlbXBsYXRlSW5mbyAmJiB0ZW1wbGF0ZUluZm8uY29udGVudCkgfHwgdGVtcGxhdGUuY29udGVudDtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDbG9uZXMgdGhlIHByb3ZpZGVkIHRlbXBsYXRlIGNvbnRlbnQgYW5kIHJldHVybnMgYSBkb2N1bWVudCBmcmFnbWVudFxuICAgICAgICogY29udGFpbmluZyB0aGUgY2xvbmVkIGRvbS5cbiAgICAgICAqXG4gICAgICAgKiBUaGUgdGVtcGxhdGUgaXMgcGFyc2VkIChvbmNlIGFuZCBtZW1vaXplZCkgdXNpbmcgdGhpcyBsaWJyYXJ5J3NcbiAgICAgICAqIHRlbXBsYXRlIHBhcnNpbmcgZmVhdHVyZXMsIGFuZCBwcm92aWRlcyB0aGUgZm9sbG93aW5nIHZhbHVlLWFkZGVkXG4gICAgICAgKiBmZWF0dXJlczpcbiAgICAgICAqICogQWRkcyBkZWNsYXJhdGl2ZSBldmVudCBsaXN0ZW5lcnMgZm9yIGBvbi1ldmVudD1cImhhbmRsZXJcImAgYXR0cmlidXRlc1xuICAgICAgICogKiBHZW5lcmF0ZXMgYW4gXCJpZCBtYXBcIiBmb3IgYWxsIG5vZGVzIHdpdGggaWQncyB1bmRlciBgJGAgb24gcmV0dXJuZWRcbiAgICAgICAqICAgZG9jdW1lbnQgZnJhZ21lbnRcbiAgICAgICAqICogUGFzc2VzIHRlbXBsYXRlIGluZm8gaW5jbHVkaW5nIGBjb250ZW50YCBiYWNrIHRvIHRlbXBsYXRlcyBhc1xuICAgICAgICogICBgX3RlbXBsYXRlSW5mb2AgKGEgcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uIHRvIGF2b2lkIGRlZXAgdGVtcGxhdGVcbiAgICAgICAqICAgY2xvbmluZylcbiAgICAgICAqXG4gICAgICAgKiBOb3RlIHRoYXQgdGhlIG1lbW9pemVkIHRlbXBsYXRlIHBhcnNpbmcgcHJvY2VzcyBpcyBkZXN0cnVjdGl2ZSB0byB0aGVcbiAgICAgICAqIHRlbXBsYXRlOiBhdHRyaWJ1dGVzIGZvciBiaW5kaW5ncyBhbmQgZGVjbGFyYXRpdmUgZXZlbnQgbGlzdGVuZXJzIGFyZVxuICAgICAgICogcmVtb3ZlZCBhZnRlciBiZWluZyBub3RlZCBpbiBub3RlcywgYW5kIGFueSBuZXN0ZWQgYDx0ZW1wbGF0ZT4uY29udGVudGBcbiAgICAgICAqIGlzIHJlbW92ZWQgYW5kIHN0b3JlZCBpbiBub3RlcyBhcyB3ZWxsLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7IUhUTUxUZW1wbGF0ZUVsZW1lbnR9IHRlbXBsYXRlIFRlbXBsYXRlIHRvIHN0YW1wXG4gICAgICAgKiBAcmV0dXJuIHshU3RhbXBlZFRlbXBsYXRlfSBDbG9uZWQgdGVtcGxhdGUgY29udGVudFxuICAgICAgICovXG4gICAgICBfc3RhbXBUZW1wbGF0ZSh0ZW1wbGF0ZSkge1xuICAgICAgICAvLyBQb2x5ZmlsbCBzdXBwb3J0OiBib290c3RyYXAgdGhlIHRlbXBsYXRlIGlmIGl0IGhhcyBub3QgYWxyZWFkeSBiZWVuXG4gICAgICAgIGlmICh0ZW1wbGF0ZSAmJiAhdGVtcGxhdGUuY29udGVudCAmJlxuICAgICAgICAgICAgd2luZG93LkhUTUxUZW1wbGF0ZUVsZW1lbnQgJiYgSFRNTFRlbXBsYXRlRWxlbWVudC5kZWNvcmF0ZSkge1xuICAgICAgICAgIEhUTUxUZW1wbGF0ZUVsZW1lbnQuZGVjb3JhdGUodGVtcGxhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0ZW1wbGF0ZUluZm8gPSB0aGlzLmNvbnN0cnVjdG9yLl9wYXJzZVRlbXBsYXRlKHRlbXBsYXRlKTtcbiAgICAgICAgbGV0IG5vZGVJbmZvID0gdGVtcGxhdGVJbmZvLm5vZGVJbmZvTGlzdDtcbiAgICAgICAgbGV0IGNvbnRlbnQgPSB0ZW1wbGF0ZUluZm8uY29udGVudCB8fCB0ZW1wbGF0ZS5jb250ZW50O1xuICAgICAgICBsZXQgZG9tID0gLyoqIEB0eXBlIERvY3VtZW50RnJhZ21lbnQgKi8gKGRvY3VtZW50LmltcG9ydE5vZGUoY29udGVudCwgdHJ1ZSkpO1xuICAgICAgICAvLyBOT1RFOiBTaGFkeURvbSBvcHRpbWl6YXRpb24gaW5kaWNhdGluZyB0aGVyZSBpcyBhbiBpbnNlcnRpb24gcG9pbnRcbiAgICAgICAgZG9tLl9fbm9JbnNlcnRpb25Qb2ludCA9ICF0ZW1wbGF0ZUluZm8uaGFzSW5zZXJ0aW9uUG9pbnQ7XG4gICAgICAgIGxldCBub2RlcyA9IGRvbS5ub2RlTGlzdCA9IG5ldyBBcnJheShub2RlSW5mby5sZW5ndGgpO1xuICAgICAgICBkb20uJCA9IHt9O1xuICAgICAgICBmb3IgKGxldCBpPTAsIGw9bm9kZUluZm8ubGVuZ3RoLCBpbmZvOyAoaTxsKSAmJiAoaW5mbz1ub2RlSW5mb1tpXSk7IGkrKykge1xuICAgICAgICAgIGxldCBub2RlID0gbm9kZXNbaV0gPSBmaW5kVGVtcGxhdGVOb2RlKGRvbSwgaW5mbyk7XG4gICAgICAgICAgYXBwbHlJZFRvTWFwKHRoaXMsIGRvbS4kLCBub2RlLCBpbmZvKTtcbiAgICAgICAgICBhcHBseVRlbXBsYXRlQ29udGVudCh0aGlzLCBub2RlLCBpbmZvKTtcbiAgICAgICAgICBhcHBseUV2ZW50TGlzdGVuZXIodGhpcywgbm9kZSwgaW5mbyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC8qKiBAdHlwZSB7IVN0YW1wZWRUZW1wbGF0ZX0gKi8oZG9tKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBBZGRzIGFuIGV2ZW50IGxpc3RlbmVyIGJ5IG1ldGhvZCBuYW1lIGZvciB0aGUgZXZlbnQgcHJvdmlkZWQuXG4gICAgICAgKlxuICAgICAgICogVGhpcyBtZXRob2QgZ2VuZXJhdGVzIGEgaGFuZGxlciBmdW5jdGlvbiB0aGF0IGxvb2tzIHVwIHRoZSBtZXRob2RcbiAgICAgICAqIG5hbWUgYXQgaGFuZGxpbmcgdGltZS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgTm9kZSB0byBhZGQgbGlzdGVuZXIgb25cbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgTmFtZSBvZiBldmVudFxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZE5hbWUgTmFtZSBvZiBtZXRob2RcbiAgICAgICAqIEBwYXJhbSB7Kj19IGNvbnRleHQgQ29udGV4dCB0aGUgbWV0aG9kIHdpbGwgYmUgY2FsbGVkIG9uIChkZWZhdWx0c1xuICAgICAgICogICB0byBgbm9kZWApXG4gICAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gR2VuZXJhdGVkIGhhbmRsZXIgZnVuY3Rpb25cbiAgICAgICAqL1xuICAgICAgX2FkZE1ldGhvZEV2ZW50TGlzdGVuZXJUb05vZGUobm9kZSwgZXZlbnROYW1lLCBtZXRob2ROYW1lLCBjb250ZXh0KSB7XG4gICAgICAgIGNvbnRleHQgPSBjb250ZXh0IHx8IG5vZGU7XG4gICAgICAgIGxldCBoYW5kbGVyID0gY3JlYXRlTm9kZUV2ZW50SGFuZGxlcihjb250ZXh0LCBldmVudE5hbWUsIG1ldGhvZE5hbWUpO1xuICAgICAgICB0aGlzLl9hZGRFdmVudExpc3RlbmVyVG9Ob2RlKG5vZGUsIGV2ZW50TmFtZSwgaGFuZGxlcik7XG4gICAgICAgIHJldHVybiBoYW5kbGVyO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIE92ZXJyaWRlIHBvaW50IGZvciBhZGRpbmcgY3VzdG9tIG9yIHNpbXVsYXRlZCBldmVudCBoYW5kbGluZy5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgTm9kZSB0byBhZGQgZXZlbnQgbGlzdGVuZXIgdG9cbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgTmFtZSBvZiBldmVudFxuICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciBMaXN0ZW5lciBmdW5jdGlvbiB0byBhZGRcbiAgICAgICAqL1xuICAgICAgX2FkZEV2ZW50TGlzdGVuZXJUb05vZGUobm9kZSwgZXZlbnROYW1lLCBoYW5kbGVyKSB7XG4gICAgICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGhhbmRsZXIpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIE92ZXJyaWRlIHBvaW50IGZvciBhZGRpbmcgY3VzdG9tIG9yIHNpbXVsYXRlZCBldmVudCBoYW5kbGluZy5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgTm9kZSB0byByZW1vdmUgZXZlbnQgbGlzdGVuZXIgZnJvbVxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBOYW1lIG9mIGV2ZW50XG4gICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIExpc3RlbmVyIGZ1bmN0aW9uIHRvIHJlbW92ZVxuICAgICAgICovXG4gICAgICBfcmVtb3ZlRXZlbnRMaXN0ZW5lckZyb21Ob2RlKG5vZGUsIGV2ZW50TmFtZSwgaGFuZGxlcikge1xuICAgICAgICBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBoYW5kbGVyKTtcbiAgICAgIH1cblxuICAgIH1cblxuICAgIHJldHVybiBUZW1wbGF0ZVN0YW1wO1xuXG4gIH0pO1xuXG59KSgpO1xuPC9zY3JpcHQ+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL3BvbHltZXIvbGliL21peGlucy90ZW1wbGF0ZS1zdGFtcC5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNSBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuXG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vLi4vcG9seW1lci9wb2x5bWVyLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi8uLi9pcm9uLWZsZXgtbGF5b3V0L2lyb24tZmxleC1sYXlvdXQuaHRtbFwiPlxuXG48IS0tXG5hcHAtZHJhd2VyIGlzIGEgbmF2aWdhdGlvbiBkcmF3ZXIgdGhhdCBjYW4gc2xpZGUgaW4gZnJvbSB0aGUgbGVmdCBvciByaWdodC5cblxuRXhhbXBsZTpcblxuQWxpZ24gdGhlIGRyYXdlciBhdCB0aGUgc3RhcnQsIHdoaWNoIGlzIGxlZnQgaW4gTFRSIGxheW91dHMgKGRlZmF1bHQpOlxuXG5gYGBodG1sXG48YXBwLWRyYXdlciBvcGVuZWQ+PC9hcHAtZHJhd2VyPlxuYGBgXG5cbkFsaWduIHRoZSBkcmF3ZXIgYXQgdGhlIGVuZDpcblxuYGBgaHRtbFxuPGFwcC1kcmF3ZXIgYWxpZ249XCJlbmRcIiBvcGVuZWQ+PC9hcHAtZHJhd2VyPlxuYGBgXG5cblRvIG1ha2UgdGhlIGNvbnRlbnRzIG9mIHRoZSBkcmF3ZXIgc2Nyb2xsYWJsZSwgY3JlYXRlIGEgd3JhcHBlciBmb3IgdGhlIHNjcm9sbFxuY29udGVudCwgYW5kIGFwcGx5IGhlaWdodCBhbmQgb3ZlcmZsb3cgc3R5bGVzIHRvIGl0LlxuXG5gYGBodG1sXG48YXBwLWRyYXdlcj5cbiAgPGRpdiBzdHlsZT1cImhlaWdodDogMTAwJTsgb3ZlcmZsb3c6IGF1dG87XCI+PC9kaXY+XG48L2FwcC1kcmF3ZXI+XG5gYGBcblxuIyMjIFN0eWxpbmdcblxuQ3VzdG9tIHByb3BlcnR5ICAgICAgICAgICAgICAgICAgfCBEZXNjcmlwdGlvbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IERlZmF1bHRcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfC0tLS0tLS0tLS0tLS0tLS0tLS0tXG5gLS1hcHAtZHJhd2VyLXdpZHRoYCAgICAgICAgICAgICB8IFdpZHRoIG9mIHRoZSBkcmF3ZXIgICAgICAgICAgICAgICAgICAgIHwgMjU2cHhcbmAtLWFwcC1kcmF3ZXItY29udGVudC1jb250YWluZXJgIHwgTWl4aW4gZm9yIHRoZSBkcmF3ZXIgY29udGVudCBjb250YWluZXIgfCB7fVxuYC0tYXBwLWRyYXdlci1zY3JpbS1iYWNrZ3JvdW5kYCAgfCBCYWNrZ3JvdW5kIGZvciB0aGUgc2NyaW0gICAgICAgICAgICAgICB8IHJnYmEoMCwgMCwgMCwgMC41KVxuXG4qKk5PVEU6KiogSWYgeW91IHVzZSA8YXBwLWRyYXdlcj4gd2l0aCA8YXBwLWRyYXdlci1sYXlvdXQ+IGFuZCBzcGVjaWZ5IGEgdmFsdWUgZm9yXG5gLS1hcHAtZHJhd2VyLXdpZHRoYCwgdGhhdCB2YWx1ZSBtdXN0IGJlIGFjY2Vzc2libGUgYnkgYm90aCBlbGVtZW50cy4gVGhpcyBjYW4gYmUgZG9uZSBieVxuZGVmaW5pbmcgdGhlIHZhbHVlIG9uIHRoZSBgOmhvc3RgIHRoYXQgY29udGFpbnMgPGFwcC1kcmF3ZXItbGF5b3V0PiAob3IgYGh0bWxgIGlmIG91dHNpZGVcbmEgc2hhZG93IHJvb3QpOlxuXG5gYGBjc3Ncbjpob3N0IHtcbiAgLS1hcHAtZHJhd2VyLXdpZHRoOiAzMDBweDtcbn1cbmBgYFxuXG5AZ3JvdXAgQXBwIEVsZW1lbnRzXG5AZWxlbWVudCBhcHAtZHJhd2VyXG5AZGVtbyBhcHAtZHJhd2VyL2RlbW8vbGVmdC1kcmF3ZXIuaHRtbCBTaW1wbGUgTGVmdCBEcmF3ZXJcbkBkZW1vIGFwcC1kcmF3ZXIvZGVtby9yaWdodC1kcmF3ZXIuaHRtbCBSaWdodCBEcmF3ZXIgd2l0aCBJY29uc1xuLS0+XG5cbjxkb20tbW9kdWxlIGlkPVwiYXBwLWRyYXdlclwiPlxuICA8dGVtcGxhdGU+XG4gICAgPHN0eWxlPlxuICAgICAgOmhvc3Qge1xuICAgICAgICBwb3NpdGlvbjogZml4ZWQ7XG4gICAgICAgIHRvcDogLTEyMHB4O1xuICAgICAgICByaWdodDogMDtcbiAgICAgICAgYm90dG9tOiAtMTIwcHg7XG4gICAgICAgIGxlZnQ6IDA7XG5cbiAgICAgICAgdmlzaWJpbGl0eTogaGlkZGVuO1xuXG4gICAgICAgIHRyYW5zaXRpb24tcHJvcGVydHk6IHZpc2liaWxpdHk7XG4gICAgICB9XG5cbiAgICAgIDpob3N0KFtvcGVuZWRdKSB7XG4gICAgICAgIHZpc2liaWxpdHk6IHZpc2libGU7XG4gICAgICB9XG5cbiAgICAgIDpob3N0KFtwZXJzaXN0ZW50XSkge1xuICAgICAgICB3aWR0aDogdmFyKC0tYXBwLWRyYXdlci13aWR0aCwgMjU2cHgpO1xuICAgICAgfVxuXG4gICAgICA6aG9zdChbcGVyc2lzdGVudF1bcG9zaXRpb249bGVmdF0pIHtcbiAgICAgICAgcmlnaHQ6IGF1dG87XG4gICAgICB9XG5cbiAgICAgIDpob3N0KFtwZXJzaXN0ZW50XVtwb3NpdGlvbj1yaWdodF0pIHtcbiAgICAgICAgbGVmdDogYXV0bztcbiAgICAgIH1cblxuICAgICAgI2NvbnRlbnRDb250YWluZXIge1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIHRvcDogMDtcbiAgICAgICAgYm90dG9tOiAwO1xuICAgICAgICBsZWZ0OiAwO1xuXG4gICAgICAgIHdpZHRoOiB2YXIoLS1hcHAtZHJhd2VyLXdpZHRoLCAyNTZweCk7XG4gICAgICAgIHBhZGRpbmc6IDEyMHB4IDA7XG5cbiAgICAgICAgdHJhbnNpdGlvbi1wcm9wZXJ0eTogLXdlYmtpdC10cmFuc2Zvcm07XG4gICAgICAgIHRyYW5zaXRpb24tcHJvcGVydHk6IHRyYW5zZm9ybTtcbiAgICAgICAgLXdlYmtpdC10cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKC0xMDAlLCAwLCAwKTtcbiAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgtMTAwJSwgMCwgMCk7XG5cbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogI0ZGRjtcblxuICAgICAgICBAYXBwbHkgLS1hcHAtZHJhd2VyLWNvbnRlbnQtY29udGFpbmVyO1xuICAgICAgfVxuXG4gICAgICAjY29udGVudENvbnRhaW5lcltwZXJzaXN0ZW50XSB7XG4gICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgfVxuXG4gICAgICAjY29udGVudENvbnRhaW5lcltwb3NpdGlvbj1yaWdodF0ge1xuICAgICAgICByaWdodDogMDtcbiAgICAgICAgbGVmdDogYXV0bztcblxuICAgICAgICAtd2Via2l0LXRyYW5zZm9ybTogdHJhbnNsYXRlM2QoMTAwJSwgMCwgMCk7XG4gICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoMTAwJSwgMCwgMCk7XG4gICAgICB9XG5cbiAgICAgICNjb250ZW50Q29udGFpbmVyW3N3aXBlLW9wZW5dOjphZnRlciB7XG4gICAgICAgIHBvc2l0aW9uOiBmaXhlZDtcbiAgICAgICAgdG9wOiAwO1xuICAgICAgICBib3R0b206IDA7XG4gICAgICAgIGxlZnQ6IDEwMCU7XG5cbiAgICAgICAgdmlzaWJpbGl0eTogdmlzaWJsZTtcblxuICAgICAgICB3aWR0aDogMjBweDtcblxuICAgICAgICBjb250ZW50OiAnJztcbiAgICAgIH1cblxuICAgICAgI2NvbnRlbnRDb250YWluZXJbc3dpcGUtb3Blbl1bcG9zaXRpb249cmlnaHRdOjphZnRlciB7XG4gICAgICAgIHJpZ2h0OiAxMDAlO1xuICAgICAgICBsZWZ0OiBhdXRvO1xuICAgICAgfVxuXG4gICAgICAjY29udGVudENvbnRhaW5lcltvcGVuZWRdIHtcbiAgICAgICAgLXdlYmtpdC10cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKDAsIDAsIDApO1xuICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKDAsIDAsIDApO1xuICAgICAgfVxuXG4gICAgICAjc2NyaW0ge1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIHRvcDogMDtcbiAgICAgICAgcmlnaHQ6IDA7XG4gICAgICAgIGJvdHRvbTogMDtcbiAgICAgICAgbGVmdDogMDtcblxuICAgICAgICB0cmFuc2l0aW9uLXByb3BlcnR5OiBvcGFjaXR5O1xuICAgICAgICAtd2Via2l0LXRyYW5zZm9ybTogdHJhbnNsYXRlWigwKTtcbiAgICAgICAgdHJhbnNmb3JtOiAgdHJhbnNsYXRlWigwKTtcblxuICAgICAgICBvcGFjaXR5OiAwO1xuICAgICAgICBiYWNrZ3JvdW5kOiB2YXIoLS1hcHAtZHJhd2VyLXNjcmltLWJhY2tncm91bmQsIHJnYmEoMCwgMCwgMCwgMC41KSk7XG4gICAgICB9XG5cbiAgICAgICNzY3JpbS52aXNpYmxlIHtcbiAgICAgICAgb3BhY2l0eTogMTtcbiAgICAgIH1cblxuICAgICAgOmhvc3QoW25vLXRyYW5zaXRpb25dKSAjY29udGVudENvbnRhaW5lciB7XG4gICAgICAgIHRyYW5zaXRpb24tcHJvcGVydHk6IG5vbmU7XG4gICAgICB9XG4gICAgPC9zdHlsZT5cblxuICAgIDxkaXYgaWQ9XCJzY3JpbVwiIG9uLWNsaWNrPVwiY2xvc2VcIj48L2Rpdj5cblxuICAgIDwhLS0gSEFDSyhrZWFudWxlZSk6IEJpbmQgYXR0cmlidXRlcyBoZXJlIChpbiBhZGRpdGlvbiB0byA6aG9zdCkgZm9yIHN0eWxpbmcgdG8gd29ya2Fyb3VuZCBTYWZhcmlcbiAgICBidWcuIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xNzA3NjIgLS0+XG4gICAgPGRpdiBpZD1cImNvbnRlbnRDb250YWluZXJcIiBvcGVuZWQkPVwiW1tvcGVuZWRdXVwiIHBlcnNpc3RlbnQkPVwiW1twZXJzaXN0ZW50XV1cIlxuICAgICAgICBwb3NpdGlvbiQ9XCJbW3Bvc2l0aW9uXV1cIiBzd2lwZS1vcGVuJD1cIltbc3dpcGVPcGVuXV1cIj5cbiAgICAgIDxzbG90Pjwvc2xvdD5cbiAgICA8L2Rpdj5cbiAgPC90ZW1wbGF0ZT5cblxuICA8c2NyaXB0PlxuXG4gICAgUG9seW1lcih7XG4gICAgICBpczogJ2FwcC1kcmF3ZXInLFxuXG4gICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgb3BlbmVkIHN0YXRlIG9mIHRoZSBkcmF3ZXIuXG4gICAgICAgICAqL1xuICAgICAgICBvcGVuZWQ6IHtcbiAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgIHZhbHVlOiBmYWxzZSxcbiAgICAgICAgICBub3RpZnk6IHRydWUsXG4gICAgICAgICAgcmVmbGVjdFRvQXR0cmlidXRlOiB0cnVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBkcmF3ZXIgZG9lcyBub3QgaGF2ZSBhIHNjcmltIGFuZCBjYW5ub3QgYmUgc3dpcGVkIGNsb3NlLlxuICAgICAgICAgKi9cbiAgICAgICAgcGVyc2lzdGVudDoge1xuICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgICAgdmFsdWU6IGZhbHNlLFxuICAgICAgICAgIHJlZmxlY3RUb0F0dHJpYnV0ZTogdHJ1ZVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdHJhbnNpdGlvbiBkdXJhdGlvbiBvZiB0aGUgZHJhd2VyIGluIG1pbGxpc2Vjb25kcy5cbiAgICAgICAgICovXG4gICAgICAgIHRyYW5zaXRpb25EdXJhdGlvbjoge1xuICAgICAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgICAgICB2YWx1ZTogMjAwXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBhbGlnbm1lbnQgb2YgdGhlIGRyYXdlciBvbiB0aGUgc2NyZWVuICgnbGVmdCcsICdyaWdodCcsICdzdGFydCcgb3IgJ2VuZCcpLlxuICAgICAgICAgKiAnc3RhcnQnIGNvbXB1dGVzIHRvIGxlZnQgYW5kICdlbmQnIHRvIHJpZ2h0IGluIExUUiBsYXlvdXQgYW5kIHZpY2UgdmVyc2EgaW4gUlRMXG4gICAgICAgICAqIGxheW91dC5cbiAgICAgICAgICovXG4gICAgICAgIGFsaWduOiB7XG4gICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgIHZhbHVlOiAnbGVmdCdcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGNvbXB1dGVkLCByZWFkLW9ubHkgcG9zaXRpb24gb2YgdGhlIGRyYXdlciBvbiB0aGUgc2NyZWVuICgnbGVmdCcgb3IgJ3JpZ2h0JykuXG4gICAgICAgICAqL1xuICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICByZWFkT25seTogdHJ1ZSxcbiAgICAgICAgICByZWZsZWN0VG9BdHRyaWJ1dGU6IHRydWVcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGFuIGFyZWEgYXQgdGhlIGVkZ2Ugb2YgdGhlIHNjcmVlbiB0byBzd2lwZSBvcGVuIHRoZSBkcmF3ZXIuXG4gICAgICAgICAqL1xuICAgICAgICBzd2lwZU9wZW46IHtcbiAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgIHZhbHVlOiBmYWxzZSxcbiAgICAgICAgICByZWZsZWN0VG9BdHRyaWJ1dGU6IHRydWVcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVHJhcCBrZXlib2FyZCBmb2N1cyB3aGVuIHRoZSBkcmF3ZXIgaXMgb3BlbmVkIGFuZCBub3QgcGVyc2lzdGVudC5cbiAgICAgICAgICovXG4gICAgICAgIG5vRm9jdXNUcmFwOiB7XG4gICAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGlzYWJsZXMgc3dpcGluZyBvbiB0aGUgZHJhd2VyLlxuICAgICAgICAgKi9cbiAgICAgICAgZGlzYWJsZVN3aXBlOiB7XG4gICAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgb2JzZXJ2ZXJzOiBbXG4gICAgICAgICdyZXNldExheW91dChwb3NpdGlvbiwgaXNBdHRhY2hlZCknLFxuICAgICAgICAnX3Jlc2V0UG9zaXRpb24oYWxpZ24sIGlzQXR0YWNoZWQpJyxcbiAgICAgICAgJ19zdHlsZVRyYW5zaXRpb25EdXJhdGlvbih0cmFuc2l0aW9uRHVyYXRpb24pJyxcbiAgICAgICAgJ19vcGVuZWRQZXJzaXN0ZW50Q2hhbmdlZChvcGVuZWQsIHBlcnNpc3RlbnQpJ1xuICAgICAgXSxcblxuICAgICAgX3RyYW5zbGF0ZU9mZnNldDogMCxcblxuICAgICAgX3RyYWNrRGV0YWlsczogbnVsbCxcblxuICAgICAgX2RyYXdlclN0YXRlOiAwLFxuXG4gICAgICBfYm91bmRFc2NLZXlkb3duSGFuZGxlcjogbnVsbCxcblxuICAgICAgX2ZpcnN0VGFiU3RvcDogbnVsbCxcblxuICAgICAgX2xhc3RUYWJTdG9wOiBudWxsLFxuXG4gICAgICBhdHRhY2hlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIFBvbHltZXIuUmVuZGVyU3RhdHVzLmFmdGVyTmV4dFJlbmRlcih0aGlzLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICB0aGlzLl9ib3VuZEVzY0tleWRvd25IYW5kbGVyID0gdGhpcy5fZXNjS2V5ZG93bkhhbmRsZXIuYmluZCh0aGlzKTtcbiAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLl90YWJLZXlkb3duSGFuZGxlci5iaW5kKHRoaXMpKVxuXG4gICAgICAgICAgLy8gT25seSBsaXN0ZW4gZm9yIGhvcml6b250YWwgdHJhY2sgc28geW91IGNhbiB2ZXJ0aWNhbGx5IHNjcm9sbCBpbnNpZGUgdGhlIGRyYXdlci5cbiAgICAgICAgICB0aGlzLmxpc3Rlbih0aGlzLCAndHJhY2snLCAnX3RyYWNrJyk7XG4gICAgICAgICAgdGhpcy5zZXRTY3JvbGxEaXJlY3Rpb24oJ3knKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5maXJlKCdhcHAtcmVzZXQtbGF5b3V0Jyk7XG4gICAgICB9LFxuXG4gICAgICBkZXRhY2hlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLl9ib3VuZEVzY0tleWRvd25IYW5kbGVyKTtcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogT3BlbnMgdGhlIGRyYXdlci5cbiAgICAgICAqL1xuICAgICAgb3BlbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMub3BlbmVkID0gdHJ1ZTtcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogQ2xvc2VzIHRoZSBkcmF3ZXIuXG4gICAgICAgKi9cbiAgICAgIGNsb3NlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5vcGVuZWQgPSBmYWxzZTtcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogVG9nZ2xlcyB0aGUgZHJhd2VyIG9wZW4gYW5kIGNsb3NlLlxuICAgICAgICovXG4gICAgICB0b2dnbGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLm9wZW5lZCA9ICF0aGlzLm9wZW5lZDtcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogR2V0cyB0aGUgd2lkdGggb2YgdGhlIGRyYXdlci5cbiAgICAgICAqXG4gICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSB3aWR0aCBvZiB0aGUgZHJhd2VyIGluIHBpeGVscy5cbiAgICAgICAqL1xuICAgICAgZ2V0V2lkdGg6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2F2ZWRXaWR0aCB8fCB0aGlzLiQuY29udGVudENvbnRhaW5lci5vZmZzZXRXaWR0aDtcbiAgICAgIH0sXG5cbiAgICAgIF9pc1JUTDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzKS5kaXJlY3Rpb24gPT09ICdydGwnO1xuICAgICAgfSxcblxuICAgICAgX3Jlc2V0UG9zaXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMuYWxpZ24pIHtcbiAgICAgICAgICBjYXNlICdzdGFydCc6XG4gICAgICAgICAgICB0aGlzLl9zZXRQb3NpdGlvbih0aGlzLl9pc1JUTCgpID8gJ3JpZ2h0JyA6ICdsZWZ0Jyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgY2FzZSAnZW5kJzpcbiAgICAgICAgICAgIHRoaXMuX3NldFBvc2l0aW9uKHRoaXMuX2lzUlRMKCkgPyAnbGVmdCcgOiAncmlnaHQnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zZXRQb3NpdGlvbih0aGlzLmFsaWduKTtcbiAgICAgIH0sXG5cbiAgICAgIF9lc2NLZXlkb3duSGFuZGxlcjogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgdmFyIEVTQ19LRVlDT0RFID0gMjc7XG4gICAgICAgIGlmIChldmVudC5rZXlDb2RlID09PSBFU0NfS0VZQ09ERSkge1xuICAgICAgICAgIC8vIFByZXZlbnQgYW55IHNpZGUgZWZmZWN0cyBpZiBhcHAtZHJhd2VyIGNsb3Nlcy5cbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgX3RyYWNrOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICBpZiAodGhpcy5wZXJzaXN0ZW50IHx8IHRoaXMuZGlzYWJsZVN3aXBlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGlzYWJsZSB1c2VyIHNlbGVjdGlvbiBvbiBkZXNrdG9wLlxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIHN3aXRjaCAoZXZlbnQuZGV0YWlsLnN0YXRlKSB7XG4gICAgICAgICAgY2FzZSAnc3RhcnQnOlxuICAgICAgICAgICAgdGhpcy5fdHJhY2tTdGFydChldmVudCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICd0cmFjayc6XG4gICAgICAgICAgICB0aGlzLl90cmFja01vdmUoZXZlbnQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnZW5kJzpcbiAgICAgICAgICAgIHRoaXMuX3RyYWNrRW5kKGV2ZW50KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBfdHJhY2tTdGFydDogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgdGhpcy5fZHJhd2VyU3RhdGUgPSB0aGlzLl9EUkFXRVJfU1RBVEUuVFJBQ0tJTkc7XG5cbiAgICAgICAgdmFyIHJlY3QgPSB0aGlzLiQuY29udGVudENvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgdGhpcy5fc2F2ZWRXaWR0aCA9IHJlY3Qud2lkdGg7XG4gICAgICAgIGlmICh0aGlzLnBvc2l0aW9uID09PSAnbGVmdCcpIHtcbiAgICAgICAgICB0aGlzLl90cmFuc2xhdGVPZmZzZXQgPSByZWN0LmxlZnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fdHJhbnNsYXRlT2Zmc2V0ID0gcmVjdC5yaWdodCAtIHdpbmRvdy5pbm5lcldpZHRoO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fdHJhY2tEZXRhaWxzID0gW107XG5cbiAgICAgICAgLy8gRGlzYWJsZSB0cmFuc2l0aW9ucyBzaW5jZSBzdHlsZSBhdHRyaWJ1dGVzIHdpbGwgcmVmbGVjdCB1c2VyIHRyYWNrIGV2ZW50cy5cbiAgICAgICAgdGhpcy5fc3R5bGVUcmFuc2l0aW9uRHVyYXRpb24oMCk7XG4gICAgICAgIHRoaXMuc3R5bGUudmlzaWJpbGl0eSA9ICd2aXNpYmxlJztcbiAgICAgIH0sXG5cbiAgICAgIF90cmFja01vdmU6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuX3RyYW5zbGF0ZURyYXdlcihldmVudC5kZXRhaWwuZHggKyB0aGlzLl90cmFuc2xhdGVPZmZzZXQpO1xuXG4gICAgICAgIC8vIFVzZSBEYXRlLm5vdygpIHNpbmNlIGV2ZW50LnRpbWVTdGFtcCBpcyBpbmNvbnNpc3RlbnQgYWNyb3NzIGJyb3dzZXJzIChlLmcuIG1vc3RcbiAgICAgICAgLy8gYnJvd3NlcnMgdXNlIG1pbGxpc2Vjb25kcyBidXQgRkYgNDQgdXNlcyBtaWNyb3NlY29uZHMpLlxuICAgICAgICB0aGlzLl90cmFja0RldGFpbHMucHVzaCh7XG4gICAgICAgICAgZHg6IGV2ZW50LmRldGFpbC5keCxcbiAgICAgICAgICB0aW1lU3RhbXA6IERhdGUubm93KClcbiAgICAgICAgfSk7XG4gICAgICB9LFxuXG4gICAgICBfdHJhY2tFbmQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIHZhciB4ID0gZXZlbnQuZGV0YWlsLmR4ICsgdGhpcy5fdHJhbnNsYXRlT2Zmc2V0O1xuICAgICAgICB2YXIgZHJhd2VyV2lkdGggPSB0aGlzLmdldFdpZHRoKCk7XG4gICAgICAgIHZhciBpc1Bvc2l0aW9uTGVmdCA9IHRoaXMucG9zaXRpb24gPT09ICdsZWZ0JztcbiAgICAgICAgdmFyIGlzSW5FbmRTdGF0ZSA9IGlzUG9zaXRpb25MZWZ0ID8gKHggPj0gMCB8fCB4IDw9IC1kcmF3ZXJXaWR0aCkgOlxuICAgICAgICAgICh4IDw9IDAgfHwgeCA+PSBkcmF3ZXJXaWR0aCk7XG5cbiAgICAgICAgaWYgKCFpc0luRW5kU3RhdGUpIHtcbiAgICAgICAgICAvLyBObyBsb25nZXIgbmVlZCB0aGUgdHJhY2sgZXZlbnRzIGFmdGVyIHRoaXMgbWV0aG9kIHJldHVybnMgLSBhbGxvdyB0aGVtIHRvIGJlIEdDJ2QuXG4gICAgICAgICAgdmFyIHRyYWNrRGV0YWlscyA9IHRoaXMuX3RyYWNrRGV0YWlscztcbiAgICAgICAgICB0aGlzLl90cmFja0RldGFpbHMgPSBudWxsO1xuXG4gICAgICAgICAgdGhpcy5fZmxpbmdEcmF3ZXIoZXZlbnQsIHRyYWNrRGV0YWlscyk7XG4gICAgICAgICAgaWYgKHRoaXMuX2RyYXdlclN0YXRlID09PSB0aGlzLl9EUkFXRVJfU1RBVEUuRkxJTkdJTkcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGUgZHJhd2VyIGlzIG5vdCBmbGluZ2luZywgdG9nZ2xlIHRoZSBvcGVuZWQgc3RhdGUgYmFzZWQgb24gdGhlIHBvc2l0aW9uIG9mXG4gICAgICAgIC8vIHRoZSBkcmF3ZXIuXG4gICAgICAgIHZhciBoYWxmV2lkdGggPSBkcmF3ZXJXaWR0aCAvIDI7XG4gICAgICAgIGlmIChldmVudC5kZXRhaWwuZHggPCAtaGFsZldpZHRoKSB7XG4gICAgICAgICAgdGhpcy5vcGVuZWQgPSB0aGlzLnBvc2l0aW9uID09PSAncmlnaHQnO1xuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50LmRldGFpbC5keCA+IGhhbGZXaWR0aCkge1xuICAgICAgICAgIHRoaXMub3BlbmVkID0gdGhpcy5wb3NpdGlvbiA9PT0gJ2xlZnQnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzSW5FbmRTdGF0ZSkge1xuICAgICAgICAgIHRoaXMuZGVib3VuY2UoJ19yZXNldERyYXdlclN0YXRlJywgdGhpcy5fcmVzZXREcmF3ZXJTdGF0ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5kZWJvdW5jZSgnX3Jlc2V0RHJhd2VyU3RhdGUnLCB0aGlzLl9yZXNldERyYXdlclN0YXRlLCB0aGlzLnRyYW5zaXRpb25EdXJhdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9zdHlsZVRyYW5zaXRpb25EdXJhdGlvbih0aGlzLnRyYW5zaXRpb25EdXJhdGlvbik7XG4gICAgICAgIHRoaXMuX3Jlc2V0RHJhd2VyVHJhbnNsYXRlKCk7XG4gICAgICAgIHRoaXMuc3R5bGUudmlzaWJpbGl0eSA9ICcnO1xuICAgICAgfSxcblxuICAgICAgX2NhbGN1bGF0ZVZlbG9jaXR5OiBmdW5jdGlvbihldmVudCwgdHJhY2tEZXRhaWxzKSB7XG4gICAgICAgIC8vIEZpbmQgdGhlIG9sZGVzdCB0cmFjayBldmVudCB0aGF0IGlzIHdpdGhpbiAxMDBtcyB1c2luZyBiaW5hcnkgc2VhcmNoLlxuICAgICAgICB2YXIgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdmFyIHRpbWVMb3dlckJvdW5kID0gbm93IC0gMTAwO1xuICAgICAgICB2YXIgdHJhY2tEZXRhaWw7XG4gICAgICAgIHZhciBtaW4gPSAwO1xuICAgICAgICB2YXIgbWF4ID0gdHJhY2tEZXRhaWxzLmxlbmd0aCAtIDE7XG5cbiAgICAgICAgd2hpbGUgKG1pbiA8PSBtYXgpIHtcbiAgICAgICAgICAvLyBGbG9vciBvZiBhdmVyYWdlIG9mIG1pbiBhbmQgbWF4LlxuICAgICAgICAgIHZhciBtaWQgPSAobWluICsgbWF4KSA+PiAxO1xuICAgICAgICAgIHZhciBkID0gdHJhY2tEZXRhaWxzW21pZF07XG4gICAgICAgICAgaWYgKGQudGltZVN0YW1wID49IHRpbWVMb3dlckJvdW5kKSB7XG4gICAgICAgICAgICB0cmFja0RldGFpbCA9IGQ7XG4gICAgICAgICAgICBtYXggPSBtaWQgLSAxO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtaW4gPSBtaWQgKyAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0cmFja0RldGFpbCkge1xuICAgICAgICAgIHZhciBkeCA9IGV2ZW50LmRldGFpbC5keCAtIHRyYWNrRGV0YWlsLmR4O1xuICAgICAgICAgIHZhciBkdCA9IChub3cgLSB0cmFja0RldGFpbC50aW1lU3RhbXApIHx8IDE7XG4gICAgICAgICAgcmV0dXJuIGR4IC8gZHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9LFxuXG4gICAgICBfZmxpbmdEcmF3ZXI6IGZ1bmN0aW9uKGV2ZW50LCB0cmFja0RldGFpbHMpIHtcbiAgICAgICAgdmFyIHZlbG9jaXR5ID0gdGhpcy5fY2FsY3VsYXRlVmVsb2NpdHkoZXZlbnQsIHRyYWNrRGV0YWlscyk7XG5cbiAgICAgICAgLy8gRG8gbm90IGZsaW5nIGlmIHZlbG9jaXR5IGlzIG5vdCBhYm92ZSBhIHRocmVzaG9sZC5cbiAgICAgICAgaWYgKE1hdGguYWJzKHZlbG9jaXR5KSA8IHRoaXMuX01JTl9GTElOR19USFJFU0hPTEQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9kcmF3ZXJTdGF0ZSA9IHRoaXMuX0RSQVdFUl9TVEFURS5GTElOR0lORztcblxuICAgICAgICB2YXIgeCA9IGV2ZW50LmRldGFpbC5keCArIHRoaXMuX3RyYW5zbGF0ZU9mZnNldDtcbiAgICAgICAgdmFyIGRyYXdlcldpZHRoID0gdGhpcy5nZXRXaWR0aCgpO1xuICAgICAgICB2YXIgaXNQb3NpdGlvbkxlZnQgPSB0aGlzLnBvc2l0aW9uID09PSAnbGVmdCc7XG4gICAgICAgIHZhciBpc1ZlbG9jaXR5UG9zaXRpdmUgPSB2ZWxvY2l0eSA+IDA7XG4gICAgICAgIHZhciBpc0Nsb3NpbmdMZWZ0ID0gIWlzVmVsb2NpdHlQb3NpdGl2ZSAmJiBpc1Bvc2l0aW9uTGVmdDtcbiAgICAgICAgdmFyIGlzQ2xvc2luZ1JpZ2h0ID0gaXNWZWxvY2l0eVBvc2l0aXZlICYmICFpc1Bvc2l0aW9uTGVmdDtcbiAgICAgICAgdmFyIGR4O1xuICAgICAgICBpZiAoaXNDbG9zaW5nTGVmdCkge1xuICAgICAgICAgIGR4ID0gLSh4ICsgZHJhd2VyV2lkdGgpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzQ2xvc2luZ1JpZ2h0KSB7XG4gICAgICAgICAgZHggPSAoZHJhd2VyV2lkdGggLSB4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkeCA9IC14O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRW5mb3JjZSBhIG1pbmltdW0gdHJhbnNpdGlvbiB2ZWxvY2l0eSB0byBtYWtlIHRoZSBkcmF3ZXIgZmVlbCBzbmFwcHkuXG4gICAgICAgIGlmIChpc1ZlbG9jaXR5UG9zaXRpdmUpIHtcbiAgICAgICAgICB2ZWxvY2l0eSA9IE1hdGgubWF4KHZlbG9jaXR5LCB0aGlzLl9NSU5fVFJBTlNJVElPTl9WRUxPQ0lUWSk7XG4gICAgICAgICAgdGhpcy5vcGVuZWQgPSB0aGlzLnBvc2l0aW9uID09PSAnbGVmdCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmVsb2NpdHkgPSBNYXRoLm1pbih2ZWxvY2l0eSwgLXRoaXMuX01JTl9UUkFOU0lUSU9OX1ZFTE9DSVRZKTtcbiAgICAgICAgICB0aGlzLm9wZW5lZCA9IHRoaXMucG9zaXRpb24gPT09ICdyaWdodCc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIGFtb3VudCBvZiB0aW1lIG5lZWRlZCB0byBmaW5pc2ggdGhlIHRyYW5zaXRpb24gYmFzZWQgb24gdGhlXG4gICAgICAgIC8vIGluaXRpYWwgc2xvcGUgb2YgdGhlIHRpbWluZyBmdW5jdGlvbi5cbiAgICAgICAgdmFyIHQgPSB0aGlzLl9GTElOR19JTklUSUFMX1NMT1BFICogZHggLyB2ZWxvY2l0eVxuICAgICAgICB0aGlzLl9zdHlsZVRyYW5zaXRpb25EdXJhdGlvbih0KTtcbiAgICAgICAgdGhpcy5fc3R5bGVUcmFuc2l0aW9uVGltaW5nRnVuY3Rpb24odGhpcy5fRkxJTkdfVElNSU5HX0ZVTkNUSU9OKTtcblxuICAgICAgICB0aGlzLl9yZXNldERyYXdlclRyYW5zbGF0ZSgpO1xuICAgICAgICB0aGlzLmRlYm91bmNlKCdfcmVzZXREcmF3ZXJTdGF0ZScsIHRoaXMuX3Jlc2V0RHJhd2VyU3RhdGUsIHQpO1xuICAgICAgfSxcblxuICAgICAgX3N0eWxlVHJhbnNpdGlvbkR1cmF0aW9uOiBmdW5jdGlvbihkdXJhdGlvbikge1xuICAgICAgICB0aGlzLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9IGR1cmF0aW9uICsgJ21zJztcbiAgICAgICAgdGhpcy4kLmNvbnRlbnRDb250YWluZXIuc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID0gZHVyYXRpb24gKyAnbXMnO1xuICAgICAgICB0aGlzLiQuc2NyaW0uc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID0gZHVyYXRpb24gKyAnbXMnO1xuICAgICAgfSxcblxuICAgICAgX3N0eWxlVHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uOiBmdW5jdGlvbih0aW1pbmdGdW5jdGlvbikge1xuICAgICAgICB0aGlzLiQuY29udGVudENvbnRhaW5lci5zdHlsZS50cmFuc2l0aW9uVGltaW5nRnVuY3Rpb24gPSB0aW1pbmdGdW5jdGlvbjtcbiAgICAgICAgdGhpcy4kLnNjcmltLnN0eWxlLnRyYW5zaXRpb25UaW1pbmdGdW5jdGlvbiA9IHRpbWluZ0Z1bmN0aW9uO1xuICAgICAgfSxcblxuICAgICAgX3RyYW5zbGF0ZURyYXdlcjogZnVuY3Rpb24oeCkge1xuICAgICAgICB2YXIgZHJhd2VyV2lkdGggPSB0aGlzLmdldFdpZHRoKCk7XG5cbiAgICAgICAgaWYgKHRoaXMucG9zaXRpb24gPT09ICdsZWZ0Jykge1xuICAgICAgICAgIHggPSBNYXRoLm1heCgtZHJhd2VyV2lkdGgsIE1hdGgubWluKHgsIDApKTtcbiAgICAgICAgICB0aGlzLiQuc2NyaW0uc3R5bGUub3BhY2l0eSA9IDEgKyB4IC8gZHJhd2VyV2lkdGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgeCA9IE1hdGgubWF4KDAsIE1hdGgubWluKHgsIGRyYXdlcldpZHRoKSk7XG4gICAgICAgICAgdGhpcy4kLnNjcmltLnN0eWxlLm9wYWNpdHkgPSAxIC0geCAvIGRyYXdlcldpZHRoO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy50cmFuc2xhdGUzZCh4ICsgJ3B4JywgJzAnLCAnMCcsIHRoaXMuJC5jb250ZW50Q29udGFpbmVyKTtcbiAgICAgIH0sXG5cbiAgICAgIF9yZXNldERyYXdlclRyYW5zbGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuJC5zY3JpbS5zdHlsZS5vcGFjaXR5ID0gJyc7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtKCcnLCB0aGlzLiQuY29udGVudENvbnRhaW5lcik7XG4gICAgICB9LFxuXG4gICAgICBfcmVzZXREcmF3ZXJTdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBvbGRTdGF0ZSA9IHRoaXMuX2RyYXdlclN0YXRlO1xuXG4gICAgICAgIC8vIElmIHRoZSBkcmF3ZXIgd2FzIGZsaW5naW5nLCB3ZSBuZWVkIHRvIHJlc2V0IHRoZSBzdHlsZSBhdHRyaWJ1dGVzLlxuICAgICAgICBpZiAob2xkU3RhdGUgPT09IHRoaXMuX0RSQVdFUl9TVEFURS5GTElOR0lORykge1xuICAgICAgICAgIHRoaXMuX3N0eWxlVHJhbnNpdGlvbkR1cmF0aW9uKHRoaXMudHJhbnNpdGlvbkR1cmF0aW9uKTtcbiAgICAgICAgICB0aGlzLl9zdHlsZVRyYW5zaXRpb25UaW1pbmdGdW5jdGlvbignJyk7XG4gICAgICAgICAgdGhpcy5zdHlsZS52aXNpYmlsaXR5ID0gJyc7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9zYXZlZFdpZHRoID0gbnVsbDtcblxuICAgICAgICBpZiAodGhpcy5vcGVuZWQpIHtcbiAgICAgICAgICB0aGlzLl9kcmF3ZXJTdGF0ZSA9IHRoaXMucGVyc2lzdGVudCA/XG4gICAgICAgICAgICB0aGlzLl9EUkFXRVJfU1RBVEUuT1BFTkVEX1BFUlNJU1RFTlQgOiB0aGlzLl9EUkFXRVJfU1RBVEUuT1BFTkVEO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX2RyYXdlclN0YXRlID0gdGhpcy5fRFJBV0VSX1NUQVRFLkNMT1NFRDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvbGRTdGF0ZSAhPT0gdGhpcy5fZHJhd2VyU3RhdGUpIHtcbiAgICAgICAgICBpZiAodGhpcy5fZHJhd2VyU3RhdGUgPT09IHRoaXMuX0RSQVdFUl9TVEFURS5PUEVORUQpIHtcbiAgICAgICAgICAgIHRoaXMuX3NldEtleWJvYXJkRm9jdXNUcmFwKCk7XG4gICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5fYm91bmRFc2NLZXlkb3duSGFuZGxlcik7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LnN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLl9ib3VuZEVzY0tleWRvd25IYW5kbGVyKTtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuc3R5bGUub3ZlcmZsb3cgPSAnJztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBEb24ndCBmaXJlIHRoZSBldmVudCBvbiBpbml0aWFsIGxvYWQuXG4gICAgICAgICAgaWYgKG9sZFN0YXRlICE9PSB0aGlzLl9EUkFXRVJfU1RBVEUuSU5JVCkge1xuICAgICAgICAgICAgdGhpcy5maXJlKCdhcHAtZHJhd2VyLXRyYW5zaXRpb25lZCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBSZXNldHMgdGhlIGxheW91dC5cbiAgICAgICAqXG4gICAgICAgKiBAbWV0aG9kIHJlc2V0TGF5b3V0XG4gICAgICAgKi9cbiAgICAgIHJlc2V0TGF5b3V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5maXJlKCdhcHAtcmVzZXQtbGF5b3V0Jyk7XG4gICAgICB9LFxuXG4gICAgICBfc2V0S2V5Ym9hcmRGb2N1c1RyYXA6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5ub0ZvY3VzVHJhcCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE5PVEU6IFVubGVzcyB3ZSB1c2UgL2RlZXAvICh3aGljaCB3ZSBzaG91bGRuJ3Qgc2luY2UgaXQncyBkZXByZWNhdGVkKSwgdGhpcyB3aWxsXG4gICAgICAgIC8vIG5vdCBzZWxlY3QgZm9jdXNhYmxlIGVsZW1lbnRzIGluc2lkZSBzaGFkb3cgcm9vdHMuXG4gICAgICAgIHZhciBmb2N1c2FibGVFbGVtZW50c1NlbGVjdG9yID0gW1xuICAgICAgICAgICAgJ2FbaHJlZl06bm90KFt0YWJpbmRleD1cIi0xXCJdKScsXG4gICAgICAgICAgICAnYXJlYVtocmVmXTpub3QoW3RhYmluZGV4PVwiLTFcIl0pJyxcbiAgICAgICAgICAgICdpbnB1dDpub3QoW2Rpc2FibGVkXSk6bm90KFt0YWJpbmRleD1cIi0xXCJdKScsXG4gICAgICAgICAgICAnc2VsZWN0Om5vdChbZGlzYWJsZWRdKTpub3QoW3RhYmluZGV4PVwiLTFcIl0pJyxcbiAgICAgICAgICAgICd0ZXh0YXJlYTpub3QoW2Rpc2FibGVkXSk6bm90KFt0YWJpbmRleD1cIi0xXCJdKScsXG4gICAgICAgICAgICAnYnV0dG9uOm5vdChbZGlzYWJsZWRdKTpub3QoW3RhYmluZGV4PVwiLTFcIl0pJyxcbiAgICAgICAgICAgICdpZnJhbWU6bm90KFt0YWJpbmRleD1cIi0xXCJdKScsXG4gICAgICAgICAgICAnW3RhYmluZGV4XTpub3QoW3RhYmluZGV4PVwiLTFcIl0pJyxcbiAgICAgICAgICAgICdbY29udGVudEVkaXRhYmxlPXRydWVdOm5vdChbdGFiaW5kZXg9XCItMVwiXSknXG4gICAgICAgICAgXS5qb2luKCcsJyk7XG4gICAgICAgIHZhciBmb2N1c2FibGVFbGVtZW50cyA9IFBvbHltZXIuZG9tKHRoaXMpLnF1ZXJ5U2VsZWN0b3JBbGwoZm9jdXNhYmxlRWxlbWVudHNTZWxlY3Rvcik7XG5cbiAgICAgICAgaWYgKGZvY3VzYWJsZUVsZW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB0aGlzLl9maXJzdFRhYlN0b3AgPSBmb2N1c2FibGVFbGVtZW50c1swXTtcbiAgICAgICAgICB0aGlzLl9sYXN0VGFiU3RvcCA9IGZvY3VzYWJsZUVsZW1lbnRzW2ZvY3VzYWJsZUVsZW1lbnRzLmxlbmd0aCAtIDFdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFJlc2V0IHNhdmVkIHRhYiBzdG9wcyB3aGVuIHRoZXJlIGFyZSBubyBmb2N1c2FibGUgZWxlbWVudHMgaW4gdGhlIGRyYXdlci5cbiAgICAgICAgICB0aGlzLl9maXJzdFRhYlN0b3AgPSBudWxsO1xuICAgICAgICAgIHRoaXMuX2xhc3RUYWJTdG9wID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZvY3VzIG9uIGFwcC1kcmF3ZXIgaWYgaXQgaGFzIG5vbi16ZXJvIHRhYmluZGV4LiBPdGhlcndpc2UsIGZvY3VzIHRoZSBmaXJzdCBmb2N1c2FibGVcbiAgICAgICAgLy8gZWxlbWVudCBpbiB0aGUgZHJhd2VyLCBpZiBpdCBleGlzdHMuIFVzZSB0aGUgdGFiaW5kZXggYXR0cmlidXRlIHNpbmNlIHRoZSB0aGlzLnRhYkluZGV4XG4gICAgICAgIC8vIHByb3BlcnR5IGluIElFL0VkZ2UgcmV0dXJucyAwIChpbnN0ZWFkIG9mIC0xKSB3aGVuIHRoZSBhdHRyaWJ1dGUgaXMgbm90IHNldC5cbiAgICAgICAgdmFyIHRhYmluZGV4ID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3RhYmluZGV4Jyk7XG4gICAgICAgIGlmICh0YWJpbmRleCAmJiBwYXJzZUludCh0YWJpbmRleCwgMTApID4gLTEpIHtcbiAgICAgICAgICB0aGlzLmZvY3VzKCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fZmlyc3RUYWJTdG9wKSB7XG4gICAgICAgICAgdGhpcy5fZmlyc3RUYWJTdG9wLmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIF90YWJLZXlkb3duSGFuZGxlcjogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMubm9Gb2N1c1RyYXApIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgVEFCX0tFWUNPREUgPSA5O1xuICAgICAgICBpZiAodGhpcy5fZHJhd2VyU3RhdGUgPT09IHRoaXMuX0RSQVdFUl9TVEFURS5PUEVORUQgJiYgZXZlbnQua2V5Q29kZSA9PT0gVEFCX0tFWUNPREUpIHtcbiAgICAgICAgICBpZiAoZXZlbnQuc2hpZnRLZXkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9maXJzdFRhYlN0b3AgJiYgUG9seW1lci5kb20oZXZlbnQpLmxvY2FsVGFyZ2V0ID09PSB0aGlzLl9maXJzdFRhYlN0b3ApIHtcbiAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgdGhpcy5fbGFzdFRhYlN0b3AuZm9jdXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2xhc3RUYWJTdG9wICYmIFBvbHltZXIuZG9tKGV2ZW50KS5sb2NhbFRhcmdldCA9PT0gdGhpcy5fbGFzdFRhYlN0b3ApIHtcbiAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgdGhpcy5fZmlyc3RUYWJTdG9wLmZvY3VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBfb3BlbmVkUGVyc2lzdGVudENoYW5nZWQ6IGZ1bmN0aW9uKG9wZW5lZCwgcGVyc2lzdGVudCkge1xuICAgICAgICB0aGlzLnRvZ2dsZUNsYXNzKCd2aXNpYmxlJywgb3BlbmVkICYmICFwZXJzaXN0ZW50LCB0aGlzLiQuc2NyaW0pO1xuXG4gICAgICAgIC8vIFVzZSBhIGRlYm91bmNlIHRpbWVyIGluc3RlYWQgb2YgdHJhbnNpdGlvbmVuZCBzaW5jZSB0cmFuc2l0aW9uZW5kIHdvbid0IGZpcmUgd2hlblxuICAgICAgICAvLyBhcHAtZHJhd2VyIGlzIGRpc3BsYXk6IG5vbmUuXG4gICAgICAgIHRoaXMuZGVib3VuY2UoJ19yZXNldERyYXdlclN0YXRlJywgdGhpcy5fcmVzZXREcmF3ZXJTdGF0ZSwgdGhpcy50cmFuc2l0aW9uRHVyYXRpb24pO1xuICAgICAgfSxcblxuICAgICAgX01JTl9GTElOR19USFJFU0hPTEQ6IDAuMixcblxuICAgICAgX01JTl9UUkFOU0lUSU9OX1ZFTE9DSVRZOiAxLjIsXG5cbiAgICAgIF9GTElOR19USU1JTkdfRlVOQ1RJT046ICdjdWJpYy1iZXppZXIoMC42NjcsIDEsIDAuNjY3LCAxKScsXG5cbiAgICAgIF9GTElOR19JTklUSUFMX1NMT1BFOiAxLjUsXG5cbiAgICAgIF9EUkFXRVJfU1RBVEU6IHtcbiAgICAgICAgSU5JVDogMCxcbiAgICAgICAgT1BFTkVEOiAxLFxuICAgICAgICBPUEVORURfUEVSU0lTVEVOVDogMixcbiAgICAgICAgQ0xPU0VEOiAzLFxuICAgICAgICBUUkFDS0lORzogNCxcbiAgICAgICAgRkxJTkdJTkc6IDVcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBGaXJlZCB3aGVuIHRoZSBsYXlvdXQgb2YgYXBwLWRyYXdlciBoYXMgY2hhbmdlZC5cbiAgICAgICAqXG4gICAgICAgKiBAZXZlbnQgYXBwLXJlc2V0LWxheW91dFxuICAgICAgICovXG5cbiAgICAgIC8qKlxuICAgICAgICogRmlyZWQgd2hlbiBhcHAtZHJhd2VyIGhhcyBmaW5pc2hlZCB0cmFuc2l0aW9uaW5nLlxuICAgICAgICpcbiAgICAgICAqIEBldmVudCBhcHAtZHJhd2VyLXRyYW5zaXRpb25lZFxuICAgICAgICovXG4gICAgfSk7XG4gIDwvc2NyaXB0PlxuPC9kb20tbW9kdWxlPlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9hcHAtbGF5b3V0L2FwcC1kcmF3ZXIvYXBwLWRyYXdlci5odG1sIiwiXG5yZXF1aXJlKCcuL2FwcGx5LXNoaW0ubWluLmpzJyk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL3NoYWR5Y3NzL2FwcGx5LXNoaW0uaHRtbCIsIihmdW5jdGlvbigpey8qXG5cbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiovXG4ndXNlIHN0cmljdCc7dmFyIGs9e307ZnVuY3Rpb24gbigpe3RoaXMuZW5kPXRoaXMuc3RhcnQ9MDt0aGlzLnJ1bGVzPXRoaXMucGFyZW50PXRoaXMucHJldmlvdXM9bnVsbDt0aGlzLmNzc1RleHQ9dGhpcy5wYXJzZWRDc3NUZXh0PVwiXCI7dGhpcy5hdFJ1bGU9ITE7dGhpcy50eXBlPTA7dGhpcy5wYXJzZWRTZWxlY3Rvcj10aGlzLnNlbGVjdG9yPXRoaXMua2V5ZnJhbWVzTmFtZT1cIlwifVxuZnVuY3Rpb24gcChhKXthPWEucmVwbGFjZShhYSxcIlwiKS5yZXBsYWNlKGJhLFwiXCIpO3ZhciBiPXEsYz1hLGQ9bmV3IG47ZC5zdGFydD0wO2QuZW5kPWMubGVuZ3RoO2Zvcih2YXIgZT1kLGY9MCxoPWMubGVuZ3RoO2Y8aDtmKyspaWYoXCJ7XCI9PT1jW2ZdKXtlLnJ1bGVzfHwoZS5ydWxlcz1bXSk7dmFyIGc9ZSxtPWcucnVsZXNbZy5ydWxlcy5sZW5ndGgtMV18fG51bGw7ZT1uZXcgbjtlLnN0YXJ0PWYrMTtlLnBhcmVudD1nO2UucHJldmlvdXM9bTtnLnJ1bGVzLnB1c2goZSl9ZWxzZVwifVwiPT09Y1tmXSYmKGUuZW5kPWYrMSxlPWUucGFyZW50fHxkKTtyZXR1cm4gYihkLGEpfVxuZnVuY3Rpb24gcShhLGIpe3ZhciBjPWIuc3Vic3RyaW5nKGEuc3RhcnQsYS5lbmQtMSk7YS5wYXJzZWRDc3NUZXh0PWEuY3NzVGV4dD1jLnRyaW0oKTthLnBhcmVudCYmKGM9Yi5zdWJzdHJpbmcoYS5wcmV2aW91cz9hLnByZXZpb3VzLmVuZDphLnBhcmVudC5zdGFydCxhLnN0YXJ0LTEpLGM9Y2EoYyksYz1jLnJlcGxhY2UocixcIiBcIiksYz1jLnN1YnN0cmluZyhjLmxhc3RJbmRleE9mKFwiO1wiKSsxKSxjPWEucGFyc2VkU2VsZWN0b3I9YS5zZWxlY3Rvcj1jLnRyaW0oKSxhLmF0UnVsZT0wPT09Yy5pbmRleE9mKFwiQFwiKSxhLmF0UnVsZT8wPT09Yy5pbmRleE9mKFwiQG1lZGlhXCIpP2EudHlwZT10OmMubWF0Y2goZGEpJiYoYS50eXBlPXUsYS5rZXlmcmFtZXNOYW1lPWEuc2VsZWN0b3Iuc3BsaXQocikucG9wKCkpOmEudHlwZT0wPT09Yy5pbmRleE9mKFwiLS1cIik/djp4KTtpZihjPWEucnVsZXMpZm9yKHZhciBkPTAsZT1jLmxlbmd0aCxmO2Q8ZSYmKGY9Y1tkXSk7ZCsrKXEoZixiKTtyZXR1cm4gYX1cbmZ1bmN0aW9uIGNhKGEpe3JldHVybiBhLnJlcGxhY2UoL1xcXFwoWzAtOWEtZl17MSw2fSlcXHMvZ2ksZnVuY3Rpb24oYSxjKXthPWM7Zm9yKGM9Ni1hLmxlbmd0aDtjLS07KWE9XCIwXCIrYTtyZXR1cm5cIlxcXFxcIithfSl9XG5mdW5jdGlvbiB5KGEsYixjKXtjPXZvaWQgMD09PWM/XCJcIjpjO3ZhciBkPVwiXCI7aWYoYS5jc3NUZXh0fHxhLnJ1bGVzKXt2YXIgZT1hLnJ1bGVzLGY7aWYoZj1lKWY9ZVswXSxmPSEoZiYmZi5zZWxlY3RvciYmMD09PWYuc2VsZWN0b3IuaW5kZXhPZihcIi0tXCIpKTtpZihmKXtmPTA7Zm9yKHZhciBoPWUubGVuZ3RoLGc7ZjxoJiYoZz1lW2ZdKTtmKyspZD15KGcsYixkKX1lbHNlIGI/Yj1hLmNzc1RleHQ6KGI9YS5jc3NUZXh0LGI9Yi5yZXBsYWNlKGVhLFwiXCIpLnJlcGxhY2UoZmEsXCJcIiksYj1iLnJlcGxhY2UoaGEsXCJcIikucmVwbGFjZShpYSxcIlwiKSksKGQ9Yi50cmltKCkpJiYoZD1cIiAgXCIrZCtcIlxcblwiKX1kJiYoYS5zZWxlY3RvciYmKGMrPWEuc2VsZWN0b3IrXCIge1xcblwiKSxjKz1kLGEuc2VsZWN0b3ImJihjKz1cIn1cXG5cXG5cIikpO3JldHVybiBjfVxudmFyIHg9MSx1PTcsdD00LHY9MUUzLGFhPS9cXC9cXCpbXipdKlxcKisoW14vKl1bXipdKlxcKispKlxcLy9naW0sYmE9L0BpbXBvcnRbXjtdKjsvZ2ltLGVhPS8oPzpeW147XFwtXFxzfV0rKT8tLVteO3t9XSo/Oltee307XSo/KD86WztcXG5dfCQpL2dpbSxmYT0vKD86XlteO1xcLVxcc31dKyk/LS1bXjt7fV0qPzpbXnt9O10qP3tbXn1dKj99KD86WztcXG5dfCQpPy9naW0saGE9L0BhcHBseVxccypcXCg/W14pO10qXFwpP1xccyooPzpbO1xcbl18JCk/L2dpbSxpYT0vW147Ol0qPzpbXjtdKj92YXJcXChbXjtdKlxcKSg/Ols7XFxuXXwkKT8vZ2ltLGRhPS9eQFteXFxzXSprZXlmcmFtZXMvLHI9L1xccysvZzt2YXIgamE9UHJvbWlzZS5yZXNvbHZlKCk7ZnVuY3Rpb24ga2EoYSl7aWYoYT1rW2FdKWEuX2FwcGx5U2hpbUN1cnJlbnRWZXJzaW9uPWEuX2FwcGx5U2hpbUN1cnJlbnRWZXJzaW9ufHwwLGEuX2FwcGx5U2hpbVZhbGlkYXRpbmdWZXJzaW9uPWEuX2FwcGx5U2hpbVZhbGlkYXRpbmdWZXJzaW9ufHwwLGEuX2FwcGx5U2hpbU5leHRWZXJzaW9uPShhLl9hcHBseVNoaW1OZXh0VmVyc2lvbnx8MCkrMX1mdW5jdGlvbiB6KGEpe3JldHVybiBhLl9hcHBseVNoaW1DdXJyZW50VmVyc2lvbj09PWEuX2FwcGx5U2hpbU5leHRWZXJzaW9ufWZ1bmN0aW9uIGxhKGEpe2EuX2FwcGx5U2hpbVZhbGlkYXRpbmdWZXJzaW9uPWEuX2FwcGx5U2hpbU5leHRWZXJzaW9uO2EuYXx8KGEuYT0hMCxqYS50aGVuKGZ1bmN0aW9uKCl7YS5fYXBwbHlTaGltQ3VycmVudFZlcnNpb249YS5fYXBwbHlTaGltTmV4dFZlcnNpb247YS5hPSExfSkpfTt2YXIgQT0hKHdpbmRvdy5TaGFkeURPTSYmd2luZG93LlNoYWR5RE9NLmluVXNlKSxCO2Z1bmN0aW9uIEMoYSl7Qj1hJiZhLnNoaW1jc3Nwcm9wZXJ0aWVzPyExOkF8fCEobmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvQXBwbGVXZWJLaXRcXC82MDF8RWRnZVxcLzE1Lyl8fCF3aW5kb3cuQ1NTfHwhQ1NTLnN1cHBvcnRzfHwhQ1NTLnN1cHBvcnRzKFwiYm94LXNoYWRvd1wiLFwiMCAwIDAgdmFyKC0tZm9vKVwiKSl9d2luZG93LlNoYWR5Q1NTJiZ2b2lkIDAhPT13aW5kb3cuU2hhZHlDU1MubmF0aXZlQ3NzP0I9d2luZG93LlNoYWR5Q1NTLm5hdGl2ZUNzczp3aW5kb3cuU2hhZHlDU1M/KEMod2luZG93LlNoYWR5Q1NTKSx3aW5kb3cuU2hhZHlDU1M9dm9pZCAwKTpDKHdpbmRvdy5XZWJDb21wb25lbnRzJiZ3aW5kb3cuV2ViQ29tcG9uZW50cy5mbGFncyk7dmFyIEU9Qjt2YXIgRj0vKD86XnxbO1xcc3tdXFxzKikoLS1bXFx3LV0qPylcXHMqOlxccyooPzooKD86Jyg/OlxcXFwnfC4pKj8nfFwiKD86XFxcXFwifC4pKj9cInxcXChbXildKj9cXCl8W159O3tdKSspfFxceyhbXn1dKilcXH0oPzooPz1bO1xcc31dKXwkKSkvZ2ksRz0vKD86XnxcXFcrKUBhcHBseVxccypcXCg/KFteKTtcXG5dKilcXCk/L2dpLG1hPS9AbWVkaWFcXHMoLiopLztmdW5jdGlvbiBIKGEpe2lmKCFhKXJldHVyblwiXCI7XCJzdHJpbmdcIj09PXR5cGVvZiBhJiYoYT1wKGEpKTtyZXR1cm4geShhLEUpfWZ1bmN0aW9uIEkoYSl7IWEuX19jc3NSdWxlcyYmYS50ZXh0Q29udGVudCYmKGEuX19jc3NSdWxlcz1wKGEudGV4dENvbnRlbnQpKTtyZXR1cm4gYS5fX2Nzc1J1bGVzfHxudWxsfWZ1bmN0aW9uIEooYSxiLGMsZCl7aWYoYSl7dmFyIGU9ITEsZj1hLnR5cGU7aWYoZCYmZj09PXQpe3ZhciBoPWEuc2VsZWN0b3IubWF0Y2gobWEpO2gmJih3aW5kb3cubWF0Y2hNZWRpYShoWzFdKS5tYXRjaGVzfHwoZT0hMCkpfWY9PT14P2IoYSk6YyYmZj09PXU/YyhhKTpmPT09diYmKGU9ITApO2lmKChhPWEucnVsZXMpJiYhZSl7ZT0wO2Y9YS5sZW5ndGg7Zm9yKHZhciBnO2U8ZiYmKGc9YVtlXSk7ZSsrKUooZyxiLGMsZCl9fX1cbmZ1bmN0aW9uIEsoYSxiKXt2YXIgYz1hLmluZGV4T2YoXCJ2YXIoXCIpO2lmKC0xPT09YylyZXR1cm4gYihhLFwiXCIsXCJcIixcIlwiKTthOnt2YXIgZD0wO3ZhciBlPWMrMztmb3IodmFyIGY9YS5sZW5ndGg7ZTxmO2UrKylpZihcIihcIj09PWFbZV0pZCsrO2Vsc2UgaWYoXCIpXCI9PT1hW2VdJiYwPT09LS1kKWJyZWFrIGE7ZT0tMX1kPWEuc3Vic3RyaW5nKGMrNCxlKTtjPWEuc3Vic3RyaW5nKDAsYyk7YT1LKGEuc3Vic3RyaW5nKGUrMSksYik7ZT1kLmluZGV4T2YoXCIsXCIpO3JldHVybi0xPT09ZT9iKGMsZC50cmltKCksXCJcIixhKTpiKGMsZC5zdWJzdHJpbmcoMCxlKS50cmltKCksZC5zdWJzdHJpbmcoZSsxKS50cmltKCksYSl9O3ZhciBuYT0vO1xccyovbSxvYT0vXlxccyooaW5pdGlhbCl8KGluaGVyaXQpXFxzKiQvO2Z1bmN0aW9uIEwoKXt0aGlzLmE9e319TC5wcm90b3R5cGUuc2V0PWZ1bmN0aW9uKGEsYil7YT1hLnRyaW0oKTt0aGlzLmFbYV09e2g6YixpOnt9fX07TC5wcm90b3R5cGUuZ2V0PWZ1bmN0aW9uKGEpe2E9YS50cmltKCk7cmV0dXJuIHRoaXMuYVthXXx8bnVsbH07dmFyIE09bnVsbDtmdW5jdGlvbiBOKCl7dGhpcy5iPXRoaXMuYz1udWxsO3RoaXMuYT1uZXcgTH1OLnByb3RvdHlwZS5vPWZ1bmN0aW9uKGEpe2E9Ry50ZXN0KGEpfHxGLnRlc3QoYSk7Ry5sYXN0SW5kZXg9MDtGLmxhc3RJbmRleD0wO3JldHVybiBhfTtOLnByb3RvdHlwZS5tPWZ1bmN0aW9uKGEsYil7YT1hLmNvbnRlbnQucXVlcnlTZWxlY3RvcihcInN0eWxlXCIpO3ZhciBjPW51bGw7YSYmKGM9dGhpcy5qKGEsYikpO3JldHVybiBjfTtcbk4ucHJvdG90eXBlLmo9ZnVuY3Rpb24oYSxiKXtiPXZvaWQgMD09PWI/XCJcIjpiO3ZhciBjPUkoYSk7dGhpcy5sKGMsYik7YS50ZXh0Q29udGVudD1IKGMpO3JldHVybiBjfTtOLnByb3RvdHlwZS5mPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMsYz1JKGEpO0ooYyxmdW5jdGlvbihhKXtcIjpyb290XCI9PT1hLnNlbGVjdG9yJiYoYS5zZWxlY3Rvcj1cImh0bWxcIik7Yi5nKGEpfSk7YS50ZXh0Q29udGVudD1IKGMpO3JldHVybiBjfTtOLnByb3RvdHlwZS5sPWZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpczt0aGlzLmM9YjtKKGEsZnVuY3Rpb24oYSl7Yy5nKGEpfSk7dGhpcy5jPW51bGx9O04ucHJvdG90eXBlLmc9ZnVuY3Rpb24oYSl7YS5jc3NUZXh0PXBhKHRoaXMsYS5wYXJzZWRDc3NUZXh0KTtcIjpyb290XCI9PT1hLnNlbGVjdG9yJiYoYS5zZWxlY3Rvcj1cIjpob3N0ID4gKlwiKX07XG5mdW5jdGlvbiBwYShhLGIpe2I9Yi5yZXBsYWNlKEYsZnVuY3Rpb24oYixkLGUsZil7cmV0dXJuIHFhKGEsYixkLGUsZil9KTtyZXR1cm4gTyhhLGIpfWZ1bmN0aW9uIE8oYSxiKXtmb3IodmFyIGM7Yz1HLmV4ZWMoYik7KXt2YXIgZD1jWzBdLGU9Y1sxXTtjPWMuaW5kZXg7dmFyIGY9Yi5zbGljZSgwLGMrZC5pbmRleE9mKFwiQGFwcGx5XCIpKTtiPWIuc2xpY2UoYytkLmxlbmd0aCk7dmFyIGg9UChhLGYpO2Q9dm9pZCAwO3ZhciBnPWE7ZT1lLnJlcGxhY2UobmEsXCJcIik7dmFyIG09W107dmFyIGw9Zy5hLmdldChlKTtsfHwoZy5hLnNldChlLHt9KSxsPWcuYS5nZXQoZSkpO2lmKGwpZm9yKGQgaW4gZy5jJiYobC5pW2cuY109ITApLGwuaClnPWgmJmhbZF0sbD1bZCxcIjogdmFyKFwiLGUsXCJfLV9cIixkXSxnJiZsLnB1c2goXCIsXCIsZyksbC5wdXNoKFwiKVwiKSxtLnB1c2gobC5qb2luKFwiXCIpKTtkPW0uam9pbihcIjsgXCIpO2I9XCJcIitmK2QrYjtHLmxhc3RJbmRleD1jK2QubGVuZ3RofXJldHVybiBifVxuZnVuY3Rpb24gUChhLGIpe2I9Yi5zcGxpdChcIjtcIik7Zm9yKHZhciBjLGQsZT17fSxmPTAsaDtmPGIubGVuZ3RoO2YrKylpZihjPWJbZl0paWYoaD1jLnNwbGl0KFwiOlwiKSwxPGgubGVuZ3RoKXtjPWhbMF0udHJpbSgpO3ZhciBnPWE7ZD1jO2g9aC5zbGljZSgxKS5qb2luKFwiOlwiKTt2YXIgbT1vYS5leGVjKGgpO20mJihtWzFdPyhnLmJ8fChnLmI9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIm1ldGFcIiksZy5iLnNldEF0dHJpYnV0ZShcImFwcGx5LXNoaW0tbWVhc3VyZVwiLFwiXCIpLGcuYi5zdHlsZS5hbGw9XCJpbml0aWFsXCIsZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChnLmIpKSxkPXdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGcuYikuZ2V0UHJvcGVydHlWYWx1ZShkKSk6ZD1cImFwcGx5LXNoaW0taW5oZXJpdFwiLGg9ZCk7ZD1oO2VbY109ZH1yZXR1cm4gZX1mdW5jdGlvbiByYShhLGIpe2lmKE0pZm9yKHZhciBjIGluIGIuaSljIT09YS5jJiZNKGMpfVxuZnVuY3Rpb24gcWEoYSxiLGMsZCxlKXtkJiZLKGQsZnVuY3Rpb24oYixjKXtjJiZhLmEuZ2V0KGMpJiYoZT1cIkBhcHBseSBcIitjK1wiO1wiKX0pO2lmKCFlKXJldHVybiBiO3ZhciBmPU8oYSxlKSxoPWIuc2xpY2UoMCxiLmluZGV4T2YoXCItLVwiKSksZz1mPVAoYSxmKSxtPWEuYS5nZXQoYyksbD1tJiZtLmg7bD9nPU9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShsKSxmKTphLmEuc2V0KGMsZyk7dmFyIFg9W10sdyxZPSExO2Zvcih3IGluIGcpe3ZhciBEPWZbd107dm9pZCAwPT09RCYmKEQ9XCJpbml0aWFsXCIpOyFsfHx3IGluIGx8fChZPSEwKTtYLnB1c2goXCJcIitjK1wiXy1fXCIrdytcIjogXCIrRCl9WSYmcmEoYSxtKTttJiYobS5oPWcpO2QmJihoPWIrXCI7XCIraCk7cmV0dXJuXCJcIitoK1guam9pbihcIjsgXCIpK1wiO1wifU4ucHJvdG90eXBlLmRldGVjdE1peGluPU4ucHJvdG90eXBlLm87Ti5wcm90b3R5cGUudHJhbnNmb3JtU3R5bGU9Ti5wcm90b3R5cGUuajtcbk4ucHJvdG90eXBlLnRyYW5zZm9ybUN1c3RvbVN0eWxlPU4ucHJvdG90eXBlLmY7Ti5wcm90b3R5cGUudHJhbnNmb3JtUnVsZXM9Ti5wcm90b3R5cGUubDtOLnByb3RvdHlwZS50cmFuc2Zvcm1SdWxlPU4ucHJvdG90eXBlLmc7Ti5wcm90b3R5cGUudHJhbnNmb3JtVGVtcGxhdGU9Ti5wcm90b3R5cGUubTtOLnByb3RvdHlwZS5fc2VwYXJhdG9yPVwiXy1fXCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KE4ucHJvdG90eXBlLFwiaW52YWxpZENhbGxiYWNrXCIse2dldDpmdW5jdGlvbigpe3JldHVybiBNfSxzZXQ6ZnVuY3Rpb24oYSl7TT1hfX0pO3ZhciBRPW51bGwsUj13aW5kb3cuSFRNTEltcG9ydHMmJndpbmRvdy5IVE1MSW1wb3J0cy53aGVuUmVhZHl8fG51bGwsUztmdW5jdGlvbiBzYShhKXtyZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKXtSP1IoYSk6KFF8fChRPW5ldyBQcm9taXNlKGZ1bmN0aW9uKGEpe1M9YX0pLFwiY29tcGxldGVcIj09PWRvY3VtZW50LnJlYWR5U3RhdGU/UygpOmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJyZWFkeXN0YXRlY2hhbmdlXCIsZnVuY3Rpb24oKXtcImNvbXBsZXRlXCI9PT1kb2N1bWVudC5yZWFkeVN0YXRlJiZTKCl9KSksUS50aGVuKGZ1bmN0aW9uKCl7YSYmYSgpfSkpfSl9O3ZhciBUPW5ldyBOO2Z1bmN0aW9uIFUoKXt2YXIgYT10aGlzO3RoaXMuYT1udWxsO3NhKGZ1bmN0aW9uKCl7VihhKX0pO1QuaW52YWxpZENhbGxiYWNrPWthfWZ1bmN0aW9uIFYoYSl7YS5hfHwoYS5hPXdpbmRvdy5TaGFkeUNTUy5DdXN0b21TdHlsZUludGVyZmFjZSxhLmEmJihhLmEudHJhbnNmb3JtQ2FsbGJhY2s9ZnVuY3Rpb24oYSl7VC5mKGEpfSxhLmEudmFsaWRhdGVDYWxsYmFjaz1mdW5jdGlvbigpe3JlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbigpe2EuYS5lbnF1ZXVlZCYmVyhhKX0pfSkpfVUucHJvdG90eXBlLnByZXBhcmVUZW1wbGF0ZT1mdW5jdGlvbihhLGIpe1YodGhpcyk7a1tiXT1hO2I9VC5tKGEsYik7YS5fc3R5bGVBc3Q9Yn07XG5mdW5jdGlvbiBXKGEpe1YoYSk7aWYoYS5hKXt2YXIgYj1hLmEucHJvY2Vzc1N0eWxlcygpO2lmKGEuYS5lbnF1ZXVlZCl7Zm9yKHZhciBjPTA7YzxiLmxlbmd0aDtjKyspe3ZhciBkPWEuYS5nZXRTdHlsZUZvckN1c3RvbVN0eWxlKGJbY10pO2QmJlQuZihkKX1hLmEuZW5xdWV1ZWQ9ITF9fX1VLnByb3RvdHlwZS5zdHlsZVN1YnRyZWU9ZnVuY3Rpb24oYSxiKXtWKHRoaXMpO2lmKGIpZm9yKHZhciBjIGluIGIpbnVsbD09PWM/YS5zdHlsZS5yZW1vdmVQcm9wZXJ0eShjKTphLnN0eWxlLnNldFByb3BlcnR5KGMsYltjXSk7aWYoYS5zaGFkb3dSb290KWZvcih0aGlzLnN0eWxlRWxlbWVudChhKSxhPWEuc2hhZG93Um9vdC5jaGlsZHJlbnx8YS5zaGFkb3dSb290LmNoaWxkTm9kZXMsYj0wO2I8YS5sZW5ndGg7YisrKXRoaXMuc3R5bGVTdWJ0cmVlKGFbYl0pO2Vsc2UgZm9yKGE9YS5jaGlsZHJlbnx8YS5jaGlsZE5vZGVzLGI9MDtiPGEubGVuZ3RoO2IrKyl0aGlzLnN0eWxlU3VidHJlZShhW2JdKX07XG5VLnByb3RvdHlwZS5zdHlsZUVsZW1lbnQ9ZnVuY3Rpb24oYSl7Vih0aGlzKTt2YXIgYj1hLmxvY2FsTmFtZSxjO2I/LTE8Yi5pbmRleE9mKFwiLVwiKT9jPWI6Yz1hLmdldEF0dHJpYnV0ZSYmYS5nZXRBdHRyaWJ1dGUoXCJpc1wiKXx8XCJcIjpjPWEuaXM7aWYoKGI9a1tjXSkmJiF6KGIpKXtpZih6KGIpfHxiLl9hcHBseVNoaW1WYWxpZGF0aW5nVmVyc2lvbiE9PWIuX2FwcGx5U2hpbU5leHRWZXJzaW9uKXRoaXMucHJlcGFyZVRlbXBsYXRlKGIsYyksbGEoYik7aWYoYT1hLnNoYWRvd1Jvb3QpaWYoYT1hLnF1ZXJ5U2VsZWN0b3IoXCJzdHlsZVwiKSlhLl9fY3NzUnVsZXM9Yi5fc3R5bGVBc3QsYS50ZXh0Q29udGVudD1IKGIuX3N0eWxlQXN0KX19O1UucHJvdG90eXBlLnN0eWxlRG9jdW1lbnQ9ZnVuY3Rpb24oYSl7Vih0aGlzKTt0aGlzLnN0eWxlU3VidHJlZShkb2N1bWVudC5ib2R5LGEpfTtcbmlmKCF3aW5kb3cuU2hhZHlDU1N8fCF3aW5kb3cuU2hhZHlDU1MuU2NvcGluZ1NoaW0pe3ZhciBaPW5ldyBVLHRhPXdpbmRvdy5TaGFkeUNTUyYmd2luZG93LlNoYWR5Q1NTLkN1c3RvbVN0eWxlSW50ZXJmYWNlO3dpbmRvdy5TaGFkeUNTUz17cHJlcGFyZVRlbXBsYXRlOmZ1bmN0aW9uKGEsYil7VyhaKTtaLnByZXBhcmVUZW1wbGF0ZShhLGIpfSxzdHlsZVN1YnRyZWU6ZnVuY3Rpb24oYSxiKXtXKFopO1ouc3R5bGVTdWJ0cmVlKGEsYil9LHN0eWxlRWxlbWVudDpmdW5jdGlvbihhKXtXKFopO1ouc3R5bGVFbGVtZW50KGEpfSxzdHlsZURvY3VtZW50OmZ1bmN0aW9uKGEpe1coWik7Wi5zdHlsZURvY3VtZW50KGEpfSxnZXRDb21wdXRlZFN0eWxlVmFsdWU6ZnVuY3Rpb24oYSxiKXtyZXR1cm4oYT13aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShhKS5nZXRQcm9wZXJ0eVZhbHVlKGIpKT9hLnRyaW0oKTpcIlwifSxuYXRpdmVDc3M6RSxuYXRpdmVTaGFkb3c6QX07dGEmJih3aW5kb3cuU2hhZHlDU1MuQ3VzdG9tU3R5bGVJbnRlcmZhY2U9XG50YSl9d2luZG93LlNoYWR5Q1NTLkFwcGx5U2hpbT1UO30pLmNhbGwodGhpcyk7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFwcGx5LXNoaW0ubWluLmpzLm1hcFxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9zaGFkeWNzcy9hcHBseS1zaGltLm1pbi5qcyIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCJib290Lmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCJhc3luYy5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiZGVib3VuY2UuaHRtbFwiPlxuXG48c2NyaXB0PlxuKGZ1bmN0aW9uKCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICAvLyBkZXRlY3QgbmF0aXZlIHRvdWNoIGFjdGlvbiBzdXBwb3J0XG4gIGxldCBIQVNfTkFUSVZFX1RBID0gdHlwZW9mIGRvY3VtZW50LmhlYWQuc3R5bGUudG91Y2hBY3Rpb24gPT09ICdzdHJpbmcnO1xuICBsZXQgR0VTVFVSRV9LRVkgPSAnX19wb2x5bWVyR2VzdHVyZXMnO1xuICBsZXQgSEFORExFRF9PQkogPSAnX19wb2x5bWVyR2VzdHVyZXNIYW5kbGVkJztcbiAgbGV0IFRPVUNIX0FDVElPTiA9ICdfX3BvbHltZXJHZXN0dXJlc1RvdWNoQWN0aW9uJztcbiAgLy8gcmFkaXVzIGZvciB0YXAgYW5kIHRyYWNrXG4gIGxldCBUQVBfRElTVEFOQ0UgPSAyNTtcbiAgbGV0IFRSQUNLX0RJU1RBTkNFID0gNTtcbiAgLy8gbnVtYmVyIG9mIGxhc3QgTiB0cmFjayBwb3NpdGlvbnMgdG8ga2VlcFxuICBsZXQgVFJBQ0tfTEVOR1RIID0gMjtcblxuICAvLyBEaXNhYmxpbmcgXCJtb3VzZVwiIGhhbmRsZXJzIGZvciAyNTAwbXMgaXMgZW5vdWdoXG4gIGxldCBNT1VTRV9USU1FT1VUID0gMjUwMDtcbiAgbGV0IE1PVVNFX0VWRU5UUyA9IFsnbW91c2Vkb3duJywgJ21vdXNlbW92ZScsICdtb3VzZXVwJywgJ2NsaWNrJ107XG4gIC8vIGFuIGFycmF5IG9mIGJpdG1hc2sgdmFsdWVzIGZvciBtYXBwaW5nIE1vdXNlRXZlbnQud2hpY2ggdG8gTW91c2VFdmVudC5idXR0b25zXG4gIGxldCBNT1VTRV9XSElDSF9UT19CVVRUT05TID0gWzAsIDEsIDQsIDJdO1xuICBsZXQgTU9VU0VfSEFTX0JVVFRPTlMgPSAoZnVuY3Rpb24oKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBuZXcgTW91c2VFdmVudCgndGVzdCcsIHtidXR0b25zOiAxfSkuYnV0dG9ucyA9PT0gMTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9KSgpO1xuXG4gIC8qIGVzbGludCBuby1lbXB0eTogW1wiZXJyb3JcIiwgeyBcImFsbG93RW1wdHlDYXRjaFwiOiB0cnVlIH1dICovXG4gIC8vIGNoZWNrIGZvciBwYXNzaXZlIGV2ZW50IGxpc3RlbmVyc1xuICBsZXQgU1VQUE9SVFNfUEFTU0lWRSA9IGZhbHNlO1xuICAoZnVuY3Rpb24oKSB7XG4gICAgdHJ5IHtcbiAgICAgIGxldCBvcHRzID0gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAncGFzc2l2ZScsIHtnZXQ6IGZ1bmN0aW9uKCkge1NVUFBPUlRTX1BBU1NJVkUgPSB0cnVlO319KVxuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Rlc3QnLCBudWxsLCBvcHRzKTtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCd0ZXN0JywgbnVsbCwgb3B0cyk7XG4gICAgfSBjYXRjaChlKSB7fVxuICB9KSgpO1xuXG4gIC8vIENoZWNrIGZvciB0b3VjaC1vbmx5IGRldmljZXNcbiAgbGV0IElTX1RPVUNIX09OTFkgPSBuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9pUCg/OltvYV1kfGhvbmUpfEFuZHJvaWQvKTtcblxuICBsZXQgR2VzdHVyZVJlY29nbml6ZXIgPSBmdW5jdGlvbigpe307IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgR2VzdHVyZVJlY29nbml6ZXIucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oKXt9O1xuICAvKiogQHR5cGUge2Z1bmN0aW9uKE1vdXNlRXZlbnQpIHwgdW5kZWZpbmVkfSAqL1xuICBHZXN0dXJlUmVjb2duaXplci5wcm90b3R5cGUubW91c2Vkb3duO1xuICAvKiogQHR5cGUgeyhmdW5jdGlvbihNb3VzZUV2ZW50KSB8IHVuZGVmaW5lZCl9ICovXG4gIEdlc3R1cmVSZWNvZ25pemVyLnByb3RvdHlwZS5tb3VzZW1vdmU7XG4gIC8qKiBAdHlwZSB7KGZ1bmN0aW9uKE1vdXNlRXZlbnQpIHwgdW5kZWZpbmVkKX0gKi9cbiAgR2VzdHVyZVJlY29nbml6ZXIucHJvdG90eXBlLm1vdXNldXA7XG4gIC8qKiBAdHlwZSB7KGZ1bmN0aW9uKFRvdWNoRXZlbnQpIHwgdW5kZWZpbmVkKX0gKi9cbiAgR2VzdHVyZVJlY29nbml6ZXIucHJvdG90eXBlLnRvdWNoc3RhcnQ7XG4gIC8qKiBAdHlwZSB7KGZ1bmN0aW9uKFRvdWNoRXZlbnQpIHwgdW5kZWZpbmVkKX0gKi9cbiAgR2VzdHVyZVJlY29nbml6ZXIucHJvdG90eXBlLnRvdWNobW92ZTtcbiAgLyoqIEB0eXBlIHsoZnVuY3Rpb24oVG91Y2hFdmVudCkgfCB1bmRlZmluZWQpfSAqL1xuICBHZXN0dXJlUmVjb2duaXplci5wcm90b3R5cGUudG91Y2hlbmQ7XG4gIC8qKiBAdHlwZSB7KGZ1bmN0aW9uKE1vdXNlRXZlbnQpIHwgdW5kZWZpbmVkKX0gKi9cbiAgR2VzdHVyZVJlY29nbml6ZXIucHJvdG90eXBlLmNsaWNrO1xuXG4gIC8vIHRvdWNoIHdpbGwgbWFrZSBzeW50aGV0aWMgbW91c2UgZXZlbnRzXG4gIC8vIGBwcmV2ZW50RGVmYXVsdGAgb24gdG91Y2hlbmQgd2lsbCBjYW5jZWwgdGhlbSxcbiAgLy8gYnV0IHRoaXMgYnJlYWtzIGA8aW5wdXQ+YCBmb2N1cyBhbmQgbGluayBjbGlja3NcbiAgLy8gZGlzYWJsZSBtb3VzZSBoYW5kbGVycyBmb3IgTU9VU0VfVElNRU9VVCBtcyBhZnRlclxuICAvLyBhIHRvdWNoZW5kIHRvIGlnbm9yZSBzeW50aGV0aWMgbW91c2UgZXZlbnRzXG4gIGxldCBtb3VzZUNhbmNlbGxlciA9IGZ1bmN0aW9uKG1vdXNlRXZlbnQpIHtcbiAgICAvLyBDaGVjayBmb3Igc291cmNlQ2FwYWJpbGl0aWVzLCB1c2VkIHRvIGRpc3Rpbmd1aXNoIHN5bnRoZXRpYyBldmVudHNcbiAgICAvLyBpZiBtb3VzZUV2ZW50IGRpZCBub3QgY29tZSBmcm9tIGEgZGV2aWNlIHRoYXQgZmlyZXMgdG91Y2ggZXZlbnRzLFxuICAgIC8vIGl0IHdhcyBtYWRlIGJ5IGEgcmVhbCBtb3VzZSBhbmQgc2hvdWxkIGJlIGNvdW50ZWRcbiAgICAvLyBodHRwOi8vd2ljZy5naXRodWIuaW8vSW5wdXREZXZpY2VDYXBhYmlsaXRpZXMvI2RvbS1pbnB1dGRldmljZWNhcGFiaWxpdGllcy1maXJlc3RvdWNoZXZlbnRzXG4gICAgbGV0IHNjID0gbW91c2VFdmVudC5zb3VyY2VDYXBhYmlsaXRpZXM7XG4gICAgaWYgKHNjICYmICFzYy5maXJlc1RvdWNoRXZlbnRzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIHNraXAgc3ludGhldGljIG1vdXNlIGV2ZW50c1xuICAgIG1vdXNlRXZlbnRbSEFORExFRF9PQkpdID0ge3NraXA6IHRydWV9O1xuICAgIC8vIGRpc2FibGUgXCJnaG9zdCBjbGlja3NcIlxuICAgIGlmIChtb3VzZUV2ZW50LnR5cGUgPT09ICdjbGljaycpIHtcbiAgICAgIGxldCBwYXRoID0gbW91c2VFdmVudC5jb21wb3NlZFBhdGggJiYgbW91c2VFdmVudC5jb21wb3NlZFBhdGgoKTtcbiAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChwYXRoW2ldID09PSBQT0lOVEVSU1RBVEUubW91c2UudGFyZ2V0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBtb3VzZUV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBtb3VzZUV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtib29sZWFuPX0gc2V0dXAgVHJ1ZSB0byBhZGQsIGZhbHNlIHRvIHJlbW92ZS5cbiAgICovXG4gIGZ1bmN0aW9uIHNldHVwVGVhcmRvd25Nb3VzZUNhbmNlbGxlcihzZXR1cCkge1xuICAgIGxldCBldmVudHMgPSBJU19UT1VDSF9PTkxZID8gWydjbGljayddIDogTU9VU0VfRVZFTlRTO1xuICAgIGZvciAobGV0IGkgPSAwLCBlbjsgaSA8IGV2ZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgZW4gPSBldmVudHNbaV07XG4gICAgICBpZiAoc2V0dXApIHtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihlbiwgbW91c2VDYW5jZWxsZXIsIHRydWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihlbiwgbW91c2VDYW5jZWxsZXIsIHRydWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlnbm9yZU1vdXNlKGUpIHtcbiAgICBpZiAoIVBPSU5URVJTVEFURS5tb3VzZS5tb3VzZUlnbm9yZUpvYikge1xuICAgICAgc2V0dXBUZWFyZG93bk1vdXNlQ2FuY2VsbGVyKHRydWUpO1xuICAgIH1cbiAgICBsZXQgdW5zZXQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHNldHVwVGVhcmRvd25Nb3VzZUNhbmNlbGxlcigpO1xuICAgICAgUE9JTlRFUlNUQVRFLm1vdXNlLnRhcmdldCA9IG51bGw7XG4gICAgICBQT0lOVEVSU1RBVEUubW91c2UubW91c2VJZ25vcmVKb2IgPSBudWxsO1xuICAgIH07XG4gICAgUE9JTlRFUlNUQVRFLm1vdXNlLnRhcmdldCA9IGUuY29tcG9zZWRQYXRoKClbMF07XG4gICAgUE9JTlRFUlNUQVRFLm1vdXNlLm1vdXNlSWdub3JlSm9iID0gUG9seW1lci5EZWJvdW5jZXIuZGVib3VuY2UoXG4gICAgICAgICAgUE9JTlRFUlNUQVRFLm1vdXNlLm1vdXNlSWdub3JlSm9iXG4gICAgICAgICwgUG9seW1lci5Bc3luYy50aW1lT3V0LmFmdGVyKE1PVVNFX1RJTUVPVVQpXG4gICAgICAgICwgdW5zZXQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZXYgZXZlbnQgdG8gdGVzdCBmb3IgbGVmdCBtb3VzZSBidXR0b24gZG93blxuICAgKiBAcmV0dXJuIHtib29sZWFufSBoYXMgbGVmdCBtb3VzZSBidXR0b24gZG93blxuICAgKi9cbiAgZnVuY3Rpb24gaGFzTGVmdE1vdXNlQnV0dG9uKGV2KSB7XG4gICAgbGV0IHR5cGUgPSBldi50eXBlO1xuICAgIC8vIGV4aXQgZWFybHkgaWYgdGhlIGV2ZW50IGlzIG5vdCBhIG1vdXNlIGV2ZW50XG4gICAgaWYgKE1PVVNFX0VWRU5UUy5pbmRleE9mKHR5cGUpID09PSAtMSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBldi5idXR0b24gaXMgbm90IHJlbGlhYmxlIGZvciBtb3VzZW1vdmUgKDAgaXMgb3ZlcmxvYWRlZCBhcyBib3RoIGxlZnQgYnV0dG9uIGFuZCBubyBidXR0b25zKVxuICAgIC8vIGluc3RlYWQgd2UgdXNlIGV2LmJ1dHRvbnMgKGJpdG1hc2sgb2YgYnV0dG9ucykgb3IgZmFsbCBiYWNrIHRvIGV2LndoaWNoIChkZXByZWNhdGVkLCAwIGZvciBubyBidXR0b25zLCAxIGZvciBsZWZ0IGJ1dHRvbilcbiAgICBpZiAodHlwZSA9PT0gJ21vdXNlbW92ZScpIHtcbiAgICAgIC8vIGFsbG93IHVuZGVmaW5lZCBmb3IgdGVzdGluZyBldmVudHNcbiAgICAgIGxldCBidXR0b25zID0gZXYuYnV0dG9ucyA9PT0gdW5kZWZpbmVkID8gMSA6IGV2LmJ1dHRvbnM7XG4gICAgICBpZiAoKGV2IGluc3RhbmNlb2Ygd2luZG93Lk1vdXNlRXZlbnQpICYmICFNT1VTRV9IQVNfQlVUVE9OUykge1xuICAgICAgICBidXR0b25zID0gTU9VU0VfV0hJQ0hfVE9fQlVUVE9OU1tldi53aGljaF0gfHwgMDtcbiAgICAgIH1cbiAgICAgIC8vIGJ1dHRvbnMgaXMgYSBiaXRtYXNrLCBjaGVjayB0aGF0IHRoZSBsZWZ0IGJ1dHRvbiBiaXQgaXMgc2V0ICgxKVxuICAgICAgcmV0dXJuIEJvb2xlYW4oYnV0dG9ucyAmIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBhbGxvdyB1bmRlZmluZWQgZm9yIHRlc3RpbmcgZXZlbnRzXG4gICAgICBsZXQgYnV0dG9uID0gZXYuYnV0dG9uID09PSB1bmRlZmluZWQgPyAwIDogZXYuYnV0dG9uO1xuICAgICAgLy8gZXYuYnV0dG9uIGlzIDAgaW4gbW91c2Vkb3duL21vdXNldXAvY2xpY2sgZm9yIGxlZnQgYnV0dG9uIGFjdGl2YXRpb25cbiAgICAgIHJldHVybiBidXR0b24gPT09IDA7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNTeW50aGV0aWNDbGljayhldikge1xuICAgIGlmIChldi50eXBlID09PSAnY2xpY2snKSB7XG4gICAgICAvLyBldi5kZXRhaWwgaXMgMCBmb3IgSFRNTEVsZW1lbnQuY2xpY2sgaW4gbW9zdCBicm93c2Vyc1xuICAgICAgaWYgKGV2LmRldGFpbCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIC8vIGluIHRoZSB3b3JzdCBjYXNlLCBjaGVjayB0aGF0IHRoZSB4L3kgcG9zaXRpb24gb2YgdGhlIGNsaWNrIGlzIHdpdGhpblxuICAgICAgLy8gdGhlIGJvdW5kaW5nIGJveCBvZiB0aGUgdGFyZ2V0IG9mIHRoZSBldmVudFxuICAgICAgLy8gVGhhbmtzIElFIDEwID46KFxuICAgICAgbGV0IHQgPSBHZXN0dXJlcy5fZmluZE9yaWdpbmFsVGFyZ2V0KGV2KTtcbiAgICAgIC8vIG1ha2Ugc3VyZSB0aGUgdGFyZ2V0IG9mIHRoZSBldmVudCBpcyBhbiBlbGVtZW50IHNvIHdlIGNhbiB1c2UgZ2V0Qm91bmRpbmdDbGllbnRSZWN0LFxuICAgICAgLy8gaWYgbm90LCBqdXN0IGFzc3VtZSBpdCBpcyBhIHN5bnRoZXRpYyBjbGlja1xuICAgICAgaWYgKCF0Lm5vZGVUeXBlIHx8IC8qKiBAdHlwZSB7RWxlbWVudH0gKi8odCkubm9kZVR5cGUgIT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgbGV0IGJjciA9IC8qKiBAdHlwZSB7RWxlbWVudH0gKi8odCkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAvLyB1c2UgcGFnZSB4L3kgdG8gYWNjb3VudCBmb3Igc2Nyb2xsaW5nXG4gICAgICBsZXQgeCA9IGV2LnBhZ2VYLCB5ID0gZXYucGFnZVk7XG4gICAgICAvLyBldiBpcyBhIHN5bnRoZXRpYyBjbGljayBpZiB0aGUgcG9zaXRpb24gaXMgb3V0c2lkZSB0aGUgYm91bmRpbmcgYm94IG9mIHRoZSB0YXJnZXRcbiAgICAgIHJldHVybiAhKCh4ID49IGJjci5sZWZ0ICYmIHggPD0gYmNyLnJpZ2h0KSAmJiAoeSA+PSBiY3IudG9wICYmIHkgPD0gYmNyLmJvdHRvbSkpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBsZXQgUE9JTlRFUlNUQVRFID0ge1xuICAgIG1vdXNlOiB7XG4gICAgICB0YXJnZXQ6IG51bGwsXG4gICAgICBtb3VzZUlnbm9yZUpvYjogbnVsbFxuICAgIH0sXG4gICAgdG91Y2g6IHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwLFxuICAgICAgaWQ6IC0xLFxuICAgICAgc2Nyb2xsRGVjaWRlZDogZmFsc2VcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gZmlyc3RUb3VjaEFjdGlvbihldikge1xuICAgIGxldCB0YSA9ICdhdXRvJztcbiAgICBsZXQgcGF0aCA9IGV2LmNvbXBvc2VkUGF0aCAmJiBldi5jb21wb3NlZFBhdGgoKTtcbiAgICBpZiAocGF0aCkge1xuICAgICAgZm9yIChsZXQgaSA9IDAsIG47IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG4gPSBwYXRoW2ldO1xuICAgICAgICBpZiAobltUT1VDSF9BQ1RJT05dKSB7XG4gICAgICAgICAgdGEgPSBuW1RPVUNIX0FDVElPTl07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRhO1xuICB9XG5cbiAgZnVuY3Rpb24gdHJhY2tEb2N1bWVudChzdGF0ZU9iaiwgbW92ZWZuLCB1cGZuKSB7XG4gICAgc3RhdGVPYmoubW92ZWZuID0gbW92ZWZuO1xuICAgIHN0YXRlT2JqLnVwZm4gPSB1cGZuO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG1vdmVmbik7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHVwZm4pO1xuICB9XG5cbiAgZnVuY3Rpb24gdW50cmFja0RvY3VtZW50KHN0YXRlT2JqKSB7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgc3RhdGVPYmoubW92ZWZuKTtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgc3RhdGVPYmoudXBmbik7XG4gICAgc3RhdGVPYmoubW92ZWZuID0gbnVsbDtcbiAgICBzdGF0ZU9iai51cGZuID0gbnVsbDtcbiAgfVxuXG4gIC8vIHVzZSBhIGRvY3VtZW50LXdpZGUgdG91Y2hlbmQgbGlzdGVuZXIgdG8gc3RhcnQgdGhlIGdob3N0LWNsaWNrIHByZXZlbnRpb24gbWVjaGFuaXNtXG4gIC8vIFVzZSBwYXNzaXZlIGV2ZW50IGxpc3RlbmVycywgaWYgc3VwcG9ydGVkLCB0byBub3QgYWZmZWN0IHNjcm9sbGluZyBwZXJmb3JtYW5jZVxuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIGlnbm9yZU1vdXNlLCBTVVBQT1JUU19QQVNTSVZFID8ge3Bhc3NpdmU6IHRydWV9IDogZmFsc2UpO1xuXG4gIC8qKlxuICAgKiBNb2R1bGUgZm9yIGFkZGluZyBsaXN0ZW5lcnMgdG8gYSBub2RlIGZvciB0aGUgZm9sbG93aW5nIG5vcm1hbGl6ZWRcbiAgICogY3Jvc3MtcGxhdGZvcm0gXCJnZXN0dXJlXCIgZXZlbnRzOlxuICAgKiAtIGBkb3duYCAtIG1vdXNlIG9yIHRvdWNoIHdlbnQgZG93blxuICAgKiAtIGB1cGAgLSBtb3VzZSBvciB0b3VjaCB3ZW50IHVwXG4gICAqIC0gYHRhcGAgLSBtb3VzZSBjbGljayBvciBmaW5nZXIgdGFwXG4gICAqIC0gYHRyYWNrYCAtIG1vdXNlIGRyYWcgb3IgdG91Y2ggbW92ZVxuICAgKlxuICAgKiBAbmFtZXNwYWNlXG4gICAqIEBtZW1iZXJvZiBQb2x5bWVyXG4gICAqIEBzdW1tYXJ5IE1vZHVsZSBmb3IgYWRkaW5nIGNyb3NzLXBsYXRmb3JtIGdlc3R1cmUgZXZlbnQgbGlzdGVuZXJzLlxuICAgKi9cbiAgY29uc3QgR2VzdHVyZXMgPSB7XG4gICAgZ2VzdHVyZXM6IHt9LFxuICAgIHJlY29nbml6ZXJzOiBbXSxcblxuICAgIC8qKlxuICAgICAqIEZpbmRzIHRoZSBlbGVtZW50IHJlbmRlcmVkIG9uIHRoZSBzY3JlZW4gYXQgdGhlIHByb3ZpZGVkIGNvb3JkaW5hdGVzLlxuICAgICAqXG4gICAgICogU2ltaWxhciB0byBgZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludGAsIGJ1dCBwaWVyY2VzIHRocm91Z2hcbiAgICAgKiBzaGFkb3cgcm9vdHMuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgUG9seW1lci5HZXN0dXJlc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IEhvcml6b250YWwgcGl4ZWwgY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IFZlcnRpY2FsIHBpeGVsIGNvb3JkaW5hdGVcbiAgICAgKiBAcmV0dXJuIHtFbGVtZW50fSBSZXR1cm5zIHRoZSBkZWVwZXN0IHNoYWRvd1Jvb3QgaW5jbHVzaXZlIGVsZW1lbnRcbiAgICAgKiBmb3VuZCBhdCB0aGUgc2NyZWVuIHBvc2l0aW9uIGdpdmVuLlxuICAgICAqL1xuICAgIGRlZXBUYXJnZXRGaW5kOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICBsZXQgbm9kZSA9IGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQoeCwgeSk7XG4gICAgICBsZXQgbmV4dCA9IG5vZGU7XG4gICAgICAvLyB0aGlzIGNvZGUgcGF0aCBpcyBvbmx5IHRha2VuIHdoZW4gbmF0aXZlIFNoYWRvd0RPTSBpcyB1c2VkXG4gICAgICAvLyBpZiB0aGVyZSBpcyBhIHNoYWRvd3Jvb3QsIGl0IG1heSBoYXZlIGEgbm9kZSBhdCB4L3lcbiAgICAgIC8vIGlmIHRoZXJlIGlzIG5vdCBhIHNoYWRvd3Jvb3QsIGV4aXQgdGhlIGxvb3BcbiAgICAgIHdoaWxlIChuZXh0ICYmIG5leHQuc2hhZG93Um9vdCAmJiAhd2luZG93LlNoYWR5RE9NKSB7XG4gICAgICAgIC8vIGlmIHRoZXJlIGlzIGEgbm9kZSBhdCB4L3kgaW4gdGhlIHNoYWRvd3Jvb3QsIGxvb2sgZGVlcGVyXG4gICAgICAgIGxldCBvbGROZXh0ID0gbmV4dDtcbiAgICAgICAgbmV4dCA9IG5leHQuc2hhZG93Um9vdC5lbGVtZW50RnJvbVBvaW50KHgsIHkpO1xuICAgICAgICAvLyBvbiBTYWZhcmksIGVsZW1lbnRGcm9tUG9pbnQgbWF5IHJldHVybiB0aGUgc2hhZG93Um9vdCBob3N0XG4gICAgICAgIGlmIChvbGROZXh0ID09PSBuZXh0KSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5leHQpIHtcbiAgICAgICAgICBub2RlID0gbmV4dDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBhIGNoZWFwZXIgY2hlY2sgdGhhbiBldi5jb21wb3NlZFBhdGgoKVswXTtcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gZXYgRXZlbnQuXG4gICAgICogQHJldHVybiB7RXZlbnRUYXJnZXR9IFJldHVybnMgdGhlIGV2ZW50IHRhcmdldC5cbiAgICAgKi9cbiAgICBfZmluZE9yaWdpbmFsVGFyZ2V0OiBmdW5jdGlvbihldikge1xuICAgICAgLy8gc2hhZG93ZG9tXG4gICAgICBpZiAoZXYuY29tcG9zZWRQYXRoKSB7XG4gICAgICAgIHJldHVybiAvKiogQHR5cGUge0V2ZW50VGFyZ2V0fSAqLyhldi5jb21wb3NlZFBhdGgoKVswXSk7XG4gICAgICB9XG4gICAgICAvLyBzaGFkeWRvbVxuICAgICAgcmV0dXJuIGV2LnRhcmdldDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBldiBFdmVudC5cbiAgICAgKi9cbiAgICBfaGFuZGxlTmF0aXZlOiBmdW5jdGlvbihldikge1xuICAgICAgbGV0IGhhbmRsZWQ7XG4gICAgICBsZXQgdHlwZSA9IGV2LnR5cGU7XG4gICAgICBsZXQgbm9kZSA9IGV2LmN1cnJlbnRUYXJnZXQ7XG4gICAgICBsZXQgZ29iaiA9IG5vZGVbR0VTVFVSRV9LRVldO1xuICAgICAgaWYgKCFnb2JqKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxldCBncyA9IGdvYmpbdHlwZV07XG4gICAgICBpZiAoIWdzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghZXZbSEFORExFRF9PQkpdKSB7XG4gICAgICAgIGV2W0hBTkRMRURfT0JKXSA9IHt9O1xuICAgICAgICBpZiAodHlwZS5zbGljZSgwLCA1KSA9PT0gJ3RvdWNoJykge1xuICAgICAgICAgIGV2ID0gLyoqIEB0eXBlIHtUb3VjaEV2ZW50fSAqLyhldik7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1hc3NpZ25cbiAgICAgICAgICBsZXQgdCA9IGV2LmNoYW5nZWRUb3VjaGVzWzBdO1xuICAgICAgICAgIGlmICh0eXBlID09PSAndG91Y2hzdGFydCcpIHtcbiAgICAgICAgICAgIC8vIG9ubHkgaGFuZGxlIHRoZSBmaXJzdCBmaW5nZXJcbiAgICAgICAgICAgIGlmIChldi50b3VjaGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICBQT0lOVEVSU1RBVEUudG91Y2guaWQgPSB0LmlkZW50aWZpZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChQT0lOVEVSU1RBVEUudG91Y2guaWQgIT09IHQuaWRlbnRpZmllcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIUhBU19OQVRJVkVfVEEpIHtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSAndG91Y2hzdGFydCcgfHwgdHlwZSA9PT0gJ3RvdWNobW92ZScpIHtcbiAgICAgICAgICAgICAgR2VzdHVyZXMuX2hhbmRsZVRvdWNoQWN0aW9uKGV2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGhhbmRsZWQgPSBldltIQU5ETEVEX09CSl07XG4gICAgICAvLyB1c2VkIHRvIGlnbm9yZSBzeW50aGV0aWMgbW91c2UgZXZlbnRzXG4gICAgICBpZiAoaGFuZGxlZC5za2lwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxldCByZWNvZ25pemVycyA9IEdlc3R1cmVzLnJlY29nbml6ZXJzO1xuICAgICAgLy8gcmVzZXQgcmVjb2duaXplciBzdGF0ZVxuICAgICAgZm9yIChsZXQgaSA9IDAsIHI7IGkgPCByZWNvZ25pemVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICByID0gcmVjb2duaXplcnNbaV07XG4gICAgICAgIGlmIChnc1tyLm5hbWVdICYmICFoYW5kbGVkW3IubmFtZV0pIHtcbiAgICAgICAgICBpZiAoci5mbG93ICYmIHIuZmxvdy5zdGFydC5pbmRleE9mKGV2LnR5cGUpID4gLTEgJiYgci5yZXNldCkge1xuICAgICAgICAgICAgci5yZXNldCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gZW5mb3JjZSBnZXN0dXJlIHJlY29nbml6ZXIgb3JkZXJcbiAgICAgIGZvciAobGV0IGkgPSAwLCByOyBpIDwgcmVjb2duaXplcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgciA9IHJlY29nbml6ZXJzW2ldO1xuICAgICAgICBpZiAoZ3Nbci5uYW1lXSAmJiAhaGFuZGxlZFtyLm5hbWVdKSB7XG4gICAgICAgICAgaGFuZGxlZFtyLm5hbWVdID0gdHJ1ZTtcbiAgICAgICAgICByW3R5cGVdKGV2KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7VG91Y2hFdmVudH0gZXYgRXZlbnQuXG4gICAgICovXG4gICAgX2hhbmRsZVRvdWNoQWN0aW9uOiBmdW5jdGlvbihldikge1xuICAgICAgbGV0IHQgPSBldi5jaGFuZ2VkVG91Y2hlc1swXTtcbiAgICAgIGxldCB0eXBlID0gZXYudHlwZTtcbiAgICAgIGlmICh0eXBlID09PSAndG91Y2hzdGFydCcpIHtcbiAgICAgICAgUE9JTlRFUlNUQVRFLnRvdWNoLnggPSB0LmNsaWVudFg7XG4gICAgICAgIFBPSU5URVJTVEFURS50b3VjaC55ID0gdC5jbGllbnRZO1xuICAgICAgICBQT0lOVEVSU1RBVEUudG91Y2guc2Nyb2xsRGVjaWRlZCA9IGZhbHNlO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAndG91Y2htb3ZlJykge1xuICAgICAgICBpZiAoUE9JTlRFUlNUQVRFLnRvdWNoLnNjcm9sbERlY2lkZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgUE9JTlRFUlNUQVRFLnRvdWNoLnNjcm9sbERlY2lkZWQgPSB0cnVlO1xuICAgICAgICBsZXQgdGEgPSBmaXJzdFRvdWNoQWN0aW9uKGV2KTtcbiAgICAgICAgbGV0IHByZXZlbnQgPSBmYWxzZTtcbiAgICAgICAgbGV0IGR4ID0gTWF0aC5hYnMoUE9JTlRFUlNUQVRFLnRvdWNoLnggLSB0LmNsaWVudFgpO1xuICAgICAgICBsZXQgZHkgPSBNYXRoLmFicyhQT0lOVEVSU1RBVEUudG91Y2gueSAtIHQuY2xpZW50WSk7XG4gICAgICAgIGlmICghZXYuY2FuY2VsYWJsZSkge1xuICAgICAgICAgIC8vIHNjcm9sbGluZyBpcyBoYXBwZW5pbmdcbiAgICAgICAgfSBlbHNlIGlmICh0YSA9PT0gJ25vbmUnKSB7XG4gICAgICAgICAgcHJldmVudCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAodGEgPT09ICdwYW4teCcpIHtcbiAgICAgICAgICBwcmV2ZW50ID0gZHkgPiBkeDtcbiAgICAgICAgfSBlbHNlIGlmICh0YSA9PT0gJ3Bhbi15Jykge1xuICAgICAgICAgIHByZXZlbnQgPSBkeCA+IGR5O1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcmV2ZW50KSB7XG4gICAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBHZXN0dXJlcy5wcmV2ZW50KCd0cmFjaycpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZHMgYW4gZXZlbnQgbGlzdGVuZXIgdG8gYSBub2RlIGZvciB0aGUgZ2l2ZW4gZ2VzdHVyZSB0eXBlLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIFBvbHltZXIuR2VzdHVyZXNcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgTm9kZSB0byBhZGQgbGlzdGVuZXIgb25cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZUeXBlIEdlc3R1cmUgdHlwZTogYGRvd25gLCBgdXBgLCBgdHJhY2tgLCBvciBgdGFwYFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIgRXZlbnQgbGlzdGVuZXIgZnVuY3Rpb24gdG8gY2FsbFxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiBhIGdlc3R1cmUgZXZlbnQgbGlzdGVuZXIgd2FzIGFkZGVkLlxuICAgICAqIEB0aGlzIHtHZXN0dXJlc31cbiAgICAgKi9cbiAgICBhZGRMaXN0ZW5lcjogZnVuY3Rpb24obm9kZSwgZXZUeXBlLCBoYW5kbGVyKSB7XG4gICAgICBpZiAodGhpcy5nZXN0dXJlc1tldlR5cGVdKSB7XG4gICAgICAgIHRoaXMuX2FkZChub2RlLCBldlR5cGUsIGhhbmRsZXIpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbiBldmVudCBsaXN0ZW5lciBmcm9tIGEgbm9kZSBmb3IgdGhlIGdpdmVuIGdlc3R1cmUgdHlwZS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBQb2x5bWVyLkdlc3R1cmVzXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlIE5vZGUgdG8gcmVtb3ZlIGxpc3RlbmVyIGZyb21cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZUeXBlIEdlc3R1cmUgdHlwZTogYGRvd25gLCBgdXBgLCBgdHJhY2tgLCBvciBgdGFwYFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIgRXZlbnQgbGlzdGVuZXIgZnVuY3Rpb24gcHJldmlvdXNseSBwYXNzZWQgdG9cbiAgICAgKiAgYGFkZExpc3RlbmVyYC5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgYSBnZXN0dXJlIGV2ZW50IGxpc3RlbmVyIHdhcyByZW1vdmVkLlxuICAgICAqIEB0aGlzIHtHZXN0dXJlc31cbiAgICAgKi9cbiAgICByZW1vdmVMaXN0ZW5lcjogZnVuY3Rpb24obm9kZSwgZXZUeXBlLCBoYW5kbGVyKSB7XG4gICAgICBpZiAodGhpcy5nZXN0dXJlc1tldlR5cGVdKSB7XG4gICAgICAgIHRoaXMuX3JlbW92ZShub2RlLCBldlR5cGUsIGhhbmRsZXIpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogYXV0b21hdGUgdGhlIGV2ZW50IGxpc3RlbmVycyBmb3IgdGhlIG5hdGl2ZSBldmVudHNcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gbm9kZSBOb2RlIG9uIHdoaWNoIHRvIGFkZCB0aGUgZXZlbnQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2VHlwZSBFdmVudCB0eXBlIHRvIGFkZC5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKEV2ZW50Pyl9IGhhbmRsZXIgRXZlbnQgaGFuZGxlciBmdW5jdGlvbi5cbiAgICAgKiBAdGhpcyB7R2VzdHVyZXN9XG4gICAgICovXG4gICAgX2FkZDogZnVuY3Rpb24obm9kZSwgZXZUeXBlLCBoYW5kbGVyKSB7XG4gICAgICBsZXQgcmVjb2duaXplciA9IHRoaXMuZ2VzdHVyZXNbZXZUeXBlXTtcbiAgICAgIGxldCBkZXBzID0gcmVjb2duaXplci5kZXBzO1xuICAgICAgbGV0IG5hbWUgPSByZWNvZ25pemVyLm5hbWU7XG4gICAgICBsZXQgZ29iaiA9IG5vZGVbR0VTVFVSRV9LRVldO1xuICAgICAgaWYgKCFnb2JqKSB7XG4gICAgICAgIG5vZGVbR0VTVFVSRV9LRVldID0gZ29iaiA9IHt9O1xuICAgICAgfVxuICAgICAgZm9yIChsZXQgaSA9IDAsIGRlcCwgZ2Q7IGkgPCBkZXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGRlcCA9IGRlcHNbaV07XG4gICAgICAgIC8vIGRvbid0IGFkZCBtb3VzZSBoYW5kbGVycyBvbiBpT1MgYmVjYXVzZSB0aGV5IGNhdXNlIGdyYXkgc2VsZWN0aW9uIG92ZXJsYXlzXG4gICAgICAgIGlmIChJU19UT1VDSF9PTkxZICYmIE1PVVNFX0VWRU5UUy5pbmRleE9mKGRlcCkgPiAtMSAmJiBkZXAgIT09ICdjbGljaycpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBnZCA9IGdvYmpbZGVwXTtcbiAgICAgICAgaWYgKCFnZCkge1xuICAgICAgICAgIGdvYmpbZGVwXSA9IGdkID0ge19jb3VudDogMH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdkLl9jb3VudCA9PT0gMCkge1xuICAgICAgICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihkZXAsIHRoaXMuX2hhbmRsZU5hdGl2ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZ2RbbmFtZV0gPSAoZ2RbbmFtZV0gfHwgMCkgKyAxO1xuICAgICAgICBnZC5fY291bnQgPSAoZ2QuX2NvdW50IHx8IDApICsgMTtcbiAgICAgIH1cbiAgICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihldlR5cGUsIGhhbmRsZXIpO1xuICAgICAgaWYgKHJlY29nbml6ZXIudG91Y2hBY3Rpb24pIHtcbiAgICAgICAgdGhpcy5zZXRUb3VjaEFjdGlvbihub2RlLCByZWNvZ25pemVyLnRvdWNoQWN0aW9uKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogYXV0b21hdGUgZXZlbnQgbGlzdGVuZXIgcmVtb3ZhbCBmb3IgbmF0aXZlIGV2ZW50c1xuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBub2RlIE5vZGUgb24gd2hpY2ggdG8gcmVtb3ZlIHRoZSBldmVudC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZUeXBlIEV2ZW50IHR5cGUgdG8gcmVtb3ZlLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oRXZlbnQ/KX0gaGFuZGxlciBFdmVudCBoYW5kbGVyIGZ1bmN0aW9uLlxuICAgICAqIEB0aGlzIHtHZXN0dXJlc31cbiAgICAgKi9cbiAgICBfcmVtb3ZlOiBmdW5jdGlvbihub2RlLCBldlR5cGUsIGhhbmRsZXIpIHtcbiAgICAgIGxldCByZWNvZ25pemVyID0gdGhpcy5nZXN0dXJlc1tldlR5cGVdO1xuICAgICAgbGV0IGRlcHMgPSByZWNvZ25pemVyLmRlcHM7XG4gICAgICBsZXQgbmFtZSA9IHJlY29nbml6ZXIubmFtZTtcbiAgICAgIGxldCBnb2JqID0gbm9kZVtHRVNUVVJFX0tFWV07XG4gICAgICBpZiAoZ29iaikge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgZGVwLCBnZDsgaSA8IGRlcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBkZXAgPSBkZXBzW2ldO1xuICAgICAgICAgIGdkID0gZ29ialtkZXBdO1xuICAgICAgICAgIGlmIChnZCAmJiBnZFtuYW1lXSkge1xuICAgICAgICAgICAgZ2RbbmFtZV0gPSAoZ2RbbmFtZV0gfHwgMSkgLSAxO1xuICAgICAgICAgICAgZ2QuX2NvdW50ID0gKGdkLl9jb3VudCB8fCAxKSAtIDE7XG4gICAgICAgICAgICBpZiAoZ2QuX2NvdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihkZXAsIHRoaXMuX2hhbmRsZU5hdGl2ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZUeXBlLCBoYW5kbGVyKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIGEgbmV3IGdlc3R1cmUgZXZlbnQgcmVjb2duaXplciBmb3IgYWRkaW5nIG5ldyBjdXN0b21cbiAgICAgKiBnZXN0dXJlIGV2ZW50IHR5cGVzLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIFBvbHltZXIuR2VzdHVyZXNcbiAgICAgKiBAcGFyYW0ge0dlc3R1cmVSZWNvZ25pemVyfSByZWNvZyBHZXN0dXJlIHJlY29nbml6ZXIgZGVzY3JpcHRvclxuICAgICAqIEB0aGlzIHtHZXN0dXJlc31cbiAgICAgKi9cbiAgICByZWdpc3RlcjogZnVuY3Rpb24ocmVjb2cpIHtcbiAgICAgIHRoaXMucmVjb2duaXplcnMucHVzaChyZWNvZyk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlY29nLmVtaXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuZ2VzdHVyZXNbcmVjb2cuZW1pdHNbaV1dID0gcmVjb2c7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2TmFtZSBFdmVudCBuYW1lLlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gUmV0dXJucyB0aGUgZ2VzdHVyZSBmb3IgdGhlIGdpdmVuIGV2ZW50IG5hbWUuXG4gICAgICogQHRoaXMge0dlc3R1cmVzfVxuICAgICAqL1xuICAgIF9maW5kUmVjb2duaXplckJ5RXZlbnQ6IGZ1bmN0aW9uKGV2TmFtZSkge1xuICAgICAgZm9yIChsZXQgaSA9IDAsIHI7IGkgPCB0aGlzLnJlY29nbml6ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHIgPSB0aGlzLnJlY29nbml6ZXJzW2ldO1xuICAgICAgICBmb3IgKGxldCBqID0gMCwgbjsgaiA8IHIuZW1pdHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBuID0gci5lbWl0c1tqXTtcbiAgICAgICAgICBpZiAobiA9PT0gZXZOYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHNjcm9sbGluZyBkaXJlY3Rpb24gb24gbm9kZS5cbiAgICAgKlxuICAgICAqIFRoaXMgdmFsdWUgaXMgY2hlY2tlZCBvbiBmaXJzdCBtb3ZlLCB0aHVzIGl0IHNob3VsZCBiZSBjYWxsZWQgcHJpb3IgdG9cbiAgICAgKiBhZGRpbmcgZXZlbnQgbGlzdGVuZXJzLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIFBvbHltZXIuR2VzdHVyZXNcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgTm9kZSB0byBzZXQgdG91Y2ggYWN0aW9uIHNldHRpbmcgb25cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgVG91Y2ggYWN0aW9uIHZhbHVlXG4gICAgICovXG4gICAgc2V0VG91Y2hBY3Rpb246IGZ1bmN0aW9uKG5vZGUsIHZhbHVlKSB7XG4gICAgICBpZiAoSEFTX05BVElWRV9UQSkge1xuICAgICAgICBub2RlLnN0eWxlLnRvdWNoQWN0aW9uID0gdmFsdWU7XG4gICAgICB9XG4gICAgICBub2RlW1RPVUNIX0FDVElPTl0gPSB2YWx1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGlzcGF0Y2hlcyBhbiBldmVudCBvbiB0aGUgYHRhcmdldGAgZWxlbWVudCBvZiBgdHlwZWAgd2l0aCB0aGUgZ2l2ZW5cbiAgICAgKiBgZGV0YWlsYC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IHRhcmdldCBUaGUgZWxlbWVudCBvbiB3aGljaCB0byBmaXJlIGFuIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIFRoZSB0eXBlIG9mIGV2ZW50IHRvIGZpcmUuXG4gICAgICogQHBhcmFtIHtPYmplY3Q9fSBkZXRhaWwgVGhlIGRldGFpbCBvYmplY3QgdG8gcG9wdWxhdGUgb24gdGhlIGV2ZW50LlxuICAgICAqL1xuICAgIF9maXJlOiBmdW5jdGlvbih0YXJnZXQsIHR5cGUsIGRldGFpbCkge1xuICAgICAgbGV0IGV2ID0gbmV3IEV2ZW50KHR5cGUsIHsgYnViYmxlczogdHJ1ZSwgY2FuY2VsYWJsZTogdHJ1ZSwgY29tcG9zZWQ6IHRydWUgfSk7XG4gICAgICBldi5kZXRhaWwgPSBkZXRhaWw7XG4gICAgICB0YXJnZXQuZGlzcGF0Y2hFdmVudChldik7XG4gICAgICAvLyBmb3J3YXJkIGBwcmV2ZW50RGVmYXVsdGAgaW4gYSBjbGVhbiB3YXlcbiAgICAgIGlmIChldi5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgIGxldCBwcmV2ZW50ZXIgPSBkZXRhaWwucHJldmVudGVyIHx8IGRldGFpbC5zb3VyY2VFdmVudDtcbiAgICAgICAgaWYgKHByZXZlbnRlciAmJiBwcmV2ZW50ZXIucHJldmVudERlZmF1bHQpIHtcbiAgICAgICAgICBwcmV2ZW50ZXIucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQcmV2ZW50cyB0aGUgZGlzcGF0Y2ggYW5kIGRlZmF1bHQgYWN0aW9uIG9mIHRoZSBnaXZlbiBldmVudCBuYW1lLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIFBvbHltZXIuR2VzdHVyZXNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZOYW1lIEV2ZW50IG5hbWUuXG4gICAgICogQHRoaXMge0dlc3R1cmVzfVxuICAgICAqL1xuICAgIHByZXZlbnQ6IGZ1bmN0aW9uKGV2TmFtZSkge1xuICAgICAgbGV0IHJlY29nbml6ZXIgPSB0aGlzLl9maW5kUmVjb2duaXplckJ5RXZlbnQoZXZOYW1lKTtcbiAgICAgIGlmIChyZWNvZ25pemVyLmluZm8pIHtcbiAgICAgICAgcmVjb2duaXplci5pbmZvLnByZXZlbnQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXNldCB0aGUgMjUwMG1zIHRpbWVvdXQgb24gcHJvY2Vzc2luZyBtb3VzZSBpbnB1dCBhZnRlciBkZXRlY3RpbmcgdG91Y2ggaW5wdXQuXG4gICAgICpcbiAgICAgKiBUb3VjaCBpbnB1dHMgY3JlYXRlIHN5bnRoZXNpemVkIG1vdXNlIGlucHV0cyBhbnl3aGVyZSBmcm9tIDAgdG8gMjAwMG1zIGFmdGVyIHRoZSB0b3VjaC5cbiAgICAgKiBUaGlzIG1ldGhvZCBzaG91bGQgb25seSBiZSBjYWxsZWQgZHVyaW5nIHRlc3Rpbmcgd2l0aCBzaW11bGF0ZWQgdG91Y2ggaW5wdXRzLlxuICAgICAqIENhbGxpbmcgdGhpcyBtZXRob2QgaW4gcHJvZHVjdGlvbiBtYXkgY2F1c2UgZHVwbGljYXRlIHRhcHMgb3Igb3RoZXIgR2VzdHVyZXMuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgUG9seW1lci5HZXN0dXJlc1xuICAgICAqL1xuICAgIHJlc2V0TW91c2VDYW5jZWxsZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKFBPSU5URVJTVEFURS5tb3VzZS5tb3VzZUlnbm9yZUpvYikge1xuICAgICAgICBQT0lOVEVSU1RBVEUubW91c2UubW91c2VJZ25vcmVKb2IuZmx1c2goKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyogZXNsaW50LWRpc2FibGUgdmFsaWQtanNkb2MgKi9cblxuICBHZXN0dXJlcy5yZWdpc3Rlcih7XG4gICAgbmFtZTogJ2Rvd251cCcsXG4gICAgZGVwczogWydtb3VzZWRvd24nLCAndG91Y2hzdGFydCcsICd0b3VjaGVuZCddLFxuICAgIGZsb3c6IHtcbiAgICAgIHN0YXJ0OiBbJ21vdXNlZG93bicsICd0b3VjaHN0YXJ0J10sXG4gICAgICBlbmQ6IFsnbW91c2V1cCcsICd0b3VjaGVuZCddXG4gICAgfSxcbiAgICBlbWl0czogWydkb3duJywgJ3VwJ10sXG5cbiAgICBpbmZvOiB7XG4gICAgICBtb3ZlZm46IG51bGwsXG4gICAgICB1cGZuOiBudWxsXG4gICAgfSxcblxuICAgIC8qKiBAdGhpcyB7R2VzdHVyZVJlY29nbml6ZXJ9ICovXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdW50cmFja0RvY3VtZW50KHRoaXMuaW5mbyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEB0aGlzIHtHZXN0dXJlUmVjb2duaXplcn1cbiAgICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGVcbiAgICAgKi9cbiAgICBtb3VzZWRvd246IGZ1bmN0aW9uKGUpIHtcbiAgICAgIGlmICghaGFzTGVmdE1vdXNlQnV0dG9uKGUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxldCB0ID0gR2VzdHVyZXMuX2ZpbmRPcmlnaW5hbFRhcmdldChlKTtcbiAgICAgIGxldCBzZWxmID0gdGhpcztcbiAgICAgIGxldCBtb3ZlZm4gPSBmdW5jdGlvbiBtb3ZlZm4oZSkge1xuICAgICAgICBpZiAoIWhhc0xlZnRNb3VzZUJ1dHRvbihlKSkge1xuICAgICAgICAgIHNlbGYuX2ZpcmUoJ3VwJywgdCwgZSk7XG4gICAgICAgICAgdW50cmFja0RvY3VtZW50KHNlbGYuaW5mbyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBsZXQgdXBmbiA9IGZ1bmN0aW9uIHVwZm4oZSkge1xuICAgICAgICBpZiAoaGFzTGVmdE1vdXNlQnV0dG9uKGUpKSB7XG4gICAgICAgICAgc2VsZi5fZmlyZSgndXAnLCB0LCBlKTtcbiAgICAgICAgfVxuICAgICAgICB1bnRyYWNrRG9jdW1lbnQoc2VsZi5pbmZvKTtcbiAgICAgIH07XG4gICAgICB0cmFja0RvY3VtZW50KHRoaXMuaW5mbywgbW92ZWZuLCB1cGZuKTtcbiAgICAgIHRoaXMuX2ZpcmUoJ2Rvd24nLCB0LCBlKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEB0aGlzIHtHZXN0dXJlUmVjb2duaXplcn1cbiAgICAgKiBAcGFyYW0ge1RvdWNoRXZlbnR9IGVcbiAgICAgKi9cbiAgICB0b3VjaHN0YXJ0OiBmdW5jdGlvbihlKSB7XG4gICAgICB0aGlzLl9maXJlKCdkb3duJywgR2VzdHVyZXMuX2ZpbmRPcmlnaW5hbFRhcmdldChlKSwgZS5jaGFuZ2VkVG91Y2hlc1swXSwgZSk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBAdGhpcyB7R2VzdHVyZVJlY29nbml6ZXJ9XG4gICAgICogQHBhcmFtIHtUb3VjaEV2ZW50fSBlXG4gICAgICovXG4gICAgdG91Y2hlbmQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgIHRoaXMuX2ZpcmUoJ3VwJywgR2VzdHVyZXMuX2ZpbmRPcmlnaW5hbFRhcmdldChlKSwgZS5jaGFuZ2VkVG91Y2hlc1swXSwgZSk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICAgICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IHRhcmdldFxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJldmVudGVyXG4gICAgICovXG4gICAgX2ZpcmU6IGZ1bmN0aW9uKHR5cGUsIHRhcmdldCwgZXZlbnQsIHByZXZlbnRlcikge1xuICAgICAgR2VzdHVyZXMuX2ZpcmUodGFyZ2V0LCB0eXBlLCB7XG4gICAgICAgIHg6IGV2ZW50LmNsaWVudFgsXG4gICAgICAgIHk6IGV2ZW50LmNsaWVudFksXG4gICAgICAgIHNvdXJjZUV2ZW50OiBldmVudCxcbiAgICAgICAgcHJldmVudGVyOiBwcmV2ZW50ZXIsXG4gICAgICAgIHByZXZlbnQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICByZXR1cm4gR2VzdHVyZXMucHJldmVudChlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcblxuICBHZXN0dXJlcy5yZWdpc3Rlcih7XG4gICAgbmFtZTogJ3RyYWNrJyxcbiAgICB0b3VjaEFjdGlvbjogJ25vbmUnLFxuICAgIGRlcHM6IFsnbW91c2Vkb3duJywgJ3RvdWNoc3RhcnQnLCAndG91Y2htb3ZlJywgJ3RvdWNoZW5kJ10sXG4gICAgZmxvdzoge1xuICAgICAgc3RhcnQ6IFsnbW91c2Vkb3duJywgJ3RvdWNoc3RhcnQnXSxcbiAgICAgIGVuZDogWydtb3VzZXVwJywgJ3RvdWNoZW5kJ11cbiAgICB9LFxuICAgIGVtaXRzOiBbJ3RyYWNrJ10sXG5cbiAgICBpbmZvOiB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMCxcbiAgICAgIHN0YXRlOiAnc3RhcnQnLFxuICAgICAgc3RhcnRlZDogZmFsc2UsXG4gICAgICBtb3ZlczogW10sXG4gICAgICAvKiogQHRoaXMge0dlc3R1cmVSZWNvZ25pemVyfSAqL1xuICAgICAgYWRkTW92ZTogZnVuY3Rpb24obW92ZSkge1xuICAgICAgICBpZiAodGhpcy5tb3Zlcy5sZW5ndGggPiBUUkFDS19MRU5HVEgpIHtcbiAgICAgICAgICB0aGlzLm1vdmVzLnNoaWZ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tb3Zlcy5wdXNoKG1vdmUpO1xuICAgICAgfSxcbiAgICAgIG1vdmVmbjogbnVsbCxcbiAgICAgIHVwZm46IG51bGwsXG4gICAgICBwcmV2ZW50OiBmYWxzZVxuICAgIH0sXG5cbiAgICAvKiogQHRoaXMge0dlc3R1cmVSZWNvZ25pemVyfSAqL1xuICAgIHJlc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuaW5mby5zdGF0ZSA9ICdzdGFydCc7XG4gICAgICB0aGlzLmluZm8uc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5pbmZvLm1vdmVzID0gW107XG4gICAgICB0aGlzLmluZm8ueCA9IDA7XG4gICAgICB0aGlzLmluZm8ueSA9IDA7XG4gICAgICB0aGlzLmluZm8ucHJldmVudCA9IGZhbHNlO1xuICAgICAgdW50cmFja0RvY3VtZW50KHRoaXMuaW5mbyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEB0aGlzIHtHZXN0dXJlUmVjb2duaXplcn1cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBoYXNNb3ZlZEVub3VnaDogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgaWYgKHRoaXMuaW5mby5wcmV2ZW50KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmluZm8uc3RhcnRlZCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGxldCBkeCA9IE1hdGguYWJzKHRoaXMuaW5mby54IC0geCk7XG4gICAgICBsZXQgZHkgPSBNYXRoLmFicyh0aGlzLmluZm8ueSAtIHkpO1xuICAgICAgcmV0dXJuIChkeCA+PSBUUkFDS19ESVNUQU5DRSB8fCBkeSA+PSBUUkFDS19ESVNUQU5DRSk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBAdGhpcyB7R2VzdHVyZVJlY29nbml6ZXJ9XG4gICAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBlXG4gICAgICovXG4gICAgbW91c2Vkb3duOiBmdW5jdGlvbihlKSB7XG4gICAgICBpZiAoIWhhc0xlZnRNb3VzZUJ1dHRvbihlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsZXQgdCA9IEdlc3R1cmVzLl9maW5kT3JpZ2luYWxUYXJnZXQoZSk7XG4gICAgICBsZXQgc2VsZiA9IHRoaXM7XG4gICAgICBsZXQgbW92ZWZuID0gZnVuY3Rpb24gbW92ZWZuKGUpIHtcbiAgICAgICAgbGV0IHggPSBlLmNsaWVudFgsIHkgPSBlLmNsaWVudFk7XG4gICAgICAgIGlmIChzZWxmLmhhc01vdmVkRW5vdWdoKHgsIHkpKSB7XG4gICAgICAgICAgLy8gZmlyc3QgbW92ZSBpcyAnc3RhcnQnLCBzdWJzZXF1ZW50IG1vdmVzIGFyZSAnbW92ZScsIG1vdXNldXAgaXMgJ2VuZCdcbiAgICAgICAgICBzZWxmLmluZm8uc3RhdGUgPSBzZWxmLmluZm8uc3RhcnRlZCA/IChlLnR5cGUgPT09ICdtb3VzZXVwJyA/ICdlbmQnIDogJ3RyYWNrJykgOiAnc3RhcnQnO1xuICAgICAgICAgIGlmIChzZWxmLmluZm8uc3RhdGUgPT09ICdzdGFydCcpIHtcbiAgICAgICAgICAgIC8vIGlmIGFuZCBvbmx5IGlmIHRyYWNraW5nLCBhbHdheXMgcHJldmVudCB0YXBcbiAgICAgICAgICAgIEdlc3R1cmVzLnByZXZlbnQoJ3RhcCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzZWxmLmluZm8uYWRkTW92ZSh7eDogeCwgeTogeX0pO1xuICAgICAgICAgIGlmICghaGFzTGVmdE1vdXNlQnV0dG9uKGUpKSB7XG4gICAgICAgICAgICAvLyBhbHdheXMgX2ZpcmUgXCJlbmRcIlxuICAgICAgICAgICAgc2VsZi5pbmZvLnN0YXRlID0gJ2VuZCc7XG4gICAgICAgICAgICB1bnRyYWNrRG9jdW1lbnQoc2VsZi5pbmZvKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2VsZi5fZmlyZSh0LCBlKTtcbiAgICAgICAgICBzZWxmLmluZm8uc3RhcnRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBsZXQgdXBmbiA9IGZ1bmN0aW9uIHVwZm4oZSkge1xuICAgICAgICBpZiAoc2VsZi5pbmZvLnN0YXJ0ZWQpIHtcbiAgICAgICAgICBtb3ZlZm4oZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZW1vdmUgdGhlIHRlbXBvcmFyeSBsaXN0ZW5lcnNcbiAgICAgICAgdW50cmFja0RvY3VtZW50KHNlbGYuaW5mbyk7XG4gICAgICB9O1xuICAgICAgLy8gYWRkIHRlbXBvcmFyeSBkb2N1bWVudCBsaXN0ZW5lcnMgYXMgbW91c2UgcmV0YXJnZXRzXG4gICAgICB0cmFja0RvY3VtZW50KHRoaXMuaW5mbywgbW92ZWZuLCB1cGZuKTtcbiAgICAgIHRoaXMuaW5mby54ID0gZS5jbGllbnRYO1xuICAgICAgdGhpcy5pbmZvLnkgPSBlLmNsaWVudFk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBAdGhpcyB7R2VzdHVyZVJlY29nbml6ZXJ9XG4gICAgICogQHBhcmFtIHtUb3VjaEV2ZW50fSBlXG4gICAgICovXG4gICAgdG91Y2hzdGFydDogZnVuY3Rpb24oZSkge1xuICAgICAgbGV0IGN0ID0gZS5jaGFuZ2VkVG91Y2hlc1swXTtcbiAgICAgIHRoaXMuaW5mby54ID0gY3QuY2xpZW50WDtcbiAgICAgIHRoaXMuaW5mby55ID0gY3QuY2xpZW50WTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEB0aGlzIHtHZXN0dXJlUmVjb2duaXplcn1cbiAgICAgKiBAcGFyYW0ge1RvdWNoRXZlbnR9IGVcbiAgICAgKi9cbiAgICB0b3VjaG1vdmU6IGZ1bmN0aW9uKGUpIHtcbiAgICAgIGxldCB0ID0gR2VzdHVyZXMuX2ZpbmRPcmlnaW5hbFRhcmdldChlKTtcbiAgICAgIGxldCBjdCA9IGUuY2hhbmdlZFRvdWNoZXNbMF07XG4gICAgICBsZXQgeCA9IGN0LmNsaWVudFgsIHkgPSBjdC5jbGllbnRZO1xuICAgICAgaWYgKHRoaXMuaGFzTW92ZWRFbm91Z2goeCwgeSkpIHtcbiAgICAgICAgaWYgKHRoaXMuaW5mby5zdGF0ZSA9PT0gJ3N0YXJ0Jykge1xuICAgICAgICAgIC8vIGlmIGFuZCBvbmx5IGlmIHRyYWNraW5nLCBhbHdheXMgcHJldmVudCB0YXBcbiAgICAgICAgICBHZXN0dXJlcy5wcmV2ZW50KCd0YXAnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluZm8uYWRkTW92ZSh7eDogeCwgeTogeX0pO1xuICAgICAgICB0aGlzLl9maXJlKHQsIGN0KTtcbiAgICAgICAgdGhpcy5pbmZvLnN0YXRlID0gJ3RyYWNrJztcbiAgICAgICAgdGhpcy5pbmZvLnN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogQHRoaXMge0dlc3R1cmVSZWNvZ25pemVyfVxuICAgICAqIEBwYXJhbSB7VG91Y2hFdmVudH0gZVxuICAgICAqL1xuICAgIHRvdWNoZW5kOiBmdW5jdGlvbihlKSB7XG4gICAgICBsZXQgdCA9IEdlc3R1cmVzLl9maW5kT3JpZ2luYWxUYXJnZXQoZSk7XG4gICAgICBsZXQgY3QgPSBlLmNoYW5nZWRUb3VjaGVzWzBdO1xuICAgICAgLy8gb25seSB0cmFja2VuZCBpZiB0cmFjayB3YXMgc3RhcnRlZCBhbmQgbm90IGFib3J0ZWRcbiAgICAgIGlmICh0aGlzLmluZm8uc3RhcnRlZCkge1xuICAgICAgICAvLyByZXNldCBzdGFydGVkIHN0YXRlIG9uIHVwXG4gICAgICAgIHRoaXMuaW5mby5zdGF0ZSA9ICdlbmQnO1xuICAgICAgICB0aGlzLmluZm8uYWRkTW92ZSh7eDogY3QuY2xpZW50WCwgeTogY3QuY2xpZW50WX0pO1xuICAgICAgICB0aGlzLl9maXJlKHQsIGN0LCBlKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHRoaXMge0dlc3R1cmVSZWNvZ25pemVyfVxuICAgICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IHRhcmdldFxuICAgICAqIEBwYXJhbSB7VG91Y2h9IHRvdWNoXG4gICAgICovXG4gICAgX2ZpcmU6IGZ1bmN0aW9uKHRhcmdldCwgdG91Y2gpIHtcbiAgICAgIGxldCBzZWNvbmRsYXN0ID0gdGhpcy5pbmZvLm1vdmVzW3RoaXMuaW5mby5tb3Zlcy5sZW5ndGggLSAyXTtcbiAgICAgIGxldCBsYXN0bW92ZSA9IHRoaXMuaW5mby5tb3Zlc1t0aGlzLmluZm8ubW92ZXMubGVuZ3RoIC0gMV07XG4gICAgICBsZXQgZHggPSBsYXN0bW92ZS54IC0gdGhpcy5pbmZvLng7XG4gICAgICBsZXQgZHkgPSBsYXN0bW92ZS55IC0gdGhpcy5pbmZvLnk7XG4gICAgICBsZXQgZGR4LCBkZHkgPSAwO1xuICAgICAgaWYgKHNlY29uZGxhc3QpIHtcbiAgICAgICAgZGR4ID0gbGFzdG1vdmUueCAtIHNlY29uZGxhc3QueDtcbiAgICAgICAgZGR5ID0gbGFzdG1vdmUueSAtIHNlY29uZGxhc3QueTtcbiAgICAgIH1cbiAgICAgIEdlc3R1cmVzLl9maXJlKHRhcmdldCwgJ3RyYWNrJywge1xuICAgICAgICBzdGF0ZTogdGhpcy5pbmZvLnN0YXRlLFxuICAgICAgICB4OiB0b3VjaC5jbGllbnRYLFxuICAgICAgICB5OiB0b3VjaC5jbGllbnRZLFxuICAgICAgICBkeDogZHgsXG4gICAgICAgIGR5OiBkeSxcbiAgICAgICAgZGR4OiBkZHgsXG4gICAgICAgIGRkeTogZGR5LFxuICAgICAgICBzb3VyY2VFdmVudDogdG91Y2gsXG4gICAgICAgIGhvdmVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gR2VzdHVyZXMuZGVlcFRhcmdldEZpbmQodG91Y2guY2xpZW50WCwgdG91Y2guY2xpZW50WSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICB9KTtcblxuICBHZXN0dXJlcy5yZWdpc3Rlcih7XG4gICAgbmFtZTogJ3RhcCcsXG4gICAgZGVwczogWydtb3VzZWRvd24nLCAnY2xpY2snLCAndG91Y2hzdGFydCcsICd0b3VjaGVuZCddLFxuICAgIGZsb3c6IHtcbiAgICAgIHN0YXJ0OiBbJ21vdXNlZG93bicsICd0b3VjaHN0YXJ0J10sXG4gICAgICBlbmQ6IFsnY2xpY2snLCAndG91Y2hlbmQnXVxuICAgIH0sXG4gICAgZW1pdHM6IFsndGFwJ10sXG4gICAgaW5mbzoge1xuICAgICAgeDogTmFOLFxuICAgICAgeTogTmFOLFxuICAgICAgcHJldmVudDogZmFsc2VcbiAgICB9LFxuICAgIC8qKiBAdGhpcyB7R2VzdHVyZVJlY29nbml6ZXJ9ICovXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5pbmZvLnggPSBOYU47XG4gICAgICB0aGlzLmluZm8ueSA9IE5hTjtcbiAgICAgIHRoaXMuaW5mby5wcmV2ZW50ID0gZmFsc2U7XG4gICAgfSxcbiAgICAvKiogQHRoaXMge0dlc3R1cmVSZWNvZ25pemVyfSAqL1xuICAgIHNhdmU6IGZ1bmN0aW9uKGUpIHtcbiAgICAgIHRoaXMuaW5mby54ID0gZS5jbGllbnRYO1xuICAgICAgdGhpcy5pbmZvLnkgPSBlLmNsaWVudFk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBAdGhpcyB7R2VzdHVyZVJlY29nbml6ZXJ9XG4gICAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBlXG4gICAgICovXG4gICAgbW91c2Vkb3duOiBmdW5jdGlvbihlKSB7XG4gICAgICBpZiAoaGFzTGVmdE1vdXNlQnV0dG9uKGUpKSB7XG4gICAgICAgIHRoaXMuc2F2ZShlKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEB0aGlzIHtHZXN0dXJlUmVjb2duaXplcn1cbiAgICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGVcbiAgICAgKi9cbiAgICBjbGljazogZnVuY3Rpb24oZSkge1xuICAgICAgaWYgKGhhc0xlZnRNb3VzZUJ1dHRvbihlKSkge1xuICAgICAgICB0aGlzLmZvcndhcmQoZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBAdGhpcyB7R2VzdHVyZVJlY29nbml6ZXJ9XG4gICAgICogQHBhcmFtIHtUb3VjaEV2ZW50fSBlXG4gICAgICovXG4gICAgdG91Y2hzdGFydDogZnVuY3Rpb24oZSkge1xuICAgICAgdGhpcy5zYXZlKGUuY2hhbmdlZFRvdWNoZXNbMF0sIGUpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQHRoaXMge0dlc3R1cmVSZWNvZ25pemVyfVxuICAgICAqIEBwYXJhbSB7VG91Y2hFdmVudH0gZVxuICAgICAqL1xuICAgIHRvdWNoZW5kOiBmdW5jdGlvbihlKSB7XG4gICAgICB0aGlzLmZvcndhcmQoZS5jaGFuZ2VkVG91Y2hlc1swXSwgZSk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBAdGhpcyB7R2VzdHVyZVJlY29nbml6ZXJ9XG4gICAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZXZlbnRlclxuICAgICAqL1xuICAgIGZvcndhcmQ6IGZ1bmN0aW9uKGUsIHByZXZlbnRlcikge1xuICAgICAgbGV0IGR4ID0gTWF0aC5hYnMoZS5jbGllbnRYIC0gdGhpcy5pbmZvLngpO1xuICAgICAgbGV0IGR5ID0gTWF0aC5hYnMoZS5jbGllbnRZIC0gdGhpcy5pbmZvLnkpO1xuICAgICAgbGV0IHQgPSBHZXN0dXJlcy5fZmluZE9yaWdpbmFsVGFyZ2V0KGUpO1xuICAgICAgLy8gZHgsZHkgY2FuIGJlIE5hTiBpZiBgY2xpY2tgIGhhcyBiZWVuIHNpbXVsYXRlZCBhbmQgdGhlcmUgd2FzIG5vIGBkb3duYCBmb3IgYHN0YXJ0YFxuICAgICAgaWYgKGlzTmFOKGR4KSB8fCBpc05hTihkeSkgfHwgKGR4IDw9IFRBUF9ESVNUQU5DRSAmJiBkeSA8PSBUQVBfRElTVEFOQ0UpIHx8IGlzU3ludGhldGljQ2xpY2soZSkpIHtcbiAgICAgICAgLy8gcHJldmVudCB0YXBzIGZyb20gYmVpbmcgZ2VuZXJhdGVkIGlmIGFuIGV2ZW50IGhhcyBjYW5jZWxlZCB0aGVtXG4gICAgICAgIGlmICghdGhpcy5pbmZvLnByZXZlbnQpIHtcbiAgICAgICAgICBHZXN0dXJlcy5fZmlyZSh0LCAndGFwJywge1xuICAgICAgICAgICAgeDogZS5jbGllbnRYLFxuICAgICAgICAgICAgeTogZS5jbGllbnRZLFxuICAgICAgICAgICAgc291cmNlRXZlbnQ6IGUsXG4gICAgICAgICAgICBwcmV2ZW50ZXI6IHByZXZlbnRlclxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICAvKiBlc2xpbnQtZW5hYmxlIHZhbGlkLWpzZG9jICovXG5cbiAgLyoqIEBkZXByZWNhdGVkICovXG4gIEdlc3R1cmVzLmZpbmRPcmlnaW5hbFRhcmdldCA9IEdlc3R1cmVzLl9maW5kT3JpZ2luYWxUYXJnZXQ7XG5cbiAgLyoqIEBkZXByZWNhdGVkICovXG4gIEdlc3R1cmVzLmFkZCA9IEdlc3R1cmVzLmFkZExpc3RlbmVyO1xuXG4gIC8qKiBAZGVwcmVjYXRlZCAqL1xuICBHZXN0dXJlcy5yZW1vdmUgPSBHZXN0dXJlcy5yZW1vdmVMaXN0ZW5lcjtcblxuICBQb2x5bWVyLkdlc3R1cmVzID0gR2VzdHVyZXM7XG5cbn0pKCk7XG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvdXRpbHMvZ2VzdHVyZXMuaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cblxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cImJvb3QuaHRtbFwiPlxuXG48c2NyaXB0PlxuXG4oZnVuY3Rpb24oKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIHJ1biBhIGNhbGxiYWNrIHdoZW4gSFRNTEltcG9ydHMgYXJlIHJlYWR5IG9yIGltbWVkaWF0ZWx5IGlmXG4gIC8vIHRoaXMgYXBpIGlzIG5vdCBhdmFpbGFibGUuXG4gIGZ1bmN0aW9uIHdoZW5JbXBvcnRzUmVhZHkoY2IpIHtcbiAgICBpZiAod2luZG93LkhUTUxJbXBvcnRzKSB7XG4gICAgICBIVE1MSW1wb3J0cy53aGVuUmVhZHkoY2IpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYigpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZW5pZW5jZSBtZXRob2QgZm9yIGltcG9ydGluZyBhbiBIVE1MIGRvY3VtZW50IGltcGVyYXRpdmVseS5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgY3JlYXRlcyBhIG5ldyBgPGxpbmsgcmVsPVwiaW1wb3J0XCI+YCBlbGVtZW50IHdpdGhcbiAgICogdGhlIHByb3ZpZGVkIFVSTCBhbmQgYXBwZW5kcyBpdCB0byB0aGUgZG9jdW1lbnQgdG8gc3RhcnQgbG9hZGluZy5cbiAgICogSW4gdGhlIGBvbmxvYWRgIGNhbGxiYWNrLCB0aGUgYGltcG9ydGAgcHJvcGVydHkgb2YgdGhlIGBsaW5rYFxuICAgKiBlbGVtZW50IHdpbGwgY29udGFpbiB0aGUgaW1wb3J0ZWQgZG9jdW1lbnQgY29udGVudHMuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBQb2x5bWVyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBocmVmIFVSTCB0byBkb2N1bWVudCB0byBsb2FkLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uPX0gb25sb2FkIENhbGxiYWNrIHRvIG5vdGlmeSB3aGVuIGFuIGltcG9ydCBzdWNjZXNzZnVsbHlcbiAgICogICBsb2FkZWQuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBvbmVycm9yIENhbGxiYWNrIHRvIG5vdGlmeSB3aGVuIGFuIGltcG9ydFxuICAgKiAgIHVuc3VjY2Vzc2Z1bGx5IGxvYWRlZC5cbiAgICogQHBhcmFtIHtib29sZWFuPX0gb3B0QXN5bmMgVHJ1ZSBpZiB0aGUgaW1wb3J0IHNob3VsZCBiZSBsb2FkZWQgYGFzeW5jYC5cbiAgICogICBEZWZhdWx0cyB0byBgZmFsc2VgLlxuICAgKiBAcmV0dXJuIHtIVE1MTGlua0VsZW1lbnR9IFRoZSBsaW5rIGVsZW1lbnQgZm9yIHRoZSBVUkwgdG8gYmUgbG9hZGVkLlxuICAgKi9cbiAgUG9seW1lci5pbXBvcnRIcmVmID0gZnVuY3Rpb24oaHJlZiwgb25sb2FkLCBvbmVycm9yLCBvcHRBc3luYykge1xuICAgIGxldCBsaW5rID0gLyoqIEB0eXBlIHtIVE1MTGlua0VsZW1lbnR9ICovXG4gICAgICAoZG9jdW1lbnQuaGVhZC5xdWVyeVNlbGVjdG9yKCdsaW5rW2hyZWY9XCInICsgaHJlZiArICdcIl1baW1wb3J0LWhyZWZdJykpO1xuICAgIGlmICghbGluaykge1xuICAgICAgbGluayA9IC8qKiBAdHlwZSB7SFRNTExpbmtFbGVtZW50fSAqLyAoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGluaycpKTtcbiAgICAgIGxpbmsucmVsID0gJ2ltcG9ydCc7XG4gICAgICBsaW5rLmhyZWYgPSBocmVmO1xuICAgICAgbGluay5zZXRBdHRyaWJ1dGUoJ2ltcG9ydC1ocmVmJywgJycpO1xuICAgIH1cbiAgICAvLyBhbHdheXMgZW5zdXJlIGxpbmsgaGFzIGBhc3luY2AgYXR0cmlidXRlIGlmIHVzZXIgc3BlY2lmaWVkIG9uZSxcbiAgICAvLyBldmVuIGlmIGl0IHdhcyBwcmV2aW91c2x5IG5vdCBhc3luYy4gVGhpcyBpcyBjb25zaWRlcmVkIGxlc3MgY29uZnVzaW5nLlxuICAgIGlmIChvcHRBc3luYykge1xuICAgICAgbGluay5zZXRBdHRyaWJ1dGUoJ2FzeW5jJywgJycpO1xuICAgIH1cbiAgICAvLyBOT1RFOiB0aGUgbGluayBtYXkgbm93IGJlIGluIDMgc3RhdGVzOiAoMSkgcGVuZGluZyBpbnNlcnRpb24sXG4gICAgLy8gKDIpIGluZmxpZ2h0LCAoMykgYWxyZWFkeSBsYW9kZWQuIEluIGVhY2ggY2FzZSwgd2UgbmVlZCB0byBhZGRcbiAgICAvLyBldmVudCBsaXN0ZW5lcnMgdG8gcHJvY2VzcyBjYWxsYmFja3MuXG4gICAgbGV0IGNsZWFudXAgPSBmdW5jdGlvbigpIHtcbiAgICAgIGxpbmsucmVtb3ZlRXZlbnRMaXN0ZW5lcignbG9hZCcsIGxvYWRMaXN0ZW5lcik7XG4gICAgICBsaW5rLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgZXJyb3JMaXN0ZW5lcik7XG4gICAgfVxuICAgIGxldCBsb2FkTGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgY2xlYW51cCgpO1xuICAgICAgLy8gSW4gY2FzZSBvZiBhIHN1Y2Nlc3NmdWwgbG9hZCwgY2FjaGUgdGhlIGxvYWQgZXZlbnQgb24gdGhlIGxpbmsgc29cbiAgICAgIC8vIHRoYXQgaXQgY2FuIGJlIHVzZWQgdG8gc2hvcnQtY2lyY3VpdCB0aGlzIG1ldGhvZCBpbiB0aGUgZnV0dXJlIHdoZW5cbiAgICAgIC8vIGl0IGlzIGNhbGxlZCB3aXRoIHRoZSBzYW1lIGhyZWYgcGFyYW0uXG4gICAgICBsaW5rLl9fZHluYW1pY0ltcG9ydExvYWRlZCA9IHRydWU7XG4gICAgICBpZiAob25sb2FkKSB7XG4gICAgICAgIHdoZW5JbXBvcnRzUmVhZHkoKCkgPT4ge1xuICAgICAgICAgIG9ubG9hZChldmVudCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gICAgbGV0IGVycm9yTGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgY2xlYW51cCgpO1xuICAgICAgLy8gSW4gY2FzZSBvZiBhbiBlcnJvciwgcmVtb3ZlIHRoZSBsaW5rIGZyb20gdGhlIGRvY3VtZW50IHNvIHRoYXQgaXRcbiAgICAgIC8vIHdpbGwgYmUgYXV0b21hdGljYWxseSBjcmVhdGVkIGFnYWluIHRoZSBuZXh0IHRpbWUgYGltcG9ydEhyZWZgIGlzXG4gICAgICAvLyBjYWxsZWQuXG4gICAgICBpZiAobGluay5wYXJlbnROb2RlKSB7XG4gICAgICAgIGxpbmsucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChsaW5rKTtcbiAgICAgIH1cbiAgICAgIGlmIChvbmVycm9yKSB7XG4gICAgICAgIHdoZW5JbXBvcnRzUmVhZHkoKCkgPT4ge1xuICAgICAgICAgIG9uZXJyb3IoZXZlbnQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGxpbmsuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIGxvYWRMaXN0ZW5lcik7XG4gICAgbGluay5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGVycm9yTGlzdGVuZXIpO1xuICAgIGlmIChsaW5rLnBhcmVudE5vZGUgPT0gbnVsbCkge1xuICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChsaW5rKTtcbiAgICAvLyBpZiB0aGUgbGluayBhbHJlYWR5IGxvYWRlZCwgZGlzcGF0Y2ggYSBmYWtlIGxvYWQgZXZlbnRcbiAgICAvLyBzbyB0aGF0IGxpc3RlbmVycyBhcmUgY2FsbGVkIGFuZCBnZXQgYSBwcm9wZXIgZXZlbnQgYXJndW1lbnQuXG4gICAgfSBlbHNlIGlmIChsaW5rLl9fZHluYW1pY0ltcG9ydExvYWRlZCkge1xuICAgICAgbGluay5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnbG9hZCcpKTtcbiAgICB9XG4gICAgcmV0dXJuIGxpbms7XG4gIH07XG5cbn0pKCk7XG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvdXRpbHMvaW1wb3J0LWhyZWYuaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCJib290Lmh0bWxcIj5cblxuPHNjcmlwdD5cbihmdW5jdGlvbigpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgbGV0IHNjaGVkdWxlZCA9IGZhbHNlO1xuICBsZXQgYmVmb3JlUmVuZGVyUXVldWUgPSBbXTtcbiAgbGV0IGFmdGVyUmVuZGVyUXVldWUgPSBbXTtcblxuICBmdW5jdGlvbiBzY2hlZHVsZSgpIHtcbiAgICBzY2hlZHVsZWQgPSB0cnVlO1xuICAgIC8vIGJlZm9yZSBuZXh0IHJlbmRlclxuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbigpIHtcbiAgICAgIHNjaGVkdWxlZCA9IGZhbHNlO1xuICAgICAgZmx1c2hRdWV1ZShiZWZvcmVSZW5kZXJRdWV1ZSk7XG4gICAgICAvLyBhZnRlciB0aGUgcmVuZGVyXG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICBydW5RdWV1ZShhZnRlclJlbmRlclF1ZXVlKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZmx1c2hRdWV1ZShxdWV1ZSkge1xuICAgIHdoaWxlIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgIGNhbGxNZXRob2QocXVldWUuc2hpZnQoKSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcnVuUXVldWUocXVldWUpIHtcbiAgICBmb3IgKGxldCBpPTAsIGw9cXVldWUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBjYWxsTWV0aG9kKHF1ZXVlLnNoaWZ0KCkpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbGxNZXRob2QoaW5mbykge1xuICAgIGNvbnN0IGNvbnRleHQgPSBpbmZvWzBdO1xuICAgIGNvbnN0IGNhbGxiYWNrID0gaW5mb1sxXTtcbiAgICBjb25zdCBhcmdzID0gaW5mb1syXTtcbiAgICB0cnkge1xuICAgICAgY2FsbGJhY2suYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgfSBjYXRjaChlKSB7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZmx1c2goKSB7XG4gICAgd2hpbGUgKGJlZm9yZVJlbmRlclF1ZXVlLmxlbmd0aCB8fCBhZnRlclJlbmRlclF1ZXVlLmxlbmd0aCkge1xuICAgICAgZmx1c2hRdWV1ZShiZWZvcmVSZW5kZXJRdWV1ZSk7XG4gICAgICBmbHVzaFF1ZXVlKGFmdGVyUmVuZGVyUXVldWUpO1xuICAgIH1cbiAgICBzY2hlZHVsZWQgPSBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNb2R1bGUgZm9yIHNjaGVkdWxpbmcgZmx1c2hhYmxlIHByZS1yZW5kZXIgYW5kIHBvc3QtcmVuZGVyIHRhc2tzLlxuICAgKlxuICAgKiBAbmFtZXNwYWNlXG4gICAqIEBtZW1iZXJvZiBQb2x5bWVyXG4gICAqIEBzdW1tYXJ5IE1vZHVsZSBmb3Igc2NoZWR1bGluZyBmbHVzaGFibGUgcHJlLXJlbmRlciBhbmQgcG9zdC1yZW5kZXIgdGFza3MuXG4gICAqL1xuICBQb2x5bWVyLlJlbmRlclN0YXR1cyA9IHtcblxuICAgIC8qKlxuICAgICAqIEVucXVldWVzIGEgY2FsbGJhY2sgd2hpY2ggd2lsbCBiZSBydW4gYmVmb3JlIHRoZSBuZXh0IHJlbmRlciwgYXRcbiAgICAgKiBgcmVxdWVzdEFuaW1hdGlvbkZyYW1lYCB0aW1pbmcuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyB1c2VmdWwgZm9yIGVucXVldWluZyB3b3JrIHRoYXQgcmVxdWlyZXMgRE9NIG1lYXN1cmVtZW50LFxuICAgICAqIHNpbmNlIG1lYXN1cmVtZW50IG1heSBub3QgYmUgcmVsaWFibGUgaW4gY3VzdG9tIGVsZW1lbnQgY2FsbGJhY2tzIGJlZm9yZVxuICAgICAqIHRoZSBmaXJzdCByZW5kZXIsIGFzIHdlbGwgYXMgZm9yIGJhdGNoaW5nIG1lYXN1cmVtZW50IHRhc2tzIGluIGdlbmVyYWwuXG4gICAgICpcbiAgICAgKiBUYXNrcyBpbiB0aGlzIHF1ZXVlIG1heSBiZSBmbHVzaGVkIGJ5IGNhbGxpbmcgYFBvbHltZXIuUmVuZGVyU3RhdHVzLmZsdXNoKClgLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIFBvbHltZXIuUmVuZGVyU3RhdHVzXG4gICAgICogQHBhcmFtIHsqfSBjb250ZXh0IENvbnRleHQgb2JqZWN0IHRoZSBjYWxsYmFjayBmdW5jdGlvbiB3aWxsIGJlIGJvdW5kIHRvXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbigpfSBjYWxsYmFjayBDYWxsYmFjayBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgQW4gYXJyYXkgb2YgYXJndW1lbnRzIHRvIGNhbGwgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHdpdGhcbiAgICAgKi9cbiAgICBiZWZvcmVOZXh0UmVuZGVyOiBmdW5jdGlvbihjb250ZXh0LCBjYWxsYmFjaywgYXJncykge1xuICAgICAgaWYgKCFzY2hlZHVsZWQpIHtcbiAgICAgICAgc2NoZWR1bGUoKTtcbiAgICAgIH1cbiAgICAgIGJlZm9yZVJlbmRlclF1ZXVlLnB1c2goW2NvbnRleHQsIGNhbGxiYWNrLCBhcmdzXSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEVucXVldWVzIGEgY2FsbGJhY2sgd2hpY2ggd2lsbCBiZSBydW4gYWZ0ZXIgdGhlIG5leHQgcmVuZGVyLCBlcXVpdmFsZW50XG4gICAgICogdG8gb25lIHRhc2sgKGBzZXRUaW1lb3V0YCkgYWZ0ZXIgdGhlIG5leHQgYHJlcXVlc3RBbmltYXRpb25GcmFtZWAuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyB1c2VmdWwgZm9yIHR1bmluZyB0aGUgZmlyc3QtcmVuZGVyIHBlcmZvcm1hbmNlIG9mIGFuXG4gICAgICogZWxlbWVudCBvciBhcHBsaWNhdGlvbiBieSBkZWZlcnJpbmcgbm9uLWNyaXRpY2FsIHdvcmsgdW50aWwgYWZ0ZXIgdGhlXG4gICAgICogZmlyc3QgcGFpbnQuICBUeXBpY2FsIG5vbi1yZW5kZXItY3JpdGljYWwgd29yayBtYXkgaW5jbHVkZSBhZGRpbmcgVUlcbiAgICAgKiBldmVudCBsaXN0ZW5lcnMgYW5kIGFyaWEgYXR0cmlidXRlcy5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBQb2x5bWVyLlJlbmRlclN0YXR1c1xuICAgICAqIEBwYXJhbSB7Kn0gY29udGV4dCBDb250ZXh0IG9iamVjdCB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gd2lsbCBiZSBib3VuZCB0b1xuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oKX0gY2FsbGJhY2sgQ2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcmdzIEFuIGFycmF5IG9mIGFyZ3VtZW50cyB0byBjYWxsIHRoZSBjYWxsYmFjayBmdW5jdGlvbiB3aXRoXG4gICAgICovXG4gICAgYWZ0ZXJOZXh0UmVuZGVyOiBmdW5jdGlvbihjb250ZXh0LCBjYWxsYmFjaywgYXJncykge1xuICAgICAgaWYgKCFzY2hlZHVsZWQpIHtcbiAgICAgICAgc2NoZWR1bGUoKTtcbiAgICAgIH1cbiAgICAgIGFmdGVyUmVuZGVyUXVldWUucHVzaChbY29udGV4dCwgY2FsbGJhY2ssIGFyZ3NdKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmx1c2hlcyBhbGwgYGJlZm9yZU5leHRSZW5kZXJgIHRhc2tzLCBmb2xsb3dlZCBieSBhbGwgYGFmdGVyTmV4dFJlbmRlcmBcbiAgICAgKiB0YXNrcy5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBQb2x5bWVyLlJlbmRlclN0YXR1c1xuICAgICAqL1xuICAgIGZsdXNoOiBmbHVzaFxuXG4gIH07XG5cbn0pKCk7XG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvdXRpbHMvcmVuZGVyLXN0YXR1cy5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuPHNjcmlwdD5cbihmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIHVucmVzb2x2ZWRcblxuICBmdW5jdGlvbiByZXNvbHZlKCkge1xuICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQXR0cmlidXRlKCd1bnJlc29sdmVkJyk7XG4gIH1cblxuICBpZiAod2luZG93LldlYkNvbXBvbmVudHMpIHtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignV2ViQ29tcG9uZW50c1JlYWR5JywgcmVzb2x2ZSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdpbnRlcmFjdGl2ZScgfHwgZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gJ2NvbXBsZXRlJykge1xuICAgICAgcmVzb2x2ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIHJlc29sdmUpO1xuICAgIH1cbiAgfVxuXG59KSgpO1xuPC9zY3JpcHQ+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL3BvbHltZXIvbGliL3V0aWxzL3VucmVzb2x2ZWQuaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi91dGlscy9ib290Lmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi91dGlscy9zZXR0aW5ncy5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vdXRpbHMvZmxhdHRlbmVkLW5vZGVzLW9ic2VydmVyLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi91dGlscy9mbHVzaC5odG1sXCI+XG48c2NyaXB0PlxuKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgY29uc3QgcCA9IEVsZW1lbnQucHJvdG90eXBlO1xuICAvKipcbiAgICogQGNvbnN0IHtmdW5jdGlvbih0aGlzOkVsZW1lbnQsIHN0cmluZyk6IGJvb2xlYW59XG4gICAqL1xuICBjb25zdCBub3JtYWxpemVkTWF0Y2hlc1NlbGVjdG9yID0gcC5tYXRjaGVzIHx8IHAubWF0Y2hlc1NlbGVjdG9yIHx8XG4gICAgcC5tb3pNYXRjaGVzU2VsZWN0b3IgfHwgcC5tc01hdGNoZXNTZWxlY3RvciB8fFxuICAgIHAub01hdGNoZXNTZWxlY3RvciB8fCBwLndlYmtpdE1hdGNoZXNTZWxlY3RvcjtcblxuICAvKipcbiAgICogQ3Jvc3MtcGxhdGZvcm0gYGVsZW1lbnQubWF0Y2hlc2Agc2hpbS5cbiAgICpcbiAgICogQGZ1bmN0aW9uIG1hdGNoZXNTZWxlY3RvclxuICAgKiBAbWVtYmVyb2YgUG9seW1lci5kb21cbiAgICogQHBhcmFtIHshRWxlbWVudH0gbm9kZSBOb2RlIHRvIGNoZWNrIHNlbGVjdG9yIGFnYWluc3RcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yIFNlbGVjdG9yIHRvIG1hdGNoXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgbm9kZSBtYXRjaGVkIHNlbGVjdG9yXG4gICAqL1xuICBjb25zdCBtYXRjaGVzU2VsZWN0b3IgPSBmdW5jdGlvbihub2RlLCBzZWxlY3Rvcikge1xuICAgIHJldHVybiBub3JtYWxpemVkTWF0Y2hlc1NlbGVjdG9yLmNhbGwobm9kZSwgc2VsZWN0b3IpO1xuICB9XG5cbiAgLyoqXG4gICAqIE5vZGUgQVBJIHdyYXBwZXIgY2xhc3MgcmV0dXJuZWQgZnJvbSBgUG9seW1lci5kb20uKHRhcmdldClgIHdoZW5cbiAgICogYHRhcmdldGAgaXMgYSBgTm9kZWAuXG4gICAqL1xuICBjbGFzcyBEb21BcGkge1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlIE5vZGUgZm9yIHdoaWNoIHRvIGNyZWF0ZSBhIFBvbHltZXIuZG9tIGhlbHBlciBvYmplY3QuXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iobm9kZSkge1xuICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGluc3RhbmNlIG9mIGBQb2x5bWVyLkZsYXR0ZW5lZE5vZGVzT2JzZXJ2ZXJgIHRoYXRcbiAgICAgKiBsaXN0ZW5zIGZvciBub2RlIGNoYW5nZXMgb24gdGhpcyBlbGVtZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIHdoZW4gZGlyZWN0IG9yIGRpc3RyaWJ1dGVkIGNoaWxkcmVuXG4gICAgICogICBvZiB0aGlzIGVsZW1lbnQgY2hhbmdlc1xuICAgICAqIEByZXR1cm4ge1BvbHltZXIuRmxhdHRlbmVkTm9kZXNPYnNlcnZlcn0gT2JzZXJ2ZXIgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBvYnNlcnZlTm9kZXMoY2FsbGJhY2spIHtcbiAgICAgIHJldHVybiBuZXcgUG9seW1lci5GbGF0dGVuZWROb2Rlc09ic2VydmVyKHRoaXMubm9kZSwgY2FsbGJhY2spO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERpc2Nvbm5lY3RzIGFuIG9ic2VydmVyIHByZXZpb3VzbHkgY3JlYXRlZCB2aWEgYG9ic2VydmVOb2Rlc2BcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UG9seW1lci5GbGF0dGVuZWROb2Rlc09ic2VydmVyfSBvYnNlcnZlckhhbmRsZSBPYnNlcnZlciBpbnN0YW5jZVxuICAgICAqICAgdG8gZGlzY29ubmVjdC5cbiAgICAgKi9cbiAgICB1bm9ic2VydmVOb2RlcyhvYnNlcnZlckhhbmRsZSkge1xuICAgICAgb2JzZXJ2ZXJIYW5kbGUuZGlzY29ubmVjdCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByb3ZpZGVkIGFzIGEgYmFja3dhcmRzLWNvbXBhdGlibGUgQVBJIG9ubHkuICBUaGlzIG1ldGhvZCBkb2VzIG5vdGhpbmcuXG4gICAgICovXG4gICAgbm90aWZ5T2JzZXJ2ZXIoKSB7fVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBwcm92aWRlZCBub2RlIGlzIGNvbnRhaW5lZCB3aXRoIHRoaXMgZWxlbWVudCdzXG4gICAgICogbGlnaHQtRE9NIGNoaWxkcmVuIG9yIHNoYWRvdyByb290LCBpbmNsdWRpbmcgYW55IG5lc3RlZCBzaGFkb3cgcm9vdHNcbiAgICAgKiBvZiBjaGlsZHJlbiB0aGVyZWluLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlIE5vZGUgdG8gdGVzdFxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gYG5vZGVgIGlzIGNvbnRhaW5lZCB3aXRoaW5cbiAgICAgKiAgIHRoaXMgZWxlbWVudCdzIGxpZ2h0IG9yIHNoYWRvdyBET00uXG4gICAgICovXG4gICAgZGVlcENvbnRhaW5zKG5vZGUpIHtcbiAgICAgIGlmICh0aGlzLm5vZGUuY29udGFpbnMobm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBsZXQgbiA9IG5vZGU7XG4gICAgICBsZXQgZG9jID0gbm9kZS5vd25lckRvY3VtZW50O1xuICAgICAgLy8gd2FsayBmcm9tIG5vZGUgdG8gYHRoaXNgIG9yIGBkb2N1bWVudGBcbiAgICAgIHdoaWxlIChuICYmIG4gIT09IGRvYyAmJiBuICE9PSB0aGlzLm5vZGUpIHtcbiAgICAgICAgLy8gdXNlIGxvZ2ljYWwgcGFyZW50bm9kZSwgb3IgbmF0aXZlIFNoYWRvd1Jvb3QgaG9zdFxuICAgICAgICBuID0gbi5wYXJlbnROb2RlIHx8IG4uaG9zdDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuID09PSB0aGlzLm5vZGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcm9vdCBub2RlIG9mIHRoaXMgbm9kZS4gIEVxdWl2YWxlbnQgdG8gYGdldFJvb2ROb2RlKClgLlxuICAgICAqXG4gICAgICogQHJldHVybiB7Tm9kZX0gVG9wIG1vc3QgZWxlbWVudCBpbiB0aGUgZG9tIHRyZWUgaW4gd2hpY2ggdGhlIG5vZGVcbiAgICAgKiBleGlzdHMuIElmIHRoZSBub2RlIGlzIGNvbm5lY3RlZCB0byBhIGRvY3VtZW50IHRoaXMgaXMgZWl0aGVyIGFcbiAgICAgKiBzaGFkb3dSb290IG9yIHRoZSBkb2N1bWVudDsgb3RoZXJ3aXNlLCBpdCBtYXkgYmUgdGhlIG5vZGVcbiAgICAgKiBpdHNlbGYgb3IgYSBub2RlIG9yIGRvY3VtZW50IGZyYWdtZW50IGNvbnRhaW5pbmcgaXQuXG4gICAgICovXG4gICAgZ2V0T3duZXJSb290KCkge1xuICAgICAgcmV0dXJuIHRoaXMubm9kZS5nZXRSb290Tm9kZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZvciBzbG90IGVsZW1lbnRzLCByZXR1cm5zIHRoZSBub2RlcyBhc3NpZ25lZCB0byB0aGUgc2xvdDsgb3RoZXJ3aXNlXG4gICAgICogYW4gZW1wdHkgYXJyYXkuIEl0IGlzIGVxdWl2YWxlbnQgdG8gYDxzbG90Pi5hZGRpZ25lZE5vZGVzKHtmbGF0dGVuOnRydWV9KWAuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtBcnJheTxOb2RlPn0gQXJyYXkgb2YgYXNzaWduZWQgbm9kZXNcbiAgICAgKi9cbiAgICBnZXREaXN0cmlidXRlZE5vZGVzKCkge1xuICAgICAgcmV0dXJuICh0aGlzLm5vZGUubG9jYWxOYW1lID09PSAnc2xvdCcpID9cbiAgICAgICAgdGhpcy5ub2RlLmFzc2lnbmVkTm9kZXMoe2ZsYXR0ZW46IHRydWV9KSA6XG4gICAgICAgIFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gYXJyYXkgb2YgYWxsIHNsb3RzIHRoaXMgZWxlbWVudCB3YXMgZGlzdHJpYnV0ZWQgdG8uXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtBcnJheTxIVE1MU2xvdEVsZW1lbnQ+fSBEZXNjcmlwdGlvblxuICAgICAqL1xuICAgIGdldERlc3RpbmF0aW9uSW5zZXJ0aW9uUG9pbnRzKCkge1xuICAgICAgbGV0IGlwJCA9IFtdO1xuICAgICAgbGV0IG4gPSB0aGlzLm5vZGUuYXNzaWduZWRTbG90O1xuICAgICAgd2hpbGUgKG4pIHtcbiAgICAgICAgaXAkLnB1c2gobik7XG4gICAgICAgIG4gPSBuLmFzc2lnbmVkU2xvdDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpcCQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbHMgYGltcG9ydE5vZGVgIG9uIHRoZSBgb3duZXJEb2N1bWVudGAgZm9yIHRoaXMgbm9kZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBOb2RlIHRvIGltcG9ydFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZGVlcCBUcnVlIGlmIHRoZSBub2RlIHNob3VsZCBiZSBjbG9uZWQgZGVlcGx5IGR1cmluZ1xuICAgICAqICAgaW1wb3J0XG4gICAgICogQHJldHVybiB7Tm9kZX0gQ2xvbmUgb2YgZ2l2ZW4gbm9kZSBpbXBvcnRlZCB0byB0aGlzIG93bmVyIGRvY3VtZW50XG4gICAgICovXG4gICAgaW1wb3J0Tm9kZShub2RlLCBkZWVwKSB7XG4gICAgICBsZXQgZG9jID0gdGhpcy5ub2RlIGluc3RhbmNlb2YgRG9jdW1lbnQgPyB0aGlzLm5vZGUgOlxuICAgICAgICB0aGlzLm5vZGUub3duZXJEb2N1bWVudDtcbiAgICAgIHJldHVybiBkb2MuaW1wb3J0Tm9kZShub2RlLCBkZWVwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gUmV0dXJucyBhIGZsYXR0ZW5lZCBsaXN0IG9mIGFsbCBjaGlsZCBub2RlcyBhbmQgbm9kZXMgYXNzaWduZWRcbiAgICAgKiB0byBjaGlsZCBzbG90cy5cbiAgICAgKi9cbiAgICBnZXRFZmZlY3RpdmVDaGlsZE5vZGVzKCkge1xuICAgICAgcmV0dXJuIFBvbHltZXIuRmxhdHRlbmVkTm9kZXNPYnNlcnZlci5nZXRGbGF0dGVuZWROb2Rlcyh0aGlzLm5vZGUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBmaWx0ZXJlZCBsaXN0IG9mIGZsYXR0ZW5lZCBjaGlsZCBlbGVtZW50cyBmb3IgdGhpcyBlbGVtZW50IGJhc2VkXG4gICAgICogb24gdGhlIGdpdmVuIHNlbGVjdG9yLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yIFNlbGVjdG9yIHRvIGZpbHRlciBub2RlcyBhZ2FpbnN0XG4gICAgICogQHJldHVybiB7QXJyYXk8SFRNTEVsZW1lbnQ+fSBMaXN0IG9mIGZsYXR0ZW5lZCBjaGlsZCBlbGVtZW50c1xuICAgICAqL1xuICAgIHF1ZXJ5RGlzdHJpYnV0ZWRFbGVtZW50cyhzZWxlY3Rvcikge1xuICAgICAgbGV0IGMkID0gdGhpcy5nZXRFZmZlY3RpdmVDaGlsZE5vZGVzKCk7XG4gICAgICBsZXQgbGlzdCA9IFtdO1xuICAgICAgZm9yIChsZXQgaT0wLCBsPWMkLmxlbmd0aCwgYzsgKGk8bCkgJiYgKGM9YyRbaV0pOyBpKyspIHtcbiAgICAgICAgaWYgKChjLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSkgJiZcbiAgICAgICAgICAgIG1hdGNoZXNTZWxlY3RvcihjLCBzZWxlY3RvcikpIHtcbiAgICAgICAgICBsaXN0LnB1c2goYyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBsaXN0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZvciBzaGFkb3cgcm9vdHMsIHJldHVybnMgdGhlIGN1cnJlbnRseSBmb2N1c2VkIGVsZW1lbnQgd2l0aGluIHRoaXNcbiAgICAgKiBzaGFkb3cgcm9vdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge05vZGV8dW5kZWZpbmVkfSBDdXJyZW50bHkgZm9jdXNlZCBlbGVtZW50XG4gICAgICovXG4gICAgZ2V0IGFjdGl2ZUVsZW1lbnQoKSB7XG4gICAgICBsZXQgbm9kZSA9IHRoaXMubm9kZTtcbiAgICAgIHJldHVybiBub2RlLl9hY3RpdmVFbGVtZW50ICE9PSB1bmRlZmluZWQgPyBub2RlLl9hY3RpdmVFbGVtZW50IDogbm9kZS5hY3RpdmVFbGVtZW50O1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcndhcmRNZXRob2RzKHByb3RvLCBtZXRob2RzKSB7XG4gICAgZm9yIChsZXQgaT0wOyBpIDwgbWV0aG9kcy5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IG1ldGhvZCA9IG1ldGhvZHNbaV07XG4gICAgICBwcm90b1ttZXRob2RdID0gLyoqIEB0aGlzIHtEb21BcGl9ICovIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ub2RlW21ldGhvZF0uYXBwbHkodGhpcy5ub2RlLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcndhcmRSZWFkT25seVByb3BlcnRpZXMocHJvdG8sIHByb3BlcnRpZXMpIHtcbiAgICBmb3IgKGxldCBpPTA7IGkgPCBwcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgbmFtZSA9IHByb3BlcnRpZXNbaV07XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG8sIG5hbWUsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gLyoqIEB0eXBlIHtEb21BcGl9ICovICh0aGlzKS5ub2RlW25hbWVdO1xuICAgICAgICB9LFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcndhcmRQcm9wZXJ0aWVzKHByb3RvLCBwcm9wZXJ0aWVzKSB7XG4gICAgZm9yIChsZXQgaT0wOyBpIDwgcHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IG5hbWUgPSBwcm9wZXJ0aWVzW2ldO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvLCBuYW1lLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIC8qKiBAdHlwZSB7RG9tQXBpfSAqLyAodGhpcykubm9kZVtuYW1lXTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgIC8qKiBAdHlwZSB7RG9tQXBpfSAqLyAodGhpcykubm9kZVtuYW1lXSA9IHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGZvcndhcmRNZXRob2RzKERvbUFwaS5wcm90b3R5cGUsIFtcbiAgICAnY2xvbmVOb2RlJywgJ2FwcGVuZENoaWxkJywgJ2luc2VydEJlZm9yZScsICdyZW1vdmVDaGlsZCcsXG4gICAgJ3JlcGxhY2VDaGlsZCcsICdzZXRBdHRyaWJ1dGUnLCAncmVtb3ZlQXR0cmlidXRlJyxcbiAgICAncXVlcnlTZWxlY3RvcicsICdxdWVyeVNlbGVjdG9yQWxsJ1xuICBdKTtcblxuICBmb3J3YXJkUmVhZE9ubHlQcm9wZXJ0aWVzKERvbUFwaS5wcm90b3R5cGUsIFtcbiAgICAncGFyZW50Tm9kZScsICdmaXJzdENoaWxkJywgJ2xhc3RDaGlsZCcsXG4gICAgJ25leHRTaWJsaW5nJywgJ3ByZXZpb3VzU2libGluZycsICdmaXJzdEVsZW1lbnRDaGlsZCcsXG4gICAgJ2xhc3RFbGVtZW50Q2hpbGQnLCAnbmV4dEVsZW1lbnRTaWJsaW5nJywgJ3ByZXZpb3VzRWxlbWVudFNpYmxpbmcnLFxuICAgICdjaGlsZE5vZGVzJywgJ2NoaWxkcmVuJywgJ2NsYXNzTGlzdCdcbiAgXSk7XG5cbiAgZm9yd2FyZFByb3BlcnRpZXMoRG9tQXBpLnByb3RvdHlwZSwgW1xuICAgICd0ZXh0Q29udGVudCcsICdpbm5lckhUTUwnXG4gIF0pO1xuXG5cbiAgLyoqXG4gICAqIEV2ZW50IEFQSSB3cmFwcGVyIGNsYXNzIHJldHVybmVkIGZyb20gYFBvbHltZXIuZG9tLih0YXJnZXQpYCB3aGVuXG4gICAqIGB0YXJnZXRgIGlzIGFuIGBFdmVudGAuXG4gICAqL1xuICBjbGFzcyBFdmVudEFwaSB7XG4gICAgY29uc3RydWN0b3IoZXZlbnQpIHtcbiAgICAgIHRoaXMuZXZlbnQgPSBldmVudDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBmaXJzdCBub2RlIG9uIHRoZSBgY29tcG9zZWRQYXRoYCBvZiB0aGlzIGV2ZW50LlxuICAgICAqXG4gICAgICogQHJldHVybiB7Tm9kZX0gVGhlIG5vZGUgdGhpcyBldmVudCB3YXMgZGlzcGF0Y2hlZCB0b1xuICAgICAqL1xuICAgIGdldCByb290VGFyZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuZXZlbnQuY29tcG9zZWRQYXRoKClbMF07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbG9jYWwgKHJlLXRhcmdldGVkKSB0YXJnZXQgZm9yIHRoaXMgZXZlbnQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtOb2RlfSBUaGUgbG9jYWwgKHJlLXRhcmdldGVkKSB0YXJnZXQgZm9yIHRoaXMgZXZlbnQuXG4gICAgICovXG4gICAgZ2V0IGxvY2FsVGFyZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuZXZlbnQudGFyZ2V0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGBjb21wb3NlZFBhdGhgIGZvciB0aGlzIGV2ZW50LlxuICAgICAqL1xuICAgIGdldCBwYXRoKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZXZlbnQuY29tcG9zZWRQYXRoKCk7XG4gICAgfVxuICB9XG5cbiAgUG9seW1lci5Eb21BcGkgPSBEb21BcGk7XG5cbiAgLyoqXG4gICAqIExlZ2FjeSBET00gYW5kIEV2ZW50IG1hbmlwdWxhdGlvbiBBUEkgd3JhcHBlciBmYWN0b3J5IHVzZWQgdG8gYWJzdHJhY3RcbiAgICogZGlmZmVyZW5jZXMgYmV0d2VlbiBuYXRpdmUgU2hhZG93IERPTSBhbmQgXCJTaGFkeSBET01cIiB3aGVuIHBvbHlmaWxsaW5nIG9uXG4gICAqIG9sZGVyIGJyb3dzZXJzLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgaW4gUG9seW1lciAyLnggdXNlIG9mIGBQb2x5bWVyLmRvbWAgaXMgbm8gbG9uZ2VyIHJlcXVpcmVkIGFuZFxuICAgKiBpbiB0aGUgbWFqb3JpdHkgb2YgY2FzZXMgc2ltcGx5IGZhY2FkZXMgZGlyZWN0bHkgdG8gdGhlIHN0YW5kYXJkIG5hdGl2ZVxuICAgKiBBUEkuXG4gICAqXG4gICAqIEBuYW1lc3BhY2VcbiAgICogQHN1bW1hcnkgTGVnYWN5IERPTSBhbmQgRXZlbnQgbWFuaXB1bGF0aW9uIEFQSSB3cmFwcGVyIGZhY3RvcnkgdXNlZCB0b1xuICAgKiBhYnN0cmFjdCBkaWZmZXJlbmNlcyBiZXR3ZWVuIG5hdGl2ZSBTaGFkb3cgRE9NIGFuZCBcIlNoYWR5IERPTS5cIlxuICAgKiBAbWVtYmVyb2YgUG9seW1lclxuICAgKiBAcGFyYW0geyFOb2RlfEV2ZW50fSBvYmogTm9kZSBvciBldmVudCB0byBvcGVyYXRlIG9uXG4gICAqIEByZXR1cm4ge0RvbUFwaXxFdmVudEFwaX0gV3JhcHBlciBwcm92aWRpbmcgZWl0aGVyIG5vZGUgQVBJIG9yIGV2ZW50IEFQSVxuICAgKi9cbiAgUG9seW1lci5kb20gPSBmdW5jdGlvbihvYmopIHtcbiAgICBvYmogPSBvYmogfHwgZG9jdW1lbnQ7XG4gICAgaWYgKCFvYmouX19kb21BcGkpIHtcbiAgICAgIGxldCBoZWxwZXI7XG4gICAgICBpZiAob2JqIGluc3RhbmNlb2YgRXZlbnQpIHtcbiAgICAgICAgaGVscGVyID0gbmV3IEV2ZW50QXBpKG9iaik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoZWxwZXIgPSBuZXcgRG9tQXBpKG9iaik7XG4gICAgICB9XG4gICAgICBvYmouX19kb21BcGkgPSBoZWxwZXI7XG4gICAgfVxuICAgIHJldHVybiBvYmouX19kb21BcGk7XG4gIH07XG5cbiAgUG9seW1lci5kb20ubWF0Y2hlc1NlbGVjdG9yID0gbWF0Y2hlc1NlbGVjdG9yO1xuXG4gIC8qKlxuICAgKiBGb3JjZXMgc2V2ZXJhbCBjbGFzc2VzIG9mIGFzeW5jaHJvbm91c2x5IHF1ZXVlZCB0YXNrcyB0byBmbHVzaDpcbiAgICogLSBEZWJvdW5jZXJzIGFkZGVkIHZpYSBgUG9seW1lci5lbnF1ZXVlRGVib3VuY2VyYFxuICAgKiAtIFNoYWR5RE9NIGRpc3RyaWJ1dGlvblxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBmYWNhZGVzIHRvIGBQb2x5bWVyLmZsdXNoYC5cbiAgICpcbiAgICogQG1lbWJlcm9mIFBvbHltZXIuZG9tXG4gICAqL1xuICBQb2x5bWVyLmRvbS5mbHVzaCA9IFBvbHltZXIuZmx1c2g7XG5cbiAgLyoqXG4gICAqIEFkZHMgYSBgUG9seW1lci5EZWJvdW5jZXJgIHRvIGEgbGlzdCBvZiBnbG9iYWxseSBmbHVzaGFibGUgdGFza3MuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGZhY2FkZXMgdG8gYFBvbHltZXIuZW5xdWV1ZURlYm91bmNlcmAuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBQb2x5bWVyLmRvbVxuICAgKiBAcGFyYW0ge1BvbHltZXIuRGVib3VuY2VyfSBkZWJvdW5jZXIgRGVib3VuY2VyIHRvIGVucXVldWVcbiAgICovXG4gIFBvbHltZXIuZG9tLmFkZERlYm91bmNlciA9IFBvbHltZXIuZW5xdWV1ZURlYm91bmNlcjtcbn0pKCk7XG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvbGVnYWN5L3BvbHltZXIuZG9tLmh0bWwiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vdXRpbHMvYm9vdC5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vdXRpbHMvYXJyYXktc3BsaWNlLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi91dGlscy9hc3luYy5odG1sXCI+XG48c2NyaXB0PlxuKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBgbm9kZWAgaXMgYSBzbG90IGVsZW1lbnRcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gbm9kZSBOb2RlIHRvIHRlc3QuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gYG5vZGVgIGlzIGEgc2xvdFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gaXNTbG90KG5vZGUpIHtcbiAgICByZXR1cm4gKG5vZGUubG9jYWxOYW1lID09PSAnc2xvdCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIENsYXNzIHRoYXQgbGlzdGVucyBmb3IgY2hhbmdlcyAoYWRkaXRpb25zIG9yIHJlbW92YWxzKSB0b1xuICAgKiBcImZsYXR0ZW5lZCBub2Rlc1wiIG9uIGEgZ2l2ZW4gYG5vZGVgLiBUaGUgbGlzdCBvZiBmbGF0dGVuZWQgbm9kZXMgY29uc2lzdHNcbiAgICogb2YgYSBub2RlJ3MgY2hpbGRyZW4gYW5kLCBmb3IgYW55IGNoaWxkcmVuIHRoYXQgYXJlIGA8c2xvdD5gIGVsZW1lbnRzLFxuICAgKiB0aGUgZXhwYW5kZWQgZmxhdHRlbmVkIGxpc3Qgb2YgYGFzc2lnbmVkTm9kZXNgLlxuICAgKiBGb3IgZXhhbXBsZSwgaWYgdGhlIG9ic2VydmVkIG5vZGUgaGFzIGNoaWxkcmVuIGA8YT48L2E+PHNsb3Q+PC9zbG90PjxiPjwvYj5gXG4gICAqIGFuZCB0aGUgYDxzbG90PmAgaGFzIG9uZSBgPGRpdj5gIGFzc2lnbmVkIHRvIGl0LCB0aGVuIHRoZSBmbGF0dGVuZWRcbiAgICogbm9kZXMgbGlzdCBpcyBgPGE+PC9hPjxkaXY+PC9kaXY+PGI+PC9iPmAuIElmIHRoZSBgPHNsb3Q+YCBoYXMgb3RoZXJcbiAgICogYDxzbG90PmAgZWxlbWVudHMgYXNzaWduZWQgdG8gaXQsIHRoZXNlIGFyZSBmbGF0dGVuZWQgYXMgd2VsbC5cbiAgICpcbiAgICogVGhlIHByb3ZpZGVkIGBjYWxsYmFja2AgaXMgY2FsbGVkIHdoZW5ldmVyIGFueSBjaGFuZ2UgdG8gdGhpcyBsaXN0XG4gICAqIG9mIGZsYXR0ZW5lZCBub2RlcyBvY2N1cnMsIHdoZXJlIGFuIGFkZGl0aW9uIG9yIHJlbW92YWwgb2YgYSBub2RlIGlzXG4gICAqIGNvbnNpZGVyZWQgYSBjaGFuZ2UuIFRoZSBgY2FsbGJhY2tgIGlzIGNhbGxlZCB3aXRoIG9uZSBhcmd1bWVudCwgYW4gb2JqZWN0XG4gICAqIGNvbnRhaW5pbmcgYW4gYXJyYXkgb2YgYW55IGBhZGRlZE5vZGVzYCBhbmQgYHJlbW92ZWROb2Rlc2AuXG4gICAqXG4gICAqIE5vdGU6IHRoZSBjYWxsYmFjayBpcyBjYWxsZWQgYXN5bmNocm9ub3VzIHRvIGFueSBjaGFuZ2VzXG4gICAqIGF0IGEgbWljcm90YXNrIGNoZWNrcG9pbnQuIFRoaXMgaXMgYmVjYXVzZSBvYnNlcnZhdGlvbiBpcyBwZXJmb3JtZWQgdXNpbmdcbiAgICogYE11dGF0aW9uT2JzZXJ2ZXJgIGFuZCB0aGUgYDxzbG90PmAgZWxlbWVudCdzIGBzbG90Y2hhbmdlYCBldmVudCB3aGljaFxuICAgKiBhcmUgYXN5bmNocm9ub3VzLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgUG9seW1lclxuICAgKiBAc3VtbWFyeSBDbGFzcyB0aGF0IGxpc3RlbnMgZm9yIGNoYW5nZXMgKGFkZGl0aW9ucyBvciByZW1vdmFscykgdG9cbiAgICogXCJmbGF0dGVuZWQgbm9kZXNcIiBvbiBhIGdpdmVuIGBub2RlYC5cbiAgICovXG4gIGNsYXNzIEZsYXR0ZW5lZE5vZGVzT2JzZXJ2ZXIge1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbGlzdCBvZiBmbGF0dGVuZWQgbm9kZXMgZm9yIHRoZSBnaXZlbiBgbm9kZWAuXG4gICAgICogVGhpcyBsaXN0IGNvbnNpc3RzIG9mIGEgbm9kZSdzIGNoaWxkcmVuIGFuZCwgZm9yIGFueSBjaGlsZHJlblxuICAgICAqIHRoYXQgYXJlIGA8c2xvdD5gIGVsZW1lbnRzLCB0aGUgZXhwYW5kZWQgZmxhdHRlbmVkIGxpc3Qgb2YgYGFzc2lnbmVkTm9kZXNgLlxuICAgICAqIEZvciBleGFtcGxlLCBpZiB0aGUgb2JzZXJ2ZWQgbm9kZSBoYXMgY2hpbGRyZW4gYDxhPjwvYT48c2xvdD48L3Nsb3Q+PGI+PC9iPmBcbiAgICAgKiBhbmQgdGhlIGA8c2xvdD5gIGhhcyBvbmUgYDxkaXY+YCBhc3NpZ25lZCB0byBpdCwgdGhlbiB0aGUgZmxhdHRlbmVkXG4gICAgICogbm9kZXMgbGlzdCBpcyBgPGE+PC9hPjxkaXY+PC9kaXY+PGI+PC9iPmAuIElmIHRoZSBgPHNsb3Q+YCBoYXMgb3RoZXJcbiAgICAgKiBgPHNsb3Q+YCBlbGVtZW50cyBhc3NpZ25lZCB0byBpdCwgdGhlc2UgYXJlIGZsYXR0ZW5lZCBhcyB3ZWxsLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudHxIVE1MU2xvdEVsZW1lbnR9IG5vZGUgVGhlIG5vZGUgZm9yIHdoaWNoIHRvIHJldHVybiB0aGUgbGlzdCBvZiBmbGF0dGVuZWQgbm9kZXMuXG4gICAgICogQHJldHVybiB7QXJyYXl9IFRoZSBsaXN0IG9mIGZsYXR0ZW5lZCBub2RlcyBmb3IgdGhlIGdpdmVuIGBub2RlYC5cbiAgICAqL1xuICAgIHN0YXRpYyBnZXRGbGF0dGVuZWROb2Rlcyhub2RlKSB7XG4gICAgICBpZiAoaXNTbG90KG5vZGUpKSB7XG4gICAgICAgIHJldHVybiAvKiogQHR5cGUge0hUTUxTbG90RWxlbWVudH0gKi8gKG5vZGUpLmFzc2lnbmVkTm9kZXMoe2ZsYXR0ZW46IHRydWV9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKG5vZGUuY2hpbGROb2RlcykubWFwKG5vZGUgPT4ge1xuICAgICAgICAgIGlmIChpc1Nsb3Qobm9kZSkpIHtcbiAgICAgICAgICAgIHJldHVybiAvKiogQHR5cGUge0hUTUxTbG90RWxlbWVudH0gKi8gKG5vZGUpLmFzc2lnbmVkTm9kZXMoe2ZsYXR0ZW46IHRydWV9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFtub2RlXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pLnJlZHVjZSgoYSwgYikgPT4gYS5jb25jYXQoYiksIFtdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge05vZGV9IHRhcmdldCBOb2RlIG9uIHdoaWNoIHRvIGxpc3RlbiBmb3IgY2hhbmdlcy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBGdW5jdGlvbiBjYWxsZWQgd2hlbiB0aGVyZSBhcmUgYWRkaXRpb25zXG4gICAgICogb3IgcmVtb3ZhbHMgZnJvbSB0aGUgdGFyZ2V0J3MgbGlzdCBvZiBmbGF0dGVuZWQgbm9kZXMuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXQsIGNhbGxiYWNrKSB7XG4gICAgICAvKiogQHR5cGUge011dGF0aW9uT2JzZXJ2ZXJ9ICovXG4gICAgICB0aGlzLl9zaGFkeUNoaWxkcmVuT2JzZXJ2ZXIgPSBudWxsO1xuICAgICAgLyoqIEB0eXBlIHtNdXRhdGlvbk9ic2VydmVyfSAqL1xuICAgICAgdGhpcy5fbmF0aXZlQ2hpbGRyZW5PYnNlcnZlciA9IG51bGw7XG4gICAgICB0aGlzLl9jb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuX3RhcmdldCA9IHRhcmdldDtcbiAgICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgIHRoaXMuX2VmZmVjdGl2ZU5vZGVzID0gW107XG4gICAgICB0aGlzLl9vYnNlcnZlciA9IG51bGw7XG4gICAgICB0aGlzLl9zY2hlZHVsZWQgPSBmYWxzZTtcbiAgICAgIC8qKiBAdHlwZSB7ZnVuY3Rpb24oKX0gKi9cbiAgICAgIHRoaXMuX2JvdW5kU2NoZWR1bGUgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMuX3NjaGVkdWxlKCk7XG4gICAgICB9XG4gICAgICB0aGlzLmNvbm5lY3QoKTtcbiAgICAgIHRoaXMuX3NjaGVkdWxlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWN0aXZhdGVzIGFuIG9ic2VydmVyLiBUaGlzIG1ldGhvZCBpcyBhdXRvbWF0aWNhbGx5IGNhbGxlZCB3aGVuXG4gICAgICogYSBgRmxhdHRlbmVkTm9kZXNPYnNlcnZlcmAgaXMgY3JlYXRlZC4gSXQgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIHRvXG4gICAgICogcmUtYWN0aXZhdGUgYW4gb2JzZXJ2ZXIgdGhhdCBoYXMgYmVlbiBkZWFjdGl2YXRlZCB2aWEgdGhlIGBkaXNjb25uZWN0YCBtZXRob2QuXG4gICAgICovXG4gICAgY29ubmVjdCgpIHtcbiAgICAgIGlmIChpc1Nsb3QodGhpcy5fdGFyZ2V0KSkge1xuICAgICAgICB0aGlzLl9saXN0ZW5TbG90cyhbdGhpcy5fdGFyZ2V0XSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9saXN0ZW5TbG90cyh0aGlzLl90YXJnZXQuY2hpbGRyZW4pO1xuICAgICAgICBpZiAod2luZG93LlNoYWR5RE9NKSB7XG4gICAgICAgICAgdGhpcy5fc2hhZHlDaGlsZHJlbk9ic2VydmVyID1cbiAgICAgICAgICAgIFNoYWR5RE9NLm9ic2VydmVDaGlsZHJlbih0aGlzLl90YXJnZXQsIChtdXRhdGlvbnMpID0+IHtcbiAgICAgICAgICAgICAgdGhpcy5fcHJvY2Vzc011dGF0aW9ucyhtdXRhdGlvbnMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fbmF0aXZlQ2hpbGRyZW5PYnNlcnZlciA9XG4gICAgICAgICAgICBuZXcgTXV0YXRpb25PYnNlcnZlcigobXV0YXRpb25zKSA9PiB7XG4gICAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3NNdXRhdGlvbnMobXV0YXRpb25zKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIHRoaXMuX25hdGl2ZUNoaWxkcmVuT2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLl90YXJnZXQsIHtjaGlsZExpc3Q6IHRydWV9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5fY29ubmVjdGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWFjdGl2YXRlcyB0aGUgZmxhdHRlbmVkIG5vZGVzIG9ic2VydmVyLiBBZnRlciBjYWxsaW5nIHRoaXMgbWV0aG9kXG4gICAgICogdGhlIG9ic2VydmVyIGNhbGxiYWNrIHdpbGwgbm90IGJlIGNhbGxlZCB3aGVuIGNoYW5nZXMgdG8gZmxhdHRlbmVkIG5vZGVzXG4gICAgICogb2NjdXIuIFRoZSBgY29ubmVjdGAgbWV0aG9kIG1heSBiZSBzdWJzZXF1ZW50bHkgY2FsbGVkIHRvIHJlYWN0aXZhdGVcbiAgICAgKiB0aGUgb2JzZXJ2ZXIuXG4gICAgICovXG4gICAgZGlzY29ubmVjdCgpIHtcbiAgICAgIGlmIChpc1Nsb3QodGhpcy5fdGFyZ2V0KSkge1xuICAgICAgICB0aGlzLl91bmxpc3RlblNsb3RzKFt0aGlzLl90YXJnZXRdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3VubGlzdGVuU2xvdHModGhpcy5fdGFyZ2V0LmNoaWxkcmVuKTtcbiAgICAgICAgaWYgKHdpbmRvdy5TaGFkeURPTSAmJiB0aGlzLl9zaGFkeUNoaWxkcmVuT2JzZXJ2ZXIpIHtcbiAgICAgICAgICBTaGFkeURPTS51bm9ic2VydmVDaGlsZHJlbih0aGlzLl9zaGFkeUNoaWxkcmVuT2JzZXJ2ZXIpO1xuICAgICAgICAgIHRoaXMuX3NoYWR5Q2hpbGRyZW5PYnNlcnZlciA9IG51bGw7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fbmF0aXZlQ2hpbGRyZW5PYnNlcnZlcikge1xuICAgICAgICAgIHRoaXMuX25hdGl2ZUNoaWxkcmVuT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICAgIHRoaXMuX25hdGl2ZUNoaWxkcmVuT2JzZXJ2ZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLl9jb25uZWN0ZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBfc2NoZWR1bGUoKSB7XG4gICAgICBpZiAoIXRoaXMuX3NjaGVkdWxlZCkge1xuICAgICAgICB0aGlzLl9zY2hlZHVsZWQgPSB0cnVlO1xuICAgICAgICBQb2x5bWVyLkFzeW5jLm1pY3JvVGFzay5ydW4oKCkgPT4gdGhpcy5mbHVzaCgpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfcHJvY2Vzc011dGF0aW9ucyhtdXRhdGlvbnMpIHtcbiAgICAgIHRoaXMuX3Byb2Nlc3NTbG90TXV0YXRpb25zKG11dGF0aW9ucyk7XG4gICAgICB0aGlzLmZsdXNoKCk7XG4gICAgfVxuXG4gICAgX3Byb2Nlc3NTbG90TXV0YXRpb25zKG11dGF0aW9ucykge1xuICAgICAgaWYgKG11dGF0aW9ucykge1xuICAgICAgICBmb3IgKGxldCBpPTA7IGkgPCBtdXRhdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBsZXQgbXV0YXRpb24gPSBtdXRhdGlvbnNbaV07XG4gICAgICAgICAgaWYgKG11dGF0aW9uLmFkZGVkTm9kZXMpIHtcbiAgICAgICAgICAgIHRoaXMuX2xpc3RlblNsb3RzKG11dGF0aW9uLmFkZGVkTm9kZXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobXV0YXRpb24ucmVtb3ZlZE5vZGVzKSB7XG4gICAgICAgICAgICB0aGlzLl91bmxpc3RlblNsb3RzKG11dGF0aW9uLnJlbW92ZWROb2Rlcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmx1c2hlcyB0aGUgb2JzZXJ2ZXIgY2F1c2luZyBhbnkgcGVuZGluZyBjaGFuZ2VzIHRvIGJlIGltbWVkaWF0ZWx5XG4gICAgICogZGVsaXZlcmVkIHRoZSBvYnNlcnZlciBjYWxsYmFjay4gQnkgZGVmYXVsdCB0aGVzZSBjaGFuZ2VzIGFyZSBkZWxpdmVyZWRcbiAgICAgKiBhc3luY2hyb25vdXNseSBhdCB0aGUgbmV4dCBtaWNyb3Rhc2sgY2hlY2twb2ludC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiBhbnkgcGVuZGluZyBjaGFuZ2VzIGNhdXNlZCB0aGUgb2JzZXJ2ZXJcbiAgICAgKiBjYWxsYmFjayB0byBydW4uXG4gICAgICovXG4gICAgZmx1c2goKSB7XG4gICAgICBpZiAoIXRoaXMuX2Nvbm5lY3RlZCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAod2luZG93LlNoYWR5RE9NKSB7XG4gICAgICAgIFNoYWR5RE9NLmZsdXNoKCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fbmF0aXZlQ2hpbGRyZW5PYnNlcnZlcikge1xuICAgICAgICB0aGlzLl9wcm9jZXNzU2xvdE11dGF0aW9ucyh0aGlzLl9uYXRpdmVDaGlsZHJlbk9ic2VydmVyLnRha2VSZWNvcmRzKCkpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl9zaGFkeUNoaWxkcmVuT2JzZXJ2ZXIpIHtcbiAgICAgICAgdGhpcy5fcHJvY2Vzc1Nsb3RNdXRhdGlvbnModGhpcy5fc2hhZHlDaGlsZHJlbk9ic2VydmVyLnRha2VSZWNvcmRzKCkpO1xuICAgICAgfVxuICAgICAgdGhpcy5fc2NoZWR1bGVkID0gZmFsc2U7XG4gICAgICBsZXQgaW5mbyA9IHtcbiAgICAgICAgdGFyZ2V0OiB0aGlzLl90YXJnZXQsXG4gICAgICAgIGFkZGVkTm9kZXM6IFtdLFxuICAgICAgICByZW1vdmVkTm9kZXM6IFtdXG4gICAgICB9O1xuICAgICAgbGV0IG5ld05vZGVzID0gdGhpcy5jb25zdHJ1Y3Rvci5nZXRGbGF0dGVuZWROb2Rlcyh0aGlzLl90YXJnZXQpO1xuICAgICAgbGV0IHNwbGljZXMgPSBQb2x5bWVyLkFycmF5U3BsaWNlLmNhbGN1bGF0ZVNwbGljZXMobmV3Tm9kZXMsXG4gICAgICAgIHRoaXMuX2VmZmVjdGl2ZU5vZGVzKTtcbiAgICAgIC8vIHByb2Nlc3MgcmVtb3ZhbHNcbiAgICAgIGZvciAobGV0IGk9MCwgczsgKGk8c3BsaWNlcy5sZW5ndGgpICYmIChzPXNwbGljZXNbaV0pOyBpKyspIHtcbiAgICAgICAgZm9yIChsZXQgaj0wLCBuOyAoaiA8IHMucmVtb3ZlZC5sZW5ndGgpICYmIChuPXMucmVtb3ZlZFtqXSk7IGorKykge1xuICAgICAgICAgIGluZm8ucmVtb3ZlZE5vZGVzLnB1c2gobik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIHByb2Nlc3MgYWRkc1xuICAgICAgZm9yIChsZXQgaT0wLCBzOyAoaTxzcGxpY2VzLmxlbmd0aCkgJiYgKHM9c3BsaWNlc1tpXSk7IGkrKykge1xuICAgICAgICBmb3IgKGxldCBqPXMuaW5kZXg7IGogPCBzLmluZGV4ICsgcy5hZGRlZENvdW50OyBqKyspIHtcbiAgICAgICAgICBpbmZvLmFkZGVkTm9kZXMucHVzaChuZXdOb2Rlc1tqXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIHVwZGF0ZSBjYWNoZVxuICAgICAgdGhpcy5fZWZmZWN0aXZlTm9kZXMgPSBuZXdOb2RlcztcbiAgICAgIGxldCBkaWRGbHVzaCA9IGZhbHNlO1xuICAgICAgaWYgKGluZm8uYWRkZWROb2Rlcy5sZW5ndGggfHwgaW5mby5yZW1vdmVkTm9kZXMubGVuZ3RoKSB7XG4gICAgICAgIGRpZEZsdXNoID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jYWxsYmFjay5jYWxsKHRoaXMuX3RhcmdldCwgaW5mbyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGlkRmx1c2g7XG4gICAgfVxuXG4gICAgX2xpc3RlblNsb3RzKG5vZGVMaXN0KSB7XG4gICAgICBmb3IgKGxldCBpPTA7IGkgPCBub2RlTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgbiA9IG5vZGVMaXN0W2ldO1xuICAgICAgICBpZiAoaXNTbG90KG4pKSB7XG4gICAgICAgICAgbi5hZGRFdmVudExpc3RlbmVyKCdzbG90Y2hhbmdlJywgdGhpcy5fYm91bmRTY2hlZHVsZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBfdW5saXN0ZW5TbG90cyhub2RlTGlzdCkge1xuICAgICAgZm9yIChsZXQgaT0wOyBpIDwgbm9kZUxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IG4gPSBub2RlTGlzdFtpXTtcbiAgICAgICAgaWYgKGlzU2xvdChuKSkge1xuICAgICAgICAgIG4ucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2xvdGNoYW5nZScsIHRoaXMuX2JvdW5kU2NoZWR1bGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gIH1cblxuICBQb2x5bWVyLkZsYXR0ZW5lZE5vZGVzT2JzZXJ2ZXIgPSBGbGF0dGVuZWROb2Rlc09ic2VydmVyO1xuXG59KSgpO1xuPC9zY3JpcHQ+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL3BvbHltZXIvbGliL3V0aWxzL2ZsYXR0ZW5lZC1ub2Rlcy1vYnNlcnZlci5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuXG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiY2xhc3MuaHRtbFwiPlxuXG48c2NyaXB0PlxuXG4gIChmdW5jdGlvbigpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICAvKipcbiAgICAgKiBMZWdhY3kgY2xhc3MgZmFjdG9yeSBhbmQgcmVnaXN0cmF0aW9uIGhlbHBlciBmb3IgZGVmaW5pbmcgUG9seW1lclxuICAgICAqIGVsZW1lbnRzLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgaXMgZXF1aXZhbGVudCB0b1xuICAgICAqIGBjdXN0b21FbGVtZW50cy5kZWZpbmUoaW5mby5pcywgUG9seW1lci5DbGFzcyhpbmZvKSk7YFxuICAgICAqXG4gICAgICogU2VlIGBQb2x5bWVyLkNsYXNzYCBmb3IgZGV0YWlscyBvbiB2YWxpZCBsZWdhY3kgbWV0YWRhdGEgZm9ybWF0IGZvciBgaW5mb2AuXG4gICAgICpcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKiBAZnVuY3Rpb24gUG9seW1lclxuICAgICAqIEBwYXJhbSB7IVBvbHltZXJJbml0fSBpbmZvIE9iamVjdCBjb250YWluaW5nIFBvbHltZXIgbWV0YWRhdGEgYW5kIGZ1bmN0aW9uc1xuICAgICAqICAgdG8gYmVjb21lIGNsYXNzIG1ldGhvZHMuXG4gICAgICogQHJldHVybiB7IUhUTUxFbGVtZW50fSBHZW5lcmF0ZWQgY2xhc3NcbiAgICAgKiBAc3VwcHJlc3Mge2R1cGxpY2F0ZSwgaW52YWxpZENhc3RzLCBjaGVja1R5cGVzfVxuICAgICAqL1xuICAgIHdpbmRvdy5Qb2x5bWVyLl9wb2x5bWVyRm4gPSBmdW5jdGlvbihpbmZvKSB7XG4gICAgICAvLyBpZiBpbnB1dCBpcyBhIGBjbGFzc2AgKGFrYSBhIGZ1bmN0aW9uIHdpdGggYSBwcm90b3R5cGUpLCB1c2UgdGhlIHByb3RvdHlwZVxuICAgICAgLy8gcmVtZW1iZXIgdGhhdCB0aGUgYGNvbnN0cnVjdG9yYCB3aWxsIG5ldmVyIGJlIGNhbGxlZFxuICAgICAgbGV0IGtsYXNzO1xuICAgICAgaWYgKHR5cGVvZiBpbmZvID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGtsYXNzID0gaW5mbztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGtsYXNzID0gUG9seW1lci5DbGFzcyhpbmZvKTtcbiAgICAgIH1cbiAgICAgIGN1c3RvbUVsZW1lbnRzLmRlZmluZShrbGFzcy5pcywgLyoqIEB0eXBlIHshSFRNTEVsZW1lbnR9ICovKGtsYXNzKSk7XG4gICAgICByZXR1cm4ga2xhc3M7XG4gICAgfTtcblxuICB9KSgpO1xuXG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvbGVnYWN5L3BvbHltZXItZm4uaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCJsZWdhY3ktZWxlbWVudC1taXhpbi5odG1sXCI+XG48c2NyaXB0PlxuXG4gIChmdW5jdGlvbigpIHtcblxuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGxldCBtZXRhUHJvcHMgPSB7XG4gICAgICBhdHRhY2hlZDogdHJ1ZSxcbiAgICAgIGRldGFjaGVkOiB0cnVlLFxuICAgICAgcmVhZHk6IHRydWUsXG4gICAgICBjcmVhdGVkOiB0cnVlLFxuICAgICAgYmVmb3JlUmVnaXN0ZXI6IHRydWUsXG4gICAgICByZWdpc3RlcmVkOiB0cnVlLFxuICAgICAgYXR0cmlidXRlQ2hhbmdlZDogdHJ1ZSxcbiAgICAgIC8vIG1ldGEgb2JqZWN0c1xuICAgICAgYmVoYXZpb3JzOiB0cnVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXBwbGllcyBhIFwibGVnYWN5XCIgYmVoYXZpb3Igb3IgYXJyYXkgb2YgYmVoYXZpb3JzIHRvIHRoZSBwcm92aWRlZCBjbGFzcy5cbiAgICAgKlxuICAgICAqIE5vdGU6IHRoaXMgbWV0aG9kIHdpbGwgYXV0b21hdGljYWxseSBhbHNvIGFwcGx5IHRoZSBgUG9seW1lci5MZWdhY3lFbGVtZW50TWl4aW5gXG4gICAgICogdG8gZW5zdXJlIHRoYXQgYW55IGxlZ2FjeSBiZWhhdmlvcnMgY2FuIHJlbHkgb24gbGVnYWN5IFBvbHltZXIgQVBJIG9uXG4gICAgICogdGhlIHVuZGVybHlpbmcgZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IShPYmplY3R8QXJyYXkpfSBiZWhhdmlvcnMgQmVoYXZpb3Igb2JqZWN0IG9yIGFycmF5IG9mIGJlaGF2aW9ycy5cbiAgICAgKiBAcGFyYW0geyFIVE1MRWxlbWVudHxmdW5jdGlvbihuZXc6SFRNTEVsZW1lbnQpfSBrbGFzcyBFbGVtZW50IGNsYXNzLlxuICAgICAqIEByZXR1cm4ge2Z1bmN0aW9uKG5ldzpIVE1MRWxlbWVudCl9IFJldHVybnMgYSBuZXcgRWxlbWVudCBjbGFzcyBleHRlbmRlZCBieSB0aGVcbiAgICAgKiBwYXNzZWQgaW4gYGJlaGF2aW9yc2AgYW5kIGFsc28gYnkgYFBvbHltZXIuTGVnYWN5RWxlbWVudE1peGluYC5cbiAgICAgKiBAbWVtYmVyb2YgUG9seW1lclxuICAgICAqIEBzdXBwcmVzcyB7aW52YWxpZENhc3RzLCBjaGVja1R5cGVzfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1peGluQmVoYXZpb3JzKGJlaGF2aW9ycywga2xhc3MpIHtcbiAgICAgIGlmICghYmVoYXZpb3JzKSB7XG4gICAgICAgIHJldHVybiAvKiogQHR5cGUge0hUTUxFbGVtZW50fSAqLyhrbGFzcyk7XG4gICAgICB9XG4gICAgICAvLyBOT1RFOiBlbnN1cmUgdGhlIGJhaGV2aW9yIGlzIGV4dGVuZGluZyBhIGNsYXNzIHdpdGhcbiAgICAgIC8vIGxlZ2FjeSBlbGVtZW50IGFwaS4gVGhpcyBpcyBuZWNlc3Nhcnkgc2luY2UgYmVoYXZpb3JzIGV4cGVjdCB0byBiZSBhYmxlXG4gICAgICAvLyB0byBhY2Nlc3MgMS54IGxlZ2FjeSBhcGkuXG4gICAgICBrbGFzcyA9IFBvbHltZXIuTGVnYWN5RWxlbWVudE1peGluKGtsYXNzKTtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShiZWhhdmlvcnMpKSB7XG4gICAgICAgIGJlaGF2aW9ycyA9IFtiZWhhdmlvcnNdO1xuICAgICAgfVxuICAgICAgbGV0IHN1cGVyQmVoYXZpb3JzID0ga2xhc3MucHJvdG90eXBlLmJlaGF2aW9ycztcbiAgICAgIC8vIGdldCBmbGF0dGVuZWQsIGRlZHVwZWQgbGlzdCBvZiBiZWhhdmlvcnMgKm5vdCogYWxyZWFkeSBvbiBzdXBlciBjbGFzc1xuICAgICAgYmVoYXZpb3JzID0gZmxhdHRlbkJlaGF2aW9ycyhiZWhhdmlvcnMsIG51bGwsIHN1cGVyQmVoYXZpb3JzKTtcbiAgICAgIC8vIG1peGluIG5ldyBiZWhhdmlvcnNcbiAgICAgIGtsYXNzID0gX21peGluQmVoYXZpb3JzKGJlaGF2aW9ycywga2xhc3MpO1xuICAgICAgaWYgKHN1cGVyQmVoYXZpb3JzKSB7XG4gICAgICAgIGJlaGF2aW9ycyA9IHN1cGVyQmVoYXZpb3JzLmNvbmNhdChiZWhhdmlvcnMpO1xuICAgICAgfVxuICAgICAgLy8gU2V0IGJlaGF2aW9ycyBvbiBwcm90b3R5cGUgZm9yIEJDLi4uXG4gICAgICBrbGFzcy5wcm90b3R5cGUuYmVoYXZpb3JzID0gYmVoYXZpb3JzO1xuICAgICAgcmV0dXJuIGtsYXNzO1xuICAgIH1cblxuICAgIC8vIE5PVEU6XG4gICAgLy8gMS54XG4gICAgLy8gQmVoYXZpb3JzIHdlcmUgbWl4ZWQgaW4gKmluIHJldmVyc2Ugb3JkZXIqIGFuZCBkZS1kdXBlZCBvbiB0aGUgZmx5LlxuICAgIC8vIFRoZSBydWxlIHdhcyB0aGF0IGJlaGF2aW9yIHByb3BlcnRpZXMgd2VyZSBjb3BpZWQgb250byB0aGUgZWxlbWVudFxuICAgIC8vIHByb3RvdHlwZSBpZiBhbmQgb25seSBpZiB0aGUgcHJvcGVydHkgZGlkIG5vdCBhbHJlYWR5IGV4aXN0LlxuICAgIC8vIEdpdmVuOiBQb2x5bWVyeyBiZWhhdmlvcnM6IFtBLCBCLCBDLCBBLCBCXX0sIHByb3BlcnR5IGNvcHkgb3JkZXIgd2FzOlxuICAgIC8vICgxKSwgQiwgKDIpLCBBLCAoMykgQy4gVGhpcyBtZWFucyBwcm90b3R5cGUgcHJvcGVydGllcyB3aW4gb3ZlclxuICAgIC8vIEIgcHJvcGVydGllcyB3aW4gb3ZlciBBIHdpbiBvdmVyIEMuIFRoaXMgbWlycm9ycyB3aGF0IHdvdWxkIGhhcHBlblxuICAgIC8vIHdpdGggaW5oZXJpdGFuY2UgaWYgZWxlbWVudCBleHRlbmRlZCBCIGV4dGVuZGVkIEEgZXh0ZW5kZWQgQy5cbiAgICAvL1xuICAgIC8vIEFnYWluIGdpdmVuLCBQb2x5bWVyeyBiZWhhdmlvcnM6IFtBLCBCLCBDLCBBLCBCXX0sIHRoZSByZXN1bHRpbmdcbiAgICAvLyBgYmVoYXZpb3JzYCBhcnJheSB3YXMgW0MsIEEsIEJdLlxuICAgIC8vIEJlaGF2aW9yIGxpZmVjeWNsZSBtZXRob2RzIHdlcmUgY2FsbGVkIGluIGJlaGF2aW9yIGFycmF5IG9yZGVyXG4gICAgLy8gZm9sbG93ZWQgYnkgdGhlIGVsZW1lbnQsIGUuZy4gKDEpIEMuY3JlYXRlZCwgKDIpIEEuY3JlYXRlZCxcbiAgICAvLyAoMykgQi5jcmVhdGVkLCAoNCkgZWxlbWVudC5jcmVhdGVkLiBUaGVyZSB3YXMgbm8gc3VwcG9ydCBmb3JcbiAgICAvLyBzdXBlciwgYW5kIFwic3VwZXItYmVoYXZpb3JcIiBtZXRob2RzIHdlcmUgY2FsbGFibGUgb25seSBieSBuYW1lKS5cbiAgICAvL1xuICAgIC8vIDIueFxuICAgIC8vIEJlaGF2aW9ycyBhcmUgbWFkZSBpbnRvIHByb3BlciBtaXhpbnMgd2hpY2ggbGl2ZSBpbiB0aGVcbiAgICAvLyBlbGVtZW50J3MgcHJvdG90eXBlIGNoYWluLiBCZWhhdmlvcnMgYXJlIHBsYWNlZCBpbiB0aGUgZWxlbWVudCBwcm90b3R5cGVcbiAgICAvLyBlbGRlc3QgdG8geW91bmdlc3QgYW5kIGRlLWR1cGVkIHlvdW5nZXN0IHRvIG9sZGVzdDpcbiAgICAvLyBTbywgZmlyc3QgW0EsIEIsIEMsIEEsIEJdIGJlY29tZXMgW0MsIEEsIEJdIHRoZW4sXG4gICAgLy8gdGhlIGVsZW1lbnQgcHJvdG90eXBlIGJlY29tZXMgKG9sZGVzdCkgKDEpIFBvbHltZXIuRWxlbWVudCwgKDIpIGNsYXNzKEMpLFxuICAgIC8vICgzKSBjbGFzcyhBKSwgKDQpIGNsYXNzKEIpLCAoNSkgY2xhc3MoUG9seW1lcih7Li4ufSkpLlxuICAgIC8vIFJlc3VsdDpcbiAgICAvLyBUaGlzIG1lYW5zIGVsZW1lbnQgcHJvcGVydGllcyB3aW4gb3ZlciBCIHByb3BlcnRpZXMgd2luIG92ZXIgQSB3aW5cbiAgICAvLyBvdmVyIEMuIChzYW1lIGFzIDEueClcbiAgICAvLyBJZiBsaWZlY3ljbGUgaXMgY2FsbGVkIChzdXBlciB0aGVuIG1lKSwgb3JkZXIgaXNcbiAgICAvLyAoMSkgQy5jcmVhdGVkLCAoMikgQS5jcmVhdGVkLCAoMykgQi5jcmVhdGVkLCAoNCkgZWxlbWVudC5jcmVhdGVkXG4gICAgLy8gKGFnYWluIHNhbWUgYXMgMS54KVxuICAgIGZ1bmN0aW9uIF9taXhpbkJlaGF2aW9ycyhiZWhhdmlvcnMsIGtsYXNzKSB7XG4gICAgICBmb3IgKGxldCBpPTA7IGk8YmVoYXZpb3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBiID0gYmVoYXZpb3JzW2ldO1xuICAgICAgICBpZiAoYikge1xuICAgICAgICAgIGtsYXNzID0gQXJyYXkuaXNBcnJheShiKSA/IF9taXhpbkJlaGF2aW9ycyhiLCBrbGFzcykgOlxuICAgICAgICAgICAgR2VuZXJhdGVDbGFzc0Zyb21JbmZvKGIsIGtsYXNzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGtsYXNzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGJlaGF2aW9ycyBMaXN0IG9mIGJlaGF2aW9ycyB0byBmbGF0dGVuLlxuICAgICAqIEBwYXJhbSB7QXJyYXk9fSBsaXN0IFRhcmdldCBsaXN0IHRvIGZsYXR0ZW4gYmVoYXZpb3JzIGludG8uXG4gICAgICogQHBhcmFtIHtBcnJheT19IGV4Y2x1ZGUgTGlzdCBvZiBiZWhhdmlvcnMgdG8gZXhjbHVkZSBmcm9tIHRoZSBsaXN0LlxuICAgICAqIEByZXR1cm4geyFBcnJheX0gUmV0dXJucyB0aGUgbGlzdCBvZiBmbGF0dGVuZWQgYmVoYXZpb3JzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZsYXR0ZW5CZWhhdmlvcnMoYmVoYXZpb3JzLCBsaXN0LCBleGNsdWRlKSB7XG4gICAgICBsaXN0ID0gbGlzdCB8fCBbXTtcbiAgICAgIGZvciAobGV0IGk9YmVoYXZpb3JzLmxlbmd0aC0xOyBpID49IDA7IGktLSkge1xuICAgICAgICBsZXQgYiA9IGJlaGF2aW9yc1tpXTtcbiAgICAgICAgaWYgKGIpIHtcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShiKSkge1xuICAgICAgICAgICAgZmxhdHRlbkJlaGF2aW9ycyhiLCBsaXN0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gZGVkdXBcbiAgICAgICAgICAgIGlmIChsaXN0LmluZGV4T2YoYikgPCAwICYmICghZXhjbHVkZSB8fCBleGNsdWRlLmluZGV4T2YoYikgPCAwKSkge1xuICAgICAgICAgICAgICBsaXN0LnVuc2hpZnQoYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUud2FybignYmVoYXZpb3IgaXMgbnVsbCwgY2hlY2sgZm9yIG1pc3Npbmcgb3IgNDA0IGltcG9ydCcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbGlzdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyFQb2x5bWVySW5pdH0gaW5mbyBQb2x5bWVyIGluZm8gb2JqZWN0XG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihuZXc6SFRNTEVsZW1lbnQpfSBCYXNlIGJhc2UgY2xhc3MgdG8gZXh0ZW5kIHdpdGggaW5mbyBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtmdW5jdGlvbihuZXc6SFRNTEVsZW1lbnQpfSBHZW5lcmF0ZWQgY2xhc3NcbiAgICAgKiBAc3VwcHJlc3Mge2NoZWNrVHlwZXN9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBHZW5lcmF0ZUNsYXNzRnJvbUluZm8oaW5mbywgQmFzZSkge1xuXG4gICAgICBjbGFzcyBQb2x5bWVyR2VuZXJhdGVkIGV4dGVuZHMgQmFzZSB7XG5cbiAgICAgICAgc3RhdGljIGdldCBwcm9wZXJ0aWVzKCkge1xuICAgICAgICAgIHJldHVybiBpbmZvLnByb3BlcnRpZXM7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0aWMgZ2V0IG9ic2VydmVycygpIHtcbiAgICAgICAgICByZXR1cm4gaW5mby5vYnNlcnZlcnM7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7SFRNTFRlbXBsYXRlRWxlbWVudH0gdGVtcGxhdGUgZm9yIHRoaXMgY2xhc3NcbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBnZXQgdGVtcGxhdGUoKSB7XG4gICAgICAgICAgLy8gZ2V0IHRlbXBsYXRlIGZpcnN0IGZyb20gYW55IGltcGVyYXRpdmUgc2V0IGluIGBpbmZvLl90ZW1wbGF0ZWBcbiAgICAgICAgICByZXR1cm4gaW5mby5fdGVtcGxhdGUgfHxcbiAgICAgICAgICAgIC8vIG5leHQgbG9vayBpbiBkb20tbW9kdWxlIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGVsZW1lbnQncyBpcy5cbiAgICAgICAgICAgIFBvbHltZXIuRG9tTW9kdWxlICYmIFBvbHltZXIuRG9tTW9kdWxlLmltcG9ydCh0aGlzLmlzLCAndGVtcGxhdGUnKSB8fFxuICAgICAgICAgICAgLy8gbmV4dCBsb29rIGZvciBzdXBlcmNsYXNzIHRlbXBsYXRlIChub3RlOiB1c2Ugc3VwZXJjbGFzcyBzeW1ib2xcbiAgICAgICAgICAgIC8vIHRvIGVuc3VyZSBjb3JyZWN0IGB0aGlzLmlzYClcbiAgICAgICAgICAgIEJhc2UudGVtcGxhdGUgfHxcbiAgICAgICAgICAgIC8vIGZpbmFsbHkgZmFsbCBiYWNrIHRvIGBfdGVtcGxhdGVgIGluIGVsZW1lbnQncyBwcm90b3lwZS5cbiAgICAgICAgICAgIHRoaXMucHJvdG90eXBlLl90ZW1wbGF0ZSB8fFxuICAgICAgICAgICAgbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNyZWF0ZWQoKSB7XG4gICAgICAgICAgc3VwZXIuY3JlYXRlZCgpO1xuICAgICAgICAgIGlmIChpbmZvLmNyZWF0ZWQpIHtcbiAgICAgICAgICAgIGluZm8uY3JlYXRlZC5jYWxsKHRoaXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIF9yZWdpc3RlcmVkKCkge1xuICAgICAgICAgIHN1cGVyLl9yZWdpc3RlcmVkKCk7XG4gICAgICAgICAgLyogTk9URTogYGJlZm9yZVJlZ2lzdGVyYCBpcyBjYWxsZWQgaGVyZSBmb3IgYmMsIGJ1dCB0aGUgYmVoYXZpb3JcbiAgICAgICAgICAgaXMgZGlmZmVyZW50IHRoYW4gaW4gMS54LiBJbiAxLjAsIHRoZSBtZXRob2Qgd2FzIGNhbGxlZCAqYWZ0ZXIqXG4gICAgICAgICAgIG1peGluZyBwcm90b3R5cGVzIHRvZ2V0aGVyIGJ1dCAqYmVmb3JlKiBwcm9jZXNzaW5nIG9mIG1ldGEtb2JqZWN0cy5cbiAgICAgICAgICAgSG93ZXZlciwgZHluYW1pYyBlZmZlY3RzIGNhbiBzdGlsbCBiZSBzZXQgaGVyZSBhbmQgY2FuIGJlIGRvbmUgZWl0aGVyXG4gICAgICAgICAgIGluIGBiZWZvcmVSZWdpc3RlcmAgb3IgYHJlZ2lzdGVyZWRgLiBJdCBpcyBubyBsb25nZXIgcG9zc2libGUgdG8gc2V0XG4gICAgICAgICAgIGBpc2AgaW4gYGJlZm9yZVJlZ2lzdGVyYCBhcyB5b3UgY291bGQgaW4gMS54LlxuICAgICAgICAgICovXG4gICAgICAgICAgaWYgKGluZm8uYmVmb3JlUmVnaXN0ZXIpIHtcbiAgICAgICAgICAgIGluZm8uYmVmb3JlUmVnaXN0ZXIuY2FsbChPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaW5mby5yZWdpc3RlcmVkKSB7XG4gICAgICAgICAgICBpbmZvLnJlZ2lzdGVyZWQuY2FsbChPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIF9hcHBseUxpc3RlbmVycygpIHtcbiAgICAgICAgICBzdXBlci5fYXBwbHlMaXN0ZW5lcnMoKTtcbiAgICAgICAgICBpZiAoaW5mby5saXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGwgaW4gaW5mby5saXN0ZW5lcnMpIHtcbiAgICAgICAgICAgICAgdGhpcy5fYWRkTWV0aG9kRXZlbnRMaXN0ZW5lclRvTm9kZSh0aGlzLCBsLCBpbmZvLmxpc3RlbmVyc1tsXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gbm90ZTogZXhjZXB0aW9uIHRvIFwic3VwZXIgdGhlbiBtZVwiIHJ1bGU7XG4gICAgICAgIC8vIGRvIHdvcmsgYmVmb3JlIGNhbGxpbmcgc3VwZXIgc28gdGhhdCBzdXBlciBhdHRyaWJ1dGVzXG4gICAgICAgIC8vIG9ubHkgYXBwbHkgaWYgbm90IGFscmVhZHkgc2V0LlxuICAgICAgICBfZW5zdXJlQXR0cmlidXRlcygpIHtcbiAgICAgICAgICBpZiAoaW5mby5ob3N0QXR0cmlidXRlcykge1xuICAgICAgICAgICAgZm9yIChsZXQgYSBpbiBpbmZvLmhvc3RBdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2Vuc3VyZUF0dHJpYnV0ZShhLCBpbmZvLmhvc3RBdHRyaWJ1dGVzW2FdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgc3VwZXIuX2Vuc3VyZUF0dHJpYnV0ZXMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlYWR5KCkge1xuICAgICAgICAgIHN1cGVyLnJlYWR5KCk7XG4gICAgICAgICAgaWYgKGluZm8ucmVhZHkpIHtcbiAgICAgICAgICAgIGluZm8ucmVhZHkuY2FsbCh0aGlzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBhdHRhY2hlZCgpIHtcbiAgICAgICAgICBzdXBlci5hdHRhY2hlZCgpO1xuICAgICAgICAgIGlmIChpbmZvLmF0dGFjaGVkKSB7XG4gICAgICAgICAgICBpbmZvLmF0dGFjaGVkLmNhbGwodGhpcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZGV0YWNoZWQoKSB7XG4gICAgICAgICAgc3VwZXIuZGV0YWNoZWQoKTtcbiAgICAgICAgICBpZiAoaW5mby5kZXRhY2hlZCkge1xuICAgICAgICAgICAgaW5mby5kZXRhY2hlZC5jYWxsKHRoaXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGF0dHJpYnV0ZUNoYW5nZWQobmFtZSwgb2xkLCB2YWx1ZSkge1xuICAgICAgICAgIHN1cGVyLmF0dHJpYnV0ZUNoYW5nZWQobmFtZSwgb2xkLCB2YWx1ZSk7XG4gICAgICAgICAgaWYgKGluZm8uYXR0cmlidXRlQ2hhbmdlZCkge1xuICAgICAgICAgICAgaW5mby5hdHRyaWJ1dGVDaGFuZ2VkLmNhbGwodGhpcywgbmFtZSwgb2xkLCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgUG9seW1lckdlbmVyYXRlZC5nZW5lcmF0ZWRGcm9tID0gaW5mb1xuXG4gICAgICBmb3IgKGxldCBwIGluIGluZm8pIHtcbiAgICAgICAgLy8gTk9URTogY2Fubm90IGNvcHkgYG1ldGFQcm9wc2AgbWV0aG9kcyBvbnRvIHByb3RvdHlwZSBhdCBsZWFzdCBiZWNhdXNlXG4gICAgICAgIC8vIGBzdXBlci5yZWFkeWAgbXVzdCBiZSBjYWxsZWQgYW5kIGlzIG5vdCBpbmNsdWRlZCBpbiB0aGUgdXNlciBmbi5cbiAgICAgICAgaWYgKCEocCBpbiBtZXRhUHJvcHMpKSB7XG4gICAgICAgICAgbGV0IHBkID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihpbmZvLCBwKTtcbiAgICAgICAgICBpZiAocGQpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQb2x5bWVyR2VuZXJhdGVkLnByb3RvdHlwZSwgcCwgcGQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gUG9seW1lckdlbmVyYXRlZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYSBjbGFzcyB0aGF0IGV4dGVuZHMgYFBvbHltZXIuTGVnYWN5RWxlbWVudGAgYmFzZWQgb24gdGhlXG4gICAgICogcHJvdmlkZWQgaW5mbyBvYmplY3QuICBNZXRhZGF0YSBvYmplY3RzIG9uIHRoZSBgaW5mb2Agb2JqZWN0XG4gICAgICogKGBwcm9wZXJ0aWVzYCwgYG9ic2VydmVyc2AsIGBsaXN0ZW5lcnNgLCBgYmVoYXZpb3JzYCwgYGlzYCkgYXJlIHVzZWRcbiAgICAgKiBmb3IgUG9seW1lcidzIG1ldGEtcHJvZ3JhbW1pbmcgc3lzdGVtcywgYW5kIGFueSBmdW5jdGlvbnMgYXJlIGNvcGllZFxuICAgICAqIHRvIHRoZSBnZW5lcmF0ZWQgY2xhc3MuXG4gICAgICpcbiAgICAgKiBWYWxpZCBcIm1ldGFkYXRhXCIgdmFsdWVzIGFyZSBhcyBmb2xsb3dzOlxuICAgICAqXG4gICAgICogYGlzYDogU3RyaW5nIHByb3ZpZGluZyB0aGUgdGFnIG5hbWUgdG8gcmVnaXN0ZXIgdGhlIGVsZW1lbnQgdW5kZXIuIEluXG4gICAgICogYWRkaXRpb24sIGlmIGEgYGRvbS1tb2R1bGVgIHdpdGggdGhlIHNhbWUgaWQgZXhpc3RzLCB0aGUgZmlyc3QgdGVtcGxhdGVcbiAgICAgKiBpbiB0aGF0IGBkb20tbW9kdWxlYCB3aWxsIGJlIHN0YW1wZWQgaW50byB0aGUgc2hhZG93IHJvb3Qgb2YgdGhpcyBlbGVtZW50LFxuICAgICAqIHdpdGggc3VwcG9ydCBmb3IgZGVjbGFyYXRpdmUgZXZlbnQgbGlzdGVuZXJzIChgb24tLi4uYCksIFBvbHltZXIgZGF0YVxuICAgICAqIGJpbmRpbmdzIChgW1suLi5dXWAgYW5kIGB7ey4uLn19YCksIGFuZCBpZC1iYXNlZCBub2RlIGZpbmRpbmcgaW50b1xuICAgICAqIGB0aGlzLiRgLlxuICAgICAqXG4gICAgICogYHByb3BlcnRpZXNgOiBPYmplY3QgZGVzY3JpYmluZyBwcm9wZXJ0eS1yZWxhdGVkIG1ldGFkYXRhIHVzZWQgYnkgUG9seW1lclxuICAgICAqIGZlYXR1cmVzIChrZXk6IHByb3BlcnR5IG5hbWVzLCB2YWx1ZTogb2JqZWN0IGNvbnRhaW5pbmcgcHJvcGVydHkgbWV0YWRhdGEpLlxuICAgICAqIFZhbGlkIGtleXMgaW4gcGVyLXByb3BlcnR5IG1ldGFkYXRhIGluY2x1ZGU6XG4gICAgICogLSBgdHlwZWAgKFN0cmluZ3xOdW1iZXJ8T2JqZWN0fEFycmF5fC4uLik6IFVzZWQgYnlcbiAgICAgKiAgIGBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2tgIHRvIGRldGVybWluZSBob3cgc3RyaW5nLWJhc2VkIGF0dHJpYnV0ZXNcbiAgICAgKiAgIGFyZSBkZXNlcmlhbGl6ZWQgdG8gSmF2YVNjcmlwdCBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICogLSBgbm90aWZ5YCAoYm9vbGVhbik6IENhdXNlcyBhIGNoYW5nZSBpbiB0aGUgcHJvcGVydHkgdG8gZmlyZSBhXG4gICAgICogICBub24tYnViYmxpbmcgZXZlbnQgY2FsbGVkIGA8cHJvcGVydHk+LWNoYW5nZWRgLiBFbGVtZW50cyB0aGF0IGhhdmVcbiAgICAgKiAgIGVuYWJsZWQgdHdvLXdheSBiaW5kaW5nIHRvIHRoZSBwcm9wZXJ0eSB1c2UgdGhpcyBldmVudCB0byBvYnNlcnZlIGNoYW5nZXMuXG4gICAgICogLSBgcmVhZE9ubHlgIChib29sZWFuKTogQ3JlYXRlcyBhIGdldHRlciBmb3IgdGhlIHByb3BlcnR5LCBidXQgbm8gc2V0dGVyLlxuICAgICAqICAgVG8gc2V0IGEgcmVhZC1vbmx5IHByb3BlcnR5LCB1c2UgdGhlIHByaXZhdGUgc2V0dGVyIG1ldGhvZFxuICAgICAqICAgYF9zZXRQcm9wZXJ0eShwcm9wZXJ0eSwgdmFsdWUpYC5cbiAgICAgKiAtIGBvYnNlcnZlcmAgKHN0cmluZyk6IE9ic2VydmVyIG1ldGhvZCBuYW1lIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2hlblxuICAgICAqICAgdGhlIHByb3BlcnR5IGNoYW5nZXMuIFRoZSBhcmd1bWVudHMgb2YgdGhlIG1ldGhvZCBhcmVcbiAgICAgKiAgIGAodmFsdWUsIHByZXZpb3VzVmFsdWUpYC5cbiAgICAgKiAtIGBjb21wdXRlZGAgKHN0cmluZyk6IFN0cmluZyBkZXNjcmliaW5nIG1ldGhvZCBhbmQgZGVwZW5kZW50IHByb3BlcnRpZXNcbiAgICAgKiAgIGZvciBjb21wdXRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgcHJvcGVydHkgKGUuZy4gYCdjb21wdXRlRm9vKGJhciwgem90KSdgKS5cbiAgICAgKiAgIENvbXB1dGVkIHByb3BlcnRpZXMgYXJlIHJlYWQtb25seSBieSBkZWZhdWx0IGFuZCBjYW4gb25seSBiZSBjaGFuZ2VkXG4gICAgICogICB2aWEgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgY29tcHV0aW5nIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIGBvYnNlcnZlcnNgOiBBcnJheSBvZiBzdHJpbmdzIGRlc2NyaWJpbmcgbXVsdGktcHJvcGVydHkgb2JzZXJ2ZXIgbWV0aG9kc1xuICAgICAqICBhbmQgdGhlaXIgZGVwZW5kZW50IHByb3BlcnRpZXMgKGUuZy4gYCdvYnNlcnZlQUJDKGEsIGIsIGMpJ2ApLlxuICAgICAqXG4gICAgICogYGxpc3RlbmVyc2A6IE9iamVjdCBkZXNjcmliaW5nIGV2ZW50IGxpc3RlbmVycyB0byBiZSBhZGRlZCB0byBlYWNoXG4gICAgICogIGluc3RhbmNlIG9mIHRoaXMgZWxlbWVudCAoa2V5OiBldmVudCBuYW1lLCB2YWx1ZTogbWV0aG9kIG5hbWUpLlxuICAgICAqXG4gICAgICogYGJlaGF2aW9yc2A6IEFycmF5IG9mIGFkZGl0aW9uYWwgYGluZm9gIG9iamVjdHMgY29udGFpbmluZyBtZXRhZGF0YVxuICAgICAqIGFuZCBjYWxsYmFja3MgaW4gdGhlIHNhbWUgZm9ybWF0IGFzIHRoZSBgaW5mb2Agb2JqZWN0IGhlcmUgd2hpY2ggYXJlXG4gICAgICogbWVyZ2VkIGludG8gdGhpcyBlbGVtZW50LlxuICAgICAqXG4gICAgICogYGhvc3RBdHRyaWJ1dGVzYDogT2JqZWN0IGxpc3RpbmcgYXR0cmlidXRlcyB0byBiZSBhcHBsaWVkIHRvIHRoZSBob3N0XG4gICAgICogIG9uY2UgY3JlYXRlZCAoa2V5OiBhdHRyaWJ1dGUgbmFtZSwgdmFsdWU6IGF0dHJpYnV0ZSB2YWx1ZSkuICBWYWx1ZXNcbiAgICAgKiAgYXJlIHNlcmlhbGl6ZWQgYmFzZWQgb24gdGhlIHR5cGUgb2YgdGhlIHZhbHVlLiAgSG9zdCBhdHRyaWJ1dGVzIHNob3VsZFxuICAgICAqICBnZW5lcmFsbHkgYmUgbGltaXRlZCB0byBhdHRyaWJ1dGVzIHN1Y2ggYXMgYHRhYkluZGV4YCBhbmQgYGFyaWEtLi4uYC5cbiAgICAgKiAgQXR0cmlidXRlcyBpbiBgaG9zdEF0dHJpYnV0ZXNgIGFyZSBvbmx5IGFwcGxpZWQgaWYgYSB1c2VyLXN1cHBsaWVkXG4gICAgICogIGF0dHJpYnV0ZSBpcyBub3QgYWxyZWFkeSBwcmVzZW50IChhdHRyaWJ1dGVzIGluIG1hcmt1cCBvdmVycmlkZVxuICAgICAqICBgaG9zdEF0dHJpYnV0ZXNgKS5cbiAgICAgKlxuICAgICAqIEluIGFkZGl0aW9uLCB0aGUgZm9sbG93aW5nIFBvbHltZXItc3BlY2lmaWMgY2FsbGJhY2tzIG1heSBiZSBwcm92aWRlZDpcbiAgICAgKiAtIGByZWdpc3RlcmVkYDogY2FsbGVkIGFmdGVyIGZpcnN0IGluc3RhbmNlIG9mIHRoaXMgZWxlbWVudCxcbiAgICAgKiAtIGBjcmVhdGVkYDogY2FsbGVkIGR1cmluZyBgY29uc3RydWN0b3JgXG4gICAgICogLSBgYXR0YWNoZWRgOiBjYWxsZWQgZHVyaW5nIGBjb25uZWN0ZWRDYWxsYmFja2BcbiAgICAgKiAtIGBkZXRhY2hlZGA6IGNhbGxlZCBkdXJpbmcgYGRpc2Nvbm5lY3RlZENhbGxiYWNrYFxuICAgICAqIC0gYHJlYWR5YDogY2FsbGVkIGJlZm9yZSBmaXJzdCBgYXR0YWNoZWRgLCBhZnRlciBhbGwgcHJvcGVydGllcyBvZlxuICAgICAqICAgdGhpcyBlbGVtZW50IGhhdmUgYmVlbiBwcm9wYWdhdGVkIHRvIGl0cyB0ZW1wbGF0ZSBhbmQgYWxsIG9ic2VydmVyc1xuICAgICAqICAgaGF2ZSBydW5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IVBvbHltZXJJbml0fSBpbmZvIE9iamVjdCBjb250YWluaW5nIFBvbHltZXIgbWV0YWRhdGEgYW5kIGZ1bmN0aW9uc1xuICAgICAqICAgdG8gYmVjb21lIGNsYXNzIG1ldGhvZHMuXG4gICAgICogQHJldHVybiB7ZnVuY3Rpb24obmV3OkhUTUxFbGVtZW50KX0gR2VuZXJhdGVkIGNsYXNzXG4gICAgICogQG1lbWJlcm9mIFBvbHltZXJcbiAgICAgKi9cbiAgICBQb2x5bWVyLkNsYXNzID0gZnVuY3Rpb24oaW5mbykge1xuICAgICAgaWYgKCFpbmZvKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignUG9seW1lci5DbGFzcyByZXF1aXJlcyBgaW5mb2AgYXJndW1lbnQnKTtcbiAgICAgIH1cbiAgICAgIGxldCBrbGFzcyA9IEdlbmVyYXRlQ2xhc3NGcm9tSW5mbyhpbmZvLCBpbmZvLmJlaGF2aW9ycyA/XG4gICAgICAgIC8vIG5vdGU6IG1peGluQmVoYXZpb3JzIGVuc3VyZXMgYExlZ2FjeUVsZW1lbnRNaXhpbmAuXG4gICAgICAgIG1peGluQmVoYXZpb3JzKGluZm8uYmVoYXZpb3JzLCBIVE1MRWxlbWVudCkgOlxuICAgICAgICBQb2x5bWVyLkxlZ2FjeUVsZW1lbnRNaXhpbihIVE1MRWxlbWVudCkpO1xuICAgICAgLy8gZGVjb3JhdGUga2xhc3Mgd2l0aCByZWdpc3RyYXRpb24gaW5mb1xuICAgICAga2xhc3MuaXMgPSBpbmZvLmlzO1xuICAgICAgcmV0dXJuIGtsYXNzO1xuICAgIH1cblxuICAgIFBvbHltZXIubWl4aW5CZWhhdmlvcnMgPSBtaXhpbkJlaGF2aW9ycztcblxuICB9KSgpO1xuXG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvbGVnYWN5L2NsYXNzLmh0bWwiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi91dGlscy90ZW1wbGF0aXplLmh0bWxcIj5cblxuPHNjcmlwdD5cbiAgKGZ1bmN0aW9uKCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGxldCBUZW1wbGF0ZUluc3RhbmNlQmFzZSA9IFBvbHltZXIuVGVtcGxhdGVJbnN0YW5jZUJhc2U7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHt7XG4gICAgICogICBfdGVtcGxhdGl6ZXJUZW1wbGF0ZTogSFRNTFRlbXBsYXRlRWxlbWVudCxcbiAgICAgKiAgIF9wYXJlbnRNb2RlbDogYm9vbGVhbixcbiAgICAgKiAgIF9pbnN0YW5jZVByb3BzOiBPYmplY3QsXG4gICAgICogICBfZm9yd2FyZEhvc3RQcm9wVjI6IEZ1bmN0aW9uLFxuICAgICAqICAgX25vdGlmeUluc3RhbmNlUHJvcFYyOiBGdW5jdGlvbixcbiAgICAgKiAgIGN0b3I6IFRlbXBsYXRlSW5zdGFuY2VCYXNlXG4gICAgICogfX1cbiAgICAgKi9cbiAgICBsZXQgVGVtcGxhdGl6ZXJVc2VyOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbiAgICAvKipcbiAgICAgKiBUaGUgYFBvbHltZXIuVGVtcGxhdGl6ZXJgIGJlaGF2aW9yIGFkZHMgbWV0aG9kcyB0byBnZW5lcmF0ZSBpbnN0YW5jZXMgb2ZcbiAgICAgKiB0ZW1wbGF0ZXMgdGhhdCBhcmUgZWFjaCBtYW5hZ2VkIGJ5IGFuIGFub255bW91cyBgUG9seW1lci5Qcm9wZXJ0eUVmZmVjdHNgXG4gICAgICogaW5zdGFuY2Ugd2hlcmUgZGF0YS1iaW5kaW5ncyBpbiB0aGUgc3RhbXBlZCB0ZW1wbGF0ZSBjb250ZW50IGFyZSBib3VuZCB0b1xuICAgICAqIGFjY2Vzc29ycyBvbiBpdHNlbGYuXG4gICAgICpcbiAgICAgKiBUaGlzIGJlaGF2aW9yIGlzIHByb3ZpZGVkIGluIFBvbHltZXIgMi54IGFzIGEgaHlicmlkLWVsZW1lbnQgY29udmVuaWVuY2VcbiAgICAgKiBvbmx5LiAgRm9yIG5vbi1oeWJyaWQgdXNhZ2UsIHRoZSBgUG9seW1lci5UZW1wbGF0aXplYCBsaWJyYXJ5XG4gICAgICogc2hvdWxkIGJlIHVzZWQgaW5zdGVhZC5cbiAgICAgKlxuICAgICAqIEV4YW1wbGU6XG4gICAgICpcbiAgICAgKiAgICAgLy8gR2V0IGEgdGVtcGxhdGUgZnJvbSBzb21ld2hlcmUsIGUuZy4gbGlnaHQgRE9NXG4gICAgICogICAgIGxldCB0ZW1wbGF0ZSA9IHRoaXMucXVlcnlTZWxlY3RvcigndGVtcGxhdGUnKTtcbiAgICAgKiAgICAgLy8gUHJlcGFyZSB0aGUgdGVtcGxhdGVcbiAgICAgKiAgICAgdGhpcy50ZW1wbGF0aXplKHRlbXBsYXRlKTtcbiAgICAgKiAgICAgLy8gSW5zdGFuY2UgdGhlIHRlbXBsYXRlIHdpdGggYW4gaW5pdGlhbCBkYXRhIG1vZGVsXG4gICAgICogICAgIGxldCBpbnN0YW5jZSA9IHRoaXMuc3RhbXAoe215UHJvcDogJ2luaXRpYWwnfSk7XG4gICAgICogICAgIC8vIEluc2VydCB0aGUgaW5zdGFuY2UncyBET00gc29tZXdoZXJlLCBlLmcuIGxpZ2h0IERPTVxuICAgICAqICAgICBQb2x5bWVyLmRvbSh0aGlzKS5hcHBlbmRDaGlsZChpbnN0YW5jZS5yb290KTtcbiAgICAgKiAgICAgLy8gQ2hhbmdpbmcgYSBwcm9wZXJ0eSBvbiB0aGUgaW5zdGFuY2Ugd2lsbCBwcm9wYWdhdGUgdG8gYmluZGluZ3NcbiAgICAgKiAgICAgLy8gaW4gdGhlIHRlbXBsYXRlXG4gICAgICogICAgIGluc3RhbmNlLm15UHJvcCA9ICduZXcgdmFsdWUnO1xuICAgICAqXG4gICAgICogVXNlcnMgb2YgYFRlbXBsYXRpemVyYCBtYXkgbmVlZCB0byBpbXBsZW1lbnQgdGhlIGZvbGxvd2luZyBhYnN0cmFjdFxuICAgICAqIEFQSSdzIHRvIGRldGVybWluZSBob3cgcHJvcGVydGllcyBhbmQgcGF0aHMgZnJvbSB0aGUgaG9zdCBzaG91bGQgYmVcbiAgICAgKiBmb3J3YXJkZWQgaW50byB0byBpbnN0YW5jZXM6XG4gICAgICpcbiAgICAgKiAgICAgX2ZvcndhcmRIb3N0UHJvcFYyOiBmdW5jdGlvbihwcm9wLCB2YWx1ZSlcbiAgICAgKlxuICAgICAqIExpa2V3aXNlLCB1c2VycyBtYXkgaW1wbGVtZW50IHRoZXNlIGFkZGl0aW9uYWwgYWJzdHJhY3QgQVBJJ3MgdG8gZGV0ZXJtaW5lXG4gICAgICogaG93IGluc3RhbmNlLXNwZWNpZmljIHByb3BlcnRpZXMgdGhhdCBjaGFuZ2Ugb24gdGhlIGluc3RhbmNlIHNob3VsZCBiZVxuICAgICAqIGZvcndhcmRlZCBvdXQgdG8gdGhlIGhvc3QsIGlmIG5lY2Vzc2FyeS5cbiAgICAgKlxuICAgICAqICAgICBfbm90aWZ5SW5zdGFuY2VQcm9wVjI6IGZ1bmN0aW9uKGluc3QsIHByb3AsIHZhbHVlKVxuICAgICAqXG4gICAgICogSW4gb3JkZXIgdG8gZGV0ZXJtaW5lIHdoaWNoIHByb3BlcnRpZXMgYXJlIGluc3RhbmNlLXNwZWNpZmljIGFuZCByZXF1aXJlXG4gICAgICogY3VzdG9tIG5vdGlmaWNhdGlvbiB2aWEgYF9ub3RpZnlJbnN0YW5jZVByb3BgLCBkZWZpbmUgYW4gYF9pbnN0YW5jZVByb3BzYFxuICAgICAqIG9iamVjdCBjb250YWluaW5nIGtleXMgZm9yIGVhY2ggaW5zdGFuY2UgcHJvcCwgZm9yIGV4YW1wbGU6XG4gICAgICpcbiAgICAgKiAgICAgX2luc3RhbmNlUHJvcHM6IHtcbiAgICAgKiAgICAgICBpdGVtOiB0cnVlLFxuICAgICAqICAgICAgIGluZGV4OiB0cnVlXG4gICAgICogICAgIH1cbiAgICAgKlxuICAgICAqIEFueSBwcm9wZXJ0aWVzIHVzZWQgaW4gdGhlIHRlbXBsYXRlIHRoYXQgYXJlIG5vdCBkZWZpbmVkIGluIF9pbnN0YW5jZVByb3BcbiAgICAgKiB3aWxsIGJlIGZvcndhcmRlZCBvdXQgdG8gdGhlIFRlbXBsYXRpemUgYG93bmVyYCBhdXRvbWF0aWNhbGx5LlxuICAgICAqXG4gICAgICogVXNlcnMgbWF5IGFsc28gaW1wbGVtZW50IHRoZSBmb2xsb3dpbmcgYWJzdHJhY3QgZnVuY3Rpb24gdG8gc2hvdyBvclxuICAgICAqIGhpZGUgYW55IERPTSBnZW5lcmF0ZWQgdXNpbmcgYHN0YW1wYDpcbiAgICAgKlxuICAgICAqICAgICBfc2hvd0hpZGVDaGlsZHJlbjogZnVuY3Rpb24oc2hvdWxkSGlkZSlcbiAgICAgKlxuICAgICAqIE5vdGUgdGhhdCBzb21lIGNhbGxiYWNrcyBhcmUgc3VmZml4ZWQgd2l0aCBgVjJgIGluIHRoZSBQb2x5bWVyIDIueCBiZWhhdmlvclxuICAgICAqIGFzIHRoZSBpbXBsZW1lbnRhdGlvbnMgd2lsbCBuZWVkIHRvIGRpZmZlciBmcm9tIHRoZSBjYWxsYmFja3MgcmVxdWlyZWRcbiAgICAgKiBieSB0aGUgMS54IFRlbXBsYXRpemVyIEFQSSBkdWUgdG8gY2hhbmdlcyBpbiB0aGUgYFRlbXBsYXRlSW5zdGFuY2VgIEFQSVxuICAgICAqIGJldHdlZW4gdmVyc2lvbnMgMS54IGFuZCAyLnguXG4gICAgICpcbiAgICAgKiBAcG9seW1lckJlaGF2aW9yXG4gICAgICogQG1lbWJlcm9mIFBvbHltZXJcbiAgICAgKi9cbiAgICBsZXQgVGVtcGxhdGl6ZXIgPSB7XG5cbiAgICAgIC8qKlxuICAgICAgICogR2VuZXJhdGVzIGFuIGFub255bW91cyBgVGVtcGxhdGVJbnN0YW5jZWAgY2xhc3MgKHN0b3JlZCBhcyBgdGhpcy5jdG9yYClcbiAgICAgICAqIGZvciB0aGUgcHJvdmlkZWQgdGVtcGxhdGUuICBUaGlzIG1ldGhvZCBzaG91bGQgYmUgY2FsbGVkIG9uY2UgcGVyXG4gICAgICAgKiB0ZW1wbGF0ZSB0byBwcmVwYXJlIGFuIGVsZW1lbnQgZm9yIHN0YW1waW5nIHRoZSB0ZW1wbGF0ZSwgZm9sbG93ZWRcbiAgICAgICAqIGJ5IGBzdGFtcGAgdG8gY3JlYXRlIG5ldyBpbnN0YW5jZXMgb2YgdGhlIHRlbXBsYXRlLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7SFRNTFRlbXBsYXRlRWxlbWVudH0gdGVtcGxhdGUgVGVtcGxhdGUgdG8gcHJlcGFyZVxuICAgICAgICogQHBhcmFtIHtib29sZWFuPX0gbXV0YWJsZURhdGEgV2hlbiBgdHJ1ZWAsIHRoZSBnZW5lcmF0ZWQgY2xhc3Mgd2lsbCBza2lwXG4gICAgICAgKiAgIHN0cmljdCBkaXJ0eS1jaGVja2luZyBmb3Igb2JqZWN0cyBhbmQgYXJyYXlzIChhbHdheXMgY29uc2lkZXIgdGhlbSB0b1xuICAgICAgICogICBiZSBcImRpcnR5XCIpLiBEZWZhdWx0cyB0byBmYWxzZS5cbiAgICAgICAqIEB0aGlzIHtUZW1wbGF0aXplclVzZXJ9XG4gICAgICAgKi9cbiAgICAgIHRlbXBsYXRpemUodGVtcGxhdGUsIG11dGFibGVEYXRhKSB7XG4gICAgICAgIHRoaXMuX3RlbXBsYXRpemVyVGVtcGxhdGUgPSB0ZW1wbGF0ZTtcbiAgICAgICAgdGhpcy5jdG9yID0gUG9seW1lci5UZW1wbGF0aXplLnRlbXBsYXRpemUodGVtcGxhdGUsIHRoaXMsIHtcbiAgICAgICAgICBtdXRhYmxlRGF0YTogQm9vbGVhbihtdXRhYmxlRGF0YSksXG4gICAgICAgICAgcGFyZW50TW9kZWw6IHRoaXMuX3BhcmVudE1vZGVsLFxuICAgICAgICAgIGluc3RhbmNlUHJvcHM6IHRoaXMuX2luc3RhbmNlUHJvcHMsXG4gICAgICAgICAgZm9yd2FyZEhvc3RQcm9wOiB0aGlzLl9mb3J3YXJkSG9zdFByb3BWMixcbiAgICAgICAgICBub3RpZnlJbnN0YW5jZVByb3A6IHRoaXMuX25vdGlmeUluc3RhbmNlUHJvcFYyXG4gICAgICAgIH0pO1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIHRoZSB0ZW1wbGF0ZSBwcmVwYXJlZCBieSBgdGVtcGxhdGl6ZWAuICBUaGUgb2JqZWN0XG4gICAgICAgKiByZXR1cm5lZCBpcyBhbiBpbnN0YW5jZSBvZiB0aGUgYW5vbnltb3VzIGNsYXNzIGdlbmVyYXRlZCBieSBgdGVtcGxhdGl6ZWBcbiAgICAgICAqIHdob3NlIGByb290YCBwcm9wZXJ0eSBpcyBhIGRvY3VtZW50IGZyYWdtZW50IGNvbnRhaW5pbmcgbmV3bHkgY2xvbmVkXG4gICAgICAgKiB0ZW1wbGF0ZSBjb250ZW50LCBhbmQgd2hpY2ggaGFzIHByb3BlcnR5IGFjY2Vzc29ycyBjb3JyZXNwb25kaW5nIHRvXG4gICAgICAgKiBwcm9wZXJ0aWVzIHJlZmVyZW5jZWQgaW4gdGVtcGxhdGUgYmluZGluZ3MuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtPYmplY3Q9fSBtb2RlbCBPYmplY3QgY29udGFpbmluZyBpbml0aWFsIHByb3BlcnR5IHZhbHVlcyB0b1xuICAgICAgICogICBwb3B1bGF0ZSBpbnRvIHRoZSB0ZW1wbGF0ZSBiaW5kaW5ncy5cbiAgICAgICAqIEByZXR1cm4ge1RlbXBsYXRlSW5zdGFuY2VCYXNlfSBSZXR1cm5zIHRoZSBjcmVhdGVkIGluc3RhbmNlIG9mXG4gICAgICAgKiB0aGUgdGVtcGxhdGUgcHJlcGFyZWQgYnkgYHRlbXBsYXRpemVgLlxuICAgICAgICogQHRoaXMge1RlbXBsYXRpemVyVXNlcn1cbiAgICAgICAqL1xuICAgICAgc3RhbXAobW9kZWwpIHtcbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzLmN0b3IobW9kZWwpO1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBSZXR1cm5zIHRoZSB0ZW1wbGF0ZSBcIm1vZGVsXCIgKGBUZW1wbGF0ZUluc3RhbmNlYCkgYXNzb2NpYXRlZCB3aXRoXG4gICAgICAgKiBhIGdpdmVuIGVsZW1lbnQsIHdoaWNoIHNlcnZlcyBhcyB0aGUgYmluZGluZyBzY29wZSBmb3IgdGhlIHRlbXBsYXRlXG4gICAgICAgKiBpbnN0YW5jZSB0aGUgZWxlbWVudCBpcyBjb250YWluZWQgaW4uICBBIHRlbXBsYXRlIG1vZGVsIHNob3VsZCBiZSB1c2VkXG4gICAgICAgKiB0byBtYW5pcHVsYXRlIGRhdGEgYXNzb2NpYXRlZCB3aXRoIHRoaXMgdGVtcGxhdGUgaW5zdGFuY2UuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgRWxlbWVudCBmb3Igd2hpY2ggdG8gcmV0dXJuIGEgdGVtcGxhdGUgbW9kZWwuXG4gICAgICAgKiBAcmV0dXJuIHtUZW1wbGF0ZUluc3RhbmNlQmFzZX0gTW9kZWwgcmVwcmVzZW50aW5nIHRoZSBiaW5kaW5nIHNjb3BlIGZvclxuICAgICAgICogICB0aGUgZWxlbWVudC5cbiAgICAgICAqIEB0aGlzIHtUZW1wbGF0aXplclVzZXJ9XG4gICAgICAgKi9cbiAgICAgIG1vZGVsRm9yRWxlbWVudChlbCkge1xuICAgICAgICByZXR1cm4gUG9seW1lci5UZW1wbGF0aXplLm1vZGVsRm9yRWxlbWVudCh0aGlzLl90ZW1wbGF0aXplclRlbXBsYXRlLCBlbCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIFBvbHltZXIuVGVtcGxhdGl6ZXIgPSBUZW1wbGF0aXplcjtcblxuICB9KSgpO1xuPC9zY3JpcHQ+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL3BvbHltZXIvbGliL2xlZ2FjeS90ZW1wbGF0aXplci1iZWhhdmlvci5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuXG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vdXRpbHMvYm9vdC5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vbWl4aW5zL3Byb3BlcnR5LWVmZmVjdHMuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL21peGlucy9tdXRhYmxlLWRhdGEuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL21peGlucy9nZXN0dXJlLWV2ZW50LWxpc3RlbmVycy5odG1sXCI+XG5cbjxzY3JpcHQ+XG5cbiAgKGZ1bmN0aW9uKCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBleHRlbmRzIHtIVE1MRWxlbWVudH1cbiAgICAgKiBAaW1wbGVtZW50cyB7UG9seW1lcl9Qcm9wZXJ0eUVmZmVjdHN9XG4gICAgICogQGltcGxlbWVudHMge1BvbHltZXJfT3B0aW9uYWxNdXRhYmxlRGF0YX1cbiAgICAgKiBAaW1wbGVtZW50cyB7UG9seW1lcl9HZXN0dXJlRXZlbnRMaXN0ZW5lcnN9XG4gICAgICovXG4gICAgY29uc3QgZG9tQmluZEJhc2UgPVxuICAgICAgUG9seW1lci5HZXN0dXJlRXZlbnRMaXN0ZW5lcnMoXG4gICAgICAgIFBvbHltZXIuT3B0aW9uYWxNdXRhYmxlRGF0YShcbiAgICAgICAgICBQb2x5bWVyLlByb3BlcnR5RWZmZWN0cyhIVE1MRWxlbWVudCkpKTtcblxuICAgIC8qKlxuICAgICAqIEN1c3RvbSBlbGVtZW50IHRvIGFsbG93IHVzaW5nIFBvbHltZXIncyB0ZW1wbGF0ZSBmZWF0dXJlcyAoZGF0YSBiaW5kaW5nLFxuICAgICAqIGRlY2xhcmF0aXZlIGV2ZW50IGxpc3RlbmVycywgZXRjLikgaW4gdGhlIG1haW4gZG9jdW1lbnQgd2l0aG91dCBkZWZpbmluZ1xuICAgICAqIGEgbmV3IGN1c3RvbSBlbGVtZW50LlxuICAgICAqXG4gICAgICogYDx0ZW1wbGF0ZT5gIHRhZ3MgdXRpbGl6aW5nIGJpbmRpbmdzIG1heSBiZSB3cmFwcGVkIHdpdGggdGhlIGA8ZG9tLWJpbmQ+YFxuICAgICAqIGVsZW1lbnQsIHdoaWNoIHdpbGwgaW1tZWRpYXRlbHkgc3RhbXAgdGhlIHdyYXBwZWQgdGVtcGxhdGUgaW50byB0aGUgbWFpblxuICAgICAqIGRvY3VtZW50IGFuZCBiaW5kIGVsZW1lbnRzIHRvIHRoZSBgZG9tLWJpbmRgIGVsZW1lbnQgaXRzZWxmIGFzIHRoZVxuICAgICAqIGJpbmRpbmcgc2NvcGUuXG4gICAgICpcbiAgICAgKiBAcG9seW1lclxuICAgICAqIEBjdXN0b21FbGVtZW50XG4gICAgICogQGFwcGxpZXNNaXhpbiBQb2x5bWVyLlByb3BlcnR5RWZmZWN0c1xuICAgICAqIEBhcHBsaWVzTWl4aW4gUG9seW1lci5PcHRpb25hbE11dGFibGVEYXRhXG4gICAgICogQGFwcGxpZXNNaXhpbiBQb2x5bWVyLkdlc3R1cmVFdmVudExpc3RlbmVyc1xuICAgICAqIEBleHRlbmRzIHtkb21CaW5kQmFzZX1cbiAgICAgKiBAbWVtYmVyb2YgUG9seW1lclxuICAgICAqIEBzdW1tYXJ5IEN1c3RvbSBlbGVtZW50IHRvIGFsbG93IHVzaW5nIFBvbHltZXIncyB0ZW1wbGF0ZSBmZWF0dXJlcyAoZGF0YVxuICAgICAqICAgYmluZGluZywgZGVjbGFyYXRpdmUgZXZlbnQgbGlzdGVuZXJzLCBldGMuKSBpbiB0aGUgbWFpbiBkb2N1bWVudC5cbiAgICAgKi9cbiAgICBjbGFzcyBEb21CaW5kIGV4dGVuZHMgZG9tQmluZEJhc2Uge1xuXG4gICAgICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHsgcmV0dXJuIFsnbXV0YWJsZS1kYXRhJ10gfVxuXG4gICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5yb290ID0gbnVsbDtcbiAgICAgICAgdGhpcy4kID0gbnVsbDtcbiAgICAgICAgdGhpcy5fX2NoaWxkcmVuID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgLy8gYXNzdW1lcyBvbmx5IG9uZSBvYnNlcnZlZCBhdHRyaWJ1dGVcbiAgICAgIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjaygpIHtcbiAgICAgICAgdGhpcy5tdXRhYmxlRGF0YSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgICAgICB0aGlzLnJlbmRlcigpO1xuICAgICAgfVxuXG4gICAgICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgICAgdGhpcy5fX3JlbW92ZUNoaWxkcmVuKCk7XG4gICAgICB9XG5cbiAgICAgIF9faW5zZXJ0Q2hpbGRyZW4oKSB7XG4gICAgICAgIHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpcy5yb290LCB0aGlzKTtcbiAgICAgIH1cblxuICAgICAgX19yZW1vdmVDaGlsZHJlbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX19jaGlsZHJlbikge1xuICAgICAgICAgIGZvciAobGV0IGk9MDsgaTx0aGlzLl9fY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMucm9vdC5hcHBlbmRDaGlsZCh0aGlzLl9fY2hpbGRyZW5baV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEZvcmNlcyB0aGUgZWxlbWVudCB0byByZW5kZXIgaXRzIGNvbnRlbnQuIFRoaXMgaXMgdHlwaWNhbGx5IG9ubHlcbiAgICAgICAqIG5lY2Vzc2FyeSB0byBjYWxsIGlmIEhUTUxJbXBvcnRzIHdpdGggdGhlIGFzeW5jIGF0dHJpYnV0ZSBhcmUgdXNlZC5cbiAgICAgICAqL1xuICAgICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgdGVtcGxhdGU7XG4gICAgICAgIGlmICghdGhpcy5fX2NoaWxkcmVuKSB7XG4gICAgICAgICAgdGVtcGxhdGUgPSAvKiogQHR5cGUge0hUTUxUZW1wbGF0ZUVsZW1lbnR9ICovKHRlbXBsYXRlIHx8IHRoaXMucXVlcnlTZWxlY3RvcigndGVtcGxhdGUnKSk7XG4gICAgICAgICAgaWYgKCF0ZW1wbGF0ZSkge1xuICAgICAgICAgICAgLy8gV2FpdCB1bnRpbCBjaGlsZExpc3QgY2hhbmdlcyBhbmQgdGVtcGxhdGUgc2hvdWxkIGJlIHRoZXJlIGJ5IHRoZW5cbiAgICAgICAgICAgIGxldCBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKCgpID0+IHtcbiAgICAgICAgICAgICAgdGVtcGxhdGUgPSAvKiogQHR5cGUge0hUTUxUZW1wbGF0ZUVsZW1lbnR9ICovKHRoaXMucXVlcnlTZWxlY3RvcigndGVtcGxhdGUnKSk7XG4gICAgICAgICAgICAgIGlmICh0ZW1wbGF0ZSkge1xuICAgICAgICAgICAgICAgIG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcigpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZG9tLWJpbmQgcmVxdWlyZXMgYSA8dGVtcGxhdGU+IGNoaWxkJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICBvYnNlcnZlci5vYnNlcnZlKHRoaXMsIHtjaGlsZExpc3Q6IHRydWV9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5yb290ID0gdGhpcy5fc3RhbXBUZW1wbGF0ZSh0ZW1wbGF0ZSk7XG4gICAgICAgICAgdGhpcy4kID0gdGhpcy5yb290LiQ7XG4gICAgICAgICAgdGhpcy5fX2NoaWxkcmVuID0gW107XG4gICAgICAgICAgZm9yIChsZXQgbj10aGlzLnJvb3QuZmlyc3RDaGlsZDsgbjsgbj1uLm5leHRTaWJsaW5nKSB7XG4gICAgICAgICAgICB0aGlzLl9fY2hpbGRyZW5bdGhpcy5fX2NoaWxkcmVuLmxlbmd0aF0gPSBuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9lbmFibGVQcm9wZXJ0aWVzKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fX2luc2VydENoaWxkcmVuKCk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ2RvbS1jaGFuZ2UnLCB7XG4gICAgICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgICAgICBjb21wb3NlZDogdHJ1ZVxuICAgICAgICB9KSk7XG4gICAgICB9XG5cbiAgICB9XG5cbiAgICBjdXN0b21FbGVtZW50cy5kZWZpbmUoJ2RvbS1iaW5kJywgRG9tQmluZCk7XG5cbiAgfSkoKTtcblxuPC9zY3JpcHQ+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL3BvbHltZXIvbGliL2VsZW1lbnRzL2RvbS1iaW5kLmh0bWwiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi8uLi9wb2x5bWVyLWVsZW1lbnQuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3V0aWxzL3RlbXBsYXRpemUuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3V0aWxzL2RlYm91bmNlLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi91dGlscy9mbHVzaC5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vbWl4aW5zL211dGFibGUtZGF0YS5odG1sXCI+XG5cbjxzY3JpcHQ+XG4oZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBsZXQgVGVtcGxhdGVJbnN0YW5jZUJhc2UgPSBQb2x5bWVyLlRlbXBsYXRlSW5zdGFuY2VCYXNlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAaW1wbGVtZW50cyB7UG9seW1lcl9PcHRpb25hbE11dGFibGVEYXRhfVxuICAgKiBAZXh0ZW5kcyB7UG9seW1lci5FbGVtZW50fVxuICAgKi9cbiAgY29uc3QgZG9tUmVwZWF0QmFzZSA9IFBvbHltZXIuT3B0aW9uYWxNdXRhYmxlRGF0YShQb2x5bWVyLkVsZW1lbnQpO1xuXG4gIC8qKlxuICAgKiBUaGUgYDxkb20tcmVwZWF0PmAgZWxlbWVudCB3aWxsIGF1dG9tYXRpY2FsbHkgc3RhbXAgYW5kIGJpbmRzIG9uZSBpbnN0YW5jZVxuICAgKiBvZiB0ZW1wbGF0ZSBjb250ZW50IHRvIGVhY2ggb2JqZWN0IGluIGEgdXNlci1wcm92aWRlZCBhcnJheS5cbiAgICogYGRvbS1yZXBlYXRgIGFjY2VwdHMgYW4gYGl0ZW1zYCBwcm9wZXJ0eSwgYW5kIG9uZSBpbnN0YW5jZSBvZiB0aGUgdGVtcGxhdGVcbiAgICogaXMgc3RhbXBlZCBmb3IgZWFjaCBpdGVtIGludG8gdGhlIERPTSBhdCB0aGUgbG9jYXRpb24gb2YgdGhlIGBkb20tcmVwZWF0YFxuICAgKiBlbGVtZW50LiAgVGhlIGBpdGVtYCBwcm9wZXJ0eSB3aWxsIGJlIHNldCBvbiBlYWNoIGluc3RhbmNlJ3MgYmluZGluZ1xuICAgKiBzY29wZSwgdGh1cyB0ZW1wbGF0ZXMgc2hvdWxkIGJpbmQgdG8gc3ViLXByb3BlcnRpZXMgb2YgYGl0ZW1gLlxuICAgKlxuICAgKiBFeGFtcGxlOlxuICAgKlxuICAgKiBgYGBodG1sXG4gICAqIDxkb20tbW9kdWxlIGlkPVwiZW1wbG95ZWUtbGlzdFwiPlxuICAgKlxuICAgKiAgIDx0ZW1wbGF0ZT5cbiAgICpcbiAgICogICAgIDxkaXY+IEVtcGxveWVlIGxpc3Q6IDwvZGl2PlxuICAgKiAgICAgPHRlbXBsYXRlIGlzPVwiZG9tLXJlcGVhdFwiIGl0ZW1zPVwie3tlbXBsb3llZXN9fVwiPlxuICAgKiAgICAgICAgIDxkaXY+Rmlyc3QgbmFtZTogPHNwYW4+e3tpdGVtLmZpcnN0fX08L3NwYW4+PC9kaXY+XG4gICAqICAgICAgICAgPGRpdj5MYXN0IG5hbWU6IDxzcGFuPnt7aXRlbS5sYXN0fX08L3NwYW4+PC9kaXY+XG4gICAqICAgICA8L3RlbXBsYXRlPlxuICAgKlxuICAgKiAgIDwvdGVtcGxhdGU+XG4gICAqXG4gICAqICAgPHNjcmlwdD5cbiAgICogICAgIFBvbHltZXIoe1xuICAgKiAgICAgICBpczogJ2VtcGxveWVlLWxpc3QnLFxuICAgKiAgICAgICByZWFkeTogZnVuY3Rpb24oKSB7XG4gICAqICAgICAgICAgdGhpcy5lbXBsb3llZXMgPSBbXG4gICAqICAgICAgICAgICAgIHtmaXJzdDogJ0JvYicsIGxhc3Q6ICdTbWl0aCd9LFxuICAgKiAgICAgICAgICAgICB7Zmlyc3Q6ICdTYWxseScsIGxhc3Q6ICdKb2huc29uJ30sXG4gICAqICAgICAgICAgICAgIC4uLlxuICAgKiAgICAgICAgIF07XG4gICAqICAgICAgIH1cbiAgICogICAgIH0pO1xuICAgKiAgIDwgL3NjcmlwdD5cbiAgICpcbiAgICogPC9kb20tbW9kdWxlPlxuICAgKiBgYGBcbiAgICpcbiAgICogTm90aWZpY2F0aW9ucyBmb3IgY2hhbmdlcyB0byBpdGVtcyBzdWItcHJvcGVydGllcyB3aWxsIGJlIGZvcndhcmRlZCB0byB0ZW1wbGF0ZVxuICAgKiBpbnN0YW5jZXMsIHdoaWNoIHdpbGwgdXBkYXRlIHZpYSB0aGUgbm9ybWFsIHN0cnVjdHVyZWQgZGF0YSBub3RpZmljYXRpb24gc3lzdGVtLlxuICAgKlxuICAgKiBNdXRhdGlvbnMgdG8gdGhlIGBpdGVtc2AgYXJyYXkgaXRzZWxmIHNob3VsZCBiZSBtYWRlIHVzaW5nIHRoZSBBcnJheVxuICAgKiBtdXRhdGlvbiBBUEkncyBvbiBgUG9seW1lci5CYXNlYCAoYHB1c2hgLCBgcG9wYCwgYHNwbGljZWAsIGBzaGlmdGAsXG4gICAqIGB1bnNoaWZ0YCksIGFuZCB0ZW1wbGF0ZSBpbnN0YW5jZXMgd2lsbCBiZSBrZXB0IGluIHN5bmMgd2l0aCB0aGUgZGF0YSBpbiB0aGVcbiAgICogYXJyYXkuXG4gICAqXG4gICAqIEV2ZW50cyBjYXVnaHQgYnkgZXZlbnQgaGFuZGxlcnMgd2l0aGluIHRoZSBgZG9tLXJlcGVhdGAgdGVtcGxhdGUgd2lsbCBiZVxuICAgKiBkZWNvcmF0ZWQgd2l0aCBhIGBtb2RlbGAgcHJvcGVydHksIHdoaWNoIHJlcHJlc2VudHMgdGhlIGJpbmRpbmcgc2NvcGUgZm9yXG4gICAqIGVhY2ggdGVtcGxhdGUgaW5zdGFuY2UuICBUaGUgbW9kZWwgaXMgYW4gaW5zdGFuY2Ugb2YgUG9seW1lci5CYXNlLCBhbmQgc2hvdWxkXG4gICAqIGJlIHVzZWQgdG8gbWFuaXB1bGF0ZSBkYXRhIG9uIHRoZSBpbnN0YW5jZSwgZm9yIGV4YW1wbGVcbiAgICogYGV2ZW50Lm1vZGVsLnNldCgnaXRlbS5jaGVja2VkJywgdHJ1ZSk7YC5cbiAgICpcbiAgICogQWx0ZXJuYXRpdmVseSwgdGhlIG1vZGVsIGZvciBhIHRlbXBsYXRlIGluc3RhbmNlIGZvciBhbiBlbGVtZW50IHN0YW1wZWQgYnlcbiAgICogYSBgZG9tLXJlcGVhdGAgY2FuIGJlIG9idGFpbmVkIHVzaW5nIHRoZSBgbW9kZWxGb3JFbGVtZW50YCBBUEkgb24gdGhlXG4gICAqIGBkb20tcmVwZWF0YCB0aGF0IHN0YW1wZWQgaXQsIGZvciBleGFtcGxlXG4gICAqIGB0aGlzLiQuZG9tUmVwZWF0Lm1vZGVsRm9yRWxlbWVudChldmVudC50YXJnZXQpLnNldCgnaXRlbS5jaGVja2VkJywgdHJ1ZSk7YC5cbiAgICogVGhpcyBtYXkgYmUgdXNlZnVsIGZvciBtYW5pcHVsYXRpbmcgaW5zdGFuY2UgZGF0YSBvZiBldmVudCB0YXJnZXRzIG9idGFpbmVkXG4gICAqIGJ5IGV2ZW50IGhhbmRsZXJzIG9uIHBhcmVudHMgb2YgdGhlIGBkb20tcmVwZWF0YCAoZXZlbnQgZGVsZWdhdGlvbikuXG4gICAqXG4gICAqIEEgdmlldy1zcGVjaWZpYyBmaWx0ZXIvc29ydCBtYXkgYmUgYXBwbGllZCB0byBlYWNoIGBkb20tcmVwZWF0YCBieSBzdXBwbHlpbmcgYVxuICAgKiBgZmlsdGVyYCBhbmQvb3IgYHNvcnRgIHByb3BlcnR5LiAgVGhpcyBtYXkgYmUgYSBzdHJpbmcgdGhhdCBuYW1lcyBhIGZ1bmN0aW9uIG9uXG4gICAqIHRoZSBob3N0LCBvciBhIGZ1bmN0aW9uIG1heSBiZSBhc3NpZ25lZCB0byB0aGUgcHJvcGVydHkgZGlyZWN0bHkuICBUaGUgZnVuY3Rpb25zXG4gICAqIHNob3VsZCBpbXBsZW1lbnRlZCBmb2xsb3dpbmcgdGhlIHN0YW5kYXJkIGBBcnJheWAgZmlsdGVyL3NvcnQgQVBJLlxuICAgKlxuICAgKiBJbiBvcmRlciB0byByZS1ydW4gdGhlIGZpbHRlciBvciBzb3J0IGZ1bmN0aW9ucyBiYXNlZCBvbiBjaGFuZ2VzIHRvIHN1Yi1maWVsZHNcbiAgICogb2YgYGl0ZW1zYCwgdGhlIGBvYnNlcnZlYCBwcm9wZXJ0eSBtYXkgYmUgc2V0IGFzIGEgc3BhY2Utc2VwYXJhdGVkIGxpc3Qgb2ZcbiAgICogYGl0ZW1gIHN1Yi1maWVsZHMgdGhhdCBzaG91bGQgY2F1c2UgYSByZS1maWx0ZXIvc29ydCB3aGVuIG1vZGlmaWVkLiAgSWZcbiAgICogdGhlIGZpbHRlciBvciBzb3J0IGZ1bmN0aW9uIGRlcGVuZHMgb24gcHJvcGVydGllcyBub3QgY29udGFpbmVkIGluIGBpdGVtc2AsXG4gICAqIHRoZSB1c2VyIHNob3VsZCBvYnNlcnZlIGNoYW5nZXMgdG8gdGhvc2UgcHJvcGVydGllcyBhbmQgY2FsbCBgcmVuZGVyYCB0byB1cGRhdGVcbiAgICogdGhlIHZpZXcgYmFzZWQgb24gdGhlIGRlcGVuZGVuY3kgY2hhbmdlLlxuICAgKlxuICAgKiBGb3IgZXhhbXBsZSwgZm9yIGFuIGBkb20tcmVwZWF0YCB3aXRoIGEgZmlsdGVyIG9mIHRoZSBmb2xsb3dpbmc6XG4gICAqXG4gICAqIGBgYGpzXG4gICAqIGlzRW5naW5lZXI6IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICogICAgIHJldHVybiBpdGVtLnR5cGUgPT0gJ2VuZ2luZWVyJyB8fCBpdGVtLm1hbmFnZXIudHlwZSA9PSAnZW5naW5lZXInO1xuICAgKiB9XG4gICAqIGBgYFxuICAgKlxuICAgKiBUaGVuIHRoZSBgb2JzZXJ2ZWAgcHJvcGVydHkgc2hvdWxkIGJlIGNvbmZpZ3VyZWQgYXMgZm9sbG93czpcbiAgICpcbiAgICogYGBgaHRtbFxuICAgKiA8dGVtcGxhdGUgaXM9XCJkb20tcmVwZWF0XCIgaXRlbXM9XCJ7e2VtcGxveWVlc319XCJcbiAgICogICAgICAgICAgIGZpbHRlcj1cImlzRW5naW5lZXJcIiBvYnNlcnZlPVwidHlwZSBtYW5hZ2VyLnR5cGVcIj5cbiAgICogYGBgXG4gICAqXG4gICAqIEBjdXN0b21FbGVtZW50XG4gICAqIEBwb2x5bWVyXG4gICAqIEBtZW1iZXJvZiBQb2x5bWVyXG4gICAqIEBleHRlbmRzIHtkb21SZXBlYXRCYXNlfVxuICAgKiBAYXBwbGllc01peGluIFBvbHltZXIuT3B0aW9uYWxNdXRhYmxlRGF0YVxuICAgKiBAc3VtbWFyeSBDdXN0b20gZWxlbWVudCBmb3Igc3RhbXBpbmcgaW5zdGFuY2Ugb2YgYSB0ZW1wbGF0ZSBib3VuZCB0b1xuICAgKiAgIGl0ZW1zIGluIGFuIGFycmF5LlxuICAgKi9cbiAgY2xhc3MgRG9tUmVwZWF0IGV4dGVuZHMgZG9tUmVwZWF0QmFzZSB7XG5cbiAgICAvLyBOb3QgbmVlZGVkIHRvIGZpbmQgdGVtcGxhdGU7IGNhbiBiZSByZW1vdmVkIG9uY2UgdGhlIGFuYWx5emVyXG4gICAgLy8gY2FuIGZpbmQgdGhlIHRhZyBuYW1lIGZyb20gY3VzdG9tRWxlbWVudHMuZGVmaW5lIGNhbGxcbiAgICBzdGF0aWMgZ2V0IGlzKCkgeyByZXR1cm4gJ2RvbS1yZXBlYXQnOyB9XG5cbiAgICBzdGF0aWMgZ2V0IHRlbXBsYXRlKCkgeyByZXR1cm4gbnVsbDsgfVxuXG4gICAgc3RhdGljIGdldCBwcm9wZXJ0aWVzKCkge1xuXG4gICAgICAvKipcbiAgICAgICAqIEZpcmVkIHdoZW5ldmVyIERPTSBpcyBhZGRlZCBvciByZW1vdmVkIGJ5IHRoaXMgdGVtcGxhdGUgKGJ5XG4gICAgICAgKiBkZWZhdWx0LCByZW5kZXJpbmcgb2NjdXJzIGxhemlseSkuICBUbyBmb3JjZSBpbW1lZGlhdGUgcmVuZGVyaW5nLCBjYWxsXG4gICAgICAgKiBgcmVuZGVyYC5cbiAgICAgICAqXG4gICAgICAgKiBAZXZlbnQgZG9tLWNoYW5nZVxuICAgICAgICovXG4gICAgICByZXR1cm4ge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbiBhcnJheSBjb250YWluaW5nIGl0ZW1zIGRldGVybWluaW5nIGhvdyBtYW55IGluc3RhbmNlcyBvZiB0aGUgdGVtcGxhdGVcbiAgICAgICAgICogdG8gc3RhbXAgYW5kIHRoYXQgdGhhdCBlYWNoIHRlbXBsYXRlIGluc3RhbmNlIHNob3VsZCBiaW5kIHRvLlxuICAgICAgICAgKi9cbiAgICAgICAgaXRlbXM6IHtcbiAgICAgICAgICB0eXBlOiBBcnJheVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbmFtZSBvZiB0aGUgdmFyaWFibGUgdG8gYWRkIHRvIHRoZSBiaW5kaW5nIHNjb3BlIGZvciB0aGUgYXJyYXlcbiAgICAgICAgICogZWxlbWVudCBhc3NvY2lhdGVkIHdpdGggYSBnaXZlbiB0ZW1wbGF0ZSBpbnN0YW5jZS5cbiAgICAgICAgICovXG4gICAgICAgIGFzOiB7XG4gICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgIHZhbHVlOiAnaXRlbSdcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG5hbWUgb2YgdGhlIHZhcmlhYmxlIHRvIGFkZCB0byB0aGUgYmluZGluZyBzY29wZSB3aXRoIHRoZSBpbmRleFxuICAgICAgICAgKiBvZiB0aGUgaW5zdGFuY2UgaW4gdGhlIHNvcnRlZCBhbmQgZmlsdGVyZWQgbGlzdCBvZiByZW5kZXJlZCBpdGVtcy5cbiAgICAgICAgICogTm90ZSwgZm9yIHRoZSBpbmRleCBpbiB0aGUgYHRoaXMuaXRlbXNgIGFycmF5LCB1c2UgdGhlIHZhbHVlIG9mIHRoZVxuICAgICAgICAgKiBgaXRlbXNJbmRleEFzYCBwcm9wZXJ0eS5cbiAgICAgICAgICovXG4gICAgICAgIGluZGV4QXM6IHtcbiAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgdmFsdWU6ICdpbmRleCdcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG5hbWUgb2YgdGhlIHZhcmlhYmxlIHRvIGFkZCB0byB0aGUgYmluZGluZyBzY29wZSB3aXRoIHRoZSBpbmRleFxuICAgICAgICAgKiBvZiB0aGUgaW5zdGFuY2UgaW4gdGhlIGB0aGlzLml0ZW1zYCBhcnJheS4gTm90ZSwgZm9yIHRoZSBpbmRleCBvZlxuICAgICAgICAgKiB0aGlzIGluc3RhbmNlIGluIHRoZSBzb3J0ZWQgYW5kIGZpbHRlcmVkIGxpc3Qgb2YgcmVuZGVyZWQgaXRlbXMsXG4gICAgICAgICAqIHVzZSB0aGUgdmFsdWUgb2YgdGhlIGBpbmRleEFzYCBwcm9wZXJ0eS5cbiAgICAgICAgICovXG4gICAgICAgIGl0ZW1zSW5kZXhBczoge1xuICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICB2YWx1ZTogJ2l0ZW1zSW5kZXgnXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgZnVuY3Rpb24gdGhhdCBzaG91bGQgZGV0ZXJtaW5lIHRoZSBzb3J0IG9yZGVyIG9mIHRoZSBpdGVtcy4gIFRoaXNcbiAgICAgICAgICogcHJvcGVydHkgc2hvdWxkIGVpdGhlciBiZSBwcm92aWRlZCBhcyBhIHN0cmluZywgaW5kaWNhdGluZyBhIG1ldGhvZFxuICAgICAgICAgKiBuYW1lIG9uIHRoZSBlbGVtZW50J3MgaG9zdCwgb3IgZWxzZSBiZSBhbiBhY3R1YWwgZnVuY3Rpb24uICBUaGVcbiAgICAgICAgICogZnVuY3Rpb24gc2hvdWxkIG1hdGNoIHRoZSBzb3J0IGZ1bmN0aW9uIHBhc3NlZCB0byBgQXJyYXkuc29ydGAuXG4gICAgICAgICAqIFVzaW5nIGEgc29ydCBmdW5jdGlvbiBoYXMgbm8gZWZmZWN0IG9uIHRoZSB1bmRlcmx5aW5nIGBpdGVtc2AgYXJyYXkuXG4gICAgICAgICAqL1xuICAgICAgICBzb3J0OiB7XG4gICAgICAgICAgdHlwZTogRnVuY3Rpb24sXG4gICAgICAgICAgb2JzZXJ2ZXI6ICdfX3NvcnRDaGFuZ2VkJ1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQgdG8gZmlsdGVyIGl0ZW1zIG91dCBvZiB0aGUgdmlldy4gIFRoaXNcbiAgICAgICAgICogcHJvcGVydHkgc2hvdWxkIGVpdGhlciBiZSBwcm92aWRlZCBhcyBhIHN0cmluZywgaW5kaWNhdGluZyBhIG1ldGhvZFxuICAgICAgICAgKiBuYW1lIG9uIHRoZSBlbGVtZW50J3MgaG9zdCwgb3IgZWxzZSBiZSBhbiBhY3R1YWwgZnVuY3Rpb24uICBUaGVcbiAgICAgICAgICogZnVuY3Rpb24gc2hvdWxkIG1hdGNoIHRoZSBzb3J0IGZ1bmN0aW9uIHBhc3NlZCB0byBgQXJyYXkuZmlsdGVyYC5cbiAgICAgICAgICogVXNpbmcgYSBmaWx0ZXIgZnVuY3Rpb24gaGFzIG5vIGVmZmVjdCBvbiB0aGUgdW5kZXJseWluZyBgaXRlbXNgIGFycmF5LlxuICAgICAgICAgKi9cbiAgICAgICAgZmlsdGVyOiB7XG4gICAgICAgICAgdHlwZTogRnVuY3Rpb24sXG4gICAgICAgICAgb2JzZXJ2ZXI6ICdfX2ZpbHRlckNoYW5nZWQnXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZW4gdXNpbmcgYSBgZmlsdGVyYCBvciBgc29ydGAgZnVuY3Rpb24sIHRoZSBgb2JzZXJ2ZWAgcHJvcGVydHlcbiAgICAgICAgICogc2hvdWxkIGJlIHNldCB0byBhIHNwYWNlLXNlcGFyYXRlZCBsaXN0IG9mIHRoZSBuYW1lcyBvZiBpdGVtXG4gICAgICAgICAqIHN1Yi1maWVsZHMgdGhhdCBzaG91bGQgdHJpZ2dlciBhIHJlLXNvcnQgb3IgcmUtZmlsdGVyIHdoZW4gY2hhbmdlZC5cbiAgICAgICAgICogVGhlc2Ugc2hvdWxkIGdlbmVyYWxseSBiZSBmaWVsZHMgb2YgYGl0ZW1gIHRoYXQgdGhlIHNvcnQgb3IgZmlsdGVyXG4gICAgICAgICAqIGZ1bmN0aW9uIGRlcGVuZHMgb24uXG4gICAgICAgICAqL1xuICAgICAgICBvYnNlcnZlOiB7XG4gICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgIG9ic2VydmVyOiAnX19vYnNlcnZlQ2hhbmdlZCdcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogV2hlbiB1c2luZyBhIGBmaWx0ZXJgIG9yIGBzb3J0YCBmdW5jdGlvbiwgdGhlIGBkZWxheWAgcHJvcGVydHlcbiAgICAgICAgICogZGV0ZXJtaW5lcyBhIGRlYm91bmNlIHRpbWUgYWZ0ZXIgYSBjaGFuZ2UgdG8gb2JzZXJ2ZWQgaXRlbVxuICAgICAgICAgKiBwcm9wZXJ0aWVzIHRoYXQgbXVzdCBwYXNzIGJlZm9yZSB0aGUgZmlsdGVyIG9yIHNvcnQgaXMgcmUtcnVuLlxuICAgICAgICAgKiBUaGlzIGlzIHVzZWZ1bCBpbiByYXRlLWxpbWl0aW5nIHNodWZmaW5nIG9mIHRoZSB2aWV3IHdoZW5cbiAgICAgICAgICogaXRlbSBjaGFuZ2VzIG1heSBiZSBmcmVxdWVudC5cbiAgICAgICAgICovXG4gICAgICAgIGRlbGF5OiBOdW1iZXIsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvdW50IG9mIGN1cnJlbnRseSByZW5kZXJlZCBpdGVtcyBhZnRlciBgZmlsdGVyYCAoaWYgYW55KSBoYXMgYmVlbiBhcHBsaWVkLlxuICAgICAgICAgKiBJZiBcImNodW5raW5nIG1vZGVcIiBpcyBlbmFibGVkLCBgcmVuZGVyZWRJdGVtQ291bnRgIGlzIHVwZGF0ZWQgZWFjaCB0aW1lIGFcbiAgICAgICAgICogc2V0IG9mIHRlbXBsYXRlIGluc3RhbmNlcyBpcyByZW5kZXJlZC5cbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIHJlbmRlcmVkSXRlbUNvdW50OiB7XG4gICAgICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgICAgIG5vdGlmeTogdHJ1ZSxcbiAgICAgICAgICByZWFkT25seTogdHJ1ZVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWZpbmVzIGFuIGluaXRpYWwgY291bnQgb2YgdGVtcGxhdGUgaW5zdGFuY2VzIHRvIHJlbmRlciBhZnRlciBzZXR0aW5nXG4gICAgICAgICAqIHRoZSBgaXRlbXNgIGFycmF5LCBiZWZvcmUgdGhlIG5leHQgcGFpbnQsIGFuZCBwdXRzIHRoZSBgZG9tLXJlcGVhdGBcbiAgICAgICAgICogaW50byBcImNodW5raW5nIG1vZGVcIi4gIFRoZSByZW1haW5pbmcgaXRlbXMgd2lsbCBiZSBjcmVhdGVkIGFuZCByZW5kZXJlZFxuICAgICAgICAgKiBpbmNyZW1lbnRhbGx5IGF0IGVhY2ggYW5pbWF0aW9uIGZyYW1lIHRoZXJvZiB1bnRpbCBhbGwgaW5zdGFuY2VzIGhhdmVcbiAgICAgICAgICogYmVlbiByZW5kZXJlZC5cbiAgICAgICAgICovXG4gICAgICAgIGluaXRpYWxDb3VudDoge1xuICAgICAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgICAgICBvYnNlcnZlcjogJ19faW5pdGlhbGl6ZUNodW5raW5nJ1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGVuIGBpbml0aWFsQ291bnRgIGlzIHVzZWQsIHRoaXMgcHJvcGVydHkgZGVmaW5lcyBhIGZyYW1lIHJhdGUgdG9cbiAgICAgICAgICogdGFyZ2V0IGJ5IHRocm90dGxpbmcgdGhlIG51bWJlciBvZiBpbnN0YW5jZXMgcmVuZGVyZWQgZWFjaCBmcmFtZSB0b1xuICAgICAgICAgKiBub3QgZXhjZWVkIHRoZSBidWRnZXQgZm9yIHRoZSB0YXJnZXQgZnJhbWUgcmF0ZS4gIFNldHRpbmcgdGhpcyB0byBhXG4gICAgICAgICAqIGhpZ2hlciBudW1iZXIgd2lsbCBhbGxvdyBsb3dlciBsYXRlbmN5IGFuZCBoaWdoZXIgdGhyb3VnaHB1dCBmb3JcbiAgICAgICAgICogdGhpbmdzIGxpa2UgZXZlbnQgaGFuZGxlcnMsIGJ1dCB3aWxsIHJlc3VsdCBpbiBhIGxvbmdlciB0aW1lIGZvciB0aGVcbiAgICAgICAgICogcmVtYWluaW5nIGl0ZW1zIHRvIGNvbXBsZXRlIHJlbmRlcmluZy5cbiAgICAgICAgICovXG4gICAgICAgIHRhcmdldEZyYW1lcmF0ZToge1xuICAgICAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgICAgICB2YWx1ZTogMjBcbiAgICAgICAgfSxcblxuICAgICAgICBfdGFyZ2V0RnJhbWVUaW1lOiB7XG4gICAgICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgICAgIGNvbXB1dGVkOiAnX19jb21wdXRlRnJhbWVUaW1lKHRhcmdldEZyYW1lcmF0ZSknXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgfVxuXG4gICAgc3RhdGljIGdldCBvYnNlcnZlcnMoKSB7XG4gICAgICByZXR1cm4gWyAnX19pdGVtc0NoYW5nZWQoaXRlbXMuKiknIF1cbiAgICB9XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgIHN1cGVyKCk7XG4gICAgICB0aGlzLl9faW5zdGFuY2VzID0gW107XG4gICAgICB0aGlzLl9fbGltaXQgPSBJbmZpbml0eTtcbiAgICAgIHRoaXMuX19wb29sID0gW107XG4gICAgICB0aGlzLl9fcmVuZGVyRGVib3VuY2VyID0gbnVsbDtcbiAgICAgIHRoaXMuX19pdGVtc0lkeFRvSW5zdElkeCA9IHt9O1xuICAgICAgdGhpcy5fX2NodW5rQ291bnQgPSBudWxsO1xuICAgICAgdGhpcy5fX2xhc3RDaHVua1RpbWUgPSBudWxsO1xuICAgICAgdGhpcy5fX3NvcnRGbiA9IG51bGw7XG4gICAgICB0aGlzLl9fZmlsdGVyRm4gPSBudWxsO1xuICAgICAgdGhpcy5fX29ic2VydmVQYXRocyA9IG51bGw7XG4gICAgICB0aGlzLl9fY3RvciA9IG51bGw7XG4gICAgICB0aGlzLl9faXNEZXRhY2hlZCA9IHRydWU7XG4gICAgICB0aGlzLnRlbXBsYXRlID0gbnVsbDtcbiAgICB9XG5cbiAgICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgIHN1cGVyLmRpc2Nvbm5lY3RlZENhbGxiYWNrKCk7XG4gICAgICB0aGlzLl9faXNEZXRhY2hlZCA9IHRydWU7XG4gICAgICBmb3IgKGxldCBpPTA7IGk8dGhpcy5fX2luc3RhbmNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLl9fZGV0YWNoSW5zdGFuY2UoaSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgICBzdXBlci5jb25uZWN0ZWRDYWxsYmFjaygpO1xuICAgICAgLy8gb25seSBwZXJmb3JtIGF0dGFjaG1lbnQgaWYgdGhlIGVsZW1lbnQgd2FzIHByZXZpb3VzbHkgZGV0YWNoZWQuXG4gICAgICBpZiAodGhpcy5fX2lzRGV0YWNoZWQpIHtcbiAgICAgICAgdGhpcy5fX2lzRGV0YWNoZWQgPSBmYWxzZTtcbiAgICAgICAgbGV0IHBhcmVudCA9IHRoaXMucGFyZW50Tm9kZTtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPHRoaXMuX19pbnN0YW5jZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB0aGlzLl9fYXR0YWNoSW5zdGFuY2UoaSwgcGFyZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIF9fZW5zdXJlVGVtcGxhdGl6ZWQoKSB7XG4gICAgICAvLyBUZW1wbGF0aXppbmcgKGdlbmVyYXRpbmcgdGhlIGluc3RhbmNlIGNvbnN0cnVjdG9yKSBuZWVkcyB0byB3YWl0XG4gICAgICAvLyB1bnRpbCByZWFkeSwgc2luY2Ugd29uJ3QgaGF2ZSBpdHMgdGVtcGxhdGUgY29udGVudCBoYW5kZWQgYmFjayB0b1xuICAgICAgLy8gaXQgdW50aWwgdGhlblxuICAgICAgaWYgKCF0aGlzLl9fY3Rvcikge1xuICAgICAgICBsZXQgdGVtcGxhdGUgPSB0aGlzLnRlbXBsYXRlID0gdGhpcy5xdWVyeVNlbGVjdG9yKCd0ZW1wbGF0ZScpO1xuICAgICAgICBpZiAoIXRlbXBsYXRlKSB7XG4gICAgICAgICAgLy8gLy8gV2FpdCB1bnRpbCBjaGlsZExpc3QgY2hhbmdlcyBhbmQgdGVtcGxhdGUgc2hvdWxkIGJlIHRoZXJlIGJ5IHRoZW5cbiAgICAgICAgICBsZXQgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcigoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5xdWVyeVNlbGVjdG9yKCd0ZW1wbGF0ZScpKSB7XG4gICAgICAgICAgICAgIG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgICAgdGhpcy5fX3JlbmRlcigpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkb20tcmVwZWF0IHJlcXVpcmVzIGEgPHRlbXBsYXRlPiBjaGlsZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgICAgb2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLCB7Y2hpbGRMaXN0OiB0cnVlfSk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRlbXBsYXRlIGluc3RhbmNlIHByb3BzIHRoYXQgc2hvdWxkIGJlIGV4Y2x1ZGVkIGZyb20gZm9yd2FyZGluZ1xuICAgICAgICBsZXQgaW5zdGFuY2VQcm9wcyA9IHt9O1xuICAgICAgICBpbnN0YW5jZVByb3BzW3RoaXMuYXNdID0gdHJ1ZTtcbiAgICAgICAgaW5zdGFuY2VQcm9wc1t0aGlzLmluZGV4QXNdID0gdHJ1ZTtcbiAgICAgICAgaW5zdGFuY2VQcm9wc1t0aGlzLml0ZW1zSW5kZXhBc10gPSB0cnVlO1xuICAgICAgICB0aGlzLl9fY3RvciA9IFBvbHltZXIuVGVtcGxhdGl6ZS50ZW1wbGF0aXplKHRlbXBsYXRlLCB0aGlzLCB7XG4gICAgICAgICAgbXV0YWJsZURhdGE6IHRoaXMubXV0YWJsZURhdGEsXG4gICAgICAgICAgcGFyZW50TW9kZWw6IHRydWUsXG4gICAgICAgICAgaW5zdGFuY2VQcm9wczogaW5zdGFuY2VQcm9wcyxcbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBAdGhpcyB7dGhpc31cbiAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcCBQcm9wZXJ0eSB0byBzZXRcbiAgICAgICAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIHNldCBwcm9wZXJ0eSB0b1xuICAgICAgICAgICAqL1xuICAgICAgICAgIGZvcndhcmRIb3N0UHJvcDogZnVuY3Rpb24ocHJvcCwgdmFsdWUpIHtcbiAgICAgICAgICAgIGxldCBpJCA9IHRoaXMuX19pbnN0YW5jZXM7XG4gICAgICAgICAgICBmb3IgKGxldCBpPTAsIGluc3Q7IChpPGkkLmxlbmd0aCkgJiYgKGluc3Q9aSRbaV0pOyBpKyspIHtcbiAgICAgICAgICAgICAgaW5zdC5mb3J3YXJkSG9zdFByb3AocHJvcCwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogQHRoaXMge3RoaXN9XG4gICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGluc3QgSW5zdGFuY2UgdG8gbm90aWZ5XG4gICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3AgUHJvcGVydHkgdG8gbm90aWZ5XG4gICAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byBub3RpZnlcbiAgICAgICAgICAgKi9cbiAgICAgICAgICBub3RpZnlJbnN0YW5jZVByb3A6IGZ1bmN0aW9uKGluc3QsIHByb3AsIHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoUG9seW1lci5QYXRoLm1hdGNoZXModGhpcy5hcywgcHJvcCkpIHtcbiAgICAgICAgICAgICAgbGV0IGlkeCA9IGluc3RbdGhpcy5pdGVtc0luZGV4QXNdO1xuICAgICAgICAgICAgICBpZiAocHJvcCA9PSB0aGlzLmFzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pdGVtc1tpZHhdID0gdmFsdWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbGV0IHBhdGggPSBQb2x5bWVyLlBhdGgudHJhbnNsYXRlKHRoaXMuYXMsICdpdGVtcy4nICsgaWR4LCBwcm9wKTtcbiAgICAgICAgICAgICAgdGhpcy5ub3RpZnlQYXRoKHBhdGgsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgX19nZXRNZXRob2RIb3N0KCkge1xuICAgICAgLy8gVGVjaG5pY2FsbHkgdGhpcyBzaG91bGQgYmUgdGhlIG93bmVyIG9mIHRoZSBvdXRlcm1vc3QgdGVtcGxhdGUuXG4gICAgICAvLyBJbiBzaGFkb3cgZG9tLCB0aGlzIGlzIGFsd2F5cyBnZXRSb290Tm9kZSgpLmhvc3QsIGJ1dCB3ZSBjYW5cbiAgICAgIC8vIGFwcHJveGltYXRlIHRoaXMgdmlhIGNvb3BlcmF0aW9uIHdpdGggb3VyIGRhdGFIb3N0IGFsd2F5cyBzZXR0aW5nXG4gICAgICAvLyBgX21ldGhvZEhvc3RgIGFzIGxvbmcgYXMgdGhlcmUgd2VyZSBiaW5kaW5ncyAob3IgaWQncykgb24gdGhpc1xuICAgICAgLy8gaW5zdGFuY2UgY2F1c2luZyBpdCB0byBnZXQgYSBkYXRhSG9zdC5cbiAgICAgIHJldHVybiB0aGlzLl9fZGF0YUhvc3QuX21ldGhvZEhvc3QgfHwgdGhpcy5fX2RhdGFIb3N0O1xuICAgIH1cblxuICAgIF9fc29ydENoYW5nZWQoc29ydCkge1xuICAgICAgbGV0IG1ldGhvZEhvc3QgPSB0aGlzLl9fZ2V0TWV0aG9kSG9zdCgpO1xuICAgICAgdGhpcy5fX3NvcnRGbiA9IHNvcnQgJiYgKHR5cGVvZiBzb3J0ID09ICdmdW5jdGlvbicgPyBzb3J0IDpcbiAgICAgICAgZnVuY3Rpb24oKSB7IHJldHVybiBtZXRob2RIb3N0W3NvcnRdLmFwcGx5KG1ldGhvZEhvc3QsIGFyZ3VtZW50cyk7IH0pO1xuICAgICAgaWYgKHRoaXMuaXRlbXMpIHtcbiAgICAgICAgdGhpcy5fX2RlYm91bmNlUmVuZGVyKHRoaXMuX19yZW5kZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIF9fZmlsdGVyQ2hhbmdlZChmaWx0ZXIpIHtcbiAgICAgIGxldCBtZXRob2RIb3N0ID0gdGhpcy5fX2dldE1ldGhvZEhvc3QoKTtcbiAgICAgIHRoaXMuX19maWx0ZXJGbiA9IGZpbHRlciAmJiAodHlwZW9mIGZpbHRlciA9PSAnZnVuY3Rpb24nID8gZmlsdGVyIDpcbiAgICAgICAgZnVuY3Rpb24oKSB7IHJldHVybiBtZXRob2RIb3N0W2ZpbHRlcl0uYXBwbHkobWV0aG9kSG9zdCwgYXJndW1lbnRzKTsgfSk7XG4gICAgICBpZiAodGhpcy5pdGVtcykge1xuICAgICAgICB0aGlzLl9fZGVib3VuY2VSZW5kZXIodGhpcy5fX3JlbmRlcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgX19jb21wdXRlRnJhbWVUaW1lKHJhdGUpIHtcbiAgICAgIHJldHVybiBNYXRoLmNlaWwoMTAwMC9yYXRlKTtcbiAgICB9XG5cbiAgICBfX2luaXRpYWxpemVDaHVua2luZygpIHtcbiAgICAgIGlmICh0aGlzLmluaXRpYWxDb3VudCkge1xuICAgICAgICB0aGlzLl9fbGltaXQgPSB0aGlzLmluaXRpYWxDb3VudDtcbiAgICAgICAgdGhpcy5fX2NodW5rQ291bnQgPSB0aGlzLmluaXRpYWxDb3VudDtcbiAgICAgICAgdGhpcy5fX2xhc3RDaHVua1RpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfX3RyeVJlbmRlckNodW5rKCkge1xuICAgICAgLy8gRGVib3VuY2VkIHNvIHRoYXQgbXVsdGlwbGUgY2FsbHMgdGhyb3VnaCBgX3JlbmRlcmAgYmV0d2VlbiBhbmltYXRpb25cbiAgICAgIC8vIGZyYW1lcyBvbmx5IHF1ZXVlIG9uZSBuZXcgckFGIChlLmcuIGFycmF5IG11dGF0aW9uICYgY2h1bmtlZCByZW5kZXIpXG4gICAgICBpZiAodGhpcy5pdGVtcyAmJiB0aGlzLl9fbGltaXQgPCB0aGlzLml0ZW1zLmxlbmd0aCkge1xuICAgICAgICB0aGlzLl9fZGVib3VuY2VSZW5kZXIodGhpcy5fX3JlcXVlc3RSZW5kZXJDaHVuayk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgX19yZXF1ZXN0UmVuZGVyQ2h1bmsoKSB7XG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCk9PnRoaXMuX19yZW5kZXJDaHVuaygpKTtcbiAgICB9XG5cbiAgICBfX3JlbmRlckNodW5rKCkge1xuICAgICAgLy8gU2ltcGxlIGF1dG8gY2h1bmtTaXplIHRocm90dGxpbmcgYWxnb3JpdGhtIGJhc2VkIG9uIGZlZWRiYWNrIGxvb3A6XG4gICAgICAvLyBtZWFzdXJlIGFjdHVhbCB0aW1lIGJldHdlZW4gZnJhbWVzIGFuZCBzY2FsZSBjaHVuayBjb3VudCBieSByYXRpb1xuICAgICAgLy8gb2YgdGFyZ2V0L2FjdHVhbCBmcmFtZSB0aW1lXG4gICAgICBsZXQgY3VyckNodW5rVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgbGV0IHJhdGlvID0gdGhpcy5fdGFyZ2V0RnJhbWVUaW1lIC8gKGN1cnJDaHVua1RpbWUgLSB0aGlzLl9fbGFzdENodW5rVGltZSk7XG4gICAgICB0aGlzLl9fY2h1bmtDb3VudCA9IE1hdGgucm91bmQodGhpcy5fX2NodW5rQ291bnQgKiByYXRpbykgfHwgMTtcbiAgICAgIHRoaXMuX19saW1pdCArPSB0aGlzLl9fY2h1bmtDb3VudDtcbiAgICAgIHRoaXMuX19sYXN0Q2h1bmtUaW1lID0gY3VyckNodW5rVGltZTtcbiAgICAgIHRoaXMuX19kZWJvdW5jZVJlbmRlcih0aGlzLl9fcmVuZGVyKTtcbiAgICB9XG5cbiAgICBfX29ic2VydmVDaGFuZ2VkKCkge1xuICAgICAgdGhpcy5fX29ic2VydmVQYXRocyA9IHRoaXMub2JzZXJ2ZSAmJlxuICAgICAgICB0aGlzLm9ic2VydmUucmVwbGFjZSgnLionLCAnLicpLnNwbGl0KCcgJyk7XG4gICAgfVxuXG4gICAgX19pdGVtc0NoYW5nZWQoY2hhbmdlKSB7XG4gICAgICBpZiAodGhpcy5pdGVtcyAmJiAhQXJyYXkuaXNBcnJheSh0aGlzLml0ZW1zKSkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ2RvbS1yZXBlYXQgZXhwZWN0ZWQgYXJyYXkgZm9yIGBpdGVtc2AsIGZvdW5kJywgdGhpcy5pdGVtcyk7XG4gICAgICB9XG4gICAgICAvLyBJZiBwYXRoIHdhcyB0byBhbiBpdGVtIChlLmcuICdpdGVtcy4zJyBvciAnaXRlbXMuMy5mb28nKSwgZm9yd2FyZCB0aGVcbiAgICAgIC8vIHBhdGggdG8gdGhhdCBpbnN0YW5jZSBzeW5jaHJvbm91c2x5IChyZXR1bnMgZmFsc2UgZm9yIG5vbi1pdGVtIHBhdGhzKVxuICAgICAgaWYgKCF0aGlzLl9faGFuZGxlSXRlbVBhdGgoY2hhbmdlLnBhdGgsIGNoYW5nZS52YWx1ZSkpIHtcbiAgICAgICAgLy8gT3RoZXJ3aXNlLCB0aGUgYXJyYXkgd2FzIHJlc2V0ICgnaXRlbXMnKSBvciBzcGxpY2VkICgnaXRlbXMuc3BsaWNlcycpLFxuICAgICAgICAvLyBzbyBxdWV1ZSBhIGZ1bGwgcmVmcmVzaFxuICAgICAgICB0aGlzLl9faW5pdGlhbGl6ZUNodW5raW5nKCk7XG4gICAgICAgIHRoaXMuX19kZWJvdW5jZVJlbmRlcih0aGlzLl9fcmVuZGVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfX2hhbmRsZU9ic2VydmVkUGF0aHMocGF0aCkge1xuICAgICAgaWYgKHRoaXMuX19vYnNlcnZlUGF0aHMpIHtcbiAgICAgICAgcGF0aCA9IHBhdGguc3Vic3RyaW5nKHBhdGguaW5kZXhPZignLicpICsgMSk7XG4gICAgICAgIGxldCBwYXRocyA9IHRoaXMuX19vYnNlcnZlUGF0aHM7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxwYXRocy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChwYXRoLmluZGV4T2YocGF0aHNbaV0pID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLl9fZGVib3VuY2VSZW5kZXIodGhpcy5fX3JlbmRlciwgdGhpcy5kZWxheSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKHRoaXM6RG9tUmVwZWF0KX0gZm4gRnVuY3Rpb24gdG8gZGVib3VuY2UuXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBkZWxheSBEZWxheSBpbiBtcyB0byBkZWJvdW5jZSBieS5cbiAgICAgKi9cbiAgICBfX2RlYm91bmNlUmVuZGVyKGZuLCBkZWxheSA9IDApIHtcbiAgICAgIHRoaXMuX19yZW5kZXJEZWJvdW5jZXIgPSBQb2x5bWVyLkRlYm91bmNlci5kZWJvdW5jZShcbiAgICAgICAgICAgIHRoaXMuX19yZW5kZXJEZWJvdW5jZXJcbiAgICAgICAgICAsIGRlbGF5ID4gMCA/IFBvbHltZXIuQXN5bmMudGltZU91dC5hZnRlcihkZWxheSkgOiBQb2x5bWVyLkFzeW5jLm1pY3JvVGFza1xuICAgICAgICAgICwgZm4uYmluZCh0aGlzKSk7XG4gICAgICBQb2x5bWVyLmVucXVldWVEZWJvdW5jZXIodGhpcy5fX3JlbmRlckRlYm91bmNlcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRm9yY2VzIHRoZSBlbGVtZW50IHRvIHJlbmRlciBpdHMgY29udGVudC4gTm9ybWFsbHkgcmVuZGVyaW5nIGlzXG4gICAgICogYXN5bmNocm9ub3VzIHRvIGEgcHJvdm9raW5nIGNoYW5nZS4gVGhpcyBpcyBkb25lIGZvciBlZmZpY2llbmN5IHNvXG4gICAgICogdGhhdCBtdWx0aXBsZSBjaGFuZ2VzIHRyaWdnZXIgb25seSBhIHNpbmdsZSByZW5kZXIuIFRoZSByZW5kZXIgbWV0aG9kXG4gICAgICogc2hvdWxkIGJlIGNhbGxlZCBpZiwgZm9yIGV4YW1wbGUsIHRlbXBsYXRlIHJlbmRlcmluZyBpcyByZXF1aXJlZCB0b1xuICAgICAqIHZhbGlkYXRlIGFwcGxpY2F0aW9uIHN0YXRlLlxuICAgICAqL1xuICAgIHJlbmRlcigpIHtcbiAgICAgIC8vIFF1ZXVlIHRoaXMgcmVwZWF0ZXIsIHRoZW4gZmx1c2ggYWxsIGluIG9yZGVyXG4gICAgICB0aGlzLl9fZGVib3VuY2VSZW5kZXIodGhpcy5fX3JlbmRlcik7XG4gICAgICBQb2x5bWVyLmZsdXNoKCk7XG4gICAgfVxuXG4gICAgX19yZW5kZXIoKSB7XG4gICAgICBpZiAoIXRoaXMuX19lbnN1cmVUZW1wbGF0aXplZCgpKSB7XG4gICAgICAgIC8vIE5vIHRlbXBsYXRlIGZvdW5kIHlldFxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl9fYXBwbHlGdWxsUmVmcmVzaCgpO1xuICAgICAgLy8gUmVzZXQgdGhlIHBvb2xcbiAgICAgIC8vIFRPRE8oa3NjaGFhZik6IFJldXNlIHBvb2wgYWNyb3NzIHR1cm5zIGFuZCBuZXN0ZWQgdGVtcGxhdGVzXG4gICAgICAvLyBOb3cgdGhhdCBvYmplY3RzL2FycmF5cyBhcmUgcmUtZXZhbHVhdGVkIHdoZW4gc2V0LCB3ZSBjYW4gc2FmZWx5XG4gICAgICAvLyByZXVzZSBwb29sZWQgaW5zdGFuY2VzIGFjcm9zcyB0dXJucywgaG93ZXZlciB3ZSBzdGlsbCBuZWVkIHRvIGRlY2lkZVxuICAgICAgLy8gc2VtYW50aWNzIHJlZ2FyZGluZyBob3cgbG9uZyB0byBob2xkLCBob3cgbWFueSB0byBob2xkLCBldGMuXG4gICAgICB0aGlzLl9fcG9vbC5sZW5ndGggPSAwO1xuICAgICAgLy8gU2V0IHJlbmRlcmVkIGl0ZW0gY291bnRcbiAgICAgIHRoaXMuX3NldFJlbmRlcmVkSXRlbUNvdW50KHRoaXMuX19pbnN0YW5jZXMubGVuZ3RoKTtcbiAgICAgIC8vIE5vdGlmeSB1c2Vyc1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnZG9tLWNoYW5nZScsIHtcbiAgICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgICAgY29tcG9zZWQ6IHRydWVcbiAgICAgIH0pKTtcbiAgICAgIC8vIENoZWNrIHRvIHNlZSBpZiB3ZSBuZWVkIHRvIHJlbmRlciBtb3JlIGl0ZW1zXG4gICAgICB0aGlzLl9fdHJ5UmVuZGVyQ2h1bmsoKTtcbiAgICB9XG5cbiAgICBfX2FwcGx5RnVsbFJlZnJlc2goKSB7XG4gICAgICBsZXQgaXRlbXMgPSB0aGlzLml0ZW1zIHx8IFtdO1xuICAgICAgbGV0IGlzbnRJZHhUb0l0ZW1zSWR4ID0gbmV3IEFycmF5KGl0ZW1zLmxlbmd0aCk7XG4gICAgICBmb3IgKGxldCBpPTA7IGk8aXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaXNudElkeFRvSXRlbXNJZHhbaV0gPSBpO1xuICAgICAgfVxuICAgICAgLy8gQXBwbHkgdXNlciBmaWx0ZXJcbiAgICAgIGlmICh0aGlzLl9fZmlsdGVyRm4pIHtcbiAgICAgICAgaXNudElkeFRvSXRlbXNJZHggPSBpc250SWR4VG9JdGVtc0lkeC5maWx0ZXIoKGksIGlkeCwgYXJyYXkpID0+XG4gICAgICAgICAgdGhpcy5fX2ZpbHRlckZuKGl0ZW1zW2ldLCBpZHgsIGFycmF5KSk7XG4gICAgICB9XG4gICAgICAvLyBBcHBseSB1c2VyIHNvcnRcbiAgICAgIGlmICh0aGlzLl9fc29ydEZuKSB7XG4gICAgICAgIGlzbnRJZHhUb0l0ZW1zSWR4LnNvcnQoKGEsIGIpID0+IHRoaXMuX19zb3J0Rm4oaXRlbXNbYV0sIGl0ZW1zW2JdKSk7XG4gICAgICB9XG4gICAgICAvLyBpdGVtcy0+aW5zdCBtYXAga2VwdCBmb3IgaXRlbSBwYXRoIGZvcndhcmRpbmdcbiAgICAgIGNvbnN0IGl0ZW1zSWR4VG9JbnN0SWR4ID0gdGhpcy5fX2l0ZW1zSWR4VG9JbnN0SWR4ID0ge307XG4gICAgICBsZXQgaW5zdElkeCA9IDA7XG4gICAgICAvLyBHZW5lcmF0ZSBpbnN0YW5jZXMgYW5kIGFzc2lnbiBpdGVtc1xuICAgICAgY29uc3QgbGltaXQgPSBNYXRoLm1pbihpc250SWR4VG9JdGVtc0lkeC5sZW5ndGgsIHRoaXMuX19saW1pdCk7XG4gICAgICBmb3IgKDsgaW5zdElkeDxsaW1pdDsgaW5zdElkeCsrKSB7XG4gICAgICAgIGxldCBpbnN0ID0gdGhpcy5fX2luc3RhbmNlc1tpbnN0SWR4XTtcbiAgICAgICAgbGV0IGl0ZW1JZHggPSBpc250SWR4VG9JdGVtc0lkeFtpbnN0SWR4XTtcbiAgICAgICAgbGV0IGl0ZW0gPSBpdGVtc1tpdGVtSWR4XTtcbiAgICAgICAgaXRlbXNJZHhUb0luc3RJZHhbaXRlbUlkeF0gPSBpbnN0SWR4O1xuICAgICAgICBpZiAoaW5zdCAmJiBpbnN0SWR4IDwgdGhpcy5fX2xpbWl0KSB7XG4gICAgICAgICAgaW5zdC5fc2V0UGVuZGluZ1Byb3BlcnR5KHRoaXMuYXMsIGl0ZW0pO1xuICAgICAgICAgIGluc3QuX3NldFBlbmRpbmdQcm9wZXJ0eSh0aGlzLmluZGV4QXMsIGluc3RJZHgpO1xuICAgICAgICAgIGluc3QuX3NldFBlbmRpbmdQcm9wZXJ0eSh0aGlzLml0ZW1zSW5kZXhBcywgaXRlbUlkeCk7XG4gICAgICAgICAgaW5zdC5fZmx1c2hQcm9wZXJ0aWVzKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fX2luc2VydEluc3RhbmNlKGl0ZW0sIGluc3RJZHgsIGl0ZW1JZHgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBSZW1vdmUgYW55IGV4dHJhIGluc3RhbmNlcyBmcm9tIHByZXZpb3VzIHN0YXRlXG4gICAgICBmb3IgKGxldCBpPXRoaXMuX19pbnN0YW5jZXMubGVuZ3RoLTE7IGk+PWluc3RJZHg7IGktLSkge1xuICAgICAgICB0aGlzLl9fZGV0YWNoQW5kUmVtb3ZlSW5zdGFuY2UoaSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgX19kZXRhY2hJbnN0YW5jZShpZHgpIHtcbiAgICAgIGxldCBpbnN0ID0gdGhpcy5fX2luc3RhbmNlc1tpZHhdO1xuICAgICAgZm9yIChsZXQgaT0wOyBpPGluc3QuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGVsID0gaW5zdC5jaGlsZHJlbltpXTtcbiAgICAgICAgaW5zdC5yb290LmFwcGVuZENoaWxkKGVsKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpbnN0O1xuICAgIH1cblxuICAgIF9fYXR0YWNoSW5zdGFuY2UoaWR4LCBwYXJlbnQpIHtcbiAgICAgIGxldCBpbnN0ID0gdGhpcy5fX2luc3RhbmNlc1tpZHhdO1xuICAgICAgcGFyZW50Lmluc2VydEJlZm9yZShpbnN0LnJvb3QsIHRoaXMpO1xuICAgIH1cblxuICAgIF9fZGV0YWNoQW5kUmVtb3ZlSW5zdGFuY2UoaWR4KSB7XG4gICAgICBsZXQgaW5zdCA9IHRoaXMuX19kZXRhY2hJbnN0YW5jZShpZHgpO1xuICAgICAgaWYgKGluc3QpIHtcbiAgICAgICAgdGhpcy5fX3Bvb2wucHVzaChpbnN0KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX19pbnN0YW5jZXMuc3BsaWNlKGlkeCwgMSk7XG4gICAgfVxuXG4gICAgX19zdGFtcEluc3RhbmNlKGl0ZW0sIGluc3RJZHgsIGl0ZW1JZHgpIHtcbiAgICAgIGxldCBtb2RlbCA9IHt9O1xuICAgICAgbW9kZWxbdGhpcy5hc10gPSBpdGVtO1xuICAgICAgbW9kZWxbdGhpcy5pbmRleEFzXSA9IGluc3RJZHg7XG4gICAgICBtb2RlbFt0aGlzLml0ZW1zSW5kZXhBc10gPSBpdGVtSWR4O1xuICAgICAgcmV0dXJuIG5ldyB0aGlzLl9fY3Rvcihtb2RlbCk7XG4gICAgfVxuXG4gICAgX19pbnNlcnRJbnN0YW5jZShpdGVtLCBpbnN0SWR4LCBpdGVtSWR4KSB7XG4gICAgICBsZXQgaW5zdCA9IHRoaXMuX19wb29sLnBvcCgpO1xuICAgICAgaWYgKGluc3QpIHtcbiAgICAgICAgLy8gVE9ETyhrc2NoYWFmKTogSWYgdGhlIHBvb2wgaXMgc2hhcmVkIGFjcm9zcyB0dXJucywgaG9zdFByb3BzXG4gICAgICAgIC8vIG5lZWQgdG8gYmUgcmUtc2V0IHRvIHJldXNlZCBpbnN0YW5jZXMgaW4gYWRkaXRpb24gdG8gaXRlbVxuICAgICAgICBpbnN0Ll9zZXRQZW5kaW5nUHJvcGVydHkodGhpcy5hcywgaXRlbSk7XG4gICAgICAgIGluc3QuX3NldFBlbmRpbmdQcm9wZXJ0eSh0aGlzLmluZGV4QXMsIGluc3RJZHgpO1xuICAgICAgICBpbnN0Ll9zZXRQZW5kaW5nUHJvcGVydHkodGhpcy5pdGVtc0luZGV4QXMsIGl0ZW1JZHgpO1xuICAgICAgICBpbnN0Ll9mbHVzaFByb3BlcnRpZXMoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluc3QgPSB0aGlzLl9fc3RhbXBJbnN0YW5jZShpdGVtLCBpbnN0SWR4LCBpdGVtSWR4KTtcbiAgICAgIH1cbiAgICAgIGxldCBiZWZvcmVSb3cgPSB0aGlzLl9faW5zdGFuY2VzW2luc3RJZHggKyAxXTtcbiAgICAgIGxldCBiZWZvcmVOb2RlID0gYmVmb3JlUm93ID8gYmVmb3JlUm93LmNoaWxkcmVuWzBdIDogdGhpcztcbiAgICAgIHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoaW5zdC5yb290LCBiZWZvcmVOb2RlKTtcbiAgICAgIHRoaXMuX19pbnN0YW5jZXNbaW5zdElkeF0gPSBpbnN0O1xuICAgICAgcmV0dXJuIGluc3Q7XG4gICAgfVxuXG4gICAgLy8gSW1wbGVtZW50cyBleHRlbnNpb24gcG9pbnQgZnJvbSBUZW1wbGF0aXplIG1peGluXG4gICAgX3Nob3dIaWRlQ2hpbGRyZW4oaGlkZGVuKSB7XG4gICAgICBmb3IgKGxldCBpPTA7IGk8dGhpcy5fX2luc3RhbmNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLl9faW5zdGFuY2VzW2ldLl9zaG93SGlkZUNoaWxkcmVuKGhpZGRlbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ2FsbGVkIGFzIGEgc2lkZSBlZmZlY3Qgb2YgYSBob3N0IGl0ZW1zLjxrZXk+LjxwYXRoPiBwYXRoIGNoYW5nZSxcbiAgICAvLyByZXNwb25zaWJsZSBmb3Igbm90aWZ5aW5nIGl0ZW0uPHBhdGg+IGNoYW5nZXMgdG8gaW5zdCBmb3Iga2V5XG4gICAgX19oYW5kbGVJdGVtUGF0aChwYXRoLCB2YWx1ZSkge1xuICAgICAgbGV0IGl0ZW1zUGF0aCA9IHBhdGguc2xpY2UoNik7IC8vICdpdGVtcy4nLmxlbmd0aCA9PSA2XG4gICAgICBsZXQgZG90ID0gaXRlbXNQYXRoLmluZGV4T2YoJy4nKTtcbiAgICAgIGxldCBpdGVtc0lkeCA9IGRvdCA8IDAgPyBpdGVtc1BhdGggOiBpdGVtc1BhdGguc3Vic3RyaW5nKDAsIGRvdCk7XG4gICAgICAvLyBJZiBwYXRoIHdhcyBpbmRleCBpbnRvIGFycmF5Li4uXG4gICAgICBpZiAoaXRlbXNJZHggPT0gcGFyc2VJbnQoaXRlbXNJZHgsIDEwKSkge1xuICAgICAgICBsZXQgaXRlbVN1YlBhdGggPSBkb3QgPCAwID8gJycgOiBpdGVtc1BhdGguc3Vic3RyaW5nKGRvdCsxKTtcbiAgICAgICAgLy8gSWYgdGhlIHBhdGggaXMgb2JzZXJ2ZWQsIGl0IHdpbGwgdHJpZ2dlciBhIGZ1bGwgcmVmcmVzaFxuICAgICAgICB0aGlzLl9faGFuZGxlT2JzZXJ2ZWRQYXRocyhpdGVtU3ViUGF0aCk7XG4gICAgICAgIC8vIE5vdGUsIGV2ZW4gaWYgYSBydWxsIHJlZnJlc2ggaXMgdHJpZ2dlcmVkLCBhbHdheXMgZG8gdGhlIHBhdGhcbiAgICAgICAgLy8gbm90aWZpY2F0aW9uIGJlY2F1c2UgdW5sZXNzIG11dGFibGVEYXRhIGlzIHVzZWQgZm9yIGRvbS1yZXBlYXRcbiAgICAgICAgLy8gYW5kIGFsbCBlbGVtZW50cyBpbiB0aGUgaW5zdGFuY2Ugc3VidHJlZSwgYSBmdWxsIHJlZnJlc2ggbWF5XG4gICAgICAgIC8vIG5vdCB0cmlnZ2VyIHRoZSBwcm9wZXIgdXBkYXRlLlxuICAgICAgICBsZXQgaW5zdElkeCA9IHRoaXMuX19pdGVtc0lkeFRvSW5zdElkeFtpdGVtc0lkeF07XG4gICAgICAgIGxldCBpbnN0ID0gdGhpcy5fX2luc3RhbmNlc1tpbnN0SWR4XTtcbiAgICAgICAgaWYgKGluc3QpIHtcbiAgICAgICAgICBsZXQgaXRlbVBhdGggPSB0aGlzLmFzICsgKGl0ZW1TdWJQYXRoID8gJy4nICsgaXRlbVN1YlBhdGggOiAnJyk7XG4gICAgICAgICAgLy8gVGhpcyBpcyBlZmZlY3RpdmVseSBgbm90aWZ5UGF0aGAsIGJ1dCBhdm9pZHMgc29tZSBvZiB0aGUgb3ZlcmhlYWRcbiAgICAgICAgICAvLyBvZiB0aGUgcHVibGljIEFQSVxuICAgICAgICAgIGluc3QuX3NldFBlbmRpbmdQcm9wZXJ0eU9yUGF0aChpdGVtUGF0aCwgdmFsdWUsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICBpbnN0Ll9mbHVzaFByb3BlcnRpZXMoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBpdGVtIGFzc29jaWF0ZWQgd2l0aCBhIGdpdmVuIGVsZW1lbnQgc3RhbXBlZCBieVxuICAgICAqIHRoaXMgYGRvbS1yZXBlYXRgLlxuICAgICAqXG4gICAgICogTm90ZSwgdG8gbW9kaWZ5IHN1Yi1wcm9wZXJ0aWVzIG9mIHRoZSBpdGVtLFxuICAgICAqIGBtb2RlbEZvckVsZW1lbnQoZWwpLnNldCgnaXRlbS48c3ViLXByb3A+JywgdmFsdWUpYFxuICAgICAqIHNob3VsZCBiZSB1c2VkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgRWxlbWVudCBmb3Igd2hpY2ggdG8gcmV0dXJuIHRoZSBpdGVtLlxuICAgICAqIEByZXR1cm4geyp9IEl0ZW0gYXNzb2NpYXRlZCB3aXRoIHRoZSBlbGVtZW50LlxuICAgICAqL1xuICAgIGl0ZW1Gb3JFbGVtZW50KGVsKSB7XG4gICAgICBsZXQgaW5zdGFuY2UgPSB0aGlzLm1vZGVsRm9yRWxlbWVudChlbCk7XG4gICAgICByZXR1cm4gaW5zdGFuY2UgJiYgaW5zdGFuY2VbdGhpcy5hc107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgaW5zdCBpbmRleCBmb3IgYSBnaXZlbiBlbGVtZW50IHN0YW1wZWQgYnkgdGhpcyBgZG9tLXJlcGVhdGAuXG4gICAgICogSWYgYHNvcnRgIGlzIHByb3ZpZGVkLCB0aGUgaW5kZXggd2lsbCByZWZsZWN0IHRoZSBzb3J0ZWQgb3JkZXIgKHJhdGhlclxuICAgICAqIHRoYW4gdGhlIG9yaWdpbmFsIGFycmF5IG9yZGVyKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIEVsZW1lbnQgZm9yIHdoaWNoIHRvIHJldHVybiB0aGUgaW5kZXguXG4gICAgICogQHJldHVybiB7Kn0gUm93IGluZGV4IGFzc29jaWF0ZWQgd2l0aCB0aGUgZWxlbWVudCAobm90ZSB0aGlzIG1heVxuICAgICAqICAgbm90IGNvcnJlc3BvbmQgdG8gdGhlIGFycmF5IGluZGV4IGlmIGEgdXNlciBgc29ydGAgaXMgYXBwbGllZCkuXG4gICAgICovXG4gICAgaW5kZXhGb3JFbGVtZW50KGVsKSB7XG4gICAgICBsZXQgaW5zdGFuY2UgPSB0aGlzLm1vZGVsRm9yRWxlbWVudChlbCk7XG4gICAgICByZXR1cm4gaW5zdGFuY2UgJiYgaW5zdGFuY2VbdGhpcy5pbmRleEFzXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB0ZW1wbGF0ZSBcIm1vZGVsXCIgYXNzb2NpYXRlZCB3aXRoIGEgZ2l2ZW4gZWxlbWVudCwgd2hpY2hcbiAgICAgKiBzZXJ2ZXMgYXMgdGhlIGJpbmRpbmcgc2NvcGUgZm9yIHRoZSB0ZW1wbGF0ZSBpbnN0YW5jZSB0aGUgZWxlbWVudCBpc1xuICAgICAqIGNvbnRhaW5lZCBpbi4gQSB0ZW1wbGF0ZSBtb2RlbCBpcyBhbiBpbnN0YW5jZSBvZiBgUG9seW1lci5CYXNlYCwgYW5kXG4gICAgICogc2hvdWxkIGJlIHVzZWQgdG8gbWFuaXB1bGF0ZSBkYXRhIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHRlbXBsYXRlIGluc3RhbmNlLlxuICAgICAqXG4gICAgICogRXhhbXBsZTpcbiAgICAgKlxuICAgICAqICAgbGV0IG1vZGVsID0gbW9kZWxGb3JFbGVtZW50KGVsKTtcbiAgICAgKiAgIGlmIChtb2RlbC5pbmRleCA8IDEwKSB7XG4gICAgICogICAgIG1vZGVsLnNldCgnaXRlbS5jaGVja2VkJywgdHJ1ZSk7XG4gICAgICogICB9XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCBFbGVtZW50IGZvciB3aGljaCB0byByZXR1cm4gYSB0ZW1wbGF0ZSBtb2RlbC5cbiAgICAgKiBAcmV0dXJuIHtUZW1wbGF0ZUluc3RhbmNlQmFzZX0gTW9kZWwgcmVwcmVzZW50aW5nIHRoZSBiaW5kaW5nIHNjb3BlIGZvclxuICAgICAqICAgdGhlIGVsZW1lbnQuXG4gICAgICovXG4gICAgbW9kZWxGb3JFbGVtZW50KGVsKSB7XG4gICAgICByZXR1cm4gUG9seW1lci5UZW1wbGF0aXplLm1vZGVsRm9yRWxlbWVudCh0aGlzLnRlbXBsYXRlLCBlbCk7XG4gICAgfVxuXG4gIH1cblxuICBjdXN0b21FbGVtZW50cy5kZWZpbmUoRG9tUmVwZWF0LmlzLCBEb21SZXBlYXQpO1xuXG4gIFBvbHltZXIuRG9tUmVwZWF0ID0gRG9tUmVwZWF0O1xuXG59KSgpO1xuXG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvZWxlbWVudHMvZG9tLXJlcGVhdC5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuXG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vLi4vcG9seW1lci1lbGVtZW50Lmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi91dGlscy90ZW1wbGF0aXplLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi91dGlscy9kZWJvdW5jZS5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vdXRpbHMvZmx1c2guaHRtbFwiPlxuXG48c2NyaXB0PlxuXG4oZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvKipcbiAgICogVGhlIGA8ZG9tLWlmPmAgZWxlbWVudCB3aWxsIHN0YW1wIGEgbGlnaHQtZG9tIGA8dGVtcGxhdGU+YCBjaGlsZCB3aGVuXG4gICAqIHRoZSBgaWZgIHByb3BlcnR5IGJlY29tZXMgdHJ1dGh5LCBhbmQgdGhlIHRlbXBsYXRlIGNhbiB1c2UgUG9seW1lclxuICAgKiBkYXRhLWJpbmRpbmcgYW5kIGRlY2xhcmF0aXZlIGV2ZW50IGZlYXR1cmVzIHdoZW4gdXNlZCBpbiB0aGUgY29udGV4dCBvZlxuICAgKiBhIFBvbHltZXIgZWxlbWVudCdzIHRlbXBsYXRlLlxuICAgKlxuICAgKiBXaGVuIGBpZmAgYmVjb21lcyBmYWxzZXksIHRoZSBzdGFtcGVkIGNvbnRlbnQgaXMgaGlkZGVuIGJ1dCBub3RcbiAgICogcmVtb3ZlZCBmcm9tIGRvbS4gV2hlbiBgaWZgIHN1YnNlcXVlbnRseSBiZWNvbWVzIHRydXRoeSBhZ2FpbiwgdGhlIGNvbnRlbnRcbiAgICogaXMgc2ltcGx5IHJlLXNob3duLiBUaGlzIGFwcHJvYWNoIGlzIHVzZWQgZHVlIHRvIGl0cyBmYXZvcmFibGUgcGVyZm9ybWFuY2VcbiAgICogY2hhcmFjdGVyaXN0aWNzOiB0aGUgZXhwZW5zZSBvZiBjcmVhdGluZyB0ZW1wbGF0ZSBjb250ZW50IGlzIHBhaWQgb25seVxuICAgKiBvbmNlIGFuZCBsYXppbHkuXG4gICAqXG4gICAqIFNldCB0aGUgYHJlc3RhbXBgIHByb3BlcnR5IHRvIHRydWUgdG8gZm9yY2UgdGhlIHN0YW1wZWQgY29udGVudCB0byBiZVxuICAgKiBjcmVhdGVkIC8gZGVzdHJveWVkIHdoZW4gdGhlIGBpZmAgY29uZGl0aW9uIGNoYW5nZXMuXG4gICAqXG4gICAqIEBjdXN0b21FbGVtZW50XG4gICAqIEBwb2x5bWVyXG4gICAqIEBleHRlbmRzIFBvbHltZXIuRWxlbWVudFxuICAgKiBAbWVtYmVyb2YgUG9seW1lclxuICAgKiBAc3VtbWFyeSBDdXN0b20gZWxlbWVudCB0aGF0IGNvbmRpdGlvbmFsbHkgc3RhbXBzIGFuZCBoaWRlcyBvciByZW1vdmVzXG4gICAqICAgdGVtcGxhdGUgY29udGVudCBiYXNlZCBvbiBhIGJvb2xlYW4gZmxhZy5cbiAgICovXG4gIGNsYXNzIERvbUlmIGV4dGVuZHMgUG9seW1lci5FbGVtZW50IHtcblxuICAgIC8vIE5vdCBuZWVkZWQgdG8gZmluZCB0ZW1wbGF0ZTsgY2FuIGJlIHJlbW92ZWQgb25jZSB0aGUgYW5hbHl6ZXJcbiAgICAvLyBjYW4gZmluZCB0aGUgdGFnIG5hbWUgZnJvbSBjdXN0b21FbGVtZW50cy5kZWZpbmUgY2FsbFxuICAgIHN0YXRpYyBnZXQgaXMoKSB7IHJldHVybiAnZG9tLWlmJzsgfVxuXG4gICAgc3RhdGljIGdldCB0ZW1wbGF0ZSgpIHsgcmV0dXJuIG51bGw7IH1cblxuICAgIHN0YXRpYyBnZXQgcHJvcGVydGllcygpIHtcblxuICAgICAgcmV0dXJuIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZWQgd2hlbmV2ZXIgRE9NIGlzIGFkZGVkIG9yIHJlbW92ZWQvaGlkZGVuIGJ5IHRoaXMgdGVtcGxhdGUgKGJ5XG4gICAgICAgICAqIGRlZmF1bHQsIHJlbmRlcmluZyBvY2N1cnMgbGF6aWx5KS4gIFRvIGZvcmNlIGltbWVkaWF0ZSByZW5kZXJpbmcsIGNhbGxcbiAgICAgICAgICogYHJlbmRlcmAuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBldmVudCBkb20tY2hhbmdlXG4gICAgICAgICAqL1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoaXMgdGVtcGxhdGUgc2hvdWxkIHN0YW1wLlxuICAgICAgICAgKi9cbiAgICAgICAgaWY6IHtcbiAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgIG9ic2VydmVyOiAnX19kZWJvdW5jZVJlbmRlcidcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogV2hlbiB0cnVlLCBlbGVtZW50cyB3aWxsIGJlIHJlbW92ZWQgZnJvbSBET00gYW5kIGRpc2NhcmRlZCB3aGVuIGBpZmBcbiAgICAgICAgICogYmVjb21lcyBmYWxzZSBhbmQgcmUtY3JlYXRlZCBhbmQgYWRkZWQgYmFjayB0byB0aGUgRE9NIHdoZW4gYGlmYFxuICAgICAgICAgKiBiZWNvbWVzIHRydWUuICBCeSBkZWZhdWx0LCBzdGFtcGVkIGVsZW1lbnRzIHdpbGwgYmUgaGlkZGVuIGJ1dCBsZWZ0XG4gICAgICAgICAqIGluIHRoZSBET00gd2hlbiBgaWZgIGJlY29tZXMgZmFsc2UsIHdoaWNoIGlzIGdlbmVyYWxseSByZXN1bHRzXG4gICAgICAgICAqIGluIGJldHRlciBwZXJmb3JtYW5jZS5cbiAgICAgICAgICovXG4gICAgICAgIHJlc3RhbXA6IHtcbiAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgIG9ic2VydmVyOiAnX19kZWJvdW5jZVJlbmRlcidcbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgIHN1cGVyKCk7XG4gICAgICB0aGlzLl9fcmVuZGVyRGVib3VuY2VyID0gbnVsbDtcbiAgICAgIHRoaXMuX19pbnZhbGlkUHJvcHMgPSBudWxsO1xuICAgICAgdGhpcy5fX2luc3RhbmNlID0gbnVsbDtcbiAgICAgIHRoaXMuX2xhc3RJZiA9IGZhbHNlO1xuICAgICAgdGhpcy5fX2N0b3IgPSBudWxsO1xuICAgIH1cblxuICAgIF9fZGVib3VuY2VSZW5kZXIoKSB7XG4gICAgICAvLyBSZW5kZXIgaXMgYXN5bmMgZm9yIDIgcmVhc29uczpcbiAgICAgIC8vIDEuIFRvIGVsaW1pbmF0ZSBkb20gY3JlYXRpb24gdHJhc2hpbmcgaWYgdXNlciBjb2RlIHRocmFzaGVzIGBpZmAgaW4gdGhlXG4gICAgICAvLyAgICBzYW1lIHR1cm4uIFRoaXMgd2FzIG1vcmUgY29tbW9uIGluIDEueCB3aGVyZSBhIGNvbXBvdW5kIGNvbXB1dGVkXG4gICAgICAvLyAgICBwcm9wZXJ0eSBjb3VsZCByZXN1bHQgaW4gdGhlIHJlc3VsdCBjaGFuZ2luZyBtdWx0aXBsZSB0aW1lcywgYnV0IGlzXG4gICAgICAvLyAgICBtaXRpZ2F0ZWQgdG8gYSBsYXJnZSBleHRlbnQgYnkgYmF0Y2hlZCBwcm9wZXJ0eSBwcm9jZXNzaW5nIGluIDIueC5cbiAgICAgIC8vIDIuIFRvIGF2b2lkIGRvdWJsZSBvYmplY3QgcHJvcGFnYXRpb24gd2hlbiBhIGJhZyBpbmNsdWRpbmcgdmFsdWVzIGJvdW5kXG4gICAgICAvLyAgICB0byB0aGUgYGlmYCBwcm9wZXJ0eSBhcyB3ZWxsIGFzIG9uZSBvciBtb3JlIGhvc3RQcm9wcyBjb3VsZCBlbnF1ZXVlXG4gICAgICAvLyAgICB0aGUgPGRvbS1pZj4gdG8gZmx1c2ggYmVmb3JlIHRoZSA8dGVtcGxhdGU+J3MgaG9zdCBwcm9wZXJ0eVxuICAgICAgLy8gICAgZm9yd2FyZGluZy4gSW4gdGhhdCBzY2VuYXJpbyBjcmVhdGluZyBhbiBpbnN0YW5jZSB3b3VsZCByZXN1bHQgaW5cbiAgICAgIC8vICAgIHRoZSBob3N0IHByb3BzIGJlaW5nIHNldCBvbmNlLCBhbmQgdGhlbiB0aGUgZW5xdWV1ZWQgY2hhbmdlcyBvbiB0aGVcbiAgICAgIC8vICAgIHRlbXBsYXRlIHdvdWxkIHNldCBwcm9wZXJ0aWVzIGEgc2Vjb25kIHRpbWUsIHBvdGVudGlhbGx5IGNhdXNpbmcgYW5cbiAgICAgIC8vICAgIG9iamVjdCB0byBiZSBzZXQgdG8gYW4gaW5zdGFuY2UgbW9yZSB0aGFuIG9uY2UuICBDcmVhdGluZyB0aGVcbiAgICAgIC8vICAgIGluc3RhbmNlIGFzeW5jIGZyb20gZmx1c2hpbmcgZGF0YSBlbnN1cmVzIHRoaXMgZG9lc24ndCBoYXBwZW4uIElmXG4gICAgICAvLyAgICB3ZSB3YW50ZWQgYSBzeW5jIG9wdGlvbiBpbiB0aGUgZnV0dXJlLCBzaW1wbHkgaGF2aW5nIDxkb20taWY+IGZsdXNoXG4gICAgICAvLyAgICAob3IgY2xlYXIpIGl0cyB0ZW1wbGF0ZSdzIHBlbmRpbmcgaG9zdCBwcm9wZXJ0aWVzIGJlZm9yZSBjcmVhdGluZ1xuICAgICAgLy8gICAgdGhlIGluc3RhbmNlIHdvdWxkIGFsc28gYXZvaWQgdGhlIHByb2JsZW0uXG4gICAgICB0aGlzLl9fcmVuZGVyRGVib3VuY2VyID0gUG9seW1lci5EZWJvdW5jZXIuZGVib3VuY2UoXG4gICAgICAgICAgICB0aGlzLl9fcmVuZGVyRGVib3VuY2VyXG4gICAgICAgICAgLCBQb2x5bWVyLkFzeW5jLm1pY3JvVGFza1xuICAgICAgICAgICwgKCkgPT4gdGhpcy5fX3JlbmRlcigpKTtcbiAgICAgIFBvbHltZXIuZW5xdWV1ZURlYm91bmNlcih0aGlzLl9fcmVuZGVyRGVib3VuY2VyKTtcbiAgICB9XG5cbiAgICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgIHN1cGVyLmRpc2Nvbm5lY3RlZENhbGxiYWNrKCk7XG4gICAgICBpZiAoIXRoaXMucGFyZW50Tm9kZSB8fFxuICAgICAgICAgICh0aGlzLnBhcmVudE5vZGUubm9kZVR5cGUgPT0gTm9kZS5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFICYmXG4gICAgICAgICAgICF0aGlzLnBhcmVudE5vZGUuaG9zdCkpIHtcbiAgICAgICAgdGhpcy5fX3RlYXJkb3duSW5zdGFuY2UoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgIHN1cGVyLmNvbm5lY3RlZENhbGxiYWNrKCk7XG4gICAgICBpZiAodGhpcy5pZikge1xuICAgICAgICB0aGlzLl9fZGVib3VuY2VSZW5kZXIoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGb3JjZXMgdGhlIGVsZW1lbnQgdG8gcmVuZGVyIGl0cyBjb250ZW50LiBOb3JtYWxseSByZW5kZXJpbmcgaXNcbiAgICAgKiBhc3luY2hyb25vdXMgdG8gYSBwcm92b2tpbmcgY2hhbmdlLiBUaGlzIGlzIGRvbmUgZm9yIGVmZmljaWVuY3kgc29cbiAgICAgKiB0aGF0IG11bHRpcGxlIGNoYW5nZXMgdHJpZ2dlciBvbmx5IGEgc2luZ2xlIHJlbmRlci4gVGhlIHJlbmRlciBtZXRob2RcbiAgICAgKiBzaG91bGQgYmUgY2FsbGVkIGlmLCBmb3IgZXhhbXBsZSwgdGVtcGxhdGUgcmVuZGVyaW5nIGlzIHJlcXVpcmVkIHRvXG4gICAgICogdmFsaWRhdGUgYXBwbGljYXRpb24gc3RhdGUuXG4gICAgICovXG4gICAgcmVuZGVyKCkge1xuICAgICAgUG9seW1lci5mbHVzaCgpO1xuICAgIH1cblxuICAgIF9fcmVuZGVyKCkge1xuICAgICAgaWYgKHRoaXMuaWYpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9fZW5zdXJlSW5zdGFuY2UoKSkge1xuICAgICAgICAgIC8vIE5vIHRlbXBsYXRlIGZvdW5kIHlldFxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zaG93SGlkZUNoaWxkcmVuKCk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMucmVzdGFtcCkge1xuICAgICAgICB0aGlzLl9fdGVhcmRvd25JbnN0YW5jZSgpO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLnJlc3RhbXAgJiYgdGhpcy5fX2luc3RhbmNlKSB7XG4gICAgICAgIHRoaXMuX3Nob3dIaWRlQ2hpbGRyZW4oKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmlmICE9IHRoaXMuX2xhc3RJZikge1xuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KCdkb20tY2hhbmdlJywge1xuICAgICAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICAgICAgY29tcG9zZWQ6IHRydWVcbiAgICAgICAgfSkpO1xuICAgICAgICB0aGlzLl9sYXN0SWYgPSB0aGlzLmlmO1xuICAgICAgfVxuICAgIH1cblxuICAgIF9fZW5zdXJlSW5zdGFuY2UoKSB7XG4gICAgICBsZXQgcGFyZW50Tm9kZSA9IHRoaXMucGFyZW50Tm9kZTtcbiAgICAgIC8vIEd1YXJkIGFnYWluc3QgZWxlbWVudCBiZWluZyBkZXRhY2hlZCB3aGlsZSByZW5kZXIgd2FzIHF1ZXVlZFxuICAgICAgaWYgKHBhcmVudE5vZGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9fY3Rvcikge1xuICAgICAgICAgIGxldCB0ZW1wbGF0ZSA9IHRoaXMucXVlcnlTZWxlY3RvcigndGVtcGxhdGUnKTtcbiAgICAgICAgICBpZiAoIXRlbXBsYXRlKSB7XG4gICAgICAgICAgICAvLyBXYWl0IHVudGlsIGNoaWxkTGlzdCBjaGFuZ2VzIGFuZCB0ZW1wbGF0ZSBzaG91bGQgYmUgdGhlcmUgYnkgdGhlblxuICAgICAgICAgICAgbGV0IG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoKCkgPT4ge1xuICAgICAgICAgICAgICBpZiAodGhpcy5xdWVyeVNlbGVjdG9yKCd0ZW1wbGF0ZScpKSB7XG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX19yZW5kZXIoKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RvbS1pZiByZXF1aXJlcyBhIDx0ZW1wbGF0ZT4gY2hpbGQnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIG9ic2VydmVyLm9ic2VydmUodGhpcywge2NoaWxkTGlzdDogdHJ1ZX0pO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9fY3RvciA9IFBvbHltZXIuVGVtcGxhdGl6ZS50ZW1wbGF0aXplKHRlbXBsYXRlLCB0aGlzLCB7XG4gICAgICAgICAgICAvLyBkb20taWYgdGVtcGxhdGl6ZXIgaW5zdGFuY2VzIHJlcXVpcmUgYG11dGFibGU6IHRydWVgLCBhc1xuICAgICAgICAgICAgLy8gYF9fc3luY0hvc3RQcm9wZXJ0aWVzYCByZWxpZXMgb24gdGhhdCBiZWhhdmlvciB0byBzeW5jIG9iamVjdHNcbiAgICAgICAgICAgIG11dGFibGVEYXRhOiB0cnVlLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcCBQcm9wZXJ0eSB0byBmb3J3YXJkXG4gICAgICAgICAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIG9mIHByb3BlcnR5XG4gICAgICAgICAgICAgKiBAdGhpcyB7dGhpc31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZm9yd2FyZEhvc3RQcm9wOiBmdW5jdGlvbihwcm9wLCB2YWx1ZSkge1xuICAgICAgICAgICAgICBpZiAodGhpcy5fX2luc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaWYpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX19pbnN0YW5jZS5mb3J3YXJkSG9zdFByb3AocHJvcCwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIGFuIGluc3RhbmNlIGJ1dCBhcmUgc3F1ZWxjaGluZyBob3N0IHByb3BlcnR5XG4gICAgICAgICAgICAgICAgICAvLyBmb3J3YXJkaW5nIGR1ZSB0byBpZiBiZWluZyBmYWxzZSwgbm90ZSB0aGUgaW52YWxpZGF0ZWRcbiAgICAgICAgICAgICAgICAgIC8vIHByb3BlcnRpZXMgc28gYF9fc3luY0hvc3RQcm9wZXJ0aWVzYCBjYW4gc3luYyB0aGVtIHRoZSBuZXh0XG4gICAgICAgICAgICAgICAgICAvLyB0aW1lIGBpZmAgYmVjb21lcyB0cnVlXG4gICAgICAgICAgICAgICAgICB0aGlzLl9faW52YWxpZFByb3BzID0gdGhpcy5fX2ludmFsaWRQcm9wcyB8fCBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgICAgICAgICAgdGhpcy5fX2ludmFsaWRQcm9wc1tQb2x5bWVyLlBhdGgucm9vdChwcm9wKV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5fX2luc3RhbmNlKSB7XG4gICAgICAgICAgdGhpcy5fX2luc3RhbmNlID0gbmV3IHRoaXMuX19jdG9yKCk7XG4gICAgICAgICAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpcy5fX2luc3RhbmNlLnJvb3QsIHRoaXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX19zeW5jSG9zdFByb3BlcnRpZXMoKTtcbiAgICAgICAgICBsZXQgYyQgPSB0aGlzLl9faW5zdGFuY2UuY2hpbGRyZW47XG4gICAgICAgICAgaWYgKGMkICYmIGMkLmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gRGV0ZWN0IGNhc2Ugd2hlcmUgZG9tLWlmIHdhcyByZS1hdHRhY2hlZCBpbiBuZXcgcG9zaXRpb25cbiAgICAgICAgICAgIGxldCBsYXN0Q2hpbGQgPSB0aGlzLnByZXZpb3VzU2libGluZztcbiAgICAgICAgICAgIGlmIChsYXN0Q2hpbGQgIT09IGMkW2MkLmxlbmd0aC0xXSkge1xuICAgICAgICAgICAgICBmb3IgKGxldCBpPTAsIG47IChpPGMkLmxlbmd0aCkgJiYgKG49YyRbaV0pOyBpKyspIHtcbiAgICAgICAgICAgICAgICBwYXJlbnROb2RlLmluc2VydEJlZm9yZShuLCB0aGlzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgX19zeW5jSG9zdFByb3BlcnRpZXMoKSB7XG4gICAgICBsZXQgcHJvcHMgPSB0aGlzLl9faW52YWxpZFByb3BzO1xuICAgICAgaWYgKHByb3BzKSB7XG4gICAgICAgIGZvciAobGV0IHByb3AgaW4gcHJvcHMpIHtcbiAgICAgICAgICB0aGlzLl9faW5zdGFuY2UuX3NldFBlbmRpbmdQcm9wZXJ0eShwcm9wLCB0aGlzLl9fZGF0YUhvc3RbcHJvcF0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX19pbnZhbGlkUHJvcHMgPSBudWxsO1xuICAgICAgICB0aGlzLl9faW5zdGFuY2UuX2ZsdXNoUHJvcGVydGllcygpO1xuICAgICAgfVxuICAgIH1cblxuICAgIF9fdGVhcmRvd25JbnN0YW5jZSgpIHtcbiAgICAgIGlmICh0aGlzLl9faW5zdGFuY2UpIHtcbiAgICAgICAgbGV0IGMkID0gdGhpcy5fX2luc3RhbmNlLmNoaWxkcmVuO1xuICAgICAgICBpZiAoYyQgJiYgYyQubGVuZ3RoKSB7XG4gICAgICAgICAgLy8gdXNlIGZpcnN0IGNoaWxkIHBhcmVudCwgZm9yIGNhc2Ugd2hlbiBkb20taWYgbWF5IGhhdmUgYmVlbiBkZXRhY2hlZFxuICAgICAgICAgIGxldCBwYXJlbnQgPSBjJFswXS5wYXJlbnROb2RlO1xuICAgICAgICAgIGZvciAobGV0IGk9MCwgbjsgKGk8YyQubGVuZ3RoKSAmJiAobj1jJFtpXSk7IGkrKykge1xuICAgICAgICAgICAgcGFyZW50LnJlbW92ZUNoaWxkKG4pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9faW5zdGFuY2UgPSBudWxsO1xuICAgICAgICB0aGlzLl9faW52YWxpZFByb3BzID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfc2hvd0hpZGVDaGlsZHJlbigpIHtcbiAgICAgIGxldCBoaWRkZW4gPSB0aGlzLl9faGlkZVRlbXBsYXRlQ2hpbGRyZW5fXyB8fCAhdGhpcy5pZjtcbiAgICAgIGlmICh0aGlzLl9faW5zdGFuY2UpIHtcbiAgICAgICAgdGhpcy5fX2luc3RhbmNlLl9zaG93SGlkZUNoaWxkcmVuKGhpZGRlbik7XG4gICAgICB9XG4gICAgfVxuXG4gIH1cblxuICBjdXN0b21FbGVtZW50cy5kZWZpbmUoRG9tSWYuaXMsIERvbUlmKTtcblxuICBQb2x5bWVyLkRvbUlmID0gRG9tSWY7XG5cbn0pKCk7XG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvZWxlbWVudHMvZG9tLWlmLmh0bWwiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi8uLi9wb2x5bWVyLWVsZW1lbnQuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3V0aWxzL21peGluLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi91dGlscy9hcnJheS1zcGxpY2UuaHRtbFwiPlxuXG48c2NyaXB0PlxuKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLyoqXG4gICAqIEVsZW1lbnQgbWl4aW4gZm9yIHJlY29yZGluZyBkeW5hbWljIGFzc29jaWF0aW9ucyBiZXR3ZWVuIGl0ZW0gcGF0aHMgaW4gYVxuICAgKiBtYXN0ZXIgYGl0ZW1zYCBhcnJheSBhbmQgYSBgc2VsZWN0ZWRgIGFycmF5IHN1Y2ggdGhhdCBwYXRoIGNoYW5nZXMgdG8gdGhlXG4gICAqIG1hc3RlciBhcnJheSAoYXQgdGhlIGhvc3QpIGVsZW1lbnQgb3IgZWxzZXdoZXJlIHZpYSBkYXRhLWJpbmRpbmcpIGFyZVxuICAgKiBjb3JyZWN0bHkgcHJvcGFnYXRlZCB0byBpdGVtcyBpbiB0aGUgc2VsZWN0ZWQgYXJyYXkgYW5kIHZpY2UtdmVyc2EuXG4gICAqXG4gICAqIFRoZSBgaXRlbXNgIHByb3BlcnR5IGFjY2VwdHMgYW4gYXJyYXkgb2YgdXNlciBkYXRhLCBhbmQgdmlhIHRoZVxuICAgKiBgc2VsZWN0KGl0ZW0pYCBhbmQgYGRlc2VsZWN0KGl0ZW0pYCBBUEksIHVwZGF0ZXMgdGhlIGBzZWxlY3RlZGAgcHJvcGVydHlcbiAgICogd2hpY2ggbWF5IGJlIGJvdW5kIHRvIG90aGVyIHBhcnRzIG9mIHRoZSBhcHBsaWNhdGlvbiwgYW5kIGFueSBjaGFuZ2VzIHRvXG4gICAqIHN1Yi1maWVsZHMgb2YgYHNlbGVjdGVkYCBpdGVtKHMpIHdpbGwgYmUga2VwdCBpbiBzeW5jIHdpdGggaXRlbXMgaW4gdGhlXG4gICAqIGBpdGVtc2AgYXJyYXkuICBXaGVuIGBtdWx0aWAgaXMgZmFsc2UsIGBzZWxlY3RlZGAgaXMgYSBwcm9wZXJ0eVxuICAgKiByZXByZXNlbnRpbmcgdGhlIGxhc3Qgc2VsZWN0ZWQgaXRlbS4gIFdoZW4gYG11bHRpYCBpcyB0cnVlLCBgc2VsZWN0ZWRgXG4gICAqIGlzIGFuIGFycmF5IG9mIG11bHRpcGx5IHNlbGVjdGVkIGl0ZW1zLlxuICAgKlxuICAgKiBAcG9seW1lclxuICAgKiBAbWl4aW5GdW5jdGlvblxuICAgKiBAYXBwbGllc01peGluIFBvbHltZXIuRWxlbWVudE1peGluXG4gICAqIEBtZW1iZXJvZiBQb2x5bWVyXG4gICAqIEBzdW1tYXJ5IEVsZW1lbnQgbWl4aW4gZm9yIHJlY29yZGluZyBkeW5hbWljIGFzc29jaWF0aW9ucyBiZXR3ZWVuIGl0ZW0gcGF0aHMgaW4gYVxuICAgKiBtYXN0ZXIgYGl0ZW1zYCBhcnJheSBhbmQgYSBgc2VsZWN0ZWRgIGFycmF5XG4gICAqL1xuICBsZXQgQXJyYXlTZWxlY3Rvck1peGluID0gUG9seW1lci5kZWR1cGluZ01peGluKHN1cGVyQ2xhc3MgPT4ge1xuXG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQGV4dGVuZHMge3N1cGVyQ2xhc3N9XG4gICAgICogQGltcGxlbWVudHMge1BvbHltZXJfRWxlbWVudE1peGlufVxuICAgICAqL1xuICAgIGxldCBlbGVtZW50QmFzZSA9IFBvbHltZXIuRWxlbWVudE1peGluKHN1cGVyQ2xhc3MpO1xuXG4gICAgLyoqXG4gICAgICogQHBvbHltZXJcbiAgICAgKiBAbWl4aW5DbGFzc1xuICAgICAqIEBpbXBsZW1lbnRzIHtQb2x5bWVyX0FycmF5U2VsZWN0b3JNaXhpbn1cbiAgICAgKiBAdW5yZXN0cmljdGVkXG4gICAgICovXG4gICAgY2xhc3MgQXJyYXlTZWxlY3Rvck1peGluIGV4dGVuZHMgZWxlbWVudEJhc2Uge1xuXG4gICAgICBzdGF0aWMgZ2V0IHByb3BlcnRpZXMoKSB7XG5cbiAgICAgICAgcmV0dXJuIHtcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIEFuIGFycmF5IGNvbnRhaW5pbmcgaXRlbXMgZnJvbSB3aGljaCBzZWxlY3Rpb24gd2lsbCBiZSBtYWRlLlxuICAgICAgICAgICAqL1xuICAgICAgICAgIGl0ZW1zOiB7XG4gICAgICAgICAgICB0eXBlOiBBcnJheSxcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogV2hlbiBgdHJ1ZWAsIG11bHRpcGxlIGl0ZW1zIG1heSBiZSBzZWxlY3RlZCBhdCBvbmNlIChpbiB0aGlzIGNhc2UsXG4gICAgICAgICAgICogYHNlbGVjdGVkYCBpcyBhbiBhcnJheSBvZiBjdXJyZW50bHkgc2VsZWN0ZWQgaXRlbXMpLiAgV2hlbiBgZmFsc2VgLFxuICAgICAgICAgICAqIG9ubHkgb25lIGl0ZW0gbWF5IGJlIHNlbGVjdGVkIGF0IGEgdGltZS5cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBtdWx0aToge1xuICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgICAgIHZhbHVlOiBmYWxzZSxcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogV2hlbiBgbXVsdGlgIGlzIHRydWUsIHRoaXMgaXMgYW4gYXJyYXkgdGhhdCBjb250YWlucyBhbnkgc2VsZWN0ZWQuXG4gICAgICAgICAgICogV2hlbiBgbXVsdGlgIGlzIGZhbHNlLCB0aGlzIGlzIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgaXRlbSwgb3IgYG51bGxgXG4gICAgICAgICAgICogaWYgbm8gaXRlbSBpcyBzZWxlY3RlZC5cbiAgICAgICAgICAgKiBAdHlwZSB7PyhPYmplY3R8QXJyYXk8IU9iamVjdD4pfVxuICAgICAgICAgICAqL1xuICAgICAgICAgIHNlbGVjdGVkOiB7XG4gICAgICAgICAgICB0eXBlOiBPYmplY3QsXG4gICAgICAgICAgICBub3RpZnk6IHRydWVcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogV2hlbiBgbXVsdGlgIGlzIGZhbHNlLCB0aGlzIGlzIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgaXRlbSwgb3IgYG51bGxgXG4gICAgICAgICAgICogaWYgbm8gaXRlbSBpcyBzZWxlY3RlZC5cbiAgICAgICAgICAgKiBAdHlwZSB7P09iamVjdH1cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBzZWxlY3RlZEl0ZW06IHtcbiAgICAgICAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgICAgICAgIG5vdGlmeTogdHJ1ZVxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBXaGVuIGB0cnVlYCwgY2FsbGluZyBgc2VsZWN0YCBvbiBhbiBpdGVtIHRoYXQgaXMgYWxyZWFkeSBzZWxlY3RlZFxuICAgICAgICAgICAqIHdpbGwgZGVzZWxlY3QgdGhlIGl0ZW0uXG4gICAgICAgICAgICovXG4gICAgICAgICAgdG9nZ2xlOiB7XG4gICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc3RhdGljIGdldCBvYnNlcnZlcnMoKSB7XG4gICAgICAgIHJldHVybiBbJ19fdXBkYXRlU2VsZWN0aW9uKG11bHRpLCBpdGVtcy4qKSddXG4gICAgICB9XG5cbiAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl9fbGFzdEl0ZW1zID0gbnVsbDtcbiAgICAgICAgdGhpcy5fX2xhc3RNdWx0aSA9IG51bGw7XG4gICAgICAgIHRoaXMuX19zZWxlY3RlZE1hcCA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIF9fdXBkYXRlU2VsZWN0aW9uKG11bHRpLCBpdGVtc0luZm8pIHtcbiAgICAgICAgbGV0IHBhdGggPSBpdGVtc0luZm8ucGF0aDtcbiAgICAgICAgaWYgKHBhdGggPT0gJ2l0ZW1zJykge1xuICAgICAgICAgIC8vIENhc2UgMSAtIGl0ZW1zIGFycmF5IGNoYW5nZWQsIHNvIGRpZmYgYWdhaW5zdCBwcmV2aW91cyBhcnJheSBhbmRcbiAgICAgICAgICAvLyBkZXNlbGVjdCBhbnkgcmVtb3ZlZCBpdGVtcyBhbmQgYWRqdXN0IHNlbGVjdGVkIGluZGljZXNcbiAgICAgICAgICBsZXQgbmV3SXRlbXMgPSBpdGVtc0luZm8uYmFzZSB8fCBbXTtcbiAgICAgICAgICBsZXQgbGFzdEl0ZW1zID0gdGhpcy5fX2xhc3RJdGVtcztcbiAgICAgICAgICBsZXQgbGFzdE11bHRpID0gdGhpcy5fX2xhc3RNdWx0aTtcbiAgICAgICAgICBpZiAobXVsdGkgIT09IGxhc3RNdWx0aSkge1xuICAgICAgICAgICAgdGhpcy5jbGVhclNlbGVjdGlvbigpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobGFzdEl0ZW1zKSB7XG4gICAgICAgICAgICBsZXQgc3BsaWNlcyA9IFBvbHltZXIuQXJyYXlTcGxpY2UuY2FsY3VsYXRlU3BsaWNlcyhuZXdJdGVtcywgbGFzdEl0ZW1zKTtcbiAgICAgICAgICAgIHRoaXMuX19hcHBseVNwbGljZXMoc3BsaWNlcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX19sYXN0SXRlbXMgPSBuZXdJdGVtcztcbiAgICAgICAgICB0aGlzLl9fbGFzdE11bHRpID0gbXVsdGk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXRlbXNJbmZvLnBhdGggPT0gJ2l0ZW1zLnNwbGljZXMnKSB7XG4gICAgICAgICAgLy8gQ2FzZSAyIC0gZ290IHNwZWNpZmljIHNwbGljZSBpbmZvcm1hdGlvbiBkZXNjcmliaW5nIHRoZSBhcnJheSBtdXRhdGlvbjpcbiAgICAgICAgICAvLyBkZXNlbGVjdCBhbnkgcmVtb3ZlZCBpdGVtcyBhbmQgYWRqdXN0IHNlbGVjdGVkIGluZGljZXNcbiAgICAgICAgICB0aGlzLl9fYXBwbHlTcGxpY2VzKGl0ZW1zSW5mby52YWx1ZS5pbmRleFNwbGljZXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIENhc2UgMyAtIGFuIGFycmF5IGVsZW1lbnQgd2FzIGNoYW5nZWQsIHNvIGRlc2VsZWN0IHRoZSBwcmV2aW91c1xuICAgICAgICAgIC8vIGl0ZW0gZm9yIHRoYXQgaW5kZXggaWYgaXQgd2FzIHByZXZpb3VzbHkgc2VsZWN0ZWRcbiAgICAgICAgICBsZXQgcGFydCA9IHBhdGguc2xpY2UoJ2l0ZW1zLicubGVuZ3RoKTtcbiAgICAgICAgICBsZXQgaWR4ID0gcGFyc2VJbnQocGFydCwgMTApO1xuICAgICAgICAgIGlmICgocGFydC5pbmRleE9mKCcuJykgPCAwKSAmJiBwYXJ0ID09IGlkeCkge1xuICAgICAgICAgICAgdGhpcy5fX2Rlc2VsZWN0Q2hhbmdlZElkeChpZHgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBfX2FwcGx5U3BsaWNlcyhzcGxpY2VzKSB7XG4gICAgICAgIGxldCBzZWxlY3RlZCA9IHRoaXMuX19zZWxlY3RlZE1hcDtcbiAgICAgICAgLy8gQWRqdXN0IHNlbGVjdGVkIGluZGljZXMgYW5kIG1hcmsgcmVtb3ZhbHNcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPHNwbGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBsZXQgcyA9IHNwbGljZXNbaV07XG4gICAgICAgICAgc2VsZWN0ZWQuZm9yRWFjaCgoaWR4LCBpdGVtKSA9PiB7XG4gICAgICAgICAgICBpZiAoaWR4IDwgcy5pbmRleCkge1xuICAgICAgICAgICAgICAvLyBubyBjaGFuZ2VcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaWR4ID49IHMuaW5kZXggKyBzLnJlbW92ZWQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIC8vIGFkanVzdCBpbmRleFxuICAgICAgICAgICAgICBzZWxlY3RlZC5zZXQoaXRlbSwgaWR4ICsgcy5hZGRlZENvdW50IC0gcy5yZW1vdmVkLmxlbmd0aCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyByZW1vdmUgaW5kZXhcbiAgICAgICAgICAgICAgc2VsZWN0ZWQuc2V0KGl0ZW0sIC0xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBmb3IgKGxldCBqPTA7IGo8cy5hZGRlZENvdW50OyBqKyspIHtcbiAgICAgICAgICAgIGxldCBpZHggPSBzLmluZGV4ICsgajtcbiAgICAgICAgICAgIGlmIChzZWxlY3RlZC5oYXModGhpcy5pdGVtc1tpZHhdKSkge1xuICAgICAgICAgICAgICBzZWxlY3RlZC5zZXQodGhpcy5pdGVtc1tpZHhdLCBpZHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBVcGRhdGUgbGlua2VkIHBhdGhzXG4gICAgICAgIHRoaXMuX191cGRhdGVMaW5rcygpO1xuICAgICAgICAvLyBSZW1vdmUgc2VsZWN0ZWQgaXRlbXMgdGhhdCB3ZXJlIHJlbW92ZWQgZnJvbSB0aGUgaXRlbXMgYXJyYXlcbiAgICAgICAgbGV0IHNpZHggPSAwO1xuICAgICAgICBzZWxlY3RlZC5mb3JFYWNoKChpZHgsIGl0ZW0pID0+IHtcbiAgICAgICAgICBpZiAoaWR4IDwgMCkge1xuICAgICAgICAgICAgaWYgKHRoaXMubXVsdGkpIHtcbiAgICAgICAgICAgICAgdGhpcy5zcGxpY2UoJ3NlbGVjdGVkJywgc2lkeCwgMSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkID0gdGhpcy5zZWxlY3RlZEl0ZW0gPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZWN0ZWQuZGVsZXRlKGl0ZW0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzaWR4Kys7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgX191cGRhdGVMaW5rcygpIHtcbiAgICAgICAgdGhpcy5fX2RhdGFMaW5rZWRQYXRocyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5tdWx0aSkge1xuICAgICAgICAgIGxldCBzaWR4ID0gMDtcbiAgICAgICAgICB0aGlzLl9fc2VsZWN0ZWRNYXAuZm9yRWFjaChpZHggPT4ge1xuICAgICAgICAgICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICAgICAgICAgIHRoaXMubGlua1BhdGhzKCdpdGVtcy4nICsgaWR4LCAnc2VsZWN0ZWQuJyArIHNpZHgrKyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fX3NlbGVjdGVkTWFwLmZvckVhY2goaWR4ID0+IHtcbiAgICAgICAgICAgIHRoaXMubGlua1BhdGhzKCdzZWxlY3RlZCcsICdpdGVtcy4nICsgaWR4KTtcbiAgICAgICAgICAgIHRoaXMubGlua1BhdGhzKCdzZWxlY3RlZEl0ZW0nLCAnaXRlbXMuJyArIGlkeCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDbGVhcnMgdGhlIHNlbGVjdGlvbiBzdGF0ZS5cbiAgICAgICAqXG4gICAgICAgKi9cbiAgICAgIGNsZWFyU2VsZWN0aW9uKCkge1xuICAgICAgICAvLyBVbmJpbmQgcHJldmlvdXMgc2VsZWN0aW9uXG4gICAgICAgIHRoaXMuX19kYXRhTGlua2VkUGF0aHMgPSB7fTtcbiAgICAgICAgLy8gVGhlIHNlbGVjdGVkIG1hcCBzdG9yZXMgMyBwaWVjZXMgb2YgaW5mb3JtYXRpb246XG4gICAgICAgIC8vIGtleTogaXRlbXMgYXJyYXkgb2JqZWN0XG4gICAgICAgIC8vIHZhbHVlOiBpdGVtcyBhcnJheSBpbmRleFxuICAgICAgICAvLyBvcmRlcjogc2VsZWN0ZWQgYXJyYXkgaW5kZXhcbiAgICAgICAgdGhpcy5fX3NlbGVjdGVkTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICAvLyBJbml0aWFsaXplIHNlbGVjdGlvblxuICAgICAgICB0aGlzLnNlbGVjdGVkID0gdGhpcy5tdWx0aSA/IFtdIDogbnVsbFxuICAgICAgICB0aGlzLnNlbGVjdGVkSXRlbSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBpdGVtIGlzIGN1cnJlbnRseSBzZWxlY3RlZC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0geyp9IGl0ZW0gSXRlbSBmcm9tIGBpdGVtc2AgYXJyYXkgdG8gdGVzdFxuICAgICAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgaXRlbSBpcyBzZWxlY3RlZFxuICAgICAgICovXG4gICAgICBpc1NlbGVjdGVkKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19zZWxlY3RlZE1hcC5oYXMoaXRlbSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBpdGVtIGlzIGN1cnJlbnRseSBzZWxlY3RlZC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0gaWR4IEluZGV4IGZyb20gYGl0ZW1zYCBhcnJheSB0byB0ZXN0XG4gICAgICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBpdGVtIGlzIHNlbGVjdGVkXG4gICAgICAgKi9cbiAgICAgIGlzSW5kZXhTZWxlY3RlZChpZHgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNTZWxlY3RlZCh0aGlzLml0ZW1zW2lkeF0pO1xuICAgICAgfVxuXG4gICAgICBfX2Rlc2VsZWN0Q2hhbmdlZElkeChpZHgpIHtcbiAgICAgICAgbGV0IHNpZHggPSB0aGlzLl9fc2VsZWN0ZWRJbmRleEZvckl0ZW1JbmRleChpZHgpO1xuICAgICAgICBpZiAoc2lkeCA+PSAwKSB7XG4gICAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAgIHRoaXMuX19zZWxlY3RlZE1hcC5mb3JFYWNoKChpZHgsIGl0ZW0pID0+IHtcbiAgICAgICAgICAgIGlmIChzaWR4ID09IGkrKykge1xuICAgICAgICAgICAgICB0aGlzLmRlc2VsZWN0KGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIF9fc2VsZWN0ZWRJbmRleEZvckl0ZW1JbmRleChpZHgpIHtcbiAgICAgICAgbGV0IHNlbGVjdGVkID0gdGhpcy5fX2RhdGFMaW5rZWRQYXRoc1snaXRlbXMuJyArIGlkeF07XG4gICAgICAgIGlmIChzZWxlY3RlZCkge1xuICAgICAgICAgIHJldHVybiBwYXJzZUludChzZWxlY3RlZC5zbGljZSgnc2VsZWN0ZWQuJy5sZW5ndGgpLCAxMCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBEZXNlbGVjdHMgdGhlIGdpdmVuIGl0ZW0gaWYgaXQgaXMgYWxyZWFkeSBzZWxlY3RlZC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0geyp9IGl0ZW0gSXRlbSBmcm9tIGBpdGVtc2AgYXJyYXkgdG8gZGVzZWxlY3RcbiAgICAgICAqL1xuICAgICAgZGVzZWxlY3QoaXRlbSkge1xuICAgICAgICBsZXQgaWR4ID0gdGhpcy5fX3NlbGVjdGVkTWFwLmdldChpdGVtKTtcbiAgICAgICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICAgICAgdGhpcy5fX3NlbGVjdGVkTWFwLmRlbGV0ZShpdGVtKTtcbiAgICAgICAgICBsZXQgc2lkeDtcbiAgICAgICAgICBpZiAodGhpcy5tdWx0aSkge1xuICAgICAgICAgICAgc2lkeCA9IHRoaXMuX19zZWxlY3RlZEluZGV4Rm9ySXRlbUluZGV4KGlkeCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX191cGRhdGVMaW5rcygpO1xuICAgICAgICAgIGlmICh0aGlzLm11bHRpKSB7XG4gICAgICAgICAgICB0aGlzLnNwbGljZSgnc2VsZWN0ZWQnLCBzaWR4LCAxKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZCA9IHRoaXMuc2VsZWN0ZWRJdGVtID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBEZXNlbGVjdHMgdGhlIGdpdmVuIGluZGV4IGlmIGl0IGlzIGFscmVhZHkgc2VsZWN0ZWQuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGlkeCBJbmRleCBmcm9tIGBpdGVtc2AgYXJyYXkgdG8gZGVzZWxlY3RcbiAgICAgICAqL1xuICAgICAgZGVzZWxlY3RJbmRleChpZHgpIHtcbiAgICAgICAgdGhpcy5kZXNlbGVjdCh0aGlzLml0ZW1zW2lkeF0pO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFNlbGVjdHMgdGhlIGdpdmVuIGl0ZW0uICBXaGVuIGB0b2dnbGVgIGlzIHRydWUsIHRoaXMgd2lsbCBhdXRvbWF0aWNhbGx5XG4gICAgICAgKiBkZXNlbGVjdCB0aGUgaXRlbSBpZiBhbHJlYWR5IHNlbGVjdGVkLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7Kn0gaXRlbSBJdGVtIGZyb20gYGl0ZW1zYCBhcnJheSB0byBzZWxlY3RcbiAgICAgICAqL1xuICAgICAgc2VsZWN0KGl0ZW0pIHtcbiAgICAgICAgdGhpcy5zZWxlY3RJbmRleCh0aGlzLml0ZW1zLmluZGV4T2YoaXRlbSkpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFNlbGVjdHMgdGhlIGdpdmVuIGluZGV4LiAgV2hlbiBgdG9nZ2xlYCBpcyB0cnVlLCB0aGlzIHdpbGwgYXV0b21hdGljYWxseVxuICAgICAgICogZGVzZWxlY3QgdGhlIGl0ZW0gaWYgYWxyZWFkeSBzZWxlY3RlZC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0gaWR4IEluZGV4IGZyb20gYGl0ZW1zYCBhcnJheSB0byBzZWxlY3RcbiAgICAgICAqL1xuICAgICAgc2VsZWN0SW5kZXgoaWR4KSB7XG4gICAgICAgIGxldCBpdGVtID0gdGhpcy5pdGVtc1tpZHhdO1xuICAgICAgICBpZiAoIXRoaXMuaXNTZWxlY3RlZChpdGVtKSkge1xuICAgICAgICAgIGlmICghdGhpcy5tdWx0aSkge1xuICAgICAgICAgICAgdGhpcy5fX3NlbGVjdGVkTWFwLmNsZWFyKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX19zZWxlY3RlZE1hcC5zZXQoaXRlbSwgaWR4KTtcbiAgICAgICAgICB0aGlzLl9fdXBkYXRlTGlua3MoKTtcbiAgICAgICAgICBpZiAodGhpcy5tdWx0aSkge1xuICAgICAgICAgICAgdGhpcy5wdXNoKCdzZWxlY3RlZCcsIGl0ZW0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkID0gdGhpcy5zZWxlY3RlZEl0ZW0gPSBpdGVtO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnRvZ2dsZSkge1xuICAgICAgICAgIHRoaXMuZGVzZWxlY3RJbmRleChpZHgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICB9XG5cbiAgICByZXR1cm4gQXJyYXlTZWxlY3Rvck1peGluO1xuXG4gIH0pO1xuXG4gIC8vIGV4cG9ydCBtaXhpblxuICBQb2x5bWVyLkFycmF5U2VsZWN0b3JNaXhpbiA9IEFycmF5U2VsZWN0b3JNaXhpbjtcblxuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBleHRlbmRzIHtQb2x5bWVyLkVsZW1lbnR9XG4gICAqIEBpbXBsZW1lbnRzIHtQb2x5bWVyX0FycmF5U2VsZWN0b3JNaXhpbn1cbiAgICovXG4gIGxldCBiYXNlQXJyYXlTZWxlY3RvciA9IEFycmF5U2VsZWN0b3JNaXhpbihQb2x5bWVyLkVsZW1lbnQpO1xuXG4gIC8qKlxuICAgKiBFbGVtZW50IGltcGxlbWVudGluZyB0aGUgYFBvbHltZXIuQXJyYXlTZWxlY3RvcmAgbWl4aW4sIHdoaWNoIHJlY29yZHNcbiAgICogZHluYW1pYyBhc3NvY2lhdGlvbnMgYmV0d2VlbiBpdGVtIHBhdGhzIGluIGEgbWFzdGVyIGBpdGVtc2AgYXJyYXkgYW5kIGFcbiAgICogYHNlbGVjdGVkYCBhcnJheSBzdWNoIHRoYXQgcGF0aCBjaGFuZ2VzIHRvIHRoZSBtYXN0ZXIgYXJyYXkgKGF0IHRoZSBob3N0KVxuICAgKiBlbGVtZW50IG9yIGVsc2V3aGVyZSB2aWEgZGF0YS1iaW5kaW5nKSBhcmUgY29ycmVjdGx5IHByb3BhZ2F0ZWQgdG8gaXRlbXNcbiAgICogaW4gdGhlIHNlbGVjdGVkIGFycmF5IGFuZCB2aWNlLXZlcnNhLlxuICAgKlxuICAgKiBUaGUgYGl0ZW1zYCBwcm9wZXJ0eSBhY2NlcHRzIGFuIGFycmF5IG9mIHVzZXIgZGF0YSwgYW5kIHZpYSB0aGVcbiAgICogYHNlbGVjdChpdGVtKWAgYW5kIGBkZXNlbGVjdChpdGVtKWAgQVBJLCB1cGRhdGVzIHRoZSBgc2VsZWN0ZWRgIHByb3BlcnR5XG4gICAqIHdoaWNoIG1heSBiZSBib3VuZCB0byBvdGhlciBwYXJ0cyBvZiB0aGUgYXBwbGljYXRpb24sIGFuZCBhbnkgY2hhbmdlcyB0b1xuICAgKiBzdWItZmllbGRzIG9mIGBzZWxlY3RlZGAgaXRlbShzKSB3aWxsIGJlIGtlcHQgaW4gc3luYyB3aXRoIGl0ZW1zIGluIHRoZVxuICAgKiBgaXRlbXNgIGFycmF5LiAgV2hlbiBgbXVsdGlgIGlzIGZhbHNlLCBgc2VsZWN0ZWRgIGlzIGEgcHJvcGVydHlcbiAgICogcmVwcmVzZW50aW5nIHRoZSBsYXN0IHNlbGVjdGVkIGl0ZW0uICBXaGVuIGBtdWx0aWAgaXMgdHJ1ZSwgYHNlbGVjdGVkYFxuICAgKiBpcyBhbiBhcnJheSBvZiBtdWx0aXBseSBzZWxlY3RlZCBpdGVtcy5cbiAgICpcbiAgICogRXhhbXBsZTpcbiAgICpcbiAgICogYGBgaHRtbFxuICAgKiA8ZG9tLW1vZHVsZSBpZD1cImVtcGxveWVlLWxpc3RcIj5cbiAgICpcbiAgICogICA8dGVtcGxhdGU+XG4gICAqXG4gICAqICAgICA8ZGl2PiBFbXBsb3llZSBsaXN0OiA8L2Rpdj5cbiAgICogICAgIDx0ZW1wbGF0ZSBpcz1cImRvbS1yZXBlYXRcIiBpZD1cImVtcGxveWVlTGlzdFwiIGl0ZW1zPVwie3tlbXBsb3llZXN9fVwiPlxuICAgKiAgICAgICAgIDxkaXY+Rmlyc3QgbmFtZTogPHNwYW4+e3tpdGVtLmZpcnN0fX08L3NwYW4+PC9kaXY+XG4gICAqICAgICAgICAgPGRpdj5MYXN0IG5hbWU6IDxzcGFuPnt7aXRlbS5sYXN0fX08L3NwYW4+PC9kaXY+XG4gICAqICAgICAgICAgPGJ1dHRvbiBvbi1jbGljaz1cInRvZ2dsZVNlbGVjdGlvblwiPlNlbGVjdDwvYnV0dG9uPlxuICAgKiAgICAgPC90ZW1wbGF0ZT5cbiAgICpcbiAgICogICAgIDxhcnJheS1zZWxlY3RvciBpZD1cInNlbGVjdG9yXCIgaXRlbXM9XCJ7e2VtcGxveWVlc319XCIgc2VsZWN0ZWQ9XCJ7e3NlbGVjdGVkfX1cIiBtdWx0aSB0b2dnbGU+PC9hcnJheS1zZWxlY3Rvcj5cbiAgICpcbiAgICogICAgIDxkaXY+IFNlbGVjdGVkIGVtcGxveWVlczogPC9kaXY+XG4gICAqICAgICA8dGVtcGxhdGUgaXM9XCJkb20tcmVwZWF0XCIgaXRlbXM9XCJ7e3NlbGVjdGVkfX1cIj5cbiAgICogICAgICAgICA8ZGl2PkZpcnN0IG5hbWU6IDxzcGFuPnt7aXRlbS5maXJzdH19PC9zcGFuPjwvZGl2PlxuICAgKiAgICAgICAgIDxkaXY+TGFzdCBuYW1lOiA8c3Bhbj57e2l0ZW0ubGFzdH19PC9zcGFuPjwvZGl2PlxuICAgKiAgICAgPC90ZW1wbGF0ZT5cbiAgICpcbiAgICogICA8L3RlbXBsYXRlPlxuICAgKlxuICAgKiA8L2RvbS1tb2R1bGU+XG4gICAqIGBgYFxuICAgKlxuICAgKiBgYGBqc1xuICAgKiBQb2x5bWVyKHtcbiAgICogICBpczogJ2VtcGxveWVlLWxpc3QnLFxuICAgKiAgIHJlYWR5KCkge1xuICAgKiAgICAgdGhpcy5lbXBsb3llZXMgPSBbXG4gICAqICAgICAgICAge2ZpcnN0OiAnQm9iJywgbGFzdDogJ1NtaXRoJ30sXG4gICAqICAgICAgICAge2ZpcnN0OiAnU2FsbHknLCBsYXN0OiAnSm9obnNvbid9LFxuICAgKiAgICAgICAgIC4uLlxuICAgKiAgICAgXTtcbiAgICogICB9LFxuICAgKiAgIHRvZ2dsZVNlbGVjdGlvbihlKSB7XG4gICAqICAgICBsZXQgaXRlbSA9IHRoaXMuJC5lbXBsb3llZUxpc3QuaXRlbUZvckVsZW1lbnQoZS50YXJnZXQpO1xuICAgKiAgICAgdGhpcy4kLnNlbGVjdG9yLnNlbGVjdChpdGVtKTtcbiAgICogICB9XG4gICAqIH0pO1xuICAgKiBgYGBcbiAgICpcbiAgICogQHBvbHltZXJcbiAgICogQGN1c3RvbUVsZW1lbnRcbiAgICogQGV4dGVuZHMge2Jhc2VBcnJheVNlbGVjdG9yfVxuICAgKiBAYXBwbGllc01peGluIFBvbHltZXIuQXJyYXlTZWxlY3Rvck1peGluXG4gICAqIEBtZW1iZXJvZiBQb2x5bWVyXG4gICAqIEBzdW1tYXJ5IEN1c3RvbSBlbGVtZW50IHRoYXQgbGlua3MgcGF0aHMgYmV0d2VlbiBhbiBpbnB1dCBgaXRlbXNgIGFycmF5IGFuZFxuICAgKiAgIGFuIG91dHB1dCBgc2VsZWN0ZWRgIGl0ZW0gb3IgYXJyYXkgYmFzZWQgb24gY2FsbHMgdG8gaXRzIHNlbGVjdGlvbiBBUEkuXG4gICAqL1xuICBjbGFzcyBBcnJheVNlbGVjdG9yIGV4dGVuZHMgYmFzZUFycmF5U2VsZWN0b3Ige1xuICAgIC8vIE5vdCBuZWVkZWQgdG8gZmluZCB0ZW1wbGF0ZTsgY2FuIGJlIHJlbW92ZWQgb25jZSB0aGUgYW5hbHl6ZXJcbiAgICAvLyBjYW4gZmluZCB0aGUgdGFnIG5hbWUgZnJvbSBjdXN0b21FbGVtZW50cy5kZWZpbmUgY2FsbFxuICAgIHN0YXRpYyBnZXQgaXMoKSB7IHJldHVybiAnYXJyYXktc2VsZWN0b3InIH1cbiAgfVxuICBjdXN0b21FbGVtZW50cy5kZWZpbmUoQXJyYXlTZWxlY3Rvci5pcywgQXJyYXlTZWxlY3Rvcik7XG4gIFBvbHltZXIuQXJyYXlTZWxlY3RvciA9IEFycmF5U2VsZWN0b3I7XG5cbn0pKCk7XG5cbjwvc2NyaXB0PlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi9lbGVtZW50cy9hcnJheS1zZWxlY3Rvci5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uLy4uLy4uL3NoYWR5Y3NzL2N1c3RvbS1zdHlsZS1pbnRlcmZhY2UuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3V0aWxzL3N0eWxlLWdhdGhlci5odG1sXCI+XG48c2NyaXB0PlxuKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgY29uc3QgYXR0ciA9ICdpbmNsdWRlJztcblxuICBjb25zdCBDdXN0b21TdHlsZUludGVyZmFjZSA9IHdpbmRvdy5TaGFkeUNTUy5DdXN0b21TdHlsZUludGVyZmFjZTtcblxuICAvKipcbiAgICogQ3VzdG9tIGVsZW1lbnQgZm9yIGRlZmluaW5nIHN0eWxlcyBpbiB0aGUgbWFpbiBkb2N1bWVudCB0aGF0IGNhbiB0YWtlXG4gICAqIGFkdmFudGFnZSBvZiBzZXZlcmFsIHNwZWNpYWwgZmVhdHVyZXMgb2YgUG9seW1lcidzIHN0eWxpbmcgc3lzdGVtOlxuICAgKlxuICAgKiAtIERvY3VtZW50IHN0eWxlcyBkZWZpbmVkIGluIGEgY3VzdG9tLXN0eWxlIGFyZSBzaGltbWVkIHRvIGVuc3VyZSB0aGV5XG4gICAqICAgZG8gbm90IGxlYWsgaW50byBsb2NhbCBET00gd2hlbiBydW5uaW5nIG9uIGJyb3dzZXJzIHdpdGhvdXQgbmF0aXZlXG4gICAqICAgU2hhZG93IERPTS5cbiAgICogLSBDdXN0b20gcHJvcGVydGllcyB1c2VkIGJ5IFBvbHltZXIncyBzaGltIGZvciBjcm9zcy1zY29wZSBzdHlsaW5nIG1heVxuICAgKiAgIGJlIGRlZmluZWQgaW4gYW4gY3VzdG9tLXN0eWxlLiBVc2UgdGhlIDpyb290IHNlbGVjdG9yIHRvIGRlZmluZSBjdXN0b21cbiAgICogICBwcm9wZXJ0aWVzIHRoYXQgYXBwbHkgdG8gYWxsIGN1c3RvbSBlbGVtZW50cy5cbiAgICpcbiAgICogVG8gdXNlLCBzaW1wbHkgd3JhcCBhbiBpbmxpbmUgYDxzdHlsZT5gIHRhZyBpbiB0aGUgbWFpbiBkb2N1bWVudCB3aG9zZVxuICAgKiBDU1MgdXNlcyB0aGVzZSBmZWF0dXJlcyB3aXRoIGEgYDxjdXN0b20tc3R5bGU+YCBlbGVtZW50LlxuICAgKlxuICAgKiBAY3VzdG9tRWxlbWVudFxuICAgKiBAZXh0ZW5kcyBIVE1MRWxlbWVudFxuICAgKiBAbWVtYmVyb2YgUG9seW1lclxuICAgKiBAc3VtbWFyeSBDdXN0b20gZWxlbWVudCBmb3IgZGVmaW5pbmcgc3R5bGVzIGluIHRoZSBtYWluIGRvY3VtZW50IHRoYXQgY2FuXG4gICAqICAgdGFrZSBhZHZhbnRhZ2Ugb2YgUG9seW1lcidzIHN0eWxlIHNjb3BpbmcgYW5kIGN1c3RvbSBwcm9wZXJ0aWVzIHNoaW1zLlxuICAgKi9cbiAgY2xhc3MgQ3VzdG9tU3R5bGUgZXh0ZW5kcyBIVE1MRWxlbWVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICBzdXBlcigpO1xuICAgICAgdGhpcy5fc3R5bGUgPSBudWxsO1xuICAgICAgQ3VzdG9tU3R5bGVJbnRlcmZhY2UuYWRkQ3VzdG9tU3R5bGUodGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGxpZ2h0LURPTSBgPHN0eWxlPmAgY2hpbGQgdGhpcyBlbGVtZW50IHdyYXBzLiAgVXBvbiBmaXJzdFxuICAgICAqIGNhbGwgYW55IHN0eWxlIG1vZHVsZXMgcmVmZXJlbmNlZCB2aWEgdGhlIGBpbmNsdWRlYCBhdHRyaWJ1dGUgd2lsbCBiZVxuICAgICAqIGNvbmNhdGVuYXRlZCB0byB0aGlzIGVsZW1lbnQncyBgPHN0eWxlPmAuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtIVE1MU3R5bGVFbGVtZW50fSBUaGlzIGVsZW1lbnQncyBsaWdodC1ET00gYDxzdHlsZT5gXG4gICAgICovXG4gICAgZ2V0U3R5bGUoKSB7XG4gICAgICBpZiAodGhpcy5fc3R5bGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0eWxlO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3R5bGUgPSAvKiogQHR5cGUge0hUTUxTdHlsZUVsZW1lbnR9ICovKHRoaXMucXVlcnlTZWxlY3Rvcignc3R5bGUnKSk7XG4gICAgICBpZiAoIXN0eWxlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgdGhpcy5fc3R5bGUgPSBzdHlsZTtcbiAgICAgIGNvbnN0IGluY2x1ZGUgPSBzdHlsZS5nZXRBdHRyaWJ1dGUoYXR0cik7XG4gICAgICBpZiAoaW5jbHVkZSkge1xuICAgICAgICBzdHlsZS5yZW1vdmVBdHRyaWJ1dGUoYXR0cik7XG4gICAgICAgIHN0eWxlLnRleHRDb250ZW50ID0gUG9seW1lci5TdHlsZUdhdGhlci5jc3NGcm9tTW9kdWxlcyhpbmNsdWRlKSArIHN0eWxlLnRleHRDb250ZW50O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX3N0eWxlO1xuICAgIH1cbiAgfVxuXG4gIHdpbmRvdy5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ2N1c3RvbS1zdHlsZScsIEN1c3RvbVN0eWxlKTtcbiAgUG9seW1lci5DdXN0b21TdHlsZSA9IEN1c3RvbVN0eWxlO1xufSkoKTtcbjwvc2NyaXB0PlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi9lbGVtZW50cy9jdXN0b20tc3R5bGUuaHRtbCIsIlxucmVxdWlyZSgnLi9jdXN0b20tc3R5bGUtaW50ZXJmYWNlLm1pbi5qcycpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9zaGFkeWNzcy9jdXN0b20tc3R5bGUtaW50ZXJmYWNlLmh0bWwiLCIoZnVuY3Rpb24oKXsvKlxuXG5Db3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4qL1xuJ3VzZSBzdHJpY3QnO3ZhciBjPSEod2luZG93LlNoYWR5RE9NJiZ3aW5kb3cuU2hhZHlET00uaW5Vc2UpLGY7ZnVuY3Rpb24gZyhhKXtmPWEmJmEuc2hpbWNzc3Byb3BlcnRpZXM/ITE6Y3x8IShuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9BcHBsZVdlYktpdFxcLzYwMXxFZGdlXFwvMTUvKXx8IXdpbmRvdy5DU1N8fCFDU1Muc3VwcG9ydHN8fCFDU1Muc3VwcG9ydHMoXCJib3gtc2hhZG93XCIsXCIwIDAgMCB2YXIoLS1mb28pXCIpKX13aW5kb3cuU2hhZHlDU1MmJnZvaWQgMCE9PXdpbmRvdy5TaGFkeUNTUy5uYXRpdmVDc3M/Zj13aW5kb3cuU2hhZHlDU1MubmF0aXZlQ3NzOndpbmRvdy5TaGFkeUNTUz8oZyh3aW5kb3cuU2hhZHlDU1MpLHdpbmRvdy5TaGFkeUNTUz12b2lkIDApOmcod2luZG93LldlYkNvbXBvbmVudHMmJndpbmRvdy5XZWJDb21wb25lbnRzLmZsYWdzKTt2YXIgaD1mO2Z1bmN0aW9uIGsoYSxiKXtmb3IodmFyIGQgaW4gYiludWxsPT09ZD9hLnN0eWxlLnJlbW92ZVByb3BlcnR5KGQpOmEuc3R5bGUuc2V0UHJvcGVydHkoZCxiW2RdKX07dmFyIGw9bnVsbCxtPXdpbmRvdy5IVE1MSW1wb3J0cyYmd2luZG93LkhUTUxJbXBvcnRzLndoZW5SZWFkeXx8bnVsbCxuO2Z1bmN0aW9uIHAoKXt2YXIgYT1xO3JlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbigpe20/bShhKToobHx8KGw9bmV3IFByb21pc2UoZnVuY3Rpb24oYSl7bj1hfSksXCJjb21wbGV0ZVwiPT09ZG9jdW1lbnQucmVhZHlTdGF0ZT9uKCk6ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInJlYWR5c3RhdGVjaGFuZ2VcIixmdW5jdGlvbigpe1wiY29tcGxldGVcIj09PWRvY3VtZW50LnJlYWR5U3RhdGUmJm4oKX0pKSxsLnRoZW4oZnVuY3Rpb24oKXthJiZhKCl9KSl9KX07dmFyIHI9bnVsbCxxPW51bGw7ZnVuY3Rpb24gdCgpe3RoaXMuY3VzdG9tU3R5bGVzPVtdO3RoaXMuZW5xdWV1ZWQ9ITF9ZnVuY3Rpb24gdShhKXshYS5lbnF1ZXVlZCYmcSYmKGEuZW5xdWV1ZWQ9ITAscCgpKX10LnByb3RvdHlwZS5jPWZ1bmN0aW9uKGEpe2EuX19zZWVuQnlTaGFkeUNTU3x8KGEuX19zZWVuQnlTaGFkeUNTUz0hMCx0aGlzLmN1c3RvbVN0eWxlcy5wdXNoKGEpLHUodGhpcykpfTt0LnByb3RvdHlwZS5iPWZ1bmN0aW9uKGEpe2lmKGEuX19zaGFkeUNTU0NhY2hlZFN0eWxlKXJldHVybiBhLl9fc2hhZHlDU1NDYWNoZWRTdHlsZTt2YXIgYjthLmdldFN0eWxlP2I9YS5nZXRTdHlsZSgpOmI9YTtyZXR1cm4gYn07XG50LnByb3RvdHlwZS5hPWZ1bmN0aW9uKCl7Zm9yKHZhciBhPXRoaXMuY3VzdG9tU3R5bGVzLGI9MDtiPGEubGVuZ3RoO2IrKyl7dmFyIGQ9YVtiXTtpZighZC5fX3NoYWR5Q1NTQ2FjaGVkU3R5bGUpe3ZhciBlPXRoaXMuYihkKTtlJiYoZT1lLl9fYXBwbGllZEVsZW1lbnR8fGUsciYmcihlKSxkLl9fc2hhZHlDU1NDYWNoZWRTdHlsZT1lKX19cmV0dXJuIGF9O3QucHJvdG90eXBlLmFkZEN1c3RvbVN0eWxlPXQucHJvdG90eXBlLmM7dC5wcm90b3R5cGUuZ2V0U3R5bGVGb3JDdXN0b21TdHlsZT10LnByb3RvdHlwZS5iO3QucHJvdG90eXBlLnByb2Nlc3NTdHlsZXM9dC5wcm90b3R5cGUuYTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHQucHJvdG90eXBlLHt0cmFuc2Zvcm1DYWxsYmFjazp7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHJ9LHNldDpmdW5jdGlvbihhKXtyPWF9fSx2YWxpZGF0ZUNhbGxiYWNrOntnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gcX0sc2V0OmZ1bmN0aW9uKGEpe3ZhciBiPSExO3F8fChiPSEwKTtxPWE7YiYmdSh0aGlzKX19fSk7dmFyIHY9bmV3IHQ7d2luZG93LlNoYWR5Q1NTfHwod2luZG93LlNoYWR5Q1NTPXtwcmVwYXJlVGVtcGxhdGU6ZnVuY3Rpb24oKXt9LHN0eWxlU3VidHJlZTpmdW5jdGlvbihhLGIpe3YuYSgpO2soYSxiKX0sc3R5bGVFbGVtZW50OmZ1bmN0aW9uKCl7di5hKCl9LHN0eWxlRG9jdW1lbnQ6ZnVuY3Rpb24oYSl7di5hKCk7ayhkb2N1bWVudC5ib2R5LGEpfSxnZXRDb21wdXRlZFN0eWxlVmFsdWU6ZnVuY3Rpb24oYSxiKXtyZXR1cm4oYT13aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShhKS5nZXRQcm9wZXJ0eVZhbHVlKGIpKT9hLnRyaW0oKTpcIlwifSxuYXRpdmVDc3M6aCxuYXRpdmVTaGFkb3c6Y30pO3dpbmRvdy5TaGFkeUNTUy5DdXN0b21TdHlsZUludGVyZmFjZT12O30pLmNhbGwodGhpcyk7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWN1c3RvbS1zdHlsZS1pbnRlcmZhY2UubWluLmpzLm1hcFxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9zaGFkeWNzcy9jdXN0b20tc3R5bGUtaW50ZXJmYWNlLm1pbi5qcyIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cblxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL21peGlucy9tdXRhYmxlLWRhdGEuaHRtbFwiPlxuXG48c2NyaXB0PlxuKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgbGV0IG11dGFibGVQcm9wZXJ0eUNoYW5nZTtcbiAgKFxuICAgIC8qKiBAc3VwcHJlc3Mge21pc3NpbmdQcm9wZXJ0aWVzfSAqL1xuICAgIGZ1bmN0aW9uKCkge1xuICAgIG11dGFibGVQcm9wZXJ0eUNoYW5nZSA9IFBvbHltZXIuTXV0YWJsZURhdGEuX211dGFibGVQcm9wZXJ0eUNoYW5nZTtcbiAgfSkoKTtcblxuICAvKipcbiAgICogTGVnYWN5IGVsZW1lbnQgYmVoYXZpb3IgdG8gc2tpcCBzdHJpY3QgZGlydHktY2hlY2tpbmcgZm9yIG9iamVjdHMgYW5kIGFycmF5cyxcbiAgICogKGFsd2F5cyBjb25zaWRlciB0aGVtIHRvIGJlIFwiZGlydHlcIikgZm9yIHVzZSBvbiBsZWdhY3kgQVBJIFBvbHltZXIgZWxlbWVudHMuXG4gICAqXG4gICAqIEJ5IGRlZmF1bHQsIGBQb2x5bWVyLlByb3BlcnR5RWZmZWN0c2AgcGVyZm9ybXMgc3RyaWN0IGRpcnR5IGNoZWNraW5nIG9uXG4gICAqIG9iamVjdHMsIHdoaWNoIG1lYW5zIHRoYXQgYW55IGRlZXAgbW9kaWZpY2F0aW9ucyB0byBhbiBvYmplY3Qgb3IgYXJyYXkgd2lsbFxuICAgKiBub3QgYmUgcHJvcGFnYXRlZCB1bmxlc3MgXCJpbW11dGFibGVcIiBkYXRhIHBhdHRlcm5zIGFyZSB1c2VkIChpLmUuIGFsbCBvYmplY3RcbiAgICogcmVmZXJlbmNlcyBmcm9tIHRoZSByb290IHRvIHRoZSBtdXRhdGlvbiB3ZXJlIGNoYW5nZWQpLlxuICAgKlxuICAgKiBQb2x5bWVyIGFsc28gcHJvdmlkZXMgYSBwcm9wcmlldGFyeSBkYXRhIG11dGF0aW9uIGFuZCBwYXRoIG5vdGlmaWNhdGlvbiBBUElcbiAgICogKGUuZy4gYG5vdGlmeVBhdGhgLCBgc2V0YCwgYW5kIGFycmF5IG11dGF0aW9uIEFQSSdzKSB0aGF0IGFsbG93IGVmZmljaWVudFxuICAgKiBtdXRhdGlvbiBhbmQgbm90aWZpY2F0aW9uIG9mIGRlZXAgY2hhbmdlcyBpbiBhbiBvYmplY3QgZ3JhcGggdG8gYWxsIGVsZW1lbnRzXG4gICAqIGJvdW5kIHRvIHRoZSBzYW1lIG9iamVjdCBncmFwaC5cbiAgICpcbiAgICogSW4gY2FzZXMgd2hlcmUgbmVpdGhlciBpbW11dGFibGUgcGF0dGVybnMgbm9yIHRoZSBkYXRhIG11dGF0aW9uIEFQSSBjYW4gYmVcbiAgICogdXNlZCwgYXBwbHlpbmcgdGhpcyBtaXhpbiB3aWxsIGNhdXNlIFBvbHltZXIgdG8gc2tpcCBkaXJ0eSBjaGVja2luZyBmb3JcbiAgICogb2JqZWN0cyBhbmQgYXJyYXlzIChhbHdheXMgY29uc2lkZXIgdGhlbSB0byBiZSBcImRpcnR5XCIpLiAgVGhpcyBhbGxvd3MgYVxuICAgKiB1c2VyIHRvIG1ha2UgYSBkZWVwIG1vZGlmaWNhdGlvbiB0byBhIGJvdW5kIG9iamVjdCBncmFwaCwgYW5kIHRoZW4gZWl0aGVyXG4gICAqIHNpbXBseSByZS1zZXQgdGhlIG9iamVjdCAoZS5nLiBgdGhpcy5pdGVtcyA9IHRoaXMuaXRlbXNgKSBvciBjYWxsIGBub3RpZnlQYXRoYFxuICAgKiAoZS5nLiBgdGhpcy5ub3RpZnlQYXRoKCdpdGVtcycpYCkgdG8gdXBkYXRlIHRoZSB0cmVlLiAgTm90ZSB0aGF0IGFsbFxuICAgKiBlbGVtZW50cyB0aGF0IHdpc2ggdG8gYmUgdXBkYXRlZCBiYXNlZCBvbiBkZWVwIG11dGF0aW9ucyBtdXN0IGFwcGx5IHRoaXNcbiAgICogbWl4aW4gb3Igb3RoZXJ3aXNlIHNraXAgc3RyaWN0IGRpcnR5IGNoZWNraW5nIGZvciBvYmplY3RzL2FycmF5cy5cbiAgICpcbiAgICogSW4gb3JkZXIgdG8gbWFrZSB0aGUgZGlydHkgY2hlY2sgc3RyYXRlZ3kgY29uZmlndXJhYmxlLCBzZWVcbiAgICogYFBvbHltZXIuT3B0aW9uYWxNdXRhYmxlRGF0YUJlaGF2aW9yYC5cbiAgICpcbiAgICogTm90ZSwgdGhlIHBlcmZvcm1hbmNlIGNoYXJhY3RlcmlzdGljcyBvZiBwcm9wYWdhdGluZyBsYXJnZSBvYmplY3QgZ3JhcGhzXG4gICAqIHdpbGwgYmUgd29yc2UgYXMgb3Bwb3NlZCB0byB1c2luZyBzdHJpY3QgZGlydHkgY2hlY2tpbmcgd2l0aCBpbW11dGFibGVcbiAgICogcGF0dGVybnMgb3IgUG9seW1lcidzIHBhdGggbm90aWZpY2F0aW9uIEFQSS5cbiAgICpcbiAgICogQHBvbHltZXJCZWhhdmlvclxuICAgKiBAbWVtYmVyb2YgUG9seW1lclxuICAgKiBAc3VtbWFyeSBCZWhhdmlvciB0byBza2lwIHN0cmljdCBkaXJ0eS1jaGVja2luZyBmb3Igb2JqZWN0cyBhbmRcbiAgICogICBhcnJheXNcbiAgICovXG4gIFBvbHltZXIuTXV0YWJsZURhdGFCZWhhdmlvciA9IHtcblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlcyBgUG9seW1lci5Qcm9wZXJ0eUVmZmVjdHNgIHRvIHByb3ZpZGUgb3B0aW9uIGZvciBza2lwcGluZ1xuICAgICAqIHN0cmljdCBlcXVhbGl0eSBjaGVja2luZyBmb3IgT2JqZWN0cyBhbmQgQXJyYXlzLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgcHVsbHMgdGhlIHZhbHVlIHRvIGRpcnR5IGNoZWNrIGFnYWluc3QgZnJvbSB0aGUgYF9fZGF0YVRlbXBgXG4gICAgICogY2FjaGUgKHJhdGhlciB0aGFuIHRoZSBub3JtYWwgYF9fZGF0YWAgY2FjaGUpIGZvciBPYmplY3RzLiAgU2luY2UgdGhlIHRlbXBcbiAgICAgKiBjYWNoZSBpcyBjbGVhcmVkIGF0IHRoZSBlbmQgb2YgYSB0dXJuLCB0aGlzIGltcGxlbWVudGF0aW9uIGFsbG93c1xuICAgICAqIHNpZGUtZWZmZWN0cyBvZiBkZWVwIG9iamVjdCBjaGFuZ2VzIHRvIGJlIHByb2Nlc3NlZCBieSByZS1zZXR0aW5nIHRoZVxuICAgICAqIHNhbWUgb2JqZWN0ICh1c2luZyB0aGUgdGVtcCBjYWNoZSBhcyBhbiBpbi10dXJuIGJhY2tzdG9wIHRvIHByZXZlbnRcbiAgICAgKiBjeWNsZXMgZHVlIHRvIDItd2F5IG5vdGlmaWNhdGlvbikuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgbmFtZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgTmV3IHByb3BlcnR5IHZhbHVlXG4gICAgICogQHBhcmFtIHsqfSBvbGQgUHJldmlvdXMgcHJvcGVydHkgdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBwcm9wZXJ0eSBzaG91bGQgYmUgY29uc2lkZXJlZCBhIGNoYW5nZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfc2hvdWxkUHJvcGVydHlDaGFuZ2UocHJvcGVydHksIHZhbHVlLCBvbGQpIHtcbiAgICAgIHJldHVybiBtdXRhYmxlUHJvcGVydHlDaGFuZ2UodGhpcywgcHJvcGVydHksIHZhbHVlLCBvbGQsIHRydWUpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogTGVnYWN5IGVsZW1lbnQgYmVoYXZpb3IgdG8gYWRkIHRoZSBvcHRpb25hbCBhYmlsaXR5IHRvIHNraXAgc3RyaWN0XG4gICAqIGRpcnR5LWNoZWNraW5nIGZvciBvYmplY3RzIGFuZCBhcnJheXMgKGFsd2F5cyBjb25zaWRlciB0aGVtIHRvIGJlXG4gICAqIFwiZGlydHlcIikgYnkgc2V0dGluZyBhIGBtdXRhYmxlLWRhdGFgIGF0dHJpYnV0ZSBvbiBhbiBlbGVtZW50IGluc3RhbmNlLlxuICAgKlxuICAgKiBCeSBkZWZhdWx0LCBgUG9seW1lci5Qcm9wZXJ0eUVmZmVjdHNgIHBlcmZvcm1zIHN0cmljdCBkaXJ0eSBjaGVja2luZyBvblxuICAgKiBvYmplY3RzLCB3aGljaCBtZWFucyB0aGF0IGFueSBkZWVwIG1vZGlmaWNhdGlvbnMgdG8gYW4gb2JqZWN0IG9yIGFycmF5IHdpbGxcbiAgICogbm90IGJlIHByb3BhZ2F0ZWQgdW5sZXNzIFwiaW1tdXRhYmxlXCIgZGF0YSBwYXR0ZXJucyBhcmUgdXNlZCAoaS5lLiBhbGwgb2JqZWN0XG4gICAqIHJlZmVyZW5jZXMgZnJvbSB0aGUgcm9vdCB0byB0aGUgbXV0YXRpb24gd2VyZSBjaGFuZ2VkKS5cbiAgICpcbiAgICogUG9seW1lciBhbHNvIHByb3ZpZGVzIGEgcHJvcHJpZXRhcnkgZGF0YSBtdXRhdGlvbiBhbmQgcGF0aCBub3RpZmljYXRpb24gQVBJXG4gICAqIChlLmcuIGBub3RpZnlQYXRoYCwgYHNldGAsIGFuZCBhcnJheSBtdXRhdGlvbiBBUEkncykgdGhhdCBhbGxvdyBlZmZpY2llbnRcbiAgICogbXV0YXRpb24gYW5kIG5vdGlmaWNhdGlvbiBvZiBkZWVwIGNoYW5nZXMgaW4gYW4gb2JqZWN0IGdyYXBoIHRvIGFsbCBlbGVtZW50c1xuICAgKiBib3VuZCB0byB0aGUgc2FtZSBvYmplY3QgZ3JhcGguXG4gICAqXG4gICAqIEluIGNhc2VzIHdoZXJlIG5laXRoZXIgaW1tdXRhYmxlIHBhdHRlcm5zIG5vciB0aGUgZGF0YSBtdXRhdGlvbiBBUEkgY2FuIGJlXG4gICAqIHVzZWQsIGFwcGx5aW5nIHRoaXMgbWl4aW4gd2lsbCBhbGxvdyBQb2x5bWVyIHRvIHNraXAgZGlydHkgY2hlY2tpbmcgZm9yXG4gICAqIG9iamVjdHMgYW5kIGFycmF5cyAoYWx3YXlzIGNvbnNpZGVyIHRoZW0gdG8gYmUgXCJkaXJ0eVwiKS4gIFRoaXMgYWxsb3dzIGFcbiAgICogdXNlciB0byBtYWtlIGEgZGVlcCBtb2RpZmljYXRpb24gdG8gYSBib3VuZCBvYmplY3QgZ3JhcGgsIGFuZCB0aGVuIGVpdGhlclxuICAgKiBzaW1wbHkgcmUtc2V0IHRoZSBvYmplY3QgKGUuZy4gYHRoaXMuaXRlbXMgPSB0aGlzLml0ZW1zYCkgb3IgY2FsbCBgbm90aWZ5UGF0aGBcbiAgICogKGUuZy4gYHRoaXMubm90aWZ5UGF0aCgnaXRlbXMnKWApIHRvIHVwZGF0ZSB0aGUgdHJlZS4gIE5vdGUgdGhhdCBhbGxcbiAgICogZWxlbWVudHMgdGhhdCB3aXNoIHRvIGJlIHVwZGF0ZWQgYmFzZWQgb24gZGVlcCBtdXRhdGlvbnMgbXVzdCBhcHBseSB0aGlzXG4gICAqIG1peGluIG9yIG90aGVyd2lzZSBza2lwIHN0cmljdCBkaXJ0eSBjaGVja2luZyBmb3Igb2JqZWN0cy9hcnJheXMuXG4gICAqXG4gICAqIFdoaWxlIHRoaXMgYmVoYXZpb3IgYWRkcyB0aGUgYWJpbGl0eSB0byBmb3JnbyBPYmplY3QvQXJyYXkgZGlydHkgY2hlY2tpbmcsXG4gICAqIHRoZSBgbXV0YWJsZURhdGFgIGZsYWcgZGVmYXVsdHMgdG8gZmFsc2UgYW5kIG11c3QgYmUgc2V0IG9uIHRoZSBpbnN0YW5jZS5cbiAgICpcbiAgICogTm90ZSwgdGhlIHBlcmZvcm1hbmNlIGNoYXJhY3RlcmlzdGljcyBvZiBwcm9wYWdhdGluZyBsYXJnZSBvYmplY3QgZ3JhcGhzXG4gICAqIHdpbGwgYmUgd29yc2UgYnkgcmVseWluZyBvbiBgbXV0YWJsZURhdGE6IHRydWVgIGFzIG9wcG9zZWQgdG8gdXNpbmdcbiAgICogc3RyaWN0IGRpcnR5IGNoZWNraW5nIHdpdGggaW1tdXRhYmxlIHBhdHRlcm5zIG9yIFBvbHltZXIncyBwYXRoIG5vdGlmaWNhdGlvblxuICAgKiBBUEkuXG4gICAqXG4gICAqIEBwb2x5bWVyQmVoYXZpb3JcbiAgICogQG1lbWJlcm9mIFBvbHltZXJcbiAgICogQHN1bW1hcnkgQmVoYXZpb3IgdG8gb3B0aW9uYWxseSBza2lwIHN0cmljdCBkaXJ0eS1jaGVja2luZyBmb3Igb2JqZWN0cyBhbmRcbiAgICogICBhcnJheXNcbiAgICovXG4gIFBvbHltZXIuT3B0aW9uYWxNdXRhYmxlRGF0YUJlaGF2aW9yID0ge1xuXG4gICAgcHJvcGVydGllczoge1xuICAgICAgLyoqXG4gICAgICAgKiBJbnN0YW5jZS1sZXZlbCBmbGFnIGZvciBjb25maWd1cmluZyB0aGUgZGlydHktY2hlY2tpbmcgc3RyYXRlZ3lcbiAgICAgICAqIGZvciB0aGlzIGVsZW1lbnQuICBXaGVuIHRydWUsIE9iamVjdHMgYW5kIEFycmF5cyB3aWxsIHNraXAgZGlydHlcbiAgICAgICAqIGNoZWNraW5nLCBvdGhlcndpc2Ugc3RyaWN0IGVxdWFsaXR5IGNoZWNraW5nIHdpbGwgYmUgdXNlZC5cbiAgICAgICAqL1xuICAgICAgbXV0YWJsZURhdGE6IEJvb2xlYW5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGVzIGBQb2x5bWVyLlByb3BlcnR5RWZmZWN0c2AgdG8gc2tpcCBzdHJpY3QgZXF1YWxpdHkgY2hlY2tpbmdcbiAgICAgKiBmb3IgT2JqZWN0cyBhbmQgQXJyYXlzLlxuICAgICAqXG4gICAgICogUHVsbHMgdGhlIHZhbHVlIHRvIGRpcnR5IGNoZWNrIGFnYWluc3QgZnJvbSB0aGUgYF9fZGF0YVRlbXBgIGNhY2hlXG4gICAgICogKHJhdGhlciB0aGFuIHRoZSBub3JtYWwgYF9fZGF0YWAgY2FjaGUpIGZvciBPYmplY3RzLiAgU2luY2UgdGhlIHRlbXBcbiAgICAgKiBjYWNoZSBpcyBjbGVhcmVkIGF0IHRoZSBlbmQgb2YgYSB0dXJuLCB0aGlzIGltcGxlbWVudGF0aW9uIGFsbG93c1xuICAgICAqIHNpZGUtZWZmZWN0cyBvZiBkZWVwIG9iamVjdCBjaGFuZ2VzIHRvIGJlIHByb2Nlc3NlZCBieSByZS1zZXR0aW5nIHRoZVxuICAgICAqIHNhbWUgb2JqZWN0ICh1c2luZyB0aGUgdGVtcCBjYWNoZSBhcyBhbiBpbi10dXJuIGJhY2tzdG9wIHRvIHByZXZlbnRcbiAgICAgKiBjeWNsZXMgZHVlIHRvIDItd2F5IG5vdGlmaWNhdGlvbikuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgbmFtZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgTmV3IHByb3BlcnR5IHZhbHVlXG4gICAgICogQHBhcmFtIHsqfSBvbGQgUHJldmlvdXMgcHJvcGVydHkgdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBwcm9wZXJ0eSBzaG91bGQgYmUgY29uc2lkZXJlZCBhIGNoYW5nZVxuICAgICAqIEB0aGlzIHt0aGlzfVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfc2hvdWxkUHJvcGVydHlDaGFuZ2UocHJvcGVydHksIHZhbHVlLCBvbGQpIHtcbiAgICAgIHJldHVybiBtdXRhYmxlUHJvcGVydHlDaGFuZ2UodGhpcywgcHJvcGVydHksIHZhbHVlLCBvbGQsIHRoaXMubXV0YWJsZURhdGEpO1xuICAgIH1cbiAgfTtcblxufSkoKTtcblxuPC9zY3JpcHQ+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL3BvbHltZXIvbGliL2xlZ2FjeS9tdXRhYmxlLWRhdGEtYmVoYXZpb3IuaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTUgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cblxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uLy4uL3BvbHltZXIvcG9seW1lci5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vLi4vaXJvbi1tZWRpYS1xdWVyeS9pcm9uLW1lZGlhLXF1ZXJ5Lmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi9hcHAtbGF5b3V0LWJlaGF2aW9yL2FwcC1sYXlvdXQtYmVoYXZpb3IuaHRtbFwiPlxuXG48IS0tXG5hcHAtZHJhd2VyLWxheW91dCBpcyBhIHdyYXBwZXIgZWxlbWVudCB0aGF0IHBvc2l0aW9ucyBhbiBhcHAtZHJhd2VyIGFuZCBvdGhlciBjb250ZW50LiBXaGVuXG50aGUgdmlld3BvcnQgd2lkdGggaXMgc21hbGxlciB0aGFuIGByZXNwb25zaXZlV2lkdGhgLCB0aGlzIGVsZW1lbnQgY2hhbmdlcyB0byBuYXJyb3cgbGF5b3V0LlxuSW4gbmFycm93IGxheW91dCwgdGhlIGRyYXdlciB3aWxsIGJlIHN0YWNrZWQgb24gdG9wIG9mIHRoZSBtYWluIGNvbnRlbnQuIFRoZSBkcmF3ZXIgd2lsbCBzbGlkZVxuaW4vb3V0IHRvIGhpZGUvcmV2ZWFsIHRoZSBtYWluIGNvbnRlbnQuXG5cbkJ5IGRlZmF1bHQgdGhlIGRyYXdlciBpcyBhbGlnbmVkIHRvIHRoZSBzdGFydCwgd2hpY2ggaXMgbGVmdCBpbiBMVFIgbGF5b3V0czpcblxuYGBgaHRtbFxuPGFwcC1kcmF3ZXItbGF5b3V0PlxuICA8YXBwLWRyYXdlciBzbG90PVwiZHJhd2VyXCI+XG4gICAgZHJhd2VyIGNvbnRlbnRcbiAgPC9hcHAtZHJhd2VyPlxuICA8ZGl2PlxuICAgIG1haW4gY29udGVudFxuICA8L2Rpdj5cbjwvYXBwLWRyYXdlci1sYXlvdXQ+XG5gYGBcblxuQWxpZ24gdGhlIGRyYXdlciBhdCB0aGUgZW5kOlxuXG5gYGBodG1sXG48YXBwLWRyYXdlci1sYXlvdXQ+XG4gIDxhcHAtZHJhd2VyIHNsb3Q9XCJkcmF3ZXJcIiBhbGlnbj1cImVuZFwiPlxuICAgICBkcmF3ZXIgY29udGVudFxuICA8L2FwcC1kcmF3ZXI+XG4gIDxkaXY+XG4gICAgbWFpbiBjb250ZW50XG4gIDwvZGl2PlxuPC9hcHAtZHJhd2VyLWxheW91dD5cbmBgYFxuXG5XaXRoIGFuIGFwcC1oZWFkZXItbGF5b3V0OlxuXG5gYGBodG1sXG48YXBwLWRyYXdlci1sYXlvdXQ+XG4gIDxhcHAtZHJhd2VyIHNsb3Q9XCJkcmF3ZXJcIj5cbiAgICBkcmF3ZXItY29udGVudFxuICA8L2FwcC1kcmF3ZXI+XG4gIDxhcHAtaGVhZGVyLWxheW91dD5cbiAgICA8YXBwLWhlYWRlciBzbG90PVwiaGVhZGVyXCI+XG4gICAgICA8YXBwLXRvb2xiYXI+XG4gICAgICAgIDxkaXYgbWFpbi10aXRsZT5BcHAgbmFtZTwvZGl2PlxuICAgICAgPC9hcHAtdG9vbGJhcj5cbiAgICA8L2FwcC1oZWFkZXI+XG5cbiAgICBtYWluIGNvbnRlbnRcblxuICA8L2FwcC1oZWFkZXItbGF5b3V0PlxuPC9hcHAtZHJhd2VyLWxheW91dD5cbmBgYFxuXG5BZGQgdGhlIGBkcmF3ZXItdG9nZ2xlYCBhdHRyaWJ1dGUgdG8gZWxlbWVudHMgaW5zaWRlIGBhcHAtZHJhd2VyLWxheW91dGAgdGhhdCB0b2dnbGUgdGhlIGRyYXdlciBvbiBjbGljayBldmVudHM6XG5cbmBgYGh0bWxcbjxhcHAtZHJhd2VyLWxheW91dD5cbiAgPGFwcC1kcmF3ZXIgc2xvdD1cImRyYXdlclwiPlxuICAgIGRyYXdlci1jb250ZW50XG4gIDwvYXBwLWRyYXdlcj5cbiAgPGFwcC1oZWFkZXItbGF5b3V0PlxuICAgIDxhcHAtaGVhZGVyIHNsb3Q9XCJoZWFkZXJcIj5cbiAgICAgIDxhcHAtdG9vbGJhcj5cbiAgICAgICAgPHBhcGVyLWljb24tYnV0dG9uIGljb249XCJtZW51XCIgZHJhd2VyLXRvZ2dsZT48L3BhcGVyLWljb24tYnV0dG9uPlxuICAgICAgICA8ZGl2IG1haW4tdGl0bGU+QXBwIG5hbWU8L2Rpdj5cbiAgICAgIDwvYXBwLXRvb2xiYXI+XG4gICAgPC9hcHAtaGVhZGVyPlxuXG4gICAgbWFpbiBjb250ZW50XG5cbiAgPC9hcHAtaGVhZGVyLWxheW91dD5cbjwvYXBwLWRyYXdlci1sYXlvdXQ+XG5gYGBcblxuKipOT1RFOioqIFdpdGggYXBwLWxheW91dCAyLjAsIHRoZSBgZHJhd2VyLXRvZ2dsZWAgZWxlbWVudCB3aWxsIG5vdCBiZSBhdXRvbWF0aWNhbGx5IGhpZGRlblxud2hlbiBhcHAtZHJhd2VyLWxheW91dCBpcyBub3QgaW4gbmFycm93IGxheW91dC4gVG8gYWRkIHRoaXMsIGFkZCB0aGUgZm9sbG93aW5nIENTUyBydWxlIHdoZXJlXG5hcHAtZHJhd2VyLWxheW91dCBpcyB1c2VkOlxuXG5gYGBjc3NcbmFwcC1kcmF3ZXItbGF5b3V0Om5vdChbbmFycm93XSkgW2RyYXdlci10b2dnbGVdIHtcbiAgZGlzcGxheTogbm9uZTtcbn1cbmBgYFxuXG5BZGQgdGhlIGBmdWxsYmxlZWRgIGF0dHJpYnV0ZSB0byBhcHAtZHJhd2VyLWxheW91dCB0byBtYWtlIGl0IGZpdCB0aGUgc2l6ZSBvZiBpdHMgY29udGFpbmVyOlxuXG5gYGBodG1sXG48YXBwLWRyYXdlci1sYXlvdXQgZnVsbGJsZWVkPlxuICA8YXBwLWRyYXdlciBzbG90PVwiZHJhd2VyXCI+XG4gICAgIGRyYXdlciBjb250ZW50XG4gIDwvYXBwLWRyYXdlcj5cbiAgPGRpdj5cbiAgICBtYWluIGNvbnRlbnRcbiAgPC9kaXY+XG48L2FwcC1kcmF3ZXItbGF5b3V0PlxuYGBgXG5cbiMjIyBTdHlsaW5nXG5cbkN1c3RvbSBwcm9wZXJ0eSAgICAgICAgICAgICAgICAgICAgICAgICAgfCBEZXNjcmlwdGlvbiAgICAgICAgICAgICAgICAgICAgICAgICAgfCBEZWZhdWx0XG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXwtLS0tLS0tLS1cbmAtLWFwcC1kcmF3ZXItd2lkdGhgICAgICAgICAgICAgICAgICAgICAgfCBXaWR0aCBvZiB0aGUgZHJhd2VyICAgICAgICAgICAgICAgICAgfCAyNTZweFxuYC0tYXBwLWRyYXdlci1sYXlvdXQtY29udGVudC10cmFuc2l0aW9uYCB8IFRyYW5zaXRpb24gZm9yIHRoZSBjb250ZW50IGNvbnRhaW5lciB8IG5vbmVcblxuKipOT1RFOioqIElmIHlvdSB1c2UgPGFwcC1kcmF3ZXI+IHdpdGggPGFwcC1kcmF3ZXItbGF5b3V0PiBhbmQgc3BlY2lmeSBhIHZhbHVlIGZvclxuYC0tYXBwLWRyYXdlci13aWR0aGAsIHRoYXQgdmFsdWUgbXVzdCBiZSBhY2Nlc3NpYmxlIGJ5IGJvdGggZWxlbWVudHMuIFRoaXMgY2FuIGJlIGRvbmUgYnlcbmRlZmluaW5nIHRoZSB2YWx1ZSBvbiB0aGUgYDpob3N0YCB0aGF0IGNvbnRhaW5zIDxhcHAtZHJhd2VyLWxheW91dD4gKG9yIGBodG1sYCBpZiBvdXRzaWRlXG5hIHNoYWRvdyByb290KTpcblxuYGBgY3NzXG46aG9zdCB7XG4gIC0tYXBwLWRyYXdlci13aWR0aDogMzAwcHg7XG59XG5gYGBcblxuQGdyb3VwIEFwcCBFbGVtZW50c1xuQGVsZW1lbnQgYXBwLWRyYXdlci1sYXlvdXRcbkBkZW1vIGFwcC1kcmF3ZXItbGF5b3V0L2RlbW8vaW5kZXguaHRtbFxuLS0+XG5cbjxkb20tbW9kdWxlIGlkPVwiYXBwLWRyYXdlci1sYXlvdXRcIj5cbiAgPHRlbXBsYXRlPlxuICAgIDxzdHlsZT5cbiAgICAgIDpob3N0IHtcbiAgICAgICAgZGlzcGxheTogYmxvY2s7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGb3JjZSBhcHAtZHJhd2VyLWxheW91dCB0byBoYXZlIGl0cyBvd24gc3RhY2tpbmcgY29udGV4dCBzbyB0aGF0IGl0cyBwYXJlbnQgY2FuXG4gICAgICAgICAqIGNvbnRyb2wgdGhlIHN0YWNraW5nIG9mIGl0IHJlbGF0aXZlIHRvIG90aGVyIGVsZW1lbnRzLlxuICAgICAgICAgKi9cbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICB6LWluZGV4OiAwO1xuICAgICAgfVxuXG4gICAgICA6aG9zdCA6OnNsb3R0ZWQoW3Nsb3Q9ZHJhd2VyXSkge1xuICAgICAgICB6LWluZGV4OiAxO1xuICAgICAgfVxuXG4gICAgICA6aG9zdChbZnVsbGJsZWVkXSkge1xuICAgICAgICBAYXBwbHkgLS1sYXlvdXQtZml0O1xuICAgICAgfVxuXG4gICAgICAjY29udGVudENvbnRhaW5lciB7XG4gICAgICAgIC8qIENyZWF0ZSBhIHN0YWNraW5nIGNvbnRleHQgaGVyZSBzbyB0aGF0IGFsbCBjaGlsZHJlbiBhcHBlYXIgYmVsb3cgdGhlIGhlYWRlci4gKi9cbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICB6LWluZGV4OiAwO1xuICAgICAgICBoZWlnaHQ6IDEwMCU7XG4gICAgICAgIHRyYW5zaXRpb246IHZhcigtLWFwcC1kcmF3ZXItbGF5b3V0LWNvbnRlbnQtdHJhbnNpdGlvbiwgbm9uZSk7XG4gICAgICB9XG5cbiAgICAgICNjb250ZW50Q29udGFpbmVyW2RyYXdlci1wb3NpdGlvbj1sZWZ0XSB7XG4gICAgICAgIG1hcmdpbi1sZWZ0OiB2YXIoLS1hcHAtZHJhd2VyLXdpZHRoLCAyNTZweCk7XG4gICAgICB9XG5cbiAgICAgICNjb250ZW50Q29udGFpbmVyW2RyYXdlci1wb3NpdGlvbj1yaWdodF0ge1xuICAgICAgICBtYXJnaW4tcmlnaHQ6IHZhcigtLWFwcC1kcmF3ZXItd2lkdGgsIDI1NnB4KTtcbiAgICAgIH1cbiAgICA8L3N0eWxlPlxuXG4gICAgPHNsb3QgaWQ9XCJkcmF3ZXJTbG90XCIgbmFtZT1cImRyYXdlclwiPjwvc2xvdD5cblxuICAgIDxkaXYgaWQ9XCJjb250ZW50Q29udGFpbmVyXCIgZHJhd2VyLXBvc2l0aW9uJD1cIltbX2RyYXdlclBvc2l0aW9uXV1cIj5cbiAgICAgIDxzbG90Pjwvc2xvdD5cbiAgICA8L2Rpdj5cblxuICAgIDxpcm9uLW1lZGlhLXF1ZXJ5XG4gICAgICAgIHF1ZXJ5PVwiW1tfY29tcHV0ZU1lZGlhUXVlcnkoZm9yY2VOYXJyb3csIHJlc3BvbnNpdmVXaWR0aCldXVwiXG4gICAgICAgIG9uLXF1ZXJ5LW1hdGNoZXMtY2hhbmdlZD1cIl9vblF1ZXJ5TWF0Y2hlc0NoYW5nZWRcIj48L2lyb24tbWVkaWEtcXVlcnk+XG4gIDwvdGVtcGxhdGU+XG5cbiAgPHNjcmlwdD5cbiAgICBQb2x5bWVyKHtcbiAgICAgIGlzOiAnYXBwLWRyYXdlci1sYXlvdXQnLFxuXG4gICAgICBiZWhhdmlvcnM6IFtcbiAgICAgICAgUG9seW1lci5BcHBMYXlvdXRCZWhhdmlvclxuICAgICAgXSxcblxuICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgdHJ1ZSwgaWdub3JlIGByZXNwb25zaXZlV2lkdGhgIHNldHRpbmcgYW5kIGZvcmNlIHRoZSBuYXJyb3cgbGF5b3V0LlxuICAgICAgICAgKi9cbiAgICAgICAgZm9yY2VOYXJyb3c6IHtcbiAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0aGUgdmlld3BvcnQncyB3aWR0aCBpcyBzbWFsbGVyIHRoYW4gdGhpcyB2YWx1ZSwgdGhlIHBhbmVsIHdpbGwgY2hhbmdlIHRvIG5hcnJvd1xuICAgICAgICAgKiBsYXlvdXQuIEluIHRoZSBtb2RlIHRoZSBkcmF3ZXIgd2lsbCBiZSBjbG9zZWQuXG4gICAgICAgICAqL1xuICAgICAgICByZXNwb25zaXZlV2lkdGg6IHtcbiAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgdmFsdWU6ICc2NDBweCdcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0cnVlIGlmIGl0IGlzIGluIG5hcnJvdyBsYXlvdXQuIFRoaXMgaXMgdXNlZnVsIGlmIHlvdSBuZWVkIHRvIHNob3cvaGlkZVxuICAgICAgICAgKiBlbGVtZW50cyBiYXNlZCBvbiB0aGUgbGF5b3V0LlxuICAgICAgICAgKi9cbiAgICAgICAgbmFycm93OiB7XG4gICAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgICByZWZsZWN0VG9BdHRyaWJ1dGU6IHRydWUsXG4gICAgICAgICAgcmVhZE9ubHk6IHRydWUsXG4gICAgICAgICAgbm90aWZ5OiB0cnVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHRydWUsIHRoZSBkcmF3ZXIgd2lsbCBpbml0aWFsbHkgYmUgb3BlbmVkIHdoZW4gaW4gbmFycm93IGxheW91dCBtb2RlLlxuICAgICAgICAgKi9cbiAgICAgICAgb3BlbmVkV2hlbk5hcnJvdzoge1xuICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgIH0sXG5cbiAgICAgICAgX2RyYXdlclBvc2l0aW9uOiB7XG4gICAgICAgICAgdHlwZTogU3RyaW5nXG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIGxpc3RlbmVyczoge1xuICAgICAgICAnY2xpY2snOiAnX2NsaWNrSGFuZGxlcidcbiAgICAgIH0sXG5cbiAgICAgIG9ic2VydmVyczogW1xuICAgICAgICAnX25hcnJvd0NoYW5nZWQobmFycm93KSdcbiAgICAgIF0sXG5cbiAgICAgIC8qKlxuICAgICAgICogQSByZWZlcmVuY2UgdG8gdGhlIGFwcC1kcmF3ZXIgZWxlbWVudC5cbiAgICAgICAqXG4gICAgICAgKiBAcHJvcGVydHkgZHJhd2VyXG4gICAgICAgKi9cbiAgICAgIGdldCBkcmF3ZXIoKSB7XG4gICAgICAgIHJldHVybiBQb2x5bWVyLmRvbSh0aGlzLiQuZHJhd2VyU2xvdCkuZ2V0RGlzdHJpYnV0ZWROb2RlcygpWzBdO1xuICAgICAgfSxcblxuICAgICAgYXR0YWNoZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBEaXNhYmxlIGRyYXdlciB0cmFuc2l0aW9ucyB1bnRpbCBhZnRlciBhcHAtZHJhd2VyLWxheW91dCBzZXRzIHRoZSBpbml0aWFsIG9wZW5lZCBzdGF0ZS5cbiAgICAgICAgdmFyIGRyYXdlciA9IHRoaXMuZHJhd2VyO1xuICAgICAgICBpZiAoZHJhd2VyKSB7XG4gICAgICAgICAgZHJhd2VyLnNldEF0dHJpYnV0ZSgnbm8tdHJhbnNpdGlvbicsICcnKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgX2NsaWNrSGFuZGxlcjogZnVuY3Rpb24oZSkge1xuICAgICAgICB2YXIgdGFyZ2V0ID0gUG9seW1lci5kb20oZSkubG9jYWxUYXJnZXQ7XG4gICAgICAgIGlmICh0YXJnZXQgJiYgdGFyZ2V0Lmhhc0F0dHJpYnV0ZSgnZHJhd2VyLXRvZ2dsZScpKSB7XG4gICAgICAgICAgdmFyIGRyYXdlciA9IHRoaXMuZHJhd2VyO1xuICAgICAgICAgIGlmIChkcmF3ZXIgJiYgIWRyYXdlci5wZXJzaXN0ZW50KSB7XG4gICAgICAgICAgICBkcmF3ZXIudG9nZ2xlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBfdXBkYXRlTGF5b3V0U3RhdGVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGRyYXdlciA9IHRoaXMuZHJhd2VyO1xuICAgICAgICBpZiAoIXRoaXMuaXNBdHRhY2hlZCB8fCAhZHJhd2VyKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZHJhd2VyUG9zaXRpb24gPSB0aGlzLm5hcnJvdyA/IG51bGwgOiBkcmF3ZXIucG9zaXRpb247XG4gICAgICAgIGlmICh0aGlzLl9kcmF3ZXJOZWVkc1Jlc2V0KSB7XG4gICAgICAgICAgaWYgKHRoaXMubmFycm93KSB7XG4gICAgICAgICAgICBkcmF3ZXIub3BlbmVkID0gdGhpcy5vcGVuZWRXaGVuTmFycm93O1xuICAgICAgICAgICAgZHJhd2VyLnBlcnNpc3RlbnQgPSBmYWxzZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZHJhd2VyLm9wZW5lZCA9IGRyYXdlci5wZXJzaXN0ZW50ID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGRyYXdlci5oYXNBdHRyaWJ1dGUoJ25vLXRyYW5zaXRpb24nKSkge1xuICAgICAgICAgICAgLy8gRW5hYmxlIGRyYXdlciB0cmFuc2l0aW9ucyBhZnRlciBhcHAtZHJhd2VyLWxheW91dCBzZXRzIHRoZSBpbml0aWFsIG9wZW5lZCBzdGF0ZS5cbiAgICAgICAgICAgIFBvbHltZXIuUmVuZGVyU3RhdHVzLmFmdGVyTmV4dFJlbmRlcih0aGlzLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgZHJhd2VyLnJlbW92ZUF0dHJpYnV0ZSgnbm8tdHJhbnNpdGlvbicpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX2RyYXdlck5lZWRzUmVzZXQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgX25hcnJvd0NoYW5nZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9kcmF3ZXJOZWVkc1Jlc2V0ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5yZXNldExheW91dCgpO1xuICAgICAgfSxcblxuICAgICAgX29uUXVlcnlNYXRjaGVzQ2hhbmdlZDogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgdGhpcy5fc2V0TmFycm93KGV2ZW50LmRldGFpbC52YWx1ZSk7XG4gICAgICB9LFxuXG4gICAgICBfY29tcHV0ZU1lZGlhUXVlcnk6IGZ1bmN0aW9uKGZvcmNlTmFycm93LCByZXNwb25zaXZlV2lkdGgpIHtcbiAgICAgICAgcmV0dXJuIGZvcmNlTmFycm93ID8gJyhtaW4td2lkdGg6IDBweCknIDogJyhtYXgtd2lkdGg6ICcgKyByZXNwb25zaXZlV2lkdGggKyAnKSc7XG4gICAgICB9XG4gICAgfSk7XG4gIDwvc2NyaXB0PlxuPC9kb20tbW9kdWxlPlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9hcHAtbGF5b3V0L2FwcC1kcmF3ZXItbGF5b3V0L2FwcC1kcmF3ZXItbGF5b3V0Lmh0bWwiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE1IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi9wb2x5bWVyL3BvbHltZXIuaHRtbFwiPlxuXG48IS0tXG5gaXJvbi1tZWRpYS1xdWVyeWAgY2FuIGJlIHVzZWQgdG8gZGF0YSBiaW5kIHRvIGEgQ1NTIG1lZGlhIHF1ZXJ5LlxuVGhlIGBxdWVyeWAgcHJvcGVydHkgaXMgYSBiYXJlIENTUyBtZWRpYSBxdWVyeS5cblRoZSBgcXVlcnktbWF0Y2hlc2AgcHJvcGVydHkgaXMgYSBib29sZWFuIHJlcHJlc2VudGluZyB3aGV0aGVyIHRoZSBwYWdlIG1hdGNoZXMgdGhhdCBtZWRpYSBxdWVyeS5cblxuRXhhbXBsZTpcblxuICAgIDxpcm9uLW1lZGlhLXF1ZXJ5IHF1ZXJ5PVwiKG1pbi13aWR0aDogNjAwcHgpXCIgcXVlcnktbWF0Y2hlcz1cInt7cXVlcnlNYXRjaGVzfX1cIj48L2lyb24tbWVkaWEtcXVlcnk+XG5cbkBncm91cCBJcm9uIEVsZW1lbnRzXG5AZGVtbyBkZW1vL2luZGV4Lmh0bWxcbkBoZXJvIGhlcm8uc3ZnXG5AZWxlbWVudCBpcm9uLW1lZGlhLXF1ZXJ5XG4tLT5cblxuPHNjcmlwdD5cblxuICBQb2x5bWVyKHtcblxuICAgIGlzOiAnaXJvbi1tZWRpYS1xdWVyeScsXG5cbiAgICBwcm9wZXJ0aWVzOiB7XG5cbiAgICAgIC8qKlxuICAgICAgICogVGhlIEJvb2xlYW4gcmV0dXJuIHZhbHVlIG9mIHRoZSBtZWRpYSBxdWVyeS5cbiAgICAgICAqL1xuICAgICAgcXVlcnlNYXRjaGVzOiB7XG4gICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgIHZhbHVlOiBmYWxzZSxcbiAgICAgICAgcmVhZE9ubHk6IHRydWUsXG4gICAgICAgIG5vdGlmeTogdHJ1ZVxuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBUaGUgQ1NTIG1lZGlhIHF1ZXJ5IHRvIGV2YWx1YXRlLlxuICAgICAgICovXG4gICAgICBxdWVyeToge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIG9ic2VydmVyOiAncXVlcnlDaGFuZ2VkJ1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBJZiB0cnVlLCB0aGUgcXVlcnkgYXR0cmlidXRlIGlzIGFzc3VtZWQgdG8gYmUgYSBjb21wbGV0ZSBtZWRpYSBxdWVyeVxuICAgICAgICogc3RyaW5nIHJhdGhlciB0aGFuIGEgc2luZ2xlIG1lZGlhIGZlYXR1cmUuXG4gICAgICAgKi9cbiAgICAgIGZ1bGw6IHtcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIEB0eXBlIHtmdW5jdGlvbihNZWRpYVF1ZXJ5TGlzdCl9XG4gICAgICAgKi9cbiAgICAgIF9ib3VuZE1RSGFuZGxlcjoge1xuICAgICAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucXVlcnlIYW5kbGVyLmJpbmQodGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogQHR5cGUge01lZGlhUXVlcnlMaXN0fVxuICAgICAgICovXG4gICAgICBfbXE6IHtcbiAgICAgICAgdmFsdWU6IG51bGxcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgYXR0YWNoZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgdGhpcy5xdWVyeUNoYW5nZWQoKTtcbiAgICB9LFxuXG4gICAgZGV0YWNoZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fcmVtb3ZlKCk7XG4gICAgfSxcblxuICAgIF9hZGQ6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuX21xKSB7XG4gICAgICAgIHRoaXMuX21xLmFkZExpc3RlbmVyKHRoaXMuX2JvdW5kTVFIYW5kbGVyKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgX3JlbW92ZTogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5fbXEpIHtcbiAgICAgICAgdGhpcy5fbXEucmVtb3ZlTGlzdGVuZXIodGhpcy5fYm91bmRNUUhhbmRsZXIpO1xuICAgICAgfVxuICAgICAgdGhpcy5fbXEgPSBudWxsO1xuICAgIH0sXG5cbiAgICBxdWVyeUNoYW5nZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fcmVtb3ZlKCk7XG4gICAgICB2YXIgcXVlcnkgPSB0aGlzLnF1ZXJ5O1xuICAgICAgaWYgKCFxdWVyeSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuZnVsbCAmJiBxdWVyeVswXSAhPT0gJygnKSB7XG4gICAgICAgIHF1ZXJ5ID0gJygnICsgcXVlcnkgKyAnKSc7XG4gICAgICB9XG4gICAgICB0aGlzLl9tcSA9IHdpbmRvdy5tYXRjaE1lZGlhKHF1ZXJ5KTtcbiAgICAgIHRoaXMuX2FkZCgpO1xuICAgICAgdGhpcy5xdWVyeUhhbmRsZXIodGhpcy5fbXEpO1xuICAgIH0sXG5cbiAgICBxdWVyeUhhbmRsZXI6IGZ1bmN0aW9uKG1xKSB7XG4gICAgICB0aGlzLl9zZXRRdWVyeU1hdGNoZXMobXEubWF0Y2hlcyk7XG4gICAgfVxuXG4gIH0pO1xuXG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvaXJvbi1tZWRpYS1xdWVyeS9pcm9uLW1lZGlhLXF1ZXJ5Lmh0bWwiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE1IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi8uLi9wb2x5bWVyL3BvbHltZXIuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uLy4uL2lyb24tZmxleC1sYXlvdXQvaXJvbi1mbGV4LWxheW91dC5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vYXBwLXNjcm9sbC1lZmZlY3RzL2FwcC1zY3JvbGwtZWZmZWN0cy1iZWhhdmlvci5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vYXBwLWxheW91dC1iZWhhdmlvci9hcHAtbGF5b3V0LWJlaGF2aW9yLmh0bWxcIj5cblxuPCEtLVxuYXBwLWhlYWRlciBpcyBjb250YWluZXIgZWxlbWVudCBmb3IgYXBwLXRvb2xiYXJzIGF0IHRoZSB0b3Agb2YgdGhlIHNjcmVlbiB0aGF0IGNhbiBoYXZlIHNjcm9sbFxuZWZmZWN0cy4gQnkgZGVmYXVsdCwgYW4gYXBwLWhlYWRlciBtb3ZlcyBhd2F5IGZyb20gdGhlIHZpZXdwb3J0IHdoZW4gc2Nyb2xsaW5nIGRvd24gYW5kXG5pZiB1c2luZyBgcmV2ZWFsc2AsIHRoZSBoZWFkZXIgc2xpZGVzIGJhY2sgd2hlbiBzY3JvbGxpbmcgYmFjayB1cC4gRm9yIGV4YW1wbGU6XG5cbmBgYGh0bWxcbjxhcHAtaGVhZGVyIHJldmVhbHM+XG4gIDxhcHAtdG9vbGJhcj5cbiAgICA8ZGl2IG1haW4tdGl0bGU+QXBwIG5hbWU8L2Rpdj5cbiAgPC9hcHAtdG9vbGJhcj5cbjwvYXBwLWhlYWRlcj5cbmBgYFxuXG5hcHAtaGVhZGVyIGNhbiBhbHNvIGNvbmRlbnNlIHdoZW4gc2Nyb2xsaW5nIGRvd24uIFRvIGFjaGlldmUgdGhpcyBiZWhhdmlvciwgdGhlIGhlYWRlclxubXVzdCBoYXZlIGEgbGFyZ2VyIGhlaWdodCB0aGFuIHRoZSBgc3RpY2t5YCBlbGVtZW50IGluIHRoZSBsaWdodCBET00uIEZvciBleGFtcGxlOlxuXG5gYGBodG1sXG48YXBwLWhlYWRlciBzdHlsZT1cImhlaWdodDogOTZweDtcIiBjb25kZW5zZXMgZml4ZWQ+XG4gIDxhcHAtdG9vbGJhciBzdHlsZT1cImhlaWdodDogNjRweDtcIj5cbiAgICA8ZGl2IG1haW4tdGl0bGU+QXBwIG5hbWU8L2Rpdj5cbiAgPC9hcHAtdG9vbGJhcj5cbjwvYXBwLWhlYWRlcj5cbmBgYFxuXG5JbiB0aGlzIGNhc2UgdGhlIGhlYWRlciBpcyBpbml0aWFsbHkgYDk2cHhgIHRhbGwsIGFuZCBpdCBzaHJpbmtzIHRvIGA2NHB4YCB3aGVuIHNjcm9sbGluZyBkb3duLlxuVGhhdCBpcyB3aGF0IGlzIG1lYW50IGJ5IFwiY29uZGVuc2luZ1wiLlxuXG4jIyMgU3RpY2t5IGVsZW1lbnRcblxuVGhlIGVsZW1lbnQgdGhhdCBpcyBwb3NpdGlvbmVkIGZpeGVkIHRvIHRvcCBvZiB0aGUgaGVhZGVyJ3MgYHNjcm9sbFRhcmdldGAgd2hlbiBhIHRocmVzaG9sZFxuaXMgcmVhY2hlZCwgc2ltaWxhciB0byBgcG9zaXRpb246IHN0aWNreWAgaW4gQ1NTLiBUaGlzIGVsZW1lbnQgKiptdXN0KiogYmUgYW4gaW1tZWRpYXRlXG5jaGlsZCBvZiBhcHAtaGVhZGVyLiBCeSBkZWZhdWx0LCB0aGUgYHN0aWNreWAgZWxlbWVudCBpcyB0aGUgZmlyc3QgYGFwcC10b29sYmFyIHRoYXRcbmlzIGFuIGltbWVkaWF0ZSBjaGlsZCBvZiBhcHAtaGVhZGVyLlxuXG5gYGBodG1sXG48YXBwLWhlYWRlciBjb25kZW5zZXM+XG4gIDxhcHAtdG9vbGJhcj4gU3RpY2t5IGVsZW1lbnQgPC9hcHAtdG9vbGJhcj5cbjwvYXBwLWhlYWRlcj5cbmBgYFxuXG4jIyMjIEN1c3RvbWl6aW5nIHRoZSBzdGlja3kgZWxlbWVudFxuXG5gYGBodG1sXG48YXBwLWhlYWRlciBjb25kZW5zZXM+XG4gIDxhcHAtdG9vbGJhcj48L2FwcC10b29sYmFyPlxuICA8YXBwLXRvb2xiYXIgc3RpY2t5PiBTdGlja3kgZWxlbWVudCA8L2FwcC10b29sYmFyPlxuPC9hcHAtaGVhZGVyPlxuYGBgXG5cbiMjIyBTY3JvbGwgdGFyZ2V0XG5cblRoZSBhcHAtaGVhZGVyJ3MgYHNjcm9sbFRhcmdldGAgcHJvcGVydHkgYWxsb3dzIHRvIGN1c3RvbWl6ZSB0aGUgc2Nyb2xsYWJsZSBlbGVtZW50IHRvIHdoaWNoXG50aGUgaGVhZGVyIHJlc3BvbmRzIHdoZW4gdGhlIHVzZXIgc2Nyb2xscy4gQnkgZGVmYXVsdCwgYXBwLWhlYWRlciB1c2VzIHRoZSBkb2N1bWVudCBhc1xudGhlIHNjcm9sbCB0YXJnZXQsIGJ1dCB5b3UgY2FuIGN1c3RvbWl6ZSB0aGlzIHByb3BlcnR5IGJ5IHNldHRpbmcgdGhlIGlkIG9mIHRoZSBlbGVtZW50LCBlLmcuXG5cbmBgYGh0bWxcbjxkaXYgaWQ9XCJzY3JvbGxpbmdSZWdpb25cIiBzdHlsZT1cIm92ZXJmbG93LXk6IGF1dG87XCI+XG4gIDxhcHAtaGVhZGVyIHNjcm9sbC10YXJnZXQ9XCJzY3JvbGxpbmdSZWdpb25cIj5cbiAgPC9hcHAtaGVhZGVyPlxuPC9kaXY+XG5gYGBcblxuSW4gdGhpcyBjYXNlLCB0aGUgYHNjcm9sbFRhcmdldGAgcHJvcGVydHkgcG9pbnRzIHRvIHRoZSBvdXRlciBkaXYgZWxlbWVudC4gQWx0ZXJuYXRpdmVseSxcbnlvdSBjYW4gc2V0IHRoaXMgcHJvcGVydHkgcHJvZ3JhbW1hdGljYWxseTpcblxuYGBganNcbmFwcEhlYWRlci5zY3JvbGxUYXJnZXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI3Njcm9sbGluZ1JlZ2lvblwiKTtcbmBgYFxuXG4jIyBCYWNrZ3JvdW5kc1xuYXBwLWhlYWRlciBoYXMgdHdvIGJhY2tncm91bmQgbGF5ZXJzIHRoYXQgY2FuIGJlIHVzZWQgZm9yIHN0eWxpbmcgd2hlbiB0aGUgaGVhZGVyIGlzIGNvbmRlbnNlZFxub3Igd2hlbiB0aGUgc2Nyb2xsYWJsZSBlbGVtZW50IGlzIHNjcm9sbGVkIHRvIHRoZSB0b3AuXG5cbiMjIFNjcm9sbCBlZmZlY3RzXG5cblNjcm9sbCBlZmZlY3RzIGFyZSBfb3B0aW9uYWxfIHZpc3VhbCBlZmZlY3RzIGFwcGxpZWQgaW4gYXBwLWhlYWRlciBiYXNlZCBvbiBzY3JvbGwgcG9zaXRpb24uIEZvciBleGFtcGxlLFxuVGhlIFtNYXRlcmlhbCBEZXNpZ24gc2Nyb2xsaW5nIHRlY2huaXF1ZXNdKGh0dHBzOi8vd3d3Lmdvb2dsZS5jb20vZGVzaWduL3NwZWMvcGF0dGVybnMvc2Nyb2xsaW5nLXRlY2huaXF1ZXMuaHRtbClcbnJlY29tbWVuZHMgZWZmZWN0cyB0aGF0IGNhbiBiZSBpbnN0YWxsZWQgdmlhIHRoZSBgZWZmZWN0c2AgcHJvcGVydHkuIGUuZy5cblxuYGBgaHRtbFxuPGFwcC1oZWFkZXIgZWZmZWN0cz1cIndhdGVyZmFsbFwiPlxuICA8YXBwLXRvb2xiYXI+QXBwIG5hbWU8L2FwcC10b29sYmFyPlxuPC9hcHAtaGVhZGVyPlxuYGBgXG5cbiMjIyMgSW1wb3J0aW5nIHRoZSBlZmZlY3RzXG5cblRvIHVzZSB0aGUgc2Nyb2xsIGVmZmVjdHMsIHlvdSBtdXN0IGV4cGxpY2l0bHkgaW1wb3J0IHRoZW0gaW4gYWRkaXRpb24gdG8gYGFwcC1oZWFkZXJgOlxuXG5gYGBodG1sXG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiL2Jvd2VyX2NvbXBvbmVudHMvYXBwLWxheW91dC9hcHAtc2Nyb2xsLWVmZmVjdHMvYXBwLXNjcm9sbC1lZmZlY3RzLmh0bWxcIj5cbmBgYFxuXG4jIyMjIExpc3Qgb2YgZWZmZWN0c1xuXG4qICoqYmxlbmQtYmFja2dyb3VuZCoqXG5GYWRlcyBpbi9vdXQgdHdvIGJhY2tncm91bmQgZWxlbWVudHMgYnkgYXBwbHlpbmcgQ1NTIG9wYWNpdHkgYmFzZWQgb24gc2Nyb2xsIHBvc2l0aW9uLlxuWW91IGNhbiB1c2UgdGhpcyBlZmZlY3QgdG8gc21vb3RobHkgY2hhbmdlIHRoZSBiYWNrZ3JvdW5kIGNvbG9yIG9yIGltYWdlIG9mIHRoZSBoZWFkZXIuXG5Gb3IgZXhhbXBsZSwgdXNpbmcgdGhlIG1peGluIGAtLWFwcC1oZWFkZXItYmFja2dyb3VuZC1yZWFyLWxheWVyYCBsZXRzIHlvdSBhc3NpZ24gYSBkaWZmZXJlbnRcbmJhY2tncm91bmQgd2hlbiB0aGUgaGVhZGVyIGlzIGNvbmRlbnNlZDpcblxuYGBgY3NzXG5hcHAtaGVhZGVyIHtcbiAgYmFja2dyb3VuZC1jb2xvcjogcmVkO1xuICAtLWFwcC1oZWFkZXItYmFja2dyb3VuZC1yZWFyLWxheWVyOiB7XG4gICAgLyogVGhlIGhlYWRlciBpcyBibHVlIHdoZW4gY29uZGVuc2VkICovXG4gICAgYmFja2dyb3VuZC1jb2xvcjogYmx1ZTtcbiAgfTtcbn1cbmBgYFxuXG4qICoqZmFkZS1iYWNrZ3JvdW5kKipcblVwb24gc2Nyb2xsaW5nIHBhc3QgYSB0aHJlc2hvbGQsIHRoaXMgZWZmZWN0IHdpbGwgdHJpZ2dlciBhbiBvcGFjaXR5IHRyYW5zaXRpb24gdG9cbmZhZGUgaW4vb3V0IHRoZSBiYWNrZ3JvdW5kcy4gQ29tcGFyZWQgdG8gdGhlIGBibGVuZC1iYWNrZ3JvdW5kYCBlZmZlY3QsXG50aGlzIGVmZmVjdCBkb2Vzbid0IGludGVycG9sYXRlIHRoZSBvcGFjaXR5IGJhc2VkIG9uIHNjcm9sbCBwb3NpdGlvbi5cblxuXG4qICoqcGFyYWxsYXgtYmFja2dyb3VuZCoqXG5BIHNpbXBsZSBwYXJhbGxheCBlZmZlY3QgdGhhdCB2ZXJ0aWNhbGx5IHRyYW5zbGF0ZXMgdGhlIGJhY2tncm91bmRzIGJhc2VkIG9uIGEgZnJhY3Rpb25cbm9mIHRoZSBzY3JvbGwgcG9zaXRpb24uIEZvciBleGFtcGxlOlxuXG5gYGBjc3NcbmFwcC1oZWFkZXIge1xuICAtLWFwcC1oZWFkZXItYmFja2dyb3VuZC1mcm9udC1sYXllcjoge1xuICAgIGJhY2tncm91bmQtaW1hZ2U6IHVybCguLi4pO1xuICB9O1xufVxuYGBgXG5gYGBodG1sXG48YXBwLWhlYWRlciBzdHlsZT1cImhlaWdodDogMzAwcHg7XCIgZWZmZWN0cz1cInBhcmFsbGF4LWJhY2tncm91bmRcIj5cbiAgPGFwcC10b29sYmFyPkFwcCBuYW1lPC9hcHAtdG9vbGJhcj5cbjwvYXBwLWhlYWRlcj5cbmBgYFxuXG5UaGUgZnJhY3Rpb24gZGV0ZXJtaW5lcyBob3cgZmFyIHRoZSBiYWNrZ3JvdW5kIG1vdmVzIHJlbGF0aXZlIHRvIHRoZSBzY3JvbGwgcG9zaXRpb24uXG5UaGlzIHZhbHVlIGNhbiBiZSBhc3NpZ25lZCB2aWEgdGhlIGBzY2FsYXJgIGNvbmZpZyB2YWx1ZSBhbmQgaXQgaXMgdHlwaWNhbGx5IGEgdmFsdWVcbmJldHdlZW4gMCBhbmQgMSBpbmNsdXNpdmUuIElmIGBzY2FsYXI9MGAsIHRoZSBiYWNrZ3JvdW5kIGRvZXNuJ3QgbW92ZSBhd2F5IGZyb20gdGhlIGhlYWRlci5cblxuKiAqKnJlc2l6ZS10aXRsZSoqXG5Qcm9ncmVzc2l2ZWx5IGludGVycG9sYXRlcyB0aGUgc2l6ZSBvZiB0aGUgdGl0bGUgZnJvbSB0aGUgZWxlbWVudCB3aXRoIHRoZSBgbWFpbi10aXRsZWAgYXR0cmlidXRlXG50byB0aGUgZWxlbWVudCB3aXRoIHRoZSBgY29uZGVuc2VkLXRpdGxlYCBhdHRyaWJ1dGUgYXMgdGhlIGhlYWRlciBjb25kZW5zZXMuIEZvciBleGFtcGxlOlxuXG5gYGBodG1sXG48YXBwLWhlYWRlciBjb25kZW5zZXMgcmV2ZWFscyBlZmZlY3RzPVwicmVzaXplLXRpdGxlXCI+XG4gIDxhcHAtdG9vbGJhcj5cbiAgICAgIDxoNCBjb25kZW5zZWQtdGl0bGU+QXBwIG5hbWU8L2g0PlxuICA8L2FwcC10b29sYmFyPlxuICA8YXBwLXRvb2xiYXI+XG4gICAgICA8aDEgbWFpbi10aXRsZT5BcHAgbmFtZTwvaDE+XG4gIDwvYXBwLXRvb2xiYXI+XG48L2FwcC1oZWFkZXI+XG5gYGBcblxuKiAqKnJlc2l6ZS1zbmFwcGVkLXRpdGxlKipcblVwb24gc2Nyb2xsaW5nIHBhc3QgYSB0aHJlc2hvbGQsIHRoaXMgZWZmZWN0IGZhZGVzIGluL291dCB0aGUgdGl0bGVzIHVzaW5nIG9wYWNpdHkgdHJhbnNpdGlvbnMuXG5TaW1pbGFybHkgdG8gYHJlc2l6ZS10aXRsZWAsIHRoZSBgbWFpbi10aXRsZWAgYW5kIGBjb25kZW5zZWQtdGl0bGVgIGVsZW1lbnRzIG11c3QgYmUgcGxhY2VkIGluIHRoZVxubGlnaHQgRE9NLlxuXG4qICoqd2F0ZXJmYWxsKipcblRvZ2dsZXMgdGhlIHNoYWRvdyBwcm9wZXJ0eSBpbiBhcHAtaGVhZGVyIHRvIGNyZWF0ZSBhIHNlbnNlIG9mIGRlcHRoIChhcyByZWNvbW1lbmRlZCBpbiB0aGVcbk1EIHNwZWMpIGJldHdlZW4gdGhlIGhlYWRlciBhbmQgdGhlIHVuZGVybmVhdGggY29udGVudC4gWW91IGNhbiBjaGFuZ2UgdGhlIHNoYWRvdyBieVxuY3VzdG9taXppbmcgdGhlIGAtLWFwcC1oZWFkZXItc2hhZG93YCBtaXhpbi4gRm9yIGV4YW1wbGU6XG5cbmBgYGNzc1xuYXBwLWhlYWRlciB7XG4gIC0tYXBwLWhlYWRlci1zaGFkb3c6IHtcbiAgICBib3gtc2hhZG93OiBpbnNldCAwcHggNXB4IDJweCAtM3B4IHJnYmEoMCwgMCwgMCwgMC4yKTtcbiAgfTtcbn1cbmBgYFxuXG5gYGBodG1sXG48YXBwLWhlYWRlciBjb25kZW5zZXMgcmV2ZWFscyBlZmZlY3RzPVwid2F0ZXJmYWxsXCI+XG4gIDxhcHAtdG9vbGJhcj5cbiAgICAgIDxoMSBtYWluLXRpdGxlPkFwcCBuYW1lPC9oMT5cbiAgPC9hcHAtdG9vbGJhcj5cbjwvYXBwLWhlYWRlcj5cbmBgYFxuXG4qICoqbWF0ZXJpYWwqKlxuSW5zdGFsbHMgdGhlIHdhdGVyZmFsbCwgcmVzaXplLXRpdGxlLCBibGVuZC1iYWNrZ3JvdW5kIGFuZCBwYXJhbGxheC1iYWNrZ3JvdW5kIGVmZmVjdHMuXG5cbiMjIyBDb250ZW50IGF0dHJpYnV0ZXNcblxuQXR0cmlidXRlIHwgRGVzY3JpcHRpb24gICAgICAgICB8IERlZmF1bHRcbi0tLS0tLS0tLS18LS0tLS0tLS0tLS0tLS0tLS0tLS0tfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmBzdGlja3lgIHwgRWxlbWVudCB0aGF0IHJlbWFpbnMgYXQgdGhlIHRvcCB3aGVuIHRoZSBoZWFkZXIgY29uZGVuc2VzLiB8IFRoZSBmaXJzdCBhcHAtdG9vbGJhciBpbiB0aGUgbGlnaHQgRE9NLlxuXG5cbiMjIFN0eWxpbmdcblxuTWl4aW4gfCBEZXNjcmlwdGlvbiB8IERlZmF1bHRcbi0tLS0tLXwtLS0tLS0tLS0tLS0tfC0tLS0tLS0tLS1cbmAtLWFwcC1oZWFkZXItYmFja2dyb3VuZC1mcm9udC1sYXllcmAgfCBBcHBsaWVzIHRvIHRoZSBmcm9udCBsYXllciBvZiB0aGUgYmFja2dyb3VuZC4gfCB7fVxuYC0tYXBwLWhlYWRlci1iYWNrZ3JvdW5kLXJlYXItbGF5ZXJgIHwgQXBwbGllcyB0byB0aGUgcmVhciBsYXllciBvZiB0aGUgYmFja2dyb3VuZC4gfCB7fVxuYC0tYXBwLWhlYWRlci1zaGFkb3dgIHwgQXBwbGllcyB0byB0aGUgc2hhZG93LiB8IHt9XG5cbkBncm91cCBBcHAgRWxlbWVudHNcbkBlbGVtZW50IGFwcC1oZWFkZXJcbkBkZW1vIGFwcC1oZWFkZXIvZGVtby9ibGVuZC1iYWNrZ3JvdW5kLTEuaHRtbCBCbGVuZCBCYWNrZ3JvdW5kIEltYWdlXG5AZGVtbyBhcHAtaGVhZGVyL2RlbW8vYmxlbmQtYmFja2dyb3VuZC0yLmh0bWwgQmxlbmQgMiBCYWNrZ3JvdW5kIEltYWdlc1xuQGRlbW8gYXBwLWhlYWRlci9kZW1vL2JsZW5kLWJhY2tncm91bmQtMy5odG1sIEJsZW5kIEJhY2tncm91bmQgQ29sb3JzXG5AZGVtbyBhcHAtaGVhZGVyL2RlbW8vY29udGFjdHMuaHRtbCBDb250YWN0cyBEZW1vXG5AZGVtbyBhcHAtaGVhZGVyL2RlbW8vZ2l2ZS5odG1sIFJlc2l6ZSBTbmFwcGVkIFRpdGxlIERlbW9cbkBkZW1vIGFwcC1oZWFkZXIvZGVtby9tdXNpYy5odG1sIFJldmVhbHMgRGVtb1xuQGRlbW8gYXBwLWhlYWRlci9kZW1vL25vLWVmZmVjdHMuaHRtbCBDb25kZW5zZXMgYW5kIFJldmVhbHMgRGVtb1xuQGRlbW8gYXBwLWhlYWRlci9kZW1vL25vdGVzLmh0bWwgRml4ZWQgd2l0aCBEeW5hbWljIFNoYWRvdyBEZW1vXG5AZGVtbyBhcHAtaGVhZGVyL2RlbW8vY3VzdG9tLXN0aWNreS1lbGVtZW50LTEuaHRtbCBDdXN0b20gU3RpY2t5IEVsZW1lbnQgRGVtbyAxXG5AZGVtbyBhcHAtaGVhZGVyL2RlbW8vY3VzdG9tLXN0aWNreS1lbGVtZW50LTIuaHRtbCBDdXN0b20gU3RpY2t5IEVsZW1lbnQgRGVtbyAyXG5cbi0tPlxuXG48ZG9tLW1vZHVsZSBpZD1cImFwcC1oZWFkZXJcIj5cbiAgPHRlbXBsYXRlPlxuICAgIDxzdHlsZT5cbiAgICAgIDpob3N0IHtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgICAgdHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb246IGxpbmVhcjtcbiAgICAgICAgdHJhbnNpdGlvbi1wcm9wZXJ0eTogLXdlYmtpdC10cmFuc2Zvcm07XG4gICAgICAgIHRyYW5zaXRpb24tcHJvcGVydHk6IHRyYW5zZm9ybTtcbiAgICAgIH1cblxuICAgICAgOmhvc3Q6OmJlZm9yZSB7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgcmlnaHQ6IDBweDtcbiAgICAgICAgYm90dG9tOiAtNXB4O1xuICAgICAgICBsZWZ0OiAwcHg7XG4gICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICBoZWlnaHQ6IDVweDtcbiAgICAgICAgY29udGVudDogXCJcIjtcbiAgICAgICAgdHJhbnNpdGlvbjogb3BhY2l0eSAwLjRzO1xuICAgICAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcbiAgICAgICAgb3BhY2l0eTogMDtcbiAgICAgICAgYm94LXNoYWRvdzogaW5zZXQgMHB4IDVweCA2cHggLTNweCByZ2JhKDAsIDAsIDAsIDAuNCk7XG4gICAgICAgIHdpbGwtY2hhbmdlOiBvcGFjaXR5O1xuICAgICAgICBAYXBwbHkgLS1hcHAtaGVhZGVyLXNoYWRvdztcbiAgICAgIH1cblxuICAgICAgOmhvc3QoW3NoYWRvd10pOjpiZWZvcmUge1xuICAgICAgICBvcGFjaXR5OiAxO1xuICAgICAgfVxuXG4gICAgICAjYmFja2dyb3VuZCB7XG4gICAgICAgIEBhcHBseSAtLWxheW91dC1maXQ7XG4gICAgICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgICB9XG5cbiAgICAgICNiYWNrZ3JvdW5kRnJvbnRMYXllcixcbiAgICAgICNiYWNrZ3JvdW5kUmVhckxheWVyIHtcbiAgICAgICAgQGFwcGx5IC0tbGF5b3V0LWZpdDtcbiAgICAgICAgaGVpZ2h0OiAxMDAlO1xuICAgICAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcbiAgICAgICAgYmFja2dyb3VuZC1zaXplOiBjb3ZlcjtcbiAgICAgIH1cblxuICAgICAgI2JhY2tncm91bmRGcm9udExheWVyIHtcbiAgICAgICAgQGFwcGx5IC0tYXBwLWhlYWRlci1iYWNrZ3JvdW5kLWZyb250LWxheWVyO1xuICAgICAgfVxuXG4gICAgICAjYmFja2dyb3VuZFJlYXJMYXllciB7XG4gICAgICAgIG9wYWNpdHk6IDA7XG4gICAgICAgIEBhcHBseSAtLWFwcC1oZWFkZXItYmFja2dyb3VuZC1yZWFyLWxheWVyO1xuICAgICAgfVxuXG4gICAgICAjY29udGVudENvbnRhaW5lciB7XG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgIGhlaWdodDogMTAwJTtcbiAgICAgIH1cblxuICAgICAgOmhvc3QoW2Rpc2FibGVkXSksXG4gICAgICA6aG9zdChbZGlzYWJsZWRdKTo6YWZ0ZXIsXG4gICAgICA6aG9zdChbZGlzYWJsZWRdKSAjYmFja2dyb3VuZEZyb250TGF5ZXIsXG4gICAgICA6aG9zdChbZGlzYWJsZWRdKSAjYmFja2dyb3VuZFJlYXJMYXllcixcbiAgICAgIC8qIFNpbGVudCBzY3JvbGxpbmcgc2hvdWxkIG5vdCBydW4gQ1NTIHRyYW5zaXRpb25zICovXG4gICAgICA6aG9zdChbc2lsZW50LXNjcm9sbF0pLFxuICAgICAgOmhvc3QoW3NpbGVudC1zY3JvbGxdKTo6YWZ0ZXIsXG4gICAgICA6aG9zdChbc2lsZW50LXNjcm9sbF0pICNiYWNrZ3JvdW5kRnJvbnRMYXllcixcbiAgICAgIDpob3N0KFtzaWxlbnQtc2Nyb2xsXSkgI2JhY2tncm91bmRSZWFyTGF5ZXIge1xuICAgICAgICB0cmFuc2l0aW9uOiBub25lICFpbXBvcnRhbnQ7XG4gICAgICB9XG5cbiAgICAgIDpob3N0KFtkaXNhYmxlZF0pIDo6c2xvdHRlZChhcHAtdG9vbGJhcjpmaXJzdC1vZi10eXBlKSxcbiAgICAgIDpob3N0KFtkaXNhYmxlZF0pIDo6c2xvdHRlZChbc3RpY2t5XSksXG4gICAgICAvKiBTaWxlbnQgc2Nyb2xsaW5nIHNob3VsZCBub3QgcnVuIENTUyB0cmFuc2l0aW9ucyAqL1xuICAgICAgOmhvc3QoW3NpbGVudC1zY3JvbGxdKSA6OnNsb3R0ZWQoYXBwLXRvb2xiYXI6Zmlyc3Qtb2YtdHlwZSksXG4gICAgICA6aG9zdChbc2lsZW50LXNjcm9sbF0pIDo6c2xvdHRlZChbc3RpY2t5XSkge1xuICAgICAgICB0cmFuc2l0aW9uOiBub25lICFpbXBvcnRhbnQ7XG4gICAgICB9XG5cbiAgICA8L3N0eWxlPlxuICAgIDxkaXYgaWQ9XCJjb250ZW50Q29udGFpbmVyXCI+XG4gICAgICA8c2xvdCBpZD1cInNsb3RcIj48L3Nsb3Q+XG4gICAgPC9kaXY+XG4gIDwvdGVtcGxhdGU+XG5cbiAgPHNjcmlwdD5cbiAgICBQb2x5bWVyKHtcbiAgICAgIGlzOiAnYXBwLWhlYWRlcicsXG5cbiAgICAgIGJlaGF2aW9yczogW1xuICAgICAgICBQb2x5bWVyLkFwcFNjcm9sbEVmZmVjdHNCZWhhdmlvcixcbiAgICAgICAgUG9seW1lci5BcHBMYXlvdXRCZWhhdmlvclxuICAgICAgXSxcblxuICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgdHJ1ZSwgdGhlIGhlYWRlciB3aWxsIGF1dG9tYXRpY2FsbHkgY29sbGFwc2Ugd2hlbiBzY3JvbGxpbmcgZG93bi5cbiAgICAgICAgICogVGhhdCBpcywgdGhlIGBzdGlja3lgIGVsZW1lbnQgcmVtYWlucyB2aXNpYmxlIHdoZW4gdGhlIGhlYWRlciBpcyBmdWxseSBjb25kZW5zZWRcbiAgICAgICAgICogd2hlcmVhcyB0aGUgcmVzdCBvZiB0aGUgZWxlbWVudHMgd2lsbCBjb2xsYXBzZSBiZWxvdyBgc3RpY2t5YCBlbGVtZW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBCeSBkZWZhdWx0LCB0aGUgYHN0aWNreWAgZWxlbWVudCBpcyB0aGUgZmlyc3QgdG9vbGJhciBpbiB0aGUgbGlnaHQgRE9NOlxuICAgICAgICAgKlxuICAgICAgICAgKmBgYGh0bWxcbiAgICAgICAgICogPGFwcC1oZWFkZXIgY29uZGVuc2VzPlxuICAgICAgICAgKiAgIDxhcHAtdG9vbGJhcj5UaGlzIHRvb2xiYXIgcmVtYWlucyBvbiB0b3A8L2FwcC10b29sYmFyPlxuICAgICAgICAgKiAgIDxhcHAtdG9vbGJhcj48L2FwcC10b29sYmFyPlxuICAgICAgICAgKiAgIDxhcHAtdG9vbGJhcj48L2FwcC10b29sYmFyPlxuICAgICAgICAgKiA8L2FwcC1oZWFkZXI+XG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKlxuICAgICAgICAgKiBBZGRpdGlvbmFsbHksIHlvdSBjYW4gc3BlY2lmeSB3aGljaCB0b29sYmFyIG9yIGVsZW1lbnQgcmVtYWlucyB2aXNpYmxlIGluIGNvbmRlbnNlZCBtb2RlXG4gICAgICAgICAqIGJ5IGFkZGluZyB0aGUgYHN0aWNreWAgYXR0cmlidXRlIHRvIHRoYXQgZWxlbWVudC4gRm9yIGV4YW1wbGU6IGlmIHdlIHdhbnQgdGhlIGxhc3RcbiAgICAgICAgICogdG9vbGJhciB0byByZW1haW4gdmlzaWJsZSwgd2UgY2FuIGFkZCB0aGUgYHN0aWNreWAgYXR0cmlidXRlIHRvIGl0LlxuICAgICAgICAgKlxuICAgICAgICAgKmBgYGh0bWxcbiAgICAgICAgICogPGFwcC1oZWFkZXIgY29uZGVuc2VzPlxuICAgICAgICAgKiAgIDxhcHAtdG9vbGJhcj48L2FwcC10b29sYmFyPlxuICAgICAgICAgKiAgIDxhcHAtdG9vbGJhcj48L2FwcC10b29sYmFyPlxuICAgICAgICAgKiAgIDxhcHAtdG9vbGJhciBzdGlja3k+VGhpcyB0b29sYmFyIHJlbWFpbnMgb24gdG9wPC9hcHAtdG9vbGJhcj5cbiAgICAgICAgICogPC9hcHAtaGVhZGVyPlxuICAgICAgICAgKiBgYGBcbiAgICAgICAgICpcbiAgICAgICAgICogTm90ZSB0aGUgYHN0aWNreWAgZWxlbWVudCBtdXN0IGJlIGEgZGlyZWN0IGNoaWxkIG9mIGBhcHAtaGVhZGVyYC5cbiAgICAgICAgICovXG4gICAgICAgIGNvbmRlbnNlczoge1xuICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1hbnRhaW5zIHRoZSBoZWFkZXIgZml4ZWQgYXQgdGhlIHRvcCBzbyBpdCBuZXZlciBtb3ZlcyBhd2F5LlxuICAgICAgICAgKi9cbiAgICAgICAgZml4ZWQ6IHtcbiAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTbGlkZXMgYmFjayB0aGUgaGVhZGVyIHdoZW4gc2Nyb2xsaW5nIGJhY2sgdXAuXG4gICAgICAgICAqL1xuICAgICAgICByZXZlYWxzOiB7XG4gICAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGlzcGxheXMgYSBzaGFkb3cgYmVsb3cgdGhlIGhlYWRlci5cbiAgICAgICAgICovXG4gICAgICAgIHNoYWRvdzoge1xuICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgICAgcmVmbGVjdFRvQXR0cmlidXRlOiB0cnVlLFxuICAgICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBvYnNlcnZlcnM6IFtcbiAgICAgICAgJ19jb25maWdDaGFuZ2VkKGlzQXR0YWNoZWQsIGNvbmRlbnNlcywgZml4ZWQpJ1xuICAgICAgXSxcblxuICAgICAgLyoqXG4gICAgICAgKiBBIGNhY2hlZCBvZmZzZXRIZWlnaHQgb2YgdGhlIGN1cnJlbnQgZWxlbWVudC5cbiAgICAgICAqXG4gICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICovXG4gICAgICBfaGVpZ2h0OiAwLFxuXG4gICAgICAvKipcbiAgICAgICAqIFRoZSBkaXN0YW5jZSBpbiBwaXhlbHMgdGhlIGhlYWRlciB3aWxsIGJlIHRyYW5zbGF0ZWQgdG8gd2hlbiBzY3JvbGxpbmcuXG4gICAgICAgKlxuICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAqL1xuICAgICAgX2RIZWlnaHQ6IDAsXG5cbiAgICAgIC8qKlxuICAgICAgICogVGhlIG9mZnNldFRvcCBvZiBgX3N0aWNreUVsYFxuICAgICAgICpcbiAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgKi9cbiAgICAgIF9zdGlja3lFbFRvcDogMCxcblxuICAgICAgLyoqXG4gICAgICAgKiBBIHJlZmVyZW5jZSB0byB0aGUgZWxlbWVudCB0aGF0IHJlbWFpbnMgdmlzaWJsZSB3aGVuIHRoZSBoZWFkZXIgY29uZGVuc2VzLlxuICAgICAgICpcbiAgICAgICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICAgICAqL1xuICAgICAgX3N0aWNreUVsUmVmOiBudWxsLFxuXG4gICAgICAvKipcbiAgICAgICAqIFRoZSBoZWFkZXIncyB0b3AgdmFsdWUgdXNlZCBmb3IgdGhlIGB0cmFuc2Zvcm1ZYFxuICAgICAgICpcbiAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgKi9cbiAgICAgIF90b3A6IDAsXG5cbiAgICAgIC8qKlxuICAgICAgICogVGhlIGN1cnJlbnQgc2Nyb2xsIHByb2dyZXNzLlxuICAgICAgICpcbiAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgKi9cbiAgICAgIF9wcm9ncmVzczogMCxcblxuICAgICAgX3dhc1Njcm9sbGluZ0Rvd246IGZhbHNlLFxuICAgICAgX2luaXRTY3JvbGxUb3A6IDAsXG4gICAgICBfaW5pdFRpbWVzdGFtcDogMCxcbiAgICAgIF9sYXN0VGltZXN0YW1wOiAwLFxuICAgICAgX2xhc3RTY3JvbGxUb3A6IDAsXG5cbiAgICAgIC8qKlxuICAgICAgICogVGhlIGRpc3RhbmNlIHRoZSBoZWFkZXIgaXMgYWxsb3dlZCB0byBtb3ZlIGF3YXkuXG4gICAgICAgKlxuICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAqL1xuICAgICAgZ2V0IF9tYXhIZWFkZXJUb3AoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpeGVkID8gdGhpcy5fZEhlaWdodCA6IHRoaXMuX2hlaWdodCArIDU7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFJldHVybnMgYSByZWZlcmVuY2UgdG8gdGhlIHN0aWNreSBlbGVtZW50LlxuICAgICAgICpcbiAgICAgICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fT9cbiAgICAgICAqL1xuICAgICAgZ2V0IF9zdGlja3lFbCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3N0aWNreUVsUmVmKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3N0aWNreUVsUmVmO1xuICAgICAgICB9XG4gICAgICAgIHZhciBub2RlcyA9IFBvbHltZXIuZG9tKHRoaXMuJC5zbG90KS5nZXREaXN0cmlidXRlZE5vZGVzKCk7XG4gICAgICAgIC8vIEdldCB0aGUgZWxlbWVudCB3aXRoIHRoZSBzdGlja3kgYXR0cmlidXRlIG9uIGl0IG9yIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBsaWdodCBET00uXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBub2RlOyBub2RlID0gbm9kZXNbaV07IGkrKykge1xuICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgaWYgKG5vZGUuaGFzQXR0cmlidXRlKCdzdGlja3knKSkge1xuICAgICAgICAgICAgICB0aGlzLl9zdGlja3lFbFJlZiA9IG5vZGU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghdGhpcy5fc3RpY2t5RWxSZWYpIHtcbiAgICAgICAgICAgICAgdGhpcy5fc3RpY2t5RWxSZWYgPSBub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fc3RpY2t5RWxSZWY7XG4gICAgICB9LFxuXG4gICAgICBfY29uZmlnQ2hhbmdlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMucmVzZXRMYXlvdXQoKTtcbiAgICAgICAgdGhpcy5fbm90aWZ5TGF5b3V0Q2hhbmdlZCgpO1xuICAgICAgfSxcblxuICAgICAgX3VwZGF0ZUxheW91dFN0YXRlczogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLm9mZnNldFdpZHRoID09PSAwICYmIHRoaXMub2Zmc2V0SGVpZ2h0ID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzY3JvbGxUb3AgPSB0aGlzLl9jbGFtcGVkU2Nyb2xsVG9wO1xuICAgICAgICB2YXIgZmlyc3RTZXR1cCA9IHRoaXMuX2hlaWdodCA9PT0gMCB8fCBzY3JvbGxUb3AgPT09IDA7XG4gICAgICAgIHZhciBjdXJyZW50RGlzYWJsZWQgPSB0aGlzLmRpc2FibGVkO1xuICAgICAgICB0aGlzLl9oZWlnaHQgPSB0aGlzLm9mZnNldEhlaWdodDtcbiAgICAgICAgdGhpcy5fc3RpY2t5RWxSZWYgPSBudWxsO1xuICAgICAgICB0aGlzLmRpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgLy8gcHJlcGFyZSBmb3IgbWVhc3VyZW1lbnRcbiAgICAgICAgaWYgICghZmlyc3RTZXR1cCkge1xuICAgICAgICAgIHRoaXMuX3VwZGF0ZVNjcm9sbFN0YXRlKDAsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9tYXlNb3ZlKCkpIHtcbiAgICAgICAgICB0aGlzLl9kSGVpZ2h0ID0gdGhpcy5fc3RpY2t5RWwgPyB0aGlzLl9oZWlnaHQgLSB0aGlzLl9zdGlja3lFbC5vZmZzZXRIZWlnaHQgOiAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX2RIZWlnaHQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3N0aWNreUVsVG9wID0gdGhpcy5fc3RpY2t5RWwgPyB0aGlzLl9zdGlja3lFbC5vZmZzZXRUb3AgOiAwO1xuICAgICAgICB0aGlzLl9zZXRVcEVmZmVjdCgpO1xuICAgICAgICBpZiAoZmlyc3RTZXR1cCkge1xuICAgICAgICAgIHRoaXMuX3VwZGF0ZVNjcm9sbFN0YXRlKHNjcm9sbFRvcCwgdHJ1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fdXBkYXRlU2Nyb2xsU3RhdGUodGhpcy5fbGFzdFNjcm9sbFRvcCwgdHJ1ZSk7XG4gICAgICAgICAgdGhpcy5fbGF5b3V0SWZEaXJ0eSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlc3RvcmUgbm8gdHJhbnNpdGlvblxuICAgICAgICB0aGlzLmRpc2FibGVkID0gY3VycmVudERpc2FibGVkO1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBVcGRhdGVzIHRoZSBzY3JvbGwgc3RhdGUuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHNjcm9sbFRvcFxuICAgICAgICogQHBhcmFtIHtib29sZWFuPX0gZm9yY2VVcGRhdGUgKGRlZmF1bHQ6IGZhbHNlKVxuICAgICAgICovXG4gICAgICBfdXBkYXRlU2Nyb2xsU3RhdGU6IGZ1bmN0aW9uKHNjcm9sbFRvcCwgZm9yY2VVcGRhdGUpIHtcbiAgICAgICAgaWYgKHRoaXMuX2hlaWdodCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJvZ3Jlc3MgPSAwO1xuICAgICAgICB2YXIgdG9wID0gMDtcbiAgICAgICAgdmFyIGxhc3RUb3AgPSB0aGlzLl90b3A7XG4gICAgICAgIHZhciBsYXN0U2Nyb2xsVG9wID0gdGhpcy5fbGFzdFNjcm9sbFRvcDtcbiAgICAgICAgdmFyIG1heEhlYWRlclRvcCA9IHRoaXMuX21heEhlYWRlclRvcDtcbiAgICAgICAgdmFyIGRTY3JvbGxUb3AgPSBzY3JvbGxUb3AgLSB0aGlzLl9sYXN0U2Nyb2xsVG9wO1xuICAgICAgICB2YXIgYWJzRFNjcm9sbFRvcCA9IE1hdGguYWJzKGRTY3JvbGxUb3ApO1xuICAgICAgICB2YXIgaXNTY3JvbGxpbmdEb3duID0gc2Nyb2xsVG9wID4gdGhpcy5fbGFzdFNjcm9sbFRvcDtcbiAgICAgICAgdmFyIG5vdyA9IHBlcmZvcm1hbmNlLm5vdygpO1xuXG4gICAgICAgIGlmICh0aGlzLl9tYXlNb3ZlKCkpIHtcbiAgICAgICAgICB0b3AgPSB0aGlzLl9jbGFtcCh0aGlzLnJldmVhbHMgPyBsYXN0VG9wICsgZFNjcm9sbFRvcCA6IHNjcm9sbFRvcCwgMCwgbWF4SGVhZGVyVG9wKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2Nyb2xsVG9wID49IHRoaXMuX2RIZWlnaHQpIHtcbiAgICAgICAgICB0b3AgPSB0aGlzLmNvbmRlbnNlcyAmJiAhdGhpcy5maXhlZCA/IE1hdGgubWF4KHRoaXMuX2RIZWlnaHQsIHRvcCkgOiB0b3A7XG4gICAgICAgICAgdGhpcy5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPSAnMG1zJztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5yZXZlYWxzICYmICF0aGlzLmRpc2FibGVkICYmIGFic0RTY3JvbGxUb3AgPCAxMDApIHtcbiAgICAgICAgICAvLyBzZXQgdGhlIGluaXRpYWwgc2Nyb2xsIHBvc2l0aW9uXG4gICAgICAgICAgaWYgKG5vdyAtIHRoaXMuX2luaXRUaW1lc3RhbXAgPiAzMDAgfHwgdGhpcy5fd2FzU2Nyb2xsaW5nRG93biAhPT0gaXNTY3JvbGxpbmdEb3duKSB7XG4gICAgICAgICAgICB0aGlzLl9pbml0U2Nyb2xsVG9wID0gc2Nyb2xsVG9wO1xuICAgICAgICAgICAgdGhpcy5faW5pdFRpbWVzdGFtcCA9IG5vdztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNjcm9sbFRvcCA+PSBtYXhIZWFkZXJUb3ApIHtcbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIHRoZSBoZWFkZXIgaXMgYWxsb3dlZCB0byBzbmFwXG4gICAgICAgICAgICBpZiAoTWF0aC5hYnModGhpcy5faW5pdFNjcm9sbFRvcCAtIHNjcm9sbFRvcCkgPiAzMCB8fCBhYnNEU2Nyb2xsVG9wID4gMTApIHtcbiAgICAgICAgICAgICAgaWYgKGlzU2Nyb2xsaW5nRG93biAmJiBzY3JvbGxUb3AgPj0gbWF4SGVhZGVyVG9wKSB7XG4gICAgICAgICAgICAgICAgdG9wID0gbWF4SGVhZGVyVG9wO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFpc1Njcm9sbGluZ0Rvd24gJiYgc2Nyb2xsVG9wID49IHRoaXMuX2RIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICB0b3AgPSB0aGlzLmNvbmRlbnNlcyAmJiAhdGhpcy5maXhlZCA/IHRoaXMuX2RIZWlnaHQgOiAwO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhciBzY3JvbGxWZWxvY2l0eSA9IGRTY3JvbGxUb3AgLyAobm93IC0gdGhpcy5fbGFzdFRpbWVzdGFtcCk7XG4gICAgICAgICAgICAgIHRoaXMuc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID0gdGhpcy5fY2xhbXAoKHRvcCAtIGxhc3RUb3ApIC8gc2Nyb2xsVmVsb2NpdHksIDAsIDMwMCkgKyAnbXMnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdG9wID0gdGhpcy5fdG9wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fZEhlaWdodCA9PT0gMCkge1xuICAgICAgICAgIHByb2dyZXNzID0gc2Nyb2xsVG9wID4gMCA/IDEgOiAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByb2dyZXNzID0gdG9wIC8gdGhpcy5fZEhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWZvcmNlVXBkYXRlKSB7XG4gICAgICAgICAgdGhpcy5fbGFzdFNjcm9sbFRvcCA9IHNjcm9sbFRvcDtcbiAgICAgICAgICB0aGlzLl90b3AgPSB0b3A7XG4gICAgICAgICAgdGhpcy5fd2FzU2Nyb2xsaW5nRG93biA9IGlzU2Nyb2xsaW5nRG93bjtcbiAgICAgICAgICB0aGlzLl9sYXN0VGltZXN0YW1wID0gbm93O1xuICAgICAgICB9XG4gICAgICAgIGlmIChmb3JjZVVwZGF0ZSB8fCBwcm9ncmVzcyAhPT0gdGhpcy5fcHJvZ3Jlc3MgfHwgbGFzdFRvcCAhPT0gdG9wIHx8IHNjcm9sbFRvcCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMuX3Byb2dyZXNzID0gcHJvZ3Jlc3M7XG4gICAgICAgICAgdGhpcy5fcnVuRWZmZWN0cyhwcm9ncmVzcywgdG9wKTtcbiAgICAgICAgICB0aGlzLl90cmFuc2Zvcm1IZWFkZXIodG9wKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGN1cnJlbnQgaGVhZGVyIGlzIGFsbG93ZWQgdG8gbW92ZSBhcyB0aGUgdXNlciBzY3JvbGxzLlxuICAgICAgICpcbiAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICAgKi9cbiAgICAgIF9tYXlNb3ZlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZGVuc2VzIHx8ICF0aGlzLmZpeGVkO1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGN1cnJlbnQgaGVhZGVyIHdpbGwgY29uZGVuc2UgYmFzZWQgb24gdGhlIHNpemUgb2YgdGhlIGhlYWRlclxuICAgICAgICogYW5kIHRoZSBgY29uc2Vuc2VzYCBwcm9wZXJ0eS5cbiAgICAgICAqXG4gICAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAgICovXG4gICAgICB3aWxsQ29uZGVuc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZEhlaWdodCA+IDAgJiYgdGhpcy5jb25kZW5zZXM7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgY3VycmVudCBlbGVtZW50IGlzIG9uIHRoZSBzY3JlZW4uXG4gICAgICAgKiBUaGF0IGlzLCB2aXNpYmxlIGluIHRoZSBjdXJyZW50IHZpZXdwb3J0LlxuICAgICAgICpcbiAgICAgICAqIEBtZXRob2QgaXNPblNjcmVlblxuICAgICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgICAqL1xuICAgICAgaXNPblNjcmVlbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oZWlnaHQgIT09IDAgJiYgdGhpcy5fdG9wIDwgdGhpcy5faGVpZ2h0O1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlcmUncyBjb250ZW50IGJlbG93IHRoZSBjdXJyZW50IGVsZW1lbnQuXG4gICAgICAgKlxuICAgICAgICogQG1ldGhvZCBpc0NvbnRlbnRCZWxvd1xuICAgICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgICAqL1xuICAgICAgaXNDb250ZW50QmVsb3c6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdG9wID09PSAwID8gdGhpcy5fY2xhbXBlZFNjcm9sbFRvcCA+IDAgOlxuICAgICAgICAgICAgdGhpcy5fY2xhbXBlZFNjcm9sbFRvcCAtIHRoaXMuX21heEhlYWRlclRvcCA+PSAwO1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBUcmFuc2Zvcm1zIHRoZSBoZWFkZXIuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgICAqL1xuICAgICAgX3RyYW5zZm9ybUhlYWRlcjogZnVuY3Rpb24oeSkge1xuICAgICAgICB0aGlzLnRyYW5zbGF0ZTNkKDAsICgteSkgKyAncHgnLCAwKTtcbiAgICAgICAgaWYgKHRoaXMuX3N0aWNreUVsKSB7XG4gICAgICAgICAgdGhpcy50cmFuc2xhdGUzZCgwLCB0aGlzLmNvbmRlbnNlcyAmJiB5ID49IHRoaXMuX3N0aWNreUVsVG9wID9cbiAgICAgICAgICAgICAgKE1hdGgubWluKHksIHRoaXMuX2RIZWlnaHQpIC0gdGhpcy5fc3RpY2t5RWxUb3ApICsgJ3B4JyA6IDAsICAwLCB0aGlzLl9zdGlja3lFbCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIF9jbGFtcDogZnVuY3Rpb24odiwgbWluLCBtYXgpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubWluKG1heCwgTWF0aC5tYXgobWluLCB2KSk7XG4gICAgICB9LFxuXG4gICAgICBfZW5zdXJlQmdDb250YWluZXJzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9iZ0NvbnRhaW5lcikge1xuICAgICAgICAgIHRoaXMuX2JnQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgdGhpcy5fYmdDb250YWluZXIuaWQgPSAnYmFja2dyb3VuZCc7XG4gICAgICAgICAgdGhpcy5fYmdSZWFyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgdGhpcy5fYmdSZWFyLmlkID0gJ2JhY2tncm91bmRSZWFyTGF5ZXInO1xuICAgICAgICAgIHRoaXMuX2JnQ29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuX2JnUmVhcik7XG4gICAgICAgICAgdGhpcy5fYmdGcm9udCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgIHRoaXMuX2JnRnJvbnQuaWQgPSAnYmFja2dyb3VuZEZyb250TGF5ZXInO1xuICAgICAgICAgIHRoaXMuX2JnQ29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuX2JnRnJvbnQpO1xuICAgICAgICAgIFBvbHltZXIuZG9tKHRoaXMucm9vdCkuaW5zZXJ0QmVmb3JlKHRoaXMuX2JnQ29udGFpbmVyLCB0aGlzLiQuY29udGVudENvbnRhaW5lcik7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIF9nZXRET01SZWY6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgIHN3aXRjaCAoaWQpIHtcbiAgICAgICAgICBjYXNlICdiYWNrZ3JvdW5kRnJvbnRMYXllcic6XG4gICAgICAgICAgICB0aGlzLl9lbnN1cmVCZ0NvbnRhaW5lcnMoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9iZ0Zyb250O1xuICAgICAgICAgIGNhc2UgJ2JhY2tncm91bmRSZWFyTGF5ZXInOlxuICAgICAgICAgICAgdGhpcy5fZW5zdXJlQmdDb250YWluZXJzKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYmdSZWFyO1xuICAgICAgICAgIGNhc2UgJ2JhY2tncm91bmQnOlxuICAgICAgICAgICAgdGhpcy5fZW5zdXJlQmdDb250YWluZXJzKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYmdDb250YWluZXI7XG4gICAgICAgICAgY2FzZSAnbWFpblRpdGxlJzpcbiAgICAgICAgICAgIHJldHVybiBQb2x5bWVyLmRvbSh0aGlzKS5xdWVyeVNlbGVjdG9yKCdbbWFpbi10aXRsZV0nKTtcbiAgICAgICAgICBjYXNlICdjb25kZW5zZWRUaXRsZSc6XG4gICAgICAgICAgICByZXR1cm4gUG9seW1lci5kb20odGhpcykucXVlcnlTZWxlY3RvcignW2NvbmRlbnNlZC10aXRsZV0nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogUmV0dXJucyBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgcHJvZ3Jlc3MgdmFsdWUgb2YgdGhlIHNjcm9sbCBlZmZlY3RzXG4gICAgICAgKiBhbmQgdGhlIHRvcCBwb3NpdGlvbiBvZiB0aGUgaGVhZGVyLlxuICAgICAgICpcbiAgICAgICAqIEBtZXRob2QgZ2V0U2Nyb2xsU3RhdGVcbiAgICAgICAqIEByZXR1cm4ge09iamVjdH1cbiAgICAgICAqL1xuICAgICAgZ2V0U2Nyb2xsU3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4geyBwcm9ncmVzczogdGhpcy5fcHJvZ3Jlc3MsIHRvcDogdGhpcy5fdG9wIH07XG4gICAgICB9XG4gICAgfSk7XG4gIDwvc2NyaXB0PlxuPC9kb20tbW9kdWxlPlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9hcHAtbGF5b3V0L2FwcC1oZWFkZXIvYXBwLWhlYWRlci5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNiBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuXG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vcG9seW1lci9wb2x5bWVyLmh0bWxcIj5cblxuPHNjcmlwdD5cblxuICAvKipcbiAgICogYFBvbHltZXIuSXJvblNjcm9sbFRhcmdldEJlaGF2aW9yYCBhbGxvd3MgYW4gZWxlbWVudCB0byByZXNwb25kIHRvIHNjcm9sbCBldmVudHMgZnJvbSBhXG4gICAqIGRlc2lnbmF0ZWQgc2Nyb2xsIHRhcmdldC5cbiAgICpcbiAgICogRWxlbWVudHMgdGhhdCBjb25zdW1lIHRoaXMgYmVoYXZpb3IgY2FuIG92ZXJyaWRlIHRoZSBgX3Njcm9sbEhhbmRsZXJgXG4gICAqIG1ldGhvZCB0byBhZGQgbG9naWMgb24gdGhlIHNjcm9sbCBldmVudC5cbiAgICpcbiAgICogQGRlbW8gZGVtby9zY3JvbGxpbmctcmVnaW9uLmh0bWwgU2Nyb2xsaW5nIFJlZ2lvblxuICAgKiBAZGVtbyBkZW1vL2RvY3VtZW50Lmh0bWwgRG9jdW1lbnQgRWxlbWVudFxuICAgKiBAcG9seW1lckJlaGF2aW9yXG4gICAqL1xuICBQb2x5bWVyLklyb25TY3JvbGxUYXJnZXRCZWhhdmlvciA9IHtcblxuICAgIHByb3BlcnRpZXM6IHtcblxuICAgICAgLyoqXG4gICAgICAgKiBTcGVjaWZpZXMgdGhlIGVsZW1lbnQgdGhhdCB3aWxsIGhhbmRsZSB0aGUgc2Nyb2xsIGV2ZW50XG4gICAgICAgKiBvbiB0aGUgYmVoYWxmIG9mIHRoZSBjdXJyZW50IGVsZW1lbnQuIFRoaXMgaXMgdHlwaWNhbGx5IGEgcmVmZXJlbmNlIHRvIGFuIGVsZW1lbnQsXG4gICAgICAgKiBidXQgdGhlcmUgYXJlIGEgZmV3IG1vcmUgcG9zaWJpbGl0aWVzOlxuICAgICAgICpcbiAgICAgICAqICMjIyBFbGVtZW50cyBpZFxuICAgICAgICpcbiAgICAgICAqYGBgaHRtbFxuICAgICAgICogPGRpdiBpZD1cInNjcm9sbGFibGUtZWxlbWVudFwiIHN0eWxlPVwib3ZlcmZsb3c6IGF1dG87XCI+XG4gICAgICAgKiAgPHgtZWxlbWVudCBzY3JvbGwtdGFyZ2V0PVwic2Nyb2xsYWJsZS1lbGVtZW50XCI+XG4gICAgICAgKiAgICA8IS0tIENvbnRlbnQtLT5cbiAgICAgICAqICA8L3gtZWxlbWVudD5cbiAgICAgICAqIDwvZGl2PlxuICAgICAgICpgYGBcbiAgICAgICAqIEluIHRoaXMgY2FzZSwgdGhlIGBzY3JvbGxUYXJnZXRgIHdpbGwgcG9pbnQgdG8gdGhlIG91dGVyIGRpdiBlbGVtZW50LlxuICAgICAgICpcbiAgICAgICAqICMjIyBEb2N1bWVudCBzY3JvbGxpbmdcbiAgICAgICAqXG4gICAgICAgKiBGb3IgZG9jdW1lbnQgc2Nyb2xsaW5nLCB5b3UgY2FuIHVzZSB0aGUgcmVzZXJ2ZWQgd29yZCBgZG9jdW1lbnRgOlxuICAgICAgICpcbiAgICAgICAqYGBgaHRtbFxuICAgICAgICogPHgtZWxlbWVudCBzY3JvbGwtdGFyZ2V0PVwiZG9jdW1lbnRcIj5cbiAgICAgICAqICAgPCEtLSBDb250ZW50IC0tPlxuICAgICAgICogPC94LWVsZW1lbnQ+XG4gICAgICAgKmBgYFxuICAgICAgICpcbiAgICAgICAqICMjIyBFbGVtZW50cyByZWZlcmVuY2VcbiAgICAgICAqXG4gICAgICAgKmBgYGpzXG4gICAgICAgKiBhcHBIZWFkZXIuc2Nyb2xsVGFyZ2V0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3Njcm9sbGFibGUtZWxlbWVudCcpO1xuICAgICAgICpgYGBcbiAgICAgICAqXG4gICAgICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAgICAgKiBAZGVmYXVsdCBkb2N1bWVudFxuICAgICAgICovXG4gICAgICBzY3JvbGxUYXJnZXQ6IHtcbiAgICAgICAgdHlwZTogSFRNTEVsZW1lbnQsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fZGVmYXVsdFNjcm9sbFRhcmdldDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBvYnNlcnZlcnM6IFtcbiAgICAgICdfc2Nyb2xsVGFyZ2V0Q2hhbmdlZChzY3JvbGxUYXJnZXQsIGlzQXR0YWNoZWQpJ1xuICAgIF0sXG5cbiAgICAvKipcbiAgICAgKiBUcnVlIGlmIHRoZSBldmVudCBsaXN0ZW5lciBzaG91bGQgYmUgaW5zdGFsbGVkLlxuICAgICAqL1xuICAgIF9zaG91bGRIYXZlTGlzdGVuZXI6IHRydWUsXG5cbiAgICBfc2Nyb2xsVGFyZ2V0Q2hhbmdlZDogZnVuY3Rpb24oc2Nyb2xsVGFyZ2V0LCBpc0F0dGFjaGVkKSB7XG4gICAgICB2YXIgZXZlbnRUYXJnZXQ7XG5cbiAgICAgIGlmICh0aGlzLl9vbGRTY3JvbGxUYXJnZXQpIHtcbiAgICAgICAgdGhpcy5fdG9nZ2xlU2Nyb2xsTGlzdGVuZXIoZmFsc2UsIHRoaXMuX29sZFNjcm9sbFRhcmdldCk7XG4gICAgICAgIHRoaXMuX29sZFNjcm9sbFRhcmdldCA9IG51bGw7XG4gICAgICB9XG4gICAgICBpZiAoIWlzQXR0YWNoZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gU3VwcG9ydCBlbGVtZW50IGlkIHJlZmVyZW5jZXNcbiAgICAgIGlmIChzY3JvbGxUYXJnZXQgPT09ICdkb2N1bWVudCcpIHtcblxuICAgICAgICB0aGlzLnNjcm9sbFRhcmdldCA9IHRoaXMuX2RvYztcblxuICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygc2Nyb2xsVGFyZ2V0ID09PSAnc3RyaW5nJykge1xuXG4gICAgICAgIHZhciBkb21Ib3N0ID0gdGhpcy5kb21Ib3N0O1xuXG4gICAgICAgIHRoaXMuc2Nyb2xsVGFyZ2V0ID0gZG9tSG9zdCAmJiBkb21Ib3N0LiQgPyBkb21Ib3N0LiRbc2Nyb2xsVGFyZ2V0XSA6XG4gICAgICAgICAgICBQb2x5bWVyLmRvbSh0aGlzLm93bmVyRG9jdW1lbnQpLnF1ZXJ5U2VsZWN0b3IoJyMnICsgc2Nyb2xsVGFyZ2V0KTtcblxuICAgICAgfSBlbHNlIGlmICh0aGlzLl9pc1ZhbGlkU2Nyb2xsVGFyZ2V0KCkpIHtcblxuICAgICAgICB0aGlzLl9vbGRTY3JvbGxUYXJnZXQgPSBzY3JvbGxUYXJnZXQ7XG4gICAgICAgIHRoaXMuX3RvZ2dsZVNjcm9sbExpc3RlbmVyKHRoaXMuX3Nob3VsZEhhdmVMaXN0ZW5lciwgc2Nyb2xsVGFyZ2V0KTtcblxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSdW5zIG9uIGV2ZXJ5IHNjcm9sbCBldmVudC4gQ29uc3VtZXIgb2YgdGhpcyBiZWhhdmlvciBtYXkgb3ZlcnJpZGUgdGhpcyBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX3Njcm9sbEhhbmRsZXI6IGZ1bmN0aW9uIHNjcm9sbEhhbmRsZXIoKSB7fSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBkZWZhdWx0IHNjcm9sbCB0YXJnZXQuIENvbnN1bWVycyBvZiB0aGlzIGJlaGF2aW9yIG1heSB3YW50IHRvIGN1c3RvbWl6ZVxuICAgICAqIHRoZSBkZWZhdWx0IHNjcm9sbCB0YXJnZXQuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7RWxlbWVudH1cbiAgICAgKi9cbiAgICBnZXQgX2RlZmF1bHRTY3JvbGxUYXJnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZG9jO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTaG9ydGN1dCBmb3IgdGhlIGRvY3VtZW50IGVsZW1lbnRcbiAgICAgKlxuICAgICAqIEB0eXBlIHtFbGVtZW50fVxuICAgICAqL1xuICAgIGdldCBfZG9jKCkge1xuICAgICAgcmV0dXJuIHRoaXMub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG51bWJlciBvZiBwaXhlbHMgdGhhdCB0aGUgY29udGVudCBvZiBhbiBlbGVtZW50IGlzIHNjcm9sbGVkIHVwd2FyZC5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IF9zY3JvbGxUb3AoKSB7XG4gICAgICBpZiAodGhpcy5faXNWYWxpZFNjcm9sbFRhcmdldCgpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjcm9sbFRhcmdldCA9PT0gdGhpcy5fZG9jID8gd2luZG93LnBhZ2VZT2Zmc2V0IDogdGhpcy5zY3JvbGxUYXJnZXQuc2Nyb2xsVG9wO1xuICAgICAgfVxuICAgICAgcmV0dXJuIDA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG51bWJlciBvZiBwaXhlbHMgdGhhdCB0aGUgY29udGVudCBvZiBhbiBlbGVtZW50IGlzIHNjcm9sbGVkIHRvIHRoZSBsZWZ0LlxuICAgICAqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgX3Njcm9sbExlZnQoKSB7XG4gICAgICBpZiAodGhpcy5faXNWYWxpZFNjcm9sbFRhcmdldCgpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjcm9sbFRhcmdldCA9PT0gdGhpcy5fZG9jID8gd2luZG93LnBhZ2VYT2Zmc2V0IDogdGhpcy5zY3JvbGxUYXJnZXQuc2Nyb2xsTGVmdDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBudW1iZXIgb2YgcGl4ZWxzIHRoYXQgdGhlIGNvbnRlbnQgb2YgYW4gZWxlbWVudCBpcyBzY3JvbGxlZCB1cHdhcmQuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHNldCBfc2Nyb2xsVG9wKHRvcCkge1xuICAgICAgaWYgKHRoaXMuc2Nyb2xsVGFyZ2V0ID09PSB0aGlzLl9kb2MpIHtcbiAgICAgICAgd2luZG93LnNjcm9sbFRvKHdpbmRvdy5wYWdlWE9mZnNldCwgdG9wKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5faXNWYWxpZFNjcm9sbFRhcmdldCgpKSB7XG4gICAgICAgIHRoaXMuc2Nyb2xsVGFyZ2V0LnNjcm9sbFRvcCA9IHRvcDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgbnVtYmVyIG9mIHBpeGVscyB0aGF0IHRoZSBjb250ZW50IG9mIGFuIGVsZW1lbnQgaXMgc2Nyb2xsZWQgdG8gdGhlIGxlZnQuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHNldCBfc2Nyb2xsTGVmdChsZWZ0KSB7XG4gICAgICBpZiAodGhpcy5zY3JvbGxUYXJnZXQgPT09IHRoaXMuX2RvYykge1xuICAgICAgICB3aW5kb3cuc2Nyb2xsVG8obGVmdCwgd2luZG93LnBhZ2VZT2Zmc2V0KTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5faXNWYWxpZFNjcm9sbFRhcmdldCgpKSB7XG4gICAgICAgIHRoaXMuc2Nyb2xsVGFyZ2V0LnNjcm9sbExlZnQgPSBsZWZ0O1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTY3JvbGxzIHRoZSBjb250ZW50IHRvIGEgcGFydGljdWxhciBwbGFjZS5cbiAgICAgKlxuICAgICAqIEBtZXRob2Qgc2Nyb2xsXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxlZnQgVGhlIGxlZnQgcG9zaXRpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdG9wIFRoZSB0b3AgcG9zaXRpb25cbiAgICAgKi9cbiAgICBzY3JvbGw6IGZ1bmN0aW9uKGxlZnQsIHRvcCkge1xuICAgICAgIGlmICh0aGlzLnNjcm9sbFRhcmdldCA9PT0gdGhpcy5fZG9jKSB7XG4gICAgICAgIHdpbmRvdy5zY3JvbGxUbyhsZWZ0LCB0b3ApO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl9pc1ZhbGlkU2Nyb2xsVGFyZ2V0KCkpIHtcbiAgICAgICAgdGhpcy5zY3JvbGxUYXJnZXQuc2Nyb2xsTGVmdCA9IGxlZnQ7XG4gICAgICAgIHRoaXMuc2Nyb2xsVGFyZ2V0LnNjcm9sbFRvcCA9IHRvcDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgd2lkdGggb2YgdGhlIHNjcm9sbCB0YXJnZXQuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldCBfc2Nyb2xsVGFyZ2V0V2lkdGgoKSB7XG4gICAgICBpZiAodGhpcy5faXNWYWxpZFNjcm9sbFRhcmdldCgpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjcm9sbFRhcmdldCA9PT0gdGhpcy5fZG9jID8gd2luZG93LmlubmVyV2lkdGggOiB0aGlzLnNjcm9sbFRhcmdldC5vZmZzZXRXaWR0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBoZWlnaHQgb2YgdGhlIHNjcm9sbCB0YXJnZXQuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldCBfc2Nyb2xsVGFyZ2V0SGVpZ2h0KCkge1xuICAgICAgaWYgKHRoaXMuX2lzVmFsaWRTY3JvbGxUYXJnZXQoKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zY3JvbGxUYXJnZXQgPT09IHRoaXMuX2RvYyA/IHdpbmRvdy5pbm5lckhlaWdodCA6IHRoaXMuc2Nyb2xsVGFyZ2V0Lm9mZnNldEhlaWdodDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHNjcm9sbCB0YXJnZXQgaXMgYSB2YWxpZCBIVE1MRWxlbWVudC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgX2lzVmFsaWRTY3JvbGxUYXJnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2Nyb2xsVGFyZ2V0IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQ7XG4gICAgfSxcblxuICAgIF90b2dnbGVTY3JvbGxMaXN0ZW5lcjogZnVuY3Rpb24oeWVzLCBzY3JvbGxUYXJnZXQpIHtcbiAgICAgIHZhciBldmVudFRhcmdldCA9IHNjcm9sbFRhcmdldCA9PT0gdGhpcy5fZG9jID8gd2luZG93IDogc2Nyb2xsVGFyZ2V0O1xuICAgICAgaWYgKHllcykge1xuICAgICAgICBpZiAoIXRoaXMuX2JvdW5kU2Nyb2xsSGFuZGxlcikge1xuICAgICAgICAgIHRoaXMuX2JvdW5kU2Nyb2xsSGFuZGxlciA9IHRoaXMuX3Njcm9sbEhhbmRsZXIuYmluZCh0aGlzKTtcbiAgICAgICAgICBldmVudFRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLl9ib3VuZFNjcm9sbEhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5fYm91bmRTY3JvbGxIYW5kbGVyKSB7XG4gICAgICAgICAgZXZlbnRUYXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy5fYm91bmRTY3JvbGxIYW5kbGVyKTtcbiAgICAgICAgICB0aGlzLl9ib3VuZFNjcm9sbEhhbmRsZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIHNjcm9sbCBldmVudCBsaXN0ZW5lci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0geWVzIFRydWUgdG8gYWRkIHRoZSBldmVudCwgRmFsc2UgdG8gcmVtb3ZlIGl0LlxuICAgICAqL1xuICAgIHRvZ2dsZVNjcm9sbExpc3RlbmVyOiBmdW5jdGlvbih5ZXMpIHtcbiAgICAgIHRoaXMuX3Nob3VsZEhhdmVMaXN0ZW5lciA9IHllcztcbiAgICAgIHRoaXMuX3RvZ2dsZVNjcm9sbExpc3RlbmVyKHllcywgdGhpcy5zY3JvbGxUYXJnZXQpO1xuICAgIH1cblxuICB9O1xuXG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvaXJvbi1zY3JvbGwtdGFyZ2V0LWJlaGF2aW9yL2lyb24tc2Nyb2xsLXRhcmdldC1iZWhhdmlvci5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNiBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuXG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vLi4vcG9seW1lci9wb2x5bWVyLmh0bWxcIj5cblxuPHNjcmlwdD5cbiAgUG9seW1lci5BcHBMYXlvdXQgPSBQb2x5bWVyLkFwcExheW91dCB8fCB7fTtcblxuICBQb2x5bWVyLkFwcExheW91dC5fc2Nyb2xsRWZmZWN0cyA9IFBvbHltZXIuQXBwTGF5b3V0Ll9zY3JvbGxFZmZlY3RzIHx8IHt9O1xuXG4gIFBvbHltZXIuQXBwTGF5b3V0LnNjcm9sbFRpbWluZ0Z1bmN0aW9uID0gZnVuY3Rpb24gZWFzZU91dFF1YWQodCwgYiwgYywgZCkge1xuICAgIHQgLz0gZDtcbiAgICByZXR1cm4gLWMgKiB0Kih0LTIpICsgYjtcbiAgfTtcblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGEgc2Nyb2xsIGVmZmVjdCB0byBiZSB1c2VkIGluIGVsZW1lbnRzIHRoYXQgaW1wbGVtZW50IHRoZVxuICAgKiBgUG9seW1lci5BcHBTY3JvbGxFZmZlY3RzQmVoYXZpb3JgIGJlaGF2aW9yLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZWZmZWN0TmFtZSBUaGUgZWZmZWN0IG5hbWUuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlZmZlY3REZWYgVGhlIGVmZmVjdCBkZWZpbml0aW9uLlxuICAgKi9cbiAgUG9seW1lci5BcHBMYXlvdXQucmVnaXN0ZXJFZmZlY3QgPSBmdW5jdGlvbiByZWdpc3RlckVmZmVjdChlZmZlY3ROYW1lLCBlZmZlY3REZWYpIHtcbiAgICBpZiAoUG9seW1lci5BcHBMYXlvdXQuX3Njcm9sbEVmZmVjdHNbZWZmZWN0TmFtZV0gIT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdlZmZlY3QgYCcrIGVmZmVjdE5hbWUgKyAnYCBpcyBhbHJlYWR5IHJlZ2lzdGVyZWQuJyk7XG4gICAgfVxuICAgIFBvbHltZXIuQXBwTGF5b3V0Ll9zY3JvbGxFZmZlY3RzW2VmZmVjdE5hbWVdID0gZWZmZWN0RGVmO1xuICB9O1xuXG5cbiAgUG9seW1lci5BcHBMYXlvdXQucXVlcnlBbGxSb290ID0gZnVuY3Rpb24oc2VsZWN0b3IsIHJvb3QpIHtcbiAgICB2YXIgcXVldWUgPSBbcm9vdF07XG4gICAgdmFyIG1hdGNoZXMgPSBbXTtcblxuICAgIHdoaWxlIChxdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICB2YXIgbm9kZSA9IHF1ZXVlLnNoaWZ0KCk7XG4gICAgICBtYXRjaGVzLnB1c2guYXBwbHkobWF0Y2hlcywgbm9kZS5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKSk7XG4gICAgICBmb3IgKGkgPSAwOyBub2RlLmNoaWxkcmVuW2ldOyBpKyspIHtcbiAgICAgICAgaWYgKG5vZGUuY2hpbGRyZW5baV0uc2hhZG93Um9vdCkge1xuICAgICAgICAgIHF1ZXVlLnB1c2gobm9kZS5jaGlsZHJlbltpXS5zaGFkb3dSb290KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWF0Y2hlcztcbiAgfTtcblxuICAvKipcbiAgICogU2Nyb2xscyB0byBhIHBhcnRpY3VsYXIgc2V0IG9mIGNvb3JkaW5hdGVzIGluIGEgc2Nyb2xsIHRhcmdldC5cbiAgICogSWYgdGhlIHNjcm9sbCB0YXJnZXQgaXMgbm90IGRlZmluZWQsIHRoZW4gaXQgd291bGQgdXNlIHRoZSBtYWluIGRvY3VtZW50IGFzIHRoZSB0YXJnZXQuXG4gICAqXG4gICAqIFRvIHNjcm9sbCBpbiBhIHNtb290aCBmYXNoaW9uLCB5b3UgY2FuIHNldCB0aGUgb3B0aW9uIGBiZWhhdmlvcjogJ3Ntb290aCdgLiBlLmcuXG4gICAqXG4gICAqIGBgYGpzXG4gICAqIFBvbHltZXIuQXBwTGF5b3V0LnNjcm9sbCh7dG9wOiAwLCBiZWhhdmlvcjogJ3Ntb290aCd9KTtcbiAgICogYGBgXG4gICAqXG4gICAqIFRvIHNjcm9sbCBpbiBhIHNpbGVudCBtb2RlLCB3aXRob3V0IG5vdGlmeWluZyBzY3JvbGwgY2hhbmdlcyB0byBhbnkgYXBwLWxheW91dCBlbGVtZW50cyxcbiAgICogeW91IGNhbiBzZXQgdGhlIG9wdGlvbiBgYmVoYXZpb3I6ICdzaWxlbnQnYC4gVGhpcyBpcyBwYXJ0aWN1bGFybHkgdXNlZnVsIHdlIHlvdSBhcmUgdXNpbmdcbiAgICogYGFwcC1oZWFkZXJgIGFuZCB5b3UgZGVzaXJlIHRvIHNjcm9sbCB0byB0aGUgdG9wIG9mIGEgc2Nyb2xsaW5nIHJlZ2lvbiB3aXRob3V0IHJ1bm5pbmdcbiAgICogc2Nyb2xsIGVmZmVjdHMuIGUuZy5cbiAgICpcbiAgICogYGBganNcbiAgICogUG9seW1lci5BcHBMYXlvdXQuc2Nyb2xsKHt0b3A6IDAsIGJlaGF2aW9yOiAnc2lsZW50J30pO1xuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMge3RvcDogTnVtYmVyLCBsZWZ0OiBOdW1iZXIsIGJlaGF2aW9yOiBTdHJpbmcoc21vb3RoIHwgc2lsZW50KX1cbiAgICovXG4gIFBvbHltZXIuQXBwTGF5b3V0LnNjcm9sbCA9IGZ1bmN0aW9uIHNjcm9sbChvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICB2YXIgZG9jRWwgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgdmFyIHRhcmdldCA9IG9wdGlvbnMudGFyZ2V0IHx8IGRvY0VsO1xuICAgIHZhciBoYXNOYXRpdmVTY3JvbGxCZWhhdmlvciA9ICdzY3JvbGxCZWhhdmlvcicgaW4gdGFyZ2V0LnN0eWxlICYmIHRhcmdldC5zY3JvbGw7XG4gICAgdmFyIHNjcm9sbENsYXNzTmFtZSA9ICdhcHAtbGF5b3V0LXNpbGVudC1zY3JvbGwnO1xuICAgIHZhciBzY3JvbGxUb3AgPSBvcHRpb25zLnRvcCB8fCAwO1xuICAgIHZhciBzY3JvbGxMZWZ0ID0gb3B0aW9ucy5sZWZ0IHx8IDA7XG4gICAgdmFyIHNjcm9sbFRvID0gdGFyZ2V0ID09PSBkb2NFbCA/IHdpbmRvdy5zY3JvbGxUbyA6XG4gICAgICBmdW5jdGlvbiBzY3JvbGxUbyhzY3JvbGxMZWZ0LCBzY3JvbGxUb3ApIHtcbiAgICAgICAgdGFyZ2V0LnNjcm9sbExlZnQgPSBzY3JvbGxMZWZ0O1xuICAgICAgICB0YXJnZXQuc2Nyb2xsVG9wID0gc2Nyb2xsVG9wO1xuICAgICAgfTtcblxuICAgIGlmIChvcHRpb25zLmJlaGF2aW9yID09PSAnc21vb3RoJykge1xuXG4gICAgICBpZiAoaGFzTmF0aXZlU2Nyb2xsQmVoYXZpb3IpIHtcblxuICAgICAgICB0YXJnZXQuc2Nyb2xsKG9wdGlvbnMpO1xuXG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIHZhciB0aW1pbmdGbiA9IFBvbHltZXIuQXBwTGF5b3V0LnNjcm9sbFRpbWluZ0Z1bmN0aW9uO1xuICAgICAgICB2YXIgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdmFyIGN1cnJlbnRTY3JvbGxUb3AgPSB0YXJnZXQgPT09IGRvY0VsID8gd2luZG93LnBhZ2VZT2Zmc2V0IDogdGFyZ2V0LnNjcm9sbFRvcDtcbiAgICAgICAgdmFyIGN1cnJlbnRTY3JvbGxMZWZ0ID0gdGFyZ2V0ID09PSBkb2NFbCA/IHdpbmRvdy5wYWdlWE9mZnNldCA6IHRhcmdldC5zY3JvbGxMZWZ0O1xuICAgICAgICB2YXIgZGVsdGFTY3JvbGxUb3AgPSBzY3JvbGxUb3AgLSBjdXJyZW50U2Nyb2xsVG9wO1xuICAgICAgICB2YXIgZGVsdGFTY3JvbGxMZWZ0ID0gc2Nyb2xsTGVmdCAtIGN1cnJlbnRTY3JvbGxMZWZ0O1xuICAgICAgICB2YXIgZHVyYXRpb24gPSAzMDA7XG4gICAgICAgIHZhciB1cGRhdGVGcmFtZSA9IChmdW5jdGlvbiB1cGRhdGVGcmFtZSgpIHtcbiAgICAgICAgICB2YXIgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICB2YXIgZWxhcHNlZFRpbWUgPSBub3cgLSBzdGFydFRpbWU7XG5cbiAgICAgICAgICBpZiAoZWxhcHNlZFRpbWUgPCBkdXJhdGlvbikge1xuICAgICAgICAgICAgc2Nyb2xsVG8odGltaW5nRm4oZWxhcHNlZFRpbWUsIGN1cnJlbnRTY3JvbGxMZWZ0LCBkZWx0YVNjcm9sbExlZnQsIGR1cmF0aW9uKSxcbiAgICAgICAgICAgICAgICB0aW1pbmdGbihlbGFwc2VkVGltZSwgY3VycmVudFNjcm9sbFRvcCwgZGVsdGFTY3JvbGxUb3AsIGR1cmF0aW9uKSk7XG4gICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodXBkYXRlRnJhbWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzY3JvbGxUbyhzY3JvbGxMZWZ0LCBzY3JvbGxUb3ApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkuYmluZCh0aGlzKTtcblxuICAgICAgICB1cGRhdGVGcmFtZSgpO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIGlmIChvcHRpb25zLmJlaGF2aW9yID09PSAnc2lsZW50Jykge1xuICAgICAgdmFyIGhlYWRlcnMgPSBQb2x5bWVyLkFwcExheW91dC5xdWVyeUFsbFJvb3QoJ2FwcC1oZWFkZXInLCBkb2N1bWVudC5ib2R5KTtcblxuICAgICAgaGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uKGhlYWRlcikge1xuICAgICAgICBoZWFkZXIuc2V0QXR0cmlidXRlKCdzaWxlbnQtc2Nyb2xsJywgJycpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIEJyb3dzZXJzIGtlZXAgdGhlIHNjcm9sbCBtb21lbnR1bSBldmVuIGlmIHRoZSBib3R0b20gb2YgdGhlIHNjcm9sbGluZyBjb250ZW50XG4gICAgICAvLyB3YXMgcmVhY2hlZC4gVGhpcyBtZWFucyB0aGF0IGNhbGxpbmcgc2Nyb2xsKHt0b3A6IDAsIGJlaGF2aW9yOiAnc2lsZW50J30pIHdoZW5cbiAgICAgIC8vIHRoZSBtb21lbnR1bSBpcyBzdGlsbCBnb2luZyB3aWxsIHJlc3VsdCBpbiBtb3JlIHNjcm9sbCBldmVudHMgYW5kIHRodXMgc2Nyb2xsIGVmZmVjdHMuXG4gICAgICAvLyBUaGlzIHNlZW1zIHRvIG9ubHkgYXBwbHkgd2hlbiB1c2luZyBkb2N1bWVudCBzY3JvbGxpbmcuXG4gICAgICAvLyBUaGVyZWZvcmUsIHdoZW4gc2hvdWxkIHdlIHJlbW92ZSB0aGUgY2xhc3MgZnJvbSB0aGUgZG9jdW1lbnQgZWxlbWVudD9cblxuICAgICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKFBvbHltZXIuQXBwTGF5b3V0Ll9zY3JvbGxUaW1lcik7XG5cbiAgICAgIFBvbHltZXIuQXBwTGF5b3V0Ll9zY3JvbGxUaW1lciA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKSB7XG4gICAgICAgIGhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbihoZWFkZXIpIHtcbiAgICAgICAgICBoZWFkZXIucmVtb3ZlQXR0cmlidXRlKCdzaWxlbnQtc2Nyb2xsJyk7XG4gICAgICAgIH0pO1xuICAgICAgICBQb2x5bWVyLkFwcExheW91dC5fc2Nyb2xsVGltZXIgPSBudWxsO1xuICAgICAgfSk7XG5cbiAgICAgIHNjcm9sbFRvKHNjcm9sbExlZnQsIHNjcm9sbFRvcCk7XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICBzY3JvbGxUbyhzY3JvbGxMZWZ0LCBzY3JvbGxUb3ApO1xuXG4gICAgfVxuICB9O1xuXG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvYXBwLWxheW91dC9oZWxwZXJzL2hlbHBlcnMuaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTUgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cblxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uLy4uL3BvbHltZXIvcG9seW1lci5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vLi4vaXJvbi1mbGV4LWxheW91dC9pcm9uLWZsZXgtbGF5b3V0Lmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi9hcHAtbGF5b3V0LWJlaGF2aW9yL2FwcC1sYXlvdXQtYmVoYXZpb3IuaHRtbFwiPlxuXG48IS0tXG5hcHAtaGVhZGVyLWxheW91dCBpcyBhIHdyYXBwZXIgZWxlbWVudCB0aGF0IHBvc2l0aW9ucyBhbiBhcHAtaGVhZGVyIGFuZCBvdGhlciBjb250ZW50LiBUaGlzXG5lbGVtZW50IHVzZXMgdGhlIGRvY3VtZW50IHNjcm9sbCBieSBkZWZhdWx0LCBidXQgaXQgY2FuIGFsc28gZGVmaW5lIGl0cyBvd24gc2Nyb2xsaW5nIHJlZ2lvbi5cblxuVXNpbmcgdGhlIGRvY3VtZW50IHNjcm9sbDpcblxuYGBgaHRtbFxuPGFwcC1oZWFkZXItbGF5b3V0PlxuICA8YXBwLWhlYWRlciBzbG90PVwiaGVhZGVyXCIgZml4ZWQgY29uZGVuc2VzIGVmZmVjdHM9XCJ3YXRlcmZhbGxcIj5cbiAgICA8YXBwLXRvb2xiYXI+XG4gICAgICA8ZGl2IG1haW4tdGl0bGU+QXBwIG5hbWU8L2Rpdj5cbiAgICA8L2FwcC10b29sYmFyPlxuICA8L2FwcC1oZWFkZXI+XG4gIDxkaXY+XG4gICAgbWFpbiBjb250ZW50XG4gIDwvZGl2PlxuPC9hcHAtaGVhZGVyLWxheW91dD5cbmBgYFxuXG5Vc2luZyBhbiBvd24gc2Nyb2xsaW5nIHJlZ2lvbjpcblxuYGBgaHRtbFxuPGFwcC1oZWFkZXItbGF5b3V0IGhhcy1zY3JvbGxpbmctcmVnaW9uIHN0eWxlPVwid2lkdGg6IDMwMHB4OyBoZWlnaHQ6IDQwMHB4O1wiPlxuICA8YXBwLWhlYWRlciBzbG90PVwiaGVhZGVyXCIgZml4ZWQgY29uZGVuc2VzIGVmZmVjdHM9XCJ3YXRlcmZhbGxcIj5cbiAgICA8YXBwLXRvb2xiYXI+XG4gICAgICA8ZGl2IG1haW4tdGl0bGU+QXBwIG5hbWU8L2Rpdj5cbiAgICA8L2FwcC10b29sYmFyPlxuICA8L2FwcC1oZWFkZXI+XG4gIDxkaXY+XG4gICAgbWFpbiBjb250ZW50XG4gIDwvZGl2PlxuPC9hcHAtaGVhZGVyLWxheW91dD5cbmBgYFxuXG5BZGQgdGhlIGBmdWxsYmxlZWRgIGF0dHJpYnV0ZSB0byBhcHAtaGVhZGVyLWxheW91dCB0byBtYWtlIGl0IGZpdCB0aGUgc2l6ZSBvZiBpdHMgY29udGFpbmVyOlxuXG5gYGBodG1sXG48YXBwLWhlYWRlci1sYXlvdXQgZnVsbGJsZWVkPlxuIC4uLlxuPC9hcHAtaGVhZGVyLWxheW91dD5cbmBgYFxuXG5AZ3JvdXAgQXBwIEVsZW1lbnRzXG5AZWxlbWVudCBhcHAtaGVhZGVyLWxheW91dFxuQGRlbW8gYXBwLWhlYWRlci1sYXlvdXQvZGVtby9zaW1wbGUuaHRtbCBTaW1wbGUgRGVtb1xuQGRlbW8gYXBwLWhlYWRlci1sYXlvdXQvZGVtby9zY3JvbGxpbmctcmVnaW9uLmh0bWwgU2Nyb2xsaW5nIFJlZ2lvblxuQGRlbW8gYXBwLWhlYWRlci1sYXlvdXQvZGVtby9tdXNpYy5odG1sIE11c2ljIERlbW9cbkBkZW1vIGFwcC1oZWFkZXItbGF5b3V0L2RlbW8vZm9vdGVyLmh0bWwgRm9vdGVyIERlbW9cbi0tPlxuXG48ZG9tLW1vZHVsZSBpZD1cImFwcC1oZWFkZXItbGF5b3V0XCI+XG4gIDx0ZW1wbGF0ZT5cbiAgICA8c3R5bGU+XG4gICAgICA6aG9zdCB7XG4gICAgICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgICAgICAvKipcbiAgICAgICAgICogRm9yY2UgYXBwLWhlYWRlci1sYXlvdXQgdG8gaGF2ZSBpdHMgb3duIHN0YWNraW5nIGNvbnRleHQgc28gdGhhdCBpdHMgcGFyZW50IGNhblxuICAgICAgICAgKiBjb250cm9sIHRoZSBzdGFja2luZyBvZiBpdCByZWxhdGl2ZSB0byBvdGhlciBlbGVtZW50cyAoZS5nLiBhcHAtZHJhd2VyLWxheW91dCkuXG4gICAgICAgICAqIFRoaXMgY291bGQgYmUgZG9uZSB1c2luZyBgaXNvbGF0aW9uOiBpc29sYXRlYCwgYnV0IHRoYXQncyBub3Qgd2VsbCBzdXBwb3J0ZWRcbiAgICAgICAgICogYWNyb3NzIGJyb3dzZXJzLlxuICAgICAgICAgKi9cbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICB6LWluZGV4OiAwO1xuICAgICAgfVxuXG4gICAgICAjd3JhcHBlciA6OnNsb3R0ZWQoW3Nsb3Q9aGVhZGVyXSkge1xuICAgICAgICBAYXBwbHkgLS1sYXlvdXQtZml4ZWQtdG9wO1xuICAgICAgICB6LWluZGV4OiAxO1xuICAgICAgfVxuXG4gICAgICAjd3JhcHBlci5pbml0aWFsaXppbmcgOjpzbG90dGVkKFtzbG90PWhlYWRlcl0pIHtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgfVxuXG4gICAgICA6aG9zdChbaGFzLXNjcm9sbGluZy1yZWdpb25dKSB7XG4gICAgICAgIGhlaWdodDogMTAwJTtcbiAgICAgIH1cblxuICAgICAgOmhvc3QoW2hhcy1zY3JvbGxpbmctcmVnaW9uXSkgI3dyYXBwZXIgOjpzbG90dGVkKFtzbG90PWhlYWRlcl0pIHtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgfVxuXG4gICAgICA6aG9zdChbaGFzLXNjcm9sbGluZy1yZWdpb25dKSAjd3JhcHBlci5pbml0aWFsaXppbmcgOjpzbG90dGVkKFtzbG90PWhlYWRlcl0pIHtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgfVxuXG4gICAgICA6aG9zdChbaGFzLXNjcm9sbGluZy1yZWdpb25dKSAjd3JhcHBlciAjY29udGVudENvbnRhaW5lciB7XG4gICAgICAgIEBhcHBseSAtLWxheW91dC1maXQ7XG4gICAgICAgIG92ZXJmbG93LXk6IGF1dG87XG4gICAgICAgIC13ZWJraXQtb3ZlcmZsb3ctc2Nyb2xsaW5nOiB0b3VjaDtcbiAgICAgIH1cblxuICAgICAgOmhvc3QoW2hhcy1zY3JvbGxpbmctcmVnaW9uXSkgI3dyYXBwZXIuaW5pdGlhbGl6aW5nICNjb250ZW50Q29udGFpbmVyIHtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgfVxuXG4gICAgICA6aG9zdChbZnVsbGJsZWVkXSkge1xuICAgICAgICBAYXBwbHkgLS1sYXlvdXQtdmVydGljYWw7XG4gICAgICAgIEBhcHBseSAtLWxheW91dC1maXQ7XG4gICAgICB9XG5cbiAgICAgIDpob3N0KFtmdWxsYmxlZWRdKSAjd3JhcHBlcixcbiAgICAgIDpob3N0KFtmdWxsYmxlZWRdKSAjd3JhcHBlciAjY29udGVudENvbnRhaW5lciB7XG4gICAgICAgIEBhcHBseSAtLWxheW91dC12ZXJ0aWNhbDtcbiAgICAgICAgQGFwcGx5IC0tbGF5b3V0LWZsZXg7XG4gICAgICB9XG5cbiAgICAgICNjb250ZW50Q29udGFpbmVyIHtcbiAgICAgICAgLyogQ3JlYXRlIGEgc3RhY2tpbmcgY29udGV4dCBoZXJlIHNvIHRoYXQgYWxsIGNoaWxkcmVuIGFwcGVhciBiZWxvdyB0aGUgaGVhZGVyLiAqL1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgIHotaW5kZXg6IDA7XG4gICAgICB9XG5cbiAgICA8L3N0eWxlPlxuXG4gICAgPGRpdiBpZD1cIndyYXBwZXJcIiBjbGFzcz1cImluaXRpYWxpemluZ1wiPlxuICAgICAgPHNsb3QgaWQ9XCJoZWFkZXJTbG90XCIgbmFtZT1cImhlYWRlclwiPjwvc2xvdD5cblxuICAgICAgPGRpdiBpZD1cImNvbnRlbnRDb250YWluZXJcIj5cbiAgICAgICAgPHNsb3Q+PC9zbG90PlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG5cbiAgPC90ZW1wbGF0ZT5cblxuICA8c2NyaXB0PlxuICAgIFBvbHltZXIoe1xuICAgICAgaXM6ICdhcHAtaGVhZGVyLWxheW91dCcsXG5cbiAgICAgIGJlaGF2aW9yczogW1xuICAgICAgICBQb2x5bWVyLkFwcExheW91dEJlaGF2aW9yXG4gICAgICBdLFxuXG4gICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0cnVlLCB0aGUgY3VycmVudCBlbGVtZW50IHdpbGwgaGF2ZSBpdHMgb3duIHNjcm9sbGluZyByZWdpb24uXG4gICAgICAgICAqIE90aGVyd2lzZSwgaXQgd2lsbCB1c2UgdGhlIGRvY3VtZW50IHNjcm9sbCB0byBjb250cm9sIHRoZSBoZWFkZXIuXG4gICAgICAgICAqL1xuICAgICAgICBoYXNTY3JvbGxpbmdSZWdpb246IHtcbiAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgIHZhbHVlOiBmYWxzZSxcbiAgICAgICAgICByZWZsZWN0VG9BdHRyaWJ1dGU6IHRydWVcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgb2JzZXJ2ZXJzOiBbXG4gICAgICAgICdyZXNldExheW91dChpc0F0dGFjaGVkLCBoYXNTY3JvbGxpbmdSZWdpb24pJ1xuICAgICAgXSxcblxuICAgICAgLyoqXG4gICAgICAgKiBBIHJlZmVyZW5jZSB0byB0aGUgYXBwLWhlYWRlciBlbGVtZW50LlxuICAgICAgICpcbiAgICAgICAqIEBwcm9wZXJ0eSBoZWFkZXJcbiAgICAgICAqL1xuICAgICAgZ2V0IGhlYWRlcigpIHtcbiAgICAgICAgcmV0dXJuIFBvbHltZXIuZG9tKHRoaXMuJC5oZWFkZXJTbG90KS5nZXREaXN0cmlidXRlZE5vZGVzKClbMF07XG4gICAgICB9LFxuXG4gICAgICBfdXBkYXRlTGF5b3V0U3RhdGVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGhlYWRlciA9IHRoaXMuaGVhZGVyO1xuICAgICAgICBpZiAoIXRoaXMuaXNBdHRhY2hlZCB8fCAhaGVhZGVyKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlbW92ZSB0aGUgaW5pdGlhbGl6aW5nIGNsYXNzLCB3aGljaCBzdGF0aWNseSBwb3NpdGlvbnMgdGhlIGhlYWRlciBhbmQgdGhlIGNvbnRlbnRcbiAgICAgICAgLy8gdW50aWwgdGhlIGhlaWdodCBvZiB0aGUgaGVhZGVyIGNhbiBiZSByZWFkLlxuICAgICAgICB0aGlzLiQud3JhcHBlci5jbGFzc0xpc3QucmVtb3ZlKCdpbml0aWFsaXppbmcnKTtcbiAgICAgICAgLy8gVXBkYXRlIHNjcm9sbCB0YXJnZXQuXG4gICAgICAgIGhlYWRlci5zY3JvbGxUYXJnZXQgPSB0aGlzLmhhc1Njcm9sbGluZ1JlZ2lvbiA/XG4gICAgICAgICAgICB0aGlzLiQuY29udGVudENvbnRhaW5lciA6IHRoaXMub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIC8vIEdldCBoZWFkZXIgaGVpZ2h0IGhlcmUgc28gdGhhdCBzdHlsZSByZWFkcyBhcmUgYmF0Y2hlZCB0b2dldGhlciBiZWZvcmUgc3R5bGUgd3JpdGVzXG4gICAgICAgIC8vIChpLmUuIGdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIGJlbG93KS5cbiAgICAgICAgdmFyIGhlYWRlckhlaWdodCA9IGhlYWRlci5vZmZzZXRIZWlnaHQ7XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgaGVhZGVyIHBvc2l0aW9uLlxuICAgICAgICBpZiAoIXRoaXMuaGFzU2Nyb2xsaW5nUmVnaW9uKSB7XG4gICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHJlY3QgPSB0aGlzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgdmFyIHJpZ2h0T2Zmc2V0ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoIC0gcmVjdC5yaWdodDtcbiAgICAgICAgICAgIGhlYWRlci5zdHlsZS5sZWZ0ID0gcmVjdC5sZWZ0ICsgJ3B4JztcbiAgICAgICAgICAgIGhlYWRlci5zdHlsZS5yaWdodCA9IHJpZ2h0T2Zmc2V0ICsgJ3B4JztcbiAgICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGhlYWRlci5zdHlsZS5sZWZ0ID0gJyc7XG4gICAgICAgICAgaGVhZGVyLnN0eWxlLnJpZ2h0ID0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXBkYXRlIHRoZSBjb250ZW50IGNvbnRhaW5lciBwb3NpdGlvbi5cbiAgICAgICAgdmFyIGNvbnRhaW5lclN0eWxlID0gdGhpcy4kLmNvbnRlbnRDb250YWluZXIuc3R5bGU7XG4gICAgICAgIGlmIChoZWFkZXIuZml4ZWQgJiYgIWhlYWRlci5jb25kZW5zZXMgJiYgdGhpcy5oYXNTY3JvbGxpbmdSZWdpb24pIHtcbiAgICAgICAgICAvLyBJZiB0aGUgaGVhZGVyIHNpemUgZG9lcyBub3QgY2hhbmdlIGFuZCB3ZSdyZSB1c2luZyBhIHNjcm9sbGluZyByZWdpb24sIGV4Y2x1ZGVcbiAgICAgICAgICAvLyB0aGUgaGVhZGVyIGFyZWEgZnJvbSB0aGUgc2Nyb2xsaW5nIHJlZ2lvbiBzbyB0aGF0IHRoZSBoZWFkZXIgZG9lc24ndCBvdmVybGFwXG4gICAgICAgICAgLy8gdGhlIHNjcm9sbGJhci5cbiAgICAgICAgICBjb250YWluZXJTdHlsZS5tYXJnaW5Ub3AgPSBoZWFkZXJIZWlnaHQgKyAncHgnO1xuICAgICAgICAgIGNvbnRhaW5lclN0eWxlLnBhZGRpbmdUb3AgPSAnJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb250YWluZXJTdHlsZS5wYWRkaW5nVG9wID0gaGVhZGVySGVpZ2h0ICsgJ3B4JztcbiAgICAgICAgICBjb250YWluZXJTdHlsZS5tYXJnaW5Ub3AgPSAnJztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgfSk7XG4gIDwvc2NyaXB0PlxuPC9kb20tbW9kdWxlPlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9hcHAtbGF5b3V0L2FwcC1oZWFkZXItbGF5b3V0L2FwcC1oZWFkZXItbGF5b3V0Lmh0bWwiLCJcbnJlcXVpcmUoJy4vZWZmZWN0cy9ibGVuZC1iYWNrZ3JvdW5kLmh0bWwnKTtcblxucmVxdWlyZSgnLi9lZmZlY3RzL2ZhZGUtYmFja2dyb3VuZC5odG1sJyk7XG5cbnJlcXVpcmUoJy4vZWZmZWN0cy9tYXRlcmlhbC5odG1sJyk7XG5cbnJlcXVpcmUoJy4vZWZmZWN0cy9wYXJhbGxheC1iYWNrZ3JvdW5kLmh0bWwnKTtcblxucmVxdWlyZSgnLi9lZmZlY3RzL3Jlc2l6ZS1zbmFwcGVkLXRpdGxlLmh0bWwnKTtcblxucmVxdWlyZSgnLi9lZmZlY3RzL3Jlc2l6ZS10aXRsZS5odG1sJyk7XG5cbnJlcXVpcmUoJy4vZWZmZWN0cy93YXRlcmZhbGwuaHRtbCcpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9hcHAtbGF5b3V0L2FwcC1zY3JvbGwtZWZmZWN0cy9hcHAtc2Nyb2xsLWVmZmVjdHMuaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTYgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cblxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL2FwcC1zY3JvbGwtZWZmZWN0cy1iZWhhdmlvci5odG1sXCI+XG5cbjxzY3JpcHQ+XG4gIC8qKlxuICAgKiBVcG9uIHNjcm9sbGluZyBwYXN0IGEgdGhyZXNob2xkLCBmYWRlIGluIHRoZSByZWFyIGJhY2tncm91bmQgbGF5ZXIgYW5kIGZhZGUgb3V0IHRoZSBmcm9udFxuICAgKiBiYWNrZ3JvdW5kIGxheWVyIChvcGFjaXR5IENTUyB0cmFuc2l0aW9uZWQgb3ZlciB0aW1lKS5cbiAgICpcbiAgICpcbiAgICovXG4gIFBvbHltZXIuQXBwTGF5b3V0LnJlZ2lzdGVyRWZmZWN0KCdmYWRlLWJhY2tncm91bmQnLCB7XG4gICAgLyoqIEB0aGlzIFBvbHltZXIuQXBwTGF5b3V0LkVsZW1lbnRXaXRoQmFja2dyb3VuZCAqL1xuICAgIHNldFVwOiBmdW5jdGlvbiBzZXRVcChjb25maWcpIHtcbiAgICAgIHZhciBmeCA9IHt9O1xuICAgICAgdmFyIGR1cmF0aW9uID0gY29uZmlnLmR1cmF0aW9uIHx8ICcwLjVzJztcbiAgICAgIGZ4LmJhY2tncm91bmRGcm9udExheWVyID0gdGhpcy5fZ2V0RE9NUmVmKCdiYWNrZ3JvdW5kRnJvbnRMYXllcicpO1xuICAgICAgZnguYmFja2dyb3VuZFJlYXJMYXllciA9IHRoaXMuX2dldERPTVJlZignYmFja2dyb3VuZFJlYXJMYXllcicpO1xuICAgICAgZnguYmFja2dyb3VuZEZyb250TGF5ZXIuc3R5bGUud2lsbENoYW5nZSA9ICdvcGFjaXR5JztcbiAgICAgIGZ4LmJhY2tncm91bmRGcm9udExheWVyLnN0eWxlLndlYmtpdFRyYW5zZm9ybSA9ICd0cmFuc2xhdGVaKDApJztcbiAgICAgIGZ4LmJhY2tncm91bmRGcm9udExheWVyLnN0eWxlLnRyYW5zaXRpb25Qcm9wZXJ0eSA9ICdvcGFjaXR5JztcbiAgICAgIGZ4LmJhY2tncm91bmRGcm9udExheWVyLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9IGR1cmF0aW9uO1xuICAgICAgZnguYmFja2dyb3VuZFJlYXJMYXllci5zdHlsZS53aWxsQ2hhbmdlID0gJ29wYWNpdHknO1xuICAgICAgZnguYmFja2dyb3VuZFJlYXJMYXllci5zdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSAndHJhbnNsYXRlWigwKSc7XG4gICAgICBmeC5iYWNrZ3JvdW5kUmVhckxheWVyLnN0eWxlLnRyYW5zaXRpb25Qcm9wZXJ0eSA9ICdvcGFjaXR5JztcbiAgICAgIGZ4LmJhY2tncm91bmRSZWFyTGF5ZXIuc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID0gZHVyYXRpb247XG4gICAgICB0aGlzLl9meEZhZGVCYWNrZ3JvdW5kID0gZng7XG4gICAgfSxcbiAgICAvKiogQHRoaXMgUG9seW1lci5BcHBMYXlvdXQuRWxlbWVudFdpdGhCYWNrZ3JvdW5kICovXG4gICAgcnVuOiBmdW5jdGlvbiBydW4ocCwgeSkge1xuICAgICAgdmFyIGZ4ID0gdGhpcy5fZnhGYWRlQmFja2dyb3VuZDtcbiAgICAgIGlmIChwID49IDEpIHtcbiAgICAgICAgZnguYmFja2dyb3VuZEZyb250TGF5ZXIuc3R5bGUub3BhY2l0eSA9IDA7XG4gICAgICAgIGZ4LmJhY2tncm91bmRSZWFyTGF5ZXIuc3R5bGUub3BhY2l0eSA9IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmeC5iYWNrZ3JvdW5kRnJvbnRMYXllci5zdHlsZS5vcGFjaXR5ID0gMTtcbiAgICAgICAgZnguYmFja2dyb3VuZFJlYXJMYXllci5zdHlsZS5vcGFjaXR5ID0gMDtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8qKiBAdGhpcyBQb2x5bWVyLkFwcExheW91dC5FbGVtZW50V2l0aEJhY2tncm91bmQgKi9cbiAgICB0ZWFyRG93bjogZnVuY3Rpb24gdGVhckRvd24oKSB7XG4gICAgICBkZWxldGUgdGhpcy5fZnhGYWRlQmFja2dyb3VuZDtcbiAgICB9XG4gIH0pO1xuPC9zY3JpcHQ+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL2FwcC1sYXlvdXQvYXBwLXNjcm9sbC1lZmZlY3RzL2VmZmVjdHMvZmFkZS1iYWNrZ3JvdW5kLmh0bWwiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi9hcHAtc2Nyb2xsLWVmZmVjdHMtYmVoYXZpb3IuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIndhdGVyZmFsbC5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwicmVzaXplLXRpdGxlLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCJibGVuZC1iYWNrZ3JvdW5kLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCJwYXJhbGxheC1iYWNrZ3JvdW5kLmh0bWxcIj5cblxuPHNjcmlwdD5cbiAgLyoqXG4gICAqIFNob3J0aGFuZCBmb3IgdGhlIHdhdGVyZmFsbCwgcmVzaXplLXRpdGxlLCBibGVuZC1iYWNrZ3JvdW5kLCBhbmQgcGFyYWxsYXgtYmFja2dyb3VuZCBlZmZlY3RzLlxuICAgKi9cbiAgUG9seW1lci5BcHBMYXlvdXQucmVnaXN0ZXJFZmZlY3QoJ21hdGVyaWFsJywge1xuICAgIC8qKlxuICAgICAqIEB0aGlzIFBvbHltZXIuQXBwTGF5b3V0LkVsZW1lbnRXaXRoQmFja2dyb3VuZFxuICAgICAqL1xuICAgIHNldFVwOiBmdW5jdGlvbiBzZXRVcCgpIHtcbiAgICAgIHRoaXMuZWZmZWN0cyA9ICd3YXRlcmZhbGwgcmVzaXplLXRpdGxlIGJsZW5kLWJhY2tncm91bmQgcGFyYWxsYXgtYmFja2dyb3VuZCc7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9KTtcbjwvc2NyaXB0PlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9hcHAtbGF5b3V0L2FwcC1zY3JvbGwtZWZmZWN0cy9lZmZlY3RzL21hdGVyaWFsLmh0bWwiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi9hcHAtc2Nyb2xsLWVmZmVjdHMtYmVoYXZpb3IuaHRtbFwiPlxuXG48c2NyaXB0PlxuICAvKipcbiAgICogVXBvbiBzY3JvbGxpbmcgcGFzdCBhIHRocmVzaG9sZCwgQ1NTIHRyYW5zaXRpb24gdGhlIGZvbnQgc2l6ZSBvZiBhIGRlc2lnbmF0ZWQgdGl0bGUgZWxlbWVudFxuICAgKiBiZXR3ZWVuIHR3byB2YWx1ZXMuXG4gICAqL1xuICBQb2x5bWVyLkFwcExheW91dC5yZWdpc3RlckVmZmVjdCgncmVzaXplLXNuYXBwZWQtdGl0bGUnLCB7XG4gICAgLyoqXG4gICAgICogQHRoaXMgUG9seW1lci5BcHBMYXlvdXQuRWxlbWVudFdpdGhCYWNrZ3JvdW5kXG4gICAgICovXG4gICAgc2V0VXA6IGZ1bmN0aW9uIHNldFVwKGNvbmZpZykge1xuICAgICAgdmFyIHRpdGxlID0gdGhpcy5fZ2V0RE9NUmVmKCdtYWluVGl0bGUnKTtcbiAgICAgIHZhciBjb25kZW5zZWRUaXRsZSA9IHRoaXMuX2dldERPTVJlZignY29uZGVuc2VkVGl0bGUnKTtcbiAgICAgIHZhciBkdXJhdGlvbiA9IGNvbmZpZy5kdXJhdGlvbiB8fCAnMC4ycyc7XG4gICAgICB2YXIgZnggPSB7fTtcblxuICAgICAgaWYgKCFjb25kZW5zZWRUaXRsZSkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1Njcm9sbCBlZmZlY3QgYHJlc2l6ZS1zbmFwcGVkLXRpdGxlYDogdW5kZWZpbmVkIGBjb25kZW5zZWQtdGl0bGVgJyk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICghdGl0bGUpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdTY3JvbGwgZWZmZWN0IGByZXNpemUtc25hcHBlZC10aXRsZWA6IHVuZGVmaW5lZCBgbWFpbi10aXRsZWAnKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB0aXRsZS5zdHlsZS50cmFuc2l0aW9uUHJvcGVydHkgPSAnb3BhY2l0eSc7XG4gICAgICB0aXRsZS5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPSBkdXJhdGlvbjtcbiAgICAgIGNvbmRlbnNlZFRpdGxlLnN0eWxlLnRyYW5zaXRpb25Qcm9wZXJ0eSA9ICdvcGFjaXR5JztcbiAgICAgIGNvbmRlbnNlZFRpdGxlLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9IGR1cmF0aW9uO1xuICAgICAgZnguY29uZGVuc2VkVGl0bGUgPSBjb25kZW5zZWRUaXRsZTtcbiAgICAgIGZ4LnRpdGxlID0gdGl0bGU7XG4gICAgICB0aGlzLl9meFJlc2l6ZVNuYXBwZWRUaXRsZSA9IGZ4O1xuICAgIH0sXG4gICAgLyoqIEB0aGlzIFBvbHltZXIuQXBwTGF5b3V0LkVsZW1lbnRXaXRoQmFja2dyb3VuZCAqL1xuICAgIHJ1bjogZnVuY3Rpb24gcnVuKHAsIHkpIHtcbiAgICAgIHZhciBmeCA9IHRoaXMuX2Z4UmVzaXplU25hcHBlZFRpdGxlO1xuICAgICAgaWYgKHAgPiAwKSB7XG4gICAgICAgIGZ4LnRpdGxlLnN0eWxlLm9wYWNpdHkgPSAwO1xuICAgICAgICBmeC5jb25kZW5zZWRUaXRsZS5zdHlsZS5vcGFjaXR5ID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZ4LnRpdGxlLnN0eWxlLm9wYWNpdHkgPSAxO1xuICAgICAgICBmeC5jb25kZW5zZWRUaXRsZS5zdHlsZS5vcGFjaXR5ID0gMDtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8qKiBAdGhpcyBQb2x5bWVyLkFwcExheW91dC5FbGVtZW50V2l0aEJhY2tncm91bmQgKi9cbiAgICB0ZWFyRG93bjogZnVuY3Rpb24gdGVhckRvd24oKSB7XG4gICAgICB2YXIgZnggPSB0aGlzLl9meFJlc2l6ZVNuYXBwZWRUaXRsZTtcbiAgICAgIGZ4LnRpdGxlLnN0eWxlLnRyYW5zaXRpb24gPSAnJztcbiAgICAgIGZ4LmNvbmRlbnNlZFRpdGxlLnN0eWxlLnRyYW5zaXRpb24gPSAnJztcbiAgICAgIGRlbGV0ZSB0aGlzLl9meFJlc2l6ZVNuYXBwZWRUaXRsZTtcbiAgICB9XG4gIH0pO1xuPC9zY3JpcHQ+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL2FwcC1sYXlvdXQvYXBwLXNjcm9sbC1lZmZlY3RzL2VmZmVjdHMvcmVzaXplLXNuYXBwZWQtdGl0bGUuaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTUgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cblxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uLy4uL3BvbHltZXIvcG9seW1lci5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vLi4vaXJvbi1mbGV4LWxheW91dC9pcm9uLWZsZXgtbGF5b3V0Lmh0bWxcIj5cblxuPCEtLVxuYXBwLXRvb2xiYXIgaXMgYSBob3Jpem9udGFsIHRvb2xiYXIgY29udGFpbmluZyBpdGVtcyB0aGF0IGNhbiBiZSB1c2VkIGZvclxubGFiZWwsIG5hdmlnYXRpb24sIHNlYXJjaCBhbmQgYWN0aW9ucy5cblxuIyMjIEV4YW1wbGVcblxuQWRkIGEgdGl0bGUgdG8gdGhlIHRvb2xiYXIuXG5cbmBgYGh0bWxcbjxhcHAtdG9vbGJhcj5cbiAgPGRpdiBtYWluLXRpdGxlPkFwcCBuYW1lPC9kaXY+XG48L2FwcC10b29sYmFyPlxuYGBgXG5cbkFkZCBhIGJ1dHRvbiB0byB0aGUgbGVmdCBhbmQgcmlnaHQgc2lkZSBvZiB0aGUgdG9vbGJhci5cblxuYGBgaHRtbFxuPGFwcC10b29sYmFyPlxuICA8cGFwZXItaWNvbi1idXR0b24gaWNvbj1cIm1lbnVcIj48L3BhcGVyLWljb24tYnV0dG9uPlxuICA8ZGl2IG1haW4tdGl0bGU+QXBwIG5hbWU8L2Rpdj5cbiAgPHBhcGVyLWljb24tYnV0dG9uIGljb249XCJzZWFyY2hcIj48L3BhcGVyLWljb24tYnV0dG9uPlxuPC9hcHAtdG9vbGJhcj5cbmBgYFxuXG5Zb3UgY2FuIHVzZSB0aGUgYXR0cmlidXRlcyBgdG9wLWl0ZW1gIG9yIGBib3R0b20taXRlbWAgdG8gY29tcGxldGVseSBmaXQgYW4gZWxlbWVudFxudG8gdGhlIHRvcCBvciBib3R0b20gb2YgdGhlIHRvb2xiYXIgcmVzcGVjdGl2ZWx5LlxuXG4jIyMgQ29udGVudCBhdHRyaWJ1dGVzXG5cbkF0dHJpYnV0ZSAgICAgICAgICAgIHwgRGVzY3JpcHRpb25cbi0tLS0tLS0tLS0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmBtYWluLXRpdGxlYCAgICAgICAgIHwgVGhlIG1haW4gdGl0bGUgZWxlbWVudC5cbmBjb25kZW5zZWQtdGl0bGVgICAgIHwgVGhlIHRpdGxlIGVsZW1lbnQgaWYgdXNlZCBpbnNpZGUgYSBjb25kZW5zZWQgYXBwLWhlYWRlci5cbmBzcGFjZXJgICAgICAgICAgICAgIHwgQWRkcyBhIGxlZnQgbWFyZ2luIG9mIGA2NHB4YC5cbmBib3R0b20taXRlbWAgICAgICAgIHwgU3RpY2tzIHRoZSBlbGVtZW50IHRvIHRoZSBib3R0b20gb2YgdGhlIHRvb2xiYXIuXG5gdG9wLWl0ZW1gICAgICAgICAgICB8IFN0aWNrcyB0aGUgZWxlbWVudCB0byB0aGUgdG9wIG9mIHRoZSB0b29sYmFyLlxuXG4jIyMgU3R5bGluZ1xuXG5DdXN0b20gcHJvcGVydHkgICAgICAgICAgICAgIHwgRGVzY3JpcHRpb24gICAgICAgICAgICAgICAgICB8IERlZmF1bHRcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuYC0tYXBwLXRvb2xiYXItZm9udC1zaXplYCAgICB8IFRvb2xiYXIgZm9udCBzaXplICAgICAgICAgICAgfCAyMHB4XG5cbkBncm91cCBBcHAgRWxlbWVudHNcbkBlbGVtZW50IGFwcC10b29sYmFyXG5AZGVtbyBhcHAtdG9vbGJhci9kZW1vL2luZGV4Lmh0bWxcbi0tPlxuXG48ZG9tLW1vZHVsZSBpZD1cImFwcC10b29sYmFyXCI+XG4gIDx0ZW1wbGF0ZT5cbiAgICA8c3R5bGU+XG5cbiAgICAgIDpob3N0IHtcbiAgICAgICAgQGFwcGx5IC0tbGF5b3V0LWhvcml6b250YWw7XG4gICAgICAgIEBhcHBseSAtLWxheW91dC1jZW50ZXI7XG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgaGVpZ2h0OiA2NHB4O1xuICAgICAgICBwYWRkaW5nOiAwIDE2cHg7XG4gICAgICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xuICAgICAgICBmb250LXNpemU6IHZhcigtLWFwcC10b29sYmFyLWZvbnQtc2l6ZSwgMjBweCk7XG4gICAgICB9XG5cbiAgICAgIDpob3N0IDo6c2xvdHRlZCgqKSB7XG4gICAgICAgIHBvaW50ZXItZXZlbnRzOiBhdXRvO1xuICAgICAgfVxuXG4gICAgICA6aG9zdCA6OnNsb3R0ZWQocGFwZXItaWNvbi1idXR0b24pIHtcbiAgICAgICAgLyogcGFwZXItaWNvbi1idXR0b24vaXNzdWVzLzMzICovXG4gICAgICAgIGZvbnQtc2l6ZTogMDtcbiAgICAgIH1cblxuICAgICAgOmhvc3QgOjpzbG90dGVkKFttYWluLXRpdGxlXSksXG4gICAgICA6aG9zdCA6OnNsb3R0ZWQoW2NvbmRlbnNlZC10aXRsZV0pIHtcbiAgICAgICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG4gICAgICAgIEBhcHBseSAtLWxheW91dC1mbGV4O1xuICAgICAgfVxuXG4gICAgICA6aG9zdCA6OnNsb3R0ZWQoW2JvdHRvbS1pdGVtXSkge1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIHJpZ2h0OiAwO1xuICAgICAgICBib3R0b206IDA7XG4gICAgICAgIGxlZnQ6IDA7XG4gICAgICB9XG5cbiAgICAgIDpob3N0IDo6c2xvdHRlZChbdG9wLWl0ZW1dKSB7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgdG9wOiAwO1xuICAgICAgICByaWdodDogMDtcbiAgICAgICAgbGVmdDogMDtcbiAgICAgIH1cblxuICAgICAgOmhvc3QgOjpzbG90dGVkKFtzcGFjZXJdKSB7XG4gICAgICAgIG1hcmdpbi1sZWZ0OiA2NHB4O1xuICAgICAgfVxuICAgIDwvc3R5bGU+XG5cbiAgICA8c2xvdD48L3Nsb3Q+XG5cbiAgPC90ZW1wbGF0ZT5cblxuICA8c2NyaXB0PlxuICAgIFBvbHltZXIoe1xuICAgICAgaXM6ICdhcHAtdG9vbGJhcidcbiAgICB9KTtcbiAgPC9zY3JpcHQ+XG48L2RvbS1tb2R1bGU+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL2FwcC1sYXlvdXQvYXBwLXRvb2xiYXIvYXBwLXRvb2xiYXIuaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTYgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi9wb2x5bWVyL3BvbHltZXIuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL2lyb24tbG9jYXRpb24vaXJvbi1sb2NhdGlvbi5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vaXJvbi1sb2NhdGlvbi9pcm9uLXF1ZXJ5LXBhcmFtcy5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiYXBwLXJvdXRlLWNvbnZlcnRlci1iZWhhdmlvci5odG1sXCI+XG5cbjwhLS1cbmBhcHAtbG9jYXRpb25gIGlzIGFuIGVsZW1lbnQgdGhhdCBwcm92aWRlcyBzeW5jaHJvbml6YXRpb24gYmV0d2VlbiB0aGVcbmJyb3dzZXIgbG9jYXRpb24gYmFyIGFuZCB0aGUgc3RhdGUgb2YgYW4gYXBwLiBXaGVuIGNyZWF0ZWQsIGBhcHAtbG9jYXRpb25gXG5lbGVtZW50cyB3aWxsIGF1dG9tYXRpY2FsbHkgd2F0Y2ggdGhlIGdsb2JhbCBsb2NhdGlvbiBmb3IgY2hhbmdlcy4gQXMgY2hhbmdlc1xub2NjdXIsIGBhcHAtbG9jYXRpb25gIHByb2R1Y2VzIGFuZCB1cGRhdGVzIGFuIG9iamVjdCBjYWxsZWQgYHJvdXRlYC4gVGhpc1xuYHJvdXRlYCBvYmplY3QgaXMgc3VpdGFibGUgZm9yIHBhc3NpbmcgaW50byBhIGBhcHAtcm91dGVgLCBhbmQgb3RoZXIgc2ltaWxhclxuZWxlbWVudHMuXG5cbkFuIGV4YW1wbGUgb2YgdGhlIHB1YmxpYyBBUEkgb2YgYSByb3V0ZSBvYmplY3QgdGhhdCBkZXNjcmliZXMgdGhlIFVSTFxuYGh0dHBzOi8vZWxlbWVudHMucG9seW1lci1wcm9qZWN0Lm9yZy9lbGVtZW50cy9hcHAtbG9jYXRpb25gOlxuXG4gICAge1xuICAgICAgcHJlZml4OiAnJyxcbiAgICAgIHBhdGg6ICcvZWxlbWVudHMvYXBwLWxvY2F0aW9uJ1xuICAgIH1cblxuRXhhbXBsZSBVc2FnZTpcblxuICAgIDxhcHAtbG9jYXRpb24gcm91dGU9XCJ7e3JvdXRlfX1cIj48L2FwcC1sb2NhdGlvbj5cbiAgICA8YXBwLXJvdXRlIHJvdXRlPVwie3tyb3V0ZX19XCIgcGF0dGVybj1cIi86cGFnZVwiIGRhdGE9XCJ7e2RhdGF9fVwiPjwvYXBwLXJvdXRlPlxuXG5BcyB5b3UgY2FuIHNlZSBhYm92ZSwgdGhlIGBhcHAtbG9jYXRpb25gIGVsZW1lbnQgcHJvZHVjZXMgYSBgcm91dGVgIGFuZCB0aGF0XG5wcm9wZXJ0eSBpcyB0aGVuIGJvdW5kIGludG8gdGhlIGBhcHAtcm91dGVgIGVsZW1lbnQuIFRoZSBiaW5kaW5ncyBhcmUgdHdvLVxuZGlyZWN0aW9uYWwsIHNvIHdoZW4gY2hhbmdlcyB0byB0aGUgYHJvdXRlYCBvYmplY3Qgb2NjdXIgd2l0aGluIGBhcHAtcm91dGVgLFxudGhleSBhdXRvbWF0aWNhbGx5IHJlZmxlY3QgYmFjayB0byB0aGUgZ2xvYmFsIGxvY2F0aW9uLlxuXG4jIyMgSGFzaGVzIHZzIFBhdGhzXG5cbkJ5IGRlZmF1bHQgYGFwcC1sb2NhdGlvbmAgcm91dGVzIHVzaW5nIHRoZSBwYXRobmFtZSBwb3J0aW9uIG9mIHRoZSBVUkwuIFRoaXMgaGFzXG5icm9hZCBicm93c2VyIHN1cHBvcnQgYnV0IGl0IGRvZXMgcmVxdWlyZSBjb29wZXJhdGlvbiBvZiB0aGUgYmFja2VuZCBzZXJ2ZXIuIEFuXG5gYXBwLWxvY2F0aW9uYCBjYW4gYmUgY29uZmlndXJlZCB0byB1c2UgdGhlIGhhc2ggcGFydCBvZiBhIFVSTCBpbnN0ZWFkIHVzaW5nXG50aGUgYHVzZS1oYXNoLWFzLXBhdGhgIGF0dHJpYnV0ZSwgbGlrZSBzbzpcblxuICAgIDxhcHAtbG9jYXRpb24gcm91dGU9XCJ7e3JvdXRlfX1cIiB1c2UtaGFzaC1hcy1wYXRoPjwvYXBwLWxvY2F0aW9uPlxuXG4jIyMgSW50ZWdyYXRpbmcgd2l0aCBvdGhlciByb3V0aW5nIGNvZGVcblxuVGhlcmUgaXMgbm8gc3RhbmRhcmQgZXZlbnQgdGhhdCBpcyBmaXJlZCB3aGVuIHdpbmRvdy5sb2NhdGlvbiBpcyBtb2RpZmllZC5cbmBhcHAtbG9jYXRpb25gIGZpcmVzIGEgYGxvY2F0aW9uLWNoYW5nZWRgIGV2ZW50IG9uIGB3aW5kb3dgIHdoZW4gaXQgdXBkYXRlcyB0aGVcbmxvY2F0aW9uLiBJdCBhbHNvIGxpc3RlbnMgZm9yIHRoYXQgc2FtZSBldmVudCwgYW5kIHJlLXJlYWRzIHRoZSBVUkwgd2hlbiBpdCdzXG5maXJlZC4gVGhpcyBtYWtlcyBpdCB2ZXJ5IGVhc3kgdG8gaW50ZXJvcCB3aXRoIG90aGVyIHJvdXRpbmcgY29kZS5cblxuU28gZm9yIGV4YW1wbGUgaWYgeW91IHdhbnQgdG8gbmF2aWdhdGUgdG8gYC9uZXdfcGF0aGAgaW1wZXJhdGl2ZWx5IHlvdSBjb3VsZFxuY2FsbCBgd2luZG93LmxvY2F0aW9uLnB1c2hTdGF0ZWAgb3IgYHdpbmRvdy5sb2NhdGlvbi5yZXBsYWNlU3RhdGVgIGZvbGxvd2VkIGJ5XG5maXJpbmcgYSBgbG9jYXRpb24tY2hhbmdlZGAgZXZlbnQgb24gYHdpbmRvd2AuIGkuZS5cblxuICAgIHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZSh7fSwgbnVsbCwgJy9uZXdfcGF0aCcpO1xuICAgIHdpbmRvdy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnbG9jYXRpb24tY2hhbmdlZCcpKTtcblxuQGVsZW1lbnQgYXBwLWxvY2F0aW9uXG5AZGVtbyBkZW1vL2luZGV4Lmh0bWxcbi0tPlxuPGRvbS1tb2R1bGUgaWQ9XCJhcHAtbG9jYXRpb25cIj5cbiAgPHRlbXBsYXRlPlxuICAgIDxpcm9uLXF1ZXJ5LXBhcmFtc1xuICAgICAgICBwYXJhbXMtc3RyaW5nPVwie3tfX3F1ZXJ5fX1cIlxuICAgICAgICBwYXJhbXMtb2JqZWN0PVwie3txdWVyeVBhcmFtc319XCI+XG4gICAgPC9pcm9uLXF1ZXJ5LXBhcmFtcz5cbiAgICA8aXJvbi1sb2NhdGlvblxuICAgICAgICBwYXRoPVwie3tfX3BhdGh9fVwiXG4gICAgICAgIHF1ZXJ5PVwie3tfX3F1ZXJ5fX1cIlxuICAgICAgICBoYXNoPVwie3tfX2hhc2h9fVwiXG4gICAgICAgIHVybC1zcGFjZS1yZWdleD17e3VybFNwYWNlUmVnZXh9fT5cbiAgICA8L2lyb24tbG9jYXRpb24+XG4gIDwvdGVtcGxhdGU+XG4gIDxzY3JpcHQ+XG4gICAgKGZ1bmN0aW9uKCkge1xuICAgICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgICBQb2x5bWVyKHtcbiAgICAgICAgaXM6ICdhcHAtbG9jYXRpb24nLFxuXG4gICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBBIG1vZGVsIHJlcHJlc2VudGluZyB0aGUgZGVzZXJpYWxpemVkIHBhdGggdGhyb3VnaCB0aGUgcm91dGUgdHJlZSwgYXNcbiAgICAgICAgICAgKiB3ZWxsIGFzIHRoZSBjdXJyZW50IHF1ZXJ5UGFyYW1zLlxuICAgICAgICAgICAqL1xuICAgICAgICAgIHJvdXRlOiB7XG4gICAgICAgICAgICB0eXBlOiBPYmplY3QsXG4gICAgICAgICAgICBub3RpZnk6IHRydWVcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogSW4gbWFueSBzY2VuYXJpb3MsIGl0IGlzIGNvbnZlbmllbnQgdG8gdHJlYXQgdGhlIGBoYXNoYCBhcyBhIHN0YW5kLWluXG4gICAgICAgICAgICogYWx0ZXJuYXRpdmUgdG8gdGhlIGBwYXRoYC4gRm9yIGV4YW1wbGUsIGlmIGRlcGxveWluZyBhbiBhcHAgdG8gYSBzdGF0aWNcbiAgICAgICAgICAgKiB3ZWIgc2VydmVyIChlLmcuLCBHaXRodWIgUGFnZXMpIC0gd2hlcmUgb25lIGRvZXMgbm90IGhhdmUgY29udHJvbCBvdmVyXG4gICAgICAgICAgICogc2VydmVyLXNpZGUgcm91dGluZyAtIGl0IGlzIHVzdWFsbHkgYSBiZXR0ZXIgZXhwZXJpZW5jZSB0byB1c2UgdGhlIGhhc2hcbiAgICAgICAgICAgKiB0byByZXByZXNlbnQgcGF0aHMgdGhyb3VnaCBvbmUncyBhcHAuXG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiBXaGVuIHRoaXMgcHJvcGVydHkgaXMgc2V0IHRvIHRydWUsIHRoZSBgaGFzaGAgd2lsbCBiZSB1c2VkIGluIHBsYWNlIG9mXG5cbiAgICAgICAgICAgKiB0aGUgYHBhdGhgIGZvciBnZW5lcmF0aW5nIGEgYHJvdXRlYC5cbiAgICAgICAgICAgKi9cbiAgICAgICAgICB1c2VIYXNoQXNQYXRoOiB7XG4gICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgICAgfSxcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIEEgcmVnZXhwIHRoYXQgZGVmaW5lcyB0aGUgc2V0IG9mIFVSTHMgdGhhdCBzaG91bGQgYmUgY29uc2lkZXJlZCBwYXJ0XG4gICAgICAgICAgICogb2YgdGhpcyB3ZWIgYXBwLlxuICAgICAgICAgICAqXG4gICAgICAgICAgICogQ2xpY2tpbmcgb24gYSBsaW5rIHRoYXQgbWF0Y2hlcyB0aGlzIHJlZ2V4IHdvbid0IHJlc3VsdCBpbiBhIGZ1bGwgcGFnZVxuICAgICAgICAgICAqIG5hdmlnYXRpb24sIGJ1dCB3aWxsIGluc3RlYWQganVzdCB1cGRhdGUgdGhlIFVSTCBzdGF0ZSBpbiBwbGFjZS5cbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIFRoaXMgcmVnZXhwIGlzIGdpdmVuIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIG9yaWdpbiBpbiBhbiBhYnNvbHV0ZVxuICAgICAgICAgICAqIFVSTC4gU28gdG8gbWF0Y2gganVzdCBVUkxzIHRoYXQgc3RhcnQgd2l0aCAvc2VhcmNoLyBkbzpcbiAgICAgICAgICAgKiAgICAgdXJsLXNwYWNlLXJlZ2V4PVwiXi9zZWFyY2gvXCJcbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIEB0eXBlIHtzdHJpbmd8UmVnRXhwfVxuICAgICAgICAgICAqL1xuICAgICAgICAgIHVybFNwYWNlUmVnZXg6IHtcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICAgIG5vdGlmeTogdHJ1ZVxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBBIHNldCBvZiBrZXkvdmFsdWUgcGFpcnMgdGhhdCBhcmUgdW5pdmVyc2FsbHkgYWNjZXNzaWJsZSB0byBicmFuY2hlc1xuICAgICAgICAgICAqIG9mIHRoZSByb3V0ZSB0cmVlLlxuICAgICAgICAgICAqL1xuICAgICAgICAgIF9fcXVlcnlQYXJhbXM6IHtcbiAgICAgICAgICAgIHR5cGU6IE9iamVjdFxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBUaGUgcGF0aG5hbWUgY29tcG9uZW50IG9mIHRoZSBjdXJyZW50IFVSTC5cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBfX3BhdGg6IHtcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZ1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBUaGUgcXVlcnkgc3RyaW5nIHBvcnRpb24gb2YgdGhlIGN1cnJlbnQgVVJMLlxuICAgICAgICAgICAqL1xuICAgICAgICAgIF9fcXVlcnk6IHtcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZ1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBUaGUgaGFzaCBwb3J0aW9uIG9mIHRoZSBjdXJyZW50IFVSTC5cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBfX2hhc2g6IHtcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZ1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBUaGUgcm91dGUgcGF0aCwgd2hpY2ggd2lsbCBiZSBlaXRoZXIgdGhlIGhhc2ggb3IgdGhlIHBhdGgsIGRlcGVuZGluZ1xuICAgICAgICAgICAqIG9uIHVzZUhhc2hBc1BhdGguXG4gICAgICAgICAgICovXG4gICAgICAgICAgcGF0aDoge1xuICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgICAgb2JzZXJ2ZXI6ICdfX29uUGF0aENoYW5nZWQnXG4gICAgICAgICAgfSxcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRoZSByZWFkeSBmdW5jdGlvbiBoYXMgYmVlbiBjYWxsZWQuXG4gICAgICAgICAgICovXG4gICAgICAgICAgX2lzUmVhZHk6IHtcbiAgICAgICAgICAgIHR5cGU6IEJvb2xlYW5cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgYmVoYXZpb3JzOiBbUG9seW1lci5BcHBSb3V0ZUNvbnZlcnRlckJlaGF2aW9yXSxcblxuICAgICAgICBvYnNlcnZlcnM6IFtcbiAgICAgICAgICAnX19jb21wdXRlUm91dGVQYXRoKHVzZUhhc2hBc1BhdGgsIF9faGFzaCwgX19wYXRoKSdcbiAgICAgICAgXSxcblxuICAgICAgICByZWFkeTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdGhpcy5faXNSZWFkeSA9IHRydWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX19jb21wdXRlUm91dGVQYXRoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB0aGlzLnBhdGggPSB0aGlzLnVzZUhhc2hBc1BhdGggPyB0aGlzLl9faGFzaCA6IHRoaXMuX19wYXRoO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9fb25QYXRoQ2hhbmdlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKCF0aGlzLl9pc1JlYWR5KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHRoaXMudXNlSGFzaEFzUGF0aCkge1xuICAgICAgICAgICAgdGhpcy5fX2hhc2ggPSB0aGlzLnBhdGg7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX19wYXRoID0gdGhpcy5wYXRoO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSkoKTtcbiAgPC9zY3JpcHQ+XG48L2RvbS1tb2R1bGU+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL2FwcC1yb3V0ZS9hcHAtbG9jYXRpb24uaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTUgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cblxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3BvbHltZXIvcG9seW1lci5odG1sXCI+XG5cbjwhLS1cblxuVGhlIGBpcm9uLWxvY2F0aW9uYCBlbGVtZW50IG1hbmFnZXMgYmluZGluZyB0byBhbmQgZnJvbSB0aGUgY3VycmVudCBVUkwuXG5cbmlyb24tbG9jYXRpb24gaXMgdGhlIGZpcnN0LCBhbmQgbG93ZXN0IGxldmVsIGVsZW1lbnQgaW4gdGhlIFBvbHltZXIgdGVhbSdzXG5yb3V0aW5nIHN5c3RlbS4gVGhpcyBpcyBhIGJldGEgcmVsZWFzZSBvZiBpcm9uLWxvY2F0aW9uIGFzIHdlIGNvbnRpbnVlIHdvcmtcbm9uIGhpZ2hlciBsZXZlbCBlbGVtZW50cywgYW5kIGFzIHN1Y2ggaXJvbi1sb2NhdGlvbiBtYXkgdW5kZXJnbyBicmVha2luZ1xuY2hhbmdlcy5cblxuIyMjIyBQcm9wZXJ0aWVzXG5cbldoZW4gdGhlIFVSTCBpczogYC9zZWFyY2g/cXVlcnk9NTgzI2RldGFpbHNgIGlyb24tbG9jYXRpb24ncyBwcm9wZXJ0aWVzIHdpbGwgYmU6XG5cbiAgLSBwYXRoOiBgJy9zZWFyY2gnYFxuICAtIHF1ZXJ5OiBgJ3F1ZXJ5PTU4MydgXG4gIC0gaGFzaDogYCdkZXRhaWxzJ2BcblxuVGhlc2UgYmluZGluZ3MgYXJlIGJpZGlyZWN0aW9uYWwuIE1vZGlmeWluZyB0aGVtIHdpbGwgaW4gdHVybiBtb2RpZnkgdGhlIFVSTC5cblxuaXJvbi1sb2NhdGlvbiBpcyBvbmx5IGFjdGl2ZSB3aGlsZSBpdCBpcyBhdHRhY2hlZCB0byB0aGUgZG9jdW1lbnQuXG5cbiMjIyMgTGlua3NcblxuV2hpbGUgaXJvbi1sb2NhdGlvbiBpcyBhY3RpdmUgaW4gdGhlIGRvY3VtZW50IGl0IHdpbGwgaW50ZXJjZXB0IGNsaWNrcyBvbiBsaW5rc1xud2l0aGluIHlvdXIgc2l0ZSwgdXBkYXRpbmcgdGhlIFVSTCBwdXNoaW5nIHRoZSB1cGRhdGVkIFVSTCBvdXQgdGhyb3VnaCB0aGVcbmRhdGFiaW5kaW5nIHN5c3RlbS4gaXJvbi1sb2NhdGlvbiBvbmx5IGludGVyY2VwdHMgY2xpY2tzIHdpdGggdGhlIGludGVudCB0b1xub3BlbiBpbiB0aGUgc2FtZSB3aW5kb3csIHNvIG1pZGRsZSBtb3VzZSBjbGlja3MgYW5kIGN0cmwvY21kIGNsaWNrcyB3b3JrIGZpbmUuXG5cbllvdSBjYW4gY3VzdG9taXplIHRoaXMgYmVoYXZpb3Igd2l0aCB0aGUgYHVybFNwYWNlUmVnZXhgLlxuXG4jIyMjIER3ZWxsIFRpbWVcblxuaXJvbi1sb2NhdGlvbiBwcm90ZWN0cyBhZ2FpbnN0IGFjY2lkZW50YWwgaGlzdG9yeSBzcGFtbWluZyBieSBvbmx5IGFkZGluZ1xuZW50cmllcyB0byB0aGUgdXNlcidzIGhpc3RvcnkgaWYgdGhlIFVSTCBzdGF5cyB1bmNoYW5nZWQgZm9yIGBkd2VsbFRpbWVgXG5taWxsaXNlY29uZHMuXG5cbkBkZW1vIGRlbW8vaW5kZXguaHRtbFxuXG4gLS0+XG48c2NyaXB0PlxuICAoZnVuY3Rpb24oKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIHdvcmtpbmdVUkw7XG5cbiAgICB2YXIgdXJsRG9jLCB1cmxCYXNlLCBhbmNob3I7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aFxuICAgICAqIEBwYXJhbSB7c3RyaW5nPX0gYmFzZVxuICAgICAqIEByZXR1cm4geyFVUkx8IUhUTUxBbmNob3JFbGVtZW50fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlc29sdmVVUkwocGF0aCwgYmFzZSkge1xuICAgICAgaWYgKHdvcmtpbmdVUkwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB3b3JraW5nVVJMID0gZmFsc2U7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIHUgPSBuZXcgVVJMKCdiJywgJ2h0dHA6Ly9hJyk7XG4gICAgICAgICAgdS5wYXRobmFtZSA9ICdjJTIwZCc7XG4gICAgICAgICAgd29ya2luZ1VSTCA9ICh1LmhyZWYgPT09ICdodHRwOi8vYS9jJTIwZCcpO1xuICAgICAgICAgIHdvcmtpbmdVUkwgPSB3b3JraW5nVVJMICYmIChuZXcgVVJMKCdodHRwOi8vd3d3Lmdvb2dsZS5jb20vP2ZvbyBiYXInKS5ocmVmID09PSAnaHR0cDovL3d3dy5nb29nbGUuY29tLz9mb28lMjBiYXInKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgIH1cbiAgICAgIGlmICh3b3JraW5nVVJMKSB7XG4gICAgICAgIHJldHVybiBuZXcgVVJMKHBhdGgsIGJhc2UpO1xuICAgICAgfVxuICAgICAgaWYgKCF1cmxEb2MpIHtcbiAgICAgICAgdXJsRG9jID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KCd1cmwnKTtcbiAgICAgICAgdXJsQmFzZSA9IHVybERvYy5jcmVhdGVFbGVtZW50KCdiYXNlJyk7XG4gICAgICAgIHVybERvYy5oZWFkLmFwcGVuZENoaWxkKHVybEJhc2UpO1xuICAgICAgICBhbmNob3IgPSAvKiogQHR5cGUge0hUTUxBbmNob3JFbGVtZW50fSovKHVybERvYy5jcmVhdGVFbGVtZW50KCdhJykpO1xuICAgICAgfVxuICAgICAgdXJsQmFzZS5ocmVmID0gYmFzZTtcbiAgICAgIGFuY2hvci5ocmVmID0gcGF0aC5yZXBsYWNlKC8gL2csICclMjAnKTtcbiAgICAgIHJldHVybiBhbmNob3I7XG4gICAgfVxuXG4gICAgUG9seW1lcih7XG4gICAgICBpczogJ2lyb24tbG9jYXRpb24nLFxuXG4gICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgcGF0aG5hbWUgY29tcG9uZW50IG9mIHRoZSBVUkwuXG4gICAgICAgICAqL1xuICAgICAgICBwYXRoOiB7XG4gICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgIG5vdGlmeTogdHJ1ZSxcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gd2luZG93LmRlY29kZVVSSUNvbXBvbmVudCh3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHF1ZXJ5IHN0cmluZyBwb3J0aW9uIG9mIHRoZSBVUkwuXG4gICAgICAgICAqL1xuICAgICAgICBxdWVyeToge1xuICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICBub3RpZnk6IHRydWUsXG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5sb2NhdGlvbi5zZWFyY2guc2xpY2UoMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgaGFzaCBjb21wb25lbnQgb2YgdGhlIFVSTC5cbiAgICAgICAgICovXG4gICAgICAgIGhhc2g6IHtcbiAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgbm90aWZ5OiB0cnVlLFxuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB3aW5kb3cuZGVjb2RlVVJJQ29tcG9uZW50KHdpbmRvdy5sb2NhdGlvbi5oYXNoLnNsaWNlKDEpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHRoZSB1c2VyIHdhcyBvbiBhIFVSTCBmb3IgbGVzcyB0aGFuIGBkd2VsbFRpbWVgIG1pbGxpc2Vjb25kcywgaXRcbiAgICAgICAgICogd29uJ3QgYmUgYWRkZWQgdG8gdGhlIGJyb3dzZXIncyBoaXN0b3J5LCBidXQgaW5zdGVhZCB3aWxsIGJlIHJlcGxhY2VkXG4gICAgICAgICAqIGJ5IHRoZSBuZXh0IGVudHJ5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIGlzIHRvIHByZXZlbnQgbGFyZ2UgbnVtYmVycyBvZiBlbnRyaWVzIGZyb20gY2xvZ2dpbmcgdXAgdGhlIHVzZXInc1xuICAgICAgICAgKiBicm93c2VyIGhpc3RvcnkuIERpc2FibGUgYnkgc2V0dGluZyB0byBhIG5lZ2F0aXZlIG51bWJlci5cbiAgICAgICAgICovXG4gICAgICAgIGR3ZWxsVGltZToge1xuICAgICAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgICAgICB2YWx1ZTogMjAwMFxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHJlZ2V4cCB0aGF0IGRlZmluZXMgdGhlIHNldCBvZiBVUkxzIHRoYXQgc2hvdWxkIGJlIGNvbnNpZGVyZWQgcGFydFxuICAgICAgICAgKiBvZiB0aGlzIHdlYiBhcHAuXG4gICAgICAgICAqXG4gICAgICAgICAqIENsaWNraW5nIG9uIGEgbGluayB0aGF0IG1hdGNoZXMgdGhpcyByZWdleCB3b24ndCByZXN1bHQgaW4gYSBmdWxsIHBhZ2VcbiAgICAgICAgICogbmF2aWdhdGlvbiwgYnV0IHdpbGwgaW5zdGVhZCBqdXN0IHVwZGF0ZSB0aGUgVVJMIHN0YXRlIGluIHBsYWNlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIHJlZ2V4cCBpcyBnaXZlbiBldmVyeXRoaW5nIGFmdGVyIHRoZSBvcmlnaW4gaW4gYW4gYWJzb2x1dGVcbiAgICAgICAgICogVVJMLiBTbyB0byBtYXRjaCBqdXN0IFVSTHMgdGhhdCBzdGFydCB3aXRoIC9zZWFyY2gvIGRvOlxuICAgICAgICAgKiAgICAgdXJsLXNwYWNlLXJlZ2V4PVwiXi9zZWFyY2gvXCJcbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUge3N0cmluZ3xSZWdFeHB9XG4gICAgICAgICAqL1xuICAgICAgICB1cmxTcGFjZVJlZ2V4OiB7XG4gICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgIHZhbHVlOiAnJ1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiB1cmxTcGFjZVJlZ2V4LCBidXQgY29lcmNlZCBpbnRvIGEgcmVnZXhwLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7UmVnRXhwfVxuICAgICAgICAgKi9cbiAgICAgICAgX3VybFNwYWNlUmVnRXhwOiB7XG4gICAgICAgICAgY29tcHV0ZWQ6ICdfbWFrZVJlZ0V4cCh1cmxTcGFjZVJlZ2V4KSdcbiAgICAgICAgfSxcblxuICAgICAgICBfbGFzdENoYW5nZWRBdDoge1xuICAgICAgICAgIHR5cGU6IE51bWJlclxuICAgICAgICB9LFxuXG4gICAgICAgIF9pbml0aWFsaXplZDoge1xuICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIGhvc3RBdHRyaWJ1dGVzOiB7XG4gICAgICAgIGhpZGRlbjogdHJ1ZVxuICAgICAgfSxcblxuICAgICAgb2JzZXJ2ZXJzOiBbXG4gICAgICAgICdfdXBkYXRlVXJsKHBhdGgsIHF1ZXJ5LCBoYXNoKSdcbiAgICAgIF0sXG5cbiAgICAgIGF0dGFjaGVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5saXN0ZW4od2luZG93LCAnaGFzaGNoYW5nZScsICdfaGFzaENoYW5nZWQnKTtcbiAgICAgICAgdGhpcy5saXN0ZW4od2luZG93LCAnbG9jYXRpb24tY2hhbmdlZCcsICdfdXJsQ2hhbmdlZCcpO1xuICAgICAgICB0aGlzLmxpc3Rlbih3aW5kb3csICdwb3BzdGF0ZScsICdfdXJsQ2hhbmdlZCcpO1xuICAgICAgICB0aGlzLmxpc3RlbigvKiogQHR5cGUgeyFIVE1MQm9keUVsZW1lbnR9ICovKGRvY3VtZW50LmJvZHkpLCAnY2xpY2snLCAnX2dsb2JhbE9uQ2xpY2snKTtcbiAgICAgICAgLy8gR2l2ZSBhIDIwMG1zIGdyYWNlIHBlcmlvZCB0byBtYWtlIGluaXRpYWwgcmVkaXJlY3RzIHdpdGhvdXQgYW55XG4gICAgICAgIC8vIGFkZGl0aW9ucyB0byB0aGUgdXNlcidzIGhpc3RvcnkuXG4gICAgICAgIHRoaXMuX2xhc3RDaGFuZ2VkQXQgPSB3aW5kb3cucGVyZm9ybWFuY2Uubm93KCkgLSAodGhpcy5kd2VsbFRpbWUgLSAyMDApO1xuICAgICAgICB0aGlzLl9pbml0aWFsaXplZCA9IHRydWU7XG5cbiAgICAgICAgdGhpcy5fdXJsQ2hhbmdlZCgpO1xuICAgICAgfSxcblxuICAgICAgZGV0YWNoZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnVubGlzdGVuKHdpbmRvdywgJ2hhc2hjaGFuZ2UnLCAnX2hhc2hDaGFuZ2VkJyk7XG4gICAgICAgIHRoaXMudW5saXN0ZW4od2luZG93LCAnbG9jYXRpb24tY2hhbmdlZCcsICdfdXJsQ2hhbmdlZCcpO1xuICAgICAgICB0aGlzLnVubGlzdGVuKHdpbmRvdywgJ3BvcHN0YXRlJywgJ191cmxDaGFuZ2VkJyk7XG4gICAgICAgIHRoaXMudW5saXN0ZW4oLyoqIEB0eXBlIHshSFRNTEJvZHlFbGVtZW50fSAqLyhkb2N1bWVudC5ib2R5KSwgJ2NsaWNrJywgJ19nbG9iYWxPbkNsaWNrJyk7XG4gICAgICAgIHRoaXMuX2luaXRpYWxpemVkID0gZmFsc2U7XG4gICAgICB9LFxuXG4gICAgICBfaGFzaENoYW5nZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmhhc2ggPSB3aW5kb3cuZGVjb2RlVVJJQ29tcG9uZW50KHdpbmRvdy5sb2NhdGlvbi5oYXNoLnN1YnN0cmluZygxKSk7XG4gICAgICB9LFxuXG4gICAgICBfdXJsQ2hhbmdlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIFdlIHdhbnQgdG8gZXh0cmFjdCBhbGwgaW5mbyBvdXQgb2YgdGhlIHVwZGF0ZWQgVVJMIGJlZm9yZSB3ZVxuICAgICAgICAvLyB0cnkgdG8gd3JpdGUgYW55dGhpbmcgYmFjayBpbnRvIGl0LlxuICAgICAgICAvL1xuICAgICAgICAvLyBpLmUuIHdpdGhvdXQgX2RvbnRVcGRhdGVVcmwgd2UnZCBvdmVyd3JpdGUgdGhlIG5ldyBwYXRoIHdpdGggdGhlIG9sZFxuICAgICAgICAvLyBvbmUgd2hlbiB3ZSBzZXQgdGhpcy5oYXNoLiBMaWtld2lzZSBmb3IgcXVlcnkuXG4gICAgICAgIHRoaXMuX2RvbnRVcGRhdGVVcmwgPSB0cnVlO1xuICAgICAgICB0aGlzLl9oYXNoQ2hhbmdlZCgpO1xuICAgICAgICB0aGlzLnBhdGggPSB3aW5kb3cuZGVjb2RlVVJJQ29tcG9uZW50KHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSk7XG4gICAgICAgIHRoaXMucXVlcnkgPSB3aW5kb3cubG9jYXRpb24uc2VhcmNoLnN1YnN0cmluZygxKTtcbiAgICAgICAgdGhpcy5fZG9udFVwZGF0ZVVybCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl91cGRhdGVVcmwoKTtcbiAgICAgIH0sXG5cbiAgICAgIF9nZXRVcmw6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcGFydGlhbGx5RW5jb2RlZFBhdGggPSB3aW5kb3cuZW5jb2RlVVJJKFxuICAgICAgICAgICAgdGhpcy5wYXRoKS5yZXBsYWNlKC9cXCMvZywgJyUyMycpLnJlcGxhY2UoL1xcPy9nLCAnJTNGJyk7XG4gICAgICAgIHZhciBwYXJ0aWFsbHlFbmNvZGVkUXVlcnkgPSAnJztcbiAgICAgICAgaWYgKHRoaXMucXVlcnkpIHtcbiAgICAgICAgICBwYXJ0aWFsbHlFbmNvZGVkUXVlcnkgPSAnPycgKyB0aGlzLnF1ZXJ5LnJlcGxhY2UoL1xcIy9nLCAnJTIzJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBhcnRpYWxseUVuY29kZWRIYXNoID0gJyc7XG4gICAgICAgIGlmICh0aGlzLmhhc2gpIHtcbiAgICAgICAgICBwYXJ0aWFsbHlFbmNvZGVkSGFzaCA9ICcjJyArIHdpbmRvdy5lbmNvZGVVUkkodGhpcy5oYXNoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgcGFydGlhbGx5RW5jb2RlZFBhdGggKyBwYXJ0aWFsbHlFbmNvZGVkUXVlcnkgKyBwYXJ0aWFsbHlFbmNvZGVkSGFzaCk7XG4gICAgICB9LFxuXG4gICAgICBfdXBkYXRlVXJsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RvbnRVcGRhdGVVcmwgfHwgIXRoaXMuX2luaXRpYWxpemVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMucGF0aCA9PT0gd2luZG93LmRlY29kZVVSSUNvbXBvbmVudCh3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUpICYmXG4gICAgICAgICAgICB0aGlzLnF1ZXJ5ID09PSB3aW5kb3cubG9jYXRpb24uc2VhcmNoLnN1YnN0cmluZygxKSAmJlxuICAgICAgICAgICAgdGhpcy5oYXNoID09PSB3aW5kb3cuZGVjb2RlVVJJQ29tcG9uZW50KFxuICAgICAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5oYXNoLnN1YnN0cmluZygxKSkpIHtcbiAgICAgICAgICAvLyBOb3RoaW5nIHRvIGRvLCB0aGUgY3VycmVudCBVUkwgaXMgYSByZXByZXNlbnRhdGlvbiBvZiBvdXIgcHJvcGVydGllcy5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbmV3VXJsID0gdGhpcy5fZ2V0VXJsKCk7XG4gICAgICAgIC8vIE5lZWQgdG8gdXNlIGEgZnVsbCBVUkwgaW4gY2FzZSB0aGUgY29udGFpbmluZyBwYWdlIGhhcyBhIGJhc2UgVVJJLlxuICAgICAgICB2YXIgZnVsbE5ld1VybCA9IHJlc29sdmVVUkwobmV3VXJsLCB3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wgKyAnLy8nICsgd2luZG93LmxvY2F0aW9uLmhvc3QpLmhyZWY7XG4gICAgICAgIHZhciBub3cgPSB3aW5kb3cucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIHZhciBzaG91bGRSZXBsYWNlID0gdGhpcy5fbGFzdENoYW5nZWRBdCArIHRoaXMuZHdlbGxUaW1lID4gbm93O1xuICAgICAgICB0aGlzLl9sYXN0Q2hhbmdlZEF0ID0gbm93O1xuXG4gICAgICAgIGlmIChzaG91bGRSZXBsYWNlKSB7XG4gICAgICAgICAgd2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlKHt9LCAnJywgZnVsbE5ld1VybCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2luZG93Lmhpc3RvcnkucHVzaFN0YXRlKHt9LCAnJywgZnVsbE5ld1VybCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmZpcmUoJ2xvY2F0aW9uLWNoYW5nZWQnLCB7fSwge25vZGU6IHdpbmRvd30pO1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBBIG5lY2Vzc2FyeSBldmlsIHNvIHRoYXQgbGlua3Mgd29yayBhcyBleHBlY3RlZC4gRG9lcyBpdHMgYmVzdCB0b1xuICAgICAgICogYmFpbCBvdXQgZWFybHkgaWYgcG9zc2libGUuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBldmVudCAuXG4gICAgICAgKi9cbiAgICAgIF9nbG9iYWxPbkNsaWNrOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAvLyBJZiBhbm90aGVyIGV2ZW50IGhhbmRsZXIgaGFzIHN0b3BwZWQgdGhpcyBldmVudCB0aGVuIHRoZXJlJ3Mgbm90aGluZ1xuICAgICAgICAvLyBmb3IgdXMgdG8gZG8uIFRoaXMgY2FuIGhhcHBlbiBlLmcuIHdoZW4gdGhlcmUgYXJlIG11bHRpcGxlXG4gICAgICAgIC8vIGlyb24tbG9jYXRpb24gZWxlbWVudHMgaW4gYSBwYWdlLlxuICAgICAgICBpZiAoZXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBocmVmID0gdGhpcy5fZ2V0U2FtZU9yaWdpbkxpbmtIcmVmKGV2ZW50KTtcblxuICAgICAgICBpZiAoIWhyZWYpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIC8vIElmIHRoZSBuYXZpZ2F0aW9uIGlzIHRvIHRoZSBjdXJyZW50IHBhZ2Ugd2Ugc2hvdWxkbid0IGFkZCBhIGhpc3RvcnlcbiAgICAgICAgLy8gZW50cnkgb3IgZmlyZSBhIGNoYW5nZSBldmVudC5cbiAgICAgICAgaWYgKGhyZWYgPT09IHdpbmRvdy5sb2NhdGlvbi5ocmVmKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgd2luZG93Lmhpc3RvcnkucHVzaFN0YXRlKHt9LCAnJywgaHJlZik7XG4gICAgICAgIHRoaXMuZmlyZSgnbG9jYXRpb24tY2hhbmdlZCcsIHt9LCB7bm9kZTogd2luZG93fSk7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFJldHVybnMgdGhlIGFic29sdXRlIFVSTCBvZiB0aGUgbGluayAoaWYgYW55KSB0aGF0IHRoaXMgY2xpY2sgZXZlbnRcbiAgICAgICAqIGlzIGNsaWNraW5nIG9uLCBpZiB3ZSBjYW4gYW5kIHNob3VsZCBvdmVycmlkZSB0aGUgcmVzdWx0aW5nIGZ1bGxcbiAgICAgICAqIHBhZ2UgbmF2aWdhdGlvbi4gUmV0dXJucyBudWxsIG90aGVyd2lzZS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGV2ZW50IC5cbiAgICAgICAqIEByZXR1cm4ge3N0cmluZz99IC5cbiAgICAgICAqL1xuICAgICAgX2dldFNhbWVPcmlnaW5MaW5rSHJlZjogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgLy8gV2Ugb25seSBjYXJlIGFib3V0IGxlZnQtY2xpY2tzLlxuICAgICAgICBpZiAoZXZlbnQuYnV0dG9uICE9PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBXZSBkb24ndCB3YW50IG1vZGlmaWVkIGNsaWNrcywgd2hlcmUgdGhlIGludGVudCBpcyB0byBvcGVuIHRoZSBwYWdlXG4gICAgICAgIC8vIGluIGEgbmV3IHRhYi5cbiAgICAgICAgaWYgKGV2ZW50Lm1ldGFLZXkgfHwgZXZlbnQuY3RybEtleSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGV2ZW50UGF0aCA9IFBvbHltZXIuZG9tKGV2ZW50KS5wYXRoO1xuICAgICAgICB2YXIgYW5jaG9yID0gbnVsbDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV2ZW50UGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBlbGVtZW50ID0gZXZlbnRQYXRoW2ldO1xuXG4gICAgICAgICAgaWYgKGVsZW1lbnQudGFnTmFtZSA9PT0gJ0EnICYmIGVsZW1lbnQuaHJlZikge1xuICAgICAgICAgICAgYW5jaG9yID0gZWxlbWVudDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHRoZXJlJ3Mgbm8gbGluayB0aGVyZSdzIG5vdGhpbmcgdG8gZG8uXG4gICAgICAgIGlmICghYW5jaG9yKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUYXJnZXQgYmxhbmsgaXMgYSBuZXcgdGFiLCBkb24ndCBpbnRlcmNlcHQuXG4gICAgICAgIGlmIChhbmNob3IudGFyZ2V0ID09PSAnX2JsYW5rJykge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgdGhlIGxpbmsgaXMgZm9yIGFuIGV4aXN0aW5nIHBhcmVudCBmcmFtZSwgZG9uJ3QgaW50ZXJjZXB0LlxuICAgICAgICBpZiAoKGFuY2hvci50YXJnZXQgPT09ICdfdG9wJyB8fFxuICAgICAgICAgICAgYW5jaG9yLnRhcmdldCA9PT0gJ19wYXJlbnQnKSAmJlxuICAgICAgICAgICAgd2luZG93LnRvcCAhPT0gd2luZG93KSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaHJlZiA9IGFuY2hvci5ocmVmO1xuXG4gICAgICAgIC8vIEl0IG9ubHkgbWFrZXMgc2Vuc2UgZm9yIHVzIHRvIGludGVyY2VwdCBzYW1lLW9yaWdpbiBuYXZpZ2F0aW9ucy5cbiAgICAgICAgLy8gcHVzaFN0YXRlL3JlcGxhY2VTdGF0ZSBkb24ndCB3b3JrIHdpdGggY3Jvc3Mtb3JpZ2luIGxpbmtzLlxuICAgICAgICB2YXIgdXJsO1xuXG4gICAgICAgIGlmIChkb2N1bWVudC5iYXNlVVJJICE9IG51bGwpIHtcbiAgICAgICAgICB1cmwgPSByZXNvbHZlVVJMKGhyZWYsIC8qKiBAdHlwZSB7c3RyaW5nfSAqLyhkb2N1bWVudC5iYXNlVVJJKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdXJsID0gcmVzb2x2ZVVSTChocmVmKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBvcmlnaW47XG5cbiAgICAgICAgLy8gSUUgUG9seWZpbGxcbiAgICAgICAgaWYgKHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4pIHtcbiAgICAgICAgICBvcmlnaW4gPSB3aW5kb3cubG9jYXRpb24ub3JpZ2luO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9yaWdpbiA9IHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCArICcvLycgKyB3aW5kb3cubG9jYXRpb24uaG9zdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB1cmxPcmlnaW47XG5cbiAgICAgICAgaWYgKHVybC5vcmlnaW4pIHtcbiAgICAgICAgICB1cmxPcmlnaW4gPSB1cmwub3JpZ2luO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHVybE9yaWdpbiA9IHVybC5wcm90b2NvbCArICcvLycgKyB1cmwuaG9zdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh1cmxPcmlnaW4gIT09IG9yaWdpbikge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5vcm1hbGl6ZWRIcmVmID0gdXJsLnBhdGhuYW1lICsgdXJsLnNlYXJjaCArIHVybC5oYXNoO1xuXG4gICAgICAgIC8vIHBhdGhuYW1lIHNob3VsZCBzdGFydCB3aXRoICcvJywgYnV0IG1heSBub3QgaWYgYG5ldyBVUkxgIGlzIG5vdCBzdXBwb3J0ZWRcbiAgICAgICAgaWYgKG5vcm1hbGl6ZWRIcmVmWzBdICE9PSAnLycpIHtcbiAgICAgICAgICBub3JtYWxpemVkSHJlZiA9ICcvJyArIG5vcm1hbGl6ZWRIcmVmO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgd2UndmUgYmVlbiBjb25maWd1cmVkIG5vdCB0byBoYW5kbGUgdGhpcyB1cmwuLi4gZG9uJ3QgaGFuZGxlIGl0IVxuICAgICAgICBpZiAodGhpcy5fdXJsU3BhY2VSZWdFeHAgJiZcbiAgICAgICAgICAgICF0aGlzLl91cmxTcGFjZVJlZ0V4cC50ZXN0KG5vcm1hbGl6ZWRIcmVmKSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTmVlZCB0byB1c2UgYSBmdWxsIFVSTCBpbiBjYXNlIHRoZSBjb250YWluaW5nIHBhZ2UgaGFzIGEgYmFzZSBVUkkuXG4gICAgICAgIHZhciBmdWxsTm9ybWFsaXplZEhyZWYgPSByZXNvbHZlVVJMKFxuICAgICAgICAgICAgbm9ybWFsaXplZEhyZWYsIHdpbmRvdy5sb2NhdGlvbi5ocmVmKS5ocmVmO1xuICAgICAgICByZXR1cm4gZnVsbE5vcm1hbGl6ZWRIcmVmO1xuICAgICAgfSxcblxuICAgICAgX21ha2VSZWdFeHA6IGZ1bmN0aW9uKHVybFNwYWNlUmVnZXgpIHtcbiAgICAgICAgcmV0dXJuIFJlZ0V4cCh1cmxTcGFjZVJlZ2V4KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSkoKTtcbjwvc2NyaXB0PlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9pcm9uLWxvY2F0aW9uL2lyb24tbG9jYXRpb24uaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTUgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG5cbkBkZW1vIGRlbW8vaXJvbi1xdWVyeS1wYXJhbXMuaHRtbFxuLS0+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vcG9seW1lci9wb2x5bWVyLmh0bWxcIj5cblxuPHNjcmlwdD5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIFBvbHltZXIoe1xuICAgIGlzOiAnaXJvbi1xdWVyeS1wYXJhbXMnLFxuXG4gICAgcHJvcGVydGllczoge1xuICAgICAgcGFyYW1zU3RyaW5nOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgbm90aWZ5OiB0cnVlLFxuICAgICAgICBvYnNlcnZlcjogJ3BhcmFtc1N0cmluZ0NoYW5nZWQnLFxuICAgICAgfSxcblxuICAgICAgcGFyYW1zT2JqZWN0OiB7XG4gICAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgICAgbm90aWZ5OiB0cnVlLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBfZG9udFJlYWN0OiB7XG4gICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBob3N0QXR0cmlidXRlczoge1xuICAgICAgaGlkZGVuOiB0cnVlXG4gICAgfSxcblxuICAgIG9ic2VydmVyczogW1xuICAgICAgJ3BhcmFtc09iamVjdENoYW5nZWQocGFyYW1zT2JqZWN0LiopJ1xuICAgIF0sXG5cbiAgICBwYXJhbXNTdHJpbmdDaGFuZ2VkOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX2RvbnRSZWFjdCA9IHRydWU7XG4gICAgICB0aGlzLnBhcmFtc09iamVjdCA9IHRoaXMuX2RlY29kZVBhcmFtcyh0aGlzLnBhcmFtc1N0cmluZyk7XG4gICAgICB0aGlzLl9kb250UmVhY3QgPSBmYWxzZTtcbiAgICB9LFxuXG4gICAgcGFyYW1zT2JqZWN0Q2hhbmdlZDogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5fZG9udFJlYWN0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMucGFyYW1zU3RyaW5nID0gdGhpcy5fZW5jb2RlUGFyYW1zKHRoaXMucGFyYW1zT2JqZWN0KVxuICAgICAgICAgIC5yZXBsYWNlKC8lM0YvZywgJz8nKS5yZXBsYWNlKC8lMkYvZywgJy8nKS5yZXBsYWNlKC8nL2csICclMjcnKTtcbiAgICB9LFxuXG4gICAgX2VuY29kZVBhcmFtczogZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICB2YXIgZW5jb2RlZFBhcmFtcyA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHBhcmFtc1trZXldO1xuXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gJycpIHtcbiAgICAgICAgICBlbmNvZGVkUGFyYW1zLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KGtleSkpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUpIHtcbiAgICAgICAgICBlbmNvZGVkUGFyYW1zLnB1c2goXG4gICAgICAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChrZXkpICtcbiAgICAgICAgICAgICAgJz0nICtcbiAgICAgICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlLnRvU3RyaW5nKCkpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGVuY29kZWRQYXJhbXMuam9pbignJicpO1xuICAgIH0sXG5cbiAgICBfZGVjb2RlUGFyYW1zOiBmdW5jdGlvbihwYXJhbVN0cmluZykge1xuICAgICAgdmFyIHBhcmFtcyA9IHt9O1xuICAgICAgLy8gV29yayBhcm91bmQgYSBidWcgaW4gZGVjb2RlVVJJQ29tcG9uZW50IHdoZXJlICsgaXMgbm90XG4gICAgICAvLyBjb252ZXJ0ZWQgdG8gc3BhY2VzOlxuICAgICAgcGFyYW1TdHJpbmcgPSAocGFyYW1TdHJpbmcgfHwgJycpLnJlcGxhY2UoL1xcKy9nLCAnJTIwJyk7XG4gICAgICB2YXIgcGFyYW1MaXN0ID0gcGFyYW1TdHJpbmcuc3BsaXQoJyYnKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyYW1MaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwYXJhbSA9IHBhcmFtTGlzdFtpXS5zcGxpdCgnPScpO1xuICAgICAgICBpZiAocGFyYW1bMF0pIHtcbiAgICAgICAgICBwYXJhbXNbZGVjb2RlVVJJQ29tcG9uZW50KHBhcmFtWzBdKV0gPVxuICAgICAgICAgICAgICBkZWNvZGVVUklDb21wb25lbnQocGFyYW1bMV0gfHwgJycpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFyYW1zO1xuICAgIH1cbiAgfSk7XG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvaXJvbi1sb2NhdGlvbi9pcm9uLXF1ZXJ5LXBhcmFtcy5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNiBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuPHNjcmlwdD5cbiAgKGZ1bmN0aW9uKCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIC8qKlxuICAgICAqIFByb3ZpZGVzIGJpZGlyZWN0aW9uYWwgbWFwcGluZyBiZXR3ZWVuIGBwYXRoYCBhbmQgYHF1ZXJ5UGFyYW1zYCBhbmQgYVxuICAgICAqIGFwcC1yb3V0ZSBjb21wYXRpYmxlIGByb3V0ZWAgb2JqZWN0LlxuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZSB0aGUgZG9jcyBmb3IgYGFwcC1yb3V0ZS1jb252ZXJ0ZXJgLlxuICAgICAqXG4gICAgICogQHBvbHltZXJCZWhhdmlvclxuICAgICAqL1xuICAgIFBvbHltZXIuQXBwUm91dGVDb252ZXJ0ZXJCZWhhdmlvciA9IHtcbiAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgbW9kZWwgcmVwcmVzZW50aW5nIHRoZSBkZXNlcmlhbGl6ZWQgcGF0aCB0aHJvdWdoIHRoZSByb3V0ZSB0cmVlLCBhc1xuICAgICAgICAgKiB3ZWxsIGFzIHRoZSBjdXJyZW50IHF1ZXJ5UGFyYW1zLlxuICAgICAgICAgKlxuICAgICAgICAgKiBBIHJvdXRlIG9iamVjdCBpcyB0aGUga2VybmVsIG9mIHRoZSByb3V0aW5nIHN5c3RlbS4gSXQgaXMgaW50ZW5kZWQgdG9cbiAgICAgICAgICogYmUgZmVkIGludG8gY29uc3VtaW5nIGVsZW1lbnRzIHN1Y2ggYXMgYGFwcC1yb3V0ZWAuXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHs/T2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgcm91dGU6IHtcbiAgICAgICAgICB0eXBlOiBPYmplY3QsXG4gICAgICAgICAgbm90aWZ5OiB0cnVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgc2V0IG9mIGtleS92YWx1ZSBwYWlycyB0aGF0IGFyZSB1bml2ZXJzYWxseSBhY2Nlc3NpYmxlIHRvIGJyYW5jaGVzIG9mXG4gICAgICAgICAqIHRoZSByb3V0ZSB0cmVlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7P09iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIHF1ZXJ5UGFyYW1zOiB7XG4gICAgICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgICAgIG5vdGlmeTogdHJ1ZVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgc2VyaWFsaXplZCBwYXRoIHRocm91Z2ggdGhlIHJvdXRlIHRyZWUuIFRoaXMgY29ycmVzcG9uZHMgdG8gdGhlXG4gICAgICAgICAqIGB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWVgIHZhbHVlLCBhbmQgd2lsbCB1cGRhdGUgdG8gcmVmbGVjdCBjaGFuZ2VzXG4gICAgICAgICAqIHRvIHRoYXQgdmFsdWUuXG4gICAgICAgICAqL1xuICAgICAgICBwYXRoOiB7XG4gICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgIG5vdGlmeTogdHJ1ZSxcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgb2JzZXJ2ZXJzOiBbXG4gICAgICAgICdfbG9jYXRpb25DaGFuZ2VkKHBhdGgsIHF1ZXJ5UGFyYW1zKScsXG4gICAgICAgICdfcm91dGVDaGFuZ2VkKHJvdXRlLnByZWZpeCwgcm91dGUucGF0aCknLFxuICAgICAgICAnX3JvdXRlUXVlcnlQYXJhbXNDaGFuZ2VkKHJvdXRlLl9fcXVlcnlQYXJhbXMpJ1xuICAgICAgXSxcblxuICAgICAgY3JlYXRlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMubGlua1BhdGhzKCdyb3V0ZS5fX3F1ZXJ5UGFyYW1zJywgJ3F1ZXJ5UGFyYW1zJyk7XG4gICAgICAgIHRoaXMubGlua1BhdGhzKCdxdWVyeVBhcmFtcycsICdyb3V0ZS5fX3F1ZXJ5UGFyYW1zJyk7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIEhhbmRsZXIgY2FsbGVkIHdoZW4gdGhlIHBhdGggb3IgcXVlcnlQYXJhbXMgY2hhbmdlLlxuICAgICAgICovXG4gICAgICBfbG9jYXRpb25DaGFuZ2VkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMucm91dGUgJiZcbiAgICAgICAgICAgIHRoaXMucm91dGUucGF0aCA9PT0gdGhpcy5wYXRoICYmXG4gICAgICAgICAgICB0aGlzLnF1ZXJ5UGFyYW1zID09PSB0aGlzLnJvdXRlLl9fcXVlcnlQYXJhbXMpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yb3V0ZSA9IHtcbiAgICAgICAgICBwcmVmaXg6ICcnLFxuICAgICAgICAgIHBhdGg6IHRoaXMucGF0aCxcbiAgICAgICAgICBfX3F1ZXJ5UGFyYW1zOiB0aGlzLnF1ZXJ5UGFyYW1zXG4gICAgICAgIH07XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIEhhbmRsZXIgY2FsbGVkIHdoZW4gdGhlIHJvdXRlIHByZWZpeCBhbmQgcm91dGUgcGF0aCBjaGFuZ2UuXG4gICAgICAgKi9cbiAgICAgIF9yb3V0ZUNoYW5nZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMucm91dGUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnBhdGggPSB0aGlzLnJvdXRlLnByZWZpeCArIHRoaXMucm91dGUucGF0aDtcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogSGFuZGxlciBjYWxsZWQgd2hlbiB0aGUgcm91dGUgcXVlcnlQYXJhbXMgY2hhbmdlLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSAge09iamVjdH0gcXVlcnlQYXJhbXMgQSBzZXQgb2Yga2V5L3ZhbHVlIHBhaXJzIHRoYXQgYXJlXG4gICAgICAgKiB1bml2ZXJzYWxseSBhY2Nlc3NpYmxlIHRvIGJyYW5jaGVzIG9mIHRoZSByb3V0ZSB0cmVlLlxuICAgICAgICovXG4gICAgICBfcm91dGVRdWVyeVBhcmFtc0NoYW5nZWQ6IGZ1bmN0aW9uKHF1ZXJ5UGFyYW1zKSB7XG4gICAgICAgIGlmICghdGhpcy5yb3V0ZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnF1ZXJ5UGFyYW1zID0gcXVlcnlQYXJhbXM7XG4gICAgICB9XG4gICAgfTtcbiAgfSkoKTtcbjwvc2NyaXB0PlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9hcHAtcm91dGUvYXBwLXJvdXRlLWNvbnZlcnRlci1iZWhhdmlvci5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNiBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuXG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vcG9seW1lci9wb2x5bWVyLmh0bWxcIj5cblxuPCEtLVxuYGFwcC1yb3V0ZWAgaXMgYW4gZWxlbWVudCB0aGF0IGVuYWJsZXMgZGVjbGFyYXRpdmUsIHNlbGYtZGVzY3JpYmluZyByb3V0aW5nXG5mb3IgYSB3ZWIgYXBwLlxuXG4+ICpuLmIuIGFwcC1yb3V0ZSBpcyBzdGlsbCBpbiBiZXRhLiBXZSBleHBlY3QgaXQgd2lsbCBuZWVkIHNvbWUgY2hhbmdlcy4gV2UncmUgY291bnRpbmcgb24geW91ciBmZWVkYmFjayEqXG5cbkluIGl0cyB0eXBpY2FsIHVzYWdlLCBhIGBhcHAtcm91dGVgIGVsZW1lbnQgY29uc3VtZXMgYW4gb2JqZWN0IHRoYXQgZGVzY3JpYmVzXG5zb21lIHN0YXRlIGFib3V0IHRoZSBjdXJyZW50IHJvdXRlLCB2aWEgdGhlIGByb3V0ZWAgcHJvcGVydHkuIEl0IHRoZW4gcGFyc2VzXG50aGF0IHN0YXRlIHVzaW5nIHRoZSBgcGF0dGVybmAgcHJvcGVydHksIGFuZCBwcm9kdWNlcyB0d28gYXJ0aWZhY3RzOiBzb21lIGBkYXRhYFxucmVsYXRlZCB0byB0aGUgYHJvdXRlYCwgYW5kIGEgYHRhaWxgIHRoYXQgY29udGFpbnMgdGhlIHJlc3Qgb2YgdGhlIGByb3V0ZWAgdGhhdFxuZGlkIG5vdCBtYXRjaC5cblxuSGVyZSBpcyBhIGJhc2ljIGV4YW1wbGUsIHdoZW4gdXNlZCB3aXRoIGBhcHAtbG9jYXRpb25gOlxuXG4gICAgPGFwcC1sb2NhdGlvbiByb3V0ZT1cInt7cm91dGV9fVwiPjwvYXBwLWxvY2F0aW9uPlxuICAgIDxhcHAtcm91dGVcbiAgICAgICAgcm91dGU9XCJ7e3JvdXRlfX1cIlxuICAgICAgICBwYXR0ZXJuPVwiLzpwYWdlXCJcbiAgICAgICAgZGF0YT1cInt7ZGF0YX19XCJcbiAgICAgICAgdGFpbD1cInt7dGFpbH19XCI+XG4gICAgPC9hcHAtcm91dGU+XG5cbkluIHRoZSBhYm92ZSBleGFtcGxlLCB0aGUgYGFwcC1sb2NhdGlvbmAgcHJvZHVjZXMgYSBgcm91dGVgIHZhbHVlLiBUaGVuLCB0aGVcbmByb3V0ZS5wYXRoYCBwcm9wZXJ0eSBpcyBtYXRjaGVkIGJ5IGNvbXBhcmluZyBpdCB0byB0aGUgYHBhdHRlcm5gIHByb3BlcnR5LiBJZlxudGhlIGBwYXR0ZXJuYCBwcm9wZXJ0eSBtYXRjaGVzIGByb3V0ZS5wYXRoYCwgdGhlIGBhcHAtcm91dGVgIHdpbGwgc2V0IG9yIHVwZGF0ZVxuaXRzIGBkYXRhYCBwcm9wZXJ0eSB3aXRoIGFuIG9iamVjdCB3aG9zZSBwcm9wZXJ0aWVzIGNvcnJlc3BvbmQgdG8gdGhlIHBhcmFtZXRlcnNcbmluIGBwYXR0ZXJuYC4gU28sIGluIHRoZSBhYm92ZSBleGFtcGxlLCBpZiBgcm91dGUucGF0aGAgd2FzIGAnL2Fib3V0J2AsIHRoZSB2YWx1ZVxub2YgYGRhdGFgIHdvdWxkIGJlIGB7XCJwYWdlXCI6IFwiYWJvdXRcIn1gLlxuXG5UaGUgYHRhaWxgIHByb3BlcnR5IHJlcHJlc2VudHMgdGhlIHJlbWFpbmluZyBwYXJ0IG9mIHRoZSByb3V0ZSBzdGF0ZSBhZnRlciB0aGVcbmBwYXR0ZXJuYCBoYXMgYmVlbiBhcHBsaWVkIHRvIGEgbWF0Y2hpbmcgYHJvdXRlYC5cblxuSGVyZSBpcyBhbm90aGVyIGV4YW1wbGUsIHdoZXJlIGB0YWlsYCBpcyB1c2VkOlxuXG4gICAgPGFwcC1sb2NhdGlvbiByb3V0ZT1cInt7cm91dGV9fVwiPjwvYXBwLWxvY2F0aW9uPlxuICAgIDxhcHAtcm91dGVcbiAgICAgICAgcm91dGU9XCJ7e3JvdXRlfX1cIlxuICAgICAgICBwYXR0ZXJuPVwiLzpwYWdlXCJcbiAgICAgICAgZGF0YT1cInt7cm91dGVEYXRhfX1cIlxuICAgICAgICB0YWlsPVwie3tzdWJyb3V0ZX19XCI+XG4gICAgPC9hcHAtcm91dGU+XG4gICAgPGFwcC1yb3V0ZVxuICAgICAgICByb3V0ZT1cInt7c3Vicm91dGV9fVwiXG4gICAgICAgIHBhdHRlcm49XCIvOmlkXCJcbiAgICAgICAgZGF0YT1cInt7c3Vicm91dGVEYXRhfX1cIj5cbiAgICA8L2FwcC1yb3V0ZT5cblxuSW4gdGhlIGFib3ZlIGV4YW1wbGUsIHRoZXJlIGFyZSB0d28gYGFwcC1yb3V0ZWAgZWxlbWVudHMuIFRoZSBmaXJzdFxuYGFwcC1yb3V0ZWAgY29uc3VtZXMgYSBgcm91dGVgLiBXaGVuIHRoZSBgcm91dGVgIGlzIG1hdGNoZWQsIHRoZSBmaXJzdFxuYGFwcC1yb3V0ZWAgYWxzbyBwcm9kdWNlcyBgcm91dGVEYXRhYCBmcm9tIGl0cyBgZGF0YWAsIGFuZCBgc3Vicm91dGVgIGZyb21cbml0cyBgdGFpbGAuIFRoZSBzZWNvbmQgYGFwcC1yb3V0ZWAgY29uc3VtZXMgdGhlIGBzdWJyb3V0ZWAsIGFuZCB3aGVuIGl0XG5tYXRjaGVzLCBpdCBwcm9kdWNlcyBhbiBvYmplY3QgY2FsbGVkIGBzdWJyb3V0ZURhdGFgIGZyb20gaXRzIGBkYXRhYC5cblxuU28sIHdoZW4gYHJvdXRlLnBhdGhgIGlzIGAnL2Fib3V0J2AsIHRoZSBgcm91dGVEYXRhYCBvYmplY3Qgd2lsbCBsb29rIGxpa2VcbnRoaXM6IGB7IHBhZ2U6ICdhYm91dCcgfWBcblxuQW5kIGBzdWJyb3V0ZURhdGFgIHdpbGwgYmUgbnVsbC4gSG93ZXZlciwgaWYgYHJvdXRlLnBhdGhgIGNoYW5nZXMgdG9cbmAnL2FydGljbGUvMTIzJ2AsIHRoZSBgcm91dGVEYXRhYCBvYmplY3Qgd2lsbCBsb29rIGxpa2UgdGhpczpcbmB7IHBhZ2U6ICdhcnRpY2xlJyB9YFxuXG5BbmQgdGhlIGBzdWJyb3V0ZURhdGFgIHdpbGwgbG9vayBsaWtlIHRoaXM6IGB7IGlkOiAnMTIzJyB9YFxuXG5gYXBwLXJvdXRlYCBpcyByZXNwb25zaXZlIHRvIGJpLWRpcmVjdGlvbmFsIGNoYW5nZXMgdG8gdGhlIGBkYXRhYCBvYmplY3RzXG50aGV5IHByb2R1Y2UuIFNvLCBpZiBgcm91dGVEYXRhLnBhZ2VgIGNoYW5nZWQgZnJvbSBgJ2FydGljbGUnYCB0byBgJ2Fib3V0J2AsXG50aGUgYGFwcC1yb3V0ZWAgd2lsbCB1cGRhdGUgYHJvdXRlLnBhdGhgLiBUaGlzIGluLXR1cm4gd2lsbCB1cGRhdGUgdGhlXG5gYXBwLWxvY2F0aW9uYCwgYW5kIGNhdXNlIHRoZSBnbG9iYWwgbG9jYXRpb24gYmFyIHRvIGNoYW5nZSBpdHMgdmFsdWUuXG5cbkBlbGVtZW50IGFwcC1yb3V0ZVxuQGRlbW8gZGVtby9pbmRleC5odG1sXG5AZGVtbyBkZW1vL2RhdGEtbG9hZGluZy1kZW1vLmh0bWxcbkBkZW1vIGRlbW8vc2ltcGxlLWRlbW8uaHRtbFxuLS0+XG5cbjxzY3JpcHQ+XG4gIChmdW5jdGlvbigpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBQb2x5bWVyKHtcbiAgICAgIGlzOiAnYXBwLXJvdXRlJyxcblxuICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIFVSTCBjb21wb25lbnQgbWFuYWdlZCBieSB0aGlzIGVsZW1lbnQuXG4gICAgICAgICAqL1xuICAgICAgICByb3V0ZToge1xuICAgICAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgICAgICBub3RpZnk6IHRydWVcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHBhdHRlcm4gb2Ygc2xhc2gtc2VwYXJhdGVkIHNlZ21lbnRzIHRvIG1hdGNoIGByb3V0ZS5wYXRoYCBhZ2FpbnN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgZXhhbXBsZSB0aGUgcGF0dGVybiBcIi9mb29cIiB3aWxsIG1hdGNoIFwiL2Zvb1wiIG9yIFwiL2Zvby9iYXJcIlxuICAgICAgICAgKiBidXQgbm90IFwiL2Zvb2JhclwiLlxuICAgICAgICAgKlxuICAgICAgICAgKiBQYXRoIHNlZ21lbnRzIGxpa2UgYC86bmFtZWRgIGFyZSBtYXBwZWQgdG8gcHJvcGVydGllcyBvbiB0aGUgYGRhdGFgIG9iamVjdC5cbiAgICAgICAgICovXG4gICAgICAgIHBhdHRlcm46IHtcbiAgICAgICAgICB0eXBlOiBTdHJpbmdcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHBhcmFtZXRlcml6ZWQgdmFsdWVzIHRoYXQgYXJlIGV4dHJhY3RlZCBmcm9tIHRoZSByb3V0ZSBhc1xuICAgICAgICAgKiBkZXNjcmliZWQgYnkgYHBhdHRlcm5gLlxuICAgICAgICAgKi9cbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24oKSB7cmV0dXJuIHt9O30sXG4gICAgICAgICAgbm90aWZ5OiB0cnVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHs/T2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgcXVlcnlQYXJhbXM6IHtcbiAgICAgICAgICB0eXBlOiBPYmplY3QsXG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICAgIH0sXG4gICAgICAgICAgbm90aWZ5OiB0cnVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBwYXJ0IG9mIGByb3V0ZS5wYXRoYCBOT1QgY29uc3VtZWQgYnkgYHBhdHRlcm5gLlxuICAgICAgICAgKi9cbiAgICAgICAgdGFpbDoge1xuICAgICAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24oKSB7cmV0dXJuIHtwYXRoOiBudWxsLCBwcmVmaXg6IG51bGwsIF9fcXVlcnlQYXJhbXM6IG51bGx9O30sXG4gICAgICAgICAgbm90aWZ5OiB0cnVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhlIGN1cnJlbnQgcm91dGUgaXMgYWN0aXZlLiBUcnVlIGlmIGByb3V0ZS5wYXRoYCBtYXRjaGVzIHRoZVxuICAgICAgICAgKiBgcGF0dGVybmAsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgICAgICovXG4gICAgICAgIGFjdGl2ZToge1xuICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgICAgbm90aWZ5OiB0cnVlLFxuICAgICAgICAgIHJlYWRPbmx5OiB0cnVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgX3F1ZXJ5UGFyYW1zVXBkYXRpbmc6IHtcbiAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUgez9zdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICBfbWF0Y2hlZDoge1xuICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICB2YWx1ZTogJydcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgb2JzZXJ2ZXJzOiBbXG4gICAgICAgICdfX3RyeVRvTWF0Y2gocm91dGUucGF0aCwgcGF0dGVybiknLFxuICAgICAgICAnX191cGRhdGVQYXRoT25EYXRhQ2hhbmdlKGRhdGEuKiknLFxuICAgICAgICAnX190YWlsUGF0aENoYW5nZWQodGFpbC5wYXRoKScsXG4gICAgICAgICdfX3JvdXRlUXVlcnlQYXJhbXNDaGFuZ2VkKHJvdXRlLl9fcXVlcnlQYXJhbXMpJyxcbiAgICAgICAgJ19fdGFpbFF1ZXJ5UGFyYW1zQ2hhbmdlZCh0YWlsLl9fcXVlcnlQYXJhbXMpJyxcbiAgICAgICAgJ19fcXVlcnlQYXJhbXNDaGFuZ2VkKHF1ZXJ5UGFyYW1zLiopJ1xuICAgICAgXSxcblxuICAgICAgY3JlYXRlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMubGlua1BhdGhzKCdyb3V0ZS5fX3F1ZXJ5UGFyYW1zJywgJ3RhaWwuX19xdWVyeVBhcmFtcycpO1xuICAgICAgICB0aGlzLmxpbmtQYXRocygndGFpbC5fX3F1ZXJ5UGFyYW1zJywgJ3JvdXRlLl9fcXVlcnlQYXJhbXMnKTtcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogRGVhbCB3aXRoIHRoZSBxdWVyeSBwYXJhbXMgb2JqZWN0IGJlaW5nIGFzc2lnbmVkIHRvIHdob2xlc2FsZS5cbiAgICAgICAqL1xuICAgICAgX19yb3V0ZVF1ZXJ5UGFyYW1zQ2hhbmdlZDogZnVuY3Rpb24ocXVlcnlQYXJhbXMpIHtcbiAgICAgICAgaWYgKHF1ZXJ5UGFyYW1zICYmIHRoaXMudGFpbCkge1xuICAgICAgICAgIGlmICh0aGlzLnRhaWwuX19xdWVyeVBhcmFtcyAhPT0gcXVlcnlQYXJhbXMpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0KCd0YWlsLl9fcXVlcnlQYXJhbXMnLCBxdWVyeVBhcmFtcyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCF0aGlzLmFjdGl2ZSB8fCB0aGlzLl9xdWVyeVBhcmFtc1VwZGF0aW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gQ29weSBxdWVyeVBhcmFtcyBhbmQgdHJhY2sgd2hldGhlciB0aGVyZSBhcmUgYW55IGRpZmZlcmVuY2VzIGNvbXBhcmVkXG4gICAgICAgICAgLy8gdG8gdGhlIGV4aXN0aW5nIHF1ZXJ5IHBhcmFtcy5cbiAgICAgICAgICB2YXIgY29weU9mUXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgICB2YXIgYW55dGhpbmdDaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgICAgZm9yICh2YXIga2V5IGluIHF1ZXJ5UGFyYW1zKSB7XG4gICAgICAgICAgICBjb3B5T2ZRdWVyeVBhcmFtc1trZXldID0gcXVlcnlQYXJhbXNba2V5XTtcbiAgICAgICAgICAgIGlmIChhbnl0aGluZ0NoYW5nZWQgfHxcbiAgICAgICAgICAgICAgICAhdGhpcy5xdWVyeVBhcmFtcyB8fFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zW2tleV0gIT09IHRoaXMucXVlcnlQYXJhbXNba2V5XSkge1xuICAgICAgICAgICAgICBhbnl0aGluZ0NoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBOZWVkIHRvIGNoZWNrIHdoZXRoZXIgYW55IGtleXMgd2VyZSBkZWxldGVkXG4gICAgICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMucXVlcnlQYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhbnl0aGluZ0NoYW5nZWQgfHwgIShrZXkgaW4gcXVlcnlQYXJhbXMpKSB7XG4gICAgICAgICAgICAgIGFueXRoaW5nQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghYW55dGhpbmdDaGFuZ2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX3F1ZXJ5UGFyYW1zVXBkYXRpbmcgPSB0cnVlO1xuICAgICAgICAgIHRoaXMuc2V0KCdxdWVyeVBhcmFtcycsIGNvcHlPZlF1ZXJ5UGFyYW1zKTtcbiAgICAgICAgICB0aGlzLl9xdWVyeVBhcmFtc1VwZGF0aW5nID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIF9fdGFpbFF1ZXJ5UGFyYW1zQ2hhbmdlZDogZnVuY3Rpb24ocXVlcnlQYXJhbXMpIHtcbiAgICAgICAgaWYgKHF1ZXJ5UGFyYW1zICYmIHRoaXMucm91dGUgJiYgdGhpcy5yb3V0ZS5fX3F1ZXJ5UGFyYW1zICE9IHF1ZXJ5UGFyYW1zKSB7XG4gICAgICAgICAgdGhpcy5zZXQoJ3JvdXRlLl9fcXVlcnlQYXJhbXMnLCBxdWVyeVBhcmFtcyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIF9fcXVlcnlQYXJhbXNDaGFuZ2VkOiBmdW5jdGlvbihjaGFuZ2VzKSB7XG4gICAgICAgIGlmICghdGhpcy5hY3RpdmUgfHwgdGhpcy5fcXVlcnlQYXJhbXNVcGRhdGluZykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2V0KCdyb3V0ZS5fXycgKyBjaGFuZ2VzLnBhdGgsIGNoYW5nZXMudmFsdWUpO1xuICAgICAgfSxcblxuICAgICAgX19yZXNldFByb3BlcnRpZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9zZXRBY3RpdmUoZmFsc2UpO1xuICAgICAgICB0aGlzLl9tYXRjaGVkID0gbnVsbDtcbiAgICAgIH0sXG5cbiAgICAgIF9fdHJ5VG9NYXRjaDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5yb3V0ZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwYXRoID0gdGhpcy5yb3V0ZS5wYXRoO1xuICAgICAgICB2YXIgcGF0dGVybiA9IHRoaXMucGF0dGVybjtcblxuICAgICAgICBpZiAoIXBhdHRlcm4pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXBhdGgpIHtcbiAgICAgICAgICB0aGlzLl9fcmVzZXRQcm9wZXJ0aWVzKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlbWFpbmluZ1BpZWNlcyA9IHBhdGguc3BsaXQoJy8nKTtcbiAgICAgICAgdmFyIHBhdHRlcm5QaWVjZXMgPSBwYXR0ZXJuLnNwbGl0KCcvJyk7XG5cbiAgICAgICAgdmFyIG1hdGNoZWQgPSBbXTtcbiAgICAgICAgdmFyIG5hbWVkTWF0Y2hlcyA9IHt9O1xuXG4gICAgICAgIGZvciAodmFyIGk9MDsgaSA8IHBhdHRlcm5QaWVjZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgcGF0dGVyblBpZWNlID0gcGF0dGVyblBpZWNlc1tpXTtcbiAgICAgICAgICBpZiAoIXBhdHRlcm5QaWVjZSAmJiBwYXR0ZXJuUGllY2UgIT09ICcnKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHBhdGhQaWVjZSA9IHJlbWFpbmluZ1BpZWNlcy5zaGlmdCgpO1xuXG4gICAgICAgICAgLy8gV2UgZG9uJ3QgbWF0Y2ggdGhpcyBwYXRoLlxuICAgICAgICAgIGlmICghcGF0aFBpZWNlICYmIHBhdGhQaWVjZSAhPT0gJycpIHtcbiAgICAgICAgICAgIHRoaXMuX19yZXNldFByb3BlcnRpZXMoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgbWF0Y2hlZC5wdXNoKHBhdGhQaWVjZSk7XG5cbiAgICAgICAgICBpZiAocGF0dGVyblBpZWNlLmNoYXJBdCgwKSA9PSAnOicpIHtcbiAgICAgICAgICAgIG5hbWVkTWF0Y2hlc1twYXR0ZXJuUGllY2Uuc2xpY2UoMSldID0gcGF0aFBpZWNlO1xuICAgICAgICAgIH0gZWxzZSBpZiAocGF0dGVyblBpZWNlICE9PSBwYXRoUGllY2UpIHtcbiAgICAgICAgICAgIHRoaXMuX19yZXNldFByb3BlcnRpZXMoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9tYXRjaGVkID0gbWF0Y2hlZC5qb2luKCcvJyk7XG5cbiAgICAgICAgLy8gUHJvcGVydGllcyB0aGF0IG11c3QgYmUgdXBkYXRlZCBhdG9taWNhbGx5LlxuICAgICAgICB2YXIgcHJvcGVydHlVcGRhdGVzID0ge307XG5cbiAgICAgICAgLy90aGlzLmFjdGl2ZVxuICAgICAgICBpZiAoIXRoaXMuYWN0aXZlKSB7XG4gICAgICAgICAgcHJvcGVydHlVcGRhdGVzLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0aGlzLnRhaWxcbiAgICAgICAgdmFyIHRhaWxQcmVmaXggPSB0aGlzLnJvdXRlLnByZWZpeCArIHRoaXMuX21hdGNoZWQ7XG4gICAgICAgIHZhciB0YWlsUGF0aCA9IHJlbWFpbmluZ1BpZWNlcy5qb2luKCcvJyk7XG4gICAgICAgIGlmIChyZW1haW5pbmdQaWVjZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHRhaWxQYXRoID0gJy8nICsgdGFpbFBhdGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLnRhaWwgfHxcbiAgICAgICAgICAgIHRoaXMudGFpbC5wcmVmaXggIT09IHRhaWxQcmVmaXggfHxcbiAgICAgICAgICAgIHRoaXMudGFpbC5wYXRoICE9PSB0YWlsUGF0aCkge1xuICAgICAgICAgIHByb3BlcnR5VXBkYXRlcy50YWlsID0ge1xuICAgICAgICAgICAgcHJlZml4OiB0YWlsUHJlZml4LFxuICAgICAgICAgICAgcGF0aDogdGFpbFBhdGgsXG4gICAgICAgICAgICBfX3F1ZXJ5UGFyYW1zOiB0aGlzLnJvdXRlLl9fcXVlcnlQYXJhbXNcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdGhpcy5kYXRhXG4gICAgICAgIHByb3BlcnR5VXBkYXRlcy5kYXRhID0gbmFtZWRNYXRjaGVzO1xuICAgICAgICB0aGlzLl9kYXRhSW5VcmwgPSB7fTtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG5hbWVkTWF0Y2hlcykge1xuICAgICAgICAgIHRoaXMuX2RhdGFJblVybFtrZXldID0gbmFtZWRNYXRjaGVzW2tleV07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5zZXRQcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgaWYgKCF0aGlzLmFjdGl2ZSkge1xuICAgICAgICAgICAgdGhpcy5fc2V0QWN0aXZlKHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBhdG9taWMgdXBkYXRlXG4gICAgICAgICAgdGhpcy5zZXRQcm9wZXJ0aWVzKHByb3BlcnR5VXBkYXRlcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fX3NldE11bHRpKHByb3BlcnR5VXBkYXRlcyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIF9fdGFpbFBhdGhDaGFuZ2VkOiBmdW5jdGlvbihwYXRoKSB7XG4gICAgICAgIGlmICghdGhpcy5hY3RpdmUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRhaWxQYXRoID0gcGF0aDtcbiAgICAgICAgdmFyIG5ld1BhdGggPSB0aGlzLl9tYXRjaGVkO1xuICAgICAgICBpZiAodGFpbFBhdGgpIHtcbiAgICAgICAgICBpZiAodGFpbFBhdGguY2hhckF0KDApICE9PSAnLycpIHtcbiAgICAgICAgICAgIHRhaWxQYXRoID0gJy8nICsgdGFpbFBhdGg7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5ld1BhdGggKz0gdGFpbFBhdGg7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXQoJ3JvdXRlLnBhdGgnLCBuZXdQYXRoKTtcbiAgICAgIH0sXG5cbiAgICAgIF9fdXBkYXRlUGF0aE9uRGF0YUNoYW5nZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5yb3V0ZSB8fCAhdGhpcy5hY3RpdmUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5ld1BhdGggPSB0aGlzLl9fZ2V0TGluayh7fSk7XG4gICAgICAgIHZhciBvbGRQYXRoID0gdGhpcy5fX2dldExpbmsodGhpcy5fZGF0YUluVXJsKTtcbiAgICAgICAgaWYgKG5ld1BhdGggPT09IG9sZFBhdGgpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXQoJ3JvdXRlLnBhdGgnLCBuZXdQYXRoKTtcbiAgICAgIH0sXG5cbiAgICAgIF9fZ2V0TGluazogZnVuY3Rpb24ob3ZlcnJpZGVWYWx1ZXMpIHtcbiAgICAgICAgdmFyIHZhbHVlcyA9IHt0YWlsOiBudWxsfTtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMuZGF0YSkge1xuICAgICAgICAgIHZhbHVlc1trZXldID0gdGhpcy5kYXRhW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIga2V5IGluIG92ZXJyaWRlVmFsdWVzKSB7XG4gICAgICAgICAgdmFsdWVzW2tleV0gPSBvdmVycmlkZVZhbHVlc1trZXldO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwYXR0ZXJuUGllY2VzID0gdGhpcy5wYXR0ZXJuLnNwbGl0KCcvJyk7XG4gICAgICAgIHZhciBpbnRlcnAgPSBwYXR0ZXJuUGllY2VzLm1hcChmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgIGlmICh2YWx1ZVswXSA9PSAnOicpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWVzW3ZhbHVlLnNsaWNlKDEpXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgaWYgKHZhbHVlcy50YWlsICYmIHZhbHVlcy50YWlsLnBhdGgpIHtcbiAgICAgICAgICBpZiAoaW50ZXJwLmxlbmd0aCA+IDAgJiYgdmFsdWVzLnRhaWwucGF0aC5jaGFyQXQoMCkgPT09ICcvJykge1xuICAgICAgICAgICAgaW50ZXJwLnB1c2godmFsdWVzLnRhaWwucGF0aC5zbGljZSgxKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGludGVycC5wdXNoKHZhbHVlcy50YWlsLnBhdGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW50ZXJwLmpvaW4oJy8nKTtcbiAgICAgIH0sXG5cbiAgICAgIF9fc2V0TXVsdGk6IGZ1bmN0aW9uKHNldE9iaikge1xuICAgICAgICAvLyBIQUNLKHJpY3RpYyk6IHNraXJ0aW5nIGFyb3VuZCAxLjAncyBsYWNrIG9mIGEgc2V0TXVsdGkgYnkgcG9raW5nIGF0XG4gICAgICAgIC8vICAgICBpbnRlcm5hbCBkYXRhIHN0cnVjdHVyZXMuIEkgd291bGQgbm90IGFkdmlzZSB0aGF0IHlvdSBjb3B5IHRoaXNcbiAgICAgICAgLy8gICAgIGV4YW1wbGUuXG4gICAgICAgIC8vXG4gICAgICAgIC8vICAgICBJbiB0aGUgZnV0dXJlIHRoaXMgd2lsbCBiZSBhIGZlYXR1cmUgb2YgUG9seW1lciBpdHNlbGYuXG4gICAgICAgIC8vICAgICBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9Qb2x5bWVyL3BvbHltZXIvaXNzdWVzLzM2NDBcbiAgICAgICAgLy9cbiAgICAgICAgLy8gICAgIEhhY2tpbmcgYXJvdW5kIHdpdGggcHJpdmF0ZSBtZXRob2RzIGxpa2UgdGhpcyBpcyBqdWdnbGluZyBmb290Z3VucyxcbiAgICAgICAgLy8gICAgIGFuZCBpcyBsaWtlbHkgdG8gaGF2ZSB1bmV4cGVjdGVkIGFuZCB1bnN1cHBvcnRlZCByb3VnaCBlZGdlcy5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gICAgIEJlIHllIHNvIHdhcm5lZC5cbiAgICAgICAgZm9yICh2YXIgcHJvcGVydHkgaW4gc2V0T2JqKSB7XG4gICAgICAgICAgdGhpcy5fcHJvcGVydHlTZXR0ZXIocHJvcGVydHksIHNldE9ialtwcm9wZXJ0eV0pO1xuICAgICAgICB9XG4gICAgICAgIC8vbm90aWZ5IGluIGEgc3BlY2lmaWMgb3JkZXJcbiAgICAgICAgaWYgKHNldE9iai5kYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLl9wYXRoRWZmZWN0b3IoJ2RhdGEnLCB0aGlzLmRhdGEpO1xuICAgICAgICAgIHRoaXMuX25vdGlmeUNoYW5nZSgnZGF0YScpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZXRPYmouYWN0aXZlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLl9wYXRoRWZmZWN0b3IoJ2FjdGl2ZScsIHRoaXMuYWN0aXZlKTtcbiAgICAgICAgICB0aGlzLl9ub3RpZnlDaGFuZ2UoJ2FjdGl2ZScpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZXRPYmoudGFpbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5fcGF0aEVmZmVjdG9yKCd0YWlsJywgdGhpcy50YWlsKTtcbiAgICAgICAgICB0aGlzLl9ub3RpZnlDaGFuZ2UoJ3RhaWwnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9KSgpO1xuPC9zY3JpcHQ+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL2FwcC1yb3V0ZS9hcHAtcm91dGUuaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTUgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cblxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3BvbHltZXIvcG9seW1lci5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vaXJvbi1yZXNpemFibGUtYmVoYXZpb3IvaXJvbi1yZXNpemFibGUtYmVoYXZpb3IuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL2lyb24tc2VsZWN0b3IvaXJvbi1zZWxlY3RhYmxlLmh0bWxcIj5cblxuPCEtLVxuYGlyb24tcGFnZXNgIGlzIHVzZWQgdG8gc2VsZWN0IG9uZSBvZiBpdHMgY2hpbGRyZW4gdG8gc2hvdy4gT25lIHVzZSBpcyB0byBjeWNsZSB0aHJvdWdoIGEgbGlzdCBvZlxuY2hpbGRyZW4gXCJwYWdlc1wiLlxuXG5FeGFtcGxlOlxuXG4gICAgPGlyb24tcGFnZXMgc2VsZWN0ZWQ9XCIwXCI+XG4gICAgICA8ZGl2Pk9uZTwvZGl2PlxuICAgICAgPGRpdj5Ud288L2Rpdj5cbiAgICAgIDxkaXY+VGhyZWU8L2Rpdj5cbiAgICA8L2lyb24tcGFnZXM+XG5cbiAgICA8c2NyaXB0PlxuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIHZhciBwYWdlcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2lyb24tcGFnZXMnKTtcbiAgICAgICAgcGFnZXMuc2VsZWN0TmV4dCgpO1xuICAgICAgfSk7XG4gICAgPC9zY3JpcHQ+XG5cbkBncm91cCBJcm9uIEVsZW1lbnRzXG5AaGVybyBoZXJvLnN2Z1xuQGRlbW8gZGVtby9pbmRleC5odG1sXG4tLT5cblxuPGRvbS1tb2R1bGUgaWQ9XCJpcm9uLXBhZ2VzXCI+XG5cbiAgPHRlbXBsYXRlPlxuICAgIDxzdHlsZT5cbiAgICAgIDpob3N0IHtcbiAgICAgICAgZGlzcGxheTogYmxvY2s7XG4gICAgICB9XG5cbiAgICAgIDpob3N0ID4gOjpzbG90dGVkKDpub3QoLmlyb24tc2VsZWN0ZWQpKSB7XG4gICAgICAgIGRpc3BsYXk6IG5vbmUgIWltcG9ydGFudDtcbiAgICAgIH1cbiAgICA8L3N0eWxlPlxuXG4gICAgPHNsb3Q+PC9zbG90PlxuICA8L3RlbXBsYXRlPlxuXG4gIDxzY3JpcHQ+XG4gICAgUG9seW1lcih7XG5cbiAgICAgIGlzOiAnaXJvbi1wYWdlcycsXG5cbiAgICAgIGJlaGF2aW9yczogW1xuICAgICAgICBQb2x5bWVyLklyb25SZXNpemFibGVCZWhhdmlvcixcbiAgICAgICAgUG9seW1lci5Jcm9uU2VsZWN0YWJsZUJlaGF2aW9yXG4gICAgICBdLFxuXG4gICAgICBwcm9wZXJ0aWVzOiB7XG5cbiAgICAgICAgLy8gYXMgdGhlIHNlbGVjdGVkIHBhZ2UgaXMgdGhlIG9ubHkgb25lIHZpc2libGUsIGFjdGl2YXRlRXZlbnRcbiAgICAgICAgLy8gaXMgYm90aCBub24tc2Vuc2ljYWwgYW5kIHByb2JsZW1hdGljOyBlLmcuIGluIGNhc2VzIHdoZXJlIGEgdXNlclxuICAgICAgICAvLyBoYW5kbGVyIGF0dGVtcHRzIHRvIGNoYW5nZSB0aGUgcGFnZSBhbmQgdGhlIGFjdGl2YXRlRXZlbnRcbiAgICAgICAgLy8gaGFuZGxlciBpbW1lZGlhdGVseSBjaGFuZ2VzIGl0IGJhY2tcbiAgICAgICAgYWN0aXZhdGVFdmVudDoge1xuICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICB2YWx1ZTogbnVsbFxuICAgICAgICB9XG5cbiAgICAgIH0sXG5cbiAgICAgIG9ic2VydmVyczogW1xuICAgICAgICAnX3NlbGVjdGVkUGFnZUNoYW5nZWQoc2VsZWN0ZWQpJ1xuICAgICAgXSxcblxuICAgICAgX3NlbGVjdGVkUGFnZUNoYW5nZWQ6IGZ1bmN0aW9uKHNlbGVjdGVkLCBvbGQpIHtcbiAgICAgICAgdGhpcy5hc3luYyh0aGlzLm5vdGlmeVJlc2l6ZSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgPC9zY3JpcHQ+XG48L2RvbS1tb2R1bGU+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL2lyb24tcGFnZXMvaXJvbi1wYWdlcy5odG1sIiwiXG48IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE1IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi9wb2x5bWVyL3BvbHltZXIuaHRtbFwiPlxuXG48c2NyaXB0PlxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFGdW5jdGlvbn0gc2VsZWN0Q2FsbGJhY2tcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuICBQb2x5bWVyLklyb25TZWxlY3Rpb24gPSBmdW5jdGlvbihzZWxlY3RDYWxsYmFjaykge1xuICAgIHRoaXMuc2VsZWN0aW9uID0gW107XG4gICAgdGhpcy5zZWxlY3RDYWxsYmFjayA9IHNlbGVjdENhbGxiYWNrO1xuICB9O1xuXG4gIFBvbHltZXIuSXJvblNlbGVjdGlvbi5wcm90b3R5cGUgPSB7XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIHNlbGVjdGVkIGl0ZW0ocykuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGdldFxuICAgICAqIEByZXR1cm5zIFJldHVybnMgdGhlIHNlbGVjdGVkIGl0ZW0ocykuIElmIHRoZSBtdWx0aSBwcm9wZXJ0eSBpcyB0cnVlLFxuICAgICAqIGBnZXRgIHdpbGwgcmV0dXJuIGFuIGFycmF5LCBvdGhlcndpc2UgaXQgd2lsbCByZXR1cm5cbiAgICAgKiB0aGUgc2VsZWN0ZWQgaXRlbSBvciB1bmRlZmluZWQgaWYgdGhlcmUgaXMgbm8gc2VsZWN0aW9uLlxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5tdWx0aSA/IHRoaXMuc2VsZWN0aW9uLnNsaWNlKCkgOiB0aGlzLnNlbGVjdGlvblswXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2xlYXJzIGFsbCB0aGUgc2VsZWN0aW9uIGV4Y2VwdCB0aGUgb25lcyBpbmRpY2F0ZWQuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGNsZWFyXG4gICAgICogQHBhcmFtIHtBcnJheX0gZXhjbHVkZXMgaXRlbXMgdG8gYmUgZXhjbHVkZWQuXG4gICAgICovXG4gICAgY2xlYXI6IGZ1bmN0aW9uKGV4Y2x1ZGVzKSB7XG4gICAgICB0aGlzLnNlbGVjdGlvbi5zbGljZSgpLmZvckVhY2goZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICBpZiAoIWV4Y2x1ZGVzIHx8IGV4Y2x1ZGVzLmluZGV4T2YoaXRlbSkgPCAwKSB7XG4gICAgICAgICAgdGhpcy5zZXRJdGVtU2VsZWN0ZWQoaXRlbSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9LCB0aGlzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIGlmIGEgZ2l2ZW4gaXRlbSBpcyBzZWxlY3RlZC5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgaXNTZWxlY3RlZFxuICAgICAqIEBwYXJhbSB7Kn0gaXRlbSBUaGUgaXRlbSB3aG9zZSBzZWxlY3Rpb24gc3RhdGUgc2hvdWxkIGJlIGNoZWNrZWQuXG4gICAgICogQHJldHVybnMgUmV0dXJucyB0cnVlIGlmIGBpdGVtYCBpcyBzZWxlY3RlZC5cbiAgICAgKi9cbiAgICBpc1NlbGVjdGVkOiBmdW5jdGlvbihpdGVtKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb24uaW5kZXhPZihpdGVtKSA+PSAwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBzZWxlY3Rpb24gc3RhdGUgZm9yIGEgZ2l2ZW4gaXRlbSB0byBlaXRoZXIgc2VsZWN0ZWQgb3IgZGVzZWxlY3RlZC5cbiAgICAgKlxuICAgICAqIEBtZXRob2Qgc2V0SXRlbVNlbGVjdGVkXG4gICAgICogQHBhcmFtIHsqfSBpdGVtIFRoZSBpdGVtIHRvIHNlbGVjdC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzU2VsZWN0ZWQgVHJ1ZSBmb3Igc2VsZWN0ZWQsIGZhbHNlIGZvciBkZXNlbGVjdGVkLlxuICAgICAqL1xuICAgIHNldEl0ZW1TZWxlY3RlZDogZnVuY3Rpb24oaXRlbSwgaXNTZWxlY3RlZCkge1xuICAgICAgaWYgKGl0ZW0gIT0gbnVsbCkge1xuICAgICAgICBpZiAoaXNTZWxlY3RlZCAhPT0gdGhpcy5pc1NlbGVjdGVkKGl0ZW0pKSB7XG4gICAgICAgICAgLy8gcHJvY2VlZCB0byB1cGRhdGUgc2VsZWN0aW9uIG9ubHkgaWYgcmVxdWVzdGVkIHN0YXRlIGRpZmZlcnMgZnJvbSBjdXJyZW50XG4gICAgICAgICAgaWYgKGlzU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uLnB1c2goaXRlbSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBpID0gdGhpcy5zZWxlY3Rpb24uaW5kZXhPZihpdGVtKTtcbiAgICAgICAgICAgIGlmIChpID49IDApIHtcbiAgICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24uc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy5zZWxlY3RDYWxsYmFjaykge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RDYWxsYmFjayhpdGVtLCBpc1NlbGVjdGVkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgc2VsZWN0aW9uIHN0YXRlIGZvciBhIGdpdmVuIGl0ZW0uIElmIHRoZSBgbXVsdGlgIHByb3BlcnR5XG4gICAgICogaXMgdHJ1ZSwgdGhlbiB0aGUgc2VsZWN0ZWQgc3RhdGUgb2YgYGl0ZW1gIHdpbGwgYmUgdG9nZ2xlZDsgb3RoZXJ3aXNlXG4gICAgICogdGhlIGBpdGVtYCB3aWxsIGJlIHNlbGVjdGVkLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBzZWxlY3RcbiAgICAgKiBAcGFyYW0geyp9IGl0ZW0gVGhlIGl0ZW0gdG8gc2VsZWN0LlxuICAgICAqL1xuICAgIHNlbGVjdDogZnVuY3Rpb24oaXRlbSkge1xuICAgICAgaWYgKHRoaXMubXVsdGkpIHtcbiAgICAgICAgdGhpcy50b2dnbGUoaXRlbSk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuZ2V0KCkgIT09IGl0ZW0pIHtcbiAgICAgICAgdGhpcy5zZXRJdGVtU2VsZWN0ZWQodGhpcy5nZXQoKSwgZmFsc2UpO1xuICAgICAgICB0aGlzLnNldEl0ZW1TZWxlY3RlZChpdGVtLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVG9nZ2xlcyB0aGUgc2VsZWN0aW9uIHN0YXRlIGZvciBgaXRlbWAuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHRvZ2dsZVxuICAgICAqIEBwYXJhbSB7Kn0gaXRlbSBUaGUgaXRlbSB0byB0b2dnbGUuXG4gICAgICovXG4gICAgdG9nZ2xlOiBmdW5jdGlvbihpdGVtKSB7XG4gICAgICB0aGlzLnNldEl0ZW1TZWxlY3RlZChpdGVtLCAhdGhpcy5pc1NlbGVjdGVkKGl0ZW0pKTtcbiAgICB9XG5cbiAgfTtcblxuPC9zY3JpcHQ+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL2lyb24tc2VsZWN0b3IvaXJvbi1zZWxlY3Rpb24uaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTUgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cblxuXG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vcG9seW1lci9wb2x5bWVyLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCJpcm9uLW11bHRpLXNlbGVjdGFibGUuaHRtbFwiPlxuXG48c2NyaXB0PlxuICAvKipcbiAgYGlyb24tc2VsZWN0b3JgIGlzIGFuIGVsZW1lbnQgd2hpY2ggY2FuIGJlIHVzZWQgdG8gbWFuYWdlIGEgbGlzdCBvZiBlbGVtZW50c1xuICB0aGF0IGNhbiBiZSBzZWxlY3RlZC4gIFRhcHBpbmcgb24gdGhlIGl0ZW0gd2lsbCBtYWtlIHRoZSBpdGVtIHNlbGVjdGVkLiAgVGhlIGBzZWxlY3RlZGAgaW5kaWNhdGVzXG4gIHdoaWNoIGl0ZW0gaXMgYmVpbmcgc2VsZWN0ZWQuICBUaGUgZGVmYXVsdCBpcyB0byB1c2UgdGhlIGluZGV4IG9mIHRoZSBpdGVtLlxuXG4gIEV4YW1wbGU6XG5cbiAgICAgIDxpcm9uLXNlbGVjdG9yIHNlbGVjdGVkPVwiMFwiPlxuICAgICAgICA8ZGl2Pkl0ZW0gMTwvZGl2PlxuICAgICAgICA8ZGl2Pkl0ZW0gMjwvZGl2PlxuICAgICAgICA8ZGl2Pkl0ZW0gMzwvZGl2PlxuICAgICAgPC9pcm9uLXNlbGVjdG9yPlxuXG4gIElmIHlvdSB3YW50IHRvIHVzZSB0aGUgYXR0cmlidXRlIHZhbHVlIG9mIGFuIGVsZW1lbnQgZm9yIGBzZWxlY3RlZGAgaW5zdGVhZCBvZiB0aGUgaW5kZXgsXG4gIHNldCBgYXR0ckZvclNlbGVjdGVkYCB0byB0aGUgbmFtZSBvZiB0aGUgYXR0cmlidXRlLiAgRm9yIGV4YW1wbGUsIGlmIHlvdSB3YW50IHRvIHNlbGVjdCBpdGVtIGJ5XG4gIGBuYW1lYCwgc2V0IGBhdHRyRm9yU2VsZWN0ZWRgIHRvIGBuYW1lYC5cblxuICBFeGFtcGxlOlxuXG4gICAgICA8aXJvbi1zZWxlY3RvciBhdHRyLWZvci1zZWxlY3RlZD1cIm5hbWVcIiBzZWxlY3RlZD1cImZvb1wiPlxuICAgICAgICA8ZGl2IG5hbWU9XCJmb29cIj5Gb288L2Rpdj5cbiAgICAgICAgPGRpdiBuYW1lPVwiYmFyXCI+QmFyPC9kaXY+XG4gICAgICAgIDxkaXYgbmFtZT1cInpvdFwiPlpvdDwvZGl2PlxuICAgICAgPC9pcm9uLXNlbGVjdG9yPlxuXG4gIFlvdSBjYW4gc3BlY2lmeSBhIGRlZmF1bHQgZmFsbGJhY2sgd2l0aCBgZmFsbGJhY2tTZWxlY3Rpb25gIGluIGNhc2UgdGhlIGBzZWxlY3RlZGAgYXR0cmlidXRlIGRvZXNcbiAgbm90IG1hdGNoIHRoZSBgYXR0ckZvclNlbGVjdGVkYCBhdHRyaWJ1dGUgb2YgYW55IGVsZW1lbnRzLlxuXG4gIEV4YW1wbGU6XG5cbiAgICAgICAgPGlyb24tc2VsZWN0b3IgYXR0ci1mb3Itc2VsZWN0ZWQ9XCJuYW1lXCIgc2VsZWN0ZWQ9XCJub24tZXhpc3RpbmdcIlxuICAgICAgICAgICAgICAgICAgICAgICBmYWxsYmFjay1zZWxlY3Rpb249XCJkZWZhdWx0XCI+XG4gICAgICAgICAgPGRpdiBuYW1lPVwiZm9vXCI+Rm9vPC9kaXY+XG4gICAgICAgICAgPGRpdiBuYW1lPVwiYmFyXCI+QmFyPC9kaXY+XG4gICAgICAgICAgPGRpdiBuYW1lPVwiZGVmYXVsdFwiPkRlZmF1bHQ8L2Rpdj5cbiAgICAgICAgPC9pcm9uLXNlbGVjdG9yPlxuXG4gIE5vdGU6IFdoZW4gdGhlIHNlbGVjdG9yIGlzIG11bHRpLCB0aGUgc2VsZWN0aW9uIHdpbGwgc2V0IHRvIGBmYWxsYmFja1NlbGVjdGlvbmAgaWZmXG4gIHRoZSBudW1iZXIgb2YgbWF0Y2hpbmcgZWxlbWVudHMgaXMgemVyby5cblxuICBgaXJvbi1zZWxlY3RvcmAgaXMgbm90IHN0eWxlZC4gVXNlIHRoZSBgaXJvbi1zZWxlY3RlZGAgQ1NTIGNsYXNzIHRvIHN0eWxlIHRoZSBzZWxlY3RlZCBlbGVtZW50LlxuXG4gIEV4YW1wbGU6XG5cbiAgICAgIDxzdHlsZT5cbiAgICAgICAgLmlyb24tc2VsZWN0ZWQge1xuICAgICAgICAgIGJhY2tncm91bmQ6ICNlZWU7XG4gICAgICAgIH1cbiAgICAgIDwvc3R5bGU+XG5cbiAgICAgIC4uLlxuXG4gICAgICA8aXJvbi1zZWxlY3RvciBzZWxlY3RlZD1cIjBcIj5cbiAgICAgICAgPGRpdj5JdGVtIDE8L2Rpdj5cbiAgICAgICAgPGRpdj5JdGVtIDI8L2Rpdj5cbiAgICAgICAgPGRpdj5JdGVtIDM8L2Rpdj5cbiAgICAgIDwvaXJvbi1zZWxlY3Rvcj5cblxuICBAZGVtbyBkZW1vL2luZGV4Lmh0bWxcbiAgKi9cblxuICBQb2x5bWVyKHtcblxuICAgIGlzOiAnaXJvbi1zZWxlY3RvcicsXG5cbiAgICBiZWhhdmlvcnM6IFtcbiAgICAgIFBvbHltZXIuSXJvbk11bHRpU2VsZWN0YWJsZUJlaGF2aW9yXG4gICAgXVxuXG4gIH0pO1xuXG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvaXJvbi1zZWxlY3Rvci9pcm9uLXNlbGVjdG9yLmh0bWwiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE1IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi9wb2x5bWVyL3BvbHltZXIuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cImlyb24tc2VsZWN0YWJsZS5odG1sXCI+XG5cbjxzY3JpcHQ+XG4gIC8qKlxuICAgKiBAcG9seW1lckJlaGF2aW9yIFBvbHltZXIuSXJvbk11bHRpU2VsZWN0YWJsZUJlaGF2aW9yXG4gICAqL1xuICBQb2x5bWVyLklyb25NdWx0aVNlbGVjdGFibGVCZWhhdmlvckltcGwgPSB7XG4gICAgcHJvcGVydGllczoge1xuXG4gICAgICAvKipcbiAgICAgICAqIElmIHRydWUsIG11bHRpcGxlIHNlbGVjdGlvbnMgYXJlIGFsbG93ZWQuXG4gICAgICAgKi9cbiAgICAgIG11bHRpOiB7XG4gICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgIHZhbHVlOiBmYWxzZSxcbiAgICAgICAgb2JzZXJ2ZXI6ICdtdWx0aUNoYW5nZWQnXG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgc2VsZWN0ZWQgZWxlbWVudHMuIFRoaXMgaXMgdXNlZCBpbnN0ZWFkIG9mIGBzZWxlY3RlZGAgd2hlbiBgbXVsdGlgXG4gICAgICAgKiBpcyB0cnVlLlxuICAgICAgICovXG4gICAgICBzZWxlY3RlZFZhbHVlczoge1xuICAgICAgICB0eXBlOiBBcnJheSxcbiAgICAgICAgbm90aWZ5OiB0cnVlLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFJldHVybnMgYW4gYXJyYXkgb2YgY3VycmVudGx5IHNlbGVjdGVkIGl0ZW1zLlxuICAgICAgICovXG4gICAgICBzZWxlY3RlZEl0ZW1zOiB7XG4gICAgICAgIHR5cGU6IEFycmF5LFxuICAgICAgICByZWFkT25seTogdHJ1ZSxcbiAgICAgICAgbm90aWZ5OiB0cnVlLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgfSxcblxuICAgIG9ic2VydmVyczogW1xuICAgICAgJ191cGRhdGVTZWxlY3RlZChzZWxlY3RlZFZhbHVlcy5zcGxpY2VzKSdcbiAgICBdLFxuXG4gICAgLyoqXG4gICAgICogU2VsZWN0cyB0aGUgZ2l2ZW4gdmFsdWUuIElmIHRoZSBgbXVsdGlgIHByb3BlcnR5IGlzIHRydWUsIHRoZW4gdGhlIHNlbGVjdGVkIHN0YXRlIG9mIHRoZVxuICAgICAqIGB2YWx1ZWAgd2lsbCBiZSB0b2dnbGVkOyBvdGhlcndpc2UgdGhlIGB2YWx1ZWAgd2lsbCBiZSBzZWxlY3RlZC5cbiAgICAgKlxuICAgICAqIEBtZXRob2Qgc2VsZWN0XG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSB2YWx1ZSB0aGUgdmFsdWUgdG8gc2VsZWN0LlxuICAgICAqL1xuICAgIHNlbGVjdDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIGlmICh0aGlzLm11bHRpKSB7XG4gICAgICAgIHRoaXMuX3RvZ2dsZVNlbGVjdGVkKHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWQgPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgbXVsdGlDaGFuZ2VkOiBmdW5jdGlvbihtdWx0aSkge1xuICAgICAgdGhpcy5fc2VsZWN0aW9uLm11bHRpID0gbXVsdGk7XG4gICAgICB0aGlzLl91cGRhdGVTZWxlY3RlZCgpO1xuICAgIH0sXG5cbiAgICAvLyBVTlVTRUQsIEZPUiBBUEkgQ09NUEFUSUJJTElUWVxuICAgIGdldCBfc2hvdWxkVXBkYXRlU2VsZWN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0ZWQgIT0gbnVsbCB8fFxuICAgICAgICAodGhpcy5zZWxlY3RlZFZhbHVlcyAhPSBudWxsICYmIHRoaXMuc2VsZWN0ZWRWYWx1ZXMubGVuZ3RoKTtcbiAgICB9LFxuXG4gICAgX3VwZGF0ZUF0dHJGb3JTZWxlY3RlZDogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXRoaXMubXVsdGkpIHtcbiAgICAgICAgUG9seW1lci5Jcm9uU2VsZWN0YWJsZUJlaGF2aW9yLl91cGRhdGVBdHRyRm9yU2VsZWN0ZWQuYXBwbHkodGhpcyk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuc2VsZWN0ZWRJdGVtcyAmJiB0aGlzLnNlbGVjdGVkSXRlbXMubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLnNlbGVjdGVkVmFsdWVzID0gdGhpcy5zZWxlY3RlZEl0ZW1zLm1hcChmdW5jdGlvbihzZWxlY3RlZEl0ZW0pIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5faW5kZXhUb1ZhbHVlKHRoaXMuaW5kZXhPZihzZWxlY3RlZEl0ZW0pKTtcbiAgICAgICAgfSwgdGhpcykuZmlsdGVyKGZ1bmN0aW9uKHVuZmlsdGVyZWRWYWx1ZSkge1xuICAgICAgICAgIHJldHVybiB1bmZpbHRlcmVkVmFsdWUgIT0gbnVsbDtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIF91cGRhdGVTZWxlY3RlZDogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5tdWx0aSkge1xuICAgICAgICB0aGlzLl9zZWxlY3RNdWx0aSh0aGlzLnNlbGVjdGVkVmFsdWVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3NlbGVjdFNlbGVjdGVkKHRoaXMuc2VsZWN0ZWQpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBfc2VsZWN0TXVsdGk6IGZ1bmN0aW9uKHZhbHVlcykge1xuICAgICAgdmFsdWVzID0gdmFsdWVzIHx8IFtdO1xuXG4gICAgICB2YXIgc2VsZWN0ZWRJdGVtcyA9ICh0aGlzLl92YWx1ZXNUb0l0ZW1zKHZhbHVlcykgfHwgW10pLmZpbHRlcihmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgIHJldHVybiBpdGVtICE9PSBudWxsICYmIGl0ZW0gIT09IHVuZGVmaW5lZDtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBjbGVhciBhbGwgYnV0IHRoZSBjdXJyZW50IHNlbGVjdGVkIGl0ZW1zXG4gICAgICB0aGlzLl9zZWxlY3Rpb24uY2xlYXIoc2VsZWN0ZWRJdGVtcyk7XG5cbiAgICAgIC8vIHNlbGVjdCBvbmx5IHRob3NlIG5vdCBzZWxlY3RlZCB5ZXRcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZWN0ZWRJdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLl9zZWxlY3Rpb24uc2V0SXRlbVNlbGVjdGVkKHNlbGVjdGVkSXRlbXNbaV0sIHRydWUpO1xuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayBmb3IgaXRlbXMsIHNpbmNlIHRoaXMgYXJyYXkgaXMgcG9wdWxhdGVkIG9ubHkgd2hlbiBhdHRhY2hlZFxuICAgICAgaWYgKHRoaXMuZmFsbGJhY2tTZWxlY3Rpb24gJiYgIXRoaXMuX3NlbGVjdGlvbi5nZXQoKS5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGZhbGxiYWNrID0gdGhpcy5fdmFsdWVUb0l0ZW0odGhpcy5mYWxsYmFja1NlbGVjdGlvbik7XG4gICAgICAgIGlmIChmYWxsYmFjaykge1xuICAgICAgICAgIHRoaXMuc2VsZWN0KHRoaXMuZmFsbGJhY2tTZWxlY3Rpb24pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIF9zZWxlY3Rpb25DaGFuZ2U6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHMgPSB0aGlzLl9zZWxlY3Rpb24uZ2V0KCk7XG4gICAgICBpZiAodGhpcy5tdWx0aSkge1xuICAgICAgICB0aGlzLl9zZXRTZWxlY3RlZEl0ZW1zKHMpO1xuICAgICAgICB0aGlzLl9zZXRTZWxlY3RlZEl0ZW0ocy5sZW5ndGggPyBzWzBdIDogbnVsbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocyAhPT0gbnVsbCAmJiBzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLl9zZXRTZWxlY3RlZEl0ZW1zKFtzXSk7XG4gICAgICAgICAgdGhpcy5fc2V0U2VsZWN0ZWRJdGVtKHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX3NldFNlbGVjdGVkSXRlbXMoW10pO1xuICAgICAgICAgIHRoaXMuX3NldFNlbGVjdGVkSXRlbShudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBfdG9nZ2xlU2VsZWN0ZWQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICB2YXIgaSA9IHRoaXMuc2VsZWN0ZWRWYWx1ZXMuaW5kZXhPZih2YWx1ZSk7XG4gICAgICB2YXIgdW5zZWxlY3RlZCA9IGkgPCAwO1xuICAgICAgaWYgKHVuc2VsZWN0ZWQpIHtcbiAgICAgICAgdGhpcy5wdXNoKCdzZWxlY3RlZFZhbHVlcycsdmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zcGxpY2UoJ3NlbGVjdGVkVmFsdWVzJyxpLDEpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBfdmFsdWVzVG9JdGVtczogZnVuY3Rpb24odmFsdWVzKSB7XG4gICAgICByZXR1cm4gKHZhbHVlcyA9PSBudWxsKSA/IG51bGwgOiB2YWx1ZXMubWFwKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92YWx1ZVRvSXRlbSh2YWx1ZSk7XG4gICAgICB9LCB0aGlzKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqIEBwb2x5bWVyQmVoYXZpb3IgKi9cbiAgUG9seW1lci5Jcm9uTXVsdGlTZWxlY3RhYmxlQmVoYXZpb3IgPSBbXG4gICAgUG9seW1lci5Jcm9uU2VsZWN0YWJsZUJlaGF2aW9yLFxuICAgIFBvbHltZXIuSXJvbk11bHRpU2VsZWN0YWJsZUJlaGF2aW9ySW1wbFxuICBdO1xuXG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvaXJvbi1zZWxlY3Rvci9pcm9uLW11bHRpLXNlbGVjdGFibGUuaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTUgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cblxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3BvbHltZXIvcG9seW1lci5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vaXJvbi1pY29uL2lyb24taWNvbi5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vcGFwZXItYmVoYXZpb3JzL3BhcGVyLWlua3ktZm9jdXMtYmVoYXZpb3IuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3BhcGVyLXN0eWxlcy9kZWZhdWx0LXRoZW1lLmh0bWxcIj5cblxuPCEtLVxuTWF0ZXJpYWwgZGVzaWduOiBbSWNvbiB0b2dnbGVzXShodHRwczovL3d3dy5nb29nbGUuY29tL2Rlc2lnbi9zcGVjL2NvbXBvbmVudHMvYnV0dG9ucy5odG1sI2J1dHRvbnMtdG9nZ2xlLWJ1dHRvbnMpXG5cbmBwYXBlci1pY29uLWJ1dHRvbmAgaXMgYSBidXR0b24gd2l0aCBhbiBpbWFnZSBwbGFjZWQgYXQgdGhlIGNlbnRlci4gV2hlbiB0aGUgdXNlciB0b3VjaGVzXG50aGUgYnV0dG9uLCBhIHJpcHBsZSBlZmZlY3QgZW1hbmF0ZXMgZnJvbSB0aGUgY2VudGVyIG9mIHRoZSBidXR0b24uXG5cbmBwYXBlci1pY29uLWJ1dHRvbmAgZG9lcyBub3QgaW5jbHVkZSBhIGRlZmF1bHQgaWNvbiBzZXQuIFRvIHVzZSBpY29ucyBmcm9tIHRoZSBkZWZhdWx0XG5zZXQsIGluY2x1ZGUgYFBvbHltZXJFbGVtZW50cy9pcm9uLWljb25zL2lyb24taWNvbnMuaHRtbGAsIGFuZCB1c2UgdGhlIGBpY29uYCBhdHRyaWJ1dGUgdG8gc3BlY2lmeSB3aGljaCBpY29uXG5mcm9tIHRoZSBpY29uIHNldCB0byB1c2UuXG5cbiAgICA8cGFwZXItaWNvbi1idXR0b24gaWNvbj1cIm1lbnVcIj48L3BhcGVyLWljb24tYnV0dG9uPlxuXG5TZWUgW2Bpcm9uLWljb25zZXRgXShpcm9uLWljb25zZXQpIGZvciBtb3JlIGluZm9ybWF0aW9uIGFib3V0XG5ob3cgdG8gdXNlIGEgY3VzdG9tIGljb24gc2V0LlxuXG5FeGFtcGxlOlxuXG4gICAgPGxpbmsgaHJlZj1cInBhdGgvdG8vaXJvbi1pY29ucy9pcm9uLWljb25zLmh0bWxcIiByZWw9XCJpbXBvcnRcIj5cblxuICAgIDxwYXBlci1pY29uLWJ1dHRvbiBpY29uPVwiZmF2b3JpdGVcIj48L3BhcGVyLWljb24tYnV0dG9uPlxuICAgIDxwYXBlci1pY29uLWJ1dHRvbiBzcmM9XCJzdGFyLnBuZ1wiPjwvcGFwZXItaWNvbi1idXR0b24+XG5cblRvIHVzZSBgcGFwZXItaWNvbi1idXR0b25gIGFzIGEgbGluaywgd3JhcCBpdCBpbiBhbiBhbmNob3IgdGFnLiBTaW5jZSBgcGFwZXItaWNvbi1idXR0b25gXG53aWxsIGFscmVhZHkgcmVjZWl2ZSBmb2N1cywgeW91IG1heSB3YW50IHRvIHByZXZlbnQgdGhlIGFuY2hvciB0YWcgZnJvbSByZWNlaXZpbmcgZm9jdXNcbmFzIHdlbGwgYnkgc2V0dGluZyBpdHMgdGFiaW5kZXggdG8gLTEuXG5cbiAgICA8YSBocmVmPVwiaHR0cHM6Ly93d3cucG9seW1lci1wcm9qZWN0Lm9yZ1wiIHRhYmluZGV4PVwiLTFcIj5cbiAgICAgIDxwYXBlci1pY29uLWJ1dHRvbiBpY29uPVwicG9seW1lclwiPjwvcGFwZXItaWNvbi1idXR0b24+XG4gICAgPC9hPlxuXG4jIyMgU3R5bGluZ1xuXG5TdHlsZSB0aGUgYnV0dG9uIHdpdGggQ1NTIGFzIHlvdSB3b3VsZCBhIG5vcm1hbCBET00gZWxlbWVudC4gSWYgeW91IGFyZSB1c2luZyB0aGUgaWNvbnNcbnByb3ZpZGVkIGJ5IGBpcm9uLWljb25zYCwgdGhleSB3aWxsIGluaGVyaXQgdGhlIGZvcmVncm91bmQgY29sb3Igb2YgdGhlIGJ1dHRvbi5cblxuICAgIC8qIG1ha2UgYSByZWQgXCJmYXZvcml0ZVwiIGJ1dHRvbiAqL1xuICAgIDxwYXBlci1pY29uLWJ1dHRvbiBpY29uPVwiZmF2b3JpdGVcIiBzdHlsZT1cImNvbG9yOiByZWQ7XCI+PC9wYXBlci1pY29uLWJ1dHRvbj5cblxuQnkgZGVmYXVsdCwgdGhlIHJpcHBsZSBpcyB0aGUgc2FtZSBjb2xvciBhcyB0aGUgZm9yZWdyb3VuZCBhdCAyNSUgb3BhY2l0eS4gWW91IG1heVxuY3VzdG9taXplIHRoZSBjb2xvciB1c2luZyB0aGUgYC0tcGFwZXItaWNvbi1idXR0b24taW5rLWNvbG9yYCBjdXN0b20gcHJvcGVydHkuXG5cblRoZSBmb2xsb3dpbmcgY3VzdG9tIHByb3BlcnRpZXMgYW5kIG1peGlucyBhcmUgYXZhaWxhYmxlIGZvciBzdHlsaW5nOlxuXG5DdXN0b20gcHJvcGVydHkgfCBEZXNjcmlwdGlvbiB8IERlZmF1bHRcbi0tLS0tLS0tLS0tLS0tLS18LS0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tXG5gLS1wYXBlci1pY29uLWJ1dHRvbi1kaXNhYmxlZC10ZXh0YCB8IFRoZSBjb2xvciBvZiB0aGUgZGlzYWJsZWQgYnV0dG9uIHwgYC0tZGlzYWJsZWQtdGV4dC1jb2xvcmBcbmAtLXBhcGVyLWljb24tYnV0dG9uLWluay1jb2xvcmAgfCBTZWxlY3RlZC9mb2N1cyByaXBwbGUgY29sb3IgfCBgLS1wcmltYXJ5LXRleHQtY29sb3JgXG5gLS1wYXBlci1pY29uLWJ1dHRvbmAgfCBNaXhpbiBmb3IgYSBidXR0b24gfCBge31gXG5gLS1wYXBlci1pY29uLWJ1dHRvbi1kaXNhYmxlZGAgfCBNaXhpbiBmb3IgYSBkaXNhYmxlZCBidXR0b24gfCBge31gXG5gLS1wYXBlci1pY29uLWJ1dHRvbi1ob3ZlcmAgfCBNaXhpbiBmb3IgYnV0dG9uIG9uIGhvdmVyIHwgYHt9YFxuXG5AZ3JvdXAgUGFwZXIgRWxlbWVudHNcbkBlbGVtZW50IHBhcGVyLWljb24tYnV0dG9uXG5AZGVtbyBkZW1vL2luZGV4Lmh0bWxcbi0tPlxuXG48ZG9tLW1vZHVsZSBpZD1cInBhcGVyLWljb24tYnV0dG9uXCI+XG4gIDx0ZW1wbGF0ZSBzdHJpcC13aGl0ZXNwYWNlPlxuICAgIDxzdHlsZT5cbiAgICAgIDpob3N0IHtcbiAgICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgIHBhZGRpbmc6IDhweDtcbiAgICAgICAgb3V0bGluZTogbm9uZTtcbiAgICAgICAgLXdlYmtpdC11c2VyLXNlbGVjdDogbm9uZTtcbiAgICAgICAgLW1vei11c2VyLXNlbGVjdDogbm9uZTtcbiAgICAgICAgLW1zLXVzZXItc2VsZWN0OiBub25lO1xuICAgICAgICB1c2VyLXNlbGVjdDogbm9uZTtcbiAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xuICAgICAgICB6LWluZGV4OiAwO1xuICAgICAgICBsaW5lLWhlaWdodDogMTtcblxuICAgICAgICB3aWR0aDogNDBweDtcbiAgICAgICAgaGVpZ2h0OiA0MHB4O1xuXG4gICAgICAgIC8qIE5PVEU6IEJvdGggdmFsdWVzIGFyZSBuZWVkZWQsIHNpbmNlIHNvbWUgcGhvbmVzIHJlcXVpcmUgdGhlIHZhbHVlIHRvIGJlIGB0cmFuc3BhcmVudGAuICovXG4gICAgICAgIC13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvcjogcmdiYSgwLCAwLCAwLCAwKTtcbiAgICAgICAgLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yOiB0cmFuc3BhcmVudDtcblxuICAgICAgICAvKiBCZWNhdXNlIG9mIHBvbHltZXIvMjU1OCwgdGhpcyBzdHlsZSBoYXMgbG93ZXIgc3BlY2lmaWNpdHkgdGhhbiAqICovXG4gICAgICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3ggIWltcG9ydGFudDtcblxuICAgICAgICBAYXBwbHkgLS1wYXBlci1pY29uLWJ1dHRvbjtcbiAgICAgIH1cblxuICAgICAgOmhvc3QgI2luayB7XG4gICAgICAgIGNvbG9yOiB2YXIoLS1wYXBlci1pY29uLWJ1dHRvbi1pbmstY29sb3IsIHZhcigtLXByaW1hcnktdGV4dC1jb2xvcikpO1xuICAgICAgICBvcGFjaXR5OiAwLjY7XG4gICAgICB9XG5cbiAgICAgIDpob3N0KFtkaXNhYmxlZF0pIHtcbiAgICAgICAgY29sb3I6IHZhcigtLXBhcGVyLWljb24tYnV0dG9uLWRpc2FibGVkLXRleHQsIHZhcigtLWRpc2FibGVkLXRleHQtY29sb3IpKTtcbiAgICAgICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG4gICAgICAgIGN1cnNvcjogYXV0bztcblxuICAgICAgICBAYXBwbHkgLS1wYXBlci1pY29uLWJ1dHRvbi1kaXNhYmxlZDtcbiAgICAgIH1cblxuICAgICAgOmhvc3QoW2hpZGRlbl0pIHtcbiAgICAgICAgZGlzcGxheTogbm9uZSAhaW1wb3J0YW50O1xuICAgICAgfVxuXG4gICAgICA6aG9zdCg6aG92ZXIpIHtcbiAgICAgICAgQGFwcGx5IC0tcGFwZXItaWNvbi1idXR0b24taG92ZXI7XG4gICAgICB9XG5cbiAgICAgIGlyb24taWNvbiB7XG4gICAgICAgIC0taXJvbi1pY29uLXdpZHRoOiAxMDAlO1xuICAgICAgICAtLWlyb24taWNvbi1oZWlnaHQ6IDEwMCU7XG4gICAgICB9XG4gICAgPC9zdHlsZT5cblxuICAgIDxpcm9uLWljb24gaWQ9XCJpY29uXCIgc3JjPVwiW1tzcmNdXVwiIGljb249XCJbW2ljb25dXVwiIGFsdCQ9XCJbW2FsdF1dXCI+PC9pcm9uLWljb24+XG4gIDwvdGVtcGxhdGU+XG5cbiAgPHNjcmlwdD5cbiAgICBQb2x5bWVyKHtcbiAgICAgIGlzOiAncGFwZXItaWNvbi1idXR0b24nLFxuXG4gICAgICBob3N0QXR0cmlidXRlczoge1xuICAgICAgICByb2xlOiAnYnV0dG9uJyxcbiAgICAgICAgdGFiaW5kZXg6ICcwJ1xuICAgICAgfSxcblxuICAgICAgYmVoYXZpb3JzOiBbXG4gICAgICAgIFBvbHltZXIuUGFwZXJJbmt5Rm9jdXNCZWhhdmlvclxuICAgICAgXSxcblxuICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIFVSTCBvZiBhbiBpbWFnZSBmb3IgdGhlIGljb24uIElmIHRoZSBzcmMgcHJvcGVydHkgaXMgc3BlY2lmaWVkLFxuICAgICAgICAgKiB0aGUgaWNvbiBwcm9wZXJ0eSBzaG91bGQgbm90IGJlLlxuICAgICAgICAgKi9cbiAgICAgICAgc3JjOiB7XG4gICAgICAgICAgdHlwZTogU3RyaW5nXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB0aGUgaWNvbiBuYW1lIG9yIGluZGV4IGluIHRoZSBzZXQgb2YgaWNvbnMgYXZhaWxhYmxlIGluXG4gICAgICAgICAqIHRoZSBpY29uJ3MgaWNvbiBzZXQuIElmIHRoZSBpY29uIHByb3BlcnR5IGlzIHNwZWNpZmllZCxcbiAgICAgICAgICogdGhlIHNyYyBwcm9wZXJ0eSBzaG91bGQgbm90IGJlLlxuICAgICAgICAgKi9cbiAgICAgICAgaWNvbjoge1xuICAgICAgICAgIHR5cGU6IFN0cmluZ1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgdGhlIGFsdGVybmF0ZSB0ZXh0IGZvciB0aGUgYnV0dG9uLCBmb3IgYWNjZXNzaWJpbGl0eS5cbiAgICAgICAgICovXG4gICAgICAgIGFsdDoge1xuICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICBvYnNlcnZlcjogXCJfYWx0Q2hhbmdlZFwiXG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIF9hbHRDaGFuZ2VkOiBmdW5jdGlvbihuZXdWYWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdmFyIGxhYmVsID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnKTtcblxuICAgICAgICAvLyBEb24ndCBzdG9tcCBvdmVyIGEgdXNlci1zZXQgYXJpYS1sYWJlbC5cbiAgICAgICAgaWYgKCFsYWJlbCB8fCBvbGRWYWx1ZSA9PSBsYWJlbCkge1xuICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsJywgbmV3VmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIDwvc2NyaXB0PlxuPC9kb20tbW9kdWxlPlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9wYXBlci1pY29uLWJ1dHRvbi9wYXBlci1pY29uLWJ1dHRvbi5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNSBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuXG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vcG9seW1lci9wb2x5bWVyLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi9pcm9uLW1ldGEvaXJvbi1tZXRhLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi9pcm9uLWZsZXgtbGF5b3V0L2lyb24tZmxleC1sYXlvdXQuaHRtbFwiPlxuXG48IS0tXG5cblRoZSBgaXJvbi1pY29uYCBlbGVtZW50IGRpc3BsYXlzIGFuIGljb24uIEJ5IGRlZmF1bHQgYW4gaWNvbiByZW5kZXJzIGFzIGEgMjRweCBzcXVhcmUuXG5cbkV4YW1wbGUgdXNpbmcgc3JjOlxuXG4gICAgPGlyb24taWNvbiBzcmM9XCJzdGFyLnBuZ1wiPjwvaXJvbi1pY29uPlxuXG5FeGFtcGxlIHNldHRpbmcgc2l6ZSB0byAzMnB4IHggMzJweDpcblxuICAgIDxpcm9uLWljb24gY2xhc3M9XCJiaWdcIiBzcmM9XCJiaWdfc3Rhci5wbmdcIj48L2lyb24taWNvbj5cblxuICAgIDxzdHlsZSBpcz1cImN1c3RvbS1zdHlsZVwiPlxuICAgICAgLmJpZyB7XG4gICAgICAgIC0taXJvbi1pY29uLWhlaWdodDogMzJweDtcbiAgICAgICAgLS1pcm9uLWljb24td2lkdGg6IDMycHg7XG4gICAgICB9XG4gICAgPC9zdHlsZT5cblxuVGhlIGlyb24gZWxlbWVudHMgaW5jbHVkZSBzZXZlcmFsIHNldHMgb2YgaWNvbnMuXG5UbyB1c2UgdGhlIGRlZmF1bHQgc2V0IG9mIGljb25zLCBpbXBvcnQgYGlyb24taWNvbnMuaHRtbGAgYW5kIHVzZSB0aGUgYGljb25gIGF0dHJpYnV0ZSB0byBzcGVjaWZ5IGFuIGljb246XG5cbiAgICA8bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiL2NvbXBvbmVudHMvaXJvbi1pY29ucy9pcm9uLWljb25zLmh0bWxcIj5cblxuICAgIDxpcm9uLWljb24gaWNvbj1cIm1lbnVcIj48L2lyb24taWNvbj5cblxuVG8gdXNlIGEgZGlmZmVyZW50IGJ1aWx0LWluIHNldCBvZiBpY29ucywgaW1wb3J0IHRoZSBzcGVjaWZpYyBgaXJvbi1pY29ucy88aWNvbnNldD4taWNvbnMuaHRtbGAsIGFuZFxuc3BlY2lmeSB0aGUgaWNvbiBhcyBgPGljb25zZXQ+OjxpY29uPmAuIEZvciBleGFtcGxlLCB0byB1c2UgYSBjb21tdW5pY2F0aW9uIGljb24sIHlvdSB3b3VsZFxudXNlOlxuXG4gICAgPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi9jb21wb25lbnRzL2lyb24taWNvbnMvY29tbXVuaWNhdGlvbi1pY29ucy5odG1sXCI+XG5cbiAgICA8aXJvbi1pY29uIGljb249XCJjb21tdW5pY2F0aW9uOmVtYWlsXCI+PC9pcm9uLWljb24+XG5cbllvdSBjYW4gYWxzbyBjcmVhdGUgY3VzdG9tIGljb24gc2V0cyBvZiBiaXRtYXAgb3IgU1ZHIGljb25zLlxuXG5FeGFtcGxlIG9mIHVzaW5nIGFuIGljb24gbmFtZWQgYGNoZXJyeWAgZnJvbSBhIGN1c3RvbSBpY29uc2V0IHdpdGggdGhlIElEIGBmcnVpdGA6XG5cbiAgICA8aXJvbi1pY29uIGljb249XCJmcnVpdDpjaGVycnlcIj48L2lyb24taWNvbj5cblxuU2VlIFtpcm9uLWljb25zZXRdKGlyb24taWNvbnNldCkgYW5kIFtpcm9uLWljb25zZXQtc3ZnXShpcm9uLWljb25zZXQtc3ZnKSBmb3IgbW9yZSBpbmZvcm1hdGlvbiBhYm91dFxuaG93IHRvIGNyZWF0ZSBhIGN1c3RvbSBpY29uc2V0LlxuXG5TZWUgdGhlIFtpcm9uLWljb25zIGRlbW9dKGlyb24taWNvbnM/dmlldz1kZW1vOmRlbW8vaW5kZXguaHRtbCkgdG8gc2VlIHRoZSBpY29ucyBhdmFpbGFibGVcbmluIHRoZSB2YXJpb3VzIGljb25zZXRzLlxuXG5UbyBsb2FkIGEgc3Vic2V0IG9mIGljb25zIGZyb20gb25lIG9mIHRoZSBkZWZhdWx0IGBpcm9uLWljb25zYCBzZXRzLCB5b3UgY2FuXG51c2UgdGhlIFtwb2x5LWljb25dKGh0dHBzOi8vcG9seS1pY29uLmFwcHNwb3QuY29tLykgdG9vbC4gSXQgYWxsb3dzIHlvdVxudG8gc2VsZWN0IGluZGl2aWR1YWwgaWNvbnMsIGFuZCBjcmVhdGVzIGFuIGljb25zZXQgZnJvbSB0aGVtIHRoYXQgeW91IGNhblxudXNlIGRpcmVjdGx5IGluIHlvdXIgZWxlbWVudHMuXG5cbiMjIyBTdHlsaW5nXG5cblRoZSBmb2xsb3dpbmcgY3VzdG9tIHByb3BlcnRpZXMgYXJlIGF2YWlsYWJsZSBmb3Igc3R5bGluZzpcblxuQ3VzdG9tIHByb3BlcnR5IHwgRGVzY3JpcHRpb24gfCBEZWZhdWx0XG4tLS0tLS0tLS0tLS0tLS0tfC0tLS0tLS0tLS0tLS18LS0tLS0tLS0tLVxuYC0taXJvbi1pY29uYCB8IE1peGluIGFwcGxpZWQgdG8gdGhlIGljb24gfCB7fVxuYC0taXJvbi1pY29uLXdpZHRoYCB8IFdpZHRoIG9mIHRoZSBpY29uIHwgYDI0cHhgXG5gLS1pcm9uLWljb24taGVpZ2h0YCB8IEhlaWdodCBvZiB0aGUgaWNvbiB8IGAyNHB4YFxuYC0taXJvbi1pY29uLWZpbGwtY29sb3JgIHwgRmlsbCBjb2xvciBvZiB0aGUgc3ZnIGljb24gfCBgY3VycmVudGNvbG9yYFxuYC0taXJvbi1pY29uLXN0cm9rZS1jb2xvcmAgfCBTdHJva2UgY29sb3Igb2YgdGhlIHN2ZyBpY29uIHwgbm9uZVxuXG5AZ3JvdXAgSXJvbiBFbGVtZW50c1xuQGVsZW1lbnQgaXJvbi1pY29uXG5AZGVtbyBkZW1vL2luZGV4Lmh0bWxcbkBoZXJvIGhlcm8uc3ZnXG5AaG9tZXBhZ2UgcG9seW1lci5naXRodWIuaW9cbi0tPlxuXG48ZG9tLW1vZHVsZSBpZD1cImlyb24taWNvblwiPlxuICA8dGVtcGxhdGU+XG4gICAgPHN0eWxlPlxuICAgICAgOmhvc3Qge1xuICAgICAgICBAYXBwbHkgLS1sYXlvdXQtaW5saW5lO1xuICAgICAgICBAYXBwbHkgLS1sYXlvdXQtY2VudGVyLWNlbnRlcjtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuXG4gICAgICAgIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XG5cbiAgICAgICAgZmlsbDogdmFyKC0taXJvbi1pY29uLWZpbGwtY29sb3IsIGN1cnJlbnRjb2xvcik7XG4gICAgICAgIHN0cm9rZTogdmFyKC0taXJvbi1pY29uLXN0cm9rZS1jb2xvciwgbm9uZSk7XG5cbiAgICAgICAgd2lkdGg6IHZhcigtLWlyb24taWNvbi13aWR0aCwgMjRweCk7XG4gICAgICAgIGhlaWdodDogdmFyKC0taXJvbi1pY29uLWhlaWdodCwgMjRweCk7XG4gICAgICAgIEBhcHBseSAtLWlyb24taWNvbjtcbiAgICAgIH1cblxuICAgICAgOmhvc3QoW2hpZGRlbl0pIHtcbiAgICAgICAgZGlzcGxheTogbm9uZTtcbiAgICAgIH1cbiAgICA8L3N0eWxlPlxuICA8L3RlbXBsYXRlPlxuXG4gIDxzY3JpcHQ+XG5cbiAgICBQb2x5bWVyKHtcblxuICAgICAgaXM6ICdpcm9uLWljb24nLFxuXG4gICAgICBwcm9wZXJ0aWVzOiB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBuYW1lIG9mIHRoZSBpY29uIHRvIHVzZS4gVGhlIG5hbWUgc2hvdWxkIGJlIG9mIHRoZSBmb3JtOlxuICAgICAgICAgKiBgaWNvbnNldF9uYW1lOmljb25fbmFtZWAuXG4gICAgICAgICAqL1xuICAgICAgICBpY29uOiB7XG4gICAgICAgICAgdHlwZTogU3RyaW5nXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBuYW1lIG9mIHRoZSB0aGVtZSB0byB1c2VkLCBpZiBvbmUgaXMgc3BlY2lmaWVkIGJ5IHRoZVxuICAgICAgICAgKiBpY29uc2V0LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhlbWU6IHtcbiAgICAgICAgICB0eXBlOiBTdHJpbmdcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgdXNpbmcgaXJvbi1pY29uIHdpdGhvdXQgYW4gaWNvbnNldCwgeW91IGNhbiBzZXQgdGhlIHNyYyB0byBiZVxuICAgICAgICAgKiB0aGUgVVJMIG9mIGFuIGluZGl2aWR1YWwgaWNvbiBpbWFnZSBmaWxlLiBOb3RlIHRoYXQgdGhpcyB3aWxsIHRha2VcbiAgICAgICAgICogcHJlY2VkZW5jZSBvdmVyIGEgZ2l2ZW4gaWNvbiBhdHRyaWJ1dGUuXG4gICAgICAgICAqL1xuICAgICAgICBzcmM6IHtcbiAgICAgICAgICB0eXBlOiBTdHJpbmdcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUgeyFQb2x5bWVyLklyb25NZXRhfVxuICAgICAgICAgKi9cbiAgICAgICAgX21ldGE6IHtcbiAgICAgICAgICB2YWx1ZTogUG9seW1lci5CYXNlLmNyZWF0ZSgnaXJvbi1tZXRhJywge3R5cGU6ICdpY29uc2V0J30pXG4gICAgICAgIH1cblxuICAgICAgfSxcblxuICAgICAgb2JzZXJ2ZXJzOiBbXG4gICAgICAgICdfdXBkYXRlSWNvbihfbWV0YSwgaXNBdHRhY2hlZCknLFxuICAgICAgICAnX3VwZGF0ZUljb24odGhlbWUsIGlzQXR0YWNoZWQpJyxcbiAgICAgICAgJ19zcmNDaGFuZ2VkKHNyYywgaXNBdHRhY2hlZCknLFxuICAgICAgICAnX2ljb25DaGFuZ2VkKGljb24sIGlzQXR0YWNoZWQpJ1xuICAgICAgXSxcblxuICAgICAgX0RFRkFVTFRfSUNPTlNFVDogJ2ljb25zJyxcblxuICAgICAgX2ljb25DaGFuZ2VkOiBmdW5jdGlvbihpY29uKSB7XG4gICAgICAgIHZhciBwYXJ0cyA9IChpY29uIHx8ICcnKS5zcGxpdCgnOicpO1xuICAgICAgICB0aGlzLl9pY29uTmFtZSA9IHBhcnRzLnBvcCgpO1xuICAgICAgICB0aGlzLl9pY29uc2V0TmFtZSA9IHBhcnRzLnBvcCgpIHx8IHRoaXMuX0RFRkFVTFRfSUNPTlNFVDtcbiAgICAgICAgdGhpcy5fdXBkYXRlSWNvbigpO1xuICAgICAgfSxcblxuICAgICAgX3NyY0NoYW5nZWQ6IGZ1bmN0aW9uKHNyYykge1xuICAgICAgICB0aGlzLl91cGRhdGVJY29uKCk7XG4gICAgICB9LFxuXG4gICAgICBfdXNlc0ljb25zZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pY29uIHx8ICF0aGlzLnNyYztcbiAgICAgIH0sXG5cbiAgICAgIC8qKiBAc3VwcHJlc3Mge3Zpc2liaWxpdHl9ICovXG4gICAgICBfdXBkYXRlSWNvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl91c2VzSWNvbnNldCgpKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX2ltZyAmJiB0aGlzLl9pbWcucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgUG9seW1lci5kb20odGhpcy5yb290KS5yZW1vdmVDaGlsZCh0aGlzLl9pbWcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy5faWNvbk5hbWUgPT09IFwiXCIpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9pY29uc2V0KSB7XG4gICAgICAgICAgICAgIHRoaXMuX2ljb25zZXQucmVtb3ZlSWNvbih0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2ljb25zZXROYW1lICYmIHRoaXMuX21ldGEpIHtcbiAgICAgICAgICAgIHRoaXMuX2ljb25zZXQgPSAvKiogQHR5cGUgez9Qb2x5bWVyLkljb25zZXR9ICovIChcbiAgICAgICAgICAgICAgdGhpcy5fbWV0YS5ieUtleSh0aGlzLl9pY29uc2V0TmFtZSkpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2ljb25zZXQpIHtcbiAgICAgICAgICAgICAgdGhpcy5faWNvbnNldC5hcHBseUljb24odGhpcywgdGhpcy5faWNvbk5hbWUsIHRoaXMudGhlbWUpO1xuICAgICAgICAgICAgICB0aGlzLnVubGlzdGVuKHdpbmRvdywgJ2lyb24taWNvbnNldC1hZGRlZCcsICdfdXBkYXRlSWNvbicpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5saXN0ZW4od2luZG93LCAnaXJvbi1pY29uc2V0LWFkZGVkJywgJ191cGRhdGVJY29uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh0aGlzLl9pY29uc2V0KSB7XG4gICAgICAgICAgICB0aGlzLl9pY29uc2V0LnJlbW92ZUljb24odGhpcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghdGhpcy5faW1nKSB7XG4gICAgICAgICAgICB0aGlzLl9pbWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcbiAgICAgICAgICAgIHRoaXMuX2ltZy5zdHlsZS53aWR0aCA9ICcxMDAlJztcbiAgICAgICAgICAgIHRoaXMuX2ltZy5zdHlsZS5oZWlnaHQgPSAnMTAwJSc7XG4gICAgICAgICAgICB0aGlzLl9pbWcuZHJhZ2dhYmxlID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX2ltZy5zcmMgPSB0aGlzLnNyYztcbiAgICAgICAgICBQb2x5bWVyLmRvbSh0aGlzLnJvb3QpLmFwcGVuZENoaWxkKHRoaXMuX2ltZyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgIH0pO1xuXG4gIDwvc2NyaXB0PlxuXG48L2RvbS1tb2R1bGU+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL2lyb24taWNvbi9pcm9uLWljb24uaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTUgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cblxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3BvbHltZXIvcG9seW1lci5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vaXJvbi1iZWhhdmlvcnMvaXJvbi1idXR0b24tc3RhdGUuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cInBhcGVyLXJpcHBsZS1iZWhhdmlvci5odG1sXCI+XG5cbjxzY3JpcHQ+XG4gIC8qKlxuICAgKiBgUG9seW1lci5QYXBlcklua3lGb2N1c0JlaGF2aW9yYCBpbXBsZW1lbnRzIGEgcmlwcGxlIHdoZW4gdGhlIGVsZW1lbnQgaGFzIGtleWJvYXJkIGZvY3VzLlxuICAgKlxuICAgKiBAcG9seW1lckJlaGF2aW9yIFBvbHltZXIuUGFwZXJJbmt5Rm9jdXNCZWhhdmlvclxuICAgKi9cbiAgUG9seW1lci5QYXBlcklua3lGb2N1c0JlaGF2aW9ySW1wbCA9IHtcbiAgICBvYnNlcnZlcnM6IFtcbiAgICAgICdfZm9jdXNlZENoYW5nZWQocmVjZWl2ZWRGb2N1c0Zyb21LZXlib2FyZCknXG4gICAgXSxcblxuICAgIF9mb2N1c2VkQ2hhbmdlZDogZnVuY3Rpb24ocmVjZWl2ZWRGb2N1c0Zyb21LZXlib2FyZCkge1xuICAgICAgaWYgKHJlY2VpdmVkRm9jdXNGcm9tS2V5Ym9hcmQpIHtcbiAgICAgICAgdGhpcy5lbnN1cmVSaXBwbGUoKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmhhc1JpcHBsZSgpKSB7XG4gICAgICAgIHRoaXMuX3JpcHBsZS5ob2xkRG93biA9IHJlY2VpdmVkRm9jdXNGcm9tS2V5Ym9hcmQ7XG4gICAgICB9XG4gICAgfSxcblxuICAgIF9jcmVhdGVSaXBwbGU6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHJpcHBsZSA9IFBvbHltZXIuUGFwZXJSaXBwbGVCZWhhdmlvci5fY3JlYXRlUmlwcGxlKCk7XG4gICAgICByaXBwbGUuaWQgPSAnaW5rJztcbiAgICAgIHJpcHBsZS5zZXRBdHRyaWJ1dGUoJ2NlbnRlcicsICcnKTtcbiAgICAgIHJpcHBsZS5jbGFzc0xpc3QuYWRkKCdjaXJjbGUnKTtcbiAgICAgIHJldHVybiByaXBwbGU7XG4gICAgfVxuICB9O1xuXG4gIC8qKiBAcG9seW1lckJlaGF2aW9yIFBvbHltZXIuUGFwZXJJbmt5Rm9jdXNCZWhhdmlvciAqL1xuICBQb2x5bWVyLlBhcGVySW5reUZvY3VzQmVoYXZpb3IgPSBbXG4gICAgUG9seW1lci5Jcm9uQnV0dG9uU3RhdGUsXG4gICAgUG9seW1lci5Jcm9uQ29udHJvbFN0YXRlLFxuICAgIFBvbHltZXIuUGFwZXJSaXBwbGVCZWhhdmlvcixcbiAgICBQb2x5bWVyLlBhcGVySW5reUZvY3VzQmVoYXZpb3JJbXBsXG4gIF07XG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvcGFwZXItYmVoYXZpb3JzL3BhcGVyLWlua3ktZm9jdXMtYmVoYXZpb3IuaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTUgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cblxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3BvbHltZXIvcG9seW1lci5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vaXJvbi1hMTF5LWtleXMtYmVoYXZpb3IvaXJvbi1hMTF5LWtleXMtYmVoYXZpb3IuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cImlyb24tY29udHJvbC1zdGF0ZS5odG1sXCI+XG5cbjxzY3JpcHQ+XG5cbiAgLyoqXG4gICAqIEBkZW1vIGRlbW8vaW5kZXguaHRtbFxuICAgKiBAcG9seW1lckJlaGF2aW9yIFBvbHltZXIuSXJvbkJ1dHRvblN0YXRlXG4gICAqL1xuICBQb2x5bWVyLklyb25CdXR0b25TdGF0ZUltcGwgPSB7XG5cbiAgICBwcm9wZXJ0aWVzOiB7XG5cbiAgICAgIC8qKlxuICAgICAgICogSWYgdHJ1ZSwgdGhlIHVzZXIgaXMgY3VycmVudGx5IGhvbGRpbmcgZG93biB0aGUgYnV0dG9uLlxuICAgICAgICovXG4gICAgICBwcmVzc2VkOiB7XG4gICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgIHJlYWRPbmx5OiB0cnVlLFxuICAgICAgICB2YWx1ZTogZmFsc2UsXG4gICAgICAgIHJlZmxlY3RUb0F0dHJpYnV0ZTogdHJ1ZSxcbiAgICAgICAgb2JzZXJ2ZXI6ICdfcHJlc3NlZENoYW5nZWQnXG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIElmIHRydWUsIHRoZSBidXR0b24gdG9nZ2xlcyB0aGUgYWN0aXZlIHN0YXRlIHdpdGggZWFjaCB0YXAgb3IgcHJlc3NcbiAgICAgICAqIG9mIHRoZSBzcGFjZWJhci5cbiAgICAgICAqL1xuICAgICAgdG9nZ2xlczoge1xuICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICB2YWx1ZTogZmFsc2UsXG4gICAgICAgIHJlZmxlY3RUb0F0dHJpYnV0ZTogdHJ1ZVxuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBJZiB0cnVlLCB0aGUgYnV0dG9uIGlzIGEgdG9nZ2xlIGFuZCBpcyBjdXJyZW50bHkgaW4gdGhlIGFjdGl2ZSBzdGF0ZS5cbiAgICAgICAqL1xuICAgICAgYWN0aXZlOiB7XG4gICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgIHZhbHVlOiBmYWxzZSxcbiAgICAgICAgbm90aWZ5OiB0cnVlLFxuICAgICAgICByZWZsZWN0VG9BdHRyaWJ1dGU6IHRydWVcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogVHJ1ZSBpZiB0aGUgZWxlbWVudCBpcyBjdXJyZW50bHkgYmVpbmcgcHJlc3NlZCBieSBhIFwicG9pbnRlcixcIiB3aGljaFxuICAgICAgICogaXMgbG9vc2VseSBkZWZpbmVkIGFzIG1vdXNlIG9yIHRvdWNoIGlucHV0IChidXQgc3BlY2lmaWNhbGx5IGV4Y2x1ZGluZ1xuICAgICAgICoga2V5Ym9hcmQgaW5wdXQpLlxuICAgICAgICovXG4gICAgICBwb2ludGVyRG93bjoge1xuICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICByZWFkT25seTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFRydWUgaWYgdGhlIGlucHV0IGRldmljZSB0aGF0IGNhdXNlZCB0aGUgZWxlbWVudCB0byByZWNlaXZlIGZvY3VzXG4gICAgICAgKiB3YXMgYSBrZXlib2FyZC5cbiAgICAgICAqL1xuICAgICAgcmVjZWl2ZWRGb2N1c0Zyb21LZXlib2FyZDoge1xuICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICByZWFkT25seTogdHJ1ZVxuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBUaGUgYXJpYSBhdHRyaWJ1dGUgdG8gYmUgc2V0IGlmIHRoZSBidXR0b24gaXMgYSB0b2dnbGUgYW5kIGluIHRoZVxuICAgICAgICogYWN0aXZlIHN0YXRlLlxuICAgICAgICovXG4gICAgICBhcmlhQWN0aXZlQXR0cmlidXRlOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgdmFsdWU6ICdhcmlhLXByZXNzZWQnLFxuICAgICAgICBvYnNlcnZlcjogJ19hcmlhQWN0aXZlQXR0cmlidXRlQ2hhbmdlZCdcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgbGlzdGVuZXJzOiB7XG4gICAgICBkb3duOiAnX2Rvd25IYW5kbGVyJyxcbiAgICAgIHVwOiAnX3VwSGFuZGxlcicsXG4gICAgICB0YXA6ICdfdGFwSGFuZGxlcidcbiAgICB9LFxuXG4gICAgb2JzZXJ2ZXJzOiBbXG4gICAgICAnX2ZvY3VzQ2hhbmdlZChmb2N1c2VkKScsXG4gICAgICAnX2FjdGl2ZUNoYW5nZWQoYWN0aXZlLCBhcmlhQWN0aXZlQXR0cmlidXRlKSdcbiAgICBdLFxuXG4gICAga2V5QmluZGluZ3M6IHtcbiAgICAgICdlbnRlcjprZXlkb3duJzogJ19hc3luY0NsaWNrJyxcbiAgICAgICdzcGFjZTprZXlkb3duJzogJ19zcGFjZUtleURvd25IYW5kbGVyJyxcbiAgICAgICdzcGFjZTprZXl1cCc6ICdfc3BhY2VLZXlVcEhhbmRsZXInLFxuICAgIH0sXG5cbiAgICBfbW91c2VFdmVudFJlOiAvXm1vdXNlLyxcblxuICAgIF90YXBIYW5kbGVyOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLnRvZ2dsZXMpIHtcbiAgICAgICAvLyBhIHRhcCBpcyBuZWVkZWQgdG8gdG9nZ2xlIHRoZSBhY3RpdmUgc3RhdGVcbiAgICAgICAgdGhpcy5fdXNlckFjdGl2YXRlKCF0aGlzLmFjdGl2ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBfZm9jdXNDaGFuZ2VkOiBmdW5jdGlvbihmb2N1c2VkKSB7XG4gICAgICB0aGlzLl9kZXRlY3RLZXlib2FyZEZvY3VzKGZvY3VzZWQpO1xuXG4gICAgICBpZiAoIWZvY3VzZWQpIHtcbiAgICAgICAgdGhpcy5fc2V0UHJlc3NlZChmYWxzZSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIF9kZXRlY3RLZXlib2FyZEZvY3VzOiBmdW5jdGlvbihmb2N1c2VkKSB7XG4gICAgICB0aGlzLl9zZXRSZWNlaXZlZEZvY3VzRnJvbUtleWJvYXJkKCF0aGlzLnBvaW50ZXJEb3duICYmIGZvY3VzZWQpO1xuICAgIH0sXG5cbiAgICAvLyB0byBlbXVsYXRlIG5hdGl2ZSBjaGVja2JveCwgKGRlLSlhY3RpdmF0aW9ucyBmcm9tIGEgdXNlciBpbnRlcmFjdGlvbiBmaXJlXG4gICAgLy8gJ2NoYW5nZScgZXZlbnRzXG4gICAgX3VzZXJBY3RpdmF0ZTogZnVuY3Rpb24oYWN0aXZlKSB7XG4gICAgICBpZiAodGhpcy5hY3RpdmUgIT09IGFjdGl2ZSkge1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IGFjdGl2ZTtcbiAgICAgICAgdGhpcy5maXJlKCdjaGFuZ2UnKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgX2Rvd25IYW5kbGVyOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgdGhpcy5fc2V0UG9pbnRlckRvd24odHJ1ZSk7XG4gICAgICB0aGlzLl9zZXRQcmVzc2VkKHRydWUpO1xuICAgICAgdGhpcy5fc2V0UmVjZWl2ZWRGb2N1c0Zyb21LZXlib2FyZChmYWxzZSk7XG4gICAgfSxcblxuICAgIF91cEhhbmRsZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fc2V0UG9pbnRlckRvd24oZmFsc2UpO1xuICAgICAgdGhpcy5fc2V0UHJlc3NlZChmYWxzZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IUtleWJvYXJkRXZlbnR9IGV2ZW50IC5cbiAgICAgKi9cbiAgICBfc3BhY2VLZXlEb3duSGFuZGxlcjogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIHZhciBrZXlib2FyZEV2ZW50ID0gZXZlbnQuZGV0YWlsLmtleWJvYXJkRXZlbnQ7XG4gICAgICB2YXIgdGFyZ2V0ID0gUG9seW1lci5kb20oa2V5Ym9hcmRFdmVudCkubG9jYWxUYXJnZXQ7XG5cbiAgICAgIC8vIElnbm9yZSB0aGUgZXZlbnQgaWYgdGhpcyBpcyBjb21pbmcgZnJvbSBhIGZvY3VzZWQgbGlnaHQgY2hpbGQsIHNpbmNlIHRoYXRcbiAgICAgIC8vIGVsZW1lbnQgd2lsbCBkZWFsIHdpdGggaXQuXG4gICAgICBpZiAodGhpcy5pc0xpZ2h0RGVzY2VuZGFudCgvKiogQHR5cGUge05vZGV9ICovKHRhcmdldCkpKVxuICAgICAgICByZXR1cm47XG5cbiAgICAgIGtleWJvYXJkRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGtleWJvYXJkRXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICB0aGlzLl9zZXRQcmVzc2VkKHRydWUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyFLZXlib2FyZEV2ZW50fSBldmVudCAuXG4gICAgICovXG4gICAgX3NwYWNlS2V5VXBIYW5kbGVyOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgdmFyIGtleWJvYXJkRXZlbnQgPSBldmVudC5kZXRhaWwua2V5Ym9hcmRFdmVudDtcbiAgICAgIHZhciB0YXJnZXQgPSBQb2x5bWVyLmRvbShrZXlib2FyZEV2ZW50KS5sb2NhbFRhcmdldDtcblxuICAgICAgLy8gSWdub3JlIHRoZSBldmVudCBpZiB0aGlzIGlzIGNvbWluZyBmcm9tIGEgZm9jdXNlZCBsaWdodCBjaGlsZCwgc2luY2UgdGhhdFxuICAgICAgLy8gZWxlbWVudCB3aWxsIGRlYWwgd2l0aCBpdC5cbiAgICAgIGlmICh0aGlzLmlzTGlnaHREZXNjZW5kYW50KC8qKiBAdHlwZSB7Tm9kZX0gKi8odGFyZ2V0KSkpXG4gICAgICAgIHJldHVybjtcblxuICAgICAgaWYgKHRoaXMucHJlc3NlZCkge1xuICAgICAgICB0aGlzLl9hc3luY0NsaWNrKCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9zZXRQcmVzc2VkKGZhbHNlKTtcbiAgICB9LFxuXG4gICAgLy8gdHJpZ2dlciBjbGljayBhc3luY2hyb25vdXNseSwgdGhlIGFzeW5jaHJvbnkgaXMgdXNlZnVsIHRvIGFsbG93IG9uZVxuICAgIC8vIGV2ZW50IGhhbmRsZXIgdG8gdW53aW5kIGJlZm9yZSB0cmlnZ2VyaW5nIGFub3RoZXIgZXZlbnRcbiAgICBfYXN5bmNDbGljazogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmFzeW5jKGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmNsaWNrKCk7XG4gICAgICB9LCAxKTtcbiAgICB9LFxuXG4gICAgLy8gYW55IG9mIHRoZXNlIGNoYW5nZXMgYXJlIGNvbnNpZGVyZWQgYSBjaGFuZ2UgdG8gYnV0dG9uIHN0YXRlXG5cbiAgICBfcHJlc3NlZENoYW5nZWQ6IGZ1bmN0aW9uKHByZXNzZWQpIHtcbiAgICAgIHRoaXMuX2NoYW5nZWRCdXR0b25TdGF0ZSgpO1xuICAgIH0sXG5cbiAgICBfYXJpYUFjdGl2ZUF0dHJpYnV0ZUNoYW5nZWQ6IGZ1bmN0aW9uKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgaWYgKG9sZFZhbHVlICYmIG9sZFZhbHVlICE9IHZhbHVlICYmIHRoaXMuaGFzQXR0cmlidXRlKG9sZFZhbHVlKSkge1xuICAgICAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZShvbGRWYWx1ZSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIF9hY3RpdmVDaGFuZ2VkOiBmdW5jdGlvbihhY3RpdmUsIGFyaWFBY3RpdmVBdHRyaWJ1dGUpIHtcbiAgICAgIGlmICh0aGlzLnRvZ2dsZXMpIHtcbiAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUodGhpcy5hcmlhQWN0aXZlQXR0cmlidXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmUgPyAndHJ1ZScgOiAnZmFsc2UnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlKHRoaXMuYXJpYUFjdGl2ZUF0dHJpYnV0ZSk7XG4gICAgICB9XG4gICAgICB0aGlzLl9jaGFuZ2VkQnV0dG9uU3RhdGUoKTtcbiAgICB9LFxuXG4gICAgX2NvbnRyb2xTdGF0ZUNoYW5nZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgdGhpcy5fc2V0UHJlc3NlZChmYWxzZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9jaGFuZ2VkQnV0dG9uU3RhdGUoKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gcHJvdmlkZSBob29rIGZvciBmb2xsb3ctb24gYmVoYXZpb3JzIHRvIHJlYWN0IHRvIGJ1dHRvbi1zdGF0ZVxuXG4gICAgX2NoYW5nZWRCdXR0b25TdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5fYnV0dG9uU3RhdGVDaGFuZ2VkKSB7XG4gICAgICAgIHRoaXMuX2J1dHRvblN0YXRlQ2hhbmdlZCgpOyAvLyBhYnN0cmFjdFxuICAgICAgfVxuICAgIH1cblxuICB9O1xuXG4gIC8qKiBAcG9seW1lckJlaGF2aW9yICovXG4gIFBvbHltZXIuSXJvbkJ1dHRvblN0YXRlID0gW1xuICAgIFBvbHltZXIuSXJvbkExMXlLZXlzQmVoYXZpb3IsXG4gICAgUG9seW1lci5Jcm9uQnV0dG9uU3RhdGVJbXBsXG4gIF07XG5cbjwvc2NyaXB0PlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9pcm9uLWJlaGF2aW9ycy9pcm9uLWJ1dHRvbi1zdGF0ZS5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNSBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuXG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vcG9seW1lci9wb2x5bWVyLmh0bWxcIj5cblxuPHNjcmlwdD5cblxuICAvKipcbiAgICogQGRlbW8gZGVtby9pbmRleC5odG1sXG4gICAqIEBwb2x5bWVyQmVoYXZpb3JcbiAgICovXG4gIFBvbHltZXIuSXJvbkNvbnRyb2xTdGF0ZSA9IHtcblxuICAgIHByb3BlcnRpZXM6IHtcblxuICAgICAgLyoqXG4gICAgICAgKiBJZiB0cnVlLCB0aGUgZWxlbWVudCBjdXJyZW50bHkgaGFzIGZvY3VzLlxuICAgICAgICovXG4gICAgICBmb2N1c2VkOiB7XG4gICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgIHZhbHVlOiBmYWxzZSxcbiAgICAgICAgbm90aWZ5OiB0cnVlLFxuICAgICAgICByZWFkT25seTogdHJ1ZSxcbiAgICAgICAgcmVmbGVjdFRvQXR0cmlidXRlOiB0cnVlXG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIElmIHRydWUsIHRoZSB1c2VyIGNhbm5vdCBpbnRlcmFjdCB3aXRoIHRoaXMgZWxlbWVudC5cbiAgICAgICAqL1xuICAgICAgZGlzYWJsZWQ6IHtcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgdmFsdWU6IGZhbHNlLFxuICAgICAgICBub3RpZnk6IHRydWUsXG4gICAgICAgIG9ic2VydmVyOiAnX2Rpc2FibGVkQ2hhbmdlZCcsXG4gICAgICAgIHJlZmxlY3RUb0F0dHJpYnV0ZTogdHJ1ZVxuICAgICAgfSxcblxuICAgICAgX29sZFRhYkluZGV4OiB7XG4gICAgICAgIHR5cGU6IE51bWJlclxuICAgICAgfSxcblxuICAgICAgX2JvdW5kRm9jdXNCbHVySGFuZGxlcjoge1xuICAgICAgICB0eXBlOiBGdW5jdGlvbixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9mb2N1c0JsdXJIYW5kbGVyLmJpbmQodGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIF9faGFuZGxlRXZlbnRSZXRhcmdldGluZzoge1xuICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuICF0aGlzLnNoYWRvd1Jvb3QgJiYgIVBvbHltZXIuRWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBvYnNlcnZlcnM6IFtcbiAgICAgICdfY2hhbmdlZENvbnRyb2xTdGF0ZShmb2N1c2VkLCBkaXNhYmxlZCknXG4gICAgXSxcblxuICAgIHJlYWR5OiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXMnLCB0aGlzLl9ib3VuZEZvY3VzQmx1ckhhbmRsZXIsIHRydWUpO1xuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgdGhpcy5fYm91bmRGb2N1c0JsdXJIYW5kbGVyLCB0cnVlKTtcbiAgICB9LFxuXG4gICAgX2ZvY3VzQmx1ckhhbmRsZXI6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAvLyBJbiBQb2x5bWVyIDIuMCwgdGhlIGxpYnJhcnkgdGFrZXMgY2FyZSBvZiByZXRhcmdldGluZyBldmVudHMuXG4gICAgICBpZiAoUG9seW1lci5FbGVtZW50KSB7XG4gICAgICAgIHRoaXMuX3NldEZvY3VzZWQoZXZlbnQudHlwZSA9PT0gJ2ZvY3VzJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gTk9URShjZGF0YSk6ICBpZiB3ZSBhcmUgaW4gU2hhZG93RE9NIGxhbmQsIGBldmVudC50YXJnZXRgIHdpbGxcbiAgICAgIC8vIGV2ZW50dWFsbHkgYmVjb21lIGB0aGlzYCBkdWUgdG8gcmV0YXJnZXRpbmc7IGlmIHdlIGFyZSBub3QgaW5cbiAgICAgIC8vIFNoYWRvd0RPTSBsYW5kLCBgZXZlbnQudGFyZ2V0YCB3aWxsIGV2ZW50dWFsbHkgYmVjb21lIGB0aGlzYCBkdWVcbiAgICAgIC8vIHRvIHRoZSBzZWNvbmQgY29uZGl0aW9uYWwgd2hpY2ggZmlyZXMgYSBzeW50aGV0aWMgZXZlbnQgKHRoYXQgaXMgYWxzb1xuICAgICAgLy8gaGFuZGxlZCkuIEluIGVpdGhlciBjYXNlLCB3ZSBjYW4gZGlzcmVnYXJkIGBldmVudC5wYXRoYC5cbiAgICAgIGlmIChldmVudC50YXJnZXQgPT09IHRoaXMpIHtcbiAgICAgICAgdGhpcy5fc2V0Rm9jdXNlZChldmVudC50eXBlID09PSAnZm9jdXMnKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fX2hhbmRsZUV2ZW50UmV0YXJnZXRpbmcpIHtcbiAgICAgICAgdmFyIHRhcmdldCA9IC8qKiBAdHlwZSB7Tm9kZX0gKi8oUG9seW1lci5kb20oZXZlbnQpLmxvY2FsVGFyZ2V0KTtcbiAgICAgICAgaWYgKCF0aGlzLmlzTGlnaHREZXNjZW5kYW50KHRhcmdldCkpIHtcbiAgICAgICAgICB0aGlzLmZpcmUoZXZlbnQudHlwZSwge3NvdXJjZUV2ZW50OiBldmVudH0sIHtcbiAgICAgICAgICAgIG5vZGU6IHRoaXMsXG4gICAgICAgICAgICBidWJibGVzOiBldmVudC5idWJibGVzLFxuICAgICAgICAgICAgY2FuY2VsYWJsZTogZXZlbnQuY2FuY2VsYWJsZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIF9kaXNhYmxlZENoYW5nZWQ6IGZ1bmN0aW9uKGRpc2FibGVkLCBvbGQpIHtcbiAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdhcmlhLWRpc2FibGVkJywgZGlzYWJsZWQgPyAndHJ1ZScgOiAnZmFsc2UnKTtcbiAgICAgIHRoaXMuc3R5bGUucG9pbnRlckV2ZW50cyA9IGRpc2FibGVkID8gJ25vbmUnIDogJyc7XG4gICAgICBpZiAoZGlzYWJsZWQpIHtcbiAgICAgICAgdGhpcy5fb2xkVGFiSW5kZXggPSB0aGlzLnRhYkluZGV4O1xuICAgICAgICB0aGlzLl9zZXRGb2N1c2VkKGZhbHNlKTtcbiAgICAgICAgdGhpcy50YWJJbmRleCA9IC0xO1xuICAgICAgICB0aGlzLmJsdXIoKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fb2xkVGFiSW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLnRhYkluZGV4ID0gdGhpcy5fb2xkVGFiSW5kZXg7XG4gICAgICB9XG4gICAgfSxcblxuICAgIF9jaGFuZ2VkQ29udHJvbFN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgIC8vIF9jb250cm9sU3RhdGVDaGFuZ2VkIGlzIGFic3RyYWN0LCBmb2xsb3ctb24gYmVoYXZpb3JzIG1heSBpbXBsZW1lbnQgaXRcbiAgICAgIGlmICh0aGlzLl9jb250cm9sU3RhdGVDaGFuZ2VkKSB7XG4gICAgICAgIHRoaXMuX2NvbnRyb2xTdGF0ZUNoYW5nZWQoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgfTtcblxuPC9zY3JpcHQ+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL2lyb24tYmVoYXZpb3JzL2lyb24tY29udHJvbC1zdGF0ZS5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNSBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuXG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vcG9seW1lci9wb2x5bWVyLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi9wYXBlci1yaXBwbGUvcGFwZXItcmlwcGxlLmh0bWxcIj5cblxuPHNjcmlwdD5cbiAgLyoqXG4gICAqIGBQb2x5bWVyLlBhcGVyUmlwcGxlQmVoYXZpb3JgIGR5bmFtaWNhbGx5IGltcGxlbWVudHMgYSByaXBwbGVcbiAgICogd2hlbiB0aGUgZWxlbWVudCBoYXMgZm9jdXMgdmlhIHBvaW50ZXIgb3Iga2V5Ym9hcmQuXG4gICAqXG4gICAqIE5PVEU6IFRoaXMgYmVoYXZpb3IgaXMgaW50ZW5kZWQgdG8gYmUgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIGFuZCBhZnRlclxuICAgKiBgUG9seW1lci5Jcm9uQnV0dG9uU3RhdGVgIGFuZCBgUG9seW1lci5Jcm9uQ29udHJvbFN0YXRlYC5cbiAgICpcbiAgICogQHBvbHltZXJCZWhhdmlvciBQb2x5bWVyLlBhcGVyUmlwcGxlQmVoYXZpb3JcbiAgICovXG4gIFBvbHltZXIuUGFwZXJSaXBwbGVCZWhhdmlvciA9IHtcbiAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAvKipcbiAgICAgICAqIElmIHRydWUsIHRoZSBlbGVtZW50IHdpbGwgbm90IHByb2R1Y2UgYSByaXBwbGUgZWZmZWN0IHdoZW4gaW50ZXJhY3RlZFxuICAgICAgICogd2l0aCB2aWEgdGhlIHBvaW50ZXIuXG4gICAgICAgKi9cbiAgICAgIG5vaW5rOiB7XG4gICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgIG9ic2VydmVyOiAnX25vaW5rQ2hhbmdlZCdcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogQHR5cGUge0VsZW1lbnR8dW5kZWZpbmVkfVxuICAgICAgICovXG4gICAgICBfcmlwcGxlQ29udGFpbmVyOiB7XG4gICAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRW5zdXJlcyBhIGA8cGFwZXItcmlwcGxlPmAgZWxlbWVudCBpcyBhdmFpbGFibGUgd2hlbiB0aGUgZWxlbWVudCBpc1xuICAgICAqIGZvY3VzZWQuXG4gICAgICovXG4gICAgX2J1dHRvblN0YXRlQ2hhbmdlZDogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5mb2N1c2VkKSB7XG4gICAgICAgIHRoaXMuZW5zdXJlUmlwcGxlKCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEluIGFkZGl0aW9uIHRvIHRoZSBmdW5jdGlvbmFsaXR5IHByb3ZpZGVkIGluIGBJcm9uQnV0dG9uU3RhdGVgLCBlbnN1cmVzXG4gICAgICogYSByaXBwbGUgZWZmZWN0IGlzIGNyZWF0ZWQgd2hlbiB0aGUgZWxlbWVudCBpcyBpbiBhIGBwcmVzc2VkYCBzdGF0ZS5cbiAgICAgKi9cbiAgICBfZG93bkhhbmRsZXI6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICBQb2x5bWVyLklyb25CdXR0b25TdGF0ZUltcGwuX2Rvd25IYW5kbGVyLmNhbGwodGhpcywgZXZlbnQpO1xuICAgICAgaWYgKHRoaXMucHJlc3NlZCkge1xuICAgICAgICB0aGlzLmVuc3VyZVJpcHBsZShldmVudCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEVuc3VyZXMgdGhpcyBlbGVtZW50IGNvbnRhaW5zIGEgcmlwcGxlIGVmZmVjdC4gRm9yIHN0YXJ0dXAgZWZmaWNpZW5jeVxuICAgICAqIHRoZSByaXBwbGUgZWZmZWN0IGlzIGR5bmFtaWNhbGx5IG9uIGRlbWFuZCB3aGVuIG5lZWRlZC5cbiAgICAgKiBAcGFyYW0geyFFdmVudD19IG9wdFRyaWdnZXJpbmdFdmVudCAob3B0aW9uYWwpIGV2ZW50IHRoYXQgdHJpZ2dlcmVkIHRoZVxuICAgICAqIHJpcHBsZS5cbiAgICAgKi9cbiAgICBlbnN1cmVSaXBwbGU6IGZ1bmN0aW9uKG9wdFRyaWdnZXJpbmdFdmVudCkge1xuICAgICAgaWYgKCF0aGlzLmhhc1JpcHBsZSgpKSB7XG4gICAgICAgIHRoaXMuX3JpcHBsZSA9IHRoaXMuX2NyZWF0ZVJpcHBsZSgpO1xuICAgICAgICB0aGlzLl9yaXBwbGUubm9pbmsgPSB0aGlzLm5vaW5rO1xuICAgICAgICB2YXIgcmlwcGxlQ29udGFpbmVyID0gdGhpcy5fcmlwcGxlQ29udGFpbmVyIHx8IHRoaXMucm9vdDtcbiAgICAgICAgaWYgKHJpcHBsZUNvbnRhaW5lcikge1xuICAgICAgICAgIFBvbHltZXIuZG9tKHJpcHBsZUNvbnRhaW5lcikuYXBwZW5kQ2hpbGQodGhpcy5fcmlwcGxlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0VHJpZ2dlcmluZ0V2ZW50KSB7XG4gICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGV2ZW50IGhhcHBlbmVkIGluc2lkZSBvZiB0aGUgcmlwcGxlIGNvbnRhaW5lclxuICAgICAgICAgIC8vIEZhbGwgYmFjayB0byBob3N0IGluc3RlYWQgb2YgdGhlIHJvb3QgYmVjYXVzZSBkaXN0cmlidXRlZCB0ZXh0XG4gICAgICAgICAgLy8gbm9kZXMgYXJlIG5vdCB2YWxpZCBldmVudCB0YXJnZXRzXG4gICAgICAgICAgdmFyIGRvbUNvbnRhaW5lciA9IFBvbHltZXIuZG9tKHRoaXMuX3JpcHBsZUNvbnRhaW5lciB8fCB0aGlzKTtcbiAgICAgICAgICB2YXIgdGFyZ2V0ID0gUG9seW1lci5kb20ob3B0VHJpZ2dlcmluZ0V2ZW50KS5yb290VGFyZ2V0O1xuICAgICAgICAgIGlmIChkb21Db250YWluZXIuZGVlcENvbnRhaW5zKCAvKiogQHR5cGUge05vZGV9ICovKHRhcmdldCkpKSB7XG4gICAgICAgICAgICB0aGlzLl9yaXBwbGUudWlEb3duQWN0aW9uKG9wdFRyaWdnZXJpbmdFdmVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGA8cGFwZXItcmlwcGxlPmAgZWxlbWVudCB1c2VkIGJ5IHRoaXMgZWxlbWVudCB0byBjcmVhdGVcbiAgICAgKiByaXBwbGUgZWZmZWN0cy4gVGhlIGVsZW1lbnQncyByaXBwbGUgaXMgY3JlYXRlZCBvbiBkZW1hbmQsIHdoZW5cbiAgICAgKiBuZWNlc3NhcnksIGFuZCBjYWxsaW5nIHRoaXMgbWV0aG9kIHdpbGwgZm9yY2UgdGhlXG4gICAgICogcmlwcGxlIHRvIGJlIGNyZWF0ZWQuXG4gICAgICovXG4gICAgZ2V0UmlwcGxlOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZW5zdXJlUmlwcGxlKCk7XG4gICAgICByZXR1cm4gdGhpcy5fcmlwcGxlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBlbGVtZW50IGN1cnJlbnRseSBjb250YWlucyBhIHJpcHBsZSBlZmZlY3QuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBoYXNSaXBwbGU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIEJvb2xlYW4odGhpcy5fcmlwcGxlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHRoZSBlbGVtZW50J3MgcmlwcGxlIGVmZmVjdCB2aWEgY3JlYXRpbmcgYSBgPHBhcGVyLXJpcHBsZT5gLlxuICAgICAqIE92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIGN1c3RvbWl6ZSB0aGUgcmlwcGxlIGVsZW1lbnQuXG4gICAgICogQHJldHVybiB7IVBhcGVyUmlwcGxlRWxlbWVudH0gUmV0dXJucyBhIGA8cGFwZXItcmlwcGxlPmAgZWxlbWVudC5cbiAgICAgKi9cbiAgICBfY3JlYXRlUmlwcGxlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAvKiogQHR5cGUgeyFQYXBlclJpcHBsZUVsZW1lbnR9ICovIChcbiAgICAgICAgICBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwYXBlci1yaXBwbGUnKSk7XG4gICAgfSxcblxuICAgIF9ub2lua0NoYW5nZWQ6IGZ1bmN0aW9uKG5vaW5rKSB7XG4gICAgICBpZiAodGhpcy5oYXNSaXBwbGUoKSkge1xuICAgICAgICB0aGlzLl9yaXBwbGUubm9pbmsgPSBub2luaztcbiAgICAgIH1cbiAgICB9XG4gIH07XG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvcGFwZXItYmVoYXZpb3JzL3BhcGVyLXJpcHBsZS1iZWhhdmlvci5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNCBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuXG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vcG9seW1lci9wb2x5bWVyLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi9pcm9uLWExMXkta2V5cy1iZWhhdmlvci9pcm9uLWExMXkta2V5cy1iZWhhdmlvci5odG1sXCI+XG5cbjwhLS1cbk1hdGVyaWFsIGRlc2lnbjogW1N1cmZhY2UgcmVhY3Rpb25dKGh0dHBzOi8vd3d3Lmdvb2dsZS5jb20vZGVzaWduL3NwZWMvYW5pbWF0aW9uL3Jlc3BvbnNpdmUtaW50ZXJhY3Rpb24uaHRtbCNyZXNwb25zaXZlLWludGVyYWN0aW9uLXN1cmZhY2UtcmVhY3Rpb24pXG5cbmBwYXBlci1yaXBwbGVgIHByb3ZpZGVzIGEgdmlzdWFsIGVmZmVjdCB0aGF0IG90aGVyIHBhcGVyIGVsZW1lbnRzIGNhblxudXNlIHRvIHNpbXVsYXRlIGEgcmlwcGxpbmcgZWZmZWN0IGVtYW5hdGluZyBmcm9tIHRoZSBwb2ludCBvZiBjb250YWN0LiAgVGhlXG5lZmZlY3QgY2FuIGJlIHZpc3VhbGl6ZWQgYXMgYSBjb25jZW50cmljIGNpcmNsZSB3aXRoIG1vdGlvbi5cblxuRXhhbXBsZTpcblxuICAgIDxkaXYgc3R5bGU9XCJwb3NpdGlvbjpyZWxhdGl2ZVwiPlxuICAgICAgPHBhcGVyLXJpcHBsZT48L3BhcGVyLXJpcHBsZT5cbiAgICA8L2Rpdj5cblxuTm90ZSwgaXQncyBpbXBvcnRhbnQgdGhhdCB0aGUgcGFyZW50IGNvbnRhaW5lciBvZiB0aGUgcmlwcGxlIGJlIHJlbGF0aXZlIHBvc2l0aW9uLCBvdGhlcndpc2VcbnRoZSByaXBwbGUgd2lsbCBlbWFuYXRlIG91dHNpZGUgb2YgdGhlIGRlc2lyZWQgY29udGFpbmVyLlxuXG5gcGFwZXItcmlwcGxlYCBsaXN0ZW5zIHRvIFwibW91c2Vkb3duXCIgYW5kIFwibW91c2V1cFwiIGV2ZW50cyBzbyBpdCB3b3VsZCBkaXNwbGF5IHJpcHBsZVxuZWZmZWN0IHdoZW4gdG91Y2hlcyBvbiBpdC4gIFlvdSBjYW4gYWxzbyBkZWZlYXQgdGhlIGRlZmF1bHQgYmVoYXZpb3IgYW5kXG5tYW51YWxseSByb3V0ZSB0aGUgZG93biBhbmQgdXAgYWN0aW9ucyB0byB0aGUgcmlwcGxlIGVsZW1lbnQuICBOb3RlIHRoYXQgaXQgaXNcbmltcG9ydGFudCBpZiB5b3UgY2FsbCBgZG93bkFjdGlvbigpYCB5b3Ugd2lsbCBoYXZlIHRvIG1ha2Ugc3VyZSB0byBjYWxsXG5gdXBBY3Rpb24oKWAgc28gdGhhdCBgcGFwZXItcmlwcGxlYCB3b3VsZCBlbmQgdGhlIGFuaW1hdGlvbiBsb29wLlxuXG5FeGFtcGxlOlxuXG4gICAgPHBhcGVyLXJpcHBsZSBpZD1cInJpcHBsZVwiIHN0eWxlPVwicG9pbnRlci1ldmVudHM6IG5vbmU7XCI+PC9wYXBlci1yaXBwbGU+XG4gICAgLi4uXG4gICAgZG93bkFjdGlvbjogZnVuY3Rpb24oZSkge1xuICAgICAgdGhpcy4kLnJpcHBsZS5kb3duQWN0aW9uKGUuZGV0YWlsKTtcbiAgICB9LFxuICAgIHVwQWN0aW9uOiBmdW5jdGlvbihlKSB7XG4gICAgICB0aGlzLiQucmlwcGxlLnVwQWN0aW9uKCk7XG4gICAgfVxuXG5TdHlsaW5nIHJpcHBsZSBlZmZlY3Q6XG5cbiAgVXNlIENTUyBjb2xvciBwcm9wZXJ0eSB0byBzdHlsZSB0aGUgcmlwcGxlOlxuXG4gICAgcGFwZXItcmlwcGxlIHtcbiAgICAgIGNvbG9yOiAjNDI4NWY0O1xuICAgIH1cblxuICBOb3RlIHRoYXQgQ1NTIGNvbG9yIHByb3BlcnR5IGlzIGluaGVyaXRlZCBzbyBpdCBpcyBub3QgcmVxdWlyZWQgdG8gc2V0IGl0IG9uXG4gIHRoZSBgcGFwZXItcmlwcGxlYCBlbGVtZW50IGRpcmVjdGx5LlxuXG5CeSBkZWZhdWx0LCB0aGUgcmlwcGxlIGlzIGNlbnRlcmVkIG9uIHRoZSBwb2ludCBvZiBjb250YWN0LiAgQXBwbHkgdGhlIGByZWNlbnRlcnNgXG5hdHRyaWJ1dGUgdG8gaGF2ZSB0aGUgcmlwcGxlIGdyb3cgdG93YXJkIHRoZSBjZW50ZXIgb2YgaXRzIGNvbnRhaW5lci5cblxuICAgIDxwYXBlci1yaXBwbGUgcmVjZW50ZXJzPjwvcGFwZXItcmlwcGxlPlxuXG5Zb3UgY2FuIGFsc28gIGNlbnRlciB0aGUgcmlwcGxlIGluc2lkZSBpdHMgY29udGFpbmVyIGZyb20gdGhlIHN0YXJ0LlxuXG4gICAgPHBhcGVyLXJpcHBsZSBjZW50ZXI+PC9wYXBlci1yaXBwbGU+XG5cbkFwcGx5IGBjaXJjbGVgIGNsYXNzIHRvIG1ha2UgdGhlIHJpcHBsaW5nIGVmZmVjdCB3aXRoaW4gYSBjaXJjbGUuXG5cbiAgICA8cGFwZXItcmlwcGxlIGNsYXNzPVwiY2lyY2xlXCI+PC9wYXBlci1yaXBwbGU+XG5cbkBncm91cCBQYXBlciBFbGVtZW50c1xuQGVsZW1lbnQgcGFwZXItcmlwcGxlXG5AaGVybyBoZXJvLnN2Z1xuQGRlbW8gZGVtby9pbmRleC5odG1sXG4tLT5cblxuPGRvbS1tb2R1bGUgaWQ9XCJwYXBlci1yaXBwbGVcIj5cblxuICA8dGVtcGxhdGU+XG4gICAgPHN0eWxlPlxuICAgICAgOmhvc3Qge1xuICAgICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICBib3JkZXItcmFkaXVzOiBpbmhlcml0O1xuICAgICAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgICAgICB0b3A6IDA7XG4gICAgICAgIGxlZnQ6IDA7XG4gICAgICAgIHJpZ2h0OiAwO1xuICAgICAgICBib3R0b206IDA7XG5cbiAgICAgICAgLyogU2VlIFBvbHltZXJFbGVtZW50cy9wYXBlci1iZWhhdmlvcnMvaXNzdWVzLzM0LiBPbiBub24tQ2hyb21lIGJyb3dzZXJzLFxuICAgICAgICAgKiBjcmVhdGluZyBhIG5vZGUgKHdpdGggYSBwb3NpdGlvbjphYnNvbHV0ZSkgaW4gdGhlIG1pZGRsZSBvZiBhbiBldmVudFxuICAgICAgICAgKiBoYW5kbGVyIFwiaW50ZXJydXB0c1wiIHRoYXQgZXZlbnQgaGFuZGxlciAod2hpY2ggaGFwcGVucyB3aGVuIHRoZVxuICAgICAgICAgKiByaXBwbGUgaXMgY3JlYXRlZCBvbiBkZW1hbmQpICovXG4gICAgICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xuICAgICAgfVxuXG4gICAgICA6aG9zdChbYW5pbWF0aW5nXSkge1xuICAgICAgICAvKiBUaGlzIHJlc29sdmVzIGEgcmVuZGVyaW5nIGlzc3VlIGluIENocm9tZSAoYXMgb2YgNDApIHdoZXJlIHRoZVxuICAgICAgICAgICByaXBwbGUgaXMgbm90IHByb3Blcmx5IGNsaXBwZWQgYnkgaXRzIHBhcmVudCAod2hpY2ggbWF5IGhhdmVcbiAgICAgICAgICAgcm91bmRlZCBjb3JuZXJzKS4gU2VlOiBodHRwOi8vanNiaW4uY29tL3RlbWV4YS80XG5cbiAgICAgICAgICAgTm90ZTogV2Ugb25seSBhcHBseSB0aGlzIHN0eWxlIGNvbmRpdGlvbmFsbHkuIE90aGVyd2lzZSwgdGhlIGJyb3dzZXJcbiAgICAgICAgICAgd2lsbCBjcmVhdGUgYSBuZXcgY29tcG9zaXRpbmcgbGF5ZXIgZm9yIGV2ZXJ5IHJpcHBsZSBlbGVtZW50IG9uIHRoZVxuICAgICAgICAgICBwYWdlLCBhbmQgdGhhdCB3b3VsZCBiZSBiYWQuICovXG4gICAgICAgIC13ZWJraXQtdHJhbnNmb3JtOiB0cmFuc2xhdGUoMCwgMCk7XG4gICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoMCwgMCwgMCk7XG4gICAgICB9XG5cbiAgICAgICNiYWNrZ3JvdW5kLFxuICAgICAgI3dhdmVzLFxuICAgICAgLndhdmUtY29udGFpbmVyLFxuICAgICAgLndhdmUge1xuICAgICAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICB0b3A6IDA7XG4gICAgICAgIGxlZnQ6IDA7XG4gICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICBoZWlnaHQ6IDEwMCU7XG4gICAgICB9XG5cbiAgICAgICNiYWNrZ3JvdW5kLFxuICAgICAgLndhdmUge1xuICAgICAgICBvcGFjaXR5OiAwO1xuICAgICAgfVxuXG4gICAgICAjd2F2ZXMsXG4gICAgICAud2F2ZSB7XG4gICAgICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgICB9XG5cbiAgICAgIC53YXZlLWNvbnRhaW5lcixcbiAgICAgIC53YXZlIHtcbiAgICAgICAgYm9yZGVyLXJhZGl1czogNTAlO1xuICAgICAgfVxuXG4gICAgICA6aG9zdCguY2lyY2xlKSAjYmFja2dyb3VuZCxcbiAgICAgIDpob3N0KC5jaXJjbGUpICN3YXZlcyB7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDUwJTtcbiAgICAgIH1cblxuICAgICAgOmhvc3QoLmNpcmNsZSkgLndhdmUtY29udGFpbmVyIHtcbiAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICAgIH1cbiAgICA8L3N0eWxlPlxuXG4gICAgPGRpdiBpZD1cImJhY2tncm91bmRcIj48L2Rpdj5cbiAgICA8ZGl2IGlkPVwid2F2ZXNcIj48L2Rpdj5cbiAgPC90ZW1wbGF0ZT5cbjwvZG9tLW1vZHVsZT5cbjxzY3JpcHQ+XG4gIChmdW5jdGlvbigpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgVXRpbGl0eSA9IHtcbiAgICAgIGRpc3RhbmNlOiBmdW5jdGlvbih4MSwgeTEsIHgyLCB5Mikge1xuICAgICAgICB2YXIgeERlbHRhID0gKHgxIC0geDIpO1xuICAgICAgICB2YXIgeURlbHRhID0gKHkxIC0geTIpO1xuXG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQoeERlbHRhICogeERlbHRhICsgeURlbHRhICogeURlbHRhKTtcbiAgICAgIH0sXG5cbiAgICAgIG5vdzogd2luZG93LnBlcmZvcm1hbmNlICYmIHdpbmRvdy5wZXJmb3JtYW5jZS5ub3cgP1xuICAgICAgICAgIHdpbmRvdy5wZXJmb3JtYW5jZS5ub3cuYmluZCh3aW5kb3cucGVyZm9ybWFuY2UpIDogRGF0ZS5ub3dcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEVsZW1lbnRNZXRyaWNzKGVsZW1lbnQpIHtcbiAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICB0aGlzLndpZHRoID0gdGhpcy5ib3VuZGluZ1JlY3Qud2lkdGg7XG4gICAgICB0aGlzLmhlaWdodCA9IHRoaXMuYm91bmRpbmdSZWN0LmhlaWdodDtcblxuICAgICAgdGhpcy5zaXplID0gTWF0aC5tYXgodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgIH1cblxuICAgIEVsZW1lbnRNZXRyaWNzLnByb3RvdHlwZSA9IHtcbiAgICAgIGdldCBib3VuZGluZ1JlY3QgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgfSxcblxuICAgICAgZnVydGhlc3RDb3JuZXJEaXN0YW5jZUZyb206IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgdmFyIHRvcExlZnQgPSBVdGlsaXR5LmRpc3RhbmNlKHgsIHksIDAsIDApO1xuICAgICAgICB2YXIgdG9wUmlnaHQgPSBVdGlsaXR5LmRpc3RhbmNlKHgsIHksIHRoaXMud2lkdGgsIDApO1xuICAgICAgICB2YXIgYm90dG9tTGVmdCA9IFV0aWxpdHkuZGlzdGFuY2UoeCwgeSwgMCwgdGhpcy5oZWlnaHQpO1xuICAgICAgICB2YXIgYm90dG9tUmlnaHQgPSBVdGlsaXR5LmRpc3RhbmNlKHgsIHksIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcblxuICAgICAgICByZXR1cm4gTWF0aC5tYXgodG9wTGVmdCwgdG9wUmlnaHQsIGJvdHRvbUxlZnQsIGJvdHRvbVJpZ2h0KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFJpcHBsZShlbGVtZW50KSB7XG4gICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgdGhpcy5jb2xvciA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLmNvbG9yO1xuXG4gICAgICB0aGlzLndhdmUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHRoaXMud2F2ZUNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgdGhpcy53YXZlLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IHRoaXMuY29sb3I7XG4gICAgICB0aGlzLndhdmUuY2xhc3NMaXN0LmFkZCgnd2F2ZScpO1xuICAgICAgdGhpcy53YXZlQ29udGFpbmVyLmNsYXNzTGlzdC5hZGQoJ3dhdmUtY29udGFpbmVyJyk7XG4gICAgICBQb2x5bWVyLmRvbSh0aGlzLndhdmVDb250YWluZXIpLmFwcGVuZENoaWxkKHRoaXMud2F2ZSk7XG5cbiAgICAgIHRoaXMucmVzZXRJbnRlcmFjdGlvblN0YXRlKCk7XG4gICAgfVxuXG4gICAgUmlwcGxlLk1BWF9SQURJVVMgPSAzMDA7XG5cbiAgICBSaXBwbGUucHJvdG90eXBlID0ge1xuICAgICAgZ2V0IHJlY2VudGVycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudC5yZWNlbnRlcnM7XG4gICAgICB9LFxuXG4gICAgICBnZXQgY2VudGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50LmNlbnRlcjtcbiAgICAgIH0sXG5cbiAgICAgIGdldCBtb3VzZURvd25FbGFwc2VkKCkge1xuICAgICAgICB2YXIgZWxhcHNlZDtcblxuICAgICAgICBpZiAoIXRoaXMubW91c2VEb3duU3RhcnQpIHtcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsYXBzZWQgPSBVdGlsaXR5Lm5vdygpIC0gdGhpcy5tb3VzZURvd25TdGFydDtcblxuICAgICAgICBpZiAodGhpcy5tb3VzZVVwU3RhcnQpIHtcbiAgICAgICAgICBlbGFwc2VkIC09IHRoaXMubW91c2VVcEVsYXBzZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZWxhcHNlZDtcbiAgICAgIH0sXG5cbiAgICAgIGdldCBtb3VzZVVwRWxhcHNlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW91c2VVcFN0YXJ0ID9cbiAgICAgICAgICBVdGlsaXR5Lm5vdyAoKSAtIHRoaXMubW91c2VVcFN0YXJ0IDogMDtcbiAgICAgIH0sXG5cbiAgICAgIGdldCBtb3VzZURvd25FbGFwc2VkU2Vjb25kcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW91c2VEb3duRWxhcHNlZCAvIDEwMDA7XG4gICAgICB9LFxuXG4gICAgICBnZXQgbW91c2VVcEVsYXBzZWRTZWNvbmRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb3VzZVVwRWxhcHNlZCAvIDEwMDA7XG4gICAgICB9LFxuXG4gICAgICBnZXQgbW91c2VJbnRlcmFjdGlvblNlY29uZHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vdXNlRG93bkVsYXBzZWRTZWNvbmRzICsgdGhpcy5tb3VzZVVwRWxhcHNlZFNlY29uZHM7XG4gICAgICB9LFxuXG4gICAgICBnZXQgaW5pdGlhbE9wYWNpdHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnQuaW5pdGlhbE9wYWNpdHk7XG4gICAgICB9LFxuXG4gICAgICBnZXQgb3BhY2l0eURlY2F5VmVsb2NpdHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnQub3BhY2l0eURlY2F5VmVsb2NpdHk7XG4gICAgICB9LFxuXG4gICAgICBnZXQgcmFkaXVzKCkge1xuICAgICAgICB2YXIgd2lkdGgyID0gdGhpcy5jb250YWluZXJNZXRyaWNzLndpZHRoICogdGhpcy5jb250YWluZXJNZXRyaWNzLndpZHRoO1xuICAgICAgICB2YXIgaGVpZ2h0MiA9IHRoaXMuY29udGFpbmVyTWV0cmljcy5oZWlnaHQgKiB0aGlzLmNvbnRhaW5lck1ldHJpY3MuaGVpZ2h0O1xuICAgICAgICB2YXIgd2F2ZVJhZGl1cyA9IE1hdGgubWluKFxuICAgICAgICAgIE1hdGguc3FydCh3aWR0aDIgKyBoZWlnaHQyKSxcbiAgICAgICAgICBSaXBwbGUuTUFYX1JBRElVU1xuICAgICAgICApICogMS4xICsgNTtcblxuICAgICAgICB2YXIgZHVyYXRpb24gPSAxLjEgLSAwLjIgKiAod2F2ZVJhZGl1cyAvIFJpcHBsZS5NQVhfUkFESVVTKTtcbiAgICAgICAgdmFyIHRpbWVOb3cgPSB0aGlzLm1vdXNlSW50ZXJhY3Rpb25TZWNvbmRzIC8gZHVyYXRpb247XG4gICAgICAgIHZhciBzaXplID0gd2F2ZVJhZGl1cyAqICgxIC0gTWF0aC5wb3coODAsIC10aW1lTm93KSk7XG5cbiAgICAgICAgcmV0dXJuIE1hdGguYWJzKHNpemUpO1xuICAgICAgfSxcblxuICAgICAgZ2V0IG9wYWNpdHkoKSB7XG4gICAgICAgIGlmICghdGhpcy5tb3VzZVVwU3RhcnQpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5pbml0aWFsT3BhY2l0eTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBNYXRoLm1heChcbiAgICAgICAgICAwLFxuICAgICAgICAgIHRoaXMuaW5pdGlhbE9wYWNpdHkgLSB0aGlzLm1vdXNlVXBFbGFwc2VkU2Vjb25kcyAqIHRoaXMub3BhY2l0eURlY2F5VmVsb2NpdHlcbiAgICAgICAgKTtcbiAgICAgIH0sXG5cbiAgICAgIGdldCBvdXRlck9wYWNpdHkoKSB7XG4gICAgICAgIC8vIExpbmVhciBpbmNyZWFzZSBpbiBiYWNrZ3JvdW5kIG9wYWNpdHksIGNhcHBlZCBhdCB0aGUgb3BhY2l0eVxuICAgICAgICAvLyBvZiB0aGUgd2F2ZWZyb250ICh3YXZlT3BhY2l0eSkuXG4gICAgICAgIHZhciBvdXRlck9wYWNpdHkgPSB0aGlzLm1vdXNlVXBFbGFwc2VkU2Vjb25kcyAqIDAuMztcbiAgICAgICAgdmFyIHdhdmVPcGFjaXR5ID0gdGhpcy5vcGFjaXR5O1xuXG4gICAgICAgIHJldHVybiBNYXRoLm1heChcbiAgICAgICAgICAwLFxuICAgICAgICAgIE1hdGgubWluKG91dGVyT3BhY2l0eSwgd2F2ZU9wYWNpdHkpXG4gICAgICAgICk7XG4gICAgICB9LFxuXG4gICAgICBnZXQgaXNPcGFjaXR5RnVsbHlEZWNheWVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcGFjaXR5IDwgMC4wMSAmJlxuICAgICAgICAgIHRoaXMucmFkaXVzID49IE1hdGgubWluKHRoaXMubWF4UmFkaXVzLCBSaXBwbGUuTUFYX1JBRElVUyk7XG4gICAgICB9LFxuXG4gICAgICBnZXQgaXNSZXN0aW5nQXRNYXhSYWRpdXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wYWNpdHkgPj0gdGhpcy5pbml0aWFsT3BhY2l0eSAmJlxuICAgICAgICAgIHRoaXMucmFkaXVzID49IE1hdGgubWluKHRoaXMubWF4UmFkaXVzLCBSaXBwbGUuTUFYX1JBRElVUyk7XG4gICAgICB9LFxuXG4gICAgICBnZXQgaXNBbmltYXRpb25Db21wbGV0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW91c2VVcFN0YXJ0ID9cbiAgICAgICAgICB0aGlzLmlzT3BhY2l0eUZ1bGx5RGVjYXllZCA6IHRoaXMuaXNSZXN0aW5nQXRNYXhSYWRpdXM7XG4gICAgICB9LFxuXG4gICAgICBnZXQgdHJhbnNsYXRpb25GcmFjdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubWluKFxuICAgICAgICAgIDEsXG4gICAgICAgICAgdGhpcy5yYWRpdXMgLyB0aGlzLmNvbnRhaW5lck1ldHJpY3Muc2l6ZSAqIDIgLyBNYXRoLnNxcnQoMilcbiAgICAgICAgKTtcbiAgICAgIH0sXG5cbiAgICAgIGdldCB4Tm93KCkge1xuICAgICAgICBpZiAodGhpcy54RW5kKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMueFN0YXJ0ICsgdGhpcy50cmFuc2xhdGlvbkZyYWN0aW9uICogKHRoaXMueEVuZCAtIHRoaXMueFN0YXJ0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLnhTdGFydDtcbiAgICAgIH0sXG5cbiAgICAgIGdldCB5Tm93KCkge1xuICAgICAgICBpZiAodGhpcy55RW5kKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMueVN0YXJ0ICsgdGhpcy50cmFuc2xhdGlvbkZyYWN0aW9uICogKHRoaXMueUVuZCAtIHRoaXMueVN0YXJ0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLnlTdGFydDtcbiAgICAgIH0sXG5cbiAgICAgIGdldCBpc01vdXNlRG93bigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW91c2VEb3duU3RhcnQgJiYgIXRoaXMubW91c2VVcFN0YXJ0O1xuICAgICAgfSxcblxuICAgICAgcmVzZXRJbnRlcmFjdGlvblN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5tYXhSYWRpdXMgPSAwO1xuICAgICAgICB0aGlzLm1vdXNlRG93blN0YXJ0ID0gMDtcbiAgICAgICAgdGhpcy5tb3VzZVVwU3RhcnQgPSAwO1xuXG4gICAgICAgIHRoaXMueFN0YXJ0ID0gMDtcbiAgICAgICAgdGhpcy55U3RhcnQgPSAwO1xuICAgICAgICB0aGlzLnhFbmQgPSAwO1xuICAgICAgICB0aGlzLnlFbmQgPSAwO1xuICAgICAgICB0aGlzLnNsaWRlRGlzdGFuY2UgPSAwO1xuXG4gICAgICAgIHRoaXMuY29udGFpbmVyTWV0cmljcyA9IG5ldyBFbGVtZW50TWV0cmljcyh0aGlzLmVsZW1lbnQpO1xuICAgICAgfSxcblxuICAgICAgZHJhdzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzY2FsZTtcbiAgICAgICAgdmFyIHRyYW5zbGF0ZVN0cmluZztcbiAgICAgICAgdmFyIGR4O1xuICAgICAgICB2YXIgZHk7XG5cbiAgICAgICAgdGhpcy53YXZlLnN0eWxlLm9wYWNpdHkgPSB0aGlzLm9wYWNpdHk7XG5cbiAgICAgICAgc2NhbGUgPSB0aGlzLnJhZGl1cyAvICh0aGlzLmNvbnRhaW5lck1ldHJpY3Muc2l6ZSAvIDIpO1xuICAgICAgICBkeCA9IHRoaXMueE5vdyAtICh0aGlzLmNvbnRhaW5lck1ldHJpY3Mud2lkdGggLyAyKTtcbiAgICAgICAgZHkgPSB0aGlzLnlOb3cgLSAodGhpcy5jb250YWluZXJNZXRyaWNzLmhlaWdodCAvIDIpO1xuXG5cbiAgICAgICAgLy8gMmQgdHJhbnNmb3JtIGZvciBzYWZhcmkgYmVjYXVzZSBvZiBib3JkZXItcmFkaXVzIGFuZCBvdmVyZmxvdzpoaWRkZW4gY2xpcHBpbmcgYnVnLlxuICAgICAgICAvLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9OTg1MzhcbiAgICAgICAgdGhpcy53YXZlQ29udGFpbmVyLnN0eWxlLndlYmtpdFRyYW5zZm9ybSA9ICd0cmFuc2xhdGUoJyArIGR4ICsgJ3B4LCAnICsgZHkgKyAncHgpJztcbiAgICAgICAgdGhpcy53YXZlQ29udGFpbmVyLnN0eWxlLnRyYW5zZm9ybSA9ICd0cmFuc2xhdGUzZCgnICsgZHggKyAncHgsICcgKyBkeSArICdweCwgMCknO1xuICAgICAgICB0aGlzLndhdmUuc3R5bGUud2Via2l0VHJhbnNmb3JtID0gJ3NjYWxlKCcgKyBzY2FsZSArICcsJyArIHNjYWxlICsgJyknO1xuICAgICAgICB0aGlzLndhdmUuc3R5bGUudHJhbnNmb3JtID0gJ3NjYWxlM2QoJyArIHNjYWxlICsgJywnICsgc2NhbGUgKyAnLDEpJztcbiAgICAgIH0sXG5cbiAgICAgIC8qKiBAcGFyYW0ge0V2ZW50PX0gZXZlbnQgKi9cbiAgICAgIGRvd25BY3Rpb246IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIHZhciB4Q2VudGVyID0gdGhpcy5jb250YWluZXJNZXRyaWNzLndpZHRoIC8gMjtcbiAgICAgICAgdmFyIHlDZW50ZXIgPSB0aGlzLmNvbnRhaW5lck1ldHJpY3MuaGVpZ2h0IC8gMjtcblxuICAgICAgICB0aGlzLnJlc2V0SW50ZXJhY3Rpb25TdGF0ZSgpO1xuICAgICAgICB0aGlzLm1vdXNlRG93blN0YXJ0ID0gVXRpbGl0eS5ub3coKTtcblxuICAgICAgICBpZiAodGhpcy5jZW50ZXIpIHtcbiAgICAgICAgICB0aGlzLnhTdGFydCA9IHhDZW50ZXI7XG4gICAgICAgICAgdGhpcy55U3RhcnQgPSB5Q2VudGVyO1xuICAgICAgICAgIHRoaXMuc2xpZGVEaXN0YW5jZSA9IFV0aWxpdHkuZGlzdGFuY2UoXG4gICAgICAgICAgICB0aGlzLnhTdGFydCwgdGhpcy55U3RhcnQsIHRoaXMueEVuZCwgdGhpcy55RW5kXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnhTdGFydCA9IGV2ZW50ID9cbiAgICAgICAgICAgICAgZXZlbnQuZGV0YWlsLnggLSB0aGlzLmNvbnRhaW5lck1ldHJpY3MuYm91bmRpbmdSZWN0LmxlZnQgOlxuICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lck1ldHJpY3Mud2lkdGggLyAyO1xuICAgICAgICAgIHRoaXMueVN0YXJ0ID0gZXZlbnQgP1xuICAgICAgICAgICAgICBldmVudC5kZXRhaWwueSAtIHRoaXMuY29udGFpbmVyTWV0cmljcy5ib3VuZGluZ1JlY3QudG9wIDpcbiAgICAgICAgICAgICAgdGhpcy5jb250YWluZXJNZXRyaWNzLmhlaWdodCAvIDI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5yZWNlbnRlcnMpIHtcbiAgICAgICAgICB0aGlzLnhFbmQgPSB4Q2VudGVyO1xuICAgICAgICAgIHRoaXMueUVuZCA9IHlDZW50ZXI7XG4gICAgICAgICAgdGhpcy5zbGlkZURpc3RhbmNlID0gVXRpbGl0eS5kaXN0YW5jZShcbiAgICAgICAgICAgIHRoaXMueFN0YXJ0LCB0aGlzLnlTdGFydCwgdGhpcy54RW5kLCB0aGlzLnlFbmRcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5tYXhSYWRpdXMgPSB0aGlzLmNvbnRhaW5lck1ldHJpY3MuZnVydGhlc3RDb3JuZXJEaXN0YW5jZUZyb20oXG4gICAgICAgICAgdGhpcy54U3RhcnQsXG4gICAgICAgICAgdGhpcy55U3RhcnRcbiAgICAgICAgKTtcblxuICAgICAgICB0aGlzLndhdmVDb250YWluZXIuc3R5bGUudG9wID1cbiAgICAgICAgICAodGhpcy5jb250YWluZXJNZXRyaWNzLmhlaWdodCAtIHRoaXMuY29udGFpbmVyTWV0cmljcy5zaXplKSAvIDIgKyAncHgnO1xuICAgICAgICB0aGlzLndhdmVDb250YWluZXIuc3R5bGUubGVmdCA9XG4gICAgICAgICAgKHRoaXMuY29udGFpbmVyTWV0cmljcy53aWR0aCAtIHRoaXMuY29udGFpbmVyTWV0cmljcy5zaXplKSAvIDIgKyAncHgnO1xuXG4gICAgICAgIHRoaXMud2F2ZUNvbnRhaW5lci5zdHlsZS53aWR0aCA9IHRoaXMuY29udGFpbmVyTWV0cmljcy5zaXplICsgJ3B4JztcbiAgICAgICAgdGhpcy53YXZlQ29udGFpbmVyLnN0eWxlLmhlaWdodCA9IHRoaXMuY29udGFpbmVyTWV0cmljcy5zaXplICsgJ3B4JztcbiAgICAgIH0sXG5cbiAgICAgIC8qKiBAcGFyYW0ge0V2ZW50PX0gZXZlbnQgKi9cbiAgICAgIHVwQWN0aW9uOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNNb3VzZURvd24pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm1vdXNlVXBTdGFydCA9IFV0aWxpdHkubm93KCk7XG4gICAgICB9LFxuXG4gICAgICByZW1vdmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBQb2x5bWVyLmRvbSh0aGlzLndhdmVDb250YWluZXIucGFyZW50Tm9kZSkucmVtb3ZlQ2hpbGQoXG4gICAgICAgICAgdGhpcy53YXZlQ29udGFpbmVyXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIFBvbHltZXIoe1xuICAgICAgaXM6ICdwYXBlci1yaXBwbGUnLFxuXG4gICAgICBiZWhhdmlvcnM6IFtcbiAgICAgICAgUG9seW1lci5Jcm9uQTExeUtleXNCZWhhdmlvclxuICAgICAgXSxcblxuICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGluaXRpYWwgb3BhY2l0eSBzZXQgb24gdGhlIHdhdmUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBhdHRyaWJ1dGUgaW5pdGlhbE9wYWNpdHlcbiAgICAgICAgICogQHR5cGUgbnVtYmVyXG4gICAgICAgICAqIEBkZWZhdWx0IDAuMjVcbiAgICAgICAgICovXG4gICAgICAgIGluaXRpYWxPcGFjaXR5OiB7XG4gICAgICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgICAgIHZhbHVlOiAwLjI1XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEhvdyBmYXN0IChvcGFjaXR5IHBlciBzZWNvbmQpIHRoZSB3YXZlIGZhZGVzIG91dC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGF0dHJpYnV0ZSBvcGFjaXR5RGVjYXlWZWxvY2l0eVxuICAgICAgICAgKiBAdHlwZSBudW1iZXJcbiAgICAgICAgICogQGRlZmF1bHQgMC44XG4gICAgICAgICAqL1xuICAgICAgICBvcGFjaXR5RGVjYXlWZWxvY2l0eToge1xuICAgICAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgICAgICB2YWx1ZTogMC44XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHRydWUsIHJpcHBsZXMgd2lsbCBleGhpYml0IGEgZ3Jhdml0YXRpb25hbCBwdWxsIHRvd2FyZHNcbiAgICAgICAgICogdGhlIGNlbnRlciBvZiB0aGVpciBjb250YWluZXIgYXMgdGhleSBmYWRlIGF3YXkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBhdHRyaWJ1dGUgcmVjZW50ZXJzXG4gICAgICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIHJlY2VudGVyczoge1xuICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHRydWUsIHJpcHBsZXMgd2lsbCBjZW50ZXIgaW5zaWRlIGl0cyBjb250YWluZXJcbiAgICAgICAgICpcbiAgICAgICAgICogQGF0dHJpYnV0ZSByZWNlbnRlcnNcbiAgICAgICAgICogQHR5cGUgYm9vbGVhblxuICAgICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgY2VudGVyOiB7XG4gICAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQSBsaXN0IG9mIHRoZSB2aXN1YWwgcmlwcGxlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQGF0dHJpYnV0ZSByaXBwbGVzXG4gICAgICAgICAqIEB0eXBlIEFycmF5XG4gICAgICAgICAqIEBkZWZhdWx0IFtdXG4gICAgICAgICAqL1xuICAgICAgICByaXBwbGVzOiB7XG4gICAgICAgICAgdHlwZTogQXJyYXksXG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVHJ1ZSB3aGVuIHRoZXJlIGFyZSB2aXNpYmxlIHJpcHBsZXMgYW5pbWF0aW5nIHdpdGhpbiB0aGVcbiAgICAgICAgICogZWxlbWVudC5cbiAgICAgICAgICovXG4gICAgICAgIGFuaW1hdGluZzoge1xuICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgICAgcmVhZE9ubHk6IHRydWUsXG4gICAgICAgICAgcmVmbGVjdFRvQXR0cmlidXRlOiB0cnVlLFxuICAgICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0cnVlLCB0aGUgcmlwcGxlIHdpbGwgcmVtYWluIGluIHRoZSBcImRvd25cIiBzdGF0ZSB1bnRpbCBgaG9sZERvd25gXG4gICAgICAgICAqIGlzIHNldCB0byBmYWxzZSBhZ2Fpbi5cbiAgICAgICAgICovXG4gICAgICAgIGhvbGREb3duOiB7XG4gICAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgICB2YWx1ZTogZmFsc2UsXG4gICAgICAgICAgb2JzZXJ2ZXI6ICdfaG9sZERvd25DaGFuZ2VkJ1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0cnVlLCB0aGUgcmlwcGxlIHdpbGwgbm90IGdlbmVyYXRlIGEgcmlwcGxlIGVmZmVjdFxuICAgICAgICAgKiB2aWEgcG9pbnRlciBpbnRlcmFjdGlvbi5cbiAgICAgICAgICogQ2FsbGluZyByaXBwbGUncyBpbXBlcmF0aXZlIGFwaSBsaWtlIGBzaW11bGF0ZWRSaXBwbGVgIHdpbGxcbiAgICAgICAgICogc3RpbGwgZ2VuZXJhdGUgdGhlIHJpcHBsZSBlZmZlY3QuXG4gICAgICAgICAqL1xuICAgICAgICBub2luazoge1xuICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgIH0sXG5cbiAgICAgICAgX2FuaW1hdGluZzoge1xuICAgICAgICAgIHR5cGU6IEJvb2xlYW5cbiAgICAgICAgfSxcblxuICAgICAgICBfYm91bmRBbmltYXRlOiB7XG4gICAgICAgICAgdHlwZTogRnVuY3Rpb24sXG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYW5pbWF0ZS5iaW5kKHRoaXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgZ2V0IHRhcmdldCAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmtleUV2ZW50VGFyZ2V0O1xuICAgICAgfSxcblxuICAgICAga2V5QmluZGluZ3M6IHtcbiAgICAgICAgJ2VudGVyOmtleWRvd24nOiAnX29uRW50ZXJLZXlkb3duJyxcbiAgICAgICAgJ3NwYWNlOmtleWRvd24nOiAnX29uU3BhY2VLZXlkb3duJyxcbiAgICAgICAgJ3NwYWNlOmtleXVwJzogJ19vblNwYWNlS2V5dXAnXG4gICAgICB9LFxuXG4gICAgICBhdHRhY2hlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIFNldCB1cCBhMTF5S2V5c0JlaGF2aW9yIHRvIGxpc3RlbiB0byBrZXkgZXZlbnRzIG9uIHRoZSB0YXJnZXQsXG4gICAgICAgIC8vIHNvIHRoYXQgc3BhY2UgYW5kIGVudGVyIGFjdGl2YXRlIHRoZSByaXBwbGUgZXZlbiBpZiB0aGUgdGFyZ2V0IGRvZXNuJ3RcbiAgICAgICAgLy8gaGFuZGxlIGtleSBldmVudHMuIFRoZSBrZXkgaGFuZGxlcnMgZGVhbCB3aXRoIGBub2lua2AgdGhlbXNlbHZlcy5cbiAgICAgICAgaWYgKHRoaXMucGFyZW50Tm9kZS5ub2RlVHlwZSA9PSAxMSkgeyAvLyBET0NVTUVOVF9GUkFHTUVOVF9OT0RFXG4gICAgICAgICAgdGhpcy5rZXlFdmVudFRhcmdldCA9IFBvbHltZXIuZG9tKHRoaXMpLmdldE93bmVyUm9vdCgpLmhvc3Q7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5rZXlFdmVudFRhcmdldCA9IHRoaXMucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIga2V5RXZlbnRUYXJnZXQgPSAvKiogQHR5cGUgeyFFdmVudFRhcmdldH0gKi8gKHRoaXMua2V5RXZlbnRUYXJnZXQpO1xuICAgICAgICB0aGlzLmxpc3RlbihrZXlFdmVudFRhcmdldCwgJ3VwJywgJ3VpVXBBY3Rpb24nKTtcbiAgICAgICAgdGhpcy5saXN0ZW4oa2V5RXZlbnRUYXJnZXQsICdkb3duJywgJ3VpRG93bkFjdGlvbicpO1xuICAgICAgfSxcblxuICAgICAgZGV0YWNoZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnVubGlzdGVuKHRoaXMua2V5RXZlbnRUYXJnZXQsICd1cCcsICd1aVVwQWN0aW9uJyk7XG4gICAgICAgIHRoaXMudW5saXN0ZW4odGhpcy5rZXlFdmVudFRhcmdldCwgJ2Rvd24nLCAndWlEb3duQWN0aW9uJyk7XG4gICAgICAgIHRoaXMua2V5RXZlbnRUYXJnZXQgPSBudWxsO1xuICAgICAgfSxcblxuICAgICAgZ2V0IHNob3VsZEtlZXBBbmltYXRpbmcgKCkge1xuICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5yaXBwbGVzLmxlbmd0aDsgKytpbmRleCkge1xuICAgICAgICAgIGlmICghdGhpcy5yaXBwbGVzW2luZGV4XS5pc0FuaW1hdGlvbkNvbXBsZXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9LFxuXG4gICAgICBzaW11bGF0ZWRSaXBwbGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmRvd25BY3Rpb24obnVsbCk7XG5cbiAgICAgICAgLy8gUGxlYXNlIHNlZSBwb2x5bWVyL3BvbHltZXIjMTMwNVxuICAgICAgICB0aGlzLmFzeW5jKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHRoaXMudXBBY3Rpb24oKTtcbiAgICAgICAgfSwgMSk7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFByb3Zva2VzIGEgcmlwcGxlIGRvd24gZWZmZWN0IHZpYSBhIFVJIGV2ZW50LFxuICAgICAgICogcmVzcGVjdGluZyB0aGUgYG5vaW5rYCBwcm9wZXJ0eS5cbiAgICAgICAqIEBwYXJhbSB7RXZlbnQ9fSBldmVudFxuICAgICAgICovXG4gICAgICB1aURvd25BY3Rpb246IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIGlmICghdGhpcy5ub2luaykge1xuICAgICAgICAgIHRoaXMuZG93bkFjdGlvbihldmVudCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogUHJvdm9rZXMgYSByaXBwbGUgZG93biBlZmZlY3QgdmlhIGEgVUkgZXZlbnQsXG4gICAgICAgKiAqbm90KiByZXNwZWN0aW5nIHRoZSBgbm9pbmtgIHByb3BlcnR5LlxuICAgICAgICogQHBhcmFtIHtFdmVudD19IGV2ZW50XG4gICAgICAgKi9cbiAgICAgIGRvd25BY3Rpb246IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmhvbGREb3duICYmIHRoaXMucmlwcGxlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJpcHBsZSA9IHRoaXMuYWRkUmlwcGxlKCk7XG5cbiAgICAgICAgcmlwcGxlLmRvd25BY3Rpb24oZXZlbnQpO1xuXG4gICAgICAgIGlmICghdGhpcy5fYW5pbWF0aW5nKSB7XG4gICAgICAgICAgdGhpcy5fYW5pbWF0aW5nID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLmFuaW1hdGUoKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBQcm92b2tlcyBhIHJpcHBsZSB1cCBlZmZlY3QgdmlhIGEgVUkgZXZlbnQsXG4gICAgICAgKiByZXNwZWN0aW5nIHRoZSBgbm9pbmtgIHByb3BlcnR5LlxuICAgICAgICogQHBhcmFtIHtFdmVudD19IGV2ZW50XG4gICAgICAgKi9cbiAgICAgIHVpVXBBY3Rpb246IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIGlmICghdGhpcy5ub2luaykge1xuICAgICAgICAgIHRoaXMudXBBY3Rpb24oZXZlbnQpO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFByb3Zva2VzIGEgcmlwcGxlIHVwIGVmZmVjdCB2aWEgYSBVSSBldmVudCxcbiAgICAgICAqICpub3QqIHJlc3BlY3RpbmcgdGhlIGBub2lua2AgcHJvcGVydHkuXG4gICAgICAgKiBAcGFyYW0ge0V2ZW50PX0gZXZlbnRcbiAgICAgICAqL1xuICAgICAgdXBBY3Rpb246IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmhvbGREb3duKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5yaXBwbGVzLmZvckVhY2goZnVuY3Rpb24ocmlwcGxlKSB7XG4gICAgICAgICAgcmlwcGxlLnVwQWN0aW9uKGV2ZW50KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5fYW5pbWF0aW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5hbmltYXRlKCk7XG4gICAgICB9LFxuXG4gICAgICBvbkFuaW1hdGlvbkNvbXBsZXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fYW5pbWF0aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuJC5iYWNrZ3JvdW5kLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IG51bGw7XG4gICAgICAgIHRoaXMuZmlyZSgndHJhbnNpdGlvbmVuZCcpO1xuICAgICAgfSxcblxuICAgICAgYWRkUmlwcGxlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJpcHBsZSA9IG5ldyBSaXBwbGUodGhpcyk7XG5cbiAgICAgICAgUG9seW1lci5kb20odGhpcy4kLndhdmVzKS5hcHBlbmRDaGlsZChyaXBwbGUud2F2ZUNvbnRhaW5lcik7XG4gICAgICAgIHRoaXMuJC5iYWNrZ3JvdW5kLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IHJpcHBsZS5jb2xvcjtcbiAgICAgICAgdGhpcy5yaXBwbGVzLnB1c2gocmlwcGxlKTtcblxuICAgICAgICB0aGlzLl9zZXRBbmltYXRpbmcodHJ1ZSk7XG5cbiAgICAgICAgcmV0dXJuIHJpcHBsZTtcbiAgICAgIH0sXG5cbiAgICAgIHJlbW92ZVJpcHBsZTogZnVuY3Rpb24ocmlwcGxlKSB7XG4gICAgICAgIHZhciByaXBwbGVJbmRleCA9IHRoaXMucmlwcGxlcy5pbmRleE9mKHJpcHBsZSk7XG5cbiAgICAgICAgaWYgKHJpcHBsZUluZGV4IDwgMCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucmlwcGxlcy5zcGxpY2UocmlwcGxlSW5kZXgsIDEpO1xuXG4gICAgICAgIHJpcHBsZS5yZW1vdmUoKTtcblxuICAgICAgICBpZiAoIXRoaXMucmlwcGxlcy5sZW5ndGgpIHtcbiAgICAgICAgICB0aGlzLl9zZXRBbmltYXRpbmcoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFRoaXMgY29uZmxpY3RzIHdpdGggRWxlbWVudCNhbnRpbWF0ZSgpLlxuICAgICAgICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0VsZW1lbnQvYW5pbWF0ZVxuICAgICAgICogQHN1cHByZXNzIHtjaGVja1R5cGVzfVxuICAgICAgICovXG4gICAgICBhbmltYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9hbmltYXRpbmcpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGluZGV4O1xuICAgICAgICB2YXIgcmlwcGxlO1xuXG4gICAgICAgIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IHRoaXMucmlwcGxlcy5sZW5ndGg7ICsraW5kZXgpIHtcbiAgICAgICAgICByaXBwbGUgPSB0aGlzLnJpcHBsZXNbaW5kZXhdO1xuXG4gICAgICAgICAgcmlwcGxlLmRyYXcoKTtcblxuICAgICAgICAgIHRoaXMuJC5iYWNrZ3JvdW5kLnN0eWxlLm9wYWNpdHkgPSByaXBwbGUub3V0ZXJPcGFjaXR5O1xuXG4gICAgICAgICAgaWYgKHJpcHBsZS5pc09wYWNpdHlGdWxseURlY2F5ZWQgJiYgIXJpcHBsZS5pc1Jlc3RpbmdBdE1heFJhZGl1cykge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVSaXBwbGUocmlwcGxlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuc2hvdWxkS2VlcEFuaW1hdGluZyAmJiB0aGlzLnJpcHBsZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5vbkFuaW1hdGlvbkNvbXBsZXRlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLl9ib3VuZEFuaW1hdGUpO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBfb25FbnRlcktleWRvd246IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnVpRG93bkFjdGlvbigpO1xuICAgICAgICB0aGlzLmFzeW5jKHRoaXMudWlVcEFjdGlvbiwgMSk7XG4gICAgICB9LFxuXG4gICAgICBfb25TcGFjZUtleWRvd246IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnVpRG93bkFjdGlvbigpO1xuICAgICAgfSxcblxuICAgICAgX29uU3BhY2VLZXl1cDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMudWlVcEFjdGlvbigpO1xuICAgICAgfSxcblxuICAgICAgLy8gbm90ZTogaG9sZERvd24gZG9lcyBub3QgcmVzcGVjdCBub2luayBzaW5jZSBpdCBjYW4gYmUgYSBmb2N1cyBiYXNlZFxuICAgICAgLy8gZWZmZWN0LlxuICAgICAgX2hvbGREb3duQ2hhbmdlZDogZnVuY3Rpb24obmV3VmFsLCBvbGRWYWwpIHtcbiAgICAgICAgaWYgKG9sZFZhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXdWYWwpIHtcbiAgICAgICAgICB0aGlzLmRvd25BY3Rpb24oKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnVwQWN0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICBGaXJlZCB3aGVuIHRoZSBhbmltYXRpb24gZmluaXNoZXMuXG4gICAgICBUaGlzIGlzIHVzZWZ1bCBpZiB5b3Ugd2FudCB0byB3YWl0IHVudGlsXG4gICAgICB0aGUgcmlwcGxlIGFuaW1hdGlvbiBmaW5pc2hlcyB0byBwZXJmb3JtIHNvbWUgYWN0aW9uLlxuXG4gICAgICBAZXZlbnQgdHJhbnNpdGlvbmVuZFxuICAgICAgQHBhcmFtIHt7bm9kZTogT2JqZWN0fX0gZGV0YWlsIENvbnRhaW5zIHRoZSBhbmltYXRlZCBub2RlLlxuICAgICAgKi9cbiAgICB9KTtcbiAgfSkoKTtcbjwvc2NyaXB0PlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9wYXBlci1yaXBwbGUvcGFwZXItcmlwcGxlLmh0bWwiLCJcbnJlcXVpcmUoJy4uL3BvbHltZXIvcG9seW1lci5odG1sJyk7XG5cbnJlcXVpcmUoJy4vY29sb3IuaHRtbCcpO1xuXG5jb25zdCBSZWdpc3Rlckh0bWxUZW1wbGF0ZSA9IHJlcXVpcmUoJ3BvbHltZXItd2VicGFjay1sb2FkZXIvcmVnaXN0ZXItaHRtbC10ZW1wbGF0ZScpO1xuXG5SZWdpc3Rlckh0bWxUZW1wbGF0ZS50b0JvZHkoXCI8Y3VzdG9tLXN0eWxlPiA8c3R5bGUgaXM9Y3VzdG9tLXN0eWxlPmh0bWx7LS1wcmltYXJ5LXRleHQtY29sb3I6dmFyKC0tbGlnaHQtdGhlbWUtdGV4dC1jb2xvcik7LS1wcmltYXJ5LWJhY2tncm91bmQtY29sb3I6dmFyKC0tbGlnaHQtdGhlbWUtYmFja2dyb3VuZC1jb2xvcik7LS1zZWNvbmRhcnktdGV4dC1jb2xvcjp2YXIoLS1saWdodC10aGVtZS1zZWNvbmRhcnktY29sb3IpOy0tZGlzYWJsZWQtdGV4dC1jb2xvcjp2YXIoLS1saWdodC10aGVtZS1kaXNhYmxlZC1jb2xvcik7LS1kaXZpZGVyLWNvbG9yOnZhcigtLWxpZ2h0LXRoZW1lLWRpdmlkZXItY29sb3IpOy0tZXJyb3ItY29sb3I6dmFyKC0tcGFwZXItZGVlcC1vcmFuZ2UtYTcwMCk7LS1wcmltYXJ5LWNvbG9yOnZhcigtLXBhcGVyLWluZGlnby01MDApOy0tbGlnaHQtcHJpbWFyeS1jb2xvcjp2YXIoLS1wYXBlci1pbmRpZ28tMTAwKTstLWRhcmstcHJpbWFyeS1jb2xvcjp2YXIoLS1wYXBlci1pbmRpZ28tNzAwKTstLWFjY2VudC1jb2xvcjp2YXIoLS1wYXBlci1waW5rLWEyMDApOy0tbGlnaHQtYWNjZW50LWNvbG9yOnZhcigtLXBhcGVyLXBpbmstYTEwMCk7LS1kYXJrLWFjY2VudC1jb2xvcjp2YXIoLS1wYXBlci1waW5rLWE0MDApOy0tbGlnaHQtdGhlbWUtYmFja2dyb3VuZC1jb2xvcjojZmZmZmZmOy0tbGlnaHQtdGhlbWUtYmFzZS1jb2xvcjojMDAwMDAwOy0tbGlnaHQtdGhlbWUtdGV4dC1jb2xvcjp2YXIoLS1wYXBlci1ncmV5LTkwMCk7LS1saWdodC10aGVtZS1zZWNvbmRhcnktY29sb3I6IzczNzM3MzstLWxpZ2h0LXRoZW1lLWRpc2FibGVkLWNvbG9yOiM5YjliOWI7LS1saWdodC10aGVtZS1kaXZpZGVyLWNvbG9yOiNkYmRiZGI7LS1kYXJrLXRoZW1lLWJhY2tncm91bmQtY29sb3I6dmFyKC0tcGFwZXItZ3JleS05MDApOy0tZGFyay10aGVtZS1iYXNlLWNvbG9yOiNmZmZmZmY7LS1kYXJrLXRoZW1lLXRleHQtY29sb3I6I2ZmZmZmZjstLWRhcmstdGhlbWUtc2Vjb25kYXJ5LWNvbG9yOiNiY2JjYmM7LS1kYXJrLXRoZW1lLWRpc2FibGVkLWNvbG9yOiM2NDY0NjQ7LS1kYXJrLXRoZW1lLWRpdmlkZXItY29sb3I6IzNjM2MzYzstLXRleHQtcHJpbWFyeS1jb2xvcjp2YXIoLS1kYXJrLXRoZW1lLXRleHQtY29sb3IpOy0tZGVmYXVsdC1wcmltYXJ5LWNvbG9yOnZhcigtLXByaW1hcnktY29sb3IpfTwvc3R5bGU+IDwvY3VzdG9tLXN0eWxlPlwiKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvcGFwZXItc3R5bGVzL2RlZmF1bHQtdGhlbWUuaHRtbCIsIlxucmVxdWlyZSgnLi4vcG9seW1lci9wb2x5bWVyLmh0bWwnKTtcblxuY29uc3QgUmVnaXN0ZXJIdG1sVGVtcGxhdGUgPSByZXF1aXJlKCdwb2x5bWVyLXdlYnBhY2stbG9hZGVyL3JlZ2lzdGVyLWh0bWwtdGVtcGxhdGUnKTtcblxuUmVnaXN0ZXJIdG1sVGVtcGxhdGUudG9Cb2R5KFwiPGN1c3RvbS1zdHlsZT4gPHN0eWxlIGlzPWN1c3RvbS1zdHlsZT5odG1sey0tZ29vZ2xlLXJlZC0xMDA6I2Y0YzdjMzstLWdvb2dsZS1yZWQtMzAwOiNlNjdjNzM7LS1nb29nbGUtcmVkLTUwMDojZGI0NDM3Oy0tZ29vZ2xlLXJlZC03MDA6I2M1MzkyOTstLWdvb2dsZS1ibHVlLTEwMDojYzZkYWZjOy0tZ29vZ2xlLWJsdWUtMzAwOiM3YmFhZjc7LS1nb29nbGUtYmx1ZS01MDA6IzQyODVmNDstLWdvb2dsZS1ibHVlLTcwMDojMzM2N2Q2Oy0tZ29vZ2xlLWdyZWVuLTEwMDojYjdlMWNkOy0tZ29vZ2xlLWdyZWVuLTMwMDojNTdiYjhhOy0tZ29vZ2xlLWdyZWVuLTUwMDojMGY5ZDU4Oy0tZ29vZ2xlLWdyZWVuLTcwMDojMGI4MDQzOy0tZ29vZ2xlLXllbGxvdy0xMDA6I2ZjZThiMjstLWdvb2dsZS15ZWxsb3ctMzAwOiNmN2NiNGQ7LS1nb29nbGUteWVsbG93LTUwMDojZjRiNDAwOy0tZ29vZ2xlLXllbGxvdy03MDA6I2YwOTMwMDstLWdvb2dsZS1ncmV5LTEwMDojZjVmNWY1Oy0tZ29vZ2xlLWdyZXktMzAwOiNlMGUwZTA7LS1nb29nbGUtZ3JleS01MDA6IzllOWU5ZTstLWdvb2dsZS1ncmV5LTcwMDojNjE2MTYxOy0tcGFwZXItcmVkLTUwOiNmZmViZWU7LS1wYXBlci1yZWQtMTAwOiNmZmNkZDI7LS1wYXBlci1yZWQtMjAwOiNlZjlhOWE7LS1wYXBlci1yZWQtMzAwOiNlNTczNzM7LS1wYXBlci1yZWQtNDAwOiNlZjUzNTA7LS1wYXBlci1yZWQtNTAwOiNmNDQzMzY7LS1wYXBlci1yZWQtNjAwOiNlNTM5MzU7LS1wYXBlci1yZWQtNzAwOiNkMzJmMmY7LS1wYXBlci1yZWQtODAwOiNjNjI4Mjg7LS1wYXBlci1yZWQtOTAwOiNiNzFjMWM7LS1wYXBlci1yZWQtYTEwMDojZmY4YTgwOy0tcGFwZXItcmVkLWEyMDA6I2ZmNTI1MjstLXBhcGVyLXJlZC1hNDAwOiNmZjE3NDQ7LS1wYXBlci1yZWQtYTcwMDojZDUwMDAwOy0tcGFwZXItcGluay01MDojZmNlNGVjOy0tcGFwZXItcGluay0xMDA6I2Y4YmJkMDstLXBhcGVyLXBpbmstMjAwOiNmNDhmYjE7LS1wYXBlci1waW5rLTMwMDojZjA2MjkyOy0tcGFwZXItcGluay00MDA6I2VjNDA3YTstLXBhcGVyLXBpbmstNTAwOiNlOTFlNjM7LS1wYXBlci1waW5rLTYwMDojZDgxYjYwOy0tcGFwZXItcGluay03MDA6I2MyMTg1YjstLXBhcGVyLXBpbmstODAwOiNhZDE0NTc7LS1wYXBlci1waW5rLTkwMDojODgwZTRmOy0tcGFwZXItcGluay1hMTAwOiNmZjgwYWI7LS1wYXBlci1waW5rLWEyMDA6I2ZmNDA4MTstLXBhcGVyLXBpbmstYTQwMDojZjUwMDU3Oy0tcGFwZXItcGluay1hNzAwOiNjNTExNjI7LS1wYXBlci1wdXJwbGUtNTA6I2YzZTVmNTstLXBhcGVyLXB1cnBsZS0xMDA6I2UxYmVlNzstLXBhcGVyLXB1cnBsZS0yMDA6I2NlOTNkODstLXBhcGVyLXB1cnBsZS0zMDA6I2JhNjhjODstLXBhcGVyLXB1cnBsZS00MDA6I2FiNDdiYzstLXBhcGVyLXB1cnBsZS01MDA6IzljMjdiMDstLXBhcGVyLXB1cnBsZS02MDA6IzhlMjRhYTstLXBhcGVyLXB1cnBsZS03MDA6IzdiMWZhMjstLXBhcGVyLXB1cnBsZS04MDA6IzZhMWI5YTstLXBhcGVyLXB1cnBsZS05MDA6IzRhMTQ4YzstLXBhcGVyLXB1cnBsZS1hMTAwOiNlYTgwZmM7LS1wYXBlci1wdXJwbGUtYTIwMDojZTA0MGZiOy0tcGFwZXItcHVycGxlLWE0MDA6I2Q1MDBmOTstLXBhcGVyLXB1cnBsZS1hNzAwOiNhYTAwZmY7LS1wYXBlci1kZWVwLXB1cnBsZS01MDojZWRlN2Y2Oy0tcGFwZXItZGVlcC1wdXJwbGUtMTAwOiNkMWM0ZTk7LS1wYXBlci1kZWVwLXB1cnBsZS0yMDA6I2IzOWRkYjstLXBhcGVyLWRlZXAtcHVycGxlLTMwMDojOTU3NWNkOy0tcGFwZXItZGVlcC1wdXJwbGUtNDAwOiM3ZTU3YzI7LS1wYXBlci1kZWVwLXB1cnBsZS01MDA6IzY3M2FiNzstLXBhcGVyLWRlZXAtcHVycGxlLTYwMDojNWUzNWIxOy0tcGFwZXItZGVlcC1wdXJwbGUtNzAwOiM1MTJkYTg7LS1wYXBlci1kZWVwLXB1cnBsZS04MDA6IzQ1MjdhMDstLXBhcGVyLWRlZXAtcHVycGxlLTkwMDojMzExYjkyOy0tcGFwZXItZGVlcC1wdXJwbGUtYTEwMDojYjM4OGZmOy0tcGFwZXItZGVlcC1wdXJwbGUtYTIwMDojN2M0ZGZmOy0tcGFwZXItZGVlcC1wdXJwbGUtYTQwMDojNjUxZmZmOy0tcGFwZXItZGVlcC1wdXJwbGUtYTcwMDojNjIwMGVhOy0tcGFwZXItaW5kaWdvLTUwOiNlOGVhZjY7LS1wYXBlci1pbmRpZ28tMTAwOiNjNWNhZTk7LS1wYXBlci1pbmRpZ28tMjAwOiM5ZmE4ZGE7LS1wYXBlci1pbmRpZ28tMzAwOiM3OTg2Y2I7LS1wYXBlci1pbmRpZ28tNDAwOiM1YzZiYzA7LS1wYXBlci1pbmRpZ28tNTAwOiMzZjUxYjU7LS1wYXBlci1pbmRpZ28tNjAwOiMzOTQ5YWI7LS1wYXBlci1pbmRpZ28tNzAwOiMzMDNmOWY7LS1wYXBlci1pbmRpZ28tODAwOiMyODM1OTM7LS1wYXBlci1pbmRpZ28tOTAwOiMxYTIzN2U7LS1wYXBlci1pbmRpZ28tYTEwMDojOGM5ZWZmOy0tcGFwZXItaW5kaWdvLWEyMDA6IzUzNmRmZTstLXBhcGVyLWluZGlnby1hNDAwOiMzZDVhZmU7LS1wYXBlci1pbmRpZ28tYTcwMDojMzA0ZmZlOy0tcGFwZXItYmx1ZS01MDojZTNmMmZkOy0tcGFwZXItYmx1ZS0xMDA6I2JiZGVmYjstLXBhcGVyLWJsdWUtMjAwOiM5MGNhZjk7LS1wYXBlci1ibHVlLTMwMDojNjRiNWY2Oy0tcGFwZXItYmx1ZS00MDA6IzQyYTVmNTstLXBhcGVyLWJsdWUtNTAwOiMyMTk2ZjM7LS1wYXBlci1ibHVlLTYwMDojMWU4OGU1Oy0tcGFwZXItYmx1ZS03MDA6IzE5NzZkMjstLXBhcGVyLWJsdWUtODAwOiMxNTY1YzA7LS1wYXBlci1ibHVlLTkwMDojMGQ0N2ExOy0tcGFwZXItYmx1ZS1hMTAwOiM4MmIxZmY7LS1wYXBlci1ibHVlLWEyMDA6IzQ0OGFmZjstLXBhcGVyLWJsdWUtYTQwMDojMjk3OWZmOy0tcGFwZXItYmx1ZS1hNzAwOiMyOTYyZmY7LS1wYXBlci1saWdodC1ibHVlLTUwOiNlMWY1ZmU7LS1wYXBlci1saWdodC1ibHVlLTEwMDojYjNlNWZjOy0tcGFwZXItbGlnaHQtYmx1ZS0yMDA6IzgxZDRmYTstLXBhcGVyLWxpZ2h0LWJsdWUtMzAwOiM0ZmMzZjc7LS1wYXBlci1saWdodC1ibHVlLTQwMDojMjliNmY2Oy0tcGFwZXItbGlnaHQtYmx1ZS01MDA6IzAzYTlmNDstLXBhcGVyLWxpZ2h0LWJsdWUtNjAwOiMwMzliZTU7LS1wYXBlci1saWdodC1ibHVlLTcwMDojMDI4OGQxOy0tcGFwZXItbGlnaHQtYmx1ZS04MDA6IzAyNzdiZDstLXBhcGVyLWxpZ2h0LWJsdWUtOTAwOiMwMTU3OWI7LS1wYXBlci1saWdodC1ibHVlLWExMDA6IzgwZDhmZjstLXBhcGVyLWxpZ2h0LWJsdWUtYTIwMDojNDBjNGZmOy0tcGFwZXItbGlnaHQtYmx1ZS1hNDAwOiMwMGIwZmY7LS1wYXBlci1saWdodC1ibHVlLWE3MDA6IzAwOTFlYTstLXBhcGVyLWN5YW4tNTA6I2UwZjdmYTstLXBhcGVyLWN5YW4tMTAwOiNiMmViZjI7LS1wYXBlci1jeWFuLTIwMDojODBkZWVhOy0tcGFwZXItY3lhbi0zMDA6IzRkZDBlMTstLXBhcGVyLWN5YW4tNDAwOiMyNmM2ZGE7LS1wYXBlci1jeWFuLTUwMDojMDBiY2Q0Oy0tcGFwZXItY3lhbi02MDA6IzAwYWNjMTstLXBhcGVyLWN5YW4tNzAwOiMwMDk3YTc7LS1wYXBlci1jeWFuLTgwMDojMDA4MzhmOy0tcGFwZXItY3lhbi05MDA6IzAwNjA2NDstLXBhcGVyLWN5YW4tYTEwMDojODRmZmZmOy0tcGFwZXItY3lhbi1hMjAwOiMxOGZmZmY7LS1wYXBlci1jeWFuLWE0MDA6IzAwZTVmZjstLXBhcGVyLWN5YW4tYTcwMDojMDBiOGQ0Oy0tcGFwZXItdGVhbC01MDojZTBmMmYxOy0tcGFwZXItdGVhbC0xMDA6I2IyZGZkYjstLXBhcGVyLXRlYWwtMjAwOiM4MGNiYzQ7LS1wYXBlci10ZWFsLTMwMDojNGRiNmFjOy0tcGFwZXItdGVhbC00MDA6IzI2YTY5YTstLXBhcGVyLXRlYWwtNTAwOiMwMDk2ODg7LS1wYXBlci10ZWFsLTYwMDojMDA4OTdiOy0tcGFwZXItdGVhbC03MDA6IzAwNzk2YjstLXBhcGVyLXRlYWwtODAwOiMwMDY5NWM7LS1wYXBlci10ZWFsLTkwMDojMDA0ZDQwOy0tcGFwZXItdGVhbC1hMTAwOiNhN2ZmZWI7LS1wYXBlci10ZWFsLWEyMDA6IzY0ZmZkYTstLXBhcGVyLXRlYWwtYTQwMDojMWRlOWI2Oy0tcGFwZXItdGVhbC1hNzAwOiMwMGJmYTU7LS1wYXBlci1ncmVlbi01MDojZThmNWU5Oy0tcGFwZXItZ3JlZW4tMTAwOiNjOGU2Yzk7LS1wYXBlci1ncmVlbi0yMDA6I2E1ZDZhNzstLXBhcGVyLWdyZWVuLTMwMDojODFjNzg0Oy0tcGFwZXItZ3JlZW4tNDAwOiM2NmJiNmE7LS1wYXBlci1ncmVlbi01MDA6IzRjYWY1MDstLXBhcGVyLWdyZWVuLTYwMDojNDNhMDQ3Oy0tcGFwZXItZ3JlZW4tNzAwOiMzODhlM2M7LS1wYXBlci1ncmVlbi04MDA6IzJlN2QzMjstLXBhcGVyLWdyZWVuLTkwMDojMWI1ZTIwOy0tcGFwZXItZ3JlZW4tYTEwMDojYjlmNmNhOy0tcGFwZXItZ3JlZW4tYTIwMDojNjlmMGFlOy0tcGFwZXItZ3JlZW4tYTQwMDojMDBlNjc2Oy0tcGFwZXItZ3JlZW4tYTcwMDojMDBjODUzOy0tcGFwZXItbGlnaHQtZ3JlZW4tNTA6I2YxZjhlOTstLXBhcGVyLWxpZ2h0LWdyZWVuLTEwMDojZGNlZGM4Oy0tcGFwZXItbGlnaHQtZ3JlZW4tMjAwOiNjNWUxYTU7LS1wYXBlci1saWdodC1ncmVlbi0zMDA6I2FlZDU4MTstLXBhcGVyLWxpZ2h0LWdyZWVuLTQwMDojOWNjYzY1Oy0tcGFwZXItbGlnaHQtZ3JlZW4tNTAwOiM4YmMzNGE7LS1wYXBlci1saWdodC1ncmVlbi02MDA6IzdjYjM0MjstLXBhcGVyLWxpZ2h0LWdyZWVuLTcwMDojNjg5ZjM4Oy0tcGFwZXItbGlnaHQtZ3JlZW4tODAwOiM1NThiMmY7LS1wYXBlci1saWdodC1ncmVlbi05MDA6IzMzNjkxZTstLXBhcGVyLWxpZ2h0LWdyZWVuLWExMDA6I2NjZmY5MDstLXBhcGVyLWxpZ2h0LWdyZWVuLWEyMDA6I2IyZmY1OTstLXBhcGVyLWxpZ2h0LWdyZWVuLWE0MDA6Izc2ZmYwMzstLXBhcGVyLWxpZ2h0LWdyZWVuLWE3MDA6IzY0ZGQxNzstLXBhcGVyLWxpbWUtNTA6I2Y5ZmJlNzstLXBhcGVyLWxpbWUtMTAwOiNmMGY0YzM7LS1wYXBlci1saW1lLTIwMDojZTZlZTljOy0tcGFwZXItbGltZS0zMDA6I2RjZTc3NTstLXBhcGVyLWxpbWUtNDAwOiNkNGUxNTc7LS1wYXBlci1saW1lLTUwMDojY2RkYzM5Oy0tcGFwZXItbGltZS02MDA6I2MwY2EzMzstLXBhcGVyLWxpbWUtNzAwOiNhZmI0MmI7LS1wYXBlci1saW1lLTgwMDojOWU5ZDI0Oy0tcGFwZXItbGltZS05MDA6IzgyNzcxNzstLXBhcGVyLWxpbWUtYTEwMDojZjRmZjgxOy0tcGFwZXItbGltZS1hMjAwOiNlZWZmNDE7LS1wYXBlci1saW1lLWE0MDA6I2M2ZmYwMDstLXBhcGVyLWxpbWUtYTcwMDojYWVlYTAwOy0tcGFwZXIteWVsbG93LTUwOiNmZmZkZTc7LS1wYXBlci15ZWxsb3ctMTAwOiNmZmY5YzQ7LS1wYXBlci15ZWxsb3ctMjAwOiNmZmY1OWQ7LS1wYXBlci15ZWxsb3ctMzAwOiNmZmYxNzY7LS1wYXBlci15ZWxsb3ctNDAwOiNmZmVlNTg7LS1wYXBlci15ZWxsb3ctNTAwOiNmZmViM2I7LS1wYXBlci15ZWxsb3ctNjAwOiNmZGQ4MzU7LS1wYXBlci15ZWxsb3ctNzAwOiNmYmMwMmQ7LS1wYXBlci15ZWxsb3ctODAwOiNmOWE4MjU7LS1wYXBlci15ZWxsb3ctOTAwOiNmNTdmMTc7LS1wYXBlci15ZWxsb3ctYTEwMDojZmZmZjhkOy0tcGFwZXIteWVsbG93LWEyMDA6I2ZmZmYwMDstLXBhcGVyLXllbGxvdy1hNDAwOiNmZmVhMDA7LS1wYXBlci15ZWxsb3ctYTcwMDojZmZkNjAwOy0tcGFwZXItYW1iZXItNTA6I2ZmZjhlMTstLXBhcGVyLWFtYmVyLTEwMDojZmZlY2IzOy0tcGFwZXItYW1iZXItMjAwOiNmZmUwODI7LS1wYXBlci1hbWJlci0zMDA6I2ZmZDU0ZjstLXBhcGVyLWFtYmVyLTQwMDojZmZjYTI4Oy0tcGFwZXItYW1iZXItNTAwOiNmZmMxMDc7LS1wYXBlci1hbWJlci02MDA6I2ZmYjMwMDstLXBhcGVyLWFtYmVyLTcwMDojZmZhMDAwOy0tcGFwZXItYW1iZXItODAwOiNmZjhmMDA7LS1wYXBlci1hbWJlci05MDA6I2ZmNmYwMDstLXBhcGVyLWFtYmVyLWExMDA6I2ZmZTU3ZjstLXBhcGVyLWFtYmVyLWEyMDA6I2ZmZDc0MDstLXBhcGVyLWFtYmVyLWE0MDA6I2ZmYzQwMDstLXBhcGVyLWFtYmVyLWE3MDA6I2ZmYWIwMDstLXBhcGVyLW9yYW5nZS01MDojZmZmM2UwOy0tcGFwZXItb3JhbmdlLTEwMDojZmZlMGIyOy0tcGFwZXItb3JhbmdlLTIwMDojZmZjYzgwOy0tcGFwZXItb3JhbmdlLTMwMDojZmZiNzRkOy0tcGFwZXItb3JhbmdlLTQwMDojZmZhNzI2Oy0tcGFwZXItb3JhbmdlLTUwMDojZmY5ODAwOy0tcGFwZXItb3JhbmdlLTYwMDojZmI4YzAwOy0tcGFwZXItb3JhbmdlLTcwMDojZjU3YzAwOy0tcGFwZXItb3JhbmdlLTgwMDojZWY2YzAwOy0tcGFwZXItb3JhbmdlLTkwMDojZTY1MTAwOy0tcGFwZXItb3JhbmdlLWExMDA6I2ZmZDE4MDstLXBhcGVyLW9yYW5nZS1hMjAwOiNmZmFiNDA7LS1wYXBlci1vcmFuZ2UtYTQwMDojZmY5MTAwOy0tcGFwZXItb3JhbmdlLWE3MDA6I2ZmNjUwMDstLXBhcGVyLWRlZXAtb3JhbmdlLTUwOiNmYmU5ZTc7LS1wYXBlci1kZWVwLW9yYW5nZS0xMDA6I2ZmY2NiYzstLXBhcGVyLWRlZXAtb3JhbmdlLTIwMDojZmZhYjkxOy0tcGFwZXItZGVlcC1vcmFuZ2UtMzAwOiNmZjhhNjU7LS1wYXBlci1kZWVwLW9yYW5nZS00MDA6I2ZmNzA0MzstLXBhcGVyLWRlZXAtb3JhbmdlLTUwMDojZmY1NzIyOy0tcGFwZXItZGVlcC1vcmFuZ2UtNjAwOiNmNDUxMWU7LS1wYXBlci1kZWVwLW9yYW5nZS03MDA6I2U2NGExOTstLXBhcGVyLWRlZXAtb3JhbmdlLTgwMDojZDg0MzE1Oy0tcGFwZXItZGVlcC1vcmFuZ2UtOTAwOiNiZjM2MGM7LS1wYXBlci1kZWVwLW9yYW5nZS1hMTAwOiNmZjllODA7LS1wYXBlci1kZWVwLW9yYW5nZS1hMjAwOiNmZjZlNDA7LS1wYXBlci1kZWVwLW9yYW5nZS1hNDAwOiNmZjNkMDA7LS1wYXBlci1kZWVwLW9yYW5nZS1hNzAwOiNkZDJjMDA7LS1wYXBlci1icm93bi01MDojZWZlYmU5Oy0tcGFwZXItYnJvd24tMTAwOiNkN2NjYzg7LS1wYXBlci1icm93bi0yMDA6I2JjYWFhNDstLXBhcGVyLWJyb3duLTMwMDojYTE4ODdmOy0tcGFwZXItYnJvd24tNDAwOiM4ZDZlNjM7LS1wYXBlci1icm93bi01MDA6Izc5NTU0ODstLXBhcGVyLWJyb3duLTYwMDojNmQ0YzQxOy0tcGFwZXItYnJvd24tNzAwOiM1ZDQwMzc7LS1wYXBlci1icm93bi04MDA6IzRlMzQyZTstLXBhcGVyLWJyb3duLTkwMDojM2UyNzIzOy0tcGFwZXItZ3JleS01MDojZmFmYWZhOy0tcGFwZXItZ3JleS0xMDA6I2Y1ZjVmNTstLXBhcGVyLWdyZXktMjAwOiNlZWVlZWU7LS1wYXBlci1ncmV5LTMwMDojZTBlMGUwOy0tcGFwZXItZ3JleS00MDA6I2JkYmRiZDstLXBhcGVyLWdyZXktNTAwOiM5ZTllOWU7LS1wYXBlci1ncmV5LTYwMDojNzU3NTc1Oy0tcGFwZXItZ3JleS03MDA6IzYxNjE2MTstLXBhcGVyLWdyZXktODAwOiM0MjQyNDI7LS1wYXBlci1ncmV5LTkwMDojMjEyMTIxOy0tcGFwZXItYmx1ZS1ncmV5LTUwOiNlY2VmZjE7LS1wYXBlci1ibHVlLWdyZXktMTAwOiNjZmQ4ZGM7LS1wYXBlci1ibHVlLWdyZXktMjAwOiNiMGJlYzU7LS1wYXBlci1ibHVlLWdyZXktMzAwOiM5MGE0YWU7LS1wYXBlci1ibHVlLWdyZXktNDAwOiM3ODkwOWM7LS1wYXBlci1ibHVlLWdyZXktNTAwOiM2MDdkOGI7LS1wYXBlci1ibHVlLWdyZXktNjAwOiM1NDZlN2E7LS1wYXBlci1ibHVlLWdyZXktNzAwOiM0NTVhNjQ7LS1wYXBlci1ibHVlLWdyZXktODAwOiMzNzQ3NGY7LS1wYXBlci1ibHVlLWdyZXktOTAwOiMyNjMyMzg7LS1kYXJrLWRpdmlkZXItb3BhY2l0eTowLjEyOy0tZGFyay1kaXNhYmxlZC1vcGFjaXR5OjAuMzg7LS1kYXJrLXNlY29uZGFyeS1vcGFjaXR5OjAuNTQ7LS1kYXJrLXByaW1hcnktb3BhY2l0eTowLjg3Oy0tbGlnaHQtZGl2aWRlci1vcGFjaXR5OjAuMTI7LS1saWdodC1kaXNhYmxlZC1vcGFjaXR5OjAuMzstLWxpZ2h0LXNlY29uZGFyeS1vcGFjaXR5OjAuNzstLWxpZ2h0LXByaW1hcnktb3BhY2l0eToxLjB9PC9zdHlsZT4gPC9jdXN0b20tc3R5bGU+XCIpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9wYXBlci1zdHlsZXMvY29sb3IuaHRtbCIsIlxucmVxdWlyZSgnLi4vYm93ZXJfY29tcG9uZW50cy9pcm9uLWljb25zZXQtc3ZnL2lyb24taWNvbnNldC1zdmcuaHRtbCcpO1xuXG5jb25zdCBSZWdpc3Rlckh0bWxUZW1wbGF0ZSA9IHJlcXVpcmUoJ3BvbHltZXItd2VicGFjay1sb2FkZXIvcmVnaXN0ZXItaHRtbC10ZW1wbGF0ZScpO1xuXG5SZWdpc3Rlckh0bWxUZW1wbGF0ZS50b0JvZHkoXCI8aXJvbi1pY29uc2V0LXN2ZyBuYW1lPW15LWljb25zIHNpemU9MjQ+IDxzdmc+IDxkZWZzPiA8ZyBpZD1hcnJvdy1iYWNrPiA8cGF0aCBkPVxcXCJNMjAgMTFINy44M2w1LjU5LTUuNTlMMTIgNGwtOCA4IDggOCAxLjQxLTEuNDFMNy44MyAxM0gyMHYtMnpcXFwiPjwvcGF0aD4gPC9nPiA8ZyBpZD1tZW51PiA8cGF0aCBkPVxcXCJNMyAxOGgxOHYtMkgzdjJ6bTAtNWgxOHYtMkgzdjJ6bTAtN3YyaDE4VjZIM3pcXFwiPjwvcGF0aD4gPC9nPiA8ZyBpZD1jaGV2cm9uLXJpZ2h0PiA8cGF0aCBkPVxcXCJNMTAgNkw4LjU5IDcuNDEgMTMuMTcgMTJsLTQuNTggNC41OUwxMCAxOGw2LTZ6XFxcIj48L3BhdGg+IDwvZz4gPGcgaWQ9Y2xvc2U+IDxwYXRoIGQ9XFxcIk0xOSA2LjQxTDE3LjU5IDUgMTIgMTAuNTkgNi40MSA1IDUgNi40MSAxMC41OSAxMiA1IDE3LjU5IDYuNDEgMTkgMTIgMTMuNDEgMTcuNTkgMTkgMTkgMTcuNTkgMTMuNDEgMTJ6XFxcIj48L3BhdGg+IDwvZz4gPC9kZWZzPiA8L3N2Zz4gPC9pcm9uLWljb25zZXQtc3ZnPlwiKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9teS1pY29ucy5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNSBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuXG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vcG9seW1lci9wb2x5bWVyLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi9pcm9uLW1ldGEvaXJvbi1tZXRhLmh0bWxcIj5cblxuPHNjcmlwdD5cbiAgLyoqXG4gICAqIFRoZSBgaXJvbi1pY29uc2V0LXN2Z2AgZWxlbWVudCBhbGxvd3MgdXNlcnMgdG8gZGVmaW5lIHRoZWlyIG93biBpY29uIHNldHNcbiAgICogdGhhdCBjb250YWluIHN2ZyBpY29ucy4gVGhlIHN2ZyBpY29uIGVsZW1lbnRzIHNob3VsZCBiZSBjaGlsZHJlbiBvZiB0aGVcbiAgICogYGlyb24taWNvbnNldC1zdmdgIGVsZW1lbnQuIE11bHRpcGxlIGljb25zIHNob3VsZCBiZSBnaXZlbiBkaXN0aW5jdCBpZCdzLlxuICAgKlxuICAgKiBVc2luZyBzdmcgZWxlbWVudHMgdG8gY3JlYXRlIGljb25zIGhhcyBhIGZldyBhZHZhbnRhZ2VzIG92ZXIgdHJhZGl0aW9uYWxcbiAgICogYml0bWFwIGdyYXBoaWNzIGxpa2UganBnIG9yIHBuZy4gSWNvbnMgdGhhdCB1c2Ugc3ZnIGFyZSB2ZWN0b3IgYmFzZWQgc29cbiAgICogdGhleSBhcmUgcmVzb2x1dGlvbiBpbmRlcGVuZGVudCBhbmQgc2hvdWxkIGxvb2sgZ29vZCBvbiBhbnkgZGV2aWNlLiBUaGV5XG4gICAqIGFyZSBzdHlsYWJsZSB2aWEgY3NzLiBJY29ucyBjYW4gYmUgdGhlbWVkLCBjb2xvcml6ZWQsIGFuZCBldmVuIGFuaW1hdGVkLlxuICAgKlxuICAgKiBFeGFtcGxlOlxuICAgKlxuICAgKiAgICAgPGlyb24taWNvbnNldC1zdmcgbmFtZT1cIm15LXN2Zy1pY29uc1wiIHNpemU9XCIyNFwiPlxuICAgKiAgICAgICA8c3ZnPlxuICAgKiAgICAgICAgIDxkZWZzPlxuICAgKiAgICAgICAgICAgPGcgaWQ9XCJzaGFwZVwiPlxuICAgKiAgICAgICAgICAgICA8cmVjdCB4PVwiMTJcIiB5PVwiMFwiIHdpZHRoPVwiMTJcIiBoZWlnaHQ9XCIyNFwiIC8+XG4gICAqICAgICAgICAgICAgIDxjaXJjbGUgY3g9XCIxMlwiIGN5PVwiMTJcIiByPVwiMTJcIiAvPlxuICAgKiAgICAgICAgICAgPC9nPlxuICAgKiAgICAgICAgIDwvZGVmcz5cbiAgICogICAgICAgPC9zdmc+XG4gICAqICAgICA8L2lyb24taWNvbnNldC1zdmc+XG4gICAqXG4gICAqIFRoaXMgd2lsbCBhdXRvbWF0aWNhbGx5IHJlZ2lzdGVyIHRoZSBpY29uIHNldCBcIm15LXN2Zy1pY29uc1wiIHRvIHRoZSBpY29uc2V0XG4gICAqIGRhdGFiYXNlLiAgVG8gdXNlIHRoZXNlIGljb25zIGZyb20gd2l0aGluIGFub3RoZXIgZWxlbWVudCwgbWFrZSBhXG4gICAqIGBpcm9uLWljb25zZXRgIGVsZW1lbnQgYW5kIGNhbGwgdGhlIGBieUlkYCBtZXRob2RcbiAgICogdG8gcmV0cmlldmUgYSBnaXZlbiBpY29uc2V0LiBUbyBhcHBseSBhIHBhcnRpY3VsYXIgaWNvbiBpbnNpZGUgYW5cbiAgICogZWxlbWVudCB1c2UgdGhlIGBhcHBseUljb25gIG1ldGhvZC4gRm9yIGV4YW1wbGU6XG4gICAqXG4gICAqICAgICBpY29uc2V0LmFwcGx5SWNvbihpY29uTm9kZSwgJ2NhcicpO1xuICAgKlxuICAgKiBAZWxlbWVudCBpcm9uLWljb25zZXQtc3ZnXG4gICAqIEBkZW1vIGRlbW8vaW5kZXguaHRtbFxuICAgKiBAaW1wbGVtZW50cyB7UG9seW1lci5JY29uc2V0fVxuICAgKi9cbiAgUG9seW1lcih7XG4gICAgaXM6ICdpcm9uLWljb25zZXQtc3ZnJyxcblxuICAgIHByb3BlcnRpZXM6IHtcblxuICAgICAgLyoqXG4gICAgICAgKiBUaGUgbmFtZSBvZiB0aGUgaWNvbnNldC5cbiAgICAgICAqL1xuICAgICAgbmFtZToge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIG9ic2VydmVyOiAnX25hbWVDaGFuZ2VkJ1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBUaGUgc2l6ZSBvZiBhbiBpbmRpdmlkdWFsIGljb24uIE5vdGUgdGhhdCBpY29ucyBtdXN0IGJlIHNxdWFyZS5cbiAgICAgICAqL1xuICAgICAgc2l6ZToge1xuICAgICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICAgIHZhbHVlOiAyNFxuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBTZXQgdG8gdHJ1ZSB0byBlbmFibGUgbWlycm9yaW5nIG9mIGljb25zIHdoZXJlIHNwZWNpZmllZCB3aGVuIHRoZXkgYXJlXG4gICAgICAgKiBzdGFtcGVkLiBJY29ucyB0aGF0IHNob3VsZCBiZSBtaXJyb3JlZCBzaG91bGQgYmUgZGVjb3JhdGVkIHdpdGggYVxuICAgICAgICogYG1pcnJvci1pbi1ydGxgIGF0dHJpYnV0ZS5cbiAgICAgICAqXG4gICAgICAgKiBOT1RFOiBGb3IgcGVyZm9ybWFuY2UgcmVhc29ucywgZGlyZWN0aW9uIHdpbGwgYmUgcmVzb2x2ZWQgb25jZSBwZXJcbiAgICAgICAqIGRvY3VtZW50IHBlciBpY29uc2V0LCBzbyBtb3ZpbmcgaWNvbnMgaW4gYW5kIG91dCBvZiBSVEwgc3VidHJlZXMgd2lsbFxuICAgICAgICogbm90IGNhdXNlIHRoZWlyIG1pcnJvcmVkIHN0YXRlIHRvIGNoYW5nZS5cbiAgICAgICAqL1xuICAgICAgcnRsTWlycm9yaW5nOiB7XG4gICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBTZXQgdG8gdHJ1ZSB0byBtZWFzdXJlIFJUTCBiYXNlZCBvbiB0aGUgZGlyIGF0dHJpYnV0ZSBvbiB0aGUgYm9keSBvclxuICAgICAgICogaHRtbCBlbGVtZW50cyAobWVhc3VyZWQgb24gZG9jdW1lbnQuYm9keSBvciBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgYXNcbiAgICAgICAqIGF2YWlsYWJsZSkuXG4gICAgICAgKi9cbiAgICAgIHVzZUdsb2JhbFJ0bEF0dHJpYnV0ZToge1xuICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgY3JlYXRlZDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9tZXRhID0gbmV3IFBvbHltZXIuSXJvbk1ldGEoe3R5cGU6ICdpY29uc2V0Jywga2V5OiBudWxsLCB2YWx1ZTogbnVsbH0pO1xuICAgIH0sXG5cbiAgICBhdHRhY2hlZDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhbiBhcnJheSBvZiBhbGwgaWNvbiBuYW1lcyBpbiB0aGlzIGljb25zZXQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHshQXJyYXl9IEFycmF5IG9mIGljb24gbmFtZXMuXG4gICAgICovXG4gICAgZ2V0SWNvbk5hbWVzOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX2ljb25zID0gdGhpcy5fY3JlYXRlSWNvbk1hcCgpO1xuICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuX2ljb25zKS5tYXAoZnVuY3Rpb24obikge1xuICAgICAgICByZXR1cm4gdGhpcy5uYW1lICsgJzonICsgbjtcbiAgICAgIH0sIHRoaXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIGFuIGljb24gdG8gdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBBbiBzdmcgaWNvbiBpcyBwcmVwZW5kZWQgdG8gdGhlIGVsZW1lbnQncyBzaGFkb3dSb290IGlmIGl0IGV4aXN0cyxcbiAgICAgKiBvdGhlcndpc2UgdG8gdGhlIGVsZW1lbnQgaXRzZWxmLlxuICAgICAqXG4gICAgICogSWYgUlRMIG1pcnJvcmluZyBpcyBlbmFibGVkLCBhbmQgdGhlIGljb24gaXMgbWFya2VkIHRvIGJlIG1pcnJvcmVkIGluXG4gICAgICogUlRMLCB0aGUgZWxlbWVudCB3aWxsIGJlIHRlc3RlZCAob25jZSBhbmQgb25seSBvbmNlIGV2ZXIgZm9yIGVhY2hcbiAgICAgKiBpY29uc2V0KSB0byBkZXRlcm1pbmUgdGhlIGRpcmVjdGlvbiBvZiB0aGUgc3VidHJlZSB0aGUgZWxlbWVudCBpcyBpbi5cbiAgICAgKiBUaGlzIGRpcmVjdGlvbiB3aWxsIGFwcGx5IHRvIGFsbCBmdXR1cmUgaWNvbiBhcHBsaWNhdGlvbnMsIGFsdGhvdWdoIG9ubHlcbiAgICAgKiBpY29ucyBtYXJrZWQgdG8gYmUgbWlycm9yZWQgd2lsbCBiZSBhZmZlY3RlZC5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgYXBwbHlJY29uXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdG8gd2hpY2ggdGhlIGljb24gaXMgYXBwbGllZC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWNvbk5hbWUgTmFtZSBvZiB0aGUgaWNvbiB0byBhcHBseS5cbiAgICAgKiBAcmV0dXJuIHs/RWxlbWVudH0gVGhlIHN2ZyBlbGVtZW50IHdoaWNoIHJlbmRlcnMgdGhlIGljb24uXG4gICAgICovXG4gICAgYXBwbHlJY29uOiBmdW5jdGlvbihlbGVtZW50LCBpY29uTmFtZSkge1xuICAgICAgLy8gUmVtb3ZlIG9sZCBzdmcgZWxlbWVudFxuICAgICAgdGhpcy5yZW1vdmVJY29uKGVsZW1lbnQpO1xuICAgICAgLy8gaW5zdGFsbCBuZXcgc3ZnIGVsZW1lbnRcbiAgICAgIHZhciBzdmcgPSB0aGlzLl9jbG9uZUljb24oaWNvbk5hbWUsXG4gICAgICAgICAgdGhpcy5ydGxNaXJyb3JpbmcgJiYgdGhpcy5fdGFyZ2V0SXNSVEwoZWxlbWVudCkpO1xuICAgICAgaWYgKHN2Zykge1xuICAgICAgICAvLyBpbnNlcnQgc3ZnIGVsZW1lbnQgaW50byBzaGFkb3cgcm9vdCwgaWYgaXQgZXhpc3RzXG4gICAgICAgIHZhciBwZGUgPSBQb2x5bWVyLmRvbShlbGVtZW50LnJvb3QgfHwgZWxlbWVudCk7XG4gICAgICAgIHBkZS5pbnNlcnRCZWZvcmUoc3ZnLCBwZGUuY2hpbGROb2Rlc1swXSk7XG4gICAgICAgIHJldHVybiBlbGVtZW50Ll9zdmdJY29uID0gc3ZnO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhbiBpY29uIGZyb20gdGhlIGdpdmVuIGVsZW1lbnQgYnkgdW5kb2luZyB0aGUgY2hhbmdlcyBlZmZlY3RlZFxuICAgICAqIGJ5IGBhcHBseUljb25gLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IFRoZSBlbGVtZW50IGZyb20gd2hpY2ggdGhlIGljb24gaXMgcmVtb3ZlZC5cbiAgICAgKi9cbiAgICByZW1vdmVJY29uOiBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAvLyBSZW1vdmUgb2xkIHN2ZyBlbGVtZW50XG4gICAgICBpZiAoZWxlbWVudC5fc3ZnSWNvbikge1xuICAgICAgICBQb2x5bWVyLmRvbShlbGVtZW50LnJvb3QgfHwgZWxlbWVudCkucmVtb3ZlQ2hpbGQoZWxlbWVudC5fc3ZnSWNvbik7XG4gICAgICAgIGVsZW1lbnQuX3N2Z0ljb24gPSBudWxsO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNZWFzdXJlcyBhbmQgbWVtb2l6ZXMgdGhlIGRpcmVjdGlvbiBvZiB0aGUgZWxlbWVudC4gTm90ZSB0aGF0IHRoaXNcbiAgICAgKiBtZWFzdXJlbWVudCBpcyBvbmx5IGRvbmUgb25jZSBhbmQgdGhlIHJlc3VsdCBpcyBtZW1vaXplZCBmb3IgZnV0dXJlXG4gICAgICogaW52b2NhdGlvbnMuXG4gICAgICovXG4gICAgX3RhcmdldElzUlRMOiBmdW5jdGlvbih0YXJnZXQpIHtcbiAgICAgIGlmICh0aGlzLl9fdGFyZ2V0SXNSVEwgPT0gbnVsbCkge1xuICAgICAgICBpZiAodGhpcy51c2VHbG9iYWxSdGxBdHRyaWJ1dGUpIHtcbiAgICAgICAgICB2YXIgZ2xvYmFsRWxlbWVudCA9XG4gICAgICAgICAgICAgIChkb2N1bWVudC5ib2R5ICYmIGRvY3VtZW50LmJvZHkuaGFzQXR0cmlidXRlKCdkaXInKSlcbiAgICAgICAgICAgICAgICAgID8gZG9jdW1lbnQuYm9keVxuICAgICAgICAgICAgICAgICAgOiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cbiAgICAgICAgICB0aGlzLl9fdGFyZ2V0SXNSVEwgPSBnbG9iYWxFbGVtZW50LmdldEF0dHJpYnV0ZSgnZGlyJykgPT09ICdydGwnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh0YXJnZXQgJiYgdGFyZ2V0Lm5vZGVUeXBlICE9PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0Lmhvc3Q7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5fX3RhcmdldElzUlRMID0gdGFyZ2V0ICYmXG4gICAgICAgICAgICAgIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRhcmdldClbJ2RpcmVjdGlvbiddID09PSAncnRsJztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5fX3RhcmdldElzUlRMO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFdoZW4gbmFtZSBpcyBjaGFuZ2VkLCByZWdpc3RlciBpY29uc2V0IG1ldGFkYXRhXG4gICAgICpcbiAgICAgKi9cbiAgICBfbmFtZUNoYW5nZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fbWV0YS52YWx1ZSA9IG51bGw7XG4gICAgICB0aGlzLl9tZXRhLmtleSA9IHRoaXMubmFtZTtcbiAgICAgIHRoaXMuX21ldGEudmFsdWUgPSB0aGlzO1xuXG4gICAgICB0aGlzLmFzeW5jKGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmZpcmUoJ2lyb24taWNvbnNldC1hZGRlZCcsIHRoaXMsIHtub2RlOiB3aW5kb3d9KTtcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBtYXAgb2YgY2hpbGQgU1ZHIGVsZW1lbnRzIGJ5IGlkLlxuICAgICAqXG4gICAgICogQHJldHVybiB7IU9iamVjdH0gTWFwIG9mIGlkJ3MgdG8gU1ZHIGVsZW1lbnRzLlxuICAgICAqL1xuICAgIF9jcmVhdGVJY29uTWFwOiBmdW5jdGlvbigpIHtcbiAgICAgIC8vIE9iamVjdHMgY2hhaW5lZCB0byBPYmplY3QucHJvdG90eXBlIChge31gKSBoYXZlIG1lbWJlcnMuIFNwZWNpZmljYWxseSxcbiAgICAgIC8vIG9uIEZGIHRoZXJlIGlzIGEgYHdhdGNoYCBtZXRob2QgdGhhdCBjb25mdXNlcyB0aGUgaWNvbiBtYXAsIHNvIHdlXG4gICAgICAvLyBuZWVkIHRvIHVzZSBhIG51bGwtYmFzZWQgb2JqZWN0IGhlcmUuXG4gICAgICB2YXIgaWNvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgUG9seW1lci5kb20odGhpcykucXVlcnlTZWxlY3RvckFsbCgnW2lkXScpXG4gICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uKGljb24pIHtcbiAgICAgICAgICBpY29uc1tpY29uLmlkXSA9IGljb247XG4gICAgICAgIH0pO1xuICAgICAgcmV0dXJuIGljb25zO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQcm9kdWNlIGluc3RhbGxhYmxlIGNsb25lIG9mIHRoZSBTVkcgZWxlbWVudCBtYXRjaGluZyBgaWRgIGluIHRoaXNcbiAgICAgKiBpY29uc2V0LCBvciBgdW5kZWZpbmVkYCBpZiB0aGVyZSBpcyBubyBtYXRjaGluZyBlbGVtZW50LlxuICAgICAqXG4gICAgICogQHJldHVybiB7RWxlbWVudH0gUmV0dXJucyBhbiBpbnN0YWxsYWJsZSBjbG9uZSBvZiB0aGUgU1ZHIGVsZW1lbnRcbiAgICAgKiBtYXRjaGluZyBgaWRgLlxuICAgICAqL1xuICAgIF9jbG9uZUljb246IGZ1bmN0aW9uKGlkLCBtaXJyb3JBbGxvd2VkKSB7XG4gICAgICAvLyBjcmVhdGUgdGhlIGljb24gbWFwIG9uLWRlbWFuZCwgc2luY2UgdGhlIGljb25zZXQgaXRzZWxmIGhhcyBubyBkaXNjcmV0ZVxuICAgICAgLy8gc2lnbmFsIHRvIGtub3cgd2hlbiBpdCdzIGNoaWxkcmVuIGFyZSBmdWxseSBwYXJzZWRcbiAgICAgIHRoaXMuX2ljb25zID0gdGhpcy5faWNvbnMgfHwgdGhpcy5fY3JlYXRlSWNvbk1hcCgpO1xuICAgICAgcmV0dXJuIHRoaXMuX3ByZXBhcmVTdmdDbG9uZSh0aGlzLl9pY29uc1tpZF0sIHRoaXMuc2l6ZSwgbWlycm9yQWxsb3dlZCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gc291cmNlU3ZnXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNpemVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG1pcnJvckFsbG93ZWRcbiAgICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgICAqL1xuICAgIF9wcmVwYXJlU3ZnQ2xvbmU6IGZ1bmN0aW9uKHNvdXJjZVN2Zywgc2l6ZSwgbWlycm9yQWxsb3dlZCkge1xuICAgICAgaWYgKHNvdXJjZVN2Zykge1xuICAgICAgICB2YXIgY29udGVudCA9IHNvdXJjZVN2Zy5jbG9uZU5vZGUodHJ1ZSksXG4gICAgICAgICAgICBzdmcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJywgJ3N2ZycpLFxuICAgICAgICAgICAgdmlld0JveCA9IGNvbnRlbnQuZ2V0QXR0cmlidXRlKCd2aWV3Qm94JykgfHwgJzAgMCAnICsgc2l6ZSArICcgJyArIHNpemUsXG4gICAgICAgICAgICBjc3NUZXh0ID0gJ3BvaW50ZXItZXZlbnRzOiBub25lOyBkaXNwbGF5OiBibG9jazsgd2lkdGg6IDEwMCU7IGhlaWdodDogMTAwJTsnO1xuXG4gICAgICAgIGlmIChtaXJyb3JBbGxvd2VkICYmIGNvbnRlbnQuaGFzQXR0cmlidXRlKCdtaXJyb3ItaW4tcnRsJykpIHtcbiAgICAgICAgICBjc3NUZXh0ICs9ICctd2Via2l0LXRyYW5zZm9ybTpzY2FsZSgtMSwxKTt0cmFuc2Zvcm06c2NhbGUoLTEsMSk7JztcbiAgICAgICAgfVxuXG4gICAgICAgIHN2Zy5zZXRBdHRyaWJ1dGUoJ3ZpZXdCb3gnLCB2aWV3Qm94KTtcbiAgICAgICAgc3ZnLnNldEF0dHJpYnV0ZSgncHJlc2VydmVBc3BlY3RSYXRpbycsICd4TWlkWU1pZCBtZWV0Jyk7XG4gICAgICAgIHN2Zy5zZXRBdHRyaWJ1dGUoJ2ZvY3VzYWJsZScsICdmYWxzZScpO1xuICAgICAgICAvLyBUT0RPKGRmcmVlZG0pOiBgcG9pbnRlci1ldmVudHM6IG5vbmVgIHdvcmtzIGFyb3VuZCBodHRwczovL2NyYnVnLmNvbS8zNzAxMzZcbiAgICAgICAgLy8gVE9ETyhzam1pbGVzKTogaW5saW5lIHN0eWxlIG1heSBub3QgYmUgaWRlYWwsIGJ1dCBhdm9pZHMgcmVxdWlyaW5nIGEgc2hhZG93LXJvb3RcbiAgICAgICAgc3ZnLnN0eWxlLmNzc1RleHQgPSBjc3NUZXh0O1xuICAgICAgICBzdmcuYXBwZW5kQ2hpbGQoY29udGVudCkucmVtb3ZlQXR0cmlidXRlKCdpZCcpO1xuICAgICAgICByZXR1cm4gc3ZnO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gIH0pO1xuXG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvaXJvbi1pY29uc2V0LXN2Zy9pcm9uLWljb25zZXQtc3ZnLmh0bWwiXSwic291cmNlUm9vdCI6IiJ9