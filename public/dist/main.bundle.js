/******/ (function(modules) { // webpackBootstrap
/******/ 	// install a JSONP callback for chunk loading
/******/ 	var parentJsonpFunction = window["webpackJsonp"];
/******/ 	window["webpackJsonp"] = function webpackJsonpCallback(chunkIds, moreModules, executeModules) {
/******/ 		// add "moreModules" to the modules object,
/******/ 		// then flag all "chunkIds" as loaded and fire callback
/******/ 		var moduleId, chunkId, i = 0, resolves = [], result;
/******/ 		for(;i < chunkIds.length; i++) {
/******/ 			chunkId = chunkIds[i];
/******/ 			if(installedChunks[chunkId]) {
/******/ 				resolves.push(installedChunks[chunkId][0]);
/******/ 			}
/******/ 			installedChunks[chunkId] = 0;
/******/ 		}
/******/ 		for(moduleId in moreModules) {
/******/ 			if(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
/******/ 				modules[moduleId] = moreModules[moduleId];
/******/ 			}
/******/ 		}
/******/ 		if(parentJsonpFunction) parentJsonpFunction(chunkIds, moreModules, executeModules);
/******/ 		while(resolves.length) {
/******/ 			resolves.shift()();
/******/ 		}
/******/
/******/ 	};
/******/
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// objects to store loaded and loading chunks
/******/ 	var installedChunks = {
/******/ 		4: 0
/******/ 	};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/ 	// This file contains only the entry chunk.
/******/ 	// The chunk loading function for additional chunks
/******/ 	__webpack_require__.e = function requireEnsure(chunkId) {
/******/ 		var installedChunkData = installedChunks[chunkId];
/******/ 		if(installedChunkData === 0) {
/******/ 			return new Promise(function(resolve) { resolve(); });
/******/ 		}
/******/
/******/ 		// a Promise means "currently loading".
/******/ 		if(installedChunkData) {
/******/ 			return installedChunkData[2];
/******/ 		}
/******/
/******/ 		// setup Promise in chunk cache
/******/ 		var promise = new Promise(function(resolve, reject) {
/******/ 			installedChunkData = installedChunks[chunkId] = [resolve, reject];
/******/ 		});
/******/ 		installedChunkData[2] = promise;
/******/
/******/ 		// start chunk loading
/******/ 		var head = document.getElementsByTagName('head')[0];
/******/ 		var script = document.createElement('script');
/******/ 		script.type = 'text/javascript';
/******/ 		script.charset = 'utf-8';
/******/ 		script.async = true;
/******/ 		script.timeout = 120000;
/******/
/******/ 		if (__webpack_require__.nc) {
/******/ 			script.setAttribute("nonce", __webpack_require__.nc);
/******/ 		}
/******/ 		script.src = __webpack_require__.p + "" + chunkId + ".bundle.js";
/******/ 		var timeout = setTimeout(onScriptComplete, 120000);
/******/ 		script.onerror = script.onload = onScriptComplete;
/******/ 		function onScriptComplete() {
/******/ 			// avoid mem leaks in IE.
/******/ 			script.onerror = script.onload = null;
/******/ 			clearTimeout(timeout);
/******/ 			var chunk = installedChunks[chunkId];
/******/ 			if(chunk !== 0) {
/******/ 				if(chunk) {
/******/ 					chunk[1](new Error('Loading chunk ' + chunkId + ' failed.'));
/******/ 				}
/******/ 				installedChunks[chunkId] = undefined;
/******/ 			}
/******/ 		};
/******/ 		head.appendChild(script);
/******/
/******/ 		return promise;
/******/ 	};
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "dist/";
/******/
/******/ 	// on error function for async loading
/******/ 	__webpack_require__.oe = function(err) { console.error(err); throw err; };
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 39);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(22);

__webpack_require__(53);

__webpack_require__(55);

__webpack_require__(56);

__webpack_require__(57);

__webpack_require__(58);

__webpack_require__(59);

__webpack_require__(60);

__webpack_require__(63);

// bc
Polymer.Base = Polymer.LegacyElementMixin(HTMLElement).prototype;

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


(function () {
  'use strict';

  var userPolymer = window.Polymer;

  /**
   * @namespace Polymer
   * @summary Polymer is a lightweight library built on top of the web
   *   standards-based Web Components API's, and makes it easy to build your
   *   own custom HTML elements.
   * @param {!PolymerInit} info Prototype for the custom element. It must contain
   *   an `is` property to specify the element name. Other properties populate
   *   the element prototype. The `properties`, `observers`, `hostAttributes`,
   *   and `listeners` properties are processed to create element features.
   * @return {!Object} Returns a custom element class for the given provided
   *   prototype `info` object. The name of the element if given by `info.is`.
   */
  window.Polymer = function (info) {
    return window.Polymer._polymerFn(info);
  };

  // support user settings on the Polymer object
  if (userPolymer) {
    Object.assign(Polymer, userPolymer);
  }

  // To be plugged by legacy implementation if loaded
  /* eslint-disable valid-jsdoc */
  /**
   * @param {!PolymerInit} info Prototype for the custom element. It must contain
   *   an `is` property to specify the element name. Other properties populate
   *   the element prototype. The `properties`, `observers`, `hostAttributes`,
   *   and `listeners` properties are processed to create element features.
   * @return {!Object} Returns a custom element class for the given provided
   *   prototype `info` object. The name of the element if given by `info.is`.
   */
  window.Polymer._polymerFn = function (info) {
    // eslint-disable-line no-unused-vars
    throw new Error('Load polymer.html to use the Polymer() function.');
  };
  /* eslint-enable */

  window.Polymer.version = '2.0.1';

  /* eslint-disable no-unused-vars */
  /*
  When using Closure Compiler, JSCompiler_renameProperty(property, object) is replaced by the munged name for object[property]
  We cannot alias this function, so we have to use a small shim that has the same behavior when not compiling.
  */
  window.JSCompiler_renameProperty = function (prop, obj) {
    return prop;
  };
  /* eslint-enable */
})();

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/* eslint-env browser */

var RegisterHtmlTemplate = function () {
  function RegisterHtmlTemplate() {
    _classCallCheck(this, RegisterHtmlTemplate);
  }

  _createClass(RegisterHtmlTemplate, null, [{
    key: 'register',

    /**
     * Create a `<template>` element to hold `<dom-module>` content.
     * This bit of code will execute in the context of the main document,
     * calling `importNode` on the `<template>`, which in turn triggers
     * the lifecycle of the `<dom-module>` and allows it to insert its
     * content into Polymer's global module map. When a Polymer element
     * boots up it will fetch its template from this module map.
     * https://github.com/Polymer/polymer/blob/master/lib/mixins/element-mixin.html#L501-L538
     * @param {string} val A `<dom-module>` as an HTML string
     */
    value: function register(val) {
      var content = void 0;
      var template = document.createElement('template');
      template.innerHTML = val;
      if (template.content) {
        content = template.content; // eslint-disable-line prefer-destructuring
      } else {
        content = document.createDocumentFragment();
        while (template.firstChild) {
          content.appendChild(template.firstChild);
        }
      }
      document.importNode(content, true);
    }
    /**
     * Content that will be injected into the main document. This is primarily
     * for things like `<iron-iconset>` and `<custom-style>` which do not have
     * templates but rely on HTML Imports ability to apply content to the main
     * document.
     * @param {string} val An HTML string
     */

  }, {
    key: 'toBody',
    value: function toBody(val) {
      var trimmedVal = val.trim();
      if (trimmedVal) {
        var div = document.createElement('div');
        div.innerHTML = trimmedVal;
        if (div.firstChild) {
          if (document.body) {
            document.body.insertBefore(div.firstChild, document.body.firstChild);
          } else {
            document.addEventListener('DOMContentLoaded', function () {
              document.body.insertBefore(div.firstChild, document.body.firstChild);
            });
          }
        }
      }
    }
  }]);

  return RegisterHtmlTemplate;
}();

module.exports = RegisterHtmlTemplate;

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(1);

(function () {

  'use strict';

  // unique global id for deduping mixins.

  var dedupeId = 0;

  /**
   * @constructor
   * @extends {Function}
   */
  function MixinFunction() {}
  /** @type {(WeakMap | undefined)} */
  MixinFunction.prototype.__mixinApplications;
  /** @type {(Object | undefined)} */
  MixinFunction.prototype.__mixinSet;

  /* eslint-disable valid-jsdoc */
  /**
   * Wraps an ES6 class expression mixin such that the mixin is only applied
   * if it has not already been applied its base argument.  Also memoizes mixin
   * applications.
   *
   * @memberof Polymer
   * @template T
   * @param {T} mixin ES6 class expression mixin to wrap
   * @suppress {invalidCasts}
   */
  Polymer.dedupingMixin = function (mixin) {
    var mixinApplications = /** @type {!MixinFunction} */mixin.__mixinApplications;
    if (!mixinApplications) {
      mixinApplications = new WeakMap();
      /** @type {!MixinFunction} */mixin.__mixinApplications = mixinApplications;
    }
    // maintain a unique id for each mixin
    var mixinDedupeId = dedupeId++;
    function dedupingMixin(base) {
      var baseSet = /** @type {!MixinFunction} */base.__mixinSet;
      if (baseSet && baseSet[mixinDedupeId]) {
        return base;
      }
      var map = mixinApplications;
      var extended = map.get(base);
      if (!extended) {
        extended = /** @type {!Function} */mixin(base);
        map.set(base, extended);
      }
      // copy inherited mixin set from the extended class, or the base class
      // NOTE: we avoid use of Set here because some browser (IE11)
      // cannot extend a base Set via the constructor.
      var mixinSet = Object.create( /** @type {!MixinFunction} */extended.__mixinSet || baseSet || null);
      mixinSet[mixinDedupeId] = true;
      /** @type {!MixinFunction} */extended.__mixinSet = mixinSet;
      return extended;
    }

    return dedupingMixin;
  };
  /* eslint-enable valid-jsdoc */
})();

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

__webpack_require__(34);

__webpack_require__(67);

/**
 * `Polymer.AppScrollEffectsBehavior` provides an interface that allows an element to use scrolls effects.
 *
 * ### Importing the app-layout effects
 *
 * app-layout provides a set of scroll effects that can be used by explicitly importing
 * `app-scroll-effects.html`:
 *
 * ```html
 * <link rel="import" href="/bower_components/app-layout/app-scroll-effects/app-scroll-effects.html">
 * ```
 *
 * The scroll effects can also be used by individually importing
 * `app-layout/app-scroll-effects/effects/[effectName].html`. For example:
 *
 * ```html
 *  <link rel="import" href="/bower_components/app-layout/app-scroll-effects/effects/waterfall.html">
 * ```
 *
 * ### Consuming effects
 *
 * Effects can be consumed via the `effects` property. For example:
 *
 * ```html
 * <app-header effects="waterfall"></app-header>
 * ```
 *
 * ### Creating scroll effects
 *
 * You may want to create a custom scroll effect if you need to modify the CSS of an element
 * based on the scroll position.
 *
 * A scroll effect definition is an object with `setUp()`, `tearDown()` and `run()` functions.
 *
 * To register the effect, you can use `Polymer.AppLayout.registerEffect(effectName, effectDef)`
 * For example, let's define an effect that resizes the header's logo:
 *
 * ```js
 * Polymer.AppLayout.registerEffect('resizable-logo', {
 *   setUp: function(config) {
 *     // the effect's config is passed to the setUp.
 *     this._fxResizeLogo = { logo: Polymer.dom(this).querySelector('[logo]') };
 *   },
 *
 *   run: function(progress) {
 *      // the progress of the effect
 *      this.transform('scale3d(' + progress + ', '+ progress +', 1)',  this._fxResizeLogo.logo);
 *   },
 *
 *   tearDown: function() {
 *      // clean up and reset of states
 *      delete this._fxResizeLogo;
 *   }
 * });
 * ```
 * Now, you can consume the effect:
 *
 * ```html
 * <app-header id="appHeader" effects="resizable-logo">
 *   <img logo src="logo.svg">
 * </app-header>
 * ```
 *
 * ### Imperative API
 *
 * ```js
 * var logoEffect = appHeader.createEffect('resizable-logo', effectConfig);
 * // run the effect: logoEffect.run(progress);
 * // tear down the effect: logoEffect.tearDown();
 * ```
 *
 * ### Configuring effects
 *
 * For effects installed via the `effects` property, their configuration can be set
 * via the `effectsConfig` property. For example:
 *
 * ```html
 * <app-header effects="waterfall"
 *   effects-config='{"waterfall": {"startsAt": 0, "endsAt": 0.5}}'>
 * </app-header>
 * ```
 *
 * All effects have a `startsAt` and `endsAt` config property. They specify at what
 * point the effect should start and end. This value goes from 0 to 1 inclusive.
 *
 * @polymerBehavior
 */
Polymer.AppScrollEffectsBehavior = [Polymer.IronScrollTargetBehavior, {

  properties: {

    /**
     * A space-separated list of the effects names that will be triggered when the user scrolls.
     * e.g. `waterfall parallax-background` installs the `waterfall` and `parallax-background`.
     */
    effects: {
      type: String
    },

    /**
     * An object that configurates the effects installed via the `effects` property. e.g.
     * ```js
     *  element.effectsConfig = {
     *   "blend-background": {
     *     "startsAt": 0.5
     *   }
     * };
     * ```
     * Every effect has at least two config properties: `startsAt` and `endsAt`.
     * These properties indicate when the event should start and end respectively
     * and relative to the overall element progress. So for example, if `blend-background`
     * starts at `0.5`, the effect will only start once the current element reaches 0.5
     * of its progress. In this context, the progress is a value in the range of `[0, 1]`
     * that indicates where this element is on the screen relative to the viewport.
     */
    effectsConfig: {
      type: Object,
      value: function value() {
        return {};
      }
    },

    /**
     * Disables CSS transitions and scroll effects on the element.
     */
    disabled: {
      type: Boolean,
      reflectToAttribute: true,
      value: false
    },

    /**
     * Allows to set a `scrollTop` threshold. When greater than 0, `thresholdTriggered`
     * is true only when the scroll target's `scrollTop` has reached this value.
     *
     * For example, if `threshold = 100`, `thresholdTriggered` is true when the `scrollTop`
     * is at least `100`.
     */
    threshold: {
      type: Number,
      value: 0
    },

    /**
     * True if the `scrollTop` threshold (set in `scrollTopThreshold`) has
     * been reached.
     */
    thresholdTriggered: {
      type: Boolean,
      notify: true,
      readOnly: true,
      reflectToAttribute: true
    }
  },

  observers: ['_effectsChanged(effects, effectsConfig, isAttached)'],

  /**
   * Updates the scroll state. This method should be overridden
   * by the consumer of this behavior.
   *
   * @method _updateScrollState
   */
  _updateScrollState: function _updateScrollState() {},

  /**
   * Returns true if the current element is on the screen.
   * That is, visible in the current viewport. This method should be
   * overridden by the consumer of this behavior.
   *
   * @method isOnScreen
   * @return {boolean}
   */
  isOnScreen: function isOnScreen() {
    return false;
  },

  /**
   * Returns true if there's content below the current element. This method
   * should be overridden by the consumer of this behavior.
   *
   * @method isContentBelow
   * @return {boolean}
   */
  isContentBelow: function isContentBelow() {
    return false;
  },

  /**
   * List of effects handlers that will take place during scroll.
   *
   * @type {Array<Function>}
   */
  _effectsRunFn: null,

  /**
   * List of the effects definitions installed via the `effects` property.
   *
   * @type {Array<Object>}
   */
  _effects: null,

  /**
   * The clamped value of `_scrollTop`.
   * @type number
   */
  get _clampedScrollTop() {
    return Math.max(0, this._scrollTop);
  },

  detached: function detached() {
    this._tearDownEffects();
  },

  /**
   * Creates an effect object from an effect's name that can be used to run
   * effects programmatically.
   *
   * @method createEffect
   * @param {string} effectName The effect's name registered via `Polymer.AppLayout.registerEffect`.
   * @param {Object=} effectConfig The effect config object. (Optional)
   * @return {Object} An effect object with the following functions:
   *
   *  * `effect.setUp()`, Sets up the requirements for the effect.
   *       This function is called automatically before the `effect` function returns.
   *  * `effect.run(progress, y)`, Runs the effect given a `progress`.
   *  * `effect.tearDown()`, Cleans up any DOM nodes or element references used by the effect.
   *
   * Example:
   * ```js
   * var parallax = element.createEffect('parallax-background');
   * // runs the effect
   * parallax.run(0.5, 0);
   * ```
   */
  createEffect: function createEffect(effectName, effectConfig) {
    var effectDef = Polymer.AppLayout._scrollEffects[effectName];
    if (!effectDef) {
      throw new ReferenceError(this._getUndefinedMsg(effectName));
    }
    var prop = this._boundEffect(effectDef, effectConfig || {});
    prop.setUp();
    return prop;
  },

  /**
   * Called when `effects` or `effectsConfig` changes.
   */
  _effectsChanged: function _effectsChanged(effects, effectsConfig, isAttached) {
    this._tearDownEffects();

    if (!effects || !isAttached) {
      return;
    }
    effects.split(' ').forEach(function (effectName) {
      var effectDef;
      if (effectName !== '') {
        if (effectDef = Polymer.AppLayout._scrollEffects[effectName]) {
          this._effects.push(this._boundEffect(effectDef, effectsConfig[effectName]));
        } else {
          console.warn(this._getUndefinedMsg(effectName));
        }
      }
    }, this);

    this._setUpEffect();
  },

  /**
   * Forces layout
   */
  _layoutIfDirty: function _layoutIfDirty() {
    return this.offsetWidth;
  },

  /**
   * Returns an effect object bound to the current context.
   *
   * @param {Object} effectDef
   * @param {Object=} effectsConfig The effect config object if the effect accepts config values. (Optional)
   */
  _boundEffect: function _boundEffect(effectDef, effectsConfig) {
    effectsConfig = effectsConfig || {};
    var startsAt = parseFloat(effectsConfig.startsAt || 0);
    var endsAt = parseFloat(effectsConfig.endsAt || 1);
    var deltaS = endsAt - startsAt;
    var noop = function noop() {};
    // fast path if possible
    var runFn = startsAt === 0 && endsAt === 1 ? effectDef.run : function (progress, y) {
      effectDef.run.call(this, Math.max(0, (progress - startsAt) / deltaS), y);
    };
    return {
      setUp: effectDef.setUp ? effectDef.setUp.bind(this, effectsConfig) : noop,
      run: effectDef.run ? runFn.bind(this) : noop,
      tearDown: effectDef.tearDown ? effectDef.tearDown.bind(this) : noop
    };
  },

  /**
   * Sets up the effects.
   */
  _setUpEffect: function _setUpEffect() {
    if (this.isAttached && this._effects) {
      this._effectsRunFn = [];
      this._effects.forEach(function (effectDef) {
        // install the effect only if no error was reported
        if (effectDef.setUp() !== false) {
          this._effectsRunFn.push(effectDef.run);
        }
      }, this);
    }
  },

  /**
   * Tears down the effects.
   */
  _tearDownEffects: function _tearDownEffects() {
    if (this._effects) {
      this._effects.forEach(function (effectDef) {
        effectDef.tearDown();
      });
    }
    this._effectsRunFn = [];
    this._effects = [];
  },

  /**
   * Runs the effects.
   *
   * @param {number} p The progress
   * @param {number} y The top position of the current element relative to the viewport.
   */
  _runEffects: function _runEffects(p, y) {
    if (this._effectsRunFn) {
      this._effectsRunFn.forEach(function (run) {
        run(p, y);
      });
    }
  },

  /**
   * Overrides the `_scrollHandler`.
   */
  _scrollHandler: function _scrollHandler() {
    if (!this.disabled) {
      var scrollTop = this._clampedScrollTop;
      this._updateScrollState(scrollTop);
      if (this.threshold > 0) {
        this._setThresholdTriggered(scrollTop >= this.threshold);
      }
    }
  },

  /**
   * Override this method to return a reference to a node in the local DOM.
   * The node is consumed by a scroll effect.
   *
   * @param {string} id The id for the node.
   */
  _getDOMRef: function _getDOMRef(id) {
    console.warn('_getDOMRef', '`' + id + '` is undefined');
  },

  _getUndefinedMsg: function _getUndefinedMsg(effectName) {
    return 'Scroll effect `' + effectName + '` is undefined. ' + 'Did you forget to import app-layout/app-scroll-effects/effects/' + effectName + '.html ?';
  }

}];

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

var RegisterHtmlTemplate = __webpack_require__(2);

RegisterHtmlTemplate.toBody("<custom-style> <style is=custom-style>html{--layout:{display:-ms-flexbox;display:-webkit-flex;display:flex};--layout-inline:{display:-ms-inline-flexbox;display:-webkit-inline-flex;display:inline-flex};--layout-horizontal:{@apply --layout;-ms-flex-direction:row;-webkit-flex-direction:row;flex-direction:row};--layout-horizontal-reverse:{@apply --layout;-ms-flex-direction:row-reverse;-webkit-flex-direction:row-reverse;flex-direction:row-reverse};--layout-vertical:{@apply --layout;-ms-flex-direction:column;-webkit-flex-direction:column;flex-direction:column};--layout-vertical-reverse:{@apply --layout;-ms-flex-direction:column-reverse;-webkit-flex-direction:column-reverse;flex-direction:column-reverse};--layout-wrap:{-ms-flex-wrap:wrap;-webkit-flex-wrap:wrap;flex-wrap:wrap};--layout-wrap-reverse:{-ms-flex-wrap:wrap-reverse;-webkit-flex-wrap:wrap-reverse;flex-wrap:wrap-reverse};--layout-flex-auto:{-ms-flex:1 1 auto;-webkit-flex:1 1 auto;flex:1 1 auto};--layout-flex-none:{-ms-flex:none;-webkit-flex:none;flex:none};--layout-flex:{-ms-flex:1 1 .000000001px;-webkit-flex:1;flex:1;-webkit-flex-basis:.000000001px;flex-basis:.000000001px};--layout-flex-2:{-ms-flex:2;-webkit-flex:2;flex:2};--layout-flex-3:{-ms-flex:3;-webkit-flex:3;flex:3};--layout-flex-4:{-ms-flex:4;-webkit-flex:4;flex:4};--layout-flex-5:{-ms-flex:5;-webkit-flex:5;flex:5};--layout-flex-6:{-ms-flex:6;-webkit-flex:6;flex:6};--layout-flex-7:{-ms-flex:7;-webkit-flex:7;flex:7};--layout-flex-8:{-ms-flex:8;-webkit-flex:8;flex:8};--layout-flex-9:{-ms-flex:9;-webkit-flex:9;flex:9};--layout-flex-10:{-ms-flex:10;-webkit-flex:10;flex:10};--layout-flex-11:{-ms-flex:11;-webkit-flex:11;flex:11};--layout-flex-12:{-ms-flex:12;-webkit-flex:12;flex:12};--layout-start:{-ms-flex-align:start;-webkit-align-items:flex-start;align-items:flex-start};--layout-center:{-ms-flex-align:center;-webkit-align-items:center;align-items:center};--layout-end:{-ms-flex-align:end;-webkit-align-items:flex-end;align-items:flex-end};--layout-baseline:{-ms-flex-align:baseline;-webkit-align-items:baseline;align-items:baseline};--layout-start-justified:{-ms-flex-pack:start;-webkit-justify-content:flex-start;justify-content:flex-start};--layout-center-justified:{-ms-flex-pack:center;-webkit-justify-content:center;justify-content:center};--layout-end-justified:{-ms-flex-pack:end;-webkit-justify-content:flex-end;justify-content:flex-end};--layout-around-justified:{-ms-flex-pack:distribute;-webkit-justify-content:space-around;justify-content:space-around};--layout-justified:{-ms-flex-pack:justify;-webkit-justify-content:space-between;justify-content:space-between};--layout-center-center:{@apply --layout-center;@apply --layout-center-justified;};--layout-self-start:{-ms-align-self:flex-start;-webkit-align-self:flex-start;align-self:flex-start};--layout-self-center:{-ms-align-self:center;-webkit-align-self:center;align-self:center};--layout-self-end:{-ms-align-self:flex-end;-webkit-align-self:flex-end;align-self:flex-end};--layout-self-stretch:{-ms-align-self:stretch;-webkit-align-self:stretch;align-self:stretch};--layout-self-baseline:{-ms-align-self:baseline;-webkit-align-self:baseline;align-self:baseline};--layout-start-aligned:{-ms-flex-line-pack:start;-ms-align-content:flex-start;-webkit-align-content:flex-start;align-content:flex-start};--layout-end-aligned:{-ms-flex-line-pack:end;-ms-align-content:flex-end;-webkit-align-content:flex-end;align-content:flex-end};--layout-center-aligned:{-ms-flex-line-pack:center;-ms-align-content:center;-webkit-align-content:center;align-content:center};--layout-between-aligned:{-ms-flex-line-pack:justify;-ms-align-content:space-between;-webkit-align-content:space-between;align-content:space-between};--layout-around-aligned:{-ms-flex-line-pack:distribute;-ms-align-content:space-around;-webkit-align-content:space-around;align-content:space-around};--layout-block:{display:block};--layout-invisible:{visibility:hidden!important};--layout-relative:{position:relative};--layout-fit:{position:absolute;top:0;right:0;bottom:0;left:0};--layout-scroll:{-webkit-overflow-scrolling:touch;overflow:auto};--layout-fullbleed:{margin:0;height:100vh};--layout-fixed-top:{position:fixed;top:0;left:0;right:0};--layout-fixed-right:{position:fixed;top:0;right:0;bottom:0};--layout-fixed-bottom:{position:fixed;right:0;bottom:0;left:0};--layout-fixed-left:{position:fixed;top:0;bottom:0;left:0};}</style> </custom-style>");

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(19);

(function () {
  'use strict';

  /**
   * Base class that provides the core API for Polymer's meta-programming
   * features including template stamping, data-binding, attribute deserialization,
   * and property change observation.
   *
   * @customElement
   * @polymer
   * @memberof Polymer
   * @constructor
   * @implements {Polymer_ElementMixin}
   * @extends HTMLElement
   * @appliesMixin Polymer.ElementMixin
   * @summary Custom element base class that provides the core API for Polymer's
   *   key meta-programming features including template stamping, data-binding,
   *   attribute deserialization, and property change observation
   */

  var Element = Polymer.ElementMixin(HTMLElement);
  /**
   * @constructor
   * @implements {Polymer_ElementMixin}
   * @extends {HTMLElement}
   */
  Polymer.Element = Element;
})();

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(1);

(function () {
  'use strict';

  var CSS_URL_RX = /(url\()([^)]*)(\))/g;
  var ABS_URL = /(^\/)|(^#)|(^[\w-\d]*:)/;
  var workingURL = void 0;
  var resolveDoc = void 0;
  /**
   * Resolves the given URL against the provided `baseUri'.
   *
   * @memberof Polymer.ResolveUrl
   * @param {string} url Input URL to resolve
   * @param {?string=} baseURI Base URI to resolve the URL against
   * @return {string} resolved URL
   */
  function resolveUrl(url, baseURI) {
    if (url && ABS_URL.test(url)) {
      return url;
    }
    // Lazy feature detection.
    if (workingURL === undefined) {
      workingURL = false;
      try {
        var u = new URL('b', 'http://a');
        u.pathname = 'c%20d';
        workingURL = u.href === 'http://a/c%20d';
      } catch (e) {
        // silently fail
      }
    }
    if (!baseURI) {
      baseURI = document.baseURI || window.location.href;
    }
    if (workingURL) {
      return new URL(url, baseURI).href;
    }
    // Fallback to creating an anchor into a disconnected document.
    if (!resolveDoc) {
      resolveDoc = document.implementation.createHTMLDocument('temp');
      resolveDoc.base = resolveDoc.createElement('base');
      resolveDoc.head.appendChild(resolveDoc.base);
      resolveDoc.anchor = resolveDoc.createElement('a');
      resolveDoc.body.appendChild(resolveDoc.anchor);
    }
    resolveDoc.base.href = baseURI;
    resolveDoc.anchor.href = url;
    return resolveDoc.anchor.href || url;
  }

  /**
   * Resolves any relative URL's in the given CSS text against the provided
   * `ownerDocument`'s `baseURI`.
   *
   * @memberof Polymer.ResolveUrl
   * @param {string} cssText CSS text to process
   * @param {string} baseURI Base URI to resolve the URL against
   * @return {string} Processed CSS text with resolved URL's
   */
  function resolveCss(cssText, baseURI) {
    return cssText.replace(CSS_URL_RX, function (m, pre, url, post) {
      return pre + '\'' + resolveUrl(url.replace(/["']/g, ''), baseURI) + '\'' + post;
    });
  }

  /**
   * Returns a path from a given `url`. The path includes the trailing
   * `/` from the url.
   *
   * @memberof Polymer.ResolveUrl
   * @param {string} url Input URL to transform
   * @return {string} resolved path
   */
  function pathFromUrl(url) {
    return url.substring(0, url.lastIndexOf('/') + 1);
  }

  /**
   * Module with utilities for resolving relative URL's.
   *
   * @namespace
   * @memberof Polymer
   * @summary Module with utilities for resolving relative URL's.
   */
  Polymer.ResolveUrl = {
    resolveCss: resolveCss,
    resolveUrl: resolveUrl,
    pathFromUrl: pathFromUrl
  };
})();

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(1);

(function () {

  'use strict';

  /** @typedef {{run: function(function(), number=):number, cancel: function(number)}} */

  var AsyncInterface = void 0; // eslint-disable-line no-unused-vars

  // Microtask implemented using Mutation Observer
  var microtaskCurrHandle = 0;
  var microtaskLastHandle = 0;
  var microtaskCallbacks = [];
  var microtaskNodeContent = 0;
  var microtaskNode = document.createTextNode('');
  new window.MutationObserver(microtaskFlush).observe(microtaskNode, { characterData: true });

  function microtaskFlush() {
    var len = microtaskCallbacks.length;
    for (var i = 0; i < len; i++) {
      var cb = microtaskCallbacks[i];
      if (cb) {
        try {
          cb();
        } catch (e) {
          setTimeout(function () {
            throw e;
          });
        }
      }
    }
    microtaskCallbacks.splice(0, len);
    microtaskLastHandle += len;
  }

  /**
   * Module that provides a number of strategies for enqueuing asynchronous
   * tasks.  Each sub-module provides a standard `run(fn)` interface that returns a
   * handle, and a `cancel(handle)` interface for canceling async tasks before
   * they run.
   *
   * @namespace
   * @memberof Polymer
   * @summary Module that provides a number of strategies for enqueuing asynchronous
   * tasks.
   */
  Polymer.Async = {

    /**
     * Async interface wrapper around `setTimeout`.
     *
     * @namespace
     * @memberof Polymer.Async
     * @summary Async interface wrapper around `setTimeout`.
     */
    timeOut: {
      /**
       * Returns a sub-module with the async interface providing the provided
       * delay.
       *
       * @memberof Polymer.Async.timeOut
       * @param {number} delay Time to wait before calling callbacks in ms
       * @return {AsyncInterface} An async timeout interface
       */
      after: function after(delay) {
        return {
          run: function run(fn) {
            return setTimeout(fn, delay);
          },

          cancel: window.clearTimeout.bind(window)
        };
      },

      /**
       * Enqueues a function called in the next task.
       *
       * @memberof Polymer.Async.timeOut
       * @param {Function} fn Callback to run
       * @return {number} Handle used for canceling task
       */
      run: window.setTimeout.bind(window),
      /**
       * Cancels a previously enqueued `timeOut` callback.
       *
       * @memberof Polymer.Async.timeOut
       * @param {number} handle Handle returned from `run` of callback to cancel
       */
      cancel: window.clearTimeout.bind(window)
    },

    /**
     * Async interface wrapper around `requestAnimationFrame`.
     *
     * @namespace
     * @memberof Polymer.Async
     * @summary Async interface wrapper around `requestAnimationFrame`.
     */
    animationFrame: {
      /**
       * Enqueues a function called at `requestAnimationFrame` timing.
       *
       * @memberof Polymer.Async.animationFrame
       * @param {Function} fn Callback to run
       * @return {number} Handle used for canceling task
       */
      run: window.requestAnimationFrame.bind(window),
      /**
       * Cancels a previously enqueued `animationFrame` callback.
       *
       * @memberof Polymer.Async.timeOut
       * @param {number} handle Handle returned from `run` of callback to cancel
       */
      cancel: window.cancelAnimationFrame.bind(window)
    },

    /**
     * Async interface wrapper around `requestIdleCallback`.  Falls back to
     * `setTimeout` on browsers that do not support `requestIdleCallback`.
     *
     * @namespace
     * @memberof Polymer.Async
     * @summary Async interface wrapper around `requestIdleCallback`.
     */
    idlePeriod: {
      /**
       * Enqueues a function called at `requestIdleCallback` timing.
       *
       * @memberof Polymer.Async.idlePeriod
       * @param {function(IdleDeadline)} fn Callback to run
       * @return {number} Handle used for canceling task
       */
      run: function run(fn) {
        return window.requestIdleCallback ? window.requestIdleCallback(fn) : window.setTimeout(fn, 16);
      },

      /**
       * Cancels a previously enqueued `idlePeriod` callback.
       *
       * @memberof Polymer.Async.idlePeriod
       * @param {number} handle Handle returned from `run` of callback to cancel
       */
      cancel: function cancel(handle) {
        window.cancelIdleCallback ? window.cancelIdleCallback(handle) : window.clearTimeout(handle);
      }
    },

    /**
     * Async interface for enqueueing callbacks that run at microtask timing.
     *
     * Note that microtask timing is achieved via a single `MutationObserver`,
     * and thus callbacks enqueued with this API will all run in a single
     * batch, and not interleaved with other microtasks such as promises.
     * Promises are avoided as an implementation choice for the time being
     * due to Safari bugs that cause Promises to lack microtask guarantees.
     *
     * @namespace
     * @memberof Polymer.Async
     * @summary Async interface for enqueueing callbacks that run at microtask
     *   timing.
     */
    microTask: {

      /**
       * Enqueues a function called at microtask timing.
       *
       * @memberof Polymer.Async.microTask
       * @param {Function} callback Callback to run
       * @return {number} Handle used for canceling task
       */
      run: function run(callback) {
        microtaskNode.textContent = microtaskNodeContent++;
        microtaskCallbacks.push(callback);
        return microtaskCurrHandle++;
      },


      /**
       * Cancels a previously enqueued `microTask` callback.
       *
       * @memberof Polymer.Async.microTask
       * @param {number} handle Handle returned from `run` of callback to cancel
       */
      cancel: function cancel(handle) {
        var idx = handle - microtaskLastHandle;
        if (idx >= 0) {
          if (!microtaskCallbacks[idx]) {
            throw new Error('invalid async handle: ' + handle);
          }
          microtaskCallbacks[idx] = null;
        }
      }
    }
  };
})();

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

__webpack_require__(3);

(function () {
  'use strict';

  // Common implementation for mixin & behavior

  function mutablePropertyChange(inst, property, value, old, mutableData) {
    var isObject = void 0;
    if (mutableData) {
      isObject = (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && value !== null;
      // Pull `old` for Objects from temp cache, but treat `null` as a primitive
      if (isObject) {
        old = inst.__dataTemp[property];
      }
    }
    // Strict equality check, but return false for NaN===NaN
    var shouldChange = old !== value && (old === old || value === value);
    // Objects are stored in temporary cache (cleared at end of
    // turn), which is used for dirty-checking
    if (isObject && shouldChange) {
      inst.__dataTemp[property] = value;
    }
    return shouldChange;
  }

  /**
   * Element class mixin to skip strict dirty-checking for objects and arrays
   * (always consider them to be "dirty"), for use on elements utilizing
   * `Polymer.PropertyEffects`
   *
   * By default, `Polymer.PropertyEffects` performs strict dirty checking on
   * objects, which means that any deep modifications to an object or array will
   * not be propagated unless "immutable" data patterns are used (i.e. all object
   * references from the root to the mutation were changed).
   *
   * Polymer also provides a proprietary data mutation and path notification API
   * (e.g. `notifyPath`, `set`, and array mutation API's) that allow efficient
   * mutation and notification of deep changes in an object graph to all elements
   * bound to the same object graph.
   *
   * In cases where neither immutable patterns nor the data mutation API can be
   * used, applying this mixin will cause Polymer to skip dirty checking for
   * objects and arrays (always consider them to be "dirty").  This allows a
   * user to make a deep modification to a bound object graph, and then either
   * simply re-set the object (e.g. `this.items = this.items`) or call `notifyPath`
   * (e.g. `this.notifyPath('items')`) to update the tree.  Note that all
   * elements that wish to be updated based on deep mutations must apply this
   * mixin or otherwise skip strict dirty checking for objects/arrays.
   *
   * In order to make the dirty check strategy configurable, see
   * `Polymer.OptionalMutableData`.
   *
   * Note, the performance characteristics of propagating large object graphs
   * will be worse as opposed to using strict dirty checking with immutable
   * patterns or Polymer's path notification API.
   *
   * @mixinFunction
   * @polymer
   * @memberof Polymer
   * @summary Element class mixin to skip strict dirty-checking for objects
   *   and arrays
   */
  Polymer.MutableData = Polymer.dedupingMixin(function (superClass) {

    /**
     * @polymer
     * @mixinClass
     * @implements {Polymer_MutableData}
     */
    var MutableData = function (_superClass) {
      _inherits(MutableData, _superClass);

      function MutableData() {
        _classCallCheck(this, MutableData);

        return _possibleConstructorReturn(this, (MutableData.__proto__ || Object.getPrototypeOf(MutableData)).apply(this, arguments));
      }

      _createClass(MutableData, [{
        key: '_shouldPropertyChange',

        /**
         * Overrides `Polymer.PropertyEffects` to provide option for skipping
         * strict equality checking for Objects and Arrays.
         *
         * This method pulls the value to dirty check against from the `__dataTemp`
         * cache (rather than the normal `__data` cache) for Objects.  Since the temp
         * cache is cleared at the end of a turn, this implementation allows
         * side-effects of deep object changes to be processed by re-setting the
         * same object (using the temp cache as an in-turn backstop to prevent
         * cycles due to 2-way notification).
         *
         * @param {string} property Property name
         * @param {*} value New property value
         * @param {*} old Previous property value
         * @return {boolean} Whether the property should be considered a change
         * @protected
         */
        value: function _shouldPropertyChange(property, value, old) {
          return mutablePropertyChange(this, property, value, old, true);
        }
      }]);

      return MutableData;
    }(superClass);
    /** @type {boolean} */


    MutableData.prototype.mutableData = false;

    return MutableData;
  });

  /**
   * Element class mixin to add the optional ability to skip strict
   * dirty-checking for objects and arrays (always consider them to be
   * "dirty") by setting a `mutable-data` attribute on an element instance.
   *
   * By default, `Polymer.PropertyEffects` performs strict dirty checking on
   * objects, which means that any deep modifications to an object or array will
   * not be propagated unless "immutable" data patterns are used (i.e. all object
   * references from the root to the mutation were changed).
   *
   * Polymer also provides a proprietary data mutation and path notification API
   * (e.g. `notifyPath`, `set`, and array mutation API's) that allow efficient
   * mutation and notification of deep changes in an object graph to all elements
   * bound to the same object graph.
   *
   * In cases where neither immutable patterns nor the data mutation API can be
   * used, applying this mixin will allow Polymer to skip dirty checking for
   * objects and arrays (always consider them to be "dirty").  This allows a
   * user to make a deep modification to a bound object graph, and then either
   * simply re-set the object (e.g. `this.items = this.items`) or call `notifyPath`
   * (e.g. `this.notifyPath('items')`) to update the tree.  Note that all
   * elements that wish to be updated based on deep mutations must apply this
   * mixin or otherwise skip strict dirty checking for objects/arrays.
   *
   * While this mixin adds the ability to forgo Object/Array dirty checking,
   * the `mutableData` flag defaults to false and must be set on the instance.
   *
   * Note, the performance characteristics of propagating large object graphs
   * will be worse by relying on `mutableData: true` as opposed to using
   * strict dirty checking with immutable patterns or Polymer's path notification
   * API.
   *
   * @mixinFunction
   * @polymer
   * @memberof Polymer
   * @summary Element class mixin to optionally skip strict dirty-checking
   *   for objects and arrays
   */
  Polymer.OptionalMutableData = Polymer.dedupingMixin(function (superClass) {

    /**
     * @mixinClass
     * @polymer
     * @implements {Polymer_OptionalMutableData}
     */
    var OptionalMutableData = function (_superClass2) {
      _inherits(OptionalMutableData, _superClass2);

      function OptionalMutableData() {
        _classCallCheck(this, OptionalMutableData);

        return _possibleConstructorReturn(this, (OptionalMutableData.__proto__ || Object.getPrototypeOf(OptionalMutableData)).apply(this, arguments));
      }

      _createClass(OptionalMutableData, [{
        key: '_shouldPropertyChange',


        /**
         * Overrides `Polymer.PropertyEffects` to provide option for skipping
         * strict equality checking for Objects and Arrays.
         *
         * When `this.mutableData` is true on this instance, this method
         * pulls the value to dirty check against from the `__dataTemp` cache
         * (rather than the normal `__data` cache) for Objects.  Since the temp
         * cache is cleared at the end of a turn, this implementation allows
         * side-effects of deep object changes to be processed by re-setting the
         * same object (using the temp cache as an in-turn backstop to prevent
         * cycles due to 2-way notification).
         *
         * @param {string} property Property name
         * @param {*} value New property value
         * @param {*} old Previous property value
         * @return {boolean} Whether the property should be considered a change
         * @protected
         */
        value: function _shouldPropertyChange(property, value, old) {
          return mutablePropertyChange(this, property, value, old, this.mutableData);
        }
      }], [{
        key: 'properties',
        get: function get() {
          return {
            /**
             * Instance-level flag for configuring the dirty-checking strategy
             * for this element.  When true, Objects and Arrays will skip dirty
             * checking, otherwise strict equality checking will be used.
             */
            mutableData: Boolean
          };
        }
      }]);

      return OptionalMutableData;
    }(superClass);

    return OptionalMutableData;
  });

  // Export for use by legacy behavior
  Polymer.MutableData._mutablePropertyChange = mutablePropertyChange;
})();

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(1);

(function () {
  'use strict';

  var caseMap = {};
  var DASH_TO_CAMEL = /-[a-z]/g;
  var CAMEL_TO_DASH = /([A-Z])/g;

  /**
   * Module with utilities for converting between "dash-case" and "camelCase"
   * identifiers.
   *
   * @namespace
   * @memberof Polymer
   * @summary Module that provides utilities for converting between "dash-case"
   *   and "camelCase".
   */
  var CaseMap = {

    /**
     * Converts "dash-case" identifier (e.g. `foo-bar-baz`) to "camelCase"
     * (e.g. `fooBarBaz`).
     *
     * @memberof Polymer.CaseMap
     * @param {string} dash Dash-case identifier
     * @return {string} Camel-case representation of the identifier
     */
    dashToCamelCase: function dashToCamelCase(dash) {
      return caseMap[dash] || (caseMap[dash] = dash.indexOf('-') < 0 ? dash : dash.replace(DASH_TO_CAMEL, function (m) {
        return m[1].toUpperCase();
      }));
    },


    /**
     * Converts "camelCase" identifier (e.g. `fooBarBaz`) to "dash-case"
     * (e.g. `foo-bar-baz`).
     *
     * @memberof Polymer.CaseMap
     * @param {string} camel Camel-case identifier
     * @return {string} Dash-case representation of the identifier
     */
    camelToDashCase: function camelToDashCase(camel) {
      return caseMap[camel] || (caseMap[camel] = camel.replace(CAMEL_TO_DASH, '-$1').toLowerCase());
    }
  };

  Polymer.CaseMap = CaseMap;
})();

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

__webpack_require__(1);

__webpack_require__(3);

__webpack_require__(41);

__webpack_require__(10);

__webpack_require__(42);

__webpack_require__(43);

(function () {

  'use strict';

  /** @const {Object} */

  var CaseMap = Polymer.CaseMap;

  // Monotonically increasing unique ID used for de-duping effects triggered
  // from multiple properties in the same turn
  var dedupeId = 0;

  /**
   * Property effect types; effects are stored on the prototype using these keys
   * @enum {string}
   */
  var TYPES = {
    COMPUTE: '__computeEffects',
    REFLECT: '__reflectEffects',
    NOTIFY: '__notifyEffects',
    PROPAGATE: '__propagateEffects',
    OBSERVE: '__observeEffects',
    READ_ONLY: '__readOnly'

    /**
     * @typedef {{
     * name: (string | undefined),
     * structured: (boolean | undefined),
     * wildcard: (boolean | undefined)
     * }}
     */
  };var DataTrigger = void 0; //eslint-disable-line no-unused-vars

  /**
   * @typedef {{
   * info: ?,
   * trigger: (!DataTrigger | undefined),
   * fn: (!Function | undefined)
   * }}
   */
  var DataEffect = void 0; //eslint-disable-line no-unused-vars

  var PropertyEffectsType = void 0; //eslint-disable-line no-unused-vars

  /**
   * Ensures that the model has an own-property map of effects for the given type.
   * The model may be a prototype or an instance.
   *
   * Property effects are stored as arrays of effects by property in a map,
   * by named type on the model. e.g.
   *
   *   __computeEffects: {
   *     foo: [ ... ],
   *     bar: [ ... ]
   *   }
   *
   * If the model does not yet have an effect map for the type, one is created
   * and returned.  If it does, but it is not an own property (i.e. the
   * prototype had effects), the the map is deeply cloned and the copy is
   * set on the model and returned, ready for new effects to be added.
   *
   * @param {Object} model Prototype or instance
   * @param {string} type Property effect type
   * @return {Object} The own-property map of effects for the given type
   * @private
   */
  function ensureOwnEffectMap(model, type) {
    var effects = model[type];
    if (!effects) {
      effects = model[type] = {};
    } else if (!model.hasOwnProperty(type)) {
      effects = model[type] = Object.create(model[type]);
      for (var p in effects) {
        var protoFx = effects[p];
        var instFx = effects[p] = Array(protoFx.length);
        for (var i = 0; i < protoFx.length; i++) {
          instFx[i] = protoFx[i];
        }
      }
    }
    return effects;
  }

  // -- effects ----------------------------------------------

  /**
   * Runs all effects of a given type for the given set of property changes
   * on an instance.
   *
   * @param {!PropertyEffectsType} inst The instance with effects to run
   * @param {Object} effects Object map of property-to-Array of effects
   * @param {Object} props Bag of current property changes
   * @param {Object=} oldProps Bag of previous values for changed properties
   * @param {boolean=} hasPaths True with `props` contains one or more paths
   * @param {*=} extraArgs Additional metadata to pass to effect function
   * @return {boolean} True if an effect ran for this property
   * @private
   */
  function runEffects(inst, effects, props, oldProps, hasPaths, extraArgs) {
    if (effects) {
      var ran = false;
      var id = dedupeId++;
      for (var prop in props) {
        if (runEffectsForProperty(inst, effects, id, prop, props, oldProps, hasPaths, extraArgs)) {
          ran = true;
        }
      }
      return ran;
    }
    return false;
  }

  /**
   * Runs a list of effects for a given property.
   *
   * @param {!PropertyEffectsType} inst The instance with effects to run
   * @param {Object} effects Object map of property-to-Array of effects
   * @param {number} dedupeId Counter used for de-duping effects
   * @param {string} prop Name of changed property
   * @param {*} props Changed properties
   * @param {*} oldProps Old properties
   * @param {boolean=} hasPaths True with `props` contains one or more paths
   * @param {*=} extraArgs Additional metadata to pass to effect function
   * @return {boolean} True if an effect ran for this property
   * @private
   */
  function runEffectsForProperty(inst, effects, dedupeId, prop, props, oldProps, hasPaths, extraArgs) {
    var ran = false;
    var rootProperty = hasPaths ? Polymer.Path.root(prop) : prop;
    var fxs = effects[rootProperty];
    if (fxs) {
      for (var i = 0, l = fxs.length, fx; i < l && (fx = fxs[i]); i++) {
        if ((!fx.info || fx.info.lastRun !== dedupeId) && (!hasPaths || pathMatchesTrigger(prop, fx.trigger))) {
          if (fx.info) {
            fx.info.lastRun = dedupeId;
          }
          fx.fn(inst, prop, props, oldProps, fx.info, hasPaths, extraArgs);
          ran = true;
        }
      }
    }
    return ran;
  }

  /**
   * Determines whether a property/path that has changed matches the trigger
   * criteria for an effect.  A trigger is a descriptor with the following
   * structure, which matches the descriptors returned from `parseArg`.
   * e.g. for `foo.bar.*`:
   * ```
   * trigger: {
   *   name: 'a.b',
   *   structured: true,
   *   wildcard: true
   * }
   * ```
   * If no trigger is given, the path is deemed to match.
   *
   * @param {string} path Path or property that changed
   * @param {DataTrigger} trigger Descriptor
   * @return {boolean} Whether the path matched the trigger
   */
  function pathMatchesTrigger(path, trigger) {
    if (trigger) {
      var triggerPath = trigger.name;
      return triggerPath == path || trigger.structured && Polymer.Path.isAncestor(triggerPath, path) || trigger.wildcard && Polymer.Path.isDescendant(triggerPath, path);
    } else {
      return true;
    }
  }

  /**
   * Implements the "observer" effect.
   *
   * Calls the method with `info.methodName` on the instance, passing the
   * new and old values.
   *
   * @param {!PropertyEffectsType} inst The instance the effect will be run on
   * @param {string} property Name of property
   * @param {Object} props Bag of current property changes
   * @param {Object} oldProps Bag of previous values for changed properties
   * @param {?} info Effect metadata
   * @private
   */
  function runObserverEffect(inst, property, props, oldProps, info) {
    var fn = inst[info.methodName];
    var changedProp = info.property;
    if (fn) {
      fn.call(inst, inst.__data[changedProp], oldProps[changedProp]);
    } else if (!info.dynamicFn) {
      console.warn('observer method `' + info.methodName + '` not defined');
    }
  }

  /**
   * Runs "notify" effects for a set of changed properties.
   *
   * This method differs from the generic `runEffects` method in that it
   * will dispatch path notification events in the case that the property
   * changed was a path and the root property for that path didn't have a
   * "notify" effect.  This is to maintain 1.0 behavior that did not require
   * `notify: true` to ensure object sub-property notifications were
   * sent.
   *
   * @param {!PropertyEffectsType} inst The instance with effects to run
   * @param {Object} notifyProps Bag of properties to notify
   * @param {Object} props Bag of current property changes
   * @param {Object} oldProps Bag of previous values for changed properties
   * @param {boolean} hasPaths True with `props` contains one or more paths
   * @private
   */
  function runNotifyEffects(inst, notifyProps, props, oldProps, hasPaths) {
    // Notify
    var fxs = inst[TYPES.NOTIFY];
    var notified = void 0;
    var id = dedupeId++;
    // Try normal notify effects; if none, fall back to try path notification
    for (var prop in notifyProps) {
      if (notifyProps[prop]) {
        if (fxs && runEffectsForProperty(inst, fxs, id, prop, props, oldProps, hasPaths)) {
          notified = true;
        } else if (hasPaths && notifyPath(inst, prop, props)) {
          notified = true;
        }
      }
    }
    // Flush host if we actually notified and host was batching
    // And the host has already initialized clients; this prevents
    // an issue with a host observing data changes before clients are ready.
    var host = void 0;
    if (notified && (host = inst.__dataHost) && host._invalidateProperties) {
      host._invalidateProperties();
    }
  }

  /**
   * Dispatches {property}-changed events with path information in the detail
   * object to indicate a sub-path of the property was changed.
   *
   * @param {!PropertyEffectsType} inst The element from which to fire the event
   * @param {string} path The path that was changed
   * @param {Object} props Bag of current property changes
   * @return {boolean} Returns true if the path was notified
   * @private
   */
  function notifyPath(inst, path, props) {
    var rootProperty = Polymer.Path.root(path);
    if (rootProperty !== path) {
      var eventName = Polymer.CaseMap.camelToDashCase(rootProperty) + '-changed';
      dispatchNotifyEvent(inst, eventName, props[path], path);
      return true;
    }
    return false;
  }

  /**
   * Dispatches {property}-changed events to indicate a property (or path)
   * changed.
   *
   * @param {!PropertyEffectsType} inst The element from which to fire the event
   * @param {string} eventName The name of the event to send ('{property}-changed')
   * @param {*} value The value of the changed property
   * @param {string | null | undefined} path If a sub-path of this property changed, the path
   *   that changed (optional).
   * @private
   * @suppress {invalidCasts}
   */
  function dispatchNotifyEvent(inst, eventName, value, path) {
    var detail = {
      value: value,
      queueProperty: true
    };
    if (path) {
      detail.path = path;
    }
    /** @type {!HTMLElement} */inst.dispatchEvent(new CustomEvent(eventName, { detail: detail }));
  }

  /**
   * Implements the "notify" effect.
   *
   * Dispatches a non-bubbling event named `info.eventName` on the instance
   * with a detail object containing the new `value`.
   *
   * @param {!PropertyEffectsType} inst The instance the effect will be run on
   * @param {string} property Name of property
   * @param {Object} props Bag of current property changes
   * @param {Object} oldProps Bag of previous values for changed properties
   * @param {?} info Effect metadata
   * @param {boolean} hasPaths True with `props` contains one or more paths
   * @private
   */
  function runNotifyEffect(inst, property, props, oldProps, info, hasPaths) {
    var rootProperty = hasPaths ? Polymer.Path.root(property) : property;
    var path = rootProperty != property ? property : null;
    var value = path ? Polymer.Path.get(inst, path) : inst.__data[property];
    if (path && value === undefined) {
      value = props[property]; // specifically for .splices
    }
    dispatchNotifyEvent(inst, info.eventName, value, path);
  }

  /**
   * Handler function for 2-way notification events. Receives context
   * information captured in the `addNotifyListener` closure from the
   * `__notifyListeners` metadata.
   *
   * Sets the value of the notified property to the host property or path.  If
   * the event contained path information, translate that path to the host
   * scope's name for that path first.
   *
   * @param {CustomEvent} event Notification event (e.g. '<property>-changed')
   * @param {!PropertyEffectsType} inst Host element instance handling the notification event
   * @param {string} fromProp Child element property that was bound
   * @param {string} toPath Host property/path that was bound
   * @param {boolean} negate Whether the binding was negated
   * @private
   */
  function handleNotification(event, inst, fromProp, toPath, negate) {
    var value = void 0;
    var detail = /** @type {Object} */event.detail;
    var fromPath = detail && detail.path;
    if (fromPath) {
      toPath = Polymer.Path.translate(fromProp, toPath, fromPath);
      value = detail && detail.value;
    } else {
      value = event.target[fromProp];
    }
    value = negate ? !value : value;
    if (!inst[TYPES.READ_ONLY] || !inst[TYPES.READ_ONLY][toPath]) {
      if (inst._setPendingPropertyOrPath(toPath, value, true, Boolean(fromPath)) && (!detail || !detail.queueProperty)) {
        inst._invalidateProperties();
      }
    }
  }

  /**
   * Implements the "reflect" effect.
   *
   * Sets the attribute named `info.attrName` to the given property value.
   *
   * @param {!PropertyEffectsType} inst The instance the effect will be run on
   * @param {string} property Name of property
   * @param {Object} props Bag of current property changes
   * @param {Object} oldProps Bag of previous values for changed properties
   * @param {?} info Effect metadata
   * @private
   */
  function runReflectEffect(inst, property, props, oldProps, info) {
    var value = inst.__data[property];
    if (Polymer.sanitizeDOMValue) {
      value = Polymer.sanitizeDOMValue(value, info.attrName, 'attribute', /** @type {Node} */inst);
    }
    inst._propertyToAttribute(property, info.attrName, value);
  }

  /**
   * Runs "computed" effects for a set of changed properties.
   *
   * This method differs from the generic `runEffects` method in that it
   * continues to run computed effects based on the output of each pass until
   * there are no more newly computed properties.  This ensures that all
   * properties that will be computed by the initial set of changes are
   * computed before other effects (binding propagation, observers, and notify)
   * run.
   *
   * @param {!PropertyEffectsType} inst The instance the effect will be run on
   * @param {!Object} changedProps Bag of changed properties
   * @param {!Object} oldProps Bag of previous values for changed properties
   * @param {boolean} hasPaths True with `props` contains one or more paths
   * @private
   */
  function runComputedEffects(inst, changedProps, oldProps, hasPaths) {
    var computeEffects = inst[TYPES.COMPUTE];
    if (computeEffects) {
      var inputProps = changedProps;
      while (runEffects(inst, computeEffects, inputProps, oldProps, hasPaths)) {
        Object.assign(oldProps, inst.__dataOld);
        Object.assign(changedProps, inst.__dataPending);
        inputProps = inst.__dataPending;
        inst.__dataPending = null;
      }
    }
  }

  /**
   * Implements the "computed property" effect by running the method with the
   * values of the arguments specified in the `info` object and setting the
   * return value to the computed property specified.
   *
   * @param {!PropertyEffectsType} inst The instance the effect will be run on
   * @param {string} property Name of property
   * @param {Object} props Bag of current property changes
   * @param {Object} oldProps Bag of previous values for changed properties
   * @param {?} info Effect metadata
   * @private
   */
  function runComputedEffect(inst, property, props, oldProps, info) {
    var result = runMethodEffect(inst, property, props, oldProps, info);
    var computedProp = info.methodInfo;
    if (inst.__dataHasAccessor && inst.__dataHasAccessor[computedProp]) {
      inst._setPendingProperty(computedProp, result, true);
    } else {
      inst[computedProp] = result;
    }
  }

  /**
   * Computes path changes based on path links set up using the `linkPaths`
   * API.
   *
   * @param {!PropertyEffectsType} inst The instance whose props are changing
   * @param {string | !Array<(string|number)>} path Path that has changed
   * @param {*} value Value of changed path
   * @private
   */
  function computeLinkedPaths(inst, path, value) {
    var links = inst.__dataLinkedPaths;
    if (links) {
      var link = void 0;
      for (var a in links) {
        var b = links[a];
        if (Polymer.Path.isDescendant(a, path)) {
          link = Polymer.Path.translate(a, b, path);
          inst._setPendingPropertyOrPath(link, value, true, true);
        } else if (Polymer.Path.isDescendant(b, path)) {
          link = Polymer.Path.translate(b, a, path);
          inst._setPendingPropertyOrPath(link, value, true, true);
        }
      }
    }
  }

  // -- bindings ----------------------------------------------

  /**
   * Adds binding metadata to the current `nodeInfo`, and binding effects
   * for all part dependencies to `templateInfo`.
   *
   * @param {Function} constructor Class that `_parseTemplate` is currently
   *   running on
   * @param {TemplateInfo} templateInfo Template metadata for current template
   * @param {NodeInfo} nodeInfo Node metadata for current template node
   * @param {string} kind Binding kind, either 'property', 'attribute', or 'text'
   * @param {string} target Target property name
   * @param {!Array<!BindingPart>} parts Array of binding part metadata
   * @param {string=} literal Literal text surrounding binding parts (specified
   *   only for 'property' bindings, since these must be initialized as part
   *   of boot-up)
   * @private
   */
  function addBinding(constructor, templateInfo, nodeInfo, kind, target, parts, literal) {
    // Create binding metadata and add to nodeInfo
    nodeInfo.bindings = nodeInfo.bindings || [];
    var /** Binding */binding = { kind: kind, target: target, parts: parts, literal: literal, isCompound: parts.length !== 1 };
    nodeInfo.bindings.push(binding);
    // Add listener info to binding metadata
    if (shouldAddListener(binding)) {
      var _binding$parts$ = binding.parts[0],
          event = _binding$parts$.event,
          negate = _binding$parts$.negate;

      binding.listenerEvent = event || CaseMap.camelToDashCase(target) + '-changed';
      binding.listenerNegate = negate;
    }
    // Add "propagate" property effects to templateInfo
    var index = templateInfo.nodeInfoList.length;
    for (var i = 0; i < binding.parts.length; i++) {
      var part = binding.parts[i];
      part.compoundIndex = i;
      addEffectForBindingPart(constructor, templateInfo, binding, part, index);
    }
  }

  /**
   * Adds property effects to the given `templateInfo` for the given binding
   * part.
   *
   * @param {Function} constructor Class that `_parseTemplate` is currently
   *   running on
   * @param {TemplateInfo} templateInfo Template metadata for current template
   * @param {!Binding} binding Binding metadata
   * @param {!BindingPart} part Binding part metadata
   * @param {number} index Index into `nodeInfoList` for this node
   */
  function addEffectForBindingPart(constructor, templateInfo, binding, part, index) {
    if (!part.literal) {
      if (binding.kind === 'attribute' && binding.target[0] === '-') {
        console.warn('Cannot set attribute ' + binding.target + ' because "-" is not a valid attribute starting character');
      } else {
        var dependencies = part.dependencies;
        var info = { index: index, binding: binding, part: part, evaluator: constructor };
        for (var j = 0; j < dependencies.length; j++) {
          var trigger = dependencies[j];
          if (typeof trigger == 'string') {
            trigger = parseArg(trigger);
            trigger.wildcard = true;
          }
          constructor._addTemplatePropertyEffect(templateInfo, trigger.rootProperty, {
            fn: runBindingEffect,
            info: info, trigger: trigger
          });
        }
      }
    }
  }

  /**
   * Implements the "binding" (property/path binding) effect.
   *
   * Note that binding syntax is overridable via `_parseBindings` and
   * `_evaluateBinding`.  This method will call `_evaluateBinding` for any
   * non-literal parts returned from `_parseBindings`.  However,
   * there is no support for _path_ bindings via custom binding parts,
   * as this is specific to Polymer's path binding syntax.
   *
   * @param {!PropertyEffectsType} inst The instance the effect will be run on
   * @param {string} path Name of property
   * @param {Object} props Bag of current property changes
   * @param {Object} oldProps Bag of previous values for changed properties
   * @param {?} info Effect metadata
   * @param {boolean} hasPaths True with `props` contains one or more paths
   * @param {Array} nodeList List of nodes associated with `nodeInfoList` template
   *   metadata
   * @private
   */
  function runBindingEffect(inst, path, props, oldProps, info, hasPaths, nodeList) {
    var node = nodeList[info.index];
    var binding = info.binding;
    var part = info.part;
    // Subpath notification: transform path and set to client
    // e.g.: foo="{{obj.sub}}", path: 'obj.sub.prop', set 'foo.prop'=obj.sub.prop
    if (hasPaths && part.source && path.length > part.source.length && binding.kind == 'property' && !binding.isCompound && node.__dataHasAccessor && node.__dataHasAccessor[binding.target]) {
      var value = props[path];
      path = Polymer.Path.translate(part.source, binding.target, path);
      if (node._setPendingPropertyOrPath(path, value, false, true)) {
        inst._enqueueClient(node);
      }
    } else {
      var _value = info.evaluator._evaluateBinding(inst, part, path, props, oldProps, hasPaths);
      // Propagate value to child
      applyBindingValue(inst, node, binding, part, _value);
    }
  }

  /**
   * Sets the value for an "binding" (binding) effect to a node,
   * either as a property or attribute.
   *
   * @param {!PropertyEffectsType} inst The instance owning the binding effect
   * @param {Node} node Target node for binding
   * @param {!Binding} binding Binding metadata
   * @param {!BindingPart} part Binding part metadata
   * @param {*} value Value to set
   * @private
   */
  function applyBindingValue(inst, node, binding, part, value) {
    value = computeBindingValue(node, value, binding, part);
    if (Polymer.sanitizeDOMValue) {
      value = Polymer.sanitizeDOMValue(value, binding.target, binding.kind, node);
    }
    if (binding.kind == 'attribute') {
      // Attribute binding
      inst._valueToNodeAttribute( /** @type {Element} */node, value, binding.target);
    } else {
      // Property binding
      var prop = binding.target;
      if (node.__dataHasAccessor && node.__dataHasAccessor[prop]) {
        if (!node[TYPES.READ_ONLY] || !node[TYPES.READ_ONLY][prop]) {
          if (node._setPendingProperty(prop, value)) {
            inst._enqueueClient(node);
          }
        }
      } else {
        inst._setUnmanagedPropertyToNode(node, prop, value);
      }
    }
  }

  /**
   * Transforms an "binding" effect value based on compound & negation
   * effect metadata, as well as handling for special-case properties
   *
   * @param {Node} node Node the value will be set to
   * @param {*} value Value to set
   * @param {!Binding} binding Binding metadata
   * @param {!BindingPart} part Binding part metadata
   * @return {*} Transformed value to set
   * @private
   */
  function computeBindingValue(node, value, binding, part) {
    if (binding.isCompound) {
      var storage = node.__dataCompoundStorage[binding.target];
      storage[part.compoundIndex] = value;
      value = storage.join('');
    }
    if (binding.kind !== 'attribute') {
      // Some browsers serialize `undefined` to `"undefined"`
      if (binding.target === 'textContent' || node.localName == 'input' && binding.target == 'value') {
        value = value == undefined ? '' : value;
      }
    }
    return value;
  }

  /**
   * Returns true if a binding's metadata meets all the requirements to allow
   * 2-way binding, and therefore a `<property>-changed` event listener should be
   * added:
   * - used curly braces
   * - is a property (not attribute) binding
   * - is not a textContent binding
   * - is not compound
   *
   * @param {!Binding} binding Binding metadata
   * @return {boolean} True if 2-way listener should be added
   * @private
   */
  function shouldAddListener(binding) {
    return Boolean(binding.target) && binding.kind != 'attribute' && binding.kind != 'text' && !binding.isCompound && binding.parts[0].mode === '{';
  }

  /**
   * Setup compound binding storage structures, notify listeners, and dataHost
   * references onto the bound nodeList.
   *
   * @param {!PropertyEffectsType} inst Instance that bas been previously bound
   * @param {TemplateInfo} templateInfo Template metadata
   * @private
   */
  function setupBindings(inst, templateInfo) {
    // Setup compound storage, dataHost, and notify listeners
    var nodeList = templateInfo.nodeList,
        nodeInfoList = templateInfo.nodeInfoList;

    if (nodeInfoList.length) {
      for (var i = 0; i < nodeInfoList.length; i++) {
        var info = nodeInfoList[i];
        var node = nodeList[i];
        var bindings = info.bindings;
        if (bindings) {
          for (var _i = 0; _i < bindings.length; _i++) {
            var binding = bindings[_i];
            setupCompoundStorage(node, binding);
            addNotifyListener(node, inst, binding);
          }
        }
        node.__dataHost = inst;
      }
    }
  }

  /**
   * Initializes `__dataCompoundStorage` local storage on a bound node with
   * initial literal data for compound bindings, and sets the joined
   * literal parts to the bound property.
   *
   * When changes to compound parts occur, they are first set into the compound
   * storage array for that property, and then the array is joined to result in
   * the final value set to the property/attribute.
   *
   * @param {Node} node Bound node to initialize
   * @param {Binding} binding Binding metadata
   * @private
   */
  function setupCompoundStorage(node, binding) {
    if (binding.isCompound) {
      // Create compound storage map
      var storage = node.__dataCompoundStorage || (node.__dataCompoundStorage = {});
      var parts = binding.parts;
      // Copy literals from parts into storage for this binding
      var literals = new Array(parts.length);
      for (var j = 0; j < parts.length; j++) {
        literals[j] = parts[j].literal;
      }
      var target = binding.target;
      storage[target] = literals;
      // Configure properties with their literal parts
      if (binding.literal && binding.kind == 'property') {
        node[target] = binding.literal;
      }
    }
  }

  /**
   * Adds a 2-way binding notification event listener to the node specified
   *
   * @param {Object} node Child element to add listener to
   * @param {!PropertyEffectsType} inst Host element instance to handle notification event
   * @param {Binding} binding Binding metadata
   * @private
   */
  function addNotifyListener(node, inst, binding) {
    if (binding.listenerEvent) {
      var part = binding.parts[0];
      node.addEventListener(binding.listenerEvent, function (e) {
        handleNotification(e, inst, binding.target, part.source, part.negate);
      });
    }
  }

  // -- for method-based effects (complexObserver & computed) --------------

  /**
   * Adds property effects for each argument in the method signature (and
   * optionally, for the method name if `dynamic` is true) that calls the
   * provided effect function.
   *
   * @param {Element | Object} model Prototype or instance
   * @param {!MethodSignature} sig Method signature metadata
   * @param {string} type Type of property effect to add
   * @param {Function} effectFn Function to run when arguments change
   * @param {*=} methodInfo Effect-specific information to be included in
   *   method effect metadata
   * @param {boolean|Object=} dynamicFn Boolean or object map indicating whether
   *   method names should be included as a dependency to the effect. Note,
   *   defaults to true if the signature is static (sig.static is true).
   * @private
   */
  function createMethodEffect(model, sig, type, effectFn, methodInfo, dynamicFn) {
    dynamicFn = sig.static || dynamicFn && ((typeof dynamicFn === 'undefined' ? 'undefined' : _typeof(dynamicFn)) !== 'object' || dynamicFn[sig.methodName]);
    var info = {
      methodName: sig.methodName,
      args: sig.args,
      methodInfo: methodInfo,
      dynamicFn: dynamicFn
    };
    for (var i = 0, arg; i < sig.args.length && (arg = sig.args[i]); i++) {
      if (!arg.literal) {
        model._addPropertyEffect(arg.rootProperty, type, {
          fn: effectFn, info: info, trigger: arg
        });
      }
    }
    if (dynamicFn) {
      model._addPropertyEffect(sig.methodName, type, {
        fn: effectFn, info: info
      });
    }
  }

  /**
   * Calls a method with arguments marshaled from properties on the instance
   * based on the method signature contained in the effect metadata.
   *
   * Multi-property observers, computed properties, and inline computing
   * functions call this function to invoke the method, then use the return
   * value accordingly.
   *
   * @param {!PropertyEffectsType} inst The instance the effect will be run on
   * @param {string} property Name of property
   * @param {Object} props Bag of current property changes
   * @param {Object} oldProps Bag of previous values for changed properties
   * @param {?} info Effect metadata
   * @return {*} Returns the return value from the method invocation
   * @private
   */
  function runMethodEffect(inst, property, props, oldProps, info) {
    // Instances can optionally have a _methodHost which allows redirecting where
    // to find methods. Currently used by `templatize`.
    var context = inst._methodHost || inst;
    var fn = context[info.methodName];
    if (fn) {
      var args = marshalArgs(inst.__data, info.args, property, props);
      return fn.apply(context, args);
    } else if (!info.dynamicFn) {
      console.warn('method `' + info.methodName + '` not defined');
    }
  }

  var emptyArray = [];

  // Regular expressions used for binding
  var IDENT = '(?:' + '[a-zA-Z_$][\\w.:$\\-*]*' + ')';
  var NUMBER = '(?:' + '[-+]?[0-9]*\\.?[0-9]+(?:[eE][-+]?[0-9]+)?' + ')';
  var SQUOTE_STRING = '(?:' + '\'(?:[^\'\\\\]|\\\\.)*\'' + ')';
  var DQUOTE_STRING = '(?:' + '"(?:[^"\\\\]|\\\\.)*"' + ')';
  var STRING = '(?:' + SQUOTE_STRING + '|' + DQUOTE_STRING + ')';
  var ARGUMENT = '(?:(' + IDENT + '|' + NUMBER + '|' + STRING + ')\\s*' + ')';
  var ARGUMENTS = '(?:' + ARGUMENT + '(?:,\\s*' + ARGUMENT + ')*' + ')';
  var ARGUMENT_LIST = '(?:' + '\\(\\s*' + '(?:' + ARGUMENTS + '?' + ')' + '\\)\\s*' + ')';
  var BINDING = '(' + IDENT + '\\s*' + ARGUMENT_LIST + '?' + ')'; // Group 3
  var OPEN_BRACKET = '(\\[\\[|{{)' + '\\s*';
  var CLOSE_BRACKET = '(?:]]|}})';
  var NEGATE = '(?:(!)\\s*)?'; // Group 2
  var EXPRESSION = OPEN_BRACKET + NEGATE + BINDING + CLOSE_BRACKET;
  var bindingRegex = new RegExp(EXPRESSION, "g");

  /**
   * Create a string from binding parts of all the literal parts
   *
   * @param {!Array<BindingPart>} parts All parts to stringify
   * @return {string} String made from the literal parts
   */
  function literalFromParts(parts) {
    var s = '';
    for (var i = 0; i < parts.length; i++) {
      var literal = parts[i].literal;
      s += literal || '';
    }
    return s;
  }

  /**
   * Parses an expression string for a method signature, and returns a metadata
   * describing the method in terms of `methodName`, `static` (whether all the
   * arguments are literals), and an array of `args`
   *
   * @param {string} expression The expression to parse
   * @return {?MethodSignature} The method metadata object if a method expression was
   *   found, otherwise `undefined`
   * @private
   */
  function parseMethod(expression) {
    // tries to match valid javascript property names
    var m = expression.match(/([^\s]+?)\(([\s\S]*)\)/);
    if (m) {
      var methodName = m[1];
      var sig = { methodName: methodName, static: true, args: emptyArray };
      if (m[2].trim()) {
        // replace escaped commas with comma entity, split on un-escaped commas
        var args = m[2].replace(/\\,/g, '&comma;').split(',');
        return parseArgs(args, sig);
      } else {
        return sig;
      }
    }
    return null;
  }

  /**
   * Parses an array of arguments and sets the `args` property of the supplied
   * signature metadata object. Sets the `static` property to false if any
   * argument is a non-literal.
   *
   * @param {!Array<string>} argList Array of argument names
   * @param {!MethodSignature} sig Method signature metadata object
   * @return {!MethodSignature} The updated signature metadata object
   * @private
   */
  function parseArgs(argList, sig) {
    sig.args = argList.map(function (rawArg) {
      var arg = parseArg(rawArg);
      if (!arg.literal) {
        sig.static = false;
      }
      return arg;
    }, this);
    return sig;
  }

  /**
   * Parses an individual argument, and returns an argument metadata object
   * with the following fields:
   *
   *   {
   *     value: 'prop',        // property/path or literal value
   *     literal: false,       // whether argument is a literal
   *     structured: false,    // whether the property is a path
   *     rootProperty: 'prop', // the root property of the path
   *     wildcard: false       // whether the argument was a wildcard '.*' path
   *   }
   *
   * @param {string} rawArg The string value of the argument
   * @return {!MethodArg} Argument metadata object
   * @private
   */
  function parseArg(rawArg) {
    // clean up whitespace
    var arg = rawArg.trim()
    // replace comma entity with comma
    .replace(/&comma;/g, ',')
    // repair extra escape sequences; note only commas strictly need
    // escaping, but we allow any other char to be escaped since its
    // likely users will do this
    .replace(/\\(.)/g, '\$1');
    // basic argument descriptor
    var a = {
      name: arg,
      value: '',
      literal: false
    };
    // detect literal value (must be String or Number)
    var fc = arg[0];
    if (fc === '-') {
      fc = arg[1];
    }
    if (fc >= '0' && fc <= '9') {
      fc = '#';
    }
    switch (fc) {
      case "'":
      case '"':
        a.value = arg.slice(1, -1);
        a.literal = true;
        break;
      case '#':
        a.value = Number(arg);
        a.literal = true;
        break;
    }
    // if not literal, look for structured path
    if (!a.literal) {
      a.rootProperty = Polymer.Path.root(arg);
      // detect structured path (has dots)
      a.structured = Polymer.Path.isPath(arg);
      if (a.structured) {
        a.wildcard = arg.slice(-2) == '.*';
        if (a.wildcard) {
          a.name = arg.slice(0, -2);
        }
      }
    }
    return a;
  }

  /**
   * Gather the argument values for a method specified in the provided array
   * of argument metadata.
   *
   * The `path` and `value` arguments are used to fill in wildcard descriptor
   * when the method is being called as a result of a path notification.
   *
   * @param {Object} data Instance data storage object to read properties from
   * @param {!Array<!MethodArg>} args Array of argument metadata
   * @param {string} path Property/path name that triggered the method effect
   * @param {Object} props Bag of current property changes
   * @return {Array<*>} Array of argument values
   * @private
   */
  function marshalArgs(data, args, path, props) {
    var values = [];
    for (var i = 0, l = args.length; i < l; i++) {
      var arg = args[i];
      var name = arg.name;
      var v = void 0;
      if (arg.literal) {
        v = arg.value;
      } else {
        if (arg.structured) {
          v = Polymer.Path.get(data, name);
          // when data is not stored e.g. `splices`
          if (v === undefined) {
            v = props[name];
          }
        } else {
          v = data[name];
        }
      }
      if (arg.wildcard) {
        // Only send the actual path changed info if the change that
        // caused the observer to run matched the wildcard
        var baseChanged = name.indexOf(path + '.') === 0;
        var matches = path.indexOf(name) === 0 && !baseChanged;
        values[i] = {
          path: matches ? path : name,
          value: matches ? props[path] : v,
          base: v
        };
      } else {
        values[i] = v;
      }
    }
    return values;
  }

  // data api

  /**
   * Sends array splice notifications (`.splices` and `.length`)
   *
   * Note: this implementation only accepts normalized paths
   *
   * @param {!PropertyEffectsType} inst Instance to send notifications to
   * @param {Array} array The array the mutations occurred on
   * @param {string} path The path to the array that was mutated
   * @param {Array} splices Array of splice records
   * @private
   */
  function _notifySplices(inst, array, path, splices) {
    var splicesPath = path + '.splices';
    inst.notifyPath(splicesPath, { indexSplices: splices });
    inst.notifyPath(path + '.length', array.length);
    // Null here to allow potentially large splice records to be GC'ed.
    inst.__data[splicesPath] = { indexSplices: null };
  }

  /**
   * Creates a splice record and sends an array splice notification for
   * the described mutation
   *
   * Note: this implementation only accepts normalized paths
   *
   * @param {!PropertyEffectsType} inst Instance to send notifications to
   * @param {Array} array The array the mutations occurred on
   * @param {string} path The path to the array that was mutated
   * @param {number} index Index at which the array mutation occurred
   * @param {number} addedCount Number of added items
   * @param {Array} removed Array of removed items
   * @private
   */
  function notifySplice(inst, array, path, index, addedCount, removed) {
    _notifySplices(inst, array, path, [{
      index: index,
      addedCount: addedCount,
      removed: removed,
      object: array,
      type: 'splice'
    }]);
  }

  /**
   * Returns an upper-cased version of the string.
   *
   * @param {string} name String to uppercase
   * @return {string} Uppercased string
   * @private
   */
  function upper(name) {
    return name[0].toUpperCase() + name.substring(1);
  }

  /**
   * Element class mixin that provides meta-programming for Polymer's template
   * binding and data observation (collectively, "property effects") system.
   *
   * This mixin uses provides the following key static methods for adding
   * property effects to an element class:
   * - `addPropertyEffect`
   * - `createPropertyObserver`
   * - `createMethodObserver`
   * - `createNotifyingProperty`
   * - `createReadOnlyProperty`
   * - `createReflectedProperty`
   * - `createComputedProperty`
   * - `bindTemplate`
   *
   * Each method creates one or more property accessors, along with metadata
   * used by this mixin's implementation of `_propertiesChanged` to perform
   * the property effects.
   *
   * Underscored versions of the above methods also exist on the element
   * prototype for adding property effects on instances at runtime.
   *
   * Note that this mixin overrides several `PropertyAccessors` methods, in
   * many cases to maintain guarantees provided by the Polymer 1.x features;
   * notably it changes property accessors to be synchronous by default
   * whereas the default when using `PropertyAccessors` standalone is to be
   * async by default.
   *
   * @mixinFunction
   * @polymer
   * @appliesMixin Polymer.TemplateStamp
   * @appliesMixin Polymer.PropertyAccessors
   * @memberof Polymer
   * @summary Element class mixin that provides meta-programming for Polymer's
   * template binding and data observation system.
   */
  Polymer.PropertyEffects = Polymer.dedupingMixin(function (superClass) {

    /**
     * @constructor
     * @extends {superClass}
     * @implements {Polymer_PropertyAccessors}
     * @implements {Polymer_TemplateStamp}
     * @unrestricted
     */
    var propertyEffectsBase = Polymer.TemplateStamp(Polymer.PropertyAccessors(superClass));

    /**
     * @polymer
     * @mixinClass
     * @implements {Polymer_PropertyEffects}
     * @extends {propertyEffectsBase}
     * @unrestricted
     */

    var PropertyEffects = function (_propertyEffectsBase) {
      _inherits(PropertyEffects, _propertyEffectsBase);

      function PropertyEffects() {
        _classCallCheck(this, PropertyEffects);

        /** @type {boolean} */
        var _this = _possibleConstructorReturn(this, (PropertyEffects.__proto__ || Object.getPrototypeOf(PropertyEffects)).call(this));

        _this.__dataClientsReady;
        /** @type {Array} */
        _this.__dataPendingClients;
        /** @type {Object} */
        _this.__dataToNotify;
        /** @type {Object} */
        _this.__dataLinkedPaths;
        /** @type {boolean} */
        _this.__dataHasPaths;
        /** @type {Object} */
        _this.__dataCompoundStorage;
        /** @type {Polymer_PropertyEffects} */
        _this.__dataHost;
        /** @type {!Object} */
        _this.__dataTemp;
        /** @type {boolean} */
        _this.__dataClientsInitialized;
        /** @type {!Object} */
        _this.__data;
        /** @type {!Object} */
        _this.__dataPending;
        /** @type {!Object} */
        _this.__dataOld;
        /** @type {Object} */
        _this.__computeEffects;
        /** @type {Object} */
        _this.__reflectEffects;
        /** @type {Object} */
        _this.__notifyEffects;
        /** @type {Object} */
        _this.__propagateEffects;
        /** @type {Object} */
        _this.__observeEffects;
        /** @type {Object} */
        _this.__readOnly;
        /** @type {number} */
        _this.__dataCounter;
        /** @type {!TemplateInfo} */
        _this.__templateInfo;
        return _this;
      }

      _createClass(PropertyEffects, [{
        key: '_initializeProperties',
        value: function _initializeProperties() {
          _get(PropertyEffects.prototype.__proto__ || Object.getPrototypeOf(PropertyEffects.prototype), '_initializeProperties', this).call(this);
          hostStack.registerHost(this);
          this.__dataClientsReady = false;
          this.__dataPendingClients = null;
          this.__dataToNotify = null;
          this.__dataLinkedPaths = null;
          this.__dataHasPaths = false;
          // May be set on instance prior to upgrade
          this.__dataCompoundStorage = this.__dataCompoundStorage || null;
          this.__dataHost = this.__dataHost || null;
          this.__dataTemp = {};
          this.__dataClientsInitialized = false;
        }

        /**
         * Overrides `Polymer.PropertyAccessors` implementation to provide a
         * more efficient implementation of initializing properties from
         * the prototype on the instance.
         *
         * @override
         * @param {Object} props Properties to initialize on the prototype
         */

      }, {
        key: '_initializeProtoProperties',
        value: function _initializeProtoProperties(props) {
          this.__data = Object.create(props);
          this.__dataPending = Object.create(props);
          this.__dataOld = {};
        }

        /**
         * Overrides `Polymer.PropertyAccessors` implementation to avoid setting
         * `_setProperty`'s `shouldNotify: true`.
         *
         * @override
         * @param {Object} props Properties to initialize on the instance
         */

      }, {
        key: '_initializeInstanceProperties',
        value: function _initializeInstanceProperties(props) {
          var readOnly = this[TYPES.READ_ONLY];
          for (var prop in props) {
            if (!readOnly || !readOnly[prop]) {
              this.__dataPending = this.__dataPending || {};
              this.__dataOld = this.__dataOld || {};
              this.__data[prop] = this.__dataPending[prop] = props[prop];
            }
          }
        }

        // Prototype setup ----------------------------------------

        /**
         * Equivalent to static `addPropertyEffect` API but can be called on
         * an instance to add effects at runtime.  See that method for
         * full API docs.
         *
         * @param {string} property Property that should trigger the effect
         * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES
         * @param {Object=} effect Effect metadata object
         * @protected
         */

      }, {
        key: '_addPropertyEffect',
        value: function _addPropertyEffect(property, type, effect) {
          this._createPropertyAccessor(property, type == TYPES.READ_ONLY);
          // effects are accumulated into arrays per property based on type
          var effects = ensureOwnEffectMap(this, type)[property];
          if (!effects) {
            effects = this[type][property] = [];
          }
          effects.push(effect);
        }

        /**
         * Removes the given property effect.
         *
         * @param {string} property Property the effect was associated with
         * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES
         * @param {Object=} effect Effect metadata object to remove
         */

      }, {
        key: '_removePropertyEffect',
        value: function _removePropertyEffect(property, type, effect) {
          var effects = ensureOwnEffectMap(this, type)[property];
          var idx = effects.indexOf(effect);
          if (idx >= 0) {
            effects.splice(idx, 1);
          }
        }

        /**
         * Returns whether the current prototype/instance has a property effect
         * of a certain type.
         *
         * @param {string} property Property name
         * @param {string=} type Effect type, from this.PROPERTY_EFFECT_TYPES
         * @return {boolean} True if the prototype/instance has an effect of this type
         * @protected
         */

      }, {
        key: '_hasPropertyEffect',
        value: function _hasPropertyEffect(property, type) {
          var effects = this[type];
          return Boolean(effects && effects[property]);
        }

        /**
         * Returns whether the current prototype/instance has a "read only"
         * accessor for the given property.
         *
         * @param {string} property Property name
         * @return {boolean} True if the prototype/instance has an effect of this type
         * @protected
         */

      }, {
        key: '_hasReadOnlyEffect',
        value: function _hasReadOnlyEffect(property) {
          return this._hasPropertyEffect(property, TYPES.READ_ONLY);
        }

        /**
         * Returns whether the current prototype/instance has a "notify"
         * property effect for the given property.
         *
         * @param {string} property Property name
         * @return {boolean} True if the prototype/instance has an effect of this type
         * @protected
         */

      }, {
        key: '_hasNotifyEffect',
        value: function _hasNotifyEffect(property) {
          return this._hasPropertyEffect(property, TYPES.NOTIFY);
        }

        /**
         * Returns whether the current prototype/instance has a "reflect to attribute"
         * property effect for the given property.
         *
         * @param {string} property Property name
         * @return {boolean} True if the prototype/instance has an effect of this type
         * @protected
         */

      }, {
        key: '_hasReflectEffect',
        value: function _hasReflectEffect(property) {
          return this._hasPropertyEffect(property, TYPES.REFLECT);
        }

        /**
         * Returns whether the current prototype/instance has a "computed"
         * property effect for the given property.
         *
         * @param {string} property Property name
         * @return {boolean} True if the prototype/instance has an effect of this type
         * @protected
         */

      }, {
        key: '_hasComputedEffect',
        value: function _hasComputedEffect(property) {
          return this._hasPropertyEffect(property, TYPES.COMPUTE);
        }

        // Runtime ----------------------------------------

        /**
         * Sets a pending property or path.  If the root property of the path in
         * question had no accessor, the path is set, otherwise it is enqueued
         * via `_setPendingProperty`.
         *
         * This function isolates relatively expensive functionality necessary
         * for the public API (`set`, `setProperties`, `notifyPath`, and property
         * change listeners via {{...}} bindings), such that it is only done
         * when paths enter the system, and not at every propagation step.  It
         * also sets a `__dataHasPaths` flag on the instance which is used to
         * fast-path slower path-matching code in the property effects host paths.
         *
         * `path` can be a path string or array of path parts as accepted by the
         * public API.
         *
         * @param {string | !Array<number|string>} path Path to set
         * @param {*} value Value to set
         * @param {boolean=} shouldNotify Set to true if this change should
         *  cause a property notification event dispatch
         * @param {boolean=} isPathNotification If the path being set is a path
         *   notification of an already changed value, as opposed to a request
         *   to set and notify the change.  In the latter `false` case, a dirty
         *   check is performed and then the value is set to the path before
         *   enqueuing the pending property change.
         * @return {boolean} Returns true if the property/path was enqueued in
         *   the pending changes bag.
         * @protected
         */

      }, {
        key: '_setPendingPropertyOrPath',
        value: function _setPendingPropertyOrPath(path, value, shouldNotify, isPathNotification) {
          if (isPathNotification || Polymer.Path.root(Array.isArray(path) ? path[0] : path) !== path) {
            // Dirty check changes being set to a path against the actual object,
            // since this is the entry point for paths into the system; from here
            // the only dirty checks are against the `__dataTemp` cache to prevent
            // duplicate work in the same turn only. Note, if this was a notification
            // of a change already set to a path (isPathNotification: true),
            // we always let the change through and skip the `set` since it was
            // already dirty checked at the point of entry and the underlying
            // object has already been updated
            if (!isPathNotification) {
              var old = Polymer.Path.get(this, path);
              path = /** @type {string} */Polymer.Path.set(this, path, value);
              // Use property-accessor's simpler dirty check
              if (!path || !_get(PropertyEffects.prototype.__proto__ || Object.getPrototypeOf(PropertyEffects.prototype), '_shouldPropertyChange', this).call(this, path, value, old)) {
                return false;
              }
            }
            this.__dataHasPaths = true;
            if (this._setPendingProperty( /**@type{string}*/path, value, shouldNotify)) {
              computeLinkedPaths(this, path, value);
              return true;
            }
          } else {
            if (this.__dataHasAccessor && this.__dataHasAccessor[path]) {
              return this._setPendingProperty( /**@type{string}*/path, value, shouldNotify);
            } else {
              this[path] = value;
            }
          }
          return false;
        }

        /**
         * Applies a value to a non-Polymer element/node's property.
         *
         * The implementation makes a best-effort at binding interop:
         * Some native element properties have side-effects when
         * re-setting the same value (e.g. setting `<input>.value` resets the
         * cursor position), so we do a dirty-check before setting the value.
         * However, for better interop with non-Polymer custom elements that
         * accept objects, we explicitly re-set object changes coming from the
         * Polymer world (which may include deep object changes without the
         * top reference changing), erring on the side of providing more
         * information.
         *
         * Users may override this method to provide alternate approaches.
         *
         * @param {Node} node The node to set a property on
         * @param {string} prop The property to set
         * @param {*} value The value to set
         * @protected
         */

      }, {
        key: '_setUnmanagedPropertyToNode',
        value: function _setUnmanagedPropertyToNode(node, prop, value) {
          // It is a judgment call that resetting primitives is
          // "bad" and resettings objects is also "good"; alternatively we could
          // implement a whitelist of tag & property values that should never
          // be reset (e.g. <input>.value && <select>.value)
          if (value !== node[prop] || (typeof value === 'undefined' ? 'undefined' : _typeof(value)) == 'object') {
            node[prop] = value;
          }
        }

        /**
         * Overrides the `PropertyAccessors` implementation to introduce special
         * dirty check logic depending on the property & value being set:
         *
         * 1. Any value set to a path (e.g. 'obj.prop': 42 or 'obj.prop': {...})
         *    Stored in `__dataTemp`, dirty checked against `__dataTemp`
         * 2. Object set to simple property (e.g. 'prop': {...})
         *    Stored in `__dataTemp` and `__data`, dirty checked against
         *    `__dataTemp` by default implementation of `_shouldPropertyChange`
         * 3. Primitive value set to simple property (e.g. 'prop': 42)
         *    Stored in `__data`, dirty checked against `__data`
         *
         * The dirty-check is important to prevent cycles due to two-way
         * notification, but paths and objects are only dirty checked against any
         * previous value set during this turn via a "temporary cache" that is
         * cleared when the last `_propertiesChaged` exits. This is so:
         * a. any cached array paths (e.g. 'array.3.prop') may be invalidated
         *    due to array mutations like shift/unshift/splice; this is fine
         *    since path changes are dirty-checked at user entry points like `set`
         * b. dirty-checking for objects only lasts one turn to allow the user
         *    to mutate the object in-place and re-set it with the same identity
         *    and have all sub-properties re-propagated in a subsequent turn.
         *
         * The temp cache is not necessarily sufficient to prevent invalid array
         * paths, since a splice can happen during the same turn (with pathological
         * user code); we could introduce a "fixup" for temporarily cached array
         * paths if needed: https://github.com/Polymer/polymer/issues/4227
         *
         * @param {string} property Name of the property
         * @param {*} value Value to set
         * @param {boolean=} shouldNotify True if property should fire notification
         *   event (applies only for `notify: true` properties)
         * @return {boolean} Returns true if the property changed
         * @override
         */

      }, {
        key: '_setPendingProperty',
        value: function _setPendingProperty(property, value, shouldNotify) {
          var isPath = this.__dataHasPaths && Polymer.Path.isPath(property);
          var prevProps = isPath ? this.__dataTemp : this.__data;
          if (this._shouldPropertyChange(property, value, prevProps[property])) {
            if (!this.__dataPending) {
              this.__dataPending = {};
              this.__dataOld = {};
            }
            // Ensure old is captured from the last turn
            if (!(property in this.__dataOld)) {
              this.__dataOld[property] = this.__data[property];
            }
            // Paths are stored in temporary cache (cleared at end of turn),
            // which is used for dirty-checking, all others stored in __data
            if (isPath) {
              this.__dataTemp[property] = value;
            } else {
              this.__data[property] = value;
            }
            // All changes go into pending property bag, passed to _propertiesChanged
            this.__dataPending[property] = value;
            // Track properties that should notify separately
            if (isPath || this[TYPES.NOTIFY] && this[TYPES.NOTIFY][property]) {
              this.__dataToNotify = this.__dataToNotify || {};
              this.__dataToNotify[property] = shouldNotify;
            }
            return true;
          }
          return false;
        }

        /**
         * Overrides base implementation to ensure all accessors set `shouldNotify`
         * to true, for per-property notification tracking.
         *
         * @override
         */

      }, {
        key: '_setProperty',
        value: function _setProperty(property, value) {
          if (this._setPendingProperty(property, value, true)) {
            this._invalidateProperties();
          }
        }

        /**
         * Overrides `PropertyAccessor`'s default async queuing of
         * `_propertiesChanged`: if `__dataReady` is false (has not yet been
         * manually flushed), the function no-ops; otherwise flushes
         * `_propertiesChanged` synchronously.
         *
         * @override
         */

      }, {
        key: '_invalidateProperties',
        value: function _invalidateProperties() {
          if (this.__dataReady) {
            this._flushProperties();
          }
        }

        /**
         * Enqueues the given client on a list of pending clients, whose
         * pending property changes can later be flushed via a call to
         * `_flushClients`.
         *
         * @param {Object} client PropertyEffects client to enqueue
         * @protected
         */

      }, {
        key: '_enqueueClient',
        value: function _enqueueClient(client) {
          this.__dataPendingClients = this.__dataPendingClients || [];
          if (client !== this) {
            this.__dataPendingClients.push(client);
          }
        }

        /**
         * Flushes any clients previously enqueued via `_enqueueClient`, causing
         * their `_flushProperties` method to run.
         *
         * @protected
         */

      }, {
        key: '_flushClients',
        value: function _flushClients() {
          if (!this.__dataClientsReady) {
            this.__dataClientsReady = true;
            this._readyClients();
            // Override point where accessors are turned on; importantly,
            // this is after clients have fully readied, providing a guarantee
            // that any property effects occur only after all clients are ready.
            this.__dataReady = true;
          } else {
            this.__enableOrFlushClients();
          }
        }

        // NOTE: We ensure clients either enable or flush as appropriate. This
        // handles two corner cases:
        // (1) clients flush properly when connected/enabled before the host
        // enables; e.g.
        //   (a) Templatize stamps with no properties and does not flush and
        //   (b) the instance is inserted into dom and
        //   (c) then the instance flushes.
        // (2) clients enable properly when not connected/enabled when the host
        // flushes; e.g.
        //   (a) a template is runtime stamped and not yet connected/enabled
        //   (b) a host sets a property, causing stamped dom to flush
        //   (c) the stamped dom enables.

      }, {
        key: '__enableOrFlushClients',
        value: function __enableOrFlushClients() {
          var clients = this.__dataPendingClients;
          if (clients) {
            this.__dataPendingClients = null;
            for (var i = 0; i < clients.length; i++) {
              var client = clients[i];
              if (!client.__dataEnabled) {
                client._enableProperties();
              } else if (client.__dataPending) {
                client._flushProperties();
              }
            }
          }
        }

        /**
         * Perform any initial setup on client dom. Called before the first
         * `_flushProperties` call on client dom and before any element
         * observers are called.
         *
         * @protected
         */

      }, {
        key: '_readyClients',
        value: function _readyClients() {
          this.__enableOrFlushClients();
        }

        /**
         * Sets a bag of property changes to this instance, and
         * synchronously processes all effects of the properties as a batch.
         *
         * Property names must be simple properties, not paths.  Batched
         * path propagation is not supported.
         *
         * @param {Object} props Bag of one or more key-value pairs whose key is
         *   a property and value is the new value to set for that property.
         * @param {boolean=} setReadOnly When true, any private values set in
         *   `props` will be set. By default, `setProperties` will not set
         *   `readOnly: true` root properties.
         * @public
         */

      }, {
        key: 'setProperties',
        value: function setProperties(props, setReadOnly) {
          for (var path in props) {
            if (setReadOnly || !this[TYPES.READ_ONLY] || !this[TYPES.READ_ONLY][path]) {
              //TODO(kschaaf): explicitly disallow paths in setProperty?
              // wildcard observers currently only pass the first changed path
              // in the `info` object, and you could do some odd things batching
              // paths, e.g. {'foo.bar': {...}, 'foo': null}
              this._setPendingPropertyOrPath(path, props[path], true);
            }
          }
          this._invalidateProperties();
        }

        /**
         * Overrides `PropertyAccessors` so that property accessor
         * side effects are not enabled until after client dom is fully ready.
         * Also calls `_flushClients` callback to ensure client dom is enabled
         * that was not enabled as a result of flushing properties.
         *
         * @override
         */

      }, {
        key: 'ready',
        value: function ready() {
          // It is important that `super.ready()` is not called here as it
          // immediately turns on accessors. Instead, we wait until `readyClients`
          // to enable accessors to provide a guarantee that clients are ready
          // before processing any accessors side effects.
          this._flushProperties();
          // If no data was pending, `_flushProperties` will not `flushClients`
          // so ensure this is done.
          if (!this.__dataClientsReady) {
            this._flushClients();
          }
          // Before ready, client notifications do not trigger _flushProperties.
          // Therefore a flush is necessary here if data has been set.
          if (this.__dataPending) {
            this._flushProperties();
          }
        }

        /**
         * Implements `PropertyAccessors`'s properties changed callback.
         *
         * Runs each class of effects for the batch of changed properties in
         * a specific order (compute, propagate, reflect, observe, notify).
         *
         * @override
         */

      }, {
        key: '_propertiesChanged',
        value: function _propertiesChanged(currentProps, changedProps, oldProps) {
          // ----------------------------
          // let c = Object.getOwnPropertyNames(changedProps || {});
          // window.debug && console.group(this.localName + '#' + this.id + ': ' + c);
          // if (window.debug) { debugger; }
          // ----------------------------
          var hasPaths = this.__dataHasPaths;
          this.__dataHasPaths = false;
          // Compute properties
          runComputedEffects(this, changedProps, oldProps, hasPaths);
          // Clear notify properties prior to possible reentry (propagate, observe),
          // but after computing effects have a chance to add to them
          var notifyProps = this.__dataToNotify;
          this.__dataToNotify = null;
          // Propagate properties to clients
          this._propagatePropertyChanges(changedProps, oldProps, hasPaths);
          // Flush clients
          this._flushClients();
          // Reflect properties
          runEffects(this, this[TYPES.REFLECT], changedProps, oldProps, hasPaths);
          // Observe properties
          runEffects(this, this[TYPES.OBSERVE], changedProps, oldProps, hasPaths);
          // Notify properties to host
          if (notifyProps) {
            runNotifyEffects(this, notifyProps, changedProps, oldProps, hasPaths);
          }
          // Clear temporary cache at end of turn
          if (this.__dataCounter == 1) {
            this.__dataTemp = {};
          }
          // ----------------------------
          // window.debug && console.groupEnd(this.localName + '#' + this.id + ': ' + c);
          // ----------------------------
        }

        /**
         * Called to propagate any property changes to stamped template nodes
         * managed by this element.
         *
         * @param {Object} changedProps Bag of changed properties
         * @param {Object} oldProps Bag of previous values for changed properties
         * @param {boolean} hasPaths True with `props` contains one or more paths
         * @protected
         */

      }, {
        key: '_propagatePropertyChanges',
        value: function _propagatePropertyChanges(changedProps, oldProps, hasPaths) {
          if (this[TYPES.PROPAGATE]) {
            runEffects(this, this[TYPES.PROPAGATE], changedProps, oldProps, hasPaths);
          }
          var templateInfo = this.__templateInfo;
          while (templateInfo) {
            runEffects(this, templateInfo.propertyEffects, changedProps, oldProps, hasPaths, templateInfo.nodeList);
            templateInfo = templateInfo.nextTemplateInfo;
          }
        }

        /**
         * Aliases one data path as another, such that path notifications from one
         * are routed to the other.
         *
         * @param {string | !Array<string|number>} to Target path to link.
         * @param {string | !Array<string|number>} from Source path to link.
         * @public
         */

      }, {
        key: 'linkPaths',
        value: function linkPaths(to, from) {
          to = Polymer.Path.normalize(to);
          from = Polymer.Path.normalize(from);
          this.__dataLinkedPaths = this.__dataLinkedPaths || {};
          this.__dataLinkedPaths[to] = from;
        }

        /**
         * Removes a data path alias previously established with `_linkPaths`.
         *
         * Note, the path to unlink should be the target (`to`) used when
         * linking the paths.
         *
         * @param {string | !Array<string|number>} path Target path to unlink.
         * @public
         */

      }, {
        key: 'unlinkPaths',
        value: function unlinkPaths(path) {
          path = Polymer.Path.normalize(path);
          if (this.__dataLinkedPaths) {
            delete this.__dataLinkedPaths[path];
          }
        }

        /**
         * Notify that an array has changed.
         *
         * Example:
         *
         *     this.items = [ {name: 'Jim'}, {name: 'Todd'}, {name: 'Bill'} ];
         *     ...
         *     this.items.splice(1, 1, {name: 'Sam'});
         *     this.items.push({name: 'Bob'});
         *     this.notifySplices('items', [
         *       { index: 1, removed: [{name: 'Todd'}], addedCount: 1, obect: this.items, type: 'splice' },
         *       { index: 3, removed: [], addedCount: 1, object: this.items, type: 'splice'}
         *     ]);
         *
         * @param {string} path Path that should be notified.
         * @param {Array} splices Array of splice records indicating ordered
         *   changes that occurred to the array. Each record should have the
         *   following fields:
         *    * index: index at which the change occurred
         *    * removed: array of items that were removed from this index
         *    * addedCount: number of new items added at this index
         *    * object: a reference to the array in question
         *    * type: the string literal 'splice'
         *
         *   Note that splice records _must_ be normalized such that they are
         *   reported in index order (raw results from `Object.observe` are not
         *   ordered and must be normalized/merged before notifying).
         * @public
        */

      }, {
        key: 'notifySplices',
        value: function notifySplices(path, splices) {
          var info = { path: '' };
          var array = /** @type {Array} */Polymer.Path.get(this, path, info);
          _notifySplices(this, array, info.path, splices);
        }

        /**
         * Convenience method for reading a value from a path.
         *
         * Note, if any part in the path is undefined, this method returns
         * `undefined` (this method does not throw when dereferencing undefined
         * paths).
         *
         * @param {(string|!Array<(string|number)>)} path Path to the value
         *   to read.  The path may be specified as a string (e.g. `foo.bar.baz`)
         *   or an array of path parts (e.g. `['foo.bar', 'baz']`).  Note that
         *   bracketed expressions are not supported; string-based path parts
         *   *must* be separated by dots.  Note that when dereferencing array
         *   indices, the index may be used as a dotted part directly
         *   (e.g. `users.12.name` or `['users', 12, 'name']`).
         * @param {Object=} root Root object from which the path is evaluated.
         * @return {*} Value at the path, or `undefined` if any part of the path
         *   is undefined.
         * @public
         */

      }, {
        key: 'get',
        value: function get(path, root) {
          return Polymer.Path.get(root || this, path);
        }

        /**
         * Convenience method for setting a value to a path and notifying any
         * elements bound to the same path.
         *
         * Note, if any part in the path except for the last is undefined,
         * this method does nothing (this method does not throw when
         * dereferencing undefined paths).
         *
         * @param {(string|!Array<(string|number)>)} path Path to the value
         *   to write.  The path may be specified as a string (e.g. `'foo.bar.baz'`)
         *   or an array of path parts (e.g. `['foo.bar', 'baz']`).  Note that
         *   bracketed expressions are not supported; string-based path parts
         *   *must* be separated by dots.  Note that when dereferencing array
         *   indices, the index may be used as a dotted part directly
         *   (e.g. `'users.12.name'` or `['users', 12, 'name']`).
         * @param {*} value Value to set at the specified path.
         * @param {Object=} root Root object from which the path is evaluated.
         *   When specified, no notification will occur.
         * @public
        */

      }, {
        key: 'set',
        value: function set(path, value, root) {
          if (root) {
            Polymer.Path.set(root, path, value);
          } else {
            if (!this[TYPES.READ_ONLY] || !this[TYPES.READ_ONLY][/** @type {string} */path]) {
              if (this._setPendingPropertyOrPath(path, value, true)) {
                this._invalidateProperties();
              }
            }
          }
        }

        /**
         * Adds items onto the end of the array at the path specified.
         *
         * The arguments after `path` and return value match that of
         * `Array.prototype.push`.
         *
         * This method notifies other paths to the same array that a
         * splice occurred to the array.
         *
         * @param {string} path Path to array.
         * @param {...*} items Items to push onto array
         * @return {number} New length of the array.
         * @public
         */

      }, {
        key: 'push',
        value: function push(path) {
          var info = { path: '' };
          var array = /** @type {Array}*/Polymer.Path.get(this, path, info);
          var len = array.length;

          for (var _len = arguments.length, items = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            items[_key - 1] = arguments[_key];
          }

          var ret = array.push.apply(array, items);
          if (items.length) {
            notifySplice(this, array, info.path, len, items.length, []);
          }
          return ret;
        }

        /**
         * Removes an item from the end of array at the path specified.
         *
         * The arguments after `path` and return value match that of
         * `Array.prototype.pop`.
         *
         * This method notifies other paths to the same array that a
         * splice occurred to the array.
         *
         * @param {string} path Path to array.
         * @return {*} Item that was removed.
         * @public
         */

      }, {
        key: 'pop',
        value: function pop(path) {
          var info = { path: '' };
          var array = /** @type {Array} */Polymer.Path.get(this, path, info);
          var hadLength = Boolean(array.length);
          var ret = array.pop();
          if (hadLength) {
            notifySplice(this, array, info.path, array.length, 0, [ret]);
          }
          return ret;
        }

        /**
         * Starting from the start index specified, removes 0 or more items
         * from the array and inserts 0 or more new items in their place.
         *
         * The arguments after `path` and return value match that of
         * `Array.prototype.splice`.
         *
         * This method notifies other paths to the same array that a
         * splice occurred to the array.
         *
         * @param {string} path Path to array.
         * @param {number} start Index from which to start removing/inserting.
         * @param {number} deleteCount Number of items to remove.
         * @param {...*} items Items to insert into array.
         * @return {Array} Array of removed items.
         * @public
         */

      }, {
        key: 'splice',
        value: function splice(path, start, deleteCount) {
          var info = { path: '' };
          var array = /** @type {Array} */Polymer.Path.get(this, path, info);
          // Normalize fancy native splice handling of crazy start values
          if (start < 0) {
            start = array.length - Math.floor(-start);
          } else {
            start = Math.floor(start);
          }
          if (!start) {
            start = 0;
          }

          for (var _len2 = arguments.length, items = Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {
            items[_key2 - 3] = arguments[_key2];
          }

          var ret = array.splice.apply(array, [start, deleteCount].concat(items));
          if (items.length || ret.length) {
            notifySplice(this, array, info.path, start, items.length, ret);
          }
          return ret;
        }

        /**
         * Removes an item from the beginning of array at the path specified.
         *
         * The arguments after `path` and return value match that of
         * `Array.prototype.pop`.
         *
         * This method notifies other paths to the same array that a
         * splice occurred to the array.
         *
         * @param {string} path Path to array.
         * @return {*} Item that was removed.
         * @public
         */

      }, {
        key: 'shift',
        value: function shift(path) {
          var info = { path: '' };
          var array = /** @type {Array} */Polymer.Path.get(this, path, info);
          var hadLength = Boolean(array.length);
          var ret = array.shift();
          if (hadLength) {
            notifySplice(this, array, info.path, 0, 0, [ret]);
          }
          return ret;
        }

        /**
         * Adds items onto the beginning of the array at the path specified.
         *
         * The arguments after `path` and return value match that of
         * `Array.prototype.push`.
         *
         * This method notifies other paths to the same array that a
         * splice occurred to the array.
         *
         * @param {string} path Path to array.
         * @param {...*} items Items to insert info array
         * @return {number} New length of the array.
         * @public
         */

      }, {
        key: 'unshift',
        value: function unshift(path) {
          var info = { path: '' };
          var array = /** @type {Array} */Polymer.Path.get(this, path, info);

          for (var _len3 = arguments.length, items = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
            items[_key3 - 1] = arguments[_key3];
          }

          var ret = array.unshift.apply(array, items);
          if (items.length) {
            notifySplice(this, array, info.path, 0, items.length, []);
          }
          return ret;
        }

        /**
         * Notify that a path has changed.
         *
         * Example:
         *
         *     this.item.user.name = 'Bob';
         *     this.notifyPath('item.user.name');
         *
         * @param {string} path Path that should be notified.
         * @param {*=} value Value at the path (optional).
         * @public
        */

      }, {
        key: 'notifyPath',
        value: function notifyPath(path, value) {
          /** @type {string} */
          var propPath = void 0;
          if (arguments.length == 1) {
            // Get value if not supplied
            var info = { path: '' };
            value = Polymer.Path.get(this, path, info);
            propPath = info.path;
          } else if (Array.isArray(path)) {
            // Normalize path if needed
            propPath = Polymer.Path.normalize(path);
          } else {
            propPath = /** @type{string} */path;
          }
          if (this._setPendingPropertyOrPath(propPath, value, true, true)) {
            this._invalidateProperties();
          }
        }

        /**
         * Equivalent to static `createReadOnlyProperty` API but can be called on
         * an instance to add effects at runtime.  See that method for
         * full API docs.
         *
         * @param {string} property Property name
         * @param {boolean=} protectedSetter Creates a custom protected setter
         *   when `true`.
         * @protected
         */

      }, {
        key: '_createReadOnlyProperty',
        value: function _createReadOnlyProperty(property, protectedSetter) {
          this._addPropertyEffect(property, TYPES.READ_ONLY);
          if (protectedSetter) {
            this['_set' + upper(property)] = /** @this {PropertyEffects} */function (value) {
              this._setProperty(property, value);
            };
          }
        }

        /**
         * Equivalent to static `createPropertyObserver` API but can be called on
         * an instance to add effects at runtime.  See that method for
         * full API docs.
         *
         * @param {string} property Property name
         * @param {string} methodName Name of observer method to call
         * @param {boolean=} dynamicFn Whether the method name should be included as
         *   a dependency to the effect.
         * @protected
         */

      }, {
        key: '_createPropertyObserver',
        value: function _createPropertyObserver(property, methodName, dynamicFn) {
          var info = { property: property, methodName: methodName, dynamicFn: Boolean(dynamicFn) };
          this._addPropertyEffect(property, TYPES.OBSERVE, {
            fn: runObserverEffect, info: info, trigger: { name: property }
          });
          if (dynamicFn) {
            this._addPropertyEffect(methodName, TYPES.OBSERVE, {
              fn: runObserverEffect, info: info, trigger: { name: methodName }
            });
          }
        }

        /**
         * Equivalent to static `createMethodObserver` API but can be called on
         * an instance to add effects at runtime.  See that method for
         * full API docs.
         *
         * @param {string} expression Method expression
         * @param {boolean|Object=} dynamicFn Boolean or object map indicating
         *   whether method names should be included as a dependency to the effect.
         * @protected
         */

      }, {
        key: '_createMethodObserver',
        value: function _createMethodObserver(expression, dynamicFn) {
          var sig = parseMethod(expression);
          if (!sig) {
            throw new Error("Malformed observer expression '" + expression + "'");
          }
          createMethodEffect(this, sig, TYPES.OBSERVE, runMethodEffect, null, dynamicFn);
        }

        /**
         * Equivalent to static `createNotifyingProperty` API but can be called on
         * an instance to add effects at runtime.  See that method for
         * full API docs.
         *
         * @param {string} property Property name
         * @protected
         */

      }, {
        key: '_createNotifyingProperty',
        value: function _createNotifyingProperty(property) {
          this._addPropertyEffect(property, TYPES.NOTIFY, {
            fn: runNotifyEffect,
            info: {
              eventName: CaseMap.camelToDashCase(property) + '-changed',
              property: property
            }
          });
        }

        /**
         * Equivalent to static `createReflectedProperty` API but can be called on
         * an instance to add effects at runtime.  See that method for
         * full API docs.
         *
         * @param {string} property Property name
         * @protected
         */

      }, {
        key: '_createReflectedProperty',
        value: function _createReflectedProperty(property) {
          var attr = CaseMap.camelToDashCase(property);
          if (attr[0] === '-') {
            console.warn('Property ' + property + ' cannot be reflected to attribute ' + attr + ' because "-" is not a valid starting attribute name. Use a lowercase first letter for the property thisead.');
          } else {
            this._addPropertyEffect(property, TYPES.REFLECT, {
              fn: runReflectEffect,
              info: {
                attrName: attr
              }
            });
          }
        }

        /**
         * Equivalent to static `createComputedProperty` API but can be called on
         * an instance to add effects at runtime.  See that method for
         * full API docs.
         *
         * @param {string} property Name of computed property to set
         * @param {string} expression Method expression
         * @param {boolean|Object=} dynamicFn Boolean or object map indicating
         *   whether method names should be included as a dependency to the effect.
         * @protected
         */

      }, {
        key: '_createComputedProperty',
        value: function _createComputedProperty(property, expression, dynamicFn) {
          var sig = parseMethod(expression);
          if (!sig) {
            throw new Error("Malformed computed expression '" + expression + "'");
          }
          createMethodEffect(this, sig, TYPES.COMPUTE, runComputedEffect, property, dynamicFn);
        }

        // -- static class methods ------------

        /**
         * Ensures an accessor exists for the specified property, and adds
         * to a list of "property effects" that will run when the accessor for
         * the specified property is set.  Effects are grouped by "type", which
         * roughly corresponds to a phase in effect processing.  The effect
         * metadata should be in the following form:
         *
         *   {
         *     fn: effectFunction, // Reference to function to call to perform effect
         *     info: { ... }       // Effect metadata passed to function
         *     trigger: {          // Optional triggering metadata; if not provided
         *       name: string      // the property is treated as a wildcard
         *       structured: boolean
         *       wildcard: boolean
         *     }
         *   }
         *
         * Effects are called from `_propertiesChanged` in the following order by
         * type:
         *
         * 1. COMPUTE
         * 2. PROPAGATE
         * 3. REFLECT
         * 4. OBSERVE
         * 5. NOTIFY
         *
         * Effect functions are called with the following signature:
         *
         *   effectFunction(inst, path, props, oldProps, info, hasPaths)
         *
         * @param {string} property Property that should trigger the effect
         * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES
         * @param {Object=} effect Effect metadata object
         * @protected
         */

      }, {
        key: '_bindTemplate',


        // -- binding ----------------------------------------------

        /**
         * Equivalent to static `bindTemplate` API but can be called on
         * an instance to add effects at runtime.  See that method for
         * full API docs.
         *
         * This method may be called on the prototype (for prototypical template
         * binding, to avoid creating accessors every instance) once per prototype,
         * and will be called with `runtimeBinding: true` by `_stampTemplate` to
         * create and link an instance of the template metadata associated with a
         * particular stamping.
         *
         * @param {HTMLTemplateElement} template Template containing binding
         *   bindings
         * @param {boolean=} instanceBinding When false (default), performs
         *   "prototypical" binding of the template and overwrites any previously
         *   bound template for the class. When true (as passed from
         *   `_stampTemplate`), the template info is instanced and linked into
         *   the list of bound templates.
         * @return {!TemplateInfo} Template metadata object; for `runtimeBinding`,
         *   this is an instance of the prototypical template info
         * @protected
         */
        value: function _bindTemplate(template, instanceBinding) {
          var templateInfo = this.constructor._parseTemplate(template);
          var wasPreBound = this.__templateInfo == templateInfo;
          // Optimization: since this is called twice for proto-bound templates,
          // don't attempt to recreate accessors if this template was pre-bound
          if (!wasPreBound) {
            for (var prop in templateInfo.propertyEffects) {
              this._createPropertyAccessor(prop);
            }
          }
          if (instanceBinding) {
            // For instance-time binding, create instance of template metadata
            // and link into list of templates if necessary
            templateInfo = /** @type {!TemplateInfo} */Object.create(templateInfo);
            templateInfo.wasPreBound = wasPreBound;
            if (!wasPreBound && this.__templateInfo) {
              var last = this.__templateInfoLast || this.__templateInfo;
              this.__templateInfoLast = last.nextTemplateInfo = templateInfo;
              templateInfo.previousTemplateInfo = last;
              return templateInfo;
            }
          }
          return this.__templateInfo = templateInfo;
        }

        /**
         * Adds a property effect to the given template metadata, which is run
         * at the "propagate" stage of `_propertiesChanged` when the template
         * has been bound to the element via `_bindTemplate`.
         *
         * The `effect` object should match the format in `_addPropertyEffect`.
         *
         * @param {Object} templateInfo Template metadata to add effect to
         * @param {string} prop Property that should trigger the effect
         * @param {Object=} effect Effect metadata object
         * @protected
         */

      }, {
        key: '_stampTemplate',


        /**
         * Stamps the provided template and performs instance-time setup for
         * Polymer template features, including data bindings, declarative event
         * listeners, and the `this.$` map of `id`'s to nodes.  A document fragment
         * is returned containing the stamped DOM, ready for insertion into the
         * DOM.
         *
         * This method may be called more than once; however note that due to
         * `shadycss` polyfill limitations, only styles from templates prepared
         * using `ShadyCSS.prepareTemplate` will be correctly polyfilled (scoped
         * to the shadow root and support CSS custom properties), and note that
         * `ShadyCSS.prepareTemplate` may only be called once per element. As such,
         * any styles required by in runtime-stamped templates must be included
         * in the main element template.
         *
         * @param {!HTMLTemplateElement} template Template to stamp
         * @return {!StampedTemplate} Cloned template content
         * @override
         * @protected
         */
        value: function _stampTemplate(template) {
          // Ensures that created dom is `_enqueueClient`'d to this element so
          // that it can be flushed on next call to `_flushProperties`
          hostStack.beginHosting(this);
          var dom = _get(PropertyEffects.prototype.__proto__ || Object.getPrototypeOf(PropertyEffects.prototype), '_stampTemplate', this).call(this, template);
          hostStack.endHosting(this);
          var templateInfo = /** @type {!TemplateInfo} */this._bindTemplate(template, true);
          // Add template-instance-specific data to instanced templateInfo
          templateInfo.nodeList = dom.nodeList;
          // Capture child nodes to allow unstamping of non-prototypical templates
          if (!templateInfo.wasPreBound) {
            var nodes = templateInfo.childNodes = [];
            for (var n = dom.firstChild; n; n = n.nextSibling) {
              nodes.push(n);
            }
          }
          dom.templateInfo = templateInfo;
          // Setup compound storage, 2-way listeners, and dataHost for bindings
          setupBindings(this, templateInfo);
          // Flush properties into template nodes if already booted
          if (this.__dataReady) {
            runEffects(this, templateInfo.propertyEffects, this.__data, null, false, templateInfo.nodeList);
          }
          return dom;
        }

        /**
         * Removes and unbinds the nodes previously contained in the provided
         * DocumentFragment returned from `_stampTemplate`.
         *
         * @param {!StampedTemplate} dom DocumentFragment previously returned
         *   from `_stampTemplate` associated with the nodes to be removed
         * @protected
         */

      }, {
        key: '_removeBoundDom',
        value: function _removeBoundDom(dom) {
          // Unlink template info
          var templateInfo = dom.templateInfo;
          if (templateInfo.previousTemplateInfo) {
            templateInfo.previousTemplateInfo.nextTemplateInfo = templateInfo.nextTemplateInfo;
          }
          if (templateInfo.nextTemplateInfo) {
            templateInfo.nextTemplateInfo.previousTemplateInfo = templateInfo.previousTemplateInfo;
          }
          if (this.__templateInfoLast == templateInfo) {
            this.__templateInfoLast = templateInfo.previousTemplateInfo;
          }
          templateInfo.previousTemplateInfo = templateInfo.nextTemplateInfo = null;
          // Remove stamped nodes
          var nodes = templateInfo.childNodes;
          for (var i = 0; i < nodes.length; i++) {
            var node = nodes[i];
            node.parentNode.removeChild(node);
          }
        }

        /**
         * Overrides default `TemplateStamp` implementation to add support for
         * parsing bindings from `TextNode`'s' `textContent`.  A `bindings`
         * array is added to `nodeInfo` and populated with binding metadata
         * with information capturing the binding target, and a `parts` array
         * with one or more metadata objects capturing the source(s) of the
         * binding.
         *
         * @override
         * @param {Node} node Node to parse
         * @param {TemplateInfo} templateInfo Template metadata for current template
         * @param {NodeInfo} nodeInfo Node metadata for current template node
         * @return {boolean} `true` if the visited node added node-specific
         *   metadata to `nodeInfo`
         * @protected
         * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
         */

      }, {
        key: 'PROPERTY_EFFECT_TYPES',
        get: function get() {
          return TYPES;
        }
      }], [{
        key: 'addPropertyEffect',
        value: function addPropertyEffect(property, type, effect) {
          this.prototype._addPropertyEffect(property, type, effect);
        }

        /**
         * Creates a single-property observer for the given property.
         *
         * @param {string} property Property name
         * @param {string} methodName Name of observer method to call
         * @param {boolean=} dynamicFn Whether the method name should be included as
         *   a dependency to the effect.
         * @protected
         */

      }, {
        key: 'createPropertyObserver',
        value: function createPropertyObserver(property, methodName, dynamicFn) {
          this.prototype._createPropertyObserver(property, methodName, dynamicFn);
        }

        /**
         * Creates a multi-property "method observer" based on the provided
         * expression, which should be a string in the form of a normal Javascript
         * function signature: `'methodName(arg1, [..., argn])'`.  Each argument
         * should correspond to a property or path in the context of this
         * prototype (or instance), or may be a literal string or number.
         *
         * @param {string} expression Method expression
         * @param {boolean|Object=} dynamicFn Boolean or object map indicating
         *   whether method names should be included as a dependency to the effect.
         * @protected
         */

      }, {
        key: 'createMethodObserver',
        value: function createMethodObserver(expression, dynamicFn) {
          this.prototype._createMethodObserver(expression, dynamicFn);
        }

        /**
         * Causes the setter for the given property to dispatch `<property>-changed`
         * events to notify of changes to the property.
         *
         * @param {string} property Property name
         * @protected
         */

      }, {
        key: 'createNotifyingProperty',
        value: function createNotifyingProperty(property) {
          this.prototype._createNotifyingProperty(property);
        }

        /**
         * Creates a read-only accessor for the given property.
         *
         * To set the property, use the protected `_setProperty` API.
         * To create a custom protected setter (e.g. `_setMyProp()` for
         * property `myProp`), pass `true` for `protectedSetter`.
         *
         * Note, if the property will have other property effects, this method
         * should be called first, before adding other effects.
         *
         * @param {string} property Property name
         * @param {boolean=} protectedSetter Creates a custom protected setter
         *   when `true`.
         * @protected
         */

      }, {
        key: 'createReadOnlyProperty',
        value: function createReadOnlyProperty(property, protectedSetter) {
          this.prototype._createReadOnlyProperty(property, protectedSetter);
        }

        /**
         * Causes the setter for the given property to reflect the property value
         * to a (dash-cased) attribute of the same name.
         *
         * @param {string} property Property name
         * @protected
         */

      }, {
        key: 'createReflectedProperty',
        value: function createReflectedProperty(property) {
          this.prototype._createReflectedProperty(property);
        }

        /**
         * Creates a computed property whose value is set to the result of the
         * method described by the given `expression` each time one or more
         * arguments to the method changes.  The expression should be a string
         * in the form of a normal Javascript function signature:
         * `'methodName(arg1, [..., argn])'`
         *
         * @param {string} property Name of computed property to set
         * @param {string} expression Method expression
         * @param {boolean|Object=} dynamicFn Boolean or object map indicating whether
         *   method names should be included as a dependency to the effect.
         * @protected
         */

      }, {
        key: 'createComputedProperty',
        value: function createComputedProperty(property, expression, dynamicFn) {
          this.prototype._createComputedProperty(property, expression, dynamicFn);
        }

        /**
         * Parses the provided template to ensure binding effects are created
         * for them, and then ensures property accessors are created for any
         * dependent properties in the template.  Binding effects for bound
         * templates are stored in a linked list on the instance so that
         * templates can be efficiently stamped and unstamped.
         *
         * @param {HTMLTemplateElement} template Template containing binding
         *   bindings
         * @return {Object} Template metadata object
         * @protected
         */

      }, {
        key: 'bindTemplate',
        value: function bindTemplate(template) {
          return this.prototype._bindTemplate(template);
        }
      }, {
        key: '_addTemplatePropertyEffect',
        value: function _addTemplatePropertyEffect(templateInfo, prop, effect) {
          var hostProps = templateInfo.hostProps = templateInfo.hostProps || {};
          hostProps[prop] = true;
          var effects = templateInfo.propertyEffects = templateInfo.propertyEffects || {};
          var propEffects = effects[prop] = effects[prop] || [];
          propEffects.push(effect);
        }
      }, {
        key: '_parseTemplateNode',
        value: function _parseTemplateNode(node, templateInfo, nodeInfo) {
          var noted = _get(PropertyEffects.__proto__ || Object.getPrototypeOf(PropertyEffects), '_parseTemplateNode', this).call(this, node, templateInfo, nodeInfo);
          if (node.nodeType === Node.TEXT_NODE) {
            var parts = this._parseBindings(node.textContent, templateInfo);
            if (parts) {
              // Initialize the textContent with any literal parts
              // NOTE: default to a space here so the textNode remains; some browsers
              // (IE) evacipate an empty textNode following cloneNode/importNode.
              node.textContent = literalFromParts(parts) || ' ';
              addBinding(this, templateInfo, nodeInfo, 'text', 'textContent', parts);
              noted = true;
            }
          }
          return noted;
        }

        /**
         * Overrides default `TemplateStamp` implementation to add support for
         * parsing bindings from attributes.  A `bindings`
         * array is added to `nodeInfo` and populated with binding metadata
         * with information capturing the binding target, and a `parts` array
         * with one or more metadata objects capturing the source(s) of the
         * binding.
         *
         * @override
         * @param {Element} node Node to parse
         * @param {TemplateInfo} templateInfo Template metadata for current template
         * @param {NodeInfo} nodeInfo Node metadata for current template node
         * @return {boolean} `true` if the visited node added node-specific
         *   metadata to `nodeInfo`
         * @protected
         * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
         */

      }, {
        key: '_parseTemplateNodeAttribute',
        value: function _parseTemplateNodeAttribute(node, templateInfo, nodeInfo, name, value) {
          var parts = this._parseBindings(value, templateInfo);
          if (parts) {
            // Attribute or property
            var origName = name;
            var kind = 'property';
            if (name[name.length - 1] == '$') {
              name = name.slice(0, -1);
              kind = 'attribute';
            }
            // Initialize attribute bindings with any literal parts
            var literal = literalFromParts(parts);
            if (literal && kind == 'attribute') {
              node.setAttribute(name, literal);
            }
            // Clear attribute before removing, since IE won't allow removing
            // `value` attribute if it previously had a value (can't
            // unconditionally set '' before removing since attributes with `$`
            // can't be set using setAttribute)
            if (node.localName === 'input' && origName === 'value') {
              node.setAttribute(origName, '');
            }
            // Remove annotation
            node.removeAttribute(origName);
            // Case hackery: attributes are lower-case, but bind targets
            // (properties) are case sensitive. Gambit is to map dash-case to
            // camel-case: `foo-bar` becomes `fooBar`.
            // Attribute bindings are excepted.
            if (kind === 'property') {
              name = Polymer.CaseMap.dashToCamelCase(name);
            }
            addBinding(this, templateInfo, nodeInfo, kind, name, parts, literal);
            return true;
          } else {
            return _get(PropertyEffects.__proto__ || Object.getPrototypeOf(PropertyEffects), '_parseTemplateNodeAttribute', this).call(this, node, templateInfo, nodeInfo, name, value);
          }
        }

        /**
         * Overrides default `TemplateStamp` implementation to add support for
         * binding the properties that a nested template depends on to the template
         * as `_host_<property>`.
         *
         * @override
         * @param {Node} node Node to parse
         * @param {TemplateInfo} templateInfo Template metadata for current template
         * @param {NodeInfo} nodeInfo Node metadata for current template node
         * @return {boolean} `true` if the visited node added node-specific
         *   metadata to `nodeInfo`
         * @protected
         * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
         */

      }, {
        key: '_parseTemplateNestedTemplate',
        value: function _parseTemplateNestedTemplate(node, templateInfo, nodeInfo) {
          var noted = _get(PropertyEffects.__proto__ || Object.getPrototypeOf(PropertyEffects), '_parseTemplateNestedTemplate', this).call(this, node, templateInfo, nodeInfo);
          // Merge host props into outer template and add bindings
          var hostProps = nodeInfo.templateInfo.hostProps;
          var mode = '{';
          for (var source in hostProps) {
            var parts = [{ mode: mode, source: source, dependencies: [source] }];
            addBinding(this, templateInfo, nodeInfo, 'property', '_host_' + source, parts);
          }
          return noted;
        }

        /**
         * Called to parse text in a template (either attribute values or
         * textContent) into binding metadata.
         *
         * Any overrides of this method should return an array of binding part
         * metadata  representing one or more bindings found in the provided text
         * and any "literal" text in between.  Any non-literal parts will be passed
         * to `_evaluateBinding` when any dependencies change.  The only required
         * fields of each "part" in the returned array are as follows:
         *
         * - `dependencies` - Array containing trigger metadata for each property
         *   that should trigger the binding to update
         * - `literal` - String containing text if the part represents a literal;
         *   in this case no `dependencies` are needed
         *
         * Additional metadata for use by `_evaluateBinding` may be provided in
         * each part object as needed.
         *
         * The default implementation handles the following types of bindings
         * (one or more may be intermixed with literal strings):
         * - Property binding: `[[prop]]`
         * - Path binding: `[[object.prop]]`
         * - Negated property or path bindings: `[[!prop]]` or `[[!object.prop]]`
         * - Two-way property or path bindings (supports negation):
         *   `{{prop}}`, `{{object.prop}}`, `{{!prop}}` or `{{!object.prop}}`
         * - Inline computed method (supports negation):
         *   `[[compute(a, 'literal', b)]]`, `[[!compute(a, 'literal', b)]]`
         *
         * @param {string} text Text to parse from attribute or textContent
         * @param {Object} templateInfo Current template metadata
         * @return {Array<!BindingPart>} Array of binding part metadata
         * @protected
         */

      }, {
        key: '_parseBindings',
        value: function _parseBindings(text, templateInfo) {
          var parts = [];
          var lastIndex = 0;
          var m = void 0;
          // Example: "literal1{{prop}}literal2[[!compute(foo,bar)]]final"
          // Regex matches:
          //        Iteration 1:  Iteration 2:
          // m[1]: '{{'          '[['
          // m[2]: ''            '!'
          // m[3]: 'prop'        'compute(foo,bar)'
          while ((m = bindingRegex.exec(text)) !== null) {
            // Add literal part
            if (m.index > lastIndex) {
              parts.push({ literal: text.slice(lastIndex, m.index) });
            }
            // Add binding part
            var mode = m[1][0];
            var negate = Boolean(m[2]);
            var source = m[3].trim();
            var customEvent = false,
                notifyEvent = '',
                colon = -1;
            if (mode == '{' && (colon = source.indexOf('::')) > 0) {
              notifyEvent = source.substring(colon + 2);
              source = source.substring(0, colon);
              customEvent = true;
            }
            var signature = parseMethod(source);
            var dependencies = [];
            if (signature) {
              // Inline computed function
              var args = signature.args,
                  methodName = signature.methodName;

              for (var i = 0; i < args.length; i++) {
                var arg = args[i];
                if (!arg.literal) {
                  dependencies.push(arg);
                }
              }
              var dynamicFns = templateInfo.dynamicFns;
              if (dynamicFns && dynamicFns[methodName] || signature.static) {
                dependencies.push(methodName);
                signature.dynamicFn = true;
              }
            } else {
              // Property or path
              dependencies.push(source);
            }
            parts.push({
              source: source, mode: mode, negate: negate, customEvent: customEvent, signature: signature, dependencies: dependencies,
              event: notifyEvent
            });
            lastIndex = bindingRegex.lastIndex;
          }
          // Add a final literal part
          if (lastIndex && lastIndex < text.length) {
            var literal = text.substring(lastIndex);
            if (literal) {
              parts.push({
                literal: literal
              });
            }
          }
          if (parts.length) {
            return parts;
          } else {
            return null;
          }
        }

        /**
         * Called to evaluate a previously parsed binding part based on a set of
         * one or more changed dependencies.
         *
         * @param {this} inst Element that should be used as scope for
         *   binding dependencies
         * @param {BindingPart} part Binding part metadata
         * @param {string} path Property/path that triggered this effect
         * @param {Object} props Bag of current property changes
         * @param {Object} oldProps Bag of previous values for changed properties
         * @param {boolean} hasPaths True with `props` contains one or more paths
         * @return {*} Value the binding part evaluated to
         * @protected
         */

      }, {
        key: '_evaluateBinding',
        value: function _evaluateBinding(inst, part, path, props, oldProps, hasPaths) {
          var value = void 0;
          if (part.signature) {
            value = runMethodEffect(inst, path, props, oldProps, part.signature);
          } else if (path != part.source) {
            value = Polymer.Path.get(inst, part.source);
          } else {
            if (hasPaths && Polymer.Path.isPath(path)) {
              value = Polymer.Path.get(inst, path);
            } else {
              value = inst.__data[path];
            }
          }
          if (part.negate) {
            value = !value;
          }
          return value;
        }
      }]);

      return PropertyEffects;
    }(propertyEffectsBase);

    // make a typing for closure :P


    PropertyEffectsType = PropertyEffects;

    return PropertyEffects;
  });

  /**
   * Helper api for enqueing client dom created by a host element.
   *
   * By default elements are flushed via `_flushProperties` when
   * `connectedCallback` is called. Elements attach their client dom to
   * themselves at `ready` time which results from this first flush.
   * This provides an ordering guarantee that the client dom an element
   * creates is flushed before the element itself (i.e. client `ready`
   * fires before host `ready`).
   *
   * However, if `_flushProperties` is called *before* an element is connected,
   * as for example `Templatize` does, this ordering guarantee cannot be
   * satisfied because no elements are connected. (Note: Bound elements that
   * receive data do become enqueued clients and are properly ordered but
   * unbound elements are not.)
   *
   * To maintain the desired "client before host" ordering guarantee for this
   * case we rely on the "host stack. Client nodes registers themselves with
   * the creating host element when created. This ensures that all client dom
   * is readied in the proper order, maintaining the desired guarantee.
   *
   * @private
   */
  var hostStack = {

    stack: [],

    /**
     * @param {*} inst Instance to add to hostStack
     * @this {hostStack}
     */
    registerHost: function registerHost(inst) {
      if (this.stack.length) {
        var host = this.stack[this.stack.length - 1];
        host._enqueueClient(inst);
      }
    },


    /**
     * @param {*} inst Instance to begin hosting
     * @this {hostStack}
     */
    beginHosting: function beginHosting(inst) {
      this.stack.push(inst);
    },


    /**
     * @param {*} inst Instance to end hosting
     * @this {hostStack}
     */
    endHosting: function endHosting(inst) {
      var stackLen = this.stack.length;
      if (stackLen && this.stack[stackLen - 1] == inst) {
        this.stack.pop();
      }
    }
  };
})();

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

__webpack_require__(1);

__webpack_require__(3);

__webpack_require__(8);

(function () {
  'use strict';

  /** @typedef {{run: function(function(), number=):number, cancel: function(number)}} */

  var AsyncModule = void 0; // eslint-disable-line no-unused-vars

  /**
   * @summary Collapse multiple callbacks into one invocation after a timer.
   * @memberof Polymer
   */

  var Debouncer = function () {
    function Debouncer() {
      _classCallCheck(this, Debouncer);

      this._asyncModule = null;
      this._callback = null;
      this._timer = null;
    }
    /**
     * Sets the scheduler; that is, a module with the Async interface,
     * a callback and optional arguments to be passed to the run function
     * from the async module.
     *
     * @param {!AsyncModule} asyncModule Object with Async interface.
     * @param {function()} callback Callback to run.
     */


    _createClass(Debouncer, [{
      key: 'setConfig',
      value: function setConfig(asyncModule, callback) {
        var _this = this;

        this._asyncModule = asyncModule;
        this._callback = callback;
        this._timer = this._asyncModule.run(function () {
          _this._timer = null;
          _this._callback();
        });
      }
      /**
       * Cancels an active debouncer and returns a reference to itself.
       */

    }, {
      key: 'cancel',
      value: function cancel() {
        if (this.isActive()) {
          this._asyncModule.cancel(this._timer);
          this._timer = null;
        }
      }
      /**
       * Flushes an active debouncer and returns a reference to itself.
       */

    }, {
      key: 'flush',
      value: function flush() {
        if (this.isActive()) {
          this.cancel();
          this._callback();
        }
      }
      /**
       * Returns true if the debouncer is active.
       *
       * @return {boolean} True if active.
       */

    }, {
      key: 'isActive',
      value: function isActive() {
        return this._timer != null;
      }
      /**
       * Creates a debouncer if no debouncer is passed as a parameter
       * or it cancels an active debouncer otherwise. The following
       * example shows how a debouncer can be called multiple times within a
       * microtask and "debounced" such that the provided callback function is
       * called once. Add this method to a custom element:
       *
       * _debounceWork() {
       *   this._debounceJob = Polymer.Debouncer.debounce(this._debounceJob,
       *       Polymer.Async.microTask, () => {
       *     this._doWork();
       *   });
       * }
       *
       * If the `_debounceWork` method is called multiple times within the same
       * microtask, the `_doWork` function will be called only once at the next
       * microtask checkpoint.
       *
       * Note: In testing it is often convenient to avoid asynchrony. To accomplish
       * this with a debouncer, you can use `Polymer.enqueueDebouncer` and
       * `Polymer.flush`. For example, extend the above example by adding
       * `Polymer.enqueueDebouncer(this._debounceJob)` at the end of the
       * `_debounceWork` method. Then in a test, call `Polymer.flush` to ensure
       * the debouncer has completed.
       *
       * @param {Debouncer?} debouncer Debouncer object.
       * @param {!AsyncModule} asyncModule Object with Async interface
       * @param {function()} callback Callback to run.
       * @return {!Debouncer} Returns a debouncer object.
       */

    }], [{
      key: 'debounce',
      value: function debounce(debouncer, asyncModule, callback) {
        if (debouncer instanceof Debouncer) {
          debouncer.cancel();
        } else {
          debouncer = new Debouncer();
        }
        debouncer.setConfig(asyncModule, callback);
        return debouncer;
      }
    }]);

    return Debouncer;
  }();

  Polymer.Debouncer = Debouncer;
})();

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(1);

(function () {
  'use strict';

  var debouncerQueue = [];

  /**
   * Adds a `Polymer.Debouncer` to a list of globally flushable tasks.
   *
   * @memberof Polymer
   * @param {Polymer.Debouncer} debouncer Debouncer to enqueue
   */
  Polymer.enqueueDebouncer = function (debouncer) {
    debouncerQueue.push(debouncer);
  };

  function flushDebouncers() {
    var didFlush = Boolean(debouncerQueue.length);
    while (debouncerQueue.length) {
      try {
        debouncerQueue.shift().flush();
      } catch (e) {
        setTimeout(function () {
          throw e;
        });
      }
    }
    return didFlush;
  }

  /**
   * Forces several classes of asynchronously queued tasks to flush:
   * - Debouncers added via `enqueueDebouncer`
   * - ShadyDOM distribution
   *
   * @memberof Polymer
   */
  Polymer.flush = function () {
    var shadyDOM = void 0,
        debouncers = void 0;
    do {
      shadyDOM = window.ShadyDOM && ShadyDOM.flush();
      if (window.ShadyCSS && window.ShadyCSS.ScopingShim) {
        window.ShadyCSS.ScopingShim.flush();
      }
      debouncers = flushDebouncers();
    } while (shadyDOM || debouncers);
  };
})();

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

__webpack_require__(1);

__webpack_require__(11);

__webpack_require__(9);

(function () {
  'use strict';

  // Base class for HTMLTemplateElement extension that has property effects
  // machinery for propagating host properties to children. This is an ES5
  // class only because Babel (incorrectly) requires super() in the class
  // constructor even though no `this` is used and it returns an instance.

  var newInstance = null;
  /**
   * @constructor
   * @extends {HTMLTemplateElement}
   */
  function HTMLTemplateElementExtension() {
    return newInstance;
  }
  HTMLTemplateElementExtension.prototype = Object.create(HTMLTemplateElement.prototype, {
    constructor: {
      value: HTMLTemplateElementExtension,
      writable: true
    }
  });
  /**
   * @constructor
   * @implements {Polymer_PropertyEffects}
   * @extends {HTMLTemplateElementExtension}
   */
  var DataTemplate = Polymer.PropertyEffects(HTMLTemplateElementExtension);
  /**
   * @constructor
   * @implements {Polymer_MutableData}
   * @extends {DataTemplate}
   */
  var MutableDataTemplate = Polymer.MutableData(DataTemplate);

  // Applies a DataTemplate subclass to a <template> instance
  function upgradeTemplate(template, constructor) {
    newInstance = template;
    Object.setPrototypeOf(template, constructor.prototype);
    new constructor();
    newInstance = null;
  }

  // Base class for TemplateInstance's
  /**
   * @constructor
   * @implements {Polymer_PropertyEffects}
   */
  var base = Polymer.PropertyEffects(function () {
    function _class() {
      _classCallCheck(this, _class);
    }

    return _class;
  }());

  /**
   * @polymer
   * @customElement
   * @appliesMixin Polymer.PropertyEffects
   * @unrestricted
   */

  var TemplateInstanceBase = function (_base) {
    _inherits(TemplateInstanceBase, _base);

    function TemplateInstanceBase(props) {
      _classCallCheck(this, TemplateInstanceBase);

      var _this = _possibleConstructorReturn(this, (TemplateInstanceBase.__proto__ || Object.getPrototypeOf(TemplateInstanceBase)).call(this));

      _this._configureProperties(props);
      _this.root = _this._stampTemplate(_this.__dataHost);
      // Save list of stamped children
      var children = _this.children = [];
      for (var n = _this.root.firstChild; n; n = n.nextSibling) {
        children.push(n);
        n.__templatizeInstance = _this;
      }
      if (_this.__templatizeOwner.__hideTemplateChildren__) {
        _this._showHideChildren(true);
      }
      // Flush props only when props are passed if instance props exist
      // or when there isn't instance props.
      var options = _this.__templatizeOptions;
      if (props && options.instanceProps || !options.instanceProps) {
        _this._enableProperties();
      }
      return _this;
    }
    /**
     * Configure the given `props` by calling `_setPendingProperty`. Also
     * sets any properties stored in `__hostProps`.
     * @private
     * @param {Object} props Object of property name-value pairs to set.
     */


    _createClass(TemplateInstanceBase, [{
      key: '_configureProperties',
      value: function _configureProperties(props) {
        var options = this.__templatizeOptions;
        if (props) {
          for (var iprop in options.instanceProps) {
            if (iprop in props) {
              this._setPendingProperty(iprop, props[iprop]);
            }
          }
        }
        for (var hprop in this.__hostProps) {
          this._setPendingProperty(hprop, this.__dataHost['_host_' + hprop]);
        }
      }
      /**
       * Forwards a host property to this instance.  This method should be
       * called on instances from the `options.forwardHostProp` callback
       * to propagate changes of host properties to each instance.
       *
       * Note this method enqueues the change, which are flushed as a batch.
       *
       * @param {string} prop Property or path name
       * @param {*} value Value of the property to forward
       */

    }, {
      key: 'forwardHostProp',
      value: function forwardHostProp(prop, value) {
        if (this._setPendingPropertyOrPath(prop, value, false, true)) {
          this.__dataHost._enqueueClient(this);
        }
      }
      /**
       * @override
       */

    }, {
      key: '_addEventListenerToNode',
      value: function _addEventListenerToNode(node, eventName, handler) {
        var _this2 = this;

        if (this._methodHost && this.__templatizeOptions.parentModel) {
          // If this instance should be considered a parent model, decorate
          // events this template instance as `model`
          this._methodHost._addEventListenerToNode(node, eventName, function (e) {
            e.model = _this2;
            handler(e);
          });
        } else {
          // Otherwise delegate to the template's host (which could be)
          // another template instance
          var templateHost = this.__dataHost.__dataHost;
          if (templateHost) {
            templateHost._addEventListenerToNode(node, eventName, handler);
          }
        }
      }
      /**
       * Shows or hides the template instance top level child elements. For
       * text nodes, `textContent` is removed while "hidden" and replaced when
       * "shown."
       * @param {boolean} hide Set to true to hide the children;
       * set to false to show them.
       * @protected
       */

    }, {
      key: '_showHideChildren',
      value: function _showHideChildren(hide) {
        var c = this.children;
        for (var i = 0; i < c.length; i++) {
          var n = c[i];
          // Ignore non-changes
          if (Boolean(hide) != Boolean(n.__hideTemplateChildren__)) {
            if (n.nodeType === Node.TEXT_NODE) {
              if (hide) {
                n.__polymerTextContent__ = n.textContent;
                n.textContent = '';
              } else {
                n.textContent = n.__polymerTextContent__;
              }
            } else if (n.style) {
              if (hide) {
                n.__polymerDisplay__ = n.style.display;
                n.style.display = 'none';
              } else {
                n.style.display = n.__polymerDisplay__;
              }
            }
          }
          n.__hideTemplateChildren__ = hide;
          if (n._showHideChildren) {
            n._showHideChildren(hide);
          }
        }
      }
      /**
       * Overrides default property-effects implementation to intercept
       * textContent bindings while children are "hidden" and cache in
       * private storage for later retrieval.
       *
       * @override
       */

    }, {
      key: '_setUnmanagedPropertyToNode',
      value: function _setUnmanagedPropertyToNode(node, prop, value) {
        if (node.__hideTemplateChildren__ && node.nodeType == Node.TEXT_NODE && prop == 'textContent') {
          node.__polymerTextContent__ = value;
        } else {
          _get(TemplateInstanceBase.prototype.__proto__ || Object.getPrototypeOf(TemplateInstanceBase.prototype), '_setUnmanagedPropertyToNode', this).call(this, node, prop, value);
        }
      }
      /**
       * Find the parent model of this template instance.  The parent model
       * is either another templatize instance that had option `parentModel: true`,
       * or else the host element.
       *
       * @return {Polymer_PropertyEffects} The parent model of this instance
       */

    }, {
      key: 'parentModel',
      get: function get() {
        var model = this.__parentModel;
        if (!model) {
          var options = void 0;
          model = this;
          do {
            // A template instance's `__dataHost` is a <template>
            // `model.__dataHost.__dataHost` is the template's host
            model = model.__dataHost.__dataHost;
          } while ((options = model.__templatizeOptions) && !options.parentModel);
          this.__parentModel = model;
        }
        return model;
      }
    }]);

    return TemplateInstanceBase;
  }(base);

  /** @type {!DataTemplate} */


  TemplateInstanceBase.prototype.__dataHost;
  /** @type {!TemplatizeOptions} */
  TemplateInstanceBase.prototype.__templatizeOptions;
  /** @type {!Polymer_PropertyEffects} */
  TemplateInstanceBase.prototype._methodHost;
  /** @type {!Object} */
  TemplateInstanceBase.prototype.__templatizeOwner;
  /** @type {!Object} */
  TemplateInstanceBase.prototype.__hostProps;

  /**
   * @constructor
   * @extends {TemplateInstanceBase}
   * @implements {Polymer_MutableData}
   */
  var MutableTemplateInstanceBase = Polymer.MutableData(TemplateInstanceBase);

  function findMethodHost(template) {
    // Technically this should be the owner of the outermost template.
    // In shadow dom, this is always getRootNode().host, but we can
    // approximate this via cooperation with our dataHost always setting
    // `_methodHost` as long as there were bindings (or id's) on this
    // instance causing it to get a dataHost.
    var templateHost = template.__dataHost;
    return templateHost && templateHost._methodHost || templateHost;
  }

  /* eslint-disable valid-jsdoc */
  /**
   * @suppress {missingProperties} class.prototype is not defined for some reason
   */
  function createTemplatizerClass(template, templateInfo, options) {
    // Anonymous class created by the templatize
    var base = options.mutableData ? MutableTemplateInstanceBase : TemplateInstanceBase;
    /**
     * @constructor
     * @extends {base}
     */
    var klass = function (_base2) {
      _inherits(klass, _base2);

      function klass() {
        _classCallCheck(this, klass);

        return _possibleConstructorReturn(this, (klass.__proto__ || Object.getPrototypeOf(klass)).apply(this, arguments));
      }

      return klass;
    }(base);
    klass.prototype.__templatizeOptions = options;
    klass.prototype._bindTemplate(template);
    addNotifyEffects(klass, template, templateInfo, options);
    return klass;
  }

  /**
   * @suppress {missingProperties} class.prototype is not defined for some reason
   */
  function addPropagateEffects(template, templateInfo, options) {
    var userForwardHostProp = options.forwardHostProp;
    if (userForwardHostProp) {
      // Provide data API and property effects on memoized template class
      var klass = templateInfo.templatizeTemplateClass;
      if (!klass) {
        var _base3 = options.mutableData ? MutableDataTemplate : DataTemplate;
        klass = templateInfo.templatizeTemplateClass = function (_base4) {
          _inherits(TemplatizedTemplate, _base4);

          function TemplatizedTemplate() {
            _classCallCheck(this, TemplatizedTemplate);

            return _possibleConstructorReturn(this, (TemplatizedTemplate.__proto__ || Object.getPrototypeOf(TemplatizedTemplate)).apply(this, arguments));
          }

          return TemplatizedTemplate;
        }(_base3);
        // Add template - >instances effects
        // and host <- template effects
        var hostProps = templateInfo.hostProps;
        for (var prop in hostProps) {
          klass.prototype._addPropertyEffect('_host_' + prop, klass.prototype.PROPERTY_EFFECT_TYPES.PROPAGATE, { fn: createForwardHostPropEffect(prop, userForwardHostProp) });
          klass.prototype._createNotifyingProperty('_host_' + prop);
        }
      }
      upgradeTemplate(template, klass);
      // Mix any pre-bound data into __data; no need to flush this to
      // instances since they pull from the template at instance-time
      if (template.__dataProto) {
        // Note, generally `__dataProto` could be chained, but it's guaranteed
        // to not be since this is a vanilla template we just added effects to
        Object.assign(template.__data, template.__dataProto);
      }
      // Clear any pending data for performance
      template.__dataTemp = {};
      template.__dataPending = null;
      template.__dataOld = null;
      template._enableProperties();
    }
  }
  /* eslint-enable valid-jsdoc */

  function createForwardHostPropEffect(hostProp, userForwardHostProp) {
    return function forwardHostProp(template, prop, props) {
      userForwardHostProp.call(template.__templatizeOwner, prop.substring('_host_'.length), props[prop]);
    };
  }

  function addNotifyEffects(klass, template, templateInfo, options) {
    var hostProps = templateInfo.hostProps || {};
    for (var iprop in options.instanceProps) {
      delete hostProps[iprop];
      var userNotifyInstanceProp = options.notifyInstanceProp;
      if (userNotifyInstanceProp) {
        klass.prototype._addPropertyEffect(iprop, klass.prototype.PROPERTY_EFFECT_TYPES.NOTIFY, { fn: createNotifyInstancePropEffect(iprop, userNotifyInstanceProp) });
      }
    }
    if (options.forwardHostProp && template.__dataHost) {
      for (var hprop in hostProps) {
        klass.prototype._addPropertyEffect(hprop, klass.prototype.PROPERTY_EFFECT_TYPES.NOTIFY, { fn: createNotifyHostPropEffect() });
      }
    }
  }

  function createNotifyInstancePropEffect(instProp, userNotifyInstanceProp) {
    return function notifyInstanceProp(inst, prop, props) {
      userNotifyInstanceProp.call(inst.__templatizeOwner, inst, prop, props[prop]);
    };
  }

  function createNotifyHostPropEffect() {
    return function notifyHostProp(inst, prop, props) {
      inst.__dataHost._setPendingPropertyOrPath('_host_' + prop, props[prop], true, true);
    };
  }

  /**
   * Module for preparing and stamping instances of templates that utilize
   * Polymer's data-binding and declarative event listener features.
   *
   * Example:
   *
   *     // Get a template from somewhere, e.g. light DOM
   *     let template = this.querySelector('template');
   *     // Prepare the template
   *     let TemplateClass = Polymer.Templatize.templatize(template);
   *     // Instance the template with an initial data model
   *     let instance = new TemplateClass({myProp: 'initial'});
   *     // Insert the instance's DOM somewhere, e.g. element's shadow DOM
   *     this.shadowRoot.appendChild(instance.root);
   *     // Changing a property on the instance will propagate to bindings
   *     // in the template
   *     instance.myProp = 'new value';
   *
   * The `options` dictionary passed to `templatize` allows for customizing
   * features of the generated template class, including how outer-scope host
   * properties should be forwarded into template instances, how any instance
   * properties added into the template's scope should be notified out to
   * the host, and whether the instance should be decorated as a "parent model"
   * of any event handlers.
   *
   *     // Customze property forwarding and event model decoration
   *     let TemplateClass = Polymer.Templatize.templatize(template, this, {
   *       parentModel: true,
   *       instanceProps: {...},
   *       forwardHostProp(property, value) {...},
   *       notifyInstanceProp(instance, property, value) {...},
   *     });
   *
   *
   * @namespace
   * @memberof Polymer
   * @summary Module for preparing and stamping instances of templates
   *   utilizing Polymer templating features.
   */

  var Templatize = {

    /**
     * Returns an anonymous `Polymer.PropertyEffects` class bound to the
     * `<template>` provided.  Instancing the class will result in the
     * template being stamped into document fragment stored as the instance's
     * `root` property, after which it can be appended to the DOM.
     *
     * Templates may utilize all Polymer data-binding features as well as
     * declarative event listeners.  Event listeners and inline computing
     * functions in the template will be called on the host of the template.
     *
     * The constructor returned takes a single argument dictionary of initial
     * property values to propagate into template bindings.  Additionally
     * host properties can be forwarded in, and instance properties can be
     * notified out by providing optional callbacks in the `options` dictionary.
     *
     * Valid configuration in `options` are as follows:
     *
     * - `forwardHostProp(property, value)`: Called when a property referenced
     *   in the template changed on the template's host. As this library does
     *   not retain references to templates instanced by the user, it is the
     *   templatize owner's responsibility to forward host property changes into
     *   user-stamped instances.  The `instance.forwardHostProp(property, value)`
     *    method on the generated class should be called to forward host
     *   properties into the template to prevent unnecessary property-changed
     *   notifications. Any properties referenced in the template that are not
     *   defined in `instanceProps` will be notified up to the template's host
     *   automatically.
     * - `instanceProps`: Dictionary of property names that will be added
     *   to the instance by the templatize owner.  These properties shadow any
     *   host properties, and changes within the template to these properties
     *   will result in `notifyInstanceProp` being called.
     * - `mutableData`: When `true`, the generated class will skip strict
     *   dirty-checking for objects and arrays (always consider them to be
     *   "dirty").
     * - `notifyInstanceProp(instance, property, value)`: Called when
     *   an instance property changes.  Users may choose to call `notifyPath`
     *   on e.g. the owner to notify the change.
     * - `parentModel`: When `true`, events handled by declarative event listeners
     *   (`on-event="handler"`) will be decorated with a `model` property pointing
     *   to the template instance that stamped it.  It will also be returned
     *   from `instance.parentModel` in cases where template instance nesting
     *   causes an inner model to shadow an outer model.
     *
     * Note that the class returned from `templatize` is generated only once
     * for a given `<template>` using `options` from the first call for that
     * template, and the cached class is returned for all subsequent calls to
     * `templatize` for that template.  As such, `options` callbacks should not
     * close over owner-specific properties since only the first `options` is
     * used; rather, callbacks are called bound to the `owner`, and so context
     * needed from the callbacks (such as references to `instances` stamped)
     * should be stored on the `owner` such that they can be retrieved via `this`.
     *
     * @memberof Polymer.Templatize
     * @param {!HTMLTemplateElement} template Template to templatize
     * @param {!Polymer_PropertyEffects} owner Owner of the template instances;
     *   any optional callbacks will be bound to this owner.
     * @param {Object=} options Options dictionary (see summary for details)
     * @return {function(new:TemplateInstanceBase)} Generated class bound to the template
     *   provided
     * @suppress {invalidCasts}
     */
    templatize: function templatize(template, owner, options) {
      options = /** @type {!TemplatizeOptions} */options || {};
      if (template.__templatizeOwner) {
        throw new Error('A <template> can only be templatized once');
      }
      template.__templatizeOwner = owner;
      var templateInfo = owner.constructor._parseTemplate(template);
      // Get memoized base class for the prototypical template, which
      // includes property effects for binding template & forwarding
      var baseClass = templateInfo.templatizeInstanceClass;
      if (!baseClass) {
        baseClass = createTemplatizerClass(template, templateInfo, options);
        templateInfo.templatizeInstanceClass = baseClass;
      }
      // Host property forwarding must be installed onto template instance
      addPropagateEffects(template, templateInfo, options);
      // Subclass base class and add reference for this specific template
      var klass = function (_baseClass) {
        _inherits(TemplateInstance, _baseClass);

        function TemplateInstance() {
          _classCallCheck(this, TemplateInstance);

          return _possibleConstructorReturn(this, (TemplateInstance.__proto__ || Object.getPrototypeOf(TemplateInstance)).apply(this, arguments));
        }

        return TemplateInstance;
      }(baseClass);
      klass.prototype._methodHost = findMethodHost(template);
      klass.prototype.__dataHost = template;
      klass.prototype.__templatizeOwner = owner;
      klass.prototype.__hostProps = templateInfo.hostProps;
      return (/** @type {function(new:TemplateInstanceBase)} */klass
      );
    },


    /**
     * Returns the template "model" associated with a given element, which
     * serves as the binding scope for the template instance the element is
     * contained in. A template model is an instance of
     * `TemplateInstanceBase`, and should be used to manipulate data
     * associated with this template instance.
     *
     * Example:
     *
     *   let model = modelForElement(el);
     *   if (model.index < 10) {
     *     model.set('item.checked', true);
     *   }
     *
     * @memberof Polymer.Templatize
     * @param {HTMLTemplateElement} template The model will be returned for
     *   elements stamped from this template
     * @param {Node} node Node for which to return a template model.
     * @return {TemplateInstanceBase} Template instance representing the
     *   binding scope for the element
     */
    modelForElement: function modelForElement(template, node) {
      var model = void 0;
      while (node) {
        // An element with a __templatizeInstance marks the top boundary
        // of a scope; walk up until we find one, and then ensure that
        // its __dataHost matches `this`, meaning this dom-repeat stamped it
        if (model = node.__templatizeInstance) {
          // Found an element stamped by another template; keep walking up
          // from its __dataHost
          if (model.__dataHost != template) {
            node = model.__dataHost;
          } else {
            return model;
          }
        } else {
          // Still in a template scope, keep going up until
          // a __templatizeInstance is found
          node = node.parentNode;
        }
      }
      return null;
    }
  };

  Polymer.Templatize = Templatize;
  Polymer.TemplateInstanceBase = TemplateInstanceBase;
})();

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

__webpack_require__(17);

/**
 * @polymerBehavior Polymer.AppLayoutBehavior
 **/
Polymer.AppLayoutBehavior = [Polymer.IronResizableBehavior, {

  listeners: {
    'app-reset-layout': '_appResetLayoutHandler',
    'iron-resize': 'resetLayout'
  },

  attached: function attached() {
    this.fire('app-reset-layout');
  },

  _appResetLayoutHandler: function _appResetLayoutHandler(e) {
    if (Polymer.dom(e).path[0] === this) {
      return;
    }
    this.resetLayout();
    e.stopPropagation();
  },

  _updateLayoutStates: function _updateLayoutStates() {
    console.error('unimplemented');
  },

  /**
   * Resets the layout. If you changed the size of this element via CSS
   * you can notify the changes by either firing the `iron-resize` event
   * or calling `resetLayout` directly.
   *
   * @method resetLayout
   */
  resetLayout: function resetLayout() {
    // Polymer v2.x
    var self = this;
    var cb = this._updateLayoutStates.bind(this);
    if (Polymer.Async && Polymer.Async.animationFrame) {
      this._layoutDebouncer = Polymer.Debouncer.debounce(this._layoutDebouncer, Polymer.Async.animationFrame, cb);
      Polymer.enqueueDebouncer(this._layoutDebouncer);
    }
    // Polymer v1.x
    else {
        this.debounce('resetLayout', cb);
      }
    this._notifyDescendantResize();
  },

  _notifyLayoutChanged: function _notifyLayoutChanged() {
    var self = this;
    // TODO: the event `app-reset-layout` can be fired synchronously
    // as long as `_updateLayoutStates` waits for all the microtasks after rAF.
    // E.g. requestAnimationFrame(setTimeOut())
    requestAnimationFrame(function () {
      self.fire('app-reset-layout');
    });
  },

  _notifyDescendantResize: function _notifyDescendantResize() {
    if (!this.isAttached) {
      return;
    }
    this._interestedResizables.forEach(function (resizable) {
      if (this.resizerShouldNotify(resizable)) {
        this._notifyDescendant(resizable);
      }
    }, this);
  }
}];

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

(function () {
  'use strict';

  /**
   * Chrome uses an older version of DOM Level 3 Keyboard Events
   *
   * Most keys are labeled as text, but some are Unicode codepoints.
   * Values taken from: http://www.w3.org/TR/2007/WD-DOM-Level-3-Events-20071221/keyset.html#KeySet-Set
   */

  var KEY_IDENTIFIER = {
    'U+0008': 'backspace',
    'U+0009': 'tab',
    'U+001B': 'esc',
    'U+0020': 'space',
    'U+007F': 'del'
  };

  /**
   * Special table for KeyboardEvent.keyCode.
   * KeyboardEvent.keyIdentifier is better, and KeyBoardEvent.key is even better
   * than that.
   *
   * Values from: https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent.keyCode#Value_of_keyCode
   */
  var KEY_CODE = {
    8: 'backspace',
    9: 'tab',
    13: 'enter',
    27: 'esc',
    33: 'pageup',
    34: 'pagedown',
    35: 'end',
    36: 'home',
    32: 'space',
    37: 'left',
    38: 'up',
    39: 'right',
    40: 'down',
    46: 'del',
    106: '*'
  };

  /**
   * MODIFIER_KEYS maps the short name for modifier keys used in a key
   * combo string to the property name that references those same keys
   * in a KeyboardEvent instance.
   */
  var MODIFIER_KEYS = {
    'shift': 'shiftKey',
    'ctrl': 'ctrlKey',
    'alt': 'altKey',
    'meta': 'metaKey'
  };

  /**
   * KeyboardEvent.key is mostly represented by printable character made by
   * the keyboard, with unprintable keys labeled nicely.
   *
   * However, on OS X, Alt+char can make a Unicode character that follows an
   * Apple-specific mapping. In this case, we fall back to .keyCode.
   */
  var KEY_CHAR = /[a-z0-9*]/;

  /**
   * Matches a keyIdentifier string.
   */
  var IDENT_CHAR = /U\+/;

  /**
   * Matches arrow keys in Gecko 27.0+
   */
  var ARROW_KEY = /^arrow/;

  /**
   * Matches space keys everywhere (notably including IE10's exceptional name
   * `spacebar`).
   */
  var SPACE_KEY = /^space(bar)?/;

  /**
   * Matches ESC key.
   *
   * Value from: http://w3c.github.io/uievents-key/#key-Escape
   */
  var ESC_KEY = /^escape$/;

  /**
   * Transforms the key.
   * @param {string} key The KeyBoardEvent.key
   * @param {Boolean} [noSpecialChars] Limits the transformation to
   * alpha-numeric characters.
   */
  function transformKey(key, noSpecialChars) {
    var validKey = '';
    if (key) {
      var lKey = key.toLowerCase();
      if (lKey === ' ' || SPACE_KEY.test(lKey)) {
        validKey = 'space';
      } else if (ESC_KEY.test(lKey)) {
        validKey = 'esc';
      } else if (lKey.length == 1) {
        if (!noSpecialChars || KEY_CHAR.test(lKey)) {
          validKey = lKey;
        }
      } else if (ARROW_KEY.test(lKey)) {
        validKey = lKey.replace('arrow', '');
      } else if (lKey == 'multiply') {
        // numpad '*' can map to Multiply on IE/Windows
        validKey = '*';
      } else {
        validKey = lKey;
      }
    }
    return validKey;
  }

  function transformKeyIdentifier(keyIdent) {
    var validKey = '';
    if (keyIdent) {
      if (keyIdent in KEY_IDENTIFIER) {
        validKey = KEY_IDENTIFIER[keyIdent];
      } else if (IDENT_CHAR.test(keyIdent)) {
        keyIdent = parseInt(keyIdent.replace('U+', '0x'), 16);
        validKey = String.fromCharCode(keyIdent).toLowerCase();
      } else {
        validKey = keyIdent.toLowerCase();
      }
    }
    return validKey;
  }

  function transformKeyCode(keyCode) {
    var validKey = '';
    if (Number(keyCode)) {
      if (keyCode >= 65 && keyCode <= 90) {
        // ascii a-z
        // lowercase is 32 offset from uppercase
        validKey = String.fromCharCode(32 + keyCode);
      } else if (keyCode >= 112 && keyCode <= 123) {
        // function keys f1-f12
        validKey = 'f' + (keyCode - 112 + 1);
      } else if (keyCode >= 48 && keyCode <= 57) {
        // top 0-9 keys
        validKey = String(keyCode - 48);
      } else if (keyCode >= 96 && keyCode <= 105) {
        // num pad 0-9
        validKey = String(keyCode - 96);
      } else {
        validKey = KEY_CODE[keyCode];
      }
    }
    return validKey;
  }

  /**
    * Calculates the normalized key for a KeyboardEvent.
    * @param {KeyboardEvent} keyEvent
    * @param {Boolean} [noSpecialChars] Set to true to limit keyEvent.key
    * transformation to alpha-numeric chars. This is useful with key
    * combinations like shift + 2, which on FF for MacOS produces
    * keyEvent.key = @
    * To get 2 returned, set noSpecialChars = true
    * To get @ returned, set noSpecialChars = false
   */
  function normalizedKeyForEvent(keyEvent, noSpecialChars) {
    // Fall back from .key, to .detail.key for artifical keyboard events,
    // and then to deprecated .keyIdentifier and .keyCode.
    if (keyEvent.key) {
      return transformKey(keyEvent.key, noSpecialChars);
    }
    if (keyEvent.detail && keyEvent.detail.key) {
      return transformKey(keyEvent.detail.key, noSpecialChars);
    }
    return transformKeyIdentifier(keyEvent.keyIdentifier) || transformKeyCode(keyEvent.keyCode) || '';
  }

  function keyComboMatchesEvent(keyCombo, event) {
    // For combos with modifiers we support only alpha-numeric keys
    var keyEvent = normalizedKeyForEvent(event, keyCombo.hasModifiers);
    return keyEvent === keyCombo.key && (!keyCombo.hasModifiers || !!event.shiftKey === !!keyCombo.shiftKey && !!event.ctrlKey === !!keyCombo.ctrlKey && !!event.altKey === !!keyCombo.altKey && !!event.metaKey === !!keyCombo.metaKey);
  }

  function parseKeyComboString(keyComboString) {
    if (keyComboString.length === 1) {
      return {
        combo: keyComboString,
        key: keyComboString,
        event: 'keydown'
      };
    }
    return keyComboString.split('+').reduce(function (parsedKeyCombo, keyComboPart) {
      var eventParts = keyComboPart.split(':');
      var keyName = eventParts[0];
      var event = eventParts[1];

      if (keyName in MODIFIER_KEYS) {
        parsedKeyCombo[MODIFIER_KEYS[keyName]] = true;
        parsedKeyCombo.hasModifiers = true;
      } else {
        parsedKeyCombo.key = keyName;
        parsedKeyCombo.event = event || 'keydown';
      }

      return parsedKeyCombo;
    }, {
      combo: keyComboString.split(':').shift()
    });
  }

  function parseEventString(eventString) {
    return eventString.trim().split(' ').map(function (keyComboString) {
      return parseKeyComboString(keyComboString);
    });
  }

  /**
   * `Polymer.IronA11yKeysBehavior` provides a normalized interface for processing
   * keyboard commands that pertain to [WAI-ARIA best practices](http://www.w3.org/TR/wai-aria-practices/#kbd_general_binding).
   * The element takes care of browser differences with respect to Keyboard events
   * and uses an expressive syntax to filter key presses.
   *
   * Use the `keyBindings` prototype property to express what combination of keys
   * will trigger the callback. A key binding has the format
   * `"KEY+MODIFIER:EVENT": "callback"` (`"KEY": "callback"` or
   * `"KEY:EVENT": "callback"` are valid as well). Some examples:
   *
   *      keyBindings: {
   *        'space': '_onKeydown', // same as 'space:keydown'
   *        'shift+tab': '_onKeydown',
   *        'enter:keypress': '_onKeypress',
   *        'esc:keyup': '_onKeyup'
   *      }
   *
   * The callback will receive with an event containing the following information in `event.detail`:
   *
   *      _onKeydown: function(event) {
   *        console.log(event.detail.combo); // KEY+MODIFIER, e.g. "shift+tab"
   *        console.log(event.detail.key); // KEY only, e.g. "tab"
   *        console.log(event.detail.event); // EVENT, e.g. "keydown"
   *        console.log(event.detail.keyboardEvent); // the original KeyboardEvent
   *      }
   *
   * Use the `keyEventTarget` attribute to set up event handlers on a specific
   * node.
   *
   * See the [demo source code](https://github.com/PolymerElements/iron-a11y-keys-behavior/blob/master/demo/x-key-aware.html)
   * for an example.
   *
   * @demo demo/index.html
   * @polymerBehavior
   */
  Polymer.IronA11yKeysBehavior = {
    properties: {
      /**
       * The EventTarget that will be firing relevant KeyboardEvents. Set it to
       * `null` to disable the listeners.
       * @type {?EventTarget}
       */
      keyEventTarget: {
        type: Object,
        value: function value() {
          return this;
        }
      },

      /**
       * If true, this property will cause the implementing element to
       * automatically stop propagation on any handled KeyboardEvents.
       */
      stopKeyboardEventPropagation: {
        type: Boolean,
        value: false
      },

      _boundKeyHandlers: {
        type: Array,
        value: function value() {
          return [];
        }
      },

      // We use this due to a limitation in IE10 where instances will have
      // own properties of everything on the "prototype".
      _imperativeKeyBindings: {
        type: Object,
        value: function value() {
          return {};
        }
      }
    },

    observers: ['_resetKeyEventListeners(keyEventTarget, _boundKeyHandlers)'],

    /**
     * To be used to express what combination of keys  will trigger the relative
     * callback. e.g. `keyBindings: { 'esc': '_onEscPressed'}`
     * @type {!Object}
     */
    keyBindings: {},

    registered: function registered() {
      this._prepKeyBindings();
    },

    attached: function attached() {
      this._listenKeyEventListeners();
    },

    detached: function detached() {
      this._unlistenKeyEventListeners();
    },

    /**
     * Can be used to imperatively add a key binding to the implementing
     * element. This is the imperative equivalent of declaring a keybinding
     * in the `keyBindings` prototype property.
     *
     * @param {string} eventString
     * @param {string} handlerName
     */
    addOwnKeyBinding: function addOwnKeyBinding(eventString, handlerName) {
      this._imperativeKeyBindings[eventString] = handlerName;
      this._prepKeyBindings();
      this._resetKeyEventListeners();
    },

    /**
     * When called, will remove all imperatively-added key bindings.
     */
    removeOwnKeyBindings: function removeOwnKeyBindings() {
      this._imperativeKeyBindings = {};
      this._prepKeyBindings();
      this._resetKeyEventListeners();
    },

    /**
     * Returns true if a keyboard event matches `eventString`.
     *
     * @param {KeyboardEvent} event
     * @param {string} eventString
     * @return {boolean}
     */
    keyboardEventMatchesKeys: function keyboardEventMatchesKeys(event, eventString) {
      var keyCombos = parseEventString(eventString);
      for (var i = 0; i < keyCombos.length; ++i) {
        if (keyComboMatchesEvent(keyCombos[i], event)) {
          return true;
        }
      }
      return false;
    },

    _collectKeyBindings: function _collectKeyBindings() {
      var keyBindings = this.behaviors.map(function (behavior) {
        return behavior.keyBindings;
      });

      if (keyBindings.indexOf(this.keyBindings) === -1) {
        keyBindings.push(this.keyBindings);
      }

      return keyBindings;
    },

    _prepKeyBindings: function _prepKeyBindings() {
      this._keyBindings = {};

      this._collectKeyBindings().forEach(function (keyBindings) {
        for (var eventString in keyBindings) {
          this._addKeyBinding(eventString, keyBindings[eventString]);
        }
      }, this);

      for (var eventString in this._imperativeKeyBindings) {
        this._addKeyBinding(eventString, this._imperativeKeyBindings[eventString]);
      }

      // Give precedence to combos with modifiers to be checked first.
      for (var eventName in this._keyBindings) {
        this._keyBindings[eventName].sort(function (kb1, kb2) {
          var b1 = kb1[0].hasModifiers;
          var b2 = kb2[0].hasModifiers;
          return b1 === b2 ? 0 : b1 ? -1 : 1;
        });
      }
    },

    _addKeyBinding: function _addKeyBinding(eventString, handlerName) {
      parseEventString(eventString).forEach(function (keyCombo) {
        this._keyBindings[keyCombo.event] = this._keyBindings[keyCombo.event] || [];

        this._keyBindings[keyCombo.event].push([keyCombo, handlerName]);
      }, this);
    },

    _resetKeyEventListeners: function _resetKeyEventListeners() {
      this._unlistenKeyEventListeners();

      if (this.isAttached) {
        this._listenKeyEventListeners();
      }
    },

    _listenKeyEventListeners: function _listenKeyEventListeners() {
      if (!this.keyEventTarget) {
        return;
      }
      Object.keys(this._keyBindings).forEach(function (eventName) {
        var keyBindings = this._keyBindings[eventName];
        var boundKeyHandler = this._onKeyBindingEvent.bind(this, keyBindings);

        this._boundKeyHandlers.push([this.keyEventTarget, eventName, boundKeyHandler]);

        this.keyEventTarget.addEventListener(eventName, boundKeyHandler);
      }, this);
    },

    _unlistenKeyEventListeners: function _unlistenKeyEventListeners() {
      var keyHandlerTuple;
      var keyEventTarget;
      var eventName;
      var boundKeyHandler;

      while (this._boundKeyHandlers.length) {
        // My kingdom for block-scope binding and destructuring assignment..
        keyHandlerTuple = this._boundKeyHandlers.pop();
        keyEventTarget = keyHandlerTuple[0];
        eventName = keyHandlerTuple[1];
        boundKeyHandler = keyHandlerTuple[2];

        keyEventTarget.removeEventListener(eventName, boundKeyHandler);
      }
    },

    _onKeyBindingEvent: function _onKeyBindingEvent(keyBindings, event) {
      if (this.stopKeyboardEventPropagation) {
        event.stopPropagation();
      }

      // if event has been already prevented, don't do anything
      if (event.defaultPrevented) {
        return;
      }

      for (var i = 0; i < keyBindings.length; i++) {
        var keyCombo = keyBindings[i][0];
        var handlerName = keyBindings[i][1];
        if (keyComboMatchesEvent(keyCombo, event)) {
          this._triggerKeyHandler(keyCombo, handlerName, event);
          // exit the loop if eventDefault was prevented
          if (event.defaultPrevented) {
            return;
          }
        }
      }
    },

    _triggerKeyHandler: function _triggerKeyHandler(keyCombo, handlerName, keyboardEvent) {
      var detail = Object.create(keyCombo);
      detail.keyboardEvent = keyboardEvent;
      var event = new CustomEvent(keyCombo.event, {
        detail: detail,
        cancelable: true
      });
      this[handlerName].call(this, event);
      if (event.defaultPrevented) {
        keyboardEvent.preventDefault();
      }
    }
  };
})();

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

/**
 * `IronResizableBehavior` is a behavior that can be used in Polymer elements to
 * coordinate the flow of resize events between "resizers" (elements that control the
 * size or hidden state of their children) and "resizables" (elements that need to be
 * notified when they are resized or un-hidden by their parents in order to take
 * action on their new measurements).
 *
 * Elements that perform measurement should add the `IronResizableBehavior` behavior to
 * their element definition and listen for the `iron-resize` event on themselves.
 * This event will be fired when they become showing after having been hidden,
 * when they are resized explicitly by another resizable, or when the window has been
 * resized.
 *
 * Note, the `iron-resize` event is non-bubbling.
 *
 * @polymerBehavior Polymer.IronResizableBehavior
 * @demo demo/index.html
 **/
Polymer.IronResizableBehavior = {
  properties: {
    /**
     * The closest ancestor element that implements `IronResizableBehavior`.
     */
    _parentResizable: {
      type: Object,
      observer: '_parentResizableChanged'
    },

    /**
     * True if this element is currently notifying its descendant elements of
     * resize.
     */
    _notifyingDescendant: {
      type: Boolean,
      value: false
    }
  },

  listeners: {
    'iron-request-resize-notifications': '_onIronRequestResizeNotifications'
  },

  created: function created() {
    // We don't really need property effects on these, and also we want them
    // to be created before the `_parentResizable` observer fires:
    this._interestedResizables = [];
    this._boundNotifyResize = this.notifyResize.bind(this);
  },

  attached: function attached() {
    this._requestResizeNotifications();
  },

  detached: function detached() {
    if (this._parentResizable) {
      this._parentResizable.stopResizeNotificationsFor(this);
    } else {
      window.removeEventListener('resize', this._boundNotifyResize);
    }

    this._parentResizable = null;
  },

  /**
   * Can be called to manually notify a resizable and its descendant
   * resizables of a resize change.
   */
  notifyResize: function notifyResize() {
    if (!this.isAttached) {
      return;
    }

    this._interestedResizables.forEach(function (resizable) {
      if (this.resizerShouldNotify(resizable)) {
        this._notifyDescendant(resizable);
      }
    }, this);

    this._fireResize();
  },

  /**
   * Used to assign the closest resizable ancestor to this resizable
   * if the ancestor detects a request for notifications.
   */
  assignParentResizable: function assignParentResizable(parentResizable) {
    this._parentResizable = parentResizable;
  },

  /**
   * Used to remove a resizable descendant from the list of descendants
   * that should be notified of a resize change.
   */
  stopResizeNotificationsFor: function stopResizeNotificationsFor(target) {
    var index = this._interestedResizables.indexOf(target);

    if (index > -1) {
      this._interestedResizables.splice(index, 1);
      this.unlisten(target, 'iron-resize', '_onDescendantIronResize');
    }
  },

  /**
   * This method can be overridden to filter nested elements that should or
   * should not be notified by the current element. Return true if an element
   * should be notified, or false if it should not be notified.
   *
   * @param {HTMLElement} element A candidate descendant element that
   * implements `IronResizableBehavior`.
   * @return {boolean} True if the `element` should be notified of resize.
   */
  resizerShouldNotify: function resizerShouldNotify(element) {
    return true;
  },

  _onDescendantIronResize: function _onDescendantIronResize(event) {
    if (this._notifyingDescendant) {
      event.stopPropagation();
      return;
    }

    // NOTE(cdata): In ShadowDOM, event retargeting makes echoing of the
    // otherwise non-bubbling event "just work." We do it manually here for
    // the case where Polymer is not using shadow roots for whatever reason:
    if (!Polymer.Settings.useShadow) {
      this._fireResize();
    }
  },

  _fireResize: function _fireResize() {
    this.fire('iron-resize', null, {
      node: this,
      bubbles: false
    });
  },

  _onIronRequestResizeNotifications: function _onIronRequestResizeNotifications(event) {
    var target = /** @type {!EventTarget} */Polymer.dom(event).rootTarget;
    if (target === this) {
      return;
    }

    if (this._interestedResizables.indexOf(target) === -1) {
      this._interestedResizables.push(target);
      this.listen(target, 'iron-resize', '_onDescendantIronResize');
    }

    target.assignParentResizable(this);
    this._notifyDescendant(target);

    event.stopPropagation();
  },

  _parentResizableChanged: function _parentResizableChanged(parentResizable) {
    if (parentResizable) {
      window.removeEventListener('resize', this._boundNotifyResize);
    }
  },

  _notifyDescendant: function _notifyDescendant(descendant) {
    // NOTE(cdata): In IE10, attached is fired on children first, so it's
    // important not to notify them if the parent is not attached yet (or
    // else they will get redundantly notified when the parent attaches).
    if (!this.isAttached) {
      return;
    }

    this._notifyingDescendant = true;
    descendant.notifyResize();
    this._notifyingDescendant = false;
  },

  _requestResizeNotifications: function _requestResizeNotifications() {
    if (!this.isAttached) return;

    // NOTE(valdrin) In CustomElements v1 with native HTMLImports, the order
    // of imports affects the order of `attached` callbacks (see webcomponents/custom-elements#15).
    // This might cause a child to notify parents too early (as the parent
    // still has to be upgraded), resulting in a parent not able to keep track
    // of the `_interestedResizables`. To solve this, we wait for the document
    // to be done loading before firing the event.
    if (document.readyState === 'loading') {
      var _requestResizeNotifications = this._requestResizeNotifications.bind(this);
      document.addEventListener('readystatechange', function readystatechanged() {
        document.removeEventListener('readystatechange', readystatechanged);
        _requestResizeNotifications();
      });
    } else {
      this.fire('iron-request-resize-notifications', null, {
        node: this,
        bubbles: true,
        cancelable: true
      });

      if (!this._parentResizable) {
        window.addEventListener('resize', this._boundNotifyResize);
        this.notifyResize();
      }
    }
  }
};

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

(function () {

  /**
   * @constructor
   * @param {{type: (string|null), key: (string|null), value: *}} options
   */
  function IronMeta(options) {
    this.type = options && options.type || 'default';
    this.key = options && options.key;
    if ('value' in options) {
      this.value = options.value;
    }
  }

  IronMeta.types = {};

  IronMeta.prototype = {
    get value() {
      var type = this.type;
      var key = this.key;

      if (type && key) {
        return IronMeta.types[type] && IronMeta.types[type][key];
      }
    },

    set value(value) {
      var type = this.type;
      var key = this.key;

      if (type && key) {
        type = IronMeta.types[type] = IronMeta.types[type] || {};
        if (value == null) {
          delete type[key];
        } else {
          type[key] = value;
        }
      }
    },

    get list() {
      var type = this.type;

      if (type) {
        return Object.keys(IronMeta.types[this.type]).map(function (key) {
          return metaDatas[this.type][key];
        }, this);
      }
    },

    byKey: function byKey(key) {
      this.key = key;
      return this.value;
    }
  };

  Polymer.IronMeta = IronMeta;

  var metaDatas = Polymer.IronMeta.types;

  Polymer({

    is: 'iron-meta',

    properties: {

      /**
       * The type of meta-data.  All meta-data of the same type is stored
       * together.
       * @type {string}
       */
      type: {
        type: String,
        value: 'default'
      },

      /**
       * The key used to store `value` under the `type` namespace.
       * @type {?string}
       */
      key: {
        type: String
      },

      /**
       * The meta-data to store or retrieve.
       * @type {*}
       */
      value: {
        type: String,
        notify: true
      },

      /**
       * If true, `value` is set to the iron-meta instance itself.
       */
      self: {
        type: Boolean,
        observer: '_selfChanged'
      },

      __meta: {
        type: Boolean,
        computed: '__computeMeta(type, key, value)'
      }
    },

    hostAttributes: {
      hidden: true
    },

    __computeMeta: function __computeMeta(type, key, value) {
      var meta = new Polymer.IronMeta({
        type: type,
        key: key
      });

      if (value !== undefined && value !== meta.value) {
        meta.value = value;
      } else if (this.value !== meta.value) {
        this.value = meta.value;
      }

      return meta;
    },

    get list() {
      return this.__meta && this.__meta.list;
    },

    _selfChanged: function _selfChanged(self) {
      if (self) {
        this.value = this;
      }
    },

    /**
     * Retrieves meta data value by key.
     *
     * @method byKey
     * @param {string} key The key of the meta-data to be returned.
     * @return {*}
     */
    byKey: function byKey(key) {
      return new Polymer.IronMeta({
        type: this.type,
        key: key
      }).value;
    }
  });
})();

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

__webpack_require__(1);

__webpack_require__(20);

__webpack_require__(3);

__webpack_require__(10);

__webpack_require__(21);

__webpack_require__(7);

__webpack_require__(40);

__webpack_require__(11);

(function () {
  'use strict';

  /**
   * Element class mixin that provides the core API for Polymer's meta-programming
   * features including template stamping, data-binding, attribute deserialization,
   * and property change observation.
   *
   * Subclassers may provide the following static getters to return metadata
   * used to configure Polymer's features for the class:
   *
   * - `static get is()`: When the template is provided via a `dom-module`,
   *   users should return the `dom-module` id from a static `is` getter.  If
   *   no template is needed or the template is provided directly via the
   *   `template` getter, there is no need to define `is` for the element.
   *
   * - `static get template()`: Users may provide the template directly (as
   *   opposed to via `dom-module`) by implementing a static `template` getter.
   *   The getter may return an `HTMLTemplateElement` or a string, which will
   *   automatically be parsed into a template.
   *
   * - `static get properties()`: Should return an object describing
   *   property-related metadata used by Polymer features (key: property name
   *   value: object containing property metadata). Valid keys in per-property
   *   metadata include:
   *   - `type` (String|Number|Object|Array|...): Used by
   *     `attributeChangedCallback` to determine how string-based attributes
   *     are deserialized to JavaScript property values.
   *   - `notify` (boolean): Causes a change in the property to fire a
   *     non-bubbling event called `<property>-changed`. Elements that have
   *     enabled two-way binding to the property use this event to observe changes.
   *   - `readOnly` (boolean): Creates a getter for the property, but no setter.
   *     To set a read-only property, use the private setter method
   *     `_setProperty(property, value)`.
   *   - `observer` (string): Observer method name that will be called when
   *     the property changes. The arguments of the method are
   *     `(value, previousValue)`.
   *   - `computed` (string): String describing method and dependent properties
   *     for computing the value of this property (e.g. `'computeFoo(bar, zot)'`).
   *     Computed properties are read-only by default and can only be changed
   *     via the return value of the computing method.
   *
   * - `static get observers()`: Array of strings describing multi-property
   *   observer methods and their dependent properties (e.g.
   *   `'observeABC(a, b, c)'`).
   *
   * The base class provides default implementations for the following standard
   * custom element lifecycle callbacks; users may override these, but should
   * call the super method to ensure
   * - `constructor`: Run when the element is created or upgraded
   * - `connectedCallback`: Run each time the element is connected to the
   *   document
   * - `disconnectedCallback`: Run each time the element is disconnected from
   *   the document
   * - `attributeChangedCallback`: Run each time an attribute in
   *   `observedAttributes` is set or removed (note: this element's default
   *   `observedAttributes` implementation will automatically return an array
   *   of dash-cased attributes based on `properties`)
   *
   * @mixinFunction
   * @polymer
   * @appliesMixin Polymer.PropertyEffects
   * @memberof Polymer
   * @property rootPath {string} Set to the value of `Polymer.rootPath`,
   *   which defaults to the main document path
   * @property importPath {string} Set to the value of the class's static
   *   `importPath` property, which defaults to the path of this element's
   *   `dom-module` (when `is` is used), but can be overridden for other
   *   import strategies.
   * @summary Element class mixin that provides the core API for Polymer's
   * meta-programming features.
   */

  Polymer.ElementMixin = Polymer.dedupingMixin(function (base) {

    /**
     * @constructor
     * @extends {base}
     * @implements {Polymer_PropertyEffects}
     */
    var polymerElementBase = Polymer.PropertyEffects(base);

    var caseMap = Polymer.CaseMap;

    /**
     * Returns the `properties` object specifically on `klass`. Use for:
     * (1) super chain mixes togther to make `propertiesForClass` which is
     * then used to make `observedAttributes`.
     * (2) properties effects and observers are created from it at `finalize` time.
     *
     * @param {HTMLElement} klass Element class
     * @return {Object} Object containing own properties for this class
     * @private
     */
    function ownPropertiesForClass(klass) {
      if (!klass.hasOwnProperty(JSCompiler_renameProperty('__ownProperties', klass))) {
        klass.__ownProperties = klass.hasOwnProperty(JSCompiler_renameProperty('properties', klass)) ?
        /** @type PolymerElementConstructor */klass.properties : {};
      }
      return klass.__ownProperties;
    }

    /**
     * Returns the `observers` array specifically on `klass`. Use for
     * setting up observers.
     *
     * @param {HTMLElement} klass Element class
     * @return {Array} Array containing own observers for this class
     * @private
     */
    function ownObserversForClass(klass) {
      if (!klass.hasOwnProperty(JSCompiler_renameProperty('__ownObservers', klass))) {
        klass.__ownObservers = klass.hasOwnProperty(JSCompiler_renameProperty('observers', klass)) ?
        /** @type PolymerElementConstructor */klass.observers : [];
      }
      return klass.__ownObservers;
    }

    /**
     * Mixes `props` into `flattenedProps` but upgrades shorthand type
     * syntax to { type: Type}.
     *
     * @param {Object} flattenedProps Bag to collect flattened properties into
     * @param {Object} props Bag of properties to add to `flattenedProps`
     * @return {Object} The input `flattenedProps` bag
     * @private
     */
    function flattenProperties(flattenedProps, props) {
      for (var p in props) {
        var o = props[p];
        if (typeof o == 'function') {
          o = { type: o };
        }
        flattenedProps[p] = o;
      }
      return flattenedProps;
    }

    /**
     * Returns a flattened list of properties mixed together from the chain of all
     * constructor's `config.properties`. This list is used to create
     * (1) observedAttributes,
     * (2) class property default values
     *
     * @param {PolymerElementConstructor} klass Element class
     * @return {PolymerElementProperties} Flattened properties for this class
     * @suppress {missingProperties} class.prototype is not a property for some reason?
     * @private
     */
    function propertiesForClass(klass) {
      if (!klass.hasOwnProperty(JSCompiler_renameProperty('__classProperties', klass))) {
        klass.__classProperties = flattenProperties({}, ownPropertiesForClass(klass));
        var superCtor = Object.getPrototypeOf(klass.prototype).constructor;
        if (superCtor.prototype instanceof PolymerElement) {
          klass.__classProperties = Object.assign(Object.create(propertiesForClass( /** @type PolymerElementConstructor */superCtor)), klass.__classProperties);
        }
      }
      return klass.__classProperties;
    }

    /**
     * Returns a list of properties with default values.
     * This list is created as an optimization since it is a subset of
     * the list returned from `propertiesForClass`.
     * This list is used in `_initializeProperties` to set property defaults.
     *
     * @param {PolymerElementConstructor} klass Element class
     * @return {PolymerElementProperties} Flattened properties for this class
     *   that have default values
     * @private
     */
    function propertyDefaultsForClass(klass) {
      if (!klass.hasOwnProperty(JSCompiler_renameProperty('__classPropertyDefaults', klass))) {
        klass.__classPropertyDefaults = null;
        var props = propertiesForClass(klass);
        for (var p in props) {
          var info = props[p];
          if ('value' in info) {
            klass.__classPropertyDefaults = klass.__classPropertyDefaults || {};
            klass.__classPropertyDefaults[p] = info;
          }
        }
      }
      return klass.__classPropertyDefaults;
    }

    /**
     * Returns true if a `klass` has finalized. Called in `ElementClass.finalize()`
     * @param {PolymerElementConstructor} klass Element class
     * @return {boolean} True if all metaprogramming for this class has been
     *   completed
     * @private
     */
    function hasClassFinalized(klass) {
      return klass.hasOwnProperty(JSCompiler_renameProperty('__finalized', klass));
    }

    /**
     * Called by `ElementClass.finalize()`. Ensures this `klass` and
     * *all superclasses* are finalized by traversing the prototype chain
     * and calling `klass.finalize()`.
     *
     * @param {PolymerElementConstructor} klass Element class
     * @private
     */
    function finalizeClassAndSuper(klass) {
      var proto = /** @type PolymerElementConstructor */klass.prototype;
      var superCtor = Object.getPrototypeOf(proto).constructor;
      if (superCtor.prototype instanceof PolymerElement) {
        superCtor.finalize();
      }
      finalizeClass(klass);
    }

    /**
     * Configures a `klass` based on a staic `klass.config` object and
     * a `template`. This includes creating accessors and effects
     * for properties in `config` and the `template` as well as preparing the
     * `template` for stamping.
     *
     * @param {PolymerElementConstructor} klass Element class
     * @private
     */
    function finalizeClass(klass) {
      klass.__finalized = true;
      var proto = /** @type PolymerElementConstructor */klass.prototype;
      if (klass.hasOwnProperty(JSCompiler_renameProperty('is', klass)) && klass.is) {
        Polymer.telemetry.register(proto);
      }
      var props = ownPropertiesForClass(klass);
      if (props) {
        finalizeProperties(proto, props);
      }
      var observers = ownObserversForClass(klass);
      if (observers) {
        finalizeObservers(proto, observers, props);
      }
      // note: create "working" template that is finalized at instance time
      var template = /** @type PolymerElementConstructor */klass.template;
      if (template) {
        if (typeof template === 'string') {
          var t = document.createElement('template');
          t.innerHTML = template;
          template = t;
        } else {
          template = template.cloneNode(true);
        }
        proto._template = template;
      }
    }

    /**
     * Configures a `proto` based on a `properties` object.
     * Leverages `PropertyEffects` to create property accessors and effects
     * supporting, observers, reflecting to attributes, change notification,
     * computed properties, and read only properties.
     * @param {PolymerElement} proto Element class prototype to add accessors
     *    and effects to
     * @param {Object} properties Flattened bag of property descriptors for
     *    this class
     * @private
     */
    function finalizeProperties(proto, properties) {
      for (var p in properties) {
        createPropertyFromConfig(proto, p, properties[p], properties);
      }
    }

    /**
     * Configures a `proto` based on a `observers` array.
     * Leverages `PropertyEffects` to create observers.
     * @param {PolymerElement} proto Element class prototype to add accessors
     *   and effects to
     * @param {Object} observers Flattened array of observer descriptors for
     *   this class
     * @param {Object} dynamicFns Object containing keys for any properties
     *   that are functions and should trigger the effect when the function
     *   reference is changed
     * @private
     */
    function finalizeObservers(proto, observers, dynamicFns) {
      for (var i = 0; i < observers.length; i++) {
        proto._createMethodObserver(observers[i], dynamicFns);
      }
    }

    /**
     * Creates effects for a property.
     *
     * Note, once a property has been set to
     * `readOnly`, `computed`, `reflectToAttribute`, or `notify`
     * these values may not be changed. For example, a subclass cannot
     * alter these settings. However, additional `observers` may be added
     * by subclasses.
     *
     * The info object should may contain property metadata as follows:
     *
     * * `type`: {function} type to which an attribute matching the property
     * is deserialized. Note the property is camel-cased from a dash-cased
     * attribute. For example, 'foo-bar' attribute is dersialized to a
     * property named 'fooBar'.
     *
     * * `readOnly`: {boolean} creates a readOnly property and
     * makes a private setter for the private of the form '_setFoo' for a
     * property 'foo',
     *
     * * `computed`: {string} creates a computed property. A computed property
     * also automatically is set to `readOnly: true`. The value is calculated
     * by running a method and arguments parsed from the given string. For
     * example 'compute(foo)' will compute a given property when the
     * 'foo' property changes by executing the 'compute' method. This method
     * must return the computed value.
     *
     * * `reflectToAttriute`: {boolean} If true, the property value is reflected
     * to an attribute of the same name. Note, the attribute is dash-cased
     * so a property named 'fooBar' is reflected as 'foo-bar'.
     *
     * * `notify`: {boolean} sends a non-bubbling notification event when
     * the property changes. For example, a property named 'foo' sends an
     * event named 'foo-changed' with `event.detail` set to the value of
     * the property.
     *
     * * observer: {string} name of a method that runs when the property
     * changes. The arguments of the method are (value, previousValue).
     *
     * Note: Users may want control over modifying property
     * effects via subclassing. For example, a user might want to make a
     * reflectToAttribute property not do so in a subclass. We've chosen to
     * disable this because it leads to additional complication.
     * For example, a readOnly effect generates a special setter. If a subclass
     * disables the effect, the setter would fail unexpectedly.
     * Based on feedback, we may want to try to make effects more malleable
     * and/or provide an advanced api for manipulating them.
     * Also consider adding warnings when an effect cannot be changed.
     *
     * @param {PolymerElement} proto Element class prototype to add accessors
     *   and effects to
     * @param {string} name Name of the property.
     * @param {Object} info Info object from which to create property effects.
     * Supported keys:
     * @param {Object} allProps Flattened map of all properties defined in this
     *   element (including inherited properties)
     * @private
     */
    function createPropertyFromConfig(proto, name, info, allProps) {
      // computed forces readOnly...
      if (info.computed) {
        info.readOnly = true;
      }
      // Note, since all computed properties are readOnly, this prevents
      // adding additional computed property effects (which leads to a confusing
      // setup where multiple triggers for setting a property)
      // While we do have `hasComputedEffect` this is set on the property's
      // dependencies rather than itself.
      if (info.computed && !proto._hasReadOnlyEffect(name)) {
        proto._createComputedProperty(name, info.computed, allProps);
      }
      if (info.readOnly && !proto._hasReadOnlyEffect(name)) {
        proto._createReadOnlyProperty(name, !info.computed);
      }
      if (info.reflectToAttribute && !proto._hasReflectEffect(name)) {
        proto._createReflectedProperty(name);
      }
      if (info.notify && !proto._hasNotifyEffect(name)) {
        proto._createNotifyingProperty(name);
      }
      // always add observer
      if (info.observer) {
        proto._createPropertyObserver(name, info.observer, allProps[info.observer]);
      }
    }

    /**
     * Configures an element `proto` to function with a given `template`.
     * The element name `is` and extends `ext` must be specified for ShadyCSS
     * style scoping.
     *
     * @param {PolymerElement} proto Element class prototype to add accessors
     *   and effects to
     * @param {!HTMLTemplateElement} template Template to process and bind
     * @param {string} baseURI URL against which to resolve urls in
     *   style element cssText
     * @param {string} is Tag name (or type extension name) for this element
     * @param {string=} ext For type extensions, the tag name that was extended
     * @private
     */
    function finalizeTemplate(proto, template, baseURI, is, ext) {
      // support `include="module-name"`
      var cssText = Polymer.StyleGather.cssFromTemplate(template, baseURI) + Polymer.StyleGather.cssFromModuleImports(is);
      if (cssText) {
        var style = document.createElement('style');
        style.textContent = cssText;
        template.content.insertBefore(style, template.content.firstChild);
      }
      if (window.ShadyCSS) {
        window.ShadyCSS.prepareTemplate(template, is, ext);
      }
      proto._bindTemplate(template);
    }

    /**
     * @polymer
     * @mixinClass
     * @unrestricted
     * @implements {Polymer_ElementMixin}
     */

    var PolymerElement = function (_polymerElementBase) {
      _inherits(PolymerElement, _polymerElementBase);

      function PolymerElement() {
        _classCallCheck(this, PolymerElement);

        return _possibleConstructorReturn(this, (PolymerElement.__proto__ || Object.getPrototypeOf(PolymerElement)).apply(this, arguments));
      }

      _createClass(PolymerElement, [{
        key: '_initializeProperties',


        /**
         * Overrides the default `Polymer.PropertyAccessors` to ensure class
         * metaprogramming related to property accessors and effects has
         * completed (calls `finalize`).
         *
         * It also initializes any property defaults provided via `value` in
         * `properties` metadata.
         *
         * @override
         * @suppress {invalidCasts}
         */
        value: function _initializeProperties() {
          Polymer.telemetry.instanceCount++;
          this.constructor.finalize();
          var importPath = this.constructor.importPath;
          // note: finalize template when we have access to `localName` to
          // avoid dependence on `is` for polyfilling styling.
          if (this._template && !this._template.__polymerFinalized) {
            this._template.__polymerFinalized = true;
            var baseURI = importPath ? Polymer.ResolveUrl.resolveUrl(importPath) : '';
            finalizeTemplate( /** @type {!PolymerElement} */this.__proto__, this._template, baseURI,
            /**@type {!HTMLElement}*/this.localName);
          }
          _get(PolymerElement.prototype.__proto__ || Object.getPrototypeOf(PolymerElement.prototype), '_initializeProperties', this).call(this);
          // set path defaults
          this.rootPath = Polymer.rootPath;
          this.importPath = importPath;
          // apply property defaults...
          var p$ = propertyDefaultsForClass(this.constructor);
          if (!p$) {
            return;
          }
          for (var p in p$) {
            var info = p$[p];
            // Don't set default value if there is already an own property, which
            // happens when a `properties` property with default but no effects had
            // a property set (e.g. bound) by its host before upgrade
            if (!this.hasOwnProperty(p)) {
              var value = typeof info.value == 'function' ? info.value.call(this) : info.value;
              // Set via `_setProperty` if there is an accessor, to enable
              // initializing readOnly property defaults
              if (this._hasAccessor(p)) {
                this._setPendingProperty(p, value, true);
              } else {
                this[p] = value;
              }
            }
          }
        }

        /**
         * Provides a default implementation of the standard Custom Elements
         * `connectedCallback`.
         *
         * The default implementation enables the property effects system and
         * flushes any pending properties, and updates shimmed CSS properties
         * when using the ShadyCSS scoping/custom properties polyfill.
         *
         * @suppress {invalidCasts}
         */

      }, {
        key: 'connectedCallback',
        value: function connectedCallback() {
          if (window.ShadyCSS && this._template) {
            window.ShadyCSS.styleElement( /** @type {!HTMLElement} */this);
          }
          this._enableProperties();
        }

        /**
         * Provides a default implementation of the standard Custom Elements
         * `disconnectedCallback`.
         */

      }, {
        key: 'disconnectedCallback',
        value: function disconnectedCallback() {}

        /**
         * Stamps the element template.
         *
         * @override
         */

      }, {
        key: 'ready',
        value: function ready() {
          if (this._template) {
            this.root = this._stampTemplate(this._template);
            this.$ = this.root.$;
          }
          _get(PolymerElement.prototype.__proto__ || Object.getPrototypeOf(PolymerElement.prototype), 'ready', this).call(this);
        }

        /**
         * Implements `PropertyEffects`'s `_readyClients` call. Attaches
         * element dom by calling `_attachDom` with the dom stamped from the
         * element's template via `_stampTemplate`. Note that this allows
         * client dom to be attached to the element prior to any observers
         * running.
         *
         * @override
         */

      }, {
        key: '_readyClients',
        value: function _readyClients() {
          if (this._template) {
            this.root = this._attachDom(this.root);
          }
          // The super._readyClients here sets the clients initialized flag.
          // We must wait to do this until after client dom is created/attached
          // so that this flag can be checked to prevent notifications fired
          // during this process from being handled before clients are ready.
          _get(PolymerElement.prototype.__proto__ || Object.getPrototypeOf(PolymerElement.prototype), '_readyClients', this).call(this);
        }

        /**
         * Attaches an element's stamped dom to itself. By default,
         * this method creates a `shadowRoot` and adds the dom to it.
         * However, this method may be overridden to allow an element
         * to put its dom in another location.
         *
         * @throws {Error}
         * @suppress {missingReturn}
         * @param {NodeList} dom to attach to the element.
         * @return {Node} node to which the dom has been attached.
         */

      }, {
        key: '_attachDom',
        value: function _attachDom(dom) {
          if (this.attachShadow) {
            if (dom) {
              if (!this.shadowRoot) {
                this.attachShadow({ mode: 'open' });
              }
              this.shadowRoot.appendChild(dom);
              return this.shadowRoot;
            }
            return null;
          } else {
            throw new Error('ShadowDOM not available. ' +
            // TODO(sorvell): move to compile-time conditional when supported
            'Polymer.Element can create dom as children instead of in ' + 'ShadowDOM by setting `this.root = this;\` before \`ready\`.');
          }
        }

        /**
         * Provides a default implementation of the standard Custom Elements
         * `attributeChangedCallback`.
         *
         * By default, attributes declared in `properties` metadata are
         * deserialized using their `type` information to properties of the
         * same name.  "Dash-cased" attributes are deserialzed to "camelCase"
         * properties.
         *
         * @param {string} name Name of attribute.
         * @param {?string} old Old value of attribute.
         * @param {?string} value Current value of attribute.
         * @override
         */

      }, {
        key: 'attributeChangedCallback',
        value: function attributeChangedCallback(name, old, value) {
          if (old !== value) {
            var property = caseMap.dashToCamelCase(name);
            var type = propertiesForClass(this.constructor)[property].type;
            if (!this._hasReadOnlyEffect(property)) {
              this._attributeToProperty(name, value, type);
            }
          }
        }

        /**
         * When using the ShadyCSS scoping and custom property shim, causes all
         * shimmed styles in this element (and its subtree) to be updated
         * based on current custom property values.
         *
         * The optional parameter overrides inline custom property styles with an
         * object of properties where the keys are CSS properties, and the values
         * are strings.
         *
         * Example: `this.updateStyles({'--color': 'blue'})`
         *
         * These properties are retained unless a value of `null` is set.
         *
         * @param {Object=} properties Bag of custom property key/values to
         *   apply to this element.
         * @suppress {invalidCasts}
         */

      }, {
        key: 'updateStyles',
        value: function updateStyles(properties) {
          if (window.ShadyCSS) {
            window.ShadyCSS.styleSubtree( /** @type {!HTMLElement} */this, properties);
          }
        }

        /**
         * Rewrites a given URL relative to a base URL. The base URL defaults to
         * the original location of the document containing the `dom-module` for
         * this element. This method will return the same URL before and after
         * bundling.
         *
         * @param {string} url URL to resolve.
         * @param {string=} base Optional base URL to resolve against, defaults
         * to the element's `importPath`
         * @return {string} Rewritten URL relative to base
         */

      }, {
        key: 'resolveUrl',
        value: function resolveUrl(url, base) {
          if (!base && this.importPath) {
            base = Polymer.ResolveUrl.resolveUrl(this.importPath);
          }
          return Polymer.ResolveUrl.resolveUrl(url, base);
        }

        /**
         * Overrides `PropertyAccessors` to add map of dynamic functions on
         * template info, for consumption by `PropertyEffects` template binding
         * code. This map determines which method templates should have accessors
         * created for them.
         *
         * @override
         * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
         */

      }], [{
        key: 'finalize',


        /**
         * Called automatically when the first element instance is created to
         * ensure that class finalization work has been completed.
         * May be called by users to eagerly perform class finalization work
         * prior to the creation of the first element instance.
         *
         * Class finalization work generally includes meta-programming such as
         * creating property accessors and any property effect metadata needed for
         * the features used.
         *
         * @public
         */
        value: function finalize() {
          if (!hasClassFinalized(this)) {
            finalizeClassAndSuper(this);
          }
        }

        /**
         * Returns the template that will be stamped into this element's shadow root.
         *
         * If a `static get is()` getter is defined, the default implementation
         * will return the first `<template>` in a `dom-module` whose `id`
         * matches this element's `is`.
         *
         * Users may override this getter to return an arbitrary template
         * (in which case the `is` getter is unnecessary). The template returned
         * may be either an `HTMLTemplateElement` or a string that will be
         * automatically parsed into a template.
         *
         * Note that when subclassing, if the super class overrode the default
         * implementation and the subclass would like to provide an alternate
         * template via a `dom-module`, it should override this getter and
         * return `Polymer.DomModule.import(this.is, 'template')`.
         *
         * If a subclass would like to modify the super class template, it should
         * clone it rather than modify it in place.  If the getter does expensive
         * work such as cloning/modifying a template, it should memoize the
         * template for maximum performance:
         *
         *   let memoizedTemplate;
         *   class MySubClass extends MySuperClass {
         *     static get template() {
         *       if (!memoizedTemplate) {
         *         memoizedTemplate = super.template.cloneNode(true);
         *         let subContent = document.createElement('div');
         *         subContent.textContent = 'This came from MySubClass';
         *         memoizedTemplate.content.appendChild(subContent);
         *       }
         *       return memoizedTemplate;
         *     }
         *   }
         *
         * @return {HTMLTemplateElement|string} Template to be stamped
         */

      }, {
        key: '_parseTemplateContent',
        value: function _parseTemplateContent(template, templateInfo, nodeInfo) {
          templateInfo.dynamicFns = templateInfo.dynamicFns || propertiesForClass(this);
          return _get(PolymerElement.__proto__ || Object.getPrototypeOf(PolymerElement), '_parseTemplateContent', this).call(this, template, templateInfo, nodeInfo);
        }
      }, {
        key: 'observedAttributes',


        /**
         * Standard Custom Elements V1 API.  The default implementation returns
         * a list of dash-cased attributes based on a flattening of all properties
         * declared in `static get properties()` for this element and any
         * superclasses.
         *
         * @return {Array} Observed attribute list
         */
        get: function get() {
          if (!this.hasOwnProperty(JSCompiler_renameProperty('__observedAttributes', this))) {
            var list = [];
            var properties = propertiesForClass(this);
            for (var prop in properties) {
              list.push(Polymer.CaseMap.camelToDashCase(prop));
            }
            this.__observedAttributes = list;
          }
          return this.__observedAttributes;
        }
      }, {
        key: 'template',
        get: function get() {
          if (!this.hasOwnProperty(JSCompiler_renameProperty('_template', this))) {
            this._template = Polymer.DomModule && Polymer.DomModule.import(
            /** @type PolymerElementConstructor*/this.is, 'template') ||
            // note: implemented so a subclass can retrieve the super
            // template; call the super impl this way so that `this` points
            // to the superclass.
            Object.getPrototypeOf( /** @type PolymerElementConstructor*/this.prototype).constructor.template;
          }
          return this._template;
        }

        /**
         * Path matching the url from which the element was imported.
         * This path is used to resolve url's in template style cssText.
         * The `importPath` property is also set on element instances and can be
         * used to create bindings relative to the import path.
         * Defaults to the path matching the url containing a `dom-module` element
         * matching this element's static `is` property.
         * Note, this path should contain a trailing `/`.
         *
         * @return {string} The import path for this element class
         */

      }, {
        key: 'importPath',
        get: function get() {
          if (!this.hasOwnProperty(JSCompiler_renameProperty('_importPath', this))) {
            var module = Polymer.DomModule && Polymer.DomModule.import( /** @type PolymerElementConstructor */this.is);
            this._importPath = module ? module.assetpath : '' || Object.getPrototypeOf( /** @type PolymerElementConstructor*/this.prototype).constructor.importPath;
          }
          return this._importPath;
        }
      }]);

      return PolymerElement;
    }(polymerElementBase);

    return PolymerElement;
  });

  /**
   * Provides basic tracking of element definitions (registrations) and
   * instance counts.
   *
   * @namespace
   * @summary Provides basic tracking of element definitions (registrations) and
   * instance counts.
   */
  Polymer.telemetry = {
    /**
     * Total number of Polymer element instances created.
     * @type {number}
     */
    instanceCount: 0,
    /**
     * Array of Polymer element classes that have been finalized.
     * @type {Array<Polymer.Element>}
     */
    registrations: [],
    /**
     * @param {!PolymerElementConstructor} prototype Element prototype to log
     * @this {this}
     * @private
     */
    _regLog: function _regLog(prototype) {
      console.log('[' + prototype.is + ']: registered');
    },
    /**
     * Registers a class prototype for telemetry purposes.
     * @param {HTMLElement} prototype Element prototype to register
     * @this {this}
     * @protected
     */
    register: function register(prototype) {
      this.registrations.push(prototype);
      Polymer.log && this._regLog(prototype);
    },
    /**
     * Logs all elements registered with an `is` to the console.
     * @public
     * @this {this}
     */
    dumpRegistrations: function dumpRegistrations() {
      this.registrations.forEach(this._regLog);
    }
  };

  /**
   * When using the ShadyCSS scoping and custom property shim, causes all
   * shimmed `styles` (via `custom-style`) in the document (and its subtree)
   * to be updated based on current custom property values.
   *
   * The optional parameter overrides inline custom property styles with an
   * object of properties where the keys are CSS properties, and the values
   * are strings.
   *
   * Example: `Polymer.updateStyles({'--color': 'blue'})`
   *
   * These properties are retained unless a value of `null` is set.
   *
   * @param {Object=} props Bag of custom property key/values to
   *   apply to the document.
   */
  Polymer.updateStyles = function (props) {
    if (window.ShadyCSS) {
      window.ShadyCSS.styleDocument(props);
    }
  };
})();

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(1);

__webpack_require__(7);

/** @suppress {deprecated} */
(function () {
  'use strict';

  /**
   * Legacy settings.
   * @namespace
   * @memberof Polymer
   */

  var settings = Polymer.Settings || {};
  settings.useShadow = !window.ShadyDOM;
  settings.useNativeCSSProperties = Boolean(!window.ShadyCSS || window.ShadyCSS.nativeCss);
  settings.useNativeCustomElements = !window.customElements.polyfillWrapFlushCallback;

  /**
   * Sets the global, legacy settings.
   *
   * @deprecated
   * @memberof Polymer
   */
  Polymer.Settings = settings;

  /**
   * Globally settable property that is automatically assigned to
   * `Polymer.ElementMixin` instances, useful for binding in templates to
   * make URL's relative to an application's root.  Defaults to the main
   * document URL, but can be overridden by users.  It may be useful to set
   * `Polymer.rootPath` to provide a stable application mount path when
   * using client side routing.
   *
   * @memberof Polymer
   */
  var rootPath = Polymer.rootPath || Polymer.ResolveUrl.pathFromUrl(document.baseURI || window.location.href);

  Polymer.rootPath = rootPath;

  /**
   * Sets the global rootPath property used by `Polymer.ElementMixin` and
   * available via `Polymer.rootPath`.
   *
   * @memberof Polymer
   * @param {string} path The new root path
   */
  Polymer.setRootPath = function (path) {
    Polymer.rootPath = path;
  };
})();

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(7);

(function () {
  'use strict';

  var MODULE_STYLE_LINK_SELECTOR = 'link[rel=import][type~=css]';
  var INCLUDE_ATTR = 'include';

  function importModule(moduleId) {
    if (!Polymer.DomModule) {
      return null;
    }
    return Polymer.DomModule.import(moduleId);
  }

  /** @typedef {{assetpath: string}} */
  var templateWithAssetPath = void 0; // eslint-disable-line no-unused-vars

  /**
   * Module with utilities for collection CSS text from `<templates>`, external
   * stylesheets, and `dom-module`s.
   *
   * @namespace
   * @memberof Polymer
   * @summary Module with utilities for collection CSS text from various sources.
   */
  var StyleGather = {

    /**
     * Returns CSS text of styles in a space-separated list of `dom-module`s.
     *
     * @memberof Polymer.StyleGather
     * @param {string} moduleIds List of dom-module id's within which to
     * search for css.
     * @return {string} Concatenated CSS content from specified `dom-module`s
     * @this {StyleGather}
     */
    cssFromModules: function cssFromModules(moduleIds) {
      var modules = moduleIds.trim().split(' ');
      var cssText = '';
      for (var i = 0; i < modules.length; i++) {
        cssText += this.cssFromModule(modules[i]);
      }
      return cssText;
    },


    /**
     * Returns CSS text of styles in a given `dom-module`.  CSS in a `dom-module`
     * can come either from `<style>`s within the first `<template>`, or else
     * from one or more `<link rel="import" type="css">` links outside the
     * template.
     *
     * Any `<styles>` processed are removed from their original location.
     *
     * @memberof Polymer.StyleGather
     * @param {string} moduleId dom-module id to gather styles from
     * @return {string} Concatenated CSS content from specified `dom-module`
     * @this {StyleGather}
     */
    cssFromModule: function cssFromModule(moduleId) {
      var m = importModule(moduleId);
      if (m && m._cssText === undefined) {
        var cssText = '';
        // include css from the first template in the module
        var t = m.querySelector('template');
        if (t) {
          cssText += this.cssFromTemplate(t, /** @type {templateWithAssetPath }*/m.assetpath);
        }
        // module imports: <link rel="import" type="css">
        cssText += this.cssFromModuleImports(moduleId);
        m._cssText = cssText || null;
      }
      if (!m) {
        console.warn('Could not find style data in module named', moduleId);
      }
      return m && m._cssText || '';
    },


    /**
     * Returns CSS text of `<styles>` within a given template.
     *
     * Any `<styles>` processed are removed from their original location.
     *
     * @memberof Polymer.StyleGather
     * @param {HTMLTemplateElement} template Template to gather styles from
     * @param {string} baseURI Base URI to resolve the URL against
     * @return {string} Concatenated CSS content from specified template
     * @this {StyleGather}
     */
    cssFromTemplate: function cssFromTemplate(template, baseURI) {
      var cssText = '';
      // if element is a template, get content from its .content
      var e$ = template.content.querySelectorAll('style');
      for (var i = 0; i < e$.length; i++) {
        var e = e$[i];
        // support style sharing by allowing styles to "include"
        // other dom-modules that contain styling
        var include = e.getAttribute(INCLUDE_ATTR);
        if (include) {
          cssText += this.cssFromModules(include);
        }
        e.parentNode.removeChild(e);
        cssText += baseURI ? Polymer.ResolveUrl.resolveCss(e.textContent, baseURI) : e.textContent;
      }
      return cssText;
    },


    /**
     * Returns CSS text from stylsheets loaded via `<link rel="import" type="css">`
     * links within the specified `dom-module`.
     *
     * @memberof Polymer.StyleGather
     * @param {string} moduleId Id of `dom-module` to gather CSS from
     * @return {string} Concatenated CSS content from links in specified `dom-module`
     * @this {StyleGather}
     */
    cssFromModuleImports: function cssFromModuleImports(moduleId) {
      var cssText = '';
      var m = importModule(moduleId);
      if (!m) {
        return cssText;
      }
      var p$ = m.querySelectorAll(MODULE_STYLE_LINK_SELECTOR);
      for (var i = 0; i < p$.length; i++) {
        var p = p$[i];
        if (p.import) {
          var importDoc = p.import;
          // NOTE: polyfill affordance.
          // under the HTMLImports polyfill, there will be no 'body',
          // but the import pseudo-doc can be used directly.
          var container = importDoc.body ? importDoc.body : importDoc;
          cssText += Polymer.ResolveUrl.resolveCss(container.textContent, importDoc.baseURI);
        }
      }
      return cssText;
    }
  };

  Polymer.StyleGather = StyleGather;
})();

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

__webpack_require__(45);

__webpack_require__(19);

__webpack_require__(23);

__webpack_require__(3);

__webpack_require__(48);

__webpack_require__(49);

__webpack_require__(50);

__webpack_require__(51);

(function () {

  'use strict';

  var styleInterface = window.ShadyCSS;

  /**
   * Element class mixin that provides Polymer's "legacy" API intended to be
   * backward-compatible to the greatest extent possible with the API
   * found on the Polymer 1.x `Polymer.Base` prototype applied to all elements
   * defined using the `Polymer({...})` function.
   *
   * @mixinFunction
   * @polymer
   * @appliesMixin Polymer.ElementMixin
   * @appliesMixin Polymer.GestureEventListeners
   * @property isAttached {boolean} Set to `true` in this element's
   *   `connectedCallback` and `false` in `disconnectedCallback`
   * @memberof Polymer
   * @summary Element class mixin that provides Polymer's "legacy" API
   */
  Polymer.LegacyElementMixin = Polymer.dedupingMixin(function (base) {

    /**
     * @constructor
     * @extends {base}
     * @implements {Polymer_ElementMixin}
     * @implements {Polymer_GestureEventListeners}
     */
    var legacyElementBase = Polymer.GestureEventListeners(Polymer.ElementMixin(base));

    /**
     * Map of simple names to touch action names
     * @dict
     */
    var DIRECTION_MAP = {
      'x': 'pan-x',
      'y': 'pan-y',
      'none': 'none',
      'all': 'auto'
    };

    /**
     * @polymer
     * @mixinClass
     * @extends {legacyElementBase}
     * @implements {Polymer_LegacyElementMixin}
     * @unrestricted
     */

    var LegacyElement = function (_legacyElementBase) {
      _inherits(LegacyElement, _legacyElementBase);

      function LegacyElement() {
        _classCallCheck(this, LegacyElement);

        var _this = _possibleConstructorReturn(this, (LegacyElement.__proto__ || Object.getPrototypeOf(LegacyElement)).call(this));

        _this.root = _this;
        _this.created();
        return _this;
      }

      /**
       * Legacy callback called during the `constructor`, for overriding
       * by the user.
       */


      _createClass(LegacyElement, [{
        key: 'created',
        value: function created() {}

        /**
         * Provides an implementation of `connectedCallback`
         * which adds Polymer legacy API's `attached` method.
         * @override
         */

      }, {
        key: 'connectedCallback',
        value: function connectedCallback() {
          _get(LegacyElement.prototype.__proto__ || Object.getPrototypeOf(LegacyElement.prototype), 'connectedCallback', this).call(this);
          this.isAttached = true;
          this.attached();
        }

        /**
         * Legacy callback called during `connectedCallback`, for overriding
         * by the user.
         */

      }, {
        key: 'attached',
        value: function attached() {}

        /**
         * Provides an implementation of `disconnectedCallback`
         * which adds Polymer legacy API's `detached` method.
         * @override
         */

      }, {
        key: 'disconnectedCallback',
        value: function disconnectedCallback() {
          _get(LegacyElement.prototype.__proto__ || Object.getPrototypeOf(LegacyElement.prototype), 'disconnectedCallback', this).call(this);
          this.isAttached = false;
          this.detached();
        }

        /**
         * Legacy callback called during `disconnectedCallback`, for overriding
         * by the user.
         */

      }, {
        key: 'detached',
        value: function detached() {}

        /**
         * Provides an override implementation of `attributeChangedCallback`
         * which adds the Polymer legacy API's `attributeChanged` method.
         * @param {string} name Name of attribute.
         * @param {?string} old Old value of attribute.
         * @param {?string} value Current value of attribute.
         * @override
         */

      }, {
        key: 'attributeChangedCallback',
        value: function attributeChangedCallback(name, old, value) {
          if (old !== value) {
            _get(LegacyElement.prototype.__proto__ || Object.getPrototypeOf(LegacyElement.prototype), 'attributeChangedCallback', this).call(this, name, old, value);
            this.attributeChanged(name, old, value);
          }
        }

        /**
         * Legacy callback called during `attributeChangedChallback`, for overriding
         * by the user.
         * @param {string} name Name of attribute.
         * @param {?string} old Old value of attribute.
         * @param {?string} value Current value of attribute.
         */

      }, {
        key: 'attributeChanged',
        value: function attributeChanged(name, old, value) {} // eslint-disable-line no-unused-vars

        /**
         * Overrides the default `Polymer.PropertyEffects` implementation to
         * add support for class initialization via the `_registered` callback.
         * This is called only when the first instance of the element is created.
         *
         * @override
         */

      }, {
        key: '_initializeProperties',
        value: function _initializeProperties() {
          var proto = Object.getPrototypeOf(this);
          if (!proto.hasOwnProperty('__hasRegisterFinished')) {
            proto.__hasRegisterFinished = true;
            this._registered();
          }
          _get(LegacyElement.prototype.__proto__ || Object.getPrototypeOf(LegacyElement.prototype), '_initializeProperties', this).call(this);
        }

        /**
         * Called automatically when an element is initializing.
         * Users may override this method to perform class registration time
         * work. The implementation should ensure the work is performed
         * only once for the class.
         * @protected
         */

      }, {
        key: '_registered',
        value: function _registered() {}

        /**
         * Overrides the default `Polymer.PropertyEffects` implementation to
         * add support for installing `hostAttributes` and `listeners`.
         *
         * @override
         */

      }, {
        key: 'ready',
        value: function ready() {
          this._ensureAttributes();
          this._applyListeners();
          _get(LegacyElement.prototype.__proto__ || Object.getPrototypeOf(LegacyElement.prototype), 'ready', this).call(this);
        }

        /**
         * Ensures an element has required attributes. Called when the element
         * is being readied via `ready`. Users should override to set the
         * element's required attributes. The implementation should be sure
         * to check and not override existing attributes added by
         * the user of the element. Typically, setting attributes should be left
         * to the element user and not done here; reasonable exceptions include
         * setting aria roles and focusability.
         * @protected
         */

      }, {
        key: '_ensureAttributes',
        value: function _ensureAttributes() {}

        /**
         * Adds element event listeners. Called when the element
         * is being readied via `ready`. Users should override to
         * add any required element event listeners.
         * In performance critical elements, the work done here should be kept
         * to a minimum since it is done before the element is rendered. In
         * these elements, consider adding listeners asychronously so as not to
         * block render.
         * @protected
         */

      }, {
        key: '_applyListeners',
        value: function _applyListeners() {}

        /**
         * Converts a typed JavaScript value to a string.
         *
         * Note this method is provided as backward-compatible legacy API
         * only.  It is not directly called by any Polymer features. To customize
         * how properties are serialized to attributes for attribute bindings and
         * `reflectToAttribute: true` properties as well as this method, override
         * the `_serializeValue` method provided by `Polymer.PropertyAccessors`.
         *
         * @param {*} value Value to deserialize
         * @return {string | undefined} Serialized value
         */

      }, {
        key: 'serialize',
        value: function serialize(value) {
          return this._serializeValue(value);
        }

        /**
         * Converts a string to a typed JavaScript value.
         *
         * Note this method is provided as backward-compatible legacy API
         * only.  It is not directly called by any Polymer features.  To customize
         * how attributes are deserialized to properties for in
         * `attributeChangedCallback`, override `_deserializeValue` method
         * provided by `Polymer.PropertyAccessors`.
         *
         * @param {string} value String to deserialize
         * @param {*} type Type to deserialize the string to
         * @return {*} Returns the deserialized value in the `type` given.
         */

      }, {
        key: 'deserialize',
        value: function deserialize(value, type) {
          return this._deserializeValue(value, type);
        }

        /**
         * Serializes a property to its associated attribute.
         *
         * Note this method is provided as backward-compatible legacy API
         * only.  It is not directly called by any Polymer features.
         *
         * @param {string} property Property name to reflect.
         * @param {string=} attribute Attribute name to reflect.
         * @param {*=} value Property value to refect.
         */

      }, {
        key: 'reflectPropertyToAttribute',
        value: function reflectPropertyToAttribute(property, attribute, value) {
          this._propertyToAttribute(property, attribute, value);
        }

        /**
         * Sets a typed value to an HTML attribute on a node.
         *
         * Note this method is provided as backward-compatible legacy API
         * only.  It is not directly called by any Polymer features.
         *
         * @param {*} value Value to serialize.
         * @param {string} attribute Attribute name to serialize to.
         * @param {Element} node Element to set attribute to.
         */

      }, {
        key: 'serializeValueToAttribute',
        value: function serializeValueToAttribute(value, attribute, node) {
          this._valueToNodeAttribute( /** @type {Element} */node || this, value, attribute);
        }

        /**
         * Copies own properties (including accessor descriptors) from a source
         * object to a target object.
         *
         * @param {Object} prototype Target object to copy properties to.
         * @param {Object} api Source object to copy properties from.
         * @return {Object} prototype object that was passed as first argument.
         */

      }, {
        key: 'extend',
        value: function extend(prototype, api) {
          if (!(prototype && api)) {
            return prototype || api;
          }
          var n$ = Object.getOwnPropertyNames(api);
          for (var i = 0, n; i < n$.length && (n = n$[i]); i++) {
            var pd = Object.getOwnPropertyDescriptor(api, n);
            if (pd) {
              Object.defineProperty(prototype, n, pd);
            }
          }
          return prototype;
        }

        /**
         * Copies props from a source object to a target object.
         *
         * Note, this method uses a simple `for...in` strategy for enumerating
         * properties.  To ensure only `ownProperties` are copied from source
         * to target and that accessor implementations are copied, use `extend`.
         *
         * @param {Object} target Target object to copy properties to.
         * @param {Object} source Source object to copy properties from.
         * @return {Object} Target object that was passed as first argument.
         */

      }, {
        key: 'mixin',
        value: function mixin(target, source) {
          for (var i in source) {
            target[i] = source[i];
          }
          return target;
        }

        /**
         * Sets the prototype of an object.
         *
         * Note this method is provided as backward-compatible legacy API
         * only.  It is not directly called by any Polymer features.
         * @param {Object} object The object on which to set the prototype.
         * @param {Object} prototype The prototype that will be set on the given
         * `object`.
         * @return {Object} Returns the given `object` with its prototype set
         * to the given `prototype` object.
         */

      }, {
        key: 'chainObject',
        value: function chainObject(object, prototype) {
          if (object && prototype && object !== prototype) {
            object.__proto__ = prototype;
          }
          return object;
        }

        /* **** Begin Template **** */

        /**
         * Calls `importNode` on the `content` of the `template` specified and
         * returns a document fragment containing the imported content.
         *
         * @param {HTMLTemplateElement} template HTML template element to instance.
         * @return {DocumentFragment} Document fragment containing the imported
         *   template content.
        */

      }, {
        key: 'instanceTemplate',
        value: function instanceTemplate(template) {
          var content = this.constructor._contentForTemplate(template);
          var dom = /** @type {DocumentFragment} */
          document.importNode(content, true);
          return dom;
        }

        /* **** Begin Events **** */

        /**
         * Dispatches a custom event with an optional detail value.
         *
         * @param {string} type Name of event type.
         * @param {*=} detail Detail value containing event-specific
         *   payload.
         * @param {{ bubbles: (boolean|undefined), cancelable: (boolean|undefined), composed: (boolean|undefined) }=}
         *  options Object specifying options.  These may include:
         *  `bubbles` (boolean, defaults to `true`),
         *  `cancelable` (boolean, defaults to false), and
         *  `node` on which to fire the event (HTMLElement, defaults to `this`).
         * @return {Event} The new event that was fired.
         */

      }, {
        key: 'fire',
        value: function fire(type, detail, options) {
          options = options || {};
          detail = detail === null || detail === undefined ? {} : detail;
          var event = new Event(type, {
            bubbles: options.bubbles === undefined ? true : options.bubbles,
            cancelable: Boolean(options.cancelable),
            composed: options.composed === undefined ? true : options.composed
          });
          event.detail = detail;
          var node = options.node || this;
          node.dispatchEvent(event);
          return event;
        }

        /**
         * Convenience method to add an event listener on a given element,
         * late bound to a named method on this element.
         *
         * @param {Element} node Element to add event listener to.
         * @param {string} eventName Name of event to listen for.
         * @param {string} methodName Name of handler method on `this` to call.
         */

      }, {
        key: 'listen',
        value: function listen(node, eventName, methodName) {
          node = /** @type {Element} */node || this;
          var hbl = this.__boundListeners || (this.__boundListeners = new WeakMap());
          var bl = hbl.get(node);
          if (!bl) {
            bl = {};
            hbl.set(node, bl);
          }
          var key = eventName + methodName;
          if (!bl[key]) {
            bl[key] = this._addMethodEventListenerToNode(node, eventName, methodName, this);
          }
        }

        /**
         * Convenience method to remove an event listener from a given element,
         * late bound to a named method on this element.
         *
         * @param {Element} node Element to remove event listener from.
         * @param {string} eventName Name of event to stop listening to.
         * @param {string} methodName Name of handler method on `this` to not call
         anymore.
         */

      }, {
        key: 'unlisten',
        value: function unlisten(node, eventName, methodName) {
          node = /** @type {Element} */node || this;
          var bl = this.__boundListeners && this.__boundListeners.get(node);
          var key = eventName + methodName;
          var handler = bl && bl[key];
          if (handler) {
            this._removeEventListenerFromNode(node, eventName, handler);
            bl[key] = null;
          }
        }

        /**
         * Override scrolling behavior to all direction, one direction, or none.
         *
         * Valid scroll directions:
         *   - 'all': scroll in any direction
         *   - 'x': scroll only in the 'x' direction
         *   - 'y': scroll only in the 'y' direction
         *   - 'none': disable scrolling for this node
         *
         * @param {string=} direction Direction to allow scrolling
         * Defaults to `all`.
         * @param {Element=} node Element to apply scroll direction setting.
         * Defaults to `this`.
         */

      }, {
        key: 'setScrollDirection',
        value: function setScrollDirection(direction, node) {
          Polymer.Gestures.setTouchAction( /** @type {Element} */node || this, DIRECTION_MAP[direction] || 'auto');
        }
        /* **** End Events **** */

        /**
         * Convenience method to run `querySelector` on this local DOM scope.
         *
         * This function calls `Polymer.dom(this.root).querySelector(slctr)`.
         *
         * @param {string} slctr Selector to run on this local DOM scope
         * @return {Element} Element found by the selector, or null if not found.
         */

      }, {
        key: '$$',
        value: function $$(slctr) {
          return this.root.querySelector(slctr);
        }

        /**
         * Return the element whose local dom within which this element
         * is contained. This is a shorthand for
         * `this.getRootNode().host`.
         * @this {Element}
         */

      }, {
        key: 'distributeContent',


        /**
         * Force this element to distribute its children to its local dom.
         * This should not be necessary as of Polymer 2.0.2 and is provided only
         * for backwards compatibility.
         */
        value: function distributeContent() {
          if (window.ShadyDOM && this.shadowRoot) {
            ShadyDOM.flush();
          }
        }

        /**
         * Returns a list of nodes that are the effective childNodes. The effective
         * childNodes list is the same as the element's childNodes except that
         * any `<content>` elements are replaced with the list of nodes distributed
         * to the `<content>`, the result of its `getDistributedNodes` method.
         * @this {Element}
         * @return {Array<Node>} List of effctive child nodes.
         */

      }, {
        key: 'getEffectiveChildNodes',
        value: function getEffectiveChildNodes() {
          return (/** @type {Polymer.DomApi} */Polymer.dom(this).getEffectiveChildNodes()
          );
        }

        /**
         * Returns a list of nodes distributed within this element that match
         * `selector`. These can be dom children or elements distributed to
         * children that are insertion points.
         * @param {string} selector Selector to run.
         * @this {Element}
         * @return {Array<Node>} List of distributed elements that match selector.
         */

      }, {
        key: 'queryDistributedElements',
        value: function queryDistributedElements(selector) {
          return (/** @type {Polymer.DomApi} */Polymer.dom(this).queryDistributedElements(selector)
          );
        }

        /**
         * Returns a list of elements that are the effective children. The effective
         * children list is the same as the element's children except that
         * any `<content>` elements are replaced with the list of elements
         * distributed to the `<content>`.
         *
         * @return {Array<Node>} List of effctive children.
         */

      }, {
        key: 'getEffectiveChildren',
        value: function getEffectiveChildren() {
          var list = this.getEffectiveChildNodes();
          return list.filter(function ( /** @type {Node} */n) {
            return n.nodeType === Node.ELEMENT_NODE;
          });
        }

        /**
         * Returns a string of text content that is the concatenation of the
         * text content's of the element's effective childNodes (the elements
         * returned by <a href="#getEffectiveChildNodes>getEffectiveChildNodes</a>.
         *
         * @return {string} List of effctive children.
         */

      }, {
        key: 'getEffectiveTextContent',
        value: function getEffectiveTextContent() {
          var cn = this.getEffectiveChildNodes();
          var tc = [];
          for (var i = 0, c; c = cn[i]; i++) {
            if (c.nodeType !== Node.COMMENT_NODE) {
              tc.push(c.textContent);
            }
          }
          return tc.join('');
        }

        /**
         * Returns the first effective childNode within this element that
         * match `selector`. These can be dom child nodes or elements distributed
         * to children that are insertion points.
         * @param {string} selector Selector to run.
         * @return {Object<Node>} First effective child node that matches selector.
         */

      }, {
        key: 'queryEffectiveChildren',
        value: function queryEffectiveChildren(selector) {
          var e$ = this.queryDistributedElements(selector);
          return e$ && e$[0];
        }

        /**
         * Returns a list of effective childNodes within this element that
         * match `selector`. These can be dom child nodes or elements distributed
         * to children that are insertion points.
         * @param {string} selector Selector to run.
         * @return {Array<Node>} List of effective child nodes that match selector.
         */

      }, {
        key: 'queryAllEffectiveChildren',
        value: function queryAllEffectiveChildren(selector) {
          return this.queryDistributedElements(selector);
        }

        /**
         * Returns a list of nodes distributed to this element's `<slot>`.
         *
         * If this element contains more than one `<slot>` in its local DOM,
         * an optional selector may be passed to choose the desired content.
         *
         * @param {string=} slctr CSS selector to choose the desired
         *   `<slot>`.  Defaults to `content`.
         * @return {Array<Node>} List of distributed nodes for the `<slot>`.
         */

      }, {
        key: 'getContentChildNodes',
        value: function getContentChildNodes(slctr) {
          var content = this.root.querySelector(slctr || 'slot');
          return content ? /** @type {Polymer.DomApi} */Polymer.dom(content).getDistributedNodes() : [];
        }

        /**
         * Returns a list of element children distributed to this element's
         * `<slot>`.
         *
         * If this element contains more than one `<slot>` in its
         * local DOM, an optional selector may be passed to choose the desired
         * content.  This method differs from `getContentChildNodes` in that only
         * elements are returned.
         *
         * @param {string=} slctr CSS selector to choose the desired
         *   `<content>`.  Defaults to `content`.
         * @return {Array<HTMLElement>} List of distributed nodes for the
         *   `<slot>`.
         * @suppress {invalidCasts}
         */

      }, {
        key: 'getContentChildren',
        value: function getContentChildren(slctr) {
          return (/** @type {Array<HTMLElement>} */this.getContentChildNodes(slctr).filter(function (n) {
              return n.nodeType === Node.ELEMENT_NODE;
            })
          );
        }

        /**
         * Checks whether an element is in this element's light DOM tree.
         *
         * @param {?Node} node The element to be checked.
         * @this {Element}
         * @return {boolean} true if node is in this element's light DOM tree.
         */

      }, {
        key: 'isLightDescendant',
        value: function isLightDescendant(node) {
          return this !== node && this.contains(node) && this.getRootNode() === node.getRootNode();
        }

        /**
         * Checks whether an element is in this element's local DOM tree.
         *
         * @param {Element=} node The element to be checked.
         * @return {boolean} true if node is in this element's local DOM tree.
         */

      }, {
        key: 'isLocalDescendant',
        value: function isLocalDescendant(node) {
          return this.root === node.getRootNode();
        }

        // NOTE: should now be handled by ShadyCss library.

      }, {
        key: 'scopeSubtree',
        value: function scopeSubtree(container, shouldObserve) {} // eslint-disable-line no-unused-vars


        /**
         * Returns the computed style value for the given property.
         * @param {string} property The css property name.
         * @return {string} Returns the computed css property value for the given
         * `property`.
         */

      }, {
        key: 'getComputedStyleValue',
        value: function getComputedStyleValue(property) {
          return styleInterface.getComputedStyleValue(this, property);
        }

        // debounce

        /**
         * Call `debounce` to collapse multiple requests for a named task into
         * one invocation which is made after the wait time has elapsed with
         * no new request.  If no wait time is given, the callback will be called
         * at microtask timing (guaranteed before paint).
         *
         *     debouncedClickAction(e) {
         *       // will not call `processClick` more than once per 100ms
         *       this.debounce('click', function() {
         *        this.processClick();
         *       } 100);
         *     }
         *
         * @param {string} jobName String to indentify the debounce job.
         * @param {function()} callback Function that is called (with `this`
         *   context) when the wait time elapses.
         * @param {number} wait Optional wait time in milliseconds (ms) after the
         *   last signal that must elapse before invoking `callback`
         * @return {Object} Returns a debouncer object on which exists the
         * following methods: `isActive()` returns true if the debouncer is
         * active; `cancel()` cancels the debouncer if it is active;
         * `flush()` immediately invokes the debounced callback if the debouncer
         * is active.
         */

      }, {
        key: 'debounce',
        value: function debounce(jobName, callback, wait) {
          this._debouncers = this._debouncers || {};
          return this._debouncers[jobName] = Polymer.Debouncer.debounce(this._debouncers[jobName], wait > 0 ? Polymer.Async.timeOut.after(wait) : Polymer.Async.microTask, callback.bind(this));
        }

        /**
         * Returns whether a named debouncer is active.
         *
         * @param {string} jobName The name of the debouncer started with `debounce`
         * @return {boolean} Whether the debouncer is active (has not yet fired).
         */

      }, {
        key: 'isDebouncerActive',
        value: function isDebouncerActive(jobName) {
          this._debouncers = this._debouncers || {};
          var debouncer = this._debouncers[jobName];
          return !!(debouncer && debouncer.isActive());
        }

        /**
         * Immediately calls the debouncer `callback` and inactivates it.
         *
         * @param {string} jobName The name of the debouncer started with `debounce`
         */

      }, {
        key: 'flushDebouncer',
        value: function flushDebouncer(jobName) {
          this._debouncers = this._debouncers || {};
          var debouncer = this._debouncers[jobName];
          if (debouncer) {
            debouncer.flush();
          }
        }

        /**
         * Cancels an active debouncer.  The `callback` will not be called.
         *
         * @param {string} jobName The name of the debouncer started with `debounce`
         */

      }, {
        key: 'cancelDebouncer',
        value: function cancelDebouncer(jobName) {
          this._debouncers = this._debouncers || {};
          var debouncer = this._debouncers[jobName];
          if (debouncer) {
            debouncer.cancel();
          }
        }

        /**
         * Runs a callback function asyncronously.
         *
         * By default (if no waitTime is specified), async callbacks are run at
         * microtask timing, which will occur before paint.
         *
         * @param {Function} callback The callback function to run, bound to `this`.
         * @param {number=} waitTime Time to wait before calling the
         *   `callback`.  If unspecified or 0, the callback will be run at microtask
         *   timing (before paint).
         * @return {number} Handle that may be used to cancel the async job.
         */

      }, {
        key: 'async',
        value: function async(callback, waitTime) {
          return waitTime > 0 ? Polymer.Async.timeOut.run(callback.bind(this), waitTime) : ~Polymer.Async.microTask.run(callback.bind(this));
        }

        /**
         * Cancels an async operation started with `async`.
         *
         * @param {number} handle Handle returned from original `async` call to
         *   cancel.
         */

      }, {
        key: 'cancelAsync',
        value: function cancelAsync(handle) {
          handle < 0 ? Polymer.Async.microTask.cancel(~handle) : Polymer.Async.timeOut.cancel(handle);
        }

        // other

        /**
         * Convenience method for creating an element and configuring it.
         *
         * @param {string} tag HTML element tag to create.
         * @param {Object} props Object of properties to configure on the
         *    instance.
         * @return {Element} Newly created and configured element.
         */

      }, {
        key: 'create',
        value: function create(tag, props) {
          var elt = document.createElement(tag);
          if (props) {
            if (elt.setProperties) {
              elt.setProperties(props);
            } else {
              for (var n in props) {
                elt[n] = props[n];
              }
            }
          }
          return elt;
        }

        /**
         * Convenience method for importing an HTML document imperatively.
         *
         * This method creates a new `<link rel="import">` element with
         * the provided URL and appends it to the document to start loading.
         * In the `onload` callback, the `import` property of the `link`
         * element will contain the imported document contents.
         *
         * @param {string} href URL to document to load.
         * @param {Function} onload Callback to notify when an import successfully
         *   loaded.
         * @param {Function} onerror Callback to notify when an import
         *   unsuccessfully loaded.
         * @param {boolean} optAsync True if the import should be loaded `async`.
         *   Defaults to `false`.
         * @return {HTMLLinkElement} The link element for the URL to be loaded.
         */

      }, {
        key: 'importHref',
        value: function importHref(href, onload, onerror, optAsync) {
          // eslint-disable-line no-unused-vars
          var loadFn = onload ? onload.bind(this) : null;
          var errorFn = onerror ? onerror.bind(this) : null;
          return Polymer.importHref(href, loadFn, errorFn, optAsync);
        }

        /**
         * Polyfill for Element.prototype.matches, which is sometimes still
         * prefixed.
         *
         * @param {string} selector Selector to test.
         * @param {Element=} node Element to test the selector against.
         * @return {boolean} Whether the element matches the selector.
         */

      }, {
        key: 'elementMatches',
        value: function elementMatches(selector, node) {
          return Polymer.dom.matchesSelector( /** @type {!Element} */node || this, selector);
        }

        /**
         * Toggles an HTML attribute on or off.
         *
         * @param {string} name HTML attribute name
         * @param {boolean=} bool Boolean to force the attribute on or off.
         *    When unspecified, the state of the attribute will be reversed.
         * @param {Element=} node Node to target.  Defaults to `this`.
         */

      }, {
        key: 'toggleAttribute',
        value: function toggleAttribute(name, bool, node) {
          node = /** @type {Element} */node || this;
          if (arguments.length == 1) {
            bool = !node.hasAttribute(name);
          }
          if (bool) {
            node.setAttribute(name, '');
          } else {
            node.removeAttribute(name);
          }
        }

        /**
         * Toggles a CSS class on or off.
         *
         * @param {string} name CSS class name
         * @param {boolean=} bool Boolean to force the class on or off.
         *    When unspecified, the state of the class will be reversed.
         * @param {Element=} node Node to target.  Defaults to `this`.
         */

      }, {
        key: 'toggleClass',
        value: function toggleClass(name, bool, node) {
          node = /** @type {Element} */node || this;
          if (arguments.length == 1) {
            bool = !node.classList.contains(name);
          }
          if (bool) {
            node.classList.add(name);
          } else {
            node.classList.remove(name);
          }
        }

        /**
         * Cross-platform helper for setting an element's CSS `transform` property.
         *
         * @param {string} transformText Transform setting.
         * @param {Element=} node Element to apply the transform to.
         * Defaults to `this`
         */

      }, {
        key: 'transform',
        value: function transform(transformText, node) {
          node = /** @type {Element} */node || this;
          node.style.webkitTransform = transformText;
          node.style.transform = transformText;
        }

        /**
         * Cross-platform helper for setting an element's CSS `translate3d`
         * property.
         *
         * @param {number} x X offset.
         * @param {number} y Y offset.
         * @param {number} z Z offset.
         * @param {Element=} node Element to apply the transform to.
         * Defaults to `this`.
         */

      }, {
        key: 'translate3d',
        value: function translate3d(x, y, z, node) {
          node = /** @type {Element} */node || this;
          this.transform('translate3d(' + x + ',' + y + ',' + z + ')', node);
        }

        /**
         * Removes an item from an array, if it exists.
         *
         * If the array is specified by path, a change notification is
         * generated, so that observers, data bindings and computed
         * properties watching that path can update.
         *
         * If the array is passed directly, **no change
         * notification is generated**.
         *
         * @param {string | !Array<number|string>} arrayOrPath Path to array from which to remove the item
         *   (or the array itself).
         * @param {*} item Item to remove.
         * @return {Array} Array containing item removed.
         */

      }, {
        key: 'arrayDelete',
        value: function arrayDelete(arrayOrPath, item) {
          var index = void 0;
          if (Array.isArray(arrayOrPath)) {
            index = arrayOrPath.indexOf(item);
            if (index >= 0) {
              return arrayOrPath.splice(index, 1);
            }
          } else {
            var arr = Polymer.Path.get(this, arrayOrPath);
            index = arr.indexOf(item);
            if (index >= 0) {
              return this.splice(arrayOrPath, index, 1);
            }
          }
          return null;
        }

        // logging

        /**
         * Facades `console.log`/`warn`/`error` as override point.
         *
         * @param {string} level One of 'log', 'warn', 'error'
         * @param {Array} args Array of strings or objects to log
         */

      }, {
        key: '_logger',
        value: function _logger(level, args) {
          var _console;

          // accept ['foo', 'bar'] and [['foo', 'bar']]
          if (Array.isArray(args) && args.length === 1) {
            args = args[0];
          }
          switch (level) {
            case 'log':
            case 'warn':
            case 'error':
              (_console = console)[level].apply(_console, _toConsumableArray(args));
          }
        }

        /**
         * Facades `console.log` as an override point.
         *
         * @param {...*} args Array of strings or objects to log
         */

      }, {
        key: '_log',
        value: function _log() {
          for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          this._logger('log', args);
        }

        /**
         * Facades `console.warn` as an override point.
         *
         * @param {...*} args Array of strings or objects to log
         */

      }, {
        key: '_warn',
        value: function _warn() {
          for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }

          this._logger('warn', args);
        }

        /**
         * Facades `console.error` as an override point.
         *
         * @param {...*} args Array of strings or objects to log
         */

      }, {
        key: '_error',
        value: function _error() {
          for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
            args[_key3] = arguments[_key3];
          }

          this._logger('error', args);
        }

        /**
         * Formats a message using the element type an a method name.
         *
         * @param {string} methodName Method name to associate with message
         * @param {...*} args Array of strings or objects to log
         * @return {Array} Array with formatting information for `console`
         *   logging.
         */

      }, {
        key: '_logf',
        value: function _logf(methodName) {
          for (var _len4 = arguments.length, args = Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
            args[_key4 - 1] = arguments[_key4];
          }

          return ['[%s::%s]', this.is, methodName].concat(args);
        }
      }, {
        key: 'domHost',
        get: function get() {
          var root = this.getRootNode();
          return root instanceof DocumentFragment ? /** @type {ShadowRoot} */root.host : root;
        }
      }]);

      return LegacyElement;
    }(legacyElementBase);

    LegacyElement.prototype.is = '';

    return LegacyElement;
  });
})();

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

__webpack_require__(1);

__webpack_require__(3);

__webpack_require__(47);

(function () {

  'use strict';

  /**
   * @const {Polymer.Gestures}
   */

  var gestures = Polymer.Gestures;

  /**
   * Element class mixin that provides API for adding Polymer's cross-platform
   * gesture events to nodes.
   *
   * The API is designed to be compatible with override points implemented
   * in `Polymer.TemplateStamp` such that declarative event listeners in
   * templates will support gesture events when this mixin is applied along with
   * `Polymer.TemplateStamp`.
   *
   * @mixinFunction
   * @polymer
   * @memberof Polymer
   * @summary Element class mixin that provides API for adding Polymer's cross-platform
   * gesture events to nodes
   */
  Polymer.GestureEventListeners = Polymer.dedupingMixin(function (superClass) {

    /**
     * @polymer
     * @mixinClass
     * @implements {Polymer_GestureEventListeners}
     */
    var GestureEventListeners = function (_superClass) {
      _inherits(GestureEventListeners, _superClass);

      function GestureEventListeners() {
        _classCallCheck(this, GestureEventListeners);

        return _possibleConstructorReturn(this, (GestureEventListeners.__proto__ || Object.getPrototypeOf(GestureEventListeners)).apply(this, arguments));
      }

      _createClass(GestureEventListeners, [{
        key: '_addEventListenerToNode',
        value: function _addEventListenerToNode(node, eventName, handler) {
          if (!gestures.addListener(node, eventName, handler)) {
            _get(GestureEventListeners.prototype.__proto__ || Object.getPrototypeOf(GestureEventListeners.prototype), '_addEventListenerToNode', this).call(this, node, eventName, handler);
          }
        }
      }, {
        key: '_removeEventListenerFromNode',
        value: function _removeEventListenerFromNode(node, eventName, handler) {
          if (!gestures.removeListener(node, eventName, handler)) {
            _get(GestureEventListeners.prototype.__proto__ || Object.getPrototypeOf(GestureEventListeners.prototype), '_removeEventListenerFromNode', this).call(this, node, eventName, handler);
          }
        }
      }]);

      return GestureEventListeners;
    }(superClass);

    return GestureEventListeners;
  });
})();

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(1);

(function () {

  'use strict';

  function newSplice(index, removed, addedCount) {
    return {
      index: index,
      removed: removed,
      addedCount: addedCount
    };
  }

  var EDIT_LEAVE = 0;
  var EDIT_UPDATE = 1;
  var EDIT_ADD = 2;
  var EDIT_DELETE = 3;

  // Note: This function is *based* on the computation of the Levenshtein
  // "edit" distance. The one change is that "updates" are treated as two
  // edits - not one. With Array splices, an update is really a delete
  // followed by an add. By retaining this, we optimize for "keeping" the
  // maximum array items in the original array. For example:
  //
  //   'xxxx123' -> '123yyyy'
  //
  // With 1-edit updates, the shortest path would be just to update all seven
  // characters. With 2-edit updates, we delete 4, leave 3, and add 4. This
  // leaves the substring '123' intact.
  function calcEditDistances(current, currentStart, currentEnd, old, oldStart, oldEnd) {
    // "Deletion" columns
    var rowCount = oldEnd - oldStart + 1;
    var columnCount = currentEnd - currentStart + 1;
    var distances = new Array(rowCount);

    // "Addition" rows. Initialize null column.
    for (var i = 0; i < rowCount; i++) {
      distances[i] = new Array(columnCount);
      distances[i][0] = i;
    }

    // Initialize null row
    for (var j = 0; j < columnCount; j++) {
      distances[0][j] = j;
    }for (var _i = 1; _i < rowCount; _i++) {
      for (var _j = 1; _j < columnCount; _j++) {
        if (equals(current[currentStart + _j - 1], old[oldStart + _i - 1])) distances[_i][_j] = distances[_i - 1][_j - 1];else {
          var north = distances[_i - 1][_j] + 1;
          var west = distances[_i][_j - 1] + 1;
          distances[_i][_j] = north < west ? north : west;
        }
      }
    }

    return distances;
  }

  // This starts at the final weight, and walks "backward" by finding
  // the minimum previous weight recursively until the origin of the weight
  // matrix.
  function spliceOperationsFromEditDistances(distances) {
    var i = distances.length - 1;
    var j = distances[0].length - 1;
    var current = distances[i][j];
    var edits = [];
    while (i > 0 || j > 0) {
      if (i == 0) {
        edits.push(EDIT_ADD);
        j--;
        continue;
      }
      if (j == 0) {
        edits.push(EDIT_DELETE);
        i--;
        continue;
      }
      var northWest = distances[i - 1][j - 1];
      var west = distances[i - 1][j];
      var north = distances[i][j - 1];

      var min = void 0;
      if (west < north) min = west < northWest ? west : northWest;else min = north < northWest ? north : northWest;

      if (min == northWest) {
        if (northWest == current) {
          edits.push(EDIT_LEAVE);
        } else {
          edits.push(EDIT_UPDATE);
          current = northWest;
        }
        i--;
        j--;
      } else if (min == west) {
        edits.push(EDIT_DELETE);
        i--;
        current = west;
      } else {
        edits.push(EDIT_ADD);
        j--;
        current = north;
      }
    }

    edits.reverse();
    return edits;
  }

  /**
   * Splice Projection functions:
   *
   * A splice map is a representation of how a previous array of items
   * was transformed into a new array of items. Conceptually it is a list of
   * tuples of
   *
   *   <index, removed, addedCount>
   *
   * which are kept in ascending index order of. The tuple represents that at
   * the |index|, |removed| sequence of items were removed, and counting forward
   * from |index|, |addedCount| items were added.
   */

  /**
   * Lacking individual splice mutation information, the minimal set of
   * splices can be synthesized given the previous state and final state of an
   * array. The basic approach is to calculate the edit distance matrix and
   * choose the shortest path through it.
   *
   * Complexity: O(l * p)
   *   l: The length of the current array
   *   p: The length of the old array
   *
   * @param {Array} current The current "changed" array for which to
   * calculate splices.
   * @param {number} currentStart Starting index in the `current` array for
   * which splices are calculated.
   * @param {number} currentEnd Ending index in the `current` array for
   * which splices are calculated.
   * @param {Array} old The original "unchanged" array to compare `current`
   * against to determine splices.
   * @param {number} oldStart Starting index in the `old` array for
   * which splices are calculated.
   * @param {number} oldEnd Ending index in the `old` array for
   * which splices are calculated.
   * @return {Array} Returns an array of splice record objects. Each of these
   * contains: `index` the location where the splice occurred; `removed`
   * the array of removed items from this location; `addedCount` the number
   * of items added at this location.
   */
  function calcSplices(current, currentStart, currentEnd, old, oldStart, oldEnd) {
    var prefixCount = 0;
    var suffixCount = 0;
    var splice = void 0;

    var minLength = Math.min(currentEnd - currentStart, oldEnd - oldStart);
    if (currentStart == 0 && oldStart == 0) prefixCount = sharedPrefix(current, old, minLength);

    if (currentEnd == current.length && oldEnd == old.length) suffixCount = sharedSuffix(current, old, minLength - prefixCount);

    currentStart += prefixCount;
    oldStart += prefixCount;
    currentEnd -= suffixCount;
    oldEnd -= suffixCount;

    if (currentEnd - currentStart == 0 && oldEnd - oldStart == 0) return [];

    if (currentStart == currentEnd) {
      splice = newSplice(currentStart, [], 0);
      while (oldStart < oldEnd) {
        splice.removed.push(old[oldStart++]);
      }return [splice];
    } else if (oldStart == oldEnd) return [newSplice(currentStart, [], currentEnd - currentStart)];

    var ops = spliceOperationsFromEditDistances(calcEditDistances(current, currentStart, currentEnd, old, oldStart, oldEnd));

    splice = undefined;
    var splices = [];
    var index = currentStart;
    var oldIndex = oldStart;
    for (var i = 0; i < ops.length; i++) {
      switch (ops[i]) {
        case EDIT_LEAVE:
          if (splice) {
            splices.push(splice);
            splice = undefined;
          }

          index++;
          oldIndex++;
          break;
        case EDIT_UPDATE:
          if (!splice) splice = newSplice(index, [], 0);

          splice.addedCount++;
          index++;

          splice.removed.push(old[oldIndex]);
          oldIndex++;
          break;
        case EDIT_ADD:
          if (!splice) splice = newSplice(index, [], 0);

          splice.addedCount++;
          index++;
          break;
        case EDIT_DELETE:
          if (!splice) splice = newSplice(index, [], 0);

          splice.removed.push(old[oldIndex]);
          oldIndex++;
          break;
      }
    }

    if (splice) {
      splices.push(splice);
    }
    return splices;
  }

  function sharedPrefix(current, old, searchLength) {
    for (var i = 0; i < searchLength; i++) {
      if (!equals(current[i], old[i])) return i;
    }return searchLength;
  }

  function sharedSuffix(current, old, searchLength) {
    var index1 = current.length;
    var index2 = old.length;
    var count = 0;
    while (count < searchLength && equals(current[--index1], old[--index2])) {
      count++;
    }return count;
  }

  function calculateSplices(current, previous) {
    return calcSplices(current, 0, current.length, previous, 0, previous.length);
  }

  function equals(currentValue, previousValue) {
    return currentValue === previousValue;
  }

  /**
   * @namespace
   * @memberof Polymer
   * @summary Module that provides utilities for diffing arrays.
   */
  Polymer.ArraySplice = {
    /**
     * Returns an array of splice records indicating the minimum edits required
     * to transform the `previous` array into the `current` array.
     *
     * Splice records are ordered by index and contain the following fields:
     * - `index`: index where edit started
     * - `removed`: array of removed items from this index
     * - `addedCount`: number of items added at this index
     *
     * This function is based on the Levenshtein "minimum edit distance"
     * algorithm. Note that updates are treated as removal followed by addition.
     *
     * The worst-case time complexity of this algorithm is `O(l * p)`
     *   l: The length of the current array
     *   p: The length of the previous array
     *
     * However, the worst-case complexity is reduced by an `O(n)` optimization
     * to detect any shared prefix & suffix between the two arrays and only
     * perform the more expensive minimum edit distance calculation over the
     * non-shared portions of the arrays.
     *
     * @memberof Polymer.ArraySplice
     * @param {Array} current The "changed" array for which splices will be
     * calculated.
     * @param {Array} previous The "unchanged" original array to compare
     * `current` against to determine the splices.
     * @return {Array} Returns an array of splice record objects. Each of these
     * contains: `index` the location where the splice occurred; `removed`
     * the array of removed items from this location; `addedCount` the number
     * of items added at this location.
     */
    calculateSplices: calculateSplices
  };
})();

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(4);

/**
 * While scrolling down, fade in the rear background layer and fade out the front background
 * layer (opacity interpolated based on scroll position).
 */
Polymer.AppLayout.registerEffect('blend-background', {
  /** @this Polymer.AppLayout.ElementWithBackground */
  setUp: function setUp() {
    var fx = {};
    fx.backgroundFrontLayer = this._getDOMRef('backgroundFrontLayer');
    fx.backgroundRearLayer = this._getDOMRef('backgroundRearLayer');
    fx.backgroundFrontLayer.style.willChange = 'opacity';
    fx.backgroundFrontLayer.style.transform = 'translateZ(0)';
    fx.backgroundRearLayer.style.willChange = 'opacity';
    fx.backgroundRearLayer.style.transform = 'translateZ(0)';
    fx.backgroundRearLayer.style.opacity = 0;
    this._fxBlendBackground = fx;
  },
  /** @this Polymer.AppLayout.ElementWithBackground */
  run: function run(p, y) {
    var fx = this._fxBlendBackground;
    fx.backgroundFrontLayer.style.opacity = 1 - p;
    fx.backgroundRearLayer.style.opacity = p;
  },
  /** @this Polymer.AppLayout.ElementWithBackground */
  tearDown: function tearDown() {
    delete this._fxBlendBackground;
  }
});

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(4);

/**
 * Toggles the shadow property in app-header when content is scrolled to create a sense of depth
 * between the element and the content underneath.
 */
Polymer.AppLayout.registerEffect('waterfall', {
  /**
   *  @this Polymer.AppLayout.ElementWithBackground
   */
  run: function run() {
    this.shadow = this.isOnScreen() && this.isContentBelow();
  }
});

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(4);

(function () {
  function interpolate(progress, points, fn, ctx) {
    fn.apply(ctx, points.map(function (point) {
      return point[0] + (point[1] - point[0]) * progress;
    }));
  }

  /**
   * Transform the font size of a designated title element between two values based on the scroll
   * position.
   */
  Polymer.AppLayout.registerEffect('resize-title', {
    /** @this Polymer.AppLayout.ElementWithBackground */
    setUp: function setUp() {
      var title = this._getDOMRef('mainTitle');
      var condensedTitle = this._getDOMRef('condensedTitle');

      if (!condensedTitle) {
        console.warn('Scroll effect `resize-title`: undefined `condensed-title`');
        return false;
      }
      if (!title) {
        console.warn('Scroll effect `resize-title`: undefined `main-title`');
        return false;
      }

      condensedTitle.style.willChange = 'opacity';
      condensedTitle.style.webkitTransform = 'translateZ(0)';
      condensedTitle.style.transform = 'translateZ(0)';
      condensedTitle.style.webkitTransformOrigin = 'left top';
      condensedTitle.style.transformOrigin = 'left top';

      title.style.willChange = 'opacity';
      title.style.webkitTransformOrigin = 'left top';
      title.style.transformOrigin = 'left top';
      title.style.webkitTransform = 'translateZ(0)';
      title.style.transform = 'translateZ(0)';

      var titleClientRect = title.getBoundingClientRect();
      var condensedTitleClientRect = condensedTitle.getBoundingClientRect();
      var fx = {};

      fx.scale = parseInt(window.getComputedStyle(condensedTitle)['font-size'], 10) / parseInt(window.getComputedStyle(title)['font-size'], 10);
      fx.titleDX = titleClientRect.left - condensedTitleClientRect.left;
      fx.titleDY = titleClientRect.top - condensedTitleClientRect.top;
      fx.condensedTitle = condensedTitle;
      fx.title = title;

      this._fxResizeTitle = fx;
    },
    /** @this PolymerElement */
    run: function run(p, y) {
      var fx = this._fxResizeTitle;
      if (!this.condenses) {
        y = 0;
      }
      if (p >= 1) {
        fx.title.style.opacity = 0;
        fx.condensedTitle.style.opacity = 1;
      } else {
        fx.title.style.opacity = 1;
        fx.condensedTitle.style.opacity = 0;
      }
      interpolate(Math.min(1, p), [[1, fx.scale], [0, -fx.titleDX], [y, y - fx.titleDY]], function (scale, translateX, translateY) {
        this.transform('translate(' + translateX + 'px, ' + translateY + 'px) ' + 'scale3d(' + scale + ', ' + scale + ', 1)', fx.title);
      }, this);
    },
    /** @this Polymer.AppLayout.ElementWithBackground */
    tearDown: function tearDown() {
      delete this._fxResizeTitle;
    }
  });
})();

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(4);

/**
 * Vertically translate the background based on a factor of the scroll position.
 */
Polymer.AppLayout.registerEffect('parallax-background', {
  /**
   * @param {{scalar: string}} config
   * @this Polymer.AppLayout.ElementWithBackground
   */
  setUp: function setUp(config) {
    var fx = {};
    var scalar = parseFloat(config.scalar);
    fx.background = this._getDOMRef('background');
    fx.backgroundFrontLayer = this._getDOMRef('backgroundFrontLayer');
    fx.backgroundRearLayer = this._getDOMRef('backgroundRearLayer');
    fx.deltaBg = fx.backgroundFrontLayer.offsetHeight - fx.background.offsetHeight;
    if (fx.deltaBg === 0) {
      if (isNaN(scalar)) {
        scalar = 0.8;
      }
      fx.deltaBg = this._dHeight * scalar;
    } else {
      if (isNaN(scalar)) {
        scalar = 1;
      }
      fx.deltaBg = fx.deltaBg * scalar;
    }
    this._fxParallaxBackground = fx;
  },
  /** @this Polymer.AppLayout.ElementWithBackground */
  run: function run(p, y) {
    var fx = this._fxParallaxBackground;
    this.transform('translate3d(0px, ' + fx.deltaBg * Math.min(1, p) + 'px, 0px)', fx.backgroundFrontLayer);
    if (fx.backgroundRearLayer) {
      this.transform('translate3d(0px, ' + fx.deltaBg * Math.min(1, p) + 'px, 0px)', fx.backgroundRearLayer);
    }
  },
  /** @this Polymer.AppLayout.ElementWithBackground */
  tearDown: function tearDown() {
    delete this._fxParallaxBackground;
  }
});

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

__webpack_require__(80);

/**
 * @polymerBehavior Polymer.IronSelectableBehavior
 */
Polymer.IronSelectableBehavior = {

  /**
   * Fired when iron-selector is activated (selected or deselected).
   * It is fired before the selected items are changed.
   * Cancel the event to abort selection.
   *
   * @event iron-activate
   */

  /**
   * Fired when an item is selected
   *
   * @event iron-select
   */

  /**
   * Fired when an item is deselected
   *
   * @event iron-deselect
   */

  /**
   * Fired when the list of selectable items changes (e.g., items are
   * added or removed). The detail of the event is a mutation record that
   * describes what changed.
   *
   * @event iron-items-changed
   */

  properties: {

    /**
     * If you want to use an attribute value or property of an element for
     * `selected` instead of the index, set this to the name of the attribute
     * or property. Hyphenated values are converted to camel case when used to
     * look up the property of a selectable element. Camel cased values are
     * *not* converted to hyphenated values for attribute lookup. It's
     * recommended that you provide the hyphenated form of the name so that
     * selection works in both cases. (Use `attr-or-property-name` instead of
     * `attrOrPropertyName`.)
     */
    attrForSelected: {
      type: String,
      value: null
    },

    /**
     * Gets or sets the selected element. The default is to use the index of the item.
     * @type {string|number}
     */
    selected: {
      type: String,
      notify: true
    },

    /**
     * Returns the currently selected item.
     *
     * @type {?Object}
     */
    selectedItem: {
      type: Object,
      readOnly: true,
      notify: true
    },

    /**
     * The event that fires from items when they are selected. Selectable
     * will listen for this event from items and update the selection state.
     * Set to empty string to listen to no events.
     */
    activateEvent: {
      type: String,
      value: 'tap',
      observer: '_activateEventChanged'
    },

    /**
     * This is a CSS selector string.  If this is set, only items that match the CSS selector
     * are selectable.
     */
    selectable: String,

    /**
     * The class to set on elements when selected.
     */
    selectedClass: {
      type: String,
      value: 'iron-selected'
    },

    /**
     * The attribute to set on elements when selected.
     */
    selectedAttribute: {
      type: String,
      value: null
    },

    /**
     * Default fallback if the selection based on selected with `attrForSelected`
     * is not found.
     */
    fallbackSelection: {
      type: String,
      value: null
    },

    /**
     * The list of items from which a selection can be made.
     */
    items: {
      type: Array,
      readOnly: true,
      notify: true,
      value: function value() {
        return [];
      }
    },

    /**
     * The set of excluded elements where the key is the `localName`
     * of the element that will be ignored from the item list.
     *
     * @default {template: 1}
     */
    _excludedLocalNames: {
      type: Object,
      value: function value() {
        return {
          'template': 1,
          'dom-bind': 1,
          'dom-if': 1,
          'dom-repeat': 1
        };
      }
    }
  },

  observers: ['_updateAttrForSelected(attrForSelected)', '_updateSelected(selected)', '_checkFallback(fallbackSelection)'],

  created: function created() {
    this._bindFilterItem = this._filterItem.bind(this);
    this._selection = new Polymer.IronSelection(this._applySelection.bind(this));
  },

  attached: function attached() {
    this._observer = this._observeItems(this);
    this._addListener(this.activateEvent);
  },

  detached: function detached() {
    if (this._observer) {
      Polymer.dom(this).unobserveNodes(this._observer);
    }
    this._removeListener(this.activateEvent);
  },

  /**
   * Returns the index of the given item.
   *
   * @method indexOf
   * @param {Object} item
   * @returns Returns the index of the item
   */
  indexOf: function indexOf(item) {
    return this.items.indexOf(item);
  },

  /**
   * Selects the given value.
   *
   * @method select
   * @param {string|number} value the value to select.
   */
  select: function select(value) {
    this.selected = value;
  },

  /**
   * Selects the previous item.
   *
   * @method selectPrevious
   */
  selectPrevious: function selectPrevious() {
    var length = this.items.length;
    var index = (Number(this._valueToIndex(this.selected)) - 1 + length) % length;
    this.selected = this._indexToValue(index);
  },

  /**
   * Selects the next item.
   *
   * @method selectNext
   */
  selectNext: function selectNext() {
    var index = (Number(this._valueToIndex(this.selected)) + 1) % this.items.length;
    this.selected = this._indexToValue(index);
  },

  /**
   * Selects the item at the given index.
   *
   * @method selectIndex
   */
  selectIndex: function selectIndex(index) {
    this.select(this._indexToValue(index));
  },

  /**
   * Force a synchronous update of the `items` property.
   *
   * NOTE: Consider listening for the `iron-items-changed` event to respond to
   * updates to the set of selectable items after updates to the DOM list and
   * selection state have been made.
   *
   * WARNING: If you are using this method, you should probably consider an
   * alternate approach. Synchronously querying for items is potentially
   * slow for many use cases. The `items` property will update asynchronously
   * on its own to reflect selectable items in the DOM.
   */
  forceSynchronousItemUpdate: function forceSynchronousItemUpdate() {
    if (this._observer && typeof this._observer.flush === "function") {
      // NOTE(bicknellr): `Polymer.dom.flush` above is no longer sufficient to
      // trigger `observeNodes` callbacks. Polymer 2.x returns an object from
      // `observeNodes` with a `flush` that synchronously gives the callback
      // any pending MutationRecords (retrieved with `takeRecords`). Any case
      // where ShadyDOM flushes were expected to synchronously trigger item
      // updates will now require calling `forceSynchronousItemUpdate`.
      this._observer.flush();
    } else {
      this._updateItems();
    }
  },

  // UNUSED, FOR API COMPATIBILITY
  get _shouldUpdateSelection() {
    return this.selected != null;
  },

  _checkFallback: function _checkFallback() {
    this._updateSelected();
  },

  _addListener: function _addListener(eventName) {
    this.listen(this, eventName, '_activateHandler');
  },

  _removeListener: function _removeListener(eventName) {
    this.unlisten(this, eventName, '_activateHandler');
  },

  _activateEventChanged: function _activateEventChanged(eventName, old) {
    this._removeListener(old);
    this._addListener(eventName);
  },

  _updateItems: function _updateItems() {
    var nodes = Polymer.dom(this).queryDistributedElements(this.selectable || '*');
    nodes = Array.prototype.filter.call(nodes, this._bindFilterItem);
    this._setItems(nodes);
  },

  _updateAttrForSelected: function _updateAttrForSelected() {
    if (this.selectedItem) {
      this.selected = this._valueForItem(this.selectedItem);
    }
  },

  _updateSelected: function _updateSelected() {
    this._selectSelected(this.selected);
  },

  _selectSelected: function _selectSelected(selected) {
    if (!this.items) {
      return;
    }

    var item = this._valueToItem(this.selected);
    if (item) {
      this._selection.select(item);
    } else {
      this._selection.clear();
    }
    // Check for items, since this array is populated only when attached
    // Since Number(0) is falsy, explicitly check for undefined
    if (this.fallbackSelection && this.items.length && this._selection.get() === undefined) {
      this.selected = this.fallbackSelection;
    }
  },

  _filterItem: function _filterItem(node) {
    return !this._excludedLocalNames[node.localName];
  },

  _valueToItem: function _valueToItem(value) {
    return value == null ? null : this.items[this._valueToIndex(value)];
  },

  _valueToIndex: function _valueToIndex(value) {
    if (this.attrForSelected) {
      for (var i = 0, item; item = this.items[i]; i++) {
        if (this._valueForItem(item) == value) {
          return i;
        }
      }
    } else {
      return Number(value);
    }
  },

  _indexToValue: function _indexToValue(index) {
    if (this.attrForSelected) {
      var item = this.items[index];
      if (item) {
        return this._valueForItem(item);
      }
    } else {
      return index;
    }
  },

  _valueForItem: function _valueForItem(item) {
    if (!item) {
      return null;
    }

    var propValue = item[Polymer.CaseMap.dashToCamelCase(this.attrForSelected)];
    return propValue != undefined ? propValue : item.getAttribute(this.attrForSelected);
  },

  _applySelection: function _applySelection(item, isSelected) {
    if (this.selectedClass) {
      this.toggleClass(this.selectedClass, isSelected, item);
    }
    if (this.selectedAttribute) {
      this.toggleAttribute(this.selectedAttribute, isSelected, item);
    }
    this._selectionChange();
    this.fire('iron-' + (isSelected ? 'select' : 'deselect'), { item: item });
  },

  _selectionChange: function _selectionChange() {
    this._setSelectedItem(this._selection.get());
  },

  // observe items change under the given node.
  _observeItems: function _observeItems(node) {
    return Polymer.dom(node).observeNodes(function (mutation) {
      this._updateItems();
      this._updateSelected();

      // Let other interested parties know about the change so that
      // we don't have to recreate mutation observers everywhere.
      this.fire('iron-items-changed', mutation, {
        bubbles: false,
        cancelable: false
      });
    });
  },

  _activateHandler: function _activateHandler(e) {
    var t = e.target;
    var items = this.items;
    while (t && t != this) {
      var i = items.indexOf(t);
      if (i >= 0) {
        var value = this._indexToValue(i);
        this._itemActivate(value, t);
        return;
      }
      t = t.parentNode;
    }
  },

  _itemActivate: function _itemActivate(value, item) {
    if (!this.fire('iron-activate', { selected: value, item: item }, { cancelable: true }).defaultPrevented) {
      this.select(value);
    }
  }

};

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

__webpack_require__(37);

var RegisterHtmlTemplate = __webpack_require__(2);

RegisterHtmlTemplate.toBody("<custom-style> <style is=custom-style>html{--primary-text-color:var(--light-theme-text-color);--primary-background-color:var(--light-theme-background-color);--secondary-text-color:var(--light-theme-secondary-color);--disabled-text-color:var(--light-theme-disabled-color);--divider-color:var(--light-theme-divider-color);--error-color:var(--paper-deep-orange-a700);--primary-color:var(--paper-indigo-500);--light-primary-color:var(--paper-indigo-100);--dark-primary-color:var(--paper-indigo-700);--accent-color:var(--paper-pink-a200);--light-accent-color:var(--paper-pink-a100);--dark-accent-color:var(--paper-pink-a400);--light-theme-background-color:#ffffff;--light-theme-base-color:#000000;--light-theme-text-color:var(--paper-grey-900);--light-theme-secondary-color:#737373;--light-theme-disabled-color:#9b9b9b;--light-theme-divider-color:#dbdbdb;--dark-theme-background-color:var(--paper-grey-900);--dark-theme-base-color:#ffffff;--dark-theme-text-color:#ffffff;--dark-theme-secondary-color:#bcbcbc;--dark-theme-disabled-color:#646464;--dark-theme-divider-color:#3c3c3c;--text-primary-color:var(--dark-theme-text-color);--default-primary-color:var(--primary-color)}</style> </custom-style>");

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

__webpack_require__(35);

__webpack_require__(83);

__webpack_require__(30);

var RegisterHtmlTemplate = __webpack_require__(2);

RegisterHtmlTemplate.register("<dom-module id=paper-icon-button> <template strip-whitespace=\"\"> <style>:host{display:inline-block;position:relative;padding:8px;outline:0;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;z-index:0;line-height:1;width:40px;height:40px;-webkit-tap-highlight-color:transparent;-webkit-tap-highlight-color:transparent;box-sizing:border-box!important;@apply --paper-icon-button;}:host #ink{color:var(--paper-icon-button-ink-color,var(--primary-text-color));opacity:.6}:host([disabled]){color:var(--paper-icon-button-disabled-text,var(--disabled-text-color));pointer-events:none;cursor:auto;@apply --paper-icon-button-disabled;}:host([hidden]){display:none!important}:host(:hover){@apply --paper-icon-button-hover;}iron-icon{--iron-icon-width:100%;--iron-icon-height:100%}</style> <iron-icon id=icon src=[[src]] icon=[[icon]] alt$=[[alt]]></iron-icon> </template> </dom-module>");

Polymer({
  is: 'paper-icon-button',

  hostAttributes: {
    role: 'button',
    tabindex: '0'
  },

  behaviors: [Polymer.PaperInkyFocusBehavior],

  properties: {
    /**
     * The URL of an image for the icon. If the src property is specified,
     * the icon property should not be.
     */
    src: {
      type: String
    },

    /**
     * Specifies the icon name or index in the set of icons available in
     * the icon's icon set. If the icon property is specified,
     * the src property should not be.
     */
    icon: {
      type: String
    },

    /**
     * Specifies the alternate text for the button, for accessibility.
     */
    alt: {
      type: String,
      observer: "_altChanged"
    }
  },

  _altChanged: function _altChanged(newValue, oldValue) {
    var label = this.getAttribute('aria-label');

    // Don't stomp over a user-set aria-label.
    if (!label || oldValue == label) {
      this.setAttribute('aria-label', newValue);
    }
  }
});

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

/**
 * @demo demo/index.html
 * @polymerBehavior
 */
Polymer.IronControlState = {

  properties: {

    /**
     * If true, the element currently has focus.
     */
    focused: {
      type: Boolean,
      value: false,
      notify: true,
      readOnly: true,
      reflectToAttribute: true
    },

    /**
     * If true, the user cannot interact with this element.
     */
    disabled: {
      type: Boolean,
      value: false,
      notify: true,
      observer: '_disabledChanged',
      reflectToAttribute: true
    },

    _oldTabIndex: {
      type: Number
    },

    _boundFocusBlurHandler: {
      type: Function,
      value: function value() {
        return this._focusBlurHandler.bind(this);
      }
    },

    __handleEventRetargeting: {
      type: Boolean,
      value: function value() {
        return !this.shadowRoot && !Polymer.Element;
      }
    }
  },

  observers: ['_changedControlState(focused, disabled)'],

  ready: function ready() {
    this.addEventListener('focus', this._boundFocusBlurHandler, true);
    this.addEventListener('blur', this._boundFocusBlurHandler, true);
  },

  _focusBlurHandler: function _focusBlurHandler(event) {
    // In Polymer 2.0, the library takes care of retargeting events.
    if (Polymer.Element) {
      this._setFocused(event.type === 'focus');
      return;
    }

    // NOTE(cdata):  if we are in ShadowDOM land, `event.target` will
    // eventually become `this` due to retargeting; if we are not in
    // ShadowDOM land, `event.target` will eventually become `this` due
    // to the second conditional which fires a synthetic event (that is also
    // handled). In either case, we can disregard `event.path`.
    if (event.target === this) {
      this._setFocused(event.type === 'focus');
    } else if (this.__handleEventRetargeting) {
      var target = /** @type {Node} */Polymer.dom(event).localTarget;
      if (!this.isLightDescendant(target)) {
        this.fire(event.type, { sourceEvent: event }, {
          node: this,
          bubbles: event.bubbles,
          cancelable: event.cancelable
        });
      }
    }
  },

  _disabledChanged: function _disabledChanged(disabled, old) {
    this.setAttribute('aria-disabled', disabled ? 'true' : 'false');
    this.style.pointerEvents = disabled ? 'none' : '';
    if (disabled) {
      this._oldTabIndex = this.tabIndex;
      this._setFocused(false);
      this.tabIndex = -1;
      this.blur();
    } else if (this._oldTabIndex !== undefined) {
      this.tabIndex = this._oldTabIndex;
    }
  },

  _changedControlState: function _changedControlState() {
    // _controlStateChanged is abstract, follow-on behaviors may implement it
    if (this._controlStateChanged) {
      this._controlStateChanged();
    }
  }

};

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

__webpack_require__(16);

var RegisterHtmlTemplate = __webpack_require__(2);

RegisterHtmlTemplate.register("<dom-module id=paper-ripple> <template> <style>:host{display:block;position:absolute;border-radius:inherit;overflow:hidden;top:0;left:0;right:0;bottom:0;pointer-events:none}:host([animating]){-webkit-transform:translate(0,0);transform:translate3d(0,0,0)}#background,#waves,.wave,.wave-container{pointer-events:none;position:absolute;top:0;left:0;width:100%;height:100%}#background,.wave{opacity:0}#waves,.wave{overflow:hidden}.wave,.wave-container{border-radius:50%}:host(.circle) #background,:host(.circle) #waves{border-radius:50%}:host(.circle) .wave-container{overflow:hidden}</style> <div id=background></div> <div id=waves></div> </template> </dom-module>");

(function () {
  'use strict';

  var Utility = {
    distance: function distance(x1, y1, x2, y2) {
      var xDelta = x1 - x2;
      var yDelta = y1 - y2;

      return Math.sqrt(xDelta * xDelta + yDelta * yDelta);
    },

    now: window.performance && window.performance.now ? window.performance.now.bind(window.performance) : Date.now
  };

  /**
   * @param {HTMLElement} element
   * @constructor
   */
  function ElementMetrics(element) {
    this.element = element;
    this.width = this.boundingRect.width;
    this.height = this.boundingRect.height;

    this.size = Math.max(this.width, this.height);
  }

  ElementMetrics.prototype = {
    get boundingRect() {
      return this.element.getBoundingClientRect();
    },

    furthestCornerDistanceFrom: function furthestCornerDistanceFrom(x, y) {
      var topLeft = Utility.distance(x, y, 0, 0);
      var topRight = Utility.distance(x, y, this.width, 0);
      var bottomLeft = Utility.distance(x, y, 0, this.height);
      var bottomRight = Utility.distance(x, y, this.width, this.height);

      return Math.max(topLeft, topRight, bottomLeft, bottomRight);
    }
  };

  /**
   * @param {HTMLElement} element
   * @constructor
   */
  function Ripple(element) {
    this.element = element;
    this.color = window.getComputedStyle(element).color;

    this.wave = document.createElement('div');
    this.waveContainer = document.createElement('div');
    this.wave.style.backgroundColor = this.color;
    this.wave.classList.add('wave');
    this.waveContainer.classList.add('wave-container');
    Polymer.dom(this.waveContainer).appendChild(this.wave);

    this.resetInteractionState();
  }

  Ripple.MAX_RADIUS = 300;

  Ripple.prototype = {
    get recenters() {
      return this.element.recenters;
    },

    get center() {
      return this.element.center;
    },

    get mouseDownElapsed() {
      var elapsed;

      if (!this.mouseDownStart) {
        return 0;
      }

      elapsed = Utility.now() - this.mouseDownStart;

      if (this.mouseUpStart) {
        elapsed -= this.mouseUpElapsed;
      }

      return elapsed;
    },

    get mouseUpElapsed() {
      return this.mouseUpStart ? Utility.now() - this.mouseUpStart : 0;
    },

    get mouseDownElapsedSeconds() {
      return this.mouseDownElapsed / 1000;
    },

    get mouseUpElapsedSeconds() {
      return this.mouseUpElapsed / 1000;
    },

    get mouseInteractionSeconds() {
      return this.mouseDownElapsedSeconds + this.mouseUpElapsedSeconds;
    },

    get initialOpacity() {
      return this.element.initialOpacity;
    },

    get opacityDecayVelocity() {
      return this.element.opacityDecayVelocity;
    },

    get radius() {
      var width2 = this.containerMetrics.width * this.containerMetrics.width;
      var height2 = this.containerMetrics.height * this.containerMetrics.height;
      var waveRadius = Math.min(Math.sqrt(width2 + height2), Ripple.MAX_RADIUS) * 1.1 + 5;

      var duration = 1.1 - 0.2 * (waveRadius / Ripple.MAX_RADIUS);
      var timeNow = this.mouseInteractionSeconds / duration;
      var size = waveRadius * (1 - Math.pow(80, -timeNow));

      return Math.abs(size);
    },

    get opacity() {
      if (!this.mouseUpStart) {
        return this.initialOpacity;
      }

      return Math.max(0, this.initialOpacity - this.mouseUpElapsedSeconds * this.opacityDecayVelocity);
    },

    get outerOpacity() {
      // Linear increase in background opacity, capped at the opacity
      // of the wavefront (waveOpacity).
      var outerOpacity = this.mouseUpElapsedSeconds * 0.3;
      var waveOpacity = this.opacity;

      return Math.max(0, Math.min(outerOpacity, waveOpacity));
    },

    get isOpacityFullyDecayed() {
      return this.opacity < 0.01 && this.radius >= Math.min(this.maxRadius, Ripple.MAX_RADIUS);
    },

    get isRestingAtMaxRadius() {
      return this.opacity >= this.initialOpacity && this.radius >= Math.min(this.maxRadius, Ripple.MAX_RADIUS);
    },

    get isAnimationComplete() {
      return this.mouseUpStart ? this.isOpacityFullyDecayed : this.isRestingAtMaxRadius;
    },

    get translationFraction() {
      return Math.min(1, this.radius / this.containerMetrics.size * 2 / Math.sqrt(2));
    },

    get xNow() {
      if (this.xEnd) {
        return this.xStart + this.translationFraction * (this.xEnd - this.xStart);
      }

      return this.xStart;
    },

    get yNow() {
      if (this.yEnd) {
        return this.yStart + this.translationFraction * (this.yEnd - this.yStart);
      }

      return this.yStart;
    },

    get isMouseDown() {
      return this.mouseDownStart && !this.mouseUpStart;
    },

    resetInteractionState: function resetInteractionState() {
      this.maxRadius = 0;
      this.mouseDownStart = 0;
      this.mouseUpStart = 0;

      this.xStart = 0;
      this.yStart = 0;
      this.xEnd = 0;
      this.yEnd = 0;
      this.slideDistance = 0;

      this.containerMetrics = new ElementMetrics(this.element);
    },

    draw: function draw() {
      var scale;
      var translateString;
      var dx;
      var dy;

      this.wave.style.opacity = this.opacity;

      scale = this.radius / (this.containerMetrics.size / 2);
      dx = this.xNow - this.containerMetrics.width / 2;
      dy = this.yNow - this.containerMetrics.height / 2;

      // 2d transform for safari because of border-radius and overflow:hidden clipping bug.
      // https://bugs.webkit.org/show_bug.cgi?id=98538
      this.waveContainer.style.webkitTransform = 'translate(' + dx + 'px, ' + dy + 'px)';
      this.waveContainer.style.transform = 'translate3d(' + dx + 'px, ' + dy + 'px, 0)';
      this.wave.style.webkitTransform = 'scale(' + scale + ',' + scale + ')';
      this.wave.style.transform = 'scale3d(' + scale + ',' + scale + ',1)';
    },

    /** @param {Event=} event */
    downAction: function downAction(event) {
      var xCenter = this.containerMetrics.width / 2;
      var yCenter = this.containerMetrics.height / 2;

      this.resetInteractionState();
      this.mouseDownStart = Utility.now();

      if (this.center) {
        this.xStart = xCenter;
        this.yStart = yCenter;
        this.slideDistance = Utility.distance(this.xStart, this.yStart, this.xEnd, this.yEnd);
      } else {
        this.xStart = event ? event.detail.x - this.containerMetrics.boundingRect.left : this.containerMetrics.width / 2;
        this.yStart = event ? event.detail.y - this.containerMetrics.boundingRect.top : this.containerMetrics.height / 2;
      }

      if (this.recenters) {
        this.xEnd = xCenter;
        this.yEnd = yCenter;
        this.slideDistance = Utility.distance(this.xStart, this.yStart, this.xEnd, this.yEnd);
      }

      this.maxRadius = this.containerMetrics.furthestCornerDistanceFrom(this.xStart, this.yStart);

      this.waveContainer.style.top = (this.containerMetrics.height - this.containerMetrics.size) / 2 + 'px';
      this.waveContainer.style.left = (this.containerMetrics.width - this.containerMetrics.size) / 2 + 'px';

      this.waveContainer.style.width = this.containerMetrics.size + 'px';
      this.waveContainer.style.height = this.containerMetrics.size + 'px';
    },

    /** @param {Event=} event */
    upAction: function upAction(event) {
      if (!this.isMouseDown) {
        return;
      }

      this.mouseUpStart = Utility.now();
    },

    remove: function remove() {
      Polymer.dom(this.waveContainer.parentNode).removeChild(this.waveContainer);
    }
  };

  Polymer({
    is: 'paper-ripple',

    behaviors: [Polymer.IronA11yKeysBehavior],

    properties: {
      /**
       * The initial opacity set on the wave.
       *
       * @attribute initialOpacity
       * @type number
       * @default 0.25
       */
      initialOpacity: {
        type: Number,
        value: 0.25
      },

      /**
       * How fast (opacity per second) the wave fades out.
       *
       * @attribute opacityDecayVelocity
       * @type number
       * @default 0.8
       */
      opacityDecayVelocity: {
        type: Number,
        value: 0.8
      },

      /**
       * If true, ripples will exhibit a gravitational pull towards
       * the center of their container as they fade away.
       *
       * @attribute recenters
       * @type boolean
       * @default false
       */
      recenters: {
        type: Boolean,
        value: false
      },

      /**
       * If true, ripples will center inside its container
       *
       * @attribute recenters
       * @type boolean
       * @default false
       */
      center: {
        type: Boolean,
        value: false
      },

      /**
       * A list of the visual ripples.
       *
       * @attribute ripples
       * @type Array
       * @default []
       */
      ripples: {
        type: Array,
        value: function value() {
          return [];
        }
      },

      /**
       * True when there are visible ripples animating within the
       * element.
       */
      animating: {
        type: Boolean,
        readOnly: true,
        reflectToAttribute: true,
        value: false
      },

      /**
       * If true, the ripple will remain in the "down" state until `holdDown`
       * is set to false again.
       */
      holdDown: {
        type: Boolean,
        value: false,
        observer: '_holdDownChanged'
      },

      /**
       * If true, the ripple will not generate a ripple effect
       * via pointer interaction.
       * Calling ripple's imperative api like `simulatedRipple` will
       * still generate the ripple effect.
       */
      noink: {
        type: Boolean,
        value: false
      },

      _animating: {
        type: Boolean
      },

      _boundAnimate: {
        type: Function,
        value: function value() {
          return this.animate.bind(this);
        }
      }
    },

    get target() {
      return this.keyEventTarget;
    },

    keyBindings: {
      'enter:keydown': '_onEnterKeydown',
      'space:keydown': '_onSpaceKeydown',
      'space:keyup': '_onSpaceKeyup'
    },

    attached: function attached() {
      // Set up a11yKeysBehavior to listen to key events on the target,
      // so that space and enter activate the ripple even if the target doesn't
      // handle key events. The key handlers deal with `noink` themselves.
      if (this.parentNode.nodeType == 11) {
        // DOCUMENT_FRAGMENT_NODE
        this.keyEventTarget = Polymer.dom(this).getOwnerRoot().host;
      } else {
        this.keyEventTarget = this.parentNode;
      }
      var keyEventTarget = /** @type {!EventTarget} */this.keyEventTarget;
      this.listen(keyEventTarget, 'up', 'uiUpAction');
      this.listen(keyEventTarget, 'down', 'uiDownAction');
    },

    detached: function detached() {
      this.unlisten(this.keyEventTarget, 'up', 'uiUpAction');
      this.unlisten(this.keyEventTarget, 'down', 'uiDownAction');
      this.keyEventTarget = null;
    },

    get shouldKeepAnimating() {
      for (var index = 0; index < this.ripples.length; ++index) {
        if (!this.ripples[index].isAnimationComplete) {
          return true;
        }
      }

      return false;
    },

    simulatedRipple: function simulatedRipple() {
      this.downAction(null);

      // Please see polymer/polymer#1305
      this.async(function () {
        this.upAction();
      }, 1);
    },

    /**
     * Provokes a ripple down effect via a UI event,
     * respecting the `noink` property.
     * @param {Event=} event
     */
    uiDownAction: function uiDownAction(event) {
      if (!this.noink) {
        this.downAction(event);
      }
    },

    /**
     * Provokes a ripple down effect via a UI event,
     * *not* respecting the `noink` property.
     * @param {Event=} event
     */
    downAction: function downAction(event) {
      if (this.holdDown && this.ripples.length > 0) {
        return;
      }

      var ripple = this.addRipple();

      ripple.downAction(event);

      if (!this._animating) {
        this._animating = true;
        this.animate();
      }
    },

    /**
     * Provokes a ripple up effect via a UI event,
     * respecting the `noink` property.
     * @param {Event=} event
     */
    uiUpAction: function uiUpAction(event) {
      if (!this.noink) {
        this.upAction(event);
      }
    },

    /**
     * Provokes a ripple up effect via a UI event,
     * *not* respecting the `noink` property.
     * @param {Event=} event
     */
    upAction: function upAction(event) {
      if (this.holdDown) {
        return;
      }

      this.ripples.forEach(function (ripple) {
        ripple.upAction(event);
      });

      this._animating = true;
      this.animate();
    },

    onAnimationComplete: function onAnimationComplete() {
      this._animating = false;
      this.$.background.style.backgroundColor = null;
      this.fire('transitionend');
    },

    addRipple: function addRipple() {
      var ripple = new Ripple(this);

      Polymer.dom(this.$.waves).appendChild(ripple.waveContainer);
      this.$.background.style.backgroundColor = ripple.color;
      this.ripples.push(ripple);

      this._setAnimating(true);

      return ripple;
    },

    removeRipple: function removeRipple(ripple) {
      var rippleIndex = this.ripples.indexOf(ripple);

      if (rippleIndex < 0) {
        return;
      }

      this.ripples.splice(rippleIndex, 1);

      ripple.remove();

      if (!this.ripples.length) {
        this._setAnimating(false);
      }
    },

    /**
     * This conflicts with Element#antimate().
     * https://developer.mozilla.org/en-US/docs/Web/API/Element/animate
     * @suppress {checkTypes}
     */
    animate: function animate() {
      if (!this._animating) {
        return;
      }
      var index;
      var ripple;

      for (index = 0; index < this.ripples.length; ++index) {
        ripple = this.ripples[index];

        ripple.draw();

        this.$.background.style.opacity = ripple.outerOpacity;

        if (ripple.isOpacityFullyDecayed && !ripple.isRestingAtMaxRadius) {
          this.removeRipple(ripple);
        }
      }

      if (!this.shouldKeepAnimating && this.ripples.length === 0) {
        this.onAnimationComplete();
      } else {
        window.requestAnimationFrame(this._boundAnimate);
      }
    },

    _onEnterKeydown: function _onEnterKeydown() {
      this.uiDownAction();
      this.async(this.uiUpAction, 1);
    },

    _onSpaceKeydown: function _onSpaceKeydown() {
      this.uiDownAction();
    },

    _onSpaceKeyup: function _onSpaceKeyup() {
      this.uiUpAction();
    },

    // note: holdDown does not respect noink since it can be a focus based
    // effect.
    _holdDownChanged: function _holdDownChanged(newVal, oldVal) {
      if (oldVal === undefined) {
        return;
      }
      if (newVal) {
        this.downAction();
      } else {
        this.upAction();
      }
    }

    /**
    Fired when the animation finishes.
    This is useful if you want to wait until
    the ripple animation finishes to perform some action.
     @event transitionend
    @param {{node: Object}} detail Contains the animated node.
    */
  });
})();

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

/**
 * `Polymer.IronScrollTargetBehavior` allows an element to respond to scroll events from a
 * designated scroll target.
 *
 * Elements that consume this behavior can override the `_scrollHandler`
 * method to add logic on the scroll event.
 *
 * @demo demo/scrolling-region.html Scrolling Region
 * @demo demo/document.html Document Element
 * @polymerBehavior
 */
Polymer.IronScrollTargetBehavior = {

  properties: {

    /**
     * Specifies the element that will handle the scroll event
     * on the behalf of the current element. This is typically a reference to an element,
     * but there are a few more posibilities:
     *
     * ### Elements id
     *
     *```html
     * <div id="scrollable-element" style="overflow: auto;">
     *  <x-element scroll-target="scrollable-element">
     *    <!-- Content-->
     *  </x-element>
     * </div>
     *```
     * In this case, the `scrollTarget` will point to the outer div element.
     *
     * ### Document scrolling
     *
     * For document scrolling, you can use the reserved word `document`:
     *
     *```html
     * <x-element scroll-target="document">
     *   <!-- Content -->
     * </x-element>
     *```
     *
     * ### Elements reference
     *
     *```js
     * appHeader.scrollTarget = document.querySelector('#scrollable-element');
     *```
     *
     * @type {HTMLElement}
     * @default document
     */
    scrollTarget: {
      type: HTMLElement,
      value: function value() {
        return this._defaultScrollTarget;
      }
    }
  },

  observers: ['_scrollTargetChanged(scrollTarget, isAttached)'],

  /**
   * True if the event listener should be installed.
   */
  _shouldHaveListener: true,

  _scrollTargetChanged: function _scrollTargetChanged(scrollTarget, isAttached) {
    var eventTarget;

    if (this._oldScrollTarget) {
      this._toggleScrollListener(false, this._oldScrollTarget);
      this._oldScrollTarget = null;
    }
    if (!isAttached) {
      return;
    }
    // Support element id references
    if (scrollTarget === 'document') {

      this.scrollTarget = this._doc;
    } else if (typeof scrollTarget === 'string') {

      var domHost = this.domHost;

      this.scrollTarget = domHost && domHost.$ ? domHost.$[scrollTarget] : Polymer.dom(this.ownerDocument).querySelector('#' + scrollTarget);
    } else if (this._isValidScrollTarget()) {

      this._oldScrollTarget = scrollTarget;
      this._toggleScrollListener(this._shouldHaveListener, scrollTarget);
    }
  },

  /**
   * Runs on every scroll event. Consumer of this behavior may override this method.
   *
   * @protected
   */
  _scrollHandler: function scrollHandler() {},

  /**
   * The default scroll target. Consumers of this behavior may want to customize
   * the default scroll target.
   *
   * @type {Element}
   */
  get _defaultScrollTarget() {
    return this._doc;
  },

  /**
   * Shortcut for the document element
   *
   * @type {Element}
   */
  get _doc() {
    return this.ownerDocument.documentElement;
  },

  /**
   * Gets the number of pixels that the content of an element is scrolled upward.
   *
   * @type {number}
   */
  get _scrollTop() {
    if (this._isValidScrollTarget()) {
      return this.scrollTarget === this._doc ? window.pageYOffset : this.scrollTarget.scrollTop;
    }
    return 0;
  },

  /**
   * Gets the number of pixels that the content of an element is scrolled to the left.
   *
   * @type {number}
   */
  get _scrollLeft() {
    if (this._isValidScrollTarget()) {
      return this.scrollTarget === this._doc ? window.pageXOffset : this.scrollTarget.scrollLeft;
    }
    return 0;
  },

  /**
   * Sets the number of pixels that the content of an element is scrolled upward.
   *
   * @type {number}
   */
  set _scrollTop(top) {
    if (this.scrollTarget === this._doc) {
      window.scrollTo(window.pageXOffset, top);
    } else if (this._isValidScrollTarget()) {
      this.scrollTarget.scrollTop = top;
    }
  },

  /**
   * Sets the number of pixels that the content of an element is scrolled to the left.
   *
   * @type {number}
   */
  set _scrollLeft(left) {
    if (this.scrollTarget === this._doc) {
      window.scrollTo(left, window.pageYOffset);
    } else if (this._isValidScrollTarget()) {
      this.scrollTarget.scrollLeft = left;
    }
  },

  /**
   * Scrolls the content to a particular place.
   *
   * @method scroll
   * @param {number} left The left position
   * @param {number} top The top position
   */
  scroll: function scroll(left, top) {
    if (this.scrollTarget === this._doc) {
      window.scrollTo(left, top);
    } else if (this._isValidScrollTarget()) {
      this.scrollTarget.scrollLeft = left;
      this.scrollTarget.scrollTop = top;
    }
  },

  /**
   * Gets the width of the scroll target.
   *
   * @type {number}
   */
  get _scrollTargetWidth() {
    if (this._isValidScrollTarget()) {
      return this.scrollTarget === this._doc ? window.innerWidth : this.scrollTarget.offsetWidth;
    }
    return 0;
  },

  /**
   * Gets the height of the scroll target.
   *
   * @type {number}
   */
  get _scrollTargetHeight() {
    if (this._isValidScrollTarget()) {
      return this.scrollTarget === this._doc ? window.innerHeight : this.scrollTarget.offsetHeight;
    }
    return 0;
  },

  /**
   * Returns true if the scroll target is a valid HTMLElement.
   *
   * @return {boolean}
   */
  _isValidScrollTarget: function _isValidScrollTarget() {
    return this.scrollTarget instanceof HTMLElement;
  },

  _toggleScrollListener: function _toggleScrollListener(yes, scrollTarget) {
    var eventTarget = scrollTarget === this._doc ? window : scrollTarget;
    if (yes) {
      if (!this._boundScrollHandler) {
        this._boundScrollHandler = this._scrollHandler.bind(this);
        eventTarget.addEventListener('scroll', this._boundScrollHandler);
      }
    } else {
      if (this._boundScrollHandler) {
        eventTarget.removeEventListener('scroll', this._boundScrollHandler);
        this._boundScrollHandler = null;
      }
    }
  },

  /**
   * Enables or disables the scroll event listener.
   *
   * @param {boolean} yes True to add the event, False to remove it.
   */
  toggleScrollListener: function toggleScrollListener(yes) {
    this._shouldHaveListener = yes;
    this._toggleScrollListener(yes, this.scrollTarget);
  }

};

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

__webpack_require__(18);

__webpack_require__(5);

var RegisterHtmlTemplate = __webpack_require__(2);

RegisterHtmlTemplate.register("<dom-module id=iron-icon> <template> <style>:host{@apply --layout-inline;@apply --layout-center-center;position:relative;vertical-align:middle;fill:var(--iron-icon-fill-color,currentcolor);stroke:var(--iron-icon-stroke-color,none);width:var(--iron-icon-width,24px);height:var(--iron-icon-height,24px);@apply --iron-icon;}:host([hidden]){display:none}</style> </template> </dom-module>");

Polymer({

  is: 'iron-icon',

  properties: {

    /**
     * The name of the icon to use. The name should be of the form:
     * `iconset_name:icon_name`.
     */
    icon: {
      type: String
    },

    /**
     * The name of the theme to used, if one is specified by the
     * iconset.
     */
    theme: {
      type: String
    },

    /**
     * If using iron-icon without an iconset, you can set the src to be
     * the URL of an individual icon image file. Note that this will take
     * precedence over a given icon attribute.
     */
    src: {
      type: String
    },

    /**
     * @type {!Polymer.IronMeta}
     */
    _meta: {
      value: Polymer.Base.create('iron-meta', { type: 'iconset' })
    }

  },

  observers: ['_updateIcon(_meta, isAttached)', '_updateIcon(theme, isAttached)', '_srcChanged(src, isAttached)', '_iconChanged(icon, isAttached)'],

  _DEFAULT_ICONSET: 'icons',

  _iconChanged: function _iconChanged(icon) {
    var parts = (icon || '').split(':');
    this._iconName = parts.pop();
    this._iconsetName = parts.pop() || this._DEFAULT_ICONSET;
    this._updateIcon();
  },

  _srcChanged: function _srcChanged(src) {
    this._updateIcon();
  },

  _usesIconset: function _usesIconset() {
    return this.icon || !this.src;
  },

  /** @suppress {visibility} */
  _updateIcon: function _updateIcon() {
    if (this._usesIconset()) {
      if (this._img && this._img.parentNode) {
        Polymer.dom(this.root).removeChild(this._img);
      }
      if (this._iconName === "") {
        if (this._iconset) {
          this._iconset.removeIcon(this);
        }
      } else if (this._iconsetName && this._meta) {
        this._iconset = /** @type {?Polymer.Iconset} */this._meta.byKey(this._iconsetName);
        if (this._iconset) {
          this._iconset.applyIcon(this, this._iconName, this.theme);
          this.unlisten(window, 'iron-iconset-added', '_updateIcon');
        } else {
          this.listen(window, 'iron-iconset-added', '_updateIcon');
        }
      }
    } else {
      if (this._iconset) {
        this._iconset.removeIcon(this);
      }
      if (!this._img) {
        this._img = document.createElement('img');
        this._img.style.width = '100%';
        this._img.style.height = '100%';
        this._img.draggable = false;
      }
      this._img.src = this.src;
      Polymer.dom(this.root).appendChild(this._img);
    }
  }

});

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

__webpack_require__(16);

__webpack_require__(32);

/**
 * @demo demo/index.html
 * @polymerBehavior Polymer.IronButtonState
 */
Polymer.IronButtonStateImpl = {

  properties: {

    /**
     * If true, the user is currently holding down the button.
     */
    pressed: {
      type: Boolean,
      readOnly: true,
      value: false,
      reflectToAttribute: true,
      observer: '_pressedChanged'
    },

    /**
     * If true, the button toggles the active state with each tap or press
     * of the spacebar.
     */
    toggles: {
      type: Boolean,
      value: false,
      reflectToAttribute: true
    },

    /**
     * If true, the button is a toggle and is currently in the active state.
     */
    active: {
      type: Boolean,
      value: false,
      notify: true,
      reflectToAttribute: true
    },

    /**
     * True if the element is currently being pressed by a "pointer," which
     * is loosely defined as mouse or touch input (but specifically excluding
     * keyboard input).
     */
    pointerDown: {
      type: Boolean,
      readOnly: true,
      value: false
    },

    /**
     * True if the input device that caused the element to receive focus
     * was a keyboard.
     */
    receivedFocusFromKeyboard: {
      type: Boolean,
      readOnly: true
    },

    /**
     * The aria attribute to be set if the button is a toggle and in the
     * active state.
     */
    ariaActiveAttribute: {
      type: String,
      value: 'aria-pressed',
      observer: '_ariaActiveAttributeChanged'
    }
  },

  listeners: {
    down: '_downHandler',
    up: '_upHandler',
    tap: '_tapHandler'
  },

  observers: ['_focusChanged(focused)', '_activeChanged(active, ariaActiveAttribute)'],

  keyBindings: {
    'enter:keydown': '_asyncClick',
    'space:keydown': '_spaceKeyDownHandler',
    'space:keyup': '_spaceKeyUpHandler'
  },

  _mouseEventRe: /^mouse/,

  _tapHandler: function _tapHandler() {
    if (this.toggles) {
      // a tap is needed to toggle the active state
      this._userActivate(!this.active);
    } else {
      this.active = false;
    }
  },

  _focusChanged: function _focusChanged(focused) {
    this._detectKeyboardFocus(focused);

    if (!focused) {
      this._setPressed(false);
    }
  },

  _detectKeyboardFocus: function _detectKeyboardFocus(focused) {
    this._setReceivedFocusFromKeyboard(!this.pointerDown && focused);
  },

  // to emulate native checkbox, (de-)activations from a user interaction fire
  // 'change' events
  _userActivate: function _userActivate(active) {
    if (this.active !== active) {
      this.active = active;
      this.fire('change');
    }
  },

  _downHandler: function _downHandler(event) {
    this._setPointerDown(true);
    this._setPressed(true);
    this._setReceivedFocusFromKeyboard(false);
  },

  _upHandler: function _upHandler() {
    this._setPointerDown(false);
    this._setPressed(false);
  },

  /**
   * @param {!KeyboardEvent} event .
   */
  _spaceKeyDownHandler: function _spaceKeyDownHandler(event) {
    var keyboardEvent = event.detail.keyboardEvent;
    var target = Polymer.dom(keyboardEvent).localTarget;

    // Ignore the event if this is coming from a focused light child, since that
    // element will deal with it.
    if (this.isLightDescendant( /** @type {Node} */target)) return;

    keyboardEvent.preventDefault();
    keyboardEvent.stopImmediatePropagation();
    this._setPressed(true);
  },

  /**
   * @param {!KeyboardEvent} event .
   */
  _spaceKeyUpHandler: function _spaceKeyUpHandler(event) {
    var keyboardEvent = event.detail.keyboardEvent;
    var target = Polymer.dom(keyboardEvent).localTarget;

    // Ignore the event if this is coming from a focused light child, since that
    // element will deal with it.
    if (this.isLightDescendant( /** @type {Node} */target)) return;

    if (this.pressed) {
      this._asyncClick();
    }
    this._setPressed(false);
  },

  // trigger click asynchronously, the asynchrony is useful to allow one
  // event handler to unwind before triggering another event
  _asyncClick: function _asyncClick() {
    this.async(function () {
      this.click();
    }, 1);
  },

  // any of these changes are considered a change to button state

  _pressedChanged: function _pressedChanged(pressed) {
    this._changedButtonState();
  },

  _ariaActiveAttributeChanged: function _ariaActiveAttributeChanged(value, oldValue) {
    if (oldValue && oldValue != value && this.hasAttribute(oldValue)) {
      this.removeAttribute(oldValue);
    }
  },

  _activeChanged: function _activeChanged(active, ariaActiveAttribute) {
    if (this.toggles) {
      this.setAttribute(this.ariaActiveAttribute, active ? 'true' : 'false');
    } else {
      this.removeAttribute(this.ariaActiveAttribute);
    }
    this._changedButtonState();
  },

  _controlStateChanged: function _controlStateChanged() {
    if (this.disabled) {
      this._setPressed(false);
    } else {
      this._changedButtonState();
    }
  },

  // provide hook for follow-on behaviors to react to button-state

  _changedButtonState: function _changedButtonState() {
    if (this._buttonStateChanged) {
      this._buttonStateChanged(); // abstract
    }
  }

};

/** @polymerBehavior */
Polymer.IronButtonState = [Polymer.IronA11yKeysBehavior, Polymer.IronButtonStateImpl];

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

var RegisterHtmlTemplate = __webpack_require__(2);

RegisterHtmlTemplate.toBody("<custom-style> <style is=custom-style>html{--google-red-100:#f4c7c3;--google-red-300:#e67c73;--google-red-500:#db4437;--google-red-700:#c53929;--google-blue-100:#c6dafc;--google-blue-300:#7baaf7;--google-blue-500:#4285f4;--google-blue-700:#3367d6;--google-green-100:#b7e1cd;--google-green-300:#57bb8a;--google-green-500:#0f9d58;--google-green-700:#0b8043;--google-yellow-100:#fce8b2;--google-yellow-300:#f7cb4d;--google-yellow-500:#f4b400;--google-yellow-700:#f09300;--google-grey-100:#f5f5f5;--google-grey-300:#e0e0e0;--google-grey-500:#9e9e9e;--google-grey-700:#616161;--paper-red-50:#ffebee;--paper-red-100:#ffcdd2;--paper-red-200:#ef9a9a;--paper-red-300:#e57373;--paper-red-400:#ef5350;--paper-red-500:#f44336;--paper-red-600:#e53935;--paper-red-700:#d32f2f;--paper-red-800:#c62828;--paper-red-900:#b71c1c;--paper-red-a100:#ff8a80;--paper-red-a200:#ff5252;--paper-red-a400:#ff1744;--paper-red-a700:#d50000;--paper-pink-50:#fce4ec;--paper-pink-100:#f8bbd0;--paper-pink-200:#f48fb1;--paper-pink-300:#f06292;--paper-pink-400:#ec407a;--paper-pink-500:#e91e63;--paper-pink-600:#d81b60;--paper-pink-700:#c2185b;--paper-pink-800:#ad1457;--paper-pink-900:#880e4f;--paper-pink-a100:#ff80ab;--paper-pink-a200:#ff4081;--paper-pink-a400:#f50057;--paper-pink-a700:#c51162;--paper-purple-50:#f3e5f5;--paper-purple-100:#e1bee7;--paper-purple-200:#ce93d8;--paper-purple-300:#ba68c8;--paper-purple-400:#ab47bc;--paper-purple-500:#9c27b0;--paper-purple-600:#8e24aa;--paper-purple-700:#7b1fa2;--paper-purple-800:#6a1b9a;--paper-purple-900:#4a148c;--paper-purple-a100:#ea80fc;--paper-purple-a200:#e040fb;--paper-purple-a400:#d500f9;--paper-purple-a700:#aa00ff;--paper-deep-purple-50:#ede7f6;--paper-deep-purple-100:#d1c4e9;--paper-deep-purple-200:#b39ddb;--paper-deep-purple-300:#9575cd;--paper-deep-purple-400:#7e57c2;--paper-deep-purple-500:#673ab7;--paper-deep-purple-600:#5e35b1;--paper-deep-purple-700:#512da8;--paper-deep-purple-800:#4527a0;--paper-deep-purple-900:#311b92;--paper-deep-purple-a100:#b388ff;--paper-deep-purple-a200:#7c4dff;--paper-deep-purple-a400:#651fff;--paper-deep-purple-a700:#6200ea;--paper-indigo-50:#e8eaf6;--paper-indigo-100:#c5cae9;--paper-indigo-200:#9fa8da;--paper-indigo-300:#7986cb;--paper-indigo-400:#5c6bc0;--paper-indigo-500:#3f51b5;--paper-indigo-600:#3949ab;--paper-indigo-700:#303f9f;--paper-indigo-800:#283593;--paper-indigo-900:#1a237e;--paper-indigo-a100:#8c9eff;--paper-indigo-a200:#536dfe;--paper-indigo-a400:#3d5afe;--paper-indigo-a700:#304ffe;--paper-blue-50:#e3f2fd;--paper-blue-100:#bbdefb;--paper-blue-200:#90caf9;--paper-blue-300:#64b5f6;--paper-blue-400:#42a5f5;--paper-blue-500:#2196f3;--paper-blue-600:#1e88e5;--paper-blue-700:#1976d2;--paper-blue-800:#1565c0;--paper-blue-900:#0d47a1;--paper-blue-a100:#82b1ff;--paper-blue-a200:#448aff;--paper-blue-a400:#2979ff;--paper-blue-a700:#2962ff;--paper-light-blue-50:#e1f5fe;--paper-light-blue-100:#b3e5fc;--paper-light-blue-200:#81d4fa;--paper-light-blue-300:#4fc3f7;--paper-light-blue-400:#29b6f6;--paper-light-blue-500:#03a9f4;--paper-light-blue-600:#039be5;--paper-light-blue-700:#0288d1;--paper-light-blue-800:#0277bd;--paper-light-blue-900:#01579b;--paper-light-blue-a100:#80d8ff;--paper-light-blue-a200:#40c4ff;--paper-light-blue-a400:#00b0ff;--paper-light-blue-a700:#0091ea;--paper-cyan-50:#e0f7fa;--paper-cyan-100:#b2ebf2;--paper-cyan-200:#80deea;--paper-cyan-300:#4dd0e1;--paper-cyan-400:#26c6da;--paper-cyan-500:#00bcd4;--paper-cyan-600:#00acc1;--paper-cyan-700:#0097a7;--paper-cyan-800:#00838f;--paper-cyan-900:#006064;--paper-cyan-a100:#84ffff;--paper-cyan-a200:#18ffff;--paper-cyan-a400:#00e5ff;--paper-cyan-a700:#00b8d4;--paper-teal-50:#e0f2f1;--paper-teal-100:#b2dfdb;--paper-teal-200:#80cbc4;--paper-teal-300:#4db6ac;--paper-teal-400:#26a69a;--paper-teal-500:#009688;--paper-teal-600:#00897b;--paper-teal-700:#00796b;--paper-teal-800:#00695c;--paper-teal-900:#004d40;--paper-teal-a100:#a7ffeb;--paper-teal-a200:#64ffda;--paper-teal-a400:#1de9b6;--paper-teal-a700:#00bfa5;--paper-green-50:#e8f5e9;--paper-green-100:#c8e6c9;--paper-green-200:#a5d6a7;--paper-green-300:#81c784;--paper-green-400:#66bb6a;--paper-green-500:#4caf50;--paper-green-600:#43a047;--paper-green-700:#388e3c;--paper-green-800:#2e7d32;--paper-green-900:#1b5e20;--paper-green-a100:#b9f6ca;--paper-green-a200:#69f0ae;--paper-green-a400:#00e676;--paper-green-a700:#00c853;--paper-light-green-50:#f1f8e9;--paper-light-green-100:#dcedc8;--paper-light-green-200:#c5e1a5;--paper-light-green-300:#aed581;--paper-light-green-400:#9ccc65;--paper-light-green-500:#8bc34a;--paper-light-green-600:#7cb342;--paper-light-green-700:#689f38;--paper-light-green-800:#558b2f;--paper-light-green-900:#33691e;--paper-light-green-a100:#ccff90;--paper-light-green-a200:#b2ff59;--paper-light-green-a400:#76ff03;--paper-light-green-a700:#64dd17;--paper-lime-50:#f9fbe7;--paper-lime-100:#f0f4c3;--paper-lime-200:#e6ee9c;--paper-lime-300:#dce775;--paper-lime-400:#d4e157;--paper-lime-500:#cddc39;--paper-lime-600:#c0ca33;--paper-lime-700:#afb42b;--paper-lime-800:#9e9d24;--paper-lime-900:#827717;--paper-lime-a100:#f4ff81;--paper-lime-a200:#eeff41;--paper-lime-a400:#c6ff00;--paper-lime-a700:#aeea00;--paper-yellow-50:#fffde7;--paper-yellow-100:#fff9c4;--paper-yellow-200:#fff59d;--paper-yellow-300:#fff176;--paper-yellow-400:#ffee58;--paper-yellow-500:#ffeb3b;--paper-yellow-600:#fdd835;--paper-yellow-700:#fbc02d;--paper-yellow-800:#f9a825;--paper-yellow-900:#f57f17;--paper-yellow-a100:#ffff8d;--paper-yellow-a200:#ffff00;--paper-yellow-a400:#ffea00;--paper-yellow-a700:#ffd600;--paper-amber-50:#fff8e1;--paper-amber-100:#ffecb3;--paper-amber-200:#ffe082;--paper-amber-300:#ffd54f;--paper-amber-400:#ffca28;--paper-amber-500:#ffc107;--paper-amber-600:#ffb300;--paper-amber-700:#ffa000;--paper-amber-800:#ff8f00;--paper-amber-900:#ff6f00;--paper-amber-a100:#ffe57f;--paper-amber-a200:#ffd740;--paper-amber-a400:#ffc400;--paper-amber-a700:#ffab00;--paper-orange-50:#fff3e0;--paper-orange-100:#ffe0b2;--paper-orange-200:#ffcc80;--paper-orange-300:#ffb74d;--paper-orange-400:#ffa726;--paper-orange-500:#ff9800;--paper-orange-600:#fb8c00;--paper-orange-700:#f57c00;--paper-orange-800:#ef6c00;--paper-orange-900:#e65100;--paper-orange-a100:#ffd180;--paper-orange-a200:#ffab40;--paper-orange-a400:#ff9100;--paper-orange-a700:#ff6500;--paper-deep-orange-50:#fbe9e7;--paper-deep-orange-100:#ffccbc;--paper-deep-orange-200:#ffab91;--paper-deep-orange-300:#ff8a65;--paper-deep-orange-400:#ff7043;--paper-deep-orange-500:#ff5722;--paper-deep-orange-600:#f4511e;--paper-deep-orange-700:#e64a19;--paper-deep-orange-800:#d84315;--paper-deep-orange-900:#bf360c;--paper-deep-orange-a100:#ff9e80;--paper-deep-orange-a200:#ff6e40;--paper-deep-orange-a400:#ff3d00;--paper-deep-orange-a700:#dd2c00;--paper-brown-50:#efebe9;--paper-brown-100:#d7ccc8;--paper-brown-200:#bcaaa4;--paper-brown-300:#a1887f;--paper-brown-400:#8d6e63;--paper-brown-500:#795548;--paper-brown-600:#6d4c41;--paper-brown-700:#5d4037;--paper-brown-800:#4e342e;--paper-brown-900:#3e2723;--paper-grey-50:#fafafa;--paper-grey-100:#f5f5f5;--paper-grey-200:#eeeeee;--paper-grey-300:#e0e0e0;--paper-grey-400:#bdbdbd;--paper-grey-500:#9e9e9e;--paper-grey-600:#757575;--paper-grey-700:#616161;--paper-grey-800:#424242;--paper-grey-900:#212121;--paper-blue-grey-50:#eceff1;--paper-blue-grey-100:#cfd8dc;--paper-blue-grey-200:#b0bec5;--paper-blue-grey-300:#90a4ae;--paper-blue-grey-400:#78909c;--paper-blue-grey-500:#607d8b;--paper-blue-grey-600:#546e7a;--paper-blue-grey-700:#455a64;--paper-blue-grey-800:#37474f;--paper-blue-grey-900:#263238;--dark-divider-opacity:0.12;--dark-disabled-opacity:0.38;--dark-secondary-opacity:0.54;--dark-primary-opacity:0.87;--light-divider-opacity:0.12;--light-disabled-opacity:0.3;--light-secondary-opacity:0.7;--light-primary-opacity:1.0}</style> </custom-style>");

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

__webpack_require__(18);

/**
 * The `iron-iconset-svg` element allows users to define their own icon sets
 * that contain svg icons. The svg icon elements should be children of the
 * `iron-iconset-svg` element. Multiple icons should be given distinct id's.
 *
 * Using svg elements to create icons has a few advantages over traditional
 * bitmap graphics like jpg or png. Icons that use svg are vector based so
 * they are resolution independent and should look good on any device. They
 * are stylable via css. Icons can be themed, colorized, and even animated.
 *
 * Example:
 *
 *     <iron-iconset-svg name="my-svg-icons" size="24">
 *       <svg>
 *         <defs>
 *           <g id="shape">
 *             <rect x="12" y="0" width="12" height="24" />
 *             <circle cx="12" cy="12" r="12" />
 *           </g>
 *         </defs>
 *       </svg>
 *     </iron-iconset-svg>
 *
 * This will automatically register the icon set "my-svg-icons" to the iconset
 * database.  To use these icons from within another element, make a
 * `iron-iconset` element and call the `byId` method
 * to retrieve a given iconset. To apply a particular icon inside an
 * element use the `applyIcon` method. For example:
 *
 *     iconset.applyIcon(iconNode, 'car');
 *
 * @element iron-iconset-svg
 * @demo demo/index.html
 * @implements {Polymer.Iconset}
 */
Polymer({
  is: 'iron-iconset-svg',

  properties: {

    /**
     * The name of the iconset.
     */
    name: {
      type: String,
      observer: '_nameChanged'
    },

    /**
     * The size of an individual icon. Note that icons must be square.
     */
    size: {
      type: Number,
      value: 24
    },

    /**
     * Set to true to enable mirroring of icons where specified when they are
     * stamped. Icons that should be mirrored should be decorated with a
     * `mirror-in-rtl` attribute.
     *
     * NOTE: For performance reasons, direction will be resolved once per
     * document per iconset, so moving icons in and out of RTL subtrees will
     * not cause their mirrored state to change.
     */
    rtlMirroring: {
      type: Boolean,
      value: false
    },

    /**
     * Set to true to measure RTL based on the dir attribute on the body or
     * html elements (measured on document.body or document.documentElement as
     * available).
     */
    useGlobalRtlAttribute: {
      type: Boolean,
      value: false
    }
  },

  created: function created() {
    this._meta = new Polymer.IronMeta({ type: 'iconset', key: null, value: null });
  },

  attached: function attached() {
    this.style.display = 'none';
  },

  /**
   * Construct an array of all icon names in this iconset.
   *
   * @return {!Array} Array of icon names.
   */
  getIconNames: function getIconNames() {
    this._icons = this._createIconMap();
    return Object.keys(this._icons).map(function (n) {
      return this.name + ':' + n;
    }, this);
  },

  /**
   * Applies an icon to the given element.
   *
   * An svg icon is prepended to the element's shadowRoot if it exists,
   * otherwise to the element itself.
   *
   * If RTL mirroring is enabled, and the icon is marked to be mirrored in
   * RTL, the element will be tested (once and only once ever for each
   * iconset) to determine the direction of the subtree the element is in.
   * This direction will apply to all future icon applications, although only
   * icons marked to be mirrored will be affected.
   *
   * @method applyIcon
   * @param {Element} element Element to which the icon is applied.
   * @param {string} iconName Name of the icon to apply.
   * @return {?Element} The svg element which renders the icon.
   */
  applyIcon: function applyIcon(element, iconName) {
    // Remove old svg element
    this.removeIcon(element);
    // install new svg element
    var svg = this._cloneIcon(iconName, this.rtlMirroring && this._targetIsRTL(element));
    if (svg) {
      // insert svg element into shadow root, if it exists
      var pde = Polymer.dom(element.root || element);
      pde.insertBefore(svg, pde.childNodes[0]);
      return element._svgIcon = svg;
    }
    return null;
  },

  /**
   * Remove an icon from the given element by undoing the changes effected
   * by `applyIcon`.
   *
   * @param {Element} element The element from which the icon is removed.
   */
  removeIcon: function removeIcon(element) {
    // Remove old svg element
    if (element._svgIcon) {
      Polymer.dom(element.root || element).removeChild(element._svgIcon);
      element._svgIcon = null;
    }
  },

  /**
   * Measures and memoizes the direction of the element. Note that this
   * measurement is only done once and the result is memoized for future
   * invocations.
   */
  _targetIsRTL: function _targetIsRTL(target) {
    if (this.__targetIsRTL == null) {
      if (this.useGlobalRtlAttribute) {
        var globalElement = document.body && document.body.hasAttribute('dir') ? document.body : document.documentElement;

        this.__targetIsRTL = globalElement.getAttribute('dir') === 'rtl';
      } else {
        if (target && target.nodeType !== Node.ELEMENT_NODE) {
          target = target.host;
        }

        this.__targetIsRTL = target && window.getComputedStyle(target)['direction'] === 'rtl';
      }
    }

    return this.__targetIsRTL;
  },

  /**
   *
   * When name is changed, register iconset metadata
   *
   */
  _nameChanged: function _nameChanged() {
    this._meta.value = null;
    this._meta.key = this.name;
    this._meta.value = this;

    this.async(function () {
      this.fire('iron-iconset-added', this, { node: window });
    });
  },

  /**
   * Create a map of child SVG elements by id.
   *
   * @return {!Object} Map of id's to SVG elements.
   */
  _createIconMap: function _createIconMap() {
    // Objects chained to Object.prototype (`{}`) have members. Specifically,
    // on FF there is a `watch` method that confuses the icon map, so we
    // need to use a null-based object here.
    var icons = Object.create(null);
    Polymer.dom(this).querySelectorAll('[id]').forEach(function (icon) {
      icons[icon.id] = icon;
    });
    return icons;
  },

  /**
   * Produce installable clone of the SVG element matching `id` in this
   * iconset, or `undefined` if there is no matching element.
   *
   * @return {Element} Returns an installable clone of the SVG element
   * matching `id`.
   */
  _cloneIcon: function _cloneIcon(id, mirrorAllowed) {
    // create the icon map on-demand, since the iconset itself has no discrete
    // signal to know when it's children are fully parsed
    this._icons = this._icons || this._createIconMap();
    return this._prepareSvgClone(this._icons[id], this.size, mirrorAllowed);
  },

  /**
   * @param {Element} sourceSvg
   * @param {number} size
   * @param {Boolean} mirrorAllowed
   * @return {Element}
   */
  _prepareSvgClone: function _prepareSvgClone(sourceSvg, size, mirrorAllowed) {
    if (sourceSvg) {
      var content = sourceSvg.cloneNode(true),
          svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg'),
          viewBox = content.getAttribute('viewBox') || '0 0 ' + size + ' ' + size,
          cssText = 'pointer-events: none; display: block; width: 100%; height: 100%;';

      if (mirrorAllowed && content.hasAttribute('mirror-in-rtl')) {
        cssText += '-webkit-transform:scale(-1,1);transform:scale(-1,1);';
      }

      svg.setAttribute('viewBox', viewBox);
      svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');
      svg.setAttribute('focusable', 'false');
      // TODO(dfreedm): `pointer-events: none` works around https://crbug.com/370136
      // TODO(sjmiles): inline style may not be ideal, but avoids requiring a shadow-root
      svg.style.cssText = cssText;
      svg.appendChild(content).removeAttribute('id');
      return svg;
    }
    return null;
  }

});

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

__webpack_require__(6);

__webpack_require__(44);

__webpack_require__(64);

__webpack_require__(66);

__webpack_require__(68);

__webpack_require__(69);

__webpack_require__(73);

__webpack_require__(74);

__webpack_require__(78);

__webpack_require__(79);

__webpack_require__(81);

__webpack_require__(31);

__webpack_require__(85);

var RegisterHtmlTemplate = __webpack_require__(2);

RegisterHtmlTemplate.register("<dom-module id=my-app> <template> <style>:host{--app-primary-color:#3D2814;--app-secondary-color:#FF3C3C;display:block}app-drawer-layout:not([narrow]) [drawer-toggle]{display:none}app-header{color:#fff;background-color:var(--app-primary-color)}app-header paper-icon-button{--paper-icon-button-ink-color:white}.drawer-list{margin:0 20px}.drawer-list a{display:block;padding:0 16px;text-decoration:none;color:var(--app-secondary-color);line-height:40px}.drawer-list a.iron-selected{color:#000;font-weight:700}</style> <app-location route={{route}} url-space-regex=^[[rootPath]]></app-location> <app-route route={{route}} pattern=[[rootPath]]:page data={{routeData}} tail={{subroute}}></app-route> <app-drawer-layout fullbleed=\"\"> <app-drawer id=drawer slot=drawer> <app-toolbar>Menu</app-toolbar> <iron-selector selected=[[page]] attr-for-selected=name class=drawer-list role=navigation> <a name=view1 href$=[[rootPath]]view1>Suche</a> <a name=view2 href$=[[rootPath]]view2>Verlag</a> <a name=view3 href$=[[rootPath]]view3>Author</a> </iron-selector> </app-drawer> <app-header-layout has-scrolling-region=\"\"> <app-header slot=header condenses=\"\" reveals=\"\" effects=waterfall> <app-toolbar> <paper-icon-button icon=my-icons:menu drawer-toggle=\"\"></paper-icon-button> <div main-title=\"\">Luding.org</div> </app-toolbar> </app-header> <iron-pages selected=[[page]] attr-for-selected=name fallback-selection=view404 role=main> <my-view1 name=view1></my-view1> <my-view2 name=view2></my-view2> <my-view3 name=view3></my-view3> <my-view404 name=view404></my-view404> </iron-pages> </app-header-layout> </app-drawer-layout> </template> </dom-module>");

var MyApp = function (_Polymer$Element) {
  _inherits(MyApp, _Polymer$Element);

  _createClass(MyApp, null, [{
    key: 'is',
    get: function get() {
      return 'my-app';
    }
  }, {
    key: 'properties',
    get: function get() {
      return {
        page: {
          type: String,
          reflectToAttribute: true,
          observer: '_pageChanged'
        },
        routeData: Object,
        subroute: String,
        rootPath: {
          type: String,
          value: '/'
        },
        lazyPages: {
          type: Object,
          value: {
            view1: function view1() {
              __webpack_require__.e/* import() */(0).then(__webpack_require__.bind(null, 86));
            },
            view2: function view2() {
              __webpack_require__.e/* import() */(2).then(__webpack_require__.bind(null, 87));
            },
            view3: function view3() {
              __webpack_require__.e/* import() */(1).then(__webpack_require__.bind(null, 88));
            },
            view404: function view404() {
              __webpack_require__.e/* import() */(3).then(__webpack_require__.bind(null, 89));
            }
          }
        }
      };
    }
  }, {
    key: 'observers',
    get: function get() {
      return ['_routePageChanged(routeData.page)'];
    }
  }]);

  function MyApp() {
    _classCallCheck(this, MyApp);

    return _possibleConstructorReturn(this, (MyApp.__proto__ || Object.getPrototypeOf(MyApp)).call(this));
  }

  _createClass(MyApp, [{
    key: '_routePageChanged',
    value: function _routePageChanged(page) {
      // Polymer 2.0 will call with `undefined` on initialization.
      // Ignore until we are properly called with a string.
      if (page === undefined) {
        return;
      }

      // If no page was found in the route data, page will be an empty string.
      // Deault to 'view1' in that case.
      this.page = page || 'view1';

      // Close a non-persistent drawer when the page & route are changed.
      if (!this.$.drawer.persistent) {
        this.$.drawer.close();
      }
    }
  }, {
    key: '_pageChanged',
    value: function _pageChanged(page) {
      if (this.lazyPages[page]) {
        this.lazyPages[page]();
      } else {
        this._showPage404();
      }
    }
  }, {
    key: '_showPage404',
    value: function _showPage404() {
      this.page = 'view404';
    }
  }]);

  return MyApp;
}(Polymer.Element);

window.customElements.define(MyApp.is, MyApp);

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

__webpack_require__(1);

__webpack_require__(7);

(function () {
  'use strict';

  var modules = {};
  var lcModules = {};
  function findModule(id) {
    return modules[id] || lcModules[id.toLowerCase()];
  }

  function styleOutsideTemplateCheck(inst) {
    if (inst.querySelector('style')) {
      console.warn('dom-module %s has style outside template', inst.id);
    }
  }

  /**
   * The `dom-module` element registers the dom it contains to the name given
   * by the module's id attribute. It provides a unified database of dom
   * accessible via its static `import` API.
   *
   * A key use case of `dom-module` is for providing custom element `<template>`s
   * via HTML imports that are parsed by the native HTML parser, that can be
   * relocated during a bundling pass and still looked up by `id`.
   *
   * Example:
   *
   *     <dom-module id="foo">
   *       <img src="stuff.png">
   *     </dom-module>
   *
   * Then in code in some other location that cannot access the dom-module above
   *
   *     let img = document.createElement('dom-module').import('foo', 'img');
   *
   * @customElement
   * @extends HTMLElement
   * @memberof Polymer
   * @summary Custom element that provides a registry of relocatable DOM content
   *   by `id` that is agnostic to bundling.
   * @unrestricted
   */

  var DomModule = function (_HTMLElement) {
    _inherits(DomModule, _HTMLElement);

    function DomModule() {
      _classCallCheck(this, DomModule);

      return _possibleConstructorReturn(this, (DomModule.__proto__ || Object.getPrototypeOf(DomModule)).apply(this, arguments));
    }

    _createClass(DomModule, [{
      key: 'attributeChangedCallback',
      value: function attributeChangedCallback(name, old, value) {
        if (old !== value) {
          this.register();
        }
      }

      /**
       * The absolute URL of the original location of this `dom-module`.
       *
       * This value will differ from this element's `ownerDocument` in the
       * following ways:
       * - Takes into account any `assetpath` attribute added during bundling
       *   to indicate the original location relative to the bundled location
       * - Uses the HTMLImports polyfill's `importForElement` API to ensure
       *   the path is relative to the import document's location since
       *   `ownerDocument` is not currently polyfilled
       */

    }, {
      key: 'register',


      /**
       * Registers the dom-module at a given id. This method should only be called
       * when a dom-module is imperatively created. For
       * example, `document.createElement('dom-module').register('foo')`.
       * @param {string=} id The id at which to register the dom-module.
       */
      value: function register(id) {
        id = id || this.id;
        if (id) {
          this.id = id;
          // store id separate from lowercased id so that
          // in all cases mixedCase id will stored distinctly
          // and lowercase version is a fallback
          modules[id] = this;
          lcModules[id.toLowerCase()] = this;
          styleOutsideTemplateCheck(this);
        }
      }
    }, {
      key: 'assetpath',
      get: function get() {
        // Don't override existing assetpath.
        if (!this.__assetpath) {
          // note: assetpath set via an attribute must be relative to this
          // element's location; accomodate polyfilled HTMLImports
          var owner = window.HTMLImports && HTMLImports.importForElement ? HTMLImports.importForElement(this) || document : this.ownerDocument;
          var url = Polymer.ResolveUrl.resolveUrl(this.getAttribute('assetpath') || '', owner.baseURI);
          this.__assetpath = Polymer.ResolveUrl.pathFromUrl(url);
        }
        return this.__assetpath;
      }
    }], [{
      key: 'import',


      /**
       * Retrieves the element specified by the css `selector` in the module
       * registered by `id`. For example, this.import('foo', 'img');
       * @param {string} id The id of the dom-module in which to search.
       * @param {string=} selector The css selector by which to find the element.
       * @return {Element} Returns the element which matches `selector` in the
       * module registered at the specified `id`.
       */
      value: function _import(id, selector) {
        if (id) {
          var m = findModule(id);
          if (m && selector) {
            return m.querySelector(selector);
          }
          return m;
        }
        return null;
      }
    }, {
      key: 'observedAttributes',
      get: function get() {
        return ['id'];
      }
    }]);

    return DomModule;
  }(HTMLElement);

  DomModule.prototype['modules'] = modules;

  customElements.define('dom-module', DomModule);

  // export
  Polymer.DomModule = DomModule;
})();

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(1);

(function () {
  'use strict';

  /**
   * Module with utilities for manipulating structured data path strings.
   *
   * @namespace
   * @memberof Polymer
   * @summary Module with utilities for manipulating structured data path strings.
   */

  var Path = {

    /**
     * Returns true if the given string is a structured data path (has dots).
     *
     * Example:
     *
     * ```
     * Polymer.Path.isPath('foo.bar.baz') // true
     * Polymer.Path.isPath('foo')         // false
     * ```
     *
     * @memberof Polymer.Path
     * @param {string} path Path string
     * @return {boolean} True if the string contained one or more dots
     */
    isPath: function isPath(path) {
      return path.indexOf('.') >= 0;
    },

    /**
     * Returns the root property name for the given path.
     *
     * Example:
     *
     * ```
     * Polymer.Path.root('foo.bar.baz') // 'foo'
     * Polymer.Path.root('foo')         // 'foo'
     * ```
     *
     * @memberof Polymer.Path
     * @param {string} path Path string
     * @return {string} Root property name
     */
    root: function root(path) {
      var dotIndex = path.indexOf('.');
      if (dotIndex === -1) {
        return path;
      }
      return path.slice(0, dotIndex);
    },

    /**
     * Given `base` is `foo.bar`, `foo` is an ancestor, `foo.bar` is not
     * Returns true if the given path is an ancestor of the base path.
     *
     * Example:
     *
     * ```
     * Polymer.Path.isAncestor('foo.bar', 'foo')         // true
     * Polymer.Path.isAncestor('foo.bar', 'foo.bar')     // false
     * Polymer.Path.isAncestor('foo.bar', 'foo.bar.baz') // false
     * ```
     *
     * @memberof Polymer.Path
     * @param {string} base Path string to test against.
     * @param {string} path Path string to test.
     * @return {boolean} True if `path` is an ancestor of `base`.
     */
    isAncestor: function isAncestor(base, path) {
      //     base.startsWith(path + '.');
      return base.indexOf(path + '.') === 0;
    },

    /**
     * Given `base` is `foo.bar`, `foo.bar.baz` is an descendant
     *
     * Example:
     *
     * ```
     * Polymer.Path.isDescendant('foo.bar', 'foo.bar.baz') // true
     * Polymer.Path.isDescendant('foo.bar', 'foo.bar')     // false
     * Polymer.Path.isDescendant('foo.bar', 'foo')         // false
     * ```
     *
     * @memberof Polymer.Path
     * @param {string} base Path string to test against.
     * @param {string} path Path string to test.
     * @return {boolean} True if `path` is a descendant of `base`.
     */
    isDescendant: function isDescendant(base, path) {
      //     path.startsWith(base + '.');
      return path.indexOf(base + '.') === 0;
    },

    /**
     * Replaces a previous base path with a new base path, preserving the
     * remainder of the path.
     *
     * User must ensure `path` has a prefix of `base`.
     *
     * Example:
     *
     * ```
     * Polymer.Path.translate('foo.bar', 'zot' 'foo.bar.baz') // 'zot.baz'
     * ```
     *
     * @memberof Polymer.Path
     * @param {string} base Current base string to remove
     * @param {string} newBase New base string to replace with
     * @param {string} path Path to translate
     * @return {string} Translated string
     */
    translate: function translate(base, newBase, path) {
      return newBase + path.slice(base.length);
    },

    /**
     * @param {string} base Path string to test against
     * @param {string} path Path string to test
     * @return {boolean} True if `path` is equal to `base`
     * @this {Path}
     */
    matches: function matches(base, path) {
      return base === path || this.isAncestor(base, path) || this.isDescendant(base, path);
    },

    /**
     * Converts array-based paths to flattened path.  String-based paths
     * are returned as-is.
     *
     * Example:
     *
     * ```
     * Polymer.Path.normalize(['foo.bar', 0, 'baz'])  // 'foo.bar.0.baz'
     * Polymer.Path.normalize('foo.bar.0.baz')        // 'foo.bar.0.baz'
     * ```
     *
     * @memberof Polymer.Path
     * @param {string | !Array<string|number>} path Input path
     * @return {string} Flattened path
     */
    normalize: function normalize(path) {
      if (Array.isArray(path)) {
        var parts = [];
        for (var i = 0; i < path.length; i++) {
          var args = path[i].toString().split('.');
          for (var j = 0; j < args.length; j++) {
            parts.push(args[j]);
          }
        }
        return parts.join('.');
      } else {
        return path;
      }
    },

    /**
     * Splits a path into an array of property names. Accepts either arrays
     * of path parts or strings.
     *
     * Example:
     *
     * ```
     * Polymer.Path.split(['foo.bar', 0, 'baz'])  // ['foo', 'bar', '0', 'baz']
     * Polymer.Path.split('foo.bar.0.baz')        // ['foo', 'bar', '0', 'baz']
     * ```
     *
     * @memberof Polymer.Path
     * @param {string | !Array<string|number>} path Input path
     * @return {!Array<string>} Array of path parts
     * @this {Path}
     * @suppress {checkTypes}
     */
    split: function split(path) {
      if (Array.isArray(path)) {
        return this.normalize(path).split('.');
      }
      return path.toString().split('.');
    },

    /**
     * Reads a value from a path.  If any sub-property in the path is `undefined`,
     * this method returns `undefined` (will never throw.
     *
     * @memberof Polymer.Path
     * @param {Object} root Object from which to dereference path from
     * @param {string | !Array<string|number>} path Path to read
     * @param {Object=} info If an object is provided to `info`, the normalized
     *  (flattened) path will be set to `info.path`.
     * @return {*} Value at path, or `undefined` if the path could not be
     *  fully dereferenced.
     * @this {Path}
     */
    get: function get(root, path, info) {
      var prop = root;
      var parts = this.split(path);
      // Loop over path parts[0..n-1] and dereference
      for (var i = 0; i < parts.length; i++) {
        if (!prop) {
          return;
        }
        var part = parts[i];
        prop = prop[part];
      }
      if (info) {
        info.path = parts.join('.');
      }
      return prop;
    },

    /**
     * Sets a value to a path.  If any sub-property in the path is `undefined`,
     * this method will no-op.
     *
     * @memberof Polymer.Path
     * @param {Object} root Object from which to dereference path from
     * @param {string | !Array<string|number>} path Path to set
     * @param {*} value Value to set to path
     * @return {string | undefined} The normalized version of the input path
     * @this {Path}
     */
    set: function set(root, path, value) {
      var prop = root;
      var parts = this.split(path);
      var last = parts[parts.length - 1];
      if (parts.length > 1) {
        // Loop over path parts[0..n-2] and dereference
        for (var i = 0; i < parts.length - 1; i++) {
          var part = parts[i];
          prop = prop[part];
          if (!prop) {
            return;
          }
        }
        // Set value to object at end of path
        prop[last] = value;
      } else {
        // Simple property set
        prop[path] = value;
      }
      return parts.join('.');
    }

  };

  /**
   * Returns true if the given string is a structured data path (has dots).
   *
   * This function is deprecated.  Use `Polymer.Path.isPath` instead.
   *
   * Example:
   *
   * ```
   * Polymer.Path.isDeep('foo.bar.baz') // true
   * Polymer.Path.isDeep('foo')         // false
   * ```
   *
   * @deprecated
   * @memberof Polymer.Path
   * @param {string} path Path string
   * @return {boolean} True if the string contained one or more dots
   */
  Path.isDeep = Path.isPath;

  Polymer.Path = Path;
})();

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

__webpack_require__(1);

__webpack_require__(3);

__webpack_require__(10);

__webpack_require__(8);

(function () {

  'use strict';

  var caseMap = Polymer.CaseMap;

  var microtask = Polymer.Async.microTask;

  // Save map of native properties; this forms a blacklist or properties
  // that won't have their values "saved" by `saveAccessorValue`, since
  // reading from an HTMLElement accessor from the context of a prototype throws
  var nativeProperties = {};
  var proto = HTMLElement.prototype;
  while (proto) {
    var props = Object.getOwnPropertyNames(proto);
    for (var i = 0; i < props.length; i++) {
      nativeProperties[props[i]] = true;
    }
    proto = Object.getPrototypeOf(proto);
  }

  /**
   * Used to save the value of a property that will be overridden with
   * an accessor. If the `model` is a prototype, the values will be saved
   * in `__dataProto`, and it's up to the user (or downstream mixin) to
   * decide how/when to set these values back into the accessors.
   * If `model` is already an instance (it has a `__data` property), then
   * the value will be set as a pending property, meaning the user should
   * call `_invalidateProperties` or `_flushProperties` to take effect
   *
   * @param {Object} model Prototype or instance
   * @param {string} property Name of property
   * @private
   */
  function saveAccessorValue(model, property) {
    // Don't read/store value for any native properties since they could throw
    if (!nativeProperties[property]) {
      var value = model[property];
      if (value !== undefined) {
        if (model.__data) {
          // Adding accessor to instance; update the property
          // It is the user's responsibility to call _flushProperties
          model._setPendingProperty(property, value);
        } else {
          // Adding accessor to proto; save proto's value for instance-time use
          if (!model.__dataProto) {
            model.__dataProto = {};
          } else if (!model.hasOwnProperty(JSCompiler_renameProperty('__dataProto', model))) {
            model.__dataProto = Object.create(model.__dataProto);
          }
          model.__dataProto[property] = value;
        }
      }
    }
  }

  /**
   * Element class mixin that provides basic meta-programming for creating one
   * or more property accessors (getter/setter pair) that enqueue an async
   * (batched) `_propertiesChanged` callback.
   *
   * For basic usage of this mixin, simply declare attributes to observe via
   * the standard `static get observedAttributes()`, implement `_propertiesChanged`
   * on the class, and then call `MyClass.createPropertiesForAttributes()` once
   * on the class to generate property accessors for each observed attribute
   * prior to instancing.  Last, call `this._flushProperties()` once to enable
   * the accessors.
   *
   * Any `observedAttributes` will automatically be
   * deserialized via `attributeChangedCallback` and set to the associated
   * property using `dash-case`-to-`camelCase` convention.
   *
   * @mixinFunction
   * @polymer
   * @memberof Polymer
   * @summary Element class mixin for reacting to property changes from
   *   generated property accessors.
   */
  Polymer.PropertyAccessors = Polymer.dedupingMixin(function (superClass) {

    /**
     * @polymer
     * @mixinClass
     * @implements {Polymer_PropertyAccessors}
     * @extends HTMLElement
     * @unrestricted
     */
    var PropertyAccessors = function (_superClass) {
      _inherits(PropertyAccessors, _superClass);

      _createClass(PropertyAccessors, null, [{
        key: 'createPropertiesForAttributes',


        /**
         * Generates property accessors for all attributes in the standard
         * static `observedAttributes` array.
         *
         * Attribute names are mapped to property names using the `dash-case` to
         * `camelCase` convention
         *
         */
        value: function createPropertiesForAttributes() {
          var a$ = this.observedAttributes;
          for (var _i = 0; _i < a$.length; _i++) {
            this.prototype._createPropertyAccessor(caseMap.dashToCamelCase(a$[_i]));
          }
        }
      }]);

      function PropertyAccessors() {
        _classCallCheck(this, PropertyAccessors);

        /** @type {boolean} */
        var _this = _possibleConstructorReturn(this, (PropertyAccessors.__proto__ || Object.getPrototypeOf(PropertyAccessors)).call(this));

        _this.__serializing;
        /** @type {number} */
        _this.__dataCounter;
        /** @type {boolean} */
        _this.__dataEnabled;
        /** @type {boolean} */
        _this.__dataReady;
        /** @type {boolean} */
        _this.__dataInvalid;
        /** @type {!Object} */
        _this.__data;
        /** @type {Object} */
        _this.__dataPending;
        /** @type {Object} */
        _this.__dataOld;
        /** @type {Object} */
        _this.__dataProto;
        /** @type {Object} */
        _this.__dataHasAccessor;
        /** @type {Object} */
        _this.__dataInstanceProps;
        _this._initializeProperties();
        return _this;
      }

      /**
       * Implements native Custom Elements `attributeChangedCallback` to
       * set an attribute value to a property via `_attributeToProperty`.
       *
       * @param {string} name Name of attribute that changed
       * @param {?string} old Old attribute value
       * @param {?string} value New attribute value
       */


      _createClass(PropertyAccessors, [{
        key: 'attributeChangedCallback',
        value: function attributeChangedCallback(name, old, value) {
          if (old !== value) {
            this._attributeToProperty(name, value);
          }
        }

        /**
         * Initializes the local storage for property accessors.
         *
         * Provided as an override point for performing any setup work prior
         * to initializing the property accessor system.
         *
         * @protected
         */

      }, {
        key: '_initializeProperties',
        value: function _initializeProperties() {
          this.__serializing = false;
          this.__dataCounter = 0;
          this.__dataEnabled = false;
          this.__dataReady = false;
          this.__dataInvalid = false;
          this.__data = {};
          this.__dataPending = null;
          this.__dataOld = null;
          if (this.__dataProto) {
            this._initializeProtoProperties(this.__dataProto);
            this.__dataProto = null;
          }
          // Capture instance properties; these will be set into accessors
          // during first flush. Don't set them here, since we want
          // these to overwrite defaults/constructor assignments
          for (var p in this.__dataHasAccessor) {
            if (this.hasOwnProperty(p)) {
              this.__dataInstanceProps = this.__dataInstanceProps || {};
              this.__dataInstanceProps[p] = this[p];
              delete this[p];
            }
          }
        }

        /**
         * Called at instance time with bag of properties that were overwritten
         * by accessors on the prototype when accessors were created.
         *
         * The default implementation sets these properties back into the
         * setter at instance time.  This method is provided as an override
         * point for customizing or providing more efficient initialization.
         *
         * @param {Object} props Bag of property values that were overwritten
         *   when creating property accessors.
         * @protected
         */

      }, {
        key: '_initializeProtoProperties',
        value: function _initializeProtoProperties(props) {
          for (var p in props) {
            this._setProperty(p, props[p]);
          }
        }

        /**
         * Called at ready time with bag of instance properties that overwrote
         * accessors when the element upgraded.
         *
         * The default implementation sets these properties back into the
         * setter at ready time.  This method is provided as an override
         * point for customizing or providing more efficient initialization.
         *
         * @param {Object} props Bag of property values that were overwritten
         *   when creating property accessors.
         * @protected
         */

      }, {
        key: '_initializeInstanceProperties',
        value: function _initializeInstanceProperties(props) {
          Object.assign(this, props);
        }

        /**
         * Ensures the element has the given attribute. If it does not,
         * assigns the given value to the attribute.
         *
         *
         * @param {string} attribute Name of attribute to ensure is set.
         * @param {string} value of the attribute.
         */

      }, {
        key: '_ensureAttribute',
        value: function _ensureAttribute(attribute, value) {
          if (!this.hasAttribute(attribute)) {
            this._valueToNodeAttribute(this, value, attribute);
          }
        }

        /**
         * Deserializes an attribute to its associated property.
         *
         * This method calls the `_deserializeValue` method to convert the string to
         * a typed value.
         *
         * @param {string} attribute Name of attribute to deserialize.
         * @param {?string} value of the attribute.
         * @param {*=} type type to deserialize to.
         */

      }, {
        key: '_attributeToProperty',
        value: function _attributeToProperty(attribute, value, type) {
          // Don't deserialize back to property if currently reflecting
          if (!this.__serializing) {
            var property = caseMap.dashToCamelCase(attribute);
            this[property] = this._deserializeValue(value, type);
          }
        }

        /**
         * Serializes a property to its associated attribute.
         *
         * @param {string} property Property name to reflect.
         * @param {string=} attribute Attribute name to reflect.
         * @param {*=} value Property value to refect.
         */

      }, {
        key: '_propertyToAttribute',
        value: function _propertyToAttribute(property, attribute, value) {
          this.__serializing = true;
          value = arguments.length < 3 ? this[property] : value;
          this._valueToNodeAttribute(this, value, attribute || caseMap.camelToDashCase(property));
          this.__serializing = false;
        }

        /**
         * Sets a typed value to an HTML attribute on a node.
         *
         * This method calls the `_serializeValue` method to convert the typed
         * value to a string.  If the `_serializeValue` method returns `undefined`,
         * the attribute will be removed (this is the default for boolean
         * type `false`).
         *
         * @param {Element} node Element to set attribute to.
         * @param {*} value Value to serialize.
         * @param {string} attribute Attribute name to serialize to.
         */

      }, {
        key: '_valueToNodeAttribute',
        value: function _valueToNodeAttribute(node, value, attribute) {
          var str = this._serializeValue(value);
          if (str === undefined) {
            node.removeAttribute(attribute);
          } else {
            node.setAttribute(attribute, str);
          }
        }

        /**
         * Converts a typed JavaScript value to a string.
         *
         * This method is called by Polymer when setting JS property values to
         * HTML attributes.  Users may override this method on Polymer element
         * prototypes to provide serialization for custom types.
         *
         * @param {*} value Property value to serialize.
         * @return {string | undefined} String serialized from the provided property value.
         */

      }, {
        key: '_serializeValue',
        value: function _serializeValue(value) {
          /* eslint-disable no-fallthrough */
          switch (typeof value === 'undefined' ? 'undefined' : _typeof(value)) {
            case 'boolean':
              return value ? '' : undefined;

            case 'object':
              if (value instanceof Date) {
                return value.toString();
              } else if (value) {
                try {
                  return JSON.stringify(value);
                } catch (x) {
                  return '';
                }
              }

            default:
              return value != null ? value.toString() : undefined;
          }
        }

        /**
         * Converts a string to a typed JavaScript value.
         *
         * This method is called by Polymer when reading HTML attribute values to
         * JS properties.  Users may override this method on Polymer element
         * prototypes to provide deserialization for custom `type`s.  Note,
         * the `type` argument is the value of the `type` field provided in the
         * `properties` configuration object for a given property, and is
         * by convention the constructor for the type to deserialize.
         *
         * Note: The return value of `undefined` is used as a sentinel value to
         * indicate the attribute should be removed.
         *
         * @param {?string} value Attribute value to deserialize.
         * @param {*=} type Type to deserialize the string to.
         * @return {*} Typed value deserialized from the provided string.
         */

      }, {
        key: '_deserializeValue',
        value: function _deserializeValue(value, type) {
          /**
           * @type {*}
           */
          var outValue = void 0;
          switch (type) {
            case Number:
              outValue = Number(value);
              break;

            case Boolean:
              outValue = value !== null;
              break;

            case Object:
              try {
                outValue = JSON.parse( /** @type string */value);
              } catch (x) {
                // allow non-JSON literals like Strings and Numbers
              }
              break;

            case Array:
              try {
                outValue = JSON.parse( /** @type string */value);
              } catch (x) {
                outValue = null;
                console.warn('Polymer::Attributes: couldn\'t decode Array as JSON: ' + value);
              }
              break;

            case Date:
              outValue = new Date(value);
              break;

            case String:
            default:
              outValue = value;
              break;
          }

          return outValue;
        }
        /* eslint-enable no-fallthrough */

        /**
         * Creates a setter/getter pair for the named property with its own
         * local storage.  The getter returns the value in the local storage,
         * and the setter calls `_setProperty`, which updates the local storage
         * for the property and enqueues a `_propertiesChanged` callback.
         *
         * This method may be called on a prototype or an instance.  Calling
         * this method may overwrite a property value that already exists on
         * the prototype/instance by creating the accessor.  When calling on
         * a prototype, any overwritten values are saved in `__dataProto`,
         * and it is up to the subclasser to decide how/when to set those
         * properties back into the accessor.  When calling on an instance,
         * the overwritten value is set via `_setPendingProperty`, and the
         * user should call `_invalidateProperties` or `_flushProperties`
         * for the values to take effect.
         *
         * @param {string} property Name of the property
         * @param {boolean=} readOnly When true, no setter is created; the
         *   protected `_setProperty` function must be used to set the property
         * @protected
         */

      }, {
        key: '_createPropertyAccessor',
        value: function _createPropertyAccessor(property, readOnly) {
          if (!this.hasOwnProperty('__dataHasAccessor')) {
            this.__dataHasAccessor = Object.assign({}, this.__dataHasAccessor);
          }
          if (!this.__dataHasAccessor[property]) {
            this.__dataHasAccessor[property] = true;
            saveAccessorValue(this, property);
            Object.defineProperty(this, property, {
              /* eslint-disable valid-jsdoc */
              /** @this {PropertyAccessors} */
              get: function get() {
                return this.__data[property];
              },
              /** @this {PropertyAccessors} */
              set: readOnly ? function () {} : function (value) {
                this._setProperty(property, value);
              }
              /* eslint-enable */
            });
          }
        }

        /**
         * Returns true if this library created an accessor for the given property.
         *
         * @param {string} property Property name
         * @return {boolean} True if an accessor was created
         */

      }, {
        key: '_hasAccessor',
        value: function _hasAccessor(property) {
          return this.__dataHasAccessor && this.__dataHasAccessor[property];
        }

        /**
         * Updates the local storage for a property (via `_setPendingProperty`)
         * and enqueues a `_proeprtiesChanged` callback.
         *
         * @param {string} property Name of the property
         * @param {*} value Value to set
         * @protected
         */

      }, {
        key: '_setProperty',
        value: function _setProperty(property, value) {
          if (this._setPendingProperty(property, value)) {
            this._invalidateProperties();
          }
        }

        /**
         * Updates the local storage for a property, records the previous value,
         * and adds it to the set of "pending changes" that will be passed to the
         * `_propertiesChanged` callback.  This method does not enqueue the
         * `_propertiesChanged` callback.
         *
         * @param {string} property Name of the property
         * @param {*} value Value to set
         * @return {boolean} Returns true if the property changed
         * @protected
         */

      }, {
        key: '_setPendingProperty',
        value: function _setPendingProperty(property, value) {
          var old = this.__data[property];
          var changed = this._shouldPropertyChange(property, value, old);
          if (changed) {
            if (!this.__dataPending) {
              this.__dataPending = {};
              this.__dataOld = {};
            }
            // Ensure old is captured from the last turn
            if (this.__dataOld && !(property in this.__dataOld)) {
              this.__dataOld[property] = old;
            }
            this.__data[property] = value;
            this.__dataPending[property] = value;
          }
          return changed;
        }

        /**
         * Returns true if the specified property has a pending change.
         *
         * @param {string} prop Property name
         * @return {boolean} True if property has a pending change
         * @protected
         */

      }, {
        key: '_isPropertyPending',
        value: function _isPropertyPending(prop) {
          return Boolean(this.__dataPending && prop in this.__dataPending);
        }

        /**
         * Marks the properties as invalid, and enqueues an async
         * `_propertiesChanged` callback.
         *
         * @protected
         */

      }, {
        key: '_invalidateProperties',
        value: function _invalidateProperties() {
          var _this2 = this;

          if (!this.__dataInvalid && this.__dataReady) {
            this.__dataInvalid = true;
            microtask.run(function () {
              if (_this2.__dataInvalid) {
                _this2.__dataInvalid = false;
                _this2._flushProperties();
              }
            });
          }
        }

        /**
         * Call to enable property accessor processing. Before this method is
         * called accessor values will be set but side effects are
         * queued. When called, any pending side effects occur immediately.
         * For elements, generally `connectedCallback` is a normal spot to do so.
         * It is safe to call this method multiple times as it only turns on
         * property accessors once.
         */

      }, {
        key: '_enableProperties',
        value: function _enableProperties() {
          if (!this.__dataEnabled) {
            this.__dataEnabled = true;
            if (this.__dataInstanceProps) {
              this._initializeInstanceProperties(this.__dataInstanceProps);
              this.__dataInstanceProps = null;
            }
            this.ready();
          }
        }

        /**
         * Calls the `_propertiesChanged` callback with the current set of
         * pending changes (and old values recorded when pending changes were
         * set), and resets the pending set of changes. Generally, this method
         * should not be called in user code.
         *
         *
         * @protected
         */

      }, {
        key: '_flushProperties',
        value: function _flushProperties() {
          if (this.__dataPending && this.__dataOld) {
            var changedProps = this.__dataPending;
            this.__dataPending = null;
            this.__dataCounter++;
            this._propertiesChanged(this.__data, changedProps, this.__dataOld);
            this.__dataCounter--;
          }
        }

        /**
         * Lifecycle callback called the first time properties are being flushed.
         * Prior to `ready`, all property sets through accessors are queued and
         * their effects are flushed after this method returns.
         *
         * Users may override this function to implement behavior that is
         * dependent on the element having its properties initialized, e.g.
         * from defaults (initialized from `constructor`, `_initializeProperties`),
         * `attributeChangedCallback`, or values propagated from host e.g. via
         * bindings.  `super.ready()` must be called to ensure the data system
         * becomes enabled.
         *
         * @public
         */

      }, {
        key: 'ready',
        value: function ready() {
          this.__dataReady = true;
          // Run normal flush
          this._flushProperties();
        }

        /**
         * Callback called when any properties with accessors created via
         * `_createPropertyAccessor` have been set.
         *
         * @param {!Object} currentProps Bag of all current accessor values
         * @param {!Object} changedProps Bag of properties changed since the last
         *   call to `_propertiesChanged`
         * @param {!Object} oldProps Bag of previous values for each property
         *   in `changedProps`
         * @protected
         */

      }, {
        key: '_propertiesChanged',
        value: function _propertiesChanged(currentProps, changedProps, oldProps) {} // eslint-disable-line no-unused-vars


        /**
         * Method called to determine whether a property value should be
         * considered as a change and cause the `_propertiesChanged` callback
         * to be enqueued.
         *
         * The default implementation returns `true` for primitive types if a
         * strict equality check fails, and returns `true` for all Object/Arrays.
         * The method always returns false for `NaN`.
         *
         * Override this method to e.g. provide stricter checking for
         * Objects/Arrays when using immutable patterns.
         *
         * @param {string} property Property name
         * @param {*} value New property value
         * @param {*} old Previous property value
         * @return {boolean} Whether the property should be considered a change
         *   and enqueue a `_proeprtiesChanged` callback
         * @protected
         */

      }, {
        key: '_shouldPropertyChange',
        value: function _shouldPropertyChange(property, value, old) {
          return (
            // Strict equality check
            old !== value && (
            // This ensures (old==NaN, value==NaN) always returns false
            old === old || value === value)
          );
        }
      }]);

      return PropertyAccessors;
    }(superClass);

    return PropertyAccessors;
  });
})();

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

__webpack_require__(1);

__webpack_require__(3);

(function () {

  'use strict';

  // 1.x backwards-compatible auto-wrapper for template type extensions
  // This is a clear layering violation and gives favored-nation status to
  // dom-if and dom-repeat templates.  This is a conceit we're choosing to keep
  // a.) to ease 1.x backwards-compatibility due to loss of `is`, and
  // b.) to maintain if/repeat capability in parser-constrained elements
  //     (e.g. table, select) in lieu of native CE type extensions without
  //     massive new invention in this space (e.g. directive system)

  var templateExtensions = {
    'dom-if': true,
    'dom-repeat': true
  };
  function wrapTemplateExtension(node) {
    var is = node.getAttribute('is');
    if (is && templateExtensions[is]) {
      var t = node;
      t.removeAttribute('is');
      node = t.ownerDocument.createElement(is);
      t.parentNode.replaceChild(node, t);
      node.appendChild(t);
      while (t.attributes.length) {
        node.setAttribute(t.attributes[0].name, t.attributes[0].value);
        t.removeAttribute(t.attributes[0].name);
      }
    }
    return node;
  }

  function findTemplateNode(root, nodeInfo) {
    // recursively ascend tree until we hit root
    var parent = nodeInfo.parentInfo && findTemplateNode(root, nodeInfo.parentInfo);
    // unwind the stack, returning the indexed node at each level
    if (parent) {
      // note: marginally faster than indexing via childNodes
      // (http://jsperf.com/childnodes-lookup)
      for (var n = parent.firstChild, i = 0; n; n = n.nextSibling) {
        if (nodeInfo.parentIndex === i++) {
          return n;
        }
      }
    } else {
      return root;
    }
  }

  // construct `$` map (from id annotations)
  function applyIdToMap(inst, map, node, nodeInfo) {
    if (nodeInfo.id) {
      map[nodeInfo.id] = node;
    }
  }

  // install event listeners (from event annotations)
  function applyEventListener(inst, node, nodeInfo) {
    if (nodeInfo.events && nodeInfo.events.length) {
      for (var j = 0, e$ = nodeInfo.events, e; j < e$.length && (e = e$[j]); j++) {
        inst._addMethodEventListenerToNode(node, e.name, e.value, inst);
      }
    }
  }

  // push configuration references at configure time
  function applyTemplateContent(inst, node, nodeInfo) {
    if (nodeInfo.templateInfo) {
      node._templateInfo = nodeInfo.templateInfo;
    }
  }

  function createNodeEventHandler(context, eventName, methodName) {
    // Instances can optionally have a _methodHost which allows redirecting where
    // to find methods. Currently used by `templatize`.
    context = context._methodHost || context;
    var handler = function handler(e) {
      if (context[methodName]) {
        context[methodName](e, e.detail);
      } else {
        console.warn('listener method `' + methodName + '` not defined');
      }
    };
    return handler;
  }

  /**
   * Element mixin that provides basic template parsing and stamping, including
   * the following template-related features for stamped templates:
   *
   * - Declarative event listeners (`on-eventname="listener"`)
   * - Map of node id's to stamped node instances (`this.$.id`)
   * - Nested template content caching/removal and re-installation (performance
   *   optimization)
   *
   * @mixinFunction
   * @polymer
   * @memberof Polymer
   * @summary Element class mixin that provides basic template parsing and stamping
   */
  Polymer.TemplateStamp = Polymer.dedupingMixin(function (superClass) {

    /**
     * @polymer
     * @mixinClass
     * @implements {Polymer_TemplateStamp}
     */
    var TemplateStamp = function (_superClass) {
      _inherits(TemplateStamp, _superClass);

      function TemplateStamp() {
        _classCallCheck(this, TemplateStamp);

        return _possibleConstructorReturn(this, (TemplateStamp.__proto__ || Object.getPrototypeOf(TemplateStamp)).apply(this, arguments));
      }

      _createClass(TemplateStamp, [{
        key: '_stampTemplate',


        /**
         * Clones the provided template content and returns a document fragment
         * containing the cloned dom.
         *
         * The template is parsed (once and memoized) using this library's
         * template parsing features, and provides the following value-added
         * features:
         * * Adds declarative event listeners for `on-event="handler"` attributes
         * * Generates an "id map" for all nodes with id's under `$` on returned
         *   document fragment
         * * Passes template info including `content` back to templates as
         *   `_templateInfo` (a performance optimization to avoid deep template
         *   cloning)
         *
         * Note that the memoized template parsing process is destructive to the
         * template: attributes for bindings and declarative event listeners are
         * removed after being noted in notes, and any nested `<template>.content`
         * is removed and stored in notes as well.
         *
         * @param {!HTMLTemplateElement} template Template to stamp
         * @return {!StampedTemplate} Cloned template content
         */
        value: function _stampTemplate(template) {
          // Polyfill support: bootstrap the template if it has not already been
          if (template && !template.content && window.HTMLTemplateElement && HTMLTemplateElement.decorate) {
            HTMLTemplateElement.decorate(template);
          }
          var templateInfo = this.constructor._parseTemplate(template);
          var nodeInfo = templateInfo.nodeInfoList;
          var content = templateInfo.content || template.content;
          var dom = /** @type DocumentFragment */document.importNode(content, true);
          // NOTE: ShadyDom optimization indicating there is an insertion point
          dom.__noInsertionPoint = !templateInfo.hasInsertionPoint;
          var nodes = dom.nodeList = new Array(nodeInfo.length);
          dom.$ = {};
          for (var i = 0, l = nodeInfo.length, info; i < l && (info = nodeInfo[i]); i++) {
            var node = nodes[i] = findTemplateNode(dom, info);
            applyIdToMap(this, dom.$, node, info);
            applyTemplateContent(this, node, info);
            applyEventListener(this, node, info);
          }
          return (/** @type {!StampedTemplate} */dom
          );
        }

        /**
         * Adds an event listener by method name for the event provided.
         *
         * This method generates a handler function that looks up the method
         * name at handling time.
         *
         * @param {Node} node Node to add listener on
         * @param {string} eventName Name of event
         * @param {string} methodName Name of method
         * @param {*=} context Context the method will be called on (defaults
         *   to `node`)
         * @return {Function} Generated handler function
         */

      }, {
        key: '_addMethodEventListenerToNode',
        value: function _addMethodEventListenerToNode(node, eventName, methodName, context) {
          context = context || node;
          var handler = createNodeEventHandler(context, eventName, methodName);
          this._addEventListenerToNode(node, eventName, handler);
          return handler;
        }

        /**
         * Override point for adding custom or simulated event handling.
         *
         * @param {Node} node Node to add event listener to
         * @param {string} eventName Name of event
         * @param {Function} handler Listener function to add
         */

      }, {
        key: '_addEventListenerToNode',
        value: function _addEventListenerToNode(node, eventName, handler) {
          node.addEventListener(eventName, handler);
        }

        /**
         * Override point for adding custom or simulated event handling.
         *
         * @param {Node} node Node to remove event listener from
         * @param {string} eventName Name of event
         * @param {Function} handler Listener function to remove
         */

      }, {
        key: '_removeEventListenerFromNode',
        value: function _removeEventListenerFromNode(node, eventName, handler) {
          node.removeEventListener(eventName, handler);
        }
      }], [{
        key: '_parseTemplate',


        /**
         * Scans a template to produce template metadata.
         *
         * Template-specific metadata are stored in the object returned, and node-
         * specific metadata are stored in objects in its flattened `nodeInfoList`
         * array.  Only nodes in the template that were parsed as nodes of
         * interest contain an object in `nodeInfoList`.  Each `nodeInfo` object
         * contains an `index` (`childNodes` index in parent) and optionally
         * `parent`, which points to node info of its parent (including its index).
         *
         * The template metadata object returned from this method has the following
         * structure (many fields optional):
         *
         * ```js
         *   {
         *     // Flattened list of node metadata (for nodes that generated metadata)
         *     nodeInfoList: [
         *       {
         *         // `id` attribute for any nodes with id's for generating `$` map
         *         id: {string},
         *         // `on-event="handler"` metadata
         *         events: [
         *           {
         *             name: {string},   // event name
         *             value: {string},  // handler method name
         *           }, ...
         *         ],
         *         // Notes when the template contained a `<slot>` for shady DOM
         *         // optimization purposes
         *         hasInsertionPoint: {boolean},
         *         // For nested `<template>`` nodes, nested template metadata
         *         templateInfo: {object}, // nested template metadata
         *         // Metadata to allow efficient retrieval of instanced node
         *         // corresponding to this metadata
         *         parentInfo: {number},   // reference to parent nodeInfo>
         *         parentIndex: {number},  // index in parent's `childNodes` collection
         *         infoIndex: {number},    // index of this `nodeInfo` in `templateInfo.nodeInfoList`
         *       },
         *       ...
         *     ],
         *     // When true, the template had the `strip-whitespace` attribute
         *     // or was nested in a template with that setting
         *     stripWhitespace: {boolean},
         *     // For nested templates, nested template content is moved into
         *     // a document fragment stored here; this is an optimization to
         *     // avoid the cost of nested template cloning
         *     content: {DocumentFragment}
         *   }
         * ```
         *
         * This method kicks off a recursive treewalk as follows:
         *
         * ```
         *    _parseTemplate <---------------------+
         *      _parseTemplateContent              |
         *        _parseTemplateNode  <------------|--+
         *          _parseTemplateNestedTemplate --+  |
         *          _parseTemplateChildNodes ---------+
         *          _parseTemplateNodeAttributes
         *            _parseTemplateNodeAttribute
         *
         * ```
         *
         * These methods may be overridden to add custom metadata about templates
         * to either `templateInfo` or `nodeInfo`.
         *
         * Note that this method may be destructive to the template, in that
         * e.g. event annotations may be removed after being noted in the
         * template metadata.
         *
         * @param {!HTMLTemplateElement} template Template to parse
         * @param {TemplateInfo=} outerTemplateInfo Template metadata from the outer
         *   template, for parsing nested templates
         * @return {!TemplateInfo} Parsed template metadata
         */
        value: function _parseTemplate(template, outerTemplateInfo) {
          // since a template may be re-used, memo-ize metadata
          if (!template._templateInfo) {
            var templateInfo = template._templateInfo = {};
            templateInfo.nodeInfoList = [];
            templateInfo.stripWhiteSpace = outerTemplateInfo && outerTemplateInfo.stripWhiteSpace || template.hasAttribute('strip-whitespace');
            this._parseTemplateContent(template, templateInfo, { parent: null });
          }
          return template._templateInfo;
        }
      }, {
        key: '_parseTemplateContent',
        value: function _parseTemplateContent(template, templateInfo, nodeInfo) {
          return this._parseTemplateNode(template.content, templateInfo, nodeInfo);
        }

        /**
         * Parses template node and adds template and node metadata based on
         * the current node, and its `childNodes` and `attributes`.
         *
         * This method may be overridden to add custom node or template specific
         * metadata based on this node.
         *
         * @param {Node} node Node to parse
         * @param {!TemplateInfo} templateInfo Template metadata for current template
         * @param {!NodeInfo} nodeInfo Node metadata for current template.
         * @return {boolean} `true` if the visited node added node-specific
         *   metadata to `nodeInfo`
         */

      }, {
        key: '_parseTemplateNode',
        value: function _parseTemplateNode(node, templateInfo, nodeInfo) {
          var noted = void 0;
          var element = /** @type Element */node;
          if (element.localName == 'template' && !element.hasAttribute('preserve-content')) {
            noted = this._parseTemplateNestedTemplate(element, templateInfo, nodeInfo) || noted;
          } else if (element.localName === 'slot') {
            // For ShadyDom optimization, indicating there is an insertion point
            templateInfo.hasInsertionPoint = true;
          }
          if (element.firstChild) {
            noted = this._parseTemplateChildNodes(element, templateInfo, nodeInfo) || noted;
          }
          if (element.hasAttributes && element.hasAttributes()) {
            noted = this._parseTemplateNodeAttributes(element, templateInfo, nodeInfo) || noted;
          }
          return noted;
        }

        /**
         * Parses template child nodes for the given root node.
         *
         * This method also wraps whitelisted legacy template extensions
         * (`is="dom-if"` and `is="dom-repeat"`) with their equivalent element
         * wrappers, collapses text nodes, and strips whitespace from the template
         * if the `templateInfo.stripWhitespace` setting was provided.
         *
         * @param {Node} root Root node whose `childNodes` will be parsed
         * @param {!TemplateInfo} templateInfo Template metadata for current template
         * @param {!NodeInfo} nodeInfo Node metadata for current template.
         */

      }, {
        key: '_parseTemplateChildNodes',
        value: function _parseTemplateChildNodes(root, templateInfo, nodeInfo) {
          for (var node = root.firstChild, parentIndex = 0, next; node; node = next) {
            // Wrap templates
            if (node.localName == 'template') {
              node = wrapTemplateExtension(node);
            }
            // collapse adjacent textNodes: fixes an IE issue that can cause
            // text nodes to be inexplicably split =(
            // note that root.normalize() should work but does not so we do this
            // manually.
            next = node.nextSibling;
            if (node.nodeType === Node.TEXT_NODE) {
              var /** Node */n = next;
              while (n && n.nodeType === Node.TEXT_NODE) {
                node.textContent += n.textContent;
                next = n.nextSibling;
                root.removeChild(n);
                n = next;
              }
              // optionally strip whitespace
              if (templateInfo.stripWhiteSpace && !node.textContent.trim()) {
                root.removeChild(node);
                continue;
              }
            }
            var childInfo = { parentIndex: parentIndex, parentInfo: nodeInfo };
            if (this._parseTemplateNode(node, templateInfo, childInfo)) {
              childInfo.infoIndex = templateInfo.nodeInfoList.push( /** @type {!NodeInfo} */childInfo) - 1;
            }
            // Increment if not removed
            if (node.parentNode) {
              parentIndex++;
            }
          }
        }

        /**
         * Parses template content for the given nested `<template>`.
         *
         * Nested template info is stored as `templateInfo` in the current node's
         * `nodeInfo`. `template.content` is removed and stored in `templateInfo`.
         * It will then be the responsibility of the host to set it back to the
         * template and for users stamping nested templates to use the
         * `_contentForTemplate` method to retrieve the content for this template
         * (an optimization to avoid the cost of cloning nested template content).
         *
         * @param {HTMLTemplateElement} node Node to parse (a <template>)
         * @param {TemplateInfo} outerTemplateInfo Template metadata for current template
         *   that includes the template `node`
         * @param {!NodeInfo} nodeInfo Node metadata for current template.
         * @return {boolean} `true` if the visited node added node-specific
         *   metadata to `nodeInfo`
         */

      }, {
        key: '_parseTemplateNestedTemplate',
        value: function _parseTemplateNestedTemplate(node, outerTemplateInfo, nodeInfo) {
          var templateInfo = this._parseTemplate(node, outerTemplateInfo);
          var content = templateInfo.content = node.content.ownerDocument.createDocumentFragment();
          content.appendChild(node.content);
          nodeInfo.templateInfo = templateInfo;
          return true;
        }

        /**
         * Parses template node attributes and adds node metadata to `nodeInfo`
         * for nodes of interest.
         *
         * @param {Element} node Node to parse
         * @param {TemplateInfo} templateInfo Template metadata for current template
         * @param {NodeInfo} nodeInfo Node metadata for current template.
         * @return {boolean} `true` if the visited node added node-specific
         *   metadata to `nodeInfo`
         */

      }, {
        key: '_parseTemplateNodeAttributes',
        value: function _parseTemplateNodeAttributes(node, templateInfo, nodeInfo) {
          // Make copy of original attribute list, since the order may change
          // as attributes are added and removed
          var noted = false;
          var attrs = Array.from(node.attributes);
          for (var i = attrs.length - 1, a; a = attrs[i]; i--) {
            noted = this._parseTemplateNodeAttribute(node, templateInfo, nodeInfo, a.name, a.value) || noted;
          }
          return noted;
        }

        /**
         * Parses a single template node attribute and adds node metadata to
         * `nodeInfo` for attributes of interest.
         *
         * This implementation adds metadata for `on-event="handler"` attributes
         * and `id` attributes.
         *
         * @param {Element} node Node to parse
         * @param {!TemplateInfo} templateInfo Template metadata for current template
         * @param {!NodeInfo} nodeInfo Node metadata for current template.
         * @param {string} name Attribute name
         * @param {string} value Attribute value
         * @return {boolean} `true` if the visited node added node-specific
         *   metadata to `nodeInfo`
         */

      }, {
        key: '_parseTemplateNodeAttribute',
        value: function _parseTemplateNodeAttribute(node, templateInfo, nodeInfo, name, value) {
          // events (on-*)
          if (name.slice(0, 3) === 'on-') {
            node.removeAttribute(name);
            nodeInfo.events = nodeInfo.events || [];
            nodeInfo.events.push({
              name: name.slice(3),
              value: value
            });
            return true;
          }
          // static id
          else if (name === 'id') {
              nodeInfo.id = value;
              return true;
            }
          return false;
        }

        /**
         * Returns the `content` document fragment for a given template.
         *
         * For nested templates, Polymer performs an optimization to cache nested
         * template content to avoid the cost of cloning deeply nested templates.
         * This method retrieves the cached content for a given template.
         *
         * @param {HTMLTemplateElement} template Template to retrieve `content` for
         * @return {DocumentFragment} Content fragment
         */

      }, {
        key: '_contentForTemplate',
        value: function _contentForTemplate(template) {
          var templateInfo = /** @type {HTMLTemplateElementWithInfo} */template._templateInfo;
          return templateInfo && templateInfo.content || template.content;
        }
      }]);

      return TemplateStamp;
    }(superClass);

    return TemplateStamp;
  });
})();

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

__webpack_require__(5);

var RegisterHtmlTemplate = __webpack_require__(2);

RegisterHtmlTemplate.register("<dom-module id=app-drawer> <template> <style>:host{position:fixed;top:-120px;right:0;bottom:-120px;left:0;visibility:hidden;transition-property:visibility}:host([opened]){visibility:visible}:host([persistent]){width:var(--app-drawer-width,256px)}:host([persistent][position=left]){right:auto}:host([persistent][position=right]){left:auto}#contentContainer{position:absolute;top:0;bottom:0;left:0;width:var(--app-drawer-width,256px);padding:120px 0;transition-property:-webkit-transform;transition-property:transform;-webkit-transform:translate3d(-100%,0,0);transform:translate3d(-100%,0,0);background-color:#fff;@apply --app-drawer-content-container;}#contentContainer[persistent]{width:100%}#contentContainer[position=right]{right:0;left:auto;-webkit-transform:translate3d(100%,0,0);transform:translate3d(100%,0,0)}#contentContainer[swipe-open]::after{position:fixed;top:0;bottom:0;left:100%;visibility:visible;width:20px;content:''}#contentContainer[swipe-open][position=right]::after{right:100%;left:auto}#contentContainer[opened]{-webkit-transform:translate3d(0,0,0);transform:translate3d(0,0,0)}#scrim{position:absolute;top:0;right:0;bottom:0;left:0;transition-property:opacity;-webkit-transform:translateZ(0);transform:translateZ(0);opacity:0;background:var(--app-drawer-scrim-background,rgba(0,0,0,.5))}#scrim.visible{opacity:1}:host([no-transition]) #contentContainer{transition-property:none}</style> <div id=scrim on-click=close></div> <div id=contentContainer opened$=[[opened]] persistent$=[[persistent]] position$=[[position]] swipe-open$=[[swipeOpen]]> <slot></slot> </div> </template> </dom-module>");

Polymer({
  is: 'app-drawer',

  properties: {
    /**
     * The opened state of the drawer.
     */
    opened: {
      type: Boolean,
      value: false,
      notify: true,
      reflectToAttribute: true
    },

    /**
     * The drawer does not have a scrim and cannot be swiped close.
     */
    persistent: {
      type: Boolean,
      value: false,
      reflectToAttribute: true
    },

    /**
     * The transition duration of the drawer in milliseconds.
     */
    transitionDuration: {
      type: Number,
      value: 200
    },

    /**
     * The alignment of the drawer on the screen ('left', 'right', 'start' or 'end').
     * 'start' computes to left and 'end' to right in LTR layout and vice versa in RTL
     * layout.
     */
    align: {
      type: String,
      value: 'left'
    },

    /**
     * The computed, read-only position of the drawer on the screen ('left' or 'right').
     */
    position: {
      type: String,
      readOnly: true,
      reflectToAttribute: true
    },

    /**
     * Create an area at the edge of the screen to swipe open the drawer.
     */
    swipeOpen: {
      type: Boolean,
      value: false,
      reflectToAttribute: true
    },

    /**
     * Trap keyboard focus when the drawer is opened and not persistent.
     */
    noFocusTrap: {
      type: Boolean,
      value: false
    },

    /**
     * Disables swiping on the drawer.
     */
    disableSwipe: {
      type: Boolean,
      value: false
    }
  },

  observers: ['resetLayout(position, isAttached)', '_resetPosition(align, isAttached)', '_styleTransitionDuration(transitionDuration)', '_openedPersistentChanged(opened, persistent)'],

  _translateOffset: 0,

  _trackDetails: null,

  _drawerState: 0,

  _boundEscKeydownHandler: null,

  _firstTabStop: null,

  _lastTabStop: null,

  attached: function attached() {
    Polymer.RenderStatus.afterNextRender(this, function () {
      this._boundEscKeydownHandler = this._escKeydownHandler.bind(this);
      this.addEventListener('keydown', this._tabKeydownHandler.bind(this));

      // Only listen for horizontal track so you can vertically scroll inside the drawer.
      this.listen(this, 'track', '_track');
      this.setScrollDirection('y');
    });

    this.fire('app-reset-layout');
  },

  detached: function detached() {
    document.removeEventListener('keydown', this._boundEscKeydownHandler);
  },

  /**
   * Opens the drawer.
   */
  open: function open() {
    this.opened = true;
  },

  /**
   * Closes the drawer.
   */
  close: function close() {
    this.opened = false;
  },

  /**
   * Toggles the drawer open and close.
   */
  toggle: function toggle() {
    this.opened = !this.opened;
  },

  /**
   * Gets the width of the drawer.
   *
   * @return {number} The width of the drawer in pixels.
   */
  getWidth: function getWidth() {
    return this._savedWidth || this.$.contentContainer.offsetWidth;
  },

  _isRTL: function _isRTL() {
    return window.getComputedStyle(this).direction === 'rtl';
  },

  _resetPosition: function _resetPosition() {
    switch (this.align) {
      case 'start':
        this._setPosition(this._isRTL() ? 'right' : 'left');
        return;
      case 'end':
        this._setPosition(this._isRTL() ? 'left' : 'right');
        return;
    }
    this._setPosition(this.align);
  },

  _escKeydownHandler: function _escKeydownHandler(event) {
    var ESC_KEYCODE = 27;
    if (event.keyCode === ESC_KEYCODE) {
      // Prevent any side effects if app-drawer closes.
      event.preventDefault();
      this.close();
    }
  },

  _track: function _track(event) {
    if (this.persistent || this.disableSwipe) {
      return;
    }

    // Disable user selection on desktop.
    event.preventDefault();

    switch (event.detail.state) {
      case 'start':
        this._trackStart(event);
        break;
      case 'track':
        this._trackMove(event);
        break;
      case 'end':
        this._trackEnd(event);
        break;
    }
  },

  _trackStart: function _trackStart(event) {
    this._drawerState = this._DRAWER_STATE.TRACKING;

    var rect = this.$.contentContainer.getBoundingClientRect();
    this._savedWidth = rect.width;
    if (this.position === 'left') {
      this._translateOffset = rect.left;
    } else {
      this._translateOffset = rect.right - window.innerWidth;
    }

    this._trackDetails = [];

    // Disable transitions since style attributes will reflect user track events.
    this._styleTransitionDuration(0);
    this.style.visibility = 'visible';
  },

  _trackMove: function _trackMove(event) {
    this._translateDrawer(event.detail.dx + this._translateOffset);

    // Use Date.now() since event.timeStamp is inconsistent across browsers (e.g. most
    // browsers use milliseconds but FF 44 uses microseconds).
    this._trackDetails.push({
      dx: event.detail.dx,
      timeStamp: Date.now()
    });
  },

  _trackEnd: function _trackEnd(event) {
    var x = event.detail.dx + this._translateOffset;
    var drawerWidth = this.getWidth();
    var isPositionLeft = this.position === 'left';
    var isInEndState = isPositionLeft ? x >= 0 || x <= -drawerWidth : x <= 0 || x >= drawerWidth;

    if (!isInEndState) {
      // No longer need the track events after this method returns - allow them to be GC'd.
      var trackDetails = this._trackDetails;
      this._trackDetails = null;

      this._flingDrawer(event, trackDetails);
      if (this._drawerState === this._DRAWER_STATE.FLINGING) {
        return;
      }
    }

    // If the drawer is not flinging, toggle the opened state based on the position of
    // the drawer.
    var halfWidth = drawerWidth / 2;
    if (event.detail.dx < -halfWidth) {
      this.opened = this.position === 'right';
    } else if (event.detail.dx > halfWidth) {
      this.opened = this.position === 'left';
    }

    if (isInEndState) {
      this.debounce('_resetDrawerState', this._resetDrawerState);
    } else {
      this.debounce('_resetDrawerState', this._resetDrawerState, this.transitionDuration);
    }

    this._styleTransitionDuration(this.transitionDuration);
    this._resetDrawerTranslate();
    this.style.visibility = '';
  },

  _calculateVelocity: function _calculateVelocity(event, trackDetails) {
    // Find the oldest track event that is within 100ms using binary search.
    var now = Date.now();
    var timeLowerBound = now - 100;
    var trackDetail;
    var min = 0;
    var max = trackDetails.length - 1;

    while (min <= max) {
      // Floor of average of min and max.
      var mid = min + max >> 1;
      var d = trackDetails[mid];
      if (d.timeStamp >= timeLowerBound) {
        trackDetail = d;
        max = mid - 1;
      } else {
        min = mid + 1;
      }
    }

    if (trackDetail) {
      var dx = event.detail.dx - trackDetail.dx;
      var dt = now - trackDetail.timeStamp || 1;
      return dx / dt;
    }
    return 0;
  },

  _flingDrawer: function _flingDrawer(event, trackDetails) {
    var velocity = this._calculateVelocity(event, trackDetails);

    // Do not fling if velocity is not above a threshold.
    if (Math.abs(velocity) < this._MIN_FLING_THRESHOLD) {
      return;
    }

    this._drawerState = this._DRAWER_STATE.FLINGING;

    var x = event.detail.dx + this._translateOffset;
    var drawerWidth = this.getWidth();
    var isPositionLeft = this.position === 'left';
    var isVelocityPositive = velocity > 0;
    var isClosingLeft = !isVelocityPositive && isPositionLeft;
    var isClosingRight = isVelocityPositive && !isPositionLeft;
    var dx;
    if (isClosingLeft) {
      dx = -(x + drawerWidth);
    } else if (isClosingRight) {
      dx = drawerWidth - x;
    } else {
      dx = -x;
    }

    // Enforce a minimum transition velocity to make the drawer feel snappy.
    if (isVelocityPositive) {
      velocity = Math.max(velocity, this._MIN_TRANSITION_VELOCITY);
      this.opened = this.position === 'left';
    } else {
      velocity = Math.min(velocity, -this._MIN_TRANSITION_VELOCITY);
      this.opened = this.position === 'right';
    }

    // Calculate the amount of time needed to finish the transition based on the
    // initial slope of the timing function.
    var t = this._FLING_INITIAL_SLOPE * dx / velocity;
    this._styleTransitionDuration(t);
    this._styleTransitionTimingFunction(this._FLING_TIMING_FUNCTION);

    this._resetDrawerTranslate();
    this.debounce('_resetDrawerState', this._resetDrawerState, t);
  },

  _styleTransitionDuration: function _styleTransitionDuration(duration) {
    this.style.transitionDuration = duration + 'ms';
    this.$.contentContainer.style.transitionDuration = duration + 'ms';
    this.$.scrim.style.transitionDuration = duration + 'ms';
  },

  _styleTransitionTimingFunction: function _styleTransitionTimingFunction(timingFunction) {
    this.$.contentContainer.style.transitionTimingFunction = timingFunction;
    this.$.scrim.style.transitionTimingFunction = timingFunction;
  },

  _translateDrawer: function _translateDrawer(x) {
    var drawerWidth = this.getWidth();

    if (this.position === 'left') {
      x = Math.max(-drawerWidth, Math.min(x, 0));
      this.$.scrim.style.opacity = 1 + x / drawerWidth;
    } else {
      x = Math.max(0, Math.min(x, drawerWidth));
      this.$.scrim.style.opacity = 1 - x / drawerWidth;
    }

    this.translate3d(x + 'px', '0', '0', this.$.contentContainer);
  },

  _resetDrawerTranslate: function _resetDrawerTranslate() {
    this.$.scrim.style.opacity = '';
    this.transform('', this.$.contentContainer);
  },

  _resetDrawerState: function _resetDrawerState() {
    var oldState = this._drawerState;

    // If the drawer was flinging, we need to reset the style attributes.
    if (oldState === this._DRAWER_STATE.FLINGING) {
      this._styleTransitionDuration(this.transitionDuration);
      this._styleTransitionTimingFunction('');
      this.style.visibility = '';
    }

    this._savedWidth = null;

    if (this.opened) {
      this._drawerState = this.persistent ? this._DRAWER_STATE.OPENED_PERSISTENT : this._DRAWER_STATE.OPENED;
    } else {
      this._drawerState = this._DRAWER_STATE.CLOSED;
    }

    if (oldState !== this._drawerState) {
      if (this._drawerState === this._DRAWER_STATE.OPENED) {
        this._setKeyboardFocusTrap();
        document.addEventListener('keydown', this._boundEscKeydownHandler);
        document.body.style.overflow = 'hidden';
      } else {
        document.removeEventListener('keydown', this._boundEscKeydownHandler);
        document.body.style.overflow = '';
      }

      // Don't fire the event on initial load.
      if (oldState !== this._DRAWER_STATE.INIT) {
        this.fire('app-drawer-transitioned');
      }
    }
  },

  /**
   * Resets the layout.
   *
   * @method resetLayout
   */
  resetLayout: function resetLayout() {
    this.fire('app-reset-layout');
  },

  _setKeyboardFocusTrap: function _setKeyboardFocusTrap() {
    if (this.noFocusTrap) {
      return;
    }

    // NOTE: Unless we use /deep/ (which we shouldn't since it's deprecated), this will
    // not select focusable elements inside shadow roots.
    var focusableElementsSelector = ['a[href]:not([tabindex="-1"])', 'area[href]:not([tabindex="-1"])', 'input:not([disabled]):not([tabindex="-1"])', 'select:not([disabled]):not([tabindex="-1"])', 'textarea:not([disabled]):not([tabindex="-1"])', 'button:not([disabled]):not([tabindex="-1"])', 'iframe:not([tabindex="-1"])', '[tabindex]:not([tabindex="-1"])', '[contentEditable=true]:not([tabindex="-1"])'].join(',');
    var focusableElements = Polymer.dom(this).querySelectorAll(focusableElementsSelector);

    if (focusableElements.length > 0) {
      this._firstTabStop = focusableElements[0];
      this._lastTabStop = focusableElements[focusableElements.length - 1];
    } else {
      // Reset saved tab stops when there are no focusable elements in the drawer.
      this._firstTabStop = null;
      this._lastTabStop = null;
    }

    // Focus on app-drawer if it has non-zero tabindex. Otherwise, focus the first focusable
    // element in the drawer, if it exists. Use the tabindex attribute since the this.tabIndex
    // property in IE/Edge returns 0 (instead of -1) when the attribute is not set.
    var tabindex = this.getAttribute('tabindex');
    if (tabindex && parseInt(tabindex, 10) > -1) {
      this.focus();
    } else if (this._firstTabStop) {
      this._firstTabStop.focus();
    }
  },

  _tabKeydownHandler: function _tabKeydownHandler(event) {
    if (this.noFocusTrap) {
      return;
    }

    var TAB_KEYCODE = 9;
    if (this._drawerState === this._DRAWER_STATE.OPENED && event.keyCode === TAB_KEYCODE) {
      if (event.shiftKey) {
        if (this._firstTabStop && Polymer.dom(event).localTarget === this._firstTabStop) {
          event.preventDefault();
          this._lastTabStop.focus();
        }
      } else {
        if (this._lastTabStop && Polymer.dom(event).localTarget === this._lastTabStop) {
          event.preventDefault();
          this._firstTabStop.focus();
        }
      }
    }
  },

  _openedPersistentChanged: function _openedPersistentChanged(opened, persistent) {
    this.toggleClass('visible', opened && !persistent, this.$.scrim);

    // Use a debounce timer instead of transitionend since transitionend won't fire when
    // app-drawer is display: none.
    this.debounce('_resetDrawerState', this._resetDrawerState, this.transitionDuration);
  },

  _MIN_FLING_THRESHOLD: 0.2,

  _MIN_TRANSITION_VELOCITY: 1.2,

  _FLING_TIMING_FUNCTION: 'cubic-bezier(0.667, 1, 0.667, 1)',

  _FLING_INITIAL_SLOPE: 1.5,

  _DRAWER_STATE: {
    INIT: 0,
    OPENED: 1,
    OPENED_PERSISTENT: 2,
    CLOSED: 3,
    TRACKING: 4,
    FLINGING: 5

    /**
     * Fired when the layout of app-drawer has changed.
     *
     * @event app-reset-layout
     */

    /**
     * Fired when app-drawer has finished transitioning.
     *
     * @event app-drawer-transitioned
     */
  } });

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(46);

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


(function () {
  /*
  Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
  This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
  The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
  The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
  Code distributed by Google as part of the polymer project is also
  subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
  */
  'use strict';
  var k = {};function n() {
    this.end = this.start = 0;this.rules = this.parent = this.previous = null;this.cssText = this.parsedCssText = "";this.atRule = !1;this.type = 0;this.parsedSelector = this.selector = this.keyframesName = "";
  }
  function p(a) {
    a = a.replace(aa, "").replace(ba, "");var b = q,
        c = a,
        d = new n();d.start = 0;d.end = c.length;for (var e = d, f = 0, h = c.length; f < h; f++) {
      if ("{" === c[f]) {
        e.rules || (e.rules = []);var g = e,
            m = g.rules[g.rules.length - 1] || null;e = new n();e.start = f + 1;e.parent = g;e.previous = m;g.rules.push(e);
      } else "}" === c[f] && (e.end = f + 1, e = e.parent || d);
    }return b(d, a);
  }
  function q(a, b) {
    var c = b.substring(a.start, a.end - 1);a.parsedCssText = a.cssText = c.trim();a.parent && (c = b.substring(a.previous ? a.previous.end : a.parent.start, a.start - 1), c = ca(c), c = c.replace(r, " "), c = c.substring(c.lastIndexOf(";") + 1), c = a.parsedSelector = a.selector = c.trim(), a.atRule = 0 === c.indexOf("@"), a.atRule ? 0 === c.indexOf("@media") ? a.type = t : c.match(da) && (a.type = u, a.keyframesName = a.selector.split(r).pop()) : a.type = 0 === c.indexOf("--") ? v : x);if (c = a.rules) for (var d = 0, e = c.length, f; d < e && (f = c[d]); d++) {
      q(f, b);
    }return a;
  }
  function ca(a) {
    return a.replace(/\\([0-9a-f]{1,6})\s/gi, function (a, c) {
      a = c;for (c = 6 - a.length; c--;) {
        a = "0" + a;
      }return "\\" + a;
    });
  }
  function y(a, b, c) {
    c = void 0 === c ? "" : c;var d = "";if (a.cssText || a.rules) {
      var e = a.rules,
          f;if (f = e) f = e[0], f = !(f && f.selector && 0 === f.selector.indexOf("--"));if (f) {
        f = 0;for (var h = e.length, g; f < h && (g = e[f]); f++) {
          d = y(g, b, d);
        }
      } else b ? b = a.cssText : (b = a.cssText, b = b.replace(ea, "").replace(fa, ""), b = b.replace(ha, "").replace(ia, "")), (d = b.trim()) && (d = "  " + d + "\n");
    }d && (a.selector && (c += a.selector + " {\n"), c += d, a.selector && (c += "}\n\n"));return c;
  }
  var x = 1,
      u = 7,
      t = 4,
      v = 1E3,
      aa = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//gim,
      ba = /@import[^;]*;/gim,
      ea = /(?:^[^;\-\s}]+)?--[^;{}]*?:[^{};]*?(?:[;\n]|$)/gim,
      fa = /(?:^[^;\-\s}]+)?--[^;{}]*?:[^{};]*?{[^}]*?}(?:[;\n]|$)?/gim,
      ha = /@apply\s*\(?[^);]*\)?\s*(?:[;\n]|$)?/gim,
      ia = /[^;:]*?:[^;]*?var\([^;]*\)(?:[;\n]|$)?/gim,
      da = /^@[^\s]*keyframes/,
      r = /\s+/g;var ja = Promise.resolve();function ka(a) {
    if (a = k[a]) a._applyShimCurrentVersion = a._applyShimCurrentVersion || 0, a._applyShimValidatingVersion = a._applyShimValidatingVersion || 0, a._applyShimNextVersion = (a._applyShimNextVersion || 0) + 1;
  }function z(a) {
    return a._applyShimCurrentVersion === a._applyShimNextVersion;
  }function la(a) {
    a._applyShimValidatingVersion = a._applyShimNextVersion;a.a || (a.a = !0, ja.then(function () {
      a._applyShimCurrentVersion = a._applyShimNextVersion;a.a = !1;
    }));
  };var A = !(window.ShadyDOM && window.ShadyDOM.inUse),
      B;function C(a) {
    B = a && a.shimcssproperties ? !1 : A || !(navigator.userAgent.match(/AppleWebKit\/601|Edge\/15/) || !window.CSS || !CSS.supports || !CSS.supports("box-shadow", "0 0 0 var(--foo)"));
  }window.ShadyCSS && void 0 !== window.ShadyCSS.nativeCss ? B = window.ShadyCSS.nativeCss : window.ShadyCSS ? (C(window.ShadyCSS), window.ShadyCSS = void 0) : C(window.WebComponents && window.WebComponents.flags);var E = B;var F = /(?:^|[;\s{]\s*)(--[\w-]*?)\s*:\s*(?:((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};{])+)|\{([^}]*)\}(?:(?=[;\s}])|$))/gi,
      G = /(?:^|\W+)@apply\s*\(?([^);\n]*)\)?/gi,
      ma = /@media\s(.*)/;function H(a) {
    if (!a) return "";"string" === typeof a && (a = p(a));return y(a, E);
  }function I(a) {
    !a.__cssRules && a.textContent && (a.__cssRules = p(a.textContent));return a.__cssRules || null;
  }function J(a, b, c, d) {
    if (a) {
      var e = !1,
          f = a.type;if (d && f === t) {
        var h = a.selector.match(ma);h && (window.matchMedia(h[1]).matches || (e = !0));
      }f === x ? b(a) : c && f === u ? c(a) : f === v && (e = !0);if ((a = a.rules) && !e) {
        e = 0;f = a.length;for (var g; e < f && (g = a[e]); e++) {
          J(g, b, c, d);
        }
      }
    }
  }
  function K(a, b) {
    var c = a.indexOf("var(");if (-1 === c) return b(a, "", "", "");a: {
      var d = 0;var e = c + 3;for (var f = a.length; e < f; e++) {
        if ("(" === a[e]) d++;else if (")" === a[e] && 0 === --d) break a;
      }e = -1;
    }d = a.substring(c + 4, e);c = a.substring(0, c);a = K(a.substring(e + 1), b);e = d.indexOf(",");return -1 === e ? b(c, d.trim(), "", a) : b(c, d.substring(0, e).trim(), d.substring(e + 1).trim(), a);
  };var na = /;\s*/m,
      oa = /^\s*(initial)|(inherit)\s*$/;function L() {
    this.a = {};
  }L.prototype.set = function (a, b) {
    a = a.trim();this.a[a] = { h: b, i: {} };
  };L.prototype.get = function (a) {
    a = a.trim();return this.a[a] || null;
  };var M = null;function N() {
    this.b = this.c = null;this.a = new L();
  }N.prototype.o = function (a) {
    a = G.test(a) || F.test(a);G.lastIndex = 0;F.lastIndex = 0;return a;
  };N.prototype.m = function (a, b) {
    a = a.content.querySelector("style");var c = null;a && (c = this.j(a, b));return c;
  };
  N.prototype.j = function (a, b) {
    b = void 0 === b ? "" : b;var c = I(a);this.l(c, b);a.textContent = H(c);return c;
  };N.prototype.f = function (a) {
    var b = this,
        c = I(a);J(c, function (a) {
      ":root" === a.selector && (a.selector = "html");b.g(a);
    });a.textContent = H(c);return c;
  };N.prototype.l = function (a, b) {
    var c = this;this.c = b;J(a, function (a) {
      c.g(a);
    });this.c = null;
  };N.prototype.g = function (a) {
    a.cssText = pa(this, a.parsedCssText);":root" === a.selector && (a.selector = ":host > *");
  };
  function pa(a, b) {
    b = b.replace(F, function (b, d, e, f) {
      return qa(a, b, d, e, f);
    });return O(a, b);
  }function O(a, b) {
    for (var c; c = G.exec(b);) {
      var d = c[0],
          e = c[1];c = c.index;var f = b.slice(0, c + d.indexOf("@apply"));b = b.slice(c + d.length);var h = P(a, f);d = void 0;var g = a;e = e.replace(na, "");var m = [];var l = g.a.get(e);l || (g.a.set(e, {}), l = g.a.get(e));if (l) for (d in g.c && (l.i[g.c] = !0), l.h) {
        g = h && h[d], l = [d, ": var(", e, "_-_", d], g && l.push(",", g), l.push(")"), m.push(l.join(""));
      }d = m.join("; ");b = "" + f + d + b;G.lastIndex = c + d.length;
    }return b;
  }
  function P(a, b) {
    b = b.split(";");for (var c, d, e = {}, f = 0, h; f < b.length; f++) {
      if (c = b[f]) if (h = c.split(":"), 1 < h.length) {
        c = h[0].trim();var g = a;d = c;h = h.slice(1).join(":");var m = oa.exec(h);m && (m[1] ? (g.b || (g.b = document.createElement("meta"), g.b.setAttribute("apply-shim-measure", ""), g.b.style.all = "initial", document.head.appendChild(g.b)), d = window.getComputedStyle(g.b).getPropertyValue(d)) : d = "apply-shim-inherit", h = d);d = h;e[c] = d;
      }
    }return e;
  }function ra(a, b) {
    if (M) for (var c in b.i) {
      c !== a.c && M(c);
    }
  }
  function qa(a, b, c, d, e) {
    d && K(d, function (b, c) {
      c && a.a.get(c) && (e = "@apply " + c + ";");
    });if (!e) return b;var f = O(a, e),
        h = b.slice(0, b.indexOf("--")),
        g = f = P(a, f),
        m = a.a.get(c),
        l = m && m.h;l ? g = Object.assign(Object.create(l), f) : a.a.set(c, g);var X = [],
        w,
        Y = !1;for (w in g) {
      var D = f[w];void 0 === D && (D = "initial");!l || w in l || (Y = !0);X.push("" + c + "_-_" + w + ": " + D);
    }Y && ra(a, m);m && (m.h = g);d && (h = b + ";" + h);return "" + h + X.join("; ") + ";";
  }N.prototype.detectMixin = N.prototype.o;N.prototype.transformStyle = N.prototype.j;
  N.prototype.transformCustomStyle = N.prototype.f;N.prototype.transformRules = N.prototype.l;N.prototype.transformRule = N.prototype.g;N.prototype.transformTemplate = N.prototype.m;N.prototype._separator = "_-_";Object.defineProperty(N.prototype, "invalidCallback", { get: function get() {
      return M;
    }, set: function set(a) {
      M = a;
    } });var Q = null,
      R = window.HTMLImports && window.HTMLImports.whenReady || null,
      S;function sa(a) {
    requestAnimationFrame(function () {
      R ? R(a) : (Q || (Q = new Promise(function (a) {
        S = a;
      }), "complete" === document.readyState ? S() : document.addEventListener("readystatechange", function () {
        "complete" === document.readyState && S();
      })), Q.then(function () {
        a && a();
      }));
    });
  };var T = new N();function U() {
    var a = this;this.a = null;sa(function () {
      V(a);
    });T.invalidCallback = ka;
  }function V(a) {
    a.a || (a.a = window.ShadyCSS.CustomStyleInterface, a.a && (a.a.transformCallback = function (a) {
      T.f(a);
    }, a.a.validateCallback = function () {
      requestAnimationFrame(function () {
        a.a.enqueued && W(a);
      });
    }));
  }U.prototype.prepareTemplate = function (a, b) {
    V(this);k[b] = a;b = T.m(a, b);a._styleAst = b;
  };
  function W(a) {
    V(a);if (a.a) {
      var b = a.a.processStyles();if (a.a.enqueued) {
        for (var c = 0; c < b.length; c++) {
          var d = a.a.getStyleForCustomStyle(b[c]);d && T.f(d);
        }a.a.enqueued = !1;
      }
    }
  }U.prototype.styleSubtree = function (a, b) {
    V(this);if (b) for (var c in b) {
      null === c ? a.style.removeProperty(c) : a.style.setProperty(c, b[c]);
    }if (a.shadowRoot) for (this.styleElement(a), a = a.shadowRoot.children || a.shadowRoot.childNodes, b = 0; b < a.length; b++) {
      this.styleSubtree(a[b]);
    } else for (a = a.children || a.childNodes, b = 0; b < a.length; b++) {
      this.styleSubtree(a[b]);
    }
  };
  U.prototype.styleElement = function (a) {
    V(this);var b = a.localName,
        c;b ? -1 < b.indexOf("-") ? c = b : c = a.getAttribute && a.getAttribute("is") || "" : c = a.is;if ((b = k[c]) && !z(b)) {
      if (z(b) || b._applyShimValidatingVersion !== b._applyShimNextVersion) this.prepareTemplate(b, c), la(b);if (a = a.shadowRoot) if (a = a.querySelector("style")) a.__cssRules = b._styleAst, a.textContent = H(b._styleAst);
    }
  };U.prototype.styleDocument = function (a) {
    V(this);this.styleSubtree(document.body, a);
  };
  if (!window.ShadyCSS || !window.ShadyCSS.ScopingShim) {
    var Z = new U(),
        ta = window.ShadyCSS && window.ShadyCSS.CustomStyleInterface;window.ShadyCSS = { prepareTemplate: function prepareTemplate(a, b) {
        W(Z);Z.prepareTemplate(a, b);
      }, styleSubtree: function styleSubtree(a, b) {
        W(Z);Z.styleSubtree(a, b);
      }, styleElement: function styleElement(a) {
        W(Z);Z.styleElement(a);
      }, styleDocument: function styleDocument(a) {
        W(Z);Z.styleDocument(a);
      }, getComputedStyleValue: function getComputedStyleValue(a, b) {
        return (a = window.getComputedStyle(a).getPropertyValue(b)) ? a.trim() : "";
      }, nativeCss: E, nativeShadow: A };ta && (window.ShadyCSS.CustomStyleInterface = ta);
  }window.ShadyCSS.ApplyShim = T;
}).call(undefined);

//# sourceMappingURL=apply-shim.min.js.map

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(1);

__webpack_require__(8);

__webpack_require__(12);

(function () {

  'use strict';

  // detect native touch action support

  var HAS_NATIVE_TA = typeof document.head.style.touchAction === 'string';
  var GESTURE_KEY = '__polymerGestures';
  var HANDLED_OBJ = '__polymerGesturesHandled';
  var TOUCH_ACTION = '__polymerGesturesTouchAction';
  // radius for tap and track
  var TAP_DISTANCE = 25;
  var TRACK_DISTANCE = 5;
  // number of last N track positions to keep
  var TRACK_LENGTH = 2;

  // Disabling "mouse" handlers for 2500ms is enough
  var MOUSE_TIMEOUT = 2500;
  var MOUSE_EVENTS = ['mousedown', 'mousemove', 'mouseup', 'click'];
  // an array of bitmask values for mapping MouseEvent.which to MouseEvent.buttons
  var MOUSE_WHICH_TO_BUTTONS = [0, 1, 4, 2];
  var MOUSE_HAS_BUTTONS = function () {
    try {
      return new MouseEvent('test', { buttons: 1 }).buttons === 1;
    } catch (e) {
      return false;
    }
  }();

  /* eslint no-empty: ["error", { "allowEmptyCatch": true }] */
  // check for passive event listeners
  var SUPPORTS_PASSIVE = false;
  (function () {
    try {
      var opts = Object.defineProperty({}, 'passive', { get: function get() {
          SUPPORTS_PASSIVE = true;
        } });
      window.addEventListener('test', null, opts);
      window.removeEventListener('test', null, opts);
    } catch (e) {}
  })();

  // Check for touch-only devices
  var IS_TOUCH_ONLY = navigator.userAgent.match(/iP(?:[oa]d|hone)|Android/);

  var GestureRecognizer = function GestureRecognizer() {}; // eslint-disable-line no-unused-vars
  GestureRecognizer.prototype.reset = function () {};
  /** @type {function(MouseEvent) | undefined} */
  GestureRecognizer.prototype.mousedown;
  /** @type {(function(MouseEvent) | undefined)} */
  GestureRecognizer.prototype.mousemove;
  /** @type {(function(MouseEvent) | undefined)} */
  GestureRecognizer.prototype.mouseup;
  /** @type {(function(TouchEvent) | undefined)} */
  GestureRecognizer.prototype.touchstart;
  /** @type {(function(TouchEvent) | undefined)} */
  GestureRecognizer.prototype.touchmove;
  /** @type {(function(TouchEvent) | undefined)} */
  GestureRecognizer.prototype.touchend;
  /** @type {(function(MouseEvent) | undefined)} */
  GestureRecognizer.prototype.click;

  // touch will make synthetic mouse events
  // `preventDefault` on touchend will cancel them,
  // but this breaks `<input>` focus and link clicks
  // disable mouse handlers for MOUSE_TIMEOUT ms after
  // a touchend to ignore synthetic mouse events
  var mouseCanceller = function mouseCanceller(mouseEvent) {
    // Check for sourceCapabilities, used to distinguish synthetic events
    // if mouseEvent did not come from a device that fires touch events,
    // it was made by a real mouse and should be counted
    // http://wicg.github.io/InputDeviceCapabilities/#dom-inputdevicecapabilities-firestouchevents
    var sc = mouseEvent.sourceCapabilities;
    if (sc && !sc.firesTouchEvents) {
      return;
    }
    // skip synthetic mouse events
    mouseEvent[HANDLED_OBJ] = { skip: true };
    // disable "ghost clicks"
    if (mouseEvent.type === 'click') {
      var path = mouseEvent.composedPath && mouseEvent.composedPath();
      if (path) {
        for (var i = 0; i < path.length; i++) {
          if (path[i] === POINTERSTATE.mouse.target) {
            return;
          }
        }
      }
      mouseEvent.preventDefault();
      mouseEvent.stopPropagation();
    }
  };

  /**
   * @param {boolean=} setup True to add, false to remove.
   */
  function setupTeardownMouseCanceller(setup) {
    var events = IS_TOUCH_ONLY ? ['click'] : MOUSE_EVENTS;
    for (var i = 0, en; i < events.length; i++) {
      en = events[i];
      if (setup) {
        document.addEventListener(en, mouseCanceller, true);
      } else {
        document.removeEventListener(en, mouseCanceller, true);
      }
    }
  }

  function ignoreMouse(e) {
    if (!POINTERSTATE.mouse.mouseIgnoreJob) {
      setupTeardownMouseCanceller(true);
    }
    var unset = function unset() {
      setupTeardownMouseCanceller();
      POINTERSTATE.mouse.target = null;
      POINTERSTATE.mouse.mouseIgnoreJob = null;
    };
    POINTERSTATE.mouse.target = e.composedPath()[0];
    POINTERSTATE.mouse.mouseIgnoreJob = Polymer.Debouncer.debounce(POINTERSTATE.mouse.mouseIgnoreJob, Polymer.Async.timeOut.after(MOUSE_TIMEOUT), unset);
  }

  /**
   * @param {MouseEvent} ev event to test for left mouse button down
   * @return {boolean} has left mouse button down
   */
  function hasLeftMouseButton(ev) {
    var type = ev.type;
    // exit early if the event is not a mouse event
    if (MOUSE_EVENTS.indexOf(type) === -1) {
      return false;
    }
    // ev.button is not reliable for mousemove (0 is overloaded as both left button and no buttons)
    // instead we use ev.buttons (bitmask of buttons) or fall back to ev.which (deprecated, 0 for no buttons, 1 for left button)
    if (type === 'mousemove') {
      // allow undefined for testing events
      var buttons = ev.buttons === undefined ? 1 : ev.buttons;
      if (ev instanceof window.MouseEvent && !MOUSE_HAS_BUTTONS) {
        buttons = MOUSE_WHICH_TO_BUTTONS[ev.which] || 0;
      }
      // buttons is a bitmask, check that the left button bit is set (1)
      return Boolean(buttons & 1);
    } else {
      // allow undefined for testing events
      var button = ev.button === undefined ? 0 : ev.button;
      // ev.button is 0 in mousedown/mouseup/click for left button activation
      return button === 0;
    }
  }

  function isSyntheticClick(ev) {
    if (ev.type === 'click') {
      // ev.detail is 0 for HTMLElement.click in most browsers
      if (ev.detail === 0) {
        return true;
      }
      // in the worst case, check that the x/y position of the click is within
      // the bounding box of the target of the event
      // Thanks IE 10 >:(
      var t = Gestures._findOriginalTarget(ev);
      // make sure the target of the event is an element so we can use getBoundingClientRect,
      // if not, just assume it is a synthetic click
      if (!t.nodeType || /** @type {Element} */t.nodeType !== Node.ELEMENT_NODE) {
        return true;
      }
      var bcr = /** @type {Element} */t.getBoundingClientRect();
      // use page x/y to account for scrolling
      var x = ev.pageX,
          y = ev.pageY;
      // ev is a synthetic click if the position is outside the bounding box of the target
      return !(x >= bcr.left && x <= bcr.right && y >= bcr.top && y <= bcr.bottom);
    }
    return false;
  }

  var POINTERSTATE = {
    mouse: {
      target: null,
      mouseIgnoreJob: null
    },
    touch: {
      x: 0,
      y: 0,
      id: -1,
      scrollDecided: false
    }
  };

  function firstTouchAction(ev) {
    var ta = 'auto';
    var path = ev.composedPath && ev.composedPath();
    if (path) {
      for (var i = 0, n; i < path.length; i++) {
        n = path[i];
        if (n[TOUCH_ACTION]) {
          ta = n[TOUCH_ACTION];
          break;
        }
      }
    }
    return ta;
  }

  function trackDocument(stateObj, movefn, upfn) {
    stateObj.movefn = movefn;
    stateObj.upfn = upfn;
    document.addEventListener('mousemove', movefn);
    document.addEventListener('mouseup', upfn);
  }

  function untrackDocument(stateObj) {
    document.removeEventListener('mousemove', stateObj.movefn);
    document.removeEventListener('mouseup', stateObj.upfn);
    stateObj.movefn = null;
    stateObj.upfn = null;
  }

  // use a document-wide touchend listener to start the ghost-click prevention mechanism
  // Use passive event listeners, if supported, to not affect scrolling performance
  document.addEventListener('touchend', ignoreMouse, SUPPORTS_PASSIVE ? { passive: true } : false);

  /**
   * Module for adding listeners to a node for the following normalized
   * cross-platform "gesture" events:
   * - `down` - mouse or touch went down
   * - `up` - mouse or touch went up
   * - `tap` - mouse click or finger tap
   * - `track` - mouse drag or touch move
   *
   * @namespace
   * @memberof Polymer
   * @summary Module for adding cross-platform gesture event listeners.
   */
  var Gestures = {
    gestures: {},
    recognizers: [],

    /**
     * Finds the element rendered on the screen at the provided coordinates.
     *
     * Similar to `document.elementFromPoint`, but pierces through
     * shadow roots.
     *
     * @memberof Polymer.Gestures
     * @param {number} x Horizontal pixel coordinate
     * @param {number} y Vertical pixel coordinate
     * @return {Element} Returns the deepest shadowRoot inclusive element
     * found at the screen position given.
     */
    deepTargetFind: function deepTargetFind(x, y) {
      var node = document.elementFromPoint(x, y);
      var next = node;
      // this code path is only taken when native ShadowDOM is used
      // if there is a shadowroot, it may have a node at x/y
      // if there is not a shadowroot, exit the loop
      while (next && next.shadowRoot && !window.ShadyDOM) {
        // if there is a node at x/y in the shadowroot, look deeper
        var oldNext = next;
        next = next.shadowRoot.elementFromPoint(x, y);
        // on Safari, elementFromPoint may return the shadowRoot host
        if (oldNext === next) {
          break;
        }
        if (next) {
          node = next;
        }
      }
      return node;
    },
    /**
     * a cheaper check than ev.composedPath()[0];
     *
     * @private
     * @param {Event} ev Event.
     * @return {EventTarget} Returns the event target.
     */
    _findOriginalTarget: function _findOriginalTarget(ev) {
      // shadowdom
      if (ev.composedPath) {
        return (/** @type {EventTarget} */ev.composedPath()[0]
        );
      }
      // shadydom
      return ev.target;
    },

    /**
     * @private
     * @param {Event} ev Event.
     */
    _handleNative: function _handleNative(ev) {
      var handled = void 0;
      var type = ev.type;
      var node = ev.currentTarget;
      var gobj = node[GESTURE_KEY];
      if (!gobj) {
        return;
      }
      var gs = gobj[type];
      if (!gs) {
        return;
      }
      if (!ev[HANDLED_OBJ]) {
        ev[HANDLED_OBJ] = {};
        if (type.slice(0, 5) === 'touch') {
          ev = /** @type {TouchEvent} */ev; // eslint-disable-line no-self-assign
          var t = ev.changedTouches[0];
          if (type === 'touchstart') {
            // only handle the first finger
            if (ev.touches.length === 1) {
              POINTERSTATE.touch.id = t.identifier;
            }
          }
          if (POINTERSTATE.touch.id !== t.identifier) {
            return;
          }
          if (!HAS_NATIVE_TA) {
            if (type === 'touchstart' || type === 'touchmove') {
              Gestures._handleTouchAction(ev);
            }
          }
        }
      }
      handled = ev[HANDLED_OBJ];
      // used to ignore synthetic mouse events
      if (handled.skip) {
        return;
      }
      var recognizers = Gestures.recognizers;
      // reset recognizer state
      for (var i = 0, r; i < recognizers.length; i++) {
        r = recognizers[i];
        if (gs[r.name] && !handled[r.name]) {
          if (r.flow && r.flow.start.indexOf(ev.type) > -1 && r.reset) {
            r.reset();
          }
        }
      }
      // enforce gesture recognizer order
      for (var _i = 0, _r; _i < recognizers.length; _i++) {
        _r = recognizers[_i];
        if (gs[_r.name] && !handled[_r.name]) {
          handled[_r.name] = true;
          _r[type](ev);
        }
      }
    },

    /**
     * @private
     * @param {TouchEvent} ev Event.
     */
    _handleTouchAction: function _handleTouchAction(ev) {
      var t = ev.changedTouches[0];
      var type = ev.type;
      if (type === 'touchstart') {
        POINTERSTATE.touch.x = t.clientX;
        POINTERSTATE.touch.y = t.clientY;
        POINTERSTATE.touch.scrollDecided = false;
      } else if (type === 'touchmove') {
        if (POINTERSTATE.touch.scrollDecided) {
          return;
        }
        POINTERSTATE.touch.scrollDecided = true;
        var ta = firstTouchAction(ev);
        var prevent = false;
        var dx = Math.abs(POINTERSTATE.touch.x - t.clientX);
        var dy = Math.abs(POINTERSTATE.touch.y - t.clientY);
        if (!ev.cancelable) {
          // scrolling is happening
        } else if (ta === 'none') {
          prevent = true;
        } else if (ta === 'pan-x') {
          prevent = dy > dx;
        } else if (ta === 'pan-y') {
          prevent = dx > dy;
        }
        if (prevent) {
          ev.preventDefault();
        } else {
          Gestures.prevent('track');
        }
      }
    },

    /**
     * Adds an event listener to a node for the given gesture type.
     *
     * @memberof Polymer.Gestures
     * @param {Node} node Node to add listener on
     * @param {string} evType Gesture type: `down`, `up`, `track`, or `tap`
     * @param {Function} handler Event listener function to call
     * @return {boolean} Returns true if a gesture event listener was added.
     * @this {Gestures}
     */
    addListener: function addListener(node, evType, handler) {
      if (this.gestures[evType]) {
        this._add(node, evType, handler);
        return true;
      }
      return false;
    },

    /**
     * Removes an event listener from a node for the given gesture type.
     *
     * @memberof Polymer.Gestures
     * @param {Node} node Node to remove listener from
     * @param {string} evType Gesture type: `down`, `up`, `track`, or `tap`
     * @param {Function} handler Event listener function previously passed to
     *  `addListener`.
     * @return {boolean} Returns true if a gesture event listener was removed.
     * @this {Gestures}
     */
    removeListener: function removeListener(node, evType, handler) {
      if (this.gestures[evType]) {
        this._remove(node, evType, handler);
        return true;
      }
      return false;
    },

    /**
     * automate the event listeners for the native events
     *
     * @private
     * @param {HTMLElement} node Node on which to add the event.
     * @param {string} evType Event type to add.
     * @param {function(Event?)} handler Event handler function.
     * @this {Gestures}
     */
    _add: function _add(node, evType, handler) {
      var recognizer = this.gestures[evType];
      var deps = recognizer.deps;
      var name = recognizer.name;
      var gobj = node[GESTURE_KEY];
      if (!gobj) {
        node[GESTURE_KEY] = gobj = {};
      }
      for (var i = 0, dep, gd; i < deps.length; i++) {
        dep = deps[i];
        // don't add mouse handlers on iOS because they cause gray selection overlays
        if (IS_TOUCH_ONLY && MOUSE_EVENTS.indexOf(dep) > -1 && dep !== 'click') {
          continue;
        }
        gd = gobj[dep];
        if (!gd) {
          gobj[dep] = gd = { _count: 0 };
        }
        if (gd._count === 0) {
          node.addEventListener(dep, this._handleNative);
        }
        gd[name] = (gd[name] || 0) + 1;
        gd._count = (gd._count || 0) + 1;
      }
      node.addEventListener(evType, handler);
      if (recognizer.touchAction) {
        this.setTouchAction(node, recognizer.touchAction);
      }
    },

    /**
     * automate event listener removal for native events
     *
     * @private
     * @param {HTMLElement} node Node on which to remove the event.
     * @param {string} evType Event type to remove.
     * @param {function(Event?)} handler Event handler function.
     * @this {Gestures}
     */
    _remove: function _remove(node, evType, handler) {
      var recognizer = this.gestures[evType];
      var deps = recognizer.deps;
      var name = recognizer.name;
      var gobj = node[GESTURE_KEY];
      if (gobj) {
        for (var i = 0, dep, gd; i < deps.length; i++) {
          dep = deps[i];
          gd = gobj[dep];
          if (gd && gd[name]) {
            gd[name] = (gd[name] || 1) - 1;
            gd._count = (gd._count || 1) - 1;
            if (gd._count === 0) {
              node.removeEventListener(dep, this._handleNative);
            }
          }
        }
      }
      node.removeEventListener(evType, handler);
    },

    /**
     * Registers a new gesture event recognizer for adding new custom
     * gesture event types.
     *
     * @memberof Polymer.Gestures
     * @param {GestureRecognizer} recog Gesture recognizer descriptor
     * @this {Gestures}
     */
    register: function register(recog) {
      this.recognizers.push(recog);
      for (var i = 0; i < recog.emits.length; i++) {
        this.gestures[recog.emits[i]] = recog;
      }
    },

    /**
     * @private
     * @param {string} evName Event name.
     * @return {Object} Returns the gesture for the given event name.
     * @this {Gestures}
     */
    _findRecognizerByEvent: function _findRecognizerByEvent(evName) {
      for (var i = 0, r; i < this.recognizers.length; i++) {
        r = this.recognizers[i];
        for (var j = 0, n; j < r.emits.length; j++) {
          n = r.emits[j];
          if (n === evName) {
            return r;
          }
        }
      }
      return null;
    },

    /**
     * Sets scrolling direction on node.
     *
     * This value is checked on first move, thus it should be called prior to
     * adding event listeners.
     *
     * @memberof Polymer.Gestures
     * @param {Element} node Node to set touch action setting on
     * @param {string} value Touch action value
     */
    setTouchAction: function setTouchAction(node, value) {
      if (HAS_NATIVE_TA) {
        node.style.touchAction = value;
      }
      node[TOUCH_ACTION] = value;
    },

    /**
     * Dispatches an event on the `target` element of `type` with the given
     * `detail`.
     * @private
     * @param {EventTarget} target The element on which to fire an event.
     * @param {string} type The type of event to fire.
     * @param {Object=} detail The detail object to populate on the event.
     */
    _fire: function _fire(target, type, detail) {
      var ev = new Event(type, { bubbles: true, cancelable: true, composed: true });
      ev.detail = detail;
      target.dispatchEvent(ev);
      // forward `preventDefault` in a clean way
      if (ev.defaultPrevented) {
        var preventer = detail.preventer || detail.sourceEvent;
        if (preventer && preventer.preventDefault) {
          preventer.preventDefault();
        }
      }
    },

    /**
     * Prevents the dispatch and default action of the given event name.
     *
     * @memberof Polymer.Gestures
     * @param {string} evName Event name.
     * @this {Gestures}
     */
    prevent: function prevent(evName) {
      var recognizer = this._findRecognizerByEvent(evName);
      if (recognizer.info) {
        recognizer.info.prevent = true;
      }
    },

    /**
     * Reset the 2500ms timeout on processing mouse input after detecting touch input.
     *
     * Touch inputs create synthesized mouse inputs anywhere from 0 to 2000ms after the touch.
     * This method should only be called during testing with simulated touch inputs.
     * Calling this method in production may cause duplicate taps or other Gestures.
     *
     * @memberof Polymer.Gestures
     */
    resetMouseCanceller: function resetMouseCanceller() {
      if (POINTERSTATE.mouse.mouseIgnoreJob) {
        POINTERSTATE.mouse.mouseIgnoreJob.flush();
      }
    }
  };

  /* eslint-disable valid-jsdoc */

  Gestures.register({
    name: 'downup',
    deps: ['mousedown', 'touchstart', 'touchend'],
    flow: {
      start: ['mousedown', 'touchstart'],
      end: ['mouseup', 'touchend']
    },
    emits: ['down', 'up'],

    info: {
      movefn: null,
      upfn: null
    },

    /** @this {GestureRecognizer} */
    reset: function reset() {
      untrackDocument(this.info);
    },

    /**
     * @this {GestureRecognizer}
     * @param {MouseEvent} e
     */
    mousedown: function mousedown(e) {
      if (!hasLeftMouseButton(e)) {
        return;
      }
      var t = Gestures._findOriginalTarget(e);
      var self = this;
      var movefn = function movefn(e) {
        if (!hasLeftMouseButton(e)) {
          self._fire('up', t, e);
          untrackDocument(self.info);
        }
      };
      var upfn = function upfn(e) {
        if (hasLeftMouseButton(e)) {
          self._fire('up', t, e);
        }
        untrackDocument(self.info);
      };
      trackDocument(this.info, movefn, upfn);
      this._fire('down', t, e);
    },
    /**
     * @this {GestureRecognizer}
     * @param {TouchEvent} e
     */
    touchstart: function touchstart(e) {
      this._fire('down', Gestures._findOriginalTarget(e), e.changedTouches[0], e);
    },
    /**
     * @this {GestureRecognizer}
     * @param {TouchEvent} e
     */
    touchend: function touchend(e) {
      this._fire('up', Gestures._findOriginalTarget(e), e.changedTouches[0], e);
    },
    /**
     * @param {string} type
     * @param {EventTarget} target
     * @param {Event} event
     * @param {Function} preventer
     */
    _fire: function _fire(type, target, event, preventer) {
      Gestures._fire(target, type, {
        x: event.clientX,
        y: event.clientY,
        sourceEvent: event,
        preventer: preventer,
        prevent: function prevent(e) {
          return Gestures.prevent(e);
        }
      });
    }
  });

  Gestures.register({
    name: 'track',
    touchAction: 'none',
    deps: ['mousedown', 'touchstart', 'touchmove', 'touchend'],
    flow: {
      start: ['mousedown', 'touchstart'],
      end: ['mouseup', 'touchend']
    },
    emits: ['track'],

    info: {
      x: 0,
      y: 0,
      state: 'start',
      started: false,
      moves: [],
      /** @this {GestureRecognizer} */
      addMove: function addMove(move) {
        if (this.moves.length > TRACK_LENGTH) {
          this.moves.shift();
        }
        this.moves.push(move);
      },
      movefn: null,
      upfn: null,
      prevent: false
    },

    /** @this {GestureRecognizer} */
    reset: function reset() {
      this.info.state = 'start';
      this.info.started = false;
      this.info.moves = [];
      this.info.x = 0;
      this.info.y = 0;
      this.info.prevent = false;
      untrackDocument(this.info);
    },

    /**
     * @this {GestureRecognizer}
     * @param {number} x
     * @param {number} y
     * @return {boolean}
     */
    hasMovedEnough: function hasMovedEnough(x, y) {
      if (this.info.prevent) {
        return false;
      }
      if (this.info.started) {
        return true;
      }
      var dx = Math.abs(this.info.x - x);
      var dy = Math.abs(this.info.y - y);
      return dx >= TRACK_DISTANCE || dy >= TRACK_DISTANCE;
    },
    /**
     * @this {GestureRecognizer}
     * @param {MouseEvent} e
     */
    mousedown: function mousedown(e) {
      if (!hasLeftMouseButton(e)) {
        return;
      }
      var t = Gestures._findOriginalTarget(e);
      var self = this;
      var movefn = function movefn(e) {
        var x = e.clientX,
            y = e.clientY;
        if (self.hasMovedEnough(x, y)) {
          // first move is 'start', subsequent moves are 'move', mouseup is 'end'
          self.info.state = self.info.started ? e.type === 'mouseup' ? 'end' : 'track' : 'start';
          if (self.info.state === 'start') {
            // if and only if tracking, always prevent tap
            Gestures.prevent('tap');
          }
          self.info.addMove({ x: x, y: y });
          if (!hasLeftMouseButton(e)) {
            // always _fire "end"
            self.info.state = 'end';
            untrackDocument(self.info);
          }
          self._fire(t, e);
          self.info.started = true;
        }
      };
      var upfn = function upfn(e) {
        if (self.info.started) {
          movefn(e);
        }

        // remove the temporary listeners
        untrackDocument(self.info);
      };
      // add temporary document listeners as mouse retargets
      trackDocument(this.info, movefn, upfn);
      this.info.x = e.clientX;
      this.info.y = e.clientY;
    },
    /**
     * @this {GestureRecognizer}
     * @param {TouchEvent} e
     */
    touchstart: function touchstart(e) {
      var ct = e.changedTouches[0];
      this.info.x = ct.clientX;
      this.info.y = ct.clientY;
    },
    /**
     * @this {GestureRecognizer}
     * @param {TouchEvent} e
     */
    touchmove: function touchmove(e) {
      var t = Gestures._findOriginalTarget(e);
      var ct = e.changedTouches[0];
      var x = ct.clientX,
          y = ct.clientY;
      if (this.hasMovedEnough(x, y)) {
        if (this.info.state === 'start') {
          // if and only if tracking, always prevent tap
          Gestures.prevent('tap');
        }
        this.info.addMove({ x: x, y: y });
        this._fire(t, ct);
        this.info.state = 'track';
        this.info.started = true;
      }
    },
    /**
     * @this {GestureRecognizer}
     * @param {TouchEvent} e
     */
    touchend: function touchend(e) {
      var t = Gestures._findOriginalTarget(e);
      var ct = e.changedTouches[0];
      // only trackend if track was started and not aborted
      if (this.info.started) {
        // reset started state on up
        this.info.state = 'end';
        this.info.addMove({ x: ct.clientX, y: ct.clientY });
        this._fire(t, ct, e);
      }
    },

    /**
     * @this {GestureRecognizer}
     * @param {EventTarget} target
     * @param {Touch} touch
     */
    _fire: function _fire(target, touch) {
      var secondlast = this.info.moves[this.info.moves.length - 2];
      var lastmove = this.info.moves[this.info.moves.length - 1];
      var dx = lastmove.x - this.info.x;
      var dy = lastmove.y - this.info.y;
      var ddx = void 0,
          ddy = 0;
      if (secondlast) {
        ddx = lastmove.x - secondlast.x;
        ddy = lastmove.y - secondlast.y;
      }
      Gestures._fire(target, 'track', {
        state: this.info.state,
        x: touch.clientX,
        y: touch.clientY,
        dx: dx,
        dy: dy,
        ddx: ddx,
        ddy: ddy,
        sourceEvent: touch,
        hover: function hover() {
          return Gestures.deepTargetFind(touch.clientX, touch.clientY);
        }
      });
    }

  });

  Gestures.register({
    name: 'tap',
    deps: ['mousedown', 'click', 'touchstart', 'touchend'],
    flow: {
      start: ['mousedown', 'touchstart'],
      end: ['click', 'touchend']
    },
    emits: ['tap'],
    info: {
      x: NaN,
      y: NaN,
      prevent: false
    },
    /** @this {GestureRecognizer} */
    reset: function reset() {
      this.info.x = NaN;
      this.info.y = NaN;
      this.info.prevent = false;
    },
    /** @this {GestureRecognizer} */
    save: function save(e) {
      this.info.x = e.clientX;
      this.info.y = e.clientY;
    },
    /**
     * @this {GestureRecognizer}
     * @param {MouseEvent} e
     */
    mousedown: function mousedown(e) {
      if (hasLeftMouseButton(e)) {
        this.save(e);
      }
    },
    /**
     * @this {GestureRecognizer}
     * @param {MouseEvent} e
     */
    click: function click(e) {
      if (hasLeftMouseButton(e)) {
        this.forward(e);
      }
    },
    /**
     * @this {GestureRecognizer}
     * @param {TouchEvent} e
     */
    touchstart: function touchstart(e) {
      this.save(e.changedTouches[0], e);
    },
    /**
     * @this {GestureRecognizer}
     * @param {TouchEvent} e
     */
    touchend: function touchend(e) {
      this.forward(e.changedTouches[0], e);
    },
    /**
     * @this {GestureRecognizer}
     * @param {Event} e
     * @param {Function} preventer
     */
    forward: function forward(e, preventer) {
      var dx = Math.abs(e.clientX - this.info.x);
      var dy = Math.abs(e.clientY - this.info.y);
      var t = Gestures._findOriginalTarget(e);
      // dx,dy can be NaN if `click` has been simulated and there was no `down` for `start`
      if (isNaN(dx) || isNaN(dy) || dx <= TAP_DISTANCE && dy <= TAP_DISTANCE || isSyntheticClick(e)) {
        // prevent taps from being generated if an event has canceled them
        if (!this.info.prevent) {
          Gestures._fire(t, 'tap', {
            x: e.clientX,
            y: e.clientY,
            sourceEvent: e,
            preventer: preventer
          });
        }
      }
    }
  });

  /* eslint-enable valid-jsdoc */

  /** @deprecated */
  Gestures.findOriginalTarget = Gestures._findOriginalTarget;

  /** @deprecated */
  Gestures.add = Gestures.addListener;

  /** @deprecated */
  Gestures.remove = Gestures.removeListener;

  Polymer.Gestures = Gestures;
})();

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(1);

(function () {

  'use strict';

  // run a callback when HTMLImports are ready or immediately if
  // this api is not available.

  function whenImportsReady(cb) {
    if (window.HTMLImports) {
      HTMLImports.whenReady(cb);
    } else {
      cb();
    }
  }

  /**
   * Convenience method for importing an HTML document imperatively.
   *
   * This method creates a new `<link rel="import">` element with
   * the provided URL and appends it to the document to start loading.
   * In the `onload` callback, the `import` property of the `link`
   * element will contain the imported document contents.
   *
   * @memberof Polymer
   * @param {string} href URL to document to load.
   * @param {Function=} onload Callback to notify when an import successfully
   *   loaded.
   * @param {Function=} onerror Callback to notify when an import
   *   unsuccessfully loaded.
   * @param {boolean=} optAsync True if the import should be loaded `async`.
   *   Defaults to `false`.
   * @return {HTMLLinkElement} The link element for the URL to be loaded.
   */
  Polymer.importHref = function (href, onload, onerror, optAsync) {
    var link = /** @type {HTMLLinkElement} */
    document.head.querySelector('link[href="' + href + '"][import-href]');
    if (!link) {
      link = /** @type {HTMLLinkElement} */document.createElement('link');
      link.rel = 'import';
      link.href = href;
      link.setAttribute('import-href', '');
    }
    // always ensure link has `async` attribute if user specified one,
    // even if it was previously not async. This is considered less confusing.
    if (optAsync) {
      link.setAttribute('async', '');
    }
    // NOTE: the link may now be in 3 states: (1) pending insertion,
    // (2) inflight, (3) already laoded. In each case, we need to add
    // event listeners to process callbacks.
    var cleanup = function cleanup() {
      link.removeEventListener('load', loadListener);
      link.removeEventListener('error', errorListener);
    };
    var loadListener = function loadListener(event) {
      cleanup();
      // In case of a successful load, cache the load event on the link so
      // that it can be used to short-circuit this method in the future when
      // it is called with the same href param.
      link.__dynamicImportLoaded = true;
      if (onload) {
        whenImportsReady(function () {
          onload(event);
        });
      }
    };
    var errorListener = function errorListener(event) {
      cleanup();
      // In case of an error, remove the link from the document so that it
      // will be automatically created again the next time `importHref` is
      // called.
      if (link.parentNode) {
        link.parentNode.removeChild(link);
      }
      if (onerror) {
        whenImportsReady(function () {
          onerror(event);
        });
      }
    };
    link.addEventListener('load', loadListener);
    link.addEventListener('error', errorListener);
    if (link.parentNode == null) {
      document.head.appendChild(link);
      // if the link already loaded, dispatch a fake load event
      // so that listeners are called and get a proper event argument.
    } else if (link.__dynamicImportLoaded) {
      link.dispatchEvent(new Event('load'));
    }
    return link;
  };
})();

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(1);

(function () {

  'use strict';

  var scheduled = false;
  var beforeRenderQueue = [];
  var afterRenderQueue = [];

  function schedule() {
    scheduled = true;
    // before next render
    requestAnimationFrame(function () {
      scheduled = false;
      flushQueue(beforeRenderQueue);
      // after the render
      setTimeout(function () {
        runQueue(afterRenderQueue);
      });
    });
  }

  function flushQueue(queue) {
    while (queue.length) {
      callMethod(queue.shift());
    }
  }

  function runQueue(queue) {
    for (var i = 0, l = queue.length; i < l; i++) {
      callMethod(queue.shift());
    }
  }

  function callMethod(info) {
    var context = info[0];
    var callback = info[1];
    var args = info[2];
    try {
      callback.apply(context, args);
    } catch (e) {
      setTimeout(function () {
        throw e;
      });
    }
  }

  function flush() {
    while (beforeRenderQueue.length || afterRenderQueue.length) {
      flushQueue(beforeRenderQueue);
      flushQueue(afterRenderQueue);
    }
    scheduled = false;
  }

  /**
   * Module for scheduling flushable pre-render and post-render tasks.
   *
   * @namespace
   * @memberof Polymer
   * @summary Module for scheduling flushable pre-render and post-render tasks.
   */
  Polymer.RenderStatus = {

    /**
     * Enqueues a callback which will be run before the next render, at
     * `requestAnimationFrame` timing.
     *
     * This method is useful for enqueuing work that requires DOM measurement,
     * since measurement may not be reliable in custom element callbacks before
     * the first render, as well as for batching measurement tasks in general.
     *
     * Tasks in this queue may be flushed by calling `Polymer.RenderStatus.flush()`.
     *
     * @memberof Polymer.RenderStatus
     * @param {*} context Context object the callback function will be bound to
     * @param {function()} callback Callback function
     * @param {Array} args An array of arguments to call the callback function with
     */
    beforeNextRender: function beforeNextRender(context, callback, args) {
      if (!scheduled) {
        schedule();
      }
      beforeRenderQueue.push([context, callback, args]);
    },

    /**
     * Enqueues a callback which will be run after the next render, equivalent
     * to one task (`setTimeout`) after the next `requestAnimationFrame`.
     *
     * This method is useful for tuning the first-render performance of an
     * element or application by deferring non-critical work until after the
     * first paint.  Typical non-render-critical work may include adding UI
     * event listeners and aria attributes.
     *
     * @memberof Polymer.RenderStatus
     * @param {*} context Context object the callback function will be bound to
     * @param {function()} callback Callback function
     * @param {Array} args An array of arguments to call the callback function with
     */
    afterNextRender: function afterNextRender(context, callback, args) {
      if (!scheduled) {
        schedule();
      }
      afterRenderQueue.push([context, callback, args]);
    },

    /**
     * Flushes all `beforeNextRender` tasks, followed by all `afterNextRender`
     * tasks.
     *
     * @memberof Polymer.RenderStatus
     */
    flush: flush

  };
})();

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


(function () {
  'use strict';

  // unresolved

  function resolve() {
    document.body.removeAttribute('unresolved');
  }

  if (window.WebComponents) {
    window.addEventListener('WebComponentsReady', resolve);
  } else {
    if (document.readyState === 'interactive' || document.readyState === 'complete') {
      resolve();
    } else {
      window.addEventListener('DOMContentLoaded', resolve);
    }
  }
})();

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

__webpack_require__(1);

__webpack_require__(20);

__webpack_require__(52);

__webpack_require__(13);

(function () {
  'use strict';

  var p = Element.prototype;
  /**
   * @const {function(this:Element, string): boolean}
   */
  var normalizedMatchesSelector = p.matches || p.matchesSelector || p.mozMatchesSelector || p.msMatchesSelector || p.oMatchesSelector || p.webkitMatchesSelector;

  /**
   * Cross-platform `element.matches` shim.
   *
   * @function matchesSelector
   * @memberof Polymer.dom
   * @param {!Element} node Node to check selector against
   * @param {string} selector Selector to match
   * @return {boolean} True if node matched selector
   */
  var matchesSelector = function matchesSelector(node, selector) {
    return normalizedMatchesSelector.call(node, selector);
  };

  /**
   * Node API wrapper class returned from `Polymer.dom.(target)` when
   * `target` is a `Node`.
   */

  var DomApi = function () {

    /**
     * @param {Node} node Node for which to create a Polymer.dom helper object.
     */
    function DomApi(node) {
      _classCallCheck(this, DomApi);

      this.node = node;
    }

    /**
     * Returns an instance of `Polymer.FlattenedNodesObserver` that
     * listens for node changes on this element.
     *
     * @param {Function} callback Called when direct or distributed children
     *   of this element changes
     * @return {Polymer.FlattenedNodesObserver} Observer instance
     */


    _createClass(DomApi, [{
      key: 'observeNodes',
      value: function observeNodes(callback) {
        return new Polymer.FlattenedNodesObserver(this.node, callback);
      }

      /**
       * Disconnects an observer previously created via `observeNodes`
       *
       * @param {Polymer.FlattenedNodesObserver} observerHandle Observer instance
       *   to disconnect.
       */

    }, {
      key: 'unobserveNodes',
      value: function unobserveNodes(observerHandle) {
        observerHandle.disconnect();
      }

      /**
       * Provided as a backwards-compatible API only.  This method does nothing.
       */

    }, {
      key: 'notifyObserver',
      value: function notifyObserver() {}

      /**
       * Returns true if the provided node is contained with this element's
       * light-DOM children or shadow root, including any nested shadow roots
       * of children therein.
       *
       * @param {Node} node Node to test
       * @return {boolean} Returns true if the given `node` is contained within
       *   this element's light or shadow DOM.
       */

    }, {
      key: 'deepContains',
      value: function deepContains(node) {
        if (this.node.contains(node)) {
          return true;
        }
        var n = node;
        var doc = node.ownerDocument;
        // walk from node to `this` or `document`
        while (n && n !== doc && n !== this.node) {
          // use logical parentnode, or native ShadowRoot host
          n = n.parentNode || n.host;
        }
        return n === this.node;
      }

      /**
       * Returns the root node of this node.  Equivalent to `getRoodNode()`.
       *
       * @return {Node} Top most element in the dom tree in which the node
       * exists. If the node is connected to a document this is either a
       * shadowRoot or the document; otherwise, it may be the node
       * itself or a node or document fragment containing it.
       */

    }, {
      key: 'getOwnerRoot',
      value: function getOwnerRoot() {
        return this.node.getRootNode();
      }

      /**
       * For slot elements, returns the nodes assigned to the slot; otherwise
       * an empty array. It is equivalent to `<slot>.addignedNodes({flatten:true})`.
       *
       * @return {Array<Node>} Array of assigned nodes
       */

    }, {
      key: 'getDistributedNodes',
      value: function getDistributedNodes() {
        return this.node.localName === 'slot' ? this.node.assignedNodes({ flatten: true }) : [];
      }

      /**
       * Returns an array of all slots this element was distributed to.
       *
       * @return {Array<HTMLSlotElement>} Description
       */

    }, {
      key: 'getDestinationInsertionPoints',
      value: function getDestinationInsertionPoints() {
        var ip$ = [];
        var n = this.node.assignedSlot;
        while (n) {
          ip$.push(n);
          n = n.assignedSlot;
        }
        return ip$;
      }

      /**
       * Calls `importNode` on the `ownerDocument` for this node.
       *
       * @param {Node} node Node to import
       * @param {boolean} deep True if the node should be cloned deeply during
       *   import
       * @return {Node} Clone of given node imported to this owner document
       */

    }, {
      key: 'importNode',
      value: function importNode(node, deep) {
        var doc = this.node instanceof Document ? this.node : this.node.ownerDocument;
        return doc.importNode(node, deep);
      }

      /**
       * @return {Array} Returns a flattened list of all child nodes and nodes assigned
       * to child slots.
       */

    }, {
      key: 'getEffectiveChildNodes',
      value: function getEffectiveChildNodes() {
        return Polymer.FlattenedNodesObserver.getFlattenedNodes(this.node);
      }

      /**
       * Returns a filtered list of flattened child elements for this element based
       * on the given selector.
       *
       * @param {string} selector Selector to filter nodes against
       * @return {Array<HTMLElement>} List of flattened child elements
       */

    }, {
      key: 'queryDistributedElements',
      value: function queryDistributedElements(selector) {
        var c$ = this.getEffectiveChildNodes();
        var list = [];
        for (var i = 0, l = c$.length, c; i < l && (c = c$[i]); i++) {
          if (c.nodeType === Node.ELEMENT_NODE && matchesSelector(c, selector)) {
            list.push(c);
          }
        }
        return list;
      }

      /**
       * For shadow roots, returns the currently focused element within this
       * shadow root.
       *
       * @return {Node|undefined} Currently focused element
       */

    }, {
      key: 'activeElement',
      get: function get() {
        var node = this.node;
        return node._activeElement !== undefined ? node._activeElement : node.activeElement;
      }
    }]);

    return DomApi;
  }();

  function forwardMethods(proto, methods) {
    var _loop = function _loop(i) {
      var method = methods[i];
      proto[method] = /** @this {DomApi} */function () {
        return this.node[method].apply(this.node, arguments);
      };
    };

    for (var i = 0; i < methods.length; i++) {
      _loop(i);
    }
  }

  function forwardReadOnlyProperties(proto, properties) {
    var _loop2 = function _loop2(i) {
      var name = properties[i];
      Object.defineProperty(proto, name, {
        get: function get() {
          return (/** @type {DomApi} */this.node[name]
          );
        },
        configurable: true
      });
    };

    for (var i = 0; i < properties.length; i++) {
      _loop2(i);
    }
  }

  function forwardProperties(proto, properties) {
    var _loop3 = function _loop3(i) {
      var name = properties[i];
      Object.defineProperty(proto, name, {
        get: function get() {
          return (/** @type {DomApi} */this.node[name]
          );
        },
        set: function set(value) {
          /** @type {DomApi} */this.node[name] = value;
        },
        configurable: true
      });
    };

    for (var i = 0; i < properties.length; i++) {
      _loop3(i);
    }
  }

  forwardMethods(DomApi.prototype, ['cloneNode', 'appendChild', 'insertBefore', 'removeChild', 'replaceChild', 'setAttribute', 'removeAttribute', 'querySelector', 'querySelectorAll']);

  forwardReadOnlyProperties(DomApi.prototype, ['parentNode', 'firstChild', 'lastChild', 'nextSibling', 'previousSibling', 'firstElementChild', 'lastElementChild', 'nextElementSibling', 'previousElementSibling', 'childNodes', 'children', 'classList']);

  forwardProperties(DomApi.prototype, ['textContent', 'innerHTML']);

  /**
   * Event API wrapper class returned from `Polymer.dom.(target)` when
   * `target` is an `Event`.
   */

  var EventApi = function () {
    function EventApi(event) {
      _classCallCheck(this, EventApi);

      this.event = event;
    }

    /**
     * Returns the first node on the `composedPath` of this event.
     *
     * @return {Node} The node this event was dispatched to
     */


    _createClass(EventApi, [{
      key: 'rootTarget',
      get: function get() {
        return this.event.composedPath()[0];
      }

      /**
       * Returns the local (re-targeted) target for this event.
       *
       * @return {Node} The local (re-targeted) target for this event.
       */

    }, {
      key: 'localTarget',
      get: function get() {
        return this.event.target;
      }

      /**
       * Returns the `composedPath` for this event.
       */

    }, {
      key: 'path',
      get: function get() {
        return this.event.composedPath();
      }
    }]);

    return EventApi;
  }();

  Polymer.DomApi = DomApi;

  /**
   * Legacy DOM and Event manipulation API wrapper factory used to abstract
   * differences between native Shadow DOM and "Shady DOM" when polyfilling on
   * older browsers.
   *
   * Note that in Polymer 2.x use of `Polymer.dom` is no longer required and
   * in the majority of cases simply facades directly to the standard native
   * API.
   *
   * @namespace
   * @summary Legacy DOM and Event manipulation API wrapper factory used to
   * abstract differences between native Shadow DOM and "Shady DOM."
   * @memberof Polymer
   * @param {!Node|Event} obj Node or event to operate on
   * @return {DomApi|EventApi} Wrapper providing either node API or event API
   */
  Polymer.dom = function (obj) {
    obj = obj || document;
    if (!obj.__domApi) {
      var helper = void 0;
      if (obj instanceof Event) {
        helper = new EventApi(obj);
      } else {
        helper = new DomApi(obj);
      }
      obj.__domApi = helper;
    }
    return obj.__domApi;
  };

  Polymer.dom.matchesSelector = matchesSelector;

  /**
   * Forces several classes of asynchronously queued tasks to flush:
   * - Debouncers added via `Polymer.enqueueDebouncer`
   * - ShadyDOM distribution
   *
   * This method facades to `Polymer.flush`.
   *
   * @memberof Polymer.dom
   */
  Polymer.dom.flush = Polymer.flush;

  /**
   * Adds a `Polymer.Debouncer` to a list of globally flushable tasks.
   *
   * This method facades to `Polymer.enqueueDebouncer`.
   *
   * @memberof Polymer.dom
   * @param {Polymer.Debouncer} debouncer Debouncer to enqueue
   */
  Polymer.dom.addDebouncer = Polymer.enqueueDebouncer;
})();

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

__webpack_require__(1);

__webpack_require__(24);

__webpack_require__(8);

(function () {
  'use strict';

  /**
   * Returns true if `node` is a slot element
   * @param {HTMLElement} node Node to test.
   * @return {boolean} Returns true if the given `node` is a slot
   * @private
   */

  function isSlot(node) {
    return node.localName === 'slot';
  }

  /**
   * Class that listens for changes (additions or removals) to
   * "flattened nodes" on a given `node`. The list of flattened nodes consists
   * of a node's children and, for any children that are `<slot>` elements,
   * the expanded flattened list of `assignedNodes`.
   * For example, if the observed node has children `<a></a><slot></slot><b></b>`
   * and the `<slot>` has one `<div>` assigned to it, then the flattened
   * nodes list is `<a></a><div></div><b></b>`. If the `<slot>` has other
   * `<slot>` elements assigned to it, these are flattened as well.
   *
   * The provided `callback` is called whenever any change to this list
   * of flattened nodes occurs, where an addition or removal of a node is
   * considered a change. The `callback` is called with one argument, an object
   * containing an array of any `addedNodes` and `removedNodes`.
   *
   * Note: the callback is called asynchronous to any changes
   * at a microtask checkpoint. This is because observation is performed using
   * `MutationObserver` and the `<slot>` element's `slotchange` event which
   * are asynchronous.
   *
   * @memberof Polymer
   * @summary Class that listens for changes (additions or removals) to
   * "flattened nodes" on a given `node`.
   */

  var FlattenedNodesObserver = function () {
    _createClass(FlattenedNodesObserver, null, [{
      key: 'getFlattenedNodes',


      /**
       * Returns the list of flattened nodes for the given `node`.
       * This list consists of a node's children and, for any children
       * that are `<slot>` elements, the expanded flattened list of `assignedNodes`.
       * For example, if the observed node has children `<a></a><slot></slot><b></b>`
       * and the `<slot>` has one `<div>` assigned to it, then the flattened
       * nodes list is `<a></a><div></div><b></b>`. If the `<slot>` has other
       * `<slot>` elements assigned to it, these are flattened as well.
       *
       * @param {HTMLElement|HTMLSlotElement} node The node for which to return the list of flattened nodes.
       * @return {Array} The list of flattened nodes for the given `node`.
      */
      value: function getFlattenedNodes(node) {
        if (isSlot(node)) {
          return (/** @type {HTMLSlotElement} */node.assignedNodes({ flatten: true })
          );
        } else {
          return Array.from(node.childNodes).map(function (node) {
            if (isSlot(node)) {
              return (/** @type {HTMLSlotElement} */node.assignedNodes({ flatten: true })
              );
            } else {
              return [node];
            }
          }).reduce(function (a, b) {
            return a.concat(b);
          }, []);
        }
      }

      /**
       * @param {Node} target Node on which to listen for changes.
       * @param {Function} callback Function called when there are additions
       * or removals from the target's list of flattened nodes.
      */

    }]);

    function FlattenedNodesObserver(target, callback) {
      var _this = this;

      _classCallCheck(this, FlattenedNodesObserver);

      /** @type {MutationObserver} */
      this._shadyChildrenObserver = null;
      /** @type {MutationObserver} */
      this._nativeChildrenObserver = null;
      this._connected = false;
      this._target = target;
      this.callback = callback;
      this._effectiveNodes = [];
      this._observer = null;
      this._scheduled = false;
      /** @type {function()} */
      this._boundSchedule = function () {
        _this._schedule();
      };
      this.connect();
      this._schedule();
    }

    /**
     * Activates an observer. This method is automatically called when
     * a `FlattenedNodesObserver` is created. It should only be called to
     * re-activate an observer that has been deactivated via the `disconnect` method.
     */


    _createClass(FlattenedNodesObserver, [{
      key: 'connect',
      value: function connect() {
        var _this2 = this;

        if (isSlot(this._target)) {
          this._listenSlots([this._target]);
        } else {
          this._listenSlots(this._target.children);
          if (window.ShadyDOM) {
            this._shadyChildrenObserver = ShadyDOM.observeChildren(this._target, function (mutations) {
              _this2._processMutations(mutations);
            });
          } else {
            this._nativeChildrenObserver = new MutationObserver(function (mutations) {
              _this2._processMutations(mutations);
            });
            this._nativeChildrenObserver.observe(this._target, { childList: true });
          }
        }
        this._connected = true;
      }

      /**
       * Deactivates the flattened nodes observer. After calling this method
       * the observer callback will not be called when changes to flattened nodes
       * occur. The `connect` method may be subsequently called to reactivate
       * the observer.
       */

    }, {
      key: 'disconnect',
      value: function disconnect() {
        if (isSlot(this._target)) {
          this._unlistenSlots([this._target]);
        } else {
          this._unlistenSlots(this._target.children);
          if (window.ShadyDOM && this._shadyChildrenObserver) {
            ShadyDOM.unobserveChildren(this._shadyChildrenObserver);
            this._shadyChildrenObserver = null;
          } else if (this._nativeChildrenObserver) {
            this._nativeChildrenObserver.disconnect();
            this._nativeChildrenObserver = null;
          }
        }
        this._connected = false;
      }
    }, {
      key: '_schedule',
      value: function _schedule() {
        var _this3 = this;

        if (!this._scheduled) {
          this._scheduled = true;
          Polymer.Async.microTask.run(function () {
            return _this3.flush();
          });
        }
      }
    }, {
      key: '_processMutations',
      value: function _processMutations(mutations) {
        this._processSlotMutations(mutations);
        this.flush();
      }
    }, {
      key: '_processSlotMutations',
      value: function _processSlotMutations(mutations) {
        if (mutations) {
          for (var i = 0; i < mutations.length; i++) {
            var mutation = mutations[i];
            if (mutation.addedNodes) {
              this._listenSlots(mutation.addedNodes);
            }
            if (mutation.removedNodes) {
              this._unlistenSlots(mutation.removedNodes);
            }
          }
        }
      }

      /**
       * Flushes the observer causing any pending changes to be immediately
       * delivered the observer callback. By default these changes are delivered
       * asynchronously at the next microtask checkpoint.
       *
       * @return {boolean} Returns true if any pending changes caused the observer
       * callback to run.
       */

    }, {
      key: 'flush',
      value: function flush() {
        if (!this._connected) {
          return false;
        }
        if (window.ShadyDOM) {
          ShadyDOM.flush();
        }
        if (this._nativeChildrenObserver) {
          this._processSlotMutations(this._nativeChildrenObserver.takeRecords());
        } else if (this._shadyChildrenObserver) {
          this._processSlotMutations(this._shadyChildrenObserver.takeRecords());
        }
        this._scheduled = false;
        var info = {
          target: this._target,
          addedNodes: [],
          removedNodes: []
        };
        var newNodes = this.constructor.getFlattenedNodes(this._target);
        var splices = Polymer.ArraySplice.calculateSplices(newNodes, this._effectiveNodes);
        // process removals
        for (var i = 0, s; i < splices.length && (s = splices[i]); i++) {
          for (var j = 0, n; j < s.removed.length && (n = s.removed[j]); j++) {
            info.removedNodes.push(n);
          }
        }
        // process adds
        for (var _i = 0, _s; _i < splices.length && (_s = splices[_i]); _i++) {
          for (var _j = _s.index; _j < _s.index + _s.addedCount; _j++) {
            info.addedNodes.push(newNodes[_j]);
          }
        }
        // update cache
        this._effectiveNodes = newNodes;
        var didFlush = false;
        if (info.addedNodes.length || info.removedNodes.length) {
          didFlush = true;
          this.callback.call(this._target, info);
        }
        return didFlush;
      }
    }, {
      key: '_listenSlots',
      value: function _listenSlots(nodeList) {
        for (var i = 0; i < nodeList.length; i++) {
          var n = nodeList[i];
          if (isSlot(n)) {
            n.addEventListener('slotchange', this._boundSchedule);
          }
        }
      }
    }, {
      key: '_unlistenSlots',
      value: function _unlistenSlots(nodeList) {
        for (var i = 0; i < nodeList.length; i++) {
          var n = nodeList[i];
          if (isSlot(n)) {
            n.removeEventListener('slotchange', this._boundSchedule);
          }
        }
      }
    }]);

    return FlattenedNodesObserver;
  }();

  Polymer.FlattenedNodesObserver = FlattenedNodesObserver;
})();

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(54);

(function () {
  'use strict';

  /**
   * Legacy class factory and registration helper for defining Polymer
   * elements.
   *
   * This method is equivalent to
   * `customElements.define(info.is, Polymer.Class(info));`
   *
   * See `Polymer.Class` for details on valid legacy metadata format for `info`.
   *
   * @override
   * @function Polymer
   * @param {!PolymerInit} info Object containing Polymer metadata and functions
   *   to become class methods.
   * @return {!HTMLElement} Generated class
   * @suppress {duplicate, invalidCasts, checkTypes}
   */

  window.Polymer._polymerFn = function (info) {
    // if input is a `class` (aka a function with a prototype), use the prototype
    // remember that the `constructor` will never be called
    var klass = void 0;
    if (typeof info === 'function') {
      klass = info;
    } else {
      klass = Polymer.Class(info);
    }
    customElements.define(klass.is, /** @type {!HTMLElement} */klass);
    return klass;
  };
})();

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

__webpack_require__(22);

(function () {

  'use strict';

  var metaProps = {
    attached: true,
    detached: true,
    ready: true,
    created: true,
    beforeRegister: true,
    registered: true,
    attributeChanged: true,
    // meta objects
    behaviors: true

    /**
     * Applies a "legacy" behavior or array of behaviors to the provided class.
     *
     * Note: this method will automatically also apply the `Polymer.LegacyElementMixin`
     * to ensure that any legacy behaviors can rely on legacy Polymer API on
     * the underlying element.
     *
     * @param {!(Object|Array)} behaviors Behavior object or array of behaviors.
     * @param {!HTMLElement|function(new:HTMLElement)} klass Element class.
     * @return {function(new:HTMLElement)} Returns a new Element class extended by the
     * passed in `behaviors` and also by `Polymer.LegacyElementMixin`.
     * @memberof Polymer
     * @suppress {invalidCasts, checkTypes}
     */
  };function mixinBehaviors(behaviors, klass) {
    if (!behaviors) {
      return (/** @type {HTMLElement} */klass
      );
    }
    // NOTE: ensure the bahevior is extending a class with
    // legacy element api. This is necessary since behaviors expect to be able
    // to access 1.x legacy api.
    klass = Polymer.LegacyElementMixin(klass);
    if (!Array.isArray(behaviors)) {
      behaviors = [behaviors];
    }
    var superBehaviors = klass.prototype.behaviors;
    // get flattened, deduped list of behaviors *not* already on super class
    behaviors = flattenBehaviors(behaviors, null, superBehaviors);
    // mixin new behaviors
    klass = _mixinBehaviors(behaviors, klass);
    if (superBehaviors) {
      behaviors = superBehaviors.concat(behaviors);
    }
    // Set behaviors on prototype for BC...
    klass.prototype.behaviors = behaviors;
    return klass;
  }

  // NOTE:
  // 1.x
  // Behaviors were mixed in *in reverse order* and de-duped on the fly.
  // The rule was that behavior properties were copied onto the element
  // prototype if and only if the property did not already exist.
  // Given: Polymer{ behaviors: [A, B, C, A, B]}, property copy order was:
  // (1), B, (2), A, (3) C. This means prototype properties win over
  // B properties win over A win over C. This mirrors what would happen
  // with inheritance if element extended B extended A extended C.
  //
  // Again given, Polymer{ behaviors: [A, B, C, A, B]}, the resulting
  // `behaviors` array was [C, A, B].
  // Behavior lifecycle methods were called in behavior array order
  // followed by the element, e.g. (1) C.created, (2) A.created,
  // (3) B.created, (4) element.created. There was no support for
  // super, and "super-behavior" methods were callable only by name).
  //
  // 2.x
  // Behaviors are made into proper mixins which live in the
  // element's prototype chain. Behaviors are placed in the element prototype
  // eldest to youngest and de-duped youngest to oldest:
  // So, first [A, B, C, A, B] becomes [C, A, B] then,
  // the element prototype becomes (oldest) (1) Polymer.Element, (2) class(C),
  // (3) class(A), (4) class(B), (5) class(Polymer({...})).
  // Result:
  // This means element properties win over B properties win over A win
  // over C. (same as 1.x)
  // If lifecycle is called (super then me), order is
  // (1) C.created, (2) A.created, (3) B.created, (4) element.created
  // (again same as 1.x)
  function _mixinBehaviors(behaviors, klass) {
    for (var i = 0; i < behaviors.length; i++) {
      var b = behaviors[i];
      if (b) {
        klass = Array.isArray(b) ? _mixinBehaviors(b, klass) : GenerateClassFromInfo(b, klass);
      }
    }
    return klass;
  }

  /**
   * @param {Array} behaviors List of behaviors to flatten.
   * @param {Array=} list Target list to flatten behaviors into.
   * @param {Array=} exclude List of behaviors to exclude from the list.
   * @return {!Array} Returns the list of flattened behaviors.
   */
  function flattenBehaviors(behaviors, list, exclude) {
    list = list || [];
    for (var i = behaviors.length - 1; i >= 0; i--) {
      var b = behaviors[i];
      if (b) {
        if (Array.isArray(b)) {
          flattenBehaviors(b, list);
        } else {
          // dedup
          if (list.indexOf(b) < 0 && (!exclude || exclude.indexOf(b) < 0)) {
            list.unshift(b);
          }
        }
      } else {
        console.warn('behavior is null, check for missing or 404 import');
      }
    }
    return list;
  }

  /**
   * @param {!PolymerInit} info Polymer info object
   * @param {function(new:HTMLElement)} Base base class to extend with info object
   * @return {function(new:HTMLElement)} Generated class
   * @suppress {checkTypes}
   * @private
   */
  function GenerateClassFromInfo(info, Base) {
    var PolymerGenerated = function (_Base) {
      _inherits(PolymerGenerated, _Base);

      function PolymerGenerated() {
        _classCallCheck(this, PolymerGenerated);

        return _possibleConstructorReturn(this, (PolymerGenerated.__proto__ || Object.getPrototypeOf(PolymerGenerated)).apply(this, arguments));
      }

      _createClass(PolymerGenerated, [{
        key: 'created',
        value: function created() {
          _get(PolymerGenerated.prototype.__proto__ || Object.getPrototypeOf(PolymerGenerated.prototype), 'created', this).call(this);
          if (info.created) {
            info.created.call(this);
          }
        }
      }, {
        key: '_registered',
        value: function _registered() {
          _get(PolymerGenerated.prototype.__proto__ || Object.getPrototypeOf(PolymerGenerated.prototype), '_registered', this).call(this);
          /* NOTE: `beforeRegister` is called here for bc, but the behavior
           is different than in 1.x. In 1.0, the method was called *after*
           mixing prototypes together but *before* processing of meta-objects.
           However, dynamic effects can still be set here and can be done either
           in `beforeRegister` or `registered`. It is no longer possible to set
           `is` in `beforeRegister` as you could in 1.x.
          */
          if (info.beforeRegister) {
            info.beforeRegister.call(Object.getPrototypeOf(this));
          }
          if (info.registered) {
            info.registered.call(Object.getPrototypeOf(this));
          }
        }
      }, {
        key: '_applyListeners',
        value: function _applyListeners() {
          _get(PolymerGenerated.prototype.__proto__ || Object.getPrototypeOf(PolymerGenerated.prototype), '_applyListeners', this).call(this);
          if (info.listeners) {
            for (var l in info.listeners) {
              this._addMethodEventListenerToNode(this, l, info.listeners[l]);
            }
          }
        }

        // note: exception to "super then me" rule;
        // do work before calling super so that super attributes
        // only apply if not already set.

      }, {
        key: '_ensureAttributes',
        value: function _ensureAttributes() {
          if (info.hostAttributes) {
            for (var a in info.hostAttributes) {
              this._ensureAttribute(a, info.hostAttributes[a]);
            }
          }
          _get(PolymerGenerated.prototype.__proto__ || Object.getPrototypeOf(PolymerGenerated.prototype), '_ensureAttributes', this).call(this);
        }
      }, {
        key: 'ready',
        value: function ready() {
          _get(PolymerGenerated.prototype.__proto__ || Object.getPrototypeOf(PolymerGenerated.prototype), 'ready', this).call(this);
          if (info.ready) {
            info.ready.call(this);
          }
        }
      }, {
        key: 'attached',
        value: function attached() {
          _get(PolymerGenerated.prototype.__proto__ || Object.getPrototypeOf(PolymerGenerated.prototype), 'attached', this).call(this);
          if (info.attached) {
            info.attached.call(this);
          }
        }
      }, {
        key: 'detached',
        value: function detached() {
          _get(PolymerGenerated.prototype.__proto__ || Object.getPrototypeOf(PolymerGenerated.prototype), 'detached', this).call(this);
          if (info.detached) {
            info.detached.call(this);
          }
        }
      }, {
        key: 'attributeChanged',
        value: function attributeChanged(name, old, value) {
          _get(PolymerGenerated.prototype.__proto__ || Object.getPrototypeOf(PolymerGenerated.prototype), 'attributeChanged', this).call(this, name, old, value);
          if (info.attributeChanged) {
            info.attributeChanged.call(this, name, old, value);
          }
        }
      }], [{
        key: 'properties',
        get: function get() {
          return info.properties;
        }
      }, {
        key: 'observers',
        get: function get() {
          return info.observers;
        }

        /**
         * @return {HTMLTemplateElement} template for this class
         */

      }, {
        key: 'template',
        get: function get() {
          // get template first from any imperative set in `info._template`
          return info._template ||
          // next look in dom-module associated with this element's is.
          Polymer.DomModule && Polymer.DomModule.import(this.is, 'template') ||
          // next look for superclass template (note: use superclass symbol
          // to ensure correct `this.is`)
          Base.template ||
          // finally fall back to `_template` in element's protoype.
          this.prototype._template || null;
        }
      }]);

      return PolymerGenerated;
    }(Base);

    PolymerGenerated.generatedFrom = info;

    for (var p in info) {
      // NOTE: cannot copy `metaProps` methods onto prototype at least because
      // `super.ready` must be called and is not included in the user fn.
      if (!(p in metaProps)) {
        var pd = Object.getOwnPropertyDescriptor(info, p);
        if (pd) {
          Object.defineProperty(PolymerGenerated.prototype, p, pd);
        }
      }
    }

    return PolymerGenerated;
  }

  /**
   * Generates a class that extends `Polymer.LegacyElement` based on the
   * provided info object.  Metadata objects on the `info` object
   * (`properties`, `observers`, `listeners`, `behaviors`, `is`) are used
   * for Polymer's meta-programming systems, and any functions are copied
   * to the generated class.
   *
   * Valid "metadata" values are as follows:
   *
   * `is`: String providing the tag name to register the element under. In
   * addition, if a `dom-module` with the same id exists, the first template
   * in that `dom-module` will be stamped into the shadow root of this element,
   * with support for declarative event listeners (`on-...`), Polymer data
   * bindings (`[[...]]` and `{{...}}`), and id-based node finding into
   * `this.$`.
   *
   * `properties`: Object describing property-related metadata used by Polymer
   * features (key: property names, value: object containing property metadata).
   * Valid keys in per-property metadata include:
   * - `type` (String|Number|Object|Array|...): Used by
   *   `attributeChangedCallback` to determine how string-based attributes
   *   are deserialized to JavaScript property values.
   * - `notify` (boolean): Causes a change in the property to fire a
   *   non-bubbling event called `<property>-changed`. Elements that have
   *   enabled two-way binding to the property use this event to observe changes.
   * - `readOnly` (boolean): Creates a getter for the property, but no setter.
   *   To set a read-only property, use the private setter method
   *   `_setProperty(property, value)`.
   * - `observer` (string): Observer method name that will be called when
   *   the property changes. The arguments of the method are
   *   `(value, previousValue)`.
   * - `computed` (string): String describing method and dependent properties
   *   for computing the value of this property (e.g. `'computeFoo(bar, zot)'`).
   *   Computed properties are read-only by default and can only be changed
   *   via the return value of the computing method.
   *
   * `observers`: Array of strings describing multi-property observer methods
   *  and their dependent properties (e.g. `'observeABC(a, b, c)'`).
   *
   * `listeners`: Object describing event listeners to be added to each
   *  instance of this element (key: event name, value: method name).
   *
   * `behaviors`: Array of additional `info` objects containing metadata
   * and callbacks in the same format as the `info` object here which are
   * merged into this element.
   *
   * `hostAttributes`: Object listing attributes to be applied to the host
   *  once created (key: attribute name, value: attribute value).  Values
   *  are serialized based on the type of the value.  Host attributes should
   *  generally be limited to attributes such as `tabIndex` and `aria-...`.
   *  Attributes in `hostAttributes` are only applied if a user-supplied
   *  attribute is not already present (attributes in markup override
   *  `hostAttributes`).
   *
   * In addition, the following Polymer-specific callbacks may be provided:
   * - `registered`: called after first instance of this element,
   * - `created`: called during `constructor`
   * - `attached`: called during `connectedCallback`
   * - `detached`: called during `disconnectedCallback`
   * - `ready`: called before first `attached`, after all properties of
   *   this element have been propagated to its template and all observers
   *   have run
   *
   * @param {!PolymerInit} info Object containing Polymer metadata and functions
   *   to become class methods.
   * @return {function(new:HTMLElement)} Generated class
   * @memberof Polymer
   */
  Polymer.Class = function (info) {
    if (!info) {
      console.warn('Polymer.Class requires `info` argument');
    }
    var klass = GenerateClassFromInfo(info, info.behaviors ?
    // note: mixinBehaviors ensures `LegacyElementMixin`.
    mixinBehaviors(info.behaviors, HTMLElement) : Polymer.LegacyElementMixin(HTMLElement));
    // decorate klass with registration info
    klass.is = info.is;
    return klass;
  };

  Polymer.mixinBehaviors = mixinBehaviors;
})();

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(14);

(function () {
  'use strict';

  var TemplateInstanceBase = Polymer.TemplateInstanceBase; // eslint-disable-line

  /**
   * @typedef {{
   *   _templatizerTemplate: HTMLTemplateElement,
   *   _parentModel: boolean,
   *   _instanceProps: Object,
   *   _forwardHostPropV2: Function,
   *   _notifyInstancePropV2: Function,
   *   ctor: TemplateInstanceBase
   * }}
   */
  var TemplatizerUser = void 0; // eslint-disable-line

  /**
   * The `Polymer.Templatizer` behavior adds methods to generate instances of
   * templates that are each managed by an anonymous `Polymer.PropertyEffects`
   * instance where data-bindings in the stamped template content are bound to
   * accessors on itself.
   *
   * This behavior is provided in Polymer 2.x as a hybrid-element convenience
   * only.  For non-hybrid usage, the `Polymer.Templatize` library
   * should be used instead.
   *
   * Example:
   *
   *     // Get a template from somewhere, e.g. light DOM
   *     let template = this.querySelector('template');
   *     // Prepare the template
   *     this.templatize(template);
   *     // Instance the template with an initial data model
   *     let instance = this.stamp({myProp: 'initial'});
   *     // Insert the instance's DOM somewhere, e.g. light DOM
   *     Polymer.dom(this).appendChild(instance.root);
   *     // Changing a property on the instance will propagate to bindings
   *     // in the template
   *     instance.myProp = 'new value';
   *
   * Users of `Templatizer` may need to implement the following abstract
   * API's to determine how properties and paths from the host should be
   * forwarded into to instances:
   *
   *     _forwardHostPropV2: function(prop, value)
   *
   * Likewise, users may implement these additional abstract API's to determine
   * how instance-specific properties that change on the instance should be
   * forwarded out to the host, if necessary.
   *
   *     _notifyInstancePropV2: function(inst, prop, value)
   *
   * In order to determine which properties are instance-specific and require
   * custom notification via `_notifyInstanceProp`, define an `_instanceProps`
   * object containing keys for each instance prop, for example:
   *
   *     _instanceProps: {
   *       item: true,
   *       index: true
   *     }
   *
   * Any properties used in the template that are not defined in _instanceProp
   * will be forwarded out to the Templatize `owner` automatically.
   *
   * Users may also implement the following abstract function to show or
   * hide any DOM generated using `stamp`:
   *
   *     _showHideChildren: function(shouldHide)
   *
   * Note that some callbacks are suffixed with `V2` in the Polymer 2.x behavior
   * as the implementations will need to differ from the callbacks required
   * by the 1.x Templatizer API due to changes in the `TemplateInstance` API
   * between versions 1.x and 2.x.
   *
   * @polymerBehavior
   * @memberof Polymer
   */
  var Templatizer = {

    /**
     * Generates an anonymous `TemplateInstance` class (stored as `this.ctor`)
     * for the provided template.  This method should be called once per
     * template to prepare an element for stamping the template, followed
     * by `stamp` to create new instances of the template.
     *
     * @param {HTMLTemplateElement} template Template to prepare
     * @param {boolean=} mutableData When `true`, the generated class will skip
     *   strict dirty-checking for objects and arrays (always consider them to
     *   be "dirty"). Defaults to false.
     * @this {TemplatizerUser}
     */
    templatize: function templatize(template, mutableData) {
      this._templatizerTemplate = template;
      this.ctor = Polymer.Templatize.templatize(template, this, {
        mutableData: Boolean(mutableData),
        parentModel: this._parentModel,
        instanceProps: this._instanceProps,
        forwardHostProp: this._forwardHostPropV2,
        notifyInstanceProp: this._notifyInstancePropV2
      });
    },


    /**
     * Creates an instance of the template prepared by `templatize`.  The object
     * returned is an instance of the anonymous class generated by `templatize`
     * whose `root` property is a document fragment containing newly cloned
     * template content, and which has property accessors corresponding to
     * properties referenced in template bindings.
     *
     * @param {Object=} model Object containing initial property values to
     *   populate into the template bindings.
     * @return {TemplateInstanceBase} Returns the created instance of
     * the template prepared by `templatize`.
     * @this {TemplatizerUser}
     */
    stamp: function stamp(model) {
      return new this.ctor(model);
    },


    /**
     * Returns the template "model" (`TemplateInstance`) associated with
     * a given element, which serves as the binding scope for the template
     * instance the element is contained in.  A template model should be used
     * to manipulate data associated with this template instance.
     *
     * @param {HTMLElement} el Element for which to return a template model.
     * @return {TemplateInstanceBase} Model representing the binding scope for
     *   the element.
     * @this {TemplatizerUser}
     */
    modelForElement: function modelForElement(el) {
      return Polymer.Templatize.modelForElement(this._templatizerTemplate, el);
    }
  };

  Polymer.Templatizer = Templatizer;
})();

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

__webpack_require__(1);

__webpack_require__(11);

__webpack_require__(9);

__webpack_require__(23);

(function () {
  'use strict';

  /**
   * @constructor
   * @extends {HTMLElement}
   * @implements {Polymer_PropertyEffects}
   * @implements {Polymer_OptionalMutableData}
   * @implements {Polymer_GestureEventListeners}
   */

  var domBindBase = Polymer.GestureEventListeners(Polymer.OptionalMutableData(Polymer.PropertyEffects(HTMLElement)));

  /**
   * Custom element to allow using Polymer's template features (data binding,
   * declarative event listeners, etc.) in the main document without defining
   * a new custom element.
   *
   * `<template>` tags utilizing bindings may be wrapped with the `<dom-bind>`
   * element, which will immediately stamp the wrapped template into the main
   * document and bind elements to the `dom-bind` element itself as the
   * binding scope.
   *
   * @polymer
   * @customElement
   * @appliesMixin Polymer.PropertyEffects
   * @appliesMixin Polymer.OptionalMutableData
   * @appliesMixin Polymer.GestureEventListeners
   * @extends {domBindBase}
   * @memberof Polymer
   * @summary Custom element to allow using Polymer's template features (data
   *   binding, declarative event listeners, etc.) in the main document.
   */

  var DomBind = function (_domBindBase) {
    _inherits(DomBind, _domBindBase);

    _createClass(DomBind, null, [{
      key: 'observedAttributes',
      get: function get() {
        return ['mutable-data'];
      }
    }]);

    function DomBind() {
      _classCallCheck(this, DomBind);

      var _this = _possibleConstructorReturn(this, (DomBind.__proto__ || Object.getPrototypeOf(DomBind)).call(this));

      _this.root = null;
      _this.$ = null;
      _this.__children = null;
      return _this;
    }

    // assumes only one observed attribute


    _createClass(DomBind, [{
      key: 'attributeChangedCallback',
      value: function attributeChangedCallback() {
        this.mutableData = true;
      }
    }, {
      key: 'connectedCallback',
      value: function connectedCallback() {
        this.render();
      }
    }, {
      key: 'disconnectedCallback',
      value: function disconnectedCallback() {
        this.__removeChildren();
      }
    }, {
      key: '__insertChildren',
      value: function __insertChildren() {
        this.parentNode.insertBefore(this.root, this);
      }
    }, {
      key: '__removeChildren',
      value: function __removeChildren() {
        if (this.__children) {
          for (var i = 0; i < this.__children.length; i++) {
            this.root.appendChild(this.__children[i]);
          }
        }
      }

      /**
       * Forces the element to render its content. This is typically only
       * necessary to call if HTMLImports with the async attribute are used.
       */

    }, {
      key: 'render',
      value: function render() {
        var _this2 = this;

        var template = void 0;
        if (!this.__children) {
          template = /** @type {HTMLTemplateElement} */template || this.querySelector('template');
          if (!template) {
            // Wait until childList changes and template should be there by then
            var observer = new MutationObserver(function () {
              template = /** @type {HTMLTemplateElement} */_this2.querySelector('template');
              if (template) {
                observer.disconnect();
                _this2.render();
              } else {
                throw new Error('dom-bind requires a <template> child');
              }
            });
            observer.observe(this, { childList: true });
            return;
          }
          this.root = this._stampTemplate(template);
          this.$ = this.root.$;
          this.__children = [];
          for (var n = this.root.firstChild; n; n = n.nextSibling) {
            this.__children[this.__children.length] = n;
          }
          this._enableProperties();
        }
        this.__insertChildren();
        this.dispatchEvent(new CustomEvent('dom-change', {
          bubbles: true,
          composed: true
        }));
      }
    }]);

    return DomBind;
  }(domBindBase);

  customElements.define('dom-bind', DomBind);
})();

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

__webpack_require__(6);

__webpack_require__(14);

__webpack_require__(12);

__webpack_require__(13);

__webpack_require__(9);

(function () {
  'use strict';

  var TemplateInstanceBase = Polymer.TemplateInstanceBase; // eslint-disable-line

  /**
   * @constructor
   * @implements {Polymer_OptionalMutableData}
   * @extends {Polymer.Element}
   */
  var domRepeatBase = Polymer.OptionalMutableData(Polymer.Element);

  /**
   * The `<dom-repeat>` element will automatically stamp and binds one instance
   * of template content to each object in a user-provided array.
   * `dom-repeat` accepts an `items` property, and one instance of the template
   * is stamped for each item into the DOM at the location of the `dom-repeat`
   * element.  The `item` property will be set on each instance's binding
   * scope, thus templates should bind to sub-properties of `item`.
   *
   * Example:
   *
   * ```html
   * <dom-module id="employee-list">
   *
   *   <template>
   *
   *     <div> Employee list: </div>
   *     <template is="dom-repeat" items="{{employees}}">
   *         <div>First name: <span>{{item.first}}</span></div>
   *         <div>Last name: <span>{{item.last}}</span></div>
   *     </template>
   *
   *   </template>
   *
   *   <script>
   *     Polymer({
   *       is: 'employee-list',
   *       ready: function() {
   *         this.employees = [
   *             {first: 'Bob', last: 'Smith'},
   *             {first: 'Sally', last: 'Johnson'},
   *             ...
   *         ];
   *       }
   *     });
   *   < /script>
   *
   * </dom-module>
   * ```
   *
   * Notifications for changes to items sub-properties will be forwarded to template
   * instances, which will update via the normal structured data notification system.
   *
   * Mutations to the `items` array itself should be made using the Array
   * mutation API's on `Polymer.Base` (`push`, `pop`, `splice`, `shift`,
   * `unshift`), and template instances will be kept in sync with the data in the
   * array.
   *
   * Events caught by event handlers within the `dom-repeat` template will be
   * decorated with a `model` property, which represents the binding scope for
   * each template instance.  The model is an instance of Polymer.Base, and should
   * be used to manipulate data on the instance, for example
   * `event.model.set('item.checked', true);`.
   *
   * Alternatively, the model for a template instance for an element stamped by
   * a `dom-repeat` can be obtained using the `modelForElement` API on the
   * `dom-repeat` that stamped it, for example
   * `this.$.domRepeat.modelForElement(event.target).set('item.checked', true);`.
   * This may be useful for manipulating instance data of event targets obtained
   * by event handlers on parents of the `dom-repeat` (event delegation).
   *
   * A view-specific filter/sort may be applied to each `dom-repeat` by supplying a
   * `filter` and/or `sort` property.  This may be a string that names a function on
   * the host, or a function may be assigned to the property directly.  The functions
   * should implemented following the standard `Array` filter/sort API.
   *
   * In order to re-run the filter or sort functions based on changes to sub-fields
   * of `items`, the `observe` property may be set as a space-separated list of
   * `item` sub-fields that should cause a re-filter/sort when modified.  If
   * the filter or sort function depends on properties not contained in `items`,
   * the user should observe changes to those properties and call `render` to update
   * the view based on the dependency change.
   *
   * For example, for an `dom-repeat` with a filter of the following:
   *
   * ```js
   * isEngineer: function(item) {
   *     return item.type == 'engineer' || item.manager.type == 'engineer';
   * }
   * ```
   *
   * Then the `observe` property should be configured as follows:
   *
   * ```html
   * <template is="dom-repeat" items="{{employees}}"
   *           filter="isEngineer" observe="type manager.type">
   * ```
   *
   * @customElement
   * @polymer
   * @memberof Polymer
   * @extends {domRepeatBase}
   * @appliesMixin Polymer.OptionalMutableData
   * @summary Custom element for stamping instance of a template bound to
   *   items in an array.
   */

  var DomRepeat = function (_domRepeatBase) {
    _inherits(DomRepeat, _domRepeatBase);

    _createClass(DomRepeat, null, [{
      key: 'is',


      // Not needed to find template; can be removed once the analyzer
      // can find the tag name from customElements.define call
      get: function get() {
        return 'dom-repeat';
      }
    }, {
      key: 'template',
      get: function get() {
        return null;
      }
    }, {
      key: 'properties',
      get: function get() {

        /**
         * Fired whenever DOM is added or removed by this template (by
         * default, rendering occurs lazily).  To force immediate rendering, call
         * `render`.
         *
         * @event dom-change
         */
        return {

          /**
           * An array containing items determining how many instances of the template
           * to stamp and that that each template instance should bind to.
           */
          items: {
            type: Array
          },

          /**
           * The name of the variable to add to the binding scope for the array
           * element associated with a given template instance.
           */
          as: {
            type: String,
            value: 'item'
          },

          /**
           * The name of the variable to add to the binding scope with the index
           * of the instance in the sorted and filtered list of rendered items.
           * Note, for the index in the `this.items` array, use the value of the
           * `itemsIndexAs` property.
           */
          indexAs: {
            type: String,
            value: 'index'
          },

          /**
           * The name of the variable to add to the binding scope with the index
           * of the instance in the `this.items` array. Note, for the index of
           * this instance in the sorted and filtered list of rendered items,
           * use the value of the `indexAs` property.
           */
          itemsIndexAs: {
            type: String,
            value: 'itemsIndex'
          },

          /**
           * A function that should determine the sort order of the items.  This
           * property should either be provided as a string, indicating a method
           * name on the element's host, or else be an actual function.  The
           * function should match the sort function passed to `Array.sort`.
           * Using a sort function has no effect on the underlying `items` array.
           */
          sort: {
            type: Function,
            observer: '__sortChanged'
          },

          /**
           * A function that can be used to filter items out of the view.  This
           * property should either be provided as a string, indicating a method
           * name on the element's host, or else be an actual function.  The
           * function should match the sort function passed to `Array.filter`.
           * Using a filter function has no effect on the underlying `items` array.
           */
          filter: {
            type: Function,
            observer: '__filterChanged'
          },

          /**
           * When using a `filter` or `sort` function, the `observe` property
           * should be set to a space-separated list of the names of item
           * sub-fields that should trigger a re-sort or re-filter when changed.
           * These should generally be fields of `item` that the sort or filter
           * function depends on.
           */
          observe: {
            type: String,
            observer: '__observeChanged'
          },

          /**
           * When using a `filter` or `sort` function, the `delay` property
           * determines a debounce time after a change to observed item
           * properties that must pass before the filter or sort is re-run.
           * This is useful in rate-limiting shuffing of the view when
           * item changes may be frequent.
           */
          delay: Number,

          /**
           * Count of currently rendered items after `filter` (if any) has been applied.
           * If "chunking mode" is enabled, `renderedItemCount` is updated each time a
           * set of template instances is rendered.
           *
           */
          renderedItemCount: {
            type: Number,
            notify: true,
            readOnly: true
          },

          /**
           * Defines an initial count of template instances to render after setting
           * the `items` array, before the next paint, and puts the `dom-repeat`
           * into "chunking mode".  The remaining items will be created and rendered
           * incrementally at each animation frame therof until all instances have
           * been rendered.
           */
          initialCount: {
            type: Number,
            observer: '__initializeChunking'
          },

          /**
           * When `initialCount` is used, this property defines a frame rate to
           * target by throttling the number of instances rendered each frame to
           * not exceed the budget for the target frame rate.  Setting this to a
           * higher number will allow lower latency and higher throughput for
           * things like event handlers, but will result in a longer time for the
           * remaining items to complete rendering.
           */
          targetFramerate: {
            type: Number,
            value: 20
          },

          _targetFrameTime: {
            type: Number,
            computed: '__computeFrameTime(targetFramerate)'
          }

        };
      }
    }, {
      key: 'observers',
      get: function get() {
        return ['__itemsChanged(items.*)'];
      }
    }]);

    function DomRepeat() {
      _classCallCheck(this, DomRepeat);

      var _this = _possibleConstructorReturn(this, (DomRepeat.__proto__ || Object.getPrototypeOf(DomRepeat)).call(this));

      _this.__instances = [];
      _this.__limit = Infinity;
      _this.__pool = [];
      _this.__renderDebouncer = null;
      _this.__itemsIdxToInstIdx = {};
      _this.__chunkCount = null;
      _this.__lastChunkTime = null;
      _this.__sortFn = null;
      _this.__filterFn = null;
      _this.__observePaths = null;
      _this.__ctor = null;
      _this.__isDetached = true;
      _this.template = null;
      return _this;
    }

    _createClass(DomRepeat, [{
      key: 'disconnectedCallback',
      value: function disconnectedCallback() {
        _get(DomRepeat.prototype.__proto__ || Object.getPrototypeOf(DomRepeat.prototype), 'disconnectedCallback', this).call(this);
        this.__isDetached = true;
        for (var i = 0; i < this.__instances.length; i++) {
          this.__detachInstance(i);
        }
      }
    }, {
      key: 'connectedCallback',
      value: function connectedCallback() {
        _get(DomRepeat.prototype.__proto__ || Object.getPrototypeOf(DomRepeat.prototype), 'connectedCallback', this).call(this);
        // only perform attachment if the element was previously detached.
        if (this.__isDetached) {
          this.__isDetached = false;
          var parent = this.parentNode;
          for (var i = 0; i < this.__instances.length; i++) {
            this.__attachInstance(i, parent);
          }
        }
      }
    }, {
      key: '__ensureTemplatized',
      value: function __ensureTemplatized() {
        var _this2 = this;

        // Templatizing (generating the instance constructor) needs to wait
        // until ready, since won't have its template content handed back to
        // it until then
        if (!this.__ctor) {
          var template = this.template = this.querySelector('template');
          if (!template) {
            // // Wait until childList changes and template should be there by then
            var observer = new MutationObserver(function () {
              if (_this2.querySelector('template')) {
                observer.disconnect();
                _this2.__render();
              } else {
                throw new Error('dom-repeat requires a <template> child');
              }
            });
            observer.observe(this, { childList: true });
            return false;
          }
          // Template instance props that should be excluded from forwarding
          var instanceProps = {};
          instanceProps[this.as] = true;
          instanceProps[this.indexAs] = true;
          instanceProps[this.itemsIndexAs] = true;
          this.__ctor = Polymer.Templatize.templatize(template, this, {
            mutableData: this.mutableData,
            parentModel: true,
            instanceProps: instanceProps,
            /**
             * @this {this}
             * @param {string} prop Property to set
             * @param {*} value Value to set property to
             */
            forwardHostProp: function forwardHostProp(prop, value) {
              var i$ = this.__instances;
              for (var i = 0, inst; i < i$.length && (inst = i$[i]); i++) {
                inst.forwardHostProp(prop, value);
              }
            },
            /**
             * @this {this}
             * @param {Object} inst Instance to notify
             * @param {string} prop Property to notify
             * @param {*} value Value to notify
             */
            notifyInstanceProp: function notifyInstanceProp(inst, prop, value) {
              if (Polymer.Path.matches(this.as, prop)) {
                var idx = inst[this.itemsIndexAs];
                if (prop == this.as) {
                  this.items[idx] = value;
                }
                var path = Polymer.Path.translate(this.as, 'items.' + idx, prop);
                this.notifyPath(path, value);
              }
            }
          });
        }
        return true;
      }
    }, {
      key: '__getMethodHost',
      value: function __getMethodHost() {
        // Technically this should be the owner of the outermost template.
        // In shadow dom, this is always getRootNode().host, but we can
        // approximate this via cooperation with our dataHost always setting
        // `_methodHost` as long as there were bindings (or id's) on this
        // instance causing it to get a dataHost.
        return this.__dataHost._methodHost || this.__dataHost;
      }
    }, {
      key: '__sortChanged',
      value: function __sortChanged(sort) {
        var methodHost = this.__getMethodHost();
        this.__sortFn = sort && (typeof sort == 'function' ? sort : function () {
          return methodHost[sort].apply(methodHost, arguments);
        });
        if (this.items) {
          this.__debounceRender(this.__render);
        }
      }
    }, {
      key: '__filterChanged',
      value: function __filterChanged(filter) {
        var methodHost = this.__getMethodHost();
        this.__filterFn = filter && (typeof filter == 'function' ? filter : function () {
          return methodHost[filter].apply(methodHost, arguments);
        });
        if (this.items) {
          this.__debounceRender(this.__render);
        }
      }
    }, {
      key: '__computeFrameTime',
      value: function __computeFrameTime(rate) {
        return Math.ceil(1000 / rate);
      }
    }, {
      key: '__initializeChunking',
      value: function __initializeChunking() {
        if (this.initialCount) {
          this.__limit = this.initialCount;
          this.__chunkCount = this.initialCount;
          this.__lastChunkTime = performance.now();
        }
      }
    }, {
      key: '__tryRenderChunk',
      value: function __tryRenderChunk() {
        // Debounced so that multiple calls through `_render` between animation
        // frames only queue one new rAF (e.g. array mutation & chunked render)
        if (this.items && this.__limit < this.items.length) {
          this.__debounceRender(this.__requestRenderChunk);
        }
      }
    }, {
      key: '__requestRenderChunk',
      value: function __requestRenderChunk() {
        var _this3 = this;

        requestAnimationFrame(function () {
          return _this3.__renderChunk();
        });
      }
    }, {
      key: '__renderChunk',
      value: function __renderChunk() {
        // Simple auto chunkSize throttling algorithm based on feedback loop:
        // measure actual time between frames and scale chunk count by ratio
        // of target/actual frame time
        var currChunkTime = performance.now();
        var ratio = this._targetFrameTime / (currChunkTime - this.__lastChunkTime);
        this.__chunkCount = Math.round(this.__chunkCount * ratio) || 1;
        this.__limit += this.__chunkCount;
        this.__lastChunkTime = currChunkTime;
        this.__debounceRender(this.__render);
      }
    }, {
      key: '__observeChanged',
      value: function __observeChanged() {
        this.__observePaths = this.observe && this.observe.replace('.*', '.').split(' ');
      }
    }, {
      key: '__itemsChanged',
      value: function __itemsChanged(change) {
        if (this.items && !Array.isArray(this.items)) {
          console.warn('dom-repeat expected array for `items`, found', this.items);
        }
        // If path was to an item (e.g. 'items.3' or 'items.3.foo'), forward the
        // path to that instance synchronously (retuns false for non-item paths)
        if (!this.__handleItemPath(change.path, change.value)) {
          // Otherwise, the array was reset ('items') or spliced ('items.splices'),
          // so queue a full refresh
          this.__initializeChunking();
          this.__debounceRender(this.__render);
        }
      }
    }, {
      key: '__handleObservedPaths',
      value: function __handleObservedPaths(path) {
        if (this.__observePaths) {
          path = path.substring(path.indexOf('.') + 1);
          var paths = this.__observePaths;
          for (var i = 0; i < paths.length; i++) {
            if (path.indexOf(paths[i]) === 0) {
              this.__debounceRender(this.__render, this.delay);
              return true;
            }
          }
        }
      }

      /**
       * @param {function(this:DomRepeat)} fn Function to debounce.
       * @param {number=} delay Delay in ms to debounce by.
       */

    }, {
      key: '__debounceRender',
      value: function __debounceRender(fn) {
        var delay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

        this.__renderDebouncer = Polymer.Debouncer.debounce(this.__renderDebouncer, delay > 0 ? Polymer.Async.timeOut.after(delay) : Polymer.Async.microTask, fn.bind(this));
        Polymer.enqueueDebouncer(this.__renderDebouncer);
      }

      /**
       * Forces the element to render its content. Normally rendering is
       * asynchronous to a provoking change. This is done for efficiency so
       * that multiple changes trigger only a single render. The render method
       * should be called if, for example, template rendering is required to
       * validate application state.
       */

    }, {
      key: 'render',
      value: function render() {
        // Queue this repeater, then flush all in order
        this.__debounceRender(this.__render);
        Polymer.flush();
      }
    }, {
      key: '__render',
      value: function __render() {
        if (!this.__ensureTemplatized()) {
          // No template found yet
          return;
        }
        this.__applyFullRefresh();
        // Reset the pool
        // TODO(kschaaf): Reuse pool across turns and nested templates
        // Now that objects/arrays are re-evaluated when set, we can safely
        // reuse pooled instances across turns, however we still need to decide
        // semantics regarding how long to hold, how many to hold, etc.
        this.__pool.length = 0;
        // Set rendered item count
        this._setRenderedItemCount(this.__instances.length);
        // Notify users
        this.dispatchEvent(new CustomEvent('dom-change', {
          bubbles: true,
          composed: true
        }));
        // Check to see if we need to render more items
        this.__tryRenderChunk();
      }
    }, {
      key: '__applyFullRefresh',
      value: function __applyFullRefresh() {
        var _this4 = this;

        var items = this.items || [];
        var isntIdxToItemsIdx = new Array(items.length);
        for (var i = 0; i < items.length; i++) {
          isntIdxToItemsIdx[i] = i;
        }
        // Apply user filter
        if (this.__filterFn) {
          isntIdxToItemsIdx = isntIdxToItemsIdx.filter(function (i, idx, array) {
            return _this4.__filterFn(items[i], idx, array);
          });
        }
        // Apply user sort
        if (this.__sortFn) {
          isntIdxToItemsIdx.sort(function (a, b) {
            return _this4.__sortFn(items[a], items[b]);
          });
        }
        // items->inst map kept for item path forwarding
        var itemsIdxToInstIdx = this.__itemsIdxToInstIdx = {};
        var instIdx = 0;
        // Generate instances and assign items
        var limit = Math.min(isntIdxToItemsIdx.length, this.__limit);
        for (; instIdx < limit; instIdx++) {
          var inst = this.__instances[instIdx];
          var itemIdx = isntIdxToItemsIdx[instIdx];
          var item = items[itemIdx];
          itemsIdxToInstIdx[itemIdx] = instIdx;
          if (inst && instIdx < this.__limit) {
            inst._setPendingProperty(this.as, item);
            inst._setPendingProperty(this.indexAs, instIdx);
            inst._setPendingProperty(this.itemsIndexAs, itemIdx);
            inst._flushProperties();
          } else {
            this.__insertInstance(item, instIdx, itemIdx);
          }
        }
        // Remove any extra instances from previous state
        for (var _i = this.__instances.length - 1; _i >= instIdx; _i--) {
          this.__detachAndRemoveInstance(_i);
        }
      }
    }, {
      key: '__detachInstance',
      value: function __detachInstance(idx) {
        var inst = this.__instances[idx];
        for (var i = 0; i < inst.children.length; i++) {
          var el = inst.children[i];
          inst.root.appendChild(el);
        }
        return inst;
      }
    }, {
      key: '__attachInstance',
      value: function __attachInstance(idx, parent) {
        var inst = this.__instances[idx];
        parent.insertBefore(inst.root, this);
      }
    }, {
      key: '__detachAndRemoveInstance',
      value: function __detachAndRemoveInstance(idx) {
        var inst = this.__detachInstance(idx);
        if (inst) {
          this.__pool.push(inst);
        }
        this.__instances.splice(idx, 1);
      }
    }, {
      key: '__stampInstance',
      value: function __stampInstance(item, instIdx, itemIdx) {
        var model = {};
        model[this.as] = item;
        model[this.indexAs] = instIdx;
        model[this.itemsIndexAs] = itemIdx;
        return new this.__ctor(model);
      }
    }, {
      key: '__insertInstance',
      value: function __insertInstance(item, instIdx, itemIdx) {
        var inst = this.__pool.pop();
        if (inst) {
          // TODO(kschaaf): If the pool is shared across turns, hostProps
          // need to be re-set to reused instances in addition to item
          inst._setPendingProperty(this.as, item);
          inst._setPendingProperty(this.indexAs, instIdx);
          inst._setPendingProperty(this.itemsIndexAs, itemIdx);
          inst._flushProperties();
        } else {
          inst = this.__stampInstance(item, instIdx, itemIdx);
        }
        var beforeRow = this.__instances[instIdx + 1];
        var beforeNode = beforeRow ? beforeRow.children[0] : this;
        this.parentNode.insertBefore(inst.root, beforeNode);
        this.__instances[instIdx] = inst;
        return inst;
      }

      // Implements extension point from Templatize mixin

    }, {
      key: '_showHideChildren',
      value: function _showHideChildren(hidden) {
        for (var i = 0; i < this.__instances.length; i++) {
          this.__instances[i]._showHideChildren(hidden);
        }
      }

      // Called as a side effect of a host items.<key>.<path> path change,
      // responsible for notifying item.<path> changes to inst for key

    }, {
      key: '__handleItemPath',
      value: function __handleItemPath(path, value) {
        var itemsPath = path.slice(6); // 'items.'.length == 6
        var dot = itemsPath.indexOf('.');
        var itemsIdx = dot < 0 ? itemsPath : itemsPath.substring(0, dot);
        // If path was index into array...
        if (itemsIdx == parseInt(itemsIdx, 10)) {
          var itemSubPath = dot < 0 ? '' : itemsPath.substring(dot + 1);
          // If the path is observed, it will trigger a full refresh
          this.__handleObservedPaths(itemSubPath);
          // Note, even if a rull refresh is triggered, always do the path
          // notification because unless mutableData is used for dom-repeat
          // and all elements in the instance subtree, a full refresh may
          // not trigger the proper update.
          var instIdx = this.__itemsIdxToInstIdx[itemsIdx];
          var inst = this.__instances[instIdx];
          if (inst) {
            var itemPath = this.as + (itemSubPath ? '.' + itemSubPath : '');
            // This is effectively `notifyPath`, but avoids some of the overhead
            // of the public API
            inst._setPendingPropertyOrPath(itemPath, value, false, true);
            inst._flushProperties();
          }
          return true;
        }
      }

      /**
       * Returns the item associated with a given element stamped by
       * this `dom-repeat`.
       *
       * Note, to modify sub-properties of the item,
       * `modelForElement(el).set('item.<sub-prop>', value)`
       * should be used.
       *
       * @param {HTMLElement} el Element for which to return the item.
       * @return {*} Item associated with the element.
       */

    }, {
      key: 'itemForElement',
      value: function itemForElement(el) {
        var instance = this.modelForElement(el);
        return instance && instance[this.as];
      }

      /**
       * Returns the inst index for a given element stamped by this `dom-repeat`.
       * If `sort` is provided, the index will reflect the sorted order (rather
       * than the original array order).
       *
       * @param {HTMLElement} el Element for which to return the index.
       * @return {*} Row index associated with the element (note this may
       *   not correspond to the array index if a user `sort` is applied).
       */

    }, {
      key: 'indexForElement',
      value: function indexForElement(el) {
        var instance = this.modelForElement(el);
        return instance && instance[this.indexAs];
      }

      /**
       * Returns the template "model" associated with a given element, which
       * serves as the binding scope for the template instance the element is
       * contained in. A template model is an instance of `Polymer.Base`, and
       * should be used to manipulate data associated with this template instance.
       *
       * Example:
       *
       *   let model = modelForElement(el);
       *   if (model.index < 10) {
       *     model.set('item.checked', true);
       *   }
       *
       * @param {HTMLElement} el Element for which to return a template model.
       * @return {TemplateInstanceBase} Model representing the binding scope for
       *   the element.
       */

    }, {
      key: 'modelForElement',
      value: function modelForElement(el) {
        return Polymer.Templatize.modelForElement(this.template, el);
      }
    }]);

    return DomRepeat;
  }(domRepeatBase);

  customElements.define(DomRepeat.is, DomRepeat);

  Polymer.DomRepeat = DomRepeat;
})();

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

__webpack_require__(6);

__webpack_require__(14);

__webpack_require__(12);

__webpack_require__(13);

(function () {
  'use strict';

  /**
   * The `<dom-if>` element will stamp a light-dom `<template>` child when
   * the `if` property becomes truthy, and the template can use Polymer
   * data-binding and declarative event features when used in the context of
   * a Polymer element's template.
   *
   * When `if` becomes falsey, the stamped content is hidden but not
   * removed from dom. When `if` subsequently becomes truthy again, the content
   * is simply re-shown. This approach is used due to its favorable performance
   * characteristics: the expense of creating template content is paid only
   * once and lazily.
   *
   * Set the `restamp` property to true to force the stamped content to be
   * created / destroyed when the `if` condition changes.
   *
   * @customElement
   * @polymer
   * @extends Polymer.Element
   * @memberof Polymer
   * @summary Custom element that conditionally stamps and hides or removes
   *   template content based on a boolean flag.
   */

  var DomIf = function (_Polymer$Element) {
    _inherits(DomIf, _Polymer$Element);

    _createClass(DomIf, null, [{
      key: 'is',


      // Not needed to find template; can be removed once the analyzer
      // can find the tag name from customElements.define call
      get: function get() {
        return 'dom-if';
      }
    }, {
      key: 'template',
      get: function get() {
        return null;
      }
    }, {
      key: 'properties',
      get: function get() {

        return {

          /**
           * Fired whenever DOM is added or removed/hidden by this template (by
           * default, rendering occurs lazily).  To force immediate rendering, call
           * `render`.
           *
           * @event dom-change
           */

          /**
           * A boolean indicating whether this template should stamp.
           */
          if: {
            type: Boolean,
            observer: '__debounceRender'
          },

          /**
           * When true, elements will be removed from DOM and discarded when `if`
           * becomes false and re-created and added back to the DOM when `if`
           * becomes true.  By default, stamped elements will be hidden but left
           * in the DOM when `if` becomes false, which is generally results
           * in better performance.
           */
          restamp: {
            type: Boolean,
            observer: '__debounceRender'
          }

        };
      }
    }]);

    function DomIf() {
      _classCallCheck(this, DomIf);

      var _this = _possibleConstructorReturn(this, (DomIf.__proto__ || Object.getPrototypeOf(DomIf)).call(this));

      _this.__renderDebouncer = null;
      _this.__invalidProps = null;
      _this.__instance = null;
      _this._lastIf = false;
      _this.__ctor = null;
      return _this;
    }

    _createClass(DomIf, [{
      key: '__debounceRender',
      value: function __debounceRender() {
        var _this2 = this;

        // Render is async for 2 reasons:
        // 1. To eliminate dom creation trashing if user code thrashes `if` in the
        //    same turn. This was more common in 1.x where a compound computed
        //    property could result in the result changing multiple times, but is
        //    mitigated to a large extent by batched property processing in 2.x.
        // 2. To avoid double object propagation when a bag including values bound
        //    to the `if` property as well as one or more hostProps could enqueue
        //    the <dom-if> to flush before the <template>'s host property
        //    forwarding. In that scenario creating an instance would result in
        //    the host props being set once, and then the enqueued changes on the
        //    template would set properties a second time, potentially causing an
        //    object to be set to an instance more than once.  Creating the
        //    instance async from flushing data ensures this doesn't happen. If
        //    we wanted a sync option in the future, simply having <dom-if> flush
        //    (or clear) its template's pending host properties before creating
        //    the instance would also avoid the problem.
        this.__renderDebouncer = Polymer.Debouncer.debounce(this.__renderDebouncer, Polymer.Async.microTask, function () {
          return _this2.__render();
        });
        Polymer.enqueueDebouncer(this.__renderDebouncer);
      }
    }, {
      key: 'disconnectedCallback',
      value: function disconnectedCallback() {
        _get(DomIf.prototype.__proto__ || Object.getPrototypeOf(DomIf.prototype), 'disconnectedCallback', this).call(this);
        if (!this.parentNode || this.parentNode.nodeType == Node.DOCUMENT_FRAGMENT_NODE && !this.parentNode.host) {
          this.__teardownInstance();
        }
      }
    }, {
      key: 'connectedCallback',
      value: function connectedCallback() {
        _get(DomIf.prototype.__proto__ || Object.getPrototypeOf(DomIf.prototype), 'connectedCallback', this).call(this);
        if (this.if) {
          this.__debounceRender();
        }
      }

      /**
       * Forces the element to render its content. Normally rendering is
       * asynchronous to a provoking change. This is done for efficiency so
       * that multiple changes trigger only a single render. The render method
       * should be called if, for example, template rendering is required to
       * validate application state.
       */

    }, {
      key: 'render',
      value: function render() {
        Polymer.flush();
      }
    }, {
      key: '__render',
      value: function __render() {
        if (this.if) {
          if (!this.__ensureInstance()) {
            // No template found yet
            return;
          }
          this._showHideChildren();
        } else if (this.restamp) {
          this.__teardownInstance();
        }
        if (!this.restamp && this.__instance) {
          this._showHideChildren();
        }
        if (this.if != this._lastIf) {
          this.dispatchEvent(new CustomEvent('dom-change', {
            bubbles: true,
            composed: true
          }));
          this._lastIf = this.if;
        }
      }
    }, {
      key: '__ensureInstance',
      value: function __ensureInstance() {
        var _this3 = this;

        var parentNode = this.parentNode;
        // Guard against element being detached while render was queued
        if (parentNode) {
          if (!this.__ctor) {
            var template = this.querySelector('template');
            if (!template) {
              // Wait until childList changes and template should be there by then
              var observer = new MutationObserver(function () {
                if (_this3.querySelector('template')) {
                  observer.disconnect();
                  _this3.__render();
                } else {
                  throw new Error('dom-if requires a <template> child');
                }
              });
              observer.observe(this, { childList: true });
              return false;
            }
            this.__ctor = Polymer.Templatize.templatize(template, this, {
              // dom-if templatizer instances require `mutable: true`, as
              // `__syncHostProperties` relies on that behavior to sync objects
              mutableData: true,
              /**
               * @param {string} prop Property to forward
               * @param {*} value Value of property
               * @this {this}
               */
              forwardHostProp: function forwardHostProp(prop, value) {
                if (this.__instance) {
                  if (this.if) {
                    this.__instance.forwardHostProp(prop, value);
                  } else {
                    // If we have an instance but are squelching host property
                    // forwarding due to if being false, note the invalidated
                    // properties so `__syncHostProperties` can sync them the next
                    // time `if` becomes true
                    this.__invalidProps = this.__invalidProps || Object.create(null);
                    this.__invalidProps[Polymer.Path.root(prop)] = true;
                  }
                }
              }
            });
          }
          if (!this.__instance) {
            this.__instance = new this.__ctor();
            parentNode.insertBefore(this.__instance.root, this);
          } else {
            this.__syncHostProperties();
            var c$ = this.__instance.children;
            if (c$ && c$.length) {
              // Detect case where dom-if was re-attached in new position
              var lastChild = this.previousSibling;
              if (lastChild !== c$[c$.length - 1]) {
                for (var i = 0, n; i < c$.length && (n = c$[i]); i++) {
                  parentNode.insertBefore(n, this);
                }
              }
            }
          }
        }
        return true;
      }
    }, {
      key: '__syncHostProperties',
      value: function __syncHostProperties() {
        var props = this.__invalidProps;
        if (props) {
          for (var prop in props) {
            this.__instance._setPendingProperty(prop, this.__dataHost[prop]);
          }
          this.__invalidProps = null;
          this.__instance._flushProperties();
        }
      }
    }, {
      key: '__teardownInstance',
      value: function __teardownInstance() {
        if (this.__instance) {
          var c$ = this.__instance.children;
          if (c$ && c$.length) {
            // use first child parent, for case when dom-if may have been detached
            var parent = c$[0].parentNode;
            for (var i = 0, n; i < c$.length && (n = c$[i]); i++) {
              parent.removeChild(n);
            }
          }
          this.__instance = null;
          this.__invalidProps = null;
        }
      }
    }, {
      key: '_showHideChildren',
      value: function _showHideChildren() {
        var hidden = this.__hideTemplateChildren__ || !this.if;
        if (this.__instance) {
          this.__instance._showHideChildren(hidden);
        }
      }
    }]);

    return DomIf;
  }(Polymer.Element);

  customElements.define(DomIf.is, DomIf);

  Polymer.DomIf = DomIf;
})();

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

__webpack_require__(6);

__webpack_require__(3);

__webpack_require__(24);

(function () {
  'use strict';

  /**
   * Element mixin for recording dynamic associations between item paths in a
   * master `items` array and a `selected` array such that path changes to the
   * master array (at the host) element or elsewhere via data-binding) are
   * correctly propagated to items in the selected array and vice-versa.
   *
   * The `items` property accepts an array of user data, and via the
   * `select(item)` and `deselect(item)` API, updates the `selected` property
   * which may be bound to other parts of the application, and any changes to
   * sub-fields of `selected` item(s) will be kept in sync with items in the
   * `items` array.  When `multi` is false, `selected` is a property
   * representing the last selected item.  When `multi` is true, `selected`
   * is an array of multiply selected items.
   *
   * @polymer
   * @mixinFunction
   * @appliesMixin Polymer.ElementMixin
   * @memberof Polymer
   * @summary Element mixin for recording dynamic associations between item paths in a
   * master `items` array and a `selected` array
   */

  var ArraySelectorMixin = Polymer.dedupingMixin(function (superClass) {

    /**
     * @constructor
     * @extends {superClass}
     * @implements {Polymer_ElementMixin}
     */
    var elementBase = Polymer.ElementMixin(superClass);

    /**
     * @polymer
     * @mixinClass
     * @implements {Polymer_ArraySelectorMixin}
     * @unrestricted
     */

    var ArraySelectorMixin = function (_elementBase) {
      _inherits(ArraySelectorMixin, _elementBase);

      _createClass(ArraySelectorMixin, null, [{
        key: 'properties',
        get: function get() {

          return {

            /**
             * An array containing items from which selection will be made.
             */
            items: {
              type: Array
            },

            /**
             * When `true`, multiple items may be selected at once (in this case,
             * `selected` is an array of currently selected items).  When `false`,
             * only one item may be selected at a time.
             */
            multi: {
              type: Boolean,
              value: false
            },

            /**
             * When `multi` is true, this is an array that contains any selected.
             * When `multi` is false, this is the currently selected item, or `null`
             * if no item is selected.
             * @type {?(Object|Array<!Object>)}
             */
            selected: {
              type: Object,
              notify: true
            },

            /**
             * When `multi` is false, this is the currently selected item, or `null`
             * if no item is selected.
             * @type {?Object}
             */
            selectedItem: {
              type: Object,
              notify: true
            },

            /**
             * When `true`, calling `select` on an item that is already selected
             * will deselect the item.
             */
            toggle: {
              type: Boolean,
              value: false
            }

          };
        }
      }, {
        key: 'observers',
        get: function get() {
          return ['__updateSelection(multi, items.*)'];
        }
      }]);

      function ArraySelectorMixin() {
        _classCallCheck(this, ArraySelectorMixin);

        var _this = _possibleConstructorReturn(this, (ArraySelectorMixin.__proto__ || Object.getPrototypeOf(ArraySelectorMixin)).call(this));

        _this.__lastItems = null;
        _this.__lastMulti = null;
        _this.__selectedMap = null;
        return _this;
      }

      _createClass(ArraySelectorMixin, [{
        key: '__updateSelection',
        value: function __updateSelection(multi, itemsInfo) {
          var path = itemsInfo.path;
          if (path == 'items') {
            // Case 1 - items array changed, so diff against previous array and
            // deselect any removed items and adjust selected indices
            var newItems = itemsInfo.base || [];
            var lastItems = this.__lastItems;
            var lastMulti = this.__lastMulti;
            if (multi !== lastMulti) {
              this.clearSelection();
            }
            if (lastItems) {
              var splices = Polymer.ArraySplice.calculateSplices(newItems, lastItems);
              this.__applySplices(splices);
            }
            this.__lastItems = newItems;
            this.__lastMulti = multi;
          } else if (itemsInfo.path == 'items.splices') {
            // Case 2 - got specific splice information describing the array mutation:
            // deselect any removed items and adjust selected indices
            this.__applySplices(itemsInfo.value.indexSplices);
          } else {
            // Case 3 - an array element was changed, so deselect the previous
            // item for that index if it was previously selected
            var part = path.slice('items.'.length);
            var idx = parseInt(part, 10);
            if (part.indexOf('.') < 0 && part == idx) {
              this.__deselectChangedIdx(idx);
            }
          }
        }
      }, {
        key: '__applySplices',
        value: function __applySplices(splices) {
          var _this2 = this;

          var selected = this.__selectedMap;
          // Adjust selected indices and mark removals

          var _loop = function _loop(i) {
            var s = splices[i];
            selected.forEach(function (idx, item) {
              if (idx < s.index) {
                // no change
              } else if (idx >= s.index + s.removed.length) {
                // adjust index
                selected.set(item, idx + s.addedCount - s.removed.length);
              } else {
                // remove index
                selected.set(item, -1);
              }
            });
            for (var j = 0; j < s.addedCount; j++) {
              var idx = s.index + j;
              if (selected.has(_this2.items[idx])) {
                selected.set(_this2.items[idx], idx);
              }
            }
          };

          for (var i = 0; i < splices.length; i++) {
            _loop(i);
          }
          // Update linked paths
          this.__updateLinks();
          // Remove selected items that were removed from the items array
          var sidx = 0;
          selected.forEach(function (idx, item) {
            if (idx < 0) {
              if (_this2.multi) {
                _this2.splice('selected', sidx, 1);
              } else {
                _this2.selected = _this2.selectedItem = null;
              }
              selected.delete(item);
            } else {
              sidx++;
            }
          });
        }
      }, {
        key: '__updateLinks',
        value: function __updateLinks() {
          var _this3 = this;

          this.__dataLinkedPaths = {};
          if (this.multi) {
            var sidx = 0;
            this.__selectedMap.forEach(function (idx) {
              if (idx >= 0) {
                _this3.linkPaths('items.' + idx, 'selected.' + sidx++);
              }
            });
          } else {
            this.__selectedMap.forEach(function (idx) {
              _this3.linkPaths('selected', 'items.' + idx);
              _this3.linkPaths('selectedItem', 'items.' + idx);
            });
          }
        }

        /**
         * Clears the selection state.
         *
         */

      }, {
        key: 'clearSelection',
        value: function clearSelection() {
          // Unbind previous selection
          this.__dataLinkedPaths = {};
          // The selected map stores 3 pieces of information:
          // key: items array object
          // value: items array index
          // order: selected array index
          this.__selectedMap = new Map();
          // Initialize selection
          this.selected = this.multi ? [] : null;
          this.selectedItem = null;
        }

        /**
         * Returns whether the item is currently selected.
         *
         * @param {*} item Item from `items` array to test
         * @return {boolean} Whether the item is selected
         */

      }, {
        key: 'isSelected',
        value: function isSelected(item) {
          return this.__selectedMap.has(item);
        }

        /**
         * Returns whether the item is currently selected.
         *
         * @param {number} idx Index from `items` array to test
         * @return {boolean} Whether the item is selected
         */

      }, {
        key: 'isIndexSelected',
        value: function isIndexSelected(idx) {
          return this.isSelected(this.items[idx]);
        }
      }, {
        key: '__deselectChangedIdx',
        value: function __deselectChangedIdx(idx) {
          var _this4 = this;

          var sidx = this.__selectedIndexForItemIndex(idx);
          if (sidx >= 0) {
            var i = 0;
            this.__selectedMap.forEach(function (idx, item) {
              if (sidx == i++) {
                _this4.deselect(item);
              }
            });
          }
        }
      }, {
        key: '__selectedIndexForItemIndex',
        value: function __selectedIndexForItemIndex(idx) {
          var selected = this.__dataLinkedPaths['items.' + idx];
          if (selected) {
            return parseInt(selected.slice('selected.'.length), 10);
          }
        }

        /**
         * Deselects the given item if it is already selected.
         *
         * @param {*} item Item from `items` array to deselect
         */

      }, {
        key: 'deselect',
        value: function deselect(item) {
          var idx = this.__selectedMap.get(item);
          if (idx >= 0) {
            this.__selectedMap.delete(item);
            var sidx = void 0;
            if (this.multi) {
              sidx = this.__selectedIndexForItemIndex(idx);
            }
            this.__updateLinks();
            if (this.multi) {
              this.splice('selected', sidx, 1);
            } else {
              this.selected = this.selectedItem = null;
            }
          }
        }

        /**
         * Deselects the given index if it is already selected.
         *
         * @param {number} idx Index from `items` array to deselect
         */

      }, {
        key: 'deselectIndex',
        value: function deselectIndex(idx) {
          this.deselect(this.items[idx]);
        }

        /**
         * Selects the given item.  When `toggle` is true, this will automatically
         * deselect the item if already selected.
         *
         * @param {*} item Item from `items` array to select
         */

      }, {
        key: 'select',
        value: function select(item) {
          this.selectIndex(this.items.indexOf(item));
        }

        /**
         * Selects the given index.  When `toggle` is true, this will automatically
         * deselect the item if already selected.
         *
         * @param {number} idx Index from `items` array to select
         */

      }, {
        key: 'selectIndex',
        value: function selectIndex(idx) {
          var item = this.items[idx];
          if (!this.isSelected(item)) {
            if (!this.multi) {
              this.__selectedMap.clear();
            }
            this.__selectedMap.set(item, idx);
            this.__updateLinks();
            if (this.multi) {
              this.push('selected', item);
            } else {
              this.selected = this.selectedItem = item;
            }
          } else if (this.toggle) {
            this.deselectIndex(idx);
          }
        }
      }]);

      return ArraySelectorMixin;
    }(elementBase);

    return ArraySelectorMixin;
  });

  // export mixin
  Polymer.ArraySelectorMixin = ArraySelectorMixin;

  /**
   * @constructor
   * @extends {Polymer.Element}
   * @implements {Polymer_ArraySelectorMixin}
   */
  var baseArraySelector = ArraySelectorMixin(Polymer.Element);

  /**
   * Element implementing the `Polymer.ArraySelector` mixin, which records
   * dynamic associations between item paths in a master `items` array and a
   * `selected` array such that path changes to the master array (at the host)
   * element or elsewhere via data-binding) are correctly propagated to items
   * in the selected array and vice-versa.
   *
   * The `items` property accepts an array of user data, and via the
   * `select(item)` and `deselect(item)` API, updates the `selected` property
   * which may be bound to other parts of the application, and any changes to
   * sub-fields of `selected` item(s) will be kept in sync with items in the
   * `items` array.  When `multi` is false, `selected` is a property
   * representing the last selected item.  When `multi` is true, `selected`
   * is an array of multiply selected items.
   *
   * Example:
   *
   * ```html
   * <dom-module id="employee-list">
   *
   *   <template>
   *
   *     <div> Employee list: </div>
   *     <template is="dom-repeat" id="employeeList" items="{{employees}}">
   *         <div>First name: <span>{{item.first}}</span></div>
   *         <div>Last name: <span>{{item.last}}</span></div>
   *         <button on-click="toggleSelection">Select</button>
   *     </template>
   *
   *     <array-selector id="selector" items="{{employees}}" selected="{{selected}}" multi toggle></array-selector>
   *
   *     <div> Selected employees: </div>
   *     <template is="dom-repeat" items="{{selected}}">
   *         <div>First name: <span>{{item.first}}</span></div>
   *         <div>Last name: <span>{{item.last}}</span></div>
   *     </template>
   *
   *   </template>
   *
   * </dom-module>
   * ```
   *
   * ```js
   * Polymer({
   *   is: 'employee-list',
   *   ready() {
   *     this.employees = [
   *         {first: 'Bob', last: 'Smith'},
   *         {first: 'Sally', last: 'Johnson'},
   *         ...
   *     ];
   *   },
   *   toggleSelection(e) {
   *     let item = this.$.employeeList.itemForElement(e.target);
   *     this.$.selector.select(item);
   *   }
   * });
   * ```
   *
   * @polymer
   * @customElement
   * @extends {baseArraySelector}
   * @appliesMixin Polymer.ArraySelectorMixin
   * @memberof Polymer
   * @summary Custom element that links paths between an input `items` array and
   *   an output `selected` item or array based on calls to its selection API.
   */

  var ArraySelector = function (_baseArraySelector) {
    _inherits(ArraySelector, _baseArraySelector);

    function ArraySelector() {
      _classCallCheck(this, ArraySelector);

      return _possibleConstructorReturn(this, (ArraySelector.__proto__ || Object.getPrototypeOf(ArraySelector)).apply(this, arguments));
    }

    _createClass(ArraySelector, null, [{
      key: 'is',

      // Not needed to find template; can be removed once the analyzer
      // can find the tag name from customElements.define call
      get: function get() {
        return 'array-selector';
      }
    }]);

    return ArraySelector;
  }(baseArraySelector);

  customElements.define(ArraySelector.is, ArraySelector);
  Polymer.ArraySelector = ArraySelector;
})();

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

__webpack_require__(61);

__webpack_require__(21);

(function () {
  'use strict';

  var attr = 'include';

  var CustomStyleInterface = window.ShadyCSS.CustomStyleInterface;

  /**
   * Custom element for defining styles in the main document that can take
   * advantage of several special features of Polymer's styling system:
   *
   * - Document styles defined in a custom-style are shimmed to ensure they
   *   do not leak into local DOM when running on browsers without native
   *   Shadow DOM.
   * - Custom properties used by Polymer's shim for cross-scope styling may
   *   be defined in an custom-style. Use the :root selector to define custom
   *   properties that apply to all custom elements.
   *
   * To use, simply wrap an inline `<style>` tag in the main document whose
   * CSS uses these features with a `<custom-style>` element.
   *
   * @customElement
   * @extends HTMLElement
   * @memberof Polymer
   * @summary Custom element for defining styles in the main document that can
   *   take advantage of Polymer's style scoping and custom properties shims.
   */

  var CustomStyle = function (_HTMLElement) {
    _inherits(CustomStyle, _HTMLElement);

    function CustomStyle() {
      _classCallCheck(this, CustomStyle);

      var _this = _possibleConstructorReturn(this, (CustomStyle.__proto__ || Object.getPrototypeOf(CustomStyle)).call(this));

      _this._style = null;
      CustomStyleInterface.addCustomStyle(_this);
      return _this;
    }
    /**
     * Returns the light-DOM `<style>` child this element wraps.  Upon first
     * call any style modules referenced via the `include` attribute will be
     * concatenated to this element's `<style>`.
     *
     * @return {HTMLStyleElement} This element's light-DOM `<style>`
     */


    _createClass(CustomStyle, [{
      key: 'getStyle',
      value: function getStyle() {
        if (this._style) {
          return this._style;
        }
        var style = /** @type {HTMLStyleElement} */this.querySelector('style');
        if (!style) {
          return null;
        }
        this._style = style;
        var include = style.getAttribute(attr);
        if (include) {
          style.removeAttribute(attr);
          style.textContent = Polymer.StyleGather.cssFromModules(include) + style.textContent;
        }
        return this._style;
      }
    }]);

    return CustomStyle;
  }(HTMLElement);

  window.customElements.define('custom-style', CustomStyle);
  Polymer.CustomStyle = CustomStyle;
})();

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(62);

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


(function () {
  /*
  Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
  This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
  The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
  The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
  Code distributed by Google as part of the polymer project is also
  subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
  */
  'use strict';
  var c = !(window.ShadyDOM && window.ShadyDOM.inUse),
      f;function g(a) {
    f = a && a.shimcssproperties ? !1 : c || !(navigator.userAgent.match(/AppleWebKit\/601|Edge\/15/) || !window.CSS || !CSS.supports || !CSS.supports("box-shadow", "0 0 0 var(--foo)"));
  }window.ShadyCSS && void 0 !== window.ShadyCSS.nativeCss ? f = window.ShadyCSS.nativeCss : window.ShadyCSS ? (g(window.ShadyCSS), window.ShadyCSS = void 0) : g(window.WebComponents && window.WebComponents.flags);var h = f;function k(a, b) {
    for (var d in b) {
      null === d ? a.style.removeProperty(d) : a.style.setProperty(d, b[d]);
    }
  };var l = null,
      m = window.HTMLImports && window.HTMLImports.whenReady || null,
      n;function p() {
    var a = q;requestAnimationFrame(function () {
      m ? m(a) : (l || (l = new Promise(function (a) {
        n = a;
      }), "complete" === document.readyState ? n() : document.addEventListener("readystatechange", function () {
        "complete" === document.readyState && n();
      })), l.then(function () {
        a && a();
      }));
    });
  };var r = null,
      q = null;function t() {
    this.customStyles = [];this.enqueued = !1;
  }function u(a) {
    !a.enqueued && q && (a.enqueued = !0, p());
  }t.prototype.c = function (a) {
    a.__seenByShadyCSS || (a.__seenByShadyCSS = !0, this.customStyles.push(a), u(this));
  };t.prototype.b = function (a) {
    if (a.__shadyCSSCachedStyle) return a.__shadyCSSCachedStyle;var b;a.getStyle ? b = a.getStyle() : b = a;return b;
  };
  t.prototype.a = function () {
    for (var a = this.customStyles, b = 0; b < a.length; b++) {
      var d = a[b];if (!d.__shadyCSSCachedStyle) {
        var e = this.b(d);e && (e = e.__appliedElement || e, r && r(e), d.__shadyCSSCachedStyle = e);
      }
    }return a;
  };t.prototype.addCustomStyle = t.prototype.c;t.prototype.getStyleForCustomStyle = t.prototype.b;t.prototype.processStyles = t.prototype.a;
  Object.defineProperties(t.prototype, { transformCallback: { get: function get() {
        return r;
      }, set: function set(a) {
        r = a;
      } }, validateCallback: { get: function get() {
        return q;
      }, set: function set(a) {
        var b = !1;q || (b = !0);q = a;b && u(this);
      } } });var v = new t();window.ShadyCSS || (window.ShadyCSS = { prepareTemplate: function prepareTemplate() {}, styleSubtree: function styleSubtree(a, b) {
      v.a();k(a, b);
    }, styleElement: function styleElement() {
      v.a();
    }, styleDocument: function styleDocument(a) {
      v.a();k(document.body, a);
    }, getComputedStyleValue: function getComputedStyleValue(a, b) {
      return (a = window.getComputedStyle(a).getPropertyValue(b)) ? a.trim() : "";
    }, nativeCss: h, nativeShadow: c });window.ShadyCSS.CustomStyleInterface = v;
}).call(undefined);

//# sourceMappingURL=custom-style-interface.min.js.map

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(9);

(function () {
  'use strict';

  var mutablePropertyChange = void 0;
  (
  /** @suppress {missingProperties} */
  function () {
    mutablePropertyChange = Polymer.MutableData._mutablePropertyChange;
  })();

  /**
   * Legacy element behavior to skip strict dirty-checking for objects and arrays,
   * (always consider them to be "dirty") for use on legacy API Polymer elements.
   *
   * By default, `Polymer.PropertyEffects` performs strict dirty checking on
   * objects, which means that any deep modifications to an object or array will
   * not be propagated unless "immutable" data patterns are used (i.e. all object
   * references from the root to the mutation were changed).
   *
   * Polymer also provides a proprietary data mutation and path notification API
   * (e.g. `notifyPath`, `set`, and array mutation API's) that allow efficient
   * mutation and notification of deep changes in an object graph to all elements
   * bound to the same object graph.
   *
   * In cases where neither immutable patterns nor the data mutation API can be
   * used, applying this mixin will cause Polymer to skip dirty checking for
   * objects and arrays (always consider them to be "dirty").  This allows a
   * user to make a deep modification to a bound object graph, and then either
   * simply re-set the object (e.g. `this.items = this.items`) or call `notifyPath`
   * (e.g. `this.notifyPath('items')`) to update the tree.  Note that all
   * elements that wish to be updated based on deep mutations must apply this
   * mixin or otherwise skip strict dirty checking for objects/arrays.
   *
   * In order to make the dirty check strategy configurable, see
   * `Polymer.OptionalMutableDataBehavior`.
   *
   * Note, the performance characteristics of propagating large object graphs
   * will be worse as opposed to using strict dirty checking with immutable
   * patterns or Polymer's path notification API.
   *
   * @polymerBehavior
   * @memberof Polymer
   * @summary Behavior to skip strict dirty-checking for objects and
   *   arrays
   */
  Polymer.MutableDataBehavior = {

    /**
     * Overrides `Polymer.PropertyEffects` to provide option for skipping
     * strict equality checking for Objects and Arrays.
     *
     * This method pulls the value to dirty check against from the `__dataTemp`
     * cache (rather than the normal `__data` cache) for Objects.  Since the temp
     * cache is cleared at the end of a turn, this implementation allows
     * side-effects of deep object changes to be processed by re-setting the
     * same object (using the temp cache as an in-turn backstop to prevent
     * cycles due to 2-way notification).
     *
     * @param {string} property Property name
     * @param {*} value New property value
     * @param {*} old Previous property value
     * @return {boolean} Whether the property should be considered a change
     * @protected
     */
    _shouldPropertyChange: function _shouldPropertyChange(property, value, old) {
      return mutablePropertyChange(this, property, value, old, true);
    }
  };

  /**
   * Legacy element behavior to add the optional ability to skip strict
   * dirty-checking for objects and arrays (always consider them to be
   * "dirty") by setting a `mutable-data` attribute on an element instance.
   *
   * By default, `Polymer.PropertyEffects` performs strict dirty checking on
   * objects, which means that any deep modifications to an object or array will
   * not be propagated unless "immutable" data patterns are used (i.e. all object
   * references from the root to the mutation were changed).
   *
   * Polymer also provides a proprietary data mutation and path notification API
   * (e.g. `notifyPath`, `set`, and array mutation API's) that allow efficient
   * mutation and notification of deep changes in an object graph to all elements
   * bound to the same object graph.
   *
   * In cases where neither immutable patterns nor the data mutation API can be
   * used, applying this mixin will allow Polymer to skip dirty checking for
   * objects and arrays (always consider them to be "dirty").  This allows a
   * user to make a deep modification to a bound object graph, and then either
   * simply re-set the object (e.g. `this.items = this.items`) or call `notifyPath`
   * (e.g. `this.notifyPath('items')`) to update the tree.  Note that all
   * elements that wish to be updated based on deep mutations must apply this
   * mixin or otherwise skip strict dirty checking for objects/arrays.
   *
   * While this behavior adds the ability to forgo Object/Array dirty checking,
   * the `mutableData` flag defaults to false and must be set on the instance.
   *
   * Note, the performance characteristics of propagating large object graphs
   * will be worse by relying on `mutableData: true` as opposed to using
   * strict dirty checking with immutable patterns or Polymer's path notification
   * API.
   *
   * @polymerBehavior
   * @memberof Polymer
   * @summary Behavior to optionally skip strict dirty-checking for objects and
   *   arrays
   */
  Polymer.OptionalMutableDataBehavior = {

    properties: {
      /**
       * Instance-level flag for configuring the dirty-checking strategy
       * for this element.  When true, Objects and Arrays will skip dirty
       * checking, otherwise strict equality checking will be used.
       */
      mutableData: Boolean
    },

    /**
     * Overrides `Polymer.PropertyEffects` to skip strict equality checking
     * for Objects and Arrays.
     *
     * Pulls the value to dirty check against from the `__dataTemp` cache
     * (rather than the normal `__data` cache) for Objects.  Since the temp
     * cache is cleared at the end of a turn, this implementation allows
     * side-effects of deep object changes to be processed by re-setting the
     * same object (using the temp cache as an in-turn backstop to prevent
     * cycles due to 2-way notification).
     *
     * @param {string} property Property name
     * @param {*} value New property value
     * @param {*} old Previous property value
     * @return {boolean} Whether the property should be considered a change
     * @this {this}
     * @protected
     */
    _shouldPropertyChange: function _shouldPropertyChange(property, value, old) {
      return mutablePropertyChange(this, property, value, old, this.mutableData);
    }
  };
})();

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

__webpack_require__(65);

__webpack_require__(15);

var RegisterHtmlTemplate = __webpack_require__(2);

RegisterHtmlTemplate.register("<dom-module id=app-drawer-layout> <template> <style>:host{display:block;position:relative;z-index:0}:host ::slotted([slot=drawer]){z-index:1}:host([fullbleed]){@apply --layout-fit;}#contentContainer{position:relative;z-index:0;height:100%;transition:var(--app-drawer-layout-content-transition,none)}#contentContainer[drawer-position=left]{margin-left:var(--app-drawer-width,256px)}#contentContainer[drawer-position=right]{margin-right:var(--app-drawer-width,256px)}</style> <slot id=drawerSlot name=drawer></slot> <div id=contentContainer drawer-position$=[[_drawerPosition]]> <slot></slot> </div> <iron-media-query query=\"[[_computeMediaQuery(forceNarrow, responsiveWidth)]]\" on-query-matches-changed=_onQueryMatchesChanged></iron-media-query> </template> </dom-module>");

Polymer({
  is: 'app-drawer-layout',

  behaviors: [Polymer.AppLayoutBehavior],

  properties: {
    /**
     * If true, ignore `responsiveWidth` setting and force the narrow layout.
     */
    forceNarrow: {
      type: Boolean,
      value: false
    },

    /**
     * If the viewport's width is smaller than this value, the panel will change to narrow
     * layout. In the mode the drawer will be closed.
     */
    responsiveWidth: {
      type: String,
      value: '640px'
    },

    /**
     * Returns true if it is in narrow layout. This is useful if you need to show/hide
     * elements based on the layout.
     */
    narrow: {
      type: Boolean,
      reflectToAttribute: true,
      readOnly: true,
      notify: true
    },

    /**
     * If true, the drawer will initially be opened when in narrow layout mode.
     */
    openedWhenNarrow: {
      type: Boolean,
      value: false
    },

    _drawerPosition: {
      type: String
    }
  },

  listeners: {
    'click': '_clickHandler'
  },

  observers: ['_narrowChanged(narrow)'],

  /**
   * A reference to the app-drawer element.
   *
   * @property drawer
   */
  get drawer() {
    return Polymer.dom(this.$.drawerSlot).getDistributedNodes()[0];
  },

  attached: function attached() {
    // Disable drawer transitions until after app-drawer-layout sets the initial opened state.
    var drawer = this.drawer;
    if (drawer) {
      drawer.setAttribute('no-transition', '');
    }
  },

  _clickHandler: function _clickHandler(e) {
    var target = Polymer.dom(e).localTarget;
    if (target && target.hasAttribute('drawer-toggle')) {
      var drawer = this.drawer;
      if (drawer && !drawer.persistent) {
        drawer.toggle();
      }
    }
  },

  _updateLayoutStates: function _updateLayoutStates() {
    var drawer = this.drawer;
    if (!this.isAttached || !drawer) {
      return;
    }

    this._drawerPosition = this.narrow ? null : drawer.position;
    if (this._drawerNeedsReset) {
      if (this.narrow) {
        drawer.opened = this.openedWhenNarrow;
        drawer.persistent = false;
      } else {
        drawer.opened = drawer.persistent = true;
      }
      if (drawer.hasAttribute('no-transition')) {
        // Enable drawer transitions after app-drawer-layout sets the initial opened state.
        Polymer.RenderStatus.afterNextRender(this, function () {
          drawer.removeAttribute('no-transition');
        });
      }
      this._drawerNeedsReset = false;
    }
  },

  _narrowChanged: function _narrowChanged() {
    this._drawerNeedsReset = true;
    this.resetLayout();
  },

  _onQueryMatchesChanged: function _onQueryMatchesChanged(event) {
    this._setNarrow(event.detail.value);
  },

  _computeMediaQuery: function _computeMediaQuery(forceNarrow, responsiveWidth) {
    return forceNarrow ? '(min-width: 0px)' : '(max-width: ' + responsiveWidth + ')';
  }
});

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

Polymer({

  is: 'iron-media-query',

  properties: {

    /**
     * The Boolean return value of the media query.
     */
    queryMatches: {
      type: Boolean,
      value: false,
      readOnly: true,
      notify: true
    },

    /**
     * The CSS media query to evaluate.
     */
    query: {
      type: String,
      observer: 'queryChanged'
    },

    /**
     * If true, the query attribute is assumed to be a complete media query
     * string rather than a single media feature.
     */
    full: {
      type: Boolean,
      value: false
    },

    /**
     * @type {function(MediaQueryList)}
     */
    _boundMQHandler: {
      value: function value() {
        return this.queryHandler.bind(this);
      }
    },

    /**
     * @type {MediaQueryList}
     */
    _mq: {
      value: null
    }
  },

  attached: function attached() {
    this.style.display = 'none';
    this.queryChanged();
  },

  detached: function detached() {
    this._remove();
  },

  _add: function _add() {
    if (this._mq) {
      this._mq.addListener(this._boundMQHandler);
    }
  },

  _remove: function _remove() {
    if (this._mq) {
      this._mq.removeListener(this._boundMQHandler);
    }
    this._mq = null;
  },

  queryChanged: function queryChanged() {
    this._remove();
    var query = this.query;
    if (!query) {
      return;
    }
    if (!this.full && query[0] !== '(') {
      query = '(' + query + ')';
    }
    this._mq = window.matchMedia(query);
    this._add();
    this.queryHandler(this._mq);
  },

  queryHandler: function queryHandler(mq) {
    this._setQueryMatches(mq.matches);
  }

});

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

__webpack_require__(5);

__webpack_require__(4);

__webpack_require__(15);

var RegisterHtmlTemplate = __webpack_require__(2);

RegisterHtmlTemplate.register("<dom-module id=app-header> <template> <style>:host{position:relative;display:block;transition-timing-function:linear;transition-property:-webkit-transform;transition-property:transform}:host::before{position:absolute;right:0;bottom:-5px;left:0;width:100%;height:5px;content:\"\";transition:opacity .4s;pointer-events:none;opacity:0;box-shadow:inset 0 5px 6px -3px rgba(0,0,0,.4);will-change:opacity;@apply --app-header-shadow;}:host([shadow])::before{opacity:1}#background{@apply --layout-fit;overflow:hidden}#backgroundFrontLayer,#backgroundRearLayer{@apply --layout-fit;height:100%;pointer-events:none;background-size:cover}#backgroundFrontLayer{@apply --app-header-background-front-layer;}#backgroundRearLayer{opacity:0;@apply --app-header-background-rear-layer;}#contentContainer{position:relative;width:100%;height:100%}:host([disabled]),:host([disabled]) #backgroundFrontLayer,:host([disabled]) #backgroundRearLayer,:host([disabled])::after,:host([silent-scroll]),:host([silent-scroll]) #backgroundFrontLayer,:host([silent-scroll]) #backgroundRearLayer,:host([silent-scroll])::after{transition:none!important}:host([disabled]) ::slotted([sticky]),:host([disabled]) ::slotted(app-toolbar:first-of-type),:host([silent-scroll]) ::slotted([sticky]),:host([silent-scroll]) ::slotted(app-toolbar:first-of-type){transition:none!important}</style> <div id=contentContainer> <slot id=slot></slot> </div> </template> </dom-module>");

Polymer({
  is: 'app-header',

  behaviors: [Polymer.AppScrollEffectsBehavior, Polymer.AppLayoutBehavior],

  properties: {
    /**
     * If true, the header will automatically collapse when scrolling down.
     * That is, the `sticky` element remains visible when the header is fully condensed
     * whereas the rest of the elements will collapse below `sticky` element.
     *
     * By default, the `sticky` element is the first toolbar in the light DOM:
     *
     *```html
     * <app-header condenses>
     *   <app-toolbar>This toolbar remains on top</app-toolbar>
     *   <app-toolbar></app-toolbar>
     *   <app-toolbar></app-toolbar>
     * </app-header>
     * ```
     *
     * Additionally, you can specify which toolbar or element remains visible in condensed mode
     * by adding the `sticky` attribute to that element. For example: if we want the last
     * toolbar to remain visible, we can add the `sticky` attribute to it.
     *
     *```html
     * <app-header condenses>
     *   <app-toolbar></app-toolbar>
     *   <app-toolbar></app-toolbar>
     *   <app-toolbar sticky>This toolbar remains on top</app-toolbar>
     * </app-header>
     * ```
     *
     * Note the `sticky` element must be a direct child of `app-header`.
     */
    condenses: {
      type: Boolean,
      value: false
    },

    /**
     * Mantains the header fixed at the top so it never moves away.
     */
    fixed: {
      type: Boolean,
      value: false
    },

    /**
     * Slides back the header when scrolling back up.
     */
    reveals: {
      type: Boolean,
      value: false
    },

    /**
     * Displays a shadow below the header.
     */
    shadow: {
      type: Boolean,
      reflectToAttribute: true,
      value: false
    }
  },

  observers: ['_configChanged(isAttached, condenses, fixed)'],

  /**
   * A cached offsetHeight of the current element.
   *
   * @type {number}
   */
  _height: 0,

  /**
   * The distance in pixels the header will be translated to when scrolling.
   *
   * @type {number}
   */
  _dHeight: 0,

  /**
   * The offsetTop of `_stickyEl`
   *
   * @type {number}
   */
  _stickyElTop: 0,

  /**
   * A reference to the element that remains visible when the header condenses.
   *
   * @type {HTMLElement}
   */
  _stickyElRef: null,

  /**
   * The header's top value used for the `transformY`
   *
   * @type {number}
   */
  _top: 0,

  /**
   * The current scroll progress.
   *
   * @type {number}
   */
  _progress: 0,

  _wasScrollingDown: false,
  _initScrollTop: 0,
  _initTimestamp: 0,
  _lastTimestamp: 0,
  _lastScrollTop: 0,

  /**
   * The distance the header is allowed to move away.
   *
   * @type {number}
   */
  get _maxHeaderTop() {
    return this.fixed ? this._dHeight : this._height + 5;
  },

  /**
   * Returns a reference to the sticky element.
   *
   * @return {HTMLElement}?
   */
  get _stickyEl() {
    if (this._stickyElRef) {
      return this._stickyElRef;
    }
    var nodes = Polymer.dom(this.$.slot).getDistributedNodes();
    // Get the element with the sticky attribute on it or the first element in the light DOM.
    for (var i = 0, node; node = nodes[i]; i++) {
      if (node.nodeType === Node.ELEMENT_NODE) {
        if (node.hasAttribute('sticky')) {
          this._stickyElRef = node;
          break;
        } else if (!this._stickyElRef) {
          this._stickyElRef = node;
        }
      }
    }
    return this._stickyElRef;
  },

  _configChanged: function _configChanged() {
    this.resetLayout();
    this._notifyLayoutChanged();
  },

  _updateLayoutStates: function _updateLayoutStates() {
    if (this.offsetWidth === 0 && this.offsetHeight === 0) {
      return;
    }
    var scrollTop = this._clampedScrollTop;
    var firstSetup = this._height === 0 || scrollTop === 0;
    var currentDisabled = this.disabled;
    this._height = this.offsetHeight;
    this._stickyElRef = null;
    this.disabled = true;
    // prepare for measurement
    if (!firstSetup) {
      this._updateScrollState(0, true);
    }
    if (this._mayMove()) {
      this._dHeight = this._stickyEl ? this._height - this._stickyEl.offsetHeight : 0;
    } else {
      this._dHeight = 0;
    }
    this._stickyElTop = this._stickyEl ? this._stickyEl.offsetTop : 0;
    this._setUpEffect();
    if (firstSetup) {
      this._updateScrollState(scrollTop, true);
    } else {
      this._updateScrollState(this._lastScrollTop, true);
      this._layoutIfDirty();
    }
    // restore no transition
    this.disabled = currentDisabled;
  },

  /**
   * Updates the scroll state.
   *
   * @param {number} scrollTop
   * @param {boolean=} forceUpdate (default: false)
   */
  _updateScrollState: function _updateScrollState(scrollTop, forceUpdate) {
    if (this._height === 0) {
      return;
    }
    var progress = 0;
    var top = 0;
    var lastTop = this._top;
    var lastScrollTop = this._lastScrollTop;
    var maxHeaderTop = this._maxHeaderTop;
    var dScrollTop = scrollTop - this._lastScrollTop;
    var absDScrollTop = Math.abs(dScrollTop);
    var isScrollingDown = scrollTop > this._lastScrollTop;
    var now = performance.now();

    if (this._mayMove()) {
      top = this._clamp(this.reveals ? lastTop + dScrollTop : scrollTop, 0, maxHeaderTop);
    }
    if (scrollTop >= this._dHeight) {
      top = this.condenses && !this.fixed ? Math.max(this._dHeight, top) : top;
      this.style.transitionDuration = '0ms';
    }
    if (this.reveals && !this.disabled && absDScrollTop < 100) {
      // set the initial scroll position
      if (now - this._initTimestamp > 300 || this._wasScrollingDown !== isScrollingDown) {
        this._initScrollTop = scrollTop;
        this._initTimestamp = now;
      }
      if (scrollTop >= maxHeaderTop) {
        // check if the header is allowed to snap
        if (Math.abs(this._initScrollTop - scrollTop) > 30 || absDScrollTop > 10) {
          if (isScrollingDown && scrollTop >= maxHeaderTop) {
            top = maxHeaderTop;
          } else if (!isScrollingDown && scrollTop >= this._dHeight) {
            top = this.condenses && !this.fixed ? this._dHeight : 0;
          }
          var scrollVelocity = dScrollTop / (now - this._lastTimestamp);
          this.style.transitionDuration = this._clamp((top - lastTop) / scrollVelocity, 0, 300) + 'ms';
        } else {
          top = this._top;
        }
      }
    }
    if (this._dHeight === 0) {
      progress = scrollTop > 0 ? 1 : 0;
    } else {
      progress = top / this._dHeight;
    }
    if (!forceUpdate) {
      this._lastScrollTop = scrollTop;
      this._top = top;
      this._wasScrollingDown = isScrollingDown;
      this._lastTimestamp = now;
    }
    if (forceUpdate || progress !== this._progress || lastTop !== top || scrollTop === 0) {
      this._progress = progress;
      this._runEffects(progress, top);
      this._transformHeader(top);
    }
  },

  /**
   * Returns true if the current header is allowed to move as the user scrolls.
   *
   * @return {boolean}
   */
  _mayMove: function _mayMove() {
    return this.condenses || !this.fixed;
  },

  /**
   * Returns true if the current header will condense based on the size of the header
   * and the `consenses` property.
   *
   * @return {boolean}
   */
  willCondense: function willCondense() {
    return this._dHeight > 0 && this.condenses;
  },

  /**
   * Returns true if the current element is on the screen.
   * That is, visible in the current viewport.
   *
   * @method isOnScreen
   * @return {boolean}
   */
  isOnScreen: function isOnScreen() {
    return this._height !== 0 && this._top < this._height;
  },

  /**
   * Returns true if there's content below the current element.
   *
   * @method isContentBelow
   * @return {boolean}
   */
  isContentBelow: function isContentBelow() {
    return this._top === 0 ? this._clampedScrollTop > 0 : this._clampedScrollTop - this._maxHeaderTop >= 0;
  },

  /**
   * Transforms the header.
   *
   * @param {number} y
   */
  _transformHeader: function _transformHeader(y) {
    this.translate3d(0, -y + 'px', 0);
    if (this._stickyEl) {
      this.translate3d(0, this.condenses && y >= this._stickyElTop ? Math.min(y, this._dHeight) - this._stickyElTop + 'px' : 0, 0, this._stickyEl);
    }
  },

  _clamp: function _clamp(v, min, max) {
    return Math.min(max, Math.max(min, v));
  },

  _ensureBgContainers: function _ensureBgContainers() {
    if (!this._bgContainer) {
      this._bgContainer = document.createElement('div');
      this._bgContainer.id = 'background';
      this._bgRear = document.createElement('div');
      this._bgRear.id = 'backgroundRearLayer';
      this._bgContainer.appendChild(this._bgRear);
      this._bgFront = document.createElement('div');
      this._bgFront.id = 'backgroundFrontLayer';
      this._bgContainer.appendChild(this._bgFront);
      Polymer.dom(this.root).insertBefore(this._bgContainer, this.$.contentContainer);
    }
  },

  _getDOMRef: function _getDOMRef(id) {
    switch (id) {
      case 'backgroundFrontLayer':
        this._ensureBgContainers();
        return this._bgFront;
      case 'backgroundRearLayer':
        this._ensureBgContainers();
        return this._bgRear;
      case 'background':
        this._ensureBgContainers();
        return this._bgContainer;
      case 'mainTitle':
        return Polymer.dom(this).querySelector('[main-title]');
      case 'condensedTitle':
        return Polymer.dom(this).querySelector('[condensed-title]');
    }
    return null;
  },

  /**
   * Returns an object containing the progress value of the scroll effects
   * and the top position of the header.
   *
   * @method getScrollState
   * @return {Object}
   */
  getScrollState: function getScrollState() {
    return { progress: this._progress, top: this._top };
  }
});

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

Polymer.AppLayout = Polymer.AppLayout || {};

Polymer.AppLayout._scrollEffects = Polymer.AppLayout._scrollEffects || {};

Polymer.AppLayout.scrollTimingFunction = function easeOutQuad(t, b, c, d) {
  t /= d;
  return -c * t * (t - 2) + b;
};

/**
 * Registers a scroll effect to be used in elements that implement the
 * `Polymer.AppScrollEffectsBehavior` behavior.
 *
 * @param {string} effectName The effect name.
 * @param {Object} effectDef The effect definition.
 */
Polymer.AppLayout.registerEffect = function registerEffect(effectName, effectDef) {
  if (Polymer.AppLayout._scrollEffects[effectName] != null) {
    throw new Error('effect `' + effectName + '` is already registered.');
  }
  Polymer.AppLayout._scrollEffects[effectName] = effectDef;
};

Polymer.AppLayout.queryAllRoot = function (selector, root) {
  var queue = [root];
  var matches = [];

  while (queue.length > 0) {
    var node = queue.shift();
    matches.push.apply(matches, node.querySelectorAll(selector));
    for (i = 0; node.children[i]; i++) {
      if (node.children[i].shadowRoot) {
        queue.push(node.children[i].shadowRoot);
      }
    }
  }
  return matches;
};

/**
 * Scrolls to a particular set of coordinates in a scroll target.
 * If the scroll target is not defined, then it would use the main document as the target.
 *
 * To scroll in a smooth fashion, you can set the option `behavior: 'smooth'`. e.g.
 *
 * ```js
 * Polymer.AppLayout.scroll({top: 0, behavior: 'smooth'});
 * ```
 *
 * To scroll in a silent mode, without notifying scroll changes to any app-layout elements,
 * you can set the option `behavior: 'silent'`. This is particularly useful we you are using
 * `app-header` and you desire to scroll to the top of a scrolling region without running
 * scroll effects. e.g.
 *
 * ```js
 * Polymer.AppLayout.scroll({top: 0, behavior: 'silent'});
 * ```
 *
 * @param {Object} options {top: Number, left: Number, behavior: String(smooth | silent)}
 */
Polymer.AppLayout.scroll = function scroll(options) {
  options = options || {};

  var docEl = document.documentElement;
  var target = options.target || docEl;
  var hasNativeScrollBehavior = 'scrollBehavior' in target.style && target.scroll;
  var scrollClassName = 'app-layout-silent-scroll';
  var scrollTop = options.top || 0;
  var scrollLeft = options.left || 0;
  var scrollTo = target === docEl ? window.scrollTo : function scrollTo(scrollLeft, scrollTop) {
    target.scrollLeft = scrollLeft;
    target.scrollTop = scrollTop;
  };

  if (options.behavior === 'smooth') {

    if (hasNativeScrollBehavior) {

      target.scroll(options);
    } else {

      var timingFn = Polymer.AppLayout.scrollTimingFunction;
      var startTime = Date.now();
      var currentScrollTop = target === docEl ? window.pageYOffset : target.scrollTop;
      var currentScrollLeft = target === docEl ? window.pageXOffset : target.scrollLeft;
      var deltaScrollTop = scrollTop - currentScrollTop;
      var deltaScrollLeft = scrollLeft - currentScrollLeft;
      var duration = 300;
      var updateFrame = function updateFrame() {
        var now = Date.now();
        var elapsedTime = now - startTime;

        if (elapsedTime < duration) {
          scrollTo(timingFn(elapsedTime, currentScrollLeft, deltaScrollLeft, duration), timingFn(elapsedTime, currentScrollTop, deltaScrollTop, duration));
          requestAnimationFrame(updateFrame);
        } else {
          scrollTo(scrollLeft, scrollTop);
        }
      }.bind(this);

      updateFrame();
    }
  } else if (options.behavior === 'silent') {
    var headers = Polymer.AppLayout.queryAllRoot('app-header', document.body);

    headers.forEach(function (header) {
      header.setAttribute('silent-scroll', '');
    });

    // Browsers keep the scroll momentum even if the bottom of the scrolling content
    // was reached. This means that calling scroll({top: 0, behavior: 'silent'}) when
    // the momentum is still going will result in more scroll events and thus scroll effects.
    // This seems to only apply when using document scrolling.
    // Therefore, when should we remove the class from the document element?

    window.cancelAnimationFrame(Polymer.AppLayout._scrollTimer);

    Polymer.AppLayout._scrollTimer = window.requestAnimationFrame(function () {
      headers.forEach(function (header) {
        header.removeAttribute('silent-scroll');
      });
      Polymer.AppLayout._scrollTimer = null;
    });

    scrollTo(scrollLeft, scrollTop);
  } else {

    scrollTo(scrollLeft, scrollTop);
  }
};

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

__webpack_require__(5);

__webpack_require__(15);

var RegisterHtmlTemplate = __webpack_require__(2);

RegisterHtmlTemplate.register("<dom-module id=app-header-layout> <template> <style>:host{display:block;position:relative;z-index:0}#wrapper ::slotted([slot=header]){@apply --layout-fixed-top;z-index:1}#wrapper.initializing ::slotted([slot=header]){position:relative}:host([has-scrolling-region]){height:100%}:host([has-scrolling-region]) #wrapper ::slotted([slot=header]){position:absolute}:host([has-scrolling-region]) #wrapper.initializing ::slotted([slot=header]){position:relative}:host([has-scrolling-region]) #wrapper #contentContainer{@apply --layout-fit;overflow-y:auto;-webkit-overflow-scrolling:touch}:host([has-scrolling-region]) #wrapper.initializing #contentContainer{position:relative}:host([fullbleed]){@apply --layout-vertical;@apply --layout-fit;}:host([fullbleed]) #wrapper,:host([fullbleed]) #wrapper #contentContainer{@apply --layout-vertical;@apply --layout-flex;}#contentContainer{position:relative;z-index:0}</style> <div id=wrapper class=initializing> <slot id=headerSlot name=header></slot> <div id=contentContainer> <slot></slot> </div> </div> </template> </dom-module>");

Polymer({
  is: 'app-header-layout',

  behaviors: [Polymer.AppLayoutBehavior],

  properties: {
    /**
     * If true, the current element will have its own scrolling region.
     * Otherwise, it will use the document scroll to control the header.
     */
    hasScrollingRegion: {
      type: Boolean,
      value: false,
      reflectToAttribute: true
    }
  },

  observers: ['resetLayout(isAttached, hasScrollingRegion)'],

  /**
   * A reference to the app-header element.
   *
   * @property header
   */
  get header() {
    return Polymer.dom(this.$.headerSlot).getDistributedNodes()[0];
  },

  _updateLayoutStates: function _updateLayoutStates() {
    var header = this.header;
    if (!this.isAttached || !header) {
      return;
    }
    // Remove the initializing class, which staticly positions the header and the content
    // until the height of the header can be read.
    this.$.wrapper.classList.remove('initializing');
    // Update scroll target.
    header.scrollTarget = this.hasScrollingRegion ? this.$.contentContainer : this.ownerDocument.documentElement;
    // Get header height here so that style reads are batched together before style writes
    // (i.e. getBoundingClientRect() below).
    var headerHeight = header.offsetHeight;
    // Update the header position.
    if (!this.hasScrollingRegion) {
      requestAnimationFrame(function () {
        var rect = this.getBoundingClientRect();
        var rightOffset = document.documentElement.clientWidth - rect.right;
        header.style.left = rect.left + 'px';
        header.style.right = rightOffset + 'px';
      }.bind(this));
    } else {
      header.style.left = '';
      header.style.right = '';
    }
    // Update the content container position.
    var containerStyle = this.$.contentContainer.style;
    if (header.fixed && !header.condenses && this.hasScrollingRegion) {
      // If the header size does not change and we're using a scrolling region, exclude
      // the header area from the scrolling region so that the header doesn't overlap
      // the scrollbar.
      containerStyle.marginTop = headerHeight + 'px';
      containerStyle.paddingTop = '';
    } else {
      containerStyle.paddingTop = headerHeight + 'px';
      containerStyle.marginTop = '';
    }
  }

});

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(25);

__webpack_require__(70);

__webpack_require__(71);

__webpack_require__(28);

__webpack_require__(72);

__webpack_require__(27);

__webpack_require__(26);

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(4);

/**
 * Upon scrolling past a threshold, fade in the rear background layer and fade out the front
 * background layer (opacity CSS transitioned over time).
 *
 *
 */
Polymer.AppLayout.registerEffect('fade-background', {
  /** @this Polymer.AppLayout.ElementWithBackground */
  setUp: function setUp(config) {
    var fx = {};
    var duration = config.duration || '0.5s';
    fx.backgroundFrontLayer = this._getDOMRef('backgroundFrontLayer');
    fx.backgroundRearLayer = this._getDOMRef('backgroundRearLayer');
    fx.backgroundFrontLayer.style.willChange = 'opacity';
    fx.backgroundFrontLayer.style.webkitTransform = 'translateZ(0)';
    fx.backgroundFrontLayer.style.transitionProperty = 'opacity';
    fx.backgroundFrontLayer.style.transitionDuration = duration;
    fx.backgroundRearLayer.style.willChange = 'opacity';
    fx.backgroundRearLayer.style.webkitTransform = 'translateZ(0)';
    fx.backgroundRearLayer.style.transitionProperty = 'opacity';
    fx.backgroundRearLayer.style.transitionDuration = duration;
    this._fxFadeBackground = fx;
  },
  /** @this Polymer.AppLayout.ElementWithBackground */
  run: function run(p, y) {
    var fx = this._fxFadeBackground;
    if (p >= 1) {
      fx.backgroundFrontLayer.style.opacity = 0;
      fx.backgroundRearLayer.style.opacity = 1;
    } else {
      fx.backgroundFrontLayer.style.opacity = 1;
      fx.backgroundRearLayer.style.opacity = 0;
    }
  },
  /** @this Polymer.AppLayout.ElementWithBackground */
  tearDown: function tearDown() {
    delete this._fxFadeBackground;
  }
});

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(4);

__webpack_require__(26);

__webpack_require__(27);

__webpack_require__(25);

__webpack_require__(28);

/**
 * Shorthand for the waterfall, resize-title, blend-background, and parallax-background effects.
 */
Polymer.AppLayout.registerEffect('material', {
  /**
   * @this Polymer.AppLayout.ElementWithBackground
   */
  setUp: function setUp() {
    this.effects = 'waterfall resize-title blend-background parallax-background';
    return false;
  }
});

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(4);

/**
 * Upon scrolling past a threshold, CSS transition the font size of a designated title element
 * between two values.
 */
Polymer.AppLayout.registerEffect('resize-snapped-title', {
  /**
   * @this Polymer.AppLayout.ElementWithBackground
   */
  setUp: function setUp(config) {
    var title = this._getDOMRef('mainTitle');
    var condensedTitle = this._getDOMRef('condensedTitle');
    var duration = config.duration || '0.2s';
    var fx = {};

    if (!condensedTitle) {
      console.warn('Scroll effect `resize-snapped-title`: undefined `condensed-title`');
      return false;
    }
    if (!title) {
      console.warn('Scroll effect `resize-snapped-title`: undefined `main-title`');
      return false;
    }

    title.style.transitionProperty = 'opacity';
    title.style.transitionDuration = duration;
    condensedTitle.style.transitionProperty = 'opacity';
    condensedTitle.style.transitionDuration = duration;
    fx.condensedTitle = condensedTitle;
    fx.title = title;
    this._fxResizeSnappedTitle = fx;
  },
  /** @this Polymer.AppLayout.ElementWithBackground */
  run: function run(p, y) {
    var fx = this._fxResizeSnappedTitle;
    if (p > 0) {
      fx.title.style.opacity = 0;
      fx.condensedTitle.style.opacity = 1;
    } else {
      fx.title.style.opacity = 1;
      fx.condensedTitle.style.opacity = 0;
    }
  },
  /** @this Polymer.AppLayout.ElementWithBackground */
  tearDown: function tearDown() {
    var fx = this._fxResizeSnappedTitle;
    fx.title.style.transition = '';
    fx.condensedTitle.style.transition = '';
    delete this._fxResizeSnappedTitle;
  }
});

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

__webpack_require__(5);

var RegisterHtmlTemplate = __webpack_require__(2);

RegisterHtmlTemplate.register("<dom-module id=app-toolbar> <template> <style>:host{@apply --layout-horizontal;@apply --layout-center;position:relative;height:64px;padding:0 16px;pointer-events:none;font-size:var(--app-toolbar-font-size,20px)}:host ::slotted(*){pointer-events:auto}:host ::slotted(paper-icon-button){font-size:0}:host ::slotted([condensed-title]),:host ::slotted([main-title]){pointer-events:none;@apply --layout-flex;}:host ::slotted([bottom-item]){position:absolute;right:0;bottom:0;left:0}:host ::slotted([top-item]){position:absolute;top:0;right:0;left:0}:host ::slotted([spacer]){margin-left:64px}</style> <slot></slot> </template> </dom-module>");

Polymer({
  is: 'app-toolbar'
});

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

__webpack_require__(75);

__webpack_require__(76);

__webpack_require__(77);

var RegisterHtmlTemplate = __webpack_require__(2);

RegisterHtmlTemplate.register("<dom-module id=app-location> <template> <iron-query-params params-string={{__query}} params-object={{queryParams}}> </iron-query-params> <iron-location path={{__path}} query={{__query}} hash={{__hash}} url-space-regex={{urlSpaceRegex}}> </iron-location> </template> </dom-module>");

(function () {
  'use strict';

  Polymer({
    is: 'app-location',

    properties: {
      /**
       * A model representing the deserialized path through the route tree, as
       * well as the current queryParams.
       */
      route: {
        type: Object,
        notify: true
      },

      /**
       * In many scenarios, it is convenient to treat the `hash` as a stand-in
       * alternative to the `path`. For example, if deploying an app to a static
       * web server (e.g., Github Pages) - where one does not have control over
       * server-side routing - it is usually a better experience to use the hash
       * to represent paths through one's app.
       *
       * When this property is set to true, the `hash` will be used in place of
        * the `path` for generating a `route`.
       */
      useHashAsPath: {
        type: Boolean,
        value: false
      },

      /**
       * A regexp that defines the set of URLs that should be considered part
       * of this web app.
       *
       * Clicking on a link that matches this regex won't result in a full page
       * navigation, but will instead just update the URL state in place.
       *
       * This regexp is given everything after the origin in an absolute
       * URL. So to match just URLs that start with /search/ do:
       *     url-space-regex="^/search/"
       *
       * @type {string|RegExp}
       */
      urlSpaceRegex: {
        type: String,
        notify: true
      },

      /**
       * A set of key/value pairs that are universally accessible to branches
       * of the route tree.
       */
      __queryParams: {
        type: Object
      },

      /**
       * The pathname component of the current URL.
       */
      __path: {
        type: String
      },

      /**
       * The query string portion of the current URL.
       */
      __query: {
        type: String
      },

      /**
       * The hash portion of the current URL.
       */
      __hash: {
        type: String
      },

      /**
       * The route path, which will be either the hash or the path, depending
       * on useHashAsPath.
       */
      path: {
        type: String,
        observer: '__onPathChanged'
      },

      /**
       * Whether or not the ready function has been called.
       */
      _isReady: {
        type: Boolean
      }
    },

    behaviors: [Polymer.AppRouteConverterBehavior],

    observers: ['__computeRoutePath(useHashAsPath, __hash, __path)'],

    ready: function ready() {
      this._isReady = true;
    },

    __computeRoutePath: function __computeRoutePath() {
      this.path = this.useHashAsPath ? this.__hash : this.__path;
    },

    __onPathChanged: function __onPathChanged() {
      if (!this._isReady) {
        return;
      }

      if (this.useHashAsPath) {
        this.__hash = this.path;
      } else {
        this.__path = this.path;
      }
    }
  });
})();

/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

(function () {
  'use strict';

  var workingURL;

  var urlDoc, urlBase, anchor;

  /**
   * @param {string} path
   * @param {string=} base
   * @return {!URL|!HTMLAnchorElement}
   */
  function resolveURL(path, base) {
    if (workingURL === undefined) {
      workingURL = false;
      try {
        var u = new URL('b', 'http://a');
        u.pathname = 'c%20d';
        workingURL = u.href === 'http://a/c%20d';
        workingURL = workingURL && new URL('http://www.google.com/?foo bar').href === 'http://www.google.com/?foo%20bar';
      } catch (e) {}
    }
    if (workingURL) {
      return new URL(path, base);
    }
    if (!urlDoc) {
      urlDoc = document.implementation.createHTMLDocument('url');
      urlBase = urlDoc.createElement('base');
      urlDoc.head.appendChild(urlBase);
      anchor = /** @type {HTMLAnchorElement}*/urlDoc.createElement('a');
    }
    urlBase.href = base;
    anchor.href = path.replace(/ /g, '%20');
    return anchor;
  }

  Polymer({
    is: 'iron-location',

    properties: {
      /**
       * The pathname component of the URL.
       */
      path: {
        type: String,
        notify: true,
        value: function value() {
          return window.decodeURIComponent(window.location.pathname);
        }
      },

      /**
       * The query string portion of the URL.
       */
      query: {
        type: String,
        notify: true,
        value: function value() {
          return window.location.search.slice(1);
        }
      },

      /**
       * The hash component of the URL.
       */
      hash: {
        type: String,
        notify: true,
        value: function value() {
          return window.decodeURIComponent(window.location.hash.slice(1));
        }
      },

      /**
       * If the user was on a URL for less than `dwellTime` milliseconds, it
       * won't be added to the browser's history, but instead will be replaced
       * by the next entry.
       *
       * This is to prevent large numbers of entries from clogging up the user's
       * browser history. Disable by setting to a negative number.
       */
      dwellTime: {
        type: Number,
        value: 2000
      },

      /**
       * A regexp that defines the set of URLs that should be considered part
       * of this web app.
       *
       * Clicking on a link that matches this regex won't result in a full page
       * navigation, but will instead just update the URL state in place.
       *
       * This regexp is given everything after the origin in an absolute
       * URL. So to match just URLs that start with /search/ do:
       *     url-space-regex="^/search/"
       *
       * @type {string|RegExp}
       */
      urlSpaceRegex: {
        type: String,
        value: ''
      },

      /**
       * urlSpaceRegex, but coerced into a regexp.
       *
       * @type {RegExp}
       */
      _urlSpaceRegExp: {
        computed: '_makeRegExp(urlSpaceRegex)'
      },

      _lastChangedAt: {
        type: Number
      },

      _initialized: {
        type: Boolean,
        value: false
      }
    },

    hostAttributes: {
      hidden: true
    },

    observers: ['_updateUrl(path, query, hash)'],

    attached: function attached() {
      this.listen(window, 'hashchange', '_hashChanged');
      this.listen(window, 'location-changed', '_urlChanged');
      this.listen(window, 'popstate', '_urlChanged');
      this.listen( /** @type {!HTMLBodyElement} */document.body, 'click', '_globalOnClick');
      // Give a 200ms grace period to make initial redirects without any
      // additions to the user's history.
      this._lastChangedAt = window.performance.now() - (this.dwellTime - 200);
      this._initialized = true;

      this._urlChanged();
    },

    detached: function detached() {
      this.unlisten(window, 'hashchange', '_hashChanged');
      this.unlisten(window, 'location-changed', '_urlChanged');
      this.unlisten(window, 'popstate', '_urlChanged');
      this.unlisten( /** @type {!HTMLBodyElement} */document.body, 'click', '_globalOnClick');
      this._initialized = false;
    },

    _hashChanged: function _hashChanged() {
      this.hash = window.decodeURIComponent(window.location.hash.substring(1));
    },

    _urlChanged: function _urlChanged() {
      // We want to extract all info out of the updated URL before we
      // try to write anything back into it.
      //
      // i.e. without _dontUpdateUrl we'd overwrite the new path with the old
      // one when we set this.hash. Likewise for query.
      this._dontUpdateUrl = true;
      this._hashChanged();
      this.path = window.decodeURIComponent(window.location.pathname);
      this.query = window.location.search.substring(1);
      this._dontUpdateUrl = false;
      this._updateUrl();
    },

    _getUrl: function _getUrl() {
      var partiallyEncodedPath = window.encodeURI(this.path).replace(/\#/g, '%23').replace(/\?/g, '%3F');
      var partiallyEncodedQuery = '';
      if (this.query) {
        partiallyEncodedQuery = '?' + this.query.replace(/\#/g, '%23');
      }
      var partiallyEncodedHash = '';
      if (this.hash) {
        partiallyEncodedHash = '#' + window.encodeURI(this.hash);
      }
      return partiallyEncodedPath + partiallyEncodedQuery + partiallyEncodedHash;
    },

    _updateUrl: function _updateUrl() {
      if (this._dontUpdateUrl || !this._initialized) {
        return;
      }

      if (this.path === window.decodeURIComponent(window.location.pathname) && this.query === window.location.search.substring(1) && this.hash === window.decodeURIComponent(window.location.hash.substring(1))) {
        // Nothing to do, the current URL is a representation of our properties.
        return;
      }

      var newUrl = this._getUrl();
      // Need to use a full URL in case the containing page has a base URI.
      var fullNewUrl = resolveURL(newUrl, window.location.protocol + '//' + window.location.host).href;
      var now = window.performance.now();
      var shouldReplace = this._lastChangedAt + this.dwellTime > now;
      this._lastChangedAt = now;

      if (shouldReplace) {
        window.history.replaceState({}, '', fullNewUrl);
      } else {
        window.history.pushState({}, '', fullNewUrl);
      }

      this.fire('location-changed', {}, { node: window });
    },

    /**
     * A necessary evil so that links work as expected. Does its best to
     * bail out early if possible.
     *
     * @param {MouseEvent} event .
     */
    _globalOnClick: function _globalOnClick(event) {
      // If another event handler has stopped this event then there's nothing
      // for us to do. This can happen e.g. when there are multiple
      // iron-location elements in a page.
      if (event.defaultPrevented) {
        return;
      }

      var href = this._getSameOriginLinkHref(event);

      if (!href) {
        return;
      }

      event.preventDefault();

      // If the navigation is to the current page we shouldn't add a history
      // entry or fire a change event.
      if (href === window.location.href) {
        return;
      }

      window.history.pushState({}, '', href);
      this.fire('location-changed', {}, { node: window });
    },

    /**
     * Returns the absolute URL of the link (if any) that this click event
     * is clicking on, if we can and should override the resulting full
     * page navigation. Returns null otherwise.
     *
     * @param {MouseEvent} event .
     * @return {string?} .
     */
    _getSameOriginLinkHref: function _getSameOriginLinkHref(event) {
      // We only care about left-clicks.
      if (event.button !== 0) {
        return null;
      }

      // We don't want modified clicks, where the intent is to open the page
      // in a new tab.
      if (event.metaKey || event.ctrlKey) {
        return null;
      }

      var eventPath = Polymer.dom(event).path;
      var anchor = null;

      for (var i = 0; i < eventPath.length; i++) {
        var element = eventPath[i];

        if (element.tagName === 'A' && element.href) {
          anchor = element;
          break;
        }
      }

      // If there's no link there's nothing to do.
      if (!anchor) {
        return null;
      }

      // Target blank is a new tab, don't intercept.
      if (anchor.target === '_blank') {
        return null;
      }

      // If the link is for an existing parent frame, don't intercept.
      if ((anchor.target === '_top' || anchor.target === '_parent') && window.top !== window) {
        return null;
      }

      var href = anchor.href;

      // It only makes sense for us to intercept same-origin navigations.
      // pushState/replaceState don't work with cross-origin links.
      var url;

      if (document.baseURI != null) {
        url = resolveURL(href, /** @type {string} */document.baseURI);
      } else {
        url = resolveURL(href);
      }

      var origin;

      // IE Polyfill
      if (window.location.origin) {
        origin = window.location.origin;
      } else {
        origin = window.location.protocol + '//' + window.location.host;
      }

      var urlOrigin;

      if (url.origin) {
        urlOrigin = url.origin;
      } else {
        urlOrigin = url.protocol + '//' + url.host;
      }

      if (urlOrigin !== origin) {
        return null;
      }

      var normalizedHref = url.pathname + url.search + url.hash;

      // pathname should start with '/', but may not if `new URL` is not supported
      if (normalizedHref[0] !== '/') {
        normalizedHref = '/' + normalizedHref;
      }

      // If we've been configured not to handle this url... don't handle it!
      if (this._urlSpaceRegExp && !this._urlSpaceRegExp.test(normalizedHref)) {
        return null;
      }

      // Need to use a full URL in case the containing page has a base URI.
      var fullNormalizedHref = resolveURL(normalizedHref, window.location.href).href;
      return fullNormalizedHref;
    },

    _makeRegExp: function _makeRegExp(urlSpaceRegex) {
      return RegExp(urlSpaceRegex);
    }
  });
})();

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

'use strict';

Polymer({
  is: 'iron-query-params',

  properties: {
    paramsString: {
      type: String,
      notify: true,
      observer: 'paramsStringChanged'
    },

    paramsObject: {
      type: Object,
      notify: true,
      value: function value() {
        return {};
      }
    },

    _dontReact: {
      type: Boolean,
      value: false
    }
  },

  hostAttributes: {
    hidden: true
  },

  observers: ['paramsObjectChanged(paramsObject.*)'],

  paramsStringChanged: function paramsStringChanged() {
    this._dontReact = true;
    this.paramsObject = this._decodeParams(this.paramsString);
    this._dontReact = false;
  },

  paramsObjectChanged: function paramsObjectChanged() {
    if (this._dontReact) {
      return;
    }
    this.paramsString = this._encodeParams(this.paramsObject).replace(/%3F/g, '?').replace(/%2F/g, '/').replace(/'/g, '%27');
  },

  _encodeParams: function _encodeParams(params) {
    var encodedParams = [];

    for (var key in params) {
      var value = params[key];

      if (value === '') {
        encodedParams.push(encodeURIComponent(key));
      } else if (value) {
        encodedParams.push(encodeURIComponent(key) + '=' + encodeURIComponent(value.toString()));
      }
    }
    return encodedParams.join('&');
  },

  _decodeParams: function _decodeParams(paramString) {
    var params = {};
    // Work around a bug in decodeURIComponent where + is not
    // converted to spaces:
    paramString = (paramString || '').replace(/\+/g, '%20');
    var paramList = paramString.split('&');
    for (var i = 0; i < paramList.length; i++) {
      var param = paramList[i].split('=');
      if (param[0]) {
        params[decodeURIComponent(param[0])] = decodeURIComponent(param[1] || '');
      }
    }
    return params;
  }
});

/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


(function () {
  'use strict';

  /**
   * Provides bidirectional mapping between `path` and `queryParams` and a
   * app-route compatible `route` object.
   *
   * For more information, see the docs for `app-route-converter`.
   *
   * @polymerBehavior
   */

  Polymer.AppRouteConverterBehavior = {
    properties: {
      /**
       * A model representing the deserialized path through the route tree, as
       * well as the current queryParams.
       *
       * A route object is the kernel of the routing system. It is intended to
       * be fed into consuming elements such as `app-route`.
       *
       * @type {?Object}
       */
      route: {
        type: Object,
        notify: true
      },

      /**
       * A set of key/value pairs that are universally accessible to branches of
       * the route tree.
       *
       * @type {?Object}
       */
      queryParams: {
        type: Object,
        notify: true
      },

      /**
       * The serialized path through the route tree. This corresponds to the
       * `window.location.pathname` value, and will update to reflect changes
       * to that value.
       */
      path: {
        type: String,
        notify: true
      }
    },

    observers: ['_locationChanged(path, queryParams)', '_routeChanged(route.prefix, route.path)', '_routeQueryParamsChanged(route.__queryParams)'],

    created: function created() {
      this.linkPaths('route.__queryParams', 'queryParams');
      this.linkPaths('queryParams', 'route.__queryParams');
    },

    /**
     * Handler called when the path or queryParams change.
     */
    _locationChanged: function _locationChanged() {
      if (this.route && this.route.path === this.path && this.queryParams === this.route.__queryParams) {
        return;
      }
      this.route = {
        prefix: '',
        path: this.path,
        __queryParams: this.queryParams
      };
    },

    /**
     * Handler called when the route prefix and route path change.
     */
    _routeChanged: function _routeChanged() {
      if (!this.route) {
        return;
      }

      this.path = this.route.prefix + this.route.path;
    },

    /**
     * Handler called when the route queryParams change.
     *
     * @param  {Object} queryParams A set of key/value pairs that are
     * universally accessible to branches of the route tree.
     */
    _routeQueryParamsChanged: function _routeQueryParamsChanged(queryParams) {
      if (!this.route) {
        return;
      }
      this.queryParams = queryParams;
    }
  };
})();

/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

(function () {
  'use strict';

  Polymer({
    is: 'app-route',

    properties: {
      /**
       * The URL component managed by this element.
       */
      route: {
        type: Object,
        notify: true
      },

      /**
       * The pattern of slash-separated segments to match `route.path` against.
       *
       * For example the pattern "/foo" will match "/foo" or "/foo/bar"
       * but not "/foobar".
       *
       * Path segments like `/:named` are mapped to properties on the `data` object.
       */
      pattern: {
        type: String
      },

      /**
       * The parameterized values that are extracted from the route as
       * described by `pattern`.
       */
      data: {
        type: Object,
        value: function value() {
          return {};
        },
        notify: true
      },

      /**
       * @type {?Object}
       */
      queryParams: {
        type: Object,
        value: function value() {
          return {};
        },
        notify: true
      },

      /**
       * The part of `route.path` NOT consumed by `pattern`.
       */
      tail: {
        type: Object,
        value: function value() {
          return { path: null, prefix: null, __queryParams: null };
        },
        notify: true
      },

      /**
       * Whether the current route is active. True if `route.path` matches the
       * `pattern`, false otherwise.
       */
      active: {
        type: Boolean,
        notify: true,
        readOnly: true
      },

      _queryParamsUpdating: {
        type: Boolean,
        value: false
      },
      /**
       * @type {?string}
       */
      _matched: {
        type: String,
        value: ''
      }
    },

    observers: ['__tryToMatch(route.path, pattern)', '__updatePathOnDataChange(data.*)', '__tailPathChanged(tail.path)', '__routeQueryParamsChanged(route.__queryParams)', '__tailQueryParamsChanged(tail.__queryParams)', '__queryParamsChanged(queryParams.*)'],

    created: function created() {
      this.linkPaths('route.__queryParams', 'tail.__queryParams');
      this.linkPaths('tail.__queryParams', 'route.__queryParams');
    },

    /**
     * Deal with the query params object being assigned to wholesale.
     */
    __routeQueryParamsChanged: function __routeQueryParamsChanged(queryParams) {
      if (queryParams && this.tail) {
        if (this.tail.__queryParams !== queryParams) {
          this.set('tail.__queryParams', queryParams);
        }

        if (!this.active || this._queryParamsUpdating) {
          return;
        }

        // Copy queryParams and track whether there are any differences compared
        // to the existing query params.
        var copyOfQueryParams = {};
        var anythingChanged = false;
        for (var key in queryParams) {
          copyOfQueryParams[key] = queryParams[key];
          if (anythingChanged || !this.queryParams || queryParams[key] !== this.queryParams[key]) {
            anythingChanged = true;
          }
        }
        // Need to check whether any keys were deleted
        for (var key in this.queryParams) {
          if (anythingChanged || !(key in queryParams)) {
            anythingChanged = true;
            break;
          }
        }

        if (!anythingChanged) {
          return;
        }
        this._queryParamsUpdating = true;
        this.set('queryParams', copyOfQueryParams);
        this._queryParamsUpdating = false;
      }
    },

    __tailQueryParamsChanged: function __tailQueryParamsChanged(queryParams) {
      if (queryParams && this.route && this.route.__queryParams != queryParams) {
        this.set('route.__queryParams', queryParams);
      }
    },

    __queryParamsChanged: function __queryParamsChanged(changes) {
      if (!this.active || this._queryParamsUpdating) {
        return;
      }

      this.set('route.__' + changes.path, changes.value);
    },

    __resetProperties: function __resetProperties() {
      this._setActive(false);
      this._matched = null;
    },

    __tryToMatch: function __tryToMatch() {
      if (!this.route) {
        return;
      }

      var path = this.route.path;
      var pattern = this.pattern;

      if (!pattern) {
        return;
      }

      if (!path) {
        this.__resetProperties();
        return;
      }

      var remainingPieces = path.split('/');
      var patternPieces = pattern.split('/');

      var matched = [];
      var namedMatches = {};

      for (var i = 0; i < patternPieces.length; i++) {
        var patternPiece = patternPieces[i];
        if (!patternPiece && patternPiece !== '') {
          break;
        }
        var pathPiece = remainingPieces.shift();

        // We don't match this path.
        if (!pathPiece && pathPiece !== '') {
          this.__resetProperties();
          return;
        }
        matched.push(pathPiece);

        if (patternPiece.charAt(0) == ':') {
          namedMatches[patternPiece.slice(1)] = pathPiece;
        } else if (patternPiece !== pathPiece) {
          this.__resetProperties();
          return;
        }
      }

      this._matched = matched.join('/');

      // Properties that must be updated atomically.
      var propertyUpdates = {};

      //this.active
      if (!this.active) {
        propertyUpdates.active = true;
      }

      // this.tail
      var tailPrefix = this.route.prefix + this._matched;
      var tailPath = remainingPieces.join('/');
      if (remainingPieces.length > 0) {
        tailPath = '/' + tailPath;
      }
      if (!this.tail || this.tail.prefix !== tailPrefix || this.tail.path !== tailPath) {
        propertyUpdates.tail = {
          prefix: tailPrefix,
          path: tailPath,
          __queryParams: this.route.__queryParams
        };
      }

      // this.data
      propertyUpdates.data = namedMatches;
      this._dataInUrl = {};
      for (var key in namedMatches) {
        this._dataInUrl[key] = namedMatches[key];
      }

      if (this.setProperties) {
        if (!this.active) {
          this._setActive(true);
        }
        // atomic update
        this.setProperties(propertyUpdates);
      } else {
        this.__setMulti(propertyUpdates);
      }
    },

    __tailPathChanged: function __tailPathChanged(path) {
      if (!this.active) {
        return;
      }
      var tailPath = path;
      var newPath = this._matched;
      if (tailPath) {
        if (tailPath.charAt(0) !== '/') {
          tailPath = '/' + tailPath;
        }
        newPath += tailPath;
      }
      this.set('route.path', newPath);
    },

    __updatePathOnDataChange: function __updatePathOnDataChange() {
      if (!this.route || !this.active) {
        return;
      }
      var newPath = this.__getLink({});
      var oldPath = this.__getLink(this._dataInUrl);
      if (newPath === oldPath) {
        return;
      }
      this.set('route.path', newPath);
    },

    __getLink: function __getLink(overrideValues) {
      var values = { tail: null };
      for (var key in this.data) {
        values[key] = this.data[key];
      }
      for (var key in overrideValues) {
        values[key] = overrideValues[key];
      }
      var patternPieces = this.pattern.split('/');
      var interp = patternPieces.map(function (value) {
        if (value[0] == ':') {
          value = values[value.slice(1)];
        }
        return value;
      }, this);
      if (values.tail && values.tail.path) {
        if (interp.length > 0 && values.tail.path.charAt(0) === '/') {
          interp.push(values.tail.path.slice(1));
        } else {
          interp.push(values.tail.path);
        }
      }
      return interp.join('/');
    },

    __setMulti: function __setMulti(setObj) {
      // HACK(rictic): skirting around 1.0's lack of a setMulti by poking at
      //     internal data structures. I would not advise that you copy this
      //     example.
      //
      //     In the future this will be a feature of Polymer itself.
      //     See: https://github.com/Polymer/polymer/issues/3640
      //
      //     Hacking around with private methods like this is juggling footguns,
      //     and is likely to have unexpected and unsupported rough edges.
      //
      //     Be ye so warned.
      for (var property in setObj) {
        this._propertySetter(property, setObj[property]);
      }
      //notify in a specific order
      if (setObj.data !== undefined) {
        this._pathEffector('data', this.data);
        this._notifyChange('data');
      }
      if (setObj.active !== undefined) {
        this._pathEffector('active', this.active);
        this._notifyChange('active');
      }
      if (setObj.tail !== undefined) {
        this._pathEffector('tail', this.tail);
        this._notifyChange('tail');
      }
    }
  });
})();

/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

__webpack_require__(17);

__webpack_require__(29);

var RegisterHtmlTemplate = __webpack_require__(2);

RegisterHtmlTemplate.register("<dom-module id=iron-pages> <template> <style>:host{display:block}:host>::slotted(:not(.iron-selected)){display:none!important}</style> <slot></slot> </template> </dom-module>");

Polymer({

  is: 'iron-pages',

  behaviors: [Polymer.IronResizableBehavior, Polymer.IronSelectableBehavior],

  properties: {

    // as the selected page is the only one visible, activateEvent
    // is both non-sensical and problematic; e.g. in cases where a user
    // handler attempts to change the page and the activateEvent
    // handler immediately changes it back
    activateEvent: {
      type: String,
      value: null
    }

  },

  observers: ['_selectedPageChanged(selected)'],

  _selectedPageChanged: function _selectedPageChanged(selected, old) {
    this.async(this.notifyResize);
  }
});

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

/**
 * @param {!Function} selectCallback
 * @constructor
 */
Polymer.IronSelection = function (selectCallback) {
  this.selection = [];
  this.selectCallback = selectCallback;
};

Polymer.IronSelection.prototype = {

  /**
   * Retrieves the selected item(s).
   *
   * @method get
   * @returns Returns the selected item(s). If the multi property is true,
   * `get` will return an array, otherwise it will return
   * the selected item or undefined if there is no selection.
   */
  get: function get() {
    return this.multi ? this.selection.slice() : this.selection[0];
  },

  /**
   * Clears all the selection except the ones indicated.
   *
   * @method clear
   * @param {Array} excludes items to be excluded.
   */
  clear: function clear(excludes) {
    this.selection.slice().forEach(function (item) {
      if (!excludes || excludes.indexOf(item) < 0) {
        this.setItemSelected(item, false);
      }
    }, this);
  },

  /**
   * Indicates if a given item is selected.
   *
   * @method isSelected
   * @param {*} item The item whose selection state should be checked.
   * @returns Returns true if `item` is selected.
   */
  isSelected: function isSelected(item) {
    return this.selection.indexOf(item) >= 0;
  },

  /**
   * Sets the selection state for a given item to either selected or deselected.
   *
   * @method setItemSelected
   * @param {*} item The item to select.
   * @param {boolean} isSelected True for selected, false for deselected.
   */
  setItemSelected: function setItemSelected(item, isSelected) {
    if (item != null) {
      if (isSelected !== this.isSelected(item)) {
        // proceed to update selection only if requested state differs from current
        if (isSelected) {
          this.selection.push(item);
        } else {
          var i = this.selection.indexOf(item);
          if (i >= 0) {
            this.selection.splice(i, 1);
          }
        }
        if (this.selectCallback) {
          this.selectCallback(item, isSelected);
        }
      }
    }
  },

  /**
   * Sets the selection state for a given item. If the `multi` property
   * is true, then the selected state of `item` will be toggled; otherwise
   * the `item` will be selected.
   *
   * @method select
   * @param {*} item The item to select.
   */
  select: function select(item) {
    if (this.multi) {
      this.toggle(item);
    } else if (this.get() !== item) {
      this.setItemSelected(this.get(), false);
      this.setItemSelected(item, true);
    }
  },

  /**
   * Toggles the selection state for `item`.
   *
   * @method toggle
   * @param {*} item The item to toggle.
   */
  toggle: function toggle(item) {
    this.setItemSelected(item, !this.isSelected(item));
  }

};

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

__webpack_require__(82);

/**
`iron-selector` is an element which can be used to manage a list of elements
that can be selected.  Tapping on the item will make the item selected.  The `selected` indicates
which item is being selected.  The default is to use the index of the item.
 Example:
     <iron-selector selected="0">
      <div>Item 1</div>
      <div>Item 2</div>
      <div>Item 3</div>
    </iron-selector>
 If you want to use the attribute value of an element for `selected` instead of the index,
set `attrForSelected` to the name of the attribute.  For example, if you want to select item by
`name`, set `attrForSelected` to `name`.
 Example:
     <iron-selector attr-for-selected="name" selected="foo">
      <div name="foo">Foo</div>
      <div name="bar">Bar</div>
      <div name="zot">Zot</div>
    </iron-selector>
 You can specify a default fallback with `fallbackSelection` in case the `selected` attribute does
not match the `attrForSelected` attribute of any elements.
 Example:
       <iron-selector attr-for-selected="name" selected="non-existing"
                     fallback-selection="default">
        <div name="foo">Foo</div>
        <div name="bar">Bar</div>
        <div name="default">Default</div>
      </iron-selector>
 Note: When the selector is multi, the selection will set to `fallbackSelection` iff
the number of matching elements is zero.
 `iron-selector` is not styled. Use the `iron-selected` CSS class to style the selected element.
 Example:
     <style>
      .iron-selected {
        background: #eee;
      }
    </style>
     ...
     <iron-selector selected="0">
      <div>Item 1</div>
      <div>Item 2</div>
      <div>Item 3</div>
    </iron-selector>
 @demo demo/index.html
*/

Polymer({

  is: 'iron-selector',

  behaviors: [Polymer.IronMultiSelectableBehavior]

});

/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

__webpack_require__(29);

/**
 * @polymerBehavior Polymer.IronMultiSelectableBehavior
 */
Polymer.IronMultiSelectableBehaviorImpl = {
  properties: {

    /**
     * If true, multiple selections are allowed.
     */
    multi: {
      type: Boolean,
      value: false,
      observer: 'multiChanged'
    },

    /**
     * Gets or sets the selected elements. This is used instead of `selected` when `multi`
     * is true.
     */
    selectedValues: {
      type: Array,
      notify: true,
      value: function value() {
        return [];
      }
    },

    /**
     * Returns an array of currently selected items.
     */
    selectedItems: {
      type: Array,
      readOnly: true,
      notify: true,
      value: function value() {
        return [];
      }
    }

  },

  observers: ['_updateSelected(selectedValues.splices)'],

  /**
   * Selects the given value. If the `multi` property is true, then the selected state of the
   * `value` will be toggled; otherwise the `value` will be selected.
   *
   * @method select
   * @param {string|number} value the value to select.
   */
  select: function select(value) {
    if (this.multi) {
      this._toggleSelected(value);
    } else {
      this.selected = value;
    }
  },

  multiChanged: function multiChanged(multi) {
    this._selection.multi = multi;
    this._updateSelected();
  },

  // UNUSED, FOR API COMPATIBILITY
  get _shouldUpdateSelection() {
    return this.selected != null || this.selectedValues != null && this.selectedValues.length;
  },

  _updateAttrForSelected: function _updateAttrForSelected() {
    if (!this.multi) {
      Polymer.IronSelectableBehavior._updateAttrForSelected.apply(this);
    } else if (this.selectedItems && this.selectedItems.length > 0) {
      this.selectedValues = this.selectedItems.map(function (selectedItem) {
        return this._indexToValue(this.indexOf(selectedItem));
      }, this).filter(function (unfilteredValue) {
        return unfilteredValue != null;
      }, this);
    }
  },

  _updateSelected: function _updateSelected() {
    if (this.multi) {
      this._selectMulti(this.selectedValues);
    } else {
      this._selectSelected(this.selected);
    }
  },

  _selectMulti: function _selectMulti(values) {
    values = values || [];

    var selectedItems = (this._valuesToItems(values) || []).filter(function (item) {
      return item !== null && item !== undefined;
    });

    // clear all but the current selected items
    this._selection.clear(selectedItems);

    // select only those not selected yet
    for (var i = 0; i < selectedItems.length; i++) {
      this._selection.setItemSelected(selectedItems[i], true);
    }

    // Check for items, since this array is populated only when attached
    if (this.fallbackSelection && !this._selection.get().length) {
      var fallback = this._valueToItem(this.fallbackSelection);
      if (fallback) {
        this.select(this.fallbackSelection);
      }
    }
  },

  _selectionChange: function _selectionChange() {
    var s = this._selection.get();
    if (this.multi) {
      this._setSelectedItems(s);
      this._setSelectedItem(s.length ? s[0] : null);
    } else {
      if (s !== null && s !== undefined) {
        this._setSelectedItems([s]);
        this._setSelectedItem(s);
      } else {
        this._setSelectedItems([]);
        this._setSelectedItem(null);
      }
    }
  },

  _toggleSelected: function _toggleSelected(value) {
    var i = this.selectedValues.indexOf(value);
    var unselected = i < 0;
    if (unselected) {
      this.push('selectedValues', value);
    } else {
      this.splice('selectedValues', i, 1);
    }
  },

  _valuesToItems: function _valuesToItems(values) {
    return values == null ? null : values.map(function (value) {
      return this._valueToItem(value);
    }, this);
  }
};

/** @polymerBehavior */
Polymer.IronMultiSelectableBehavior = [Polymer.IronSelectableBehavior, Polymer.IronMultiSelectableBehaviorImpl];

/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

__webpack_require__(36);

__webpack_require__(84);

/**
 * `Polymer.PaperInkyFocusBehavior` implements a ripple when the element has keyboard focus.
 *
 * @polymerBehavior Polymer.PaperInkyFocusBehavior
 */
Polymer.PaperInkyFocusBehaviorImpl = {
  observers: ['_focusedChanged(receivedFocusFromKeyboard)'],

  _focusedChanged: function _focusedChanged(receivedFocusFromKeyboard) {
    if (receivedFocusFromKeyboard) {
      this.ensureRipple();
    }
    if (this.hasRipple()) {
      this._ripple.holdDown = receivedFocusFromKeyboard;
    }
  },

  _createRipple: function _createRipple() {
    var ripple = Polymer.PaperRippleBehavior._createRipple();
    ripple.id = 'ink';
    ripple.setAttribute('center', '');
    ripple.classList.add('circle');
    return ripple;
  }
};

/** @polymerBehavior Polymer.PaperInkyFocusBehavior */
Polymer.PaperInkyFocusBehavior = [Polymer.IronButtonState, Polymer.IronControlState, Polymer.PaperRippleBehavior, Polymer.PaperInkyFocusBehaviorImpl];

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(0);

__webpack_require__(33);

/**
 * `Polymer.PaperRippleBehavior` dynamically implements a ripple
 * when the element has focus via pointer or keyboard.
 *
 * NOTE: This behavior is intended to be used in conjunction with and after
 * `Polymer.IronButtonState` and `Polymer.IronControlState`.
 *
 * @polymerBehavior Polymer.PaperRippleBehavior
 */
Polymer.PaperRippleBehavior = {
  properties: {
    /**
     * If true, the element will not produce a ripple effect when interacted
     * with via the pointer.
     */
    noink: {
      type: Boolean,
      observer: '_noinkChanged'
    },

    /**
     * @type {Element|undefined}
     */
    _rippleContainer: {
      type: Object
    }
  },

  /**
   * Ensures a `<paper-ripple>` element is available when the element is
   * focused.
   */
  _buttonStateChanged: function _buttonStateChanged() {
    if (this.focused) {
      this.ensureRipple();
    }
  },

  /**
   * In addition to the functionality provided in `IronButtonState`, ensures
   * a ripple effect is created when the element is in a `pressed` state.
   */
  _downHandler: function _downHandler(event) {
    Polymer.IronButtonStateImpl._downHandler.call(this, event);
    if (this.pressed) {
      this.ensureRipple(event);
    }
  },

  /**
   * Ensures this element contains a ripple effect. For startup efficiency
   * the ripple effect is dynamically on demand when needed.
   * @param {!Event=} optTriggeringEvent (optional) event that triggered the
   * ripple.
   */
  ensureRipple: function ensureRipple(optTriggeringEvent) {
    if (!this.hasRipple()) {
      this._ripple = this._createRipple();
      this._ripple.noink = this.noink;
      var rippleContainer = this._rippleContainer || this.root;
      if (rippleContainer) {
        Polymer.dom(rippleContainer).appendChild(this._ripple);
      }
      if (optTriggeringEvent) {
        // Check if the event happened inside of the ripple container
        // Fall back to host instead of the root because distributed text
        // nodes are not valid event targets
        var domContainer = Polymer.dom(this._rippleContainer || this);
        var target = Polymer.dom(optTriggeringEvent).rootTarget;
        if (domContainer.deepContains( /** @type {Node} */target)) {
          this._ripple.uiDownAction(optTriggeringEvent);
        }
      }
    }
  },

  /**
   * Returns the `<paper-ripple>` element used by this element to create
   * ripple effects. The element's ripple is created on demand, when
   * necessary, and calling this method will force the
   * ripple to be created.
   */
  getRipple: function getRipple() {
    this.ensureRipple();
    return this._ripple;
  },

  /**
   * Returns true if this element currently contains a ripple effect.
   * @return {boolean}
   */
  hasRipple: function hasRipple() {
    return Boolean(this._ripple);
  },

  /**
   * Create the element's ripple effect via creating a `<paper-ripple>`.
   * Override this method to customize the ripple element.
   * @return {!PaperRippleElement} Returns a `<paper-ripple>` element.
   */
  _createRipple: function _createRipple() {
    return (/** @type {!PaperRippleElement} */document.createElement('paper-ripple')
    );
  },

  _noinkChanged: function _noinkChanged(noink) {
    if (this.hasRipple()) {
      this._ripple.noink = noink;
    }
  }
};

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(38);

var RegisterHtmlTemplate = __webpack_require__(2);

RegisterHtmlTemplate.toBody("<iron-iconset-svg name=my-icons size=24> <svg> <defs> <g id=arrow-back> <path d=\"M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z\"></path> </g> <g id=menu> <path d=\"M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z\"></path> </g> <g id=chevron-right> <path d=\"M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z\"></path> </g> <g id=close> <path d=\"M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z\"></path> </g> <g id=search><path d=\"M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z\"></path> </g> </defs> </svg> </iron-iconset-svg>");

/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgYTA3ZjU4NGFlMTJmZmUyYjJmYzEiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL3BvbHltZXIuaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL3BvbHltZXIvbGliL3V0aWxzL2Jvb3QuaHRtbCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcG9seW1lci13ZWJwYWNrLWxvYWRlci9yZWdpc3Rlci1odG1sLXRlbXBsYXRlLmpzIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvdXRpbHMvbWl4aW4uaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL2FwcC1sYXlvdXQvYXBwLXNjcm9sbC1lZmZlY3RzL2FwcC1zY3JvbGwtZWZmZWN0cy1iZWhhdmlvci5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvaXJvbi1mbGV4LWxheW91dC9pcm9uLWZsZXgtbGF5b3V0Lmh0bWwiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL3BvbHltZXItZWxlbWVudC5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvdXRpbHMvcmVzb2x2ZS11cmwuaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL3BvbHltZXIvbGliL3V0aWxzL2FzeW5jLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi9taXhpbnMvbXV0YWJsZS1kYXRhLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi91dGlscy9jYXNlLW1hcC5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvbWl4aW5zL3Byb3BlcnR5LWVmZmVjdHMuaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL3BvbHltZXIvbGliL3V0aWxzL2RlYm91bmNlLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi91dGlscy9mbHVzaC5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvdXRpbHMvdGVtcGxhdGl6ZS5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvYXBwLWxheW91dC9hcHAtbGF5b3V0LWJlaGF2aW9yL2FwcC1sYXlvdXQtYmVoYXZpb3IuaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL2lyb24tYTExeS1rZXlzLWJlaGF2aW9yL2lyb24tYTExeS1rZXlzLWJlaGF2aW9yLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9pcm9uLXJlc2l6YWJsZS1iZWhhdmlvci9pcm9uLXJlc2l6YWJsZS1iZWhhdmlvci5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvaXJvbi1tZXRhL2lyb24tbWV0YS5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvbWl4aW5zL2VsZW1lbnQtbWl4aW4uaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL3BvbHltZXIvbGliL3V0aWxzL3NldHRpbmdzLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi91dGlscy9zdHlsZS1nYXRoZXIuaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL3BvbHltZXIvbGliL2xlZ2FjeS9sZWdhY3ktZWxlbWVudC1taXhpbi5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvbWl4aW5zL2dlc3R1cmUtZXZlbnQtbGlzdGVuZXJzLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi91dGlscy9hcnJheS1zcGxpY2UuaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL2FwcC1sYXlvdXQvYXBwLXNjcm9sbC1lZmZlY3RzL2VmZmVjdHMvYmxlbmQtYmFja2dyb3VuZC5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvYXBwLWxheW91dC9hcHAtc2Nyb2xsLWVmZmVjdHMvZWZmZWN0cy93YXRlcmZhbGwuaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL2FwcC1sYXlvdXQvYXBwLXNjcm9sbC1lZmZlY3RzL2VmZmVjdHMvcmVzaXplLXRpdGxlLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9hcHAtbGF5b3V0L2FwcC1zY3JvbGwtZWZmZWN0cy9lZmZlY3RzL3BhcmFsbGF4LWJhY2tncm91bmQuaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL2lyb24tc2VsZWN0b3IvaXJvbi1zZWxlY3RhYmxlLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9wYXBlci1zdHlsZXMvZGVmYXVsdC10aGVtZS5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvcGFwZXItaWNvbi1idXR0b24vcGFwZXItaWNvbi1idXR0b24uaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL2lyb24tYmVoYXZpb3JzL2lyb24tY29udHJvbC1zdGF0ZS5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvcGFwZXItcmlwcGxlL3BhcGVyLXJpcHBsZS5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvaXJvbi1zY3JvbGwtdGFyZ2V0LWJlaGF2aW9yL2lyb24tc2Nyb2xsLXRhcmdldC1iZWhhdmlvci5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvaXJvbi1pY29uL2lyb24taWNvbi5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvaXJvbi1iZWhhdmlvcnMvaXJvbi1idXR0b24tc3RhdGUuaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL3BhcGVyLXN0eWxlcy9jb2xvci5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvaXJvbi1pY29uc2V0LXN2Zy9pcm9uLWljb25zZXQtc3ZnLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vc3JjL215LWFwcC5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvZWxlbWVudHMvZG9tLW1vZHVsZS5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvdXRpbHMvcGF0aC5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvbWl4aW5zL3Byb3BlcnR5LWFjY2Vzc29ycy5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvbWl4aW5zL3RlbXBsYXRlLXN0YW1wLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9hcHAtbGF5b3V0L2FwcC1kcmF3ZXIvYXBwLWRyYXdlci5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvc2hhZHljc3MvYXBwbHktc2hpbS5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvc2hhZHljc3MvYXBwbHktc2hpbS5taW4uanMiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi91dGlscy9nZXN0dXJlcy5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvdXRpbHMvaW1wb3J0LWhyZWYuaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL3BvbHltZXIvbGliL3V0aWxzL3JlbmRlci1zdGF0dXMuaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL3BvbHltZXIvbGliL3V0aWxzL3VucmVzb2x2ZWQuaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL3BvbHltZXIvbGliL2xlZ2FjeS9wb2x5bWVyLmRvbS5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvdXRpbHMvZmxhdHRlbmVkLW5vZGVzLW9ic2VydmVyLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi9sZWdhY3kvcG9seW1lci1mbi5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvbGVnYWN5L2NsYXNzLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi9sZWdhY3kvdGVtcGxhdGl6ZXItYmVoYXZpb3IuaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL3BvbHltZXIvbGliL2VsZW1lbnRzL2RvbS1iaW5kLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi9lbGVtZW50cy9kb20tcmVwZWF0Lmh0bWwiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi9lbGVtZW50cy9kb20taWYuaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL3BvbHltZXIvbGliL2VsZW1lbnRzL2FycmF5LXNlbGVjdG9yLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi9lbGVtZW50cy9jdXN0b20tc3R5bGUuaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL3NoYWR5Y3NzL2N1c3RvbS1zdHlsZS1pbnRlcmZhY2UuaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL3NoYWR5Y3NzL2N1c3RvbS1zdHlsZS1pbnRlcmZhY2UubWluLmpzIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvbGVnYWN5L211dGFibGUtZGF0YS1iZWhhdmlvci5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvYXBwLWxheW91dC9hcHAtZHJhd2VyLWxheW91dC9hcHAtZHJhd2VyLWxheW91dC5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvaXJvbi1tZWRpYS1xdWVyeS9pcm9uLW1lZGlhLXF1ZXJ5Lmh0bWwiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9hcHAtbGF5b3V0L2FwcC1oZWFkZXIvYXBwLWhlYWRlci5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvYXBwLWxheW91dC9oZWxwZXJzL2hlbHBlcnMuaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL2FwcC1sYXlvdXQvYXBwLWhlYWRlci1sYXlvdXQvYXBwLWhlYWRlci1sYXlvdXQuaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL2FwcC1sYXlvdXQvYXBwLXNjcm9sbC1lZmZlY3RzL2FwcC1zY3JvbGwtZWZmZWN0cy5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvYXBwLWxheW91dC9hcHAtc2Nyb2xsLWVmZmVjdHMvZWZmZWN0cy9mYWRlLWJhY2tncm91bmQuaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL2FwcC1sYXlvdXQvYXBwLXNjcm9sbC1lZmZlY3RzL2VmZmVjdHMvbWF0ZXJpYWwuaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL2FwcC1sYXlvdXQvYXBwLXNjcm9sbC1lZmZlY3RzL2VmZmVjdHMvcmVzaXplLXNuYXBwZWQtdGl0bGUuaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL2FwcC1sYXlvdXQvYXBwLXRvb2xiYXIvYXBwLXRvb2xiYXIuaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL2FwcC1yb3V0ZS9hcHAtbG9jYXRpb24uaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL2lyb24tbG9jYXRpb24vaXJvbi1sb2NhdGlvbi5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvaXJvbi1sb2NhdGlvbi9pcm9uLXF1ZXJ5LXBhcmFtcy5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvYXBwLXJvdXRlL2FwcC1yb3V0ZS1jb252ZXJ0ZXItYmVoYXZpb3IuaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL2FwcC1yb3V0ZS9hcHAtcm91dGUuaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL2lyb24tcGFnZXMvaXJvbi1wYWdlcy5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvaXJvbi1zZWxlY3Rvci9pcm9uLXNlbGVjdGlvbi5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvaXJvbi1zZWxlY3Rvci9pcm9uLXNlbGVjdG9yLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9pcm9uLXNlbGVjdG9yL2lyb24tbXVsdGktc2VsZWN0YWJsZS5odG1sIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvcGFwZXItYmVoYXZpb3JzL3BhcGVyLWlua3ktZm9jdXMtYmVoYXZpb3IuaHRtbCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL3BhcGVyLWJlaGF2aW9ycy9wYXBlci1yaXBwbGUtYmVoYXZpb3IuaHRtbCIsIndlYnBhY2s6Ly8vLi9zcmMvbXktaWNvbnMuaHRtbCJdLCJuYW1lcyI6WyJSZWdpc3Rlckh0bWxUZW1wbGF0ZSIsInZhbCIsImNvbnRlbnQiLCJ0ZW1wbGF0ZSIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImlubmVySFRNTCIsImNyZWF0ZURvY3VtZW50RnJhZ21lbnQiLCJmaXJzdENoaWxkIiwiYXBwZW5kQ2hpbGQiLCJpbXBvcnROb2RlIiwidHJpbW1lZFZhbCIsInRyaW0iLCJkaXYiLCJib2R5IiwiaW5zZXJ0QmVmb3JlIiwiYWRkRXZlbnRMaXN0ZW5lciIsIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIiwidG9Cb2R5IiwiayIsIm4iLCJlbmQiLCJzdGFydCIsInJ1bGVzIiwicGFyZW50IiwicHJldmlvdXMiLCJjc3NUZXh0IiwicGFyc2VkQ3NzVGV4dCIsImF0UnVsZSIsInR5cGUiLCJwYXJzZWRTZWxlY3RvciIsInNlbGVjdG9yIiwia2V5ZnJhbWVzTmFtZSIsInAiLCJhIiwicmVwbGFjZSIsImFhIiwiYmEiLCJiIiwicSIsImMiLCJkIiwibGVuZ3RoIiwiZSIsImYiLCJoIiwiZyIsIm0iLCJwdXNoIiwic3Vic3RyaW5nIiwiY2EiLCJyIiwibGFzdEluZGV4T2YiLCJpbmRleE9mIiwidCIsIm1hdGNoIiwiZGEiLCJ1Iiwic3BsaXQiLCJwb3AiLCJ2IiwieCIsInkiLCJlYSIsImZhIiwiaGEiLCJpYSIsImphIiwiUHJvbWlzZSIsInJlc29sdmUiLCJrYSIsIl9hcHBseVNoaW1DdXJyZW50VmVyc2lvbiIsIl9hcHBseVNoaW1WYWxpZGF0aW5nVmVyc2lvbiIsIl9hcHBseVNoaW1OZXh0VmVyc2lvbiIsInoiLCJsYSIsInRoZW4iLCJBIiwid2luZG93IiwiU2hhZHlET00iLCJpblVzZSIsIkIiLCJDIiwic2hpbWNzc3Byb3BlcnRpZXMiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJDU1MiLCJzdXBwb3J0cyIsIlNoYWR5Q1NTIiwibmF0aXZlQ3NzIiwiV2ViQ29tcG9uZW50cyIsImZsYWdzIiwiRSIsIkYiLCJHIiwibWEiLCJIIiwiSSIsIl9fY3NzUnVsZXMiLCJ0ZXh0Q29udGVudCIsIkoiLCJtYXRjaE1lZGlhIiwibWF0Y2hlcyIsIksiLCJuYSIsIm9hIiwiTCIsInByb3RvdHlwZSIsInNldCIsImkiLCJnZXQiLCJNIiwiTiIsIm8iLCJ0ZXN0IiwibGFzdEluZGV4IiwicXVlcnlTZWxlY3RvciIsImoiLCJsIiwicGEiLCJxYSIsIk8iLCJleGVjIiwiaW5kZXgiLCJzbGljZSIsIlAiLCJqb2luIiwic2V0QXR0cmlidXRlIiwic3R5bGUiLCJhbGwiLCJoZWFkIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImdldFByb3BlcnR5VmFsdWUiLCJyYSIsIk9iamVjdCIsImFzc2lnbiIsImNyZWF0ZSIsIlgiLCJ3IiwiWSIsIkQiLCJkZXRlY3RNaXhpbiIsInRyYW5zZm9ybVN0eWxlIiwidHJhbnNmb3JtQ3VzdG9tU3R5bGUiLCJ0cmFuc2Zvcm1SdWxlcyIsInRyYW5zZm9ybVJ1bGUiLCJ0cmFuc2Zvcm1UZW1wbGF0ZSIsIl9zZXBhcmF0b3IiLCJkZWZpbmVQcm9wZXJ0eSIsIlEiLCJSIiwiSFRNTEltcG9ydHMiLCJ3aGVuUmVhZHkiLCJTIiwic2EiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJyZWFkeVN0YXRlIiwiVCIsIlUiLCJWIiwiaW52YWxpZENhbGxiYWNrIiwiQ3VzdG9tU3R5bGVJbnRlcmZhY2UiLCJ0cmFuc2Zvcm1DYWxsYmFjayIsInZhbGlkYXRlQ2FsbGJhY2siLCJlbnF1ZXVlZCIsIlciLCJwcmVwYXJlVGVtcGxhdGUiLCJfc3R5bGVBc3QiLCJwcm9jZXNzU3R5bGVzIiwiZ2V0U3R5bGVGb3JDdXN0b21TdHlsZSIsInN0eWxlU3VidHJlZSIsInJlbW92ZVByb3BlcnR5Iiwic2V0UHJvcGVydHkiLCJzaGFkb3dSb290Iiwic3R5bGVFbGVtZW50IiwiY2hpbGRyZW4iLCJjaGlsZE5vZGVzIiwibG9jYWxOYW1lIiwiZ2V0QXR0cmlidXRlIiwiaXMiLCJzdHlsZURvY3VtZW50IiwiU2NvcGluZ1NoaW0iLCJaIiwidGEiLCJnZXRDb21wdXRlZFN0eWxlVmFsdWUiLCJuYXRpdmVTaGFkb3ciLCJBcHBseVNoaW0iLCJjYWxsIiwiY3VzdG9tU3R5bGVzIiwiX19zZWVuQnlTaGFkeUNTUyIsIl9fc2hhZHlDU1NDYWNoZWRTdHlsZSIsImdldFN0eWxlIiwiX19hcHBsaWVkRWxlbWVudCIsImFkZEN1c3RvbVN0eWxlIiwiZGVmaW5lUHJvcGVydGllcyJdLCJtYXBwaW5ncyI6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bkIscUJBQXFCb0IsTUFBckIsQ0FBNEIsK3dCQUE1QixFIiwiZmlsZSI6Im1haW4uYnVuZGxlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gaW5zdGFsbCBhIEpTT05QIGNhbGxiYWNrIGZvciBjaHVuayBsb2FkaW5nXG4gXHR2YXIgcGFyZW50SnNvbnBGdW5jdGlvbiA9IHdpbmRvd1tcIndlYnBhY2tKc29ucFwiXTtcbiBcdHdpbmRvd1tcIndlYnBhY2tKc29ucFwiXSA9IGZ1bmN0aW9uIHdlYnBhY2tKc29ucENhbGxiYWNrKGNodW5rSWRzLCBtb3JlTW9kdWxlcywgZXhlY3V0ZU1vZHVsZXMpIHtcbiBcdFx0Ly8gYWRkIFwibW9yZU1vZHVsZXNcIiB0byB0aGUgbW9kdWxlcyBvYmplY3QsXG4gXHRcdC8vIHRoZW4gZmxhZyBhbGwgXCJjaHVua0lkc1wiIGFzIGxvYWRlZCBhbmQgZmlyZSBjYWxsYmFja1xuIFx0XHR2YXIgbW9kdWxlSWQsIGNodW5rSWQsIGkgPSAwLCByZXNvbHZlcyA9IFtdLCByZXN1bHQ7XG4gXHRcdGZvcig7aSA8IGNodW5rSWRzLmxlbmd0aDsgaSsrKSB7XG4gXHRcdFx0Y2h1bmtJZCA9IGNodW5rSWRzW2ldO1xuIFx0XHRcdGlmKGluc3RhbGxlZENodW5rc1tjaHVua0lkXSkge1xuIFx0XHRcdFx0cmVzb2x2ZXMucHVzaChpbnN0YWxsZWRDaHVua3NbY2h1bmtJZF1bMF0pO1xuIFx0XHRcdH1cbiBcdFx0XHRpbnN0YWxsZWRDaHVua3NbY2h1bmtJZF0gPSAwO1xuIFx0XHR9XG4gXHRcdGZvcihtb2R1bGVJZCBpbiBtb3JlTW9kdWxlcykge1xuIFx0XHRcdGlmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb3JlTW9kdWxlcywgbW9kdWxlSWQpKSB7XG4gXHRcdFx0XHRtb2R1bGVzW21vZHVsZUlkXSA9IG1vcmVNb2R1bGVzW21vZHVsZUlkXTtcbiBcdFx0XHR9XG4gXHRcdH1cbiBcdFx0aWYocGFyZW50SnNvbnBGdW5jdGlvbikgcGFyZW50SnNvbnBGdW5jdGlvbihjaHVua0lkcywgbW9yZU1vZHVsZXMsIGV4ZWN1dGVNb2R1bGVzKTtcbiBcdFx0d2hpbGUocmVzb2x2ZXMubGVuZ3RoKSB7XG4gXHRcdFx0cmVzb2x2ZXMuc2hpZnQoKSgpO1xuIFx0XHR9XG5cbiBcdH07XG5cbiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIG9iamVjdHMgdG8gc3RvcmUgbG9hZGVkIGFuZCBsb2FkaW5nIGNodW5rc1xuIFx0dmFyIGluc3RhbGxlZENodW5rcyA9IHtcbiBcdFx0NDogMFxuIFx0fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG4gXHQvLyBUaGlzIGZpbGUgY29udGFpbnMgb25seSB0aGUgZW50cnkgY2h1bmsuXG4gXHQvLyBUaGUgY2h1bmsgbG9hZGluZyBmdW5jdGlvbiBmb3IgYWRkaXRpb25hbCBjaHVua3NcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZSA9IGZ1bmN0aW9uIHJlcXVpcmVFbnN1cmUoY2h1bmtJZCkge1xuIFx0XHR2YXIgaW5zdGFsbGVkQ2h1bmtEYXRhID0gaW5zdGFsbGVkQ2h1bmtzW2NodW5rSWRdO1xuIFx0XHRpZihpbnN0YWxsZWRDaHVua0RhdGEgPT09IDApIHtcbiBcdFx0XHRyZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSkgeyByZXNvbHZlKCk7IH0pO1xuIFx0XHR9XG5cbiBcdFx0Ly8gYSBQcm9taXNlIG1lYW5zIFwiY3VycmVudGx5IGxvYWRpbmdcIi5cbiBcdFx0aWYoaW5zdGFsbGVkQ2h1bmtEYXRhKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZENodW5rRGF0YVsyXTtcbiBcdFx0fVxuXG4gXHRcdC8vIHNldHVwIFByb21pc2UgaW4gY2h1bmsgY2FjaGVcbiBcdFx0dmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiBcdFx0XHRpbnN0YWxsZWRDaHVua0RhdGEgPSBpbnN0YWxsZWRDaHVua3NbY2h1bmtJZF0gPSBbcmVzb2x2ZSwgcmVqZWN0XTtcbiBcdFx0fSk7XG4gXHRcdGluc3RhbGxlZENodW5rRGF0YVsyXSA9IHByb21pc2U7XG5cbiBcdFx0Ly8gc3RhcnQgY2h1bmsgbG9hZGluZ1xuIFx0XHR2YXIgaGVhZCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF07XG4gXHRcdHZhciBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiBcdFx0c2NyaXB0LnR5cGUgPSAndGV4dC9qYXZhc2NyaXB0JztcbiBcdFx0c2NyaXB0LmNoYXJzZXQgPSAndXRmLTgnO1xuIFx0XHRzY3JpcHQuYXN5bmMgPSB0cnVlO1xuIFx0XHRzY3JpcHQudGltZW91dCA9IDEyMDAwMDtcblxuIFx0XHRpZiAoX193ZWJwYWNrX3JlcXVpcmVfXy5uYykge1xuIFx0XHRcdHNjcmlwdC5zZXRBdHRyaWJ1dGUoXCJub25jZVwiLCBfX3dlYnBhY2tfcmVxdWlyZV9fLm5jKTtcbiBcdFx0fVxuIFx0XHRzY3JpcHQuc3JjID0gX193ZWJwYWNrX3JlcXVpcmVfXy5wICsgXCJcIiArIGNodW5rSWQgKyBcIi5idW5kbGUuanNcIjtcbiBcdFx0dmFyIHRpbWVvdXQgPSBzZXRUaW1lb3V0KG9uU2NyaXB0Q29tcGxldGUsIDEyMDAwMCk7XG4gXHRcdHNjcmlwdC5vbmVycm9yID0gc2NyaXB0Lm9ubG9hZCA9IG9uU2NyaXB0Q29tcGxldGU7XG4gXHRcdGZ1bmN0aW9uIG9uU2NyaXB0Q29tcGxldGUoKSB7XG4gXHRcdFx0Ly8gYXZvaWQgbWVtIGxlYWtzIGluIElFLlxuIFx0XHRcdHNjcmlwdC5vbmVycm9yID0gc2NyaXB0Lm9ubG9hZCA9IG51bGw7XG4gXHRcdFx0Y2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuIFx0XHRcdHZhciBjaHVuayA9IGluc3RhbGxlZENodW5rc1tjaHVua0lkXTtcbiBcdFx0XHRpZihjaHVuayAhPT0gMCkge1xuIFx0XHRcdFx0aWYoY2h1bmspIHtcbiBcdFx0XHRcdFx0Y2h1bmtbMV0obmV3IEVycm9yKCdMb2FkaW5nIGNodW5rICcgKyBjaHVua0lkICsgJyBmYWlsZWQuJykpO1xuIFx0XHRcdFx0fVxuIFx0XHRcdFx0aW5zdGFsbGVkQ2h1bmtzW2NodW5rSWRdID0gdW5kZWZpbmVkO1xuIFx0XHRcdH1cbiBcdFx0fTtcbiBcdFx0aGVhZC5hcHBlbmRDaGlsZChzY3JpcHQpO1xuXG4gXHRcdHJldHVybiBwcm9taXNlO1xuIFx0fTtcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbiBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbiBcdFx0XHR9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJkaXN0L1wiO1xuXG4gXHQvLyBvbiBlcnJvciBmdW5jdGlvbiBmb3IgYXN5bmMgbG9hZGluZ1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vZSA9IGZ1bmN0aW9uKGVycikgeyBjb25zb2xlLmVycm9yKGVycik7IHRocm93IGVycjsgfTtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAzOSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay9ib290c3RyYXAgYTA3ZjU4NGFlMTJmZmUyYjJmYzEiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwibGliL2xlZ2FjeS9sZWdhY3ktZWxlbWVudC1taXhpbi5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwibGliL2xlZ2FjeS9wb2x5bWVyLWZuLmh0bWxcIj5cbjwhLS0gdGVtcGxhdGUgZWxlbWVudHMgLS0+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwibGliL2xlZ2FjeS90ZW1wbGF0aXplci1iZWhhdmlvci5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwibGliL2VsZW1lbnRzL2RvbS1iaW5kLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCJsaWIvZWxlbWVudHMvZG9tLXJlcGVhdC5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwibGliL2VsZW1lbnRzL2RvbS1pZi5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwibGliL2VsZW1lbnRzL2FycmF5LXNlbGVjdG9yLmh0bWxcIj5cbjwhLS0gY3VzdG9tLXN0eWxlIC0tPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cImxpYi9lbGVtZW50cy9jdXN0b20tc3R5bGUuaHRtbFwiPlxuPCEtLSBiYyBiZWhhdmlvcnMgLS0+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwibGliL2xlZ2FjeS9tdXRhYmxlLWRhdGEtYmVoYXZpb3IuaHRtbFwiPlxuPHNjcmlwdD5cbiAgLy8gYmNcbiAgUG9seW1lci5CYXNlID0gUG9seW1lci5MZWdhY3lFbGVtZW50TWl4aW4oSFRNTEVsZW1lbnQpLnByb3RvdHlwZTtcbjwvc2NyaXB0PlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL3BvbHltZXIuaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cbjxzY3JpcHQ+XG4oZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBjb25zdCB1c2VyUG9seW1lciA9IHdpbmRvdy5Qb2x5bWVyO1xuXG4gIC8qKlxuICAgKiBAbmFtZXNwYWNlIFBvbHltZXJcbiAgICogQHN1bW1hcnkgUG9seW1lciBpcyBhIGxpZ2h0d2VpZ2h0IGxpYnJhcnkgYnVpbHQgb24gdG9wIG9mIHRoZSB3ZWJcbiAgICogICBzdGFuZGFyZHMtYmFzZWQgV2ViIENvbXBvbmVudHMgQVBJJ3MsIGFuZCBtYWtlcyBpdCBlYXN5IHRvIGJ1aWxkIHlvdXJcbiAgICogICBvd24gY3VzdG9tIEhUTUwgZWxlbWVudHMuXG4gICAqIEBwYXJhbSB7IVBvbHltZXJJbml0fSBpbmZvIFByb3RvdHlwZSBmb3IgdGhlIGN1c3RvbSBlbGVtZW50LiBJdCBtdXN0IGNvbnRhaW5cbiAgICogICBhbiBgaXNgIHByb3BlcnR5IHRvIHNwZWNpZnkgdGhlIGVsZW1lbnQgbmFtZS4gT3RoZXIgcHJvcGVydGllcyBwb3B1bGF0ZVxuICAgKiAgIHRoZSBlbGVtZW50IHByb3RvdHlwZS4gVGhlIGBwcm9wZXJ0aWVzYCwgYG9ic2VydmVyc2AsIGBob3N0QXR0cmlidXRlc2AsXG4gICAqICAgYW5kIGBsaXN0ZW5lcnNgIHByb3BlcnRpZXMgYXJlIHByb2Nlc3NlZCB0byBjcmVhdGUgZWxlbWVudCBmZWF0dXJlcy5cbiAgICogQHJldHVybiB7IU9iamVjdH0gUmV0dXJucyBhIGN1c3RvbSBlbGVtZW50IGNsYXNzIGZvciB0aGUgZ2l2ZW4gcHJvdmlkZWRcbiAgICogICBwcm90b3R5cGUgYGluZm9gIG9iamVjdC4gVGhlIG5hbWUgb2YgdGhlIGVsZW1lbnQgaWYgZ2l2ZW4gYnkgYGluZm8uaXNgLlxuICAgKi9cbiAgd2luZG93LlBvbHltZXIgPSBmdW5jdGlvbihpbmZvKSB7XG4gICAgcmV0dXJuIHdpbmRvdy5Qb2x5bWVyLl9wb2x5bWVyRm4oaW5mbyk7XG4gIH1cblxuICAvLyBzdXBwb3J0IHVzZXIgc2V0dGluZ3Mgb24gdGhlIFBvbHltZXIgb2JqZWN0XG4gIGlmICh1c2VyUG9seW1lcikge1xuICAgIE9iamVjdC5hc3NpZ24oUG9seW1lciwgdXNlclBvbHltZXIpO1xuICB9XG5cbiAgLy8gVG8gYmUgcGx1Z2dlZCBieSBsZWdhY3kgaW1wbGVtZW50YXRpb24gaWYgbG9hZGVkXG4gIC8qIGVzbGludC1kaXNhYmxlIHZhbGlkLWpzZG9jICovXG4gIC8qKlxuICAgKiBAcGFyYW0geyFQb2x5bWVySW5pdH0gaW5mbyBQcm90b3R5cGUgZm9yIHRoZSBjdXN0b20gZWxlbWVudC4gSXQgbXVzdCBjb250YWluXG4gICAqICAgYW4gYGlzYCBwcm9wZXJ0eSB0byBzcGVjaWZ5IHRoZSBlbGVtZW50IG5hbWUuIE90aGVyIHByb3BlcnRpZXMgcG9wdWxhdGVcbiAgICogICB0aGUgZWxlbWVudCBwcm90b3R5cGUuIFRoZSBgcHJvcGVydGllc2AsIGBvYnNlcnZlcnNgLCBgaG9zdEF0dHJpYnV0ZXNgLFxuICAgKiAgIGFuZCBgbGlzdGVuZXJzYCBwcm9wZXJ0aWVzIGFyZSBwcm9jZXNzZWQgdG8gY3JlYXRlIGVsZW1lbnQgZmVhdHVyZXMuXG4gICAqIEByZXR1cm4geyFPYmplY3R9IFJldHVybnMgYSBjdXN0b20gZWxlbWVudCBjbGFzcyBmb3IgdGhlIGdpdmVuIHByb3ZpZGVkXG4gICAqICAgcHJvdG90eXBlIGBpbmZvYCBvYmplY3QuIFRoZSBuYW1lIG9mIHRoZSBlbGVtZW50IGlmIGdpdmVuIGJ5IGBpbmZvLmlzYC5cbiAgICovXG4gIHdpbmRvdy5Qb2x5bWVyLl9wb2x5bWVyRm4gPSBmdW5jdGlvbihpbmZvKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0xvYWQgcG9seW1lci5odG1sIHRvIHVzZSB0aGUgUG9seW1lcigpIGZ1bmN0aW9uLicpO1xuICB9XG4gIC8qIGVzbGludC1lbmFibGUgKi9cblxuICB3aW5kb3cuUG9seW1lci52ZXJzaW9uID0gJzIuMC4xJztcblxuICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuICAvKlxuICBXaGVuIHVzaW5nIENsb3N1cmUgQ29tcGlsZXIsIEpTQ29tcGlsZXJfcmVuYW1lUHJvcGVydHkocHJvcGVydHksIG9iamVjdCkgaXMgcmVwbGFjZWQgYnkgdGhlIG11bmdlZCBuYW1lIGZvciBvYmplY3RbcHJvcGVydHldXG4gIFdlIGNhbm5vdCBhbGlhcyB0aGlzIGZ1bmN0aW9uLCBzbyB3ZSBoYXZlIHRvIHVzZSBhIHNtYWxsIHNoaW0gdGhhdCBoYXMgdGhlIHNhbWUgYmVoYXZpb3Igd2hlbiBub3QgY29tcGlsaW5nLlxuICAqL1xuICB3aW5kb3cuSlNDb21waWxlcl9yZW5hbWVQcm9wZXJ0eSA9IGZ1bmN0aW9uKHByb3AsIG9iaikge1xuICAgIHJldHVybiBwcm9wO1xuICB9XG4gIC8qIGVzbGludC1lbmFibGUgKi9cblxufSkoKTtcbjwvc2NyaXB0PlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi91dGlscy9ib290Lmh0bWwiLCIvKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cblxuY2xhc3MgUmVnaXN0ZXJIdG1sVGVtcGxhdGUge1xuICAvKipcbiAgICogQ3JlYXRlIGEgYDx0ZW1wbGF0ZT5gIGVsZW1lbnQgdG8gaG9sZCBgPGRvbS1tb2R1bGU+YCBjb250ZW50LlxuICAgKiBUaGlzIGJpdCBvZiBjb2RlIHdpbGwgZXhlY3V0ZSBpbiB0aGUgY29udGV4dCBvZiB0aGUgbWFpbiBkb2N1bWVudCxcbiAgICogY2FsbGluZyBgaW1wb3J0Tm9kZWAgb24gdGhlIGA8dGVtcGxhdGU+YCwgd2hpY2ggaW4gdHVybiB0cmlnZ2Vyc1xuICAgKiB0aGUgbGlmZWN5Y2xlIG9mIHRoZSBgPGRvbS1tb2R1bGU+YCBhbmQgYWxsb3dzIGl0IHRvIGluc2VydCBpdHNcbiAgICogY29udGVudCBpbnRvIFBvbHltZXIncyBnbG9iYWwgbW9kdWxlIG1hcC4gV2hlbiBhIFBvbHltZXIgZWxlbWVudFxuICAgKiBib290cyB1cCBpdCB3aWxsIGZldGNoIGl0cyB0ZW1wbGF0ZSBmcm9tIHRoaXMgbW9kdWxlIG1hcC5cbiAgICogaHR0cHM6Ly9naXRodWIuY29tL1BvbHltZXIvcG9seW1lci9ibG9iL21hc3Rlci9saWIvbWl4aW5zL2VsZW1lbnQtbWl4aW4uaHRtbCNMNTAxLUw1MzhcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbCBBIGA8ZG9tLW1vZHVsZT5gIGFzIGFuIEhUTUwgc3RyaW5nXG4gICAqL1xuICBzdGF0aWMgcmVnaXN0ZXIodmFsKSB7XG4gICAgbGV0IGNvbnRlbnQ7XG4gICAgY29uc3QgdGVtcGxhdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScpO1xuICAgIHRlbXBsYXRlLmlubmVySFRNTCA9IHZhbDtcbiAgICBpZiAodGVtcGxhdGUuY29udGVudCkge1xuICAgICAgY29udGVudCA9IHRlbXBsYXRlLmNvbnRlbnQ7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcHJlZmVyLWRlc3RydWN0dXJpbmdcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICAgIHdoaWxlICh0ZW1wbGF0ZS5maXJzdENoaWxkKSB7XG4gICAgICAgIGNvbnRlbnQuYXBwZW5kQ2hpbGQodGVtcGxhdGUuZmlyc3RDaGlsZCk7XG4gICAgICB9XG4gICAgfVxuICAgIGRvY3VtZW50LmltcG9ydE5vZGUoY29udGVudCwgdHJ1ZSk7XG4gIH1cbiAgLyoqXG4gICAqIENvbnRlbnQgdGhhdCB3aWxsIGJlIGluamVjdGVkIGludG8gdGhlIG1haW4gZG9jdW1lbnQuIFRoaXMgaXMgcHJpbWFyaWx5XG4gICAqIGZvciB0aGluZ3MgbGlrZSBgPGlyb24taWNvbnNldD5gIGFuZCBgPGN1c3RvbS1zdHlsZT5gIHdoaWNoIGRvIG5vdCBoYXZlXG4gICAqIHRlbXBsYXRlcyBidXQgcmVseSBvbiBIVE1MIEltcG9ydHMgYWJpbGl0eSB0byBhcHBseSBjb250ZW50IHRvIHRoZSBtYWluXG4gICAqIGRvY3VtZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsIEFuIEhUTUwgc3RyaW5nXG4gICAqL1xuICBzdGF0aWMgdG9Cb2R5KHZhbCkge1xuICAgIGNvbnN0IHRyaW1tZWRWYWwgPSB2YWwudHJpbSgpO1xuICAgIGlmICh0cmltbWVkVmFsKSB7XG4gICAgICBjb25zdCBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGRpdi5pbm5lckhUTUwgPSB0cmltbWVkVmFsO1xuICAgICAgaWYgKGRpdi5maXJzdENoaWxkKSB7XG4gICAgICAgIGlmIChkb2N1bWVudC5ib2R5KSB7XG4gICAgICAgICAgZG9jdW1lbnQuYm9keS5pbnNlcnRCZWZvcmUoZGl2LmZpcnN0Q2hpbGQsIGRvY3VtZW50LmJvZHkuZmlyc3RDaGlsZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsICgpID0+IHtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuaW5zZXJ0QmVmb3JlKGRpdi5maXJzdENoaWxkLCBkb2N1bWVudC5ib2R5LmZpcnN0Q2hpbGQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVnaXN0ZXJIdG1sVGVtcGxhdGU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcG9seW1lci13ZWJwYWNrLWxvYWRlci9yZWdpc3Rlci1odG1sLXRlbXBsYXRlLmpzIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuXG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiYm9vdC5odG1sXCI+XG5cbjxzY3JpcHQ+XG5cbihmdW5jdGlvbigpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgLy8gdW5pcXVlIGdsb2JhbCBpZCBmb3IgZGVkdXBpbmcgbWl4aW5zLlxuICBsZXQgZGVkdXBlSWQgPSAwO1xuXG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQGV4dGVuZHMge0Z1bmN0aW9ufVxuICAgKi9cbiAgZnVuY3Rpb24gTWl4aW5GdW5jdGlvbigpe31cbiAgLyoqIEB0eXBlIHsoV2Vha01hcCB8IHVuZGVmaW5lZCl9ICovXG4gIE1peGluRnVuY3Rpb24ucHJvdG90eXBlLl9fbWl4aW5BcHBsaWNhdGlvbnM7XG4gIC8qKiBAdHlwZSB7KE9iamVjdCB8IHVuZGVmaW5lZCl9ICovXG4gIE1peGluRnVuY3Rpb24ucHJvdG90eXBlLl9fbWl4aW5TZXQ7XG5cbiAgLyogZXNsaW50LWRpc2FibGUgdmFsaWQtanNkb2MgKi9cbiAgLyoqXG4gICAqIFdyYXBzIGFuIEVTNiBjbGFzcyBleHByZXNzaW9uIG1peGluIHN1Y2ggdGhhdCB0aGUgbWl4aW4gaXMgb25seSBhcHBsaWVkXG4gICAqIGlmIGl0IGhhcyBub3QgYWxyZWFkeSBiZWVuIGFwcGxpZWQgaXRzIGJhc2UgYXJndW1lbnQuICBBbHNvIG1lbW9pemVzIG1peGluXG4gICAqIGFwcGxpY2F0aW9ucy5cbiAgICpcbiAgICogQG1lbWJlcm9mIFBvbHltZXJcbiAgICogQHRlbXBsYXRlIFRcbiAgICogQHBhcmFtIHtUfSBtaXhpbiBFUzYgY2xhc3MgZXhwcmVzc2lvbiBtaXhpbiB0byB3cmFwXG4gICAqIEBzdXBwcmVzcyB7aW52YWxpZENhc3RzfVxuICAgKi9cbiAgUG9seW1lci5kZWR1cGluZ01peGluID0gZnVuY3Rpb24obWl4aW4pIHtcbiAgICBsZXQgbWl4aW5BcHBsaWNhdGlvbnMgPSAvKiogQHR5cGUgeyFNaXhpbkZ1bmN0aW9ufSAqLyhtaXhpbikuX19taXhpbkFwcGxpY2F0aW9ucztcbiAgICBpZiAoIW1peGluQXBwbGljYXRpb25zKSB7XG4gICAgICBtaXhpbkFwcGxpY2F0aW9ucyA9IG5ldyBXZWFrTWFwKCk7XG4gICAgICAvKiogQHR5cGUgeyFNaXhpbkZ1bmN0aW9ufSAqLyhtaXhpbikuX19taXhpbkFwcGxpY2F0aW9ucyA9IG1peGluQXBwbGljYXRpb25zO1xuICAgIH1cbiAgICAvLyBtYWludGFpbiBhIHVuaXF1ZSBpZCBmb3IgZWFjaCBtaXhpblxuICAgIGxldCBtaXhpbkRlZHVwZUlkID0gZGVkdXBlSWQrKztcbiAgICBmdW5jdGlvbiBkZWR1cGluZ01peGluKGJhc2UpIHtcbiAgICAgIGxldCBiYXNlU2V0ID0gLyoqIEB0eXBlIHshTWl4aW5GdW5jdGlvbn0gKi8oYmFzZSkuX19taXhpblNldDtcbiAgICAgIGlmIChiYXNlU2V0ICYmIGJhc2VTZXRbbWl4aW5EZWR1cGVJZF0pIHtcbiAgICAgICAgcmV0dXJuIGJhc2U7XG4gICAgICB9XG4gICAgICBsZXQgbWFwID0gbWl4aW5BcHBsaWNhdGlvbnM7XG4gICAgICBsZXQgZXh0ZW5kZWQgPSBtYXAuZ2V0KGJhc2UpO1xuICAgICAgaWYgKCFleHRlbmRlZCkge1xuICAgICAgICBleHRlbmRlZCA9IC8qKiBAdHlwZSB7IUZ1bmN0aW9ufSAqLyhtaXhpbikoYmFzZSk7XG4gICAgICAgIG1hcC5zZXQoYmFzZSwgZXh0ZW5kZWQpO1xuICAgICAgfVxuICAgICAgLy8gY29weSBpbmhlcml0ZWQgbWl4aW4gc2V0IGZyb20gdGhlIGV4dGVuZGVkIGNsYXNzLCBvciB0aGUgYmFzZSBjbGFzc1xuICAgICAgLy8gTk9URTogd2UgYXZvaWQgdXNlIG9mIFNldCBoZXJlIGJlY2F1c2Ugc29tZSBicm93c2VyIChJRTExKVxuICAgICAgLy8gY2Fubm90IGV4dGVuZCBhIGJhc2UgU2V0IHZpYSB0aGUgY29uc3RydWN0b3IuXG4gICAgICBsZXQgbWl4aW5TZXQgPSBPYmplY3QuY3JlYXRlKC8qKiBAdHlwZSB7IU1peGluRnVuY3Rpb259ICovKGV4dGVuZGVkKS5fX21peGluU2V0IHx8IGJhc2VTZXQgfHwgbnVsbCk7XG4gICAgICBtaXhpblNldFttaXhpbkRlZHVwZUlkXSA9IHRydWU7XG4gICAgICAvKiogQHR5cGUgeyFNaXhpbkZ1bmN0aW9ufSAqLyhleHRlbmRlZCkuX19taXhpblNldCA9IG1peGluU2V0O1xuICAgICAgcmV0dXJuIGV4dGVuZGVkO1xuICAgIH1cblxuICAgIHJldHVybiBkZWR1cGluZ01peGluO1xuICB9O1xuICAvKiBlc2xpbnQtZW5hYmxlIHZhbGlkLWpzZG9jICovXG5cbn0pKCk7XG5cbjwvc2NyaXB0PlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi91dGlscy9taXhpbi5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNiBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuXG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vLi4vcG9seW1lci9wb2x5bWVyLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi8uLi9pcm9uLXNjcm9sbC10YXJnZXQtYmVoYXZpb3IvaXJvbi1zY3JvbGwtdGFyZ2V0LWJlaGF2aW9yLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi9oZWxwZXJzL2hlbHBlcnMuaHRtbFwiPlxuXG48c2NyaXB0PlxuICAvKipcbiAgICogYFBvbHltZXIuQXBwU2Nyb2xsRWZmZWN0c0JlaGF2aW9yYCBwcm92aWRlcyBhbiBpbnRlcmZhY2UgdGhhdCBhbGxvd3MgYW4gZWxlbWVudCB0byB1c2Ugc2Nyb2xscyBlZmZlY3RzLlxuICAgKlxuICAgKiAjIyMgSW1wb3J0aW5nIHRoZSBhcHAtbGF5b3V0IGVmZmVjdHNcbiAgICpcbiAgICogYXBwLWxheW91dCBwcm92aWRlcyBhIHNldCBvZiBzY3JvbGwgZWZmZWN0cyB0aGF0IGNhbiBiZSB1c2VkIGJ5IGV4cGxpY2l0bHkgaW1wb3J0aW5nXG4gICAqIGBhcHAtc2Nyb2xsLWVmZmVjdHMuaHRtbGA6XG4gICAqXG4gICAqIGBgYGh0bWxcbiAgICogPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi9ib3dlcl9jb21wb25lbnRzL2FwcC1sYXlvdXQvYXBwLXNjcm9sbC1lZmZlY3RzL2FwcC1zY3JvbGwtZWZmZWN0cy5odG1sXCI+XG4gICAqIGBgYFxuICAgKlxuICAgKiBUaGUgc2Nyb2xsIGVmZmVjdHMgY2FuIGFsc28gYmUgdXNlZCBieSBpbmRpdmlkdWFsbHkgaW1wb3J0aW5nXG4gICAqIGBhcHAtbGF5b3V0L2FwcC1zY3JvbGwtZWZmZWN0cy9lZmZlY3RzL1tlZmZlY3ROYW1lXS5odG1sYC4gRm9yIGV4YW1wbGU6XG4gICAqXG4gICAqIGBgYGh0bWxcbiAgICogIDxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIvYm93ZXJfY29tcG9uZW50cy9hcHAtbGF5b3V0L2FwcC1zY3JvbGwtZWZmZWN0cy9lZmZlY3RzL3dhdGVyZmFsbC5odG1sXCI+XG4gICAqIGBgYFxuICAgKlxuICAgKiAjIyMgQ29uc3VtaW5nIGVmZmVjdHNcbiAgICpcbiAgICogRWZmZWN0cyBjYW4gYmUgY29uc3VtZWQgdmlhIHRoZSBgZWZmZWN0c2AgcHJvcGVydHkuIEZvciBleGFtcGxlOlxuICAgKlxuICAgKiBgYGBodG1sXG4gICAqIDxhcHAtaGVhZGVyIGVmZmVjdHM9XCJ3YXRlcmZhbGxcIj48L2FwcC1oZWFkZXI+XG4gICAqIGBgYFxuICAgKlxuICAgKiAjIyMgQ3JlYXRpbmcgc2Nyb2xsIGVmZmVjdHNcbiAgICpcbiAgICogWW91IG1heSB3YW50IHRvIGNyZWF0ZSBhIGN1c3RvbSBzY3JvbGwgZWZmZWN0IGlmIHlvdSBuZWVkIHRvIG1vZGlmeSB0aGUgQ1NTIG9mIGFuIGVsZW1lbnRcbiAgICogYmFzZWQgb24gdGhlIHNjcm9sbCBwb3NpdGlvbi5cbiAgICpcbiAgICogQSBzY3JvbGwgZWZmZWN0IGRlZmluaXRpb24gaXMgYW4gb2JqZWN0IHdpdGggYHNldFVwKClgLCBgdGVhckRvd24oKWAgYW5kIGBydW4oKWAgZnVuY3Rpb25zLlxuICAgKlxuICAgKiBUbyByZWdpc3RlciB0aGUgZWZmZWN0LCB5b3UgY2FuIHVzZSBgUG9seW1lci5BcHBMYXlvdXQucmVnaXN0ZXJFZmZlY3QoZWZmZWN0TmFtZSwgZWZmZWN0RGVmKWBcbiAgICogRm9yIGV4YW1wbGUsIGxldCdzIGRlZmluZSBhbiBlZmZlY3QgdGhhdCByZXNpemVzIHRoZSBoZWFkZXIncyBsb2dvOlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiBQb2x5bWVyLkFwcExheW91dC5yZWdpc3RlckVmZmVjdCgncmVzaXphYmxlLWxvZ28nLCB7XG4gICAqICAgc2V0VXA6IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgKiAgICAgLy8gdGhlIGVmZmVjdCdzIGNvbmZpZyBpcyBwYXNzZWQgdG8gdGhlIHNldFVwLlxuICAgKiAgICAgdGhpcy5fZnhSZXNpemVMb2dvID0geyBsb2dvOiBQb2x5bWVyLmRvbSh0aGlzKS5xdWVyeVNlbGVjdG9yKCdbbG9nb10nKSB9O1xuICAgKiAgIH0sXG4gICAqXG4gICAqICAgcnVuOiBmdW5jdGlvbihwcm9ncmVzcykge1xuICAgKiAgICAgIC8vIHRoZSBwcm9ncmVzcyBvZiB0aGUgZWZmZWN0XG4gICAqICAgICAgdGhpcy50cmFuc2Zvcm0oJ3NjYWxlM2QoJyArIHByb2dyZXNzICsgJywgJysgcHJvZ3Jlc3MgKycsIDEpJywgIHRoaXMuX2Z4UmVzaXplTG9nby5sb2dvKTtcbiAgICogICB9LFxuICAgKlxuICAgKiAgIHRlYXJEb3duOiBmdW5jdGlvbigpIHtcbiAgICogICAgICAvLyBjbGVhbiB1cCBhbmQgcmVzZXQgb2Ygc3RhdGVzXG4gICAqICAgICAgZGVsZXRlIHRoaXMuX2Z4UmVzaXplTG9nbztcbiAgICogICB9XG4gICAqIH0pO1xuICAgKiBgYGBcbiAgICogTm93LCB5b3UgY2FuIGNvbnN1bWUgdGhlIGVmZmVjdDpcbiAgICpcbiAgICogYGBgaHRtbFxuICAgKiA8YXBwLWhlYWRlciBpZD1cImFwcEhlYWRlclwiIGVmZmVjdHM9XCJyZXNpemFibGUtbG9nb1wiPlxuICAgKiAgIDxpbWcgbG9nbyBzcmM9XCJsb2dvLnN2Z1wiPlxuICAgKiA8L2FwcC1oZWFkZXI+XG4gICAqIGBgYFxuICAgKlxuICAgKiAjIyMgSW1wZXJhdGl2ZSBBUElcbiAgICpcbiAgICogYGBganNcbiAgICogdmFyIGxvZ29FZmZlY3QgPSBhcHBIZWFkZXIuY3JlYXRlRWZmZWN0KCdyZXNpemFibGUtbG9nbycsIGVmZmVjdENvbmZpZyk7XG4gICAqIC8vIHJ1biB0aGUgZWZmZWN0OiBsb2dvRWZmZWN0LnJ1bihwcm9ncmVzcyk7XG4gICAqIC8vIHRlYXIgZG93biB0aGUgZWZmZWN0OiBsb2dvRWZmZWN0LnRlYXJEb3duKCk7XG4gICAqIGBgYFxuICAgKlxuICAgKiAjIyMgQ29uZmlndXJpbmcgZWZmZWN0c1xuICAgKlxuICAgKiBGb3IgZWZmZWN0cyBpbnN0YWxsZWQgdmlhIHRoZSBgZWZmZWN0c2AgcHJvcGVydHksIHRoZWlyIGNvbmZpZ3VyYXRpb24gY2FuIGJlIHNldFxuICAgKiB2aWEgdGhlIGBlZmZlY3RzQ29uZmlnYCBwcm9wZXJ0eS4gRm9yIGV4YW1wbGU6XG4gICAqXG4gICAqIGBgYGh0bWxcbiAgICogPGFwcC1oZWFkZXIgZWZmZWN0cz1cIndhdGVyZmFsbFwiXG4gICAqICAgZWZmZWN0cy1jb25maWc9J3tcIndhdGVyZmFsbFwiOiB7XCJzdGFydHNBdFwiOiAwLCBcImVuZHNBdFwiOiAwLjV9fSc+XG4gICAqIDwvYXBwLWhlYWRlcj5cbiAgICogYGBgXG4gICAqXG4gICAqIEFsbCBlZmZlY3RzIGhhdmUgYSBgc3RhcnRzQXRgIGFuZCBgZW5kc0F0YCBjb25maWcgcHJvcGVydHkuIFRoZXkgc3BlY2lmeSBhdCB3aGF0XG4gICAqIHBvaW50IHRoZSBlZmZlY3Qgc2hvdWxkIHN0YXJ0IGFuZCBlbmQuIFRoaXMgdmFsdWUgZ29lcyBmcm9tIDAgdG8gMSBpbmNsdXNpdmUuXG4gICAqXG4gICAqIEBwb2x5bWVyQmVoYXZpb3JcbiAgICovXG4gIFBvbHltZXIuQXBwU2Nyb2xsRWZmZWN0c0JlaGF2aW9yID0gW1xuICAgIFBvbHltZXIuSXJvblNjcm9sbFRhcmdldEJlaGF2aW9yLFxuICAge1xuXG4gICAgcHJvcGVydGllczoge1xuXG4gICAgICAvKipcbiAgICAgICAqIEEgc3BhY2Utc2VwYXJhdGVkIGxpc3Qgb2YgdGhlIGVmZmVjdHMgbmFtZXMgdGhhdCB3aWxsIGJlIHRyaWdnZXJlZCB3aGVuIHRoZSB1c2VyIHNjcm9sbHMuXG4gICAgICAgKiBlLmcuIGB3YXRlcmZhbGwgcGFyYWxsYXgtYmFja2dyb3VuZGAgaW5zdGFsbHMgdGhlIGB3YXRlcmZhbGxgIGFuZCBgcGFyYWxsYXgtYmFja2dyb3VuZGAuXG4gICAgICAgKi9cbiAgICAgIGVmZmVjdHM6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nXG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIEFuIG9iamVjdCB0aGF0IGNvbmZpZ3VyYXRlcyB0aGUgZWZmZWN0cyBpbnN0YWxsZWQgdmlhIHRoZSBgZWZmZWN0c2AgcHJvcGVydHkuIGUuZy5cbiAgICAgICAqIGBgYGpzXG4gICAgICAgKiAgZWxlbWVudC5lZmZlY3RzQ29uZmlnID0ge1xuICAgICAgICogICBcImJsZW5kLWJhY2tncm91bmRcIjoge1xuICAgICAgICogICAgIFwic3RhcnRzQXRcIjogMC41XG4gICAgICAgKiAgIH1cbiAgICAgICAqIH07XG4gICAgICAgKiBgYGBcbiAgICAgICAqIEV2ZXJ5IGVmZmVjdCBoYXMgYXQgbGVhc3QgdHdvIGNvbmZpZyBwcm9wZXJ0aWVzOiBgc3RhcnRzQXRgIGFuZCBgZW5kc0F0YC5cbiAgICAgICAqIFRoZXNlIHByb3BlcnRpZXMgaW5kaWNhdGUgd2hlbiB0aGUgZXZlbnQgc2hvdWxkIHN0YXJ0IGFuZCBlbmQgcmVzcGVjdGl2ZWx5XG4gICAgICAgKiBhbmQgcmVsYXRpdmUgdG8gdGhlIG92ZXJhbGwgZWxlbWVudCBwcm9ncmVzcy4gU28gZm9yIGV4YW1wbGUsIGlmIGBibGVuZC1iYWNrZ3JvdW5kYFxuICAgICAgICogc3RhcnRzIGF0IGAwLjVgLCB0aGUgZWZmZWN0IHdpbGwgb25seSBzdGFydCBvbmNlIHRoZSBjdXJyZW50IGVsZW1lbnQgcmVhY2hlcyAwLjVcbiAgICAgICAqIG9mIGl0cyBwcm9ncmVzcy4gSW4gdGhpcyBjb250ZXh0LCB0aGUgcHJvZ3Jlc3MgaXMgYSB2YWx1ZSBpbiB0aGUgcmFuZ2Ugb2YgYFswLCAxXWBcbiAgICAgICAqIHRoYXQgaW5kaWNhdGVzIHdoZXJlIHRoaXMgZWxlbWVudCBpcyBvbiB0aGUgc2NyZWVuIHJlbGF0aXZlIHRvIHRoZSB2aWV3cG9ydC5cbiAgICAgICAqL1xuICAgICAgZWZmZWN0c0NvbmZpZzoge1xuICAgICAgICB0eXBlOiBPYmplY3QsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogRGlzYWJsZXMgQ1NTIHRyYW5zaXRpb25zIGFuZCBzY3JvbGwgZWZmZWN0cyBvbiB0aGUgZWxlbWVudC5cbiAgICAgICAqL1xuICAgICAgZGlzYWJsZWQ6IHtcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgcmVmbGVjdFRvQXR0cmlidXRlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogQWxsb3dzIHRvIHNldCBhIGBzY3JvbGxUb3BgIHRocmVzaG9sZC4gV2hlbiBncmVhdGVyIHRoYW4gMCwgYHRocmVzaG9sZFRyaWdnZXJlZGBcbiAgICAgICAqIGlzIHRydWUgb25seSB3aGVuIHRoZSBzY3JvbGwgdGFyZ2V0J3MgYHNjcm9sbFRvcGAgaGFzIHJlYWNoZWQgdGhpcyB2YWx1ZS5cbiAgICAgICAqXG4gICAgICAgKiBGb3IgZXhhbXBsZSwgaWYgYHRocmVzaG9sZCA9IDEwMGAsIGB0aHJlc2hvbGRUcmlnZ2VyZWRgIGlzIHRydWUgd2hlbiB0aGUgYHNjcm9sbFRvcGBcbiAgICAgICAqIGlzIGF0IGxlYXN0IGAxMDBgLlxuICAgICAgICovXG4gICAgICB0aHJlc2hvbGQ6IHtcbiAgICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgICB2YWx1ZTogMFxuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBUcnVlIGlmIHRoZSBgc2Nyb2xsVG9wYCB0aHJlc2hvbGQgKHNldCBpbiBgc2Nyb2xsVG9wVGhyZXNob2xkYCkgaGFzXG4gICAgICAgKiBiZWVuIHJlYWNoZWQuXG4gICAgICAgKi9cbiAgICAgIHRocmVzaG9sZFRyaWdnZXJlZDoge1xuICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICBub3RpZnk6IHRydWUsXG4gICAgICAgIHJlYWRPbmx5OiB0cnVlLFxuICAgICAgICByZWZsZWN0VG9BdHRyaWJ1dGU6IHRydWVcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgb2JzZXJ2ZXJzOiBbXG4gICAgICAnX2VmZmVjdHNDaGFuZ2VkKGVmZmVjdHMsIGVmZmVjdHNDb25maWcsIGlzQXR0YWNoZWQpJ1xuICAgIF0sXG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBzY3JvbGwgc3RhdGUuIFRoaXMgbWV0aG9kIHNob3VsZCBiZSBvdmVycmlkZGVuXG4gICAgICogYnkgdGhlIGNvbnN1bWVyIG9mIHRoaXMgYmVoYXZpb3IuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIF91cGRhdGVTY3JvbGxTdGF0ZVxuICAgICAqL1xuICAgIF91cGRhdGVTY3JvbGxTdGF0ZTogZnVuY3Rpb24oKSB7fSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgY3VycmVudCBlbGVtZW50IGlzIG9uIHRoZSBzY3JlZW4uXG4gICAgICogVGhhdCBpcywgdmlzaWJsZSBpbiB0aGUgY3VycmVudCB2aWV3cG9ydC4gVGhpcyBtZXRob2Qgc2hvdWxkIGJlXG4gICAgICogb3ZlcnJpZGRlbiBieSB0aGUgY29uc3VtZXIgb2YgdGhpcyBiZWhhdmlvci5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgaXNPblNjcmVlblxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgaXNPblNjcmVlbjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGVyZSdzIGNvbnRlbnQgYmVsb3cgdGhlIGN1cnJlbnQgZWxlbWVudC4gVGhpcyBtZXRob2RcbiAgICAgKiBzaG91bGQgYmUgb3ZlcnJpZGRlbiBieSB0aGUgY29uc3VtZXIgb2YgdGhpcyBiZWhhdmlvci5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgaXNDb250ZW50QmVsb3dcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuICAgIGlzQ29udGVudEJlbG93OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTGlzdCBvZiBlZmZlY3RzIGhhbmRsZXJzIHRoYXQgd2lsbCB0YWtlIHBsYWNlIGR1cmluZyBzY3JvbGwuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7QXJyYXk8RnVuY3Rpb24+fVxuICAgICAqL1xuICAgIF9lZmZlY3RzUnVuRm46IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBMaXN0IG9mIHRoZSBlZmZlY3RzIGRlZmluaXRpb25zIGluc3RhbGxlZCB2aWEgdGhlIGBlZmZlY3RzYCBwcm9wZXJ0eS5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtBcnJheTxPYmplY3Q+fVxuICAgICAqL1xuICAgIF9lZmZlY3RzOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogVGhlIGNsYW1wZWQgdmFsdWUgb2YgYF9zY3JvbGxUb3BgLlxuICAgICAqIEB0eXBlIG51bWJlclxuICAgICAqL1xuICAgIGdldCBfY2xhbXBlZFNjcm9sbFRvcCgpIHtcbiAgICAgIHJldHVybiBNYXRoLm1heCgwLCB0aGlzLl9zY3JvbGxUb3ApO1xuICAgIH0sXG5cbiAgICBkZXRhY2hlZDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl90ZWFyRG93bkVmZmVjdHMoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBlZmZlY3Qgb2JqZWN0IGZyb20gYW4gZWZmZWN0J3MgbmFtZSB0aGF0IGNhbiBiZSB1c2VkIHRvIHJ1blxuICAgICAqIGVmZmVjdHMgcHJvZ3JhbW1hdGljYWxseS5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgY3JlYXRlRWZmZWN0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGVmZmVjdE5hbWUgVGhlIGVmZmVjdCdzIG5hbWUgcmVnaXN0ZXJlZCB2aWEgYFBvbHltZXIuQXBwTGF5b3V0LnJlZ2lzdGVyRWZmZWN0YC5cbiAgICAgKiBAcGFyYW0ge09iamVjdD19IGVmZmVjdENvbmZpZyBUaGUgZWZmZWN0IGNvbmZpZyBvYmplY3QuIChPcHRpb25hbClcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEFuIGVmZmVjdCBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIGZ1bmN0aW9uczpcbiAgICAgKlxuICAgICAqICAqIGBlZmZlY3Quc2V0VXAoKWAsIFNldHMgdXAgdGhlIHJlcXVpcmVtZW50cyBmb3IgdGhlIGVmZmVjdC5cbiAgICAgKiAgICAgICBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBhdXRvbWF0aWNhbGx5IGJlZm9yZSB0aGUgYGVmZmVjdGAgZnVuY3Rpb24gcmV0dXJucy5cbiAgICAgKiAgKiBgZWZmZWN0LnJ1bihwcm9ncmVzcywgeSlgLCBSdW5zIHRoZSBlZmZlY3QgZ2l2ZW4gYSBgcHJvZ3Jlc3NgLlxuICAgICAqICAqIGBlZmZlY3QudGVhckRvd24oKWAsIENsZWFucyB1cCBhbnkgRE9NIG5vZGVzIG9yIGVsZW1lbnQgcmVmZXJlbmNlcyB1c2VkIGJ5IHRoZSBlZmZlY3QuXG4gICAgICpcbiAgICAgKiBFeGFtcGxlOlxuICAgICAqIGBgYGpzXG4gICAgICogdmFyIHBhcmFsbGF4ID0gZWxlbWVudC5jcmVhdGVFZmZlY3QoJ3BhcmFsbGF4LWJhY2tncm91bmQnKTtcbiAgICAgKiAvLyBydW5zIHRoZSBlZmZlY3RcbiAgICAgKiBwYXJhbGxheC5ydW4oMC41LCAwKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBjcmVhdGVFZmZlY3Q6IGZ1bmN0aW9uKGVmZmVjdE5hbWUsIGVmZmVjdENvbmZpZykge1xuICAgICAgdmFyIGVmZmVjdERlZiA9IFBvbHltZXIuQXBwTGF5b3V0Ll9zY3JvbGxFZmZlY3RzW2VmZmVjdE5hbWVdO1xuICAgICAgaWYgKCFlZmZlY3REZWYpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKHRoaXMuX2dldFVuZGVmaW5lZE1zZyhlZmZlY3ROYW1lKSk7XG4gICAgICB9XG4gICAgICB2YXIgcHJvcCA9IHRoaXMuX2JvdW5kRWZmZWN0KGVmZmVjdERlZiwgZWZmZWN0Q29uZmlnIHx8IHt9KTtcbiAgICAgIHByb3Auc2V0VXAoKTtcbiAgICAgIHJldHVybiBwcm9wO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiBgZWZmZWN0c2Agb3IgYGVmZmVjdHNDb25maWdgIGNoYW5nZXMuXG4gICAgICovXG4gICAgX2VmZmVjdHNDaGFuZ2VkOiBmdW5jdGlvbihlZmZlY3RzLCBlZmZlY3RzQ29uZmlnLCBpc0F0dGFjaGVkKSB7XG4gICAgICB0aGlzLl90ZWFyRG93bkVmZmVjdHMoKTtcblxuICAgICAgaWYgKCFlZmZlY3RzIHx8ICFpc0F0dGFjaGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGVmZmVjdHMuc3BsaXQoJyAnKS5mb3JFYWNoKGZ1bmN0aW9uKGVmZmVjdE5hbWUpIHtcbiAgICAgICAgdmFyIGVmZmVjdERlZjtcbiAgICAgICAgaWYgKGVmZmVjdE5hbWUgIT09ICcnKSB7XG4gICAgICAgICAgaWYgKChlZmZlY3REZWYgPSBQb2x5bWVyLkFwcExheW91dC5fc2Nyb2xsRWZmZWN0c1tlZmZlY3ROYW1lXSkpIHtcbiAgICAgICAgICAgIHRoaXMuX2VmZmVjdHMucHVzaCh0aGlzLl9ib3VuZEVmZmVjdChlZmZlY3REZWYsIGVmZmVjdHNDb25maWdbZWZmZWN0TmFtZV0pKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKHRoaXMuX2dldFVuZGVmaW5lZE1zZyhlZmZlY3ROYW1lKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCB0aGlzKTtcblxuICAgICAgdGhpcy5fc2V0VXBFZmZlY3QoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRm9yY2VzIGxheW91dFxuICAgICAqL1xuICAgIF9sYXlvdXRJZkRpcnR5OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLm9mZnNldFdpZHRoO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGVmZmVjdCBvYmplY3QgYm91bmQgdG8gdGhlIGN1cnJlbnQgY29udGV4dC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlZmZlY3REZWZcbiAgICAgKiBAcGFyYW0ge09iamVjdD19IGVmZmVjdHNDb25maWcgVGhlIGVmZmVjdCBjb25maWcgb2JqZWN0IGlmIHRoZSBlZmZlY3QgYWNjZXB0cyBjb25maWcgdmFsdWVzLiAoT3B0aW9uYWwpXG4gICAgICovXG4gICAgX2JvdW5kRWZmZWN0OiBmdW5jdGlvbihlZmZlY3REZWYsIGVmZmVjdHNDb25maWcpIHtcbiAgICAgIGVmZmVjdHNDb25maWcgPSBlZmZlY3RzQ29uZmlnIHx8IHt9O1xuICAgICAgdmFyIHN0YXJ0c0F0ID0gcGFyc2VGbG9hdChlZmZlY3RzQ29uZmlnLnN0YXJ0c0F0IHx8IDApO1xuICAgICAgdmFyIGVuZHNBdCA9IHBhcnNlRmxvYXQoZWZmZWN0c0NvbmZpZy5lbmRzQXQgfHwgMSk7XG4gICAgICB2YXIgZGVsdGFTID0gZW5kc0F0IC0gc3RhcnRzQXQ7XG4gICAgICB2YXIgbm9vcCA9IGZ1bmN0aW9uKCkge307XG4gICAgICAvLyBmYXN0IHBhdGggaWYgcG9zc2libGVcbiAgICAgIHZhciBydW5GbiA9IChzdGFydHNBdCA9PT0gMCAmJiBlbmRzQXQgPT09IDEpID8gZWZmZWN0RGVmLnJ1biA6XG4gICAgICAgIGZ1bmN0aW9uKHByb2dyZXNzLCB5KSB7XG4gICAgICAgICAgZWZmZWN0RGVmLnJ1bi5jYWxsKHRoaXMsXG4gICAgICAgICAgICAgIE1hdGgubWF4KDAsIChwcm9ncmVzcyAtIHN0YXJ0c0F0KSAvIGRlbHRhUyksIHkpO1xuICAgICAgICB9O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2V0VXA6IGVmZmVjdERlZi5zZXRVcCA/IGVmZmVjdERlZi5zZXRVcC5iaW5kKHRoaXMsIGVmZmVjdHNDb25maWcpIDogbm9vcCxcbiAgICAgICAgcnVuOiBlZmZlY3REZWYucnVuID8gcnVuRm4uYmluZCh0aGlzKSA6IG5vb3AsXG4gICAgICAgIHRlYXJEb3duOiBlZmZlY3REZWYudGVhckRvd24gPyBlZmZlY3REZWYudGVhckRvd24uYmluZCh0aGlzKSA6IG5vb3BcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgdXAgdGhlIGVmZmVjdHMuXG4gICAgICovXG4gICAgX3NldFVwRWZmZWN0OiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmlzQXR0YWNoZWQgJiYgdGhpcy5fZWZmZWN0cykge1xuICAgICAgICB0aGlzLl9lZmZlY3RzUnVuRm4gPSBbXTtcbiAgICAgICAgdGhpcy5fZWZmZWN0cy5mb3JFYWNoKGZ1bmN0aW9uKGVmZmVjdERlZikge1xuICAgICAgICAgIC8vIGluc3RhbGwgdGhlIGVmZmVjdCBvbmx5IGlmIG5vIGVycm9yIHdhcyByZXBvcnRlZFxuICAgICAgICAgIGlmIChlZmZlY3REZWYuc2V0VXAoKSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRoaXMuX2VmZmVjdHNSdW5Gbi5wdXNoKGVmZmVjdERlZi5ydW4pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRlYXJzIGRvd24gdGhlIGVmZmVjdHMuXG4gICAgICovXG4gICAgX3RlYXJEb3duRWZmZWN0czogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5fZWZmZWN0cykge1xuICAgICAgICB0aGlzLl9lZmZlY3RzLmZvckVhY2goZnVuY3Rpb24oZWZmZWN0RGVmKSB7XG4gICAgICAgICAgZWZmZWN0RGVmLnRlYXJEb3duKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdGhpcy5fZWZmZWN0c1J1bkZuID0gW107XG4gICAgICB0aGlzLl9lZmZlY3RzID0gW107XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJ1bnMgdGhlIGVmZmVjdHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcCBUaGUgcHJvZ3Jlc3NcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSBUaGUgdG9wIHBvc2l0aW9uIG9mIHRoZSBjdXJyZW50IGVsZW1lbnQgcmVsYXRpdmUgdG8gdGhlIHZpZXdwb3J0LlxuICAgICAqL1xuICAgIF9ydW5FZmZlY3RzOiBmdW5jdGlvbihwLCB5KSB7XG4gICAgICBpZiAodGhpcy5fZWZmZWN0c1J1bkZuKSB7XG4gICAgICAgIHRoaXMuX2VmZmVjdHNSdW5Gbi5mb3JFYWNoKGZ1bmN0aW9uKHJ1bikge1xuICAgICAgICAgIHJ1bihwLCB5KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlcyB0aGUgYF9zY3JvbGxIYW5kbGVyYC5cbiAgICAgKi9cbiAgICBfc2Nyb2xsSGFuZGxlcjogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgdmFyIHNjcm9sbFRvcCA9IHRoaXMuX2NsYW1wZWRTY3JvbGxUb3A7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVNjcm9sbFN0YXRlKHNjcm9sbFRvcCk7XG4gICAgICAgIGlmICh0aGlzLnRocmVzaG9sZCA+IDApIHtcbiAgICAgICAgICB0aGlzLl9zZXRUaHJlc2hvbGRUcmlnZ2VyZWQoc2Nyb2xsVG9wID49IHRoaXMudGhyZXNob2xkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSB0aGlzIG1ldGhvZCB0byByZXR1cm4gYSByZWZlcmVuY2UgdG8gYSBub2RlIGluIHRoZSBsb2NhbCBET00uXG4gICAgICogVGhlIG5vZGUgaXMgY29uc3VtZWQgYnkgYSBzY3JvbGwgZWZmZWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkIFRoZSBpZCBmb3IgdGhlIG5vZGUuXG4gICAgICovXG4gICAgX2dldERPTVJlZjogZnVuY3Rpb24oaWQpIHtcbiAgICAgIGNvbnNvbGUud2FybignX2dldERPTVJlZicsICdgJysgaWQgKydgIGlzIHVuZGVmaW5lZCcpO1xuICAgIH0sXG5cbiAgICBfZ2V0VW5kZWZpbmVkTXNnOiBmdW5jdGlvbihlZmZlY3ROYW1lKSB7XG4gICAgICByZXR1cm4gJ1Njcm9sbCBlZmZlY3QgYCcgKyBlZmZlY3ROYW1lICsgJ2AgaXMgdW5kZWZpbmVkLiAnICtcbiAgICAgICAgICAnRGlkIHlvdSBmb3JnZXQgdG8gaW1wb3J0IGFwcC1sYXlvdXQvYXBwLXNjcm9sbC1lZmZlY3RzL2VmZmVjdHMvJyArIGVmZmVjdE5hbWUgKyAnLmh0bWwgPyc7XG4gICAgfVxuXG4gIH1dO1xuXG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvYXBwLWxheW91dC9hcHAtc2Nyb2xsLWVmZmVjdHMvYXBwLXNjcm9sbC1lZmZlY3RzLWJlaGF2aW9yLmh0bWwiLCJcbnJlcXVpcmUoJy4uL3BvbHltZXIvcG9seW1lci5odG1sJyk7XG5cbmNvbnN0IFJlZ2lzdGVySHRtbFRlbXBsYXRlID0gcmVxdWlyZSgncG9seW1lci13ZWJwYWNrLWxvYWRlci9yZWdpc3Rlci1odG1sLXRlbXBsYXRlJyk7XG5cblJlZ2lzdGVySHRtbFRlbXBsYXRlLnRvQm9keShcIjxjdXN0b20tc3R5bGU+IDxzdHlsZSBpcz1jdXN0b20tc3R5bGU+aHRtbHstLWxheW91dDp7ZGlzcGxheTotbXMtZmxleGJveDtkaXNwbGF5Oi13ZWJraXQtZmxleDtkaXNwbGF5OmZsZXh9Oy0tbGF5b3V0LWlubGluZTp7ZGlzcGxheTotbXMtaW5saW5lLWZsZXhib3g7ZGlzcGxheTotd2Via2l0LWlubGluZS1mbGV4O2Rpc3BsYXk6aW5saW5lLWZsZXh9Oy0tbGF5b3V0LWhvcml6b250YWw6e0BhcHBseSAtLWxheW91dDstbXMtZmxleC1kaXJlY3Rpb246cm93Oy13ZWJraXQtZmxleC1kaXJlY3Rpb246cm93O2ZsZXgtZGlyZWN0aW9uOnJvd307LS1sYXlvdXQtaG9yaXpvbnRhbC1yZXZlcnNlOntAYXBwbHkgLS1sYXlvdXQ7LW1zLWZsZXgtZGlyZWN0aW9uOnJvdy1yZXZlcnNlOy13ZWJraXQtZmxleC1kaXJlY3Rpb246cm93LXJldmVyc2U7ZmxleC1kaXJlY3Rpb246cm93LXJldmVyc2V9Oy0tbGF5b3V0LXZlcnRpY2FsOntAYXBwbHkgLS1sYXlvdXQ7LW1zLWZsZXgtZGlyZWN0aW9uOmNvbHVtbjstd2Via2l0LWZsZXgtZGlyZWN0aW9uOmNvbHVtbjtmbGV4LWRpcmVjdGlvbjpjb2x1bW59Oy0tbGF5b3V0LXZlcnRpY2FsLXJldmVyc2U6e0BhcHBseSAtLWxheW91dDstbXMtZmxleC1kaXJlY3Rpb246Y29sdW1uLXJldmVyc2U7LXdlYmtpdC1mbGV4LWRpcmVjdGlvbjpjb2x1bW4tcmV2ZXJzZTtmbGV4LWRpcmVjdGlvbjpjb2x1bW4tcmV2ZXJzZX07LS1sYXlvdXQtd3JhcDp7LW1zLWZsZXgtd3JhcDp3cmFwOy13ZWJraXQtZmxleC13cmFwOndyYXA7ZmxleC13cmFwOndyYXB9Oy0tbGF5b3V0LXdyYXAtcmV2ZXJzZTp7LW1zLWZsZXgtd3JhcDp3cmFwLXJldmVyc2U7LXdlYmtpdC1mbGV4LXdyYXA6d3JhcC1yZXZlcnNlO2ZsZXgtd3JhcDp3cmFwLXJldmVyc2V9Oy0tbGF5b3V0LWZsZXgtYXV0bzp7LW1zLWZsZXg6MSAxIGF1dG87LXdlYmtpdC1mbGV4OjEgMSBhdXRvO2ZsZXg6MSAxIGF1dG99Oy0tbGF5b3V0LWZsZXgtbm9uZTp7LW1zLWZsZXg6bm9uZTstd2Via2l0LWZsZXg6bm9uZTtmbGV4Om5vbmV9Oy0tbGF5b3V0LWZsZXg6ey1tcy1mbGV4OjEgMSAuMDAwMDAwMDAxcHg7LXdlYmtpdC1mbGV4OjE7ZmxleDoxOy13ZWJraXQtZmxleC1iYXNpczouMDAwMDAwMDAxcHg7ZmxleC1iYXNpczouMDAwMDAwMDAxcHh9Oy0tbGF5b3V0LWZsZXgtMjp7LW1zLWZsZXg6Mjstd2Via2l0LWZsZXg6MjtmbGV4OjJ9Oy0tbGF5b3V0LWZsZXgtMzp7LW1zLWZsZXg6Mzstd2Via2l0LWZsZXg6MztmbGV4OjN9Oy0tbGF5b3V0LWZsZXgtNDp7LW1zLWZsZXg6NDstd2Via2l0LWZsZXg6NDtmbGV4OjR9Oy0tbGF5b3V0LWZsZXgtNTp7LW1zLWZsZXg6NTstd2Via2l0LWZsZXg6NTtmbGV4OjV9Oy0tbGF5b3V0LWZsZXgtNjp7LW1zLWZsZXg6Njstd2Via2l0LWZsZXg6NjtmbGV4OjZ9Oy0tbGF5b3V0LWZsZXgtNzp7LW1zLWZsZXg6Nzstd2Via2l0LWZsZXg6NztmbGV4Ojd9Oy0tbGF5b3V0LWZsZXgtODp7LW1zLWZsZXg6ODstd2Via2l0LWZsZXg6ODtmbGV4Ojh9Oy0tbGF5b3V0LWZsZXgtOTp7LW1zLWZsZXg6OTstd2Via2l0LWZsZXg6OTtmbGV4Ojl9Oy0tbGF5b3V0LWZsZXgtMTA6ey1tcy1mbGV4OjEwOy13ZWJraXQtZmxleDoxMDtmbGV4OjEwfTstLWxheW91dC1mbGV4LTExOnstbXMtZmxleDoxMTstd2Via2l0LWZsZXg6MTE7ZmxleDoxMX07LS1sYXlvdXQtZmxleC0xMjp7LW1zLWZsZXg6MTI7LXdlYmtpdC1mbGV4OjEyO2ZsZXg6MTJ9Oy0tbGF5b3V0LXN0YXJ0OnstbXMtZmxleC1hbGlnbjpzdGFydDstd2Via2l0LWFsaWduLWl0ZW1zOmZsZXgtc3RhcnQ7YWxpZ24taXRlbXM6ZmxleC1zdGFydH07LS1sYXlvdXQtY2VudGVyOnstbXMtZmxleC1hbGlnbjpjZW50ZXI7LXdlYmtpdC1hbGlnbi1pdGVtczpjZW50ZXI7YWxpZ24taXRlbXM6Y2VudGVyfTstLWxheW91dC1lbmQ6ey1tcy1mbGV4LWFsaWduOmVuZDstd2Via2l0LWFsaWduLWl0ZW1zOmZsZXgtZW5kO2FsaWduLWl0ZW1zOmZsZXgtZW5kfTstLWxheW91dC1iYXNlbGluZTp7LW1zLWZsZXgtYWxpZ246YmFzZWxpbmU7LXdlYmtpdC1hbGlnbi1pdGVtczpiYXNlbGluZTthbGlnbi1pdGVtczpiYXNlbGluZX07LS1sYXlvdXQtc3RhcnQtanVzdGlmaWVkOnstbXMtZmxleC1wYWNrOnN0YXJ0Oy13ZWJraXQtanVzdGlmeS1jb250ZW50OmZsZXgtc3RhcnQ7anVzdGlmeS1jb250ZW50OmZsZXgtc3RhcnR9Oy0tbGF5b3V0LWNlbnRlci1qdXN0aWZpZWQ6ey1tcy1mbGV4LXBhY2s6Y2VudGVyOy13ZWJraXQtanVzdGlmeS1jb250ZW50OmNlbnRlcjtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyfTstLWxheW91dC1lbmQtanVzdGlmaWVkOnstbXMtZmxleC1wYWNrOmVuZDstd2Via2l0LWp1c3RpZnktY29udGVudDpmbGV4LWVuZDtqdXN0aWZ5LWNvbnRlbnQ6ZmxleC1lbmR9Oy0tbGF5b3V0LWFyb3VuZC1qdXN0aWZpZWQ6ey1tcy1mbGV4LXBhY2s6ZGlzdHJpYnV0ZTstd2Via2l0LWp1c3RpZnktY29udGVudDpzcGFjZS1hcm91bmQ7anVzdGlmeS1jb250ZW50OnNwYWNlLWFyb3VuZH07LS1sYXlvdXQtanVzdGlmaWVkOnstbXMtZmxleC1wYWNrOmp1c3RpZnk7LXdlYmtpdC1qdXN0aWZ5LWNvbnRlbnQ6c3BhY2UtYmV0d2VlbjtqdXN0aWZ5LWNvbnRlbnQ6c3BhY2UtYmV0d2Vlbn07LS1sYXlvdXQtY2VudGVyLWNlbnRlcjp7QGFwcGx5IC0tbGF5b3V0LWNlbnRlcjtAYXBwbHkgLS1sYXlvdXQtY2VudGVyLWp1c3RpZmllZDt9Oy0tbGF5b3V0LXNlbGYtc3RhcnQ6ey1tcy1hbGlnbi1zZWxmOmZsZXgtc3RhcnQ7LXdlYmtpdC1hbGlnbi1zZWxmOmZsZXgtc3RhcnQ7YWxpZ24tc2VsZjpmbGV4LXN0YXJ0fTstLWxheW91dC1zZWxmLWNlbnRlcjp7LW1zLWFsaWduLXNlbGY6Y2VudGVyOy13ZWJraXQtYWxpZ24tc2VsZjpjZW50ZXI7YWxpZ24tc2VsZjpjZW50ZXJ9Oy0tbGF5b3V0LXNlbGYtZW5kOnstbXMtYWxpZ24tc2VsZjpmbGV4LWVuZDstd2Via2l0LWFsaWduLXNlbGY6ZmxleC1lbmQ7YWxpZ24tc2VsZjpmbGV4LWVuZH07LS1sYXlvdXQtc2VsZi1zdHJldGNoOnstbXMtYWxpZ24tc2VsZjpzdHJldGNoOy13ZWJraXQtYWxpZ24tc2VsZjpzdHJldGNoO2FsaWduLXNlbGY6c3RyZXRjaH07LS1sYXlvdXQtc2VsZi1iYXNlbGluZTp7LW1zLWFsaWduLXNlbGY6YmFzZWxpbmU7LXdlYmtpdC1hbGlnbi1zZWxmOmJhc2VsaW5lO2FsaWduLXNlbGY6YmFzZWxpbmV9Oy0tbGF5b3V0LXN0YXJ0LWFsaWduZWQ6ey1tcy1mbGV4LWxpbmUtcGFjazpzdGFydDstbXMtYWxpZ24tY29udGVudDpmbGV4LXN0YXJ0Oy13ZWJraXQtYWxpZ24tY29udGVudDpmbGV4LXN0YXJ0O2FsaWduLWNvbnRlbnQ6ZmxleC1zdGFydH07LS1sYXlvdXQtZW5kLWFsaWduZWQ6ey1tcy1mbGV4LWxpbmUtcGFjazplbmQ7LW1zLWFsaWduLWNvbnRlbnQ6ZmxleC1lbmQ7LXdlYmtpdC1hbGlnbi1jb250ZW50OmZsZXgtZW5kO2FsaWduLWNvbnRlbnQ6ZmxleC1lbmR9Oy0tbGF5b3V0LWNlbnRlci1hbGlnbmVkOnstbXMtZmxleC1saW5lLXBhY2s6Y2VudGVyOy1tcy1hbGlnbi1jb250ZW50OmNlbnRlcjstd2Via2l0LWFsaWduLWNvbnRlbnQ6Y2VudGVyO2FsaWduLWNvbnRlbnQ6Y2VudGVyfTstLWxheW91dC1iZXR3ZWVuLWFsaWduZWQ6ey1tcy1mbGV4LWxpbmUtcGFjazpqdXN0aWZ5Oy1tcy1hbGlnbi1jb250ZW50OnNwYWNlLWJldHdlZW47LXdlYmtpdC1hbGlnbi1jb250ZW50OnNwYWNlLWJldHdlZW47YWxpZ24tY29udGVudDpzcGFjZS1iZXR3ZWVufTstLWxheW91dC1hcm91bmQtYWxpZ25lZDp7LW1zLWZsZXgtbGluZS1wYWNrOmRpc3RyaWJ1dGU7LW1zLWFsaWduLWNvbnRlbnQ6c3BhY2UtYXJvdW5kOy13ZWJraXQtYWxpZ24tY29udGVudDpzcGFjZS1hcm91bmQ7YWxpZ24tY29udGVudDpzcGFjZS1hcm91bmR9Oy0tbGF5b3V0LWJsb2NrOntkaXNwbGF5OmJsb2NrfTstLWxheW91dC1pbnZpc2libGU6e3Zpc2liaWxpdHk6aGlkZGVuIWltcG9ydGFudH07LS1sYXlvdXQtcmVsYXRpdmU6e3Bvc2l0aW9uOnJlbGF0aXZlfTstLWxheW91dC1maXQ6e3Bvc2l0aW9uOmFic29sdXRlO3RvcDowO3JpZ2h0OjA7Ym90dG9tOjA7bGVmdDowfTstLWxheW91dC1zY3JvbGw6ey13ZWJraXQtb3ZlcmZsb3ctc2Nyb2xsaW5nOnRvdWNoO292ZXJmbG93OmF1dG99Oy0tbGF5b3V0LWZ1bGxibGVlZDp7bWFyZ2luOjA7aGVpZ2h0OjEwMHZofTstLWxheW91dC1maXhlZC10b3A6e3Bvc2l0aW9uOmZpeGVkO3RvcDowO2xlZnQ6MDtyaWdodDowfTstLWxheW91dC1maXhlZC1yaWdodDp7cG9zaXRpb246Zml4ZWQ7dG9wOjA7cmlnaHQ6MDtib3R0b206MH07LS1sYXlvdXQtZml4ZWQtYm90dG9tOntwb3NpdGlvbjpmaXhlZDtyaWdodDowO2JvdHRvbTowO2xlZnQ6MH07LS1sYXlvdXQtZml4ZWQtbGVmdDp7cG9zaXRpb246Zml4ZWQ7dG9wOjA7Ym90dG9tOjA7bGVmdDowfTt9PC9zdHlsZT4gPC9jdXN0b20tc3R5bGU+XCIpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9pcm9uLWZsZXgtbGF5b3V0L2lyb24tZmxleC1sYXlvdXQuaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCJsaWIvbWl4aW5zL2VsZW1lbnQtbWl4aW4uaHRtbFwiPlxuPHNjcmlwdD5cbihmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8qKlxuICAgKiBCYXNlIGNsYXNzIHRoYXQgcHJvdmlkZXMgdGhlIGNvcmUgQVBJIGZvciBQb2x5bWVyJ3MgbWV0YS1wcm9ncmFtbWluZ1xuICAgKiBmZWF0dXJlcyBpbmNsdWRpbmcgdGVtcGxhdGUgc3RhbXBpbmcsIGRhdGEtYmluZGluZywgYXR0cmlidXRlIGRlc2VyaWFsaXphdGlvbixcbiAgICogYW5kIHByb3BlcnR5IGNoYW5nZSBvYnNlcnZhdGlvbi5cbiAgICpcbiAgICogQGN1c3RvbUVsZW1lbnRcbiAgICogQHBvbHltZXJcbiAgICogQG1lbWJlcm9mIFBvbHltZXJcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBpbXBsZW1lbnRzIHtQb2x5bWVyX0VsZW1lbnRNaXhpbn1cbiAgICogQGV4dGVuZHMgSFRNTEVsZW1lbnRcbiAgICogQGFwcGxpZXNNaXhpbiBQb2x5bWVyLkVsZW1lbnRNaXhpblxuICAgKiBAc3VtbWFyeSBDdXN0b20gZWxlbWVudCBiYXNlIGNsYXNzIHRoYXQgcHJvdmlkZXMgdGhlIGNvcmUgQVBJIGZvciBQb2x5bWVyJ3NcbiAgICogICBrZXkgbWV0YS1wcm9ncmFtbWluZyBmZWF0dXJlcyBpbmNsdWRpbmcgdGVtcGxhdGUgc3RhbXBpbmcsIGRhdGEtYmluZGluZyxcbiAgICogICBhdHRyaWJ1dGUgZGVzZXJpYWxpemF0aW9uLCBhbmQgcHJvcGVydHkgY2hhbmdlIG9ic2VydmF0aW9uXG4gICAqL1xuICBjb25zdCBFbGVtZW50ID0gUG9seW1lci5FbGVtZW50TWl4aW4oSFRNTEVsZW1lbnQpO1xuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBpbXBsZW1lbnRzIHtQb2x5bWVyX0VsZW1lbnRNaXhpbn1cbiAgICogQGV4dGVuZHMge0hUTUxFbGVtZW50fVxuICAgKi9cbiAgUG9seW1lci5FbGVtZW50ID0gRWxlbWVudDtcbn0pKCk7XG48L3NjcmlwdD5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL3BvbHltZXIvcG9seW1lci1lbGVtZW50Lmh0bWwiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiYm9vdC5odG1sXCI+XG5cbjxzY3JpcHQ+XG5cbiAgKGZ1bmN0aW9uKCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGxldCBDU1NfVVJMX1JYID0gLyh1cmxcXCgpKFteKV0qKShcXCkpL2c7XG4gICAgbGV0IEFCU19VUkwgPSAvKF5cXC8pfCheIyl8KF5bXFx3LVxcZF0qOikvO1xuICAgIGxldCB3b3JraW5nVVJMO1xuICAgIGxldCByZXNvbHZlRG9jO1xuICAgIC8qKlxuICAgICAqIFJlc29sdmVzIHRoZSBnaXZlbiBVUkwgYWdhaW5zdCB0aGUgcHJvdmlkZWQgYGJhc2VVcmknLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIFBvbHltZXIuUmVzb2x2ZVVybFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgSW5wdXQgVVJMIHRvIHJlc29sdmVcbiAgICAgKiBAcGFyYW0gez9zdHJpbmc9fSBiYXNlVVJJIEJhc2UgVVJJIHRvIHJlc29sdmUgdGhlIFVSTCBhZ2FpbnN0XG4gICAgICogQHJldHVybiB7c3RyaW5nfSByZXNvbHZlZCBVUkxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXNvbHZlVXJsKHVybCwgYmFzZVVSSSkge1xuICAgICAgaWYgKHVybCAmJiBBQlNfVVJMLnRlc3QodXJsKSkge1xuICAgICAgICByZXR1cm4gdXJsO1xuICAgICAgfVxuICAgICAgLy8gTGF6eSBmZWF0dXJlIGRldGVjdGlvbi5cbiAgICAgIGlmICh3b3JraW5nVVJMID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgd29ya2luZ1VSTCA9IGZhbHNlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHUgPSBuZXcgVVJMKCdiJywgJ2h0dHA6Ly9hJyk7XG4gICAgICAgICAgdS5wYXRobmFtZSA9ICdjJTIwZCc7XG4gICAgICAgICAgd29ya2luZ1VSTCA9ICh1LmhyZWYgPT09ICdodHRwOi8vYS9jJTIwZCcpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgLy8gc2lsZW50bHkgZmFpbFxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWJhc2VVUkkpIHtcbiAgICAgICAgYmFzZVVSSSA9IGRvY3VtZW50LmJhc2VVUkkgfHwgd2luZG93LmxvY2F0aW9uLmhyZWY7XG4gICAgICB9XG4gICAgICBpZiAod29ya2luZ1VSTCkge1xuICAgICAgICByZXR1cm4gKG5ldyBVUkwodXJsLCBiYXNlVVJJKSkuaHJlZjtcbiAgICAgIH1cbiAgICAgIC8vIEZhbGxiYWNrIHRvIGNyZWF0aW5nIGFuIGFuY2hvciBpbnRvIGEgZGlzY29ubmVjdGVkIGRvY3VtZW50LlxuICAgICAgaWYgKCFyZXNvbHZlRG9jKSB7XG4gICAgICAgIHJlc29sdmVEb2MgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoJ3RlbXAnKTtcbiAgICAgICAgcmVzb2x2ZURvYy5iYXNlID0gcmVzb2x2ZURvYy5jcmVhdGVFbGVtZW50KCdiYXNlJyk7XG4gICAgICAgIHJlc29sdmVEb2MuaGVhZC5hcHBlbmRDaGlsZChyZXNvbHZlRG9jLmJhc2UpO1xuICAgICAgICByZXNvbHZlRG9jLmFuY2hvciA9IHJlc29sdmVEb2MuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgICAgICByZXNvbHZlRG9jLmJvZHkuYXBwZW5kQ2hpbGQocmVzb2x2ZURvYy5hbmNob3IpO1xuICAgICAgfVxuICAgICAgcmVzb2x2ZURvYy5iYXNlLmhyZWYgPSBiYXNlVVJJO1xuICAgICAgcmVzb2x2ZURvYy5hbmNob3IuaHJlZiA9IHVybDtcbiAgICAgIHJldHVybiByZXNvbHZlRG9jLmFuY2hvci5ocmVmIHx8IHVybDtcblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlc29sdmVzIGFueSByZWxhdGl2ZSBVUkwncyBpbiB0aGUgZ2l2ZW4gQ1NTIHRleHQgYWdhaW5zdCB0aGUgcHJvdmlkZWRcbiAgICAgKiBgb3duZXJEb2N1bWVudGAncyBgYmFzZVVSSWAuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgUG9seW1lci5SZXNvbHZlVXJsXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNzc1RleHQgQ1NTIHRleHQgdG8gcHJvY2Vzc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlVVJJIEJhc2UgVVJJIHRvIHJlc29sdmUgdGhlIFVSTCBhZ2FpbnN0XG4gICAgICogQHJldHVybiB7c3RyaW5nfSBQcm9jZXNzZWQgQ1NTIHRleHQgd2l0aCByZXNvbHZlZCBVUkwnc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlc29sdmVDc3MoY3NzVGV4dCwgYmFzZVVSSSkge1xuICAgICAgcmV0dXJuIGNzc1RleHQucmVwbGFjZShDU1NfVVJMX1JYLCBmdW5jdGlvbihtLCBwcmUsIHVybCwgcG9zdCkge1xuICAgICAgICByZXR1cm4gcHJlICsgJ1xcJycgK1xuICAgICAgICAgIHJlc29sdmVVcmwodXJsLnJlcGxhY2UoL1tcIiddL2csICcnKSwgYmFzZVVSSSkgK1xuICAgICAgICAgICdcXCcnICsgcG9zdDtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBwYXRoIGZyb20gYSBnaXZlbiBgdXJsYC4gVGhlIHBhdGggaW5jbHVkZXMgdGhlIHRyYWlsaW5nXG4gICAgICogYC9gIGZyb20gdGhlIHVybC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBQb2x5bWVyLlJlc29sdmVVcmxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsIElucHV0IFVSTCB0byB0cmFuc2Zvcm1cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IHJlc29sdmVkIHBhdGhcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYXRoRnJvbVVybCh1cmwpIHtcbiAgICAgIHJldHVybiB1cmwuc3Vic3RyaW5nKDAsIHVybC5sYXN0SW5kZXhPZignLycpICsgMSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTW9kdWxlIHdpdGggdXRpbGl0aWVzIGZvciByZXNvbHZpbmcgcmVsYXRpdmUgVVJMJ3MuXG4gICAgICpcbiAgICAgKiBAbmFtZXNwYWNlXG4gICAgICogQG1lbWJlcm9mIFBvbHltZXJcbiAgICAgKiBAc3VtbWFyeSBNb2R1bGUgd2l0aCB1dGlsaXRpZXMgZm9yIHJlc29sdmluZyByZWxhdGl2ZSBVUkwncy5cbiAgICAgKi9cbiAgICBQb2x5bWVyLlJlc29sdmVVcmwgPSB7XG4gICAgICByZXNvbHZlQ3NzOiByZXNvbHZlQ3NzLFxuICAgICAgcmVzb2x2ZVVybDogcmVzb2x2ZVVybCxcbiAgICAgIHBhdGhGcm9tVXJsOiBwYXRoRnJvbVVybFxuICAgIH07XG5cbiAgfSkoKTtcblxuPC9zY3JpcHQ+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL3BvbHltZXIvbGliL3V0aWxzL3Jlc29sdmUtdXJsLmh0bWwiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiYm9vdC5odG1sXCI+XG5cbjxzY3JpcHQ+XG4oZnVuY3Rpb24oKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8qKiBAdHlwZWRlZiB7e3J1bjogZnVuY3Rpb24oZnVuY3Rpb24oKSwgbnVtYmVyPSk6bnVtYmVyLCBjYW5jZWw6IGZ1bmN0aW9uKG51bWJlcil9fSAqL1xuICBsZXQgQXN5bmNJbnRlcmZhY2U7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblxuICAvLyBNaWNyb3Rhc2sgaW1wbGVtZW50ZWQgdXNpbmcgTXV0YXRpb24gT2JzZXJ2ZXJcbiAgbGV0IG1pY3JvdGFza0N1cnJIYW5kbGUgPSAwO1xuICBsZXQgbWljcm90YXNrTGFzdEhhbmRsZSA9IDA7XG4gIGxldCBtaWNyb3Rhc2tDYWxsYmFja3MgPSBbXTtcbiAgbGV0IG1pY3JvdGFza05vZGVDb250ZW50ID0gMDtcbiAgbGV0IG1pY3JvdGFza05vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyk7XG4gIG5ldyB3aW5kb3cuTXV0YXRpb25PYnNlcnZlcihtaWNyb3Rhc2tGbHVzaCkub2JzZXJ2ZShtaWNyb3Rhc2tOb2RlLCB7Y2hhcmFjdGVyRGF0YTogdHJ1ZX0pO1xuXG4gIGZ1bmN0aW9uIG1pY3JvdGFza0ZsdXNoKCkge1xuICAgIGNvbnN0IGxlbiA9IG1pY3JvdGFza0NhbGxiYWNrcy5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgbGV0IGNiID0gbWljcm90YXNrQ2FsbGJhY2tzW2ldO1xuICAgICAgaWYgKGNiKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY2IoKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4geyB0aHJvdyBlIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIG1pY3JvdGFza0NhbGxiYWNrcy5zcGxpY2UoMCwgbGVuKTtcbiAgICBtaWNyb3Rhc2tMYXN0SGFuZGxlICs9IGxlbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBNb2R1bGUgdGhhdCBwcm92aWRlcyBhIG51bWJlciBvZiBzdHJhdGVnaWVzIGZvciBlbnF1ZXVpbmcgYXN5bmNocm9ub3VzXG4gICAqIHRhc2tzLiAgRWFjaCBzdWItbW9kdWxlIHByb3ZpZGVzIGEgc3RhbmRhcmQgYHJ1bihmbilgIGludGVyZmFjZSB0aGF0IHJldHVybnMgYVxuICAgKiBoYW5kbGUsIGFuZCBhIGBjYW5jZWwoaGFuZGxlKWAgaW50ZXJmYWNlIGZvciBjYW5jZWxpbmcgYXN5bmMgdGFza3MgYmVmb3JlXG4gICAqIHRoZXkgcnVuLlxuICAgKlxuICAgKiBAbmFtZXNwYWNlXG4gICAqIEBtZW1iZXJvZiBQb2x5bWVyXG4gICAqIEBzdW1tYXJ5IE1vZHVsZSB0aGF0IHByb3ZpZGVzIGEgbnVtYmVyIG9mIHN0cmF0ZWdpZXMgZm9yIGVucXVldWluZyBhc3luY2hyb25vdXNcbiAgICogdGFza3MuXG4gICAqL1xuICBQb2x5bWVyLkFzeW5jID0ge1xuXG4gICAgLyoqXG4gICAgICogQXN5bmMgaW50ZXJmYWNlIHdyYXBwZXIgYXJvdW5kIGBzZXRUaW1lb3V0YC5cbiAgICAgKlxuICAgICAqIEBuYW1lc3BhY2VcbiAgICAgKiBAbWVtYmVyb2YgUG9seW1lci5Bc3luY1xuICAgICAqIEBzdW1tYXJ5IEFzeW5jIGludGVyZmFjZSB3cmFwcGVyIGFyb3VuZCBgc2V0VGltZW91dGAuXG4gICAgICovXG4gICAgdGltZU91dDoge1xuICAgICAgLyoqXG4gICAgICAgKiBSZXR1cm5zIGEgc3ViLW1vZHVsZSB3aXRoIHRoZSBhc3luYyBpbnRlcmZhY2UgcHJvdmlkaW5nIHRoZSBwcm92aWRlZFxuICAgICAgICogZGVsYXkuXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlcm9mIFBvbHltZXIuQXN5bmMudGltZU91dFxuICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGRlbGF5IFRpbWUgdG8gd2FpdCBiZWZvcmUgY2FsbGluZyBjYWxsYmFja3MgaW4gbXNcbiAgICAgICAqIEByZXR1cm4ge0FzeW5jSW50ZXJmYWNlfSBBbiBhc3luYyB0aW1lb3V0IGludGVyZmFjZVxuICAgICAgICovXG4gICAgICBhZnRlcihkZWxheSkge1xuICAgICAgICByZXR1cm4gIHtcbiAgICAgICAgICBydW4oZm4pIHsgcmV0dXJuIHNldFRpbWVvdXQoZm4sIGRlbGF5KSB9LFxuICAgICAgICAgIGNhbmNlbDogd2luZG93LmNsZWFyVGltZW91dC5iaW5kKHdpbmRvdylcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8qKlxuICAgICAgICogRW5xdWV1ZXMgYSBmdW5jdGlvbiBjYWxsZWQgaW4gdGhlIG5leHQgdGFzay5cbiAgICAgICAqXG4gICAgICAgKiBAbWVtYmVyb2YgUG9seW1lci5Bc3luYy50aW1lT3V0XG4gICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBDYWxsYmFjayB0byBydW5cbiAgICAgICAqIEByZXR1cm4ge251bWJlcn0gSGFuZGxlIHVzZWQgZm9yIGNhbmNlbGluZyB0YXNrXG4gICAgICAgKi9cbiAgICAgIHJ1bjogd2luZG93LnNldFRpbWVvdXQuYmluZCh3aW5kb3cpLFxuICAgICAgLyoqXG4gICAgICAgKiBDYW5jZWxzIGEgcHJldmlvdXNseSBlbnF1ZXVlZCBgdGltZU91dGAgY2FsbGJhY2suXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlcm9mIFBvbHltZXIuQXN5bmMudGltZU91dFxuICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGhhbmRsZSBIYW5kbGUgcmV0dXJuZWQgZnJvbSBgcnVuYCBvZiBjYWxsYmFjayB0byBjYW5jZWxcbiAgICAgICAqL1xuICAgICAgY2FuY2VsOiB3aW5kb3cuY2xlYXJUaW1lb3V0LmJpbmQod2luZG93KVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBc3luYyBpbnRlcmZhY2Ugd3JhcHBlciBhcm91bmQgYHJlcXVlc3RBbmltYXRpb25GcmFtZWAuXG4gICAgICpcbiAgICAgKiBAbmFtZXNwYWNlXG4gICAgICogQG1lbWJlcm9mIFBvbHltZXIuQXN5bmNcbiAgICAgKiBAc3VtbWFyeSBBc3luYyBpbnRlcmZhY2Ugd3JhcHBlciBhcm91bmQgYHJlcXVlc3RBbmltYXRpb25GcmFtZWAuXG4gICAgICovXG4gICAgYW5pbWF0aW9uRnJhbWU6IHtcbiAgICAgIC8qKlxuICAgICAgICogRW5xdWV1ZXMgYSBmdW5jdGlvbiBjYWxsZWQgYXQgYHJlcXVlc3RBbmltYXRpb25GcmFtZWAgdGltaW5nLlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJvZiBQb2x5bWVyLkFzeW5jLmFuaW1hdGlvbkZyYW1lXG4gICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBDYWxsYmFjayB0byBydW5cbiAgICAgICAqIEByZXR1cm4ge251bWJlcn0gSGFuZGxlIHVzZWQgZm9yIGNhbmNlbGluZyB0YXNrXG4gICAgICAgKi9cbiAgICAgIHJ1bjogd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZS5iaW5kKHdpbmRvdyksXG4gICAgICAvKipcbiAgICAgICAqIENhbmNlbHMgYSBwcmV2aW91c2x5IGVucXVldWVkIGBhbmltYXRpb25GcmFtZWAgY2FsbGJhY2suXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlcm9mIFBvbHltZXIuQXN5bmMudGltZU91dFxuICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGhhbmRsZSBIYW5kbGUgcmV0dXJuZWQgZnJvbSBgcnVuYCBvZiBjYWxsYmFjayB0byBjYW5jZWxcbiAgICAgICAqL1xuICAgICAgY2FuY2VsOiB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUuYmluZCh3aW5kb3cpXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFzeW5jIGludGVyZmFjZSB3cmFwcGVyIGFyb3VuZCBgcmVxdWVzdElkbGVDYWxsYmFja2AuICBGYWxscyBiYWNrIHRvXG4gICAgICogYHNldFRpbWVvdXRgIG9uIGJyb3dzZXJzIHRoYXQgZG8gbm90IHN1cHBvcnQgYHJlcXVlc3RJZGxlQ2FsbGJhY2tgLlxuICAgICAqXG4gICAgICogQG5hbWVzcGFjZVxuICAgICAqIEBtZW1iZXJvZiBQb2x5bWVyLkFzeW5jXG4gICAgICogQHN1bW1hcnkgQXN5bmMgaW50ZXJmYWNlIHdyYXBwZXIgYXJvdW5kIGByZXF1ZXN0SWRsZUNhbGxiYWNrYC5cbiAgICAgKi9cbiAgICBpZGxlUGVyaW9kOiB7XG4gICAgICAvKipcbiAgICAgICAqIEVucXVldWVzIGEgZnVuY3Rpb24gY2FsbGVkIGF0IGByZXF1ZXN0SWRsZUNhbGxiYWNrYCB0aW1pbmcuXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlcm9mIFBvbHltZXIuQXN5bmMuaWRsZVBlcmlvZFxuICAgICAgICogQHBhcmFtIHtmdW5jdGlvbihJZGxlRGVhZGxpbmUpfSBmbiBDYWxsYmFjayB0byBydW5cbiAgICAgICAqIEByZXR1cm4ge251bWJlcn0gSGFuZGxlIHVzZWQgZm9yIGNhbmNlbGluZyB0YXNrXG4gICAgICAgKi9cbiAgICAgIHJ1bihmbikge1xuICAgICAgICByZXR1cm4gd2luZG93LnJlcXVlc3RJZGxlQ2FsbGJhY2sgP1xuICAgICAgICAgIHdpbmRvdy5yZXF1ZXN0SWRsZUNhbGxiYWNrKGZuKSA6XG4gICAgICAgICAgd2luZG93LnNldFRpbWVvdXQoZm4sIDE2KTtcbiAgICAgIH0sXG4gICAgICAvKipcbiAgICAgICAqIENhbmNlbHMgYSBwcmV2aW91c2x5IGVucXVldWVkIGBpZGxlUGVyaW9kYCBjYWxsYmFjay5cbiAgICAgICAqXG4gICAgICAgKiBAbWVtYmVyb2YgUG9seW1lci5Bc3luYy5pZGxlUGVyaW9kXG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0gaGFuZGxlIEhhbmRsZSByZXR1cm5lZCBmcm9tIGBydW5gIG9mIGNhbGxiYWNrIHRvIGNhbmNlbFxuICAgICAgICovXG4gICAgICBjYW5jZWwoaGFuZGxlKSB7XG4gICAgICAgIHdpbmRvdy5jYW5jZWxJZGxlQ2FsbGJhY2sgP1xuICAgICAgICAgIHdpbmRvdy5jYW5jZWxJZGxlQ2FsbGJhY2soaGFuZGxlKSA6XG4gICAgICAgICAgd2luZG93LmNsZWFyVGltZW91dChoYW5kbGUpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBc3luYyBpbnRlcmZhY2UgZm9yIGVucXVldWVpbmcgY2FsbGJhY2tzIHRoYXQgcnVuIGF0IG1pY3JvdGFzayB0aW1pbmcuXG4gICAgICpcbiAgICAgKiBOb3RlIHRoYXQgbWljcm90YXNrIHRpbWluZyBpcyBhY2hpZXZlZCB2aWEgYSBzaW5nbGUgYE11dGF0aW9uT2JzZXJ2ZXJgLFxuICAgICAqIGFuZCB0aHVzIGNhbGxiYWNrcyBlbnF1ZXVlZCB3aXRoIHRoaXMgQVBJIHdpbGwgYWxsIHJ1biBpbiBhIHNpbmdsZVxuICAgICAqIGJhdGNoLCBhbmQgbm90IGludGVybGVhdmVkIHdpdGggb3RoZXIgbWljcm90YXNrcyBzdWNoIGFzIHByb21pc2VzLlxuICAgICAqIFByb21pc2VzIGFyZSBhdm9pZGVkIGFzIGFuIGltcGxlbWVudGF0aW9uIGNob2ljZSBmb3IgdGhlIHRpbWUgYmVpbmdcbiAgICAgKiBkdWUgdG8gU2FmYXJpIGJ1Z3MgdGhhdCBjYXVzZSBQcm9taXNlcyB0byBsYWNrIG1pY3JvdGFzayBndWFyYW50ZWVzLlxuICAgICAqXG4gICAgICogQG5hbWVzcGFjZVxuICAgICAqIEBtZW1iZXJvZiBQb2x5bWVyLkFzeW5jXG4gICAgICogQHN1bW1hcnkgQXN5bmMgaW50ZXJmYWNlIGZvciBlbnF1ZXVlaW5nIGNhbGxiYWNrcyB0aGF0IHJ1biBhdCBtaWNyb3Rhc2tcbiAgICAgKiAgIHRpbWluZy5cbiAgICAgKi9cbiAgICBtaWNyb1Rhc2s6IHtcblxuICAgICAgLyoqXG4gICAgICAgKiBFbnF1ZXVlcyBhIGZ1bmN0aW9uIGNhbGxlZCBhdCBtaWNyb3Rhc2sgdGltaW5nLlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJvZiBQb2x5bWVyLkFzeW5jLm1pY3JvVGFza1xuICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgdG8gcnVuXG4gICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IEhhbmRsZSB1c2VkIGZvciBjYW5jZWxpbmcgdGFza1xuICAgICAgICovXG4gICAgICBydW4oY2FsbGJhY2spIHtcbiAgICAgICAgbWljcm90YXNrTm9kZS50ZXh0Q29udGVudCA9IG1pY3JvdGFza05vZGVDb250ZW50Kys7XG4gICAgICAgIG1pY3JvdGFza0NhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgcmV0dXJuIG1pY3JvdGFza0N1cnJIYW5kbGUrKztcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogQ2FuY2VscyBhIHByZXZpb3VzbHkgZW5xdWV1ZWQgYG1pY3JvVGFza2AgY2FsbGJhY2suXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlcm9mIFBvbHltZXIuQXN5bmMubWljcm9UYXNrXG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0gaGFuZGxlIEhhbmRsZSByZXR1cm5lZCBmcm9tIGBydW5gIG9mIGNhbGxiYWNrIHRvIGNhbmNlbFxuICAgICAgICovXG4gICAgICBjYW5jZWwoaGFuZGxlKSB7XG4gICAgICAgIGNvbnN0IGlkeCA9IGhhbmRsZSAtIG1pY3JvdGFza0xhc3RIYW5kbGU7XG4gICAgICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgICAgIGlmICghbWljcm90YXNrQ2FsbGJhY2tzW2lkeF0pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBhc3luYyBoYW5kbGU6ICcgKyBoYW5kbGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtaWNyb3Rhc2tDYWxsYmFja3NbaWR4XSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgIH1cbiAgfTtcblxufSkoKTtcbjwvc2NyaXB0PlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi91dGlscy9hc3luYy5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuXG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vdXRpbHMvbWl4aW4uaHRtbFwiPlxuXG48c2NyaXB0PlxuKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLy8gQ29tbW9uIGltcGxlbWVudGF0aW9uIGZvciBtaXhpbiAmIGJlaGF2aW9yXG4gIGZ1bmN0aW9uIG11dGFibGVQcm9wZXJ0eUNoYW5nZShpbnN0LCBwcm9wZXJ0eSwgdmFsdWUsIG9sZCwgbXV0YWJsZURhdGEpIHtcbiAgICBsZXQgaXNPYmplY3Q7XG4gICAgaWYgKG11dGFibGVEYXRhKSB7XG4gICAgICBpc09iamVjdCA9ICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsKTtcbiAgICAgIC8vIFB1bGwgYG9sZGAgZm9yIE9iamVjdHMgZnJvbSB0ZW1wIGNhY2hlLCBidXQgdHJlYXQgYG51bGxgIGFzIGEgcHJpbWl0aXZlXG4gICAgICBpZiAoaXNPYmplY3QpIHtcbiAgICAgICAgb2xkID0gaW5zdC5fX2RhdGFUZW1wW3Byb3BlcnR5XTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gU3RyaWN0IGVxdWFsaXR5IGNoZWNrLCBidXQgcmV0dXJuIGZhbHNlIGZvciBOYU49PT1OYU5cbiAgICBsZXQgc2hvdWxkQ2hhbmdlID0gKG9sZCAhPT0gdmFsdWUgJiYgKG9sZCA9PT0gb2xkIHx8IHZhbHVlID09PSB2YWx1ZSkpO1xuICAgIC8vIE9iamVjdHMgYXJlIHN0b3JlZCBpbiB0ZW1wb3JhcnkgY2FjaGUgKGNsZWFyZWQgYXQgZW5kIG9mXG4gICAgLy8gdHVybiksIHdoaWNoIGlzIHVzZWQgZm9yIGRpcnR5LWNoZWNraW5nXG4gICAgaWYgKGlzT2JqZWN0ICYmIHNob3VsZENoYW5nZSkge1xuICAgICAgaW5zdC5fX2RhdGFUZW1wW3Byb3BlcnR5XSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gc2hvdWxkQ2hhbmdlO1xuICB9XG5cbiAgLyoqXG4gICAqIEVsZW1lbnQgY2xhc3MgbWl4aW4gdG8gc2tpcCBzdHJpY3QgZGlydHktY2hlY2tpbmcgZm9yIG9iamVjdHMgYW5kIGFycmF5c1xuICAgKiAoYWx3YXlzIGNvbnNpZGVyIHRoZW0gdG8gYmUgXCJkaXJ0eVwiKSwgZm9yIHVzZSBvbiBlbGVtZW50cyB1dGlsaXppbmdcbiAgICogYFBvbHltZXIuUHJvcGVydHlFZmZlY3RzYFxuICAgKlxuICAgKiBCeSBkZWZhdWx0LCBgUG9seW1lci5Qcm9wZXJ0eUVmZmVjdHNgIHBlcmZvcm1zIHN0cmljdCBkaXJ0eSBjaGVja2luZyBvblxuICAgKiBvYmplY3RzLCB3aGljaCBtZWFucyB0aGF0IGFueSBkZWVwIG1vZGlmaWNhdGlvbnMgdG8gYW4gb2JqZWN0IG9yIGFycmF5IHdpbGxcbiAgICogbm90IGJlIHByb3BhZ2F0ZWQgdW5sZXNzIFwiaW1tdXRhYmxlXCIgZGF0YSBwYXR0ZXJucyBhcmUgdXNlZCAoaS5lLiBhbGwgb2JqZWN0XG4gICAqIHJlZmVyZW5jZXMgZnJvbSB0aGUgcm9vdCB0byB0aGUgbXV0YXRpb24gd2VyZSBjaGFuZ2VkKS5cbiAgICpcbiAgICogUG9seW1lciBhbHNvIHByb3ZpZGVzIGEgcHJvcHJpZXRhcnkgZGF0YSBtdXRhdGlvbiBhbmQgcGF0aCBub3RpZmljYXRpb24gQVBJXG4gICAqIChlLmcuIGBub3RpZnlQYXRoYCwgYHNldGAsIGFuZCBhcnJheSBtdXRhdGlvbiBBUEkncykgdGhhdCBhbGxvdyBlZmZpY2llbnRcbiAgICogbXV0YXRpb24gYW5kIG5vdGlmaWNhdGlvbiBvZiBkZWVwIGNoYW5nZXMgaW4gYW4gb2JqZWN0IGdyYXBoIHRvIGFsbCBlbGVtZW50c1xuICAgKiBib3VuZCB0byB0aGUgc2FtZSBvYmplY3QgZ3JhcGguXG4gICAqXG4gICAqIEluIGNhc2VzIHdoZXJlIG5laXRoZXIgaW1tdXRhYmxlIHBhdHRlcm5zIG5vciB0aGUgZGF0YSBtdXRhdGlvbiBBUEkgY2FuIGJlXG4gICAqIHVzZWQsIGFwcGx5aW5nIHRoaXMgbWl4aW4gd2lsbCBjYXVzZSBQb2x5bWVyIHRvIHNraXAgZGlydHkgY2hlY2tpbmcgZm9yXG4gICAqIG9iamVjdHMgYW5kIGFycmF5cyAoYWx3YXlzIGNvbnNpZGVyIHRoZW0gdG8gYmUgXCJkaXJ0eVwiKS4gIFRoaXMgYWxsb3dzIGFcbiAgICogdXNlciB0byBtYWtlIGEgZGVlcCBtb2RpZmljYXRpb24gdG8gYSBib3VuZCBvYmplY3QgZ3JhcGgsIGFuZCB0aGVuIGVpdGhlclxuICAgKiBzaW1wbHkgcmUtc2V0IHRoZSBvYmplY3QgKGUuZy4gYHRoaXMuaXRlbXMgPSB0aGlzLml0ZW1zYCkgb3IgY2FsbCBgbm90aWZ5UGF0aGBcbiAgICogKGUuZy4gYHRoaXMubm90aWZ5UGF0aCgnaXRlbXMnKWApIHRvIHVwZGF0ZSB0aGUgdHJlZS4gIE5vdGUgdGhhdCBhbGxcbiAgICogZWxlbWVudHMgdGhhdCB3aXNoIHRvIGJlIHVwZGF0ZWQgYmFzZWQgb24gZGVlcCBtdXRhdGlvbnMgbXVzdCBhcHBseSB0aGlzXG4gICAqIG1peGluIG9yIG90aGVyd2lzZSBza2lwIHN0cmljdCBkaXJ0eSBjaGVja2luZyBmb3Igb2JqZWN0cy9hcnJheXMuXG4gICAqXG4gICAqIEluIG9yZGVyIHRvIG1ha2UgdGhlIGRpcnR5IGNoZWNrIHN0cmF0ZWd5IGNvbmZpZ3VyYWJsZSwgc2VlXG4gICAqIGBQb2x5bWVyLk9wdGlvbmFsTXV0YWJsZURhdGFgLlxuICAgKlxuICAgKiBOb3RlLCB0aGUgcGVyZm9ybWFuY2UgY2hhcmFjdGVyaXN0aWNzIG9mIHByb3BhZ2F0aW5nIGxhcmdlIG9iamVjdCBncmFwaHNcbiAgICogd2lsbCBiZSB3b3JzZSBhcyBvcHBvc2VkIHRvIHVzaW5nIHN0cmljdCBkaXJ0eSBjaGVja2luZyB3aXRoIGltbXV0YWJsZVxuICAgKiBwYXR0ZXJucyBvciBQb2x5bWVyJ3MgcGF0aCBub3RpZmljYXRpb24gQVBJLlxuICAgKlxuICAgKiBAbWl4aW5GdW5jdGlvblxuICAgKiBAcG9seW1lclxuICAgKiBAbWVtYmVyb2YgUG9seW1lclxuICAgKiBAc3VtbWFyeSBFbGVtZW50IGNsYXNzIG1peGluIHRvIHNraXAgc3RyaWN0IGRpcnR5LWNoZWNraW5nIGZvciBvYmplY3RzXG4gICAqICAgYW5kIGFycmF5c1xuICAgKi9cbiAgUG9seW1lci5NdXRhYmxlRGF0YSA9IFBvbHltZXIuZGVkdXBpbmdNaXhpbihzdXBlckNsYXNzID0+IHtcblxuICAgIC8qKlxuICAgICAqIEBwb2x5bWVyXG4gICAgICogQG1peGluQ2xhc3NcbiAgICAgKiBAaW1wbGVtZW50cyB7UG9seW1lcl9NdXRhYmxlRGF0YX1cbiAgICAgKi9cbiAgICBjbGFzcyBNdXRhYmxlRGF0YSBleHRlbmRzIHN1cGVyQ2xhc3Mge1xuICAgICAgLyoqXG4gICAgICAgKiBPdmVycmlkZXMgYFBvbHltZXIuUHJvcGVydHlFZmZlY3RzYCB0byBwcm92aWRlIG9wdGlvbiBmb3Igc2tpcHBpbmdcbiAgICAgICAqIHN0cmljdCBlcXVhbGl0eSBjaGVja2luZyBmb3IgT2JqZWN0cyBhbmQgQXJyYXlzLlxuICAgICAgICpcbiAgICAgICAqIFRoaXMgbWV0aG9kIHB1bGxzIHRoZSB2YWx1ZSB0byBkaXJ0eSBjaGVjayBhZ2FpbnN0IGZyb20gdGhlIGBfX2RhdGFUZW1wYFxuICAgICAgICogY2FjaGUgKHJhdGhlciB0aGFuIHRoZSBub3JtYWwgYF9fZGF0YWAgY2FjaGUpIGZvciBPYmplY3RzLiAgU2luY2UgdGhlIHRlbXBcbiAgICAgICAqIGNhY2hlIGlzIGNsZWFyZWQgYXQgdGhlIGVuZCBvZiBhIHR1cm4sIHRoaXMgaW1wbGVtZW50YXRpb24gYWxsb3dzXG4gICAgICAgKiBzaWRlLWVmZmVjdHMgb2YgZGVlcCBvYmplY3QgY2hhbmdlcyB0byBiZSBwcm9jZXNzZWQgYnkgcmUtc2V0dGluZyB0aGVcbiAgICAgICAqIHNhbWUgb2JqZWN0ICh1c2luZyB0aGUgdGVtcCBjYWNoZSBhcyBhbiBpbi10dXJuIGJhY2tzdG9wIHRvIHByZXZlbnRcbiAgICAgICAqIGN5Y2xlcyBkdWUgdG8gMi13YXkgbm90aWZpY2F0aW9uKS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgbmFtZVxuICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBOZXcgcHJvcGVydHkgdmFsdWVcbiAgICAgICAqIEBwYXJhbSB7Kn0gb2xkIFByZXZpb3VzIHByb3BlcnR5IHZhbHVlXG4gICAgICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBwcm9wZXJ0eSBzaG91bGQgYmUgY29uc2lkZXJlZCBhIGNoYW5nZVxuICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICovXG4gICAgICBfc2hvdWxkUHJvcGVydHlDaGFuZ2UocHJvcGVydHksIHZhbHVlLCBvbGQpIHtcbiAgICAgICAgcmV0dXJuIG11dGFibGVQcm9wZXJ0eUNoYW5nZSh0aGlzLCBwcm9wZXJ0eSwgdmFsdWUsIG9sZCwgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICB9XG4gICAgLyoqIEB0eXBlIHtib29sZWFufSAqL1xuICAgIE11dGFibGVEYXRhLnByb3RvdHlwZS5tdXRhYmxlRGF0YSA9IGZhbHNlO1xuXG4gICAgcmV0dXJuIE11dGFibGVEYXRhO1xuXG4gIH0pO1xuXG5cbiAgLyoqXG4gICAqIEVsZW1lbnQgY2xhc3MgbWl4aW4gdG8gYWRkIHRoZSBvcHRpb25hbCBhYmlsaXR5IHRvIHNraXAgc3RyaWN0XG4gICAqIGRpcnR5LWNoZWNraW5nIGZvciBvYmplY3RzIGFuZCBhcnJheXMgKGFsd2F5cyBjb25zaWRlciB0aGVtIHRvIGJlXG4gICAqIFwiZGlydHlcIikgYnkgc2V0dGluZyBhIGBtdXRhYmxlLWRhdGFgIGF0dHJpYnV0ZSBvbiBhbiBlbGVtZW50IGluc3RhbmNlLlxuICAgKlxuICAgKiBCeSBkZWZhdWx0LCBgUG9seW1lci5Qcm9wZXJ0eUVmZmVjdHNgIHBlcmZvcm1zIHN0cmljdCBkaXJ0eSBjaGVja2luZyBvblxuICAgKiBvYmplY3RzLCB3aGljaCBtZWFucyB0aGF0IGFueSBkZWVwIG1vZGlmaWNhdGlvbnMgdG8gYW4gb2JqZWN0IG9yIGFycmF5IHdpbGxcbiAgICogbm90IGJlIHByb3BhZ2F0ZWQgdW5sZXNzIFwiaW1tdXRhYmxlXCIgZGF0YSBwYXR0ZXJucyBhcmUgdXNlZCAoaS5lLiBhbGwgb2JqZWN0XG4gICAqIHJlZmVyZW5jZXMgZnJvbSB0aGUgcm9vdCB0byB0aGUgbXV0YXRpb24gd2VyZSBjaGFuZ2VkKS5cbiAgICpcbiAgICogUG9seW1lciBhbHNvIHByb3ZpZGVzIGEgcHJvcHJpZXRhcnkgZGF0YSBtdXRhdGlvbiBhbmQgcGF0aCBub3RpZmljYXRpb24gQVBJXG4gICAqIChlLmcuIGBub3RpZnlQYXRoYCwgYHNldGAsIGFuZCBhcnJheSBtdXRhdGlvbiBBUEkncykgdGhhdCBhbGxvdyBlZmZpY2llbnRcbiAgICogbXV0YXRpb24gYW5kIG5vdGlmaWNhdGlvbiBvZiBkZWVwIGNoYW5nZXMgaW4gYW4gb2JqZWN0IGdyYXBoIHRvIGFsbCBlbGVtZW50c1xuICAgKiBib3VuZCB0byB0aGUgc2FtZSBvYmplY3QgZ3JhcGguXG4gICAqXG4gICAqIEluIGNhc2VzIHdoZXJlIG5laXRoZXIgaW1tdXRhYmxlIHBhdHRlcm5zIG5vciB0aGUgZGF0YSBtdXRhdGlvbiBBUEkgY2FuIGJlXG4gICAqIHVzZWQsIGFwcGx5aW5nIHRoaXMgbWl4aW4gd2lsbCBhbGxvdyBQb2x5bWVyIHRvIHNraXAgZGlydHkgY2hlY2tpbmcgZm9yXG4gICAqIG9iamVjdHMgYW5kIGFycmF5cyAoYWx3YXlzIGNvbnNpZGVyIHRoZW0gdG8gYmUgXCJkaXJ0eVwiKS4gIFRoaXMgYWxsb3dzIGFcbiAgICogdXNlciB0byBtYWtlIGEgZGVlcCBtb2RpZmljYXRpb24gdG8gYSBib3VuZCBvYmplY3QgZ3JhcGgsIGFuZCB0aGVuIGVpdGhlclxuICAgKiBzaW1wbHkgcmUtc2V0IHRoZSBvYmplY3QgKGUuZy4gYHRoaXMuaXRlbXMgPSB0aGlzLml0ZW1zYCkgb3IgY2FsbCBgbm90aWZ5UGF0aGBcbiAgICogKGUuZy4gYHRoaXMubm90aWZ5UGF0aCgnaXRlbXMnKWApIHRvIHVwZGF0ZSB0aGUgdHJlZS4gIE5vdGUgdGhhdCBhbGxcbiAgICogZWxlbWVudHMgdGhhdCB3aXNoIHRvIGJlIHVwZGF0ZWQgYmFzZWQgb24gZGVlcCBtdXRhdGlvbnMgbXVzdCBhcHBseSB0aGlzXG4gICAqIG1peGluIG9yIG90aGVyd2lzZSBza2lwIHN0cmljdCBkaXJ0eSBjaGVja2luZyBmb3Igb2JqZWN0cy9hcnJheXMuXG4gICAqXG4gICAqIFdoaWxlIHRoaXMgbWl4aW4gYWRkcyB0aGUgYWJpbGl0eSB0byBmb3JnbyBPYmplY3QvQXJyYXkgZGlydHkgY2hlY2tpbmcsXG4gICAqIHRoZSBgbXV0YWJsZURhdGFgIGZsYWcgZGVmYXVsdHMgdG8gZmFsc2UgYW5kIG11c3QgYmUgc2V0IG9uIHRoZSBpbnN0YW5jZS5cbiAgICpcbiAgICogTm90ZSwgdGhlIHBlcmZvcm1hbmNlIGNoYXJhY3RlcmlzdGljcyBvZiBwcm9wYWdhdGluZyBsYXJnZSBvYmplY3QgZ3JhcGhzXG4gICAqIHdpbGwgYmUgd29yc2UgYnkgcmVseWluZyBvbiBgbXV0YWJsZURhdGE6IHRydWVgIGFzIG9wcG9zZWQgdG8gdXNpbmdcbiAgICogc3RyaWN0IGRpcnR5IGNoZWNraW5nIHdpdGggaW1tdXRhYmxlIHBhdHRlcm5zIG9yIFBvbHltZXIncyBwYXRoIG5vdGlmaWNhdGlvblxuICAgKiBBUEkuXG4gICAqXG4gICAqIEBtaXhpbkZ1bmN0aW9uXG4gICAqIEBwb2x5bWVyXG4gICAqIEBtZW1iZXJvZiBQb2x5bWVyXG4gICAqIEBzdW1tYXJ5IEVsZW1lbnQgY2xhc3MgbWl4aW4gdG8gb3B0aW9uYWxseSBza2lwIHN0cmljdCBkaXJ0eS1jaGVja2luZ1xuICAgKiAgIGZvciBvYmplY3RzIGFuZCBhcnJheXNcbiAgICovXG4gIFBvbHltZXIuT3B0aW9uYWxNdXRhYmxlRGF0YSA9IFBvbHltZXIuZGVkdXBpbmdNaXhpbihzdXBlckNsYXNzID0+IHtcblxuICAgIC8qKlxuICAgICAqIEBtaXhpbkNsYXNzXG4gICAgICogQHBvbHltZXJcbiAgICAgKiBAaW1wbGVtZW50cyB7UG9seW1lcl9PcHRpb25hbE11dGFibGVEYXRhfVxuICAgICAqL1xuICAgIGNsYXNzIE9wdGlvbmFsTXV0YWJsZURhdGEgZXh0ZW5kcyBzdXBlckNsYXNzIHtcblxuICAgICAgc3RhdGljIGdldCBwcm9wZXJ0aWVzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIEluc3RhbmNlLWxldmVsIGZsYWcgZm9yIGNvbmZpZ3VyaW5nIHRoZSBkaXJ0eS1jaGVja2luZyBzdHJhdGVneVxuICAgICAgICAgICAqIGZvciB0aGlzIGVsZW1lbnQuICBXaGVuIHRydWUsIE9iamVjdHMgYW5kIEFycmF5cyB3aWxsIHNraXAgZGlydHlcbiAgICAgICAgICAgKiBjaGVja2luZywgb3RoZXJ3aXNlIHN0cmljdCBlcXVhbGl0eSBjaGVja2luZyB3aWxsIGJlIHVzZWQuXG4gICAgICAgICAgICovXG4gICAgICAgICAgbXV0YWJsZURhdGE6IEJvb2xlYW5cbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBPdmVycmlkZXMgYFBvbHltZXIuUHJvcGVydHlFZmZlY3RzYCB0byBwcm92aWRlIG9wdGlvbiBmb3Igc2tpcHBpbmdcbiAgICAgICAqIHN0cmljdCBlcXVhbGl0eSBjaGVja2luZyBmb3IgT2JqZWN0cyBhbmQgQXJyYXlzLlxuICAgICAgICpcbiAgICAgICAqIFdoZW4gYHRoaXMubXV0YWJsZURhdGFgIGlzIHRydWUgb24gdGhpcyBpbnN0YW5jZSwgdGhpcyBtZXRob2RcbiAgICAgICAqIHB1bGxzIHRoZSB2YWx1ZSB0byBkaXJ0eSBjaGVjayBhZ2FpbnN0IGZyb20gdGhlIGBfX2RhdGFUZW1wYCBjYWNoZVxuICAgICAgICogKHJhdGhlciB0aGFuIHRoZSBub3JtYWwgYF9fZGF0YWAgY2FjaGUpIGZvciBPYmplY3RzLiAgU2luY2UgdGhlIHRlbXBcbiAgICAgICAqIGNhY2hlIGlzIGNsZWFyZWQgYXQgdGhlIGVuZCBvZiBhIHR1cm4sIHRoaXMgaW1wbGVtZW50YXRpb24gYWxsb3dzXG4gICAgICAgKiBzaWRlLWVmZmVjdHMgb2YgZGVlcCBvYmplY3QgY2hhbmdlcyB0byBiZSBwcm9jZXNzZWQgYnkgcmUtc2V0dGluZyB0aGVcbiAgICAgICAqIHNhbWUgb2JqZWN0ICh1c2luZyB0aGUgdGVtcCBjYWNoZSBhcyBhbiBpbi10dXJuIGJhY2tzdG9wIHRvIHByZXZlbnRcbiAgICAgICAqIGN5Y2xlcyBkdWUgdG8gMi13YXkgbm90aWZpY2F0aW9uKS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgbmFtZVxuICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBOZXcgcHJvcGVydHkgdmFsdWVcbiAgICAgICAqIEBwYXJhbSB7Kn0gb2xkIFByZXZpb3VzIHByb3BlcnR5IHZhbHVlXG4gICAgICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBwcm9wZXJ0eSBzaG91bGQgYmUgY29uc2lkZXJlZCBhIGNoYW5nZVxuICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICovXG4gICAgICBfc2hvdWxkUHJvcGVydHlDaGFuZ2UocHJvcGVydHksIHZhbHVlLCBvbGQpIHtcbiAgICAgICAgcmV0dXJuIG11dGFibGVQcm9wZXJ0eUNoYW5nZSh0aGlzLCBwcm9wZXJ0eSwgdmFsdWUsIG9sZCwgdGhpcy5tdXRhYmxlRGF0YSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIE9wdGlvbmFsTXV0YWJsZURhdGE7XG5cbiAgfSk7XG5cbiAgLy8gRXhwb3J0IGZvciB1c2UgYnkgbGVnYWN5IGJlaGF2aW9yXG4gIFBvbHltZXIuTXV0YWJsZURhdGEuX211dGFibGVQcm9wZXJ0eUNoYW5nZSA9IG11dGFibGVQcm9wZXJ0eUNoYW5nZTtcblxufSkoKTtcbjwvc2NyaXB0PlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi9taXhpbnMvbXV0YWJsZS1kYXRhLmh0bWwiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiYm9vdC5odG1sXCI+XG48c2NyaXB0PlxuKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgY29uc3QgY2FzZU1hcCA9IHt9O1xuICBjb25zdCBEQVNIX1RPX0NBTUVMID0gLy1bYS16XS9nO1xuICBjb25zdCBDQU1FTF9UT19EQVNIID0gLyhbQS1aXSkvZztcblxuICAvKipcbiAgICogTW9kdWxlIHdpdGggdXRpbGl0aWVzIGZvciBjb252ZXJ0aW5nIGJldHdlZW4gXCJkYXNoLWNhc2VcIiBhbmQgXCJjYW1lbENhc2VcIlxuICAgKiBpZGVudGlmaWVycy5cbiAgICpcbiAgICogQG5hbWVzcGFjZVxuICAgKiBAbWVtYmVyb2YgUG9seW1lclxuICAgKiBAc3VtbWFyeSBNb2R1bGUgdGhhdCBwcm92aWRlcyB1dGlsaXRpZXMgZm9yIGNvbnZlcnRpbmcgYmV0d2VlbiBcImRhc2gtY2FzZVwiXG4gICAqICAgYW5kIFwiY2FtZWxDYXNlXCIuXG4gICAqL1xuICBjb25zdCBDYXNlTWFwID0ge1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgXCJkYXNoLWNhc2VcIiBpZGVudGlmaWVyIChlLmcuIGBmb28tYmFyLWJhemApIHRvIFwiY2FtZWxDYXNlXCJcbiAgICAgKiAoZS5nLiBgZm9vQmFyQmF6YCkuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgUG9seW1lci5DYXNlTWFwXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRhc2ggRGFzaC1jYXNlIGlkZW50aWZpZXJcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IENhbWVsLWNhc2UgcmVwcmVzZW50YXRpb24gb2YgdGhlIGlkZW50aWZpZXJcbiAgICAgKi9cbiAgICBkYXNoVG9DYW1lbENhc2UoZGFzaCkge1xuICAgICAgcmV0dXJuIGNhc2VNYXBbZGFzaF0gfHwgKFxuICAgICAgICBjYXNlTWFwW2Rhc2hdID0gZGFzaC5pbmRleE9mKCctJykgPCAwID8gZGFzaCA6IGRhc2gucmVwbGFjZShEQVNIX1RPX0NBTUVMLFxuICAgICAgICAgIChtKSA9PiBtWzFdLnRvVXBwZXJDYXNlKClcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgXCJjYW1lbENhc2VcIiBpZGVudGlmaWVyIChlLmcuIGBmb29CYXJCYXpgKSB0byBcImRhc2gtY2FzZVwiXG4gICAgICogKGUuZy4gYGZvby1iYXItYmF6YCkuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgUG9seW1lci5DYXNlTWFwXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNhbWVsIENhbWVsLWNhc2UgaWRlbnRpZmllclxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gRGFzaC1jYXNlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBpZGVudGlmaWVyXG4gICAgICovXG4gICAgY2FtZWxUb0Rhc2hDYXNlKGNhbWVsKSB7XG4gICAgICByZXR1cm4gY2FzZU1hcFtjYW1lbF0gfHwgKFxuICAgICAgICBjYXNlTWFwW2NhbWVsXSA9IGNhbWVsLnJlcGxhY2UoQ0FNRUxfVE9fREFTSCwgJy0kMScpLnRvTG93ZXJDYXNlKClcbiAgICAgICk7XG4gICAgfVxuXG4gIH07XG5cbiAgUG9seW1lci5DYXNlTWFwID0gQ2FzZU1hcDtcbn0pKCk7XG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvdXRpbHMvY2FzZS1tYXAuaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cblxuXG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vdXRpbHMvYm9vdC5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vdXRpbHMvbWl4aW4uaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3V0aWxzL3BhdGguaHRtbFwiPlxuPCEtLSBmb3Igbm90aWZ5LCByZWZsZWN0IC0tPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3V0aWxzL2Nhc2UtbWFwLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCJwcm9wZXJ0eS1hY2Nlc3NvcnMuaHRtbFwiPlxuPCEtLSBmb3IgYW5ub3RhdGVkIGVmZmVjdHMgLS0+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwidGVtcGxhdGUtc3RhbXAuaHRtbFwiPlxuXG5cbjxzY3JpcHQ+XG4oZnVuY3Rpb24oKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8qKiBAY29uc3Qge09iamVjdH0gKi9cbiAgY29uc3QgQ2FzZU1hcCA9IFBvbHltZXIuQ2FzZU1hcDtcblxuICAvLyBNb25vdG9uaWNhbGx5IGluY3JlYXNpbmcgdW5pcXVlIElEIHVzZWQgZm9yIGRlLWR1cGluZyBlZmZlY3RzIHRyaWdnZXJlZFxuICAvLyBmcm9tIG11bHRpcGxlIHByb3BlcnRpZXMgaW4gdGhlIHNhbWUgdHVyblxuICBsZXQgZGVkdXBlSWQgPSAwO1xuXG4gIC8qKlxuICAgKiBQcm9wZXJ0eSBlZmZlY3QgdHlwZXM7IGVmZmVjdHMgYXJlIHN0b3JlZCBvbiB0aGUgcHJvdG90eXBlIHVzaW5nIHRoZXNlIGtleXNcbiAgICogQGVudW0ge3N0cmluZ31cbiAgICovXG4gIGNvbnN0IFRZUEVTID0ge1xuICAgIENPTVBVVEU6ICdfX2NvbXB1dGVFZmZlY3RzJyxcbiAgICBSRUZMRUNUOiAnX19yZWZsZWN0RWZmZWN0cycsXG4gICAgTk9USUZZOiAnX19ub3RpZnlFZmZlY3RzJyxcbiAgICBQUk9QQUdBVEU6ICdfX3Byb3BhZ2F0ZUVmZmVjdHMnLFxuICAgIE9CU0VSVkU6ICdfX29ic2VydmVFZmZlY3RzJyxcbiAgICBSRUFEX09OTFk6ICdfX3JlYWRPbmx5J1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlZGVmIHt7XG4gICAqIG5hbWU6IChzdHJpbmcgfCB1bmRlZmluZWQpLFxuICAgKiBzdHJ1Y3R1cmVkOiAoYm9vbGVhbiB8IHVuZGVmaW5lZCksXG4gICAqIHdpbGRjYXJkOiAoYm9vbGVhbiB8IHVuZGVmaW5lZClcbiAgICogfX1cbiAgICovXG4gIGxldCBEYXRhVHJpZ2dlcjsgLy9lc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cbiAgLyoqXG4gICAqIEB0eXBlZGVmIHt7XG4gICAqIGluZm86ID8sXG4gICAqIHRyaWdnZXI6ICghRGF0YVRyaWdnZXIgfCB1bmRlZmluZWQpLFxuICAgKiBmbjogKCFGdW5jdGlvbiB8IHVuZGVmaW5lZClcbiAgICogfX1cbiAgICovXG4gIGxldCBEYXRhRWZmZWN0OyAvL2VzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblxuICBsZXQgUHJvcGVydHlFZmZlY3RzVHlwZTsgLy9lc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cbiAgLyoqXG4gICAqIEVuc3VyZXMgdGhhdCB0aGUgbW9kZWwgaGFzIGFuIG93bi1wcm9wZXJ0eSBtYXAgb2YgZWZmZWN0cyBmb3IgdGhlIGdpdmVuIHR5cGUuXG4gICAqIFRoZSBtb2RlbCBtYXkgYmUgYSBwcm90b3R5cGUgb3IgYW4gaW5zdGFuY2UuXG4gICAqXG4gICAqIFByb3BlcnR5IGVmZmVjdHMgYXJlIHN0b3JlZCBhcyBhcnJheXMgb2YgZWZmZWN0cyBieSBwcm9wZXJ0eSBpbiBhIG1hcCxcbiAgICogYnkgbmFtZWQgdHlwZSBvbiB0aGUgbW9kZWwuIGUuZy5cbiAgICpcbiAgICogICBfX2NvbXB1dGVFZmZlY3RzOiB7XG4gICAqICAgICBmb286IFsgLi4uIF0sXG4gICAqICAgICBiYXI6IFsgLi4uIF1cbiAgICogICB9XG4gICAqXG4gICAqIElmIHRoZSBtb2RlbCBkb2VzIG5vdCB5ZXQgaGF2ZSBhbiBlZmZlY3QgbWFwIGZvciB0aGUgdHlwZSwgb25lIGlzIGNyZWF0ZWRcbiAgICogYW5kIHJldHVybmVkLiAgSWYgaXQgZG9lcywgYnV0IGl0IGlzIG5vdCBhbiBvd24gcHJvcGVydHkgKGkuZS4gdGhlXG4gICAqIHByb3RvdHlwZSBoYWQgZWZmZWN0cyksIHRoZSB0aGUgbWFwIGlzIGRlZXBseSBjbG9uZWQgYW5kIHRoZSBjb3B5IGlzXG4gICAqIHNldCBvbiB0aGUgbW9kZWwgYW5kIHJldHVybmVkLCByZWFkeSBmb3IgbmV3IGVmZmVjdHMgdG8gYmUgYWRkZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBtb2RlbCBQcm90b3R5cGUgb3IgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgUHJvcGVydHkgZWZmZWN0IHR5cGVcbiAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgb3duLXByb3BlcnR5IG1hcCBvZiBlZmZlY3RzIGZvciB0aGUgZ2l2ZW4gdHlwZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gZW5zdXJlT3duRWZmZWN0TWFwKG1vZGVsLCB0eXBlKSB7XG4gICAgbGV0IGVmZmVjdHMgPSBtb2RlbFt0eXBlXTtcbiAgICBpZiAoIWVmZmVjdHMpIHtcbiAgICAgIGVmZmVjdHMgPSBtb2RlbFt0eXBlXSA9IHt9O1xuICAgIH0gZWxzZSBpZiAoIW1vZGVsLmhhc093blByb3BlcnR5KHR5cGUpKSB7XG4gICAgICBlZmZlY3RzID0gbW9kZWxbdHlwZV0gPSBPYmplY3QuY3JlYXRlKG1vZGVsW3R5cGVdKTtcbiAgICAgIGZvciAobGV0IHAgaW4gZWZmZWN0cykge1xuICAgICAgICBsZXQgcHJvdG9GeCA9IGVmZmVjdHNbcF07XG4gICAgICAgIGxldCBpbnN0RnggPSBlZmZlY3RzW3BdID0gQXJyYXkocHJvdG9GeC5sZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8cHJvdG9GeC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGluc3RGeFtpXSA9IHByb3RvRnhbaV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVmZmVjdHM7XG4gIH1cblxuICAvLyAtLSBlZmZlY3RzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvKipcbiAgICogUnVucyBhbGwgZWZmZWN0cyBvZiBhIGdpdmVuIHR5cGUgZm9yIHRoZSBnaXZlbiBzZXQgb2YgcHJvcGVydHkgY2hhbmdlc1xuICAgKiBvbiBhbiBpbnN0YW5jZS5cbiAgICpcbiAgICogQHBhcmFtIHshUHJvcGVydHlFZmZlY3RzVHlwZX0gaW5zdCBUaGUgaW5zdGFuY2Ugd2l0aCBlZmZlY3RzIHRvIHJ1blxuICAgKiBAcGFyYW0ge09iamVjdH0gZWZmZWN0cyBPYmplY3QgbWFwIG9mIHByb3BlcnR5LXRvLUFycmF5IG9mIGVmZmVjdHNcbiAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzIEJhZyBvZiBjdXJyZW50IHByb3BlcnR5IGNoYW5nZXNcbiAgICogQHBhcmFtIHtPYmplY3Q9fSBvbGRQcm9wcyBCYWcgb2YgcHJldmlvdXMgdmFsdWVzIGZvciBjaGFuZ2VkIHByb3BlcnRpZXNcbiAgICogQHBhcmFtIHtib29sZWFuPX0gaGFzUGF0aHMgVHJ1ZSB3aXRoIGBwcm9wc2AgY29udGFpbnMgb25lIG9yIG1vcmUgcGF0aHNcbiAgICogQHBhcmFtIHsqPX0gZXh0cmFBcmdzIEFkZGl0aW9uYWwgbWV0YWRhdGEgdG8gcGFzcyB0byBlZmZlY3QgZnVuY3Rpb25cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBhbiBlZmZlY3QgcmFuIGZvciB0aGlzIHByb3BlcnR5XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBydW5FZmZlY3RzKGluc3QsIGVmZmVjdHMsIHByb3BzLCBvbGRQcm9wcywgaGFzUGF0aHMsIGV4dHJhQXJncykge1xuICAgIGlmIChlZmZlY3RzKSB7XG4gICAgICBsZXQgcmFuID0gZmFsc2U7XG4gICAgICBsZXQgaWQgPSBkZWR1cGVJZCsrO1xuICAgICAgZm9yIChsZXQgcHJvcCBpbiBwcm9wcykge1xuICAgICAgICBpZiAocnVuRWZmZWN0c0ZvclByb3BlcnR5KGluc3QsIGVmZmVjdHMsIGlkLCBwcm9wLCBwcm9wcywgb2xkUHJvcHMsIGhhc1BhdGhzLCBleHRyYUFyZ3MpKSB7XG4gICAgICAgICAgcmFuID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJhbjtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJ1bnMgYSBsaXN0IG9mIGVmZmVjdHMgZm9yIGEgZ2l2ZW4gcHJvcGVydHkuXG4gICAqXG4gICAqIEBwYXJhbSB7IVByb3BlcnR5RWZmZWN0c1R5cGV9IGluc3QgVGhlIGluc3RhbmNlIHdpdGggZWZmZWN0cyB0byBydW5cbiAgICogQHBhcmFtIHtPYmplY3R9IGVmZmVjdHMgT2JqZWN0IG1hcCBvZiBwcm9wZXJ0eS10by1BcnJheSBvZiBlZmZlY3RzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkZWR1cGVJZCBDb3VudGVyIHVzZWQgZm9yIGRlLWR1cGluZyBlZmZlY3RzXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wIE5hbWUgb2YgY2hhbmdlZCBwcm9wZXJ0eVxuICAgKiBAcGFyYW0geyp9IHByb3BzIENoYW5nZWQgcHJvcGVydGllc1xuICAgKiBAcGFyYW0geyp9IG9sZFByb3BzIE9sZCBwcm9wZXJ0aWVzXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IGhhc1BhdGhzIFRydWUgd2l0aCBgcHJvcHNgIGNvbnRhaW5zIG9uZSBvciBtb3JlIHBhdGhzXG4gICAqIEBwYXJhbSB7Kj19IGV4dHJhQXJncyBBZGRpdGlvbmFsIG1ldGFkYXRhIHRvIHBhc3MgdG8gZWZmZWN0IGZ1bmN0aW9uXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYW4gZWZmZWN0IHJhbiBmb3IgdGhpcyBwcm9wZXJ0eVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gcnVuRWZmZWN0c0ZvclByb3BlcnR5KGluc3QsIGVmZmVjdHMsIGRlZHVwZUlkLCBwcm9wLCBwcm9wcywgb2xkUHJvcHMsIGhhc1BhdGhzLCBleHRyYUFyZ3MpIHtcbiAgICBsZXQgcmFuID0gZmFsc2U7XG4gICAgbGV0IHJvb3RQcm9wZXJ0eSA9IGhhc1BhdGhzID8gUG9seW1lci5QYXRoLnJvb3QocHJvcCkgOiBwcm9wO1xuICAgIGxldCBmeHMgPSBlZmZlY3RzW3Jvb3RQcm9wZXJ0eV07XG4gICAgaWYgKGZ4cykge1xuICAgICAgZm9yIChsZXQgaT0wLCBsPWZ4cy5sZW5ndGgsIGZ4OyAoaTxsKSAmJiAoZng9ZnhzW2ldKTsgaSsrKSB7XG4gICAgICAgIGlmICgoIWZ4LmluZm8gfHwgZnguaW5mby5sYXN0UnVuICE9PSBkZWR1cGVJZCkgJiZcbiAgICAgICAgICAgICghaGFzUGF0aHMgfHwgcGF0aE1hdGNoZXNUcmlnZ2VyKHByb3AsIGZ4LnRyaWdnZXIpKSkge1xuICAgICAgICAgIGlmIChmeC5pbmZvKSB7XG4gICAgICAgICAgICBmeC5pbmZvLmxhc3RSdW4gPSBkZWR1cGVJZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnguZm4oaW5zdCwgcHJvcCwgcHJvcHMsIG9sZFByb3BzLCBmeC5pbmZvLCBoYXNQYXRocywgZXh0cmFBcmdzKTtcbiAgICAgICAgICByYW4gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByYW47XG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIGEgcHJvcGVydHkvcGF0aCB0aGF0IGhhcyBjaGFuZ2VkIG1hdGNoZXMgdGhlIHRyaWdnZXJcbiAgICogY3JpdGVyaWEgZm9yIGFuIGVmZmVjdC4gIEEgdHJpZ2dlciBpcyBhIGRlc2NyaXB0b3Igd2l0aCB0aGUgZm9sbG93aW5nXG4gICAqIHN0cnVjdHVyZSwgd2hpY2ggbWF0Y2hlcyB0aGUgZGVzY3JpcHRvcnMgcmV0dXJuZWQgZnJvbSBgcGFyc2VBcmdgLlxuICAgKiBlLmcuIGZvciBgZm9vLmJhci4qYDpcbiAgICogYGBgXG4gICAqIHRyaWdnZXI6IHtcbiAgICogICBuYW1lOiAnYS5iJyxcbiAgICogICBzdHJ1Y3R1cmVkOiB0cnVlLFxuICAgKiAgIHdpbGRjYXJkOiB0cnVlXG4gICAqIH1cbiAgICogYGBgXG4gICAqIElmIG5vIHRyaWdnZXIgaXMgZ2l2ZW4sIHRoZSBwYXRoIGlzIGRlZW1lZCB0byBtYXRjaC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggUGF0aCBvciBwcm9wZXJ0eSB0aGF0IGNoYW5nZWRcbiAgICogQHBhcmFtIHtEYXRhVHJpZ2dlcn0gdHJpZ2dlciBEZXNjcmlwdG9yXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIHBhdGggbWF0Y2hlZCB0aGUgdHJpZ2dlclxuICAgKi9cbiAgZnVuY3Rpb24gcGF0aE1hdGNoZXNUcmlnZ2VyKHBhdGgsIHRyaWdnZXIpIHtcbiAgICBpZiAodHJpZ2dlcikge1xuICAgICAgbGV0IHRyaWdnZXJQYXRoID0gdHJpZ2dlci5uYW1lO1xuICAgICAgcmV0dXJuICh0cmlnZ2VyUGF0aCA9PSBwYXRoKSB8fFxuICAgICAgICAodHJpZ2dlci5zdHJ1Y3R1cmVkICYmIFBvbHltZXIuUGF0aC5pc0FuY2VzdG9yKHRyaWdnZXJQYXRoLCBwYXRoKSkgfHxcbiAgICAgICAgKHRyaWdnZXIud2lsZGNhcmQgJiYgUG9seW1lci5QYXRoLmlzRGVzY2VuZGFudCh0cmlnZ2VyUGF0aCwgcGF0aCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSW1wbGVtZW50cyB0aGUgXCJvYnNlcnZlclwiIGVmZmVjdC5cbiAgICpcbiAgICogQ2FsbHMgdGhlIG1ldGhvZCB3aXRoIGBpbmZvLm1ldGhvZE5hbWVgIG9uIHRoZSBpbnN0YW5jZSwgcGFzc2luZyB0aGVcbiAgICogbmV3IGFuZCBvbGQgdmFsdWVzLlxuICAgKlxuICAgKiBAcGFyYW0geyFQcm9wZXJ0eUVmZmVjdHNUeXBlfSBpbnN0IFRoZSBpbnN0YW5jZSB0aGUgZWZmZWN0IHdpbGwgYmUgcnVuIG9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBOYW1lIG9mIHByb3BlcnR5XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBCYWcgb2YgY3VycmVudCBwcm9wZXJ0eSBjaGFuZ2VzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvbGRQcm9wcyBCYWcgb2YgcHJldmlvdXMgdmFsdWVzIGZvciBjaGFuZ2VkIHByb3BlcnRpZXNcbiAgICogQHBhcmFtIHs/fSBpbmZvIEVmZmVjdCBtZXRhZGF0YVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gcnVuT2JzZXJ2ZXJFZmZlY3QoaW5zdCwgcHJvcGVydHksIHByb3BzLCBvbGRQcm9wcywgaW5mbykge1xuICAgIGxldCBmbiA9IGluc3RbaW5mby5tZXRob2ROYW1lXTtcbiAgICBsZXQgY2hhbmdlZFByb3AgPSBpbmZvLnByb3BlcnR5O1xuICAgIGlmIChmbikge1xuICAgICAgZm4uY2FsbChpbnN0LCBpbnN0Ll9fZGF0YVtjaGFuZ2VkUHJvcF0sIG9sZFByb3BzW2NoYW5nZWRQcm9wXSk7XG4gICAgfSBlbHNlIGlmICghaW5mby5keW5hbWljRm4pIHtcbiAgICAgIGNvbnNvbGUud2Fybignb2JzZXJ2ZXIgbWV0aG9kIGAnICsgaW5mby5tZXRob2ROYW1lICsgJ2Agbm90IGRlZmluZWQnKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUnVucyBcIm5vdGlmeVwiIGVmZmVjdHMgZm9yIGEgc2V0IG9mIGNoYW5nZWQgcHJvcGVydGllcy5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgZGlmZmVycyBmcm9tIHRoZSBnZW5lcmljIGBydW5FZmZlY3RzYCBtZXRob2QgaW4gdGhhdCBpdFxuICAgKiB3aWxsIGRpc3BhdGNoIHBhdGggbm90aWZpY2F0aW9uIGV2ZW50cyBpbiB0aGUgY2FzZSB0aGF0IHRoZSBwcm9wZXJ0eVxuICAgKiBjaGFuZ2VkIHdhcyBhIHBhdGggYW5kIHRoZSByb290IHByb3BlcnR5IGZvciB0aGF0IHBhdGggZGlkbid0IGhhdmUgYVxuICAgKiBcIm5vdGlmeVwiIGVmZmVjdC4gIFRoaXMgaXMgdG8gbWFpbnRhaW4gMS4wIGJlaGF2aW9yIHRoYXQgZGlkIG5vdCByZXF1aXJlXG4gICAqIGBub3RpZnk6IHRydWVgIHRvIGVuc3VyZSBvYmplY3Qgc3ViLXByb3BlcnR5IG5vdGlmaWNhdGlvbnMgd2VyZVxuICAgKiBzZW50LlxuICAgKlxuICAgKiBAcGFyYW0geyFQcm9wZXJ0eUVmZmVjdHNUeXBlfSBpbnN0IFRoZSBpbnN0YW5jZSB3aXRoIGVmZmVjdHMgdG8gcnVuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBub3RpZnlQcm9wcyBCYWcgb2YgcHJvcGVydGllcyB0byBub3RpZnlcbiAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzIEJhZyBvZiBjdXJyZW50IHByb3BlcnR5IGNoYW5nZXNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9sZFByb3BzIEJhZyBvZiBwcmV2aW91cyB2YWx1ZXMgZm9yIGNoYW5nZWQgcHJvcGVydGllc1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhhc1BhdGhzIFRydWUgd2l0aCBgcHJvcHNgIGNvbnRhaW5zIG9uZSBvciBtb3JlIHBhdGhzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBydW5Ob3RpZnlFZmZlY3RzKGluc3QsIG5vdGlmeVByb3BzLCBwcm9wcywgb2xkUHJvcHMsIGhhc1BhdGhzKSB7XG4gICAgLy8gTm90aWZ5XG4gICAgbGV0IGZ4cyA9IGluc3RbVFlQRVMuTk9USUZZXTtcbiAgICBsZXQgbm90aWZpZWQ7XG4gICAgbGV0IGlkID0gZGVkdXBlSWQrKztcbiAgICAvLyBUcnkgbm9ybWFsIG5vdGlmeSBlZmZlY3RzOyBpZiBub25lLCBmYWxsIGJhY2sgdG8gdHJ5IHBhdGggbm90aWZpY2F0aW9uXG4gICAgZm9yIChsZXQgcHJvcCBpbiBub3RpZnlQcm9wcykge1xuICAgICAgaWYgKG5vdGlmeVByb3BzW3Byb3BdKSB7XG4gICAgICAgIGlmIChmeHMgJiYgcnVuRWZmZWN0c0ZvclByb3BlcnR5KGluc3QsIGZ4cywgaWQsIHByb3AsIHByb3BzLCBvbGRQcm9wcywgaGFzUGF0aHMpKSB7XG4gICAgICAgICAgbm90aWZpZWQgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGhhc1BhdGhzICYmIG5vdGlmeVBhdGgoaW5zdCwgcHJvcCwgcHJvcHMpKSB7XG4gICAgICAgICAgbm90aWZpZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIEZsdXNoIGhvc3QgaWYgd2UgYWN0dWFsbHkgbm90aWZpZWQgYW5kIGhvc3Qgd2FzIGJhdGNoaW5nXG4gICAgLy8gQW5kIHRoZSBob3N0IGhhcyBhbHJlYWR5IGluaXRpYWxpemVkIGNsaWVudHM7IHRoaXMgcHJldmVudHNcbiAgICAvLyBhbiBpc3N1ZSB3aXRoIGEgaG9zdCBvYnNlcnZpbmcgZGF0YSBjaGFuZ2VzIGJlZm9yZSBjbGllbnRzIGFyZSByZWFkeS5cbiAgICBsZXQgaG9zdDtcbiAgICBpZiAobm90aWZpZWQgJiYgKGhvc3QgPSBpbnN0Ll9fZGF0YUhvc3QpICYmIGhvc3QuX2ludmFsaWRhdGVQcm9wZXJ0aWVzKSB7XG4gICAgICBob3N0Ll9pbnZhbGlkYXRlUHJvcGVydGllcygpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNwYXRjaGVzIHtwcm9wZXJ0eX0tY2hhbmdlZCBldmVudHMgd2l0aCBwYXRoIGluZm9ybWF0aW9uIGluIHRoZSBkZXRhaWxcbiAgICogb2JqZWN0IHRvIGluZGljYXRlIGEgc3ViLXBhdGggb2YgdGhlIHByb3BlcnR5IHdhcyBjaGFuZ2VkLlxuICAgKlxuICAgKiBAcGFyYW0geyFQcm9wZXJ0eUVmZmVjdHNUeXBlfSBpbnN0IFRoZSBlbGVtZW50IGZyb20gd2hpY2ggdG8gZmlyZSB0aGUgZXZlbnRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggVGhlIHBhdGggdGhhdCB3YXMgY2hhbmdlZFxuICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgQmFnIG9mIGN1cnJlbnQgcHJvcGVydHkgY2hhbmdlc1xuICAgKiBAcmV0dXJuIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgdGhlIHBhdGggd2FzIG5vdGlmaWVkXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBub3RpZnlQYXRoKGluc3QsIHBhdGgsIHByb3BzKSB7XG4gICAgbGV0IHJvb3RQcm9wZXJ0eSA9IFBvbHltZXIuUGF0aC5yb290KHBhdGgpO1xuICAgIGlmIChyb290UHJvcGVydHkgIT09IHBhdGgpIHtcbiAgICAgIGxldCBldmVudE5hbWUgPSBQb2x5bWVyLkNhc2VNYXAuY2FtZWxUb0Rhc2hDYXNlKHJvb3RQcm9wZXJ0eSkgKyAnLWNoYW5nZWQnO1xuICAgICAgZGlzcGF0Y2hOb3RpZnlFdmVudChpbnN0LCBldmVudE5hbWUsIHByb3BzW3BhdGhdLCBwYXRoKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogRGlzcGF0Y2hlcyB7cHJvcGVydHl9LWNoYW5nZWQgZXZlbnRzIHRvIGluZGljYXRlIGEgcHJvcGVydHkgKG9yIHBhdGgpXG4gICAqIGNoYW5nZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7IVByb3BlcnR5RWZmZWN0c1R5cGV9IGluc3QgVGhlIGVsZW1lbnQgZnJvbSB3aGljaCB0byBmaXJlIHRoZSBldmVudFxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byBzZW5kICgne3Byb3BlcnR5fS1jaGFuZ2VkJylcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgb2YgdGhlIGNoYW5nZWQgcHJvcGVydHlcbiAgICogQHBhcmFtIHtzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkfSBwYXRoIElmIGEgc3ViLXBhdGggb2YgdGhpcyBwcm9wZXJ0eSBjaGFuZ2VkLCB0aGUgcGF0aFxuICAgKiAgIHRoYXQgY2hhbmdlZCAob3B0aW9uYWwpLlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAc3VwcHJlc3Mge2ludmFsaWRDYXN0c31cbiAgICovXG4gIGZ1bmN0aW9uIGRpc3BhdGNoTm90aWZ5RXZlbnQoaW5zdCwgZXZlbnROYW1lLCB2YWx1ZSwgcGF0aCkge1xuICAgIGxldCBkZXRhaWwgPSB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBxdWV1ZVByb3BlcnR5OiB0cnVlXG4gICAgfTtcbiAgICBpZiAocGF0aCkge1xuICAgICAgZGV0YWlsLnBhdGggPSBwYXRoO1xuICAgIH1cbiAgICAvKiogQHR5cGUgeyFIVE1MRWxlbWVudH0gKi8oaW5zdCkuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoZXZlbnROYW1lLCB7IGRldGFpbCB9KSk7XG4gIH1cblxuICAvKipcbiAgICogSW1wbGVtZW50cyB0aGUgXCJub3RpZnlcIiBlZmZlY3QuXG4gICAqXG4gICAqIERpc3BhdGNoZXMgYSBub24tYnViYmxpbmcgZXZlbnQgbmFtZWQgYGluZm8uZXZlbnROYW1lYCBvbiB0aGUgaW5zdGFuY2VcbiAgICogd2l0aCBhIGRldGFpbCBvYmplY3QgY29udGFpbmluZyB0aGUgbmV3IGB2YWx1ZWAuXG4gICAqXG4gICAqIEBwYXJhbSB7IVByb3BlcnR5RWZmZWN0c1R5cGV9IGluc3QgVGhlIGluc3RhbmNlIHRoZSBlZmZlY3Qgd2lsbCBiZSBydW4gb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IE5hbWUgb2YgcHJvcGVydHlcbiAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzIEJhZyBvZiBjdXJyZW50IHByb3BlcnR5IGNoYW5nZXNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9sZFByb3BzIEJhZyBvZiBwcmV2aW91cyB2YWx1ZXMgZm9yIGNoYW5nZWQgcHJvcGVydGllc1xuICAgKiBAcGFyYW0gez99IGluZm8gRWZmZWN0IG1ldGFkYXRhXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaGFzUGF0aHMgVHJ1ZSB3aXRoIGBwcm9wc2AgY29udGFpbnMgb25lIG9yIG1vcmUgcGF0aHNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIHJ1bk5vdGlmeUVmZmVjdChpbnN0LCBwcm9wZXJ0eSwgcHJvcHMsIG9sZFByb3BzLCBpbmZvLCBoYXNQYXRocykge1xuICAgIGxldCByb290UHJvcGVydHkgPSBoYXNQYXRocyA/IFBvbHltZXIuUGF0aC5yb290KHByb3BlcnR5KSA6IHByb3BlcnR5O1xuICAgIGxldCBwYXRoID0gcm9vdFByb3BlcnR5ICE9IHByb3BlcnR5ID8gcHJvcGVydHkgOiBudWxsO1xuICAgIGxldCB2YWx1ZSA9IHBhdGggPyBQb2x5bWVyLlBhdGguZ2V0KGluc3QsIHBhdGgpIDogaW5zdC5fX2RhdGFbcHJvcGVydHldO1xuICAgIGlmIChwYXRoICYmIHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhbHVlID0gcHJvcHNbcHJvcGVydHldOyAgLy8gc3BlY2lmaWNhbGx5IGZvciAuc3BsaWNlc1xuICAgIH1cbiAgICBkaXNwYXRjaE5vdGlmeUV2ZW50KGluc3QsIGluZm8uZXZlbnROYW1lLCB2YWx1ZSwgcGF0aCk7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlciBmdW5jdGlvbiBmb3IgMi13YXkgbm90aWZpY2F0aW9uIGV2ZW50cy4gUmVjZWl2ZXMgY29udGV4dFxuICAgKiBpbmZvcm1hdGlvbiBjYXB0dXJlZCBpbiB0aGUgYGFkZE5vdGlmeUxpc3RlbmVyYCBjbG9zdXJlIGZyb20gdGhlXG4gICAqIGBfX25vdGlmeUxpc3RlbmVyc2AgbWV0YWRhdGEuXG4gICAqXG4gICAqIFNldHMgdGhlIHZhbHVlIG9mIHRoZSBub3RpZmllZCBwcm9wZXJ0eSB0byB0aGUgaG9zdCBwcm9wZXJ0eSBvciBwYXRoLiAgSWZcbiAgICogdGhlIGV2ZW50IGNvbnRhaW5lZCBwYXRoIGluZm9ybWF0aW9uLCB0cmFuc2xhdGUgdGhhdCBwYXRoIHRvIHRoZSBob3N0XG4gICAqIHNjb3BlJ3MgbmFtZSBmb3IgdGhhdCBwYXRoIGZpcnN0LlxuICAgKlxuICAgKiBAcGFyYW0ge0N1c3RvbUV2ZW50fSBldmVudCBOb3RpZmljYXRpb24gZXZlbnQgKGUuZy4gJzxwcm9wZXJ0eT4tY2hhbmdlZCcpXG4gICAqIEBwYXJhbSB7IVByb3BlcnR5RWZmZWN0c1R5cGV9IGluc3QgSG9zdCBlbGVtZW50IGluc3RhbmNlIGhhbmRsaW5nIHRoZSBub3RpZmljYXRpb24gZXZlbnRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZyb21Qcm9wIENoaWxkIGVsZW1lbnQgcHJvcGVydHkgdGhhdCB3YXMgYm91bmRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRvUGF0aCBIb3N0IHByb3BlcnR5L3BhdGggdGhhdCB3YXMgYm91bmRcbiAgICogQHBhcmFtIHtib29sZWFufSBuZWdhdGUgV2hldGhlciB0aGUgYmluZGluZyB3YXMgbmVnYXRlZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gaGFuZGxlTm90aWZpY2F0aW9uKGV2ZW50LCBpbnN0LCBmcm9tUHJvcCwgdG9QYXRoLCBuZWdhdGUpIHtcbiAgICBsZXQgdmFsdWU7XG4gICAgbGV0IGRldGFpbCA9IC8qKiBAdHlwZSB7T2JqZWN0fSAqLyhldmVudC5kZXRhaWwpO1xuICAgIGxldCBmcm9tUGF0aCA9IGRldGFpbCAmJiBkZXRhaWwucGF0aDtcbiAgICBpZiAoZnJvbVBhdGgpIHtcbiAgICAgIHRvUGF0aCA9IFBvbHltZXIuUGF0aC50cmFuc2xhdGUoZnJvbVByb3AsIHRvUGF0aCwgZnJvbVBhdGgpO1xuICAgICAgdmFsdWUgPSBkZXRhaWwgJiYgZGV0YWlsLnZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSA9IGV2ZW50LnRhcmdldFtmcm9tUHJvcF07XG4gICAgfVxuICAgIHZhbHVlID0gbmVnYXRlID8gIXZhbHVlIDogdmFsdWU7XG4gICAgaWYgKCFpbnN0W1RZUEVTLlJFQURfT05MWV0gfHwgIWluc3RbVFlQRVMuUkVBRF9PTkxZXVt0b1BhdGhdKSB7XG4gICAgICBpZiAoaW5zdC5fc2V0UGVuZGluZ1Byb3BlcnR5T3JQYXRoKHRvUGF0aCwgdmFsdWUsIHRydWUsIEJvb2xlYW4oZnJvbVBhdGgpKVxuICAgICAgICAmJiAoIWRldGFpbCB8fCAhZGV0YWlsLnF1ZXVlUHJvcGVydHkpKSB7XG4gICAgICAgIGluc3QuX2ludmFsaWRhdGVQcm9wZXJ0aWVzKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEltcGxlbWVudHMgdGhlIFwicmVmbGVjdFwiIGVmZmVjdC5cbiAgICpcbiAgICogU2V0cyB0aGUgYXR0cmlidXRlIG5hbWVkIGBpbmZvLmF0dHJOYW1lYCB0byB0aGUgZ2l2ZW4gcHJvcGVydHkgdmFsdWUuXG4gICAqXG4gICAqIEBwYXJhbSB7IVByb3BlcnR5RWZmZWN0c1R5cGV9IGluc3QgVGhlIGluc3RhbmNlIHRoZSBlZmZlY3Qgd2lsbCBiZSBydW4gb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IE5hbWUgb2YgcHJvcGVydHlcbiAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzIEJhZyBvZiBjdXJyZW50IHByb3BlcnR5IGNoYW5nZXNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9sZFByb3BzIEJhZyBvZiBwcmV2aW91cyB2YWx1ZXMgZm9yIGNoYW5nZWQgcHJvcGVydGllc1xuICAgKiBAcGFyYW0gez99IGluZm8gRWZmZWN0IG1ldGFkYXRhXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBydW5SZWZsZWN0RWZmZWN0KGluc3QsIHByb3BlcnR5LCBwcm9wcywgb2xkUHJvcHMsIGluZm8pIHtcbiAgICBsZXQgdmFsdWUgPSBpbnN0Ll9fZGF0YVtwcm9wZXJ0eV07XG4gICAgaWYgKFBvbHltZXIuc2FuaXRpemVET01WYWx1ZSkge1xuICAgICAgdmFsdWUgPSBQb2x5bWVyLnNhbml0aXplRE9NVmFsdWUodmFsdWUsIGluZm8uYXR0ck5hbWUsICdhdHRyaWJ1dGUnLCAvKiogQHR5cGUge05vZGV9ICovKGluc3QpKTtcbiAgICB9XG4gICAgaW5zdC5fcHJvcGVydHlUb0F0dHJpYnV0ZShwcm9wZXJ0eSwgaW5mby5hdHRyTmFtZSwgdmFsdWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJ1bnMgXCJjb21wdXRlZFwiIGVmZmVjdHMgZm9yIGEgc2V0IG9mIGNoYW5nZWQgcHJvcGVydGllcy5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgZGlmZmVycyBmcm9tIHRoZSBnZW5lcmljIGBydW5FZmZlY3RzYCBtZXRob2QgaW4gdGhhdCBpdFxuICAgKiBjb250aW51ZXMgdG8gcnVuIGNvbXB1dGVkIGVmZmVjdHMgYmFzZWQgb24gdGhlIG91dHB1dCBvZiBlYWNoIHBhc3MgdW50aWxcbiAgICogdGhlcmUgYXJlIG5vIG1vcmUgbmV3bHkgY29tcHV0ZWQgcHJvcGVydGllcy4gIFRoaXMgZW5zdXJlcyB0aGF0IGFsbFxuICAgKiBwcm9wZXJ0aWVzIHRoYXQgd2lsbCBiZSBjb21wdXRlZCBieSB0aGUgaW5pdGlhbCBzZXQgb2YgY2hhbmdlcyBhcmVcbiAgICogY29tcHV0ZWQgYmVmb3JlIG90aGVyIGVmZmVjdHMgKGJpbmRpbmcgcHJvcGFnYXRpb24sIG9ic2VydmVycywgYW5kIG5vdGlmeSlcbiAgICogcnVuLlxuICAgKlxuICAgKiBAcGFyYW0geyFQcm9wZXJ0eUVmZmVjdHNUeXBlfSBpbnN0IFRoZSBpbnN0YW5jZSB0aGUgZWZmZWN0IHdpbGwgYmUgcnVuIG9uXG4gICAqIEBwYXJhbSB7IU9iamVjdH0gY2hhbmdlZFByb3BzIEJhZyBvZiBjaGFuZ2VkIHByb3BlcnRpZXNcbiAgICogQHBhcmFtIHshT2JqZWN0fSBvbGRQcm9wcyBCYWcgb2YgcHJldmlvdXMgdmFsdWVzIGZvciBjaGFuZ2VkIHByb3BlcnRpZXNcbiAgICogQHBhcmFtIHtib29sZWFufSBoYXNQYXRocyBUcnVlIHdpdGggYHByb3BzYCBjb250YWlucyBvbmUgb3IgbW9yZSBwYXRoc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gcnVuQ29tcHV0ZWRFZmZlY3RzKGluc3QsIGNoYW5nZWRQcm9wcywgb2xkUHJvcHMsIGhhc1BhdGhzKSB7XG4gICAgbGV0IGNvbXB1dGVFZmZlY3RzID0gaW5zdFtUWVBFUy5DT01QVVRFXTtcbiAgICBpZiAoY29tcHV0ZUVmZmVjdHMpIHtcbiAgICAgIGxldCBpbnB1dFByb3BzID0gY2hhbmdlZFByb3BzO1xuICAgICAgd2hpbGUgKHJ1bkVmZmVjdHMoaW5zdCwgY29tcHV0ZUVmZmVjdHMsIGlucHV0UHJvcHMsIG9sZFByb3BzLCBoYXNQYXRocykpIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihvbGRQcm9wcywgaW5zdC5fX2RhdGFPbGQpO1xuICAgICAgICBPYmplY3QuYXNzaWduKGNoYW5nZWRQcm9wcywgaW5zdC5fX2RhdGFQZW5kaW5nKTtcbiAgICAgICAgaW5wdXRQcm9wcyA9IGluc3QuX19kYXRhUGVuZGluZztcbiAgICAgICAgaW5zdC5fX2RhdGFQZW5kaW5nID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSW1wbGVtZW50cyB0aGUgXCJjb21wdXRlZCBwcm9wZXJ0eVwiIGVmZmVjdCBieSBydW5uaW5nIHRoZSBtZXRob2Qgd2l0aCB0aGVcbiAgICogdmFsdWVzIG9mIHRoZSBhcmd1bWVudHMgc3BlY2lmaWVkIGluIHRoZSBgaW5mb2Agb2JqZWN0IGFuZCBzZXR0aW5nIHRoZVxuICAgKiByZXR1cm4gdmFsdWUgdG8gdGhlIGNvbXB1dGVkIHByb3BlcnR5IHNwZWNpZmllZC5cbiAgICpcbiAgICogQHBhcmFtIHshUHJvcGVydHlFZmZlY3RzVHlwZX0gaW5zdCBUaGUgaW5zdGFuY2UgdGhlIGVmZmVjdCB3aWxsIGJlIHJ1biBvblxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgTmFtZSBvZiBwcm9wZXJ0eVxuICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgQmFnIG9mIGN1cnJlbnQgcHJvcGVydHkgY2hhbmdlc1xuICAgKiBAcGFyYW0ge09iamVjdH0gb2xkUHJvcHMgQmFnIG9mIHByZXZpb3VzIHZhbHVlcyBmb3IgY2hhbmdlZCBwcm9wZXJ0aWVzXG4gICAqIEBwYXJhbSB7P30gaW5mbyBFZmZlY3QgbWV0YWRhdGFcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIHJ1bkNvbXB1dGVkRWZmZWN0KGluc3QsIHByb3BlcnR5LCBwcm9wcywgb2xkUHJvcHMsIGluZm8pIHtcbiAgICBsZXQgcmVzdWx0ID0gcnVuTWV0aG9kRWZmZWN0KGluc3QsIHByb3BlcnR5LCBwcm9wcywgb2xkUHJvcHMsIGluZm8pO1xuICAgIGxldCBjb21wdXRlZFByb3AgPSBpbmZvLm1ldGhvZEluZm87XG4gICAgaWYgKGluc3QuX19kYXRhSGFzQWNjZXNzb3IgJiYgaW5zdC5fX2RhdGFIYXNBY2Nlc3Nvcltjb21wdXRlZFByb3BdKSB7XG4gICAgICBpbnN0Ll9zZXRQZW5kaW5nUHJvcGVydHkoY29tcHV0ZWRQcm9wLCByZXN1bHQsIHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnN0W2NvbXB1dGVkUHJvcF0gPSByZXN1bHQ7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbXB1dGVzIHBhdGggY2hhbmdlcyBiYXNlZCBvbiBwYXRoIGxpbmtzIHNldCB1cCB1c2luZyB0aGUgYGxpbmtQYXRoc2BcbiAgICogQVBJLlxuICAgKlxuICAgKiBAcGFyYW0geyFQcm9wZXJ0eUVmZmVjdHNUeXBlfSBpbnN0IFRoZSBpbnN0YW5jZSB3aG9zZSBwcm9wcyBhcmUgY2hhbmdpbmdcbiAgICogQHBhcmFtIHtzdHJpbmcgfCAhQXJyYXk8KHN0cmluZ3xudW1iZXIpPn0gcGF0aCBQYXRoIHRoYXQgaGFzIGNoYW5nZWRcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSBvZiBjaGFuZ2VkIHBhdGhcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIGNvbXB1dGVMaW5rZWRQYXRocyhpbnN0LCBwYXRoLCB2YWx1ZSkge1xuICAgIGxldCBsaW5rcyA9IGluc3QuX19kYXRhTGlua2VkUGF0aHM7XG4gICAgaWYgKGxpbmtzKSB7XG4gICAgICBsZXQgbGluaztcbiAgICAgIGZvciAobGV0IGEgaW4gbGlua3MpIHtcbiAgICAgICAgbGV0IGIgPSBsaW5rc1thXTtcbiAgICAgICAgaWYgKFBvbHltZXIuUGF0aC5pc0Rlc2NlbmRhbnQoYSwgcGF0aCkpIHtcbiAgICAgICAgICBsaW5rID0gUG9seW1lci5QYXRoLnRyYW5zbGF0ZShhLCBiLCBwYXRoKTtcbiAgICAgICAgICBpbnN0Ll9zZXRQZW5kaW5nUHJvcGVydHlPclBhdGgobGluaywgdmFsdWUsIHRydWUsIHRydWUpO1xuICAgICAgICB9IGVsc2UgaWYgKFBvbHltZXIuUGF0aC5pc0Rlc2NlbmRhbnQoYiwgcGF0aCkpIHtcbiAgICAgICAgICBsaW5rID0gUG9seW1lci5QYXRoLnRyYW5zbGF0ZShiLCBhLCBwYXRoKTtcbiAgICAgICAgICBpbnN0Ll9zZXRQZW5kaW5nUHJvcGVydHlPclBhdGgobGluaywgdmFsdWUsIHRydWUsIHRydWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gLS0gYmluZGluZ3MgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8qKlxuICAgKiBBZGRzIGJpbmRpbmcgbWV0YWRhdGEgdG8gdGhlIGN1cnJlbnQgYG5vZGVJbmZvYCwgYW5kIGJpbmRpbmcgZWZmZWN0c1xuICAgKiBmb3IgYWxsIHBhcnQgZGVwZW5kZW5jaWVzIHRvIGB0ZW1wbGF0ZUluZm9gLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb25zdHJ1Y3RvciBDbGFzcyB0aGF0IGBfcGFyc2VUZW1wbGF0ZWAgaXMgY3VycmVudGx5XG4gICAqICAgcnVubmluZyBvblxuICAgKiBAcGFyYW0ge1RlbXBsYXRlSW5mb30gdGVtcGxhdGVJbmZvIFRlbXBsYXRlIG1ldGFkYXRhIGZvciBjdXJyZW50IHRlbXBsYXRlXG4gICAqIEBwYXJhbSB7Tm9kZUluZm99IG5vZGVJbmZvIE5vZGUgbWV0YWRhdGEgZm9yIGN1cnJlbnQgdGVtcGxhdGUgbm9kZVxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2luZCBCaW5kaW5nIGtpbmQsIGVpdGhlciAncHJvcGVydHknLCAnYXR0cmlidXRlJywgb3IgJ3RleHQnXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0YXJnZXQgVGFyZ2V0IHByb3BlcnR5IG5hbWVcbiAgICogQHBhcmFtIHshQXJyYXk8IUJpbmRpbmdQYXJ0Pn0gcGFydHMgQXJyYXkgb2YgYmluZGluZyBwYXJ0IG1ldGFkYXRhXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gbGl0ZXJhbCBMaXRlcmFsIHRleHQgc3Vycm91bmRpbmcgYmluZGluZyBwYXJ0cyAoc3BlY2lmaWVkXG4gICAqICAgb25seSBmb3IgJ3Byb3BlcnR5JyBiaW5kaW5ncywgc2luY2UgdGhlc2UgbXVzdCBiZSBpbml0aWFsaXplZCBhcyBwYXJ0XG4gICAqICAgb2YgYm9vdC11cClcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIGFkZEJpbmRpbmcoY29uc3RydWN0b3IsIHRlbXBsYXRlSW5mbywgbm9kZUluZm8sIGtpbmQsIHRhcmdldCwgcGFydHMsIGxpdGVyYWwpIHtcbiAgICAvLyBDcmVhdGUgYmluZGluZyBtZXRhZGF0YSBhbmQgYWRkIHRvIG5vZGVJbmZvXG4gICAgbm9kZUluZm8uYmluZGluZ3MgPSBub2RlSW5mby5iaW5kaW5ncyB8fCBbXTtcbiAgICBsZXQgLyoqIEJpbmRpbmcgKi8gYmluZGluZyA9IHsga2luZCwgdGFyZ2V0LCBwYXJ0cywgbGl0ZXJhbCwgaXNDb21wb3VuZDogKHBhcnRzLmxlbmd0aCAhPT0gMSkgfTtcbiAgICBub2RlSW5mby5iaW5kaW5ncy5wdXNoKGJpbmRpbmcpO1xuICAgIC8vIEFkZCBsaXN0ZW5lciBpbmZvIHRvIGJpbmRpbmcgbWV0YWRhdGFcbiAgICBpZiAoc2hvdWxkQWRkTGlzdGVuZXIoYmluZGluZykpIHtcbiAgICAgIGxldCB7ZXZlbnQsIG5lZ2F0ZX0gPSBiaW5kaW5nLnBhcnRzWzBdO1xuICAgICAgYmluZGluZy5saXN0ZW5lckV2ZW50ID0gZXZlbnQgfHwgKENhc2VNYXAuY2FtZWxUb0Rhc2hDYXNlKHRhcmdldCkgKyAnLWNoYW5nZWQnKTtcbiAgICAgIGJpbmRpbmcubGlzdGVuZXJOZWdhdGUgPSBuZWdhdGU7XG4gICAgfVxuICAgIC8vIEFkZCBcInByb3BhZ2F0ZVwiIHByb3BlcnR5IGVmZmVjdHMgdG8gdGVtcGxhdGVJbmZvXG4gICAgbGV0IGluZGV4ID0gdGVtcGxhdGVJbmZvLm5vZGVJbmZvTGlzdC5sZW5ndGg7XG4gICAgZm9yIChsZXQgaT0wOyBpPGJpbmRpbmcucGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBwYXJ0ID0gYmluZGluZy5wYXJ0c1tpXTtcbiAgICAgIHBhcnQuY29tcG91bmRJbmRleCA9IGk7XG4gICAgICBhZGRFZmZlY3RGb3JCaW5kaW5nUGFydChjb25zdHJ1Y3RvciwgdGVtcGxhdGVJbmZvLCBiaW5kaW5nLCBwYXJ0LCBpbmRleCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgcHJvcGVydHkgZWZmZWN0cyB0byB0aGUgZ2l2ZW4gYHRlbXBsYXRlSW5mb2AgZm9yIHRoZSBnaXZlbiBiaW5kaW5nXG4gICAqIHBhcnQuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbnN0cnVjdG9yIENsYXNzIHRoYXQgYF9wYXJzZVRlbXBsYXRlYCBpcyBjdXJyZW50bHlcbiAgICogICBydW5uaW5nIG9uXG4gICAqIEBwYXJhbSB7VGVtcGxhdGVJbmZvfSB0ZW1wbGF0ZUluZm8gVGVtcGxhdGUgbWV0YWRhdGEgZm9yIGN1cnJlbnQgdGVtcGxhdGVcbiAgICogQHBhcmFtIHshQmluZGluZ30gYmluZGluZyBCaW5kaW5nIG1ldGFkYXRhXG4gICAqIEBwYXJhbSB7IUJpbmRpbmdQYXJ0fSBwYXJ0IEJpbmRpbmcgcGFydCBtZXRhZGF0YVxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSW5kZXggaW50byBgbm9kZUluZm9MaXN0YCBmb3IgdGhpcyBub2RlXG4gICAqL1xuICBmdW5jdGlvbiBhZGRFZmZlY3RGb3JCaW5kaW5nUGFydChjb25zdHJ1Y3RvciwgdGVtcGxhdGVJbmZvLCBiaW5kaW5nLCBwYXJ0LCBpbmRleCkge1xuICAgIGlmICghcGFydC5saXRlcmFsKSB7XG4gICAgICBpZiAoYmluZGluZy5raW5kID09PSAnYXR0cmlidXRlJyAmJiBiaW5kaW5nLnRhcmdldFswXSA9PT0gJy0nKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignQ2Fubm90IHNldCBhdHRyaWJ1dGUgJyArIGJpbmRpbmcudGFyZ2V0ICtcbiAgICAgICAgICAnIGJlY2F1c2UgXCItXCIgaXMgbm90IGEgdmFsaWQgYXR0cmlidXRlIHN0YXJ0aW5nIGNoYXJhY3RlcicpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IGRlcGVuZGVuY2llcyA9IHBhcnQuZGVwZW5kZW5jaWVzO1xuICAgICAgICBsZXQgaW5mbyA9IHsgaW5kZXgsIGJpbmRpbmcsIHBhcnQsIGV2YWx1YXRvcjogY29uc3RydWN0b3IgfTtcbiAgICAgICAgZm9yIChsZXQgaj0wOyBqPGRlcGVuZGVuY2llcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGxldCB0cmlnZ2VyID0gZGVwZW5kZW5jaWVzW2pdO1xuICAgICAgICAgIGlmICh0eXBlb2YgdHJpZ2dlciA9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdHJpZ2dlciA9IHBhcnNlQXJnKHRyaWdnZXIpO1xuICAgICAgICAgICAgdHJpZ2dlci53aWxkY2FyZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0cnVjdG9yLl9hZGRUZW1wbGF0ZVByb3BlcnR5RWZmZWN0KHRlbXBsYXRlSW5mbywgdHJpZ2dlci5yb290UHJvcGVydHksIHtcbiAgICAgICAgICAgIGZuOiBydW5CaW5kaW5nRWZmZWN0LFxuICAgICAgICAgICAgaW5mbywgdHJpZ2dlclxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEltcGxlbWVudHMgdGhlIFwiYmluZGluZ1wiIChwcm9wZXJ0eS9wYXRoIGJpbmRpbmcpIGVmZmVjdC5cbiAgICpcbiAgICogTm90ZSB0aGF0IGJpbmRpbmcgc3ludGF4IGlzIG92ZXJyaWRhYmxlIHZpYSBgX3BhcnNlQmluZGluZ3NgIGFuZFxuICAgKiBgX2V2YWx1YXRlQmluZGluZ2AuICBUaGlzIG1ldGhvZCB3aWxsIGNhbGwgYF9ldmFsdWF0ZUJpbmRpbmdgIGZvciBhbnlcbiAgICogbm9uLWxpdGVyYWwgcGFydHMgcmV0dXJuZWQgZnJvbSBgX3BhcnNlQmluZGluZ3NgLiAgSG93ZXZlcixcbiAgICogdGhlcmUgaXMgbm8gc3VwcG9ydCBmb3IgX3BhdGhfIGJpbmRpbmdzIHZpYSBjdXN0b20gYmluZGluZyBwYXJ0cyxcbiAgICogYXMgdGhpcyBpcyBzcGVjaWZpYyB0byBQb2x5bWVyJ3MgcGF0aCBiaW5kaW5nIHN5bnRheC5cbiAgICpcbiAgICogQHBhcmFtIHshUHJvcGVydHlFZmZlY3RzVHlwZX0gaW5zdCBUaGUgaW5zdGFuY2UgdGhlIGVmZmVjdCB3aWxsIGJlIHJ1biBvblxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBOYW1lIG9mIHByb3BlcnR5XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBCYWcgb2YgY3VycmVudCBwcm9wZXJ0eSBjaGFuZ2VzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvbGRQcm9wcyBCYWcgb2YgcHJldmlvdXMgdmFsdWVzIGZvciBjaGFuZ2VkIHByb3BlcnRpZXNcbiAgICogQHBhcmFtIHs/fSBpbmZvIEVmZmVjdCBtZXRhZGF0YVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhhc1BhdGhzIFRydWUgd2l0aCBgcHJvcHNgIGNvbnRhaW5zIG9uZSBvciBtb3JlIHBhdGhzXG4gICAqIEBwYXJhbSB7QXJyYXl9IG5vZGVMaXN0IExpc3Qgb2Ygbm9kZXMgYXNzb2NpYXRlZCB3aXRoIGBub2RlSW5mb0xpc3RgIHRlbXBsYXRlXG4gICAqICAgbWV0YWRhdGFcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIHJ1bkJpbmRpbmdFZmZlY3QoaW5zdCwgcGF0aCwgcHJvcHMsIG9sZFByb3BzLCBpbmZvLCBoYXNQYXRocywgbm9kZUxpc3QpIHtcbiAgICBsZXQgbm9kZSA9IG5vZGVMaXN0W2luZm8uaW5kZXhdO1xuICAgIGxldCBiaW5kaW5nID0gaW5mby5iaW5kaW5nO1xuICAgIGxldCBwYXJ0ID0gaW5mby5wYXJ0O1xuICAgIC8vIFN1YnBhdGggbm90aWZpY2F0aW9uOiB0cmFuc2Zvcm0gcGF0aCBhbmQgc2V0IHRvIGNsaWVudFxuICAgIC8vIGUuZy46IGZvbz1cInt7b2JqLnN1Yn19XCIsIHBhdGg6ICdvYmouc3ViLnByb3AnLCBzZXQgJ2Zvby5wcm9wJz1vYmouc3ViLnByb3BcbiAgICBpZiAoaGFzUGF0aHMgJiYgcGFydC5zb3VyY2UgJiYgKHBhdGgubGVuZ3RoID4gcGFydC5zb3VyY2UubGVuZ3RoKSAmJlxuICAgICAgICAoYmluZGluZy5raW5kID09ICdwcm9wZXJ0eScpICYmICFiaW5kaW5nLmlzQ29tcG91bmQgJiZcbiAgICAgICAgbm9kZS5fX2RhdGFIYXNBY2Nlc3NvciAmJiBub2RlLl9fZGF0YUhhc0FjY2Vzc29yW2JpbmRpbmcudGFyZ2V0XSkge1xuICAgICAgbGV0IHZhbHVlID0gcHJvcHNbcGF0aF07XG4gICAgICBwYXRoID0gUG9seW1lci5QYXRoLnRyYW5zbGF0ZShwYXJ0LnNvdXJjZSwgYmluZGluZy50YXJnZXQsIHBhdGgpO1xuICAgICAgaWYgKG5vZGUuX3NldFBlbmRpbmdQcm9wZXJ0eU9yUGF0aChwYXRoLCB2YWx1ZSwgZmFsc2UsIHRydWUpKSB7XG4gICAgICAgIGluc3QuX2VucXVldWVDbGllbnQobm9kZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCB2YWx1ZSA9IGluZm8uZXZhbHVhdG9yLl9ldmFsdWF0ZUJpbmRpbmcoaW5zdCwgcGFydCwgcGF0aCwgcHJvcHMsIG9sZFByb3BzLCBoYXNQYXRocyk7XG4gICAgICAvLyBQcm9wYWdhdGUgdmFsdWUgdG8gY2hpbGRcbiAgICAgIGFwcGx5QmluZGluZ1ZhbHVlKGluc3QsIG5vZGUsIGJpbmRpbmcsIHBhcnQsIHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgdmFsdWUgZm9yIGFuIFwiYmluZGluZ1wiIChiaW5kaW5nKSBlZmZlY3QgdG8gYSBub2RlLFxuICAgKiBlaXRoZXIgYXMgYSBwcm9wZXJ0eSBvciBhdHRyaWJ1dGUuXG4gICAqXG4gICAqIEBwYXJhbSB7IVByb3BlcnR5RWZmZWN0c1R5cGV9IGluc3QgVGhlIGluc3RhbmNlIG93bmluZyB0aGUgYmluZGluZyBlZmZlY3RcbiAgICogQHBhcmFtIHtOb2RlfSBub2RlIFRhcmdldCBub2RlIGZvciBiaW5kaW5nXG4gICAqIEBwYXJhbSB7IUJpbmRpbmd9IGJpbmRpbmcgQmluZGluZyBtZXRhZGF0YVxuICAgKiBAcGFyYW0geyFCaW5kaW5nUGFydH0gcGFydCBCaW5kaW5nIHBhcnQgbWV0YWRhdGFcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byBzZXRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIGFwcGx5QmluZGluZ1ZhbHVlKGluc3QsIG5vZGUsIGJpbmRpbmcsIHBhcnQsIHZhbHVlKSB7XG4gICAgdmFsdWUgPSBjb21wdXRlQmluZGluZ1ZhbHVlKG5vZGUsIHZhbHVlLCBiaW5kaW5nLCBwYXJ0KTtcbiAgICBpZiAoUG9seW1lci5zYW5pdGl6ZURPTVZhbHVlKSB7XG4gICAgICB2YWx1ZSA9IFBvbHltZXIuc2FuaXRpemVET01WYWx1ZSh2YWx1ZSwgYmluZGluZy50YXJnZXQsIGJpbmRpbmcua2luZCwgbm9kZSk7XG4gICAgfVxuICAgIGlmIChiaW5kaW5nLmtpbmQgPT0gJ2F0dHJpYnV0ZScpIHtcbiAgICAgIC8vIEF0dHJpYnV0ZSBiaW5kaW5nXG4gICAgICBpbnN0Ll92YWx1ZVRvTm9kZUF0dHJpYnV0ZSgvKiogQHR5cGUge0VsZW1lbnR9ICovKG5vZGUpLCB2YWx1ZSwgYmluZGluZy50YXJnZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBQcm9wZXJ0eSBiaW5kaW5nXG4gICAgICBsZXQgcHJvcCA9IGJpbmRpbmcudGFyZ2V0O1xuICAgICAgaWYgKG5vZGUuX19kYXRhSGFzQWNjZXNzb3IgJiYgbm9kZS5fX2RhdGFIYXNBY2Nlc3Nvcltwcm9wXSkge1xuICAgICAgICBpZiAoIW5vZGVbVFlQRVMuUkVBRF9PTkxZXSB8fCAhbm9kZVtUWVBFUy5SRUFEX09OTFldW3Byb3BdKSB7XG4gICAgICAgICAgaWYgKG5vZGUuX3NldFBlbmRpbmdQcm9wZXJ0eShwcm9wLCB2YWx1ZSkpIHtcbiAgICAgICAgICAgIGluc3QuX2VucXVldWVDbGllbnQobm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgIHtcbiAgICAgICAgaW5zdC5fc2V0VW5tYW5hZ2VkUHJvcGVydHlUb05vZGUobm9kZSwgcHJvcCwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUcmFuc2Zvcm1zIGFuIFwiYmluZGluZ1wiIGVmZmVjdCB2YWx1ZSBiYXNlZCBvbiBjb21wb3VuZCAmIG5lZ2F0aW9uXG4gICAqIGVmZmVjdCBtZXRhZGF0YSwgYXMgd2VsbCBhcyBoYW5kbGluZyBmb3Igc3BlY2lhbC1jYXNlIHByb3BlcnRpZXNcbiAgICpcbiAgICogQHBhcmFtIHtOb2RlfSBub2RlIE5vZGUgdGhlIHZhbHVlIHdpbGwgYmUgc2V0IHRvXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgdG8gc2V0XG4gICAqIEBwYXJhbSB7IUJpbmRpbmd9IGJpbmRpbmcgQmluZGluZyBtZXRhZGF0YVxuICAgKiBAcGFyYW0geyFCaW5kaW5nUGFydH0gcGFydCBCaW5kaW5nIHBhcnQgbWV0YWRhdGFcbiAgICogQHJldHVybiB7Kn0gVHJhbnNmb3JtZWQgdmFsdWUgdG8gc2V0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBjb21wdXRlQmluZGluZ1ZhbHVlKG5vZGUsIHZhbHVlLCBiaW5kaW5nLCBwYXJ0KSB7XG4gICAgaWYgKGJpbmRpbmcuaXNDb21wb3VuZCkge1xuICAgICAgbGV0IHN0b3JhZ2UgPSBub2RlLl9fZGF0YUNvbXBvdW5kU3RvcmFnZVtiaW5kaW5nLnRhcmdldF07XG4gICAgICBzdG9yYWdlW3BhcnQuY29tcG91bmRJbmRleF0gPSB2YWx1ZTtcbiAgICAgIHZhbHVlID0gc3RvcmFnZS5qb2luKCcnKTtcbiAgICB9XG4gICAgaWYgKGJpbmRpbmcua2luZCAhPT0gJ2F0dHJpYnV0ZScpIHtcbiAgICAgIC8vIFNvbWUgYnJvd3NlcnMgc2VyaWFsaXplIGB1bmRlZmluZWRgIHRvIGBcInVuZGVmaW5lZFwiYFxuICAgICAgaWYgKGJpbmRpbmcudGFyZ2V0ID09PSAndGV4dENvbnRlbnQnIHx8XG4gICAgICAgICAgKG5vZGUubG9jYWxOYW1lID09ICdpbnB1dCcgJiYgYmluZGluZy50YXJnZXQgPT0gJ3ZhbHVlJykpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZSA9PSB1bmRlZmluZWQgPyAnJyA6IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIGEgYmluZGluZydzIG1ldGFkYXRhIG1lZXRzIGFsbCB0aGUgcmVxdWlyZW1lbnRzIHRvIGFsbG93XG4gICAqIDItd2F5IGJpbmRpbmcsIGFuZCB0aGVyZWZvcmUgYSBgPHByb3BlcnR5Pi1jaGFuZ2VkYCBldmVudCBsaXN0ZW5lciBzaG91bGQgYmVcbiAgICogYWRkZWQ6XG4gICAqIC0gdXNlZCBjdXJseSBicmFjZXNcbiAgICogLSBpcyBhIHByb3BlcnR5IChub3QgYXR0cmlidXRlKSBiaW5kaW5nXG4gICAqIC0gaXMgbm90IGEgdGV4dENvbnRlbnQgYmluZGluZ1xuICAgKiAtIGlzIG5vdCBjb21wb3VuZFxuICAgKlxuICAgKiBAcGFyYW0geyFCaW5kaW5nfSBiaW5kaW5nIEJpbmRpbmcgbWV0YWRhdGFcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiAyLXdheSBsaXN0ZW5lciBzaG91bGQgYmUgYWRkZWRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIHNob3VsZEFkZExpc3RlbmVyKGJpbmRpbmcpIHtcbiAgICByZXR1cm4gQm9vbGVhbihiaW5kaW5nLnRhcmdldCkgJiZcbiAgICAgICAgICAgYmluZGluZy5raW5kICE9ICdhdHRyaWJ1dGUnICYmXG4gICAgICAgICAgIGJpbmRpbmcua2luZCAhPSAndGV4dCcgJiZcbiAgICAgICAgICAgIWJpbmRpbmcuaXNDb21wb3VuZCAmJlxuICAgICAgICAgICBiaW5kaW5nLnBhcnRzWzBdLm1vZGUgPT09ICd7JztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXR1cCBjb21wb3VuZCBiaW5kaW5nIHN0b3JhZ2Ugc3RydWN0dXJlcywgbm90aWZ5IGxpc3RlbmVycywgYW5kIGRhdGFIb3N0XG4gICAqIHJlZmVyZW5jZXMgb250byB0aGUgYm91bmQgbm9kZUxpc3QuXG4gICAqXG4gICAqIEBwYXJhbSB7IVByb3BlcnR5RWZmZWN0c1R5cGV9IGluc3QgSW5zdGFuY2UgdGhhdCBiYXMgYmVlbiBwcmV2aW91c2x5IGJvdW5kXG4gICAqIEBwYXJhbSB7VGVtcGxhdGVJbmZvfSB0ZW1wbGF0ZUluZm8gVGVtcGxhdGUgbWV0YWRhdGFcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIHNldHVwQmluZGluZ3MoaW5zdCwgdGVtcGxhdGVJbmZvKSB7XG4gICAgLy8gU2V0dXAgY29tcG91bmQgc3RvcmFnZSwgZGF0YUhvc3QsIGFuZCBub3RpZnkgbGlzdGVuZXJzXG4gICAgbGV0IHtub2RlTGlzdCwgbm9kZUluZm9MaXN0fSA9IHRlbXBsYXRlSW5mbztcbiAgICBpZiAobm9kZUluZm9MaXN0Lmxlbmd0aCkge1xuICAgICAgZm9yIChsZXQgaT0wOyBpIDwgbm9kZUluZm9MaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBpbmZvID0gbm9kZUluZm9MaXN0W2ldO1xuICAgICAgICBsZXQgbm9kZSA9IG5vZGVMaXN0W2ldO1xuICAgICAgICBsZXQgYmluZGluZ3MgPSBpbmZvLmJpbmRpbmdzO1xuICAgICAgICBpZiAoYmluZGluZ3MpIHtcbiAgICAgICAgICBmb3IgKGxldCBpPTA7IGk8YmluZGluZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBiaW5kaW5nID0gYmluZGluZ3NbaV07XG4gICAgICAgICAgICBzZXR1cENvbXBvdW5kU3RvcmFnZShub2RlLCBiaW5kaW5nKTtcbiAgICAgICAgICAgIGFkZE5vdGlmeUxpc3RlbmVyKG5vZGUsIGluc3QsIGJpbmRpbmcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBub2RlLl9fZGF0YUhvc3QgPSBpbnN0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyBgX19kYXRhQ29tcG91bmRTdG9yYWdlYCBsb2NhbCBzdG9yYWdlIG9uIGEgYm91bmQgbm9kZSB3aXRoXG4gICAqIGluaXRpYWwgbGl0ZXJhbCBkYXRhIGZvciBjb21wb3VuZCBiaW5kaW5ncywgYW5kIHNldHMgdGhlIGpvaW5lZFxuICAgKiBsaXRlcmFsIHBhcnRzIHRvIHRoZSBib3VuZCBwcm9wZXJ0eS5cbiAgICpcbiAgICogV2hlbiBjaGFuZ2VzIHRvIGNvbXBvdW5kIHBhcnRzIG9jY3VyLCB0aGV5IGFyZSBmaXJzdCBzZXQgaW50byB0aGUgY29tcG91bmRcbiAgICogc3RvcmFnZSBhcnJheSBmb3IgdGhhdCBwcm9wZXJ0eSwgYW5kIHRoZW4gdGhlIGFycmF5IGlzIGpvaW5lZCB0byByZXN1bHQgaW5cbiAgICogdGhlIGZpbmFsIHZhbHVlIHNldCB0byB0aGUgcHJvcGVydHkvYXR0cmlidXRlLlxuICAgKlxuICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgQm91bmQgbm9kZSB0byBpbml0aWFsaXplXG4gICAqIEBwYXJhbSB7QmluZGluZ30gYmluZGluZyBCaW5kaW5nIG1ldGFkYXRhXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBzZXR1cENvbXBvdW5kU3RvcmFnZShub2RlLCBiaW5kaW5nKSB7XG4gICAgaWYgKGJpbmRpbmcuaXNDb21wb3VuZCkge1xuICAgICAgLy8gQ3JlYXRlIGNvbXBvdW5kIHN0b3JhZ2UgbWFwXG4gICAgICBsZXQgc3RvcmFnZSA9IG5vZGUuX19kYXRhQ29tcG91bmRTdG9yYWdlIHx8XG4gICAgICAgIChub2RlLl9fZGF0YUNvbXBvdW5kU3RvcmFnZSA9IHt9KTtcbiAgICAgIGxldCBwYXJ0cyA9IGJpbmRpbmcucGFydHM7XG4gICAgICAvLyBDb3B5IGxpdGVyYWxzIGZyb20gcGFydHMgaW50byBzdG9yYWdlIGZvciB0aGlzIGJpbmRpbmdcbiAgICAgIGxldCBsaXRlcmFscyA9IG5ldyBBcnJheShwYXJ0cy5sZW5ndGgpO1xuICAgICAgZm9yIChsZXQgaj0wOyBqPHBhcnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGxpdGVyYWxzW2pdID0gcGFydHNbal0ubGl0ZXJhbDtcbiAgICAgIH1cbiAgICAgIGxldCB0YXJnZXQgPSBiaW5kaW5nLnRhcmdldDtcbiAgICAgIHN0b3JhZ2VbdGFyZ2V0XSA9IGxpdGVyYWxzO1xuICAgICAgLy8gQ29uZmlndXJlIHByb3BlcnRpZXMgd2l0aCB0aGVpciBsaXRlcmFsIHBhcnRzXG4gICAgICBpZiAoYmluZGluZy5saXRlcmFsICYmIGJpbmRpbmcua2luZCA9PSAncHJvcGVydHknKSB7XG4gICAgICAgIG5vZGVbdGFyZ2V0XSA9IGJpbmRpbmcubGl0ZXJhbDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhIDItd2F5IGJpbmRpbmcgbm90aWZpY2F0aW9uIGV2ZW50IGxpc3RlbmVyIHRvIHRoZSBub2RlIHNwZWNpZmllZFxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gbm9kZSBDaGlsZCBlbGVtZW50IHRvIGFkZCBsaXN0ZW5lciB0b1xuICAgKiBAcGFyYW0geyFQcm9wZXJ0eUVmZmVjdHNUeXBlfSBpbnN0IEhvc3QgZWxlbWVudCBpbnN0YW5jZSB0byBoYW5kbGUgbm90aWZpY2F0aW9uIGV2ZW50XG4gICAqIEBwYXJhbSB7QmluZGluZ30gYmluZGluZyBCaW5kaW5nIG1ldGFkYXRhXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBhZGROb3RpZnlMaXN0ZW5lcihub2RlLCBpbnN0LCBiaW5kaW5nKSB7XG4gICAgaWYgKGJpbmRpbmcubGlzdGVuZXJFdmVudCkge1xuICAgICAgbGV0IHBhcnQgPSBiaW5kaW5nLnBhcnRzWzBdO1xuICAgICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKGJpbmRpbmcubGlzdGVuZXJFdmVudCwgZnVuY3Rpb24oZSkge1xuICAgICAgICBoYW5kbGVOb3RpZmljYXRpb24oZSwgaW5zdCwgYmluZGluZy50YXJnZXQsIHBhcnQuc291cmNlLCBwYXJ0Lm5lZ2F0ZSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvLyAtLSBmb3IgbWV0aG9kLWJhc2VkIGVmZmVjdHMgKGNvbXBsZXhPYnNlcnZlciAmIGNvbXB1dGVkKSAtLS0tLS0tLS0tLS0tLVxuXG4gIC8qKlxuICAgKiBBZGRzIHByb3BlcnR5IGVmZmVjdHMgZm9yIGVhY2ggYXJndW1lbnQgaW4gdGhlIG1ldGhvZCBzaWduYXR1cmUgKGFuZFxuICAgKiBvcHRpb25hbGx5LCBmb3IgdGhlIG1ldGhvZCBuYW1lIGlmIGBkeW5hbWljYCBpcyB0cnVlKSB0aGF0IGNhbGxzIHRoZVxuICAgKiBwcm92aWRlZCBlZmZlY3QgZnVuY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7RWxlbWVudCB8IE9iamVjdH0gbW9kZWwgUHJvdG90eXBlIG9yIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7IU1ldGhvZFNpZ25hdHVyZX0gc2lnIE1ldGhvZCBzaWduYXR1cmUgbWV0YWRhdGFcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgVHlwZSBvZiBwcm9wZXJ0eSBlZmZlY3QgdG8gYWRkXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGVmZmVjdEZuIEZ1bmN0aW9uIHRvIHJ1biB3aGVuIGFyZ3VtZW50cyBjaGFuZ2VcbiAgICogQHBhcmFtIHsqPX0gbWV0aG9kSW5mbyBFZmZlY3Qtc3BlY2lmaWMgaW5mb3JtYXRpb24gdG8gYmUgaW5jbHVkZWQgaW5cbiAgICogICBtZXRob2QgZWZmZWN0IG1ldGFkYXRhXG4gICAqIEBwYXJhbSB7Ym9vbGVhbnxPYmplY3Q9fSBkeW5hbWljRm4gQm9vbGVhbiBvciBvYmplY3QgbWFwIGluZGljYXRpbmcgd2hldGhlclxuICAgKiAgIG1ldGhvZCBuYW1lcyBzaG91bGQgYmUgaW5jbHVkZWQgYXMgYSBkZXBlbmRlbmN5IHRvIHRoZSBlZmZlY3QuIE5vdGUsXG4gICAqICAgZGVmYXVsdHMgdG8gdHJ1ZSBpZiB0aGUgc2lnbmF0dXJlIGlzIHN0YXRpYyAoc2lnLnN0YXRpYyBpcyB0cnVlKS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIGNyZWF0ZU1ldGhvZEVmZmVjdChtb2RlbCwgc2lnLCB0eXBlLCBlZmZlY3RGbiwgbWV0aG9kSW5mbywgZHluYW1pY0ZuKSB7XG4gICAgZHluYW1pY0ZuID0gc2lnLnN0YXRpYyB8fCAoZHluYW1pY0ZuICYmXG4gICAgICAodHlwZW9mIGR5bmFtaWNGbiAhPT0gJ29iamVjdCcgfHwgZHluYW1pY0ZuW3NpZy5tZXRob2ROYW1lXSkpO1xuICAgIGxldCBpbmZvID0ge1xuICAgICAgbWV0aG9kTmFtZTogc2lnLm1ldGhvZE5hbWUsXG4gICAgICBhcmdzOiBzaWcuYXJncyxcbiAgICAgIG1ldGhvZEluZm8sXG4gICAgICBkeW5hbWljRm5cbiAgICB9O1xuICAgIGZvciAobGV0IGk9MCwgYXJnOyAoaTxzaWcuYXJncy5sZW5ndGgpICYmIChhcmc9c2lnLmFyZ3NbaV0pOyBpKyspIHtcbiAgICAgIGlmICghYXJnLmxpdGVyYWwpIHtcbiAgICAgICAgbW9kZWwuX2FkZFByb3BlcnR5RWZmZWN0KGFyZy5yb290UHJvcGVydHksIHR5cGUsIHtcbiAgICAgICAgICBmbjogZWZmZWN0Rm4sIGluZm86IGluZm8sIHRyaWdnZXI6IGFyZ1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGR5bmFtaWNGbikge1xuICAgICAgbW9kZWwuX2FkZFByb3BlcnR5RWZmZWN0KHNpZy5tZXRob2ROYW1lLCB0eXBlLCB7XG4gICAgICAgIGZuOiBlZmZlY3RGbiwgaW5mbzogaW5mb1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENhbGxzIGEgbWV0aG9kIHdpdGggYXJndW1lbnRzIG1hcnNoYWxlZCBmcm9tIHByb3BlcnRpZXMgb24gdGhlIGluc3RhbmNlXG4gICAqIGJhc2VkIG9uIHRoZSBtZXRob2Qgc2lnbmF0dXJlIGNvbnRhaW5lZCBpbiB0aGUgZWZmZWN0IG1ldGFkYXRhLlxuICAgKlxuICAgKiBNdWx0aS1wcm9wZXJ0eSBvYnNlcnZlcnMsIGNvbXB1dGVkIHByb3BlcnRpZXMsIGFuZCBpbmxpbmUgY29tcHV0aW5nXG4gICAqIGZ1bmN0aW9ucyBjYWxsIHRoaXMgZnVuY3Rpb24gdG8gaW52b2tlIHRoZSBtZXRob2QsIHRoZW4gdXNlIHRoZSByZXR1cm5cbiAgICogdmFsdWUgYWNjb3JkaW5nbHkuXG4gICAqXG4gICAqIEBwYXJhbSB7IVByb3BlcnR5RWZmZWN0c1R5cGV9IGluc3QgVGhlIGluc3RhbmNlIHRoZSBlZmZlY3Qgd2lsbCBiZSBydW4gb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IE5hbWUgb2YgcHJvcGVydHlcbiAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzIEJhZyBvZiBjdXJyZW50IHByb3BlcnR5IGNoYW5nZXNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9sZFByb3BzIEJhZyBvZiBwcmV2aW91cyB2YWx1ZXMgZm9yIGNoYW5nZWQgcHJvcGVydGllc1xuICAgKiBAcGFyYW0gez99IGluZm8gRWZmZWN0IG1ldGFkYXRhXG4gICAqIEByZXR1cm4geyp9IFJldHVybnMgdGhlIHJldHVybiB2YWx1ZSBmcm9tIHRoZSBtZXRob2QgaW52b2NhdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gcnVuTWV0aG9kRWZmZWN0KGluc3QsIHByb3BlcnR5LCBwcm9wcywgb2xkUHJvcHMsIGluZm8pIHtcbiAgICAvLyBJbnN0YW5jZXMgY2FuIG9wdGlvbmFsbHkgaGF2ZSBhIF9tZXRob2RIb3N0IHdoaWNoIGFsbG93cyByZWRpcmVjdGluZyB3aGVyZVxuICAgIC8vIHRvIGZpbmQgbWV0aG9kcy4gQ3VycmVudGx5IHVzZWQgYnkgYHRlbXBsYXRpemVgLlxuICAgIGxldCBjb250ZXh0ID0gaW5zdC5fbWV0aG9kSG9zdCB8fCBpbnN0O1xuICAgIGxldCBmbiA9IGNvbnRleHRbaW5mby5tZXRob2ROYW1lXTtcbiAgICBpZiAoZm4pIHtcbiAgICAgIGxldCBhcmdzID0gbWFyc2hhbEFyZ3MoaW5zdC5fX2RhdGEsIGluZm8uYXJncywgcHJvcGVydHksIHByb3BzKTtcbiAgICAgIHJldHVybiBmbi5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICB9IGVsc2UgaWYgKCFpbmZvLmR5bmFtaWNGbikge1xuICAgICAgY29uc29sZS53YXJuKCdtZXRob2QgYCcgKyBpbmZvLm1ldGhvZE5hbWUgKyAnYCBub3QgZGVmaW5lZCcpO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGVtcHR5QXJyYXkgPSBbXTtcblxuICAvLyBSZWd1bGFyIGV4cHJlc3Npb25zIHVzZWQgZm9yIGJpbmRpbmdcbiAgY29uc3QgSURFTlQgID0gJyg/OicgKyAnW2EtekEtWl8kXVtcXFxcdy46JFxcXFwtKl0qJyArICcpJztcbiAgY29uc3QgTlVNQkVSID0gJyg/OicgKyAnWy0rXT9bMC05XSpcXFxcLj9bMC05XSsoPzpbZUVdWy0rXT9bMC05XSspPycgKyAnKSc7XG4gIGNvbnN0IFNRVU9URV9TVFJJTkcgPSAnKD86JyArICdcXCcoPzpbXlxcJ1xcXFxcXFxcXXxcXFxcXFxcXC4pKlxcJycgKyAnKSc7XG4gIGNvbnN0IERRVU9URV9TVFJJTkcgPSAnKD86JyArICdcIig/OlteXCJcXFxcXFxcXF18XFxcXFxcXFwuKSpcIicgKyAnKSc7XG4gIGNvbnN0IFNUUklORyA9ICcoPzonICsgU1FVT1RFX1NUUklORyArICd8JyArIERRVU9URV9TVFJJTkcgKyAnKSc7XG4gIGNvbnN0IEFSR1VNRU5UID0gJyg/OignICsgSURFTlQgKyAnfCcgKyBOVU1CRVIgKyAnfCcgKyAgU1RSSU5HICsgJylcXFxccyonICsgJyknO1xuICBjb25zdCBBUkdVTUVOVFMgPSAnKD86JyArIEFSR1VNRU5UICsgJyg/OixcXFxccyonICsgQVJHVU1FTlQgKyAnKSonICsgJyknO1xuICBjb25zdCBBUkdVTUVOVF9MSVNUID0gJyg/OicgKyAnXFxcXChcXFxccyonICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyg/OicgKyBBUkdVTUVOVFMgKyAnPycgKyAnKScgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1xcXFwpXFxcXHMqJyArICcpJztcbiAgY29uc3QgQklORElORyA9ICcoJyArIElERU5UICsgJ1xcXFxzKicgKyBBUkdVTUVOVF9MSVNUICsgJz8nICsgJyknOyAvLyBHcm91cCAzXG4gIGNvbnN0IE9QRU5fQlJBQ0tFVCA9ICcoXFxcXFtcXFxcW3x7eyknICsgJ1xcXFxzKic7XG4gIGNvbnN0IENMT1NFX0JSQUNLRVQgPSAnKD86XV18fX0pJztcbiAgY29uc3QgTkVHQVRFID0gJyg/OighKVxcXFxzKik/JzsgLy8gR3JvdXAgMlxuICBjb25zdCBFWFBSRVNTSU9OID0gT1BFTl9CUkFDS0VUICsgTkVHQVRFICsgQklORElORyArIENMT1NFX0JSQUNLRVQ7XG4gIGNvbnN0IGJpbmRpbmdSZWdleCA9IG5ldyBSZWdFeHAoRVhQUkVTU0lPTiwgXCJnXCIpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBzdHJpbmcgZnJvbSBiaW5kaW5nIHBhcnRzIG9mIGFsbCB0aGUgbGl0ZXJhbCBwYXJ0c1xuICAgKlxuICAgKiBAcGFyYW0geyFBcnJheTxCaW5kaW5nUGFydD59IHBhcnRzIEFsbCBwYXJ0cyB0byBzdHJpbmdpZnlcbiAgICogQHJldHVybiB7c3RyaW5nfSBTdHJpbmcgbWFkZSBmcm9tIHRoZSBsaXRlcmFsIHBhcnRzXG4gICAqL1xuICBmdW5jdGlvbiBsaXRlcmFsRnJvbVBhcnRzKHBhcnRzKSB7XG4gICAgbGV0IHMgPSAnJztcbiAgICBmb3IgKGxldCBpPTA7IGk8cGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBsaXRlcmFsID0gcGFydHNbaV0ubGl0ZXJhbDtcbiAgICAgIHMgKz0gbGl0ZXJhbCB8fCAnJztcbiAgICB9XG4gICAgcmV0dXJuIHM7XG4gIH1cblxuICAvKipcbiAgICogUGFyc2VzIGFuIGV4cHJlc3Npb24gc3RyaW5nIGZvciBhIG1ldGhvZCBzaWduYXR1cmUsIGFuZCByZXR1cm5zIGEgbWV0YWRhdGFcbiAgICogZGVzY3JpYmluZyB0aGUgbWV0aG9kIGluIHRlcm1zIG9mIGBtZXRob2ROYW1lYCwgYHN0YXRpY2AgKHdoZXRoZXIgYWxsIHRoZVxuICAgKiBhcmd1bWVudHMgYXJlIGxpdGVyYWxzKSwgYW5kIGFuIGFycmF5IG9mIGBhcmdzYFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXhwcmVzc2lvbiBUaGUgZXhwcmVzc2lvbiB0byBwYXJzZVxuICAgKiBAcmV0dXJuIHs/TWV0aG9kU2lnbmF0dXJlfSBUaGUgbWV0aG9kIG1ldGFkYXRhIG9iamVjdCBpZiBhIG1ldGhvZCBleHByZXNzaW9uIHdhc1xuICAgKiAgIGZvdW5kLCBvdGhlcndpc2UgYHVuZGVmaW5lZGBcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIHBhcnNlTWV0aG9kKGV4cHJlc3Npb24pIHtcbiAgICAvLyB0cmllcyB0byBtYXRjaCB2YWxpZCBqYXZhc2NyaXB0IHByb3BlcnR5IG5hbWVzXG4gICAgbGV0IG0gPSBleHByZXNzaW9uLm1hdGNoKC8oW15cXHNdKz8pXFwoKFtcXHNcXFNdKilcXCkvKTtcbiAgICBpZiAobSkge1xuICAgICAgbGV0IG1ldGhvZE5hbWUgPSBtWzFdO1xuICAgICAgbGV0IHNpZyA9IHsgbWV0aG9kTmFtZSwgc3RhdGljOiB0cnVlLCBhcmdzOiBlbXB0eUFycmF5IH07XG4gICAgICBpZiAobVsyXS50cmltKCkpIHtcbiAgICAgICAgLy8gcmVwbGFjZSBlc2NhcGVkIGNvbW1hcyB3aXRoIGNvbW1hIGVudGl0eSwgc3BsaXQgb24gdW4tZXNjYXBlZCBjb21tYXNcbiAgICAgICAgbGV0IGFyZ3MgPSBtWzJdLnJlcGxhY2UoL1xcXFwsL2csICcmY29tbWE7Jykuc3BsaXQoJywnKTtcbiAgICAgICAgcmV0dXJuIHBhcnNlQXJncyhhcmdzLCBzaWcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHNpZztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcbiAgICogUGFyc2VzIGFuIGFycmF5IG9mIGFyZ3VtZW50cyBhbmQgc2V0cyB0aGUgYGFyZ3NgIHByb3BlcnR5IG9mIHRoZSBzdXBwbGllZFxuICAgKiBzaWduYXR1cmUgbWV0YWRhdGEgb2JqZWN0LiBTZXRzIHRoZSBgc3RhdGljYCBwcm9wZXJ0eSB0byBmYWxzZSBpZiBhbnlcbiAgICogYXJndW1lbnQgaXMgYSBub24tbGl0ZXJhbC5cbiAgICpcbiAgICogQHBhcmFtIHshQXJyYXk8c3RyaW5nPn0gYXJnTGlzdCBBcnJheSBvZiBhcmd1bWVudCBuYW1lc1xuICAgKiBAcGFyYW0geyFNZXRob2RTaWduYXR1cmV9IHNpZyBNZXRob2Qgc2lnbmF0dXJlIG1ldGFkYXRhIG9iamVjdFxuICAgKiBAcmV0dXJuIHshTWV0aG9kU2lnbmF0dXJlfSBUaGUgdXBkYXRlZCBzaWduYXR1cmUgbWV0YWRhdGEgb2JqZWN0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBwYXJzZUFyZ3MoYXJnTGlzdCwgc2lnKSB7XG4gICAgc2lnLmFyZ3MgPSBhcmdMaXN0Lm1hcChmdW5jdGlvbihyYXdBcmcpIHtcbiAgICAgIGxldCBhcmcgPSBwYXJzZUFyZyhyYXdBcmcpO1xuICAgICAgaWYgKCFhcmcubGl0ZXJhbCkge1xuICAgICAgICBzaWcuc3RhdGljID0gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJnO1xuICAgIH0sIHRoaXMpO1xuICAgIHJldHVybiBzaWc7XG4gIH1cblxuICAvKipcbiAgICogUGFyc2VzIGFuIGluZGl2aWR1YWwgYXJndW1lbnQsIGFuZCByZXR1cm5zIGFuIGFyZ3VtZW50IG1ldGFkYXRhIG9iamVjdFxuICAgKiB3aXRoIHRoZSBmb2xsb3dpbmcgZmllbGRzOlxuICAgKlxuICAgKiAgIHtcbiAgICogICAgIHZhbHVlOiAncHJvcCcsICAgICAgICAvLyBwcm9wZXJ0eS9wYXRoIG9yIGxpdGVyYWwgdmFsdWVcbiAgICogICAgIGxpdGVyYWw6IGZhbHNlLCAgICAgICAvLyB3aGV0aGVyIGFyZ3VtZW50IGlzIGEgbGl0ZXJhbFxuICAgKiAgICAgc3RydWN0dXJlZDogZmFsc2UsICAgIC8vIHdoZXRoZXIgdGhlIHByb3BlcnR5IGlzIGEgcGF0aFxuICAgKiAgICAgcm9vdFByb3BlcnR5OiAncHJvcCcsIC8vIHRoZSByb290IHByb3BlcnR5IG9mIHRoZSBwYXRoXG4gICAqICAgICB3aWxkY2FyZDogZmFsc2UgICAgICAgLy8gd2hldGhlciB0aGUgYXJndW1lbnQgd2FzIGEgd2lsZGNhcmQgJy4qJyBwYXRoXG4gICAqICAgfVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmF3QXJnIFRoZSBzdHJpbmcgdmFsdWUgb2YgdGhlIGFyZ3VtZW50XG4gICAqIEByZXR1cm4geyFNZXRob2RBcmd9IEFyZ3VtZW50IG1ldGFkYXRhIG9iamVjdFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gcGFyc2VBcmcocmF3QXJnKSB7XG4gICAgLy8gY2xlYW4gdXAgd2hpdGVzcGFjZVxuICAgIGxldCBhcmcgPSByYXdBcmcudHJpbSgpXG4gICAgICAvLyByZXBsYWNlIGNvbW1hIGVudGl0eSB3aXRoIGNvbW1hXG4gICAgICAucmVwbGFjZSgvJmNvbW1hOy9nLCAnLCcpXG4gICAgICAvLyByZXBhaXIgZXh0cmEgZXNjYXBlIHNlcXVlbmNlczsgbm90ZSBvbmx5IGNvbW1hcyBzdHJpY3RseSBuZWVkXG4gICAgICAvLyBlc2NhcGluZywgYnV0IHdlIGFsbG93IGFueSBvdGhlciBjaGFyIHRvIGJlIGVzY2FwZWQgc2luY2UgaXRzXG4gICAgICAvLyBsaWtlbHkgdXNlcnMgd2lsbCBkbyB0aGlzXG4gICAgICAucmVwbGFjZSgvXFxcXCguKS9nLCAnXFwkMScpXG4gICAgICA7XG4gICAgLy8gYmFzaWMgYXJndW1lbnQgZGVzY3JpcHRvclxuICAgIGxldCBhID0ge1xuICAgICAgbmFtZTogYXJnLFxuICAgICAgdmFsdWU6ICcnLFxuICAgICAgbGl0ZXJhbDogZmFsc2VcbiAgICB9O1xuICAgIC8vIGRldGVjdCBsaXRlcmFsIHZhbHVlIChtdXN0IGJlIFN0cmluZyBvciBOdW1iZXIpXG4gICAgbGV0IGZjID0gYXJnWzBdO1xuICAgIGlmIChmYyA9PT0gJy0nKSB7XG4gICAgICBmYyA9IGFyZ1sxXTtcbiAgICB9XG4gICAgaWYgKGZjID49ICcwJyAmJiBmYyA8PSAnOScpIHtcbiAgICAgIGZjID0gJyMnO1xuICAgIH1cbiAgICBzd2l0Y2goZmMpIHtcbiAgICAgIGNhc2UgXCInXCI6XG4gICAgICBjYXNlICdcIic6XG4gICAgICAgIGEudmFsdWUgPSBhcmcuc2xpY2UoMSwgLTEpO1xuICAgICAgICBhLmxpdGVyYWwgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJyMnOlxuICAgICAgICBhLnZhbHVlID0gTnVtYmVyKGFyZyk7XG4gICAgICAgIGEubGl0ZXJhbCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAvLyBpZiBub3QgbGl0ZXJhbCwgbG9vayBmb3Igc3RydWN0dXJlZCBwYXRoXG4gICAgaWYgKCFhLmxpdGVyYWwpIHtcbiAgICAgIGEucm9vdFByb3BlcnR5ID0gUG9seW1lci5QYXRoLnJvb3QoYXJnKTtcbiAgICAgIC8vIGRldGVjdCBzdHJ1Y3R1cmVkIHBhdGggKGhhcyBkb3RzKVxuICAgICAgYS5zdHJ1Y3R1cmVkID0gUG9seW1lci5QYXRoLmlzUGF0aChhcmcpO1xuICAgICAgaWYgKGEuc3RydWN0dXJlZCkge1xuICAgICAgICBhLndpbGRjYXJkID0gKGFyZy5zbGljZSgtMikgPT0gJy4qJyk7XG4gICAgICAgIGlmIChhLndpbGRjYXJkKSB7XG4gICAgICAgICAgYS5uYW1lID0gYXJnLnNsaWNlKDAsIC0yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHYXRoZXIgdGhlIGFyZ3VtZW50IHZhbHVlcyBmb3IgYSBtZXRob2Qgc3BlY2lmaWVkIGluIHRoZSBwcm92aWRlZCBhcnJheVxuICAgKiBvZiBhcmd1bWVudCBtZXRhZGF0YS5cbiAgICpcbiAgICogVGhlIGBwYXRoYCBhbmQgYHZhbHVlYCBhcmd1bWVudHMgYXJlIHVzZWQgdG8gZmlsbCBpbiB3aWxkY2FyZCBkZXNjcmlwdG9yXG4gICAqIHdoZW4gdGhlIG1ldGhvZCBpcyBiZWluZyBjYWxsZWQgYXMgYSByZXN1bHQgb2YgYSBwYXRoIG5vdGlmaWNhdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgSW5zdGFuY2UgZGF0YSBzdG9yYWdlIG9iamVjdCB0byByZWFkIHByb3BlcnRpZXMgZnJvbVxuICAgKiBAcGFyYW0geyFBcnJheTwhTWV0aG9kQXJnPn0gYXJncyBBcnJheSBvZiBhcmd1bWVudCBtZXRhZGF0YVxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBQcm9wZXJ0eS9wYXRoIG5hbWUgdGhhdCB0cmlnZ2VyZWQgdGhlIG1ldGhvZCBlZmZlY3RcbiAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzIEJhZyBvZiBjdXJyZW50IHByb3BlcnR5IGNoYW5nZXNcbiAgICogQHJldHVybiB7QXJyYXk8Kj59IEFycmF5IG9mIGFyZ3VtZW50IHZhbHVlc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gbWFyc2hhbEFyZ3MoZGF0YSwgYXJncywgcGF0aCwgcHJvcHMpIHtcbiAgICBsZXQgdmFsdWVzID0gW107XG4gICAgZm9yIChsZXQgaT0wLCBsPWFyZ3MubGVuZ3RoOyBpPGw7IGkrKykge1xuICAgICAgbGV0IGFyZyA9IGFyZ3NbaV07XG4gICAgICBsZXQgbmFtZSA9IGFyZy5uYW1lO1xuICAgICAgbGV0IHY7XG4gICAgICBpZiAoYXJnLmxpdGVyYWwpIHtcbiAgICAgICAgdiA9IGFyZy52YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChhcmcuc3RydWN0dXJlZCkge1xuICAgICAgICAgIHYgPSBQb2x5bWVyLlBhdGguZ2V0KGRhdGEsIG5hbWUpO1xuICAgICAgICAgIC8vIHdoZW4gZGF0YSBpcyBub3Qgc3RvcmVkIGUuZy4gYHNwbGljZXNgXG4gICAgICAgICAgaWYgKHYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdiA9IHByb3BzW25hbWVdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2ID0gZGF0YVtuYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGFyZy53aWxkY2FyZCkge1xuICAgICAgICAvLyBPbmx5IHNlbmQgdGhlIGFjdHVhbCBwYXRoIGNoYW5nZWQgaW5mbyBpZiB0aGUgY2hhbmdlIHRoYXRcbiAgICAgICAgLy8gY2F1c2VkIHRoZSBvYnNlcnZlciB0byBydW4gbWF0Y2hlZCB0aGUgd2lsZGNhcmRcbiAgICAgICAgbGV0IGJhc2VDaGFuZ2VkID0gKG5hbWUuaW5kZXhPZihwYXRoICsgJy4nKSA9PT0gMCk7XG4gICAgICAgIGxldCBtYXRjaGVzID0gKHBhdGguaW5kZXhPZihuYW1lKSA9PT0gMCAmJiAhYmFzZUNoYW5nZWQpO1xuICAgICAgICB2YWx1ZXNbaV0gPSB7XG4gICAgICAgICAgcGF0aDogbWF0Y2hlcyA/IHBhdGggOiBuYW1lLFxuICAgICAgICAgIHZhbHVlOiBtYXRjaGVzID8gcHJvcHNbcGF0aF0gOiB2LFxuICAgICAgICAgIGJhc2U6IHZcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlc1tpXSA9IHY7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZXM7XG4gIH1cblxuICAvLyBkYXRhIGFwaVxuXG4gIC8qKlxuICAgKiBTZW5kcyBhcnJheSBzcGxpY2Ugbm90aWZpY2F0aW9ucyAoYC5zcGxpY2VzYCBhbmQgYC5sZW5ndGhgKVxuICAgKlxuICAgKiBOb3RlOiB0aGlzIGltcGxlbWVudGF0aW9uIG9ubHkgYWNjZXB0cyBub3JtYWxpemVkIHBhdGhzXG4gICAqXG4gICAqIEBwYXJhbSB7IVByb3BlcnR5RWZmZWN0c1R5cGV9IGluc3QgSW5zdGFuY2UgdG8gc2VuZCBub3RpZmljYXRpb25zIHRvXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0aGUgbXV0YXRpb25zIG9jY3VycmVkIG9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIHRoZSBhcnJheSB0aGF0IHdhcyBtdXRhdGVkXG4gICAqIEBwYXJhbSB7QXJyYXl9IHNwbGljZXMgQXJyYXkgb2Ygc3BsaWNlIHJlY29yZHNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIG5vdGlmeVNwbGljZXMoaW5zdCwgYXJyYXksIHBhdGgsIHNwbGljZXMpIHtcbiAgICBsZXQgc3BsaWNlc1BhdGggPSBwYXRoICsgJy5zcGxpY2VzJztcbiAgICBpbnN0Lm5vdGlmeVBhdGgoc3BsaWNlc1BhdGgsIHsgaW5kZXhTcGxpY2VzOiBzcGxpY2VzIH0pO1xuICAgIGluc3Qubm90aWZ5UGF0aChwYXRoICsgJy5sZW5ndGgnLCBhcnJheS5sZW5ndGgpO1xuICAgIC8vIE51bGwgaGVyZSB0byBhbGxvdyBwb3RlbnRpYWxseSBsYXJnZSBzcGxpY2UgcmVjb3JkcyB0byBiZSBHQydlZC5cbiAgICBpbnN0Ll9fZGF0YVtzcGxpY2VzUGF0aF0gPSB7aW5kZXhTcGxpY2VzOiBudWxsfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgc3BsaWNlIHJlY29yZCBhbmQgc2VuZHMgYW4gYXJyYXkgc3BsaWNlIG5vdGlmaWNhdGlvbiBmb3JcbiAgICogdGhlIGRlc2NyaWJlZCBtdXRhdGlvblxuICAgKlxuICAgKiBOb3RlOiB0aGlzIGltcGxlbWVudGF0aW9uIG9ubHkgYWNjZXB0cyBub3JtYWxpemVkIHBhdGhzXG4gICAqXG4gICAqIEBwYXJhbSB7IVByb3BlcnR5RWZmZWN0c1R5cGV9IGluc3QgSW5zdGFuY2UgdG8gc2VuZCBub3RpZmljYXRpb25zIHRvXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0aGUgbXV0YXRpb25zIG9jY3VycmVkIG9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIHRoZSBhcnJheSB0aGF0IHdhcyBtdXRhdGVkXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleCBhdCB3aGljaCB0aGUgYXJyYXkgbXV0YXRpb24gb2NjdXJyZWRcbiAgICogQHBhcmFtIHtudW1iZXJ9IGFkZGVkQ291bnQgTnVtYmVyIG9mIGFkZGVkIGl0ZW1zXG4gICAqIEBwYXJhbSB7QXJyYXl9IHJlbW92ZWQgQXJyYXkgb2YgcmVtb3ZlZCBpdGVtc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gbm90aWZ5U3BsaWNlKGluc3QsIGFycmF5LCBwYXRoLCBpbmRleCwgYWRkZWRDb3VudCwgcmVtb3ZlZCkge1xuICAgIG5vdGlmeVNwbGljZXMoaW5zdCwgYXJyYXksIHBhdGgsIFt7XG4gICAgICBpbmRleDogaW5kZXgsXG4gICAgICBhZGRlZENvdW50OiBhZGRlZENvdW50LFxuICAgICAgcmVtb3ZlZDogcmVtb3ZlZCxcbiAgICAgIG9iamVjdDogYXJyYXksXG4gICAgICB0eXBlOiAnc3BsaWNlJ1xuICAgIH1dKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIHVwcGVyLWNhc2VkIHZlcnNpb24gb2YgdGhlIHN0cmluZy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgU3RyaW5nIHRvIHVwcGVyY2FzZVxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFVwcGVyY2FzZWQgc3RyaW5nXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiB1cHBlcihuYW1lKSB7XG4gICAgcmV0dXJuIG5hbWVbMF0udG9VcHBlckNhc2UoKSArIG5hbWUuc3Vic3RyaW5nKDEpO1xuICB9XG5cbiAgLyoqXG4gICAqIEVsZW1lbnQgY2xhc3MgbWl4aW4gdGhhdCBwcm92aWRlcyBtZXRhLXByb2dyYW1taW5nIGZvciBQb2x5bWVyJ3MgdGVtcGxhdGVcbiAgICogYmluZGluZyBhbmQgZGF0YSBvYnNlcnZhdGlvbiAoY29sbGVjdGl2ZWx5LCBcInByb3BlcnR5IGVmZmVjdHNcIikgc3lzdGVtLlxuICAgKlxuICAgKiBUaGlzIG1peGluIHVzZXMgcHJvdmlkZXMgdGhlIGZvbGxvd2luZyBrZXkgc3RhdGljIG1ldGhvZHMgZm9yIGFkZGluZ1xuICAgKiBwcm9wZXJ0eSBlZmZlY3RzIHRvIGFuIGVsZW1lbnQgY2xhc3M6XG4gICAqIC0gYGFkZFByb3BlcnR5RWZmZWN0YFxuICAgKiAtIGBjcmVhdGVQcm9wZXJ0eU9ic2VydmVyYFxuICAgKiAtIGBjcmVhdGVNZXRob2RPYnNlcnZlcmBcbiAgICogLSBgY3JlYXRlTm90aWZ5aW5nUHJvcGVydHlgXG4gICAqIC0gYGNyZWF0ZVJlYWRPbmx5UHJvcGVydHlgXG4gICAqIC0gYGNyZWF0ZVJlZmxlY3RlZFByb3BlcnR5YFxuICAgKiAtIGBjcmVhdGVDb21wdXRlZFByb3BlcnR5YFxuICAgKiAtIGBiaW5kVGVtcGxhdGVgXG4gICAqXG4gICAqIEVhY2ggbWV0aG9kIGNyZWF0ZXMgb25lIG9yIG1vcmUgcHJvcGVydHkgYWNjZXNzb3JzLCBhbG9uZyB3aXRoIG1ldGFkYXRhXG4gICAqIHVzZWQgYnkgdGhpcyBtaXhpbidzIGltcGxlbWVudGF0aW9uIG9mIGBfcHJvcGVydGllc0NoYW5nZWRgIHRvIHBlcmZvcm1cbiAgICogdGhlIHByb3BlcnR5IGVmZmVjdHMuXG4gICAqXG4gICAqIFVuZGVyc2NvcmVkIHZlcnNpb25zIG9mIHRoZSBhYm92ZSBtZXRob2RzIGFsc28gZXhpc3Qgb24gdGhlIGVsZW1lbnRcbiAgICogcHJvdG90eXBlIGZvciBhZGRpbmcgcHJvcGVydHkgZWZmZWN0cyBvbiBpbnN0YW5jZXMgYXQgcnVudGltZS5cbiAgICpcbiAgICogTm90ZSB0aGF0IHRoaXMgbWl4aW4gb3ZlcnJpZGVzIHNldmVyYWwgYFByb3BlcnR5QWNjZXNzb3JzYCBtZXRob2RzLCBpblxuICAgKiBtYW55IGNhc2VzIHRvIG1haW50YWluIGd1YXJhbnRlZXMgcHJvdmlkZWQgYnkgdGhlIFBvbHltZXIgMS54IGZlYXR1cmVzO1xuICAgKiBub3RhYmx5IGl0IGNoYW5nZXMgcHJvcGVydHkgYWNjZXNzb3JzIHRvIGJlIHN5bmNocm9ub3VzIGJ5IGRlZmF1bHRcbiAgICogd2hlcmVhcyB0aGUgZGVmYXVsdCB3aGVuIHVzaW5nIGBQcm9wZXJ0eUFjY2Vzc29yc2Agc3RhbmRhbG9uZSBpcyB0byBiZVxuICAgKiBhc3luYyBieSBkZWZhdWx0LlxuICAgKlxuICAgKiBAbWl4aW5GdW5jdGlvblxuICAgKiBAcG9seW1lclxuICAgKiBAYXBwbGllc01peGluIFBvbHltZXIuVGVtcGxhdGVTdGFtcFxuICAgKiBAYXBwbGllc01peGluIFBvbHltZXIuUHJvcGVydHlBY2Nlc3NvcnNcbiAgICogQG1lbWJlcm9mIFBvbHltZXJcbiAgICogQHN1bW1hcnkgRWxlbWVudCBjbGFzcyBtaXhpbiB0aGF0IHByb3ZpZGVzIG1ldGEtcHJvZ3JhbW1pbmcgZm9yIFBvbHltZXInc1xuICAgKiB0ZW1wbGF0ZSBiaW5kaW5nIGFuZCBkYXRhIG9ic2VydmF0aW9uIHN5c3RlbS5cbiAgICovXG4gIFBvbHltZXIuUHJvcGVydHlFZmZlY3RzID0gUG9seW1lci5kZWR1cGluZ01peGluKHN1cGVyQ2xhc3MgPT4ge1xuXG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQGV4dGVuZHMge3N1cGVyQ2xhc3N9XG4gICAgICogQGltcGxlbWVudHMge1BvbHltZXJfUHJvcGVydHlBY2Nlc3NvcnN9XG4gICAgICogQGltcGxlbWVudHMge1BvbHltZXJfVGVtcGxhdGVTdGFtcH1cbiAgICAgKiBAdW5yZXN0cmljdGVkXG4gICAgICovXG4gICAgY29uc3QgcHJvcGVydHlFZmZlY3RzQmFzZSA9IFBvbHltZXIuVGVtcGxhdGVTdGFtcChQb2x5bWVyLlByb3BlcnR5QWNjZXNzb3JzKHN1cGVyQ2xhc3MpKTtcblxuICAgIC8qKlxuICAgICAqIEBwb2x5bWVyXG4gICAgICogQG1peGluQ2xhc3NcbiAgICAgKiBAaW1wbGVtZW50cyB7UG9seW1lcl9Qcm9wZXJ0eUVmZmVjdHN9XG4gICAgICogQGV4dGVuZHMge3Byb3BlcnR5RWZmZWN0c0Jhc2V9XG4gICAgICogQHVucmVzdHJpY3RlZFxuICAgICAqL1xuICAgIGNsYXNzIFByb3BlcnR5RWZmZWN0cyBleHRlbmRzIHByb3BlcnR5RWZmZWN0c0Jhc2Uge1xuXG4gICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLyoqIEB0eXBlIHtib29sZWFufSAqL1xuICAgICAgICB0aGlzLl9fZGF0YUNsaWVudHNSZWFkeTtcbiAgICAgICAgLyoqIEB0eXBlIHtBcnJheX0gKi9cbiAgICAgICAgdGhpcy5fX2RhdGFQZW5kaW5nQ2xpZW50cztcbiAgICAgICAgLyoqIEB0eXBlIHtPYmplY3R9ICovXG4gICAgICAgIHRoaXMuX19kYXRhVG9Ob3RpZnk7XG4gICAgICAgIC8qKiBAdHlwZSB7T2JqZWN0fSAqL1xuICAgICAgICB0aGlzLl9fZGF0YUxpbmtlZFBhdGhzO1xuICAgICAgICAvKiogQHR5cGUge2Jvb2xlYW59ICovXG4gICAgICAgIHRoaXMuX19kYXRhSGFzUGF0aHM7XG4gICAgICAgIC8qKiBAdHlwZSB7T2JqZWN0fSAqL1xuICAgICAgICB0aGlzLl9fZGF0YUNvbXBvdW5kU3RvcmFnZTtcbiAgICAgICAgLyoqIEB0eXBlIHtQb2x5bWVyX1Byb3BlcnR5RWZmZWN0c30gKi9cbiAgICAgICAgdGhpcy5fX2RhdGFIb3N0O1xuICAgICAgICAvKiogQHR5cGUgeyFPYmplY3R9ICovXG4gICAgICAgIHRoaXMuX19kYXRhVGVtcDtcbiAgICAgICAgLyoqIEB0eXBlIHtib29sZWFufSAqL1xuICAgICAgICB0aGlzLl9fZGF0YUNsaWVudHNJbml0aWFsaXplZDtcbiAgICAgICAgLyoqIEB0eXBlIHshT2JqZWN0fSAqL1xuICAgICAgICB0aGlzLl9fZGF0YTtcbiAgICAgICAgLyoqIEB0eXBlIHshT2JqZWN0fSAqL1xuICAgICAgICB0aGlzLl9fZGF0YVBlbmRpbmc7XG4gICAgICAgIC8qKiBAdHlwZSB7IU9iamVjdH0gKi9cbiAgICAgICAgdGhpcy5fX2RhdGFPbGQ7XG4gICAgICAgIC8qKiBAdHlwZSB7T2JqZWN0fSAqL1xuICAgICAgICB0aGlzLl9fY29tcHV0ZUVmZmVjdHM7XG4gICAgICAgIC8qKiBAdHlwZSB7T2JqZWN0fSAqL1xuICAgICAgICB0aGlzLl9fcmVmbGVjdEVmZmVjdHM7XG4gICAgICAgIC8qKiBAdHlwZSB7T2JqZWN0fSAqL1xuICAgICAgICB0aGlzLl9fbm90aWZ5RWZmZWN0cztcbiAgICAgICAgLyoqIEB0eXBlIHtPYmplY3R9ICovXG4gICAgICAgIHRoaXMuX19wcm9wYWdhdGVFZmZlY3RzO1xuICAgICAgICAvKiogQHR5cGUge09iamVjdH0gKi9cbiAgICAgICAgdGhpcy5fX29ic2VydmVFZmZlY3RzO1xuICAgICAgICAvKiogQHR5cGUge09iamVjdH0gKi9cbiAgICAgICAgdGhpcy5fX3JlYWRPbmx5O1xuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy5fX2RhdGFDb3VudGVyO1xuICAgICAgICAvKiogQHR5cGUgeyFUZW1wbGF0ZUluZm99ICovXG4gICAgICAgIHRoaXMuX190ZW1wbGF0ZUluZm87XG4gICAgICB9XG5cbiAgICAgIGdldCBQUk9QRVJUWV9FRkZFQ1RfVFlQRVMoKSB7XG4gICAgICAgIHJldHVybiBUWVBFUztcbiAgICAgIH1cblxuICAgICAgX2luaXRpYWxpemVQcm9wZXJ0aWVzKCkge1xuICAgICAgICBzdXBlci5faW5pdGlhbGl6ZVByb3BlcnRpZXMoKTtcbiAgICAgICAgaG9zdFN0YWNrLnJlZ2lzdGVySG9zdCh0aGlzKTtcbiAgICAgICAgdGhpcy5fX2RhdGFDbGllbnRzUmVhZHkgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fX2RhdGFQZW5kaW5nQ2xpZW50cyA9IG51bGw7XG4gICAgICAgIHRoaXMuX19kYXRhVG9Ob3RpZnkgPSBudWxsO1xuICAgICAgICB0aGlzLl9fZGF0YUxpbmtlZFBhdGhzID0gbnVsbDtcbiAgICAgICAgdGhpcy5fX2RhdGFIYXNQYXRocyA9IGZhbHNlO1xuICAgICAgICAvLyBNYXkgYmUgc2V0IG9uIGluc3RhbmNlIHByaW9yIHRvIHVwZ3JhZGVcbiAgICAgICAgdGhpcy5fX2RhdGFDb21wb3VuZFN0b3JhZ2UgPSB0aGlzLl9fZGF0YUNvbXBvdW5kU3RvcmFnZSB8fCBudWxsO1xuICAgICAgICB0aGlzLl9fZGF0YUhvc3QgPSB0aGlzLl9fZGF0YUhvc3QgfHwgbnVsbDtcbiAgICAgICAgdGhpcy5fX2RhdGFUZW1wID0ge307XG4gICAgICAgIHRoaXMuX19kYXRhQ2xpZW50c0luaXRpYWxpemVkID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogT3ZlcnJpZGVzIGBQb2x5bWVyLlByb3BlcnR5QWNjZXNzb3JzYCBpbXBsZW1lbnRhdGlvbiB0byBwcm92aWRlIGFcbiAgICAgICAqIG1vcmUgZWZmaWNpZW50IGltcGxlbWVudGF0aW9uIG9mIGluaXRpYWxpemluZyBwcm9wZXJ0aWVzIGZyb21cbiAgICAgICAqIHRoZSBwcm90b3R5cGUgb24gdGhlIGluc3RhbmNlLlxuICAgICAgICpcbiAgICAgICAqIEBvdmVycmlkZVxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzIFByb3BlcnRpZXMgdG8gaW5pdGlhbGl6ZSBvbiB0aGUgcHJvdG90eXBlXG4gICAgICAgKi9cbiAgICAgIF9pbml0aWFsaXplUHJvdG9Qcm9wZXJ0aWVzKHByb3BzKSB7XG4gICAgICAgIHRoaXMuX19kYXRhID0gT2JqZWN0LmNyZWF0ZShwcm9wcyk7XG4gICAgICAgIHRoaXMuX19kYXRhUGVuZGluZyA9IE9iamVjdC5jcmVhdGUocHJvcHMpO1xuICAgICAgICB0aGlzLl9fZGF0YU9sZCA9IHt9O1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIE92ZXJyaWRlcyBgUG9seW1lci5Qcm9wZXJ0eUFjY2Vzc29yc2AgaW1wbGVtZW50YXRpb24gdG8gYXZvaWQgc2V0dGluZ1xuICAgICAgICogYF9zZXRQcm9wZXJ0eWAncyBgc2hvdWxkTm90aWZ5OiB0cnVlYC5cbiAgICAgICAqXG4gICAgICAgKiBAb3ZlcnJpZGVcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBQcm9wZXJ0aWVzIHRvIGluaXRpYWxpemUgb24gdGhlIGluc3RhbmNlXG4gICAgICAgKi9cbiAgICAgIF9pbml0aWFsaXplSW5zdGFuY2VQcm9wZXJ0aWVzKHByb3BzKSB7XG4gICAgICAgIGxldCByZWFkT25seSA9IHRoaXNbVFlQRVMuUkVBRF9PTkxZXTtcbiAgICAgICAgZm9yIChsZXQgcHJvcCBpbiBwcm9wcykge1xuICAgICAgICAgIGlmICghcmVhZE9ubHkgfHwgIXJlYWRPbmx5W3Byb3BdKSB7XG4gICAgICAgICAgICB0aGlzLl9fZGF0YVBlbmRpbmcgPSB0aGlzLl9fZGF0YVBlbmRpbmcgfHwge307XG4gICAgICAgICAgICB0aGlzLl9fZGF0YU9sZCA9IHRoaXMuX19kYXRhT2xkIHx8IHt9O1xuICAgICAgICAgICAgdGhpcy5fX2RhdGFbcHJvcF0gPSB0aGlzLl9fZGF0YVBlbmRpbmdbcHJvcF0gPSBwcm9wc1twcm9wXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gUHJvdG90eXBlIHNldHVwIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgLyoqXG4gICAgICAgKiBFcXVpdmFsZW50IHRvIHN0YXRpYyBgYWRkUHJvcGVydHlFZmZlY3RgIEFQSSBidXQgY2FuIGJlIGNhbGxlZCBvblxuICAgICAgICogYW4gaW5zdGFuY2UgdG8gYWRkIGVmZmVjdHMgYXQgcnVudGltZS4gIFNlZSB0aGF0IG1ldGhvZCBmb3JcbiAgICAgICAqIGZ1bGwgQVBJIGRvY3MuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IHRoYXQgc2hvdWxkIHRyaWdnZXIgdGhlIGVmZmVjdFxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgRWZmZWN0IHR5cGUsIGZyb20gdGhpcy5QUk9QRVJUWV9FRkZFQ1RfVFlQRVNcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0PX0gZWZmZWN0IEVmZmVjdCBtZXRhZGF0YSBvYmplY3RcbiAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAqL1xuICAgICAgX2FkZFByb3BlcnR5RWZmZWN0KHByb3BlcnR5LCB0eXBlLCBlZmZlY3QpIHtcbiAgICAgICAgdGhpcy5fY3JlYXRlUHJvcGVydHlBY2Nlc3Nvcihwcm9wZXJ0eSwgdHlwZSA9PSBUWVBFUy5SRUFEX09OTFkpO1xuICAgICAgICAvLyBlZmZlY3RzIGFyZSBhY2N1bXVsYXRlZCBpbnRvIGFycmF5cyBwZXIgcHJvcGVydHkgYmFzZWQgb24gdHlwZVxuICAgICAgICBsZXQgZWZmZWN0cyA9IGVuc3VyZU93bkVmZmVjdE1hcCh0aGlzLCB0eXBlKVtwcm9wZXJ0eV07XG4gICAgICAgIGlmICghZWZmZWN0cykge1xuICAgICAgICAgIGVmZmVjdHMgPSB0aGlzW3R5cGVdW3Byb3BlcnR5XSA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGVmZmVjdHMucHVzaChlZmZlY3QpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJlbW92ZXMgdGhlIGdpdmVuIHByb3BlcnR5IGVmZmVjdC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgdGhlIGVmZmVjdCB3YXMgYXNzb2NpYXRlZCB3aXRoXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBFZmZlY3QgdHlwZSwgZnJvbSB0aGlzLlBST1BFUlRZX0VGRkVDVF9UWVBFU1xuICAgICAgICogQHBhcmFtIHtPYmplY3Q9fSBlZmZlY3QgRWZmZWN0IG1ldGFkYXRhIG9iamVjdCB0byByZW1vdmVcbiAgICAgICAqL1xuICAgICAgX3JlbW92ZVByb3BlcnR5RWZmZWN0KHByb3BlcnR5LCB0eXBlLCBlZmZlY3QpIHtcbiAgICAgICAgbGV0IGVmZmVjdHMgPSBlbnN1cmVPd25FZmZlY3RNYXAodGhpcywgdHlwZSlbcHJvcGVydHldO1xuICAgICAgICBsZXQgaWR4ID0gZWZmZWN0cy5pbmRleE9mKGVmZmVjdCk7XG4gICAgICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgICAgIGVmZmVjdHMuc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGN1cnJlbnQgcHJvdG90eXBlL2luc3RhbmNlIGhhcyBhIHByb3BlcnR5IGVmZmVjdFxuICAgICAgICogb2YgYSBjZXJ0YWluIHR5cGUuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IG5hbWVcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nPX0gdHlwZSBFZmZlY3QgdHlwZSwgZnJvbSB0aGlzLlBST1BFUlRZX0VGRkVDVF9UWVBFU1xuICAgICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgcHJvdG90eXBlL2luc3RhbmNlIGhhcyBhbiBlZmZlY3Qgb2YgdGhpcyB0eXBlXG4gICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgKi9cbiAgICAgIF9oYXNQcm9wZXJ0eUVmZmVjdChwcm9wZXJ0eSwgdHlwZSkge1xuICAgICAgICBsZXQgZWZmZWN0cyA9IHRoaXNbdHlwZV07XG4gICAgICAgIHJldHVybiBCb29sZWFuKGVmZmVjdHMgJiYgZWZmZWN0c1twcm9wZXJ0eV0pO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgY3VycmVudCBwcm90b3R5cGUvaW5zdGFuY2UgaGFzIGEgXCJyZWFkIG9ubHlcIlxuICAgICAgICogYWNjZXNzb3IgZm9yIHRoZSBnaXZlbiBwcm9wZXJ0eS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgbmFtZVxuICAgICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgcHJvdG90eXBlL2luc3RhbmNlIGhhcyBhbiBlZmZlY3Qgb2YgdGhpcyB0eXBlXG4gICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgKi9cbiAgICAgIF9oYXNSZWFkT25seUVmZmVjdChwcm9wZXJ0eSkge1xuICAgICAgICByZXR1cm4gdGhpcy5faGFzUHJvcGVydHlFZmZlY3QocHJvcGVydHksIFRZUEVTLlJFQURfT05MWSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBjdXJyZW50IHByb3RvdHlwZS9pbnN0YW5jZSBoYXMgYSBcIm5vdGlmeVwiXG4gICAgICAgKiBwcm9wZXJ0eSBlZmZlY3QgZm9yIHRoZSBnaXZlbiBwcm9wZXJ0eS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgbmFtZVxuICAgICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgcHJvdG90eXBlL2luc3RhbmNlIGhhcyBhbiBlZmZlY3Qgb2YgdGhpcyB0eXBlXG4gICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgKi9cbiAgICAgIF9oYXNOb3RpZnlFZmZlY3QocHJvcGVydHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hhc1Byb3BlcnR5RWZmZWN0KHByb3BlcnR5LCBUWVBFUy5OT1RJRlkpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgY3VycmVudCBwcm90b3R5cGUvaW5zdGFuY2UgaGFzIGEgXCJyZWZsZWN0IHRvIGF0dHJpYnV0ZVwiXG4gICAgICAgKiBwcm9wZXJ0eSBlZmZlY3QgZm9yIHRoZSBnaXZlbiBwcm9wZXJ0eS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgbmFtZVxuICAgICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgcHJvdG90eXBlL2luc3RhbmNlIGhhcyBhbiBlZmZlY3Qgb2YgdGhpcyB0eXBlXG4gICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgKi9cbiAgICAgIF9oYXNSZWZsZWN0RWZmZWN0KHByb3BlcnR5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oYXNQcm9wZXJ0eUVmZmVjdChwcm9wZXJ0eSwgVFlQRVMuUkVGTEVDVCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBjdXJyZW50IHByb3RvdHlwZS9pbnN0YW5jZSBoYXMgYSBcImNvbXB1dGVkXCJcbiAgICAgICAqIHByb3BlcnR5IGVmZmVjdCBmb3IgdGhlIGdpdmVuIHByb3BlcnR5LlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSBuYW1lXG4gICAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBwcm90b3R5cGUvaW5zdGFuY2UgaGFzIGFuIGVmZmVjdCBvZiB0aGlzIHR5cGVcbiAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAqL1xuICAgICAgX2hhc0NvbXB1dGVkRWZmZWN0KHByb3BlcnR5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oYXNQcm9wZXJ0eUVmZmVjdChwcm9wZXJ0eSwgVFlQRVMuQ09NUFVURSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFJ1bnRpbWUgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAvKipcbiAgICAgICAqIFNldHMgYSBwZW5kaW5nIHByb3BlcnR5IG9yIHBhdGguICBJZiB0aGUgcm9vdCBwcm9wZXJ0eSBvZiB0aGUgcGF0aCBpblxuICAgICAgICogcXVlc3Rpb24gaGFkIG5vIGFjY2Vzc29yLCB0aGUgcGF0aCBpcyBzZXQsIG90aGVyd2lzZSBpdCBpcyBlbnF1ZXVlZFxuICAgICAgICogdmlhIGBfc2V0UGVuZGluZ1Byb3BlcnR5YC5cbiAgICAgICAqXG4gICAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzb2xhdGVzIHJlbGF0aXZlbHkgZXhwZW5zaXZlIGZ1bmN0aW9uYWxpdHkgbmVjZXNzYXJ5XG4gICAgICAgKiBmb3IgdGhlIHB1YmxpYyBBUEkgKGBzZXRgLCBgc2V0UHJvcGVydGllc2AsIGBub3RpZnlQYXRoYCwgYW5kIHByb3BlcnR5XG4gICAgICAgKiBjaGFuZ2UgbGlzdGVuZXJzIHZpYSB7ey4uLn19IGJpbmRpbmdzKSwgc3VjaCB0aGF0IGl0IGlzIG9ubHkgZG9uZVxuICAgICAgICogd2hlbiBwYXRocyBlbnRlciB0aGUgc3lzdGVtLCBhbmQgbm90IGF0IGV2ZXJ5IHByb3BhZ2F0aW9uIHN0ZXAuICBJdFxuICAgICAgICogYWxzbyBzZXRzIGEgYF9fZGF0YUhhc1BhdGhzYCBmbGFnIG9uIHRoZSBpbnN0YW5jZSB3aGljaCBpcyB1c2VkIHRvXG4gICAgICAgKiBmYXN0LXBhdGggc2xvd2VyIHBhdGgtbWF0Y2hpbmcgY29kZSBpbiB0aGUgcHJvcGVydHkgZWZmZWN0cyBob3N0IHBhdGhzLlxuICAgICAgICpcbiAgICAgICAqIGBwYXRoYCBjYW4gYmUgYSBwYXRoIHN0cmluZyBvciBhcnJheSBvZiBwYXRoIHBhcnRzIGFzIGFjY2VwdGVkIGJ5IHRoZVxuICAgICAgICogcHVibGljIEFQSS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZyB8ICFBcnJheTxudW1iZXJ8c3RyaW5nPn0gcGF0aCBQYXRoIHRvIHNldFxuICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byBzZXRcbiAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IHNob3VsZE5vdGlmeSBTZXQgdG8gdHJ1ZSBpZiB0aGlzIGNoYW5nZSBzaG91bGRcbiAgICAgICAqICBjYXVzZSBhIHByb3BlcnR5IG5vdGlmaWNhdGlvbiBldmVudCBkaXNwYXRjaFxuICAgICAgICogQHBhcmFtIHtib29sZWFuPX0gaXNQYXRoTm90aWZpY2F0aW9uIElmIHRoZSBwYXRoIGJlaW5nIHNldCBpcyBhIHBhdGhcbiAgICAgICAqICAgbm90aWZpY2F0aW9uIG9mIGFuIGFscmVhZHkgY2hhbmdlZCB2YWx1ZSwgYXMgb3Bwb3NlZCB0byBhIHJlcXVlc3RcbiAgICAgICAqICAgdG8gc2V0IGFuZCBub3RpZnkgdGhlIGNoYW5nZS4gIEluIHRoZSBsYXR0ZXIgYGZhbHNlYCBjYXNlLCBhIGRpcnR5XG4gICAgICAgKiAgIGNoZWNrIGlzIHBlcmZvcm1lZCBhbmQgdGhlbiB0aGUgdmFsdWUgaXMgc2V0IHRvIHRoZSBwYXRoIGJlZm9yZVxuICAgICAgICogICBlbnF1ZXVpbmcgdGhlIHBlbmRpbmcgcHJvcGVydHkgY2hhbmdlLlxuICAgICAgICogQHJldHVybiB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZSBwcm9wZXJ0eS9wYXRoIHdhcyBlbnF1ZXVlZCBpblxuICAgICAgICogICB0aGUgcGVuZGluZyBjaGFuZ2VzIGJhZy5cbiAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAqL1xuICAgICAgX3NldFBlbmRpbmdQcm9wZXJ0eU9yUGF0aChwYXRoLCB2YWx1ZSwgc2hvdWxkTm90aWZ5LCBpc1BhdGhOb3RpZmljYXRpb24pIHtcbiAgICAgICAgaWYgKGlzUGF0aE5vdGlmaWNhdGlvbiB8fFxuICAgICAgICAgICAgUG9seW1lci5QYXRoLnJvb3QoQXJyYXkuaXNBcnJheShwYXRoKSA/IHBhdGhbMF0gOiBwYXRoKSAhPT0gcGF0aCkge1xuICAgICAgICAgIC8vIERpcnR5IGNoZWNrIGNoYW5nZXMgYmVpbmcgc2V0IHRvIGEgcGF0aCBhZ2FpbnN0IHRoZSBhY3R1YWwgb2JqZWN0LFxuICAgICAgICAgIC8vIHNpbmNlIHRoaXMgaXMgdGhlIGVudHJ5IHBvaW50IGZvciBwYXRocyBpbnRvIHRoZSBzeXN0ZW07IGZyb20gaGVyZVxuICAgICAgICAgIC8vIHRoZSBvbmx5IGRpcnR5IGNoZWNrcyBhcmUgYWdhaW5zdCB0aGUgYF9fZGF0YVRlbXBgIGNhY2hlIHRvIHByZXZlbnRcbiAgICAgICAgICAvLyBkdXBsaWNhdGUgd29yayBpbiB0aGUgc2FtZSB0dXJuIG9ubHkuIE5vdGUsIGlmIHRoaXMgd2FzIGEgbm90aWZpY2F0aW9uXG4gICAgICAgICAgLy8gb2YgYSBjaGFuZ2UgYWxyZWFkeSBzZXQgdG8gYSBwYXRoIChpc1BhdGhOb3RpZmljYXRpb246IHRydWUpLFxuICAgICAgICAgIC8vIHdlIGFsd2F5cyBsZXQgdGhlIGNoYW5nZSB0aHJvdWdoIGFuZCBza2lwIHRoZSBgc2V0YCBzaW5jZSBpdCB3YXNcbiAgICAgICAgICAvLyBhbHJlYWR5IGRpcnR5IGNoZWNrZWQgYXQgdGhlIHBvaW50IG9mIGVudHJ5IGFuZCB0aGUgdW5kZXJseWluZ1xuICAgICAgICAgIC8vIG9iamVjdCBoYXMgYWxyZWFkeSBiZWVuIHVwZGF0ZWRcbiAgICAgICAgICBpZiAoIWlzUGF0aE5vdGlmaWNhdGlvbikge1xuICAgICAgICAgICAgbGV0IG9sZCA9IFBvbHltZXIuUGF0aC5nZXQodGhpcywgcGF0aCk7XG4gICAgICAgICAgICBwYXRoID0gLyoqIEB0eXBlIHtzdHJpbmd9ICovIChQb2x5bWVyLlBhdGguc2V0KHRoaXMsIHBhdGgsIHZhbHVlKSk7XG4gICAgICAgICAgICAvLyBVc2UgcHJvcGVydHktYWNjZXNzb3IncyBzaW1wbGVyIGRpcnR5IGNoZWNrXG4gICAgICAgICAgICBpZiAoIXBhdGggfHwgIXN1cGVyLl9zaG91bGRQcm9wZXJ0eUNoYW5nZShwYXRoLCB2YWx1ZSwgb2xkKSkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX19kYXRhSGFzUGF0aHMgPSB0cnVlO1xuICAgICAgICAgIGlmICh0aGlzLl9zZXRQZW5kaW5nUHJvcGVydHkoLyoqQHR5cGV7c3RyaW5nfSovKHBhdGgpLCB2YWx1ZSwgc2hvdWxkTm90aWZ5KSkge1xuICAgICAgICAgICAgY29tcHV0ZUxpbmtlZFBhdGhzKHRoaXMsIHBhdGgsIHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodGhpcy5fX2RhdGFIYXNBY2Nlc3NvciAmJiB0aGlzLl9fZGF0YUhhc0FjY2Vzc29yW3BhdGhdKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2V0UGVuZGluZ1Byb3BlcnR5KC8qKkB0eXBle3N0cmluZ30qLyhwYXRoKSwgdmFsdWUsIHNob3VsZE5vdGlmeSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXNbcGF0aF0gPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEFwcGxpZXMgYSB2YWx1ZSB0byBhIG5vbi1Qb2x5bWVyIGVsZW1lbnQvbm9kZSdzIHByb3BlcnR5LlxuICAgICAgICpcbiAgICAgICAqIFRoZSBpbXBsZW1lbnRhdGlvbiBtYWtlcyBhIGJlc3QtZWZmb3J0IGF0IGJpbmRpbmcgaW50ZXJvcDpcbiAgICAgICAqIFNvbWUgbmF0aXZlIGVsZW1lbnQgcHJvcGVydGllcyBoYXZlIHNpZGUtZWZmZWN0cyB3aGVuXG4gICAgICAgKiByZS1zZXR0aW5nIHRoZSBzYW1lIHZhbHVlIChlLmcuIHNldHRpbmcgYDxpbnB1dD4udmFsdWVgIHJlc2V0cyB0aGVcbiAgICAgICAqIGN1cnNvciBwb3NpdGlvbiksIHNvIHdlIGRvIGEgZGlydHktY2hlY2sgYmVmb3JlIHNldHRpbmcgdGhlIHZhbHVlLlxuICAgICAgICogSG93ZXZlciwgZm9yIGJldHRlciBpbnRlcm9wIHdpdGggbm9uLVBvbHltZXIgY3VzdG9tIGVsZW1lbnRzIHRoYXRcbiAgICAgICAqIGFjY2VwdCBvYmplY3RzLCB3ZSBleHBsaWNpdGx5IHJlLXNldCBvYmplY3QgY2hhbmdlcyBjb21pbmcgZnJvbSB0aGVcbiAgICAgICAqIFBvbHltZXIgd29ybGQgKHdoaWNoIG1heSBpbmNsdWRlIGRlZXAgb2JqZWN0IGNoYW5nZXMgd2l0aG91dCB0aGVcbiAgICAgICAqIHRvcCByZWZlcmVuY2UgY2hhbmdpbmcpLCBlcnJpbmcgb24gdGhlIHNpZGUgb2YgcHJvdmlkaW5nIG1vcmVcbiAgICAgICAqIGluZm9ybWF0aW9uLlxuICAgICAgICpcbiAgICAgICAqIFVzZXJzIG1heSBvdmVycmlkZSB0aGlzIG1ldGhvZCB0byBwcm92aWRlIGFsdGVybmF0ZSBhcHByb2FjaGVzLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBUaGUgbm9kZSB0byBzZXQgYSBwcm9wZXJ0eSBvblxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3AgVGhlIHByb3BlcnR5IHRvIHNldFxuICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0XG4gICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgKi9cbiAgICAgIF9zZXRVbm1hbmFnZWRQcm9wZXJ0eVRvTm9kZShub2RlLCBwcm9wLCB2YWx1ZSkge1xuICAgICAgICAvLyBJdCBpcyBhIGp1ZGdtZW50IGNhbGwgdGhhdCByZXNldHRpbmcgcHJpbWl0aXZlcyBpc1xuICAgICAgICAvLyBcImJhZFwiIGFuZCByZXNldHRpbmdzIG9iamVjdHMgaXMgYWxzbyBcImdvb2RcIjsgYWx0ZXJuYXRpdmVseSB3ZSBjb3VsZFxuICAgICAgICAvLyBpbXBsZW1lbnQgYSB3aGl0ZWxpc3Qgb2YgdGFnICYgcHJvcGVydHkgdmFsdWVzIHRoYXQgc2hvdWxkIG5ldmVyXG4gICAgICAgIC8vIGJlIHJlc2V0IChlLmcuIDxpbnB1dD4udmFsdWUgJiYgPHNlbGVjdD4udmFsdWUpXG4gICAgICAgIGlmICh2YWx1ZSAhPT0gbm9kZVtwcm9wXSB8fCB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBub2RlW3Byb3BdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBPdmVycmlkZXMgdGhlIGBQcm9wZXJ0eUFjY2Vzc29yc2AgaW1wbGVtZW50YXRpb24gdG8gaW50cm9kdWNlIHNwZWNpYWxcbiAgICAgICAqIGRpcnR5IGNoZWNrIGxvZ2ljIGRlcGVuZGluZyBvbiB0aGUgcHJvcGVydHkgJiB2YWx1ZSBiZWluZyBzZXQ6XG4gICAgICAgKlxuICAgICAgICogMS4gQW55IHZhbHVlIHNldCB0byBhIHBhdGggKGUuZy4gJ29iai5wcm9wJzogNDIgb3IgJ29iai5wcm9wJzogey4uLn0pXG4gICAgICAgKiAgICBTdG9yZWQgaW4gYF9fZGF0YVRlbXBgLCBkaXJ0eSBjaGVja2VkIGFnYWluc3QgYF9fZGF0YVRlbXBgXG4gICAgICAgKiAyLiBPYmplY3Qgc2V0IHRvIHNpbXBsZSBwcm9wZXJ0eSAoZS5nLiAncHJvcCc6IHsuLi59KVxuICAgICAgICogICAgU3RvcmVkIGluIGBfX2RhdGFUZW1wYCBhbmQgYF9fZGF0YWAsIGRpcnR5IGNoZWNrZWQgYWdhaW5zdFxuICAgICAgICogICAgYF9fZGF0YVRlbXBgIGJ5IGRlZmF1bHQgaW1wbGVtZW50YXRpb24gb2YgYF9zaG91bGRQcm9wZXJ0eUNoYW5nZWBcbiAgICAgICAqIDMuIFByaW1pdGl2ZSB2YWx1ZSBzZXQgdG8gc2ltcGxlIHByb3BlcnR5IChlLmcuICdwcm9wJzogNDIpXG4gICAgICAgKiAgICBTdG9yZWQgaW4gYF9fZGF0YWAsIGRpcnR5IGNoZWNrZWQgYWdhaW5zdCBgX19kYXRhYFxuICAgICAgICpcbiAgICAgICAqIFRoZSBkaXJ0eS1jaGVjayBpcyBpbXBvcnRhbnQgdG8gcHJldmVudCBjeWNsZXMgZHVlIHRvIHR3by13YXlcbiAgICAgICAqIG5vdGlmaWNhdGlvbiwgYnV0IHBhdGhzIGFuZCBvYmplY3RzIGFyZSBvbmx5IGRpcnR5IGNoZWNrZWQgYWdhaW5zdCBhbnlcbiAgICAgICAqIHByZXZpb3VzIHZhbHVlIHNldCBkdXJpbmcgdGhpcyB0dXJuIHZpYSBhIFwidGVtcG9yYXJ5IGNhY2hlXCIgdGhhdCBpc1xuICAgICAgICogY2xlYXJlZCB3aGVuIHRoZSBsYXN0IGBfcHJvcGVydGllc0NoYWdlZGAgZXhpdHMuIFRoaXMgaXMgc286XG4gICAgICAgKiBhLiBhbnkgY2FjaGVkIGFycmF5IHBhdGhzIChlLmcuICdhcnJheS4zLnByb3AnKSBtYXkgYmUgaW52YWxpZGF0ZWRcbiAgICAgICAqICAgIGR1ZSB0byBhcnJheSBtdXRhdGlvbnMgbGlrZSBzaGlmdC91bnNoaWZ0L3NwbGljZTsgdGhpcyBpcyBmaW5lXG4gICAgICAgKiAgICBzaW5jZSBwYXRoIGNoYW5nZXMgYXJlIGRpcnR5LWNoZWNrZWQgYXQgdXNlciBlbnRyeSBwb2ludHMgbGlrZSBgc2V0YFxuICAgICAgICogYi4gZGlydHktY2hlY2tpbmcgZm9yIG9iamVjdHMgb25seSBsYXN0cyBvbmUgdHVybiB0byBhbGxvdyB0aGUgdXNlclxuICAgICAgICogICAgdG8gbXV0YXRlIHRoZSBvYmplY3QgaW4tcGxhY2UgYW5kIHJlLXNldCBpdCB3aXRoIHRoZSBzYW1lIGlkZW50aXR5XG4gICAgICAgKiAgICBhbmQgaGF2ZSBhbGwgc3ViLXByb3BlcnRpZXMgcmUtcHJvcGFnYXRlZCBpbiBhIHN1YnNlcXVlbnQgdHVybi5cbiAgICAgICAqXG4gICAgICAgKiBUaGUgdGVtcCBjYWNoZSBpcyBub3QgbmVjZXNzYXJpbHkgc3VmZmljaWVudCB0byBwcmV2ZW50IGludmFsaWQgYXJyYXlcbiAgICAgICAqIHBhdGhzLCBzaW5jZSBhIHNwbGljZSBjYW4gaGFwcGVuIGR1cmluZyB0aGUgc2FtZSB0dXJuICh3aXRoIHBhdGhvbG9naWNhbFxuICAgICAgICogdXNlciBjb2RlKTsgd2UgY291bGQgaW50cm9kdWNlIGEgXCJmaXh1cFwiIGZvciB0ZW1wb3JhcmlseSBjYWNoZWQgYXJyYXlcbiAgICAgICAqIHBhdGhzIGlmIG5lZWRlZDogaHR0cHM6Ly9naXRodWIuY29tL1BvbHltZXIvcG9seW1lci9pc3N1ZXMvNDIyN1xuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBOYW1lIG9mIHRoZSBwcm9wZXJ0eVxuICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byBzZXRcbiAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IHNob3VsZE5vdGlmeSBUcnVlIGlmIHByb3BlcnR5IHNob3VsZCBmaXJlIG5vdGlmaWNhdGlvblxuICAgICAgICogICBldmVudCAoYXBwbGllcyBvbmx5IGZvciBgbm90aWZ5OiB0cnVlYCBwcm9wZXJ0aWVzKVxuICAgICAgICogQHJldHVybiB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZSBwcm9wZXJ0eSBjaGFuZ2VkXG4gICAgICAgKiBAb3ZlcnJpZGVcbiAgICAgICAqL1xuICAgICAgX3NldFBlbmRpbmdQcm9wZXJ0eShwcm9wZXJ0eSwgdmFsdWUsIHNob3VsZE5vdGlmeSkge1xuICAgICAgICBsZXQgaXNQYXRoID0gdGhpcy5fX2RhdGFIYXNQYXRocyAmJiBQb2x5bWVyLlBhdGguaXNQYXRoKHByb3BlcnR5KTtcbiAgICAgICAgbGV0IHByZXZQcm9wcyA9IGlzUGF0aCA/IHRoaXMuX19kYXRhVGVtcCA6IHRoaXMuX19kYXRhO1xuICAgICAgICBpZiAodGhpcy5fc2hvdWxkUHJvcGVydHlDaGFuZ2UocHJvcGVydHksIHZhbHVlLCBwcmV2UHJvcHNbcHJvcGVydHldKSkge1xuICAgICAgICAgIGlmICghdGhpcy5fX2RhdGFQZW5kaW5nKSB7XG4gICAgICAgICAgICB0aGlzLl9fZGF0YVBlbmRpbmcgPSB7fTtcbiAgICAgICAgICAgIHRoaXMuX19kYXRhT2xkID0ge307XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIEVuc3VyZSBvbGQgaXMgY2FwdHVyZWQgZnJvbSB0aGUgbGFzdCB0dXJuXG4gICAgICAgICAgaWYgKCEocHJvcGVydHkgaW4gdGhpcy5fX2RhdGFPbGQpKSB7XG4gICAgICAgICAgICB0aGlzLl9fZGF0YU9sZFtwcm9wZXJ0eV0gPSB0aGlzLl9fZGF0YVtwcm9wZXJ0eV07XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFBhdGhzIGFyZSBzdG9yZWQgaW4gdGVtcG9yYXJ5IGNhY2hlIChjbGVhcmVkIGF0IGVuZCBvZiB0dXJuKSxcbiAgICAgICAgICAvLyB3aGljaCBpcyB1c2VkIGZvciBkaXJ0eS1jaGVja2luZywgYWxsIG90aGVycyBzdG9yZWQgaW4gX19kYXRhXG4gICAgICAgICAgaWYgKGlzUGF0aCkge1xuICAgICAgICAgICAgdGhpcy5fX2RhdGFUZW1wW3Byb3BlcnR5XSA9IHZhbHVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9fZGF0YVtwcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gQWxsIGNoYW5nZXMgZ28gaW50byBwZW5kaW5nIHByb3BlcnR5IGJhZywgcGFzc2VkIHRvIF9wcm9wZXJ0aWVzQ2hhbmdlZFxuICAgICAgICAgIHRoaXMuX19kYXRhUGVuZGluZ1twcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICAgICAgICAvLyBUcmFjayBwcm9wZXJ0aWVzIHRoYXQgc2hvdWxkIG5vdGlmeSBzZXBhcmF0ZWx5XG4gICAgICAgICAgaWYgKGlzUGF0aCB8fCAodGhpc1tUWVBFUy5OT1RJRlldICYmIHRoaXNbVFlQRVMuTk9USUZZXVtwcm9wZXJ0eV0pKSB7XG4gICAgICAgICAgICB0aGlzLl9fZGF0YVRvTm90aWZ5ID0gdGhpcy5fX2RhdGFUb05vdGlmeSB8fCB7fTtcbiAgICAgICAgICAgIHRoaXMuX19kYXRhVG9Ob3RpZnlbcHJvcGVydHldID0gc2hvdWxkTm90aWZ5O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogT3ZlcnJpZGVzIGJhc2UgaW1wbGVtZW50YXRpb24gdG8gZW5zdXJlIGFsbCBhY2Nlc3NvcnMgc2V0IGBzaG91bGROb3RpZnlgXG4gICAgICAgKiB0byB0cnVlLCBmb3IgcGVyLXByb3BlcnR5IG5vdGlmaWNhdGlvbiB0cmFja2luZy5cbiAgICAgICAqXG4gICAgICAgKiBAb3ZlcnJpZGVcbiAgICAgICAqL1xuICAgICAgX3NldFByb3BlcnR5KHByb3BlcnR5LCB2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5fc2V0UGVuZGluZ1Byb3BlcnR5KHByb3BlcnR5LCB2YWx1ZSwgdHJ1ZSkpIHtcbiAgICAgICAgICB0aGlzLl9pbnZhbGlkYXRlUHJvcGVydGllcygpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogT3ZlcnJpZGVzIGBQcm9wZXJ0eUFjY2Vzc29yYCdzIGRlZmF1bHQgYXN5bmMgcXVldWluZyBvZlxuICAgICAgICogYF9wcm9wZXJ0aWVzQ2hhbmdlZGA6IGlmIGBfX2RhdGFSZWFkeWAgaXMgZmFsc2UgKGhhcyBub3QgeWV0IGJlZW5cbiAgICAgICAqIG1hbnVhbGx5IGZsdXNoZWQpLCB0aGUgZnVuY3Rpb24gbm8tb3BzOyBvdGhlcndpc2UgZmx1c2hlc1xuICAgICAgICogYF9wcm9wZXJ0aWVzQ2hhbmdlZGAgc3luY2hyb25vdXNseS5cbiAgICAgICAqXG4gICAgICAgKiBAb3ZlcnJpZGVcbiAgICAgICAqL1xuICAgICAgX2ludmFsaWRhdGVQcm9wZXJ0aWVzKCkge1xuICAgICAgICBpZiAodGhpcy5fX2RhdGFSZWFkeSkge1xuICAgICAgICAgIHRoaXMuX2ZsdXNoUHJvcGVydGllcygpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogRW5xdWV1ZXMgdGhlIGdpdmVuIGNsaWVudCBvbiBhIGxpc3Qgb2YgcGVuZGluZyBjbGllbnRzLCB3aG9zZVxuICAgICAgICogcGVuZGluZyBwcm9wZXJ0eSBjaGFuZ2VzIGNhbiBsYXRlciBiZSBmbHVzaGVkIHZpYSBhIGNhbGwgdG9cbiAgICAgICAqIGBfZmx1c2hDbGllbnRzYC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2xpZW50IFByb3BlcnR5RWZmZWN0cyBjbGllbnQgdG8gZW5xdWV1ZVxuICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICovXG4gICAgICBfZW5xdWV1ZUNsaWVudChjbGllbnQpIHtcbiAgICAgICAgdGhpcy5fX2RhdGFQZW5kaW5nQ2xpZW50cyA9IHRoaXMuX19kYXRhUGVuZGluZ0NsaWVudHMgfHwgW107XG4gICAgICAgIGlmIChjbGllbnQgIT09IHRoaXMpIHtcbiAgICAgICAgICB0aGlzLl9fZGF0YVBlbmRpbmdDbGllbnRzLnB1c2goY2xpZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEZsdXNoZXMgYW55IGNsaWVudHMgcHJldmlvdXNseSBlbnF1ZXVlZCB2aWEgYF9lbnF1ZXVlQ2xpZW50YCwgY2F1c2luZ1xuICAgICAgICogdGhlaXIgYF9mbHVzaFByb3BlcnRpZXNgIG1ldGhvZCB0byBydW4uXG4gICAgICAgKlxuICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICovXG4gICAgICBfZmx1c2hDbGllbnRzKCkge1xuICAgICAgICBpZiAoIXRoaXMuX19kYXRhQ2xpZW50c1JlYWR5KSB7XG4gICAgICAgICAgdGhpcy5fX2RhdGFDbGllbnRzUmVhZHkgPSB0cnVlO1xuICAgICAgICAgIHRoaXMuX3JlYWR5Q2xpZW50cygpO1xuICAgICAgICAgIC8vIE92ZXJyaWRlIHBvaW50IHdoZXJlIGFjY2Vzc29ycyBhcmUgdHVybmVkIG9uOyBpbXBvcnRhbnRseSxcbiAgICAgICAgICAvLyB0aGlzIGlzIGFmdGVyIGNsaWVudHMgaGF2ZSBmdWxseSByZWFkaWVkLCBwcm92aWRpbmcgYSBndWFyYW50ZWVcbiAgICAgICAgICAvLyB0aGF0IGFueSBwcm9wZXJ0eSBlZmZlY3RzIG9jY3VyIG9ubHkgYWZ0ZXIgYWxsIGNsaWVudHMgYXJlIHJlYWR5LlxuICAgICAgICAgIHRoaXMuX19kYXRhUmVhZHkgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX19lbmFibGVPckZsdXNoQ2xpZW50cygpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIE5PVEU6IFdlIGVuc3VyZSBjbGllbnRzIGVpdGhlciBlbmFibGUgb3IgZmx1c2ggYXMgYXBwcm9wcmlhdGUuIFRoaXNcbiAgICAgIC8vIGhhbmRsZXMgdHdvIGNvcm5lciBjYXNlczpcbiAgICAgIC8vICgxKSBjbGllbnRzIGZsdXNoIHByb3Blcmx5IHdoZW4gY29ubmVjdGVkL2VuYWJsZWQgYmVmb3JlIHRoZSBob3N0XG4gICAgICAvLyBlbmFibGVzOyBlLmcuXG4gICAgICAvLyAgIChhKSBUZW1wbGF0aXplIHN0YW1wcyB3aXRoIG5vIHByb3BlcnRpZXMgYW5kIGRvZXMgbm90IGZsdXNoIGFuZFxuICAgICAgLy8gICAoYikgdGhlIGluc3RhbmNlIGlzIGluc2VydGVkIGludG8gZG9tIGFuZFxuICAgICAgLy8gICAoYykgdGhlbiB0aGUgaW5zdGFuY2UgZmx1c2hlcy5cbiAgICAgIC8vICgyKSBjbGllbnRzIGVuYWJsZSBwcm9wZXJseSB3aGVuIG5vdCBjb25uZWN0ZWQvZW5hYmxlZCB3aGVuIHRoZSBob3N0XG4gICAgICAvLyBmbHVzaGVzOyBlLmcuXG4gICAgICAvLyAgIChhKSBhIHRlbXBsYXRlIGlzIHJ1bnRpbWUgc3RhbXBlZCBhbmQgbm90IHlldCBjb25uZWN0ZWQvZW5hYmxlZFxuICAgICAgLy8gICAoYikgYSBob3N0IHNldHMgYSBwcm9wZXJ0eSwgY2F1c2luZyBzdGFtcGVkIGRvbSB0byBmbHVzaFxuICAgICAgLy8gICAoYykgdGhlIHN0YW1wZWQgZG9tIGVuYWJsZXMuXG4gICAgICBfX2VuYWJsZU9yRmx1c2hDbGllbnRzKCkge1xuICAgICAgICBsZXQgY2xpZW50cyA9IHRoaXMuX19kYXRhUGVuZGluZ0NsaWVudHM7XG4gICAgICAgIGlmIChjbGllbnRzKSB7XG4gICAgICAgICAgdGhpcy5fX2RhdGFQZW5kaW5nQ2xpZW50cyA9IG51bGw7XG4gICAgICAgICAgZm9yIChsZXQgaT0wOyBpIDwgY2xpZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGNsaWVudCA9IGNsaWVudHNbaV07XG4gICAgICAgICAgICBpZiAoIWNsaWVudC5fX2RhdGFFbmFibGVkKSB7XG4gICAgICAgICAgICAgIGNsaWVudC5fZW5hYmxlUHJvcGVydGllcygpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjbGllbnQuX19kYXRhUGVuZGluZykge1xuICAgICAgICAgICAgICBjbGllbnQuX2ZsdXNoUHJvcGVydGllcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFBlcmZvcm0gYW55IGluaXRpYWwgc2V0dXAgb24gY2xpZW50IGRvbS4gQ2FsbGVkIGJlZm9yZSB0aGUgZmlyc3RcbiAgICAgICAqIGBfZmx1c2hQcm9wZXJ0aWVzYCBjYWxsIG9uIGNsaWVudCBkb20gYW5kIGJlZm9yZSBhbnkgZWxlbWVudFxuICAgICAgICogb2JzZXJ2ZXJzIGFyZSBjYWxsZWQuXG4gICAgICAgKlxuICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICovXG4gICAgICBfcmVhZHlDbGllbnRzKCkge1xuICAgICAgICB0aGlzLl9fZW5hYmxlT3JGbHVzaENsaWVudHMoKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBTZXRzIGEgYmFnIG9mIHByb3BlcnR5IGNoYW5nZXMgdG8gdGhpcyBpbnN0YW5jZSwgYW5kXG4gICAgICAgKiBzeW5jaHJvbm91c2x5IHByb2Nlc3NlcyBhbGwgZWZmZWN0cyBvZiB0aGUgcHJvcGVydGllcyBhcyBhIGJhdGNoLlxuICAgICAgICpcbiAgICAgICAqIFByb3BlcnR5IG5hbWVzIG11c3QgYmUgc2ltcGxlIHByb3BlcnRpZXMsIG5vdCBwYXRocy4gIEJhdGNoZWRcbiAgICAgICAqIHBhdGggcHJvcGFnYXRpb24gaXMgbm90IHN1cHBvcnRlZC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgQmFnIG9mIG9uZSBvciBtb3JlIGtleS12YWx1ZSBwYWlycyB3aG9zZSBrZXkgaXNcbiAgICAgICAqICAgYSBwcm9wZXJ0eSBhbmQgdmFsdWUgaXMgdGhlIG5ldyB2YWx1ZSB0byBzZXQgZm9yIHRoYXQgcHJvcGVydHkuXG4gICAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBzZXRSZWFkT25seSBXaGVuIHRydWUsIGFueSBwcml2YXRlIHZhbHVlcyBzZXQgaW5cbiAgICAgICAqICAgYHByb3BzYCB3aWxsIGJlIHNldC4gQnkgZGVmYXVsdCwgYHNldFByb3BlcnRpZXNgIHdpbGwgbm90IHNldFxuICAgICAgICogICBgcmVhZE9ubHk6IHRydWVgIHJvb3QgcHJvcGVydGllcy5cbiAgICAgICAqIEBwdWJsaWNcbiAgICAgICAqL1xuICAgICAgc2V0UHJvcGVydGllcyhwcm9wcywgc2V0UmVhZE9ubHkpIHtcbiAgICAgICAgZm9yIChsZXQgcGF0aCBpbiBwcm9wcykge1xuICAgICAgICAgIGlmIChzZXRSZWFkT25seSB8fCAhdGhpc1tUWVBFUy5SRUFEX09OTFldIHx8ICF0aGlzW1RZUEVTLlJFQURfT05MWV1bcGF0aF0pIHtcbiAgICAgICAgICAgIC8vVE9ETyhrc2NoYWFmKTogZXhwbGljaXRseSBkaXNhbGxvdyBwYXRocyBpbiBzZXRQcm9wZXJ0eT9cbiAgICAgICAgICAgIC8vIHdpbGRjYXJkIG9ic2VydmVycyBjdXJyZW50bHkgb25seSBwYXNzIHRoZSBmaXJzdCBjaGFuZ2VkIHBhdGhcbiAgICAgICAgICAgIC8vIGluIHRoZSBgaW5mb2Agb2JqZWN0LCBhbmQgeW91IGNvdWxkIGRvIHNvbWUgb2RkIHRoaW5ncyBiYXRjaGluZ1xuICAgICAgICAgICAgLy8gcGF0aHMsIGUuZy4geydmb28uYmFyJzogey4uLn0sICdmb28nOiBudWxsfVxuICAgICAgICAgICAgdGhpcy5fc2V0UGVuZGluZ1Byb3BlcnR5T3JQYXRoKHBhdGgsIHByb3BzW3BhdGhdLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faW52YWxpZGF0ZVByb3BlcnRpZXMoKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBPdmVycmlkZXMgYFByb3BlcnR5QWNjZXNzb3JzYCBzbyB0aGF0IHByb3BlcnR5IGFjY2Vzc29yXG4gICAgICAgKiBzaWRlIGVmZmVjdHMgYXJlIG5vdCBlbmFibGVkIHVudGlsIGFmdGVyIGNsaWVudCBkb20gaXMgZnVsbHkgcmVhZHkuXG4gICAgICAgKiBBbHNvIGNhbGxzIGBfZmx1c2hDbGllbnRzYCBjYWxsYmFjayB0byBlbnN1cmUgY2xpZW50IGRvbSBpcyBlbmFibGVkXG4gICAgICAgKiB0aGF0IHdhcyBub3QgZW5hYmxlZCBhcyBhIHJlc3VsdCBvZiBmbHVzaGluZyBwcm9wZXJ0aWVzLlxuICAgICAgICpcbiAgICAgICAqIEBvdmVycmlkZVxuICAgICAgICovXG4gICAgICByZWFkeSgpIHtcbiAgICAgICAgLy8gSXQgaXMgaW1wb3J0YW50IHRoYXQgYHN1cGVyLnJlYWR5KClgIGlzIG5vdCBjYWxsZWQgaGVyZSBhcyBpdFxuICAgICAgICAvLyBpbW1lZGlhdGVseSB0dXJucyBvbiBhY2Nlc3NvcnMuIEluc3RlYWQsIHdlIHdhaXQgdW50aWwgYHJlYWR5Q2xpZW50c2BcbiAgICAgICAgLy8gdG8gZW5hYmxlIGFjY2Vzc29ycyB0byBwcm92aWRlIGEgZ3VhcmFudGVlIHRoYXQgY2xpZW50cyBhcmUgcmVhZHlcbiAgICAgICAgLy8gYmVmb3JlIHByb2Nlc3NpbmcgYW55IGFjY2Vzc29ycyBzaWRlIGVmZmVjdHMuXG4gICAgICAgIHRoaXMuX2ZsdXNoUHJvcGVydGllcygpO1xuICAgICAgICAvLyBJZiBubyBkYXRhIHdhcyBwZW5kaW5nLCBgX2ZsdXNoUHJvcGVydGllc2Agd2lsbCBub3QgYGZsdXNoQ2xpZW50c2BcbiAgICAgICAgLy8gc28gZW5zdXJlIHRoaXMgaXMgZG9uZS5cbiAgICAgICAgaWYgKCF0aGlzLl9fZGF0YUNsaWVudHNSZWFkeSkge1xuICAgICAgICAgIHRoaXMuX2ZsdXNoQ2xpZW50cygpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEJlZm9yZSByZWFkeSwgY2xpZW50IG5vdGlmaWNhdGlvbnMgZG8gbm90IHRyaWdnZXIgX2ZsdXNoUHJvcGVydGllcy5cbiAgICAgICAgLy8gVGhlcmVmb3JlIGEgZmx1c2ggaXMgbmVjZXNzYXJ5IGhlcmUgaWYgZGF0YSBoYXMgYmVlbiBzZXQuXG4gICAgICAgIGlmICh0aGlzLl9fZGF0YVBlbmRpbmcpIHtcbiAgICAgICAgICB0aGlzLl9mbHVzaFByb3BlcnRpZXMoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEltcGxlbWVudHMgYFByb3BlcnR5QWNjZXNzb3JzYCdzIHByb3BlcnRpZXMgY2hhbmdlZCBjYWxsYmFjay5cbiAgICAgICAqXG4gICAgICAgKiBSdW5zIGVhY2ggY2xhc3Mgb2YgZWZmZWN0cyBmb3IgdGhlIGJhdGNoIG9mIGNoYW5nZWQgcHJvcGVydGllcyBpblxuICAgICAgICogYSBzcGVjaWZpYyBvcmRlciAoY29tcHV0ZSwgcHJvcGFnYXRlLCByZWZsZWN0LCBvYnNlcnZlLCBub3RpZnkpLlxuICAgICAgICpcbiAgICAgICAqIEBvdmVycmlkZVxuICAgICAgICovXG4gICAgICBfcHJvcGVydGllc0NoYW5nZWQoY3VycmVudFByb3BzLCBjaGFuZ2VkUHJvcHMsIG9sZFByb3BzKSB7XG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gbGV0IGMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhjaGFuZ2VkUHJvcHMgfHwge30pO1xuICAgICAgICAvLyB3aW5kb3cuZGVidWcgJiYgY29uc29sZS5ncm91cCh0aGlzLmxvY2FsTmFtZSArICcjJyArIHRoaXMuaWQgKyAnOiAnICsgYyk7XG4gICAgICAgIC8vIGlmICh3aW5kb3cuZGVidWcpIHsgZGVidWdnZXI7IH1cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICBsZXQgaGFzUGF0aHMgPSB0aGlzLl9fZGF0YUhhc1BhdGhzO1xuICAgICAgICB0aGlzLl9fZGF0YUhhc1BhdGhzID0gZmFsc2U7XG4gICAgICAgIC8vIENvbXB1dGUgcHJvcGVydGllc1xuICAgICAgICBydW5Db21wdXRlZEVmZmVjdHModGhpcywgY2hhbmdlZFByb3BzLCBvbGRQcm9wcywgaGFzUGF0aHMpO1xuICAgICAgICAvLyBDbGVhciBub3RpZnkgcHJvcGVydGllcyBwcmlvciB0byBwb3NzaWJsZSByZWVudHJ5IChwcm9wYWdhdGUsIG9ic2VydmUpLFxuICAgICAgICAvLyBidXQgYWZ0ZXIgY29tcHV0aW5nIGVmZmVjdHMgaGF2ZSBhIGNoYW5jZSB0byBhZGQgdG8gdGhlbVxuICAgICAgICBsZXQgbm90aWZ5UHJvcHMgPSB0aGlzLl9fZGF0YVRvTm90aWZ5O1xuICAgICAgICB0aGlzLl9fZGF0YVRvTm90aWZ5ID0gbnVsbDtcbiAgICAgICAgLy8gUHJvcGFnYXRlIHByb3BlcnRpZXMgdG8gY2xpZW50c1xuICAgICAgICB0aGlzLl9wcm9wYWdhdGVQcm9wZXJ0eUNoYW5nZXMoY2hhbmdlZFByb3BzLCBvbGRQcm9wcywgaGFzUGF0aHMpO1xuICAgICAgICAvLyBGbHVzaCBjbGllbnRzXG4gICAgICAgIHRoaXMuX2ZsdXNoQ2xpZW50cygpO1xuICAgICAgICAvLyBSZWZsZWN0IHByb3BlcnRpZXNcbiAgICAgICAgcnVuRWZmZWN0cyh0aGlzLCB0aGlzW1RZUEVTLlJFRkxFQ1RdLCBjaGFuZ2VkUHJvcHMsIG9sZFByb3BzLCBoYXNQYXRocyk7XG4gICAgICAgIC8vIE9ic2VydmUgcHJvcGVydGllc1xuICAgICAgICBydW5FZmZlY3RzKHRoaXMsIHRoaXNbVFlQRVMuT0JTRVJWRV0sIGNoYW5nZWRQcm9wcywgb2xkUHJvcHMsIGhhc1BhdGhzKTtcbiAgICAgICAgLy8gTm90aWZ5IHByb3BlcnRpZXMgdG8gaG9zdFxuICAgICAgICBpZiAobm90aWZ5UHJvcHMpIHtcbiAgICAgICAgICBydW5Ob3RpZnlFZmZlY3RzKHRoaXMsIG5vdGlmeVByb3BzLCBjaGFuZ2VkUHJvcHMsIG9sZFByb3BzLCBoYXNQYXRocyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2xlYXIgdGVtcG9yYXJ5IGNhY2hlIGF0IGVuZCBvZiB0dXJuXG4gICAgICAgIGlmICh0aGlzLl9fZGF0YUNvdW50ZXIgPT0gMSkge1xuICAgICAgICAgIHRoaXMuX19kYXRhVGVtcCA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gd2luZG93LmRlYnVnICYmIGNvbnNvbGUuZ3JvdXBFbmQodGhpcy5sb2NhbE5hbWUgKyAnIycgKyB0aGlzLmlkICsgJzogJyArIGMpO1xuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ2FsbGVkIHRvIHByb3BhZ2F0ZSBhbnkgcHJvcGVydHkgY2hhbmdlcyB0byBzdGFtcGVkIHRlbXBsYXRlIG5vZGVzXG4gICAgICAgKiBtYW5hZ2VkIGJ5IHRoaXMgZWxlbWVudC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2hhbmdlZFByb3BzIEJhZyBvZiBjaGFuZ2VkIHByb3BlcnRpZXNcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvbGRQcm9wcyBCYWcgb2YgcHJldmlvdXMgdmFsdWVzIGZvciBjaGFuZ2VkIHByb3BlcnRpZXNcbiAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaGFzUGF0aHMgVHJ1ZSB3aXRoIGBwcm9wc2AgY29udGFpbnMgb25lIG9yIG1vcmUgcGF0aHNcbiAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAqL1xuICAgICAgX3Byb3BhZ2F0ZVByb3BlcnR5Q2hhbmdlcyhjaGFuZ2VkUHJvcHMsIG9sZFByb3BzLCBoYXNQYXRocykge1xuICAgICAgICBpZiAodGhpc1tUWVBFUy5QUk9QQUdBVEVdKSB7XG4gICAgICAgICAgcnVuRWZmZWN0cyh0aGlzLCB0aGlzW1RZUEVTLlBST1BBR0FURV0sIGNoYW5nZWRQcm9wcywgb2xkUHJvcHMsIGhhc1BhdGhzKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdGVtcGxhdGVJbmZvID0gdGhpcy5fX3RlbXBsYXRlSW5mbztcbiAgICAgICAgd2hpbGUgKHRlbXBsYXRlSW5mbykge1xuICAgICAgICAgIHJ1bkVmZmVjdHModGhpcywgdGVtcGxhdGVJbmZvLnByb3BlcnR5RWZmZWN0cywgY2hhbmdlZFByb3BzLCBvbGRQcm9wcyxcbiAgICAgICAgICAgIGhhc1BhdGhzLCB0ZW1wbGF0ZUluZm8ubm9kZUxpc3QpO1xuICAgICAgICAgIHRlbXBsYXRlSW5mbyA9IHRlbXBsYXRlSW5mby5uZXh0VGVtcGxhdGVJbmZvO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQWxpYXNlcyBvbmUgZGF0YSBwYXRoIGFzIGFub3RoZXIsIHN1Y2ggdGhhdCBwYXRoIG5vdGlmaWNhdGlvbnMgZnJvbSBvbmVcbiAgICAgICAqIGFyZSByb3V0ZWQgdG8gdGhlIG90aGVyLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgIUFycmF5PHN0cmluZ3xudW1iZXI+fSB0byBUYXJnZXQgcGF0aCB0byBsaW5rLlxuICAgICAgICogQHBhcmFtIHtzdHJpbmcgfCAhQXJyYXk8c3RyaW5nfG51bWJlcj59IGZyb20gU291cmNlIHBhdGggdG8gbGluay5cbiAgICAgICAqIEBwdWJsaWNcbiAgICAgICAqL1xuICAgICAgbGlua1BhdGhzKHRvLCBmcm9tKSB7XG4gICAgICAgIHRvID0gUG9seW1lci5QYXRoLm5vcm1hbGl6ZSh0byk7XG4gICAgICAgIGZyb20gPSBQb2x5bWVyLlBhdGgubm9ybWFsaXplKGZyb20pO1xuICAgICAgICB0aGlzLl9fZGF0YUxpbmtlZFBhdGhzID0gdGhpcy5fX2RhdGFMaW5rZWRQYXRocyB8fCB7fTtcbiAgICAgICAgdGhpcy5fX2RhdGFMaW5rZWRQYXRoc1t0b10gPSBmcm9tO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJlbW92ZXMgYSBkYXRhIHBhdGggYWxpYXMgcHJldmlvdXNseSBlc3RhYmxpc2hlZCB3aXRoIGBfbGlua1BhdGhzYC5cbiAgICAgICAqXG4gICAgICAgKiBOb3RlLCB0aGUgcGF0aCB0byB1bmxpbmsgc2hvdWxkIGJlIHRoZSB0YXJnZXQgKGB0b2ApIHVzZWQgd2hlblxuICAgICAgICogbGlua2luZyB0aGUgcGF0aHMuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmcgfCAhQXJyYXk8c3RyaW5nfG51bWJlcj59IHBhdGggVGFyZ2V0IHBhdGggdG8gdW5saW5rLlxuICAgICAgICogQHB1YmxpY1xuICAgICAgICovXG4gICAgICB1bmxpbmtQYXRocyhwYXRoKSB7XG4gICAgICAgIHBhdGggPSBQb2x5bWVyLlBhdGgubm9ybWFsaXplKHBhdGgpO1xuICAgICAgICBpZiAodGhpcy5fX2RhdGFMaW5rZWRQYXRocykge1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLl9fZGF0YUxpbmtlZFBhdGhzW3BhdGhdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogTm90aWZ5IHRoYXQgYW4gYXJyYXkgaGFzIGNoYW5nZWQuXG4gICAgICAgKlxuICAgICAgICogRXhhbXBsZTpcbiAgICAgICAqXG4gICAgICAgKiAgICAgdGhpcy5pdGVtcyA9IFsge25hbWU6ICdKaW0nfSwge25hbWU6ICdUb2RkJ30sIHtuYW1lOiAnQmlsbCd9IF07XG4gICAgICAgKiAgICAgLi4uXG4gICAgICAgKiAgICAgdGhpcy5pdGVtcy5zcGxpY2UoMSwgMSwge25hbWU6ICdTYW0nfSk7XG4gICAgICAgKiAgICAgdGhpcy5pdGVtcy5wdXNoKHtuYW1lOiAnQm9iJ30pO1xuICAgICAgICogICAgIHRoaXMubm90aWZ5U3BsaWNlcygnaXRlbXMnLCBbXG4gICAgICAgKiAgICAgICB7IGluZGV4OiAxLCByZW1vdmVkOiBbe25hbWU6ICdUb2RkJ31dLCBhZGRlZENvdW50OiAxLCBvYmVjdDogdGhpcy5pdGVtcywgdHlwZTogJ3NwbGljZScgfSxcbiAgICAgICAqICAgICAgIHsgaW5kZXg6IDMsIHJlbW92ZWQ6IFtdLCBhZGRlZENvdW50OiAxLCBvYmplY3Q6IHRoaXMuaXRlbXMsIHR5cGU6ICdzcGxpY2UnfVxuICAgICAgICogICAgIF0pO1xuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFBhdGggdGhhdCBzaG91bGQgYmUgbm90aWZpZWQuXG4gICAgICAgKiBAcGFyYW0ge0FycmF5fSBzcGxpY2VzIEFycmF5IG9mIHNwbGljZSByZWNvcmRzIGluZGljYXRpbmcgb3JkZXJlZFxuICAgICAgICogICBjaGFuZ2VzIHRoYXQgb2NjdXJyZWQgdG8gdGhlIGFycmF5LiBFYWNoIHJlY29yZCBzaG91bGQgaGF2ZSB0aGVcbiAgICAgICAqICAgZm9sbG93aW5nIGZpZWxkczpcbiAgICAgICAqICAgICogaW5kZXg6IGluZGV4IGF0IHdoaWNoIHRoZSBjaGFuZ2Ugb2NjdXJyZWRcbiAgICAgICAqICAgICogcmVtb3ZlZDogYXJyYXkgb2YgaXRlbXMgdGhhdCB3ZXJlIHJlbW92ZWQgZnJvbSB0aGlzIGluZGV4XG4gICAgICAgKiAgICAqIGFkZGVkQ291bnQ6IG51bWJlciBvZiBuZXcgaXRlbXMgYWRkZWQgYXQgdGhpcyBpbmRleFxuICAgICAgICogICAgKiBvYmplY3Q6IGEgcmVmZXJlbmNlIHRvIHRoZSBhcnJheSBpbiBxdWVzdGlvblxuICAgICAgICogICAgKiB0eXBlOiB0aGUgc3RyaW5nIGxpdGVyYWwgJ3NwbGljZSdcbiAgICAgICAqXG4gICAgICAgKiAgIE5vdGUgdGhhdCBzcGxpY2UgcmVjb3JkcyBfbXVzdF8gYmUgbm9ybWFsaXplZCBzdWNoIHRoYXQgdGhleSBhcmVcbiAgICAgICAqICAgcmVwb3J0ZWQgaW4gaW5kZXggb3JkZXIgKHJhdyByZXN1bHRzIGZyb20gYE9iamVjdC5vYnNlcnZlYCBhcmUgbm90XG4gICAgICAgKiAgIG9yZGVyZWQgYW5kIG11c3QgYmUgbm9ybWFsaXplZC9tZXJnZWQgYmVmb3JlIG5vdGlmeWluZykuXG4gICAgICAgKiBAcHVibGljXG4gICAgICAqL1xuICAgICAgbm90aWZ5U3BsaWNlcyhwYXRoLCBzcGxpY2VzKSB7XG4gICAgICAgIGxldCBpbmZvID0ge3BhdGg6ICcnfTtcbiAgICAgICAgbGV0IGFycmF5ID0gLyoqIEB0eXBlIHtBcnJheX0gKi8oUG9seW1lci5QYXRoLmdldCh0aGlzLCBwYXRoLCBpbmZvKSk7XG4gICAgICAgIG5vdGlmeVNwbGljZXModGhpcywgYXJyYXksIGluZm8ucGF0aCwgc3BsaWNlcyk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ29udmVuaWVuY2UgbWV0aG9kIGZvciByZWFkaW5nIGEgdmFsdWUgZnJvbSBhIHBhdGguXG4gICAgICAgKlxuICAgICAgICogTm90ZSwgaWYgYW55IHBhcnQgaW4gdGhlIHBhdGggaXMgdW5kZWZpbmVkLCB0aGlzIG1ldGhvZCByZXR1cm5zXG4gICAgICAgKiBgdW5kZWZpbmVkYCAodGhpcyBtZXRob2QgZG9lcyBub3QgdGhyb3cgd2hlbiBkZXJlZmVyZW5jaW5nIHVuZGVmaW5lZFxuICAgICAgICogcGF0aHMpLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7KHN0cmluZ3whQXJyYXk8KHN0cmluZ3xudW1iZXIpPil9IHBhdGggUGF0aCB0byB0aGUgdmFsdWVcbiAgICAgICAqICAgdG8gcmVhZC4gIFRoZSBwYXRoIG1heSBiZSBzcGVjaWZpZWQgYXMgYSBzdHJpbmcgKGUuZy4gYGZvby5iYXIuYmF6YClcbiAgICAgICAqICAgb3IgYW4gYXJyYXkgb2YgcGF0aCBwYXJ0cyAoZS5nLiBgWydmb28uYmFyJywgJ2JheiddYCkuICBOb3RlIHRoYXRcbiAgICAgICAqICAgYnJhY2tldGVkIGV4cHJlc3Npb25zIGFyZSBub3Qgc3VwcG9ydGVkOyBzdHJpbmctYmFzZWQgcGF0aCBwYXJ0c1xuICAgICAgICogICAqbXVzdCogYmUgc2VwYXJhdGVkIGJ5IGRvdHMuICBOb3RlIHRoYXQgd2hlbiBkZXJlZmVyZW5jaW5nIGFycmF5XG4gICAgICAgKiAgIGluZGljZXMsIHRoZSBpbmRleCBtYXkgYmUgdXNlZCBhcyBhIGRvdHRlZCBwYXJ0IGRpcmVjdGx5XG4gICAgICAgKiAgIChlLmcuIGB1c2Vycy4xMi5uYW1lYCBvciBgWyd1c2VycycsIDEyLCAnbmFtZSddYCkuXG4gICAgICAgKiBAcGFyYW0ge09iamVjdD19IHJvb3QgUm9vdCBvYmplY3QgZnJvbSB3aGljaCB0aGUgcGF0aCBpcyBldmFsdWF0ZWQuXG4gICAgICAgKiBAcmV0dXJuIHsqfSBWYWx1ZSBhdCB0aGUgcGF0aCwgb3IgYHVuZGVmaW5lZGAgaWYgYW55IHBhcnQgb2YgdGhlIHBhdGhcbiAgICAgICAqICAgaXMgdW5kZWZpbmVkLlxuICAgICAgICogQHB1YmxpY1xuICAgICAgICovXG4gICAgICBnZXQocGF0aCwgcm9vdCkge1xuICAgICAgICByZXR1cm4gUG9seW1lci5QYXRoLmdldChyb290IHx8IHRoaXMsIHBhdGgpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENvbnZlbmllbmNlIG1ldGhvZCBmb3Igc2V0dGluZyBhIHZhbHVlIHRvIGEgcGF0aCBhbmQgbm90aWZ5aW5nIGFueVxuICAgICAgICogZWxlbWVudHMgYm91bmQgdG8gdGhlIHNhbWUgcGF0aC5cbiAgICAgICAqXG4gICAgICAgKiBOb3RlLCBpZiBhbnkgcGFydCBpbiB0aGUgcGF0aCBleGNlcHQgZm9yIHRoZSBsYXN0IGlzIHVuZGVmaW5lZCxcbiAgICAgICAqIHRoaXMgbWV0aG9kIGRvZXMgbm90aGluZyAodGhpcyBtZXRob2QgZG9lcyBub3QgdGhyb3cgd2hlblxuICAgICAgICogZGVyZWZlcmVuY2luZyB1bmRlZmluZWQgcGF0aHMpLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7KHN0cmluZ3whQXJyYXk8KHN0cmluZ3xudW1iZXIpPil9IHBhdGggUGF0aCB0byB0aGUgdmFsdWVcbiAgICAgICAqICAgdG8gd3JpdGUuICBUaGUgcGF0aCBtYXkgYmUgc3BlY2lmaWVkIGFzIGEgc3RyaW5nIChlLmcuIGAnZm9vLmJhci5iYXonYClcbiAgICAgICAqICAgb3IgYW4gYXJyYXkgb2YgcGF0aCBwYXJ0cyAoZS5nLiBgWydmb28uYmFyJywgJ2JheiddYCkuICBOb3RlIHRoYXRcbiAgICAgICAqICAgYnJhY2tldGVkIGV4cHJlc3Npb25zIGFyZSBub3Qgc3VwcG9ydGVkOyBzdHJpbmctYmFzZWQgcGF0aCBwYXJ0c1xuICAgICAgICogICAqbXVzdCogYmUgc2VwYXJhdGVkIGJ5IGRvdHMuICBOb3RlIHRoYXQgd2hlbiBkZXJlZmVyZW5jaW5nIGFycmF5XG4gICAgICAgKiAgIGluZGljZXMsIHRoZSBpbmRleCBtYXkgYmUgdXNlZCBhcyBhIGRvdHRlZCBwYXJ0IGRpcmVjdGx5XG4gICAgICAgKiAgIChlLmcuIGAndXNlcnMuMTIubmFtZSdgIG9yIGBbJ3VzZXJzJywgMTIsICduYW1lJ11gKS5cbiAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgdG8gc2V0IGF0IHRoZSBzcGVjaWZpZWQgcGF0aC5cbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0PX0gcm9vdCBSb290IG9iamVjdCBmcm9tIHdoaWNoIHRoZSBwYXRoIGlzIGV2YWx1YXRlZC5cbiAgICAgICAqICAgV2hlbiBzcGVjaWZpZWQsIG5vIG5vdGlmaWNhdGlvbiB3aWxsIG9jY3VyLlxuICAgICAgICogQHB1YmxpY1xuICAgICAgKi9cbiAgICAgIHNldChwYXRoLCB2YWx1ZSwgcm9vdCkge1xuICAgICAgICBpZiAocm9vdCkge1xuICAgICAgICAgIFBvbHltZXIuUGF0aC5zZXQocm9vdCwgcGF0aCwgdmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICghdGhpc1tUWVBFUy5SRUFEX09OTFldIHx8ICF0aGlzW1RZUEVTLlJFQURfT05MWV1bLyoqIEB0eXBlIHtzdHJpbmd9ICovKHBhdGgpXSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3NldFBlbmRpbmdQcm9wZXJ0eU9yUGF0aChwYXRoLCB2YWx1ZSwgdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgdGhpcy5faW52YWxpZGF0ZVByb3BlcnRpZXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBBZGRzIGl0ZW1zIG9udG8gdGhlIGVuZCBvZiB0aGUgYXJyYXkgYXQgdGhlIHBhdGggc3BlY2lmaWVkLlxuICAgICAgICpcbiAgICAgICAqIFRoZSBhcmd1bWVudHMgYWZ0ZXIgYHBhdGhgIGFuZCByZXR1cm4gdmFsdWUgbWF0Y2ggdGhhdCBvZlxuICAgICAgICogYEFycmF5LnByb3RvdHlwZS5wdXNoYC5cbiAgICAgICAqXG4gICAgICAgKiBUaGlzIG1ldGhvZCBub3RpZmllcyBvdGhlciBwYXRocyB0byB0aGUgc2FtZSBhcnJheSB0aGF0IGFcbiAgICAgICAqIHNwbGljZSBvY2N1cnJlZCB0byB0aGUgYXJyYXkuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggUGF0aCB0byBhcnJheS5cbiAgICAgICAqIEBwYXJhbSB7Li4uKn0gaXRlbXMgSXRlbXMgdG8gcHVzaCBvbnRvIGFycmF5XG4gICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IE5ldyBsZW5ndGggb2YgdGhlIGFycmF5LlxuICAgICAgICogQHB1YmxpY1xuICAgICAgICovXG4gICAgICBwdXNoKHBhdGgsIC4uLml0ZW1zKSB7XG4gICAgICAgIGxldCBpbmZvID0ge3BhdGg6ICcnfTtcbiAgICAgICAgbGV0IGFycmF5ID0gLyoqIEB0eXBlIHtBcnJheX0qLyhQb2x5bWVyLlBhdGguZ2V0KHRoaXMsIHBhdGgsIGluZm8pKTtcbiAgICAgICAgbGV0IGxlbiA9IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgbGV0IHJldCA9IGFycmF5LnB1c2goLi4uaXRlbXMpO1xuICAgICAgICBpZiAoaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgbm90aWZ5U3BsaWNlKHRoaXMsIGFycmF5LCBpbmZvLnBhdGgsIGxlbiwgaXRlbXMubGVuZ3RoLCBbXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZW1vdmVzIGFuIGl0ZW0gZnJvbSB0aGUgZW5kIG9mIGFycmF5IGF0IHRoZSBwYXRoIHNwZWNpZmllZC5cbiAgICAgICAqXG4gICAgICAgKiBUaGUgYXJndW1lbnRzIGFmdGVyIGBwYXRoYCBhbmQgcmV0dXJuIHZhbHVlIG1hdGNoIHRoYXQgb2ZcbiAgICAgICAqIGBBcnJheS5wcm90b3R5cGUucG9wYC5cbiAgICAgICAqXG4gICAgICAgKiBUaGlzIG1ldGhvZCBub3RpZmllcyBvdGhlciBwYXRocyB0byB0aGUgc2FtZSBhcnJheSB0aGF0IGFcbiAgICAgICAqIHNwbGljZSBvY2N1cnJlZCB0byB0aGUgYXJyYXkuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggUGF0aCB0byBhcnJheS5cbiAgICAgICAqIEByZXR1cm4geyp9IEl0ZW0gdGhhdCB3YXMgcmVtb3ZlZC5cbiAgICAgICAqIEBwdWJsaWNcbiAgICAgICAqL1xuICAgICAgcG9wKHBhdGgpIHtcbiAgICAgICAgbGV0IGluZm8gPSB7cGF0aDogJyd9O1xuICAgICAgICBsZXQgYXJyYXkgPSAvKiogQHR5cGUge0FycmF5fSAqLyhQb2x5bWVyLlBhdGguZ2V0KHRoaXMsIHBhdGgsIGluZm8pKTtcbiAgICAgICAgbGV0IGhhZExlbmd0aCA9IEJvb2xlYW4oYXJyYXkubGVuZ3RoKTtcbiAgICAgICAgbGV0IHJldCA9IGFycmF5LnBvcCgpO1xuICAgICAgICBpZiAoaGFkTGVuZ3RoKSB7XG4gICAgICAgICAgbm90aWZ5U3BsaWNlKHRoaXMsIGFycmF5LCBpbmZvLnBhdGgsIGFycmF5Lmxlbmd0aCwgMCwgW3JldF0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogU3RhcnRpbmcgZnJvbSB0aGUgc3RhcnQgaW5kZXggc3BlY2lmaWVkLCByZW1vdmVzIDAgb3IgbW9yZSBpdGVtc1xuICAgICAgICogZnJvbSB0aGUgYXJyYXkgYW5kIGluc2VydHMgMCBvciBtb3JlIG5ldyBpdGVtcyBpbiB0aGVpciBwbGFjZS5cbiAgICAgICAqXG4gICAgICAgKiBUaGUgYXJndW1lbnRzIGFmdGVyIGBwYXRoYCBhbmQgcmV0dXJuIHZhbHVlIG1hdGNoIHRoYXQgb2ZcbiAgICAgICAqIGBBcnJheS5wcm90b3R5cGUuc3BsaWNlYC5cbiAgICAgICAqXG4gICAgICAgKiBUaGlzIG1ldGhvZCBub3RpZmllcyBvdGhlciBwYXRocyB0byB0aGUgc2FtZSBhcnJheSB0aGF0IGFcbiAgICAgICAqIHNwbGljZSBvY2N1cnJlZCB0byB0aGUgYXJyYXkuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggUGF0aCB0byBhcnJheS5cbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBJbmRleCBmcm9tIHdoaWNoIHRvIHN0YXJ0IHJlbW92aW5nL2luc2VydGluZy5cbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkZWxldGVDb3VudCBOdW1iZXIgb2YgaXRlbXMgdG8gcmVtb3ZlLlxuICAgICAgICogQHBhcmFtIHsuLi4qfSBpdGVtcyBJdGVtcyB0byBpbnNlcnQgaW50byBhcnJheS5cbiAgICAgICAqIEByZXR1cm4ge0FycmF5fSBBcnJheSBvZiByZW1vdmVkIGl0ZW1zLlxuICAgICAgICogQHB1YmxpY1xuICAgICAgICovXG4gICAgICBzcGxpY2UocGF0aCwgc3RhcnQsIGRlbGV0ZUNvdW50LCAuLi5pdGVtcykge1xuICAgICAgICBsZXQgaW5mbyA9IHtwYXRoIDogJyd9O1xuICAgICAgICBsZXQgYXJyYXkgPSAvKiogQHR5cGUge0FycmF5fSAqLyhQb2x5bWVyLlBhdGguZ2V0KHRoaXMsIHBhdGgsIGluZm8pKTtcbiAgICAgICAgLy8gTm9ybWFsaXplIGZhbmN5IG5hdGl2ZSBzcGxpY2UgaGFuZGxpbmcgb2YgY3Jhenkgc3RhcnQgdmFsdWVzXG4gICAgICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgICAgICBzdGFydCA9IGFycmF5Lmxlbmd0aCAtIE1hdGguZmxvb3IoLXN0YXJ0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdGFydCA9IE1hdGguZmxvb3Ioc3RhcnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc3RhcnQpIHtcbiAgICAgICAgICBzdGFydCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJldCA9IGFycmF5LnNwbGljZShzdGFydCwgZGVsZXRlQ291bnQsIC4uLml0ZW1zKTtcbiAgICAgICAgaWYgKGl0ZW1zLmxlbmd0aCB8fCByZXQubGVuZ3RoKSB7XG4gICAgICAgICAgbm90aWZ5U3BsaWNlKHRoaXMsIGFycmF5LCBpbmZvLnBhdGgsIHN0YXJ0LCBpdGVtcy5sZW5ndGgsIHJldCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZW1vdmVzIGFuIGl0ZW0gZnJvbSB0aGUgYmVnaW5uaW5nIG9mIGFycmF5IGF0IHRoZSBwYXRoIHNwZWNpZmllZC5cbiAgICAgICAqXG4gICAgICAgKiBUaGUgYXJndW1lbnRzIGFmdGVyIGBwYXRoYCBhbmQgcmV0dXJuIHZhbHVlIG1hdGNoIHRoYXQgb2ZcbiAgICAgICAqIGBBcnJheS5wcm90b3R5cGUucG9wYC5cbiAgICAgICAqXG4gICAgICAgKiBUaGlzIG1ldGhvZCBub3RpZmllcyBvdGhlciBwYXRocyB0byB0aGUgc2FtZSBhcnJheSB0aGF0IGFcbiAgICAgICAqIHNwbGljZSBvY2N1cnJlZCB0byB0aGUgYXJyYXkuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggUGF0aCB0byBhcnJheS5cbiAgICAgICAqIEByZXR1cm4geyp9IEl0ZW0gdGhhdCB3YXMgcmVtb3ZlZC5cbiAgICAgICAqIEBwdWJsaWNcbiAgICAgICAqL1xuICAgICAgc2hpZnQocGF0aCkge1xuICAgICAgICBsZXQgaW5mbyA9IHtwYXRoOiAnJ307XG4gICAgICAgIGxldCBhcnJheSA9IC8qKiBAdHlwZSB7QXJyYXl9ICovKFBvbHltZXIuUGF0aC5nZXQodGhpcywgcGF0aCwgaW5mbykpO1xuICAgICAgICBsZXQgaGFkTGVuZ3RoID0gQm9vbGVhbihhcnJheS5sZW5ndGgpO1xuICAgICAgICBsZXQgcmV0ID0gYXJyYXkuc2hpZnQoKTtcbiAgICAgICAgaWYgKGhhZExlbmd0aCkge1xuICAgICAgICAgIG5vdGlmeVNwbGljZSh0aGlzLCBhcnJheSwgaW5mby5wYXRoLCAwLCAwLCBbcmV0XSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBBZGRzIGl0ZW1zIG9udG8gdGhlIGJlZ2lubmluZyBvZiB0aGUgYXJyYXkgYXQgdGhlIHBhdGggc3BlY2lmaWVkLlxuICAgICAgICpcbiAgICAgICAqIFRoZSBhcmd1bWVudHMgYWZ0ZXIgYHBhdGhgIGFuZCByZXR1cm4gdmFsdWUgbWF0Y2ggdGhhdCBvZlxuICAgICAgICogYEFycmF5LnByb3RvdHlwZS5wdXNoYC5cbiAgICAgICAqXG4gICAgICAgKiBUaGlzIG1ldGhvZCBub3RpZmllcyBvdGhlciBwYXRocyB0byB0aGUgc2FtZSBhcnJheSB0aGF0IGFcbiAgICAgICAqIHNwbGljZSBvY2N1cnJlZCB0byB0aGUgYXJyYXkuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggUGF0aCB0byBhcnJheS5cbiAgICAgICAqIEBwYXJhbSB7Li4uKn0gaXRlbXMgSXRlbXMgdG8gaW5zZXJ0IGluZm8gYXJyYXlcbiAgICAgICAqIEByZXR1cm4ge251bWJlcn0gTmV3IGxlbmd0aCBvZiB0aGUgYXJyYXkuXG4gICAgICAgKiBAcHVibGljXG4gICAgICAgKi9cbiAgICAgIHVuc2hpZnQocGF0aCwgLi4uaXRlbXMpIHtcbiAgICAgICAgbGV0IGluZm8gPSB7cGF0aDogJyd9O1xuICAgICAgICBsZXQgYXJyYXkgPSAvKiogQHR5cGUge0FycmF5fSAqLyhQb2x5bWVyLlBhdGguZ2V0KHRoaXMsIHBhdGgsIGluZm8pKTtcbiAgICAgICAgbGV0IHJldCA9IGFycmF5LnVuc2hpZnQoLi4uaXRlbXMpO1xuICAgICAgICBpZiAoaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgbm90aWZ5U3BsaWNlKHRoaXMsIGFycmF5LCBpbmZvLnBhdGgsIDAsIGl0ZW1zLmxlbmd0aCwgW10pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogTm90aWZ5IHRoYXQgYSBwYXRoIGhhcyBjaGFuZ2VkLlxuICAgICAgICpcbiAgICAgICAqIEV4YW1wbGU6XG4gICAgICAgKlxuICAgICAgICogICAgIHRoaXMuaXRlbS51c2VyLm5hbWUgPSAnQm9iJztcbiAgICAgICAqICAgICB0aGlzLm5vdGlmeVBhdGgoJ2l0ZW0udXNlci5uYW1lJyk7XG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggUGF0aCB0aGF0IHNob3VsZCBiZSBub3RpZmllZC5cbiAgICAgICAqIEBwYXJhbSB7Kj19IHZhbHVlIFZhbHVlIGF0IHRoZSBwYXRoIChvcHRpb25hbCkuXG4gICAgICAgKiBAcHVibGljXG4gICAgICAqL1xuICAgICAgbm90aWZ5UGF0aChwYXRoLCB2YWx1ZSkge1xuICAgICAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgICAgICAgbGV0IHByb3BQYXRoO1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgLy8gR2V0IHZhbHVlIGlmIG5vdCBzdXBwbGllZFxuICAgICAgICAgIGxldCBpbmZvID0ge3BhdGg6ICcnfTtcbiAgICAgICAgICB2YWx1ZSA9IFBvbHltZXIuUGF0aC5nZXQodGhpcywgcGF0aCwgaW5mbyk7XG4gICAgICAgICAgcHJvcFBhdGggPSBpbmZvLnBhdGg7XG4gICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShwYXRoKSkge1xuICAgICAgICAgIC8vIE5vcm1hbGl6ZSBwYXRoIGlmIG5lZWRlZFxuICAgICAgICAgIHByb3BQYXRoID0gUG9seW1lci5QYXRoLm5vcm1hbGl6ZShwYXRoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcm9wUGF0aCA9IC8qKiBAdHlwZXtzdHJpbmd9ICovKHBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9zZXRQZW5kaW5nUHJvcGVydHlPclBhdGgocHJvcFBhdGgsIHZhbHVlLCB0cnVlLCB0cnVlKSkge1xuICAgICAgICAgIHRoaXMuX2ludmFsaWRhdGVQcm9wZXJ0aWVzKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBFcXVpdmFsZW50IHRvIHN0YXRpYyBgY3JlYXRlUmVhZE9ubHlQcm9wZXJ0eWAgQVBJIGJ1dCBjYW4gYmUgY2FsbGVkIG9uXG4gICAgICAgKiBhbiBpbnN0YW5jZSB0byBhZGQgZWZmZWN0cyBhdCBydW50aW1lLiAgU2VlIHRoYXQgbWV0aG9kIGZvclxuICAgICAgICogZnVsbCBBUEkgZG9jcy5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgbmFtZVxuICAgICAgICogQHBhcmFtIHtib29sZWFuPX0gcHJvdGVjdGVkU2V0dGVyIENyZWF0ZXMgYSBjdXN0b20gcHJvdGVjdGVkIHNldHRlclxuICAgICAgICogICB3aGVuIGB0cnVlYC5cbiAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAqL1xuICAgICAgX2NyZWF0ZVJlYWRPbmx5UHJvcGVydHkocHJvcGVydHksIHByb3RlY3RlZFNldHRlcikge1xuICAgICAgICB0aGlzLl9hZGRQcm9wZXJ0eUVmZmVjdChwcm9wZXJ0eSwgVFlQRVMuUkVBRF9PTkxZKTtcbiAgICAgICAgaWYgKHByb3RlY3RlZFNldHRlcikge1xuICAgICAgICAgIHRoaXNbJ19zZXQnICsgdXBwZXIocHJvcGVydHkpXSA9IC8qKiBAdGhpcyB7UHJvcGVydHlFZmZlY3RzfSAqL2Z1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9zZXRQcm9wZXJ0eShwcm9wZXJ0eSwgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEVxdWl2YWxlbnQgdG8gc3RhdGljIGBjcmVhdGVQcm9wZXJ0eU9ic2VydmVyYCBBUEkgYnV0IGNhbiBiZSBjYWxsZWQgb25cbiAgICAgICAqIGFuIGluc3RhbmNlIHRvIGFkZCBlZmZlY3RzIGF0IHJ1bnRpbWUuICBTZWUgdGhhdCBtZXRob2QgZm9yXG4gICAgICAgKiBmdWxsIEFQSSBkb2NzLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSBuYW1lXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kTmFtZSBOYW1lIG9mIG9ic2VydmVyIG1ldGhvZCB0byBjYWxsXG4gICAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBkeW5hbWljRm4gV2hldGhlciB0aGUgbWV0aG9kIG5hbWUgc2hvdWxkIGJlIGluY2x1ZGVkIGFzXG4gICAgICAgKiAgIGEgZGVwZW5kZW5jeSB0byB0aGUgZWZmZWN0LlxuICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICovXG4gICAgICBfY3JlYXRlUHJvcGVydHlPYnNlcnZlcihwcm9wZXJ0eSwgbWV0aG9kTmFtZSwgZHluYW1pY0ZuKSB7XG4gICAgICAgIGxldCBpbmZvID0geyBwcm9wZXJ0eSwgbWV0aG9kTmFtZSwgZHluYW1pY0ZuOiBCb29sZWFuKGR5bmFtaWNGbikgfTtcbiAgICAgICAgdGhpcy5fYWRkUHJvcGVydHlFZmZlY3QocHJvcGVydHksIFRZUEVTLk9CU0VSVkUsIHtcbiAgICAgICAgICBmbjogcnVuT2JzZXJ2ZXJFZmZlY3QsIGluZm8sIHRyaWdnZXI6IHtuYW1lOiBwcm9wZXJ0eX1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChkeW5hbWljRm4pIHtcbiAgICAgICAgICB0aGlzLl9hZGRQcm9wZXJ0eUVmZmVjdChtZXRob2ROYW1lLCBUWVBFUy5PQlNFUlZFLCB7XG4gICAgICAgICAgICBmbjogcnVuT2JzZXJ2ZXJFZmZlY3QsIGluZm8sIHRyaWdnZXI6IHtuYW1lOiBtZXRob2ROYW1lfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogRXF1aXZhbGVudCB0byBzdGF0aWMgYGNyZWF0ZU1ldGhvZE9ic2VydmVyYCBBUEkgYnV0IGNhbiBiZSBjYWxsZWQgb25cbiAgICAgICAqIGFuIGluc3RhbmNlIHRvIGFkZCBlZmZlY3RzIGF0IHJ1bnRpbWUuICBTZWUgdGhhdCBtZXRob2QgZm9yXG4gICAgICAgKiBmdWxsIEFQSSBkb2NzLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBleHByZXNzaW9uIE1ldGhvZCBleHByZXNzaW9uXG4gICAgICAgKiBAcGFyYW0ge2Jvb2xlYW58T2JqZWN0PX0gZHluYW1pY0ZuIEJvb2xlYW4gb3Igb2JqZWN0IG1hcCBpbmRpY2F0aW5nXG4gICAgICAgKiAgIHdoZXRoZXIgbWV0aG9kIG5hbWVzIHNob3VsZCBiZSBpbmNsdWRlZCBhcyBhIGRlcGVuZGVuY3kgdG8gdGhlIGVmZmVjdC5cbiAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAqL1xuICAgICAgX2NyZWF0ZU1ldGhvZE9ic2VydmVyKGV4cHJlc3Npb24sIGR5bmFtaWNGbikge1xuICAgICAgICBsZXQgc2lnID0gcGFyc2VNZXRob2QoZXhwcmVzc2lvbik7XG4gICAgICAgIGlmICghc2lnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWFsZm9ybWVkIG9ic2VydmVyIGV4cHJlc3Npb24gJ1wiICsgZXhwcmVzc2lvbiArIFwiJ1wiKTtcbiAgICAgICAgfVxuICAgICAgICBjcmVhdGVNZXRob2RFZmZlY3QodGhpcywgc2lnLCBUWVBFUy5PQlNFUlZFLCBydW5NZXRob2RFZmZlY3QsIG51bGwsIGR5bmFtaWNGbik7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogRXF1aXZhbGVudCB0byBzdGF0aWMgYGNyZWF0ZU5vdGlmeWluZ1Byb3BlcnR5YCBBUEkgYnV0IGNhbiBiZSBjYWxsZWQgb25cbiAgICAgICAqIGFuIGluc3RhbmNlIHRvIGFkZCBlZmZlY3RzIGF0IHJ1bnRpbWUuICBTZWUgdGhhdCBtZXRob2QgZm9yXG4gICAgICAgKiBmdWxsIEFQSSBkb2NzLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSBuYW1lXG4gICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgKi9cbiAgICAgIF9jcmVhdGVOb3RpZnlpbmdQcm9wZXJ0eShwcm9wZXJ0eSkge1xuICAgICAgICB0aGlzLl9hZGRQcm9wZXJ0eUVmZmVjdChwcm9wZXJ0eSwgVFlQRVMuTk9USUZZLCB7XG4gICAgICAgICAgZm46IHJ1bk5vdGlmeUVmZmVjdCxcbiAgICAgICAgICBpbmZvOiB7XG4gICAgICAgICAgICBldmVudE5hbWU6IENhc2VNYXAuY2FtZWxUb0Rhc2hDYXNlKHByb3BlcnR5KSArICctY2hhbmdlZCcsXG4gICAgICAgICAgICBwcm9wZXJ0eTogcHJvcGVydHlcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEVxdWl2YWxlbnQgdG8gc3RhdGljIGBjcmVhdGVSZWZsZWN0ZWRQcm9wZXJ0eWAgQVBJIGJ1dCBjYW4gYmUgY2FsbGVkIG9uXG4gICAgICAgKiBhbiBpbnN0YW5jZSB0byBhZGQgZWZmZWN0cyBhdCBydW50aW1lLiAgU2VlIHRoYXQgbWV0aG9kIGZvclxuICAgICAgICogZnVsbCBBUEkgZG9jcy5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgbmFtZVxuICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICovXG4gICAgICBfY3JlYXRlUmVmbGVjdGVkUHJvcGVydHkocHJvcGVydHkpIHtcbiAgICAgICAgbGV0IGF0dHIgPSBDYXNlTWFwLmNhbWVsVG9EYXNoQ2FzZShwcm9wZXJ0eSk7XG4gICAgICAgIGlmIChhdHRyWzBdID09PSAnLScpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ1Byb3BlcnR5ICcgKyBwcm9wZXJ0eSArICcgY2Fubm90IGJlIHJlZmxlY3RlZCB0byBhdHRyaWJ1dGUgJyArXG4gICAgICAgICAgICBhdHRyICsgJyBiZWNhdXNlIFwiLVwiIGlzIG5vdCBhIHZhbGlkIHN0YXJ0aW5nIGF0dHJpYnV0ZSBuYW1lLiBVc2UgYSBsb3dlcmNhc2UgZmlyc3QgbGV0dGVyIGZvciB0aGUgcHJvcGVydHkgdGhpc2VhZC4nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9hZGRQcm9wZXJ0eUVmZmVjdChwcm9wZXJ0eSwgVFlQRVMuUkVGTEVDVCwge1xuICAgICAgICAgICAgZm46IHJ1blJlZmxlY3RFZmZlY3QsXG4gICAgICAgICAgICBpbmZvOiB7XG4gICAgICAgICAgICAgIGF0dHJOYW1lOiBhdHRyXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBFcXVpdmFsZW50IHRvIHN0YXRpYyBgY3JlYXRlQ29tcHV0ZWRQcm9wZXJ0eWAgQVBJIGJ1dCBjYW4gYmUgY2FsbGVkIG9uXG4gICAgICAgKiBhbiBpbnN0YW5jZSB0byBhZGQgZWZmZWN0cyBhdCBydW50aW1lLiAgU2VlIHRoYXQgbWV0aG9kIGZvclxuICAgICAgICogZnVsbCBBUEkgZG9jcy5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgTmFtZSBvZiBjb21wdXRlZCBwcm9wZXJ0eSB0byBzZXRcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBleHByZXNzaW9uIE1ldGhvZCBleHByZXNzaW9uXG4gICAgICAgKiBAcGFyYW0ge2Jvb2xlYW58T2JqZWN0PX0gZHluYW1pY0ZuIEJvb2xlYW4gb3Igb2JqZWN0IG1hcCBpbmRpY2F0aW5nXG4gICAgICAgKiAgIHdoZXRoZXIgbWV0aG9kIG5hbWVzIHNob3VsZCBiZSBpbmNsdWRlZCBhcyBhIGRlcGVuZGVuY3kgdG8gdGhlIGVmZmVjdC5cbiAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAqL1xuICAgICAgX2NyZWF0ZUNvbXB1dGVkUHJvcGVydHkocHJvcGVydHksIGV4cHJlc3Npb24sIGR5bmFtaWNGbikge1xuICAgICAgICBsZXQgc2lnID0gcGFyc2VNZXRob2QoZXhwcmVzc2lvbik7XG4gICAgICAgIGlmICghc2lnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWFsZm9ybWVkIGNvbXB1dGVkIGV4cHJlc3Npb24gJ1wiICsgZXhwcmVzc2lvbiArIFwiJ1wiKTtcbiAgICAgICAgfVxuICAgICAgICBjcmVhdGVNZXRob2RFZmZlY3QodGhpcywgc2lnLCBUWVBFUy5DT01QVVRFLCBydW5Db21wdXRlZEVmZmVjdCwgcHJvcGVydHksIGR5bmFtaWNGbik7XG4gICAgICB9XG5cbiAgICAgIC8vIC0tIHN0YXRpYyBjbGFzcyBtZXRob2RzIC0tLS0tLS0tLS0tLVxuXG4gICAgICAvKipcbiAgICAgICAqIEVuc3VyZXMgYW4gYWNjZXNzb3IgZXhpc3RzIGZvciB0aGUgc3BlY2lmaWVkIHByb3BlcnR5LCBhbmQgYWRkc1xuICAgICAgICogdG8gYSBsaXN0IG9mIFwicHJvcGVydHkgZWZmZWN0c1wiIHRoYXQgd2lsbCBydW4gd2hlbiB0aGUgYWNjZXNzb3IgZm9yXG4gICAgICAgKiB0aGUgc3BlY2lmaWVkIHByb3BlcnR5IGlzIHNldC4gIEVmZmVjdHMgYXJlIGdyb3VwZWQgYnkgXCJ0eXBlXCIsIHdoaWNoXG4gICAgICAgKiByb3VnaGx5IGNvcnJlc3BvbmRzIHRvIGEgcGhhc2UgaW4gZWZmZWN0IHByb2Nlc3NpbmcuICBUaGUgZWZmZWN0XG4gICAgICAgKiBtZXRhZGF0YSBzaG91bGQgYmUgaW4gdGhlIGZvbGxvd2luZyBmb3JtOlxuICAgICAgICpcbiAgICAgICAqICAge1xuICAgICAgICogICAgIGZuOiBlZmZlY3RGdW5jdGlvbiwgLy8gUmVmZXJlbmNlIHRvIGZ1bmN0aW9uIHRvIGNhbGwgdG8gcGVyZm9ybSBlZmZlY3RcbiAgICAgICAqICAgICBpbmZvOiB7IC4uLiB9ICAgICAgIC8vIEVmZmVjdCBtZXRhZGF0YSBwYXNzZWQgdG8gZnVuY3Rpb25cbiAgICAgICAqICAgICB0cmlnZ2VyOiB7ICAgICAgICAgIC8vIE9wdGlvbmFsIHRyaWdnZXJpbmcgbWV0YWRhdGE7IGlmIG5vdCBwcm92aWRlZFxuICAgICAgICogICAgICAgbmFtZTogc3RyaW5nICAgICAgLy8gdGhlIHByb3BlcnR5IGlzIHRyZWF0ZWQgYXMgYSB3aWxkY2FyZFxuICAgICAgICogICAgICAgc3RydWN0dXJlZDogYm9vbGVhblxuICAgICAgICogICAgICAgd2lsZGNhcmQ6IGJvb2xlYW5cbiAgICAgICAqICAgICB9XG4gICAgICAgKiAgIH1cbiAgICAgICAqXG4gICAgICAgKiBFZmZlY3RzIGFyZSBjYWxsZWQgZnJvbSBgX3Byb3BlcnRpZXNDaGFuZ2VkYCBpbiB0aGUgZm9sbG93aW5nIG9yZGVyIGJ5XG4gICAgICAgKiB0eXBlOlxuICAgICAgICpcbiAgICAgICAqIDEuIENPTVBVVEVcbiAgICAgICAqIDIuIFBST1BBR0FURVxuICAgICAgICogMy4gUkVGTEVDVFxuICAgICAgICogNC4gT0JTRVJWRVxuICAgICAgICogNS4gTk9USUZZXG4gICAgICAgKlxuICAgICAgICogRWZmZWN0IGZ1bmN0aW9ucyBhcmUgY2FsbGVkIHdpdGggdGhlIGZvbGxvd2luZyBzaWduYXR1cmU6XG4gICAgICAgKlxuICAgICAgICogICBlZmZlY3RGdW5jdGlvbihpbnN0LCBwYXRoLCBwcm9wcywgb2xkUHJvcHMsIGluZm8sIGhhc1BhdGhzKVxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSB0aGF0IHNob3VsZCB0cmlnZ2VyIHRoZSBlZmZlY3RcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIEVmZmVjdCB0eXBlLCBmcm9tIHRoaXMuUFJPUEVSVFlfRUZGRUNUX1RZUEVTXG4gICAgICAgKiBAcGFyYW0ge09iamVjdD19IGVmZmVjdCBFZmZlY3QgbWV0YWRhdGEgb2JqZWN0XG4gICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgKi9cbiAgICAgIHN0YXRpYyBhZGRQcm9wZXJ0eUVmZmVjdChwcm9wZXJ0eSwgdHlwZSwgZWZmZWN0KSB7XG4gICAgICAgIHRoaXMucHJvdG90eXBlLl9hZGRQcm9wZXJ0eUVmZmVjdChwcm9wZXJ0eSwgdHlwZSwgZWZmZWN0KTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDcmVhdGVzIGEgc2luZ2xlLXByb3BlcnR5IG9ic2VydmVyIGZvciB0aGUgZ2l2ZW4gcHJvcGVydHkuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IG5hbWVcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2ROYW1lIE5hbWUgb2Ygb2JzZXJ2ZXIgbWV0aG9kIHRvIGNhbGxcbiAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IGR5bmFtaWNGbiBXaGV0aGVyIHRoZSBtZXRob2QgbmFtZSBzaG91bGQgYmUgaW5jbHVkZWQgYXNcbiAgICAgICAqICAgYSBkZXBlbmRlbmN5IHRvIHRoZSBlZmZlY3QuXG4gICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgKi9cbiAgICAgIHN0YXRpYyBjcmVhdGVQcm9wZXJ0eU9ic2VydmVyKHByb3BlcnR5LCBtZXRob2ROYW1lLCBkeW5hbWljRm4pIHtcbiAgICAgICAgdGhpcy5wcm90b3R5cGUuX2NyZWF0ZVByb3BlcnR5T2JzZXJ2ZXIocHJvcGVydHksIG1ldGhvZE5hbWUsIGR5bmFtaWNGbik7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ3JlYXRlcyBhIG11bHRpLXByb3BlcnR5IFwibWV0aG9kIG9ic2VydmVyXCIgYmFzZWQgb24gdGhlIHByb3ZpZGVkXG4gICAgICAgKiBleHByZXNzaW9uLCB3aGljaCBzaG91bGQgYmUgYSBzdHJpbmcgaW4gdGhlIGZvcm0gb2YgYSBub3JtYWwgSmF2YXNjcmlwdFxuICAgICAgICogZnVuY3Rpb24gc2lnbmF0dXJlOiBgJ21ldGhvZE5hbWUoYXJnMSwgWy4uLiwgYXJnbl0pJ2AuICBFYWNoIGFyZ3VtZW50XG4gICAgICAgKiBzaG91bGQgY29ycmVzcG9uZCB0byBhIHByb3BlcnR5IG9yIHBhdGggaW4gdGhlIGNvbnRleHQgb2YgdGhpc1xuICAgICAgICogcHJvdG90eXBlIChvciBpbnN0YW5jZSksIG9yIG1heSBiZSBhIGxpdGVyYWwgc3RyaW5nIG9yIG51bWJlci5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXhwcmVzc2lvbiBNZXRob2QgZXhwcmVzc2lvblxuICAgICAgICogQHBhcmFtIHtib29sZWFufE9iamVjdD19IGR5bmFtaWNGbiBCb29sZWFuIG9yIG9iamVjdCBtYXAgaW5kaWNhdGluZ1xuICAgICAgICogICB3aGV0aGVyIG1ldGhvZCBuYW1lcyBzaG91bGQgYmUgaW5jbHVkZWQgYXMgYSBkZXBlbmRlbmN5IHRvIHRoZSBlZmZlY3QuXG4gICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgKi9cbiAgICAgIHN0YXRpYyBjcmVhdGVNZXRob2RPYnNlcnZlcihleHByZXNzaW9uLCBkeW5hbWljRm4pIHtcbiAgICAgICAgdGhpcy5wcm90b3R5cGUuX2NyZWF0ZU1ldGhvZE9ic2VydmVyKGV4cHJlc3Npb24sIGR5bmFtaWNGbik7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ2F1c2VzIHRoZSBzZXR0ZXIgZm9yIHRoZSBnaXZlbiBwcm9wZXJ0eSB0byBkaXNwYXRjaCBgPHByb3BlcnR5Pi1jaGFuZ2VkYFxuICAgICAgICogZXZlbnRzIHRvIG5vdGlmeSBvZiBjaGFuZ2VzIHRvIHRoZSBwcm9wZXJ0eS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgbmFtZVxuICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICovXG4gICAgICBzdGF0aWMgY3JlYXRlTm90aWZ5aW5nUHJvcGVydHkocHJvcGVydHkpIHtcbiAgICAgICAgdGhpcy5wcm90b3R5cGUuX2NyZWF0ZU5vdGlmeWluZ1Byb3BlcnR5KHByb3BlcnR5KTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDcmVhdGVzIGEgcmVhZC1vbmx5IGFjY2Vzc29yIGZvciB0aGUgZ2l2ZW4gcHJvcGVydHkuXG4gICAgICAgKlxuICAgICAgICogVG8gc2V0IHRoZSBwcm9wZXJ0eSwgdXNlIHRoZSBwcm90ZWN0ZWQgYF9zZXRQcm9wZXJ0eWAgQVBJLlxuICAgICAgICogVG8gY3JlYXRlIGEgY3VzdG9tIHByb3RlY3RlZCBzZXR0ZXIgKGUuZy4gYF9zZXRNeVByb3AoKWAgZm9yXG4gICAgICAgKiBwcm9wZXJ0eSBgbXlQcm9wYCksIHBhc3MgYHRydWVgIGZvciBgcHJvdGVjdGVkU2V0dGVyYC5cbiAgICAgICAqXG4gICAgICAgKiBOb3RlLCBpZiB0aGUgcHJvcGVydHkgd2lsbCBoYXZlIG90aGVyIHByb3BlcnR5IGVmZmVjdHMsIHRoaXMgbWV0aG9kXG4gICAgICAgKiBzaG91bGQgYmUgY2FsbGVkIGZpcnN0LCBiZWZvcmUgYWRkaW5nIG90aGVyIGVmZmVjdHMuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IG5hbWVcbiAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IHByb3RlY3RlZFNldHRlciBDcmVhdGVzIGEgY3VzdG9tIHByb3RlY3RlZCBzZXR0ZXJcbiAgICAgICAqICAgd2hlbiBgdHJ1ZWAuXG4gICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgKi9cbiAgICAgIHN0YXRpYyBjcmVhdGVSZWFkT25seVByb3BlcnR5KHByb3BlcnR5LCBwcm90ZWN0ZWRTZXR0ZXIpIHtcbiAgICAgICAgdGhpcy5wcm90b3R5cGUuX2NyZWF0ZVJlYWRPbmx5UHJvcGVydHkocHJvcGVydHksIHByb3RlY3RlZFNldHRlcik7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ2F1c2VzIHRoZSBzZXR0ZXIgZm9yIHRoZSBnaXZlbiBwcm9wZXJ0eSB0byByZWZsZWN0IHRoZSBwcm9wZXJ0eSB2YWx1ZVxuICAgICAgICogdG8gYSAoZGFzaC1jYXNlZCkgYXR0cmlidXRlIG9mIHRoZSBzYW1lIG5hbWUuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IG5hbWVcbiAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAqL1xuICAgICAgc3RhdGljIGNyZWF0ZVJlZmxlY3RlZFByb3BlcnR5KHByb3BlcnR5KSB7XG4gICAgICAgIHRoaXMucHJvdG90eXBlLl9jcmVhdGVSZWZsZWN0ZWRQcm9wZXJ0eShwcm9wZXJ0eSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ3JlYXRlcyBhIGNvbXB1dGVkIHByb3BlcnR5IHdob3NlIHZhbHVlIGlzIHNldCB0byB0aGUgcmVzdWx0IG9mIHRoZVxuICAgICAgICogbWV0aG9kIGRlc2NyaWJlZCBieSB0aGUgZ2l2ZW4gYGV4cHJlc3Npb25gIGVhY2ggdGltZSBvbmUgb3IgbW9yZVxuICAgICAgICogYXJndW1lbnRzIHRvIHRoZSBtZXRob2QgY2hhbmdlcy4gIFRoZSBleHByZXNzaW9uIHNob3VsZCBiZSBhIHN0cmluZ1xuICAgICAgICogaW4gdGhlIGZvcm0gb2YgYSBub3JtYWwgSmF2YXNjcmlwdCBmdW5jdGlvbiBzaWduYXR1cmU6XG4gICAgICAgKiBgJ21ldGhvZE5hbWUoYXJnMSwgWy4uLiwgYXJnbl0pJ2BcbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgTmFtZSBvZiBjb21wdXRlZCBwcm9wZXJ0eSB0byBzZXRcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBleHByZXNzaW9uIE1ldGhvZCBleHByZXNzaW9uXG4gICAgICAgKiBAcGFyYW0ge2Jvb2xlYW58T2JqZWN0PX0gZHluYW1pY0ZuIEJvb2xlYW4gb3Igb2JqZWN0IG1hcCBpbmRpY2F0aW5nIHdoZXRoZXJcbiAgICAgICAqICAgbWV0aG9kIG5hbWVzIHNob3VsZCBiZSBpbmNsdWRlZCBhcyBhIGRlcGVuZGVuY3kgdG8gdGhlIGVmZmVjdC5cbiAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAqL1xuICAgICAgc3RhdGljIGNyZWF0ZUNvbXB1dGVkUHJvcGVydHkocHJvcGVydHksIGV4cHJlc3Npb24sIGR5bmFtaWNGbikge1xuICAgICAgICB0aGlzLnByb3RvdHlwZS5fY3JlYXRlQ29tcHV0ZWRQcm9wZXJ0eShwcm9wZXJ0eSwgZXhwcmVzc2lvbiwgZHluYW1pY0ZuKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBQYXJzZXMgdGhlIHByb3ZpZGVkIHRlbXBsYXRlIHRvIGVuc3VyZSBiaW5kaW5nIGVmZmVjdHMgYXJlIGNyZWF0ZWRcbiAgICAgICAqIGZvciB0aGVtLCBhbmQgdGhlbiBlbnN1cmVzIHByb3BlcnR5IGFjY2Vzc29ycyBhcmUgY3JlYXRlZCBmb3IgYW55XG4gICAgICAgKiBkZXBlbmRlbnQgcHJvcGVydGllcyBpbiB0aGUgdGVtcGxhdGUuICBCaW5kaW5nIGVmZmVjdHMgZm9yIGJvdW5kXG4gICAgICAgKiB0ZW1wbGF0ZXMgYXJlIHN0b3JlZCBpbiBhIGxpbmtlZCBsaXN0IG9uIHRoZSBpbnN0YW5jZSBzbyB0aGF0XG4gICAgICAgKiB0ZW1wbGF0ZXMgY2FuIGJlIGVmZmljaWVudGx5IHN0YW1wZWQgYW5kIHVuc3RhbXBlZC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge0hUTUxUZW1wbGF0ZUVsZW1lbnR9IHRlbXBsYXRlIFRlbXBsYXRlIGNvbnRhaW5pbmcgYmluZGluZ1xuICAgICAgICogICBiaW5kaW5nc1xuICAgICAgICogQHJldHVybiB7T2JqZWN0fSBUZW1wbGF0ZSBtZXRhZGF0YSBvYmplY3RcbiAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAqL1xuICAgICAgc3RhdGljIGJpbmRUZW1wbGF0ZSh0ZW1wbGF0ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm90b3R5cGUuX2JpbmRUZW1wbGF0ZSh0ZW1wbGF0ZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIC0tIGJpbmRpbmcgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAvKipcbiAgICAgICAqIEVxdWl2YWxlbnQgdG8gc3RhdGljIGBiaW5kVGVtcGxhdGVgIEFQSSBidXQgY2FuIGJlIGNhbGxlZCBvblxuICAgICAgICogYW4gaW5zdGFuY2UgdG8gYWRkIGVmZmVjdHMgYXQgcnVudGltZS4gIFNlZSB0aGF0IG1ldGhvZCBmb3JcbiAgICAgICAqIGZ1bGwgQVBJIGRvY3MuXG4gICAgICAgKlxuICAgICAgICogVGhpcyBtZXRob2QgbWF5IGJlIGNhbGxlZCBvbiB0aGUgcHJvdG90eXBlIChmb3IgcHJvdG90eXBpY2FsIHRlbXBsYXRlXG4gICAgICAgKiBiaW5kaW5nLCB0byBhdm9pZCBjcmVhdGluZyBhY2Nlc3NvcnMgZXZlcnkgaW5zdGFuY2UpIG9uY2UgcGVyIHByb3RvdHlwZSxcbiAgICAgICAqIGFuZCB3aWxsIGJlIGNhbGxlZCB3aXRoIGBydW50aW1lQmluZGluZzogdHJ1ZWAgYnkgYF9zdGFtcFRlbXBsYXRlYCB0b1xuICAgICAgICogY3JlYXRlIGFuZCBsaW5rIGFuIGluc3RhbmNlIG9mIHRoZSB0ZW1wbGF0ZSBtZXRhZGF0YSBhc3NvY2lhdGVkIHdpdGggYVxuICAgICAgICogcGFydGljdWxhciBzdGFtcGluZy5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge0hUTUxUZW1wbGF0ZUVsZW1lbnR9IHRlbXBsYXRlIFRlbXBsYXRlIGNvbnRhaW5pbmcgYmluZGluZ1xuICAgICAgICogICBiaW5kaW5nc1xuICAgICAgICogQHBhcmFtIHtib29sZWFuPX0gaW5zdGFuY2VCaW5kaW5nIFdoZW4gZmFsc2UgKGRlZmF1bHQpLCBwZXJmb3Jtc1xuICAgICAgICogICBcInByb3RvdHlwaWNhbFwiIGJpbmRpbmcgb2YgdGhlIHRlbXBsYXRlIGFuZCBvdmVyd3JpdGVzIGFueSBwcmV2aW91c2x5XG4gICAgICAgKiAgIGJvdW5kIHRlbXBsYXRlIGZvciB0aGUgY2xhc3MuIFdoZW4gdHJ1ZSAoYXMgcGFzc2VkIGZyb21cbiAgICAgICAqICAgYF9zdGFtcFRlbXBsYXRlYCksIHRoZSB0ZW1wbGF0ZSBpbmZvIGlzIGluc3RhbmNlZCBhbmQgbGlua2VkIGludG9cbiAgICAgICAqICAgdGhlIGxpc3Qgb2YgYm91bmQgdGVtcGxhdGVzLlxuICAgICAgICogQHJldHVybiB7IVRlbXBsYXRlSW5mb30gVGVtcGxhdGUgbWV0YWRhdGEgb2JqZWN0OyBmb3IgYHJ1bnRpbWVCaW5kaW5nYCxcbiAgICAgICAqICAgdGhpcyBpcyBhbiBpbnN0YW5jZSBvZiB0aGUgcHJvdG90eXBpY2FsIHRlbXBsYXRlIGluZm9cbiAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAqL1xuICAgICAgX2JpbmRUZW1wbGF0ZSh0ZW1wbGF0ZSwgaW5zdGFuY2VCaW5kaW5nKSB7XG4gICAgICAgIGxldCB0ZW1wbGF0ZUluZm8gPSB0aGlzLmNvbnN0cnVjdG9yLl9wYXJzZVRlbXBsYXRlKHRlbXBsYXRlKTtcbiAgICAgICAgbGV0IHdhc1ByZUJvdW5kID0gdGhpcy5fX3RlbXBsYXRlSW5mbyA9PSB0ZW1wbGF0ZUluZm87XG4gICAgICAgIC8vIE9wdGltaXphdGlvbjogc2luY2UgdGhpcyBpcyBjYWxsZWQgdHdpY2UgZm9yIHByb3RvLWJvdW5kIHRlbXBsYXRlcyxcbiAgICAgICAgLy8gZG9uJ3QgYXR0ZW1wdCB0byByZWNyZWF0ZSBhY2Nlc3NvcnMgaWYgdGhpcyB0ZW1wbGF0ZSB3YXMgcHJlLWJvdW5kXG4gICAgICAgIGlmICghd2FzUHJlQm91bmQpIHtcbiAgICAgICAgICBmb3IgKGxldCBwcm9wIGluIHRlbXBsYXRlSW5mby5wcm9wZXJ0eUVmZmVjdHMpIHtcbiAgICAgICAgICAgIHRoaXMuX2NyZWF0ZVByb3BlcnR5QWNjZXNzb3IocHJvcCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpbnN0YW5jZUJpbmRpbmcpIHtcbiAgICAgICAgICAvLyBGb3IgaW5zdGFuY2UtdGltZSBiaW5kaW5nLCBjcmVhdGUgaW5zdGFuY2Ugb2YgdGVtcGxhdGUgbWV0YWRhdGFcbiAgICAgICAgICAvLyBhbmQgbGluayBpbnRvIGxpc3Qgb2YgdGVtcGxhdGVzIGlmIG5lY2Vzc2FyeVxuICAgICAgICAgIHRlbXBsYXRlSW5mbyA9IC8qKiBAdHlwZSB7IVRlbXBsYXRlSW5mb30gKi8oT2JqZWN0LmNyZWF0ZSh0ZW1wbGF0ZUluZm8pKTtcbiAgICAgICAgICB0ZW1wbGF0ZUluZm8ud2FzUHJlQm91bmQgPSB3YXNQcmVCb3VuZDtcbiAgICAgICAgICBpZiAoIXdhc1ByZUJvdW5kICYmIHRoaXMuX190ZW1wbGF0ZUluZm8pIHtcbiAgICAgICAgICAgIGxldCBsYXN0ID0gdGhpcy5fX3RlbXBsYXRlSW5mb0xhc3QgfHwgdGhpcy5fX3RlbXBsYXRlSW5mbztcbiAgICAgICAgICAgIHRoaXMuX190ZW1wbGF0ZUluZm9MYXN0ID0gbGFzdC5uZXh0VGVtcGxhdGVJbmZvID0gdGVtcGxhdGVJbmZvO1xuICAgICAgICAgICAgdGVtcGxhdGVJbmZvLnByZXZpb3VzVGVtcGxhdGVJbmZvID0gbGFzdDtcbiAgICAgICAgICAgIHJldHVybiB0ZW1wbGF0ZUluZm87XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9fdGVtcGxhdGVJbmZvID0gdGVtcGxhdGVJbmZvO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEFkZHMgYSBwcm9wZXJ0eSBlZmZlY3QgdG8gdGhlIGdpdmVuIHRlbXBsYXRlIG1ldGFkYXRhLCB3aGljaCBpcyBydW5cbiAgICAgICAqIGF0IHRoZSBcInByb3BhZ2F0ZVwiIHN0YWdlIG9mIGBfcHJvcGVydGllc0NoYW5nZWRgIHdoZW4gdGhlIHRlbXBsYXRlXG4gICAgICAgKiBoYXMgYmVlbiBib3VuZCB0byB0aGUgZWxlbWVudCB2aWEgYF9iaW5kVGVtcGxhdGVgLlxuICAgICAgICpcbiAgICAgICAqIFRoZSBgZWZmZWN0YCBvYmplY3Qgc2hvdWxkIG1hdGNoIHRoZSBmb3JtYXQgaW4gYF9hZGRQcm9wZXJ0eUVmZmVjdGAuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IHRlbXBsYXRlSW5mbyBUZW1wbGF0ZSBtZXRhZGF0YSB0byBhZGQgZWZmZWN0IHRvXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcCBQcm9wZXJ0eSB0aGF0IHNob3VsZCB0cmlnZ2VyIHRoZSBlZmZlY3RcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0PX0gZWZmZWN0IEVmZmVjdCBtZXRhZGF0YSBvYmplY3RcbiAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAqL1xuICAgICAgc3RhdGljIF9hZGRUZW1wbGF0ZVByb3BlcnR5RWZmZWN0KHRlbXBsYXRlSW5mbywgcHJvcCwgZWZmZWN0KSB7XG4gICAgICAgIGxldCBob3N0UHJvcHMgPSB0ZW1wbGF0ZUluZm8uaG9zdFByb3BzID0gdGVtcGxhdGVJbmZvLmhvc3RQcm9wcyB8fCB7fTtcbiAgICAgICAgaG9zdFByb3BzW3Byb3BdID0gdHJ1ZTtcbiAgICAgICAgbGV0IGVmZmVjdHMgPSB0ZW1wbGF0ZUluZm8ucHJvcGVydHlFZmZlY3RzID0gdGVtcGxhdGVJbmZvLnByb3BlcnR5RWZmZWN0cyB8fCB7fTtcbiAgICAgICAgbGV0IHByb3BFZmZlY3RzID0gZWZmZWN0c1twcm9wXSA9IGVmZmVjdHNbcHJvcF0gfHwgW107XG4gICAgICAgIHByb3BFZmZlY3RzLnB1c2goZWZmZWN0KTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBTdGFtcHMgdGhlIHByb3ZpZGVkIHRlbXBsYXRlIGFuZCBwZXJmb3JtcyBpbnN0YW5jZS10aW1lIHNldHVwIGZvclxuICAgICAgICogUG9seW1lciB0ZW1wbGF0ZSBmZWF0dXJlcywgaW5jbHVkaW5nIGRhdGEgYmluZGluZ3MsIGRlY2xhcmF0aXZlIGV2ZW50XG4gICAgICAgKiBsaXN0ZW5lcnMsIGFuZCB0aGUgYHRoaXMuJGAgbWFwIG9mIGBpZGAncyB0byBub2Rlcy4gIEEgZG9jdW1lbnQgZnJhZ21lbnRcbiAgICAgICAqIGlzIHJldHVybmVkIGNvbnRhaW5pbmcgdGhlIHN0YW1wZWQgRE9NLCByZWFkeSBmb3IgaW5zZXJ0aW9uIGludG8gdGhlXG4gICAgICAgKiBET00uXG4gICAgICAgKlxuICAgICAgICogVGhpcyBtZXRob2QgbWF5IGJlIGNhbGxlZCBtb3JlIHRoYW4gb25jZTsgaG93ZXZlciBub3RlIHRoYXQgZHVlIHRvXG4gICAgICAgKiBgc2hhZHljc3NgIHBvbHlmaWxsIGxpbWl0YXRpb25zLCBvbmx5IHN0eWxlcyBmcm9tIHRlbXBsYXRlcyBwcmVwYXJlZFxuICAgICAgICogdXNpbmcgYFNoYWR5Q1NTLnByZXBhcmVUZW1wbGF0ZWAgd2lsbCBiZSBjb3JyZWN0bHkgcG9seWZpbGxlZCAoc2NvcGVkXG4gICAgICAgKiB0byB0aGUgc2hhZG93IHJvb3QgYW5kIHN1cHBvcnQgQ1NTIGN1c3RvbSBwcm9wZXJ0aWVzKSwgYW5kIG5vdGUgdGhhdFxuICAgICAgICogYFNoYWR5Q1NTLnByZXBhcmVUZW1wbGF0ZWAgbWF5IG9ubHkgYmUgY2FsbGVkIG9uY2UgcGVyIGVsZW1lbnQuIEFzIHN1Y2gsXG4gICAgICAgKiBhbnkgc3R5bGVzIHJlcXVpcmVkIGJ5IGluIHJ1bnRpbWUtc3RhbXBlZCB0ZW1wbGF0ZXMgbXVzdCBiZSBpbmNsdWRlZFxuICAgICAgICogaW4gdGhlIG1haW4gZWxlbWVudCB0ZW1wbGF0ZS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0geyFIVE1MVGVtcGxhdGVFbGVtZW50fSB0ZW1wbGF0ZSBUZW1wbGF0ZSB0byBzdGFtcFxuICAgICAgICogQHJldHVybiB7IVN0YW1wZWRUZW1wbGF0ZX0gQ2xvbmVkIHRlbXBsYXRlIGNvbnRlbnRcbiAgICAgICAqIEBvdmVycmlkZVxuICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICovXG4gICAgICBfc3RhbXBUZW1wbGF0ZSh0ZW1wbGF0ZSkge1xuICAgICAgICAvLyBFbnN1cmVzIHRoYXQgY3JlYXRlZCBkb20gaXMgYF9lbnF1ZXVlQ2xpZW50YCdkIHRvIHRoaXMgZWxlbWVudCBzb1xuICAgICAgICAvLyB0aGF0IGl0IGNhbiBiZSBmbHVzaGVkIG9uIG5leHQgY2FsbCB0byBgX2ZsdXNoUHJvcGVydGllc2BcbiAgICAgICAgaG9zdFN0YWNrLmJlZ2luSG9zdGluZyh0aGlzKTtcbiAgICAgICAgbGV0IGRvbSA9IHN1cGVyLl9zdGFtcFRlbXBsYXRlKHRlbXBsYXRlKTtcbiAgICAgICAgaG9zdFN0YWNrLmVuZEhvc3RpbmcodGhpcyk7XG4gICAgICAgIGxldCB0ZW1wbGF0ZUluZm8gPSAvKiogQHR5cGUgeyFUZW1wbGF0ZUluZm99ICovKHRoaXMuX2JpbmRUZW1wbGF0ZSh0ZW1wbGF0ZSwgdHJ1ZSkpO1xuICAgICAgICAvLyBBZGQgdGVtcGxhdGUtaW5zdGFuY2Utc3BlY2lmaWMgZGF0YSB0byBpbnN0YW5jZWQgdGVtcGxhdGVJbmZvXG4gICAgICAgIHRlbXBsYXRlSW5mby5ub2RlTGlzdCA9IGRvbS5ub2RlTGlzdDtcbiAgICAgICAgLy8gQ2FwdHVyZSBjaGlsZCBub2RlcyB0byBhbGxvdyB1bnN0YW1waW5nIG9mIG5vbi1wcm90b3R5cGljYWwgdGVtcGxhdGVzXG4gICAgICAgIGlmICghdGVtcGxhdGVJbmZvLndhc1ByZUJvdW5kKSB7XG4gICAgICAgICAgbGV0IG5vZGVzID0gdGVtcGxhdGVJbmZvLmNoaWxkTm9kZXMgPSBbXTtcbiAgICAgICAgICBmb3IgKGxldCBuPWRvbS5maXJzdENoaWxkOyBuOyBuPW4ubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICAgIG5vZGVzLnB1c2gobik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGRvbS50ZW1wbGF0ZUluZm8gPSB0ZW1wbGF0ZUluZm87XG4gICAgICAgIC8vIFNldHVwIGNvbXBvdW5kIHN0b3JhZ2UsIDItd2F5IGxpc3RlbmVycywgYW5kIGRhdGFIb3N0IGZvciBiaW5kaW5nc1xuICAgICAgICBzZXR1cEJpbmRpbmdzKHRoaXMsIHRlbXBsYXRlSW5mbyk7XG4gICAgICAgIC8vIEZsdXNoIHByb3BlcnRpZXMgaW50byB0ZW1wbGF0ZSBub2RlcyBpZiBhbHJlYWR5IGJvb3RlZFxuICAgICAgICBpZiAodGhpcy5fX2RhdGFSZWFkeSkge1xuICAgICAgICAgIHJ1bkVmZmVjdHModGhpcywgdGVtcGxhdGVJbmZvLnByb3BlcnR5RWZmZWN0cywgdGhpcy5fX2RhdGEsIG51bGwsXG4gICAgICAgICAgICBmYWxzZSwgdGVtcGxhdGVJbmZvLm5vZGVMaXN0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZG9tO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJlbW92ZXMgYW5kIHVuYmluZHMgdGhlIG5vZGVzIHByZXZpb3VzbHkgY29udGFpbmVkIGluIHRoZSBwcm92aWRlZFxuICAgICAgICogRG9jdW1lbnRGcmFnbWVudCByZXR1cm5lZCBmcm9tIGBfc3RhbXBUZW1wbGF0ZWAuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHshU3RhbXBlZFRlbXBsYXRlfSBkb20gRG9jdW1lbnRGcmFnbWVudCBwcmV2aW91c2x5IHJldHVybmVkXG4gICAgICAgKiAgIGZyb20gYF9zdGFtcFRlbXBsYXRlYCBhc3NvY2lhdGVkIHdpdGggdGhlIG5vZGVzIHRvIGJlIHJlbW92ZWRcbiAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAqL1xuICAgICAgX3JlbW92ZUJvdW5kRG9tKGRvbSkge1xuICAgICAgICAvLyBVbmxpbmsgdGVtcGxhdGUgaW5mb1xuICAgICAgICBsZXQgdGVtcGxhdGVJbmZvID0gZG9tLnRlbXBsYXRlSW5mbztcbiAgICAgICAgaWYgKHRlbXBsYXRlSW5mby5wcmV2aW91c1RlbXBsYXRlSW5mbykge1xuICAgICAgICAgIHRlbXBsYXRlSW5mby5wcmV2aW91c1RlbXBsYXRlSW5mby5uZXh0VGVtcGxhdGVJbmZvID1cbiAgICAgICAgICAgIHRlbXBsYXRlSW5mby5uZXh0VGVtcGxhdGVJbmZvO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0ZW1wbGF0ZUluZm8ubmV4dFRlbXBsYXRlSW5mbykge1xuICAgICAgICAgIHRlbXBsYXRlSW5mby5uZXh0VGVtcGxhdGVJbmZvLnByZXZpb3VzVGVtcGxhdGVJbmZvID1cbiAgICAgICAgICAgIHRlbXBsYXRlSW5mby5wcmV2aW91c1RlbXBsYXRlSW5mbztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fX3RlbXBsYXRlSW5mb0xhc3QgPT0gdGVtcGxhdGVJbmZvKSB7XG4gICAgICAgICAgdGhpcy5fX3RlbXBsYXRlSW5mb0xhc3QgPSB0ZW1wbGF0ZUluZm8ucHJldmlvdXNUZW1wbGF0ZUluZm87XG4gICAgICAgIH1cbiAgICAgICAgdGVtcGxhdGVJbmZvLnByZXZpb3VzVGVtcGxhdGVJbmZvID0gdGVtcGxhdGVJbmZvLm5leHRUZW1wbGF0ZUluZm8gPSBudWxsO1xuICAgICAgICAvLyBSZW1vdmUgc3RhbXBlZCBub2Rlc1xuICAgICAgICBsZXQgbm9kZXMgPSB0ZW1wbGF0ZUluZm8uY2hpbGROb2RlcztcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgbGV0IG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgICBub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBPdmVycmlkZXMgZGVmYXVsdCBgVGVtcGxhdGVTdGFtcGAgaW1wbGVtZW50YXRpb24gdG8gYWRkIHN1cHBvcnQgZm9yXG4gICAgICAgKiBwYXJzaW5nIGJpbmRpbmdzIGZyb20gYFRleHROb2RlYCdzJyBgdGV4dENvbnRlbnRgLiAgQSBgYmluZGluZ3NgXG4gICAgICAgKiBhcnJheSBpcyBhZGRlZCB0byBgbm9kZUluZm9gIGFuZCBwb3B1bGF0ZWQgd2l0aCBiaW5kaW5nIG1ldGFkYXRhXG4gICAgICAgKiB3aXRoIGluZm9ybWF0aW9uIGNhcHR1cmluZyB0aGUgYmluZGluZyB0YXJnZXQsIGFuZCBhIGBwYXJ0c2AgYXJyYXlcbiAgICAgICAqIHdpdGggb25lIG9yIG1vcmUgbWV0YWRhdGEgb2JqZWN0cyBjYXB0dXJpbmcgdGhlIHNvdXJjZShzKSBvZiB0aGVcbiAgICAgICAqIGJpbmRpbmcuXG4gICAgICAgKlxuICAgICAgICogQG92ZXJyaWRlXG4gICAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgTm9kZSB0byBwYXJzZVxuICAgICAgICogQHBhcmFtIHtUZW1wbGF0ZUluZm99IHRlbXBsYXRlSW5mbyBUZW1wbGF0ZSBtZXRhZGF0YSBmb3IgY3VycmVudCB0ZW1wbGF0ZVxuICAgICAgICogQHBhcmFtIHtOb2RlSW5mb30gbm9kZUluZm8gTm9kZSBtZXRhZGF0YSBmb3IgY3VycmVudCB0ZW1wbGF0ZSBub2RlXG4gICAgICAgKiBAcmV0dXJuIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIHZpc2l0ZWQgbm9kZSBhZGRlZCBub2RlLXNwZWNpZmljXG4gICAgICAgKiAgIG1ldGFkYXRhIHRvIGBub2RlSW5mb2BcbiAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAqIEBzdXBwcmVzcyB7bWlzc2luZ1Byb3BlcnRpZXN9IEludGVyZmFjZXMgaW4gY2xvc3VyZSBkbyBub3QgaW5oZXJpdCBzdGF0aWNzLCBidXQgY2xhc3NlcyBkb1xuICAgICAgICovXG4gICAgICBzdGF0aWMgX3BhcnNlVGVtcGxhdGVOb2RlKG5vZGUsIHRlbXBsYXRlSW5mbywgbm9kZUluZm8pIHtcbiAgICAgICAgbGV0IG5vdGVkID0gc3VwZXIuX3BhcnNlVGVtcGxhdGVOb2RlKG5vZGUsIHRlbXBsYXRlSW5mbywgbm9kZUluZm8pO1xuICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUpIHtcbiAgICAgICAgICBsZXQgcGFydHMgPSB0aGlzLl9wYXJzZUJpbmRpbmdzKG5vZGUudGV4dENvbnRlbnQsIHRlbXBsYXRlSW5mbyk7XG4gICAgICAgICAgaWYgKHBhcnRzKSB7XG4gICAgICAgICAgICAvLyBJbml0aWFsaXplIHRoZSB0ZXh0Q29udGVudCB3aXRoIGFueSBsaXRlcmFsIHBhcnRzXG4gICAgICAgICAgICAvLyBOT1RFOiBkZWZhdWx0IHRvIGEgc3BhY2UgaGVyZSBzbyB0aGUgdGV4dE5vZGUgcmVtYWluczsgc29tZSBicm93c2Vyc1xuICAgICAgICAgICAgLy8gKElFKSBldmFjaXBhdGUgYW4gZW1wdHkgdGV4dE5vZGUgZm9sbG93aW5nIGNsb25lTm9kZS9pbXBvcnROb2RlLlxuICAgICAgICAgICAgbm9kZS50ZXh0Q29udGVudCA9IGxpdGVyYWxGcm9tUGFydHMocGFydHMpIHx8ICcgJztcbiAgICAgICAgICAgIGFkZEJpbmRpbmcodGhpcywgdGVtcGxhdGVJbmZvLCBub2RlSW5mbywgJ3RleHQnLCAndGV4dENvbnRlbnQnLCBwYXJ0cyk7XG4gICAgICAgICAgICBub3RlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub3RlZDtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBPdmVycmlkZXMgZGVmYXVsdCBgVGVtcGxhdGVTdGFtcGAgaW1wbGVtZW50YXRpb24gdG8gYWRkIHN1cHBvcnQgZm9yXG4gICAgICAgKiBwYXJzaW5nIGJpbmRpbmdzIGZyb20gYXR0cmlidXRlcy4gIEEgYGJpbmRpbmdzYFxuICAgICAgICogYXJyYXkgaXMgYWRkZWQgdG8gYG5vZGVJbmZvYCBhbmQgcG9wdWxhdGVkIHdpdGggYmluZGluZyBtZXRhZGF0YVxuICAgICAgICogd2l0aCBpbmZvcm1hdGlvbiBjYXB0dXJpbmcgdGhlIGJpbmRpbmcgdGFyZ2V0LCBhbmQgYSBgcGFydHNgIGFycmF5XG4gICAgICAgKiB3aXRoIG9uZSBvciBtb3JlIG1ldGFkYXRhIG9iamVjdHMgY2FwdHVyaW5nIHRoZSBzb3VyY2Uocykgb2YgdGhlXG4gICAgICAgKiBiaW5kaW5nLlxuICAgICAgICpcbiAgICAgICAqIEBvdmVycmlkZVxuICAgICAgICogQHBhcmFtIHtFbGVtZW50fSBub2RlIE5vZGUgdG8gcGFyc2VcbiAgICAgICAqIEBwYXJhbSB7VGVtcGxhdGVJbmZvfSB0ZW1wbGF0ZUluZm8gVGVtcGxhdGUgbWV0YWRhdGEgZm9yIGN1cnJlbnQgdGVtcGxhdGVcbiAgICAgICAqIEBwYXJhbSB7Tm9kZUluZm99IG5vZGVJbmZvIE5vZGUgbWV0YWRhdGEgZm9yIGN1cnJlbnQgdGVtcGxhdGUgbm9kZVxuICAgICAgICogQHJldHVybiB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSB2aXNpdGVkIG5vZGUgYWRkZWQgbm9kZS1zcGVjaWZpY1xuICAgICAgICogICBtZXRhZGF0YSB0byBgbm9kZUluZm9gXG4gICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgKiBAc3VwcHJlc3Mge21pc3NpbmdQcm9wZXJ0aWVzfSBJbnRlcmZhY2VzIGluIGNsb3N1cmUgZG8gbm90IGluaGVyaXQgc3RhdGljcywgYnV0IGNsYXNzZXMgZG9cbiAgICAgICAqL1xuICAgICAgc3RhdGljIF9wYXJzZVRlbXBsYXRlTm9kZUF0dHJpYnV0ZShub2RlLCB0ZW1wbGF0ZUluZm8sIG5vZGVJbmZvLCBuYW1lLCB2YWx1ZSkge1xuICAgICAgICBsZXQgcGFydHMgPSB0aGlzLl9wYXJzZUJpbmRpbmdzKHZhbHVlLCB0ZW1wbGF0ZUluZm8pO1xuICAgICAgICBpZiAocGFydHMpIHtcbiAgICAgICAgICAvLyBBdHRyaWJ1dGUgb3IgcHJvcGVydHlcbiAgICAgICAgICBsZXQgb3JpZ05hbWUgPSBuYW1lO1xuICAgICAgICAgIGxldCBraW5kID0gJ3Byb3BlcnR5JztcbiAgICAgICAgICBpZiAobmFtZVtuYW1lLmxlbmd0aC0xXSA9PSAnJCcpIHtcbiAgICAgICAgICAgIG5hbWUgPSBuYW1lLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgICAgIGtpbmQgPSAnYXR0cmlidXRlJztcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gSW5pdGlhbGl6ZSBhdHRyaWJ1dGUgYmluZGluZ3Mgd2l0aCBhbnkgbGl0ZXJhbCBwYXJ0c1xuICAgICAgICAgIGxldCBsaXRlcmFsID0gbGl0ZXJhbEZyb21QYXJ0cyhwYXJ0cyk7XG4gICAgICAgICAgaWYgKGxpdGVyYWwgJiYga2luZCA9PSAnYXR0cmlidXRlJykge1xuICAgICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUobmFtZSwgbGl0ZXJhbCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIENsZWFyIGF0dHJpYnV0ZSBiZWZvcmUgcmVtb3ZpbmcsIHNpbmNlIElFIHdvbid0IGFsbG93IHJlbW92aW5nXG4gICAgICAgICAgLy8gYHZhbHVlYCBhdHRyaWJ1dGUgaWYgaXQgcHJldmlvdXNseSBoYWQgYSB2YWx1ZSAoY2FuJ3RcbiAgICAgICAgICAvLyB1bmNvbmRpdGlvbmFsbHkgc2V0ICcnIGJlZm9yZSByZW1vdmluZyBzaW5jZSBhdHRyaWJ1dGVzIHdpdGggYCRgXG4gICAgICAgICAgLy8gY2FuJ3QgYmUgc2V0IHVzaW5nIHNldEF0dHJpYnV0ZSlcbiAgICAgICAgICBpZiAobm9kZS5sb2NhbE5hbWUgPT09ICdpbnB1dCcgJiYgb3JpZ05hbWUgPT09ICd2YWx1ZScpIHtcbiAgICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKG9yaWdOYW1lLCAnJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFJlbW92ZSBhbm5vdGF0aW9uXG4gICAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUob3JpZ05hbWUpO1xuICAgICAgICAgIC8vIENhc2UgaGFja2VyeTogYXR0cmlidXRlcyBhcmUgbG93ZXItY2FzZSwgYnV0IGJpbmQgdGFyZ2V0c1xuICAgICAgICAgIC8vIChwcm9wZXJ0aWVzKSBhcmUgY2FzZSBzZW5zaXRpdmUuIEdhbWJpdCBpcyB0byBtYXAgZGFzaC1jYXNlIHRvXG4gICAgICAgICAgLy8gY2FtZWwtY2FzZTogYGZvby1iYXJgIGJlY29tZXMgYGZvb0JhcmAuXG4gICAgICAgICAgLy8gQXR0cmlidXRlIGJpbmRpbmdzIGFyZSBleGNlcHRlZC5cbiAgICAgICAgICBpZiAoa2luZCA9PT0gJ3Byb3BlcnR5Jykge1xuICAgICAgICAgICAgbmFtZSA9IFBvbHltZXIuQ2FzZU1hcC5kYXNoVG9DYW1lbENhc2UobmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGFkZEJpbmRpbmcodGhpcywgdGVtcGxhdGVJbmZvLCBub2RlSW5mbywga2luZCwgbmFtZSwgcGFydHMsIGxpdGVyYWwpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBzdXBlci5fcGFyc2VUZW1wbGF0ZU5vZGVBdHRyaWJ1dGUobm9kZSwgdGVtcGxhdGVJbmZvLCBub2RlSW5mbywgbmFtZSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogT3ZlcnJpZGVzIGRlZmF1bHQgYFRlbXBsYXRlU3RhbXBgIGltcGxlbWVudGF0aW9uIHRvIGFkZCBzdXBwb3J0IGZvclxuICAgICAgICogYmluZGluZyB0aGUgcHJvcGVydGllcyB0aGF0IGEgbmVzdGVkIHRlbXBsYXRlIGRlcGVuZHMgb24gdG8gdGhlIHRlbXBsYXRlXG4gICAgICAgKiBhcyBgX2hvc3RfPHByb3BlcnR5PmAuXG4gICAgICAgKlxuICAgICAgICogQG92ZXJyaWRlXG4gICAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgTm9kZSB0byBwYXJzZVxuICAgICAgICogQHBhcmFtIHtUZW1wbGF0ZUluZm99IHRlbXBsYXRlSW5mbyBUZW1wbGF0ZSBtZXRhZGF0YSBmb3IgY3VycmVudCB0ZW1wbGF0ZVxuICAgICAgICogQHBhcmFtIHtOb2RlSW5mb30gbm9kZUluZm8gTm9kZSBtZXRhZGF0YSBmb3IgY3VycmVudCB0ZW1wbGF0ZSBub2RlXG4gICAgICAgKiBAcmV0dXJuIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIHZpc2l0ZWQgbm9kZSBhZGRlZCBub2RlLXNwZWNpZmljXG4gICAgICAgKiAgIG1ldGFkYXRhIHRvIGBub2RlSW5mb2BcbiAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAqIEBzdXBwcmVzcyB7bWlzc2luZ1Byb3BlcnRpZXN9IEludGVyZmFjZXMgaW4gY2xvc3VyZSBkbyBub3QgaW5oZXJpdCBzdGF0aWNzLCBidXQgY2xhc3NlcyBkb1xuICAgICAgICovXG4gICAgICBzdGF0aWMgX3BhcnNlVGVtcGxhdGVOZXN0ZWRUZW1wbGF0ZShub2RlLCB0ZW1wbGF0ZUluZm8sIG5vZGVJbmZvKSB7XG4gICAgICAgIGxldCBub3RlZCA9IHN1cGVyLl9wYXJzZVRlbXBsYXRlTmVzdGVkVGVtcGxhdGUobm9kZSwgdGVtcGxhdGVJbmZvLCBub2RlSW5mbyk7XG4gICAgICAgIC8vIE1lcmdlIGhvc3QgcHJvcHMgaW50byBvdXRlciB0ZW1wbGF0ZSBhbmQgYWRkIGJpbmRpbmdzXG4gICAgICAgIGxldCBob3N0UHJvcHMgPSBub2RlSW5mby50ZW1wbGF0ZUluZm8uaG9zdFByb3BzO1xuICAgICAgICBsZXQgbW9kZSA9ICd7JztcbiAgICAgICAgZm9yIChsZXQgc291cmNlIGluIGhvc3RQcm9wcykge1xuICAgICAgICAgIGxldCBwYXJ0cyA9IFt7IG1vZGUsIHNvdXJjZSwgZGVwZW5kZW5jaWVzOiBbc291cmNlXSB9XTtcbiAgICAgICAgICBhZGRCaW5kaW5nKHRoaXMsIHRlbXBsYXRlSW5mbywgbm9kZUluZm8sICdwcm9wZXJ0eScsICdfaG9zdF8nICsgc291cmNlLCBwYXJ0cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vdGVkO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENhbGxlZCB0byBwYXJzZSB0ZXh0IGluIGEgdGVtcGxhdGUgKGVpdGhlciBhdHRyaWJ1dGUgdmFsdWVzIG9yXG4gICAgICAgKiB0ZXh0Q29udGVudCkgaW50byBiaW5kaW5nIG1ldGFkYXRhLlxuICAgICAgICpcbiAgICAgICAqIEFueSBvdmVycmlkZXMgb2YgdGhpcyBtZXRob2Qgc2hvdWxkIHJldHVybiBhbiBhcnJheSBvZiBiaW5kaW5nIHBhcnRcbiAgICAgICAqIG1ldGFkYXRhICByZXByZXNlbnRpbmcgb25lIG9yIG1vcmUgYmluZGluZ3MgZm91bmQgaW4gdGhlIHByb3ZpZGVkIHRleHRcbiAgICAgICAqIGFuZCBhbnkgXCJsaXRlcmFsXCIgdGV4dCBpbiBiZXR3ZWVuLiAgQW55IG5vbi1saXRlcmFsIHBhcnRzIHdpbGwgYmUgcGFzc2VkXG4gICAgICAgKiB0byBgX2V2YWx1YXRlQmluZGluZ2Agd2hlbiBhbnkgZGVwZW5kZW5jaWVzIGNoYW5nZS4gIFRoZSBvbmx5IHJlcXVpcmVkXG4gICAgICAgKiBmaWVsZHMgb2YgZWFjaCBcInBhcnRcIiBpbiB0aGUgcmV0dXJuZWQgYXJyYXkgYXJlIGFzIGZvbGxvd3M6XG4gICAgICAgKlxuICAgICAgICogLSBgZGVwZW5kZW5jaWVzYCAtIEFycmF5IGNvbnRhaW5pbmcgdHJpZ2dlciBtZXRhZGF0YSBmb3IgZWFjaCBwcm9wZXJ0eVxuICAgICAgICogICB0aGF0IHNob3VsZCB0cmlnZ2VyIHRoZSBiaW5kaW5nIHRvIHVwZGF0ZVxuICAgICAgICogLSBgbGl0ZXJhbGAgLSBTdHJpbmcgY29udGFpbmluZyB0ZXh0IGlmIHRoZSBwYXJ0IHJlcHJlc2VudHMgYSBsaXRlcmFsO1xuICAgICAgICogICBpbiB0aGlzIGNhc2Ugbm8gYGRlcGVuZGVuY2llc2AgYXJlIG5lZWRlZFxuICAgICAgICpcbiAgICAgICAqIEFkZGl0aW9uYWwgbWV0YWRhdGEgZm9yIHVzZSBieSBgX2V2YWx1YXRlQmluZGluZ2AgbWF5IGJlIHByb3ZpZGVkIGluXG4gICAgICAgKiBlYWNoIHBhcnQgb2JqZWN0IGFzIG5lZWRlZC5cbiAgICAgICAqXG4gICAgICAgKiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBoYW5kbGVzIHRoZSBmb2xsb3dpbmcgdHlwZXMgb2YgYmluZGluZ3NcbiAgICAgICAqIChvbmUgb3IgbW9yZSBtYXkgYmUgaW50ZXJtaXhlZCB3aXRoIGxpdGVyYWwgc3RyaW5ncyk6XG4gICAgICAgKiAtIFByb3BlcnR5IGJpbmRpbmc6IGBbW3Byb3BdXWBcbiAgICAgICAqIC0gUGF0aCBiaW5kaW5nOiBgW1tvYmplY3QucHJvcF1dYFxuICAgICAgICogLSBOZWdhdGVkIHByb3BlcnR5IG9yIHBhdGggYmluZGluZ3M6IGBbWyFwcm9wXV1gIG9yIGBbWyFvYmplY3QucHJvcF1dYFxuICAgICAgICogLSBUd28td2F5IHByb3BlcnR5IG9yIHBhdGggYmluZGluZ3MgKHN1cHBvcnRzIG5lZ2F0aW9uKTpcbiAgICAgICAqICAgYHt7cHJvcH19YCwgYHt7b2JqZWN0LnByb3B9fWAsIGB7eyFwcm9wfX1gIG9yIGB7eyFvYmplY3QucHJvcH19YFxuICAgICAgICogLSBJbmxpbmUgY29tcHV0ZWQgbWV0aG9kIChzdXBwb3J0cyBuZWdhdGlvbik6XG4gICAgICAgKiAgIGBbW2NvbXB1dGUoYSwgJ2xpdGVyYWwnLCBiKV1dYCwgYFtbIWNvbXB1dGUoYSwgJ2xpdGVyYWwnLCBiKV1dYFxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IFRleHQgdG8gcGFyc2UgZnJvbSBhdHRyaWJ1dGUgb3IgdGV4dENvbnRlbnRcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0ZW1wbGF0ZUluZm8gQ3VycmVudCB0ZW1wbGF0ZSBtZXRhZGF0YVxuICAgICAgICogQHJldHVybiB7QXJyYXk8IUJpbmRpbmdQYXJ0Pn0gQXJyYXkgb2YgYmluZGluZyBwYXJ0IG1ldGFkYXRhXG4gICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgKi9cbiAgICAgIHN0YXRpYyBfcGFyc2VCaW5kaW5ncyh0ZXh0LCB0ZW1wbGF0ZUluZm8pIHtcbiAgICAgICAgbGV0IHBhcnRzID0gW107XG4gICAgICAgIGxldCBsYXN0SW5kZXggPSAwO1xuICAgICAgICBsZXQgbTtcbiAgICAgICAgLy8gRXhhbXBsZTogXCJsaXRlcmFsMXt7cHJvcH19bGl0ZXJhbDJbWyFjb21wdXRlKGZvbyxiYXIpXV1maW5hbFwiXG4gICAgICAgIC8vIFJlZ2V4IG1hdGNoZXM6XG4gICAgICAgIC8vICAgICAgICBJdGVyYXRpb24gMTogIEl0ZXJhdGlvbiAyOlxuICAgICAgICAvLyBtWzFdOiAne3snICAgICAgICAgICdbWydcbiAgICAgICAgLy8gbVsyXTogJycgICAgICAgICAgICAnISdcbiAgICAgICAgLy8gbVszXTogJ3Byb3AnICAgICAgICAnY29tcHV0ZShmb28sYmFyKSdcbiAgICAgICAgd2hpbGUgKChtID0gYmluZGluZ1JlZ2V4LmV4ZWModGV4dCkpICE9PSBudWxsKSB7XG4gICAgICAgICAgLy8gQWRkIGxpdGVyYWwgcGFydFxuICAgICAgICAgIGlmIChtLmluZGV4ID4gbGFzdEluZGV4KSB7XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKHtsaXRlcmFsOiB0ZXh0LnNsaWNlKGxhc3RJbmRleCwgbS5pbmRleCl9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gQWRkIGJpbmRpbmcgcGFydFxuICAgICAgICAgIGxldCBtb2RlID0gbVsxXVswXTtcbiAgICAgICAgICBsZXQgbmVnYXRlID0gQm9vbGVhbihtWzJdKTtcbiAgICAgICAgICBsZXQgc291cmNlID0gbVszXS50cmltKCk7XG4gICAgICAgICAgbGV0IGN1c3RvbUV2ZW50ID0gZmFsc2UsIG5vdGlmeUV2ZW50ID0gJycsIGNvbG9uID0gLTE7XG4gICAgICAgICAgaWYgKG1vZGUgPT0gJ3snICYmIChjb2xvbiA9IHNvdXJjZS5pbmRleE9mKCc6OicpKSA+IDApIHtcbiAgICAgICAgICAgIG5vdGlmeUV2ZW50ID0gc291cmNlLnN1YnN0cmluZyhjb2xvbiArIDIpO1xuICAgICAgICAgICAgc291cmNlID0gc291cmNlLnN1YnN0cmluZygwLCBjb2xvbik7XG4gICAgICAgICAgICBjdXN0b21FdmVudCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCBzaWduYXR1cmUgPSBwYXJzZU1ldGhvZChzb3VyY2UpO1xuICAgICAgICAgIGxldCBkZXBlbmRlbmNpZXMgPSBbXTtcbiAgICAgICAgICBpZiAoc2lnbmF0dXJlKSB7XG4gICAgICAgICAgICAvLyBJbmxpbmUgY29tcHV0ZWQgZnVuY3Rpb25cbiAgICAgICAgICAgIGxldCB7YXJncywgbWV0aG9kTmFtZX0gPSBzaWduYXR1cmU7XG4gICAgICAgICAgICBmb3IgKGxldCBpPTA7IGk8YXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBsZXQgYXJnID0gYXJnc1tpXTtcbiAgICAgICAgICAgICAgaWYgKCFhcmcubGl0ZXJhbCkge1xuICAgICAgICAgICAgICAgIGRlcGVuZGVuY2llcy5wdXNoKGFyZyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBkeW5hbWljRm5zID0gdGVtcGxhdGVJbmZvLmR5bmFtaWNGbnM7XG4gICAgICAgICAgICBpZiAoZHluYW1pY0ZucyAmJiBkeW5hbWljRm5zW21ldGhvZE5hbWVdIHx8IHNpZ25hdHVyZS5zdGF0aWMpIHtcbiAgICAgICAgICAgICAgZGVwZW5kZW5jaWVzLnB1c2gobWV0aG9kTmFtZSk7XG4gICAgICAgICAgICAgIHNpZ25hdHVyZS5keW5hbWljRm4gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBQcm9wZXJ0eSBvciBwYXRoXG4gICAgICAgICAgICBkZXBlbmRlbmNpZXMucHVzaChzb3VyY2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwYXJ0cy5wdXNoKHtcbiAgICAgICAgICAgIHNvdXJjZSwgbW9kZSwgbmVnYXRlLCBjdXN0b21FdmVudCwgc2lnbmF0dXJlLCBkZXBlbmRlbmNpZXMsXG4gICAgICAgICAgICBldmVudDogbm90aWZ5RXZlbnRcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBsYXN0SW5kZXggPSBiaW5kaW5nUmVnZXgubGFzdEluZGV4O1xuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCBhIGZpbmFsIGxpdGVyYWwgcGFydFxuICAgICAgICBpZiAobGFzdEluZGV4ICYmIGxhc3RJbmRleCA8IHRleHQubGVuZ3RoKSB7XG4gICAgICAgICAgbGV0IGxpdGVyYWwgPSB0ZXh0LnN1YnN0cmluZyhsYXN0SW5kZXgpO1xuICAgICAgICAgIGlmIChsaXRlcmFsKSB7XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKHtcbiAgICAgICAgICAgICAgbGl0ZXJhbDogbGl0ZXJhbFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0cy5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gcGFydHM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDYWxsZWQgdG8gZXZhbHVhdGUgYSBwcmV2aW91c2x5IHBhcnNlZCBiaW5kaW5nIHBhcnQgYmFzZWQgb24gYSBzZXQgb2ZcbiAgICAgICAqIG9uZSBvciBtb3JlIGNoYW5nZWQgZGVwZW5kZW5jaWVzLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7dGhpc30gaW5zdCBFbGVtZW50IHRoYXQgc2hvdWxkIGJlIHVzZWQgYXMgc2NvcGUgZm9yXG4gICAgICAgKiAgIGJpbmRpbmcgZGVwZW5kZW5jaWVzXG4gICAgICAgKiBAcGFyYW0ge0JpbmRpbmdQYXJ0fSBwYXJ0IEJpbmRpbmcgcGFydCBtZXRhZGF0YVxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggUHJvcGVydHkvcGF0aCB0aGF0IHRyaWdnZXJlZCB0aGlzIGVmZmVjdFxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzIEJhZyBvZiBjdXJyZW50IHByb3BlcnR5IGNoYW5nZXNcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvbGRQcm9wcyBCYWcgb2YgcHJldmlvdXMgdmFsdWVzIGZvciBjaGFuZ2VkIHByb3BlcnRpZXNcbiAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaGFzUGF0aHMgVHJ1ZSB3aXRoIGBwcm9wc2AgY29udGFpbnMgb25lIG9yIG1vcmUgcGF0aHNcbiAgICAgICAqIEByZXR1cm4geyp9IFZhbHVlIHRoZSBiaW5kaW5nIHBhcnQgZXZhbHVhdGVkIHRvXG4gICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgKi9cbiAgICAgIHN0YXRpYyBfZXZhbHVhdGVCaW5kaW5nKGluc3QsIHBhcnQsIHBhdGgsIHByb3BzLCBvbGRQcm9wcywgaGFzUGF0aHMpIHtcbiAgICAgICAgbGV0IHZhbHVlO1xuICAgICAgICBpZiAocGFydC5zaWduYXR1cmUpIHtcbiAgICAgICAgICB2YWx1ZSA9IHJ1bk1ldGhvZEVmZmVjdChpbnN0LCBwYXRoLCBwcm9wcywgb2xkUHJvcHMsIHBhcnQuc2lnbmF0dXJlKTtcbiAgICAgICAgfSBlbHNlIGlmIChwYXRoICE9IHBhcnQuc291cmNlKSB7XG4gICAgICAgICAgdmFsdWUgPSBQb2x5bWVyLlBhdGguZ2V0KGluc3QsIHBhcnQuc291cmNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoaGFzUGF0aHMgJiYgUG9seW1lci5QYXRoLmlzUGF0aChwYXRoKSkge1xuICAgICAgICAgICAgdmFsdWUgPSBQb2x5bWVyLlBhdGguZ2V0KGluc3QsIHBhdGgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGluc3QuX19kYXRhW3BhdGhdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydC5uZWdhdGUpIHtcbiAgICAgICAgICB2YWx1ZSA9ICF2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG5cbiAgICB9XG5cbiAgICAvLyBtYWtlIGEgdHlwaW5nIGZvciBjbG9zdXJlIDpQXG4gICAgUHJvcGVydHlFZmZlY3RzVHlwZSA9IFByb3BlcnR5RWZmZWN0cztcblxuICAgIHJldHVybiBQcm9wZXJ0eUVmZmVjdHM7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBIZWxwZXIgYXBpIGZvciBlbnF1ZWluZyBjbGllbnQgZG9tIGNyZWF0ZWQgYnkgYSBob3N0IGVsZW1lbnQuXG4gICAqXG4gICAqIEJ5IGRlZmF1bHQgZWxlbWVudHMgYXJlIGZsdXNoZWQgdmlhIGBfZmx1c2hQcm9wZXJ0aWVzYCB3aGVuXG4gICAqIGBjb25uZWN0ZWRDYWxsYmFja2AgaXMgY2FsbGVkLiBFbGVtZW50cyBhdHRhY2ggdGhlaXIgY2xpZW50IGRvbSB0b1xuICAgKiB0aGVtc2VsdmVzIGF0IGByZWFkeWAgdGltZSB3aGljaCByZXN1bHRzIGZyb20gdGhpcyBmaXJzdCBmbHVzaC5cbiAgICogVGhpcyBwcm92aWRlcyBhbiBvcmRlcmluZyBndWFyYW50ZWUgdGhhdCB0aGUgY2xpZW50IGRvbSBhbiBlbGVtZW50XG4gICAqIGNyZWF0ZXMgaXMgZmx1c2hlZCBiZWZvcmUgdGhlIGVsZW1lbnQgaXRzZWxmIChpLmUuIGNsaWVudCBgcmVhZHlgXG4gICAqIGZpcmVzIGJlZm9yZSBob3N0IGByZWFkeWApLlxuICAgKlxuICAgKiBIb3dldmVyLCBpZiBgX2ZsdXNoUHJvcGVydGllc2AgaXMgY2FsbGVkICpiZWZvcmUqIGFuIGVsZW1lbnQgaXMgY29ubmVjdGVkLFxuICAgKiBhcyBmb3IgZXhhbXBsZSBgVGVtcGxhdGl6ZWAgZG9lcywgdGhpcyBvcmRlcmluZyBndWFyYW50ZWUgY2Fubm90IGJlXG4gICAqIHNhdGlzZmllZCBiZWNhdXNlIG5vIGVsZW1lbnRzIGFyZSBjb25uZWN0ZWQuIChOb3RlOiBCb3VuZCBlbGVtZW50cyB0aGF0XG4gICAqIHJlY2VpdmUgZGF0YSBkbyBiZWNvbWUgZW5xdWV1ZWQgY2xpZW50cyBhbmQgYXJlIHByb3Blcmx5IG9yZGVyZWQgYnV0XG4gICAqIHVuYm91bmQgZWxlbWVudHMgYXJlIG5vdC4pXG4gICAqXG4gICAqIFRvIG1haW50YWluIHRoZSBkZXNpcmVkIFwiY2xpZW50IGJlZm9yZSBob3N0XCIgb3JkZXJpbmcgZ3VhcmFudGVlIGZvciB0aGlzXG4gICAqIGNhc2Ugd2UgcmVseSBvbiB0aGUgXCJob3N0IHN0YWNrLiBDbGllbnQgbm9kZXMgcmVnaXN0ZXJzIHRoZW1zZWx2ZXMgd2l0aFxuICAgKiB0aGUgY3JlYXRpbmcgaG9zdCBlbGVtZW50IHdoZW4gY3JlYXRlZC4gVGhpcyBlbnN1cmVzIHRoYXQgYWxsIGNsaWVudCBkb21cbiAgICogaXMgcmVhZGllZCBpbiB0aGUgcHJvcGVyIG9yZGVyLCBtYWludGFpbmluZyB0aGUgZGVzaXJlZCBndWFyYW50ZWUuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBsZXQgaG9zdFN0YWNrID0ge1xuXG4gICAgc3RhY2s6IFtdLFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHsqfSBpbnN0IEluc3RhbmNlIHRvIGFkZCB0byBob3N0U3RhY2tcbiAgICAgKiBAdGhpcyB7aG9zdFN0YWNrfVxuICAgICAqL1xuICAgIHJlZ2lzdGVySG9zdChpbnN0KSB7XG4gICAgICBpZiAodGhpcy5zdGFjay5sZW5ndGgpIHtcbiAgICAgICAgbGV0IGhvc3QgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoLTFdO1xuICAgICAgICBob3N0Ll9lbnF1ZXVlQ2xpZW50KGluc3QpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyp9IGluc3QgSW5zdGFuY2UgdG8gYmVnaW4gaG9zdGluZ1xuICAgICAqIEB0aGlzIHtob3N0U3RhY2t9XG4gICAgICovXG4gICAgYmVnaW5Ib3N0aW5nKGluc3QpIHtcbiAgICAgIHRoaXMuc3RhY2sucHVzaChpbnN0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHsqfSBpbnN0IEluc3RhbmNlIHRvIGVuZCBob3N0aW5nXG4gICAgICogQHRoaXMge2hvc3RTdGFja31cbiAgICAgKi9cbiAgICBlbmRIb3N0aW5nKGluc3QpIHtcbiAgICAgIGxldCBzdGFja0xlbiA9IHRoaXMuc3RhY2subGVuZ3RoO1xuICAgICAgaWYgKHN0YWNrTGVuICYmIHRoaXMuc3RhY2tbc3RhY2tMZW4tMV0gPT0gaW5zdCkge1xuICAgICAgICB0aGlzLnN0YWNrLnBvcCgpO1xuICAgICAgfVxuICAgIH1cblxuICB9XG5cbn0pKCk7XG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvbWl4aW5zL3Byb3BlcnR5LWVmZmVjdHMuaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCJib290Lmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCJtaXhpbi5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiYXN5bmMuaHRtbFwiPlxuXG48c2NyaXB0PlxuKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLyoqIEB0eXBlZGVmIHt7cnVuOiBmdW5jdGlvbihmdW5jdGlvbigpLCBudW1iZXI9KTpudW1iZXIsIGNhbmNlbDogZnVuY3Rpb24obnVtYmVyKX19ICovXG4gIGxldCBBc3luY01vZHVsZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuXG4gIC8qKlxuICAgKiBAc3VtbWFyeSBDb2xsYXBzZSBtdWx0aXBsZSBjYWxsYmFja3MgaW50byBvbmUgaW52b2NhdGlvbiBhZnRlciBhIHRpbWVyLlxuICAgKiBAbWVtYmVyb2YgUG9seW1lclxuICAgKi9cbiAgY2xhc3MgRGVib3VuY2VyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgIHRoaXMuX2FzeW5jTW9kdWxlID0gbnVsbDtcbiAgICAgIHRoaXMuX2NhbGxiYWNrID0gbnVsbDtcbiAgICAgIHRoaXMuX3RpbWVyID0gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgc2NoZWR1bGVyOyB0aGF0IGlzLCBhIG1vZHVsZSB3aXRoIHRoZSBBc3luYyBpbnRlcmZhY2UsXG4gICAgICogYSBjYWxsYmFjayBhbmQgb3B0aW9uYWwgYXJndW1lbnRzIHRvIGJlIHBhc3NlZCB0byB0aGUgcnVuIGZ1bmN0aW9uXG4gICAgICogZnJvbSB0aGUgYXN5bmMgbW9kdWxlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHshQXN5bmNNb2R1bGV9IGFzeW5jTW9kdWxlIE9iamVjdCB3aXRoIEFzeW5jIGludGVyZmFjZS5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCl9IGNhbGxiYWNrIENhbGxiYWNrIHRvIHJ1bi5cbiAgICAgKi9cbiAgICBzZXRDb25maWcoYXN5bmNNb2R1bGUsIGNhbGxiYWNrKSB7XG4gICAgICB0aGlzLl9hc3luY01vZHVsZSA9IGFzeW5jTW9kdWxlO1xuICAgICAgdGhpcy5fY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgIHRoaXMuX3RpbWVyID0gdGhpcy5fYXN5bmNNb2R1bGUucnVuKCgpID0+IHtcbiAgICAgICAgdGhpcy5fdGltZXIgPSBudWxsO1xuICAgICAgICB0aGlzLl9jYWxsYmFjaygpXG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FuY2VscyBhbiBhY3RpdmUgZGVib3VuY2VyIGFuZCByZXR1cm5zIGEgcmVmZXJlbmNlIHRvIGl0c2VsZi5cbiAgICAgKi9cbiAgICBjYW5jZWwoKSB7XG4gICAgICBpZiAodGhpcy5pc0FjdGl2ZSgpKSB7XG4gICAgICAgIHRoaXMuX2FzeW5jTW9kdWxlLmNhbmNlbCh0aGlzLl90aW1lcik7XG4gICAgICAgIHRoaXMuX3RpbWVyID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRmx1c2hlcyBhbiBhY3RpdmUgZGVib3VuY2VyIGFuZCByZXR1cm5zIGEgcmVmZXJlbmNlIHRvIGl0c2VsZi5cbiAgICAgKi9cbiAgICBmbHVzaCgpIHtcbiAgICAgIGlmICh0aGlzLmlzQWN0aXZlKCkpIHtcbiAgICAgICAgdGhpcy5jYW5jZWwoKTtcbiAgICAgICAgdGhpcy5fY2FsbGJhY2soKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBkZWJvdW5jZXIgaXMgYWN0aXZlLlxuICAgICAqXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBhY3RpdmUuXG4gICAgICovXG4gICAgaXNBY3RpdmUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdGltZXIgIT0gbnVsbDtcbiAgICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgZGVib3VuY2VyIGlmIG5vIGRlYm91bmNlciBpcyBwYXNzZWQgYXMgYSBwYXJhbWV0ZXJcbiAgICogb3IgaXQgY2FuY2VscyBhbiBhY3RpdmUgZGVib3VuY2VyIG90aGVyd2lzZS4gVGhlIGZvbGxvd2luZ1xuICAgKiBleGFtcGxlIHNob3dzIGhvdyBhIGRlYm91bmNlciBjYW4gYmUgY2FsbGVkIG11bHRpcGxlIHRpbWVzIHdpdGhpbiBhXG4gICAqIG1pY3JvdGFzayBhbmQgXCJkZWJvdW5jZWRcIiBzdWNoIHRoYXQgdGhlIHByb3ZpZGVkIGNhbGxiYWNrIGZ1bmN0aW9uIGlzXG4gICAqIGNhbGxlZCBvbmNlLiBBZGQgdGhpcyBtZXRob2QgdG8gYSBjdXN0b20gZWxlbWVudDpcbiAgICpcbiAgICogX2RlYm91bmNlV29yaygpIHtcbiAgICogICB0aGlzLl9kZWJvdW5jZUpvYiA9IFBvbHltZXIuRGVib3VuY2VyLmRlYm91bmNlKHRoaXMuX2RlYm91bmNlSm9iLFxuICAgKiAgICAgICBQb2x5bWVyLkFzeW5jLm1pY3JvVGFzaywgKCkgPT4ge1xuICAgKiAgICAgdGhpcy5fZG9Xb3JrKCk7XG4gICAqICAgfSk7XG4gICAqIH1cbiAgICpcbiAgICogSWYgdGhlIGBfZGVib3VuY2VXb3JrYCBtZXRob2QgaXMgY2FsbGVkIG11bHRpcGxlIHRpbWVzIHdpdGhpbiB0aGUgc2FtZVxuICAgKiBtaWNyb3Rhc2ssIHRoZSBgX2RvV29ya2AgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgb25seSBvbmNlIGF0IHRoZSBuZXh0XG4gICAqIG1pY3JvdGFzayBjaGVja3BvaW50LlxuICAgKlxuICAgKiBOb3RlOiBJbiB0ZXN0aW5nIGl0IGlzIG9mdGVuIGNvbnZlbmllbnQgdG8gYXZvaWQgYXN5bmNocm9ueS4gVG8gYWNjb21wbGlzaFxuICAgKiB0aGlzIHdpdGggYSBkZWJvdW5jZXIsIHlvdSBjYW4gdXNlIGBQb2x5bWVyLmVucXVldWVEZWJvdW5jZXJgIGFuZFxuICAgKiBgUG9seW1lci5mbHVzaGAuIEZvciBleGFtcGxlLCBleHRlbmQgdGhlIGFib3ZlIGV4YW1wbGUgYnkgYWRkaW5nXG4gICAqIGBQb2x5bWVyLmVucXVldWVEZWJvdW5jZXIodGhpcy5fZGVib3VuY2VKb2IpYCBhdCB0aGUgZW5kIG9mIHRoZVxuICAgKiBgX2RlYm91bmNlV29ya2AgbWV0aG9kLiBUaGVuIGluIGEgdGVzdCwgY2FsbCBgUG9seW1lci5mbHVzaGAgdG8gZW5zdXJlXG4gICAqIHRoZSBkZWJvdW5jZXIgaGFzIGNvbXBsZXRlZC5cbiAgICpcbiAgICogQHBhcmFtIHtEZWJvdW5jZXI/fSBkZWJvdW5jZXIgRGVib3VuY2VyIG9iamVjdC5cbiAgICogQHBhcmFtIHshQXN5bmNNb2R1bGV9IGFzeW5jTW9kdWxlIE9iamVjdCB3aXRoIEFzeW5jIGludGVyZmFjZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCl9IGNhbGxiYWNrIENhbGxiYWNrIHRvIHJ1bi5cbiAgICogQHJldHVybiB7IURlYm91bmNlcn0gUmV0dXJucyBhIGRlYm91bmNlciBvYmplY3QuXG4gICAqL1xuICAgIHN0YXRpYyBkZWJvdW5jZShkZWJvdW5jZXIsIGFzeW5jTW9kdWxlLCBjYWxsYmFjaykge1xuICAgICAgaWYgKGRlYm91bmNlciBpbnN0YW5jZW9mIERlYm91bmNlcikge1xuICAgICAgICBkZWJvdW5jZXIuY2FuY2VsKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWJvdW5jZXIgPSBuZXcgRGVib3VuY2VyKCk7XG4gICAgICB9XG4gICAgICBkZWJvdW5jZXIuc2V0Q29uZmlnKGFzeW5jTW9kdWxlLCBjYWxsYmFjayk7XG4gICAgICByZXR1cm4gZGVib3VuY2VyO1xuICAgIH1cbiAgfVxuXG4gIFBvbHltZXIuRGVib3VuY2VyID0gRGVib3VuY2VyO1xufSkoKTtcbjwvc2NyaXB0PlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi91dGlscy9kZWJvdW5jZS5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cImJvb3QuaHRtbFwiPlxuPHNjcmlwdD5cbihmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIGxldCBkZWJvdW5jZXJRdWV1ZSA9IFtdO1xuXG4gIC8qKlxuICAgKiBBZGRzIGEgYFBvbHltZXIuRGVib3VuY2VyYCB0byBhIGxpc3Qgb2YgZ2xvYmFsbHkgZmx1c2hhYmxlIHRhc2tzLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgUG9seW1lclxuICAgKiBAcGFyYW0ge1BvbHltZXIuRGVib3VuY2VyfSBkZWJvdW5jZXIgRGVib3VuY2VyIHRvIGVucXVldWVcbiAgICovXG4gIFBvbHltZXIuZW5xdWV1ZURlYm91bmNlciA9IGZ1bmN0aW9uKGRlYm91bmNlcikge1xuICAgIGRlYm91bmNlclF1ZXVlLnB1c2goZGVib3VuY2VyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZsdXNoRGVib3VuY2VycygpIHtcbiAgICBjb25zdCBkaWRGbHVzaCA9IEJvb2xlYW4oZGVib3VuY2VyUXVldWUubGVuZ3RoKTtcbiAgICB3aGlsZSAoZGVib3VuY2VyUXVldWUubGVuZ3RoKSB7XG4gICAgICB0cnkge1xuICAgICAgICBkZWJvdW5jZXJRdWV1ZS5zaGlmdCgpLmZsdXNoKCk7XG4gICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkaWRGbHVzaDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGb3JjZXMgc2V2ZXJhbCBjbGFzc2VzIG9mIGFzeW5jaHJvbm91c2x5IHF1ZXVlZCB0YXNrcyB0byBmbHVzaDpcbiAgICogLSBEZWJvdW5jZXJzIGFkZGVkIHZpYSBgZW5xdWV1ZURlYm91bmNlcmBcbiAgICogLSBTaGFkeURPTSBkaXN0cmlidXRpb25cbiAgICpcbiAgICogQG1lbWJlcm9mIFBvbHltZXJcbiAgICovXG4gIFBvbHltZXIuZmx1c2ggPSBmdW5jdGlvbigpIHtcbiAgICBsZXQgc2hhZHlET00sIGRlYm91bmNlcnM7XG4gICAgZG8ge1xuICAgICAgc2hhZHlET00gPSB3aW5kb3cuU2hhZHlET00gJiYgU2hhZHlET00uZmx1c2goKTtcbiAgICAgIGlmICh3aW5kb3cuU2hhZHlDU1MgJiYgd2luZG93LlNoYWR5Q1NTLlNjb3BpbmdTaGltKSB7XG4gICAgICAgIHdpbmRvdy5TaGFkeUNTUy5TY29waW5nU2hpbS5mbHVzaCgpO1xuICAgICAgfVxuICAgICAgZGVib3VuY2VycyA9IGZsdXNoRGVib3VuY2VycygpO1xuICAgIH0gd2hpbGUgKHNoYWR5RE9NIHx8IGRlYm91bmNlcnMpO1xuICB9XG5cbn0pKCk7XG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvdXRpbHMvZmx1c2guaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cblxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cImJvb3QuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL21peGlucy9wcm9wZXJ0eS1lZmZlY3RzLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi9taXhpbnMvbXV0YWJsZS1kYXRhLmh0bWxcIj5cblxuPHNjcmlwdD5cbiAgKGZ1bmN0aW9uKCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIC8vIEJhc2UgY2xhc3MgZm9yIEhUTUxUZW1wbGF0ZUVsZW1lbnQgZXh0ZW5zaW9uIHRoYXQgaGFzIHByb3BlcnR5IGVmZmVjdHNcbiAgICAvLyBtYWNoaW5lcnkgZm9yIHByb3BhZ2F0aW5nIGhvc3QgcHJvcGVydGllcyB0byBjaGlsZHJlbi4gVGhpcyBpcyBhbiBFUzVcbiAgICAvLyBjbGFzcyBvbmx5IGJlY2F1c2UgQmFiZWwgKGluY29ycmVjdGx5KSByZXF1aXJlcyBzdXBlcigpIGluIHRoZSBjbGFzc1xuICAgIC8vIGNvbnN0cnVjdG9yIGV2ZW4gdGhvdWdoIG5vIGB0aGlzYCBpcyB1c2VkIGFuZCBpdCByZXR1cm5zIGFuIGluc3RhbmNlLlxuICAgIGxldCBuZXdJbnN0YW5jZSA9IG51bGw7XG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQGV4dGVuZHMge0hUTUxUZW1wbGF0ZUVsZW1lbnR9XG4gICAgICovXG4gICAgZnVuY3Rpb24gSFRNTFRlbXBsYXRlRWxlbWVudEV4dGVuc2lvbigpIHsgcmV0dXJuIG5ld0luc3RhbmNlOyB9XG4gICAgSFRNTFRlbXBsYXRlRWxlbWVudEV4dGVuc2lvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEhUTUxUZW1wbGF0ZUVsZW1lbnQucHJvdG90eXBlLCB7XG4gICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICB2YWx1ZTogSFRNTFRlbXBsYXRlRWxlbWVudEV4dGVuc2lvbixcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAaW1wbGVtZW50cyB7UG9seW1lcl9Qcm9wZXJ0eUVmZmVjdHN9XG4gICAgICogQGV4dGVuZHMge0hUTUxUZW1wbGF0ZUVsZW1lbnRFeHRlbnNpb259XG4gICAgICovXG4gICAgY29uc3QgRGF0YVRlbXBsYXRlID0gUG9seW1lci5Qcm9wZXJ0eUVmZmVjdHMoSFRNTFRlbXBsYXRlRWxlbWVudEV4dGVuc2lvbik7XG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQGltcGxlbWVudHMge1BvbHltZXJfTXV0YWJsZURhdGF9XG4gICAgICogQGV4dGVuZHMge0RhdGFUZW1wbGF0ZX1cbiAgICAgKi9cbiAgICBjb25zdCBNdXRhYmxlRGF0YVRlbXBsYXRlID0gUG9seW1lci5NdXRhYmxlRGF0YShEYXRhVGVtcGxhdGUpO1xuXG4gICAgLy8gQXBwbGllcyBhIERhdGFUZW1wbGF0ZSBzdWJjbGFzcyB0byBhIDx0ZW1wbGF0ZT4gaW5zdGFuY2VcbiAgICBmdW5jdGlvbiB1cGdyYWRlVGVtcGxhdGUodGVtcGxhdGUsIGNvbnN0cnVjdG9yKSB7XG4gICAgICBuZXdJbnN0YW5jZSA9IHRlbXBsYXRlO1xuICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRlbXBsYXRlLCBjb25zdHJ1Y3Rvci5wcm90b3R5cGUpO1xuICAgICAgbmV3IGNvbnN0cnVjdG9yKCk7XG4gICAgICBuZXdJbnN0YW5jZSA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gQmFzZSBjbGFzcyBmb3IgVGVtcGxhdGVJbnN0YW5jZSdzXG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQGltcGxlbWVudHMge1BvbHltZXJfUHJvcGVydHlFZmZlY3RzfVxuICAgICAqL1xuICAgIGNvbnN0IGJhc2UgPSBQb2x5bWVyLlByb3BlcnR5RWZmZWN0cyhjbGFzcyB7fSk7XG5cbiAgICAvKipcbiAgICAgKiBAcG9seW1lclxuICAgICAqIEBjdXN0b21FbGVtZW50XG4gICAgICogQGFwcGxpZXNNaXhpbiBQb2x5bWVyLlByb3BlcnR5RWZmZWN0c1xuICAgICAqIEB1bnJlc3RyaWN0ZWRcbiAgICAgKi9cbiAgICBjbGFzcyBUZW1wbGF0ZUluc3RhbmNlQmFzZSBleHRlbmRzIGJhc2Uge1xuICAgICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5fY29uZmlndXJlUHJvcGVydGllcyhwcm9wcyk7XG4gICAgICAgIHRoaXMucm9vdCA9IHRoaXMuX3N0YW1wVGVtcGxhdGUodGhpcy5fX2RhdGFIb3N0KTtcbiAgICAgICAgLy8gU2F2ZSBsaXN0IG9mIHN0YW1wZWQgY2hpbGRyZW5cbiAgICAgICAgbGV0IGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbiA9IFtdO1xuICAgICAgICBmb3IgKGxldCBuID0gdGhpcy5yb290LmZpcnN0Q2hpbGQ7IG47IG49bi5uZXh0U2libGluZykge1xuICAgICAgICAgIGNoaWxkcmVuLnB1c2gobik7XG4gICAgICAgICAgbi5fX3RlbXBsYXRpemVJbnN0YW5jZSA9IHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX190ZW1wbGF0aXplT3duZXIuX19oaWRlVGVtcGxhdGVDaGlsZHJlbl9fKSB7XG4gICAgICAgICAgdGhpcy5fc2hvd0hpZGVDaGlsZHJlbih0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGbHVzaCBwcm9wcyBvbmx5IHdoZW4gcHJvcHMgYXJlIHBhc3NlZCBpZiBpbnN0YW5jZSBwcm9wcyBleGlzdFxuICAgICAgICAvLyBvciB3aGVuIHRoZXJlIGlzbid0IGluc3RhbmNlIHByb3BzLlxuICAgICAgICBsZXQgb3B0aW9ucyA9IHRoaXMuX190ZW1wbGF0aXplT3B0aW9ucztcbiAgICAgICAgaWYgKChwcm9wcyAmJiBvcHRpb25zLmluc3RhbmNlUHJvcHMpIHx8ICFvcHRpb25zLmluc3RhbmNlUHJvcHMpIHtcbiAgICAgICAgICB0aGlzLl9lbmFibGVQcm9wZXJ0aWVzKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogQ29uZmlndXJlIHRoZSBnaXZlbiBgcHJvcHNgIGJ5IGNhbGxpbmcgYF9zZXRQZW5kaW5nUHJvcGVydHlgLiBBbHNvXG4gICAgICAgKiBzZXRzIGFueSBwcm9wZXJ0aWVzIHN0b3JlZCBpbiBgX19ob3N0UHJvcHNgLlxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBPYmplY3Qgb2YgcHJvcGVydHkgbmFtZS12YWx1ZSBwYWlycyB0byBzZXQuXG4gICAgICAgKi9cbiAgICAgIF9jb25maWd1cmVQcm9wZXJ0aWVzKHByb3BzKSB7XG4gICAgICAgIGxldCBvcHRpb25zID0gdGhpcy5fX3RlbXBsYXRpemVPcHRpb25zO1xuICAgICAgICBpZiAocHJvcHMpIHtcbiAgICAgICAgICBmb3IgKGxldCBpcHJvcCBpbiBvcHRpb25zLmluc3RhbmNlUHJvcHMpIHtcbiAgICAgICAgICAgIGlmIChpcHJvcCBpbiBwcm9wcykge1xuICAgICAgICAgICAgICB0aGlzLl9zZXRQZW5kaW5nUHJvcGVydHkoaXByb3AsIHByb3BzW2lwcm9wXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGhwcm9wIGluIHRoaXMuX19ob3N0UHJvcHMpIHtcbiAgICAgICAgICB0aGlzLl9zZXRQZW5kaW5nUHJvcGVydHkoaHByb3AsIHRoaXMuX19kYXRhSG9zdFsnX2hvc3RfJyArIGhwcm9wXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogRm9yd2FyZHMgYSBob3N0IHByb3BlcnR5IHRvIHRoaXMgaW5zdGFuY2UuICBUaGlzIG1ldGhvZCBzaG91bGQgYmVcbiAgICAgICAqIGNhbGxlZCBvbiBpbnN0YW5jZXMgZnJvbSB0aGUgYG9wdGlvbnMuZm9yd2FyZEhvc3RQcm9wYCBjYWxsYmFja1xuICAgICAgICogdG8gcHJvcGFnYXRlIGNoYW5nZXMgb2YgaG9zdCBwcm9wZXJ0aWVzIHRvIGVhY2ggaW5zdGFuY2UuXG4gICAgICAgKlxuICAgICAgICogTm90ZSB0aGlzIG1ldGhvZCBlbnF1ZXVlcyB0aGUgY2hhbmdlLCB3aGljaCBhcmUgZmx1c2hlZCBhcyBhIGJhdGNoLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wIFByb3BlcnR5IG9yIHBhdGggbmFtZVxuICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSBvZiB0aGUgcHJvcGVydHkgdG8gZm9yd2FyZFxuICAgICAgICovXG4gICAgICBmb3J3YXJkSG9zdFByb3AocHJvcCwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuX3NldFBlbmRpbmdQcm9wZXJ0eU9yUGF0aChwcm9wLCB2YWx1ZSwgZmFsc2UsIHRydWUpKSB7XG4gICAgICAgICAgdGhpcy5fX2RhdGFIb3N0Ll9lbnF1ZXVlQ2xpZW50KHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIEBvdmVycmlkZVxuICAgICAgICovXG4gICAgICBfYWRkRXZlbnRMaXN0ZW5lclRvTm9kZShub2RlLCBldmVudE5hbWUsIGhhbmRsZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuX21ldGhvZEhvc3QgJiYgdGhpcy5fX3RlbXBsYXRpemVPcHRpb25zLnBhcmVudE1vZGVsKSB7XG4gICAgICAgICAgLy8gSWYgdGhpcyBpbnN0YW5jZSBzaG91bGQgYmUgY29uc2lkZXJlZCBhIHBhcmVudCBtb2RlbCwgZGVjb3JhdGVcbiAgICAgICAgICAvLyBldmVudHMgdGhpcyB0ZW1wbGF0ZSBpbnN0YW5jZSBhcyBgbW9kZWxgXG4gICAgICAgICAgdGhpcy5fbWV0aG9kSG9zdC5fYWRkRXZlbnRMaXN0ZW5lclRvTm9kZShub2RlLCBldmVudE5hbWUsIChlKSA9PiB7XG4gICAgICAgICAgICBlLm1vZGVsID0gdGhpcztcbiAgICAgICAgICAgIGhhbmRsZXIoZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gT3RoZXJ3aXNlIGRlbGVnYXRlIHRvIHRoZSB0ZW1wbGF0ZSdzIGhvc3QgKHdoaWNoIGNvdWxkIGJlKVxuICAgICAgICAgIC8vIGFub3RoZXIgdGVtcGxhdGUgaW5zdGFuY2VcbiAgICAgICAgICBsZXQgdGVtcGxhdGVIb3N0ID0gdGhpcy5fX2RhdGFIb3N0Ll9fZGF0YUhvc3Q7XG4gICAgICAgICAgaWYgKHRlbXBsYXRlSG9zdCkge1xuICAgICAgICAgICAgdGVtcGxhdGVIb3N0Ll9hZGRFdmVudExpc3RlbmVyVG9Ob2RlKG5vZGUsIGV2ZW50TmFtZSwgaGFuZGxlcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIFNob3dzIG9yIGhpZGVzIHRoZSB0ZW1wbGF0ZSBpbnN0YW5jZSB0b3AgbGV2ZWwgY2hpbGQgZWxlbWVudHMuIEZvclxuICAgICAgICogdGV4dCBub2RlcywgYHRleHRDb250ZW50YCBpcyByZW1vdmVkIHdoaWxlIFwiaGlkZGVuXCIgYW5kIHJlcGxhY2VkIHdoZW5cbiAgICAgICAqIFwic2hvd24uXCJcbiAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaGlkZSBTZXQgdG8gdHJ1ZSB0byBoaWRlIHRoZSBjaGlsZHJlbjtcbiAgICAgICAqIHNldCB0byBmYWxzZSB0byBzaG93IHRoZW0uXG4gICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgKi9cbiAgICAgIF9zaG93SGlkZUNoaWxkcmVuKGhpZGUpIHtcbiAgICAgICAgbGV0IGMgPSB0aGlzLmNoaWxkcmVuO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8Yy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGxldCBuID0gY1tpXTtcbiAgICAgICAgICAvLyBJZ25vcmUgbm9uLWNoYW5nZXNcbiAgICAgICAgICBpZiAoQm9vbGVhbihoaWRlKSAhPSBCb29sZWFuKG4uX19oaWRlVGVtcGxhdGVDaGlsZHJlbl9fKSkge1xuICAgICAgICAgICAgaWYgKG4ubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFKSB7XG4gICAgICAgICAgICAgIGlmIChoaWRlKSB7XG4gICAgICAgICAgICAgICAgbi5fX3BvbHltZXJUZXh0Q29udGVudF9fID0gbi50ZXh0Q29udGVudDtcbiAgICAgICAgICAgICAgICBuLnRleHRDb250ZW50ID0gJyc7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbi50ZXh0Q29udGVudCA9IG4uX19wb2x5bWVyVGV4dENvbnRlbnRfXztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChuLnN0eWxlKSB7XG4gICAgICAgICAgICAgIGlmIChoaWRlKSB7XG4gICAgICAgICAgICAgICAgbi5fX3BvbHltZXJEaXNwbGF5X18gPSBuLnN0eWxlLmRpc3BsYXk7XG4gICAgICAgICAgICAgICAgbi5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG4uc3R5bGUuZGlzcGxheSA9IG4uX19wb2x5bWVyRGlzcGxheV9fO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIG4uX19oaWRlVGVtcGxhdGVDaGlsZHJlbl9fID0gaGlkZTtcbiAgICAgICAgICBpZiAobi5fc2hvd0hpZGVDaGlsZHJlbikge1xuICAgICAgICAgICAgbi5fc2hvd0hpZGVDaGlsZHJlbihoaWRlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogT3ZlcnJpZGVzIGRlZmF1bHQgcHJvcGVydHktZWZmZWN0cyBpbXBsZW1lbnRhdGlvbiB0byBpbnRlcmNlcHRcbiAgICAgICAqIHRleHRDb250ZW50IGJpbmRpbmdzIHdoaWxlIGNoaWxkcmVuIGFyZSBcImhpZGRlblwiIGFuZCBjYWNoZSBpblxuICAgICAgICogcHJpdmF0ZSBzdG9yYWdlIGZvciBsYXRlciByZXRyaWV2YWwuXG4gICAgICAgKlxuICAgICAgICogQG92ZXJyaWRlXG4gICAgICAgKi9cbiAgICAgIF9zZXRVbm1hbmFnZWRQcm9wZXJ0eVRvTm9kZShub2RlLCBwcm9wLCB2YWx1ZSkge1xuICAgICAgICBpZiAobm9kZS5fX2hpZGVUZW1wbGF0ZUNoaWxkcmVuX18gJiZcbiAgICAgICAgICAgIG5vZGUubm9kZVR5cGUgPT0gTm9kZS5URVhUX05PREUgJiYgcHJvcCA9PSAndGV4dENvbnRlbnQnKSB7XG4gICAgICAgICAgbm9kZS5fX3BvbHltZXJUZXh0Q29udGVudF9fID0gdmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3VwZXIuX3NldFVubWFuYWdlZFByb3BlcnR5VG9Ob2RlKG5vZGUsIHByb3AsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBGaW5kIHRoZSBwYXJlbnQgbW9kZWwgb2YgdGhpcyB0ZW1wbGF0ZSBpbnN0YW5jZS4gIFRoZSBwYXJlbnQgbW9kZWxcbiAgICAgICAqIGlzIGVpdGhlciBhbm90aGVyIHRlbXBsYXRpemUgaW5zdGFuY2UgdGhhdCBoYWQgb3B0aW9uIGBwYXJlbnRNb2RlbDogdHJ1ZWAsXG4gICAgICAgKiBvciBlbHNlIHRoZSBob3N0IGVsZW1lbnQuXG4gICAgICAgKlxuICAgICAgICogQHJldHVybiB7UG9seW1lcl9Qcm9wZXJ0eUVmZmVjdHN9IFRoZSBwYXJlbnQgbW9kZWwgb2YgdGhpcyBpbnN0YW5jZVxuICAgICAgICovXG4gICAgICBnZXQgcGFyZW50TW9kZWwoKSB7XG4gICAgICAgIGxldCBtb2RlbCA9IHRoaXMuX19wYXJlbnRNb2RlbDtcbiAgICAgICAgaWYgKCFtb2RlbCkge1xuICAgICAgICAgIGxldCBvcHRpb25zO1xuICAgICAgICAgIG1vZGVsID0gdGhpc1xuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIC8vIEEgdGVtcGxhdGUgaW5zdGFuY2UncyBgX19kYXRhSG9zdGAgaXMgYSA8dGVtcGxhdGU+XG4gICAgICAgICAgICAvLyBgbW9kZWwuX19kYXRhSG9zdC5fX2RhdGFIb3N0YCBpcyB0aGUgdGVtcGxhdGUncyBob3N0XG4gICAgICAgICAgICBtb2RlbCA9IG1vZGVsLl9fZGF0YUhvc3QuX19kYXRhSG9zdDtcbiAgICAgICAgICB9IHdoaWxlICgob3B0aW9ucyA9IG1vZGVsLl9fdGVtcGxhdGl6ZU9wdGlvbnMpICYmICFvcHRpb25zLnBhcmVudE1vZGVsKVxuICAgICAgICAgIHRoaXMuX19wYXJlbnRNb2RlbCA9IG1vZGVsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtb2RlbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogQHR5cGUgeyFEYXRhVGVtcGxhdGV9ICovXG4gICAgVGVtcGxhdGVJbnN0YW5jZUJhc2UucHJvdG90eXBlLl9fZGF0YUhvc3Q7XG4gICAgLyoqIEB0eXBlIHshVGVtcGxhdGl6ZU9wdGlvbnN9ICovXG4gICAgVGVtcGxhdGVJbnN0YW5jZUJhc2UucHJvdG90eXBlLl9fdGVtcGxhdGl6ZU9wdGlvbnM7XG4gICAgLyoqIEB0eXBlIHshUG9seW1lcl9Qcm9wZXJ0eUVmZmVjdHN9ICovXG4gICAgVGVtcGxhdGVJbnN0YW5jZUJhc2UucHJvdG90eXBlLl9tZXRob2RIb3N0O1xuICAgIC8qKiBAdHlwZSB7IU9iamVjdH0gKi9cbiAgICBUZW1wbGF0ZUluc3RhbmNlQmFzZS5wcm90b3R5cGUuX190ZW1wbGF0aXplT3duZXI7XG4gICAgLyoqIEB0eXBlIHshT2JqZWN0fSAqL1xuICAgIFRlbXBsYXRlSW5zdGFuY2VCYXNlLnByb3RvdHlwZS5fX2hvc3RQcm9wcztcblxuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBleHRlbmRzIHtUZW1wbGF0ZUluc3RhbmNlQmFzZX1cbiAgICAgKiBAaW1wbGVtZW50cyB7UG9seW1lcl9NdXRhYmxlRGF0YX1cbiAgICAgKi9cbiAgICBjb25zdCBNdXRhYmxlVGVtcGxhdGVJbnN0YW5jZUJhc2UgPSBQb2x5bWVyLk11dGFibGVEYXRhKFRlbXBsYXRlSW5zdGFuY2VCYXNlKTtcblxuICAgIGZ1bmN0aW9uIGZpbmRNZXRob2RIb3N0KHRlbXBsYXRlKSB7XG4gICAgICAvLyBUZWNobmljYWxseSB0aGlzIHNob3VsZCBiZSB0aGUgb3duZXIgb2YgdGhlIG91dGVybW9zdCB0ZW1wbGF0ZS5cbiAgICAgIC8vIEluIHNoYWRvdyBkb20sIHRoaXMgaXMgYWx3YXlzIGdldFJvb3ROb2RlKCkuaG9zdCwgYnV0IHdlIGNhblxuICAgICAgLy8gYXBwcm94aW1hdGUgdGhpcyB2aWEgY29vcGVyYXRpb24gd2l0aCBvdXIgZGF0YUhvc3QgYWx3YXlzIHNldHRpbmdcbiAgICAgIC8vIGBfbWV0aG9kSG9zdGAgYXMgbG9uZyBhcyB0aGVyZSB3ZXJlIGJpbmRpbmdzIChvciBpZCdzKSBvbiB0aGlzXG4gICAgICAvLyBpbnN0YW5jZSBjYXVzaW5nIGl0IHRvIGdldCBhIGRhdGFIb3N0LlxuICAgICAgbGV0IHRlbXBsYXRlSG9zdCA9IHRlbXBsYXRlLl9fZGF0YUhvc3Q7XG4gICAgICByZXR1cm4gdGVtcGxhdGVIb3N0ICYmIHRlbXBsYXRlSG9zdC5fbWV0aG9kSG9zdCB8fCB0ZW1wbGF0ZUhvc3Q7XG4gICAgfVxuXG4gICAgLyogZXNsaW50LWRpc2FibGUgdmFsaWQtanNkb2MgKi9cbiAgICAvKipcbiAgICAgKiBAc3VwcHJlc3Mge21pc3NpbmdQcm9wZXJ0aWVzfSBjbGFzcy5wcm90b3R5cGUgaXMgbm90IGRlZmluZWQgZm9yIHNvbWUgcmVhc29uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlVGVtcGxhdGl6ZXJDbGFzcyh0ZW1wbGF0ZSwgdGVtcGxhdGVJbmZvLCBvcHRpb25zKSB7XG4gICAgICAvLyBBbm9ueW1vdXMgY2xhc3MgY3JlYXRlZCBieSB0aGUgdGVtcGxhdGl6ZVxuICAgICAgbGV0IGJhc2UgPSBvcHRpb25zLm11dGFibGVEYXRhID9cbiAgICAgICAgTXV0YWJsZVRlbXBsYXRlSW5zdGFuY2VCYXNlIDogVGVtcGxhdGVJbnN0YW5jZUJhc2U7XG4gICAgICAvKipcbiAgICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAgICogQGV4dGVuZHMge2Jhc2V9XG4gICAgICAgKi9cbiAgICAgIGxldCBrbGFzcyA9IGNsYXNzIGV4dGVuZHMgYmFzZSB7IH1cbiAgICAgIGtsYXNzLnByb3RvdHlwZS5fX3RlbXBsYXRpemVPcHRpb25zID0gb3B0aW9ucztcbiAgICAgIGtsYXNzLnByb3RvdHlwZS5fYmluZFRlbXBsYXRlKHRlbXBsYXRlKTtcbiAgICAgIGFkZE5vdGlmeUVmZmVjdHMoa2xhc3MsIHRlbXBsYXRlLCB0ZW1wbGF0ZUluZm8sIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIGtsYXNzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBzdXBwcmVzcyB7bWlzc2luZ1Byb3BlcnRpZXN9IGNsYXNzLnByb3RvdHlwZSBpcyBub3QgZGVmaW5lZCBmb3Igc29tZSByZWFzb25cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhZGRQcm9wYWdhdGVFZmZlY3RzKHRlbXBsYXRlLCB0ZW1wbGF0ZUluZm8sIG9wdGlvbnMpIHtcbiAgICAgIGxldCB1c2VyRm9yd2FyZEhvc3RQcm9wID0gb3B0aW9ucy5mb3J3YXJkSG9zdFByb3A7XG4gICAgICBpZiAodXNlckZvcndhcmRIb3N0UHJvcCkge1xuICAgICAgICAvLyBQcm92aWRlIGRhdGEgQVBJIGFuZCBwcm9wZXJ0eSBlZmZlY3RzIG9uIG1lbW9pemVkIHRlbXBsYXRlIGNsYXNzXG4gICAgICAgIGxldCBrbGFzcyA9IHRlbXBsYXRlSW5mby50ZW1wbGF0aXplVGVtcGxhdGVDbGFzcztcbiAgICAgICAgaWYgKCFrbGFzcykge1xuICAgICAgICAgIGxldCBiYXNlID0gb3B0aW9ucy5tdXRhYmxlRGF0YSA/IE11dGFibGVEYXRhVGVtcGxhdGUgOiBEYXRhVGVtcGxhdGU7XG4gICAgICAgICAga2xhc3MgPSB0ZW1wbGF0ZUluZm8udGVtcGxhdGl6ZVRlbXBsYXRlQ2xhc3MgPVxuICAgICAgICAgICAgY2xhc3MgVGVtcGxhdGl6ZWRUZW1wbGF0ZSBleHRlbmRzIGJhc2Uge31cbiAgICAgICAgICAvLyBBZGQgdGVtcGxhdGUgLSA+aW5zdGFuY2VzIGVmZmVjdHNcbiAgICAgICAgICAvLyBhbmQgaG9zdCA8LSB0ZW1wbGF0ZSBlZmZlY3RzXG4gICAgICAgICAgbGV0IGhvc3RQcm9wcyA9IHRlbXBsYXRlSW5mby5ob3N0UHJvcHM7XG4gICAgICAgICAgZm9yIChsZXQgcHJvcCBpbiBob3N0UHJvcHMpIHtcbiAgICAgICAgICAgIGtsYXNzLnByb3RvdHlwZS5fYWRkUHJvcGVydHlFZmZlY3QoJ19ob3N0XycgKyBwcm9wLFxuICAgICAgICAgICAgICBrbGFzcy5wcm90b3R5cGUuUFJPUEVSVFlfRUZGRUNUX1RZUEVTLlBST1BBR0FURSxcbiAgICAgICAgICAgICAge2ZuOiBjcmVhdGVGb3J3YXJkSG9zdFByb3BFZmZlY3QocHJvcCwgdXNlckZvcndhcmRIb3N0UHJvcCl9KTtcbiAgICAgICAgICAgIGtsYXNzLnByb3RvdHlwZS5fY3JlYXRlTm90aWZ5aW5nUHJvcGVydHkoJ19ob3N0XycgKyBwcm9wKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdXBncmFkZVRlbXBsYXRlKHRlbXBsYXRlLCBrbGFzcyk7XG4gICAgICAgIC8vIE1peCBhbnkgcHJlLWJvdW5kIGRhdGEgaW50byBfX2RhdGE7IG5vIG5lZWQgdG8gZmx1c2ggdGhpcyB0b1xuICAgICAgICAvLyBpbnN0YW5jZXMgc2luY2UgdGhleSBwdWxsIGZyb20gdGhlIHRlbXBsYXRlIGF0IGluc3RhbmNlLXRpbWVcbiAgICAgICAgaWYgKHRlbXBsYXRlLl9fZGF0YVByb3RvKSB7XG4gICAgICAgICAgLy8gTm90ZSwgZ2VuZXJhbGx5IGBfX2RhdGFQcm90b2AgY291bGQgYmUgY2hhaW5lZCwgYnV0IGl0J3MgZ3VhcmFudGVlZFxuICAgICAgICAgIC8vIHRvIG5vdCBiZSBzaW5jZSB0aGlzIGlzIGEgdmFuaWxsYSB0ZW1wbGF0ZSB3ZSBqdXN0IGFkZGVkIGVmZmVjdHMgdG9cbiAgICAgICAgICBPYmplY3QuYXNzaWduKHRlbXBsYXRlLl9fZGF0YSwgdGVtcGxhdGUuX19kYXRhUHJvdG8pO1xuICAgICAgICB9XG4gICAgICAgIC8vIENsZWFyIGFueSBwZW5kaW5nIGRhdGEgZm9yIHBlcmZvcm1hbmNlXG4gICAgICAgIHRlbXBsYXRlLl9fZGF0YVRlbXAgPSB7fTtcbiAgICAgICAgdGVtcGxhdGUuX19kYXRhUGVuZGluZyA9IG51bGw7XG4gICAgICAgIHRlbXBsYXRlLl9fZGF0YU9sZCA9IG51bGw7XG4gICAgICAgIHRlbXBsYXRlLl9lbmFibGVQcm9wZXJ0aWVzKCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qIGVzbGludC1lbmFibGUgdmFsaWQtanNkb2MgKi9cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUZvcndhcmRIb3N0UHJvcEVmZmVjdChob3N0UHJvcCwgdXNlckZvcndhcmRIb3N0UHJvcCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIGZvcndhcmRIb3N0UHJvcCh0ZW1wbGF0ZSwgcHJvcCwgcHJvcHMpIHtcbiAgICAgICAgdXNlckZvcndhcmRIb3N0UHJvcC5jYWxsKHRlbXBsYXRlLl9fdGVtcGxhdGl6ZU93bmVyLFxuICAgICAgICAgIHByb3Auc3Vic3RyaW5nKCdfaG9zdF8nLmxlbmd0aCksIHByb3BzW3Byb3BdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGROb3RpZnlFZmZlY3RzKGtsYXNzLCB0ZW1wbGF0ZSwgdGVtcGxhdGVJbmZvLCBvcHRpb25zKSB7XG4gICAgICBsZXQgaG9zdFByb3BzID0gdGVtcGxhdGVJbmZvLmhvc3RQcm9wcyB8fCB7fTtcbiAgICAgIGZvciAobGV0IGlwcm9wIGluIG9wdGlvbnMuaW5zdGFuY2VQcm9wcykge1xuICAgICAgICBkZWxldGUgaG9zdFByb3BzW2lwcm9wXTtcbiAgICAgICAgbGV0IHVzZXJOb3RpZnlJbnN0YW5jZVByb3AgPSBvcHRpb25zLm5vdGlmeUluc3RhbmNlUHJvcDtcbiAgICAgICAgaWYgKHVzZXJOb3RpZnlJbnN0YW5jZVByb3ApIHtcbiAgICAgICAgICBrbGFzcy5wcm90b3R5cGUuX2FkZFByb3BlcnR5RWZmZWN0KGlwcm9wLFxuICAgICAgICAgICAga2xhc3MucHJvdG90eXBlLlBST1BFUlRZX0VGRkVDVF9UWVBFUy5OT1RJRlksXG4gICAgICAgICAgICB7Zm46IGNyZWF0ZU5vdGlmeUluc3RhbmNlUHJvcEVmZmVjdChpcHJvcCwgdXNlck5vdGlmeUluc3RhbmNlUHJvcCl9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuZm9yd2FyZEhvc3RQcm9wICYmIHRlbXBsYXRlLl9fZGF0YUhvc3QpIHtcbiAgICAgICAgZm9yIChsZXQgaHByb3AgaW4gaG9zdFByb3BzKSB7XG4gICAgICAgICAga2xhc3MucHJvdG90eXBlLl9hZGRQcm9wZXJ0eUVmZmVjdChocHJvcCxcbiAgICAgICAgICAgIGtsYXNzLnByb3RvdHlwZS5QUk9QRVJUWV9FRkZFQ1RfVFlQRVMuTk9USUZZLFxuICAgICAgICAgICAge2ZuOiBjcmVhdGVOb3RpZnlIb3N0UHJvcEVmZmVjdCgpfSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZU5vdGlmeUluc3RhbmNlUHJvcEVmZmVjdChpbnN0UHJvcCwgdXNlck5vdGlmeUluc3RhbmNlUHJvcCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIG5vdGlmeUluc3RhbmNlUHJvcChpbnN0LCBwcm9wLCBwcm9wcykge1xuICAgICAgICB1c2VyTm90aWZ5SW5zdGFuY2VQcm9wLmNhbGwoaW5zdC5fX3RlbXBsYXRpemVPd25lcixcbiAgICAgICAgICBpbnN0LCBwcm9wLCBwcm9wc1twcm9wXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlTm90aWZ5SG9zdFByb3BFZmZlY3QoKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gbm90aWZ5SG9zdFByb3AoaW5zdCwgcHJvcCwgcHJvcHMpIHtcbiAgICAgICAgaW5zdC5fX2RhdGFIb3N0Ll9zZXRQZW5kaW5nUHJvcGVydHlPclBhdGgoJ19ob3N0XycgKyBwcm9wLCBwcm9wc1twcm9wXSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTW9kdWxlIGZvciBwcmVwYXJpbmcgYW5kIHN0YW1waW5nIGluc3RhbmNlcyBvZiB0ZW1wbGF0ZXMgdGhhdCB1dGlsaXplXG4gICAgICogUG9seW1lcidzIGRhdGEtYmluZGluZyBhbmQgZGVjbGFyYXRpdmUgZXZlbnQgbGlzdGVuZXIgZmVhdHVyZXMuXG4gICAgICpcbiAgICAgKiBFeGFtcGxlOlxuICAgICAqXG4gICAgICogICAgIC8vIEdldCBhIHRlbXBsYXRlIGZyb20gc29tZXdoZXJlLCBlLmcuIGxpZ2h0IERPTVxuICAgICAqICAgICBsZXQgdGVtcGxhdGUgPSB0aGlzLnF1ZXJ5U2VsZWN0b3IoJ3RlbXBsYXRlJyk7XG4gICAgICogICAgIC8vIFByZXBhcmUgdGhlIHRlbXBsYXRlXG4gICAgICogICAgIGxldCBUZW1wbGF0ZUNsYXNzID0gUG9seW1lci5UZW1wbGF0aXplLnRlbXBsYXRpemUodGVtcGxhdGUpO1xuICAgICAqICAgICAvLyBJbnN0YW5jZSB0aGUgdGVtcGxhdGUgd2l0aCBhbiBpbml0aWFsIGRhdGEgbW9kZWxcbiAgICAgKiAgICAgbGV0IGluc3RhbmNlID0gbmV3IFRlbXBsYXRlQ2xhc3Moe215UHJvcDogJ2luaXRpYWwnfSk7XG4gICAgICogICAgIC8vIEluc2VydCB0aGUgaW5zdGFuY2UncyBET00gc29tZXdoZXJlLCBlLmcuIGVsZW1lbnQncyBzaGFkb3cgRE9NXG4gICAgICogICAgIHRoaXMuc2hhZG93Um9vdC5hcHBlbmRDaGlsZChpbnN0YW5jZS5yb290KTtcbiAgICAgKiAgICAgLy8gQ2hhbmdpbmcgYSBwcm9wZXJ0eSBvbiB0aGUgaW5zdGFuY2Ugd2lsbCBwcm9wYWdhdGUgdG8gYmluZGluZ3NcbiAgICAgKiAgICAgLy8gaW4gdGhlIHRlbXBsYXRlXG4gICAgICogICAgIGluc3RhbmNlLm15UHJvcCA9ICduZXcgdmFsdWUnO1xuICAgICAqXG4gICAgICogVGhlIGBvcHRpb25zYCBkaWN0aW9uYXJ5IHBhc3NlZCB0byBgdGVtcGxhdGl6ZWAgYWxsb3dzIGZvciBjdXN0b21pemluZ1xuICAgICAqIGZlYXR1cmVzIG9mIHRoZSBnZW5lcmF0ZWQgdGVtcGxhdGUgY2xhc3MsIGluY2x1ZGluZyBob3cgb3V0ZXItc2NvcGUgaG9zdFxuICAgICAqIHByb3BlcnRpZXMgc2hvdWxkIGJlIGZvcndhcmRlZCBpbnRvIHRlbXBsYXRlIGluc3RhbmNlcywgaG93IGFueSBpbnN0YW5jZVxuICAgICAqIHByb3BlcnRpZXMgYWRkZWQgaW50byB0aGUgdGVtcGxhdGUncyBzY29wZSBzaG91bGQgYmUgbm90aWZpZWQgb3V0IHRvXG4gICAgICogdGhlIGhvc3QsIGFuZCB3aGV0aGVyIHRoZSBpbnN0YW5jZSBzaG91bGQgYmUgZGVjb3JhdGVkIGFzIGEgXCJwYXJlbnQgbW9kZWxcIlxuICAgICAqIG9mIGFueSBldmVudCBoYW5kbGVycy5cbiAgICAgKlxuICAgICAqICAgICAvLyBDdXN0b216ZSBwcm9wZXJ0eSBmb3J3YXJkaW5nIGFuZCBldmVudCBtb2RlbCBkZWNvcmF0aW9uXG4gICAgICogICAgIGxldCBUZW1wbGF0ZUNsYXNzID0gUG9seW1lci5UZW1wbGF0aXplLnRlbXBsYXRpemUodGVtcGxhdGUsIHRoaXMsIHtcbiAgICAgKiAgICAgICBwYXJlbnRNb2RlbDogdHJ1ZSxcbiAgICAgKiAgICAgICBpbnN0YW5jZVByb3BzOiB7Li4ufSxcbiAgICAgKiAgICAgICBmb3J3YXJkSG9zdFByb3AocHJvcGVydHksIHZhbHVlKSB7Li4ufSxcbiAgICAgKiAgICAgICBub3RpZnlJbnN0YW5jZVByb3AoaW5zdGFuY2UsIHByb3BlcnR5LCB2YWx1ZSkgey4uLn0sXG4gICAgICogICAgIH0pO1xuICAgICAqXG4gICAgICpcbiAgICAgKiBAbmFtZXNwYWNlXG4gICAgICogQG1lbWJlcm9mIFBvbHltZXJcbiAgICAgKiBAc3VtbWFyeSBNb2R1bGUgZm9yIHByZXBhcmluZyBhbmQgc3RhbXBpbmcgaW5zdGFuY2VzIG9mIHRlbXBsYXRlc1xuICAgICAqICAgdXRpbGl6aW5nIFBvbHltZXIgdGVtcGxhdGluZyBmZWF0dXJlcy5cbiAgICAgKi9cblxuICAgIGNvbnN0IFRlbXBsYXRpemUgPSB7XG5cbiAgICAgIC8qKlxuICAgICAgICogUmV0dXJucyBhbiBhbm9ueW1vdXMgYFBvbHltZXIuUHJvcGVydHlFZmZlY3RzYCBjbGFzcyBib3VuZCB0byB0aGVcbiAgICAgICAqIGA8dGVtcGxhdGU+YCBwcm92aWRlZC4gIEluc3RhbmNpbmcgdGhlIGNsYXNzIHdpbGwgcmVzdWx0IGluIHRoZVxuICAgICAgICogdGVtcGxhdGUgYmVpbmcgc3RhbXBlZCBpbnRvIGRvY3VtZW50IGZyYWdtZW50IHN0b3JlZCBhcyB0aGUgaW5zdGFuY2Unc1xuICAgICAgICogYHJvb3RgIHByb3BlcnR5LCBhZnRlciB3aGljaCBpdCBjYW4gYmUgYXBwZW5kZWQgdG8gdGhlIERPTS5cbiAgICAgICAqXG4gICAgICAgKiBUZW1wbGF0ZXMgbWF5IHV0aWxpemUgYWxsIFBvbHltZXIgZGF0YS1iaW5kaW5nIGZlYXR1cmVzIGFzIHdlbGwgYXNcbiAgICAgICAqIGRlY2xhcmF0aXZlIGV2ZW50IGxpc3RlbmVycy4gIEV2ZW50IGxpc3RlbmVycyBhbmQgaW5saW5lIGNvbXB1dGluZ1xuICAgICAgICogZnVuY3Rpb25zIGluIHRoZSB0ZW1wbGF0ZSB3aWxsIGJlIGNhbGxlZCBvbiB0aGUgaG9zdCBvZiB0aGUgdGVtcGxhdGUuXG4gICAgICAgKlxuICAgICAgICogVGhlIGNvbnN0cnVjdG9yIHJldHVybmVkIHRha2VzIGEgc2luZ2xlIGFyZ3VtZW50IGRpY3Rpb25hcnkgb2YgaW5pdGlhbFxuICAgICAgICogcHJvcGVydHkgdmFsdWVzIHRvIHByb3BhZ2F0ZSBpbnRvIHRlbXBsYXRlIGJpbmRpbmdzLiAgQWRkaXRpb25hbGx5XG4gICAgICAgKiBob3N0IHByb3BlcnRpZXMgY2FuIGJlIGZvcndhcmRlZCBpbiwgYW5kIGluc3RhbmNlIHByb3BlcnRpZXMgY2FuIGJlXG4gICAgICAgKiBub3RpZmllZCBvdXQgYnkgcHJvdmlkaW5nIG9wdGlvbmFsIGNhbGxiYWNrcyBpbiB0aGUgYG9wdGlvbnNgIGRpY3Rpb25hcnkuXG4gICAgICAgKlxuICAgICAgICogVmFsaWQgY29uZmlndXJhdGlvbiBpbiBgb3B0aW9uc2AgYXJlIGFzIGZvbGxvd3M6XG4gICAgICAgKlxuICAgICAgICogLSBgZm9yd2FyZEhvc3RQcm9wKHByb3BlcnR5LCB2YWx1ZSlgOiBDYWxsZWQgd2hlbiBhIHByb3BlcnR5IHJlZmVyZW5jZWRcbiAgICAgICAqICAgaW4gdGhlIHRlbXBsYXRlIGNoYW5nZWQgb24gdGhlIHRlbXBsYXRlJ3MgaG9zdC4gQXMgdGhpcyBsaWJyYXJ5IGRvZXNcbiAgICAgICAqICAgbm90IHJldGFpbiByZWZlcmVuY2VzIHRvIHRlbXBsYXRlcyBpbnN0YW5jZWQgYnkgdGhlIHVzZXIsIGl0IGlzIHRoZVxuICAgICAgICogICB0ZW1wbGF0aXplIG93bmVyJ3MgcmVzcG9uc2liaWxpdHkgdG8gZm9yd2FyZCBob3N0IHByb3BlcnR5IGNoYW5nZXMgaW50b1xuICAgICAgICogICB1c2VyLXN0YW1wZWQgaW5zdGFuY2VzLiAgVGhlIGBpbnN0YW5jZS5mb3J3YXJkSG9zdFByb3AocHJvcGVydHksIHZhbHVlKWBcbiAgICAgICAqICAgIG1ldGhvZCBvbiB0aGUgZ2VuZXJhdGVkIGNsYXNzIHNob3VsZCBiZSBjYWxsZWQgdG8gZm9yd2FyZCBob3N0XG4gICAgICAgKiAgIHByb3BlcnRpZXMgaW50byB0aGUgdGVtcGxhdGUgdG8gcHJldmVudCB1bm5lY2Vzc2FyeSBwcm9wZXJ0eS1jaGFuZ2VkXG4gICAgICAgKiAgIG5vdGlmaWNhdGlvbnMuIEFueSBwcm9wZXJ0aWVzIHJlZmVyZW5jZWQgaW4gdGhlIHRlbXBsYXRlIHRoYXQgYXJlIG5vdFxuICAgICAgICogICBkZWZpbmVkIGluIGBpbnN0YW5jZVByb3BzYCB3aWxsIGJlIG5vdGlmaWVkIHVwIHRvIHRoZSB0ZW1wbGF0ZSdzIGhvc3RcbiAgICAgICAqICAgYXV0b21hdGljYWxseS5cbiAgICAgICAqIC0gYGluc3RhbmNlUHJvcHNgOiBEaWN0aW9uYXJ5IG9mIHByb3BlcnR5IG5hbWVzIHRoYXQgd2lsbCBiZSBhZGRlZFxuICAgICAgICogICB0byB0aGUgaW5zdGFuY2UgYnkgdGhlIHRlbXBsYXRpemUgb3duZXIuICBUaGVzZSBwcm9wZXJ0aWVzIHNoYWRvdyBhbnlcbiAgICAgICAqICAgaG9zdCBwcm9wZXJ0aWVzLCBhbmQgY2hhbmdlcyB3aXRoaW4gdGhlIHRlbXBsYXRlIHRvIHRoZXNlIHByb3BlcnRpZXNcbiAgICAgICAqICAgd2lsbCByZXN1bHQgaW4gYG5vdGlmeUluc3RhbmNlUHJvcGAgYmVpbmcgY2FsbGVkLlxuICAgICAgICogLSBgbXV0YWJsZURhdGFgOiBXaGVuIGB0cnVlYCwgdGhlIGdlbmVyYXRlZCBjbGFzcyB3aWxsIHNraXAgc3RyaWN0XG4gICAgICAgKiAgIGRpcnR5LWNoZWNraW5nIGZvciBvYmplY3RzIGFuZCBhcnJheXMgKGFsd2F5cyBjb25zaWRlciB0aGVtIHRvIGJlXG4gICAgICAgKiAgIFwiZGlydHlcIikuXG4gICAgICAgKiAtIGBub3RpZnlJbnN0YW5jZVByb3AoaW5zdGFuY2UsIHByb3BlcnR5LCB2YWx1ZSlgOiBDYWxsZWQgd2hlblxuICAgICAgICogICBhbiBpbnN0YW5jZSBwcm9wZXJ0eSBjaGFuZ2VzLiAgVXNlcnMgbWF5IGNob29zZSB0byBjYWxsIGBub3RpZnlQYXRoYFxuICAgICAgICogICBvbiBlLmcuIHRoZSBvd25lciB0byBub3RpZnkgdGhlIGNoYW5nZS5cbiAgICAgICAqIC0gYHBhcmVudE1vZGVsYDogV2hlbiBgdHJ1ZWAsIGV2ZW50cyBoYW5kbGVkIGJ5IGRlY2xhcmF0aXZlIGV2ZW50IGxpc3RlbmVyc1xuICAgICAgICogICAoYG9uLWV2ZW50PVwiaGFuZGxlclwiYCkgd2lsbCBiZSBkZWNvcmF0ZWQgd2l0aCBhIGBtb2RlbGAgcHJvcGVydHkgcG9pbnRpbmdcbiAgICAgICAqICAgdG8gdGhlIHRlbXBsYXRlIGluc3RhbmNlIHRoYXQgc3RhbXBlZCBpdC4gIEl0IHdpbGwgYWxzbyBiZSByZXR1cm5lZFxuICAgICAgICogICBmcm9tIGBpbnN0YW5jZS5wYXJlbnRNb2RlbGAgaW4gY2FzZXMgd2hlcmUgdGVtcGxhdGUgaW5zdGFuY2UgbmVzdGluZ1xuICAgICAgICogICBjYXVzZXMgYW4gaW5uZXIgbW9kZWwgdG8gc2hhZG93IGFuIG91dGVyIG1vZGVsLlxuICAgICAgICpcbiAgICAgICAqIE5vdGUgdGhhdCB0aGUgY2xhc3MgcmV0dXJuZWQgZnJvbSBgdGVtcGxhdGl6ZWAgaXMgZ2VuZXJhdGVkIG9ubHkgb25jZVxuICAgICAgICogZm9yIGEgZ2l2ZW4gYDx0ZW1wbGF0ZT5gIHVzaW5nIGBvcHRpb25zYCBmcm9tIHRoZSBmaXJzdCBjYWxsIGZvciB0aGF0XG4gICAgICAgKiB0ZW1wbGF0ZSwgYW5kIHRoZSBjYWNoZWQgY2xhc3MgaXMgcmV0dXJuZWQgZm9yIGFsbCBzdWJzZXF1ZW50IGNhbGxzIHRvXG4gICAgICAgKiBgdGVtcGxhdGl6ZWAgZm9yIHRoYXQgdGVtcGxhdGUuICBBcyBzdWNoLCBgb3B0aW9uc2AgY2FsbGJhY2tzIHNob3VsZCBub3RcbiAgICAgICAqIGNsb3NlIG92ZXIgb3duZXItc3BlY2lmaWMgcHJvcGVydGllcyBzaW5jZSBvbmx5IHRoZSBmaXJzdCBgb3B0aW9uc2AgaXNcbiAgICAgICAqIHVzZWQ7IHJhdGhlciwgY2FsbGJhY2tzIGFyZSBjYWxsZWQgYm91bmQgdG8gdGhlIGBvd25lcmAsIGFuZCBzbyBjb250ZXh0XG4gICAgICAgKiBuZWVkZWQgZnJvbSB0aGUgY2FsbGJhY2tzIChzdWNoIGFzIHJlZmVyZW5jZXMgdG8gYGluc3RhbmNlc2Agc3RhbXBlZClcbiAgICAgICAqIHNob3VsZCBiZSBzdG9yZWQgb24gdGhlIGBvd25lcmAgc3VjaCB0aGF0IHRoZXkgY2FuIGJlIHJldHJpZXZlZCB2aWEgYHRoaXNgLlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJvZiBQb2x5bWVyLlRlbXBsYXRpemVcbiAgICAgICAqIEBwYXJhbSB7IUhUTUxUZW1wbGF0ZUVsZW1lbnR9IHRlbXBsYXRlIFRlbXBsYXRlIHRvIHRlbXBsYXRpemVcbiAgICAgICAqIEBwYXJhbSB7IVBvbHltZXJfUHJvcGVydHlFZmZlY3RzfSBvd25lciBPd25lciBvZiB0aGUgdGVtcGxhdGUgaW5zdGFuY2VzO1xuICAgICAgICogICBhbnkgb3B0aW9uYWwgY2FsbGJhY2tzIHdpbGwgYmUgYm91bmQgdG8gdGhpcyBvd25lci5cbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9ucyBPcHRpb25zIGRpY3Rpb25hcnkgKHNlZSBzdW1tYXJ5IGZvciBkZXRhaWxzKVxuICAgICAgICogQHJldHVybiB7ZnVuY3Rpb24obmV3OlRlbXBsYXRlSW5zdGFuY2VCYXNlKX0gR2VuZXJhdGVkIGNsYXNzIGJvdW5kIHRvIHRoZSB0ZW1wbGF0ZVxuICAgICAgICogICBwcm92aWRlZFxuICAgICAgICogQHN1cHByZXNzIHtpbnZhbGlkQ2FzdHN9XG4gICAgICAgKi9cbiAgICAgIHRlbXBsYXRpemUodGVtcGxhdGUsIG93bmVyLCBvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSAvKiogQHR5cGUgeyFUZW1wbGF0aXplT3B0aW9uc30gKi8ob3B0aW9ucyB8fCB7fSk7XG4gICAgICAgIGlmICh0ZW1wbGF0ZS5fX3RlbXBsYXRpemVPd25lcikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQSA8dGVtcGxhdGU+IGNhbiBvbmx5IGJlIHRlbXBsYXRpemVkIG9uY2UnKTtcbiAgICAgICAgfVxuICAgICAgICB0ZW1wbGF0ZS5fX3RlbXBsYXRpemVPd25lciA9IG93bmVyO1xuICAgICAgICBsZXQgdGVtcGxhdGVJbmZvID0gb3duZXIuY29uc3RydWN0b3IuX3BhcnNlVGVtcGxhdGUodGVtcGxhdGUpO1xuICAgICAgICAvLyBHZXQgbWVtb2l6ZWQgYmFzZSBjbGFzcyBmb3IgdGhlIHByb3RvdHlwaWNhbCB0ZW1wbGF0ZSwgd2hpY2hcbiAgICAgICAgLy8gaW5jbHVkZXMgcHJvcGVydHkgZWZmZWN0cyBmb3IgYmluZGluZyB0ZW1wbGF0ZSAmIGZvcndhcmRpbmdcbiAgICAgICAgbGV0IGJhc2VDbGFzcyA9IHRlbXBsYXRlSW5mby50ZW1wbGF0aXplSW5zdGFuY2VDbGFzcztcbiAgICAgICAgaWYgKCFiYXNlQ2xhc3MpIHtcbiAgICAgICAgICBiYXNlQ2xhc3MgPSBjcmVhdGVUZW1wbGF0aXplckNsYXNzKHRlbXBsYXRlLCB0ZW1wbGF0ZUluZm8sIG9wdGlvbnMpO1xuICAgICAgICAgIHRlbXBsYXRlSW5mby50ZW1wbGF0aXplSW5zdGFuY2VDbGFzcyA9IGJhc2VDbGFzcztcbiAgICAgICAgfVxuICAgICAgICAvLyBIb3N0IHByb3BlcnR5IGZvcndhcmRpbmcgbXVzdCBiZSBpbnN0YWxsZWQgb250byB0ZW1wbGF0ZSBpbnN0YW5jZVxuICAgICAgICBhZGRQcm9wYWdhdGVFZmZlY3RzKHRlbXBsYXRlLCB0ZW1wbGF0ZUluZm8sIG9wdGlvbnMpO1xuICAgICAgICAvLyBTdWJjbGFzcyBiYXNlIGNsYXNzIGFuZCBhZGQgcmVmZXJlbmNlIGZvciB0aGlzIHNwZWNpZmljIHRlbXBsYXRlXG4gICAgICAgIGxldCBrbGFzcyA9IGNsYXNzIFRlbXBsYXRlSW5zdGFuY2UgZXh0ZW5kcyBiYXNlQ2xhc3Mge307XG4gICAgICAgIGtsYXNzLnByb3RvdHlwZS5fbWV0aG9kSG9zdCA9IGZpbmRNZXRob2RIb3N0KHRlbXBsYXRlKTtcbiAgICAgICAga2xhc3MucHJvdG90eXBlLl9fZGF0YUhvc3QgPSB0ZW1wbGF0ZTtcbiAgICAgICAga2xhc3MucHJvdG90eXBlLl9fdGVtcGxhdGl6ZU93bmVyID0gb3duZXI7XG4gICAgICAgIGtsYXNzLnByb3RvdHlwZS5fX2hvc3RQcm9wcyA9IHRlbXBsYXRlSW5mby5ob3N0UHJvcHM7XG4gICAgICAgIHJldHVybiAvKiogQHR5cGUge2Z1bmN0aW9uKG5ldzpUZW1wbGF0ZUluc3RhbmNlQmFzZSl9ICovKGtsYXNzKTtcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogUmV0dXJucyB0aGUgdGVtcGxhdGUgXCJtb2RlbFwiIGFzc29jaWF0ZWQgd2l0aCBhIGdpdmVuIGVsZW1lbnQsIHdoaWNoXG4gICAgICAgKiBzZXJ2ZXMgYXMgdGhlIGJpbmRpbmcgc2NvcGUgZm9yIHRoZSB0ZW1wbGF0ZSBpbnN0YW5jZSB0aGUgZWxlbWVudCBpc1xuICAgICAgICogY29udGFpbmVkIGluLiBBIHRlbXBsYXRlIG1vZGVsIGlzIGFuIGluc3RhbmNlIG9mXG4gICAgICAgKiBgVGVtcGxhdGVJbnN0YW5jZUJhc2VgLCBhbmQgc2hvdWxkIGJlIHVzZWQgdG8gbWFuaXB1bGF0ZSBkYXRhXG4gICAgICAgKiBhc3NvY2lhdGVkIHdpdGggdGhpcyB0ZW1wbGF0ZSBpbnN0YW5jZS5cbiAgICAgICAqXG4gICAgICAgKiBFeGFtcGxlOlxuICAgICAgICpcbiAgICAgICAqICAgbGV0IG1vZGVsID0gbW9kZWxGb3JFbGVtZW50KGVsKTtcbiAgICAgICAqICAgaWYgKG1vZGVsLmluZGV4IDwgMTApIHtcbiAgICAgICAqICAgICBtb2RlbC5zZXQoJ2l0ZW0uY2hlY2tlZCcsIHRydWUpO1xuICAgICAgICogICB9XG4gICAgICAgKlxuICAgICAgICogQG1lbWJlcm9mIFBvbHltZXIuVGVtcGxhdGl6ZVxuICAgICAgICogQHBhcmFtIHtIVE1MVGVtcGxhdGVFbGVtZW50fSB0ZW1wbGF0ZSBUaGUgbW9kZWwgd2lsbCBiZSByZXR1cm5lZCBmb3JcbiAgICAgICAqICAgZWxlbWVudHMgc3RhbXBlZCBmcm9tIHRoaXMgdGVtcGxhdGVcbiAgICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBOb2RlIGZvciB3aGljaCB0byByZXR1cm4gYSB0ZW1wbGF0ZSBtb2RlbC5cbiAgICAgICAqIEByZXR1cm4ge1RlbXBsYXRlSW5zdGFuY2VCYXNlfSBUZW1wbGF0ZSBpbnN0YW5jZSByZXByZXNlbnRpbmcgdGhlXG4gICAgICAgKiAgIGJpbmRpbmcgc2NvcGUgZm9yIHRoZSBlbGVtZW50XG4gICAgICAgKi9cbiAgICAgIG1vZGVsRm9yRWxlbWVudCh0ZW1wbGF0ZSwgbm9kZSkge1xuICAgICAgICBsZXQgbW9kZWw7XG4gICAgICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgICAgLy8gQW4gZWxlbWVudCB3aXRoIGEgX190ZW1wbGF0aXplSW5zdGFuY2UgbWFya3MgdGhlIHRvcCBib3VuZGFyeVxuICAgICAgICAgIC8vIG9mIGEgc2NvcGU7IHdhbGsgdXAgdW50aWwgd2UgZmluZCBvbmUsIGFuZCB0aGVuIGVuc3VyZSB0aGF0XG4gICAgICAgICAgLy8gaXRzIF9fZGF0YUhvc3QgbWF0Y2hlcyBgdGhpc2AsIG1lYW5pbmcgdGhpcyBkb20tcmVwZWF0IHN0YW1wZWQgaXRcbiAgICAgICAgICBpZiAoKG1vZGVsID0gbm9kZS5fX3RlbXBsYXRpemVJbnN0YW5jZSkpIHtcbiAgICAgICAgICAgIC8vIEZvdW5kIGFuIGVsZW1lbnQgc3RhbXBlZCBieSBhbm90aGVyIHRlbXBsYXRlOyBrZWVwIHdhbGtpbmcgdXBcbiAgICAgICAgICAgIC8vIGZyb20gaXRzIF9fZGF0YUhvc3RcbiAgICAgICAgICAgIGlmIChtb2RlbC5fX2RhdGFIb3N0ICE9IHRlbXBsYXRlKSB7XG4gICAgICAgICAgICAgIG5vZGUgPSBtb2RlbC5fX2RhdGFIb3N0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG1vZGVsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBTdGlsbCBpbiBhIHRlbXBsYXRlIHNjb3BlLCBrZWVwIGdvaW5nIHVwIHVudGlsXG4gICAgICAgICAgICAvLyBhIF9fdGVtcGxhdGl6ZUluc3RhbmNlIGlzIGZvdW5kXG4gICAgICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBQb2x5bWVyLlRlbXBsYXRpemUgPSBUZW1wbGF0aXplO1xuICAgIFBvbHltZXIuVGVtcGxhdGVJbnN0YW5jZUJhc2UgPSBUZW1wbGF0ZUluc3RhbmNlQmFzZTtcblxuICB9KSgpO1xuXG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvdXRpbHMvdGVtcGxhdGl6ZS5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNiBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuXG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vLi4vcG9seW1lci9wb2x5bWVyLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi8uLi9pcm9uLXJlc2l6YWJsZS1iZWhhdmlvci9pcm9uLXJlc2l6YWJsZS1iZWhhdmlvci5odG1sXCI+XG5cbjxzY3JpcHQ+XG5cbiAgLyoqXG4gICAqIEBwb2x5bWVyQmVoYXZpb3IgUG9seW1lci5BcHBMYXlvdXRCZWhhdmlvclxuICAgKiovXG4gIFBvbHltZXIuQXBwTGF5b3V0QmVoYXZpb3IgPSBbXG4gICAgUG9seW1lci5Jcm9uUmVzaXphYmxlQmVoYXZpb3IsIHtcblxuICAgIGxpc3RlbmVyczoge1xuICAgICAgJ2FwcC1yZXNldC1sYXlvdXQnOiAnX2FwcFJlc2V0TGF5b3V0SGFuZGxlcicsXG4gICAgICAnaXJvbi1yZXNpemUnOiAncmVzZXRMYXlvdXQnXG4gICAgfSxcblxuICAgIGF0dGFjaGVkOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZmlyZSgnYXBwLXJlc2V0LWxheW91dCcpO1xuICAgIH0sXG5cbiAgICBfYXBwUmVzZXRMYXlvdXRIYW5kbGVyOiBmdW5jdGlvbihlKSB7XG4gICAgICBpZiAoUG9seW1lci5kb20oZSkucGF0aFswXSA9PT0gdGhpcykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLnJlc2V0TGF5b3V0KCk7XG4gICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH0sXG5cbiAgICBfdXBkYXRlTGF5b3V0U3RhdGVzOiBmdW5jdGlvbigpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ3VuaW1wbGVtZW50ZWQnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVzZXRzIHRoZSBsYXlvdXQuIElmIHlvdSBjaGFuZ2VkIHRoZSBzaXplIG9mIHRoaXMgZWxlbWVudCB2aWEgQ1NTXG4gICAgICogeW91IGNhbiBub3RpZnkgdGhlIGNoYW5nZXMgYnkgZWl0aGVyIGZpcmluZyB0aGUgYGlyb24tcmVzaXplYCBldmVudFxuICAgICAqIG9yIGNhbGxpbmcgYHJlc2V0TGF5b3V0YCBkaXJlY3RseS5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgcmVzZXRMYXlvdXRcbiAgICAgKi9cbiAgICByZXNldExheW91dDogZnVuY3Rpb24oKSB7XG4gICAgICAvLyBQb2x5bWVyIHYyLnhcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBjYiA9IHRoaXMuX3VwZGF0ZUxheW91dFN0YXRlcy5iaW5kKHRoaXMpO1xuICAgICAgaWYgKFBvbHltZXIuQXN5bmMgJiYgUG9seW1lci5Bc3luYy5hbmltYXRpb25GcmFtZSkge1xuICAgICAgICB0aGlzLl9sYXlvdXREZWJvdW5jZXIgPSBQb2x5bWVyLkRlYm91bmNlci5kZWJvdW5jZShcbiAgICAgICAgICAgIHRoaXMuX2xheW91dERlYm91bmNlcixcbiAgICAgICAgICAgIFBvbHltZXIuQXN5bmMuYW5pbWF0aW9uRnJhbWUsXG4gICAgICAgICAgICBjYik7XG4gICAgICAgIFBvbHltZXIuZW5xdWV1ZURlYm91bmNlcih0aGlzLl9sYXlvdXREZWJvdW5jZXIpO1xuICAgICAgfVxuICAgICAgLy8gUG9seW1lciB2MS54XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5kZWJvdW5jZSgncmVzZXRMYXlvdXQnLCBjYik7XG4gICAgICB9XG4gICAgICB0aGlzLl9ub3RpZnlEZXNjZW5kYW50UmVzaXplKCk7XG4gICAgfSxcblxuICAgIF9ub3RpZnlMYXlvdXRDaGFuZ2VkOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIC8vIFRPRE86IHRoZSBldmVudCBgYXBwLXJlc2V0LWxheW91dGAgY2FuIGJlIGZpcmVkIHN5bmNocm9ub3VzbHlcbiAgICAgIC8vIGFzIGxvbmcgYXMgYF91cGRhdGVMYXlvdXRTdGF0ZXNgIHdhaXRzIGZvciBhbGwgdGhlIG1pY3JvdGFza3MgYWZ0ZXIgckFGLlxuICAgICAgLy8gRS5nLiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoc2V0VGltZU91dCgpKVxuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCkge1xuICAgICAgICBzZWxmLmZpcmUoJ2FwcC1yZXNldC1sYXlvdXQnKTtcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBfbm90aWZ5RGVzY2VuZGFudFJlc2l6ZTogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXRoaXMuaXNBdHRhY2hlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl9pbnRlcmVzdGVkUmVzaXphYmxlcy5mb3JFYWNoKGZ1bmN0aW9uKHJlc2l6YWJsZSkge1xuICAgICAgICBpZiAodGhpcy5yZXNpemVyU2hvdWxkTm90aWZ5KHJlc2l6YWJsZSkpIHtcbiAgICAgICAgICB0aGlzLl9ub3RpZnlEZXNjZW5kYW50KHJlc2l6YWJsZSk7XG4gICAgICAgIH1cbiAgICAgIH0sIHRoaXMpO1xuICAgIH1cbiAgfV07XG5cbjwvc2NyaXB0PlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9hcHAtbGF5b3V0L2FwcC1sYXlvdXQtYmVoYXZpb3IvYXBwLWxheW91dC1iZWhhdmlvci5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNSBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuXG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vcG9seW1lci9wb2x5bWVyLmh0bWxcIj5cblxuPHNjcmlwdD5cbiAgKGZ1bmN0aW9uKCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIC8qKlxuICAgICAqIENocm9tZSB1c2VzIGFuIG9sZGVyIHZlcnNpb24gb2YgRE9NIExldmVsIDMgS2V5Ym9hcmQgRXZlbnRzXG4gICAgICpcbiAgICAgKiBNb3N0IGtleXMgYXJlIGxhYmVsZWQgYXMgdGV4dCwgYnV0IHNvbWUgYXJlIFVuaWNvZGUgY29kZXBvaW50cy5cbiAgICAgKiBWYWx1ZXMgdGFrZW4gZnJvbTogaHR0cDovL3d3dy53My5vcmcvVFIvMjAwNy9XRC1ET00tTGV2ZWwtMy1FdmVudHMtMjAwNzEyMjEva2V5c2V0Lmh0bWwjS2V5U2V0LVNldFxuICAgICAqL1xuICAgIHZhciBLRVlfSURFTlRJRklFUiA9IHtcbiAgICAgICdVKzAwMDgnOiAnYmFja3NwYWNlJyxcbiAgICAgICdVKzAwMDknOiAndGFiJyxcbiAgICAgICdVKzAwMUInOiAnZXNjJyxcbiAgICAgICdVKzAwMjAnOiAnc3BhY2UnLFxuICAgICAgJ1UrMDA3Ric6ICdkZWwnXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNwZWNpYWwgdGFibGUgZm9yIEtleWJvYXJkRXZlbnQua2V5Q29kZS5cbiAgICAgKiBLZXlib2FyZEV2ZW50LmtleUlkZW50aWZpZXIgaXMgYmV0dGVyLCBhbmQgS2V5Qm9hcmRFdmVudC5rZXkgaXMgZXZlbiBiZXR0ZXJcbiAgICAgKiB0aGFuIHRoYXQuXG4gICAgICpcbiAgICAgKiBWYWx1ZXMgZnJvbTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0tleWJvYXJkRXZlbnQua2V5Q29kZSNWYWx1ZV9vZl9rZXlDb2RlXG4gICAgICovXG4gICAgdmFyIEtFWV9DT0RFID0ge1xuICAgICAgODogJ2JhY2tzcGFjZScsXG4gICAgICA5OiAndGFiJyxcbiAgICAgIDEzOiAnZW50ZXInLFxuICAgICAgMjc6ICdlc2MnLFxuICAgICAgMzM6ICdwYWdldXAnLFxuICAgICAgMzQ6ICdwYWdlZG93bicsXG4gICAgICAzNTogJ2VuZCcsXG4gICAgICAzNjogJ2hvbWUnLFxuICAgICAgMzI6ICdzcGFjZScsXG4gICAgICAzNzogJ2xlZnQnLFxuICAgICAgMzg6ICd1cCcsXG4gICAgICAzOTogJ3JpZ2h0JyxcbiAgICAgIDQwOiAnZG93bicsXG4gICAgICA0NjogJ2RlbCcsXG4gICAgICAxMDY6ICcqJ1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBNT0RJRklFUl9LRVlTIG1hcHMgdGhlIHNob3J0IG5hbWUgZm9yIG1vZGlmaWVyIGtleXMgdXNlZCBpbiBhIGtleVxuICAgICAqIGNvbWJvIHN0cmluZyB0byB0aGUgcHJvcGVydHkgbmFtZSB0aGF0IHJlZmVyZW5jZXMgdGhvc2Ugc2FtZSBrZXlzXG4gICAgICogaW4gYSBLZXlib2FyZEV2ZW50IGluc3RhbmNlLlxuICAgICAqL1xuICAgIHZhciBNT0RJRklFUl9LRVlTID0ge1xuICAgICAgJ3NoaWZ0JzogJ3NoaWZ0S2V5JyxcbiAgICAgICdjdHJsJzogJ2N0cmxLZXknLFxuICAgICAgJ2FsdCc6ICdhbHRLZXknLFxuICAgICAgJ21ldGEnOiAnbWV0YUtleSdcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogS2V5Ym9hcmRFdmVudC5rZXkgaXMgbW9zdGx5IHJlcHJlc2VudGVkIGJ5IHByaW50YWJsZSBjaGFyYWN0ZXIgbWFkZSBieVxuICAgICAqIHRoZSBrZXlib2FyZCwgd2l0aCB1bnByaW50YWJsZSBrZXlzIGxhYmVsZWQgbmljZWx5LlxuICAgICAqXG4gICAgICogSG93ZXZlciwgb24gT1MgWCwgQWx0K2NoYXIgY2FuIG1ha2UgYSBVbmljb2RlIGNoYXJhY3RlciB0aGF0IGZvbGxvd3MgYW5cbiAgICAgKiBBcHBsZS1zcGVjaWZpYyBtYXBwaW5nLiBJbiB0aGlzIGNhc2UsIHdlIGZhbGwgYmFjayB0byAua2V5Q29kZS5cbiAgICAgKi9cbiAgICB2YXIgS0VZX0NIQVIgPSAvW2EtejAtOSpdLztcblxuICAgIC8qKlxuICAgICAqIE1hdGNoZXMgYSBrZXlJZGVudGlmaWVyIHN0cmluZy5cbiAgICAgKi9cbiAgICB2YXIgSURFTlRfQ0hBUiA9IC9VXFwrLztcblxuICAgIC8qKlxuICAgICAqIE1hdGNoZXMgYXJyb3cga2V5cyBpbiBHZWNrbyAyNy4wK1xuICAgICAqL1xuICAgIHZhciBBUlJPV19LRVkgPSAvXmFycm93LztcblxuICAgIC8qKlxuICAgICAqIE1hdGNoZXMgc3BhY2Uga2V5cyBldmVyeXdoZXJlIChub3RhYmx5IGluY2x1ZGluZyBJRTEwJ3MgZXhjZXB0aW9uYWwgbmFtZVxuICAgICAqIGBzcGFjZWJhcmApLlxuICAgICAqL1xuICAgIHZhciBTUEFDRV9LRVkgPSAvXnNwYWNlKGJhcik/LztcblxuICAgIC8qKlxuICAgICAqIE1hdGNoZXMgRVNDIGtleS5cbiAgICAgKlxuICAgICAqIFZhbHVlIGZyb206IGh0dHA6Ly93M2MuZ2l0aHViLmlvL3VpZXZlbnRzLWtleS8ja2V5LUVzY2FwZVxuICAgICAqL1xuICAgIHZhciBFU0NfS0VZID0gL15lc2NhcGUkLztcblxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybXMgdGhlIGtleS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBLZXlCb2FyZEV2ZW50LmtleVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW25vU3BlY2lhbENoYXJzXSBMaW1pdHMgdGhlIHRyYW5zZm9ybWF0aW9uIHRvXG4gICAgICogYWxwaGEtbnVtZXJpYyBjaGFyYWN0ZXJzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRyYW5zZm9ybUtleShrZXksIG5vU3BlY2lhbENoYXJzKSB7XG4gICAgICB2YXIgdmFsaWRLZXkgPSAnJztcbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgdmFyIGxLZXkgPSBrZXkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKGxLZXkgPT09ICcgJyB8fCBTUEFDRV9LRVkudGVzdChsS2V5KSkge1xuICAgICAgICAgIHZhbGlkS2V5ID0gJ3NwYWNlJztcbiAgICAgICAgfSBlbHNlIGlmIChFU0NfS0VZLnRlc3QobEtleSkpIHtcbiAgICAgICAgICB2YWxpZEtleSA9ICdlc2MnO1xuICAgICAgICB9IGVsc2UgaWYgKGxLZXkubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICBpZiAoIW5vU3BlY2lhbENoYXJzIHx8IEtFWV9DSEFSLnRlc3QobEtleSkpIHtcbiAgICAgICAgICAgIHZhbGlkS2V5ID0gbEtleTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoQVJST1dfS0VZLnRlc3QobEtleSkpIHtcbiAgICAgICAgICB2YWxpZEtleSA9IGxLZXkucmVwbGFjZSgnYXJyb3cnLCAnJyk7XG4gICAgICAgIH0gZWxzZSBpZiAobEtleSA9PSAnbXVsdGlwbHknKSB7XG4gICAgICAgICAgLy8gbnVtcGFkICcqJyBjYW4gbWFwIHRvIE11bHRpcGx5IG9uIElFL1dpbmRvd3NcbiAgICAgICAgICB2YWxpZEtleSA9ICcqJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWxpZEtleSA9IGxLZXk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWxpZEtleTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0cmFuc2Zvcm1LZXlJZGVudGlmaWVyKGtleUlkZW50KSB7XG4gICAgICB2YXIgdmFsaWRLZXkgPSAnJztcbiAgICAgIGlmIChrZXlJZGVudCkge1xuICAgICAgICBpZiAoa2V5SWRlbnQgaW4gS0VZX0lERU5USUZJRVIpIHtcbiAgICAgICAgICB2YWxpZEtleSA9IEtFWV9JREVOVElGSUVSW2tleUlkZW50XTtcbiAgICAgICAgfSBlbHNlIGlmIChJREVOVF9DSEFSLnRlc3Qoa2V5SWRlbnQpKSB7XG4gICAgICAgICAga2V5SWRlbnQgPSBwYXJzZUludChrZXlJZGVudC5yZXBsYWNlKCdVKycsICcweCcpLCAxNik7XG4gICAgICAgICAgdmFsaWRLZXkgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGtleUlkZW50KS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbGlkS2V5ID0ga2V5SWRlbnQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbGlkS2V5O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRyYW5zZm9ybUtleUNvZGUoa2V5Q29kZSkge1xuICAgICAgdmFyIHZhbGlkS2V5ID0gJyc7XG4gICAgICBpZiAoTnVtYmVyKGtleUNvZGUpKSB7XG4gICAgICAgIGlmIChrZXlDb2RlID49IDY1ICYmIGtleUNvZGUgPD0gOTApIHtcbiAgICAgICAgICAvLyBhc2NpaSBhLXpcbiAgICAgICAgICAvLyBsb3dlcmNhc2UgaXMgMzIgb2Zmc2V0IGZyb20gdXBwZXJjYXNlXG4gICAgICAgICAgdmFsaWRLZXkgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDMyICsga2V5Q29kZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoa2V5Q29kZSA+PSAxMTIgJiYga2V5Q29kZSA8PSAxMjMpIHtcbiAgICAgICAgICAvLyBmdW5jdGlvbiBrZXlzIGYxLWYxMlxuICAgICAgICAgIHZhbGlkS2V5ID0gJ2YnICsgKGtleUNvZGUgLSAxMTIgKyAxKTtcbiAgICAgICAgfSBlbHNlIGlmIChrZXlDb2RlID49IDQ4ICYmIGtleUNvZGUgPD0gNTcpIHtcbiAgICAgICAgICAvLyB0b3AgMC05IGtleXNcbiAgICAgICAgICB2YWxpZEtleSA9IFN0cmluZyhrZXlDb2RlIC0gNDgpO1xuICAgICAgICB9IGVsc2UgaWYgKGtleUNvZGUgPj0gOTYgJiYga2V5Q29kZSA8PSAxMDUpIHtcbiAgICAgICAgICAvLyBudW0gcGFkIDAtOVxuICAgICAgICAgIHZhbGlkS2V5ID0gU3RyaW5nKGtleUNvZGUgLSA5Nik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsaWRLZXkgPSBLRVlfQ09ERVtrZXlDb2RlXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbGlkS2V5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAgKiBDYWxjdWxhdGVzIHRoZSBub3JtYWxpemVkIGtleSBmb3IgYSBLZXlib2FyZEV2ZW50LlxuICAgICAgKiBAcGFyYW0ge0tleWJvYXJkRXZlbnR9IGtleUV2ZW50XG4gICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW25vU3BlY2lhbENoYXJzXSBTZXQgdG8gdHJ1ZSB0byBsaW1pdCBrZXlFdmVudC5rZXlcbiAgICAgICogdHJhbnNmb3JtYXRpb24gdG8gYWxwaGEtbnVtZXJpYyBjaGFycy4gVGhpcyBpcyB1c2VmdWwgd2l0aCBrZXlcbiAgICAgICogY29tYmluYXRpb25zIGxpa2Ugc2hpZnQgKyAyLCB3aGljaCBvbiBGRiBmb3IgTWFjT1MgcHJvZHVjZXNcbiAgICAgICoga2V5RXZlbnQua2V5ID0gQFxuICAgICAgKiBUbyBnZXQgMiByZXR1cm5lZCwgc2V0IG5vU3BlY2lhbENoYXJzID0gdHJ1ZVxuICAgICAgKiBUbyBnZXQgQCByZXR1cm5lZCwgc2V0IG5vU3BlY2lhbENoYXJzID0gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBub3JtYWxpemVkS2V5Rm9yRXZlbnQoa2V5RXZlbnQsIG5vU3BlY2lhbENoYXJzKSB7XG4gICAgICAvLyBGYWxsIGJhY2sgZnJvbSAua2V5LCB0byAuZGV0YWlsLmtleSBmb3IgYXJ0aWZpY2FsIGtleWJvYXJkIGV2ZW50cyxcbiAgICAgIC8vIGFuZCB0aGVuIHRvIGRlcHJlY2F0ZWQgLmtleUlkZW50aWZpZXIgYW5kIC5rZXlDb2RlLlxuICAgICAgaWYgKGtleUV2ZW50LmtleSkge1xuICAgICAgICByZXR1cm4gdHJhbnNmb3JtS2V5KGtleUV2ZW50LmtleSwgbm9TcGVjaWFsQ2hhcnMpO1xuICAgICAgfVxuICAgICAgaWYgKGtleUV2ZW50LmRldGFpbCAmJiBrZXlFdmVudC5kZXRhaWwua2V5KSB7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1LZXkoa2V5RXZlbnQuZGV0YWlsLmtleSwgbm9TcGVjaWFsQ2hhcnMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRyYW5zZm9ybUtleUlkZW50aWZpZXIoa2V5RXZlbnQua2V5SWRlbnRpZmllcikgfHxcbiAgICAgICAgdHJhbnNmb3JtS2V5Q29kZShrZXlFdmVudC5rZXlDb2RlKSB8fCAnJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBrZXlDb21ib01hdGNoZXNFdmVudChrZXlDb21ibywgZXZlbnQpIHtcbiAgICAgIC8vIEZvciBjb21ib3Mgd2l0aCBtb2RpZmllcnMgd2Ugc3VwcG9ydCBvbmx5IGFscGhhLW51bWVyaWMga2V5c1xuICAgICAgdmFyIGtleUV2ZW50ID0gbm9ybWFsaXplZEtleUZvckV2ZW50KGV2ZW50LCBrZXlDb21iby5oYXNNb2RpZmllcnMpO1xuICAgICAgcmV0dXJuIGtleUV2ZW50ID09PSBrZXlDb21iby5rZXkgJiZcbiAgICAgICAgKCFrZXlDb21iby5oYXNNb2RpZmllcnMgfHwgKFxuICAgICAgICAgICEhZXZlbnQuc2hpZnRLZXkgPT09ICEha2V5Q29tYm8uc2hpZnRLZXkgJiZcbiAgICAgICAgICAhIWV2ZW50LmN0cmxLZXkgPT09ICEha2V5Q29tYm8uY3RybEtleSAmJlxuICAgICAgICAgICEhZXZlbnQuYWx0S2V5ID09PSAhIWtleUNvbWJvLmFsdEtleSAmJlxuICAgICAgICAgICEhZXZlbnQubWV0YUtleSA9PT0gISFrZXlDb21iby5tZXRhS2V5KVxuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlS2V5Q29tYm9TdHJpbmcoa2V5Q29tYm9TdHJpbmcpIHtcbiAgICAgIGlmIChrZXlDb21ib1N0cmluZy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBjb21ibzoga2V5Q29tYm9TdHJpbmcsXG4gICAgICAgICAga2V5OiBrZXlDb21ib1N0cmluZyxcbiAgICAgICAgICBldmVudDogJ2tleWRvd24nXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ga2V5Q29tYm9TdHJpbmcuc3BsaXQoJysnKS5yZWR1Y2UoZnVuY3Rpb24ocGFyc2VkS2V5Q29tYm8sIGtleUNvbWJvUGFydCkge1xuICAgICAgICB2YXIgZXZlbnRQYXJ0cyA9IGtleUNvbWJvUGFydC5zcGxpdCgnOicpO1xuICAgICAgICB2YXIga2V5TmFtZSA9IGV2ZW50UGFydHNbMF07XG4gICAgICAgIHZhciBldmVudCA9IGV2ZW50UGFydHNbMV07XG5cbiAgICAgICAgaWYgKGtleU5hbWUgaW4gTU9ESUZJRVJfS0VZUykge1xuICAgICAgICAgIHBhcnNlZEtleUNvbWJvW01PRElGSUVSX0tFWVNba2V5TmFtZV1dID0gdHJ1ZTtcbiAgICAgICAgICBwYXJzZWRLZXlDb21iby5oYXNNb2RpZmllcnMgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhcnNlZEtleUNvbWJvLmtleSA9IGtleU5hbWU7XG4gICAgICAgICAgcGFyc2VkS2V5Q29tYm8uZXZlbnQgPSBldmVudCB8fCAna2V5ZG93bic7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGFyc2VkS2V5Q29tYm87XG4gICAgICB9LCB7XG4gICAgICAgIGNvbWJvOiBrZXlDb21ib1N0cmluZy5zcGxpdCgnOicpLnNoaWZ0KClcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlRXZlbnRTdHJpbmcoZXZlbnRTdHJpbmcpIHtcbiAgICAgIHJldHVybiBldmVudFN0cmluZy50cmltKCkuc3BsaXQoJyAnKS5tYXAoZnVuY3Rpb24oa2V5Q29tYm9TdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlS2V5Q29tYm9TdHJpbmcoa2V5Q29tYm9TdHJpbmcpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogYFBvbHltZXIuSXJvbkExMXlLZXlzQmVoYXZpb3JgIHByb3ZpZGVzIGEgbm9ybWFsaXplZCBpbnRlcmZhY2UgZm9yIHByb2Nlc3NpbmdcbiAgICAgKiBrZXlib2FyZCBjb21tYW5kcyB0aGF0IHBlcnRhaW4gdG8gW1dBSS1BUklBIGJlc3QgcHJhY3RpY2VzXShodHRwOi8vd3d3LnczLm9yZy9UUi93YWktYXJpYS1wcmFjdGljZXMvI2tiZF9nZW5lcmFsX2JpbmRpbmcpLlxuICAgICAqIFRoZSBlbGVtZW50IHRha2VzIGNhcmUgb2YgYnJvd3NlciBkaWZmZXJlbmNlcyB3aXRoIHJlc3BlY3QgdG8gS2V5Ym9hcmQgZXZlbnRzXG4gICAgICogYW5kIHVzZXMgYW4gZXhwcmVzc2l2ZSBzeW50YXggdG8gZmlsdGVyIGtleSBwcmVzc2VzLlxuICAgICAqXG4gICAgICogVXNlIHRoZSBga2V5QmluZGluZ3NgIHByb3RvdHlwZSBwcm9wZXJ0eSB0byBleHByZXNzIHdoYXQgY29tYmluYXRpb24gb2Yga2V5c1xuICAgICAqIHdpbGwgdHJpZ2dlciB0aGUgY2FsbGJhY2suIEEga2V5IGJpbmRpbmcgaGFzIHRoZSBmb3JtYXRcbiAgICAgKiBgXCJLRVkrTU9ESUZJRVI6RVZFTlRcIjogXCJjYWxsYmFja1wiYCAoYFwiS0VZXCI6IFwiY2FsbGJhY2tcImAgb3JcbiAgICAgKiBgXCJLRVk6RVZFTlRcIjogXCJjYWxsYmFja1wiYCBhcmUgdmFsaWQgYXMgd2VsbCkuIFNvbWUgZXhhbXBsZXM6XG4gICAgICpcbiAgICAgKiAgICAgIGtleUJpbmRpbmdzOiB7XG4gICAgICogICAgICAgICdzcGFjZSc6ICdfb25LZXlkb3duJywgLy8gc2FtZSBhcyAnc3BhY2U6a2V5ZG93bidcbiAgICAgKiAgICAgICAgJ3NoaWZ0K3RhYic6ICdfb25LZXlkb3duJyxcbiAgICAgKiAgICAgICAgJ2VudGVyOmtleXByZXNzJzogJ19vbktleXByZXNzJyxcbiAgICAgKiAgICAgICAgJ2VzYzprZXl1cCc6ICdfb25LZXl1cCdcbiAgICAgKiAgICAgIH1cbiAgICAgKlxuICAgICAqIFRoZSBjYWxsYmFjayB3aWxsIHJlY2VpdmUgd2l0aCBhbiBldmVudCBjb250YWluaW5nIHRoZSBmb2xsb3dpbmcgaW5mb3JtYXRpb24gaW4gYGV2ZW50LmRldGFpbGA6XG4gICAgICpcbiAgICAgKiAgICAgIF9vbktleWRvd246IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICogICAgICAgIGNvbnNvbGUubG9nKGV2ZW50LmRldGFpbC5jb21ibyk7IC8vIEtFWStNT0RJRklFUiwgZS5nLiBcInNoaWZ0K3RhYlwiXG4gICAgICogICAgICAgIGNvbnNvbGUubG9nKGV2ZW50LmRldGFpbC5rZXkpOyAvLyBLRVkgb25seSwgZS5nLiBcInRhYlwiXG4gICAgICogICAgICAgIGNvbnNvbGUubG9nKGV2ZW50LmRldGFpbC5ldmVudCk7IC8vIEVWRU5ULCBlLmcuIFwia2V5ZG93blwiXG4gICAgICogICAgICAgIGNvbnNvbGUubG9nKGV2ZW50LmRldGFpbC5rZXlib2FyZEV2ZW50KTsgLy8gdGhlIG9yaWdpbmFsIEtleWJvYXJkRXZlbnRcbiAgICAgKiAgICAgIH1cbiAgICAgKlxuICAgICAqIFVzZSB0aGUgYGtleUV2ZW50VGFyZ2V0YCBhdHRyaWJ1dGUgdG8gc2V0IHVwIGV2ZW50IGhhbmRsZXJzIG9uIGEgc3BlY2lmaWNcbiAgICAgKiBub2RlLlxuICAgICAqXG4gICAgICogU2VlIHRoZSBbZGVtbyBzb3VyY2UgY29kZV0oaHR0cHM6Ly9naXRodWIuY29tL1BvbHltZXJFbGVtZW50cy9pcm9uLWExMXkta2V5cy1iZWhhdmlvci9ibG9iL21hc3Rlci9kZW1vL3gta2V5LWF3YXJlLmh0bWwpXG4gICAgICogZm9yIGFuIGV4YW1wbGUuXG4gICAgICpcbiAgICAgKiBAZGVtbyBkZW1vL2luZGV4Lmh0bWxcbiAgICAgKiBAcG9seW1lckJlaGF2aW9yXG4gICAgICovXG4gICAgUG9seW1lci5Jcm9uQTExeUtleXNCZWhhdmlvciA9IHtcbiAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBFdmVudFRhcmdldCB0aGF0IHdpbGwgYmUgZmlyaW5nIHJlbGV2YW50IEtleWJvYXJkRXZlbnRzLiBTZXQgaXQgdG9cbiAgICAgICAgICogYG51bGxgIHRvIGRpc2FibGUgdGhlIGxpc3RlbmVycy5cbiAgICAgICAgICogQHR5cGUgez9FdmVudFRhcmdldH1cbiAgICAgICAgICovXG4gICAgICAgIGtleUV2ZW50VGFyZ2V0OiB7XG4gICAgICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgdHJ1ZSwgdGhpcyBwcm9wZXJ0eSB3aWxsIGNhdXNlIHRoZSBpbXBsZW1lbnRpbmcgZWxlbWVudCB0b1xuICAgICAgICAgKiBhdXRvbWF0aWNhbGx5IHN0b3AgcHJvcGFnYXRpb24gb24gYW55IGhhbmRsZWQgS2V5Ym9hcmRFdmVudHMuXG4gICAgICAgICAqL1xuICAgICAgICBzdG9wS2V5Ym9hcmRFdmVudFByb3BhZ2F0aW9uOiB7XG4gICAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgfSxcblxuICAgICAgICBfYm91bmRLZXlIYW5kbGVyczoge1xuICAgICAgICAgIHR5cGU6IEFycmF5LFxuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gV2UgdXNlIHRoaXMgZHVlIHRvIGEgbGltaXRhdGlvbiBpbiBJRTEwIHdoZXJlIGluc3RhbmNlcyB3aWxsIGhhdmVcbiAgICAgICAgLy8gb3duIHByb3BlcnRpZXMgb2YgZXZlcnl0aGluZyBvbiB0aGUgXCJwcm90b3R5cGVcIi5cbiAgICAgICAgX2ltcGVyYXRpdmVLZXlCaW5kaW5nczoge1xuICAgICAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBvYnNlcnZlcnM6IFtcbiAgICAgICAgJ19yZXNldEtleUV2ZW50TGlzdGVuZXJzKGtleUV2ZW50VGFyZ2V0LCBfYm91bmRLZXlIYW5kbGVycyknXG4gICAgICBdLFxuXG5cbiAgICAgIC8qKlxuICAgICAgICogVG8gYmUgdXNlZCB0byBleHByZXNzIHdoYXQgY29tYmluYXRpb24gb2Yga2V5cyAgd2lsbCB0cmlnZ2VyIHRoZSByZWxhdGl2ZVxuICAgICAgICogY2FsbGJhY2suIGUuZy4gYGtleUJpbmRpbmdzOiB7ICdlc2MnOiAnX29uRXNjUHJlc3NlZCd9YFxuICAgICAgICogQHR5cGUgeyFPYmplY3R9XG4gICAgICAgKi9cbiAgICAgIGtleUJpbmRpbmdzOiB7fSxcblxuICAgICAgcmVnaXN0ZXJlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX3ByZXBLZXlCaW5kaW5ncygpO1xuICAgICAgfSxcblxuICAgICAgYXR0YWNoZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9saXN0ZW5LZXlFdmVudExpc3RlbmVycygpO1xuICAgICAgfSxcblxuICAgICAgZGV0YWNoZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl91bmxpc3RlbktleUV2ZW50TGlzdGVuZXJzKCk7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIENhbiBiZSB1c2VkIHRvIGltcGVyYXRpdmVseSBhZGQgYSBrZXkgYmluZGluZyB0byB0aGUgaW1wbGVtZW50aW5nXG4gICAgICAgKiBlbGVtZW50LiBUaGlzIGlzIHRoZSBpbXBlcmF0aXZlIGVxdWl2YWxlbnQgb2YgZGVjbGFyaW5nIGEga2V5YmluZGluZ1xuICAgICAgICogaW4gdGhlIGBrZXlCaW5kaW5nc2AgcHJvdG90eXBlIHByb3BlcnR5LlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFN0cmluZ1xuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGhhbmRsZXJOYW1lXG4gICAgICAgKi9cbiAgICAgIGFkZE93bktleUJpbmRpbmc6IGZ1bmN0aW9uKGV2ZW50U3RyaW5nLCBoYW5kbGVyTmFtZSkge1xuICAgICAgICB0aGlzLl9pbXBlcmF0aXZlS2V5QmluZGluZ3NbZXZlbnRTdHJpbmddID0gaGFuZGxlck5hbWU7XG4gICAgICAgIHRoaXMuX3ByZXBLZXlCaW5kaW5ncygpO1xuICAgICAgICB0aGlzLl9yZXNldEtleUV2ZW50TGlzdGVuZXJzKCk7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFdoZW4gY2FsbGVkLCB3aWxsIHJlbW92ZSBhbGwgaW1wZXJhdGl2ZWx5LWFkZGVkIGtleSBiaW5kaW5ncy5cbiAgICAgICAqL1xuICAgICAgcmVtb3ZlT3duS2V5QmluZGluZ3M6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9pbXBlcmF0aXZlS2V5QmluZGluZ3MgPSB7fTtcbiAgICAgICAgdGhpcy5fcHJlcEtleUJpbmRpbmdzKCk7XG4gICAgICAgIHRoaXMuX3Jlc2V0S2V5RXZlbnRMaXN0ZW5lcnMoKTtcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogUmV0dXJucyB0cnVlIGlmIGEga2V5Ym9hcmQgZXZlbnQgbWF0Y2hlcyBgZXZlbnRTdHJpbmdgLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7S2V5Ym9hcmRFdmVudH0gZXZlbnRcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFN0cmluZ1xuICAgICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgICAqL1xuICAgICAga2V5Ym9hcmRFdmVudE1hdGNoZXNLZXlzOiBmdW5jdGlvbihldmVudCwgZXZlbnRTdHJpbmcpIHtcbiAgICAgICAgdmFyIGtleUNvbWJvcyA9IHBhcnNlRXZlbnRTdHJpbmcoZXZlbnRTdHJpbmcpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleUNvbWJvcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGlmIChrZXlDb21ib01hdGNoZXNFdmVudChrZXlDb21ib3NbaV0sIGV2ZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0sXG5cbiAgICAgIF9jb2xsZWN0S2V5QmluZGluZ3M6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIga2V5QmluZGluZ3MgPSB0aGlzLmJlaGF2aW9ycy5tYXAoZnVuY3Rpb24oYmVoYXZpb3IpIHtcbiAgICAgICAgICByZXR1cm4gYmVoYXZpb3Iua2V5QmluZGluZ3M7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChrZXlCaW5kaW5ncy5pbmRleE9mKHRoaXMua2V5QmluZGluZ3MpID09PSAtMSkge1xuICAgICAgICAgIGtleUJpbmRpbmdzLnB1c2godGhpcy5rZXlCaW5kaW5ncyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ga2V5QmluZGluZ3M7XG4gICAgICB9LFxuXG4gICAgICBfcHJlcEtleUJpbmRpbmdzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fa2V5QmluZGluZ3MgPSB7fTtcblxuICAgICAgICB0aGlzLl9jb2xsZWN0S2V5QmluZGluZ3MoKS5mb3JFYWNoKGZ1bmN0aW9uKGtleUJpbmRpbmdzKSB7XG4gICAgICAgICAgZm9yICh2YXIgZXZlbnRTdHJpbmcgaW4ga2V5QmluZGluZ3MpIHtcbiAgICAgICAgICAgIHRoaXMuX2FkZEtleUJpbmRpbmcoZXZlbnRTdHJpbmcsIGtleUJpbmRpbmdzW2V2ZW50U3RyaW5nXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICBmb3IgKHZhciBldmVudFN0cmluZyBpbiB0aGlzLl9pbXBlcmF0aXZlS2V5QmluZGluZ3MpIHtcbiAgICAgICAgICB0aGlzLl9hZGRLZXlCaW5kaW5nKGV2ZW50U3RyaW5nLCB0aGlzLl9pbXBlcmF0aXZlS2V5QmluZGluZ3NbZXZlbnRTdHJpbmddKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEdpdmUgcHJlY2VkZW5jZSB0byBjb21ib3Mgd2l0aCBtb2RpZmllcnMgdG8gYmUgY2hlY2tlZCBmaXJzdC5cbiAgICAgICAgZm9yICh2YXIgZXZlbnROYW1lIGluIHRoaXMuX2tleUJpbmRpbmdzKSB7XG4gICAgICAgICAgdGhpcy5fa2V5QmluZGluZ3NbZXZlbnROYW1lXS5zb3J0KGZ1bmN0aW9uIChrYjEsIGtiMikge1xuICAgICAgICAgICAgdmFyIGIxID0ga2IxWzBdLmhhc01vZGlmaWVycztcbiAgICAgICAgICAgIHZhciBiMiA9IGtiMlswXS5oYXNNb2RpZmllcnM7XG4gICAgICAgICAgICByZXR1cm4gKGIxID09PSBiMikgPyAwIDogYjEgPyAtMSA6IDE7XG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgX2FkZEtleUJpbmRpbmc6IGZ1bmN0aW9uKGV2ZW50U3RyaW5nLCBoYW5kbGVyTmFtZSkge1xuICAgICAgICBwYXJzZUV2ZW50U3RyaW5nKGV2ZW50U3RyaW5nKS5mb3JFYWNoKGZ1bmN0aW9uKGtleUNvbWJvKSB7XG4gICAgICAgICAgdGhpcy5fa2V5QmluZGluZ3Nba2V5Q29tYm8uZXZlbnRdID1cbiAgICAgICAgICAgIHRoaXMuX2tleUJpbmRpbmdzW2tleUNvbWJvLmV2ZW50XSB8fCBbXTtcblxuICAgICAgICAgIHRoaXMuX2tleUJpbmRpbmdzW2tleUNvbWJvLmV2ZW50XS5wdXNoKFtcbiAgICAgICAgICAgIGtleUNvbWJvLFxuICAgICAgICAgICAgaGFuZGxlck5hbWVcbiAgICAgICAgICBdKTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICB9LFxuXG4gICAgICBfcmVzZXRLZXlFdmVudExpc3RlbmVyczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX3VubGlzdGVuS2V5RXZlbnRMaXN0ZW5lcnMoKTtcblxuICAgICAgICBpZiAodGhpcy5pc0F0dGFjaGVkKSB7XG4gICAgICAgICAgdGhpcy5fbGlzdGVuS2V5RXZlbnRMaXN0ZW5lcnMoKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgX2xpc3RlbktleUV2ZW50TGlzdGVuZXJzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmtleUV2ZW50VGFyZ2V0KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5rZXlzKHRoaXMuX2tleUJpbmRpbmdzKS5mb3JFYWNoKGZ1bmN0aW9uKGV2ZW50TmFtZSkge1xuICAgICAgICAgIHZhciBrZXlCaW5kaW5ncyA9IHRoaXMuX2tleUJpbmRpbmdzW2V2ZW50TmFtZV07XG4gICAgICAgICAgdmFyIGJvdW5kS2V5SGFuZGxlciA9IHRoaXMuX29uS2V5QmluZGluZ0V2ZW50LmJpbmQodGhpcywga2V5QmluZGluZ3MpO1xuXG4gICAgICAgICAgdGhpcy5fYm91bmRLZXlIYW5kbGVycy5wdXNoKFt0aGlzLmtleUV2ZW50VGFyZ2V0LCBldmVudE5hbWUsIGJvdW5kS2V5SGFuZGxlcl0pO1xuXG4gICAgICAgICAgdGhpcy5rZXlFdmVudFRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgYm91bmRLZXlIYW5kbGVyKTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICB9LFxuXG4gICAgICBfdW5saXN0ZW5LZXlFdmVudExpc3RlbmVyczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBrZXlIYW5kbGVyVHVwbGU7XG4gICAgICAgIHZhciBrZXlFdmVudFRhcmdldDtcbiAgICAgICAgdmFyIGV2ZW50TmFtZTtcbiAgICAgICAgdmFyIGJvdW5kS2V5SGFuZGxlcjtcblxuICAgICAgICB3aGlsZSAodGhpcy5fYm91bmRLZXlIYW5kbGVycy5sZW5ndGgpIHtcbiAgICAgICAgICAvLyBNeSBraW5nZG9tIGZvciBibG9jay1zY29wZSBiaW5kaW5nIGFuZCBkZXN0cnVjdHVyaW5nIGFzc2lnbm1lbnQuLlxuICAgICAgICAgIGtleUhhbmRsZXJUdXBsZSA9IHRoaXMuX2JvdW5kS2V5SGFuZGxlcnMucG9wKCk7XG4gICAgICAgICAga2V5RXZlbnRUYXJnZXQgPSBrZXlIYW5kbGVyVHVwbGVbMF07XG4gICAgICAgICAgZXZlbnROYW1lID0ga2V5SGFuZGxlclR1cGxlWzFdO1xuICAgICAgICAgIGJvdW5kS2V5SGFuZGxlciA9IGtleUhhbmRsZXJUdXBsZVsyXTtcblxuICAgICAgICAgIGtleUV2ZW50VGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBib3VuZEtleUhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBfb25LZXlCaW5kaW5nRXZlbnQ6IGZ1bmN0aW9uKGtleUJpbmRpbmdzLCBldmVudCkge1xuICAgICAgICBpZiAodGhpcy5zdG9wS2V5Ym9hcmRFdmVudFByb3BhZ2F0aW9uKSB7XG4gICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiBldmVudCBoYXMgYmVlbiBhbHJlYWR5IHByZXZlbnRlZCwgZG9uJ3QgZG8gYW55dGhpbmdcbiAgICAgICAgaWYgKGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleUJpbmRpbmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGtleUNvbWJvID0ga2V5QmluZGluZ3NbaV1bMF07XG4gICAgICAgICAgdmFyIGhhbmRsZXJOYW1lID0ga2V5QmluZGluZ3NbaV1bMV07XG4gICAgICAgICAgaWYgKGtleUNvbWJvTWF0Y2hlc0V2ZW50KGtleUNvbWJvLCBldmVudCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3RyaWdnZXJLZXlIYW5kbGVyKGtleUNvbWJvLCBoYW5kbGVyTmFtZSwgZXZlbnQpO1xuICAgICAgICAgICAgLy8gZXhpdCB0aGUgbG9vcCBpZiBldmVudERlZmF1bHQgd2FzIHByZXZlbnRlZFxuICAgICAgICAgICAgaWYgKGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgX3RyaWdnZXJLZXlIYW5kbGVyOiBmdW5jdGlvbihrZXlDb21ibywgaGFuZGxlck5hbWUsIGtleWJvYXJkRXZlbnQpIHtcbiAgICAgICAgdmFyIGRldGFpbCA9IE9iamVjdC5jcmVhdGUoa2V5Q29tYm8pO1xuICAgICAgICBkZXRhaWwua2V5Ym9hcmRFdmVudCA9IGtleWJvYXJkRXZlbnQ7XG4gICAgICAgIHZhciBldmVudCA9IG5ldyBDdXN0b21FdmVudChrZXlDb21iby5ldmVudCwge1xuICAgICAgICAgIGRldGFpbDogZGV0YWlsLFxuICAgICAgICAgIGNhbmNlbGFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXNbaGFuZGxlck5hbWVdLmNhbGwodGhpcywgZXZlbnQpO1xuICAgICAgICBpZiAoZXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICAgIGtleWJvYXJkRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH0pKCk7XG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvaXJvbi1hMTF5LWtleXMtYmVoYXZpb3IvaXJvbi1hMTF5LWtleXMtYmVoYXZpb3IuaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTUgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cblxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3BvbHltZXIvcG9seW1lci5odG1sXCI+XG5cbjxzY3JpcHQ+XG4gIC8qKlxuICAgKiBgSXJvblJlc2l6YWJsZUJlaGF2aW9yYCBpcyBhIGJlaGF2aW9yIHRoYXQgY2FuIGJlIHVzZWQgaW4gUG9seW1lciBlbGVtZW50cyB0b1xuICAgKiBjb29yZGluYXRlIHRoZSBmbG93IG9mIHJlc2l6ZSBldmVudHMgYmV0d2VlbiBcInJlc2l6ZXJzXCIgKGVsZW1lbnRzIHRoYXQgY29udHJvbCB0aGVcbiAgICogc2l6ZSBvciBoaWRkZW4gc3RhdGUgb2YgdGhlaXIgY2hpbGRyZW4pIGFuZCBcInJlc2l6YWJsZXNcIiAoZWxlbWVudHMgdGhhdCBuZWVkIHRvIGJlXG4gICAqIG5vdGlmaWVkIHdoZW4gdGhleSBhcmUgcmVzaXplZCBvciB1bi1oaWRkZW4gYnkgdGhlaXIgcGFyZW50cyBpbiBvcmRlciB0byB0YWtlXG4gICAqIGFjdGlvbiBvbiB0aGVpciBuZXcgbWVhc3VyZW1lbnRzKS5cbiAgICpcbiAgICogRWxlbWVudHMgdGhhdCBwZXJmb3JtIG1lYXN1cmVtZW50IHNob3VsZCBhZGQgdGhlIGBJcm9uUmVzaXphYmxlQmVoYXZpb3JgIGJlaGF2aW9yIHRvXG4gICAqIHRoZWlyIGVsZW1lbnQgZGVmaW5pdGlvbiBhbmQgbGlzdGVuIGZvciB0aGUgYGlyb24tcmVzaXplYCBldmVudCBvbiB0aGVtc2VsdmVzLlxuICAgKiBUaGlzIGV2ZW50IHdpbGwgYmUgZmlyZWQgd2hlbiB0aGV5IGJlY29tZSBzaG93aW5nIGFmdGVyIGhhdmluZyBiZWVuIGhpZGRlbixcbiAgICogd2hlbiB0aGV5IGFyZSByZXNpemVkIGV4cGxpY2l0bHkgYnkgYW5vdGhlciByZXNpemFibGUsIG9yIHdoZW4gdGhlIHdpbmRvdyBoYXMgYmVlblxuICAgKiByZXNpemVkLlxuICAgKlxuICAgKiBOb3RlLCB0aGUgYGlyb24tcmVzaXplYCBldmVudCBpcyBub24tYnViYmxpbmcuXG4gICAqXG4gICAqIEBwb2x5bWVyQmVoYXZpb3IgUG9seW1lci5Jcm9uUmVzaXphYmxlQmVoYXZpb3JcbiAgICogQGRlbW8gZGVtby9pbmRleC5odG1sXG4gICAqKi9cbiAgUG9seW1lci5Jcm9uUmVzaXphYmxlQmVoYXZpb3IgPSB7XG4gICAgcHJvcGVydGllczoge1xuICAgICAgLyoqXG4gICAgICAgKiBUaGUgY2xvc2VzdCBhbmNlc3RvciBlbGVtZW50IHRoYXQgaW1wbGVtZW50cyBgSXJvblJlc2l6YWJsZUJlaGF2aW9yYC5cbiAgICAgICAqL1xuICAgICAgX3BhcmVudFJlc2l6YWJsZToge1xuICAgICAgICB0eXBlOiBPYmplY3QsXG4gICAgICAgIG9ic2VydmVyOiAnX3BhcmVudFJlc2l6YWJsZUNoYW5nZWQnXG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFRydWUgaWYgdGhpcyBlbGVtZW50IGlzIGN1cnJlbnRseSBub3RpZnlpbmcgaXRzIGRlc2NlbmRhbnQgZWxlbWVudHMgb2ZcbiAgICAgICAqIHJlc2l6ZS5cbiAgICAgICAqL1xuICAgICAgX25vdGlmeWluZ0Rlc2NlbmRhbnQ6IHtcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICB9XG4gICAgfSxcblxuICAgIGxpc3RlbmVyczoge1xuICAgICAgJ2lyb24tcmVxdWVzdC1yZXNpemUtbm90aWZpY2F0aW9ucyc6ICdfb25Jcm9uUmVxdWVzdFJlc2l6ZU5vdGlmaWNhdGlvbnMnXG4gICAgfSxcblxuICAgIGNyZWF0ZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gV2UgZG9uJ3QgcmVhbGx5IG5lZWQgcHJvcGVydHkgZWZmZWN0cyBvbiB0aGVzZSwgYW5kIGFsc28gd2Ugd2FudCB0aGVtXG4gICAgICAvLyB0byBiZSBjcmVhdGVkIGJlZm9yZSB0aGUgYF9wYXJlbnRSZXNpemFibGVgIG9ic2VydmVyIGZpcmVzOlxuICAgICAgdGhpcy5faW50ZXJlc3RlZFJlc2l6YWJsZXMgPSBbXTtcbiAgICAgIHRoaXMuX2JvdW5kTm90aWZ5UmVzaXplID0gdGhpcy5ub3RpZnlSZXNpemUuYmluZCh0aGlzKTtcbiAgICB9LFxuXG4gICAgYXR0YWNoZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fcmVxdWVzdFJlc2l6ZU5vdGlmaWNhdGlvbnMoKTtcbiAgICB9LFxuXG4gICAgZGV0YWNoZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuX3BhcmVudFJlc2l6YWJsZSkge1xuICAgICAgICB0aGlzLl9wYXJlbnRSZXNpemFibGUuc3RvcFJlc2l6ZU5vdGlmaWNhdGlvbnNGb3IodGhpcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5fYm91bmROb3RpZnlSZXNpemUpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9wYXJlbnRSZXNpemFibGUgPSBudWxsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYW4gYmUgY2FsbGVkIHRvIG1hbnVhbGx5IG5vdGlmeSBhIHJlc2l6YWJsZSBhbmQgaXRzIGRlc2NlbmRhbnRcbiAgICAgKiByZXNpemFibGVzIG9mIGEgcmVzaXplIGNoYW5nZS5cbiAgICAgKi9cbiAgICBub3RpZnlSZXNpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLmlzQXR0YWNoZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9pbnRlcmVzdGVkUmVzaXphYmxlcy5mb3JFYWNoKGZ1bmN0aW9uKHJlc2l6YWJsZSkge1xuICAgICAgICBpZiAodGhpcy5yZXNpemVyU2hvdWxkTm90aWZ5KHJlc2l6YWJsZSkpIHtcbiAgICAgICAgICB0aGlzLl9ub3RpZnlEZXNjZW5kYW50KHJlc2l6YWJsZSk7XG4gICAgICAgIH1cbiAgICAgIH0sIHRoaXMpO1xuXG4gICAgICB0aGlzLl9maXJlUmVzaXplKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gYXNzaWduIHRoZSBjbG9zZXN0IHJlc2l6YWJsZSBhbmNlc3RvciB0byB0aGlzIHJlc2l6YWJsZVxuICAgICAqIGlmIHRoZSBhbmNlc3RvciBkZXRlY3RzIGEgcmVxdWVzdCBmb3Igbm90aWZpY2F0aW9ucy5cbiAgICAgKi9cbiAgICBhc3NpZ25QYXJlbnRSZXNpemFibGU6IGZ1bmN0aW9uKHBhcmVudFJlc2l6YWJsZSkge1xuICAgICAgdGhpcy5fcGFyZW50UmVzaXphYmxlID0gcGFyZW50UmVzaXphYmxlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIHJlbW92ZSBhIHJlc2l6YWJsZSBkZXNjZW5kYW50IGZyb20gdGhlIGxpc3Qgb2YgZGVzY2VuZGFudHNcbiAgICAgKiB0aGF0IHNob3VsZCBiZSBub3RpZmllZCBvZiBhIHJlc2l6ZSBjaGFuZ2UuXG4gICAgICovXG4gICAgc3RvcFJlc2l6ZU5vdGlmaWNhdGlvbnNGb3I6IGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgdmFyIGluZGV4ID0gdGhpcy5faW50ZXJlc3RlZFJlc2l6YWJsZXMuaW5kZXhPZih0YXJnZXQpO1xuXG4gICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICB0aGlzLl9pbnRlcmVzdGVkUmVzaXphYmxlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB0aGlzLnVubGlzdGVuKHRhcmdldCwgJ2lyb24tcmVzaXplJywgJ19vbkRlc2NlbmRhbnRJcm9uUmVzaXplJyk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGNhbiBiZSBvdmVycmlkZGVuIHRvIGZpbHRlciBuZXN0ZWQgZWxlbWVudHMgdGhhdCBzaG91bGQgb3JcbiAgICAgKiBzaG91bGQgbm90IGJlIG5vdGlmaWVkIGJ5IHRoZSBjdXJyZW50IGVsZW1lbnQuIFJldHVybiB0cnVlIGlmIGFuIGVsZW1lbnRcbiAgICAgKiBzaG91bGQgYmUgbm90aWZpZWQsIG9yIGZhbHNlIGlmIGl0IHNob3VsZCBub3QgYmUgbm90aWZpZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IEEgY2FuZGlkYXRlIGRlc2NlbmRhbnQgZWxlbWVudCB0aGF0XG4gICAgICogaW1wbGVtZW50cyBgSXJvblJlc2l6YWJsZUJlaGF2aW9yYC5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBgZWxlbWVudGAgc2hvdWxkIGJlIG5vdGlmaWVkIG9mIHJlc2l6ZS5cbiAgICAgKi9cbiAgICByZXNpemVyU2hvdWxkTm90aWZ5OiBmdW5jdGlvbihlbGVtZW50KSB7IHJldHVybiB0cnVlOyB9LFxuXG4gICAgX29uRGVzY2VuZGFudElyb25SZXNpemU6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICBpZiAodGhpcy5fbm90aWZ5aW5nRGVzY2VuZGFudCkge1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBOT1RFKGNkYXRhKTogSW4gU2hhZG93RE9NLCBldmVudCByZXRhcmdldGluZyBtYWtlcyBlY2hvaW5nIG9mIHRoZVxuICAgICAgLy8gb3RoZXJ3aXNlIG5vbi1idWJibGluZyBldmVudCBcImp1c3Qgd29yay5cIiBXZSBkbyBpdCBtYW51YWxseSBoZXJlIGZvclxuICAgICAgLy8gdGhlIGNhc2Ugd2hlcmUgUG9seW1lciBpcyBub3QgdXNpbmcgc2hhZG93IHJvb3RzIGZvciB3aGF0ZXZlciByZWFzb246XG4gICAgICBpZiAoIVBvbHltZXIuU2V0dGluZ3MudXNlU2hhZG93KSB7XG4gICAgICAgIHRoaXMuX2ZpcmVSZXNpemUoKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgX2ZpcmVSZXNpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5maXJlKCdpcm9uLXJlc2l6ZScsIG51bGwsIHtcbiAgICAgICAgbm9kZTogdGhpcyxcbiAgICAgICAgYnViYmxlczogZmFsc2VcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBfb25Jcm9uUmVxdWVzdFJlc2l6ZU5vdGlmaWNhdGlvbnM6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICB2YXIgdGFyZ2V0ID0gLyoqIEB0eXBlIHshRXZlbnRUYXJnZXR9ICovIChQb2x5bWVyLmRvbShldmVudCkucm9vdFRhcmdldCk7XG4gICAgICBpZiAodGFyZ2V0ID09PSB0aGlzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2ludGVyZXN0ZWRSZXNpemFibGVzLmluZGV4T2YodGFyZ2V0KSA9PT0gLTEpIHtcbiAgICAgICAgdGhpcy5faW50ZXJlc3RlZFJlc2l6YWJsZXMucHVzaCh0YXJnZXQpO1xuICAgICAgICB0aGlzLmxpc3Rlbih0YXJnZXQsICdpcm9uLXJlc2l6ZScsICdfb25EZXNjZW5kYW50SXJvblJlc2l6ZScpO1xuICAgICAgfVxuXG4gICAgICB0YXJnZXQuYXNzaWduUGFyZW50UmVzaXphYmxlKHRoaXMpO1xuICAgICAgdGhpcy5fbm90aWZ5RGVzY2VuZGFudCh0YXJnZXQpO1xuXG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9LFxuXG4gICAgX3BhcmVudFJlc2l6YWJsZUNoYW5nZWQ6IGZ1bmN0aW9uKHBhcmVudFJlc2l6YWJsZSkge1xuICAgICAgaWYgKHBhcmVudFJlc2l6YWJsZSkge1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5fYm91bmROb3RpZnlSZXNpemUpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBfbm90aWZ5RGVzY2VuZGFudDogZnVuY3Rpb24oZGVzY2VuZGFudCkge1xuICAgICAgLy8gTk9URShjZGF0YSk6IEluIElFMTAsIGF0dGFjaGVkIGlzIGZpcmVkIG9uIGNoaWxkcmVuIGZpcnN0LCBzbyBpdCdzXG4gICAgICAvLyBpbXBvcnRhbnQgbm90IHRvIG5vdGlmeSB0aGVtIGlmIHRoZSBwYXJlbnQgaXMgbm90IGF0dGFjaGVkIHlldCAob3JcbiAgICAgIC8vIGVsc2UgdGhleSB3aWxsIGdldCByZWR1bmRhbnRseSBub3RpZmllZCB3aGVuIHRoZSBwYXJlbnQgYXR0YWNoZXMpLlxuICAgICAgaWYgKCF0aGlzLmlzQXR0YWNoZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9ub3RpZnlpbmdEZXNjZW5kYW50ID0gdHJ1ZTtcbiAgICAgIGRlc2NlbmRhbnQubm90aWZ5UmVzaXplKCk7XG4gICAgICB0aGlzLl9ub3RpZnlpbmdEZXNjZW5kYW50ID0gZmFsc2U7XG4gICAgfSxcbiAgICBcbiAgICBfcmVxdWVzdFJlc2l6ZU5vdGlmaWNhdGlvbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLmlzQXR0YWNoZWQpXG4gICAgICAgIHJldHVybjtcbiAgICAgIFxuICAgICAgLy8gTk9URSh2YWxkcmluKSBJbiBDdXN0b21FbGVtZW50cyB2MSB3aXRoIG5hdGl2ZSBIVE1MSW1wb3J0cywgdGhlIG9yZGVyXG4gICAgICAvLyBvZiBpbXBvcnRzIGFmZmVjdHMgdGhlIG9yZGVyIG9mIGBhdHRhY2hlZGAgY2FsbGJhY2tzIChzZWUgd2ViY29tcG9uZW50cy9jdXN0b20tZWxlbWVudHMjMTUpLlxuICAgICAgLy8gVGhpcyBtaWdodCBjYXVzZSBhIGNoaWxkIHRvIG5vdGlmeSBwYXJlbnRzIHRvbyBlYXJseSAoYXMgdGhlIHBhcmVudFxuICAgICAgLy8gc3RpbGwgaGFzIHRvIGJlIHVwZ3JhZGVkKSwgcmVzdWx0aW5nIGluIGEgcGFyZW50IG5vdCBhYmxlIHRvIGtlZXAgdHJhY2tcbiAgICAgIC8vIG9mIHRoZSBgX2ludGVyZXN0ZWRSZXNpemFibGVzYC4gVG8gc29sdmUgdGhpcywgd2Ugd2FpdCBmb3IgdGhlIGRvY3VtZW50XG4gICAgICAvLyB0byBiZSBkb25lIGxvYWRpbmcgYmVmb3JlIGZpcmluZyB0aGUgZXZlbnQuXG4gICAgICBpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gJ2xvYWRpbmcnKSB7XG4gICAgICAgIHZhciBfcmVxdWVzdFJlc2l6ZU5vdGlmaWNhdGlvbnMgPSB0aGlzLl9yZXF1ZXN0UmVzaXplTm90aWZpY2F0aW9ucy5iaW5kKHRoaXMpO1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdyZWFkeXN0YXRlY2hhbmdlJywgZnVuY3Rpb24gcmVhZHlzdGF0ZWNoYW5nZWQoKSB7XG4gICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVhZHlzdGF0ZWNoYW5nZScsIHJlYWR5c3RhdGVjaGFuZ2VkKTtcbiAgICAgICAgICBfcmVxdWVzdFJlc2l6ZU5vdGlmaWNhdGlvbnMoKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmZpcmUoJ2lyb24tcmVxdWVzdC1yZXNpemUtbm90aWZpY2F0aW9ucycsIG51bGwsIHtcbiAgICAgICAgICBub2RlOiB0aGlzLFxuICAgICAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICAgICAgY2FuY2VsYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoIXRoaXMuX3BhcmVudFJlc2l6YWJsZSkge1xuICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLl9ib3VuZE5vdGlmeVJlc2l6ZSk7XG4gICAgICAgICAgdGhpcy5ub3RpZnlSZXNpemUoKTtcbiAgICAgICAgfSBcbiAgICAgIH1cbiAgICB9XG4gIH07XG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvaXJvbi1yZXNpemFibGUtYmVoYXZpb3IvaXJvbi1yZXNpemFibGUtYmVoYXZpb3IuaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTUgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cblxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3BvbHltZXIvcG9seW1lci5odG1sXCI+XG5cbjwhLS1cbmBpcm9uLW1ldGFgIGlzIGEgZ2VuZXJpYyBlbGVtZW50IHlvdSBjYW4gdXNlIGZvciBzaGFyaW5nIGluZm9ybWF0aW9uIGFjcm9zcyB0aGUgRE9NIHRyZWUuXG5JdCB1c2VzIFttb25vc3RhdGUgcGF0dGVybl0oaHR0cDovL2MyLmNvbS9jZ2kvd2lraT9Nb25vc3RhdGVQYXR0ZXJuKSBzdWNoIHRoYXQgYW55XG5pbnN0YW5jZSBvZiBpcm9uLW1ldGEgaGFzIGFjY2VzcyB0byB0aGUgc2hhcmVkXG5pbmZvcm1hdGlvbi4gWW91IGNhbiB1c2UgYGlyb24tbWV0YWAgdG8gc2hhcmUgd2hhdGV2ZXIgeW91IHdhbnQgKG9yIGNyZWF0ZSBhbiBleHRlbnNpb25cbltsaWtlIHgtbWV0YV0gZm9yIGVuaGFuY2VtZW50cykuXG5cblRoZSBgaXJvbi1tZXRhYCBpbnN0YW5jZXMgY29udGFpbmluZyB5b3VyIGFjdHVhbCBkYXRhIGNhbiBiZSBsb2FkZWQgaW4gYW4gaW1wb3J0LFxub3IgY29uc3RydWN0ZWQgaW4gYW55IHdheSB5b3Ugc2VlIGZpdC4gVGhlIG9ubHkgcmVxdWlyZW1lbnQgaXMgdGhhdCB5b3UgY3JlYXRlIHRoZW1cbmJlZm9yZSB5b3UgdHJ5IHRvIGFjY2VzcyB0aGVtLlxuXG5FeGFtcGxlczpcblxuSWYgSSBjcmVhdGUgYW4gaW5zdGFuY2UgbGlrZSB0aGlzOlxuXG4gICAgPGlyb24tbWV0YSBrZXk9XCJpbmZvXCIgdmFsdWU9XCJmb28vYmFyXCI+PC9pcm9uLW1ldGE+XG5cbk5vdGUgdGhhdCB2YWx1ZT1cImZvby9iYXJcIiBpcyB0aGUgbWV0YWRhdGEgSSd2ZSBkZWZpbmVkLiBJIGNvdWxkIGRlZmluZSBtb3JlXG5hdHRyaWJ1dGVzIG9yIHVzZSBjaGlsZCBub2RlcyB0byBkZWZpbmUgYWRkaXRpb25hbCBtZXRhZGF0YS5cblxuTm93IEkgY2FuIGFjY2VzcyB0aGF0IGVsZW1lbnQgKGFuZCBpdCdzIG1ldGFkYXRhKSBmcm9tIGFueSBpcm9uLW1ldGEgaW5zdGFuY2VcbnZpYSB0aGUgYnlLZXkgbWV0aG9kLCBlLmcuXG5cbiAgICBtZXRhLmJ5S2V5KCdpbmZvJyk7XG5cblB1cmUgaW1wZXJhdGl2ZSBmb3JtIHdvdWxkIGJlIGxpa2U6XG5cbiAgICBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpcm9uLW1ldGEnKS5ieUtleSgnaW5mbycpO1xuXG5PciwgaW4gYSBQb2x5bWVyIGVsZW1lbnQsIHlvdSBjYW4gaW5jbHVkZSBhIG1ldGEgaW4geW91ciB0ZW1wbGF0ZTpcblxuICAgIDxpcm9uLW1ldGEgaWQ9XCJtZXRhXCI+PC9pcm9uLW1ldGE+XG4gICAgLi4uXG4gICAgdGhpcy4kLm1ldGEuYnlLZXkoJ2luZm8nKTtcblxuQGdyb3VwIElyb24gRWxlbWVudHNcbkBkZW1vIGRlbW8vaW5kZXguaHRtbFxuQGhlcm8gaGVyby5zdmdcbkBlbGVtZW50IGlyb24tbWV0YVxuLS0+XG5cbjxzY3JpcHQ+XG5cbiAgKGZ1bmN0aW9uKCkge1xuXG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHt7dHlwZTogKHN0cmluZ3xudWxsKSwga2V5OiAoc3RyaW5nfG51bGwpLCB2YWx1ZTogKn19IG9wdGlvbnNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBJcm9uTWV0YShvcHRpb25zKSB7XG4gICAgICB0aGlzLnR5cGUgPSAob3B0aW9ucyAmJiBvcHRpb25zLnR5cGUpIHx8ICdkZWZhdWx0JztcbiAgICAgIHRoaXMua2V5ID0gb3B0aW9ucyAmJiBvcHRpb25zLmtleTtcbiAgICAgIGlmICgndmFsdWUnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IG9wdGlvbnMudmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgSXJvbk1ldGEudHlwZXMgPSB7fTtcblxuICAgIElyb25NZXRhLnByb3RvdHlwZSA9IHtcbiAgICAgIGdldCB2YWx1ZSgpIHtcbiAgICAgICAgdmFyIHR5cGUgPSB0aGlzLnR5cGU7XG4gICAgICAgIHZhciBrZXkgPSB0aGlzLmtleTtcblxuICAgICAgICBpZiAodHlwZSAmJiBrZXkpIHtcbiAgICAgICAgICByZXR1cm4gSXJvbk1ldGEudHlwZXNbdHlwZV0gJiYgSXJvbk1ldGEudHlwZXNbdHlwZV1ba2V5XTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgc2V0IHZhbHVlKHZhbHVlKSB7XG4gICAgICAgIHZhciB0eXBlID0gdGhpcy50eXBlO1xuICAgICAgICB2YXIga2V5ID0gdGhpcy5rZXk7XG5cbiAgICAgICAgaWYgKHR5cGUgJiYga2V5KSB7XG4gICAgICAgICAgdHlwZSA9IElyb25NZXRhLnR5cGVzW3R5cGVdID0gSXJvbk1ldGEudHlwZXNbdHlwZV0gfHwge307XG4gICAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0eXBlW2tleV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHR5cGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgZ2V0IGxpc3QoKSB7XG4gICAgICAgIHZhciB0eXBlID0gdGhpcy50eXBlO1xuXG4gICAgICAgIGlmICh0eXBlKSB7XG4gICAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKElyb25NZXRhLnR5cGVzW3RoaXMudHlwZV0pLm1hcChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBtZXRhRGF0YXNbdGhpcy50eXBlXVtrZXldO1xuICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBieUtleTogZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgUG9seW1lci5Jcm9uTWV0YSA9IElyb25NZXRhO1xuXG4gICAgdmFyIG1ldGFEYXRhcyA9IFBvbHltZXIuSXJvbk1ldGEudHlwZXM7XG5cbiAgICBQb2x5bWVyKHtcblxuICAgICAgaXM6ICdpcm9uLW1ldGEnLFxuXG4gICAgICBwcm9wZXJ0aWVzOiB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0eXBlIG9mIG1ldGEtZGF0YS4gIEFsbCBtZXRhLWRhdGEgb2YgdGhlIHNhbWUgdHlwZSBpcyBzdG9yZWRcbiAgICAgICAgICogdG9nZXRoZXIuXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0eXBlOiB7XG4gICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgIHZhbHVlOiAnZGVmYXVsdCcsXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBrZXkgdXNlZCB0byBzdG9yZSBgdmFsdWVgIHVuZGVyIHRoZSBgdHlwZWAgbmFtZXNwYWNlLlxuICAgICAgICAgKiBAdHlwZSB7P3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIGtleToge1xuICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG1ldGEtZGF0YSB0byBzdG9yZSBvciByZXRyaWV2ZS5cbiAgICAgICAgICogQHR5cGUgeyp9XG4gICAgICAgICAqL1xuICAgICAgICB2YWx1ZToge1xuICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICBub3RpZnk6IHRydWUsXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHRydWUsIGB2YWx1ZWAgaXMgc2V0IHRvIHRoZSBpcm9uLW1ldGEgaW5zdGFuY2UgaXRzZWxmLlxuICAgICAgICAgKi9cbiAgICAgICAgIHNlbGY6IHtcbiAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgIG9ic2VydmVyOiAnX3NlbGZDaGFuZ2VkJ1xuICAgICAgICB9LFxuXG4gICAgICAgIF9fbWV0YToge1xuICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgICAgY29tcHV0ZWQ6ICdfX2NvbXB1dGVNZXRhKHR5cGUsIGtleSwgdmFsdWUpJ1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBob3N0QXR0cmlidXRlczoge1xuICAgICAgICBoaWRkZW46IHRydWVcbiAgICAgIH0sXG5cbiAgICAgIF9fY29tcHV0ZU1ldGE6IGZ1bmN0aW9uKHR5cGUsIGtleSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIG1ldGEgPSBuZXcgUG9seW1lci5Jcm9uTWV0YSh7XG4gICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICBrZXk6IGtleVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbWV0YS52YWx1ZSkge1xuICAgICAgICAgIG1ldGEudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnZhbHVlICE9PSBtZXRhLnZhbHVlKSB7XG4gICAgICAgICAgdGhpcy52YWx1ZSA9IG1ldGEudmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWV0YTtcbiAgICAgIH0sXG5cbiAgICAgIGdldCBsaXN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX21ldGEgJiYgdGhpcy5fX21ldGEubGlzdDtcbiAgICAgIH0sXG5cbiAgICAgIF9zZWxmQ2hhbmdlZDogZnVuY3Rpb24oc2VsZikge1xuICAgICAgICBpZiAoc2VsZikge1xuICAgICAgICAgIHRoaXMudmFsdWUgPSB0aGlzO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFJldHJpZXZlcyBtZXRhIGRhdGEgdmFsdWUgYnkga2V5LlxuICAgICAgICpcbiAgICAgICAqIEBtZXRob2QgYnlLZXlcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgbWV0YS1kYXRhIHRvIGJlIHJldHVybmVkLlxuICAgICAgICogQHJldHVybiB7Kn1cbiAgICAgICAqL1xuICAgICAgYnlLZXk6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICByZXR1cm4gbmV3IFBvbHltZXIuSXJvbk1ldGEoe1xuICAgICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAgICBrZXk6IGtleVxuICAgICAgICB9KS52YWx1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSkoKTtcbjwvc2NyaXB0PlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9pcm9uLW1ldGEvaXJvbi1tZXRhLmh0bWwiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi91dGlscy9ib290Lmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi91dGlscy9zZXR0aW5ncy5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vdXRpbHMvbWl4aW4uaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3V0aWxzL2Nhc2UtbWFwLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi91dGlscy9zdHlsZS1nYXRoZXIuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3V0aWxzL3Jlc29sdmUtdXJsLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi9lbGVtZW50cy9kb20tbW9kdWxlLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCJwcm9wZXJ0eS1lZmZlY3RzLmh0bWxcIj5cblxuPHNjcmlwdD5cbihmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8qKlxuICAgKiBFbGVtZW50IGNsYXNzIG1peGluIHRoYXQgcHJvdmlkZXMgdGhlIGNvcmUgQVBJIGZvciBQb2x5bWVyJ3MgbWV0YS1wcm9ncmFtbWluZ1xuICAgKiBmZWF0dXJlcyBpbmNsdWRpbmcgdGVtcGxhdGUgc3RhbXBpbmcsIGRhdGEtYmluZGluZywgYXR0cmlidXRlIGRlc2VyaWFsaXphdGlvbixcbiAgICogYW5kIHByb3BlcnR5IGNoYW5nZSBvYnNlcnZhdGlvbi5cbiAgICpcbiAgICogU3ViY2xhc3NlcnMgbWF5IHByb3ZpZGUgdGhlIGZvbGxvd2luZyBzdGF0aWMgZ2V0dGVycyB0byByZXR1cm4gbWV0YWRhdGFcbiAgICogdXNlZCB0byBjb25maWd1cmUgUG9seW1lcidzIGZlYXR1cmVzIGZvciB0aGUgY2xhc3M6XG4gICAqXG4gICAqIC0gYHN0YXRpYyBnZXQgaXMoKWA6IFdoZW4gdGhlIHRlbXBsYXRlIGlzIHByb3ZpZGVkIHZpYSBhIGBkb20tbW9kdWxlYCxcbiAgICogICB1c2VycyBzaG91bGQgcmV0dXJuIHRoZSBgZG9tLW1vZHVsZWAgaWQgZnJvbSBhIHN0YXRpYyBgaXNgIGdldHRlci4gIElmXG4gICAqICAgbm8gdGVtcGxhdGUgaXMgbmVlZGVkIG9yIHRoZSB0ZW1wbGF0ZSBpcyBwcm92aWRlZCBkaXJlY3RseSB2aWEgdGhlXG4gICAqICAgYHRlbXBsYXRlYCBnZXR0ZXIsIHRoZXJlIGlzIG5vIG5lZWQgdG8gZGVmaW5lIGBpc2AgZm9yIHRoZSBlbGVtZW50LlxuICAgKlxuICAgKiAtIGBzdGF0aWMgZ2V0IHRlbXBsYXRlKClgOiBVc2VycyBtYXkgcHJvdmlkZSB0aGUgdGVtcGxhdGUgZGlyZWN0bHkgKGFzXG4gICAqICAgb3Bwb3NlZCB0byB2aWEgYGRvbS1tb2R1bGVgKSBieSBpbXBsZW1lbnRpbmcgYSBzdGF0aWMgYHRlbXBsYXRlYCBnZXR0ZXIuXG4gICAqICAgVGhlIGdldHRlciBtYXkgcmV0dXJuIGFuIGBIVE1MVGVtcGxhdGVFbGVtZW50YCBvciBhIHN0cmluZywgd2hpY2ggd2lsbFxuICAgKiAgIGF1dG9tYXRpY2FsbHkgYmUgcGFyc2VkIGludG8gYSB0ZW1wbGF0ZS5cbiAgICpcbiAgICogLSBgc3RhdGljIGdldCBwcm9wZXJ0aWVzKClgOiBTaG91bGQgcmV0dXJuIGFuIG9iamVjdCBkZXNjcmliaW5nXG4gICAqICAgcHJvcGVydHktcmVsYXRlZCBtZXRhZGF0YSB1c2VkIGJ5IFBvbHltZXIgZmVhdHVyZXMgKGtleTogcHJvcGVydHkgbmFtZVxuICAgKiAgIHZhbHVlOiBvYmplY3QgY29udGFpbmluZyBwcm9wZXJ0eSBtZXRhZGF0YSkuIFZhbGlkIGtleXMgaW4gcGVyLXByb3BlcnR5XG4gICAqICAgbWV0YWRhdGEgaW5jbHVkZTpcbiAgICogICAtIGB0eXBlYCAoU3RyaW5nfE51bWJlcnxPYmplY3R8QXJyYXl8Li4uKTogVXNlZCBieVxuICAgKiAgICAgYGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFja2AgdG8gZGV0ZXJtaW5lIGhvdyBzdHJpbmctYmFzZWQgYXR0cmlidXRlc1xuICAgKiAgICAgYXJlIGRlc2VyaWFsaXplZCB0byBKYXZhU2NyaXB0IHByb3BlcnR5IHZhbHVlcy5cbiAgICogICAtIGBub3RpZnlgIChib29sZWFuKTogQ2F1c2VzIGEgY2hhbmdlIGluIHRoZSBwcm9wZXJ0eSB0byBmaXJlIGFcbiAgICogICAgIG5vbi1idWJibGluZyBldmVudCBjYWxsZWQgYDxwcm9wZXJ0eT4tY2hhbmdlZGAuIEVsZW1lbnRzIHRoYXQgaGF2ZVxuICAgKiAgICAgZW5hYmxlZCB0d28td2F5IGJpbmRpbmcgdG8gdGhlIHByb3BlcnR5IHVzZSB0aGlzIGV2ZW50IHRvIG9ic2VydmUgY2hhbmdlcy5cbiAgICogICAtIGByZWFkT25seWAgKGJvb2xlYW4pOiBDcmVhdGVzIGEgZ2V0dGVyIGZvciB0aGUgcHJvcGVydHksIGJ1dCBubyBzZXR0ZXIuXG4gICAqICAgICBUbyBzZXQgYSByZWFkLW9ubHkgcHJvcGVydHksIHVzZSB0aGUgcHJpdmF0ZSBzZXR0ZXIgbWV0aG9kXG4gICAqICAgICBgX3NldFByb3BlcnR5KHByb3BlcnR5LCB2YWx1ZSlgLlxuICAgKiAgIC0gYG9ic2VydmVyYCAoc3RyaW5nKTogT2JzZXJ2ZXIgbWV0aG9kIG5hbWUgdGhhdCB3aWxsIGJlIGNhbGxlZCB3aGVuXG4gICAqICAgICB0aGUgcHJvcGVydHkgY2hhbmdlcy4gVGhlIGFyZ3VtZW50cyBvZiB0aGUgbWV0aG9kIGFyZVxuICAgKiAgICAgYCh2YWx1ZSwgcHJldmlvdXNWYWx1ZSlgLlxuICAgKiAgIC0gYGNvbXB1dGVkYCAoc3RyaW5nKTogU3RyaW5nIGRlc2NyaWJpbmcgbWV0aG9kIGFuZCBkZXBlbmRlbnQgcHJvcGVydGllc1xuICAgKiAgICAgZm9yIGNvbXB1dGluZyB0aGUgdmFsdWUgb2YgdGhpcyBwcm9wZXJ0eSAoZS5nLiBgJ2NvbXB1dGVGb28oYmFyLCB6b3QpJ2ApLlxuICAgKiAgICAgQ29tcHV0ZWQgcHJvcGVydGllcyBhcmUgcmVhZC1vbmx5IGJ5IGRlZmF1bHQgYW5kIGNhbiBvbmx5IGJlIGNoYW5nZWRcbiAgICogICAgIHZpYSB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBjb21wdXRpbmcgbWV0aG9kLlxuICAgKlxuICAgKiAtIGBzdGF0aWMgZ2V0IG9ic2VydmVycygpYDogQXJyYXkgb2Ygc3RyaW5ncyBkZXNjcmliaW5nIG11bHRpLXByb3BlcnR5XG4gICAqICAgb2JzZXJ2ZXIgbWV0aG9kcyBhbmQgdGhlaXIgZGVwZW5kZW50IHByb3BlcnRpZXMgKGUuZy5cbiAgICogICBgJ29ic2VydmVBQkMoYSwgYiwgYyknYCkuXG4gICAqXG4gICAqIFRoZSBiYXNlIGNsYXNzIHByb3ZpZGVzIGRlZmF1bHQgaW1wbGVtZW50YXRpb25zIGZvciB0aGUgZm9sbG93aW5nIHN0YW5kYXJkXG4gICAqIGN1c3RvbSBlbGVtZW50IGxpZmVjeWNsZSBjYWxsYmFja3M7IHVzZXJzIG1heSBvdmVycmlkZSB0aGVzZSwgYnV0IHNob3VsZFxuICAgKiBjYWxsIHRoZSBzdXBlciBtZXRob2QgdG8gZW5zdXJlXG4gICAqIC0gYGNvbnN0cnVjdG9yYDogUnVuIHdoZW4gdGhlIGVsZW1lbnQgaXMgY3JlYXRlZCBvciB1cGdyYWRlZFxuICAgKiAtIGBjb25uZWN0ZWRDYWxsYmFja2A6IFJ1biBlYWNoIHRpbWUgdGhlIGVsZW1lbnQgaXMgY29ubmVjdGVkIHRvIHRoZVxuICAgKiAgIGRvY3VtZW50XG4gICAqIC0gYGRpc2Nvbm5lY3RlZENhbGxiYWNrYDogUnVuIGVhY2ggdGltZSB0aGUgZWxlbWVudCBpcyBkaXNjb25uZWN0ZWQgZnJvbVxuICAgKiAgIHRoZSBkb2N1bWVudFxuICAgKiAtIGBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2tgOiBSdW4gZWFjaCB0aW1lIGFuIGF0dHJpYnV0ZSBpblxuICAgKiAgIGBvYnNlcnZlZEF0dHJpYnV0ZXNgIGlzIHNldCBvciByZW1vdmVkIChub3RlOiB0aGlzIGVsZW1lbnQncyBkZWZhdWx0XG4gICAqICAgYG9ic2VydmVkQXR0cmlidXRlc2AgaW1wbGVtZW50YXRpb24gd2lsbCBhdXRvbWF0aWNhbGx5IHJldHVybiBhbiBhcnJheVxuICAgKiAgIG9mIGRhc2gtY2FzZWQgYXR0cmlidXRlcyBiYXNlZCBvbiBgcHJvcGVydGllc2ApXG4gICAqXG4gICAqIEBtaXhpbkZ1bmN0aW9uXG4gICAqIEBwb2x5bWVyXG4gICAqIEBhcHBsaWVzTWl4aW4gUG9seW1lci5Qcm9wZXJ0eUVmZmVjdHNcbiAgICogQG1lbWJlcm9mIFBvbHltZXJcbiAgICogQHByb3BlcnR5IHJvb3RQYXRoIHtzdHJpbmd9IFNldCB0byB0aGUgdmFsdWUgb2YgYFBvbHltZXIucm9vdFBhdGhgLFxuICAgKiAgIHdoaWNoIGRlZmF1bHRzIHRvIHRoZSBtYWluIGRvY3VtZW50IHBhdGhcbiAgICogQHByb3BlcnR5IGltcG9ydFBhdGgge3N0cmluZ30gU2V0IHRvIHRoZSB2YWx1ZSBvZiB0aGUgY2xhc3MncyBzdGF0aWNcbiAgICogICBgaW1wb3J0UGF0aGAgcHJvcGVydHksIHdoaWNoIGRlZmF1bHRzIHRvIHRoZSBwYXRoIG9mIHRoaXMgZWxlbWVudCdzXG4gICAqICAgYGRvbS1tb2R1bGVgICh3aGVuIGBpc2AgaXMgdXNlZCksIGJ1dCBjYW4gYmUgb3ZlcnJpZGRlbiBmb3Igb3RoZXJcbiAgICogICBpbXBvcnQgc3RyYXRlZ2llcy5cbiAgICogQHN1bW1hcnkgRWxlbWVudCBjbGFzcyBtaXhpbiB0aGF0IHByb3ZpZGVzIHRoZSBjb3JlIEFQSSBmb3IgUG9seW1lcidzXG4gICAqIG1ldGEtcHJvZ3JhbW1pbmcgZmVhdHVyZXMuXG4gICAqL1xuICBQb2x5bWVyLkVsZW1lbnRNaXhpbiA9IFBvbHltZXIuZGVkdXBpbmdNaXhpbihiYXNlID0+IHtcblxuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBleHRlbmRzIHtiYXNlfVxuICAgICAqIEBpbXBsZW1lbnRzIHtQb2x5bWVyX1Byb3BlcnR5RWZmZWN0c31cbiAgICAgKi9cbiAgICBjb25zdCBwb2x5bWVyRWxlbWVudEJhc2UgPSBQb2x5bWVyLlByb3BlcnR5RWZmZWN0cyhiYXNlKTtcblxuICAgIGxldCBjYXNlTWFwID0gUG9seW1lci5DYXNlTWFwO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYHByb3BlcnRpZXNgIG9iamVjdCBzcGVjaWZpY2FsbHkgb24gYGtsYXNzYC4gVXNlIGZvcjpcbiAgICAgKiAoMSkgc3VwZXIgY2hhaW4gbWl4ZXMgdG9ndGhlciB0byBtYWtlIGBwcm9wZXJ0aWVzRm9yQ2xhc3NgIHdoaWNoIGlzXG4gICAgICogdGhlbiB1c2VkIHRvIG1ha2UgYG9ic2VydmVkQXR0cmlidXRlc2AuXG4gICAgICogKDIpIHByb3BlcnRpZXMgZWZmZWN0cyBhbmQgb2JzZXJ2ZXJzIGFyZSBjcmVhdGVkIGZyb20gaXQgYXQgYGZpbmFsaXplYCB0aW1lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0ga2xhc3MgRWxlbWVudCBjbGFzc1xuICAgICAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0IGNvbnRhaW5pbmcgb3duIHByb3BlcnRpZXMgZm9yIHRoaXMgY2xhc3NcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG93blByb3BlcnRpZXNGb3JDbGFzcyhrbGFzcykge1xuICAgICAgaWYgKCFrbGFzcy5oYXNPd25Qcm9wZXJ0eShcbiAgICAgICAgSlNDb21waWxlcl9yZW5hbWVQcm9wZXJ0eSgnX19vd25Qcm9wZXJ0aWVzJywga2xhc3MpKSkge1xuICAgICAgICBrbGFzcy5fX293blByb3BlcnRpZXMgPVxuICAgICAgICAgIGtsYXNzLmhhc093blByb3BlcnR5KEpTQ29tcGlsZXJfcmVuYW1lUHJvcGVydHkoJ3Byb3BlcnRpZXMnLCBrbGFzcykpID9cbiAgICAgICAgICAvKiogQHR5cGUgUG9seW1lckVsZW1lbnRDb25zdHJ1Y3RvciAqLyAoa2xhc3MpLnByb3BlcnRpZXMgOiB7fTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBrbGFzcy5fX293blByb3BlcnRpZXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYG9ic2VydmVyc2AgYXJyYXkgc3BlY2lmaWNhbGx5IG9uIGBrbGFzc2AuIFVzZSBmb3JcbiAgICAgKiBzZXR0aW5nIHVwIG9ic2VydmVycy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGtsYXNzIEVsZW1lbnQgY2xhc3NcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gQXJyYXkgY29udGFpbmluZyBvd24gb2JzZXJ2ZXJzIGZvciB0aGlzIGNsYXNzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvd25PYnNlcnZlcnNGb3JDbGFzcyhrbGFzcykge1xuICAgICAgaWYgKCFrbGFzcy5oYXNPd25Qcm9wZXJ0eShcbiAgICAgICAgSlNDb21waWxlcl9yZW5hbWVQcm9wZXJ0eSgnX19vd25PYnNlcnZlcnMnLCBrbGFzcykpKSB7XG4gICAgICAgIGtsYXNzLl9fb3duT2JzZXJ2ZXJzID1cbiAgICAgICAgICBrbGFzcy5oYXNPd25Qcm9wZXJ0eShKU0NvbXBpbGVyX3JlbmFtZVByb3BlcnR5KCdvYnNlcnZlcnMnLCBrbGFzcykpID9cbiAgICAgICAgICAvKiogQHR5cGUgUG9seW1lckVsZW1lbnRDb25zdHJ1Y3RvciAqLyAoa2xhc3MpLm9ic2VydmVycyA6IFtdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGtsYXNzLl9fb3duT2JzZXJ2ZXJzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1peGVzIGBwcm9wc2AgaW50byBgZmxhdHRlbmVkUHJvcHNgIGJ1dCB1cGdyYWRlcyBzaG9ydGhhbmQgdHlwZVxuICAgICAqIHN5bnRheCB0byB7IHR5cGU6IFR5cGV9LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGZsYXR0ZW5lZFByb3BzIEJhZyB0byBjb2xsZWN0IGZsYXR0ZW5lZCBwcm9wZXJ0aWVzIGludG9cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgQmFnIG9mIHByb3BlcnRpZXMgdG8gYWRkIHRvIGBmbGF0dGVuZWRQcm9wc2BcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBpbnB1dCBgZmxhdHRlbmVkUHJvcHNgIGJhZ1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmxhdHRlblByb3BlcnRpZXMoZmxhdHRlbmVkUHJvcHMsIHByb3BzKSB7XG4gICAgICBmb3IgKGxldCBwIGluIHByb3BzKSB7XG4gICAgICAgIGxldCBvID0gcHJvcHNbcF07XG4gICAgICAgIGlmICh0eXBlb2YgbyA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgbyA9IHsgdHlwZTogbyB9O1xuICAgICAgICB9XG4gICAgICAgIGZsYXR0ZW5lZFByb3BzW3BdID0gbztcbiAgICAgIH1cbiAgICAgIHJldHVybiBmbGF0dGVuZWRQcm9wcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgZmxhdHRlbmVkIGxpc3Qgb2YgcHJvcGVydGllcyBtaXhlZCB0b2dldGhlciBmcm9tIHRoZSBjaGFpbiBvZiBhbGxcbiAgICAgKiBjb25zdHJ1Y3RvcidzIGBjb25maWcucHJvcGVydGllc2AuIFRoaXMgbGlzdCBpcyB1c2VkIHRvIGNyZWF0ZVxuICAgICAqICgxKSBvYnNlcnZlZEF0dHJpYnV0ZXMsXG4gICAgICogKDIpIGNsYXNzIHByb3BlcnR5IGRlZmF1bHQgdmFsdWVzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BvbHltZXJFbGVtZW50Q29uc3RydWN0b3J9IGtsYXNzIEVsZW1lbnQgY2xhc3NcbiAgICAgKiBAcmV0dXJuIHtQb2x5bWVyRWxlbWVudFByb3BlcnRpZXN9IEZsYXR0ZW5lZCBwcm9wZXJ0aWVzIGZvciB0aGlzIGNsYXNzXG4gICAgICogQHN1cHByZXNzIHttaXNzaW5nUHJvcGVydGllc30gY2xhc3MucHJvdG90eXBlIGlzIG5vdCBhIHByb3BlcnR5IGZvciBzb21lIHJlYXNvbj9cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHByb3BlcnRpZXNGb3JDbGFzcyhrbGFzcykge1xuICAgICAgaWYgKCFrbGFzcy5oYXNPd25Qcm9wZXJ0eShcbiAgICAgICAgSlNDb21waWxlcl9yZW5hbWVQcm9wZXJ0eSgnX19jbGFzc1Byb3BlcnRpZXMnLCBrbGFzcykpKSB7XG4gICAgICAgIGtsYXNzLl9fY2xhc3NQcm9wZXJ0aWVzID1cbiAgICAgICAgZmxhdHRlblByb3BlcnRpZXMoe30sIG93blByb3BlcnRpZXNGb3JDbGFzcyhrbGFzcykpO1xuICAgICAgICBsZXQgc3VwZXJDdG9yID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGtsYXNzLnByb3RvdHlwZSkuY29uc3RydWN0b3I7XG4gICAgICAgIGlmIChzdXBlckN0b3IucHJvdG90eXBlIGluc3RhbmNlb2YgUG9seW1lckVsZW1lbnQpIHtcbiAgICAgICAgICBrbGFzcy5fX2NsYXNzUHJvcGVydGllcyA9IE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAgICBPYmplY3QuY3JlYXRlKHByb3BlcnRpZXNGb3JDbGFzcygvKiogQHR5cGUgUG9seW1lckVsZW1lbnRDb25zdHJ1Y3RvciAqLyhzdXBlckN0b3IpKSksXG4gICAgICAgICAgICBrbGFzcy5fX2NsYXNzUHJvcGVydGllcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBrbGFzcy5fX2NsYXNzUHJvcGVydGllcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBwcm9wZXJ0aWVzIHdpdGggZGVmYXVsdCB2YWx1ZXMuXG4gICAgICogVGhpcyBsaXN0IGlzIGNyZWF0ZWQgYXMgYW4gb3B0aW1pemF0aW9uIHNpbmNlIGl0IGlzIGEgc3Vic2V0IG9mXG4gICAgICogdGhlIGxpc3QgcmV0dXJuZWQgZnJvbSBgcHJvcGVydGllc0ZvckNsYXNzYC5cbiAgICAgKiBUaGlzIGxpc3QgaXMgdXNlZCBpbiBgX2luaXRpYWxpemVQcm9wZXJ0aWVzYCB0byBzZXQgcHJvcGVydHkgZGVmYXVsdHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BvbHltZXJFbGVtZW50Q29uc3RydWN0b3J9IGtsYXNzIEVsZW1lbnQgY2xhc3NcbiAgICAgKiBAcmV0dXJuIHtQb2x5bWVyRWxlbWVudFByb3BlcnRpZXN9IEZsYXR0ZW5lZCBwcm9wZXJ0aWVzIGZvciB0aGlzIGNsYXNzXG4gICAgICogICB0aGF0IGhhdmUgZGVmYXVsdCB2YWx1ZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHByb3BlcnR5RGVmYXVsdHNGb3JDbGFzcyhrbGFzcykge1xuICAgICAgaWYgKCFrbGFzcy5oYXNPd25Qcm9wZXJ0eShcbiAgICAgICAgSlNDb21waWxlcl9yZW5hbWVQcm9wZXJ0eSgnX19jbGFzc1Byb3BlcnR5RGVmYXVsdHMnLCBrbGFzcykpKSB7XG4gICAgICAgIGtsYXNzLl9fY2xhc3NQcm9wZXJ0eURlZmF1bHRzID0gbnVsbDtcbiAgICAgICAgbGV0IHByb3BzID0gcHJvcGVydGllc0ZvckNsYXNzKGtsYXNzKTtcbiAgICAgICAgZm9yIChsZXQgcCBpbiBwcm9wcykge1xuICAgICAgICAgIGxldCBpbmZvID0gcHJvcHNbcF07XG4gICAgICAgICAgaWYgKCd2YWx1ZScgaW4gaW5mbykge1xuICAgICAgICAgICAga2xhc3MuX19jbGFzc1Byb3BlcnR5RGVmYXVsdHMgPSBrbGFzcy5fX2NsYXNzUHJvcGVydHlEZWZhdWx0cyB8fCB7fTtcbiAgICAgICAgICAgIGtsYXNzLl9fY2xhc3NQcm9wZXJ0eURlZmF1bHRzW3BdID0gaW5mbztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBrbGFzcy5fX2NsYXNzUHJvcGVydHlEZWZhdWx0cztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgYSBga2xhc3NgIGhhcyBmaW5hbGl6ZWQuIENhbGxlZCBpbiBgRWxlbWVudENsYXNzLmZpbmFsaXplKClgXG4gICAgICogQHBhcmFtIHtQb2x5bWVyRWxlbWVudENvbnN0cnVjdG9yfSBrbGFzcyBFbGVtZW50IGNsYXNzXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBhbGwgbWV0YXByb2dyYW1taW5nIGZvciB0aGlzIGNsYXNzIGhhcyBiZWVuXG4gICAgICogICBjb21wbGV0ZWRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhhc0NsYXNzRmluYWxpemVkKGtsYXNzKSB7XG4gICAgICByZXR1cm4ga2xhc3MuaGFzT3duUHJvcGVydHkoSlNDb21waWxlcl9yZW5hbWVQcm9wZXJ0eSgnX19maW5hbGl6ZWQnLCBrbGFzcykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGxlZCBieSBgRWxlbWVudENsYXNzLmZpbmFsaXplKClgLiBFbnN1cmVzIHRoaXMgYGtsYXNzYCBhbmRcbiAgICAgKiAqYWxsIHN1cGVyY2xhc3NlcyogYXJlIGZpbmFsaXplZCBieSB0cmF2ZXJzaW5nIHRoZSBwcm90b3R5cGUgY2hhaW5cbiAgICAgKiBhbmQgY2FsbGluZyBga2xhc3MuZmluYWxpemUoKWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BvbHltZXJFbGVtZW50Q29uc3RydWN0b3J9IGtsYXNzIEVsZW1lbnQgY2xhc3NcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbmFsaXplQ2xhc3NBbmRTdXBlcihrbGFzcykge1xuICAgICAgbGV0IHByb3RvID0gLyoqIEB0eXBlIFBvbHltZXJFbGVtZW50Q29uc3RydWN0b3IgKi8gKGtsYXNzKS5wcm90b3R5cGU7XG4gICAgICBsZXQgc3VwZXJDdG9yID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvKS5jb25zdHJ1Y3RvcjtcbiAgICAgIGlmIChzdXBlckN0b3IucHJvdG90eXBlIGluc3RhbmNlb2YgUG9seW1lckVsZW1lbnQpIHtcbiAgICAgICAgc3VwZXJDdG9yLmZpbmFsaXplKCk7XG4gICAgICB9XG4gICAgICBmaW5hbGl6ZUNsYXNzKGtsYXNzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb25maWd1cmVzIGEgYGtsYXNzYCBiYXNlZCBvbiBhIHN0YWljIGBrbGFzcy5jb25maWdgIG9iamVjdCBhbmRcbiAgICAgKiBhIGB0ZW1wbGF0ZWAuIFRoaXMgaW5jbHVkZXMgY3JlYXRpbmcgYWNjZXNzb3JzIGFuZCBlZmZlY3RzXG4gICAgICogZm9yIHByb3BlcnRpZXMgaW4gYGNvbmZpZ2AgYW5kIHRoZSBgdGVtcGxhdGVgIGFzIHdlbGwgYXMgcHJlcGFyaW5nIHRoZVxuICAgICAqIGB0ZW1wbGF0ZWAgZm9yIHN0YW1waW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQb2x5bWVyRWxlbWVudENvbnN0cnVjdG9yfSBrbGFzcyBFbGVtZW50IGNsYXNzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5hbGl6ZUNsYXNzKGtsYXNzKSB7XG4gICAgICBrbGFzcy5fX2ZpbmFsaXplZCA9IHRydWU7XG4gICAgICBsZXQgcHJvdG8gPSAvKiogQHR5cGUgUG9seW1lckVsZW1lbnRDb25zdHJ1Y3RvciAqLyAoa2xhc3MpLnByb3RvdHlwZTtcbiAgICAgIGlmIChrbGFzcy5oYXNPd25Qcm9wZXJ0eShcbiAgICAgICAgSlNDb21waWxlcl9yZW5hbWVQcm9wZXJ0eSgnaXMnLCBrbGFzcykpICYmIGtsYXNzLmlzKSB7XG4gICAgICAgIFBvbHltZXIudGVsZW1ldHJ5LnJlZ2lzdGVyKHByb3RvKTtcbiAgICAgIH1cbiAgICAgIGxldCBwcm9wcyA9IG93blByb3BlcnRpZXNGb3JDbGFzcyhrbGFzcyk7XG4gICAgICBpZiAocHJvcHMpIHtcbiAgICAgICAgZmluYWxpemVQcm9wZXJ0aWVzKHByb3RvLCBwcm9wcyk7XG4gICAgICB9XG4gICAgICBsZXQgb2JzZXJ2ZXJzID0gb3duT2JzZXJ2ZXJzRm9yQ2xhc3Moa2xhc3MpO1xuICAgICAgaWYgKG9ic2VydmVycykge1xuICAgICAgICBmaW5hbGl6ZU9ic2VydmVycyhwcm90bywgb2JzZXJ2ZXJzLCBwcm9wcyk7XG4gICAgICB9XG4gICAgICAvLyBub3RlOiBjcmVhdGUgXCJ3b3JraW5nXCIgdGVtcGxhdGUgdGhhdCBpcyBmaW5hbGl6ZWQgYXQgaW5zdGFuY2UgdGltZVxuICAgICAgbGV0IHRlbXBsYXRlID0gLyoqIEB0eXBlIFBvbHltZXJFbGVtZW50Q29uc3RydWN0b3IgKi8gKGtsYXNzKS50ZW1wbGF0ZTtcbiAgICAgIGlmICh0ZW1wbGF0ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHRlbXBsYXRlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGxldCB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKTtcbiAgICAgICAgICB0LmlubmVySFRNTCA9IHRlbXBsYXRlO1xuICAgICAgICAgIHRlbXBsYXRlID0gdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ZW1wbGF0ZSA9IHRlbXBsYXRlLmNsb25lTm9kZSh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBwcm90by5fdGVtcGxhdGUgPSB0ZW1wbGF0ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb25maWd1cmVzIGEgYHByb3RvYCBiYXNlZCBvbiBhIGBwcm9wZXJ0aWVzYCBvYmplY3QuXG4gICAgICogTGV2ZXJhZ2VzIGBQcm9wZXJ0eUVmZmVjdHNgIHRvIGNyZWF0ZSBwcm9wZXJ0eSBhY2Nlc3NvcnMgYW5kIGVmZmVjdHNcbiAgICAgKiBzdXBwb3J0aW5nLCBvYnNlcnZlcnMsIHJlZmxlY3RpbmcgdG8gYXR0cmlidXRlcywgY2hhbmdlIG5vdGlmaWNhdGlvbixcbiAgICAgKiBjb21wdXRlZCBwcm9wZXJ0aWVzLCBhbmQgcmVhZCBvbmx5IHByb3BlcnRpZXMuXG4gICAgICogQHBhcmFtIHtQb2x5bWVyRWxlbWVudH0gcHJvdG8gRWxlbWVudCBjbGFzcyBwcm90b3R5cGUgdG8gYWRkIGFjY2Vzc29yc1xuICAgICAqICAgIGFuZCBlZmZlY3RzIHRvXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3BlcnRpZXMgRmxhdHRlbmVkIGJhZyBvZiBwcm9wZXJ0eSBkZXNjcmlwdG9ycyBmb3JcbiAgICAgKiAgICB0aGlzIGNsYXNzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5hbGl6ZVByb3BlcnRpZXMocHJvdG8sIHByb3BlcnRpZXMpIHtcbiAgICAgIGZvciAobGV0IHAgaW4gcHJvcGVydGllcykge1xuICAgICAgICBjcmVhdGVQcm9wZXJ0eUZyb21Db25maWcocHJvdG8sIHAsIHByb3BlcnRpZXNbcF0sIHByb3BlcnRpZXMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbmZpZ3VyZXMgYSBgcHJvdG9gIGJhc2VkIG9uIGEgYG9ic2VydmVyc2AgYXJyYXkuXG4gICAgICogTGV2ZXJhZ2VzIGBQcm9wZXJ0eUVmZmVjdHNgIHRvIGNyZWF0ZSBvYnNlcnZlcnMuXG4gICAgICogQHBhcmFtIHtQb2x5bWVyRWxlbWVudH0gcHJvdG8gRWxlbWVudCBjbGFzcyBwcm90b3R5cGUgdG8gYWRkIGFjY2Vzc29yc1xuICAgICAqICAgYW5kIGVmZmVjdHMgdG9cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JzZXJ2ZXJzIEZsYXR0ZW5lZCBhcnJheSBvZiBvYnNlcnZlciBkZXNjcmlwdG9ycyBmb3JcbiAgICAgKiAgIHRoaXMgY2xhc3NcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZHluYW1pY0ZucyBPYmplY3QgY29udGFpbmluZyBrZXlzIGZvciBhbnkgcHJvcGVydGllc1xuICAgICAqICAgdGhhdCBhcmUgZnVuY3Rpb25zIGFuZCBzaG91bGQgdHJpZ2dlciB0aGUgZWZmZWN0IHdoZW4gdGhlIGZ1bmN0aW9uXG4gICAgICogICByZWZlcmVuY2UgaXMgY2hhbmdlZFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmluYWxpemVPYnNlcnZlcnMocHJvdG8sIG9ic2VydmVycywgZHluYW1pY0Zucykge1xuICAgICAgZm9yIChsZXQgaT0wOyBpIDwgb2JzZXJ2ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHByb3RvLl9jcmVhdGVNZXRob2RPYnNlcnZlcihvYnNlcnZlcnNbaV0sIGR5bmFtaWNGbnMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgZWZmZWN0cyBmb3IgYSBwcm9wZXJ0eS5cbiAgICAgKlxuICAgICAqIE5vdGUsIG9uY2UgYSBwcm9wZXJ0eSBoYXMgYmVlbiBzZXQgdG9cbiAgICAgKiBgcmVhZE9ubHlgLCBgY29tcHV0ZWRgLCBgcmVmbGVjdFRvQXR0cmlidXRlYCwgb3IgYG5vdGlmeWBcbiAgICAgKiB0aGVzZSB2YWx1ZXMgbWF5IG5vdCBiZSBjaGFuZ2VkLiBGb3IgZXhhbXBsZSwgYSBzdWJjbGFzcyBjYW5ub3RcbiAgICAgKiBhbHRlciB0aGVzZSBzZXR0aW5ncy4gSG93ZXZlciwgYWRkaXRpb25hbCBgb2JzZXJ2ZXJzYCBtYXkgYmUgYWRkZWRcbiAgICAgKiBieSBzdWJjbGFzc2VzLlxuICAgICAqXG4gICAgICogVGhlIGluZm8gb2JqZWN0IHNob3VsZCBtYXkgY29udGFpbiBwcm9wZXJ0eSBtZXRhZGF0YSBhcyBmb2xsb3dzOlxuICAgICAqXG4gICAgICogKiBgdHlwZWA6IHtmdW5jdGlvbn0gdHlwZSB0byB3aGljaCBhbiBhdHRyaWJ1dGUgbWF0Y2hpbmcgdGhlIHByb3BlcnR5XG4gICAgICogaXMgZGVzZXJpYWxpemVkLiBOb3RlIHRoZSBwcm9wZXJ0eSBpcyBjYW1lbC1jYXNlZCBmcm9tIGEgZGFzaC1jYXNlZFxuICAgICAqIGF0dHJpYnV0ZS4gRm9yIGV4YW1wbGUsICdmb28tYmFyJyBhdHRyaWJ1dGUgaXMgZGVyc2lhbGl6ZWQgdG8gYVxuICAgICAqIHByb3BlcnR5IG5hbWVkICdmb29CYXInLlxuICAgICAqXG4gICAgICogKiBgcmVhZE9ubHlgOiB7Ym9vbGVhbn0gY3JlYXRlcyBhIHJlYWRPbmx5IHByb3BlcnR5IGFuZFxuICAgICAqIG1ha2VzIGEgcHJpdmF0ZSBzZXR0ZXIgZm9yIHRoZSBwcml2YXRlIG9mIHRoZSBmb3JtICdfc2V0Rm9vJyBmb3IgYVxuICAgICAqIHByb3BlcnR5ICdmb28nLFxuICAgICAqXG4gICAgICogKiBgY29tcHV0ZWRgOiB7c3RyaW5nfSBjcmVhdGVzIGEgY29tcHV0ZWQgcHJvcGVydHkuIEEgY29tcHV0ZWQgcHJvcGVydHlcbiAgICAgKiBhbHNvIGF1dG9tYXRpY2FsbHkgaXMgc2V0IHRvIGByZWFkT25seTogdHJ1ZWAuIFRoZSB2YWx1ZSBpcyBjYWxjdWxhdGVkXG4gICAgICogYnkgcnVubmluZyBhIG1ldGhvZCBhbmQgYXJndW1lbnRzIHBhcnNlZCBmcm9tIHRoZSBnaXZlbiBzdHJpbmcuIEZvclxuICAgICAqIGV4YW1wbGUgJ2NvbXB1dGUoZm9vKScgd2lsbCBjb21wdXRlIGEgZ2l2ZW4gcHJvcGVydHkgd2hlbiB0aGVcbiAgICAgKiAnZm9vJyBwcm9wZXJ0eSBjaGFuZ2VzIGJ5IGV4ZWN1dGluZyB0aGUgJ2NvbXB1dGUnIG1ldGhvZC4gVGhpcyBtZXRob2RcbiAgICAgKiBtdXN0IHJldHVybiB0aGUgY29tcHV0ZWQgdmFsdWUuXG4gICAgICpcbiAgICAgKiAqIGByZWZsZWN0VG9BdHRyaXV0ZWA6IHtib29sZWFufSBJZiB0cnVlLCB0aGUgcHJvcGVydHkgdmFsdWUgaXMgcmVmbGVjdGVkXG4gICAgICogdG8gYW4gYXR0cmlidXRlIG9mIHRoZSBzYW1lIG5hbWUuIE5vdGUsIHRoZSBhdHRyaWJ1dGUgaXMgZGFzaC1jYXNlZFxuICAgICAqIHNvIGEgcHJvcGVydHkgbmFtZWQgJ2Zvb0JhcicgaXMgcmVmbGVjdGVkIGFzICdmb28tYmFyJy5cbiAgICAgKlxuICAgICAqICogYG5vdGlmeWA6IHtib29sZWFufSBzZW5kcyBhIG5vbi1idWJibGluZyBub3RpZmljYXRpb24gZXZlbnQgd2hlblxuICAgICAqIHRoZSBwcm9wZXJ0eSBjaGFuZ2VzLiBGb3IgZXhhbXBsZSwgYSBwcm9wZXJ0eSBuYW1lZCAnZm9vJyBzZW5kcyBhblxuICAgICAqIGV2ZW50IG5hbWVkICdmb28tY2hhbmdlZCcgd2l0aCBgZXZlbnQuZGV0YWlsYCBzZXQgdG8gdGhlIHZhbHVlIG9mXG4gICAgICogdGhlIHByb3BlcnR5LlxuICAgICAqXG4gICAgICogKiBvYnNlcnZlcjoge3N0cmluZ30gbmFtZSBvZiBhIG1ldGhvZCB0aGF0IHJ1bnMgd2hlbiB0aGUgcHJvcGVydHlcbiAgICAgKiBjaGFuZ2VzLiBUaGUgYXJndW1lbnRzIG9mIHRoZSBtZXRob2QgYXJlICh2YWx1ZSwgcHJldmlvdXNWYWx1ZSkuXG4gICAgICpcbiAgICAgKiBOb3RlOiBVc2VycyBtYXkgd2FudCBjb250cm9sIG92ZXIgbW9kaWZ5aW5nIHByb3BlcnR5XG4gICAgICogZWZmZWN0cyB2aWEgc3ViY2xhc3NpbmcuIEZvciBleGFtcGxlLCBhIHVzZXIgbWlnaHQgd2FudCB0byBtYWtlIGFcbiAgICAgKiByZWZsZWN0VG9BdHRyaWJ1dGUgcHJvcGVydHkgbm90IGRvIHNvIGluIGEgc3ViY2xhc3MuIFdlJ3ZlIGNob3NlbiB0b1xuICAgICAqIGRpc2FibGUgdGhpcyBiZWNhdXNlIGl0IGxlYWRzIHRvIGFkZGl0aW9uYWwgY29tcGxpY2F0aW9uLlxuICAgICAqIEZvciBleGFtcGxlLCBhIHJlYWRPbmx5IGVmZmVjdCBnZW5lcmF0ZXMgYSBzcGVjaWFsIHNldHRlci4gSWYgYSBzdWJjbGFzc1xuICAgICAqIGRpc2FibGVzIHRoZSBlZmZlY3QsIHRoZSBzZXR0ZXIgd291bGQgZmFpbCB1bmV4cGVjdGVkbHkuXG4gICAgICogQmFzZWQgb24gZmVlZGJhY2ssIHdlIG1heSB3YW50IHRvIHRyeSB0byBtYWtlIGVmZmVjdHMgbW9yZSBtYWxsZWFibGVcbiAgICAgKiBhbmQvb3IgcHJvdmlkZSBhbiBhZHZhbmNlZCBhcGkgZm9yIG1hbmlwdWxhdGluZyB0aGVtLlxuICAgICAqIEFsc28gY29uc2lkZXIgYWRkaW5nIHdhcm5pbmdzIHdoZW4gYW4gZWZmZWN0IGNhbm5vdCBiZSBjaGFuZ2VkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQb2x5bWVyRWxlbWVudH0gcHJvdG8gRWxlbWVudCBjbGFzcyBwcm90b3R5cGUgdG8gYWRkIGFjY2Vzc29yc1xuICAgICAqICAgYW5kIGVmZmVjdHMgdG9cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBOYW1lIG9mIHRoZSBwcm9wZXJ0eS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5mbyBJbmZvIG9iamVjdCBmcm9tIHdoaWNoIHRvIGNyZWF0ZSBwcm9wZXJ0eSBlZmZlY3RzLlxuICAgICAqIFN1cHBvcnRlZCBrZXlzOlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhbGxQcm9wcyBGbGF0dGVuZWQgbWFwIG9mIGFsbCBwcm9wZXJ0aWVzIGRlZmluZWQgaW4gdGhpc1xuICAgICAqICAgZWxlbWVudCAoaW5jbHVkaW5nIGluaGVyaXRlZCBwcm9wZXJ0aWVzKVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlUHJvcGVydHlGcm9tQ29uZmlnKHByb3RvLCBuYW1lLCBpbmZvLCBhbGxQcm9wcykge1xuICAgICAgLy8gY29tcHV0ZWQgZm9yY2VzIHJlYWRPbmx5Li4uXG4gICAgICBpZiAoaW5mby5jb21wdXRlZCkge1xuICAgICAgICBpbmZvLnJlYWRPbmx5ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIC8vIE5vdGUsIHNpbmNlIGFsbCBjb21wdXRlZCBwcm9wZXJ0aWVzIGFyZSByZWFkT25seSwgdGhpcyBwcmV2ZW50c1xuICAgICAgLy8gYWRkaW5nIGFkZGl0aW9uYWwgY29tcHV0ZWQgcHJvcGVydHkgZWZmZWN0cyAod2hpY2ggbGVhZHMgdG8gYSBjb25mdXNpbmdcbiAgICAgIC8vIHNldHVwIHdoZXJlIG11bHRpcGxlIHRyaWdnZXJzIGZvciBzZXR0aW5nIGEgcHJvcGVydHkpXG4gICAgICAvLyBXaGlsZSB3ZSBkbyBoYXZlIGBoYXNDb21wdXRlZEVmZmVjdGAgdGhpcyBpcyBzZXQgb24gdGhlIHByb3BlcnR5J3NcbiAgICAgIC8vIGRlcGVuZGVuY2llcyByYXRoZXIgdGhhbiBpdHNlbGYuXG4gICAgICBpZiAoaW5mby5jb21wdXRlZCAgJiYgIXByb3RvLl9oYXNSZWFkT25seUVmZmVjdChuYW1lKSkge1xuICAgICAgICBwcm90by5fY3JlYXRlQ29tcHV0ZWRQcm9wZXJ0eShuYW1lLCBpbmZvLmNvbXB1dGVkLCBhbGxQcm9wcyk7XG4gICAgICB9XG4gICAgICBpZiAoaW5mby5yZWFkT25seSAmJiAhcHJvdG8uX2hhc1JlYWRPbmx5RWZmZWN0KG5hbWUpKSB7XG4gICAgICAgIHByb3RvLl9jcmVhdGVSZWFkT25seVByb3BlcnR5KG5hbWUsICFpbmZvLmNvbXB1dGVkKTtcbiAgICAgIH1cbiAgICAgIGlmIChpbmZvLnJlZmxlY3RUb0F0dHJpYnV0ZSAmJiAhcHJvdG8uX2hhc1JlZmxlY3RFZmZlY3QobmFtZSkpIHtcbiAgICAgICAgcHJvdG8uX2NyZWF0ZVJlZmxlY3RlZFByb3BlcnR5KG5hbWUpO1xuICAgICAgfVxuICAgICAgaWYgKGluZm8ubm90aWZ5ICYmICFwcm90by5faGFzTm90aWZ5RWZmZWN0KG5hbWUpKSB7XG4gICAgICAgIHByb3RvLl9jcmVhdGVOb3RpZnlpbmdQcm9wZXJ0eShuYW1lKTtcbiAgICAgIH1cbiAgICAgIC8vIGFsd2F5cyBhZGQgb2JzZXJ2ZXJcbiAgICAgIGlmIChpbmZvLm9ic2VydmVyKSB7XG4gICAgICAgIHByb3RvLl9jcmVhdGVQcm9wZXJ0eU9ic2VydmVyKG5hbWUsIGluZm8ub2JzZXJ2ZXIsIGFsbFByb3BzW2luZm8ub2JzZXJ2ZXJdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb25maWd1cmVzIGFuIGVsZW1lbnQgYHByb3RvYCB0byBmdW5jdGlvbiB3aXRoIGEgZ2l2ZW4gYHRlbXBsYXRlYC5cbiAgICAgKiBUaGUgZWxlbWVudCBuYW1lIGBpc2AgYW5kIGV4dGVuZHMgYGV4dGAgbXVzdCBiZSBzcGVjaWZpZWQgZm9yIFNoYWR5Q1NTXG4gICAgICogc3R5bGUgc2NvcGluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UG9seW1lckVsZW1lbnR9IHByb3RvIEVsZW1lbnQgY2xhc3MgcHJvdG90eXBlIHRvIGFkZCBhY2Nlc3NvcnNcbiAgICAgKiAgIGFuZCBlZmZlY3RzIHRvXG4gICAgICogQHBhcmFtIHshSFRNTFRlbXBsYXRlRWxlbWVudH0gdGVtcGxhdGUgVGVtcGxhdGUgdG8gcHJvY2VzcyBhbmQgYmluZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlVVJJIFVSTCBhZ2FpbnN0IHdoaWNoIHRvIHJlc29sdmUgdXJscyBpblxuICAgICAqICAgc3R5bGUgZWxlbWVudCBjc3NUZXh0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlzIFRhZyBuYW1lIChvciB0eXBlIGV4dGVuc2lvbiBuYW1lKSBmb3IgdGhpcyBlbGVtZW50XG4gICAgICogQHBhcmFtIHtzdHJpbmc9fSBleHQgRm9yIHR5cGUgZXh0ZW5zaW9ucywgdGhlIHRhZyBuYW1lIHRoYXQgd2FzIGV4dGVuZGVkXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5hbGl6ZVRlbXBsYXRlKHByb3RvLCB0ZW1wbGF0ZSwgYmFzZVVSSSwgaXMsIGV4dCkge1xuICAgICAgLy8gc3VwcG9ydCBgaW5jbHVkZT1cIm1vZHVsZS1uYW1lXCJgXG4gICAgICBsZXQgY3NzVGV4dCA9XG4gICAgICAgIFBvbHltZXIuU3R5bGVHYXRoZXIuY3NzRnJvbVRlbXBsYXRlKHRlbXBsYXRlLCBiYXNlVVJJKSArXG4gICAgICAgIFBvbHltZXIuU3R5bGVHYXRoZXIuY3NzRnJvbU1vZHVsZUltcG9ydHMoaXMpO1xuICAgICAgaWYgKGNzc1RleHQpIHtcbiAgICAgICAgbGV0IHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICAgICAgc3R5bGUudGV4dENvbnRlbnQgPSBjc3NUZXh0O1xuICAgICAgICB0ZW1wbGF0ZS5jb250ZW50Lmluc2VydEJlZm9yZShzdHlsZSwgdGVtcGxhdGUuY29udGVudC5maXJzdENoaWxkKTtcbiAgICAgIH1cbiAgICAgIGlmICh3aW5kb3cuU2hhZHlDU1MpIHtcbiAgICAgICAgd2luZG93LlNoYWR5Q1NTLnByZXBhcmVUZW1wbGF0ZSh0ZW1wbGF0ZSwgaXMsIGV4dCk7XG4gICAgICB9XG4gICAgICBwcm90by5fYmluZFRlbXBsYXRlKHRlbXBsYXRlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcG9seW1lclxuICAgICAqIEBtaXhpbkNsYXNzXG4gICAgICogQHVucmVzdHJpY3RlZFxuICAgICAqIEBpbXBsZW1lbnRzIHtQb2x5bWVyX0VsZW1lbnRNaXhpbn1cbiAgICAgKi9cbiAgICBjbGFzcyBQb2x5bWVyRWxlbWVudCBleHRlbmRzIHBvbHltZXJFbGVtZW50QmFzZSB7XG5cbiAgICAgIC8qKlxuICAgICAgICogU3RhbmRhcmQgQ3VzdG9tIEVsZW1lbnRzIFYxIEFQSS4gIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIHJldHVybnNcbiAgICAgICAqIGEgbGlzdCBvZiBkYXNoLWNhc2VkIGF0dHJpYnV0ZXMgYmFzZWQgb24gYSBmbGF0dGVuaW5nIG9mIGFsbCBwcm9wZXJ0aWVzXG4gICAgICAgKiBkZWNsYXJlZCBpbiBgc3RhdGljIGdldCBwcm9wZXJ0aWVzKClgIGZvciB0aGlzIGVsZW1lbnQgYW5kIGFueVxuICAgICAgICogc3VwZXJjbGFzc2VzLlxuICAgICAgICpcbiAgICAgICAqIEByZXR1cm4ge0FycmF5fSBPYnNlcnZlZCBhdHRyaWJ1dGUgbGlzdFxuICAgICAgICovXG4gICAgICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhc093blByb3BlcnR5KEpTQ29tcGlsZXJfcmVuYW1lUHJvcGVydHkoJ19fb2JzZXJ2ZWRBdHRyaWJ1dGVzJywgdGhpcykpKSB7XG4gICAgICAgICAgbGV0IGxpc3QgPSBbXTtcbiAgICAgICAgICBsZXQgcHJvcGVydGllcyA9IHByb3BlcnRpZXNGb3JDbGFzcyh0aGlzKTtcbiAgICAgICAgICBmb3IgKGxldCBwcm9wIGluIHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIGxpc3QucHVzaChQb2x5bWVyLkNhc2VNYXAuY2FtZWxUb0Rhc2hDYXNlKHByb3ApKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fX29ic2VydmVkQXR0cmlidXRlcyA9IGxpc3Q7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX19vYnNlcnZlZEF0dHJpYnV0ZXM7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ2FsbGVkIGF1dG9tYXRpY2FsbHkgd2hlbiB0aGUgZmlyc3QgZWxlbWVudCBpbnN0YW5jZSBpcyBjcmVhdGVkIHRvXG4gICAgICAgKiBlbnN1cmUgdGhhdCBjbGFzcyBmaW5hbGl6YXRpb24gd29yayBoYXMgYmVlbiBjb21wbGV0ZWQuXG4gICAgICAgKiBNYXkgYmUgY2FsbGVkIGJ5IHVzZXJzIHRvIGVhZ2VybHkgcGVyZm9ybSBjbGFzcyBmaW5hbGl6YXRpb24gd29ya1xuICAgICAgICogcHJpb3IgdG8gdGhlIGNyZWF0aW9uIG9mIHRoZSBmaXJzdCBlbGVtZW50IGluc3RhbmNlLlxuICAgICAgICpcbiAgICAgICAqIENsYXNzIGZpbmFsaXphdGlvbiB3b3JrIGdlbmVyYWxseSBpbmNsdWRlcyBtZXRhLXByb2dyYW1taW5nIHN1Y2ggYXNcbiAgICAgICAqIGNyZWF0aW5nIHByb3BlcnR5IGFjY2Vzc29ycyBhbmQgYW55IHByb3BlcnR5IGVmZmVjdCBtZXRhZGF0YSBuZWVkZWQgZm9yXG4gICAgICAgKiB0aGUgZmVhdHVyZXMgdXNlZC5cbiAgICAgICAqXG4gICAgICAgKiBAcHVibGljXG4gICAgICAgKi9cbiAgICAgIHN0YXRpYyBmaW5hbGl6ZSgpIHtcbiAgICAgICAgaWYgKCFoYXNDbGFzc0ZpbmFsaXplZCh0aGlzKSkge1xuICAgICAgICAgIGZpbmFsaXplQ2xhc3NBbmRTdXBlcih0aGlzKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJldHVybnMgdGhlIHRlbXBsYXRlIHRoYXQgd2lsbCBiZSBzdGFtcGVkIGludG8gdGhpcyBlbGVtZW50J3Mgc2hhZG93IHJvb3QuXG4gICAgICAgKlxuICAgICAgICogSWYgYSBgc3RhdGljIGdldCBpcygpYCBnZXR0ZXIgaXMgZGVmaW5lZCwgdGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb25cbiAgICAgICAqIHdpbGwgcmV0dXJuIHRoZSBmaXJzdCBgPHRlbXBsYXRlPmAgaW4gYSBgZG9tLW1vZHVsZWAgd2hvc2UgYGlkYFxuICAgICAgICogbWF0Y2hlcyB0aGlzIGVsZW1lbnQncyBgaXNgLlxuICAgICAgICpcbiAgICAgICAqIFVzZXJzIG1heSBvdmVycmlkZSB0aGlzIGdldHRlciB0byByZXR1cm4gYW4gYXJiaXRyYXJ5IHRlbXBsYXRlXG4gICAgICAgKiAoaW4gd2hpY2ggY2FzZSB0aGUgYGlzYCBnZXR0ZXIgaXMgdW5uZWNlc3NhcnkpLiBUaGUgdGVtcGxhdGUgcmV0dXJuZWRcbiAgICAgICAqIG1heSBiZSBlaXRoZXIgYW4gYEhUTUxUZW1wbGF0ZUVsZW1lbnRgIG9yIGEgc3RyaW5nIHRoYXQgd2lsbCBiZVxuICAgICAgICogYXV0b21hdGljYWxseSBwYXJzZWQgaW50byBhIHRlbXBsYXRlLlxuICAgICAgICpcbiAgICAgICAqIE5vdGUgdGhhdCB3aGVuIHN1YmNsYXNzaW5nLCBpZiB0aGUgc3VwZXIgY2xhc3Mgb3ZlcnJvZGUgdGhlIGRlZmF1bHRcbiAgICAgICAqIGltcGxlbWVudGF0aW9uIGFuZCB0aGUgc3ViY2xhc3Mgd291bGQgbGlrZSB0byBwcm92aWRlIGFuIGFsdGVybmF0ZVxuICAgICAgICogdGVtcGxhdGUgdmlhIGEgYGRvbS1tb2R1bGVgLCBpdCBzaG91bGQgb3ZlcnJpZGUgdGhpcyBnZXR0ZXIgYW5kXG4gICAgICAgKiByZXR1cm4gYFBvbHltZXIuRG9tTW9kdWxlLmltcG9ydCh0aGlzLmlzLCAndGVtcGxhdGUnKWAuXG4gICAgICAgKlxuICAgICAgICogSWYgYSBzdWJjbGFzcyB3b3VsZCBsaWtlIHRvIG1vZGlmeSB0aGUgc3VwZXIgY2xhc3MgdGVtcGxhdGUsIGl0IHNob3VsZFxuICAgICAgICogY2xvbmUgaXQgcmF0aGVyIHRoYW4gbW9kaWZ5IGl0IGluIHBsYWNlLiAgSWYgdGhlIGdldHRlciBkb2VzIGV4cGVuc2l2ZVxuICAgICAgICogd29yayBzdWNoIGFzIGNsb25pbmcvbW9kaWZ5aW5nIGEgdGVtcGxhdGUsIGl0IHNob3VsZCBtZW1vaXplIHRoZVxuICAgICAgICogdGVtcGxhdGUgZm9yIG1heGltdW0gcGVyZm9ybWFuY2U6XG4gICAgICAgKlxuICAgICAgICogICBsZXQgbWVtb2l6ZWRUZW1wbGF0ZTtcbiAgICAgICAqICAgY2xhc3MgTXlTdWJDbGFzcyBleHRlbmRzIE15U3VwZXJDbGFzcyB7XG4gICAgICAgKiAgICAgc3RhdGljIGdldCB0ZW1wbGF0ZSgpIHtcbiAgICAgICAqICAgICAgIGlmICghbWVtb2l6ZWRUZW1wbGF0ZSkge1xuICAgICAgICogICAgICAgICBtZW1vaXplZFRlbXBsYXRlID0gc3VwZXIudGVtcGxhdGUuY2xvbmVOb2RlKHRydWUpO1xuICAgICAgICogICAgICAgICBsZXQgc3ViQ29udGVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICogICAgICAgICBzdWJDb250ZW50LnRleHRDb250ZW50ID0gJ1RoaXMgY2FtZSBmcm9tIE15U3ViQ2xhc3MnO1xuICAgICAgICogICAgICAgICBtZW1vaXplZFRlbXBsYXRlLmNvbnRlbnQuYXBwZW5kQ2hpbGQoc3ViQ29udGVudCk7XG4gICAgICAgKiAgICAgICB9XG4gICAgICAgKiAgICAgICByZXR1cm4gbWVtb2l6ZWRUZW1wbGF0ZTtcbiAgICAgICAqICAgICB9XG4gICAgICAgKiAgIH1cbiAgICAgICAqXG4gICAgICAgKiBAcmV0dXJuIHtIVE1MVGVtcGxhdGVFbGVtZW50fHN0cmluZ30gVGVtcGxhdGUgdG8gYmUgc3RhbXBlZFxuICAgICAgICovXG4gICAgICBzdGF0aWMgZ2V0IHRlbXBsYXRlKCkge1xuICAgICAgICBpZiAoIXRoaXMuaGFzT3duUHJvcGVydHkoSlNDb21waWxlcl9yZW5hbWVQcm9wZXJ0eSgnX3RlbXBsYXRlJywgdGhpcykpKSB7XG4gICAgICAgICAgdGhpcy5fdGVtcGxhdGUgPSBQb2x5bWVyLkRvbU1vZHVsZSAmJiBQb2x5bWVyLkRvbU1vZHVsZS5pbXBvcnQoXG4gICAgICAgICAgICAvKiogQHR5cGUgUG9seW1lckVsZW1lbnRDb25zdHJ1Y3RvciovICh0aGlzKS5pcywgJ3RlbXBsYXRlJykgfHxcbiAgICAgICAgICAgIC8vIG5vdGU6IGltcGxlbWVudGVkIHNvIGEgc3ViY2xhc3MgY2FuIHJldHJpZXZlIHRoZSBzdXBlclxuICAgICAgICAgICAgLy8gdGVtcGxhdGU7IGNhbGwgdGhlIHN1cGVyIGltcGwgdGhpcyB3YXkgc28gdGhhdCBgdGhpc2AgcG9pbnRzXG4gICAgICAgICAgICAvLyB0byB0aGUgc3VwZXJjbGFzcy5cbiAgICAgICAgICAgIE9iamVjdC5nZXRQcm90b3R5cGVPZigvKiogQHR5cGUgUG9seW1lckVsZW1lbnRDb25zdHJ1Y3RvciovICh0aGlzKS5wcm90b3R5cGUpLmNvbnN0cnVjdG9yLnRlbXBsYXRlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl90ZW1wbGF0ZTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBQYXRoIG1hdGNoaW5nIHRoZSB1cmwgZnJvbSB3aGljaCB0aGUgZWxlbWVudCB3YXMgaW1wb3J0ZWQuXG4gICAgICAgKiBUaGlzIHBhdGggaXMgdXNlZCB0byByZXNvbHZlIHVybCdzIGluIHRlbXBsYXRlIHN0eWxlIGNzc1RleHQuXG4gICAgICAgKiBUaGUgYGltcG9ydFBhdGhgIHByb3BlcnR5IGlzIGFsc28gc2V0IG9uIGVsZW1lbnQgaW5zdGFuY2VzIGFuZCBjYW4gYmVcbiAgICAgICAqIHVzZWQgdG8gY3JlYXRlIGJpbmRpbmdzIHJlbGF0aXZlIHRvIHRoZSBpbXBvcnQgcGF0aC5cbiAgICAgICAqIERlZmF1bHRzIHRvIHRoZSBwYXRoIG1hdGNoaW5nIHRoZSB1cmwgY29udGFpbmluZyBhIGBkb20tbW9kdWxlYCBlbGVtZW50XG4gICAgICAgKiBtYXRjaGluZyB0aGlzIGVsZW1lbnQncyBzdGF0aWMgYGlzYCBwcm9wZXJ0eS5cbiAgICAgICAqIE5vdGUsIHRoaXMgcGF0aCBzaG91bGQgY29udGFpbiBhIHRyYWlsaW5nIGAvYC5cbiAgICAgICAqXG4gICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBpbXBvcnQgcGF0aCBmb3IgdGhpcyBlbGVtZW50IGNsYXNzXG4gICAgICAgKi9cbiAgICAgIHN0YXRpYyBnZXQgaW1wb3J0UGF0aCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhc093blByb3BlcnR5KEpTQ29tcGlsZXJfcmVuYW1lUHJvcGVydHkoJ19pbXBvcnRQYXRoJywgdGhpcykpKSB7XG4gICAgICAgICAgICBjb25zdCBtb2R1bGUgPSBQb2x5bWVyLkRvbU1vZHVsZSAmJiBQb2x5bWVyLkRvbU1vZHVsZS5pbXBvcnQoLyoqIEB0eXBlIFBvbHltZXJFbGVtZW50Q29uc3RydWN0b3IgKi8gKHRoaXMpLmlzKTtcbiAgICAgICAgICAgIHRoaXMuX2ltcG9ydFBhdGggPSBtb2R1bGUgPyBtb2R1bGUuYXNzZXRwYXRoIDogJycgfHxcbiAgICAgICAgICAgIE9iamVjdC5nZXRQcm90b3R5cGVPZigvKiogQHR5cGUgUG9seW1lckVsZW1lbnRDb25zdHJ1Y3RvciovICh0aGlzKS5wcm90b3R5cGUpLmNvbnN0cnVjdG9yLmltcG9ydFBhdGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2ltcG9ydFBhdGg7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogT3ZlcnJpZGVzIHRoZSBkZWZhdWx0IGBQb2x5bWVyLlByb3BlcnR5QWNjZXNzb3JzYCB0byBlbnN1cmUgY2xhc3NcbiAgICAgICAqIG1ldGFwcm9ncmFtbWluZyByZWxhdGVkIHRvIHByb3BlcnR5IGFjY2Vzc29ycyBhbmQgZWZmZWN0cyBoYXNcbiAgICAgICAqIGNvbXBsZXRlZCAoY2FsbHMgYGZpbmFsaXplYCkuXG4gICAgICAgKlxuICAgICAgICogSXQgYWxzbyBpbml0aWFsaXplcyBhbnkgcHJvcGVydHkgZGVmYXVsdHMgcHJvdmlkZWQgdmlhIGB2YWx1ZWAgaW5cbiAgICAgICAqIGBwcm9wZXJ0aWVzYCBtZXRhZGF0YS5cbiAgICAgICAqXG4gICAgICAgKiBAb3ZlcnJpZGVcbiAgICAgICAqIEBzdXBwcmVzcyB7aW52YWxpZENhc3RzfVxuICAgICAgICovXG4gICAgICBfaW5pdGlhbGl6ZVByb3BlcnRpZXMoKSB7XG4gICAgICAgIFBvbHltZXIudGVsZW1ldHJ5Lmluc3RhbmNlQ291bnQrKztcbiAgICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5maW5hbGl6ZSgpO1xuICAgICAgICBjb25zdCBpbXBvcnRQYXRoID0gdGhpcy5jb25zdHJ1Y3Rvci5pbXBvcnRQYXRoO1xuICAgICAgICAvLyBub3RlOiBmaW5hbGl6ZSB0ZW1wbGF0ZSB3aGVuIHdlIGhhdmUgYWNjZXNzIHRvIGBsb2NhbE5hbWVgIHRvXG4gICAgICAgIC8vIGF2b2lkIGRlcGVuZGVuY2Ugb24gYGlzYCBmb3IgcG9seWZpbGxpbmcgc3R5bGluZy5cbiAgICAgICAgaWYgKHRoaXMuX3RlbXBsYXRlICYmICF0aGlzLl90ZW1wbGF0ZS5fX3BvbHltZXJGaW5hbGl6ZWQpIHtcbiAgICAgICAgICB0aGlzLl90ZW1wbGF0ZS5fX3BvbHltZXJGaW5hbGl6ZWQgPSB0cnVlO1xuICAgICAgICAgIGNvbnN0IGJhc2VVUkkgPVxuICAgICAgICAgICAgaW1wb3J0UGF0aCA/IFBvbHltZXIuUmVzb2x2ZVVybC5yZXNvbHZlVXJsKGltcG9ydFBhdGgpIDogJyc7XG4gICAgICAgICAgZmluYWxpemVUZW1wbGF0ZSgvKiogQHR5cGUgeyFQb2x5bWVyRWxlbWVudH0gKi8odGhpcy5fX3Byb3RvX18pLCB0aGlzLl90ZW1wbGF0ZSwgYmFzZVVSSSxcbiAgICAgICAgICAgIC8qKkB0eXBlIHshSFRNTEVsZW1lbnR9Ki8odGhpcykubG9jYWxOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlci5faW5pdGlhbGl6ZVByb3BlcnRpZXMoKTtcbiAgICAgICAgLy8gc2V0IHBhdGggZGVmYXVsdHNcbiAgICAgICAgdGhpcy5yb290UGF0aCA9IFBvbHltZXIucm9vdFBhdGg7XG4gICAgICAgIHRoaXMuaW1wb3J0UGF0aCA9IGltcG9ydFBhdGg7XG4gICAgICAgIC8vIGFwcGx5IHByb3BlcnR5IGRlZmF1bHRzLi4uXG4gICAgICAgIGxldCBwJCA9IHByb3BlcnR5RGVmYXVsdHNGb3JDbGFzcyh0aGlzLmNvbnN0cnVjdG9yKTtcbiAgICAgICAgaWYgKCFwJCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBwIGluIHAkKSB7XG4gICAgICAgICAgbGV0IGluZm8gPSBwJFtwXTtcbiAgICAgICAgICAvLyBEb24ndCBzZXQgZGVmYXVsdCB2YWx1ZSBpZiB0aGVyZSBpcyBhbHJlYWR5IGFuIG93biBwcm9wZXJ0eSwgd2hpY2hcbiAgICAgICAgICAvLyBoYXBwZW5zIHdoZW4gYSBgcHJvcGVydGllc2AgcHJvcGVydHkgd2l0aCBkZWZhdWx0IGJ1dCBubyBlZmZlY3RzIGhhZFxuICAgICAgICAgIC8vIGEgcHJvcGVydHkgc2V0IChlLmcuIGJvdW5kKSBieSBpdHMgaG9zdCBiZWZvcmUgdXBncmFkZVxuICAgICAgICAgIGlmICghdGhpcy5oYXNPd25Qcm9wZXJ0eShwKSkge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gdHlwZW9mIGluZm8udmFsdWUgPT0gJ2Z1bmN0aW9uJyA/XG4gICAgICAgICAgICAgIGluZm8udmFsdWUuY2FsbCh0aGlzKSA6XG4gICAgICAgICAgICAgIGluZm8udmFsdWU7XG4gICAgICAgICAgICAvLyBTZXQgdmlhIGBfc2V0UHJvcGVydHlgIGlmIHRoZXJlIGlzIGFuIGFjY2Vzc29yLCB0byBlbmFibGVcbiAgICAgICAgICAgIC8vIGluaXRpYWxpemluZyByZWFkT25seSBwcm9wZXJ0eSBkZWZhdWx0c1xuICAgICAgICAgICAgaWYgKHRoaXMuX2hhc0FjY2Vzc29yKHApKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3NldFBlbmRpbmdQcm9wZXJ0eShwLCB2YWx1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzW3BdID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUHJvdmlkZXMgYSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIG9mIHRoZSBzdGFuZGFyZCBDdXN0b20gRWxlbWVudHNcbiAgICAgICAqIGBjb25uZWN0ZWRDYWxsYmFja2AuXG4gICAgICAgKlxuICAgICAgICogVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gZW5hYmxlcyB0aGUgcHJvcGVydHkgZWZmZWN0cyBzeXN0ZW0gYW5kXG4gICAgICAgKiBmbHVzaGVzIGFueSBwZW5kaW5nIHByb3BlcnRpZXMsIGFuZCB1cGRhdGVzIHNoaW1tZWQgQ1NTIHByb3BlcnRpZXNcbiAgICAgICAqIHdoZW4gdXNpbmcgdGhlIFNoYWR5Q1NTIHNjb3BpbmcvY3VzdG9tIHByb3BlcnRpZXMgcG9seWZpbGwuXG4gICAgICAgKlxuICAgICAgICogQHN1cHByZXNzIHtpbnZhbGlkQ2FzdHN9XG4gICAgICAgKi9cbiAgICAgIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgICAgICBpZiAod2luZG93LlNoYWR5Q1NTICYmIHRoaXMuX3RlbXBsYXRlKSB7XG4gICAgICAgICAgd2luZG93LlNoYWR5Q1NTLnN0eWxlRWxlbWVudCgvKiogQHR5cGUgeyFIVE1MRWxlbWVudH0gKi8odGhpcykpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2VuYWJsZVByb3BlcnRpZXMoKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBQcm92aWRlcyBhIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gb2YgdGhlIHN0YW5kYXJkIEN1c3RvbSBFbGVtZW50c1xuICAgICAgICogYGRpc2Nvbm5lY3RlZENhbGxiYWNrYC5cbiAgICAgICAqL1xuICAgICAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7fVxuXG4gICAgICAvKipcbiAgICAgICAqIFN0YW1wcyB0aGUgZWxlbWVudCB0ZW1wbGF0ZS5cbiAgICAgICAqXG4gICAgICAgKiBAb3ZlcnJpZGVcbiAgICAgICAqL1xuICAgICAgcmVhZHkoKSB7XG4gICAgICAgIGlmICh0aGlzLl90ZW1wbGF0ZSkge1xuICAgICAgICAgIHRoaXMucm9vdCA9IHRoaXMuX3N0YW1wVGVtcGxhdGUodGhpcy5fdGVtcGxhdGUpO1xuICAgICAgICAgIHRoaXMuJCA9IHRoaXMucm9vdC4kO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyLnJlYWR5KCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogSW1wbGVtZW50cyBgUHJvcGVydHlFZmZlY3RzYCdzIGBfcmVhZHlDbGllbnRzYCBjYWxsLiBBdHRhY2hlc1xuICAgICAgICogZWxlbWVudCBkb20gYnkgY2FsbGluZyBgX2F0dGFjaERvbWAgd2l0aCB0aGUgZG9tIHN0YW1wZWQgZnJvbSB0aGVcbiAgICAgICAqIGVsZW1lbnQncyB0ZW1wbGF0ZSB2aWEgYF9zdGFtcFRlbXBsYXRlYC4gTm90ZSB0aGF0IHRoaXMgYWxsb3dzXG4gICAgICAgKiBjbGllbnQgZG9tIHRvIGJlIGF0dGFjaGVkIHRvIHRoZSBlbGVtZW50IHByaW9yIHRvIGFueSBvYnNlcnZlcnNcbiAgICAgICAqIHJ1bm5pbmcuXG4gICAgICAgKlxuICAgICAgICogQG92ZXJyaWRlXG4gICAgICAgKi9cbiAgICAgIF9yZWFkeUNsaWVudHMoKSB7XG4gICAgICAgIGlmICh0aGlzLl90ZW1wbGF0ZSkge1xuICAgICAgICAgIHRoaXMucm9vdCA9IHRoaXMuX2F0dGFjaERvbSh0aGlzLnJvb3QpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoZSBzdXBlci5fcmVhZHlDbGllbnRzIGhlcmUgc2V0cyB0aGUgY2xpZW50cyBpbml0aWFsaXplZCBmbGFnLlxuICAgICAgICAvLyBXZSBtdXN0IHdhaXQgdG8gZG8gdGhpcyB1bnRpbCBhZnRlciBjbGllbnQgZG9tIGlzIGNyZWF0ZWQvYXR0YWNoZWRcbiAgICAgICAgLy8gc28gdGhhdCB0aGlzIGZsYWcgY2FuIGJlIGNoZWNrZWQgdG8gcHJldmVudCBub3RpZmljYXRpb25zIGZpcmVkXG4gICAgICAgIC8vIGR1cmluZyB0aGlzIHByb2Nlc3MgZnJvbSBiZWluZyBoYW5kbGVkIGJlZm9yZSBjbGllbnRzIGFyZSByZWFkeS5cbiAgICAgICAgc3VwZXIuX3JlYWR5Q2xpZW50cygpO1xuICAgICAgfVxuXG5cbiAgICAgIC8qKlxuICAgICAgICogQXR0YWNoZXMgYW4gZWxlbWVudCdzIHN0YW1wZWQgZG9tIHRvIGl0c2VsZi4gQnkgZGVmYXVsdCxcbiAgICAgICAqIHRoaXMgbWV0aG9kIGNyZWF0ZXMgYSBgc2hhZG93Um9vdGAgYW5kIGFkZHMgdGhlIGRvbSB0byBpdC5cbiAgICAgICAqIEhvd2V2ZXIsIHRoaXMgbWV0aG9kIG1heSBiZSBvdmVycmlkZGVuIHRvIGFsbG93IGFuIGVsZW1lbnRcbiAgICAgICAqIHRvIHB1dCBpdHMgZG9tIGluIGFub3RoZXIgbG9jYXRpb24uXG4gICAgICAgKlxuICAgICAgICogQHRocm93cyB7RXJyb3J9XG4gICAgICAgKiBAc3VwcHJlc3Mge21pc3NpbmdSZXR1cm59XG4gICAgICAgKiBAcGFyYW0ge05vZGVMaXN0fSBkb20gdG8gYXR0YWNoIHRvIHRoZSBlbGVtZW50LlxuICAgICAgICogQHJldHVybiB7Tm9kZX0gbm9kZSB0byB3aGljaCB0aGUgZG9tIGhhcyBiZWVuIGF0dGFjaGVkLlxuICAgICAgICovXG4gICAgICBfYXR0YWNoRG9tKGRvbSkge1xuICAgICAgICBpZiAodGhpcy5hdHRhY2hTaGFkb3cpIHtcbiAgICAgICAgICBpZiAoZG9tKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuc2hhZG93Um9vdCkge1xuICAgICAgICAgICAgICB0aGlzLmF0dGFjaFNoYWRvdyh7bW9kZTogJ29wZW4nfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNoYWRvd1Jvb3QuYXBwZW5kQ2hpbGQoZG9tKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNoYWRvd1Jvb3Q7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU2hhZG93RE9NIG5vdCBhdmFpbGFibGUuICcgK1xuICAgICAgICAgICAgLy8gVE9ETyhzb3J2ZWxsKTogbW92ZSB0byBjb21waWxlLXRpbWUgY29uZGl0aW9uYWwgd2hlbiBzdXBwb3J0ZWRcbiAgICAgICAgICAnUG9seW1lci5FbGVtZW50IGNhbiBjcmVhdGUgZG9tIGFzIGNoaWxkcmVuIGluc3RlYWQgb2YgaW4gJyArXG4gICAgICAgICAgJ1NoYWRvd0RPTSBieSBzZXR0aW5nIGB0aGlzLnJvb3QgPSB0aGlzO1xcYCBiZWZvcmUgXFxgcmVhZHlcXGAuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBQcm92aWRlcyBhIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gb2YgdGhlIHN0YW5kYXJkIEN1c3RvbSBFbGVtZW50c1xuICAgICAgICogYGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFja2AuXG4gICAgICAgKlxuICAgICAgICogQnkgZGVmYXVsdCwgYXR0cmlidXRlcyBkZWNsYXJlZCBpbiBgcHJvcGVydGllc2AgbWV0YWRhdGEgYXJlXG4gICAgICAgKiBkZXNlcmlhbGl6ZWQgdXNpbmcgdGhlaXIgYHR5cGVgIGluZm9ybWF0aW9uIHRvIHByb3BlcnRpZXMgb2YgdGhlXG4gICAgICAgKiBzYW1lIG5hbWUuICBcIkRhc2gtY2FzZWRcIiBhdHRyaWJ1dGVzIGFyZSBkZXNlcmlhbHplZCB0byBcImNhbWVsQ2FzZVwiXG4gICAgICAgKiBwcm9wZXJ0aWVzLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE5hbWUgb2YgYXR0cmlidXRlLlxuICAgICAgICogQHBhcmFtIHs/c3RyaW5nfSBvbGQgT2xkIHZhbHVlIG9mIGF0dHJpYnV0ZS5cbiAgICAgICAqIEBwYXJhbSB7P3N0cmluZ30gdmFsdWUgQ3VycmVudCB2YWx1ZSBvZiBhdHRyaWJ1dGUuXG4gICAgICAgKiBAb3ZlcnJpZGVcbiAgICAgICAqL1xuICAgICAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIG9sZCwgdmFsdWUpIHtcbiAgICAgICAgaWYgKG9sZCAhPT0gdmFsdWUpIHtcbiAgICAgICAgICBsZXQgcHJvcGVydHkgPSBjYXNlTWFwLmRhc2hUb0NhbWVsQ2FzZShuYW1lKTtcbiAgICAgICAgICBsZXQgdHlwZSA9IHByb3BlcnRpZXNGb3JDbGFzcyh0aGlzLmNvbnN0cnVjdG9yKVtwcm9wZXJ0eV0udHlwZTtcbiAgICAgICAgICBpZiAoIXRoaXMuX2hhc1JlYWRPbmx5RWZmZWN0KHByb3BlcnR5KSkge1xuICAgICAgICAgICAgdGhpcy5fYXR0cmlidXRlVG9Qcm9wZXJ0eShuYW1lLCB2YWx1ZSwgdHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogV2hlbiB1c2luZyB0aGUgU2hhZHlDU1Mgc2NvcGluZyBhbmQgY3VzdG9tIHByb3BlcnR5IHNoaW0sIGNhdXNlcyBhbGxcbiAgICAgICAqIHNoaW1tZWQgc3R5bGVzIGluIHRoaXMgZWxlbWVudCAoYW5kIGl0cyBzdWJ0cmVlKSB0byBiZSB1cGRhdGVkXG4gICAgICAgKiBiYXNlZCBvbiBjdXJyZW50IGN1c3RvbSBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICAgKlxuICAgICAgICogVGhlIG9wdGlvbmFsIHBhcmFtZXRlciBvdmVycmlkZXMgaW5saW5lIGN1c3RvbSBwcm9wZXJ0eSBzdHlsZXMgd2l0aCBhblxuICAgICAgICogb2JqZWN0IG9mIHByb3BlcnRpZXMgd2hlcmUgdGhlIGtleXMgYXJlIENTUyBwcm9wZXJ0aWVzLCBhbmQgdGhlIHZhbHVlc1xuICAgICAgICogYXJlIHN0cmluZ3MuXG4gICAgICAgKlxuICAgICAgICogRXhhbXBsZTogYHRoaXMudXBkYXRlU3R5bGVzKHsnLS1jb2xvcic6ICdibHVlJ30pYFxuICAgICAgICpcbiAgICAgICAqIFRoZXNlIHByb3BlcnRpZXMgYXJlIHJldGFpbmVkIHVubGVzcyBhIHZhbHVlIG9mIGBudWxsYCBpcyBzZXQuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtPYmplY3Q9fSBwcm9wZXJ0aWVzIEJhZyBvZiBjdXN0b20gcHJvcGVydHkga2V5L3ZhbHVlcyB0b1xuICAgICAgICogICBhcHBseSB0byB0aGlzIGVsZW1lbnQuXG4gICAgICAgKiBAc3VwcHJlc3Mge2ludmFsaWRDYXN0c31cbiAgICAgICAqL1xuICAgICAgdXBkYXRlU3R5bGVzKHByb3BlcnRpZXMpIHtcbiAgICAgICAgaWYgKHdpbmRvdy5TaGFkeUNTUykge1xuICAgICAgICAgIHdpbmRvdy5TaGFkeUNTUy5zdHlsZVN1YnRyZWUoLyoqIEB0eXBlIHshSFRNTEVsZW1lbnR9ICovKHRoaXMpLCBwcm9wZXJ0aWVzKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJld3JpdGVzIGEgZ2l2ZW4gVVJMIHJlbGF0aXZlIHRvIGEgYmFzZSBVUkwuIFRoZSBiYXNlIFVSTCBkZWZhdWx0cyB0b1xuICAgICAgICogdGhlIG9yaWdpbmFsIGxvY2F0aW9uIG9mIHRoZSBkb2N1bWVudCBjb250YWluaW5nIHRoZSBgZG9tLW1vZHVsZWAgZm9yXG4gICAgICAgKiB0aGlzIGVsZW1lbnQuIFRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuIHRoZSBzYW1lIFVSTCBiZWZvcmUgYW5kIGFmdGVyXG4gICAgICAgKiBidW5kbGluZy5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsIFVSTCB0byByZXNvbHZlLlxuICAgICAgICogQHBhcmFtIHtzdHJpbmc9fSBiYXNlIE9wdGlvbmFsIGJhc2UgVVJMIHRvIHJlc29sdmUgYWdhaW5zdCwgZGVmYXVsdHNcbiAgICAgICAqIHRvIHRoZSBlbGVtZW50J3MgYGltcG9ydFBhdGhgXG4gICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFJld3JpdHRlbiBVUkwgcmVsYXRpdmUgdG8gYmFzZVxuICAgICAgICovXG4gICAgICByZXNvbHZlVXJsKHVybCwgYmFzZSkge1xuICAgICAgICBpZiAoIWJhc2UgJiYgdGhpcy5pbXBvcnRQYXRoKSB7XG4gICAgICAgICAgYmFzZSA9IFBvbHltZXIuUmVzb2x2ZVVybC5yZXNvbHZlVXJsKHRoaXMuaW1wb3J0UGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFBvbHltZXIuUmVzb2x2ZVVybC5yZXNvbHZlVXJsKHVybCwgYmFzZSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogT3ZlcnJpZGVzIGBQcm9wZXJ0eUFjY2Vzc29yc2AgdG8gYWRkIG1hcCBvZiBkeW5hbWljIGZ1bmN0aW9ucyBvblxuICAgICAgICogdGVtcGxhdGUgaW5mbywgZm9yIGNvbnN1bXB0aW9uIGJ5IGBQcm9wZXJ0eUVmZmVjdHNgIHRlbXBsYXRlIGJpbmRpbmdcbiAgICAgICAqIGNvZGUuIFRoaXMgbWFwIGRldGVybWluZXMgd2hpY2ggbWV0aG9kIHRlbXBsYXRlcyBzaG91bGQgaGF2ZSBhY2Nlc3NvcnNcbiAgICAgICAqIGNyZWF0ZWQgZm9yIHRoZW0uXG4gICAgICAgKlxuICAgICAgICogQG92ZXJyaWRlXG4gICAgICAgKiBAc3VwcHJlc3Mge21pc3NpbmdQcm9wZXJ0aWVzfSBJbnRlcmZhY2VzIGluIGNsb3N1cmUgZG8gbm90IGluaGVyaXQgc3RhdGljcywgYnV0IGNsYXNzZXMgZG9cbiAgICAgICAqL1xuICAgICAgc3RhdGljIF9wYXJzZVRlbXBsYXRlQ29udGVudCh0ZW1wbGF0ZSwgdGVtcGxhdGVJbmZvLCBub2RlSW5mbykge1xuICAgICAgICB0ZW1wbGF0ZUluZm8uZHluYW1pY0ZucyA9IHRlbXBsYXRlSW5mby5keW5hbWljRm5zIHx8IHByb3BlcnRpZXNGb3JDbGFzcyh0aGlzKTtcbiAgICAgICAgcmV0dXJuIHN1cGVyLl9wYXJzZVRlbXBsYXRlQ29udGVudCh0ZW1wbGF0ZSwgdGVtcGxhdGVJbmZvLCBub2RlSW5mbyk7XG4gICAgICB9XG5cbiAgICB9XG5cbiAgICByZXR1cm4gUG9seW1lckVsZW1lbnQ7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBQcm92aWRlcyBiYXNpYyB0cmFja2luZyBvZiBlbGVtZW50IGRlZmluaXRpb25zIChyZWdpc3RyYXRpb25zKSBhbmRcbiAgICogaW5zdGFuY2UgY291bnRzLlxuICAgKlxuICAgKiBAbmFtZXNwYWNlXG4gICAqIEBzdW1tYXJ5IFByb3ZpZGVzIGJhc2ljIHRyYWNraW5nIG9mIGVsZW1lbnQgZGVmaW5pdGlvbnMgKHJlZ2lzdHJhdGlvbnMpIGFuZFxuICAgKiBpbnN0YW5jZSBjb3VudHMuXG4gICAqL1xuICBQb2x5bWVyLnRlbGVtZXRyeSA9IHtcbiAgICAvKipcbiAgICAgKiBUb3RhbCBudW1iZXIgb2YgUG9seW1lciBlbGVtZW50IGluc3RhbmNlcyBjcmVhdGVkLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgaW5zdGFuY2VDb3VudDogMCxcbiAgICAvKipcbiAgICAgKiBBcnJheSBvZiBQb2x5bWVyIGVsZW1lbnQgY2xhc3NlcyB0aGF0IGhhdmUgYmVlbiBmaW5hbGl6ZWQuXG4gICAgICogQHR5cGUge0FycmF5PFBvbHltZXIuRWxlbWVudD59XG4gICAgICovXG4gICAgcmVnaXN0cmF0aW9uczogW10sXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshUG9seW1lckVsZW1lbnRDb25zdHJ1Y3Rvcn0gcHJvdG90eXBlIEVsZW1lbnQgcHJvdG90eXBlIHRvIGxvZ1xuICAgICAqIEB0aGlzIHt0aGlzfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlZ0xvZzogZnVuY3Rpb24ocHJvdG90eXBlKSB7XG4gICAgICBjb25zb2xlLmxvZygnWycgKyBwcm90b3R5cGUuaXMgKyAnXTogcmVnaXN0ZXJlZCcpXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYSBjbGFzcyBwcm90b3R5cGUgZm9yIHRlbGVtZXRyeSBwdXJwb3Nlcy5cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwcm90b3R5cGUgRWxlbWVudCBwcm90b3R5cGUgdG8gcmVnaXN0ZXJcbiAgICAgKiBAdGhpcyB7dGhpc31cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgcmVnaXN0ZXI6IGZ1bmN0aW9uKHByb3RvdHlwZSkge1xuICAgICAgdGhpcy5yZWdpc3RyYXRpb25zLnB1c2gocHJvdG90eXBlKTtcbiAgICAgIFBvbHltZXIubG9nICYmIHRoaXMuX3JlZ0xvZyhwcm90b3R5cGUpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogTG9ncyBhbGwgZWxlbWVudHMgcmVnaXN0ZXJlZCB3aXRoIGFuIGBpc2AgdG8gdGhlIGNvbnNvbGUuXG4gICAgICogQHB1YmxpY1xuICAgICAqIEB0aGlzIHt0aGlzfVxuICAgICAqL1xuICAgIGR1bXBSZWdpc3RyYXRpb25zOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMucmVnaXN0cmF0aW9ucy5mb3JFYWNoKHRoaXMuX3JlZ0xvZyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBXaGVuIHVzaW5nIHRoZSBTaGFkeUNTUyBzY29waW5nIGFuZCBjdXN0b20gcHJvcGVydHkgc2hpbSwgY2F1c2VzIGFsbFxuICAgKiBzaGltbWVkIGBzdHlsZXNgICh2aWEgYGN1c3RvbS1zdHlsZWApIGluIHRoZSBkb2N1bWVudCAoYW5kIGl0cyBzdWJ0cmVlKVxuICAgKiB0byBiZSB1cGRhdGVkIGJhc2VkIG9uIGN1cnJlbnQgY3VzdG9tIHByb3BlcnR5IHZhbHVlcy5cbiAgICpcbiAgICogVGhlIG9wdGlvbmFsIHBhcmFtZXRlciBvdmVycmlkZXMgaW5saW5lIGN1c3RvbSBwcm9wZXJ0eSBzdHlsZXMgd2l0aCBhblxuICAgKiBvYmplY3Qgb2YgcHJvcGVydGllcyB3aGVyZSB0aGUga2V5cyBhcmUgQ1NTIHByb3BlcnRpZXMsIGFuZCB0aGUgdmFsdWVzXG4gICAqIGFyZSBzdHJpbmdzLlxuICAgKlxuICAgKiBFeGFtcGxlOiBgUG9seW1lci51cGRhdGVTdHlsZXMoeyctLWNvbG9yJzogJ2JsdWUnfSlgXG4gICAqXG4gICAqIFRoZXNlIHByb3BlcnRpZXMgYXJlIHJldGFpbmVkIHVubGVzcyBhIHZhbHVlIG9mIGBudWxsYCBpcyBzZXQuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0PX0gcHJvcHMgQmFnIG9mIGN1c3RvbSBwcm9wZXJ0eSBrZXkvdmFsdWVzIHRvXG4gICAqICAgYXBwbHkgdG8gdGhlIGRvY3VtZW50LlxuICAgKi9cbiAgUG9seW1lci51cGRhdGVTdHlsZXMgPSBmdW5jdGlvbihwcm9wcykge1xuICAgIGlmICh3aW5kb3cuU2hhZHlDU1MpIHtcbiAgICAgIHdpbmRvdy5TaGFkeUNTUy5zdHlsZURvY3VtZW50KHByb3BzKTtcbiAgICB9XG4gIH07XG5cbn0pKCk7XG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvbWl4aW5zL2VsZW1lbnQtbWl4aW4uaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cblxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3V0aWxzL2Jvb3QuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3V0aWxzL3Jlc29sdmUtdXJsLmh0bWxcIj5cblxuPHNjcmlwdD5cbi8qKiBAc3VwcHJlc3Mge2RlcHJlY2F0ZWR9ICovXG4oZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvKipcbiAgICogTGVnYWN5IHNldHRpbmdzLlxuICAgKiBAbmFtZXNwYWNlXG4gICAqIEBtZW1iZXJvZiBQb2x5bWVyXG4gICAqL1xuICBjb25zdCBzZXR0aW5ncyA9IFBvbHltZXIuU2V0dGluZ3MgfHwge307XG4gIHNldHRpbmdzLnVzZVNoYWRvdyA9ICEod2luZG93LlNoYWR5RE9NKTtcbiAgc2V0dGluZ3MudXNlTmF0aXZlQ1NTUHJvcGVydGllcyA9XG4gICAgQm9vbGVhbighd2luZG93LlNoYWR5Q1NTIHx8IHdpbmRvdy5TaGFkeUNTUy5uYXRpdmVDc3MpO1xuICBzZXR0aW5ncy51c2VOYXRpdmVDdXN0b21FbGVtZW50cyA9XG4gICAgISh3aW5kb3cuY3VzdG9tRWxlbWVudHMucG9seWZpbGxXcmFwRmx1c2hDYWxsYmFjayk7XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGdsb2JhbCwgbGVnYWN5IHNldHRpbmdzLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZFxuICAgKiBAbWVtYmVyb2YgUG9seW1lclxuICAgKi9cbiAgUG9seW1lci5TZXR0aW5ncyA9IHNldHRpbmdzO1xuXG4gIC8qKlxuICAgKiBHbG9iYWxseSBzZXR0YWJsZSBwcm9wZXJ0eSB0aGF0IGlzIGF1dG9tYXRpY2FsbHkgYXNzaWduZWQgdG9cbiAgICogYFBvbHltZXIuRWxlbWVudE1peGluYCBpbnN0YW5jZXMsIHVzZWZ1bCBmb3IgYmluZGluZyBpbiB0ZW1wbGF0ZXMgdG9cbiAgICogbWFrZSBVUkwncyByZWxhdGl2ZSB0byBhbiBhcHBsaWNhdGlvbidzIHJvb3QuICBEZWZhdWx0cyB0byB0aGUgbWFpblxuICAgKiBkb2N1bWVudCBVUkwsIGJ1dCBjYW4gYmUgb3ZlcnJpZGRlbiBieSB1c2Vycy4gIEl0IG1heSBiZSB1c2VmdWwgdG8gc2V0XG4gICAqIGBQb2x5bWVyLnJvb3RQYXRoYCB0byBwcm92aWRlIGEgc3RhYmxlIGFwcGxpY2F0aW9uIG1vdW50IHBhdGggd2hlblxuICAgKiB1c2luZyBjbGllbnQgc2lkZSByb3V0aW5nLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgUG9seW1lclxuICAgKi9cbiAgbGV0IHJvb3RQYXRoID0gUG9seW1lci5yb290UGF0aCB8fFxuICAgIFBvbHltZXIuUmVzb2x2ZVVybC5wYXRoRnJvbVVybChkb2N1bWVudC5iYXNlVVJJIHx8IHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcblxuICBQb2x5bWVyLnJvb3RQYXRoID0gcm9vdFBhdGg7XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGdsb2JhbCByb290UGF0aCBwcm9wZXJ0eSB1c2VkIGJ5IGBQb2x5bWVyLkVsZW1lbnRNaXhpbmAgYW5kXG4gICAqIGF2YWlsYWJsZSB2aWEgYFBvbHltZXIucm9vdFBhdGhgLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgUG9seW1lclxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBUaGUgbmV3IHJvb3QgcGF0aFxuICAgKi9cbiAgUG9seW1lci5zZXRSb290UGF0aCA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgICBQb2x5bWVyLnJvb3RQYXRoID0gcGF0aDtcbiAgfVxufSkoKTtcbjwvc2NyaXB0PlxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvdXRpbHMvc2V0dGluZ3MuaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCJyZXNvbHZlLXVybC5odG1sXCI+XG48c2NyaXB0PlxuKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgY29uc3QgTU9EVUxFX1NUWUxFX0xJTktfU0VMRUNUT1IgPSAnbGlua1tyZWw9aW1wb3J0XVt0eXBlfj1jc3NdJztcbiAgY29uc3QgSU5DTFVERV9BVFRSID0gJ2luY2x1ZGUnO1xuXG4gIGZ1bmN0aW9uIGltcG9ydE1vZHVsZShtb2R1bGVJZCkge1xuICAgIGlmICghUG9seW1lci5Eb21Nb2R1bGUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gUG9seW1lci5Eb21Nb2R1bGUuaW1wb3J0KG1vZHVsZUlkKTtcbiAgfVxuXG4gIC8qKiBAdHlwZWRlZiB7e2Fzc2V0cGF0aDogc3RyaW5nfX0gKi9cbiAgbGV0IHRlbXBsYXRlV2l0aEFzc2V0UGF0aDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuXG4gIC8qKlxuICAgKiBNb2R1bGUgd2l0aCB1dGlsaXRpZXMgZm9yIGNvbGxlY3Rpb24gQ1NTIHRleHQgZnJvbSBgPHRlbXBsYXRlcz5gLCBleHRlcm5hbFxuICAgKiBzdHlsZXNoZWV0cywgYW5kIGBkb20tbW9kdWxlYHMuXG4gICAqXG4gICAqIEBuYW1lc3BhY2VcbiAgICogQG1lbWJlcm9mIFBvbHltZXJcbiAgICogQHN1bW1hcnkgTW9kdWxlIHdpdGggdXRpbGl0aWVzIGZvciBjb2xsZWN0aW9uIENTUyB0ZXh0IGZyb20gdmFyaW91cyBzb3VyY2VzLlxuICAgKi9cbiAgY29uc3QgU3R5bGVHYXRoZXIgPSB7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIENTUyB0ZXh0IG9mIHN0eWxlcyBpbiBhIHNwYWNlLXNlcGFyYXRlZCBsaXN0IG9mIGBkb20tbW9kdWxlYHMuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgUG9seW1lci5TdHlsZUdhdGhlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtb2R1bGVJZHMgTGlzdCBvZiBkb20tbW9kdWxlIGlkJ3Mgd2l0aGluIHdoaWNoIHRvXG4gICAgICogc2VhcmNoIGZvciBjc3MuXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBDb25jYXRlbmF0ZWQgQ1NTIGNvbnRlbnQgZnJvbSBzcGVjaWZpZWQgYGRvbS1tb2R1bGVgc1xuICAgICAqIEB0aGlzIHtTdHlsZUdhdGhlcn1cbiAgICAgKi9cbiAgICBjc3NGcm9tTW9kdWxlcyhtb2R1bGVJZHMpIHtcbiAgICAgIGxldCBtb2R1bGVzID0gbW9kdWxlSWRzLnRyaW0oKS5zcGxpdCgnICcpO1xuICAgICAgbGV0IGNzc1RleHQgPSAnJztcbiAgICAgIGZvciAobGV0IGk9MDsgaSA8IG1vZHVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY3NzVGV4dCArPSB0aGlzLmNzc0Zyb21Nb2R1bGUobW9kdWxlc1tpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY3NzVGV4dDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBDU1MgdGV4dCBvZiBzdHlsZXMgaW4gYSBnaXZlbiBgZG9tLW1vZHVsZWAuICBDU1MgaW4gYSBgZG9tLW1vZHVsZWBcbiAgICAgKiBjYW4gY29tZSBlaXRoZXIgZnJvbSBgPHN0eWxlPmBzIHdpdGhpbiB0aGUgZmlyc3QgYDx0ZW1wbGF0ZT5gLCBvciBlbHNlXG4gICAgICogZnJvbSBvbmUgb3IgbW9yZSBgPGxpbmsgcmVsPVwiaW1wb3J0XCIgdHlwZT1cImNzc1wiPmAgbGlua3Mgb3V0c2lkZSB0aGVcbiAgICAgKiB0ZW1wbGF0ZS5cbiAgICAgKlxuICAgICAqIEFueSBgPHN0eWxlcz5gIHByb2Nlc3NlZCBhcmUgcmVtb3ZlZCBmcm9tIHRoZWlyIG9yaWdpbmFsIGxvY2F0aW9uLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIFBvbHltZXIuU3R5bGVHYXRoZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbW9kdWxlSWQgZG9tLW1vZHVsZSBpZCB0byBnYXRoZXIgc3R5bGVzIGZyb21cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IENvbmNhdGVuYXRlZCBDU1MgY29udGVudCBmcm9tIHNwZWNpZmllZCBgZG9tLW1vZHVsZWBcbiAgICAgKiBAdGhpcyB7U3R5bGVHYXRoZXJ9XG4gICAgICovXG4gICAgY3NzRnJvbU1vZHVsZShtb2R1bGVJZCkge1xuICAgICAgbGV0IG0gPSBpbXBvcnRNb2R1bGUobW9kdWxlSWQpO1xuICAgICAgaWYgKG0gJiYgbS5fY3NzVGV4dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCBjc3NUZXh0ID0gJyc7XG4gICAgICAgIC8vIGluY2x1ZGUgY3NzIGZyb20gdGhlIGZpcnN0IHRlbXBsYXRlIGluIHRoZSBtb2R1bGVcbiAgICAgICAgbGV0IHQgPSBtLnF1ZXJ5U2VsZWN0b3IoJ3RlbXBsYXRlJyk7XG4gICAgICAgIGlmICh0KSB7XG4gICAgICAgICAgY3NzVGV4dCArPSB0aGlzLmNzc0Zyb21UZW1wbGF0ZSh0LCAvKiogQHR5cGUge3RlbXBsYXRlV2l0aEFzc2V0UGF0aCB9Ki8obSkuYXNzZXRwYXRoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBtb2R1bGUgaW1wb3J0czogPGxpbmsgcmVsPVwiaW1wb3J0XCIgdHlwZT1cImNzc1wiPlxuICAgICAgICBjc3NUZXh0ICs9IHRoaXMuY3NzRnJvbU1vZHVsZUltcG9ydHMobW9kdWxlSWQpO1xuICAgICAgICBtLl9jc3NUZXh0ID0gY3NzVGV4dCB8fCBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKCFtKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignQ291bGQgbm90IGZpbmQgc3R5bGUgZGF0YSBpbiBtb2R1bGUgbmFtZWQnLCBtb2R1bGVJZCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbSAmJiBtLl9jc3NUZXh0IHx8ICcnO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIENTUyB0ZXh0IG9mIGA8c3R5bGVzPmAgd2l0aGluIGEgZ2l2ZW4gdGVtcGxhdGUuXG4gICAgICpcbiAgICAgKiBBbnkgYDxzdHlsZXM+YCBwcm9jZXNzZWQgYXJlIHJlbW92ZWQgZnJvbSB0aGVpciBvcmlnaW5hbCBsb2NhdGlvbi5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBQb2x5bWVyLlN0eWxlR2F0aGVyXG4gICAgICogQHBhcmFtIHtIVE1MVGVtcGxhdGVFbGVtZW50fSB0ZW1wbGF0ZSBUZW1wbGF0ZSB0byBnYXRoZXIgc3R5bGVzIGZyb21cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYmFzZVVSSSBCYXNlIFVSSSB0byByZXNvbHZlIHRoZSBVUkwgYWdhaW5zdFxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gQ29uY2F0ZW5hdGVkIENTUyBjb250ZW50IGZyb20gc3BlY2lmaWVkIHRlbXBsYXRlXG4gICAgICogQHRoaXMge1N0eWxlR2F0aGVyfVxuICAgICAqL1xuICAgIGNzc0Zyb21UZW1wbGF0ZSh0ZW1wbGF0ZSwgYmFzZVVSSSkge1xuICAgICAgbGV0IGNzc1RleHQgPSAnJztcbiAgICAgIC8vIGlmIGVsZW1lbnQgaXMgYSB0ZW1wbGF0ZSwgZ2V0IGNvbnRlbnQgZnJvbSBpdHMgLmNvbnRlbnRcbiAgICAgIGxldCBlJCA9IHRlbXBsYXRlLmNvbnRlbnQucXVlcnlTZWxlY3RvckFsbCgnc3R5bGUnKTtcbiAgICAgIGZvciAobGV0IGk9MDsgaSA8IGUkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBlID0gZSRbaV07XG4gICAgICAgIC8vIHN1cHBvcnQgc3R5bGUgc2hhcmluZyBieSBhbGxvd2luZyBzdHlsZXMgdG8gXCJpbmNsdWRlXCJcbiAgICAgICAgLy8gb3RoZXIgZG9tLW1vZHVsZXMgdGhhdCBjb250YWluIHN0eWxpbmdcbiAgICAgICAgbGV0IGluY2x1ZGUgPSBlLmdldEF0dHJpYnV0ZShJTkNMVURFX0FUVFIpO1xuICAgICAgICBpZiAoaW5jbHVkZSkge1xuICAgICAgICAgIGNzc1RleHQgKz0gdGhpcy5jc3NGcm9tTW9kdWxlcyhpbmNsdWRlKTtcbiAgICAgICAgfVxuICAgICAgICBlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZSk7XG4gICAgICAgIGNzc1RleHQgKz0gYmFzZVVSSSA/XG4gICAgICAgICAgUG9seW1lci5SZXNvbHZlVXJsLnJlc29sdmVDc3MoZS50ZXh0Q29udGVudCwgYmFzZVVSSSkgOiBlLnRleHRDb250ZW50O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNzc1RleHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgQ1NTIHRleHQgZnJvbSBzdHlsc2hlZXRzIGxvYWRlZCB2aWEgYDxsaW5rIHJlbD1cImltcG9ydFwiIHR5cGU9XCJjc3NcIj5gXG4gICAgICogbGlua3Mgd2l0aGluIHRoZSBzcGVjaWZpZWQgYGRvbS1tb2R1bGVgLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIFBvbHltZXIuU3R5bGVHYXRoZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbW9kdWxlSWQgSWQgb2YgYGRvbS1tb2R1bGVgIHRvIGdhdGhlciBDU1MgZnJvbVxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gQ29uY2F0ZW5hdGVkIENTUyBjb250ZW50IGZyb20gbGlua3MgaW4gc3BlY2lmaWVkIGBkb20tbW9kdWxlYFxuICAgICAqIEB0aGlzIHtTdHlsZUdhdGhlcn1cbiAgICAgKi9cbiAgICBjc3NGcm9tTW9kdWxlSW1wb3J0cyhtb2R1bGVJZCkge1xuICAgICAgbGV0IGNzc1RleHQgPSAnJztcbiAgICAgIGxldCBtID0gaW1wb3J0TW9kdWxlKG1vZHVsZUlkKTtcbiAgICAgIGlmICghbSkge1xuICAgICAgICByZXR1cm4gY3NzVGV4dDtcbiAgICAgIH1cbiAgICAgIGxldCBwJCA9IG0ucXVlcnlTZWxlY3RvckFsbChNT0RVTEVfU1RZTEVfTElOS19TRUxFQ1RPUik7XG4gICAgICBmb3IgKGxldCBpPTA7IGkgPCBwJC5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgcCA9IHAkW2ldO1xuICAgICAgICBpZiAocC5pbXBvcnQpIHtcbiAgICAgICAgICBsZXQgaW1wb3J0RG9jID0gcC5pbXBvcnQ7XG4gICAgICAgICAgLy8gTk9URTogcG9seWZpbGwgYWZmb3JkYW5jZS5cbiAgICAgICAgICAvLyB1bmRlciB0aGUgSFRNTEltcG9ydHMgcG9seWZpbGwsIHRoZXJlIHdpbGwgYmUgbm8gJ2JvZHknLFxuICAgICAgICAgIC8vIGJ1dCB0aGUgaW1wb3J0IHBzZXVkby1kb2MgY2FuIGJlIHVzZWQgZGlyZWN0bHkuXG4gICAgICAgICAgbGV0IGNvbnRhaW5lciA9IGltcG9ydERvYy5ib2R5ID8gaW1wb3J0RG9jLmJvZHkgOiBpbXBvcnREb2M7XG4gICAgICAgICAgY3NzVGV4dCArPVxuICAgICAgICAgICAgUG9seW1lci5SZXNvbHZlVXJsLnJlc29sdmVDc3MoY29udGFpbmVyLnRleHRDb250ZW50LFxuICAgICAgICAgICAgICBpbXBvcnREb2MuYmFzZVVSSSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBjc3NUZXh0O1xuICAgIH1cbiAgfTtcblxuICBQb2x5bWVyLlN0eWxlR2F0aGVyID0gU3R5bGVHYXRoZXI7XG59KSgpO1xuPC9zY3JpcHQ+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL3BvbHltZXIvbGliL3V0aWxzL3N0eWxlLWdhdGhlci5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuXG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vLi4vLi4vc2hhZHljc3MvYXBwbHktc2hpbS5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vbWl4aW5zL2VsZW1lbnQtbWl4aW4uaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL21peGlucy9nZXN0dXJlLWV2ZW50LWxpc3RlbmVycy5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vdXRpbHMvbWl4aW4uaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3V0aWxzL2ltcG9ydC1ocmVmLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi91dGlscy9yZW5kZXItc3RhdHVzLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi91dGlscy91bnJlc29sdmVkLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCJwb2x5bWVyLmRvbS5odG1sXCI+XG5cbjxzY3JpcHQ+XG4oZnVuY3Rpb24oKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIGxldCBzdHlsZUludGVyZmFjZSA9IHdpbmRvdy5TaGFkeUNTUztcblxuICAvKipcbiAgICogRWxlbWVudCBjbGFzcyBtaXhpbiB0aGF0IHByb3ZpZGVzIFBvbHltZXIncyBcImxlZ2FjeVwiIEFQSSBpbnRlbmRlZCB0byBiZVxuICAgKiBiYWNrd2FyZC1jb21wYXRpYmxlIHRvIHRoZSBncmVhdGVzdCBleHRlbnQgcG9zc2libGUgd2l0aCB0aGUgQVBJXG4gICAqIGZvdW5kIG9uIHRoZSBQb2x5bWVyIDEueCBgUG9seW1lci5CYXNlYCBwcm90b3R5cGUgYXBwbGllZCB0byBhbGwgZWxlbWVudHNcbiAgICogZGVmaW5lZCB1c2luZyB0aGUgYFBvbHltZXIoey4uLn0pYCBmdW5jdGlvbi5cbiAgICpcbiAgICogQG1peGluRnVuY3Rpb25cbiAgICogQHBvbHltZXJcbiAgICogQGFwcGxpZXNNaXhpbiBQb2x5bWVyLkVsZW1lbnRNaXhpblxuICAgKiBAYXBwbGllc01peGluIFBvbHltZXIuR2VzdHVyZUV2ZW50TGlzdGVuZXJzXG4gICAqIEBwcm9wZXJ0eSBpc0F0dGFjaGVkIHtib29sZWFufSBTZXQgdG8gYHRydWVgIGluIHRoaXMgZWxlbWVudCdzXG4gICAqICAgYGNvbm5lY3RlZENhbGxiYWNrYCBhbmQgYGZhbHNlYCBpbiBgZGlzY29ubmVjdGVkQ2FsbGJhY2tgXG4gICAqIEBtZW1iZXJvZiBQb2x5bWVyXG4gICAqIEBzdW1tYXJ5IEVsZW1lbnQgY2xhc3MgbWl4aW4gdGhhdCBwcm92aWRlcyBQb2x5bWVyJ3MgXCJsZWdhY3lcIiBBUElcbiAgICovXG4gIFBvbHltZXIuTGVnYWN5RWxlbWVudE1peGluID0gUG9seW1lci5kZWR1cGluZ01peGluKChiYXNlKSA9PiB7XG5cbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAZXh0ZW5kcyB7YmFzZX1cbiAgICAgKiBAaW1wbGVtZW50cyB7UG9seW1lcl9FbGVtZW50TWl4aW59XG4gICAgICogQGltcGxlbWVudHMge1BvbHltZXJfR2VzdHVyZUV2ZW50TGlzdGVuZXJzfVxuICAgICAqL1xuICAgIGNvbnN0IGxlZ2FjeUVsZW1lbnRCYXNlID0gUG9seW1lci5HZXN0dXJlRXZlbnRMaXN0ZW5lcnMoUG9seW1lci5FbGVtZW50TWl4aW4oYmFzZSkpO1xuXG4gICAgLyoqXG4gICAgICogTWFwIG9mIHNpbXBsZSBuYW1lcyB0byB0b3VjaCBhY3Rpb24gbmFtZXNcbiAgICAgKiBAZGljdFxuICAgICAqL1xuICAgIGNvbnN0IERJUkVDVElPTl9NQVAgPSB7XG4gICAgICAneCc6ICdwYW4teCcsXG4gICAgICAneSc6ICdwYW4teScsXG4gICAgICAnbm9uZSc6ICdub25lJyxcbiAgICAgICdhbGwnOiAnYXV0bydcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHBvbHltZXJcbiAgICAgKiBAbWl4aW5DbGFzc1xuICAgICAqIEBleHRlbmRzIHtsZWdhY3lFbGVtZW50QmFzZX1cbiAgICAgKiBAaW1wbGVtZW50cyB7UG9seW1lcl9MZWdhY3lFbGVtZW50TWl4aW59XG4gICAgICogQHVucmVzdHJpY3RlZFxuICAgICAqL1xuICAgIGNsYXNzIExlZ2FjeUVsZW1lbnQgZXh0ZW5kcyBsZWdhY3lFbGVtZW50QmFzZSB7XG5cbiAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnJvb3QgPSB0aGlzO1xuICAgICAgICB0aGlzLmNyZWF0ZWQoKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBMZWdhY3kgY2FsbGJhY2sgY2FsbGVkIGR1cmluZyB0aGUgYGNvbnN0cnVjdG9yYCwgZm9yIG92ZXJyaWRpbmdcbiAgICAgICAqIGJ5IHRoZSB1c2VyLlxuICAgICAgICovXG4gICAgICBjcmVhdGVkKCkge31cblxuICAgICAgLyoqXG4gICAgICAgKiBQcm92aWRlcyBhbiBpbXBsZW1lbnRhdGlvbiBvZiBgY29ubmVjdGVkQ2FsbGJhY2tgXG4gICAgICAgKiB3aGljaCBhZGRzIFBvbHltZXIgbGVnYWN5IEFQSSdzIGBhdHRhY2hlZGAgbWV0aG9kLlxuICAgICAgICogQG92ZXJyaWRlXG4gICAgICAgKi9cbiAgICAgIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgICAgICBzdXBlci5jb25uZWN0ZWRDYWxsYmFjaygpO1xuICAgICAgICB0aGlzLmlzQXR0YWNoZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmF0dGFjaGVkKCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogTGVnYWN5IGNhbGxiYWNrIGNhbGxlZCBkdXJpbmcgYGNvbm5lY3RlZENhbGxiYWNrYCwgZm9yIG92ZXJyaWRpbmdcbiAgICAgICAqIGJ5IHRoZSB1c2VyLlxuICAgICAgICovXG4gICAgICBhdHRhY2hlZCgpIHt9XG5cbiAgICAgIC8qKlxuICAgICAgICogUHJvdmlkZXMgYW4gaW1wbGVtZW50YXRpb24gb2YgYGRpc2Nvbm5lY3RlZENhbGxiYWNrYFxuICAgICAgICogd2hpY2ggYWRkcyBQb2x5bWVyIGxlZ2FjeSBBUEkncyBgZGV0YWNoZWRgIG1ldGhvZC5cbiAgICAgICAqIEBvdmVycmlkZVxuICAgICAgICovXG4gICAgICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgICAgc3VwZXIuZGlzY29ubmVjdGVkQ2FsbGJhY2soKTtcbiAgICAgICAgdGhpcy5pc0F0dGFjaGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZGV0YWNoZWQoKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBMZWdhY3kgY2FsbGJhY2sgY2FsbGVkIGR1cmluZyBgZGlzY29ubmVjdGVkQ2FsbGJhY2tgLCBmb3Igb3ZlcnJpZGluZ1xuICAgICAgICogYnkgdGhlIHVzZXIuXG4gICAgICAgKi9cbiAgICAgIGRldGFjaGVkKCkge31cblxuICAgICAgLyoqXG4gICAgICAgKiBQcm92aWRlcyBhbiBvdmVycmlkZSBpbXBsZW1lbnRhdGlvbiBvZiBgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrYFxuICAgICAgICogd2hpY2ggYWRkcyB0aGUgUG9seW1lciBsZWdhY3kgQVBJJ3MgYGF0dHJpYnV0ZUNoYW5nZWRgIG1ldGhvZC5cbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE5hbWUgb2YgYXR0cmlidXRlLlxuICAgICAgICogQHBhcmFtIHs/c3RyaW5nfSBvbGQgT2xkIHZhbHVlIG9mIGF0dHJpYnV0ZS5cbiAgICAgICAqIEBwYXJhbSB7P3N0cmluZ30gdmFsdWUgQ3VycmVudCB2YWx1ZSBvZiBhdHRyaWJ1dGUuXG4gICAgICAgKiBAb3ZlcnJpZGVcbiAgICAgICAqL1xuICAgICAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIG9sZCwgdmFsdWUpIHtcbiAgICAgICAgaWYgKG9sZCAhPT0gdmFsdWUpIHtcbiAgICAgICAgICBzdXBlci5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgb2xkLCB2YWx1ZSk7XG4gICAgICAgICAgdGhpcy5hdHRyaWJ1dGVDaGFuZ2VkKG5hbWUsIG9sZCwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogTGVnYWN5IGNhbGxiYWNrIGNhbGxlZCBkdXJpbmcgYGF0dHJpYnV0ZUNoYW5nZWRDaGFsbGJhY2tgLCBmb3Igb3ZlcnJpZGluZ1xuICAgICAgICogYnkgdGhlIHVzZXIuXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBOYW1lIG9mIGF0dHJpYnV0ZS5cbiAgICAgICAqIEBwYXJhbSB7P3N0cmluZ30gb2xkIE9sZCB2YWx1ZSBvZiBhdHRyaWJ1dGUuXG4gICAgICAgKiBAcGFyYW0gez9zdHJpbmd9IHZhbHVlIEN1cnJlbnQgdmFsdWUgb2YgYXR0cmlidXRlLlxuICAgICAgICovXG4gICAgICBhdHRyaWJ1dGVDaGFuZ2VkKG5hbWUsIG9sZCwgdmFsdWUpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblxuICAgICAgLyoqXG4gICAgICAgKiBPdmVycmlkZXMgdGhlIGRlZmF1bHQgYFBvbHltZXIuUHJvcGVydHlFZmZlY3RzYCBpbXBsZW1lbnRhdGlvbiB0b1xuICAgICAgICogYWRkIHN1cHBvcnQgZm9yIGNsYXNzIGluaXRpYWxpemF0aW9uIHZpYSB0aGUgYF9yZWdpc3RlcmVkYCBjYWxsYmFjay5cbiAgICAgICAqIFRoaXMgaXMgY2FsbGVkIG9ubHkgd2hlbiB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgdGhlIGVsZW1lbnQgaXMgY3JlYXRlZC5cbiAgICAgICAqXG4gICAgICAgKiBAb3ZlcnJpZGVcbiAgICAgICAqL1xuICAgICAgX2luaXRpYWxpemVQcm9wZXJ0aWVzKCkge1xuICAgICAgICBsZXQgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcyk7XG4gICAgICAgIGlmICghcHJvdG8uaGFzT3duUHJvcGVydHkoJ19faGFzUmVnaXN0ZXJGaW5pc2hlZCcpKSB7XG4gICAgICAgICAgcHJvdG8uX19oYXNSZWdpc3RlckZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLl9yZWdpc3RlcmVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIuX2luaXRpYWxpemVQcm9wZXJ0aWVzKCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ2FsbGVkIGF1dG9tYXRpY2FsbHkgd2hlbiBhbiBlbGVtZW50IGlzIGluaXRpYWxpemluZy5cbiAgICAgICAqIFVzZXJzIG1heSBvdmVycmlkZSB0aGlzIG1ldGhvZCB0byBwZXJmb3JtIGNsYXNzIHJlZ2lzdHJhdGlvbiB0aW1lXG4gICAgICAgKiB3b3JrLiBUaGUgaW1wbGVtZW50YXRpb24gc2hvdWxkIGVuc3VyZSB0aGUgd29yayBpcyBwZXJmb3JtZWRcbiAgICAgICAqIG9ubHkgb25jZSBmb3IgdGhlIGNsYXNzLlxuICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICovXG4gICAgICBfcmVnaXN0ZXJlZCgpIHt9XG5cbiAgICAgIC8qKlxuICAgICAgICogT3ZlcnJpZGVzIHRoZSBkZWZhdWx0IGBQb2x5bWVyLlByb3BlcnR5RWZmZWN0c2AgaW1wbGVtZW50YXRpb24gdG9cbiAgICAgICAqIGFkZCBzdXBwb3J0IGZvciBpbnN0YWxsaW5nIGBob3N0QXR0cmlidXRlc2AgYW5kIGBsaXN0ZW5lcnNgLlxuICAgICAgICpcbiAgICAgICAqIEBvdmVycmlkZVxuICAgICAgICovXG4gICAgICByZWFkeSgpIHtcbiAgICAgICAgdGhpcy5fZW5zdXJlQXR0cmlidXRlcygpO1xuICAgICAgICB0aGlzLl9hcHBseUxpc3RlbmVycygpO1xuICAgICAgICBzdXBlci5yZWFkeSgpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEVuc3VyZXMgYW4gZWxlbWVudCBoYXMgcmVxdWlyZWQgYXR0cmlidXRlcy4gQ2FsbGVkIHdoZW4gdGhlIGVsZW1lbnRcbiAgICAgICAqIGlzIGJlaW5nIHJlYWRpZWQgdmlhIGByZWFkeWAuIFVzZXJzIHNob3VsZCBvdmVycmlkZSB0byBzZXQgdGhlXG4gICAgICAgKiBlbGVtZW50J3MgcmVxdWlyZWQgYXR0cmlidXRlcy4gVGhlIGltcGxlbWVudGF0aW9uIHNob3VsZCBiZSBzdXJlXG4gICAgICAgKiB0byBjaGVjayBhbmQgbm90IG92ZXJyaWRlIGV4aXN0aW5nIGF0dHJpYnV0ZXMgYWRkZWQgYnlcbiAgICAgICAqIHRoZSB1c2VyIG9mIHRoZSBlbGVtZW50LiBUeXBpY2FsbHksIHNldHRpbmcgYXR0cmlidXRlcyBzaG91bGQgYmUgbGVmdFxuICAgICAgICogdG8gdGhlIGVsZW1lbnQgdXNlciBhbmQgbm90IGRvbmUgaGVyZTsgcmVhc29uYWJsZSBleGNlcHRpb25zIGluY2x1ZGVcbiAgICAgICAqIHNldHRpbmcgYXJpYSByb2xlcyBhbmQgZm9jdXNhYmlsaXR5LlxuICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICovXG4gICAgICBfZW5zdXJlQXR0cmlidXRlcygpIHt9XG5cbiAgICAgIC8qKlxuICAgICAgICogQWRkcyBlbGVtZW50IGV2ZW50IGxpc3RlbmVycy4gQ2FsbGVkIHdoZW4gdGhlIGVsZW1lbnRcbiAgICAgICAqIGlzIGJlaW5nIHJlYWRpZWQgdmlhIGByZWFkeWAuIFVzZXJzIHNob3VsZCBvdmVycmlkZSB0b1xuICAgICAgICogYWRkIGFueSByZXF1aXJlZCBlbGVtZW50IGV2ZW50IGxpc3RlbmVycy5cbiAgICAgICAqIEluIHBlcmZvcm1hbmNlIGNyaXRpY2FsIGVsZW1lbnRzLCB0aGUgd29yayBkb25lIGhlcmUgc2hvdWxkIGJlIGtlcHRcbiAgICAgICAqIHRvIGEgbWluaW11bSBzaW5jZSBpdCBpcyBkb25lIGJlZm9yZSB0aGUgZWxlbWVudCBpcyByZW5kZXJlZC4gSW5cbiAgICAgICAqIHRoZXNlIGVsZW1lbnRzLCBjb25zaWRlciBhZGRpbmcgbGlzdGVuZXJzIGFzeWNocm9ub3VzbHkgc28gYXMgbm90IHRvXG4gICAgICAgKiBibG9jayByZW5kZXIuXG4gICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgKi9cbiAgICAgIF9hcHBseUxpc3RlbmVycygpIHt9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ29udmVydHMgYSB0eXBlZCBKYXZhU2NyaXB0IHZhbHVlIHRvIGEgc3RyaW5nLlxuICAgICAgICpcbiAgICAgICAqIE5vdGUgdGhpcyBtZXRob2QgaXMgcHJvdmlkZWQgYXMgYmFja3dhcmQtY29tcGF0aWJsZSBsZWdhY3kgQVBJXG4gICAgICAgKiBvbmx5LiAgSXQgaXMgbm90IGRpcmVjdGx5IGNhbGxlZCBieSBhbnkgUG9seW1lciBmZWF0dXJlcy4gVG8gY3VzdG9taXplXG4gICAgICAgKiBob3cgcHJvcGVydGllcyBhcmUgc2VyaWFsaXplZCB0byBhdHRyaWJ1dGVzIGZvciBhdHRyaWJ1dGUgYmluZGluZ3MgYW5kXG4gICAgICAgKiBgcmVmbGVjdFRvQXR0cmlidXRlOiB0cnVlYCBwcm9wZXJ0aWVzIGFzIHdlbGwgYXMgdGhpcyBtZXRob2QsIG92ZXJyaWRlXG4gICAgICAgKiB0aGUgYF9zZXJpYWxpemVWYWx1ZWAgbWV0aG9kIHByb3ZpZGVkIGJ5IGBQb2x5bWVyLlByb3BlcnR5QWNjZXNzb3JzYC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIGRlc2VyaWFsaXplXG4gICAgICAgKiBAcmV0dXJuIHtzdHJpbmcgfCB1bmRlZmluZWR9IFNlcmlhbGl6ZWQgdmFsdWVcbiAgICAgICAqL1xuICAgICAgc2VyaWFsaXplKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZXJpYWxpemVWYWx1ZSh2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ29udmVydHMgYSBzdHJpbmcgdG8gYSB0eXBlZCBKYXZhU2NyaXB0IHZhbHVlLlxuICAgICAgICpcbiAgICAgICAqIE5vdGUgdGhpcyBtZXRob2QgaXMgcHJvdmlkZWQgYXMgYmFja3dhcmQtY29tcGF0aWJsZSBsZWdhY3kgQVBJXG4gICAgICAgKiBvbmx5LiAgSXQgaXMgbm90IGRpcmVjdGx5IGNhbGxlZCBieSBhbnkgUG9seW1lciBmZWF0dXJlcy4gIFRvIGN1c3RvbWl6ZVxuICAgICAgICogaG93IGF0dHJpYnV0ZXMgYXJlIGRlc2VyaWFsaXplZCB0byBwcm9wZXJ0aWVzIGZvciBpblxuICAgICAgICogYGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFja2AsIG92ZXJyaWRlIGBfZGVzZXJpYWxpemVWYWx1ZWAgbWV0aG9kXG4gICAgICAgKiBwcm92aWRlZCBieSBgUG9seW1lci5Qcm9wZXJ0eUFjY2Vzc29yc2AuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIFN0cmluZyB0byBkZXNlcmlhbGl6ZVxuICAgICAgICogQHBhcmFtIHsqfSB0eXBlIFR5cGUgdG8gZGVzZXJpYWxpemUgdGhlIHN0cmluZyB0b1xuICAgICAgICogQHJldHVybiB7Kn0gUmV0dXJucyB0aGUgZGVzZXJpYWxpemVkIHZhbHVlIGluIHRoZSBgdHlwZWAgZ2l2ZW4uXG4gICAgICAgKi9cbiAgICAgIGRlc2VyaWFsaXplKHZhbHVlLCB0eXBlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZXNlcmlhbGl6ZVZhbHVlKHZhbHVlLCB0eXBlKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBTZXJpYWxpemVzIGEgcHJvcGVydHkgdG8gaXRzIGFzc29jaWF0ZWQgYXR0cmlidXRlLlxuICAgICAgICpcbiAgICAgICAqIE5vdGUgdGhpcyBtZXRob2QgaXMgcHJvdmlkZWQgYXMgYmFja3dhcmQtY29tcGF0aWJsZSBsZWdhY3kgQVBJXG4gICAgICAgKiBvbmx5LiAgSXQgaXMgbm90IGRpcmVjdGx5IGNhbGxlZCBieSBhbnkgUG9seW1lciBmZWF0dXJlcy5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgbmFtZSB0byByZWZsZWN0LlxuICAgICAgICogQHBhcmFtIHtzdHJpbmc9fSBhdHRyaWJ1dGUgQXR0cmlidXRlIG5hbWUgdG8gcmVmbGVjdC5cbiAgICAgICAqIEBwYXJhbSB7Kj19IHZhbHVlIFByb3BlcnR5IHZhbHVlIHRvIHJlZmVjdC5cbiAgICAgICAqL1xuICAgICAgcmVmbGVjdFByb3BlcnR5VG9BdHRyaWJ1dGUocHJvcGVydHksIGF0dHJpYnV0ZSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5fcHJvcGVydHlUb0F0dHJpYnV0ZShwcm9wZXJ0eSwgYXR0cmlidXRlLCB2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogU2V0cyBhIHR5cGVkIHZhbHVlIHRvIGFuIEhUTUwgYXR0cmlidXRlIG9uIGEgbm9kZS5cbiAgICAgICAqXG4gICAgICAgKiBOb3RlIHRoaXMgbWV0aG9kIGlzIHByb3ZpZGVkIGFzIGJhY2t3YXJkLWNvbXBhdGlibGUgbGVnYWN5IEFQSVxuICAgICAgICogb25seS4gIEl0IGlzIG5vdCBkaXJlY3RseSBjYWxsZWQgYnkgYW55IFBvbHltZXIgZmVhdHVyZXMuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byBzZXJpYWxpemUuXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlIEF0dHJpYnV0ZSBuYW1lIHRvIHNlcmlhbGl6ZSB0by5cbiAgICAgICAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZSBFbGVtZW50IHRvIHNldCBhdHRyaWJ1dGUgdG8uXG4gICAgICAgKi9cbiAgICAgIHNlcmlhbGl6ZVZhbHVlVG9BdHRyaWJ1dGUodmFsdWUsIGF0dHJpYnV0ZSwgbm9kZSkge1xuICAgICAgICB0aGlzLl92YWx1ZVRvTm9kZUF0dHJpYnV0ZSgvKiogQHR5cGUge0VsZW1lbnR9ICovIChub2RlIHx8IHRoaXMpLCB2YWx1ZSwgYXR0cmlidXRlKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDb3BpZXMgb3duIHByb3BlcnRpZXMgKGluY2x1ZGluZyBhY2Nlc3NvciBkZXNjcmlwdG9ycykgZnJvbSBhIHNvdXJjZVxuICAgICAgICogb2JqZWN0IHRvIGEgdGFyZ2V0IG9iamVjdC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvdG90eXBlIFRhcmdldCBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIHRvLlxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IGFwaSBTb3VyY2Ugb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tLlxuICAgICAgICogQHJldHVybiB7T2JqZWN0fSBwcm90b3R5cGUgb2JqZWN0IHRoYXQgd2FzIHBhc3NlZCBhcyBmaXJzdCBhcmd1bWVudC5cbiAgICAgICAqL1xuICAgICAgZXh0ZW5kKHByb3RvdHlwZSwgYXBpKSB7XG4gICAgICAgIGlmICghKHByb3RvdHlwZSAmJiBhcGkpKSB7XG4gICAgICAgICAgcmV0dXJuIHByb3RvdHlwZSB8fCBhcGk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG4kID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYXBpKTtcbiAgICAgICAgZm9yIChsZXQgaT0wLCBuOyAoaTxuJC5sZW5ndGgpICYmIChuPW4kW2ldKTsgaSsrKSB7XG4gICAgICAgICAgbGV0IHBkID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihhcGksIG4pO1xuICAgICAgICAgIGlmIChwZCkge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvdHlwZSwgbiwgcGQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJvdG90eXBlO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENvcGllcyBwcm9wcyBmcm9tIGEgc291cmNlIG9iamVjdCB0byBhIHRhcmdldCBvYmplY3QuXG4gICAgICAgKlxuICAgICAgICogTm90ZSwgdGhpcyBtZXRob2QgdXNlcyBhIHNpbXBsZSBgZm9yLi4uaW5gIHN0cmF0ZWd5IGZvciBlbnVtZXJhdGluZ1xuICAgICAgICogcHJvcGVydGllcy4gIFRvIGVuc3VyZSBvbmx5IGBvd25Qcm9wZXJ0aWVzYCBhcmUgY29waWVkIGZyb20gc291cmNlXG4gICAgICAgKiB0byB0YXJnZXQgYW5kIHRoYXQgYWNjZXNzb3IgaW1wbGVtZW50YXRpb25zIGFyZSBjb3BpZWQsIHVzZSBgZXh0ZW5kYC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IFRhcmdldCBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIHRvLlxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBTb3VyY2Ugb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tLlxuICAgICAgICogQHJldHVybiB7T2JqZWN0fSBUYXJnZXQgb2JqZWN0IHRoYXQgd2FzIHBhc3NlZCBhcyBmaXJzdCBhcmd1bWVudC5cbiAgICAgICAqL1xuICAgICAgbWl4aW4odGFyZ2V0LCBzb3VyY2UpIHtcbiAgICAgICAgZm9yIChsZXQgaSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICB0YXJnZXRbaV0gPSBzb3VyY2VbaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBTZXRzIHRoZSBwcm90b3R5cGUgb2YgYW4gb2JqZWN0LlxuICAgICAgICpcbiAgICAgICAqIE5vdGUgdGhpcyBtZXRob2QgaXMgcHJvdmlkZWQgYXMgYmFja3dhcmQtY29tcGF0aWJsZSBsZWdhY3kgQVBJXG4gICAgICAgKiBvbmx5LiAgSXQgaXMgbm90IGRpcmVjdGx5IGNhbGxlZCBieSBhbnkgUG9seW1lciBmZWF0dXJlcy5cbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCBvbiB3aGljaCB0byBzZXQgdGhlIHByb3RvdHlwZS5cbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm90b3R5cGUgVGhlIHByb3RvdHlwZSB0aGF0IHdpbGwgYmUgc2V0IG9uIHRoZSBnaXZlblxuICAgICAgICogYG9iamVjdGAuXG4gICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFJldHVybnMgdGhlIGdpdmVuIGBvYmplY3RgIHdpdGggaXRzIHByb3RvdHlwZSBzZXRcbiAgICAgICAqIHRvIHRoZSBnaXZlbiBgcHJvdG90eXBlYCBvYmplY3QuXG4gICAgICAgKi9cbiAgICAgIGNoYWluT2JqZWN0KG9iamVjdCwgcHJvdG90eXBlKSB7XG4gICAgICAgIGlmIChvYmplY3QgJiYgcHJvdG90eXBlICYmIG9iamVjdCAhPT0gcHJvdG90eXBlKSB7XG4gICAgICAgICAgb2JqZWN0Ll9fcHJvdG9fXyA9IHByb3RvdHlwZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgfVxuXG4gICAgICAvKiAqKioqIEJlZ2luIFRlbXBsYXRlICoqKiogKi9cblxuICAgICAgLyoqXG4gICAgICAgKiBDYWxscyBgaW1wb3J0Tm9kZWAgb24gdGhlIGBjb250ZW50YCBvZiB0aGUgYHRlbXBsYXRlYCBzcGVjaWZpZWQgYW5kXG4gICAgICAgKiByZXR1cm5zIGEgZG9jdW1lbnQgZnJhZ21lbnQgY29udGFpbmluZyB0aGUgaW1wb3J0ZWQgY29udGVudC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge0hUTUxUZW1wbGF0ZUVsZW1lbnR9IHRlbXBsYXRlIEhUTUwgdGVtcGxhdGUgZWxlbWVudCB0byBpbnN0YW5jZS5cbiAgICAgICAqIEByZXR1cm4ge0RvY3VtZW50RnJhZ21lbnR9IERvY3VtZW50IGZyYWdtZW50IGNvbnRhaW5pbmcgdGhlIGltcG9ydGVkXG4gICAgICAgKiAgIHRlbXBsYXRlIGNvbnRlbnQuXG4gICAgICAqL1xuICAgICAgaW5zdGFuY2VUZW1wbGF0ZSh0ZW1wbGF0ZSkge1xuICAgICAgICBsZXQgY29udGVudCA9IHRoaXMuY29uc3RydWN0b3IuX2NvbnRlbnRGb3JUZW1wbGF0ZSh0ZW1wbGF0ZSk7XG4gICAgICAgIGxldCBkb20gPSAvKiogQHR5cGUge0RvY3VtZW50RnJhZ21lbnR9ICovXG4gICAgICAgICAgKGRvY3VtZW50LmltcG9ydE5vZGUoY29udGVudCwgdHJ1ZSkpO1xuICAgICAgICByZXR1cm4gZG9tO1xuICAgICAgfVxuXG4gICAgICAvKiAqKioqIEJlZ2luIEV2ZW50cyAqKioqICovXG5cblxuXG4gICAgICAvKipcbiAgICAgICAqIERpc3BhdGNoZXMgYSBjdXN0b20gZXZlbnQgd2l0aCBhbiBvcHRpb25hbCBkZXRhaWwgdmFsdWUuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgTmFtZSBvZiBldmVudCB0eXBlLlxuICAgICAgICogQHBhcmFtIHsqPX0gZGV0YWlsIERldGFpbCB2YWx1ZSBjb250YWluaW5nIGV2ZW50LXNwZWNpZmljXG4gICAgICAgKiAgIHBheWxvYWQuXG4gICAgICAgKiBAcGFyYW0ge3sgYnViYmxlczogKGJvb2xlYW58dW5kZWZpbmVkKSwgY2FuY2VsYWJsZTogKGJvb2xlYW58dW5kZWZpbmVkKSwgY29tcG9zZWQ6IChib29sZWFufHVuZGVmaW5lZCkgfT19XG4gICAgICAgKiAgb3B0aW9ucyBPYmplY3Qgc3BlY2lmeWluZyBvcHRpb25zLiAgVGhlc2UgbWF5IGluY2x1ZGU6XG4gICAgICAgKiAgYGJ1YmJsZXNgIChib29sZWFuLCBkZWZhdWx0cyB0byBgdHJ1ZWApLFxuICAgICAgICogIGBjYW5jZWxhYmxlYCAoYm9vbGVhbiwgZGVmYXVsdHMgdG8gZmFsc2UpLCBhbmRcbiAgICAgICAqICBgbm9kZWAgb24gd2hpY2ggdG8gZmlyZSB0aGUgZXZlbnQgKEhUTUxFbGVtZW50LCBkZWZhdWx0cyB0byBgdGhpc2ApLlxuICAgICAgICogQHJldHVybiB7RXZlbnR9IFRoZSBuZXcgZXZlbnQgdGhhdCB3YXMgZmlyZWQuXG4gICAgICAgKi9cbiAgICAgIGZpcmUodHlwZSwgZGV0YWlsLCBvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICBkZXRhaWwgPSAoZGV0YWlsID09PSBudWxsIHx8IGRldGFpbCA9PT0gdW5kZWZpbmVkKSA/IHt9IDogZGV0YWlsO1xuICAgICAgICBsZXQgZXZlbnQgPSBuZXcgRXZlbnQodHlwZSwge1xuICAgICAgICAgIGJ1YmJsZXM6IG9wdGlvbnMuYnViYmxlcyA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IG9wdGlvbnMuYnViYmxlcyxcbiAgICAgICAgICBjYW5jZWxhYmxlOiBCb29sZWFuKG9wdGlvbnMuY2FuY2VsYWJsZSksXG4gICAgICAgICAgY29tcG9zZWQ6IG9wdGlvbnMuY29tcG9zZWQgPT09IHVuZGVmaW5lZCA/IHRydWU6IG9wdGlvbnMuY29tcG9zZWRcbiAgICAgICAgfSk7XG4gICAgICAgIGV2ZW50LmRldGFpbCA9IGRldGFpbDtcbiAgICAgICAgbGV0IG5vZGUgPSBvcHRpb25zLm5vZGUgfHwgdGhpcztcbiAgICAgICAgbm9kZS5kaXNwYXRjaEV2ZW50KGV2ZW50KVxuICAgICAgICByZXR1cm4gZXZlbnQ7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ29udmVuaWVuY2UgbWV0aG9kIHRvIGFkZCBhbiBldmVudCBsaXN0ZW5lciBvbiBhIGdpdmVuIGVsZW1lbnQsXG4gICAgICAgKiBsYXRlIGJvdW5kIHRvIGEgbmFtZWQgbWV0aG9kIG9uIHRoaXMgZWxlbWVudC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgRWxlbWVudCB0byBhZGQgZXZlbnQgbGlzdGVuZXIgdG8uXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIE5hbWUgb2YgZXZlbnQgdG8gbGlzdGVuIGZvci5cbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2ROYW1lIE5hbWUgb2YgaGFuZGxlciBtZXRob2Qgb24gYHRoaXNgIHRvIGNhbGwuXG4gICAgICAgKi9cbiAgICAgIGxpc3Rlbihub2RlLCBldmVudE5hbWUsIG1ldGhvZE5hbWUpIHtcbiAgICAgICAgbm9kZSA9IC8qKiBAdHlwZSB7RWxlbWVudH0gKi8gKG5vZGUgfHwgdGhpcyk7XG4gICAgICAgIGxldCBoYmwgPSB0aGlzLl9fYm91bmRMaXN0ZW5lcnMgfHxcbiAgICAgICAgICAodGhpcy5fX2JvdW5kTGlzdGVuZXJzID0gbmV3IFdlYWtNYXAoKSk7XG4gICAgICAgIGxldCBibCA9IGhibC5nZXQobm9kZSk7XG4gICAgICAgIGlmICghYmwpIHtcbiAgICAgICAgICBibCA9IHt9O1xuICAgICAgICAgIGhibC5zZXQobm9kZSwgYmwpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBrZXkgPSBldmVudE5hbWUgKyBtZXRob2ROYW1lO1xuICAgICAgICBpZiAoIWJsW2tleV0pIHtcbiAgICAgICAgICBibFtrZXldID0gdGhpcy5fYWRkTWV0aG9kRXZlbnRMaXN0ZW5lclRvTm9kZShcbiAgICAgICAgICAgIG5vZGUsIGV2ZW50TmFtZSwgbWV0aG9kTmFtZSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDb252ZW5pZW5jZSBtZXRob2QgdG8gcmVtb3ZlIGFuIGV2ZW50IGxpc3RlbmVyIGZyb20gYSBnaXZlbiBlbGVtZW50LFxuICAgICAgICogbGF0ZSBib3VuZCB0byBhIG5hbWVkIG1ldGhvZCBvbiB0aGlzIGVsZW1lbnQuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtFbGVtZW50fSBub2RlIEVsZW1lbnQgdG8gcmVtb3ZlIGV2ZW50IGxpc3RlbmVyIGZyb20uXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIE5hbWUgb2YgZXZlbnQgdG8gc3RvcCBsaXN0ZW5pbmcgdG8uXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kTmFtZSBOYW1lIG9mIGhhbmRsZXIgbWV0aG9kIG9uIGB0aGlzYCB0byBub3QgY2FsbFxuICAgICAgIGFueW1vcmUuXG4gICAgICAgKi9cbiAgICAgIHVubGlzdGVuKG5vZGUsIGV2ZW50TmFtZSwgbWV0aG9kTmFtZSkge1xuICAgICAgICBub2RlID0gLyoqIEB0eXBlIHtFbGVtZW50fSAqLyAobm9kZSB8fCB0aGlzKTtcbiAgICAgICAgbGV0IGJsID0gdGhpcy5fX2JvdW5kTGlzdGVuZXJzICYmIHRoaXMuX19ib3VuZExpc3RlbmVycy5nZXQobm9kZSk7XG4gICAgICAgIGxldCBrZXkgPSBldmVudE5hbWUgKyBtZXRob2ROYW1lO1xuICAgICAgICBsZXQgaGFuZGxlciA9IGJsICYmIGJsW2tleV07XG4gICAgICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICAgICAgdGhpcy5fcmVtb3ZlRXZlbnRMaXN0ZW5lckZyb21Ob2RlKG5vZGUsIGV2ZW50TmFtZSwgaGFuZGxlcik7XG4gICAgICAgICAgYmxba2V5XSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBPdmVycmlkZSBzY3JvbGxpbmcgYmVoYXZpb3IgdG8gYWxsIGRpcmVjdGlvbiwgb25lIGRpcmVjdGlvbiwgb3Igbm9uZS5cbiAgICAgICAqXG4gICAgICAgKiBWYWxpZCBzY3JvbGwgZGlyZWN0aW9uczpcbiAgICAgICAqICAgLSAnYWxsJzogc2Nyb2xsIGluIGFueSBkaXJlY3Rpb25cbiAgICAgICAqICAgLSAneCc6IHNjcm9sbCBvbmx5IGluIHRoZSAneCcgZGlyZWN0aW9uXG4gICAgICAgKiAgIC0gJ3knOiBzY3JvbGwgb25seSBpbiB0aGUgJ3knIGRpcmVjdGlvblxuICAgICAgICogICAtICdub25lJzogZGlzYWJsZSBzY3JvbGxpbmcgZm9yIHRoaXMgbm9kZVxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nPX0gZGlyZWN0aW9uIERpcmVjdGlvbiB0byBhbGxvdyBzY3JvbGxpbmdcbiAgICAgICAqIERlZmF1bHRzIHRvIGBhbGxgLlxuICAgICAgICogQHBhcmFtIHtFbGVtZW50PX0gbm9kZSBFbGVtZW50IHRvIGFwcGx5IHNjcm9sbCBkaXJlY3Rpb24gc2V0dGluZy5cbiAgICAgICAqIERlZmF1bHRzIHRvIGB0aGlzYC5cbiAgICAgICAqL1xuICAgICAgc2V0U2Nyb2xsRGlyZWN0aW9uKGRpcmVjdGlvbiwgbm9kZSkge1xuICAgICAgICBQb2x5bWVyLkdlc3R1cmVzLnNldFRvdWNoQWN0aW9uKC8qKiBAdHlwZSB7RWxlbWVudH0gKi8gKG5vZGUgfHwgdGhpcyksIERJUkVDVElPTl9NQVBbZGlyZWN0aW9uXSB8fCAnYXV0bycpO1xuICAgICAgfVxuICAgICAgLyogKioqKiBFbmQgRXZlbnRzICoqKiogKi9cblxuICAgICAgLyoqXG4gICAgICAgKiBDb252ZW5pZW5jZSBtZXRob2QgdG8gcnVuIGBxdWVyeVNlbGVjdG9yYCBvbiB0aGlzIGxvY2FsIERPTSBzY29wZS5cbiAgICAgICAqXG4gICAgICAgKiBUaGlzIGZ1bmN0aW9uIGNhbGxzIGBQb2x5bWVyLmRvbSh0aGlzLnJvb3QpLnF1ZXJ5U2VsZWN0b3Ioc2xjdHIpYC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2xjdHIgU2VsZWN0b3IgdG8gcnVuIG9uIHRoaXMgbG9jYWwgRE9NIHNjb3BlXG4gICAgICAgKiBAcmV0dXJuIHtFbGVtZW50fSBFbGVtZW50IGZvdW5kIGJ5IHRoZSBzZWxlY3Rvciwgb3IgbnVsbCBpZiBub3QgZm91bmQuXG4gICAgICAgKi9cbiAgICAgICQkKHNsY3RyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvb3QucXVlcnlTZWxlY3RvcihzbGN0cik7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUmV0dXJuIHRoZSBlbGVtZW50IHdob3NlIGxvY2FsIGRvbSB3aXRoaW4gd2hpY2ggdGhpcyBlbGVtZW50XG4gICAgICAgKiBpcyBjb250YWluZWQuIFRoaXMgaXMgYSBzaG9ydGhhbmQgZm9yXG4gICAgICAgKiBgdGhpcy5nZXRSb290Tm9kZSgpLmhvc3RgLlxuICAgICAgICogQHRoaXMge0VsZW1lbnR9XG4gICAgICAgKi9cbiAgICAgIGdldCBkb21Ib3N0KCkge1xuICAgICAgICBsZXQgcm9vdCA9IHRoaXMuZ2V0Um9vdE5vZGUoKTtcbiAgICAgICAgcmV0dXJuIChyb290IGluc3RhbmNlb2YgRG9jdW1lbnRGcmFnbWVudCkgPyAvKiogQHR5cGUge1NoYWRvd1Jvb3R9ICovIChyb290KS5ob3N0IDogcm9vdDtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBGb3JjZSB0aGlzIGVsZW1lbnQgdG8gZGlzdHJpYnV0ZSBpdHMgY2hpbGRyZW4gdG8gaXRzIGxvY2FsIGRvbS5cbiAgICAgICAqIFRoaXMgc2hvdWxkIG5vdCBiZSBuZWNlc3NhcnkgYXMgb2YgUG9seW1lciAyLjAuMiBhbmQgaXMgcHJvdmlkZWQgb25seVxuICAgICAgICogZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuICAgICAgICovXG4gICAgICBkaXN0cmlidXRlQ29udGVudCgpIHtcbiAgICAgICAgaWYgKHdpbmRvdy5TaGFkeURPTSAmJiB0aGlzLnNoYWRvd1Jvb3QpIHtcbiAgICAgICAgICBTaGFkeURPTS5mbHVzaCgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUmV0dXJucyBhIGxpc3Qgb2Ygbm9kZXMgdGhhdCBhcmUgdGhlIGVmZmVjdGl2ZSBjaGlsZE5vZGVzLiBUaGUgZWZmZWN0aXZlXG4gICAgICAgKiBjaGlsZE5vZGVzIGxpc3QgaXMgdGhlIHNhbWUgYXMgdGhlIGVsZW1lbnQncyBjaGlsZE5vZGVzIGV4Y2VwdCB0aGF0XG4gICAgICAgKiBhbnkgYDxjb250ZW50PmAgZWxlbWVudHMgYXJlIHJlcGxhY2VkIHdpdGggdGhlIGxpc3Qgb2Ygbm9kZXMgZGlzdHJpYnV0ZWRcbiAgICAgICAqIHRvIHRoZSBgPGNvbnRlbnQ+YCwgdGhlIHJlc3VsdCBvZiBpdHMgYGdldERpc3RyaWJ1dGVkTm9kZXNgIG1ldGhvZC5cbiAgICAgICAqIEB0aGlzIHtFbGVtZW50fVxuICAgICAgICogQHJldHVybiB7QXJyYXk8Tm9kZT59IExpc3Qgb2YgZWZmY3RpdmUgY2hpbGQgbm9kZXMuXG4gICAgICAgKi9cbiAgICAgIGdldEVmZmVjdGl2ZUNoaWxkTm9kZXMoKSB7XG4gICAgICAgIHJldHVybiAvKiogQHR5cGUge1BvbHltZXIuRG9tQXBpfSAqLyAoUG9seW1lci5kb20odGhpcykpLmdldEVmZmVjdGl2ZUNoaWxkTm9kZXMoKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBub2RlcyBkaXN0cmlidXRlZCB3aXRoaW4gdGhpcyBlbGVtZW50IHRoYXQgbWF0Y2hcbiAgICAgICAqIGBzZWxlY3RvcmAuIFRoZXNlIGNhbiBiZSBkb20gY2hpbGRyZW4gb3IgZWxlbWVudHMgZGlzdHJpYnV0ZWQgdG9cbiAgICAgICAqIGNoaWxkcmVuIHRoYXQgYXJlIGluc2VydGlvbiBwb2ludHMuXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3IgU2VsZWN0b3IgdG8gcnVuLlxuICAgICAgICogQHRoaXMge0VsZW1lbnR9XG4gICAgICAgKiBAcmV0dXJuIHtBcnJheTxOb2RlPn0gTGlzdCBvZiBkaXN0cmlidXRlZCBlbGVtZW50cyB0aGF0IG1hdGNoIHNlbGVjdG9yLlxuICAgICAgICovXG4gICAgICBxdWVyeURpc3RyaWJ1dGVkRWxlbWVudHMoc2VsZWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIC8qKiBAdHlwZSB7UG9seW1lci5Eb21BcGl9ICovIChQb2x5bWVyLmRvbSh0aGlzKSkucXVlcnlEaXN0cmlidXRlZEVsZW1lbnRzKHNlbGVjdG9yKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBlbGVtZW50cyB0aGF0IGFyZSB0aGUgZWZmZWN0aXZlIGNoaWxkcmVuLiBUaGUgZWZmZWN0aXZlXG4gICAgICAgKiBjaGlsZHJlbiBsaXN0IGlzIHRoZSBzYW1lIGFzIHRoZSBlbGVtZW50J3MgY2hpbGRyZW4gZXhjZXB0IHRoYXRcbiAgICAgICAqIGFueSBgPGNvbnRlbnQ+YCBlbGVtZW50cyBhcmUgcmVwbGFjZWQgd2l0aCB0aGUgbGlzdCBvZiBlbGVtZW50c1xuICAgICAgICogZGlzdHJpYnV0ZWQgdG8gdGhlIGA8Y29udGVudD5gLlxuICAgICAgICpcbiAgICAgICAqIEByZXR1cm4ge0FycmF5PE5vZGU+fSBMaXN0IG9mIGVmZmN0aXZlIGNoaWxkcmVuLlxuICAgICAgICovXG4gICAgICBnZXRFZmZlY3RpdmVDaGlsZHJlbigpIHtcbiAgICAgICAgbGV0IGxpc3QgPSB0aGlzLmdldEVmZmVjdGl2ZUNoaWxkTm9kZXMoKTtcbiAgICAgICAgcmV0dXJuIGxpc3QuZmlsdGVyKGZ1bmN0aW9uKC8qKiBAdHlwZSB7Tm9kZX0gKi8gbikge1xuICAgICAgICAgIHJldHVybiAobi5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIG9mIHRleHQgY29udGVudCB0aGF0IGlzIHRoZSBjb25jYXRlbmF0aW9uIG9mIHRoZVxuICAgICAgICogdGV4dCBjb250ZW50J3Mgb2YgdGhlIGVsZW1lbnQncyBlZmZlY3RpdmUgY2hpbGROb2RlcyAodGhlIGVsZW1lbnRzXG4gICAgICAgKiByZXR1cm5lZCBieSA8YSBocmVmPVwiI2dldEVmZmVjdGl2ZUNoaWxkTm9kZXM+Z2V0RWZmZWN0aXZlQ2hpbGROb2RlczwvYT4uXG4gICAgICAgKlxuICAgICAgICogQHJldHVybiB7c3RyaW5nfSBMaXN0IG9mIGVmZmN0aXZlIGNoaWxkcmVuLlxuICAgICAgICovXG4gICAgICBnZXRFZmZlY3RpdmVUZXh0Q29udGVudCgpIHtcbiAgICAgICAgbGV0IGNuID0gdGhpcy5nZXRFZmZlY3RpdmVDaGlsZE5vZGVzKCk7XG4gICAgICAgIGxldCB0YyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpPTAsIGM7IChjID0gY25baV0pOyBpKyspIHtcbiAgICAgICAgICBpZiAoYy5ub2RlVHlwZSAhPT0gTm9kZS5DT01NRU5UX05PREUpIHtcbiAgICAgICAgICAgIHRjLnB1c2goYy50ZXh0Q29udGVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0Yy5qb2luKCcnKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZXR1cm5zIHRoZSBmaXJzdCBlZmZlY3RpdmUgY2hpbGROb2RlIHdpdGhpbiB0aGlzIGVsZW1lbnQgdGhhdFxuICAgICAgICogbWF0Y2ggYHNlbGVjdG9yYC4gVGhlc2UgY2FuIGJlIGRvbSBjaGlsZCBub2RlcyBvciBlbGVtZW50cyBkaXN0cmlidXRlZFxuICAgICAgICogdG8gY2hpbGRyZW4gdGhhdCBhcmUgaW5zZXJ0aW9uIHBvaW50cy5cbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzZWxlY3RvciBTZWxlY3RvciB0byBydW4uXG4gICAgICAgKiBAcmV0dXJuIHtPYmplY3Q8Tm9kZT59IEZpcnN0IGVmZmVjdGl2ZSBjaGlsZCBub2RlIHRoYXQgbWF0Y2hlcyBzZWxlY3Rvci5cbiAgICAgICAqL1xuICAgICAgcXVlcnlFZmZlY3RpdmVDaGlsZHJlbihzZWxlY3Rvcikge1xuICAgICAgICBsZXQgZSQgPSB0aGlzLnF1ZXJ5RGlzdHJpYnV0ZWRFbGVtZW50cyhzZWxlY3Rvcik7XG4gICAgICAgIHJldHVybiBlJCAmJiBlJFswXTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBlZmZlY3RpdmUgY2hpbGROb2RlcyB3aXRoaW4gdGhpcyBlbGVtZW50IHRoYXRcbiAgICAgICAqIG1hdGNoIGBzZWxlY3RvcmAuIFRoZXNlIGNhbiBiZSBkb20gY2hpbGQgbm9kZXMgb3IgZWxlbWVudHMgZGlzdHJpYnV0ZWRcbiAgICAgICAqIHRvIGNoaWxkcmVuIHRoYXQgYXJlIGluc2VydGlvbiBwb2ludHMuXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3IgU2VsZWN0b3IgdG8gcnVuLlxuICAgICAgICogQHJldHVybiB7QXJyYXk8Tm9kZT59IExpc3Qgb2YgZWZmZWN0aXZlIGNoaWxkIG5vZGVzIHRoYXQgbWF0Y2ggc2VsZWN0b3IuXG4gICAgICAgKi9cbiAgICAgIHF1ZXJ5QWxsRWZmZWN0aXZlQ2hpbGRyZW4oc2VsZWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucXVlcnlEaXN0cmlidXRlZEVsZW1lbnRzKHNlbGVjdG9yKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBub2RlcyBkaXN0cmlidXRlZCB0byB0aGlzIGVsZW1lbnQncyBgPHNsb3Q+YC5cbiAgICAgICAqXG4gICAgICAgKiBJZiB0aGlzIGVsZW1lbnQgY29udGFpbnMgbW9yZSB0aGFuIG9uZSBgPHNsb3Q+YCBpbiBpdHMgbG9jYWwgRE9NLFxuICAgICAgICogYW4gb3B0aW9uYWwgc2VsZWN0b3IgbWF5IGJlIHBhc3NlZCB0byBjaG9vc2UgdGhlIGRlc2lyZWQgY29udGVudC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZz19IHNsY3RyIENTUyBzZWxlY3RvciB0byBjaG9vc2UgdGhlIGRlc2lyZWRcbiAgICAgICAqICAgYDxzbG90PmAuICBEZWZhdWx0cyB0byBgY29udGVudGAuXG4gICAgICAgKiBAcmV0dXJuIHtBcnJheTxOb2RlPn0gTGlzdCBvZiBkaXN0cmlidXRlZCBub2RlcyBmb3IgdGhlIGA8c2xvdD5gLlxuICAgICAgICovXG4gICAgICBnZXRDb250ZW50Q2hpbGROb2RlcyhzbGN0cikge1xuICAgICAgICBsZXQgY29udGVudCA9IHRoaXMucm9vdC5xdWVyeVNlbGVjdG9yKHNsY3RyIHx8ICdzbG90Jyk7XG4gICAgICAgIHJldHVybiBjb250ZW50ID8gLyoqIEB0eXBlIHtQb2x5bWVyLkRvbUFwaX0gKi8oUG9seW1lci5kb20oY29udGVudCkpLmdldERpc3RyaWJ1dGVkTm9kZXMoKSA6IFtdO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJldHVybnMgYSBsaXN0IG9mIGVsZW1lbnQgY2hpbGRyZW4gZGlzdHJpYnV0ZWQgdG8gdGhpcyBlbGVtZW50J3NcbiAgICAgICAqIGA8c2xvdD5gLlxuICAgICAgICpcbiAgICAgICAqIElmIHRoaXMgZWxlbWVudCBjb250YWlucyBtb3JlIHRoYW4gb25lIGA8c2xvdD5gIGluIGl0c1xuICAgICAgICogbG9jYWwgRE9NLCBhbiBvcHRpb25hbCBzZWxlY3RvciBtYXkgYmUgcGFzc2VkIHRvIGNob29zZSB0aGUgZGVzaXJlZFxuICAgICAgICogY29udGVudC4gIFRoaXMgbWV0aG9kIGRpZmZlcnMgZnJvbSBgZ2V0Q29udGVudENoaWxkTm9kZXNgIGluIHRoYXQgb25seVxuICAgICAgICogZWxlbWVudHMgYXJlIHJldHVybmVkLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nPX0gc2xjdHIgQ1NTIHNlbGVjdG9yIHRvIGNob29zZSB0aGUgZGVzaXJlZFxuICAgICAgICogICBgPGNvbnRlbnQ+YC4gIERlZmF1bHRzIHRvIGBjb250ZW50YC5cbiAgICAgICAqIEByZXR1cm4ge0FycmF5PEhUTUxFbGVtZW50Pn0gTGlzdCBvZiBkaXN0cmlidXRlZCBub2RlcyBmb3IgdGhlXG4gICAgICAgKiAgIGA8c2xvdD5gLlxuICAgICAgICogQHN1cHByZXNzIHtpbnZhbGlkQ2FzdHN9XG4gICAgICAgKi9cbiAgICAgIGdldENvbnRlbnRDaGlsZHJlbihzbGN0cikge1xuICAgICAgICByZXR1cm4gLyoqIEB0eXBlIHtBcnJheTxIVE1MRWxlbWVudD59ICovKHRoaXMuZ2V0Q29udGVudENoaWxkTm9kZXMoc2xjdHIpLmZpbHRlcihmdW5jdGlvbihuKSB7XG4gICAgICAgICAgcmV0dXJuIChuLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSk7XG4gICAgICAgIH0pKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDaGVja3Mgd2hldGhlciBhbiBlbGVtZW50IGlzIGluIHRoaXMgZWxlbWVudCdzIGxpZ2h0IERPTSB0cmVlLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7P05vZGV9IG5vZGUgVGhlIGVsZW1lbnQgdG8gYmUgY2hlY2tlZC5cbiAgICAgICAqIEB0aGlzIHtFbGVtZW50fVxuICAgICAgICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiBub2RlIGlzIGluIHRoaXMgZWxlbWVudCdzIGxpZ2h0IERPTSB0cmVlLlxuICAgICAgICovXG4gICAgICBpc0xpZ2h0RGVzY2VuZGFudChub2RlKSB7XG4gICAgICAgIHJldHVybiB0aGlzICE9PSBub2RlICYmIHRoaXMuY29udGFpbnMobm9kZSkgJiZcbiAgICAgICAgICAgIHRoaXMuZ2V0Um9vdE5vZGUoKSA9PT0gbm9kZS5nZXRSb290Tm9kZSgpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENoZWNrcyB3aGV0aGVyIGFuIGVsZW1lbnQgaXMgaW4gdGhpcyBlbGVtZW50J3MgbG9jYWwgRE9NIHRyZWUuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtFbGVtZW50PX0gbm9kZSBUaGUgZWxlbWVudCB0byBiZSBjaGVja2VkLlxuICAgICAgICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiBub2RlIGlzIGluIHRoaXMgZWxlbWVudCdzIGxvY2FsIERPTSB0cmVlLlxuICAgICAgICovXG4gICAgICBpc0xvY2FsRGVzY2VuZGFudChub2RlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvb3QgPT09IG5vZGUuZ2V0Um9vdE5vZGUoKTtcbiAgICAgIH1cblxuICAgICAgLy8gTk9URTogc2hvdWxkIG5vdyBiZSBoYW5kbGVkIGJ5IFNoYWR5Q3NzIGxpYnJhcnkuXG4gICAgICBzY29wZVN1YnRyZWUoY29udGFpbmVyLCBzaG91bGRPYnNlcnZlKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZXR1cm5zIHRoZSBjb21wdXRlZCBzdHlsZSB2YWx1ZSBmb3IgdGhlIGdpdmVuIHByb3BlcnR5LlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFRoZSBjc3MgcHJvcGVydHkgbmFtZS5cbiAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gUmV0dXJucyB0aGUgY29tcHV0ZWQgY3NzIHByb3BlcnR5IHZhbHVlIGZvciB0aGUgZ2l2ZW5cbiAgICAgICAqIGBwcm9wZXJ0eWAuXG4gICAgICAgKi9cbiAgICAgIGdldENvbXB1dGVkU3R5bGVWYWx1ZShwcm9wZXJ0eSkge1xuICAgICAgICByZXR1cm4gc3R5bGVJbnRlcmZhY2UuZ2V0Q29tcHV0ZWRTdHlsZVZhbHVlKHRoaXMsIHByb3BlcnR5KTtcbiAgICAgIH1cblxuICAgICAgLy8gZGVib3VuY2VcblxuICAgICAgLyoqXG4gICAgICAgKiBDYWxsIGBkZWJvdW5jZWAgdG8gY29sbGFwc2UgbXVsdGlwbGUgcmVxdWVzdHMgZm9yIGEgbmFtZWQgdGFzayBpbnRvXG4gICAgICAgKiBvbmUgaW52b2NhdGlvbiB3aGljaCBpcyBtYWRlIGFmdGVyIHRoZSB3YWl0IHRpbWUgaGFzIGVsYXBzZWQgd2l0aFxuICAgICAgICogbm8gbmV3IHJlcXVlc3QuICBJZiBubyB3YWl0IHRpbWUgaXMgZ2l2ZW4sIHRoZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZFxuICAgICAgICogYXQgbWljcm90YXNrIHRpbWluZyAoZ3VhcmFudGVlZCBiZWZvcmUgcGFpbnQpLlxuICAgICAgICpcbiAgICAgICAqICAgICBkZWJvdW5jZWRDbGlja0FjdGlvbihlKSB7XG4gICAgICAgKiAgICAgICAvLyB3aWxsIG5vdCBjYWxsIGBwcm9jZXNzQ2xpY2tgIG1vcmUgdGhhbiBvbmNlIHBlciAxMDBtc1xuICAgICAgICogICAgICAgdGhpcy5kZWJvdW5jZSgnY2xpY2snLCBmdW5jdGlvbigpIHtcbiAgICAgICAqICAgICAgICB0aGlzLnByb2Nlc3NDbGljaygpO1xuICAgICAgICogICAgICAgfSAxMDApO1xuICAgICAgICogICAgIH1cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gam9iTmFtZSBTdHJpbmcgdG8gaW5kZW50aWZ5IHRoZSBkZWJvdW5jZSBqb2IuXG4gICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCl9IGNhbGxiYWNrIEZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkICh3aXRoIGB0aGlzYFxuICAgICAgICogICBjb250ZXh0KSB3aGVuIHRoZSB3YWl0IHRpbWUgZWxhcHNlcy5cbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3YWl0IE9wdGlvbmFsIHdhaXQgdGltZSBpbiBtaWxsaXNlY29uZHMgKG1zKSBhZnRlciB0aGVcbiAgICAgICAqICAgbGFzdCBzaWduYWwgdGhhdCBtdXN0IGVsYXBzZSBiZWZvcmUgaW52b2tpbmcgYGNhbGxiYWNrYFxuICAgICAgICogQHJldHVybiB7T2JqZWN0fSBSZXR1cm5zIGEgZGVib3VuY2VyIG9iamVjdCBvbiB3aGljaCBleGlzdHMgdGhlXG4gICAgICAgKiBmb2xsb3dpbmcgbWV0aG9kczogYGlzQWN0aXZlKClgIHJldHVybnMgdHJ1ZSBpZiB0aGUgZGVib3VuY2VyIGlzXG4gICAgICAgKiBhY3RpdmU7IGBjYW5jZWwoKWAgY2FuY2VscyB0aGUgZGVib3VuY2VyIGlmIGl0IGlzIGFjdGl2ZTtcbiAgICAgICAqIGBmbHVzaCgpYCBpbW1lZGlhdGVseSBpbnZva2VzIHRoZSBkZWJvdW5jZWQgY2FsbGJhY2sgaWYgdGhlIGRlYm91bmNlclxuICAgICAgICogaXMgYWN0aXZlLlxuICAgICAgICovXG4gICAgICBkZWJvdW5jZShqb2JOYW1lLCBjYWxsYmFjaywgd2FpdCkge1xuICAgICAgICB0aGlzLl9kZWJvdW5jZXJzID0gdGhpcy5fZGVib3VuY2VycyB8fCB7fTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlYm91bmNlcnNbam9iTmFtZV0gPSBQb2x5bWVyLkRlYm91bmNlci5kZWJvdW5jZShcbiAgICAgICAgICAgICAgdGhpcy5fZGVib3VuY2Vyc1tqb2JOYW1lXVxuICAgICAgICAgICAgLCB3YWl0ID4gMCA/IFBvbHltZXIuQXN5bmMudGltZU91dC5hZnRlcih3YWl0KSA6IFBvbHltZXIuQXN5bmMubWljcm9UYXNrXG4gICAgICAgICAgICAsIGNhbGxiYWNrLmJpbmQodGhpcykpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJldHVybnMgd2hldGhlciBhIG5hbWVkIGRlYm91bmNlciBpcyBhY3RpdmUuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGpvYk5hbWUgVGhlIG5hbWUgb2YgdGhlIGRlYm91bmNlciBzdGFydGVkIHdpdGggYGRlYm91bmNlYFxuICAgICAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgZGVib3VuY2VyIGlzIGFjdGl2ZSAoaGFzIG5vdCB5ZXQgZmlyZWQpLlxuICAgICAgICovXG4gICAgICBpc0RlYm91bmNlckFjdGl2ZShqb2JOYW1lKSB7XG4gICAgICAgIHRoaXMuX2RlYm91bmNlcnMgPSB0aGlzLl9kZWJvdW5jZXJzIHx8IHt9O1xuICAgICAgICBsZXQgZGVib3VuY2VyID0gdGhpcy5fZGVib3VuY2Vyc1tqb2JOYW1lXTtcbiAgICAgICAgcmV0dXJuICEhKGRlYm91bmNlciAmJiBkZWJvdW5jZXIuaXNBY3RpdmUoKSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogSW1tZWRpYXRlbHkgY2FsbHMgdGhlIGRlYm91bmNlciBgY2FsbGJhY2tgIGFuZCBpbmFjdGl2YXRlcyBpdC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gam9iTmFtZSBUaGUgbmFtZSBvZiB0aGUgZGVib3VuY2VyIHN0YXJ0ZWQgd2l0aCBgZGVib3VuY2VgXG4gICAgICAgKi9cbiAgICAgIGZsdXNoRGVib3VuY2VyKGpvYk5hbWUpIHtcbiAgICAgICAgdGhpcy5fZGVib3VuY2VycyA9IHRoaXMuX2RlYm91bmNlcnMgfHwge307XG4gICAgICAgIGxldCBkZWJvdW5jZXIgPSB0aGlzLl9kZWJvdW5jZXJzW2pvYk5hbWVdO1xuICAgICAgICBpZiAoZGVib3VuY2VyKSB7XG4gICAgICAgICAgZGVib3VuY2VyLmZsdXNoKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDYW5jZWxzIGFuIGFjdGl2ZSBkZWJvdW5jZXIuICBUaGUgYGNhbGxiYWNrYCB3aWxsIG5vdCBiZSBjYWxsZWQuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGpvYk5hbWUgVGhlIG5hbWUgb2YgdGhlIGRlYm91bmNlciBzdGFydGVkIHdpdGggYGRlYm91bmNlYFxuICAgICAgICovXG4gICAgICBjYW5jZWxEZWJvdW5jZXIoam9iTmFtZSkge1xuICAgICAgICB0aGlzLl9kZWJvdW5jZXJzID0gdGhpcy5fZGVib3VuY2VycyB8fCB7fVxuICAgICAgICBsZXQgZGVib3VuY2VyID0gdGhpcy5fZGVib3VuY2Vyc1tqb2JOYW1lXTtcbiAgICAgICAgaWYgKGRlYm91bmNlcikge1xuICAgICAgICAgIGRlYm91bmNlci5jYW5jZWwoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJ1bnMgYSBjYWxsYmFjayBmdW5jdGlvbiBhc3luY3Jvbm91c2x5LlxuICAgICAgICpcbiAgICAgICAqIEJ5IGRlZmF1bHQgKGlmIG5vIHdhaXRUaW1lIGlzIHNwZWNpZmllZCksIGFzeW5jIGNhbGxiYWNrcyBhcmUgcnVuIGF0XG4gICAgICAgKiBtaWNyb3Rhc2sgdGltaW5nLCB3aGljaCB3aWxsIG9jY3VyIGJlZm9yZSBwYWludC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgY2FsbGJhY2sgZnVuY3Rpb24gdG8gcnVuLCBib3VuZCB0byBgdGhpc2AuXG4gICAgICAgKiBAcGFyYW0ge251bWJlcj19IHdhaXRUaW1lIFRpbWUgdG8gd2FpdCBiZWZvcmUgY2FsbGluZyB0aGVcbiAgICAgICAqICAgYGNhbGxiYWNrYC4gIElmIHVuc3BlY2lmaWVkIG9yIDAsIHRoZSBjYWxsYmFjayB3aWxsIGJlIHJ1biBhdCBtaWNyb3Rhc2tcbiAgICAgICAqICAgdGltaW5nIChiZWZvcmUgcGFpbnQpLlxuICAgICAgICogQHJldHVybiB7bnVtYmVyfSBIYW5kbGUgdGhhdCBtYXkgYmUgdXNlZCB0byBjYW5jZWwgdGhlIGFzeW5jIGpvYi5cbiAgICAgICAqL1xuICAgICAgYXN5bmMoY2FsbGJhY2ssIHdhaXRUaW1lKSB7XG4gICAgICAgIHJldHVybiB3YWl0VGltZSA+IDAgPyBQb2x5bWVyLkFzeW5jLnRpbWVPdXQucnVuKGNhbGxiYWNrLmJpbmQodGhpcyksIHdhaXRUaW1lKSA6XG4gICAgICAgICAgICB+UG9seW1lci5Bc3luYy5taWNyb1Rhc2sucnVuKGNhbGxiYWNrLmJpbmQodGhpcykpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENhbmNlbHMgYW4gYXN5bmMgb3BlcmF0aW9uIHN0YXJ0ZWQgd2l0aCBgYXN5bmNgLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoYW5kbGUgSGFuZGxlIHJldHVybmVkIGZyb20gb3JpZ2luYWwgYGFzeW5jYCBjYWxsIHRvXG4gICAgICAgKiAgIGNhbmNlbC5cbiAgICAgICAqL1xuICAgICAgY2FuY2VsQXN5bmMoaGFuZGxlKSB7XG4gICAgICAgIGhhbmRsZSA8IDAgPyBQb2x5bWVyLkFzeW5jLm1pY3JvVGFzay5jYW5jZWwofmhhbmRsZSkgOlxuICAgICAgICAgICAgUG9seW1lci5Bc3luYy50aW1lT3V0LmNhbmNlbChoYW5kbGUpO1xuICAgICAgfVxuXG4gICAgICAvLyBvdGhlclxuXG4gICAgICAvKipcbiAgICAgICAqIENvbnZlbmllbmNlIG1ldGhvZCBmb3IgY3JlYXRpbmcgYW4gZWxlbWVudCBhbmQgY29uZmlndXJpbmcgaXQuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHRhZyBIVE1MIGVsZW1lbnQgdGFnIHRvIGNyZWF0ZS5cbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBPYmplY3Qgb2YgcHJvcGVydGllcyB0byBjb25maWd1cmUgb24gdGhlXG4gICAgICAgKiAgICBpbnN0YW5jZS5cbiAgICAgICAqIEByZXR1cm4ge0VsZW1lbnR9IE5ld2x5IGNyZWF0ZWQgYW5kIGNvbmZpZ3VyZWQgZWxlbWVudC5cbiAgICAgICAqL1xuICAgICAgY3JlYXRlKHRhZywgcHJvcHMpIHtcbiAgICAgICAgbGV0IGVsdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgICAgaWYgKHByb3BzKSB7XG4gICAgICAgICAgaWYgKGVsdC5zZXRQcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICBlbHQuc2V0UHJvcGVydGllcyhwcm9wcyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvciAobGV0IG4gaW4gcHJvcHMpIHtcbiAgICAgICAgICAgICAgZWx0W25dID0gcHJvcHNbbl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbHQ7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ29udmVuaWVuY2UgbWV0aG9kIGZvciBpbXBvcnRpbmcgYW4gSFRNTCBkb2N1bWVudCBpbXBlcmF0aXZlbHkuXG4gICAgICAgKlxuICAgICAgICogVGhpcyBtZXRob2QgY3JlYXRlcyBhIG5ldyBgPGxpbmsgcmVsPVwiaW1wb3J0XCI+YCBlbGVtZW50IHdpdGhcbiAgICAgICAqIHRoZSBwcm92aWRlZCBVUkwgYW5kIGFwcGVuZHMgaXQgdG8gdGhlIGRvY3VtZW50IHRvIHN0YXJ0IGxvYWRpbmcuXG4gICAgICAgKiBJbiB0aGUgYG9ubG9hZGAgY2FsbGJhY2ssIHRoZSBgaW1wb3J0YCBwcm9wZXJ0eSBvZiB0aGUgYGxpbmtgXG4gICAgICAgKiBlbGVtZW50IHdpbGwgY29udGFpbiB0aGUgaW1wb3J0ZWQgZG9jdW1lbnQgY29udGVudHMuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGhyZWYgVVJMIHRvIGRvY3VtZW50IHRvIGxvYWQuXG4gICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvbmxvYWQgQ2FsbGJhY2sgdG8gbm90aWZ5IHdoZW4gYW4gaW1wb3J0IHN1Y2Nlc3NmdWxseVxuICAgICAgICogICBsb2FkZWQuXG4gICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvbmVycm9yIENhbGxiYWNrIHRvIG5vdGlmeSB3aGVuIGFuIGltcG9ydFxuICAgICAgICogICB1bnN1Y2Nlc3NmdWxseSBsb2FkZWQuXG4gICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IG9wdEFzeW5jIFRydWUgaWYgdGhlIGltcG9ydCBzaG91bGQgYmUgbG9hZGVkIGBhc3luY2AuXG4gICAgICAgKiAgIERlZmF1bHRzIHRvIGBmYWxzZWAuXG4gICAgICAgKiBAcmV0dXJuIHtIVE1MTGlua0VsZW1lbnR9IFRoZSBsaW5rIGVsZW1lbnQgZm9yIHRoZSBVUkwgdG8gYmUgbG9hZGVkLlxuICAgICAgICovXG4gICAgICBpbXBvcnRIcmVmKGhyZWYsIG9ubG9hZCwgb25lcnJvciwgb3B0QXN5bmMpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgICBsZXQgbG9hZEZuID0gb25sb2FkID8gb25sb2FkLmJpbmQodGhpcykgOiBudWxsO1xuICAgICAgICBsZXQgZXJyb3JGbiA9IG9uZXJyb3IgPyBvbmVycm9yLmJpbmQodGhpcykgOiBudWxsO1xuICAgICAgICByZXR1cm4gUG9seW1lci5pbXBvcnRIcmVmKGhyZWYsIGxvYWRGbiwgZXJyb3JGbiwgb3B0QXN5bmMpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFBvbHlmaWxsIGZvciBFbGVtZW50LnByb3RvdHlwZS5tYXRjaGVzLCB3aGljaCBpcyBzb21ldGltZXMgc3RpbGxcbiAgICAgICAqIHByZWZpeGVkLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzZWxlY3RvciBTZWxlY3RvciB0byB0ZXN0LlxuICAgICAgICogQHBhcmFtIHtFbGVtZW50PX0gbm9kZSBFbGVtZW50IHRvIHRlc3QgdGhlIHNlbGVjdG9yIGFnYWluc3QuXG4gICAgICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBlbGVtZW50IG1hdGNoZXMgdGhlIHNlbGVjdG9yLlxuICAgICAgICovXG4gICAgICBlbGVtZW50TWF0Y2hlcyhzZWxlY3Rvciwgbm9kZSkge1xuICAgICAgICByZXR1cm4gUG9seW1lci5kb20ubWF0Y2hlc1NlbGVjdG9yKC8qKiBAdHlwZSB7IUVsZW1lbnR9ICovIChub2RlIHx8IHRoaXMpLCBzZWxlY3Rvcik7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogVG9nZ2xlcyBhbiBIVE1MIGF0dHJpYnV0ZSBvbiBvciBvZmYuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgSFRNTCBhdHRyaWJ1dGUgbmFtZVxuICAgICAgICogQHBhcmFtIHtib29sZWFuPX0gYm9vbCBCb29sZWFuIHRvIGZvcmNlIHRoZSBhdHRyaWJ1dGUgb24gb3Igb2ZmLlxuICAgICAgICogICAgV2hlbiB1bnNwZWNpZmllZCwgdGhlIHN0YXRlIG9mIHRoZSBhdHRyaWJ1dGUgd2lsbCBiZSByZXZlcnNlZC5cbiAgICAgICAqIEBwYXJhbSB7RWxlbWVudD19IG5vZGUgTm9kZSB0byB0YXJnZXQuICBEZWZhdWx0cyB0byBgdGhpc2AuXG4gICAgICAgKi9cbiAgICAgIHRvZ2dsZUF0dHJpYnV0ZShuYW1lLCBib29sLCBub2RlKSB7XG4gICAgICAgIG5vZGUgPSAvKiogQHR5cGUge0VsZW1lbnR9ICovIChub2RlIHx8IHRoaXMpO1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgYm9vbCA9ICFub2RlLmhhc0F0dHJpYnV0ZShuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYm9vbCkge1xuICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKG5hbWUsICcnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG5cbiAgICAgIC8qKlxuICAgICAgICogVG9nZ2xlcyBhIENTUyBjbGFzcyBvbiBvciBvZmYuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgQ1NTIGNsYXNzIG5hbWVcbiAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IGJvb2wgQm9vbGVhbiB0byBmb3JjZSB0aGUgY2xhc3Mgb24gb3Igb2ZmLlxuICAgICAgICogICAgV2hlbiB1bnNwZWNpZmllZCwgdGhlIHN0YXRlIG9mIHRoZSBjbGFzcyB3aWxsIGJlIHJldmVyc2VkLlxuICAgICAgICogQHBhcmFtIHtFbGVtZW50PX0gbm9kZSBOb2RlIHRvIHRhcmdldC4gIERlZmF1bHRzIHRvIGB0aGlzYC5cbiAgICAgICAqL1xuICAgICAgdG9nZ2xlQ2xhc3MobmFtZSwgYm9vbCwgbm9kZSkge1xuICAgICAgICBub2RlID0gLyoqIEB0eXBlIHtFbGVtZW50fSAqLyAobm9kZSB8fCB0aGlzKTtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMSkge1xuICAgICAgICAgIGJvb2wgPSAhbm9kZS5jbGFzc0xpc3QuY29udGFpbnMobmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJvb2wpIHtcbiAgICAgICAgICBub2RlLmNsYXNzTGlzdC5hZGQobmFtZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9kZS5jbGFzc0xpc3QucmVtb3ZlKG5hbWUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ3Jvc3MtcGxhdGZvcm0gaGVscGVyIGZvciBzZXR0aW5nIGFuIGVsZW1lbnQncyBDU1MgYHRyYW5zZm9ybWAgcHJvcGVydHkuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHRyYW5zZm9ybVRleHQgVHJhbnNmb3JtIHNldHRpbmcuXG4gICAgICAgKiBAcGFyYW0ge0VsZW1lbnQ9fSBub2RlIEVsZW1lbnQgdG8gYXBwbHkgdGhlIHRyYW5zZm9ybSB0by5cbiAgICAgICAqIERlZmF1bHRzIHRvIGB0aGlzYFxuICAgICAgICovXG4gICAgICB0cmFuc2Zvcm0odHJhbnNmb3JtVGV4dCwgbm9kZSkge1xuICAgICAgICBub2RlID0gLyoqIEB0eXBlIHtFbGVtZW50fSAqLyAobm9kZSB8fCB0aGlzKTtcbiAgICAgICAgbm9kZS5zdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSB0cmFuc2Zvcm1UZXh0O1xuICAgICAgICBub2RlLnN0eWxlLnRyYW5zZm9ybSA9IHRyYW5zZm9ybVRleHQ7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ3Jvc3MtcGxhdGZvcm0gaGVscGVyIGZvciBzZXR0aW5nIGFuIGVsZW1lbnQncyBDU1MgYHRyYW5zbGF0ZTNkYFxuICAgICAgICogcHJvcGVydHkuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHggWCBvZmZzZXQuXG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0geSBZIG9mZnNldC5cbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB6IFogb2Zmc2V0LlxuICAgICAgICogQHBhcmFtIHtFbGVtZW50PX0gbm9kZSBFbGVtZW50IHRvIGFwcGx5IHRoZSB0cmFuc2Zvcm0gdG8uXG4gICAgICAgKiBEZWZhdWx0cyB0byBgdGhpc2AuXG4gICAgICAgKi9cbiAgICAgIHRyYW5zbGF0ZTNkKHgsIHksIHosIG5vZGUpIHtcbiAgICAgICAgbm9kZSA9IC8qKiBAdHlwZSB7RWxlbWVudH0gKi8gKG5vZGUgfHwgdGhpcyk7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtKCd0cmFuc2xhdGUzZCgnICsgeCArICcsJyArIHkgKyAnLCcgKyB6ICsgJyknLCBub2RlKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZW1vdmVzIGFuIGl0ZW0gZnJvbSBhbiBhcnJheSwgaWYgaXQgZXhpc3RzLlxuICAgICAgICpcbiAgICAgICAqIElmIHRoZSBhcnJheSBpcyBzcGVjaWZpZWQgYnkgcGF0aCwgYSBjaGFuZ2Ugbm90aWZpY2F0aW9uIGlzXG4gICAgICAgKiBnZW5lcmF0ZWQsIHNvIHRoYXQgb2JzZXJ2ZXJzLCBkYXRhIGJpbmRpbmdzIGFuZCBjb21wdXRlZFxuICAgICAgICogcHJvcGVydGllcyB3YXRjaGluZyB0aGF0IHBhdGggY2FuIHVwZGF0ZS5cbiAgICAgICAqXG4gICAgICAgKiBJZiB0aGUgYXJyYXkgaXMgcGFzc2VkIGRpcmVjdGx5LCAqKm5vIGNoYW5nZVxuICAgICAgICogbm90aWZpY2F0aW9uIGlzIGdlbmVyYXRlZCoqLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgIUFycmF5PG51bWJlcnxzdHJpbmc+fSBhcnJheU9yUGF0aCBQYXRoIHRvIGFycmF5IGZyb20gd2hpY2ggdG8gcmVtb3ZlIHRoZSBpdGVtXG4gICAgICAgKiAgIChvciB0aGUgYXJyYXkgaXRzZWxmKS5cbiAgICAgICAqIEBwYXJhbSB7Kn0gaXRlbSBJdGVtIHRvIHJlbW92ZS5cbiAgICAgICAqIEByZXR1cm4ge0FycmF5fSBBcnJheSBjb250YWluaW5nIGl0ZW0gcmVtb3ZlZC5cbiAgICAgICAqL1xuICAgICAgYXJyYXlEZWxldGUoYXJyYXlPclBhdGgsIGl0ZW0pIHtcbiAgICAgICAgbGV0IGluZGV4O1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhcnJheU9yUGF0aCkpIHtcbiAgICAgICAgICBpbmRleCA9IGFycmF5T3JQYXRoLmluZGV4T2YoaXRlbSk7XG4gICAgICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgICAgIHJldHVybiBhcnJheU9yUGF0aC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsZXQgYXJyID0gUG9seW1lci5QYXRoLmdldCh0aGlzLCBhcnJheU9yUGF0aCk7XG4gICAgICAgICAgaW5kZXggPSBhcnIuaW5kZXhPZihpdGVtKTtcbiAgICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3BsaWNlKGFycmF5T3JQYXRoLCBpbmRleCwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICAvLyBsb2dnaW5nXG5cbiAgICAgIC8qKlxuICAgICAgICogRmFjYWRlcyBgY29uc29sZS5sb2dgL2B3YXJuYC9gZXJyb3JgIGFzIG92ZXJyaWRlIHBvaW50LlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsZXZlbCBPbmUgb2YgJ2xvZycsICd3YXJuJywgJ2Vycm9yJ1xuICAgICAgICogQHBhcmFtIHtBcnJheX0gYXJncyBBcnJheSBvZiBzdHJpbmdzIG9yIG9iamVjdHMgdG8gbG9nXG4gICAgICAgKi9cbiAgICAgIF9sb2dnZXIobGV2ZWwsIGFyZ3MpIHtcbiAgICAgICAgLy8gYWNjZXB0IFsnZm9vJywgJ2JhciddIGFuZCBbWydmb28nLCAnYmFyJ11dXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFyZ3MpICYmIGFyZ3MubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgYXJncyA9IGFyZ3NbMF07XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoKGxldmVsKSB7XG4gICAgICAgICAgY2FzZSAnbG9nJzpcbiAgICAgICAgICBjYXNlICd3YXJuJzpcbiAgICAgICAgICBjYXNlICdlcnJvcic6XG4gICAgICAgICAgICBjb25zb2xlW2xldmVsXSguLi5hcmdzKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEZhY2FkZXMgYGNvbnNvbGUubG9nYCBhcyBhbiBvdmVycmlkZSBwb2ludC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0gey4uLip9IGFyZ3MgQXJyYXkgb2Ygc3RyaW5ncyBvciBvYmplY3RzIHRvIGxvZ1xuICAgICAgICovXG4gICAgICBfbG9nKC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5fbG9nZ2VyKCdsb2cnLCBhcmdzKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBGYWNhZGVzIGBjb25zb2xlLndhcm5gIGFzIGFuIG92ZXJyaWRlIHBvaW50LlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7Li4uKn0gYXJncyBBcnJheSBvZiBzdHJpbmdzIG9yIG9iamVjdHMgdG8gbG9nXG4gICAgICAgKi9cbiAgICAgIF93YXJuKC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5fbG9nZ2VyKCd3YXJuJywgYXJncyk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogRmFjYWRlcyBgY29uc29sZS5lcnJvcmAgYXMgYW4gb3ZlcnJpZGUgcG9pbnQuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHsuLi4qfSBhcmdzIEFycmF5IG9mIHN0cmluZ3Mgb3Igb2JqZWN0cyB0byBsb2dcbiAgICAgICAqL1xuICAgICAgX2Vycm9yKC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5fbG9nZ2VyKCdlcnJvcicsIGFyZ3MpXG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogRm9ybWF0cyBhIG1lc3NhZ2UgdXNpbmcgdGhlIGVsZW1lbnQgdHlwZSBhbiBhIG1ldGhvZCBuYW1lLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2ROYW1lIE1ldGhvZCBuYW1lIHRvIGFzc29jaWF0ZSB3aXRoIG1lc3NhZ2VcbiAgICAgICAqIEBwYXJhbSB7Li4uKn0gYXJncyBBcnJheSBvZiBzdHJpbmdzIG9yIG9iamVjdHMgdG8gbG9nXG4gICAgICAgKiBAcmV0dXJuIHtBcnJheX0gQXJyYXkgd2l0aCBmb3JtYXR0aW5nIGluZm9ybWF0aW9uIGZvciBgY29uc29sZWBcbiAgICAgICAqICAgbG9nZ2luZy5cbiAgICAgICAqL1xuICAgICAgX2xvZ2YobWV0aG9kTmFtZSwgLi4uYXJncykge1xuICAgICAgICByZXR1cm4gWydbJXM6OiVzXScsIHRoaXMuaXMsIG1ldGhvZE5hbWUsIC4uLmFyZ3NdO1xuICAgICAgfVxuXG4gICAgfVxuXG4gICAgTGVnYWN5RWxlbWVudC5wcm90b3R5cGUuaXMgPSAnJztcblxuICAgIHJldHVybiBMZWdhY3lFbGVtZW50O1xuXG4gIH0pO1xuXG59KSgpO1xuPC9zY3JpcHQ+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL3BvbHltZXIvbGliL2xlZ2FjeS9sZWdhY3ktZWxlbWVudC1taXhpbi5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3V0aWxzL2Jvb3QuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3V0aWxzL21peGluLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi91dGlscy9nZXN0dXJlcy5odG1sXCI+XG5cbjxzY3JpcHQ+XG4oZnVuY3Rpb24oKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8qKlxuICAgKiBAY29uc3Qge1BvbHltZXIuR2VzdHVyZXN9XG4gICAqL1xuICBjb25zdCBnZXN0dXJlcyA9IFBvbHltZXIuR2VzdHVyZXM7XG5cbiAgLyoqXG4gICAqIEVsZW1lbnQgY2xhc3MgbWl4aW4gdGhhdCBwcm92aWRlcyBBUEkgZm9yIGFkZGluZyBQb2x5bWVyJ3MgY3Jvc3MtcGxhdGZvcm1cbiAgICogZ2VzdHVyZSBldmVudHMgdG8gbm9kZXMuXG4gICAqXG4gICAqIFRoZSBBUEkgaXMgZGVzaWduZWQgdG8gYmUgY29tcGF0aWJsZSB3aXRoIG92ZXJyaWRlIHBvaW50cyBpbXBsZW1lbnRlZFxuICAgKiBpbiBgUG9seW1lci5UZW1wbGF0ZVN0YW1wYCBzdWNoIHRoYXQgZGVjbGFyYXRpdmUgZXZlbnQgbGlzdGVuZXJzIGluXG4gICAqIHRlbXBsYXRlcyB3aWxsIHN1cHBvcnQgZ2VzdHVyZSBldmVudHMgd2hlbiB0aGlzIG1peGluIGlzIGFwcGxpZWQgYWxvbmcgd2l0aFxuICAgKiBgUG9seW1lci5UZW1wbGF0ZVN0YW1wYC5cbiAgICpcbiAgICogQG1peGluRnVuY3Rpb25cbiAgICogQHBvbHltZXJcbiAgICogQG1lbWJlcm9mIFBvbHltZXJcbiAgICogQHN1bW1hcnkgRWxlbWVudCBjbGFzcyBtaXhpbiB0aGF0IHByb3ZpZGVzIEFQSSBmb3IgYWRkaW5nIFBvbHltZXIncyBjcm9zcy1wbGF0Zm9ybVxuICAgKiBnZXN0dXJlIGV2ZW50cyB0byBub2Rlc1xuICAgKi9cbiAgUG9seW1lci5HZXN0dXJlRXZlbnRMaXN0ZW5lcnMgPSBQb2x5bWVyLmRlZHVwaW5nTWl4aW4oc3VwZXJDbGFzcyA9PiB7XG5cbiAgICAvKipcbiAgICAgKiBAcG9seW1lclxuICAgICAqIEBtaXhpbkNsYXNzXG4gICAgICogQGltcGxlbWVudHMge1BvbHltZXJfR2VzdHVyZUV2ZW50TGlzdGVuZXJzfVxuICAgICAqL1xuICAgIGNsYXNzIEdlc3R1cmVFdmVudExpc3RlbmVycyBleHRlbmRzIHN1cGVyQ2xhc3Mge1xuXG4gICAgICBfYWRkRXZlbnRMaXN0ZW5lclRvTm9kZShub2RlLCBldmVudE5hbWUsIGhhbmRsZXIpIHtcbiAgICAgICAgaWYgKCFnZXN0dXJlcy5hZGRMaXN0ZW5lcihub2RlLCBldmVudE5hbWUsIGhhbmRsZXIpKSB7XG4gICAgICAgICAgc3VwZXIuX2FkZEV2ZW50TGlzdGVuZXJUb05vZGUobm9kZSwgZXZlbnROYW1lLCBoYW5kbGVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBfcmVtb3ZlRXZlbnRMaXN0ZW5lckZyb21Ob2RlKG5vZGUsIGV2ZW50TmFtZSwgaGFuZGxlcikge1xuICAgICAgICBpZiAoIWdlc3R1cmVzLnJlbW92ZUxpc3RlbmVyKG5vZGUsIGV2ZW50TmFtZSwgaGFuZGxlcikpIHtcbiAgICAgICAgICBzdXBlci5fcmVtb3ZlRXZlbnRMaXN0ZW5lckZyb21Ob2RlKG5vZGUsIGV2ZW50TmFtZSwgaGFuZGxlcik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgIH1cblxuICAgIHJldHVybiBHZXN0dXJlRXZlbnRMaXN0ZW5lcnM7XG5cbiAgfSk7XG5cbn0pKCk7XG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvbWl4aW5zL2dlc3R1cmUtZXZlbnQtbGlzdGVuZXJzLmh0bWwiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiYm9vdC5odG1sXCI+XG48c2NyaXB0PlxuKGZ1bmN0aW9uKCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICBmdW5jdGlvbiBuZXdTcGxpY2UoaW5kZXgsIHJlbW92ZWQsIGFkZGVkQ291bnQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgcmVtb3ZlZDogcmVtb3ZlZCxcbiAgICAgIGFkZGVkQ291bnQ6IGFkZGVkQ291bnRcbiAgICB9O1xuICB9XG5cbiAgY29uc3QgRURJVF9MRUFWRSA9IDA7XG4gIGNvbnN0IEVESVRfVVBEQVRFID0gMTtcbiAgY29uc3QgRURJVF9BREQgPSAyO1xuICBjb25zdCBFRElUX0RFTEVURSA9IDM7XG5cbiAgLy8gTm90ZTogVGhpcyBmdW5jdGlvbiBpcyAqYmFzZWQqIG9uIHRoZSBjb21wdXRhdGlvbiBvZiB0aGUgTGV2ZW5zaHRlaW5cbiAgLy8gXCJlZGl0XCIgZGlzdGFuY2UuIFRoZSBvbmUgY2hhbmdlIGlzIHRoYXQgXCJ1cGRhdGVzXCIgYXJlIHRyZWF0ZWQgYXMgdHdvXG4gIC8vIGVkaXRzIC0gbm90IG9uZS4gV2l0aCBBcnJheSBzcGxpY2VzLCBhbiB1cGRhdGUgaXMgcmVhbGx5IGEgZGVsZXRlXG4gIC8vIGZvbGxvd2VkIGJ5IGFuIGFkZC4gQnkgcmV0YWluaW5nIHRoaXMsIHdlIG9wdGltaXplIGZvciBcImtlZXBpbmdcIiB0aGVcbiAgLy8gbWF4aW11bSBhcnJheSBpdGVtcyBpbiB0aGUgb3JpZ2luYWwgYXJyYXkuIEZvciBleGFtcGxlOlxuICAvL1xuICAvLyAgICd4eHh4MTIzJyAtPiAnMTIzeXl5eSdcbiAgLy9cbiAgLy8gV2l0aCAxLWVkaXQgdXBkYXRlcywgdGhlIHNob3J0ZXN0IHBhdGggd291bGQgYmUganVzdCB0byB1cGRhdGUgYWxsIHNldmVuXG4gIC8vIGNoYXJhY3RlcnMuIFdpdGggMi1lZGl0IHVwZGF0ZXMsIHdlIGRlbGV0ZSA0LCBsZWF2ZSAzLCBhbmQgYWRkIDQuIFRoaXNcbiAgLy8gbGVhdmVzIHRoZSBzdWJzdHJpbmcgJzEyMycgaW50YWN0LlxuICBmdW5jdGlvbiBjYWxjRWRpdERpc3RhbmNlcyhjdXJyZW50LCBjdXJyZW50U3RhcnQsIGN1cnJlbnRFbmQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbGQsIG9sZFN0YXJ0LCBvbGRFbmQpIHtcbiAgICAvLyBcIkRlbGV0aW9uXCIgY29sdW1uc1xuICAgIGxldCByb3dDb3VudCA9IG9sZEVuZCAtIG9sZFN0YXJ0ICsgMTtcbiAgICBsZXQgY29sdW1uQ291bnQgPSBjdXJyZW50RW5kIC0gY3VycmVudFN0YXJ0ICsgMTtcbiAgICBsZXQgZGlzdGFuY2VzID0gbmV3IEFycmF5KHJvd0NvdW50KTtcblxuICAgIC8vIFwiQWRkaXRpb25cIiByb3dzLiBJbml0aWFsaXplIG51bGwgY29sdW1uLlxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcm93Q291bnQ7IGkrKykge1xuICAgICAgZGlzdGFuY2VzW2ldID0gbmV3IEFycmF5KGNvbHVtbkNvdW50KTtcbiAgICAgIGRpc3RhbmNlc1tpXVswXSA9IGk7XG4gICAgfVxuXG4gICAgLy8gSW5pdGlhbGl6ZSBudWxsIHJvd1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgY29sdW1uQ291bnQ7IGorKylcbiAgICAgIGRpc3RhbmNlc1swXVtqXSA9IGo7XG5cbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IHJvd0NvdW50OyBpKyspIHtcbiAgICAgIGZvciAobGV0IGogPSAxOyBqIDwgY29sdW1uQ291bnQ7IGorKykge1xuICAgICAgICBpZiAoZXF1YWxzKGN1cnJlbnRbY3VycmVudFN0YXJ0ICsgaiAtIDFdLCBvbGRbb2xkU3RhcnQgKyBpIC0gMV0pKVxuICAgICAgICAgIGRpc3RhbmNlc1tpXVtqXSA9IGRpc3RhbmNlc1tpIC0gMV1baiAtIDFdO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBsZXQgbm9ydGggPSBkaXN0YW5jZXNbaSAtIDFdW2pdICsgMTtcbiAgICAgICAgICBsZXQgd2VzdCA9IGRpc3RhbmNlc1tpXVtqIC0gMV0gKyAxO1xuICAgICAgICAgIGRpc3RhbmNlc1tpXVtqXSA9IG5vcnRoIDwgd2VzdCA/IG5vcnRoIDogd2VzdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBkaXN0YW5jZXM7XG4gIH1cblxuICAvLyBUaGlzIHN0YXJ0cyBhdCB0aGUgZmluYWwgd2VpZ2h0LCBhbmQgd2Fsa3MgXCJiYWNrd2FyZFwiIGJ5IGZpbmRpbmdcbiAgLy8gdGhlIG1pbmltdW0gcHJldmlvdXMgd2VpZ2h0IHJlY3Vyc2l2ZWx5IHVudGlsIHRoZSBvcmlnaW4gb2YgdGhlIHdlaWdodFxuICAvLyBtYXRyaXguXG4gIGZ1bmN0aW9uIHNwbGljZU9wZXJhdGlvbnNGcm9tRWRpdERpc3RhbmNlcyhkaXN0YW5jZXMpIHtcbiAgICBsZXQgaSA9IGRpc3RhbmNlcy5sZW5ndGggLSAxO1xuICAgIGxldCBqID0gZGlzdGFuY2VzWzBdLmxlbmd0aCAtIDE7XG4gICAgbGV0IGN1cnJlbnQgPSBkaXN0YW5jZXNbaV1bal07XG4gICAgbGV0IGVkaXRzID0gW107XG4gICAgd2hpbGUgKGkgPiAwIHx8IGogPiAwKSB7XG4gICAgICBpZiAoaSA9PSAwKSB7XG4gICAgICAgIGVkaXRzLnB1c2goRURJVF9BREQpO1xuICAgICAgICBqLS07XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKGogPT0gMCkge1xuICAgICAgICBlZGl0cy5wdXNoKEVESVRfREVMRVRFKTtcbiAgICAgICAgaS0tO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGxldCBub3J0aFdlc3QgPSBkaXN0YW5jZXNbaSAtIDFdW2ogLSAxXTtcbiAgICAgIGxldCB3ZXN0ID0gZGlzdGFuY2VzW2kgLSAxXVtqXTtcbiAgICAgIGxldCBub3J0aCA9IGRpc3RhbmNlc1tpXVtqIC0gMV07XG5cbiAgICAgIGxldCBtaW47XG4gICAgICBpZiAod2VzdCA8IG5vcnRoKVxuICAgICAgICBtaW4gPSB3ZXN0IDwgbm9ydGhXZXN0ID8gd2VzdCA6IG5vcnRoV2VzdDtcbiAgICAgIGVsc2VcbiAgICAgICAgbWluID0gbm9ydGggPCBub3J0aFdlc3QgPyBub3J0aCA6IG5vcnRoV2VzdDtcblxuICAgICAgaWYgKG1pbiA9PSBub3J0aFdlc3QpIHtcbiAgICAgICAgaWYgKG5vcnRoV2VzdCA9PSBjdXJyZW50KSB7XG4gICAgICAgICAgZWRpdHMucHVzaChFRElUX0xFQVZFKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlZGl0cy5wdXNoKEVESVRfVVBEQVRFKTtcbiAgICAgICAgICBjdXJyZW50ID0gbm9ydGhXZXN0O1xuICAgICAgICB9XG4gICAgICAgIGktLTtcbiAgICAgICAgai0tO1xuICAgICAgfSBlbHNlIGlmIChtaW4gPT0gd2VzdCkge1xuICAgICAgICBlZGl0cy5wdXNoKEVESVRfREVMRVRFKTtcbiAgICAgICAgaS0tO1xuICAgICAgICBjdXJyZW50ID0gd2VzdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVkaXRzLnB1c2goRURJVF9BREQpO1xuICAgICAgICBqLS07XG4gICAgICAgIGN1cnJlbnQgPSBub3J0aDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBlZGl0cy5yZXZlcnNlKCk7XG4gICAgcmV0dXJuIGVkaXRzO1xuICB9XG5cbiAgLyoqXG4gICAqIFNwbGljZSBQcm9qZWN0aW9uIGZ1bmN0aW9uczpcbiAgICpcbiAgICogQSBzcGxpY2UgbWFwIGlzIGEgcmVwcmVzZW50YXRpb24gb2YgaG93IGEgcHJldmlvdXMgYXJyYXkgb2YgaXRlbXNcbiAgICogd2FzIHRyYW5zZm9ybWVkIGludG8gYSBuZXcgYXJyYXkgb2YgaXRlbXMuIENvbmNlcHR1YWxseSBpdCBpcyBhIGxpc3Qgb2ZcbiAgICogdHVwbGVzIG9mXG4gICAqXG4gICAqICAgPGluZGV4LCByZW1vdmVkLCBhZGRlZENvdW50PlxuICAgKlxuICAgKiB3aGljaCBhcmUga2VwdCBpbiBhc2NlbmRpbmcgaW5kZXggb3JkZXIgb2YuIFRoZSB0dXBsZSByZXByZXNlbnRzIHRoYXQgYXRcbiAgICogdGhlIHxpbmRleHwsIHxyZW1vdmVkfCBzZXF1ZW5jZSBvZiBpdGVtcyB3ZXJlIHJlbW92ZWQsIGFuZCBjb3VudGluZyBmb3J3YXJkXG4gICAqIGZyb20gfGluZGV4fCwgfGFkZGVkQ291bnR8IGl0ZW1zIHdlcmUgYWRkZWQuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBMYWNraW5nIGluZGl2aWR1YWwgc3BsaWNlIG11dGF0aW9uIGluZm9ybWF0aW9uLCB0aGUgbWluaW1hbCBzZXQgb2ZcbiAgICogc3BsaWNlcyBjYW4gYmUgc3ludGhlc2l6ZWQgZ2l2ZW4gdGhlIHByZXZpb3VzIHN0YXRlIGFuZCBmaW5hbCBzdGF0ZSBvZiBhblxuICAgKiBhcnJheS4gVGhlIGJhc2ljIGFwcHJvYWNoIGlzIHRvIGNhbGN1bGF0ZSB0aGUgZWRpdCBkaXN0YW5jZSBtYXRyaXggYW5kXG4gICAqIGNob29zZSB0aGUgc2hvcnRlc3QgcGF0aCB0aHJvdWdoIGl0LlxuICAgKlxuICAgKiBDb21wbGV4aXR5OiBPKGwgKiBwKVxuICAgKiAgIGw6IFRoZSBsZW5ndGggb2YgdGhlIGN1cnJlbnQgYXJyYXlcbiAgICogICBwOiBUaGUgbGVuZ3RoIG9mIHRoZSBvbGQgYXJyYXlcbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gY3VycmVudCBUaGUgY3VycmVudCBcImNoYW5nZWRcIiBhcnJheSBmb3Igd2hpY2ggdG9cbiAgICogY2FsY3VsYXRlIHNwbGljZXMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjdXJyZW50U3RhcnQgU3RhcnRpbmcgaW5kZXggaW4gdGhlIGBjdXJyZW50YCBhcnJheSBmb3JcbiAgICogd2hpY2ggc3BsaWNlcyBhcmUgY2FsY3VsYXRlZC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGN1cnJlbnRFbmQgRW5kaW5nIGluZGV4IGluIHRoZSBgY3VycmVudGAgYXJyYXkgZm9yXG4gICAqIHdoaWNoIHNwbGljZXMgYXJlIGNhbGN1bGF0ZWQuXG4gICAqIEBwYXJhbSB7QXJyYXl9IG9sZCBUaGUgb3JpZ2luYWwgXCJ1bmNoYW5nZWRcIiBhcnJheSB0byBjb21wYXJlIGBjdXJyZW50YFxuICAgKiBhZ2FpbnN0IHRvIGRldGVybWluZSBzcGxpY2VzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gb2xkU3RhcnQgU3RhcnRpbmcgaW5kZXggaW4gdGhlIGBvbGRgIGFycmF5IGZvclxuICAgKiB3aGljaCBzcGxpY2VzIGFyZSBjYWxjdWxhdGVkLlxuICAgKiBAcGFyYW0ge251bWJlcn0gb2xkRW5kIEVuZGluZyBpbmRleCBpbiB0aGUgYG9sZGAgYXJyYXkgZm9yXG4gICAqIHdoaWNoIHNwbGljZXMgYXJlIGNhbGN1bGF0ZWQuXG4gICAqIEByZXR1cm4ge0FycmF5fSBSZXR1cm5zIGFuIGFycmF5IG9mIHNwbGljZSByZWNvcmQgb2JqZWN0cy4gRWFjaCBvZiB0aGVzZVxuICAgKiBjb250YWluczogYGluZGV4YCB0aGUgbG9jYXRpb24gd2hlcmUgdGhlIHNwbGljZSBvY2N1cnJlZDsgYHJlbW92ZWRgXG4gICAqIHRoZSBhcnJheSBvZiByZW1vdmVkIGl0ZW1zIGZyb20gdGhpcyBsb2NhdGlvbjsgYGFkZGVkQ291bnRgIHRoZSBudW1iZXJcbiAgICogb2YgaXRlbXMgYWRkZWQgYXQgdGhpcyBsb2NhdGlvbi5cbiAgICovXG4gIGZ1bmN0aW9uIGNhbGNTcGxpY2VzKGN1cnJlbnQsIGN1cnJlbnRTdGFydCwgY3VycmVudEVuZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9sZCwgb2xkU3RhcnQsIG9sZEVuZCkge1xuICAgIGxldCBwcmVmaXhDb3VudCA9IDA7XG4gICAgbGV0IHN1ZmZpeENvdW50ID0gMDtcbiAgICBsZXQgc3BsaWNlO1xuXG4gICAgbGV0IG1pbkxlbmd0aCA9IE1hdGgubWluKGN1cnJlbnRFbmQgLSBjdXJyZW50U3RhcnQsIG9sZEVuZCAtIG9sZFN0YXJ0KTtcbiAgICBpZiAoY3VycmVudFN0YXJ0ID09IDAgJiYgb2xkU3RhcnQgPT0gMClcbiAgICAgIHByZWZpeENvdW50ID0gc2hhcmVkUHJlZml4KGN1cnJlbnQsIG9sZCwgbWluTGVuZ3RoKTtcblxuICAgIGlmIChjdXJyZW50RW5kID09IGN1cnJlbnQubGVuZ3RoICYmIG9sZEVuZCA9PSBvbGQubGVuZ3RoKVxuICAgICAgc3VmZml4Q291bnQgPSBzaGFyZWRTdWZmaXgoY3VycmVudCwgb2xkLCBtaW5MZW5ndGggLSBwcmVmaXhDb3VudCk7XG5cbiAgICBjdXJyZW50U3RhcnQgKz0gcHJlZml4Q291bnQ7XG4gICAgb2xkU3RhcnQgKz0gcHJlZml4Q291bnQ7XG4gICAgY3VycmVudEVuZCAtPSBzdWZmaXhDb3VudDtcbiAgICBvbGRFbmQgLT0gc3VmZml4Q291bnQ7XG5cbiAgICBpZiAoY3VycmVudEVuZCAtIGN1cnJlbnRTdGFydCA9PSAwICYmIG9sZEVuZCAtIG9sZFN0YXJ0ID09IDApXG4gICAgICByZXR1cm4gW107XG5cbiAgICBpZiAoY3VycmVudFN0YXJ0ID09IGN1cnJlbnRFbmQpIHtcbiAgICAgIHNwbGljZSA9IG5ld1NwbGljZShjdXJyZW50U3RhcnQsIFtdLCAwKTtcbiAgICAgIHdoaWxlIChvbGRTdGFydCA8IG9sZEVuZClcbiAgICAgICAgc3BsaWNlLnJlbW92ZWQucHVzaChvbGRbb2xkU3RhcnQrK10pO1xuXG4gICAgICByZXR1cm4gWyBzcGxpY2UgXTtcbiAgICB9IGVsc2UgaWYgKG9sZFN0YXJ0ID09IG9sZEVuZClcbiAgICAgIHJldHVybiBbIG5ld1NwbGljZShjdXJyZW50U3RhcnQsIFtdLCBjdXJyZW50RW5kIC0gY3VycmVudFN0YXJ0KSBdO1xuXG4gICAgbGV0IG9wcyA9IHNwbGljZU9wZXJhdGlvbnNGcm9tRWRpdERpc3RhbmNlcyhcbiAgICAgICAgY2FsY0VkaXREaXN0YW5jZXMoY3VycmVudCwgY3VycmVudFN0YXJ0LCBjdXJyZW50RW5kLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9sZCwgb2xkU3RhcnQsIG9sZEVuZCkpO1xuXG4gICAgc3BsaWNlID0gdW5kZWZpbmVkO1xuICAgIGxldCBzcGxpY2VzID0gW107XG4gICAgbGV0IGluZGV4ID0gY3VycmVudFN0YXJ0O1xuICAgIGxldCBvbGRJbmRleCA9IG9sZFN0YXJ0O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBzd2l0Y2gob3BzW2ldKSB7XG4gICAgICAgIGNhc2UgRURJVF9MRUFWRTpcbiAgICAgICAgICBpZiAoc3BsaWNlKSB7XG4gICAgICAgICAgICBzcGxpY2VzLnB1c2goc3BsaWNlKTtcbiAgICAgICAgICAgIHNwbGljZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpbmRleCsrO1xuICAgICAgICAgIG9sZEluZGV4Kys7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgRURJVF9VUERBVEU6XG4gICAgICAgICAgaWYgKCFzcGxpY2UpXG4gICAgICAgICAgICBzcGxpY2UgPSBuZXdTcGxpY2UoaW5kZXgsIFtdLCAwKTtcblxuICAgICAgICAgIHNwbGljZS5hZGRlZENvdW50Kys7XG4gICAgICAgICAgaW5kZXgrKztcblxuICAgICAgICAgIHNwbGljZS5yZW1vdmVkLnB1c2gob2xkW29sZEluZGV4XSk7XG4gICAgICAgICAgb2xkSW5kZXgrKztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBFRElUX0FERDpcbiAgICAgICAgICBpZiAoIXNwbGljZSlcbiAgICAgICAgICAgIHNwbGljZSA9IG5ld1NwbGljZShpbmRleCwgW10sIDApO1xuXG4gICAgICAgICAgc3BsaWNlLmFkZGVkQ291bnQrKztcbiAgICAgICAgICBpbmRleCsrO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEVESVRfREVMRVRFOlxuICAgICAgICAgIGlmICghc3BsaWNlKVxuICAgICAgICAgICAgc3BsaWNlID0gbmV3U3BsaWNlKGluZGV4LCBbXSwgMCk7XG5cbiAgICAgICAgICBzcGxpY2UucmVtb3ZlZC5wdXNoKG9sZFtvbGRJbmRleF0pO1xuICAgICAgICAgIG9sZEluZGV4Kys7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHNwbGljZSkge1xuICAgICAgc3BsaWNlcy5wdXNoKHNwbGljZSk7XG4gICAgfVxuICAgIHJldHVybiBzcGxpY2VzO1xuICB9XG5cbiAgZnVuY3Rpb24gc2hhcmVkUHJlZml4KGN1cnJlbnQsIG9sZCwgc2VhcmNoTGVuZ3RoKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWFyY2hMZW5ndGg7IGkrKylcbiAgICAgIGlmICghZXF1YWxzKGN1cnJlbnRbaV0sIG9sZFtpXSkpXG4gICAgICAgIHJldHVybiBpO1xuICAgIHJldHVybiBzZWFyY2hMZW5ndGg7XG4gIH1cblxuICBmdW5jdGlvbiBzaGFyZWRTdWZmaXgoY3VycmVudCwgb2xkLCBzZWFyY2hMZW5ndGgpIHtcbiAgICBsZXQgaW5kZXgxID0gY3VycmVudC5sZW5ndGg7XG4gICAgbGV0IGluZGV4MiA9IG9sZC5sZW5ndGg7XG4gICAgbGV0IGNvdW50ID0gMDtcbiAgICB3aGlsZSAoY291bnQgPCBzZWFyY2hMZW5ndGggJiYgZXF1YWxzKGN1cnJlbnRbLS1pbmRleDFdLCBvbGRbLS1pbmRleDJdKSlcbiAgICAgIGNvdW50Kys7XG5cbiAgICByZXR1cm4gY291bnQ7XG4gIH1cblxuICBmdW5jdGlvbiBjYWxjdWxhdGVTcGxpY2VzKGN1cnJlbnQsIHByZXZpb3VzKSB7XG4gICAgcmV0dXJuIGNhbGNTcGxpY2VzKGN1cnJlbnQsIDAsIGN1cnJlbnQubGVuZ3RoLCBwcmV2aW91cywgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2aW91cy5sZW5ndGgpO1xuICB9XG5cbiAgZnVuY3Rpb24gZXF1YWxzKGN1cnJlbnRWYWx1ZSwgcHJldmlvdXNWYWx1ZSkge1xuICAgIHJldHVybiBjdXJyZW50VmFsdWUgPT09IHByZXZpb3VzVmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogQG5hbWVzcGFjZVxuICAgKiBAbWVtYmVyb2YgUG9seW1lclxuICAgKiBAc3VtbWFyeSBNb2R1bGUgdGhhdCBwcm92aWRlcyB1dGlsaXRpZXMgZm9yIGRpZmZpbmcgYXJyYXlzLlxuICAgKi9cbiAgUG9seW1lci5BcnJheVNwbGljZSA9IHtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIHNwbGljZSByZWNvcmRzIGluZGljYXRpbmcgdGhlIG1pbmltdW0gZWRpdHMgcmVxdWlyZWRcbiAgICAgKiB0byB0cmFuc2Zvcm0gdGhlIGBwcmV2aW91c2AgYXJyYXkgaW50byB0aGUgYGN1cnJlbnRgIGFycmF5LlxuICAgICAqXG4gICAgICogU3BsaWNlIHJlY29yZHMgYXJlIG9yZGVyZWQgYnkgaW5kZXggYW5kIGNvbnRhaW4gdGhlIGZvbGxvd2luZyBmaWVsZHM6XG4gICAgICogLSBgaW5kZXhgOiBpbmRleCB3aGVyZSBlZGl0IHN0YXJ0ZWRcbiAgICAgKiAtIGByZW1vdmVkYDogYXJyYXkgb2YgcmVtb3ZlZCBpdGVtcyBmcm9tIHRoaXMgaW5kZXhcbiAgICAgKiAtIGBhZGRlZENvdW50YDogbnVtYmVyIG9mIGl0ZW1zIGFkZGVkIGF0IHRoaXMgaW5kZXhcbiAgICAgKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgYmFzZWQgb24gdGhlIExldmVuc2h0ZWluIFwibWluaW11bSBlZGl0IGRpc3RhbmNlXCJcbiAgICAgKiBhbGdvcml0aG0uIE5vdGUgdGhhdCB1cGRhdGVzIGFyZSB0cmVhdGVkIGFzIHJlbW92YWwgZm9sbG93ZWQgYnkgYWRkaXRpb24uXG4gICAgICpcbiAgICAgKiBUaGUgd29yc3QtY2FzZSB0aW1lIGNvbXBsZXhpdHkgb2YgdGhpcyBhbGdvcml0aG0gaXMgYE8obCAqIHApYFxuICAgICAqICAgbDogVGhlIGxlbmd0aCBvZiB0aGUgY3VycmVudCBhcnJheVxuICAgICAqICAgcDogVGhlIGxlbmd0aCBvZiB0aGUgcHJldmlvdXMgYXJyYXlcbiAgICAgKlxuICAgICAqIEhvd2V2ZXIsIHRoZSB3b3JzdC1jYXNlIGNvbXBsZXhpdHkgaXMgcmVkdWNlZCBieSBhbiBgTyhuKWAgb3B0aW1pemF0aW9uXG4gICAgICogdG8gZGV0ZWN0IGFueSBzaGFyZWQgcHJlZml4ICYgc3VmZml4IGJldHdlZW4gdGhlIHR3byBhcnJheXMgYW5kIG9ubHlcbiAgICAgKiBwZXJmb3JtIHRoZSBtb3JlIGV4cGVuc2l2ZSBtaW5pbXVtIGVkaXQgZGlzdGFuY2UgY2FsY3VsYXRpb24gb3ZlciB0aGVcbiAgICAgKiBub24tc2hhcmVkIHBvcnRpb25zIG9mIHRoZSBhcnJheXMuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgUG9seW1lci5BcnJheVNwbGljZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGN1cnJlbnQgVGhlIFwiY2hhbmdlZFwiIGFycmF5IGZvciB3aGljaCBzcGxpY2VzIHdpbGwgYmVcbiAgICAgKiBjYWxjdWxhdGVkLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHByZXZpb3VzIFRoZSBcInVuY2hhbmdlZFwiIG9yaWdpbmFsIGFycmF5IHRvIGNvbXBhcmVcbiAgICAgKiBgY3VycmVudGAgYWdhaW5zdCB0byBkZXRlcm1pbmUgdGhlIHNwbGljZXMuXG4gICAgICogQHJldHVybiB7QXJyYXl9IFJldHVybnMgYW4gYXJyYXkgb2Ygc3BsaWNlIHJlY29yZCBvYmplY3RzLiBFYWNoIG9mIHRoZXNlXG4gICAgICogY29udGFpbnM6IGBpbmRleGAgdGhlIGxvY2F0aW9uIHdoZXJlIHRoZSBzcGxpY2Ugb2NjdXJyZWQ7IGByZW1vdmVkYFxuICAgICAqIHRoZSBhcnJheSBvZiByZW1vdmVkIGl0ZW1zIGZyb20gdGhpcyBsb2NhdGlvbjsgYGFkZGVkQ291bnRgIHRoZSBudW1iZXJcbiAgICAgKiBvZiBpdGVtcyBhZGRlZCBhdCB0aGlzIGxvY2F0aW9uLlxuICAgICAqL1xuICAgIGNhbGN1bGF0ZVNwbGljZXNcbiAgfVxuXG59KSgpO1xuPC9zY3JpcHQ+XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi91dGlscy9hcnJheS1zcGxpY2UuaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTYgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cblxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL2FwcC1zY3JvbGwtZWZmZWN0cy1iZWhhdmlvci5odG1sXCI+XG5cbjxzY3JpcHQ+XG4gIC8qKlxuICAgKiBXaGlsZSBzY3JvbGxpbmcgZG93biwgZmFkZSBpbiB0aGUgcmVhciBiYWNrZ3JvdW5kIGxheWVyIGFuZCBmYWRlIG91dCB0aGUgZnJvbnQgYmFja2dyb3VuZFxuICAgKiBsYXllciAob3BhY2l0eSBpbnRlcnBvbGF0ZWQgYmFzZWQgb24gc2Nyb2xsIHBvc2l0aW9uKS5cbiAgICovXG4gIFBvbHltZXIuQXBwTGF5b3V0LnJlZ2lzdGVyRWZmZWN0KCdibGVuZC1iYWNrZ3JvdW5kJywge1xuICAgIC8qKiBAdGhpcyBQb2x5bWVyLkFwcExheW91dC5FbGVtZW50V2l0aEJhY2tncm91bmQgKi9cbiAgICBzZXRVcDogZnVuY3Rpb24gc2V0VXAoKSB7XG4gICAgICB2YXIgZnggPSB7fTtcbiAgICAgIGZ4LmJhY2tncm91bmRGcm9udExheWVyID0gdGhpcy5fZ2V0RE9NUmVmKCdiYWNrZ3JvdW5kRnJvbnRMYXllcicpO1xuICAgICAgZnguYmFja2dyb3VuZFJlYXJMYXllciA9IHRoaXMuX2dldERPTVJlZignYmFja2dyb3VuZFJlYXJMYXllcicpO1xuICAgICAgZnguYmFja2dyb3VuZEZyb250TGF5ZXIuc3R5bGUud2lsbENoYW5nZSA9ICdvcGFjaXR5JztcbiAgICAgIGZ4LmJhY2tncm91bmRGcm9udExheWVyLnN0eWxlLnRyYW5zZm9ybSA9ICd0cmFuc2xhdGVaKDApJztcbiAgICAgIGZ4LmJhY2tncm91bmRSZWFyTGF5ZXIuc3R5bGUud2lsbENoYW5nZSA9ICdvcGFjaXR5JztcbiAgICAgIGZ4LmJhY2tncm91bmRSZWFyTGF5ZXIuc3R5bGUudHJhbnNmb3JtID0gJ3RyYW5zbGF0ZVooMCknO1xuICAgICAgZnguYmFja2dyb3VuZFJlYXJMYXllci5zdHlsZS5vcGFjaXR5ID0gMDtcbiAgICAgIHRoaXMuX2Z4QmxlbmRCYWNrZ3JvdW5kID0gZng7XG4gICAgfSxcbiAgICAvKiogQHRoaXMgUG9seW1lci5BcHBMYXlvdXQuRWxlbWVudFdpdGhCYWNrZ3JvdW5kICovXG4gICAgcnVuOiBmdW5jdGlvbiBydW4ocCwgeSkge1xuICAgICAgdmFyIGZ4ID0gdGhpcy5fZnhCbGVuZEJhY2tncm91bmQ7XG4gICAgICBmeC5iYWNrZ3JvdW5kRnJvbnRMYXllci5zdHlsZS5vcGFjaXR5ID0gMSAtIHA7XG4gICAgICBmeC5iYWNrZ3JvdW5kUmVhckxheWVyLnN0eWxlLm9wYWNpdHkgPSBwO1xuICAgIH0sXG4gICAgLyoqIEB0aGlzIFBvbHltZXIuQXBwTGF5b3V0LkVsZW1lbnRXaXRoQmFja2dyb3VuZCAqL1xuICAgIHRlYXJEb3duOiBmdW5jdGlvbiB0ZWFyRG93bigpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLl9meEJsZW5kQmFja2dyb3VuZDtcbiAgICB9XG4gIH0pO1xuPC9zY3JpcHQ+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL2FwcC1sYXlvdXQvYXBwLXNjcm9sbC1lZmZlY3RzL2VmZmVjdHMvYmxlbmQtYmFja2dyb3VuZC5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNiBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuXG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vYXBwLXNjcm9sbC1lZmZlY3RzLWJlaGF2aW9yLmh0bWxcIj5cblxuPHNjcmlwdD5cbiAgLyoqXG4gICAqIFRvZ2dsZXMgdGhlIHNoYWRvdyBwcm9wZXJ0eSBpbiBhcHAtaGVhZGVyIHdoZW4gY29udGVudCBpcyBzY3JvbGxlZCB0byBjcmVhdGUgYSBzZW5zZSBvZiBkZXB0aFxuICAgKiBiZXR3ZWVuIHRoZSBlbGVtZW50IGFuZCB0aGUgY29udGVudCB1bmRlcm5lYXRoLlxuICAgKi9cbiAgUG9seW1lci5BcHBMYXlvdXQucmVnaXN0ZXJFZmZlY3QoJ3dhdGVyZmFsbCcsIHtcbiAgICAvKipcbiAgICAgKiAgQHRoaXMgUG9seW1lci5BcHBMYXlvdXQuRWxlbWVudFdpdGhCYWNrZ3JvdW5kXG4gICAgICovXG4gICAgcnVuOiBmdW5jdGlvbiBydW4oKSB7XG4gICAgICB0aGlzLnNoYWRvdyA9IHRoaXMuaXNPblNjcmVlbigpICYmIHRoaXMuaXNDb250ZW50QmVsb3coKTtcbiAgICB9XG4gIH0pO1xuPC9zY3JpcHQ+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL2FwcC1sYXlvdXQvYXBwLXNjcm9sbC1lZmZlY3RzL2VmZmVjdHMvd2F0ZXJmYWxsLmh0bWwiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi9hcHAtc2Nyb2xsLWVmZmVjdHMtYmVoYXZpb3IuaHRtbFwiPlxuXG48c2NyaXB0PlxuICAoZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gaW50ZXJwb2xhdGUocHJvZ3Jlc3MsIHBvaW50cywgZm4sIGN0eCkge1xuICAgICAgZm4uYXBwbHkoY3R4LCBwb2ludHMubWFwKGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgICAgIHJldHVybiBwb2ludFswXSArIChwb2ludFsxXSAtIHBvaW50WzBdKSAqIHByb2dyZXNzO1xuICAgICAgfSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybSB0aGUgZm9udCBzaXplIG9mIGEgZGVzaWduYXRlZCB0aXRsZSBlbGVtZW50IGJldHdlZW4gdHdvIHZhbHVlcyBiYXNlZCBvbiB0aGUgc2Nyb2xsXG4gICAgICogcG9zaXRpb24uXG4gICAgICovXG4gICAgUG9seW1lci5BcHBMYXlvdXQucmVnaXN0ZXJFZmZlY3QoJ3Jlc2l6ZS10aXRsZScsIHtcbiAgICAgIC8qKiBAdGhpcyBQb2x5bWVyLkFwcExheW91dC5FbGVtZW50V2l0aEJhY2tncm91bmQgKi9cbiAgICAgIHNldFVwOiBmdW5jdGlvbiBzZXRVcCgpIHtcbiAgICAgICAgdmFyIHRpdGxlID0gdGhpcy5fZ2V0RE9NUmVmKCdtYWluVGl0bGUnKTtcbiAgICAgICAgdmFyIGNvbmRlbnNlZFRpdGxlID0gdGhpcy5fZ2V0RE9NUmVmKCdjb25kZW5zZWRUaXRsZScpO1xuXG4gICAgICAgIGlmICghY29uZGVuc2VkVGl0bGUpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ1Njcm9sbCBlZmZlY3QgYHJlc2l6ZS10aXRsZWA6IHVuZGVmaW5lZCBgY29uZGVuc2VkLXRpdGxlYCcpO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRpdGxlKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKCdTY3JvbGwgZWZmZWN0IGByZXNpemUtdGl0bGVgOiB1bmRlZmluZWQgYG1haW4tdGl0bGVgJyk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uZGVuc2VkVGl0bGUuc3R5bGUud2lsbENoYW5nZSA9ICdvcGFjaXR5JztcbiAgICAgICAgY29uZGVuc2VkVGl0bGUuc3R5bGUud2Via2l0VHJhbnNmb3JtID0gJ3RyYW5zbGF0ZVooMCknO1xuICAgICAgICBjb25kZW5zZWRUaXRsZS5zdHlsZS50cmFuc2Zvcm0gPSAndHJhbnNsYXRlWigwKSc7XG4gICAgICAgIGNvbmRlbnNlZFRpdGxlLnN0eWxlLndlYmtpdFRyYW5zZm9ybU9yaWdpbiA9ICdsZWZ0IHRvcCc7XG4gICAgICAgIGNvbmRlbnNlZFRpdGxlLnN0eWxlLnRyYW5zZm9ybU9yaWdpbiA9ICdsZWZ0IHRvcCc7XG5cbiAgICAgICAgdGl0bGUuc3R5bGUud2lsbENoYW5nZSA9ICdvcGFjaXR5JztcbiAgICAgICAgdGl0bGUuc3R5bGUud2Via2l0VHJhbnNmb3JtT3JpZ2luID0gJ2xlZnQgdG9wJztcbiAgICAgICAgdGl0bGUuc3R5bGUudHJhbnNmb3JtT3JpZ2luID0gJ2xlZnQgdG9wJztcbiAgICAgICAgdGl0bGUuc3R5bGUud2Via2l0VHJhbnNmb3JtID0gJ3RyYW5zbGF0ZVooMCknO1xuICAgICAgICB0aXRsZS5zdHlsZS50cmFuc2Zvcm0gPSAndHJhbnNsYXRlWigwKSc7XG5cbiAgICAgICAgdmFyIHRpdGxlQ2xpZW50UmVjdCA9IHRpdGxlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB2YXIgY29uZGVuc2VkVGl0bGVDbGllbnRSZWN0ID0gY29uZGVuc2VkVGl0bGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHZhciBmeCA9IHt9O1xuXG4gICAgICAgIGZ4LnNjYWxlID0gcGFyc2VJbnQod2luZG93LmdldENvbXB1dGVkU3R5bGUoY29uZGVuc2VkVGl0bGUpWydmb250LXNpemUnXSwgMTApIC9cbiAgICAgICAgICAgIHBhcnNlSW50KHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRpdGxlKVsnZm9udC1zaXplJ10sIDEwKTtcbiAgICAgICAgZngudGl0bGVEWCA9IHRpdGxlQ2xpZW50UmVjdC5sZWZ0IC0gY29uZGVuc2VkVGl0bGVDbGllbnRSZWN0LmxlZnQ7XG4gICAgICAgIGZ4LnRpdGxlRFkgPSB0aXRsZUNsaWVudFJlY3QudG9wIC0gY29uZGVuc2VkVGl0bGVDbGllbnRSZWN0LnRvcDtcbiAgICAgICAgZnguY29uZGVuc2VkVGl0bGUgPSBjb25kZW5zZWRUaXRsZTtcbiAgICAgICAgZngudGl0bGUgPSB0aXRsZTtcblxuICAgICAgICB0aGlzLl9meFJlc2l6ZVRpdGxlID0gZng7XG4gICAgICB9LFxuICAgICAgLyoqIEB0aGlzIFBvbHltZXJFbGVtZW50ICovXG4gICAgICBydW46IGZ1bmN0aW9uIHJ1bihwLCB5KSB7XG4gICAgICAgIHZhciBmeCA9IHRoaXMuX2Z4UmVzaXplVGl0bGU7XG4gICAgICAgIGlmICghdGhpcy5jb25kZW5zZXMpIHtcbiAgICAgICAgICB5ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocCA+PSAxKSB7XG4gICAgICAgICAgZngudGl0bGUuc3R5bGUub3BhY2l0eSA9IDA7XG4gICAgICAgICAgZnguY29uZGVuc2VkVGl0bGUuc3R5bGUub3BhY2l0eSA9IDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZngudGl0bGUuc3R5bGUub3BhY2l0eSA9IDE7XG4gICAgICAgICAgZnguY29uZGVuc2VkVGl0bGUuc3R5bGUub3BhY2l0eSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaW50ZXJwb2xhdGUoTWF0aC5taW4oMSwgcCksIFsgWzEsIGZ4LnNjYWxlXSwgWzAsIC1meC50aXRsZURYXSwgW3ksIHktZngudGl0bGVEWV0gXSxcbiAgICAgICAgICBmdW5jdGlvbihzY2FsZSwgdHJhbnNsYXRlWCwgdHJhbnNsYXRlWSkge1xuICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm0oJ3RyYW5zbGF0ZSgnICsgdHJhbnNsYXRlWCArICdweCwgJyArIHRyYW5zbGF0ZVkgKyAncHgpICcgK1xuICAgICAgICAgICAgICAgICdzY2FsZTNkKCcgKyBzY2FsZSArICcsICcgKyBzY2FsZSArICcsIDEpJywgZngudGl0bGUpO1xuICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgfSxcbiAgICAgIC8qKiBAdGhpcyBQb2x5bWVyLkFwcExheW91dC5FbGVtZW50V2l0aEJhY2tncm91bmQgKi9cbiAgICAgIHRlYXJEb3duOiBmdW5jdGlvbiB0ZWFyRG93bigpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuX2Z4UmVzaXplVGl0bGU7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pKCk7XG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvYXBwLWxheW91dC9hcHAtc2Nyb2xsLWVmZmVjdHMvZWZmZWN0cy9yZXNpemUtdGl0bGUuaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTYgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cblxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL2FwcC1zY3JvbGwtZWZmZWN0cy1iZWhhdmlvci5odG1sXCI+XG5cbjxzY3JpcHQ+XG4gIC8qKlxuICAgKiBWZXJ0aWNhbGx5IHRyYW5zbGF0ZSB0aGUgYmFja2dyb3VuZCBiYXNlZCBvbiBhIGZhY3RvciBvZiB0aGUgc2Nyb2xsIHBvc2l0aW9uLlxuICAgKi9cbiAgUG9seW1lci5BcHBMYXlvdXQucmVnaXN0ZXJFZmZlY3QoJ3BhcmFsbGF4LWJhY2tncm91bmQnLCB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHt7c2NhbGFyOiBzdHJpbmd9fSBjb25maWdcbiAgICAgKiBAdGhpcyBQb2x5bWVyLkFwcExheW91dC5FbGVtZW50V2l0aEJhY2tncm91bmRcbiAgICAgKi9cbiAgICBzZXRVcDogZnVuY3Rpb24gc2V0VXAoY29uZmlnKSB7XG4gICAgICB2YXIgZnggPSB7fTtcbiAgICAgIHZhciBzY2FsYXIgPSBwYXJzZUZsb2F0KGNvbmZpZy5zY2FsYXIpO1xuICAgICAgZnguYmFja2dyb3VuZCA9IHRoaXMuX2dldERPTVJlZignYmFja2dyb3VuZCcpO1xuICAgICAgZnguYmFja2dyb3VuZEZyb250TGF5ZXIgPSB0aGlzLl9nZXRET01SZWYoJ2JhY2tncm91bmRGcm9udExheWVyJyk7XG4gICAgICBmeC5iYWNrZ3JvdW5kUmVhckxheWVyID0gdGhpcy5fZ2V0RE9NUmVmKCdiYWNrZ3JvdW5kUmVhckxheWVyJyk7XG4gICAgICBmeC5kZWx0YUJnID0gZnguYmFja2dyb3VuZEZyb250TGF5ZXIub2Zmc2V0SGVpZ2h0IC0gZnguYmFja2dyb3VuZC5vZmZzZXRIZWlnaHQ7XG4gICAgICBpZiAoZnguZGVsdGFCZyA9PT0gMCkge1xuICAgICAgICBpZiAoaXNOYU4oc2NhbGFyKSkge1xuICAgICAgICAgIHNjYWxhciA9IDAuODtcbiAgICAgICAgfVxuICAgICAgICBmeC5kZWx0YUJnID0gdGhpcy5fZEhlaWdodCAqIHNjYWxhcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc05hTihzY2FsYXIpKSB7XG4gICAgICAgICAgc2NhbGFyID0gMTtcbiAgICAgICAgfVxuICAgICAgICBmeC5kZWx0YUJnID0gZnguZGVsdGFCZyAqIHNjYWxhcjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2Z4UGFyYWxsYXhCYWNrZ3JvdW5kID0gZng7XG4gICAgfSxcbiAgICAvKiogQHRoaXMgUG9seW1lci5BcHBMYXlvdXQuRWxlbWVudFdpdGhCYWNrZ3JvdW5kICovXG4gICAgcnVuOiBmdW5jdGlvbiBydW4ocCwgeSkge1xuICAgICAgdmFyIGZ4ID0gdGhpcy5fZnhQYXJhbGxheEJhY2tncm91bmQ7XG4gICAgICB0aGlzLnRyYW5zZm9ybSgndHJhbnNsYXRlM2QoMHB4LCAnICsgKGZ4LmRlbHRhQmcgKiBNYXRoLm1pbigxLCBwKSkgKyAncHgsIDBweCknLCBmeC5iYWNrZ3JvdW5kRnJvbnRMYXllcik7XG4gICAgICBpZiAoZnguYmFja2dyb3VuZFJlYXJMYXllcikge1xuICAgICAgICB0aGlzLnRyYW5zZm9ybSgndHJhbnNsYXRlM2QoMHB4LCAnICsgKGZ4LmRlbHRhQmcgKiBNYXRoLm1pbigxLCBwKSkgKyAncHgsIDBweCknLCBmeC5iYWNrZ3JvdW5kUmVhckxheWVyKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8qKiBAdGhpcyBQb2x5bWVyLkFwcExheW91dC5FbGVtZW50V2l0aEJhY2tncm91bmQgKi9cbiAgICB0ZWFyRG93bjogZnVuY3Rpb24gdGVhckRvd24oKSB7XG4gICAgICBkZWxldGUgdGhpcy5fZnhQYXJhbGxheEJhY2tncm91bmQ7XG4gICAgfVxuICB9KTtcbjwvc2NyaXB0PlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9hcHAtbGF5b3V0L2FwcC1zY3JvbGwtZWZmZWN0cy9lZmZlY3RzL3BhcmFsbGF4LWJhY2tncm91bmQuaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTUgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cblxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3BvbHltZXIvcG9seW1lci5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiaXJvbi1zZWxlY3Rpb24uaHRtbFwiPlxuXG48c2NyaXB0PlxuICAvKipcbiAgICogQHBvbHltZXJCZWhhdmlvciBQb2x5bWVyLklyb25TZWxlY3RhYmxlQmVoYXZpb3JcbiAgICovXG4gIFBvbHltZXIuSXJvblNlbGVjdGFibGVCZWhhdmlvciA9IHtcblxuICAgICAgLyoqXG4gICAgICAgKiBGaXJlZCB3aGVuIGlyb24tc2VsZWN0b3IgaXMgYWN0aXZhdGVkIChzZWxlY3RlZCBvciBkZXNlbGVjdGVkKS5cbiAgICAgICAqIEl0IGlzIGZpcmVkIGJlZm9yZSB0aGUgc2VsZWN0ZWQgaXRlbXMgYXJlIGNoYW5nZWQuXG4gICAgICAgKiBDYW5jZWwgdGhlIGV2ZW50IHRvIGFib3J0IHNlbGVjdGlvbi5cbiAgICAgICAqXG4gICAgICAgKiBAZXZlbnQgaXJvbi1hY3RpdmF0ZVxuICAgICAgICovXG5cbiAgICAgIC8qKlxuICAgICAgICogRmlyZWQgd2hlbiBhbiBpdGVtIGlzIHNlbGVjdGVkXG4gICAgICAgKlxuICAgICAgICogQGV2ZW50IGlyb24tc2VsZWN0XG4gICAgICAgKi9cblxuICAgICAgLyoqXG4gICAgICAgKiBGaXJlZCB3aGVuIGFuIGl0ZW0gaXMgZGVzZWxlY3RlZFxuICAgICAgICpcbiAgICAgICAqIEBldmVudCBpcm9uLWRlc2VsZWN0XG4gICAgICAgKi9cblxuICAgICAgLyoqXG4gICAgICAgKiBGaXJlZCB3aGVuIHRoZSBsaXN0IG9mIHNlbGVjdGFibGUgaXRlbXMgY2hhbmdlcyAoZS5nLiwgaXRlbXMgYXJlXG4gICAgICAgKiBhZGRlZCBvciByZW1vdmVkKS4gVGhlIGRldGFpbCBvZiB0aGUgZXZlbnQgaXMgYSBtdXRhdGlvbiByZWNvcmQgdGhhdFxuICAgICAgICogZGVzY3JpYmVzIHdoYXQgY2hhbmdlZC5cbiAgICAgICAqXG4gICAgICAgKiBAZXZlbnQgaXJvbi1pdGVtcy1jaGFuZ2VkXG4gICAgICAgKi9cblxuICAgIHByb3BlcnRpZXM6IHtcblxuICAgICAgLyoqXG4gICAgICAgKiBJZiB5b3Ugd2FudCB0byB1c2UgYW4gYXR0cmlidXRlIHZhbHVlIG9yIHByb3BlcnR5IG9mIGFuIGVsZW1lbnQgZm9yXG4gICAgICAgKiBgc2VsZWN0ZWRgIGluc3RlYWQgb2YgdGhlIGluZGV4LCBzZXQgdGhpcyB0byB0aGUgbmFtZSBvZiB0aGUgYXR0cmlidXRlXG4gICAgICAgKiBvciBwcm9wZXJ0eS4gSHlwaGVuYXRlZCB2YWx1ZXMgYXJlIGNvbnZlcnRlZCB0byBjYW1lbCBjYXNlIHdoZW4gdXNlZCB0b1xuICAgICAgICogbG9vayB1cCB0aGUgcHJvcGVydHkgb2YgYSBzZWxlY3RhYmxlIGVsZW1lbnQuIENhbWVsIGNhc2VkIHZhbHVlcyBhcmVcbiAgICAgICAqICpub3QqIGNvbnZlcnRlZCB0byBoeXBoZW5hdGVkIHZhbHVlcyBmb3IgYXR0cmlidXRlIGxvb2t1cC4gSXQnc1xuICAgICAgICogcmVjb21tZW5kZWQgdGhhdCB5b3UgcHJvdmlkZSB0aGUgaHlwaGVuYXRlZCBmb3JtIG9mIHRoZSBuYW1lIHNvIHRoYXRcbiAgICAgICAqIHNlbGVjdGlvbiB3b3JrcyBpbiBib3RoIGNhc2VzLiAoVXNlIGBhdHRyLW9yLXByb3BlcnR5LW5hbWVgIGluc3RlYWQgb2ZcbiAgICAgICAqIGBhdHRyT3JQcm9wZXJ0eU5hbWVgLilcbiAgICAgICAqL1xuICAgICAgYXR0ckZvclNlbGVjdGVkOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgdmFsdWU6IG51bGxcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBzZWxlY3RlZCBlbGVtZW50LiBUaGUgZGVmYXVsdCBpcyB0byB1c2UgdGhlIGluZGV4IG9mIHRoZSBpdGVtLlxuICAgICAgICogQHR5cGUge3N0cmluZ3xudW1iZXJ9XG4gICAgICAgKi9cbiAgICAgIHNlbGVjdGVkOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgbm90aWZ5OiB0cnVlXG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBpdGVtLlxuICAgICAgICpcbiAgICAgICAqIEB0eXBlIHs/T2JqZWN0fVxuICAgICAgICovXG4gICAgICBzZWxlY3RlZEl0ZW06IHtcbiAgICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgICByZWFkT25seTogdHJ1ZSxcbiAgICAgICAgbm90aWZ5OiB0cnVlXG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFRoZSBldmVudCB0aGF0IGZpcmVzIGZyb20gaXRlbXMgd2hlbiB0aGV5IGFyZSBzZWxlY3RlZC4gU2VsZWN0YWJsZVxuICAgICAgICogd2lsbCBsaXN0ZW4gZm9yIHRoaXMgZXZlbnQgZnJvbSBpdGVtcyBhbmQgdXBkYXRlIHRoZSBzZWxlY3Rpb24gc3RhdGUuXG4gICAgICAgKiBTZXQgdG8gZW1wdHkgc3RyaW5nIHRvIGxpc3RlbiB0byBubyBldmVudHMuXG4gICAgICAgKi9cbiAgICAgIGFjdGl2YXRlRXZlbnQ6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICB2YWx1ZTogJ3RhcCcsXG4gICAgICAgIG9ic2VydmVyOiAnX2FjdGl2YXRlRXZlbnRDaGFuZ2VkJ1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBUaGlzIGlzIGEgQ1NTIHNlbGVjdG9yIHN0cmluZy4gIElmIHRoaXMgaXMgc2V0LCBvbmx5IGl0ZW1zIHRoYXQgbWF0Y2ggdGhlIENTUyBzZWxlY3RvclxuICAgICAgICogYXJlIHNlbGVjdGFibGUuXG4gICAgICAgKi9cbiAgICAgIHNlbGVjdGFibGU6IFN0cmluZyxcblxuICAgICAgLyoqXG4gICAgICAgKiBUaGUgY2xhc3MgdG8gc2V0IG9uIGVsZW1lbnRzIHdoZW4gc2VsZWN0ZWQuXG4gICAgICAgKi9cbiAgICAgIHNlbGVjdGVkQ2xhc3M6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICB2YWx1ZTogJ2lyb24tc2VsZWN0ZWQnXG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFRoZSBhdHRyaWJ1dGUgdG8gc2V0IG9uIGVsZW1lbnRzIHdoZW4gc2VsZWN0ZWQuXG4gICAgICAgKi9cbiAgICAgIHNlbGVjdGVkQXR0cmlidXRlOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgdmFsdWU6IG51bGxcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogRGVmYXVsdCBmYWxsYmFjayBpZiB0aGUgc2VsZWN0aW9uIGJhc2VkIG9uIHNlbGVjdGVkIHdpdGggYGF0dHJGb3JTZWxlY3RlZGBcbiAgICAgICAqIGlzIG5vdCBmb3VuZC5cbiAgICAgICAqL1xuICAgICAgZmFsbGJhY2tTZWxlY3Rpb246IHtcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICB2YWx1ZTogbnVsbFxuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBUaGUgbGlzdCBvZiBpdGVtcyBmcm9tIHdoaWNoIGEgc2VsZWN0aW9uIGNhbiBiZSBtYWRlLlxuICAgICAgICovXG4gICAgICBpdGVtczoge1xuICAgICAgICB0eXBlOiBBcnJheSxcbiAgICAgICAgcmVhZE9ubHk6IHRydWUsXG4gICAgICAgIG5vdGlmeTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBUaGUgc2V0IG9mIGV4Y2x1ZGVkIGVsZW1lbnRzIHdoZXJlIHRoZSBrZXkgaXMgdGhlIGBsb2NhbE5hbWVgXG4gICAgICAgKiBvZiB0aGUgZWxlbWVudCB0aGF0IHdpbGwgYmUgaWdub3JlZCBmcm9tIHRoZSBpdGVtIGxpc3QuXG4gICAgICAgKlxuICAgICAgICogQGRlZmF1bHQge3RlbXBsYXRlOiAxfVxuICAgICAgICovXG4gICAgICBfZXhjbHVkZWRMb2NhbE5hbWVzOiB7XG4gICAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAndGVtcGxhdGUnOiAxLFxuICAgICAgICAgICAgJ2RvbS1iaW5kJzogMSxcbiAgICAgICAgICAgICdkb20taWYnOiAxLFxuICAgICAgICAgICAgJ2RvbS1yZXBlYXQnOiAxLFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgb2JzZXJ2ZXJzOiBbXG4gICAgICAnX3VwZGF0ZUF0dHJGb3JTZWxlY3RlZChhdHRyRm9yU2VsZWN0ZWQpJyxcbiAgICAgICdfdXBkYXRlU2VsZWN0ZWQoc2VsZWN0ZWQpJyxcbiAgICAgICdfY2hlY2tGYWxsYmFjayhmYWxsYmFja1NlbGVjdGlvbiknXG4gICAgXSxcblxuICAgIGNyZWF0ZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fYmluZEZpbHRlckl0ZW0gPSB0aGlzLl9maWx0ZXJJdGVtLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLl9zZWxlY3Rpb24gPSBuZXcgUG9seW1lci5Jcm9uU2VsZWN0aW9uKHRoaXMuX2FwcGx5U2VsZWN0aW9uLmJpbmQodGhpcykpO1xuICAgIH0sXG5cbiAgICBhdHRhY2hlZDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9vYnNlcnZlciA9IHRoaXMuX29ic2VydmVJdGVtcyh0aGlzKTtcbiAgICAgIHRoaXMuX2FkZExpc3RlbmVyKHRoaXMuYWN0aXZhdGVFdmVudCk7XG4gICAgfSxcblxuICAgIGRldGFjaGVkOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLl9vYnNlcnZlcikge1xuICAgICAgICBQb2x5bWVyLmRvbSh0aGlzKS51bm9ic2VydmVOb2Rlcyh0aGlzLl9vYnNlcnZlcik7XG4gICAgICB9XG4gICAgICB0aGlzLl9yZW1vdmVMaXN0ZW5lcih0aGlzLmFjdGl2YXRlRXZlbnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZ2l2ZW4gaXRlbS5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgaW5kZXhPZlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtXG4gICAgICogQHJldHVybnMgUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGl0ZW1cbiAgICAgKi9cbiAgICBpbmRleE9mOiBmdW5jdGlvbihpdGVtKSB7XG4gICAgICByZXR1cm4gdGhpcy5pdGVtcy5pbmRleE9mKGl0ZW0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZWxlY3RzIHRoZSBnaXZlbiB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBtZXRob2Qgc2VsZWN0XG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSB2YWx1ZSB0aGUgdmFsdWUgdG8gc2VsZWN0LlxuICAgICAqL1xuICAgIHNlbGVjdDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHRoaXMuc2VsZWN0ZWQgPSB2YWx1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2VsZWN0cyB0aGUgcHJldmlvdXMgaXRlbS5cbiAgICAgKlxuICAgICAqIEBtZXRob2Qgc2VsZWN0UHJldmlvdXNcbiAgICAgKi9cbiAgICBzZWxlY3RQcmV2aW91czogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gdGhpcy5pdGVtcy5sZW5ndGg7XG4gICAgICB2YXIgaW5kZXggPSAoTnVtYmVyKHRoaXMuX3ZhbHVlVG9JbmRleCh0aGlzLnNlbGVjdGVkKSkgLSAxICsgbGVuZ3RoKSAlIGxlbmd0aDtcbiAgICAgIHRoaXMuc2VsZWN0ZWQgPSB0aGlzLl9pbmRleFRvVmFsdWUoaW5kZXgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZWxlY3RzIHRoZSBuZXh0IGl0ZW0uXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHNlbGVjdE5leHRcbiAgICAgKi9cbiAgICBzZWxlY3ROZXh0OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBpbmRleCA9IChOdW1iZXIodGhpcy5fdmFsdWVUb0luZGV4KHRoaXMuc2VsZWN0ZWQpKSArIDEpICUgdGhpcy5pdGVtcy5sZW5ndGg7XG4gICAgICB0aGlzLnNlbGVjdGVkID0gdGhpcy5faW5kZXhUb1ZhbHVlKGluZGV4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2VsZWN0cyB0aGUgaXRlbSBhdCB0aGUgZ2l2ZW4gaW5kZXguXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHNlbGVjdEluZGV4XG4gICAgICovXG4gICAgc2VsZWN0SW5kZXg6IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICB0aGlzLnNlbGVjdCh0aGlzLl9pbmRleFRvVmFsdWUoaW5kZXgpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRm9yY2UgYSBzeW5jaHJvbm91cyB1cGRhdGUgb2YgdGhlIGBpdGVtc2AgcHJvcGVydHkuXG4gICAgICpcbiAgICAgKiBOT1RFOiBDb25zaWRlciBsaXN0ZW5pbmcgZm9yIHRoZSBgaXJvbi1pdGVtcy1jaGFuZ2VkYCBldmVudCB0byByZXNwb25kIHRvXG4gICAgICogdXBkYXRlcyB0byB0aGUgc2V0IG9mIHNlbGVjdGFibGUgaXRlbXMgYWZ0ZXIgdXBkYXRlcyB0byB0aGUgRE9NIGxpc3QgYW5kXG4gICAgICogc2VsZWN0aW9uIHN0YXRlIGhhdmUgYmVlbiBtYWRlLlxuICAgICAqXG4gICAgICogV0FSTklORzogSWYgeW91IGFyZSB1c2luZyB0aGlzIG1ldGhvZCwgeW91IHNob3VsZCBwcm9iYWJseSBjb25zaWRlciBhblxuICAgICAqIGFsdGVybmF0ZSBhcHByb2FjaC4gU3luY2hyb25vdXNseSBxdWVyeWluZyBmb3IgaXRlbXMgaXMgcG90ZW50aWFsbHlcbiAgICAgKiBzbG93IGZvciBtYW55IHVzZSBjYXNlcy4gVGhlIGBpdGVtc2AgcHJvcGVydHkgd2lsbCB1cGRhdGUgYXN5bmNocm9ub3VzbHlcbiAgICAgKiBvbiBpdHMgb3duIHRvIHJlZmxlY3Qgc2VsZWN0YWJsZSBpdGVtcyBpbiB0aGUgRE9NLlxuICAgICAqL1xuICAgIGZvcmNlU3luY2hyb25vdXNJdGVtVXBkYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLl9vYnNlcnZlciAmJiB0eXBlb2YgdGhpcy5fb2JzZXJ2ZXIuZmx1c2ggPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAvLyBOT1RFKGJpY2tuZWxscik6IGBQb2x5bWVyLmRvbS5mbHVzaGAgYWJvdmUgaXMgbm8gbG9uZ2VyIHN1ZmZpY2llbnQgdG9cbiAgICAgICAgLy8gdHJpZ2dlciBgb2JzZXJ2ZU5vZGVzYCBjYWxsYmFja3MuIFBvbHltZXIgMi54IHJldHVybnMgYW4gb2JqZWN0IGZyb21cbiAgICAgICAgLy8gYG9ic2VydmVOb2Rlc2Agd2l0aCBhIGBmbHVzaGAgdGhhdCBzeW5jaHJvbm91c2x5IGdpdmVzIHRoZSBjYWxsYmFja1xuICAgICAgICAvLyBhbnkgcGVuZGluZyBNdXRhdGlvblJlY29yZHMgKHJldHJpZXZlZCB3aXRoIGB0YWtlUmVjb3Jkc2ApLiBBbnkgY2FzZVxuICAgICAgICAvLyB3aGVyZSBTaGFkeURPTSBmbHVzaGVzIHdlcmUgZXhwZWN0ZWQgdG8gc3luY2hyb25vdXNseSB0cmlnZ2VyIGl0ZW1cbiAgICAgICAgLy8gdXBkYXRlcyB3aWxsIG5vdyByZXF1aXJlIGNhbGxpbmcgYGZvcmNlU3luY2hyb25vdXNJdGVtVXBkYXRlYC5cbiAgICAgICAgdGhpcy5fb2JzZXJ2ZXIuZmx1c2goKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUl0ZW1zKCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8vIFVOVVNFRCwgRk9SIEFQSSBDT01QQVRJQklMSVRZXG4gICAgZ2V0IF9zaG91bGRVcGRhdGVTZWxlY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZWxlY3RlZCAhPSBudWxsO1xuICAgIH0sXG5cbiAgICBfY2hlY2tGYWxsYmFjazogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl91cGRhdGVTZWxlY3RlZCgpO1xuICAgIH0sXG5cbiAgICBfYWRkTGlzdGVuZXI6IGZ1bmN0aW9uKGV2ZW50TmFtZSkge1xuICAgICAgdGhpcy5saXN0ZW4odGhpcywgZXZlbnROYW1lLCAnX2FjdGl2YXRlSGFuZGxlcicpO1xuICAgIH0sXG5cbiAgICBfcmVtb3ZlTGlzdGVuZXI6IGZ1bmN0aW9uKGV2ZW50TmFtZSkge1xuICAgICAgdGhpcy51bmxpc3Rlbih0aGlzLCBldmVudE5hbWUsICdfYWN0aXZhdGVIYW5kbGVyJyk7XG4gICAgfSxcblxuICAgIF9hY3RpdmF0ZUV2ZW50Q2hhbmdlZDogZnVuY3Rpb24oZXZlbnROYW1lLCBvbGQpIHtcbiAgICAgIHRoaXMuX3JlbW92ZUxpc3RlbmVyKG9sZCk7XG4gICAgICB0aGlzLl9hZGRMaXN0ZW5lcihldmVudE5hbWUpO1xuICAgIH0sXG5cbiAgICBfdXBkYXRlSXRlbXM6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG5vZGVzID0gUG9seW1lci5kb20odGhpcykucXVlcnlEaXN0cmlidXRlZEVsZW1lbnRzKHRoaXMuc2VsZWN0YWJsZSB8fCAnKicpO1xuICAgICAgbm9kZXMgPSBBcnJheS5wcm90b3R5cGUuZmlsdGVyLmNhbGwobm9kZXMsIHRoaXMuX2JpbmRGaWx0ZXJJdGVtKTtcbiAgICAgIHRoaXMuX3NldEl0ZW1zKG5vZGVzKTtcbiAgICB9LFxuXG4gICAgX3VwZGF0ZUF0dHJGb3JTZWxlY3RlZDogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5zZWxlY3RlZEl0ZW0pIHtcbiAgICAgICAgdGhpcy5zZWxlY3RlZCA9IHRoaXMuX3ZhbHVlRm9ySXRlbSh0aGlzLnNlbGVjdGVkSXRlbSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIF91cGRhdGVTZWxlY3RlZDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9zZWxlY3RTZWxlY3RlZCh0aGlzLnNlbGVjdGVkKTtcbiAgICB9LFxuXG4gICAgX3NlbGVjdFNlbGVjdGVkOiBmdW5jdGlvbihzZWxlY3RlZCkge1xuICAgICAgaWYgKCF0aGlzLml0ZW1zKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGl0ZW0gPSB0aGlzLl92YWx1ZVRvSXRlbSh0aGlzLnNlbGVjdGVkKTtcbiAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgIHRoaXMuX3NlbGVjdGlvbi5zZWxlY3QoaXRlbSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9zZWxlY3Rpb24uY2xlYXIoKTtcbiAgICAgIH1cbiAgICAgIC8vIENoZWNrIGZvciBpdGVtcywgc2luY2UgdGhpcyBhcnJheSBpcyBwb3B1bGF0ZWQgb25seSB3aGVuIGF0dGFjaGVkXG4gICAgICAvLyBTaW5jZSBOdW1iZXIoMCkgaXMgZmFsc3ksIGV4cGxpY2l0bHkgY2hlY2sgZm9yIHVuZGVmaW5lZFxuICAgICAgaWYgKHRoaXMuZmFsbGJhY2tTZWxlY3Rpb24gJiYgdGhpcy5pdGVtcy5sZW5ndGggJiYgKHRoaXMuX3NlbGVjdGlvbi5nZXQoKSA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICB0aGlzLnNlbGVjdGVkID0gdGhpcy5mYWxsYmFja1NlbGVjdGlvbjtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgX2ZpbHRlckl0ZW06IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHJldHVybiAhdGhpcy5fZXhjbHVkZWRMb2NhbE5hbWVzW25vZGUubG9jYWxOYW1lXTtcbiAgICB9LFxuXG4gICAgX3ZhbHVlVG9JdGVtOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuICh2YWx1ZSA9PSBudWxsKSA/IG51bGwgOiB0aGlzLml0ZW1zW3RoaXMuX3ZhbHVlVG9JbmRleCh2YWx1ZSldO1xuICAgIH0sXG5cbiAgICBfdmFsdWVUb0luZGV4OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgaWYgKHRoaXMuYXR0ckZvclNlbGVjdGVkKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBpdGVtOyBpdGVtID0gdGhpcy5pdGVtc1tpXTsgaSsrKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX3ZhbHVlRm9ySXRlbShpdGVtKSA9PSB2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gTnVtYmVyKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgX2luZGV4VG9WYWx1ZTogZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgIGlmICh0aGlzLmF0dHJGb3JTZWxlY3RlZCkge1xuICAgICAgICB2YXIgaXRlbSA9IHRoaXMuaXRlbXNbaW5kZXhdO1xuICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl92YWx1ZUZvckl0ZW0oaXRlbSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgX3ZhbHVlRm9ySXRlbTogZnVuY3Rpb24oaXRlbSkge1xuICAgICAgaWYgKCFpdGVtKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgcHJvcFZhbHVlID0gaXRlbVtQb2x5bWVyLkNhc2VNYXAuZGFzaFRvQ2FtZWxDYXNlKHRoaXMuYXR0ckZvclNlbGVjdGVkKV07XG4gICAgICByZXR1cm4gcHJvcFZhbHVlICE9IHVuZGVmaW5lZCA/IHByb3BWYWx1ZSA6IGl0ZW0uZ2V0QXR0cmlidXRlKHRoaXMuYXR0ckZvclNlbGVjdGVkKTtcbiAgICB9LFxuXG4gICAgX2FwcGx5U2VsZWN0aW9uOiBmdW5jdGlvbihpdGVtLCBpc1NlbGVjdGVkKSB7XG4gICAgICBpZiAodGhpcy5zZWxlY3RlZENsYXNzKSB7XG4gICAgICAgIHRoaXMudG9nZ2xlQ2xhc3ModGhpcy5zZWxlY3RlZENsYXNzLCBpc1NlbGVjdGVkLCBpdGVtKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnNlbGVjdGVkQXR0cmlidXRlKSB7XG4gICAgICAgIHRoaXMudG9nZ2xlQXR0cmlidXRlKHRoaXMuc2VsZWN0ZWRBdHRyaWJ1dGUsIGlzU2VsZWN0ZWQsIGl0ZW0pO1xuICAgICAgfVxuICAgICAgdGhpcy5fc2VsZWN0aW9uQ2hhbmdlKCk7XG4gICAgICB0aGlzLmZpcmUoJ2lyb24tJyArIChpc1NlbGVjdGVkID8gJ3NlbGVjdCcgOiAnZGVzZWxlY3QnKSwge2l0ZW06IGl0ZW19KTtcbiAgICB9LFxuXG4gICAgX3NlbGVjdGlvbkNoYW5nZTogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9zZXRTZWxlY3RlZEl0ZW0odGhpcy5fc2VsZWN0aW9uLmdldCgpKTtcbiAgICB9LFxuXG4gICAgLy8gb2JzZXJ2ZSBpdGVtcyBjaGFuZ2UgdW5kZXIgdGhlIGdpdmVuIG5vZGUuXG4gICAgX29ic2VydmVJdGVtczogZnVuY3Rpb24obm9kZSkge1xuICAgICAgcmV0dXJuIFBvbHltZXIuZG9tKG5vZGUpLm9ic2VydmVOb2RlcyhmdW5jdGlvbihtdXRhdGlvbikge1xuICAgICAgICB0aGlzLl91cGRhdGVJdGVtcygpO1xuICAgICAgICB0aGlzLl91cGRhdGVTZWxlY3RlZCgpO1xuXG4gICAgICAgIC8vIExldCBvdGhlciBpbnRlcmVzdGVkIHBhcnRpZXMga25vdyBhYm91dCB0aGUgY2hhbmdlIHNvIHRoYXRcbiAgICAgICAgLy8gd2UgZG9uJ3QgaGF2ZSB0byByZWNyZWF0ZSBtdXRhdGlvbiBvYnNlcnZlcnMgZXZlcnl3aGVyZS5cbiAgICAgICAgdGhpcy5maXJlKCdpcm9uLWl0ZW1zLWNoYW5nZWQnLCBtdXRhdGlvbiwge1xuICAgICAgICAgIGJ1YmJsZXM6IGZhbHNlLFxuICAgICAgICAgIGNhbmNlbGFibGU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSxcblxuICAgIF9hY3RpdmF0ZUhhbmRsZXI6IGZ1bmN0aW9uKGUpIHtcbiAgICAgIHZhciB0ID0gZS50YXJnZXQ7XG4gICAgICB2YXIgaXRlbXMgPSB0aGlzLml0ZW1zO1xuICAgICAgd2hpbGUgKHQgJiYgdCAhPSB0aGlzKSB7XG4gICAgICAgIHZhciBpID0gaXRlbXMuaW5kZXhPZih0KTtcbiAgICAgICAgaWYgKGkgPj0gMCkge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuX2luZGV4VG9WYWx1ZShpKTtcbiAgICAgICAgICB0aGlzLl9pdGVtQWN0aXZhdGUodmFsdWUsIHQpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0ID0gdC5wYXJlbnROb2RlO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBfaXRlbUFjdGl2YXRlOiBmdW5jdGlvbih2YWx1ZSwgaXRlbSkge1xuICAgICAgaWYgKCF0aGlzLmZpcmUoJ2lyb24tYWN0aXZhdGUnLFxuICAgICAgICAgIHtzZWxlY3RlZDogdmFsdWUsIGl0ZW06IGl0ZW19LCB7Y2FuY2VsYWJsZTogdHJ1ZX0pLmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgdGhpcy5zZWxlY3QodmFsdWUpO1xuICAgICAgfVxuICAgIH1cblxuICB9O1xuXG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvaXJvbi1zZWxlY3Rvci9pcm9uLXNlbGVjdGFibGUuaHRtbCIsIlxucmVxdWlyZSgnLi4vcG9seW1lci9wb2x5bWVyLmh0bWwnKTtcblxucmVxdWlyZSgnLi9jb2xvci5odG1sJyk7XG5cbmNvbnN0IFJlZ2lzdGVySHRtbFRlbXBsYXRlID0gcmVxdWlyZSgncG9seW1lci13ZWJwYWNrLWxvYWRlci9yZWdpc3Rlci1odG1sLXRlbXBsYXRlJyk7XG5cblJlZ2lzdGVySHRtbFRlbXBsYXRlLnRvQm9keShcIjxjdXN0b20tc3R5bGU+IDxzdHlsZSBpcz1jdXN0b20tc3R5bGU+aHRtbHstLXByaW1hcnktdGV4dC1jb2xvcjp2YXIoLS1saWdodC10aGVtZS10ZXh0LWNvbG9yKTstLXByaW1hcnktYmFja2dyb3VuZC1jb2xvcjp2YXIoLS1saWdodC10aGVtZS1iYWNrZ3JvdW5kLWNvbG9yKTstLXNlY29uZGFyeS10ZXh0LWNvbG9yOnZhcigtLWxpZ2h0LXRoZW1lLXNlY29uZGFyeS1jb2xvcik7LS1kaXNhYmxlZC10ZXh0LWNvbG9yOnZhcigtLWxpZ2h0LXRoZW1lLWRpc2FibGVkLWNvbG9yKTstLWRpdmlkZXItY29sb3I6dmFyKC0tbGlnaHQtdGhlbWUtZGl2aWRlci1jb2xvcik7LS1lcnJvci1jb2xvcjp2YXIoLS1wYXBlci1kZWVwLW9yYW5nZS1hNzAwKTstLXByaW1hcnktY29sb3I6dmFyKC0tcGFwZXItaW5kaWdvLTUwMCk7LS1saWdodC1wcmltYXJ5LWNvbG9yOnZhcigtLXBhcGVyLWluZGlnby0xMDApOy0tZGFyay1wcmltYXJ5LWNvbG9yOnZhcigtLXBhcGVyLWluZGlnby03MDApOy0tYWNjZW50LWNvbG9yOnZhcigtLXBhcGVyLXBpbmstYTIwMCk7LS1saWdodC1hY2NlbnQtY29sb3I6dmFyKC0tcGFwZXItcGluay1hMTAwKTstLWRhcmstYWNjZW50LWNvbG9yOnZhcigtLXBhcGVyLXBpbmstYTQwMCk7LS1saWdodC10aGVtZS1iYWNrZ3JvdW5kLWNvbG9yOiNmZmZmZmY7LS1saWdodC10aGVtZS1iYXNlLWNvbG9yOiMwMDAwMDA7LS1saWdodC10aGVtZS10ZXh0LWNvbG9yOnZhcigtLXBhcGVyLWdyZXktOTAwKTstLWxpZ2h0LXRoZW1lLXNlY29uZGFyeS1jb2xvcjojNzM3MzczOy0tbGlnaHQtdGhlbWUtZGlzYWJsZWQtY29sb3I6IzliOWI5YjstLWxpZ2h0LXRoZW1lLWRpdmlkZXItY29sb3I6I2RiZGJkYjstLWRhcmstdGhlbWUtYmFja2dyb3VuZC1jb2xvcjp2YXIoLS1wYXBlci1ncmV5LTkwMCk7LS1kYXJrLXRoZW1lLWJhc2UtY29sb3I6I2ZmZmZmZjstLWRhcmstdGhlbWUtdGV4dC1jb2xvcjojZmZmZmZmOy0tZGFyay10aGVtZS1zZWNvbmRhcnktY29sb3I6I2JjYmNiYzstLWRhcmstdGhlbWUtZGlzYWJsZWQtY29sb3I6IzY0NjQ2NDstLWRhcmstdGhlbWUtZGl2aWRlci1jb2xvcjojM2MzYzNjOy0tdGV4dC1wcmltYXJ5LWNvbG9yOnZhcigtLWRhcmstdGhlbWUtdGV4dC1jb2xvcik7LS1kZWZhdWx0LXByaW1hcnktY29sb3I6dmFyKC0tcHJpbWFyeS1jb2xvcil9PC9zdHlsZT4gPC9jdXN0b20tc3R5bGU+XCIpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9wYXBlci1zdHlsZXMvZGVmYXVsdC10aGVtZS5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNSBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuXG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vcG9seW1lci9wb2x5bWVyLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi9pcm9uLWljb24vaXJvbi1pY29uLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi9wYXBlci1iZWhhdmlvcnMvcGFwZXItaW5reS1mb2N1cy1iZWhhdmlvci5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vcGFwZXItc3R5bGVzL2RlZmF1bHQtdGhlbWUuaHRtbFwiPlxuXG48IS0tXG5NYXRlcmlhbCBkZXNpZ246IFtJY29uIHRvZ2dsZXNdKGh0dHBzOi8vd3d3Lmdvb2dsZS5jb20vZGVzaWduL3NwZWMvY29tcG9uZW50cy9idXR0b25zLmh0bWwjYnV0dG9ucy10b2dnbGUtYnV0dG9ucylcblxuYHBhcGVyLWljb24tYnV0dG9uYCBpcyBhIGJ1dHRvbiB3aXRoIGFuIGltYWdlIHBsYWNlZCBhdCB0aGUgY2VudGVyLiBXaGVuIHRoZSB1c2VyIHRvdWNoZXNcbnRoZSBidXR0b24sIGEgcmlwcGxlIGVmZmVjdCBlbWFuYXRlcyBmcm9tIHRoZSBjZW50ZXIgb2YgdGhlIGJ1dHRvbi5cblxuYHBhcGVyLWljb24tYnV0dG9uYCBkb2VzIG5vdCBpbmNsdWRlIGEgZGVmYXVsdCBpY29uIHNldC4gVG8gdXNlIGljb25zIGZyb20gdGhlIGRlZmF1bHRcbnNldCwgaW5jbHVkZSBgUG9seW1lckVsZW1lbnRzL2lyb24taWNvbnMvaXJvbi1pY29ucy5odG1sYCwgYW5kIHVzZSB0aGUgYGljb25gIGF0dHJpYnV0ZSB0byBzcGVjaWZ5IHdoaWNoIGljb25cbmZyb20gdGhlIGljb24gc2V0IHRvIHVzZS5cblxuICAgIDxwYXBlci1pY29uLWJ1dHRvbiBpY29uPVwibWVudVwiPjwvcGFwZXItaWNvbi1idXR0b24+XG5cblNlZSBbYGlyb24taWNvbnNldGBdKGlyb24taWNvbnNldCkgZm9yIG1vcmUgaW5mb3JtYXRpb24gYWJvdXRcbmhvdyB0byB1c2UgYSBjdXN0b20gaWNvbiBzZXQuXG5cbkV4YW1wbGU6XG5cbiAgICA8bGluayBocmVmPVwicGF0aC90by9pcm9uLWljb25zL2lyb24taWNvbnMuaHRtbFwiIHJlbD1cImltcG9ydFwiPlxuXG4gICAgPHBhcGVyLWljb24tYnV0dG9uIGljb249XCJmYXZvcml0ZVwiPjwvcGFwZXItaWNvbi1idXR0b24+XG4gICAgPHBhcGVyLWljb24tYnV0dG9uIHNyYz1cInN0YXIucG5nXCI+PC9wYXBlci1pY29uLWJ1dHRvbj5cblxuVG8gdXNlIGBwYXBlci1pY29uLWJ1dHRvbmAgYXMgYSBsaW5rLCB3cmFwIGl0IGluIGFuIGFuY2hvciB0YWcuIFNpbmNlIGBwYXBlci1pY29uLWJ1dHRvbmBcbndpbGwgYWxyZWFkeSByZWNlaXZlIGZvY3VzLCB5b3UgbWF5IHdhbnQgdG8gcHJldmVudCB0aGUgYW5jaG9yIHRhZyBmcm9tIHJlY2VpdmluZyBmb2N1c1xuYXMgd2VsbCBieSBzZXR0aW5nIGl0cyB0YWJpbmRleCB0byAtMS5cblxuICAgIDxhIGhyZWY9XCJodHRwczovL3d3dy5wb2x5bWVyLXByb2plY3Qub3JnXCIgdGFiaW5kZXg9XCItMVwiPlxuICAgICAgPHBhcGVyLWljb24tYnV0dG9uIGljb249XCJwb2x5bWVyXCI+PC9wYXBlci1pY29uLWJ1dHRvbj5cbiAgICA8L2E+XG5cbiMjIyBTdHlsaW5nXG5cblN0eWxlIHRoZSBidXR0b24gd2l0aCBDU1MgYXMgeW91IHdvdWxkIGEgbm9ybWFsIERPTSBlbGVtZW50LiBJZiB5b3UgYXJlIHVzaW5nIHRoZSBpY29uc1xucHJvdmlkZWQgYnkgYGlyb24taWNvbnNgLCB0aGV5IHdpbGwgaW5oZXJpdCB0aGUgZm9yZWdyb3VuZCBjb2xvciBvZiB0aGUgYnV0dG9uLlxuXG4gICAgLyogbWFrZSBhIHJlZCBcImZhdm9yaXRlXCIgYnV0dG9uICovXG4gICAgPHBhcGVyLWljb24tYnV0dG9uIGljb249XCJmYXZvcml0ZVwiIHN0eWxlPVwiY29sb3I6IHJlZDtcIj48L3BhcGVyLWljb24tYnV0dG9uPlxuXG5CeSBkZWZhdWx0LCB0aGUgcmlwcGxlIGlzIHRoZSBzYW1lIGNvbG9yIGFzIHRoZSBmb3JlZ3JvdW5kIGF0IDI1JSBvcGFjaXR5LiBZb3UgbWF5XG5jdXN0b21pemUgdGhlIGNvbG9yIHVzaW5nIHRoZSBgLS1wYXBlci1pY29uLWJ1dHRvbi1pbmstY29sb3JgIGN1c3RvbSBwcm9wZXJ0eS5cblxuVGhlIGZvbGxvd2luZyBjdXN0b20gcHJvcGVydGllcyBhbmQgbWl4aW5zIGFyZSBhdmFpbGFibGUgZm9yIHN0eWxpbmc6XG5cbkN1c3RvbSBwcm9wZXJ0eSB8IERlc2NyaXB0aW9uIHwgRGVmYXVsdFxuLS0tLS0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tfC0tLS0tLS0tLS1cbmAtLXBhcGVyLWljb24tYnV0dG9uLWRpc2FibGVkLXRleHRgIHwgVGhlIGNvbG9yIG9mIHRoZSBkaXNhYmxlZCBidXR0b24gfCBgLS1kaXNhYmxlZC10ZXh0LWNvbG9yYFxuYC0tcGFwZXItaWNvbi1idXR0b24taW5rLWNvbG9yYCB8IFNlbGVjdGVkL2ZvY3VzIHJpcHBsZSBjb2xvciB8IGAtLXByaW1hcnktdGV4dC1jb2xvcmBcbmAtLXBhcGVyLWljb24tYnV0dG9uYCB8IE1peGluIGZvciBhIGJ1dHRvbiB8IGB7fWBcbmAtLXBhcGVyLWljb24tYnV0dG9uLWRpc2FibGVkYCB8IE1peGluIGZvciBhIGRpc2FibGVkIGJ1dHRvbiB8IGB7fWBcbmAtLXBhcGVyLWljb24tYnV0dG9uLWhvdmVyYCB8IE1peGluIGZvciBidXR0b24gb24gaG92ZXIgfCBge31gXG5cbkBncm91cCBQYXBlciBFbGVtZW50c1xuQGVsZW1lbnQgcGFwZXItaWNvbi1idXR0b25cbkBkZW1vIGRlbW8vaW5kZXguaHRtbFxuLS0+XG5cbjxkb20tbW9kdWxlIGlkPVwicGFwZXItaWNvbi1idXR0b25cIj5cbiAgPHRlbXBsYXRlIHN0cmlwLXdoaXRlc3BhY2U+XG4gICAgPHN0eWxlPlxuICAgICAgOmhvc3Qge1xuICAgICAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgcGFkZGluZzogOHB4O1xuICAgICAgICBvdXRsaW5lOiBub25lO1xuICAgICAgICAtd2Via2l0LXVzZXItc2VsZWN0OiBub25lO1xuICAgICAgICAtbW96LXVzZXItc2VsZWN0OiBub25lO1xuICAgICAgICAtbXMtdXNlci1zZWxlY3Q6IG5vbmU7XG4gICAgICAgIHVzZXItc2VsZWN0OiBub25lO1xuICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgICAgIHotaW5kZXg6IDA7XG4gICAgICAgIGxpbmUtaGVpZ2h0OiAxO1xuXG4gICAgICAgIHdpZHRoOiA0MHB4O1xuICAgICAgICBoZWlnaHQ6IDQwcHg7XG5cbiAgICAgICAgLyogTk9URTogQm90aCB2YWx1ZXMgYXJlIG5lZWRlZCwgc2luY2Ugc29tZSBwaG9uZXMgcmVxdWlyZSB0aGUgdmFsdWUgdG8gYmUgYHRyYW5zcGFyZW50YC4gKi9cbiAgICAgICAgLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yOiByZ2JhKDAsIDAsIDAsIDApO1xuICAgICAgICAtd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3I6IHRyYW5zcGFyZW50O1xuXG4gICAgICAgIC8qIEJlY2F1c2Ugb2YgcG9seW1lci8yNTU4LCB0aGlzIHN0eWxlIGhhcyBsb3dlciBzcGVjaWZpY2l0eSB0aGFuICogKi9cbiAgICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveCAhaW1wb3J0YW50O1xuXG4gICAgICAgIEBhcHBseSAtLXBhcGVyLWljb24tYnV0dG9uO1xuICAgICAgfVxuXG4gICAgICA6aG9zdCAjaW5rIHtcbiAgICAgICAgY29sb3I6IHZhcigtLXBhcGVyLWljb24tYnV0dG9uLWluay1jb2xvciwgdmFyKC0tcHJpbWFyeS10ZXh0LWNvbG9yKSk7XG4gICAgICAgIG9wYWNpdHk6IDAuNjtcbiAgICAgIH1cblxuICAgICAgOmhvc3QoW2Rpc2FibGVkXSkge1xuICAgICAgICBjb2xvcjogdmFyKC0tcGFwZXItaWNvbi1idXR0b24tZGlzYWJsZWQtdGV4dCwgdmFyKC0tZGlzYWJsZWQtdGV4dC1jb2xvcikpO1xuICAgICAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcbiAgICAgICAgY3Vyc29yOiBhdXRvO1xuXG4gICAgICAgIEBhcHBseSAtLXBhcGVyLWljb24tYnV0dG9uLWRpc2FibGVkO1xuICAgICAgfVxuXG4gICAgICA6aG9zdChbaGlkZGVuXSkge1xuICAgICAgICBkaXNwbGF5OiBub25lICFpbXBvcnRhbnQ7XG4gICAgICB9XG5cbiAgICAgIDpob3N0KDpob3Zlcikge1xuICAgICAgICBAYXBwbHkgLS1wYXBlci1pY29uLWJ1dHRvbi1ob3ZlcjtcbiAgICAgIH1cblxuICAgICAgaXJvbi1pY29uIHtcbiAgICAgICAgLS1pcm9uLWljb24td2lkdGg6IDEwMCU7XG4gICAgICAgIC0taXJvbi1pY29uLWhlaWdodDogMTAwJTtcbiAgICAgIH1cbiAgICA8L3N0eWxlPlxuXG4gICAgPGlyb24taWNvbiBpZD1cImljb25cIiBzcmM9XCJbW3NyY11dXCIgaWNvbj1cIltbaWNvbl1dXCIgYWx0JD1cIltbYWx0XV1cIj48L2lyb24taWNvbj5cbiAgPC90ZW1wbGF0ZT5cblxuICA8c2NyaXB0PlxuICAgIFBvbHltZXIoe1xuICAgICAgaXM6ICdwYXBlci1pY29uLWJ1dHRvbicsXG5cbiAgICAgIGhvc3RBdHRyaWJ1dGVzOiB7XG4gICAgICAgIHJvbGU6ICdidXR0b24nLFxuICAgICAgICB0YWJpbmRleDogJzAnXG4gICAgICB9LFxuXG4gICAgICBiZWhhdmlvcnM6IFtcbiAgICAgICAgUG9seW1lci5QYXBlcklua3lGb2N1c0JlaGF2aW9yXG4gICAgICBdLFxuXG4gICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgVVJMIG9mIGFuIGltYWdlIGZvciB0aGUgaWNvbi4gSWYgdGhlIHNyYyBwcm9wZXJ0eSBpcyBzcGVjaWZpZWQsXG4gICAgICAgICAqIHRoZSBpY29uIHByb3BlcnR5IHNob3VsZCBub3QgYmUuXG4gICAgICAgICAqL1xuICAgICAgICBzcmM6IHtcbiAgICAgICAgICB0eXBlOiBTdHJpbmdcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmaWVzIHRoZSBpY29uIG5hbWUgb3IgaW5kZXggaW4gdGhlIHNldCBvZiBpY29ucyBhdmFpbGFibGUgaW5cbiAgICAgICAgICogdGhlIGljb24ncyBpY29uIHNldC4gSWYgdGhlIGljb24gcHJvcGVydHkgaXMgc3BlY2lmaWVkLFxuICAgICAgICAgKiB0aGUgc3JjIHByb3BlcnR5IHNob3VsZCBub3QgYmUuXG4gICAgICAgICAqL1xuICAgICAgICBpY29uOiB7XG4gICAgICAgICAgdHlwZTogU3RyaW5nXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB0aGUgYWx0ZXJuYXRlIHRleHQgZm9yIHRoZSBidXR0b24sIGZvciBhY2Nlc3NpYmlsaXR5LlxuICAgICAgICAgKi9cbiAgICAgICAgYWx0OiB7XG4gICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgIG9ic2VydmVyOiBcIl9hbHRDaGFuZ2VkXCJcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgX2FsdENoYW5nZWQ6IGZ1bmN0aW9uKG5ld1ZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICB2YXIgbGFiZWwgPSB0aGlzLmdldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcpO1xuXG4gICAgICAgIC8vIERvbid0IHN0b21wIG92ZXIgYSB1c2VyLXNldCBhcmlhLWxhYmVsLlxuICAgICAgICBpZiAoIWxhYmVsIHx8IG9sZFZhbHVlID09IGxhYmVsKSB7XG4gICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnLCBuZXdWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgPC9zY3JpcHQ+XG48L2RvbS1tb2R1bGU+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL3BhcGVyLWljb24tYnV0dG9uL3BhcGVyLWljb24tYnV0dG9uLmh0bWwiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE1IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi9wb2x5bWVyL3BvbHltZXIuaHRtbFwiPlxuXG48c2NyaXB0PlxuXG4gIC8qKlxuICAgKiBAZGVtbyBkZW1vL2luZGV4Lmh0bWxcbiAgICogQHBvbHltZXJCZWhhdmlvclxuICAgKi9cbiAgUG9seW1lci5Jcm9uQ29udHJvbFN0YXRlID0ge1xuXG4gICAgcHJvcGVydGllczoge1xuXG4gICAgICAvKipcbiAgICAgICAqIElmIHRydWUsIHRoZSBlbGVtZW50IGN1cnJlbnRseSBoYXMgZm9jdXMuXG4gICAgICAgKi9cbiAgICAgIGZvY3VzZWQ6IHtcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgdmFsdWU6IGZhbHNlLFxuICAgICAgICBub3RpZnk6IHRydWUsXG4gICAgICAgIHJlYWRPbmx5OiB0cnVlLFxuICAgICAgICByZWZsZWN0VG9BdHRyaWJ1dGU6IHRydWVcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogSWYgdHJ1ZSwgdGhlIHVzZXIgY2Fubm90IGludGVyYWN0IHdpdGggdGhpcyBlbGVtZW50LlxuICAgICAgICovXG4gICAgICBkaXNhYmxlZDoge1xuICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICB2YWx1ZTogZmFsc2UsXG4gICAgICAgIG5vdGlmeTogdHJ1ZSxcbiAgICAgICAgb2JzZXJ2ZXI6ICdfZGlzYWJsZWRDaGFuZ2VkJyxcbiAgICAgICAgcmVmbGVjdFRvQXR0cmlidXRlOiB0cnVlXG4gICAgICB9LFxuXG4gICAgICBfb2xkVGFiSW5kZXg6IHtcbiAgICAgICAgdHlwZTogTnVtYmVyXG4gICAgICB9LFxuXG4gICAgICBfYm91bmRGb2N1c0JsdXJIYW5kbGVyOiB7XG4gICAgICAgIHR5cGU6IEZ1bmN0aW9uLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2ZvY3VzQmx1ckhhbmRsZXIuYmluZCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgX19oYW5kbGVFdmVudFJldGFyZ2V0aW5nOiB7XG4gICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gIXRoaXMuc2hhZG93Um9vdCAmJiAhUG9seW1lci5FbGVtZW50O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIG9ic2VydmVyczogW1xuICAgICAgJ19jaGFuZ2VkQ29udHJvbFN0YXRlKGZvY3VzZWQsIGRpc2FibGVkKSdcbiAgICBdLFxuXG4gICAgcmVhZHk6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdmb2N1cycsIHRoaXMuX2JvdW5kRm9jdXNCbHVySGFuZGxlciwgdHJ1ZSk7XG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCB0aGlzLl9ib3VuZEZvY3VzQmx1ckhhbmRsZXIsIHRydWUpO1xuICAgIH0sXG5cbiAgICBfZm9jdXNCbHVySGFuZGxlcjogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIC8vIEluIFBvbHltZXIgMi4wLCB0aGUgbGlicmFyeSB0YWtlcyBjYXJlIG9mIHJldGFyZ2V0aW5nIGV2ZW50cy5cbiAgICAgIGlmIChQb2x5bWVyLkVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5fc2V0Rm9jdXNlZChldmVudC50eXBlID09PSAnZm9jdXMnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBOT1RFKGNkYXRhKTogIGlmIHdlIGFyZSBpbiBTaGFkb3dET00gbGFuZCwgYGV2ZW50LnRhcmdldGAgd2lsbFxuICAgICAgLy8gZXZlbnR1YWxseSBiZWNvbWUgYHRoaXNgIGR1ZSB0byByZXRhcmdldGluZzsgaWYgd2UgYXJlIG5vdCBpblxuICAgICAgLy8gU2hhZG93RE9NIGxhbmQsIGBldmVudC50YXJnZXRgIHdpbGwgZXZlbnR1YWxseSBiZWNvbWUgYHRoaXNgIGR1ZVxuICAgICAgLy8gdG8gdGhlIHNlY29uZCBjb25kaXRpb25hbCB3aGljaCBmaXJlcyBhIHN5bnRoZXRpYyBldmVudCAodGhhdCBpcyBhbHNvXG4gICAgICAvLyBoYW5kbGVkKS4gSW4gZWl0aGVyIGNhc2UsIHdlIGNhbiBkaXNyZWdhcmQgYGV2ZW50LnBhdGhgLlxuICAgICAgaWYgKGV2ZW50LnRhcmdldCA9PT0gdGhpcykge1xuICAgICAgICB0aGlzLl9zZXRGb2N1c2VkKGV2ZW50LnR5cGUgPT09ICdmb2N1cycpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl9faGFuZGxlRXZlbnRSZXRhcmdldGluZykge1xuICAgICAgICB2YXIgdGFyZ2V0ID0gLyoqIEB0eXBlIHtOb2RlfSAqLyhQb2x5bWVyLmRvbShldmVudCkubG9jYWxUYXJnZXQpO1xuICAgICAgICBpZiAoIXRoaXMuaXNMaWdodERlc2NlbmRhbnQodGFyZ2V0KSkge1xuICAgICAgICAgIHRoaXMuZmlyZShldmVudC50eXBlLCB7c291cmNlRXZlbnQ6IGV2ZW50fSwge1xuICAgICAgICAgICAgbm9kZTogdGhpcyxcbiAgICAgICAgICAgIGJ1YmJsZXM6IGV2ZW50LmJ1YmJsZXMsXG4gICAgICAgICAgICBjYW5jZWxhYmxlOiBldmVudC5jYW5jZWxhYmxlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgX2Rpc2FibGVkQ2hhbmdlZDogZnVuY3Rpb24oZGlzYWJsZWQsIG9sZCkge1xuICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2FyaWEtZGlzYWJsZWQnLCBkaXNhYmxlZCA/ICd0cnVlJyA6ICdmYWxzZScpO1xuICAgICAgdGhpcy5zdHlsZS5wb2ludGVyRXZlbnRzID0gZGlzYWJsZWQgPyAnbm9uZScgOiAnJztcbiAgICAgIGlmIChkaXNhYmxlZCkge1xuICAgICAgICB0aGlzLl9vbGRUYWJJbmRleCA9IHRoaXMudGFiSW5kZXg7XG4gICAgICAgIHRoaXMuX3NldEZvY3VzZWQoZmFsc2UpO1xuICAgICAgICB0aGlzLnRhYkluZGV4ID0gLTE7XG4gICAgICAgIHRoaXMuYmx1cigpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl9vbGRUYWJJbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMudGFiSW5kZXggPSB0aGlzLl9vbGRUYWJJbmRleDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgX2NoYW5nZWRDb250cm9sU3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gX2NvbnRyb2xTdGF0ZUNoYW5nZWQgaXMgYWJzdHJhY3QsIGZvbGxvdy1vbiBiZWhhdmlvcnMgbWF5IGltcGxlbWVudCBpdFxuICAgICAgaWYgKHRoaXMuX2NvbnRyb2xTdGF0ZUNoYW5nZWQpIHtcbiAgICAgICAgdGhpcy5fY29udHJvbFN0YXRlQ2hhbmdlZCgpO1xuICAgICAgfVxuICAgIH1cblxuICB9O1xuXG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvaXJvbi1iZWhhdmlvcnMvaXJvbi1jb250cm9sLXN0YXRlLmh0bWwiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE0IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi9wb2x5bWVyL3BvbHltZXIuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL2lyb24tYTExeS1rZXlzLWJlaGF2aW9yL2lyb24tYTExeS1rZXlzLWJlaGF2aW9yLmh0bWxcIj5cblxuPCEtLVxuTWF0ZXJpYWwgZGVzaWduOiBbU3VyZmFjZSByZWFjdGlvbl0oaHR0cHM6Ly93d3cuZ29vZ2xlLmNvbS9kZXNpZ24vc3BlYy9hbmltYXRpb24vcmVzcG9uc2l2ZS1pbnRlcmFjdGlvbi5odG1sI3Jlc3BvbnNpdmUtaW50ZXJhY3Rpb24tc3VyZmFjZS1yZWFjdGlvbilcblxuYHBhcGVyLXJpcHBsZWAgcHJvdmlkZXMgYSB2aXN1YWwgZWZmZWN0IHRoYXQgb3RoZXIgcGFwZXIgZWxlbWVudHMgY2FuXG51c2UgdG8gc2ltdWxhdGUgYSByaXBwbGluZyBlZmZlY3QgZW1hbmF0aW5nIGZyb20gdGhlIHBvaW50IG9mIGNvbnRhY3QuICBUaGVcbmVmZmVjdCBjYW4gYmUgdmlzdWFsaXplZCBhcyBhIGNvbmNlbnRyaWMgY2lyY2xlIHdpdGggbW90aW9uLlxuXG5FeGFtcGxlOlxuXG4gICAgPGRpdiBzdHlsZT1cInBvc2l0aW9uOnJlbGF0aXZlXCI+XG4gICAgICA8cGFwZXItcmlwcGxlPjwvcGFwZXItcmlwcGxlPlxuICAgIDwvZGl2PlxuXG5Ob3RlLCBpdCdzIGltcG9ydGFudCB0aGF0IHRoZSBwYXJlbnQgY29udGFpbmVyIG9mIHRoZSByaXBwbGUgYmUgcmVsYXRpdmUgcG9zaXRpb24sIG90aGVyd2lzZVxudGhlIHJpcHBsZSB3aWxsIGVtYW5hdGUgb3V0c2lkZSBvZiB0aGUgZGVzaXJlZCBjb250YWluZXIuXG5cbmBwYXBlci1yaXBwbGVgIGxpc3RlbnMgdG8gXCJtb3VzZWRvd25cIiBhbmQgXCJtb3VzZXVwXCIgZXZlbnRzIHNvIGl0IHdvdWxkIGRpc3BsYXkgcmlwcGxlXG5lZmZlY3Qgd2hlbiB0b3VjaGVzIG9uIGl0LiAgWW91IGNhbiBhbHNvIGRlZmVhdCB0aGUgZGVmYXVsdCBiZWhhdmlvciBhbmRcbm1hbnVhbGx5IHJvdXRlIHRoZSBkb3duIGFuZCB1cCBhY3Rpb25zIHRvIHRoZSByaXBwbGUgZWxlbWVudC4gIE5vdGUgdGhhdCBpdCBpc1xuaW1wb3J0YW50IGlmIHlvdSBjYWxsIGBkb3duQWN0aW9uKClgIHlvdSB3aWxsIGhhdmUgdG8gbWFrZSBzdXJlIHRvIGNhbGxcbmB1cEFjdGlvbigpYCBzbyB0aGF0IGBwYXBlci1yaXBwbGVgIHdvdWxkIGVuZCB0aGUgYW5pbWF0aW9uIGxvb3AuXG5cbkV4YW1wbGU6XG5cbiAgICA8cGFwZXItcmlwcGxlIGlkPVwicmlwcGxlXCIgc3R5bGU9XCJwb2ludGVyLWV2ZW50czogbm9uZTtcIj48L3BhcGVyLXJpcHBsZT5cbiAgICAuLi5cbiAgICBkb3duQWN0aW9uOiBmdW5jdGlvbihlKSB7XG4gICAgICB0aGlzLiQucmlwcGxlLmRvd25BY3Rpb24oZS5kZXRhaWwpO1xuICAgIH0sXG4gICAgdXBBY3Rpb246IGZ1bmN0aW9uKGUpIHtcbiAgICAgIHRoaXMuJC5yaXBwbGUudXBBY3Rpb24oKTtcbiAgICB9XG5cblN0eWxpbmcgcmlwcGxlIGVmZmVjdDpcblxuICBVc2UgQ1NTIGNvbG9yIHByb3BlcnR5IHRvIHN0eWxlIHRoZSByaXBwbGU6XG5cbiAgICBwYXBlci1yaXBwbGUge1xuICAgICAgY29sb3I6ICM0Mjg1ZjQ7XG4gICAgfVxuXG4gIE5vdGUgdGhhdCBDU1MgY29sb3IgcHJvcGVydHkgaXMgaW5oZXJpdGVkIHNvIGl0IGlzIG5vdCByZXF1aXJlZCB0byBzZXQgaXQgb25cbiAgdGhlIGBwYXBlci1yaXBwbGVgIGVsZW1lbnQgZGlyZWN0bHkuXG5cbkJ5IGRlZmF1bHQsIHRoZSByaXBwbGUgaXMgY2VudGVyZWQgb24gdGhlIHBvaW50IG9mIGNvbnRhY3QuICBBcHBseSB0aGUgYHJlY2VudGVyc2BcbmF0dHJpYnV0ZSB0byBoYXZlIHRoZSByaXBwbGUgZ3JvdyB0b3dhcmQgdGhlIGNlbnRlciBvZiBpdHMgY29udGFpbmVyLlxuXG4gICAgPHBhcGVyLXJpcHBsZSByZWNlbnRlcnM+PC9wYXBlci1yaXBwbGU+XG5cbllvdSBjYW4gYWxzbyAgY2VudGVyIHRoZSByaXBwbGUgaW5zaWRlIGl0cyBjb250YWluZXIgZnJvbSB0aGUgc3RhcnQuXG5cbiAgICA8cGFwZXItcmlwcGxlIGNlbnRlcj48L3BhcGVyLXJpcHBsZT5cblxuQXBwbHkgYGNpcmNsZWAgY2xhc3MgdG8gbWFrZSB0aGUgcmlwcGxpbmcgZWZmZWN0IHdpdGhpbiBhIGNpcmNsZS5cblxuICAgIDxwYXBlci1yaXBwbGUgY2xhc3M9XCJjaXJjbGVcIj48L3BhcGVyLXJpcHBsZT5cblxuQGdyb3VwIFBhcGVyIEVsZW1lbnRzXG5AZWxlbWVudCBwYXBlci1yaXBwbGVcbkBoZXJvIGhlcm8uc3ZnXG5AZGVtbyBkZW1vL2luZGV4Lmh0bWxcbi0tPlxuXG48ZG9tLW1vZHVsZSBpZD1cInBhcGVyLXJpcHBsZVwiPlxuXG4gIDx0ZW1wbGF0ZT5cbiAgICA8c3R5bGU+XG4gICAgICA6aG9zdCB7XG4gICAgICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IGluaGVyaXQ7XG4gICAgICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgICAgIHRvcDogMDtcbiAgICAgICAgbGVmdDogMDtcbiAgICAgICAgcmlnaHQ6IDA7XG4gICAgICAgIGJvdHRvbTogMDtcblxuICAgICAgICAvKiBTZWUgUG9seW1lckVsZW1lbnRzL3BhcGVyLWJlaGF2aW9ycy9pc3N1ZXMvMzQuIE9uIG5vbi1DaHJvbWUgYnJvd3NlcnMsXG4gICAgICAgICAqIGNyZWF0aW5nIGEgbm9kZSAod2l0aCBhIHBvc2l0aW9uOmFic29sdXRlKSBpbiB0aGUgbWlkZGxlIG9mIGFuIGV2ZW50XG4gICAgICAgICAqIGhhbmRsZXIgXCJpbnRlcnJ1cHRzXCIgdGhhdCBldmVudCBoYW5kbGVyICh3aGljaCBoYXBwZW5zIHdoZW4gdGhlXG4gICAgICAgICAqIHJpcHBsZSBpcyBjcmVhdGVkIG9uIGRlbWFuZCkgKi9cbiAgICAgICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG4gICAgICB9XG5cbiAgICAgIDpob3N0KFthbmltYXRpbmddKSB7XG4gICAgICAgIC8qIFRoaXMgcmVzb2x2ZXMgYSByZW5kZXJpbmcgaXNzdWUgaW4gQ2hyb21lIChhcyBvZiA0MCkgd2hlcmUgdGhlXG4gICAgICAgICAgIHJpcHBsZSBpcyBub3QgcHJvcGVybHkgY2xpcHBlZCBieSBpdHMgcGFyZW50ICh3aGljaCBtYXkgaGF2ZVxuICAgICAgICAgICByb3VuZGVkIGNvcm5lcnMpLiBTZWU6IGh0dHA6Ly9qc2Jpbi5jb20vdGVtZXhhLzRcblxuICAgICAgICAgICBOb3RlOiBXZSBvbmx5IGFwcGx5IHRoaXMgc3R5bGUgY29uZGl0aW9uYWxseS4gT3RoZXJ3aXNlLCB0aGUgYnJvd3NlclxuICAgICAgICAgICB3aWxsIGNyZWF0ZSBhIG5ldyBjb21wb3NpdGluZyBsYXllciBmb3IgZXZlcnkgcmlwcGxlIGVsZW1lbnQgb24gdGhlXG4gICAgICAgICAgIHBhZ2UsIGFuZCB0aGF0IHdvdWxkIGJlIGJhZC4gKi9cbiAgICAgICAgLXdlYmtpdC10cmFuc2Zvcm06IHRyYW5zbGF0ZSgwLCAwKTtcbiAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgwLCAwLCAwKTtcbiAgICAgIH1cblxuICAgICAgI2JhY2tncm91bmQsXG4gICAgICAjd2F2ZXMsXG4gICAgICAud2F2ZS1jb250YWluZXIsXG4gICAgICAud2F2ZSB7XG4gICAgICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIHRvcDogMDtcbiAgICAgICAgbGVmdDogMDtcbiAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgIGhlaWdodDogMTAwJTtcbiAgICAgIH1cblxuICAgICAgI2JhY2tncm91bmQsXG4gICAgICAud2F2ZSB7XG4gICAgICAgIG9wYWNpdHk6IDA7XG4gICAgICB9XG5cbiAgICAgICN3YXZlcyxcbiAgICAgIC53YXZlIHtcbiAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICAgIH1cblxuICAgICAgLndhdmUtY29udGFpbmVyLFxuICAgICAgLndhdmUge1xuICAgICAgICBib3JkZXItcmFkaXVzOiA1MCU7XG4gICAgICB9XG5cbiAgICAgIDpob3N0KC5jaXJjbGUpICNiYWNrZ3JvdW5kLFxuICAgICAgOmhvc3QoLmNpcmNsZSkgI3dhdmVzIHtcbiAgICAgICAgYm9yZGVyLXJhZGl1czogNTAlO1xuICAgICAgfVxuXG4gICAgICA6aG9zdCguY2lyY2xlKSAud2F2ZS1jb250YWluZXIge1xuICAgICAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgICAgfVxuICAgIDwvc3R5bGU+XG5cbiAgICA8ZGl2IGlkPVwiYmFja2dyb3VuZFwiPjwvZGl2PlxuICAgIDxkaXYgaWQ9XCJ3YXZlc1wiPjwvZGl2PlxuICA8L3RlbXBsYXRlPlxuPC9kb20tbW9kdWxlPlxuPHNjcmlwdD5cbiAgKGZ1bmN0aW9uKCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBVdGlsaXR5ID0ge1xuICAgICAgZGlzdGFuY2U6IGZ1bmN0aW9uKHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgICAgIHZhciB4RGVsdGEgPSAoeDEgLSB4Mik7XG4gICAgICAgIHZhciB5RGVsdGEgPSAoeTEgLSB5Mik7XG5cbiAgICAgICAgcmV0dXJuIE1hdGguc3FydCh4RGVsdGEgKiB4RGVsdGEgKyB5RGVsdGEgKiB5RGVsdGEpO1xuICAgICAgfSxcblxuICAgICAgbm93OiB3aW5kb3cucGVyZm9ybWFuY2UgJiYgd2luZG93LnBlcmZvcm1hbmNlLm5vdyA/XG4gICAgICAgICAgd2luZG93LnBlcmZvcm1hbmNlLm5vdy5iaW5kKHdpbmRvdy5wZXJmb3JtYW5jZSkgOiBEYXRlLm5vd1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gRWxlbWVudE1ldHJpY3MoZWxlbWVudCkge1xuICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgIHRoaXMud2lkdGggPSB0aGlzLmJvdW5kaW5nUmVjdC53aWR0aDtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5ib3VuZGluZ1JlY3QuaGVpZ2h0O1xuXG4gICAgICB0aGlzLnNpemUgPSBNYXRoLm1heCh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgfVxuXG4gICAgRWxlbWVudE1ldHJpY3MucHJvdG90eXBlID0ge1xuICAgICAgZ2V0IGJvdW5kaW5nUmVjdCAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB9LFxuXG4gICAgICBmdXJ0aGVzdENvcm5lckRpc3RhbmNlRnJvbTogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICB2YXIgdG9wTGVmdCA9IFV0aWxpdHkuZGlzdGFuY2UoeCwgeSwgMCwgMCk7XG4gICAgICAgIHZhciB0b3BSaWdodCA9IFV0aWxpdHkuZGlzdGFuY2UoeCwgeSwgdGhpcy53aWR0aCwgMCk7XG4gICAgICAgIHZhciBib3R0b21MZWZ0ID0gVXRpbGl0eS5kaXN0YW5jZSh4LCB5LCAwLCB0aGlzLmhlaWdodCk7XG4gICAgICAgIHZhciBib3R0b21SaWdodCA9IFV0aWxpdHkuZGlzdGFuY2UoeCwgeSwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuXG4gICAgICAgIHJldHVybiBNYXRoLm1heCh0b3BMZWZ0LCB0b3BSaWdodCwgYm90dG9tTGVmdCwgYm90dG9tUmlnaHQpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gUmlwcGxlKGVsZW1lbnQpIHtcbiAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICB0aGlzLmNvbG9yID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkuY29sb3I7XG5cbiAgICAgIHRoaXMud2F2ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgdGhpcy53YXZlQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICB0aGlzLndhdmUuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gdGhpcy5jb2xvcjtcbiAgICAgIHRoaXMud2F2ZS5jbGFzc0xpc3QuYWRkKCd3YXZlJyk7XG4gICAgICB0aGlzLndhdmVDb250YWluZXIuY2xhc3NMaXN0LmFkZCgnd2F2ZS1jb250YWluZXInKTtcbiAgICAgIFBvbHltZXIuZG9tKHRoaXMud2F2ZUNvbnRhaW5lcikuYXBwZW5kQ2hpbGQodGhpcy53YXZlKTtcblxuICAgICAgdGhpcy5yZXNldEludGVyYWN0aW9uU3RhdGUoKTtcbiAgICB9XG5cbiAgICBSaXBwbGUuTUFYX1JBRElVUyA9IDMwMDtcblxuICAgIFJpcHBsZS5wcm90b3R5cGUgPSB7XG4gICAgICBnZXQgcmVjZW50ZXJzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50LnJlY2VudGVycztcbiAgICAgIH0sXG5cbiAgICAgIGdldCBjZW50ZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnQuY2VudGVyO1xuICAgICAgfSxcblxuICAgICAgZ2V0IG1vdXNlRG93bkVsYXBzZWQoKSB7XG4gICAgICAgIHZhciBlbGFwc2VkO1xuXG4gICAgICAgIGlmICghdGhpcy5tb3VzZURvd25TdGFydCkge1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgZWxhcHNlZCA9IFV0aWxpdHkubm93KCkgLSB0aGlzLm1vdXNlRG93blN0YXJ0O1xuXG4gICAgICAgIGlmICh0aGlzLm1vdXNlVXBTdGFydCkge1xuICAgICAgICAgIGVsYXBzZWQgLT0gdGhpcy5tb3VzZVVwRWxhcHNlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBlbGFwc2VkO1xuICAgICAgfSxcblxuICAgICAgZ2V0IG1vdXNlVXBFbGFwc2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb3VzZVVwU3RhcnQgP1xuICAgICAgICAgIFV0aWxpdHkubm93ICgpIC0gdGhpcy5tb3VzZVVwU3RhcnQgOiAwO1xuICAgICAgfSxcblxuICAgICAgZ2V0IG1vdXNlRG93bkVsYXBzZWRTZWNvbmRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb3VzZURvd25FbGFwc2VkIC8gMTAwMDtcbiAgICAgIH0sXG5cbiAgICAgIGdldCBtb3VzZVVwRWxhcHNlZFNlY29uZHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vdXNlVXBFbGFwc2VkIC8gMTAwMDtcbiAgICAgIH0sXG5cbiAgICAgIGdldCBtb3VzZUludGVyYWN0aW9uU2Vjb25kcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW91c2VEb3duRWxhcHNlZFNlY29uZHMgKyB0aGlzLm1vdXNlVXBFbGFwc2VkU2Vjb25kcztcbiAgICAgIH0sXG5cbiAgICAgIGdldCBpbml0aWFsT3BhY2l0eSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudC5pbml0aWFsT3BhY2l0eTtcbiAgICAgIH0sXG5cbiAgICAgIGdldCBvcGFjaXR5RGVjYXlWZWxvY2l0eSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudC5vcGFjaXR5RGVjYXlWZWxvY2l0eTtcbiAgICAgIH0sXG5cbiAgICAgIGdldCByYWRpdXMoKSB7XG4gICAgICAgIHZhciB3aWR0aDIgPSB0aGlzLmNvbnRhaW5lck1ldHJpY3Mud2lkdGggKiB0aGlzLmNvbnRhaW5lck1ldHJpY3Mud2lkdGg7XG4gICAgICAgIHZhciBoZWlnaHQyID0gdGhpcy5jb250YWluZXJNZXRyaWNzLmhlaWdodCAqIHRoaXMuY29udGFpbmVyTWV0cmljcy5oZWlnaHQ7XG4gICAgICAgIHZhciB3YXZlUmFkaXVzID0gTWF0aC5taW4oXG4gICAgICAgICAgTWF0aC5zcXJ0KHdpZHRoMiArIGhlaWdodDIpLFxuICAgICAgICAgIFJpcHBsZS5NQVhfUkFESVVTXG4gICAgICAgICkgKiAxLjEgKyA1O1xuXG4gICAgICAgIHZhciBkdXJhdGlvbiA9IDEuMSAtIDAuMiAqICh3YXZlUmFkaXVzIC8gUmlwcGxlLk1BWF9SQURJVVMpO1xuICAgICAgICB2YXIgdGltZU5vdyA9IHRoaXMubW91c2VJbnRlcmFjdGlvblNlY29uZHMgLyBkdXJhdGlvbjtcbiAgICAgICAgdmFyIHNpemUgPSB3YXZlUmFkaXVzICogKDEgLSBNYXRoLnBvdyg4MCwgLXRpbWVOb3cpKTtcblxuICAgICAgICByZXR1cm4gTWF0aC5hYnMoc2l6ZSk7XG4gICAgICB9LFxuXG4gICAgICBnZXQgb3BhY2l0eSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLm1vdXNlVXBTdGFydCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmluaXRpYWxPcGFjaXR5O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KFxuICAgICAgICAgIDAsXG4gICAgICAgICAgdGhpcy5pbml0aWFsT3BhY2l0eSAtIHRoaXMubW91c2VVcEVsYXBzZWRTZWNvbmRzICogdGhpcy5vcGFjaXR5RGVjYXlWZWxvY2l0eVxuICAgICAgICApO1xuICAgICAgfSxcblxuICAgICAgZ2V0IG91dGVyT3BhY2l0eSgpIHtcbiAgICAgICAgLy8gTGluZWFyIGluY3JlYXNlIGluIGJhY2tncm91bmQgb3BhY2l0eSwgY2FwcGVkIGF0IHRoZSBvcGFjaXR5XG4gICAgICAgIC8vIG9mIHRoZSB3YXZlZnJvbnQgKHdhdmVPcGFjaXR5KS5cbiAgICAgICAgdmFyIG91dGVyT3BhY2l0eSA9IHRoaXMubW91c2VVcEVsYXBzZWRTZWNvbmRzICogMC4zO1xuICAgICAgICB2YXIgd2F2ZU9wYWNpdHkgPSB0aGlzLm9wYWNpdHk7XG5cbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KFxuICAgICAgICAgIDAsXG4gICAgICAgICAgTWF0aC5taW4ob3V0ZXJPcGFjaXR5LCB3YXZlT3BhY2l0eSlcbiAgICAgICAgKTtcbiAgICAgIH0sXG5cbiAgICAgIGdldCBpc09wYWNpdHlGdWxseURlY2F5ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wYWNpdHkgPCAwLjAxICYmXG4gICAgICAgICAgdGhpcy5yYWRpdXMgPj0gTWF0aC5taW4odGhpcy5tYXhSYWRpdXMsIFJpcHBsZS5NQVhfUkFESVVTKTtcbiAgICAgIH0sXG5cbiAgICAgIGdldCBpc1Jlc3RpbmdBdE1heFJhZGl1cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3BhY2l0eSA+PSB0aGlzLmluaXRpYWxPcGFjaXR5ICYmXG4gICAgICAgICAgdGhpcy5yYWRpdXMgPj0gTWF0aC5taW4odGhpcy5tYXhSYWRpdXMsIFJpcHBsZS5NQVhfUkFESVVTKTtcbiAgICAgIH0sXG5cbiAgICAgIGdldCBpc0FuaW1hdGlvbkNvbXBsZXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb3VzZVVwU3RhcnQgP1xuICAgICAgICAgIHRoaXMuaXNPcGFjaXR5RnVsbHlEZWNheWVkIDogdGhpcy5pc1Jlc3RpbmdBdE1heFJhZGl1cztcbiAgICAgIH0sXG5cbiAgICAgIGdldCB0cmFuc2xhdGlvbkZyYWN0aW9uKCkge1xuICAgICAgICByZXR1cm4gTWF0aC5taW4oXG4gICAgICAgICAgMSxcbiAgICAgICAgICB0aGlzLnJhZGl1cyAvIHRoaXMuY29udGFpbmVyTWV0cmljcy5zaXplICogMiAvIE1hdGguc3FydCgyKVxuICAgICAgICApO1xuICAgICAgfSxcblxuICAgICAgZ2V0IHhOb3coKSB7XG4gICAgICAgIGlmICh0aGlzLnhFbmQpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy54U3RhcnQgKyB0aGlzLnRyYW5zbGF0aW9uRnJhY3Rpb24gKiAodGhpcy54RW5kIC0gdGhpcy54U3RhcnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMueFN0YXJ0O1xuICAgICAgfSxcblxuICAgICAgZ2V0IHlOb3coKSB7XG4gICAgICAgIGlmICh0aGlzLnlFbmQpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy55U3RhcnQgKyB0aGlzLnRyYW5zbGF0aW9uRnJhY3Rpb24gKiAodGhpcy55RW5kIC0gdGhpcy55U3RhcnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMueVN0YXJ0O1xuICAgICAgfSxcblxuICAgICAgZ2V0IGlzTW91c2VEb3duKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb3VzZURvd25TdGFydCAmJiAhdGhpcy5tb3VzZVVwU3RhcnQ7XG4gICAgICB9LFxuXG4gICAgICByZXNldEludGVyYWN0aW9uU3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLm1heFJhZGl1cyA9IDA7XG4gICAgICAgIHRoaXMubW91c2VEb3duU3RhcnQgPSAwO1xuICAgICAgICB0aGlzLm1vdXNlVXBTdGFydCA9IDA7XG5cbiAgICAgICAgdGhpcy54U3RhcnQgPSAwO1xuICAgICAgICB0aGlzLnlTdGFydCA9IDA7XG4gICAgICAgIHRoaXMueEVuZCA9IDA7XG4gICAgICAgIHRoaXMueUVuZCA9IDA7XG4gICAgICAgIHRoaXMuc2xpZGVEaXN0YW5jZSA9IDA7XG5cbiAgICAgICAgdGhpcy5jb250YWluZXJNZXRyaWNzID0gbmV3IEVsZW1lbnRNZXRyaWNzKHRoaXMuZWxlbWVudCk7XG4gICAgICB9LFxuXG4gICAgICBkcmF3OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNjYWxlO1xuICAgICAgICB2YXIgdHJhbnNsYXRlU3RyaW5nO1xuICAgICAgICB2YXIgZHg7XG4gICAgICAgIHZhciBkeTtcblxuICAgICAgICB0aGlzLndhdmUuc3R5bGUub3BhY2l0eSA9IHRoaXMub3BhY2l0eTtcblxuICAgICAgICBzY2FsZSA9IHRoaXMucmFkaXVzIC8gKHRoaXMuY29udGFpbmVyTWV0cmljcy5zaXplIC8gMik7XG4gICAgICAgIGR4ID0gdGhpcy54Tm93IC0gKHRoaXMuY29udGFpbmVyTWV0cmljcy53aWR0aCAvIDIpO1xuICAgICAgICBkeSA9IHRoaXMueU5vdyAtICh0aGlzLmNvbnRhaW5lck1ldHJpY3MuaGVpZ2h0IC8gMik7XG5cblxuICAgICAgICAvLyAyZCB0cmFuc2Zvcm0gZm9yIHNhZmFyaSBiZWNhdXNlIG9mIGJvcmRlci1yYWRpdXMgYW5kIG92ZXJmbG93OmhpZGRlbiBjbGlwcGluZyBidWcuXG4gICAgICAgIC8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD05ODUzOFxuICAgICAgICB0aGlzLndhdmVDb250YWluZXIuc3R5bGUud2Via2l0VHJhbnNmb3JtID0gJ3RyYW5zbGF0ZSgnICsgZHggKyAncHgsICcgKyBkeSArICdweCknO1xuICAgICAgICB0aGlzLndhdmVDb250YWluZXIuc3R5bGUudHJhbnNmb3JtID0gJ3RyYW5zbGF0ZTNkKCcgKyBkeCArICdweCwgJyArIGR5ICsgJ3B4LCAwKSc7XG4gICAgICAgIHRoaXMud2F2ZS5zdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSAnc2NhbGUoJyArIHNjYWxlICsgJywnICsgc2NhbGUgKyAnKSc7XG4gICAgICAgIHRoaXMud2F2ZS5zdHlsZS50cmFuc2Zvcm0gPSAnc2NhbGUzZCgnICsgc2NhbGUgKyAnLCcgKyBzY2FsZSArICcsMSknO1xuICAgICAgfSxcblxuICAgICAgLyoqIEBwYXJhbSB7RXZlbnQ9fSBldmVudCAqL1xuICAgICAgZG93bkFjdGlvbjogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgdmFyIHhDZW50ZXIgPSB0aGlzLmNvbnRhaW5lck1ldHJpY3Mud2lkdGggLyAyO1xuICAgICAgICB2YXIgeUNlbnRlciA9IHRoaXMuY29udGFpbmVyTWV0cmljcy5oZWlnaHQgLyAyO1xuXG4gICAgICAgIHRoaXMucmVzZXRJbnRlcmFjdGlvblN0YXRlKCk7XG4gICAgICAgIHRoaXMubW91c2VEb3duU3RhcnQgPSBVdGlsaXR5Lm5vdygpO1xuXG4gICAgICAgIGlmICh0aGlzLmNlbnRlcikge1xuICAgICAgICAgIHRoaXMueFN0YXJ0ID0geENlbnRlcjtcbiAgICAgICAgICB0aGlzLnlTdGFydCA9IHlDZW50ZXI7XG4gICAgICAgICAgdGhpcy5zbGlkZURpc3RhbmNlID0gVXRpbGl0eS5kaXN0YW5jZShcbiAgICAgICAgICAgIHRoaXMueFN0YXJ0LCB0aGlzLnlTdGFydCwgdGhpcy54RW5kLCB0aGlzLnlFbmRcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMueFN0YXJ0ID0gZXZlbnQgP1xuICAgICAgICAgICAgICBldmVudC5kZXRhaWwueCAtIHRoaXMuY29udGFpbmVyTWV0cmljcy5ib3VuZGluZ1JlY3QubGVmdCA6XG4gICAgICAgICAgICAgIHRoaXMuY29udGFpbmVyTWV0cmljcy53aWR0aCAvIDI7XG4gICAgICAgICAgdGhpcy55U3RhcnQgPSBldmVudCA/XG4gICAgICAgICAgICAgIGV2ZW50LmRldGFpbC55IC0gdGhpcy5jb250YWluZXJNZXRyaWNzLmJvdW5kaW5nUmVjdC50b3AgOlxuICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lck1ldHJpY3MuaGVpZ2h0IC8gMjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnJlY2VudGVycykge1xuICAgICAgICAgIHRoaXMueEVuZCA9IHhDZW50ZXI7XG4gICAgICAgICAgdGhpcy55RW5kID0geUNlbnRlcjtcbiAgICAgICAgICB0aGlzLnNsaWRlRGlzdGFuY2UgPSBVdGlsaXR5LmRpc3RhbmNlKFxuICAgICAgICAgICAgdGhpcy54U3RhcnQsIHRoaXMueVN0YXJ0LCB0aGlzLnhFbmQsIHRoaXMueUVuZFxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm1heFJhZGl1cyA9IHRoaXMuY29udGFpbmVyTWV0cmljcy5mdXJ0aGVzdENvcm5lckRpc3RhbmNlRnJvbShcbiAgICAgICAgICB0aGlzLnhTdGFydCxcbiAgICAgICAgICB0aGlzLnlTdGFydFxuICAgICAgICApO1xuXG4gICAgICAgIHRoaXMud2F2ZUNvbnRhaW5lci5zdHlsZS50b3AgPVxuICAgICAgICAgICh0aGlzLmNvbnRhaW5lck1ldHJpY3MuaGVpZ2h0IC0gdGhpcy5jb250YWluZXJNZXRyaWNzLnNpemUpIC8gMiArICdweCc7XG4gICAgICAgIHRoaXMud2F2ZUNvbnRhaW5lci5zdHlsZS5sZWZ0ID1cbiAgICAgICAgICAodGhpcy5jb250YWluZXJNZXRyaWNzLndpZHRoIC0gdGhpcy5jb250YWluZXJNZXRyaWNzLnNpemUpIC8gMiArICdweCc7XG5cbiAgICAgICAgdGhpcy53YXZlQ29udGFpbmVyLnN0eWxlLndpZHRoID0gdGhpcy5jb250YWluZXJNZXRyaWNzLnNpemUgKyAncHgnO1xuICAgICAgICB0aGlzLndhdmVDb250YWluZXIuc3R5bGUuaGVpZ2h0ID0gdGhpcy5jb250YWluZXJNZXRyaWNzLnNpemUgKyAncHgnO1xuICAgICAgfSxcblxuICAgICAgLyoqIEBwYXJhbSB7RXZlbnQ9fSBldmVudCAqL1xuICAgICAgdXBBY3Rpb246IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIGlmICghdGhpcy5pc01vdXNlRG93bikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubW91c2VVcFN0YXJ0ID0gVXRpbGl0eS5ub3coKTtcbiAgICAgIH0sXG5cbiAgICAgIHJlbW92ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIFBvbHltZXIuZG9tKHRoaXMud2F2ZUNvbnRhaW5lci5wYXJlbnROb2RlKS5yZW1vdmVDaGlsZChcbiAgICAgICAgICB0aGlzLndhdmVDb250YWluZXJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgUG9seW1lcih7XG4gICAgICBpczogJ3BhcGVyLXJpcHBsZScsXG5cbiAgICAgIGJlaGF2aW9yczogW1xuICAgICAgICBQb2x5bWVyLklyb25BMTF5S2V5c0JlaGF2aW9yXG4gICAgICBdLFxuXG4gICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgaW5pdGlhbCBvcGFjaXR5IHNldCBvbiB0aGUgd2F2ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQGF0dHJpYnV0ZSBpbml0aWFsT3BhY2l0eVxuICAgICAgICAgKiBAdHlwZSBudW1iZXJcbiAgICAgICAgICogQGRlZmF1bHQgMC4yNVxuICAgICAgICAgKi9cbiAgICAgICAgaW5pdGlhbE9wYWNpdHk6IHtcbiAgICAgICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICAgICAgdmFsdWU6IDAuMjVcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSG93IGZhc3QgKG9wYWNpdHkgcGVyIHNlY29uZCkgdGhlIHdhdmUgZmFkZXMgb3V0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAYXR0cmlidXRlIG9wYWNpdHlEZWNheVZlbG9jaXR5XG4gICAgICAgICAqIEB0eXBlIG51bWJlclxuICAgICAgICAgKiBAZGVmYXVsdCAwLjhcbiAgICAgICAgICovXG4gICAgICAgIG9wYWNpdHlEZWNheVZlbG9jaXR5OiB7XG4gICAgICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgICAgIHZhbHVlOiAwLjhcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgdHJ1ZSwgcmlwcGxlcyB3aWxsIGV4aGliaXQgYSBncmF2aXRhdGlvbmFsIHB1bGwgdG93YXJkc1xuICAgICAgICAgKiB0aGUgY2VudGVyIG9mIHRoZWlyIGNvbnRhaW5lciBhcyB0aGV5IGZhZGUgYXdheS5cbiAgICAgICAgICpcbiAgICAgICAgICogQGF0dHJpYnV0ZSByZWNlbnRlcnNcbiAgICAgICAgICogQHR5cGUgYm9vbGVhblxuICAgICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgcmVjZW50ZXJzOiB7XG4gICAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgdHJ1ZSwgcmlwcGxlcyB3aWxsIGNlbnRlciBpbnNpZGUgaXRzIGNvbnRhaW5lclxuICAgICAgICAgKlxuICAgICAgICAgKiBAYXR0cmlidXRlIHJlY2VudGVyc1xuICAgICAgICAgKiBAdHlwZSBib29sZWFuXG4gICAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBjZW50ZXI6IHtcbiAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGxpc3Qgb2YgdGhlIHZpc3VhbCByaXBwbGVzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAYXR0cmlidXRlIHJpcHBsZXNcbiAgICAgICAgICogQHR5cGUgQXJyYXlcbiAgICAgICAgICogQGRlZmF1bHQgW11cbiAgICAgICAgICovXG4gICAgICAgIHJpcHBsZXM6IHtcbiAgICAgICAgICB0eXBlOiBBcnJheSxcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcnVlIHdoZW4gdGhlcmUgYXJlIHZpc2libGUgcmlwcGxlcyBhbmltYXRpbmcgd2l0aGluIHRoZVxuICAgICAgICAgKiBlbGVtZW50LlxuICAgICAgICAgKi9cbiAgICAgICAgYW5pbWF0aW5nOiB7XG4gICAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgICByZWFkT25seTogdHJ1ZSxcbiAgICAgICAgICByZWZsZWN0VG9BdHRyaWJ1dGU6IHRydWUsXG4gICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHRydWUsIHRoZSByaXBwbGUgd2lsbCByZW1haW4gaW4gdGhlIFwiZG93blwiIHN0YXRlIHVudGlsIGBob2xkRG93bmBcbiAgICAgICAgICogaXMgc2V0IHRvIGZhbHNlIGFnYWluLlxuICAgICAgICAgKi9cbiAgICAgICAgaG9sZERvd246IHtcbiAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgIHZhbHVlOiBmYWxzZSxcbiAgICAgICAgICBvYnNlcnZlcjogJ19ob2xkRG93bkNoYW5nZWQnXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHRydWUsIHRoZSByaXBwbGUgd2lsbCBub3QgZ2VuZXJhdGUgYSByaXBwbGUgZWZmZWN0XG4gICAgICAgICAqIHZpYSBwb2ludGVyIGludGVyYWN0aW9uLlxuICAgICAgICAgKiBDYWxsaW5nIHJpcHBsZSdzIGltcGVyYXRpdmUgYXBpIGxpa2UgYHNpbXVsYXRlZFJpcHBsZWAgd2lsbFxuICAgICAgICAgKiBzdGlsbCBnZW5lcmF0ZSB0aGUgcmlwcGxlIGVmZmVjdC5cbiAgICAgICAgICovXG4gICAgICAgIG5vaW5rOiB7XG4gICAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgfSxcblxuICAgICAgICBfYW5pbWF0aW5nOiB7XG4gICAgICAgICAgdHlwZTogQm9vbGVhblxuICAgICAgICB9LFxuXG4gICAgICAgIF9ib3VuZEFuaW1hdGU6IHtcbiAgICAgICAgICB0eXBlOiBGdW5jdGlvbixcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hbmltYXRlLmJpbmQodGhpcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBnZXQgdGFyZ2V0ICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMua2V5RXZlbnRUYXJnZXQ7XG4gICAgICB9LFxuXG4gICAgICBrZXlCaW5kaW5nczoge1xuICAgICAgICAnZW50ZXI6a2V5ZG93bic6ICdfb25FbnRlcktleWRvd24nLFxuICAgICAgICAnc3BhY2U6a2V5ZG93bic6ICdfb25TcGFjZUtleWRvd24nLFxuICAgICAgICAnc3BhY2U6a2V5dXAnOiAnX29uU3BhY2VLZXl1cCdcbiAgICAgIH0sXG5cbiAgICAgIGF0dGFjaGVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gU2V0IHVwIGExMXlLZXlzQmVoYXZpb3IgdG8gbGlzdGVuIHRvIGtleSBldmVudHMgb24gdGhlIHRhcmdldCxcbiAgICAgICAgLy8gc28gdGhhdCBzcGFjZSBhbmQgZW50ZXIgYWN0aXZhdGUgdGhlIHJpcHBsZSBldmVuIGlmIHRoZSB0YXJnZXQgZG9lc24ndFxuICAgICAgICAvLyBoYW5kbGUga2V5IGV2ZW50cy4gVGhlIGtleSBoYW5kbGVycyBkZWFsIHdpdGggYG5vaW5rYCB0aGVtc2VsdmVzLlxuICAgICAgICBpZiAodGhpcy5wYXJlbnROb2RlLm5vZGVUeXBlID09IDExKSB7IC8vIERPQ1VNRU5UX0ZSQUdNRU5UX05PREVcbiAgICAgICAgICB0aGlzLmtleUV2ZW50VGFyZ2V0ID0gUG9seW1lci5kb20odGhpcykuZ2V0T3duZXJSb290KCkuaG9zdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmtleUV2ZW50VGFyZ2V0ID0gdGhpcy5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBrZXlFdmVudFRhcmdldCA9IC8qKiBAdHlwZSB7IUV2ZW50VGFyZ2V0fSAqLyAodGhpcy5rZXlFdmVudFRhcmdldCk7XG4gICAgICAgIHRoaXMubGlzdGVuKGtleUV2ZW50VGFyZ2V0LCAndXAnLCAndWlVcEFjdGlvbicpO1xuICAgICAgICB0aGlzLmxpc3RlbihrZXlFdmVudFRhcmdldCwgJ2Rvd24nLCAndWlEb3duQWN0aW9uJyk7XG4gICAgICB9LFxuXG4gICAgICBkZXRhY2hlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMudW5saXN0ZW4odGhpcy5rZXlFdmVudFRhcmdldCwgJ3VwJywgJ3VpVXBBY3Rpb24nKTtcbiAgICAgICAgdGhpcy51bmxpc3Rlbih0aGlzLmtleUV2ZW50VGFyZ2V0LCAnZG93bicsICd1aURvd25BY3Rpb24nKTtcbiAgICAgICAgdGhpcy5rZXlFdmVudFRhcmdldCA9IG51bGw7XG4gICAgICB9LFxuXG4gICAgICBnZXQgc2hvdWxkS2VlcEFuaW1hdGluZyAoKSB7XG4gICAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCB0aGlzLnJpcHBsZXMubGVuZ3RoOyArK2luZGV4KSB7XG4gICAgICAgICAgaWYgKCF0aGlzLnJpcHBsZXNbaW5kZXhdLmlzQW5pbWF0aW9uQ29tcGxldGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0sXG5cbiAgICAgIHNpbXVsYXRlZFJpcHBsZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZG93bkFjdGlvbihudWxsKTtcblxuICAgICAgICAvLyBQbGVhc2Ugc2VlIHBvbHltZXIvcG9seW1lciMxMzA1XG4gICAgICAgIHRoaXMuYXN5bmMoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdGhpcy51cEFjdGlvbigpO1xuICAgICAgICB9LCAxKTtcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogUHJvdm9rZXMgYSByaXBwbGUgZG93biBlZmZlY3QgdmlhIGEgVUkgZXZlbnQsXG4gICAgICAgKiByZXNwZWN0aW5nIHRoZSBgbm9pbmtgIHByb3BlcnR5LlxuICAgICAgICogQHBhcmFtIHtFdmVudD19IGV2ZW50XG4gICAgICAgKi9cbiAgICAgIHVpRG93bkFjdGlvbjogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLm5vaW5rKSB7XG4gICAgICAgICAgdGhpcy5kb3duQWN0aW9uKGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBQcm92b2tlcyBhIHJpcHBsZSBkb3duIGVmZmVjdCB2aWEgYSBVSSBldmVudCxcbiAgICAgICAqICpub3QqIHJlc3BlY3RpbmcgdGhlIGBub2lua2AgcHJvcGVydHkuXG4gICAgICAgKiBAcGFyYW0ge0V2ZW50PX0gZXZlbnRcbiAgICAgICAqL1xuICAgICAgZG93bkFjdGlvbjogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuaG9sZERvd24gJiYgdGhpcy5yaXBwbGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmlwcGxlID0gdGhpcy5hZGRSaXBwbGUoKTtcblxuICAgICAgICByaXBwbGUuZG93bkFjdGlvbihldmVudCk7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9hbmltYXRpbmcpIHtcbiAgICAgICAgICB0aGlzLl9hbmltYXRpbmcgPSB0cnVlO1xuICAgICAgICAgIHRoaXMuYW5pbWF0ZSgpO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFByb3Zva2VzIGEgcmlwcGxlIHVwIGVmZmVjdCB2aWEgYSBVSSBldmVudCxcbiAgICAgICAqIHJlc3BlY3RpbmcgdGhlIGBub2lua2AgcHJvcGVydHkuXG4gICAgICAgKiBAcGFyYW0ge0V2ZW50PX0gZXZlbnRcbiAgICAgICAqL1xuICAgICAgdWlVcEFjdGlvbjogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLm5vaW5rKSB7XG4gICAgICAgICAgdGhpcy51cEFjdGlvbihldmVudCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogUHJvdm9rZXMgYSByaXBwbGUgdXAgZWZmZWN0IHZpYSBhIFVJIGV2ZW50LFxuICAgICAgICogKm5vdCogcmVzcGVjdGluZyB0aGUgYG5vaW5rYCBwcm9wZXJ0eS5cbiAgICAgICAqIEBwYXJhbSB7RXZlbnQ9fSBldmVudFxuICAgICAgICovXG4gICAgICB1cEFjdGlvbjogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuaG9sZERvd24pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnJpcHBsZXMuZm9yRWFjaChmdW5jdGlvbihyaXBwbGUpIHtcbiAgICAgICAgICByaXBwbGUudXBBY3Rpb24oZXZlbnQpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLl9hbmltYXRpbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLmFuaW1hdGUoKTtcbiAgICAgIH0sXG5cbiAgICAgIG9uQW5pbWF0aW9uQ29tcGxldGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9hbmltYXRpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy4kLmJhY2tncm91bmQuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gbnVsbDtcbiAgICAgICAgdGhpcy5maXJlKCd0cmFuc2l0aW9uZW5kJyk7XG4gICAgICB9LFxuXG4gICAgICBhZGRSaXBwbGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmlwcGxlID0gbmV3IFJpcHBsZSh0aGlzKTtcblxuICAgICAgICBQb2x5bWVyLmRvbSh0aGlzLiQud2F2ZXMpLmFwcGVuZENoaWxkKHJpcHBsZS53YXZlQ29udGFpbmVyKTtcbiAgICAgICAgdGhpcy4kLmJhY2tncm91bmQuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gcmlwcGxlLmNvbG9yO1xuICAgICAgICB0aGlzLnJpcHBsZXMucHVzaChyaXBwbGUpO1xuXG4gICAgICAgIHRoaXMuX3NldEFuaW1hdGluZyh0cnVlKTtcblxuICAgICAgICByZXR1cm4gcmlwcGxlO1xuICAgICAgfSxcblxuICAgICAgcmVtb3ZlUmlwcGxlOiBmdW5jdGlvbihyaXBwbGUpIHtcbiAgICAgICAgdmFyIHJpcHBsZUluZGV4ID0gdGhpcy5yaXBwbGVzLmluZGV4T2YocmlwcGxlKTtcblxuICAgICAgICBpZiAocmlwcGxlSW5kZXggPCAwKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5yaXBwbGVzLnNwbGljZShyaXBwbGVJbmRleCwgMSk7XG5cbiAgICAgICAgcmlwcGxlLnJlbW92ZSgpO1xuXG4gICAgICAgIGlmICghdGhpcy5yaXBwbGVzLmxlbmd0aCkge1xuICAgICAgICAgIHRoaXMuX3NldEFuaW1hdGluZyhmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogVGhpcyBjb25mbGljdHMgd2l0aCBFbGVtZW50I2FudGltYXRlKCkuXG4gICAgICAgKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRWxlbWVudC9hbmltYXRlXG4gICAgICAgKiBAc3VwcHJlc3Mge2NoZWNrVHlwZXN9XG4gICAgICAgKi9cbiAgICAgIGFuaW1hdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2FuaW1hdGluZykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW5kZXg7XG4gICAgICAgIHZhciByaXBwbGU7XG5cbiAgICAgICAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5yaXBwbGVzLmxlbmd0aDsgKytpbmRleCkge1xuICAgICAgICAgIHJpcHBsZSA9IHRoaXMucmlwcGxlc1tpbmRleF07XG5cbiAgICAgICAgICByaXBwbGUuZHJhdygpO1xuXG4gICAgICAgICAgdGhpcy4kLmJhY2tncm91bmQuc3R5bGUub3BhY2l0eSA9IHJpcHBsZS5vdXRlck9wYWNpdHk7XG5cbiAgICAgICAgICBpZiAocmlwcGxlLmlzT3BhY2l0eUZ1bGx5RGVjYXllZCAmJiAhcmlwcGxlLmlzUmVzdGluZ0F0TWF4UmFkaXVzKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZVJpcHBsZShyaXBwbGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5zaG91bGRLZWVwQW5pbWF0aW5nICYmIHRoaXMucmlwcGxlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLm9uQW5pbWF0aW9uQ29tcGxldGUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuX2JvdW5kQW5pbWF0ZSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIF9vbkVudGVyS2V5ZG93bjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMudWlEb3duQWN0aW9uKCk7XG4gICAgICAgIHRoaXMuYXN5bmModGhpcy51aVVwQWN0aW9uLCAxKTtcbiAgICAgIH0sXG5cbiAgICAgIF9vblNwYWNlS2V5ZG93bjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMudWlEb3duQWN0aW9uKCk7XG4gICAgICB9LFxuXG4gICAgICBfb25TcGFjZUtleXVwOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy51aVVwQWN0aW9uKCk7XG4gICAgICB9LFxuXG4gICAgICAvLyBub3RlOiBob2xkRG93biBkb2VzIG5vdCByZXNwZWN0IG5vaW5rIHNpbmNlIGl0IGNhbiBiZSBhIGZvY3VzIGJhc2VkXG4gICAgICAvLyBlZmZlY3QuXG4gICAgICBfaG9sZERvd25DaGFuZ2VkOiBmdW5jdGlvbihuZXdWYWwsIG9sZFZhbCkge1xuICAgICAgICBpZiAob2xkVmFsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5ld1ZhbCkge1xuICAgICAgICAgIHRoaXMuZG93bkFjdGlvbigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMudXBBY3Rpb24oKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgIEZpcmVkIHdoZW4gdGhlIGFuaW1hdGlvbiBmaW5pc2hlcy5cbiAgICAgIFRoaXMgaXMgdXNlZnVsIGlmIHlvdSB3YW50IHRvIHdhaXQgdW50aWxcbiAgICAgIHRoZSByaXBwbGUgYW5pbWF0aW9uIGZpbmlzaGVzIHRvIHBlcmZvcm0gc29tZSBhY3Rpb24uXG5cbiAgICAgIEBldmVudCB0cmFuc2l0aW9uZW5kXG4gICAgICBAcGFyYW0ge3tub2RlOiBPYmplY3R9fSBkZXRhaWwgQ29udGFpbnMgdGhlIGFuaW1hdGVkIG5vZGUuXG4gICAgICAqL1xuICAgIH0pO1xuICB9KSgpO1xuPC9zY3JpcHQ+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL3BhcGVyLXJpcHBsZS9wYXBlci1yaXBwbGUuaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTYgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cblxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3BvbHltZXIvcG9seW1lci5odG1sXCI+XG5cbjxzY3JpcHQ+XG5cbiAgLyoqXG4gICAqIGBQb2x5bWVyLklyb25TY3JvbGxUYXJnZXRCZWhhdmlvcmAgYWxsb3dzIGFuIGVsZW1lbnQgdG8gcmVzcG9uZCB0byBzY3JvbGwgZXZlbnRzIGZyb20gYVxuICAgKiBkZXNpZ25hdGVkIHNjcm9sbCB0YXJnZXQuXG4gICAqXG4gICAqIEVsZW1lbnRzIHRoYXQgY29uc3VtZSB0aGlzIGJlaGF2aW9yIGNhbiBvdmVycmlkZSB0aGUgYF9zY3JvbGxIYW5kbGVyYFxuICAgKiBtZXRob2QgdG8gYWRkIGxvZ2ljIG9uIHRoZSBzY3JvbGwgZXZlbnQuXG4gICAqXG4gICAqIEBkZW1vIGRlbW8vc2Nyb2xsaW5nLXJlZ2lvbi5odG1sIFNjcm9sbGluZyBSZWdpb25cbiAgICogQGRlbW8gZGVtby9kb2N1bWVudC5odG1sIERvY3VtZW50IEVsZW1lbnRcbiAgICogQHBvbHltZXJCZWhhdmlvclxuICAgKi9cbiAgUG9seW1lci5Jcm9uU2Nyb2xsVGFyZ2V0QmVoYXZpb3IgPSB7XG5cbiAgICBwcm9wZXJ0aWVzOiB7XG5cbiAgICAgIC8qKlxuICAgICAgICogU3BlY2lmaWVzIHRoZSBlbGVtZW50IHRoYXQgd2lsbCBoYW5kbGUgdGhlIHNjcm9sbCBldmVudFxuICAgICAgICogb24gdGhlIGJlaGFsZiBvZiB0aGUgY3VycmVudCBlbGVtZW50LiBUaGlzIGlzIHR5cGljYWxseSBhIHJlZmVyZW5jZSB0byBhbiBlbGVtZW50LFxuICAgICAgICogYnV0IHRoZXJlIGFyZSBhIGZldyBtb3JlIHBvc2liaWxpdGllczpcbiAgICAgICAqXG4gICAgICAgKiAjIyMgRWxlbWVudHMgaWRcbiAgICAgICAqXG4gICAgICAgKmBgYGh0bWxcbiAgICAgICAqIDxkaXYgaWQ9XCJzY3JvbGxhYmxlLWVsZW1lbnRcIiBzdHlsZT1cIm92ZXJmbG93OiBhdXRvO1wiPlxuICAgICAgICogIDx4LWVsZW1lbnQgc2Nyb2xsLXRhcmdldD1cInNjcm9sbGFibGUtZWxlbWVudFwiPlxuICAgICAgICogICAgPCEtLSBDb250ZW50LS0+XG4gICAgICAgKiAgPC94LWVsZW1lbnQ+XG4gICAgICAgKiA8L2Rpdj5cbiAgICAgICAqYGBgXG4gICAgICAgKiBJbiB0aGlzIGNhc2UsIHRoZSBgc2Nyb2xsVGFyZ2V0YCB3aWxsIHBvaW50IHRvIHRoZSBvdXRlciBkaXYgZWxlbWVudC5cbiAgICAgICAqXG4gICAgICAgKiAjIyMgRG9jdW1lbnQgc2Nyb2xsaW5nXG4gICAgICAgKlxuICAgICAgICogRm9yIGRvY3VtZW50IHNjcm9sbGluZywgeW91IGNhbiB1c2UgdGhlIHJlc2VydmVkIHdvcmQgYGRvY3VtZW50YDpcbiAgICAgICAqXG4gICAgICAgKmBgYGh0bWxcbiAgICAgICAqIDx4LWVsZW1lbnQgc2Nyb2xsLXRhcmdldD1cImRvY3VtZW50XCI+XG4gICAgICAgKiAgIDwhLS0gQ29udGVudCAtLT5cbiAgICAgICAqIDwveC1lbGVtZW50PlxuICAgICAgICpgYGBcbiAgICAgICAqXG4gICAgICAgKiAjIyMgRWxlbWVudHMgcmVmZXJlbmNlXG4gICAgICAgKlxuICAgICAgICpgYGBqc1xuICAgICAgICogYXBwSGVhZGVyLnNjcm9sbFRhcmdldCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNzY3JvbGxhYmxlLWVsZW1lbnQnKTtcbiAgICAgICAqYGBgXG4gICAgICAgKlxuICAgICAgICogQHR5cGUge0hUTUxFbGVtZW50fVxuICAgICAgICogQGRlZmF1bHQgZG9jdW1lbnRcbiAgICAgICAqL1xuICAgICAgc2Nyb2xsVGFyZ2V0OiB7XG4gICAgICAgIHR5cGU6IEhUTUxFbGVtZW50LFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2RlZmF1bHRTY3JvbGxUYXJnZXQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgb2JzZXJ2ZXJzOiBbXG4gICAgICAnX3Njcm9sbFRhcmdldENoYW5nZWQoc2Nyb2xsVGFyZ2V0LCBpc0F0dGFjaGVkKSdcbiAgICBdLFxuXG4gICAgLyoqXG4gICAgICogVHJ1ZSBpZiB0aGUgZXZlbnQgbGlzdGVuZXIgc2hvdWxkIGJlIGluc3RhbGxlZC5cbiAgICAgKi9cbiAgICBfc2hvdWxkSGF2ZUxpc3RlbmVyOiB0cnVlLFxuXG4gICAgX3Njcm9sbFRhcmdldENoYW5nZWQ6IGZ1bmN0aW9uKHNjcm9sbFRhcmdldCwgaXNBdHRhY2hlZCkge1xuICAgICAgdmFyIGV2ZW50VGFyZ2V0O1xuXG4gICAgICBpZiAodGhpcy5fb2xkU2Nyb2xsVGFyZ2V0KSB7XG4gICAgICAgIHRoaXMuX3RvZ2dsZVNjcm9sbExpc3RlbmVyKGZhbHNlLCB0aGlzLl9vbGRTY3JvbGxUYXJnZXQpO1xuICAgICAgICB0aGlzLl9vbGRTY3JvbGxUYXJnZXQgPSBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKCFpc0F0dGFjaGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIFN1cHBvcnQgZWxlbWVudCBpZCByZWZlcmVuY2VzXG4gICAgICBpZiAoc2Nyb2xsVGFyZ2V0ID09PSAnZG9jdW1lbnQnKSB7XG5cbiAgICAgICAgdGhpcy5zY3JvbGxUYXJnZXQgPSB0aGlzLl9kb2M7XG5cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHNjcm9sbFRhcmdldCA9PT0gJ3N0cmluZycpIHtcblxuICAgICAgICB2YXIgZG9tSG9zdCA9IHRoaXMuZG9tSG9zdDtcblxuICAgICAgICB0aGlzLnNjcm9sbFRhcmdldCA9IGRvbUhvc3QgJiYgZG9tSG9zdC4kID8gZG9tSG9zdC4kW3Njcm9sbFRhcmdldF0gOlxuICAgICAgICAgICAgUG9seW1lci5kb20odGhpcy5vd25lckRvY3VtZW50KS5xdWVyeVNlbGVjdG9yKCcjJyArIHNjcm9sbFRhcmdldCk7XG5cbiAgICAgIH0gZWxzZSBpZiAodGhpcy5faXNWYWxpZFNjcm9sbFRhcmdldCgpKSB7XG5cbiAgICAgICAgdGhpcy5fb2xkU2Nyb2xsVGFyZ2V0ID0gc2Nyb2xsVGFyZ2V0O1xuICAgICAgICB0aGlzLl90b2dnbGVTY3JvbGxMaXN0ZW5lcih0aGlzLl9zaG91bGRIYXZlTGlzdGVuZXIsIHNjcm9sbFRhcmdldCk7XG5cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUnVucyBvbiBldmVyeSBzY3JvbGwgZXZlbnQuIENvbnN1bWVyIG9mIHRoaXMgYmVoYXZpb3IgbWF5IG92ZXJyaWRlIHRoaXMgbWV0aG9kLlxuICAgICAqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9zY3JvbGxIYW5kbGVyOiBmdW5jdGlvbiBzY3JvbGxIYW5kbGVyKCkge30sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGVmYXVsdCBzY3JvbGwgdGFyZ2V0LiBDb25zdW1lcnMgb2YgdGhpcyBiZWhhdmlvciBtYXkgd2FudCB0byBjdXN0b21pemVcbiAgICAgKiB0aGUgZGVmYXVsdCBzY3JvbGwgdGFyZ2V0LlxuICAgICAqXG4gICAgICogQHR5cGUge0VsZW1lbnR9XG4gICAgICovXG4gICAgZ2V0IF9kZWZhdWx0U2Nyb2xsVGFyZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2RvYztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2hvcnRjdXQgZm9yIHRoZSBkb2N1bWVudCBlbGVtZW50XG4gICAgICpcbiAgICAgKiBAdHlwZSB7RWxlbWVudH1cbiAgICAgKi9cbiAgICBnZXQgX2RvYygpIHtcbiAgICAgIHJldHVybiB0aGlzLm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBudW1iZXIgb2YgcGl4ZWxzIHRoYXQgdGhlIGNvbnRlbnQgb2YgYW4gZWxlbWVudCBpcyBzY3JvbGxlZCB1cHdhcmQuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldCBfc2Nyb2xsVG9wKCkge1xuICAgICAgaWYgKHRoaXMuX2lzVmFsaWRTY3JvbGxUYXJnZXQoKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zY3JvbGxUYXJnZXQgPT09IHRoaXMuX2RvYyA/IHdpbmRvdy5wYWdlWU9mZnNldCA6IHRoaXMuc2Nyb2xsVGFyZ2V0LnNjcm9sbFRvcDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBudW1iZXIgb2YgcGl4ZWxzIHRoYXQgdGhlIGNvbnRlbnQgb2YgYW4gZWxlbWVudCBpcyBzY3JvbGxlZCB0byB0aGUgbGVmdC5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IF9zY3JvbGxMZWZ0KCkge1xuICAgICAgaWYgKHRoaXMuX2lzVmFsaWRTY3JvbGxUYXJnZXQoKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zY3JvbGxUYXJnZXQgPT09IHRoaXMuX2RvYyA/IHdpbmRvdy5wYWdlWE9mZnNldCA6IHRoaXMuc2Nyb2xsVGFyZ2V0LnNjcm9sbExlZnQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gMDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgbnVtYmVyIG9mIHBpeGVscyB0aGF0IHRoZSBjb250ZW50IG9mIGFuIGVsZW1lbnQgaXMgc2Nyb2xsZWQgdXB3YXJkLlxuICAgICAqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICBzZXQgX3Njcm9sbFRvcCh0b3ApIHtcbiAgICAgIGlmICh0aGlzLnNjcm9sbFRhcmdldCA9PT0gdGhpcy5fZG9jKSB7XG4gICAgICAgIHdpbmRvdy5zY3JvbGxUbyh3aW5kb3cucGFnZVhPZmZzZXQsIHRvcCk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX2lzVmFsaWRTY3JvbGxUYXJnZXQoKSkge1xuICAgICAgICB0aGlzLnNjcm9sbFRhcmdldC5zY3JvbGxUb3AgPSB0b3A7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIG51bWJlciBvZiBwaXhlbHMgdGhhdCB0aGUgY29udGVudCBvZiBhbiBlbGVtZW50IGlzIHNjcm9sbGVkIHRvIHRoZSBsZWZ0LlxuICAgICAqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICBzZXQgX3Njcm9sbExlZnQobGVmdCkge1xuICAgICAgaWYgKHRoaXMuc2Nyb2xsVGFyZ2V0ID09PSB0aGlzLl9kb2MpIHtcbiAgICAgICAgd2luZG93LnNjcm9sbFRvKGxlZnQsIHdpbmRvdy5wYWdlWU9mZnNldCk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX2lzVmFsaWRTY3JvbGxUYXJnZXQoKSkge1xuICAgICAgICB0aGlzLnNjcm9sbFRhcmdldC5zY3JvbGxMZWZ0ID0gbGVmdDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2Nyb2xscyB0aGUgY29udGVudCB0byBhIHBhcnRpY3VsYXIgcGxhY2UuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHNjcm9sbFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsZWZ0IFRoZSBsZWZ0IHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRvcCBUaGUgdG9wIHBvc2l0aW9uXG4gICAgICovXG4gICAgc2Nyb2xsOiBmdW5jdGlvbihsZWZ0LCB0b3ApIHtcbiAgICAgICBpZiAodGhpcy5zY3JvbGxUYXJnZXQgPT09IHRoaXMuX2RvYykge1xuICAgICAgICB3aW5kb3cuc2Nyb2xsVG8obGVmdCwgdG9wKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5faXNWYWxpZFNjcm9sbFRhcmdldCgpKSB7XG4gICAgICAgIHRoaXMuc2Nyb2xsVGFyZ2V0LnNjcm9sbExlZnQgPSBsZWZ0O1xuICAgICAgICB0aGlzLnNjcm9sbFRhcmdldC5zY3JvbGxUb3AgPSB0b3A7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHdpZHRoIG9mIHRoZSBzY3JvbGwgdGFyZ2V0LlxuICAgICAqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgX3Njcm9sbFRhcmdldFdpZHRoKCkge1xuICAgICAgaWYgKHRoaXMuX2lzVmFsaWRTY3JvbGxUYXJnZXQoKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zY3JvbGxUYXJnZXQgPT09IHRoaXMuX2RvYyA/IHdpbmRvdy5pbm5lcldpZHRoIDogdGhpcy5zY3JvbGxUYXJnZXQub2Zmc2V0V2lkdGg7XG4gICAgICB9XG4gICAgICByZXR1cm4gMDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgaGVpZ2h0IG9mIHRoZSBzY3JvbGwgdGFyZ2V0LlxuICAgICAqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgX3Njcm9sbFRhcmdldEhlaWdodCgpIHtcbiAgICAgIGlmICh0aGlzLl9pc1ZhbGlkU2Nyb2xsVGFyZ2V0KCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2Nyb2xsVGFyZ2V0ID09PSB0aGlzLl9kb2MgPyB3aW5kb3cuaW5uZXJIZWlnaHQgOiB0aGlzLnNjcm9sbFRhcmdldC5vZmZzZXRIZWlnaHQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gMDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBzY3JvbGwgdGFyZ2V0IGlzIGEgdmFsaWQgSFRNTEVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuICAgIF9pc1ZhbGlkU2Nyb2xsVGFyZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnNjcm9sbFRhcmdldCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50O1xuICAgIH0sXG5cbiAgICBfdG9nZ2xlU2Nyb2xsTGlzdGVuZXI6IGZ1bmN0aW9uKHllcywgc2Nyb2xsVGFyZ2V0KSB7XG4gICAgICB2YXIgZXZlbnRUYXJnZXQgPSBzY3JvbGxUYXJnZXQgPT09IHRoaXMuX2RvYyA/IHdpbmRvdyA6IHNjcm9sbFRhcmdldDtcbiAgICAgIGlmICh5ZXMpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9ib3VuZFNjcm9sbEhhbmRsZXIpIHtcbiAgICAgICAgICB0aGlzLl9ib3VuZFNjcm9sbEhhbmRsZXIgPSB0aGlzLl9zY3JvbGxIYW5kbGVyLmJpbmQodGhpcyk7XG4gICAgICAgICAgZXZlbnRUYXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy5fYm91bmRTY3JvbGxIYW5kbGVyKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuX2JvdW5kU2Nyb2xsSGFuZGxlcikge1xuICAgICAgICAgIGV2ZW50VGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMuX2JvdW5kU2Nyb2xsSGFuZGxlcik7XG4gICAgICAgICAgdGhpcy5fYm91bmRTY3JvbGxIYW5kbGVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBFbmFibGVzIG9yIGRpc2FibGVzIHRoZSBzY3JvbGwgZXZlbnQgbGlzdGVuZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHllcyBUcnVlIHRvIGFkZCB0aGUgZXZlbnQsIEZhbHNlIHRvIHJlbW92ZSBpdC5cbiAgICAgKi9cbiAgICB0b2dnbGVTY3JvbGxMaXN0ZW5lcjogZnVuY3Rpb24oeWVzKSB7XG4gICAgICB0aGlzLl9zaG91bGRIYXZlTGlzdGVuZXIgPSB5ZXM7XG4gICAgICB0aGlzLl90b2dnbGVTY3JvbGxMaXN0ZW5lcih5ZXMsIHRoaXMuc2Nyb2xsVGFyZ2V0KTtcbiAgICB9XG5cbiAgfTtcblxuPC9zY3JpcHQ+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL2lyb24tc2Nyb2xsLXRhcmdldC1iZWhhdmlvci9pcm9uLXNjcm9sbC10YXJnZXQtYmVoYXZpb3IuaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTUgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cblxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3BvbHltZXIvcG9seW1lci5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vaXJvbi1tZXRhL2lyb24tbWV0YS5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vaXJvbi1mbGV4LWxheW91dC9pcm9uLWZsZXgtbGF5b3V0Lmh0bWxcIj5cblxuPCEtLVxuXG5UaGUgYGlyb24taWNvbmAgZWxlbWVudCBkaXNwbGF5cyBhbiBpY29uLiBCeSBkZWZhdWx0IGFuIGljb24gcmVuZGVycyBhcyBhIDI0cHggc3F1YXJlLlxuXG5FeGFtcGxlIHVzaW5nIHNyYzpcblxuICAgIDxpcm9uLWljb24gc3JjPVwic3Rhci5wbmdcIj48L2lyb24taWNvbj5cblxuRXhhbXBsZSBzZXR0aW5nIHNpemUgdG8gMzJweCB4IDMycHg6XG5cbiAgICA8aXJvbi1pY29uIGNsYXNzPVwiYmlnXCIgc3JjPVwiYmlnX3N0YXIucG5nXCI+PC9pcm9uLWljb24+XG5cbiAgICA8c3R5bGUgaXM9XCJjdXN0b20tc3R5bGVcIj5cbiAgICAgIC5iaWcge1xuICAgICAgICAtLWlyb24taWNvbi1oZWlnaHQ6IDMycHg7XG4gICAgICAgIC0taXJvbi1pY29uLXdpZHRoOiAzMnB4O1xuICAgICAgfVxuICAgIDwvc3R5bGU+XG5cblRoZSBpcm9uIGVsZW1lbnRzIGluY2x1ZGUgc2V2ZXJhbCBzZXRzIG9mIGljb25zLlxuVG8gdXNlIHRoZSBkZWZhdWx0IHNldCBvZiBpY29ucywgaW1wb3J0IGBpcm9uLWljb25zLmh0bWxgIGFuZCB1c2UgdGhlIGBpY29uYCBhdHRyaWJ1dGUgdG8gc3BlY2lmeSBhbiBpY29uOlxuXG4gICAgPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi9jb21wb25lbnRzL2lyb24taWNvbnMvaXJvbi1pY29ucy5odG1sXCI+XG5cbiAgICA8aXJvbi1pY29uIGljb249XCJtZW51XCI+PC9pcm9uLWljb24+XG5cblRvIHVzZSBhIGRpZmZlcmVudCBidWlsdC1pbiBzZXQgb2YgaWNvbnMsIGltcG9ydCB0aGUgc3BlY2lmaWMgYGlyb24taWNvbnMvPGljb25zZXQ+LWljb25zLmh0bWxgLCBhbmRcbnNwZWNpZnkgdGhlIGljb24gYXMgYDxpY29uc2V0Pjo8aWNvbj5gLiBGb3IgZXhhbXBsZSwgdG8gdXNlIGEgY29tbXVuaWNhdGlvbiBpY29uLCB5b3Ugd291bGRcbnVzZTpcblxuICAgIDxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIvY29tcG9uZW50cy9pcm9uLWljb25zL2NvbW11bmljYXRpb24taWNvbnMuaHRtbFwiPlxuXG4gICAgPGlyb24taWNvbiBpY29uPVwiY29tbXVuaWNhdGlvbjplbWFpbFwiPjwvaXJvbi1pY29uPlxuXG5Zb3UgY2FuIGFsc28gY3JlYXRlIGN1c3RvbSBpY29uIHNldHMgb2YgYml0bWFwIG9yIFNWRyBpY29ucy5cblxuRXhhbXBsZSBvZiB1c2luZyBhbiBpY29uIG5hbWVkIGBjaGVycnlgIGZyb20gYSBjdXN0b20gaWNvbnNldCB3aXRoIHRoZSBJRCBgZnJ1aXRgOlxuXG4gICAgPGlyb24taWNvbiBpY29uPVwiZnJ1aXQ6Y2hlcnJ5XCI+PC9pcm9uLWljb24+XG5cblNlZSBbaXJvbi1pY29uc2V0XShpcm9uLWljb25zZXQpIGFuZCBbaXJvbi1pY29uc2V0LXN2Z10oaXJvbi1pY29uc2V0LXN2ZykgZm9yIG1vcmUgaW5mb3JtYXRpb24gYWJvdXRcbmhvdyB0byBjcmVhdGUgYSBjdXN0b20gaWNvbnNldC5cblxuU2VlIHRoZSBbaXJvbi1pY29ucyBkZW1vXShpcm9uLWljb25zP3ZpZXc9ZGVtbzpkZW1vL2luZGV4Lmh0bWwpIHRvIHNlZSB0aGUgaWNvbnMgYXZhaWxhYmxlXG5pbiB0aGUgdmFyaW91cyBpY29uc2V0cy5cblxuVG8gbG9hZCBhIHN1YnNldCBvZiBpY29ucyBmcm9tIG9uZSBvZiB0aGUgZGVmYXVsdCBgaXJvbi1pY29uc2Agc2V0cywgeW91IGNhblxudXNlIHRoZSBbcG9seS1pY29uXShodHRwczovL3BvbHktaWNvbi5hcHBzcG90LmNvbS8pIHRvb2wuIEl0IGFsbG93cyB5b3VcbnRvIHNlbGVjdCBpbmRpdmlkdWFsIGljb25zLCBhbmQgY3JlYXRlcyBhbiBpY29uc2V0IGZyb20gdGhlbSB0aGF0IHlvdSBjYW5cbnVzZSBkaXJlY3RseSBpbiB5b3VyIGVsZW1lbnRzLlxuXG4jIyMgU3R5bGluZ1xuXG5UaGUgZm9sbG93aW5nIGN1c3RvbSBwcm9wZXJ0aWVzIGFyZSBhdmFpbGFibGUgZm9yIHN0eWxpbmc6XG5cbkN1c3RvbSBwcm9wZXJ0eSB8IERlc2NyaXB0aW9uIHwgRGVmYXVsdFxuLS0tLS0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tfC0tLS0tLS0tLS1cbmAtLWlyb24taWNvbmAgfCBNaXhpbiBhcHBsaWVkIHRvIHRoZSBpY29uIHwge31cbmAtLWlyb24taWNvbi13aWR0aGAgfCBXaWR0aCBvZiB0aGUgaWNvbiB8IGAyNHB4YFxuYC0taXJvbi1pY29uLWhlaWdodGAgfCBIZWlnaHQgb2YgdGhlIGljb24gfCBgMjRweGBcbmAtLWlyb24taWNvbi1maWxsLWNvbG9yYCB8IEZpbGwgY29sb3Igb2YgdGhlIHN2ZyBpY29uIHwgYGN1cnJlbnRjb2xvcmBcbmAtLWlyb24taWNvbi1zdHJva2UtY29sb3JgIHwgU3Ryb2tlIGNvbG9yIG9mIHRoZSBzdmcgaWNvbiB8IG5vbmVcblxuQGdyb3VwIElyb24gRWxlbWVudHNcbkBlbGVtZW50IGlyb24taWNvblxuQGRlbW8gZGVtby9pbmRleC5odG1sXG5AaGVybyBoZXJvLnN2Z1xuQGhvbWVwYWdlIHBvbHltZXIuZ2l0aHViLmlvXG4tLT5cblxuPGRvbS1tb2R1bGUgaWQ9XCJpcm9uLWljb25cIj5cbiAgPHRlbXBsYXRlPlxuICAgIDxzdHlsZT5cbiAgICAgIDpob3N0IHtcbiAgICAgICAgQGFwcGx5IC0tbGF5b3V0LWlubGluZTtcbiAgICAgICAgQGFwcGx5IC0tbGF5b3V0LWNlbnRlci1jZW50ZXI7XG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcblxuICAgICAgICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xuXG4gICAgICAgIGZpbGw6IHZhcigtLWlyb24taWNvbi1maWxsLWNvbG9yLCBjdXJyZW50Y29sb3IpO1xuICAgICAgICBzdHJva2U6IHZhcigtLWlyb24taWNvbi1zdHJva2UtY29sb3IsIG5vbmUpO1xuXG4gICAgICAgIHdpZHRoOiB2YXIoLS1pcm9uLWljb24td2lkdGgsIDI0cHgpO1xuICAgICAgICBoZWlnaHQ6IHZhcigtLWlyb24taWNvbi1oZWlnaHQsIDI0cHgpO1xuICAgICAgICBAYXBwbHkgLS1pcm9uLWljb247XG4gICAgICB9XG5cbiAgICAgIDpob3N0KFtoaWRkZW5dKSB7XG4gICAgICAgIGRpc3BsYXk6IG5vbmU7XG4gICAgICB9XG4gICAgPC9zdHlsZT5cbiAgPC90ZW1wbGF0ZT5cblxuICA8c2NyaXB0PlxuXG4gICAgUG9seW1lcih7XG5cbiAgICAgIGlzOiAnaXJvbi1pY29uJyxcblxuICAgICAgcHJvcGVydGllczoge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbmFtZSBvZiB0aGUgaWNvbiB0byB1c2UuIFRoZSBuYW1lIHNob3VsZCBiZSBvZiB0aGUgZm9ybTpcbiAgICAgICAgICogYGljb25zZXRfbmFtZTppY29uX25hbWVgLlxuICAgICAgICAgKi9cbiAgICAgICAgaWNvbjoge1xuICAgICAgICAgIHR5cGU6IFN0cmluZ1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbmFtZSBvZiB0aGUgdGhlbWUgdG8gdXNlZCwgaWYgb25lIGlzIHNwZWNpZmllZCBieSB0aGVcbiAgICAgICAgICogaWNvbnNldC5cbiAgICAgICAgICovXG4gICAgICAgIHRoZW1lOiB7XG4gICAgICAgICAgdHlwZTogU3RyaW5nXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHVzaW5nIGlyb24taWNvbiB3aXRob3V0IGFuIGljb25zZXQsIHlvdSBjYW4gc2V0IHRoZSBzcmMgdG8gYmVcbiAgICAgICAgICogdGhlIFVSTCBvZiBhbiBpbmRpdmlkdWFsIGljb24gaW1hZ2UgZmlsZS4gTm90ZSB0aGF0IHRoaXMgd2lsbCB0YWtlXG4gICAgICAgICAqIHByZWNlZGVuY2Ugb3ZlciBhIGdpdmVuIGljb24gYXR0cmlidXRlLlxuICAgICAgICAgKi9cbiAgICAgICAgc3JjOiB7XG4gICAgICAgICAgdHlwZTogU3RyaW5nXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHshUG9seW1lci5Jcm9uTWV0YX1cbiAgICAgICAgICovXG4gICAgICAgIF9tZXRhOiB7XG4gICAgICAgICAgdmFsdWU6IFBvbHltZXIuQmFzZS5jcmVhdGUoJ2lyb24tbWV0YScsIHt0eXBlOiAnaWNvbnNldCd9KVxuICAgICAgICB9XG5cbiAgICAgIH0sXG5cbiAgICAgIG9ic2VydmVyczogW1xuICAgICAgICAnX3VwZGF0ZUljb24oX21ldGEsIGlzQXR0YWNoZWQpJyxcbiAgICAgICAgJ191cGRhdGVJY29uKHRoZW1lLCBpc0F0dGFjaGVkKScsXG4gICAgICAgICdfc3JjQ2hhbmdlZChzcmMsIGlzQXR0YWNoZWQpJyxcbiAgICAgICAgJ19pY29uQ2hhbmdlZChpY29uLCBpc0F0dGFjaGVkKSdcbiAgICAgIF0sXG5cbiAgICAgIF9ERUZBVUxUX0lDT05TRVQ6ICdpY29ucycsXG5cbiAgICAgIF9pY29uQ2hhbmdlZDogZnVuY3Rpb24oaWNvbikge1xuICAgICAgICB2YXIgcGFydHMgPSAoaWNvbiB8fCAnJykuc3BsaXQoJzonKTtcbiAgICAgICAgdGhpcy5faWNvbk5hbWUgPSBwYXJ0cy5wb3AoKTtcbiAgICAgICAgdGhpcy5faWNvbnNldE5hbWUgPSBwYXJ0cy5wb3AoKSB8fCB0aGlzLl9ERUZBVUxUX0lDT05TRVQ7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUljb24oKTtcbiAgICAgIH0sXG5cbiAgICAgIF9zcmNDaGFuZ2VkOiBmdW5jdGlvbihzcmMpIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlSWNvbigpO1xuICAgICAgfSxcblxuICAgICAgX3VzZXNJY29uc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaWNvbiB8fCAhdGhpcy5zcmM7XG4gICAgICB9LFxuXG4gICAgICAvKiogQHN1cHByZXNzIHt2aXNpYmlsaXR5fSAqL1xuICAgICAgX3VwZGF0ZUljb246IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fdXNlc0ljb25zZXQoKSkge1xuICAgICAgICAgIGlmICh0aGlzLl9pbWcgJiYgdGhpcy5faW1nLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIFBvbHltZXIuZG9tKHRoaXMucm9vdCkucmVtb3ZlQ2hpbGQodGhpcy5faW1nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRoaXMuX2ljb25OYW1lID09PSBcIlwiKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5faWNvbnNldCkge1xuICAgICAgICAgICAgICB0aGlzLl9pY29uc2V0LnJlbW92ZUljb24odGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9pY29uc2V0TmFtZSAmJiB0aGlzLl9tZXRhKSB7XG4gICAgICAgICAgICB0aGlzLl9pY29uc2V0ID0gLyoqIEB0eXBlIHs/UG9seW1lci5JY29uc2V0fSAqLyAoXG4gICAgICAgICAgICAgIHRoaXMuX21ldGEuYnlLZXkodGhpcy5faWNvbnNldE5hbWUpKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9pY29uc2V0KSB7XG4gICAgICAgICAgICAgIHRoaXMuX2ljb25zZXQuYXBwbHlJY29uKHRoaXMsIHRoaXMuX2ljb25OYW1lLCB0aGlzLnRoZW1lKTtcbiAgICAgICAgICAgICAgdGhpcy51bmxpc3Rlbih3aW5kb3csICdpcm9uLWljb25zZXQtYWRkZWQnLCAnX3VwZGF0ZUljb24nKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMubGlzdGVuKHdpbmRvdywgJ2lyb24taWNvbnNldC1hZGRlZCcsICdfdXBkYXRlSWNvbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodGhpcy5faWNvbnNldCkge1xuICAgICAgICAgICAgdGhpcy5faWNvbnNldC5yZW1vdmVJY29uKHRoaXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXRoaXMuX2ltZykge1xuICAgICAgICAgICAgdGhpcy5faW1nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XG4gICAgICAgICAgICB0aGlzLl9pbWcuc3R5bGUud2lkdGggPSAnMTAwJSc7XG4gICAgICAgICAgICB0aGlzLl9pbWcuc3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xuICAgICAgICAgICAgdGhpcy5faW1nLmRyYWdnYWJsZSA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9pbWcuc3JjID0gdGhpcy5zcmM7XG4gICAgICAgICAgUG9seW1lci5kb20odGhpcy5yb290KS5hcHBlbmRDaGlsZCh0aGlzLl9pbWcpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICB9KTtcblxuICA8L3NjcmlwdD5cblxuPC9kb20tbW9kdWxlPlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9pcm9uLWljb24vaXJvbi1pY29uLmh0bWwiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE1IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi9wb2x5bWVyL3BvbHltZXIuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL2lyb24tYTExeS1rZXlzLWJlaGF2aW9yL2lyb24tYTExeS1rZXlzLWJlaGF2aW9yLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCJpcm9uLWNvbnRyb2wtc3RhdGUuaHRtbFwiPlxuXG48c2NyaXB0PlxuXG4gIC8qKlxuICAgKiBAZGVtbyBkZW1vL2luZGV4Lmh0bWxcbiAgICogQHBvbHltZXJCZWhhdmlvciBQb2x5bWVyLklyb25CdXR0b25TdGF0ZVxuICAgKi9cbiAgUG9seW1lci5Jcm9uQnV0dG9uU3RhdGVJbXBsID0ge1xuXG4gICAgcHJvcGVydGllczoge1xuXG4gICAgICAvKipcbiAgICAgICAqIElmIHRydWUsIHRoZSB1c2VyIGlzIGN1cnJlbnRseSBob2xkaW5nIGRvd24gdGhlIGJ1dHRvbi5cbiAgICAgICAqL1xuICAgICAgcHJlc3NlZDoge1xuICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICByZWFkT25seTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGZhbHNlLFxuICAgICAgICByZWZsZWN0VG9BdHRyaWJ1dGU6IHRydWUsXG4gICAgICAgIG9ic2VydmVyOiAnX3ByZXNzZWRDaGFuZ2VkJ1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBJZiB0cnVlLCB0aGUgYnV0dG9uIHRvZ2dsZXMgdGhlIGFjdGl2ZSBzdGF0ZSB3aXRoIGVhY2ggdGFwIG9yIHByZXNzXG4gICAgICAgKiBvZiB0aGUgc3BhY2ViYXIuXG4gICAgICAgKi9cbiAgICAgIHRvZ2dsZXM6IHtcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgdmFsdWU6IGZhbHNlLFxuICAgICAgICByZWZsZWN0VG9BdHRyaWJ1dGU6IHRydWVcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogSWYgdHJ1ZSwgdGhlIGJ1dHRvbiBpcyBhIHRvZ2dsZSBhbmQgaXMgY3VycmVudGx5IGluIHRoZSBhY3RpdmUgc3RhdGUuXG4gICAgICAgKi9cbiAgICAgIGFjdGl2ZToge1xuICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICB2YWx1ZTogZmFsc2UsXG4gICAgICAgIG5vdGlmeTogdHJ1ZSxcbiAgICAgICAgcmVmbGVjdFRvQXR0cmlidXRlOiB0cnVlXG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFRydWUgaWYgdGhlIGVsZW1lbnQgaXMgY3VycmVudGx5IGJlaW5nIHByZXNzZWQgYnkgYSBcInBvaW50ZXIsXCIgd2hpY2hcbiAgICAgICAqIGlzIGxvb3NlbHkgZGVmaW5lZCBhcyBtb3VzZSBvciB0b3VjaCBpbnB1dCAoYnV0IHNwZWNpZmljYWxseSBleGNsdWRpbmdcbiAgICAgICAqIGtleWJvYXJkIGlucHV0KS5cbiAgICAgICAqL1xuICAgICAgcG9pbnRlckRvd246IHtcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgcmVhZE9ubHk6IHRydWUsXG4gICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBUcnVlIGlmIHRoZSBpbnB1dCBkZXZpY2UgdGhhdCBjYXVzZWQgdGhlIGVsZW1lbnQgdG8gcmVjZWl2ZSBmb2N1c1xuICAgICAgICogd2FzIGEga2V5Ym9hcmQuXG4gICAgICAgKi9cbiAgICAgIHJlY2VpdmVkRm9jdXNGcm9tS2V5Ym9hcmQ6IHtcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgcmVhZE9ubHk6IHRydWVcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogVGhlIGFyaWEgYXR0cmlidXRlIHRvIGJlIHNldCBpZiB0aGUgYnV0dG9uIGlzIGEgdG9nZ2xlIGFuZCBpbiB0aGVcbiAgICAgICAqIGFjdGl2ZSBzdGF0ZS5cbiAgICAgICAqL1xuICAgICAgYXJpYUFjdGl2ZUF0dHJpYnV0ZToge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIHZhbHVlOiAnYXJpYS1wcmVzc2VkJyxcbiAgICAgICAgb2JzZXJ2ZXI6ICdfYXJpYUFjdGl2ZUF0dHJpYnV0ZUNoYW5nZWQnXG4gICAgICB9XG4gICAgfSxcblxuICAgIGxpc3RlbmVyczoge1xuICAgICAgZG93bjogJ19kb3duSGFuZGxlcicsXG4gICAgICB1cDogJ191cEhhbmRsZXInLFxuICAgICAgdGFwOiAnX3RhcEhhbmRsZXInXG4gICAgfSxcblxuICAgIG9ic2VydmVyczogW1xuICAgICAgJ19mb2N1c0NoYW5nZWQoZm9jdXNlZCknLFxuICAgICAgJ19hY3RpdmVDaGFuZ2VkKGFjdGl2ZSwgYXJpYUFjdGl2ZUF0dHJpYnV0ZSknXG4gICAgXSxcblxuICAgIGtleUJpbmRpbmdzOiB7XG4gICAgICAnZW50ZXI6a2V5ZG93bic6ICdfYXN5bmNDbGljaycsXG4gICAgICAnc3BhY2U6a2V5ZG93bic6ICdfc3BhY2VLZXlEb3duSGFuZGxlcicsXG4gICAgICAnc3BhY2U6a2V5dXAnOiAnX3NwYWNlS2V5VXBIYW5kbGVyJyxcbiAgICB9LFxuXG4gICAgX21vdXNlRXZlbnRSZTogL15tb3VzZS8sXG5cbiAgICBfdGFwSGFuZGxlcjogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy50b2dnbGVzKSB7XG4gICAgICAgLy8gYSB0YXAgaXMgbmVlZGVkIHRvIHRvZ2dsZSB0aGUgYWN0aXZlIHN0YXRlXG4gICAgICAgIHRoaXMuX3VzZXJBY3RpdmF0ZSghdGhpcy5hY3RpdmUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgX2ZvY3VzQ2hhbmdlZDogZnVuY3Rpb24oZm9jdXNlZCkge1xuICAgICAgdGhpcy5fZGV0ZWN0S2V5Ym9hcmRGb2N1cyhmb2N1c2VkKTtcblxuICAgICAgaWYgKCFmb2N1c2VkKSB7XG4gICAgICAgIHRoaXMuX3NldFByZXNzZWQoZmFsc2UpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBfZGV0ZWN0S2V5Ym9hcmRGb2N1czogZnVuY3Rpb24oZm9jdXNlZCkge1xuICAgICAgdGhpcy5fc2V0UmVjZWl2ZWRGb2N1c0Zyb21LZXlib2FyZCghdGhpcy5wb2ludGVyRG93biAmJiBmb2N1c2VkKTtcbiAgICB9LFxuXG4gICAgLy8gdG8gZW11bGF0ZSBuYXRpdmUgY2hlY2tib3gsIChkZS0pYWN0aXZhdGlvbnMgZnJvbSBhIHVzZXIgaW50ZXJhY3Rpb24gZmlyZVxuICAgIC8vICdjaGFuZ2UnIGV2ZW50c1xuICAgIF91c2VyQWN0aXZhdGU6IGZ1bmN0aW9uKGFjdGl2ZSkge1xuICAgICAgaWYgKHRoaXMuYWN0aXZlICE9PSBhY3RpdmUpIHtcbiAgICAgICAgdGhpcy5hY3RpdmUgPSBhY3RpdmU7XG4gICAgICAgIHRoaXMuZmlyZSgnY2hhbmdlJyk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIF9kb3duSGFuZGxlcjogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIHRoaXMuX3NldFBvaW50ZXJEb3duKHRydWUpO1xuICAgICAgdGhpcy5fc2V0UHJlc3NlZCh0cnVlKTtcbiAgICAgIHRoaXMuX3NldFJlY2VpdmVkRm9jdXNGcm9tS2V5Ym9hcmQoZmFsc2UpO1xuICAgIH0sXG5cbiAgICBfdXBIYW5kbGVyOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX3NldFBvaW50ZXJEb3duKGZhbHNlKTtcbiAgICAgIHRoaXMuX3NldFByZXNzZWQoZmFsc2UpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyFLZXlib2FyZEV2ZW50fSBldmVudCAuXG4gICAgICovXG4gICAgX3NwYWNlS2V5RG93bkhhbmRsZXI6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICB2YXIga2V5Ym9hcmRFdmVudCA9IGV2ZW50LmRldGFpbC5rZXlib2FyZEV2ZW50O1xuICAgICAgdmFyIHRhcmdldCA9IFBvbHltZXIuZG9tKGtleWJvYXJkRXZlbnQpLmxvY2FsVGFyZ2V0O1xuXG4gICAgICAvLyBJZ25vcmUgdGhlIGV2ZW50IGlmIHRoaXMgaXMgY29taW5nIGZyb20gYSBmb2N1c2VkIGxpZ2h0IGNoaWxkLCBzaW5jZSB0aGF0XG4gICAgICAvLyBlbGVtZW50IHdpbGwgZGVhbCB3aXRoIGl0LlxuICAgICAgaWYgKHRoaXMuaXNMaWdodERlc2NlbmRhbnQoLyoqIEB0eXBlIHtOb2RlfSAqLyh0YXJnZXQpKSlcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICBrZXlib2FyZEV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBrZXlib2FyZEV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgdGhpcy5fc2V0UHJlc3NlZCh0cnVlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshS2V5Ym9hcmRFdmVudH0gZXZlbnQgLlxuICAgICAqL1xuICAgIF9zcGFjZUtleVVwSGFuZGxlcjogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIHZhciBrZXlib2FyZEV2ZW50ID0gZXZlbnQuZGV0YWlsLmtleWJvYXJkRXZlbnQ7XG4gICAgICB2YXIgdGFyZ2V0ID0gUG9seW1lci5kb20oa2V5Ym9hcmRFdmVudCkubG9jYWxUYXJnZXQ7XG5cbiAgICAgIC8vIElnbm9yZSB0aGUgZXZlbnQgaWYgdGhpcyBpcyBjb21pbmcgZnJvbSBhIGZvY3VzZWQgbGlnaHQgY2hpbGQsIHNpbmNlIHRoYXRcbiAgICAgIC8vIGVsZW1lbnQgd2lsbCBkZWFsIHdpdGggaXQuXG4gICAgICBpZiAodGhpcy5pc0xpZ2h0RGVzY2VuZGFudCgvKiogQHR5cGUge05vZGV9ICovKHRhcmdldCkpKVxuICAgICAgICByZXR1cm47XG5cbiAgICAgIGlmICh0aGlzLnByZXNzZWQpIHtcbiAgICAgICAgdGhpcy5fYXN5bmNDbGljaygpO1xuICAgICAgfVxuICAgICAgdGhpcy5fc2V0UHJlc3NlZChmYWxzZSk7XG4gICAgfSxcblxuICAgIC8vIHRyaWdnZXIgY2xpY2sgYXN5bmNocm9ub3VzbHksIHRoZSBhc3luY2hyb255IGlzIHVzZWZ1bCB0byBhbGxvdyBvbmVcbiAgICAvLyBldmVudCBoYW5kbGVyIHRvIHVud2luZCBiZWZvcmUgdHJpZ2dlcmluZyBhbm90aGVyIGV2ZW50XG4gICAgX2FzeW5jQ2xpY2s6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5hc3luYyhmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5jbGljaygpO1xuICAgICAgfSwgMSk7XG4gICAgfSxcblxuICAgIC8vIGFueSBvZiB0aGVzZSBjaGFuZ2VzIGFyZSBjb25zaWRlcmVkIGEgY2hhbmdlIHRvIGJ1dHRvbiBzdGF0ZVxuXG4gICAgX3ByZXNzZWRDaGFuZ2VkOiBmdW5jdGlvbihwcmVzc2VkKSB7XG4gICAgICB0aGlzLl9jaGFuZ2VkQnV0dG9uU3RhdGUoKTtcbiAgICB9LFxuXG4gICAgX2FyaWFBY3RpdmVBdHRyaWJ1dGVDaGFuZ2VkOiBmdW5jdGlvbih2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgIGlmIChvbGRWYWx1ZSAmJiBvbGRWYWx1ZSAhPSB2YWx1ZSAmJiB0aGlzLmhhc0F0dHJpYnV0ZShvbGRWYWx1ZSkpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGUob2xkVmFsdWUpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBfYWN0aXZlQ2hhbmdlZDogZnVuY3Rpb24oYWN0aXZlLCBhcmlhQWN0aXZlQXR0cmlidXRlKSB7XG4gICAgICBpZiAodGhpcy50b2dnbGVzKSB7XG4gICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKHRoaXMuYXJpYUFjdGl2ZUF0dHJpYnV0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlID8gJ3RydWUnIDogJ2ZhbHNlJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZSh0aGlzLmFyaWFBY3RpdmVBdHRyaWJ1dGUpO1xuICAgICAgfVxuICAgICAgdGhpcy5fY2hhbmdlZEJ1dHRvblN0YXRlKCk7XG4gICAgfSxcblxuICAgIF9jb250cm9sU3RhdGVDaGFuZ2VkOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmRpc2FibGVkKSB7XG4gICAgICAgIHRoaXMuX3NldFByZXNzZWQoZmFsc2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fY2hhbmdlZEJ1dHRvblN0YXRlKCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8vIHByb3ZpZGUgaG9vayBmb3IgZm9sbG93LW9uIGJlaGF2aW9ycyB0byByZWFjdCB0byBidXR0b24tc3RhdGVcblxuICAgIF9jaGFuZ2VkQnV0dG9uU3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuX2J1dHRvblN0YXRlQ2hhbmdlZCkge1xuICAgICAgICB0aGlzLl9idXR0b25TdGF0ZUNoYW5nZWQoKTsgLy8gYWJzdHJhY3RcbiAgICAgIH1cbiAgICB9XG5cbiAgfTtcblxuICAvKiogQHBvbHltZXJCZWhhdmlvciAqL1xuICBQb2x5bWVyLklyb25CdXR0b25TdGF0ZSA9IFtcbiAgICBQb2x5bWVyLklyb25BMTF5S2V5c0JlaGF2aW9yLFxuICAgIFBvbHltZXIuSXJvbkJ1dHRvblN0YXRlSW1wbFxuICBdO1xuXG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvaXJvbi1iZWhhdmlvcnMvaXJvbi1idXR0b24tc3RhdGUuaHRtbCIsIlxucmVxdWlyZSgnLi4vcG9seW1lci9wb2x5bWVyLmh0bWwnKTtcblxuY29uc3QgUmVnaXN0ZXJIdG1sVGVtcGxhdGUgPSByZXF1aXJlKCdwb2x5bWVyLXdlYnBhY2stbG9hZGVyL3JlZ2lzdGVyLWh0bWwtdGVtcGxhdGUnKTtcblxuUmVnaXN0ZXJIdG1sVGVtcGxhdGUudG9Cb2R5KFwiPGN1c3RvbS1zdHlsZT4gPHN0eWxlIGlzPWN1c3RvbS1zdHlsZT5odG1sey0tZ29vZ2xlLXJlZC0xMDA6I2Y0YzdjMzstLWdvb2dsZS1yZWQtMzAwOiNlNjdjNzM7LS1nb29nbGUtcmVkLTUwMDojZGI0NDM3Oy0tZ29vZ2xlLXJlZC03MDA6I2M1MzkyOTstLWdvb2dsZS1ibHVlLTEwMDojYzZkYWZjOy0tZ29vZ2xlLWJsdWUtMzAwOiM3YmFhZjc7LS1nb29nbGUtYmx1ZS01MDA6IzQyODVmNDstLWdvb2dsZS1ibHVlLTcwMDojMzM2N2Q2Oy0tZ29vZ2xlLWdyZWVuLTEwMDojYjdlMWNkOy0tZ29vZ2xlLWdyZWVuLTMwMDojNTdiYjhhOy0tZ29vZ2xlLWdyZWVuLTUwMDojMGY5ZDU4Oy0tZ29vZ2xlLWdyZWVuLTcwMDojMGI4MDQzOy0tZ29vZ2xlLXllbGxvdy0xMDA6I2ZjZThiMjstLWdvb2dsZS15ZWxsb3ctMzAwOiNmN2NiNGQ7LS1nb29nbGUteWVsbG93LTUwMDojZjRiNDAwOy0tZ29vZ2xlLXllbGxvdy03MDA6I2YwOTMwMDstLWdvb2dsZS1ncmV5LTEwMDojZjVmNWY1Oy0tZ29vZ2xlLWdyZXktMzAwOiNlMGUwZTA7LS1nb29nbGUtZ3JleS01MDA6IzllOWU5ZTstLWdvb2dsZS1ncmV5LTcwMDojNjE2MTYxOy0tcGFwZXItcmVkLTUwOiNmZmViZWU7LS1wYXBlci1yZWQtMTAwOiNmZmNkZDI7LS1wYXBlci1yZWQtMjAwOiNlZjlhOWE7LS1wYXBlci1yZWQtMzAwOiNlNTczNzM7LS1wYXBlci1yZWQtNDAwOiNlZjUzNTA7LS1wYXBlci1yZWQtNTAwOiNmNDQzMzY7LS1wYXBlci1yZWQtNjAwOiNlNTM5MzU7LS1wYXBlci1yZWQtNzAwOiNkMzJmMmY7LS1wYXBlci1yZWQtODAwOiNjNjI4Mjg7LS1wYXBlci1yZWQtOTAwOiNiNzFjMWM7LS1wYXBlci1yZWQtYTEwMDojZmY4YTgwOy0tcGFwZXItcmVkLWEyMDA6I2ZmNTI1MjstLXBhcGVyLXJlZC1hNDAwOiNmZjE3NDQ7LS1wYXBlci1yZWQtYTcwMDojZDUwMDAwOy0tcGFwZXItcGluay01MDojZmNlNGVjOy0tcGFwZXItcGluay0xMDA6I2Y4YmJkMDstLXBhcGVyLXBpbmstMjAwOiNmNDhmYjE7LS1wYXBlci1waW5rLTMwMDojZjA2MjkyOy0tcGFwZXItcGluay00MDA6I2VjNDA3YTstLXBhcGVyLXBpbmstNTAwOiNlOTFlNjM7LS1wYXBlci1waW5rLTYwMDojZDgxYjYwOy0tcGFwZXItcGluay03MDA6I2MyMTg1YjstLXBhcGVyLXBpbmstODAwOiNhZDE0NTc7LS1wYXBlci1waW5rLTkwMDojODgwZTRmOy0tcGFwZXItcGluay1hMTAwOiNmZjgwYWI7LS1wYXBlci1waW5rLWEyMDA6I2ZmNDA4MTstLXBhcGVyLXBpbmstYTQwMDojZjUwMDU3Oy0tcGFwZXItcGluay1hNzAwOiNjNTExNjI7LS1wYXBlci1wdXJwbGUtNTA6I2YzZTVmNTstLXBhcGVyLXB1cnBsZS0xMDA6I2UxYmVlNzstLXBhcGVyLXB1cnBsZS0yMDA6I2NlOTNkODstLXBhcGVyLXB1cnBsZS0zMDA6I2JhNjhjODstLXBhcGVyLXB1cnBsZS00MDA6I2FiNDdiYzstLXBhcGVyLXB1cnBsZS01MDA6IzljMjdiMDstLXBhcGVyLXB1cnBsZS02MDA6IzhlMjRhYTstLXBhcGVyLXB1cnBsZS03MDA6IzdiMWZhMjstLXBhcGVyLXB1cnBsZS04MDA6IzZhMWI5YTstLXBhcGVyLXB1cnBsZS05MDA6IzRhMTQ4YzstLXBhcGVyLXB1cnBsZS1hMTAwOiNlYTgwZmM7LS1wYXBlci1wdXJwbGUtYTIwMDojZTA0MGZiOy0tcGFwZXItcHVycGxlLWE0MDA6I2Q1MDBmOTstLXBhcGVyLXB1cnBsZS1hNzAwOiNhYTAwZmY7LS1wYXBlci1kZWVwLXB1cnBsZS01MDojZWRlN2Y2Oy0tcGFwZXItZGVlcC1wdXJwbGUtMTAwOiNkMWM0ZTk7LS1wYXBlci1kZWVwLXB1cnBsZS0yMDA6I2IzOWRkYjstLXBhcGVyLWRlZXAtcHVycGxlLTMwMDojOTU3NWNkOy0tcGFwZXItZGVlcC1wdXJwbGUtNDAwOiM3ZTU3YzI7LS1wYXBlci1kZWVwLXB1cnBsZS01MDA6IzY3M2FiNzstLXBhcGVyLWRlZXAtcHVycGxlLTYwMDojNWUzNWIxOy0tcGFwZXItZGVlcC1wdXJwbGUtNzAwOiM1MTJkYTg7LS1wYXBlci1kZWVwLXB1cnBsZS04MDA6IzQ1MjdhMDstLXBhcGVyLWRlZXAtcHVycGxlLTkwMDojMzExYjkyOy0tcGFwZXItZGVlcC1wdXJwbGUtYTEwMDojYjM4OGZmOy0tcGFwZXItZGVlcC1wdXJwbGUtYTIwMDojN2M0ZGZmOy0tcGFwZXItZGVlcC1wdXJwbGUtYTQwMDojNjUxZmZmOy0tcGFwZXItZGVlcC1wdXJwbGUtYTcwMDojNjIwMGVhOy0tcGFwZXItaW5kaWdvLTUwOiNlOGVhZjY7LS1wYXBlci1pbmRpZ28tMTAwOiNjNWNhZTk7LS1wYXBlci1pbmRpZ28tMjAwOiM5ZmE4ZGE7LS1wYXBlci1pbmRpZ28tMzAwOiM3OTg2Y2I7LS1wYXBlci1pbmRpZ28tNDAwOiM1YzZiYzA7LS1wYXBlci1pbmRpZ28tNTAwOiMzZjUxYjU7LS1wYXBlci1pbmRpZ28tNjAwOiMzOTQ5YWI7LS1wYXBlci1pbmRpZ28tNzAwOiMzMDNmOWY7LS1wYXBlci1pbmRpZ28tODAwOiMyODM1OTM7LS1wYXBlci1pbmRpZ28tOTAwOiMxYTIzN2U7LS1wYXBlci1pbmRpZ28tYTEwMDojOGM5ZWZmOy0tcGFwZXItaW5kaWdvLWEyMDA6IzUzNmRmZTstLXBhcGVyLWluZGlnby1hNDAwOiMzZDVhZmU7LS1wYXBlci1pbmRpZ28tYTcwMDojMzA0ZmZlOy0tcGFwZXItYmx1ZS01MDojZTNmMmZkOy0tcGFwZXItYmx1ZS0xMDA6I2JiZGVmYjstLXBhcGVyLWJsdWUtMjAwOiM5MGNhZjk7LS1wYXBlci1ibHVlLTMwMDojNjRiNWY2Oy0tcGFwZXItYmx1ZS00MDA6IzQyYTVmNTstLXBhcGVyLWJsdWUtNTAwOiMyMTk2ZjM7LS1wYXBlci1ibHVlLTYwMDojMWU4OGU1Oy0tcGFwZXItYmx1ZS03MDA6IzE5NzZkMjstLXBhcGVyLWJsdWUtODAwOiMxNTY1YzA7LS1wYXBlci1ibHVlLTkwMDojMGQ0N2ExOy0tcGFwZXItYmx1ZS1hMTAwOiM4MmIxZmY7LS1wYXBlci1ibHVlLWEyMDA6IzQ0OGFmZjstLXBhcGVyLWJsdWUtYTQwMDojMjk3OWZmOy0tcGFwZXItYmx1ZS1hNzAwOiMyOTYyZmY7LS1wYXBlci1saWdodC1ibHVlLTUwOiNlMWY1ZmU7LS1wYXBlci1saWdodC1ibHVlLTEwMDojYjNlNWZjOy0tcGFwZXItbGlnaHQtYmx1ZS0yMDA6IzgxZDRmYTstLXBhcGVyLWxpZ2h0LWJsdWUtMzAwOiM0ZmMzZjc7LS1wYXBlci1saWdodC1ibHVlLTQwMDojMjliNmY2Oy0tcGFwZXItbGlnaHQtYmx1ZS01MDA6IzAzYTlmNDstLXBhcGVyLWxpZ2h0LWJsdWUtNjAwOiMwMzliZTU7LS1wYXBlci1saWdodC1ibHVlLTcwMDojMDI4OGQxOy0tcGFwZXItbGlnaHQtYmx1ZS04MDA6IzAyNzdiZDstLXBhcGVyLWxpZ2h0LWJsdWUtOTAwOiMwMTU3OWI7LS1wYXBlci1saWdodC1ibHVlLWExMDA6IzgwZDhmZjstLXBhcGVyLWxpZ2h0LWJsdWUtYTIwMDojNDBjNGZmOy0tcGFwZXItbGlnaHQtYmx1ZS1hNDAwOiMwMGIwZmY7LS1wYXBlci1saWdodC1ibHVlLWE3MDA6IzAwOTFlYTstLXBhcGVyLWN5YW4tNTA6I2UwZjdmYTstLXBhcGVyLWN5YW4tMTAwOiNiMmViZjI7LS1wYXBlci1jeWFuLTIwMDojODBkZWVhOy0tcGFwZXItY3lhbi0zMDA6IzRkZDBlMTstLXBhcGVyLWN5YW4tNDAwOiMyNmM2ZGE7LS1wYXBlci1jeWFuLTUwMDojMDBiY2Q0Oy0tcGFwZXItY3lhbi02MDA6IzAwYWNjMTstLXBhcGVyLWN5YW4tNzAwOiMwMDk3YTc7LS1wYXBlci1jeWFuLTgwMDojMDA4MzhmOy0tcGFwZXItY3lhbi05MDA6IzAwNjA2NDstLXBhcGVyLWN5YW4tYTEwMDojODRmZmZmOy0tcGFwZXItY3lhbi1hMjAwOiMxOGZmZmY7LS1wYXBlci1jeWFuLWE0MDA6IzAwZTVmZjstLXBhcGVyLWN5YW4tYTcwMDojMDBiOGQ0Oy0tcGFwZXItdGVhbC01MDojZTBmMmYxOy0tcGFwZXItdGVhbC0xMDA6I2IyZGZkYjstLXBhcGVyLXRlYWwtMjAwOiM4MGNiYzQ7LS1wYXBlci10ZWFsLTMwMDojNGRiNmFjOy0tcGFwZXItdGVhbC00MDA6IzI2YTY5YTstLXBhcGVyLXRlYWwtNTAwOiMwMDk2ODg7LS1wYXBlci10ZWFsLTYwMDojMDA4OTdiOy0tcGFwZXItdGVhbC03MDA6IzAwNzk2YjstLXBhcGVyLXRlYWwtODAwOiMwMDY5NWM7LS1wYXBlci10ZWFsLTkwMDojMDA0ZDQwOy0tcGFwZXItdGVhbC1hMTAwOiNhN2ZmZWI7LS1wYXBlci10ZWFsLWEyMDA6IzY0ZmZkYTstLXBhcGVyLXRlYWwtYTQwMDojMWRlOWI2Oy0tcGFwZXItdGVhbC1hNzAwOiMwMGJmYTU7LS1wYXBlci1ncmVlbi01MDojZThmNWU5Oy0tcGFwZXItZ3JlZW4tMTAwOiNjOGU2Yzk7LS1wYXBlci1ncmVlbi0yMDA6I2E1ZDZhNzstLXBhcGVyLWdyZWVuLTMwMDojODFjNzg0Oy0tcGFwZXItZ3JlZW4tNDAwOiM2NmJiNmE7LS1wYXBlci1ncmVlbi01MDA6IzRjYWY1MDstLXBhcGVyLWdyZWVuLTYwMDojNDNhMDQ3Oy0tcGFwZXItZ3JlZW4tNzAwOiMzODhlM2M7LS1wYXBlci1ncmVlbi04MDA6IzJlN2QzMjstLXBhcGVyLWdyZWVuLTkwMDojMWI1ZTIwOy0tcGFwZXItZ3JlZW4tYTEwMDojYjlmNmNhOy0tcGFwZXItZ3JlZW4tYTIwMDojNjlmMGFlOy0tcGFwZXItZ3JlZW4tYTQwMDojMDBlNjc2Oy0tcGFwZXItZ3JlZW4tYTcwMDojMDBjODUzOy0tcGFwZXItbGlnaHQtZ3JlZW4tNTA6I2YxZjhlOTstLXBhcGVyLWxpZ2h0LWdyZWVuLTEwMDojZGNlZGM4Oy0tcGFwZXItbGlnaHQtZ3JlZW4tMjAwOiNjNWUxYTU7LS1wYXBlci1saWdodC1ncmVlbi0zMDA6I2FlZDU4MTstLXBhcGVyLWxpZ2h0LWdyZWVuLTQwMDojOWNjYzY1Oy0tcGFwZXItbGlnaHQtZ3JlZW4tNTAwOiM4YmMzNGE7LS1wYXBlci1saWdodC1ncmVlbi02MDA6IzdjYjM0MjstLXBhcGVyLWxpZ2h0LWdyZWVuLTcwMDojNjg5ZjM4Oy0tcGFwZXItbGlnaHQtZ3JlZW4tODAwOiM1NThiMmY7LS1wYXBlci1saWdodC1ncmVlbi05MDA6IzMzNjkxZTstLXBhcGVyLWxpZ2h0LWdyZWVuLWExMDA6I2NjZmY5MDstLXBhcGVyLWxpZ2h0LWdyZWVuLWEyMDA6I2IyZmY1OTstLXBhcGVyLWxpZ2h0LWdyZWVuLWE0MDA6Izc2ZmYwMzstLXBhcGVyLWxpZ2h0LWdyZWVuLWE3MDA6IzY0ZGQxNzstLXBhcGVyLWxpbWUtNTA6I2Y5ZmJlNzstLXBhcGVyLWxpbWUtMTAwOiNmMGY0YzM7LS1wYXBlci1saW1lLTIwMDojZTZlZTljOy0tcGFwZXItbGltZS0zMDA6I2RjZTc3NTstLXBhcGVyLWxpbWUtNDAwOiNkNGUxNTc7LS1wYXBlci1saW1lLTUwMDojY2RkYzM5Oy0tcGFwZXItbGltZS02MDA6I2MwY2EzMzstLXBhcGVyLWxpbWUtNzAwOiNhZmI0MmI7LS1wYXBlci1saW1lLTgwMDojOWU5ZDI0Oy0tcGFwZXItbGltZS05MDA6IzgyNzcxNzstLXBhcGVyLWxpbWUtYTEwMDojZjRmZjgxOy0tcGFwZXItbGltZS1hMjAwOiNlZWZmNDE7LS1wYXBlci1saW1lLWE0MDA6I2M2ZmYwMDstLXBhcGVyLWxpbWUtYTcwMDojYWVlYTAwOy0tcGFwZXIteWVsbG93LTUwOiNmZmZkZTc7LS1wYXBlci15ZWxsb3ctMTAwOiNmZmY5YzQ7LS1wYXBlci15ZWxsb3ctMjAwOiNmZmY1OWQ7LS1wYXBlci15ZWxsb3ctMzAwOiNmZmYxNzY7LS1wYXBlci15ZWxsb3ctNDAwOiNmZmVlNTg7LS1wYXBlci15ZWxsb3ctNTAwOiNmZmViM2I7LS1wYXBlci15ZWxsb3ctNjAwOiNmZGQ4MzU7LS1wYXBlci15ZWxsb3ctNzAwOiNmYmMwMmQ7LS1wYXBlci15ZWxsb3ctODAwOiNmOWE4MjU7LS1wYXBlci15ZWxsb3ctOTAwOiNmNTdmMTc7LS1wYXBlci15ZWxsb3ctYTEwMDojZmZmZjhkOy0tcGFwZXIteWVsbG93LWEyMDA6I2ZmZmYwMDstLXBhcGVyLXllbGxvdy1hNDAwOiNmZmVhMDA7LS1wYXBlci15ZWxsb3ctYTcwMDojZmZkNjAwOy0tcGFwZXItYW1iZXItNTA6I2ZmZjhlMTstLXBhcGVyLWFtYmVyLTEwMDojZmZlY2IzOy0tcGFwZXItYW1iZXItMjAwOiNmZmUwODI7LS1wYXBlci1hbWJlci0zMDA6I2ZmZDU0ZjstLXBhcGVyLWFtYmVyLTQwMDojZmZjYTI4Oy0tcGFwZXItYW1iZXItNTAwOiNmZmMxMDc7LS1wYXBlci1hbWJlci02MDA6I2ZmYjMwMDstLXBhcGVyLWFtYmVyLTcwMDojZmZhMDAwOy0tcGFwZXItYW1iZXItODAwOiNmZjhmMDA7LS1wYXBlci1hbWJlci05MDA6I2ZmNmYwMDstLXBhcGVyLWFtYmVyLWExMDA6I2ZmZTU3ZjstLXBhcGVyLWFtYmVyLWEyMDA6I2ZmZDc0MDstLXBhcGVyLWFtYmVyLWE0MDA6I2ZmYzQwMDstLXBhcGVyLWFtYmVyLWE3MDA6I2ZmYWIwMDstLXBhcGVyLW9yYW5nZS01MDojZmZmM2UwOy0tcGFwZXItb3JhbmdlLTEwMDojZmZlMGIyOy0tcGFwZXItb3JhbmdlLTIwMDojZmZjYzgwOy0tcGFwZXItb3JhbmdlLTMwMDojZmZiNzRkOy0tcGFwZXItb3JhbmdlLTQwMDojZmZhNzI2Oy0tcGFwZXItb3JhbmdlLTUwMDojZmY5ODAwOy0tcGFwZXItb3JhbmdlLTYwMDojZmI4YzAwOy0tcGFwZXItb3JhbmdlLTcwMDojZjU3YzAwOy0tcGFwZXItb3JhbmdlLTgwMDojZWY2YzAwOy0tcGFwZXItb3JhbmdlLTkwMDojZTY1MTAwOy0tcGFwZXItb3JhbmdlLWExMDA6I2ZmZDE4MDstLXBhcGVyLW9yYW5nZS1hMjAwOiNmZmFiNDA7LS1wYXBlci1vcmFuZ2UtYTQwMDojZmY5MTAwOy0tcGFwZXItb3JhbmdlLWE3MDA6I2ZmNjUwMDstLXBhcGVyLWRlZXAtb3JhbmdlLTUwOiNmYmU5ZTc7LS1wYXBlci1kZWVwLW9yYW5nZS0xMDA6I2ZmY2NiYzstLXBhcGVyLWRlZXAtb3JhbmdlLTIwMDojZmZhYjkxOy0tcGFwZXItZGVlcC1vcmFuZ2UtMzAwOiNmZjhhNjU7LS1wYXBlci1kZWVwLW9yYW5nZS00MDA6I2ZmNzA0MzstLXBhcGVyLWRlZXAtb3JhbmdlLTUwMDojZmY1NzIyOy0tcGFwZXItZGVlcC1vcmFuZ2UtNjAwOiNmNDUxMWU7LS1wYXBlci1kZWVwLW9yYW5nZS03MDA6I2U2NGExOTstLXBhcGVyLWRlZXAtb3JhbmdlLTgwMDojZDg0MzE1Oy0tcGFwZXItZGVlcC1vcmFuZ2UtOTAwOiNiZjM2MGM7LS1wYXBlci1kZWVwLW9yYW5nZS1hMTAwOiNmZjllODA7LS1wYXBlci1kZWVwLW9yYW5nZS1hMjAwOiNmZjZlNDA7LS1wYXBlci1kZWVwLW9yYW5nZS1hNDAwOiNmZjNkMDA7LS1wYXBlci1kZWVwLW9yYW5nZS1hNzAwOiNkZDJjMDA7LS1wYXBlci1icm93bi01MDojZWZlYmU5Oy0tcGFwZXItYnJvd24tMTAwOiNkN2NjYzg7LS1wYXBlci1icm93bi0yMDA6I2JjYWFhNDstLXBhcGVyLWJyb3duLTMwMDojYTE4ODdmOy0tcGFwZXItYnJvd24tNDAwOiM4ZDZlNjM7LS1wYXBlci1icm93bi01MDA6Izc5NTU0ODstLXBhcGVyLWJyb3duLTYwMDojNmQ0YzQxOy0tcGFwZXItYnJvd24tNzAwOiM1ZDQwMzc7LS1wYXBlci1icm93bi04MDA6IzRlMzQyZTstLXBhcGVyLWJyb3duLTkwMDojM2UyNzIzOy0tcGFwZXItZ3JleS01MDojZmFmYWZhOy0tcGFwZXItZ3JleS0xMDA6I2Y1ZjVmNTstLXBhcGVyLWdyZXktMjAwOiNlZWVlZWU7LS1wYXBlci1ncmV5LTMwMDojZTBlMGUwOy0tcGFwZXItZ3JleS00MDA6I2JkYmRiZDstLXBhcGVyLWdyZXktNTAwOiM5ZTllOWU7LS1wYXBlci1ncmV5LTYwMDojNzU3NTc1Oy0tcGFwZXItZ3JleS03MDA6IzYxNjE2MTstLXBhcGVyLWdyZXktODAwOiM0MjQyNDI7LS1wYXBlci1ncmV5LTkwMDojMjEyMTIxOy0tcGFwZXItYmx1ZS1ncmV5LTUwOiNlY2VmZjE7LS1wYXBlci1ibHVlLWdyZXktMTAwOiNjZmQ4ZGM7LS1wYXBlci1ibHVlLWdyZXktMjAwOiNiMGJlYzU7LS1wYXBlci1ibHVlLWdyZXktMzAwOiM5MGE0YWU7LS1wYXBlci1ibHVlLWdyZXktNDAwOiM3ODkwOWM7LS1wYXBlci1ibHVlLWdyZXktNTAwOiM2MDdkOGI7LS1wYXBlci1ibHVlLWdyZXktNjAwOiM1NDZlN2E7LS1wYXBlci1ibHVlLWdyZXktNzAwOiM0NTVhNjQ7LS1wYXBlci1ibHVlLWdyZXktODAwOiMzNzQ3NGY7LS1wYXBlci1ibHVlLWdyZXktOTAwOiMyNjMyMzg7LS1kYXJrLWRpdmlkZXItb3BhY2l0eTowLjEyOy0tZGFyay1kaXNhYmxlZC1vcGFjaXR5OjAuMzg7LS1kYXJrLXNlY29uZGFyeS1vcGFjaXR5OjAuNTQ7LS1kYXJrLXByaW1hcnktb3BhY2l0eTowLjg3Oy0tbGlnaHQtZGl2aWRlci1vcGFjaXR5OjAuMTI7LS1saWdodC1kaXNhYmxlZC1vcGFjaXR5OjAuMzstLWxpZ2h0LXNlY29uZGFyeS1vcGFjaXR5OjAuNzstLWxpZ2h0LXByaW1hcnktb3BhY2l0eToxLjB9PC9zdHlsZT4gPC9jdXN0b20tc3R5bGU+XCIpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9wYXBlci1zdHlsZXMvY29sb3IuaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTUgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cblxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3BvbHltZXIvcG9seW1lci5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vaXJvbi1tZXRhL2lyb24tbWV0YS5odG1sXCI+XG5cbjxzY3JpcHQ+XG4gIC8qKlxuICAgKiBUaGUgYGlyb24taWNvbnNldC1zdmdgIGVsZW1lbnQgYWxsb3dzIHVzZXJzIHRvIGRlZmluZSB0aGVpciBvd24gaWNvbiBzZXRzXG4gICAqIHRoYXQgY29udGFpbiBzdmcgaWNvbnMuIFRoZSBzdmcgaWNvbiBlbGVtZW50cyBzaG91bGQgYmUgY2hpbGRyZW4gb2YgdGhlXG4gICAqIGBpcm9uLWljb25zZXQtc3ZnYCBlbGVtZW50LiBNdWx0aXBsZSBpY29ucyBzaG91bGQgYmUgZ2l2ZW4gZGlzdGluY3QgaWQncy5cbiAgICpcbiAgICogVXNpbmcgc3ZnIGVsZW1lbnRzIHRvIGNyZWF0ZSBpY29ucyBoYXMgYSBmZXcgYWR2YW50YWdlcyBvdmVyIHRyYWRpdGlvbmFsXG4gICAqIGJpdG1hcCBncmFwaGljcyBsaWtlIGpwZyBvciBwbmcuIEljb25zIHRoYXQgdXNlIHN2ZyBhcmUgdmVjdG9yIGJhc2VkIHNvXG4gICAqIHRoZXkgYXJlIHJlc29sdXRpb24gaW5kZXBlbmRlbnQgYW5kIHNob3VsZCBsb29rIGdvb2Qgb24gYW55IGRldmljZS4gVGhleVxuICAgKiBhcmUgc3R5bGFibGUgdmlhIGNzcy4gSWNvbnMgY2FuIGJlIHRoZW1lZCwgY29sb3JpemVkLCBhbmQgZXZlbiBhbmltYXRlZC5cbiAgICpcbiAgICogRXhhbXBsZTpcbiAgICpcbiAgICogICAgIDxpcm9uLWljb25zZXQtc3ZnIG5hbWU9XCJteS1zdmctaWNvbnNcIiBzaXplPVwiMjRcIj5cbiAgICogICAgICAgPHN2Zz5cbiAgICogICAgICAgICA8ZGVmcz5cbiAgICogICAgICAgICAgIDxnIGlkPVwic2hhcGVcIj5cbiAgICogICAgICAgICAgICAgPHJlY3QgeD1cIjEyXCIgeT1cIjBcIiB3aWR0aD1cIjEyXCIgaGVpZ2h0PVwiMjRcIiAvPlxuICAgKiAgICAgICAgICAgICA8Y2lyY2xlIGN4PVwiMTJcIiBjeT1cIjEyXCIgcj1cIjEyXCIgLz5cbiAgICogICAgICAgICAgIDwvZz5cbiAgICogICAgICAgICA8L2RlZnM+XG4gICAqICAgICAgIDwvc3ZnPlxuICAgKiAgICAgPC9pcm9uLWljb25zZXQtc3ZnPlxuICAgKlxuICAgKiBUaGlzIHdpbGwgYXV0b21hdGljYWxseSByZWdpc3RlciB0aGUgaWNvbiBzZXQgXCJteS1zdmctaWNvbnNcIiB0byB0aGUgaWNvbnNldFxuICAgKiBkYXRhYmFzZS4gIFRvIHVzZSB0aGVzZSBpY29ucyBmcm9tIHdpdGhpbiBhbm90aGVyIGVsZW1lbnQsIG1ha2UgYVxuICAgKiBgaXJvbi1pY29uc2V0YCBlbGVtZW50IGFuZCBjYWxsIHRoZSBgYnlJZGAgbWV0aG9kXG4gICAqIHRvIHJldHJpZXZlIGEgZ2l2ZW4gaWNvbnNldC4gVG8gYXBwbHkgYSBwYXJ0aWN1bGFyIGljb24gaW5zaWRlIGFuXG4gICAqIGVsZW1lbnQgdXNlIHRoZSBgYXBwbHlJY29uYCBtZXRob2QuIEZvciBleGFtcGxlOlxuICAgKlxuICAgKiAgICAgaWNvbnNldC5hcHBseUljb24oaWNvbk5vZGUsICdjYXInKTtcbiAgICpcbiAgICogQGVsZW1lbnQgaXJvbi1pY29uc2V0LXN2Z1xuICAgKiBAZGVtbyBkZW1vL2luZGV4Lmh0bWxcbiAgICogQGltcGxlbWVudHMge1BvbHltZXIuSWNvbnNldH1cbiAgICovXG4gIFBvbHltZXIoe1xuICAgIGlzOiAnaXJvbi1pY29uc2V0LXN2ZycsXG5cbiAgICBwcm9wZXJ0aWVzOiB7XG5cbiAgICAgIC8qKlxuICAgICAgICogVGhlIG5hbWUgb2YgdGhlIGljb25zZXQuXG4gICAgICAgKi9cbiAgICAgIG5hbWU6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICBvYnNlcnZlcjogJ19uYW1lQ2hhbmdlZCdcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogVGhlIHNpemUgb2YgYW4gaW5kaXZpZHVhbCBpY29uLiBOb3RlIHRoYXQgaWNvbnMgbXVzdCBiZSBzcXVhcmUuXG4gICAgICAgKi9cbiAgICAgIHNpemU6IHtcbiAgICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgICB2YWx1ZTogMjRcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogU2V0IHRvIHRydWUgdG8gZW5hYmxlIG1pcnJvcmluZyBvZiBpY29ucyB3aGVyZSBzcGVjaWZpZWQgd2hlbiB0aGV5IGFyZVxuICAgICAgICogc3RhbXBlZC4gSWNvbnMgdGhhdCBzaG91bGQgYmUgbWlycm9yZWQgc2hvdWxkIGJlIGRlY29yYXRlZCB3aXRoIGFcbiAgICAgICAqIGBtaXJyb3ItaW4tcnRsYCBhdHRyaWJ1dGUuXG4gICAgICAgKlxuICAgICAgICogTk9URTogRm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMsIGRpcmVjdGlvbiB3aWxsIGJlIHJlc29sdmVkIG9uY2UgcGVyXG4gICAgICAgKiBkb2N1bWVudCBwZXIgaWNvbnNldCwgc28gbW92aW5nIGljb25zIGluIGFuZCBvdXQgb2YgUlRMIHN1YnRyZWVzIHdpbGxcbiAgICAgICAqIG5vdCBjYXVzZSB0aGVpciBtaXJyb3JlZCBzdGF0ZSB0byBjaGFuZ2UuXG4gICAgICAgKi9cbiAgICAgIHJ0bE1pcnJvcmluZzoge1xuICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogU2V0IHRvIHRydWUgdG8gbWVhc3VyZSBSVEwgYmFzZWQgb24gdGhlIGRpciBhdHRyaWJ1dGUgb24gdGhlIGJvZHkgb3JcbiAgICAgICAqIGh0bWwgZWxlbWVudHMgKG1lYXN1cmVkIG9uIGRvY3VtZW50LmJvZHkgb3IgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50IGFzXG4gICAgICAgKiBhdmFpbGFibGUpLlxuICAgICAgICovXG4gICAgICB1c2VHbG9iYWxSdGxBdHRyaWJ1dGU6IHtcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICB9XG4gICAgfSxcblxuICAgIGNyZWF0ZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fbWV0YSA9IG5ldyBQb2x5bWVyLklyb25NZXRhKHt0eXBlOiAnaWNvbnNldCcsIGtleTogbnVsbCwgdmFsdWU6IG51bGx9KTtcbiAgICB9LFxuXG4gICAgYXR0YWNoZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYW4gYXJyYXkgb2YgYWxsIGljb24gbmFtZXMgaW4gdGhpcyBpY29uc2V0LlxuICAgICAqXG4gICAgICogQHJldHVybiB7IUFycmF5fSBBcnJheSBvZiBpY29uIG5hbWVzLlxuICAgICAqL1xuICAgIGdldEljb25OYW1lczogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9pY29ucyA9IHRoaXMuX2NyZWF0ZUljb25NYXAoKTtcbiAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLl9pY29ucykubWFwKGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmFtZSArICc6JyArIG47XG4gICAgICB9LCB0aGlzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQXBwbGllcyBhbiBpY29uIHRvIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogQW4gc3ZnIGljb24gaXMgcHJlcGVuZGVkIHRvIHRoZSBlbGVtZW50J3Mgc2hhZG93Um9vdCBpZiBpdCBleGlzdHMsXG4gICAgICogb3RoZXJ3aXNlIHRvIHRoZSBlbGVtZW50IGl0c2VsZi5cbiAgICAgKlxuICAgICAqIElmIFJUTCBtaXJyb3JpbmcgaXMgZW5hYmxlZCwgYW5kIHRoZSBpY29uIGlzIG1hcmtlZCB0byBiZSBtaXJyb3JlZCBpblxuICAgICAqIFJUTCwgdGhlIGVsZW1lbnQgd2lsbCBiZSB0ZXN0ZWQgKG9uY2UgYW5kIG9ubHkgb25jZSBldmVyIGZvciBlYWNoXG4gICAgICogaWNvbnNldCkgdG8gZGV0ZXJtaW5lIHRoZSBkaXJlY3Rpb24gb2YgdGhlIHN1YnRyZWUgdGhlIGVsZW1lbnQgaXMgaW4uXG4gICAgICogVGhpcyBkaXJlY3Rpb24gd2lsbCBhcHBseSB0byBhbGwgZnV0dXJlIGljb24gYXBwbGljYXRpb25zLCBhbHRob3VnaCBvbmx5XG4gICAgICogaWNvbnMgbWFya2VkIHRvIGJlIG1pcnJvcmVkIHdpbGwgYmUgYWZmZWN0ZWQuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGFwcGx5SWNvblxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRvIHdoaWNoIHRoZSBpY29uIGlzIGFwcGxpZWQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGljb25OYW1lIE5hbWUgb2YgdGhlIGljb24gdG8gYXBwbHkuXG4gICAgICogQHJldHVybiB7P0VsZW1lbnR9IFRoZSBzdmcgZWxlbWVudCB3aGljaCByZW5kZXJzIHRoZSBpY29uLlxuICAgICAqL1xuICAgIGFwcGx5SWNvbjogZnVuY3Rpb24oZWxlbWVudCwgaWNvbk5hbWUpIHtcbiAgICAgIC8vIFJlbW92ZSBvbGQgc3ZnIGVsZW1lbnRcbiAgICAgIHRoaXMucmVtb3ZlSWNvbihlbGVtZW50KTtcbiAgICAgIC8vIGluc3RhbGwgbmV3IHN2ZyBlbGVtZW50XG4gICAgICB2YXIgc3ZnID0gdGhpcy5fY2xvbmVJY29uKGljb25OYW1lLFxuICAgICAgICAgIHRoaXMucnRsTWlycm9yaW5nICYmIHRoaXMuX3RhcmdldElzUlRMKGVsZW1lbnQpKTtcbiAgICAgIGlmIChzdmcpIHtcbiAgICAgICAgLy8gaW5zZXJ0IHN2ZyBlbGVtZW50IGludG8gc2hhZG93IHJvb3QsIGlmIGl0IGV4aXN0c1xuICAgICAgICB2YXIgcGRlID0gUG9seW1lci5kb20oZWxlbWVudC5yb290IHx8IGVsZW1lbnQpO1xuICAgICAgICBwZGUuaW5zZXJ0QmVmb3JlKHN2ZywgcGRlLmNoaWxkTm9kZXNbMF0pO1xuICAgICAgICByZXR1cm4gZWxlbWVudC5fc3ZnSWNvbiA9IHN2ZztcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYW4gaWNvbiBmcm9tIHRoZSBnaXZlbiBlbGVtZW50IGJ5IHVuZG9pbmcgdGhlIGNoYW5nZXMgZWZmZWN0ZWRcbiAgICAgKiBieSBgYXBwbHlJY29uYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCBUaGUgZWxlbWVudCBmcm9tIHdoaWNoIHRoZSBpY29uIGlzIHJlbW92ZWQuXG4gICAgICovXG4gICAgcmVtb3ZlSWNvbjogZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgLy8gUmVtb3ZlIG9sZCBzdmcgZWxlbWVudFxuICAgICAgaWYgKGVsZW1lbnQuX3N2Z0ljb24pIHtcbiAgICAgICAgUG9seW1lci5kb20oZWxlbWVudC5yb290IHx8IGVsZW1lbnQpLnJlbW92ZUNoaWxkKGVsZW1lbnQuX3N2Z0ljb24pO1xuICAgICAgICBlbGVtZW50Ll9zdmdJY29uID0gbnVsbDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWVhc3VyZXMgYW5kIG1lbW9pemVzIHRoZSBkaXJlY3Rpb24gb2YgdGhlIGVsZW1lbnQuIE5vdGUgdGhhdCB0aGlzXG4gICAgICogbWVhc3VyZW1lbnQgaXMgb25seSBkb25lIG9uY2UgYW5kIHRoZSByZXN1bHQgaXMgbWVtb2l6ZWQgZm9yIGZ1dHVyZVxuICAgICAqIGludm9jYXRpb25zLlxuICAgICAqL1xuICAgIF90YXJnZXRJc1JUTDogZnVuY3Rpb24odGFyZ2V0KSB7XG4gICAgICBpZiAodGhpcy5fX3RhcmdldElzUlRMID09IG51bGwpIHtcbiAgICAgICAgaWYgKHRoaXMudXNlR2xvYmFsUnRsQXR0cmlidXRlKSB7XG4gICAgICAgICAgdmFyIGdsb2JhbEVsZW1lbnQgPVxuICAgICAgICAgICAgICAoZG9jdW1lbnQuYm9keSAmJiBkb2N1bWVudC5ib2R5Lmhhc0F0dHJpYnV0ZSgnZGlyJykpXG4gICAgICAgICAgICAgICAgICA/IGRvY3VtZW50LmJvZHlcbiAgICAgICAgICAgICAgICAgIDogZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXG4gICAgICAgICAgdGhpcy5fX3RhcmdldElzUlRMID0gZ2xvYmFsRWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RpcicpID09PSAncnRsJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodGFyZ2V0ICYmIHRhcmdldC5ub2RlVHlwZSAhPT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgICAgIHRhcmdldCA9IHRhcmdldC5ob3N0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuX190YXJnZXRJc1JUTCA9IHRhcmdldCAmJlxuICAgICAgICAgICAgICB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0YXJnZXQpWydkaXJlY3Rpb24nXSA9PT0gJ3J0bCc7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuX190YXJnZXRJc1JUTDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBXaGVuIG5hbWUgaXMgY2hhbmdlZCwgcmVnaXN0ZXIgaWNvbnNldCBtZXRhZGF0YVxuICAgICAqXG4gICAgICovXG4gICAgX25hbWVDaGFuZ2VkOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX21ldGEudmFsdWUgPSBudWxsO1xuICAgICAgdGhpcy5fbWV0YS5rZXkgPSB0aGlzLm5hbWU7XG4gICAgICB0aGlzLl9tZXRhLnZhbHVlID0gdGhpcztcblxuICAgICAgdGhpcy5hc3luYyhmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5maXJlKCdpcm9uLWljb25zZXQtYWRkZWQnLCB0aGlzLCB7bm9kZTogd2luZG93fSk7XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbWFwIG9mIGNoaWxkIFNWRyBlbGVtZW50cyBieSBpZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4geyFPYmplY3R9IE1hcCBvZiBpZCdzIHRvIFNWRyBlbGVtZW50cy5cbiAgICAgKi9cbiAgICBfY3JlYXRlSWNvbk1hcDogZnVuY3Rpb24oKSB7XG4gICAgICAvLyBPYmplY3RzIGNoYWluZWQgdG8gT2JqZWN0LnByb3RvdHlwZSAoYHt9YCkgaGF2ZSBtZW1iZXJzLiBTcGVjaWZpY2FsbHksXG4gICAgICAvLyBvbiBGRiB0aGVyZSBpcyBhIGB3YXRjaGAgbWV0aG9kIHRoYXQgY29uZnVzZXMgdGhlIGljb24gbWFwLCBzbyB3ZVxuICAgICAgLy8gbmVlZCB0byB1c2UgYSBudWxsLWJhc2VkIG9iamVjdCBoZXJlLlxuICAgICAgdmFyIGljb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIFBvbHltZXIuZG9tKHRoaXMpLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tpZF0nKVxuICAgICAgICAuZm9yRWFjaChmdW5jdGlvbihpY29uKSB7XG4gICAgICAgICAgaWNvbnNbaWNvbi5pZF0gPSBpY29uO1xuICAgICAgICB9KTtcbiAgICAgIHJldHVybiBpY29ucztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUHJvZHVjZSBpbnN0YWxsYWJsZSBjbG9uZSBvZiB0aGUgU1ZHIGVsZW1lbnQgbWF0Y2hpbmcgYGlkYCBpbiB0aGlzXG4gICAgICogaWNvbnNldCwgb3IgYHVuZGVmaW5lZGAgaWYgdGhlcmUgaXMgbm8gbWF0Y2hpbmcgZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0VsZW1lbnR9IFJldHVybnMgYW4gaW5zdGFsbGFibGUgY2xvbmUgb2YgdGhlIFNWRyBlbGVtZW50XG4gICAgICogbWF0Y2hpbmcgYGlkYC5cbiAgICAgKi9cbiAgICBfY2xvbmVJY29uOiBmdW5jdGlvbihpZCwgbWlycm9yQWxsb3dlZCkge1xuICAgICAgLy8gY3JlYXRlIHRoZSBpY29uIG1hcCBvbi1kZW1hbmQsIHNpbmNlIHRoZSBpY29uc2V0IGl0c2VsZiBoYXMgbm8gZGlzY3JldGVcbiAgICAgIC8vIHNpZ25hbCB0byBrbm93IHdoZW4gaXQncyBjaGlsZHJlbiBhcmUgZnVsbHkgcGFyc2VkXG4gICAgICB0aGlzLl9pY29ucyA9IHRoaXMuX2ljb25zIHx8IHRoaXMuX2NyZWF0ZUljb25NYXAoKTtcbiAgICAgIHJldHVybiB0aGlzLl9wcmVwYXJlU3ZnQ2xvbmUodGhpcy5faWNvbnNbaWRdLCB0aGlzLnNpemUsIG1pcnJvckFsbG93ZWQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IHNvdXJjZVN2Z1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzaXplXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBtaXJyb3JBbGxvd2VkXG4gICAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICAgKi9cbiAgICBfcHJlcGFyZVN2Z0Nsb25lOiBmdW5jdGlvbihzb3VyY2VTdmcsIHNpemUsIG1pcnJvckFsbG93ZWQpIHtcbiAgICAgIGlmIChzb3VyY2VTdmcpIHtcbiAgICAgICAgdmFyIGNvbnRlbnQgPSBzb3VyY2VTdmcuY2xvbmVOb2RlKHRydWUpLFxuICAgICAgICAgICAgc3ZnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsICdzdmcnKSxcbiAgICAgICAgICAgIHZpZXdCb3ggPSBjb250ZW50LmdldEF0dHJpYnV0ZSgndmlld0JveCcpIHx8ICcwIDAgJyArIHNpemUgKyAnICcgKyBzaXplLFxuICAgICAgICAgICAgY3NzVGV4dCA9ICdwb2ludGVyLWV2ZW50czogbm9uZTsgZGlzcGxheTogYmxvY2s7IHdpZHRoOiAxMDAlOyBoZWlnaHQ6IDEwMCU7JztcblxuICAgICAgICBpZiAobWlycm9yQWxsb3dlZCAmJiBjb250ZW50Lmhhc0F0dHJpYnV0ZSgnbWlycm9yLWluLXJ0bCcpKSB7XG4gICAgICAgICAgY3NzVGV4dCArPSAnLXdlYmtpdC10cmFuc2Zvcm06c2NhbGUoLTEsMSk7dHJhbnNmb3JtOnNjYWxlKC0xLDEpOyc7XG4gICAgICAgIH1cblxuICAgICAgICBzdmcuc2V0QXR0cmlidXRlKCd2aWV3Qm94Jywgdmlld0JveCk7XG4gICAgICAgIHN2Zy5zZXRBdHRyaWJ1dGUoJ3ByZXNlcnZlQXNwZWN0UmF0aW8nLCAneE1pZFlNaWQgbWVldCcpO1xuICAgICAgICBzdmcuc2V0QXR0cmlidXRlKCdmb2N1c2FibGUnLCAnZmFsc2UnKTtcbiAgICAgICAgLy8gVE9ETyhkZnJlZWRtKTogYHBvaW50ZXItZXZlbnRzOiBub25lYCB3b3JrcyBhcm91bmQgaHR0cHM6Ly9jcmJ1Zy5jb20vMzcwMTM2XG4gICAgICAgIC8vIFRPRE8oc2ptaWxlcyk6IGlubGluZSBzdHlsZSBtYXkgbm90IGJlIGlkZWFsLCBidXQgYXZvaWRzIHJlcXVpcmluZyBhIHNoYWRvdy1yb290XG4gICAgICAgIHN2Zy5zdHlsZS5jc3NUZXh0ID0gY3NzVGV4dDtcbiAgICAgICAgc3ZnLmFwcGVuZENoaWxkKGNvbnRlbnQpLnJlbW92ZUF0dHJpYnV0ZSgnaWQnKTtcbiAgICAgICAgcmV0dXJuIHN2ZztcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICB9KTtcblxuPC9zY3JpcHQ+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL2lyb24taWNvbnNldC1zdmcvaXJvbi1pY29uc2V0LXN2Zy5odG1sIiwiPCEtLVxyXG5AbGljZW5zZVxyXG5Db3B5cmlnaHQgKGMpIDIwMTYgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XHJcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XHJcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxyXG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xyXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxyXG4tLT5cclxuXHJcbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi9ib3dlcl9jb21wb25lbnRzL3BvbHltZXIvcG9seW1lci1lbGVtZW50Lmh0bWxcIj5cclxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL2Jvd2VyX2NvbXBvbmVudHMvYXBwLWxheW91dC9hcHAtZHJhd2VyL2FwcC1kcmF3ZXIuaHRtbFwiPlxyXG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vYm93ZXJfY29tcG9uZW50cy9hcHAtbGF5b3V0L2FwcC1kcmF3ZXItbGF5b3V0L2FwcC1kcmF3ZXItbGF5b3V0Lmh0bWxcIj5cclxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL2Jvd2VyX2NvbXBvbmVudHMvYXBwLWxheW91dC9hcHAtaGVhZGVyL2FwcC1oZWFkZXIuaHRtbFwiPlxyXG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vYm93ZXJfY29tcG9uZW50cy9hcHAtbGF5b3V0L2FwcC1oZWFkZXItbGF5b3V0L2FwcC1oZWFkZXItbGF5b3V0Lmh0bWxcIj5cclxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL2Jvd2VyX2NvbXBvbmVudHMvYXBwLWxheW91dC9hcHAtc2Nyb2xsLWVmZmVjdHMvYXBwLXNjcm9sbC1lZmZlY3RzLmh0bWxcIj5cclxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL2Jvd2VyX2NvbXBvbmVudHMvYXBwLWxheW91dC9hcHAtdG9vbGJhci9hcHAtdG9vbGJhci5odG1sXCI+XHJcbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi9ib3dlcl9jb21wb25lbnRzL2FwcC1yb3V0ZS9hcHAtbG9jYXRpb24uaHRtbFwiPlxyXG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vYm93ZXJfY29tcG9uZW50cy9hcHAtcm91dGUvYXBwLXJvdXRlLmh0bWxcIj5cclxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL2Jvd2VyX2NvbXBvbmVudHMvaXJvbi1wYWdlcy9pcm9uLXBhZ2VzLmh0bWxcIj5cclxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL2Jvd2VyX2NvbXBvbmVudHMvaXJvbi1zZWxlY3Rvci9pcm9uLXNlbGVjdG9yLmh0bWxcIj5cclxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL2Jvd2VyX2NvbXBvbmVudHMvcGFwZXItaWNvbi1idXR0b24vcGFwZXItaWNvbi1idXR0b24uaHRtbFwiPlxyXG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwibXktaWNvbnMuaHRtbFwiPlxyXG5cclxuPGRvbS1tb2R1bGUgaWQ9XCJteS1hcHBcIj5cclxuICA8dGVtcGxhdGU+XHJcbiAgICA8c3R5bGU+XHJcbiAgICAgIDpob3N0IHtcclxuICAgICAgICAtLWFwcC1wcmltYXJ5LWNvbG9yOiAjM0QyODE0O1xyXG4gICAgICAgIC0tYXBwLXNlY29uZGFyeS1jb2xvcjogI0ZGM0MzQztcclxuXHJcbiAgICAgICAgZGlzcGxheTogYmxvY2s7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGFwcC1kcmF3ZXItbGF5b3V0Om5vdChbbmFycm93XSkgW2RyYXdlci10b2dnbGVdIHtcclxuICAgICAgICBkaXNwbGF5OiBub25lO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBhcHAtaGVhZGVyIHtcclxuICAgICAgICBjb2xvcjogI2ZmZjtcclxuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1hcHAtcHJpbWFyeS1jb2xvcik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGFwcC1oZWFkZXIgcGFwZXItaWNvbi1idXR0b24ge1xyXG4gICAgICAgIC0tcGFwZXItaWNvbi1idXR0b24taW5rLWNvbG9yOiB3aGl0ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLmRyYXdlci1saXN0IHtcclxuICAgICAgICBtYXJnaW46IDAgMjBweDtcclxuICAgICAgfVxyXG5cclxuICAgICAgLmRyYXdlci1saXN0IGEge1xyXG4gICAgICAgIGRpc3BsYXk6IGJsb2NrO1xyXG4gICAgICAgIHBhZGRpbmc6IDAgMTZweDtcclxuICAgICAgICB0ZXh0LWRlY29yYXRpb246IG5vbmU7XHJcbiAgICAgICAgY29sb3I6IHZhcigtLWFwcC1zZWNvbmRhcnktY29sb3IpO1xyXG4gICAgICAgIGxpbmUtaGVpZ2h0OiA0MHB4O1xyXG4gICAgICB9XHJcblxyXG4gICAgICAuZHJhd2VyLWxpc3QgYS5pcm9uLXNlbGVjdGVkIHtcclxuICAgICAgICBjb2xvcjogYmxhY2s7XHJcbiAgICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XHJcbiAgICAgIH1cclxuICAgIDwvc3R5bGU+XHJcblxyXG4gICAgPGFwcC1sb2NhdGlvbiByb3V0ZT1cInt7cm91dGV9fVwiIHVybC1zcGFjZS1yZWdleD1cIl5bW3Jvb3RQYXRoXV1cIj48L2FwcC1sb2NhdGlvbj5cclxuICAgIDxhcHAtcm91dGVcclxuICAgICAgICByb3V0ZT1cInt7cm91dGV9fVwiXHJcbiAgICAgICAgcGF0dGVybj1cIltbcm9vdFBhdGhdXTpwYWdlXCJcclxuICAgICAgICBkYXRhPVwie3tyb3V0ZURhdGF9fVwiXHJcbiAgICAgICAgdGFpbD1cInt7c3Vicm91dGV9fVwiPjwvYXBwLXJvdXRlPlxyXG5cclxuICAgIDxhcHAtZHJhd2VyLWxheW91dCBmdWxsYmxlZWQ+XHJcbiAgICAgIDwhLS0gRHJhd2VyIGNvbnRlbnQgLS0+XHJcbiAgICAgIDxhcHAtZHJhd2VyIGlkPVwiZHJhd2VyXCIgc2xvdD1cImRyYXdlclwiPlxyXG4gICAgICAgIDxhcHAtdG9vbGJhcj5NZW51PC9hcHAtdG9vbGJhcj5cclxuICAgICAgICA8aXJvbi1zZWxlY3RvciBzZWxlY3RlZD1cIltbcGFnZV1dXCIgYXR0ci1mb3Itc2VsZWN0ZWQ9XCJuYW1lXCIgY2xhc3M9XCJkcmF3ZXItbGlzdFwiIHJvbGU9XCJuYXZpZ2F0aW9uXCI+XHJcbiAgICAgICAgICA8YSBuYW1lPVwidmlldzFcIiBocmVmJD1cIltbcm9vdFBhdGhdXXZpZXcxXCI+U3VjaGU8L2E+XHJcbiAgICAgICAgICA8YSBuYW1lPVwidmlldzJcIiBocmVmJD1cIltbcm9vdFBhdGhdXXZpZXcyXCI+VmVybGFnPC9hPlxyXG4gICAgICAgICAgPGEgbmFtZT1cInZpZXczXCIgaHJlZiQ9XCJbW3Jvb3RQYXRoXV12aWV3M1wiPkF1dGhvcjwvYT5cclxuICAgICAgICA8L2lyb24tc2VsZWN0b3I+XHJcbiAgICAgIDwvYXBwLWRyYXdlcj5cclxuXHJcbiAgICAgIDwhLS0gTWFpbiBjb250ZW50IC0tPlxyXG4gICAgICA8YXBwLWhlYWRlci1sYXlvdXQgaGFzLXNjcm9sbGluZy1yZWdpb24+XHJcblxyXG4gICAgICAgIDxhcHAtaGVhZGVyIHNsb3Q9XCJoZWFkZXJcIiBjb25kZW5zZXMgcmV2ZWFscyBlZmZlY3RzPVwid2F0ZXJmYWxsXCI+XHJcbiAgICAgICAgICA8YXBwLXRvb2xiYXI+XHJcbiAgICAgICAgICAgIDxwYXBlci1pY29uLWJ1dHRvbiBpY29uPVwibXktaWNvbnM6bWVudVwiIGRyYXdlci10b2dnbGU+PC9wYXBlci1pY29uLWJ1dHRvbj5cclxuICAgICAgICAgICAgPGRpdiBtYWluLXRpdGxlPkx1ZGluZy5vcmc8L2Rpdj5cclxuICAgICAgICAgIDwvYXBwLXRvb2xiYXI+XHJcbiAgICAgICAgPC9hcHAtaGVhZGVyPlxyXG5cclxuICAgICAgICA8aXJvbi1wYWdlc1xyXG4gICAgICAgICAgICBzZWxlY3RlZD1cIltbcGFnZV1dXCJcclxuICAgICAgICAgICAgYXR0ci1mb3Itc2VsZWN0ZWQ9XCJuYW1lXCJcclxuICAgICAgICAgICAgZmFsbGJhY2stc2VsZWN0aW9uPVwidmlldzQwNFwiXHJcbiAgICAgICAgICAgIHJvbGU9XCJtYWluXCI+XHJcbiAgICAgICAgICA8bXktdmlldzEgbmFtZT1cInZpZXcxXCI+PC9teS12aWV3MT5cclxuICAgICAgICAgIDxteS12aWV3MiBuYW1lPVwidmlldzJcIj48L215LXZpZXcyPlxyXG4gICAgICAgICAgPG15LXZpZXczIG5hbWU9XCJ2aWV3M1wiPjwvbXktdmlldzM+XHJcbiAgICAgICAgICA8bXktdmlldzQwNCBuYW1lPVwidmlldzQwNFwiPjwvbXktdmlldzQwND5cclxuICAgICAgICA8L2lyb24tcGFnZXM+XHJcbiAgICAgIDwvYXBwLWhlYWRlci1sYXlvdXQ+XHJcbiAgICA8L2FwcC1kcmF3ZXItbGF5b3V0PlxyXG4gIDwvdGVtcGxhdGU+XHJcblxyXG4gIDxzY3JpcHQ+XHJcbiAgICBjbGFzcyBNeUFwcCBleHRlbmRzIFBvbHltZXIuRWxlbWVudCB7XHJcblxyXG4gICAgICBzdGF0aWMgZ2V0IGlzKCkgeyByZXR1cm4gJ215LWFwcCc7IH1cclxuXHJcbiAgICAgIHN0YXRpYyBnZXQgcHJvcGVydGllcygpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgcGFnZToge1xyXG4gICAgICAgICAgICB0eXBlOiBTdHJpbmcsXHJcbiAgICAgICAgICAgIHJlZmxlY3RUb0F0dHJpYnV0ZTogdHJ1ZSxcclxuICAgICAgICAgICAgb2JzZXJ2ZXI6ICdfcGFnZUNoYW5nZWQnLFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIHJvdXRlRGF0YTogT2JqZWN0LFxyXG4gICAgICAgICAgc3Vicm91dGU6IFN0cmluZyxcclxuICAgICAgICAgIHJvb3RQYXRoOiB7XHJcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcclxuICAgICAgICAgICAgdmFsdWU6ICcvJ1xyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIGxhenlQYWdlczoge1xyXG4gICAgICAgICAgICB0eXBlOiBPYmplY3QsXHJcbiAgICAgICAgICAgIHZhbHVlOiB7XHJcbiAgICAgICAgICAgICAgdmlldzE6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgaW1wb3J0KC8qIHdlYnBhY2tDaHVua05hbWU6IFwibXktdmlldzFcIiAqLyAnLi9teS12aWV3MS5odG1sJyk7XHJcbiAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICB2aWV3MjogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICBpbXBvcnQoLyogd2VicGFja0NodW5rTmFtZTogXCJteS12aWV3MlwiICovICcuL215LXZpZXcyLmh0bWwnKTtcclxuICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgIHZpZXczOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIGltcG9ydCgvKiB3ZWJwYWNrQ2h1bmtOYW1lOiBcIm15LXZpZXczXCIgKi8gJy4vbXktdmlldzMuaHRtbCcpO1xyXG4gICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgdmlldzQwNDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICBpbXBvcnQoLyogd2VicGFja0NodW5rTmFtZTogXCJteS12aWV3NDA0XCIgKi8gJy4vbXktdmlldzQwNC5odG1sJyk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgfVxyXG5cclxuICAgICAgc3RhdGljIGdldCBvYnNlcnZlcnMoKSB7XHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICdfcm91dGVQYWdlQ2hhbmdlZChyb3V0ZURhdGEucGFnZSknLFxyXG4gICAgICAgIF07XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIF9yb3V0ZVBhZ2VDaGFuZ2VkKHBhZ2UpIHtcclxuICAgICAgICAvLyBQb2x5bWVyIDIuMCB3aWxsIGNhbGwgd2l0aCBgdW5kZWZpbmVkYCBvbiBpbml0aWFsaXphdGlvbi5cclxuICAgICAgICAvLyBJZ25vcmUgdW50aWwgd2UgYXJlIHByb3Blcmx5IGNhbGxlZCB3aXRoIGEgc3RyaW5nLlxyXG4gICAgICAgIGlmIChwYWdlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIElmIG5vIHBhZ2Ugd2FzIGZvdW5kIGluIHRoZSByb3V0ZSBkYXRhLCBwYWdlIHdpbGwgYmUgYW4gZW1wdHkgc3RyaW5nLlxyXG4gICAgICAgIC8vIERlYXVsdCB0byAndmlldzEnIGluIHRoYXQgY2FzZS5cclxuICAgICAgICB0aGlzLnBhZ2UgPSBwYWdlIHx8ICd2aWV3MSc7XHJcblxyXG4gICAgICAgIC8vIENsb3NlIGEgbm9uLXBlcnNpc3RlbnQgZHJhd2VyIHdoZW4gdGhlIHBhZ2UgJiByb3V0ZSBhcmUgY2hhbmdlZC5cclxuICAgICAgICBpZiAoIXRoaXMuJC5kcmF3ZXIucGVyc2lzdGVudCkge1xyXG4gICAgICAgICAgdGhpcy4kLmRyYXdlci5jbG9zZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgX3BhZ2VDaGFuZ2VkKHBhZ2UpIHtcclxuICAgICAgICBpZih0aGlzLmxhenlQYWdlc1twYWdlXSl7XHJcbiAgICAgICAgICB0aGlzLmxhenlQYWdlc1twYWdlXSgpOyAgICAgICBcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdGhpcy5fc2hvd1BhZ2U0MDQoKTtcclxuICAgICAgICB9ICAgICAgICBcclxuICAgICAgfVxyXG5cclxuICAgICAgX3Nob3dQYWdlNDA0KCkge1xyXG4gICAgICAgIHRoaXMucGFnZSA9ICd2aWV3NDA0JztcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHdpbmRvdy5jdXN0b21FbGVtZW50cy5kZWZpbmUoTXlBcHAuaXMsIE15QXBwKTtcclxuICA8L3NjcmlwdD5cclxuPC9kb20tbW9kdWxlPlxyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvbXktYXBwLmh0bWwiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vdXRpbHMvYm9vdC5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vdXRpbHMvcmVzb2x2ZS11cmwuaHRtbFwiPlxuPHNjcmlwdD5cbihmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIGxldCBtb2R1bGVzID0ge307XG4gIGxldCBsY01vZHVsZXMgPSB7fTtcbiAgZnVuY3Rpb24gZmluZE1vZHVsZShpZCkge1xuICAgIHJldHVybiBtb2R1bGVzW2lkXSB8fCBsY01vZHVsZXNbaWQudG9Mb3dlckNhc2UoKV07XG4gIH1cblxuICBmdW5jdGlvbiBzdHlsZU91dHNpZGVUZW1wbGF0ZUNoZWNrKGluc3QpIHtcbiAgICBpZiAoaW5zdC5xdWVyeVNlbGVjdG9yKCdzdHlsZScpKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ2RvbS1tb2R1bGUgJXMgaGFzIHN0eWxlIG91dHNpZGUgdGVtcGxhdGUnLCBpbnN0LmlkKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVGhlIGBkb20tbW9kdWxlYCBlbGVtZW50IHJlZ2lzdGVycyB0aGUgZG9tIGl0IGNvbnRhaW5zIHRvIHRoZSBuYW1lIGdpdmVuXG4gICAqIGJ5IHRoZSBtb2R1bGUncyBpZCBhdHRyaWJ1dGUuIEl0IHByb3ZpZGVzIGEgdW5pZmllZCBkYXRhYmFzZSBvZiBkb21cbiAgICogYWNjZXNzaWJsZSB2aWEgaXRzIHN0YXRpYyBgaW1wb3J0YCBBUEkuXG4gICAqXG4gICAqIEEga2V5IHVzZSBjYXNlIG9mIGBkb20tbW9kdWxlYCBpcyBmb3IgcHJvdmlkaW5nIGN1c3RvbSBlbGVtZW50IGA8dGVtcGxhdGU+YHNcbiAgICogdmlhIEhUTUwgaW1wb3J0cyB0aGF0IGFyZSBwYXJzZWQgYnkgdGhlIG5hdGl2ZSBIVE1MIHBhcnNlciwgdGhhdCBjYW4gYmVcbiAgICogcmVsb2NhdGVkIGR1cmluZyBhIGJ1bmRsaW5nIHBhc3MgYW5kIHN0aWxsIGxvb2tlZCB1cCBieSBgaWRgLlxuICAgKlxuICAgKiBFeGFtcGxlOlxuICAgKlxuICAgKiAgICAgPGRvbS1tb2R1bGUgaWQ9XCJmb29cIj5cbiAgICogICAgICAgPGltZyBzcmM9XCJzdHVmZi5wbmdcIj5cbiAgICogICAgIDwvZG9tLW1vZHVsZT5cbiAgICpcbiAgICogVGhlbiBpbiBjb2RlIGluIHNvbWUgb3RoZXIgbG9jYXRpb24gdGhhdCBjYW5ub3QgYWNjZXNzIHRoZSBkb20tbW9kdWxlIGFib3ZlXG4gICAqXG4gICAqICAgICBsZXQgaW1nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZG9tLW1vZHVsZScpLmltcG9ydCgnZm9vJywgJ2ltZycpO1xuICAgKlxuICAgKiBAY3VzdG9tRWxlbWVudFxuICAgKiBAZXh0ZW5kcyBIVE1MRWxlbWVudFxuICAgKiBAbWVtYmVyb2YgUG9seW1lclxuICAgKiBAc3VtbWFyeSBDdXN0b20gZWxlbWVudCB0aGF0IHByb3ZpZGVzIGEgcmVnaXN0cnkgb2YgcmVsb2NhdGFibGUgRE9NIGNvbnRlbnRcbiAgICogICBieSBgaWRgIHRoYXQgaXMgYWdub3N0aWMgdG8gYnVuZGxpbmcuXG4gICAqIEB1bnJlc3RyaWN0ZWRcbiAgICovXG4gIGNsYXNzIERvbU1vZHVsZSBleHRlbmRzIEhUTUxFbGVtZW50IHtcblxuICAgIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkgeyByZXR1cm4gWydpZCddIH1cblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgZWxlbWVudCBzcGVjaWZpZWQgYnkgdGhlIGNzcyBgc2VsZWN0b3JgIGluIHRoZSBtb2R1bGVcbiAgICAgKiByZWdpc3RlcmVkIGJ5IGBpZGAuIEZvciBleGFtcGxlLCB0aGlzLmltcG9ydCgnZm9vJywgJ2ltZycpO1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBUaGUgaWQgb2YgdGhlIGRvbS1tb2R1bGUgaW4gd2hpY2ggdG8gc2VhcmNoLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nPX0gc2VsZWN0b3IgVGhlIGNzcyBzZWxlY3RvciBieSB3aGljaCB0byBmaW5kIHRoZSBlbGVtZW50LlxuICAgICAqIEByZXR1cm4ge0VsZW1lbnR9IFJldHVybnMgdGhlIGVsZW1lbnQgd2hpY2ggbWF0Y2hlcyBgc2VsZWN0b3JgIGluIHRoZVxuICAgICAqIG1vZHVsZSByZWdpc3RlcmVkIGF0IHRoZSBzcGVjaWZpZWQgYGlkYC5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW1wb3J0KGlkLCBzZWxlY3Rvcikge1xuICAgICAgaWYgKGlkKSB7XG4gICAgICAgIGxldCBtID0gZmluZE1vZHVsZShpZCk7XG4gICAgICAgIGlmIChtICYmIHNlbGVjdG9yKSB7XG4gICAgICAgICAgcmV0dXJuIG0ucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG07XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgb2xkLCB2YWx1ZSkge1xuICAgICAgaWYgKG9sZCAhPT0gdmFsdWUpIHtcbiAgICAgICAgdGhpcy5yZWdpc3RlcigpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBhYnNvbHV0ZSBVUkwgb2YgdGhlIG9yaWdpbmFsIGxvY2F0aW9uIG9mIHRoaXMgYGRvbS1tb2R1bGVgLlxuICAgICAqXG4gICAgICogVGhpcyB2YWx1ZSB3aWxsIGRpZmZlciBmcm9tIHRoaXMgZWxlbWVudCdzIGBvd25lckRvY3VtZW50YCBpbiB0aGVcbiAgICAgKiBmb2xsb3dpbmcgd2F5czpcbiAgICAgKiAtIFRha2VzIGludG8gYWNjb3VudCBhbnkgYGFzc2V0cGF0aGAgYXR0cmlidXRlIGFkZGVkIGR1cmluZyBidW5kbGluZ1xuICAgICAqICAgdG8gaW5kaWNhdGUgdGhlIG9yaWdpbmFsIGxvY2F0aW9uIHJlbGF0aXZlIHRvIHRoZSBidW5kbGVkIGxvY2F0aW9uXG4gICAgICogLSBVc2VzIHRoZSBIVE1MSW1wb3J0cyBwb2x5ZmlsbCdzIGBpbXBvcnRGb3JFbGVtZW50YCBBUEkgdG8gZW5zdXJlXG4gICAgICogICB0aGUgcGF0aCBpcyByZWxhdGl2ZSB0byB0aGUgaW1wb3J0IGRvY3VtZW50J3MgbG9jYXRpb24gc2luY2VcbiAgICAgKiAgIGBvd25lckRvY3VtZW50YCBpcyBub3QgY3VycmVudGx5IHBvbHlmaWxsZWRcbiAgICAgKi9cbiAgICBnZXQgYXNzZXRwYXRoKCkge1xuICAgICAgLy8gRG9uJ3Qgb3ZlcnJpZGUgZXhpc3RpbmcgYXNzZXRwYXRoLlxuICAgICAgaWYgKCF0aGlzLl9fYXNzZXRwYXRoKSB7XG4gICAgICAgIC8vIG5vdGU6IGFzc2V0cGF0aCBzZXQgdmlhIGFuIGF0dHJpYnV0ZSBtdXN0IGJlIHJlbGF0aXZlIHRvIHRoaXNcbiAgICAgICAgLy8gZWxlbWVudCdzIGxvY2F0aW9uOyBhY2NvbW9kYXRlIHBvbHlmaWxsZWQgSFRNTEltcG9ydHNcbiAgICAgICAgY29uc3Qgb3duZXIgPSB3aW5kb3cuSFRNTEltcG9ydHMgJiYgSFRNTEltcG9ydHMuaW1wb3J0Rm9yRWxlbWVudCA/XG4gICAgICAgICAgSFRNTEltcG9ydHMuaW1wb3J0Rm9yRWxlbWVudCh0aGlzKSB8fCBkb2N1bWVudCA6IHRoaXMub3duZXJEb2N1bWVudDtcbiAgICAgICAgY29uc3QgdXJsID0gUG9seW1lci5SZXNvbHZlVXJsLnJlc29sdmVVcmwoXG4gICAgICAgICAgdGhpcy5nZXRBdHRyaWJ1dGUoJ2Fzc2V0cGF0aCcpIHx8ICcnLCBvd25lci5iYXNlVVJJKTtcbiAgICAgICAgdGhpcy5fX2Fzc2V0cGF0aCA9IFBvbHltZXIuUmVzb2x2ZVVybC5wYXRoRnJvbVVybCh1cmwpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX19hc3NldHBhdGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIHRoZSBkb20tbW9kdWxlIGF0IGEgZ2l2ZW4gaWQuIFRoaXMgbWV0aG9kIHNob3VsZCBvbmx5IGJlIGNhbGxlZFxuICAgICAqIHdoZW4gYSBkb20tbW9kdWxlIGlzIGltcGVyYXRpdmVseSBjcmVhdGVkLiBGb3JcbiAgICAgKiBleGFtcGxlLCBgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZG9tLW1vZHVsZScpLnJlZ2lzdGVyKCdmb28nKWAuXG4gICAgICogQHBhcmFtIHtzdHJpbmc9fSBpZCBUaGUgaWQgYXQgd2hpY2ggdG8gcmVnaXN0ZXIgdGhlIGRvbS1tb2R1bGUuXG4gICAgICovXG4gICAgcmVnaXN0ZXIoaWQpIHtcbiAgICAgIGlkID0gaWQgfHwgdGhpcy5pZDtcbiAgICAgIGlmIChpZCkge1xuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgIC8vIHN0b3JlIGlkIHNlcGFyYXRlIGZyb20gbG93ZXJjYXNlZCBpZCBzbyB0aGF0XG4gICAgICAgIC8vIGluIGFsbCBjYXNlcyBtaXhlZENhc2UgaWQgd2lsbCBzdG9yZWQgZGlzdGluY3RseVxuICAgICAgICAvLyBhbmQgbG93ZXJjYXNlIHZlcnNpb24gaXMgYSBmYWxsYmFja1xuICAgICAgICBtb2R1bGVzW2lkXSA9IHRoaXM7XG4gICAgICAgIGxjTW9kdWxlc1tpZC50b0xvd2VyQ2FzZSgpXSA9IHRoaXM7XG4gICAgICAgIHN0eWxlT3V0c2lkZVRlbXBsYXRlQ2hlY2sodGhpcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgRG9tTW9kdWxlLnByb3RvdHlwZVsnbW9kdWxlcyddID0gbW9kdWxlcztcblxuICBjdXN0b21FbGVtZW50cy5kZWZpbmUoJ2RvbS1tb2R1bGUnLCBEb21Nb2R1bGUpO1xuXG4gIC8vIGV4cG9ydFxuICBQb2x5bWVyLkRvbU1vZHVsZSA9IERvbU1vZHVsZTtcblxufSkoKTtcbjwvc2NyaXB0PlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi9lbGVtZW50cy9kb20tbW9kdWxlLmh0bWwiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCJib290Lmh0bWxcIj5cblxuPHNjcmlwdD5cbihmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8qKlxuICAgKiBNb2R1bGUgd2l0aCB1dGlsaXRpZXMgZm9yIG1hbmlwdWxhdGluZyBzdHJ1Y3R1cmVkIGRhdGEgcGF0aCBzdHJpbmdzLlxuICAgKlxuICAgKiBAbmFtZXNwYWNlXG4gICAqIEBtZW1iZXJvZiBQb2x5bWVyXG4gICAqIEBzdW1tYXJ5IE1vZHVsZSB3aXRoIHV0aWxpdGllcyBmb3IgbWFuaXB1bGF0aW5nIHN0cnVjdHVyZWQgZGF0YSBwYXRoIHN0cmluZ3MuXG4gICAqL1xuICBjb25zdCBQYXRoID0ge1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBzdHJpbmcgaXMgYSBzdHJ1Y3R1cmVkIGRhdGEgcGF0aCAoaGFzIGRvdHMpLlxuICAgICAqXG4gICAgICogRXhhbXBsZTpcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIFBvbHltZXIuUGF0aC5pc1BhdGgoJ2Zvby5iYXIuYmF6JykgLy8gdHJ1ZVxuICAgICAqIFBvbHltZXIuUGF0aC5pc1BhdGgoJ2ZvbycpICAgICAgICAgLy8gZmFsc2VcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBQb2x5bWVyLlBhdGhcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBQYXRoIHN0cmluZ1xuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIHN0cmluZyBjb250YWluZWQgb25lIG9yIG1vcmUgZG90c1xuICAgICAqL1xuICAgIGlzUGF0aDogZnVuY3Rpb24ocGF0aCkge1xuICAgICAgcmV0dXJuIHBhdGguaW5kZXhPZignLicpID49IDA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHJvb3QgcHJvcGVydHkgbmFtZSBmb3IgdGhlIGdpdmVuIHBhdGguXG4gICAgICpcbiAgICAgKiBFeGFtcGxlOlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogUG9seW1lci5QYXRoLnJvb3QoJ2Zvby5iYXIuYmF6JykgLy8gJ2ZvbydcbiAgICAgKiBQb2x5bWVyLlBhdGgucm9vdCgnZm9vJykgICAgICAgICAvLyAnZm9vJ1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIFBvbHltZXIuUGF0aFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFBhdGggc3RyaW5nXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBSb290IHByb3BlcnR5IG5hbWVcbiAgICAgKi9cbiAgICByb290OiBmdW5jdGlvbihwYXRoKSB7XG4gICAgICBsZXQgZG90SW5kZXggPSBwYXRoLmluZGV4T2YoJy4nKTtcbiAgICAgIGlmIChkb3RJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGF0aC5zbGljZSgwLCBkb3RJbmRleCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdpdmVuIGBiYXNlYCBpcyBgZm9vLmJhcmAsIGBmb29gIGlzIGFuIGFuY2VzdG9yLCBgZm9vLmJhcmAgaXMgbm90XG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBwYXRoIGlzIGFuIGFuY2VzdG9yIG9mIHRoZSBiYXNlIHBhdGguXG4gICAgICpcbiAgICAgKiBFeGFtcGxlOlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogUG9seW1lci5QYXRoLmlzQW5jZXN0b3IoJ2Zvby5iYXInLCAnZm9vJykgICAgICAgICAvLyB0cnVlXG4gICAgICogUG9seW1lci5QYXRoLmlzQW5jZXN0b3IoJ2Zvby5iYXInLCAnZm9vLmJhcicpICAgICAvLyBmYWxzZVxuICAgICAqIFBvbHltZXIuUGF0aC5pc0FuY2VzdG9yKCdmb28uYmFyJywgJ2Zvby5iYXIuYmF6JykgLy8gZmFsc2VcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBQb2x5bWVyLlBhdGhcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYmFzZSBQYXRoIHN0cmluZyB0byB0ZXN0IGFnYWluc3QuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggUGF0aCBzdHJpbmcgdG8gdGVzdC5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGBwYXRoYCBpcyBhbiBhbmNlc3RvciBvZiBgYmFzZWAuXG4gICAgICovXG4gICAgaXNBbmNlc3RvcjogZnVuY3Rpb24oYmFzZSwgcGF0aCkge1xuICAgICAgLy8gICAgIGJhc2Uuc3RhcnRzV2l0aChwYXRoICsgJy4nKTtcbiAgICAgIHJldHVybiBiYXNlLmluZGV4T2YocGF0aCArICcuJykgPT09IDA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdpdmVuIGBiYXNlYCBpcyBgZm9vLmJhcmAsIGBmb28uYmFyLmJhemAgaXMgYW4gZGVzY2VuZGFudFxuICAgICAqXG4gICAgICogRXhhbXBsZTpcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIFBvbHltZXIuUGF0aC5pc0Rlc2NlbmRhbnQoJ2Zvby5iYXInLCAnZm9vLmJhci5iYXonKSAvLyB0cnVlXG4gICAgICogUG9seW1lci5QYXRoLmlzRGVzY2VuZGFudCgnZm9vLmJhcicsICdmb28uYmFyJykgICAgIC8vIGZhbHNlXG4gICAgICogUG9seW1lci5QYXRoLmlzRGVzY2VuZGFudCgnZm9vLmJhcicsICdmb28nKSAgICAgICAgIC8vIGZhbHNlXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgUG9seW1lci5QYXRoXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGJhc2UgUGF0aCBzdHJpbmcgdG8gdGVzdCBhZ2FpbnN0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFBhdGggc3RyaW5nIHRvIHRlc3QuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBgcGF0aGAgaXMgYSBkZXNjZW5kYW50IG9mIGBiYXNlYC5cbiAgICAgKi9cbiAgICBpc0Rlc2NlbmRhbnQ6IGZ1bmN0aW9uKGJhc2UsIHBhdGgpIHtcbiAgICAgIC8vICAgICBwYXRoLnN0YXJ0c1dpdGgoYmFzZSArICcuJyk7XG4gICAgICByZXR1cm4gcGF0aC5pbmRleE9mKGJhc2UgKyAnLicpID09PSAwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXBsYWNlcyBhIHByZXZpb3VzIGJhc2UgcGF0aCB3aXRoIGEgbmV3IGJhc2UgcGF0aCwgcHJlc2VydmluZyB0aGVcbiAgICAgKiByZW1haW5kZXIgb2YgdGhlIHBhdGguXG4gICAgICpcbiAgICAgKiBVc2VyIG11c3QgZW5zdXJlIGBwYXRoYCBoYXMgYSBwcmVmaXggb2YgYGJhc2VgLlxuICAgICAqXG4gICAgICogRXhhbXBsZTpcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIFBvbHltZXIuUGF0aC50cmFuc2xhdGUoJ2Zvby5iYXInLCAnem90JyAnZm9vLmJhci5iYXonKSAvLyAnem90LmJheidcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBQb2x5bWVyLlBhdGhcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYmFzZSBDdXJyZW50IGJhc2Ugc3RyaW5nIHRvIHJlbW92ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXdCYXNlIE5ldyBiYXNlIHN0cmluZyB0byByZXBsYWNlIHdpdGhcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBQYXRoIHRvIHRyYW5zbGF0ZVxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gVHJhbnNsYXRlZCBzdHJpbmdcbiAgICAgKi9cbiAgICB0cmFuc2xhdGU6IGZ1bmN0aW9uKGJhc2UsIG5ld0Jhc2UsIHBhdGgpIHtcbiAgICAgIHJldHVybiBuZXdCYXNlICsgcGF0aC5zbGljZShiYXNlLmxlbmd0aCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlIFBhdGggc3RyaW5nIHRvIHRlc3QgYWdhaW5zdFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFBhdGggc3RyaW5nIHRvIHRlc3RcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGBwYXRoYCBpcyBlcXVhbCB0byBgYmFzZWBcbiAgICAgKiBAdGhpcyB7UGF0aH1cbiAgICAgKi9cbiAgICBtYXRjaGVzOiBmdW5jdGlvbihiYXNlLCBwYXRoKSB7XG4gICAgICByZXR1cm4gKGJhc2UgPT09IHBhdGgpIHx8XG4gICAgICAgICAgICAgdGhpcy5pc0FuY2VzdG9yKGJhc2UsIHBhdGgpIHx8XG4gICAgICAgICAgICAgdGhpcy5pc0Rlc2NlbmRhbnQoYmFzZSwgcGF0aCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGFycmF5LWJhc2VkIHBhdGhzIHRvIGZsYXR0ZW5lZCBwYXRoLiAgU3RyaW5nLWJhc2VkIHBhdGhzXG4gICAgICogYXJlIHJldHVybmVkIGFzLWlzLlxuICAgICAqXG4gICAgICogRXhhbXBsZTpcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIFBvbHltZXIuUGF0aC5ub3JtYWxpemUoWydmb28uYmFyJywgMCwgJ2JheiddKSAgLy8gJ2Zvby5iYXIuMC5iYXonXG4gICAgICogUG9seW1lci5QYXRoLm5vcm1hbGl6ZSgnZm9vLmJhci4wLmJheicpICAgICAgICAvLyAnZm9vLmJhci4wLmJheidcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBQb2x5bWVyLlBhdGhcbiAgICAgKiBAcGFyYW0ge3N0cmluZyB8ICFBcnJheTxzdHJpbmd8bnVtYmVyPn0gcGF0aCBJbnB1dCBwYXRoXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBGbGF0dGVuZWQgcGF0aFxuICAgICAqL1xuICAgIG5vcm1hbGl6ZTogZnVuY3Rpb24ocGF0aCkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGF0aCkpIHtcbiAgICAgICAgbGV0IHBhcnRzID0gW107XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgbGV0IGFyZ3MgPSBwYXRoW2ldLnRvU3RyaW5nKCkuc3BsaXQoJy4nKTtcbiAgICAgICAgICBmb3IgKGxldCBqPTA7IGo8YXJncy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgcGFydHMucHVzaChhcmdzW2pdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcnRzLmpvaW4oJy4nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTcGxpdHMgYSBwYXRoIGludG8gYW4gYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuIEFjY2VwdHMgZWl0aGVyIGFycmF5c1xuICAgICAqIG9mIHBhdGggcGFydHMgb3Igc3RyaW5ncy5cbiAgICAgKlxuICAgICAqIEV4YW1wbGU6XG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiBQb2x5bWVyLlBhdGguc3BsaXQoWydmb28uYmFyJywgMCwgJ2JheiddKSAgLy8gWydmb28nLCAnYmFyJywgJzAnLCAnYmF6J11cbiAgICAgKiBQb2x5bWVyLlBhdGguc3BsaXQoJ2Zvby5iYXIuMC5iYXonKSAgICAgICAgLy8gWydmb28nLCAnYmFyJywgJzAnLCAnYmF6J11cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBQb2x5bWVyLlBhdGhcbiAgICAgKiBAcGFyYW0ge3N0cmluZyB8ICFBcnJheTxzdHJpbmd8bnVtYmVyPn0gcGF0aCBJbnB1dCBwYXRoXG4gICAgICogQHJldHVybiB7IUFycmF5PHN0cmluZz59IEFycmF5IG9mIHBhdGggcGFydHNcbiAgICAgKiBAdGhpcyB7UGF0aH1cbiAgICAgKiBAc3VwcHJlc3Mge2NoZWNrVHlwZXN9XG4gICAgICovXG4gICAgc3BsaXQ6IGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhdGgpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5vcm1hbGl6ZShwYXRoKS5zcGxpdCgnLicpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhdGgudG9TdHJpbmcoKS5zcGxpdCgnLicpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZWFkcyBhIHZhbHVlIGZyb20gYSBwYXRoLiAgSWYgYW55IHN1Yi1wcm9wZXJ0eSBpbiB0aGUgcGF0aCBpcyBgdW5kZWZpbmVkYCxcbiAgICAgKiB0aGlzIG1ldGhvZCByZXR1cm5zIGB1bmRlZmluZWRgICh3aWxsIG5ldmVyIHRocm93LlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIFBvbHltZXIuUGF0aFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByb290IE9iamVjdCBmcm9tIHdoaWNoIHRvIGRlcmVmZXJlbmNlIHBhdGggZnJvbVxuICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgIUFycmF5PHN0cmluZ3xudW1iZXI+fSBwYXRoIFBhdGggdG8gcmVhZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0PX0gaW5mbyBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgdG8gYGluZm9gLCB0aGUgbm9ybWFsaXplZFxuICAgICAqICAoZmxhdHRlbmVkKSBwYXRoIHdpbGwgYmUgc2V0IHRvIGBpbmZvLnBhdGhgLlxuICAgICAqIEByZXR1cm4geyp9IFZhbHVlIGF0IHBhdGgsIG9yIGB1bmRlZmluZWRgIGlmIHRoZSBwYXRoIGNvdWxkIG5vdCBiZVxuICAgICAqICBmdWxseSBkZXJlZmVyZW5jZWQuXG4gICAgICogQHRoaXMge1BhdGh9XG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbihyb290LCBwYXRoLCBpbmZvKSB7XG4gICAgICBsZXQgcHJvcCA9IHJvb3Q7XG4gICAgICBsZXQgcGFydHMgPSB0aGlzLnNwbGl0KHBhdGgpO1xuICAgICAgLy8gTG9vcCBvdmVyIHBhdGggcGFydHNbMC4ubi0xXSBhbmQgZGVyZWZlcmVuY2VcbiAgICAgIGZvciAobGV0IGk9MDsgaTxwYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoIXByb3ApIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHBhcnQgPSBwYXJ0c1tpXTtcbiAgICAgICAgcHJvcCA9IHByb3BbcGFydF07XG4gICAgICB9XG4gICAgICBpZiAoaW5mbykge1xuICAgICAgICBpbmZvLnBhdGggPSBwYXJ0cy5qb2luKCcuJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcHJvcDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyBhIHZhbHVlIHRvIGEgcGF0aC4gIElmIGFueSBzdWItcHJvcGVydHkgaW4gdGhlIHBhdGggaXMgYHVuZGVmaW5lZGAsXG4gICAgICogdGhpcyBtZXRob2Qgd2lsbCBuby1vcC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBQb2x5bWVyLlBhdGhcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcm9vdCBPYmplY3QgZnJvbSB3aGljaCB0byBkZXJlZmVyZW5jZSBwYXRoIGZyb21cbiAgICAgKiBAcGFyYW0ge3N0cmluZyB8ICFBcnJheTxzdHJpbmd8bnVtYmVyPn0gcGF0aCBQYXRoIHRvIHNldFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgdG8gc2V0IHRvIHBhdGhcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmcgfCB1bmRlZmluZWR9IFRoZSBub3JtYWxpemVkIHZlcnNpb24gb2YgdGhlIGlucHV0IHBhdGhcbiAgICAgKiBAdGhpcyB7UGF0aH1cbiAgICAgKi9cbiAgICBzZXQ6IGZ1bmN0aW9uKHJvb3QsIHBhdGgsIHZhbHVlKSB7XG4gICAgICBsZXQgcHJvcCA9IHJvb3Q7XG4gICAgICBsZXQgcGFydHMgPSB0aGlzLnNwbGl0KHBhdGgpO1xuICAgICAgbGV0IGxhc3QgPSBwYXJ0c1twYXJ0cy5sZW5ndGgtMV07XG4gICAgICBpZiAocGFydHMubGVuZ3RoID4gMSkge1xuICAgICAgICAvLyBMb29wIG92ZXIgcGF0aCBwYXJ0c1swLi5uLTJdIGFuZCBkZXJlZmVyZW5jZVxuICAgICAgICBmb3IgKGxldCBpPTA7IGk8cGFydHMubGVuZ3RoLTE7IGkrKykge1xuICAgICAgICAgIGxldCBwYXJ0ID0gcGFydHNbaV07XG4gICAgICAgICAgcHJvcCA9IHByb3BbcGFydF07XG4gICAgICAgICAgaWYgKCFwcm9wKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFNldCB2YWx1ZSB0byBvYmplY3QgYXQgZW5kIG9mIHBhdGhcbiAgICAgICAgcHJvcFtsYXN0XSA9IHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gU2ltcGxlIHByb3BlcnR5IHNldFxuICAgICAgICBwcm9wW3BhdGhdID0gdmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFydHMuam9pbignLicpO1xuICAgIH1cblxuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHN0cmluZyBpcyBhIHN0cnVjdHVyZWQgZGF0YSBwYXRoIChoYXMgZG90cykuXG4gICAqXG4gICAqIFRoaXMgZnVuY3Rpb24gaXMgZGVwcmVjYXRlZC4gIFVzZSBgUG9seW1lci5QYXRoLmlzUGF0aGAgaW5zdGVhZC5cbiAgICpcbiAgICogRXhhbXBsZTpcbiAgICpcbiAgICogYGBgXG4gICAqIFBvbHltZXIuUGF0aC5pc0RlZXAoJ2Zvby5iYXIuYmF6JykgLy8gdHJ1ZVxuICAgKiBQb2x5bWVyLlBhdGguaXNEZWVwKCdmb28nKSAgICAgICAgIC8vIGZhbHNlXG4gICAqIGBgYFxuICAgKlxuICAgKiBAZGVwcmVjYXRlZFxuICAgKiBAbWVtYmVyb2YgUG9seW1lci5QYXRoXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFBhdGggc3RyaW5nXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIHN0cmluZyBjb250YWluZWQgb25lIG9yIG1vcmUgZG90c1xuICAgKi9cbiAgUGF0aC5pc0RlZXAgPSBQYXRoLmlzUGF0aDtcblxuICBQb2x5bWVyLlBhdGggPSBQYXRoO1xuXG59KSgpO1xuPC9zY3JpcHQ+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL3BvbHltZXIvbGliL3V0aWxzL3BhdGguaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cblxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3V0aWxzL2Jvb3QuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3V0aWxzL21peGluLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi91dGlscy9jYXNlLW1hcC5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vdXRpbHMvYXN5bmMuaHRtbFwiPlxuXG48c2NyaXB0PlxuKGZ1bmN0aW9uKCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICBsZXQgY2FzZU1hcCA9IFBvbHltZXIuQ2FzZU1hcDtcblxuICBsZXQgbWljcm90YXNrID0gUG9seW1lci5Bc3luYy5taWNyb1Rhc2s7XG5cbiAgLy8gU2F2ZSBtYXAgb2YgbmF0aXZlIHByb3BlcnRpZXM7IHRoaXMgZm9ybXMgYSBibGFja2xpc3Qgb3IgcHJvcGVydGllc1xuICAvLyB0aGF0IHdvbid0IGhhdmUgdGhlaXIgdmFsdWVzIFwic2F2ZWRcIiBieSBgc2F2ZUFjY2Vzc29yVmFsdWVgLCBzaW5jZVxuICAvLyByZWFkaW5nIGZyb20gYW4gSFRNTEVsZW1lbnQgYWNjZXNzb3IgZnJvbSB0aGUgY29udGV4dCBvZiBhIHByb3RvdHlwZSB0aHJvd3NcbiAgY29uc3QgbmF0aXZlUHJvcGVydGllcyA9IHt9O1xuICBsZXQgcHJvdG8gPSBIVE1MRWxlbWVudC5wcm90b3R5cGU7XG4gIHdoaWxlIChwcm90bykge1xuICAgIGxldCBwcm9wcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHByb3RvKTtcbiAgICBmb3IgKGxldCBpPTA7IGk8cHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG5hdGl2ZVByb3BlcnRpZXNbcHJvcHNbaV1dID0gdHJ1ZTtcbiAgICB9XG4gICAgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG8pO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gc2F2ZSB0aGUgdmFsdWUgb2YgYSBwcm9wZXJ0eSB0aGF0IHdpbGwgYmUgb3ZlcnJpZGRlbiB3aXRoXG4gICAqIGFuIGFjY2Vzc29yLiBJZiB0aGUgYG1vZGVsYCBpcyBhIHByb3RvdHlwZSwgdGhlIHZhbHVlcyB3aWxsIGJlIHNhdmVkXG4gICAqIGluIGBfX2RhdGFQcm90b2AsIGFuZCBpdCdzIHVwIHRvIHRoZSB1c2VyIChvciBkb3duc3RyZWFtIG1peGluKSB0b1xuICAgKiBkZWNpZGUgaG93L3doZW4gdG8gc2V0IHRoZXNlIHZhbHVlcyBiYWNrIGludG8gdGhlIGFjY2Vzc29ycy5cbiAgICogSWYgYG1vZGVsYCBpcyBhbHJlYWR5IGFuIGluc3RhbmNlIChpdCBoYXMgYSBgX19kYXRhYCBwcm9wZXJ0eSksIHRoZW5cbiAgICogdGhlIHZhbHVlIHdpbGwgYmUgc2V0IGFzIGEgcGVuZGluZyBwcm9wZXJ0eSwgbWVhbmluZyB0aGUgdXNlciBzaG91bGRcbiAgICogY2FsbCBgX2ludmFsaWRhdGVQcm9wZXJ0aWVzYCBvciBgX2ZsdXNoUHJvcGVydGllc2AgdG8gdGFrZSBlZmZlY3RcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG1vZGVsIFByb3RvdHlwZSBvciBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgTmFtZSBvZiBwcm9wZXJ0eVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gc2F2ZUFjY2Vzc29yVmFsdWUobW9kZWwsIHByb3BlcnR5KSB7XG4gICAgLy8gRG9uJ3QgcmVhZC9zdG9yZSB2YWx1ZSBmb3IgYW55IG5hdGl2ZSBwcm9wZXJ0aWVzIHNpbmNlIHRoZXkgY291bGQgdGhyb3dcbiAgICBpZiAoIW5hdGl2ZVByb3BlcnRpZXNbcHJvcGVydHldKSB7XG4gICAgICBsZXQgdmFsdWUgPSBtb2RlbFtwcm9wZXJ0eV07XG4gICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAobW9kZWwuX19kYXRhKSB7XG4gICAgICAgICAgLy8gQWRkaW5nIGFjY2Vzc29yIHRvIGluc3RhbmNlOyB1cGRhdGUgdGhlIHByb3BlcnR5XG4gICAgICAgICAgLy8gSXQgaXMgdGhlIHVzZXIncyByZXNwb25zaWJpbGl0eSB0byBjYWxsIF9mbHVzaFByb3BlcnRpZXNcbiAgICAgICAgICBtb2RlbC5fc2V0UGVuZGluZ1Byb3BlcnR5KHByb3BlcnR5LCB2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gQWRkaW5nIGFjY2Vzc29yIHRvIHByb3RvOyBzYXZlIHByb3RvJ3MgdmFsdWUgZm9yIGluc3RhbmNlLXRpbWUgdXNlXG4gICAgICAgICAgaWYgKCFtb2RlbC5fX2RhdGFQcm90bykge1xuICAgICAgICAgICAgbW9kZWwuX19kYXRhUHJvdG8gPSB7fTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCFtb2RlbC5oYXNPd25Qcm9wZXJ0eShKU0NvbXBpbGVyX3JlbmFtZVByb3BlcnR5KCdfX2RhdGFQcm90bycsIG1vZGVsKSkpIHtcbiAgICAgICAgICAgIG1vZGVsLl9fZGF0YVByb3RvID0gT2JqZWN0LmNyZWF0ZShtb2RlbC5fX2RhdGFQcm90byk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG1vZGVsLl9fZGF0YVByb3RvW3Byb3BlcnR5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEVsZW1lbnQgY2xhc3MgbWl4aW4gdGhhdCBwcm92aWRlcyBiYXNpYyBtZXRhLXByb2dyYW1taW5nIGZvciBjcmVhdGluZyBvbmVcbiAgICogb3IgbW9yZSBwcm9wZXJ0eSBhY2Nlc3NvcnMgKGdldHRlci9zZXR0ZXIgcGFpcikgdGhhdCBlbnF1ZXVlIGFuIGFzeW5jXG4gICAqIChiYXRjaGVkKSBgX3Byb3BlcnRpZXNDaGFuZ2VkYCBjYWxsYmFjay5cbiAgICpcbiAgICogRm9yIGJhc2ljIHVzYWdlIG9mIHRoaXMgbWl4aW4sIHNpbXBseSBkZWNsYXJlIGF0dHJpYnV0ZXMgdG8gb2JzZXJ2ZSB2aWFcbiAgICogdGhlIHN0YW5kYXJkIGBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpYCwgaW1wbGVtZW50IGBfcHJvcGVydGllc0NoYW5nZWRgXG4gICAqIG9uIHRoZSBjbGFzcywgYW5kIHRoZW4gY2FsbCBgTXlDbGFzcy5jcmVhdGVQcm9wZXJ0aWVzRm9yQXR0cmlidXRlcygpYCBvbmNlXG4gICAqIG9uIHRoZSBjbGFzcyB0byBnZW5lcmF0ZSBwcm9wZXJ0eSBhY2Nlc3NvcnMgZm9yIGVhY2ggb2JzZXJ2ZWQgYXR0cmlidXRlXG4gICAqIHByaW9yIHRvIGluc3RhbmNpbmcuICBMYXN0LCBjYWxsIGB0aGlzLl9mbHVzaFByb3BlcnRpZXMoKWAgb25jZSB0byBlbmFibGVcbiAgICogdGhlIGFjY2Vzc29ycy5cbiAgICpcbiAgICogQW55IGBvYnNlcnZlZEF0dHJpYnV0ZXNgIHdpbGwgYXV0b21hdGljYWxseSBiZVxuICAgKiBkZXNlcmlhbGl6ZWQgdmlhIGBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2tgIGFuZCBzZXQgdG8gdGhlIGFzc29jaWF0ZWRcbiAgICogcHJvcGVydHkgdXNpbmcgYGRhc2gtY2FzZWAtdG8tYGNhbWVsQ2FzZWAgY29udmVudGlvbi5cbiAgICpcbiAgICogQG1peGluRnVuY3Rpb25cbiAgICogQHBvbHltZXJcbiAgICogQG1lbWJlcm9mIFBvbHltZXJcbiAgICogQHN1bW1hcnkgRWxlbWVudCBjbGFzcyBtaXhpbiBmb3IgcmVhY3RpbmcgdG8gcHJvcGVydHkgY2hhbmdlcyBmcm9tXG4gICAqICAgZ2VuZXJhdGVkIHByb3BlcnR5IGFjY2Vzc29ycy5cbiAgICovXG4gIFBvbHltZXIuUHJvcGVydHlBY2Nlc3NvcnMgPSBQb2x5bWVyLmRlZHVwaW5nTWl4aW4oc3VwZXJDbGFzcyA9PiB7XG5cbiAgICAvKipcbiAgICAgKiBAcG9seW1lclxuICAgICAqIEBtaXhpbkNsYXNzXG4gICAgICogQGltcGxlbWVudHMge1BvbHltZXJfUHJvcGVydHlBY2Nlc3NvcnN9XG4gICAgICogQGV4dGVuZHMgSFRNTEVsZW1lbnRcbiAgICAgKiBAdW5yZXN0cmljdGVkXG4gICAgICovXG4gICAgY2xhc3MgUHJvcGVydHlBY2Nlc3NvcnMgZXh0ZW5kcyBzdXBlckNsYXNzIHtcblxuICAgICAgLyoqXG4gICAgICAgKiBHZW5lcmF0ZXMgcHJvcGVydHkgYWNjZXNzb3JzIGZvciBhbGwgYXR0cmlidXRlcyBpbiB0aGUgc3RhbmRhcmRcbiAgICAgICAqIHN0YXRpYyBgb2JzZXJ2ZWRBdHRyaWJ1dGVzYCBhcnJheS5cbiAgICAgICAqXG4gICAgICAgKiBBdHRyaWJ1dGUgbmFtZXMgYXJlIG1hcHBlZCB0byBwcm9wZXJ0eSBuYW1lcyB1c2luZyB0aGUgYGRhc2gtY2FzZWAgdG9cbiAgICAgICAqIGBjYW1lbENhc2VgIGNvbnZlbnRpb25cbiAgICAgICAqXG4gICAgICAgKi9cbiAgICAgIHN0YXRpYyBjcmVhdGVQcm9wZXJ0aWVzRm9yQXR0cmlidXRlcygpIHtcbiAgICAgICAgbGV0IGEkID0gdGhpcy5vYnNlcnZlZEF0dHJpYnV0ZXM7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaSA8IGEkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdGhpcy5wcm90b3R5cGUuX2NyZWF0ZVByb3BlcnR5QWNjZXNzb3IoY2FzZU1hcC5kYXNoVG9DYW1lbENhc2UoYSRbaV0pKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLyoqIEB0eXBlIHtib29sZWFufSAqL1xuICAgICAgICB0aGlzLl9fc2VyaWFsaXppbmc7XG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLl9fZGF0YUNvdW50ZXI7XG4gICAgICAgIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cbiAgICAgICAgdGhpcy5fX2RhdGFFbmFibGVkO1xuICAgICAgICAvKiogQHR5cGUge2Jvb2xlYW59ICovXG4gICAgICAgIHRoaXMuX19kYXRhUmVhZHk7XG4gICAgICAgIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cbiAgICAgICAgdGhpcy5fX2RhdGFJbnZhbGlkO1xuICAgICAgICAvKiogQHR5cGUgeyFPYmplY3R9ICovXG4gICAgICAgIHRoaXMuX19kYXRhO1xuICAgICAgICAvKiogQHR5cGUge09iamVjdH0gKi9cbiAgICAgICAgdGhpcy5fX2RhdGFQZW5kaW5nO1xuICAgICAgICAvKiogQHR5cGUge09iamVjdH0gKi9cbiAgICAgICAgdGhpcy5fX2RhdGFPbGQ7XG4gICAgICAgIC8qKiBAdHlwZSB7T2JqZWN0fSAqL1xuICAgICAgICB0aGlzLl9fZGF0YVByb3RvO1xuICAgICAgICAvKiogQHR5cGUge09iamVjdH0gKi9cbiAgICAgICAgdGhpcy5fX2RhdGFIYXNBY2Nlc3NvcjtcbiAgICAgICAgLyoqIEB0eXBlIHtPYmplY3R9ICovXG4gICAgICAgIHRoaXMuX19kYXRhSW5zdGFuY2VQcm9wcztcbiAgICAgICAgdGhpcy5faW5pdGlhbGl6ZVByb3BlcnRpZXMoKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBJbXBsZW1lbnRzIG5hdGl2ZSBDdXN0b20gRWxlbWVudHMgYGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFja2AgdG9cbiAgICAgICAqIHNldCBhbiBhdHRyaWJ1dGUgdmFsdWUgdG8gYSBwcm9wZXJ0eSB2aWEgYF9hdHRyaWJ1dGVUb1Byb3BlcnR5YC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBOYW1lIG9mIGF0dHJpYnV0ZSB0aGF0IGNoYW5nZWRcbiAgICAgICAqIEBwYXJhbSB7P3N0cmluZ30gb2xkIE9sZCBhdHRyaWJ1dGUgdmFsdWVcbiAgICAgICAqIEBwYXJhbSB7P3N0cmluZ30gdmFsdWUgTmV3IGF0dHJpYnV0ZSB2YWx1ZVxuICAgICAgICovXG4gICAgICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgb2xkLCB2YWx1ZSkge1xuICAgICAgICBpZiAob2xkICE9PSB2YWx1ZSkge1xuICAgICAgICAgIHRoaXMuX2F0dHJpYnV0ZVRvUHJvcGVydHkobmFtZSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogSW5pdGlhbGl6ZXMgdGhlIGxvY2FsIHN0b3JhZ2UgZm9yIHByb3BlcnR5IGFjY2Vzc29ycy5cbiAgICAgICAqXG4gICAgICAgKiBQcm92aWRlZCBhcyBhbiBvdmVycmlkZSBwb2ludCBmb3IgcGVyZm9ybWluZyBhbnkgc2V0dXAgd29yayBwcmlvclxuICAgICAgICogdG8gaW5pdGlhbGl6aW5nIHRoZSBwcm9wZXJ0eSBhY2Nlc3NvciBzeXN0ZW0uXG4gICAgICAgKlxuICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICovXG4gICAgICBfaW5pdGlhbGl6ZVByb3BlcnRpZXMoKSB7XG4gICAgICAgIHRoaXMuX19zZXJpYWxpemluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9fZGF0YUNvdW50ZXIgPSAwO1xuICAgICAgICB0aGlzLl9fZGF0YUVuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fX2RhdGFSZWFkeSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9fZGF0YUludmFsaWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fX2RhdGEgPSB7fTtcbiAgICAgICAgdGhpcy5fX2RhdGFQZW5kaW5nID0gbnVsbDtcbiAgICAgICAgdGhpcy5fX2RhdGFPbGQgPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5fX2RhdGFQcm90bykge1xuICAgICAgICAgIHRoaXMuX2luaXRpYWxpemVQcm90b1Byb3BlcnRpZXModGhpcy5fX2RhdGFQcm90byk7XG4gICAgICAgICAgdGhpcy5fX2RhdGFQcm90byA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2FwdHVyZSBpbnN0YW5jZSBwcm9wZXJ0aWVzOyB0aGVzZSB3aWxsIGJlIHNldCBpbnRvIGFjY2Vzc29yc1xuICAgICAgICAvLyBkdXJpbmcgZmlyc3QgZmx1c2guIERvbid0IHNldCB0aGVtIGhlcmUsIHNpbmNlIHdlIHdhbnRcbiAgICAgICAgLy8gdGhlc2UgdG8gb3ZlcndyaXRlIGRlZmF1bHRzL2NvbnN0cnVjdG9yIGFzc2lnbm1lbnRzXG4gICAgICAgIGZvciAobGV0IHAgaW4gdGhpcy5fX2RhdGFIYXNBY2Nlc3Nvcikge1xuICAgICAgICAgIGlmICh0aGlzLmhhc093blByb3BlcnR5KHApKSB7XG4gICAgICAgICAgICB0aGlzLl9fZGF0YUluc3RhbmNlUHJvcHMgPSB0aGlzLl9fZGF0YUluc3RhbmNlUHJvcHMgfHwge307XG4gICAgICAgICAgICB0aGlzLl9fZGF0YUluc3RhbmNlUHJvcHNbcF0gPSB0aGlzW3BdO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXNbcF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ2FsbGVkIGF0IGluc3RhbmNlIHRpbWUgd2l0aCBiYWcgb2YgcHJvcGVydGllcyB0aGF0IHdlcmUgb3ZlcndyaXR0ZW5cbiAgICAgICAqIGJ5IGFjY2Vzc29ycyBvbiB0aGUgcHJvdG90eXBlIHdoZW4gYWNjZXNzb3JzIHdlcmUgY3JlYXRlZC5cbiAgICAgICAqXG4gICAgICAgKiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBzZXRzIHRoZXNlIHByb3BlcnRpZXMgYmFjayBpbnRvIHRoZVxuICAgICAgICogc2V0dGVyIGF0IGluc3RhbmNlIHRpbWUuICBUaGlzIG1ldGhvZCBpcyBwcm92aWRlZCBhcyBhbiBvdmVycmlkZVxuICAgICAgICogcG9pbnQgZm9yIGN1c3RvbWl6aW5nIG9yIHByb3ZpZGluZyBtb3JlIGVmZmljaWVudCBpbml0aWFsaXphdGlvbi5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgQmFnIG9mIHByb3BlcnR5IHZhbHVlcyB0aGF0IHdlcmUgb3ZlcndyaXR0ZW5cbiAgICAgICAqICAgd2hlbiBjcmVhdGluZyBwcm9wZXJ0eSBhY2Nlc3NvcnMuXG4gICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgKi9cbiAgICAgIF9pbml0aWFsaXplUHJvdG9Qcm9wZXJ0aWVzKHByb3BzKSB7XG4gICAgICAgIGZvciAobGV0IHAgaW4gcHJvcHMpIHtcbiAgICAgICAgICB0aGlzLl9zZXRQcm9wZXJ0eShwLCBwcm9wc1twXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDYWxsZWQgYXQgcmVhZHkgdGltZSB3aXRoIGJhZyBvZiBpbnN0YW5jZSBwcm9wZXJ0aWVzIHRoYXQgb3Zlcndyb3RlXG4gICAgICAgKiBhY2Nlc3NvcnMgd2hlbiB0aGUgZWxlbWVudCB1cGdyYWRlZC5cbiAgICAgICAqXG4gICAgICAgKiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBzZXRzIHRoZXNlIHByb3BlcnRpZXMgYmFjayBpbnRvIHRoZVxuICAgICAgICogc2V0dGVyIGF0IHJlYWR5IHRpbWUuICBUaGlzIG1ldGhvZCBpcyBwcm92aWRlZCBhcyBhbiBvdmVycmlkZVxuICAgICAgICogcG9pbnQgZm9yIGN1c3RvbWl6aW5nIG9yIHByb3ZpZGluZyBtb3JlIGVmZmljaWVudCBpbml0aWFsaXphdGlvbi5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgQmFnIG9mIHByb3BlcnR5IHZhbHVlcyB0aGF0IHdlcmUgb3ZlcndyaXR0ZW5cbiAgICAgICAqICAgd2hlbiBjcmVhdGluZyBwcm9wZXJ0eSBhY2Nlc3NvcnMuXG4gICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgKi9cbiAgICAgIF9pbml0aWFsaXplSW5zdGFuY2VQcm9wZXJ0aWVzKHByb3BzKSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgcHJvcHMpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEVuc3VyZXMgdGhlIGVsZW1lbnQgaGFzIHRoZSBnaXZlbiBhdHRyaWJ1dGUuIElmIGl0IGRvZXMgbm90LFxuICAgICAgICogYXNzaWducyB0aGUgZ2l2ZW4gdmFsdWUgdG8gdGhlIGF0dHJpYnV0ZS5cbiAgICAgICAqXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGF0dHJpYnV0ZSBOYW1lIG9mIGF0dHJpYnV0ZSB0byBlbnN1cmUgaXMgc2V0LlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIG9mIHRoZSBhdHRyaWJ1dGUuXG4gICAgICAgKi9cbiAgICAgIF9lbnN1cmVBdHRyaWJ1dGUoYXR0cmlidXRlLCB2YWx1ZSkge1xuICAgICAgICBpZiAoIXRoaXMuaGFzQXR0cmlidXRlKGF0dHJpYnV0ZSkpIHtcbiAgICAgICAgICB0aGlzLl92YWx1ZVRvTm9kZUF0dHJpYnV0ZSh0aGlzLCB2YWx1ZSwgYXR0cmlidXRlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIERlc2VyaWFsaXplcyBhbiBhdHRyaWJ1dGUgdG8gaXRzIGFzc29jaWF0ZWQgcHJvcGVydHkuXG4gICAgICAgKlxuICAgICAgICogVGhpcyBtZXRob2QgY2FsbHMgdGhlIGBfZGVzZXJpYWxpemVWYWx1ZWAgbWV0aG9kIHRvIGNvbnZlcnQgdGhlIHN0cmluZyB0b1xuICAgICAgICogYSB0eXBlZCB2YWx1ZS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlIE5hbWUgb2YgYXR0cmlidXRlIHRvIGRlc2VyaWFsaXplLlxuICAgICAgICogQHBhcmFtIHs/c3RyaW5nfSB2YWx1ZSBvZiB0aGUgYXR0cmlidXRlLlxuICAgICAgICogQHBhcmFtIHsqPX0gdHlwZSB0eXBlIHRvIGRlc2VyaWFsaXplIHRvLlxuICAgICAgICovXG4gICAgICBfYXR0cmlidXRlVG9Qcm9wZXJ0eShhdHRyaWJ1dGUsIHZhbHVlLCB0eXBlKSB7XG4gICAgICAgIC8vIERvbid0IGRlc2VyaWFsaXplIGJhY2sgdG8gcHJvcGVydHkgaWYgY3VycmVudGx5IHJlZmxlY3RpbmdcbiAgICAgICAgaWYgKCF0aGlzLl9fc2VyaWFsaXppbmcpIHtcbiAgICAgICAgICBsZXQgcHJvcGVydHkgPSBjYXNlTWFwLmRhc2hUb0NhbWVsQ2FzZShhdHRyaWJ1dGUpO1xuICAgICAgICAgIHRoaXNbcHJvcGVydHldID0gdGhpcy5fZGVzZXJpYWxpemVWYWx1ZSh2YWx1ZSwgdHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBTZXJpYWxpemVzIGEgcHJvcGVydHkgdG8gaXRzIGFzc29jaWF0ZWQgYXR0cmlidXRlLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSBuYW1lIHRvIHJlZmxlY3QuXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZz19IGF0dHJpYnV0ZSBBdHRyaWJ1dGUgbmFtZSB0byByZWZsZWN0LlxuICAgICAgICogQHBhcmFtIHsqPX0gdmFsdWUgUHJvcGVydHkgdmFsdWUgdG8gcmVmZWN0LlxuICAgICAgICovXG4gICAgICBfcHJvcGVydHlUb0F0dHJpYnV0ZShwcm9wZXJ0eSwgYXR0cmlidXRlLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLl9fc2VyaWFsaXppbmcgPSB0cnVlO1xuICAgICAgICB2YWx1ZSA9IChhcmd1bWVudHMubGVuZ3RoIDwgMykgPyB0aGlzW3Byb3BlcnR5XSA6IHZhbHVlO1xuICAgICAgICB0aGlzLl92YWx1ZVRvTm9kZUF0dHJpYnV0ZSh0aGlzLCB2YWx1ZSxcbiAgICAgICAgICBhdHRyaWJ1dGUgfHwgY2FzZU1hcC5jYW1lbFRvRGFzaENhc2UocHJvcGVydHkpKTtcbiAgICAgICAgdGhpcy5fX3NlcmlhbGl6aW5nID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogU2V0cyBhIHR5cGVkIHZhbHVlIHRvIGFuIEhUTUwgYXR0cmlidXRlIG9uIGEgbm9kZS5cbiAgICAgICAqXG4gICAgICAgKiBUaGlzIG1ldGhvZCBjYWxscyB0aGUgYF9zZXJpYWxpemVWYWx1ZWAgbWV0aG9kIHRvIGNvbnZlcnQgdGhlIHR5cGVkXG4gICAgICAgKiB2YWx1ZSB0byBhIHN0cmluZy4gIElmIHRoZSBgX3NlcmlhbGl6ZVZhbHVlYCBtZXRob2QgcmV0dXJucyBgdW5kZWZpbmVkYCxcbiAgICAgICAqIHRoZSBhdHRyaWJ1dGUgd2lsbCBiZSByZW1vdmVkICh0aGlzIGlzIHRoZSBkZWZhdWx0IGZvciBib29sZWFuXG4gICAgICAgKiB0eXBlIGBmYWxzZWApLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZSBFbGVtZW50IHRvIHNldCBhdHRyaWJ1dGUgdG8uXG4gICAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIHNlcmlhbGl6ZS5cbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGUgQXR0cmlidXRlIG5hbWUgdG8gc2VyaWFsaXplIHRvLlxuICAgICAgICovXG4gICAgICBfdmFsdWVUb05vZGVBdHRyaWJ1dGUobm9kZSwgdmFsdWUsIGF0dHJpYnV0ZSkge1xuICAgICAgICBsZXQgc3RyID0gdGhpcy5fc2VyaWFsaXplVmFsdWUodmFsdWUpO1xuICAgICAgICBpZiAoc3RyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShhdHRyaWJ1dGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZSwgc3RyKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENvbnZlcnRzIGEgdHlwZWQgSmF2YVNjcmlwdCB2YWx1ZSB0byBhIHN0cmluZy5cbiAgICAgICAqXG4gICAgICAgKiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgYnkgUG9seW1lciB3aGVuIHNldHRpbmcgSlMgcHJvcGVydHkgdmFsdWVzIHRvXG4gICAgICAgKiBIVE1MIGF0dHJpYnV0ZXMuICBVc2VycyBtYXkgb3ZlcnJpZGUgdGhpcyBtZXRob2Qgb24gUG9seW1lciBlbGVtZW50XG4gICAgICAgKiBwcm90b3R5cGVzIHRvIHByb3ZpZGUgc2VyaWFsaXphdGlvbiBmb3IgY3VzdG9tIHR5cGVzLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgUHJvcGVydHkgdmFsdWUgdG8gc2VyaWFsaXplLlxuICAgICAgICogQHJldHVybiB7c3RyaW5nIHwgdW5kZWZpbmVkfSBTdHJpbmcgc2VyaWFsaXplZCBmcm9tIHRoZSBwcm92aWRlZCBwcm9wZXJ0eSB2YWx1ZS5cbiAgICAgICAqL1xuICAgICAgX3NlcmlhbGl6ZVZhbHVlKHZhbHVlKSB7XG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWZhbGx0aHJvdWdoICovXG4gICAgICAgIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgPyAnJyA6IHVuZGVmaW5lZDtcblxuICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgICAgICAgICAgIH0gY2F0Y2goeCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSAhPSBudWxsID8gdmFsdWUudG9TdHJpbmcoKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENvbnZlcnRzIGEgc3RyaW5nIHRvIGEgdHlwZWQgSmF2YVNjcmlwdCB2YWx1ZS5cbiAgICAgICAqXG4gICAgICAgKiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgYnkgUG9seW1lciB3aGVuIHJlYWRpbmcgSFRNTCBhdHRyaWJ1dGUgdmFsdWVzIHRvXG4gICAgICAgKiBKUyBwcm9wZXJ0aWVzLiAgVXNlcnMgbWF5IG92ZXJyaWRlIHRoaXMgbWV0aG9kIG9uIFBvbHltZXIgZWxlbWVudFxuICAgICAgICogcHJvdG90eXBlcyB0byBwcm92aWRlIGRlc2VyaWFsaXphdGlvbiBmb3IgY3VzdG9tIGB0eXBlYHMuICBOb3RlLFxuICAgICAgICogdGhlIGB0eXBlYCBhcmd1bWVudCBpcyB0aGUgdmFsdWUgb2YgdGhlIGB0eXBlYCBmaWVsZCBwcm92aWRlZCBpbiB0aGVcbiAgICAgICAqIGBwcm9wZXJ0aWVzYCBjb25maWd1cmF0aW9uIG9iamVjdCBmb3IgYSBnaXZlbiBwcm9wZXJ0eSwgYW5kIGlzXG4gICAgICAgKiBieSBjb252ZW50aW9uIHRoZSBjb25zdHJ1Y3RvciBmb3IgdGhlIHR5cGUgdG8gZGVzZXJpYWxpemUuXG4gICAgICAgKlxuICAgICAgICogTm90ZTogVGhlIHJldHVybiB2YWx1ZSBvZiBgdW5kZWZpbmVkYCBpcyB1c2VkIGFzIGEgc2VudGluZWwgdmFsdWUgdG9cbiAgICAgICAqIGluZGljYXRlIHRoZSBhdHRyaWJ1dGUgc2hvdWxkIGJlIHJlbW92ZWQuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHs/c3RyaW5nfSB2YWx1ZSBBdHRyaWJ1dGUgdmFsdWUgdG8gZGVzZXJpYWxpemUuXG4gICAgICAgKiBAcGFyYW0geyo9fSB0eXBlIFR5cGUgdG8gZGVzZXJpYWxpemUgdGhlIHN0cmluZyB0by5cbiAgICAgICAqIEByZXR1cm4geyp9IFR5cGVkIHZhbHVlIGRlc2VyaWFsaXplZCBmcm9tIHRoZSBwcm92aWRlZCBzdHJpbmcuXG4gICAgICAgKi9cbiAgICAgIF9kZXNlcmlhbGl6ZVZhbHVlKHZhbHVlLCB0eXBlKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7Kn1cbiAgICAgICAgICovXG4gICAgICAgIGxldCBvdXRWYWx1ZTtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgY2FzZSBOdW1iZXI6XG4gICAgICAgICAgICBvdXRWYWx1ZSA9IE51bWJlcih2YWx1ZSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgQm9vbGVhbjpcbiAgICAgICAgICAgIG91dFZhbHVlID0gKHZhbHVlICE9PSBudWxsKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBPYmplY3Q6XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBvdXRWYWx1ZSA9IEpTT04ucGFyc2UoLyoqIEB0eXBlIHN0cmluZyAqLyh2YWx1ZSkpO1xuICAgICAgICAgICAgfSBjYXRjaCh4KSB7XG4gICAgICAgICAgICAgIC8vIGFsbG93IG5vbi1KU09OIGxpdGVyYWxzIGxpa2UgU3RyaW5ncyBhbmQgTnVtYmVyc1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIEFycmF5OlxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgb3V0VmFsdWUgPSBKU09OLnBhcnNlKC8qKiBAdHlwZSBzdHJpbmcgKi8odmFsdWUpKTtcbiAgICAgICAgICAgIH0gY2F0Y2goeCkge1xuICAgICAgICAgICAgICBvdXRWYWx1ZSA9IG51bGw7XG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybihgUG9seW1lcjo6QXR0cmlidXRlczogY291bGRuJ3QgZGVjb2RlIEFycmF5IGFzIEpTT046ICR7dmFsdWV9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgRGF0ZTpcbiAgICAgICAgICAgIG91dFZhbHVlID0gbmV3IERhdGUodmFsdWUpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIFN0cmluZzpcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgb3V0VmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG91dFZhbHVlO1xuICAgICAgfVxuICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1mYWxsdGhyb3VnaCAqL1xuXG4gICAgICAvKipcbiAgICAgICAqIENyZWF0ZXMgYSBzZXR0ZXIvZ2V0dGVyIHBhaXIgZm9yIHRoZSBuYW1lZCBwcm9wZXJ0eSB3aXRoIGl0cyBvd25cbiAgICAgICAqIGxvY2FsIHN0b3JhZ2UuICBUaGUgZ2V0dGVyIHJldHVybnMgdGhlIHZhbHVlIGluIHRoZSBsb2NhbCBzdG9yYWdlLFxuICAgICAgICogYW5kIHRoZSBzZXR0ZXIgY2FsbHMgYF9zZXRQcm9wZXJ0eWAsIHdoaWNoIHVwZGF0ZXMgdGhlIGxvY2FsIHN0b3JhZ2VcbiAgICAgICAqIGZvciB0aGUgcHJvcGVydHkgYW5kIGVucXVldWVzIGEgYF9wcm9wZXJ0aWVzQ2hhbmdlZGAgY2FsbGJhY2suXG4gICAgICAgKlxuICAgICAgICogVGhpcyBtZXRob2QgbWF5IGJlIGNhbGxlZCBvbiBhIHByb3RvdHlwZSBvciBhbiBpbnN0YW5jZS4gIENhbGxpbmdcbiAgICAgICAqIHRoaXMgbWV0aG9kIG1heSBvdmVyd3JpdGUgYSBwcm9wZXJ0eSB2YWx1ZSB0aGF0IGFscmVhZHkgZXhpc3RzIG9uXG4gICAgICAgKiB0aGUgcHJvdG90eXBlL2luc3RhbmNlIGJ5IGNyZWF0aW5nIHRoZSBhY2Nlc3Nvci4gIFdoZW4gY2FsbGluZyBvblxuICAgICAgICogYSBwcm90b3R5cGUsIGFueSBvdmVyd3JpdHRlbiB2YWx1ZXMgYXJlIHNhdmVkIGluIGBfX2RhdGFQcm90b2AsXG4gICAgICAgKiBhbmQgaXQgaXMgdXAgdG8gdGhlIHN1YmNsYXNzZXIgdG8gZGVjaWRlIGhvdy93aGVuIHRvIHNldCB0aG9zZVxuICAgICAgICogcHJvcGVydGllcyBiYWNrIGludG8gdGhlIGFjY2Vzc29yLiAgV2hlbiBjYWxsaW5nIG9uIGFuIGluc3RhbmNlLFxuICAgICAgICogdGhlIG92ZXJ3cml0dGVuIHZhbHVlIGlzIHNldCB2aWEgYF9zZXRQZW5kaW5nUHJvcGVydHlgLCBhbmQgdGhlXG4gICAgICAgKiB1c2VyIHNob3VsZCBjYWxsIGBfaW52YWxpZGF0ZVByb3BlcnRpZXNgIG9yIGBfZmx1c2hQcm9wZXJ0aWVzYFxuICAgICAgICogZm9yIHRoZSB2YWx1ZXMgdG8gdGFrZSBlZmZlY3QuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IE5hbWUgb2YgdGhlIHByb3BlcnR5XG4gICAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSByZWFkT25seSBXaGVuIHRydWUsIG5vIHNldHRlciBpcyBjcmVhdGVkOyB0aGVcbiAgICAgICAqICAgcHJvdGVjdGVkIGBfc2V0UHJvcGVydHlgIGZ1bmN0aW9uIG11c3QgYmUgdXNlZCB0byBzZXQgdGhlIHByb3BlcnR5XG4gICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgKi9cbiAgICAgIF9jcmVhdGVQcm9wZXJ0eUFjY2Vzc29yKHByb3BlcnR5LCByZWFkT25seSkge1xuICAgICAgICBpZiAoIXRoaXMuaGFzT3duUHJvcGVydHkoJ19fZGF0YUhhc0FjY2Vzc29yJykpIHtcbiAgICAgICAgICB0aGlzLl9fZGF0YUhhc0FjY2Vzc29yID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5fX2RhdGFIYXNBY2Nlc3Nvcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9fZGF0YUhhc0FjY2Vzc29yW3Byb3BlcnR5XSkge1xuICAgICAgICAgIHRoaXMuX19kYXRhSGFzQWNjZXNzb3JbcHJvcGVydHldID0gdHJ1ZTtcbiAgICAgICAgICBzYXZlQWNjZXNzb3JWYWx1ZSh0aGlzLCBwcm9wZXJ0eSk7XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIHByb3BlcnR5LCB7XG4gICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSB2YWxpZC1qc2RvYyAqL1xuICAgICAgICAgICAgLyoqIEB0aGlzIHtQcm9wZXJ0eUFjY2Vzc29yc30gKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLl9fZGF0YVtwcm9wZXJ0eV07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLyoqIEB0aGlzIHtQcm9wZXJ0eUFjY2Vzc29yc30gKi9cbiAgICAgICAgICAgIHNldDogcmVhZE9ubHkgPyBmdW5jdGlvbigpIHt9IDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgdGhpcy5fc2V0UHJvcGVydHkocHJvcGVydHksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIGVzbGludC1lbmFibGUgKi9cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIGxpYnJhcnkgY3JlYXRlZCBhbiBhY2Nlc3NvciBmb3IgdGhlIGdpdmVuIHByb3BlcnR5LlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSBuYW1lXG4gICAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGFuIGFjY2Vzc29yIHdhcyBjcmVhdGVkXG4gICAgICAgKi9cbiAgICAgIF9oYXNBY2Nlc3Nvcihwcm9wZXJ0eSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX2RhdGFIYXNBY2Nlc3NvciAmJiB0aGlzLl9fZGF0YUhhc0FjY2Vzc29yW3Byb3BlcnR5XTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBVcGRhdGVzIHRoZSBsb2NhbCBzdG9yYWdlIGZvciBhIHByb3BlcnR5ICh2aWEgYF9zZXRQZW5kaW5nUHJvcGVydHlgKVxuICAgICAgICogYW5kIGVucXVldWVzIGEgYF9wcm9lcHJ0aWVzQ2hhbmdlZGAgY2FsbGJhY2suXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IE5hbWUgb2YgdGhlIHByb3BlcnR5XG4gICAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIHNldFxuICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICovXG4gICAgICBfc2V0UHJvcGVydHkocHJvcGVydHksIHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLl9zZXRQZW5kaW5nUHJvcGVydHkocHJvcGVydHksIHZhbHVlKSkge1xuICAgICAgICAgIHRoaXMuX2ludmFsaWRhdGVQcm9wZXJ0aWVzKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBVcGRhdGVzIHRoZSBsb2NhbCBzdG9yYWdlIGZvciBhIHByb3BlcnR5LCByZWNvcmRzIHRoZSBwcmV2aW91cyB2YWx1ZSxcbiAgICAgICAqIGFuZCBhZGRzIGl0IHRvIHRoZSBzZXQgb2YgXCJwZW5kaW5nIGNoYW5nZXNcIiB0aGF0IHdpbGwgYmUgcGFzc2VkIHRvIHRoZVxuICAgICAgICogYF9wcm9wZXJ0aWVzQ2hhbmdlZGAgY2FsbGJhY2suICBUaGlzIG1ldGhvZCBkb2VzIG5vdCBlbnF1ZXVlIHRoZVxuICAgICAgICogYF9wcm9wZXJ0aWVzQ2hhbmdlZGAgY2FsbGJhY2suXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IE5hbWUgb2YgdGhlIHByb3BlcnR5XG4gICAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIHNldFxuICAgICAgICogQHJldHVybiB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZSBwcm9wZXJ0eSBjaGFuZ2VkXG4gICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgKi9cbiAgICAgIF9zZXRQZW5kaW5nUHJvcGVydHkocHJvcGVydHksIHZhbHVlKSB7XG4gICAgICAgIGxldCBvbGQgPSB0aGlzLl9fZGF0YVtwcm9wZXJ0eV07XG4gICAgICAgIGxldCBjaGFuZ2VkID0gdGhpcy5fc2hvdWxkUHJvcGVydHlDaGFuZ2UocHJvcGVydHksIHZhbHVlLCBvbGQpXG4gICAgICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICAgICAgaWYgKCF0aGlzLl9fZGF0YVBlbmRpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuX19kYXRhUGVuZGluZyA9IHt9O1xuICAgICAgICAgICAgdGhpcy5fX2RhdGFPbGQgPSB7fTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gRW5zdXJlIG9sZCBpcyBjYXB0dXJlZCBmcm9tIHRoZSBsYXN0IHR1cm5cbiAgICAgICAgICBpZiAodGhpcy5fX2RhdGFPbGQgJiYgIShwcm9wZXJ0eSBpbiB0aGlzLl9fZGF0YU9sZCkpIHtcbiAgICAgICAgICAgIHRoaXMuX19kYXRhT2xkW3Byb3BlcnR5XSA9IG9sZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fX2RhdGFbcHJvcGVydHldID0gdmFsdWU7XG4gICAgICAgICAgdGhpcy5fX2RhdGFQZW5kaW5nW3Byb3BlcnR5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGFuZ2VkO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIHByb3BlcnR5IGhhcyBhIHBlbmRpbmcgY2hhbmdlLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wIFByb3BlcnR5IG5hbWVcbiAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgcHJvcGVydHkgaGFzIGEgcGVuZGluZyBjaGFuZ2VcbiAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAqL1xuICAgICAgX2lzUHJvcGVydHlQZW5kaW5nKHByb3ApIHtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4odGhpcy5fX2RhdGFQZW5kaW5nICYmIChwcm9wIGluIHRoaXMuX19kYXRhUGVuZGluZykpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIE1hcmtzIHRoZSBwcm9wZXJ0aWVzIGFzIGludmFsaWQsIGFuZCBlbnF1ZXVlcyBhbiBhc3luY1xuICAgICAgICogYF9wcm9wZXJ0aWVzQ2hhbmdlZGAgY2FsbGJhY2suXG4gICAgICAgKlxuICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICovXG4gICAgICBfaW52YWxpZGF0ZVByb3BlcnRpZXMoKSB7XG4gICAgICAgIGlmICghdGhpcy5fX2RhdGFJbnZhbGlkICYmIHRoaXMuX19kYXRhUmVhZHkpIHtcbiAgICAgICAgICB0aGlzLl9fZGF0YUludmFsaWQgPSB0cnVlO1xuICAgICAgICAgIG1pY3JvdGFzay5ydW4oKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuX19kYXRhSW52YWxpZCkge1xuICAgICAgICAgICAgICB0aGlzLl9fZGF0YUludmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgdGhpcy5fZmx1c2hQcm9wZXJ0aWVzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDYWxsIHRvIGVuYWJsZSBwcm9wZXJ0eSBhY2Nlc3NvciBwcm9jZXNzaW5nLiBCZWZvcmUgdGhpcyBtZXRob2QgaXNcbiAgICAgICAqIGNhbGxlZCBhY2Nlc3NvciB2YWx1ZXMgd2lsbCBiZSBzZXQgYnV0IHNpZGUgZWZmZWN0cyBhcmVcbiAgICAgICAqIHF1ZXVlZC4gV2hlbiBjYWxsZWQsIGFueSBwZW5kaW5nIHNpZGUgZWZmZWN0cyBvY2N1ciBpbW1lZGlhdGVseS5cbiAgICAgICAqIEZvciBlbGVtZW50cywgZ2VuZXJhbGx5IGBjb25uZWN0ZWRDYWxsYmFja2AgaXMgYSBub3JtYWwgc3BvdCB0byBkbyBzby5cbiAgICAgICAqIEl0IGlzIHNhZmUgdG8gY2FsbCB0aGlzIG1ldGhvZCBtdWx0aXBsZSB0aW1lcyBhcyBpdCBvbmx5IHR1cm5zIG9uXG4gICAgICAgKiBwcm9wZXJ0eSBhY2Nlc3NvcnMgb25jZS5cbiAgICAgICAqL1xuICAgICAgX2VuYWJsZVByb3BlcnRpZXMoKSB7XG4gICAgICAgIGlmICghdGhpcy5fX2RhdGFFbmFibGVkKSB7XG4gICAgICAgICAgdGhpcy5fX2RhdGFFbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgICBpZiAodGhpcy5fX2RhdGFJbnN0YW5jZVByb3BzKSB7XG4gICAgICAgICAgICB0aGlzLl9pbml0aWFsaXplSW5zdGFuY2VQcm9wZXJ0aWVzKHRoaXMuX19kYXRhSW5zdGFuY2VQcm9wcyk7XG4gICAgICAgICAgICB0aGlzLl9fZGF0YUluc3RhbmNlUHJvcHMgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnJlYWR5KClcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENhbGxzIHRoZSBgX3Byb3BlcnRpZXNDaGFuZ2VkYCBjYWxsYmFjayB3aXRoIHRoZSBjdXJyZW50IHNldCBvZlxuICAgICAgICogcGVuZGluZyBjaGFuZ2VzIChhbmQgb2xkIHZhbHVlcyByZWNvcmRlZCB3aGVuIHBlbmRpbmcgY2hhbmdlcyB3ZXJlXG4gICAgICAgKiBzZXQpLCBhbmQgcmVzZXRzIHRoZSBwZW5kaW5nIHNldCBvZiBjaGFuZ2VzLiBHZW5lcmFsbHksIHRoaXMgbWV0aG9kXG4gICAgICAgKiBzaG91bGQgbm90IGJlIGNhbGxlZCBpbiB1c2VyIGNvZGUuXG4gICAgICAgKlxuICAgICAgICpcbiAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAqL1xuICAgICAgX2ZsdXNoUHJvcGVydGllcygpIHtcbiAgICAgICAgaWYgKHRoaXMuX19kYXRhUGVuZGluZyAmJiB0aGlzLl9fZGF0YU9sZCkge1xuICAgICAgICAgIGxldCBjaGFuZ2VkUHJvcHMgPSB0aGlzLl9fZGF0YVBlbmRpbmc7XG4gICAgICAgICAgdGhpcy5fX2RhdGFQZW5kaW5nID0gbnVsbDtcbiAgICAgICAgICB0aGlzLl9fZGF0YUNvdW50ZXIrKztcbiAgICAgICAgICB0aGlzLl9wcm9wZXJ0aWVzQ2hhbmdlZCh0aGlzLl9fZGF0YSwgY2hhbmdlZFByb3BzLCB0aGlzLl9fZGF0YU9sZCk7XG4gICAgICAgICAgdGhpcy5fX2RhdGFDb3VudGVyLS07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBMaWZlY3ljbGUgY2FsbGJhY2sgY2FsbGVkIHRoZSBmaXJzdCB0aW1lIHByb3BlcnRpZXMgYXJlIGJlaW5nIGZsdXNoZWQuXG4gICAgICAgKiBQcmlvciB0byBgcmVhZHlgLCBhbGwgcHJvcGVydHkgc2V0cyB0aHJvdWdoIGFjY2Vzc29ycyBhcmUgcXVldWVkIGFuZFxuICAgICAgICogdGhlaXIgZWZmZWN0cyBhcmUgZmx1c2hlZCBhZnRlciB0aGlzIG1ldGhvZCByZXR1cm5zLlxuICAgICAgICpcbiAgICAgICAqIFVzZXJzIG1heSBvdmVycmlkZSB0aGlzIGZ1bmN0aW9uIHRvIGltcGxlbWVudCBiZWhhdmlvciB0aGF0IGlzXG4gICAgICAgKiBkZXBlbmRlbnQgb24gdGhlIGVsZW1lbnQgaGF2aW5nIGl0cyBwcm9wZXJ0aWVzIGluaXRpYWxpemVkLCBlLmcuXG4gICAgICAgKiBmcm9tIGRlZmF1bHRzIChpbml0aWFsaXplZCBmcm9tIGBjb25zdHJ1Y3RvcmAsIGBfaW5pdGlhbGl6ZVByb3BlcnRpZXNgKSxcbiAgICAgICAqIGBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2tgLCBvciB2YWx1ZXMgcHJvcGFnYXRlZCBmcm9tIGhvc3QgZS5nLiB2aWFcbiAgICAgICAqIGJpbmRpbmdzLiAgYHN1cGVyLnJlYWR5KClgIG11c3QgYmUgY2FsbGVkIHRvIGVuc3VyZSB0aGUgZGF0YSBzeXN0ZW1cbiAgICAgICAqIGJlY29tZXMgZW5hYmxlZC5cbiAgICAgICAqXG4gICAgICAgKiBAcHVibGljXG4gICAgICAgKi9cbiAgICAgIHJlYWR5KCkge1xuICAgICAgICB0aGlzLl9fZGF0YVJlYWR5ID0gdHJ1ZTtcbiAgICAgICAgLy8gUnVuIG5vcm1hbCBmbHVzaFxuICAgICAgICB0aGlzLl9mbHVzaFByb3BlcnRpZXMoKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDYWxsYmFjayBjYWxsZWQgd2hlbiBhbnkgcHJvcGVydGllcyB3aXRoIGFjY2Vzc29ycyBjcmVhdGVkIHZpYVxuICAgICAgICogYF9jcmVhdGVQcm9wZXJ0eUFjY2Vzc29yYCBoYXZlIGJlZW4gc2V0LlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7IU9iamVjdH0gY3VycmVudFByb3BzIEJhZyBvZiBhbGwgY3VycmVudCBhY2Nlc3NvciB2YWx1ZXNcbiAgICAgICAqIEBwYXJhbSB7IU9iamVjdH0gY2hhbmdlZFByb3BzIEJhZyBvZiBwcm9wZXJ0aWVzIGNoYW5nZWQgc2luY2UgdGhlIGxhc3RcbiAgICAgICAqICAgY2FsbCB0byBgX3Byb3BlcnRpZXNDaGFuZ2VkYFxuICAgICAgICogQHBhcmFtIHshT2JqZWN0fSBvbGRQcm9wcyBCYWcgb2YgcHJldmlvdXMgdmFsdWVzIGZvciBlYWNoIHByb3BlcnR5XG4gICAgICAgKiAgIGluIGBjaGFuZ2VkUHJvcHNgXG4gICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgKi9cbiAgICAgIF9wcm9wZXJ0aWVzQ2hhbmdlZChjdXJyZW50UHJvcHMsIGNoYW5nZWRQcm9wcywgb2xkUHJvcHMpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIE1ldGhvZCBjYWxsZWQgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgYSBwcm9wZXJ0eSB2YWx1ZSBzaG91bGQgYmVcbiAgICAgICAqIGNvbnNpZGVyZWQgYXMgYSBjaGFuZ2UgYW5kIGNhdXNlIHRoZSBgX3Byb3BlcnRpZXNDaGFuZ2VkYCBjYWxsYmFja1xuICAgICAgICogdG8gYmUgZW5xdWV1ZWQuXG4gICAgICAgKlxuICAgICAgICogVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gcmV0dXJucyBgdHJ1ZWAgZm9yIHByaW1pdGl2ZSB0eXBlcyBpZiBhXG4gICAgICAgKiBzdHJpY3QgZXF1YWxpdHkgY2hlY2sgZmFpbHMsIGFuZCByZXR1cm5zIGB0cnVlYCBmb3IgYWxsIE9iamVjdC9BcnJheXMuXG4gICAgICAgKiBUaGUgbWV0aG9kIGFsd2F5cyByZXR1cm5zIGZhbHNlIGZvciBgTmFOYC5cbiAgICAgICAqXG4gICAgICAgKiBPdmVycmlkZSB0aGlzIG1ldGhvZCB0byBlLmcuIHByb3ZpZGUgc3RyaWN0ZXIgY2hlY2tpbmcgZm9yXG4gICAgICAgKiBPYmplY3RzL0FycmF5cyB3aGVuIHVzaW5nIGltbXV0YWJsZSBwYXR0ZXJucy5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgbmFtZVxuICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBOZXcgcHJvcGVydHkgdmFsdWVcbiAgICAgICAqIEBwYXJhbSB7Kn0gb2xkIFByZXZpb3VzIHByb3BlcnR5IHZhbHVlXG4gICAgICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBwcm9wZXJ0eSBzaG91bGQgYmUgY29uc2lkZXJlZCBhIGNoYW5nZVxuICAgICAgICogICBhbmQgZW5xdWV1ZSBhIGBfcHJvZXBydGllc0NoYW5nZWRgIGNhbGxiYWNrXG4gICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgKi9cbiAgICAgIF9zaG91bGRQcm9wZXJ0eUNoYW5nZShwcm9wZXJ0eSwgdmFsdWUsIG9sZCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIC8vIFN0cmljdCBlcXVhbGl0eSBjaGVja1xuICAgICAgICAgIChvbGQgIT09IHZhbHVlICYmXG4gICAgICAgICAgIC8vIFRoaXMgZW5zdXJlcyAob2xkPT1OYU4sIHZhbHVlPT1OYU4pIGFsd2F5cyByZXR1cm5zIGZhbHNlXG4gICAgICAgICAgIChvbGQgPT09IG9sZCB8fCB2YWx1ZSA9PT0gdmFsdWUpKVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgfVxuXG4gICAgcmV0dXJuIFByb3BlcnR5QWNjZXNzb3JzO1xuXG4gIH0pO1xuXG59KSgpO1xuPC9zY3JpcHQ+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL3BvbHltZXIvbGliL21peGlucy9wcm9wZXJ0eS1hY2Nlc3NvcnMuaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cblxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3V0aWxzL2Jvb3QuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3V0aWxzL21peGluLmh0bWxcIj5cblxuPHNjcmlwdD5cbihmdW5jdGlvbigpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgLy8gMS54IGJhY2t3YXJkcy1jb21wYXRpYmxlIGF1dG8td3JhcHBlciBmb3IgdGVtcGxhdGUgdHlwZSBleHRlbnNpb25zXG4gIC8vIFRoaXMgaXMgYSBjbGVhciBsYXllcmluZyB2aW9sYXRpb24gYW5kIGdpdmVzIGZhdm9yZWQtbmF0aW9uIHN0YXR1cyB0b1xuICAvLyBkb20taWYgYW5kIGRvbS1yZXBlYXQgdGVtcGxhdGVzLiAgVGhpcyBpcyBhIGNvbmNlaXQgd2UncmUgY2hvb3NpbmcgdG8ga2VlcFxuICAvLyBhLikgdG8gZWFzZSAxLnggYmFja3dhcmRzLWNvbXBhdGliaWxpdHkgZHVlIHRvIGxvc3Mgb2YgYGlzYCwgYW5kXG4gIC8vIGIuKSB0byBtYWludGFpbiBpZi9yZXBlYXQgY2FwYWJpbGl0eSBpbiBwYXJzZXItY29uc3RyYWluZWQgZWxlbWVudHNcbiAgLy8gICAgIChlLmcuIHRhYmxlLCBzZWxlY3QpIGluIGxpZXUgb2YgbmF0aXZlIENFIHR5cGUgZXh0ZW5zaW9ucyB3aXRob3V0XG4gIC8vICAgICBtYXNzaXZlIG5ldyBpbnZlbnRpb24gaW4gdGhpcyBzcGFjZSAoZS5nLiBkaXJlY3RpdmUgc3lzdGVtKVxuICBjb25zdCB0ZW1wbGF0ZUV4dGVuc2lvbnMgPSB7XG4gICAgJ2RvbS1pZic6IHRydWUsXG4gICAgJ2RvbS1yZXBlYXQnOiB0cnVlXG4gIH07XG4gIGZ1bmN0aW9uIHdyYXBUZW1wbGF0ZUV4dGVuc2lvbihub2RlKSB7XG4gICAgbGV0IGlzID0gbm9kZS5nZXRBdHRyaWJ1dGUoJ2lzJyk7XG4gICAgaWYgKGlzICYmIHRlbXBsYXRlRXh0ZW5zaW9uc1tpc10pIHtcbiAgICAgIGxldCB0ID0gbm9kZTtcbiAgICAgIHQucmVtb3ZlQXR0cmlidXRlKCdpcycpO1xuICAgICAgbm9kZSA9IHQub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KGlzKTtcbiAgICAgIHQucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQobm9kZSwgdCk7XG4gICAgICBub2RlLmFwcGVuZENoaWxkKHQpO1xuICAgICAgd2hpbGUodC5hdHRyaWJ1dGVzLmxlbmd0aCkge1xuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZSh0LmF0dHJpYnV0ZXNbMF0ubmFtZSwgdC5hdHRyaWJ1dGVzWzBdLnZhbHVlKTtcbiAgICAgICAgdC5yZW1vdmVBdHRyaWJ1dGUodC5hdHRyaWJ1dGVzWzBdLm5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmRUZW1wbGF0ZU5vZGUocm9vdCwgbm9kZUluZm8pIHtcbiAgICAvLyByZWN1cnNpdmVseSBhc2NlbmQgdHJlZSB1bnRpbCB3ZSBoaXQgcm9vdFxuICAgIGxldCBwYXJlbnQgPSBub2RlSW5mby5wYXJlbnRJbmZvICYmIGZpbmRUZW1wbGF0ZU5vZGUocm9vdCwgbm9kZUluZm8ucGFyZW50SW5mbyk7XG4gICAgLy8gdW53aW5kIHRoZSBzdGFjaywgcmV0dXJuaW5nIHRoZSBpbmRleGVkIG5vZGUgYXQgZWFjaCBsZXZlbFxuICAgIGlmIChwYXJlbnQpIHtcbiAgICAgIC8vIG5vdGU6IG1hcmdpbmFsbHkgZmFzdGVyIHRoYW4gaW5kZXhpbmcgdmlhIGNoaWxkTm9kZXNcbiAgICAgIC8vIChodHRwOi8vanNwZXJmLmNvbS9jaGlsZG5vZGVzLWxvb2t1cClcbiAgICAgIGZvciAobGV0IG49cGFyZW50LmZpcnN0Q2hpbGQsIGk9MDsgbjsgbj1uLm5leHRTaWJsaW5nKSB7XG4gICAgICAgIGlmIChub2RlSW5mby5wYXJlbnRJbmRleCA9PT0gaSsrKSB7XG4gICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgfVxuICB9XG5cbiAgLy8gY29uc3RydWN0IGAkYCBtYXAgKGZyb20gaWQgYW5ub3RhdGlvbnMpXG4gIGZ1bmN0aW9uIGFwcGx5SWRUb01hcChpbnN0LCBtYXAsIG5vZGUsIG5vZGVJbmZvKSB7XG4gICAgaWYgKG5vZGVJbmZvLmlkKSB7XG4gICAgICBtYXBbbm9kZUluZm8uaWRdID0gbm9kZTtcbiAgICB9XG4gIH1cblxuICAvLyBpbnN0YWxsIGV2ZW50IGxpc3RlbmVycyAoZnJvbSBldmVudCBhbm5vdGF0aW9ucylcbiAgZnVuY3Rpb24gYXBwbHlFdmVudExpc3RlbmVyKGluc3QsIG5vZGUsIG5vZGVJbmZvKSB7XG4gICAgaWYgKG5vZGVJbmZvLmV2ZW50cyAmJiBub2RlSW5mby5ldmVudHMubGVuZ3RoKSB7XG4gICAgICBmb3IgKGxldCBqPTAsIGUkPW5vZGVJbmZvLmV2ZW50cywgZTsgKGo8ZSQubGVuZ3RoKSAmJiAoZT1lJFtqXSk7IGorKykge1xuICAgICAgICBpbnN0Ll9hZGRNZXRob2RFdmVudExpc3RlbmVyVG9Ob2RlKG5vZGUsIGUubmFtZSwgZS52YWx1ZSwgaW5zdCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gcHVzaCBjb25maWd1cmF0aW9uIHJlZmVyZW5jZXMgYXQgY29uZmlndXJlIHRpbWVcbiAgZnVuY3Rpb24gYXBwbHlUZW1wbGF0ZUNvbnRlbnQoaW5zdCwgbm9kZSwgbm9kZUluZm8pIHtcbiAgICBpZiAobm9kZUluZm8udGVtcGxhdGVJbmZvKSB7XG4gICAgICBub2RlLl90ZW1wbGF0ZUluZm8gPSBub2RlSW5mby50ZW1wbGF0ZUluZm87XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlTm9kZUV2ZW50SGFuZGxlcihjb250ZXh0LCBldmVudE5hbWUsIG1ldGhvZE5hbWUpIHtcbiAgICAvLyBJbnN0YW5jZXMgY2FuIG9wdGlvbmFsbHkgaGF2ZSBhIF9tZXRob2RIb3N0IHdoaWNoIGFsbG93cyByZWRpcmVjdGluZyB3aGVyZVxuICAgIC8vIHRvIGZpbmQgbWV0aG9kcy4gQ3VycmVudGx5IHVzZWQgYnkgYHRlbXBsYXRpemVgLlxuICAgIGNvbnRleHQgPSBjb250ZXh0Ll9tZXRob2RIb3N0IHx8IGNvbnRleHQ7XG4gICAgbGV0IGhhbmRsZXIgPSBmdW5jdGlvbihlKSB7XG4gICAgICBpZiAoY29udGV4dFttZXRob2ROYW1lXSkge1xuICAgICAgICBjb250ZXh0W21ldGhvZE5hbWVdKGUsIGUuZGV0YWlsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUud2FybignbGlzdGVuZXIgbWV0aG9kIGAnICsgbWV0aG9kTmFtZSArICdgIG5vdCBkZWZpbmVkJyk7XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gaGFuZGxlcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbGVtZW50IG1peGluIHRoYXQgcHJvdmlkZXMgYmFzaWMgdGVtcGxhdGUgcGFyc2luZyBhbmQgc3RhbXBpbmcsIGluY2x1ZGluZ1xuICAgKiB0aGUgZm9sbG93aW5nIHRlbXBsYXRlLXJlbGF0ZWQgZmVhdHVyZXMgZm9yIHN0YW1wZWQgdGVtcGxhdGVzOlxuICAgKlxuICAgKiAtIERlY2xhcmF0aXZlIGV2ZW50IGxpc3RlbmVycyAoYG9uLWV2ZW50bmFtZT1cImxpc3RlbmVyXCJgKVxuICAgKiAtIE1hcCBvZiBub2RlIGlkJ3MgdG8gc3RhbXBlZCBub2RlIGluc3RhbmNlcyAoYHRoaXMuJC5pZGApXG4gICAqIC0gTmVzdGVkIHRlbXBsYXRlIGNvbnRlbnQgY2FjaGluZy9yZW1vdmFsIGFuZCByZS1pbnN0YWxsYXRpb24gKHBlcmZvcm1hbmNlXG4gICAqICAgb3B0aW1pemF0aW9uKVxuICAgKlxuICAgKiBAbWl4aW5GdW5jdGlvblxuICAgKiBAcG9seW1lclxuICAgKiBAbWVtYmVyb2YgUG9seW1lclxuICAgKiBAc3VtbWFyeSBFbGVtZW50IGNsYXNzIG1peGluIHRoYXQgcHJvdmlkZXMgYmFzaWMgdGVtcGxhdGUgcGFyc2luZyBhbmQgc3RhbXBpbmdcbiAgICovXG4gIFBvbHltZXIuVGVtcGxhdGVTdGFtcCA9IFBvbHltZXIuZGVkdXBpbmdNaXhpbihzdXBlckNsYXNzID0+IHtcblxuICAgIC8qKlxuICAgICAqIEBwb2x5bWVyXG4gICAgICogQG1peGluQ2xhc3NcbiAgICAgKiBAaW1wbGVtZW50cyB7UG9seW1lcl9UZW1wbGF0ZVN0YW1wfVxuICAgICAqL1xuICAgIGNsYXNzIFRlbXBsYXRlU3RhbXAgZXh0ZW5kcyBzdXBlckNsYXNzIHtcblxuICAgICAgLyoqXG4gICAgICAgKiBTY2FucyBhIHRlbXBsYXRlIHRvIHByb2R1Y2UgdGVtcGxhdGUgbWV0YWRhdGEuXG4gICAgICAgKlxuICAgICAgICogVGVtcGxhdGUtc3BlY2lmaWMgbWV0YWRhdGEgYXJlIHN0b3JlZCBpbiB0aGUgb2JqZWN0IHJldHVybmVkLCBhbmQgbm9kZS1cbiAgICAgICAqIHNwZWNpZmljIG1ldGFkYXRhIGFyZSBzdG9yZWQgaW4gb2JqZWN0cyBpbiBpdHMgZmxhdHRlbmVkIGBub2RlSW5mb0xpc3RgXG4gICAgICAgKiBhcnJheS4gIE9ubHkgbm9kZXMgaW4gdGhlIHRlbXBsYXRlIHRoYXQgd2VyZSBwYXJzZWQgYXMgbm9kZXMgb2ZcbiAgICAgICAqIGludGVyZXN0IGNvbnRhaW4gYW4gb2JqZWN0IGluIGBub2RlSW5mb0xpc3RgLiAgRWFjaCBgbm9kZUluZm9gIG9iamVjdFxuICAgICAgICogY29udGFpbnMgYW4gYGluZGV4YCAoYGNoaWxkTm9kZXNgIGluZGV4IGluIHBhcmVudCkgYW5kIG9wdGlvbmFsbHlcbiAgICAgICAqIGBwYXJlbnRgLCB3aGljaCBwb2ludHMgdG8gbm9kZSBpbmZvIG9mIGl0cyBwYXJlbnQgKGluY2x1ZGluZyBpdHMgaW5kZXgpLlxuICAgICAgICpcbiAgICAgICAqIFRoZSB0ZW1wbGF0ZSBtZXRhZGF0YSBvYmplY3QgcmV0dXJuZWQgZnJvbSB0aGlzIG1ldGhvZCBoYXMgdGhlIGZvbGxvd2luZ1xuICAgICAgICogc3RydWN0dXJlIChtYW55IGZpZWxkcyBvcHRpb25hbCk6XG4gICAgICAgKlxuICAgICAgICogYGBganNcbiAgICAgICAqICAge1xuICAgICAgICogICAgIC8vIEZsYXR0ZW5lZCBsaXN0IG9mIG5vZGUgbWV0YWRhdGEgKGZvciBub2RlcyB0aGF0IGdlbmVyYXRlZCBtZXRhZGF0YSlcbiAgICAgICAqICAgICBub2RlSW5mb0xpc3Q6IFtcbiAgICAgICAqICAgICAgIHtcbiAgICAgICAqICAgICAgICAgLy8gYGlkYCBhdHRyaWJ1dGUgZm9yIGFueSBub2RlcyB3aXRoIGlkJ3MgZm9yIGdlbmVyYXRpbmcgYCRgIG1hcFxuICAgICAgICogICAgICAgICBpZDoge3N0cmluZ30sXG4gICAgICAgKiAgICAgICAgIC8vIGBvbi1ldmVudD1cImhhbmRsZXJcImAgbWV0YWRhdGFcbiAgICAgICAqICAgICAgICAgZXZlbnRzOiBbXG4gICAgICAgKiAgICAgICAgICAge1xuICAgICAgICogICAgICAgICAgICAgbmFtZToge3N0cmluZ30sICAgLy8gZXZlbnQgbmFtZVxuICAgICAgICogICAgICAgICAgICAgdmFsdWU6IHtzdHJpbmd9LCAgLy8gaGFuZGxlciBtZXRob2QgbmFtZVxuICAgICAgICogICAgICAgICAgIH0sIC4uLlxuICAgICAgICogICAgICAgICBdLFxuICAgICAgICogICAgICAgICAvLyBOb3RlcyB3aGVuIHRoZSB0ZW1wbGF0ZSBjb250YWluZWQgYSBgPHNsb3Q+YCBmb3Igc2hhZHkgRE9NXG4gICAgICAgKiAgICAgICAgIC8vIG9wdGltaXphdGlvbiBwdXJwb3Nlc1xuICAgICAgICogICAgICAgICBoYXNJbnNlcnRpb25Qb2ludDoge2Jvb2xlYW59LFxuICAgICAgICogICAgICAgICAvLyBGb3IgbmVzdGVkIGA8dGVtcGxhdGU+YGAgbm9kZXMsIG5lc3RlZCB0ZW1wbGF0ZSBtZXRhZGF0YVxuICAgICAgICogICAgICAgICB0ZW1wbGF0ZUluZm86IHtvYmplY3R9LCAvLyBuZXN0ZWQgdGVtcGxhdGUgbWV0YWRhdGFcbiAgICAgICAqICAgICAgICAgLy8gTWV0YWRhdGEgdG8gYWxsb3cgZWZmaWNpZW50IHJldHJpZXZhbCBvZiBpbnN0YW5jZWQgbm9kZVxuICAgICAgICogICAgICAgICAvLyBjb3JyZXNwb25kaW5nIHRvIHRoaXMgbWV0YWRhdGFcbiAgICAgICAqICAgICAgICAgcGFyZW50SW5mbzoge251bWJlcn0sICAgLy8gcmVmZXJlbmNlIHRvIHBhcmVudCBub2RlSW5mbz5cbiAgICAgICAqICAgICAgICAgcGFyZW50SW5kZXg6IHtudW1iZXJ9LCAgLy8gaW5kZXggaW4gcGFyZW50J3MgYGNoaWxkTm9kZXNgIGNvbGxlY3Rpb25cbiAgICAgICAqICAgICAgICAgaW5mb0luZGV4OiB7bnVtYmVyfSwgICAgLy8gaW5kZXggb2YgdGhpcyBgbm9kZUluZm9gIGluIGB0ZW1wbGF0ZUluZm8ubm9kZUluZm9MaXN0YFxuICAgICAgICogICAgICAgfSxcbiAgICAgICAqICAgICAgIC4uLlxuICAgICAgICogICAgIF0sXG4gICAgICAgKiAgICAgLy8gV2hlbiB0cnVlLCB0aGUgdGVtcGxhdGUgaGFkIHRoZSBgc3RyaXAtd2hpdGVzcGFjZWAgYXR0cmlidXRlXG4gICAgICAgKiAgICAgLy8gb3Igd2FzIG5lc3RlZCBpbiBhIHRlbXBsYXRlIHdpdGggdGhhdCBzZXR0aW5nXG4gICAgICAgKiAgICAgc3RyaXBXaGl0ZXNwYWNlOiB7Ym9vbGVhbn0sXG4gICAgICAgKiAgICAgLy8gRm9yIG5lc3RlZCB0ZW1wbGF0ZXMsIG5lc3RlZCB0ZW1wbGF0ZSBjb250ZW50IGlzIG1vdmVkIGludG9cbiAgICAgICAqICAgICAvLyBhIGRvY3VtZW50IGZyYWdtZW50IHN0b3JlZCBoZXJlOyB0aGlzIGlzIGFuIG9wdGltaXphdGlvbiB0b1xuICAgICAgICogICAgIC8vIGF2b2lkIHRoZSBjb3N0IG9mIG5lc3RlZCB0ZW1wbGF0ZSBjbG9uaW5nXG4gICAgICAgKiAgICAgY29udGVudDoge0RvY3VtZW50RnJhZ21lbnR9XG4gICAgICAgKiAgIH1cbiAgICAgICAqIGBgYFxuICAgICAgICpcbiAgICAgICAqIFRoaXMgbWV0aG9kIGtpY2tzIG9mZiBhIHJlY3Vyc2l2ZSB0cmVld2FsayBhcyBmb2xsb3dzOlxuICAgICAgICpcbiAgICAgICAqIGBgYFxuICAgICAgICogICAgX3BhcnNlVGVtcGxhdGUgPC0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAqICAgICAgX3BhcnNlVGVtcGxhdGVDb250ZW50ICAgICAgICAgICAgICB8XG4gICAgICAgKiAgICAgICAgX3BhcnNlVGVtcGxhdGVOb2RlICA8LS0tLS0tLS0tLS0tfC0tK1xuICAgICAgICogICAgICAgICAgX3BhcnNlVGVtcGxhdGVOZXN0ZWRUZW1wbGF0ZSAtLSsgIHxcbiAgICAgICAqICAgICAgICAgIF9wYXJzZVRlbXBsYXRlQ2hpbGROb2RlcyAtLS0tLS0tLS0rXG4gICAgICAgKiAgICAgICAgICBfcGFyc2VUZW1wbGF0ZU5vZGVBdHRyaWJ1dGVzXG4gICAgICAgKiAgICAgICAgICAgIF9wYXJzZVRlbXBsYXRlTm9kZUF0dHJpYnV0ZVxuICAgICAgICpcbiAgICAgICAqIGBgYFxuICAgICAgICpcbiAgICAgICAqIFRoZXNlIG1ldGhvZHMgbWF5IGJlIG92ZXJyaWRkZW4gdG8gYWRkIGN1c3RvbSBtZXRhZGF0YSBhYm91dCB0ZW1wbGF0ZXNcbiAgICAgICAqIHRvIGVpdGhlciBgdGVtcGxhdGVJbmZvYCBvciBgbm9kZUluZm9gLlxuICAgICAgICpcbiAgICAgICAqIE5vdGUgdGhhdCB0aGlzIG1ldGhvZCBtYXkgYmUgZGVzdHJ1Y3RpdmUgdG8gdGhlIHRlbXBsYXRlLCBpbiB0aGF0XG4gICAgICAgKiBlLmcuIGV2ZW50IGFubm90YXRpb25zIG1heSBiZSByZW1vdmVkIGFmdGVyIGJlaW5nIG5vdGVkIGluIHRoZVxuICAgICAgICogdGVtcGxhdGUgbWV0YWRhdGEuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHshSFRNTFRlbXBsYXRlRWxlbWVudH0gdGVtcGxhdGUgVGVtcGxhdGUgdG8gcGFyc2VcbiAgICAgICAqIEBwYXJhbSB7VGVtcGxhdGVJbmZvPX0gb3V0ZXJUZW1wbGF0ZUluZm8gVGVtcGxhdGUgbWV0YWRhdGEgZnJvbSB0aGUgb3V0ZXJcbiAgICAgICAqICAgdGVtcGxhdGUsIGZvciBwYXJzaW5nIG5lc3RlZCB0ZW1wbGF0ZXNcbiAgICAgICAqIEByZXR1cm4geyFUZW1wbGF0ZUluZm99IFBhcnNlZCB0ZW1wbGF0ZSBtZXRhZGF0YVxuICAgICAgICovXG4gICAgICBzdGF0aWMgX3BhcnNlVGVtcGxhdGUodGVtcGxhdGUsIG91dGVyVGVtcGxhdGVJbmZvKSB7XG4gICAgICAgIC8vIHNpbmNlIGEgdGVtcGxhdGUgbWF5IGJlIHJlLXVzZWQsIG1lbW8taXplIG1ldGFkYXRhXG4gICAgICAgIGlmICghdGVtcGxhdGUuX3RlbXBsYXRlSW5mbykge1xuICAgICAgICAgIGxldCB0ZW1wbGF0ZUluZm8gPSB0ZW1wbGF0ZS5fdGVtcGxhdGVJbmZvID0ge307XG4gICAgICAgICAgdGVtcGxhdGVJbmZvLm5vZGVJbmZvTGlzdCA9IFtdO1xuICAgICAgICAgIHRlbXBsYXRlSW5mby5zdHJpcFdoaXRlU3BhY2UgPVxuICAgICAgICAgICAgKG91dGVyVGVtcGxhdGVJbmZvICYmIG91dGVyVGVtcGxhdGVJbmZvLnN0cmlwV2hpdGVTcGFjZSkgfHxcbiAgICAgICAgICAgIHRlbXBsYXRlLmhhc0F0dHJpYnV0ZSgnc3RyaXAtd2hpdGVzcGFjZScpO1xuICAgICAgICAgIHRoaXMuX3BhcnNlVGVtcGxhdGVDb250ZW50KHRlbXBsYXRlLCB0ZW1wbGF0ZUluZm8sIHtwYXJlbnQ6IG51bGx9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGVtcGxhdGUuX3RlbXBsYXRlSW5mbztcbiAgICAgIH1cblxuICAgICAgc3RhdGljIF9wYXJzZVRlbXBsYXRlQ29udGVudCh0ZW1wbGF0ZSwgdGVtcGxhdGVJbmZvLCBub2RlSW5mbykge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFyc2VUZW1wbGF0ZU5vZGUodGVtcGxhdGUuY29udGVudCwgdGVtcGxhdGVJbmZvLCBub2RlSW5mbyk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUGFyc2VzIHRlbXBsYXRlIG5vZGUgYW5kIGFkZHMgdGVtcGxhdGUgYW5kIG5vZGUgbWV0YWRhdGEgYmFzZWQgb25cbiAgICAgICAqIHRoZSBjdXJyZW50IG5vZGUsIGFuZCBpdHMgYGNoaWxkTm9kZXNgIGFuZCBgYXR0cmlidXRlc2AuXG4gICAgICAgKlxuICAgICAgICogVGhpcyBtZXRob2QgbWF5IGJlIG92ZXJyaWRkZW4gdG8gYWRkIGN1c3RvbSBub2RlIG9yIHRlbXBsYXRlIHNwZWNpZmljXG4gICAgICAgKiBtZXRhZGF0YSBiYXNlZCBvbiB0aGlzIG5vZGUuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtOb2RlfSBub2RlIE5vZGUgdG8gcGFyc2VcbiAgICAgICAqIEBwYXJhbSB7IVRlbXBsYXRlSW5mb30gdGVtcGxhdGVJbmZvIFRlbXBsYXRlIG1ldGFkYXRhIGZvciBjdXJyZW50IHRlbXBsYXRlXG4gICAgICAgKiBAcGFyYW0geyFOb2RlSW5mb30gbm9kZUluZm8gTm9kZSBtZXRhZGF0YSBmb3IgY3VycmVudCB0ZW1wbGF0ZS5cbiAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgdmlzaXRlZCBub2RlIGFkZGVkIG5vZGUtc3BlY2lmaWNcbiAgICAgICAqICAgbWV0YWRhdGEgdG8gYG5vZGVJbmZvYFxuICAgICAgICovXG4gICAgICBzdGF0aWMgX3BhcnNlVGVtcGxhdGVOb2RlKG5vZGUsIHRlbXBsYXRlSW5mbywgbm9kZUluZm8pIHtcbiAgICAgICAgbGV0IG5vdGVkO1xuICAgICAgICBsZXQgZWxlbWVudCA9IC8qKiBAdHlwZSBFbGVtZW50ICovKG5vZGUpO1xuICAgICAgICBpZiAoZWxlbWVudC5sb2NhbE5hbWUgPT0gJ3RlbXBsYXRlJyAmJiAhZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ3ByZXNlcnZlLWNvbnRlbnQnKSkge1xuICAgICAgICAgIG5vdGVkID0gdGhpcy5fcGFyc2VUZW1wbGF0ZU5lc3RlZFRlbXBsYXRlKGVsZW1lbnQsIHRlbXBsYXRlSW5mbywgbm9kZUluZm8pIHx8IG5vdGVkO1xuICAgICAgICB9IGVsc2UgaWYgKGVsZW1lbnQubG9jYWxOYW1lID09PSAnc2xvdCcpIHtcbiAgICAgICAgICAvLyBGb3IgU2hhZHlEb20gb3B0aW1pemF0aW9uLCBpbmRpY2F0aW5nIHRoZXJlIGlzIGFuIGluc2VydGlvbiBwb2ludFxuICAgICAgICAgIHRlbXBsYXRlSW5mby5oYXNJbnNlcnRpb25Qb2ludCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVsZW1lbnQuZmlyc3RDaGlsZCkge1xuICAgICAgICAgIG5vdGVkID0gdGhpcy5fcGFyc2VUZW1wbGF0ZUNoaWxkTm9kZXMoZWxlbWVudCwgdGVtcGxhdGVJbmZvLCBub2RlSW5mbykgfHwgbm90ZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVsZW1lbnQuaGFzQXR0cmlidXRlcyAmJiBlbGVtZW50Lmhhc0F0dHJpYnV0ZXMoKSkge1xuICAgICAgICAgIG5vdGVkID0gdGhpcy5fcGFyc2VUZW1wbGF0ZU5vZGVBdHRyaWJ1dGVzKGVsZW1lbnQsIHRlbXBsYXRlSW5mbywgbm9kZUluZm8pIHx8IG5vdGVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub3RlZDtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBQYXJzZXMgdGVtcGxhdGUgY2hpbGQgbm9kZXMgZm9yIHRoZSBnaXZlbiByb290IG5vZGUuXG4gICAgICAgKlxuICAgICAgICogVGhpcyBtZXRob2QgYWxzbyB3cmFwcyB3aGl0ZWxpc3RlZCBsZWdhY3kgdGVtcGxhdGUgZXh0ZW5zaW9uc1xuICAgICAgICogKGBpcz1cImRvbS1pZlwiYCBhbmQgYGlzPVwiZG9tLXJlcGVhdFwiYCkgd2l0aCB0aGVpciBlcXVpdmFsZW50IGVsZW1lbnRcbiAgICAgICAqIHdyYXBwZXJzLCBjb2xsYXBzZXMgdGV4dCBub2RlcywgYW5kIHN0cmlwcyB3aGl0ZXNwYWNlIGZyb20gdGhlIHRlbXBsYXRlXG4gICAgICAgKiBpZiB0aGUgYHRlbXBsYXRlSW5mby5zdHJpcFdoaXRlc3BhY2VgIHNldHRpbmcgd2FzIHByb3ZpZGVkLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7Tm9kZX0gcm9vdCBSb290IG5vZGUgd2hvc2UgYGNoaWxkTm9kZXNgIHdpbGwgYmUgcGFyc2VkXG4gICAgICAgKiBAcGFyYW0geyFUZW1wbGF0ZUluZm99IHRlbXBsYXRlSW5mbyBUZW1wbGF0ZSBtZXRhZGF0YSBmb3IgY3VycmVudCB0ZW1wbGF0ZVxuICAgICAgICogQHBhcmFtIHshTm9kZUluZm99IG5vZGVJbmZvIE5vZGUgbWV0YWRhdGEgZm9yIGN1cnJlbnQgdGVtcGxhdGUuXG4gICAgICAgKi9cbiAgICAgIHN0YXRpYyBfcGFyc2VUZW1wbGF0ZUNoaWxkTm9kZXMocm9vdCwgdGVtcGxhdGVJbmZvLCBub2RlSW5mbykge1xuICAgICAgICBmb3IgKGxldCBub2RlPXJvb3QuZmlyc3RDaGlsZCwgcGFyZW50SW5kZXg9MCwgbmV4dDsgbm9kZTsgbm9kZT1uZXh0KSB7XG4gICAgICAgICAgLy8gV3JhcCB0ZW1wbGF0ZXNcbiAgICAgICAgICBpZiAobm9kZS5sb2NhbE5hbWUgPT0gJ3RlbXBsYXRlJykge1xuICAgICAgICAgICAgbm9kZSA9IHdyYXBUZW1wbGF0ZUV4dGVuc2lvbihub2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gY29sbGFwc2UgYWRqYWNlbnQgdGV4dE5vZGVzOiBmaXhlcyBhbiBJRSBpc3N1ZSB0aGF0IGNhbiBjYXVzZVxuICAgICAgICAgIC8vIHRleHQgbm9kZXMgdG8gYmUgaW5leHBsaWNhYmx5IHNwbGl0ID0oXG4gICAgICAgICAgLy8gbm90ZSB0aGF0IHJvb3Qubm9ybWFsaXplKCkgc2hvdWxkIHdvcmsgYnV0IGRvZXMgbm90IHNvIHdlIGRvIHRoaXNcbiAgICAgICAgICAvLyBtYW51YWxseS5cbiAgICAgICAgICBuZXh0ID0gbm9kZS5uZXh0U2libGluZztcbiAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUpIHtcbiAgICAgICAgICAgIGxldCAvKiogTm9kZSAqLyBuID0gbmV4dDtcbiAgICAgICAgICAgIHdoaWxlIChuICYmIChuLm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSkpIHtcbiAgICAgICAgICAgICAgbm9kZS50ZXh0Q29udGVudCArPSBuLnRleHRDb250ZW50O1xuICAgICAgICAgICAgICBuZXh0ID0gbi5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgcm9vdC5yZW1vdmVDaGlsZChuKTtcbiAgICAgICAgICAgICAgbiA9IG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBvcHRpb25hbGx5IHN0cmlwIHdoaXRlc3BhY2VcbiAgICAgICAgICAgIGlmICh0ZW1wbGF0ZUluZm8uc3RyaXBXaGl0ZVNwYWNlICYmICFub2RlLnRleHRDb250ZW50LnRyaW0oKSkge1xuICAgICAgICAgICAgICByb290LnJlbW92ZUNoaWxkKG5vZGUpO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IGNoaWxkSW5mbyA9IHsgcGFyZW50SW5kZXgsIHBhcmVudEluZm86IG5vZGVJbmZvIH07XG4gICAgICAgICAgaWYgKHRoaXMuX3BhcnNlVGVtcGxhdGVOb2RlKG5vZGUsIHRlbXBsYXRlSW5mbywgY2hpbGRJbmZvKSkge1xuICAgICAgICAgICAgY2hpbGRJbmZvLmluZm9JbmRleCA9IHRlbXBsYXRlSW5mby5ub2RlSW5mb0xpc3QucHVzaCgvKiogQHR5cGUgeyFOb2RlSW5mb30gKi8oY2hpbGRJbmZvKSkgLSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBJbmNyZW1lbnQgaWYgbm90IHJlbW92ZWRcbiAgICAgICAgICBpZiAobm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICBwYXJlbnRJbmRleCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFBhcnNlcyB0ZW1wbGF0ZSBjb250ZW50IGZvciB0aGUgZ2l2ZW4gbmVzdGVkIGA8dGVtcGxhdGU+YC5cbiAgICAgICAqXG4gICAgICAgKiBOZXN0ZWQgdGVtcGxhdGUgaW5mbyBpcyBzdG9yZWQgYXMgYHRlbXBsYXRlSW5mb2AgaW4gdGhlIGN1cnJlbnQgbm9kZSdzXG4gICAgICAgKiBgbm9kZUluZm9gLiBgdGVtcGxhdGUuY29udGVudGAgaXMgcmVtb3ZlZCBhbmQgc3RvcmVkIGluIGB0ZW1wbGF0ZUluZm9gLlxuICAgICAgICogSXQgd2lsbCB0aGVuIGJlIHRoZSByZXNwb25zaWJpbGl0eSBvZiB0aGUgaG9zdCB0byBzZXQgaXQgYmFjayB0byB0aGVcbiAgICAgICAqIHRlbXBsYXRlIGFuZCBmb3IgdXNlcnMgc3RhbXBpbmcgbmVzdGVkIHRlbXBsYXRlcyB0byB1c2UgdGhlXG4gICAgICAgKiBgX2NvbnRlbnRGb3JUZW1wbGF0ZWAgbWV0aG9kIHRvIHJldHJpZXZlIHRoZSBjb250ZW50IGZvciB0aGlzIHRlbXBsYXRlXG4gICAgICAgKiAoYW4gb3B0aW1pemF0aW9uIHRvIGF2b2lkIHRoZSBjb3N0IG9mIGNsb25pbmcgbmVzdGVkIHRlbXBsYXRlIGNvbnRlbnQpLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7SFRNTFRlbXBsYXRlRWxlbWVudH0gbm9kZSBOb2RlIHRvIHBhcnNlIChhIDx0ZW1wbGF0ZT4pXG4gICAgICAgKiBAcGFyYW0ge1RlbXBsYXRlSW5mb30gb3V0ZXJUZW1wbGF0ZUluZm8gVGVtcGxhdGUgbWV0YWRhdGEgZm9yIGN1cnJlbnQgdGVtcGxhdGVcbiAgICAgICAqICAgdGhhdCBpbmNsdWRlcyB0aGUgdGVtcGxhdGUgYG5vZGVgXG4gICAgICAgKiBAcGFyYW0geyFOb2RlSW5mb30gbm9kZUluZm8gTm9kZSBtZXRhZGF0YSBmb3IgY3VycmVudCB0ZW1wbGF0ZS5cbiAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgdmlzaXRlZCBub2RlIGFkZGVkIG5vZGUtc3BlY2lmaWNcbiAgICAgICAqICAgbWV0YWRhdGEgdG8gYG5vZGVJbmZvYFxuICAgICAgICovXG4gICAgICBzdGF0aWMgX3BhcnNlVGVtcGxhdGVOZXN0ZWRUZW1wbGF0ZShub2RlLCBvdXRlclRlbXBsYXRlSW5mbywgbm9kZUluZm8pIHtcbiAgICAgICAgbGV0IHRlbXBsYXRlSW5mbyA9IHRoaXMuX3BhcnNlVGVtcGxhdGUobm9kZSwgb3V0ZXJUZW1wbGF0ZUluZm8pO1xuICAgICAgICBsZXQgY29udGVudCA9IHRlbXBsYXRlSW5mby5jb250ZW50ID1cbiAgICAgICAgICBub2RlLmNvbnRlbnQub3duZXJEb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgICAgIGNvbnRlbnQuYXBwZW5kQ2hpbGQobm9kZS5jb250ZW50KTtcbiAgICAgICAgbm9kZUluZm8udGVtcGxhdGVJbmZvID0gdGVtcGxhdGVJbmZvO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBQYXJzZXMgdGVtcGxhdGUgbm9kZSBhdHRyaWJ1dGVzIGFuZCBhZGRzIG5vZGUgbWV0YWRhdGEgdG8gYG5vZGVJbmZvYFxuICAgICAgICogZm9yIG5vZGVzIG9mIGludGVyZXN0LlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZSBOb2RlIHRvIHBhcnNlXG4gICAgICAgKiBAcGFyYW0ge1RlbXBsYXRlSW5mb30gdGVtcGxhdGVJbmZvIFRlbXBsYXRlIG1ldGFkYXRhIGZvciBjdXJyZW50IHRlbXBsYXRlXG4gICAgICAgKiBAcGFyYW0ge05vZGVJbmZvfSBub2RlSW5mbyBOb2RlIG1ldGFkYXRhIGZvciBjdXJyZW50IHRlbXBsYXRlLlxuICAgICAgICogQHJldHVybiB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSB2aXNpdGVkIG5vZGUgYWRkZWQgbm9kZS1zcGVjaWZpY1xuICAgICAgICogICBtZXRhZGF0YSB0byBgbm9kZUluZm9gXG4gICAgICAgKi9cbiAgICAgIHN0YXRpYyBfcGFyc2VUZW1wbGF0ZU5vZGVBdHRyaWJ1dGVzKG5vZGUsIHRlbXBsYXRlSW5mbywgbm9kZUluZm8pIHtcbiAgICAgICAgLy8gTWFrZSBjb3B5IG9mIG9yaWdpbmFsIGF0dHJpYnV0ZSBsaXN0LCBzaW5jZSB0aGUgb3JkZXIgbWF5IGNoYW5nZVxuICAgICAgICAvLyBhcyBhdHRyaWJ1dGVzIGFyZSBhZGRlZCBhbmQgcmVtb3ZlZFxuICAgICAgICBsZXQgbm90ZWQgPSBmYWxzZTtcbiAgICAgICAgbGV0IGF0dHJzID0gQXJyYXkuZnJvbShub2RlLmF0dHJpYnV0ZXMpO1xuICAgICAgICBmb3IgKGxldCBpPWF0dHJzLmxlbmd0aC0xLCBhOyAoYT1hdHRyc1tpXSk7IGktLSkge1xuICAgICAgICAgIG5vdGVkID0gdGhpcy5fcGFyc2VUZW1wbGF0ZU5vZGVBdHRyaWJ1dGUobm9kZSwgdGVtcGxhdGVJbmZvLCBub2RlSW5mbywgYS5uYW1lLCBhLnZhbHVlKSB8fCBub3RlZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm90ZWQ7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUGFyc2VzIGEgc2luZ2xlIHRlbXBsYXRlIG5vZGUgYXR0cmlidXRlIGFuZCBhZGRzIG5vZGUgbWV0YWRhdGEgdG9cbiAgICAgICAqIGBub2RlSW5mb2AgZm9yIGF0dHJpYnV0ZXMgb2YgaW50ZXJlc3QuXG4gICAgICAgKlxuICAgICAgICogVGhpcyBpbXBsZW1lbnRhdGlvbiBhZGRzIG1ldGFkYXRhIGZvciBgb24tZXZlbnQ9XCJoYW5kbGVyXCJgIGF0dHJpYnV0ZXNcbiAgICAgICAqIGFuZCBgaWRgIGF0dHJpYnV0ZXMuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtFbGVtZW50fSBub2RlIE5vZGUgdG8gcGFyc2VcbiAgICAgICAqIEBwYXJhbSB7IVRlbXBsYXRlSW5mb30gdGVtcGxhdGVJbmZvIFRlbXBsYXRlIG1ldGFkYXRhIGZvciBjdXJyZW50IHRlbXBsYXRlXG4gICAgICAgKiBAcGFyYW0geyFOb2RlSW5mb30gbm9kZUluZm8gTm9kZSBtZXRhZGF0YSBmb3IgY3VycmVudCB0ZW1wbGF0ZS5cbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIEF0dHJpYnV0ZSBuYW1lXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgQXR0cmlidXRlIHZhbHVlXG4gICAgICAgKiBAcmV0dXJuIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIHZpc2l0ZWQgbm9kZSBhZGRlZCBub2RlLXNwZWNpZmljXG4gICAgICAgKiAgIG1ldGFkYXRhIHRvIGBub2RlSW5mb2BcbiAgICAgICAqL1xuICAgICAgc3RhdGljIF9wYXJzZVRlbXBsYXRlTm9kZUF0dHJpYnV0ZShub2RlLCB0ZW1wbGF0ZUluZm8sIG5vZGVJbmZvLCBuYW1lLCB2YWx1ZSkge1xuICAgICAgICAvLyBldmVudHMgKG9uLSopXG4gICAgICAgIGlmIChuYW1lLnNsaWNlKDAsIDMpID09PSAnb24tJykge1xuICAgICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgICAgICAgIG5vZGVJbmZvLmV2ZW50cyA9IG5vZGVJbmZvLmV2ZW50cyB8fCBbXTtcbiAgICAgICAgICBub2RlSW5mby5ldmVudHMucHVzaCh7XG4gICAgICAgICAgICBuYW1lOiBuYW1lLnNsaWNlKDMpLFxuICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzdGF0aWMgaWRcbiAgICAgICAgZWxzZSBpZiAobmFtZSA9PT0gJ2lkJykge1xuICAgICAgICAgIG5vZGVJbmZvLmlkID0gdmFsdWU7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJldHVybnMgdGhlIGBjb250ZW50YCBkb2N1bWVudCBmcmFnbWVudCBmb3IgYSBnaXZlbiB0ZW1wbGF0ZS5cbiAgICAgICAqXG4gICAgICAgKiBGb3IgbmVzdGVkIHRlbXBsYXRlcywgUG9seW1lciBwZXJmb3JtcyBhbiBvcHRpbWl6YXRpb24gdG8gY2FjaGUgbmVzdGVkXG4gICAgICAgKiB0ZW1wbGF0ZSBjb250ZW50IHRvIGF2b2lkIHRoZSBjb3N0IG9mIGNsb25pbmcgZGVlcGx5IG5lc3RlZCB0ZW1wbGF0ZXMuXG4gICAgICAgKiBUaGlzIG1ldGhvZCByZXRyaWV2ZXMgdGhlIGNhY2hlZCBjb250ZW50IGZvciBhIGdpdmVuIHRlbXBsYXRlLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7SFRNTFRlbXBsYXRlRWxlbWVudH0gdGVtcGxhdGUgVGVtcGxhdGUgdG8gcmV0cmlldmUgYGNvbnRlbnRgIGZvclxuICAgICAgICogQHJldHVybiB7RG9jdW1lbnRGcmFnbWVudH0gQ29udGVudCBmcmFnbWVudFxuICAgICAgICovXG4gICAgICBzdGF0aWMgX2NvbnRlbnRGb3JUZW1wbGF0ZSh0ZW1wbGF0ZSkge1xuICAgICAgICBsZXQgdGVtcGxhdGVJbmZvID0gLyoqIEB0eXBlIHtIVE1MVGVtcGxhdGVFbGVtZW50V2l0aEluZm99ICovICh0ZW1wbGF0ZSkuX3RlbXBsYXRlSW5mbztcbiAgICAgICAgcmV0dXJuICh0ZW1wbGF0ZUluZm8gJiYgdGVtcGxhdGVJbmZvLmNvbnRlbnQpIHx8IHRlbXBsYXRlLmNvbnRlbnQ7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ2xvbmVzIHRoZSBwcm92aWRlZCB0ZW1wbGF0ZSBjb250ZW50IGFuZCByZXR1cm5zIGEgZG9jdW1lbnQgZnJhZ21lbnRcbiAgICAgICAqIGNvbnRhaW5pbmcgdGhlIGNsb25lZCBkb20uXG4gICAgICAgKlxuICAgICAgICogVGhlIHRlbXBsYXRlIGlzIHBhcnNlZCAob25jZSBhbmQgbWVtb2l6ZWQpIHVzaW5nIHRoaXMgbGlicmFyeSdzXG4gICAgICAgKiB0ZW1wbGF0ZSBwYXJzaW5nIGZlYXR1cmVzLCBhbmQgcHJvdmlkZXMgdGhlIGZvbGxvd2luZyB2YWx1ZS1hZGRlZFxuICAgICAgICogZmVhdHVyZXM6XG4gICAgICAgKiAqIEFkZHMgZGVjbGFyYXRpdmUgZXZlbnQgbGlzdGVuZXJzIGZvciBgb24tZXZlbnQ9XCJoYW5kbGVyXCJgIGF0dHJpYnV0ZXNcbiAgICAgICAqICogR2VuZXJhdGVzIGFuIFwiaWQgbWFwXCIgZm9yIGFsbCBub2RlcyB3aXRoIGlkJ3MgdW5kZXIgYCRgIG9uIHJldHVybmVkXG4gICAgICAgKiAgIGRvY3VtZW50IGZyYWdtZW50XG4gICAgICAgKiAqIFBhc3NlcyB0ZW1wbGF0ZSBpbmZvIGluY2x1ZGluZyBgY29udGVudGAgYmFjayB0byB0ZW1wbGF0ZXMgYXNcbiAgICAgICAqICAgYF90ZW1wbGF0ZUluZm9gIChhIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbiB0byBhdm9pZCBkZWVwIHRlbXBsYXRlXG4gICAgICAgKiAgIGNsb25pbmcpXG4gICAgICAgKlxuICAgICAgICogTm90ZSB0aGF0IHRoZSBtZW1vaXplZCB0ZW1wbGF0ZSBwYXJzaW5nIHByb2Nlc3MgaXMgZGVzdHJ1Y3RpdmUgdG8gdGhlXG4gICAgICAgKiB0ZW1wbGF0ZTogYXR0cmlidXRlcyBmb3IgYmluZGluZ3MgYW5kIGRlY2xhcmF0aXZlIGV2ZW50IGxpc3RlbmVycyBhcmVcbiAgICAgICAqIHJlbW92ZWQgYWZ0ZXIgYmVpbmcgbm90ZWQgaW4gbm90ZXMsIGFuZCBhbnkgbmVzdGVkIGA8dGVtcGxhdGU+LmNvbnRlbnRgXG4gICAgICAgKiBpcyByZW1vdmVkIGFuZCBzdG9yZWQgaW4gbm90ZXMgYXMgd2VsbC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0geyFIVE1MVGVtcGxhdGVFbGVtZW50fSB0ZW1wbGF0ZSBUZW1wbGF0ZSB0byBzdGFtcFxuICAgICAgICogQHJldHVybiB7IVN0YW1wZWRUZW1wbGF0ZX0gQ2xvbmVkIHRlbXBsYXRlIGNvbnRlbnRcbiAgICAgICAqL1xuICAgICAgX3N0YW1wVGVtcGxhdGUodGVtcGxhdGUpIHtcbiAgICAgICAgLy8gUG9seWZpbGwgc3VwcG9ydDogYm9vdHN0cmFwIHRoZSB0ZW1wbGF0ZSBpZiBpdCBoYXMgbm90IGFscmVhZHkgYmVlblxuICAgICAgICBpZiAodGVtcGxhdGUgJiYgIXRlbXBsYXRlLmNvbnRlbnQgJiZcbiAgICAgICAgICAgIHdpbmRvdy5IVE1MVGVtcGxhdGVFbGVtZW50ICYmIEhUTUxUZW1wbGF0ZUVsZW1lbnQuZGVjb3JhdGUpIHtcbiAgICAgICAgICBIVE1MVGVtcGxhdGVFbGVtZW50LmRlY29yYXRlKHRlbXBsYXRlKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdGVtcGxhdGVJbmZvID0gdGhpcy5jb25zdHJ1Y3Rvci5fcGFyc2VUZW1wbGF0ZSh0ZW1wbGF0ZSk7XG4gICAgICAgIGxldCBub2RlSW5mbyA9IHRlbXBsYXRlSW5mby5ub2RlSW5mb0xpc3Q7XG4gICAgICAgIGxldCBjb250ZW50ID0gdGVtcGxhdGVJbmZvLmNvbnRlbnQgfHwgdGVtcGxhdGUuY29udGVudDtcbiAgICAgICAgbGV0IGRvbSA9IC8qKiBAdHlwZSBEb2N1bWVudEZyYWdtZW50ICovIChkb2N1bWVudC5pbXBvcnROb2RlKGNvbnRlbnQsIHRydWUpKTtcbiAgICAgICAgLy8gTk9URTogU2hhZHlEb20gb3B0aW1pemF0aW9uIGluZGljYXRpbmcgdGhlcmUgaXMgYW4gaW5zZXJ0aW9uIHBvaW50XG4gICAgICAgIGRvbS5fX25vSW5zZXJ0aW9uUG9pbnQgPSAhdGVtcGxhdGVJbmZvLmhhc0luc2VydGlvblBvaW50O1xuICAgICAgICBsZXQgbm9kZXMgPSBkb20ubm9kZUxpc3QgPSBuZXcgQXJyYXkobm9kZUluZm8ubGVuZ3RoKTtcbiAgICAgICAgZG9tLiQgPSB7fTtcbiAgICAgICAgZm9yIChsZXQgaT0wLCBsPW5vZGVJbmZvLmxlbmd0aCwgaW5mbzsgKGk8bCkgJiYgKGluZm89bm9kZUluZm9baV0pOyBpKyspIHtcbiAgICAgICAgICBsZXQgbm9kZSA9IG5vZGVzW2ldID0gZmluZFRlbXBsYXRlTm9kZShkb20sIGluZm8pO1xuICAgICAgICAgIGFwcGx5SWRUb01hcCh0aGlzLCBkb20uJCwgbm9kZSwgaW5mbyk7XG4gICAgICAgICAgYXBwbHlUZW1wbGF0ZUNvbnRlbnQodGhpcywgbm9kZSwgaW5mbyk7XG4gICAgICAgICAgYXBwbHlFdmVudExpc3RlbmVyKHRoaXMsIG5vZGUsIGluZm8pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAvKiogQHR5cGUgeyFTdGFtcGVkVGVtcGxhdGV9ICovKGRvbSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQWRkcyBhbiBldmVudCBsaXN0ZW5lciBieSBtZXRob2QgbmFtZSBmb3IgdGhlIGV2ZW50IHByb3ZpZGVkLlxuICAgICAgICpcbiAgICAgICAqIFRoaXMgbWV0aG9kIGdlbmVyYXRlcyBhIGhhbmRsZXIgZnVuY3Rpb24gdGhhdCBsb29rcyB1cCB0aGUgbWV0aG9kXG4gICAgICAgKiBuYW1lIGF0IGhhbmRsaW5nIHRpbWUuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtOb2RlfSBub2RlIE5vZGUgdG8gYWRkIGxpc3RlbmVyIG9uXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIE5hbWUgb2YgZXZlbnRcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2ROYW1lIE5hbWUgb2YgbWV0aG9kXG4gICAgICAgKiBAcGFyYW0geyo9fSBjb250ZXh0IENvbnRleHQgdGhlIG1ldGhvZCB3aWxsIGJlIGNhbGxlZCBvbiAoZGVmYXVsdHNcbiAgICAgICAqICAgdG8gYG5vZGVgKVxuICAgICAgICogQHJldHVybiB7RnVuY3Rpb259IEdlbmVyYXRlZCBoYW5kbGVyIGZ1bmN0aW9uXG4gICAgICAgKi9cbiAgICAgIF9hZGRNZXRob2RFdmVudExpc3RlbmVyVG9Ob2RlKG5vZGUsIGV2ZW50TmFtZSwgbWV0aG9kTmFtZSwgY29udGV4dCkge1xuICAgICAgICBjb250ZXh0ID0gY29udGV4dCB8fCBub2RlO1xuICAgICAgICBsZXQgaGFuZGxlciA9IGNyZWF0ZU5vZGVFdmVudEhhbmRsZXIoY29udGV4dCwgZXZlbnROYW1lLCBtZXRob2ROYW1lKTtcbiAgICAgICAgdGhpcy5fYWRkRXZlbnRMaXN0ZW5lclRvTm9kZShub2RlLCBldmVudE5hbWUsIGhhbmRsZXIpO1xuICAgICAgICByZXR1cm4gaGFuZGxlcjtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBPdmVycmlkZSBwb2ludCBmb3IgYWRkaW5nIGN1c3RvbSBvciBzaW11bGF0ZWQgZXZlbnQgaGFuZGxpbmcuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtOb2RlfSBub2RlIE5vZGUgdG8gYWRkIGV2ZW50IGxpc3RlbmVyIHRvXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIE5hbWUgb2YgZXZlbnRcbiAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIgTGlzdGVuZXIgZnVuY3Rpb24gdG8gYWRkXG4gICAgICAgKi9cbiAgICAgIF9hZGRFdmVudExpc3RlbmVyVG9Ob2RlKG5vZGUsIGV2ZW50TmFtZSwgaGFuZGxlcikge1xuICAgICAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBoYW5kbGVyKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBPdmVycmlkZSBwb2ludCBmb3IgYWRkaW5nIGN1c3RvbSBvciBzaW11bGF0ZWQgZXZlbnQgaGFuZGxpbmcuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtOb2RlfSBub2RlIE5vZGUgdG8gcmVtb3ZlIGV2ZW50IGxpc3RlbmVyIGZyb21cbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgTmFtZSBvZiBldmVudFxuICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciBMaXN0ZW5lciBmdW5jdGlvbiB0byByZW1vdmVcbiAgICAgICAqL1xuICAgICAgX3JlbW92ZUV2ZW50TGlzdGVuZXJGcm9tTm9kZShub2RlLCBldmVudE5hbWUsIGhhbmRsZXIpIHtcbiAgICAgICAgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgaGFuZGxlcik7XG4gICAgICB9XG5cbiAgICB9XG5cbiAgICByZXR1cm4gVGVtcGxhdGVTdGFtcDtcblxuICB9KTtcblxufSkoKTtcbjwvc2NyaXB0PlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi9taXhpbnMvdGVtcGxhdGUtc3RhbXAuaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTUgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cblxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uLy4uL3BvbHltZXIvcG9seW1lci5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vLi4vaXJvbi1mbGV4LWxheW91dC9pcm9uLWZsZXgtbGF5b3V0Lmh0bWxcIj5cblxuPCEtLVxuYXBwLWRyYXdlciBpcyBhIG5hdmlnYXRpb24gZHJhd2VyIHRoYXQgY2FuIHNsaWRlIGluIGZyb20gdGhlIGxlZnQgb3IgcmlnaHQuXG5cbkV4YW1wbGU6XG5cbkFsaWduIHRoZSBkcmF3ZXIgYXQgdGhlIHN0YXJ0LCB3aGljaCBpcyBsZWZ0IGluIExUUiBsYXlvdXRzIChkZWZhdWx0KTpcblxuYGBgaHRtbFxuPGFwcC1kcmF3ZXIgb3BlbmVkPjwvYXBwLWRyYXdlcj5cbmBgYFxuXG5BbGlnbiB0aGUgZHJhd2VyIGF0IHRoZSBlbmQ6XG5cbmBgYGh0bWxcbjxhcHAtZHJhd2VyIGFsaWduPVwiZW5kXCIgb3BlbmVkPjwvYXBwLWRyYXdlcj5cbmBgYFxuXG5UbyBtYWtlIHRoZSBjb250ZW50cyBvZiB0aGUgZHJhd2VyIHNjcm9sbGFibGUsIGNyZWF0ZSBhIHdyYXBwZXIgZm9yIHRoZSBzY3JvbGxcbmNvbnRlbnQsIGFuZCBhcHBseSBoZWlnaHQgYW5kIG92ZXJmbG93IHN0eWxlcyB0byBpdC5cblxuYGBgaHRtbFxuPGFwcC1kcmF3ZXI+XG4gIDxkaXYgc3R5bGU9XCJoZWlnaHQ6IDEwMCU7IG92ZXJmbG93OiBhdXRvO1wiPjwvZGl2PlxuPC9hcHAtZHJhd2VyPlxuYGBgXG5cbiMjIyBTdHlsaW5nXG5cbkN1c3RvbSBwcm9wZXJ0eSAgICAgICAgICAgICAgICAgIHwgRGVzY3JpcHRpb24gICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBEZWZhdWx0XG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tLS0tLS0tLVxuYC0tYXBwLWRyYXdlci13aWR0aGAgICAgICAgICAgICAgfCBXaWR0aCBvZiB0aGUgZHJhd2VyICAgICAgICAgICAgICAgICAgICB8IDI1NnB4XG5gLS1hcHAtZHJhd2VyLWNvbnRlbnQtY29udGFpbmVyYCB8IE1peGluIGZvciB0aGUgZHJhd2VyIGNvbnRlbnQgY29udGFpbmVyIHwge31cbmAtLWFwcC1kcmF3ZXItc2NyaW0tYmFja2dyb3VuZGAgIHwgQmFja2dyb3VuZCBmb3IgdGhlIHNjcmltICAgICAgICAgICAgICAgfCByZ2JhKDAsIDAsIDAsIDAuNSlcblxuKipOT1RFOioqIElmIHlvdSB1c2UgPGFwcC1kcmF3ZXI+IHdpdGggPGFwcC1kcmF3ZXItbGF5b3V0PiBhbmQgc3BlY2lmeSBhIHZhbHVlIGZvclxuYC0tYXBwLWRyYXdlci13aWR0aGAsIHRoYXQgdmFsdWUgbXVzdCBiZSBhY2Nlc3NpYmxlIGJ5IGJvdGggZWxlbWVudHMuIFRoaXMgY2FuIGJlIGRvbmUgYnlcbmRlZmluaW5nIHRoZSB2YWx1ZSBvbiB0aGUgYDpob3N0YCB0aGF0IGNvbnRhaW5zIDxhcHAtZHJhd2VyLWxheW91dD4gKG9yIGBodG1sYCBpZiBvdXRzaWRlXG5hIHNoYWRvdyByb290KTpcblxuYGBgY3NzXG46aG9zdCB7XG4gIC0tYXBwLWRyYXdlci13aWR0aDogMzAwcHg7XG59XG5gYGBcblxuQGdyb3VwIEFwcCBFbGVtZW50c1xuQGVsZW1lbnQgYXBwLWRyYXdlclxuQGRlbW8gYXBwLWRyYXdlci9kZW1vL2xlZnQtZHJhd2VyLmh0bWwgU2ltcGxlIExlZnQgRHJhd2VyXG5AZGVtbyBhcHAtZHJhd2VyL2RlbW8vcmlnaHQtZHJhd2VyLmh0bWwgUmlnaHQgRHJhd2VyIHdpdGggSWNvbnNcbi0tPlxuXG48ZG9tLW1vZHVsZSBpZD1cImFwcC1kcmF3ZXJcIj5cbiAgPHRlbXBsYXRlPlxuICAgIDxzdHlsZT5cbiAgICAgIDpob3N0IHtcbiAgICAgICAgcG9zaXRpb246IGZpeGVkO1xuICAgICAgICB0b3A6IC0xMjBweDtcbiAgICAgICAgcmlnaHQ6IDA7XG4gICAgICAgIGJvdHRvbTogLTEyMHB4O1xuICAgICAgICBsZWZ0OiAwO1xuXG4gICAgICAgIHZpc2liaWxpdHk6IGhpZGRlbjtcblxuICAgICAgICB0cmFuc2l0aW9uLXByb3BlcnR5OiB2aXNpYmlsaXR5O1xuICAgICAgfVxuXG4gICAgICA6aG9zdChbb3BlbmVkXSkge1xuICAgICAgICB2aXNpYmlsaXR5OiB2aXNpYmxlO1xuICAgICAgfVxuXG4gICAgICA6aG9zdChbcGVyc2lzdGVudF0pIHtcbiAgICAgICAgd2lkdGg6IHZhcigtLWFwcC1kcmF3ZXItd2lkdGgsIDI1NnB4KTtcbiAgICAgIH1cblxuICAgICAgOmhvc3QoW3BlcnNpc3RlbnRdW3Bvc2l0aW9uPWxlZnRdKSB7XG4gICAgICAgIHJpZ2h0OiBhdXRvO1xuICAgICAgfVxuXG4gICAgICA6aG9zdChbcGVyc2lzdGVudF1bcG9zaXRpb249cmlnaHRdKSB7XG4gICAgICAgIGxlZnQ6IGF1dG87XG4gICAgICB9XG5cbiAgICAgICNjb250ZW50Q29udGFpbmVyIHtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICB0b3A6IDA7XG4gICAgICAgIGJvdHRvbTogMDtcbiAgICAgICAgbGVmdDogMDtcblxuICAgICAgICB3aWR0aDogdmFyKC0tYXBwLWRyYXdlci13aWR0aCwgMjU2cHgpO1xuICAgICAgICBwYWRkaW5nOiAxMjBweCAwO1xuXG4gICAgICAgIHRyYW5zaXRpb24tcHJvcGVydHk6IC13ZWJraXQtdHJhbnNmb3JtO1xuICAgICAgICB0cmFuc2l0aW9uLXByb3BlcnR5OiB0cmFuc2Zvcm07XG4gICAgICAgIC13ZWJraXQtdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgtMTAwJSwgMCwgMCk7XG4gICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoLTEwMCUsIDAsIDApO1xuXG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6ICNGRkY7XG5cbiAgICAgICAgQGFwcGx5IC0tYXBwLWRyYXdlci1jb250ZW50LWNvbnRhaW5lcjtcbiAgICAgIH1cblxuICAgICAgI2NvbnRlbnRDb250YWluZXJbcGVyc2lzdGVudF0ge1xuICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgIH1cblxuICAgICAgI2NvbnRlbnRDb250YWluZXJbcG9zaXRpb249cmlnaHRdIHtcbiAgICAgICAgcmlnaHQ6IDA7XG4gICAgICAgIGxlZnQ6IGF1dG87XG5cbiAgICAgICAgLXdlYmtpdC10cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKDEwMCUsIDAsIDApO1xuICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKDEwMCUsIDAsIDApO1xuICAgICAgfVxuXG4gICAgICAjY29udGVudENvbnRhaW5lcltzd2lwZS1vcGVuXTo6YWZ0ZXIge1xuICAgICAgICBwb3NpdGlvbjogZml4ZWQ7XG4gICAgICAgIHRvcDogMDtcbiAgICAgICAgYm90dG9tOiAwO1xuICAgICAgICBsZWZ0OiAxMDAlO1xuXG4gICAgICAgIHZpc2liaWxpdHk6IHZpc2libGU7XG5cbiAgICAgICAgd2lkdGg6IDIwcHg7XG5cbiAgICAgICAgY29udGVudDogJyc7XG4gICAgICB9XG5cbiAgICAgICNjb250ZW50Q29udGFpbmVyW3N3aXBlLW9wZW5dW3Bvc2l0aW9uPXJpZ2h0XTo6YWZ0ZXIge1xuICAgICAgICByaWdodDogMTAwJTtcbiAgICAgICAgbGVmdDogYXV0bztcbiAgICAgIH1cblxuICAgICAgI2NvbnRlbnRDb250YWluZXJbb3BlbmVkXSB7XG4gICAgICAgIC13ZWJraXQtdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgwLCAwLCAwKTtcbiAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgwLCAwLCAwKTtcbiAgICAgIH1cblxuICAgICAgI3NjcmltIHtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICB0b3A6IDA7XG4gICAgICAgIHJpZ2h0OiAwO1xuICAgICAgICBib3R0b206IDA7XG4gICAgICAgIGxlZnQ6IDA7XG5cbiAgICAgICAgdHJhbnNpdGlvbi1wcm9wZXJ0eTogb3BhY2l0eTtcbiAgICAgICAgLXdlYmtpdC10cmFuc2Zvcm06IHRyYW5zbGF0ZVooMCk7XG4gICAgICAgIHRyYW5zZm9ybTogIHRyYW5zbGF0ZVooMCk7XG5cbiAgICAgICAgb3BhY2l0eTogMDtcbiAgICAgICAgYmFja2dyb3VuZDogdmFyKC0tYXBwLWRyYXdlci1zY3JpbS1iYWNrZ3JvdW5kLCByZ2JhKDAsIDAsIDAsIDAuNSkpO1xuICAgICAgfVxuXG4gICAgICAjc2NyaW0udmlzaWJsZSB7XG4gICAgICAgIG9wYWNpdHk6IDE7XG4gICAgICB9XG5cbiAgICAgIDpob3N0KFtuby10cmFuc2l0aW9uXSkgI2NvbnRlbnRDb250YWluZXIge1xuICAgICAgICB0cmFuc2l0aW9uLXByb3BlcnR5OiBub25lO1xuICAgICAgfVxuICAgIDwvc3R5bGU+XG5cbiAgICA8ZGl2IGlkPVwic2NyaW1cIiBvbi1jbGljaz1cImNsb3NlXCI+PC9kaXY+XG5cbiAgICA8IS0tIEhBQ0soa2VhbnVsZWUpOiBCaW5kIGF0dHJpYnV0ZXMgaGVyZSAoaW4gYWRkaXRpb24gdG8gOmhvc3QpIGZvciBzdHlsaW5nIHRvIHdvcmthcm91bmQgU2FmYXJpXG4gICAgYnVnLiBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTcwNzYyIC0tPlxuICAgIDxkaXYgaWQ9XCJjb250ZW50Q29udGFpbmVyXCIgb3BlbmVkJD1cIltbb3BlbmVkXV1cIiBwZXJzaXN0ZW50JD1cIltbcGVyc2lzdGVudF1dXCJcbiAgICAgICAgcG9zaXRpb24kPVwiW1twb3NpdGlvbl1dXCIgc3dpcGUtb3BlbiQ9XCJbW3N3aXBlT3Blbl1dXCI+XG4gICAgICA8c2xvdD48L3Nsb3Q+XG4gICAgPC9kaXY+XG4gIDwvdGVtcGxhdGU+XG5cbiAgPHNjcmlwdD5cblxuICAgIFBvbHltZXIoe1xuICAgICAgaXM6ICdhcHAtZHJhd2VyJyxcblxuICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG9wZW5lZCBzdGF0ZSBvZiB0aGUgZHJhd2VyLlxuICAgICAgICAgKi9cbiAgICAgICAgb3BlbmVkOiB7XG4gICAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgICB2YWx1ZTogZmFsc2UsXG4gICAgICAgICAgbm90aWZ5OiB0cnVlLFxuICAgICAgICAgIHJlZmxlY3RUb0F0dHJpYnV0ZTogdHJ1ZVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZHJhd2VyIGRvZXMgbm90IGhhdmUgYSBzY3JpbSBhbmQgY2Fubm90IGJlIHN3aXBlZCBjbG9zZS5cbiAgICAgICAgICovXG4gICAgICAgIHBlcnNpc3RlbnQ6IHtcbiAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgIHZhbHVlOiBmYWxzZSxcbiAgICAgICAgICByZWZsZWN0VG9BdHRyaWJ1dGU6IHRydWVcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHRyYW5zaXRpb24gZHVyYXRpb24gb2YgdGhlIGRyYXdlciBpbiBtaWxsaXNlY29uZHMuXG4gICAgICAgICAqL1xuICAgICAgICB0cmFuc2l0aW9uRHVyYXRpb246IHtcbiAgICAgICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICAgICAgdmFsdWU6IDIwMFxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYWxpZ25tZW50IG9mIHRoZSBkcmF3ZXIgb24gdGhlIHNjcmVlbiAoJ2xlZnQnLCAncmlnaHQnLCAnc3RhcnQnIG9yICdlbmQnKS5cbiAgICAgICAgICogJ3N0YXJ0JyBjb21wdXRlcyB0byBsZWZ0IGFuZCAnZW5kJyB0byByaWdodCBpbiBMVFIgbGF5b3V0IGFuZCB2aWNlIHZlcnNhIGluIFJUTFxuICAgICAgICAgKiBsYXlvdXQuXG4gICAgICAgICAqL1xuICAgICAgICBhbGlnbjoge1xuICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICB2YWx1ZTogJ2xlZnQnXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjb21wdXRlZCwgcmVhZC1vbmx5IHBvc2l0aW9uIG9mIHRoZSBkcmF3ZXIgb24gdGhlIHNjcmVlbiAoJ2xlZnQnIG9yICdyaWdodCcpLlxuICAgICAgICAgKi9cbiAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgcmVhZE9ubHk6IHRydWUsXG4gICAgICAgICAgcmVmbGVjdFRvQXR0cmlidXRlOiB0cnVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBhbiBhcmVhIGF0IHRoZSBlZGdlIG9mIHRoZSBzY3JlZW4gdG8gc3dpcGUgb3BlbiB0aGUgZHJhd2VyLlxuICAgICAgICAgKi9cbiAgICAgICAgc3dpcGVPcGVuOiB7XG4gICAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgICB2YWx1ZTogZmFsc2UsXG4gICAgICAgICAgcmVmbGVjdFRvQXR0cmlidXRlOiB0cnVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRyYXAga2V5Ym9hcmQgZm9jdXMgd2hlbiB0aGUgZHJhd2VyIGlzIG9wZW5lZCBhbmQgbm90IHBlcnNpc3RlbnQuXG4gICAgICAgICAqL1xuICAgICAgICBub0ZvY3VzVHJhcDoge1xuICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERpc2FibGVzIHN3aXBpbmcgb24gdGhlIGRyYXdlci5cbiAgICAgICAgICovXG4gICAgICAgIGRpc2FibGVTd2lwZToge1xuICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIG9ic2VydmVyczogW1xuICAgICAgICAncmVzZXRMYXlvdXQocG9zaXRpb24sIGlzQXR0YWNoZWQpJyxcbiAgICAgICAgJ19yZXNldFBvc2l0aW9uKGFsaWduLCBpc0F0dGFjaGVkKScsXG4gICAgICAgICdfc3R5bGVUcmFuc2l0aW9uRHVyYXRpb24odHJhbnNpdGlvbkR1cmF0aW9uKScsXG4gICAgICAgICdfb3BlbmVkUGVyc2lzdGVudENoYW5nZWQob3BlbmVkLCBwZXJzaXN0ZW50KSdcbiAgICAgIF0sXG5cbiAgICAgIF90cmFuc2xhdGVPZmZzZXQ6IDAsXG5cbiAgICAgIF90cmFja0RldGFpbHM6IG51bGwsXG5cbiAgICAgIF9kcmF3ZXJTdGF0ZTogMCxcblxuICAgICAgX2JvdW5kRXNjS2V5ZG93bkhhbmRsZXI6IG51bGwsXG5cbiAgICAgIF9maXJzdFRhYlN0b3A6IG51bGwsXG5cbiAgICAgIF9sYXN0VGFiU3RvcDogbnVsbCxcblxuICAgICAgYXR0YWNoZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBQb2x5bWVyLlJlbmRlclN0YXR1cy5hZnRlck5leHRSZW5kZXIodGhpcywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdGhpcy5fYm91bmRFc2NLZXlkb3duSGFuZGxlciA9IHRoaXMuX2VzY0tleWRvd25IYW5kbGVyLmJpbmQodGhpcyk7XG4gICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5fdGFiS2V5ZG93bkhhbmRsZXIuYmluZCh0aGlzKSlcblxuICAgICAgICAgIC8vIE9ubHkgbGlzdGVuIGZvciBob3Jpem9udGFsIHRyYWNrIHNvIHlvdSBjYW4gdmVydGljYWxseSBzY3JvbGwgaW5zaWRlIHRoZSBkcmF3ZXIuXG4gICAgICAgICAgdGhpcy5saXN0ZW4odGhpcywgJ3RyYWNrJywgJ190cmFjaycpO1xuICAgICAgICAgIHRoaXMuc2V0U2Nyb2xsRGlyZWN0aW9uKCd5Jyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuZmlyZSgnYXBwLXJlc2V0LWxheW91dCcpO1xuICAgICAgfSxcblxuICAgICAgZGV0YWNoZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5fYm91bmRFc2NLZXlkb3duSGFuZGxlcik7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIE9wZW5zIHRoZSBkcmF3ZXIuXG4gICAgICAgKi9cbiAgICAgIG9wZW46IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLm9wZW5lZCA9IHRydWU7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIENsb3NlcyB0aGUgZHJhd2VyLlxuICAgICAgICovXG4gICAgICBjbG9zZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMub3BlbmVkID0gZmFsc2U7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFRvZ2dsZXMgdGhlIGRyYXdlciBvcGVuIGFuZCBjbG9zZS5cbiAgICAgICAqL1xuICAgICAgdG9nZ2xlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5vcGVuZWQgPSAhdGhpcy5vcGVuZWQ7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIEdldHMgdGhlIHdpZHRoIG9mIHRoZSBkcmF3ZXIuXG4gICAgICAgKlxuICAgICAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgd2lkdGggb2YgdGhlIGRyYXdlciBpbiBwaXhlbHMuXG4gICAgICAgKi9cbiAgICAgIGdldFdpZHRoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NhdmVkV2lkdGggfHwgdGhpcy4kLmNvbnRlbnRDb250YWluZXIub2Zmc2V0V2lkdGg7XG4gICAgICB9LFxuXG4gICAgICBfaXNSVEw6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gd2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcykuZGlyZWN0aW9uID09PSAncnRsJztcbiAgICAgIH0sXG5cbiAgICAgIF9yZXNldFBvc2l0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLmFsaWduKSB7XG4gICAgICAgICAgY2FzZSAnc3RhcnQnOlxuICAgICAgICAgICAgdGhpcy5fc2V0UG9zaXRpb24odGhpcy5faXNSVEwoKSA/ICdyaWdodCcgOiAnbGVmdCcpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIGNhc2UgJ2VuZCc6XG4gICAgICAgICAgICB0aGlzLl9zZXRQb3NpdGlvbih0aGlzLl9pc1JUTCgpID8gJ2xlZnQnIDogJ3JpZ2h0Jyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2V0UG9zaXRpb24odGhpcy5hbGlnbik7XG4gICAgICB9LFxuXG4gICAgICBfZXNjS2V5ZG93bkhhbmRsZXI6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIHZhciBFU0NfS0VZQ09ERSA9IDI3O1xuICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PT0gRVNDX0tFWUNPREUpIHtcbiAgICAgICAgICAvLyBQcmV2ZW50IGFueSBzaWRlIGVmZmVjdHMgaWYgYXBwLWRyYXdlciBjbG9zZXMuXG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIF90cmFjazogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMucGVyc2lzdGVudCB8fCB0aGlzLmRpc2FibGVTd2lwZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERpc2FibGUgdXNlciBzZWxlY3Rpb24gb24gZGVza3RvcC5cbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICBzd2l0Y2ggKGV2ZW50LmRldGFpbC5zdGF0ZSkge1xuICAgICAgICAgIGNhc2UgJ3N0YXJ0JzpcbiAgICAgICAgICAgIHRoaXMuX3RyYWNrU3RhcnQoZXZlbnQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAndHJhY2snOlxuICAgICAgICAgICAgdGhpcy5fdHJhY2tNb3ZlKGV2ZW50KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2VuZCc6XG4gICAgICAgICAgICB0aGlzLl90cmFja0VuZChldmVudCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgX3RyYWNrU3RhcnQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuX2RyYXdlclN0YXRlID0gdGhpcy5fRFJBV0VSX1NUQVRFLlRSQUNLSU5HO1xuXG4gICAgICAgIHZhciByZWN0ID0gdGhpcy4kLmNvbnRlbnRDb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHRoaXMuX3NhdmVkV2lkdGggPSByZWN0LndpZHRoO1xuICAgICAgICBpZiAodGhpcy5wb3NpdGlvbiA9PT0gJ2xlZnQnKSB7XG4gICAgICAgICAgdGhpcy5fdHJhbnNsYXRlT2Zmc2V0ID0gcmVjdC5sZWZ0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX3RyYW5zbGF0ZU9mZnNldCA9IHJlY3QucmlnaHQgLSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3RyYWNrRGV0YWlscyA9IFtdO1xuXG4gICAgICAgIC8vIERpc2FibGUgdHJhbnNpdGlvbnMgc2luY2Ugc3R5bGUgYXR0cmlidXRlcyB3aWxsIHJlZmxlY3QgdXNlciB0cmFjayBldmVudHMuXG4gICAgICAgIHRoaXMuX3N0eWxlVHJhbnNpdGlvbkR1cmF0aW9uKDApO1xuICAgICAgICB0aGlzLnN0eWxlLnZpc2liaWxpdHkgPSAndmlzaWJsZSc7XG4gICAgICB9LFxuXG4gICAgICBfdHJhY2tNb3ZlOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICB0aGlzLl90cmFuc2xhdGVEcmF3ZXIoZXZlbnQuZGV0YWlsLmR4ICsgdGhpcy5fdHJhbnNsYXRlT2Zmc2V0KTtcblxuICAgICAgICAvLyBVc2UgRGF0ZS5ub3coKSBzaW5jZSBldmVudC50aW1lU3RhbXAgaXMgaW5jb25zaXN0ZW50IGFjcm9zcyBicm93c2VycyAoZS5nLiBtb3N0XG4gICAgICAgIC8vIGJyb3dzZXJzIHVzZSBtaWxsaXNlY29uZHMgYnV0IEZGIDQ0IHVzZXMgbWljcm9zZWNvbmRzKS5cbiAgICAgICAgdGhpcy5fdHJhY2tEZXRhaWxzLnB1c2goe1xuICAgICAgICAgIGR4OiBldmVudC5kZXRhaWwuZHgsXG4gICAgICAgICAgdGltZVN0YW1wOiBEYXRlLm5vdygpXG4gICAgICAgIH0pO1xuICAgICAgfSxcblxuICAgICAgX3RyYWNrRW5kOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICB2YXIgeCA9IGV2ZW50LmRldGFpbC5keCArIHRoaXMuX3RyYW5zbGF0ZU9mZnNldDtcbiAgICAgICAgdmFyIGRyYXdlcldpZHRoID0gdGhpcy5nZXRXaWR0aCgpO1xuICAgICAgICB2YXIgaXNQb3NpdGlvbkxlZnQgPSB0aGlzLnBvc2l0aW9uID09PSAnbGVmdCc7XG4gICAgICAgIHZhciBpc0luRW5kU3RhdGUgPSBpc1Bvc2l0aW9uTGVmdCA/ICh4ID49IDAgfHwgeCA8PSAtZHJhd2VyV2lkdGgpIDpcbiAgICAgICAgICAoeCA8PSAwIHx8IHggPj0gZHJhd2VyV2lkdGgpO1xuXG4gICAgICAgIGlmICghaXNJbkVuZFN0YXRlKSB7XG4gICAgICAgICAgLy8gTm8gbG9uZ2VyIG5lZWQgdGhlIHRyYWNrIGV2ZW50cyBhZnRlciB0aGlzIG1ldGhvZCByZXR1cm5zIC0gYWxsb3cgdGhlbSB0byBiZSBHQydkLlxuICAgICAgICAgIHZhciB0cmFja0RldGFpbHMgPSB0aGlzLl90cmFja0RldGFpbHM7XG4gICAgICAgICAgdGhpcy5fdHJhY2tEZXRhaWxzID0gbnVsbDtcblxuICAgICAgICAgIHRoaXMuX2ZsaW5nRHJhd2VyKGV2ZW50LCB0cmFja0RldGFpbHMpO1xuICAgICAgICAgIGlmICh0aGlzLl9kcmF3ZXJTdGF0ZSA9PT0gdGhpcy5fRFJBV0VSX1NUQVRFLkZMSU5HSU5HKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgdGhlIGRyYXdlciBpcyBub3QgZmxpbmdpbmcsIHRvZ2dsZSB0aGUgb3BlbmVkIHN0YXRlIGJhc2VkIG9uIHRoZSBwb3NpdGlvbiBvZlxuICAgICAgICAvLyB0aGUgZHJhd2VyLlxuICAgICAgICB2YXIgaGFsZldpZHRoID0gZHJhd2VyV2lkdGggLyAyO1xuICAgICAgICBpZiAoZXZlbnQuZGV0YWlsLmR4IDwgLWhhbGZXaWR0aCkge1xuICAgICAgICAgIHRoaXMub3BlbmVkID0gdGhpcy5wb3NpdGlvbiA9PT0gJ3JpZ2h0JztcbiAgICAgICAgfSBlbHNlIGlmIChldmVudC5kZXRhaWwuZHggPiBoYWxmV2lkdGgpIHtcbiAgICAgICAgICB0aGlzLm9wZW5lZCA9IHRoaXMucG9zaXRpb24gPT09ICdsZWZ0JztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0luRW5kU3RhdGUpIHtcbiAgICAgICAgICB0aGlzLmRlYm91bmNlKCdfcmVzZXREcmF3ZXJTdGF0ZScsIHRoaXMuX3Jlc2V0RHJhd2VyU3RhdGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZGVib3VuY2UoJ19yZXNldERyYXdlclN0YXRlJywgdGhpcy5fcmVzZXREcmF3ZXJTdGF0ZSwgdGhpcy50cmFuc2l0aW9uRHVyYXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fc3R5bGVUcmFuc2l0aW9uRHVyYXRpb24odGhpcy50cmFuc2l0aW9uRHVyYXRpb24pO1xuICAgICAgICB0aGlzLl9yZXNldERyYXdlclRyYW5zbGF0ZSgpO1xuICAgICAgICB0aGlzLnN0eWxlLnZpc2liaWxpdHkgPSAnJztcbiAgICAgIH0sXG5cbiAgICAgIF9jYWxjdWxhdGVWZWxvY2l0eTogZnVuY3Rpb24oZXZlbnQsIHRyYWNrRGV0YWlscykge1xuICAgICAgICAvLyBGaW5kIHRoZSBvbGRlc3QgdHJhY2sgZXZlbnQgdGhhdCBpcyB3aXRoaW4gMTAwbXMgdXNpbmcgYmluYXJ5IHNlYXJjaC5cbiAgICAgICAgdmFyIG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgIHZhciB0aW1lTG93ZXJCb3VuZCA9IG5vdyAtIDEwMDtcbiAgICAgICAgdmFyIHRyYWNrRGV0YWlsO1xuICAgICAgICB2YXIgbWluID0gMDtcbiAgICAgICAgdmFyIG1heCA9IHRyYWNrRGV0YWlscy5sZW5ndGggLSAxO1xuXG4gICAgICAgIHdoaWxlIChtaW4gPD0gbWF4KSB7XG4gICAgICAgICAgLy8gRmxvb3Igb2YgYXZlcmFnZSBvZiBtaW4gYW5kIG1heC5cbiAgICAgICAgICB2YXIgbWlkID0gKG1pbiArIG1heCkgPj4gMTtcbiAgICAgICAgICB2YXIgZCA9IHRyYWNrRGV0YWlsc1ttaWRdO1xuICAgICAgICAgIGlmIChkLnRpbWVTdGFtcCA+PSB0aW1lTG93ZXJCb3VuZCkge1xuICAgICAgICAgICAgdHJhY2tEZXRhaWwgPSBkO1xuICAgICAgICAgICAgbWF4ID0gbWlkIC0gMTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWluID0gbWlkICsgMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHJhY2tEZXRhaWwpIHtcbiAgICAgICAgICB2YXIgZHggPSBldmVudC5kZXRhaWwuZHggLSB0cmFja0RldGFpbC5keDtcbiAgICAgICAgICB2YXIgZHQgPSAobm93IC0gdHJhY2tEZXRhaWwudGltZVN0YW1wKSB8fCAxO1xuICAgICAgICAgIHJldHVybiBkeCAvIGR0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfSxcblxuICAgICAgX2ZsaW5nRHJhd2VyOiBmdW5jdGlvbihldmVudCwgdHJhY2tEZXRhaWxzKSB7XG4gICAgICAgIHZhciB2ZWxvY2l0eSA9IHRoaXMuX2NhbGN1bGF0ZVZlbG9jaXR5KGV2ZW50LCB0cmFja0RldGFpbHMpO1xuXG4gICAgICAgIC8vIERvIG5vdCBmbGluZyBpZiB2ZWxvY2l0eSBpcyBub3QgYWJvdmUgYSB0aHJlc2hvbGQuXG4gICAgICAgIGlmIChNYXRoLmFicyh2ZWxvY2l0eSkgPCB0aGlzLl9NSU5fRkxJTkdfVEhSRVNIT0xEKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZHJhd2VyU3RhdGUgPSB0aGlzLl9EUkFXRVJfU1RBVEUuRkxJTkdJTkc7XG5cbiAgICAgICAgdmFyIHggPSBldmVudC5kZXRhaWwuZHggKyB0aGlzLl90cmFuc2xhdGVPZmZzZXQ7XG4gICAgICAgIHZhciBkcmF3ZXJXaWR0aCA9IHRoaXMuZ2V0V2lkdGgoKTtcbiAgICAgICAgdmFyIGlzUG9zaXRpb25MZWZ0ID0gdGhpcy5wb3NpdGlvbiA9PT0gJ2xlZnQnO1xuICAgICAgICB2YXIgaXNWZWxvY2l0eVBvc2l0aXZlID0gdmVsb2NpdHkgPiAwO1xuICAgICAgICB2YXIgaXNDbG9zaW5nTGVmdCA9ICFpc1ZlbG9jaXR5UG9zaXRpdmUgJiYgaXNQb3NpdGlvbkxlZnQ7XG4gICAgICAgIHZhciBpc0Nsb3NpbmdSaWdodCA9IGlzVmVsb2NpdHlQb3NpdGl2ZSAmJiAhaXNQb3NpdGlvbkxlZnQ7XG4gICAgICAgIHZhciBkeDtcbiAgICAgICAgaWYgKGlzQ2xvc2luZ0xlZnQpIHtcbiAgICAgICAgICBkeCA9IC0oeCArIGRyYXdlcldpZHRoKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0Nsb3NpbmdSaWdodCkge1xuICAgICAgICAgIGR4ID0gKGRyYXdlcldpZHRoIC0geCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZHggPSAteDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEVuZm9yY2UgYSBtaW5pbXVtIHRyYW5zaXRpb24gdmVsb2NpdHkgdG8gbWFrZSB0aGUgZHJhd2VyIGZlZWwgc25hcHB5LlxuICAgICAgICBpZiAoaXNWZWxvY2l0eVBvc2l0aXZlKSB7XG4gICAgICAgICAgdmVsb2NpdHkgPSBNYXRoLm1heCh2ZWxvY2l0eSwgdGhpcy5fTUlOX1RSQU5TSVRJT05fVkVMT0NJVFkpO1xuICAgICAgICAgIHRoaXMub3BlbmVkID0gdGhpcy5wb3NpdGlvbiA9PT0gJ2xlZnQnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZlbG9jaXR5ID0gTWF0aC5taW4odmVsb2NpdHksIC10aGlzLl9NSU5fVFJBTlNJVElPTl9WRUxPQ0lUWSk7XG4gICAgICAgICAgdGhpcy5vcGVuZWQgPSB0aGlzLnBvc2l0aW9uID09PSAncmlnaHQnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBhbW91bnQgb2YgdGltZSBuZWVkZWQgdG8gZmluaXNoIHRoZSB0cmFuc2l0aW9uIGJhc2VkIG9uIHRoZVxuICAgICAgICAvLyBpbml0aWFsIHNsb3BlIG9mIHRoZSB0aW1pbmcgZnVuY3Rpb24uXG4gICAgICAgIHZhciB0ID0gdGhpcy5fRkxJTkdfSU5JVElBTF9TTE9QRSAqIGR4IC8gdmVsb2NpdHlcbiAgICAgICAgdGhpcy5fc3R5bGVUcmFuc2l0aW9uRHVyYXRpb24odCk7XG4gICAgICAgIHRoaXMuX3N0eWxlVHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uKHRoaXMuX0ZMSU5HX1RJTUlOR19GVU5DVElPTik7XG5cbiAgICAgICAgdGhpcy5fcmVzZXREcmF3ZXJUcmFuc2xhdGUoKTtcbiAgICAgICAgdGhpcy5kZWJvdW5jZSgnX3Jlc2V0RHJhd2VyU3RhdGUnLCB0aGlzLl9yZXNldERyYXdlclN0YXRlLCB0KTtcbiAgICAgIH0sXG5cbiAgICAgIF9zdHlsZVRyYW5zaXRpb25EdXJhdGlvbjogZnVuY3Rpb24oZHVyYXRpb24pIHtcbiAgICAgICAgdGhpcy5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPSBkdXJhdGlvbiArICdtcyc7XG4gICAgICAgIHRoaXMuJC5jb250ZW50Q29udGFpbmVyLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9IGR1cmF0aW9uICsgJ21zJztcbiAgICAgICAgdGhpcy4kLnNjcmltLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9IGR1cmF0aW9uICsgJ21zJztcbiAgICAgIH0sXG5cbiAgICAgIF9zdHlsZVRyYW5zaXRpb25UaW1pbmdGdW5jdGlvbjogZnVuY3Rpb24odGltaW5nRnVuY3Rpb24pIHtcbiAgICAgICAgdGhpcy4kLmNvbnRlbnRDb250YWluZXIuc3R5bGUudHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uID0gdGltaW5nRnVuY3Rpb247XG4gICAgICAgIHRoaXMuJC5zY3JpbS5zdHlsZS50cmFuc2l0aW9uVGltaW5nRnVuY3Rpb24gPSB0aW1pbmdGdW5jdGlvbjtcbiAgICAgIH0sXG5cbiAgICAgIF90cmFuc2xhdGVEcmF3ZXI6IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgdmFyIGRyYXdlcldpZHRoID0gdGhpcy5nZXRXaWR0aCgpO1xuXG4gICAgICAgIGlmICh0aGlzLnBvc2l0aW9uID09PSAnbGVmdCcpIHtcbiAgICAgICAgICB4ID0gTWF0aC5tYXgoLWRyYXdlcldpZHRoLCBNYXRoLm1pbih4LCAwKSk7XG4gICAgICAgICAgdGhpcy4kLnNjcmltLnN0eWxlLm9wYWNpdHkgPSAxICsgeCAvIGRyYXdlcldpZHRoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHggPSBNYXRoLm1heCgwLCBNYXRoLm1pbih4LCBkcmF3ZXJXaWR0aCkpO1xuICAgICAgICAgIHRoaXMuJC5zY3JpbS5zdHlsZS5vcGFjaXR5ID0gMSAtIHggLyBkcmF3ZXJXaWR0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudHJhbnNsYXRlM2QoeCArICdweCcsICcwJywgJzAnLCB0aGlzLiQuY29udGVudENvbnRhaW5lcik7XG4gICAgICB9LFxuXG4gICAgICBfcmVzZXREcmF3ZXJUcmFuc2xhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLiQuc2NyaW0uc3R5bGUub3BhY2l0eSA9ICcnO1xuICAgICAgICB0aGlzLnRyYW5zZm9ybSgnJywgdGhpcy4kLmNvbnRlbnRDb250YWluZXIpO1xuICAgICAgfSxcblxuICAgICAgX3Jlc2V0RHJhd2VyU3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgb2xkU3RhdGUgPSB0aGlzLl9kcmF3ZXJTdGF0ZTtcblxuICAgICAgICAvLyBJZiB0aGUgZHJhd2VyIHdhcyBmbGluZ2luZywgd2UgbmVlZCB0byByZXNldCB0aGUgc3R5bGUgYXR0cmlidXRlcy5cbiAgICAgICAgaWYgKG9sZFN0YXRlID09PSB0aGlzLl9EUkFXRVJfU1RBVEUuRkxJTkdJTkcpIHtcbiAgICAgICAgICB0aGlzLl9zdHlsZVRyYW5zaXRpb25EdXJhdGlvbih0aGlzLnRyYW5zaXRpb25EdXJhdGlvbik7XG4gICAgICAgICAgdGhpcy5fc3R5bGVUcmFuc2l0aW9uVGltaW5nRnVuY3Rpb24oJycpO1xuICAgICAgICAgIHRoaXMuc3R5bGUudmlzaWJpbGl0eSA9ICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fc2F2ZWRXaWR0aCA9IG51bGw7XG5cbiAgICAgICAgaWYgKHRoaXMub3BlbmVkKSB7XG4gICAgICAgICAgdGhpcy5fZHJhd2VyU3RhdGUgPSB0aGlzLnBlcnNpc3RlbnQgP1xuICAgICAgICAgICAgdGhpcy5fRFJBV0VSX1NUQVRFLk9QRU5FRF9QRVJTSVNURU5UIDogdGhpcy5fRFJBV0VSX1NUQVRFLk9QRU5FRDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9kcmF3ZXJTdGF0ZSA9IHRoaXMuX0RSQVdFUl9TVEFURS5DTE9TRUQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob2xkU3RhdGUgIT09IHRoaXMuX2RyYXdlclN0YXRlKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX2RyYXdlclN0YXRlID09PSB0aGlzLl9EUkFXRVJfU1RBVEUuT1BFTkVEKSB7XG4gICAgICAgICAgICB0aGlzLl9zZXRLZXlib2FyZEZvY3VzVHJhcCgpO1xuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuX2JvdW5kRXNjS2V5ZG93bkhhbmRsZXIpO1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5fYm91bmRFc2NLZXlkb3duSGFuZGxlcik7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LnN0eWxlLm92ZXJmbG93ID0gJyc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gRG9uJ3QgZmlyZSB0aGUgZXZlbnQgb24gaW5pdGlhbCBsb2FkLlxuICAgICAgICAgIGlmIChvbGRTdGF0ZSAhPT0gdGhpcy5fRFJBV0VSX1NUQVRFLklOSVQpIHtcbiAgICAgICAgICAgIHRoaXMuZmlyZSgnYXBwLWRyYXdlci10cmFuc2l0aW9uZWQnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogUmVzZXRzIHRoZSBsYXlvdXQuXG4gICAgICAgKlxuICAgICAgICogQG1ldGhvZCByZXNldExheW91dFxuICAgICAgICovXG4gICAgICByZXNldExheW91dDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZmlyZSgnYXBwLXJlc2V0LWxheW91dCcpO1xuICAgICAgfSxcblxuICAgICAgX3NldEtleWJvYXJkRm9jdXNUcmFwOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMubm9Gb2N1c1RyYXApIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBOT1RFOiBVbmxlc3Mgd2UgdXNlIC9kZWVwLyAod2hpY2ggd2Ugc2hvdWxkbid0IHNpbmNlIGl0J3MgZGVwcmVjYXRlZCksIHRoaXMgd2lsbFxuICAgICAgICAvLyBub3Qgc2VsZWN0IGZvY3VzYWJsZSBlbGVtZW50cyBpbnNpZGUgc2hhZG93IHJvb3RzLlxuICAgICAgICB2YXIgZm9jdXNhYmxlRWxlbWVudHNTZWxlY3RvciA9IFtcbiAgICAgICAgICAgICdhW2hyZWZdOm5vdChbdGFiaW5kZXg9XCItMVwiXSknLFxuICAgICAgICAgICAgJ2FyZWFbaHJlZl06bm90KFt0YWJpbmRleD1cIi0xXCJdKScsXG4gICAgICAgICAgICAnaW5wdXQ6bm90KFtkaXNhYmxlZF0pOm5vdChbdGFiaW5kZXg9XCItMVwiXSknLFxuICAgICAgICAgICAgJ3NlbGVjdDpub3QoW2Rpc2FibGVkXSk6bm90KFt0YWJpbmRleD1cIi0xXCJdKScsXG4gICAgICAgICAgICAndGV4dGFyZWE6bm90KFtkaXNhYmxlZF0pOm5vdChbdGFiaW5kZXg9XCItMVwiXSknLFxuICAgICAgICAgICAgJ2J1dHRvbjpub3QoW2Rpc2FibGVkXSk6bm90KFt0YWJpbmRleD1cIi0xXCJdKScsXG4gICAgICAgICAgICAnaWZyYW1lOm5vdChbdGFiaW5kZXg9XCItMVwiXSknLFxuICAgICAgICAgICAgJ1t0YWJpbmRleF06bm90KFt0YWJpbmRleD1cIi0xXCJdKScsXG4gICAgICAgICAgICAnW2NvbnRlbnRFZGl0YWJsZT10cnVlXTpub3QoW3RhYmluZGV4PVwiLTFcIl0pJ1xuICAgICAgICAgIF0uam9pbignLCcpO1xuICAgICAgICB2YXIgZm9jdXNhYmxlRWxlbWVudHMgPSBQb2x5bWVyLmRvbSh0aGlzKS5xdWVyeVNlbGVjdG9yQWxsKGZvY3VzYWJsZUVsZW1lbnRzU2VsZWN0b3IpO1xuXG4gICAgICAgIGlmIChmb2N1c2FibGVFbGVtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdGhpcy5fZmlyc3RUYWJTdG9wID0gZm9jdXNhYmxlRWxlbWVudHNbMF07XG4gICAgICAgICAgdGhpcy5fbGFzdFRhYlN0b3AgPSBmb2N1c2FibGVFbGVtZW50c1tmb2N1c2FibGVFbGVtZW50cy5sZW5ndGggLSAxXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBSZXNldCBzYXZlZCB0YWIgc3RvcHMgd2hlbiB0aGVyZSBhcmUgbm8gZm9jdXNhYmxlIGVsZW1lbnRzIGluIHRoZSBkcmF3ZXIuXG4gICAgICAgICAgdGhpcy5fZmlyc3RUYWJTdG9wID0gbnVsbDtcbiAgICAgICAgICB0aGlzLl9sYXN0VGFiU3RvcCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGb2N1cyBvbiBhcHAtZHJhd2VyIGlmIGl0IGhhcyBub24temVybyB0YWJpbmRleC4gT3RoZXJ3aXNlLCBmb2N1cyB0aGUgZmlyc3QgZm9jdXNhYmxlXG4gICAgICAgIC8vIGVsZW1lbnQgaW4gdGhlIGRyYXdlciwgaWYgaXQgZXhpc3RzLiBVc2UgdGhlIHRhYmluZGV4IGF0dHJpYnV0ZSBzaW5jZSB0aGUgdGhpcy50YWJJbmRleFxuICAgICAgICAvLyBwcm9wZXJ0eSBpbiBJRS9FZGdlIHJldHVybnMgMCAoaW5zdGVhZCBvZiAtMSkgd2hlbiB0aGUgYXR0cmlidXRlIGlzIG5vdCBzZXQuXG4gICAgICAgIHZhciB0YWJpbmRleCA9IHRoaXMuZ2V0QXR0cmlidXRlKCd0YWJpbmRleCcpO1xuICAgICAgICBpZiAodGFiaW5kZXggJiYgcGFyc2VJbnQodGFiaW5kZXgsIDEwKSA+IC0xKSB7XG4gICAgICAgICAgdGhpcy5mb2N1cygpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2ZpcnN0VGFiU3RvcCkge1xuICAgICAgICAgIHRoaXMuX2ZpcnN0VGFiU3RvcC5mb2N1cygpO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBfdGFiS2V5ZG93bkhhbmRsZXI6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLm5vRm9jdXNUcmFwKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIFRBQl9LRVlDT0RFID0gOTtcbiAgICAgICAgaWYgKHRoaXMuX2RyYXdlclN0YXRlID09PSB0aGlzLl9EUkFXRVJfU1RBVEUuT1BFTkVEICYmIGV2ZW50LmtleUNvZGUgPT09IFRBQl9LRVlDT0RFKSB7XG4gICAgICAgICAgaWYgKGV2ZW50LnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fZmlyc3RUYWJTdG9wICYmIFBvbHltZXIuZG9tKGV2ZW50KS5sb2NhbFRhcmdldCA9PT0gdGhpcy5fZmlyc3RUYWJTdG9wKSB7XG4gICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgIHRoaXMuX2xhc3RUYWJTdG9wLmZvY3VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9sYXN0VGFiU3RvcCAmJiBQb2x5bWVyLmRvbShldmVudCkubG9jYWxUYXJnZXQgPT09IHRoaXMuX2xhc3RUYWJTdG9wKSB7XG4gICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgIHRoaXMuX2ZpcnN0VGFiU3RvcC5mb2N1cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgX29wZW5lZFBlcnNpc3RlbnRDaGFuZ2VkOiBmdW5jdGlvbihvcGVuZWQsIHBlcnNpc3RlbnQpIHtcbiAgICAgICAgdGhpcy50b2dnbGVDbGFzcygndmlzaWJsZScsIG9wZW5lZCAmJiAhcGVyc2lzdGVudCwgdGhpcy4kLnNjcmltKTtcblxuICAgICAgICAvLyBVc2UgYSBkZWJvdW5jZSB0aW1lciBpbnN0ZWFkIG9mIHRyYW5zaXRpb25lbmQgc2luY2UgdHJhbnNpdGlvbmVuZCB3b24ndCBmaXJlIHdoZW5cbiAgICAgICAgLy8gYXBwLWRyYXdlciBpcyBkaXNwbGF5OiBub25lLlxuICAgICAgICB0aGlzLmRlYm91bmNlKCdfcmVzZXREcmF3ZXJTdGF0ZScsIHRoaXMuX3Jlc2V0RHJhd2VyU3RhdGUsIHRoaXMudHJhbnNpdGlvbkR1cmF0aW9uKTtcbiAgICAgIH0sXG5cbiAgICAgIF9NSU5fRkxJTkdfVEhSRVNIT0xEOiAwLjIsXG5cbiAgICAgIF9NSU5fVFJBTlNJVElPTl9WRUxPQ0lUWTogMS4yLFxuXG4gICAgICBfRkxJTkdfVElNSU5HX0ZVTkNUSU9OOiAnY3ViaWMtYmV6aWVyKDAuNjY3LCAxLCAwLjY2NywgMSknLFxuXG4gICAgICBfRkxJTkdfSU5JVElBTF9TTE9QRTogMS41LFxuXG4gICAgICBfRFJBV0VSX1NUQVRFOiB7XG4gICAgICAgIElOSVQ6IDAsXG4gICAgICAgIE9QRU5FRDogMSxcbiAgICAgICAgT1BFTkVEX1BFUlNJU1RFTlQ6IDIsXG4gICAgICAgIENMT1NFRDogMyxcbiAgICAgICAgVFJBQ0tJTkc6IDQsXG4gICAgICAgIEZMSU5HSU5HOiA1XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogRmlyZWQgd2hlbiB0aGUgbGF5b3V0IG9mIGFwcC1kcmF3ZXIgaGFzIGNoYW5nZWQuXG4gICAgICAgKlxuICAgICAgICogQGV2ZW50IGFwcC1yZXNldC1sYXlvdXRcbiAgICAgICAqL1xuXG4gICAgICAvKipcbiAgICAgICAqIEZpcmVkIHdoZW4gYXBwLWRyYXdlciBoYXMgZmluaXNoZWQgdHJhbnNpdGlvbmluZy5cbiAgICAgICAqXG4gICAgICAgKiBAZXZlbnQgYXBwLWRyYXdlci10cmFuc2l0aW9uZWRcbiAgICAgICAqL1xuICAgIH0pO1xuICA8L3NjcmlwdD5cbjwvZG9tLW1vZHVsZT5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvYXBwLWxheW91dC9hcHAtZHJhd2VyL2FwcC1kcmF3ZXIuaHRtbCIsIlxucmVxdWlyZSgnLi9hcHBseS1zaGltLm1pbi5qcycpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9zaGFkeWNzcy9hcHBseS1zaGltLmh0bWwiLCIoZnVuY3Rpb24oKXsvKlxuXG5Db3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4qL1xuJ3VzZSBzdHJpY3QnO3ZhciBrPXt9O2Z1bmN0aW9uIG4oKXt0aGlzLmVuZD10aGlzLnN0YXJ0PTA7dGhpcy5ydWxlcz10aGlzLnBhcmVudD10aGlzLnByZXZpb3VzPW51bGw7dGhpcy5jc3NUZXh0PXRoaXMucGFyc2VkQ3NzVGV4dD1cIlwiO3RoaXMuYXRSdWxlPSExO3RoaXMudHlwZT0wO3RoaXMucGFyc2VkU2VsZWN0b3I9dGhpcy5zZWxlY3Rvcj10aGlzLmtleWZyYW1lc05hbWU9XCJcIn1cbmZ1bmN0aW9uIHAoYSl7YT1hLnJlcGxhY2UoYWEsXCJcIikucmVwbGFjZShiYSxcIlwiKTt2YXIgYj1xLGM9YSxkPW5ldyBuO2Quc3RhcnQ9MDtkLmVuZD1jLmxlbmd0aDtmb3IodmFyIGU9ZCxmPTAsaD1jLmxlbmd0aDtmPGg7ZisrKWlmKFwie1wiPT09Y1tmXSl7ZS5ydWxlc3x8KGUucnVsZXM9W10pO3ZhciBnPWUsbT1nLnJ1bGVzW2cucnVsZXMubGVuZ3RoLTFdfHxudWxsO2U9bmV3IG47ZS5zdGFydD1mKzE7ZS5wYXJlbnQ9ZztlLnByZXZpb3VzPW07Zy5ydWxlcy5wdXNoKGUpfWVsc2VcIn1cIj09PWNbZl0mJihlLmVuZD1mKzEsZT1lLnBhcmVudHx8ZCk7cmV0dXJuIGIoZCxhKX1cbmZ1bmN0aW9uIHEoYSxiKXt2YXIgYz1iLnN1YnN0cmluZyhhLnN0YXJ0LGEuZW5kLTEpO2EucGFyc2VkQ3NzVGV4dD1hLmNzc1RleHQ9Yy50cmltKCk7YS5wYXJlbnQmJihjPWIuc3Vic3RyaW5nKGEucHJldmlvdXM/YS5wcmV2aW91cy5lbmQ6YS5wYXJlbnQuc3RhcnQsYS5zdGFydC0xKSxjPWNhKGMpLGM9Yy5yZXBsYWNlKHIsXCIgXCIpLGM9Yy5zdWJzdHJpbmcoYy5sYXN0SW5kZXhPZihcIjtcIikrMSksYz1hLnBhcnNlZFNlbGVjdG9yPWEuc2VsZWN0b3I9Yy50cmltKCksYS5hdFJ1bGU9MD09PWMuaW5kZXhPZihcIkBcIiksYS5hdFJ1bGU/MD09PWMuaW5kZXhPZihcIkBtZWRpYVwiKT9hLnR5cGU9dDpjLm1hdGNoKGRhKSYmKGEudHlwZT11LGEua2V5ZnJhbWVzTmFtZT1hLnNlbGVjdG9yLnNwbGl0KHIpLnBvcCgpKTphLnR5cGU9MD09PWMuaW5kZXhPZihcIi0tXCIpP3Y6eCk7aWYoYz1hLnJ1bGVzKWZvcih2YXIgZD0wLGU9Yy5sZW5ndGgsZjtkPGUmJihmPWNbZF0pO2QrKylxKGYsYik7cmV0dXJuIGF9XG5mdW5jdGlvbiBjYShhKXtyZXR1cm4gYS5yZXBsYWNlKC9cXFxcKFswLTlhLWZdezEsNn0pXFxzL2dpLGZ1bmN0aW9uKGEsYyl7YT1jO2ZvcihjPTYtYS5sZW5ndGg7Yy0tOylhPVwiMFwiK2E7cmV0dXJuXCJcXFxcXCIrYX0pfVxuZnVuY3Rpb24geShhLGIsYyl7Yz12b2lkIDA9PT1jP1wiXCI6Yzt2YXIgZD1cIlwiO2lmKGEuY3NzVGV4dHx8YS5ydWxlcyl7dmFyIGU9YS5ydWxlcyxmO2lmKGY9ZSlmPWVbMF0sZj0hKGYmJmYuc2VsZWN0b3ImJjA9PT1mLnNlbGVjdG9yLmluZGV4T2YoXCItLVwiKSk7aWYoZil7Zj0wO2Zvcih2YXIgaD1lLmxlbmd0aCxnO2Y8aCYmKGc9ZVtmXSk7ZisrKWQ9eShnLGIsZCl9ZWxzZSBiP2I9YS5jc3NUZXh0OihiPWEuY3NzVGV4dCxiPWIucmVwbGFjZShlYSxcIlwiKS5yZXBsYWNlKGZhLFwiXCIpLGI9Yi5yZXBsYWNlKGhhLFwiXCIpLnJlcGxhY2UoaWEsXCJcIikpLChkPWIudHJpbSgpKSYmKGQ9XCIgIFwiK2QrXCJcXG5cIil9ZCYmKGEuc2VsZWN0b3ImJihjKz1hLnNlbGVjdG9yK1wiIHtcXG5cIiksYys9ZCxhLnNlbGVjdG9yJiYoYys9XCJ9XFxuXFxuXCIpKTtyZXR1cm4gY31cbnZhciB4PTEsdT03LHQ9NCx2PTFFMyxhYT0vXFwvXFwqW14qXSpcXCorKFteLypdW14qXSpcXCorKSpcXC8vZ2ltLGJhPS9AaW1wb3J0W147XSo7L2dpbSxlYT0vKD86XlteO1xcLVxcc31dKyk/LS1bXjt7fV0qPzpbXnt9O10qPyg/Ols7XFxuXXwkKS9naW0sZmE9Lyg/Ol5bXjtcXC1cXHN9XSspPy0tW147e31dKj86W157fTtdKj97W159XSo/fSg/Ols7XFxuXXwkKT8vZ2ltLGhhPS9AYXBwbHlcXHMqXFwoP1teKTtdKlxcKT9cXHMqKD86WztcXG5dfCQpPy9naW0saWE9L1teOzpdKj86W147XSo/dmFyXFwoW147XSpcXCkoPzpbO1xcbl18JCk/L2dpbSxkYT0vXkBbXlxcc10qa2V5ZnJhbWVzLyxyPS9cXHMrL2c7dmFyIGphPVByb21pc2UucmVzb2x2ZSgpO2Z1bmN0aW9uIGthKGEpe2lmKGE9a1thXSlhLl9hcHBseVNoaW1DdXJyZW50VmVyc2lvbj1hLl9hcHBseVNoaW1DdXJyZW50VmVyc2lvbnx8MCxhLl9hcHBseVNoaW1WYWxpZGF0aW5nVmVyc2lvbj1hLl9hcHBseVNoaW1WYWxpZGF0aW5nVmVyc2lvbnx8MCxhLl9hcHBseVNoaW1OZXh0VmVyc2lvbj0oYS5fYXBwbHlTaGltTmV4dFZlcnNpb258fDApKzF9ZnVuY3Rpb24geihhKXtyZXR1cm4gYS5fYXBwbHlTaGltQ3VycmVudFZlcnNpb249PT1hLl9hcHBseVNoaW1OZXh0VmVyc2lvbn1mdW5jdGlvbiBsYShhKXthLl9hcHBseVNoaW1WYWxpZGF0aW5nVmVyc2lvbj1hLl9hcHBseVNoaW1OZXh0VmVyc2lvbjthLmF8fChhLmE9ITAsamEudGhlbihmdW5jdGlvbigpe2EuX2FwcGx5U2hpbUN1cnJlbnRWZXJzaW9uPWEuX2FwcGx5U2hpbU5leHRWZXJzaW9uO2EuYT0hMX0pKX07dmFyIEE9ISh3aW5kb3cuU2hhZHlET00mJndpbmRvdy5TaGFkeURPTS5pblVzZSksQjtmdW5jdGlvbiBDKGEpe0I9YSYmYS5zaGltY3NzcHJvcGVydGllcz8hMTpBfHwhKG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL0FwcGxlV2ViS2l0XFwvNjAxfEVkZ2VcXC8xNS8pfHwhd2luZG93LkNTU3x8IUNTUy5zdXBwb3J0c3x8IUNTUy5zdXBwb3J0cyhcImJveC1zaGFkb3dcIixcIjAgMCAwIHZhcigtLWZvbylcIikpfXdpbmRvdy5TaGFkeUNTUyYmdm9pZCAwIT09d2luZG93LlNoYWR5Q1NTLm5hdGl2ZUNzcz9CPXdpbmRvdy5TaGFkeUNTUy5uYXRpdmVDc3M6d2luZG93LlNoYWR5Q1NTPyhDKHdpbmRvdy5TaGFkeUNTUyksd2luZG93LlNoYWR5Q1NTPXZvaWQgMCk6Qyh3aW5kb3cuV2ViQ29tcG9uZW50cyYmd2luZG93LldlYkNvbXBvbmVudHMuZmxhZ3MpO3ZhciBFPUI7dmFyIEY9Lyg/Ol58WztcXHN7XVxccyopKC0tW1xcdy1dKj8pXFxzKjpcXHMqKD86KCg/OicoPzpcXFxcJ3wuKSo/J3xcIig/OlxcXFxcInwuKSo/XCJ8XFwoW14pXSo/XFwpfFtefTt7XSkrKXxcXHsoW159XSopXFx9KD86KD89WztcXHN9XSl8JCkpL2dpLEc9Lyg/Ol58XFxXKylAYXBwbHlcXHMqXFwoPyhbXik7XFxuXSopXFwpPy9naSxtYT0vQG1lZGlhXFxzKC4qKS87ZnVuY3Rpb24gSChhKXtpZighYSlyZXR1cm5cIlwiO1wic3RyaW5nXCI9PT10eXBlb2YgYSYmKGE9cChhKSk7cmV0dXJuIHkoYSxFKX1mdW5jdGlvbiBJKGEpeyFhLl9fY3NzUnVsZXMmJmEudGV4dENvbnRlbnQmJihhLl9fY3NzUnVsZXM9cChhLnRleHRDb250ZW50KSk7cmV0dXJuIGEuX19jc3NSdWxlc3x8bnVsbH1mdW5jdGlvbiBKKGEsYixjLGQpe2lmKGEpe3ZhciBlPSExLGY9YS50eXBlO2lmKGQmJmY9PT10KXt2YXIgaD1hLnNlbGVjdG9yLm1hdGNoKG1hKTtoJiYod2luZG93Lm1hdGNoTWVkaWEoaFsxXSkubWF0Y2hlc3x8KGU9ITApKX1mPT09eD9iKGEpOmMmJmY9PT11P2MoYSk6Zj09PXYmJihlPSEwKTtpZigoYT1hLnJ1bGVzKSYmIWUpe2U9MDtmPWEubGVuZ3RoO2Zvcih2YXIgZztlPGYmJihnPWFbZV0pO2UrKylKKGcsYixjLGQpfX19XG5mdW5jdGlvbiBLKGEsYil7dmFyIGM9YS5pbmRleE9mKFwidmFyKFwiKTtpZigtMT09PWMpcmV0dXJuIGIoYSxcIlwiLFwiXCIsXCJcIik7YTp7dmFyIGQ9MDt2YXIgZT1jKzM7Zm9yKHZhciBmPWEubGVuZ3RoO2U8ZjtlKyspaWYoXCIoXCI9PT1hW2VdKWQrKztlbHNlIGlmKFwiKVwiPT09YVtlXSYmMD09PS0tZClicmVhayBhO2U9LTF9ZD1hLnN1YnN0cmluZyhjKzQsZSk7Yz1hLnN1YnN0cmluZygwLGMpO2E9SyhhLnN1YnN0cmluZyhlKzEpLGIpO2U9ZC5pbmRleE9mKFwiLFwiKTtyZXR1cm4tMT09PWU/YihjLGQudHJpbSgpLFwiXCIsYSk6YihjLGQuc3Vic3RyaW5nKDAsZSkudHJpbSgpLGQuc3Vic3RyaW5nKGUrMSkudHJpbSgpLGEpfTt2YXIgbmE9LztcXHMqL20sb2E9L15cXHMqKGluaXRpYWwpfChpbmhlcml0KVxccyokLztmdW5jdGlvbiBMKCl7dGhpcy5hPXt9fUwucHJvdG90eXBlLnNldD1mdW5jdGlvbihhLGIpe2E9YS50cmltKCk7dGhpcy5hW2FdPXtoOmIsaTp7fX19O0wucHJvdG90eXBlLmdldD1mdW5jdGlvbihhKXthPWEudHJpbSgpO3JldHVybiB0aGlzLmFbYV18fG51bGx9O3ZhciBNPW51bGw7ZnVuY3Rpb24gTigpe3RoaXMuYj10aGlzLmM9bnVsbDt0aGlzLmE9bmV3IEx9Ti5wcm90b3R5cGUubz1mdW5jdGlvbihhKXthPUcudGVzdChhKXx8Ri50ZXN0KGEpO0cubGFzdEluZGV4PTA7Ri5sYXN0SW5kZXg9MDtyZXR1cm4gYX07Ti5wcm90b3R5cGUubT1mdW5jdGlvbihhLGIpe2E9YS5jb250ZW50LnF1ZXJ5U2VsZWN0b3IoXCJzdHlsZVwiKTt2YXIgYz1udWxsO2EmJihjPXRoaXMuaihhLGIpKTtyZXR1cm4gY307XG5OLnByb3RvdHlwZS5qPWZ1bmN0aW9uKGEsYil7Yj12b2lkIDA9PT1iP1wiXCI6Yjt2YXIgYz1JKGEpO3RoaXMubChjLGIpO2EudGV4dENvbnRlbnQ9SChjKTtyZXR1cm4gY307Ti5wcm90b3R5cGUuZj1mdW5jdGlvbihhKXt2YXIgYj10aGlzLGM9SShhKTtKKGMsZnVuY3Rpb24oYSl7XCI6cm9vdFwiPT09YS5zZWxlY3RvciYmKGEuc2VsZWN0b3I9XCJodG1sXCIpO2IuZyhhKX0pO2EudGV4dENvbnRlbnQ9SChjKTtyZXR1cm4gY307Ti5wcm90b3R5cGUubD1mdW5jdGlvbihhLGIpe3ZhciBjPXRoaXM7dGhpcy5jPWI7SihhLGZ1bmN0aW9uKGEpe2MuZyhhKX0pO3RoaXMuYz1udWxsfTtOLnByb3RvdHlwZS5nPWZ1bmN0aW9uKGEpe2EuY3NzVGV4dD1wYSh0aGlzLGEucGFyc2VkQ3NzVGV4dCk7XCI6cm9vdFwiPT09YS5zZWxlY3RvciYmKGEuc2VsZWN0b3I9XCI6aG9zdCA+ICpcIil9O1xuZnVuY3Rpb24gcGEoYSxiKXtiPWIucmVwbGFjZShGLGZ1bmN0aW9uKGIsZCxlLGYpe3JldHVybiBxYShhLGIsZCxlLGYpfSk7cmV0dXJuIE8oYSxiKX1mdW5jdGlvbiBPKGEsYil7Zm9yKHZhciBjO2M9Ry5leGVjKGIpOyl7dmFyIGQ9Y1swXSxlPWNbMV07Yz1jLmluZGV4O3ZhciBmPWIuc2xpY2UoMCxjK2QuaW5kZXhPZihcIkBhcHBseVwiKSk7Yj1iLnNsaWNlKGMrZC5sZW5ndGgpO3ZhciBoPVAoYSxmKTtkPXZvaWQgMDt2YXIgZz1hO2U9ZS5yZXBsYWNlKG5hLFwiXCIpO3ZhciBtPVtdO3ZhciBsPWcuYS5nZXQoZSk7bHx8KGcuYS5zZXQoZSx7fSksbD1nLmEuZ2V0KGUpKTtpZihsKWZvcihkIGluIGcuYyYmKGwuaVtnLmNdPSEwKSxsLmgpZz1oJiZoW2RdLGw9W2QsXCI6IHZhcihcIixlLFwiXy1fXCIsZF0sZyYmbC5wdXNoKFwiLFwiLGcpLGwucHVzaChcIilcIiksbS5wdXNoKGwuam9pbihcIlwiKSk7ZD1tLmpvaW4oXCI7IFwiKTtiPVwiXCIrZitkK2I7Ry5sYXN0SW5kZXg9YytkLmxlbmd0aH1yZXR1cm4gYn1cbmZ1bmN0aW9uIFAoYSxiKXtiPWIuc3BsaXQoXCI7XCIpO2Zvcih2YXIgYyxkLGU9e30sZj0wLGg7ZjxiLmxlbmd0aDtmKyspaWYoYz1iW2ZdKWlmKGg9Yy5zcGxpdChcIjpcIiksMTxoLmxlbmd0aCl7Yz1oWzBdLnRyaW0oKTt2YXIgZz1hO2Q9YztoPWguc2xpY2UoMSkuam9pbihcIjpcIik7dmFyIG09b2EuZXhlYyhoKTttJiYobVsxXT8oZy5ifHwoZy5iPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJtZXRhXCIpLGcuYi5zZXRBdHRyaWJ1dGUoXCJhcHBseS1zaGltLW1lYXN1cmVcIixcIlwiKSxnLmIuc3R5bGUuYWxsPVwiaW5pdGlhbFwiLGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoZy5iKSksZD13aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShnLmIpLmdldFByb3BlcnR5VmFsdWUoZCkpOmQ9XCJhcHBseS1zaGltLWluaGVyaXRcIixoPWQpO2Q9aDtlW2NdPWR9cmV0dXJuIGV9ZnVuY3Rpb24gcmEoYSxiKXtpZihNKWZvcih2YXIgYyBpbiBiLmkpYyE9PWEuYyYmTShjKX1cbmZ1bmN0aW9uIHFhKGEsYixjLGQsZSl7ZCYmSyhkLGZ1bmN0aW9uKGIsYyl7YyYmYS5hLmdldChjKSYmKGU9XCJAYXBwbHkgXCIrYytcIjtcIil9KTtpZighZSlyZXR1cm4gYjt2YXIgZj1PKGEsZSksaD1iLnNsaWNlKDAsYi5pbmRleE9mKFwiLS1cIikpLGc9Zj1QKGEsZiksbT1hLmEuZ2V0KGMpLGw9bSYmbS5oO2w/Zz1PYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUobCksZik6YS5hLnNldChjLGcpO3ZhciBYPVtdLHcsWT0hMTtmb3IodyBpbiBnKXt2YXIgRD1mW3ddO3ZvaWQgMD09PUQmJihEPVwiaW5pdGlhbFwiKTshbHx8dyBpbiBsfHwoWT0hMCk7WC5wdXNoKFwiXCIrYytcIl8tX1wiK3crXCI6IFwiK0QpfVkmJnJhKGEsbSk7bSYmKG0uaD1nKTtkJiYoaD1iK1wiO1wiK2gpO3JldHVyblwiXCIraCtYLmpvaW4oXCI7IFwiKStcIjtcIn1OLnByb3RvdHlwZS5kZXRlY3RNaXhpbj1OLnByb3RvdHlwZS5vO04ucHJvdG90eXBlLnRyYW5zZm9ybVN0eWxlPU4ucHJvdG90eXBlLmo7XG5OLnByb3RvdHlwZS50cmFuc2Zvcm1DdXN0b21TdHlsZT1OLnByb3RvdHlwZS5mO04ucHJvdG90eXBlLnRyYW5zZm9ybVJ1bGVzPU4ucHJvdG90eXBlLmw7Ti5wcm90b3R5cGUudHJhbnNmb3JtUnVsZT1OLnByb3RvdHlwZS5nO04ucHJvdG90eXBlLnRyYW5zZm9ybVRlbXBsYXRlPU4ucHJvdG90eXBlLm07Ti5wcm90b3R5cGUuX3NlcGFyYXRvcj1cIl8tX1wiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShOLnByb3RvdHlwZSxcImludmFsaWRDYWxsYmFja1wiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gTX0sc2V0OmZ1bmN0aW9uKGEpe009YX19KTt2YXIgUT1udWxsLFI9d2luZG93LkhUTUxJbXBvcnRzJiZ3aW5kb3cuSFRNTEltcG9ydHMud2hlblJlYWR5fHxudWxsLFM7ZnVuY3Rpb24gc2EoYSl7cmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCl7Uj9SKGEpOihRfHwoUT1uZXcgUHJvbWlzZShmdW5jdGlvbihhKXtTPWF9KSxcImNvbXBsZXRlXCI9PT1kb2N1bWVudC5yZWFkeVN0YXRlP1MoKTpkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwicmVhZHlzdGF0ZWNoYW5nZVwiLGZ1bmN0aW9uKCl7XCJjb21wbGV0ZVwiPT09ZG9jdW1lbnQucmVhZHlTdGF0ZSYmUygpfSkpLFEudGhlbihmdW5jdGlvbigpe2EmJmEoKX0pKX0pfTt2YXIgVD1uZXcgTjtmdW5jdGlvbiBVKCl7dmFyIGE9dGhpczt0aGlzLmE9bnVsbDtzYShmdW5jdGlvbigpe1YoYSl9KTtULmludmFsaWRDYWxsYmFjaz1rYX1mdW5jdGlvbiBWKGEpe2EuYXx8KGEuYT13aW5kb3cuU2hhZHlDU1MuQ3VzdG9tU3R5bGVJbnRlcmZhY2UsYS5hJiYoYS5hLnRyYW5zZm9ybUNhbGxiYWNrPWZ1bmN0aW9uKGEpe1QuZihhKX0sYS5hLnZhbGlkYXRlQ2FsbGJhY2s9ZnVuY3Rpb24oKXtyZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKXthLmEuZW5xdWV1ZWQmJlcoYSl9KX0pKX1VLnByb3RvdHlwZS5wcmVwYXJlVGVtcGxhdGU9ZnVuY3Rpb24oYSxiKXtWKHRoaXMpO2tbYl09YTtiPVQubShhLGIpO2EuX3N0eWxlQXN0PWJ9O1xuZnVuY3Rpb24gVyhhKXtWKGEpO2lmKGEuYSl7dmFyIGI9YS5hLnByb2Nlc3NTdHlsZXMoKTtpZihhLmEuZW5xdWV1ZWQpe2Zvcih2YXIgYz0wO2M8Yi5sZW5ndGg7YysrKXt2YXIgZD1hLmEuZ2V0U3R5bGVGb3JDdXN0b21TdHlsZShiW2NdKTtkJiZULmYoZCl9YS5hLmVucXVldWVkPSExfX19VS5wcm90b3R5cGUuc3R5bGVTdWJ0cmVlPWZ1bmN0aW9uKGEsYil7Vih0aGlzKTtpZihiKWZvcih2YXIgYyBpbiBiKW51bGw9PT1jP2Euc3R5bGUucmVtb3ZlUHJvcGVydHkoYyk6YS5zdHlsZS5zZXRQcm9wZXJ0eShjLGJbY10pO2lmKGEuc2hhZG93Um9vdClmb3IodGhpcy5zdHlsZUVsZW1lbnQoYSksYT1hLnNoYWRvd1Jvb3QuY2hpbGRyZW58fGEuc2hhZG93Um9vdC5jaGlsZE5vZGVzLGI9MDtiPGEubGVuZ3RoO2IrKyl0aGlzLnN0eWxlU3VidHJlZShhW2JdKTtlbHNlIGZvcihhPWEuY2hpbGRyZW58fGEuY2hpbGROb2RlcyxiPTA7YjxhLmxlbmd0aDtiKyspdGhpcy5zdHlsZVN1YnRyZWUoYVtiXSl9O1xuVS5wcm90b3R5cGUuc3R5bGVFbGVtZW50PWZ1bmN0aW9uKGEpe1YodGhpcyk7dmFyIGI9YS5sb2NhbE5hbWUsYztiPy0xPGIuaW5kZXhPZihcIi1cIik/Yz1iOmM9YS5nZXRBdHRyaWJ1dGUmJmEuZ2V0QXR0cmlidXRlKFwiaXNcIil8fFwiXCI6Yz1hLmlzO2lmKChiPWtbY10pJiYheihiKSl7aWYoeihiKXx8Yi5fYXBwbHlTaGltVmFsaWRhdGluZ1ZlcnNpb24hPT1iLl9hcHBseVNoaW1OZXh0VmVyc2lvbil0aGlzLnByZXBhcmVUZW1wbGF0ZShiLGMpLGxhKGIpO2lmKGE9YS5zaGFkb3dSb290KWlmKGE9YS5xdWVyeVNlbGVjdG9yKFwic3R5bGVcIikpYS5fX2Nzc1J1bGVzPWIuX3N0eWxlQXN0LGEudGV4dENvbnRlbnQ9SChiLl9zdHlsZUFzdCl9fTtVLnByb3RvdHlwZS5zdHlsZURvY3VtZW50PWZ1bmN0aW9uKGEpe1YodGhpcyk7dGhpcy5zdHlsZVN1YnRyZWUoZG9jdW1lbnQuYm9keSxhKX07XG5pZighd2luZG93LlNoYWR5Q1NTfHwhd2luZG93LlNoYWR5Q1NTLlNjb3BpbmdTaGltKXt2YXIgWj1uZXcgVSx0YT13aW5kb3cuU2hhZHlDU1MmJndpbmRvdy5TaGFkeUNTUy5DdXN0b21TdHlsZUludGVyZmFjZTt3aW5kb3cuU2hhZHlDU1M9e3ByZXBhcmVUZW1wbGF0ZTpmdW5jdGlvbihhLGIpe1coWik7Wi5wcmVwYXJlVGVtcGxhdGUoYSxiKX0sc3R5bGVTdWJ0cmVlOmZ1bmN0aW9uKGEsYil7VyhaKTtaLnN0eWxlU3VidHJlZShhLGIpfSxzdHlsZUVsZW1lbnQ6ZnVuY3Rpb24oYSl7VyhaKTtaLnN0eWxlRWxlbWVudChhKX0sc3R5bGVEb2N1bWVudDpmdW5jdGlvbihhKXtXKFopO1ouc3R5bGVEb2N1bWVudChhKX0sZ2V0Q29tcHV0ZWRTdHlsZVZhbHVlOmZ1bmN0aW9uKGEsYil7cmV0dXJuKGE9d2luZG93LmdldENvbXB1dGVkU3R5bGUoYSkuZ2V0UHJvcGVydHlWYWx1ZShiKSk/YS50cmltKCk6XCJcIn0sbmF0aXZlQ3NzOkUsbmF0aXZlU2hhZG93OkF9O3RhJiYod2luZG93LlNoYWR5Q1NTLkN1c3RvbVN0eWxlSW50ZXJmYWNlPVxudGEpfXdpbmRvdy5TaGFkeUNTUy5BcHBseVNoaW09VDt9KS5jYWxsKHRoaXMpO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcHBseS1zaGltLm1pbi5qcy5tYXBcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvc2hhZHljc3MvYXBwbHktc2hpbS5taW4uanMiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiYm9vdC5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiYXN5bmMuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cImRlYm91bmNlLmh0bWxcIj5cblxuPHNjcmlwdD5cbihmdW5jdGlvbigpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgLy8gZGV0ZWN0IG5hdGl2ZSB0b3VjaCBhY3Rpb24gc3VwcG9ydFxuICBsZXQgSEFTX05BVElWRV9UQSA9IHR5cGVvZiBkb2N1bWVudC5oZWFkLnN0eWxlLnRvdWNoQWN0aW9uID09PSAnc3RyaW5nJztcbiAgbGV0IEdFU1RVUkVfS0VZID0gJ19fcG9seW1lckdlc3R1cmVzJztcbiAgbGV0IEhBTkRMRURfT0JKID0gJ19fcG9seW1lckdlc3R1cmVzSGFuZGxlZCc7XG4gIGxldCBUT1VDSF9BQ1RJT04gPSAnX19wb2x5bWVyR2VzdHVyZXNUb3VjaEFjdGlvbic7XG4gIC8vIHJhZGl1cyBmb3IgdGFwIGFuZCB0cmFja1xuICBsZXQgVEFQX0RJU1RBTkNFID0gMjU7XG4gIGxldCBUUkFDS19ESVNUQU5DRSA9IDU7XG4gIC8vIG51bWJlciBvZiBsYXN0IE4gdHJhY2sgcG9zaXRpb25zIHRvIGtlZXBcbiAgbGV0IFRSQUNLX0xFTkdUSCA9IDI7XG5cbiAgLy8gRGlzYWJsaW5nIFwibW91c2VcIiBoYW5kbGVycyBmb3IgMjUwMG1zIGlzIGVub3VnaFxuICBsZXQgTU9VU0VfVElNRU9VVCA9IDI1MDA7XG4gIGxldCBNT1VTRV9FVkVOVFMgPSBbJ21vdXNlZG93bicsICdtb3VzZW1vdmUnLCAnbW91c2V1cCcsICdjbGljayddO1xuICAvLyBhbiBhcnJheSBvZiBiaXRtYXNrIHZhbHVlcyBmb3IgbWFwcGluZyBNb3VzZUV2ZW50LndoaWNoIHRvIE1vdXNlRXZlbnQuYnV0dG9uc1xuICBsZXQgTU9VU0VfV0hJQ0hfVE9fQlVUVE9OUyA9IFswLCAxLCA0LCAyXTtcbiAgbGV0IE1PVVNFX0hBU19CVVRUT05TID0gKGZ1bmN0aW9uKCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gbmV3IE1vdXNlRXZlbnQoJ3Rlc3QnLCB7YnV0dG9uczogMX0pLmJ1dHRvbnMgPT09IDE7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSkoKTtcblxuICAvKiBlc2xpbnQgbm8tZW1wdHk6IFtcImVycm9yXCIsIHsgXCJhbGxvd0VtcHR5Q2F0Y2hcIjogdHJ1ZSB9XSAqL1xuICAvLyBjaGVjayBmb3IgcGFzc2l2ZSBldmVudCBsaXN0ZW5lcnNcbiAgbGV0IFNVUFBPUlRTX1BBU1NJVkUgPSBmYWxzZTtcbiAgKGZ1bmN0aW9uKCkge1xuICAgIHRyeSB7XG4gICAgICBsZXQgb3B0cyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ3Bhc3NpdmUnLCB7Z2V0OiBmdW5jdGlvbigpIHtTVVBQT1JUU19QQVNTSVZFID0gdHJ1ZTt9fSlcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0ZXN0JywgbnVsbCwgb3B0cyk7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndGVzdCcsIG51bGwsIG9wdHMpO1xuICAgIH0gY2F0Y2goZSkge31cbiAgfSkoKTtcblxuICAvLyBDaGVjayBmb3IgdG91Y2gtb25seSBkZXZpY2VzXG4gIGxldCBJU19UT1VDSF9PTkxZID0gbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvaVAoPzpbb2FdZHxob25lKXxBbmRyb2lkLyk7XG5cbiAgbGV0IEdlc3R1cmVSZWNvZ25pemVyID0gZnVuY3Rpb24oKXt9OyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gIEdlc3R1cmVSZWNvZ25pemVyLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKCl7fTtcbiAgLyoqIEB0eXBlIHtmdW5jdGlvbihNb3VzZUV2ZW50KSB8IHVuZGVmaW5lZH0gKi9cbiAgR2VzdHVyZVJlY29nbml6ZXIucHJvdG90eXBlLm1vdXNlZG93bjtcbiAgLyoqIEB0eXBlIHsoZnVuY3Rpb24oTW91c2VFdmVudCkgfCB1bmRlZmluZWQpfSAqL1xuICBHZXN0dXJlUmVjb2duaXplci5wcm90b3R5cGUubW91c2Vtb3ZlO1xuICAvKiogQHR5cGUgeyhmdW5jdGlvbihNb3VzZUV2ZW50KSB8IHVuZGVmaW5lZCl9ICovXG4gIEdlc3R1cmVSZWNvZ25pemVyLnByb3RvdHlwZS5tb3VzZXVwO1xuICAvKiogQHR5cGUgeyhmdW5jdGlvbihUb3VjaEV2ZW50KSB8IHVuZGVmaW5lZCl9ICovXG4gIEdlc3R1cmVSZWNvZ25pemVyLnByb3RvdHlwZS50b3VjaHN0YXJ0O1xuICAvKiogQHR5cGUgeyhmdW5jdGlvbihUb3VjaEV2ZW50KSB8IHVuZGVmaW5lZCl9ICovXG4gIEdlc3R1cmVSZWNvZ25pemVyLnByb3RvdHlwZS50b3VjaG1vdmU7XG4gIC8qKiBAdHlwZSB7KGZ1bmN0aW9uKFRvdWNoRXZlbnQpIHwgdW5kZWZpbmVkKX0gKi9cbiAgR2VzdHVyZVJlY29nbml6ZXIucHJvdG90eXBlLnRvdWNoZW5kO1xuICAvKiogQHR5cGUgeyhmdW5jdGlvbihNb3VzZUV2ZW50KSB8IHVuZGVmaW5lZCl9ICovXG4gIEdlc3R1cmVSZWNvZ25pemVyLnByb3RvdHlwZS5jbGljaztcblxuICAvLyB0b3VjaCB3aWxsIG1ha2Ugc3ludGhldGljIG1vdXNlIGV2ZW50c1xuICAvLyBgcHJldmVudERlZmF1bHRgIG9uIHRvdWNoZW5kIHdpbGwgY2FuY2VsIHRoZW0sXG4gIC8vIGJ1dCB0aGlzIGJyZWFrcyBgPGlucHV0PmAgZm9jdXMgYW5kIGxpbmsgY2xpY2tzXG4gIC8vIGRpc2FibGUgbW91c2UgaGFuZGxlcnMgZm9yIE1PVVNFX1RJTUVPVVQgbXMgYWZ0ZXJcbiAgLy8gYSB0b3VjaGVuZCB0byBpZ25vcmUgc3ludGhldGljIG1vdXNlIGV2ZW50c1xuICBsZXQgbW91c2VDYW5jZWxsZXIgPSBmdW5jdGlvbihtb3VzZUV2ZW50KSB7XG4gICAgLy8gQ2hlY2sgZm9yIHNvdXJjZUNhcGFiaWxpdGllcywgdXNlZCB0byBkaXN0aW5ndWlzaCBzeW50aGV0aWMgZXZlbnRzXG4gICAgLy8gaWYgbW91c2VFdmVudCBkaWQgbm90IGNvbWUgZnJvbSBhIGRldmljZSB0aGF0IGZpcmVzIHRvdWNoIGV2ZW50cyxcbiAgICAvLyBpdCB3YXMgbWFkZSBieSBhIHJlYWwgbW91c2UgYW5kIHNob3VsZCBiZSBjb3VudGVkXG4gICAgLy8gaHR0cDovL3dpY2cuZ2l0aHViLmlvL0lucHV0RGV2aWNlQ2FwYWJpbGl0aWVzLyNkb20taW5wdXRkZXZpY2VjYXBhYmlsaXRpZXMtZmlyZXN0b3VjaGV2ZW50c1xuICAgIGxldCBzYyA9IG1vdXNlRXZlbnQuc291cmNlQ2FwYWJpbGl0aWVzO1xuICAgIGlmIChzYyAmJiAhc2MuZmlyZXNUb3VjaEV2ZW50cykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBza2lwIHN5bnRoZXRpYyBtb3VzZSBldmVudHNcbiAgICBtb3VzZUV2ZW50W0hBTkRMRURfT0JKXSA9IHtza2lwOiB0cnVlfTtcbiAgICAvLyBkaXNhYmxlIFwiZ2hvc3QgY2xpY2tzXCJcbiAgICBpZiAobW91c2VFdmVudC50eXBlID09PSAnY2xpY2snKSB7XG4gICAgICBsZXQgcGF0aCA9IG1vdXNlRXZlbnQuY29tcG9zZWRQYXRoICYmIG1vdXNlRXZlbnQuY29tcG9zZWRQYXRoKCk7XG4gICAgICBpZiAocGF0aCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAocGF0aFtpXSA9PT0gUE9JTlRFUlNUQVRFLm1vdXNlLnRhcmdldCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbW91c2VFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgbW91c2VFdmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IHNldHVwIFRydWUgdG8gYWRkLCBmYWxzZSB0byByZW1vdmUuXG4gICAqL1xuICBmdW5jdGlvbiBzZXR1cFRlYXJkb3duTW91c2VDYW5jZWxsZXIoc2V0dXApIHtcbiAgICBsZXQgZXZlbnRzID0gSVNfVE9VQ0hfT05MWSA/IFsnY2xpY2snXSA6IE1PVVNFX0VWRU5UUztcbiAgICBmb3IgKGxldCBpID0gMCwgZW47IGkgPCBldmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGVuID0gZXZlbnRzW2ldO1xuICAgICAgaWYgKHNldHVwKSB7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoZW4sIG1vdXNlQ2FuY2VsbGVyLCB0cnVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoZW4sIG1vdXNlQ2FuY2VsbGVyLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpZ25vcmVNb3VzZShlKSB7XG4gICAgaWYgKCFQT0lOVEVSU1RBVEUubW91c2UubW91c2VJZ25vcmVKb2IpIHtcbiAgICAgIHNldHVwVGVhcmRvd25Nb3VzZUNhbmNlbGxlcih0cnVlKTtcbiAgICB9XG4gICAgbGV0IHVuc2V0ID0gZnVuY3Rpb24oKSB7XG4gICAgICBzZXR1cFRlYXJkb3duTW91c2VDYW5jZWxsZXIoKTtcbiAgICAgIFBPSU5URVJTVEFURS5tb3VzZS50YXJnZXQgPSBudWxsO1xuICAgICAgUE9JTlRFUlNUQVRFLm1vdXNlLm1vdXNlSWdub3JlSm9iID0gbnVsbDtcbiAgICB9O1xuICAgIFBPSU5URVJTVEFURS5tb3VzZS50YXJnZXQgPSBlLmNvbXBvc2VkUGF0aCgpWzBdO1xuICAgIFBPSU5URVJTVEFURS5tb3VzZS5tb3VzZUlnbm9yZUpvYiA9IFBvbHltZXIuRGVib3VuY2VyLmRlYm91bmNlKFxuICAgICAgICAgIFBPSU5URVJTVEFURS5tb3VzZS5tb3VzZUlnbm9yZUpvYlxuICAgICAgICAsIFBvbHltZXIuQXN5bmMudGltZU91dC5hZnRlcihNT1VTRV9USU1FT1VUKVxuICAgICAgICAsIHVuc2V0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGV2IGV2ZW50IHRvIHRlc3QgZm9yIGxlZnQgbW91c2UgYnV0dG9uIGRvd25cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gaGFzIGxlZnQgbW91c2UgYnV0dG9uIGRvd25cbiAgICovXG4gIGZ1bmN0aW9uIGhhc0xlZnRNb3VzZUJ1dHRvbihldikge1xuICAgIGxldCB0eXBlID0gZXYudHlwZTtcbiAgICAvLyBleGl0IGVhcmx5IGlmIHRoZSBldmVudCBpcyBub3QgYSBtb3VzZSBldmVudFxuICAgIGlmIChNT1VTRV9FVkVOVFMuaW5kZXhPZih0eXBlKSA9PT0gLTEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gZXYuYnV0dG9uIGlzIG5vdCByZWxpYWJsZSBmb3IgbW91c2Vtb3ZlICgwIGlzIG92ZXJsb2FkZWQgYXMgYm90aCBsZWZ0IGJ1dHRvbiBhbmQgbm8gYnV0dG9ucylcbiAgICAvLyBpbnN0ZWFkIHdlIHVzZSBldi5idXR0b25zIChiaXRtYXNrIG9mIGJ1dHRvbnMpIG9yIGZhbGwgYmFjayB0byBldi53aGljaCAoZGVwcmVjYXRlZCwgMCBmb3Igbm8gYnV0dG9ucywgMSBmb3IgbGVmdCBidXR0b24pXG4gICAgaWYgKHR5cGUgPT09ICdtb3VzZW1vdmUnKSB7XG4gICAgICAvLyBhbGxvdyB1bmRlZmluZWQgZm9yIHRlc3RpbmcgZXZlbnRzXG4gICAgICBsZXQgYnV0dG9ucyA9IGV2LmJ1dHRvbnMgPT09IHVuZGVmaW5lZCA/IDEgOiBldi5idXR0b25zO1xuICAgICAgaWYgKChldiBpbnN0YW5jZW9mIHdpbmRvdy5Nb3VzZUV2ZW50KSAmJiAhTU9VU0VfSEFTX0JVVFRPTlMpIHtcbiAgICAgICAgYnV0dG9ucyA9IE1PVVNFX1dISUNIX1RPX0JVVFRPTlNbZXYud2hpY2hdIHx8IDA7XG4gICAgICB9XG4gICAgICAvLyBidXR0b25zIGlzIGEgYml0bWFzaywgY2hlY2sgdGhhdCB0aGUgbGVmdCBidXR0b24gYml0IGlzIHNldCAoMSlcbiAgICAgIHJldHVybiBCb29sZWFuKGJ1dHRvbnMgJiAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gYWxsb3cgdW5kZWZpbmVkIGZvciB0ZXN0aW5nIGV2ZW50c1xuICAgICAgbGV0IGJ1dHRvbiA9IGV2LmJ1dHRvbiA9PT0gdW5kZWZpbmVkID8gMCA6IGV2LmJ1dHRvbjtcbiAgICAgIC8vIGV2LmJ1dHRvbiBpcyAwIGluIG1vdXNlZG93bi9tb3VzZXVwL2NsaWNrIGZvciBsZWZ0IGJ1dHRvbiBhY3RpdmF0aW9uXG4gICAgICByZXR1cm4gYnV0dG9uID09PSAwO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzU3ludGhldGljQ2xpY2soZXYpIHtcbiAgICBpZiAoZXYudHlwZSA9PT0gJ2NsaWNrJykge1xuICAgICAgLy8gZXYuZGV0YWlsIGlzIDAgZm9yIEhUTUxFbGVtZW50LmNsaWNrIGluIG1vc3QgYnJvd3NlcnNcbiAgICAgIGlmIChldi5kZXRhaWwgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICAvLyBpbiB0aGUgd29yc3QgY2FzZSwgY2hlY2sgdGhhdCB0aGUgeC95IHBvc2l0aW9uIG9mIHRoZSBjbGljayBpcyB3aXRoaW5cbiAgICAgIC8vIHRoZSBib3VuZGluZyBib3ggb2YgdGhlIHRhcmdldCBvZiB0aGUgZXZlbnRcbiAgICAgIC8vIFRoYW5rcyBJRSAxMCA+OihcbiAgICAgIGxldCB0ID0gR2VzdHVyZXMuX2ZpbmRPcmlnaW5hbFRhcmdldChldik7XG4gICAgICAvLyBtYWtlIHN1cmUgdGhlIHRhcmdldCBvZiB0aGUgZXZlbnQgaXMgYW4gZWxlbWVudCBzbyB3ZSBjYW4gdXNlIGdldEJvdW5kaW5nQ2xpZW50UmVjdCxcbiAgICAgIC8vIGlmIG5vdCwganVzdCBhc3N1bWUgaXQgaXMgYSBzeW50aGV0aWMgY2xpY2tcbiAgICAgIGlmICghdC5ub2RlVHlwZSB8fCAvKiogQHR5cGUge0VsZW1lbnR9ICovKHQpLm5vZGVUeXBlICE9PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGxldCBiY3IgPSAvKiogQHR5cGUge0VsZW1lbnR9ICovKHQpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgLy8gdXNlIHBhZ2UgeC95IHRvIGFjY291bnQgZm9yIHNjcm9sbGluZ1xuICAgICAgbGV0IHggPSBldi5wYWdlWCwgeSA9IGV2LnBhZ2VZO1xuICAgICAgLy8gZXYgaXMgYSBzeW50aGV0aWMgY2xpY2sgaWYgdGhlIHBvc2l0aW9uIGlzIG91dHNpZGUgdGhlIGJvdW5kaW5nIGJveCBvZiB0aGUgdGFyZ2V0XG4gICAgICByZXR1cm4gISgoeCA+PSBiY3IubGVmdCAmJiB4IDw9IGJjci5yaWdodCkgJiYgKHkgPj0gYmNyLnRvcCAmJiB5IDw9IGJjci5ib3R0b20pKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgbGV0IFBPSU5URVJTVEFURSA9IHtcbiAgICBtb3VzZToge1xuICAgICAgdGFyZ2V0OiBudWxsLFxuICAgICAgbW91c2VJZ25vcmVKb2I6IG51bGxcbiAgICB9LFxuICAgIHRvdWNoOiB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMCxcbiAgICAgIGlkOiAtMSxcbiAgICAgIHNjcm9sbERlY2lkZWQ6IGZhbHNlXG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIGZpcnN0VG91Y2hBY3Rpb24oZXYpIHtcbiAgICBsZXQgdGEgPSAnYXV0byc7XG4gICAgbGV0IHBhdGggPSBldi5jb21wb3NlZFBhdGggJiYgZXYuY29tcG9zZWRQYXRoKCk7XG4gICAgaWYgKHBhdGgpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBuOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgICBuID0gcGF0aFtpXTtcbiAgICAgICAgaWYgKG5bVE9VQ0hfQUNUSU9OXSkge1xuICAgICAgICAgIHRhID0gbltUT1VDSF9BQ1RJT05dO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0YTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyYWNrRG9jdW1lbnQoc3RhdGVPYmosIG1vdmVmbiwgdXBmbikge1xuICAgIHN0YXRlT2JqLm1vdmVmbiA9IG1vdmVmbjtcbiAgICBzdGF0ZU9iai51cGZuID0gdXBmbjtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBtb3ZlZm4pO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB1cGZuKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVudHJhY2tEb2N1bWVudChzdGF0ZU9iaikge1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHN0YXRlT2JqLm1vdmVmbik7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHN0YXRlT2JqLnVwZm4pO1xuICAgIHN0YXRlT2JqLm1vdmVmbiA9IG51bGw7XG4gICAgc3RhdGVPYmoudXBmbiA9IG51bGw7XG4gIH1cblxuICAvLyB1c2UgYSBkb2N1bWVudC13aWRlIHRvdWNoZW5kIGxpc3RlbmVyIHRvIHN0YXJ0IHRoZSBnaG9zdC1jbGljayBwcmV2ZW50aW9uIG1lY2hhbmlzbVxuICAvLyBVc2UgcGFzc2l2ZSBldmVudCBsaXN0ZW5lcnMsIGlmIHN1cHBvcnRlZCwgdG8gbm90IGFmZmVjdCBzY3JvbGxpbmcgcGVyZm9ybWFuY2VcbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCBpZ25vcmVNb3VzZSwgU1VQUE9SVFNfUEFTU0lWRSA/IHtwYXNzaXZlOiB0cnVlfSA6IGZhbHNlKTtcblxuICAvKipcbiAgICogTW9kdWxlIGZvciBhZGRpbmcgbGlzdGVuZXJzIHRvIGEgbm9kZSBmb3IgdGhlIGZvbGxvd2luZyBub3JtYWxpemVkXG4gICAqIGNyb3NzLXBsYXRmb3JtIFwiZ2VzdHVyZVwiIGV2ZW50czpcbiAgICogLSBgZG93bmAgLSBtb3VzZSBvciB0b3VjaCB3ZW50IGRvd25cbiAgICogLSBgdXBgIC0gbW91c2Ugb3IgdG91Y2ggd2VudCB1cFxuICAgKiAtIGB0YXBgIC0gbW91c2UgY2xpY2sgb3IgZmluZ2VyIHRhcFxuICAgKiAtIGB0cmFja2AgLSBtb3VzZSBkcmFnIG9yIHRvdWNoIG1vdmVcbiAgICpcbiAgICogQG5hbWVzcGFjZVxuICAgKiBAbWVtYmVyb2YgUG9seW1lclxuICAgKiBAc3VtbWFyeSBNb2R1bGUgZm9yIGFkZGluZyBjcm9zcy1wbGF0Zm9ybSBnZXN0dXJlIGV2ZW50IGxpc3RlbmVycy5cbiAgICovXG4gIGNvbnN0IEdlc3R1cmVzID0ge1xuICAgIGdlc3R1cmVzOiB7fSxcbiAgICByZWNvZ25pemVyczogW10sXG5cbiAgICAvKipcbiAgICAgKiBGaW5kcyB0aGUgZWxlbWVudCByZW5kZXJlZCBvbiB0aGUgc2NyZWVuIGF0IHRoZSBwcm92aWRlZCBjb29yZGluYXRlcy5cbiAgICAgKlxuICAgICAqIFNpbWlsYXIgdG8gYGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnRgLCBidXQgcGllcmNlcyB0aHJvdWdoXG4gICAgICogc2hhZG93IHJvb3RzLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIFBvbHltZXIuR2VzdHVyZXNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCBIb3Jpem9udGFsIHBpeGVsIGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSBWZXJ0aWNhbCBwaXhlbCBjb29yZGluYXRlXG4gICAgICogQHJldHVybiB7RWxlbWVudH0gUmV0dXJucyB0aGUgZGVlcGVzdCBzaGFkb3dSb290IGluY2x1c2l2ZSBlbGVtZW50XG4gICAgICogZm91bmQgYXQgdGhlIHNjcmVlbiBwb3NpdGlvbiBnaXZlbi5cbiAgICAgKi9cbiAgICBkZWVwVGFyZ2V0RmluZDogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgbGV0IG5vZGUgPSBkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KHgsIHkpO1xuICAgICAgbGV0IG5leHQgPSBub2RlO1xuICAgICAgLy8gdGhpcyBjb2RlIHBhdGggaXMgb25seSB0YWtlbiB3aGVuIG5hdGl2ZSBTaGFkb3dET00gaXMgdXNlZFxuICAgICAgLy8gaWYgdGhlcmUgaXMgYSBzaGFkb3dyb290LCBpdCBtYXkgaGF2ZSBhIG5vZGUgYXQgeC95XG4gICAgICAvLyBpZiB0aGVyZSBpcyBub3QgYSBzaGFkb3dyb290LCBleGl0IHRoZSBsb29wXG4gICAgICB3aGlsZSAobmV4dCAmJiBuZXh0LnNoYWRvd1Jvb3QgJiYgIXdpbmRvdy5TaGFkeURPTSkge1xuICAgICAgICAvLyBpZiB0aGVyZSBpcyBhIG5vZGUgYXQgeC95IGluIHRoZSBzaGFkb3dyb290LCBsb29rIGRlZXBlclxuICAgICAgICBsZXQgb2xkTmV4dCA9IG5leHQ7XG4gICAgICAgIG5leHQgPSBuZXh0LnNoYWRvd1Jvb3QuZWxlbWVudEZyb21Qb2ludCh4LCB5KTtcbiAgICAgICAgLy8gb24gU2FmYXJpLCBlbGVtZW50RnJvbVBvaW50IG1heSByZXR1cm4gdGhlIHNoYWRvd1Jvb3QgaG9zdFxuICAgICAgICBpZiAob2xkTmV4dCA9PT0gbmV4dCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXh0KSB7XG4gICAgICAgICAgbm9kZSA9IG5leHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBub2RlO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogYSBjaGVhcGVyIGNoZWNrIHRoYW4gZXYuY29tcG9zZWRQYXRoKClbMF07XG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2IEV2ZW50LlxuICAgICAqIEByZXR1cm4ge0V2ZW50VGFyZ2V0fSBSZXR1cm5zIHRoZSBldmVudCB0YXJnZXQuXG4gICAgICovXG4gICAgX2ZpbmRPcmlnaW5hbFRhcmdldDogZnVuY3Rpb24oZXYpIHtcbiAgICAgIC8vIHNoYWRvd2RvbVxuICAgICAgaWYgKGV2LmNvbXBvc2VkUGF0aCkge1xuICAgICAgICByZXR1cm4gLyoqIEB0eXBlIHtFdmVudFRhcmdldH0gKi8oZXYuY29tcG9zZWRQYXRoKClbMF0pO1xuICAgICAgfVxuICAgICAgLy8gc2hhZHlkb21cbiAgICAgIHJldHVybiBldi50YXJnZXQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gZXYgRXZlbnQuXG4gICAgICovXG4gICAgX2hhbmRsZU5hdGl2ZTogZnVuY3Rpb24oZXYpIHtcbiAgICAgIGxldCBoYW5kbGVkO1xuICAgICAgbGV0IHR5cGUgPSBldi50eXBlO1xuICAgICAgbGV0IG5vZGUgPSBldi5jdXJyZW50VGFyZ2V0O1xuICAgICAgbGV0IGdvYmogPSBub2RlW0dFU1RVUkVfS0VZXTtcbiAgICAgIGlmICghZ29iaikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsZXQgZ3MgPSBnb2JqW3R5cGVdO1xuICAgICAgaWYgKCFncykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIWV2W0hBTkRMRURfT0JKXSkge1xuICAgICAgICBldltIQU5ETEVEX09CSl0gPSB7fTtcbiAgICAgICAgaWYgKHR5cGUuc2xpY2UoMCwgNSkgPT09ICd0b3VjaCcpIHtcbiAgICAgICAgICBldiA9IC8qKiBAdHlwZSB7VG91Y2hFdmVudH0gKi8oZXYpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtYXNzaWduXG4gICAgICAgICAgbGV0IHQgPSBldi5jaGFuZ2VkVG91Y2hlc1swXTtcbiAgICAgICAgICBpZiAodHlwZSA9PT0gJ3RvdWNoc3RhcnQnKSB7XG4gICAgICAgICAgICAvLyBvbmx5IGhhbmRsZSB0aGUgZmlyc3QgZmluZ2VyXG4gICAgICAgICAgICBpZiAoZXYudG91Y2hlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgUE9JTlRFUlNUQVRFLnRvdWNoLmlkID0gdC5pZGVudGlmaWVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoUE9JTlRFUlNUQVRFLnRvdWNoLmlkICE9PSB0LmlkZW50aWZpZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFIQVNfTkFUSVZFX1RBKSB7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gJ3RvdWNoc3RhcnQnIHx8IHR5cGUgPT09ICd0b3VjaG1vdmUnKSB7XG4gICAgICAgICAgICAgIEdlc3R1cmVzLl9oYW5kbGVUb3VjaEFjdGlvbihldik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBoYW5kbGVkID0gZXZbSEFORExFRF9PQkpdO1xuICAgICAgLy8gdXNlZCB0byBpZ25vcmUgc3ludGhldGljIG1vdXNlIGV2ZW50c1xuICAgICAgaWYgKGhhbmRsZWQuc2tpcCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsZXQgcmVjb2duaXplcnMgPSBHZXN0dXJlcy5yZWNvZ25pemVycztcbiAgICAgIC8vIHJlc2V0IHJlY29nbml6ZXIgc3RhdGVcbiAgICAgIGZvciAobGV0IGkgPSAwLCByOyBpIDwgcmVjb2duaXplcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgciA9IHJlY29nbml6ZXJzW2ldO1xuICAgICAgICBpZiAoZ3Nbci5uYW1lXSAmJiAhaGFuZGxlZFtyLm5hbWVdKSB7XG4gICAgICAgICAgaWYgKHIuZmxvdyAmJiByLmZsb3cuc3RhcnQuaW5kZXhPZihldi50eXBlKSA+IC0xICYmIHIucmVzZXQpIHtcbiAgICAgICAgICAgIHIucmVzZXQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIGVuZm9yY2UgZ2VzdHVyZSByZWNvZ25pemVyIG9yZGVyXG4gICAgICBmb3IgKGxldCBpID0gMCwgcjsgaSA8IHJlY29nbml6ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHIgPSByZWNvZ25pemVyc1tpXTtcbiAgICAgICAgaWYgKGdzW3IubmFtZV0gJiYgIWhhbmRsZWRbci5uYW1lXSkge1xuICAgICAgICAgIGhhbmRsZWRbci5uYW1lXSA9IHRydWU7XG4gICAgICAgICAgclt0eXBlXShldik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1RvdWNoRXZlbnR9IGV2IEV2ZW50LlxuICAgICAqL1xuICAgIF9oYW5kbGVUb3VjaEFjdGlvbjogZnVuY3Rpb24oZXYpIHtcbiAgICAgIGxldCB0ID0gZXYuY2hhbmdlZFRvdWNoZXNbMF07XG4gICAgICBsZXQgdHlwZSA9IGV2LnR5cGU7XG4gICAgICBpZiAodHlwZSA9PT0gJ3RvdWNoc3RhcnQnKSB7XG4gICAgICAgIFBPSU5URVJTVEFURS50b3VjaC54ID0gdC5jbGllbnRYO1xuICAgICAgICBQT0lOVEVSU1RBVEUudG91Y2gueSA9IHQuY2xpZW50WTtcbiAgICAgICAgUE9JTlRFUlNUQVRFLnRvdWNoLnNjcm9sbERlY2lkZWQgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3RvdWNobW92ZScpIHtcbiAgICAgICAgaWYgKFBPSU5URVJTVEFURS50b3VjaC5zY3JvbGxEZWNpZGVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIFBPSU5URVJTVEFURS50b3VjaC5zY3JvbGxEZWNpZGVkID0gdHJ1ZTtcbiAgICAgICAgbGV0IHRhID0gZmlyc3RUb3VjaEFjdGlvbihldik7XG4gICAgICAgIGxldCBwcmV2ZW50ID0gZmFsc2U7XG4gICAgICAgIGxldCBkeCA9IE1hdGguYWJzKFBPSU5URVJTVEFURS50b3VjaC54IC0gdC5jbGllbnRYKTtcbiAgICAgICAgbGV0IGR5ID0gTWF0aC5hYnMoUE9JTlRFUlNUQVRFLnRvdWNoLnkgLSB0LmNsaWVudFkpO1xuICAgICAgICBpZiAoIWV2LmNhbmNlbGFibGUpIHtcbiAgICAgICAgICAvLyBzY3JvbGxpbmcgaXMgaGFwcGVuaW5nXG4gICAgICAgIH0gZWxzZSBpZiAodGEgPT09ICdub25lJykge1xuICAgICAgICAgIHByZXZlbnQgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKHRhID09PSAncGFuLXgnKSB7XG4gICAgICAgICAgcHJldmVudCA9IGR5ID4gZHg7XG4gICAgICAgIH0gZWxzZSBpZiAodGEgPT09ICdwYW4teScpIHtcbiAgICAgICAgICBwcmV2ZW50ID0gZHggPiBkeTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJldmVudCkge1xuICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgR2VzdHVyZXMucHJldmVudCgndHJhY2snKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGFuIGV2ZW50IGxpc3RlbmVyIHRvIGEgbm9kZSBmb3IgdGhlIGdpdmVuIGdlc3R1cmUgdHlwZS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBQb2x5bWVyLkdlc3R1cmVzXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlIE5vZGUgdG8gYWRkIGxpc3RlbmVyIG9uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2VHlwZSBHZXN0dXJlIHR5cGU6IGBkb3duYCwgYHVwYCwgYHRyYWNrYCwgb3IgYHRhcGBcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIEV2ZW50IGxpc3RlbmVyIGZ1bmN0aW9uIHRvIGNhbGxcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgYSBnZXN0dXJlIGV2ZW50IGxpc3RlbmVyIHdhcyBhZGRlZC5cbiAgICAgKiBAdGhpcyB7R2VzdHVyZXN9XG4gICAgICovXG4gICAgYWRkTGlzdGVuZXI6IGZ1bmN0aW9uKG5vZGUsIGV2VHlwZSwgaGFuZGxlcikge1xuICAgICAgaWYgKHRoaXMuZ2VzdHVyZXNbZXZUeXBlXSkge1xuICAgICAgICB0aGlzLl9hZGQobm9kZSwgZXZUeXBlLCBoYW5kbGVyKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYW4gZXZlbnQgbGlzdGVuZXIgZnJvbSBhIG5vZGUgZm9yIHRoZSBnaXZlbiBnZXN0dXJlIHR5cGUuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgUG9seW1lci5HZXN0dXJlc1xuICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBOb2RlIHRvIHJlbW92ZSBsaXN0ZW5lciBmcm9tXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2VHlwZSBHZXN0dXJlIHR5cGU6IGBkb3duYCwgYHVwYCwgYHRyYWNrYCwgb3IgYHRhcGBcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIEV2ZW50IGxpc3RlbmVyIGZ1bmN0aW9uIHByZXZpb3VzbHkgcGFzc2VkIHRvXG4gICAgICogIGBhZGRMaXN0ZW5lcmAuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIGEgZ2VzdHVyZSBldmVudCBsaXN0ZW5lciB3YXMgcmVtb3ZlZC5cbiAgICAgKiBAdGhpcyB7R2VzdHVyZXN9XG4gICAgICovXG4gICAgcmVtb3ZlTGlzdGVuZXI6IGZ1bmN0aW9uKG5vZGUsIGV2VHlwZSwgaGFuZGxlcikge1xuICAgICAgaWYgKHRoaXMuZ2VzdHVyZXNbZXZUeXBlXSkge1xuICAgICAgICB0aGlzLl9yZW1vdmUobm9kZSwgZXZUeXBlLCBoYW5kbGVyKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGF1dG9tYXRlIHRoZSBldmVudCBsaXN0ZW5lcnMgZm9yIHRoZSBuYXRpdmUgZXZlbnRzXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG5vZGUgTm9kZSBvbiB3aGljaCB0byBhZGQgdGhlIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldlR5cGUgRXZlbnQgdHlwZSB0byBhZGQuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihFdmVudD8pfSBoYW5kbGVyIEV2ZW50IGhhbmRsZXIgZnVuY3Rpb24uXG4gICAgICogQHRoaXMge0dlc3R1cmVzfVxuICAgICAqL1xuICAgIF9hZGQ6IGZ1bmN0aW9uKG5vZGUsIGV2VHlwZSwgaGFuZGxlcikge1xuICAgICAgbGV0IHJlY29nbml6ZXIgPSB0aGlzLmdlc3R1cmVzW2V2VHlwZV07XG4gICAgICBsZXQgZGVwcyA9IHJlY29nbml6ZXIuZGVwcztcbiAgICAgIGxldCBuYW1lID0gcmVjb2duaXplci5uYW1lO1xuICAgICAgbGV0IGdvYmogPSBub2RlW0dFU1RVUkVfS0VZXTtcbiAgICAgIGlmICghZ29iaikge1xuICAgICAgICBub2RlW0dFU1RVUkVfS0VZXSA9IGdvYmogPSB7fTtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGkgPSAwLCBkZXAsIGdkOyBpIDwgZGVwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBkZXAgPSBkZXBzW2ldO1xuICAgICAgICAvLyBkb24ndCBhZGQgbW91c2UgaGFuZGxlcnMgb24gaU9TIGJlY2F1c2UgdGhleSBjYXVzZSBncmF5IHNlbGVjdGlvbiBvdmVybGF5c1xuICAgICAgICBpZiAoSVNfVE9VQ0hfT05MWSAmJiBNT1VTRV9FVkVOVFMuaW5kZXhPZihkZXApID4gLTEgJiYgZGVwICE9PSAnY2xpY2snKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgZ2QgPSBnb2JqW2RlcF07XG4gICAgICAgIGlmICghZ2QpIHtcbiAgICAgICAgICBnb2JqW2RlcF0gPSBnZCA9IHtfY291bnQ6IDB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChnZC5fY291bnQgPT09IDApIHtcbiAgICAgICAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoZGVwLCB0aGlzLl9oYW5kbGVOYXRpdmUpO1xuICAgICAgICB9XG4gICAgICAgIGdkW25hbWVdID0gKGdkW25hbWVdIHx8IDApICsgMTtcbiAgICAgICAgZ2QuX2NvdW50ID0gKGdkLl9jb3VudCB8fCAwKSArIDE7XG4gICAgICB9XG4gICAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoZXZUeXBlLCBoYW5kbGVyKTtcbiAgICAgIGlmIChyZWNvZ25pemVyLnRvdWNoQWN0aW9uKSB7XG4gICAgICAgIHRoaXMuc2V0VG91Y2hBY3Rpb24obm9kZSwgcmVjb2duaXplci50b3VjaEFjdGlvbik7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGF1dG9tYXRlIGV2ZW50IGxpc3RlbmVyIHJlbW92YWwgZm9yIG5hdGl2ZSBldmVudHNcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gbm9kZSBOb2RlIG9uIHdoaWNoIHRvIHJlbW92ZSB0aGUgZXZlbnQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2VHlwZSBFdmVudCB0eXBlIHRvIHJlbW92ZS5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKEV2ZW50Pyl9IGhhbmRsZXIgRXZlbnQgaGFuZGxlciBmdW5jdGlvbi5cbiAgICAgKiBAdGhpcyB7R2VzdHVyZXN9XG4gICAgICovXG4gICAgX3JlbW92ZTogZnVuY3Rpb24obm9kZSwgZXZUeXBlLCBoYW5kbGVyKSB7XG4gICAgICBsZXQgcmVjb2duaXplciA9IHRoaXMuZ2VzdHVyZXNbZXZUeXBlXTtcbiAgICAgIGxldCBkZXBzID0gcmVjb2duaXplci5kZXBzO1xuICAgICAgbGV0IG5hbWUgPSByZWNvZ25pemVyLm5hbWU7XG4gICAgICBsZXQgZ29iaiA9IG5vZGVbR0VTVFVSRV9LRVldO1xuICAgICAgaWYgKGdvYmopIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGRlcCwgZ2Q7IGkgPCBkZXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgZGVwID0gZGVwc1tpXTtcbiAgICAgICAgICBnZCA9IGdvYmpbZGVwXTtcbiAgICAgICAgICBpZiAoZ2QgJiYgZ2RbbmFtZV0pIHtcbiAgICAgICAgICAgIGdkW25hbWVdID0gKGdkW25hbWVdIHx8IDEpIC0gMTtcbiAgICAgICAgICAgIGdkLl9jb3VudCA9IChnZC5fY291bnQgfHwgMSkgLSAxO1xuICAgICAgICAgICAgaWYgKGdkLl9jb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoZGVwLCB0aGlzLl9oYW5kbGVOYXRpdmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKGV2VHlwZSwgaGFuZGxlcik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBhIG5ldyBnZXN0dXJlIGV2ZW50IHJlY29nbml6ZXIgZm9yIGFkZGluZyBuZXcgY3VzdG9tXG4gICAgICogZ2VzdHVyZSBldmVudCB0eXBlcy5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBQb2x5bWVyLkdlc3R1cmVzXG4gICAgICogQHBhcmFtIHtHZXN0dXJlUmVjb2duaXplcn0gcmVjb2cgR2VzdHVyZSByZWNvZ25pemVyIGRlc2NyaXB0b3JcbiAgICAgKiBAdGhpcyB7R2VzdHVyZXN9XG4gICAgICovXG4gICAgcmVnaXN0ZXI6IGZ1bmN0aW9uKHJlY29nKSB7XG4gICAgICB0aGlzLnJlY29nbml6ZXJzLnB1c2gocmVjb2cpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZWNvZy5lbWl0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLmdlc3R1cmVzW3JlY29nLmVtaXRzW2ldXSA9IHJlY29nO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldk5hbWUgRXZlbnQgbmFtZS5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFJldHVybnMgdGhlIGdlc3R1cmUgZm9yIHRoZSBnaXZlbiBldmVudCBuYW1lLlxuICAgICAqIEB0aGlzIHtHZXN0dXJlc31cbiAgICAgKi9cbiAgICBfZmluZFJlY29nbml6ZXJCeUV2ZW50OiBmdW5jdGlvbihldk5hbWUpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwLCByOyBpIDwgdGhpcy5yZWNvZ25pemVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICByID0gdGhpcy5yZWNvZ25pemVyc1tpXTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDAsIG47IGogPCByLmVtaXRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgbiA9IHIuZW1pdHNbal07XG4gICAgICAgICAgaWYgKG4gPT09IGV2TmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyBzY3JvbGxpbmcgZGlyZWN0aW9uIG9uIG5vZGUuXG4gICAgICpcbiAgICAgKiBUaGlzIHZhbHVlIGlzIGNoZWNrZWQgb24gZmlyc3QgbW92ZSwgdGh1cyBpdCBzaG91bGQgYmUgY2FsbGVkIHByaW9yIHRvXG4gICAgICogYWRkaW5nIGV2ZW50IGxpc3RlbmVycy5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBQb2x5bWVyLkdlc3R1cmVzXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBub2RlIE5vZGUgdG8gc2V0IHRvdWNoIGFjdGlvbiBzZXR0aW5nIG9uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIFRvdWNoIGFjdGlvbiB2YWx1ZVxuICAgICAqL1xuICAgIHNldFRvdWNoQWN0aW9uOiBmdW5jdGlvbihub2RlLCB2YWx1ZSkge1xuICAgICAgaWYgKEhBU19OQVRJVkVfVEEpIHtcbiAgICAgICAgbm9kZS5zdHlsZS50b3VjaEFjdGlvbiA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgbm9kZVtUT1VDSF9BQ1RJT05dID0gdmFsdWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERpc3BhdGNoZXMgYW4gZXZlbnQgb24gdGhlIGB0YXJnZXRgIGVsZW1lbnQgb2YgYHR5cGVgIHdpdGggdGhlIGdpdmVuXG4gICAgICogYGRldGFpbGAuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fSB0YXJnZXQgVGhlIGVsZW1lbnQgb24gd2hpY2ggdG8gZmlyZSBhbiBldmVudC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBUaGUgdHlwZSBvZiBldmVudCB0byBmaXJlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0PX0gZGV0YWlsIFRoZSBkZXRhaWwgb2JqZWN0IHRvIHBvcHVsYXRlIG9uIHRoZSBldmVudC5cbiAgICAgKi9cbiAgICBfZmlyZTogZnVuY3Rpb24odGFyZ2V0LCB0eXBlLCBkZXRhaWwpIHtcbiAgICAgIGxldCBldiA9IG5ldyBFdmVudCh0eXBlLCB7IGJ1YmJsZXM6IHRydWUsIGNhbmNlbGFibGU6IHRydWUsIGNvbXBvc2VkOiB0cnVlIH0pO1xuICAgICAgZXYuZGV0YWlsID0gZGV0YWlsO1xuICAgICAgdGFyZ2V0LmRpc3BhdGNoRXZlbnQoZXYpO1xuICAgICAgLy8gZm9yd2FyZCBgcHJldmVudERlZmF1bHRgIGluIGEgY2xlYW4gd2F5XG4gICAgICBpZiAoZXYuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICBsZXQgcHJldmVudGVyID0gZGV0YWlsLnByZXZlbnRlciB8fCBkZXRhaWwuc291cmNlRXZlbnQ7XG4gICAgICAgIGlmIChwcmV2ZW50ZXIgJiYgcHJldmVudGVyLnByZXZlbnREZWZhdWx0KSB7XG4gICAgICAgICAgcHJldmVudGVyLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUHJldmVudHMgdGhlIGRpc3BhdGNoIGFuZCBkZWZhdWx0IGFjdGlvbiBvZiB0aGUgZ2l2ZW4gZXZlbnQgbmFtZS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBQb2x5bWVyLkdlc3R1cmVzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2TmFtZSBFdmVudCBuYW1lLlxuICAgICAqIEB0aGlzIHtHZXN0dXJlc31cbiAgICAgKi9cbiAgICBwcmV2ZW50OiBmdW5jdGlvbihldk5hbWUpIHtcbiAgICAgIGxldCByZWNvZ25pemVyID0gdGhpcy5fZmluZFJlY29nbml6ZXJCeUV2ZW50KGV2TmFtZSk7XG4gICAgICBpZiAocmVjb2duaXplci5pbmZvKSB7XG4gICAgICAgIHJlY29nbml6ZXIuaW5mby5wcmV2ZW50ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVzZXQgdGhlIDI1MDBtcyB0aW1lb3V0IG9uIHByb2Nlc3NpbmcgbW91c2UgaW5wdXQgYWZ0ZXIgZGV0ZWN0aW5nIHRvdWNoIGlucHV0LlxuICAgICAqXG4gICAgICogVG91Y2ggaW5wdXRzIGNyZWF0ZSBzeW50aGVzaXplZCBtb3VzZSBpbnB1dHMgYW55d2hlcmUgZnJvbSAwIHRvIDIwMDBtcyBhZnRlciB0aGUgdG91Y2guXG4gICAgICogVGhpcyBtZXRob2Qgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIGR1cmluZyB0ZXN0aW5nIHdpdGggc2ltdWxhdGVkIHRvdWNoIGlucHV0cy5cbiAgICAgKiBDYWxsaW5nIHRoaXMgbWV0aG9kIGluIHByb2R1Y3Rpb24gbWF5IGNhdXNlIGR1cGxpY2F0ZSB0YXBzIG9yIG90aGVyIEdlc3R1cmVzLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIFBvbHltZXIuR2VzdHVyZXNcbiAgICAgKi9cbiAgICByZXNldE1vdXNlQ2FuY2VsbGVyOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmIChQT0lOVEVSU1RBVEUubW91c2UubW91c2VJZ25vcmVKb2IpIHtcbiAgICAgICAgUE9JTlRFUlNUQVRFLm1vdXNlLm1vdXNlSWdub3JlSm9iLmZsdXNoKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qIGVzbGludC1kaXNhYmxlIHZhbGlkLWpzZG9jICovXG5cbiAgR2VzdHVyZXMucmVnaXN0ZXIoe1xuICAgIG5hbWU6ICdkb3dudXAnLFxuICAgIGRlcHM6IFsnbW91c2Vkb3duJywgJ3RvdWNoc3RhcnQnLCAndG91Y2hlbmQnXSxcbiAgICBmbG93OiB7XG4gICAgICBzdGFydDogWydtb3VzZWRvd24nLCAndG91Y2hzdGFydCddLFxuICAgICAgZW5kOiBbJ21vdXNldXAnLCAndG91Y2hlbmQnXVxuICAgIH0sXG4gICAgZW1pdHM6IFsnZG93bicsICd1cCddLFxuXG4gICAgaW5mbzoge1xuICAgICAgbW92ZWZuOiBudWxsLFxuICAgICAgdXBmbjogbnVsbFxuICAgIH0sXG5cbiAgICAvKiogQHRoaXMge0dlc3R1cmVSZWNvZ25pemVyfSAqL1xuICAgIHJlc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHVudHJhY2tEb2N1bWVudCh0aGlzLmluZm8pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAdGhpcyB7R2VzdHVyZVJlY29nbml6ZXJ9XG4gICAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBlXG4gICAgICovXG4gICAgbW91c2Vkb3duOiBmdW5jdGlvbihlKSB7XG4gICAgICBpZiAoIWhhc0xlZnRNb3VzZUJ1dHRvbihlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsZXQgdCA9IEdlc3R1cmVzLl9maW5kT3JpZ2luYWxUYXJnZXQoZSk7XG4gICAgICBsZXQgc2VsZiA9IHRoaXM7XG4gICAgICBsZXQgbW92ZWZuID0gZnVuY3Rpb24gbW92ZWZuKGUpIHtcbiAgICAgICAgaWYgKCFoYXNMZWZ0TW91c2VCdXR0b24oZSkpIHtcbiAgICAgICAgICBzZWxmLl9maXJlKCd1cCcsIHQsIGUpO1xuICAgICAgICAgIHVudHJhY2tEb2N1bWVudChzZWxmLmluZm8pO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgbGV0IHVwZm4gPSBmdW5jdGlvbiB1cGZuKGUpIHtcbiAgICAgICAgaWYgKGhhc0xlZnRNb3VzZUJ1dHRvbihlKSkge1xuICAgICAgICAgIHNlbGYuX2ZpcmUoJ3VwJywgdCwgZSk7XG4gICAgICAgIH1cbiAgICAgICAgdW50cmFja0RvY3VtZW50KHNlbGYuaW5mbyk7XG4gICAgICB9O1xuICAgICAgdHJhY2tEb2N1bWVudCh0aGlzLmluZm8sIG1vdmVmbiwgdXBmbik7XG4gICAgICB0aGlzLl9maXJlKCdkb3duJywgdCwgZSk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBAdGhpcyB7R2VzdHVyZVJlY29nbml6ZXJ9XG4gICAgICogQHBhcmFtIHtUb3VjaEV2ZW50fSBlXG4gICAgICovXG4gICAgdG91Y2hzdGFydDogZnVuY3Rpb24oZSkge1xuICAgICAgdGhpcy5fZmlyZSgnZG93bicsIEdlc3R1cmVzLl9maW5kT3JpZ2luYWxUYXJnZXQoZSksIGUuY2hhbmdlZFRvdWNoZXNbMF0sIGUpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQHRoaXMge0dlc3R1cmVSZWNvZ25pemVyfVxuICAgICAqIEBwYXJhbSB7VG91Y2hFdmVudH0gZVxuICAgICAqL1xuICAgIHRvdWNoZW5kOiBmdW5jdGlvbihlKSB7XG4gICAgICB0aGlzLl9maXJlKCd1cCcsIEdlc3R1cmVzLl9maW5kT3JpZ2luYWxUYXJnZXQoZSksIGUuY2hhbmdlZFRvdWNoZXNbMF0sIGUpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fSB0YXJnZXRcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZXZlbnRlclxuICAgICAqL1xuICAgIF9maXJlOiBmdW5jdGlvbih0eXBlLCB0YXJnZXQsIGV2ZW50LCBwcmV2ZW50ZXIpIHtcbiAgICAgIEdlc3R1cmVzLl9maXJlKHRhcmdldCwgdHlwZSwge1xuICAgICAgICB4OiBldmVudC5jbGllbnRYLFxuICAgICAgICB5OiBldmVudC5jbGllbnRZLFxuICAgICAgICBzb3VyY2VFdmVudDogZXZlbnQsXG4gICAgICAgIHByZXZlbnRlcjogcHJldmVudGVyLFxuICAgICAgICBwcmV2ZW50OiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgcmV0dXJuIEdlc3R1cmVzLnByZXZlbnQoZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG5cbiAgR2VzdHVyZXMucmVnaXN0ZXIoe1xuICAgIG5hbWU6ICd0cmFjaycsXG4gICAgdG91Y2hBY3Rpb246ICdub25lJyxcbiAgICBkZXBzOiBbJ21vdXNlZG93bicsICd0b3VjaHN0YXJ0JywgJ3RvdWNobW92ZScsICd0b3VjaGVuZCddLFxuICAgIGZsb3c6IHtcbiAgICAgIHN0YXJ0OiBbJ21vdXNlZG93bicsICd0b3VjaHN0YXJ0J10sXG4gICAgICBlbmQ6IFsnbW91c2V1cCcsICd0b3VjaGVuZCddXG4gICAgfSxcbiAgICBlbWl0czogWyd0cmFjayddLFxuXG4gICAgaW5mbzoge1xuICAgICAgeDogMCxcbiAgICAgIHk6IDAsXG4gICAgICBzdGF0ZTogJ3N0YXJ0JyxcbiAgICAgIHN0YXJ0ZWQ6IGZhbHNlLFxuICAgICAgbW92ZXM6IFtdLFxuICAgICAgLyoqIEB0aGlzIHtHZXN0dXJlUmVjb2duaXplcn0gKi9cbiAgICAgIGFkZE1vdmU6IGZ1bmN0aW9uKG1vdmUpIHtcbiAgICAgICAgaWYgKHRoaXMubW92ZXMubGVuZ3RoID4gVFJBQ0tfTEVOR1RIKSB7XG4gICAgICAgICAgdGhpcy5tb3Zlcy5zaGlmdCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubW92ZXMucHVzaChtb3ZlKTtcbiAgICAgIH0sXG4gICAgICBtb3ZlZm46IG51bGwsXG4gICAgICB1cGZuOiBudWxsLFxuICAgICAgcHJldmVudDogZmFsc2VcbiAgICB9LFxuXG4gICAgLyoqIEB0aGlzIHtHZXN0dXJlUmVjb2duaXplcn0gKi9cbiAgICByZXNldDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmluZm8uc3RhdGUgPSAnc3RhcnQnO1xuICAgICAgdGhpcy5pbmZvLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuaW5mby5tb3ZlcyA9IFtdO1xuICAgICAgdGhpcy5pbmZvLnggPSAwO1xuICAgICAgdGhpcy5pbmZvLnkgPSAwO1xuICAgICAgdGhpcy5pbmZvLnByZXZlbnQgPSBmYWxzZTtcbiAgICAgIHVudHJhY2tEb2N1bWVudCh0aGlzLmluZm8pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAdGhpcyB7R2VzdHVyZVJlY29nbml6ZXJ9XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgaGFzTW92ZWRFbm91Z2g6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgIGlmICh0aGlzLmluZm8ucHJldmVudCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5pbmZvLnN0YXJ0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBsZXQgZHggPSBNYXRoLmFicyh0aGlzLmluZm8ueCAtIHgpO1xuICAgICAgbGV0IGR5ID0gTWF0aC5hYnModGhpcy5pbmZvLnkgLSB5KTtcbiAgICAgIHJldHVybiAoZHggPj0gVFJBQ0tfRElTVEFOQ0UgfHwgZHkgPj0gVFJBQ0tfRElTVEFOQ0UpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQHRoaXMge0dlc3R1cmVSZWNvZ25pemVyfVxuICAgICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZVxuICAgICAqL1xuICAgIG1vdXNlZG93bjogZnVuY3Rpb24oZSkge1xuICAgICAgaWYgKCFoYXNMZWZ0TW91c2VCdXR0b24oZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGV0IHQgPSBHZXN0dXJlcy5fZmluZE9yaWdpbmFsVGFyZ2V0KGUpO1xuICAgICAgbGV0IHNlbGYgPSB0aGlzO1xuICAgICAgbGV0IG1vdmVmbiA9IGZ1bmN0aW9uIG1vdmVmbihlKSB7XG4gICAgICAgIGxldCB4ID0gZS5jbGllbnRYLCB5ID0gZS5jbGllbnRZO1xuICAgICAgICBpZiAoc2VsZi5oYXNNb3ZlZEVub3VnaCh4LCB5KSkge1xuICAgICAgICAgIC8vIGZpcnN0IG1vdmUgaXMgJ3N0YXJ0Jywgc3Vic2VxdWVudCBtb3ZlcyBhcmUgJ21vdmUnLCBtb3VzZXVwIGlzICdlbmQnXG4gICAgICAgICAgc2VsZi5pbmZvLnN0YXRlID0gc2VsZi5pbmZvLnN0YXJ0ZWQgPyAoZS50eXBlID09PSAnbW91c2V1cCcgPyAnZW5kJyA6ICd0cmFjaycpIDogJ3N0YXJ0JztcbiAgICAgICAgICBpZiAoc2VsZi5pbmZvLnN0YXRlID09PSAnc3RhcnQnKSB7XG4gICAgICAgICAgICAvLyBpZiBhbmQgb25seSBpZiB0cmFja2luZywgYWx3YXlzIHByZXZlbnQgdGFwXG4gICAgICAgICAgICBHZXN0dXJlcy5wcmV2ZW50KCd0YXAnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2VsZi5pbmZvLmFkZE1vdmUoe3g6IHgsIHk6IHl9KTtcbiAgICAgICAgICBpZiAoIWhhc0xlZnRNb3VzZUJ1dHRvbihlKSkge1xuICAgICAgICAgICAgLy8gYWx3YXlzIF9maXJlIFwiZW5kXCJcbiAgICAgICAgICAgIHNlbGYuaW5mby5zdGF0ZSA9ICdlbmQnO1xuICAgICAgICAgICAgdW50cmFja0RvY3VtZW50KHNlbGYuaW5mbyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNlbGYuX2ZpcmUodCwgZSk7XG4gICAgICAgICAgc2VsZi5pbmZvLnN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgbGV0IHVwZm4gPSBmdW5jdGlvbiB1cGZuKGUpIHtcbiAgICAgICAgaWYgKHNlbGYuaW5mby5zdGFydGVkKSB7XG4gICAgICAgICAgbW92ZWZuKGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVtb3ZlIHRoZSB0ZW1wb3JhcnkgbGlzdGVuZXJzXG4gICAgICAgIHVudHJhY2tEb2N1bWVudChzZWxmLmluZm8pO1xuICAgICAgfTtcbiAgICAgIC8vIGFkZCB0ZW1wb3JhcnkgZG9jdW1lbnQgbGlzdGVuZXJzIGFzIG1vdXNlIHJldGFyZ2V0c1xuICAgICAgdHJhY2tEb2N1bWVudCh0aGlzLmluZm8sIG1vdmVmbiwgdXBmbik7XG4gICAgICB0aGlzLmluZm8ueCA9IGUuY2xpZW50WDtcbiAgICAgIHRoaXMuaW5mby55ID0gZS5jbGllbnRZO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQHRoaXMge0dlc3R1cmVSZWNvZ25pemVyfVxuICAgICAqIEBwYXJhbSB7VG91Y2hFdmVudH0gZVxuICAgICAqL1xuICAgIHRvdWNoc3RhcnQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgIGxldCBjdCA9IGUuY2hhbmdlZFRvdWNoZXNbMF07XG4gICAgICB0aGlzLmluZm8ueCA9IGN0LmNsaWVudFg7XG4gICAgICB0aGlzLmluZm8ueSA9IGN0LmNsaWVudFk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBAdGhpcyB7R2VzdHVyZVJlY29nbml6ZXJ9XG4gICAgICogQHBhcmFtIHtUb3VjaEV2ZW50fSBlXG4gICAgICovXG4gICAgdG91Y2htb3ZlOiBmdW5jdGlvbihlKSB7XG4gICAgICBsZXQgdCA9IEdlc3R1cmVzLl9maW5kT3JpZ2luYWxUYXJnZXQoZSk7XG4gICAgICBsZXQgY3QgPSBlLmNoYW5nZWRUb3VjaGVzWzBdO1xuICAgICAgbGV0IHggPSBjdC5jbGllbnRYLCB5ID0gY3QuY2xpZW50WTtcbiAgICAgIGlmICh0aGlzLmhhc01vdmVkRW5vdWdoKHgsIHkpKSB7XG4gICAgICAgIGlmICh0aGlzLmluZm8uc3RhdGUgPT09ICdzdGFydCcpIHtcbiAgICAgICAgICAvLyBpZiBhbmQgb25seSBpZiB0cmFja2luZywgYWx3YXlzIHByZXZlbnQgdGFwXG4gICAgICAgICAgR2VzdHVyZXMucHJldmVudCgndGFwJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbmZvLmFkZE1vdmUoe3g6IHgsIHk6IHl9KTtcbiAgICAgICAgdGhpcy5fZmlyZSh0LCBjdCk7XG4gICAgICAgIHRoaXMuaW5mby5zdGF0ZSA9ICd0cmFjayc7XG4gICAgICAgIHRoaXMuaW5mby5zdGFydGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEB0aGlzIHtHZXN0dXJlUmVjb2duaXplcn1cbiAgICAgKiBAcGFyYW0ge1RvdWNoRXZlbnR9IGVcbiAgICAgKi9cbiAgICB0b3VjaGVuZDogZnVuY3Rpb24oZSkge1xuICAgICAgbGV0IHQgPSBHZXN0dXJlcy5fZmluZE9yaWdpbmFsVGFyZ2V0KGUpO1xuICAgICAgbGV0IGN0ID0gZS5jaGFuZ2VkVG91Y2hlc1swXTtcbiAgICAgIC8vIG9ubHkgdHJhY2tlbmQgaWYgdHJhY2sgd2FzIHN0YXJ0ZWQgYW5kIG5vdCBhYm9ydGVkXG4gICAgICBpZiAodGhpcy5pbmZvLnN0YXJ0ZWQpIHtcbiAgICAgICAgLy8gcmVzZXQgc3RhcnRlZCBzdGF0ZSBvbiB1cFxuICAgICAgICB0aGlzLmluZm8uc3RhdGUgPSAnZW5kJztcbiAgICAgICAgdGhpcy5pbmZvLmFkZE1vdmUoe3g6IGN0LmNsaWVudFgsIHk6IGN0LmNsaWVudFl9KTtcbiAgICAgICAgdGhpcy5fZmlyZSh0LCBjdCwgZSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEB0aGlzIHtHZXN0dXJlUmVjb2duaXplcn1cbiAgICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fSB0YXJnZXRcbiAgICAgKiBAcGFyYW0ge1RvdWNofSB0b3VjaFxuICAgICAqL1xuICAgIF9maXJlOiBmdW5jdGlvbih0YXJnZXQsIHRvdWNoKSB7XG4gICAgICBsZXQgc2Vjb25kbGFzdCA9IHRoaXMuaW5mby5tb3Zlc1t0aGlzLmluZm8ubW92ZXMubGVuZ3RoIC0gMl07XG4gICAgICBsZXQgbGFzdG1vdmUgPSB0aGlzLmluZm8ubW92ZXNbdGhpcy5pbmZvLm1vdmVzLmxlbmd0aCAtIDFdO1xuICAgICAgbGV0IGR4ID0gbGFzdG1vdmUueCAtIHRoaXMuaW5mby54O1xuICAgICAgbGV0IGR5ID0gbGFzdG1vdmUueSAtIHRoaXMuaW5mby55O1xuICAgICAgbGV0IGRkeCwgZGR5ID0gMDtcbiAgICAgIGlmIChzZWNvbmRsYXN0KSB7XG4gICAgICAgIGRkeCA9IGxhc3Rtb3ZlLnggLSBzZWNvbmRsYXN0Lng7XG4gICAgICAgIGRkeSA9IGxhc3Rtb3ZlLnkgLSBzZWNvbmRsYXN0Lnk7XG4gICAgICB9XG4gICAgICBHZXN0dXJlcy5fZmlyZSh0YXJnZXQsICd0cmFjaycsIHtcbiAgICAgICAgc3RhdGU6IHRoaXMuaW5mby5zdGF0ZSxcbiAgICAgICAgeDogdG91Y2guY2xpZW50WCxcbiAgICAgICAgeTogdG91Y2guY2xpZW50WSxcbiAgICAgICAgZHg6IGR4LFxuICAgICAgICBkeTogZHksXG4gICAgICAgIGRkeDogZGR4LFxuICAgICAgICBkZHk6IGRkeSxcbiAgICAgICAgc291cmNlRXZlbnQ6IHRvdWNoLFxuICAgICAgICBob3ZlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIEdlc3R1cmVzLmRlZXBUYXJnZXRGaW5kKHRvdWNoLmNsaWVudFgsIHRvdWNoLmNsaWVudFkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgfSk7XG5cbiAgR2VzdHVyZXMucmVnaXN0ZXIoe1xuICAgIG5hbWU6ICd0YXAnLFxuICAgIGRlcHM6IFsnbW91c2Vkb3duJywgJ2NsaWNrJywgJ3RvdWNoc3RhcnQnLCAndG91Y2hlbmQnXSxcbiAgICBmbG93OiB7XG4gICAgICBzdGFydDogWydtb3VzZWRvd24nLCAndG91Y2hzdGFydCddLFxuICAgICAgZW5kOiBbJ2NsaWNrJywgJ3RvdWNoZW5kJ11cbiAgICB9LFxuICAgIGVtaXRzOiBbJ3RhcCddLFxuICAgIGluZm86IHtcbiAgICAgIHg6IE5hTixcbiAgICAgIHk6IE5hTixcbiAgICAgIHByZXZlbnQ6IGZhbHNlXG4gICAgfSxcbiAgICAvKiogQHRoaXMge0dlc3R1cmVSZWNvZ25pemVyfSAqL1xuICAgIHJlc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuaW5mby54ID0gTmFOO1xuICAgICAgdGhpcy5pbmZvLnkgPSBOYU47XG4gICAgICB0aGlzLmluZm8ucHJldmVudCA9IGZhbHNlO1xuICAgIH0sXG4gICAgLyoqIEB0aGlzIHtHZXN0dXJlUmVjb2duaXplcn0gKi9cbiAgICBzYXZlOiBmdW5jdGlvbihlKSB7XG4gICAgICB0aGlzLmluZm8ueCA9IGUuY2xpZW50WDtcbiAgICAgIHRoaXMuaW5mby55ID0gZS5jbGllbnRZO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQHRoaXMge0dlc3R1cmVSZWNvZ25pemVyfVxuICAgICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZVxuICAgICAqL1xuICAgIG1vdXNlZG93bjogZnVuY3Rpb24oZSkge1xuICAgICAgaWYgKGhhc0xlZnRNb3VzZUJ1dHRvbihlKSkge1xuICAgICAgICB0aGlzLnNhdmUoZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBAdGhpcyB7R2VzdHVyZVJlY29nbml6ZXJ9XG4gICAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBlXG4gICAgICovXG4gICAgY2xpY2s6IGZ1bmN0aW9uKGUpIHtcbiAgICAgIGlmIChoYXNMZWZ0TW91c2VCdXR0b24oZSkpIHtcbiAgICAgICAgdGhpcy5mb3J3YXJkKGUpO1xuICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogQHRoaXMge0dlc3R1cmVSZWNvZ25pemVyfVxuICAgICAqIEBwYXJhbSB7VG91Y2hFdmVudH0gZVxuICAgICAqL1xuICAgIHRvdWNoc3RhcnQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgIHRoaXMuc2F2ZShlLmNoYW5nZWRUb3VjaGVzWzBdLCBlKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEB0aGlzIHtHZXN0dXJlUmVjb2duaXplcn1cbiAgICAgKiBAcGFyYW0ge1RvdWNoRXZlbnR9IGVcbiAgICAgKi9cbiAgICB0b3VjaGVuZDogZnVuY3Rpb24oZSkge1xuICAgICAgdGhpcy5mb3J3YXJkKGUuY2hhbmdlZFRvdWNoZXNbMF0sIGUpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQHRoaXMge0dlc3R1cmVSZWNvZ25pemVyfVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmV2ZW50ZXJcbiAgICAgKi9cbiAgICBmb3J3YXJkOiBmdW5jdGlvbihlLCBwcmV2ZW50ZXIpIHtcbiAgICAgIGxldCBkeCA9IE1hdGguYWJzKGUuY2xpZW50WCAtIHRoaXMuaW5mby54KTtcbiAgICAgIGxldCBkeSA9IE1hdGguYWJzKGUuY2xpZW50WSAtIHRoaXMuaW5mby55KTtcbiAgICAgIGxldCB0ID0gR2VzdHVyZXMuX2ZpbmRPcmlnaW5hbFRhcmdldChlKTtcbiAgICAgIC8vIGR4LGR5IGNhbiBiZSBOYU4gaWYgYGNsaWNrYCBoYXMgYmVlbiBzaW11bGF0ZWQgYW5kIHRoZXJlIHdhcyBubyBgZG93bmAgZm9yIGBzdGFydGBcbiAgICAgIGlmIChpc05hTihkeCkgfHwgaXNOYU4oZHkpIHx8IChkeCA8PSBUQVBfRElTVEFOQ0UgJiYgZHkgPD0gVEFQX0RJU1RBTkNFKSB8fCBpc1N5bnRoZXRpY0NsaWNrKGUpKSB7XG4gICAgICAgIC8vIHByZXZlbnQgdGFwcyBmcm9tIGJlaW5nIGdlbmVyYXRlZCBpZiBhbiBldmVudCBoYXMgY2FuY2VsZWQgdGhlbVxuICAgICAgICBpZiAoIXRoaXMuaW5mby5wcmV2ZW50KSB7XG4gICAgICAgICAgR2VzdHVyZXMuX2ZpcmUodCwgJ3RhcCcsIHtcbiAgICAgICAgICAgIHg6IGUuY2xpZW50WCxcbiAgICAgICAgICAgIHk6IGUuY2xpZW50WSxcbiAgICAgICAgICAgIHNvdXJjZUV2ZW50OiBlLFxuICAgICAgICAgICAgcHJldmVudGVyOiBwcmV2ZW50ZXJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgLyogZXNsaW50LWVuYWJsZSB2YWxpZC1qc2RvYyAqL1xuXG4gIC8qKiBAZGVwcmVjYXRlZCAqL1xuICBHZXN0dXJlcy5maW5kT3JpZ2luYWxUYXJnZXQgPSBHZXN0dXJlcy5fZmluZE9yaWdpbmFsVGFyZ2V0O1xuXG4gIC8qKiBAZGVwcmVjYXRlZCAqL1xuICBHZXN0dXJlcy5hZGQgPSBHZXN0dXJlcy5hZGRMaXN0ZW5lcjtcblxuICAvKiogQGRlcHJlY2F0ZWQgKi9cbiAgR2VzdHVyZXMucmVtb3ZlID0gR2VzdHVyZXMucmVtb3ZlTGlzdGVuZXI7XG5cbiAgUG9seW1lci5HZXN0dXJlcyA9IEdlc3R1cmVzO1xuXG59KSgpO1xuPC9zY3JpcHQ+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL3BvbHltZXIvbGliL3V0aWxzL2dlc3R1cmVzLmh0bWwiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCJib290Lmh0bWxcIj5cblxuPHNjcmlwdD5cblxuKGZ1bmN0aW9uKCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICAvLyBydW4gYSBjYWxsYmFjayB3aGVuIEhUTUxJbXBvcnRzIGFyZSByZWFkeSBvciBpbW1lZGlhdGVseSBpZlxuICAvLyB0aGlzIGFwaSBpcyBub3QgYXZhaWxhYmxlLlxuICBmdW5jdGlvbiB3aGVuSW1wb3J0c1JlYWR5KGNiKSB7XG4gICAgaWYgKHdpbmRvdy5IVE1MSW1wb3J0cykge1xuICAgICAgSFRNTEltcG9ydHMud2hlblJlYWR5KGNiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2IoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ29udmVuaWVuY2UgbWV0aG9kIGZvciBpbXBvcnRpbmcgYW4gSFRNTCBkb2N1bWVudCBpbXBlcmF0aXZlbHkuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGNyZWF0ZXMgYSBuZXcgYDxsaW5rIHJlbD1cImltcG9ydFwiPmAgZWxlbWVudCB3aXRoXG4gICAqIHRoZSBwcm92aWRlZCBVUkwgYW5kIGFwcGVuZHMgaXQgdG8gdGhlIGRvY3VtZW50IHRvIHN0YXJ0IGxvYWRpbmcuXG4gICAqIEluIHRoZSBgb25sb2FkYCBjYWxsYmFjaywgdGhlIGBpbXBvcnRgIHByb3BlcnR5IG9mIHRoZSBgbGlua2BcbiAgICogZWxlbWVudCB3aWxsIGNvbnRhaW4gdGhlIGltcG9ydGVkIGRvY3VtZW50IGNvbnRlbnRzLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgUG9seW1lclxuICAgKiBAcGFyYW0ge3N0cmluZ30gaHJlZiBVUkwgdG8gZG9jdW1lbnQgdG8gbG9hZC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IG9ubG9hZCBDYWxsYmFjayB0byBub3RpZnkgd2hlbiBhbiBpbXBvcnQgc3VjY2Vzc2Z1bGx5XG4gICAqICAgbG9hZGVkLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uPX0gb25lcnJvciBDYWxsYmFjayB0byBub3RpZnkgd2hlbiBhbiBpbXBvcnRcbiAgICogICB1bnN1Y2Nlc3NmdWxseSBsb2FkZWQuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IG9wdEFzeW5jIFRydWUgaWYgdGhlIGltcG9ydCBzaG91bGQgYmUgbG9hZGVkIGBhc3luY2AuXG4gICAqICAgRGVmYXVsdHMgdG8gYGZhbHNlYC5cbiAgICogQHJldHVybiB7SFRNTExpbmtFbGVtZW50fSBUaGUgbGluayBlbGVtZW50IGZvciB0aGUgVVJMIHRvIGJlIGxvYWRlZC5cbiAgICovXG4gIFBvbHltZXIuaW1wb3J0SHJlZiA9IGZ1bmN0aW9uKGhyZWYsIG9ubG9hZCwgb25lcnJvciwgb3B0QXN5bmMpIHtcbiAgICBsZXQgbGluayA9IC8qKiBAdHlwZSB7SFRNTExpbmtFbGVtZW50fSAqL1xuICAgICAgKGRvY3VtZW50LmhlYWQucXVlcnlTZWxlY3RvcignbGlua1tocmVmPVwiJyArIGhyZWYgKyAnXCJdW2ltcG9ydC1ocmVmXScpKTtcbiAgICBpZiAoIWxpbmspIHtcbiAgICAgIGxpbmsgPSAvKiogQHR5cGUge0hUTUxMaW5rRWxlbWVudH0gKi8gKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpbmsnKSk7XG4gICAgICBsaW5rLnJlbCA9ICdpbXBvcnQnO1xuICAgICAgbGluay5ocmVmID0gaHJlZjtcbiAgICAgIGxpbmsuc2V0QXR0cmlidXRlKCdpbXBvcnQtaHJlZicsICcnKTtcbiAgICB9XG4gICAgLy8gYWx3YXlzIGVuc3VyZSBsaW5rIGhhcyBgYXN5bmNgIGF0dHJpYnV0ZSBpZiB1c2VyIHNwZWNpZmllZCBvbmUsXG4gICAgLy8gZXZlbiBpZiBpdCB3YXMgcHJldmlvdXNseSBub3QgYXN5bmMuIFRoaXMgaXMgY29uc2lkZXJlZCBsZXNzIGNvbmZ1c2luZy5cbiAgICBpZiAob3B0QXN5bmMpIHtcbiAgICAgIGxpbmsuc2V0QXR0cmlidXRlKCdhc3luYycsICcnKTtcbiAgICB9XG4gICAgLy8gTk9URTogdGhlIGxpbmsgbWF5IG5vdyBiZSBpbiAzIHN0YXRlczogKDEpIHBlbmRpbmcgaW5zZXJ0aW9uLFxuICAgIC8vICgyKSBpbmZsaWdodCwgKDMpIGFscmVhZHkgbGFvZGVkLiBJbiBlYWNoIGNhc2UsIHdlIG5lZWQgdG8gYWRkXG4gICAgLy8gZXZlbnQgbGlzdGVuZXJzIHRvIHByb2Nlc3MgY2FsbGJhY2tzLlxuICAgIGxldCBjbGVhbnVwID0gZnVuY3Rpb24oKSB7XG4gICAgICBsaW5rLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBsb2FkTGlzdGVuZXIpO1xuICAgICAgbGluay5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsIGVycm9yTGlzdGVuZXIpO1xuICAgIH1cbiAgICBsZXQgbG9hZExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIGNsZWFudXAoKTtcbiAgICAgIC8vIEluIGNhc2Ugb2YgYSBzdWNjZXNzZnVsIGxvYWQsIGNhY2hlIHRoZSBsb2FkIGV2ZW50IG9uIHRoZSBsaW5rIHNvXG4gICAgICAvLyB0aGF0IGl0IGNhbiBiZSB1c2VkIHRvIHNob3J0LWNpcmN1aXQgdGhpcyBtZXRob2QgaW4gdGhlIGZ1dHVyZSB3aGVuXG4gICAgICAvLyBpdCBpcyBjYWxsZWQgd2l0aCB0aGUgc2FtZSBocmVmIHBhcmFtLlxuICAgICAgbGluay5fX2R5bmFtaWNJbXBvcnRMb2FkZWQgPSB0cnVlO1xuICAgICAgaWYgKG9ubG9hZCkge1xuICAgICAgICB3aGVuSW1wb3J0c1JlYWR5KCgpID0+IHtcbiAgICAgICAgICBvbmxvYWQoZXZlbnQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGxldCBlcnJvckxpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIGNsZWFudXAoKTtcbiAgICAgIC8vIEluIGNhc2Ugb2YgYW4gZXJyb3IsIHJlbW92ZSB0aGUgbGluayBmcm9tIHRoZSBkb2N1bWVudCBzbyB0aGF0IGl0XG4gICAgICAvLyB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgY3JlYXRlZCBhZ2FpbiB0aGUgbmV4dCB0aW1lIGBpbXBvcnRIcmVmYCBpc1xuICAgICAgLy8gY2FsbGVkLlxuICAgICAgaWYgKGxpbmsucGFyZW50Tm9kZSkge1xuICAgICAgICBsaW5rLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobGluayk7XG4gICAgICB9XG4gICAgICBpZiAob25lcnJvcikge1xuICAgICAgICB3aGVuSW1wb3J0c1JlYWR5KCgpID0+IHtcbiAgICAgICAgICBvbmVycm9yKGV2ZW50KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBsaW5rLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBsb2FkTGlzdGVuZXIpO1xuICAgIGxpbmsuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBlcnJvckxpc3RlbmVyKTtcbiAgICBpZiAobGluay5wYXJlbnROb2RlID09IG51bGwpIHtcbiAgICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQobGluayk7XG4gICAgLy8gaWYgdGhlIGxpbmsgYWxyZWFkeSBsb2FkZWQsIGRpc3BhdGNoIGEgZmFrZSBsb2FkIGV2ZW50XG4gICAgLy8gc28gdGhhdCBsaXN0ZW5lcnMgYXJlIGNhbGxlZCBhbmQgZ2V0IGEgcHJvcGVyIGV2ZW50IGFyZ3VtZW50LlxuICAgIH0gZWxzZSBpZiAobGluay5fX2R5bmFtaWNJbXBvcnRMb2FkZWQpIHtcbiAgICAgIGxpbmsuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ2xvYWQnKSk7XG4gICAgfVxuICAgIHJldHVybiBsaW5rO1xuICB9O1xuXG59KSgpO1xuPC9zY3JpcHQ+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL3BvbHltZXIvbGliL3V0aWxzL2ltcG9ydC1ocmVmLmh0bWwiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiYm9vdC5odG1sXCI+XG5cbjxzY3JpcHQ+XG4oZnVuY3Rpb24oKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIGxldCBzY2hlZHVsZWQgPSBmYWxzZTtcbiAgbGV0IGJlZm9yZVJlbmRlclF1ZXVlID0gW107XG4gIGxldCBhZnRlclJlbmRlclF1ZXVlID0gW107XG5cbiAgZnVuY3Rpb24gc2NoZWR1bGUoKSB7XG4gICAgc2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAvLyBiZWZvcmUgbmV4dCByZW5kZXJcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKSB7XG4gICAgICBzY2hlZHVsZWQgPSBmYWxzZTtcbiAgICAgIGZsdXNoUXVldWUoYmVmb3JlUmVuZGVyUXVldWUpO1xuICAgICAgLy8gYWZ0ZXIgdGhlIHJlbmRlclxuICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgcnVuUXVldWUoYWZ0ZXJSZW5kZXJRdWV1ZSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZsdXNoUXVldWUocXVldWUpIHtcbiAgICB3aGlsZSAocXVldWUubGVuZ3RoKSB7XG4gICAgICBjYWxsTWV0aG9kKHF1ZXVlLnNoaWZ0KCkpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJ1blF1ZXVlKHF1ZXVlKSB7XG4gICAgZm9yIChsZXQgaT0wLCBsPXF1ZXVlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgY2FsbE1ldGhvZChxdWV1ZS5zaGlmdCgpKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjYWxsTWV0aG9kKGluZm8pIHtcbiAgICBjb25zdCBjb250ZXh0ID0gaW5mb1swXTtcbiAgICBjb25zdCBjYWxsYmFjayA9IGluZm9bMV07XG4gICAgY29uc3QgYXJncyA9IGluZm9bMl07XG4gICAgdHJ5IHtcbiAgICAgIGNhbGxiYWNrLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgIH0gY2F0Y2goZSkge1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGZsdXNoKCkge1xuICAgIHdoaWxlIChiZWZvcmVSZW5kZXJRdWV1ZS5sZW5ndGggfHwgYWZ0ZXJSZW5kZXJRdWV1ZS5sZW5ndGgpIHtcbiAgICAgIGZsdXNoUXVldWUoYmVmb3JlUmVuZGVyUXVldWUpO1xuICAgICAgZmx1c2hRdWV1ZShhZnRlclJlbmRlclF1ZXVlKTtcbiAgICB9XG4gICAgc2NoZWR1bGVkID0gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogTW9kdWxlIGZvciBzY2hlZHVsaW5nIGZsdXNoYWJsZSBwcmUtcmVuZGVyIGFuZCBwb3N0LXJlbmRlciB0YXNrcy5cbiAgICpcbiAgICogQG5hbWVzcGFjZVxuICAgKiBAbWVtYmVyb2YgUG9seW1lclxuICAgKiBAc3VtbWFyeSBNb2R1bGUgZm9yIHNjaGVkdWxpbmcgZmx1c2hhYmxlIHByZS1yZW5kZXIgYW5kIHBvc3QtcmVuZGVyIHRhc2tzLlxuICAgKi9cbiAgUG9seW1lci5SZW5kZXJTdGF0dXMgPSB7XG5cbiAgICAvKipcbiAgICAgKiBFbnF1ZXVlcyBhIGNhbGxiYWNrIHdoaWNoIHdpbGwgYmUgcnVuIGJlZm9yZSB0aGUgbmV4dCByZW5kZXIsIGF0XG4gICAgICogYHJlcXVlc3RBbmltYXRpb25GcmFtZWAgdGltaW5nLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgaXMgdXNlZnVsIGZvciBlbnF1ZXVpbmcgd29yayB0aGF0IHJlcXVpcmVzIERPTSBtZWFzdXJlbWVudCxcbiAgICAgKiBzaW5jZSBtZWFzdXJlbWVudCBtYXkgbm90IGJlIHJlbGlhYmxlIGluIGN1c3RvbSBlbGVtZW50IGNhbGxiYWNrcyBiZWZvcmVcbiAgICAgKiB0aGUgZmlyc3QgcmVuZGVyLCBhcyB3ZWxsIGFzIGZvciBiYXRjaGluZyBtZWFzdXJlbWVudCB0YXNrcyBpbiBnZW5lcmFsLlxuICAgICAqXG4gICAgICogVGFza3MgaW4gdGhpcyBxdWV1ZSBtYXkgYmUgZmx1c2hlZCBieSBjYWxsaW5nIGBQb2x5bWVyLlJlbmRlclN0YXR1cy5mbHVzaCgpYC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBQb2x5bWVyLlJlbmRlclN0YXR1c1xuICAgICAqIEBwYXJhbSB7Kn0gY29udGV4dCBDb250ZXh0IG9iamVjdCB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gd2lsbCBiZSBib3VuZCB0b1xuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oKX0gY2FsbGJhY2sgQ2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcmdzIEFuIGFycmF5IG9mIGFyZ3VtZW50cyB0byBjYWxsIHRoZSBjYWxsYmFjayBmdW5jdGlvbiB3aXRoXG4gICAgICovXG4gICAgYmVmb3JlTmV4dFJlbmRlcjogZnVuY3Rpb24oY29udGV4dCwgY2FsbGJhY2ssIGFyZ3MpIHtcbiAgICAgIGlmICghc2NoZWR1bGVkKSB7XG4gICAgICAgIHNjaGVkdWxlKCk7XG4gICAgICB9XG4gICAgICBiZWZvcmVSZW5kZXJRdWV1ZS5wdXNoKFtjb250ZXh0LCBjYWxsYmFjaywgYXJnc10pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBFbnF1ZXVlcyBhIGNhbGxiYWNrIHdoaWNoIHdpbGwgYmUgcnVuIGFmdGVyIHRoZSBuZXh0IHJlbmRlciwgZXF1aXZhbGVudFxuICAgICAqIHRvIG9uZSB0YXNrIChgc2V0VGltZW91dGApIGFmdGVyIHRoZSBuZXh0IGByZXF1ZXN0QW5pbWF0aW9uRnJhbWVgLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgaXMgdXNlZnVsIGZvciB0dW5pbmcgdGhlIGZpcnN0LXJlbmRlciBwZXJmb3JtYW5jZSBvZiBhblxuICAgICAqIGVsZW1lbnQgb3IgYXBwbGljYXRpb24gYnkgZGVmZXJyaW5nIG5vbi1jcml0aWNhbCB3b3JrIHVudGlsIGFmdGVyIHRoZVxuICAgICAqIGZpcnN0IHBhaW50LiAgVHlwaWNhbCBub24tcmVuZGVyLWNyaXRpY2FsIHdvcmsgbWF5IGluY2x1ZGUgYWRkaW5nIFVJXG4gICAgICogZXZlbnQgbGlzdGVuZXJzIGFuZCBhcmlhIGF0dHJpYnV0ZXMuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgUG9seW1lci5SZW5kZXJTdGF0dXNcbiAgICAgKiBAcGFyYW0geyp9IGNvbnRleHQgQ29udGV4dCBvYmplY3QgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHdpbGwgYmUgYm91bmQgdG9cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCl9IGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJncyBBbiBhcnJheSBvZiBhcmd1bWVudHMgdG8gY2FsbCB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gd2l0aFxuICAgICAqL1xuICAgIGFmdGVyTmV4dFJlbmRlcjogZnVuY3Rpb24oY29udGV4dCwgY2FsbGJhY2ssIGFyZ3MpIHtcbiAgICAgIGlmICghc2NoZWR1bGVkKSB7XG4gICAgICAgIHNjaGVkdWxlKCk7XG4gICAgICB9XG4gICAgICBhZnRlclJlbmRlclF1ZXVlLnB1c2goW2NvbnRleHQsIGNhbGxiYWNrLCBhcmdzXSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZsdXNoZXMgYWxsIGBiZWZvcmVOZXh0UmVuZGVyYCB0YXNrcywgZm9sbG93ZWQgYnkgYWxsIGBhZnRlck5leHRSZW5kZXJgXG4gICAgICogdGFza3MuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgUG9seW1lci5SZW5kZXJTdGF0dXNcbiAgICAgKi9cbiAgICBmbHVzaDogZmx1c2hcblxuICB9O1xuXG59KSgpO1xuPC9zY3JpcHQ+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL3BvbHltZXIvbGliL3V0aWxzL3JlbmRlci1zdGF0dXMuaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cbjxzY3JpcHQ+XG4oZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvLyB1bnJlc29sdmVkXG5cbiAgZnVuY3Rpb24gcmVzb2x2ZSgpIHtcbiAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUF0dHJpYnV0ZSgndW5yZXNvbHZlZCcpO1xuICB9XG5cbiAgaWYgKHdpbmRvdy5XZWJDb21wb25lbnRzKSB7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ1dlYkNvbXBvbmVudHNSZWFkeScsIHJlc29sdmUpO1xuICB9IGVsc2Uge1xuICAgIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnaW50ZXJhY3RpdmUnIHx8IGRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdjb21wbGV0ZScpIHtcbiAgICAgIHJlc29sdmUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCByZXNvbHZlKTtcbiAgICB9XG4gIH1cblxufSkoKTtcbjwvc2NyaXB0PlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi91dGlscy91bnJlc29sdmVkLmh0bWwiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vdXRpbHMvYm9vdC5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vdXRpbHMvc2V0dGluZ3MuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3V0aWxzL2ZsYXR0ZW5lZC1ub2Rlcy1vYnNlcnZlci5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vdXRpbHMvZmx1c2guaHRtbFwiPlxuPHNjcmlwdD5cbihmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIGNvbnN0IHAgPSBFbGVtZW50LnByb3RvdHlwZTtcbiAgLyoqXG4gICAqIEBjb25zdCB7ZnVuY3Rpb24odGhpczpFbGVtZW50LCBzdHJpbmcpOiBib29sZWFufVxuICAgKi9cbiAgY29uc3Qgbm9ybWFsaXplZE1hdGNoZXNTZWxlY3RvciA9IHAubWF0Y2hlcyB8fCBwLm1hdGNoZXNTZWxlY3RvciB8fFxuICAgIHAubW96TWF0Y2hlc1NlbGVjdG9yIHx8IHAubXNNYXRjaGVzU2VsZWN0b3IgfHxcbiAgICBwLm9NYXRjaGVzU2VsZWN0b3IgfHwgcC53ZWJraXRNYXRjaGVzU2VsZWN0b3I7XG5cbiAgLyoqXG4gICAqIENyb3NzLXBsYXRmb3JtIGBlbGVtZW50Lm1hdGNoZXNgIHNoaW0uXG4gICAqXG4gICAqIEBmdW5jdGlvbiBtYXRjaGVzU2VsZWN0b3JcbiAgICogQG1lbWJlcm9mIFBvbHltZXIuZG9tXG4gICAqIEBwYXJhbSB7IUVsZW1lbnR9IG5vZGUgTm9kZSB0byBjaGVjayBzZWxlY3RvciBhZ2FpbnN0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzZWxlY3RvciBTZWxlY3RvciB0byBtYXRjaFxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIG5vZGUgbWF0Y2hlZCBzZWxlY3RvclxuICAgKi9cbiAgY29uc3QgbWF0Y2hlc1NlbGVjdG9yID0gZnVuY3Rpb24obm9kZSwgc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gbm9ybWFsaXplZE1hdGNoZXNTZWxlY3Rvci5jYWxsKG5vZGUsIHNlbGVjdG9yKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBOb2RlIEFQSSB3cmFwcGVyIGNsYXNzIHJldHVybmVkIGZyb20gYFBvbHltZXIuZG9tLih0YXJnZXQpYCB3aGVuXG4gICAqIGB0YXJnZXRgIGlzIGEgYE5vZGVgLlxuICAgKi9cbiAgY2xhc3MgRG9tQXBpIHtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBOb2RlIGZvciB3aGljaCB0byBjcmVhdGUgYSBQb2x5bWVyLmRvbSBoZWxwZXIgb2JqZWN0LlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG5vZGUpIHtcbiAgICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBpbnN0YW5jZSBvZiBgUG9seW1lci5GbGF0dGVuZWROb2Rlc09ic2VydmVyYCB0aGF0XG4gICAgICogbGlzdGVucyBmb3Igbm9kZSBjaGFuZ2VzIG9uIHRoaXMgZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCB3aGVuIGRpcmVjdCBvciBkaXN0cmlidXRlZCBjaGlsZHJlblxuICAgICAqICAgb2YgdGhpcyBlbGVtZW50IGNoYW5nZXNcbiAgICAgKiBAcmV0dXJuIHtQb2x5bWVyLkZsYXR0ZW5lZE5vZGVzT2JzZXJ2ZXJ9IE9ic2VydmVyIGluc3RhbmNlXG4gICAgICovXG4gICAgb2JzZXJ2ZU5vZGVzKGNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gbmV3IFBvbHltZXIuRmxhdHRlbmVkTm9kZXNPYnNlcnZlcih0aGlzLm5vZGUsIGNhbGxiYWNrKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEaXNjb25uZWN0cyBhbiBvYnNlcnZlciBwcmV2aW91c2x5IGNyZWF0ZWQgdmlhIGBvYnNlcnZlTm9kZXNgXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BvbHltZXIuRmxhdHRlbmVkTm9kZXNPYnNlcnZlcn0gb2JzZXJ2ZXJIYW5kbGUgT2JzZXJ2ZXIgaW5zdGFuY2VcbiAgICAgKiAgIHRvIGRpc2Nvbm5lY3QuXG4gICAgICovXG4gICAgdW5vYnNlcnZlTm9kZXMob2JzZXJ2ZXJIYW5kbGUpIHtcbiAgICAgIG9ic2VydmVySGFuZGxlLmRpc2Nvbm5lY3QoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQcm92aWRlZCBhcyBhIGJhY2t3YXJkcy1jb21wYXRpYmxlIEFQSSBvbmx5LiAgVGhpcyBtZXRob2QgZG9lcyBub3RoaW5nLlxuICAgICAqL1xuICAgIG5vdGlmeU9ic2VydmVyKCkge31cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcHJvdmlkZWQgbm9kZSBpcyBjb250YWluZWQgd2l0aCB0aGlzIGVsZW1lbnQnc1xuICAgICAqIGxpZ2h0LURPTSBjaGlsZHJlbiBvciBzaGFkb3cgcm9vdCwgaW5jbHVkaW5nIGFueSBuZXN0ZWQgc2hhZG93IHJvb3RzXG4gICAgICogb2YgY2hpbGRyZW4gdGhlcmVpbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBOb2RlIHRvIHRlc3RcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIGBub2RlYCBpcyBjb250YWluZWQgd2l0aGluXG4gICAgICogICB0aGlzIGVsZW1lbnQncyBsaWdodCBvciBzaGFkb3cgRE9NLlxuICAgICAqL1xuICAgIGRlZXBDb250YWlucyhub2RlKSB7XG4gICAgICBpZiAodGhpcy5ub2RlLmNvbnRhaW5zKG5vZGUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgbGV0IG4gPSBub2RlO1xuICAgICAgbGV0IGRvYyA9IG5vZGUub3duZXJEb2N1bWVudDtcbiAgICAgIC8vIHdhbGsgZnJvbSBub2RlIHRvIGB0aGlzYCBvciBgZG9jdW1lbnRgXG4gICAgICB3aGlsZSAobiAmJiBuICE9PSBkb2MgJiYgbiAhPT0gdGhpcy5ub2RlKSB7XG4gICAgICAgIC8vIHVzZSBsb2dpY2FsIHBhcmVudG5vZGUsIG9yIG5hdGl2ZSBTaGFkb3dSb290IGhvc3RcbiAgICAgICAgbiA9IG4ucGFyZW50Tm9kZSB8fCBuLmhvc3Q7XG4gICAgICB9XG4gICAgICByZXR1cm4gbiA9PT0gdGhpcy5ub2RlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHJvb3Qgbm9kZSBvZiB0aGlzIG5vZGUuICBFcXVpdmFsZW50IHRvIGBnZXRSb29kTm9kZSgpYC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge05vZGV9IFRvcCBtb3N0IGVsZW1lbnQgaW4gdGhlIGRvbSB0cmVlIGluIHdoaWNoIHRoZSBub2RlXG4gICAgICogZXhpc3RzLiBJZiB0aGUgbm9kZSBpcyBjb25uZWN0ZWQgdG8gYSBkb2N1bWVudCB0aGlzIGlzIGVpdGhlciBhXG4gICAgICogc2hhZG93Um9vdCBvciB0aGUgZG9jdW1lbnQ7IG90aGVyd2lzZSwgaXQgbWF5IGJlIHRoZSBub2RlXG4gICAgICogaXRzZWxmIG9yIGEgbm9kZSBvciBkb2N1bWVudCBmcmFnbWVudCBjb250YWluaW5nIGl0LlxuICAgICAqL1xuICAgIGdldE93bmVyUm9vdCgpIHtcbiAgICAgIHJldHVybiB0aGlzLm5vZGUuZ2V0Um9vdE5vZGUoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGb3Igc2xvdCBlbGVtZW50cywgcmV0dXJucyB0aGUgbm9kZXMgYXNzaWduZWQgdG8gdGhlIHNsb3Q7IG90aGVyd2lzZVxuICAgICAqIGFuIGVtcHR5IGFycmF5LiBJdCBpcyBlcXVpdmFsZW50IHRvIGA8c2xvdD4uYWRkaWduZWROb2Rlcyh7ZmxhdHRlbjp0cnVlfSlgLlxuICAgICAqXG4gICAgICogQHJldHVybiB7QXJyYXk8Tm9kZT59IEFycmF5IG9mIGFzc2lnbmVkIG5vZGVzXG4gICAgICovXG4gICAgZ2V0RGlzdHJpYnV0ZWROb2RlcygpIHtcbiAgICAgIHJldHVybiAodGhpcy5ub2RlLmxvY2FsTmFtZSA9PT0gJ3Nsb3QnKSA/XG4gICAgICAgIHRoaXMubm9kZS5hc3NpZ25lZE5vZGVzKHtmbGF0dGVuOiB0cnVlfSkgOlxuICAgICAgICBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIGFsbCBzbG90cyB0aGlzIGVsZW1lbnQgd2FzIGRpc3RyaWJ1dGVkIHRvLlxuICAgICAqXG4gICAgICogQHJldHVybiB7QXJyYXk8SFRNTFNsb3RFbGVtZW50Pn0gRGVzY3JpcHRpb25cbiAgICAgKi9cbiAgICBnZXREZXN0aW5hdGlvbkluc2VydGlvblBvaW50cygpIHtcbiAgICAgIGxldCBpcCQgPSBbXTtcbiAgICAgIGxldCBuID0gdGhpcy5ub2RlLmFzc2lnbmVkU2xvdDtcbiAgICAgIHdoaWxlIChuKSB7XG4gICAgICAgIGlwJC5wdXNoKG4pO1xuICAgICAgICBuID0gbi5hc3NpZ25lZFNsb3Q7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXAkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGxzIGBpbXBvcnROb2RlYCBvbiB0aGUgYG93bmVyRG9jdW1lbnRgIGZvciB0aGlzIG5vZGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgTm9kZSB0byBpbXBvcnRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGRlZXAgVHJ1ZSBpZiB0aGUgbm9kZSBzaG91bGQgYmUgY2xvbmVkIGRlZXBseSBkdXJpbmdcbiAgICAgKiAgIGltcG9ydFxuICAgICAqIEByZXR1cm4ge05vZGV9IENsb25lIG9mIGdpdmVuIG5vZGUgaW1wb3J0ZWQgdG8gdGhpcyBvd25lciBkb2N1bWVudFxuICAgICAqL1xuICAgIGltcG9ydE5vZGUobm9kZSwgZGVlcCkge1xuICAgICAgbGV0IGRvYyA9IHRoaXMubm9kZSBpbnN0YW5jZW9mIERvY3VtZW50ID8gdGhpcy5ub2RlIDpcbiAgICAgICAgdGhpcy5ub2RlLm93bmVyRG9jdW1lbnQ7XG4gICAgICByZXR1cm4gZG9jLmltcG9ydE5vZGUobm9kZSwgZGVlcCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7QXJyYXl9IFJldHVybnMgYSBmbGF0dGVuZWQgbGlzdCBvZiBhbGwgY2hpbGQgbm9kZXMgYW5kIG5vZGVzIGFzc2lnbmVkXG4gICAgICogdG8gY2hpbGQgc2xvdHMuXG4gICAgICovXG4gICAgZ2V0RWZmZWN0aXZlQ2hpbGROb2RlcygpIHtcbiAgICAgIHJldHVybiBQb2x5bWVyLkZsYXR0ZW5lZE5vZGVzT2JzZXJ2ZXIuZ2V0RmxhdHRlbmVkTm9kZXModGhpcy5ub2RlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgZmlsdGVyZWQgbGlzdCBvZiBmbGF0dGVuZWQgY2hpbGQgZWxlbWVudHMgZm9yIHRoaXMgZWxlbWVudCBiYXNlZFxuICAgICAqIG9uIHRoZSBnaXZlbiBzZWxlY3Rvci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzZWxlY3RvciBTZWxlY3RvciB0byBmaWx0ZXIgbm9kZXMgYWdhaW5zdFxuICAgICAqIEByZXR1cm4ge0FycmF5PEhUTUxFbGVtZW50Pn0gTGlzdCBvZiBmbGF0dGVuZWQgY2hpbGQgZWxlbWVudHNcbiAgICAgKi9cbiAgICBxdWVyeURpc3RyaWJ1dGVkRWxlbWVudHMoc2VsZWN0b3IpIHtcbiAgICAgIGxldCBjJCA9IHRoaXMuZ2V0RWZmZWN0aXZlQ2hpbGROb2RlcygpO1xuICAgICAgbGV0IGxpc3QgPSBbXTtcbiAgICAgIGZvciAobGV0IGk9MCwgbD1jJC5sZW5ndGgsIGM7IChpPGwpICYmIChjPWMkW2ldKTsgaSsrKSB7XG4gICAgICAgIGlmICgoYy5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUpICYmXG4gICAgICAgICAgICBtYXRjaGVzU2VsZWN0b3IoYywgc2VsZWN0b3IpKSB7XG4gICAgICAgICAgbGlzdC5wdXNoKGMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbGlzdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGb3Igc2hhZG93IHJvb3RzLCByZXR1cm5zIHRoZSBjdXJyZW50bHkgZm9jdXNlZCBlbGVtZW50IHdpdGhpbiB0aGlzXG4gICAgICogc2hhZG93IHJvb3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtOb2RlfHVuZGVmaW5lZH0gQ3VycmVudGx5IGZvY3VzZWQgZWxlbWVudFxuICAgICAqL1xuICAgIGdldCBhY3RpdmVFbGVtZW50KCkge1xuICAgICAgbGV0IG5vZGUgPSB0aGlzLm5vZGU7XG4gICAgICByZXR1cm4gbm9kZS5fYWN0aXZlRWxlbWVudCAhPT0gdW5kZWZpbmVkID8gbm9kZS5fYWN0aXZlRWxlbWVudCA6IG5vZGUuYWN0aXZlRWxlbWVudDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBmb3J3YXJkTWV0aG9kcyhwcm90bywgbWV0aG9kcykge1xuICAgIGZvciAobGV0IGk9MDsgaSA8IG1ldGhvZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBtZXRob2QgPSBtZXRob2RzW2ldO1xuICAgICAgcHJvdG9bbWV0aG9kXSA9IC8qKiBAdGhpcyB7RG9tQXBpfSAqLyBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZVttZXRob2RdLmFwcGx5KHRoaXMubm9kZSwgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBmb3J3YXJkUmVhZE9ubHlQcm9wZXJ0aWVzKHByb3RvLCBwcm9wZXJ0aWVzKSB7XG4gICAgZm9yIChsZXQgaT0wOyBpIDwgcHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IG5hbWUgPSBwcm9wZXJ0aWVzW2ldO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvLCBuYW1lLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIC8qKiBAdHlwZSB7RG9tQXBpfSAqLyAodGhpcykubm9kZVtuYW1lXTtcbiAgICAgICAgfSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBmb3J3YXJkUHJvcGVydGllcyhwcm90bywgcHJvcGVydGllcykge1xuICAgIGZvciAobGV0IGk9MDsgaSA8IHByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBuYW1lID0gcHJvcGVydGllc1tpXTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90bywgbmFtZSwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiAvKiogQHR5cGUge0RvbUFwaX0gKi8gKHRoaXMpLm5vZGVbbmFtZV07XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAvKiogQHR5cGUge0RvbUFwaX0gKi8gKHRoaXMpLm5vZGVbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBmb3J3YXJkTWV0aG9kcyhEb21BcGkucHJvdG90eXBlLCBbXG4gICAgJ2Nsb25lTm9kZScsICdhcHBlbmRDaGlsZCcsICdpbnNlcnRCZWZvcmUnLCAncmVtb3ZlQ2hpbGQnLFxuICAgICdyZXBsYWNlQ2hpbGQnLCAnc2V0QXR0cmlidXRlJywgJ3JlbW92ZUF0dHJpYnV0ZScsXG4gICAgJ3F1ZXJ5U2VsZWN0b3InLCAncXVlcnlTZWxlY3RvckFsbCdcbiAgXSk7XG5cbiAgZm9yd2FyZFJlYWRPbmx5UHJvcGVydGllcyhEb21BcGkucHJvdG90eXBlLCBbXG4gICAgJ3BhcmVudE5vZGUnLCAnZmlyc3RDaGlsZCcsICdsYXN0Q2hpbGQnLFxuICAgICduZXh0U2libGluZycsICdwcmV2aW91c1NpYmxpbmcnLCAnZmlyc3RFbGVtZW50Q2hpbGQnLFxuICAgICdsYXN0RWxlbWVudENoaWxkJywgJ25leHRFbGVtZW50U2libGluZycsICdwcmV2aW91c0VsZW1lbnRTaWJsaW5nJyxcbiAgICAnY2hpbGROb2RlcycsICdjaGlsZHJlbicsICdjbGFzc0xpc3QnXG4gIF0pO1xuXG4gIGZvcndhcmRQcm9wZXJ0aWVzKERvbUFwaS5wcm90b3R5cGUsIFtcbiAgICAndGV4dENvbnRlbnQnLCAnaW5uZXJIVE1MJ1xuICBdKTtcblxuXG4gIC8qKlxuICAgKiBFdmVudCBBUEkgd3JhcHBlciBjbGFzcyByZXR1cm5lZCBmcm9tIGBQb2x5bWVyLmRvbS4odGFyZ2V0KWAgd2hlblxuICAgKiBgdGFyZ2V0YCBpcyBhbiBgRXZlbnRgLlxuICAgKi9cbiAgY2xhc3MgRXZlbnRBcGkge1xuICAgIGNvbnN0cnVjdG9yKGV2ZW50KSB7XG4gICAgICB0aGlzLmV2ZW50ID0gZXZlbnQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZmlyc3Qgbm9kZSBvbiB0aGUgYGNvbXBvc2VkUGF0aGAgb2YgdGhpcyBldmVudC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge05vZGV9IFRoZSBub2RlIHRoaXMgZXZlbnQgd2FzIGRpc3BhdGNoZWQgdG9cbiAgICAgKi9cbiAgICBnZXQgcm9vdFRhcmdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmV2ZW50LmNvbXBvc2VkUGF0aCgpWzBdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGxvY2FsIChyZS10YXJnZXRlZCkgdGFyZ2V0IGZvciB0aGlzIGV2ZW50LlxuICAgICAqXG4gICAgICogQHJldHVybiB7Tm9kZX0gVGhlIGxvY2FsIChyZS10YXJnZXRlZCkgdGFyZ2V0IGZvciB0aGlzIGV2ZW50LlxuICAgICAqL1xuICAgIGdldCBsb2NhbFRhcmdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmV2ZW50LnRhcmdldDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBgY29tcG9zZWRQYXRoYCBmb3IgdGhpcyBldmVudC5cbiAgICAgKi9cbiAgICBnZXQgcGF0aCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmV2ZW50LmNvbXBvc2VkUGF0aCgpO1xuICAgIH1cbiAgfVxuXG4gIFBvbHltZXIuRG9tQXBpID0gRG9tQXBpO1xuXG4gIC8qKlxuICAgKiBMZWdhY3kgRE9NIGFuZCBFdmVudCBtYW5pcHVsYXRpb24gQVBJIHdyYXBwZXIgZmFjdG9yeSB1c2VkIHRvIGFic3RyYWN0XG4gICAqIGRpZmZlcmVuY2VzIGJldHdlZW4gbmF0aXZlIFNoYWRvdyBET00gYW5kIFwiU2hhZHkgRE9NXCIgd2hlbiBwb2x5ZmlsbGluZyBvblxuICAgKiBvbGRlciBicm93c2Vycy5cbiAgICpcbiAgICogTm90ZSB0aGF0IGluIFBvbHltZXIgMi54IHVzZSBvZiBgUG9seW1lci5kb21gIGlzIG5vIGxvbmdlciByZXF1aXJlZCBhbmRcbiAgICogaW4gdGhlIG1ham9yaXR5IG9mIGNhc2VzIHNpbXBseSBmYWNhZGVzIGRpcmVjdGx5IHRvIHRoZSBzdGFuZGFyZCBuYXRpdmVcbiAgICogQVBJLlxuICAgKlxuICAgKiBAbmFtZXNwYWNlXG4gICAqIEBzdW1tYXJ5IExlZ2FjeSBET00gYW5kIEV2ZW50IG1hbmlwdWxhdGlvbiBBUEkgd3JhcHBlciBmYWN0b3J5IHVzZWQgdG9cbiAgICogYWJzdHJhY3QgZGlmZmVyZW5jZXMgYmV0d2VlbiBuYXRpdmUgU2hhZG93IERPTSBhbmQgXCJTaGFkeSBET00uXCJcbiAgICogQG1lbWJlcm9mIFBvbHltZXJcbiAgICogQHBhcmFtIHshTm9kZXxFdmVudH0gb2JqIE5vZGUgb3IgZXZlbnQgdG8gb3BlcmF0ZSBvblxuICAgKiBAcmV0dXJuIHtEb21BcGl8RXZlbnRBcGl9IFdyYXBwZXIgcHJvdmlkaW5nIGVpdGhlciBub2RlIEFQSSBvciBldmVudCBBUElcbiAgICovXG4gIFBvbHltZXIuZG9tID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgb2JqID0gb2JqIHx8IGRvY3VtZW50O1xuICAgIGlmICghb2JqLl9fZG9tQXBpKSB7XG4gICAgICBsZXQgaGVscGVyO1xuICAgICAgaWYgKG9iaiBpbnN0YW5jZW9mIEV2ZW50KSB7XG4gICAgICAgIGhlbHBlciA9IG5ldyBFdmVudEFwaShvYmopO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaGVscGVyID0gbmV3IERvbUFwaShvYmopO1xuICAgICAgfVxuICAgICAgb2JqLl9fZG9tQXBpID0gaGVscGVyO1xuICAgIH1cbiAgICByZXR1cm4gb2JqLl9fZG9tQXBpO1xuICB9O1xuXG4gIFBvbHltZXIuZG9tLm1hdGNoZXNTZWxlY3RvciA9IG1hdGNoZXNTZWxlY3RvcjtcblxuICAvKipcbiAgICogRm9yY2VzIHNldmVyYWwgY2xhc3NlcyBvZiBhc3luY2hyb25vdXNseSBxdWV1ZWQgdGFza3MgdG8gZmx1c2g6XG4gICAqIC0gRGVib3VuY2VycyBhZGRlZCB2aWEgYFBvbHltZXIuZW5xdWV1ZURlYm91bmNlcmBcbiAgICogLSBTaGFkeURPTSBkaXN0cmlidXRpb25cbiAgICpcbiAgICogVGhpcyBtZXRob2QgZmFjYWRlcyB0byBgUG9seW1lci5mbHVzaGAuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBQb2x5bWVyLmRvbVxuICAgKi9cbiAgUG9seW1lci5kb20uZmx1c2ggPSBQb2x5bWVyLmZsdXNoO1xuXG4gIC8qKlxuICAgKiBBZGRzIGEgYFBvbHltZXIuRGVib3VuY2VyYCB0byBhIGxpc3Qgb2YgZ2xvYmFsbHkgZmx1c2hhYmxlIHRhc2tzLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBmYWNhZGVzIHRvIGBQb2x5bWVyLmVucXVldWVEZWJvdW5jZXJgLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgUG9seW1lci5kb21cbiAgICogQHBhcmFtIHtQb2x5bWVyLkRlYm91bmNlcn0gZGVib3VuY2VyIERlYm91bmNlciB0byBlbnF1ZXVlXG4gICAqL1xuICBQb2x5bWVyLmRvbS5hZGREZWJvdW5jZXIgPSBQb2x5bWVyLmVucXVldWVEZWJvdW5jZXI7XG59KSgpO1xuPC9zY3JpcHQ+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL3BvbHltZXIvbGliL2xlZ2FjeS9wb2x5bWVyLmRvbS5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3V0aWxzL2Jvb3QuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3V0aWxzL2FycmF5LXNwbGljZS5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vdXRpbHMvYXN5bmMuaHRtbFwiPlxuPHNjcmlwdD5cbihmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgYG5vZGVgIGlzIGEgc2xvdCBlbGVtZW50XG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG5vZGUgTm9kZSB0byB0ZXN0LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIGBub2RlYCBpcyBhIHNsb3RcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIGlzU2xvdChub2RlKSB7XG4gICAgcmV0dXJuIChub2RlLmxvY2FsTmFtZSA9PT0gJ3Nsb3QnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGFzcyB0aGF0IGxpc3RlbnMgZm9yIGNoYW5nZXMgKGFkZGl0aW9ucyBvciByZW1vdmFscykgdG9cbiAgICogXCJmbGF0dGVuZWQgbm9kZXNcIiBvbiBhIGdpdmVuIGBub2RlYC4gVGhlIGxpc3Qgb2YgZmxhdHRlbmVkIG5vZGVzIGNvbnNpc3RzXG4gICAqIG9mIGEgbm9kZSdzIGNoaWxkcmVuIGFuZCwgZm9yIGFueSBjaGlsZHJlbiB0aGF0IGFyZSBgPHNsb3Q+YCBlbGVtZW50cyxcbiAgICogdGhlIGV4cGFuZGVkIGZsYXR0ZW5lZCBsaXN0IG9mIGBhc3NpZ25lZE5vZGVzYC5cbiAgICogRm9yIGV4YW1wbGUsIGlmIHRoZSBvYnNlcnZlZCBub2RlIGhhcyBjaGlsZHJlbiBgPGE+PC9hPjxzbG90Pjwvc2xvdD48Yj48L2I+YFxuICAgKiBhbmQgdGhlIGA8c2xvdD5gIGhhcyBvbmUgYDxkaXY+YCBhc3NpZ25lZCB0byBpdCwgdGhlbiB0aGUgZmxhdHRlbmVkXG4gICAqIG5vZGVzIGxpc3QgaXMgYDxhPjwvYT48ZGl2PjwvZGl2PjxiPjwvYj5gLiBJZiB0aGUgYDxzbG90PmAgaGFzIG90aGVyXG4gICAqIGA8c2xvdD5gIGVsZW1lbnRzIGFzc2lnbmVkIHRvIGl0LCB0aGVzZSBhcmUgZmxhdHRlbmVkIGFzIHdlbGwuXG4gICAqXG4gICAqIFRoZSBwcm92aWRlZCBgY2FsbGJhY2tgIGlzIGNhbGxlZCB3aGVuZXZlciBhbnkgY2hhbmdlIHRvIHRoaXMgbGlzdFxuICAgKiBvZiBmbGF0dGVuZWQgbm9kZXMgb2NjdXJzLCB3aGVyZSBhbiBhZGRpdGlvbiBvciByZW1vdmFsIG9mIGEgbm9kZSBpc1xuICAgKiBjb25zaWRlcmVkIGEgY2hhbmdlLiBUaGUgYGNhbGxiYWNrYCBpcyBjYWxsZWQgd2l0aCBvbmUgYXJndW1lbnQsIGFuIG9iamVjdFxuICAgKiBjb250YWluaW5nIGFuIGFycmF5IG9mIGFueSBgYWRkZWROb2Rlc2AgYW5kIGByZW1vdmVkTm9kZXNgLlxuICAgKlxuICAgKiBOb3RlOiB0aGUgY2FsbGJhY2sgaXMgY2FsbGVkIGFzeW5jaHJvbm91cyB0byBhbnkgY2hhbmdlc1xuICAgKiBhdCBhIG1pY3JvdGFzayBjaGVja3BvaW50LiBUaGlzIGlzIGJlY2F1c2Ugb2JzZXJ2YXRpb24gaXMgcGVyZm9ybWVkIHVzaW5nXG4gICAqIGBNdXRhdGlvbk9ic2VydmVyYCBhbmQgdGhlIGA8c2xvdD5gIGVsZW1lbnQncyBgc2xvdGNoYW5nZWAgZXZlbnQgd2hpY2hcbiAgICogYXJlIGFzeW5jaHJvbm91cy5cbiAgICpcbiAgICogQG1lbWJlcm9mIFBvbHltZXJcbiAgICogQHN1bW1hcnkgQ2xhc3MgdGhhdCBsaXN0ZW5zIGZvciBjaGFuZ2VzIChhZGRpdGlvbnMgb3IgcmVtb3ZhbHMpIHRvXG4gICAqIFwiZmxhdHRlbmVkIG5vZGVzXCIgb24gYSBnaXZlbiBgbm9kZWAuXG4gICAqL1xuICBjbGFzcyBGbGF0dGVuZWROb2Rlc09ic2VydmVyIHtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGxpc3Qgb2YgZmxhdHRlbmVkIG5vZGVzIGZvciB0aGUgZ2l2ZW4gYG5vZGVgLlxuICAgICAqIFRoaXMgbGlzdCBjb25zaXN0cyBvZiBhIG5vZGUncyBjaGlsZHJlbiBhbmQsIGZvciBhbnkgY2hpbGRyZW5cbiAgICAgKiB0aGF0IGFyZSBgPHNsb3Q+YCBlbGVtZW50cywgdGhlIGV4cGFuZGVkIGZsYXR0ZW5lZCBsaXN0IG9mIGBhc3NpZ25lZE5vZGVzYC5cbiAgICAgKiBGb3IgZXhhbXBsZSwgaWYgdGhlIG9ic2VydmVkIG5vZGUgaGFzIGNoaWxkcmVuIGA8YT48L2E+PHNsb3Q+PC9zbG90PjxiPjwvYj5gXG4gICAgICogYW5kIHRoZSBgPHNsb3Q+YCBoYXMgb25lIGA8ZGl2PmAgYXNzaWduZWQgdG8gaXQsIHRoZW4gdGhlIGZsYXR0ZW5lZFxuICAgICAqIG5vZGVzIGxpc3QgaXMgYDxhPjwvYT48ZGl2PjwvZGl2PjxiPjwvYj5gLiBJZiB0aGUgYDxzbG90PmAgaGFzIG90aGVyXG4gICAgICogYDxzbG90PmAgZWxlbWVudHMgYXNzaWduZWQgdG8gaXQsIHRoZXNlIGFyZSBmbGF0dGVuZWQgYXMgd2VsbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR8SFRNTFNsb3RFbGVtZW50fSBub2RlIFRoZSBub2RlIGZvciB3aGljaCB0byByZXR1cm4gdGhlIGxpc3Qgb2YgZmxhdHRlbmVkIG5vZGVzLlxuICAgICAqIEByZXR1cm4ge0FycmF5fSBUaGUgbGlzdCBvZiBmbGF0dGVuZWQgbm9kZXMgZm9yIHRoZSBnaXZlbiBgbm9kZWAuXG4gICAgKi9cbiAgICBzdGF0aWMgZ2V0RmxhdHRlbmVkTm9kZXMobm9kZSkge1xuICAgICAgaWYgKGlzU2xvdChub2RlKSkge1xuICAgICAgICByZXR1cm4gLyoqIEB0eXBlIHtIVE1MU2xvdEVsZW1lbnR9ICovIChub2RlKS5hc3NpZ25lZE5vZGVzKHtmbGF0dGVuOiB0cnVlfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbShub2RlLmNoaWxkTm9kZXMpLm1hcChub2RlID0+IHtcbiAgICAgICAgICBpZiAoaXNTbG90KG5vZGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gLyoqIEB0eXBlIHtIVE1MU2xvdEVsZW1lbnR9ICovIChub2RlKS5hc3NpZ25lZE5vZGVzKHtmbGF0dGVuOiB0cnVlfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBbbm9kZV07XG4gICAgICAgICAgfVxuICAgICAgICB9KS5yZWR1Y2UoKGEsIGIpID0+IGEuY29uY2F0KGIpLCBbXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOb2RlfSB0YXJnZXQgTm9kZSBvbiB3aGljaCB0byBsaXN0ZW4gZm9yIGNoYW5nZXMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgRnVuY3Rpb24gY2FsbGVkIHdoZW4gdGhlcmUgYXJlIGFkZGl0aW9uc1xuICAgICAqIG9yIHJlbW92YWxzIGZyb20gdGhlIHRhcmdldCdzIGxpc3Qgb2YgZmxhdHRlbmVkIG5vZGVzLlxuICAgICovXG4gICAgY29uc3RydWN0b3IodGFyZ2V0LCBjYWxsYmFjaykge1xuICAgICAgLyoqIEB0eXBlIHtNdXRhdGlvbk9ic2VydmVyfSAqL1xuICAgICAgdGhpcy5fc2hhZHlDaGlsZHJlbk9ic2VydmVyID0gbnVsbDtcbiAgICAgIC8qKiBAdHlwZSB7TXV0YXRpb25PYnNlcnZlcn0gKi9cbiAgICAgIHRoaXMuX25hdGl2ZUNoaWxkcmVuT2JzZXJ2ZXIgPSBudWxsO1xuICAgICAgdGhpcy5fY29ubmVjdGVkID0gZmFsc2U7XG4gICAgICB0aGlzLl90YXJnZXQgPSB0YXJnZXQ7XG4gICAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICB0aGlzLl9lZmZlY3RpdmVOb2RlcyA9IFtdO1xuICAgICAgdGhpcy5fb2JzZXJ2ZXIgPSBudWxsO1xuICAgICAgdGhpcy5fc2NoZWR1bGVkID0gZmFsc2U7XG4gICAgICAvKiogQHR5cGUge2Z1bmN0aW9uKCl9ICovXG4gICAgICB0aGlzLl9ib3VuZFNjaGVkdWxlID0gKCkgPT4ge1xuICAgICAgICB0aGlzLl9zY2hlZHVsZSgpO1xuICAgICAgfVxuICAgICAgdGhpcy5jb25uZWN0KCk7XG4gICAgICB0aGlzLl9zY2hlZHVsZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFjdGl2YXRlcyBhbiBvYnNlcnZlci4gVGhpcyBtZXRob2QgaXMgYXV0b21hdGljYWxseSBjYWxsZWQgd2hlblxuICAgICAqIGEgYEZsYXR0ZW5lZE5vZGVzT2JzZXJ2ZXJgIGlzIGNyZWF0ZWQuIEl0IHNob3VsZCBvbmx5IGJlIGNhbGxlZCB0b1xuICAgICAqIHJlLWFjdGl2YXRlIGFuIG9ic2VydmVyIHRoYXQgaGFzIGJlZW4gZGVhY3RpdmF0ZWQgdmlhIHRoZSBgZGlzY29ubmVjdGAgbWV0aG9kLlxuICAgICAqL1xuICAgIGNvbm5lY3QoKSB7XG4gICAgICBpZiAoaXNTbG90KHRoaXMuX3RhcmdldCkpIHtcbiAgICAgICAgdGhpcy5fbGlzdGVuU2xvdHMoW3RoaXMuX3RhcmdldF0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fbGlzdGVuU2xvdHModGhpcy5fdGFyZ2V0LmNoaWxkcmVuKTtcbiAgICAgICAgaWYgKHdpbmRvdy5TaGFkeURPTSkge1xuICAgICAgICAgIHRoaXMuX3NoYWR5Q2hpbGRyZW5PYnNlcnZlciA9XG4gICAgICAgICAgICBTaGFkeURPTS5vYnNlcnZlQ2hpbGRyZW4odGhpcy5fdGFyZ2V0LCAobXV0YXRpb25zKSA9PiB7XG4gICAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3NNdXRhdGlvbnMobXV0YXRpb25zKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX25hdGl2ZUNoaWxkcmVuT2JzZXJ2ZXIgPVxuICAgICAgICAgICAgbmV3IE11dGF0aW9uT2JzZXJ2ZXIoKG11dGF0aW9ucykgPT4ge1xuICAgICAgICAgICAgICB0aGlzLl9wcm9jZXNzTXV0YXRpb25zKG11dGF0aW9ucyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLl9uYXRpdmVDaGlsZHJlbk9ic2VydmVyLm9ic2VydmUodGhpcy5fdGFyZ2V0LCB7Y2hpbGRMaXN0OiB0cnVlfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuX2Nvbm5lY3RlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVhY3RpdmF0ZXMgdGhlIGZsYXR0ZW5lZCBub2RlcyBvYnNlcnZlci4gQWZ0ZXIgY2FsbGluZyB0aGlzIG1ldGhvZFxuICAgICAqIHRoZSBvYnNlcnZlciBjYWxsYmFjayB3aWxsIG5vdCBiZSBjYWxsZWQgd2hlbiBjaGFuZ2VzIHRvIGZsYXR0ZW5lZCBub2Rlc1xuICAgICAqIG9jY3VyLiBUaGUgYGNvbm5lY3RgIG1ldGhvZCBtYXkgYmUgc3Vic2VxdWVudGx5IGNhbGxlZCB0byByZWFjdGl2YXRlXG4gICAgICogdGhlIG9ic2VydmVyLlxuICAgICAqL1xuICAgIGRpc2Nvbm5lY3QoKSB7XG4gICAgICBpZiAoaXNTbG90KHRoaXMuX3RhcmdldCkpIHtcbiAgICAgICAgdGhpcy5fdW5saXN0ZW5TbG90cyhbdGhpcy5fdGFyZ2V0XSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl91bmxpc3RlblNsb3RzKHRoaXMuX3RhcmdldC5jaGlsZHJlbik7XG4gICAgICAgIGlmICh3aW5kb3cuU2hhZHlET00gJiYgdGhpcy5fc2hhZHlDaGlsZHJlbk9ic2VydmVyKSB7XG4gICAgICAgICAgU2hhZHlET00udW5vYnNlcnZlQ2hpbGRyZW4odGhpcy5fc2hhZHlDaGlsZHJlbk9ic2VydmVyKTtcbiAgICAgICAgICB0aGlzLl9zaGFkeUNoaWxkcmVuT2JzZXJ2ZXIgPSBudWxsO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX25hdGl2ZUNoaWxkcmVuT2JzZXJ2ZXIpIHtcbiAgICAgICAgICB0aGlzLl9uYXRpdmVDaGlsZHJlbk9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICB0aGlzLl9uYXRpdmVDaGlsZHJlbk9ic2VydmVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5fY29ubmVjdGVkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgX3NjaGVkdWxlKCkge1xuICAgICAgaWYgKCF0aGlzLl9zY2hlZHVsZWQpIHtcbiAgICAgICAgdGhpcy5fc2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgICAgUG9seW1lci5Bc3luYy5taWNyb1Rhc2sucnVuKCgpID0+IHRoaXMuZmx1c2goKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgX3Byb2Nlc3NNdXRhdGlvbnMobXV0YXRpb25zKSB7XG4gICAgICB0aGlzLl9wcm9jZXNzU2xvdE11dGF0aW9ucyhtdXRhdGlvbnMpO1xuICAgICAgdGhpcy5mbHVzaCgpO1xuICAgIH1cblxuICAgIF9wcm9jZXNzU2xvdE11dGF0aW9ucyhtdXRhdGlvbnMpIHtcbiAgICAgIGlmIChtdXRhdGlvbnMpIHtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpIDwgbXV0YXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgbGV0IG11dGF0aW9uID0gbXV0YXRpb25zW2ldO1xuICAgICAgICAgIGlmIChtdXRhdGlvbi5hZGRlZE5vZGVzKSB7XG4gICAgICAgICAgICB0aGlzLl9saXN0ZW5TbG90cyhtdXRhdGlvbi5hZGRlZE5vZGVzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG11dGF0aW9uLnJlbW92ZWROb2Rlcykge1xuICAgICAgICAgICAgdGhpcy5fdW5saXN0ZW5TbG90cyhtdXRhdGlvbi5yZW1vdmVkTm9kZXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZsdXNoZXMgdGhlIG9ic2VydmVyIGNhdXNpbmcgYW55IHBlbmRpbmcgY2hhbmdlcyB0byBiZSBpbW1lZGlhdGVseVxuICAgICAqIGRlbGl2ZXJlZCB0aGUgb2JzZXJ2ZXIgY2FsbGJhY2suIEJ5IGRlZmF1bHQgdGhlc2UgY2hhbmdlcyBhcmUgZGVsaXZlcmVkXG4gICAgICogYXN5bmNocm9ub3VzbHkgYXQgdGhlIG5leHQgbWljcm90YXNrIGNoZWNrcG9pbnQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgYW55IHBlbmRpbmcgY2hhbmdlcyBjYXVzZWQgdGhlIG9ic2VydmVyXG4gICAgICogY2FsbGJhY2sgdG8gcnVuLlxuICAgICAqL1xuICAgIGZsdXNoKCkge1xuICAgICAgaWYgKCF0aGlzLl9jb25uZWN0ZWQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKHdpbmRvdy5TaGFkeURPTSkge1xuICAgICAgICBTaGFkeURPTS5mbHVzaCgpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX25hdGl2ZUNoaWxkcmVuT2JzZXJ2ZXIpIHtcbiAgICAgICAgdGhpcy5fcHJvY2Vzc1Nsb3RNdXRhdGlvbnModGhpcy5fbmF0aXZlQ2hpbGRyZW5PYnNlcnZlci50YWtlUmVjb3JkcygpKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fc2hhZHlDaGlsZHJlbk9ic2VydmVyKSB7XG4gICAgICAgIHRoaXMuX3Byb2Nlc3NTbG90TXV0YXRpb25zKHRoaXMuX3NoYWR5Q2hpbGRyZW5PYnNlcnZlci50YWtlUmVjb3JkcygpKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3NjaGVkdWxlZCA9IGZhbHNlO1xuICAgICAgbGV0IGluZm8gPSB7XG4gICAgICAgIHRhcmdldDogdGhpcy5fdGFyZ2V0LFxuICAgICAgICBhZGRlZE5vZGVzOiBbXSxcbiAgICAgICAgcmVtb3ZlZE5vZGVzOiBbXVxuICAgICAgfTtcbiAgICAgIGxldCBuZXdOb2RlcyA9IHRoaXMuY29uc3RydWN0b3IuZ2V0RmxhdHRlbmVkTm9kZXModGhpcy5fdGFyZ2V0KTtcbiAgICAgIGxldCBzcGxpY2VzID0gUG9seW1lci5BcnJheVNwbGljZS5jYWxjdWxhdGVTcGxpY2VzKG5ld05vZGVzLFxuICAgICAgICB0aGlzLl9lZmZlY3RpdmVOb2Rlcyk7XG4gICAgICAvLyBwcm9jZXNzIHJlbW92YWxzXG4gICAgICBmb3IgKGxldCBpPTAsIHM7IChpPHNwbGljZXMubGVuZ3RoKSAmJiAocz1zcGxpY2VzW2ldKTsgaSsrKSB7XG4gICAgICAgIGZvciAobGV0IGo9MCwgbjsgKGogPCBzLnJlbW92ZWQubGVuZ3RoKSAmJiAobj1zLnJlbW92ZWRbal0pOyBqKyspIHtcbiAgICAgICAgICBpbmZvLnJlbW92ZWROb2Rlcy5wdXNoKG4pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBwcm9jZXNzIGFkZHNcbiAgICAgIGZvciAobGV0IGk9MCwgczsgKGk8c3BsaWNlcy5sZW5ndGgpICYmIChzPXNwbGljZXNbaV0pOyBpKyspIHtcbiAgICAgICAgZm9yIChsZXQgaj1zLmluZGV4OyBqIDwgcy5pbmRleCArIHMuYWRkZWRDb3VudDsgaisrKSB7XG4gICAgICAgICAgaW5mby5hZGRlZE5vZGVzLnB1c2gobmV3Tm9kZXNbal0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyB1cGRhdGUgY2FjaGVcbiAgICAgIHRoaXMuX2VmZmVjdGl2ZU5vZGVzID0gbmV3Tm9kZXM7XG4gICAgICBsZXQgZGlkRmx1c2ggPSBmYWxzZTtcbiAgICAgIGlmIChpbmZvLmFkZGVkTm9kZXMubGVuZ3RoIHx8IGluZm8ucmVtb3ZlZE5vZGVzLmxlbmd0aCkge1xuICAgICAgICBkaWRGbHVzaCA9IHRydWU7XG4gICAgICAgIHRoaXMuY2FsbGJhY2suY2FsbCh0aGlzLl90YXJnZXQsIGluZm8pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRpZEZsdXNoO1xuICAgIH1cblxuICAgIF9saXN0ZW5TbG90cyhub2RlTGlzdCkge1xuICAgICAgZm9yIChsZXQgaT0wOyBpIDwgbm9kZUxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IG4gPSBub2RlTGlzdFtpXTtcbiAgICAgICAgaWYgKGlzU2xvdChuKSkge1xuICAgICAgICAgIG4uYWRkRXZlbnRMaXN0ZW5lcignc2xvdGNoYW5nZScsIHRoaXMuX2JvdW5kU2NoZWR1bGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgX3VubGlzdGVuU2xvdHMobm9kZUxpc3QpIHtcbiAgICAgIGZvciAobGV0IGk9MDsgaSA8IG5vZGVMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBuID0gbm9kZUxpc3RbaV07XG4gICAgICAgIGlmIChpc1Nsb3QobikpIHtcbiAgICAgICAgICBuLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Nsb3RjaGFuZ2UnLCB0aGlzLl9ib3VuZFNjaGVkdWxlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICB9XG5cbiAgUG9seW1lci5GbGF0dGVuZWROb2Rlc09ic2VydmVyID0gRmxhdHRlbmVkTm9kZXNPYnNlcnZlcjtcblxufSkoKTtcbjwvc2NyaXB0PlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi91dGlscy9mbGF0dGVuZWQtbm9kZXMtb2JzZXJ2ZXIuaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cblxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cImNsYXNzLmh0bWxcIj5cblxuPHNjcmlwdD5cblxuICAoZnVuY3Rpb24oKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgLyoqXG4gICAgICogTGVnYWN5IGNsYXNzIGZhY3RvcnkgYW5kIHJlZ2lzdHJhdGlvbiBoZWxwZXIgZm9yIGRlZmluaW5nIFBvbHltZXJcbiAgICAgKiBlbGVtZW50cy5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGVxdWl2YWxlbnQgdG9cbiAgICAgKiBgY3VzdG9tRWxlbWVudHMuZGVmaW5lKGluZm8uaXMsIFBvbHltZXIuQ2xhc3MoaW5mbykpO2BcbiAgICAgKlxuICAgICAqIFNlZSBgUG9seW1lci5DbGFzc2AgZm9yIGRldGFpbHMgb24gdmFsaWQgbGVnYWN5IG1ldGFkYXRhIGZvcm1hdCBmb3IgYGluZm9gLlxuICAgICAqXG4gICAgICogQG92ZXJyaWRlXG4gICAgICogQGZ1bmN0aW9uIFBvbHltZXJcbiAgICAgKiBAcGFyYW0geyFQb2x5bWVySW5pdH0gaW5mbyBPYmplY3QgY29udGFpbmluZyBQb2x5bWVyIG1ldGFkYXRhIGFuZCBmdW5jdGlvbnNcbiAgICAgKiAgIHRvIGJlY29tZSBjbGFzcyBtZXRob2RzLlxuICAgICAqIEByZXR1cm4geyFIVE1MRWxlbWVudH0gR2VuZXJhdGVkIGNsYXNzXG4gICAgICogQHN1cHByZXNzIHtkdXBsaWNhdGUsIGludmFsaWRDYXN0cywgY2hlY2tUeXBlc31cbiAgICAgKi9cbiAgICB3aW5kb3cuUG9seW1lci5fcG9seW1lckZuID0gZnVuY3Rpb24oaW5mbykge1xuICAgICAgLy8gaWYgaW5wdXQgaXMgYSBgY2xhc3NgIChha2EgYSBmdW5jdGlvbiB3aXRoIGEgcHJvdG90eXBlKSwgdXNlIHRoZSBwcm90b3R5cGVcbiAgICAgIC8vIHJlbWVtYmVyIHRoYXQgdGhlIGBjb25zdHJ1Y3RvcmAgd2lsbCBuZXZlciBiZSBjYWxsZWRcbiAgICAgIGxldCBrbGFzcztcbiAgICAgIGlmICh0eXBlb2YgaW5mbyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBrbGFzcyA9IGluZm87XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBrbGFzcyA9IFBvbHltZXIuQ2xhc3MoaW5mbyk7XG4gICAgICB9XG4gICAgICBjdXN0b21FbGVtZW50cy5kZWZpbmUoa2xhc3MuaXMsIC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqLyhrbGFzcykpO1xuICAgICAgcmV0dXJuIGtsYXNzO1xuICAgIH07XG5cbiAgfSkoKTtcblxuPC9zY3JpcHQ+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL3BvbHltZXIvbGliL2xlZ2FjeS9wb2x5bWVyLWZuLmh0bWwiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwibGVnYWN5LWVsZW1lbnQtbWl4aW4uaHRtbFwiPlxuPHNjcmlwdD5cblxuICAoZnVuY3Rpb24oKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBsZXQgbWV0YVByb3BzID0ge1xuICAgICAgYXR0YWNoZWQ6IHRydWUsXG4gICAgICBkZXRhY2hlZDogdHJ1ZSxcbiAgICAgIHJlYWR5OiB0cnVlLFxuICAgICAgY3JlYXRlZDogdHJ1ZSxcbiAgICAgIGJlZm9yZVJlZ2lzdGVyOiB0cnVlLFxuICAgICAgcmVnaXN0ZXJlZDogdHJ1ZSxcbiAgICAgIGF0dHJpYnV0ZUNoYW5nZWQ6IHRydWUsXG4gICAgICAvLyBtZXRhIG9iamVjdHNcbiAgICAgIGJlaGF2aW9yczogdHJ1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgYSBcImxlZ2FjeVwiIGJlaGF2aW9yIG9yIGFycmF5IG9mIGJlaGF2aW9ycyB0byB0aGUgcHJvdmlkZWQgY2xhc3MuXG4gICAgICpcbiAgICAgKiBOb3RlOiB0aGlzIG1ldGhvZCB3aWxsIGF1dG9tYXRpY2FsbHkgYWxzbyBhcHBseSB0aGUgYFBvbHltZXIuTGVnYWN5RWxlbWVudE1peGluYFxuICAgICAqIHRvIGVuc3VyZSB0aGF0IGFueSBsZWdhY3kgYmVoYXZpb3JzIGNhbiByZWx5IG9uIGxlZ2FjeSBQb2x5bWVyIEFQSSBvblxuICAgICAqIHRoZSB1bmRlcmx5aW5nIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyEoT2JqZWN0fEFycmF5KX0gYmVoYXZpb3JzIEJlaGF2aW9yIG9iamVjdCBvciBhcnJheSBvZiBiZWhhdmlvcnMuXG4gICAgICogQHBhcmFtIHshSFRNTEVsZW1lbnR8ZnVuY3Rpb24obmV3OkhUTUxFbGVtZW50KX0ga2xhc3MgRWxlbWVudCBjbGFzcy5cbiAgICAgKiBAcmV0dXJuIHtmdW5jdGlvbihuZXc6SFRNTEVsZW1lbnQpfSBSZXR1cm5zIGEgbmV3IEVsZW1lbnQgY2xhc3MgZXh0ZW5kZWQgYnkgdGhlXG4gICAgICogcGFzc2VkIGluIGBiZWhhdmlvcnNgIGFuZCBhbHNvIGJ5IGBQb2x5bWVyLkxlZ2FjeUVsZW1lbnRNaXhpbmAuXG4gICAgICogQG1lbWJlcm9mIFBvbHltZXJcbiAgICAgKiBAc3VwcHJlc3Mge2ludmFsaWRDYXN0cywgY2hlY2tUeXBlc31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtaXhpbkJlaGF2aW9ycyhiZWhhdmlvcnMsIGtsYXNzKSB7XG4gICAgICBpZiAoIWJlaGF2aW9ycykge1xuICAgICAgICByZXR1cm4gLyoqIEB0eXBlIHtIVE1MRWxlbWVudH0gKi8oa2xhc3MpO1xuICAgICAgfVxuICAgICAgLy8gTk9URTogZW5zdXJlIHRoZSBiYWhldmlvciBpcyBleHRlbmRpbmcgYSBjbGFzcyB3aXRoXG4gICAgICAvLyBsZWdhY3kgZWxlbWVudCBhcGkuIFRoaXMgaXMgbmVjZXNzYXJ5IHNpbmNlIGJlaGF2aW9ycyBleHBlY3QgdG8gYmUgYWJsZVxuICAgICAgLy8gdG8gYWNjZXNzIDEueCBsZWdhY3kgYXBpLlxuICAgICAga2xhc3MgPSBQb2x5bWVyLkxlZ2FjeUVsZW1lbnRNaXhpbihrbGFzcyk7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoYmVoYXZpb3JzKSkge1xuICAgICAgICBiZWhhdmlvcnMgPSBbYmVoYXZpb3JzXTtcbiAgICAgIH1cbiAgICAgIGxldCBzdXBlckJlaGF2aW9ycyA9IGtsYXNzLnByb3RvdHlwZS5iZWhhdmlvcnM7XG4gICAgICAvLyBnZXQgZmxhdHRlbmVkLCBkZWR1cGVkIGxpc3Qgb2YgYmVoYXZpb3JzICpub3QqIGFscmVhZHkgb24gc3VwZXIgY2xhc3NcbiAgICAgIGJlaGF2aW9ycyA9IGZsYXR0ZW5CZWhhdmlvcnMoYmVoYXZpb3JzLCBudWxsLCBzdXBlckJlaGF2aW9ycyk7XG4gICAgICAvLyBtaXhpbiBuZXcgYmVoYXZpb3JzXG4gICAgICBrbGFzcyA9IF9taXhpbkJlaGF2aW9ycyhiZWhhdmlvcnMsIGtsYXNzKTtcbiAgICAgIGlmIChzdXBlckJlaGF2aW9ycykge1xuICAgICAgICBiZWhhdmlvcnMgPSBzdXBlckJlaGF2aW9ycy5jb25jYXQoYmVoYXZpb3JzKTtcbiAgICAgIH1cbiAgICAgIC8vIFNldCBiZWhhdmlvcnMgb24gcHJvdG90eXBlIGZvciBCQy4uLlxuICAgICAga2xhc3MucHJvdG90eXBlLmJlaGF2aW9ycyA9IGJlaGF2aW9ycztcbiAgICAgIHJldHVybiBrbGFzcztcbiAgICB9XG5cbiAgICAvLyBOT1RFOlxuICAgIC8vIDEueFxuICAgIC8vIEJlaGF2aW9ycyB3ZXJlIG1peGVkIGluICppbiByZXZlcnNlIG9yZGVyKiBhbmQgZGUtZHVwZWQgb24gdGhlIGZseS5cbiAgICAvLyBUaGUgcnVsZSB3YXMgdGhhdCBiZWhhdmlvciBwcm9wZXJ0aWVzIHdlcmUgY29waWVkIG9udG8gdGhlIGVsZW1lbnRcbiAgICAvLyBwcm90b3R5cGUgaWYgYW5kIG9ubHkgaWYgdGhlIHByb3BlcnR5IGRpZCBub3QgYWxyZWFkeSBleGlzdC5cbiAgICAvLyBHaXZlbjogUG9seW1lcnsgYmVoYXZpb3JzOiBbQSwgQiwgQywgQSwgQl19LCBwcm9wZXJ0eSBjb3B5IG9yZGVyIHdhczpcbiAgICAvLyAoMSksIEIsICgyKSwgQSwgKDMpIEMuIFRoaXMgbWVhbnMgcHJvdG90eXBlIHByb3BlcnRpZXMgd2luIG92ZXJcbiAgICAvLyBCIHByb3BlcnRpZXMgd2luIG92ZXIgQSB3aW4gb3ZlciBDLiBUaGlzIG1pcnJvcnMgd2hhdCB3b3VsZCBoYXBwZW5cbiAgICAvLyB3aXRoIGluaGVyaXRhbmNlIGlmIGVsZW1lbnQgZXh0ZW5kZWQgQiBleHRlbmRlZCBBIGV4dGVuZGVkIEMuXG4gICAgLy9cbiAgICAvLyBBZ2FpbiBnaXZlbiwgUG9seW1lcnsgYmVoYXZpb3JzOiBbQSwgQiwgQywgQSwgQl19LCB0aGUgcmVzdWx0aW5nXG4gICAgLy8gYGJlaGF2aW9yc2AgYXJyYXkgd2FzIFtDLCBBLCBCXS5cbiAgICAvLyBCZWhhdmlvciBsaWZlY3ljbGUgbWV0aG9kcyB3ZXJlIGNhbGxlZCBpbiBiZWhhdmlvciBhcnJheSBvcmRlclxuICAgIC8vIGZvbGxvd2VkIGJ5IHRoZSBlbGVtZW50LCBlLmcuICgxKSBDLmNyZWF0ZWQsICgyKSBBLmNyZWF0ZWQsXG4gICAgLy8gKDMpIEIuY3JlYXRlZCwgKDQpIGVsZW1lbnQuY3JlYXRlZC4gVGhlcmUgd2FzIG5vIHN1cHBvcnQgZm9yXG4gICAgLy8gc3VwZXIsIGFuZCBcInN1cGVyLWJlaGF2aW9yXCIgbWV0aG9kcyB3ZXJlIGNhbGxhYmxlIG9ubHkgYnkgbmFtZSkuXG4gICAgLy9cbiAgICAvLyAyLnhcbiAgICAvLyBCZWhhdmlvcnMgYXJlIG1hZGUgaW50byBwcm9wZXIgbWl4aW5zIHdoaWNoIGxpdmUgaW4gdGhlXG4gICAgLy8gZWxlbWVudCdzIHByb3RvdHlwZSBjaGFpbi4gQmVoYXZpb3JzIGFyZSBwbGFjZWQgaW4gdGhlIGVsZW1lbnQgcHJvdG90eXBlXG4gICAgLy8gZWxkZXN0IHRvIHlvdW5nZXN0IGFuZCBkZS1kdXBlZCB5b3VuZ2VzdCB0byBvbGRlc3Q6XG4gICAgLy8gU28sIGZpcnN0IFtBLCBCLCBDLCBBLCBCXSBiZWNvbWVzIFtDLCBBLCBCXSB0aGVuLFxuICAgIC8vIHRoZSBlbGVtZW50IHByb3RvdHlwZSBiZWNvbWVzIChvbGRlc3QpICgxKSBQb2x5bWVyLkVsZW1lbnQsICgyKSBjbGFzcyhDKSxcbiAgICAvLyAoMykgY2xhc3MoQSksICg0KSBjbGFzcyhCKSwgKDUpIGNsYXNzKFBvbHltZXIoey4uLn0pKS5cbiAgICAvLyBSZXN1bHQ6XG4gICAgLy8gVGhpcyBtZWFucyBlbGVtZW50IHByb3BlcnRpZXMgd2luIG92ZXIgQiBwcm9wZXJ0aWVzIHdpbiBvdmVyIEEgd2luXG4gICAgLy8gb3ZlciBDLiAoc2FtZSBhcyAxLngpXG4gICAgLy8gSWYgbGlmZWN5Y2xlIGlzIGNhbGxlZCAoc3VwZXIgdGhlbiBtZSksIG9yZGVyIGlzXG4gICAgLy8gKDEpIEMuY3JlYXRlZCwgKDIpIEEuY3JlYXRlZCwgKDMpIEIuY3JlYXRlZCwgKDQpIGVsZW1lbnQuY3JlYXRlZFxuICAgIC8vIChhZ2FpbiBzYW1lIGFzIDEueClcbiAgICBmdW5jdGlvbiBfbWl4aW5CZWhhdmlvcnMoYmVoYXZpb3JzLCBrbGFzcykge1xuICAgICAgZm9yIChsZXQgaT0wOyBpPGJlaGF2aW9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgYiA9IGJlaGF2aW9yc1tpXTtcbiAgICAgICAgaWYgKGIpIHtcbiAgICAgICAgICBrbGFzcyA9IEFycmF5LmlzQXJyYXkoYikgPyBfbWl4aW5CZWhhdmlvcnMoYiwga2xhc3MpIDpcbiAgICAgICAgICAgIEdlbmVyYXRlQ2xhc3NGcm9tSW5mbyhiLCBrbGFzcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBrbGFzcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBiZWhhdmlvcnMgTGlzdCBvZiBiZWhhdmlvcnMgdG8gZmxhdHRlbi5cbiAgICAgKiBAcGFyYW0ge0FycmF5PX0gbGlzdCBUYXJnZXQgbGlzdCB0byBmbGF0dGVuIGJlaGF2aW9ycyBpbnRvLlxuICAgICAqIEBwYXJhbSB7QXJyYXk9fSBleGNsdWRlIExpc3Qgb2YgYmVoYXZpb3JzIHRvIGV4Y2x1ZGUgZnJvbSB0aGUgbGlzdC5cbiAgICAgKiBAcmV0dXJuIHshQXJyYXl9IFJldHVybnMgdGhlIGxpc3Qgb2YgZmxhdHRlbmVkIGJlaGF2aW9ycy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmbGF0dGVuQmVoYXZpb3JzKGJlaGF2aW9ycywgbGlzdCwgZXhjbHVkZSkge1xuICAgICAgbGlzdCA9IGxpc3QgfHwgW107XG4gICAgICBmb3IgKGxldCBpPWJlaGF2aW9ycy5sZW5ndGgtMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgbGV0IGIgPSBiZWhhdmlvcnNbaV07XG4gICAgICAgIGlmIChiKSB7XG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYikpIHtcbiAgICAgICAgICAgIGZsYXR0ZW5CZWhhdmlvcnMoYiwgbGlzdCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGRlZHVwXG4gICAgICAgICAgICBpZiAobGlzdC5pbmRleE9mKGIpIDwgMCAmJiAoIWV4Y2x1ZGUgfHwgZXhjbHVkZS5pbmRleE9mKGIpIDwgMCkpIHtcbiAgICAgICAgICAgICAgbGlzdC51bnNoaWZ0KGIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ2JlaGF2aW9yIGlzIG51bGwsIGNoZWNrIGZvciBtaXNzaW5nIG9yIDQwNCBpbXBvcnQnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshUG9seW1lckluaXR9IGluZm8gUG9seW1lciBpbmZvIG9iamVjdFxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24obmV3OkhUTUxFbGVtZW50KX0gQmFzZSBiYXNlIGNsYXNzIHRvIGV4dGVuZCB3aXRoIGluZm8gb2JqZWN0XG4gICAgICogQHJldHVybiB7ZnVuY3Rpb24obmV3OkhUTUxFbGVtZW50KX0gR2VuZXJhdGVkIGNsYXNzXG4gICAgICogQHN1cHByZXNzIHtjaGVja1R5cGVzfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZnVuY3Rpb24gR2VuZXJhdGVDbGFzc0Zyb21JbmZvKGluZm8sIEJhc2UpIHtcblxuICAgICAgY2xhc3MgUG9seW1lckdlbmVyYXRlZCBleHRlbmRzIEJhc2Uge1xuXG4gICAgICAgIHN0YXRpYyBnZXQgcHJvcGVydGllcygpIHtcbiAgICAgICAgICByZXR1cm4gaW5mby5wcm9wZXJ0aWVzO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGljIGdldCBvYnNlcnZlcnMoKSB7XG4gICAgICAgICAgcmV0dXJuIGluZm8ub2JzZXJ2ZXJzO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4ge0hUTUxUZW1wbGF0ZUVsZW1lbnR9IHRlbXBsYXRlIGZvciB0aGlzIGNsYXNzXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgZ2V0IHRlbXBsYXRlKCkge1xuICAgICAgICAgIC8vIGdldCB0ZW1wbGF0ZSBmaXJzdCBmcm9tIGFueSBpbXBlcmF0aXZlIHNldCBpbiBgaW5mby5fdGVtcGxhdGVgXG4gICAgICAgICAgcmV0dXJuIGluZm8uX3RlbXBsYXRlIHx8XG4gICAgICAgICAgICAvLyBuZXh0IGxvb2sgaW4gZG9tLW1vZHVsZSBhc3NvY2lhdGVkIHdpdGggdGhpcyBlbGVtZW50J3MgaXMuXG4gICAgICAgICAgICBQb2x5bWVyLkRvbU1vZHVsZSAmJiBQb2x5bWVyLkRvbU1vZHVsZS5pbXBvcnQodGhpcy5pcywgJ3RlbXBsYXRlJykgfHxcbiAgICAgICAgICAgIC8vIG5leHQgbG9vayBmb3Igc3VwZXJjbGFzcyB0ZW1wbGF0ZSAobm90ZTogdXNlIHN1cGVyY2xhc3Mgc3ltYm9sXG4gICAgICAgICAgICAvLyB0byBlbnN1cmUgY29ycmVjdCBgdGhpcy5pc2ApXG4gICAgICAgICAgICBCYXNlLnRlbXBsYXRlIHx8XG4gICAgICAgICAgICAvLyBmaW5hbGx5IGZhbGwgYmFjayB0byBgX3RlbXBsYXRlYCBpbiBlbGVtZW50J3MgcHJvdG95cGUuXG4gICAgICAgICAgICB0aGlzLnByb3RvdHlwZS5fdGVtcGxhdGUgfHxcbiAgICAgICAgICAgIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBjcmVhdGVkKCkge1xuICAgICAgICAgIHN1cGVyLmNyZWF0ZWQoKTtcbiAgICAgICAgICBpZiAoaW5mby5jcmVhdGVkKSB7XG4gICAgICAgICAgICBpbmZvLmNyZWF0ZWQuY2FsbCh0aGlzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBfcmVnaXN0ZXJlZCgpIHtcbiAgICAgICAgICBzdXBlci5fcmVnaXN0ZXJlZCgpO1xuICAgICAgICAgIC8qIE5PVEU6IGBiZWZvcmVSZWdpc3RlcmAgaXMgY2FsbGVkIGhlcmUgZm9yIGJjLCBidXQgdGhlIGJlaGF2aW9yXG4gICAgICAgICAgIGlzIGRpZmZlcmVudCB0aGFuIGluIDEueC4gSW4gMS4wLCB0aGUgbWV0aG9kIHdhcyBjYWxsZWQgKmFmdGVyKlxuICAgICAgICAgICBtaXhpbmcgcHJvdG90eXBlcyB0b2dldGhlciBidXQgKmJlZm9yZSogcHJvY2Vzc2luZyBvZiBtZXRhLW9iamVjdHMuXG4gICAgICAgICAgIEhvd2V2ZXIsIGR5bmFtaWMgZWZmZWN0cyBjYW4gc3RpbGwgYmUgc2V0IGhlcmUgYW5kIGNhbiBiZSBkb25lIGVpdGhlclxuICAgICAgICAgICBpbiBgYmVmb3JlUmVnaXN0ZXJgIG9yIGByZWdpc3RlcmVkYC4gSXQgaXMgbm8gbG9uZ2VyIHBvc3NpYmxlIHRvIHNldFxuICAgICAgICAgICBgaXNgIGluIGBiZWZvcmVSZWdpc3RlcmAgYXMgeW91IGNvdWxkIGluIDEueC5cbiAgICAgICAgICAqL1xuICAgICAgICAgIGlmIChpbmZvLmJlZm9yZVJlZ2lzdGVyKSB7XG4gICAgICAgICAgICBpbmZvLmJlZm9yZVJlZ2lzdGVyLmNhbGwoT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGluZm8ucmVnaXN0ZXJlZCkge1xuICAgICAgICAgICAgaW5mby5yZWdpc3RlcmVkLmNhbGwoT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBfYXBwbHlMaXN0ZW5lcnMoKSB7XG4gICAgICAgICAgc3VwZXIuX2FwcGx5TGlzdGVuZXJzKCk7XG4gICAgICAgICAgaWYgKGluZm8ubGlzdGVuZXJzKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBsIGluIGluZm8ubGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2FkZE1ldGhvZEV2ZW50TGlzdGVuZXJUb05vZGUodGhpcywgbCwgaW5mby5saXN0ZW5lcnNbbF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG5vdGU6IGV4Y2VwdGlvbiB0byBcInN1cGVyIHRoZW4gbWVcIiBydWxlO1xuICAgICAgICAvLyBkbyB3b3JrIGJlZm9yZSBjYWxsaW5nIHN1cGVyIHNvIHRoYXQgc3VwZXIgYXR0cmlidXRlc1xuICAgICAgICAvLyBvbmx5IGFwcGx5IGlmIG5vdCBhbHJlYWR5IHNldC5cbiAgICAgICAgX2Vuc3VyZUF0dHJpYnV0ZXMoKSB7XG4gICAgICAgICAgaWYgKGluZm8uaG9zdEF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGEgaW4gaW5mby5ob3N0QXR0cmlidXRlcykge1xuICAgICAgICAgICAgICB0aGlzLl9lbnN1cmVBdHRyaWJ1dGUoYSwgaW5mby5ob3N0QXR0cmlidXRlc1thXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHN1cGVyLl9lbnN1cmVBdHRyaWJ1dGVzKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZWFkeSgpIHtcbiAgICAgICAgICBzdXBlci5yZWFkeSgpO1xuICAgICAgICAgIGlmIChpbmZvLnJlYWR5KSB7XG4gICAgICAgICAgICBpbmZvLnJlYWR5LmNhbGwodGhpcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYXR0YWNoZWQoKSB7XG4gICAgICAgICAgc3VwZXIuYXR0YWNoZWQoKTtcbiAgICAgICAgICBpZiAoaW5mby5hdHRhY2hlZCkge1xuICAgICAgICAgICAgaW5mby5hdHRhY2hlZC5jYWxsKHRoaXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGRldGFjaGVkKCkge1xuICAgICAgICAgIHN1cGVyLmRldGFjaGVkKCk7XG4gICAgICAgICAgaWYgKGluZm8uZGV0YWNoZWQpIHtcbiAgICAgICAgICAgIGluZm8uZGV0YWNoZWQuY2FsbCh0aGlzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBhdHRyaWJ1dGVDaGFuZ2VkKG5hbWUsIG9sZCwgdmFsdWUpIHtcbiAgICAgICAgICBzdXBlci5hdHRyaWJ1dGVDaGFuZ2VkKG5hbWUsIG9sZCwgdmFsdWUpO1xuICAgICAgICAgIGlmIChpbmZvLmF0dHJpYnV0ZUNoYW5nZWQpIHtcbiAgICAgICAgICAgIGluZm8uYXR0cmlidXRlQ2hhbmdlZC5jYWxsKHRoaXMsIG5hbWUsIG9sZCwgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIFBvbHltZXJHZW5lcmF0ZWQuZ2VuZXJhdGVkRnJvbSA9IGluZm9cblxuICAgICAgZm9yIChsZXQgcCBpbiBpbmZvKSB7XG4gICAgICAgIC8vIE5PVEU6IGNhbm5vdCBjb3B5IGBtZXRhUHJvcHNgIG1ldGhvZHMgb250byBwcm90b3R5cGUgYXQgbGVhc3QgYmVjYXVzZVxuICAgICAgICAvLyBgc3VwZXIucmVhZHlgIG11c3QgYmUgY2FsbGVkIGFuZCBpcyBub3QgaW5jbHVkZWQgaW4gdGhlIHVzZXIgZm4uXG4gICAgICAgIGlmICghKHAgaW4gbWV0YVByb3BzKSkge1xuICAgICAgICAgIGxldCBwZCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaW5mbywgcCk7XG4gICAgICAgICAgaWYgKHBkKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUG9seW1lckdlbmVyYXRlZC5wcm90b3R5cGUsIHAsIHBkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFBvbHltZXJHZW5lcmF0ZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGEgY2xhc3MgdGhhdCBleHRlbmRzIGBQb2x5bWVyLkxlZ2FjeUVsZW1lbnRgIGJhc2VkIG9uIHRoZVxuICAgICAqIHByb3ZpZGVkIGluZm8gb2JqZWN0LiAgTWV0YWRhdGEgb2JqZWN0cyBvbiB0aGUgYGluZm9gIG9iamVjdFxuICAgICAqIChgcHJvcGVydGllc2AsIGBvYnNlcnZlcnNgLCBgbGlzdGVuZXJzYCwgYGJlaGF2aW9yc2AsIGBpc2ApIGFyZSB1c2VkXG4gICAgICogZm9yIFBvbHltZXIncyBtZXRhLXByb2dyYW1taW5nIHN5c3RlbXMsIGFuZCBhbnkgZnVuY3Rpb25zIGFyZSBjb3BpZWRcbiAgICAgKiB0byB0aGUgZ2VuZXJhdGVkIGNsYXNzLlxuICAgICAqXG4gICAgICogVmFsaWQgXCJtZXRhZGF0YVwiIHZhbHVlcyBhcmUgYXMgZm9sbG93czpcbiAgICAgKlxuICAgICAqIGBpc2A6IFN0cmluZyBwcm92aWRpbmcgdGhlIHRhZyBuYW1lIHRvIHJlZ2lzdGVyIHRoZSBlbGVtZW50IHVuZGVyLiBJblxuICAgICAqIGFkZGl0aW9uLCBpZiBhIGBkb20tbW9kdWxlYCB3aXRoIHRoZSBzYW1lIGlkIGV4aXN0cywgdGhlIGZpcnN0IHRlbXBsYXRlXG4gICAgICogaW4gdGhhdCBgZG9tLW1vZHVsZWAgd2lsbCBiZSBzdGFtcGVkIGludG8gdGhlIHNoYWRvdyByb290IG9mIHRoaXMgZWxlbWVudCxcbiAgICAgKiB3aXRoIHN1cHBvcnQgZm9yIGRlY2xhcmF0aXZlIGV2ZW50IGxpc3RlbmVycyAoYG9uLS4uLmApLCBQb2x5bWVyIGRhdGFcbiAgICAgKiBiaW5kaW5ncyAoYFtbLi4uXV1gIGFuZCBge3suLi59fWApLCBhbmQgaWQtYmFzZWQgbm9kZSBmaW5kaW5nIGludG9cbiAgICAgKiBgdGhpcy4kYC5cbiAgICAgKlxuICAgICAqIGBwcm9wZXJ0aWVzYDogT2JqZWN0IGRlc2NyaWJpbmcgcHJvcGVydHktcmVsYXRlZCBtZXRhZGF0YSB1c2VkIGJ5IFBvbHltZXJcbiAgICAgKiBmZWF0dXJlcyAoa2V5OiBwcm9wZXJ0eSBuYW1lcywgdmFsdWU6IG9iamVjdCBjb250YWluaW5nIHByb3BlcnR5IG1ldGFkYXRhKS5cbiAgICAgKiBWYWxpZCBrZXlzIGluIHBlci1wcm9wZXJ0eSBtZXRhZGF0YSBpbmNsdWRlOlxuICAgICAqIC0gYHR5cGVgIChTdHJpbmd8TnVtYmVyfE9iamVjdHxBcnJheXwuLi4pOiBVc2VkIGJ5XG4gICAgICogICBgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrYCB0byBkZXRlcm1pbmUgaG93IHN0cmluZy1iYXNlZCBhdHRyaWJ1dGVzXG4gICAgICogICBhcmUgZGVzZXJpYWxpemVkIHRvIEphdmFTY3JpcHQgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqIC0gYG5vdGlmeWAgKGJvb2xlYW4pOiBDYXVzZXMgYSBjaGFuZ2UgaW4gdGhlIHByb3BlcnR5IHRvIGZpcmUgYVxuICAgICAqICAgbm9uLWJ1YmJsaW5nIGV2ZW50IGNhbGxlZCBgPHByb3BlcnR5Pi1jaGFuZ2VkYC4gRWxlbWVudHMgdGhhdCBoYXZlXG4gICAgICogICBlbmFibGVkIHR3by13YXkgYmluZGluZyB0byB0aGUgcHJvcGVydHkgdXNlIHRoaXMgZXZlbnQgdG8gb2JzZXJ2ZSBjaGFuZ2VzLlxuICAgICAqIC0gYHJlYWRPbmx5YCAoYm9vbGVhbik6IENyZWF0ZXMgYSBnZXR0ZXIgZm9yIHRoZSBwcm9wZXJ0eSwgYnV0IG5vIHNldHRlci5cbiAgICAgKiAgIFRvIHNldCBhIHJlYWQtb25seSBwcm9wZXJ0eSwgdXNlIHRoZSBwcml2YXRlIHNldHRlciBtZXRob2RcbiAgICAgKiAgIGBfc2V0UHJvcGVydHkocHJvcGVydHksIHZhbHVlKWAuXG4gICAgICogLSBgb2JzZXJ2ZXJgIChzdHJpbmcpOiBPYnNlcnZlciBtZXRob2QgbmFtZSB0aGF0IHdpbGwgYmUgY2FsbGVkIHdoZW5cbiAgICAgKiAgIHRoZSBwcm9wZXJ0eSBjaGFuZ2VzLiBUaGUgYXJndW1lbnRzIG9mIHRoZSBtZXRob2QgYXJlXG4gICAgICogICBgKHZhbHVlLCBwcmV2aW91c1ZhbHVlKWAuXG4gICAgICogLSBgY29tcHV0ZWRgIChzdHJpbmcpOiBTdHJpbmcgZGVzY3JpYmluZyBtZXRob2QgYW5kIGRlcGVuZGVudCBwcm9wZXJ0aWVzXG4gICAgICogICBmb3IgY29tcHV0aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIHByb3BlcnR5IChlLmcuIGAnY29tcHV0ZUZvbyhiYXIsIHpvdCknYCkuXG4gICAgICogICBDb21wdXRlZCBwcm9wZXJ0aWVzIGFyZSByZWFkLW9ubHkgYnkgZGVmYXVsdCBhbmQgY2FuIG9ubHkgYmUgY2hhbmdlZFxuICAgICAqICAgdmlhIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGNvbXB1dGluZyBtZXRob2QuXG4gICAgICpcbiAgICAgKiBgb2JzZXJ2ZXJzYDogQXJyYXkgb2Ygc3RyaW5ncyBkZXNjcmliaW5nIG11bHRpLXByb3BlcnR5IG9ic2VydmVyIG1ldGhvZHNcbiAgICAgKiAgYW5kIHRoZWlyIGRlcGVuZGVudCBwcm9wZXJ0aWVzIChlLmcuIGAnb2JzZXJ2ZUFCQyhhLCBiLCBjKSdgKS5cbiAgICAgKlxuICAgICAqIGBsaXN0ZW5lcnNgOiBPYmplY3QgZGVzY3JpYmluZyBldmVudCBsaXN0ZW5lcnMgdG8gYmUgYWRkZWQgdG8gZWFjaFxuICAgICAqICBpbnN0YW5jZSBvZiB0aGlzIGVsZW1lbnQgKGtleTogZXZlbnQgbmFtZSwgdmFsdWU6IG1ldGhvZCBuYW1lKS5cbiAgICAgKlxuICAgICAqIGBiZWhhdmlvcnNgOiBBcnJheSBvZiBhZGRpdGlvbmFsIGBpbmZvYCBvYmplY3RzIGNvbnRhaW5pbmcgbWV0YWRhdGFcbiAgICAgKiBhbmQgY2FsbGJhY2tzIGluIHRoZSBzYW1lIGZvcm1hdCBhcyB0aGUgYGluZm9gIG9iamVjdCBoZXJlIHdoaWNoIGFyZVxuICAgICAqIG1lcmdlZCBpbnRvIHRoaXMgZWxlbWVudC5cbiAgICAgKlxuICAgICAqIGBob3N0QXR0cmlidXRlc2A6IE9iamVjdCBsaXN0aW5nIGF0dHJpYnV0ZXMgdG8gYmUgYXBwbGllZCB0byB0aGUgaG9zdFxuICAgICAqICBvbmNlIGNyZWF0ZWQgKGtleTogYXR0cmlidXRlIG5hbWUsIHZhbHVlOiBhdHRyaWJ1dGUgdmFsdWUpLiAgVmFsdWVzXG4gICAgICogIGFyZSBzZXJpYWxpemVkIGJhc2VkIG9uIHRoZSB0eXBlIG9mIHRoZSB2YWx1ZS4gIEhvc3QgYXR0cmlidXRlcyBzaG91bGRcbiAgICAgKiAgZ2VuZXJhbGx5IGJlIGxpbWl0ZWQgdG8gYXR0cmlidXRlcyBzdWNoIGFzIGB0YWJJbmRleGAgYW5kIGBhcmlhLS4uLmAuXG4gICAgICogIEF0dHJpYnV0ZXMgaW4gYGhvc3RBdHRyaWJ1dGVzYCBhcmUgb25seSBhcHBsaWVkIGlmIGEgdXNlci1zdXBwbGllZFxuICAgICAqICBhdHRyaWJ1dGUgaXMgbm90IGFscmVhZHkgcHJlc2VudCAoYXR0cmlidXRlcyBpbiBtYXJrdXAgb3ZlcnJpZGVcbiAgICAgKiAgYGhvc3RBdHRyaWJ1dGVzYCkuXG4gICAgICpcbiAgICAgKiBJbiBhZGRpdGlvbiwgdGhlIGZvbGxvd2luZyBQb2x5bWVyLXNwZWNpZmljIGNhbGxiYWNrcyBtYXkgYmUgcHJvdmlkZWQ6XG4gICAgICogLSBgcmVnaXN0ZXJlZGA6IGNhbGxlZCBhZnRlciBmaXJzdCBpbnN0YW5jZSBvZiB0aGlzIGVsZW1lbnQsXG4gICAgICogLSBgY3JlYXRlZGA6IGNhbGxlZCBkdXJpbmcgYGNvbnN0cnVjdG9yYFxuICAgICAqIC0gYGF0dGFjaGVkYDogY2FsbGVkIGR1cmluZyBgY29ubmVjdGVkQ2FsbGJhY2tgXG4gICAgICogLSBgZGV0YWNoZWRgOiBjYWxsZWQgZHVyaW5nIGBkaXNjb25uZWN0ZWRDYWxsYmFja2BcbiAgICAgKiAtIGByZWFkeWA6IGNhbGxlZCBiZWZvcmUgZmlyc3QgYGF0dGFjaGVkYCwgYWZ0ZXIgYWxsIHByb3BlcnRpZXMgb2ZcbiAgICAgKiAgIHRoaXMgZWxlbWVudCBoYXZlIGJlZW4gcHJvcGFnYXRlZCB0byBpdHMgdGVtcGxhdGUgYW5kIGFsbCBvYnNlcnZlcnNcbiAgICAgKiAgIGhhdmUgcnVuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyFQb2x5bWVySW5pdH0gaW5mbyBPYmplY3QgY29udGFpbmluZyBQb2x5bWVyIG1ldGFkYXRhIGFuZCBmdW5jdGlvbnNcbiAgICAgKiAgIHRvIGJlY29tZSBjbGFzcyBtZXRob2RzLlxuICAgICAqIEByZXR1cm4ge2Z1bmN0aW9uKG5ldzpIVE1MRWxlbWVudCl9IEdlbmVyYXRlZCBjbGFzc1xuICAgICAqIEBtZW1iZXJvZiBQb2x5bWVyXG4gICAgICovXG4gICAgUG9seW1lci5DbGFzcyA9IGZ1bmN0aW9uKGluZm8pIHtcbiAgICAgIGlmICghaW5mbykge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1BvbHltZXIuQ2xhc3MgcmVxdWlyZXMgYGluZm9gIGFyZ3VtZW50Jyk7XG4gICAgICB9XG4gICAgICBsZXQga2xhc3MgPSBHZW5lcmF0ZUNsYXNzRnJvbUluZm8oaW5mbywgaW5mby5iZWhhdmlvcnMgP1xuICAgICAgICAvLyBub3RlOiBtaXhpbkJlaGF2aW9ycyBlbnN1cmVzIGBMZWdhY3lFbGVtZW50TWl4aW5gLlxuICAgICAgICBtaXhpbkJlaGF2aW9ycyhpbmZvLmJlaGF2aW9ycywgSFRNTEVsZW1lbnQpIDpcbiAgICAgICAgUG9seW1lci5MZWdhY3lFbGVtZW50TWl4aW4oSFRNTEVsZW1lbnQpKTtcbiAgICAgIC8vIGRlY29yYXRlIGtsYXNzIHdpdGggcmVnaXN0cmF0aW9uIGluZm9cbiAgICAgIGtsYXNzLmlzID0gaW5mby5pcztcbiAgICAgIHJldHVybiBrbGFzcztcbiAgICB9XG5cbiAgICBQb2x5bWVyLm1peGluQmVoYXZpb3JzID0gbWl4aW5CZWhhdmlvcnM7XG5cbiAgfSkoKTtcblxuPC9zY3JpcHQ+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL3BvbHltZXIvbGliL2xlZ2FjeS9jbGFzcy5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuXG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vdXRpbHMvdGVtcGxhdGl6ZS5odG1sXCI+XG5cbjxzY3JpcHQ+XG4gIChmdW5jdGlvbigpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBsZXQgVGVtcGxhdGVJbnN0YW5jZUJhc2UgPSBQb2x5bWVyLlRlbXBsYXRlSW5zdGFuY2VCYXNlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7e1xuICAgICAqICAgX3RlbXBsYXRpemVyVGVtcGxhdGU6IEhUTUxUZW1wbGF0ZUVsZW1lbnQsXG4gICAgICogICBfcGFyZW50TW9kZWw6IGJvb2xlYW4sXG4gICAgICogICBfaW5zdGFuY2VQcm9wczogT2JqZWN0LFxuICAgICAqICAgX2ZvcndhcmRIb3N0UHJvcFYyOiBGdW5jdGlvbixcbiAgICAgKiAgIF9ub3RpZnlJbnN0YW5jZVByb3BWMjogRnVuY3Rpb24sXG4gICAgICogICBjdG9yOiBUZW1wbGF0ZUluc3RhbmNlQmFzZVxuICAgICAqIH19XG4gICAgICovXG4gICAgbGV0IFRlbXBsYXRpemVyVXNlcjsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gICAgLyoqXG4gICAgICogVGhlIGBQb2x5bWVyLlRlbXBsYXRpemVyYCBiZWhhdmlvciBhZGRzIG1ldGhvZHMgdG8gZ2VuZXJhdGUgaW5zdGFuY2VzIG9mXG4gICAgICogdGVtcGxhdGVzIHRoYXQgYXJlIGVhY2ggbWFuYWdlZCBieSBhbiBhbm9ueW1vdXMgYFBvbHltZXIuUHJvcGVydHlFZmZlY3RzYFxuICAgICAqIGluc3RhbmNlIHdoZXJlIGRhdGEtYmluZGluZ3MgaW4gdGhlIHN0YW1wZWQgdGVtcGxhdGUgY29udGVudCBhcmUgYm91bmQgdG9cbiAgICAgKiBhY2Nlc3NvcnMgb24gaXRzZWxmLlxuICAgICAqXG4gICAgICogVGhpcyBiZWhhdmlvciBpcyBwcm92aWRlZCBpbiBQb2x5bWVyIDIueCBhcyBhIGh5YnJpZC1lbGVtZW50IGNvbnZlbmllbmNlXG4gICAgICogb25seS4gIEZvciBub24taHlicmlkIHVzYWdlLCB0aGUgYFBvbHltZXIuVGVtcGxhdGl6ZWAgbGlicmFyeVxuICAgICAqIHNob3VsZCBiZSB1c2VkIGluc3RlYWQuXG4gICAgICpcbiAgICAgKiBFeGFtcGxlOlxuICAgICAqXG4gICAgICogICAgIC8vIEdldCBhIHRlbXBsYXRlIGZyb20gc29tZXdoZXJlLCBlLmcuIGxpZ2h0IERPTVxuICAgICAqICAgICBsZXQgdGVtcGxhdGUgPSB0aGlzLnF1ZXJ5U2VsZWN0b3IoJ3RlbXBsYXRlJyk7XG4gICAgICogICAgIC8vIFByZXBhcmUgdGhlIHRlbXBsYXRlXG4gICAgICogICAgIHRoaXMudGVtcGxhdGl6ZSh0ZW1wbGF0ZSk7XG4gICAgICogICAgIC8vIEluc3RhbmNlIHRoZSB0ZW1wbGF0ZSB3aXRoIGFuIGluaXRpYWwgZGF0YSBtb2RlbFxuICAgICAqICAgICBsZXQgaW5zdGFuY2UgPSB0aGlzLnN0YW1wKHtteVByb3A6ICdpbml0aWFsJ30pO1xuICAgICAqICAgICAvLyBJbnNlcnQgdGhlIGluc3RhbmNlJ3MgRE9NIHNvbWV3aGVyZSwgZS5nLiBsaWdodCBET01cbiAgICAgKiAgICAgUG9seW1lci5kb20odGhpcykuYXBwZW5kQ2hpbGQoaW5zdGFuY2Uucm9vdCk7XG4gICAgICogICAgIC8vIENoYW5naW5nIGEgcHJvcGVydHkgb24gdGhlIGluc3RhbmNlIHdpbGwgcHJvcGFnYXRlIHRvIGJpbmRpbmdzXG4gICAgICogICAgIC8vIGluIHRoZSB0ZW1wbGF0ZVxuICAgICAqICAgICBpbnN0YW5jZS5teVByb3AgPSAnbmV3IHZhbHVlJztcbiAgICAgKlxuICAgICAqIFVzZXJzIG9mIGBUZW1wbGF0aXplcmAgbWF5IG5lZWQgdG8gaW1wbGVtZW50IHRoZSBmb2xsb3dpbmcgYWJzdHJhY3RcbiAgICAgKiBBUEkncyB0byBkZXRlcm1pbmUgaG93IHByb3BlcnRpZXMgYW5kIHBhdGhzIGZyb20gdGhlIGhvc3Qgc2hvdWxkIGJlXG4gICAgICogZm9yd2FyZGVkIGludG8gdG8gaW5zdGFuY2VzOlxuICAgICAqXG4gICAgICogICAgIF9mb3J3YXJkSG9zdFByb3BWMjogZnVuY3Rpb24ocHJvcCwgdmFsdWUpXG4gICAgICpcbiAgICAgKiBMaWtld2lzZSwgdXNlcnMgbWF5IGltcGxlbWVudCB0aGVzZSBhZGRpdGlvbmFsIGFic3RyYWN0IEFQSSdzIHRvIGRldGVybWluZVxuICAgICAqIGhvdyBpbnN0YW5jZS1zcGVjaWZpYyBwcm9wZXJ0aWVzIHRoYXQgY2hhbmdlIG9uIHRoZSBpbnN0YW5jZSBzaG91bGQgYmVcbiAgICAgKiBmb3J3YXJkZWQgb3V0IHRvIHRoZSBob3N0LCBpZiBuZWNlc3NhcnkuXG4gICAgICpcbiAgICAgKiAgICAgX25vdGlmeUluc3RhbmNlUHJvcFYyOiBmdW5jdGlvbihpbnN0LCBwcm9wLCB2YWx1ZSlcbiAgICAgKlxuICAgICAqIEluIG9yZGVyIHRvIGRldGVybWluZSB3aGljaCBwcm9wZXJ0aWVzIGFyZSBpbnN0YW5jZS1zcGVjaWZpYyBhbmQgcmVxdWlyZVxuICAgICAqIGN1c3RvbSBub3RpZmljYXRpb24gdmlhIGBfbm90aWZ5SW5zdGFuY2VQcm9wYCwgZGVmaW5lIGFuIGBfaW5zdGFuY2VQcm9wc2BcbiAgICAgKiBvYmplY3QgY29udGFpbmluZyBrZXlzIGZvciBlYWNoIGluc3RhbmNlIHByb3AsIGZvciBleGFtcGxlOlxuICAgICAqXG4gICAgICogICAgIF9pbnN0YW5jZVByb3BzOiB7XG4gICAgICogICAgICAgaXRlbTogdHJ1ZSxcbiAgICAgKiAgICAgICBpbmRleDogdHJ1ZVxuICAgICAqICAgICB9XG4gICAgICpcbiAgICAgKiBBbnkgcHJvcGVydGllcyB1c2VkIGluIHRoZSB0ZW1wbGF0ZSB0aGF0IGFyZSBub3QgZGVmaW5lZCBpbiBfaW5zdGFuY2VQcm9wXG4gICAgICogd2lsbCBiZSBmb3J3YXJkZWQgb3V0IHRvIHRoZSBUZW1wbGF0aXplIGBvd25lcmAgYXV0b21hdGljYWxseS5cbiAgICAgKlxuICAgICAqIFVzZXJzIG1heSBhbHNvIGltcGxlbWVudCB0aGUgZm9sbG93aW5nIGFic3RyYWN0IGZ1bmN0aW9uIHRvIHNob3cgb3JcbiAgICAgKiBoaWRlIGFueSBET00gZ2VuZXJhdGVkIHVzaW5nIGBzdGFtcGA6XG4gICAgICpcbiAgICAgKiAgICAgX3Nob3dIaWRlQ2hpbGRyZW46IGZ1bmN0aW9uKHNob3VsZEhpZGUpXG4gICAgICpcbiAgICAgKiBOb3RlIHRoYXQgc29tZSBjYWxsYmFja3MgYXJlIHN1ZmZpeGVkIHdpdGggYFYyYCBpbiB0aGUgUG9seW1lciAyLnggYmVoYXZpb3JcbiAgICAgKiBhcyB0aGUgaW1wbGVtZW50YXRpb25zIHdpbGwgbmVlZCB0byBkaWZmZXIgZnJvbSB0aGUgY2FsbGJhY2tzIHJlcXVpcmVkXG4gICAgICogYnkgdGhlIDEueCBUZW1wbGF0aXplciBBUEkgZHVlIHRvIGNoYW5nZXMgaW4gdGhlIGBUZW1wbGF0ZUluc3RhbmNlYCBBUElcbiAgICAgKiBiZXR3ZWVuIHZlcnNpb25zIDEueCBhbmQgMi54LlxuICAgICAqXG4gICAgICogQHBvbHltZXJCZWhhdmlvclxuICAgICAqIEBtZW1iZXJvZiBQb2x5bWVyXG4gICAgICovXG4gICAgbGV0IFRlbXBsYXRpemVyID0ge1xuXG4gICAgICAvKipcbiAgICAgICAqIEdlbmVyYXRlcyBhbiBhbm9ueW1vdXMgYFRlbXBsYXRlSW5zdGFuY2VgIGNsYXNzIChzdG9yZWQgYXMgYHRoaXMuY3RvcmApXG4gICAgICAgKiBmb3IgdGhlIHByb3ZpZGVkIHRlbXBsYXRlLiAgVGhpcyBtZXRob2Qgc2hvdWxkIGJlIGNhbGxlZCBvbmNlIHBlclxuICAgICAgICogdGVtcGxhdGUgdG8gcHJlcGFyZSBhbiBlbGVtZW50IGZvciBzdGFtcGluZyB0aGUgdGVtcGxhdGUsIGZvbGxvd2VkXG4gICAgICAgKiBieSBgc3RhbXBgIHRvIGNyZWF0ZSBuZXcgaW5zdGFuY2VzIG9mIHRoZSB0ZW1wbGF0ZS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge0hUTUxUZW1wbGF0ZUVsZW1lbnR9IHRlbXBsYXRlIFRlbXBsYXRlIHRvIHByZXBhcmVcbiAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IG11dGFibGVEYXRhIFdoZW4gYHRydWVgLCB0aGUgZ2VuZXJhdGVkIGNsYXNzIHdpbGwgc2tpcFxuICAgICAgICogICBzdHJpY3QgZGlydHktY2hlY2tpbmcgZm9yIG9iamVjdHMgYW5kIGFycmF5cyAoYWx3YXlzIGNvbnNpZGVyIHRoZW0gdG9cbiAgICAgICAqICAgYmUgXCJkaXJ0eVwiKS4gRGVmYXVsdHMgdG8gZmFsc2UuXG4gICAgICAgKiBAdGhpcyB7VGVtcGxhdGl6ZXJVc2VyfVxuICAgICAgICovXG4gICAgICB0ZW1wbGF0aXplKHRlbXBsYXRlLCBtdXRhYmxlRGF0YSkge1xuICAgICAgICB0aGlzLl90ZW1wbGF0aXplclRlbXBsYXRlID0gdGVtcGxhdGU7XG4gICAgICAgIHRoaXMuY3RvciA9IFBvbHltZXIuVGVtcGxhdGl6ZS50ZW1wbGF0aXplKHRlbXBsYXRlLCB0aGlzLCB7XG4gICAgICAgICAgbXV0YWJsZURhdGE6IEJvb2xlYW4obXV0YWJsZURhdGEpLFxuICAgICAgICAgIHBhcmVudE1vZGVsOiB0aGlzLl9wYXJlbnRNb2RlbCxcbiAgICAgICAgICBpbnN0YW5jZVByb3BzOiB0aGlzLl9pbnN0YW5jZVByb3BzLFxuICAgICAgICAgIGZvcndhcmRIb3N0UHJvcDogdGhpcy5fZm9yd2FyZEhvc3RQcm9wVjIsXG4gICAgICAgICAgbm90aWZ5SW5zdGFuY2VQcm9wOiB0aGlzLl9ub3RpZnlJbnN0YW5jZVByb3BWMlxuICAgICAgICB9KTtcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGUgdGVtcGxhdGUgcHJlcGFyZWQgYnkgYHRlbXBsYXRpemVgLiAgVGhlIG9iamVjdFxuICAgICAgICogcmV0dXJuZWQgaXMgYW4gaW5zdGFuY2Ugb2YgdGhlIGFub255bW91cyBjbGFzcyBnZW5lcmF0ZWQgYnkgYHRlbXBsYXRpemVgXG4gICAgICAgKiB3aG9zZSBgcm9vdGAgcHJvcGVydHkgaXMgYSBkb2N1bWVudCBmcmFnbWVudCBjb250YWluaW5nIG5ld2x5IGNsb25lZFxuICAgICAgICogdGVtcGxhdGUgY29udGVudCwgYW5kIHdoaWNoIGhhcyBwcm9wZXJ0eSBhY2Nlc3NvcnMgY29ycmVzcG9uZGluZyB0b1xuICAgICAgICogcHJvcGVydGllcyByZWZlcmVuY2VkIGluIHRlbXBsYXRlIGJpbmRpbmdzLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0PX0gbW9kZWwgT2JqZWN0IGNvbnRhaW5pbmcgaW5pdGlhbCBwcm9wZXJ0eSB2YWx1ZXMgdG9cbiAgICAgICAqICAgcG9wdWxhdGUgaW50byB0aGUgdGVtcGxhdGUgYmluZGluZ3MuXG4gICAgICAgKiBAcmV0dXJuIHtUZW1wbGF0ZUluc3RhbmNlQmFzZX0gUmV0dXJucyB0aGUgY3JlYXRlZCBpbnN0YW5jZSBvZlxuICAgICAgICogdGhlIHRlbXBsYXRlIHByZXBhcmVkIGJ5IGB0ZW1wbGF0aXplYC5cbiAgICAgICAqIEB0aGlzIHtUZW1wbGF0aXplclVzZXJ9XG4gICAgICAgKi9cbiAgICAgIHN0YW1wKG1vZGVsKSB7XG4gICAgICAgIHJldHVybiBuZXcgdGhpcy5jdG9yKG1vZGVsKTtcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogUmV0dXJucyB0aGUgdGVtcGxhdGUgXCJtb2RlbFwiIChgVGVtcGxhdGVJbnN0YW5jZWApIGFzc29jaWF0ZWQgd2l0aFxuICAgICAgICogYSBnaXZlbiBlbGVtZW50LCB3aGljaCBzZXJ2ZXMgYXMgdGhlIGJpbmRpbmcgc2NvcGUgZm9yIHRoZSB0ZW1wbGF0ZVxuICAgICAgICogaW5zdGFuY2UgdGhlIGVsZW1lbnQgaXMgY29udGFpbmVkIGluLiAgQSB0ZW1wbGF0ZSBtb2RlbCBzaG91bGQgYmUgdXNlZFxuICAgICAgICogdG8gbWFuaXB1bGF0ZSBkYXRhIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHRlbXBsYXRlIGluc3RhbmNlLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIEVsZW1lbnQgZm9yIHdoaWNoIHRvIHJldHVybiBhIHRlbXBsYXRlIG1vZGVsLlxuICAgICAgICogQHJldHVybiB7VGVtcGxhdGVJbnN0YW5jZUJhc2V9IE1vZGVsIHJlcHJlc2VudGluZyB0aGUgYmluZGluZyBzY29wZSBmb3JcbiAgICAgICAqICAgdGhlIGVsZW1lbnQuXG4gICAgICAgKiBAdGhpcyB7VGVtcGxhdGl6ZXJVc2VyfVxuICAgICAgICovXG4gICAgICBtb2RlbEZvckVsZW1lbnQoZWwpIHtcbiAgICAgICAgcmV0dXJuIFBvbHltZXIuVGVtcGxhdGl6ZS5tb2RlbEZvckVsZW1lbnQodGhpcy5fdGVtcGxhdGl6ZXJUZW1wbGF0ZSwgZWwpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBQb2x5bWVyLlRlbXBsYXRpemVyID0gVGVtcGxhdGl6ZXI7XG5cbiAgfSkoKTtcbjwvc2NyaXB0PlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi9sZWdhY3kvdGVtcGxhdGl6ZXItYmVoYXZpb3IuaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cblxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3V0aWxzL2Jvb3QuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL21peGlucy9wcm9wZXJ0eS1lZmZlY3RzLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi9taXhpbnMvbXV0YWJsZS1kYXRhLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi9taXhpbnMvZ2VzdHVyZS1ldmVudC1saXN0ZW5lcnMuaHRtbFwiPlxuXG48c2NyaXB0PlxuXG4gIChmdW5jdGlvbigpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAZXh0ZW5kcyB7SFRNTEVsZW1lbnR9XG4gICAgICogQGltcGxlbWVudHMge1BvbHltZXJfUHJvcGVydHlFZmZlY3RzfVxuICAgICAqIEBpbXBsZW1lbnRzIHtQb2x5bWVyX09wdGlvbmFsTXV0YWJsZURhdGF9XG4gICAgICogQGltcGxlbWVudHMge1BvbHltZXJfR2VzdHVyZUV2ZW50TGlzdGVuZXJzfVxuICAgICAqL1xuICAgIGNvbnN0IGRvbUJpbmRCYXNlID1cbiAgICAgIFBvbHltZXIuR2VzdHVyZUV2ZW50TGlzdGVuZXJzKFxuICAgICAgICBQb2x5bWVyLk9wdGlvbmFsTXV0YWJsZURhdGEoXG4gICAgICAgICAgUG9seW1lci5Qcm9wZXJ0eUVmZmVjdHMoSFRNTEVsZW1lbnQpKSk7XG5cbiAgICAvKipcbiAgICAgKiBDdXN0b20gZWxlbWVudCB0byBhbGxvdyB1c2luZyBQb2x5bWVyJ3MgdGVtcGxhdGUgZmVhdHVyZXMgKGRhdGEgYmluZGluZyxcbiAgICAgKiBkZWNsYXJhdGl2ZSBldmVudCBsaXN0ZW5lcnMsIGV0Yy4pIGluIHRoZSBtYWluIGRvY3VtZW50IHdpdGhvdXQgZGVmaW5pbmdcbiAgICAgKiBhIG5ldyBjdXN0b20gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIGA8dGVtcGxhdGU+YCB0YWdzIHV0aWxpemluZyBiaW5kaW5ncyBtYXkgYmUgd3JhcHBlZCB3aXRoIHRoZSBgPGRvbS1iaW5kPmBcbiAgICAgKiBlbGVtZW50LCB3aGljaCB3aWxsIGltbWVkaWF0ZWx5IHN0YW1wIHRoZSB3cmFwcGVkIHRlbXBsYXRlIGludG8gdGhlIG1haW5cbiAgICAgKiBkb2N1bWVudCBhbmQgYmluZCBlbGVtZW50cyB0byB0aGUgYGRvbS1iaW5kYCBlbGVtZW50IGl0c2VsZiBhcyB0aGVcbiAgICAgKiBiaW5kaW5nIHNjb3BlLlxuICAgICAqXG4gICAgICogQHBvbHltZXJcbiAgICAgKiBAY3VzdG9tRWxlbWVudFxuICAgICAqIEBhcHBsaWVzTWl4aW4gUG9seW1lci5Qcm9wZXJ0eUVmZmVjdHNcbiAgICAgKiBAYXBwbGllc01peGluIFBvbHltZXIuT3B0aW9uYWxNdXRhYmxlRGF0YVxuICAgICAqIEBhcHBsaWVzTWl4aW4gUG9seW1lci5HZXN0dXJlRXZlbnRMaXN0ZW5lcnNcbiAgICAgKiBAZXh0ZW5kcyB7ZG9tQmluZEJhc2V9XG4gICAgICogQG1lbWJlcm9mIFBvbHltZXJcbiAgICAgKiBAc3VtbWFyeSBDdXN0b20gZWxlbWVudCB0byBhbGxvdyB1c2luZyBQb2x5bWVyJ3MgdGVtcGxhdGUgZmVhdHVyZXMgKGRhdGFcbiAgICAgKiAgIGJpbmRpbmcsIGRlY2xhcmF0aXZlIGV2ZW50IGxpc3RlbmVycywgZXRjLikgaW4gdGhlIG1haW4gZG9jdW1lbnQuXG4gICAgICovXG4gICAgY2xhc3MgRG9tQmluZCBleHRlbmRzIGRvbUJpbmRCYXNlIHtcblxuICAgICAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7IHJldHVybiBbJ211dGFibGUtZGF0YSddIH1cblxuICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMucm9vdCA9IG51bGw7XG4gICAgICAgIHRoaXMuJCA9IG51bGw7XG4gICAgICAgIHRoaXMuX19jaGlsZHJlbiA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIC8vIGFzc3VtZXMgb25seSBvbmUgb2JzZXJ2ZWQgYXR0cmlidXRlXG4gICAgICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2soKSB7XG4gICAgICAgIHRoaXMubXV0YWJsZURhdGEgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICAgIH1cblxuICAgICAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgICAgIHRoaXMuX19yZW1vdmVDaGlsZHJlbigpO1xuICAgICAgfVxuXG4gICAgICBfX2luc2VydENoaWxkcmVuKCkge1xuICAgICAgICB0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMucm9vdCwgdGhpcyk7XG4gICAgICB9XG5cbiAgICAgIF9fcmVtb3ZlQ2hpbGRyZW4oKSB7XG4gICAgICAgIGlmICh0aGlzLl9fY2hpbGRyZW4pIHtcbiAgICAgICAgICBmb3IgKGxldCBpPTA7IGk8dGhpcy5fX2NoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLnJvb3QuYXBwZW5kQ2hpbGQodGhpcy5fX2NoaWxkcmVuW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBGb3JjZXMgdGhlIGVsZW1lbnQgdG8gcmVuZGVyIGl0cyBjb250ZW50LiBUaGlzIGlzIHR5cGljYWxseSBvbmx5XG4gICAgICAgKiBuZWNlc3NhcnkgdG8gY2FsbCBpZiBIVE1MSW1wb3J0cyB3aXRoIHRoZSBhc3luYyBhdHRyaWJ1dGUgYXJlIHVzZWQuXG4gICAgICAgKi9cbiAgICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHRlbXBsYXRlO1xuICAgICAgICBpZiAoIXRoaXMuX19jaGlsZHJlbikge1xuICAgICAgICAgIHRlbXBsYXRlID0gLyoqIEB0eXBlIHtIVE1MVGVtcGxhdGVFbGVtZW50fSAqLyh0ZW1wbGF0ZSB8fCB0aGlzLnF1ZXJ5U2VsZWN0b3IoJ3RlbXBsYXRlJykpO1xuICAgICAgICAgIGlmICghdGVtcGxhdGUpIHtcbiAgICAgICAgICAgIC8vIFdhaXQgdW50aWwgY2hpbGRMaXN0IGNoYW5nZXMgYW5kIHRlbXBsYXRlIHNob3VsZCBiZSB0aGVyZSBieSB0aGVuXG4gICAgICAgICAgICBsZXQgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcigoKSA9PiB7XG4gICAgICAgICAgICAgIHRlbXBsYXRlID0gLyoqIEB0eXBlIHtIVE1MVGVtcGxhdGVFbGVtZW50fSAqLyh0aGlzLnF1ZXJ5U2VsZWN0b3IoJ3RlbXBsYXRlJykpO1xuICAgICAgICAgICAgICBpZiAodGVtcGxhdGUpIHtcbiAgICAgICAgICAgICAgICBvYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RvbS1iaW5kIHJlcXVpcmVzIGEgPHRlbXBsYXRlPiBjaGlsZCcpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgb2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLCB7Y2hpbGRMaXN0OiB0cnVlfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMucm9vdCA9IHRoaXMuX3N0YW1wVGVtcGxhdGUodGVtcGxhdGUpO1xuICAgICAgICAgIHRoaXMuJCA9IHRoaXMucm9vdC4kO1xuICAgICAgICAgIHRoaXMuX19jaGlsZHJlbiA9IFtdO1xuICAgICAgICAgIGZvciAobGV0IG49dGhpcy5yb290LmZpcnN0Q2hpbGQ7IG47IG49bi5uZXh0U2libGluZykge1xuICAgICAgICAgICAgdGhpcy5fX2NoaWxkcmVuW3RoaXMuX19jaGlsZHJlbi5sZW5ndGhdID0gbjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fZW5hYmxlUHJvcGVydGllcygpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX19pbnNlcnRDaGlsZHJlbigpO1xuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KCdkb20tY2hhbmdlJywge1xuICAgICAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICAgICAgY29tcG9zZWQ6IHRydWVcbiAgICAgICAgfSkpO1xuICAgICAgfVxuXG4gICAgfVxuXG4gICAgY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdkb20tYmluZCcsIERvbUJpbmQpO1xuXG4gIH0pKCk7XG5cbjwvc2NyaXB0PlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi9lbGVtZW50cy9kb20tYmluZC5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuXG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vLi4vcG9seW1lci1lbGVtZW50Lmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi91dGlscy90ZW1wbGF0aXplLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi91dGlscy9kZWJvdW5jZS5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vdXRpbHMvZmx1c2guaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL21peGlucy9tdXRhYmxlLWRhdGEuaHRtbFwiPlxuXG48c2NyaXB0PlxuKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgbGV0IFRlbXBsYXRlSW5zdGFuY2VCYXNlID0gUG9seW1lci5UZW1wbGF0ZUluc3RhbmNlQmFzZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQGltcGxlbWVudHMge1BvbHltZXJfT3B0aW9uYWxNdXRhYmxlRGF0YX1cbiAgICogQGV4dGVuZHMge1BvbHltZXIuRWxlbWVudH1cbiAgICovXG4gIGNvbnN0IGRvbVJlcGVhdEJhc2UgPSBQb2x5bWVyLk9wdGlvbmFsTXV0YWJsZURhdGEoUG9seW1lci5FbGVtZW50KTtcblxuICAvKipcbiAgICogVGhlIGA8ZG9tLXJlcGVhdD5gIGVsZW1lbnQgd2lsbCBhdXRvbWF0aWNhbGx5IHN0YW1wIGFuZCBiaW5kcyBvbmUgaW5zdGFuY2VcbiAgICogb2YgdGVtcGxhdGUgY29udGVudCB0byBlYWNoIG9iamVjdCBpbiBhIHVzZXItcHJvdmlkZWQgYXJyYXkuXG4gICAqIGBkb20tcmVwZWF0YCBhY2NlcHRzIGFuIGBpdGVtc2AgcHJvcGVydHksIGFuZCBvbmUgaW5zdGFuY2Ugb2YgdGhlIHRlbXBsYXRlXG4gICAqIGlzIHN0YW1wZWQgZm9yIGVhY2ggaXRlbSBpbnRvIHRoZSBET00gYXQgdGhlIGxvY2F0aW9uIG9mIHRoZSBgZG9tLXJlcGVhdGBcbiAgICogZWxlbWVudC4gIFRoZSBgaXRlbWAgcHJvcGVydHkgd2lsbCBiZSBzZXQgb24gZWFjaCBpbnN0YW5jZSdzIGJpbmRpbmdcbiAgICogc2NvcGUsIHRodXMgdGVtcGxhdGVzIHNob3VsZCBiaW5kIHRvIHN1Yi1wcm9wZXJ0aWVzIG9mIGBpdGVtYC5cbiAgICpcbiAgICogRXhhbXBsZTpcbiAgICpcbiAgICogYGBgaHRtbFxuICAgKiA8ZG9tLW1vZHVsZSBpZD1cImVtcGxveWVlLWxpc3RcIj5cbiAgICpcbiAgICogICA8dGVtcGxhdGU+XG4gICAqXG4gICAqICAgICA8ZGl2PiBFbXBsb3llZSBsaXN0OiA8L2Rpdj5cbiAgICogICAgIDx0ZW1wbGF0ZSBpcz1cImRvbS1yZXBlYXRcIiBpdGVtcz1cInt7ZW1wbG95ZWVzfX1cIj5cbiAgICogICAgICAgICA8ZGl2PkZpcnN0IG5hbWU6IDxzcGFuPnt7aXRlbS5maXJzdH19PC9zcGFuPjwvZGl2PlxuICAgKiAgICAgICAgIDxkaXY+TGFzdCBuYW1lOiA8c3Bhbj57e2l0ZW0ubGFzdH19PC9zcGFuPjwvZGl2PlxuICAgKiAgICAgPC90ZW1wbGF0ZT5cbiAgICpcbiAgICogICA8L3RlbXBsYXRlPlxuICAgKlxuICAgKiAgIDxzY3JpcHQ+XG4gICAqICAgICBQb2x5bWVyKHtcbiAgICogICAgICAgaXM6ICdlbXBsb3llZS1saXN0JyxcbiAgICogICAgICAgcmVhZHk6IGZ1bmN0aW9uKCkge1xuICAgKiAgICAgICAgIHRoaXMuZW1wbG95ZWVzID0gW1xuICAgKiAgICAgICAgICAgICB7Zmlyc3Q6ICdCb2InLCBsYXN0OiAnU21pdGgnfSxcbiAgICogICAgICAgICAgICAge2ZpcnN0OiAnU2FsbHknLCBsYXN0OiAnSm9obnNvbid9LFxuICAgKiAgICAgICAgICAgICAuLi5cbiAgICogICAgICAgICBdO1xuICAgKiAgICAgICB9XG4gICAqICAgICB9KTtcbiAgICogICA8IC9zY3JpcHQ+XG4gICAqXG4gICAqIDwvZG9tLW1vZHVsZT5cbiAgICogYGBgXG4gICAqXG4gICAqIE5vdGlmaWNhdGlvbnMgZm9yIGNoYW5nZXMgdG8gaXRlbXMgc3ViLXByb3BlcnRpZXMgd2lsbCBiZSBmb3J3YXJkZWQgdG8gdGVtcGxhdGVcbiAgICogaW5zdGFuY2VzLCB3aGljaCB3aWxsIHVwZGF0ZSB2aWEgdGhlIG5vcm1hbCBzdHJ1Y3R1cmVkIGRhdGEgbm90aWZpY2F0aW9uIHN5c3RlbS5cbiAgICpcbiAgICogTXV0YXRpb25zIHRvIHRoZSBgaXRlbXNgIGFycmF5IGl0c2VsZiBzaG91bGQgYmUgbWFkZSB1c2luZyB0aGUgQXJyYXlcbiAgICogbXV0YXRpb24gQVBJJ3Mgb24gYFBvbHltZXIuQmFzZWAgKGBwdXNoYCwgYHBvcGAsIGBzcGxpY2VgLCBgc2hpZnRgLFxuICAgKiBgdW5zaGlmdGApLCBhbmQgdGVtcGxhdGUgaW5zdGFuY2VzIHdpbGwgYmUga2VwdCBpbiBzeW5jIHdpdGggdGhlIGRhdGEgaW4gdGhlXG4gICAqIGFycmF5LlxuICAgKlxuICAgKiBFdmVudHMgY2F1Z2h0IGJ5IGV2ZW50IGhhbmRsZXJzIHdpdGhpbiB0aGUgYGRvbS1yZXBlYXRgIHRlbXBsYXRlIHdpbGwgYmVcbiAgICogZGVjb3JhdGVkIHdpdGggYSBgbW9kZWxgIHByb3BlcnR5LCB3aGljaCByZXByZXNlbnRzIHRoZSBiaW5kaW5nIHNjb3BlIGZvclxuICAgKiBlYWNoIHRlbXBsYXRlIGluc3RhbmNlLiAgVGhlIG1vZGVsIGlzIGFuIGluc3RhbmNlIG9mIFBvbHltZXIuQmFzZSwgYW5kIHNob3VsZFxuICAgKiBiZSB1c2VkIHRvIG1hbmlwdWxhdGUgZGF0YSBvbiB0aGUgaW5zdGFuY2UsIGZvciBleGFtcGxlXG4gICAqIGBldmVudC5tb2RlbC5zZXQoJ2l0ZW0uY2hlY2tlZCcsIHRydWUpO2AuXG4gICAqXG4gICAqIEFsdGVybmF0aXZlbHksIHRoZSBtb2RlbCBmb3IgYSB0ZW1wbGF0ZSBpbnN0YW5jZSBmb3IgYW4gZWxlbWVudCBzdGFtcGVkIGJ5XG4gICAqIGEgYGRvbS1yZXBlYXRgIGNhbiBiZSBvYnRhaW5lZCB1c2luZyB0aGUgYG1vZGVsRm9yRWxlbWVudGAgQVBJIG9uIHRoZVxuICAgKiBgZG9tLXJlcGVhdGAgdGhhdCBzdGFtcGVkIGl0LCBmb3IgZXhhbXBsZVxuICAgKiBgdGhpcy4kLmRvbVJlcGVhdC5tb2RlbEZvckVsZW1lbnQoZXZlbnQudGFyZ2V0KS5zZXQoJ2l0ZW0uY2hlY2tlZCcsIHRydWUpO2AuXG4gICAqIFRoaXMgbWF5IGJlIHVzZWZ1bCBmb3IgbWFuaXB1bGF0aW5nIGluc3RhbmNlIGRhdGEgb2YgZXZlbnQgdGFyZ2V0cyBvYnRhaW5lZFxuICAgKiBieSBldmVudCBoYW5kbGVycyBvbiBwYXJlbnRzIG9mIHRoZSBgZG9tLXJlcGVhdGAgKGV2ZW50IGRlbGVnYXRpb24pLlxuICAgKlxuICAgKiBBIHZpZXctc3BlY2lmaWMgZmlsdGVyL3NvcnQgbWF5IGJlIGFwcGxpZWQgdG8gZWFjaCBgZG9tLXJlcGVhdGAgYnkgc3VwcGx5aW5nIGFcbiAgICogYGZpbHRlcmAgYW5kL29yIGBzb3J0YCBwcm9wZXJ0eS4gIFRoaXMgbWF5IGJlIGEgc3RyaW5nIHRoYXQgbmFtZXMgYSBmdW5jdGlvbiBvblxuICAgKiB0aGUgaG9zdCwgb3IgYSBmdW5jdGlvbiBtYXkgYmUgYXNzaWduZWQgdG8gdGhlIHByb3BlcnR5IGRpcmVjdGx5LiAgVGhlIGZ1bmN0aW9uc1xuICAgKiBzaG91bGQgaW1wbGVtZW50ZWQgZm9sbG93aW5nIHRoZSBzdGFuZGFyZCBgQXJyYXlgIGZpbHRlci9zb3J0IEFQSS5cbiAgICpcbiAgICogSW4gb3JkZXIgdG8gcmUtcnVuIHRoZSBmaWx0ZXIgb3Igc29ydCBmdW5jdGlvbnMgYmFzZWQgb24gY2hhbmdlcyB0byBzdWItZmllbGRzXG4gICAqIG9mIGBpdGVtc2AsIHRoZSBgb2JzZXJ2ZWAgcHJvcGVydHkgbWF5IGJlIHNldCBhcyBhIHNwYWNlLXNlcGFyYXRlZCBsaXN0IG9mXG4gICAqIGBpdGVtYCBzdWItZmllbGRzIHRoYXQgc2hvdWxkIGNhdXNlIGEgcmUtZmlsdGVyL3NvcnQgd2hlbiBtb2RpZmllZC4gIElmXG4gICAqIHRoZSBmaWx0ZXIgb3Igc29ydCBmdW5jdGlvbiBkZXBlbmRzIG9uIHByb3BlcnRpZXMgbm90IGNvbnRhaW5lZCBpbiBgaXRlbXNgLFxuICAgKiB0aGUgdXNlciBzaG91bGQgb2JzZXJ2ZSBjaGFuZ2VzIHRvIHRob3NlIHByb3BlcnRpZXMgYW5kIGNhbGwgYHJlbmRlcmAgdG8gdXBkYXRlXG4gICAqIHRoZSB2aWV3IGJhc2VkIG9uIHRoZSBkZXBlbmRlbmN5IGNoYW5nZS5cbiAgICpcbiAgICogRm9yIGV4YW1wbGUsIGZvciBhbiBgZG9tLXJlcGVhdGAgd2l0aCBhIGZpbHRlciBvZiB0aGUgZm9sbG93aW5nOlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiBpc0VuZ2luZWVyOiBmdW5jdGlvbihpdGVtKSB7XG4gICAqICAgICByZXR1cm4gaXRlbS50eXBlID09ICdlbmdpbmVlcicgfHwgaXRlbS5tYW5hZ2VyLnR5cGUgPT0gJ2VuZ2luZWVyJztcbiAgICogfVxuICAgKiBgYGBcbiAgICpcbiAgICogVGhlbiB0aGUgYG9ic2VydmVgIHByb3BlcnR5IHNob3VsZCBiZSBjb25maWd1cmVkIGFzIGZvbGxvd3M6XG4gICAqXG4gICAqIGBgYGh0bWxcbiAgICogPHRlbXBsYXRlIGlzPVwiZG9tLXJlcGVhdFwiIGl0ZW1zPVwie3tlbXBsb3llZXN9fVwiXG4gICAqICAgICAgICAgICBmaWx0ZXI9XCJpc0VuZ2luZWVyXCIgb2JzZXJ2ZT1cInR5cGUgbWFuYWdlci50eXBlXCI+XG4gICAqIGBgYFxuICAgKlxuICAgKiBAY3VzdG9tRWxlbWVudFxuICAgKiBAcG9seW1lclxuICAgKiBAbWVtYmVyb2YgUG9seW1lclxuICAgKiBAZXh0ZW5kcyB7ZG9tUmVwZWF0QmFzZX1cbiAgICogQGFwcGxpZXNNaXhpbiBQb2x5bWVyLk9wdGlvbmFsTXV0YWJsZURhdGFcbiAgICogQHN1bW1hcnkgQ3VzdG9tIGVsZW1lbnQgZm9yIHN0YW1waW5nIGluc3RhbmNlIG9mIGEgdGVtcGxhdGUgYm91bmQgdG9cbiAgICogICBpdGVtcyBpbiBhbiBhcnJheS5cbiAgICovXG4gIGNsYXNzIERvbVJlcGVhdCBleHRlbmRzIGRvbVJlcGVhdEJhc2Uge1xuXG4gICAgLy8gTm90IG5lZWRlZCB0byBmaW5kIHRlbXBsYXRlOyBjYW4gYmUgcmVtb3ZlZCBvbmNlIHRoZSBhbmFseXplclxuICAgIC8vIGNhbiBmaW5kIHRoZSB0YWcgbmFtZSBmcm9tIGN1c3RvbUVsZW1lbnRzLmRlZmluZSBjYWxsXG4gICAgc3RhdGljIGdldCBpcygpIHsgcmV0dXJuICdkb20tcmVwZWF0JzsgfVxuXG4gICAgc3RhdGljIGdldCB0ZW1wbGF0ZSgpIHsgcmV0dXJuIG51bGw7IH1cblxuICAgIHN0YXRpYyBnZXQgcHJvcGVydGllcygpIHtcblxuICAgICAgLyoqXG4gICAgICAgKiBGaXJlZCB3aGVuZXZlciBET00gaXMgYWRkZWQgb3IgcmVtb3ZlZCBieSB0aGlzIHRlbXBsYXRlIChieVxuICAgICAgICogZGVmYXVsdCwgcmVuZGVyaW5nIG9jY3VycyBsYXppbHkpLiAgVG8gZm9yY2UgaW1tZWRpYXRlIHJlbmRlcmluZywgY2FsbFxuICAgICAgICogYHJlbmRlcmAuXG4gICAgICAgKlxuICAgICAgICogQGV2ZW50IGRvbS1jaGFuZ2VcbiAgICAgICAqL1xuICAgICAgcmV0dXJuIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQW4gYXJyYXkgY29udGFpbmluZyBpdGVtcyBkZXRlcm1pbmluZyBob3cgbWFueSBpbnN0YW5jZXMgb2YgdGhlIHRlbXBsYXRlXG4gICAgICAgICAqIHRvIHN0YW1wIGFuZCB0aGF0IHRoYXQgZWFjaCB0ZW1wbGF0ZSBpbnN0YW5jZSBzaG91bGQgYmluZCB0by5cbiAgICAgICAgICovXG4gICAgICAgIGl0ZW1zOiB7XG4gICAgICAgICAgdHlwZTogQXJyYXlcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG5hbWUgb2YgdGhlIHZhcmlhYmxlIHRvIGFkZCB0byB0aGUgYmluZGluZyBzY29wZSBmb3IgdGhlIGFycmF5XG4gICAgICAgICAqIGVsZW1lbnQgYXNzb2NpYXRlZCB3aXRoIGEgZ2l2ZW4gdGVtcGxhdGUgaW5zdGFuY2UuXG4gICAgICAgICAqL1xuICAgICAgICBhczoge1xuICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICB2YWx1ZTogJ2l0ZW0nXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBuYW1lIG9mIHRoZSB2YXJpYWJsZSB0byBhZGQgdG8gdGhlIGJpbmRpbmcgc2NvcGUgd2l0aCB0aGUgaW5kZXhcbiAgICAgICAgICogb2YgdGhlIGluc3RhbmNlIGluIHRoZSBzb3J0ZWQgYW5kIGZpbHRlcmVkIGxpc3Qgb2YgcmVuZGVyZWQgaXRlbXMuXG4gICAgICAgICAqIE5vdGUsIGZvciB0aGUgaW5kZXggaW4gdGhlIGB0aGlzLml0ZW1zYCBhcnJheSwgdXNlIHRoZSB2YWx1ZSBvZiB0aGVcbiAgICAgICAgICogYGl0ZW1zSW5kZXhBc2AgcHJvcGVydHkuXG4gICAgICAgICAqL1xuICAgICAgICBpbmRleEFzOiB7XG4gICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgIHZhbHVlOiAnaW5kZXgnXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBuYW1lIG9mIHRoZSB2YXJpYWJsZSB0byBhZGQgdG8gdGhlIGJpbmRpbmcgc2NvcGUgd2l0aCB0aGUgaW5kZXhcbiAgICAgICAgICogb2YgdGhlIGluc3RhbmNlIGluIHRoZSBgdGhpcy5pdGVtc2AgYXJyYXkuIE5vdGUsIGZvciB0aGUgaW5kZXggb2ZcbiAgICAgICAgICogdGhpcyBpbnN0YW5jZSBpbiB0aGUgc29ydGVkIGFuZCBmaWx0ZXJlZCBsaXN0IG9mIHJlbmRlcmVkIGl0ZW1zLFxuICAgICAgICAgKiB1c2UgdGhlIHZhbHVlIG9mIHRoZSBgaW5kZXhBc2AgcHJvcGVydHkuXG4gICAgICAgICAqL1xuICAgICAgICBpdGVtc0luZGV4QXM6IHtcbiAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgdmFsdWU6ICdpdGVtc0luZGV4J1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGZ1bmN0aW9uIHRoYXQgc2hvdWxkIGRldGVybWluZSB0aGUgc29ydCBvcmRlciBvZiB0aGUgaXRlbXMuICBUaGlzXG4gICAgICAgICAqIHByb3BlcnR5IHNob3VsZCBlaXRoZXIgYmUgcHJvdmlkZWQgYXMgYSBzdHJpbmcsIGluZGljYXRpbmcgYSBtZXRob2RcbiAgICAgICAgICogbmFtZSBvbiB0aGUgZWxlbWVudCdzIGhvc3QsIG9yIGVsc2UgYmUgYW4gYWN0dWFsIGZ1bmN0aW9uLiAgVGhlXG4gICAgICAgICAqIGZ1bmN0aW9uIHNob3VsZCBtYXRjaCB0aGUgc29ydCBmdW5jdGlvbiBwYXNzZWQgdG8gYEFycmF5LnNvcnRgLlxuICAgICAgICAgKiBVc2luZyBhIHNvcnQgZnVuY3Rpb24gaGFzIG5vIGVmZmVjdCBvbiB0aGUgdW5kZXJseWluZyBgaXRlbXNgIGFycmF5LlxuICAgICAgICAgKi9cbiAgICAgICAgc29ydDoge1xuICAgICAgICAgIHR5cGU6IEZ1bmN0aW9uLFxuICAgICAgICAgIG9ic2VydmVyOiAnX19zb3J0Q2hhbmdlZCdcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQSBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIHRvIGZpbHRlciBpdGVtcyBvdXQgb2YgdGhlIHZpZXcuICBUaGlzXG4gICAgICAgICAqIHByb3BlcnR5IHNob3VsZCBlaXRoZXIgYmUgcHJvdmlkZWQgYXMgYSBzdHJpbmcsIGluZGljYXRpbmcgYSBtZXRob2RcbiAgICAgICAgICogbmFtZSBvbiB0aGUgZWxlbWVudCdzIGhvc3QsIG9yIGVsc2UgYmUgYW4gYWN0dWFsIGZ1bmN0aW9uLiAgVGhlXG4gICAgICAgICAqIGZ1bmN0aW9uIHNob3VsZCBtYXRjaCB0aGUgc29ydCBmdW5jdGlvbiBwYXNzZWQgdG8gYEFycmF5LmZpbHRlcmAuXG4gICAgICAgICAqIFVzaW5nIGEgZmlsdGVyIGZ1bmN0aW9uIGhhcyBubyBlZmZlY3Qgb24gdGhlIHVuZGVybHlpbmcgYGl0ZW1zYCBhcnJheS5cbiAgICAgICAgICovXG4gICAgICAgIGZpbHRlcjoge1xuICAgICAgICAgIHR5cGU6IEZ1bmN0aW9uLFxuICAgICAgICAgIG9ic2VydmVyOiAnX19maWx0ZXJDaGFuZ2VkJ1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGVuIHVzaW5nIGEgYGZpbHRlcmAgb3IgYHNvcnRgIGZ1bmN0aW9uLCB0aGUgYG9ic2VydmVgIHByb3BlcnR5XG4gICAgICAgICAqIHNob3VsZCBiZSBzZXQgdG8gYSBzcGFjZS1zZXBhcmF0ZWQgbGlzdCBvZiB0aGUgbmFtZXMgb2YgaXRlbVxuICAgICAgICAgKiBzdWItZmllbGRzIHRoYXQgc2hvdWxkIHRyaWdnZXIgYSByZS1zb3J0IG9yIHJlLWZpbHRlciB3aGVuIGNoYW5nZWQuXG4gICAgICAgICAqIFRoZXNlIHNob3VsZCBnZW5lcmFsbHkgYmUgZmllbGRzIG9mIGBpdGVtYCB0aGF0IHRoZSBzb3J0IG9yIGZpbHRlclxuICAgICAgICAgKiBmdW5jdGlvbiBkZXBlbmRzIG9uLlxuICAgICAgICAgKi9cbiAgICAgICAgb2JzZXJ2ZToge1xuICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICBvYnNlcnZlcjogJ19fb2JzZXJ2ZUNoYW5nZWQnXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZW4gdXNpbmcgYSBgZmlsdGVyYCBvciBgc29ydGAgZnVuY3Rpb24sIHRoZSBgZGVsYXlgIHByb3BlcnR5XG4gICAgICAgICAqIGRldGVybWluZXMgYSBkZWJvdW5jZSB0aW1lIGFmdGVyIGEgY2hhbmdlIHRvIG9ic2VydmVkIGl0ZW1cbiAgICAgICAgICogcHJvcGVydGllcyB0aGF0IG11c3QgcGFzcyBiZWZvcmUgdGhlIGZpbHRlciBvciBzb3J0IGlzIHJlLXJ1bi5cbiAgICAgICAgICogVGhpcyBpcyB1c2VmdWwgaW4gcmF0ZS1saW1pdGluZyBzaHVmZmluZyBvZiB0aGUgdmlldyB3aGVuXG4gICAgICAgICAqIGl0ZW0gY2hhbmdlcyBtYXkgYmUgZnJlcXVlbnQuXG4gICAgICAgICAqL1xuICAgICAgICBkZWxheTogTnVtYmVyLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb3VudCBvZiBjdXJyZW50bHkgcmVuZGVyZWQgaXRlbXMgYWZ0ZXIgYGZpbHRlcmAgKGlmIGFueSkgaGFzIGJlZW4gYXBwbGllZC5cbiAgICAgICAgICogSWYgXCJjaHVua2luZyBtb2RlXCIgaXMgZW5hYmxlZCwgYHJlbmRlcmVkSXRlbUNvdW50YCBpcyB1cGRhdGVkIGVhY2ggdGltZSBhXG4gICAgICAgICAqIHNldCBvZiB0ZW1wbGF0ZSBpbnN0YW5jZXMgaXMgcmVuZGVyZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICByZW5kZXJlZEl0ZW1Db3VudDoge1xuICAgICAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgICAgICBub3RpZnk6IHRydWUsXG4gICAgICAgICAgcmVhZE9ubHk6IHRydWVcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGVmaW5lcyBhbiBpbml0aWFsIGNvdW50IG9mIHRlbXBsYXRlIGluc3RhbmNlcyB0byByZW5kZXIgYWZ0ZXIgc2V0dGluZ1xuICAgICAgICAgKiB0aGUgYGl0ZW1zYCBhcnJheSwgYmVmb3JlIHRoZSBuZXh0IHBhaW50LCBhbmQgcHV0cyB0aGUgYGRvbS1yZXBlYXRgXG4gICAgICAgICAqIGludG8gXCJjaHVua2luZyBtb2RlXCIuICBUaGUgcmVtYWluaW5nIGl0ZW1zIHdpbGwgYmUgY3JlYXRlZCBhbmQgcmVuZGVyZWRcbiAgICAgICAgICogaW5jcmVtZW50YWxseSBhdCBlYWNoIGFuaW1hdGlvbiBmcmFtZSB0aGVyb2YgdW50aWwgYWxsIGluc3RhbmNlcyBoYXZlXG4gICAgICAgICAqIGJlZW4gcmVuZGVyZWQuXG4gICAgICAgICAqL1xuICAgICAgICBpbml0aWFsQ291bnQ6IHtcbiAgICAgICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICAgICAgb2JzZXJ2ZXI6ICdfX2luaXRpYWxpemVDaHVua2luZydcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogV2hlbiBgaW5pdGlhbENvdW50YCBpcyB1c2VkLCB0aGlzIHByb3BlcnR5IGRlZmluZXMgYSBmcmFtZSByYXRlIHRvXG4gICAgICAgICAqIHRhcmdldCBieSB0aHJvdHRsaW5nIHRoZSBudW1iZXIgb2YgaW5zdGFuY2VzIHJlbmRlcmVkIGVhY2ggZnJhbWUgdG9cbiAgICAgICAgICogbm90IGV4Y2VlZCB0aGUgYnVkZ2V0IGZvciB0aGUgdGFyZ2V0IGZyYW1lIHJhdGUuICBTZXR0aW5nIHRoaXMgdG8gYVxuICAgICAgICAgKiBoaWdoZXIgbnVtYmVyIHdpbGwgYWxsb3cgbG93ZXIgbGF0ZW5jeSBhbmQgaGlnaGVyIHRocm91Z2hwdXQgZm9yXG4gICAgICAgICAqIHRoaW5ncyBsaWtlIGV2ZW50IGhhbmRsZXJzLCBidXQgd2lsbCByZXN1bHQgaW4gYSBsb25nZXIgdGltZSBmb3IgdGhlXG4gICAgICAgICAqIHJlbWFpbmluZyBpdGVtcyB0byBjb21wbGV0ZSByZW5kZXJpbmcuXG4gICAgICAgICAqL1xuICAgICAgICB0YXJnZXRGcmFtZXJhdGU6IHtcbiAgICAgICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICAgICAgdmFsdWU6IDIwXG4gICAgICAgIH0sXG5cbiAgICAgICAgX3RhcmdldEZyYW1lVGltZToge1xuICAgICAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgICAgICBjb21wdXRlZDogJ19fY29tcHV0ZUZyYW1lVGltZSh0YXJnZXRGcmFtZXJhdGUpJ1xuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgIH1cblxuICAgIHN0YXRpYyBnZXQgb2JzZXJ2ZXJzKCkge1xuICAgICAgcmV0dXJuIFsgJ19faXRlbXNDaGFuZ2VkKGl0ZW1zLiopJyBdXG4gICAgfVxuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICBzdXBlcigpO1xuICAgICAgdGhpcy5fX2luc3RhbmNlcyA9IFtdO1xuICAgICAgdGhpcy5fX2xpbWl0ID0gSW5maW5pdHk7XG4gICAgICB0aGlzLl9fcG9vbCA9IFtdO1xuICAgICAgdGhpcy5fX3JlbmRlckRlYm91bmNlciA9IG51bGw7XG4gICAgICB0aGlzLl9faXRlbXNJZHhUb0luc3RJZHggPSB7fTtcbiAgICAgIHRoaXMuX19jaHVua0NvdW50ID0gbnVsbDtcbiAgICAgIHRoaXMuX19sYXN0Q2h1bmtUaW1lID0gbnVsbDtcbiAgICAgIHRoaXMuX19zb3J0Rm4gPSBudWxsO1xuICAgICAgdGhpcy5fX2ZpbHRlckZuID0gbnVsbDtcbiAgICAgIHRoaXMuX19vYnNlcnZlUGF0aHMgPSBudWxsO1xuICAgICAgdGhpcy5fX2N0b3IgPSBudWxsO1xuICAgICAgdGhpcy5fX2lzRGV0YWNoZWQgPSB0cnVlO1xuICAgICAgdGhpcy50ZW1wbGF0ZSA9IG51bGw7XG4gICAgfVxuXG4gICAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgICBzdXBlci5kaXNjb25uZWN0ZWRDYWxsYmFjaygpO1xuICAgICAgdGhpcy5fX2lzRGV0YWNoZWQgPSB0cnVlO1xuICAgICAgZm9yIChsZXQgaT0wOyBpPHRoaXMuX19pbnN0YW5jZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5fX2RldGFjaEluc3RhbmNlKGkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgICAgc3VwZXIuY29ubmVjdGVkQ2FsbGJhY2soKTtcbiAgICAgIC8vIG9ubHkgcGVyZm9ybSBhdHRhY2htZW50IGlmIHRoZSBlbGVtZW50IHdhcyBwcmV2aW91c2x5IGRldGFjaGVkLlxuICAgICAgaWYgKHRoaXMuX19pc0RldGFjaGVkKSB7XG4gICAgICAgIHRoaXMuX19pc0RldGFjaGVkID0gZmFsc2U7XG4gICAgICAgIGxldCBwYXJlbnQgPSB0aGlzLnBhcmVudE5vZGU7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTx0aGlzLl9faW5zdGFuY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdGhpcy5fX2F0dGFjaEluc3RhbmNlKGksIHBhcmVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBfX2Vuc3VyZVRlbXBsYXRpemVkKCkge1xuICAgICAgLy8gVGVtcGxhdGl6aW5nIChnZW5lcmF0aW5nIHRoZSBpbnN0YW5jZSBjb25zdHJ1Y3RvcikgbmVlZHMgdG8gd2FpdFxuICAgICAgLy8gdW50aWwgcmVhZHksIHNpbmNlIHdvbid0IGhhdmUgaXRzIHRlbXBsYXRlIGNvbnRlbnQgaGFuZGVkIGJhY2sgdG9cbiAgICAgIC8vIGl0IHVudGlsIHRoZW5cbiAgICAgIGlmICghdGhpcy5fX2N0b3IpIHtcbiAgICAgICAgbGV0IHRlbXBsYXRlID0gdGhpcy50ZW1wbGF0ZSA9IHRoaXMucXVlcnlTZWxlY3RvcigndGVtcGxhdGUnKTtcbiAgICAgICAgaWYgKCF0ZW1wbGF0ZSkge1xuICAgICAgICAgIC8vIC8vIFdhaXQgdW50aWwgY2hpbGRMaXN0IGNoYW5nZXMgYW5kIHRlbXBsYXRlIHNob3VsZCBiZSB0aGVyZSBieSB0aGVuXG4gICAgICAgICAgbGV0IG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMucXVlcnlTZWxlY3RvcigndGVtcGxhdGUnKSkge1xuICAgICAgICAgICAgICBvYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICAgIHRoaXMuX19yZW5kZXIoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZG9tLXJlcGVhdCByZXF1aXJlcyBhIDx0ZW1wbGF0ZT4gY2hpbGQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICAgIG9ic2VydmVyLm9ic2VydmUodGhpcywge2NoaWxkTGlzdDogdHJ1ZX0pO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUZW1wbGF0ZSBpbnN0YW5jZSBwcm9wcyB0aGF0IHNob3VsZCBiZSBleGNsdWRlZCBmcm9tIGZvcndhcmRpbmdcbiAgICAgICAgbGV0IGluc3RhbmNlUHJvcHMgPSB7fTtcbiAgICAgICAgaW5zdGFuY2VQcm9wc1t0aGlzLmFzXSA9IHRydWU7XG4gICAgICAgIGluc3RhbmNlUHJvcHNbdGhpcy5pbmRleEFzXSA9IHRydWU7XG4gICAgICAgIGluc3RhbmNlUHJvcHNbdGhpcy5pdGVtc0luZGV4QXNdID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fX2N0b3IgPSBQb2x5bWVyLlRlbXBsYXRpemUudGVtcGxhdGl6ZSh0ZW1wbGF0ZSwgdGhpcywge1xuICAgICAgICAgIG11dGFibGVEYXRhOiB0aGlzLm11dGFibGVEYXRhLFxuICAgICAgICAgIHBhcmVudE1vZGVsOiB0cnVlLFxuICAgICAgICAgIGluc3RhbmNlUHJvcHM6IGluc3RhbmNlUHJvcHMsXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogQHRoaXMge3RoaXN9XG4gICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3AgUHJvcGVydHkgdG8gc2V0XG4gICAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byBzZXQgcHJvcGVydHkgdG9cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBmb3J3YXJkSG9zdFByb3A6IGZ1bmN0aW9uKHByb3AsIHZhbHVlKSB7XG4gICAgICAgICAgICBsZXQgaSQgPSB0aGlzLl9faW5zdGFuY2VzO1xuICAgICAgICAgICAgZm9yIChsZXQgaT0wLCBpbnN0OyAoaTxpJC5sZW5ndGgpICYmIChpbnN0PWkkW2ldKTsgaSsrKSB7XG4gICAgICAgICAgICAgIGluc3QuZm9yd2FyZEhvc3RQcm9wKHByb3AsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIEB0aGlzIHt0aGlzfVxuICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnN0IEluc3RhbmNlIHRvIG5vdGlmeVxuICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wIFByb3BlcnR5IHRvIG5vdGlmeVxuICAgICAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgdG8gbm90aWZ5XG4gICAgICAgICAgICovXG4gICAgICAgICAgbm90aWZ5SW5zdGFuY2VQcm9wOiBmdW5jdGlvbihpbnN0LCBwcm9wLCB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKFBvbHltZXIuUGF0aC5tYXRjaGVzKHRoaXMuYXMsIHByb3ApKSB7XG4gICAgICAgICAgICAgIGxldCBpZHggPSBpbnN0W3RoaXMuaXRlbXNJbmRleEFzXTtcbiAgICAgICAgICAgICAgaWYgKHByb3AgPT0gdGhpcy5hcykge1xuICAgICAgICAgICAgICAgIHRoaXMuaXRlbXNbaWR4XSA9IHZhbHVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGxldCBwYXRoID0gUG9seW1lci5QYXRoLnRyYW5zbGF0ZSh0aGlzLmFzLCAnaXRlbXMuJyArIGlkeCwgcHJvcCk7XG4gICAgICAgICAgICAgIHRoaXMubm90aWZ5UGF0aChwYXRoLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIF9fZ2V0TWV0aG9kSG9zdCgpIHtcbiAgICAgIC8vIFRlY2huaWNhbGx5IHRoaXMgc2hvdWxkIGJlIHRoZSBvd25lciBvZiB0aGUgb3V0ZXJtb3N0IHRlbXBsYXRlLlxuICAgICAgLy8gSW4gc2hhZG93IGRvbSwgdGhpcyBpcyBhbHdheXMgZ2V0Um9vdE5vZGUoKS5ob3N0LCBidXQgd2UgY2FuXG4gICAgICAvLyBhcHByb3hpbWF0ZSB0aGlzIHZpYSBjb29wZXJhdGlvbiB3aXRoIG91ciBkYXRhSG9zdCBhbHdheXMgc2V0dGluZ1xuICAgICAgLy8gYF9tZXRob2RIb3N0YCBhcyBsb25nIGFzIHRoZXJlIHdlcmUgYmluZGluZ3MgKG9yIGlkJ3MpIG9uIHRoaXNcbiAgICAgIC8vIGluc3RhbmNlIGNhdXNpbmcgaXQgdG8gZ2V0IGEgZGF0YUhvc3QuXG4gICAgICByZXR1cm4gdGhpcy5fX2RhdGFIb3N0Ll9tZXRob2RIb3N0IHx8IHRoaXMuX19kYXRhSG9zdDtcbiAgICB9XG5cbiAgICBfX3NvcnRDaGFuZ2VkKHNvcnQpIHtcbiAgICAgIGxldCBtZXRob2RIb3N0ID0gdGhpcy5fX2dldE1ldGhvZEhvc3QoKTtcbiAgICAgIHRoaXMuX19zb3J0Rm4gPSBzb3J0ICYmICh0eXBlb2Ygc29ydCA9PSAnZnVuY3Rpb24nID8gc29ydCA6XG4gICAgICAgIGZ1bmN0aW9uKCkgeyByZXR1cm4gbWV0aG9kSG9zdFtzb3J0XS5hcHBseShtZXRob2RIb3N0LCBhcmd1bWVudHMpOyB9KTtcbiAgICAgIGlmICh0aGlzLml0ZW1zKSB7XG4gICAgICAgIHRoaXMuX19kZWJvdW5jZVJlbmRlcih0aGlzLl9fcmVuZGVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfX2ZpbHRlckNoYW5nZWQoZmlsdGVyKSB7XG4gICAgICBsZXQgbWV0aG9kSG9zdCA9IHRoaXMuX19nZXRNZXRob2RIb3N0KCk7XG4gICAgICB0aGlzLl9fZmlsdGVyRm4gPSBmaWx0ZXIgJiYgKHR5cGVvZiBmaWx0ZXIgPT0gJ2Z1bmN0aW9uJyA/IGZpbHRlciA6XG4gICAgICAgIGZ1bmN0aW9uKCkgeyByZXR1cm4gbWV0aG9kSG9zdFtmaWx0ZXJdLmFwcGx5KG1ldGhvZEhvc3QsIGFyZ3VtZW50cyk7IH0pO1xuICAgICAgaWYgKHRoaXMuaXRlbXMpIHtcbiAgICAgICAgdGhpcy5fX2RlYm91bmNlUmVuZGVyKHRoaXMuX19yZW5kZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIF9fY29tcHV0ZUZyYW1lVGltZShyYXRlKSB7XG4gICAgICByZXR1cm4gTWF0aC5jZWlsKDEwMDAvcmF0ZSk7XG4gICAgfVxuXG4gICAgX19pbml0aWFsaXplQ2h1bmtpbmcoKSB7XG4gICAgICBpZiAodGhpcy5pbml0aWFsQ291bnQpIHtcbiAgICAgICAgdGhpcy5fX2xpbWl0ID0gdGhpcy5pbml0aWFsQ291bnQ7XG4gICAgICAgIHRoaXMuX19jaHVua0NvdW50ID0gdGhpcy5pbml0aWFsQ291bnQ7XG4gICAgICAgIHRoaXMuX19sYXN0Q2h1bmtUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgX190cnlSZW5kZXJDaHVuaygpIHtcbiAgICAgIC8vIERlYm91bmNlZCBzbyB0aGF0IG11bHRpcGxlIGNhbGxzIHRocm91Z2ggYF9yZW5kZXJgIGJldHdlZW4gYW5pbWF0aW9uXG4gICAgICAvLyBmcmFtZXMgb25seSBxdWV1ZSBvbmUgbmV3IHJBRiAoZS5nLiBhcnJheSBtdXRhdGlvbiAmIGNodW5rZWQgcmVuZGVyKVxuICAgICAgaWYgKHRoaXMuaXRlbXMgJiYgdGhpcy5fX2xpbWl0IDwgdGhpcy5pdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5fX2RlYm91bmNlUmVuZGVyKHRoaXMuX19yZXF1ZXN0UmVuZGVyQ2h1bmspO1xuICAgICAgfVxuICAgIH1cblxuICAgIF9fcmVxdWVzdFJlbmRlckNodW5rKCkge1xuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpPT50aGlzLl9fcmVuZGVyQ2h1bmsoKSk7XG4gICAgfVxuXG4gICAgX19yZW5kZXJDaHVuaygpIHtcbiAgICAgIC8vIFNpbXBsZSBhdXRvIGNodW5rU2l6ZSB0aHJvdHRsaW5nIGFsZ29yaXRobSBiYXNlZCBvbiBmZWVkYmFjayBsb29wOlxuICAgICAgLy8gbWVhc3VyZSBhY3R1YWwgdGltZSBiZXR3ZWVuIGZyYW1lcyBhbmQgc2NhbGUgY2h1bmsgY291bnQgYnkgcmF0aW9cbiAgICAgIC8vIG9mIHRhcmdldC9hY3R1YWwgZnJhbWUgdGltZVxuICAgICAgbGV0IGN1cnJDaHVua1RpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIGxldCByYXRpbyA9IHRoaXMuX3RhcmdldEZyYW1lVGltZSAvIChjdXJyQ2h1bmtUaW1lIC0gdGhpcy5fX2xhc3RDaHVua1RpbWUpO1xuICAgICAgdGhpcy5fX2NodW5rQ291bnQgPSBNYXRoLnJvdW5kKHRoaXMuX19jaHVua0NvdW50ICogcmF0aW8pIHx8IDE7XG4gICAgICB0aGlzLl9fbGltaXQgKz0gdGhpcy5fX2NodW5rQ291bnQ7XG4gICAgICB0aGlzLl9fbGFzdENodW5rVGltZSA9IGN1cnJDaHVua1RpbWU7XG4gICAgICB0aGlzLl9fZGVib3VuY2VSZW5kZXIodGhpcy5fX3JlbmRlcik7XG4gICAgfVxuXG4gICAgX19vYnNlcnZlQ2hhbmdlZCgpIHtcbiAgICAgIHRoaXMuX19vYnNlcnZlUGF0aHMgPSB0aGlzLm9ic2VydmUgJiZcbiAgICAgICAgdGhpcy5vYnNlcnZlLnJlcGxhY2UoJy4qJywgJy4nKS5zcGxpdCgnICcpO1xuICAgIH1cblxuICAgIF9faXRlbXNDaGFuZ2VkKGNoYW5nZSkge1xuICAgICAgaWYgKHRoaXMuaXRlbXMgJiYgIUFycmF5LmlzQXJyYXkodGhpcy5pdGVtcykpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdkb20tcmVwZWF0IGV4cGVjdGVkIGFycmF5IGZvciBgaXRlbXNgLCBmb3VuZCcsIHRoaXMuaXRlbXMpO1xuICAgICAgfVxuICAgICAgLy8gSWYgcGF0aCB3YXMgdG8gYW4gaXRlbSAoZS5nLiAnaXRlbXMuMycgb3IgJ2l0ZW1zLjMuZm9vJyksIGZvcndhcmQgdGhlXG4gICAgICAvLyBwYXRoIHRvIHRoYXQgaW5zdGFuY2Ugc3luY2hyb25vdXNseSAocmV0dW5zIGZhbHNlIGZvciBub24taXRlbSBwYXRocylcbiAgICAgIGlmICghdGhpcy5fX2hhbmRsZUl0ZW1QYXRoKGNoYW5nZS5wYXRoLCBjaGFuZ2UudmFsdWUpKSB7XG4gICAgICAgIC8vIE90aGVyd2lzZSwgdGhlIGFycmF5IHdhcyByZXNldCAoJ2l0ZW1zJykgb3Igc3BsaWNlZCAoJ2l0ZW1zLnNwbGljZXMnKSxcbiAgICAgICAgLy8gc28gcXVldWUgYSBmdWxsIHJlZnJlc2hcbiAgICAgICAgdGhpcy5fX2luaXRpYWxpemVDaHVua2luZygpO1xuICAgICAgICB0aGlzLl9fZGVib3VuY2VSZW5kZXIodGhpcy5fX3JlbmRlcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgX19oYW5kbGVPYnNlcnZlZFBhdGhzKHBhdGgpIHtcbiAgICAgIGlmICh0aGlzLl9fb2JzZXJ2ZVBhdGhzKSB7XG4gICAgICAgIHBhdGggPSBwYXRoLnN1YnN0cmluZyhwYXRoLmluZGV4T2YoJy4nKSArIDEpO1xuICAgICAgICBsZXQgcGF0aHMgPSB0aGlzLl9fb2JzZXJ2ZVBhdGhzO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8cGF0aHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAocGF0aC5pbmRleE9mKHBhdGhzW2ldKSA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5fX2RlYm91bmNlUmVuZGVyKHRoaXMuX19yZW5kZXIsIHRoaXMuZGVsYXkpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbih0aGlzOkRvbVJlcGVhdCl9IGZuIEZ1bmN0aW9uIHRvIGRlYm91bmNlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gZGVsYXkgRGVsYXkgaW4gbXMgdG8gZGVib3VuY2UgYnkuXG4gICAgICovXG4gICAgX19kZWJvdW5jZVJlbmRlcihmbiwgZGVsYXkgPSAwKSB7XG4gICAgICB0aGlzLl9fcmVuZGVyRGVib3VuY2VyID0gUG9seW1lci5EZWJvdW5jZXIuZGVib3VuY2UoXG4gICAgICAgICAgICB0aGlzLl9fcmVuZGVyRGVib3VuY2VyXG4gICAgICAgICAgLCBkZWxheSA+IDAgPyBQb2x5bWVyLkFzeW5jLnRpbWVPdXQuYWZ0ZXIoZGVsYXkpIDogUG9seW1lci5Bc3luYy5taWNyb1Rhc2tcbiAgICAgICAgICAsIGZuLmJpbmQodGhpcykpO1xuICAgICAgUG9seW1lci5lbnF1ZXVlRGVib3VuY2VyKHRoaXMuX19yZW5kZXJEZWJvdW5jZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZvcmNlcyB0aGUgZWxlbWVudCB0byByZW5kZXIgaXRzIGNvbnRlbnQuIE5vcm1hbGx5IHJlbmRlcmluZyBpc1xuICAgICAqIGFzeW5jaHJvbm91cyB0byBhIHByb3Zva2luZyBjaGFuZ2UuIFRoaXMgaXMgZG9uZSBmb3IgZWZmaWNpZW5jeSBzb1xuICAgICAqIHRoYXQgbXVsdGlwbGUgY2hhbmdlcyB0cmlnZ2VyIG9ubHkgYSBzaW5nbGUgcmVuZGVyLiBUaGUgcmVuZGVyIG1ldGhvZFxuICAgICAqIHNob3VsZCBiZSBjYWxsZWQgaWYsIGZvciBleGFtcGxlLCB0ZW1wbGF0ZSByZW5kZXJpbmcgaXMgcmVxdWlyZWQgdG9cbiAgICAgKiB2YWxpZGF0ZSBhcHBsaWNhdGlvbiBzdGF0ZS5cbiAgICAgKi9cbiAgICByZW5kZXIoKSB7XG4gICAgICAvLyBRdWV1ZSB0aGlzIHJlcGVhdGVyLCB0aGVuIGZsdXNoIGFsbCBpbiBvcmRlclxuICAgICAgdGhpcy5fX2RlYm91bmNlUmVuZGVyKHRoaXMuX19yZW5kZXIpO1xuICAgICAgUG9seW1lci5mbHVzaCgpO1xuICAgIH1cblxuICAgIF9fcmVuZGVyKCkge1xuICAgICAgaWYgKCF0aGlzLl9fZW5zdXJlVGVtcGxhdGl6ZWQoKSkge1xuICAgICAgICAvLyBObyB0ZW1wbGF0ZSBmb3VuZCB5ZXRcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5fX2FwcGx5RnVsbFJlZnJlc2goKTtcbiAgICAgIC8vIFJlc2V0IHRoZSBwb29sXG4gICAgICAvLyBUT0RPKGtzY2hhYWYpOiBSZXVzZSBwb29sIGFjcm9zcyB0dXJucyBhbmQgbmVzdGVkIHRlbXBsYXRlc1xuICAgICAgLy8gTm93IHRoYXQgb2JqZWN0cy9hcnJheXMgYXJlIHJlLWV2YWx1YXRlZCB3aGVuIHNldCwgd2UgY2FuIHNhZmVseVxuICAgICAgLy8gcmV1c2UgcG9vbGVkIGluc3RhbmNlcyBhY3Jvc3MgdHVybnMsIGhvd2V2ZXIgd2Ugc3RpbGwgbmVlZCB0byBkZWNpZGVcbiAgICAgIC8vIHNlbWFudGljcyByZWdhcmRpbmcgaG93IGxvbmcgdG8gaG9sZCwgaG93IG1hbnkgdG8gaG9sZCwgZXRjLlxuICAgICAgdGhpcy5fX3Bvb2wubGVuZ3RoID0gMDtcbiAgICAgIC8vIFNldCByZW5kZXJlZCBpdGVtIGNvdW50XG4gICAgICB0aGlzLl9zZXRSZW5kZXJlZEl0ZW1Db3VudCh0aGlzLl9faW5zdGFuY2VzLmxlbmd0aCk7XG4gICAgICAvLyBOb3RpZnkgdXNlcnNcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ2RvbS1jaGFuZ2UnLCB7XG4gICAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICAgIGNvbXBvc2VkOiB0cnVlXG4gICAgICB9KSk7XG4gICAgICAvLyBDaGVjayB0byBzZWUgaWYgd2UgbmVlZCB0byByZW5kZXIgbW9yZSBpdGVtc1xuICAgICAgdGhpcy5fX3RyeVJlbmRlckNodW5rKCk7XG4gICAgfVxuXG4gICAgX19hcHBseUZ1bGxSZWZyZXNoKCkge1xuICAgICAgbGV0IGl0ZW1zID0gdGhpcy5pdGVtcyB8fCBbXTtcbiAgICAgIGxldCBpc250SWR4VG9JdGVtc0lkeCA9IG5ldyBBcnJheShpdGVtcy5sZW5ndGgpO1xuICAgICAgZm9yIChsZXQgaT0wOyBpPGl0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlzbnRJZHhUb0l0ZW1zSWR4W2ldID0gaTtcbiAgICAgIH1cbiAgICAgIC8vIEFwcGx5IHVzZXIgZmlsdGVyXG4gICAgICBpZiAodGhpcy5fX2ZpbHRlckZuKSB7XG4gICAgICAgIGlzbnRJZHhUb0l0ZW1zSWR4ID0gaXNudElkeFRvSXRlbXNJZHguZmlsdGVyKChpLCBpZHgsIGFycmF5KSA9PlxuICAgICAgICAgIHRoaXMuX19maWx0ZXJGbihpdGVtc1tpXSwgaWR4LCBhcnJheSkpO1xuICAgICAgfVxuICAgICAgLy8gQXBwbHkgdXNlciBzb3J0XG4gICAgICBpZiAodGhpcy5fX3NvcnRGbikge1xuICAgICAgICBpc250SWR4VG9JdGVtc0lkeC5zb3J0KChhLCBiKSA9PiB0aGlzLl9fc29ydEZuKGl0ZW1zW2FdLCBpdGVtc1tiXSkpO1xuICAgICAgfVxuICAgICAgLy8gaXRlbXMtPmluc3QgbWFwIGtlcHQgZm9yIGl0ZW0gcGF0aCBmb3J3YXJkaW5nXG4gICAgICBjb25zdCBpdGVtc0lkeFRvSW5zdElkeCA9IHRoaXMuX19pdGVtc0lkeFRvSW5zdElkeCA9IHt9O1xuICAgICAgbGV0IGluc3RJZHggPSAwO1xuICAgICAgLy8gR2VuZXJhdGUgaW5zdGFuY2VzIGFuZCBhc3NpZ24gaXRlbXNcbiAgICAgIGNvbnN0IGxpbWl0ID0gTWF0aC5taW4oaXNudElkeFRvSXRlbXNJZHgubGVuZ3RoLCB0aGlzLl9fbGltaXQpO1xuICAgICAgZm9yICg7IGluc3RJZHg8bGltaXQ7IGluc3RJZHgrKykge1xuICAgICAgICBsZXQgaW5zdCA9IHRoaXMuX19pbnN0YW5jZXNbaW5zdElkeF07XG4gICAgICAgIGxldCBpdGVtSWR4ID0gaXNudElkeFRvSXRlbXNJZHhbaW5zdElkeF07XG4gICAgICAgIGxldCBpdGVtID0gaXRlbXNbaXRlbUlkeF07XG4gICAgICAgIGl0ZW1zSWR4VG9JbnN0SWR4W2l0ZW1JZHhdID0gaW5zdElkeDtcbiAgICAgICAgaWYgKGluc3QgJiYgaW5zdElkeCA8IHRoaXMuX19saW1pdCkge1xuICAgICAgICAgIGluc3QuX3NldFBlbmRpbmdQcm9wZXJ0eSh0aGlzLmFzLCBpdGVtKTtcbiAgICAgICAgICBpbnN0Ll9zZXRQZW5kaW5nUHJvcGVydHkodGhpcy5pbmRleEFzLCBpbnN0SWR4KTtcbiAgICAgICAgICBpbnN0Ll9zZXRQZW5kaW5nUHJvcGVydHkodGhpcy5pdGVtc0luZGV4QXMsIGl0ZW1JZHgpO1xuICAgICAgICAgIGluc3QuX2ZsdXNoUHJvcGVydGllcygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX19pbnNlcnRJbnN0YW5jZShpdGVtLCBpbnN0SWR4LCBpdGVtSWR4KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gUmVtb3ZlIGFueSBleHRyYSBpbnN0YW5jZXMgZnJvbSBwcmV2aW91cyBzdGF0ZVxuICAgICAgZm9yIChsZXQgaT10aGlzLl9faW5zdGFuY2VzLmxlbmd0aC0xOyBpPj1pbnN0SWR4OyBpLS0pIHtcbiAgICAgICAgdGhpcy5fX2RldGFjaEFuZFJlbW92ZUluc3RhbmNlKGkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIF9fZGV0YWNoSW5zdGFuY2UoaWR4KSB7XG4gICAgICBsZXQgaW5zdCA9IHRoaXMuX19pbnN0YW5jZXNbaWR4XTtcbiAgICAgIGZvciAobGV0IGk9MDsgaTxpbnN0LmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBlbCA9IGluc3QuY2hpbGRyZW5baV07XG4gICAgICAgIGluc3Qucm9vdC5hcHBlbmRDaGlsZChlbCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaW5zdDtcbiAgICB9XG5cbiAgICBfX2F0dGFjaEluc3RhbmNlKGlkeCwgcGFyZW50KSB7XG4gICAgICBsZXQgaW5zdCA9IHRoaXMuX19pbnN0YW5jZXNbaWR4XTtcbiAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUoaW5zdC5yb290LCB0aGlzKTtcbiAgICB9XG5cbiAgICBfX2RldGFjaEFuZFJlbW92ZUluc3RhbmNlKGlkeCkge1xuICAgICAgbGV0IGluc3QgPSB0aGlzLl9fZGV0YWNoSW5zdGFuY2UoaWR4KTtcbiAgICAgIGlmIChpbnN0KSB7XG4gICAgICAgIHRoaXMuX19wb29sLnB1c2goaW5zdCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9faW5zdGFuY2VzLnNwbGljZShpZHgsIDEpO1xuICAgIH1cblxuICAgIF9fc3RhbXBJbnN0YW5jZShpdGVtLCBpbnN0SWR4LCBpdGVtSWR4KSB7XG4gICAgICBsZXQgbW9kZWwgPSB7fTtcbiAgICAgIG1vZGVsW3RoaXMuYXNdID0gaXRlbTtcbiAgICAgIG1vZGVsW3RoaXMuaW5kZXhBc10gPSBpbnN0SWR4O1xuICAgICAgbW9kZWxbdGhpcy5pdGVtc0luZGV4QXNdID0gaXRlbUlkeDtcbiAgICAgIHJldHVybiBuZXcgdGhpcy5fX2N0b3IobW9kZWwpO1xuICAgIH1cblxuICAgIF9faW5zZXJ0SW5zdGFuY2UoaXRlbSwgaW5zdElkeCwgaXRlbUlkeCkge1xuICAgICAgbGV0IGluc3QgPSB0aGlzLl9fcG9vbC5wb3AoKTtcbiAgICAgIGlmIChpbnN0KSB7XG4gICAgICAgIC8vIFRPRE8oa3NjaGFhZik6IElmIHRoZSBwb29sIGlzIHNoYXJlZCBhY3Jvc3MgdHVybnMsIGhvc3RQcm9wc1xuICAgICAgICAvLyBuZWVkIHRvIGJlIHJlLXNldCB0byByZXVzZWQgaW5zdGFuY2VzIGluIGFkZGl0aW9uIHRvIGl0ZW1cbiAgICAgICAgaW5zdC5fc2V0UGVuZGluZ1Byb3BlcnR5KHRoaXMuYXMsIGl0ZW0pO1xuICAgICAgICBpbnN0Ll9zZXRQZW5kaW5nUHJvcGVydHkodGhpcy5pbmRleEFzLCBpbnN0SWR4KTtcbiAgICAgICAgaW5zdC5fc2V0UGVuZGluZ1Byb3BlcnR5KHRoaXMuaXRlbXNJbmRleEFzLCBpdGVtSWR4KTtcbiAgICAgICAgaW5zdC5fZmx1c2hQcm9wZXJ0aWVzKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnN0ID0gdGhpcy5fX3N0YW1wSW5zdGFuY2UoaXRlbSwgaW5zdElkeCwgaXRlbUlkeCk7XG4gICAgICB9XG4gICAgICBsZXQgYmVmb3JlUm93ID0gdGhpcy5fX2luc3RhbmNlc1tpbnN0SWR4ICsgMV07XG4gICAgICBsZXQgYmVmb3JlTm9kZSA9IGJlZm9yZVJvdyA/IGJlZm9yZVJvdy5jaGlsZHJlblswXSA6IHRoaXM7XG4gICAgICB0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGluc3Qucm9vdCwgYmVmb3JlTm9kZSk7XG4gICAgICB0aGlzLl9faW5zdGFuY2VzW2luc3RJZHhdID0gaW5zdDtcbiAgICAgIHJldHVybiBpbnN0O1xuICAgIH1cblxuICAgIC8vIEltcGxlbWVudHMgZXh0ZW5zaW9uIHBvaW50IGZyb20gVGVtcGxhdGl6ZSBtaXhpblxuICAgIF9zaG93SGlkZUNoaWxkcmVuKGhpZGRlbikge1xuICAgICAgZm9yIChsZXQgaT0wOyBpPHRoaXMuX19pbnN0YW5jZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5fX2luc3RhbmNlc1tpXS5fc2hvd0hpZGVDaGlsZHJlbihoaWRkZW4pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENhbGxlZCBhcyBhIHNpZGUgZWZmZWN0IG9mIGEgaG9zdCBpdGVtcy48a2V5Pi48cGF0aD4gcGF0aCBjaGFuZ2UsXG4gICAgLy8gcmVzcG9uc2libGUgZm9yIG5vdGlmeWluZyBpdGVtLjxwYXRoPiBjaGFuZ2VzIHRvIGluc3QgZm9yIGtleVxuICAgIF9faGFuZGxlSXRlbVBhdGgocGF0aCwgdmFsdWUpIHtcbiAgICAgIGxldCBpdGVtc1BhdGggPSBwYXRoLnNsaWNlKDYpOyAvLyAnaXRlbXMuJy5sZW5ndGggPT0gNlxuICAgICAgbGV0IGRvdCA9IGl0ZW1zUGF0aC5pbmRleE9mKCcuJyk7XG4gICAgICBsZXQgaXRlbXNJZHggPSBkb3QgPCAwID8gaXRlbXNQYXRoIDogaXRlbXNQYXRoLnN1YnN0cmluZygwLCBkb3QpO1xuICAgICAgLy8gSWYgcGF0aCB3YXMgaW5kZXggaW50byBhcnJheS4uLlxuICAgICAgaWYgKGl0ZW1zSWR4ID09IHBhcnNlSW50KGl0ZW1zSWR4LCAxMCkpIHtcbiAgICAgICAgbGV0IGl0ZW1TdWJQYXRoID0gZG90IDwgMCA/ICcnIDogaXRlbXNQYXRoLnN1YnN0cmluZyhkb3QrMSk7XG4gICAgICAgIC8vIElmIHRoZSBwYXRoIGlzIG9ic2VydmVkLCBpdCB3aWxsIHRyaWdnZXIgYSBmdWxsIHJlZnJlc2hcbiAgICAgICAgdGhpcy5fX2hhbmRsZU9ic2VydmVkUGF0aHMoaXRlbVN1YlBhdGgpO1xuICAgICAgICAvLyBOb3RlLCBldmVuIGlmIGEgcnVsbCByZWZyZXNoIGlzIHRyaWdnZXJlZCwgYWx3YXlzIGRvIHRoZSBwYXRoXG4gICAgICAgIC8vIG5vdGlmaWNhdGlvbiBiZWNhdXNlIHVubGVzcyBtdXRhYmxlRGF0YSBpcyB1c2VkIGZvciBkb20tcmVwZWF0XG4gICAgICAgIC8vIGFuZCBhbGwgZWxlbWVudHMgaW4gdGhlIGluc3RhbmNlIHN1YnRyZWUsIGEgZnVsbCByZWZyZXNoIG1heVxuICAgICAgICAvLyBub3QgdHJpZ2dlciB0aGUgcHJvcGVyIHVwZGF0ZS5cbiAgICAgICAgbGV0IGluc3RJZHggPSB0aGlzLl9faXRlbXNJZHhUb0luc3RJZHhbaXRlbXNJZHhdO1xuICAgICAgICBsZXQgaW5zdCA9IHRoaXMuX19pbnN0YW5jZXNbaW5zdElkeF07XG4gICAgICAgIGlmIChpbnN0KSB7XG4gICAgICAgICAgbGV0IGl0ZW1QYXRoID0gdGhpcy5hcyArIChpdGVtU3ViUGF0aCA/ICcuJyArIGl0ZW1TdWJQYXRoIDogJycpO1xuICAgICAgICAgIC8vIFRoaXMgaXMgZWZmZWN0aXZlbHkgYG5vdGlmeVBhdGhgLCBidXQgYXZvaWRzIHNvbWUgb2YgdGhlIG92ZXJoZWFkXG4gICAgICAgICAgLy8gb2YgdGhlIHB1YmxpYyBBUElcbiAgICAgICAgICBpbnN0Ll9zZXRQZW5kaW5nUHJvcGVydHlPclBhdGgoaXRlbVBhdGgsIHZhbHVlLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgICAgaW5zdC5fZmx1c2hQcm9wZXJ0aWVzKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgaXRlbSBhc3NvY2lhdGVkIHdpdGggYSBnaXZlbiBlbGVtZW50IHN0YW1wZWQgYnlcbiAgICAgKiB0aGlzIGBkb20tcmVwZWF0YC5cbiAgICAgKlxuICAgICAqIE5vdGUsIHRvIG1vZGlmeSBzdWItcHJvcGVydGllcyBvZiB0aGUgaXRlbSxcbiAgICAgKiBgbW9kZWxGb3JFbGVtZW50KGVsKS5zZXQoJ2l0ZW0uPHN1Yi1wcm9wPicsIHZhbHVlKWBcbiAgICAgKiBzaG91bGQgYmUgdXNlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIEVsZW1lbnQgZm9yIHdoaWNoIHRvIHJldHVybiB0aGUgaXRlbS5cbiAgICAgKiBAcmV0dXJuIHsqfSBJdGVtIGFzc29jaWF0ZWQgd2l0aCB0aGUgZWxlbWVudC5cbiAgICAgKi9cbiAgICBpdGVtRm9yRWxlbWVudChlbCkge1xuICAgICAgbGV0IGluc3RhbmNlID0gdGhpcy5tb2RlbEZvckVsZW1lbnQoZWwpO1xuICAgICAgcmV0dXJuIGluc3RhbmNlICYmIGluc3RhbmNlW3RoaXMuYXNdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGluc3QgaW5kZXggZm9yIGEgZ2l2ZW4gZWxlbWVudCBzdGFtcGVkIGJ5IHRoaXMgYGRvbS1yZXBlYXRgLlxuICAgICAqIElmIGBzb3J0YCBpcyBwcm92aWRlZCwgdGhlIGluZGV4IHdpbGwgcmVmbGVjdCB0aGUgc29ydGVkIG9yZGVyIChyYXRoZXJcbiAgICAgKiB0aGFuIHRoZSBvcmlnaW5hbCBhcnJheSBvcmRlcikuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCBFbGVtZW50IGZvciB3aGljaCB0byByZXR1cm4gdGhlIGluZGV4LlxuICAgICAqIEByZXR1cm4geyp9IFJvdyBpbmRleCBhc3NvY2lhdGVkIHdpdGggdGhlIGVsZW1lbnQgKG5vdGUgdGhpcyBtYXlcbiAgICAgKiAgIG5vdCBjb3JyZXNwb25kIHRvIHRoZSBhcnJheSBpbmRleCBpZiBhIHVzZXIgYHNvcnRgIGlzIGFwcGxpZWQpLlxuICAgICAqL1xuICAgIGluZGV4Rm9yRWxlbWVudChlbCkge1xuICAgICAgbGV0IGluc3RhbmNlID0gdGhpcy5tb2RlbEZvckVsZW1lbnQoZWwpO1xuICAgICAgcmV0dXJuIGluc3RhbmNlICYmIGluc3RhbmNlW3RoaXMuaW5kZXhBc107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdGVtcGxhdGUgXCJtb2RlbFwiIGFzc29jaWF0ZWQgd2l0aCBhIGdpdmVuIGVsZW1lbnQsIHdoaWNoXG4gICAgICogc2VydmVzIGFzIHRoZSBiaW5kaW5nIHNjb3BlIGZvciB0aGUgdGVtcGxhdGUgaW5zdGFuY2UgdGhlIGVsZW1lbnQgaXNcbiAgICAgKiBjb250YWluZWQgaW4uIEEgdGVtcGxhdGUgbW9kZWwgaXMgYW4gaW5zdGFuY2Ugb2YgYFBvbHltZXIuQmFzZWAsIGFuZFxuICAgICAqIHNob3VsZCBiZSB1c2VkIHRvIG1hbmlwdWxhdGUgZGF0YSBhc3NvY2lhdGVkIHdpdGggdGhpcyB0ZW1wbGF0ZSBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEV4YW1wbGU6XG4gICAgICpcbiAgICAgKiAgIGxldCBtb2RlbCA9IG1vZGVsRm9yRWxlbWVudChlbCk7XG4gICAgICogICBpZiAobW9kZWwuaW5kZXggPCAxMCkge1xuICAgICAqICAgICBtb2RlbC5zZXQoJ2l0ZW0uY2hlY2tlZCcsIHRydWUpO1xuICAgICAqICAgfVxuICAgICAqXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgRWxlbWVudCBmb3Igd2hpY2ggdG8gcmV0dXJuIGEgdGVtcGxhdGUgbW9kZWwuXG4gICAgICogQHJldHVybiB7VGVtcGxhdGVJbnN0YW5jZUJhc2V9IE1vZGVsIHJlcHJlc2VudGluZyB0aGUgYmluZGluZyBzY29wZSBmb3JcbiAgICAgKiAgIHRoZSBlbGVtZW50LlxuICAgICAqL1xuICAgIG1vZGVsRm9yRWxlbWVudChlbCkge1xuICAgICAgcmV0dXJuIFBvbHltZXIuVGVtcGxhdGl6ZS5tb2RlbEZvckVsZW1lbnQodGhpcy50ZW1wbGF0ZSwgZWwpO1xuICAgIH1cblxuICB9XG5cbiAgY3VzdG9tRWxlbWVudHMuZGVmaW5lKERvbVJlcGVhdC5pcywgRG9tUmVwZWF0KTtcblxuICBQb2x5bWVyLkRvbVJlcGVhdCA9IERvbVJlcGVhdDtcblxufSkoKTtcblxuPC9zY3JpcHQ+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL3BvbHltZXIvbGliL2VsZW1lbnRzL2RvbS1yZXBlYXQuaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cblxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uLy4uL3BvbHltZXItZWxlbWVudC5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vdXRpbHMvdGVtcGxhdGl6ZS5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vdXRpbHMvZGVib3VuY2UuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3V0aWxzL2ZsdXNoLmh0bWxcIj5cblxuPHNjcmlwdD5cblxuKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLyoqXG4gICAqIFRoZSBgPGRvbS1pZj5gIGVsZW1lbnQgd2lsbCBzdGFtcCBhIGxpZ2h0LWRvbSBgPHRlbXBsYXRlPmAgY2hpbGQgd2hlblxuICAgKiB0aGUgYGlmYCBwcm9wZXJ0eSBiZWNvbWVzIHRydXRoeSwgYW5kIHRoZSB0ZW1wbGF0ZSBjYW4gdXNlIFBvbHltZXJcbiAgICogZGF0YS1iaW5kaW5nIGFuZCBkZWNsYXJhdGl2ZSBldmVudCBmZWF0dXJlcyB3aGVuIHVzZWQgaW4gdGhlIGNvbnRleHQgb2ZcbiAgICogYSBQb2x5bWVyIGVsZW1lbnQncyB0ZW1wbGF0ZS5cbiAgICpcbiAgICogV2hlbiBgaWZgIGJlY29tZXMgZmFsc2V5LCB0aGUgc3RhbXBlZCBjb250ZW50IGlzIGhpZGRlbiBidXQgbm90XG4gICAqIHJlbW92ZWQgZnJvbSBkb20uIFdoZW4gYGlmYCBzdWJzZXF1ZW50bHkgYmVjb21lcyB0cnV0aHkgYWdhaW4sIHRoZSBjb250ZW50XG4gICAqIGlzIHNpbXBseSByZS1zaG93bi4gVGhpcyBhcHByb2FjaCBpcyB1c2VkIGR1ZSB0byBpdHMgZmF2b3JhYmxlIHBlcmZvcm1hbmNlXG4gICAqIGNoYXJhY3RlcmlzdGljczogdGhlIGV4cGVuc2Ugb2YgY3JlYXRpbmcgdGVtcGxhdGUgY29udGVudCBpcyBwYWlkIG9ubHlcbiAgICogb25jZSBhbmQgbGF6aWx5LlxuICAgKlxuICAgKiBTZXQgdGhlIGByZXN0YW1wYCBwcm9wZXJ0eSB0byB0cnVlIHRvIGZvcmNlIHRoZSBzdGFtcGVkIGNvbnRlbnQgdG8gYmVcbiAgICogY3JlYXRlZCAvIGRlc3Ryb3llZCB3aGVuIHRoZSBgaWZgIGNvbmRpdGlvbiBjaGFuZ2VzLlxuICAgKlxuICAgKiBAY3VzdG9tRWxlbWVudFxuICAgKiBAcG9seW1lclxuICAgKiBAZXh0ZW5kcyBQb2x5bWVyLkVsZW1lbnRcbiAgICogQG1lbWJlcm9mIFBvbHltZXJcbiAgICogQHN1bW1hcnkgQ3VzdG9tIGVsZW1lbnQgdGhhdCBjb25kaXRpb25hbGx5IHN0YW1wcyBhbmQgaGlkZXMgb3IgcmVtb3Zlc1xuICAgKiAgIHRlbXBsYXRlIGNvbnRlbnQgYmFzZWQgb24gYSBib29sZWFuIGZsYWcuXG4gICAqL1xuICBjbGFzcyBEb21JZiBleHRlbmRzIFBvbHltZXIuRWxlbWVudCB7XG5cbiAgICAvLyBOb3QgbmVlZGVkIHRvIGZpbmQgdGVtcGxhdGU7IGNhbiBiZSByZW1vdmVkIG9uY2UgdGhlIGFuYWx5emVyXG4gICAgLy8gY2FuIGZpbmQgdGhlIHRhZyBuYW1lIGZyb20gY3VzdG9tRWxlbWVudHMuZGVmaW5lIGNhbGxcbiAgICBzdGF0aWMgZ2V0IGlzKCkgeyByZXR1cm4gJ2RvbS1pZic7IH1cblxuICAgIHN0YXRpYyBnZXQgdGVtcGxhdGUoKSB7IHJldHVybiBudWxsOyB9XG5cbiAgICBzdGF0aWMgZ2V0IHByb3BlcnRpZXMoKSB7XG5cbiAgICAgIHJldHVybiB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVkIHdoZW5ldmVyIERPTSBpcyBhZGRlZCBvciByZW1vdmVkL2hpZGRlbiBieSB0aGlzIHRlbXBsYXRlIChieVxuICAgICAgICAgKiBkZWZhdWx0LCByZW5kZXJpbmcgb2NjdXJzIGxhemlseSkuICBUbyBmb3JjZSBpbW1lZGlhdGUgcmVuZGVyaW5nLCBjYWxsXG4gICAgICAgICAqIGByZW5kZXJgLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXZlbnQgZG9tLWNoYW5nZVxuICAgICAgICAgKi9cblxuICAgICAgICAvKipcbiAgICAgICAgICogQSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGlzIHRlbXBsYXRlIHNob3VsZCBzdGFtcC5cbiAgICAgICAgICovXG4gICAgICAgIGlmOiB7XG4gICAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgICBvYnNlcnZlcjogJ19fZGVib3VuY2VSZW5kZXInXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZW4gdHJ1ZSwgZWxlbWVudHMgd2lsbCBiZSByZW1vdmVkIGZyb20gRE9NIGFuZCBkaXNjYXJkZWQgd2hlbiBgaWZgXG4gICAgICAgICAqIGJlY29tZXMgZmFsc2UgYW5kIHJlLWNyZWF0ZWQgYW5kIGFkZGVkIGJhY2sgdG8gdGhlIERPTSB3aGVuIGBpZmBcbiAgICAgICAgICogYmVjb21lcyB0cnVlLiAgQnkgZGVmYXVsdCwgc3RhbXBlZCBlbGVtZW50cyB3aWxsIGJlIGhpZGRlbiBidXQgbGVmdFxuICAgICAgICAgKiBpbiB0aGUgRE9NIHdoZW4gYGlmYCBiZWNvbWVzIGZhbHNlLCB3aGljaCBpcyBnZW5lcmFsbHkgcmVzdWx0c1xuICAgICAgICAgKiBpbiBiZXR0ZXIgcGVyZm9ybWFuY2UuXG4gICAgICAgICAqL1xuICAgICAgICByZXN0YW1wOiB7XG4gICAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgICBvYnNlcnZlcjogJ19fZGVib3VuY2VSZW5kZXInXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgfVxuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICBzdXBlcigpO1xuICAgICAgdGhpcy5fX3JlbmRlckRlYm91bmNlciA9IG51bGw7XG4gICAgICB0aGlzLl9faW52YWxpZFByb3BzID0gbnVsbDtcbiAgICAgIHRoaXMuX19pbnN0YW5jZSA9IG51bGw7XG4gICAgICB0aGlzLl9sYXN0SWYgPSBmYWxzZTtcbiAgICAgIHRoaXMuX19jdG9yID0gbnVsbDtcbiAgICB9XG5cbiAgICBfX2RlYm91bmNlUmVuZGVyKCkge1xuICAgICAgLy8gUmVuZGVyIGlzIGFzeW5jIGZvciAyIHJlYXNvbnM6XG4gICAgICAvLyAxLiBUbyBlbGltaW5hdGUgZG9tIGNyZWF0aW9uIHRyYXNoaW5nIGlmIHVzZXIgY29kZSB0aHJhc2hlcyBgaWZgIGluIHRoZVxuICAgICAgLy8gICAgc2FtZSB0dXJuLiBUaGlzIHdhcyBtb3JlIGNvbW1vbiBpbiAxLnggd2hlcmUgYSBjb21wb3VuZCBjb21wdXRlZFxuICAgICAgLy8gICAgcHJvcGVydHkgY291bGQgcmVzdWx0IGluIHRoZSByZXN1bHQgY2hhbmdpbmcgbXVsdGlwbGUgdGltZXMsIGJ1dCBpc1xuICAgICAgLy8gICAgbWl0aWdhdGVkIHRvIGEgbGFyZ2UgZXh0ZW50IGJ5IGJhdGNoZWQgcHJvcGVydHkgcHJvY2Vzc2luZyBpbiAyLnguXG4gICAgICAvLyAyLiBUbyBhdm9pZCBkb3VibGUgb2JqZWN0IHByb3BhZ2F0aW9uIHdoZW4gYSBiYWcgaW5jbHVkaW5nIHZhbHVlcyBib3VuZFxuICAgICAgLy8gICAgdG8gdGhlIGBpZmAgcHJvcGVydHkgYXMgd2VsbCBhcyBvbmUgb3IgbW9yZSBob3N0UHJvcHMgY291bGQgZW5xdWV1ZVxuICAgICAgLy8gICAgdGhlIDxkb20taWY+IHRvIGZsdXNoIGJlZm9yZSB0aGUgPHRlbXBsYXRlPidzIGhvc3QgcHJvcGVydHlcbiAgICAgIC8vICAgIGZvcndhcmRpbmcuIEluIHRoYXQgc2NlbmFyaW8gY3JlYXRpbmcgYW4gaW5zdGFuY2Ugd291bGQgcmVzdWx0IGluXG4gICAgICAvLyAgICB0aGUgaG9zdCBwcm9wcyBiZWluZyBzZXQgb25jZSwgYW5kIHRoZW4gdGhlIGVucXVldWVkIGNoYW5nZXMgb24gdGhlXG4gICAgICAvLyAgICB0ZW1wbGF0ZSB3b3VsZCBzZXQgcHJvcGVydGllcyBhIHNlY29uZCB0aW1lLCBwb3RlbnRpYWxseSBjYXVzaW5nIGFuXG4gICAgICAvLyAgICBvYmplY3QgdG8gYmUgc2V0IHRvIGFuIGluc3RhbmNlIG1vcmUgdGhhbiBvbmNlLiAgQ3JlYXRpbmcgdGhlXG4gICAgICAvLyAgICBpbnN0YW5jZSBhc3luYyBmcm9tIGZsdXNoaW5nIGRhdGEgZW5zdXJlcyB0aGlzIGRvZXNuJ3QgaGFwcGVuLiBJZlxuICAgICAgLy8gICAgd2Ugd2FudGVkIGEgc3luYyBvcHRpb24gaW4gdGhlIGZ1dHVyZSwgc2ltcGx5IGhhdmluZyA8ZG9tLWlmPiBmbHVzaFxuICAgICAgLy8gICAgKG9yIGNsZWFyKSBpdHMgdGVtcGxhdGUncyBwZW5kaW5nIGhvc3QgcHJvcGVydGllcyBiZWZvcmUgY3JlYXRpbmdcbiAgICAgIC8vICAgIHRoZSBpbnN0YW5jZSB3b3VsZCBhbHNvIGF2b2lkIHRoZSBwcm9ibGVtLlxuICAgICAgdGhpcy5fX3JlbmRlckRlYm91bmNlciA9IFBvbHltZXIuRGVib3VuY2VyLmRlYm91bmNlKFxuICAgICAgICAgICAgdGhpcy5fX3JlbmRlckRlYm91bmNlclxuICAgICAgICAgICwgUG9seW1lci5Bc3luYy5taWNyb1Rhc2tcbiAgICAgICAgICAsICgpID0+IHRoaXMuX19yZW5kZXIoKSk7XG4gICAgICBQb2x5bWVyLmVucXVldWVEZWJvdW5jZXIodGhpcy5fX3JlbmRlckRlYm91bmNlcik7XG4gICAgfVxuXG4gICAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgICBzdXBlci5kaXNjb25uZWN0ZWRDYWxsYmFjaygpO1xuICAgICAgaWYgKCF0aGlzLnBhcmVudE5vZGUgfHxcbiAgICAgICAgICAodGhpcy5wYXJlbnROb2RlLm5vZGVUeXBlID09IE5vZGUuRE9DVU1FTlRfRlJBR01FTlRfTk9ERSAmJlxuICAgICAgICAgICAhdGhpcy5wYXJlbnROb2RlLmhvc3QpKSB7XG4gICAgICAgIHRoaXMuX190ZWFyZG93bkluc3RhbmNlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgICBzdXBlci5jb25uZWN0ZWRDYWxsYmFjaygpO1xuICAgICAgaWYgKHRoaXMuaWYpIHtcbiAgICAgICAgdGhpcy5fX2RlYm91bmNlUmVuZGVyKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRm9yY2VzIHRoZSBlbGVtZW50IHRvIHJlbmRlciBpdHMgY29udGVudC4gTm9ybWFsbHkgcmVuZGVyaW5nIGlzXG4gICAgICogYXN5bmNocm9ub3VzIHRvIGEgcHJvdm9raW5nIGNoYW5nZS4gVGhpcyBpcyBkb25lIGZvciBlZmZpY2llbmN5IHNvXG4gICAgICogdGhhdCBtdWx0aXBsZSBjaGFuZ2VzIHRyaWdnZXIgb25seSBhIHNpbmdsZSByZW5kZXIuIFRoZSByZW5kZXIgbWV0aG9kXG4gICAgICogc2hvdWxkIGJlIGNhbGxlZCBpZiwgZm9yIGV4YW1wbGUsIHRlbXBsYXRlIHJlbmRlcmluZyBpcyByZXF1aXJlZCB0b1xuICAgICAqIHZhbGlkYXRlIGFwcGxpY2F0aW9uIHN0YXRlLlxuICAgICAqL1xuICAgIHJlbmRlcigpIHtcbiAgICAgIFBvbHltZXIuZmx1c2goKTtcbiAgICB9XG5cbiAgICBfX3JlbmRlcigpIHtcbiAgICAgIGlmICh0aGlzLmlmKSB7XG4gICAgICAgIGlmICghdGhpcy5fX2Vuc3VyZUluc3RhbmNlKCkpIHtcbiAgICAgICAgICAvLyBObyB0ZW1wbGF0ZSBmb3VuZCB5ZXRcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2hvd0hpZGVDaGlsZHJlbigpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnJlc3RhbXApIHtcbiAgICAgICAgdGhpcy5fX3RlYXJkb3duSW5zdGFuY2UoKTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5yZXN0YW1wICYmIHRoaXMuX19pbnN0YW5jZSkge1xuICAgICAgICB0aGlzLl9zaG93SGlkZUNoaWxkcmVuKCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5pZiAhPSB0aGlzLl9sYXN0SWYpIHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnZG9tLWNoYW5nZScsIHtcbiAgICAgICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgICAgIGNvbXBvc2VkOiB0cnVlXG4gICAgICAgIH0pKTtcbiAgICAgICAgdGhpcy5fbGFzdElmID0gdGhpcy5pZjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfX2Vuc3VyZUluc3RhbmNlKCkge1xuICAgICAgbGV0IHBhcmVudE5vZGUgPSB0aGlzLnBhcmVudE5vZGU7XG4gICAgICAvLyBHdWFyZCBhZ2FpbnN0IGVsZW1lbnQgYmVpbmcgZGV0YWNoZWQgd2hpbGUgcmVuZGVyIHdhcyBxdWV1ZWRcbiAgICAgIGlmIChwYXJlbnROb2RlKSB7XG4gICAgICAgIGlmICghdGhpcy5fX2N0b3IpIHtcbiAgICAgICAgICBsZXQgdGVtcGxhdGUgPSB0aGlzLnF1ZXJ5U2VsZWN0b3IoJ3RlbXBsYXRlJyk7XG4gICAgICAgICAgaWYgKCF0ZW1wbGF0ZSkge1xuICAgICAgICAgICAgLy8gV2FpdCB1bnRpbCBjaGlsZExpc3QgY2hhbmdlcyBhbmQgdGVtcGxhdGUgc2hvdWxkIGJlIHRoZXJlIGJ5IHRoZW5cbiAgICAgICAgICAgIGxldCBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKCgpID0+IHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMucXVlcnlTZWxlY3RvcigndGVtcGxhdGUnKSkge1xuICAgICAgICAgICAgICAgIG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9fcmVuZGVyKCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkb20taWYgcmVxdWlyZXMgYSA8dGVtcGxhdGU+IGNoaWxkJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICBvYnNlcnZlci5vYnNlcnZlKHRoaXMsIHtjaGlsZExpc3Q6IHRydWV9KTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fX2N0b3IgPSBQb2x5bWVyLlRlbXBsYXRpemUudGVtcGxhdGl6ZSh0ZW1wbGF0ZSwgdGhpcywge1xuICAgICAgICAgICAgLy8gZG9tLWlmIHRlbXBsYXRpemVyIGluc3RhbmNlcyByZXF1aXJlIGBtdXRhYmxlOiB0cnVlYCwgYXNcbiAgICAgICAgICAgIC8vIGBfX3N5bmNIb3N0UHJvcGVydGllc2AgcmVsaWVzIG9uIHRoYXQgYmVoYXZpb3IgdG8gc3luYyBvYmplY3RzXG4gICAgICAgICAgICBtdXRhYmxlRGF0YTogdHJ1ZSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3AgUHJvcGVydHkgdG8gZm9yd2FyZFxuICAgICAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSBvZiBwcm9wZXJ0eVxuICAgICAgICAgICAgICogQHRoaXMge3RoaXN9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZvcndhcmRIb3N0UHJvcDogZnVuY3Rpb24ocHJvcCwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuX19pbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlmKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9faW5zdGFuY2UuZm9yd2FyZEhvc3RQcm9wKHByb3AsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZSBhbiBpbnN0YW5jZSBidXQgYXJlIHNxdWVsY2hpbmcgaG9zdCBwcm9wZXJ0eVxuICAgICAgICAgICAgICAgICAgLy8gZm9yd2FyZGluZyBkdWUgdG8gaWYgYmVpbmcgZmFsc2UsIG5vdGUgdGhlIGludmFsaWRhdGVkXG4gICAgICAgICAgICAgICAgICAvLyBwcm9wZXJ0aWVzIHNvIGBfX3N5bmNIb3N0UHJvcGVydGllc2AgY2FuIHN5bmMgdGhlbSB0aGUgbmV4dFxuICAgICAgICAgICAgICAgICAgLy8gdGltZSBgaWZgIGJlY29tZXMgdHJ1ZVxuICAgICAgICAgICAgICAgICAgdGhpcy5fX2ludmFsaWRQcm9wcyA9IHRoaXMuX19pbnZhbGlkUHJvcHMgfHwgT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX19pbnZhbGlkUHJvcHNbUG9seW1lci5QYXRoLnJvb3QocHJvcCldID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX19pbnN0YW5jZSkge1xuICAgICAgICAgIHRoaXMuX19pbnN0YW5jZSA9IG5ldyB0aGlzLl9fY3RvcigpO1xuICAgICAgICAgIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMuX19pbnN0YW5jZS5yb290LCB0aGlzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9fc3luY0hvc3RQcm9wZXJ0aWVzKCk7XG4gICAgICAgICAgbGV0IGMkID0gdGhpcy5fX2luc3RhbmNlLmNoaWxkcmVuO1xuICAgICAgICAgIGlmIChjJCAmJiBjJC5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIERldGVjdCBjYXNlIHdoZXJlIGRvbS1pZiB3YXMgcmUtYXR0YWNoZWQgaW4gbmV3IHBvc2l0aW9uXG4gICAgICAgICAgICBsZXQgbGFzdENoaWxkID0gdGhpcy5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgICAgICBpZiAobGFzdENoaWxkICE9PSBjJFtjJC5sZW5ndGgtMV0pIHtcbiAgICAgICAgICAgICAgZm9yIChsZXQgaT0wLCBuOyAoaTxjJC5sZW5ndGgpICYmIChuPWMkW2ldKTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobiwgdGhpcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIF9fc3luY0hvc3RQcm9wZXJ0aWVzKCkge1xuICAgICAgbGV0IHByb3BzID0gdGhpcy5fX2ludmFsaWRQcm9wcztcbiAgICAgIGlmIChwcm9wcykge1xuICAgICAgICBmb3IgKGxldCBwcm9wIGluIHByb3BzKSB7XG4gICAgICAgICAgdGhpcy5fX2luc3RhbmNlLl9zZXRQZW5kaW5nUHJvcGVydHkocHJvcCwgdGhpcy5fX2RhdGFIb3N0W3Byb3BdKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9faW52YWxpZFByb3BzID0gbnVsbDtcbiAgICAgICAgdGhpcy5fX2luc3RhbmNlLl9mbHVzaFByb3BlcnRpZXMoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfX3RlYXJkb3duSW5zdGFuY2UoKSB7XG4gICAgICBpZiAodGhpcy5fX2luc3RhbmNlKSB7XG4gICAgICAgIGxldCBjJCA9IHRoaXMuX19pbnN0YW5jZS5jaGlsZHJlbjtcbiAgICAgICAgaWYgKGMkICYmIGMkLmxlbmd0aCkge1xuICAgICAgICAgIC8vIHVzZSBmaXJzdCBjaGlsZCBwYXJlbnQsIGZvciBjYXNlIHdoZW4gZG9tLWlmIG1heSBoYXZlIGJlZW4gZGV0YWNoZWRcbiAgICAgICAgICBsZXQgcGFyZW50ID0gYyRbMF0ucGFyZW50Tm9kZTtcbiAgICAgICAgICBmb3IgKGxldCBpPTAsIG47IChpPGMkLmxlbmd0aCkgJiYgKG49YyRbaV0pOyBpKyspIHtcbiAgICAgICAgICAgIHBhcmVudC5yZW1vdmVDaGlsZChuKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fX2luc3RhbmNlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fX2ludmFsaWRQcm9wcyA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgX3Nob3dIaWRlQ2hpbGRyZW4oKSB7XG4gICAgICBsZXQgaGlkZGVuID0gdGhpcy5fX2hpZGVUZW1wbGF0ZUNoaWxkcmVuX18gfHwgIXRoaXMuaWY7XG4gICAgICBpZiAodGhpcy5fX2luc3RhbmNlKSB7XG4gICAgICAgIHRoaXMuX19pbnN0YW5jZS5fc2hvd0hpZGVDaGlsZHJlbihoaWRkZW4pO1xuICAgICAgfVxuICAgIH1cblxuICB9XG5cbiAgY3VzdG9tRWxlbWVudHMuZGVmaW5lKERvbUlmLmlzLCBEb21JZik7XG5cbiAgUG9seW1lci5Eb21JZiA9IERvbUlmO1xuXG59KSgpO1xuPC9zY3JpcHQ+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL3BvbHltZXIvbGliL2VsZW1lbnRzL2RvbS1pZi5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuXG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vLi4vcG9seW1lci1lbGVtZW50Lmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi91dGlscy9taXhpbi5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vdXRpbHMvYXJyYXktc3BsaWNlLmh0bWxcIj5cblxuPHNjcmlwdD5cbihmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8qKlxuICAgKiBFbGVtZW50IG1peGluIGZvciByZWNvcmRpbmcgZHluYW1pYyBhc3NvY2lhdGlvbnMgYmV0d2VlbiBpdGVtIHBhdGhzIGluIGFcbiAgICogbWFzdGVyIGBpdGVtc2AgYXJyYXkgYW5kIGEgYHNlbGVjdGVkYCBhcnJheSBzdWNoIHRoYXQgcGF0aCBjaGFuZ2VzIHRvIHRoZVxuICAgKiBtYXN0ZXIgYXJyYXkgKGF0IHRoZSBob3N0KSBlbGVtZW50IG9yIGVsc2V3aGVyZSB2aWEgZGF0YS1iaW5kaW5nKSBhcmVcbiAgICogY29ycmVjdGx5IHByb3BhZ2F0ZWQgdG8gaXRlbXMgaW4gdGhlIHNlbGVjdGVkIGFycmF5IGFuZCB2aWNlLXZlcnNhLlxuICAgKlxuICAgKiBUaGUgYGl0ZW1zYCBwcm9wZXJ0eSBhY2NlcHRzIGFuIGFycmF5IG9mIHVzZXIgZGF0YSwgYW5kIHZpYSB0aGVcbiAgICogYHNlbGVjdChpdGVtKWAgYW5kIGBkZXNlbGVjdChpdGVtKWAgQVBJLCB1cGRhdGVzIHRoZSBgc2VsZWN0ZWRgIHByb3BlcnR5XG4gICAqIHdoaWNoIG1heSBiZSBib3VuZCB0byBvdGhlciBwYXJ0cyBvZiB0aGUgYXBwbGljYXRpb24sIGFuZCBhbnkgY2hhbmdlcyB0b1xuICAgKiBzdWItZmllbGRzIG9mIGBzZWxlY3RlZGAgaXRlbShzKSB3aWxsIGJlIGtlcHQgaW4gc3luYyB3aXRoIGl0ZW1zIGluIHRoZVxuICAgKiBgaXRlbXNgIGFycmF5LiAgV2hlbiBgbXVsdGlgIGlzIGZhbHNlLCBgc2VsZWN0ZWRgIGlzIGEgcHJvcGVydHlcbiAgICogcmVwcmVzZW50aW5nIHRoZSBsYXN0IHNlbGVjdGVkIGl0ZW0uICBXaGVuIGBtdWx0aWAgaXMgdHJ1ZSwgYHNlbGVjdGVkYFxuICAgKiBpcyBhbiBhcnJheSBvZiBtdWx0aXBseSBzZWxlY3RlZCBpdGVtcy5cbiAgICpcbiAgICogQHBvbHltZXJcbiAgICogQG1peGluRnVuY3Rpb25cbiAgICogQGFwcGxpZXNNaXhpbiBQb2x5bWVyLkVsZW1lbnRNaXhpblxuICAgKiBAbWVtYmVyb2YgUG9seW1lclxuICAgKiBAc3VtbWFyeSBFbGVtZW50IG1peGluIGZvciByZWNvcmRpbmcgZHluYW1pYyBhc3NvY2lhdGlvbnMgYmV0d2VlbiBpdGVtIHBhdGhzIGluIGFcbiAgICogbWFzdGVyIGBpdGVtc2AgYXJyYXkgYW5kIGEgYHNlbGVjdGVkYCBhcnJheVxuICAgKi9cbiAgbGV0IEFycmF5U2VsZWN0b3JNaXhpbiA9IFBvbHltZXIuZGVkdXBpbmdNaXhpbihzdXBlckNsYXNzID0+IHtcblxuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBleHRlbmRzIHtzdXBlckNsYXNzfVxuICAgICAqIEBpbXBsZW1lbnRzIHtQb2x5bWVyX0VsZW1lbnRNaXhpbn1cbiAgICAgKi9cbiAgICBsZXQgZWxlbWVudEJhc2UgPSBQb2x5bWVyLkVsZW1lbnRNaXhpbihzdXBlckNsYXNzKTtcblxuICAgIC8qKlxuICAgICAqIEBwb2x5bWVyXG4gICAgICogQG1peGluQ2xhc3NcbiAgICAgKiBAaW1wbGVtZW50cyB7UG9seW1lcl9BcnJheVNlbGVjdG9yTWl4aW59XG4gICAgICogQHVucmVzdHJpY3RlZFxuICAgICAqL1xuICAgIGNsYXNzIEFycmF5U2VsZWN0b3JNaXhpbiBleHRlbmRzIGVsZW1lbnRCYXNlIHtcblxuICAgICAgc3RhdGljIGdldCBwcm9wZXJ0aWVzKCkge1xuXG4gICAgICAgIHJldHVybiB7XG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBBbiBhcnJheSBjb250YWluaW5nIGl0ZW1zIGZyb20gd2hpY2ggc2VsZWN0aW9uIHdpbGwgYmUgbWFkZS5cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBpdGVtczoge1xuICAgICAgICAgICAgdHlwZTogQXJyYXksXG4gICAgICAgICAgfSxcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFdoZW4gYHRydWVgLCBtdWx0aXBsZSBpdGVtcyBtYXkgYmUgc2VsZWN0ZWQgYXQgb25jZSAoaW4gdGhpcyBjYXNlLFxuICAgICAgICAgICAqIGBzZWxlY3RlZGAgaXMgYW4gYXJyYXkgb2YgY3VycmVudGx5IHNlbGVjdGVkIGl0ZW1zKS4gIFdoZW4gYGZhbHNlYCxcbiAgICAgICAgICAgKiBvbmx5IG9uZSBpdGVtIG1heSBiZSBzZWxlY3RlZCBhdCBhIHRpbWUuXG4gICAgICAgICAgICovXG4gICAgICAgICAgbXVsdGk6IHtcbiAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgICAgICB2YWx1ZTogZmFsc2UsXG4gICAgICAgICAgfSxcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFdoZW4gYG11bHRpYCBpcyB0cnVlLCB0aGlzIGlzIGFuIGFycmF5IHRoYXQgY29udGFpbnMgYW55IHNlbGVjdGVkLlxuICAgICAgICAgICAqIFdoZW4gYG11bHRpYCBpcyBmYWxzZSwgdGhpcyBpcyB0aGUgY3VycmVudGx5IHNlbGVjdGVkIGl0ZW0sIG9yIGBudWxsYFxuICAgICAgICAgICAqIGlmIG5vIGl0ZW0gaXMgc2VsZWN0ZWQuXG4gICAgICAgICAgICogQHR5cGUgez8oT2JqZWN0fEFycmF5PCFPYmplY3Q+KX1cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBzZWxlY3RlZDoge1xuICAgICAgICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgICAgICAgbm90aWZ5OiB0cnVlXG4gICAgICAgICAgfSxcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFdoZW4gYG11bHRpYCBpcyBmYWxzZSwgdGhpcyBpcyB0aGUgY3VycmVudGx5IHNlbGVjdGVkIGl0ZW0sIG9yIGBudWxsYFxuICAgICAgICAgICAqIGlmIG5vIGl0ZW0gaXMgc2VsZWN0ZWQuXG4gICAgICAgICAgICogQHR5cGUgez9PYmplY3R9XG4gICAgICAgICAgICovXG4gICAgICAgICAgc2VsZWN0ZWRJdGVtOiB7XG4gICAgICAgICAgICB0eXBlOiBPYmplY3QsXG4gICAgICAgICAgICBub3RpZnk6IHRydWVcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogV2hlbiBgdHJ1ZWAsIGNhbGxpbmcgYHNlbGVjdGAgb24gYW4gaXRlbSB0aGF0IGlzIGFscmVhZHkgc2VsZWN0ZWRcbiAgICAgICAgICAgKiB3aWxsIGRlc2VsZWN0IHRoZSBpdGVtLlxuICAgICAgICAgICAqL1xuICAgICAgICAgIHRvZ2dsZToge1xuICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgICAgIH1cblxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHN0YXRpYyBnZXQgb2JzZXJ2ZXJzKCkge1xuICAgICAgICByZXR1cm4gWydfX3VwZGF0ZVNlbGVjdGlvbihtdWx0aSwgaXRlbXMuKiknXVxuICAgICAgfVxuXG4gICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5fX2xhc3RJdGVtcyA9IG51bGw7XG4gICAgICAgIHRoaXMuX19sYXN0TXVsdGkgPSBudWxsO1xuICAgICAgICB0aGlzLl9fc2VsZWN0ZWRNYXAgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBfX3VwZGF0ZVNlbGVjdGlvbihtdWx0aSwgaXRlbXNJbmZvKSB7XG4gICAgICAgIGxldCBwYXRoID0gaXRlbXNJbmZvLnBhdGg7XG4gICAgICAgIGlmIChwYXRoID09ICdpdGVtcycpIHtcbiAgICAgICAgICAvLyBDYXNlIDEgLSBpdGVtcyBhcnJheSBjaGFuZ2VkLCBzbyBkaWZmIGFnYWluc3QgcHJldmlvdXMgYXJyYXkgYW5kXG4gICAgICAgICAgLy8gZGVzZWxlY3QgYW55IHJlbW92ZWQgaXRlbXMgYW5kIGFkanVzdCBzZWxlY3RlZCBpbmRpY2VzXG4gICAgICAgICAgbGV0IG5ld0l0ZW1zID0gaXRlbXNJbmZvLmJhc2UgfHwgW107XG4gICAgICAgICAgbGV0IGxhc3RJdGVtcyA9IHRoaXMuX19sYXN0SXRlbXM7XG4gICAgICAgICAgbGV0IGxhc3RNdWx0aSA9IHRoaXMuX19sYXN0TXVsdGk7XG4gICAgICAgICAgaWYgKG11bHRpICE9PSBsYXN0TXVsdGkpIHtcbiAgICAgICAgICAgIHRoaXMuY2xlYXJTZWxlY3Rpb24oKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGxhc3RJdGVtcykge1xuICAgICAgICAgICAgbGV0IHNwbGljZXMgPSBQb2x5bWVyLkFycmF5U3BsaWNlLmNhbGN1bGF0ZVNwbGljZXMobmV3SXRlbXMsIGxhc3RJdGVtcyk7XG4gICAgICAgICAgICB0aGlzLl9fYXBwbHlTcGxpY2VzKHNwbGljZXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9fbGFzdEl0ZW1zID0gbmV3SXRlbXM7XG4gICAgICAgICAgdGhpcy5fX2xhc3RNdWx0aSA9IG11bHRpO1xuICAgICAgICB9IGVsc2UgaWYgKGl0ZW1zSW5mby5wYXRoID09ICdpdGVtcy5zcGxpY2VzJykge1xuICAgICAgICAgIC8vIENhc2UgMiAtIGdvdCBzcGVjaWZpYyBzcGxpY2UgaW5mb3JtYXRpb24gZGVzY3JpYmluZyB0aGUgYXJyYXkgbXV0YXRpb246XG4gICAgICAgICAgLy8gZGVzZWxlY3QgYW55IHJlbW92ZWQgaXRlbXMgYW5kIGFkanVzdCBzZWxlY3RlZCBpbmRpY2VzXG4gICAgICAgICAgdGhpcy5fX2FwcGx5U3BsaWNlcyhpdGVtc0luZm8udmFsdWUuaW5kZXhTcGxpY2VzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBDYXNlIDMgLSBhbiBhcnJheSBlbGVtZW50IHdhcyBjaGFuZ2VkLCBzbyBkZXNlbGVjdCB0aGUgcHJldmlvdXNcbiAgICAgICAgICAvLyBpdGVtIGZvciB0aGF0IGluZGV4IGlmIGl0IHdhcyBwcmV2aW91c2x5IHNlbGVjdGVkXG4gICAgICAgICAgbGV0IHBhcnQgPSBwYXRoLnNsaWNlKCdpdGVtcy4nLmxlbmd0aCk7XG4gICAgICAgICAgbGV0IGlkeCA9IHBhcnNlSW50KHBhcnQsIDEwKTtcbiAgICAgICAgICBpZiAoKHBhcnQuaW5kZXhPZignLicpIDwgMCkgJiYgcGFydCA9PSBpZHgpIHtcbiAgICAgICAgICAgIHRoaXMuX19kZXNlbGVjdENoYW5nZWRJZHgoaWR4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgX19hcHBseVNwbGljZXMoc3BsaWNlcykge1xuICAgICAgICBsZXQgc2VsZWN0ZWQgPSB0aGlzLl9fc2VsZWN0ZWRNYXA7XG4gICAgICAgIC8vIEFkanVzdCBzZWxlY3RlZCBpbmRpY2VzIGFuZCBtYXJrIHJlbW92YWxzXG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxzcGxpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgbGV0IHMgPSBzcGxpY2VzW2ldO1xuICAgICAgICAgIHNlbGVjdGVkLmZvckVhY2goKGlkeCwgaXRlbSkgPT4ge1xuICAgICAgICAgICAgaWYgKGlkeCA8IHMuaW5kZXgpIHtcbiAgICAgICAgICAgICAgLy8gbm8gY2hhbmdlXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlkeCA+PSBzLmluZGV4ICsgcy5yZW1vdmVkLmxlbmd0aCkge1xuICAgICAgICAgICAgICAvLyBhZGp1c3QgaW5kZXhcbiAgICAgICAgICAgICAgc2VsZWN0ZWQuc2V0KGl0ZW0sIGlkeCArIHMuYWRkZWRDb3VudCAtIHMucmVtb3ZlZC5sZW5ndGgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gcmVtb3ZlIGluZGV4XG4gICAgICAgICAgICAgIHNlbGVjdGVkLnNldChpdGVtLCAtMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZm9yIChsZXQgaj0wOyBqPHMuYWRkZWRDb3VudDsgaisrKSB7XG4gICAgICAgICAgICBsZXQgaWR4ID0gcy5pbmRleCArIGo7XG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWQuaGFzKHRoaXMuaXRlbXNbaWR4XSkpIHtcbiAgICAgICAgICAgICAgc2VsZWN0ZWQuc2V0KHRoaXMuaXRlbXNbaWR4XSwgaWR4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXBkYXRlIGxpbmtlZCBwYXRoc1xuICAgICAgICB0aGlzLl9fdXBkYXRlTGlua3MoKTtcbiAgICAgICAgLy8gUmVtb3ZlIHNlbGVjdGVkIGl0ZW1zIHRoYXQgd2VyZSByZW1vdmVkIGZyb20gdGhlIGl0ZW1zIGFycmF5XG4gICAgICAgIGxldCBzaWR4ID0gMDtcbiAgICAgICAgc2VsZWN0ZWQuZm9yRWFjaCgoaWR4LCBpdGVtKSA9PiB7XG4gICAgICAgICAgaWYgKGlkeCA8IDApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm11bHRpKSB7XG4gICAgICAgICAgICAgIHRoaXMuc3BsaWNlKCdzZWxlY3RlZCcsIHNpZHgsIDEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZCA9IHRoaXMuc2VsZWN0ZWRJdGVtID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGVjdGVkLmRlbGV0ZShpdGVtKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2lkeCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIF9fdXBkYXRlTGlua3MoKSB7XG4gICAgICAgIHRoaXMuX19kYXRhTGlua2VkUGF0aHMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMubXVsdGkpIHtcbiAgICAgICAgICBsZXQgc2lkeCA9IDA7XG4gICAgICAgICAgdGhpcy5fX3NlbGVjdGVkTWFwLmZvckVhY2goaWR4ID0+IHtcbiAgICAgICAgICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgICAgICAgICB0aGlzLmxpbmtQYXRocygnaXRlbXMuJyArIGlkeCwgJ3NlbGVjdGVkLicgKyBzaWR4KyspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX19zZWxlY3RlZE1hcC5mb3JFYWNoKGlkeCA9PiB7XG4gICAgICAgICAgICB0aGlzLmxpbmtQYXRocygnc2VsZWN0ZWQnLCAnaXRlbXMuJyArIGlkeCk7XG4gICAgICAgICAgICB0aGlzLmxpbmtQYXRocygnc2VsZWN0ZWRJdGVtJywgJ2l0ZW1zLicgKyBpZHgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ2xlYXJzIHRoZSBzZWxlY3Rpb24gc3RhdGUuXG4gICAgICAgKlxuICAgICAgICovXG4gICAgICBjbGVhclNlbGVjdGlvbigpIHtcbiAgICAgICAgLy8gVW5iaW5kIHByZXZpb3VzIHNlbGVjdGlvblxuICAgICAgICB0aGlzLl9fZGF0YUxpbmtlZFBhdGhzID0ge307XG4gICAgICAgIC8vIFRoZSBzZWxlY3RlZCBtYXAgc3RvcmVzIDMgcGllY2VzIG9mIGluZm9ybWF0aW9uOlxuICAgICAgICAvLyBrZXk6IGl0ZW1zIGFycmF5IG9iamVjdFxuICAgICAgICAvLyB2YWx1ZTogaXRlbXMgYXJyYXkgaW5kZXhcbiAgICAgICAgLy8gb3JkZXI6IHNlbGVjdGVkIGFycmF5IGluZGV4XG4gICAgICAgIHRoaXMuX19zZWxlY3RlZE1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBzZWxlY3Rpb25cbiAgICAgICAgdGhpcy5zZWxlY3RlZCA9IHRoaXMubXVsdGkgPyBbXSA6IG51bGxcbiAgICAgICAgdGhpcy5zZWxlY3RlZEl0ZW0gPSBudWxsO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgaXRlbSBpcyBjdXJyZW50bHkgc2VsZWN0ZWQuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHsqfSBpdGVtIEl0ZW0gZnJvbSBgaXRlbXNgIGFycmF5IHRvIHRlc3RcbiAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIGl0ZW0gaXMgc2VsZWN0ZWRcbiAgICAgICAqL1xuICAgICAgaXNTZWxlY3RlZChpdGVtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fc2VsZWN0ZWRNYXAuaGFzKGl0ZW0pO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgaXRlbSBpcyBjdXJyZW50bHkgc2VsZWN0ZWQuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGlkeCBJbmRleCBmcm9tIGBpdGVtc2AgYXJyYXkgdG8gdGVzdFxuICAgICAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgaXRlbSBpcyBzZWxlY3RlZFxuICAgICAgICovXG4gICAgICBpc0luZGV4U2VsZWN0ZWQoaWR4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzU2VsZWN0ZWQodGhpcy5pdGVtc1tpZHhdKTtcbiAgICAgIH1cblxuICAgICAgX19kZXNlbGVjdENoYW5nZWRJZHgoaWR4KSB7XG4gICAgICAgIGxldCBzaWR4ID0gdGhpcy5fX3NlbGVjdGVkSW5kZXhGb3JJdGVtSW5kZXgoaWR4KTtcbiAgICAgICAgaWYgKHNpZHggPj0gMCkge1xuICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICB0aGlzLl9fc2VsZWN0ZWRNYXAuZm9yRWFjaCgoaWR4LCBpdGVtKSA9PiB7XG4gICAgICAgICAgICBpZiAoc2lkeCA9PSBpKyspIHtcbiAgICAgICAgICAgICAgdGhpcy5kZXNlbGVjdChpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBfX3NlbGVjdGVkSW5kZXhGb3JJdGVtSW5kZXgoaWR4KSB7XG4gICAgICAgIGxldCBzZWxlY3RlZCA9IHRoaXMuX19kYXRhTGlua2VkUGF0aHNbJ2l0ZW1zLicgKyBpZHhdO1xuICAgICAgICBpZiAoc2VsZWN0ZWQpIHtcbiAgICAgICAgICByZXR1cm4gcGFyc2VJbnQoc2VsZWN0ZWQuc2xpY2UoJ3NlbGVjdGVkLicubGVuZ3RoKSwgMTApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogRGVzZWxlY3RzIHRoZSBnaXZlbiBpdGVtIGlmIGl0IGlzIGFscmVhZHkgc2VsZWN0ZWQuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHsqfSBpdGVtIEl0ZW0gZnJvbSBgaXRlbXNgIGFycmF5IHRvIGRlc2VsZWN0XG4gICAgICAgKi9cbiAgICAgIGRlc2VsZWN0KGl0ZW0pIHtcbiAgICAgICAgbGV0IGlkeCA9IHRoaXMuX19zZWxlY3RlZE1hcC5nZXQoaXRlbSk7XG4gICAgICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgICAgIHRoaXMuX19zZWxlY3RlZE1hcC5kZWxldGUoaXRlbSk7XG4gICAgICAgICAgbGV0IHNpZHg7XG4gICAgICAgICAgaWYgKHRoaXMubXVsdGkpIHtcbiAgICAgICAgICAgIHNpZHggPSB0aGlzLl9fc2VsZWN0ZWRJbmRleEZvckl0ZW1JbmRleChpZHgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9fdXBkYXRlTGlua3MoKTtcbiAgICAgICAgICBpZiAodGhpcy5tdWx0aSkge1xuICAgICAgICAgICAgdGhpcy5zcGxpY2UoJ3NlbGVjdGVkJywgc2lkeCwgMSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWQgPSB0aGlzLnNlbGVjdGVkSXRlbSA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogRGVzZWxlY3RzIHRoZSBnaXZlbiBpbmRleCBpZiBpdCBpcyBhbHJlYWR5IHNlbGVjdGVkLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpZHggSW5kZXggZnJvbSBgaXRlbXNgIGFycmF5IHRvIGRlc2VsZWN0XG4gICAgICAgKi9cbiAgICAgIGRlc2VsZWN0SW5kZXgoaWR4KSB7XG4gICAgICAgIHRoaXMuZGVzZWxlY3QodGhpcy5pdGVtc1tpZHhdKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBTZWxlY3RzIHRoZSBnaXZlbiBpdGVtLiAgV2hlbiBgdG9nZ2xlYCBpcyB0cnVlLCB0aGlzIHdpbGwgYXV0b21hdGljYWxseVxuICAgICAgICogZGVzZWxlY3QgdGhlIGl0ZW0gaWYgYWxyZWFkeSBzZWxlY3RlZC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0geyp9IGl0ZW0gSXRlbSBmcm9tIGBpdGVtc2AgYXJyYXkgdG8gc2VsZWN0XG4gICAgICAgKi9cbiAgICAgIHNlbGVjdChpdGVtKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0SW5kZXgodGhpcy5pdGVtcy5pbmRleE9mKGl0ZW0pKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBTZWxlY3RzIHRoZSBnaXZlbiBpbmRleC4gIFdoZW4gYHRvZ2dsZWAgaXMgdHJ1ZSwgdGhpcyB3aWxsIGF1dG9tYXRpY2FsbHlcbiAgICAgICAqIGRlc2VsZWN0IHRoZSBpdGVtIGlmIGFscmVhZHkgc2VsZWN0ZWQuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGlkeCBJbmRleCBmcm9tIGBpdGVtc2AgYXJyYXkgdG8gc2VsZWN0XG4gICAgICAgKi9cbiAgICAgIHNlbGVjdEluZGV4KGlkeCkge1xuICAgICAgICBsZXQgaXRlbSA9IHRoaXMuaXRlbXNbaWR4XTtcbiAgICAgICAgaWYgKCF0aGlzLmlzU2VsZWN0ZWQoaXRlbSkpIHtcbiAgICAgICAgICBpZiAoIXRoaXMubXVsdGkpIHtcbiAgICAgICAgICAgIHRoaXMuX19zZWxlY3RlZE1hcC5jbGVhcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9fc2VsZWN0ZWRNYXAuc2V0KGl0ZW0sIGlkeCk7XG4gICAgICAgICAgdGhpcy5fX3VwZGF0ZUxpbmtzKCk7XG4gICAgICAgICAgaWYgKHRoaXMubXVsdGkpIHtcbiAgICAgICAgICAgIHRoaXMucHVzaCgnc2VsZWN0ZWQnLCBpdGVtKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZCA9IHRoaXMuc2VsZWN0ZWRJdGVtID0gaXRlbTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy50b2dnbGUpIHtcbiAgICAgICAgICB0aGlzLmRlc2VsZWN0SW5kZXgoaWR4KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgfVxuXG4gICAgcmV0dXJuIEFycmF5U2VsZWN0b3JNaXhpbjtcblxuICB9KTtcblxuICAvLyBleHBvcnQgbWl4aW5cbiAgUG9seW1lci5BcnJheVNlbGVjdG9yTWl4aW4gPSBBcnJheVNlbGVjdG9yTWl4aW47XG5cbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAZXh0ZW5kcyB7UG9seW1lci5FbGVtZW50fVxuICAgKiBAaW1wbGVtZW50cyB7UG9seW1lcl9BcnJheVNlbGVjdG9yTWl4aW59XG4gICAqL1xuICBsZXQgYmFzZUFycmF5U2VsZWN0b3IgPSBBcnJheVNlbGVjdG9yTWl4aW4oUG9seW1lci5FbGVtZW50KTtcblxuICAvKipcbiAgICogRWxlbWVudCBpbXBsZW1lbnRpbmcgdGhlIGBQb2x5bWVyLkFycmF5U2VsZWN0b3JgIG1peGluLCB3aGljaCByZWNvcmRzXG4gICAqIGR5bmFtaWMgYXNzb2NpYXRpb25zIGJldHdlZW4gaXRlbSBwYXRocyBpbiBhIG1hc3RlciBgaXRlbXNgIGFycmF5IGFuZCBhXG4gICAqIGBzZWxlY3RlZGAgYXJyYXkgc3VjaCB0aGF0IHBhdGggY2hhbmdlcyB0byB0aGUgbWFzdGVyIGFycmF5IChhdCB0aGUgaG9zdClcbiAgICogZWxlbWVudCBvciBlbHNld2hlcmUgdmlhIGRhdGEtYmluZGluZykgYXJlIGNvcnJlY3RseSBwcm9wYWdhdGVkIHRvIGl0ZW1zXG4gICAqIGluIHRoZSBzZWxlY3RlZCBhcnJheSBhbmQgdmljZS12ZXJzYS5cbiAgICpcbiAgICogVGhlIGBpdGVtc2AgcHJvcGVydHkgYWNjZXB0cyBhbiBhcnJheSBvZiB1c2VyIGRhdGEsIGFuZCB2aWEgdGhlXG4gICAqIGBzZWxlY3QoaXRlbSlgIGFuZCBgZGVzZWxlY3QoaXRlbSlgIEFQSSwgdXBkYXRlcyB0aGUgYHNlbGVjdGVkYCBwcm9wZXJ0eVxuICAgKiB3aGljaCBtYXkgYmUgYm91bmQgdG8gb3RoZXIgcGFydHMgb2YgdGhlIGFwcGxpY2F0aW9uLCBhbmQgYW55IGNoYW5nZXMgdG9cbiAgICogc3ViLWZpZWxkcyBvZiBgc2VsZWN0ZWRgIGl0ZW0ocykgd2lsbCBiZSBrZXB0IGluIHN5bmMgd2l0aCBpdGVtcyBpbiB0aGVcbiAgICogYGl0ZW1zYCBhcnJheS4gIFdoZW4gYG11bHRpYCBpcyBmYWxzZSwgYHNlbGVjdGVkYCBpcyBhIHByb3BlcnR5XG4gICAqIHJlcHJlc2VudGluZyB0aGUgbGFzdCBzZWxlY3RlZCBpdGVtLiAgV2hlbiBgbXVsdGlgIGlzIHRydWUsIGBzZWxlY3RlZGBcbiAgICogaXMgYW4gYXJyYXkgb2YgbXVsdGlwbHkgc2VsZWN0ZWQgaXRlbXMuXG4gICAqXG4gICAqIEV4YW1wbGU6XG4gICAqXG4gICAqIGBgYGh0bWxcbiAgICogPGRvbS1tb2R1bGUgaWQ9XCJlbXBsb3llZS1saXN0XCI+XG4gICAqXG4gICAqICAgPHRlbXBsYXRlPlxuICAgKlxuICAgKiAgICAgPGRpdj4gRW1wbG95ZWUgbGlzdDogPC9kaXY+XG4gICAqICAgICA8dGVtcGxhdGUgaXM9XCJkb20tcmVwZWF0XCIgaWQ9XCJlbXBsb3llZUxpc3RcIiBpdGVtcz1cInt7ZW1wbG95ZWVzfX1cIj5cbiAgICogICAgICAgICA8ZGl2PkZpcnN0IG5hbWU6IDxzcGFuPnt7aXRlbS5maXJzdH19PC9zcGFuPjwvZGl2PlxuICAgKiAgICAgICAgIDxkaXY+TGFzdCBuYW1lOiA8c3Bhbj57e2l0ZW0ubGFzdH19PC9zcGFuPjwvZGl2PlxuICAgKiAgICAgICAgIDxidXR0b24gb24tY2xpY2s9XCJ0b2dnbGVTZWxlY3Rpb25cIj5TZWxlY3Q8L2J1dHRvbj5cbiAgICogICAgIDwvdGVtcGxhdGU+XG4gICAqXG4gICAqICAgICA8YXJyYXktc2VsZWN0b3IgaWQ9XCJzZWxlY3RvclwiIGl0ZW1zPVwie3tlbXBsb3llZXN9fVwiIHNlbGVjdGVkPVwie3tzZWxlY3RlZH19XCIgbXVsdGkgdG9nZ2xlPjwvYXJyYXktc2VsZWN0b3I+XG4gICAqXG4gICAqICAgICA8ZGl2PiBTZWxlY3RlZCBlbXBsb3llZXM6IDwvZGl2PlxuICAgKiAgICAgPHRlbXBsYXRlIGlzPVwiZG9tLXJlcGVhdFwiIGl0ZW1zPVwie3tzZWxlY3RlZH19XCI+XG4gICAqICAgICAgICAgPGRpdj5GaXJzdCBuYW1lOiA8c3Bhbj57e2l0ZW0uZmlyc3R9fTwvc3Bhbj48L2Rpdj5cbiAgICogICAgICAgICA8ZGl2Pkxhc3QgbmFtZTogPHNwYW4+e3tpdGVtLmxhc3R9fTwvc3Bhbj48L2Rpdj5cbiAgICogICAgIDwvdGVtcGxhdGU+XG4gICAqXG4gICAqICAgPC90ZW1wbGF0ZT5cbiAgICpcbiAgICogPC9kb20tbW9kdWxlPlxuICAgKiBgYGBcbiAgICpcbiAgICogYGBganNcbiAgICogUG9seW1lcih7XG4gICAqICAgaXM6ICdlbXBsb3llZS1saXN0JyxcbiAgICogICByZWFkeSgpIHtcbiAgICogICAgIHRoaXMuZW1wbG95ZWVzID0gW1xuICAgKiAgICAgICAgIHtmaXJzdDogJ0JvYicsIGxhc3Q6ICdTbWl0aCd9LFxuICAgKiAgICAgICAgIHtmaXJzdDogJ1NhbGx5JywgbGFzdDogJ0pvaG5zb24nfSxcbiAgICogICAgICAgICAuLi5cbiAgICogICAgIF07XG4gICAqICAgfSxcbiAgICogICB0b2dnbGVTZWxlY3Rpb24oZSkge1xuICAgKiAgICAgbGV0IGl0ZW0gPSB0aGlzLiQuZW1wbG95ZWVMaXN0Lml0ZW1Gb3JFbGVtZW50KGUudGFyZ2V0KTtcbiAgICogICAgIHRoaXMuJC5zZWxlY3Rvci5zZWxlY3QoaXRlbSk7XG4gICAqICAgfVxuICAgKiB9KTtcbiAgICogYGBgXG4gICAqXG4gICAqIEBwb2x5bWVyXG4gICAqIEBjdXN0b21FbGVtZW50XG4gICAqIEBleHRlbmRzIHtiYXNlQXJyYXlTZWxlY3Rvcn1cbiAgICogQGFwcGxpZXNNaXhpbiBQb2x5bWVyLkFycmF5U2VsZWN0b3JNaXhpblxuICAgKiBAbWVtYmVyb2YgUG9seW1lclxuICAgKiBAc3VtbWFyeSBDdXN0b20gZWxlbWVudCB0aGF0IGxpbmtzIHBhdGhzIGJldHdlZW4gYW4gaW5wdXQgYGl0ZW1zYCBhcnJheSBhbmRcbiAgICogICBhbiBvdXRwdXQgYHNlbGVjdGVkYCBpdGVtIG9yIGFycmF5IGJhc2VkIG9uIGNhbGxzIHRvIGl0cyBzZWxlY3Rpb24gQVBJLlxuICAgKi9cbiAgY2xhc3MgQXJyYXlTZWxlY3RvciBleHRlbmRzIGJhc2VBcnJheVNlbGVjdG9yIHtcbiAgICAvLyBOb3QgbmVlZGVkIHRvIGZpbmQgdGVtcGxhdGU7IGNhbiBiZSByZW1vdmVkIG9uY2UgdGhlIGFuYWx5emVyXG4gICAgLy8gY2FuIGZpbmQgdGhlIHRhZyBuYW1lIGZyb20gY3VzdG9tRWxlbWVudHMuZGVmaW5lIGNhbGxcbiAgICBzdGF0aWMgZ2V0IGlzKCkgeyByZXR1cm4gJ2FycmF5LXNlbGVjdG9yJyB9XG4gIH1cbiAgY3VzdG9tRWxlbWVudHMuZGVmaW5lKEFycmF5U2VsZWN0b3IuaXMsIEFycmF5U2VsZWN0b3IpO1xuICBQb2x5bWVyLkFycmF5U2VsZWN0b3IgPSBBcnJheVNlbGVjdG9yO1xuXG59KSgpO1xuXG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvZWxlbWVudHMvYXJyYXktc2VsZWN0b3IuaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi8uLi8uLi9zaGFkeWNzcy9jdXN0b20tc3R5bGUtaW50ZXJmYWNlLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi91dGlscy9zdHlsZS1nYXRoZXIuaHRtbFwiPlxuPHNjcmlwdD5cbihmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIGNvbnN0IGF0dHIgPSAnaW5jbHVkZSc7XG5cbiAgY29uc3QgQ3VzdG9tU3R5bGVJbnRlcmZhY2UgPSB3aW5kb3cuU2hhZHlDU1MuQ3VzdG9tU3R5bGVJbnRlcmZhY2U7XG5cbiAgLyoqXG4gICAqIEN1c3RvbSBlbGVtZW50IGZvciBkZWZpbmluZyBzdHlsZXMgaW4gdGhlIG1haW4gZG9jdW1lbnQgdGhhdCBjYW4gdGFrZVxuICAgKiBhZHZhbnRhZ2Ugb2Ygc2V2ZXJhbCBzcGVjaWFsIGZlYXR1cmVzIG9mIFBvbHltZXIncyBzdHlsaW5nIHN5c3RlbTpcbiAgICpcbiAgICogLSBEb2N1bWVudCBzdHlsZXMgZGVmaW5lZCBpbiBhIGN1c3RvbS1zdHlsZSBhcmUgc2hpbW1lZCB0byBlbnN1cmUgdGhleVxuICAgKiAgIGRvIG5vdCBsZWFrIGludG8gbG9jYWwgRE9NIHdoZW4gcnVubmluZyBvbiBicm93c2VycyB3aXRob3V0IG5hdGl2ZVxuICAgKiAgIFNoYWRvdyBET00uXG4gICAqIC0gQ3VzdG9tIHByb3BlcnRpZXMgdXNlZCBieSBQb2x5bWVyJ3Mgc2hpbSBmb3IgY3Jvc3Mtc2NvcGUgc3R5bGluZyBtYXlcbiAgICogICBiZSBkZWZpbmVkIGluIGFuIGN1c3RvbS1zdHlsZS4gVXNlIHRoZSA6cm9vdCBzZWxlY3RvciB0byBkZWZpbmUgY3VzdG9tXG4gICAqICAgcHJvcGVydGllcyB0aGF0IGFwcGx5IHRvIGFsbCBjdXN0b20gZWxlbWVudHMuXG4gICAqXG4gICAqIFRvIHVzZSwgc2ltcGx5IHdyYXAgYW4gaW5saW5lIGA8c3R5bGU+YCB0YWcgaW4gdGhlIG1haW4gZG9jdW1lbnQgd2hvc2VcbiAgICogQ1NTIHVzZXMgdGhlc2UgZmVhdHVyZXMgd2l0aCBhIGA8Y3VzdG9tLXN0eWxlPmAgZWxlbWVudC5cbiAgICpcbiAgICogQGN1c3RvbUVsZW1lbnRcbiAgICogQGV4dGVuZHMgSFRNTEVsZW1lbnRcbiAgICogQG1lbWJlcm9mIFBvbHltZXJcbiAgICogQHN1bW1hcnkgQ3VzdG9tIGVsZW1lbnQgZm9yIGRlZmluaW5nIHN0eWxlcyBpbiB0aGUgbWFpbiBkb2N1bWVudCB0aGF0IGNhblxuICAgKiAgIHRha2UgYWR2YW50YWdlIG9mIFBvbHltZXIncyBzdHlsZSBzY29waW5nIGFuZCBjdXN0b20gcHJvcGVydGllcyBzaGltcy5cbiAgICovXG4gIGNsYXNzIEN1c3RvbVN0eWxlIGV4dGVuZHMgSFRNTEVsZW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgc3VwZXIoKTtcbiAgICAgIHRoaXMuX3N0eWxlID0gbnVsbDtcbiAgICAgIEN1c3RvbVN0eWxlSW50ZXJmYWNlLmFkZEN1c3RvbVN0eWxlKHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBsaWdodC1ET00gYDxzdHlsZT5gIGNoaWxkIHRoaXMgZWxlbWVudCB3cmFwcy4gIFVwb24gZmlyc3RcbiAgICAgKiBjYWxsIGFueSBzdHlsZSBtb2R1bGVzIHJlZmVyZW5jZWQgdmlhIHRoZSBgaW5jbHVkZWAgYXR0cmlidXRlIHdpbGwgYmVcbiAgICAgKiBjb25jYXRlbmF0ZWQgdG8gdGhpcyBlbGVtZW50J3MgYDxzdHlsZT5gLlxuICAgICAqXG4gICAgICogQHJldHVybiB7SFRNTFN0eWxlRWxlbWVudH0gVGhpcyBlbGVtZW50J3MgbGlnaHQtRE9NIGA8c3R5bGU+YFxuICAgICAqL1xuICAgIGdldFN0eWxlKCkge1xuICAgICAgaWYgKHRoaXMuX3N0eWxlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdHlsZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN0eWxlID0gLyoqIEB0eXBlIHtIVE1MU3R5bGVFbGVtZW50fSAqLyh0aGlzLnF1ZXJ5U2VsZWN0b3IoJ3N0eWxlJykpO1xuICAgICAgaWYgKCFzdHlsZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3N0eWxlID0gc3R5bGU7XG4gICAgICBjb25zdCBpbmNsdWRlID0gc3R5bGUuZ2V0QXR0cmlidXRlKGF0dHIpO1xuICAgICAgaWYgKGluY2x1ZGUpIHtcbiAgICAgICAgc3R5bGUucmVtb3ZlQXR0cmlidXRlKGF0dHIpO1xuICAgICAgICBzdHlsZS50ZXh0Q29udGVudCA9IFBvbHltZXIuU3R5bGVHYXRoZXIuY3NzRnJvbU1vZHVsZXMoaW5jbHVkZSkgKyBzdHlsZS50ZXh0Q29udGVudDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9zdHlsZTtcbiAgICB9XG4gIH1cblxuICB3aW5kb3cuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdjdXN0b20tc3R5bGUnLCBDdXN0b21TdHlsZSk7XG4gIFBvbHltZXIuQ3VzdG9tU3R5bGUgPSBDdXN0b21TdHlsZTtcbn0pKCk7XG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvZWxlbWVudHMvY3VzdG9tLXN0eWxlLmh0bWwiLCJcbnJlcXVpcmUoJy4vY3VzdG9tLXN0eWxlLWludGVyZmFjZS5taW4uanMnKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvc2hhZHljc3MvY3VzdG9tLXN0eWxlLWludGVyZmFjZS5odG1sIiwiKGZ1bmN0aW9uKCl7LypcblxuQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuKi9cbid1c2Ugc3RyaWN0Jzt2YXIgYz0hKHdpbmRvdy5TaGFkeURPTSYmd2luZG93LlNoYWR5RE9NLmluVXNlKSxmO2Z1bmN0aW9uIGcoYSl7Zj1hJiZhLnNoaW1jc3Nwcm9wZXJ0aWVzPyExOmN8fCEobmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvQXBwbGVXZWJLaXRcXC82MDF8RWRnZVxcLzE1Lyl8fCF3aW5kb3cuQ1NTfHwhQ1NTLnN1cHBvcnRzfHwhQ1NTLnN1cHBvcnRzKFwiYm94LXNoYWRvd1wiLFwiMCAwIDAgdmFyKC0tZm9vKVwiKSl9d2luZG93LlNoYWR5Q1NTJiZ2b2lkIDAhPT13aW5kb3cuU2hhZHlDU1MubmF0aXZlQ3NzP2Y9d2luZG93LlNoYWR5Q1NTLm5hdGl2ZUNzczp3aW5kb3cuU2hhZHlDU1M/KGcod2luZG93LlNoYWR5Q1NTKSx3aW5kb3cuU2hhZHlDU1M9dm9pZCAwKTpnKHdpbmRvdy5XZWJDb21wb25lbnRzJiZ3aW5kb3cuV2ViQ29tcG9uZW50cy5mbGFncyk7dmFyIGg9ZjtmdW5jdGlvbiBrKGEsYil7Zm9yKHZhciBkIGluIGIpbnVsbD09PWQ/YS5zdHlsZS5yZW1vdmVQcm9wZXJ0eShkKTphLnN0eWxlLnNldFByb3BlcnR5KGQsYltkXSl9O3ZhciBsPW51bGwsbT13aW5kb3cuSFRNTEltcG9ydHMmJndpbmRvdy5IVE1MSW1wb3J0cy53aGVuUmVhZHl8fG51bGwsbjtmdW5jdGlvbiBwKCl7dmFyIGE9cTtyZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKXttP20oYSk6KGx8fChsPW5ldyBQcm9taXNlKGZ1bmN0aW9uKGEpe249YX0pLFwiY29tcGxldGVcIj09PWRvY3VtZW50LnJlYWR5U3RhdGU/bigpOmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJyZWFkeXN0YXRlY2hhbmdlXCIsZnVuY3Rpb24oKXtcImNvbXBsZXRlXCI9PT1kb2N1bWVudC5yZWFkeVN0YXRlJiZuKCl9KSksbC50aGVuKGZ1bmN0aW9uKCl7YSYmYSgpfSkpfSl9O3ZhciByPW51bGwscT1udWxsO2Z1bmN0aW9uIHQoKXt0aGlzLmN1c3RvbVN0eWxlcz1bXTt0aGlzLmVucXVldWVkPSExfWZ1bmN0aW9uIHUoYSl7IWEuZW5xdWV1ZWQmJnEmJihhLmVucXVldWVkPSEwLHAoKSl9dC5wcm90b3R5cGUuYz1mdW5jdGlvbihhKXthLl9fc2VlbkJ5U2hhZHlDU1N8fChhLl9fc2VlbkJ5U2hhZHlDU1M9ITAsdGhpcy5jdXN0b21TdHlsZXMucHVzaChhKSx1KHRoaXMpKX07dC5wcm90b3R5cGUuYj1mdW5jdGlvbihhKXtpZihhLl9fc2hhZHlDU1NDYWNoZWRTdHlsZSlyZXR1cm4gYS5fX3NoYWR5Q1NTQ2FjaGVkU3R5bGU7dmFyIGI7YS5nZXRTdHlsZT9iPWEuZ2V0U3R5bGUoKTpiPWE7cmV0dXJuIGJ9O1xudC5wcm90b3R5cGUuYT1mdW5jdGlvbigpe2Zvcih2YXIgYT10aGlzLmN1c3RvbVN0eWxlcyxiPTA7YjxhLmxlbmd0aDtiKyspe3ZhciBkPWFbYl07aWYoIWQuX19zaGFkeUNTU0NhY2hlZFN0eWxlKXt2YXIgZT10aGlzLmIoZCk7ZSYmKGU9ZS5fX2FwcGxpZWRFbGVtZW50fHxlLHImJnIoZSksZC5fX3NoYWR5Q1NTQ2FjaGVkU3R5bGU9ZSl9fXJldHVybiBhfTt0LnByb3RvdHlwZS5hZGRDdXN0b21TdHlsZT10LnByb3RvdHlwZS5jO3QucHJvdG90eXBlLmdldFN0eWxlRm9yQ3VzdG9tU3R5bGU9dC5wcm90b3R5cGUuYjt0LnByb3RvdHlwZS5wcm9jZXNzU3R5bGVzPXQucHJvdG90eXBlLmE7XG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyh0LnByb3RvdHlwZSx7dHJhbnNmb3JtQ2FsbGJhY2s6e2dldDpmdW5jdGlvbigpe3JldHVybiByfSxzZXQ6ZnVuY3Rpb24oYSl7cj1hfX0sdmFsaWRhdGVDYWxsYmFjazp7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHF9LHNldDpmdW5jdGlvbihhKXt2YXIgYj0hMTtxfHwoYj0hMCk7cT1hO2ImJnUodGhpcyl9fX0pO3ZhciB2PW5ldyB0O3dpbmRvdy5TaGFkeUNTU3x8KHdpbmRvdy5TaGFkeUNTUz17cHJlcGFyZVRlbXBsYXRlOmZ1bmN0aW9uKCl7fSxzdHlsZVN1YnRyZWU6ZnVuY3Rpb24oYSxiKXt2LmEoKTtrKGEsYil9LHN0eWxlRWxlbWVudDpmdW5jdGlvbigpe3YuYSgpfSxzdHlsZURvY3VtZW50OmZ1bmN0aW9uKGEpe3YuYSgpO2soZG9jdW1lbnQuYm9keSxhKX0sZ2V0Q29tcHV0ZWRTdHlsZVZhbHVlOmZ1bmN0aW9uKGEsYil7cmV0dXJuKGE9d2luZG93LmdldENvbXB1dGVkU3R5bGUoYSkuZ2V0UHJvcGVydHlWYWx1ZShiKSk/YS50cmltKCk6XCJcIn0sbmF0aXZlQ3NzOmgsbmF0aXZlU2hhZG93OmN9KTt3aW5kb3cuU2hhZHlDU1MuQ3VzdG9tU3R5bGVJbnRlcmZhY2U9djt9KS5jYWxsKHRoaXMpO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jdXN0b20tc3R5bGUtaW50ZXJmYWNlLm1pbi5qcy5tYXBcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvc2hhZHljc3MvY3VzdG9tLXN0eWxlLWludGVyZmFjZS5taW4uanMiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi9taXhpbnMvbXV0YWJsZS1kYXRhLmh0bWxcIj5cblxuPHNjcmlwdD5cbihmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIGxldCBtdXRhYmxlUHJvcGVydHlDaGFuZ2U7XG4gIChcbiAgICAvKiogQHN1cHByZXNzIHttaXNzaW5nUHJvcGVydGllc30gKi9cbiAgICBmdW5jdGlvbigpIHtcbiAgICBtdXRhYmxlUHJvcGVydHlDaGFuZ2UgPSBQb2x5bWVyLk11dGFibGVEYXRhLl9tdXRhYmxlUHJvcGVydHlDaGFuZ2U7XG4gIH0pKCk7XG5cbiAgLyoqXG4gICAqIExlZ2FjeSBlbGVtZW50IGJlaGF2aW9yIHRvIHNraXAgc3RyaWN0IGRpcnR5LWNoZWNraW5nIGZvciBvYmplY3RzIGFuZCBhcnJheXMsXG4gICAqIChhbHdheXMgY29uc2lkZXIgdGhlbSB0byBiZSBcImRpcnR5XCIpIGZvciB1c2Ugb24gbGVnYWN5IEFQSSBQb2x5bWVyIGVsZW1lbnRzLlxuICAgKlxuICAgKiBCeSBkZWZhdWx0LCBgUG9seW1lci5Qcm9wZXJ0eUVmZmVjdHNgIHBlcmZvcm1zIHN0cmljdCBkaXJ0eSBjaGVja2luZyBvblxuICAgKiBvYmplY3RzLCB3aGljaCBtZWFucyB0aGF0IGFueSBkZWVwIG1vZGlmaWNhdGlvbnMgdG8gYW4gb2JqZWN0IG9yIGFycmF5IHdpbGxcbiAgICogbm90IGJlIHByb3BhZ2F0ZWQgdW5sZXNzIFwiaW1tdXRhYmxlXCIgZGF0YSBwYXR0ZXJucyBhcmUgdXNlZCAoaS5lLiBhbGwgb2JqZWN0XG4gICAqIHJlZmVyZW5jZXMgZnJvbSB0aGUgcm9vdCB0byB0aGUgbXV0YXRpb24gd2VyZSBjaGFuZ2VkKS5cbiAgICpcbiAgICogUG9seW1lciBhbHNvIHByb3ZpZGVzIGEgcHJvcHJpZXRhcnkgZGF0YSBtdXRhdGlvbiBhbmQgcGF0aCBub3RpZmljYXRpb24gQVBJXG4gICAqIChlLmcuIGBub3RpZnlQYXRoYCwgYHNldGAsIGFuZCBhcnJheSBtdXRhdGlvbiBBUEkncykgdGhhdCBhbGxvdyBlZmZpY2llbnRcbiAgICogbXV0YXRpb24gYW5kIG5vdGlmaWNhdGlvbiBvZiBkZWVwIGNoYW5nZXMgaW4gYW4gb2JqZWN0IGdyYXBoIHRvIGFsbCBlbGVtZW50c1xuICAgKiBib3VuZCB0byB0aGUgc2FtZSBvYmplY3QgZ3JhcGguXG4gICAqXG4gICAqIEluIGNhc2VzIHdoZXJlIG5laXRoZXIgaW1tdXRhYmxlIHBhdHRlcm5zIG5vciB0aGUgZGF0YSBtdXRhdGlvbiBBUEkgY2FuIGJlXG4gICAqIHVzZWQsIGFwcGx5aW5nIHRoaXMgbWl4aW4gd2lsbCBjYXVzZSBQb2x5bWVyIHRvIHNraXAgZGlydHkgY2hlY2tpbmcgZm9yXG4gICAqIG9iamVjdHMgYW5kIGFycmF5cyAoYWx3YXlzIGNvbnNpZGVyIHRoZW0gdG8gYmUgXCJkaXJ0eVwiKS4gIFRoaXMgYWxsb3dzIGFcbiAgICogdXNlciB0byBtYWtlIGEgZGVlcCBtb2RpZmljYXRpb24gdG8gYSBib3VuZCBvYmplY3QgZ3JhcGgsIGFuZCB0aGVuIGVpdGhlclxuICAgKiBzaW1wbHkgcmUtc2V0IHRoZSBvYmplY3QgKGUuZy4gYHRoaXMuaXRlbXMgPSB0aGlzLml0ZW1zYCkgb3IgY2FsbCBgbm90aWZ5UGF0aGBcbiAgICogKGUuZy4gYHRoaXMubm90aWZ5UGF0aCgnaXRlbXMnKWApIHRvIHVwZGF0ZSB0aGUgdHJlZS4gIE5vdGUgdGhhdCBhbGxcbiAgICogZWxlbWVudHMgdGhhdCB3aXNoIHRvIGJlIHVwZGF0ZWQgYmFzZWQgb24gZGVlcCBtdXRhdGlvbnMgbXVzdCBhcHBseSB0aGlzXG4gICAqIG1peGluIG9yIG90aGVyd2lzZSBza2lwIHN0cmljdCBkaXJ0eSBjaGVja2luZyBmb3Igb2JqZWN0cy9hcnJheXMuXG4gICAqXG4gICAqIEluIG9yZGVyIHRvIG1ha2UgdGhlIGRpcnR5IGNoZWNrIHN0cmF0ZWd5IGNvbmZpZ3VyYWJsZSwgc2VlXG4gICAqIGBQb2x5bWVyLk9wdGlvbmFsTXV0YWJsZURhdGFCZWhhdmlvcmAuXG4gICAqXG4gICAqIE5vdGUsIHRoZSBwZXJmb3JtYW5jZSBjaGFyYWN0ZXJpc3RpY3Mgb2YgcHJvcGFnYXRpbmcgbGFyZ2Ugb2JqZWN0IGdyYXBoc1xuICAgKiB3aWxsIGJlIHdvcnNlIGFzIG9wcG9zZWQgdG8gdXNpbmcgc3RyaWN0IGRpcnR5IGNoZWNraW5nIHdpdGggaW1tdXRhYmxlXG4gICAqIHBhdHRlcm5zIG9yIFBvbHltZXIncyBwYXRoIG5vdGlmaWNhdGlvbiBBUEkuXG4gICAqXG4gICAqIEBwb2x5bWVyQmVoYXZpb3JcbiAgICogQG1lbWJlcm9mIFBvbHltZXJcbiAgICogQHN1bW1hcnkgQmVoYXZpb3IgdG8gc2tpcCBzdHJpY3QgZGlydHktY2hlY2tpbmcgZm9yIG9iamVjdHMgYW5kXG4gICAqICAgYXJyYXlzXG4gICAqL1xuICBQb2x5bWVyLk11dGFibGVEYXRhQmVoYXZpb3IgPSB7XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZXMgYFBvbHltZXIuUHJvcGVydHlFZmZlY3RzYCB0byBwcm92aWRlIG9wdGlvbiBmb3Igc2tpcHBpbmdcbiAgICAgKiBzdHJpY3QgZXF1YWxpdHkgY2hlY2tpbmcgZm9yIE9iamVjdHMgYW5kIEFycmF5cy5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIHB1bGxzIHRoZSB2YWx1ZSB0byBkaXJ0eSBjaGVjayBhZ2FpbnN0IGZyb20gdGhlIGBfX2RhdGFUZW1wYFxuICAgICAqIGNhY2hlIChyYXRoZXIgdGhhbiB0aGUgbm9ybWFsIGBfX2RhdGFgIGNhY2hlKSBmb3IgT2JqZWN0cy4gIFNpbmNlIHRoZSB0ZW1wXG4gICAgICogY2FjaGUgaXMgY2xlYXJlZCBhdCB0aGUgZW5kIG9mIGEgdHVybiwgdGhpcyBpbXBsZW1lbnRhdGlvbiBhbGxvd3NcbiAgICAgKiBzaWRlLWVmZmVjdHMgb2YgZGVlcCBvYmplY3QgY2hhbmdlcyB0byBiZSBwcm9jZXNzZWQgYnkgcmUtc2V0dGluZyB0aGVcbiAgICAgKiBzYW1lIG9iamVjdCAodXNpbmcgdGhlIHRlbXAgY2FjaGUgYXMgYW4gaW4tdHVybiBiYWNrc3RvcCB0byBwcmV2ZW50XG4gICAgICogY3ljbGVzIGR1ZSB0byAyLXdheSBub3RpZmljYXRpb24pLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IG5hbWVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIE5ldyBwcm9wZXJ0eSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Kn0gb2xkIFByZXZpb3VzIHByb3BlcnR5IHZhbHVlXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgcHJvcGVydHkgc2hvdWxkIGJlIGNvbnNpZGVyZWQgYSBjaGFuZ2VcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX3Nob3VsZFByb3BlcnR5Q2hhbmdlKHByb3BlcnR5LCB2YWx1ZSwgb2xkKSB7XG4gICAgICByZXR1cm4gbXV0YWJsZVByb3BlcnR5Q2hhbmdlKHRoaXMsIHByb3BlcnR5LCB2YWx1ZSwgb2xkLCB0cnVlKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIExlZ2FjeSBlbGVtZW50IGJlaGF2aW9yIHRvIGFkZCB0aGUgb3B0aW9uYWwgYWJpbGl0eSB0byBza2lwIHN0cmljdFxuICAgKiBkaXJ0eS1jaGVja2luZyBmb3Igb2JqZWN0cyBhbmQgYXJyYXlzIChhbHdheXMgY29uc2lkZXIgdGhlbSB0byBiZVxuICAgKiBcImRpcnR5XCIpIGJ5IHNldHRpbmcgYSBgbXV0YWJsZS1kYXRhYCBhdHRyaWJ1dGUgb24gYW4gZWxlbWVudCBpbnN0YW5jZS5cbiAgICpcbiAgICogQnkgZGVmYXVsdCwgYFBvbHltZXIuUHJvcGVydHlFZmZlY3RzYCBwZXJmb3JtcyBzdHJpY3QgZGlydHkgY2hlY2tpbmcgb25cbiAgICogb2JqZWN0cywgd2hpY2ggbWVhbnMgdGhhdCBhbnkgZGVlcCBtb2RpZmljYXRpb25zIHRvIGFuIG9iamVjdCBvciBhcnJheSB3aWxsXG4gICAqIG5vdCBiZSBwcm9wYWdhdGVkIHVubGVzcyBcImltbXV0YWJsZVwiIGRhdGEgcGF0dGVybnMgYXJlIHVzZWQgKGkuZS4gYWxsIG9iamVjdFxuICAgKiByZWZlcmVuY2VzIGZyb20gdGhlIHJvb3QgdG8gdGhlIG11dGF0aW9uIHdlcmUgY2hhbmdlZCkuXG4gICAqXG4gICAqIFBvbHltZXIgYWxzbyBwcm92aWRlcyBhIHByb3ByaWV0YXJ5IGRhdGEgbXV0YXRpb24gYW5kIHBhdGggbm90aWZpY2F0aW9uIEFQSVxuICAgKiAoZS5nLiBgbm90aWZ5UGF0aGAsIGBzZXRgLCBhbmQgYXJyYXkgbXV0YXRpb24gQVBJJ3MpIHRoYXQgYWxsb3cgZWZmaWNpZW50XG4gICAqIG11dGF0aW9uIGFuZCBub3RpZmljYXRpb24gb2YgZGVlcCBjaGFuZ2VzIGluIGFuIG9iamVjdCBncmFwaCB0byBhbGwgZWxlbWVudHNcbiAgICogYm91bmQgdG8gdGhlIHNhbWUgb2JqZWN0IGdyYXBoLlxuICAgKlxuICAgKiBJbiBjYXNlcyB3aGVyZSBuZWl0aGVyIGltbXV0YWJsZSBwYXR0ZXJucyBub3IgdGhlIGRhdGEgbXV0YXRpb24gQVBJIGNhbiBiZVxuICAgKiB1c2VkLCBhcHBseWluZyB0aGlzIG1peGluIHdpbGwgYWxsb3cgUG9seW1lciB0byBza2lwIGRpcnR5IGNoZWNraW5nIGZvclxuICAgKiBvYmplY3RzIGFuZCBhcnJheXMgKGFsd2F5cyBjb25zaWRlciB0aGVtIHRvIGJlIFwiZGlydHlcIikuICBUaGlzIGFsbG93cyBhXG4gICAqIHVzZXIgdG8gbWFrZSBhIGRlZXAgbW9kaWZpY2F0aW9uIHRvIGEgYm91bmQgb2JqZWN0IGdyYXBoLCBhbmQgdGhlbiBlaXRoZXJcbiAgICogc2ltcGx5IHJlLXNldCB0aGUgb2JqZWN0IChlLmcuIGB0aGlzLml0ZW1zID0gdGhpcy5pdGVtc2ApIG9yIGNhbGwgYG5vdGlmeVBhdGhgXG4gICAqIChlLmcuIGB0aGlzLm5vdGlmeVBhdGgoJ2l0ZW1zJylgKSB0byB1cGRhdGUgdGhlIHRyZWUuICBOb3RlIHRoYXQgYWxsXG4gICAqIGVsZW1lbnRzIHRoYXQgd2lzaCB0byBiZSB1cGRhdGVkIGJhc2VkIG9uIGRlZXAgbXV0YXRpb25zIG11c3QgYXBwbHkgdGhpc1xuICAgKiBtaXhpbiBvciBvdGhlcndpc2Ugc2tpcCBzdHJpY3QgZGlydHkgY2hlY2tpbmcgZm9yIG9iamVjdHMvYXJyYXlzLlxuICAgKlxuICAgKiBXaGlsZSB0aGlzIGJlaGF2aW9yIGFkZHMgdGhlIGFiaWxpdHkgdG8gZm9yZ28gT2JqZWN0L0FycmF5IGRpcnR5IGNoZWNraW5nLFxuICAgKiB0aGUgYG11dGFibGVEYXRhYCBmbGFnIGRlZmF1bHRzIHRvIGZhbHNlIGFuZCBtdXN0IGJlIHNldCBvbiB0aGUgaW5zdGFuY2UuXG4gICAqXG4gICAqIE5vdGUsIHRoZSBwZXJmb3JtYW5jZSBjaGFyYWN0ZXJpc3RpY3Mgb2YgcHJvcGFnYXRpbmcgbGFyZ2Ugb2JqZWN0IGdyYXBoc1xuICAgKiB3aWxsIGJlIHdvcnNlIGJ5IHJlbHlpbmcgb24gYG11dGFibGVEYXRhOiB0cnVlYCBhcyBvcHBvc2VkIHRvIHVzaW5nXG4gICAqIHN0cmljdCBkaXJ0eSBjaGVja2luZyB3aXRoIGltbXV0YWJsZSBwYXR0ZXJucyBvciBQb2x5bWVyJ3MgcGF0aCBub3RpZmljYXRpb25cbiAgICogQVBJLlxuICAgKlxuICAgKiBAcG9seW1lckJlaGF2aW9yXG4gICAqIEBtZW1iZXJvZiBQb2x5bWVyXG4gICAqIEBzdW1tYXJ5IEJlaGF2aW9yIHRvIG9wdGlvbmFsbHkgc2tpcCBzdHJpY3QgZGlydHktY2hlY2tpbmcgZm9yIG9iamVjdHMgYW5kXG4gICAqICAgYXJyYXlzXG4gICAqL1xuICBQb2x5bWVyLk9wdGlvbmFsTXV0YWJsZURhdGFCZWhhdmlvciA9IHtcblxuICAgIHByb3BlcnRpZXM6IHtcbiAgICAgIC8qKlxuICAgICAgICogSW5zdGFuY2UtbGV2ZWwgZmxhZyBmb3IgY29uZmlndXJpbmcgdGhlIGRpcnR5LWNoZWNraW5nIHN0cmF0ZWd5XG4gICAgICAgKiBmb3IgdGhpcyBlbGVtZW50LiAgV2hlbiB0cnVlLCBPYmplY3RzIGFuZCBBcnJheXMgd2lsbCBza2lwIGRpcnR5XG4gICAgICAgKiBjaGVja2luZywgb3RoZXJ3aXNlIHN0cmljdCBlcXVhbGl0eSBjaGVja2luZyB3aWxsIGJlIHVzZWQuXG4gICAgICAgKi9cbiAgICAgIG11dGFibGVEYXRhOiBCb29sZWFuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlcyBgUG9seW1lci5Qcm9wZXJ0eUVmZmVjdHNgIHRvIHNraXAgc3RyaWN0IGVxdWFsaXR5IGNoZWNraW5nXG4gICAgICogZm9yIE9iamVjdHMgYW5kIEFycmF5cy5cbiAgICAgKlxuICAgICAqIFB1bGxzIHRoZSB2YWx1ZSB0byBkaXJ0eSBjaGVjayBhZ2FpbnN0IGZyb20gdGhlIGBfX2RhdGFUZW1wYCBjYWNoZVxuICAgICAqIChyYXRoZXIgdGhhbiB0aGUgbm9ybWFsIGBfX2RhdGFgIGNhY2hlKSBmb3IgT2JqZWN0cy4gIFNpbmNlIHRoZSB0ZW1wXG4gICAgICogY2FjaGUgaXMgY2xlYXJlZCBhdCB0aGUgZW5kIG9mIGEgdHVybiwgdGhpcyBpbXBsZW1lbnRhdGlvbiBhbGxvd3NcbiAgICAgKiBzaWRlLWVmZmVjdHMgb2YgZGVlcCBvYmplY3QgY2hhbmdlcyB0byBiZSBwcm9jZXNzZWQgYnkgcmUtc2V0dGluZyB0aGVcbiAgICAgKiBzYW1lIG9iamVjdCAodXNpbmcgdGhlIHRlbXAgY2FjaGUgYXMgYW4gaW4tdHVybiBiYWNrc3RvcCB0byBwcmV2ZW50XG4gICAgICogY3ljbGVzIGR1ZSB0byAyLXdheSBub3RpZmljYXRpb24pLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IG5hbWVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIE5ldyBwcm9wZXJ0eSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Kn0gb2xkIFByZXZpb3VzIHByb3BlcnR5IHZhbHVlXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgcHJvcGVydHkgc2hvdWxkIGJlIGNvbnNpZGVyZWQgYSBjaGFuZ2VcbiAgICAgKiBAdGhpcyB7dGhpc31cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX3Nob3VsZFByb3BlcnR5Q2hhbmdlKHByb3BlcnR5LCB2YWx1ZSwgb2xkKSB7XG4gICAgICByZXR1cm4gbXV0YWJsZVByb3BlcnR5Q2hhbmdlKHRoaXMsIHByb3BlcnR5LCB2YWx1ZSwgb2xkLCB0aGlzLm11dGFibGVEYXRhKTtcbiAgICB9XG4gIH07XG5cbn0pKCk7XG5cbjwvc2NyaXB0PlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi9sZWdhY3kvbXV0YWJsZS1kYXRhLWJlaGF2aW9yLmh0bWwiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE1IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi8uLi9wb2x5bWVyL3BvbHltZXIuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uLy4uL2lyb24tbWVkaWEtcXVlcnkvaXJvbi1tZWRpYS1xdWVyeS5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vYXBwLWxheW91dC1iZWhhdmlvci9hcHAtbGF5b3V0LWJlaGF2aW9yLmh0bWxcIj5cblxuPCEtLVxuYXBwLWRyYXdlci1sYXlvdXQgaXMgYSB3cmFwcGVyIGVsZW1lbnQgdGhhdCBwb3NpdGlvbnMgYW4gYXBwLWRyYXdlciBhbmQgb3RoZXIgY29udGVudC4gV2hlblxudGhlIHZpZXdwb3J0IHdpZHRoIGlzIHNtYWxsZXIgdGhhbiBgcmVzcG9uc2l2ZVdpZHRoYCwgdGhpcyBlbGVtZW50IGNoYW5nZXMgdG8gbmFycm93IGxheW91dC5cbkluIG5hcnJvdyBsYXlvdXQsIHRoZSBkcmF3ZXIgd2lsbCBiZSBzdGFja2VkIG9uIHRvcCBvZiB0aGUgbWFpbiBjb250ZW50LiBUaGUgZHJhd2VyIHdpbGwgc2xpZGVcbmluL291dCB0byBoaWRlL3JldmVhbCB0aGUgbWFpbiBjb250ZW50LlxuXG5CeSBkZWZhdWx0IHRoZSBkcmF3ZXIgaXMgYWxpZ25lZCB0byB0aGUgc3RhcnQsIHdoaWNoIGlzIGxlZnQgaW4gTFRSIGxheW91dHM6XG5cbmBgYGh0bWxcbjxhcHAtZHJhd2VyLWxheW91dD5cbiAgPGFwcC1kcmF3ZXIgc2xvdD1cImRyYXdlclwiPlxuICAgIGRyYXdlciBjb250ZW50XG4gIDwvYXBwLWRyYXdlcj5cbiAgPGRpdj5cbiAgICBtYWluIGNvbnRlbnRcbiAgPC9kaXY+XG48L2FwcC1kcmF3ZXItbGF5b3V0PlxuYGBgXG5cbkFsaWduIHRoZSBkcmF3ZXIgYXQgdGhlIGVuZDpcblxuYGBgaHRtbFxuPGFwcC1kcmF3ZXItbGF5b3V0PlxuICA8YXBwLWRyYXdlciBzbG90PVwiZHJhd2VyXCIgYWxpZ249XCJlbmRcIj5cbiAgICAgZHJhd2VyIGNvbnRlbnRcbiAgPC9hcHAtZHJhd2VyPlxuICA8ZGl2PlxuICAgIG1haW4gY29udGVudFxuICA8L2Rpdj5cbjwvYXBwLWRyYXdlci1sYXlvdXQ+XG5gYGBcblxuV2l0aCBhbiBhcHAtaGVhZGVyLWxheW91dDpcblxuYGBgaHRtbFxuPGFwcC1kcmF3ZXItbGF5b3V0PlxuICA8YXBwLWRyYXdlciBzbG90PVwiZHJhd2VyXCI+XG4gICAgZHJhd2VyLWNvbnRlbnRcbiAgPC9hcHAtZHJhd2VyPlxuICA8YXBwLWhlYWRlci1sYXlvdXQ+XG4gICAgPGFwcC1oZWFkZXIgc2xvdD1cImhlYWRlclwiPlxuICAgICAgPGFwcC10b29sYmFyPlxuICAgICAgICA8ZGl2IG1haW4tdGl0bGU+QXBwIG5hbWU8L2Rpdj5cbiAgICAgIDwvYXBwLXRvb2xiYXI+XG4gICAgPC9hcHAtaGVhZGVyPlxuXG4gICAgbWFpbiBjb250ZW50XG5cbiAgPC9hcHAtaGVhZGVyLWxheW91dD5cbjwvYXBwLWRyYXdlci1sYXlvdXQ+XG5gYGBcblxuQWRkIHRoZSBgZHJhd2VyLXRvZ2dsZWAgYXR0cmlidXRlIHRvIGVsZW1lbnRzIGluc2lkZSBgYXBwLWRyYXdlci1sYXlvdXRgIHRoYXQgdG9nZ2xlIHRoZSBkcmF3ZXIgb24gY2xpY2sgZXZlbnRzOlxuXG5gYGBodG1sXG48YXBwLWRyYXdlci1sYXlvdXQ+XG4gIDxhcHAtZHJhd2VyIHNsb3Q9XCJkcmF3ZXJcIj5cbiAgICBkcmF3ZXItY29udGVudFxuICA8L2FwcC1kcmF3ZXI+XG4gIDxhcHAtaGVhZGVyLWxheW91dD5cbiAgICA8YXBwLWhlYWRlciBzbG90PVwiaGVhZGVyXCI+XG4gICAgICA8YXBwLXRvb2xiYXI+XG4gICAgICAgIDxwYXBlci1pY29uLWJ1dHRvbiBpY29uPVwibWVudVwiIGRyYXdlci10b2dnbGU+PC9wYXBlci1pY29uLWJ1dHRvbj5cbiAgICAgICAgPGRpdiBtYWluLXRpdGxlPkFwcCBuYW1lPC9kaXY+XG4gICAgICA8L2FwcC10b29sYmFyPlxuICAgIDwvYXBwLWhlYWRlcj5cblxuICAgIG1haW4gY29udGVudFxuXG4gIDwvYXBwLWhlYWRlci1sYXlvdXQ+XG48L2FwcC1kcmF3ZXItbGF5b3V0PlxuYGBgXG5cbioqTk9URToqKiBXaXRoIGFwcC1sYXlvdXQgMi4wLCB0aGUgYGRyYXdlci10b2dnbGVgIGVsZW1lbnQgd2lsbCBub3QgYmUgYXV0b21hdGljYWxseSBoaWRkZW5cbndoZW4gYXBwLWRyYXdlci1sYXlvdXQgaXMgbm90IGluIG5hcnJvdyBsYXlvdXQuIFRvIGFkZCB0aGlzLCBhZGQgdGhlIGZvbGxvd2luZyBDU1MgcnVsZSB3aGVyZVxuYXBwLWRyYXdlci1sYXlvdXQgaXMgdXNlZDpcblxuYGBgY3NzXG5hcHAtZHJhd2VyLWxheW91dDpub3QoW25hcnJvd10pIFtkcmF3ZXItdG9nZ2xlXSB7XG4gIGRpc3BsYXk6IG5vbmU7XG59XG5gYGBcblxuQWRkIHRoZSBgZnVsbGJsZWVkYCBhdHRyaWJ1dGUgdG8gYXBwLWRyYXdlci1sYXlvdXQgdG8gbWFrZSBpdCBmaXQgdGhlIHNpemUgb2YgaXRzIGNvbnRhaW5lcjpcblxuYGBgaHRtbFxuPGFwcC1kcmF3ZXItbGF5b3V0IGZ1bGxibGVlZD5cbiAgPGFwcC1kcmF3ZXIgc2xvdD1cImRyYXdlclwiPlxuICAgICBkcmF3ZXIgY29udGVudFxuICA8L2FwcC1kcmF3ZXI+XG4gIDxkaXY+XG4gICAgbWFpbiBjb250ZW50XG4gIDwvZGl2PlxuPC9hcHAtZHJhd2VyLWxheW91dD5cbmBgYFxuXG4jIyMgU3R5bGluZ1xuXG5DdXN0b20gcHJvcGVydHkgICAgICAgICAgICAgICAgICAgICAgICAgIHwgRGVzY3JpcHRpb24gICAgICAgICAgICAgICAgICAgICAgICAgIHwgRGVmYXVsdFxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18LS0tLS0tLS0tXG5gLS1hcHAtZHJhd2VyLXdpZHRoYCAgICAgICAgICAgICAgICAgICAgIHwgV2lkdGggb2YgdGhlIGRyYXdlciAgICAgICAgICAgICAgICAgIHwgMjU2cHhcbmAtLWFwcC1kcmF3ZXItbGF5b3V0LWNvbnRlbnQtdHJhbnNpdGlvbmAgfCBUcmFuc2l0aW9uIGZvciB0aGUgY29udGVudCBjb250YWluZXIgfCBub25lXG5cbioqTk9URToqKiBJZiB5b3UgdXNlIDxhcHAtZHJhd2VyPiB3aXRoIDxhcHAtZHJhd2VyLWxheW91dD4gYW5kIHNwZWNpZnkgYSB2YWx1ZSBmb3JcbmAtLWFwcC1kcmF3ZXItd2lkdGhgLCB0aGF0IHZhbHVlIG11c3QgYmUgYWNjZXNzaWJsZSBieSBib3RoIGVsZW1lbnRzLiBUaGlzIGNhbiBiZSBkb25lIGJ5XG5kZWZpbmluZyB0aGUgdmFsdWUgb24gdGhlIGA6aG9zdGAgdGhhdCBjb250YWlucyA8YXBwLWRyYXdlci1sYXlvdXQ+IChvciBgaHRtbGAgaWYgb3V0c2lkZVxuYSBzaGFkb3cgcm9vdCk6XG5cbmBgYGNzc1xuOmhvc3Qge1xuICAtLWFwcC1kcmF3ZXItd2lkdGg6IDMwMHB4O1xufVxuYGBgXG5cbkBncm91cCBBcHAgRWxlbWVudHNcbkBlbGVtZW50IGFwcC1kcmF3ZXItbGF5b3V0XG5AZGVtbyBhcHAtZHJhd2VyLWxheW91dC9kZW1vL2luZGV4Lmh0bWxcbi0tPlxuXG48ZG9tLW1vZHVsZSBpZD1cImFwcC1kcmF3ZXItbGF5b3V0XCI+XG4gIDx0ZW1wbGF0ZT5cbiAgICA8c3R5bGU+XG4gICAgICA6aG9zdCB7XG4gICAgICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgICAgICAvKipcbiAgICAgICAgICogRm9yY2UgYXBwLWRyYXdlci1sYXlvdXQgdG8gaGF2ZSBpdHMgb3duIHN0YWNraW5nIGNvbnRleHQgc28gdGhhdCBpdHMgcGFyZW50IGNhblxuICAgICAgICAgKiBjb250cm9sIHRoZSBzdGFja2luZyBvZiBpdCByZWxhdGl2ZSB0byBvdGhlciBlbGVtZW50cy5cbiAgICAgICAgICovXG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgei1pbmRleDogMDtcbiAgICAgIH1cblxuICAgICAgOmhvc3QgOjpzbG90dGVkKFtzbG90PWRyYXdlcl0pIHtcbiAgICAgICAgei1pbmRleDogMTtcbiAgICAgIH1cblxuICAgICAgOmhvc3QoW2Z1bGxibGVlZF0pIHtcbiAgICAgICAgQGFwcGx5IC0tbGF5b3V0LWZpdDtcbiAgICAgIH1cblxuICAgICAgI2NvbnRlbnRDb250YWluZXIge1xuICAgICAgICAvKiBDcmVhdGUgYSBzdGFja2luZyBjb250ZXh0IGhlcmUgc28gdGhhdCBhbGwgY2hpbGRyZW4gYXBwZWFyIGJlbG93IHRoZSBoZWFkZXIuICovXG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgei1pbmRleDogMDtcbiAgICAgICAgaGVpZ2h0OiAxMDAlO1xuICAgICAgICB0cmFuc2l0aW9uOiB2YXIoLS1hcHAtZHJhd2VyLWxheW91dC1jb250ZW50LXRyYW5zaXRpb24sIG5vbmUpO1xuICAgICAgfVxuXG4gICAgICAjY29udGVudENvbnRhaW5lcltkcmF3ZXItcG9zaXRpb249bGVmdF0ge1xuICAgICAgICBtYXJnaW4tbGVmdDogdmFyKC0tYXBwLWRyYXdlci13aWR0aCwgMjU2cHgpO1xuICAgICAgfVxuXG4gICAgICAjY29udGVudENvbnRhaW5lcltkcmF3ZXItcG9zaXRpb249cmlnaHRdIHtcbiAgICAgICAgbWFyZ2luLXJpZ2h0OiB2YXIoLS1hcHAtZHJhd2VyLXdpZHRoLCAyNTZweCk7XG4gICAgICB9XG4gICAgPC9zdHlsZT5cblxuICAgIDxzbG90IGlkPVwiZHJhd2VyU2xvdFwiIG5hbWU9XCJkcmF3ZXJcIj48L3Nsb3Q+XG5cbiAgICA8ZGl2IGlkPVwiY29udGVudENvbnRhaW5lclwiIGRyYXdlci1wb3NpdGlvbiQ9XCJbW19kcmF3ZXJQb3NpdGlvbl1dXCI+XG4gICAgICA8c2xvdD48L3Nsb3Q+XG4gICAgPC9kaXY+XG5cbiAgICA8aXJvbi1tZWRpYS1xdWVyeVxuICAgICAgICBxdWVyeT1cIltbX2NvbXB1dGVNZWRpYVF1ZXJ5KGZvcmNlTmFycm93LCByZXNwb25zaXZlV2lkdGgpXV1cIlxuICAgICAgICBvbi1xdWVyeS1tYXRjaGVzLWNoYW5nZWQ9XCJfb25RdWVyeU1hdGNoZXNDaGFuZ2VkXCI+PC9pcm9uLW1lZGlhLXF1ZXJ5PlxuICA8L3RlbXBsYXRlPlxuXG4gIDxzY3JpcHQ+XG4gICAgUG9seW1lcih7XG4gICAgICBpczogJ2FwcC1kcmF3ZXItbGF5b3V0JyxcblxuICAgICAgYmVoYXZpb3JzOiBbXG4gICAgICAgIFBvbHltZXIuQXBwTGF5b3V0QmVoYXZpb3JcbiAgICAgIF0sXG5cbiAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHRydWUsIGlnbm9yZSBgcmVzcG9uc2l2ZVdpZHRoYCBzZXR0aW5nIGFuZCBmb3JjZSB0aGUgbmFycm93IGxheW91dC5cbiAgICAgICAgICovXG4gICAgICAgIGZvcmNlTmFycm93OiB7XG4gICAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgdGhlIHZpZXdwb3J0J3Mgd2lkdGggaXMgc21hbGxlciB0aGFuIHRoaXMgdmFsdWUsIHRoZSBwYW5lbCB3aWxsIGNoYW5nZSB0byBuYXJyb3dcbiAgICAgICAgICogbGF5b3V0LiBJbiB0aGUgbW9kZSB0aGUgZHJhd2VyIHdpbGwgYmUgY2xvc2VkLlxuICAgICAgICAgKi9cbiAgICAgICAgcmVzcG9uc2l2ZVdpZHRoOiB7XG4gICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgIHZhbHVlOiAnNjQwcHgnXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdHJ1ZSBpZiBpdCBpcyBpbiBuYXJyb3cgbGF5b3V0LiBUaGlzIGlzIHVzZWZ1bCBpZiB5b3UgbmVlZCB0byBzaG93L2hpZGVcbiAgICAgICAgICogZWxlbWVudHMgYmFzZWQgb24gdGhlIGxheW91dC5cbiAgICAgICAgICovXG4gICAgICAgIG5hcnJvdzoge1xuICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgICAgcmVmbGVjdFRvQXR0cmlidXRlOiB0cnVlLFxuICAgICAgICAgIHJlYWRPbmx5OiB0cnVlLFxuICAgICAgICAgIG5vdGlmeTogdHJ1ZVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0cnVlLCB0aGUgZHJhd2VyIHdpbGwgaW5pdGlhbGx5IGJlIG9wZW5lZCB3aGVuIGluIG5hcnJvdyBsYXlvdXQgbW9kZS5cbiAgICAgICAgICovXG4gICAgICAgIG9wZW5lZFdoZW5OYXJyb3c6IHtcbiAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgICB9LFxuXG4gICAgICAgIF9kcmF3ZXJQb3NpdGlvbjoge1xuICAgICAgICAgIHR5cGU6IFN0cmluZ1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBsaXN0ZW5lcnM6IHtcbiAgICAgICAgJ2NsaWNrJzogJ19jbGlja0hhbmRsZXInXG4gICAgICB9LFxuXG4gICAgICBvYnNlcnZlcnM6IFtcbiAgICAgICAgJ19uYXJyb3dDaGFuZ2VkKG5hcnJvdyknXG4gICAgICBdLFxuXG4gICAgICAvKipcbiAgICAgICAqIEEgcmVmZXJlbmNlIHRvIHRoZSBhcHAtZHJhd2VyIGVsZW1lbnQuXG4gICAgICAgKlxuICAgICAgICogQHByb3BlcnR5IGRyYXdlclxuICAgICAgICovXG4gICAgICBnZXQgZHJhd2VyKCkge1xuICAgICAgICByZXR1cm4gUG9seW1lci5kb20odGhpcy4kLmRyYXdlclNsb3QpLmdldERpc3RyaWJ1dGVkTm9kZXMoKVswXTtcbiAgICAgIH0sXG5cbiAgICAgIGF0dGFjaGVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gRGlzYWJsZSBkcmF3ZXIgdHJhbnNpdGlvbnMgdW50aWwgYWZ0ZXIgYXBwLWRyYXdlci1sYXlvdXQgc2V0cyB0aGUgaW5pdGlhbCBvcGVuZWQgc3RhdGUuXG4gICAgICAgIHZhciBkcmF3ZXIgPSB0aGlzLmRyYXdlcjtcbiAgICAgICAgaWYgKGRyYXdlcikge1xuICAgICAgICAgIGRyYXdlci5zZXRBdHRyaWJ1dGUoJ25vLXRyYW5zaXRpb24nLCAnJyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIF9jbGlja0hhbmRsZXI6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdmFyIHRhcmdldCA9IFBvbHltZXIuZG9tKGUpLmxvY2FsVGFyZ2V0O1xuICAgICAgICBpZiAodGFyZ2V0ICYmIHRhcmdldC5oYXNBdHRyaWJ1dGUoJ2RyYXdlci10b2dnbGUnKSkge1xuICAgICAgICAgIHZhciBkcmF3ZXIgPSB0aGlzLmRyYXdlcjtcbiAgICAgICAgICBpZiAoZHJhd2VyICYmICFkcmF3ZXIucGVyc2lzdGVudCkge1xuICAgICAgICAgICAgZHJhd2VyLnRvZ2dsZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgX3VwZGF0ZUxheW91dFN0YXRlczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBkcmF3ZXIgPSB0aGlzLmRyYXdlcjtcbiAgICAgICAgaWYgKCF0aGlzLmlzQXR0YWNoZWQgfHwgIWRyYXdlcikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2RyYXdlclBvc2l0aW9uID0gdGhpcy5uYXJyb3cgPyBudWxsIDogZHJhd2VyLnBvc2l0aW9uO1xuICAgICAgICBpZiAodGhpcy5fZHJhd2VyTmVlZHNSZXNldCkge1xuICAgICAgICAgIGlmICh0aGlzLm5hcnJvdykge1xuICAgICAgICAgICAgZHJhd2VyLm9wZW5lZCA9IHRoaXMub3BlbmVkV2hlbk5hcnJvdztcbiAgICAgICAgICAgIGRyYXdlci5wZXJzaXN0ZW50ID0gZmFsc2U7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRyYXdlci5vcGVuZWQgPSBkcmF3ZXIucGVyc2lzdGVudCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChkcmF3ZXIuaGFzQXR0cmlidXRlKCduby10cmFuc2l0aW9uJykpIHtcbiAgICAgICAgICAgIC8vIEVuYWJsZSBkcmF3ZXIgdHJhbnNpdGlvbnMgYWZ0ZXIgYXBwLWRyYXdlci1sYXlvdXQgc2V0cyB0aGUgaW5pdGlhbCBvcGVuZWQgc3RhdGUuXG4gICAgICAgICAgICBQb2x5bWVyLlJlbmRlclN0YXR1cy5hZnRlck5leHRSZW5kZXIodGhpcywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIGRyYXdlci5yZW1vdmVBdHRyaWJ1dGUoJ25vLXRyYW5zaXRpb24nKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9kcmF3ZXJOZWVkc1Jlc2V0ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIF9uYXJyb3dDaGFuZ2VkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fZHJhd2VyTmVlZHNSZXNldCA9IHRydWU7XG4gICAgICAgIHRoaXMucmVzZXRMYXlvdXQoKTtcbiAgICAgIH0sXG5cbiAgICAgIF9vblF1ZXJ5TWF0Y2hlc0NoYW5nZWQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuX3NldE5hcnJvdyhldmVudC5kZXRhaWwudmFsdWUpO1xuICAgICAgfSxcblxuICAgICAgX2NvbXB1dGVNZWRpYVF1ZXJ5OiBmdW5jdGlvbihmb3JjZU5hcnJvdywgcmVzcG9uc2l2ZVdpZHRoKSB7XG4gICAgICAgIHJldHVybiBmb3JjZU5hcnJvdyA/ICcobWluLXdpZHRoOiAwcHgpJyA6ICcobWF4LXdpZHRoOiAnICsgcmVzcG9uc2l2ZVdpZHRoICsgJyknO1xuICAgICAgfVxuICAgIH0pO1xuICA8L3NjcmlwdD5cbjwvZG9tLW1vZHVsZT5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvYXBwLWxheW91dC9hcHAtZHJhd2VyLWxheW91dC9hcHAtZHJhd2VyLWxheW91dC5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNSBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuXG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vcG9seW1lci9wb2x5bWVyLmh0bWxcIj5cblxuPCEtLVxuYGlyb24tbWVkaWEtcXVlcnlgIGNhbiBiZSB1c2VkIHRvIGRhdGEgYmluZCB0byBhIENTUyBtZWRpYSBxdWVyeS5cblRoZSBgcXVlcnlgIHByb3BlcnR5IGlzIGEgYmFyZSBDU1MgbWVkaWEgcXVlcnkuXG5UaGUgYHF1ZXJ5LW1hdGNoZXNgIHByb3BlcnR5IGlzIGEgYm9vbGVhbiByZXByZXNlbnRpbmcgd2hldGhlciB0aGUgcGFnZSBtYXRjaGVzIHRoYXQgbWVkaWEgcXVlcnkuXG5cbkV4YW1wbGU6XG5cbiAgICA8aXJvbi1tZWRpYS1xdWVyeSBxdWVyeT1cIihtaW4td2lkdGg6IDYwMHB4KVwiIHF1ZXJ5LW1hdGNoZXM9XCJ7e3F1ZXJ5TWF0Y2hlc319XCI+PC9pcm9uLW1lZGlhLXF1ZXJ5PlxuXG5AZ3JvdXAgSXJvbiBFbGVtZW50c1xuQGRlbW8gZGVtby9pbmRleC5odG1sXG5AaGVybyBoZXJvLnN2Z1xuQGVsZW1lbnQgaXJvbi1tZWRpYS1xdWVyeVxuLS0+XG5cbjxzY3JpcHQ+XG5cbiAgUG9seW1lcih7XG5cbiAgICBpczogJ2lyb24tbWVkaWEtcXVlcnknLFxuXG4gICAgcHJvcGVydGllczoge1xuXG4gICAgICAvKipcbiAgICAgICAqIFRoZSBCb29sZWFuIHJldHVybiB2YWx1ZSBvZiB0aGUgbWVkaWEgcXVlcnkuXG4gICAgICAgKi9cbiAgICAgIHF1ZXJ5TWF0Y2hlczoge1xuICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICB2YWx1ZTogZmFsc2UsXG4gICAgICAgIHJlYWRPbmx5OiB0cnVlLFxuICAgICAgICBub3RpZnk6IHRydWVcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogVGhlIENTUyBtZWRpYSBxdWVyeSB0byBldmFsdWF0ZS5cbiAgICAgICAqL1xuICAgICAgcXVlcnk6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICBvYnNlcnZlcjogJ3F1ZXJ5Q2hhbmdlZCdcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogSWYgdHJ1ZSwgdGhlIHF1ZXJ5IGF0dHJpYnV0ZSBpcyBhc3N1bWVkIHRvIGJlIGEgY29tcGxldGUgbWVkaWEgcXVlcnlcbiAgICAgICAqIHN0cmluZyByYXRoZXIgdGhhbiBhIHNpbmdsZSBtZWRpYSBmZWF0dXJlLlxuICAgICAgICovXG4gICAgICBmdWxsOiB7XG4gICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBAdHlwZSB7ZnVuY3Rpb24oTWVkaWFRdWVyeUxpc3QpfVxuICAgICAgICovXG4gICAgICBfYm91bmRNUUhhbmRsZXI6IHtcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnF1ZXJ5SGFuZGxlci5iaW5kKHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIEB0eXBlIHtNZWRpYVF1ZXJ5TGlzdH1cbiAgICAgICAqL1xuICAgICAgX21xOiB7XG4gICAgICAgIHZhbHVlOiBudWxsXG4gICAgICB9XG4gICAgfSxcblxuICAgIGF0dGFjaGVkOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgIHRoaXMucXVlcnlDaGFuZ2VkKCk7XG4gICAgfSxcblxuICAgIGRldGFjaGVkOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX3JlbW92ZSgpO1xuICAgIH0sXG5cbiAgICBfYWRkOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLl9tcSkge1xuICAgICAgICB0aGlzLl9tcS5hZGRMaXN0ZW5lcih0aGlzLl9ib3VuZE1RSGFuZGxlcik7XG4gICAgICB9XG4gICAgfSxcblxuICAgIF9yZW1vdmU6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuX21xKSB7XG4gICAgICAgIHRoaXMuX21xLnJlbW92ZUxpc3RlbmVyKHRoaXMuX2JvdW5kTVFIYW5kbGVyKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX21xID0gbnVsbDtcbiAgICB9LFxuXG4gICAgcXVlcnlDaGFuZ2VkOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX3JlbW92ZSgpO1xuICAgICAgdmFyIHF1ZXJ5ID0gdGhpcy5xdWVyeTtcbiAgICAgIGlmICghcXVlcnkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLmZ1bGwgJiYgcXVlcnlbMF0gIT09ICcoJykge1xuICAgICAgICBxdWVyeSA9ICcoJyArIHF1ZXJ5ICsgJyknO1xuICAgICAgfVxuICAgICAgdGhpcy5fbXEgPSB3aW5kb3cubWF0Y2hNZWRpYShxdWVyeSk7XG4gICAgICB0aGlzLl9hZGQoKTtcbiAgICAgIHRoaXMucXVlcnlIYW5kbGVyKHRoaXMuX21xKTtcbiAgICB9LFxuXG4gICAgcXVlcnlIYW5kbGVyOiBmdW5jdGlvbihtcSkge1xuICAgICAgdGhpcy5fc2V0UXVlcnlNYXRjaGVzKG1xLm1hdGNoZXMpO1xuICAgIH1cblxuICB9KTtcblxuPC9zY3JpcHQ+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL2lyb24tbWVkaWEtcXVlcnkvaXJvbi1tZWRpYS1xdWVyeS5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNSBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuXG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vLi4vcG9seW1lci9wb2x5bWVyLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi8uLi9pcm9uLWZsZXgtbGF5b3V0L2lyb24tZmxleC1sYXlvdXQuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL2FwcC1zY3JvbGwtZWZmZWN0cy9hcHAtc2Nyb2xsLWVmZmVjdHMtYmVoYXZpb3IuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL2FwcC1sYXlvdXQtYmVoYXZpb3IvYXBwLWxheW91dC1iZWhhdmlvci5odG1sXCI+XG5cbjwhLS1cbmFwcC1oZWFkZXIgaXMgY29udGFpbmVyIGVsZW1lbnQgZm9yIGFwcC10b29sYmFycyBhdCB0aGUgdG9wIG9mIHRoZSBzY3JlZW4gdGhhdCBjYW4gaGF2ZSBzY3JvbGxcbmVmZmVjdHMuIEJ5IGRlZmF1bHQsIGFuIGFwcC1oZWFkZXIgbW92ZXMgYXdheSBmcm9tIHRoZSB2aWV3cG9ydCB3aGVuIHNjcm9sbGluZyBkb3duIGFuZFxuaWYgdXNpbmcgYHJldmVhbHNgLCB0aGUgaGVhZGVyIHNsaWRlcyBiYWNrIHdoZW4gc2Nyb2xsaW5nIGJhY2sgdXAuIEZvciBleGFtcGxlOlxuXG5gYGBodG1sXG48YXBwLWhlYWRlciByZXZlYWxzPlxuICA8YXBwLXRvb2xiYXI+XG4gICAgPGRpdiBtYWluLXRpdGxlPkFwcCBuYW1lPC9kaXY+XG4gIDwvYXBwLXRvb2xiYXI+XG48L2FwcC1oZWFkZXI+XG5gYGBcblxuYXBwLWhlYWRlciBjYW4gYWxzbyBjb25kZW5zZSB3aGVuIHNjcm9sbGluZyBkb3duLiBUbyBhY2hpZXZlIHRoaXMgYmVoYXZpb3IsIHRoZSBoZWFkZXJcbm11c3QgaGF2ZSBhIGxhcmdlciBoZWlnaHQgdGhhbiB0aGUgYHN0aWNreWAgZWxlbWVudCBpbiB0aGUgbGlnaHQgRE9NLiBGb3IgZXhhbXBsZTpcblxuYGBgaHRtbFxuPGFwcC1oZWFkZXIgc3R5bGU9XCJoZWlnaHQ6IDk2cHg7XCIgY29uZGVuc2VzIGZpeGVkPlxuICA8YXBwLXRvb2xiYXIgc3R5bGU9XCJoZWlnaHQ6IDY0cHg7XCI+XG4gICAgPGRpdiBtYWluLXRpdGxlPkFwcCBuYW1lPC9kaXY+XG4gIDwvYXBwLXRvb2xiYXI+XG48L2FwcC1oZWFkZXI+XG5gYGBcblxuSW4gdGhpcyBjYXNlIHRoZSBoZWFkZXIgaXMgaW5pdGlhbGx5IGA5NnB4YCB0YWxsLCBhbmQgaXQgc2hyaW5rcyB0byBgNjRweGAgd2hlbiBzY3JvbGxpbmcgZG93bi5cblRoYXQgaXMgd2hhdCBpcyBtZWFudCBieSBcImNvbmRlbnNpbmdcIi5cblxuIyMjIFN0aWNreSBlbGVtZW50XG5cblRoZSBlbGVtZW50IHRoYXQgaXMgcG9zaXRpb25lZCBmaXhlZCB0byB0b3Agb2YgdGhlIGhlYWRlcidzIGBzY3JvbGxUYXJnZXRgIHdoZW4gYSB0aHJlc2hvbGRcbmlzIHJlYWNoZWQsIHNpbWlsYXIgdG8gYHBvc2l0aW9uOiBzdGlja3lgIGluIENTUy4gVGhpcyBlbGVtZW50ICoqbXVzdCoqIGJlIGFuIGltbWVkaWF0ZVxuY2hpbGQgb2YgYXBwLWhlYWRlci4gQnkgZGVmYXVsdCwgdGhlIGBzdGlja3lgIGVsZW1lbnQgaXMgdGhlIGZpcnN0IGBhcHAtdG9vbGJhciB0aGF0XG5pcyBhbiBpbW1lZGlhdGUgY2hpbGQgb2YgYXBwLWhlYWRlci5cblxuYGBgaHRtbFxuPGFwcC1oZWFkZXIgY29uZGVuc2VzPlxuICA8YXBwLXRvb2xiYXI+IFN0aWNreSBlbGVtZW50IDwvYXBwLXRvb2xiYXI+XG48L2FwcC1oZWFkZXI+XG5gYGBcblxuIyMjIyBDdXN0b21pemluZyB0aGUgc3RpY2t5IGVsZW1lbnRcblxuYGBgaHRtbFxuPGFwcC1oZWFkZXIgY29uZGVuc2VzPlxuICA8YXBwLXRvb2xiYXI+PC9hcHAtdG9vbGJhcj5cbiAgPGFwcC10b29sYmFyIHN0aWNreT4gU3RpY2t5IGVsZW1lbnQgPC9hcHAtdG9vbGJhcj5cbjwvYXBwLWhlYWRlcj5cbmBgYFxuXG4jIyMgU2Nyb2xsIHRhcmdldFxuXG5UaGUgYXBwLWhlYWRlcidzIGBzY3JvbGxUYXJnZXRgIHByb3BlcnR5IGFsbG93cyB0byBjdXN0b21pemUgdGhlIHNjcm9sbGFibGUgZWxlbWVudCB0byB3aGljaFxudGhlIGhlYWRlciByZXNwb25kcyB3aGVuIHRoZSB1c2VyIHNjcm9sbHMuIEJ5IGRlZmF1bHQsIGFwcC1oZWFkZXIgdXNlcyB0aGUgZG9jdW1lbnQgYXNcbnRoZSBzY3JvbGwgdGFyZ2V0LCBidXQgeW91IGNhbiBjdXN0b21pemUgdGhpcyBwcm9wZXJ0eSBieSBzZXR0aW5nIHRoZSBpZCBvZiB0aGUgZWxlbWVudCwgZS5nLlxuXG5gYGBodG1sXG48ZGl2IGlkPVwic2Nyb2xsaW5nUmVnaW9uXCIgc3R5bGU9XCJvdmVyZmxvdy15OiBhdXRvO1wiPlxuICA8YXBwLWhlYWRlciBzY3JvbGwtdGFyZ2V0PVwic2Nyb2xsaW5nUmVnaW9uXCI+XG4gIDwvYXBwLWhlYWRlcj5cbjwvZGl2PlxuYGBgXG5cbkluIHRoaXMgY2FzZSwgdGhlIGBzY3JvbGxUYXJnZXRgIHByb3BlcnR5IHBvaW50cyB0byB0aGUgb3V0ZXIgZGl2IGVsZW1lbnQuIEFsdGVybmF0aXZlbHksXG55b3UgY2FuIHNldCB0aGlzIHByb3BlcnR5IHByb2dyYW1tYXRpY2FsbHk6XG5cbmBgYGpzXG5hcHBIZWFkZXIuc2Nyb2xsVGFyZ2V0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNzY3JvbGxpbmdSZWdpb25cIik7XG5gYGBcblxuIyMgQmFja2dyb3VuZHNcbmFwcC1oZWFkZXIgaGFzIHR3byBiYWNrZ3JvdW5kIGxheWVycyB0aGF0IGNhbiBiZSB1c2VkIGZvciBzdHlsaW5nIHdoZW4gdGhlIGhlYWRlciBpcyBjb25kZW5zZWRcbm9yIHdoZW4gdGhlIHNjcm9sbGFibGUgZWxlbWVudCBpcyBzY3JvbGxlZCB0byB0aGUgdG9wLlxuXG4jIyBTY3JvbGwgZWZmZWN0c1xuXG5TY3JvbGwgZWZmZWN0cyBhcmUgX29wdGlvbmFsXyB2aXN1YWwgZWZmZWN0cyBhcHBsaWVkIGluIGFwcC1oZWFkZXIgYmFzZWQgb24gc2Nyb2xsIHBvc2l0aW9uLiBGb3IgZXhhbXBsZSxcblRoZSBbTWF0ZXJpYWwgRGVzaWduIHNjcm9sbGluZyB0ZWNobmlxdWVzXShodHRwczovL3d3dy5nb29nbGUuY29tL2Rlc2lnbi9zcGVjL3BhdHRlcm5zL3Njcm9sbGluZy10ZWNobmlxdWVzLmh0bWwpXG5yZWNvbW1lbmRzIGVmZmVjdHMgdGhhdCBjYW4gYmUgaW5zdGFsbGVkIHZpYSB0aGUgYGVmZmVjdHNgIHByb3BlcnR5LiBlLmcuXG5cbmBgYGh0bWxcbjxhcHAtaGVhZGVyIGVmZmVjdHM9XCJ3YXRlcmZhbGxcIj5cbiAgPGFwcC10b29sYmFyPkFwcCBuYW1lPC9hcHAtdG9vbGJhcj5cbjwvYXBwLWhlYWRlcj5cbmBgYFxuXG4jIyMjIEltcG9ydGluZyB0aGUgZWZmZWN0c1xuXG5UbyB1c2UgdGhlIHNjcm9sbCBlZmZlY3RzLCB5b3UgbXVzdCBleHBsaWNpdGx5IGltcG9ydCB0aGVtIGluIGFkZGl0aW9uIHRvIGBhcHAtaGVhZGVyYDpcblxuYGBgaHRtbFxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi9ib3dlcl9jb21wb25lbnRzL2FwcC1sYXlvdXQvYXBwLXNjcm9sbC1lZmZlY3RzL2FwcC1zY3JvbGwtZWZmZWN0cy5odG1sXCI+XG5gYGBcblxuIyMjIyBMaXN0IG9mIGVmZmVjdHNcblxuKiAqKmJsZW5kLWJhY2tncm91bmQqKlxuRmFkZXMgaW4vb3V0IHR3byBiYWNrZ3JvdW5kIGVsZW1lbnRzIGJ5IGFwcGx5aW5nIENTUyBvcGFjaXR5IGJhc2VkIG9uIHNjcm9sbCBwb3NpdGlvbi5cbllvdSBjYW4gdXNlIHRoaXMgZWZmZWN0IHRvIHNtb290aGx5IGNoYW5nZSB0aGUgYmFja2dyb3VuZCBjb2xvciBvciBpbWFnZSBvZiB0aGUgaGVhZGVyLlxuRm9yIGV4YW1wbGUsIHVzaW5nIHRoZSBtaXhpbiBgLS1hcHAtaGVhZGVyLWJhY2tncm91bmQtcmVhci1sYXllcmAgbGV0cyB5b3UgYXNzaWduIGEgZGlmZmVyZW50XG5iYWNrZ3JvdW5kIHdoZW4gdGhlIGhlYWRlciBpcyBjb25kZW5zZWQ6XG5cbmBgYGNzc1xuYXBwLWhlYWRlciB7XG4gIGJhY2tncm91bmQtY29sb3I6IHJlZDtcbiAgLS1hcHAtaGVhZGVyLWJhY2tncm91bmQtcmVhci1sYXllcjoge1xuICAgIC8qIFRoZSBoZWFkZXIgaXMgYmx1ZSB3aGVuIGNvbmRlbnNlZCAqL1xuICAgIGJhY2tncm91bmQtY29sb3I6IGJsdWU7XG4gIH07XG59XG5gYGBcblxuKiAqKmZhZGUtYmFja2dyb3VuZCoqXG5VcG9uIHNjcm9sbGluZyBwYXN0IGEgdGhyZXNob2xkLCB0aGlzIGVmZmVjdCB3aWxsIHRyaWdnZXIgYW4gb3BhY2l0eSB0cmFuc2l0aW9uIHRvXG5mYWRlIGluL291dCB0aGUgYmFja2dyb3VuZHMuIENvbXBhcmVkIHRvIHRoZSBgYmxlbmQtYmFja2dyb3VuZGAgZWZmZWN0LFxudGhpcyBlZmZlY3QgZG9lc24ndCBpbnRlcnBvbGF0ZSB0aGUgb3BhY2l0eSBiYXNlZCBvbiBzY3JvbGwgcG9zaXRpb24uXG5cblxuKiAqKnBhcmFsbGF4LWJhY2tncm91bmQqKlxuQSBzaW1wbGUgcGFyYWxsYXggZWZmZWN0IHRoYXQgdmVydGljYWxseSB0cmFuc2xhdGVzIHRoZSBiYWNrZ3JvdW5kcyBiYXNlZCBvbiBhIGZyYWN0aW9uXG5vZiB0aGUgc2Nyb2xsIHBvc2l0aW9uLiBGb3IgZXhhbXBsZTpcblxuYGBgY3NzXG5hcHAtaGVhZGVyIHtcbiAgLS1hcHAtaGVhZGVyLWJhY2tncm91bmQtZnJvbnQtbGF5ZXI6IHtcbiAgICBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoLi4uKTtcbiAgfTtcbn1cbmBgYFxuYGBgaHRtbFxuPGFwcC1oZWFkZXIgc3R5bGU9XCJoZWlnaHQ6IDMwMHB4O1wiIGVmZmVjdHM9XCJwYXJhbGxheC1iYWNrZ3JvdW5kXCI+XG4gIDxhcHAtdG9vbGJhcj5BcHAgbmFtZTwvYXBwLXRvb2xiYXI+XG48L2FwcC1oZWFkZXI+XG5gYGBcblxuVGhlIGZyYWN0aW9uIGRldGVybWluZXMgaG93IGZhciB0aGUgYmFja2dyb3VuZCBtb3ZlcyByZWxhdGl2ZSB0byB0aGUgc2Nyb2xsIHBvc2l0aW9uLlxuVGhpcyB2YWx1ZSBjYW4gYmUgYXNzaWduZWQgdmlhIHRoZSBgc2NhbGFyYCBjb25maWcgdmFsdWUgYW5kIGl0IGlzIHR5cGljYWxseSBhIHZhbHVlXG5iZXR3ZWVuIDAgYW5kIDEgaW5jbHVzaXZlLiBJZiBgc2NhbGFyPTBgLCB0aGUgYmFja2dyb3VuZCBkb2Vzbid0IG1vdmUgYXdheSBmcm9tIHRoZSBoZWFkZXIuXG5cbiogKipyZXNpemUtdGl0bGUqKlxuUHJvZ3Jlc3NpdmVseSBpbnRlcnBvbGF0ZXMgdGhlIHNpemUgb2YgdGhlIHRpdGxlIGZyb20gdGhlIGVsZW1lbnQgd2l0aCB0aGUgYG1haW4tdGl0bGVgIGF0dHJpYnV0ZVxudG8gdGhlIGVsZW1lbnQgd2l0aCB0aGUgYGNvbmRlbnNlZC10aXRsZWAgYXR0cmlidXRlIGFzIHRoZSBoZWFkZXIgY29uZGVuc2VzLiBGb3IgZXhhbXBsZTpcblxuYGBgaHRtbFxuPGFwcC1oZWFkZXIgY29uZGVuc2VzIHJldmVhbHMgZWZmZWN0cz1cInJlc2l6ZS10aXRsZVwiPlxuICA8YXBwLXRvb2xiYXI+XG4gICAgICA8aDQgY29uZGVuc2VkLXRpdGxlPkFwcCBuYW1lPC9oND5cbiAgPC9hcHAtdG9vbGJhcj5cbiAgPGFwcC10b29sYmFyPlxuICAgICAgPGgxIG1haW4tdGl0bGU+QXBwIG5hbWU8L2gxPlxuICA8L2FwcC10b29sYmFyPlxuPC9hcHAtaGVhZGVyPlxuYGBgXG5cbiogKipyZXNpemUtc25hcHBlZC10aXRsZSoqXG5VcG9uIHNjcm9sbGluZyBwYXN0IGEgdGhyZXNob2xkLCB0aGlzIGVmZmVjdCBmYWRlcyBpbi9vdXQgdGhlIHRpdGxlcyB1c2luZyBvcGFjaXR5IHRyYW5zaXRpb25zLlxuU2ltaWxhcmx5IHRvIGByZXNpemUtdGl0bGVgLCB0aGUgYG1haW4tdGl0bGVgIGFuZCBgY29uZGVuc2VkLXRpdGxlYCBlbGVtZW50cyBtdXN0IGJlIHBsYWNlZCBpbiB0aGVcbmxpZ2h0IERPTS5cblxuKiAqKndhdGVyZmFsbCoqXG5Ub2dnbGVzIHRoZSBzaGFkb3cgcHJvcGVydHkgaW4gYXBwLWhlYWRlciB0byBjcmVhdGUgYSBzZW5zZSBvZiBkZXB0aCAoYXMgcmVjb21tZW5kZWQgaW4gdGhlXG5NRCBzcGVjKSBiZXR3ZWVuIHRoZSBoZWFkZXIgYW5kIHRoZSB1bmRlcm5lYXRoIGNvbnRlbnQuIFlvdSBjYW4gY2hhbmdlIHRoZSBzaGFkb3cgYnlcbmN1c3RvbWl6aW5nIHRoZSBgLS1hcHAtaGVhZGVyLXNoYWRvd2AgbWl4aW4uIEZvciBleGFtcGxlOlxuXG5gYGBjc3NcbmFwcC1oZWFkZXIge1xuICAtLWFwcC1oZWFkZXItc2hhZG93OiB7XG4gICAgYm94LXNoYWRvdzogaW5zZXQgMHB4IDVweCAycHggLTNweCByZ2JhKDAsIDAsIDAsIDAuMik7XG4gIH07XG59XG5gYGBcblxuYGBgaHRtbFxuPGFwcC1oZWFkZXIgY29uZGVuc2VzIHJldmVhbHMgZWZmZWN0cz1cIndhdGVyZmFsbFwiPlxuICA8YXBwLXRvb2xiYXI+XG4gICAgICA8aDEgbWFpbi10aXRsZT5BcHAgbmFtZTwvaDE+XG4gIDwvYXBwLXRvb2xiYXI+XG48L2FwcC1oZWFkZXI+XG5gYGBcblxuKiAqKm1hdGVyaWFsKipcbkluc3RhbGxzIHRoZSB3YXRlcmZhbGwsIHJlc2l6ZS10aXRsZSwgYmxlbmQtYmFja2dyb3VuZCBhbmQgcGFyYWxsYXgtYmFja2dyb3VuZCBlZmZlY3RzLlxuXG4jIyMgQ29udGVudCBhdHRyaWJ1dGVzXG5cbkF0dHJpYnV0ZSB8IERlc2NyaXB0aW9uICAgICAgICAgfCBEZWZhdWx0XG4tLS0tLS0tLS0tfC0tLS0tLS0tLS0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5gc3RpY2t5YCB8IEVsZW1lbnQgdGhhdCByZW1haW5zIGF0IHRoZSB0b3Agd2hlbiB0aGUgaGVhZGVyIGNvbmRlbnNlcy4gfCBUaGUgZmlyc3QgYXBwLXRvb2xiYXIgaW4gdGhlIGxpZ2h0IERPTS5cblxuXG4jIyBTdHlsaW5nXG5cbk1peGluIHwgRGVzY3JpcHRpb24gfCBEZWZhdWx0XG4tLS0tLS18LS0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tXG5gLS1hcHAtaGVhZGVyLWJhY2tncm91bmQtZnJvbnQtbGF5ZXJgIHwgQXBwbGllcyB0byB0aGUgZnJvbnQgbGF5ZXIgb2YgdGhlIGJhY2tncm91bmQuIHwge31cbmAtLWFwcC1oZWFkZXItYmFja2dyb3VuZC1yZWFyLWxheWVyYCB8IEFwcGxpZXMgdG8gdGhlIHJlYXIgbGF5ZXIgb2YgdGhlIGJhY2tncm91bmQuIHwge31cbmAtLWFwcC1oZWFkZXItc2hhZG93YCB8IEFwcGxpZXMgdG8gdGhlIHNoYWRvdy4gfCB7fVxuXG5AZ3JvdXAgQXBwIEVsZW1lbnRzXG5AZWxlbWVudCBhcHAtaGVhZGVyXG5AZGVtbyBhcHAtaGVhZGVyL2RlbW8vYmxlbmQtYmFja2dyb3VuZC0xLmh0bWwgQmxlbmQgQmFja2dyb3VuZCBJbWFnZVxuQGRlbW8gYXBwLWhlYWRlci9kZW1vL2JsZW5kLWJhY2tncm91bmQtMi5odG1sIEJsZW5kIDIgQmFja2dyb3VuZCBJbWFnZXNcbkBkZW1vIGFwcC1oZWFkZXIvZGVtby9ibGVuZC1iYWNrZ3JvdW5kLTMuaHRtbCBCbGVuZCBCYWNrZ3JvdW5kIENvbG9yc1xuQGRlbW8gYXBwLWhlYWRlci9kZW1vL2NvbnRhY3RzLmh0bWwgQ29udGFjdHMgRGVtb1xuQGRlbW8gYXBwLWhlYWRlci9kZW1vL2dpdmUuaHRtbCBSZXNpemUgU25hcHBlZCBUaXRsZSBEZW1vXG5AZGVtbyBhcHAtaGVhZGVyL2RlbW8vbXVzaWMuaHRtbCBSZXZlYWxzIERlbW9cbkBkZW1vIGFwcC1oZWFkZXIvZGVtby9uby1lZmZlY3RzLmh0bWwgQ29uZGVuc2VzIGFuZCBSZXZlYWxzIERlbW9cbkBkZW1vIGFwcC1oZWFkZXIvZGVtby9ub3Rlcy5odG1sIEZpeGVkIHdpdGggRHluYW1pYyBTaGFkb3cgRGVtb1xuQGRlbW8gYXBwLWhlYWRlci9kZW1vL2N1c3RvbS1zdGlja3ktZWxlbWVudC0xLmh0bWwgQ3VzdG9tIFN0aWNreSBFbGVtZW50IERlbW8gMVxuQGRlbW8gYXBwLWhlYWRlci9kZW1vL2N1c3RvbS1zdGlja3ktZWxlbWVudC0yLmh0bWwgQ3VzdG9tIFN0aWNreSBFbGVtZW50IERlbW8gMlxuXG4tLT5cblxuPGRvbS1tb2R1bGUgaWQ9XCJhcHAtaGVhZGVyXCI+XG4gIDx0ZW1wbGF0ZT5cbiAgICA8c3R5bGU+XG4gICAgICA6aG9zdCB7XG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgZGlzcGxheTogYmxvY2s7XG4gICAgICAgIHRyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uOiBsaW5lYXI7XG4gICAgICAgIHRyYW5zaXRpb24tcHJvcGVydHk6IC13ZWJraXQtdHJhbnNmb3JtO1xuICAgICAgICB0cmFuc2l0aW9uLXByb3BlcnR5OiB0cmFuc2Zvcm07XG4gICAgICB9XG5cbiAgICAgIDpob3N0OjpiZWZvcmUge1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIHJpZ2h0OiAwcHg7XG4gICAgICAgIGJvdHRvbTogLTVweDtcbiAgICAgICAgbGVmdDogMHB4O1xuICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgaGVpZ2h0OiA1cHg7XG4gICAgICAgIGNvbnRlbnQ6IFwiXCI7XG4gICAgICAgIHRyYW5zaXRpb246IG9wYWNpdHkgMC40cztcbiAgICAgICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG4gICAgICAgIG9wYWNpdHk6IDA7XG4gICAgICAgIGJveC1zaGFkb3c6IGluc2V0IDBweCA1cHggNnB4IC0zcHggcmdiYSgwLCAwLCAwLCAwLjQpO1xuICAgICAgICB3aWxsLWNoYW5nZTogb3BhY2l0eTtcbiAgICAgICAgQGFwcGx5IC0tYXBwLWhlYWRlci1zaGFkb3c7XG4gICAgICB9XG5cbiAgICAgIDpob3N0KFtzaGFkb3ddKTo6YmVmb3JlIHtcbiAgICAgICAgb3BhY2l0eTogMTtcbiAgICAgIH1cblxuICAgICAgI2JhY2tncm91bmQge1xuICAgICAgICBAYXBwbHkgLS1sYXlvdXQtZml0O1xuICAgICAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgICAgfVxuXG4gICAgICAjYmFja2dyb3VuZEZyb250TGF5ZXIsXG4gICAgICAjYmFja2dyb3VuZFJlYXJMYXllciB7XG4gICAgICAgIEBhcHBseSAtLWxheW91dC1maXQ7XG4gICAgICAgIGhlaWdodDogMTAwJTtcbiAgICAgICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG4gICAgICAgIGJhY2tncm91bmQtc2l6ZTogY292ZXI7XG4gICAgICB9XG5cbiAgICAgICNiYWNrZ3JvdW5kRnJvbnRMYXllciB7XG4gICAgICAgIEBhcHBseSAtLWFwcC1oZWFkZXItYmFja2dyb3VuZC1mcm9udC1sYXllcjtcbiAgICAgIH1cblxuICAgICAgI2JhY2tncm91bmRSZWFyTGF5ZXIge1xuICAgICAgICBvcGFjaXR5OiAwO1xuICAgICAgICBAYXBwbHkgLS1hcHAtaGVhZGVyLWJhY2tncm91bmQtcmVhci1sYXllcjtcbiAgICAgIH1cblxuICAgICAgI2NvbnRlbnRDb250YWluZXIge1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICBoZWlnaHQ6IDEwMCU7XG4gICAgICB9XG5cbiAgICAgIDpob3N0KFtkaXNhYmxlZF0pLFxuICAgICAgOmhvc3QoW2Rpc2FibGVkXSk6OmFmdGVyLFxuICAgICAgOmhvc3QoW2Rpc2FibGVkXSkgI2JhY2tncm91bmRGcm9udExheWVyLFxuICAgICAgOmhvc3QoW2Rpc2FibGVkXSkgI2JhY2tncm91bmRSZWFyTGF5ZXIsXG4gICAgICAvKiBTaWxlbnQgc2Nyb2xsaW5nIHNob3VsZCBub3QgcnVuIENTUyB0cmFuc2l0aW9ucyAqL1xuICAgICAgOmhvc3QoW3NpbGVudC1zY3JvbGxdKSxcbiAgICAgIDpob3N0KFtzaWxlbnQtc2Nyb2xsXSk6OmFmdGVyLFxuICAgICAgOmhvc3QoW3NpbGVudC1zY3JvbGxdKSAjYmFja2dyb3VuZEZyb250TGF5ZXIsXG4gICAgICA6aG9zdChbc2lsZW50LXNjcm9sbF0pICNiYWNrZ3JvdW5kUmVhckxheWVyIHtcbiAgICAgICAgdHJhbnNpdGlvbjogbm9uZSAhaW1wb3J0YW50O1xuICAgICAgfVxuXG4gICAgICA6aG9zdChbZGlzYWJsZWRdKSA6OnNsb3R0ZWQoYXBwLXRvb2xiYXI6Zmlyc3Qtb2YtdHlwZSksXG4gICAgICA6aG9zdChbZGlzYWJsZWRdKSA6OnNsb3R0ZWQoW3N0aWNreV0pLFxuICAgICAgLyogU2lsZW50IHNjcm9sbGluZyBzaG91bGQgbm90IHJ1biBDU1MgdHJhbnNpdGlvbnMgKi9cbiAgICAgIDpob3N0KFtzaWxlbnQtc2Nyb2xsXSkgOjpzbG90dGVkKGFwcC10b29sYmFyOmZpcnN0LW9mLXR5cGUpLFxuICAgICAgOmhvc3QoW3NpbGVudC1zY3JvbGxdKSA6OnNsb3R0ZWQoW3N0aWNreV0pIHtcbiAgICAgICAgdHJhbnNpdGlvbjogbm9uZSAhaW1wb3J0YW50O1xuICAgICAgfVxuXG4gICAgPC9zdHlsZT5cbiAgICA8ZGl2IGlkPVwiY29udGVudENvbnRhaW5lclwiPlxuICAgICAgPHNsb3QgaWQ9XCJzbG90XCI+PC9zbG90PlxuICAgIDwvZGl2PlxuICA8L3RlbXBsYXRlPlxuXG4gIDxzY3JpcHQ+XG4gICAgUG9seW1lcih7XG4gICAgICBpczogJ2FwcC1oZWFkZXInLFxuXG4gICAgICBiZWhhdmlvcnM6IFtcbiAgICAgICAgUG9seW1lci5BcHBTY3JvbGxFZmZlY3RzQmVoYXZpb3IsXG4gICAgICAgIFBvbHltZXIuQXBwTGF5b3V0QmVoYXZpb3JcbiAgICAgIF0sXG5cbiAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHRydWUsIHRoZSBoZWFkZXIgd2lsbCBhdXRvbWF0aWNhbGx5IGNvbGxhcHNlIHdoZW4gc2Nyb2xsaW5nIGRvd24uXG4gICAgICAgICAqIFRoYXQgaXMsIHRoZSBgc3RpY2t5YCBlbGVtZW50IHJlbWFpbnMgdmlzaWJsZSB3aGVuIHRoZSBoZWFkZXIgaXMgZnVsbHkgY29uZGVuc2VkXG4gICAgICAgICAqIHdoZXJlYXMgdGhlIHJlc3Qgb2YgdGhlIGVsZW1lbnRzIHdpbGwgY29sbGFwc2UgYmVsb3cgYHN0aWNreWAgZWxlbWVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogQnkgZGVmYXVsdCwgdGhlIGBzdGlja3lgIGVsZW1lbnQgaXMgdGhlIGZpcnN0IHRvb2xiYXIgaW4gdGhlIGxpZ2h0IERPTTpcbiAgICAgICAgICpcbiAgICAgICAgICpgYGBodG1sXG4gICAgICAgICAqIDxhcHAtaGVhZGVyIGNvbmRlbnNlcz5cbiAgICAgICAgICogICA8YXBwLXRvb2xiYXI+VGhpcyB0b29sYmFyIHJlbWFpbnMgb24gdG9wPC9hcHAtdG9vbGJhcj5cbiAgICAgICAgICogICA8YXBwLXRvb2xiYXI+PC9hcHAtdG9vbGJhcj5cbiAgICAgICAgICogICA8YXBwLXRvb2xiYXI+PC9hcHAtdG9vbGJhcj5cbiAgICAgICAgICogPC9hcHAtaGVhZGVyPlxuICAgICAgICAgKiBgYGBcbiAgICAgICAgICpcbiAgICAgICAgICogQWRkaXRpb25hbGx5LCB5b3UgY2FuIHNwZWNpZnkgd2hpY2ggdG9vbGJhciBvciBlbGVtZW50IHJlbWFpbnMgdmlzaWJsZSBpbiBjb25kZW5zZWQgbW9kZVxuICAgICAgICAgKiBieSBhZGRpbmcgdGhlIGBzdGlja3lgIGF0dHJpYnV0ZSB0byB0aGF0IGVsZW1lbnQuIEZvciBleGFtcGxlOiBpZiB3ZSB3YW50IHRoZSBsYXN0XG4gICAgICAgICAqIHRvb2xiYXIgdG8gcmVtYWluIHZpc2libGUsIHdlIGNhbiBhZGQgdGhlIGBzdGlja3lgIGF0dHJpYnV0ZSB0byBpdC5cbiAgICAgICAgICpcbiAgICAgICAgICpgYGBodG1sXG4gICAgICAgICAqIDxhcHAtaGVhZGVyIGNvbmRlbnNlcz5cbiAgICAgICAgICogICA8YXBwLXRvb2xiYXI+PC9hcHAtdG9vbGJhcj5cbiAgICAgICAgICogICA8YXBwLXRvb2xiYXI+PC9hcHAtdG9vbGJhcj5cbiAgICAgICAgICogICA8YXBwLXRvb2xiYXIgc3RpY2t5PlRoaXMgdG9vbGJhciByZW1haW5zIG9uIHRvcDwvYXBwLXRvb2xiYXI+XG4gICAgICAgICAqIDwvYXBwLWhlYWRlcj5cbiAgICAgICAgICogYGBgXG4gICAgICAgICAqXG4gICAgICAgICAqIE5vdGUgdGhlIGBzdGlja3lgIGVsZW1lbnQgbXVzdCBiZSBhIGRpcmVjdCBjaGlsZCBvZiBgYXBwLWhlYWRlcmAuXG4gICAgICAgICAqL1xuICAgICAgICBjb25kZW5zZXM6IHtcbiAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYW50YWlucyB0aGUgaGVhZGVyIGZpeGVkIGF0IHRoZSB0b3Agc28gaXQgbmV2ZXIgbW92ZXMgYXdheS5cbiAgICAgICAgICovXG4gICAgICAgIGZpeGVkOiB7XG4gICAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2xpZGVzIGJhY2sgdGhlIGhlYWRlciB3aGVuIHNjcm9sbGluZyBiYWNrIHVwLlxuICAgICAgICAgKi9cbiAgICAgICAgcmV2ZWFsczoge1xuICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERpc3BsYXlzIGEgc2hhZG93IGJlbG93IHRoZSBoZWFkZXIuXG4gICAgICAgICAqL1xuICAgICAgICBzaGFkb3c6IHtcbiAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgIHJlZmxlY3RUb0F0dHJpYnV0ZTogdHJ1ZSxcbiAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgb2JzZXJ2ZXJzOiBbXG4gICAgICAgICdfY29uZmlnQ2hhbmdlZChpc0F0dGFjaGVkLCBjb25kZW5zZXMsIGZpeGVkKSdcbiAgICAgIF0sXG5cbiAgICAgIC8qKlxuICAgICAgICogQSBjYWNoZWQgb2Zmc2V0SGVpZ2h0IG9mIHRoZSBjdXJyZW50IGVsZW1lbnQuXG4gICAgICAgKlxuICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAqL1xuICAgICAgX2hlaWdodDogMCxcblxuICAgICAgLyoqXG4gICAgICAgKiBUaGUgZGlzdGFuY2UgaW4gcGl4ZWxzIHRoZSBoZWFkZXIgd2lsbCBiZSB0cmFuc2xhdGVkIHRvIHdoZW4gc2Nyb2xsaW5nLlxuICAgICAgICpcbiAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgKi9cbiAgICAgIF9kSGVpZ2h0OiAwLFxuXG4gICAgICAvKipcbiAgICAgICAqIFRoZSBvZmZzZXRUb3Agb2YgYF9zdGlja3lFbGBcbiAgICAgICAqXG4gICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICovXG4gICAgICBfc3RpY2t5RWxUb3A6IDAsXG5cbiAgICAgIC8qKlxuICAgICAgICogQSByZWZlcmVuY2UgdG8gdGhlIGVsZW1lbnQgdGhhdCByZW1haW5zIHZpc2libGUgd2hlbiB0aGUgaGVhZGVyIGNvbmRlbnNlcy5cbiAgICAgICAqXG4gICAgICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAgICAgKi9cbiAgICAgIF9zdGlja3lFbFJlZjogbnVsbCxcblxuICAgICAgLyoqXG4gICAgICAgKiBUaGUgaGVhZGVyJ3MgdG9wIHZhbHVlIHVzZWQgZm9yIHRoZSBgdHJhbnNmb3JtWWBcbiAgICAgICAqXG4gICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICovXG4gICAgICBfdG9wOiAwLFxuXG4gICAgICAvKipcbiAgICAgICAqIFRoZSBjdXJyZW50IHNjcm9sbCBwcm9ncmVzcy5cbiAgICAgICAqXG4gICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICovXG4gICAgICBfcHJvZ3Jlc3M6IDAsXG5cbiAgICAgIF93YXNTY3JvbGxpbmdEb3duOiBmYWxzZSxcbiAgICAgIF9pbml0U2Nyb2xsVG9wOiAwLFxuICAgICAgX2luaXRUaW1lc3RhbXA6IDAsXG4gICAgICBfbGFzdFRpbWVzdGFtcDogMCxcbiAgICAgIF9sYXN0U2Nyb2xsVG9wOiAwLFxuXG4gICAgICAvKipcbiAgICAgICAqIFRoZSBkaXN0YW5jZSB0aGUgaGVhZGVyIGlzIGFsbG93ZWQgdG8gbW92ZSBhd2F5LlxuICAgICAgICpcbiAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgKi9cbiAgICAgIGdldCBfbWF4SGVhZGVyVG9wKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5maXhlZCA/IHRoaXMuX2RIZWlnaHQgOiB0aGlzLl9oZWlnaHQgKyA1O1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBSZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoZSBzdGlja3kgZWxlbWVudC5cbiAgICAgICAqXG4gICAgICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudH0/XG4gICAgICAgKi9cbiAgICAgIGdldCBfc3RpY2t5RWwoKSB7XG4gICAgICAgIGlmICh0aGlzLl9zdGlja3lFbFJlZikge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9zdGlja3lFbFJlZjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbm9kZXMgPSBQb2x5bWVyLmRvbSh0aGlzLiQuc2xvdCkuZ2V0RGlzdHJpYnV0ZWROb2RlcygpO1xuICAgICAgICAvLyBHZXQgdGhlIGVsZW1lbnQgd2l0aCB0aGUgc3RpY2t5IGF0dHJpYnV0ZSBvbiBpdCBvciB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgbGlnaHQgRE9NLlxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbm9kZTsgbm9kZSA9IG5vZGVzW2ldOyBpKyspIHtcbiAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgICAgIGlmIChub2RlLmhhc0F0dHJpYnV0ZSgnc3RpY2t5JykpIHtcbiAgICAgICAgICAgICAgdGhpcy5fc3RpY2t5RWxSZWYgPSBub2RlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXRoaXMuX3N0aWNreUVsUmVmKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3N0aWNreUVsUmVmID0gbm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0aWNreUVsUmVmO1xuICAgICAgfSxcblxuICAgICAgX2NvbmZpZ0NoYW5nZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnJlc2V0TGF5b3V0KCk7XG4gICAgICAgIHRoaXMuX25vdGlmeUxheW91dENoYW5nZWQoKTtcbiAgICAgIH0sXG5cbiAgICAgIF91cGRhdGVMYXlvdXRTdGF0ZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5vZmZzZXRXaWR0aCA9PT0gMCAmJiB0aGlzLm9mZnNldEhlaWdodCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2Nyb2xsVG9wID0gdGhpcy5fY2xhbXBlZFNjcm9sbFRvcDtcbiAgICAgICAgdmFyIGZpcnN0U2V0dXAgPSB0aGlzLl9oZWlnaHQgPT09IDAgfHwgc2Nyb2xsVG9wID09PSAwO1xuICAgICAgICB2YXIgY3VycmVudERpc2FibGVkID0gdGhpcy5kaXNhYmxlZDtcbiAgICAgICAgdGhpcy5faGVpZ2h0ID0gdGhpcy5vZmZzZXRIZWlnaHQ7XG4gICAgICAgIHRoaXMuX3N0aWNreUVsUmVmID0gbnVsbDtcbiAgICAgICAgdGhpcy5kaXNhYmxlZCA9IHRydWU7XG4gICAgICAgIC8vIHByZXBhcmUgZm9yIG1lYXN1cmVtZW50XG4gICAgICAgIGlmICAoIWZpcnN0U2V0dXApIHtcbiAgICAgICAgICB0aGlzLl91cGRhdGVTY3JvbGxTdGF0ZSgwLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fbWF5TW92ZSgpKSB7XG4gICAgICAgICAgdGhpcy5fZEhlaWdodCA9IHRoaXMuX3N0aWNreUVsID8gdGhpcy5faGVpZ2h0IC0gdGhpcy5fc3RpY2t5RWwub2Zmc2V0SGVpZ2h0IDogMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9kSGVpZ2h0ID0gMDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zdGlja3lFbFRvcCA9IHRoaXMuX3N0aWNreUVsID8gdGhpcy5fc3RpY2t5RWwub2Zmc2V0VG9wIDogMDtcbiAgICAgICAgdGhpcy5fc2V0VXBFZmZlY3QoKTtcbiAgICAgICAgaWYgKGZpcnN0U2V0dXApIHtcbiAgICAgICAgICB0aGlzLl91cGRhdGVTY3JvbGxTdGF0ZShzY3JvbGxUb3AsIHRydWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX3VwZGF0ZVNjcm9sbFN0YXRlKHRoaXMuX2xhc3RTY3JvbGxUb3AsIHRydWUpO1xuICAgICAgICAgIHRoaXMuX2xheW91dElmRGlydHkoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyByZXN0b3JlIG5vIHRyYW5zaXRpb25cbiAgICAgICAgdGhpcy5kaXNhYmxlZCA9IGN1cnJlbnREaXNhYmxlZDtcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogVXBkYXRlcyB0aGUgc2Nyb2xsIHN0YXRlLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzY3JvbGxUb3BcbiAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IGZvcmNlVXBkYXRlIChkZWZhdWx0OiBmYWxzZSlcbiAgICAgICAqL1xuICAgICAgX3VwZGF0ZVNjcm9sbFN0YXRlOiBmdW5jdGlvbihzY3JvbGxUb3AsIGZvcmNlVXBkYXRlKSB7XG4gICAgICAgIGlmICh0aGlzLl9oZWlnaHQgPT09IDApIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByb2dyZXNzID0gMDtcbiAgICAgICAgdmFyIHRvcCA9IDA7XG4gICAgICAgIHZhciBsYXN0VG9wID0gdGhpcy5fdG9wO1xuICAgICAgICB2YXIgbGFzdFNjcm9sbFRvcCA9IHRoaXMuX2xhc3RTY3JvbGxUb3A7XG4gICAgICAgIHZhciBtYXhIZWFkZXJUb3AgPSB0aGlzLl9tYXhIZWFkZXJUb3A7XG4gICAgICAgIHZhciBkU2Nyb2xsVG9wID0gc2Nyb2xsVG9wIC0gdGhpcy5fbGFzdFNjcm9sbFRvcDtcbiAgICAgICAgdmFyIGFic0RTY3JvbGxUb3AgPSBNYXRoLmFicyhkU2Nyb2xsVG9wKTtcbiAgICAgICAgdmFyIGlzU2Nyb2xsaW5nRG93biA9IHNjcm9sbFRvcCA+IHRoaXMuX2xhc3RTY3JvbGxUb3A7XG4gICAgICAgIHZhciBub3cgPSBwZXJmb3JtYW5jZS5ub3coKTtcblxuICAgICAgICBpZiAodGhpcy5fbWF5TW92ZSgpKSB7XG4gICAgICAgICAgdG9wID0gdGhpcy5fY2xhbXAodGhpcy5yZXZlYWxzID8gbGFzdFRvcCArIGRTY3JvbGxUb3AgOiBzY3JvbGxUb3AsIDAsIG1heEhlYWRlclRvcCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNjcm9sbFRvcCA+PSB0aGlzLl9kSGVpZ2h0KSB7XG4gICAgICAgICAgdG9wID0gdGhpcy5jb25kZW5zZXMgJiYgIXRoaXMuZml4ZWQgPyBNYXRoLm1heCh0aGlzLl9kSGVpZ2h0LCB0b3ApIDogdG9wO1xuICAgICAgICAgIHRoaXMuc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID0gJzBtcyc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucmV2ZWFscyAmJiAhdGhpcy5kaXNhYmxlZCAmJiBhYnNEU2Nyb2xsVG9wIDwgMTAwKSB7XG4gICAgICAgICAgLy8gc2V0IHRoZSBpbml0aWFsIHNjcm9sbCBwb3NpdGlvblxuICAgICAgICAgIGlmIChub3cgLSB0aGlzLl9pbml0VGltZXN0YW1wID4gMzAwIHx8IHRoaXMuX3dhc1Njcm9sbGluZ0Rvd24gIT09IGlzU2Nyb2xsaW5nRG93bikge1xuICAgICAgICAgICAgdGhpcy5faW5pdFNjcm9sbFRvcCA9IHNjcm9sbFRvcDtcbiAgICAgICAgICAgIHRoaXMuX2luaXRUaW1lc3RhbXAgPSBub3c7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzY3JvbGxUb3AgPj0gbWF4SGVhZGVyVG9wKSB7XG4gICAgICAgICAgICAvLyBjaGVjayBpZiB0aGUgaGVhZGVyIGlzIGFsbG93ZWQgdG8gc25hcFxuICAgICAgICAgICAgaWYgKE1hdGguYWJzKHRoaXMuX2luaXRTY3JvbGxUb3AgLSBzY3JvbGxUb3ApID4gMzAgfHwgYWJzRFNjcm9sbFRvcCA+IDEwKSB7XG4gICAgICAgICAgICAgIGlmIChpc1Njcm9sbGluZ0Rvd24gJiYgc2Nyb2xsVG9wID49IG1heEhlYWRlclRvcCkge1xuICAgICAgICAgICAgICAgIHRvcCA9IG1heEhlYWRlclRvcDtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICghaXNTY3JvbGxpbmdEb3duICYmIHNjcm9sbFRvcCA+PSB0aGlzLl9kSGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgdG9wID0gdGhpcy5jb25kZW5zZXMgJiYgIXRoaXMuZml4ZWQgPyB0aGlzLl9kSGVpZ2h0IDogMDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2YXIgc2Nyb2xsVmVsb2NpdHkgPSBkU2Nyb2xsVG9wIC8gKG5vdyAtIHRoaXMuX2xhc3RUaW1lc3RhbXApO1xuICAgICAgICAgICAgICB0aGlzLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9IHRoaXMuX2NsYW1wKCh0b3AgLSBsYXN0VG9wKSAvIHNjcm9sbFZlbG9jaXR5LCAwLCAzMDApICsgJ21zJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRvcCA9IHRoaXMuX3RvcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2RIZWlnaHQgPT09IDApIHtcbiAgICAgICAgICBwcm9ncmVzcyA9IHNjcm9sbFRvcCA+IDAgPyAxIDogMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcm9ncmVzcyA9IHRvcCAvIHRoaXMuX2RIZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFmb3JjZVVwZGF0ZSkge1xuICAgICAgICAgIHRoaXMuX2xhc3RTY3JvbGxUb3AgPSBzY3JvbGxUb3A7XG4gICAgICAgICAgdGhpcy5fdG9wID0gdG9wO1xuICAgICAgICAgIHRoaXMuX3dhc1Njcm9sbGluZ0Rvd24gPSBpc1Njcm9sbGluZ0Rvd247XG4gICAgICAgICAgdGhpcy5fbGFzdFRpbWVzdGFtcCA9IG5vdztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZm9yY2VVcGRhdGUgfHwgcHJvZ3Jlc3MgIT09IHRoaXMuX3Byb2dyZXNzIHx8IGxhc3RUb3AgIT09IHRvcCB8fCBzY3JvbGxUb3AgPT09IDApIHtcbiAgICAgICAgICB0aGlzLl9wcm9ncmVzcyA9IHByb2dyZXNzO1xuICAgICAgICAgIHRoaXMuX3J1bkVmZmVjdHMocHJvZ3Jlc3MsIHRvcCk7XG4gICAgICAgICAgdGhpcy5fdHJhbnNmb3JtSGVhZGVyKHRvcCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBjdXJyZW50IGhlYWRlciBpcyBhbGxvd2VkIHRvIG1vdmUgYXMgdGhlIHVzZXIgc2Nyb2xscy5cbiAgICAgICAqXG4gICAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAgICovXG4gICAgICBfbWF5TW92ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmRlbnNlcyB8fCAhdGhpcy5maXhlZDtcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBjdXJyZW50IGhlYWRlciB3aWxsIGNvbmRlbnNlIGJhc2VkIG9uIHRoZSBzaXplIG9mIHRoZSBoZWFkZXJcbiAgICAgICAqIGFuZCB0aGUgYGNvbnNlbnNlc2AgcHJvcGVydHkuXG4gICAgICAgKlxuICAgICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgICAqL1xuICAgICAgd2lsbENvbmRlbnNlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RIZWlnaHQgPiAwICYmIHRoaXMuY29uZGVuc2VzO1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGN1cnJlbnQgZWxlbWVudCBpcyBvbiB0aGUgc2NyZWVuLlxuICAgICAgICogVGhhdCBpcywgdmlzaWJsZSBpbiB0aGUgY3VycmVudCB2aWV3cG9ydC5cbiAgICAgICAqXG4gICAgICAgKiBAbWV0aG9kIGlzT25TY3JlZW5cbiAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICAgKi9cbiAgICAgIGlzT25TY3JlZW46IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faGVpZ2h0ICE9PSAwICYmIHRoaXMuX3RvcCA8IHRoaXMuX2hlaWdodDtcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogUmV0dXJucyB0cnVlIGlmIHRoZXJlJ3MgY29udGVudCBiZWxvdyB0aGUgY3VycmVudCBlbGVtZW50LlxuICAgICAgICpcbiAgICAgICAqIEBtZXRob2QgaXNDb250ZW50QmVsb3dcbiAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICAgKi9cbiAgICAgIGlzQ29udGVudEJlbG93OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RvcCA9PT0gMCA/IHRoaXMuX2NsYW1wZWRTY3JvbGxUb3AgPiAwIDpcbiAgICAgICAgICAgIHRoaXMuX2NsYW1wZWRTY3JvbGxUb3AgLSB0aGlzLl9tYXhIZWFkZXJUb3AgPj0gMDtcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogVHJhbnNmb3JtcyB0aGUgaGVhZGVyLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgICAgKi9cbiAgICAgIF90cmFuc2Zvcm1IZWFkZXI6IGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgdGhpcy50cmFuc2xhdGUzZCgwLCAoLXkpICsgJ3B4JywgMCk7XG4gICAgICAgIGlmICh0aGlzLl9zdGlja3lFbCkge1xuICAgICAgICAgIHRoaXMudHJhbnNsYXRlM2QoMCwgdGhpcy5jb25kZW5zZXMgJiYgeSA+PSB0aGlzLl9zdGlja3lFbFRvcCA/XG4gICAgICAgICAgICAgIChNYXRoLm1pbih5LCB0aGlzLl9kSGVpZ2h0KSAtIHRoaXMuX3N0aWNreUVsVG9wKSArICdweCcgOiAwLCAgMCwgdGhpcy5fc3RpY2t5RWwpO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBfY2xhbXA6IGZ1bmN0aW9uKHYsIG1pbiwgbWF4KSB7XG4gICAgICAgIHJldHVybiBNYXRoLm1pbihtYXgsIE1hdGgubWF4KG1pbiwgdikpO1xuICAgICAgfSxcblxuICAgICAgX2Vuc3VyZUJnQ29udGFpbmVyczogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5fYmdDb250YWluZXIpIHtcbiAgICAgICAgICB0aGlzLl9iZ0NvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgIHRoaXMuX2JnQ29udGFpbmVyLmlkID0gJ2JhY2tncm91bmQnO1xuICAgICAgICAgIHRoaXMuX2JnUmVhciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgIHRoaXMuX2JnUmVhci5pZCA9ICdiYWNrZ3JvdW5kUmVhckxheWVyJztcbiAgICAgICAgICB0aGlzLl9iZ0NvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLl9iZ1JlYXIpO1xuICAgICAgICAgIHRoaXMuX2JnRnJvbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICB0aGlzLl9iZ0Zyb250LmlkID0gJ2JhY2tncm91bmRGcm9udExheWVyJztcbiAgICAgICAgICB0aGlzLl9iZ0NvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLl9iZ0Zyb250KTtcbiAgICAgICAgICBQb2x5bWVyLmRvbSh0aGlzLnJvb3QpLmluc2VydEJlZm9yZSh0aGlzLl9iZ0NvbnRhaW5lciwgdGhpcy4kLmNvbnRlbnRDb250YWluZXIpO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBfZ2V0RE9NUmVmOiBmdW5jdGlvbihpZCkge1xuICAgICAgICBzd2l0Y2ggKGlkKSB7XG4gICAgICAgICAgY2FzZSAnYmFja2dyb3VuZEZyb250TGF5ZXInOlxuICAgICAgICAgICAgdGhpcy5fZW5zdXJlQmdDb250YWluZXJzKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYmdGcm9udDtcbiAgICAgICAgICBjYXNlICdiYWNrZ3JvdW5kUmVhckxheWVyJzpcbiAgICAgICAgICAgIHRoaXMuX2Vuc3VyZUJnQ29udGFpbmVycygpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2JnUmVhcjtcbiAgICAgICAgICBjYXNlICdiYWNrZ3JvdW5kJzpcbiAgICAgICAgICAgIHRoaXMuX2Vuc3VyZUJnQ29udGFpbmVycygpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2JnQ29udGFpbmVyO1xuICAgICAgICAgIGNhc2UgJ21haW5UaXRsZSc6XG4gICAgICAgICAgICByZXR1cm4gUG9seW1lci5kb20odGhpcykucXVlcnlTZWxlY3RvcignW21haW4tdGl0bGVdJyk7XG4gICAgICAgICAgY2FzZSAnY29uZGVuc2VkVGl0bGUnOlxuICAgICAgICAgICAgcmV0dXJuIFBvbHltZXIuZG9tKHRoaXMpLnF1ZXJ5U2VsZWN0b3IoJ1tjb25kZW5zZWQtdGl0bGVdJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFJldHVybnMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHByb2dyZXNzIHZhbHVlIG9mIHRoZSBzY3JvbGwgZWZmZWN0c1xuICAgICAgICogYW5kIHRoZSB0b3AgcG9zaXRpb24gb2YgdGhlIGhlYWRlci5cbiAgICAgICAqXG4gICAgICAgKiBAbWV0aG9kIGdldFNjcm9sbFN0YXRlXG4gICAgICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAgICAgKi9cbiAgICAgIGdldFNjcm9sbFN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHsgcHJvZ3Jlc3M6IHRoaXMuX3Byb2dyZXNzLCB0b3A6IHRoaXMuX3RvcCB9O1xuICAgICAgfVxuICAgIH0pO1xuICA8L3NjcmlwdD5cbjwvZG9tLW1vZHVsZT5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvYXBwLWxheW91dC9hcHAtaGVhZGVyL2FwcC1oZWFkZXIuaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTYgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cblxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uLy4uL3BvbHltZXIvcG9seW1lci5odG1sXCI+XG5cbjxzY3JpcHQ+XG4gIFBvbHltZXIuQXBwTGF5b3V0ID0gUG9seW1lci5BcHBMYXlvdXQgfHwge307XG5cbiAgUG9seW1lci5BcHBMYXlvdXQuX3Njcm9sbEVmZmVjdHMgPSBQb2x5bWVyLkFwcExheW91dC5fc2Nyb2xsRWZmZWN0cyB8fCB7fTtcblxuICBQb2x5bWVyLkFwcExheW91dC5zY3JvbGxUaW1pbmdGdW5jdGlvbiA9IGZ1bmN0aW9uIGVhc2VPdXRRdWFkKHQsIGIsIGMsIGQpIHtcbiAgICB0IC89IGQ7XG4gICAgcmV0dXJuIC1jICogdCoodC0yKSArIGI7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhIHNjcm9sbCBlZmZlY3QgdG8gYmUgdXNlZCBpbiBlbGVtZW50cyB0aGF0IGltcGxlbWVudCB0aGVcbiAgICogYFBvbHltZXIuQXBwU2Nyb2xsRWZmZWN0c0JlaGF2aW9yYCBiZWhhdmlvci5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGVmZmVjdE5hbWUgVGhlIGVmZmVjdCBuYW1lLlxuICAgKiBAcGFyYW0ge09iamVjdH0gZWZmZWN0RGVmIFRoZSBlZmZlY3QgZGVmaW5pdGlvbi5cbiAgICovXG4gIFBvbHltZXIuQXBwTGF5b3V0LnJlZ2lzdGVyRWZmZWN0ID0gZnVuY3Rpb24gcmVnaXN0ZXJFZmZlY3QoZWZmZWN0TmFtZSwgZWZmZWN0RGVmKSB7XG4gICAgaWYgKFBvbHltZXIuQXBwTGF5b3V0Ll9zY3JvbGxFZmZlY3RzW2VmZmVjdE5hbWVdICE9IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZWZmZWN0IGAnKyBlZmZlY3ROYW1lICsgJ2AgaXMgYWxyZWFkeSByZWdpc3RlcmVkLicpO1xuICAgIH1cbiAgICBQb2x5bWVyLkFwcExheW91dC5fc2Nyb2xsRWZmZWN0c1tlZmZlY3ROYW1lXSA9IGVmZmVjdERlZjtcbiAgfTtcblxuXG4gIFBvbHltZXIuQXBwTGF5b3V0LnF1ZXJ5QWxsUm9vdCA9IGZ1bmN0aW9uKHNlbGVjdG9yLCByb290KSB7XG4gICAgdmFyIHF1ZXVlID0gW3Jvb3RdO1xuICAgIHZhciBtYXRjaGVzID0gW107XG5cbiAgICB3aGlsZSAocXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgdmFyIG5vZGUgPSBxdWV1ZS5zaGlmdCgpO1xuICAgICAgbWF0Y2hlcy5wdXNoLmFwcGx5KG1hdGNoZXMsIG5vZGUucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcikpO1xuICAgICAgZm9yIChpID0gMDsgbm9kZS5jaGlsZHJlbltpXTsgaSsrKSB7XG4gICAgICAgIGlmIChub2RlLmNoaWxkcmVuW2ldLnNoYWRvd1Jvb3QpIHtcbiAgICAgICAgICBxdWV1ZS5wdXNoKG5vZGUuY2hpbGRyZW5baV0uc2hhZG93Um9vdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1hdGNoZXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNjcm9sbHMgdG8gYSBwYXJ0aWN1bGFyIHNldCBvZiBjb29yZGluYXRlcyBpbiBhIHNjcm9sbCB0YXJnZXQuXG4gICAqIElmIHRoZSBzY3JvbGwgdGFyZ2V0IGlzIG5vdCBkZWZpbmVkLCB0aGVuIGl0IHdvdWxkIHVzZSB0aGUgbWFpbiBkb2N1bWVudCBhcyB0aGUgdGFyZ2V0LlxuICAgKlxuICAgKiBUbyBzY3JvbGwgaW4gYSBzbW9vdGggZmFzaGlvbiwgeW91IGNhbiBzZXQgdGhlIG9wdGlvbiBgYmVoYXZpb3I6ICdzbW9vdGgnYC4gZS5nLlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiBQb2x5bWVyLkFwcExheW91dC5zY3JvbGwoe3RvcDogMCwgYmVoYXZpb3I6ICdzbW9vdGgnfSk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBUbyBzY3JvbGwgaW4gYSBzaWxlbnQgbW9kZSwgd2l0aG91dCBub3RpZnlpbmcgc2Nyb2xsIGNoYW5nZXMgdG8gYW55IGFwcC1sYXlvdXQgZWxlbWVudHMsXG4gICAqIHlvdSBjYW4gc2V0IHRoZSBvcHRpb24gYGJlaGF2aW9yOiAnc2lsZW50J2AuIFRoaXMgaXMgcGFydGljdWxhcmx5IHVzZWZ1bCB3ZSB5b3UgYXJlIHVzaW5nXG4gICAqIGBhcHAtaGVhZGVyYCBhbmQgeW91IGRlc2lyZSB0byBzY3JvbGwgdG8gdGhlIHRvcCBvZiBhIHNjcm9sbGluZyByZWdpb24gd2l0aG91dCBydW5uaW5nXG4gICAqIHNjcm9sbCBlZmZlY3RzLiBlLmcuXG4gICAqXG4gICAqIGBgYGpzXG4gICAqIFBvbHltZXIuQXBwTGF5b3V0LnNjcm9sbCh7dG9wOiAwLCBiZWhhdmlvcjogJ3NpbGVudCd9KTtcbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIHt0b3A6IE51bWJlciwgbGVmdDogTnVtYmVyLCBiZWhhdmlvcjogU3RyaW5nKHNtb290aCB8IHNpbGVudCl9XG4gICAqL1xuICBQb2x5bWVyLkFwcExheW91dC5zY3JvbGwgPSBmdW5jdGlvbiBzY3JvbGwob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgdmFyIGRvY0VsID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgIHZhciB0YXJnZXQgPSBvcHRpb25zLnRhcmdldCB8fCBkb2NFbDtcbiAgICB2YXIgaGFzTmF0aXZlU2Nyb2xsQmVoYXZpb3IgPSAnc2Nyb2xsQmVoYXZpb3InIGluIHRhcmdldC5zdHlsZSAmJiB0YXJnZXQuc2Nyb2xsO1xuICAgIHZhciBzY3JvbGxDbGFzc05hbWUgPSAnYXBwLWxheW91dC1zaWxlbnQtc2Nyb2xsJztcbiAgICB2YXIgc2Nyb2xsVG9wID0gb3B0aW9ucy50b3AgfHwgMDtcbiAgICB2YXIgc2Nyb2xsTGVmdCA9IG9wdGlvbnMubGVmdCB8fCAwO1xuICAgIHZhciBzY3JvbGxUbyA9IHRhcmdldCA9PT0gZG9jRWwgPyB3aW5kb3cuc2Nyb2xsVG8gOlxuICAgICAgZnVuY3Rpb24gc2Nyb2xsVG8oc2Nyb2xsTGVmdCwgc2Nyb2xsVG9wKSB7XG4gICAgICAgIHRhcmdldC5zY3JvbGxMZWZ0ID0gc2Nyb2xsTGVmdDtcbiAgICAgICAgdGFyZ2V0LnNjcm9sbFRvcCA9IHNjcm9sbFRvcDtcbiAgICAgIH07XG5cbiAgICBpZiAob3B0aW9ucy5iZWhhdmlvciA9PT0gJ3Ntb290aCcpIHtcblxuICAgICAgaWYgKGhhc05hdGl2ZVNjcm9sbEJlaGF2aW9yKSB7XG5cbiAgICAgICAgdGFyZ2V0LnNjcm9sbChvcHRpb25zKTtcblxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICB2YXIgdGltaW5nRm4gPSBQb2x5bWVyLkFwcExheW91dC5zY3JvbGxUaW1pbmdGdW5jdGlvbjtcbiAgICAgICAgdmFyIHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIHZhciBjdXJyZW50U2Nyb2xsVG9wID0gdGFyZ2V0ID09PSBkb2NFbCA/IHdpbmRvdy5wYWdlWU9mZnNldCA6IHRhcmdldC5zY3JvbGxUb3A7XG4gICAgICAgIHZhciBjdXJyZW50U2Nyb2xsTGVmdCA9IHRhcmdldCA9PT0gZG9jRWwgPyB3aW5kb3cucGFnZVhPZmZzZXQgOiB0YXJnZXQuc2Nyb2xsTGVmdDtcbiAgICAgICAgdmFyIGRlbHRhU2Nyb2xsVG9wID0gc2Nyb2xsVG9wIC0gY3VycmVudFNjcm9sbFRvcDtcbiAgICAgICAgdmFyIGRlbHRhU2Nyb2xsTGVmdCA9IHNjcm9sbExlZnQgLSBjdXJyZW50U2Nyb2xsTGVmdDtcbiAgICAgICAgdmFyIGR1cmF0aW9uID0gMzAwO1xuICAgICAgICB2YXIgdXBkYXRlRnJhbWUgPSAoZnVuY3Rpb24gdXBkYXRlRnJhbWUoKSB7XG4gICAgICAgICAgdmFyIG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgICAgdmFyIGVsYXBzZWRUaW1lID0gbm93IC0gc3RhcnRUaW1lO1xuXG4gICAgICAgICAgaWYgKGVsYXBzZWRUaW1lIDwgZHVyYXRpb24pIHtcbiAgICAgICAgICAgIHNjcm9sbFRvKHRpbWluZ0ZuKGVsYXBzZWRUaW1lLCBjdXJyZW50U2Nyb2xsTGVmdCwgZGVsdGFTY3JvbGxMZWZ0LCBkdXJhdGlvbiksXG4gICAgICAgICAgICAgICAgdGltaW5nRm4oZWxhcHNlZFRpbWUsIGN1cnJlbnRTY3JvbGxUb3AsIGRlbHRhU2Nyb2xsVG9wLCBkdXJhdGlvbikpO1xuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHVwZGF0ZUZyYW1lKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2Nyb2xsVG8oc2Nyb2xsTGVmdCwgc2Nyb2xsVG9wKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pLmJpbmQodGhpcyk7XG5cbiAgICAgICAgdXBkYXRlRnJhbWUoKTtcbiAgICAgIH1cblxuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5iZWhhdmlvciA9PT0gJ3NpbGVudCcpIHtcbiAgICAgIHZhciBoZWFkZXJzID0gUG9seW1lci5BcHBMYXlvdXQucXVlcnlBbGxSb290KCdhcHAtaGVhZGVyJywgZG9jdW1lbnQuYm9keSk7XG5cbiAgICAgIGhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbihoZWFkZXIpIHtcbiAgICAgICAgaGVhZGVyLnNldEF0dHJpYnV0ZSgnc2lsZW50LXNjcm9sbCcsICcnKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBCcm93c2VycyBrZWVwIHRoZSBzY3JvbGwgbW9tZW50dW0gZXZlbiBpZiB0aGUgYm90dG9tIG9mIHRoZSBzY3JvbGxpbmcgY29udGVudFxuICAgICAgLy8gd2FzIHJlYWNoZWQuIFRoaXMgbWVhbnMgdGhhdCBjYWxsaW5nIHNjcm9sbCh7dG9wOiAwLCBiZWhhdmlvcjogJ3NpbGVudCd9KSB3aGVuXG4gICAgICAvLyB0aGUgbW9tZW50dW0gaXMgc3RpbGwgZ29pbmcgd2lsbCByZXN1bHQgaW4gbW9yZSBzY3JvbGwgZXZlbnRzIGFuZCB0aHVzIHNjcm9sbCBlZmZlY3RzLlxuICAgICAgLy8gVGhpcyBzZWVtcyB0byBvbmx5IGFwcGx5IHdoZW4gdXNpbmcgZG9jdW1lbnQgc2Nyb2xsaW5nLlxuICAgICAgLy8gVGhlcmVmb3JlLCB3aGVuIHNob3VsZCB3ZSByZW1vdmUgdGhlIGNsYXNzIGZyb20gdGhlIGRvY3VtZW50IGVsZW1lbnQ/XG5cbiAgICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZShQb2x5bWVyLkFwcExheW91dC5fc2Nyb2xsVGltZXIpO1xuXG4gICAgICBQb2x5bWVyLkFwcExheW91dC5fc2Nyb2xsVGltZXIgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCkge1xuICAgICAgICBoZWFkZXJzLmZvckVhY2goZnVuY3Rpb24oaGVhZGVyKSB7XG4gICAgICAgICAgaGVhZGVyLnJlbW92ZUF0dHJpYnV0ZSgnc2lsZW50LXNjcm9sbCcpO1xuICAgICAgICB9KTtcbiAgICAgICAgUG9seW1lci5BcHBMYXlvdXQuX3Njcm9sbFRpbWVyID0gbnVsbDtcbiAgICAgIH0pO1xuXG4gICAgICBzY3JvbGxUbyhzY3JvbGxMZWZ0LCBzY3JvbGxUb3ApO1xuXG4gICAgfSBlbHNlIHtcblxuICAgICAgc2Nyb2xsVG8oc2Nyb2xsTGVmdCwgc2Nyb2xsVG9wKTtcblxuICAgIH1cbiAgfTtcblxuPC9zY3JpcHQ+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL2FwcC1sYXlvdXQvaGVscGVycy9oZWxwZXJzLmh0bWwiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE1IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi8uLi9wb2x5bWVyL3BvbHltZXIuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uLy4uL2lyb24tZmxleC1sYXlvdXQvaXJvbi1mbGV4LWxheW91dC5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vYXBwLWxheW91dC1iZWhhdmlvci9hcHAtbGF5b3V0LWJlaGF2aW9yLmh0bWxcIj5cblxuPCEtLVxuYXBwLWhlYWRlci1sYXlvdXQgaXMgYSB3cmFwcGVyIGVsZW1lbnQgdGhhdCBwb3NpdGlvbnMgYW4gYXBwLWhlYWRlciBhbmQgb3RoZXIgY29udGVudC4gVGhpc1xuZWxlbWVudCB1c2VzIHRoZSBkb2N1bWVudCBzY3JvbGwgYnkgZGVmYXVsdCwgYnV0IGl0IGNhbiBhbHNvIGRlZmluZSBpdHMgb3duIHNjcm9sbGluZyByZWdpb24uXG5cblVzaW5nIHRoZSBkb2N1bWVudCBzY3JvbGw6XG5cbmBgYGh0bWxcbjxhcHAtaGVhZGVyLWxheW91dD5cbiAgPGFwcC1oZWFkZXIgc2xvdD1cImhlYWRlclwiIGZpeGVkIGNvbmRlbnNlcyBlZmZlY3RzPVwid2F0ZXJmYWxsXCI+XG4gICAgPGFwcC10b29sYmFyPlxuICAgICAgPGRpdiBtYWluLXRpdGxlPkFwcCBuYW1lPC9kaXY+XG4gICAgPC9hcHAtdG9vbGJhcj5cbiAgPC9hcHAtaGVhZGVyPlxuICA8ZGl2PlxuICAgIG1haW4gY29udGVudFxuICA8L2Rpdj5cbjwvYXBwLWhlYWRlci1sYXlvdXQ+XG5gYGBcblxuVXNpbmcgYW4gb3duIHNjcm9sbGluZyByZWdpb246XG5cbmBgYGh0bWxcbjxhcHAtaGVhZGVyLWxheW91dCBoYXMtc2Nyb2xsaW5nLXJlZ2lvbiBzdHlsZT1cIndpZHRoOiAzMDBweDsgaGVpZ2h0OiA0MDBweDtcIj5cbiAgPGFwcC1oZWFkZXIgc2xvdD1cImhlYWRlclwiIGZpeGVkIGNvbmRlbnNlcyBlZmZlY3RzPVwid2F0ZXJmYWxsXCI+XG4gICAgPGFwcC10b29sYmFyPlxuICAgICAgPGRpdiBtYWluLXRpdGxlPkFwcCBuYW1lPC9kaXY+XG4gICAgPC9hcHAtdG9vbGJhcj5cbiAgPC9hcHAtaGVhZGVyPlxuICA8ZGl2PlxuICAgIG1haW4gY29udGVudFxuICA8L2Rpdj5cbjwvYXBwLWhlYWRlci1sYXlvdXQ+XG5gYGBcblxuQWRkIHRoZSBgZnVsbGJsZWVkYCBhdHRyaWJ1dGUgdG8gYXBwLWhlYWRlci1sYXlvdXQgdG8gbWFrZSBpdCBmaXQgdGhlIHNpemUgb2YgaXRzIGNvbnRhaW5lcjpcblxuYGBgaHRtbFxuPGFwcC1oZWFkZXItbGF5b3V0IGZ1bGxibGVlZD5cbiAuLi5cbjwvYXBwLWhlYWRlci1sYXlvdXQ+XG5gYGBcblxuQGdyb3VwIEFwcCBFbGVtZW50c1xuQGVsZW1lbnQgYXBwLWhlYWRlci1sYXlvdXRcbkBkZW1vIGFwcC1oZWFkZXItbGF5b3V0L2RlbW8vc2ltcGxlLmh0bWwgU2ltcGxlIERlbW9cbkBkZW1vIGFwcC1oZWFkZXItbGF5b3V0L2RlbW8vc2Nyb2xsaW5nLXJlZ2lvbi5odG1sIFNjcm9sbGluZyBSZWdpb25cbkBkZW1vIGFwcC1oZWFkZXItbGF5b3V0L2RlbW8vbXVzaWMuaHRtbCBNdXNpYyBEZW1vXG5AZGVtbyBhcHAtaGVhZGVyLWxheW91dC9kZW1vL2Zvb3Rlci5odG1sIEZvb3RlciBEZW1vXG4tLT5cblxuPGRvbS1tb2R1bGUgaWQ9XCJhcHAtaGVhZGVyLWxheW91dFwiPlxuICA8dGVtcGxhdGU+XG4gICAgPHN0eWxlPlxuICAgICAgOmhvc3Qge1xuICAgICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZvcmNlIGFwcC1oZWFkZXItbGF5b3V0IHRvIGhhdmUgaXRzIG93biBzdGFja2luZyBjb250ZXh0IHNvIHRoYXQgaXRzIHBhcmVudCBjYW5cbiAgICAgICAgICogY29udHJvbCB0aGUgc3RhY2tpbmcgb2YgaXQgcmVsYXRpdmUgdG8gb3RoZXIgZWxlbWVudHMgKGUuZy4gYXBwLWRyYXdlci1sYXlvdXQpLlxuICAgICAgICAgKiBUaGlzIGNvdWxkIGJlIGRvbmUgdXNpbmcgYGlzb2xhdGlvbjogaXNvbGF0ZWAsIGJ1dCB0aGF0J3Mgbm90IHdlbGwgc3VwcG9ydGVkXG4gICAgICAgICAqIGFjcm9zcyBicm93c2Vycy5cbiAgICAgICAgICovXG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgei1pbmRleDogMDtcbiAgICAgIH1cblxuICAgICAgI3dyYXBwZXIgOjpzbG90dGVkKFtzbG90PWhlYWRlcl0pIHtcbiAgICAgICAgQGFwcGx5IC0tbGF5b3V0LWZpeGVkLXRvcDtcbiAgICAgICAgei1pbmRleDogMTtcbiAgICAgIH1cblxuICAgICAgI3dyYXBwZXIuaW5pdGlhbGl6aW5nIDo6c2xvdHRlZChbc2xvdD1oZWFkZXJdKSB7XG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgIH1cblxuICAgICAgOmhvc3QoW2hhcy1zY3JvbGxpbmctcmVnaW9uXSkge1xuICAgICAgICBoZWlnaHQ6IDEwMCU7XG4gICAgICB9XG5cbiAgICAgIDpob3N0KFtoYXMtc2Nyb2xsaW5nLXJlZ2lvbl0pICN3cmFwcGVyIDo6c2xvdHRlZChbc2xvdD1oZWFkZXJdKSB7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgIH1cblxuICAgICAgOmhvc3QoW2hhcy1zY3JvbGxpbmctcmVnaW9uXSkgI3dyYXBwZXIuaW5pdGlhbGl6aW5nIDo6c2xvdHRlZChbc2xvdD1oZWFkZXJdKSB7XG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgIH1cblxuICAgICAgOmhvc3QoW2hhcy1zY3JvbGxpbmctcmVnaW9uXSkgI3dyYXBwZXIgI2NvbnRlbnRDb250YWluZXIge1xuICAgICAgICBAYXBwbHkgLS1sYXlvdXQtZml0O1xuICAgICAgICBvdmVyZmxvdy15OiBhdXRvO1xuICAgICAgICAtd2Via2l0LW92ZXJmbG93LXNjcm9sbGluZzogdG91Y2g7XG4gICAgICB9XG5cbiAgICAgIDpob3N0KFtoYXMtc2Nyb2xsaW5nLXJlZ2lvbl0pICN3cmFwcGVyLmluaXRpYWxpemluZyAjY29udGVudENvbnRhaW5lciB7XG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgIH1cblxuICAgICAgOmhvc3QoW2Z1bGxibGVlZF0pIHtcbiAgICAgICAgQGFwcGx5IC0tbGF5b3V0LXZlcnRpY2FsO1xuICAgICAgICBAYXBwbHkgLS1sYXlvdXQtZml0O1xuICAgICAgfVxuXG4gICAgICA6aG9zdChbZnVsbGJsZWVkXSkgI3dyYXBwZXIsXG4gICAgICA6aG9zdChbZnVsbGJsZWVkXSkgI3dyYXBwZXIgI2NvbnRlbnRDb250YWluZXIge1xuICAgICAgICBAYXBwbHkgLS1sYXlvdXQtdmVydGljYWw7XG4gICAgICAgIEBhcHBseSAtLWxheW91dC1mbGV4O1xuICAgICAgfVxuXG4gICAgICAjY29udGVudENvbnRhaW5lciB7XG4gICAgICAgIC8qIENyZWF0ZSBhIHN0YWNraW5nIGNvbnRleHQgaGVyZSBzbyB0aGF0IGFsbCBjaGlsZHJlbiBhcHBlYXIgYmVsb3cgdGhlIGhlYWRlci4gKi9cbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICB6LWluZGV4OiAwO1xuICAgICAgfVxuXG4gICAgPC9zdHlsZT5cblxuICAgIDxkaXYgaWQ9XCJ3cmFwcGVyXCIgY2xhc3M9XCJpbml0aWFsaXppbmdcIj5cbiAgICAgIDxzbG90IGlkPVwiaGVhZGVyU2xvdFwiIG5hbWU9XCJoZWFkZXJcIj48L3Nsb3Q+XG5cbiAgICAgIDxkaXYgaWQ9XCJjb250ZW50Q29udGFpbmVyXCI+XG4gICAgICAgIDxzbG90Pjwvc2xvdD5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuXG4gIDwvdGVtcGxhdGU+XG5cbiAgPHNjcmlwdD5cbiAgICBQb2x5bWVyKHtcbiAgICAgIGlzOiAnYXBwLWhlYWRlci1sYXlvdXQnLFxuXG4gICAgICBiZWhhdmlvcnM6IFtcbiAgICAgICAgUG9seW1lci5BcHBMYXlvdXRCZWhhdmlvclxuICAgICAgXSxcblxuICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgdHJ1ZSwgdGhlIGN1cnJlbnQgZWxlbWVudCB3aWxsIGhhdmUgaXRzIG93biBzY3JvbGxpbmcgcmVnaW9uLlxuICAgICAgICAgKiBPdGhlcndpc2UsIGl0IHdpbGwgdXNlIHRoZSBkb2N1bWVudCBzY3JvbGwgdG8gY29udHJvbCB0aGUgaGVhZGVyLlxuICAgICAgICAgKi9cbiAgICAgICAgaGFzU2Nyb2xsaW5nUmVnaW9uOiB7XG4gICAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgICB2YWx1ZTogZmFsc2UsXG4gICAgICAgICAgcmVmbGVjdFRvQXR0cmlidXRlOiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIG9ic2VydmVyczogW1xuICAgICAgICAncmVzZXRMYXlvdXQoaXNBdHRhY2hlZCwgaGFzU2Nyb2xsaW5nUmVnaW9uKSdcbiAgICAgIF0sXG5cbiAgICAgIC8qKlxuICAgICAgICogQSByZWZlcmVuY2UgdG8gdGhlIGFwcC1oZWFkZXIgZWxlbWVudC5cbiAgICAgICAqXG4gICAgICAgKiBAcHJvcGVydHkgaGVhZGVyXG4gICAgICAgKi9cbiAgICAgIGdldCBoZWFkZXIoKSB7XG4gICAgICAgIHJldHVybiBQb2x5bWVyLmRvbSh0aGlzLiQuaGVhZGVyU2xvdCkuZ2V0RGlzdHJpYnV0ZWROb2RlcygpWzBdO1xuICAgICAgfSxcblxuICAgICAgX3VwZGF0ZUxheW91dFN0YXRlczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBoZWFkZXIgPSB0aGlzLmhlYWRlcjtcbiAgICAgICAgaWYgKCF0aGlzLmlzQXR0YWNoZWQgfHwgIWhlYWRlcikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZW1vdmUgdGhlIGluaXRpYWxpemluZyBjbGFzcywgd2hpY2ggc3RhdGljbHkgcG9zaXRpb25zIHRoZSBoZWFkZXIgYW5kIHRoZSBjb250ZW50XG4gICAgICAgIC8vIHVudGlsIHRoZSBoZWlnaHQgb2YgdGhlIGhlYWRlciBjYW4gYmUgcmVhZC5cbiAgICAgICAgdGhpcy4kLndyYXBwZXIuY2xhc3NMaXN0LnJlbW92ZSgnaW5pdGlhbGl6aW5nJyk7XG4gICAgICAgIC8vIFVwZGF0ZSBzY3JvbGwgdGFyZ2V0LlxuICAgICAgICBoZWFkZXIuc2Nyb2xsVGFyZ2V0ID0gdGhpcy5oYXNTY3JvbGxpbmdSZWdpb24gP1xuICAgICAgICAgICAgdGhpcy4kLmNvbnRlbnRDb250YWluZXIgOiB0aGlzLm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICAvLyBHZXQgaGVhZGVyIGhlaWdodCBoZXJlIHNvIHRoYXQgc3R5bGUgcmVhZHMgYXJlIGJhdGNoZWQgdG9nZXRoZXIgYmVmb3JlIHN0eWxlIHdyaXRlc1xuICAgICAgICAvLyAoaS5lLiBnZXRCb3VuZGluZ0NsaWVudFJlY3QoKSBiZWxvdykuXG4gICAgICAgIHZhciBoZWFkZXJIZWlnaHQgPSBoZWFkZXIub2Zmc2V0SGVpZ2h0O1xuICAgICAgICAvLyBVcGRhdGUgdGhlIGhlYWRlciBwb3NpdGlvbi5cbiAgICAgICAgaWYgKCF0aGlzLmhhc1Njcm9sbGluZ1JlZ2lvbikge1xuICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciByZWN0ID0gdGhpcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIHZhciByaWdodE9mZnNldCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCAtIHJlY3QucmlnaHQ7XG4gICAgICAgICAgICBoZWFkZXIuc3R5bGUubGVmdCA9IHJlY3QubGVmdCArICdweCc7XG4gICAgICAgICAgICBoZWFkZXIuc3R5bGUucmlnaHQgPSByaWdodE9mZnNldCArICdweCc7XG4gICAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBoZWFkZXIuc3R5bGUubGVmdCA9ICcnO1xuICAgICAgICAgIGhlYWRlci5zdHlsZS5yaWdodCA9ICcnO1xuICAgICAgICB9XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgY29udGVudCBjb250YWluZXIgcG9zaXRpb24uXG4gICAgICAgIHZhciBjb250YWluZXJTdHlsZSA9IHRoaXMuJC5jb250ZW50Q29udGFpbmVyLnN0eWxlO1xuICAgICAgICBpZiAoaGVhZGVyLmZpeGVkICYmICFoZWFkZXIuY29uZGVuc2VzICYmIHRoaXMuaGFzU2Nyb2xsaW5nUmVnaW9uKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGhlYWRlciBzaXplIGRvZXMgbm90IGNoYW5nZSBhbmQgd2UncmUgdXNpbmcgYSBzY3JvbGxpbmcgcmVnaW9uLCBleGNsdWRlXG4gICAgICAgICAgLy8gdGhlIGhlYWRlciBhcmVhIGZyb20gdGhlIHNjcm9sbGluZyByZWdpb24gc28gdGhhdCB0aGUgaGVhZGVyIGRvZXNuJ3Qgb3ZlcmxhcFxuICAgICAgICAgIC8vIHRoZSBzY3JvbGxiYXIuXG4gICAgICAgICAgY29udGFpbmVyU3R5bGUubWFyZ2luVG9wID0gaGVhZGVySGVpZ2h0ICsgJ3B4JztcbiAgICAgICAgICBjb250YWluZXJTdHlsZS5wYWRkaW5nVG9wID0gJyc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29udGFpbmVyU3R5bGUucGFkZGluZ1RvcCA9IGhlYWRlckhlaWdodCArICdweCc7XG4gICAgICAgICAgY29udGFpbmVyU3R5bGUubWFyZ2luVG9wID0gJyc7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgIH0pO1xuICA8L3NjcmlwdD5cbjwvZG9tLW1vZHVsZT5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvYXBwLWxheW91dC9hcHAtaGVhZGVyLWxheW91dC9hcHAtaGVhZGVyLWxheW91dC5odG1sIiwiXG5yZXF1aXJlKCcuL2VmZmVjdHMvYmxlbmQtYmFja2dyb3VuZC5odG1sJyk7XG5cbnJlcXVpcmUoJy4vZWZmZWN0cy9mYWRlLWJhY2tncm91bmQuaHRtbCcpO1xuXG5yZXF1aXJlKCcuL2VmZmVjdHMvbWF0ZXJpYWwuaHRtbCcpO1xuXG5yZXF1aXJlKCcuL2VmZmVjdHMvcGFyYWxsYXgtYmFja2dyb3VuZC5odG1sJyk7XG5cbnJlcXVpcmUoJy4vZWZmZWN0cy9yZXNpemUtc25hcHBlZC10aXRsZS5odG1sJyk7XG5cbnJlcXVpcmUoJy4vZWZmZWN0cy9yZXNpemUtdGl0bGUuaHRtbCcpO1xuXG5yZXF1aXJlKCcuL2VmZmVjdHMvd2F0ZXJmYWxsLmh0bWwnKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvYXBwLWxheW91dC9hcHAtc2Nyb2xsLWVmZmVjdHMvYXBwLXNjcm9sbC1lZmZlY3RzLmh0bWwiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi9hcHAtc2Nyb2xsLWVmZmVjdHMtYmVoYXZpb3IuaHRtbFwiPlxuXG48c2NyaXB0PlxuICAvKipcbiAgICogVXBvbiBzY3JvbGxpbmcgcGFzdCBhIHRocmVzaG9sZCwgZmFkZSBpbiB0aGUgcmVhciBiYWNrZ3JvdW5kIGxheWVyIGFuZCBmYWRlIG91dCB0aGUgZnJvbnRcbiAgICogYmFja2dyb3VuZCBsYXllciAob3BhY2l0eSBDU1MgdHJhbnNpdGlvbmVkIG92ZXIgdGltZSkuXG4gICAqXG4gICAqXG4gICAqL1xuICBQb2x5bWVyLkFwcExheW91dC5yZWdpc3RlckVmZmVjdCgnZmFkZS1iYWNrZ3JvdW5kJywge1xuICAgIC8qKiBAdGhpcyBQb2x5bWVyLkFwcExheW91dC5FbGVtZW50V2l0aEJhY2tncm91bmQgKi9cbiAgICBzZXRVcDogZnVuY3Rpb24gc2V0VXAoY29uZmlnKSB7XG4gICAgICB2YXIgZnggPSB7fTtcbiAgICAgIHZhciBkdXJhdGlvbiA9IGNvbmZpZy5kdXJhdGlvbiB8fCAnMC41cyc7XG4gICAgICBmeC5iYWNrZ3JvdW5kRnJvbnRMYXllciA9IHRoaXMuX2dldERPTVJlZignYmFja2dyb3VuZEZyb250TGF5ZXInKTtcbiAgICAgIGZ4LmJhY2tncm91bmRSZWFyTGF5ZXIgPSB0aGlzLl9nZXRET01SZWYoJ2JhY2tncm91bmRSZWFyTGF5ZXInKTtcbiAgICAgIGZ4LmJhY2tncm91bmRGcm9udExheWVyLnN0eWxlLndpbGxDaGFuZ2UgPSAnb3BhY2l0eSc7XG4gICAgICBmeC5iYWNrZ3JvdW5kRnJvbnRMYXllci5zdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSAndHJhbnNsYXRlWigwKSc7XG4gICAgICBmeC5iYWNrZ3JvdW5kRnJvbnRMYXllci5zdHlsZS50cmFuc2l0aW9uUHJvcGVydHkgPSAnb3BhY2l0eSc7XG4gICAgICBmeC5iYWNrZ3JvdW5kRnJvbnRMYXllci5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPSBkdXJhdGlvbjtcbiAgICAgIGZ4LmJhY2tncm91bmRSZWFyTGF5ZXIuc3R5bGUud2lsbENoYW5nZSA9ICdvcGFjaXR5JztcbiAgICAgIGZ4LmJhY2tncm91bmRSZWFyTGF5ZXIuc3R5bGUud2Via2l0VHJhbnNmb3JtID0gJ3RyYW5zbGF0ZVooMCknO1xuICAgICAgZnguYmFja2dyb3VuZFJlYXJMYXllci5zdHlsZS50cmFuc2l0aW9uUHJvcGVydHkgPSAnb3BhY2l0eSc7XG4gICAgICBmeC5iYWNrZ3JvdW5kUmVhckxheWVyLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9IGR1cmF0aW9uO1xuICAgICAgdGhpcy5fZnhGYWRlQmFja2dyb3VuZCA9IGZ4O1xuICAgIH0sXG4gICAgLyoqIEB0aGlzIFBvbHltZXIuQXBwTGF5b3V0LkVsZW1lbnRXaXRoQmFja2dyb3VuZCAqL1xuICAgIHJ1bjogZnVuY3Rpb24gcnVuKHAsIHkpIHtcbiAgICAgIHZhciBmeCA9IHRoaXMuX2Z4RmFkZUJhY2tncm91bmQ7XG4gICAgICBpZiAocCA+PSAxKSB7XG4gICAgICAgIGZ4LmJhY2tncm91bmRGcm9udExheWVyLnN0eWxlLm9wYWNpdHkgPSAwO1xuICAgICAgICBmeC5iYWNrZ3JvdW5kUmVhckxheWVyLnN0eWxlLm9wYWNpdHkgPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZnguYmFja2dyb3VuZEZyb250TGF5ZXIuc3R5bGUub3BhY2l0eSA9IDE7XG4gICAgICAgIGZ4LmJhY2tncm91bmRSZWFyTGF5ZXIuc3R5bGUub3BhY2l0eSA9IDA7XG4gICAgICB9XG4gICAgfSxcbiAgICAvKiogQHRoaXMgUG9seW1lci5BcHBMYXlvdXQuRWxlbWVudFdpdGhCYWNrZ3JvdW5kICovXG4gICAgdGVhckRvd246IGZ1bmN0aW9uIHRlYXJEb3duKCkge1xuICAgICAgZGVsZXRlIHRoaXMuX2Z4RmFkZUJhY2tncm91bmQ7XG4gICAgfVxuICB9KTtcbjwvc2NyaXB0PlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9hcHAtbGF5b3V0L2FwcC1zY3JvbGwtZWZmZWN0cy9lZmZlY3RzL2ZhZGUtYmFja2dyb3VuZC5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNiBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuXG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vYXBwLXNjcm9sbC1lZmZlY3RzLWJlaGF2aW9yLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCJ3YXRlcmZhbGwuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cInJlc2l6ZS10aXRsZS5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiYmxlbmQtYmFja2dyb3VuZC5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwicGFyYWxsYXgtYmFja2dyb3VuZC5odG1sXCI+XG5cbjxzY3JpcHQ+XG4gIC8qKlxuICAgKiBTaG9ydGhhbmQgZm9yIHRoZSB3YXRlcmZhbGwsIHJlc2l6ZS10aXRsZSwgYmxlbmQtYmFja2dyb3VuZCwgYW5kIHBhcmFsbGF4LWJhY2tncm91bmQgZWZmZWN0cy5cbiAgICovXG4gIFBvbHltZXIuQXBwTGF5b3V0LnJlZ2lzdGVyRWZmZWN0KCdtYXRlcmlhbCcsIHtcbiAgICAvKipcbiAgICAgKiBAdGhpcyBQb2x5bWVyLkFwcExheW91dC5FbGVtZW50V2l0aEJhY2tncm91bmRcbiAgICAgKi9cbiAgICBzZXRVcDogZnVuY3Rpb24gc2V0VXAoKSB7XG4gICAgICB0aGlzLmVmZmVjdHMgPSAnd2F0ZXJmYWxsIHJlc2l6ZS10aXRsZSBibGVuZC1iYWNrZ3JvdW5kIHBhcmFsbGF4LWJhY2tncm91bmQnO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSk7XG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvYXBwLWxheW91dC9hcHAtc2Nyb2xsLWVmZmVjdHMvZWZmZWN0cy9tYXRlcmlhbC5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNiBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuXG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vYXBwLXNjcm9sbC1lZmZlY3RzLWJlaGF2aW9yLmh0bWxcIj5cblxuPHNjcmlwdD5cbiAgLyoqXG4gICAqIFVwb24gc2Nyb2xsaW5nIHBhc3QgYSB0aHJlc2hvbGQsIENTUyB0cmFuc2l0aW9uIHRoZSBmb250IHNpemUgb2YgYSBkZXNpZ25hdGVkIHRpdGxlIGVsZW1lbnRcbiAgICogYmV0d2VlbiB0d28gdmFsdWVzLlxuICAgKi9cbiAgUG9seW1lci5BcHBMYXlvdXQucmVnaXN0ZXJFZmZlY3QoJ3Jlc2l6ZS1zbmFwcGVkLXRpdGxlJywge1xuICAgIC8qKlxuICAgICAqIEB0aGlzIFBvbHltZXIuQXBwTGF5b3V0LkVsZW1lbnRXaXRoQmFja2dyb3VuZFxuICAgICAqL1xuICAgIHNldFVwOiBmdW5jdGlvbiBzZXRVcChjb25maWcpIHtcbiAgICAgIHZhciB0aXRsZSA9IHRoaXMuX2dldERPTVJlZignbWFpblRpdGxlJyk7XG4gICAgICB2YXIgY29uZGVuc2VkVGl0bGUgPSB0aGlzLl9nZXRET01SZWYoJ2NvbmRlbnNlZFRpdGxlJyk7XG4gICAgICB2YXIgZHVyYXRpb24gPSBjb25maWcuZHVyYXRpb24gfHwgJzAuMnMnO1xuICAgICAgdmFyIGZ4ID0ge307XG5cbiAgICAgIGlmICghY29uZGVuc2VkVGl0bGUpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdTY3JvbGwgZWZmZWN0IGByZXNpemUtc25hcHBlZC10aXRsZWA6IHVuZGVmaW5lZCBgY29uZGVuc2VkLXRpdGxlYCcpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoIXRpdGxlKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignU2Nyb2xsIGVmZmVjdCBgcmVzaXplLXNuYXBwZWQtdGl0bGVgOiB1bmRlZmluZWQgYG1haW4tdGl0bGVgJyk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdGl0bGUuc3R5bGUudHJhbnNpdGlvblByb3BlcnR5ID0gJ29wYWNpdHknO1xuICAgICAgdGl0bGUuc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID0gZHVyYXRpb247XG4gICAgICBjb25kZW5zZWRUaXRsZS5zdHlsZS50cmFuc2l0aW9uUHJvcGVydHkgPSAnb3BhY2l0eSc7XG4gICAgICBjb25kZW5zZWRUaXRsZS5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPSBkdXJhdGlvbjtcbiAgICAgIGZ4LmNvbmRlbnNlZFRpdGxlID0gY29uZGVuc2VkVGl0bGU7XG4gICAgICBmeC50aXRsZSA9IHRpdGxlO1xuICAgICAgdGhpcy5fZnhSZXNpemVTbmFwcGVkVGl0bGUgPSBmeDtcbiAgICB9LFxuICAgIC8qKiBAdGhpcyBQb2x5bWVyLkFwcExheW91dC5FbGVtZW50V2l0aEJhY2tncm91bmQgKi9cbiAgICBydW46IGZ1bmN0aW9uIHJ1bihwLCB5KSB7XG4gICAgICB2YXIgZnggPSB0aGlzLl9meFJlc2l6ZVNuYXBwZWRUaXRsZTtcbiAgICAgIGlmIChwID4gMCkge1xuICAgICAgICBmeC50aXRsZS5zdHlsZS5vcGFjaXR5ID0gMDtcbiAgICAgICAgZnguY29uZGVuc2VkVGl0bGUuc3R5bGUub3BhY2l0eSA9IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmeC50aXRsZS5zdHlsZS5vcGFjaXR5ID0gMTtcbiAgICAgICAgZnguY29uZGVuc2VkVGl0bGUuc3R5bGUub3BhY2l0eSA9IDA7XG4gICAgICB9XG4gICAgfSxcbiAgICAvKiogQHRoaXMgUG9seW1lci5BcHBMYXlvdXQuRWxlbWVudFdpdGhCYWNrZ3JvdW5kICovXG4gICAgdGVhckRvd246IGZ1bmN0aW9uIHRlYXJEb3duKCkge1xuICAgICAgdmFyIGZ4ID0gdGhpcy5fZnhSZXNpemVTbmFwcGVkVGl0bGU7XG4gICAgICBmeC50aXRsZS5zdHlsZS50cmFuc2l0aW9uID0gJyc7XG4gICAgICBmeC5jb25kZW5zZWRUaXRsZS5zdHlsZS50cmFuc2l0aW9uID0gJyc7XG4gICAgICBkZWxldGUgdGhpcy5fZnhSZXNpemVTbmFwcGVkVGl0bGU7XG4gICAgfVxuICB9KTtcbjwvc2NyaXB0PlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9hcHAtbGF5b3V0L2FwcC1zY3JvbGwtZWZmZWN0cy9lZmZlY3RzL3Jlc2l6ZS1zbmFwcGVkLXRpdGxlLmh0bWwiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE1IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi8uLi9wb2x5bWVyL3BvbHltZXIuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uLy4uL2lyb24tZmxleC1sYXlvdXQvaXJvbi1mbGV4LWxheW91dC5odG1sXCI+XG5cbjwhLS1cbmFwcC10b29sYmFyIGlzIGEgaG9yaXpvbnRhbCB0b29sYmFyIGNvbnRhaW5pbmcgaXRlbXMgdGhhdCBjYW4gYmUgdXNlZCBmb3JcbmxhYmVsLCBuYXZpZ2F0aW9uLCBzZWFyY2ggYW5kIGFjdGlvbnMuXG5cbiMjIyBFeGFtcGxlXG5cbkFkZCBhIHRpdGxlIHRvIHRoZSB0b29sYmFyLlxuXG5gYGBodG1sXG48YXBwLXRvb2xiYXI+XG4gIDxkaXYgbWFpbi10aXRsZT5BcHAgbmFtZTwvZGl2PlxuPC9hcHAtdG9vbGJhcj5cbmBgYFxuXG5BZGQgYSBidXR0b24gdG8gdGhlIGxlZnQgYW5kIHJpZ2h0IHNpZGUgb2YgdGhlIHRvb2xiYXIuXG5cbmBgYGh0bWxcbjxhcHAtdG9vbGJhcj5cbiAgPHBhcGVyLWljb24tYnV0dG9uIGljb249XCJtZW51XCI+PC9wYXBlci1pY29uLWJ1dHRvbj5cbiAgPGRpdiBtYWluLXRpdGxlPkFwcCBuYW1lPC9kaXY+XG4gIDxwYXBlci1pY29uLWJ1dHRvbiBpY29uPVwic2VhcmNoXCI+PC9wYXBlci1pY29uLWJ1dHRvbj5cbjwvYXBwLXRvb2xiYXI+XG5gYGBcblxuWW91IGNhbiB1c2UgdGhlIGF0dHJpYnV0ZXMgYHRvcC1pdGVtYCBvciBgYm90dG9tLWl0ZW1gIHRvIGNvbXBsZXRlbHkgZml0IGFuIGVsZW1lbnRcbnRvIHRoZSB0b3Agb3IgYm90dG9tIG9mIHRoZSB0b29sYmFyIHJlc3BlY3RpdmVseS5cblxuIyMjIENvbnRlbnQgYXR0cmlidXRlc1xuXG5BdHRyaWJ1dGUgICAgICAgICAgICB8IERlc2NyaXB0aW9uXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS18LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5gbWFpbi10aXRsZWAgICAgICAgICB8IFRoZSBtYWluIHRpdGxlIGVsZW1lbnQuXG5gY29uZGVuc2VkLXRpdGxlYCAgICB8IFRoZSB0aXRsZSBlbGVtZW50IGlmIHVzZWQgaW5zaWRlIGEgY29uZGVuc2VkIGFwcC1oZWFkZXIuXG5gc3BhY2VyYCAgICAgICAgICAgICB8IEFkZHMgYSBsZWZ0IG1hcmdpbiBvZiBgNjRweGAuXG5gYm90dG9tLWl0ZW1gICAgICAgICB8IFN0aWNrcyB0aGUgZWxlbWVudCB0byB0aGUgYm90dG9tIG9mIHRoZSB0b29sYmFyLlxuYHRvcC1pdGVtYCAgICAgICAgICAgfCBTdGlja3MgdGhlIGVsZW1lbnQgdG8gdGhlIHRvcCBvZiB0aGUgdG9vbGJhci5cblxuIyMjIFN0eWxpbmdcblxuQ3VzdG9tIHByb3BlcnR5ICAgICAgICAgICAgICB8IERlc2NyaXB0aW9uICAgICAgICAgICAgICAgICAgfCBEZWZhdWx0XG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmAtLWFwcC10b29sYmFyLWZvbnQtc2l6ZWAgICAgfCBUb29sYmFyIGZvbnQgc2l6ZSAgICAgICAgICAgIHwgMjBweFxuXG5AZ3JvdXAgQXBwIEVsZW1lbnRzXG5AZWxlbWVudCBhcHAtdG9vbGJhclxuQGRlbW8gYXBwLXRvb2xiYXIvZGVtby9pbmRleC5odG1sXG4tLT5cblxuPGRvbS1tb2R1bGUgaWQ9XCJhcHAtdG9vbGJhclwiPlxuICA8dGVtcGxhdGU+XG4gICAgPHN0eWxlPlxuXG4gICAgICA6aG9zdCB7XG4gICAgICAgIEBhcHBseSAtLWxheW91dC1ob3Jpem9udGFsO1xuICAgICAgICBAYXBwbHkgLS1sYXlvdXQtY2VudGVyO1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgIGhlaWdodDogNjRweDtcbiAgICAgICAgcGFkZGluZzogMCAxNnB4O1xuICAgICAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcbiAgICAgICAgZm9udC1zaXplOiB2YXIoLS1hcHAtdG9vbGJhci1mb250LXNpemUsIDIwcHgpO1xuICAgICAgfVxuXG4gICAgICA6aG9zdCA6OnNsb3R0ZWQoKikge1xuICAgICAgICBwb2ludGVyLWV2ZW50czogYXV0bztcbiAgICAgIH1cblxuICAgICAgOmhvc3QgOjpzbG90dGVkKHBhcGVyLWljb24tYnV0dG9uKSB7XG4gICAgICAgIC8qIHBhcGVyLWljb24tYnV0dG9uL2lzc3Vlcy8zMyAqL1xuICAgICAgICBmb250LXNpemU6IDA7XG4gICAgICB9XG5cbiAgICAgIDpob3N0IDo6c2xvdHRlZChbbWFpbi10aXRsZV0pLFxuICAgICAgOmhvc3QgOjpzbG90dGVkKFtjb25kZW5zZWQtdGl0bGVdKSB7XG4gICAgICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xuICAgICAgICBAYXBwbHkgLS1sYXlvdXQtZmxleDtcbiAgICAgIH1cblxuICAgICAgOmhvc3QgOjpzbG90dGVkKFtib3R0b20taXRlbV0pIHtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICByaWdodDogMDtcbiAgICAgICAgYm90dG9tOiAwO1xuICAgICAgICBsZWZ0OiAwO1xuICAgICAgfVxuXG4gICAgICA6aG9zdCA6OnNsb3R0ZWQoW3RvcC1pdGVtXSkge1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIHRvcDogMDtcbiAgICAgICAgcmlnaHQ6IDA7XG4gICAgICAgIGxlZnQ6IDA7XG4gICAgICB9XG5cbiAgICAgIDpob3N0IDo6c2xvdHRlZChbc3BhY2VyXSkge1xuICAgICAgICBtYXJnaW4tbGVmdDogNjRweDtcbiAgICAgIH1cbiAgICA8L3N0eWxlPlxuXG4gICAgPHNsb3Q+PC9zbG90PlxuXG4gIDwvdGVtcGxhdGU+XG5cbiAgPHNjcmlwdD5cbiAgICBQb2x5bWVyKHtcbiAgICAgIGlzOiAnYXBwLXRvb2xiYXInXG4gICAgfSk7XG4gIDwvc2NyaXB0PlxuPC9kb20tbW9kdWxlPlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9hcHAtbGF5b3V0L2FwcC10b29sYmFyL2FwcC10b29sYmFyLmh0bWwiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vcG9seW1lci9wb2x5bWVyLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi9pcm9uLWxvY2F0aW9uL2lyb24tbG9jYXRpb24uaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL2lyb24tbG9jYXRpb24vaXJvbi1xdWVyeS1wYXJhbXMuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cImFwcC1yb3V0ZS1jb252ZXJ0ZXItYmVoYXZpb3IuaHRtbFwiPlxuXG48IS0tXG5gYXBwLWxvY2F0aW9uYCBpcyBhbiBlbGVtZW50IHRoYXQgcHJvdmlkZXMgc3luY2hyb25pemF0aW9uIGJldHdlZW4gdGhlXG5icm93c2VyIGxvY2F0aW9uIGJhciBhbmQgdGhlIHN0YXRlIG9mIGFuIGFwcC4gV2hlbiBjcmVhdGVkLCBgYXBwLWxvY2F0aW9uYFxuZWxlbWVudHMgd2lsbCBhdXRvbWF0aWNhbGx5IHdhdGNoIHRoZSBnbG9iYWwgbG9jYXRpb24gZm9yIGNoYW5nZXMuIEFzIGNoYW5nZXNcbm9jY3VyLCBgYXBwLWxvY2F0aW9uYCBwcm9kdWNlcyBhbmQgdXBkYXRlcyBhbiBvYmplY3QgY2FsbGVkIGByb3V0ZWAuIFRoaXNcbmByb3V0ZWAgb2JqZWN0IGlzIHN1aXRhYmxlIGZvciBwYXNzaW5nIGludG8gYSBgYXBwLXJvdXRlYCwgYW5kIG90aGVyIHNpbWlsYXJcbmVsZW1lbnRzLlxuXG5BbiBleGFtcGxlIG9mIHRoZSBwdWJsaWMgQVBJIG9mIGEgcm91dGUgb2JqZWN0IHRoYXQgZGVzY3JpYmVzIHRoZSBVUkxcbmBodHRwczovL2VsZW1lbnRzLnBvbHltZXItcHJvamVjdC5vcmcvZWxlbWVudHMvYXBwLWxvY2F0aW9uYDpcblxuICAgIHtcbiAgICAgIHByZWZpeDogJycsXG4gICAgICBwYXRoOiAnL2VsZW1lbnRzL2FwcC1sb2NhdGlvbidcbiAgICB9XG5cbkV4YW1wbGUgVXNhZ2U6XG5cbiAgICA8YXBwLWxvY2F0aW9uIHJvdXRlPVwie3tyb3V0ZX19XCI+PC9hcHAtbG9jYXRpb24+XG4gICAgPGFwcC1yb3V0ZSByb3V0ZT1cInt7cm91dGV9fVwiIHBhdHRlcm49XCIvOnBhZ2VcIiBkYXRhPVwie3tkYXRhfX1cIj48L2FwcC1yb3V0ZT5cblxuQXMgeW91IGNhbiBzZWUgYWJvdmUsIHRoZSBgYXBwLWxvY2F0aW9uYCBlbGVtZW50IHByb2R1Y2VzIGEgYHJvdXRlYCBhbmQgdGhhdFxucHJvcGVydHkgaXMgdGhlbiBib3VuZCBpbnRvIHRoZSBgYXBwLXJvdXRlYCBlbGVtZW50LiBUaGUgYmluZGluZ3MgYXJlIHR3by1cbmRpcmVjdGlvbmFsLCBzbyB3aGVuIGNoYW5nZXMgdG8gdGhlIGByb3V0ZWAgb2JqZWN0IG9jY3VyIHdpdGhpbiBgYXBwLXJvdXRlYCxcbnRoZXkgYXV0b21hdGljYWxseSByZWZsZWN0IGJhY2sgdG8gdGhlIGdsb2JhbCBsb2NhdGlvbi5cblxuIyMjIEhhc2hlcyB2cyBQYXRoc1xuXG5CeSBkZWZhdWx0IGBhcHAtbG9jYXRpb25gIHJvdXRlcyB1c2luZyB0aGUgcGF0aG5hbWUgcG9ydGlvbiBvZiB0aGUgVVJMLiBUaGlzIGhhc1xuYnJvYWQgYnJvd3NlciBzdXBwb3J0IGJ1dCBpdCBkb2VzIHJlcXVpcmUgY29vcGVyYXRpb24gb2YgdGhlIGJhY2tlbmQgc2VydmVyLiBBblxuYGFwcC1sb2NhdGlvbmAgY2FuIGJlIGNvbmZpZ3VyZWQgdG8gdXNlIHRoZSBoYXNoIHBhcnQgb2YgYSBVUkwgaW5zdGVhZCB1c2luZ1xudGhlIGB1c2UtaGFzaC1hcy1wYXRoYCBhdHRyaWJ1dGUsIGxpa2Ugc286XG5cbiAgICA8YXBwLWxvY2F0aW9uIHJvdXRlPVwie3tyb3V0ZX19XCIgdXNlLWhhc2gtYXMtcGF0aD48L2FwcC1sb2NhdGlvbj5cblxuIyMjIEludGVncmF0aW5nIHdpdGggb3RoZXIgcm91dGluZyBjb2RlXG5cblRoZXJlIGlzIG5vIHN0YW5kYXJkIGV2ZW50IHRoYXQgaXMgZmlyZWQgd2hlbiB3aW5kb3cubG9jYXRpb24gaXMgbW9kaWZpZWQuXG5gYXBwLWxvY2F0aW9uYCBmaXJlcyBhIGBsb2NhdGlvbi1jaGFuZ2VkYCBldmVudCBvbiBgd2luZG93YCB3aGVuIGl0IHVwZGF0ZXMgdGhlXG5sb2NhdGlvbi4gSXQgYWxzbyBsaXN0ZW5zIGZvciB0aGF0IHNhbWUgZXZlbnQsIGFuZCByZS1yZWFkcyB0aGUgVVJMIHdoZW4gaXQnc1xuZmlyZWQuIFRoaXMgbWFrZXMgaXQgdmVyeSBlYXN5IHRvIGludGVyb3Agd2l0aCBvdGhlciByb3V0aW5nIGNvZGUuXG5cblNvIGZvciBleGFtcGxlIGlmIHlvdSB3YW50IHRvIG5hdmlnYXRlIHRvIGAvbmV3X3BhdGhgIGltcGVyYXRpdmVseSB5b3UgY291bGRcbmNhbGwgYHdpbmRvdy5sb2NhdGlvbi5wdXNoU3RhdGVgIG9yIGB3aW5kb3cubG9jYXRpb24ucmVwbGFjZVN0YXRlYCBmb2xsb3dlZCBieVxuZmlyaW5nIGEgYGxvY2F0aW9uLWNoYW5nZWRgIGV2ZW50IG9uIGB3aW5kb3dgLiBpLmUuXG5cbiAgICB3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUoe30sIG51bGwsICcvbmV3X3BhdGgnKTtcbiAgICB3aW5kb3cuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ2xvY2F0aW9uLWNoYW5nZWQnKSk7XG5cbkBlbGVtZW50IGFwcC1sb2NhdGlvblxuQGRlbW8gZGVtby9pbmRleC5odG1sXG4tLT5cbjxkb20tbW9kdWxlIGlkPVwiYXBwLWxvY2F0aW9uXCI+XG4gIDx0ZW1wbGF0ZT5cbiAgICA8aXJvbi1xdWVyeS1wYXJhbXNcbiAgICAgICAgcGFyYW1zLXN0cmluZz1cInt7X19xdWVyeX19XCJcbiAgICAgICAgcGFyYW1zLW9iamVjdD1cInt7cXVlcnlQYXJhbXN9fVwiPlxuICAgIDwvaXJvbi1xdWVyeS1wYXJhbXM+XG4gICAgPGlyb24tbG9jYXRpb25cbiAgICAgICAgcGF0aD1cInt7X19wYXRofX1cIlxuICAgICAgICBxdWVyeT1cInt7X19xdWVyeX19XCJcbiAgICAgICAgaGFzaD1cInt7X19oYXNofX1cIlxuICAgICAgICB1cmwtc3BhY2UtcmVnZXg9e3t1cmxTcGFjZVJlZ2V4fX0+XG4gICAgPC9pcm9uLWxvY2F0aW9uPlxuICA8L3RlbXBsYXRlPlxuICA8c2NyaXB0PlxuICAgIChmdW5jdGlvbigpIHtcbiAgICAgICd1c2Ugc3RyaWN0JztcblxuICAgICAgUG9seW1lcih7XG4gICAgICAgIGlzOiAnYXBwLWxvY2F0aW9uJyxcblxuICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogQSBtb2RlbCByZXByZXNlbnRpbmcgdGhlIGRlc2VyaWFsaXplZCBwYXRoIHRocm91Z2ggdGhlIHJvdXRlIHRyZWUsIGFzXG4gICAgICAgICAgICogd2VsbCBhcyB0aGUgY3VycmVudCBxdWVyeVBhcmFtcy5cbiAgICAgICAgICAgKi9cbiAgICAgICAgICByb3V0ZToge1xuICAgICAgICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgICAgICAgbm90aWZ5OiB0cnVlXG4gICAgICAgICAgfSxcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIEluIG1hbnkgc2NlbmFyaW9zLCBpdCBpcyBjb252ZW5pZW50IHRvIHRyZWF0IHRoZSBgaGFzaGAgYXMgYSBzdGFuZC1pblxuICAgICAgICAgICAqIGFsdGVybmF0aXZlIHRvIHRoZSBgcGF0aGAuIEZvciBleGFtcGxlLCBpZiBkZXBsb3lpbmcgYW4gYXBwIHRvIGEgc3RhdGljXG4gICAgICAgICAgICogd2ViIHNlcnZlciAoZS5nLiwgR2l0aHViIFBhZ2VzKSAtIHdoZXJlIG9uZSBkb2VzIG5vdCBoYXZlIGNvbnRyb2wgb3ZlclxuICAgICAgICAgICAqIHNlcnZlci1zaWRlIHJvdXRpbmcgLSBpdCBpcyB1c3VhbGx5IGEgYmV0dGVyIGV4cGVyaWVuY2UgdG8gdXNlIHRoZSBoYXNoXG4gICAgICAgICAgICogdG8gcmVwcmVzZW50IHBhdGhzIHRocm91Z2ggb25lJ3MgYXBwLlxuICAgICAgICAgICAqXG4gICAgICAgICAgICogV2hlbiB0aGlzIHByb3BlcnR5IGlzIHNldCB0byB0cnVlLCB0aGUgYGhhc2hgIHdpbGwgYmUgdXNlZCBpbiBwbGFjZSBvZlxuXG4gICAgICAgICAgICogdGhlIGBwYXRoYCBmb3IgZ2VuZXJhdGluZyBhIGByb3V0ZWAuXG4gICAgICAgICAgICovXG4gICAgICAgICAgdXNlSGFzaEFzUGF0aDoge1xuICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBBIHJlZ2V4cCB0aGF0IGRlZmluZXMgdGhlIHNldCBvZiBVUkxzIHRoYXQgc2hvdWxkIGJlIGNvbnNpZGVyZWQgcGFydFxuICAgICAgICAgICAqIG9mIHRoaXMgd2ViIGFwcC5cbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIENsaWNraW5nIG9uIGEgbGluayB0aGF0IG1hdGNoZXMgdGhpcyByZWdleCB3b24ndCByZXN1bHQgaW4gYSBmdWxsIHBhZ2VcbiAgICAgICAgICAgKiBuYXZpZ2F0aW9uLCBidXQgd2lsbCBpbnN0ZWFkIGp1c3QgdXBkYXRlIHRoZSBVUkwgc3RhdGUgaW4gcGxhY2UuXG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiBUaGlzIHJlZ2V4cCBpcyBnaXZlbiBldmVyeXRoaW5nIGFmdGVyIHRoZSBvcmlnaW4gaW4gYW4gYWJzb2x1dGVcbiAgICAgICAgICAgKiBVUkwuIFNvIHRvIG1hdGNoIGp1c3QgVVJMcyB0aGF0IHN0YXJ0IHdpdGggL3NlYXJjaC8gZG86XG4gICAgICAgICAgICogICAgIHVybC1zcGFjZS1yZWdleD1cIl4vc2VhcmNoL1wiXG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfFJlZ0V4cH1cbiAgICAgICAgICAgKi9cbiAgICAgICAgICB1cmxTcGFjZVJlZ2V4OiB7XG4gICAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgICBub3RpZnk6IHRydWVcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogQSBzZXQgb2Yga2V5L3ZhbHVlIHBhaXJzIHRoYXQgYXJlIHVuaXZlcnNhbGx5IGFjY2Vzc2libGUgdG8gYnJhbmNoZXNcbiAgICAgICAgICAgKiBvZiB0aGUgcm91dGUgdHJlZS5cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBfX3F1ZXJ5UGFyYW1zOiB7XG4gICAgICAgICAgICB0eXBlOiBPYmplY3RcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogVGhlIHBhdGhuYW1lIGNvbXBvbmVudCBvZiB0aGUgY3VycmVudCBVUkwuXG4gICAgICAgICAgICovXG4gICAgICAgICAgX19wYXRoOiB7XG4gICAgICAgICAgICB0eXBlOiBTdHJpbmdcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogVGhlIHF1ZXJ5IHN0cmluZyBwb3J0aW9uIG9mIHRoZSBjdXJyZW50IFVSTC5cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBfX3F1ZXJ5OiB7XG4gICAgICAgICAgICB0eXBlOiBTdHJpbmdcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogVGhlIGhhc2ggcG9ydGlvbiBvZiB0aGUgY3VycmVudCBVUkwuXG4gICAgICAgICAgICovXG4gICAgICAgICAgX19oYXNoOiB7XG4gICAgICAgICAgICB0eXBlOiBTdHJpbmdcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogVGhlIHJvdXRlIHBhdGgsIHdoaWNoIHdpbGwgYmUgZWl0aGVyIHRoZSBoYXNoIG9yIHRoZSBwYXRoLCBkZXBlbmRpbmdcbiAgICAgICAgICAgKiBvbiB1c2VIYXNoQXNQYXRoLlxuICAgICAgICAgICAqL1xuICAgICAgICAgIHBhdGg6IHtcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICAgIG9ic2VydmVyOiAnX19vblBhdGhDaGFuZ2VkJ1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBXaGV0aGVyIG9yIG5vdCB0aGUgcmVhZHkgZnVuY3Rpb24gaGFzIGJlZW4gY2FsbGVkLlxuICAgICAgICAgICAqL1xuICAgICAgICAgIF9pc1JlYWR5OiB7XG4gICAgICAgICAgICB0eXBlOiBCb29sZWFuXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGJlaGF2aW9yczogW1BvbHltZXIuQXBwUm91dGVDb252ZXJ0ZXJCZWhhdmlvcl0sXG5cbiAgICAgICAgb2JzZXJ2ZXJzOiBbXG4gICAgICAgICAgJ19fY29tcHV0ZVJvdXRlUGF0aCh1c2VIYXNoQXNQYXRoLCBfX2hhc2gsIF9fcGF0aCknXG4gICAgICAgIF0sXG5cbiAgICAgICAgcmVhZHk6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHRoaXMuX2lzUmVhZHkgPSB0cnVlO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9fY29tcHV0ZVJvdXRlUGF0aDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdGhpcy5wYXRoID0gdGhpcy51c2VIYXNoQXNQYXRoID8gdGhpcy5fX2hhc2ggOiB0aGlzLl9fcGF0aDtcbiAgICAgICAgfSxcblxuICAgICAgICBfX29uUGF0aENoYW5nZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmICghdGhpcy5faXNSZWFkeSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0aGlzLnVzZUhhc2hBc1BhdGgpIHtcbiAgICAgICAgICAgIHRoaXMuX19oYXNoID0gdGhpcy5wYXRoO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9fcGF0aCA9IHRoaXMucGF0aDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pKCk7XG4gIDwvc2NyaXB0PlxuPC9kb20tbW9kdWxlPlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9hcHAtcm91dGUvYXBwLWxvY2F0aW9uLmh0bWwiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE1IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi9wb2x5bWVyL3BvbHltZXIuaHRtbFwiPlxuXG48IS0tXG5cblRoZSBgaXJvbi1sb2NhdGlvbmAgZWxlbWVudCBtYW5hZ2VzIGJpbmRpbmcgdG8gYW5kIGZyb20gdGhlIGN1cnJlbnQgVVJMLlxuXG5pcm9uLWxvY2F0aW9uIGlzIHRoZSBmaXJzdCwgYW5kIGxvd2VzdCBsZXZlbCBlbGVtZW50IGluIHRoZSBQb2x5bWVyIHRlYW0nc1xucm91dGluZyBzeXN0ZW0uIFRoaXMgaXMgYSBiZXRhIHJlbGVhc2Ugb2YgaXJvbi1sb2NhdGlvbiBhcyB3ZSBjb250aW51ZSB3b3JrXG5vbiBoaWdoZXIgbGV2ZWwgZWxlbWVudHMsIGFuZCBhcyBzdWNoIGlyb24tbG9jYXRpb24gbWF5IHVuZGVyZ28gYnJlYWtpbmdcbmNoYW5nZXMuXG5cbiMjIyMgUHJvcGVydGllc1xuXG5XaGVuIHRoZSBVUkwgaXM6IGAvc2VhcmNoP3F1ZXJ5PTU4MyNkZXRhaWxzYCBpcm9uLWxvY2F0aW9uJ3MgcHJvcGVydGllcyB3aWxsIGJlOlxuXG4gIC0gcGF0aDogYCcvc2VhcmNoJ2BcbiAgLSBxdWVyeTogYCdxdWVyeT01ODMnYFxuICAtIGhhc2g6IGAnZGV0YWlscydgXG5cblRoZXNlIGJpbmRpbmdzIGFyZSBiaWRpcmVjdGlvbmFsLiBNb2RpZnlpbmcgdGhlbSB3aWxsIGluIHR1cm4gbW9kaWZ5IHRoZSBVUkwuXG5cbmlyb24tbG9jYXRpb24gaXMgb25seSBhY3RpdmUgd2hpbGUgaXQgaXMgYXR0YWNoZWQgdG8gdGhlIGRvY3VtZW50LlxuXG4jIyMjIExpbmtzXG5cbldoaWxlIGlyb24tbG9jYXRpb24gaXMgYWN0aXZlIGluIHRoZSBkb2N1bWVudCBpdCB3aWxsIGludGVyY2VwdCBjbGlja3Mgb24gbGlua3NcbndpdGhpbiB5b3VyIHNpdGUsIHVwZGF0aW5nIHRoZSBVUkwgcHVzaGluZyB0aGUgdXBkYXRlZCBVUkwgb3V0IHRocm91Z2ggdGhlXG5kYXRhYmluZGluZyBzeXN0ZW0uIGlyb24tbG9jYXRpb24gb25seSBpbnRlcmNlcHRzIGNsaWNrcyB3aXRoIHRoZSBpbnRlbnQgdG9cbm9wZW4gaW4gdGhlIHNhbWUgd2luZG93LCBzbyBtaWRkbGUgbW91c2UgY2xpY2tzIGFuZCBjdHJsL2NtZCBjbGlja3Mgd29yayBmaW5lLlxuXG5Zb3UgY2FuIGN1c3RvbWl6ZSB0aGlzIGJlaGF2aW9yIHdpdGggdGhlIGB1cmxTcGFjZVJlZ2V4YC5cblxuIyMjIyBEd2VsbCBUaW1lXG5cbmlyb24tbG9jYXRpb24gcHJvdGVjdHMgYWdhaW5zdCBhY2NpZGVudGFsIGhpc3Rvcnkgc3BhbW1pbmcgYnkgb25seSBhZGRpbmdcbmVudHJpZXMgdG8gdGhlIHVzZXIncyBoaXN0b3J5IGlmIHRoZSBVUkwgc3RheXMgdW5jaGFuZ2VkIGZvciBgZHdlbGxUaW1lYFxubWlsbGlzZWNvbmRzLlxuXG5AZGVtbyBkZW1vL2luZGV4Lmh0bWxcblxuIC0tPlxuPHNjcmlwdD5cbiAgKGZ1bmN0aW9uKCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciB3b3JraW5nVVJMO1xuXG4gICAgdmFyIHVybERvYywgdXJsQmFzZSwgYW5jaG9yO1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGhcbiAgICAgKiBAcGFyYW0ge3N0cmluZz19IGJhc2VcbiAgICAgKiBAcmV0dXJuIHshVVJMfCFIVE1MQW5jaG9yRWxlbWVudH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXNvbHZlVVJMKHBhdGgsIGJhc2UpIHtcbiAgICAgIGlmICh3b3JraW5nVVJMID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgd29ya2luZ1VSTCA9IGZhbHNlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciB1ID0gbmV3IFVSTCgnYicsICdodHRwOi8vYScpO1xuICAgICAgICAgIHUucGF0aG5hbWUgPSAnYyUyMGQnO1xuICAgICAgICAgIHdvcmtpbmdVUkwgPSAodS5ocmVmID09PSAnaHR0cDovL2EvYyUyMGQnKTtcbiAgICAgICAgICB3b3JraW5nVVJMID0gd29ya2luZ1VSTCAmJiAobmV3IFVSTCgnaHR0cDovL3d3dy5nb29nbGUuY29tLz9mb28gYmFyJykuaHJlZiA9PT0gJ2h0dHA6Ly93d3cuZ29vZ2xlLmNvbS8/Zm9vJTIwYmFyJyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICB9XG4gICAgICBpZiAod29ya2luZ1VSTCkge1xuICAgICAgICByZXR1cm4gbmV3IFVSTChwYXRoLCBiYXNlKTtcbiAgICAgIH1cbiAgICAgIGlmICghdXJsRG9jKSB7XG4gICAgICAgIHVybERvYyA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudCgndXJsJyk7XG4gICAgICAgIHVybEJhc2UgPSB1cmxEb2MuY3JlYXRlRWxlbWVudCgnYmFzZScpO1xuICAgICAgICB1cmxEb2MuaGVhZC5hcHBlbmRDaGlsZCh1cmxCYXNlKTtcbiAgICAgICAgYW5jaG9yID0gLyoqIEB0eXBlIHtIVE1MQW5jaG9yRWxlbWVudH0qLyh1cmxEb2MuY3JlYXRlRWxlbWVudCgnYScpKTtcbiAgICAgIH1cbiAgICAgIHVybEJhc2UuaHJlZiA9IGJhc2U7XG4gICAgICBhbmNob3IuaHJlZiA9IHBhdGgucmVwbGFjZSgvIC9nLCAnJTIwJyk7XG4gICAgICByZXR1cm4gYW5jaG9yO1xuICAgIH1cblxuICAgIFBvbHltZXIoe1xuICAgICAgaXM6ICdpcm9uLWxvY2F0aW9uJyxcblxuICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHBhdGhuYW1lIGNvbXBvbmVudCBvZiB0aGUgVVJMLlxuICAgICAgICAgKi9cbiAgICAgICAgcGF0aDoge1xuICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICBub3RpZnk6IHRydWUsXG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5kZWNvZGVVUklDb21wb25lbnQod2luZG93LmxvY2F0aW9uLnBhdGhuYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBxdWVyeSBzdHJpbmcgcG9ydGlvbiBvZiB0aGUgVVJMLlxuICAgICAgICAgKi9cbiAgICAgICAgcXVlcnk6IHtcbiAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgbm90aWZ5OiB0cnVlLFxuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB3aW5kb3cubG9jYXRpb24uc2VhcmNoLnNsaWNlKDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGhhc2ggY29tcG9uZW50IG9mIHRoZSBVUkwuXG4gICAgICAgICAqL1xuICAgICAgICBoYXNoOiB7XG4gICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgIG5vdGlmeTogdHJ1ZSxcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gd2luZG93LmRlY29kZVVSSUNvbXBvbmVudCh3aW5kb3cubG9jYXRpb24uaGFzaC5zbGljZSgxKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0aGUgdXNlciB3YXMgb24gYSBVUkwgZm9yIGxlc3MgdGhhbiBgZHdlbGxUaW1lYCBtaWxsaXNlY29uZHMsIGl0XG4gICAgICAgICAqIHdvbid0IGJlIGFkZGVkIHRvIHRoZSBicm93c2VyJ3MgaGlzdG9yeSwgYnV0IGluc3RlYWQgd2lsbCBiZSByZXBsYWNlZFxuICAgICAgICAgKiBieSB0aGUgbmV4dCBlbnRyeS5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBpcyB0byBwcmV2ZW50IGxhcmdlIG51bWJlcnMgb2YgZW50cmllcyBmcm9tIGNsb2dnaW5nIHVwIHRoZSB1c2VyJ3NcbiAgICAgICAgICogYnJvd3NlciBoaXN0b3J5LiBEaXNhYmxlIGJ5IHNldHRpbmcgdG8gYSBuZWdhdGl2ZSBudW1iZXIuXG4gICAgICAgICAqL1xuICAgICAgICBkd2VsbFRpbWU6IHtcbiAgICAgICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICAgICAgdmFsdWU6IDIwMDBcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQSByZWdleHAgdGhhdCBkZWZpbmVzIHRoZSBzZXQgb2YgVVJMcyB0aGF0IHNob3VsZCBiZSBjb25zaWRlcmVkIHBhcnRcbiAgICAgICAgICogb2YgdGhpcyB3ZWIgYXBwLlxuICAgICAgICAgKlxuICAgICAgICAgKiBDbGlja2luZyBvbiBhIGxpbmsgdGhhdCBtYXRjaGVzIHRoaXMgcmVnZXggd29uJ3QgcmVzdWx0IGluIGEgZnVsbCBwYWdlXG4gICAgICAgICAqIG5hdmlnYXRpb24sIGJ1dCB3aWxsIGluc3RlYWQganVzdCB1cGRhdGUgdGhlIFVSTCBzdGF0ZSBpbiBwbGFjZS5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyByZWdleHAgaXMgZ2l2ZW4gZXZlcnl0aGluZyBhZnRlciB0aGUgb3JpZ2luIGluIGFuIGFic29sdXRlXG4gICAgICAgICAqIFVSTC4gU28gdG8gbWF0Y2gganVzdCBVUkxzIHRoYXQgc3RhcnQgd2l0aCAvc2VhcmNoLyBkbzpcbiAgICAgICAgICogICAgIHVybC1zcGFjZS1yZWdleD1cIl4vc2VhcmNoL1wiXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd8UmVnRXhwfVxuICAgICAgICAgKi9cbiAgICAgICAgdXJsU3BhY2VSZWdleDoge1xuICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICB2YWx1ZTogJydcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogdXJsU3BhY2VSZWdleCwgYnV0IGNvZXJjZWQgaW50byBhIHJlZ2V4cC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUge1JlZ0V4cH1cbiAgICAgICAgICovXG4gICAgICAgIF91cmxTcGFjZVJlZ0V4cDoge1xuICAgICAgICAgIGNvbXB1dGVkOiAnX21ha2VSZWdFeHAodXJsU3BhY2VSZWdleCknXG4gICAgICAgIH0sXG5cbiAgICAgICAgX2xhc3RDaGFuZ2VkQXQ6IHtcbiAgICAgICAgICB0eXBlOiBOdW1iZXJcbiAgICAgICAgfSxcblxuICAgICAgICBfaW5pdGlhbGl6ZWQ6IHtcbiAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBob3N0QXR0cmlidXRlczoge1xuICAgICAgICBoaWRkZW46IHRydWVcbiAgICAgIH0sXG5cbiAgICAgIG9ic2VydmVyczogW1xuICAgICAgICAnX3VwZGF0ZVVybChwYXRoLCBxdWVyeSwgaGFzaCknXG4gICAgICBdLFxuXG4gICAgICBhdHRhY2hlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMubGlzdGVuKHdpbmRvdywgJ2hhc2hjaGFuZ2UnLCAnX2hhc2hDaGFuZ2VkJyk7XG4gICAgICAgIHRoaXMubGlzdGVuKHdpbmRvdywgJ2xvY2F0aW9uLWNoYW5nZWQnLCAnX3VybENoYW5nZWQnKTtcbiAgICAgICAgdGhpcy5saXN0ZW4od2luZG93LCAncG9wc3RhdGUnLCAnX3VybENoYW5nZWQnKTtcbiAgICAgICAgdGhpcy5saXN0ZW4oLyoqIEB0eXBlIHshSFRNTEJvZHlFbGVtZW50fSAqLyhkb2N1bWVudC5ib2R5KSwgJ2NsaWNrJywgJ19nbG9iYWxPbkNsaWNrJyk7XG4gICAgICAgIC8vIEdpdmUgYSAyMDBtcyBncmFjZSBwZXJpb2QgdG8gbWFrZSBpbml0aWFsIHJlZGlyZWN0cyB3aXRob3V0IGFueVxuICAgICAgICAvLyBhZGRpdGlvbnMgdG8gdGhlIHVzZXIncyBoaXN0b3J5LlxuICAgICAgICB0aGlzLl9sYXN0Q2hhbmdlZEF0ID0gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpIC0gKHRoaXMuZHdlbGxUaW1lIC0gMjAwKTtcbiAgICAgICAgdGhpcy5faW5pdGlhbGl6ZWQgPSB0cnVlO1xuXG4gICAgICAgIHRoaXMuX3VybENoYW5nZWQoKTtcbiAgICAgIH0sXG5cbiAgICAgIGRldGFjaGVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy51bmxpc3Rlbih3aW5kb3csICdoYXNoY2hhbmdlJywgJ19oYXNoQ2hhbmdlZCcpO1xuICAgICAgICB0aGlzLnVubGlzdGVuKHdpbmRvdywgJ2xvY2F0aW9uLWNoYW5nZWQnLCAnX3VybENoYW5nZWQnKTtcbiAgICAgICAgdGhpcy51bmxpc3Rlbih3aW5kb3csICdwb3BzdGF0ZScsICdfdXJsQ2hhbmdlZCcpO1xuICAgICAgICB0aGlzLnVubGlzdGVuKC8qKiBAdHlwZSB7IUhUTUxCb2R5RWxlbWVudH0gKi8oZG9jdW1lbnQuYm9keSksICdjbGljaycsICdfZ2xvYmFsT25DbGljaycpO1xuICAgICAgICB0aGlzLl9pbml0aWFsaXplZCA9IGZhbHNlO1xuICAgICAgfSxcblxuICAgICAgX2hhc2hDaGFuZ2VkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5oYXNoID0gd2luZG93LmRlY29kZVVSSUNvbXBvbmVudCh3aW5kb3cubG9jYXRpb24uaGFzaC5zdWJzdHJpbmcoMSkpO1xuICAgICAgfSxcblxuICAgICAgX3VybENoYW5nZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBXZSB3YW50IHRvIGV4dHJhY3QgYWxsIGluZm8gb3V0IG9mIHRoZSB1cGRhdGVkIFVSTCBiZWZvcmUgd2VcbiAgICAgICAgLy8gdHJ5IHRvIHdyaXRlIGFueXRoaW5nIGJhY2sgaW50byBpdC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gaS5lLiB3aXRob3V0IF9kb250VXBkYXRlVXJsIHdlJ2Qgb3ZlcndyaXRlIHRoZSBuZXcgcGF0aCB3aXRoIHRoZSBvbGRcbiAgICAgICAgLy8gb25lIHdoZW4gd2Ugc2V0IHRoaXMuaGFzaC4gTGlrZXdpc2UgZm9yIHF1ZXJ5LlxuICAgICAgICB0aGlzLl9kb250VXBkYXRlVXJsID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5faGFzaENoYW5nZWQoKTtcbiAgICAgICAgdGhpcy5wYXRoID0gd2luZG93LmRlY29kZVVSSUNvbXBvbmVudCh3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUpO1xuICAgICAgICB0aGlzLnF1ZXJ5ID0gd2luZG93LmxvY2F0aW9uLnNlYXJjaC5zdWJzdHJpbmcoMSk7XG4gICAgICAgIHRoaXMuX2RvbnRVcGRhdGVVcmwgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fdXBkYXRlVXJsKCk7XG4gICAgICB9LFxuXG4gICAgICBfZ2V0VXJsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBhcnRpYWxseUVuY29kZWRQYXRoID0gd2luZG93LmVuY29kZVVSSShcbiAgICAgICAgICAgIHRoaXMucGF0aCkucmVwbGFjZSgvXFwjL2csICclMjMnKS5yZXBsYWNlKC9cXD8vZywgJyUzRicpO1xuICAgICAgICB2YXIgcGFydGlhbGx5RW5jb2RlZFF1ZXJ5ID0gJyc7XG4gICAgICAgIGlmICh0aGlzLnF1ZXJ5KSB7XG4gICAgICAgICAgcGFydGlhbGx5RW5jb2RlZFF1ZXJ5ID0gJz8nICsgdGhpcy5xdWVyeS5yZXBsYWNlKC9cXCMvZywgJyUyMycpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwYXJ0aWFsbHlFbmNvZGVkSGFzaCA9ICcnO1xuICAgICAgICBpZiAodGhpcy5oYXNoKSB7XG4gICAgICAgICAgcGFydGlhbGx5RW5jb2RlZEhhc2ggPSAnIycgKyB3aW5kb3cuZW5jb2RlVVJJKHRoaXMuaGFzaCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHBhcnRpYWxseUVuY29kZWRQYXRoICsgcGFydGlhbGx5RW5jb2RlZFF1ZXJ5ICsgcGFydGlhbGx5RW5jb2RlZEhhc2gpO1xuICAgICAgfSxcblxuICAgICAgX3VwZGF0ZVVybDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl9kb250VXBkYXRlVXJsIHx8ICF0aGlzLl9pbml0aWFsaXplZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnBhdGggPT09IHdpbmRvdy5kZWNvZGVVUklDb21wb25lbnQod2luZG93LmxvY2F0aW9uLnBhdGhuYW1lKSAmJlxuICAgICAgICAgICAgdGhpcy5xdWVyeSA9PT0gd2luZG93LmxvY2F0aW9uLnNlYXJjaC5zdWJzdHJpbmcoMSkgJiZcbiAgICAgICAgICAgIHRoaXMuaGFzaCA9PT0gd2luZG93LmRlY29kZVVSSUNvbXBvbmVudChcbiAgICAgICAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaGFzaC5zdWJzdHJpbmcoMSkpKSB7XG4gICAgICAgICAgLy8gTm90aGluZyB0byBkbywgdGhlIGN1cnJlbnQgVVJMIGlzIGEgcmVwcmVzZW50YXRpb24gb2Ygb3VyIHByb3BlcnRpZXMuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5ld1VybCA9IHRoaXMuX2dldFVybCgpO1xuICAgICAgICAvLyBOZWVkIHRvIHVzZSBhIGZ1bGwgVVJMIGluIGNhc2UgdGhlIGNvbnRhaW5pbmcgcGFnZSBoYXMgYSBiYXNlIFVSSS5cbiAgICAgICAgdmFyIGZ1bGxOZXdVcmwgPSByZXNvbHZlVVJMKG5ld1VybCwgd2luZG93LmxvY2F0aW9uLnByb3RvY29sICsgJy8vJyArIHdpbmRvdy5sb2NhdGlvbi5ob3N0KS5ocmVmO1xuICAgICAgICB2YXIgbm93ID0gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICB2YXIgc2hvdWxkUmVwbGFjZSA9IHRoaXMuX2xhc3RDaGFuZ2VkQXQgKyB0aGlzLmR3ZWxsVGltZSA+IG5vdztcbiAgICAgICAgdGhpcy5fbGFzdENoYW5nZWRBdCA9IG5vdztcblxuICAgICAgICBpZiAoc2hvdWxkUmVwbGFjZSkge1xuICAgICAgICAgIHdpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZSh7fSwgJycsIGZ1bGxOZXdVcmwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZSh7fSwgJycsIGZ1bGxOZXdVcmwpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5maXJlKCdsb2NhdGlvbi1jaGFuZ2VkJywge30sIHtub2RlOiB3aW5kb3d9KTtcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogQSBuZWNlc3NhcnkgZXZpbCBzbyB0aGF0IGxpbmtzIHdvcmsgYXMgZXhwZWN0ZWQuIERvZXMgaXRzIGJlc3QgdG9cbiAgICAgICAqIGJhaWwgb3V0IGVhcmx5IGlmIHBvc3NpYmxlLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZXZlbnQgLlxuICAgICAgICovXG4gICAgICBfZ2xvYmFsT25DbGljazogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgLy8gSWYgYW5vdGhlciBldmVudCBoYW5kbGVyIGhhcyBzdG9wcGVkIHRoaXMgZXZlbnQgdGhlbiB0aGVyZSdzIG5vdGhpbmdcbiAgICAgICAgLy8gZm9yIHVzIHRvIGRvLiBUaGlzIGNhbiBoYXBwZW4gZS5nLiB3aGVuIHRoZXJlIGFyZSBtdWx0aXBsZVxuICAgICAgICAvLyBpcm9uLWxvY2F0aW9uIGVsZW1lbnRzIGluIGEgcGFnZS5cbiAgICAgICAgaWYgKGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaHJlZiA9IHRoaXMuX2dldFNhbWVPcmlnaW5MaW5rSHJlZihldmVudCk7XG5cbiAgICAgICAgaWYgKCFocmVmKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAvLyBJZiB0aGUgbmF2aWdhdGlvbiBpcyB0byB0aGUgY3VycmVudCBwYWdlIHdlIHNob3VsZG4ndCBhZGQgYSBoaXN0b3J5XG4gICAgICAgIC8vIGVudHJ5IG9yIGZpcmUgYSBjaGFuZ2UgZXZlbnQuXG4gICAgICAgIGlmIChocmVmID09PSB3aW5kb3cubG9jYXRpb24uaHJlZikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZSh7fSwgJycsIGhyZWYpO1xuICAgICAgICB0aGlzLmZpcmUoJ2xvY2F0aW9uLWNoYW5nZWQnLCB7fSwge25vZGU6IHdpbmRvd30pO1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBSZXR1cm5zIHRoZSBhYnNvbHV0ZSBVUkwgb2YgdGhlIGxpbmsgKGlmIGFueSkgdGhhdCB0aGlzIGNsaWNrIGV2ZW50XG4gICAgICAgKiBpcyBjbGlja2luZyBvbiwgaWYgd2UgY2FuIGFuZCBzaG91bGQgb3ZlcnJpZGUgdGhlIHJlc3VsdGluZyBmdWxsXG4gICAgICAgKiBwYWdlIG5hdmlnYXRpb24uIFJldHVybnMgbnVsbCBvdGhlcndpc2UuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBldmVudCAuXG4gICAgICAgKiBAcmV0dXJuIHtzdHJpbmc/fSAuXG4gICAgICAgKi9cbiAgICAgIF9nZXRTYW1lT3JpZ2luTGlua0hyZWY6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIC8vIFdlIG9ubHkgY2FyZSBhYm91dCBsZWZ0LWNsaWNrcy5cbiAgICAgICAgaWYgKGV2ZW50LmJ1dHRvbiAhPT0gMCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gV2UgZG9uJ3Qgd2FudCBtb2RpZmllZCBjbGlja3MsIHdoZXJlIHRoZSBpbnRlbnQgaXMgdG8gb3BlbiB0aGUgcGFnZVxuICAgICAgICAvLyBpbiBhIG5ldyB0YWIuXG4gICAgICAgIGlmIChldmVudC5tZXRhS2V5IHx8IGV2ZW50LmN0cmxLZXkpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBldmVudFBhdGggPSBQb2x5bWVyLmRvbShldmVudCkucGF0aDtcbiAgICAgICAgdmFyIGFuY2hvciA9IG51bGw7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBldmVudFBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgZWxlbWVudCA9IGV2ZW50UGF0aFtpXTtcblxuICAgICAgICAgIGlmIChlbGVtZW50LnRhZ05hbWUgPT09ICdBJyAmJiBlbGVtZW50LmhyZWYpIHtcbiAgICAgICAgICAgIGFuY2hvciA9IGVsZW1lbnQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGVyZSdzIG5vIGxpbmsgdGhlcmUncyBub3RoaW5nIHRvIGRvLlxuICAgICAgICBpZiAoIWFuY2hvcikge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGFyZ2V0IGJsYW5rIGlzIGEgbmV3IHRhYiwgZG9uJ3QgaW50ZXJjZXB0LlxuICAgICAgICBpZiAoYW5jaG9yLnRhcmdldCA9PT0gJ19ibGFuaycpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHRoZSBsaW5rIGlzIGZvciBhbiBleGlzdGluZyBwYXJlbnQgZnJhbWUsIGRvbid0IGludGVyY2VwdC5cbiAgICAgICAgaWYgKChhbmNob3IudGFyZ2V0ID09PSAnX3RvcCcgfHxcbiAgICAgICAgICAgIGFuY2hvci50YXJnZXQgPT09ICdfcGFyZW50JykgJiZcbiAgICAgICAgICAgIHdpbmRvdy50b3AgIT09IHdpbmRvdykge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGhyZWYgPSBhbmNob3IuaHJlZjtcblxuICAgICAgICAvLyBJdCBvbmx5IG1ha2VzIHNlbnNlIGZvciB1cyB0byBpbnRlcmNlcHQgc2FtZS1vcmlnaW4gbmF2aWdhdGlvbnMuXG4gICAgICAgIC8vIHB1c2hTdGF0ZS9yZXBsYWNlU3RhdGUgZG9uJ3Qgd29yayB3aXRoIGNyb3NzLW9yaWdpbiBsaW5rcy5cbiAgICAgICAgdmFyIHVybDtcblxuICAgICAgICBpZiAoZG9jdW1lbnQuYmFzZVVSSSAhPSBudWxsKSB7XG4gICAgICAgICAgdXJsID0gcmVzb2x2ZVVSTChocmVmLCAvKiogQHR5cGUge3N0cmluZ30gKi8oZG9jdW1lbnQuYmFzZVVSSSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHVybCA9IHJlc29sdmVVUkwoaHJlZik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgb3JpZ2luO1xuXG4gICAgICAgIC8vIElFIFBvbHlmaWxsXG4gICAgICAgIGlmICh3aW5kb3cubG9jYXRpb24ub3JpZ2luKSB7XG4gICAgICAgICAgb3JpZ2luID0gd2luZG93LmxvY2F0aW9uLm9yaWdpbjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvcmlnaW4gPSB3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wgKyAnLy8nICsgd2luZG93LmxvY2F0aW9uLmhvc3Q7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdXJsT3JpZ2luO1xuXG4gICAgICAgIGlmICh1cmwub3JpZ2luKSB7XG4gICAgICAgICAgdXJsT3JpZ2luID0gdXJsLm9yaWdpbjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB1cmxPcmlnaW4gPSB1cmwucHJvdG9jb2wgKyAnLy8nICsgdXJsLmhvc3Q7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodXJsT3JpZ2luICE9PSBvcmlnaW4pIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBub3JtYWxpemVkSHJlZiA9IHVybC5wYXRobmFtZSArIHVybC5zZWFyY2ggKyB1cmwuaGFzaDtcblxuICAgICAgICAvLyBwYXRobmFtZSBzaG91bGQgc3RhcnQgd2l0aCAnLycsIGJ1dCBtYXkgbm90IGlmIGBuZXcgVVJMYCBpcyBub3Qgc3VwcG9ydGVkXG4gICAgICAgIGlmIChub3JtYWxpemVkSHJlZlswXSAhPT0gJy8nKSB7XG4gICAgICAgICAgbm9ybWFsaXplZEhyZWYgPSAnLycgKyBub3JtYWxpemVkSHJlZjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHdlJ3ZlIGJlZW4gY29uZmlndXJlZCBub3QgdG8gaGFuZGxlIHRoaXMgdXJsLi4uIGRvbid0IGhhbmRsZSBpdCFcbiAgICAgICAgaWYgKHRoaXMuX3VybFNwYWNlUmVnRXhwICYmXG4gICAgICAgICAgICAhdGhpcy5fdXJsU3BhY2VSZWdFeHAudGVzdChub3JtYWxpemVkSHJlZikpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE5lZWQgdG8gdXNlIGEgZnVsbCBVUkwgaW4gY2FzZSB0aGUgY29udGFpbmluZyBwYWdlIGhhcyBhIGJhc2UgVVJJLlxuICAgICAgICB2YXIgZnVsbE5vcm1hbGl6ZWRIcmVmID0gcmVzb2x2ZVVSTChcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRIcmVmLCB3aW5kb3cubG9jYXRpb24uaHJlZikuaHJlZjtcbiAgICAgICAgcmV0dXJuIGZ1bGxOb3JtYWxpemVkSHJlZjtcbiAgICAgIH0sXG5cbiAgICAgIF9tYWtlUmVnRXhwOiBmdW5jdGlvbih1cmxTcGFjZVJlZ2V4KSB7XG4gICAgICAgIHJldHVybiBSZWdFeHAodXJsU3BhY2VSZWdleCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pKCk7XG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvaXJvbi1sb2NhdGlvbi9pcm9uLWxvY2F0aW9uLmh0bWwiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE1IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuXG5AZGVtbyBkZW1vL2lyb24tcXVlcnktcGFyYW1zLmh0bWxcbi0tPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3BvbHltZXIvcG9seW1lci5odG1sXCI+XG5cbjxzY3JpcHQ+XG4gICd1c2Ugc3RyaWN0JztcblxuICBQb2x5bWVyKHtcbiAgICBpczogJ2lyb24tcXVlcnktcGFyYW1zJyxcblxuICAgIHByb3BlcnRpZXM6IHtcbiAgICAgIHBhcmFtc1N0cmluZzoge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIG5vdGlmeTogdHJ1ZSxcbiAgICAgICAgb2JzZXJ2ZXI6ICdwYXJhbXNTdHJpbmdDaGFuZ2VkJyxcbiAgICAgIH0sXG5cbiAgICAgIHBhcmFtc09iamVjdDoge1xuICAgICAgICB0eXBlOiBPYmplY3QsXG4gICAgICAgIG5vdGlmeTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgX2RvbnRSZWFjdDoge1xuICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgaG9zdEF0dHJpYnV0ZXM6IHtcbiAgICAgIGhpZGRlbjogdHJ1ZVxuICAgIH0sXG5cbiAgICBvYnNlcnZlcnM6IFtcbiAgICAgICdwYXJhbXNPYmplY3RDaGFuZ2VkKHBhcmFtc09iamVjdC4qKSdcbiAgICBdLFxuXG4gICAgcGFyYW1zU3RyaW5nQ2hhbmdlZDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9kb250UmVhY3QgPSB0cnVlO1xuICAgICAgdGhpcy5wYXJhbXNPYmplY3QgPSB0aGlzLl9kZWNvZGVQYXJhbXModGhpcy5wYXJhbXNTdHJpbmcpO1xuICAgICAgdGhpcy5fZG9udFJlYWN0ID0gZmFsc2U7XG4gICAgfSxcblxuICAgIHBhcmFtc09iamVjdENoYW5nZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuX2RvbnRSZWFjdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLnBhcmFtc1N0cmluZyA9IHRoaXMuX2VuY29kZVBhcmFtcyh0aGlzLnBhcmFtc09iamVjdClcbiAgICAgICAgICAucmVwbGFjZSgvJTNGL2csICc/JykucmVwbGFjZSgvJTJGL2csICcvJykucmVwbGFjZSgvJy9nLCAnJTI3Jyk7XG4gICAgfSxcblxuICAgIF9lbmNvZGVQYXJhbXM6IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgdmFyIGVuY29kZWRQYXJhbXMgPSBbXTtcblxuICAgICAgZm9yICh2YXIga2V5IGluIHBhcmFtcykge1xuICAgICAgICB2YXIgdmFsdWUgPSBwYXJhbXNba2V5XTtcblxuICAgICAgICBpZiAodmFsdWUgPT09ICcnKSB7XG4gICAgICAgICAgZW5jb2RlZFBhcmFtcy5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChrZXkpKTtcblxuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgZW5jb2RlZFBhcmFtcy5wdXNoKFxuICAgICAgICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoa2V5KSArXG4gICAgICAgICAgICAgICc9JyArXG4gICAgICAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZS50b1N0cmluZygpKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBlbmNvZGVkUGFyYW1zLmpvaW4oJyYnKTtcbiAgICB9LFxuXG4gICAgX2RlY29kZVBhcmFtczogZnVuY3Rpb24ocGFyYW1TdHJpbmcpIHtcbiAgICAgIHZhciBwYXJhbXMgPSB7fTtcbiAgICAgIC8vIFdvcmsgYXJvdW5kIGEgYnVnIGluIGRlY29kZVVSSUNvbXBvbmVudCB3aGVyZSArIGlzIG5vdFxuICAgICAgLy8gY29udmVydGVkIHRvIHNwYWNlczpcbiAgICAgIHBhcmFtU3RyaW5nID0gKHBhcmFtU3RyaW5nIHx8ICcnKS5yZXBsYWNlKC9cXCsvZywgJyUyMCcpO1xuICAgICAgdmFyIHBhcmFtTGlzdCA9IHBhcmFtU3RyaW5nLnNwbGl0KCcmJyk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmFtTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcGFyYW0gPSBwYXJhbUxpc3RbaV0uc3BsaXQoJz0nKTtcbiAgICAgICAgaWYgKHBhcmFtWzBdKSB7XG4gICAgICAgICAgcGFyYW1zW2RlY29kZVVSSUNvbXBvbmVudChwYXJhbVswXSldID1cbiAgICAgICAgICAgICAgZGVjb2RlVVJJQ29tcG9uZW50KHBhcmFtWzFdIHx8ICcnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICB9XG4gIH0pO1xuPC9zY3JpcHQ+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL2lyb24tbG9jYXRpb24vaXJvbi1xdWVyeS1wYXJhbXMuaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTYgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cbjxzY3JpcHQ+XG4gIChmdW5jdGlvbigpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICAvKipcbiAgICAgKiBQcm92aWRlcyBiaWRpcmVjdGlvbmFsIG1hcHBpbmcgYmV0d2VlbiBgcGF0aGAgYW5kIGBxdWVyeVBhcmFtc2AgYW5kIGFcbiAgICAgKiBhcHAtcm91dGUgY29tcGF0aWJsZSBgcm91dGVgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWUgdGhlIGRvY3MgZm9yIGBhcHAtcm91dGUtY29udmVydGVyYC5cbiAgICAgKlxuICAgICAqIEBwb2x5bWVyQmVoYXZpb3JcbiAgICAgKi9cbiAgICBQb2x5bWVyLkFwcFJvdXRlQ29udmVydGVyQmVoYXZpb3IgPSB7XG4gICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIG1vZGVsIHJlcHJlc2VudGluZyB0aGUgZGVzZXJpYWxpemVkIHBhdGggdGhyb3VnaCB0aGUgcm91dGUgdHJlZSwgYXNcbiAgICAgICAgICogd2VsbCBhcyB0aGUgY3VycmVudCBxdWVyeVBhcmFtcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQSByb3V0ZSBvYmplY3QgaXMgdGhlIGtlcm5lbCBvZiB0aGUgcm91dGluZyBzeXN0ZW0uIEl0IGlzIGludGVuZGVkIHRvXG4gICAgICAgICAqIGJlIGZlZCBpbnRvIGNvbnN1bWluZyBlbGVtZW50cyBzdWNoIGFzIGBhcHAtcm91dGVgLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7P09iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIHJvdXRlOiB7XG4gICAgICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgICAgIG5vdGlmeTogdHJ1ZVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHNldCBvZiBrZXkvdmFsdWUgcGFpcnMgdGhhdCBhcmUgdW5pdmVyc2FsbHkgYWNjZXNzaWJsZSB0byBicmFuY2hlcyBvZlxuICAgICAgICAgKiB0aGUgcm91dGUgdHJlZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUgez9PYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICBxdWVyeVBhcmFtczoge1xuICAgICAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgICAgICBub3RpZnk6IHRydWVcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHNlcmlhbGl6ZWQgcGF0aCB0aHJvdWdoIHRoZSByb3V0ZSB0cmVlLiBUaGlzIGNvcnJlc3BvbmRzIHRvIHRoZVxuICAgICAgICAgKiBgd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lYCB2YWx1ZSwgYW5kIHdpbGwgdXBkYXRlIHRvIHJlZmxlY3QgY2hhbmdlc1xuICAgICAgICAgKiB0byB0aGF0IHZhbHVlLlxuICAgICAgICAgKi9cbiAgICAgICAgcGF0aDoge1xuICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICBub3RpZnk6IHRydWUsXG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIG9ic2VydmVyczogW1xuICAgICAgICAnX2xvY2F0aW9uQ2hhbmdlZChwYXRoLCBxdWVyeVBhcmFtcyknLFxuICAgICAgICAnX3JvdXRlQ2hhbmdlZChyb3V0ZS5wcmVmaXgsIHJvdXRlLnBhdGgpJyxcbiAgICAgICAgJ19yb3V0ZVF1ZXJ5UGFyYW1zQ2hhbmdlZChyb3V0ZS5fX3F1ZXJ5UGFyYW1zKSdcbiAgICAgIF0sXG5cbiAgICAgIGNyZWF0ZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmxpbmtQYXRocygncm91dGUuX19xdWVyeVBhcmFtcycsICdxdWVyeVBhcmFtcycpO1xuICAgICAgICB0aGlzLmxpbmtQYXRocygncXVlcnlQYXJhbXMnLCAncm91dGUuX19xdWVyeVBhcmFtcycpO1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBIYW5kbGVyIGNhbGxlZCB3aGVuIHRoZSBwYXRoIG9yIHF1ZXJ5UGFyYW1zIGNoYW5nZS5cbiAgICAgICAqL1xuICAgICAgX2xvY2F0aW9uQ2hhbmdlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLnJvdXRlICYmXG4gICAgICAgICAgICB0aGlzLnJvdXRlLnBhdGggPT09IHRoaXMucGF0aCAmJlxuICAgICAgICAgICAgdGhpcy5xdWVyeVBhcmFtcyA9PT0gdGhpcy5yb3V0ZS5fX3F1ZXJ5UGFyYW1zKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucm91dGUgPSB7XG4gICAgICAgICAgcHJlZml4OiAnJyxcbiAgICAgICAgICBwYXRoOiB0aGlzLnBhdGgsXG4gICAgICAgICAgX19xdWVyeVBhcmFtczogdGhpcy5xdWVyeVBhcmFtc1xuICAgICAgICB9O1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBIYW5kbGVyIGNhbGxlZCB3aGVuIHRoZSByb3V0ZSBwcmVmaXggYW5kIHJvdXRlIHBhdGggY2hhbmdlLlxuICAgICAgICovXG4gICAgICBfcm91dGVDaGFuZ2VkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLnJvdXRlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5wYXRoID0gdGhpcy5yb3V0ZS5wcmVmaXggKyB0aGlzLnJvdXRlLnBhdGg7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIEhhbmRsZXIgY2FsbGVkIHdoZW4gdGhlIHJvdXRlIHF1ZXJ5UGFyYW1zIGNoYW5nZS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0gIHtPYmplY3R9IHF1ZXJ5UGFyYW1zIEEgc2V0IG9mIGtleS92YWx1ZSBwYWlycyB0aGF0IGFyZVxuICAgICAgICogdW5pdmVyc2FsbHkgYWNjZXNzaWJsZSB0byBicmFuY2hlcyBvZiB0aGUgcm91dGUgdHJlZS5cbiAgICAgICAqL1xuICAgICAgX3JvdXRlUXVlcnlQYXJhbXNDaGFuZ2VkOiBmdW5jdGlvbihxdWVyeVBhcmFtcykge1xuICAgICAgICBpZiAoIXRoaXMucm91dGUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5xdWVyeVBhcmFtcyA9IHF1ZXJ5UGFyYW1zO1xuICAgICAgfVxuICAgIH07XG4gIH0pKCk7XG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvYXBwLXJvdXRlL2FwcC1yb3V0ZS1jb252ZXJ0ZXItYmVoYXZpb3IuaHRtbCIsIjwhLS1cbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTYgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4tLT5cblxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3BvbHltZXIvcG9seW1lci5odG1sXCI+XG5cbjwhLS1cbmBhcHAtcm91dGVgIGlzIGFuIGVsZW1lbnQgdGhhdCBlbmFibGVzIGRlY2xhcmF0aXZlLCBzZWxmLWRlc2NyaWJpbmcgcm91dGluZ1xuZm9yIGEgd2ViIGFwcC5cblxuPiAqbi5iLiBhcHAtcm91dGUgaXMgc3RpbGwgaW4gYmV0YS4gV2UgZXhwZWN0IGl0IHdpbGwgbmVlZCBzb21lIGNoYW5nZXMuIFdlJ3JlIGNvdW50aW5nIG9uIHlvdXIgZmVlZGJhY2shKlxuXG5JbiBpdHMgdHlwaWNhbCB1c2FnZSwgYSBgYXBwLXJvdXRlYCBlbGVtZW50IGNvbnN1bWVzIGFuIG9iamVjdCB0aGF0IGRlc2NyaWJlc1xuc29tZSBzdGF0ZSBhYm91dCB0aGUgY3VycmVudCByb3V0ZSwgdmlhIHRoZSBgcm91dGVgIHByb3BlcnR5LiBJdCB0aGVuIHBhcnNlc1xudGhhdCBzdGF0ZSB1c2luZyB0aGUgYHBhdHRlcm5gIHByb3BlcnR5LCBhbmQgcHJvZHVjZXMgdHdvIGFydGlmYWN0czogc29tZSBgZGF0YWBcbnJlbGF0ZWQgdG8gdGhlIGByb3V0ZWAsIGFuZCBhIGB0YWlsYCB0aGF0IGNvbnRhaW5zIHRoZSByZXN0IG9mIHRoZSBgcm91dGVgIHRoYXRcbmRpZCBub3QgbWF0Y2guXG5cbkhlcmUgaXMgYSBiYXNpYyBleGFtcGxlLCB3aGVuIHVzZWQgd2l0aCBgYXBwLWxvY2F0aW9uYDpcblxuICAgIDxhcHAtbG9jYXRpb24gcm91dGU9XCJ7e3JvdXRlfX1cIj48L2FwcC1sb2NhdGlvbj5cbiAgICA8YXBwLXJvdXRlXG4gICAgICAgIHJvdXRlPVwie3tyb3V0ZX19XCJcbiAgICAgICAgcGF0dGVybj1cIi86cGFnZVwiXG4gICAgICAgIGRhdGE9XCJ7e2RhdGF9fVwiXG4gICAgICAgIHRhaWw9XCJ7e3RhaWx9fVwiPlxuICAgIDwvYXBwLXJvdXRlPlxuXG5JbiB0aGUgYWJvdmUgZXhhbXBsZSwgdGhlIGBhcHAtbG9jYXRpb25gIHByb2R1Y2VzIGEgYHJvdXRlYCB2YWx1ZS4gVGhlbiwgdGhlXG5gcm91dGUucGF0aGAgcHJvcGVydHkgaXMgbWF0Y2hlZCBieSBjb21wYXJpbmcgaXQgdG8gdGhlIGBwYXR0ZXJuYCBwcm9wZXJ0eS4gSWZcbnRoZSBgcGF0dGVybmAgcHJvcGVydHkgbWF0Y2hlcyBgcm91dGUucGF0aGAsIHRoZSBgYXBwLXJvdXRlYCB3aWxsIHNldCBvciB1cGRhdGVcbml0cyBgZGF0YWAgcHJvcGVydHkgd2l0aCBhbiBvYmplY3Qgd2hvc2UgcHJvcGVydGllcyBjb3JyZXNwb25kIHRvIHRoZSBwYXJhbWV0ZXJzXG5pbiBgcGF0dGVybmAuIFNvLCBpbiB0aGUgYWJvdmUgZXhhbXBsZSwgaWYgYHJvdXRlLnBhdGhgIHdhcyBgJy9hYm91dCdgLCB0aGUgdmFsdWVcbm9mIGBkYXRhYCB3b3VsZCBiZSBge1wicGFnZVwiOiBcImFib3V0XCJ9YC5cblxuVGhlIGB0YWlsYCBwcm9wZXJ0eSByZXByZXNlbnRzIHRoZSByZW1haW5pbmcgcGFydCBvZiB0aGUgcm91dGUgc3RhdGUgYWZ0ZXIgdGhlXG5gcGF0dGVybmAgaGFzIGJlZW4gYXBwbGllZCB0byBhIG1hdGNoaW5nIGByb3V0ZWAuXG5cbkhlcmUgaXMgYW5vdGhlciBleGFtcGxlLCB3aGVyZSBgdGFpbGAgaXMgdXNlZDpcblxuICAgIDxhcHAtbG9jYXRpb24gcm91dGU9XCJ7e3JvdXRlfX1cIj48L2FwcC1sb2NhdGlvbj5cbiAgICA8YXBwLXJvdXRlXG4gICAgICAgIHJvdXRlPVwie3tyb3V0ZX19XCJcbiAgICAgICAgcGF0dGVybj1cIi86cGFnZVwiXG4gICAgICAgIGRhdGE9XCJ7e3JvdXRlRGF0YX19XCJcbiAgICAgICAgdGFpbD1cInt7c3Vicm91dGV9fVwiPlxuICAgIDwvYXBwLXJvdXRlPlxuICAgIDxhcHAtcm91dGVcbiAgICAgICAgcm91dGU9XCJ7e3N1YnJvdXRlfX1cIlxuICAgICAgICBwYXR0ZXJuPVwiLzppZFwiXG4gICAgICAgIGRhdGE9XCJ7e3N1YnJvdXRlRGF0YX19XCI+XG4gICAgPC9hcHAtcm91dGU+XG5cbkluIHRoZSBhYm92ZSBleGFtcGxlLCB0aGVyZSBhcmUgdHdvIGBhcHAtcm91dGVgIGVsZW1lbnRzLiBUaGUgZmlyc3RcbmBhcHAtcm91dGVgIGNvbnN1bWVzIGEgYHJvdXRlYC4gV2hlbiB0aGUgYHJvdXRlYCBpcyBtYXRjaGVkLCB0aGUgZmlyc3RcbmBhcHAtcm91dGVgIGFsc28gcHJvZHVjZXMgYHJvdXRlRGF0YWAgZnJvbSBpdHMgYGRhdGFgLCBhbmQgYHN1YnJvdXRlYCBmcm9tXG5pdHMgYHRhaWxgLiBUaGUgc2Vjb25kIGBhcHAtcm91dGVgIGNvbnN1bWVzIHRoZSBgc3Vicm91dGVgLCBhbmQgd2hlbiBpdFxubWF0Y2hlcywgaXQgcHJvZHVjZXMgYW4gb2JqZWN0IGNhbGxlZCBgc3Vicm91dGVEYXRhYCBmcm9tIGl0cyBgZGF0YWAuXG5cblNvLCB3aGVuIGByb3V0ZS5wYXRoYCBpcyBgJy9hYm91dCdgLCB0aGUgYHJvdXRlRGF0YWAgb2JqZWN0IHdpbGwgbG9vayBsaWtlXG50aGlzOiBgeyBwYWdlOiAnYWJvdXQnIH1gXG5cbkFuZCBgc3Vicm91dGVEYXRhYCB3aWxsIGJlIG51bGwuIEhvd2V2ZXIsIGlmIGByb3V0ZS5wYXRoYCBjaGFuZ2VzIHRvXG5gJy9hcnRpY2xlLzEyMydgLCB0aGUgYHJvdXRlRGF0YWAgb2JqZWN0IHdpbGwgbG9vayBsaWtlIHRoaXM6XG5geyBwYWdlOiAnYXJ0aWNsZScgfWBcblxuQW5kIHRoZSBgc3Vicm91dGVEYXRhYCB3aWxsIGxvb2sgbGlrZSB0aGlzOiBgeyBpZDogJzEyMycgfWBcblxuYGFwcC1yb3V0ZWAgaXMgcmVzcG9uc2l2ZSB0byBiaS1kaXJlY3Rpb25hbCBjaGFuZ2VzIHRvIHRoZSBgZGF0YWAgb2JqZWN0c1xudGhleSBwcm9kdWNlLiBTbywgaWYgYHJvdXRlRGF0YS5wYWdlYCBjaGFuZ2VkIGZyb20gYCdhcnRpY2xlJ2AgdG8gYCdhYm91dCdgLFxudGhlIGBhcHAtcm91dGVgIHdpbGwgdXBkYXRlIGByb3V0ZS5wYXRoYC4gVGhpcyBpbi10dXJuIHdpbGwgdXBkYXRlIHRoZVxuYGFwcC1sb2NhdGlvbmAsIGFuZCBjYXVzZSB0aGUgZ2xvYmFsIGxvY2F0aW9uIGJhciB0byBjaGFuZ2UgaXRzIHZhbHVlLlxuXG5AZWxlbWVudCBhcHAtcm91dGVcbkBkZW1vIGRlbW8vaW5kZXguaHRtbFxuQGRlbW8gZGVtby9kYXRhLWxvYWRpbmctZGVtby5odG1sXG5AZGVtbyBkZW1vL3NpbXBsZS1kZW1vLmh0bWxcbi0tPlxuXG48c2NyaXB0PlxuICAoZnVuY3Rpb24oKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgUG9seW1lcih7XG4gICAgICBpczogJ2FwcC1yb3V0ZScsXG5cbiAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBVUkwgY29tcG9uZW50IG1hbmFnZWQgYnkgdGhpcyBlbGVtZW50LlxuICAgICAgICAgKi9cbiAgICAgICAgcm91dGU6IHtcbiAgICAgICAgICB0eXBlOiBPYmplY3QsXG4gICAgICAgICAgbm90aWZ5OiB0cnVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBwYXR0ZXJuIG9mIHNsYXNoLXNlcGFyYXRlZCBzZWdtZW50cyB0byBtYXRjaCBgcm91dGUucGF0aGAgYWdhaW5zdC5cbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIGV4YW1wbGUgdGhlIHBhdHRlcm4gXCIvZm9vXCIgd2lsbCBtYXRjaCBcIi9mb29cIiBvciBcIi9mb28vYmFyXCJcbiAgICAgICAgICogYnV0IG5vdCBcIi9mb29iYXJcIi5cbiAgICAgICAgICpcbiAgICAgICAgICogUGF0aCBzZWdtZW50cyBsaWtlIGAvOm5hbWVkYCBhcmUgbWFwcGVkIHRvIHByb3BlcnRpZXMgb24gdGhlIGBkYXRhYCBvYmplY3QuXG4gICAgICAgICAqL1xuICAgICAgICBwYXR0ZXJuOiB7XG4gICAgICAgICAgdHlwZTogU3RyaW5nXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBwYXJhbWV0ZXJpemVkIHZhbHVlcyB0aGF0IGFyZSBleHRyYWN0ZWQgZnJvbSB0aGUgcm91dGUgYXNcbiAgICAgICAgICogZGVzY3JpYmVkIGJ5IGBwYXR0ZXJuYC5cbiAgICAgICAgICovXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICB0eXBlOiBPYmplY3QsXG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uKCkge3JldHVybiB7fTt9LFxuICAgICAgICAgIG5vdGlmeTogdHJ1ZVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7P09iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIHF1ZXJ5UGFyYW1zOiB7XG4gICAgICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIG5vdGlmeTogdHJ1ZVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgcGFydCBvZiBgcm91dGUucGF0aGAgTk9UIGNvbnN1bWVkIGJ5IGBwYXR0ZXJuYC5cbiAgICAgICAgICovXG4gICAgICAgIHRhaWw6IHtcbiAgICAgICAgICB0eXBlOiBPYmplY3QsXG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uKCkge3JldHVybiB7cGF0aDogbnVsbCwgcHJlZml4OiBudWxsLCBfX3F1ZXJ5UGFyYW1zOiBudWxsfTt9LFxuICAgICAgICAgIG5vdGlmeTogdHJ1ZVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZSBjdXJyZW50IHJvdXRlIGlzIGFjdGl2ZS4gVHJ1ZSBpZiBgcm91dGUucGF0aGAgbWF0Y2hlcyB0aGVcbiAgICAgICAgICogYHBhdHRlcm5gLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICAgICAqL1xuICAgICAgICBhY3RpdmU6IHtcbiAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgIG5vdGlmeTogdHJ1ZSxcbiAgICAgICAgICByZWFkT25seTogdHJ1ZVxuICAgICAgICB9LFxuXG4gICAgICAgIF9xdWVyeVBhcmFtc1VwZGF0aW5nOiB7XG4gICAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHs/c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgX21hdGNoZWQ6IHtcbiAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgdmFsdWU6ICcnXG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIG9ic2VydmVyczogW1xuICAgICAgICAnX190cnlUb01hdGNoKHJvdXRlLnBhdGgsIHBhdHRlcm4pJyxcbiAgICAgICAgJ19fdXBkYXRlUGF0aE9uRGF0YUNoYW5nZShkYXRhLiopJyxcbiAgICAgICAgJ19fdGFpbFBhdGhDaGFuZ2VkKHRhaWwucGF0aCknLFxuICAgICAgICAnX19yb3V0ZVF1ZXJ5UGFyYW1zQ2hhbmdlZChyb3V0ZS5fX3F1ZXJ5UGFyYW1zKScsXG4gICAgICAgICdfX3RhaWxRdWVyeVBhcmFtc0NoYW5nZWQodGFpbC5fX3F1ZXJ5UGFyYW1zKScsXG4gICAgICAgICdfX3F1ZXJ5UGFyYW1zQ2hhbmdlZChxdWVyeVBhcmFtcy4qKSdcbiAgICAgIF0sXG5cbiAgICAgIGNyZWF0ZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmxpbmtQYXRocygncm91dGUuX19xdWVyeVBhcmFtcycsICd0YWlsLl9fcXVlcnlQYXJhbXMnKTtcbiAgICAgICAgdGhpcy5saW5rUGF0aHMoJ3RhaWwuX19xdWVyeVBhcmFtcycsICdyb3V0ZS5fX3F1ZXJ5UGFyYW1zJyk7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIERlYWwgd2l0aCB0aGUgcXVlcnkgcGFyYW1zIG9iamVjdCBiZWluZyBhc3NpZ25lZCB0byB3aG9sZXNhbGUuXG4gICAgICAgKi9cbiAgICAgIF9fcm91dGVRdWVyeVBhcmFtc0NoYW5nZWQ6IGZ1bmN0aW9uKHF1ZXJ5UGFyYW1zKSB7XG4gICAgICAgIGlmIChxdWVyeVBhcmFtcyAmJiB0aGlzLnRhaWwpIHtcbiAgICAgICAgICBpZiAodGhpcy50YWlsLl9fcXVlcnlQYXJhbXMgIT09IHF1ZXJ5UGFyYW1zKSB7XG4gICAgICAgICAgICB0aGlzLnNldCgndGFpbC5fX3F1ZXJ5UGFyYW1zJywgcXVlcnlQYXJhbXMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghdGhpcy5hY3RpdmUgfHwgdGhpcy5fcXVlcnlQYXJhbXNVcGRhdGluZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIENvcHkgcXVlcnlQYXJhbXMgYW5kIHRyYWNrIHdoZXRoZXIgdGhlcmUgYXJlIGFueSBkaWZmZXJlbmNlcyBjb21wYXJlZFxuICAgICAgICAgIC8vIHRvIHRoZSBleGlzdGluZyBxdWVyeSBwYXJhbXMuXG4gICAgICAgICAgdmFyIGNvcHlPZlF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgICAgdmFyIGFueXRoaW5nQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICAgIGZvciAodmFyIGtleSBpbiBxdWVyeVBhcmFtcykge1xuICAgICAgICAgICAgY29weU9mUXVlcnlQYXJhbXNba2V5XSA9IHF1ZXJ5UGFyYW1zW2tleV07XG4gICAgICAgICAgICBpZiAoYW55dGhpbmdDaGFuZ2VkIHx8XG4gICAgICAgICAgICAgICAgIXRoaXMucXVlcnlQYXJhbXMgfHxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtc1trZXldICE9PSB0aGlzLnF1ZXJ5UGFyYW1zW2tleV0pIHtcbiAgICAgICAgICAgICAgYW55dGhpbmdDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gTmVlZCB0byBjaGVjayB3aGV0aGVyIGFueSBrZXlzIHdlcmUgZGVsZXRlZFxuICAgICAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLnF1ZXJ5UGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYW55dGhpbmdDaGFuZ2VkIHx8ICEoa2V5IGluIHF1ZXJ5UGFyYW1zKSkge1xuICAgICAgICAgICAgICBhbnl0aGluZ0NoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIWFueXRoaW5nQ2hhbmdlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9xdWVyeVBhcmFtc1VwZGF0aW5nID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLnNldCgncXVlcnlQYXJhbXMnLCBjb3B5T2ZRdWVyeVBhcmFtcyk7XG4gICAgICAgICAgdGhpcy5fcXVlcnlQYXJhbXNVcGRhdGluZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBfX3RhaWxRdWVyeVBhcmFtc0NoYW5nZWQ6IGZ1bmN0aW9uKHF1ZXJ5UGFyYW1zKSB7XG4gICAgICAgIGlmIChxdWVyeVBhcmFtcyAmJiB0aGlzLnJvdXRlICYmIHRoaXMucm91dGUuX19xdWVyeVBhcmFtcyAhPSBxdWVyeVBhcmFtcykge1xuICAgICAgICAgIHRoaXMuc2V0KCdyb3V0ZS5fX3F1ZXJ5UGFyYW1zJywgcXVlcnlQYXJhbXMpO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBfX3F1ZXJ5UGFyYW1zQ2hhbmdlZDogZnVuY3Rpb24oY2hhbmdlcykge1xuICAgICAgICBpZiAoIXRoaXMuYWN0aXZlIHx8IHRoaXMuX3F1ZXJ5UGFyYW1zVXBkYXRpbmcpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNldCgncm91dGUuX18nICsgY2hhbmdlcy5wYXRoLCBjaGFuZ2VzLnZhbHVlKTtcbiAgICAgIH0sXG5cbiAgICAgIF9fcmVzZXRQcm9wZXJ0aWVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fc2V0QWN0aXZlKGZhbHNlKTtcbiAgICAgICAgdGhpcy5fbWF0Y2hlZCA9IG51bGw7XG4gICAgICB9LFxuXG4gICAgICBfX3RyeVRvTWF0Y2g6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMucm91dGUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcGF0aCA9IHRoaXMucm91dGUucGF0aDtcbiAgICAgICAgdmFyIHBhdHRlcm4gPSB0aGlzLnBhdHRlcm47XG5cbiAgICAgICAgaWYgKCFwYXR0ZXJuKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFwYXRoKSB7XG4gICAgICAgICAgdGhpcy5fX3Jlc2V0UHJvcGVydGllcygpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZW1haW5pbmdQaWVjZXMgPSBwYXRoLnNwbGl0KCcvJyk7XG4gICAgICAgIHZhciBwYXR0ZXJuUGllY2VzID0gcGF0dGVybi5zcGxpdCgnLycpO1xuXG4gICAgICAgIHZhciBtYXRjaGVkID0gW107XG4gICAgICAgIHZhciBuYW1lZE1hdGNoZXMgPSB7fTtcblxuICAgICAgICBmb3IgKHZhciBpPTA7IGkgPCBwYXR0ZXJuUGllY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHBhdHRlcm5QaWVjZSA9IHBhdHRlcm5QaWVjZXNbaV07XG4gICAgICAgICAgaWYgKCFwYXR0ZXJuUGllY2UgJiYgcGF0dGVyblBpZWNlICE9PSAnJykge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBwYXRoUGllY2UgPSByZW1haW5pbmdQaWVjZXMuc2hpZnQoKTtcblxuICAgICAgICAgIC8vIFdlIGRvbid0IG1hdGNoIHRoaXMgcGF0aC5cbiAgICAgICAgICBpZiAoIXBhdGhQaWVjZSAmJiBwYXRoUGllY2UgIT09ICcnKSB7XG4gICAgICAgICAgICB0aGlzLl9fcmVzZXRQcm9wZXJ0aWVzKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIG1hdGNoZWQucHVzaChwYXRoUGllY2UpO1xuXG4gICAgICAgICAgaWYgKHBhdHRlcm5QaWVjZS5jaGFyQXQoMCkgPT0gJzonKSB7XG4gICAgICAgICAgICBuYW1lZE1hdGNoZXNbcGF0dGVyblBpZWNlLnNsaWNlKDEpXSA9IHBhdGhQaWVjZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHBhdHRlcm5QaWVjZSAhPT0gcGF0aFBpZWNlKSB7XG4gICAgICAgICAgICB0aGlzLl9fcmVzZXRQcm9wZXJ0aWVzKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbWF0Y2hlZCA9IG1hdGNoZWQuam9pbignLycpO1xuXG4gICAgICAgIC8vIFByb3BlcnRpZXMgdGhhdCBtdXN0IGJlIHVwZGF0ZWQgYXRvbWljYWxseS5cbiAgICAgICAgdmFyIHByb3BlcnR5VXBkYXRlcyA9IHt9O1xuXG4gICAgICAgIC8vdGhpcy5hY3RpdmVcbiAgICAgICAgaWYgKCF0aGlzLmFjdGl2ZSkge1xuICAgICAgICAgIHByb3BlcnR5VXBkYXRlcy5hY3RpdmUgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdGhpcy50YWlsXG4gICAgICAgIHZhciB0YWlsUHJlZml4ID0gdGhpcy5yb3V0ZS5wcmVmaXggKyB0aGlzLl9tYXRjaGVkO1xuICAgICAgICB2YXIgdGFpbFBhdGggPSByZW1haW5pbmdQaWVjZXMuam9pbignLycpO1xuICAgICAgICBpZiAocmVtYWluaW5nUGllY2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB0YWlsUGF0aCA9ICcvJyArIHRhaWxQYXRoO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy50YWlsIHx8XG4gICAgICAgICAgICB0aGlzLnRhaWwucHJlZml4ICE9PSB0YWlsUHJlZml4IHx8XG4gICAgICAgICAgICB0aGlzLnRhaWwucGF0aCAhPT0gdGFpbFBhdGgpIHtcbiAgICAgICAgICBwcm9wZXJ0eVVwZGF0ZXMudGFpbCA9IHtcbiAgICAgICAgICAgIHByZWZpeDogdGFpbFByZWZpeCxcbiAgICAgICAgICAgIHBhdGg6IHRhaWxQYXRoLFxuICAgICAgICAgICAgX19xdWVyeVBhcmFtczogdGhpcy5yb3V0ZS5fX3F1ZXJ5UGFyYW1zXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRoaXMuZGF0YVxuICAgICAgICBwcm9wZXJ0eVVwZGF0ZXMuZGF0YSA9IG5hbWVkTWF0Y2hlcztcbiAgICAgICAgdGhpcy5fZGF0YUluVXJsID0ge307XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBuYW1lZE1hdGNoZXMpIHtcbiAgICAgICAgICB0aGlzLl9kYXRhSW5Vcmxba2V5XSA9IG5hbWVkTWF0Y2hlc1trZXldO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuc2V0UHJvcGVydGllcykge1xuICAgICAgICAgIGlmICghdGhpcy5hY3RpdmUpIHtcbiAgICAgICAgICAgIHRoaXMuX3NldEFjdGl2ZSh0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gYXRvbWljIHVwZGF0ZVxuICAgICAgICAgIHRoaXMuc2V0UHJvcGVydGllcyhwcm9wZXJ0eVVwZGF0ZXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX19zZXRNdWx0aShwcm9wZXJ0eVVwZGF0ZXMpO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBfX3RhaWxQYXRoQ2hhbmdlZDogZnVuY3Rpb24ocGF0aCkge1xuICAgICAgICBpZiAoIXRoaXMuYWN0aXZlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0YWlsUGF0aCA9IHBhdGg7XG4gICAgICAgIHZhciBuZXdQYXRoID0gdGhpcy5fbWF0Y2hlZDtcbiAgICAgICAgaWYgKHRhaWxQYXRoKSB7XG4gICAgICAgICAgaWYgKHRhaWxQYXRoLmNoYXJBdCgwKSAhPT0gJy8nKSB7XG4gICAgICAgICAgICB0YWlsUGF0aCA9ICcvJyArIHRhaWxQYXRoO1xuICAgICAgICAgIH1cbiAgICAgICAgICBuZXdQYXRoICs9IHRhaWxQYXRoO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0KCdyb3V0ZS5wYXRoJywgbmV3UGF0aCk7XG4gICAgICB9LFxuXG4gICAgICBfX3VwZGF0ZVBhdGhPbkRhdGFDaGFuZ2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMucm91dGUgfHwgIXRoaXMuYWN0aXZlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuZXdQYXRoID0gdGhpcy5fX2dldExpbmsoe30pO1xuICAgICAgICB2YXIgb2xkUGF0aCA9IHRoaXMuX19nZXRMaW5rKHRoaXMuX2RhdGFJblVybCk7XG4gICAgICAgIGlmIChuZXdQYXRoID09PSBvbGRQYXRoKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0KCdyb3V0ZS5wYXRoJywgbmV3UGF0aCk7XG4gICAgICB9LFxuXG4gICAgICBfX2dldExpbms6IGZ1bmN0aW9uKG92ZXJyaWRlVmFsdWVzKSB7XG4gICAgICAgIHZhciB2YWx1ZXMgPSB7dGFpbDogbnVsbH07XG4gICAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLmRhdGEpIHtcbiAgICAgICAgICB2YWx1ZXNba2V5XSA9IHRoaXMuZGF0YVtrZXldO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvdmVycmlkZVZhbHVlcykge1xuICAgICAgICAgIHZhbHVlc1trZXldID0gb3ZlcnJpZGVWYWx1ZXNba2V5XTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcGF0dGVyblBpZWNlcyA9IHRoaXMucGF0dGVybi5zcGxpdCgnLycpO1xuICAgICAgICB2YXIgaW50ZXJwID0gcGF0dGVyblBpZWNlcy5tYXAoZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICBpZiAodmFsdWVbMF0gPT0gJzonKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlc1t2YWx1ZS5zbGljZSgxKV07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIGlmICh2YWx1ZXMudGFpbCAmJiB2YWx1ZXMudGFpbC5wYXRoKSB7XG4gICAgICAgICAgaWYgKGludGVycC5sZW5ndGggPiAwICYmIHZhbHVlcy50YWlsLnBhdGguY2hhckF0KDApID09PSAnLycpIHtcbiAgICAgICAgICAgIGludGVycC5wdXNoKHZhbHVlcy50YWlsLnBhdGguc2xpY2UoMSkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbnRlcnAucHVzaCh2YWx1ZXMudGFpbC5wYXRoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGludGVycC5qb2luKCcvJyk7XG4gICAgICB9LFxuXG4gICAgICBfX3NldE11bHRpOiBmdW5jdGlvbihzZXRPYmopIHtcbiAgICAgICAgLy8gSEFDSyhyaWN0aWMpOiBza2lydGluZyBhcm91bmQgMS4wJ3MgbGFjayBvZiBhIHNldE11bHRpIGJ5IHBva2luZyBhdFxuICAgICAgICAvLyAgICAgaW50ZXJuYWwgZGF0YSBzdHJ1Y3R1cmVzLiBJIHdvdWxkIG5vdCBhZHZpc2UgdGhhdCB5b3UgY29weSB0aGlzXG4gICAgICAgIC8vICAgICBleGFtcGxlLlxuICAgICAgICAvL1xuICAgICAgICAvLyAgICAgSW4gdGhlIGZ1dHVyZSB0aGlzIHdpbGwgYmUgYSBmZWF0dXJlIG9mIFBvbHltZXIgaXRzZWxmLlxuICAgICAgICAvLyAgICAgU2VlOiBodHRwczovL2dpdGh1Yi5jb20vUG9seW1lci9wb2x5bWVyL2lzc3Vlcy8zNjQwXG4gICAgICAgIC8vXG4gICAgICAgIC8vICAgICBIYWNraW5nIGFyb3VuZCB3aXRoIHByaXZhdGUgbWV0aG9kcyBsaWtlIHRoaXMgaXMganVnZ2xpbmcgZm9vdGd1bnMsXG4gICAgICAgIC8vICAgICBhbmQgaXMgbGlrZWx5IHRvIGhhdmUgdW5leHBlY3RlZCBhbmQgdW5zdXBwb3J0ZWQgcm91Z2ggZWRnZXMuXG4gICAgICAgIC8vXG4gICAgICAgIC8vICAgICBCZSB5ZSBzbyB3YXJuZWQuXG4gICAgICAgIGZvciAodmFyIHByb3BlcnR5IGluIHNldE9iaikge1xuICAgICAgICAgIHRoaXMuX3Byb3BlcnR5U2V0dGVyKHByb3BlcnR5LCBzZXRPYmpbcHJvcGVydHldKTtcbiAgICAgICAgfVxuICAgICAgICAvL25vdGlmeSBpbiBhIHNwZWNpZmljIG9yZGVyXG4gICAgICAgIGlmIChzZXRPYmouZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5fcGF0aEVmZmVjdG9yKCdkYXRhJywgdGhpcy5kYXRhKTtcbiAgICAgICAgICB0aGlzLl9ub3RpZnlDaGFuZ2UoJ2RhdGEnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2V0T2JqLmFjdGl2ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5fcGF0aEVmZmVjdG9yKCdhY3RpdmUnLCB0aGlzLmFjdGl2ZSk7XG4gICAgICAgICAgdGhpcy5fbm90aWZ5Q2hhbmdlKCdhY3RpdmUnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2V0T2JqLnRhaWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMuX3BhdGhFZmZlY3RvcigndGFpbCcsIHRoaXMudGFpbCk7XG4gICAgICAgICAgdGhpcy5fbm90aWZ5Q2hhbmdlKCd0YWlsJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSkoKTtcbjwvc2NyaXB0PlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9hcHAtcm91dGUvYXBwLXJvdXRlLmh0bWwiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE1IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi9wb2x5bWVyL3BvbHltZXIuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL2lyb24tcmVzaXphYmxlLWJlaGF2aW9yL2lyb24tcmVzaXphYmxlLWJlaGF2aW9yLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi9pcm9uLXNlbGVjdG9yL2lyb24tc2VsZWN0YWJsZS5odG1sXCI+XG5cbjwhLS1cbmBpcm9uLXBhZ2VzYCBpcyB1c2VkIHRvIHNlbGVjdCBvbmUgb2YgaXRzIGNoaWxkcmVuIHRvIHNob3cuIE9uZSB1c2UgaXMgdG8gY3ljbGUgdGhyb3VnaCBhIGxpc3Qgb2ZcbmNoaWxkcmVuIFwicGFnZXNcIi5cblxuRXhhbXBsZTpcblxuICAgIDxpcm9uLXBhZ2VzIHNlbGVjdGVkPVwiMFwiPlxuICAgICAgPGRpdj5PbmU8L2Rpdj5cbiAgICAgIDxkaXY+VHdvPC9kaXY+XG4gICAgICA8ZGl2PlRocmVlPC9kaXY+XG4gICAgPC9pcm9uLXBhZ2VzPlxuXG4gICAgPHNjcmlwdD5cbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oZSkge1xuICAgICAgICB2YXIgcGFnZXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdpcm9uLXBhZ2VzJyk7XG4gICAgICAgIHBhZ2VzLnNlbGVjdE5leHQoKTtcbiAgICAgIH0pO1xuICAgIDwvc2NyaXB0PlxuXG5AZ3JvdXAgSXJvbiBFbGVtZW50c1xuQGhlcm8gaGVyby5zdmdcbkBkZW1vIGRlbW8vaW5kZXguaHRtbFxuLS0+XG5cbjxkb20tbW9kdWxlIGlkPVwiaXJvbi1wYWdlc1wiPlxuXG4gIDx0ZW1wbGF0ZT5cbiAgICA8c3R5bGU+XG4gICAgICA6aG9zdCB7XG4gICAgICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgICAgfVxuXG4gICAgICA6aG9zdCA+IDo6c2xvdHRlZCg6bm90KC5pcm9uLXNlbGVjdGVkKSkge1xuICAgICAgICBkaXNwbGF5OiBub25lICFpbXBvcnRhbnQ7XG4gICAgICB9XG4gICAgPC9zdHlsZT5cblxuICAgIDxzbG90Pjwvc2xvdD5cbiAgPC90ZW1wbGF0ZT5cblxuICA8c2NyaXB0PlxuICAgIFBvbHltZXIoe1xuXG4gICAgICBpczogJ2lyb24tcGFnZXMnLFxuXG4gICAgICBiZWhhdmlvcnM6IFtcbiAgICAgICAgUG9seW1lci5Jcm9uUmVzaXphYmxlQmVoYXZpb3IsXG4gICAgICAgIFBvbHltZXIuSXJvblNlbGVjdGFibGVCZWhhdmlvclxuICAgICAgXSxcblxuICAgICAgcHJvcGVydGllczoge1xuXG4gICAgICAgIC8vIGFzIHRoZSBzZWxlY3RlZCBwYWdlIGlzIHRoZSBvbmx5IG9uZSB2aXNpYmxlLCBhY3RpdmF0ZUV2ZW50XG4gICAgICAgIC8vIGlzIGJvdGggbm9uLXNlbnNpY2FsIGFuZCBwcm9ibGVtYXRpYzsgZS5nLiBpbiBjYXNlcyB3aGVyZSBhIHVzZXJcbiAgICAgICAgLy8gaGFuZGxlciBhdHRlbXB0cyB0byBjaGFuZ2UgdGhlIHBhZ2UgYW5kIHRoZSBhY3RpdmF0ZUV2ZW50XG4gICAgICAgIC8vIGhhbmRsZXIgaW1tZWRpYXRlbHkgY2hhbmdlcyBpdCBiYWNrXG4gICAgICAgIGFjdGl2YXRlRXZlbnQ6IHtcbiAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgdmFsdWU6IG51bGxcbiAgICAgICAgfVxuXG4gICAgICB9LFxuXG4gICAgICBvYnNlcnZlcnM6IFtcbiAgICAgICAgJ19zZWxlY3RlZFBhZ2VDaGFuZ2VkKHNlbGVjdGVkKSdcbiAgICAgIF0sXG5cbiAgICAgIF9zZWxlY3RlZFBhZ2VDaGFuZ2VkOiBmdW5jdGlvbihzZWxlY3RlZCwgb2xkKSB7XG4gICAgICAgIHRoaXMuYXN5bmModGhpcy5ub3RpZnlSZXNpemUpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gIDwvc2NyaXB0PlxuPC9kb20tbW9kdWxlPlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9pcm9uLXBhZ2VzL2lyb24tcGFnZXMuaHRtbCIsIlxuPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNSBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuXG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vcG9seW1lci9wb2x5bWVyLmh0bWxcIj5cblxuPHNjcmlwdD5cblxuICAvKipcbiAgICogQHBhcmFtIHshRnVuY3Rpb259IHNlbGVjdENhbGxiYWNrXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cbiAgUG9seW1lci5Jcm9uU2VsZWN0aW9uID0gZnVuY3Rpb24oc2VsZWN0Q2FsbGJhY2spIHtcbiAgICB0aGlzLnNlbGVjdGlvbiA9IFtdO1xuICAgIHRoaXMuc2VsZWN0Q2FsbGJhY2sgPSBzZWxlY3RDYWxsYmFjaztcbiAgfTtcblxuICBQb2x5bWVyLklyb25TZWxlY3Rpb24ucHJvdG90eXBlID0ge1xuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSBzZWxlY3RlZCBpdGVtKHMpLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBnZXRcbiAgICAgKiBAcmV0dXJucyBSZXR1cm5zIHRoZSBzZWxlY3RlZCBpdGVtKHMpLiBJZiB0aGUgbXVsdGkgcHJvcGVydHkgaXMgdHJ1ZSxcbiAgICAgKiBgZ2V0YCB3aWxsIHJldHVybiBhbiBhcnJheSwgb3RoZXJ3aXNlIGl0IHdpbGwgcmV0dXJuXG4gICAgICogdGhlIHNlbGVjdGVkIGl0ZW0gb3IgdW5kZWZpbmVkIGlmIHRoZXJlIGlzIG5vIHNlbGVjdGlvbi5cbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMubXVsdGkgPyB0aGlzLnNlbGVjdGlvbi5zbGljZSgpIDogdGhpcy5zZWxlY3Rpb25bMF07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENsZWFycyBhbGwgdGhlIHNlbGVjdGlvbiBleGNlcHQgdGhlIG9uZXMgaW5kaWNhdGVkLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBjbGVhclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGV4Y2x1ZGVzIGl0ZW1zIHRvIGJlIGV4Y2x1ZGVkLlxuICAgICAqL1xuICAgIGNsZWFyOiBmdW5jdGlvbihleGNsdWRlcykge1xuICAgICAgdGhpcy5zZWxlY3Rpb24uc2xpY2UoKS5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgaWYgKCFleGNsdWRlcyB8fCBleGNsdWRlcy5pbmRleE9mKGl0ZW0pIDwgMCkge1xuICAgICAgICAgIHRoaXMuc2V0SXRlbVNlbGVjdGVkKGl0ZW0sIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfSwgdGhpcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyBpZiBhIGdpdmVuIGl0ZW0gaXMgc2VsZWN0ZWQuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGlzU2VsZWN0ZWRcbiAgICAgKiBAcGFyYW0geyp9IGl0ZW0gVGhlIGl0ZW0gd2hvc2Ugc2VsZWN0aW9uIHN0YXRlIHNob3VsZCBiZSBjaGVja2VkLlxuICAgICAqIEByZXR1cm5zIFJldHVybnMgdHJ1ZSBpZiBgaXRlbWAgaXMgc2VsZWN0ZWQuXG4gICAgICovXG4gICAgaXNTZWxlY3RlZDogZnVuY3Rpb24oaXRlbSkge1xuICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uLmluZGV4T2YoaXRlbSkgPj0gMDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgc2VsZWN0aW9uIHN0YXRlIGZvciBhIGdpdmVuIGl0ZW0gdG8gZWl0aGVyIHNlbGVjdGVkIG9yIGRlc2VsZWN0ZWQuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHNldEl0ZW1TZWxlY3RlZFxuICAgICAqIEBwYXJhbSB7Kn0gaXRlbSBUaGUgaXRlbSB0byBzZWxlY3QuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBpc1NlbGVjdGVkIFRydWUgZm9yIHNlbGVjdGVkLCBmYWxzZSBmb3IgZGVzZWxlY3RlZC5cbiAgICAgKi9cbiAgICBzZXRJdGVtU2VsZWN0ZWQ6IGZ1bmN0aW9uKGl0ZW0sIGlzU2VsZWN0ZWQpIHtcbiAgICAgIGlmIChpdGVtICE9IG51bGwpIHtcbiAgICAgICAgaWYgKGlzU2VsZWN0ZWQgIT09IHRoaXMuaXNTZWxlY3RlZChpdGVtKSkge1xuICAgICAgICAgIC8vIHByb2NlZWQgdG8gdXBkYXRlIHNlbGVjdGlvbiBvbmx5IGlmIHJlcXVlc3RlZCBzdGF0ZSBkaWZmZXJzIGZyb20gY3VycmVudFxuICAgICAgICAgIGlmIChpc1NlbGVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbi5wdXNoKGl0ZW0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgaSA9IHRoaXMuc2VsZWN0aW9uLmluZGV4T2YoaXRlbSk7XG4gICAgICAgICAgICBpZiAoaSA+PSAwKSB7XG4gICAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRoaXMuc2VsZWN0Q2FsbGJhY2spIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0Q2FsbGJhY2soaXRlbSwgaXNTZWxlY3RlZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHNlbGVjdGlvbiBzdGF0ZSBmb3IgYSBnaXZlbiBpdGVtLiBJZiB0aGUgYG11bHRpYCBwcm9wZXJ0eVxuICAgICAqIGlzIHRydWUsIHRoZW4gdGhlIHNlbGVjdGVkIHN0YXRlIG9mIGBpdGVtYCB3aWxsIGJlIHRvZ2dsZWQ7IG90aGVyd2lzZVxuICAgICAqIHRoZSBgaXRlbWAgd2lsbCBiZSBzZWxlY3RlZC5cbiAgICAgKlxuICAgICAqIEBtZXRob2Qgc2VsZWN0XG4gICAgICogQHBhcmFtIHsqfSBpdGVtIFRoZSBpdGVtIHRvIHNlbGVjdC5cbiAgICAgKi9cbiAgICBzZWxlY3Q6IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgIGlmICh0aGlzLm11bHRpKSB7XG4gICAgICAgIHRoaXMudG9nZ2xlKGl0ZW0pO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmdldCgpICE9PSBpdGVtKSB7XG4gICAgICAgIHRoaXMuc2V0SXRlbVNlbGVjdGVkKHRoaXMuZ2V0KCksIGZhbHNlKTtcbiAgICAgICAgdGhpcy5zZXRJdGVtU2VsZWN0ZWQoaXRlbSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRvZ2dsZXMgdGhlIHNlbGVjdGlvbiBzdGF0ZSBmb3IgYGl0ZW1gLlxuICAgICAqXG4gICAgICogQG1ldGhvZCB0b2dnbGVcbiAgICAgKiBAcGFyYW0geyp9IGl0ZW0gVGhlIGl0ZW0gdG8gdG9nZ2xlLlxuICAgICAqL1xuICAgIHRvZ2dsZTogZnVuY3Rpb24oaXRlbSkge1xuICAgICAgdGhpcy5zZXRJdGVtU2VsZWN0ZWQoaXRlbSwgIXRoaXMuaXNTZWxlY3RlZChpdGVtKSk7XG4gICAgfVxuXG4gIH07XG5cbjwvc2NyaXB0PlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9pcm9uLXNlbGVjdG9yL2lyb24tc2VsZWN0aW9uLmh0bWwiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE1IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG5cblxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3BvbHltZXIvcG9seW1lci5odG1sXCI+XG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiaXJvbi1tdWx0aS1zZWxlY3RhYmxlLmh0bWxcIj5cblxuPHNjcmlwdD5cbiAgLyoqXG4gIGBpcm9uLXNlbGVjdG9yYCBpcyBhbiBlbGVtZW50IHdoaWNoIGNhbiBiZSB1c2VkIHRvIG1hbmFnZSBhIGxpc3Qgb2YgZWxlbWVudHNcbiAgdGhhdCBjYW4gYmUgc2VsZWN0ZWQuICBUYXBwaW5nIG9uIHRoZSBpdGVtIHdpbGwgbWFrZSB0aGUgaXRlbSBzZWxlY3RlZC4gIFRoZSBgc2VsZWN0ZWRgIGluZGljYXRlc1xuICB3aGljaCBpdGVtIGlzIGJlaW5nIHNlbGVjdGVkLiAgVGhlIGRlZmF1bHQgaXMgdG8gdXNlIHRoZSBpbmRleCBvZiB0aGUgaXRlbS5cblxuICBFeGFtcGxlOlxuXG4gICAgICA8aXJvbi1zZWxlY3RvciBzZWxlY3RlZD1cIjBcIj5cbiAgICAgICAgPGRpdj5JdGVtIDE8L2Rpdj5cbiAgICAgICAgPGRpdj5JdGVtIDI8L2Rpdj5cbiAgICAgICAgPGRpdj5JdGVtIDM8L2Rpdj5cbiAgICAgIDwvaXJvbi1zZWxlY3Rvcj5cblxuICBJZiB5b3Ugd2FudCB0byB1c2UgdGhlIGF0dHJpYnV0ZSB2YWx1ZSBvZiBhbiBlbGVtZW50IGZvciBgc2VsZWN0ZWRgIGluc3RlYWQgb2YgdGhlIGluZGV4LFxuICBzZXQgYGF0dHJGb3JTZWxlY3RlZGAgdG8gdGhlIG5hbWUgb2YgdGhlIGF0dHJpYnV0ZS4gIEZvciBleGFtcGxlLCBpZiB5b3Ugd2FudCB0byBzZWxlY3QgaXRlbSBieVxuICBgbmFtZWAsIHNldCBgYXR0ckZvclNlbGVjdGVkYCB0byBgbmFtZWAuXG5cbiAgRXhhbXBsZTpcblxuICAgICAgPGlyb24tc2VsZWN0b3IgYXR0ci1mb3Itc2VsZWN0ZWQ9XCJuYW1lXCIgc2VsZWN0ZWQ9XCJmb29cIj5cbiAgICAgICAgPGRpdiBuYW1lPVwiZm9vXCI+Rm9vPC9kaXY+XG4gICAgICAgIDxkaXYgbmFtZT1cImJhclwiPkJhcjwvZGl2PlxuICAgICAgICA8ZGl2IG5hbWU9XCJ6b3RcIj5ab3Q8L2Rpdj5cbiAgICAgIDwvaXJvbi1zZWxlY3Rvcj5cblxuICBZb3UgY2FuIHNwZWNpZnkgYSBkZWZhdWx0IGZhbGxiYWNrIHdpdGggYGZhbGxiYWNrU2VsZWN0aW9uYCBpbiBjYXNlIHRoZSBgc2VsZWN0ZWRgIGF0dHJpYnV0ZSBkb2VzXG4gIG5vdCBtYXRjaCB0aGUgYGF0dHJGb3JTZWxlY3RlZGAgYXR0cmlidXRlIG9mIGFueSBlbGVtZW50cy5cblxuICBFeGFtcGxlOlxuXG4gICAgICAgIDxpcm9uLXNlbGVjdG9yIGF0dHItZm9yLXNlbGVjdGVkPVwibmFtZVwiIHNlbGVjdGVkPVwibm9uLWV4aXN0aW5nXCJcbiAgICAgICAgICAgICAgICAgICAgICAgZmFsbGJhY2stc2VsZWN0aW9uPVwiZGVmYXVsdFwiPlxuICAgICAgICAgIDxkaXYgbmFtZT1cImZvb1wiPkZvbzwvZGl2PlxuICAgICAgICAgIDxkaXYgbmFtZT1cImJhclwiPkJhcjwvZGl2PlxuICAgICAgICAgIDxkaXYgbmFtZT1cImRlZmF1bHRcIj5EZWZhdWx0PC9kaXY+XG4gICAgICAgIDwvaXJvbi1zZWxlY3Rvcj5cblxuICBOb3RlOiBXaGVuIHRoZSBzZWxlY3RvciBpcyBtdWx0aSwgdGhlIHNlbGVjdGlvbiB3aWxsIHNldCB0byBgZmFsbGJhY2tTZWxlY3Rpb25gIGlmZlxuICB0aGUgbnVtYmVyIG9mIG1hdGNoaW5nIGVsZW1lbnRzIGlzIHplcm8uXG5cbiAgYGlyb24tc2VsZWN0b3JgIGlzIG5vdCBzdHlsZWQuIFVzZSB0aGUgYGlyb24tc2VsZWN0ZWRgIENTUyBjbGFzcyB0byBzdHlsZSB0aGUgc2VsZWN0ZWQgZWxlbWVudC5cblxuICBFeGFtcGxlOlxuXG4gICAgICA8c3R5bGU+XG4gICAgICAgIC5pcm9uLXNlbGVjdGVkIHtcbiAgICAgICAgICBiYWNrZ3JvdW5kOiAjZWVlO1xuICAgICAgICB9XG4gICAgICA8L3N0eWxlPlxuXG4gICAgICAuLi5cblxuICAgICAgPGlyb24tc2VsZWN0b3Igc2VsZWN0ZWQ9XCIwXCI+XG4gICAgICAgIDxkaXY+SXRlbSAxPC9kaXY+XG4gICAgICAgIDxkaXY+SXRlbSAyPC9kaXY+XG4gICAgICAgIDxkaXY+SXRlbSAzPC9kaXY+XG4gICAgICA8L2lyb24tc2VsZWN0b3I+XG5cbiAgQGRlbW8gZGVtby9pbmRleC5odG1sXG4gICovXG5cbiAgUG9seW1lcih7XG5cbiAgICBpczogJ2lyb24tc2VsZWN0b3InLFxuXG4gICAgYmVoYXZpb3JzOiBbXG4gICAgICBQb2x5bWVyLklyb25NdWx0aVNlbGVjdGFibGVCZWhhdmlvclxuICAgIF1cblxuICB9KTtcblxuPC9zY3JpcHQ+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL2lyb24tc2VsZWN0b3IvaXJvbi1zZWxlY3Rvci5odG1sIiwiPCEtLVxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNSBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbi0tPlxuXG48bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiLi4vcG9seW1lci9wb2x5bWVyLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCJpcm9uLXNlbGVjdGFibGUuaHRtbFwiPlxuXG48c2NyaXB0PlxuICAvKipcbiAgICogQHBvbHltZXJCZWhhdmlvciBQb2x5bWVyLklyb25NdWx0aVNlbGVjdGFibGVCZWhhdmlvclxuICAgKi9cbiAgUG9seW1lci5Jcm9uTXVsdGlTZWxlY3RhYmxlQmVoYXZpb3JJbXBsID0ge1xuICAgIHByb3BlcnRpZXM6IHtcblxuICAgICAgLyoqXG4gICAgICAgKiBJZiB0cnVlLCBtdWx0aXBsZSBzZWxlY3Rpb25zIGFyZSBhbGxvd2VkLlxuICAgICAgICovXG4gICAgICBtdWx0aToge1xuICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICB2YWx1ZTogZmFsc2UsXG4gICAgICAgIG9ic2VydmVyOiAnbXVsdGlDaGFuZ2VkJ1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIHNlbGVjdGVkIGVsZW1lbnRzLiBUaGlzIGlzIHVzZWQgaW5zdGVhZCBvZiBgc2VsZWN0ZWRgIHdoZW4gYG11bHRpYFxuICAgICAgICogaXMgdHJ1ZS5cbiAgICAgICAqL1xuICAgICAgc2VsZWN0ZWRWYWx1ZXM6IHtcbiAgICAgICAgdHlwZTogQXJyYXksXG4gICAgICAgIG5vdGlmeTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIGN1cnJlbnRseSBzZWxlY3RlZCBpdGVtcy5cbiAgICAgICAqL1xuICAgICAgc2VsZWN0ZWRJdGVtczoge1xuICAgICAgICB0eXBlOiBBcnJheSxcbiAgICAgICAgcmVhZE9ubHk6IHRydWUsXG4gICAgICAgIG5vdGlmeTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgIH0sXG5cbiAgICBvYnNlcnZlcnM6IFtcbiAgICAgICdfdXBkYXRlU2VsZWN0ZWQoc2VsZWN0ZWRWYWx1ZXMuc3BsaWNlcyknXG4gICAgXSxcblxuICAgIC8qKlxuICAgICAqIFNlbGVjdHMgdGhlIGdpdmVuIHZhbHVlLiBJZiB0aGUgYG11bHRpYCBwcm9wZXJ0eSBpcyB0cnVlLCB0aGVuIHRoZSBzZWxlY3RlZCBzdGF0ZSBvZiB0aGVcbiAgICAgKiBgdmFsdWVgIHdpbGwgYmUgdG9nZ2xlZDsgb3RoZXJ3aXNlIHRoZSBgdmFsdWVgIHdpbGwgYmUgc2VsZWN0ZWQuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHNlbGVjdFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gdmFsdWUgdGhlIHZhbHVlIHRvIHNlbGVjdC5cbiAgICAgKi9cbiAgICBzZWxlY3Q6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICBpZiAodGhpcy5tdWx0aSkge1xuICAgICAgICB0aGlzLl90b2dnbGVTZWxlY3RlZCh2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNlbGVjdGVkID0gdmFsdWU7XG4gICAgICB9XG4gICAgfSxcblxuICAgIG11bHRpQ2hhbmdlZDogZnVuY3Rpb24obXVsdGkpIHtcbiAgICAgIHRoaXMuX3NlbGVjdGlvbi5tdWx0aSA9IG11bHRpO1xuICAgICAgdGhpcy5fdXBkYXRlU2VsZWN0ZWQoKTtcbiAgICB9LFxuXG4gICAgLy8gVU5VU0VELCBGT1IgQVBJIENPTVBBVElCSUxJVFlcbiAgICBnZXQgX3Nob3VsZFVwZGF0ZVNlbGVjdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnNlbGVjdGVkICE9IG51bGwgfHxcbiAgICAgICAgKHRoaXMuc2VsZWN0ZWRWYWx1ZXMgIT0gbnVsbCAmJiB0aGlzLnNlbGVjdGVkVmFsdWVzLmxlbmd0aCk7XG4gICAgfSxcblxuICAgIF91cGRhdGVBdHRyRm9yU2VsZWN0ZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLm11bHRpKSB7XG4gICAgICAgIFBvbHltZXIuSXJvblNlbGVjdGFibGVCZWhhdmlvci5fdXBkYXRlQXR0ckZvclNlbGVjdGVkLmFwcGx5KHRoaXMpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnNlbGVjdGVkSXRlbXMgJiYgdGhpcy5zZWxlY3RlZEl0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy5zZWxlY3RlZFZhbHVlcyA9IHRoaXMuc2VsZWN0ZWRJdGVtcy5tYXAoZnVuY3Rpb24oc2VsZWN0ZWRJdGVtKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2luZGV4VG9WYWx1ZSh0aGlzLmluZGV4T2Yoc2VsZWN0ZWRJdGVtKSk7XG4gICAgICAgIH0sIHRoaXMpLmZpbHRlcihmdW5jdGlvbih1bmZpbHRlcmVkVmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gdW5maWx0ZXJlZFZhbHVlICE9IG51bGw7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBfdXBkYXRlU2VsZWN0ZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMubXVsdGkpIHtcbiAgICAgICAgdGhpcy5fc2VsZWN0TXVsdGkodGhpcy5zZWxlY3RlZFZhbHVlcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9zZWxlY3RTZWxlY3RlZCh0aGlzLnNlbGVjdGVkKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgX3NlbGVjdE11bHRpOiBmdW5jdGlvbih2YWx1ZXMpIHtcbiAgICAgIHZhbHVlcyA9IHZhbHVlcyB8fCBbXTtcblxuICAgICAgdmFyIHNlbGVjdGVkSXRlbXMgPSAodGhpcy5fdmFsdWVzVG9JdGVtcyh2YWx1ZXMpIHx8IFtdKS5maWx0ZXIoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICByZXR1cm4gaXRlbSAhPT0gbnVsbCAmJiBpdGVtICE9PSB1bmRlZmluZWQ7XG4gICAgICB9KTtcblxuICAgICAgLy8gY2xlYXIgYWxsIGJ1dCB0aGUgY3VycmVudCBzZWxlY3RlZCBpdGVtc1xuICAgICAgdGhpcy5fc2VsZWN0aW9uLmNsZWFyKHNlbGVjdGVkSXRlbXMpO1xuXG4gICAgICAvLyBzZWxlY3Qgb25seSB0aG9zZSBub3Qgc2VsZWN0ZWQgeWV0XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGVjdGVkSXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5fc2VsZWN0aW9uLnNldEl0ZW1TZWxlY3RlZChzZWxlY3RlZEl0ZW1zW2ldLCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgZm9yIGl0ZW1zLCBzaW5jZSB0aGlzIGFycmF5IGlzIHBvcHVsYXRlZCBvbmx5IHdoZW4gYXR0YWNoZWRcbiAgICAgIGlmICh0aGlzLmZhbGxiYWNrU2VsZWN0aW9uICYmICF0aGlzLl9zZWxlY3Rpb24uZ2V0KCkubGVuZ3RoKSB7XG4gICAgICAgIHZhciBmYWxsYmFjayA9IHRoaXMuX3ZhbHVlVG9JdGVtKHRoaXMuZmFsbGJhY2tTZWxlY3Rpb24pO1xuICAgICAgICBpZiAoZmFsbGJhY2spIHtcbiAgICAgICAgICB0aGlzLnNlbGVjdCh0aGlzLmZhbGxiYWNrU2VsZWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBfc2VsZWN0aW9uQ2hhbmdlOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzID0gdGhpcy5fc2VsZWN0aW9uLmdldCgpO1xuICAgICAgaWYgKHRoaXMubXVsdGkpIHtcbiAgICAgICAgdGhpcy5fc2V0U2VsZWN0ZWRJdGVtcyhzKTtcbiAgICAgICAgdGhpcy5fc2V0U2VsZWN0ZWRJdGVtKHMubGVuZ3RoID8gc1swXSA6IG51bGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHMgIT09IG51bGwgJiYgcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5fc2V0U2VsZWN0ZWRJdGVtcyhbc10pO1xuICAgICAgICAgIHRoaXMuX3NldFNlbGVjdGVkSXRlbShzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9zZXRTZWxlY3RlZEl0ZW1zKFtdKTtcbiAgICAgICAgICB0aGlzLl9zZXRTZWxlY3RlZEl0ZW0obnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgX3RvZ2dsZVNlbGVjdGVkOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgdmFyIGkgPSB0aGlzLnNlbGVjdGVkVmFsdWVzLmluZGV4T2YodmFsdWUpO1xuICAgICAgdmFyIHVuc2VsZWN0ZWQgPSBpIDwgMDtcbiAgICAgIGlmICh1bnNlbGVjdGVkKSB7XG4gICAgICAgIHRoaXMucHVzaCgnc2VsZWN0ZWRWYWx1ZXMnLHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc3BsaWNlKCdzZWxlY3RlZFZhbHVlcycsaSwxKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgX3ZhbHVlc1RvSXRlbXM6IGZ1bmN0aW9uKHZhbHVlcykge1xuICAgICAgcmV0dXJuICh2YWx1ZXMgPT0gbnVsbCkgPyBudWxsIDogdmFsdWVzLm1hcChmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWVUb0l0ZW0odmFsdWUpO1xuICAgICAgfSwgdGhpcyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKiBAcG9seW1lckJlaGF2aW9yICovXG4gIFBvbHltZXIuSXJvbk11bHRpU2VsZWN0YWJsZUJlaGF2aW9yID0gW1xuICAgIFBvbHltZXIuSXJvblNlbGVjdGFibGVCZWhhdmlvcixcbiAgICBQb2x5bWVyLklyb25NdWx0aVNlbGVjdGFibGVCZWhhdmlvckltcGxcbiAgXTtcblxuPC9zY3JpcHQ+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL2lyb24tc2VsZWN0b3IvaXJvbi1tdWx0aS1zZWxlY3RhYmxlLmh0bWwiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE1IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi9wb2x5bWVyL3BvbHltZXIuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL2lyb24tYmVoYXZpb3JzL2lyb24tYnV0dG9uLXN0YXRlLmh0bWxcIj5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCJwYXBlci1yaXBwbGUtYmVoYXZpb3IuaHRtbFwiPlxuXG48c2NyaXB0PlxuICAvKipcbiAgICogYFBvbHltZXIuUGFwZXJJbmt5Rm9jdXNCZWhhdmlvcmAgaW1wbGVtZW50cyBhIHJpcHBsZSB3aGVuIHRoZSBlbGVtZW50IGhhcyBrZXlib2FyZCBmb2N1cy5cbiAgICpcbiAgICogQHBvbHltZXJCZWhhdmlvciBQb2x5bWVyLlBhcGVySW5reUZvY3VzQmVoYXZpb3JcbiAgICovXG4gIFBvbHltZXIuUGFwZXJJbmt5Rm9jdXNCZWhhdmlvckltcGwgPSB7XG4gICAgb2JzZXJ2ZXJzOiBbXG4gICAgICAnX2ZvY3VzZWRDaGFuZ2VkKHJlY2VpdmVkRm9jdXNGcm9tS2V5Ym9hcmQpJ1xuICAgIF0sXG5cbiAgICBfZm9jdXNlZENoYW5nZWQ6IGZ1bmN0aW9uKHJlY2VpdmVkRm9jdXNGcm9tS2V5Ym9hcmQpIHtcbiAgICAgIGlmIChyZWNlaXZlZEZvY3VzRnJvbUtleWJvYXJkKSB7XG4gICAgICAgIHRoaXMuZW5zdXJlUmlwcGxlKCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5oYXNSaXBwbGUoKSkge1xuICAgICAgICB0aGlzLl9yaXBwbGUuaG9sZERvd24gPSByZWNlaXZlZEZvY3VzRnJvbUtleWJvYXJkO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBfY3JlYXRlUmlwcGxlOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciByaXBwbGUgPSBQb2x5bWVyLlBhcGVyUmlwcGxlQmVoYXZpb3IuX2NyZWF0ZVJpcHBsZSgpO1xuICAgICAgcmlwcGxlLmlkID0gJ2luayc7XG4gICAgICByaXBwbGUuc2V0QXR0cmlidXRlKCdjZW50ZXInLCAnJyk7XG4gICAgICByaXBwbGUuY2xhc3NMaXN0LmFkZCgnY2lyY2xlJyk7XG4gICAgICByZXR1cm4gcmlwcGxlO1xuICAgIH1cbiAgfTtcblxuICAvKiogQHBvbHltZXJCZWhhdmlvciBQb2x5bWVyLlBhcGVySW5reUZvY3VzQmVoYXZpb3IgKi9cbiAgUG9seW1lci5QYXBlcklua3lGb2N1c0JlaGF2aW9yID0gW1xuICAgIFBvbHltZXIuSXJvbkJ1dHRvblN0YXRlLFxuICAgIFBvbHltZXIuSXJvbkNvbnRyb2xTdGF0ZSxcbiAgICBQb2x5bWVyLlBhcGVyUmlwcGxlQmVoYXZpb3IsXG4gICAgUG9seW1lci5QYXBlcklua3lGb2N1c0JlaGF2aW9ySW1wbFxuICBdO1xuPC9zY3JpcHQ+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL3BhcGVyLWJlaGF2aW9ycy9wYXBlci1pbmt5LWZvY3VzLWJlaGF2aW9yLmh0bWwiLCI8IS0tXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE1IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuLS0+XG5cbjxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCIuLi9wb2x5bWVyL3BvbHltZXIuaHRtbFwiPlxuPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cIi4uL3BhcGVyLXJpcHBsZS9wYXBlci1yaXBwbGUuaHRtbFwiPlxuXG48c2NyaXB0PlxuICAvKipcbiAgICogYFBvbHltZXIuUGFwZXJSaXBwbGVCZWhhdmlvcmAgZHluYW1pY2FsbHkgaW1wbGVtZW50cyBhIHJpcHBsZVxuICAgKiB3aGVuIHRoZSBlbGVtZW50IGhhcyBmb2N1cyB2aWEgcG9pbnRlciBvciBrZXlib2FyZC5cbiAgICpcbiAgICogTk9URTogVGhpcyBiZWhhdmlvciBpcyBpbnRlbmRlZCB0byBiZSB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggYW5kIGFmdGVyXG4gICAqIGBQb2x5bWVyLklyb25CdXR0b25TdGF0ZWAgYW5kIGBQb2x5bWVyLklyb25Db250cm9sU3RhdGVgLlxuICAgKlxuICAgKiBAcG9seW1lckJlaGF2aW9yIFBvbHltZXIuUGFwZXJSaXBwbGVCZWhhdmlvclxuICAgKi9cbiAgUG9seW1lci5QYXBlclJpcHBsZUJlaGF2aW9yID0ge1xuICAgIHByb3BlcnRpZXM6IHtcbiAgICAgIC8qKlxuICAgICAgICogSWYgdHJ1ZSwgdGhlIGVsZW1lbnQgd2lsbCBub3QgcHJvZHVjZSBhIHJpcHBsZSBlZmZlY3Qgd2hlbiBpbnRlcmFjdGVkXG4gICAgICAgKiB3aXRoIHZpYSB0aGUgcG9pbnRlci5cbiAgICAgICAqL1xuICAgICAgbm9pbms6IHtcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgb2JzZXJ2ZXI6ICdfbm9pbmtDaGFuZ2VkJ1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBAdHlwZSB7RWxlbWVudHx1bmRlZmluZWR9XG4gICAgICAgKi9cbiAgICAgIF9yaXBwbGVDb250YWluZXI6IHtcbiAgICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBFbnN1cmVzIGEgYDxwYXBlci1yaXBwbGU+YCBlbGVtZW50IGlzIGF2YWlsYWJsZSB3aGVuIHRoZSBlbGVtZW50IGlzXG4gICAgICogZm9jdXNlZC5cbiAgICAgKi9cbiAgICBfYnV0dG9uU3RhdGVDaGFuZ2VkOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmZvY3VzZWQpIHtcbiAgICAgICAgdGhpcy5lbnN1cmVSaXBwbGUoKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW4gYWRkaXRpb24gdG8gdGhlIGZ1bmN0aW9uYWxpdHkgcHJvdmlkZWQgaW4gYElyb25CdXR0b25TdGF0ZWAsIGVuc3VyZXNcbiAgICAgKiBhIHJpcHBsZSBlZmZlY3QgaXMgY3JlYXRlZCB3aGVuIHRoZSBlbGVtZW50IGlzIGluIGEgYHByZXNzZWRgIHN0YXRlLlxuICAgICAqL1xuICAgIF9kb3duSGFuZGxlcjogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIFBvbHltZXIuSXJvbkJ1dHRvblN0YXRlSW1wbC5fZG93bkhhbmRsZXIuY2FsbCh0aGlzLCBldmVudCk7XG4gICAgICBpZiAodGhpcy5wcmVzc2VkKSB7XG4gICAgICAgIHRoaXMuZW5zdXJlUmlwcGxlKGV2ZW50KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRW5zdXJlcyB0aGlzIGVsZW1lbnQgY29udGFpbnMgYSByaXBwbGUgZWZmZWN0LiBGb3Igc3RhcnR1cCBlZmZpY2llbmN5XG4gICAgICogdGhlIHJpcHBsZSBlZmZlY3QgaXMgZHluYW1pY2FsbHkgb24gZGVtYW5kIHdoZW4gbmVlZGVkLlxuICAgICAqIEBwYXJhbSB7IUV2ZW50PX0gb3B0VHJpZ2dlcmluZ0V2ZW50IChvcHRpb25hbCkgZXZlbnQgdGhhdCB0cmlnZ2VyZWQgdGhlXG4gICAgICogcmlwcGxlLlxuICAgICAqL1xuICAgIGVuc3VyZVJpcHBsZTogZnVuY3Rpb24ob3B0VHJpZ2dlcmluZ0V2ZW50KSB7XG4gICAgICBpZiAoIXRoaXMuaGFzUmlwcGxlKCkpIHtcbiAgICAgICAgdGhpcy5fcmlwcGxlID0gdGhpcy5fY3JlYXRlUmlwcGxlKCk7XG4gICAgICAgIHRoaXMuX3JpcHBsZS5ub2luayA9IHRoaXMubm9pbms7XG4gICAgICAgIHZhciByaXBwbGVDb250YWluZXIgPSB0aGlzLl9yaXBwbGVDb250YWluZXIgfHwgdGhpcy5yb290O1xuICAgICAgICBpZiAocmlwcGxlQ29udGFpbmVyKSB7XG4gICAgICAgICAgUG9seW1lci5kb20ocmlwcGxlQ29udGFpbmVyKS5hcHBlbmRDaGlsZCh0aGlzLl9yaXBwbGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRUcmlnZ2VyaW5nRXZlbnQpIHtcbiAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgZXZlbnQgaGFwcGVuZWQgaW5zaWRlIG9mIHRoZSByaXBwbGUgY29udGFpbmVyXG4gICAgICAgICAgLy8gRmFsbCBiYWNrIHRvIGhvc3QgaW5zdGVhZCBvZiB0aGUgcm9vdCBiZWNhdXNlIGRpc3RyaWJ1dGVkIHRleHRcbiAgICAgICAgICAvLyBub2RlcyBhcmUgbm90IHZhbGlkIGV2ZW50IHRhcmdldHNcbiAgICAgICAgICB2YXIgZG9tQ29udGFpbmVyID0gUG9seW1lci5kb20odGhpcy5fcmlwcGxlQ29udGFpbmVyIHx8IHRoaXMpO1xuICAgICAgICAgIHZhciB0YXJnZXQgPSBQb2x5bWVyLmRvbShvcHRUcmlnZ2VyaW5nRXZlbnQpLnJvb3RUYXJnZXQ7XG4gICAgICAgICAgaWYgKGRvbUNvbnRhaW5lci5kZWVwQ29udGFpbnMoIC8qKiBAdHlwZSB7Tm9kZX0gKi8odGFyZ2V0KSkpIHtcbiAgICAgICAgICAgIHRoaXMuX3JpcHBsZS51aURvd25BY3Rpb24ob3B0VHJpZ2dlcmluZ0V2ZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYDxwYXBlci1yaXBwbGU+YCBlbGVtZW50IHVzZWQgYnkgdGhpcyBlbGVtZW50IHRvIGNyZWF0ZVxuICAgICAqIHJpcHBsZSBlZmZlY3RzLiBUaGUgZWxlbWVudCdzIHJpcHBsZSBpcyBjcmVhdGVkIG9uIGRlbWFuZCwgd2hlblxuICAgICAqIG5lY2Vzc2FyeSwgYW5kIGNhbGxpbmcgdGhpcyBtZXRob2Qgd2lsbCBmb3JjZSB0aGVcbiAgICAgKiByaXBwbGUgdG8gYmUgY3JlYXRlZC5cbiAgICAgKi9cbiAgICBnZXRSaXBwbGU6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5lbnN1cmVSaXBwbGUoKTtcbiAgICAgIHJldHVybiB0aGlzLl9yaXBwbGU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIGVsZW1lbnQgY3VycmVudGx5IGNvbnRhaW5zIGEgcmlwcGxlIGVmZmVjdC5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuICAgIGhhc1JpcHBsZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gQm9vbGVhbih0aGlzLl9yaXBwbGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgdGhlIGVsZW1lbnQncyByaXBwbGUgZWZmZWN0IHZpYSBjcmVhdGluZyBhIGA8cGFwZXItcmlwcGxlPmAuXG4gICAgICogT3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gY3VzdG9taXplIHRoZSByaXBwbGUgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJuIHshUGFwZXJSaXBwbGVFbGVtZW50fSBSZXR1cm5zIGEgYDxwYXBlci1yaXBwbGU+YCBlbGVtZW50LlxuICAgICAqL1xuICAgIF9jcmVhdGVSaXBwbGU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIC8qKiBAdHlwZSB7IVBhcGVyUmlwcGxlRWxlbWVudH0gKi8gKFxuICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3BhcGVyLXJpcHBsZScpKTtcbiAgICB9LFxuXG4gICAgX25vaW5rQ2hhbmdlZDogZnVuY3Rpb24obm9pbmspIHtcbiAgICAgIGlmICh0aGlzLmhhc1JpcHBsZSgpKSB7XG4gICAgICAgIHRoaXMuX3JpcHBsZS5ub2luayA9IG5vaW5rO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbjwvc2NyaXB0PlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYm93ZXJfY29tcG9uZW50cy9wYXBlci1iZWhhdmlvcnMvcGFwZXItcmlwcGxlLWJlaGF2aW9yLmh0bWwiLCJcbnJlcXVpcmUoJy4uL2Jvd2VyX2NvbXBvbmVudHMvaXJvbi1pY29uc2V0LXN2Zy9pcm9uLWljb25zZXQtc3ZnLmh0bWwnKTtcblxuY29uc3QgUmVnaXN0ZXJIdG1sVGVtcGxhdGUgPSByZXF1aXJlKCdwb2x5bWVyLXdlYnBhY2stbG9hZGVyL3JlZ2lzdGVyLWh0bWwtdGVtcGxhdGUnKTtcblxuUmVnaXN0ZXJIdG1sVGVtcGxhdGUudG9Cb2R5KFwiPGlyb24taWNvbnNldC1zdmcgbmFtZT1teS1pY29ucyBzaXplPTI0PiA8c3ZnPiA8ZGVmcz4gPGcgaWQ9YXJyb3ctYmFjaz4gPHBhdGggZD1cXFwiTTIwIDExSDcuODNsNS41OS01LjU5TDEyIDRsLTggOCA4IDggMS40MS0xLjQxTDcuODMgMTNIMjB2LTJ6XFxcIj48L3BhdGg+IDwvZz4gPGcgaWQ9bWVudT4gPHBhdGggZD1cXFwiTTMgMThoMTh2LTJIM3Yyem0wLTVoMTh2LTJIM3Yyem0wLTd2MmgxOFY2SDN6XFxcIj48L3BhdGg+IDwvZz4gPGcgaWQ9Y2hldnJvbi1yaWdodD4gPHBhdGggZD1cXFwiTTEwIDZMOC41OSA3LjQxIDEzLjE3IDEybC00LjU4IDQuNTlMMTAgMThsNi02elxcXCI+PC9wYXRoPiA8L2c+IDxnIGlkPWNsb3NlPiA8cGF0aCBkPVxcXCJNMTkgNi40MUwxNy41OSA1IDEyIDEwLjU5IDYuNDEgNSA1IDYuNDEgMTAuNTkgMTIgNSAxNy41OSA2LjQxIDE5IDEyIDEzLjQxIDE3LjU5IDE5IDE5IDE3LjU5IDEzLjQxIDEyelxcXCI+PC9wYXRoPiA8L2c+IDxnIGlkPXNlYXJjaD48cGF0aCBkPVxcXCJNMTUuNSAxNGgtLjc5bC0uMjgtLjI3QzE1LjQxIDEyLjU5IDE2IDExLjExIDE2IDkuNSAxNiA1LjkxIDEzLjA5IDMgOS41IDNTMyA1LjkxIDMgOS41IDUuOTEgMTYgOS41IDE2YzEuNjEgMCAzLjA5LS41OSA0LjIzLTEuNTdsLjI3LjI4di43OWw1IDQuOTlMMjAuNDkgMTlsLTQuOTktNXptLTYgMEM3LjAxIDE0IDUgMTEuOTkgNSA5LjVTNy4wMSA1IDkuNSA1IDE0IDcuMDEgMTQgOS41IDExLjk5IDE0IDkuNSAxNHpcXFwiPjwvcGF0aD4gPC9nPiA8L2RlZnM+IDwvc3ZnPiA8L2lyb24taWNvbnNldC1zdmc+XCIpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL215LWljb25zLmh0bWwiXSwic291cmNlUm9vdCI6IiJ9